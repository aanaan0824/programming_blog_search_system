{"blogid": "126665826", "writerAge": "码龄9年", "writerBlogNum": "41", "writerCollect": "53", "writerComment": "10", "writerFan": "8", "writerGrade": "3级", "writerIntegral": "504", "writerName": "broadview_java", "writerProfileAdress": "writer_image\\profile_126665826.jpg", "writerRankTotal": "33595", "writerRankWeekly": "12859", "writerThumb": "61", "writerVisitNum": "54077", "blog_read_count": "328", "blog_time": "已于 2022-09-02 20:16:14 修改", "blog_title": "Android 动态更新Menu菜单", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h1>1. 需求描述</h1>\n<p>        Android Menu菜单是比较常见的功能，在ActionBar  or ToolBar上显示，点击更多(3个点)，会有下拉列表菜单展示,  在工作项目中有个小需求改动: 在 ToolBar上添加一个图标，点击后会切换图标状态，界面也会显示对应内容，这也是本篇文章要讲的是如何动态更新Menu菜单。</p>\n<p>        首先，我们来看看效果图:</p>\n<p>1. 当点击网格图标时，显示为网格模式</p>\n<p class=\"img-center\"><img alt=\"\" height=\"270\" src=\"image\\fc8731de900b4f0da4fba032de7b0066.png\" width=\"450\"/></p>\n<p> 2. 当点击列表图标时，显示为列表模式</p>\n<p class=\"img-center\"><img alt=\"\" height=\"273\" src=\"image\\64a56b1068ac4acc8c6426f2f969d5d2.png\" width=\"450\"/></p>\n<p> 3. 点击更多图标时，显示更多菜单列表：设置   关于  测试</p>\n<p class=\"img-center\"><img alt=\"\" height=\"271\" src=\"image\\d9566f7004b34d3293b85d7a461a52d3.png\" width=\"450\"/></p>\n<p></p>\n<h1>2. 基础知识</h1>\n<p>        在写代码之前，先来复习一下Menu的基础知识，具体可以看官方文档：<a href=\"https://developer.android.google.cn/develop/ui/views/components/menus\" title=\"Menus  |  Android Developers\">Menus  |  Android Developers</a></p>\n<p>菜单xml编写例子：</p>\n<pre><code>&lt;menu xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    tools:context=\"com.example.menutest.MainActivity\"&gt;\n\n    &lt;item\n        android:id=\"@+id/sub_menu_grid\"\n        android:title=\"网格视图\"\n        android:icon=\"@drawable/ic_menu_view_grid\"\n        app:showAsAction=\"always\"/&gt;\n    &lt;item\n        android:id=\"@+id/sub_menu_list\"\n        android:title=\"列表视图\"\n        android:icon=\"@drawable/ic_menu_view_list\"\n        app:showAsAction=\"always\"/&gt;\n\n    &lt;item\n        android:id=\"@+id/action_settings\"\n        android:orderInCategory=\"100\"\n        android:title=\"设置\"\n        app:showAsAction=\"never\" /&gt;\n\n    &lt;item\n        android:id=\"@+id/action_about\"\n        android:orderInCategory=\"200\"\n        android:title=\"关于\"\n        app:showAsAction=\"never\" /&gt;\n\n    &lt;item\n        android:id=\"@+id/action_test\"\n        android:orderInCategory=\"300\"\n        android:title=\"测试\"\n        app:showAsAction=\"never\" /&gt;\n\n&lt;/menu&gt;</code></pre>\n<p><strong>&lt;item&gt;</strong>是我们主要需要关注的元素，它的常见属性如下：</p>\n<p>    <strong>android:id</strong>：     菜单项(MenuItem)的唯一标识（必须定义）<br/>     <strong>android:icon</strong>： 菜单项的图标（可选）<br/>     <strong>android:title</strong>： 菜单项的标题（必选）<br/>     <strong>android:showAsAction</strong>：指定菜单项的显示方式。常用的有ifRoom、never、always、withText，多个属性值之间可以使用|隔开。</p>\n<p><strong>指定菜单的显示方式：</strong></p>\n<p><code>always</code>：菜单项永远不会被收纳到溢出菜单中，因此在菜单项过多的情况下可能超出菜单栏的显示范围。</p>\n<p><code>ifRoom</code>：在空间足够时，菜单项会显示在菜单栏中，否则收纳入溢出菜单中。</p>\n<p><code>withText</code>：无论菜单项是否定义了<code>icon</code>属性，都只会显示它的标题，而不会显示图标。使用这种方式的菜单项默认会被收纳入溢出菜单中。</p>\n<p><code>never</code>：菜单项永远只会出现在溢出菜单中。</p>\n<p></p>\n<p>我们通过上面的3张图片，在Toolbar上面显示有两类菜单：</p>\n<p>1. 比如网格和列表菜单，在菜单栏上定义为一直显示（<code>always</code>），我们称它为<strong>常驻菜单</strong></p>\n<p>2. 另一种会被集中放置到<strong>溢出菜单</strong>中（就是菜单栏右侧的3个小点图标图标）</p>\n<p></p>\n<p></p>\n<h1>3. 菜单加载</h1>\n<p>        菜单加载，有两个相关API </p>\n<p>  1.  onCreateOptionsMenu（Menu menu）</p>\n<p>      此方法在初次加载菜单时，会调用一次。</p>\n<p>2.  onPrepareOptionsMenu（Menu menu）</p>\n<p>      此方法应用场景：在运行时更改菜单项，我们看看官网的描述：</p>\n<p><strong>在运行时修改的选项菜单：</strong></p>\n<p>系统调用onCreateOptionsMenu方法后，将保留创建的Menu实例。除非菜单由于某些原因而失效，否则不会再次调用onCreateOptionsMenu。因此，我们只应该使用onCreateOptionsMenu来创建初始菜单状态，而不应使用它在Activity生命周期中对菜单执行任何更改。</p>\n<p>如果需要根据在Activity生命周期中发生的某些事件修改选项菜单，则应该通过onPrepareOptionsMenu方法实现。这个方法的参数中有一个Menu对象（即旧的Menu对象），我们可以使用它对菜单执行修改，如添加、移除、启用或禁用菜单项。（Fragment同样提供onPrepareOptionsMenu方法，只是不需要提供返回值）</p>\n<p><strong>需要注意：</strong>在Android 3.0及更高版本中，当菜单项显示在应用栏中时，选项菜单被视为始终处于打开状态,说的就是常驻菜单。<strong>发生事件时，如果要执行菜单更新，则必须调用 invalidateOptionsMenu来请求系统调用onPrepareOptionsMenu方法</strong>。</p>\n<p>对于上句话我的理解如下：</p>\n<p>1. 对于<strong>常驻菜单</strong>，如果你想动态修改菜单的话，就必须调用 invalidateOptionsMenu() 方法去更新,为什么呢? 因为调用 invalidateOptionsMenu方法后，会重新执行一遍 onCreateOptionsMenu 和 onPrepareOptionsMenu这两个方法。</p>\n<p>2. 对于<strong>溢出菜单，</strong>如果你想动态修改菜单的话，只需要在onPrepareOptionsMenu方法中实现即可，为什么呢？</p>\n<p>    当你点击 更多（3个小点）图标的时候，就会回调onPrepareOptionsMenu方法</p>\n<p></p>\n<p></p>\n<h1>4. 需求实现</h1>\n<p>        有了上面理论做支持，具体结合需求，网格和列表菜单属于常驻菜单，所以必须先要调用invalidateOptionsMenu()方法，然后在onPrepareOptionsMenu去写动态更新状态的代码</p>\n<p>       图三中，关于属于溢出菜单，需求：<strong> 关于</strong> 菜单不能点击，所以也是在onPrepareOptionsMenu中去写动态更新状态的代码</p>\n<p></p>\n<p>好了，我把代码展示出来：</p>\n<pre><code>public class MainActivity extends AppCompatActivity {\n\n    //默认为网格模式\n    private boolean isShowGridModeIcon = true;\n\n    //网格菜单 和 列表菜单\n    private MenuItem gridMenuItem;\n    private MenuItem listMenuItem;\n\n    //用字符串来表示当前的文件列表显示模式\n    private TextView viewModeStatus;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        Toolbar toolbar = findViewById(R.id.toolbar);\n        setSupportActionBar(toolbar);\n\n        viewModeStatus = findViewById(R.id.textview_refresh);\n\n    }\n\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        // Inflate the menu; this adds items to the action bar if it is present.\n        getMenuInflater().inflate(R.menu.menu_main, menu);\n        Log.e(\"test\", \"=====MenuTest onCreateOptionsMenu=====\");\n\n        gridMenuItem = menu.findItem(R.id.sub_menu_grid);\n        listMenuItem = menu.findItem(R.id.sub_menu_list);\n        return true;\n    }\n\n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu) {\n        Log.e(\"test\", \"=====MenuTest onPrepareOptionsMenu=xxxx====\");\n        MenuItem aboutMenuItem = menu.findItem(R.id.action_about);\n\n        // （3个点）【更多】菜单中把 关于 设置为不可点击\n        aboutMenuItem.setEnabled(false);\n\n        if (isShowGridModeIcon) {\n            gridMenuItem.setVisible(true);\n            listMenuItem.setVisible(false);\n            viewModeStatus.setText(\"当前为网格模式\");\n        } else {\n            gridMenuItem.setVisible(false);\n            listMenuItem.setVisible(true);\n            viewModeStatus.setText(\"当前为列表模式\");\n        }\n        return super.onPrepareOptionsMenu(menu);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        // Handle action bar item clicks here. The action bar will\n        // automatically handle clicks on the Home/Up button, so long\n        // as you specify a parent activity in AndroidManifest.xml.\n        int id = item.getItemId();\n        Log.e(\"test\", \"=====MenuTest onOptionsItemSelected= sssss ====\");\n        //noinspection SimplifiableIfStatement\n        if (id == R.id.action_settings) {\n            return true;\n        } else if (id == R.id.sub_menu_grid) {\n          /*1. 点击网格图标，界面中文件布局显示变成网格模式*/\n          //伪代码：setViewMode(State.MODE_GRID);\n            isShowGridModeIcon = false;\n          /*2. 图标变成切换list图标*/\n            invalidateOptionsMenu();\n\n        } else if (id == R.id.sub_menu_list) {\n            /*1.点击列表图标，界面中文件布局显示变成列表模式*/\n            //伪代码：setViewMode(State.MODE_LIST);\n            isShowGridModeIcon = true;\n            /*2. 图标变成切换grid图标*/\n            invalidateOptionsMenu();\n        }\n\n        return super.onOptionsItemSelected(item);\n    }\n}</code></pre>\n<p></p>\n<p>代码中加了打印log<br/> 1.  在桌面上启动apk的时候，打印log如下：</p>\n<pre><code>21900 21900 E test    : =====MenuTest onCreateOptionsMenu=====\n21900 21900 E test    : =====MenuTest onPrepareOptionsMenu=xxxx====\n</code></pre>\n<p></p>\n<p>2. 点击网格模式菜单时，打印log如下：</p>\n<pre><code>21900 21900 E test    : =====MenuTest onOptionsItemSelected= sssss ====\n21900 21900 E test    : =====MenuTest onCreateOptionsMenu=====\n21900 21900 E test    : =====MenuTest onPrepareOptionsMenu=xxxx====</code></pre>\n<p>    如上分析，在onOptionsItemSelected方法中点击响应时，调用了invalidateOptionsMenu方法，所以会重新走一遍onCreateOptionsMenu， onPrepareOptionsMenu。</p>\n<p>3. 点击（3个点）更多菜单时，打印log如下：</p>\n<pre><code>21900 21900 E test    : =====MenuTest onPrepareOptionsMenu=xxxx====\n</code></pre>\n<p>     如上分析， 对于溢出菜单类型，点击更多菜单时，只会回调onPrepareOptionsMenu方法</p>\n<p></p>\n<h1>5. 总结</h1>\n<p>        本篇文章讲解了动态菜单更新显示的过程，也是对menu菜单的一个小结，对于同类需求，可以仿照此demo，整个Demo代码我上传到这里:<a href=\"https://download.csdn.net/download/u012514113/86507389?spm=1001.2014.3001.5503\" title=\"Android动态更新Menu菜单-Android文档类资源-CSDN下载\">Android动态更新Menu菜单-Android文档类资源-CSDN下载</a></p>\n</div>\n</div>"}