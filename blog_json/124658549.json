{"blogid": "124658549", "writerAge": "码龄1年", "writerBlogNum": "48", "writerCollect": "311", "writerComment": "15", "writerFan": "31", "writerGrade": "3级", "writerIntegral": "593", "writerName": "一只路过的菜鸟", "writerProfileAdress": "writer_image\\profile_124658549.jpg", "writerRankTotal": "32832", "writerRankWeekly": "26809", "writerThumb": "52", "writerVisitNum": "51736", "blog_read_count": "11763", "blog_time": "已于 2022-09-06 15:23:57 修改", "blog_title": "js十五道面试题（含答案）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p></p>\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"1.%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E-toc\" style=\"margin-left:40px;\"><a href=\"#1.%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E\">1.线程和进程是什么？举例说明</a></p>\n<p id=\"2.%20js%E4%B8%AD%E7%9A%84%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%3F%20%E4%BA%86%E8%A7%A3%E5%8C%85%E8%A3%85%E5%AF%B9%E8%B1%A1%E5%90%97%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#2.%20js%E4%B8%AD%E7%9A%84%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%3F%20%E4%BA%86%E8%A7%A3%E5%8C%85%E8%A3%85%E5%AF%B9%E8%B1%A1%E5%90%97%EF%BC%9F\">2. js中的基础数据类型有哪几种? 了解包装对象吗？</a></p>\n<p id=\"3.%E5%AF%B9%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E4%BA%86%E8%A7%A3-toc\" style=\"margin-left:40px;\"><a href=\"#3.%E5%AF%B9%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E4%BA%86%E8%A7%A3\">3.对内存泄漏的了解</a></p>\n<p id=\"4.js%E4%B8%AD%E6%95%B0%E7%BB%84%E5%90%88%E5%B9%B6%E7%9A%84%E6%96%B9%E6%B3%95-toc\" style=\"margin-left:40px;\"><a href=\"#4.js%E4%B8%AD%E6%95%B0%E7%BB%84%E5%90%88%E5%B9%B6%E7%9A%84%E6%96%B9%E6%B3%95\">4.js中数组合并的方法</a></p>\n<p id=\"5.%E5%90%88%E5%B9%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95-toc\" style=\"margin-left:40px;\"><a href=\"#5.%E5%90%88%E5%B9%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95\">5.合并对象的方法</a></p>\n<p id=\"6.%E4%BB%80%E4%B9%88%E6%98%AF%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#6.%E4%BB%80%E4%B9%88%E6%98%AF%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%EF%BC%9F\">6.什么是作用域，什么是作用域链？</a></p>\n<p id=\"7.JS%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%EF%BC%885%E7%A7%8D%EF%BC%89%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#7.JS%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%EF%BC%885%E7%A7%8D%EF%BC%89%EF%BC%9F\">7.JS如何实现异步编程（5种）？</a></p>\n<p id=\"js中的堆内存与栈内存-toc\" style=\"margin-left:40px;\"><a href=\"#js%E4%B8%AD%E7%9A%84%E5%A0%86%E5%86%85%E5%AD%98%E4%B8%8E%E6%A0%88%E5%86%85%E5%AD%98\">8.js中的堆内存与栈内存</a></p>\n<p id=\"9.%E5%A6%82%E4%BD%95%E5%8E%BB%E5%88%A4%E6%96%ADjs%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#9.%E5%A6%82%E4%BD%95%E5%8E%BB%E5%88%A4%E6%96%ADjs%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9F\">9.如何去判断js数据类型？</a></p>\n<p id=\"10%EF%BC%8C%E6%80%8E%E4%B9%88%E5%85%81%E8%AE%B8%E8%B7%A8%E5%9F%9F%EF%BC%88%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%EF%BC%89-toc\" style=\"margin-left:40px;\"><a href=\"#10%EF%BC%8C%E6%80%8E%E4%B9%88%E5%85%81%E8%AE%B8%E8%B7%A8%E5%9F%9F%EF%BC%88%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%EF%BC%89\">10，怎么允许跨域（跨域解决办法）</a></p>\n<p id=\"C%E3%80%81Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86-toc\" style=\"margin-left:80px;\"><a href=\"#C%E3%80%81Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86\">C、Nginx反向代理</a></p>\n<p id=\"D%E3%80%81webpack%20%EF%BC%88%E5%9C%A8vue.config.js%E6%96%87%E4%BB%B6%E4%B8%AD%EF%BC%89%E4%B8%AD%20%E9%85%8D%E7%BD%AEwebpack-dev-server-toc\" style=\"margin-left:80px;\"><a href=\"#D%E3%80%81webpack%20%EF%BC%88%E5%9C%A8vue.config.js%E6%96%87%E4%BB%B6%E4%B8%AD%EF%BC%89%E4%B8%AD%20%E9%85%8D%E7%BD%AEwebpack-dev-server\">D、webpack （在vue.config.js文件中）中 配置webpack-dev-server</a></p>\n<p id=\"11.%E6%80%8E%E4%B9%88%E8%AE%A9%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B1%9E%E6%80%A7%E4%B8%8D%E5%8F%AF%E8%A2%AB%E6%94%B9%E5%8F%98-toc\" style=\"margin-left:40px;\"><a href=\"#11.%E6%80%8E%E4%B9%88%E8%AE%A9%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B1%9E%E6%80%A7%E4%B8%8D%E5%8F%AF%E8%A2%AB%E6%94%B9%E5%8F%98\">11.怎么让对象的一个属性不可被改变</a></p>\n<p id=\"%EF%BC%881%EF%BC%89%20Object.defineProperty()-toc\" style=\"margin-left:80px;\"><a href=\"#%EF%BC%881%EF%BC%89%20Object.defineProperty%28%29\">（1） Object.defineProperty()</a></p>\n<p id=\"2%EF%BC%89object.preventExtensions()-toc\" style=\"margin-left:80px;\"><a href=\"#2%EF%BC%89object.preventExtensions%28%29\">2）object.preventExtensions()</a></p>\n<p id=\"12.%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%80%E7%94%A8%E7%9A%84%E5%86%85%E6%A0%B8-toc\" style=\"margin-left:40px;\"><a href=\"#12.%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%80%E7%94%A8%E7%9A%84%E5%86%85%E6%A0%B8\">12.浏览器所用的内核</a></p>\n<p id=\"13%E3%80%81%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E6%98%AF%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E8%BF%98%E6%98%AF%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%88%E8%A1%A5%E5%85%A8funcA()%7B%7D%EF%BC%89-toc\" style=\"margin-left:40px;\"><a href=\"#13%E3%80%81%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E6%98%AF%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E8%BF%98%E6%98%AF%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%88%E8%A1%A5%E5%85%A8funcA%28%29%7B%7D%EF%BC%89\">13、判断一个函数是普通函数还是构造函数（补全funcA(){}）</a></p>\n<p id=\"14.JavaScript%20%E4%B8%AD%E7%9A%84%E6%8F%90%E5%8D%87%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#14.JavaScript%20%E4%B8%AD%E7%9A%84%E6%8F%90%E5%8D%87%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\">14.JavaScript 中的提升是什么？</a></p>\n<p id=\"15%E3%80%81js%E6%9C%89%E5%93%AA%E4%BA%9B%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%EF%BC%9F%E3%80%80-toc\" style=\"margin-left:40px;\"><a href=\"#15%E3%80%81js%E6%9C%89%E5%93%AA%E4%BA%9B%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%EF%BC%9F%E3%80%80\">15、js有哪些内置对象？　</a></p>\n<p id=\"16.%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81-toc\" style=\"margin-left:40px;\"><a href=\"#16.%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81\">16.防抖和节流</a></p>\n<p id=\"函数防抖-toc\" style=\"margin-left:80px;\"><a href=\"#%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96\">函数防抖</a></p>\n<p id=\"函数节流-toc\" style=\"margin-left:80px;\"><a href=\"#%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81\">函数节流</a></p>\n<p id=\"17.%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D-toc\" style=\"margin-left:40px;\"><a href=\"#17.%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D\">17.对象的深拷贝</a></p>\n<p id=\"18%E3%80%81%C2%A0Nodelist%E5%92%8CHTMLCollection%E7%9A%84%E5%8C%BA%E5%88%AB-toc\" style=\"margin-left:40px;\"><a href=\"#18%E3%80%81%C2%A0Nodelist%E5%92%8CHTMLCollection%E7%9A%84%E5%8C%BA%E5%88%AB\">18、 Nodelist和HTMLCollection的区别</a></p>\n<p id=\"%C2%A019.js%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%99%90%E5%88%B6-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A019.js%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%99%90%E5%88%B6\"> 19.js严格模式的限制</a></p>\n<p id=\"%E2%80%8B%E7%BC%96%E8%BE%91-toc\" style=\"margin-left:40px;\"><a href=\"#%E2%80%8B%E7%BC%96%E8%BE%91\">​编辑</a></p>\n<p id=\"20%20js%E4%B8%AD%E7%9A%84%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1-toc\" style=\"margin-left:40px;\"><a href=\"#20%20js%E4%B8%AD%E7%9A%84%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1\">20 js中的宏任务和微任务</a></p>\n<p id=\"21%20vdom%E7%9C%9F%E7%9A%84%E5%BE%88%E5%BF%AB%E5%90%97%EF%BC%9F%EF%BC%88%E6%A1%86%E6%9E%B6%EF%BC%89-toc\" style=\"margin-left:40px;\"><a href=\"#21%20vdom%E7%9C%9F%E7%9A%84%E5%BE%88%E5%BF%AB%E5%90%97%EF%BC%9F%EF%BC%88%E6%A1%86%E6%9E%B6%EF%BC%89\">21 vdom真的很快吗？（框架）</a></p>\n<p id=\"22.for%E5%92%8Cforeach%E8%B0%81%E6%9B%B4%E5%BF%AB%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#22.for%E5%92%8Cforeach%E8%B0%81%E6%9B%B4%E5%BF%AB%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F\">22.for和foreach谁更快，为什么？</a></p>\n<p id=\"23%20%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B-toc\" style=\"margin-left:40px;\"><a href=\"#23%20%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B\">23 进程和线程</a></p>\n<p id=\"24%20nodejs%E5%A6%82%E4%BD%95%E5%BC%80%E5%90%AF%E5%A4%9A%E8%BF%9B%E7%A8%8B-toc\" style=\"margin-left:40px;\"><a href=\"#24%20nodejs%E5%A6%82%E4%BD%95%E5%BC%80%E5%90%AF%E5%A4%9A%E8%BF%9B%E7%A8%8B\">24 nodejs如何开启多进程</a></p>\n<p id=\"25%20%E8%AF%B7%E6%8F%8F%E8%BF%B0JS%20Bridge%E5%8E%9F%E7%90%86-toc\" style=\"margin-left:40px;\"><a href=\"#25%20%E8%AF%B7%E6%8F%8F%E8%BF%B0JS%20Bridge%E5%8E%9F%E7%90%86\">25 请描述JS Bridge原理</a></p>\n<p id=\"26%2C%20script%E4%B8%AD%E7%9A%84defer%E5%92%8Casync%E5%B1%9E%E6%80%A7%E7%9A%84%E5%8C%BA%E5%88%AB-toc\" style=\"margin-left:40px;\"><a href=\"#26%2C%20script%E4%B8%AD%E7%9A%84defer%E5%92%8Casync%E5%B1%9E%E6%80%A7%E7%9A%84%E5%8C%BA%E5%88%AB\">26, script中的defer和async属性的区别</a></p>\n<p id=\"27%EF%BC%8C%E7%A7%BB%E5%8A%A8%E7%AB%AFh5%E6%9C%89300%E6%AF%AB%E7%A7%92%E5%BB%B6%E8%BF%9F%EF%BC%8C%E8%AF%A5%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#27%EF%BC%8C%E7%A7%BB%E5%8A%A8%E7%AB%AFh5%E6%9C%89300%E6%AF%AB%E7%A7%92%E5%BB%B6%E8%BF%9F%EF%BC%8C%E8%AF%A5%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F\">27，移动端h5有300毫秒延迟，该如何解决？</a></p>\n<p id=\"27%EF%BC%8Cprefetch%20%E5%92%8Cdns-prefetch%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%3F-toc\" style=\"margin-left:40px;\"><a href=\"#27%EF%BC%8Cprefetch%20%E5%92%8Cdns-prefetch%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%3F\">27，prefetch 和dns-prefetch有什么区别?</a></p>\n<p id=\"-toc\" style=\"margin-left:40px;\"></p>\n<p id=\"28%EF%BC%8C%E5%89%8D%E7%AB%AF%E6%94%BB%E5%87%BB%E6%89%8B%E6%AE%B5%E6%9C%89%E5%93%AA%E4%BA%9B%3F%E8%AF%A5%E5%A6%82%E4%BD%95%E9%A2%84%E9%98%B2%3F-toc\" style=\"margin-left:40px;\"><a href=\"#28%EF%BC%8C%E5%89%8D%E7%AB%AF%E6%94%BB%E5%87%BB%E6%89%8B%E6%AE%B5%E6%9C%89%E5%93%AA%E4%BA%9B%3F%E8%AF%A5%E5%A6%82%E4%BD%95%E9%A2%84%E9%98%B2%3F\">28，前端攻击手段有哪些?该如何预防?</a></p>\n<p id=\"-toc\" style=\"margin-left:40px;\"></p>\n<p></p>\n<hr/>\n<p></p>\n<h2 id=\"1.%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E\">1.线程和进程是什么？举例说明</h2>\n<p><br/> 进程：cpu分配资源的最小单位（是能拥有资源和独立运行的最小单位）<br/> 线程：是cpu最小的调度单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）<br/> 栗子：比如进程=火车，线程就是车厢</p>\n<p>一个进程内有多个线程，执行过程是多条线程共同完成的，线程是进程的部分。<br/> 一个火车可以有多个车厢<br/> 每个进程都有独立的代码和数据空间，程序之间切换会产生较大的开销；线程可以看作轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器，线程之间切换的开销小。<br/> 【多列火车比多个车厢更耗资源】<br/> 【一辆火车上的乘客很难换到另外一辆火车，比如站点换乘，但是同一辆火车上乘客很容易从A车厢换到B车厢】<br/> 同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的<br/> 【一辆火车上不同车厢的人可以共用各节车厢的洗手间，但是不是火车上的乘客无法使用别的火车上的洗手间】</p>\n<p>为什么js是单线程<br/> JS是单线程的原因主要和JS的用途有关，JS主要实现浏览器与用户的交互，以及操作DOM。<br/> 如果JS被设计为多线程，如果一个线程要修改一个DOM元素，另一个线程要删除这个DOM元素，这时浏览器就不知道该怎么办，为了避免复杂的情况产生，所以JS是单线程的。</p>\n<p>为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。</p>\n<h2 id=\"2.%20js%E4%B8%AD%E7%9A%84%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%3F%20%E4%BA%86%E8%A7%A3%E5%8C%85%E8%A3%85%E5%AF%B9%E8%B1%A1%E5%90%97%EF%BC%9F\">2. js中的基础数据类型有哪几种? 了解包装对象吗？</h2>\n<p><br/> 答：六种，string, number, boolean, undefiend, null, symbol<br/> 基础数据类型临时创建的临时对象，称为包装对象。其中 number、boolean 和 string 有包装对象，代码运行的过程中会找到对应的包装对象，然后包装对象把属性和方法给了基本类型，然后包装对象被系统进行销毁。</p>\n<p></p>\n<h2 id=\"3.%E5%AF%B9%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E4%BA%86%E8%A7%A3\">3.对内存泄漏的了解</h2>\n<p><br/> 1. 理解<br/> - 定义：程序中已在堆中分配的内存，因为某种原因未释放或者无法释放的问题<br/> - 简单理解: 无用的内存还在占用，得不到释放和归还，比较严重的时候，无用的内存还会增加，从而导致整个系统卡顿，甚至崩溃。<br/><br/> 2. 生命周期<br/> 1. 分配期<br/>   分配所需要的内存，在js中，是自动分配的<br/> 2. 使用期<br/>   使用分配的内存，就是读写变量或者对象的属性值<br/> 3. 释放期<br/>   不需要时将该内存释放，js会自动释放(除了闭包和一些bug以外)<br/>   内存泄漏就是出现在这个时期，内存没有被释放导致的<br/><br/> 3. 可能出现内存泄漏的原因<br/> 1. 意外的全局变量<br/> 2. DOM元素清空时，还存在引用<br/> 3. 闭包<br/> 4. 遗忘的定时器</p>\n<p><strong>如何优化内存泄漏?</strong></p>\n<ul><li>全局变量先声明在使用</li><li>避免过多使用闭包。</li><li>注意清除定时器和事件监听器。</li></ul>\n<p></p>\n<h2 id=\"4.js%E4%B8%AD%E6%95%B0%E7%BB%84%E5%90%88%E5%B9%B6%E7%9A%84%E6%96%B9%E6%B3%95\">4.js中数组合并的方法</h2>\n<p>js 数组合并<br/> let arr1 = ['温情', '刘聪']<br/> let arr2 = ['杨和苏', '邓紫棋']<br/> let arr3 = ['周延']<br/><br/><strong>1. arr1.concat(arr2, ······)</strong><br/> es5 Array.concat() 合并两个数组, 返回新数组，不会改变原数组<br/> arr = arr1.concat(arr2, arr3);<br/> console.log(arr);  // [\"温情\", \"刘聪\", \"杨和苏\", \"邓紫棋\", \"周延\"]<br/><br/><strong>2. […arr1, …arr2，······]</strong><br/> es6 展开运算符(…)<br/> arr = [...arr1, ...arr2, ...arr3];<br/> console.log(arr);  // [\"温情\", \"刘聪\", \"杨和苏\", \"邓紫棋\", \"周延\"]<br/><br/><strong>3. push(…arr)</strong><br/> push 结合 ...[] 来实现, 会更改原数组<br/> arr1.push(...arr2, ...arr3)<br/> console.log(arr1);  // [\"温情\", \"刘聪\", \"杨和苏\", \"邓紫棋\", \"周延\"<br/><br/><strong>适合两个数组，不适合多个数组的方法</strong><br/><strong>1. for + push</strong><br/> for(let i in arr2) {<!-- --><br/>     arr1.push(arr2[i])<br/> }<br/> console.log(arr1);  // [\"温情\", \"刘聪\", \"杨和苏\", \"邓紫棋\"]<br/><br/><strong>2. arr1.push.apply(arr1, arr2)</strong><br/> arr1.push.apply(arr1, arr2)<br/> console.log(arr1);  // [\"温情\", \"刘聪\", \"杨和苏\", \"邓紫棋\"]</p>\n<p></p>\n<h2 id=\"5.%E5%90%88%E5%B9%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95\">5.合并对象的方法</h2>\n<p><strong>Object.assign()</strong><br/> es6 Object.assign()方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target)<br/> Object.assign()方法的第一个参数是目标对象，后面的参数都是源对象。<br/> let obj1 = {name: '温情'}<br/> let obj2 = {age: '22'}</p>\n<p><strong>const newObj = Object.assign({}, obj1, obj2);</strong><br/> console.log(newObj);  // {name: \"温情\", age: \"22\"}<br/><br/> !注意! Object.assign()实行的是浅拷贝，也就是说如果源对象的属性是一个对象，那么目标对象得到的是这个对象的引用</p>\n<p>let obj1 = {name: {chinese: '杨和苏', english: 'keyNG'}}<br/> const newObj = Object.assign({}, obj1);<br/> console.log(newObj);  // name: {chinese: \"杨和苏\", english: \"keyNG\"}<br/> obj1.name.english = 'pig';<br/> console.log(newObj);  // name: {chinese: \"杨和苏\", english: \"pig\"}</p>\n<p></p>\n<h2 id=\"6.%E4%BB%80%E4%B9%88%E6%98%AF%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%EF%BC%9F\">6.什么是作用域，什么是作用域链？</h2>\n<ul><li>规定变量和函数的可使用范围称为作用域</li><li>查找变量或者函数时，需要从局部作用域到全局作用域依次查找，这些作用域的集合称作用域链。</li></ul>\n<p></p>\n<h2 id=\"7.JS%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%EF%BC%885%E7%A7%8D%EF%BC%89%EF%BC%9F\"><strong>7.JS如何实现异步编程（5种）？</strong></h2>\n<p><br/> 1）回调函数(callback)<br/> 优点：解决了同步的问题（只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。）<br/> 缺点：回调地狱，每个任务只能指定一个回调函数,不能 return.</p>\n<p>2)事件监听。这种思路是说异步任务的执行不取决于代码的顺序，而取决于某个事件是否发生。比如一个我们注册一个按钮的点击事件或者注册一个自定义事件，然后通过点击或者trigger的方式触发这个事件。</p>\n<p>3)Promise</p>\n<p>4)Generator</p>\n<p>5)生成器 async/await,是ES7提供的一种解决方案。</p>\n<p></p>\n<h2 id=\"js中的堆内存与栈内存\">8.js中的<a href=\"https://so.csdn.net/so/search?q=%E5%A0%86%E5%86%85%E5%AD%98&amp;spm=1001.2101.3001.7020\" title=\"堆内存\">堆内存</a>与栈内存</h2>\n<p>在js引擎中对变量的存储主要有两种位置，<strong>堆内存和栈内存</strong>。</p>\n<p>和java中对<a href=\"https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&amp;spm=1001.2101.3001.7020\" title=\"内存\">内存</a>的处理类似，<strong>栈内存</strong>主要用于存储各种<strong>基本类型的</strong>变量，包括Boolean、Number、String、Undefined、Null，**以及对象变量的指针，这时候栈内存给人的感觉就像一个线性排列的空间，每个小单元大小基本相等。</p>\n<p>而堆内存主要负责像对象Object这种变量类型的存储，如下图</p>\n<p><img alt=\"\" src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvNDYxOTc2LzIwMTgwOC80NjE5NzYtMjAxODA4MjMyMTE1MTE0MzQtMTcwNzU3OTc5NC5wbmc?x-oss-process=image/format,png\"/></p>\n<p></p>\n<p><strong>栈内存中的变量一般都是已知大小或者有范围上限的</strong>，算作一种简单存储。<strong>而堆内存存储的对象类型数据对于大小这方面，一般都是未知的</strong>。个人认为，这也是为什么null作为一个object类型的变量却存储在栈内存中的原因。</p>\n<p><strong>因此当我们定义一个const对象的时候，<u>我们说的常量其实是指针</u>，就是const对象对应的堆内存指向是不变的，但是堆内存中的数据本身的大小或者属性是可变的。而<u>对于const定义的基础变量而言，这个值就相当于const对象的指针</u>，是不可变。</strong></p>\n<p>既然知道了const在内存中的存储，那么const、let定义的变量不能二次定义的流程也就比较容易猜出来了，每次使用const或者let去初始化一个变量的时候，会首先遍历当前的内存栈，看看有没有重名变量，有的话就返回错误。</p>\n<p>说到这里，有一个十分很容易忽略的点，之前也是自己一直没有注意的就是，使用new关键字初始化的之后是不存储在栈内存中的。为什么呢？new大家都知道，根据构造函数生成新实例，这个时候生成的是<strong>对象</strong>，而不是基本类型。再看一个例子</p>\n<p><img alt=\"\" height=\"168\" src=\"image\\f47b7407ab704459ae922e8779ce6875.png\" width=\"652\"/></p>\n<p> 我们可以看到new一个String，出来的是对象，而直接字面量赋值和工厂模式出来的都是字符串。但是根据我们上面的分析大小相对固定可预期的即便是对象也可以存储在栈内存的，比如null，为啥这个不是呢？再继续看</p>\n<p><img alt=\"\" height=\"88\" src=\"image\\6e2e46d349d14fd5af23eb19efa628b5.png\" width=\"293\"/></p>\n<p> 很明显，如果a，b是存储在栈内存中的话，两者应该是明显相等的，就像null === null是true一样，但结果两者并不相等，说明两者都是存储在堆内存中的，指针指向不一致。</p>\n<p><br/>  </p>\n<h2 id=\"9.%E5%A6%82%E4%BD%95%E5%8E%BB%E5%88%A4%E6%96%ADjs%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9F\">9.如何去判断js数据类型？</h2>\n<p><strong>         首先我们可以用typeof去判断，typeof只能判断基本数据类型，对于引用数据类型，- -律返回object,在js中，数组是一种特殊的对象类型， 因此typeof-个数组,返回的是object.<br/>         还可以通过instanceof来判断，它不能检测基本数据类型，它是用来判断个实例是否属于某种类型， 使用它的方式可以用Ainstanceof B，如果A是B的实例，则返回true,否则返回flase。<br/>         然后还可以用constructor来判断，除了undefined和nul1之外，其它类型都可以通过constructor来判断,<br/>         但是如果声明了一个构造函数，并且把它的原型指向改变了，这种情况下，constructor也不能准确的判断。<br/>         通过0bject . prototype . toString,判断一个对象 只属于某种内置类型，但是不能准确的判断一个实例是否属于某种类型。<br/> 原因是因为实例对象可能会自定义toString方法，把这个方法给覆盖掉，我们可以通过函数. call( )方法，可以在任意值上调用这个方法，帮助我们判断这个值的类型。</strong></p>\n<p></p>\n<h2 id=\"10%EF%BC%8C%E6%80%8E%E4%B9%88%E5%85%81%E8%AE%B8%E8%B7%A8%E5%9F%9F%EF%BC%88%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%EF%BC%89\">10，怎么允许跨域（跨域解决办法）</h2>\n<p><strong>A、JSONP</strong><br/> 在页面上，js脚本，css样式文件，图片这三种资源是可以与页面本身不同源的。jsonp就利用了script标签进行跨域取得数据。<br/> JSONP允许用户传递一个callback参数给服务器端，然后服务器端返回数据时会将这个callback参数作为函数名来包裹住JSON数据。这样客户端就可以随意定制自己的函数来自动处理返回的数据了。<br/> JSONP只能解决get请求，不能解决post请求。<br/>  </p>\n<pre><code class=\"language-javascript\">&lt;script&gt;\n        function callback(data){\n            console.log(data);\n        }\n    &lt;/script&gt;\n    &lt;script src=\"http://localhost:80/?callback=callback\"&gt;&lt;/script&gt;\n</code></pre>\n<p>使用ajax实现跨域：</p>\n<pre><code class=\"language-javascript\">&lt;script src=\"http://code.jquery.com/jquery-latest.js\"&gt;&lt;/script&gt; \n\n  $.ajax({\n            url:'http://localhost:80/?callback=callback',\n            method:'get',\n            dataType:'jsonp', //=&gt; 执行jsonp请求\n            success:(res) =&gt; {\n                console.log(res);\n            }\n        })\n    \n        function callback(data){\n            console.log(data);\n        }\n</code></pre>\n<p></p>\n<p><strong>B、 CORS跨域资源共享：</strong><br/> 浏览器会自动进行CORS通信，实现CORS通信的关键是后端。服务端设置Access-Control-Allow-Origin就可以开启CORS。该属性表示哪些域名跨域访问资源。<br/> 主要设置以下几个属性：<br/> Access-Control-Allow-Origin//允许跨域的域名<br/> Access-Control-Allow-Headers//允许的header类型<br/> Access-Control-Allow-Methods//跨域允许的请求方式</p>\n<h3 id=\"C%E3%80%81Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86\">C、Nginx反向代理</h3>\n<p>通过nginx配置一个代理服务器将客户机请求转发给内部网络上的目标服务器；并将服务器上返回的结果返回给客户端。</p>\n<h3 id=\"D%E3%80%81webpack%20%EF%BC%88%E5%9C%A8vue.config.js%E6%96%87%E4%BB%B6%E4%B8%AD%EF%BC%89%E4%B8%AD%20%E9%85%8D%E7%BD%AEwebpack-dev-server\"><a name=\"t27\"></a><a id=\"Dwebpack_vueconfigjs_webpackdevserver_283\"></a>D、webpack （在vue.config.js文件中）中 配置webpack-dev-server</h3>\n<pre><code class=\"language-javascript\">devServer: {\n        proxy: {\n          '/api': {\n            target: \"http://39.98.123.211\",\n            changeOrigin: true,  //是否跨域\n          },\n        },\n      },\n</code></pre>\n<h2 id=\"11.%E6%80%8E%E4%B9%88%E8%AE%A9%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B1%9E%E6%80%A7%E4%B8%8D%E5%8F%AF%E8%A2%AB%E6%94%B9%E5%8F%98\">11.怎么让对象的一个属性不可被改变</h2>\n<h3 id=\"%EF%BC%881%EF%BC%89%20Object.defineProperty()\"><a name=\"t88\"></a><a id=\"1_ObjectdefineProperty_910\"></a>（1） Object.defineProperty()</h3>\n<p>可以使用Object.defineProperty()方法，让对象的某一个属性不可变，把对象某一属性的writable和configurable设置为false.</p>\n<pre><code class=\"language-javascript\">let obj = {a:1,b:2};\n      Object.defineProperty(obj,'c',{\n        value:100000,\n        writable:false,//当该属性的 writable 键值为 true 时，属性的值才能被赋值操作修改\n        configurable:false//当为true时，该属性的描述符才能够被改变，同时该属性也能从对应的对象上被删除。\n      })\n      \n      obj.c = 282031283\n      console.log(obj.c)//100000\n</code></pre>\n<h3 id=\"2%EF%BC%89object.preventExtensions()\">2）object.preventExtensions()</h3>\n<p>让对象不能添加新属性，可以使用object.preventExtensions()方法。（但是可以修改属性值）</p>\n<pre><code class=\"language-javascript\">\t  let obj = {a:1,b:2};\n      Object.preventExtensions(obj);\n      obj.c = 1000;\n      console.log(obj)\n</code></pre>\n<h2 id=\"12.%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%80%E7%94%A8%E7%9A%84%E5%86%85%E6%A0%B8\">12.浏览器所用的内核</h2>\n<p><br/> IE：Trident内核<br/> Chrome:以前是webkit内核，现在是Blink内核<br/> Firefox:Gecko（/ˈɡekoʊ/）内核<br/> Safari:webkit内核<br/> Opera:最初使用的是presto内核，后来加入谷歌大军，从webkit内核又变成了Blink内核<br/> 360，猎豹浏览器：IE+chrome双内核</p>\n<p></p>\n<h2 id=\"13%E3%80%81%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E6%98%AF%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E8%BF%98%E6%98%AF%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%88%E8%A1%A5%E5%85%A8funcA()%7B%7D%EF%BC%89\">13、判断一个函数是普通函数还是构造函数（补全funcA(){}）</h2>\n<blockquote>\n<p>构造函数中this指向new创建的实例。所以可通过在函数内部判断this是否为当前函数的实例进而判断当前函数是否作为构造函数。</p>\n</blockquote>\n<pre><code class=\"language-javascript\">\t\tfunction A(){\n            if(this instanceof A){\n                console.log('我是构造函数')\n            }else{\n                console.log('我是普通函数')\n            }\n        }\n        A();\n        new A();\n</code></pre>\n<h2 id=\"14.JavaScript%20%E4%B8%AD%E7%9A%84%E6%8F%90%E5%8D%87%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><strong>14.JavaScript 中的提升是什么？</strong></h2>\n<p>提升意味着所有的声明都被移动到作用域的顶部。这发生在代码运行之前。</p>\n<p>对于函数，这意味着你可以从作用域中的任何位置调用它们，甚至在它们被定义之前。</p>\n<pre><code class=\"language-javascript\">hello();  // Prints \"Hello world! \" even though the function is called \"before\" declaration\n \n \nfunction hello(){ \n  console.log(\"Hello world! \");\n}</code></pre>\n<p>对于变量，提升有点不同。它在作用域的顶部将 undefined 分配给它们。</p>\n<p>例如，在定义变量之前调用它：</p>\n<pre><code class=\"language-javascript\">console.log(dog);//undefined\nvar dog = \"Spot\";</code></pre>\n<p></p>\n<p>结果是：</p>\n<pre><code>undefined</code></pre>\n<p>这可能令人惊讶，因为你可能预计它会导致错误。</p>\n<p>用var声明一个函数或变量，无论你在哪里声明它，它总是被移动到作用域的顶部。</p>\n<p></p>\n<p></p>\n<h2 id=\"15%E3%80%81js%E6%9C%89%E5%93%AA%E4%BA%9B%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%EF%BC%9F%E3%80%80\"><strong>15、js有哪些内置对象？</strong>　</h2>\n<p><br/> 数据封装类对象：Object、Array、Boolean、Number 和 String<br/> 　　其他对象：Function、Arguments、Math、Date、RegExp、Error....</p>\n<h2 id=\"16.%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81\">16.防抖和节流</h2>\n<h3 id=\"函数防抖\"><strong>函数防抖</strong></h3>\n<p>当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定时间到来之前，又触发了事件，就重新开始延时。也就是说当一个用户一直触发这个函数，且每次触发函数的间隔小于既定时间，那么防抖的情况下只会执行一次。</p>\n<p>举个例子：</p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n    &lt;title&gt;防抖&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n搜索：&lt;input type=\"text\" id=\"input1\"&gt;\n\n    &lt;script&gt;\n        // 防抖 \n        // 默认值200ms\n        function debounce(fn,dalay=200) {\n         let  timer=0;\n            return function(){\n             if(timer)   clearTimeout(timer);\n                timer=setTimeout(()=&gt;{\n                     fn.apply(this,arguments)//透传this和参数\n                     timer=0\n                },dalay)\n            }           \n        }\n      \n        const input=document.getElementById(\"input1\");\n        input.addEventListener(\"keyup\",debounce(()=&gt;{\n            console.log(\"发起搜索\"+input.value)\n        },1000))\n\n   \n\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre>\n<h3 id=\"函数节流\">函数节流</h3>\n<p>当持续触发事件时，保证在一定时间内只调用一次事件处理函数，意思就是说，假设一个用户一直触发这个函数，且每次触发小于既定值，函数节流会每隔这个时间调用一次<br/> 用一句话总结防抖和节流的区别：防抖是将多次执行变为最后一次执行，节流是将多次执行变为每隔一段时间执行</p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n    &lt;title&gt;throttle&lt;/title&gt;\n    &lt;div id=\"div1\" draggable=\"true\" style=\"width:100px;height: 50px;background-color:gray; \"&gt;\n        可拖拽\n    &lt;/div&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    \n\n    &lt;script&gt;\n        // 节流 不管时间触发了多少次 在规定事件内只会执行一次 \n        function throttle(fn,delay=200) {\n            let timer=0;\n            return function(){\n                if(timer) return ;\n                timer=setTimeout(()=&gt;{\n                     fn.apply(this,arguments)//透传this和参数\n                     timer=0\n                },delay)\n            }\n        }\n\n        const div1=document.getElementById(\"div1\");\n        div1.addEventListener(\"drag\",throttle((e)=&gt;{\n            console.log(\"鼠标的位置\"+e.offsetX,e.offsetY)\n        },2000))\n\n\n\n    \n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre>\n<p>总结防抖和节流函数： js代码区别就在于if这里是清除定时器还是直接return终止函数</p>\n<pre><code class=\"language-javascript\"> function throttleOrDebounce(fn,delay=3000) {\n            let timer=0;\n            return function (){\n                // 防抖\n                // if(timer) clearTimeout(timer);\n                // 节流\n                if (timer) return;\n                timer=setTimeout(()=&gt;{\n                       fn.apply(this,arguments)\n                       timer=0\n                },delay)\n            }\n        }</code></pre>\n<p></p>\n<h2 id=\"17.%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D\">17.对象的深拷贝</h2>\n<p> 深拷贝就是对目标的完全拷贝，不像浅拷贝那样只是复制了一层引用，而是就连值也都复制了。</p>\n<p> 深拷贝之后，两个对象将毫无关联，不会相互影响。</p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n\t&lt;head&gt;\n\t\t&lt;meta charset=\"utf-8\"&gt;\n\t\t&lt;title&gt;&lt;/title&gt;\n\t&lt;/head&gt;\n\t&lt;body&gt;\n\t\t&lt;script type=\"text/javascript\"&gt;\n\t\t\tlet obj = {\n\t\t\t\tname: \"张三\",\n\t\t\t\tlist: [1, 2, 3, 4, 5, 6],\n\t\t\t\teat(){\n\t\t\t\t\tconsole.log(this.name+\"正在吃\")\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// 深拷贝\n\t\t\tfunction deepClone(obj) {\n\t\t\t\t// 如果是引用数据类型 \n\t\t\t\tif (typeof obj == 'object') {\n\t\t\t\t\tlet result = Array.isArray(obj) ? [] : {}\n\t\t\t\t\tfor (key in obj) {\n\t\t\t\t\t\tresult[key] = deepClone(obj[key])\n\t\t\t\t\t}\n\t\t\t\t\treturn result\n\t\t\t\t} else {\n\t\t\t\t\treturn obj\n\t\t\t\t}\n\t\t\t}\n\n\t\t    let obj1 = deepClone(obj)\n\t\t\tobj.hight = '1.78m'\n\t\t\tobj1.age = 18;\n\t\t\tobj1.like='dog'\n\t\t\tconsole.log(obj, obj1)\n\n\n      \n\n\t\t\t\n\t\t&lt;/script&gt;\n\t&lt;/body&gt;\n\n&lt;/html&gt;\n</code></pre>\n<h2 id=\"18%E3%80%81%C2%A0Nodelist%E5%92%8CHTMLCollection%E7%9A%84%E5%8C%BA%E5%88%AB\">18、 Nodelist和HTMLCollection的区别</h2>\n<p>1.Nodelist是返回节点的集合，而nodelist里面也有数组，因此元素也是节点的一种，也就是元素节点<strong> nodelist包含所有的节点 ：注释节点、text节点、element节点.....等</strong></p>\n<pre><code class=\"language-html\">&lt;div class=\"a\"&gt;\n    &lt;div class=\"cc\"&gt;&lt;/div&gt;\n&lt;/div&gt;\n\n\nconsole.log(document.getElementsByClassName('a')[0].childNodes);//nodelist\nconsole.log(document.getElementsByClassName('a')[0].children);//Htmlcollection</code></pre>\n<p><img alt=\"\" src=\"https://img-blog.csdnimg.cn/20201024190704393.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTYzODkwOQ==,size_16,color_FFFFFF,t_70#pic_center\"/></p>\n<p> 2.<strong>HTMLCollection是html元素的集合</strong>，是节点的一种，<strong>它里面只有元素节点</strong>，并且元素节点可以包含很多的节点， 因此我们可以理解为HTMLCollection是Nodelist集合的一种。Nodelist和HTMLCollection都是伪数组</p>\n<p> 可以看到HTMLCollection中只包含了 div元素</p>\n<p> <img alt=\"\" height=\"130\" src=\"image\\8dad29475cca4d57b826691460b5b9f5.png\" width=\"328\"/></p>\n<p> 最后在上一张图 加深理解：</p>\n<p><img alt=\"\" height=\"737\" src=\"image\\edeb32e4f4ac45768f77ef16b8e91b5d.png\" width=\"1200\"/></p>\n<h2 id=\"%C2%A019.js%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%99%90%E5%88%B6\"> 19.js严格模式的限制</h2>\n<h2 id=\"%E2%80%8B%E7%BC%96%E8%BE%91\"><img alt=\"\" height=\"174\" src=\"image\\6be11b01200c4dfcbc51375dde10b69c.png\" width=\"291\"/></h2>\n<p><strong>1.变量必须声明后再使用</strong><br/><strong>2.函数的参数不能有同名属性，否则报错</strong><br/><strong>3.不能使用with语句</strong><br/> 4.不能对只读属性赋值，否则报错<br/> 5.不能使用前缀 0 表示八进制数，否则报错<br/> 6.不能删除不可删除的属性，否则报错<br/> 7.不能删除变量delete prop，会报错，只能删除属性delete global[prop]<br/> 8.eval不会在它的外层作用域引入变量<br/> 9.eval和arguments不能被重新赋值<br/> 10.arguments不会自动反映函数参数的变化<br/> 11.不能使用arguments.callee<br/> 12.不能使用arguments.caller<br/><strong>13.禁止this指向全局对象window</strong><br/> 14.不能使用fn.caller和fn.arguments获取函数调用的堆栈<br/> 15.增加了保留字（比如protected、static和interface）</p>\n<p><strong>16.创建eval作用域 ，使eval具有自己独立的作用域</strong></p>\n<p></p>\n<h2 id=\"20%20js%E4%B8%AD%E7%9A%84%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1\">20 js中的宏任务和微任务</h2>\n<p> 1）首先理解一下单线程和异步</p>\n<p><img alt=\"\" height=\"354\" src=\"image\\7aef592047bb43eb957e85ee6c484d12.png\" width=\"691\"/></p>\n<p></p>\n<p> 2）宏任务和微任务</p>\n<p></p>\n<p><img alt=\"\" height=\"671\" src=\"image\\810588cafcf640d9a565d2bd9ac8f5db.png\" width=\"1200\"/></p>\n<p> 还有一个不常用的微任务<img alt=\"\" height=\"29\" src=\"image\\4e17551289004afebe034a8c3a89dec6.png\" width=\"160\"/> 作用是监听dom树的变化</p>\n<p></p>\n<p>微任务 比宏任务执行的 快</p>\n<p></p>\n<h2 id=\"21%20vdom%E7%9C%9F%E7%9A%84%E5%BE%88%E5%BF%AB%E5%90%97%EF%BC%9F%EF%BC%88%E6%A1%86%E6%9E%B6%EF%BC%89\"><strong>21 vdom真的很快吗？（框架）</strong></h2>\n<p><img alt=\"\" height=\"634\" src=\"image\\5e83f2e5233a4222acb2dca7b2f9c5fd.png\" width=\"1064\"/></p>\n<p> <img alt=\"\" height=\"649\" src=\"image\\8cd28c931ce743859f7a2d8b96dd8841.png\" width=\"1200\"/></p>\n<p></p>\n<p> 数据驱动试图的技术方法：vdom （虚拟dom）、</p>\n<p>原因：数据和试图分离 如果dom全部更新--不行 所以使用虚拟dom</p>\n<p>  data变化==&gt;生成 vnode 和oldnode进行对比（diff算法）新、旧两个虚拟dom进行比较==&gt;找到需要更新的部分 ==&gt;局部dom更新</p>\n<p>使用jquery：直接操作dom节点</p>\n<p><strong>从dom变化上来说，常规的dom操作更快，但是从完整的链条来说（包括研发、运维、设计、开发、测试，整个软件工程的完整链条来看），vdom更快，简化了代码逻辑</strong></p>\n<p>vdom并不快，JS直接操作DOM才是最快的<br/> 但“数据驱动视图”要有合适的技术方案，不能全部 DOM重建<br/> vdom 就是目前最合适的技术方案（并不是因为它快，而是合适)</p>\n<p></p>\n<h2 id=\"22.for%E5%92%8Cforeach%E8%B0%81%E6%9B%B4%E5%BF%AB%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F\">22.for和foreach谁更快，为什么？</h2>\n<p>使用性能测试之后发现for更快，为什么呢？</p>\n<p>for 更快</p>\n<p>原因：<br/><strong>forEach每次都要创建一个函数来调用，而for不会创建函数，</strong></p>\n<p><strong>函数需要独立的作用域，会有额外的开销</strong></p>\n<p>越“低级”的代码，性能往往越好<br/> 日常开发别只考虑性能，forEach代码可读性更好（基于时间复杂度一样的情况下，使用可读性更好的方式更佳）</p>\n<p></p>\n<h2 id=\"23%20%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B\">23 进程和线程</h2>\n<p>进程process vs 线程thread<br/><br/> ◆进程，OS<strong>进行资源分配和调度的最小单位</strong>，<strong>有独立内存空间</strong><br/> ◆线程，OS<strong>进行运算调度的最小单位</strong>，<strong>共享进程内存空间</strong></p>\n<p></p>\n<p><img alt=\"\" height=\"545\" src=\"image\\0024701d1bd14095b967ddac08752289.png\" width=\"977\"/></p>\n<p></p>\n<p>为何需要多进程?<br/> 多核CPU ，更适合处理多进程<br/> ◆内存较大，多个进程才能更好的利用（单进程有内存上限)<br/> ◆总之，“压榨”机器资源，更快，更节省</p>\n<h2 id=\"24%20nodejs%E5%A6%82%E4%BD%95%E5%BC%80%E5%90%AF%E5%A4%9A%E8%BF%9B%E7%A8%8B\"><br/><br/> 24 nodejs如何开启多进程</h2>\n<p>方法：使用模块开启子进程 看下方连接</p>\n<p><a href=\"https://blog.csdn.net/SK_study/article/details/122774164\" title=\"Nodejs 玩转进程_石头山_S的博客-CSDN博客_nodejs 进程\">Nodejs 玩转进程_石头山_S的博客-CSDN博客_nodejs 进程</a></p>\n<p></p>\n<h2 id=\"25%20%E8%AF%B7%E6%8F%8F%E8%BF%B0JS%20Bridge%E5%8E%9F%E7%90%86\">25 请描述JS Bridge原理</h2>\n<p><br/> 什么是JS Bridge？<br/>         JS无法直接调用native API （手机版app）<br/>         需要通过一些特定的“格式”来调用（手机版app）<br/>         ◆这些“格式”就统称JS-Brlage，例如微信JSSDK</p>\n<h2 id=\"26%2C%20script%E4%B8%AD%E7%9A%84defer%E5%92%8Casync%E5%B1%9E%E6%80%A7%E7%9A%84%E5%8C%BA%E5%88%AB\">26, script中的defer和async属性的区别</h2>\n<p>普通的script:HTML 暂停解析，下载JS，执行JS，再继续解析HTML<br/> defer : HTML继续解析，并行下载JS，HTML解析完再执行JS<br/> async : HTML 继续解析，并行下载JS，执行JS同时中断解析html，js执行完，再解析HTML</p>\n<p>之所以把sctipt标签放在 &lt;/body&gt;前面的原因：让js在html解析完才开始加载 然后执行</p>\n<p>可以把 sctipt标签放在header中添加defer属性， 让js在html解析时并行加载 但是延迟执行，js会在html解析完才执行</p>\n<p></p>\n<p></p>\n<h2 id=\"27%EF%BC%8C%E7%A7%BB%E5%8A%A8%E7%AB%AFh5%E6%9C%89300%E6%AF%AB%E7%A7%92%E5%BB%B6%E8%BF%9F%EF%BC%8C%E8%AF%A5%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F\">27，移动端h5有300毫秒延迟，该如何解决？</h2>\n<p><img alt=\"\" height=\"577\" src=\"image\\5bbba485ccf048efab7a783d518b6b54.png\" width=\"1200\"/></p>\n<p> FastClick原理</p>\n<ul><li>监听touchend 事件( touchstart touchend会先于click触发)</li><li>使用自定义DOM事件模拟一个click 事件</li><li>把默认的click事件( 300ms之后触发）禁止掉</li></ul>\n<p><img alt=\"\" height=\"639\" src=\"image\\ccfa830aaf78488b88d9beaa70596c9b.png\" width=\"1200\"/></p>\n<p> mete中 使用content=\"width=device-width\"</p>\n<p></p>\n<h2 id=\"27%EF%BC%8Cprefetch%20%E5%92%8Cdns-prefetch%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%3F\">27，prefetch 和dns-prefetch有什么区别?</h2>\n<p><br/><strong>        preload和prefetch</strong></p>\n<ul><li>preload资源在当前页面使用，会优先加载</li><li>prefetch资源在未来页面使用，空闲时加载</li></ul>\n<p>他两都必须要用ink标签 引入 使用rel方式写</p>\n<p><img alt=\"\" height=\"902\" src=\"image\\718f59f1740d44dc9b7e5658e23a6148.png\" width=\"1200\"/></p>\n<p></p>\n<p><strong>       dns-prefetch 和preconnet</strong></p>\n<p>        dns：域名<br/>         dns-prefetch即 DNS 预查询<br/>         preconnect 即 DNS 预连接   </p>\n<p>对未来可能访问的页面 提前解析dns 查询到ip地址 进行tcp连接</p>\n<p><img alt=\"\" height=\"575\" src=\"image\\e54f236a0b6d48a2968f8f8f59eb684d.png\" width=\"1200\"/></p>\n<p></p>\n<p><strong>prefetch是资源预获取（和preload 相关)<br/> dns-prefetch是DNS 预查询(和preconnect相关)</strong></p>\n<h2></h2>\n<h2 id=\"28%EF%BC%8C%E5%89%8D%E7%AB%AF%E6%94%BB%E5%87%BB%E6%89%8B%E6%AE%B5%E6%9C%89%E5%93%AA%E4%BA%9B%3F%E8%AF%A5%E5%A6%82%E4%BD%95%E9%A2%84%E9%98%B2%3F\"><strong>28，前端攻击手段有哪些?该如何预防?</strong></h2>\n<p></p>\n<p><strong>XSS ：</strong>跨站脚本攻击<br/><strong>DDoS  ：</strong>分布式的、大规模的流量访问，使服务器瘫痪<br/><strong>CSRF  ：</strong>跨站请求伪造<br/><strong>SQL 注入<br/> 点击劫持</strong><br/>  </p>\n<h2></h2>\n<p><strong>1， xss</strong></p>\n<p>Cross Site Script跨站脚本攻击<br/> 手段∶<strong>黑客将JS代码插入到网页内容中，渲染时执行JS代码</strong><br/> 预防∶<strong>特殊字符替换（前端或者后端)</strong></p>\n<p>在页面中插入脚本script标签获取 页面信息 比如 cookie 、页面内容等等... 并使用image的<strong>src</strong>规避跨域， 将获取到的信息发送到 自己网站中收集起来<br/>  </p>\n<p><strong><img alt=\"\" height=\"664\" src=\"image\\ea1697e972db4f3091e6e9b0b56ed37b.png\" width=\"1132\"/></strong></p>\n<p><strong>防范方法：这里进行了特殊字符的替换 将 尖括号替换了 </strong></p>\n<p> <img alt=\"\" height=\"87\" src=\"image\\395d427216ff4b629aba238aff523276.png\" width=\"528\"/></p>\n<p><strong> vue和react中除了使用这两个标签插入脚本 其他情况默认屏蔽xss攻击</strong></p>\n<p><a href=\"https://blog.csdn.net/weixin_47450807/article/details/123207164\" title=\"XSS攻击详解_卖菜的小白的博客-CSDN博客_xss攻击代码\">XSS攻击详解_卖菜的小白的博客-CSDN博客_xss攻击代码</a></p>\n<p><strong>2，CSRF</strong><br/> Cross Site Request Forgery跨站请求伪造<br/> 手段:<strong>黑客诱导用户去访问另一个网站的接口，伪造请求</strong><br/> 预防︰<strong>严格的跨域限制＋验证码机制</strong><br/>  </p>\n<p><strong>CSRF 详细过程</strong><br/> 用户登录了A网站，有了cookie<br/> 黑客诱导用户到B网站，并发起A网站的请求<br/> A网站的API发现有cookie ，认为是用户自己操作的<br/><strong>严格跨域限制</strong><br/> 严格的跨域请求限制，如判断referrer（请求来源)<br/> 为cookie设置SameSite ，禁止跨域传递cookie</p>\n<p>关键接口使用短信验证码</p>\n<p><strong>3，点击劫持</strong></p>\n<p>Click Jacking<br/> 手段:诱导界面上蒙一个透明的iframe<br/> ，诱导用户点击<br/> 预防:让iframe不能跨域加载<br/>  </p>\n<p></p>\n<p>诱导界面上蒙一个透明的iframe 当用户点击抽奖时 ，点到的是关注：如下</p>\n<p><img alt=\"\" height=\"765\" src=\"image\\b83efdff95b64eec8a51e1ab3a7c581d.png\" width=\"1200\"/></p>\n<p><img alt=\"\" height=\"788\" src=\"image\\dc83457c56f84788a1742d7e6bc23b48.png\" width=\"1200\"/></p>\n<p></p>\n<p><strong>4，DDoS</strong><br/> Distribute denial-of-service分布式拒绝服务<br/> 手段:<strong>分布式的、大规模的流量访问，使服务器瘫痪</strong>。例如传播了几百万的木马病毒，然后控制这几百万台设备在某一时间点同时访问 </p>\n<p><br/> ◆预防:软件层不好做，需硬件预防（如阿里云 WAF )</p>\n<p></p>\n<p><strong>5， sql注入 </strong></p>\n<p>手段:<strong>黑客提交内容时写入SQL语句，破坏数据库</strong><br/> 预防∶处理输入的内容，替换特殊字符<br/>  </p>\n<p><img alt=\"\" height=\"357\" src=\"image\\492570c368f94b33812e5ffe717c3ac7.png\" width=\"1200\"/></p>\n<p> 登录提交时 用户名写入<img alt=\"\" height=\"33\" src=\"image\\7e727339089743f4aa28e66593d3b284.png\" width=\"251\"/></p>\n<p>导致 原本查询 用户名是否存在的 的语句<img alt=\"\" height=\"42\" src=\"image\\530bbae342844a4f99698ee55fa882a9.png\" width=\"561\"/></p>\n<p> 变成了<img alt=\"\" height=\"39\" src=\"image\\ef409fe94b7348688a5e08a65b2ed249.png\" width=\"693\"/></p>\n<p>使用；将语句隔开， 然后删除了 用户表， 并使用 --  注释了后面的内容</p>\n<p><strong> 预防方法： 使用字符串替换去掉单引号 或者--</strong></p>\n<p></p>\n<p><br/><br/>  </p>\n</div>\n</div>"}