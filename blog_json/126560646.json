{"blogid": "126560646", "writerAge": "码龄2年", "writerBlogNum": "42", "writerCollect": "36", "writerComment": "4", "writerFan": "7", "writerGrade": "3级", "writerIntegral": "436", "writerName": "江南、寻你", "writerProfileAdress": "writer_image\\profile_126560646.jpg", "writerRankTotal": "38637", "writerRankWeekly": "19042", "writerThumb": "13", "writerVisitNum": "27530", "blog_read_count": "432", "blog_time": "于 2022-08-27 17:48:50 发布", "blog_title": "Mybatis详解", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-light\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h1><a id=\"Mybatis_0\"></a>Mybatis</h1>\n<p>环境：</p>\n<ul><li>JDK1.8</li><li>Mysql 5.7</li><li>maven 3.6.1</li><li>IDEA</li></ul>\n<p>回顾：</p>\n<ul><li>JDBC</li><li>Mysql</li><li>Java基础</li><li>maven</li><li>Junit</li></ul>\n<p>框架：都有配置文件的。最好的方式：看官网文档</p>\n<p>https://mybatis.org/mybatis-3/zh/</p>\n<h2><a id=\"1_25\"></a>1、简介</h2>\n<h3><a id=\"11_Mybatis_27\"></a>1.1 什么是Mybatis</h3>\n<ul><li> <p>MyBatis 是一款优秀的持久层框架</p> </li><li> <p>它支持自定义 SQL、存储过程以及高级映射。</p> </li><li> <p>MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。</p> </li><li> <p>MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</p> </li><li> <p>MyBatis本是apache的一个<a href=\"https://baike.baidu.com/item/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/3406069\">开源项目</a>iBatis，2010年这个<a href=\"https://baike.baidu.com/item/%E9%A1%B9%E7%9B%AE/477803\">项目</a>由apache software foundation迁移到了[google code](https://baike.baidu.com/item/google code/2346604)，并且改名为MyBatis。2013年11月迁移到<a href=\"https://baike.baidu.com/item/Github/10145341\">Github</a>。</p> </li><li> <p>iBATIS一词来源于“internet”和“abatis”的组合，是一个基于Java的<a href=\"https://baike.baidu.com/item/%E6%8C%81%E4%B9%85%E5%B1%82/3584971\">持久层</a>框架。iBATIS提供的持久层框架包括SQL Maps和Data Access Objects（DAOs）。</p> </li></ul>\n<p>如何获得Mybatis？</p>\n<ul><li> <p>maven仓库：https://mvnrepository.com/</p> <pre><code>&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;\n    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;\n    &lt;version&gt;3.5.10&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> </li><li> <p>Github：https://github.com/mybatis/mybatis-3/releases</p> </li><li> <p>中文文档：https://mybatis.org/mybatis-3/zh/</p> </li></ul>\n<h3><a id=\"12__60\"></a>1.2 持久化</h3>\n<p>数据持久化</p>\n<ul><li> <p>持久化就是将程序的数据在持久状态和瞬时状态转化的过程</p> </li><li> <p>内存：断电即失</p> </li><li> <p>数据库（jdbc），io文件持久化</p> </li><li> <p>生活：冷藏</p> </li></ul>\n<p>为什么需要持久化？</p>\n<ul><li>有一些对象不能让它丢掉</li><li>内存太贵了</li></ul>\n<h3><a id=\"13__77\"></a>1.3 持久层</h3>\n<p>Dao层，Service层，Controller层 …</p>\n<ul><li>完成持久化工作的代码块</li><li>层界限十分明显</li></ul>\n<h3><a id=\"14_Mybatis_86\"></a>1.4 为什么需要Mybatis？</h3>\n<ul><li> <p>帮助程序员将数据存入数据库中</p> </li><li> <p>方便</p> </li><li> <p>传统的JDBC代码太复杂了。简化。框架。自动化</p> </li><li> <p>不用Mybatis也可以。更容易上手。技术没有高低之分</p> </li></ul>\n<p>优点：</p>\n<ul><li> <p>简单易学：本身就很小且简单。没有任何第三方依赖，最简单安装只要两个jar文件+配置几个sql映射文件。易于学习，易于使用。通过文档和源代码，可以比较完全的掌握它的设计思路和实现。</p> </li><li> <p>灵活：mybatis不会对应用程序或者数据库的现有设计强加任何影响。 sql写在xml里，便于统一管理和优化。通过sql语句可以满足操作数据库的所有需求。</p> </li><li> <p>解除sql与程序代码的耦合：通过提供DAO层，将业务逻辑和数据访问逻辑分离，使系统的设计更清晰，更易维护，更易单元测试。sql和代码的分离，提高了可维护性。</p> </li><li> <p>提供映射标签，支持对象与数据库的orm字段关系映射。</p> </li><li> <p>提供对象关系映射标签，支持对象关系组建维护。</p> </li><li> <p>提供xml标签，支持编写动态sql</p> </li></ul>\n<p>最重要的一点：使用的人多！</p>\n<h2><a id=\"2Mybatis_110\"></a>2、第一个Mybatis程序</h2>\n<p>思路：搭建环境——》导入Mybatis——》编写代码——》测试</p>\n<h3><a id=\"21__114\"></a>2.1 搭建环境</h3>\n<ol><li>搭建数据库</li></ol>\n<pre><code>CREATE DATABASE if NOT EXISTS `mybatis`;\nUSE `mybatis`;\nCREATE TABLE `user`(\n  `id` INT(10) NOT NULL COMMENT '用户id',\n\t`name` VARCHAR(50) NOT NULL COMMENT '用户名',\n\t`pwd` VARCHAR(50) NOT NULL COMMENT '密码',\n\tPRIMARY KEY(`id`)\n)ENGINE=INNODB DEFAULT CHARSET=utf8;\nINSERT INTO `user`(`id`,`name`,`pwd`) \nVALUES(1,'张三','123456'),\n(2,'李四','123456'),\n(3,'王五','123456');\n</code></pre>\n<ol start=\"2\"><li> <p>在IDEA新建项目（父工程）</p> <p><img alt=\"image-20220731185146469\" src=\"image\\f68ddf66f98789849200e781aa75c3a2.png\"/></p> </li><li> <p>删除src目录</p> </li><li> <p>导入maven依赖</p> <pre><code>&lt;!--导入依赖--&gt;\n&lt;!--1、mysql驱动--&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;mysql&lt;/groupId&gt;\n    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n    &lt;version&gt;5.1.47&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;!--2、mybatis--&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;\n    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;\n    &lt;version&gt;3.5.10&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;!--3、junit--&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;junit&lt;/groupId&gt;\n    &lt;artifactId&gt;junit&lt;/artifactId&gt;\n    &lt;version&gt;4.12&lt;/version&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre> </li></ol>\n<h3><a id=\"22__164\"></a>2.2 创建一个模块（子工程）</h3>\n<p><img alt=\"image-20220731185338805\" src=\"image\\ce467b527a1a154714589198003fdc9a.png\"/></p>\n<ul><li> <p>编写mybstis核心配置文件：mybatis-config.xml</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;\n&lt;!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;\n\n&lt;!--configuration：核心配置文件--&gt;\n&lt;configuration&gt;\n    &lt;environments default=\"development\"&gt;\n        &lt;environment id=\"development\"&gt;\n            &lt;transactionManager type=\"JDBC\"/&gt;\n            &lt;dataSource type=\"POOLED\"&gt;\n                &lt;property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/&gt;\n                &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf-8&amp;amp;serverTimezone=UTC\"/&gt;\n                &lt;property name=\"username\" value=\"root\"/&gt;\n                &lt;property name=\"password\" value=\"123456\"/&gt;\n            &lt;/dataSource&gt;\n        &lt;/environment&gt;\n    &lt;/environments&gt;\n&lt;/configuration&gt;\n</code></pre> <p><img alt=\"image-20220731185405483\" src=\"image\\af7d04c644fe9006cc125ebf1854c312.png\"/></p> </li><li> <p>编写mybatis工具类</p> </li></ul>\n<pre><code>package com.shu.utils;\n\nimport org.apache.ibatis.io.Resources;\nimport org.apache.ibatis.session.SqlSession;\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\n\nimport java.io.IOException;\nimport java.io.InputStream;\n\n//工具类  SqlSessionFactory ——&gt;SqlSession\npublic class MybatisUtils {\n    //提升作用域\n    public static SqlSessionFactory sqlSessionFactory;\n\n    static {\n        try {\n            //使用mybatis第一步：获取SqlSessionFactory对象\n            String resource = \"mybatis-config.xml\";\n            InputStream inputStream = Resources.getResourceAsStream(resource);\n            sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    //既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。\n    // SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。\n    public static SqlSession getSqlSession(){\n        /* \n        SqlSession sqlSession = sqlSessionFactory.openSession();\n        return sqlSession;\n        */\n        \n        //优化代码\n        return sqlSessionFactory.openSession();\n    }\n}\n</code></pre>\n<h3><a id=\"23__236\"></a>2.3 编写代码</h3>\n<ul><li> <p>实体类</p> <pre><code>package com.shu.pojo;\n\n//实体类\npublic class user {\n    private int id;\n    private String name;\n    private String pwd;\n\n    public user() {\n    }\n\n    public user(int id, String name, String pwd) {\n        this.id = id;\n        this.name = name;\n        this.pwd = pwd;\n    }\n\n    public int getId() {\n        return id;\n    }\n\n    public void setId(int id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getPwd() {\n        return pwd;\n    }\n\n    public void setPwd(String pwd) {\n        this.pwd = pwd;\n    }\n\n    @Override\n    public String toString() {\n        return \"user{\" +\n                \"id=\" + id +\n                \", name='\" + name + '\\'' +\n                \", pwd='\" + pwd + '\\'' +\n                '}';\n    }\n}\n</code></pre> </li><li> <p>Dao接口</p> <pre><code>package com.shu.dao;\n\nimport com.shu.pojo.User;\n\nimport java.util.List;\n\n//UserDao等价于Mapper\npublic interface UserDao {\n    //返回值类型：User（获取用户）\n    List&lt;User&gt; getUserList();  //获取所有用户\n}\n</code></pre> </li><li> <p>接口实现类UserMapper.xml：由原来的Impl转换为一个Mapper配置文件</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;\n&lt;!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;\n\n&lt;!--namespace:绑定一个对应的Dao/Mapper接口--&gt;\n&lt;mapper namespace=\"com.shu.dao.UserDao\"&gt;\n    &lt;!--select查询语句--&gt;\n    //id=\"getUserList\":接口中的方法名      resultType=\"com.shu.pojo.User\"：返回类型\n    &lt;select id=\"getUserList\" resultType=\"com.shu.pojo.User\"&gt;\n        select * from mybatis.user\n    &lt;/select&gt;\n&lt;/mapper&gt;\n</code></pre> </li></ul>\n<blockquote>\n<p><strong>提示</strong> ：<strong>对命名空间的一点补充</strong></p>\n<p>在之前版本的 MyBatis 中，**命名空间（Namespaces）**的作用并不大，是可选的。 但现在，随着命名空间越发重要，你必须指定命名空间。</p>\n<p>命名空间的作用有两个，一个是利用更长的全限定名来将不同的语句隔离开来，同时也实现了你上面见到的接口绑定。就算你觉得暂时用不到接口绑定，你也应该遵循这里的规定，以防哪天你改变了主意。 长远来看，只要将命名空间置于合适的 Java 包命名空间之中，你的代码会变得更加整洁，也有利于你更方便地使用 MyBatis。</p>\n<p>**命名解析：**为了减少输入量，MyBatis 对所有具有名称的配置元素（包括语句，结果映射，缓存等）使用了如下的命名解析规则。</p>\n<ul><li>全限定名（比如 “com.mypackage.MyMapper.selectAllThings）将被直接用于查找及使用。</li><li>短名称（比如 “selectAllThings”）如果全局唯一也可以作为一个单独的引用。 如果不唯一，有两个或两个以上的相同名称（比如 “com.foo.selectAllThings” 和 “com.bar.selectAllThings”），那么使用时就会产生“短名称不唯一”的错误，这种情况下就必须使用全限定名。</li></ul>\n</blockquote>\n<h3><a id=\"24__338\"></a>2.4 测试</h3>\n<ul><li> <p>编写进行junit测试（会报错）</p> <pre><code>package com.shu.dao;\n\nimport com.shu.pojo.User;\nimport com.shu.utils.MybatisUtils;\nimport org.apache.ibatis.session.SqlSession;\nimport org.junit.Test;\n\nimport java.util.List;\n\npublic class UserDaoTest {\n    @Test\n    public void test(){\n        //第一步：获取SqlSession对象\n        SqlSession sqlSession = MybatisUtils.getSqlSession();\n        //方式一：getMapper（执行SQL）  最新推荐！！！\n        /*UserDao userDao = sqlSession.getMapper(UserDao.class);\n        List&lt;User&gt; userList = userDao.getUserList();*/\n\n        //方式二：   原来的,不推荐使用！\n        //List&lt;Object&gt; objects = sqlSession.selectList(\"com.shu.dao.UserDao.getUserList\");\n        //对上面代码进行类型转换（强转）\n        List&lt;User&gt; userList = sqlSession.selectList(\"com.shu.dao.UserDao.getUserList\");\n\n        for (User user : userList) {\n            System.out.println(user);\n        }\n\n        //关闭SqlSession\n        sqlSession.close();\n    }\n}\n\n//官方建议\npackage com.shu.dao;\n\nimport com.shu.pojo.User;\nimport com.shu.utils.MybatisUtils;\nimport org.apache.ibatis.session.SqlSession;\nimport org.junit.Test;\n\nimport java.util.List;\n\npublic class UserDaoTest {\n    @Test\n    public void test(){\n        //第一步：获取SqlSession对象\n        SqlSession sqlSession = MybatisUtils.getSqlSession();\n\n        try{\n            //方式一：getMapper（执行SQL）  最新推荐！！！\n            /*UserDao userDao = sqlSession.getMapper(UserDao.class);\n            List&lt;User&gt; userList = userDao.getUserList();*/\n\n            //方式二：   原来的,不推荐使用！\n            //List&lt;Object&gt; objects = sqlSession.selectList(\"com.shu.dao.UserDao.getUserList\");\n            //对上面代码进行类型转换（强转）\n            List&lt;User&gt; userList = sqlSession.selectList(\"com.shu.dao.UserDao.getUserList\");\n\n            for (User user : userList) {\n                System.out.println(user);\n            }\n        }catch(Exception e){\n            e.printStackTrace();\n        }finally {\n            //关闭SqlSession\n            sqlSession.close();\n        }\n    }\n}\n\n</code></pre> </li></ul>\n<p><img alt=\"image-20220731190100217\" src=\"image\\c2b14a1b1087f2a8f9f67df535f3f50f.png\"/></p>\n<blockquote>\n<p>报错1：配置文件没有注册问题</p>\n<p>org.apache.ibatis.binding.BindingException: Type interface com.shu.dao.UserDao is not known to the MapperRegistry.</p>\n<p>MapperRegistry是什么？</p>\n</blockquote>\n<p>解决方案：在mybatis-config.xml文件中加入MapperRegistry部分代码</p>\n<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;\n&lt;!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;\n\n&lt;!--configuration：核心配置文件--&gt;\n&lt;configuration&gt;\n    &lt;environments default=\"development\"&gt;\n        &lt;environment id=\"development\"&gt;\n            &lt;transactionManager type=\"JDBC\"/&gt;\n            &lt;dataSource type=\"POOLED\"&gt;\n                &lt;property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/&gt;\n                &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf-8&amp;amp;serverTimezone=UTC\"/&gt;\n                &lt;property name=\"username\" value=\"root\"/&gt;\n                &lt;property name=\"password\" value=\"123456\"/&gt;\n            &lt;/dataSource&gt;\n        &lt;/environment&gt;\n    &lt;/environments&gt;\n    \n    &lt;!--每一个Mapper.xml都需要在Mybatis的核心配置文件中注册            MapperRegistry       --&gt;\n    &lt;mappers&gt;\n        &lt;mapper resource=\"com/shu/dao/UserMapper.xml\"/&gt;\n    &lt;/mappers&gt;\n    \n&lt;/configuration&gt;\n</code></pre>\n<blockquote>\n<p>报错2：</p>\n<p>maven报错：maven导出资源问题</p>\n</blockquote>\n<pre><code>java.lang.ExceptionInInitializerError\n\tat com.shu.dao.UserDaoTest.test(UserDaoTest.java:14)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)\n\tat org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\n\tat org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)\n\tat org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)\n\tat org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)\n\tat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)\n\tat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:363)\n\tat org.junit.runner.JUnitCore.run(JUnitCore.java:137)\n\tat com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:69)\n\tat com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:33)\n\tat com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:221)\n\tat com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:54)\nCaused by: org.apache.ibatis.exceptions.PersistenceException: \n### Error building SqlSession.\n### The error may exist in com/shu/dao/UserMapper.xml\n### Cause: org.apache.ibatis.builder.BuilderException: Error parsing SQL Mapper Configuration. Cause: java.io.IOException: Could not find resource com/shu/dao/UserMapper.xml\n\tat org.apache.ibatis.exceptions.ExceptionFactory.wrapException(ExceptionFactory.java:30)\n\tat org.apache.ibatis.session.SqlSessionFactoryBuilder.build(SqlSessionFactoryBuilder.java:82)\n\tat org.apache.ibatis.session.SqlSessionFactoryBuilder.build(SqlSessionFactoryBuilder.java:66)\n\tat com.shu.utils.MybatisUtils.&lt;clinit&gt;(MybatisUtils.java:21)\n\t... 23 more\nCaused by: org.apache.ibatis.builder.BuilderException: Error parsing SQL Mapper Configuration. Cause: java.io.IOException: Could not find resource com/shu/dao/UserMapper.xml\n\tat org.apache.ibatis.builder.xml.XMLConfigBuilder.parseConfiguration(XMLConfigBuilder.java:122)\n\tat org.apache.ibatis.builder.xml.XMLConfigBuilder.parse(XMLConfigBuilder.java:99)\n\tat org.apache.ibatis.session.SqlSessionFactoryBuilder.build(SqlSessionFactoryBuilder.java:80)\n\t... 25 more\nCaused by: java.io.IOException: Could not find resource com/shu/dao/UserMapper.xml\n\tat org.apache.ibatis.io.Resources.getResourceAsStream(Resources.java:114)\n\tat org.apache.ibatis.io.Resources.getResourceAsStream(Resources.java:100)\n\tat org.apache.ibatis.builder.xml.XMLConfigBuilder.mapperElement(XMLConfigBuilder.java:378)\n\tat org.apache.ibatis.builder.xml.XMLConfigBuilder.parseConfiguration(XMLConfigBuilder.java:120)\n\t... 27 more\n</code></pre>\n<p>解决方案：在父工程的pom.xml文件中加入以下代码</p>\n<pre><code>&lt;!--maven资源过滤问题：在build中配置resources，来防止我们资源导出失败的问题--&gt;\n&lt;build&gt;\n&lt;resources&gt;\n    &lt;resource&gt;\n        &lt;directory&gt;src/main/resources&lt;/directory&gt;\n        &lt;includes&gt;\n            &lt;include&gt;**/*.properties&lt;/include&gt;\n            &lt;include&gt;**/*.xml&lt;/include&gt;\n        &lt;/includes&gt;\n        &lt;filtering&gt;true&lt;/filtering&gt;\n    &lt;/resource&gt;\n    &lt;resource&gt;\n        &lt;directory&gt;src/main/java&lt;/directory&gt;\n        &lt;includes&gt;\n             &lt;include&gt;**/*.properties&lt;/include&gt;\n             &lt;include&gt;**/*.xml&lt;/include&gt;\n        &lt;/includes&gt;\n        &lt;filtering&gt;true&lt;/filtering&gt;\n    &lt;/resource&gt;\n&lt;/resources&gt;\n&lt;/build&gt;\n</code></pre>\n<blockquote>\n<p>报错3：编码不一致问题</p>\n<p>org.apache.ibatis.builder.BuilderException: Error creating document instance.</p>\n<p>这个问题的主要原因是xml文件中声明的编码与xml文件本身保存时的编码不一致。 比如:你的声明是</p> &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; \n <p>但是却以ANSI格式编码保存，尽管并没有乱码出现，但是xml解析器是无法解析的。 解决办法就是重新设置xml文件保存时的编码与声明的一致。</p>\n<p>ps：pom.xml添加代码若运行成功后，删除添加的代码，依然能再次运行成功！</p>\n</blockquote>\n<p>解决方案：在pom.<a href=\"https://so.csdn.net/so/search?q=xml&amp;spm=1001.2101.3001.7020\">xml</a>文件中添加如下代码：</p>\n<pre><code class=\"prism language-XML\">    &lt;properties&gt;\n        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;\n        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;\n        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n    &lt;/properties&gt;\n</code></pre>\n<ul><li> <p>避坑之后，测试成功</p> <p><img alt=\"image-20220731190314237\" src=\"image\\b6473d18347d209bc387389b883a472c.png\"/></p> </li></ul>\n<p>总结：</p>\n<p><img alt=\"image-20220731193534642\" src=\"image\\3e822b8720f2b398339bbab38b0df850.png\"/></p>\n<h2><a id=\"3CRUD_559\"></a>3、CRUD</h2>\n<h3><a id=\"31_namespace_561\"></a>3.1 namespace</h3>\n<p>namespace中的包名要和Dao/Mapper接口中的包名保持一致！</p>\n<h3><a id=\"32_select_565\"></a>3.2 select</h3>\n<p>选择，查询语句</p>\n<ul><li>id：就是对应的namespace中的方法名</li><li>resultType：SQL语句执行的返回值！</li><li>parameterType：参数类型</li></ul>\n<ol><li> <p>编写接口</p> <pre><code>//根据id查询用户\nUser getUserById(int id);\n</code></pre> </li><li> <p>编写对应的UserMapper.xml中的sql语句</p> <pre><code>&lt;!--根据id查询用户--&gt;\n&lt;select id=\"getUserById\" resultType=\"com.shu.pojo.User\" parameterType=\"int\"&gt;\n    select * from mybatis.user where id=#{id}\n&lt;/select&gt;\n</code></pre> </li><li> <p>测试</p> <pre><code>/*\n根据id查询用户\n*/\n@Test\npublic void getUserByIdTest(){\n    //获取执行sqlSession对象\n    SqlSession sqlSession = MybatisUtils.getSqlSession();\n    //获取接口\n    UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n    User user = mapper.getUserById(2);\n    System.out.println(user);\n\n    //关闭sqlSession\n    sqlSession.close();\n}\n</code></pre> </li></ol>\n<h3><a id=\"33_insert_609\"></a>3.3 insert</h3>\n<ol><li> <p>编写接口</p> <pre><code>//insert一个用户\nint addUser(User user);\n</code></pre> </li><li> <p>编写对应的UserMapper.xml中的sql语句</p> <pre><code>&lt;!--insert一个用户--&gt;\n&lt;insert id=\"addUser\" parameterType=\"com.shu.pojo.User\"&gt;\n    insert into mybatis.user (id,name,pwd) value (#{id},#{name},#{pwd})\n&lt;/insert&gt;\n</code></pre> </li><li> <p>测试</p> <pre><code>/*\ninsert一个用户\n注意：增删改需要提交事务\n*/\n@Test\npublic void addUser(){\n    SqlSession sqlSession = MybatisUtils.getSqlSession();\n    UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n    //User user = new User(4, \"小舒\", \"123456\");\n\n    int res = mapper.addUser(new User(4, \"小舒\", \"123456\"));\n    if(res&gt;0){\n        System.out.println(\"插入成功！\");\n    }\n\n    //提交事务,不提交则不会持久化到数据库\n    sqlSession.commit();\n\n    sqlSession.close();\n}\n</code></pre> </li></ol>\n<h3><a id=\"34_update_652\"></a>3.4 update</h3>\n<ol><li> <p>编写接口</p> <pre><code>//修改一个用户\nint updateUser(User user);\n</code></pre> </li><li> <p>编写对应的UserMapper.xml中的sql语句</p> <pre><code>&lt;!--update一个用户--&gt;\n&lt;update id=\"updateUser\" parameterType=\"com.shu.pojo.User\"&gt;\n    update mybatis.user set name=#{name},pwd=#{pwd} where id=#{id}\n&lt;/update&gt;\n</code></pre> </li><li> <p>测试</p> <pre><code>/*\nupdate一个用户\n注意：增删改需要提交事务\n*/\n@Test\npublic void updateUser(){\n    SqlSession sqlSession = MybatisUtils.getSqlSession();\n    UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n\n    int res = mapper.updateUser(new User(4, \"xiaoshu\", \"123456\"));\n    if(res&gt;0){\n        System.out.println(\"更新成功！\");\n    }\n    //提交事务,不提交则不会持久化到数据库\n    sqlSession.commit();\n\n    sqlSession.close();\n}\n</code></pre> </li></ol>\n<h3><a id=\"35_delete_693\"></a>3.5 delete</h3>\n<ol><li> <p>编写接口</p> <pre><code>&lt;!--删除一个用户--&gt;\n&lt;delete id=\"deleteUser\" parameterType=\"int\"&gt;\n    delete from mybatis.user where id=#{id}\n&lt;/delete&gt;\n</code></pre> </li><li> <p>编写对应的UserMapper.xml中的sql语句</p> <pre><code>&lt;!--删除一个用户--&gt;\n&lt;delete id=\"deleteUser\" parameterType=\"int\"&gt;\n    delete from mybatis.user where id=#{id}\n&lt;/delete&gt;\n</code></pre> </li><li> <p>测试</p> <pre><code>/*\n删除一个用户\n */\n@Test\npublic void deleteUser(){\n    SqlSession sqlSession = MybatisUtils.getSqlSession();\n\n    UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n    int res = mapper.deleteUser(4);\n    if(res&gt;0){\n        System.out.println(\"删除成功！\");\n    }\n    sqlSession.commit();\n    sqlSession.close();\n}\n</code></pre> </li></ol>\n<p>注意点：</p>\n<ul><li>增删改需要提交事务</li><li>标签不要匹配错</li><li>resource绑定mapper，需要使用路径！</li><li>程序配置文件必须符合规范</li><li>maven资源导出问题</li></ul>\n<h3><a id=\"36_Map_741\"></a>3.6 万能的Map</h3>\n<p>假设我们的实体类，或者数据库中的表、字段或者参数过多，我们应当考虑使用Map！</p>\n<pre><code>//万能的Map\nint addUser2(Map&lt;String,Object&gt; map);\n</code></pre>\n<pre><code>&lt;!--万能的Map--&gt;\n&lt;insert id=\"addUser2\" parameterType=\"map\"&gt;\n    insert into mybatis.user (id,name,pwd) value (#{userid},#{userName},#{passWord})\n&lt;/insert&gt;\n</code></pre>\n<pre><code>@Test\npublic void addUser2(){\n    SqlSession sqlSession = MybatisUtils.getSqlSession();\n    UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n    Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();\n    map.put(\"userid\",5);\n    map.put(\"userName\",\"小舒\");\n    map.put(\"passWord\",\"123456\");\n    int res = mapper.addUser2(map);\n    if(res&gt;0){\n        System.out.println(\"插入成功！\");\n    }\n\n    //提交事务,不提交则不会持久化到数据库\n    sqlSession.commit();\n\n    sqlSession.close();\n}\n</code></pre>\n<p>Map传递参数，直接在sql中取出key即可！ 【parameterType=“map”】</p>\n<p>对象传递参数，直接在sql中取对象的属性即可！ 【parameterType=“object”】</p>\n<p>只有一个基本类型参数的情况下，可以直接在sql中取到！</p>\n<p>多个参数用Map，或者注解！</p>\n<h3><a id=\"37__786\"></a>3.7 思考题</h3>\n<p>模糊查询怎么写？</p>\n<pre><code>//模糊查询一个用户\nList&lt;User&gt; getUserLike(String value);\n</code></pre>\n<pre><code>&lt;!--模糊查询一个用户--&gt;\n&lt;select id=\"getUserLike\" resultType=\"com.shu.pojo.User\"&gt;\n    select * from mybatis.user where name like #{value}\n&lt;/select&gt;\n</code></pre>\n<pre><code>&lt;!--模糊查询一个用户--&gt;\n@Test\npublic void getUserLike(){\n    SqlSession sqlSession = MybatisUtils.getSqlSession();\n    UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n    List&lt;User&gt; userList = mapper.getUserLike(\"%李%\");\n    for (User user : userList) {\n        System.out.println(user);\n    }\n\n    sqlSession.close();\n}\n</code></pre>\n<ol><li> <p>java代码执行的时候，传递通配符%</p> <pre><code>List&lt;User&gt; userList = mapper.getUserLike(\"%李%\");\n</code></pre> </li><li> <p>在sql拼接中使用通配符！</p> <pre><code>select * from mybatis.user where name like \"%\"#{value}*\"%\"\n</code></pre> </li></ol>\n<h2><a id=\"4_829\"></a>4、配置解析</h2>\n<h3><a id=\"41__831\"></a>4.1 核心配置文件</h3>\n<ul><li>mybatis-config.xml</li><li>MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。</li></ul>\n<pre><code>//在xml中，所有的标签都可以规定其顺序\nconfiguration（配置）\nproperties（属性）\nsettings（设置）\ntypeAliases（类型别名）\ntypeHandlers（类型处理器）\nobjectFactory（对象工厂）\nplugins（插件）\nenvironments（环境配置）\nenvironment（环境变量）\ntransactionManager（事务管理器）\ndataSource（数据源）\ndatabaseIdProvider（数据库厂商标识）\nmappers（映射器）\n</code></pre>\n<p><img alt=\"image-20220821114356935\" src=\"image\\609d520168fadb7e5d5610d187f0b604.png\"/></p>\n<h3><a id=\"42_environments_855\"></a>4.2 环境配置（environments）</h3>\n<p>MyBatis 可以配置成适应多种环境，学会使用多套运行环境！</p>\n<p><strong>不过要记住：尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境。</strong></p>\n<p>Mybatis默认的事务管理器就是JDBC，连接池：POOLED</p>\n<h3><a id=\"43_properties_863\"></a>4.3 属性（properties）</h3>\n<p>我们可以通过properties属性来实现引用配置文件</p>\n<p>这些属性可以在外部进行配置，并可以进行动态替换。你既可以在典型的 Java 属性文件中配置这些属性，也可以在 properties 元素的子元素中设置。【db.properties】</p>\n<p>编写一个配置文件db.properties</p>\n<pre><code>driver=com.mysql.jdbc.Driver\nurl=jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=UTC\nusername=root\npassword=123456\n</code></pre>\n<p>在核心配置文件中引入</p>\n<pre><code>&lt;!--引入外部配置文件：db.properties直接在resource路径下就不用写路径了--&gt;\n&lt;properties resource=\"db.properties\"&gt;\n    &lt;property name=\"username\" value=\"root\"/&gt;\n    &lt;property name=\"password\" value=\"111111\"/&gt;\n&lt;/properties&gt;\n</code></pre>\n<ul><li>可以直接引入外部文件</li><li>可以在其中增加一些属性配置</li><li>如果两个文件有同一个字段，优先使用外部配置文件的！</li></ul>\n<h3><a id=\"44_typeAliases_892\"></a>4.4 类型别名（typeAliases）</h3>\n<p>类型别名可为 Java 类型设置一个缩写名字。 它仅用于 XML 配置，意在降低冗余的全限定类名书写。</p>\n<pre><code>&lt;!--可以给实体类起别名--&gt;\n&lt;typeAliases&gt;\n    &lt;typeAlias type=\"com.shu.pojo.User\" alias=\"User\"/&gt;\n&lt;/typeAliases&gt;\n</code></pre>\n<pre><code>&lt;!--获取所有用户--&gt;\n&lt;select id=\"getUserList\" resultType=\"User\"&gt;\n    select * from mybatis.user\n&lt;/select&gt;\n</code></pre>\n<p>也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，比如：</p>\n<p>扫描实体类的包，它的默认别名就为这个类的类名，首字母小写！</p>\n<pre><code>&lt;!--可以给实体类起别名--&gt;\n&lt;typeAliases&gt;\n    &lt;package name=\"com.shu.pojo\"/&gt;\n&lt;/typeAliases&gt;\n</code></pre>\n<pre><code>&lt;!--获取所有用户--&gt;\n&lt;select id=\"getUserList\" resultType=\"user\"&gt;\n    select * from mybatis.user\n&lt;/select&gt;\n</code></pre>\n<p>在实体类比较少的时候，使用第一种方式</p>\n<p>如果实体类十分多，建议使用第二种！</p>\n<p>区别：</p>\n<p>第一种可以DIY（自定义别名），第二种则不行（没有注解的情况下；有注解的情况下可以通过注解指定别名）</p>\n<pre><code>&lt;!--可以给实体类起别名--&gt;\n&lt;typeAliases&gt;\n    &lt;package name=\"com.shu.pojo\"/&gt;\n&lt;/typeAliases&gt;\n</code></pre>\n<pre><code>@Alias(\"hello\")\npublic class User {\n    ...\n}\n</code></pre>\n<pre><code>&lt;!--获取所有用户--&gt;\n&lt;select id=\"getUserList\" resultType=\"hello\"&gt;\n    select * from mybatis.user\n&lt;/select&gt;\n</code></pre>\n<h3><a id=\"45_settings_959\"></a>4.5 设置（settings）</h3>\n<p>这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。</p>\n<p><img alt=\"image-20220821133555812\" src=\"image\\bb127c3ce9bee3a43186cb89542fb6a3.png\"/></p>\n<p><img alt=\"image-20220821133509855\" src=\"image\\84bb37ac922c2b391551b9ddd142910a.png\"/></p>\n<h3><a id=\"46__967\"></a>4.6 其他配置</h3>\n<p>typeHandlers（类型处理器）<br/> objectFactory（对象工厂）<br/> plugins（插件）</p>\n<ul><li>MyBatis Generator Core</li><li>MyBatis Plus：mybatis的增强工具</li><li>通用Mapper</li></ul>\n<h3><a id=\"47_mappers_977\"></a>4.7 映射器（mappers）</h3>\n<p>MapperRegistry：注册绑定我们的Mapper文件</p>\n<p>方式一：【推荐使用】大多情况下，写一个注册绑定一个</p>\n<pre><code>&lt;!--每一个Mapper.xml都需要在Mybatis的核心配置文件中注册--&gt;\n&lt;mappers&gt;\n    &lt;mapper resource=\"com/shu/dao/UserMapper.xml\"/&gt;\n&lt;/mappers&gt;\n</code></pre>\n<p>方式二：使用class文件绑定注册</p>\n<pre><code>&lt;!--每一个Mapper.xml都需要在Mybatis的核心配置文件中注册--&gt;\n&lt;mappers&gt;\n    &lt;mapper class=\"com.shu.dao.UserMapper\"/&gt;\n&lt;/mappers&gt;\n</code></pre>\n<p>注意：UserMapper和UserMapper.xml必须同名，并且需要在一个包下，否则会报错</p>\n<p><img alt=\"image-20220821135232466\" src=\"image\\51b0b942567c72d04bc39fb4d20f963e.png\"/></p>\n<p>方式三：使用扫描包进行绑定注入</p>\n<pre><code>&lt;!--每一个Mapper.xml都需要在Mybatis的核心配置文件中注册--&gt;\n&lt;mappers&gt;\n    &lt;package name=\"com.shu.dao\"/&gt;\n&lt;/mappers&gt;\n</code></pre>\n<p>注意：UserMapper和UserMapper.xml必须同名，并且需要在一个包下，否则会报错</p>\n<h3><a id=\"48_Scope_1014\"></a>4.8 作用域（Scope）和生命周期</h3>\n<p>生命周期和作用域是至关重要的，因为错误的使用会导致非常严重的<strong>并发问题</strong>。</p>\n<p><img alt=\"image-20220821165555667\" src=\"image\\47ba20315b501a739d5cfbca01b8b72d.png\"/></p>\n<p><strong>SqlSessionFactoryBuilder：</strong></p>\n<ul><li> <p>这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。</p> </li><li> <p>局部变量</p> </li></ul>\n<p><strong>SqlSessionFactory：</strong></p>\n<ul><li>SqlSessionFactory说白了就是可以想象成：数据库连接池</li><li>SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。</li><li>因此 SqlSessionFactory 的最佳作用域是应用作用域。有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。</li></ul>\n<p><strong>SqlSession:</strong></p>\n<ul><li>连接到连接池的的一个请求！</li><li>SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。</li><li>用完之后需要赶紧关闭，否则资源被占用！</li></ul>\n<p><img alt=\"image-20220821165952309\" src=\"image\\8311a2a0004d9e9b31aa37cbdb694b89.png\"/></p>\n<p>这里面的每一个Mapper，就代表具体的业务！</p>\n<h2><a id=\"5ResultMap_1042\"></a>5、ResultMap结果集映射</h2>\n<p>解决属性名和字段名不一致的问题</p>\n<h3><a id=\"51__1046\"></a>5.1 问题</h3>\n<p>数据库中的字段</p>\n<p><img alt=\"image-20220821170338564\" src=\"image\\187c50f9d72eade08c93b6fbdaf958ab.png\"/></p>\n<p>新建一个项目，拷贝之前的，测试实体类字段不一致的情况</p>\n<pre><code>//实体类\npublic class User {\n    private int id;\n    private String name;\n    private String password;\n    }\n</code></pre>\n<p><img alt=\"image-20220821171357299\" src=\"image\\db9cf33fb10d6090596086484bcaad0d.png\"/></p>\n<p>进行功能测试出现问题</p>\n<pre><code>@Test\npublic void getUserList(){\n    SqlSession sqlSession = MybatisUtils.getSqlSession();\n    UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n\n    System.out.println(mapper.getUserById(2));\n        \n    sqlSession.close();\n}\n</code></pre>\n<p><img alt=\"image-20220821171817358\" src=\"image\\8ec833905ae1275a15dfd7500995b9ca.png\"/></p>\n<pre><code>select * from mybatis.user where id=#{id}\n\n&lt;!--\n类型处理器，完整查询语句：\nselect id,name,pwd from mybatis.user where id=#{id}\n--&gt;\n</code></pre>\n<p>解决方法：</p>\n<ul><li> <p>起别名</p> <pre><code>&lt;!--根据id查询用户--&gt;\n    &lt;select id=\"getUserById\" resultType=\"com.shu.pojo.User\" parameterType=\"int\"&gt;\n        &lt;!--完整查询语句：select id,name,pwd from mybatis.user where id=#{id}--&gt;\n        select id,name,pwd as password from mybatis.user where id=#{id}\n    &lt;/select&gt;\n</code></pre> </li></ul>\n<h3><a id=\"52_ResultMap_1102\"></a>5.2 引出ResultMap结果集映射</h3>\n<p>结果集映射</p>\n<pre><code>id    name    pwd\nid    name    password\n</code></pre>\n<p><img alt=\"image-20220821173816261\" src=\"image\\79ddb91e849361738ff3002f8238d65d.png\"/></p>\n<p>编写以上代码自行测试即可。</p>\n<ul><li><code>resultMap</code> 元素是 MyBatis 中最重要最强大的元素。</li><li>ResultMap 的设计思想是，对简单的语句做到零配置，对于复杂一点的语句，只需要描述语句之间的关系就行了。</li><li><code>ResultMap</code> 的优秀之处——你完全可以不用显式地配置它们。</li><li>如果这个世界总是这么简单就好了。</li></ul>\n<h2><a id=\"6_1120\"></a>6、日志</h2>\n<h3><a id=\"61__1122\"></a>6.1 日志工厂</h3>\n<p>如果一个数据库操作，出现了异常，我们需要拍错。日志就是最好的助手。</p>\n<p>曾经：sout 、debug</p>\n<p>现在：日志工厂!</p>\n<p><img alt=\"image-20220821224628312\" src=\"image\\22eb4945378afd5cbe4c9bfeef25a4fe.png\"/></p>\n<p>SLF4J | LOG4J（3.5.9 起废弃） | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING</p>\n<ul><li>STDOUT_LOGGING 【标准日志输出】</li><li>SLF4J</li></ul>\n<p>在mybatis中具体使用哪一个日志实现，在设置中设定！</p>\n<p>在mybatis核心配置文件中，配置我们的配置！</p>\n<pre><code>&lt;!--设置--&gt;\n&lt;settings&gt;\n    &lt;!--标准的日志工厂实现--&gt;\n    &lt;setting name=\"logImpl\" value=\"STDOUT_LOGGING\"/&gt;\n&lt;/settings&gt;\n</code></pre>\n<p><img alt=\"image-20220821230051687\" src=\"image\\bb5678cd82bb4a2223e791385a1b28ee.png\"/></p>\n<h3><a id=\"62_LOG4J_1151\"></a>6.2 LOG4J</h3>\n<p>什么是LOG4J？</p>\n<ul><li>Log4j是<a href=\"https://baike.baidu.com/item/Apache/8512995\">Apache</a>的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是<a href=\"https://baike.baidu.com/item/%E6%8E%A7%E5%88%B6%E5%8F%B0/2438626\">控制台</a>、文件、<a href=\"https://baike.baidu.com/item/GUI\">GUI</a>组件等</li><li>我们也可以控制每一条日志的输出格式</li><li>通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程</li><li>通过一个<a href=\"https://baike.baidu.com/item/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/286550\">配置文件</a>来灵活地进行配置，而不需要修改应用的代码</li></ul>\n<p>1.先导入LOG4J的包</p>\n<pre><code>&lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;log4j&lt;/groupId&gt;\n    &lt;artifactId&gt;log4j&lt;/artifactId&gt;\n    &lt;version&gt;1.2.17&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p>2.log4j.properties</p>\n<pre><code>#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码\nlog4j.rootLogger = DEBUG,console,file\n\n#控制台输出的相关设置\nlog4j.appender.console = org.apache.log4j.ConsoleAppender\nlog4j.appender.console.Target = System.out\nlog4j.appender.console.Threshold = DEBUG\nlog4j.appender.console.layout = org.apache.log4j.PatternLayout\nlog4j.appender.console.layout.ConversionPattern = [%c]-%m%n\n\n#文件输出的相关设置\nlog4j.appender.file = org.apache.log4j.RollingFileAppender\n#定义日志文件输出路径：如log4j.appender.file.File = D:/logs/log.log4j ——》D盘的指定路径下\n#当前目录下\nlog4j.appender.file.File = ./logs/log.log4j\n\nlog4j.appender.file.MaxFileSize = 10mb\nlog4j.appender.file.Threshold = DEBUG\nlog4j.appender.file.layout = org.apache.log4j.PatternLayout\nlog4j.appender.file.layout.ConversionPattern = [%p][%d{yy-MM-dd}][%c]%m%n\n\n#日志输出级别\nlog4j.logger.org.mybatis=DEBUG\nlog4j.logger.java.sql=DEBUG\nlog4j.logger.java.sql.Statement=DEBUG\nlog4j.logger.java.sql.ResultSet=DEBUG\nlog4j.logger.java.sql.PreparedStatement=DEBUG\n</code></pre>\n<p>3.配置log4j日志的实现</p>\n<pre><code>&lt;!--设置--&gt;\n&lt;settings&gt;\n    &lt;setting name=\"logImpl\" value=\"LOG4J\"/&gt;\n&lt;/settings&gt;\n</code></pre>\n<p>4.LOG4J的使用，直接测试运行刚才的查询</p>\n<p><img alt=\"image-20220821234921861\" src=\"image\\84141ef7e220206cb76b7c11347ba5c6.png\"/></p>\n<p><strong>简单使用</strong></p>\n<ol><li>在要使用Log4j的测试类中，导入包import org.apache.log4j.Logger;</li><li>日志对象，参数为当前类的class</li><li>日志级别</li><li>在logs文件中查看日志</li></ol>\n<p><img alt=\"image-20220822000820672\" src=\"image\\198fc69a8498dd6489724c2bf8d776dc.png\"/></p>\n<h2><a id=\"7_1225\"></a>7、分页</h2>\n<p>思考：为什么要分页？</p>\n<ul><li>减少数据的处理量</li></ul>\n<h3><a id=\"71_Limit_1231\"></a>7.1 使用Limit分页</h3>\n<pre><code>语法：select *  from mybatis.user limit startIndex,pageSize\n</code></pre>\n<pre><code>-- 从第0个下标开始，每页两个数据\nselect *  from mybatis.user limit 0,2;\n</code></pre>\n<p><img alt=\"image-20220822101848863\" src=\"image\\03df35a482d81b6d47d1cd678cc78427.png\"/></p>\n<pre><code>-- 默认从第0个下标开始，每页3个数据\nselect *  from mybatis.user limit 3;  #[0,n]\n</code></pre>\n<p><img alt=\"image-20220822102544472\" src=\"image\\2245f2c8ce003a3c4b6995c71d72d3d1.png\"/></p>\n<p>使用mybatis实现分页，核心SQL</p>\n<ol><li> <p>接口</p> <pre><code>//分页1：需要两个参数，使用万能的Map\nList&lt;User&gt; getUserByLimit(Map&lt;String,Integer&gt; map);\n</code></pre> </li><li> <p>Mapper.xml</p> <pre><code>&lt;!--实现分页查询--&gt;\n&lt;select id=\"getUserByLimit\" parameterType=\"map\" resultMap=\"UserMap\"&gt;\n    select * from user limit #{startIndex},#{pageSize}\n&lt;/select&gt;\n</code></pre> </li><li> <p>测试</p> <pre><code>@Test\npublic void getUserByLimit(){\n    SqlSession sqlSession = MybatisUtils.getSqlSession();\n\n    UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n\n    HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();\n    map.put(\"startIndex\",2);\n    map.put(\"pageSize\",2);\n    List&lt;User&gt; userList = mapper.getUserByLimit(map);//需要传一个map，则在上面构造一个\n    for (User user : userList) {\n        System.out.println(user);\n    }\n\n    sqlSession.close();\n}\n</code></pre> </li></ol>\n<h3><a id=\"72_RowBounds_1292\"></a>7.2 RowBounds分页</h3>\n<p>注意：面向对象的RowBounds分页没有使用SQL来的快！</p>\n<p>不再使用SQL实现分页</p>\n<ol><li> <p>接口</p> <pre><code>//分页2：通过RowBounds实现\nList&lt;User&gt; getUserByRowBounds();\n</code></pre> </li><li> <p>Mapper.xml</p> <pre><code>&lt;!--分页实现查询:RowBounds--&gt;\n&lt;select id=\"getUserByRowBounds\"  resultMap=\"UserMap\"&gt;\n    select * from user\n&lt;/select&gt;\n</code></pre> </li><li> <p>测试</p> <pre><code>@Test\npublic void getUserByRowBounds(){\n    SqlSession sqlSession = MybatisUtils.getSqlSession();\n\n    //RowBounds实现\n    RowBounds rowBounds = new RowBounds(1, 2);\n\n    //通过java代码层面实现分页\n    List&lt;User&gt; userList = sqlSession.selectList(\"com.shu.dao.UserMapper.getUserByRowBounds\",null,rowBounds);\n    for (User user : userList) {\n        System.out.println(user);\n    }\n    sqlSession.close();\n}\n</code></pre> </li></ol>\n<h3><a id=\"73__1333\"></a>7.3 分页插件</h3>\n<p><img alt=\"image-20220822115001142\" src=\"image\\bdeaf11d576e501cf12182f31aa42b8f.png\"/></p>\n<p>了解即可，万一以后公司的架构师说要使用，你需要知道它是什么东西！</p>\n<h2><a id=\"8_1339\"></a>8、使用注解开发</h2>\n<h3><a id=\"81_1341\"></a>8.1、面向接口编程</h3>\n<p>之前学过面向对象编程，也学习过接口，但在真正的开发中，很多时候会选择面向接口编程。<br/> <strong>根本原因：解耦，可拓展，提高复用，分层开发中，上层不用管具体的实现，大家都遵守共同的标准，使得开发变得容易，规范性更好</strong><br/> 在一个面向对象的系统中，系统的各种功能是由许许多多的不同对象协作完成的。在这种情况下，各个对象内部是如何实现自己的，对系统设计人员来讲就不那么重要了；<br/> 而各个对象之间的协作关系则成为系统设计的关键。小到不同类之间的通信，大到各模块之间的交互，在系统设计之初都是要着重考虑的，这也是系统设计的主要工作内容。面向接口编程就是指按照这种思想来编程。</p>\n<p><strong>三个面向区别</strong></p>\n<p>面向对象是指，我们考虑问题时，以对象为单位，考虑它的属性和方法；<br/> 面向过程是指，我们考虑问题时，以一个具体的流程（事务过程）为单位，考虑它的实现；<br/> 接口设计与非接口设计是针对复用技术而言的，与面向对象（过程）不是一个问题，更多的体现就是对系统整体的架构；</p>\n<h3><a id=\"82__1354\"></a>8.2 使用注解开发</h3>\n<ol><li> <p>注解在接口上实现</p> <pre><code>@Select(\"select * from user\")\nList&lt;User&gt; getUsers();\n</code></pre> </li><li> <p>需要在核心配置文件中绑定接口</p> <pre><code>&lt;!--绑定接口--&gt;\n&lt;mappers&gt;\n    &lt;mapper class=\"com.shu.dao.UserMapper\"/&gt;\n&lt;/mappers&gt;\n</code></pre> </li><li> <p>测试</p> <pre><code>@Test\npublic void getUsers(){\n    SqlSession sqlSession = MybatisUtils.getSqlSession();\n    //底层主要应用反射：通过反射可以得到类的所有东西\n    UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n\n    List&lt;User&gt; users = mapper.getUsers();\n    for (User user : users) {\n        System.out.println(user);\n    }\n\n    sqlSession.close();\n}\n</code></pre> </li></ol>\n<p>本质：反射机制实现</p>\n<p>底层：动态代理</p>\n<h3><a id=\"83_mybatis_1396\"></a>8.3 mybatis详细的执行流程</h3>\n<p><img alt=\"image-20220822152647718\" src=\"image\\30da28dc510cb9f9fcb1694ae1456bba.png\"/></p>\n<h3><a id=\"84_CRUD_1400\"></a>8.4 CRUD</h3>\n<p><em>CRUD</em>是指在做计算处理时的增加(Create)、读取(Read)、更新(Update)和删除(Delete)几个单词的首字母简写。<em>CRUD</em>主要被用在描述软件系统中数据库或者持久层的基本操作功能。</p>\n<p>我们可以在工具类创建的时候实现自动提交事务！</p>\n<pre><code>public static SqlSession getSqlSession(){\n    //优化代码\n    return sqlSessionFactory.openSession(true);  //设置自动提交事务为true\n}\n</code></pre>\n<p>C：增加(Create)</p>\n<pre><code>//引用对象不需要加@Param(\"\")：User   #{password}:要和实体类一致\n@Insert(\"insert into user(id,name,pwd) values(#{id},#{name},#{password})\")\nint addUser(User user);\n</code></pre>\n<pre><code>@Test\npublic void addUser(){\n    SqlSession sqlSession = MybatisUtils.getSqlSession();\n    //底层主要应用反射：通过反射可以得到类的所有东西\n    UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n\n    mapper.addUser(new User(6, \"小苏\", \"123456\"));\n\n    sqlSession.close();\n}\n</code></pre>\n<p>R：读取(Read)</p>\n<pre><code>@Select(\"select * from user where id=#{id}\")\nUser getUserById(@Param(\"id\") int id);\n</code></pre>\n<pre><code>@Test\npublic void getUserById(){\n    SqlSession sqlSession = MybatisUtils.getSqlSession();\n    //底层主要应用反射：通过反射可以得到类的所有东西\n    UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n\n    User user = mapper.getUserById(2);\n    System.out.println(user);\n\n    sqlSession.close();\n}\n</code></pre>\n<p>U：更新(Update)</p>\n<pre><code>@Update(\"update user set name=#{name},pwd=#{password} where id=#{id}\")\nint updateUser(User user);\n</code></pre>\n<pre><code>@Test\npublic void updateUser(){\n    SqlSession sqlSession = MybatisUtils.getSqlSession();\n    //底层主要应用反射：通过反射可以得到类的所有东西\n    UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n\n    mapper.updateUser(new User(6, \"小苏\", \"123123\"));\n\n    sqlSession.close();\n}\n</code></pre>\n<p>D：删除(Delete)</p>\n<pre><code>@Delete(\"delete from user where id=#{id}\")\nint deleteUser(@Param(\"id\") int id);\n</code></pre>\n<pre><code>@Test\npublic void deleteUser(){\n    SqlSession sqlSession = MybatisUtils.getSqlSession();\n    //底层主要应用反射：通过反射可以得到类的所有东西\n    UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n\n    mapper.deleteUser(6);\n\n    sqlSession.close();\n}\n</code></pre>\n<p><strong>注意：</strong></p>\n<p>我们必须要讲接口注册绑定到我们的核心配置文件中！</p>\n<pre><code>&lt;!--绑定接口--&gt;\n&lt;mappers&gt;\n    &lt;mapper class=\"com.shu.dao.UserMapper\"/&gt;\n&lt;/mappers&gt;\n</code></pre>\n<p><strong>关于@Param()注解</strong></p>\n<ul><li>基本类型的参数或者String类型，需要加上</li><li>引用类型不需要加</li><li>如果只有一个基本类型的话，可以忽略，但是建议大家加上</li><li>我们在SQL中引用的就是我们这里的@Param()中设定的属性名！</li></ul>\n<p><strong>#{} ${} 区别</strong></p>\n<p>1）#{}是预编译处理，$ {}是字符串替换。<br/> 2）mybatis在处理两个字符时，处理的方式也是不同的：<br/> ①处理#{}时，会将sql中的#{}整体替换为占位符（即：?），调用PreparedStatement的set方法来赋值；<br/> ②在处理 $ { } 时，就是把 <span class=\"katex--inline\"><span class=\"katex\"><span class=\"katex-mathml\">\n    \n     \n      \n       \n       \n        替换成变量的值。\n       \n       \n        3\n       \n       \n        ）假如用\n       \n      \n      \n       { } 替换成变量的值。 3）假如用\n      \n     \n    </span><span class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord\"></span><span class=\"mord cjk_fallback\">替换成变量的值。</span><span class=\"mord\">3</span><span class=\"mord cjk_fallback\">）假如用</span></span></span></span></span>{}来编写SQL会出现：恶意SQL注入，对于数据库的数据安全性就没办法保证了。</p>\n<h2><a id=\"9Lombok_1521\"></a>9、Lombok</h2>\n<p>Lombok项目是一个java库，它可以自动插入到编辑器和构建工具中，增强java的性能。不需要再写getter、setter或equals方法，只要有一个<a href=\"https://baike.baidu.com/item/%E6%B3%A8%E8%A7%A3/22344968\">注解</a>，你的类就有一个功能齐全的构建器、自动记录变量等等。</p>\n<p>Lombok常用注解</p>\n<p>▪ @Data</p>\n<p>▪ @Getter</p>\n<p>▪ @Setter</p>\n<p>▪ @ToString</p>\n<p>▪ @EqualsAndHashCode</p>\n<p>▪ @NonNull</p>\n<p>▪ @Log4j, @Log4j2, @Slf4j, @XSlf4j</p>\n<p>▪ @AllArgsConstructor, @RequiredArgsConstructor and @NoArgsConstructor</p>\n<p><strong>使用步骤：</strong></p>\n<ol><li> <p>在IDEA中安装lombok插件</p> <p><img alt=\"image-20220823135315355\" src=\"image\\84383940756d9666edfdca26fa8f02ea.png\"/></p> </li><li> <p>在项目中导入lombok的jar包【maven仓库中去找到lombok的依赖】</p> <pre><code>&lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\n            &lt;artifactId&gt;lombok&lt;/artifactId&gt;\n            &lt;version&gt;1.18.24&lt;/version&gt;\n            &lt;!--\n            Lombok的作用域：去掉则可以运用于所有项目\n            &lt;scope&gt;provided&lt;/scope&gt;\n            --&gt;\n        &lt;/dependency&gt;\n</code></pre> </li><li> <p>在实体类上使用Lombok注解</p> <p><img alt=\"image-20220823140243581\" src=\"image\\2e52034785bac8cb73f56b30558f93d0.png\"/></p> </li></ol>\n<h2><a id=\"10_1568\"></a>10、多对一的处理</h2>\n<p>多对一：</p>\n<ul><li>多个学生，对应一个老师</li><li>对于学生这边而言，关联 … 多个学生，关联一个老师 【多对一】</li><li>对于老师而言，集合，一个老师有很多学生 【一对多】</li></ul>\n<p>SQL语句：</p>\n<pre><code>CREATE TABLE `teacher` (\n\t`id` INT(10) NOT NULL,\n\t`name` VARCHAR(30) DEFAULT NULL,\n\tPRIMARY KEY (`id`)\n)ENGINE = INNODB DEFAULT CHARSET=utf8\n\nINSERT INTO teacher(`id`,`name`) VALUES (1,'秦老师');\n\nCREATE TABLE `student` (\n\t`id` INT(10) NOT NULL,\n\t`name` VARCHAR(30) DEFAULT NULL,\n\t`tid` INT(10) DEFAULT NULL,\n\tPRIMARY KEY (`id`),\n\tKEY `fktid`(`tid`),\n\tCONSTRAINT `fktid` FOREIGN KEY (`tid`) REFERENCES `teacher` (`id`)\n)ENGINE = INNODB DEFAULT CHARSET=utf8\n\nINSERT INTO `student`(`id`,`name`,`tid`) VALUES ('1','小明','1');\nINSERT INTO `student`(`id`,`name`,`tid`) VALUES ('2','小红','1');\nINSERT INTO `student`(`id`,`name`,`tid`) VALUES ('3','小张','1');\nINSERT INTO `student`(`id`,`name`,`tid`) VALUES ('4','小李','1');\nINSERT INTO `student`(`id`,`name`,`tid`) VALUES ('5','小王','1');\n</code></pre>\n<h3><a id=\"101_1603\"></a>10.1测试环境搭建</h3>\n<ol><li> <p>导入lombok</p> </li><li> <p>新建实体类Teacher，Student</p> <pre><code>@Data\npublic class Teacher {\n    private int id;\n    private String name;\n}\n</code></pre> <pre><code>@Data\npublic class Student {\n    private int id;\n    private String name;\n\n    //一个学生需要关联一个老师，使用组合\n    private Teacher teacher;\n}\n</code></pre> </li><li> <p>建立Mapper接口</p> </li><li> <p>建立Mapper.xml文件</p> </li><li> <p>在核心配置文件中绑定注册我们的Mapper接口或者文件</p> </li><li> <p>测试查询是否能够成功</p> </li></ol>\n<h3><a id=\"102__1636\"></a>10.2 按照查询嵌套处理</h3>\n<pre><code>public interface StudentMapper {\n    //查询所有的学生信息，以及对应的老师的信息\n    public List&lt;Student&gt; getStudent();\n\n    public List&lt;Student&gt; getStudent2();\n}\n</code></pre>\n<pre><code>&lt;!--\n怎么将老师信息同学生信息一起查出来？\n思路：\n1.查询所有的学生信息\n2.根据查询出来的学生的tid，寻找对应的老师   子查询！\n--&gt;\n\n&lt;select id=\"getStudent\" resultMap=\"StudentTeacher\"&gt;\n    select * from student\n&lt;/select&gt;\n\n&lt;resultMap id=\"StudentTeacher\" type=\"Student\"&gt;\n    &lt;result property=\"id\" column=\"id\"/&gt;\n    &lt;result property=\"name\" column=\"name\"/&gt;\n    &lt;!--复杂的属性，我们需要单独处理\n        对象：association\n        集合：collection\n    --&gt;\n    &lt;association property=\"teacher\" column=\"tid\" javaType=\"Teacher\" select=\"getTeacher\"/&gt;\n\n&lt;/resultMap&gt;\n\n&lt;select id=\"getTeacher\" resultType=\"Teacher\"&gt;\n    select * from teacher where id=#{id}\n&lt;/select&gt;\n</code></pre>\n<pre><code>@Test\npublic void testStudent(){\n    SqlSession sqlSession = MybatisUtils.getSqlSession();\n    StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);\n    List&lt;Student&gt; studentList = mapper.getStudent();\n    for (Student student : studentList) {\n        System.out.println(student);\n    }\n    sqlSession.close();\n}\n</code></pre>\n<h3><a id=\"103__1688\"></a>10.3 按照结果嵌套处理</h3>\n<pre><code>&lt;!--方法二：按照结果嵌套处理--&gt;\n&lt;resultMap id=\"StudentTeacher2\" type=\"Student\"&gt;\n    &lt;result property=\"id\" column=\"学生学号\"/&gt;\n    &lt;result property=\"name\" column=\"学生姓名\"/&gt;\n    &lt;association property=\"teacher\" javaType=\"Teacher\"&gt;\n        &lt;result property=\"name\" column=\"教师姓名\"/&gt;\n    &lt;/association&gt;\n&lt;/resultMap&gt;\n\n&lt;select id=\"getStudent2\" resultMap=\"StudentTeacher2\"&gt;\n    select\n        s.id as `学生学号`,s.name as `学生姓名`,t.name as `教师姓名`\n    from\n        student s\n            inner join\n        teacher t\n        on\n            s.tid = t.id\n&lt;/select&gt;\n</code></pre>\n<pre><code>@Test\npublic void testStudent2() {\n    SqlSession sqlSession = MybatisUtils.getSqlSession();\n    StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);\n    List&lt;Student&gt; studentList = mapper.getStudent2();\n    for (Student student : studentList) {\n        System.out.println(student);\n    }\n    sqlSession.close();\n}\n</code></pre>\n<p>回顾Mysql多对一查询方式：</p>\n<ul><li>子查询</li><li>联表查询</li></ul>\n<h2><a id=\"11_1730\"></a>11、一对多的处理</h2>\n<p>比如：一个老师拥有多个学生</p>\n<p>对于老师而言，就是一对多的关系！</p>\n<ol><li> <p>环境搭建，和刚才的一样</p> </li><li> <p>新建实体类Teacher、Student</p> <pre><code>@Data\npublic class Teacher {\n    private int id;\n    private String name;\n    //一个老师拥有多个学生\n    private List&lt;Student&gt; students;\n}\n</code></pre> <pre><code>@Data\npublic class Student {\n    private int id;\n    private String name;\n    private int tid;\n}\n</code></pre> </li><li> <p>按照结果嵌套处理</p> <pre><code>&lt;!--按结果嵌套查询--&gt;\n&lt;resultMap id=\"TeacherStudent2\" type=\"Teacher\"&gt;\n    &lt;result property=\"id\" column=\"教师编号\"/&gt;\n    &lt;result property=\"name\" column=\"教师姓名\"/&gt;\n    &lt;!--\n    javaType=\"\":指定的属性的类型\n    集合中的泛型信息，我们使用ofType获取  ofType=\"Student\n    --&gt;\n    &lt;!--取出来的每一个值，每一个值是对应的，不需要写javaType=\"ArrayList\"--&gt;\n    &lt;collection property=\"students\" ofType=\"Student\"&gt;\n        &lt;result property=\"id\" column=\"学生编号\"/&gt;\n        &lt;result property=\"name\" column=\"学生姓名\"/&gt;\n        &lt;!--&lt;result property=\"tid\" column=\"tid\"/&gt;--&gt;\n    &lt;/collection&gt;\n&lt;/resultMap&gt;\n\n&lt;select id=\"getTeacher2\" resultMap=\"TeacherStudent2\"&gt;\n    select t.id 教师编号,t.name 教师姓名,s.id 学生编号,s.name 学生姓名\n    from teacher t,student s\n    where t.id=s.tid and t.id=#{tid}\n&lt;/select&gt;\n</code></pre> </li><li> <p>按照查询嵌套处理</p> <pre><code>&lt;!--按照查询嵌套处理--&gt;\n&lt;select id=\"getTeacher3\" resultMap=\"TeacherStudent3\"&gt;\n    select * from teacher where id=#{tid}\n&lt;/select&gt;\n&lt;resultMap id=\"TeacherStudent3\" type=\"Teacher\"&gt;\n    &lt;!--一样的字段可以省略不写--&gt;\n    &lt;!--&lt;result property=\"id\" column=\"id\"/&gt;\n    &lt;result property=\"name\" column=\"name\"/&gt;--&gt;\n    &lt;!--\n    下面这种本来就是一个集合，集合的对象需要加上javaType=\"ArrayList\"\n    select=\"getStudentByTeacherId\":子查询语句\n    --&gt;\n    &lt;collection property=\"students\" ofType=\"Student\" javaType=\"ArrayList\" select=\"getStudentByTeacherId\" column=\"id\"/&gt;\n&lt;/resultMap&gt;\n&lt;select id=\"getStudentByTeacherId\" resultType=\"Student\"&gt;\n    select * from student where tid=#{tid}\n&lt;/select&gt;\n</code></pre> </li><li> <p>测试查询</p> <pre><code>    @Test\n    public void getTeacher2(){\n        SqlSession sqlSession = MybatisUtils.getSqlSession();\n        TeacherMapper mapper = sqlSession.getMapper(TeacherMapper.class);\n        Teacher teacher2 = mapper.getTeacher2(1);\n        System.out.println(teacher2);\n        sqlSession.close();\n    }\n    @Test\n    public void getTeacher3(){\n        SqlSession sqlSession = MybatisUtils.getSqlSession();\n        TeacherMapper mapper = sqlSession.getMapper(TeacherMapper.class);\n        Teacher teacher2 = mapper.getTeacher3(1);\n        System.out.println(teacher2);\n        sqlSession.close();\n    }\n}\n</code></pre> </li></ol>\n<p><strong>小结</strong></p>\n<ul><li>关联：association【多对一】</li><li>集合：collection 【一对多】</li><li>javaType &amp; ofType的区别 \n  <ol><li>javaType 用来指定实体类中的属性的类型</li><li>ofType 用来指定映射到List或者集合中的pojo类型，也就是泛型中的约束类型！</li></ol> </li></ul>\n<p><strong>注意点</strong></p>\n<ul><li>保证SQL的可读性，尽量保证通俗易懂</li><li>注意一对多和多对一中，属性名和字段的问题！</li><li>如果问题不好排查错误，可以使用日志。建议使用Log4j</li></ul>\n<p>面试高频</p>\n<ul><li>MySQL引擎：INNODB和MYISAM</li><li>INNODB的底层原理</li><li>索引</li><li>索引优化！</li></ul>\n<h2><a id=\"12SQL_1852\"></a>12、动态SQL</h2>\n<p><strong>什么是动态SQL：动态SQL就是指根据不同的条件生成不同的SQL语句</strong></p>\n<p>如果你之前用过 JSTL 或任何基于类 XML 语言的文本处理器，你对动态 SQL 元素可能会感觉似曾相识。在 MyBatis 之前的版本中，需要花时间了解大量的元素。借助功能强大的基于 OGNL 的表达式，MyBatis 3 替换了之前的大部分元素，大大精简了元素种类，现在要学习的元素种类比原来的一半还要少。</p>\n<ul><li>if</li><li>choose (when, otherwise)</li><li>trim (where, set)</li><li>foreach</li></ul>\n<h3><a id=\"121__1863\"></a>12.1 搭建环境</h3>\n<pre><code>CREATE TABLE `blog`(\n\t`id` VARCHAR(50) NOT NULL COMMENT '博客id',\n\t`title` VARCHAR(100) NOT NULL COMMENT '博客标题',\n\t`author` VARCHAR(30) NOT NULL COMMENT '博客作者',\n\t`create_time` DATETIME NOT NULL COMMENT '创建时间',\n\t`views` INT(30) NOT NULL COMMENT '浏览量'\n)ENGINE=INNODB DEFAULT CHARSET=utf8\n</code></pre>\n<p>创建一个基础工程</p>\n<ol><li> <p>导包</p> </li><li> <p>编写配置文件</p> </li><li> <p>编写实体类</p> <pre><code>@Data\npublic class Blog {\n    private String id;\n    private String title;\n    private String author;\n    //属性名和字段名不一致，需要在配置文件中开启驼峰命名自动映射\n    /*\n    &lt;!--是否开启驼峰命名自动映射--&gt;\n    &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/&gt;\n    */\n    private Date createTime;\n    private int views;\n}\n</code></pre> </li><li> <p>编写实体类对应的Mapper接口和Mapper.xml文件</p> </li></ol>\n<p><strong>动态SQL之IF语句</strong></p>\n<pre><code>//查询博客\nList&lt;Blog&gt; queryBlogIF(Map map);\n</code></pre>\n<pre><code>&lt;select id=\"queryBlogIF\" parameterType=\"map\" resultType=\"blog\"&gt;\n    select * from blog where 1=1\n    &lt;if test=\"title != null\"&gt;\n        and title = #{title}\n    &lt;/if&gt;\n    &lt;if test=\"author != null\"&gt;\n        and author = #{author}\n    &lt;/if&gt;\n&lt;/select&gt;\n</code></pre>\n<pre><code>@Test\npublic void queryBlogIf(){\n    SqlSession sqlSession = MybatisUtils.getSqlSession();\n    BlogMapper mapper = sqlSession.getMapper(BlogMapper.class);\n    HashMap map = new HashMap();\n    map.put(\"title\",\"Java\");\n    map.put(\"author\",\"小狂\");\n    List&lt;Blog&gt; blogs = mapper.queryBlogIF(map);\n    for (Blog blog : blogs) {\n        System.out.println(blog);\n    }\n    sqlSession.close();\n}\n</code></pre>\n<p><strong>choose、when、otherwise</strong></p>\n<pre><code>&lt;select id=\"queryBlogChoose\" parameterType=\"map\" resultType=\"blog\"&gt;\n    select * from blog\n    &lt;where&gt;\n        &lt;choose&gt;\n            &lt;when test=\"title !=null\"&gt;\n                title=#{title}\n            &lt;/when&gt;\n            &lt;when test=\"author !=null\"&gt;\n                and author=#{author}\n            &lt;/when&gt;\n            &lt;otherwise&gt;\n                and views=#{views}\n            &lt;/otherwise&gt;\n        &lt;/choose&gt;\n    &lt;/where&gt;\n&lt;/select&gt;\n</code></pre>\n<p><strong>trim、where、set</strong></p>\n<pre><code>&lt;select id=\"queryBlogIF\" parameterType=\"map\" resultType=\"blog\"&gt;\n    select * from blog\n    &lt;where&gt;\n    &lt;if test=\"title != null\"&gt;\n        title = #{title}\n    &lt;/if&gt;\n    &lt;if test=\"author != null\"&gt;\n        and author = #{author}\n    &lt;/if&gt;\n    &lt;/where&gt;\n&lt;/select&gt;\n</code></pre>\n<pre><code>&lt;update id=\"updateBlog\" parameterType=\"map\"&gt;\n    /*set语句要加,*/\n    update blog\n    &lt;set&gt;\n        &lt;if test=\"title != null\"&gt;\n            title = #{title},\n        &lt;/if&gt;\n        &lt;if test=\"author != null\"&gt;\n            author = #{author}\n        &lt;/if&gt;\n    &lt;/set&gt;\n    where id=#{id}\n&lt;/update&gt;\n</code></pre>\n<pre><code>&lt;trim prefix=\"SET\" suffixOverrides=\",\"&gt;\n  ...\n&lt;/trim&gt;\n</code></pre>\n<pre><code class=\"prism language-&lt;trim\">&lt;trim prefix=\"WHERE\" prefixOverrides=\"AND |OR \"&gt;\n  ...\n&lt;/trim&gt;\n</code></pre>\n<p>所谓的动态SQL，本质还是SQL语句，只是我们可以在SQL层面，去执行一个逻辑代码</p>\n<p>if</p>\n<p>where , set , choose , when</p>\n<h3><a id=\"122_foreach_2007\"></a>12.2 foreach</h3>\n<p>动态 SQL 的另一个常见使用场景是对集合进行遍历（尤其是在构建 IN 条件语句的时候）。比如：</p>\n<pre><code>&lt;select id=\"selectPostIn\" resultType=\"domain.blog.Post\"&gt;\n  SELECT *\n  FROM POST P\n  &lt;where&gt;\n    &lt;foreach item=\"item\" index=\"index\" collection=\"list\"\n        open=\"ID in (\" separator=\",\" close=\")\" nullable=\"true\"&gt;\n          #{item}\n    &lt;/foreach&gt;\n  &lt;/where&gt;\n&lt;/select&gt;\n</code></pre>\n<p><em>foreach</em> 元素的功能非常强大，它允许你指定一个集合，声明可以在元素体内使用的集合项（item）和索引（index）变量。它也允许你指定开头与结尾的字符串以及集合项迭代之间的分隔符。这个元素也不会错误地添加多余的分隔符，看它多智能！</p>\n<p><strong>提示</strong> 你可以将任何可迭代对象（如 List、Set 等）、Map 对象或者数组对象作为集合参数传递给 <em>foreach</em>。当使用可迭代对象或者数组时，index 是当前迭代的序号，item 的值是本次迭代获取到的元素。当使用 Map 对象（或者 Map.Entry 对象的集合）时，index 是键，item 是值。</p>\n<pre><code>//查询第1,2,3号记录的博客\nList&lt;Blog&gt; queryBlogForeach(Map map);\n</code></pre>\n<pre><code>&lt;!--查询第1,2,3号记录的博客--&gt;\n&lt;!--open=\"and (\" close=\")\" separator=\"or\":拼接SQL   and (  ) or--&gt;\n&lt;!--select * from blog where 1=1 and (id=1 or id=2 or id=3)--&gt;\n&lt;select id=\"queryBlogForeach\" parameterType=\"map\" resultType=\"blog\"&gt;\n    select * from blog\n    &lt;where&gt;\n    &lt;foreach collection=\"ids\" item=\"id\" open=\"and (\" close=\")\" separator=\"or\"&gt;\n        id=#{id}\n    &lt;/foreach&gt;\n    &lt;/where&gt;\n&lt;/select&gt;\n</code></pre>\n<pre><code>@Test\npublic void queryBlogForeach(){\n    SqlSession sqlSession = MybatisUtils.getSqlSession();\n    BlogMapper mapper = sqlSession.getMapper(BlogMapper.class);\n    HashMap map = new HashMap();\n    ArrayList&lt;Integer&gt; ids = new ArrayList&lt;&gt;();\n    ids.add(1);\n    ids.add(2);\n    ids.add(3);\n    map.put(\"ids\",ids);\n\n    List&lt;Blog&gt; blogs = mapper.queryBlogForeach(map);\n    for (Blog blog : blogs) {\n        System.out.println(blog);\n    }\n    sqlSession.close();\n}\n</code></pre>\n<h3><a id=\"123_SQL_2067\"></a>12.3 SQL片段</h3>\n<p>有的时候我们可能会将一些公共的部分抽取出来进行复用</p>\n<p><img alt=\"image-20220827140550813\" src=\"image\\83ee4a207c33f8412a00d48ad7166dcf.png\"/></p>\n<p><img alt=\"image-20220827140805127\" src=\"image\\73075763b6345f228911a1733cfb2a9a.png\"/></p>\n<pre><code>&lt;sql id=\"if-title-author\"&gt;\n    &lt;if test=\"title != null\"&gt;\n        title = #{title}\n    &lt;/if&gt;\n    &lt;if test=\"author != null\"&gt;\n        and author = #{author}\n    &lt;/if&gt;\n&lt;/sql&gt;\n&lt;select id=\"queryBlogIF\" parameterType=\"map\" resultType=\"blog\"&gt;\n    select * from blog\n    &lt;where&gt;\n        &lt;include refid=\"if-title-author\"&gt;&lt;/include&gt;\n    &lt;/where&gt;\n&lt;/select&gt;\n</code></pre>\n<p>总结：</p>\n<ol><li>使用sql标签抽取公共的部分</li><li>在需要的使用的地方使用include标签引用即可</li></ol>\n<p>注意事项：</p>\n<ul><li>最好基于单表来定义SQL片段</li><li>不要存在where标签</li></ul>\n<h3><a id=\"124__2104\"></a>12.4 总结</h3>\n<p>动态SQL就是在拼接SQL语句，我们只要保证SQL的正确性，按照SQL的格式，去排列组合就可以了！</p>\n<p>建议：</p>\n<ul><li>先在mysql中写出完整的sql，再对应的去修改我们的动态SQl实现通用即可</li></ul>\n<h2><a id=\"13_2112\"></a>13、缓存【读写分离】</h2>\n<h3><a id=\"131__2114\"></a>13.1 简介</h3>\n<pre><code>查询：连接数据库，耗资源！\n     一次查询的结果给，给它暂存在一个可以直接取到的地方！——》内存：缓存\n我们再次查询相同的数据的时候，直接走缓存，就不用走数据库了！\n</code></pre>\n<ol><li> <p>什么是缓存[Cache]？<br/> 存在内存中的临时数据。<br/> 将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上（关系型数据库查询文件）查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。</p> </li><li> <p>为什么使用缓存？<br/> 减少和数据库的交互次数，减少系统开销，提高系统效率。</p> </li><li> <p>什么样的数据能使用缓存？</p> <p>经常查询并且不经常改变的数据。【可以使用缓存】</p> </li></ol>\n<h3><a id=\"132_Mybatis_2133\"></a>13.2 Mybatis缓存</h3>\n<p>Mybatis包含一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效率。<br/> Mybatis系统中默认定义了两级缓存：一级缓存和二级缓存<br/> 默认情况下，只有一级缓存开启。（SqlSession级别的缓存，也称为本地缓存）<br/> 二级缓存需要手动开启和配置，它是基于namespace级别的缓存。<br/> 为了提高扩展性，Mybatis定义了缓存接口Cache，我们可以通过实现Cache接口来自定义二级缓存。</p>\n<h3><a id=\"133__2141\"></a>13.3 一级缓存</h3>\n<p>一级缓存也叫本地缓存：<br/> 与数据库同一次会话期间查询到的数据会放在本地缓存中。<br/> 以后如果需要获取相同的数据，直接从缓存中拿，没必要再去查询数据库</p>\n<p>测试步骤：</p>\n<ol><li> <p>开启日志！</p> <pre><code>&lt;settings&gt;\n    &lt;setting name=\"logImpl\" value=\"STDOUT_LOGGING\"/&gt;\n&lt;/settings&gt;\n</code></pre> </li><li> <p>测试在一个Session中查询两次相同记录</p> <pre><code>//通过id获取一个用户\nUser getUserById(@Param(\"id\") int id);\n</code></pre> <pre><code>&lt;select id=\"getUserById\" resultType=\"user\"&gt;\n    select * from user where id=#{id}\n&lt;/select&gt;\n</code></pre> <pre><code>@Test\npublic void getUserById(){\n    SqlSession sqlSession = MybatisUtils.getSqlSession();\n    UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n    User user = mapper.getUserById(1);\n    System.out.println(user);\n\n    System.out.println(\"======================\");\n    User user2 = mapper.getUserById(1);\n    System.out.println(user2);\n\n    System.out.println(user==user2);\n    sqlSession.close();\n}\n</code></pre> </li><li> <p>查看日志输出，走了一次SQL查出两条信息</p> <p><img alt=\"image-20220827160812387\" src=\"image\\8918a23e4df3f7f9a31502731447a775.png\"/></p> </li></ol>\n<p>缓存失效的情况：</p>\n<ol><li> <p>查询不同的东西；</p> <pre><code>@Test\npublic void getUserById(){\n    SqlSession sqlSession = MybatisUtils.getSqlSession();\n    UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n    User user = mapper.getUserById(1);\n    System.out.println(user);\n\n    System.out.println(\"======================\");\n    User user2 = mapper.getUserById(2);\n    System.out.println(user2);\n\n    System.out.println(user==user2);\n    sqlSession.close();\n}\n</code></pre> <p><img alt=\"image-20220827161201731\" src=\"image\\16e7a7b5ae5e40aea352c2b06ab8bd75.png\"/></p> </li><li> <p>增删改操作，可能会改变原来的数据，所以必定会刷新缓存！</p> <p><img alt=\"image-20220827162732503\" src=\"image\\d7d355cd3113a89d8e470986533e1156.png\"/></p> </li><li> <p>查询不同的Mapper.xml</p> </li><li> <p>手动清理缓存！</p> <p><img alt=\"image-20220827162829900\" src=\"image\\fac212b879f69b39213a3bdb7e0a04cb.png\"/></p> </li></ol>\n<p><strong>小结</strong></p>\n<ul><li>一级缓存默认是开启的，只在一次sqlSession中有效，也就是拿到连接到关闭连接这个区间！</li><li>一级缓存就是一个Map！</li></ul>\n<h3><a id=\"134__2229\"></a>13.4 二级缓存</h3>\n<ul><li> <p>二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存；</p> </li><li> <p>基于namespace级别的缓存，一个名称空间，对应一个二级缓存；</p> </li><li> <p>工作机制</p>\n<ul><li> <p>一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中；</p> </li><li> <p>如果当前会话关闭了，这个会话对应的一级缓存就没了；但是我们想要的是，会话关闭了，一级缓存中的数据被保存到二级缓存中；</p> </li><li> <p>新的会话查询信息，就可以从二级缓存中获取内容；</p> </li><li> <p>不同的mapper查出的数据就会放在自己对应的缓存（map）中；</p> </li></ul> </li></ul>\n<p>步骤：</p>\n<ol><li> <p>在mybatis-config.xml开启全局缓存</p> <pre><code>&lt;!--显示的开启全局缓存--&gt;\n&lt;setting name=\"cacheEnabled\" value=\"true\"/&gt;\n</code></pre> </li><li> <p>在要使用二级缓存的Mapper中开启</p> <pre><code>&lt;!--自定义参数--&gt;   \n&lt;cache\n  eviction=\"FIFO\"\n  flushInterval=\"60000\"\n  size=\"512\"\n  readOnly=\"true\"/&gt;\n</code></pre> </li><li> <p>测试</p> <pre><code>@Test\npublic void cacheTest(){\n    SqlSession sqlSession = MybatisUtils.getSqlSession();\n    SqlSession sqlSession2 = MybatisUtils.getSqlSession();\n\n    UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n    User user = mapper.getUserById(1);\n    System.out.println(user);\n    sqlSession.close();\n\n    UserMapper mapper2 = sqlSession2.getMapper(UserMapper.class);\n    User user2 = mapper2.getUserById(1);\n    System.out.println(user2);\n\n    System.out.println(user==user2);\n\n    sqlSession2.close();\n}\n</code></pre>\n<ol><li> <p>问题：如果没有自定义参数，则会报错，我们需要将实体类序列化！</p> <pre><code>&lt;cache/&gt;\n</code></pre> <p><img alt=\"\" src=\"image\\e9bc84a8ad440a742a876255a1c0eb95.png\"/></p> <p><img alt=\"image-20220827170149875\" src=\"image\\40523ade713b04f621568b89408b9139.png\"/></p> </li><li> <p>设置好参数</p> <pre><code>&lt;cache\n        eviction=\"FIFO\"\n        flushInterval=\"60000\"\n        size=\"512\"\n        readOnly=\"true\"/&gt;\n</code></pre> <p><img alt=\"image-20220827165531349\" src=\"image\\64c5dc447187961c17e9377a6c1dd9d3.png\"/></p> </li></ol> </li></ol>\n<p>小结：</p>\n<ul><li>只要开启了二级缓存，在同一个Mapper下就有效；</li><li>所有的数据都会先放在一级缓存中；</li><li>只有当会话提交或者关闭的时候，才会提交到二级缓存中！</li></ul>\n<h3><a id=\"135__2316\"></a>13.5 缓存原理</h3>\n<p><img alt=\"image-20220827172433497\" src=\"image\\ca40bc80256d42b240f5c2e1b5839c68.png\"/></p>\n<h3><a id=\"136_ehcache_2320\"></a>13.6 自定义缓存-ehcache（可以了解）</h3>\n<p>Ehcache是一种广泛使用的开源Java分布式缓存，主要面向通用缓存。</p>\n<p>要在程序中使用ehcache，先要导包！</p>\n<pre><code>&lt;!-- https://mvnrepository.com/artifact/org.mybatis.caches/mybatis-ehcache --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt;\n    &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt;\n    &lt;version&gt;1.2.2&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p>在mapper中指定使用我们的ehcache缓存实现！</p>\n<pre><code>&lt;cache type=\"org.mybatis.caches.ehcache.EhcacheCache\"/&gt;\n</code></pre>\n<p>配置ehcache.xml</p>\n<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;ehcache xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:noNamespaceSchemaLocation=\"http://ehcache.org/ehcache.xsd\"\n         updateCheck=\"false\"&gt;\n    &lt;!--\n       diskStore：为缓存路径，ehcache分为内存和磁盘两级，此属性定义磁盘的缓存位置。参数解释如下：\n       user.home – 用户主目录\n       user.dir  – 用户当前工作目录\n       java.io.tmpdir – 默认临时文件路径\n     --&gt;\n    &lt;diskStore path=\"java.io.tmpdir/Tmp_EhCache\"/&gt;\n    &lt;!--\n       defaultCache：默认缓存策略，当ehcache找不到定义的缓存时，则使用这个缓存策略。只能定义一个。\n     --&gt;\n    &lt;!--\n      name:缓存名称。\n      maxElementsInMemory:缓存最大数目\n      maxElementsOnDisk：硬盘最大缓存个数。\n      eternal:对象是否永久有效，一但设置了，timeout将不起作用。\n      overflowToDisk:是否保存到磁盘，当系统宕机时\n      timeToIdleSeconds:设置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。\n      timeToLiveSeconds:设置对象在失效前允许存活时间（单位：秒）。最大时间介于创建时间和失效时间之间。仅当eternal=false对象不是永久有效时使用，默认是0.，也就是对象存活时间无穷大。\n      diskPersistent：是否缓存虚拟机重启期数据 Whether the disk store persists between restarts of the Virtual Machine. The default value is false.\n      diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。\n      diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。\n      memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。\n      clearOnFlush：内存数量最大时是否清除。\n      memoryStoreEvictionPolicy:可选策略有：LRU（最近最少使用，默认策略）、FIFO（先进先出）、LFU（最少访问次数）。\n      FIFO，first in first out，这个是大家最熟的，先进先出。\n      LFU， Less Frequently Used，就是上面例子中使用的策略，直白一点就是讲一直以来最少被使用的。如上面所讲，缓存的元素有一个hit属性，hit值最小的将会被清出缓存。\n      LRU，Least Recently Used，最近最少使用的，缓存的元素有一个时间戳，当缓存容量满了，而又需要腾出地方来缓存新的元素的时候，那么现有缓存元素中时间戳离当前时间最远的元素将被清出缓存。\n   --&gt;\n    &lt;defaultCache\n            eternal=\"false\"\n            maxElementsInMemory=\"10000\"\n            overflowToDisk=\"false\"\n            diskPersistent=\"false\"\n            timeToIdleSeconds=\"1800\"\n            timeToLiveSeconds=\"259200\"\n            memoryStoreEvictionPolicy=\"LRU\"/&gt;\n\n    &lt;cache\n            name=\"cloud_user\"\n            eternal=\"false\"\n            maxElementsInMemory=\"5000\"\n            overflowToDisk=\"false\"\n            diskPersistent=\"false\"\n            timeToIdleSeconds=\"1800\"\n            timeToLiveSeconds=\"1800\"\n            memoryStoreEvictionPolicy=\"LRU\"/&gt;\n\n&lt;/ehcache&gt;\n</code></pre>\n<p><strong>目前：Redis数据库来做缓存！K-V</strong></p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}