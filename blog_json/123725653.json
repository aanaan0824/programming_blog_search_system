{"blogid": "123725653", "writerAge": "码龄3年", "writerBlogNum": "12", "writerCollect": "0", "writerComment": "2", "writerFan": "691", "writerGrade": "2级", "writerIntegral": "123", "writerName": "被时光铭刻的天空", "writerProfileAdress": "writer_image\\profile_123725653.jpg", "writerRankTotal": "119729", "writerRankWeekly": "114739", "writerThumb": "2", "writerVisitNum": "9465", "blog_read_count": "2905", "blog_time": "于 2022-03-25 00:42:47 发布", "blog_title": "std::array", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h3><a id=\"array_0\"></a>array</h3>\n<ul><li>c++11 封装了相关的数组模板类，不同于 C 风格数组，它不会自动退化成 T* 类型，它能作为聚合类型聚合初始化</li><li>std::array 是封装固定大小数组的容器，数组元素下标索引从 0 开始</li></ul>\n<pre><code>// 模板类定义\ntemplate&lt;typename _Tp, std::size_t _Nm&gt; \nstruct array{...};\n\n// 数组元素个数为 0，访问时行为未定义\nstd::array&lt;int, 0&gt; arr;\n</code></pre>\n<pre><code>// 常见初始化方法\nint main()\n{\n    const int SIZE = 5;\n    auto Print = [](const std::array&lt;int, SIZE&gt; &amp;arr){\n        std::cout &lt;&lt; \"arr value : \\t\";\n        for (const auto &amp;val : arr) {\n            std::cout &lt;&lt; val &lt;&lt; \"\\t\";\n        }\n        std::cout &lt;&lt; \"\\n\";\n    };\n    // 初始化容器\n    std::array&lt;int, SIZE&gt; arr;\n    Print(arr);  //  未初始化值为随机值\n    for (int i = 0; i &lt; SIZE; ++i) {  // 先定义，后初始化\n        arr[i] = i;\n    }\n    Print(arr);\n    std::array&lt;int, SIZE&gt; arr1{2,3,4,5,6};  // 定义并初始化\n    Print(arr1);\n    std::array&lt;int, SIZE&gt; arr2 = {1,2,3,4,5}; // 定义并初始化\n    Print(arr2);\n\n    std::array&lt;int, SIZE&gt; arr3{arr};\n    Print(arr3);\n    std::array&lt;int, SIZE&gt; arr4 = {arr};\n    Print(arr4);\n    std::array&lt;int, SIZE&gt; arr5 = arr;\n    Print(arr5);\n    std::array&lt;int, SIZE&gt; arr6;\n    arr6 = arr;\n    Print(arr6);\n    return 0;\n}\n</code></pre>\n<blockquote>\n<p>输出结果：<br/> arr value : 8 0 4199705 0 8<br/> arr value : 0 1 2 3 4<br/> arr value : 2 3 4 5 6<br/> arr value : 1 2 3 4 5<br/> arr value : 0 1 2 3 4<br/> arr value : 0 1 2 3 4<br/> arr value : 0 1 2 3 4<br/> arr value : 0 1 2 3 4</p>\n</blockquote>\n<pre><code>// 元素访问函数\nint main()\n{\n    const int SIZE = 5;\n    // 初始化容器\n    std::array&lt;int, SIZE&gt; arr;\n    for (int i = 0; i &lt; SIZE; ++i) {  // 先定义，后初始化\n        arr[i] = i;\n    }\n\n    // 元素访问\n    // 访问指定的元素，同时进行越界检查\n    std::cout &lt;&lt; \"arr.at(2) : \" &lt;&lt; arr.at(2) &lt;&lt; std::endl;\n    // 访问指定的元素，不进行越界检查\n    std::cout &lt;&lt; \"arr[2] : \" &lt;&lt; arr[2] &lt;&lt; std::endl;\n    // 访问第一个元素\n    std::cout &lt;&lt; \"arr.front() : \" &lt;&lt; arr.front() &lt;&lt; std::endl;\n    // 访问最后一个元素\n    std::cout &lt;&lt; \"arr.back() : \" &lt;&lt; arr.back() &lt;&lt; std::endl;\n    // 返回指向内存中数组第一个元素的指针\n    printf(\"arr[0] address : %#p\\tarr.data() address : %#p\\n\", &amp;arr[0], arr.data());\n    return 0;\n}\n</code></pre>\n<blockquote>\n<p>输出结果：<br/> arr.at(2) : 2<br/> arr[2] : 2<br/> arr.front() : 0<br/> arr.back() : 4<br/> arr[0] address : 0x65fdf0 arr.data() address : 0x65fdf0</p>\n</blockquote>\n<pre><code>// 使用迭代器对元素访问\nint main()\n{\n    const int SIZE = 5;\n    // 初始化容器\n    std::array&lt;int, SIZE&gt; arr{1, 2, 3, 4, 5};\n\n    // 迭代器，本身类似指针，stl 提供的一种容器元素操作方法\n    // 返回指向起始的迭代器，iterator 迭代器可读写，const_iterator 迭代器可读\n    std::array&lt;int, SIZE&gt;::iterator iter = arr.begin();  // 可使用 auto 简化，auto iter = arr.begin();\n    for (; iter != arr.end(); ++iter) {\n        std::cout &lt;&lt; *iter &lt;&lt; \"\\t\";\n    }\n    std::cout &lt;&lt; \"\\n\";\n\n    std::array&lt;int, SIZE&gt;::const_iterator iter2 = arr.cbegin();\n    for (; iter2 != arr.cend(); ++iter2) {\n        std::cout &lt;&lt; *iter2 &lt;&lt; \"\\t\";\n    }\n    std::cout &lt;&lt; \"\\n\";\n    // 返回指向末尾的迭代器，指向最后一个元素的下一个位置\n    printf(\"(arr.data() + 5) addr : %#p\\tarr.end() addr : %#p\\n\", (arr.data() + 5), arr.end());\n    printf(\"(arr.data() + 5) addr : %#p\\tarr.cend() addr : %#p\\n\", (arr.data() + 5), arr.cend());\n\n    // 返回指向起始的逆向迭代器\n    std::array&lt;int, SIZE&gt;::reverse_iterator iter3 = arr.rbegin();\n    for (; iter3 != arr.rend(); ++iter3) {\n        std::cout &lt;&lt; *iter3 &lt;&lt; \"\\t\";\n    }\n    std::cout &lt;&lt; \"\\n\";\n    std::array&lt;int, SIZE&gt;::const_reverse_iterator iter4 = arr.crbegin();\n    for (; iter4 != arr.crend(); ++iter4) {\n        std::cout &lt;&lt; *iter4 &lt;&lt; \"\\t\";\n    }\n    std::cout &lt;&lt; \"\\n\";\n    // 返回指向末尾的逆向迭代器\n    printf(\"(arr.data() - 1) addr : %#p\\tarr.rend() addr : %#p\\n\", (arr.data() - 1), &amp;(*arr.rend()));\n    printf(\"(arr.data() - 1) addr : %#p\\tarr.crend() addr : %#p\\n\", (arr.data() - 1), &amp;(*arr.crend()));\n    return 0;\n}\n</code></pre>\n<blockquote>\n<p>输出结果：<br/> 0 1 2 3 4<br/> 0 1 2 3 4<br/> (arr.data() + 5) addr : 0x66fdc4 arr.end() addr : 0x66fdc4<br/> (arr.data() + 5) addr : 0x66fdc4 arr.cend() addr : 0x66fdc4<br/> 4 3 2 1 0<br/> 4 3 2 1 0<br/> (arr.data() - 1) addr : 0x66fdac arr.rend() addr : 0x66fdac<br/> (arr.data() - 1) addr : 0x66fdac arr.crend() addr : 0x66fdac</p>\n</blockquote>\n<pre><code>int main()\n{\n    const int SIZE = 5;\n    // 初始化容器\n    std::array&lt;int, SIZE&gt; arr{1, 2, 3, 4, 5};\n\n    // 数组容量访问函数\n    // 检查容器是否为空，为空返回 true\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; \"arr.empty() : \" &lt;&lt; arr.empty() &lt;&lt; std::endl;\n    // 返回容纳的元素数\n    std::cout &lt;&lt; \"arr.size() : \" &lt;&lt; arr.size() &lt;&lt; std::endl;\n    // 返回可容纳的最大元素数\n    std::cout &lt;&lt; \"arr.max_size() : \" &lt;&lt; arr.max_size() &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<blockquote>\n<p>输出结果：<br/> arr.empty() : false<br/> arr.size() : 5<br/> arr.max_size() : 5</p>\n</blockquote>\n<pre><code>// 数组操作函数\nint main()\n{\n    const int SIZE = 5;\n    auto Print = [](const std::string &amp;str, const std::array&lt;int, SIZE&gt; &amp;arr){\n        std::cout &lt;&lt; str &lt;&lt; \" value : \\t\";\n        for (const auto &amp;val : arr) {\n            std::cout &lt;&lt; val &lt;&lt; \"\\t\";\n        }\n        std::cout &lt;&lt; \"\\n\";\n    };\n    // 初始化容器\n    std::array&lt;int, SIZE&gt; arr{1, 2, 3, 4, 5};\n    Print(\"original arr\", arr);\n    // 数组操作\n    // 以指定值填充容器\n    arr.fill(10);\n    Print(\"fill arr\", arr);\n\n    // 交换数组内容，数组元素个数和类型相同\n    std::array&lt;int, SIZE&gt; arr2{};  // 初始化为零\n    Print(\"original arr2\", arr2);\n    arr2.swap(arr);\n    Print(\"swap arr\", arr);\n    Print(\"swap arr2\", arr2);\n    return 0;\n}\n</code></pre>\n<blockquote>\n<p>输出结果：<br/> original arr value : 1 2 3 4 5<br/> fill arr value : 10 10 10 10 10<br/> original arr2 value : 0 0 0 0 0<br/> swap arr value : 0 0 0 0 0<br/> swap arr2 value : 10 10 10 10 10</p>\n</blockquote>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;array&gt;\n#include &lt;type_traits&gt;\n#include &lt;tuple&gt;\n\nint main()\n{\n    const int SIZE = 5;\n    auto Print = [](const std::string &amp;str, const std::array&lt;int, SIZE&gt; &amp;arr){\n        std::cout &lt;&lt; str &lt;&lt; \" value : \\t\";\n        for (const auto &amp;val : arr) {\n            std::cout &lt;&lt; val &lt;&lt; \"\\t\";\n        }\n        std::cout &lt;&lt; \"\\n\";\n    };\n    // 初始化容器\n    std::array&lt;int, SIZE&gt; arr1{1, 2, 3, 4, 5};\n    std::array&lt;int, SIZE&gt; arr2{1, 2, 3, 4, 6};\n\n    // 非成员函数 (operator 相关操作在 c++20 中被移除)\n    // 按照字典顺序比较 array 中的值\n    // operator==、operator!=、operator&lt;、operator&lt;=、operator&gt;、operator&gt;=\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; \"arr1 == arr2 : \" &lt;&lt; (arr1 == arr2) &lt;&lt; std::endl;\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; \"arr1 != arr2 : \" &lt;&lt; (arr1 != arr2) &lt;&lt; std::endl;\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; \"arr1 &lt; arr2 : \" &lt;&lt; (arr1 &lt; arr2) &lt;&lt; std::endl;\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; \"arr1 &lt;= arr2 : \" &lt;&lt; (arr1 &lt;= arr2) &lt;&lt; std::endl;\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; \"arr1 &gt; arr2 : \" &lt;&lt; (arr1 &gt; arr2) &lt;&lt; std::endl;\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; \"arr1 &gt;= arr2 : \" &lt;&lt; (arr1 &gt;= arr2) &lt;&lt; std::endl;\n\n    // 访问 array 的一个元素\n    std::cout &lt;&lt; \"arr1[0] : \" &lt;&lt; std::get&lt;0&gt;(arr1) &lt;&lt; std::endl;\n    // 特化 std::swap 算法\n    Print(\"original arr1\", arr1);\n    Print(\"original arr2\", arr2);\n    std::swap(arr1, arr2);\n    Print(\"swap arr1\", arr1);\n    Print(\"swap arr2\", arr2);\n\n    // 辅助类操作\n    // 获得 array 的大小\n    std::cout &lt;&lt; \"std::array&lt;int, SIZE&gt; size : \" &lt;&lt; std::tuple_size&lt;std::array&lt;int, SIZE&gt; &gt;::value &lt;&lt; std::endl;\n    // 获得 array 元素的类型\n    using type_t = std::tuple_element&lt;0, decltype (arr1)&gt;::type;\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; std::is_same&lt;int, type_t&gt;::value &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<blockquote>\n<p>输出结果：<br/> arr1 == arr2 : false<br/> arr1 != arr2 : true<br/> arr1 &lt; arr2 : true<br/> arr1 &lt;= arr2 : true<br/> arr1 &gt; arr2 : false<br/> arr1 &gt;= arr2 : false<br/> arr1[0] : 1<br/> original arr1 value : 1 2 3 4 5<br/> original arr2 value : 1 2 3 4 6<br/> swap arr1 value : 1 2 3 4 6<br/> swap arr2 value : 1 2 3 4 5<br/> std::array&lt;int, SIZE&gt; size : 5<br/> true</p>\n</blockquote>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}