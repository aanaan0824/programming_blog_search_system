{"blogid": "126743550", "writerAge": "码龄1年", "writerBlogNum": "301", "writerCollect": "33", "writerComment": "0", "writerFan": "19", "writerGrade": "5级", "writerIntegral": "3035", "writerName": "小迅想变强", "writerProfileAdress": "writer_image\\profile_126743550.jpg", "writerRankTotal": "8368", "writerRankWeekly": "7164", "writerThumb": "10", "writerVisitNum": "16481", "blog_read_count": "20", "blog_time": "于 2022-09-07 13:09:41 发布", "blog_title": "LeetCode·45.跳跃游戏 ||· 贪心·动态规划", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>链接：<a class=\"link-info\" href=\"https://leetcode.cn/problems/jump-game-ii/solution/-by-xun-ge-v-l2cc/\" title=\"https://leetcode.cn/problems/jump-game-ii/solution/-by-xun-ge-v-l2cc/\">https://leetcode.cn/problems/jump-game-ii/solution/-by-xun-ge-v-l2cc/</a><br/> 来源：力扣（LeetCode）<br/> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 </p>\n<h1>题目<img alt=\"\" height=\"305\" src=\"image\\cb12b134467a474ab2d9fc7e0fe79e34.png\" width=\"967\"/></h1>\n<p> </p>\n<h1>示例<img alt=\"\" height=\"511\" src=\"image\\b4d5d2090c964bb3ac17b7ed7f574661.png\" width=\"976\"/></h1>\n<p> </p>\n<h1>思路</h1>\n<p><strong>解题思路<br/> 【贪心】</strong><br/> 本题要计算最小步数，那么就要想清楚什么时候步数才一定要加一呢？</p>\n<p>贪心的思路，局部最优：当前可移动距离尽可能多走，如果还没到终点，步数再加一。整体最优：一步尽可能多走，从而达到最小步数。</p>\n<p>思路虽然是这样，但在写代码的时候还不能真的就能跳多远跳远，那样就不知道下一步最远能跳到哪里了。</p>\n<p>所以真正解题的时候，要从覆盖范围出发，不管怎么跳，覆盖范围内一定是可以跳到的，以最小的步数增加覆盖范围，覆盖范围一旦覆盖了终点，得到的就是最小步数！</p>\n<p>这里需要统计两个覆盖范围，当前这一步的最大覆盖和下一步最大覆盖。</p>\n<p>如果移动下标达到了当前这一步的最大覆盖最远距离了，还没有到终点的话，那么就必须再走一步来增加覆盖范围，直到覆盖范围覆盖了终点。</p>\n<p><strong>【动态规划】</strong><br/> 定义dp数组</p>\n<ul><li>含义：dp[i]表示从下标0到下标i所以的最小跳跃步数</li><li>初始化：因为需要动态更新dp，所以初始化应该为最大值，才能保存最小值</li><li>动态状态方程：dp[i] = MIN(dp[i],dp[j]+1);</li></ul>\n<p>如何判断从下标0到下标i所以的最小跳跃步数，使用双指针，一个指向当前位置i，一个从0开始遍历，判断需要多少步才能到当前位置，每次保存最小步数。</p>\n<p></p>\n<h1>代码</h1>\n<p><strong>【贪心】</strong></p>\n<pre><code class=\"language-cpp\">#define MAX(a, b) ((a) &gt; (b) ? (a) : (b))\n\nint jump(int* nums, int numsSize){ \n    int curDistance = 0;    // 当前覆盖的最远距离下标\n    int ans = 0;            // 记录走的最大步数\n    int nextDistance = 0;   // 下一步覆盖的最远距离下标\n    for (int i = 0; i &lt; numsSize - 1; i++) { // 注意这里是小于nums.size() - 1，这是关键所在\n        nextDistance = MAX(nums[i] + i, nextDistance); // 更新下一步覆盖的最远距离下标\n        if (i == curDistance) {                 // 遇到当前覆盖的最远距离下标\n            curDistance = nextDistance;         // 更新当前覆盖的最远距离下标\n            ans++;\n        }\n    }\n    return ans;\n}\n\n作者：xun-ge-v\n链接：https://leetcode.cn/problems/jump-game-ii/solution/-by-xun-ge-v-l2cc/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre>\n<p><strong>【动态规划】</strong></p>\n<pre><code class=\"language-cpp\">#define MIN(a, b) ((a) &lt; (b) ? (a) : (b))\n\nint jump(int* nums, int numsSize)\n{\n    //定义dp数组\n    int dp[numsSize];\n    dp[0] = 0;\n    //双重遍历\n   \n    for(int i =1; i&lt; numsSize; i++)\n    {\n        dp[i] = INT_MAX;//初始化最大值\n        for(int j = 0; j &lt; i; j++)\n        {\n            if(j + nums[j] &gt;= i)\n            {\n                dp[i] = MIN(dp[i],dp[j]+1);//更新dp数组，保存最小值\n            }\n        }\n    }\n    return dp[numsSize-1];\n}\n\n作者：xun-ge-v\n链接：https://leetcode.cn/problems/jump-game-ii/solution/-by-xun-ge-v-l2cc/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre>\n<p></p>\n</div>\n</div>"}