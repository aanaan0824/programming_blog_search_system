{"blogid": "122981983", "writerAge": "码龄1年", "writerBlogNum": "368", "writerCollect": "911", "writerComment": "40", "writerFan": "204", "writerGrade": "5级", "writerIntegral": "3969", "writerName": "Just-ForStudy", "writerProfileAdress": "writer_image\\profile_122981983.jpg", "writerRankTotal": "4730", "writerRankWeekly": "18925", "writerThumb": "193", "writerVisitNum": "302332", "blog_read_count": "7671", "blog_time": "于 2022-02-17 14:01:39 发布", "blog_title": "Java 中的双冒号“::”", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-light\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h1><a id=\"_Java_Method_references_0\"></a>一、双冒号“::”就是 Java 中的方法引用(Method references)</h1>\n<p>方法引用的格式是<code>类名::方法名</code>。一般是用作 <a href=\"https://blog.csdn.net/ChineseSoftware/article/details/122981712\">Lambda表达式</a>。</p>\n<p>形如 <strong>ClassName::methodName</strong> 或者 <strong>objectName::methodName</strong> 的表达式，叫做方法引用(Method Reference)。看看编译器是如何根据 “晦涩难懂” 的 Method Reference 来推断开发者的意图的。例如：</p>\n<pre><code class=\"prism language-java\"><span class=\"token number\">1.</span>表达式：\nperson <span class=\"token operator\">-&gt;</span> person<span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n可以替换成：\n<span class=\"token class-name\">Person</span><span class=\"token operator\">::</span><span class=\"token function\">getName</span>\n\n<span class=\"token number\">2.</span>表达式：\n<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-&gt;</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashMap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">&gt;</span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n可以替换成：\n<span class=\"token class-name\">HashMap</span><span class=\"token operator\">::</span><span class=\"token keyword\">new</span>\n</code></pre>\n<h1><a id=\"_17\"></a>二、四种方法引用</h1>\n<p><img alt=\"\" src=\"image\\03cf85c8d5e3a5fa0c842e44ca49071e.png\"/></p>\n<p>1️⃣指向静态方法的引用<br/> 2️⃣指向某个对象的实例方法的引用<br/> 3️⃣指向某个类型的实例方法的引用<br/> 4️⃣指向构造方法的引用</p>\n<h1><a id=\"_25\"></a>三、总结</h1>\n<p>其实，<a href=\"https://blog.csdn.net/ChineseSoftware/article/details/119212455\">JVM</a> 本身并不支持指向方法引用，过去不支持，现在也不支持。Java 8 对方法引用的支持只是编译器层面的支持，虚拟机执行引擎并不了解方法引用。编译器遇到方法引用的时候，会像上面那样自动推断出开发者的意图，将方法引用还原成接口实现对象，或者更形象地说，就是把方法引用设法包装成一个接口实现对象，这样虚拟机就可以无差别地执行字节码文件而不需要管什么是方法引用了。</p>\n<p>需要注意的是，方法引用是用来简化接口实现代码的，并且凡是能够用方法引用来简化的接口，都有这样的特征：有且只有一个待实现的方法。这种接口在 Java 中有个专门的名称： 函数式接口。当试图用方法引用替代一个非函数式接口时，会有这样的错误提示： xxx is not a functional interface。</p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}