{"blogid": "126743172", "writerAge": "码龄2年", "writerBlogNum": "37", "writerCollect": "38", "writerComment": "17", "writerFan": "813", "writerGrade": "3级", "writerIntegral": "418", "writerName": "FODKING", "writerProfileAdress": "writer_image\\profile_126743172.jpg", "writerRankTotal": "38181", "writerRankWeekly": "7348", "writerThumb": "16", "writerVisitNum": "29130", "blog_read_count": "16", "blog_time": "于 2022-09-07 12:33:29 发布", "blog_title": "Shiro反序列化漏洞综合", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-tomorrow-night\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p>原因：Apache Shiro框架提供了记住我的功能（RememberMe），用户登陆成功后会生成经过加密并编码的cookie，在服务端接收cookie值后，Base64解码–&gt;AES解密–&gt;反序列化。攻击者只要找到AES加密的密钥，就可以构造一个恶意对象，对其进行序列化–&gt;AES加密–&gt;Base64编码，然后将其作为cookie的rememberMe字段发送，Shiro将rememberMe进行解密并且反序列化，最终造成反序列化漏洞。<br/> <img alt=\"在这里插入图片描述\" src=\"image\\bf8f7049e78e4732a1a993d4605f14fa.png\"/></p>\n<p>影响范围:Shiro框架<br/> 验证手法:<br/> 验证是否存在shiro框架<br/> 1.返回包中存在 rememberMe=deleteMe<br/> 2.请求中cookie中加入 rememberMe=deleteMe 返回rememberMe=deleteMe<br/> <img alt=\"在这里插入图片描述\" src=\"image\\42810231618a4db1a17ef848f5952c5a.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"image\\fe62420254934c6cbf75a2b6057da3a7.png\"/></p>\n<p>在反序列化时,不会对其进行过滤,所以如果传入恶意代码将会造成安全问题<br/> 在 1.2.4 版本前,是默认ASE秘钥,Key: kPH+bIxk5D2deZiIxcaaaA==,可以直接反序列化执行恶意代码<br/> 而在1.2.4之后,ASE秘钥就不为默认了,需要获取到Key才可以进行渗透</p>\n<p>key获取方法：shiro高版本要求开发者自己设置，如果开发者没有设置，则默认动态生成，降低了固定密钥泄漏的风险。<br/> 但有可能存在代码复用的可能，可以在github上搜索<code>\"securityManager.setRememberMeManager(rememberMeManager); Base64.decode(“或\"setCipherKey(Base64.decode(”）</code><br/> <img alt=\"在这里插入图片描述\" src=\"image\\6b4242ef4d5347bcbae7c41e782a7a51.png\"/><br/> Guns框架内部集成了shiro并进行二次开发，作者自定义密钥并固定，此时用户若不对密钥进行再次修改，即使升级shiro版本，也依旧存在固定密钥的风险。</p>\n<p>脚本跑（shiro-exploit ）<br/> 旧版本(1.2.4之前)使用AES-CBC加密模式，新版是使用AES-GCM加密模式。<br/> shiro-exploit<br/> -v CBC加密版本 Version 为1 ，GCM加密版本 Version 为2<br/> -u 参数可将payload发送至指定url，如不指定url将输出base64编码后的payload用于手工利用<br/> -k 参数可指定shiro加密所用的key，如不指定将使用默认key kPH+bIxk5D2deZiIxcaaaA== 可修改文件头部的key来更换默认key<br/> python shiro-exploit.py check -u http://10.xxx.xxx.72 脚本爆破key<br/> <img alt=\"在这里插入图片描述\" src=\"image\\c3f1e5018cc04ebfa6ebe4db9e9fa6d4.png\"/><br/> shiro-exploit<br/> 内置6条tomcat回显链，<br/> [CommonsCollectionsK1/CommonsCollectionsK2/CommonsBeanutils1/CommonsBeanutils2/Jdk7u21/Jdk8u20]</p>\n<p>python3 shiro-exploit.py echo -g CommonsCollectionsK1 ##不指定，默认为whoami<br/> python3 shiro-exploit.py echo -g CommonsCollectionsK1 -c ipconfig<br/> <img alt=\"在这里插入图片描述\" src=\"image\\166a324e83ec469980ad636124448c39.png\"/><br/> Shiro反序列化注入内存马<br/> 通过TemplatesImpl去加载恶意类，然后把动态注册Filter的代码写在反序列化的类的static方法中。<br/> 不同利用链有不同的内存马，不同点利用不同方式获取到standardContext<br/> 详情请看p牛的项目（https://github.com/phith0n/JavaThings。） CommonsBeanutils1Shiro内存马<br/> <img alt=\"在这里插入图片描述\" src=\"image\\a0687aadebc5455cba25cab98a3637b2.png\"/></p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}