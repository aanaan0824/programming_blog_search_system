{"blogid": "125362560", "writerAge": "码龄4年", "writerBlogNum": "156", "writerCollect": "2435", "writerComment": "2543", "writerFan": "2425", "writerGrade": "6级", "writerIntegral": "5842", "writerName": "Mindtechnist", "writerProfileAdress": "writer_image\\profile_125362560.jpg", "writerRankTotal": "2818", "writerRankWeekly": "414", "writerThumb": "1693", "writerVisitNum": "114026", "blog_read_count": "2408", "blog_time": "已于 2022-06-25 10:14:05 修改", "blog_title": "C/C++程序的编译过程", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-tomorrow-night\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\2203f5b7b64346c58707e59848f072fd.jpeg\"/><br/> 我们拿到一个.c或者是.cpp源文件，它是怎么样一步步的变化成一个机器可执行文件的呢？程序的一般编译流程主要包括四大部分：预处理、编译、汇编和链接。下面讲解这四步的具体工作，带你了解源文件到可执行文件是怎样生成的。</p>\n<hr/>\n<blockquote>\n<p></p>\n<div class=\"toc\">\n<h3>编译过程</h3>\n<ul><li><ul><li><ul><li><a href=\"#1_Preprocess_6\">1. 预处理（Preprocess）</a></li><li><a href=\"#2_Compilation_17\">2. 编译（Compilation）</a></li><li><a href=\"#3_Assemoly_22\">3. 汇编（Assemoly）</a></li><li><a href=\"#4_Linking_24\">4. 链接（Linking）</a></li></ul>\n</li></ul>\n</li></ul>\n</div>\n<p></p>\n</blockquote>\n<hr/>\n<h3><a id=\"1_Preprocess_6\"></a>1. 预处理（Preprocess）</h3>\n<p>这一步由预处理器完成，对源程序中的伪指令（以#开头的指令）和特殊符号进行处理，伪指令包括宏定义指令、条件编译指令和头文件中包含的指令。这一步的主要工作包括以下内容：</p>\n<ul><li>将所有的#define删除，并将宏定义进行宏展开；</li><li>处理所有条件编译指令，如#if、#ifdef、#ifndef、#else、#elif、#endif等；</li><li>处理 #include预编译指令，将被包含的头文件内容插入该预编译指令的位置，如果是多重包含的话会递归执行；</li><li>处理其他宏指令，包括#error、#warning、#line、#pragma；</li><li>处理所有注释（C++的//，C语言的/**/），一般会用一个空格来代替连续的注释；</li><li>添加行号和文件标识，以便于编译时编译器产生调试用的行号信息及编译时产生编译错误和警告时可以把行号打印出来；</li><li>保留所有的#pragma编译器指令；</li><li>处理预定义的宏：如__DATE__、__FILE__等；</li><li>处理三元符：比如会将??=替换为#，将??/替换成\\等（对于键盘不提供#等输入的情况，可能会用到三元符，可以直接忽略这一条）；</li></ul>\n<h3><a id=\"2_Compilation_17\"></a>2. 编译（Compilation）</h3>\n<p>这一步由编译器完成，对预处理后的文件进行词法分析、语法分析、语义分析以及优化后生成相应的汇编代码文件。</p>\n<ul><li>词法分析：词法分析是编译过程的第一个阶段，这个阶段的任务可以看成是从左到右一个字符一个字符地读入源程序，从中识别出一个个单词符号，即对构成源程序的字符流进行扫描然后根据构词规则识别单词(也称单词符号或符号)。上述读入源程序的过程和识别符号的任务通过词法分析程序实现，词法分析整个过程依据的是语言的词法规则。词法分析程序的输出通常是一个二元组，即单词种别和单词自身的值。词法分析程序可以使用lex等工具自动生成。</li><li>语法分析：语法分析是编译过程的一个逻辑阶段，此阶段的任务是在词法分析的基础上将单词序列组合成各类语法短语，如“程序”，“语句”，“表达式”等等。语法分析程序判断源程序在结构上是否正确。</li><li>语义分析：语义分析是编译过程的一个逻辑阶段，语义是解释控制信息每个部分的意义，它规定了需要发出何种控制信息，以及完成的动作与做出什么样的响应，此阶段的任务是对结构上正确的源程序进行上下文有关性质的审查, 进行类型审查，语义分析将审查类型并报告错误。也就是说，语义分析结合上下文推导出语句真正的含义。</li></ul>\n<h3><a id=\"3_Assemoly_22\"></a>3. 汇编（Assemoly）</h3>\n<p>由汇编器完成，将汇编代码转变成机器可执行的二进制代码（机器码），并生成目标文件。之所以要经过预处理、编译、汇编这么一系列步骤才生成目标文件，是因为在每一阶段都有相应的优化技术，只有在每个阶段分别优化并生成最为高效的机器指令才能达到最大的优化效果，如果一步到位直接从源程序生成目标文件，可能就会失去很多代码优化的机会。</p>\n<h3><a id=\"4_Linking_24\"></a>4. 链接（Linking）</h3>\n<p>由链接器完成，主要解决多个文件之间符号引用的问题，即symbol resolution。编译时编译器只对单个文件进行处理，如果该文件里面需要引用到其他文件中的符号，比如全局变量或者调用了某个库函数中的函数，那么这时候，在这个文件中该符号的地址是没法确定的，只能由链接器把所有的目标文件链接到一起才能确定最终的地址，并生成最终的可执行文件。无论采用静态链接还是动态链接，都会生成一个可以在计算机上执行的可执行程序。<br/> <img alt=\"在这里插入图片描述\" src=\"image\\c22b258c226140b49b914e2cc34c6787.png\"/></p>\n<hr/>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\d9c995a37eb54b1bbfcfab38b1b91552.jpeg\"/></p>\n<p><img alt=\"在这里插入图片描述\" src=\"https://img-blog.csdnimg.cn/e6d901c7abb546aca518bacf15623535.gif#pic_center\"/></p>\n<hr/>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}