{"blogid": "125229190", "writerAge": "码龄1年", "writerBlogNum": "19", "writerCollect": "2056", "writerComment": "1005", "writerFan": "2713", "writerGrade": "5级", "writerIntegral": "3587", "writerName": "小张﹉", "writerProfileAdress": "writer_image\\profile_125229190.jpg", "writerRankTotal": "7465", "writerRankWeekly": "83142", "writerThumb": "1617", "writerVisitNum": "37832", "blog_read_count": "1550", "blog_time": "已于 2022-07-17 18:18:40 修改", "blog_title": "BF，KMP算法（万字图文详解）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\" style=\"text-align:center;\"><strong>目录</strong></p>\n<p id=\"%E5%89%8D%E8%A8%80-toc\" style=\"margin-left:0px;text-align:center;\"><a href=\"#%E5%89%8D%E8%A8%80\">前言(很重要)</a></p>\n<p id=\"BF%E7%AE%97%E6%B3%95-toc\" style=\"margin-left:0px;text-align:center;\"><a href=\"#BF%E7%AE%97%E6%B3%95\">BF算法定义</a></p>\n<p id=\"%C2%A0BF%E7%AE%97%E6%B3%95%E7%9A%84%E5%9B%BE%E6%96%87%E8%A7%A3%E9%87%8A-toc\" style=\"margin-left:0px;text-align:center;\"><a href=\"#%C2%A0BF%E7%AE%97%E6%B3%95%E7%9A%84%E5%9B%BE%E6%96%87%E8%A7%A3%E9%87%8A\"> BF算法的图文解释</a></p>\n<p id=\"BF%E7%AE%97%E6%B3%95%E7%9A%84-toc\" style=\"margin-left:0px;text-align:center;\"><a href=\"#BF%E7%AE%97%E6%B3%95%E7%9A%84\">BF算法的灵魂——回溯</a></p>\n<p id=\"%C2%A0BF%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-toc\" style=\"margin-left:0px;text-align:center;\"><a href=\"#%C2%A0BF%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0\"> BF算法代码实现</a></p>\n<p id=\"BF%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%C2%A0-toc\" style=\"margin-left:0px;text-align:center;\"><a href=\"#BF%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%C2%A0\">BF算法的时间复杂度 </a></p>\n<p id=\"KMP%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89-toc\" style=\"margin-left:0px;text-align:center;\"><a href=\"#KMP%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89\">KMP算法的定义</a></p>\n<p id=\"KMP%E7%AE%97%E6%B3%95%E5%92%8CBF%E7%AE%97%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB-toc\" style=\"margin-left:0px;text-align:center;\"><a href=\"#KMP%E7%AE%97%E6%B3%95%E5%92%8CBF%E7%AE%97%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB\">KMP算法和BF算法的区别</a></p>\n<p id=\"Next%E6%95%B0%E7%BB%84-toc\" style=\"margin-left:0px;text-align:center;\"><a href=\"#Next%E6%95%B0%E7%BB%84\">Next数组</a></p>\n<p id=\"%C2%A0Next%E6%95%B0%E7%BB%84%E7%9A%84%E6%B1%82%E6%B3%95%EF%BC%88%E6%89%8B%E7%AE%97%EF%BC%89-toc\" style=\"margin-left:0px;text-align:center;\"><a href=\"#%C2%A0Next%E6%95%B0%E7%BB%84%E7%9A%84%E6%B1%82%E6%B3%95%EF%BC%88%E6%89%8B%E7%AE%97%EF%BC%89\"> Next数组的求法（手算）</a></p>\n<p id=\"%C2%A0Next%E6%95%B0%E7%BB%84%E7%9A%84%E6%B1%82%E6%B3%95%EF%BC%88%E4%BB%A3%E7%A0%81%EF%BC%89%C2%A0-toc\" style=\"margin-left:0px;text-align:center;\"><a href=\"#%C2%A0Next%E6%95%B0%E7%BB%84%E7%9A%84%E6%B1%82%E6%B3%95%EF%BC%88%E4%BB%A3%E7%A0%81%EF%BC%89%C2%A0\"> Next数组的求法（代码） </a></p>\n<p id=\"KMP%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81%C2%A0-toc\" style=\"margin-left:0px;text-align:center;\"><a href=\"#KMP%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81%C2%A0\">KMP算法代码 </a></p>\n<p id=\"%C2%A0Next%E6%95%B0%E7%BB%84%E7%9A%84%E4%BC%98%E5%8C%96%E2%80%94%E2%80%94Nextval%E6%95%B0%E7%BB%84-toc\" style=\"margin-left:0px;text-align:center;\"><a href=\"#%C2%A0Next%E6%95%B0%E7%BB%84%E7%9A%84%E4%BC%98%E5%8C%96%E2%80%94%E2%80%94Nextval%E6%95%B0%E7%BB%84\"> Next数组的优化——Nextval数组</a></p>\n<p id=\"%C2%A0%E7%BB%93%E6%9D%9F%E8%AF%AD-toc\" style=\"margin-left:0px;text-align:center;\"><a href=\"#%C2%A0%E7%BB%93%E6%9D%9F%E8%AF%AD\"> KMP算法时间复杂度</a></p>\n<p id=\"%E7%BB%93%E6%9D%9F%E8%AF%AD%C2%A0-toc\" style=\"margin-left:0px;text-align:center;\"><a href=\"#%E7%BB%93%E6%9D%9F%E8%AF%AD%C2%A0\">结束语 </a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h1 id=\"%E5%89%8D%E8%A8%80\">前言(很重要)</h1>\n<blockquote>\n<p>        大家好，这里是小张，已经很久没有更新了，距上次更新已有快有一个月了。现在学校已经放暑假了，时间相对来说比较充裕，所以我觉得是时候继续写博客了。然后今天的内容是数据结构中<strong>BF算法，KMP算法的详解</strong>，并在里面加入了些我个人的理解和解释，希望能够给大家带来帮助。</p>\n<p><strong>        另外有很多小伙伴们在学习算法的时候，只去学习一些关于算法理论的知识，并不知道自己的代码实战能力如何</strong>，<strong>也不清楚到底对该算法的了解有多深，所以在这里小张给大家推荐一个很棒的平台，在这里有很多的面试和算法题，也有很多的面试和求职的机会，大家可以点击下方链接进入牛客网刷算法真题，提高自己代码实战能力，早日拿到满意的offer！</strong></p>\n<p><strong><a class=\"link-info\" href=\"https://www.nowcoder.com/exam/oj/ta?tpId=13&amp;fromPut=pc_csdncpt_xiaozhang_jzsf\" title=\"点击这里进入牛客网刷算法面试真题提高实战能力\">点击这里进入牛客网刷算法面试真题提高实战能力</a></strong></p>\n</blockquote>\n<h1 id=\"BF%E7%AE%97%E6%B3%95\">BF算法定义</h1>\n<blockquote>\n<p>         首先给大家带来的是<strong>BF算法</strong>，那么什么是BF算法，为什么要先从BF算法说起，不从KMP算法说起呢？</p>\n<p>        BF算法：BF算法，即暴力(Brute Force)算法，是普通的模式匹配算法，BF算法的思想就是将目标串S的第一个字符与模式串T的第一个字符进行匹配，若相等，则继续比较S的第二个字符和 T的第二个字符；若不相等，则比较S的第二个字符和T的第一个字符，依次比较下去，直到得出最后的匹配结果。BF算法是一种蛮力算法。</p>\n<p>        为什么先从BF算法说起：是因为<strong>BF算法可以说是KMP算法的基础</strong>，熟悉了BF算法之后就能够更快的去理解KMP算法内容，所以我们就先从BF算法说起。</p>\n</blockquote>\n<h1 id=\"%C2%A0BF%E7%AE%97%E6%B3%95%E7%9A%84%E5%9B%BE%E6%96%87%E8%A7%A3%E9%87%8A\"> BF算法的图文解释</h1>\n<p><img alt=\"\" height=\"269\" src=\"image\\c06da24e436b41b8a2547a57a9fbf789.png\" width=\"542\"/></p>\n<blockquote>\n<p>        在该图中有两个串，一个是<strong>串S</strong>另外一个是<strong>串T</strong>，其中串<strong>S我们称它为主串</strong>，串<strong>T我们称它为子串</strong>，i指向主串S的第一个元素（a），j指向子串T的第一个元素（a）。</p>\n<p>        现在我们开始进行串的匹配操作，从主串的第一个字符开始与我们子串的第一个字符进行比较 ，此时我们根据图示可以发现主串中i所对应的元素与子串中j所<strong>对应的元素都是a</strong>，既然相等，我们就可以使<strong>i，j的位置往后移动</strong>。此时i指向主串的第二个元素，j指向子串的第二个元素，我们根据图示可以发现主串中i所对应的元素与子串中j所对应的元素还是a，那么我们继续<strong>使i，j的位置往后移动</strong>。此时i指向主串的第三个元素，j指向子串的第三个元素，我们根据图示可以发现主串中i所对应的元素与子串中j所对应的元素还是a，那么我们继续使i，j的位置往后移动。</p>\n<p>        此时i指向主串的第四个元素，j指向子串的第四个元素，我们根据图示可以发现主串中i所对应的元素是a，但是子串j对应的元素为b，此时<strong>发生了不匹配的情况</strong>，这时我们就要进行<strong>“回溯”</strong>操作，主串S进行回溯操作，使i指向主串S的第二个元素，而此时j指向子串T的第一个元素然后再次进行匹配操作。</p>\n<p>        我们再进行如上的操作，我们会发现依旧是到了第四个元素匹配失败，那么我们此时再对S进行回溯操作，使i指向主串S的第三个元素，使j指向子串T的第一个元素之后再次进行匹配操作。</p>\n<p>        我们这时发现主串与字串的每个元素都匹配成功了，此时结束匹配。</p>\n</blockquote>\n<h1 id=\"BF%E7%AE%97%E6%B3%95%E7%9A%84\">BF算法的灵魂——回溯</h1>\n<blockquote>\n<p>        刚刚在BF算法的图文解释中我们多次提到了<strong>“回溯操作”，</strong>那么什么是回溯呢。回溯是BF算法的灵魂，但同时也是BF算法中比较难理解的地方，下面来细说说回溯操作！</p>\n</blockquote>\n<blockquote>\n<p>        回溯：在什么时候要进行回溯操作呢，没错，在主串中的元素和子串中的元素发生不匹配的情况时要进行回溯操作，<strong>回溯操作是针对于主串来说的</strong>， 我们还以上图来进行解释，此时我们的主串中的的a与子串中的b发生了不匹配的操作，满足了回溯的条件，那么我们此时的主串就要进行回溯操作。</p>\n<p><strong>        回溯操作有一个公式：i=i-j+2；</strong>这个公式是怎么来的呢，我们来根据下图来进行解释，此时我们的i的位置4，j的位置也是4，但是我们的i此时实际上并没有移动四次，只移动了三次，是因为本来我们的i就已经指向了1。所以说该公式<strong>i=i-j+2</strong>可以分解为<strong>两部分</strong>，<strong>第一部分是i-j+1。</strong>意为我们此时用主串的i减去子串的j时，本来只移动了三个间隔我们却减去了四个间隔，我们此时是多减去了一个间隔，所以我们现在应该在把这个多减去的间隔加回来，所以此时就是<strong>i-j+1。第二部分是(i-j+1)+1</strong>，即在第一部分的基础上我们又加了一个1，是因为我们既然前一个位置的元素开始已经匹配失败了，那么我们就要使<strong>主串的位置++，从而找到一个新的位置再次进行匹配操作</strong>。而对于子串中的j的话，每次一旦执行回溯操作的话，我们子串中的j都要置为1，意为从子串第一个元素开始重新进行串的匹配操作。</p>\n<p>        综上，回溯的公式就为：<strong>i=i-j+2。</strong></p>\n</blockquote>\n<p><img alt=\"\" height=\"269\" src=\"image\\c06da24e436b41b8a2547a57a9fbf789.png\" width=\"542\"/></p>\n<h1 id=\"%C2%A0BF%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0\"> BF算法代码实现</h1>\n<p><strong>第一种：在数组中第一个元素置为0，从数组下标为1开始（符合上方规律的一种）</strong></p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;string.h&gt;\nusing namespace std;\n//BF算法函数\nint BF(char*S, char*T)\n{\n\t//主串的长度\n\tint lenS = strlen(S)-1;\n\t//子串的长度\n\tint lenT = strlen(T)-1;\n\t//定义i，j分别作为主串和子串的指示器\n\tint i = 1, j = 1;\n\t//当主串和子串没有匹配完全时执行该while语句\n\twhile (i &lt;= lenS &amp;&amp; j &lt;= lenT)\n\t{\n\t\t//如果此时主串和子串的元素匹配成功\n\t\tif (S[i] == T[j])\n\t\t{\n\t\t\t//就让它们指向后一个元素继续进行匹配操作\n\t\t\ti++;\n\t\t\tj++;\n\t\t}\n\t\t//如果匹配不成功的话就要进行回溯操作\n\t\t//主串回溯。子串的j指向0\n\t\telse\n\t\t{\n\t\t\ti = i - j + 2;\n\t\t\tj = 1;\n\t\t}\n\t}\n\t//如果此时j的值大于等于子串的长度说明已经匹配成功\n\tif (j &gt;= lenT)\n\t{\n\t\t//返回匹配成功的位置\n\t\t//因为我们此时是从下标0开始的\n\t\t//所以我们往后加了一个1返回的是子串在主串中的位置\n\t\treturn i - lenT;\n\t}\n\t//匹配不成功\n\telse\n\t{\n\t\treturn 0;\n\t}\n\n}\n\nint main()\n{\n\tchar S[100], T[100];\n\twhile (1)\n\t{\n\t\tcout &lt;&lt; \"请输入主串，第一个元素请置为0\" &lt;&lt; endl;\n\t\tcin &gt;&gt; S;\n\t\tcout &lt;&lt; \"请输入子串，第一个元素请置为0\" &lt;&lt; endl;\n\t\tcin &gt;&gt; T;\n\t\tint ret = BF(S, T);\n\t\tif (ret == 0)\n\t\t{\n\t\t\tcout &lt;&lt; \"很抱歉，匹配失败，未在主串中找到子串的相关信息\" &lt;&lt; endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout &lt;&lt; \"匹配成功\" &lt;&lt; endl &lt;&lt; \"匹配成功的位置为\" &lt;&lt; ret &lt;&lt; endl;\n\t\t}\n\t}\n\treturn 0;\n}</code></pre>\n<p><strong>运行结果展示：</strong></p>\n<p><img alt=\"\" height=\"637\" src=\"image\\5ed9c464bca7424c8459098fdc6061bb.png\" width=\"1200\"/></p>\n<p><strong>第二种：数组第一个元素不置为1（仅供参考，不建议使用） </strong></p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;string.h&gt;\nusing namespace std;\n\n//BF算法函数\nint BF(char*S, char*T)\n{\n\t//主串的长度\n\tint lenS = strlen(S);\n\t//子串的长度\n\tint lenT = strlen(T);\n\t//定义i，j分别作为主串和子串的指示器\n\tint i = 0, j = 0;\n\t//当主串和子串没有匹配完全时执行该while语句\n\twhile (i &lt; lenS &amp;&amp; j &lt; lenT)\n\t{\n\t\t//如果此时主串和子串的元素匹配成功\n\t\tif (S[i] == T[j])\n\t\t{\n\t\t\t//就让它们指向后一个元素继续进行匹配操作\n\t\t\ti++;\n\t\t\tj++;\n\t\t}\n\t\t//如果匹配不成功的话就要进行回溯操作\n\t\t//主串回溯。子串的j指向0\n\t\telse\n\t\t{\n\t\t\ti = i - j + 1;\n\t\t\tj = 0;\n\t\t}\n\t}\n\t//如果此时j的值大于等于子串的长度说明已经匹配成功\n\tif (j &gt;= lenT)\n\t{\n\t\t//返回匹配成功的位置\n\t\t//因为我们此时是从下标0开始的\n\t\t//所以我们往后加了一个1返回的是子串在主串中的位置\n\t\treturn i - lenT + 1;\n\t}\n\t//匹配不成功\n\telse\n\t{\n\t\treturn 0;\n\t}\n\t\n}\n\nint main()\n{\n\tchar S[100], T[100];\n\twhile (1)\n\t{\n\t\tcout &lt;&lt; \"请输入主串\" &lt;&lt; endl;\n\t\tcin &gt;&gt; S;\n\t\tcout &lt;&lt; \"请输入子串\" &lt;&lt; endl;\n\t\tcin &gt;&gt; T;\n\t\tint ret = BF(S, T);\n\t\tif (ret == 0)\n\t\t{\n\t\t\tcout &lt;&lt; \"很抱歉，匹配失败，未在主串中找到子串的相关信息\" &lt;&lt; endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout &lt;&lt; \"匹配成功\" &lt;&lt; endl &lt;&lt; \"匹配成功的位置为\" &lt;&lt; ret &lt;&lt; endl;\n\t\t}\n\t}\n\treturn 0;\n}</code></pre>\n<p><strong>运行结果展示：</strong><br/><img alt=\"\" height=\"640\" src=\"image\\ed678b0dbfea4188acc8903eb1949e92.png\" width=\"1200\"/></p>\n<h1 id=\"BF%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%C2%A0\">BF算法的时间复杂度 </h1>\n<blockquote>\n<p>在匹配成功的情况下，应考虑<strong>两种情况：</strong></p>\n<p></p>\n<p><strong>1.</strong>最好情况下，每趟不成功的匹配都发生在模拟串的第一个字符与主串中相应字符的比较。<br/> 设主串的长度为 n ，子串的长度为 m，假设从主串的第 i 个位置开始与模拟串匹配成功，则在前 i-1 趟匹配中字符总共比较了 i-1 次；若第 i 趟成功的字符比较次数为 m ， 则总比较次数为 i-1+m 。对于匹配成功的主串，其起始位置由 1 到 n-m+1 ，假定这 n-m+1 个起始位置上的匹配成功概率相等，则最好情况下匹配成功的平均比较次数为 (n+m)/2，则最好情况下的<strong>平均时间复杂度为 O(n+m)</strong></p>\n<p><br/><strong>2.</strong>最坏情况下，每趟不成功的匹配都发生在模拟串的最后一个字符与主串中相应字符的比较。假设从主串的第 i 个位置开始与模拟串匹配成功，则在前 i-1趟匹配中字符总共比较</p>\n<p>（i-1)*m 次；若第 i 趟成功的字符比较次数为 m ，则总比较次数 i*m 。 所以最坏情况下匹配成功的平均比较次数为 m*(n-m+2)/2，最坏情况下的<strong>平均时间复杂度为O(n*m)</strong></p>\n</blockquote>\n<h1 id=\"KMP%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89\">KMP算法的定义</h1>\n<blockquote>\n<p>        KMP算法是一种改进的字符串匹配算法，由D.E.Knuth，J.H.Morris和V.R.Pratt提出的，因此人们称它为克努特—莫里斯—普拉特操作（简称KMP算法）。KMP算法的核心是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。具体实现就是通过一个next()函数实现，函数本身包含了模式串的局部匹配信息。</p>\n</blockquote>\n<h1 id=\"KMP%E7%AE%97%E6%B3%95%E5%92%8CBF%E7%AE%97%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB\">KMP算法和BF算法的区别</h1>\n<blockquote>\n<p>        在上面我们说过的BF算法中我们知道了回溯是BF算法的灵魂，每次进行回溯操作的时候，主串和子串都要进行移动。而<strong>KMP算法中的主串是不用进行移动的</strong>，而子串的会也不用再移动到第一个元素的位置上了，子串的话会移动到<strong>特定的位置上</strong>，而这个特定的位置就是该位置上<strong>next数组中存储子串要移动位置的下标。</strong></p>\n</blockquote>\n<h1 id=\"Next%E6%95%B0%E7%BB%84\">Next数组</h1>\n<blockquote>\n<p>         Next数组是KMP算法最重要的一块，在求next之前我们应该知道next数组中存储的是什么。<strong>next数组中存储的是子串需要进行回退的下标</strong>，即当我们的主串和子串在某个位置匹配失败的时候，我们的子串就可以根据next数组对应的值进行<strong>回退到最合适的位置之后再次进行串的匹配操作。</strong></p>\n</blockquote>\n<h1 id=\"%C2%A0Next%E6%95%B0%E7%BB%84%E7%9A%84%E6%B1%82%E6%B3%95%EF%BC%88%E6%89%8B%E7%AE%97%EF%BC%89\"> Next数组的求法（手算）</h1>\n<blockquote>\n<p style=\"margin-left:0;text-align:justify;\">        在网上的一些资料中对next数组的求法主流的有两种，第一种next[0]=-1,next[1]=0。第二种next[0]=0,next[1]=1。虽然说next数组的前两个值不相同，但是思想和求法却是大同小异，只是在代码实现上有些许差异，所以我们这里以第一种为主。</p>\n<p style=\"margin-left:0;text-align:justify;\"><span style=\"color:#262626;\">        如果我们现在要求next数组的第三个元素，则从next数组第三个元素开始，求next数组的方法是从第一个元素到该元素前一个元素之间寻找最长前缀以及最长后缀，最长的那个串就是next数组中的值。</span>只有干巴巴的结论不具有说服性，下面我们来进行举例说明：</p>\n</blockquote>\n<p><strong>假设现在有个串为abcabc，我们来求它的next数组 </strong></p>\n<blockquote>\n<p><strong>        </strong>首先我们可以快速写出它的数组中<strong>第一个元素和第二个元素的值</strong>，分别是<strong>-1和0。</strong></p>\n<p>        第三个元素为c，我们此时来求它的next数组，在c前面的的元素为ab，此时在c前面<strong>以a开始b结束</strong>的串不存在，所以此时的next数组的值就为0。</p>\n<p>        再来看第四个元素a，在a前面的元素为abc，此时在a前面<strong>以a开头c结尾</strong>的串不存在，所以此时的next数组的值就为0。</p>\n<p>        接着是第五个元素b，在b前面的元素为abca，此时在b前面<strong>以a开头a结尾</strong>的串存在，就是开头的a，和结束的a，长度为1，所以此时的next数组的值就为1。</p>\n<p>        最后是第六个元素c，在b前面的元素为abcab，此时在c前面<strong>以a开头b结尾</strong>的串存在，分别为开头的ab，和结束时的ab，长度为2，所以此时的next数组的值就为2。</p>\n</blockquote>\n<p><img alt=\"\" height=\"467\" src=\"image\\9f5170879b614092bfcda26bbfb10ce2.png\" width=\"1200\"/></p>\n<p><strong>此时的next数组对应的值如图所示 </strong></p>\n<h1 id=\"%C2%A0Next%E6%95%B0%E7%BB%84%E7%9A%84%E6%B1%82%E6%B3%95%EF%BC%88%E4%BB%A3%E7%A0%81%EF%BC%89%C2%A0\"> Next数组的求法（代码） </h1>\n<p><img alt=\"\" height=\"183\" src=\"image\\45eca2908ee34a869fe83f68378027a9.png\" width=\"913\"/></p>\n<blockquote>\n<p>        我相信通过上方的练习大家现在应该已经会求next数组了，那么此时串abcababcabc 对应的next数组在这里就不进行解释了，大家可以自行求解然后和这个进行对照一下。</p>\n<p>        假设我们在下标为8对应的元素这里匹配失败了，我们这时就要进行回退操作，此时主串的i不动，子串回退到此时匹配失败元素下标对应的next数组即next[8]中储存的元素，我们由图可得此时next[8]=3的此时子串应该回退到下标为3的主串位置进行比较。此时的p[i]==p[k],而且我们也不难发现next[i+1]=k+1即next[9]=4，那么我们此时就可以书写一部分求next数组的代码了，代码如下：</p>\n</blockquote>\n<pre><code class=\"language-cpp\">if(sub[i-1]==sub[k])//这里之所以是i-1是因为我们前两个next数组的值是已经知道的\n//我们此时是从第三个元素开始的，所以这里的i就相当于i+1，i-1相等=当于i\n{\n    next[i]=k+1;\n    i++;\n    k++;\n}</code></pre>\n<p><img alt=\"\" height=\"171\" src=\"image\\46b27dff0e0f4cb48a0ab4a06a9e2ca8.png\" width=\"758\"/></p>\n<blockquote>\n<p>如果我们出现了 这种情况即p[i-1]!=p[k],一个是a一个是c，那么我们就需要连续回退，去找p[i-1]==p[k]的情况再执行以上操作就可以了，代码如下：</p>\n</blockquote>\n<pre><code class=\"language-cpp\">if(k==-1sub[i-1]==sub[k])//这里之所以是i-1是因为我们前两个next数组的值是已经知道的\n//我们此时是从第三个元素开始的，所以这里的i就相当于i+1，i-1相等=当于i\n//这里的k==-1是为了防止数组越界\n{\n    next[i]=k+1;\n    i++;\n    k++;\n}\nelse\n{\n    k=next[k];//进行连续回退直到找到sub[i-1]==sub[k]\n}</code></pre>\n<h1 id=\"KMP%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81%C2%A0\">KMP算法代码 </h1>\n<pre><code class=\"language-cpp\">//KMP算法\n#include&lt;iostream&gt;\n#include&lt;assert.h&gt;\n#include&lt;string.h&gt;\n#include&lt;stdlib.h&gt;\nusing namespace std;\n\nvoid GetNext(char*sub, int*next)\n{\n\tint lenSub = strlen(sub);\n\tnext[0] = -1;\n\tnext[1] = 0;\n\t//子串下一项的i值\n\tint i = 2;\n\t//前一项即next[1]对应的k值，即回退的下标\n\tint k = 0;\n\n\t//next数组还没遍历完\n\twhile (i &lt; lenSub)\n\t{\n\t\tif (k == -1 || sub[k] == sub[i - 1])\n\t\t{\n\t\t\tnext[i] = k + 1;\n\t\t\ti++;\n\t\t\tk++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tk = next[k];\n\t\t}\n\t}\n}\n\n//KMP算法函数\nint KMP(char*str, char*sub, int pos)\n{\n\t//断言判断主串和子串是否为空串\n\tassert(str != NULL &amp;&amp; sub != NULL);\n\t//主串长度\n\tint lenStr = strlen(str);\n\t//子串长度\n\tint lenSub = strlen(sub);\n\t\n\tif (lenStr == 0 || lenSub == 0)\n\t{\n\t\treturn -1;\n\t}\n\n\t//判断寻找的位置是否合理\n\tif (pos &lt; 0 || pos &gt;= lenStr)\n\t{\n\t\treturn -1;\n\t}\n\n\t//在堆区开辟一个next数组\n\tint *next = (int*)malloc(sizeof(int)*lenSub);\n\t//断言判断内存是否申请成功\n\tassert(next != NULL);\n\t//获取next数组\n\tGetNext(sub, next);\n\n\t//i用来遍历主串\n\tint i = pos;\n\t//j用来遍历子串\n\tint j = 0;\n\twhile (i &lt; lenStr&amp;&amp;j &lt; lenSub)\n\t{\n\t\tif (j == -1 || str[i] == sub[j])\n\t\t{\n\t\t\ti++;\n\t\t\tj++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//进行回退操作\n\t\t\tj = next[j];\n\t\t}\n\t}\n\t//此时已遍历完成\n\t//如果j已经遍历完子串，说明匹配成功，可以返回匹配成功的位置\n\tif (j &gt;= lenSub)\n\t{\n\t\treturn i - j + 1;\n\t}\n\telse\n\t{\n\t\treturn -1;\n\t}\n}\n\nint main()\n{\n\tchar S[100], t[100];\n\twhile (1)\n\t{\n\t\tcout &lt;&lt; \"请输入主串\" &lt;&lt; endl;\n\t\tcin &gt;&gt; S;\n\t\tcout &lt;&lt; \"请输入子串\" &lt;&lt; endl;\n\t\tcin &gt;&gt; t;\n\t\tint ret = KMP(S, t, 0);\n\t\tif (ret == -1)\n\t\t{\n\t\t\tcout &lt;&lt; \"很抱歉，匹配失败，在主串中未找到相关的子串\" &lt;&lt; endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout &lt;&lt; \"找到了，它的位置为：\" &lt;&lt; ret &lt;&lt; endl;\n\t\t}\n\t}\n\treturn 0;\n}</code></pre>\n<p><strong>运行结果展示 </strong></p>\n<p><img alt=\"\" height=\"642\" src=\"image\\f94d5509c12b48a4bc28bf2cb28793b5.png\" width=\"1200\"/></p>\n<h1 id=\"%C2%A0Next%E6%95%B0%E7%BB%84%E7%9A%84%E4%BC%98%E5%8C%96%E2%80%94%E2%80%94Nextval%E6%95%B0%E7%BB%84\"> Next数组的优化——Nextval数组</h1>\n<blockquote>\n<p>         只要我们next数组会求了，那么nextval数组就是手到擒来。nextval数组的第一个是和next数组的第一个是相同的即nextval[0]=-1。</p>\n<p>        从第二个开始，只要我们回退的位置是和当前位置的元素一样，就写回退位置的那个nextval值。</p>\n<p>        要是我们回退的位置是和当前位置的元素是不一样的，就写字符当前的这个next数组值。下面进行举例验证：</p>\n</blockquote>\n<p> <img alt=\"\" height=\"224\" src=\"image\\ca043c011d4d4a658e19495c9762672e.png\" width=\"693\"/></p>\n<blockquote>\n<p> 首先我们先求出next数组的值，然后 从第二个开始发现我们回退的位置和当前位置的元素一样，就写回退位置的那个nextval值即-1，然后一直往后推直到到了i=8我们发现它回退到7的位置是和当前位置的元素是不一样的，那么就写字符当前的这个next数组值，即就写7就行。</p>\n</blockquote>\n<p><img alt=\"\" height=\"94\" src=\"image\\ba5ca0a391f748b9bf8d413b26e4d102.png\" width=\"622\"/></p>\n<blockquote>\n<p>这里是一个求nextval数组的例子，大家可以自行练习，然后对照一下答案看看求得对不对，要是有什么不理解得地方可以随时私信或者在评论区留言给小张。 </p>\n</blockquote>\n<h1 id=\"%C2%A0%E7%BB%93%E6%9D%9F%E8%AF%AD\"> KMP算法时间复杂度</h1>\n<p><strong>KMP算法的时间复杂度为O(m+n)</strong></p>\n<h1 id=\"%E7%BB%93%E6%9D%9F%E8%AF%AD%C2%A0\">结束语 </h1>\n<blockquote>\n<p>        到这里关于BF算法和KMP算法的内容就已经全部结束了，若文章中有什么出错的地方的话，还请希望大家可以多多指正，小张在这里感谢大家的支持了！ </p>\n</blockquote>\n</div>\n</div>"}