{"blogid": "125081314", "writerAge": "码龄1年", "writerBlogNum": "72", "writerCollect": "2076", "writerComment": "3545", "writerFan": "2875", "writerGrade": "6级", "writerIntegral": "6764", "writerName": "快到锅里来呀", "writerProfileAdress": "writer_image\\profile_125081314.jpg", "writerRankTotal": "2565", "writerRankWeekly": "159", "writerThumb": "2567", "writerVisitNum": "59191", "blog_read_count": "2382", "blog_time": "于 2022-07-10 12:41:02 发布", "blog_title": "详解Java【泛型】", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"1%20%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B-toc\" style=\"margin-left:0px;\"><a href=\"#1%20%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B\">1 为什么使用泛型</a></p>\n<p id=\"2%20%E6%B3%9B%E5%9E%8B%E7%9A%84%E8%AF%AD%E6%B3%95-toc\" style=\"margin-left:0px;\"><a href=\"#2%20%E6%B3%9B%E5%9E%8B%E7%9A%84%E8%AF%AD%E6%B3%95\">2 泛型的语法</a></p>\n<p id=\"3.%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%BC%96%E8%AF%91%E6%AD%A5%E9%AA%A4-toc\" style=\"margin-left:0px;\"><a href=\"#3.%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%BC%96%E8%AF%91%E6%AD%A5%E9%AA%A4\">3.泛型的编译步骤</a></p>\n<p id=\"3.1%20%E6%93%A6%E9%99%A4%E6%9C%BA%E5%88%B6-toc\" style=\"margin-left:40px;\"><a href=\"#3.1%20%E6%93%A6%E9%99%A4%E6%9C%BA%E5%88%B6\">3.1 擦除机制</a></p>\n<p id=\"3.2%20%E4%B8%8D%E5%8F%AF%E4%BB%A5%E5%AE%9E%E4%BE%8B%E5%8C%96%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B%E6%95%B0%E7%BB%84-toc\" style=\"margin-left:40px;\"><a href=\"#3.2%20%E4%B8%8D%E5%8F%AF%E4%BB%A5%E5%AE%9E%E4%BE%8B%E5%8C%96%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B%E6%95%B0%E7%BB%84\">3.2 不可以实例化泛型类型数组</a></p>\n<p id=\"4.%E4%BA%86%E8%A7%A3%E8%A3%B8%E7%B1%BB%E5%9E%8B-toc\" style=\"margin-left:0px;\"><a href=\"#4.%E4%BA%86%E8%A7%A3%E8%A3%B8%E7%B1%BB%E5%9E%8B\">4.了解裸类型</a></p>\n<p id=\"5.%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%B8%8A%E7%95%8C-toc\" style=\"margin-left:0px;\"><a href=\"#5.%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%B8%8A%E7%95%8C\">5.泛型的上界</a></p>\n<p id=\"6.%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95-toc\" style=\"margin-left:0px;\"><a href=\"#6.%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95\">6.泛型方法</a></p>\n<p id=\"7.%E9%80%9A%E9%85%8D%E7%AC%A6%EF%BC%88%3F%EF%BC%89-toc\" style=\"margin-left:0px;\"><a href=\"#7.%E9%80%9A%E9%85%8D%E7%AC%A6%EF%BC%88%3F%EF%BC%89\">7.通配符（?）</a></p>\n<p id=\"7.1%20%E7%90%86%E8%A7%A3%E9%80%9A%E9%85%8D%E7%AC%A6-toc\" style=\"margin-left:40px;\"><a href=\"#7.1%20%E7%90%86%E8%A7%A3%E9%80%9A%E9%85%8D%E7%AC%A6\">7.1 理解通配符</a></p>\n<p id=\"7.2%20%E9%80%9A%E9%85%8D%E7%AC%A6%E4%B8%8A%E7%95%8C-toc\" style=\"margin-left:40px;\"><a href=\"#7.2%20%E9%80%9A%E9%85%8D%E7%AC%A6%E4%B8%8A%E7%95%8C\">7.2 通配符上界</a></p>\n<p id=\"7.3%20%E9%80%9A%E9%85%8D%E7%AC%A6%E4%B8%8B%E7%95%8C-toc\" style=\"margin-left:40px;\"><a href=\"#7.3%20%E9%80%9A%E9%85%8D%E7%AC%A6%E4%B8%8B%E7%95%8C\">7.3 通配符下界</a></p>\n<p id=\"%C2%A08.%E5%8C%85%E8%A3%85%E7%B1%BB-toc\" style=\"margin-left:0px;\"><a href=\"#%C2%A08.%E5%8C%85%E8%A3%85%E7%B1%BB\"> 8.包装类</a></p>\n<p id=\"8.1%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%AF%B9%E5%BA%94%E5%8C%85%E8%A3%85%E7%B1%BB-toc\" style=\"margin-left:40px;\"><a href=\"#8.1%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%AF%B9%E5%BA%94%E5%8C%85%E8%A3%85%E7%B1%BB\">8.1基本数据类型对应包装类</a></p>\n<p id=\"-toc\" style=\"margin-left:40px;\"><a href=\"#8.2%20%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1\">8.2 装箱和拆箱</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h1 id=\"1%20%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B\"><span style=\"color:#ff9900;\">1 为什么使用泛型</span></h1>\n<blockquote>\n<p><span style=\"color:#956fe7;\"><strong>普通的类和方法，只能使用具体的类型，比如基本类型或者自定义的类，如果要应用多种类型的代码，就非常的不方便。</strong></span></p>\n<p><span style=\"color:#4da8ee;\"><strong>而从JDK1.5后，引入了泛型这个概念，泛型和函数的区别就是</strong></span></p>\n<p><span style=\"color:#fe2c24;\"><strong>函数传参传的是值，而泛型传的是类型，这样泛型就适用于许多许多类型，也就是将类型当做了参数</strong></span></p>\n</blockquote>\n<hr/>\n<p></p>\n<h1 id=\"2%20%E6%B3%9B%E5%9E%8B%E7%9A%84%E8%AF%AD%E6%B3%95\"><span style=\"color:#fe2c24;\">2 泛型的语法</span></h1>\n<p><span style=\"color:#0d0016;\"><strong>⚜️在写泛型语法之前，我们先思考一下，</strong></span></p>\n<blockquote>\n<p><span style=\"color:#956fe7;\"><strong>如何实现一个类，这个类中包含一个数组成员，使得这个数组可以存放任何类型的数据，并且这个也可以根据成员方法返回数组中某个元素下标值。</strong></span></p>\n</blockquote>\n<p><span style=\"color:#0d0016;\"><strong>简单分析一下吧</strong></span></p>\n<p><span style=\"color:#be191c;\"><strong>正常的数组是只能存放指定类型元素的值，但我们学过了，所有类的父类，默认都是Object类型的，那么数组可以为Object吗，下面我们来浅浅的试一下</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>创建一个类</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong><img alt=\"\" height=\"341\" src=\"image\\40fa21e7513b4d89a1d6f8156eec5cbd.png\" width=\"534\"/></strong></span></p>\n<p><span style=\"color:#ff9900;\"><strong> 注意看，我们将数组类型设置成Object后没有报错，说明是可行的</strong></span></p>\n<p></p>\n<p><strong><span style=\"color:#956fe7;\">然后我们开始存放数据，并且获取下标元素的值</span></strong></p>\n<p><span style=\"color:#ff9900;\"><strong><img alt=\"\" height=\"366\" src=\"image\\e3704b14e747451cac8b2890416de17c.png\" width=\"812\"/></strong></span></p>\n<p><span style=\"color:#ff9900;\"><strong> 这里我们可以，强制类型转化一下</strong></span></p>\n<p><img alt=\"\" height=\"231\" src=\"image\\3d12b788fbb94b3ab6bd24f5d85e89f9.png\" width=\"556\"/></p>\n<p><span style=\"color:#ad720d;\"><strong> 虽然说，这样数组任何类型也可以存放，但是感觉不太方便，而且条理比较混乱，</strong></span></p>\n<p><span style=\"color:#1c7331;\"><strong>所以还是想让他只有一种数据类型，此时，我们就一个是考虑泛型了，</strong></span></p>\n<blockquote>\n<p><span style=\"color:#fe2c24;\"><strong>泛型存在的意义，就是指定当前的容器，然后想要什么类型的对象，让编译器去检查，把想要的类型，当做参数去传递。</strong></span></p>\n</blockquote>\n<p><span style=\"color:#0d0016;\"><strong>下面直接上语法吧</strong></span></p>\n<pre><code class=\"language-java\">class 泛型类名称&lt;类型形参列表&gt; {\n    //这里可以使用类型参数\n}\n\nclass ClassName&lt;T1,T2...,Tn&gt;{\n    \n}\n\nclass 泛型类名称&lt;类型形参列表&gt; extends 继承类/*这里可以是类型参数*/ {\n    //这里可以使用类型参数\n}\n\nclass ClassName&lt;T1,T2...,Tn&gt; extends ParentClass&lt;T1&gt; {\n    //这里可以使用部分类型参数\n}</code></pre>\n<p><span style=\"color:#0d0016;\"><strong>然后，现在把刚刚那个问题代码修改一下，引入泛型试试看效果</strong></span></p>\n<p><span style=\"color:#ff9900;\"><strong>先写一个泛型类</strong></span></p>\n<pre><code class=\"language-java\">//&lt;T&gt;代表当前类是泛型类\nclass MyArray2&lt;T&gt; {\n    \n    public T[] array = (T[])new Object[10];\n    public T getPos(int pos) {\n        return array[pos];\n    }\n    public void setVal(int pos,T val) {\n        this.array[pos] = val;\n    }\n}</code></pre>\n<p><span style=\"color:#ff9900;\"><strong>下面我们在&lt;&gt;中指定类型，此时就只能存放这个数据类型的数据了 </strong></span></p>\n<pre><code class=\"language-java\">    public static void main(String[] args) {\n        //&lt;&gt;中指定类型,此时这个类里面，只能放这个数据类型的数据\n        MyArray2&lt;String&gt; myArray = new MyArray2&lt;String&gt;();\n        myArray.setVal(0,\"nb\");\n        myArray.setVal(1,\"xawl\");\n\n        String s =  myArray.getPos(1);\n        String s1 = myArray.getPos(0);\n        System.out.println(s);\n        System.out.println(s1);\n    }</code></pre>\n<p><img alt=\"\" height=\"102\" src=\"image\\a41a0bd833494066b2fc6ba8f4272aa4.png\" width=\"171\"/></p>\n<p><span style=\"color:#ff9900;\"><strong> 我们比如在定义一个Integer类型的</strong></span></p>\n<pre><code class=\"language-java\">        MyArray2&lt;Integer&gt; myArray2 = new MyArray2&lt;Integer&gt;();\n        myArray2.setVal(0,12);\n        myArray2.setVal(1,13);\n        Integer I = myArray2.getPos(0);\n        System.out.println(I);</code></pre>\n<p><img alt=\"\" height=\"62\" src=\"image\\1f5e8a1ecf4c4950b12c7cfeb6d9fd28.png\" width=\"153\"/></p>\n<p><span style=\"color:#0d0016;\"><strong>例子就写到这里</strong></span></p>\n<p>下面说一下泛型类语法</p>\n<pre><code class=\"language-java\">泛型类&lt;类型实参&gt; 变量名;//定义一个泛型类引用\nnew 泛型类&lt;类型实参&gt; (构造方法实参);//实例化一个泛型类对象\n</code></pre>\n<p><span style=\"color:#956fe7;\"><strong>注意事项：</strong></span></p>\n<blockquote>\n<p><span style=\"color:#fe2c24;\"><strong>（1）类名后的&lt;T&gt;叫占位符,意思就是当前的类是泛型类</strong></span></p>\n</blockquote>\n<p><img alt=\"\" height=\"200\" src=\"image\\5a3995de43e341209fac8d24384083dd.png\" width=\"363\"/></p>\n<blockquote>\n<p><span style=\"color:#ff9900;\"><strong>（2）不需要进行强制类型转化</strong></span></p>\n</blockquote>\n<p><span style=\"color:#ffd900;\"><strong>（3）Java中，不可以new泛型类型的数组</strong></span></p>\n<p><img alt=\"\" height=\"44\" src=\"image\\a8abea25f32a4b68895d1e4a8b582a24.png\" width=\"341\"/></p>\n<blockquote>\n<p><span style=\"color:#956fe7;\"><strong> （4）注意&lt;&gt;中必须要引用类型</strong></span></p>\n</blockquote>\n<p><span style=\"color:#0d0016;\"><strong>否则，就会报错  </strong></span></p>\n<p><img alt=\"\" height=\"65\" src=\"image\\9a24b475405c4ba5bb8d4cc2f21d965a.png\" width=\"595\"/></p>\n<blockquote>\n<p><span style=\"color:#1c7331;\"><strong>（5）泛型类使用中可以省略类型实参的填写</strong></span></p>\n</blockquote>\n<pre><code class=\"language-java\">MyArray&lt;Integer&gt; list = new MyArray&lt;&gt;();</code></pre>\n<p><span style=\"color:#fe2c24;\"><strong>这是因为，编译器可以推导出实例化需要的类型实参为Integer</strong></span></p>\n<hr/>\n<h1 id=\"3.%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%BC%96%E8%AF%91%E6%AD%A5%E9%AA%A4\"><span style=\"color:#1c7331;\"><strong>3.泛型的编译步骤</strong></span></h1>\n<h2 id=\"3.1%20%E6%93%A6%E9%99%A4%E6%9C%BA%E5%88%B6\"><span style=\"color:#4da8ee;\">3.1 擦除机制</span></h2>\n<p><img alt=\"\" height=\"563\" src=\"image\\9622fa46a4b344b2a9b6c102179016f0.png\" width=\"980\"/></p>\n<blockquote>\n<p><span style=\"color:#fe2c24;\"><strong>擦除机制就是，在编译的过程中，将泛型T替换为Object</strong></span></p>\n<p></p>\n<p><span style=\"color:#a2e043;\"><strong>并且擦除机制就是编译时期的一种机制，运行期间没有泛型这个概念</strong></span></p>\n</blockquote>\n<hr/>\n<p></p>\n<h2 id=\"3.2%20%E4%B8%8D%E5%8F%AF%E4%BB%A5%E5%AE%9E%E4%BE%8B%E5%8C%96%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B%E6%95%B0%E7%BB%84\"><span style=\"color:#1c7331;\">3.2 不可以实例化泛型类型数组</span></h2>\n<p><span style=\"color:#1c7331;\">思考这样一个例子</span></p>\n<p><span style=\"color:#ff9900;\"><strong>既然所有的T都替换为Object，那为什么这样就不可以写</strong></span></p>\n<p><img alt=\"\" height=\"90\" src=\"image\\20688afb4cfc4b0b99168e0f9efb1545.png\" width=\"596\"/></p>\n<p> 下面看一下这个例子你就明白了</p>\n<p><img alt=\"\" height=\"196\" src=\"image\\45a710f894af4ffcbd45eb7a57cd289e.png\" width=\"444\"/></p>\n<p><img alt=\"\" height=\"452\" src=\"image\\1cea738ae6ff4e31881db2c2fd76a4c7.png\" width=\"813\"/></p>\n<p><span style=\"color:#fe2c24;\"><strong> ⚜️ 那为什么不能被转化呢？</strong></span></p>\n<blockquote>\n<p><span style=\"color:#956fe7;\"><strong>很简单Object数组中存在很多的类型，然后此时你用Integer来转化很多种类型，那肯定是不行的，编译器从安全考虑不会让你通过的，</strong></span></p>\n</blockquote>\n<p><span style=\"color:#be191c;\"><strong> 所以我们正确的应该是这样做</strong></span></p>\n<pre><code class=\"language-java\">package Demo01;\n\nimport java.lang.reflect.Array;\nimport java.util.Arrays;\nclass MyArray&lt;T&gt; {\n    public T[] array;\n    \n    public MyArray(Class&lt;T&gt; clazz, int capacity) {\n        array = (T[]) Array.newInstance(clazz,capacity);\n    }\n    public T[] getArray() {\n        return array;\n    }\n    public void setVal(int pos,T val) {\n        this.array[pos] = val;\n    }\n    public T getPos(int pos) {\n        return this.array[pos];\n    }\n}\npublic class Test01 {\n    public static void main(String[] args) {//指定数组类型是Integer\n        MyArray&lt;Integer&gt; myArray = new MyArray&lt;&gt;(Integer.class,10);\n        myArray.setVal(0,10);\n        Integer[] tmp = myArray.getArray();\n        System.out.println(Arrays.toString(tmp));\n    }\n}\n</code></pre>\n<hr/>\n<h1 id=\"4.%E4%BA%86%E8%A7%A3%E8%A3%B8%E7%B1%BB%E5%9E%8B\"><span style=\"color:#ff9900;\">4.了解裸类型</span></h1>\n<blockquote>\n<p><span style=\"color:#0d0016;\"><strong>下面看一下这个</strong></span></p>\n<p><span style=\"color:#fe2c24;\"><strong>我们写了一个泛型类，但是并没有带参数类型，而且也没报错，那么我们把这个叫做裸类型</strong></span></p>\n</blockquote>\n<p><img alt=\"\" height=\"230\" src=\"image\\1d1b662ebf764ddc8cf15a05790d0581.png\" width=\"528\"/></p>\n<p><span style=\"color:#a2e043;\"><strong> 这里说明裸类型，是为了兼容老版本的API保留机制，我们不要自己去使用裸类型</strong></span></p>\n<hr/>\n<h1 id=\"5.%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%B8%8A%E7%95%8C\"><span style=\"color:#1a439c;\">5.泛型的上界</span></h1>\n<p><span style=\"color:#0d0016;\"><strong>语法格式</strong></span></p>\n<blockquote>\n<p><span style=\"color:#fe2c24;\"><strong>class 泛型类名称&lt;类型形参 extends 类型边界&gt; {<!-- --></strong></span></p>\n<p><span style=\"color:#fe2c24;\"><strong>......</strong></span></p>\n<p><span style=\"color:#fe2c24;\"><strong>}</strong></span></p>\n</blockquote>\n<p><img alt=\"\" height=\"234\" src=\"image\\19f16a89b7bb43c4be89c538c8b6eda9.png\" width=\"807\"/></p>\n<p><span style=\"color:#ff9900;\"><strong> 下面思考一下，如果要写一个泛型类，找数组中的最大值，应该怎么做</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>首先，肯定是直接比较不了的，因为T是引用数据类型，引用类型比较要用比较器</strong></span></p>\n<p>所以，<img alt=\"\" height=\"88\" src=\"image\\053884ead7b54d2698f7341158274f78.png\" width=\"522\"/></p>\n<p> <img alt=\"\" height=\"69\" src=\"image\\424ff79030594eb6a3cb52c62ac15c16.png\" width=\"504\"/></p>\n<p><span style=\"color:#956fe7;\"><strong> 这里也可以看到Comparable也是个泛型接口</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>所以泛型类可以这样写</strong></span></p>\n<pre><code class=\"language-java\">class Alg&lt;T extends Comparable&lt;T&gt;&gt; {\n\n    public T findMaxVal(T[] array) {\n        T maxVal = array[0];\n        for (int i = 1; i &lt; array.length; i++) {\n            if (array[i].compareTo(maxVal) &gt; 0) {\n                maxVal = array[i];\n            }\n        }\n        return maxVal;\n    }\n}</code></pre>\n<hr/>\n<h1 id=\"6.%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95\"><span style=\"color:#ad720d;\">6.泛型方法</span></h1>\n<p><span style=\"color:#0d0016;\"><strong>语法格式</strong></span></p>\n<blockquote>\n<div>\n<span style=\"color:#fe2c24;\"><strong>方法限定符 &lt;类型形参列表&gt; 返回值类型 方法名称(形参列表) { ... }</strong></span>\n</div>\n</blockquote>\n<p><span style=\"color:#0d0016;\"><strong>直接上例子</strong></span></p>\n<p><span style=\"color:#ff9900;\"><strong>在前面我们找数组中的最大值，是在泛型类中写了一个方法，来实现的</strong></span></p>\n<p><img alt=\"\" height=\"89\" src=\"image\\d3482e7d690b44deb8a6908ecf600add.png\" width=\"635\"/></p>\n<p><span style=\"color:#956fe7;\"><strong> 要调用这个方法，就必须要有个对象，如果不想有这个对象，那就可以把这个方法变成静态的就可以了，所以还有一种方法是</strong></span></p>\n<p><span style=\"color:#4da8ee;\"><strong>⚜️ 可以把这个方法写成静态的，然后放在普通类中</strong></span></p>\n<pre><code class=\"language-java\">class Alg2 {\n    //静态方法\n    public static&lt;T extends Comparable&lt;T&gt;&gt; T findMaxVal(T[] array) {\n            T maxVal = array[0];\n            for (int i = 1; i &lt; array.length; i++) {\n                if (array[i].compareTo(maxVal) &gt; 0) {\n                    maxVal = array[i];\n                }\n            }\n            return maxVal;\n    }\n}</code></pre>\n<p><img alt=\"\" height=\"159\" src=\"image\\78ad314556054b17b19cbef61d885683.png\" width=\"681\"/></p>\n<p><span style=\"color:#956fe7;\"><strong> ⚜️ 还有个方法是，继续写一个泛型方法，只不过这个方法也是成员方法</strong></span></p>\n<pre><code class=\"language-java\">class Alg3 {\n    //泛型方法：成员方法\n    public &lt;T extends Comparable&lt;T&gt;&gt; T findMaxVal2(T[] array) {\n        T maxVal = array[0];\n        for (int i = 1; i &lt; array.length; i++) {\n            if (array[i].compareTo(maxVal) &gt; 0) {\n                maxVal = array[i];\n            }\n        }\n        return maxVal;\n    }\n}</code></pre>\n<p><span style=\"color:#ff9900;\"><strong>因为这个不是静态方法，所以还是要引用对象， </strong></span></p>\n<pre><code class=\"language-java\">    public static void main(String[] args) {\n        Alg3 alg3 = new Alg3();\n        Integer[] array = {100,200,24,34,55};\n        int val = alg3.findMaxVal2(array);\n        System.out.println(val);\n    }</code></pre>\n<hr/>\n<h1 id=\"7.%E9%80%9A%E9%85%8D%E7%AC%A6%EF%BC%88%3F%EF%BC%89\"><span style=\"color:#956fe7;\">7.通配符（?）</span></h1>\n<h2 id=\"7.1%20%E7%90%86%E8%A7%A3%E9%80%9A%E9%85%8D%E7%AC%A6\"><span style=\"color:#ff9900;\">7.1 理解通配符</span></h2>\n<blockquote>\n<p><span style=\"color:#fe2c24;\"><strong>通配符是用来解决泛型无法</strong></span><span style=\"color:#0d0016;\"><strong>协变</strong></span><span style=\"color:#fe2c24;\"><strong>的问题的</strong></span></p>\n<p></p>\n<p><span style=\"color:#0d0016;\"><strong>协变</strong></span><span style=\"color:#4da8ee;\"><strong>指的是如果child是parent的子类，那么List&lt;Child&gt;也应该是List&lt;Parent&gt;的子类。但是泛型是不支持这样的父子类关系的</strong>。</span></p>\n</blockquote>\n<p><span style=\"color:#0d0016;\"><strong>这是因为</strong></span></p>\n<pre><code class=\"language-java\">class MyArray&lt;T&gt; {\n    public T[] array = (T[]) new Object[10];\n\n    public T getPos(int pos) {\n        return this.array[pos];\n    }\n    public void setval(int pos,T val) {\n        this.array[pos] = val;\n    }\n    public T[] getArray() {\n        return array;\n    }\n}\npublic class Test01 {\n    public static void main(String[] args) {\n        MyArray&lt;Integer&gt; myArray = new MyArray&lt;&gt;();\n        System.out.println(myArray);\n        MyArray&lt;String&gt; myArray2 = new MyArray&lt;&gt;();\n        System.out.println(myArray2);\n    }\n}</code></pre>\n<p><img alt=\"\" height=\"71\" src=\"image\\ea4ac7267db94d9f8c820a745e74114d.png\" width=\"246\"/></p>\n<blockquote>\n<p><span style=\"color:#1c7331;\"><strong>🤠 可以看到&lt;&gt;尖括号中的内容，不参与类型的组成。</strong></span></p>\n<p><span style=\"color:#1c7331;\"><strong>所以在泛型中List&lt;Child&gt;不是List&lt;Parent&gt;的子类</strong></span></p>\n</blockquote>\n<p>下面看一个例子</p>\n<pre><code class=\"language-java\">class Message&lt;T&gt; {\n    private T message ;\n    public T getMessage() {\n        return message;\n    }\n    public void setMessage(T message) {\n        this.message = message;\n    }\n}\npublic class Test02 {\n    public static void main(String[] args) {\n        Message&lt;String&gt; message = new Message() ;\n        message.setMessage(\"xawl\");\n        fun(message);\n    }\n    public static void fun(Message&lt;String&gt; temp){\n        System.out.println(temp.getMessage());\n    }\n}\n</code></pre>\n<p><span style=\"color:#ad720d;\"><strong>⚜️ 如果说此时泛型的类型不是String而是Integer</strong></span></p>\n<p><img alt=\"\" height=\"457\" src=\"image\\9c9607d77efb41fab17036a0caddf64e.png\" width=\"573\"/></p>\n<p><span style=\"color:#fe2c24;\"><strong> 🤠 所以这里就希望的是可以接收所有的泛型类型，但是又不能够让用户随意修改。这样就需要使用通配符‘’？‘’来解决</strong></span></p>\n<pre><code class=\"language-java\">    public static void fun(Message&lt;?&gt; temp){\n        System.out.println(temp.getMessage());\n    }</code></pre>\n<blockquote>\n<p><span style=\"color:#38d8f0;\"><strong>所以通配符“？”表示，可以接收任意类型</strong></span></p>\n</blockquote>\n<hr/>\n<p><span style=\"color:#956fe7;\">在泛型中只有上界，没有下界</span></p>\n<p><span style=\"color:#956fe7;\">而在通配符？的基础上又产生了两个子通配符：</span></p>\n<p><span style=\"color:#956fe7;\">？extends类：设置通配符上界</span></p>\n<p><span style=\"color:#956fe7;\">？super类：设置通配符下界 </span></p>\n<hr/>\n<p></p>\n<h2 id=\"7.2%20%E9%80%9A%E9%85%8D%E7%AC%A6%E4%B8%8A%E7%95%8C\"><span style=\"color:#4da8ee;\">7.2 通配符上界</span></h2>\n<p><span style=\"color:#fe2c24;\"><strong>语法：</strong></span></p>\n<pre><code class=\"language-java\">Vector&lt;? extends 类型1&gt; x = new Vector&lt;类型2&gt;();</code></pre>\n<p><span style=\"color:#956fe7;\"><strong>类型1指定一个数据类型，那么类型2就只能是类型1或者是类型1的子类：</strong> </span></p>\n<pre><code class=\"language-java\">Vector&lt;? extends Number&gt; x = new Vector&lt;Integer&gt;();</code></pre>\n<p> 下面看一个例子</p>\n<pre><code class=\"language-java\">class Food {}\nclass Fruit extends Food {}\nclass Apple extends Fruit {}\nclass Banana extends Fruit {}\nclass Test&lt;T&gt; { // 设置泛型上限\n    private T val ;\n    public T getVal() {\n        return val;\n    }\n\n    public void setVal(T Val) {\n        this.val = val;\n    }\n}\npublic class Test03 {\n    public static void main(String[] args) {\n        Test&lt;Apple&gt; test = new Test&lt;&gt;() ;\n        test.setVal(new Apple());\n        fun(test);\n        Test&lt;Banana&gt; test2 = new Test&lt;&gt;() ;\n        test2.setVal(new Banana());\n        fun(test2);\n    }\n    //只要是Fruit或者Fruit的子类即可\n    public static void fun(Test&lt;? extends Fruit&gt; temp){\n         System.out.println(temp.getVal());\n    }\n}</code></pre>\n<p><span style=\"color:#ff9900;\"><strong>⚜️  如果此时在fun函数中对temp添加元素，就会报错</strong></span></p>\n<p><img alt=\"\" height=\"315\" src=\"image\\9cb624af8c3a4cb1bb3db53271e9ea42.png\" width=\"784\"/><span style=\"color:#511b78;\"><strong> 这是因为temp接收的是Fruit和他的子类，此时存储的元素应该是哪个子类无法确定，所以添加元素就会报错，所以只能获取元素</strong></span></p>\n<blockquote>\n<p><span style=\"color:#0d0016;\"><strong>总结：</strong></span><span style=\"color:#fe2c24;\"><strong>通配符的上界，不能进行写入数据，只能进行读取数据。 </strong></span></p>\n</blockquote>\n<div>\n<hr/>\n<p></p>\n</div>\n<h2 id=\"7.3%20%E9%80%9A%E9%85%8D%E7%AC%A6%E4%B8%8B%E7%95%8C\"><span style=\"color:#a2e043;\">7.3 通配符下界</span></h2>\n<p><span style=\"color:#0d0016;\"><strong>语法：</strong></span></p>\n<pre><code class=\"language-java\">Vector&lt;? super 类型1&gt; x = new Vector&lt;类型2&gt;();</code></pre>\n<p><span style=\"color:#956fe7;\"><strong>类型1指定一个数据类型，那么类型2就只能是类型1或者是类型1的父类： </strong></span></p>\n<pre><code class=\"language-java\">Vector&lt;? super Integer&gt; x = new Vector&lt;Number&gt;();</code></pre>\n<p>下面看一个例子：</p>\n<pre><code class=\"language-java\">class Food {}\nclass Fruit extends Food {}\nclass Apple extends Fruit {}\nclass Banana extends Fruit {}\nclass Test&lt;T&gt; { // 设置泛型上限\n    private T val ;\n    public T getVal() {\n        return val;\n    }\n    public void setVal(T Val) {\n        this.val = val;\n    }\n}\npublic class Test03 {\n    public static void main(String[] args) {\n        Test&lt;Fruit&gt; test = new Test&lt;&gt;() ;\n        test.setVal(new Fruit());\n        fun2(test);\n        Test&lt;Food&gt; test2 = new Test&lt;&gt;() ;\n        test2.setVal(new Food());\n        fun2(test2);\n    }\n    public static void fun2(Test&lt;? super Fruit&gt; temp){\n        System.out.println(temp.getVal());\n    }</code></pre>\n<p><span style=\"color:#ff9900;\"><strong>⚜️  如果此时在fun2函数中对temp添加元素，还会报错吗</strong></span></p>\n<pre><code class=\"language-java\">    public static void fun2(Test&lt;? super Fruit&gt; temp){\n      // 此时可以修改！！添加的是Fruit 或者Fruit的子类\n        temp.setVal(new Apple());//这个是Fruit的子类\n        temp.setVal(new Fruit());//这个是Fruit的本身\n        // Fruit fruit = temp.getMessage(); 不能接收，这里无法确定是哪个父类\n        System.out.println(temp.getVal());//只能直接输出\n    }</code></pre>\n<blockquote>\n<p><span style=\"color:#0d0016;\"><strong>总结：</strong></span><span style=\"color:#fe2c24;\"><strong>通配符的下界，不能进行读取数据，只能进行写入数据。 </strong></span> </p>\n</blockquote>\n<hr/>\n<h1 id=\"%C2%A08.%E5%8C%85%E8%A3%85%E7%B1%BB\"><span style=\"color:#ffd900;\"> 8.包装类</span></h1>\n<h2 id=\"8.1%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%AF%B9%E5%BA%94%E5%8C%85%E8%A3%85%E7%B1%BB\"><span style=\"color:#956fe7;\">8.1基本数据类型对应包装类</span></h2>\n<p><span style=\"color:#fe2c24;\"><strong>在java中，因为基本类型不是继承Object，为了在泛型代码中可以支持基本类型，java给每个基本类型都搞了一个包装类型。</strong></span></p>\n<table align=\"left\" border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px;\"><thead><tr><th>基本数据类型</th><th> <p>包装类</p> </th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td><span style=\"color:#0d0016;\"><strong>int</strong></span></td><td><span style=\"color:#0d0016;\"><strong>Integer</strong></span></td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td><span style=\"color:#0d0016;\"><strong>char</strong></span></td><td><span style=\"color:#0d0016;\"><strong>Character</strong></span></td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<h2></h2>\n<hr/>\n<p></p>\n<h2 id=\"8.2%20%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1\"><span style=\"color:#ff9900;\"><strong>8.2 装箱和拆箱</strong></span></h2>\n<p>装箱：</p>\n<pre><code class=\"language-java\">    public static void main(String[] args) {\n        int a = 20;\n        Integer integer = a;//自动装箱\n\n        Integer integer2 = new Integer(a);//显示装箱\n\n        Integer integer3 = Integer.valueOf(a);//显示装箱\n\n        System.out.println(integer);\n        System.out.println(integer2);\n        System.out.println(integer3);\n    }</code></pre>\n<p><span style=\"color:#ff9900;\"><strong>⚜️ 下面看一下，自动装箱的字节码文件</strong></span></p>\n<p><img alt=\"\" height=\"408\" src=\"image\\07741df4e7db4a3496605ceb44892052.png\" width=\"1200\"/></p>\n<p>拆箱：</p>\n<pre><code class=\"language-java\">    public static void main(String[] args) {\n        int a = 30;\n        Integer integer  = a;\n\n        int val = integer;//自动拆箱\n        System.out.println(val);\n\n        int val2 = integer.intValue();//显示拆箱\n        System.out.println(val2);\n\n        double val3 = integer.doubleValue();//显示拆箱\n        System.out.println(val3);\n    }</code></pre>\n<p><span style=\"color:#ff9900;\"><strong>⚜️ 下面看一下，自动拆箱的字节码文件</strong></span></p>\n<p><img alt=\"\" height=\"511\" src=\"image\\0ed554df4d584644814a28d8fc151766.png\" width=\"1055\"/></p>\n<hr/>\n<p></p>\n</div>\n</div>"}