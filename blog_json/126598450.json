{"blogid": "126598450", "writerAge": "码龄2年", "writerBlogNum": "189", "writerCollect": "1238", "writerComment": "887", "writerFan": "986", "writerGrade": "5级", "writerIntegral": "3946", "writerName": "Cpt丶", "writerProfileAdress": "writer_image\\profile_126598450.jpg", "writerRankTotal": "4507", "writerRankWeekly": "3835", "writerThumb": "1005", "writerVisitNum": "104337", "blog_read_count": "125", "blog_time": "已于 2022-09-05 16:34:40 修改", "blog_title": "【C++实战 】标准库", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-tomorrow-night\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p></p>\n<div class=\"toc\">\n<h3>文章目录</h3>\n<ul><li><a href=\"#_1\">文本处理</a></li><li><ul><li><a href=\"#_2\">认识字符串</a></li><li><a href=\"#sring_18\">sring使用</a></li><li><ul><li><a href=\"#1__24\">1. 字面量后缀</a></li><li><a href=\"#2__28\">2. 原始字符串</a></li><li><a href=\"#3__38\">3. 字符串转换函数</a></li><li><a href=\"#4__44\">4. 字符串视图类</a></li><li><a href=\"#_51\">正则表达式</a></li></ul>\n</li></ul>\n</li><li><a href=\"#_69\">容器</a></li><li><ul><li><a href=\"#_75\">容器的通用特效</a></li><li><a href=\"#_81\">有序容器</a></li><li><a href=\"#_90\">无序容器</a></li></ul>\n</li><li><a href=\"#_105\">算法</a></li><li><ul><li><a href=\"#_107\">认识算法</a></li><li><a href=\"#_117\">迭代器</a></li><li><a href=\"#for_each__for_125\">for_each 代替 for</a></li><li><a href=\"#_128\">排序算法</a></li><li><a href=\"#_139\">查找算法</a></li><li><ul><li><a href=\"#_141\">需要排序后使用查找算法</a></li></ul>\n</li><li><a href=\"#_147\">无需排序的查找算法</a></li></ul>\n</li><li><a href=\"#Concurrencymultithreading_155\">“并发”（Concurrency）、“多线程”（multithreading）</a></li><li><ul><li><a href=\"#_157\">认识线程和多线程</a></li><li><ul><li><a href=\"#_163\">“读而不写”就不会有数据竞争。</a></li></ul>\n</li><li><a href=\"#_166\">多线程开发实践</a></li><li><ul><li><a href=\"#_167\">仅调用一次</a></li><li><a href=\"#_186\">线程局部存储</a></li><li><a href=\"#_193\">原子变量</a></li><li><a href=\"#_206\">线程</a></li></ul>\n</li><li><a href=\"#_217\">小结</a></li></ul>\n</li></ul>\n</div>\n<p></p>\n<h1><a id=\"_1\"></a>文本处理</h1>\n<h2><a id=\"_2\"></a>认识字符串</h2>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">using</span> string <span class=\"token operator\">=</span> std<span class=\"token double-colon punctuation\">::</span>basic_string<span class=\"token operator\">&lt;</span><span class=\"token keyword\">char</span><span class=\"token operator\">&gt;</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// string其实是一个类型别名</span>\n<span class=\"token comment\">//是模板类 basic_string 的特化形式，是一个 typedef：</span>\n</code></pre>\n<ul><li>字符串，就是字符的序列。字符是人类语言、文字的计算机表示。</li><li><code>Unicode</code>它的目标是用一种编码方式统一处理人类语言 文字，使用 32 位（4 个字节）来保证能够容纳过去或者将来所有的文字。</li></ul>\n<pre><code class=\"prism language-cpp\"><span class=\"token comment\">//char 类型，无法支持 Unicode</span>\n<span class=\"token keyword\">using</span> wstring <span class=\"token operator\">=</span> std<span class=\"token double-colon punctuation\">::</span>basic_string<span class=\"token operator\">&lt;</span><span class=\"token keyword\">wchar_t</span><span class=\"token operator\">&gt;</span><span class=\"token punctuation\">;</span> \n<span class=\"token keyword\">using</span> u16string <span class=\"token operator\">=</span> std<span class=\"token double-colon punctuation\">::</span>basic_string<span class=\"token operator\">&lt;</span><span class=\"token keyword\">char16_t</span><span class=\"token operator\">&gt;</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">//适配 UTF-16</span>\n<span class=\"token keyword\">using</span> u32string <span class=\"token operator\">=</span> std<span class=\"token double-colon punctuation\">::</span>basic_string<span class=\"token operator\">&lt;</span><span class=\"token keyword\">char32_t</span><span class=\"token operator\">&gt;</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">//适配 UTF-32</span>\n</code></pre>\n<p>+Unicode 还有一个 UTF-8 编码方式，与单字节的 char 完全兼容</p>\n<h2><a id=\"sring_18\"></a>sring使用</h2>\n<p>基本使用：<br/> <img alt=\"在这里插入图片描述\" src=\"image\\fc73e183b5de479096e9a51cc747ed9f.png\"/></p>\n<ul><li><strong>字符串和容器完全是两个不同的概念。把每个字符串都看作是一个不可变的实体，你才能在 C++ 里真正地用好字符串</strong></li><li>我们也确实需要存储字符的容器，比如字节序列、数据缓冲区，这该怎么办 呢？<br/> 这个时候，我建议你最好改用<strong>vector&lt;<strong>char</strong>&gt;</strong></li></ul>\n<h3><a id=\"1__24\"></a>1. 字面量后缀</h3>\n<ul><li>新增了一个字面量的后缀“s”，明确地表示它是 string 字符 串类型，而不是 C 字符串</li><li>为了避免与用户自定义字面量的冲突，后缀“s”不能直接使用，必须 用 using 打开名字空间才行<br/> <img alt=\"在这里插入图片描述\" src=\"image\\e2efceb5db4141dd92408335ab939fad.png\"/></li></ul>\n<h3><a id=\"2__28\"></a>2. 原始字符串</h3>\n<ul><li><code>C++11</code> 还为字面量增加了一个“原始字符串”（Raw string literal）的新表示形式。这样就没必要使用<code>\\</code> 对不可打印字符进行<strong>转义</strong>了<br/> <img alt=\"在这里插入图片描述\" src=\"image\\acf9e1569f624cc289181f3cbf3c230c.png\"/></li></ul>\n<pre><code class=\"prism language-cpp\"><span class=\"token comment\">// 如果想输出()</span>\n<span class=\"token keyword\">auto</span> str5 <span class=\"token operator\">=</span> <span class=\"token raw-string string\">R\"==(R\"(xxx)\")==\"</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 原样输出：R\"(xxx)\"</span>\n</code></pre>\n<h3><a id=\"3__38\"></a>3. 字符串转换函数</h3>\n<ul><li>stoi()、stol()、stoll() 等把字符串转换成整数；</li><li>stof()、stod() 等把字符串转换成浮点数；</li><li>to_string() 把整数、浮点数转换成字符串。<br/> <img alt=\"在这里插入图片描述\" src=\"image\\b46c20271f1346bfb0c1bf15446deb4f.png\"/></li></ul>\n<h3><a id=\"4__44\"></a>4. 字符串视图类</h3>\n<ul><li>大字符串的拷贝、修改代价很高，所 以我们通常都尽量用 const string&amp;</li><li>C++17 ： string_view , 一个字符串的视图，成本很低，内部只保存一个指针和长度，无论是拷贝，还是修改，都非 常廉价。<br/> <img alt=\"在这里插入图片描述\" src=\"image\\68290a3063074f228da27b13fbbedca3.png\"/></li></ul>\n<h3><a id=\"_51\"></a>正则表达式</h3>\n<ul><li> <p>C++ 正则表达式主要有两个类。<br/> regex：表示一个正则表达式，是 basic_regex 的特化形式；<br/> smatch：表示正则表达式的匹配结果，是 match_results 的特化形式。</p> </li><li> <p>C++ 正则匹配有三个算法，注意它们都是“只读”的，不会变动原字符串。<br/> regex_match()：完全匹配一个字符串；<br/> regex_search()：在字符串里查找一个正则匹配；<br/> regex_replace()：正则查找再做替换。<br/> <img alt=\"在这里插入图片描述\" src=\"image\\0d7fb7334664417fb312d8a1001eee8e.png\"/></p> </li><li> <p>你只要用 regex 定义好一个表达式，然后再调用匹配算法，就可以立刻得到结果， 用起来和其他语言差不多。不过，在写正则的时候，记得最好要用“原始字符串”，不然转义符会特别的麻烦。</p> </li><li> <p>regex_match() 检查字符串，函数会返回 bool 值表示是否完全匹配 正则。如果匹配成功，结果存储在 what 里，可以像容器那样去访问，第 0 号元素是整个 匹配串，其他的是子表达式匹配串：<br/> <img alt=\"在这里插入图片描述\" src=\"image\\c61f036eb7854df1aff49dd64a67f952.png\"/><img alt=\"在这里插入图片描述\" src=\"image\\de31af94179e41d88841bd85eb8f63ce.png\"/></p> </li><li> <p><img alt=\"在这里插入图片描述\" src=\"image\\46dac77f705346b1aca55efc1f88fd7e.png\"/></p> </li><li> <p><strong>尽量不要反复创建正则对象，能重用就重用</strong>。 在使用循环的时候更要特别注意，一定要把正则提到循环体外。</p> </li><li> <p>regex_replace() 不需要匹配结果，而是要提供一个替换字符串，因为算法是“只读”的， 所以它会返回修改后的新字符串。</p> </li><li> <p>https://github.com/chronolaw/cpp_study/blob/master/section3/string.cpp</p> </li></ul>\n<h1><a id=\"_69\"></a>容器</h1>\n<blockquote>\n<p>容器，就是能够“容纳”“存放”元素的一些数据结构。 容器 == 数据结构<br/> 容器，它也是 C++ 泛型编程范式的基础。</p>\n</blockquote>\n<ul><li>连续存储的数组：array、vector 和 deque。 指针结构的链表：list 和 forward_list。</li><li>指针结构的链表：list 和 forward_list。</li></ul>\n<h2><a id=\"_75\"></a>容器的通用特效</h2>\n<ul><li>容器里存储的是元素的拷贝、副本，而不是引用。</li><li><strong>array 和 vector 直接对应 C 的内置数组，内存布局与 C 完全兼容，所以是开销最低、速 度最快的容器</strong>。它们两个的区别在于容量能否动态增长。array 是静态数组，大小在初始化的时候就固定 了，不能再容纳更多的元素。而 vector 是动态数组，虽然初始化的时候设定了大小，但可 以在后面随需增长，容纳任意数量的元素。</li></ul>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\ce21a9f6eb01441e811a059afbb00ad0.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"image\\d21bdb4a8dc2435188ffdd8bca241fea.png\"/></p>\n<h2><a id=\"_81\"></a>有序容器</h2>\n<ul><li>顺序容器的特点是，元素的次序是由它插入的次序而决定的，访问元素也就按照最初插入的 顺序。而有序容器则不同，它的元素在插入容器后就被按照某种规则自动排序，所以是“有序”的。</li><li><strong>为了解决容器判断俩个元素的“先后顺序” ， 需要在定义容器的时候必须要指定 key 的 比较函数。</strong></li><li></li></ul>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\ea8771575add4544b9e80a97697dfe98.png\"/></p>\n<ul><li>方法一： 重载“&lt;”，另一个是自定义模板参数。<img alt=\"在这里插入图片描述\" src=\"image\\f8024b89d14b44cba7f2f6eec3e14295.png\"/></li><li>方法二：编写专门的函数对象或者 lambda 表达式，然后在容器的模板参数里指定。<br/> <img alt=\"在这里插入图片描述\" src=\"image\\16432ba4e7cf44699045ac538f98d88c.png\"/></li><li>有序容器： 集合关系就用 set，关联数组就用 map</li></ul>\n<h2><a id=\"_90\"></a>无序容器</h2>\n<ul><li>无序容器也有四种，名字里也有 set 和 map，只是加上了 unordered（无序）前缀，分别 是 unordered_set/unordered_multiset、unordered_map/unordered_multimap。 散列表（也叫哈希表，hash table）。<br/> <img alt=\"+\" src=\"image\\8398e93f377342e5994693fdf05829c5.png\"/></li></ul>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\655f3dbb97a04c5fbe4fc3d91094f803.png\"/></p>\n<ul><li><code>key</code> 具备两个条件: 一是可以计算<code> hash</code> 值，二是能够执行相等比较操作。<br/> <img alt=\"在这里插入图片描述\" src=\"image\\106abe48ea104d3b8ffe5ce7ab9ad17b.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"image\\31fee0afdeb74c4495dc2de24ccfa361.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"image\\7e355dffa11a43eab6ca1b86610a8d5e.png\"/></li><li>如果只想要单纯的集合、字典，没有排序需求，就应该用无序容 器，没有比较排序的成本，它的速度就会非常快。<br/> <img alt=\"+\" src=\"image\\400634e8c85040e18c7f19d42c177f65.png\"/><br/> <strong>就是多利用类型别名 using xx，而不要“写死”容器定义。因 为容器的大部分接口是相同的，所以只要变动别名定义，就能够随意改换不同的容器，对于 开发、测试都非常方便。</strong></li><li><code>vector</code> 是动态的， 不要使用<code>new / delete</code><img alt=\"在这里插入图片描述\" src=\"image\\69974cf51f614116bdaacac89896b535.png\"/></li></ul>\n<h1><a id=\"_105\"></a>算法</h1>\n<p>算法是 <code>STL</code>（标准库前身）的三大要件之一（容器、算法、迭代器），也是 <code>C++</code> 标准 库里一个非常重要的部分，但它却没有像容器那样被大众广泛接受。</p>\n<h2><a id=\"_107\"></a>认识算法</h2>\n<ul><li><code>C++</code> 里的算法，指的是工作在容器上的一些泛型函数，会对容器内的元素实施的各种操作。</li><li>算法其实并不神秘，因为所有的算法本质上都是 <code>for</code> 或者 <code>while</code>，通 过循环遍历来逐个处理容器里的元素，比如说 <code>count</code> 算法，它的功能非常简单，就是统计某个元素的出现次数，完全可以用 <code>range-for</code> 来实现同样的功能。<br/> <img alt=\"+\" src=\"image\\1dd89771cc0644089f5523c28fd54e4d.png\"/></li></ul>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\7cdf537e8a9545c0a8552055c229afbc.png\"/></p>\n<ul><li><strong>追求更高层次上的抽象和封装</strong>，也是函数式编程的基本理念。</li><li>算法只能通过迭代器去“间接”访问容器以及元素，算法的能力是由迭代器决定的.</li><li>好处：<strong>分离了数据和操作</strong>。弊端：算法是通用的，但对有的数据结构虽然可行 但<strong>效率比较低</strong></li></ul>\n<h2><a id=\"_117\"></a>迭代器</h2>\n<ul><li><code>C++ </code>里的迭代器也有很多种，比如输入迭代器、输出迭代器、双向迭代器、随机访问迭代 ，可以把它简单地理解为另一种形式的“<code>智能指针</code>”，只是它<strong>强调的是对数据的访问</strong>，而不是生命周期管理。</li><li>容器一般都会提供 <strong>begin()、end()</strong> 成员函数，调用它们就可以得到表示两个端点的迭代 器，具体类型最好<strong>用 auto</strong> 自动推导<br/> <img alt=\"在这里插入图片描述\" src=\"image\\b5ace89e4d3d4390b2189e3d5279af97.png\"/></li><li>类似 ++ – 操作的操作符 distance()，计算两个迭代器之间的距离； advance()，前进或者后退 N 步； next()/prev()，计算迭代器前后的某个位置。<br/> <img alt=\"在这里插入图片描述\" src=\"image\\dd786845567c4bd28923d934a24b876d.png\"/></li></ul>\n<h2><a id=\"for_each__for_125\"></a>for_each 代替 for</h2>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\d74a39d49ea24dcfbf23d852afe01974.png\"/></p>\n<ul><li><code>for_each</code> 算法的价值就体现在这里，它把要做的事情分成了两部分，也就是两个函数：一个遍历容器元素，另一个操纵容器元素，而且名字的含义更明确，代码也有更好的封装。它能够促使我们更多地以“函数式编程”来思考，使用 <code>lambda</code> 来封装逻辑，得到更干净、更安全的代码。</li></ul>\n<h2><a id=\"_128\"></a>排序算法</h2>\n<ul><li>sort() 快排算法 ， 不稳定，而且是全排所有元素。<br/> <img alt=\"在这里插入图片描述\" src=\"image\\654cfd7bdb794d098fb71d367d7702e6.png\"/></li><li>stable_sort，它是稳定的；</li><li>选出前几名（TopN），应该用 partial_sort；</li><li>选出前几名，但不要求再排出名次（BestN），应该用 nth_element；</li><li>中位数（Median）、百分位数（Percentile），还是用 nth_element；</li><li>按照某种规则把元素划分成两组，用 partition；</li><li>第一名和最后一名，用 minmax_element。<br/> <img alt=\"在这里插入图片描述\" src=\"image\\0691772639f44125a239e9694c07acac.png\"/></li><li>在使用这些排序算法时，还要注意一点，它们对迭代器要求比较高，通常都是随机访问迭代 器（minmax_element 除外），所以最好在顺序容器 array/vector 上调用。</li></ul>\n<h2><a id=\"_139\"></a>查找算法</h2>\n<h3><a id=\"_141\"></a>需要排序后使用查找算法</h3>\n<ul><li>binary_search () 查找一个数 如果在返回true<br/> <img alt=\"在这里插入图片描述\" src=\"image\\77075e973e1140978a07a5bf7e392952.png\"/></li><li>lower_bound查找左边界 二分的 search_left</li><li>upper_bound 查右边界 二分的 search_right<br/> <img alt=\"在这里插入图片描述\" src=\"image\\631bdeb7790546c68b6d748a7ad38a44.png\"/></li></ul>\n<h2><a id=\"_147\"></a>无需排序的查找算法</h2>\n<ul><li>标准库里还有一些查找算法可以 用于未排序的容器，虽然肯定没有排序后的二分查找速度快，但也正因为不需要排序，所以 适应范围更广。</li><li>find 和 search 命名，不过可能是当时制定标准时的疏忽，名称有点混乱，其 中用于查找区间的 find_first_of/find_end，或许更应该叫作 search_first/search_last<br/> <img alt=\"在这里插入图片描述\" src=\"image\\a4e77e37886b4f0698646a4c2202a70e.png\"/></li><li>C++ 里的算法像是一个大宝库，非常值得你去发掘。比如类似 memcpy 的 copy/move 算法（搭配插入迭代器）、检查元素的 all_of/any_of 算法，用好了都可以替 代很多手写 for 循环<br/> <img alt=\"在这里插入图片描述\" src=\"image\\06ed761e767a4dad93b1c4b03ca04332.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"image\\b41dcf90a73842b4b35e82e08ed659f0.png\"/></li></ul>\n<h1><a id=\"Concurrencymultithreading_155\"></a>“并发”（Concurrency）、“多线程”（multithreading）</h1>\n<h2><a id=\"_157\"></a>认识线程和多线程</h2>\n<ul><li>在 C++ 语言里，线程就是一个能够独立运行的函数。<br/> <img alt=\"在这里插入图片描述\" src=\"image\\0f669875d39449ebb2cd8a01cb935896.png\"/></li><li>任何程序一开始就有一个主线程，它从 main() 开始运行。主线程可以调用接口函数，创建 出子线程。子线程会立即脱离主线程的控制流程，单独运行，但共享主线程的数据。程序创 建出多个子线程，执行多个不同的函数，也就成了多线程。</li><li><strong>多线程的好处</strong>你肯定能列出好几条，比如任务并行、避免 I/O 阻塞、充分利用 CPU、提高 用户界面响应速度，等等。</li><li>缺点：比如同步、死锁、数据竞争、系统调度开 销等……</li></ul>\n<h3><a id=\"_163\"></a>“读而不写”就不会有数据竞争。</h3>\n<ul><li>在<code> C++</code> 多线程编程里读取 <code>const</code> 变量总是安全的，对类调用 <code>const</code> 成员函数、对 容器调用只读算法也总是线程安全的。</li><li>多用 const 关键字，尽可能让操作都 是只读的，为多线程打造一个坚实的基础。</li></ul>\n<h2><a id=\"_166\"></a>多线程开发实践</h2>\n<h3><a id=\"_167\"></a>仅调用一次</h3>\n<ul><li>程序免不了要初始化数据，这在多线程里却是一个不大不小的麻烦。因为线程并发，如果没 有某种同步手段来控制，会导致初始化函数多次运行.</li><li>声明一个<code> once_flag</code> 类型的变量,最好是静态、全局的.</li></ul>\n<pre><code class=\"prism language-c\"><span class=\"token keyword\">static</span> std<span class=\"token operator\">::</span>once_flag flag<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 全局的初始化标志</span>\n然后调用专门的 <span class=\"token function\">call_once</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> 函数 \n\n\n<span class=\"token keyword\">auto</span> f <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> \n<span class=\"token punctuation\">{<!-- --></span>\nstd<span class=\"token operator\">::</span><span class=\"token function\">call_once</span><span class=\"token punctuation\">(</span>flag<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token comment\">// 仅一次调用，注意要传flag // 匿名lambda，初始化函数，只会执行一次 </span>\n<span class=\"token comment\">// 在线程里运行的lambda表达式 </span>\ncout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"only once\"</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nthread <span class=\"token function\">t1</span><span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nthread <span class=\"token function\">t2</span><span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 启动两个线程，运行函数f</span>\n</code></pre>\n<h3><a id=\"_186\"></a>线程局部存储</h3>\n<ul><li>读写全局（或者局部静态）变量是另一个比较常见的数据竞争场景，因为共享数据，多线程 操作时就有可能导致状态不一致。</li><li>全局变量并不一定是必须共享的，可能仅仅是 为了方便线程传入传出数据，或者是本地 cache，而不是为了共享所有权。</li><li>线程独占所有权，不应该在多线程之间共同拥有，术语叫**“线程局部存储”**（thread local storage）。<br/> <img alt=\"在这里插入图片描述\" src=\"image\\7ef73b8a6c624e398e18eb4a10373a0d.png\"/><br/> 两个线程分别输出了 <code>10</code> 和 <code>20</code>，互不干扰 。<br/> 如果使用 <code>static</code> 就会输出 <code>30</code></li></ul>\n<h3><a id=\"_193\"></a>原子变量</h3>\n<ul><li>要想保证多线程读写共享数据的一致性，关键是要解决同步问题，不能让两个线程同时写， 也就是“互斥”。</li><li>所谓<strong>原子（atomic）</strong>，在多线程领域里的意思就是不可分的。操作要么完成，要么未完成，不能被任何外部操作打断，总是有一个确定的、完整的状态。所以也就不会存在竞争读 写的问题，不需要使用互斥量来同步，成本也就更低。 【避免同时执行一个操作】<br/> <img alt=\"在这里插入图片描述\" src=\"image\\30e13986cbd94bca98c028c978fb7176.png\"/></li><li>除了模拟整数运算，原子变量还有一些特殊的原子操作，比如 <strong>store、load、fetch_add、 fetch_sub、exchange、compare_exchange_weak/compare_exchange_strong</strong>，最后 一组就是著名的 <strong>CAS</strong>（Compare And Swap）操作。</li><li>而另一个同样著名的 **TAS（Test And Set）**操作，则需要用到一个特殊的原子类型 atomic_flag。</li><li>它不是简单的 <strong>bool 特化（atomic</strong>），没有 store、load 的操作，只用来实现 TAS，保证 绝对无锁.</li><li>原子变量禁用了拷贝构造函数，所以在初始化的时候不能用“=”的赋值形式，只能用圆括号或者花括号：<br/> <img alt=\"在这里插入图片描述\" src=\"image\\7b95e251e88a470fa915ea65348889b6.png\"/></li><li>除了模拟整数运算，原子变量还有一些特殊的原子操作，比如 store、load、fetch_add、 fetch_sub、exchange、compare_exchange_weak/compare_exchange_strong，最后一组就是著名的 CAS（Compare And Swap）操作。</li><li>而另一个同样著名的 TAS（Test And Set）操作，则需要用到一个特殊的原子类型 atomic_flag。</li><li>它不是简单的 bool 特化（atomic），没有 store、load 的操作，只用来实现 TAS，保证绝对无锁.</li><li>原子操作 的用法是把原子变量当作线程安全的全局计数器或者标志位，这也算是“初心”吧。 但它还有一个更重要的应用领域，就是实现高效的无锁数据结构（lock-free)</li></ul>\n<h3><a id=\"_206\"></a>线程</h3>\n<ul><li> <p>call_once、thread_local 和 atomic 这三个用于 C++ 多线程变成的工具，尽量消除显式地使用线程。</p> </li><li> <p>线程 ： <code>C++ </code>标准库里有专门的线程类<code>thread</code>，使用它就可以简单地创建线程，在名字空间 std::this_thread 里，还有 yield()、get_id()、sleep_for()、sleep_until() 等几个方便的管理函数。<br/> 原子操作atomic 结合 thread:<br/> <img alt=\"在这里插入图片描述\" src=\"image\\06dd5f9342f044f0abdfccba67bffada.png\"/></p> </li><li> <p><strong>async()</strong>，它的含义是“异步运行”一个任务。<br/> <img alt=\"在这里插入图片描述\" src=\"image\\22daa03d33d347d4b6b4a5973da19447.png\"/></p> </li><li> <p>async() 会返回一个 future 变量，可以认为是代表了执行结果的“期货”，如果任务有返回值，就可以用成员函数 get() 获取。不过要特别注意，<code>get()</code> 只能调一次，再次获取结果会发生错误，抛出异常 std::future_error。（至于为什么这么设计我也不太清楚，没找到官方的解释）<br/> 另外，这里还有一个很隐蔽的“坑”，如果你不显式获取 async() 的返回值（即 future 对象），它就会同步阻塞直至任务完成（由于临时对象的析构函数），于是“async”就变成 了“sync”。所以，即使我们不关心返回值，也总要用 <code>auto</code> 来配合<code> async()</code>，避免同步阻塞，就像下面 的示例代码那样<br/> <img alt=\"在这里插入图片描述\" src=\"image\\535447b322044de29d85499e45c792a1.png\"/></p> </li></ul>\n<h2><a id=\"_217\"></a>小结</h2>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\11468c307beb46d09d14909b0c0f3ed8.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"image\\519ea6ec9099461fb7e70b2e8b8054d8.png\"/></p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}