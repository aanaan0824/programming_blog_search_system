{"blogid": "125229830", "writerAge": "码龄4年", "writerBlogNum": "119", "writerCollect": "1078", "writerComment": "1437", "writerFan": "831", "writerGrade": "5级", "writerIntegral": "4426", "writerName": "爪哇斗罗", "writerProfileAdress": "writer_image\\profile_125229830.jpg", "writerRankTotal": "5206", "writerRankWeekly": "21724", "writerThumb": "1194", "writerVisitNum": "106377", "blog_read_count": "1161", "blog_time": "已于 2022-06-14 00:08:29 修改", "blog_title": "Spring注解详解：@ComponentScan自动扫描组件使用", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p><strong>目录</strong></p>\n<p style=\"margin-left:80px;\"><a href=\"#main-toc\">无注解方式component-scan使用</a></p>\n<p style=\"margin-left:80px;\"><a href=\"#%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8Fcomponent-scan%E4%BD%BF%E7%94%A8\">注解方式@ComponentScan使用</a></p>\n<p style=\"margin-left:80px;\"><a href=\"#%40ComponentScan%E7%9A%84%E6%89%AB%E6%8F%8F%E8%A7%84%E5%88%99\">@ComponentScan的扫描规则</a></p>\n<hr/>\n<p></p>\n<h3>无注解方式component-scan使用</h3>\n<p>之前，我们需要扫描工程下一些类上所标注的注解，这些常用注解有：</p>\n<blockquote>\n<p><span style=\"background-color:#ff9900;\">@Controller,</span><span style=\"background-color:#a2e043;\">@Service,</span><span style=\"background-color:#38d8f0;\">@Component,</span><span style=\"background-color:#4da8ee;\">@Repository</span></p>\n</blockquote>\n<p>通过在Spring的配置文件中配置<span style=\"background-color:#cccccc;\">&lt;context:component-scan&gt;</span>扫描对应包下扫描这些注解的方式：</p>\n<pre><code class=\"language-XML\">&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\txmlns:p=\"http://www.springframework.org/schema/p\"\n\txmlns:context=\"http://www.springframework.org/schema/context\"\n\txsi:schemaLocation=\"http://www.springframework.org/schema/beans\n         http://www.springframework.org/schema/beans/spring-beans.xsd\n         http://www.springframework.org/schema/context  \n         http://www.springframework.org/schema/context/spring-context-2.5.xsd\"&gt;\n\n    &lt;!--@Controller,@Service,@Component,@Repository--&gt;\n\t&lt;context:component-scan base-package=\"com.jektong.spring\"/&gt;\n\n&lt;/beans&gt;</code></pre>\n<h3>注解方式<strong>@ComponentScan</strong>使用</h3>\n<p>建三个类，依次将</p>\n<p><span style=\"background-color:#ff9900;\">@Controller</span>，<span style=\"background-color:#4da8ee;\">@Repository</span>，<span style=\"background-color:#a2e043;\">@Service,</span>标注这些类：</p>\n<div>\n<img alt=\"9676e1d230404d359e879afc90694c96.png\" src=\"image\\9676e1d230404d359e879afc90694c96.png\"/>\n<p>图1</p>\n</div>\n<p>现在通过使用注解<span style=\"color:#fe2c24;\"><strong>@ComponentScan</strong></span>的方式来扫描所在包下面的这些类：之前定义的<strong>PersonConfig修改：</strong></p>\n<pre><code class=\"language-java\">package com.jektong.config;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\n\nimport com.jektong.spring.Person;\n\n@Configuration\n@ComponentScan(\"com.jektong\")\npublic class PersonConfig {\n\n\t@Bean(\"person01\")\n\tpublic Person person() {\n\t\treturn new Person(\"李四\",21);\n\t}\n}</code></pre>\n<p>测试，看是否扫描到这些注解所标注的类：<strong>PersonTest.java</strong></p>\n<pre><code class=\"language-java\">@Test\npublic  void test02() {\n\tApplicationContext ac = new AnnotationConfigApplicationContext(PersonConfig.class);\n\tPerson bean = ac.getBean(Person.class);\n\tSystem.out.println(bean);\n\t\n\tString[] beanDefinitionNames = ac.getBeanDefinitionNames();\n\tfor (String string : beanDefinitionNames) {\n\t\tSystem.out.println(string);\n\t}\n}</code></pre>\n<p>测试效果：除了Spring要自动加载的配置类以外也显示了刚才添加的配置类：</p>\n<p><img alt=\"32af07a5fb0f442c916164f7f441bd35.png\" src=\"image\\32af07a5fb0f442c916164f7f441bd35.png\"/></p>\n<p>图2</p>\n<p>为何会出现<strong>PersonConfig</strong>,因为<span style=\"color:#0d0016;\"><span style=\"background-color:#4da8ee;\">@Configuration</span></span>本 身就是@Component注解的：</p>\n<div>\n<img alt=\"f3647d616e5145e68ca4f5c2c8a21616.png\" src=\"image\\f3647d616e5145e68ca4f5c2c8a21616.png\"/>\n<p>图3</p>\n</div>\n<h3>@ComponentScan的扫描规则</h3>\n<p>如果需要指定配置类的扫描规则, <span style=\"color:#fe2c24;\"><strong>@ComponentScan</strong></span>提供对应的扫描方式<span style=\"background-color:#98c091;\">@Filter</span>进行配置类的过滤：</p>\n<pre><code class=\"language-java\">// 扫描包的时候只规定扫描一些注解配置类。\nFilter[] includeFilters() default {};\n\n// 扫描包的时候可以排除一些注解配置类。 \nFilter[] excludeFilters() default {};</code></pre>\n<p><span style=\"background-color:#98c091;\">Filter</span>其实也是一个注解，相当于@ComponentScan的子注解，可以看<strong>图4</strong>：</p>\n<p><img alt=\"0616dc7cd25a4dcdb5ac759f50ab4230.png\" src=\"image\\0616dc7cd25a4dcdb5ac759f50ab4230.png\"/></p>\n<p>图4</p>\n<p><span style=\"background-color:#98c091;\">Filter</span>对应的过滤规则如下:</p>\n<p><strong>第一种：扫描包的时候只规定扫描一些注解配置类【includeFilters】。</strong></p>\n<p>使用这个<strong>includeFilters</strong>过滤规则，必须解除默认的过滤规则，</p>\n<p>使用<strong><span style=\"background-color:#6eaad7;\">【useDefaultFilters = false】</span>：</strong></p>\n<pre><code class=\"language-java\">package com.jektong.config;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.ComponentScan.Filter;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.FilterType;\nimport org.springframework.stereotype.Controller;\n\nimport com.jektong.spring.Person;\n\n@Configuration\n@ComponentScan(value = \"com.jektong\",includeFilters  = {\n\t\t@Filter(type = FilterType.ANNOTATION,value= {Controller.class})\n},useDefaultFilters = false )\npublic class PersonConfig {\n\n\t@Bean(\"person01\")\n\tpublic Person person() {\n\t\treturn new Person(\"李四\",21);\n\t}\n}</code></pre>\n<p>这样就只会扫描用<span style=\"background-color:#ff9900;\">@Controller,</span>标注的配置类交给Spring容器中了：</p>\n<div>\n<img alt=\"692b89ffdc8b4038977d5b4b8ebbbf94.png\" src=\"image\\692b89ffdc8b4038977d5b4b8ebbbf94.png\"/>\n<p>图5</p>\n</div>\n<p> <strong>第二种：扫描包的时候可以排除一些注解配置类【excludeFilters 】。</strong></p>\n<p><img alt=\"87f83f3d10824d1cb846cea234642191.png\" src=\"image\\87f83f3d10824d1cb846cea234642191.png\"/></p>\n<p>图6</p>\n<p> <span style=\"background-color:#98c091;\">@Filter</span>看上图，有5种不同类型的过滤策略。拿第一种举例，我们需要过滤使用@Controller注解的配置类：</p>\n<pre><code class=\"language-java\">package com.jektong.config;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.ComponentScan.Filter;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.FilterType;\nimport org.springframework.stereotype.Controller;\n\nimport com.jektong.spring.Person;\n\n@Configuration\n@ComponentScan(value = \"com.jektong\",excludeFilters = {\n\t\t@Filter(type = FilterType.ANNOTATION,value= {Controller.class})\n} )\npublic class PersonConfig {\n\n\t@Bean(\"person01\")\n\tpublic Person person() {\n\t\treturn new Person(\"李四\",21);\n\t}\n}</code></pre>\n<p>测试看一下发现<strong>图2</strong>中的personController不会交给Spring容器去管理了：</p>\n<div>\n<img alt=\"1157d6b18b2f40d89f59310b3c624bf4.png\" src=\"image\\1157d6b18b2f40d89f59310b3c624bf4.png\"/>\n<p>图7</p>\n</div>\n<p></p>\n<p>上面的<strong>图6</strong>展示出5种不同类型的过滤策略，上面介绍了注解类型（<strong><span style=\"color:#38d8f0;\">FilterType.ANNOTATION</span></strong>），还有四种： </p>\n<p><strong><span style=\"color:#0d0016;\">重点看一下</span><span style=\"color:#38d8f0;\">CUSTOM</span><span style=\"color:#0d0016;\">自定义扫描策略。</span></strong></p>\n<p><img alt=\"\" height=\"108\" src=\"image\\741f046a299741d799e9e5e7acc75efb.png\" width=\"890\"/></p>\n<p> </p>\n<p>从源码看，自定义扫描注解类型需要实现<strong>TypeFilter接口,下面就写一个实现类MyFilter.java:</strong>在实现类中可以自定义配置规则：</p>\n<pre><code class=\"language-java\">package com.jektong.config;\n\nimport java.io.IOException;\n\nimport org.springframework.core.io.Resource;\nimport org.springframework.core.type.AnnotationMetadata;\nimport org.springframework.core.type.ClassMetadata;\nimport org.springframework.core.type.classreading.MetadataReader;\nimport org.springframework.core.type.classreading.MetadataReaderFactory;\nimport org.springframework.core.type.filter.TypeFilter;\n\npublic class MyFilter implements TypeFilter {\n\n\t@Override\n\tpublic boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)\n\t\t\tthrows IOException {\n\t\t// 查看当前类的注解。\n\t\tAnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata();\n\t\t// 查看当前扫描类的信息\n\t\tClassMetadata classMetadata = metadataReader.getClassMetadata();\n\t\t// 获取当前类资源\n\t\tResource resource = metadataReader.getResource();\n\t\tString className = classMetadata.getClassName();\n\t\tSystem.out.println(\"className===&gt;\" + className);\n\t\t// 只要类名包含er则注册Spring容器\n\t\tif(className.contains(\"er\")) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n</code></pre>\n<p>测试：</p>\n<p></p>\n<p><strong>PersonConfig 中进行扫描：</strong></p>\n<pre><code class=\"language-java\">package com.jektong.config;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.ComponentScan.Filter;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.FilterType;\nimport org.springframework.stereotype.Controller;\n\nimport com.jektong.service.PersonService;\nimport com.jektong.spring.Person;\n\n@Configuration\n@ComponentScan(value = \"com.jektong\",includeFilters  = {\n\t\t@Filter(type = FilterType.CUSTOM,value= {MyFilter.class})\n},useDefaultFilters = false )\npublic class PersonConfig {\n\n\t@Bean(\"person01\")\n\tpublic Person person() {\n\t\treturn new Person(\"李四\",21);\n\t}\n}</code></pre>\n<p>可以看出扫描出包下面的类只要带“er”的全部扫描出来，并配置给Spring容器：</p>\n<p><img alt=\"\" height=\"375\" src=\"image\\987228c827424ea7a74d015c6aadeb6c.png\" width=\"891\"/></p>\n<p><strong><span style=\"color:#38d8f0;\">ASSIGNABLE_TYPE：</span><span style=\"color:#0d0016;\">按照指定的类型去加载对应配置类：</span></strong></p>\n<pre><code class=\"language-java\">package com.jektong.config;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.ComponentScan.Filter;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.FilterType;\nimport org.springframework.stereotype.Controller;\n\nimport com.jektong.service.PersonService;\nimport com.jektong.spring.Person;\n\n@Configuration\n@ComponentScan(value = \"com.jektong\",includeFilters  = {\n\t\t@Filter(type = FilterType.ASSIGNABLE_TYPE,value= {PersonService.class})\n},useDefaultFilters = false )\npublic class PersonConfig {\n\n\t@Bean(\"person01\")\n\tpublic Person person() {\n\t\treturn new Person(\"李四\",21);\n\t}\n}</code></pre>\n<p>尽管我们将PersonService.java上的注解去掉，使用<strong><span style=\"color:#38d8f0;\">ASSIGNABLE_TYPE依然会加载出来（自行测试）。</span></strong></p>\n<p><strong><span style=\"color:#38d8f0;\">ASPECTJ与REGEX</span><span style=\"color:#0d0016;\">基本不用，不用了解。</span></strong></p>\n<p>以上就是<strong><span style=\"background-color:#9c8ec1;\">@ComponentScan</span></strong>的具体用法，该兴趣的话可以看一下源码。</p>\n<p></p>\n</div>\n</div>"}