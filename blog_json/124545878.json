{"blogid": "124545878", "writerAge": "码龄1年", "writerBlogNum": "30", "writerCollect": "130", "writerComment": "4", "writerFan": "24", "writerGrade": "2级", "writerIntegral": "364", "writerName": "Amy--成长ing", "writerProfileAdress": "writer_image\\profile_124545878.jpg", "writerRankTotal": "54560", "writerRankWeekly": "489780", "writerThumb": "59", "writerVisitNum": "55953", "blog_read_count": "13124", "blog_time": "已于 2022-06-24 00:02:29 修改", "blog_title": "什么是跨域？跨域解决方法", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h2>一、为什么会出现<a class=\"link-info\" href=\"https://so.csdn.net/so/search?spm=1001.2014.3001.4498&amp;q=%E8%B7%A8%E5%9F%9F&amp;t=&amp;u=\" title=\"跨域\">跨域</a>问题</h2>\n<p>       出于浏览器的同源策略限制。同源策略（Sameoriginpolicy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。同源策略会阻止一个域的。javascript脚本和另外一个域的内容进行交互。所谓同源（即指在同一个域）就是两个页面具有相同的协议（protocol），主机（host）和端口号（port。</p>\n<h3>二、什么是跨域</h3>\n<p>1.当一个请求url的<strong><a class=\"link-info\" href=\"https://so.csdn.net/so/search?spm=1001.2014.3001.4498&amp;q=%E5%8D%8F%E8%AE%AE%E3%80%81%E5%9F%9F%E5%90%8D%E3%80%81%E7%AB%AF%E5%8F%A3&amp;t=&amp;u=\" title=\"协议、域名、端口\">协议、域名、端口</a></strong>三者之间任意一个与当前页面url不同即为跨域。</p>\n<p><img alt=\"\" height=\"234\" src=\"image\\70e9de32598a4783acfafbf082ff3039.png\" width=\"962\"/></p>\n<p>2.当我们对跨域概念有一定的基础了解时，开始实操一下跨域演示吧！</p>\n<p>   <strong> 2.1目录结构</strong></p>\n<p><img alt=\"\" height=\"202\" src=\"image\\279dec7983c2464a9ed1834656c222d9.png\" width=\"750\"/></p>\n<p></p>\n<h3 id=\"b5af3249\">    2.2前端页面</h3>\n<p id=\"ufb5e870a\">     public/index.html</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;button id=\"btn1_get\"&gt;接口测试1：get请求带参数&lt;/button&gt;\n    &lt;button id=\"btn2_post\"&gt; 接口测试2:post-传递普通键值对&lt;/button&gt;\n    &lt;hr/&gt;\n    &lt;button id=\"btn3_postJSON\"&gt;接口测试3:post-传递json&lt;/button&gt;\n    &lt;hr/&gt;\n    &lt;form id=\"myform\"&gt;\n        &lt;input type=\"text\" name=\"title\"&gt;\n        &lt;input type=\"file\" name=\"cover\"&gt;\n    &lt;/form&gt;\n    &lt;button id=\"btn4_formdata\"&gt;接口测试4:post-传递formdata&lt;/button&gt;\n    &lt;hr/&gt;\n    &lt;script src=\"./js/axios.js\"&gt;&lt;/script&gt;\n    &lt;script&gt;\n    document.getElementById('btn1_get').addEventListener('click',() =&gt; {\n        axios.get('http://localhost:3000/getapi', {params: {a:1,b:2}})\n    })\n    var obj = {\n        \"name\":\"abc\",\n        \"address\":{\n            \"a\":1,\n            \"b\":2,\n            \"info\":\"c\"\n        }\n    }\n    document.getElementById('btn2_post').addEventListener('click', () =&gt; {\n        const params = new URLSearchParams();\n        params.append('param1', 'value1');\n        params.append('param2', 'value2');\n        axios.post('http://localhost:3000/post', params, {\n            headers: {\"content-type\":\"application/x-www-form-urlencoded\"}})\n    })\n\n    document.getElementById('btn3_postJSON').addEventListener('click', () =&gt; {\n        axios.post('http://localhost:3000/postJSON', obj)\n    })\n\n    document.getElementById('btn4_formdata').addEventListener('click', () =&gt; {\n        console.log(1)\n        var fd = new FormData(document.getElementById('myform'));\n\n        axios.post('http://localhost:3000/publish', \n            fd\n        )\n    })\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre>\n<p></p>\n<h3 id=\"e778d61a\"> 2.3后端</h3>\n<pre><code>// 实现get接口\nconst express = require('express')\nconst app = express();\n\napp.use(express.static('public'))\n// 引入bodyParse包\nconst bodyParser = require('body-parser')\n// 使用包. 则在后续的post请求中\n// 会自动加入req.body属性，这个属性中就包含了post请求所传入的参数\n// 处理普通的键值对格式\n// Content-Type: application/x-www-form-urlencoded\napp.use(express.urlencoded())\n\n// 处理JSON格式\n// Content-Type: application/json;\napp.use(express.json())\n\n// 引入multer包\nconst multer = require('multer');\n\n// 配置一下multer\n// 如果本次post请求涉及文件上传，则上传到uploads这个文件夹下\n// Content-Type: multipart/form-data;\nvar upload = multer({ dest: 'uploads/'})\n\n\n// 实现接口1： get类型接口\n// 返回所传入的参数，并附上上时间戳\napp.get('/getapi',(req,res)=&gt;{\n    // 通过 req.query快速获取传入的参数\n    console.log(req.query);\n    let obj = req.query\n    \n    obj._t = Date.now(); \n    res.json( obj )\n})\n\n// 实现接口2：普通post 键值对\napp.post('/post',(req,res)=&gt;{\n    // 希望在后端收到post传参\n    console.log(req.body);\n\n    let obj = req.body\n    obj._t = Date.now();\n    \n    res.json(obj)\n})\n\n// 实现接口3：用来JSON格式的数据\n// Content-Type: application/json;\napp.post('/postJSON',(req,res)=&gt;{\n    // 希望在后端收到post传参\n    console.log(req.body);\n    \n    // res.send('/postJSON')\n    res.json( req.body )\n})\n\n// 实现接口4：接口formDate\napp.post('/publish',upload.single('cover'),(req,res)=&gt;{\n    console.log('publish...')\n    //upload.single('cover')\n    // 这里的cover就是在页面中表单元素中的name\n    // &lt;input type=\"file\" name=\"cover\" /&gt;\n    // 把要上传文件放在指定的目录\n    console.log(req.file);\n    // 其它参数，还是在req.body中找\n    console.log(req.body);\n\n    res.json({code:200,msg:'上传成功',info:req.file.path})\n})\n\napp.listen(3000,()=&gt;{\n    console.log('express应用在3000端口启动了'); \n})</code></pre>\n<p><span style=\"color:#fe2c24;\"><strong>代码报错演示</strong></span></p>\n<hr/>\n<h3><img alt=\"\" height=\"331\" src=\"image\\f5351bd5c8d542ae9a58dae9ce2425eb.png\" width=\"868\"/></h3>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\b0c9f8e4eff86f1277c849554f6d8d0b.png\"/></p>\n<h2> 三、跨域-错误原因及解决思路</h2>\n<h3>3.1什么原因导致了浏览器报跨域错误</h3>\n<p id=\"u9415c812\">      3.1.1发起ajax请求的那个页面的地址 和 ajax接口地址 不在同一个域中。</p>\n<p id=\"u09e41c51\">      3.1.2跨域错误:<code>不同源</code>的<code>ajax请求</code>====&gt; 报跨域的错误。</p>\n<p id=\"u15e4dcf8\">      3.1.3浏览器向web服务器发起http请求时 ，如果同时满足以下<code>三个条件</code>时，就会出现跨域问题，从而导致ajax请求失败。</p>\n<p id=\"uc9c74468\">（1）请求响应双方url不同源。</p>\n<p id=\"u5f246750\">          双方url：发出请求所在的页面 与 所请求的资源的url</p>\n<p id=\"u6b082c78\">          同源是指：<code>协议相同</code>，<code>域名相同</code>，<code>端口相同</code> 都相同。</p>\n<p id=\"ud7ceacce\">以下就是不同源的：</p>\n<p id=\"u2c5bdf42\">       从<code>http://127.0.0.1:5500/message_front/index.html</code> 请求<code>http://localhost:8080/getmsg</code></p>\n<p id=\"u4b9235e7\">网络中不同源的请求有很多。</p>\n<p id=\"uf732609e\">（2）请求类型是xhr请求。就是常说的ajax请求。不是请求图片资源，js文件,css文件等</p>\n<p id=\"ub0d06bd4\">（3）浏览器觉得不安全。跨域问题出现的基本原因是浏览器的同源策略。<strong>同源策略</strong>是一个重要的安全策略，它限制一个<a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/Origin\" title=\"origin\">origin</a>的文档或者它加载的脚本如何能与另一个源的资源进行交互。</p>\n<p id=\"u37970543\">注意，错误是发生在浏览器端的。请求是可以正常从浏览器发到服务器端，服务器也可以处理请求，只是返回到浏览器端时出错了。</p>\n<p><img alt=\"\" height=\"194\" src=\"image\\8ece07238c9f4336883571699152d639.png\" width=\"871\"/></p>\n<h3 id=\"0a7aacf1\">3.2解决思路</h3>\n<p id=\"u88e1f173\">请求响应双方url不同源</p>\n<p id=\"u9d489e82\"><strong>    服务器代理</strong></p>\n<p id=\"u66433d4b\">请求是ajax</p>\n<ul><li id=\"ucfea23e1\"><strong>改发<a class=\"link-info\" href=\"https://so.csdn.net/so/search?q=JSONP&amp;t=&amp;u=&amp;urw=\" title=\"JSONP\">JSONP</a></strong></li></ul>\n<p id=\"u120e7a41\">浏览器觉得不安全 （后端还是能收到请求的）</p>\n<ul><li id=\"u78b92ead\">可以安装一个浏览器插件<code>allow-control-allow-origin</code> 绕过同源策略。</li><li id=\"u2a2cfab3\">用postman软件测试</li><li id=\"u78e4b50f\"><strong><a class=\"link-info\" href=\"https://so.csdn.net/so/search?spm=1001.2014.3001.4498&amp;q=CORS&amp;t=code&amp;u=\" title=\"CORS\">CORS</a></strong></li></ul>\n<p><strong><span style=\"color:#fe2c24;\">3.2.1请求响应双方url不同源</span></strong></p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\4dbf4db0661cd797b535e694e12bc22d.png\"/></p>\n<h3 id=\"RwCeE\">原理</h3>\n<ul><li id=\"u614b8c71\">script的src属性可以请求外部的js文件，这个请求不是ajax，它没有跨域问题。</li><li id=\"u5ea07887\">借助 <code>script</code> 标签的src请求服务端上的接口。<code>&lt;script src=\"http://localhost:3000/get\"。</code></li><li id=\"u7576eb59\">服务端的接口返回JavaScript 脚本，并附上要返回的数据。例如：<code>res.end(\"fn(数据)\")。</code></li></ul>\n<h3 id=\"f610ae8c\">实现步骤</h3>\n<ul><li id=\"u4a27f206\">补充script标签并设置它的src值为接口地址</li><li id=\"u6281fc71\">改造接口返回函数调用表达式，并传入数据</li><li id=\"u0723a2da\">在前端准备相应的函数</li></ul>\n<p id=\"u686ddd90\"><span style=\"color:#fe2c24;\">注意：</span></p>\n<ul><li id=\"ue02a00e0\">script标签中的src会指向一个后端接口的地址。由于script标签并不会导致跨域问题，所以这里的请求是可以正常发送和接收的。</li><li id=\"u7d0a62e5\">与我们之前理解的src指向某个具体的.js文件不同，我们只需要确保src所指向的地址的返回内容是js代码就行了，而不必要src直接指向某个.js文件。</li><li id=\"ua3b8cbcc\">接口地址中返回的内容将会作为script标签的主体。</li></ul>\n<p> <img alt=\"\" height=\"301\" src=\"image\\7e5541888d0f4d4faa58f62750c8a6c5.png\" width=\"674\"/></p>\n<p id=\"ud466f02d\"><span style=\"color:#fe2c24;\">注意：</span></p>\n<ul><li id=\"u5a8f0fa2\">后端接口的返回值是一个特殊的字符串： 一个刻意拼写的js函数调用语句。</li></ul>\n<p><img alt=\"\" height=\"189\" src=\"image\\cc7575816e654a08a16c3b9756fc7fa6.png\" width=\"675\"/></p>\n<p> 图示：</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\a5d2158775747880ca5e7f0d8c04a831.png\"/></p>\n<p><strong><span style=\"color:#fe2c24;\">3.2.2改发<a class=\"link-info\" href=\"https://so.csdn.net/so/search?spm=1001.2014.3001.4498&amp;q=JSONP&amp;t=&amp;u=\" title=\"JSONP\">JSONP</a></span></strong></p>\n<p>       首先前后端需要添加不同的内容，前端加上datastype:json属性，则后端express框架已经提供了一个名为jsonp的方法来处理jsonp请求:原来是res.json,要改成res.jsonp</p>\n<p><img alt=\"\" height=\"189\" src=\"image\\39afbe418b4d465a87c7152ea696bb6a.png\" width=\"672\"/></p>\n<p><img alt=\"\" height=\"233\" src=\"image\\b6e421e11c5f4f6bac73a323673bb0b1.png\" width=\"670\"/></p>\n<p><span style=\"color:#fe2c24;\"><strong> 3.2.3  CORS</strong></span></p>\n<p id=\"u8927c9f8\">        CORS是一个W3C标准，全称是\"跨域资源共享\"（Cross-origin resource sharing）。它允许浏览器向跨源服务器，发出<code><a href=\"http://www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html\" title=\"XMLHttpRequest\">XMLHttpRequest</a></code>请求，从而克服了AJAX只能<a href=\"http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html\" title=\"同源\">同源</a>使用的限制。</p>\n<p id=\"u35d902f5\">        CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10(ie8通过XDomainRequest能支持CORS)。</p>\n<p><img alt=\"\" height=\"356\" src=\"image\\4e41af38101d4ec4bf26af1df65a8339.png\" width=\"937\"/></p>\n<p> 首先准备一个案例，通过在<strong>被请求的路由中</strong>设置header头，可以实现跨域。</p>\n<p><img alt=\"\" height=\"166\" src=\"image\\ce072c3da97f457286ef772e91de14af.png\" width=\"677\"/></p>\n<p><span style=\"color:#fe2c24;\"> 那么这样的方法有什么意义呢？</span></p>\n<ul><li id=\"uc9248d2b\">这种方案无需客户端作出任何变化（客户端不用改代码），就当跨域问题不存在一样。</li><li id=\"u55581cef\">服务端响应的时候添加一个 <code>Access-Control-Allow-Origin</code> 的响应头。</li></ul>\n<p><span style=\"color:#fe2c24;\">又该如何使用cors</span></p>\n<ol><li id=\"u69f5f447\">它是一个npm包，要单独下载使用 npm 包 <a href=\"https://www.npmjs.com/package/cors\" title=\"cors\">cors</a><br/><code>npm i cors</code></li><li id=\"u6422e522\">当做express中的中间件，注意代码应该放在顶部 <p><img alt=\"\" height=\"67\" src=\"image\\963c654811e14fecb3ad31c3a0be45db.png\" width=\"759\"/></p> </li></ol>\n<p id=\"ud96fd164\">此时也许正在想jsonp vs cors 对比哪个更好呢</p>\n<p id=\"u972c6d00\"><span style=\"color:#fe2c24;\"><strong>jsonp：</strong></span></p>\n<ul><li id=\"u1c0b0ff3\">不是ajax</li><li id=\"uc7748a4b\">只能支持<code>get方式</code></li><li id=\"u257d02fe\">兼容性好</li></ul>\n<p id=\"u694afdb6\"><strong><span style=\"color:#fe2c24;\">cors:</span></strong></p>\n<ul><li id=\"u6cf9b564\">前端不需要做额外的修改，就当跨域问题不存在。</li><li id=\"ua6ab5b83\">是ajax</li><li id=\"u3676dcbc\">支持各种方式的请求(post,get....)</li><li id=\"uf1202419\">浏览器的支持不好（标准浏览器都支持）</li></ul>\n<p></p>\n<p>持续更新中............</p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n</div>\n</div>"}