{"blogid": "126074911", "writerAge": "码龄5年", "writerBlogNum": "82", "writerCollect": "609", "writerComment": "73", "writerFan": "5297", "writerGrade": "5级", "writerIntegral": "1830", "writerName": "熊思宇", "writerProfileAdress": "writer_image\\profile_126074911.jpg", "writerRankTotal": "9706", "writerRankWeekly": "1170", "writerThumb": "149", "writerVisitNum": "238768", "blog_read_count": "782", "blog_time": "已于 2022-07-31 14:34:56 修改", "blog_title": "C# Rectangle基本用法和图片切割", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E4%B8%80%E3%80%81%E9%9C%80%E6%B1%82-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%80%E3%80%81%E9%9C%80%E6%B1%82\">一、需求</a></p>\n<p id=\"Rectangle(Point%2C%20Size)-toc\" style=\"margin-left:40px;\"><a href=\"#Rectangle%28Point%2C%20Size%29\">Rectangle(Point, Size)</a></p>\n<p id=\"Rectangle(Int32%2C%20Int32%2C%20Int32%2C%20Int32)-toc\" style=\"margin-left:40px;\"><a href=\"#Rectangle%28Int32%2C%20Int32%2C%20Int32%2C%20Int32%29\">Rectangle(Int32, Int32, Int32, Int32)</a></p>\n<p id=\"%E4%BA%8C%E3%80%81%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8A%9F%E8%83%BD-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BA%8C%E3%80%81%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8A%9F%E8%83%BD\">二、常用的功能</a></p>\n<p id=\"1.%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E7%9F%A9%E5%BD%A2%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4-toc\" style=\"margin-left:40px;\"><a href=\"#1.%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E7%9F%A9%E5%BD%A2%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4\">1.判断两个矩形是否相交</a></p>\n<p id=\"2.%E6%B1%82%E5%87%BA%E4%B8%A4%E7%9F%A9%E5%BD%A2%E7%9B%B8%E4%BA%A4%E9%87%8D%E5%8F%A0%E5%A4%84%E7%9A%84%E7%9F%A9%E5%BD%A2-toc\" style=\"margin-left:40px;\"><a href=\"#2.%E6%B1%82%E5%87%BA%E4%B8%A4%E7%9F%A9%E5%BD%A2%E7%9B%B8%E4%BA%A4%E9%87%8D%E5%8F%A0%E5%A4%84%E7%9A%84%E7%9F%A9%E5%BD%A2\">2.求出两矩形相交重叠处的矩形</a></p>\n<p id=\"3.%E6%A1%88%E4%BE%8B-toc\" style=\"margin-left:40px;\"><a href=\"#3.%E6%A1%88%E4%BE%8B\">3.案例</a></p>\n<p id=\"%E4%B8%89%E3%80%81%E5%88%87%E5%9B%BEDemo-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%89%E3%80%81%E5%88%87%E5%9B%BEDemo\">三、切图Demo</a></p>\n<p id=\"%E7%BB%93%E6%9D%9F-toc\" style=\"margin-left:0px;\"><a href=\"#%E7%BB%93%E6%9D%9F\">结束</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<p></p>\n<h1 id=\"%E4%B8%80%E3%80%81%E9%9C%80%E6%B1%82\">一、需求</h1>\n<p>矩形在开发中非常常见，比如截图功能，GDI+ 画图，Rectangle 的构造函数中，需要提供四个参数，坐标x，y，宽度，高度，另外还封装了其他的一写方法，比如是否相交，两矩形相交处重叠的矩形，根据左上，和右下坐标生成矩形等等方法，下面是构造函数的一些介绍。</p>\n<p>构造函数：</p>\n<h2 id=\"Rectangle(Point%2C%20Size)\">Rectangle(Point, Size)</h2>\n<p>用指定的位置和大小初始化 Rectangle 类的新实例。</p>\n<pre><code class=\"language-cs\">public Rectangle (System.Drawing.Point location, System.Drawing.Size size);</code></pre>\n<p>参数：location Point  Point，它表示矩形区域的左上角。size Size  Size，它表示矩形区域的宽度和高度。</p>\n<h2 id=\"Rectangle(Int32%2C%20Int32%2C%20Int32%2C%20Int32)\">Rectangle(Int32, Int32, Int32, Int32)</h2>\n<p>用指定的位置和大小初始化 Rectangle 类的新实例。</p>\n<pre><code class=\"language-cs\">public Rectangle (int x, int y, int width, int height);</code></pre>\n<p>参数：x Int32 矩形左上角的 x 坐标。y Int32 矩形左上角的 y 坐标。width Int32 矩形的宽度。height Int32 矩形的高度。</p>\n<p><br/>  </p>\n<h1 id=\"%E4%BA%8C%E3%80%81%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8A%9F%E8%83%BD\">二、常用的功能</h1>\n<h2 id=\"1.%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E7%9F%A9%E5%BD%A2%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4\">1.判断两个矩形是否相交</h2>\n<p>判断连个矩形是否相交，返回值是布尔类型</p>\n<pre><code class=\"language-cs\">Rectangle rectangle1 = new Rectangle(100,100,50,50);\nRectangle rectangle2 = new Rectangle(110,110,50,50);\nbool isIntersect = rectangle1.IntersectsWith(rectangle2);</code></pre>\n<h2 id=\"2.%E6%B1%82%E5%87%BA%E4%B8%A4%E7%9F%A9%E5%BD%A2%E7%9B%B8%E4%BA%A4%E9%87%8D%E5%8F%A0%E5%A4%84%E7%9A%84%E7%9F%A9%E5%BD%A2\">2.求出两矩形相交重叠处的矩形</h2>\n<p>两个矩形相交后，根据两个矩形的重叠处，得出一个新的矩形</p>\n<pre><code class=\"language-cs\">Rectangle rectangle1 = new Rectangle(100,100,50,50);\nRectangle rectangle2 = new Rectangle(110,110,50,50);\nRectangle overlap = Rectangle.Intersect(rectangle1, rectangle2);</code></pre>\n<h2 id=\"3.%E6%A1%88%E4%BE%8B\">3.案例</h2>\n<p>上面这两个API，下面就用一个案例来展示</p>\n<p>效果</p>\n<p style=\"text-align:center;\"><img alt=\"\" class=\"left\" src=\"https://img-blog.csdnimg.cn/9e9175279a734536af9fc8cf560d48e1.gif\"/></p>\n<p>上图可以看到，当两个图像重合后，就立马将重合的部分图像显示在旁边的小图中了，另外，我将是否重合的判断输出在控制台中了</p>\n<p><img alt=\"\" height=\"234\" src=\"image\\29be643721ff4621a6a71d3c129a7152.png\" width=\"300\"/></p>\n<p>界面设计</p>\n<p><img alt=\"\" height=\"383\" src=\"image\\fb96dfbcf9074bcf9e1a78757f20cff4.png\" width=\"600\"/></p>\n<p>代码</p>\n<pre><code class=\"language-cs\">using System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\nusing System.Data;\nusing System.Drawing;\nusing System.Drawing.Drawing2D;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing System.Windows.Forms;\n\nnamespace 矩形\n{\n    public partial class Form1 : Form\n    {\n        public Form1()\n        {\n            InitializeComponent();\n        }\n\n        //图片列表\n        private string Img1Path = Application.StartupPath + \"\\\\test.jpg\";\n        //存储矩形列表\n        List&lt;Rectangle&gt; PictureCuttingList = new List&lt;Rectangle&gt;();\n        //边长\n        int SideLength = 180;\n\n        private void Form1_Load(object sender, EventArgs e)\n        {\n\n        }\n\n        private void Button_Examine_Click(object sender, EventArgs e)\n        {\n            if (!System.IO.File.Exists(Img1Path))\n            {\n                Console.WriteLine(\"图片路径不存在：\" + Img1Path);\n                return;\n            }\n\n            Bitmap bitmaps = new Bitmap(Img1Path);\n            Random random = new Random();\n\n            PictureCuttingList.Clear();\n            PictureBox_Coincide.Image = null;\n\n            for (int i = 0; i &lt; 2; i++)\n            {\n                int x = random.Next(10, bitmaps.Width - SideLength);\n                int y = random.Next(10, bitmaps.Height - SideLength);\n                PictureCuttingList.Add(new Rectangle(new Point(x, y), new Size(SideLength, SideLength)));\n            }\n\n            //给图片画矩形\n            PictureBox_Template.Image = PaintingRectangle(PictureCuttingList, bitmaps);\n\n            //判断两个矩形是否相交\n            Rectangle rectangle1 = PictureCuttingList[0];\n            Rectangle rectangle2 = PictureCuttingList[1];\n\n            bool isRect = rectangle1.IntersectsWith(rectangle2);\n            Console.WriteLine(\"两个矩形是否相交：\" + isRect);\n            if (isRect)\n            {\n                //两个矩形相交部分图片显示到小图中\n                Rectangle overlap = Rectangle.Intersect(rectangle1, rectangle2);\n                Bitmap newBitmap = new Bitmap(Img1Path);\n                Bitmap cuttingBitmap = newBitmap.Clone(overlap, System.Drawing.Imaging.PixelFormat.DontCare);\n                PictureBox_Coincide.Image = cuttingBitmap;\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// 给图片画矩形\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"rectanglesList\"&gt;&lt;/param&gt;\n        /// &lt;param name=\"bitmap\"&gt;&lt;/param&gt;\n        public Bitmap PaintingRectangle(List&lt;Rectangle&gt; rectanglesList, Bitmap bitmap)\n        {\n            Bitmap bit = null;\n            for (int i = 0; i &lt; rectanglesList.Count; i++)\n            {\n                if (bit == null)\n                {\n                    bit = DrawRectangleInPicture(bitmap, rectanglesList[i], Color.Red, 4, \"索引：\" + i, 25);\n                }\n                else\n                {\n                    Bitmap newBit = new Bitmap(bit);\n                    bit.Dispose();\n                    bit = DrawRectangleInPicture(newBit, rectanglesList[i], Color.Red, 4, \"索引：\" + i, 25);\n                }\n            }\n            if (bit == null)\n            {\n                Console.WriteLine(\"bit等于null\");\n                return null;\n            }\n\n            return bit;\n        }\n\n        /// &lt;summary&gt;\n        /// 图片上画矩形和标记文字\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"bmp\"&gt;图片bitmap&lt;/param&gt;\n        /// &lt;param name=\"imgRectangle\"&gt;矩形&lt;/param&gt;\n        /// &lt;param name=\"lineColor\"&gt;线条的颜色&lt;/param&gt;\n        /// &lt;param name=\"lineWidth\"&gt;线条&lt;/param&gt;\n        /// &lt;param name=\"text\"&gt;矩形的文本&lt;/param&gt;\n        /// &lt;param name=\"fontSize\"&gt;字体大小&lt;/param&gt;\n        /// &lt;param name=\"ds\"&gt;线条的线型&lt;/param&gt;\n        /// &lt;returns&gt;&lt;/returns&gt;\n        public Bitmap DrawRectangleInPicture(Bitmap bmp, Rectangle imgRectangle, Color lineColor, int lineWidth, string text, int fontSize, DashStyle ds = DashStyle.Solid)\n        {\n            if (bmp == null) return null;\n            if (imgRectangle == null) return null;\n            if (lineColor == null) return null;\n            if (lineWidth == 0) return null;\n            if (fontSize == 0) return null;\n            if (string.IsNullOrEmpty(text)) return null;\n\n            Point pos = imgRectangle.Location;\n            Size size = imgRectangle.Size;\n\n            Graphics g = Graphics.FromImage(bmp);\n\n            Brush brush = new SolidBrush(lineColor);\n            Pen pen = new Pen(brush, lineWidth);\n            pen.DashStyle = ds;\n\n            //画坐标的原点（用于测试）\n            g.DrawEllipse(pen, new Rectangle(pos.X, pos.Y, 15, 15));\n\n            //画矩形\n            //int rectX = pos.X - (size.Width / 2);\n            //int rectY = pos.Y - (size.Height / 2);\n            //g.DrawRectangle(pen, rectX, rectY, size.Width, size.Height);\n            g.DrawRectangle(pen, pos.X, pos.Y, size.Width, size.Height);\n\n            Font myFont = new Font(\"宋体\", fontSize, FontStyle.Regular);\n            Brush bush = new SolidBrush(lineColor);//填充的颜色\n\n            //字体位置的计算\n            SizeF sizeF = g.MeasureString(text, myFont);\n            //int fontPosX = (int)(pos.X - (sizeF.Width / 2));\n            //int fontPosY = (int)(pos.Y + (sizeF.Height / 2) + (size.Height / 2));\n            //g.DrawString(text, myFont, bush, fontPosX, fontPosY);\n            int fontPosX = (int)(pos.X + (size.Width / 2) - (sizeF.Width / 2));\n            int fontPosY = (int)(pos.Y + (size.Height / 2) - (sizeF.Height / 2));\n            g.DrawString(text, myFont, bush, fontPosX, fontPosY);\n\n            g.Dispose();\n\n            return bmp;\n        }\n    }\n}\n</code></pre>\n<p></p>\n<h1 id=\"%E4%B8%89%E3%80%81%E5%88%87%E5%9B%BEDemo\">三、切图Demo</h1>\n<p>切图的demo和上面的案例的功能类似</p>\n<p>界面</p>\n<p><img alt=\"\" height=\"564\" src=\"image\\9190b9a0bf90414589e3c3aa6b976e39.png\" width=\"600\"/></p>\n<p>效果</p>\n<p style=\"text-align:center;\"><img alt=\"\" class=\"left\" src=\"https://img-blog.csdnimg.cn/0e121a43c2624b3ab65457aea8ea2b23.gif\"/></p>\n<p> 上面gif图片的最后画面</p>\n<p><img alt=\"\" height=\"665\" src=\"image\\efed4b0bf1b54af2a3514c82b8df3a29.png\" width=\"700\"/></p>\n<p> 代码</p>\n<pre><code class=\"language-cs\">using System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\nusing System.Data;\nusing System.Drawing;\nusing System.Drawing.Drawing2D;\nusing System.Linq;\nusing System.Text;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing System.Windows.Forms;\n\nnamespace 裁切小图\n{\n    public partial class Form1 : Form\n    {\n        public Form1()\n        {\n            InitializeComponent();\n        }\n\n        string Img1Path = Application.StartupPath + \"\\\\test.jpg\";\n\n        List&lt;PictureBox&gt; PictureBoxesList = new List&lt;PictureBox&gt;();\n        List&lt;Rectangle&gt; PictureCuttingList = new List&lt;Rectangle&gt;();\n\n        //切割小图的宽度\n        int ImgWidth = 180;\n\n        private void Form1_Load(object sender, EventArgs e)\n        {\n            TextBox_ImaPath.Text = Img1Path;\n\n            PictureBoxesList.Add(pictureBox1);\n            PictureBoxesList.Add(pictureBox2);\n            PictureBoxesList.Add(pictureBox3);\n            PictureBoxesList.Add(pictureBox4);\n            PictureBoxesList.Add(pictureBox5);\n        }\n\n        /// &lt;summary&gt;\n        /// 选择图片路径\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"sender\"&gt;&lt;/param&gt;\n        /// &lt;param name=\"e\"&gt;&lt;/param&gt;\n        private void Button_SelectImg_Click(object sender, EventArgs e)\n        {\n            OpenFileDialog dialog = new OpenFileDialog();\n            dialog.Multiselect = true;//该值确定是否可以选择多个文件\n            dialog.Title = \"请选择文件\";\n            dialog.Filter = \"所有文件(*.*)|*.*\";\n            if (dialog.ShowDialog() == System.Windows.Forms.DialogResult.OK)\n            {\n                TextBox_ImaPath.Text = dialog.FileName;\n                Img1Path = dialog.FileName;\n                PictureBox_Template.Image = new Bitmap(Img1Path);\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// 生成矩形图\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"sender\"&gt;&lt;/param&gt;\n        /// &lt;param name=\"e\"&gt;&lt;/param&gt;\n        private void Button_Examine_Click(object sender, EventArgs e)\n        {\n            if (!System.IO.File.Exists(Img1Path))\n            {\n                Console.WriteLine(\"图片路径不存在：\" + Img1Path);\n                return;\n            }\n   \n            Bitmap bitmaps = new Bitmap(Img1Path);\n            Random random = new Random();\n\n            //Console.WriteLine(string.Format(\"总宽度：{0} 总高度：{1}\", Bitmaps.Width, Bitmaps.Height));\n\n            PictureCuttingList.Clear();\n            for (int i = 0; i &lt; 2; i++)\n            {\n                int x = random.Next(10, bitmaps.Width - ImgWidth);\n                int y = random.Next(10, bitmaps.Height - ImgWidth);\n\n                //这样写矩形会超出图片范围，可以用来测试\n                //int x = random.Next(10, Bitmaps.Width);\n                //int y = random.Next(10, Bitmaps.Height);\n\n                //Console.WriteLine(string.Format(\"索引值: {0} x: {1}, y: {2}\", i, x, y));\n\n                PictureCuttingList.Add(new Rectangle(new Point(x, y), new Size(ImgWidth, ImgWidth)));\n            }\n\n            //给图片画矩形\n            PictureBox_Template.Image = PaintingRectangle(PictureCuttingList, bitmaps);\n\n        }\n\n        /// &lt;summary&gt;\n        /// 开始切割\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"sender\"&gt;&lt;/param&gt;\n        /// &lt;param name=\"e\"&gt;&lt;/param&gt;\n        private void Button_Cutting_Click(object sender, EventArgs e)\n        {\n            if (!System.IO.File.Exists(Img1Path))\n            {\n                Console.WriteLine(\"图片路径不存在：\" + Img1Path);\n                return;\n            }\n            if (PictureCuttingList.Count == 0)\n            {\n                Console.WriteLine(\"PictureCuttingList不能为空\");\n                return;\n            }\n\n            Bitmap bitmaps = new Bitmap(Img1Path);\n            List&lt;Bitmap&gt; cuttingList = CuttingHandle(PictureCuttingList, bitmaps);\n            if (cuttingList != null &amp;&amp; cuttingList.Count &gt; 0)\n            {\n                for (int i = 0; i &lt; cuttingList.Count; i++)\n                {\n                    PictureBoxesList[i].Image = cuttingList[i];\n                }\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// 给图片画矩形\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"rectanglesList\"&gt;&lt;/param&gt;\n        /// &lt;param name=\"bitmap\"&gt;&lt;/param&gt;\n        public Bitmap PaintingRectangle(List&lt;Rectangle&gt; rectanglesList, Bitmap bitmap)\n        {\n            Bitmap bit = null;\n            for (int i = 0; i &lt; rectanglesList.Count; i++)\n            {\n                if (bit == null)\n                {\n                    bit = DrawRectangleInPicture(bitmap, rectanglesList[i], Color.Red, 4, \"索引：\" + i, 25);\n                }\n                else\n                {\n                    Bitmap newBit = new Bitmap(bit);\n                    bit.Dispose();\n                    bit = DrawRectangleInPicture(newBit, rectanglesList[i], Color.Red, 4, \"索引：\" + i, 25);\n                }\n            }\n            if (bit == null)\n            {\n                Console.WriteLine(\"bit等于null\");\n                return null;\n            }\n\n            return bit;\n        }\n\n        /// &lt;summary&gt;\n        /// 裁切图片（切片的坐标以左上角为原点)\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"pictureCuttingList\"&gt;区域数据列表&lt;/param&gt;\n        /// &lt;param name=\"bitmap\"&gt;图片bitmap&lt;/param&gt;\n        /// &lt;returns&gt;切片的图片列表&lt;/returns&gt;\n        public List&lt;Bitmap&gt; CuttingHandle(List&lt;Rectangle&gt; pictureCuttingList, Bitmap bitmap)\n        {\n            if (pictureCuttingList == null || pictureCuttingList.Count == 0)\n            {\n                Console.WriteLine(\"[CuttingHandle]pictureCuttingList不能为空\");\n                return null;\n            }\n            if (bitmap == null)\n            {\n                Console.WriteLine(\"[CuttingHandle]图片bitmap不能为空\");\n                return null;\n            }\n\n            List&lt;Bitmap&gt; bitmapList = new List&lt;Bitmap&gt;();\n            for (int i = 0; i &lt; pictureCuttingList.Count; i++)\n            {\n                Rectangle rectangle = pictureCuttingList[i];\n                if(rectangle == null)\n                {\n                    Console.WriteLine(\"[CuttingHandle]pictureCuttingList有值为空，index：\" + i);\n                    return null;\n                }\n                //判断坐标是否在图片范围内\n                Point pos = rectangle.Location;\n                Size size = rectangle.Size;\n                if(pos.X &lt; 0 || pos.X + size.Width &gt; bitmap.Width)\n                {\n                    Console.WriteLine(\"[CuttingHandle]当前区域X轴超出图片范围，索引是：\" + i);\n                    return null;\n                }\n                if(pos.Y &lt; 0 || pos.Y + size.Height &gt; bitmap.Height)\n                {\n                    Console.WriteLine(\"[CuttingHandle]当前区域Y轴超出图片范围，索引是：\" + i);\n                    return null;\n                }\n\n                Bitmap cuttingBitmap = bitmap.Clone(rectangle, System.Drawing.Imaging.PixelFormat.DontCare);\n                bitmapList.Add(cuttingBitmap);\n            }\n\n            if (bitmapList.Count &gt; 0)\n                return bitmapList;\n\n            return null;\n        }\n\n\n        /// &lt;summary&gt;\n        /// 图片上画矩形和标记文字\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"bmp\"&gt;图片bitmap&lt;/param&gt;\n        /// &lt;param name=\"imgRectangle\"&gt;矩形&lt;/param&gt;\n        /// &lt;param name=\"lineColor\"&gt;线条的颜色&lt;/param&gt;\n        /// &lt;param name=\"lineWidth\"&gt;线条&lt;/param&gt;\n        /// &lt;param name=\"text\"&gt;矩形的文本&lt;/param&gt;\n        /// &lt;param name=\"fontSize\"&gt;字体大小&lt;/param&gt;\n        /// &lt;param name=\"ds\"&gt;线条的线型&lt;/param&gt;\n        /// &lt;returns&gt;&lt;/returns&gt;\n        public Bitmap DrawRectangleInPicture(Bitmap bmp, Rectangle imgRectangle, Color lineColor, int lineWidth, string text, int fontSize, DashStyle ds = DashStyle.Solid)\n        {\n            if (bmp == null) return null;\n            if (imgRectangle == null) return null;\n            if (lineColor == null) return null;\n            if (lineWidth == 0) return null;\n            if (fontSize == 0) return null;\n            if (string.IsNullOrEmpty(text)) return null;\n\n            Point pos = imgRectangle.Location;\n            Size size = imgRectangle.Size;\n\n            Graphics g = Graphics.FromImage(bmp);\n\n            Brush brush = new SolidBrush(lineColor);\n            Pen pen = new Pen(brush, lineWidth);\n            pen.DashStyle = ds;\n\n            //画坐标的原点（用于测试）\n            g.DrawEllipse(pen, new Rectangle(pos.X, pos.Y, 15, 15));\n\n            //画矩形\n            //int rectX = pos.X - (size.Width / 2);\n            //int rectY = pos.Y - (size.Height / 2);\n            //g.DrawRectangle(pen, rectX, rectY, size.Width, size.Height);\n            g.DrawRectangle(pen, pos.X, pos.Y, size.Width, size.Height);\n\n            Font myFont = new Font(\"宋体\", fontSize, FontStyle.Regular);\n            Brush bush = new SolidBrush(lineColor);//填充的颜色\n\n            //字体位置的计算\n            SizeF sizeF = g.MeasureString(text, myFont);\n            //int fontPosX = (int)(pos.X - (sizeF.Width / 2));\n            //int fontPosY = (int)(pos.Y + (sizeF.Height / 2) + (size.Height / 2));\n            //g.DrawString(text, myFont, bush, fontPosX, fontPosY);\n            int fontPosX = (int)(pos.X + (size.Width / 2) - (sizeF.Width / 2));\n            int fontPosY = (int)(pos.Y + (size.Height / 2) - (sizeF.Height / 2));\n            g.DrawString(text, myFont, bush, fontPosX, fontPosY);\n\n            g.Dispose();\n\n            return bmp;\n        }\n\n\n    }\n}\n</code></pre>\n<p> 源码地址：<a class=\"link-info\" href=\"https://download.csdn.net/download/qq_38693757/86268551\" title=\"点击下载\">点击下载</a></p>\n<p></p>\n<h1 id=\"%E7%BB%93%E6%9D%9F\">结束</h1>\n<p>如果这个帖子对你有用，欢迎 关注 + 点赞 + 留言，谢谢</p>\n<p>end</p>\n</div>\n</div>"}