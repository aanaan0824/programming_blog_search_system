{"blogid": "119967779", "writerAge": "码龄11年", "writerBlogNum": "28", "writerCollect": "552", "writerComment": "29", "writerFan": "134", "writerGrade": "3级", "writerIntegral": "422", "writerName": "李宥小哥", "writerProfileAdress": "writer_image\\profile_119967779.jpg", "writerRankTotal": "34456", "writerRankWeekly": "14039", "writerThumb": "121", "writerVisitNum": "89604", "blog_read_count": "7883", "blog_time": "于 2021-08-28 14:30:55 发布", "blog_title": "C#高级--Expression详解", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-github-gist\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h1><a id=\"CExpression_0\"></a>C#高级–Expression详解</h1>\n<h2><a id=\"httpsblogcsdnnetliyou123456789articledetails119715435_2\"></a><a href=\"https://blog.csdn.net/liyou123456789/article/details/119715435\">零、文章目录</a></h2>\n<h2><a id=\"Expression_4\"></a>一、Expression是什么</h2>\n<h3><a id=\"1_6\"></a>1、如何定义</h3>\n<ul><li>Expression&lt;Func&lt;TSource, bool&gt;&gt;就是表达式目录树</li><li>Expression不能带有大括号，只能有一行代码</li></ul>\n<h3><a id=\"2_11\"></a>2、和委托的区别</h3>\n<ul><li> <p>在委托外面包裹一层Expression&lt;&gt;就是表达式目录树</p> </li><li> <p>表达式目录树可以通过Compile()转换成一个委托</p> </li></ul>\n<h3><a id=\"3Expression_17\"></a>3、Expression本质</h3>\n<ul><li>表达式目录树是一个类的封装，描述了一个结构，有身体部分和参数部分</li><li>身体部分分为左边和右边，内部描述了左边和右边之间的关系，可以不断的往下拆分，类似于二叉树</li><li>表达式目录树展开后的每一个节点也是一个表达式目录树</li></ul>\n<pre><code class=\"prism language-C#\">Expression&lt;Func&lt;People, bool&gt;&gt; expression = p =&gt; p.Id == 10;\nFunc&lt;People, bool&gt; func = expression.Compile();\nbool bResult = func.Invoke(new People()\n{\n    Id = 10,\n    Name = \"张三\"\n});\n</code></pre>\n<h2><a id=\"Expression_33\"></a>二、Expression动态拼装</h2>\n<h3><a id=\"1_35\"></a>1、最基础版本</h3>\n<pre><code class=\"prism language-C#\">Expression&lt;Func&lt;int&gt;&gt; expression = () =&gt; 123 + 234;\n//常量表达式\nConstantExpression expression1 = Expression.Constant(123);\nConstantExpression expression2 = Expression.Constant(234);\n//二元表达式\nBinaryExpression binaryExpression = Expression.Add(expression1, expression2);\nExpression&lt;Func&lt;int&gt;&gt; expressionReslut = Expression.Lambda&lt;Func&lt;int&gt;&gt;(binaryExpression);\nFunc&lt;int&gt; func = expressionReslut.Compile();\nint iResult = func.Invoke();\n</code></pre>\n<h3><a id=\"2_49\"></a>2、带参数版本</h3>\n<pre><code class=\"prism language-C#\">Expression&lt;Func&lt;int, int&gt;&gt; expression1 = m =&gt; m + 1;\nFunc&lt;int, int&gt; func = expression1.Compile();\nint iResult = func.Invoke(5);\n//参数表达式\nParameterExpression parameterExpression = Expression.Parameter(typeof(int), \"m\");\n//常量表达式\nConstantExpression constant = Expression.Constant(1, typeof(int));\n//二元表达式\nBinaryExpression addExpression = Expression.Add(parameterExpression, constant);\nExpression&lt;Func&lt;int, int&gt;&gt; expression = Expression.Lambda&lt;Func&lt;int, int&gt;&gt;(addExpression, new ParameterExpression[1]\n{\n      parameterExpression\n});\nFunc&lt;int, int&gt; func1 = expression.Compile();\nint iResult1 = func1.Invoke(5);\n</code></pre>\n<h3><a id=\"3_69\"></a>3、带有多个参数</h3>\n<pre><code class=\"prism language-C#\">Expression&lt;Func&lt;int, int, int&gt;&gt; expression = (m, n) =&gt; m * n + 2;\nFunc&lt;int, int, int&gt; func = expression.Compile();\nint iResult = func.Invoke(10, 20);\n//参数表达式\nParameterExpression parameterExpressionM = Expression.Parameter(typeof(int), \"m\");\nParameterExpression parameterExpressionN = Expression.Parameter(typeof(int), \"n\");\n//二元表达式\nBinaryExpression multiply = Expression.Multiply(parameterExpressionM, parameterExpressionN);\n//常量表达式\nConstantExpression constantExpression = Expression.Constant(2);\n//二元表达式\nBinaryExpression plus = Expression.Add(multiply, constantExpression);\nExpression&lt;Func&lt;int, int, int&gt;&gt; expression1 = Expression.Lambda&lt;Func&lt;int, int, int&gt;&gt;(plus, new ParameterExpression[2]\n{\n      parameterExpressionM,\n      parameterExpressionN\n});\nFunc&lt;int, int, int&gt; func1 = expression1.Compile();\nint iResult1 = func1.Invoke(10, 20);\n</code></pre>\n<h3><a id=\"4_93\"></a>4、对象字段值比较</h3>\n<p>类似于这种比较复杂的，建议大家可以反编译看看</p>\n<pre><code class=\"prism language-C#\">Expression&lt;Func&lt;People, bool&gt;&gt; predicate = c =&gt; c.Id == 10;\nFunc&lt;People, bool&gt; func = predicate.Compile();\nbool bResult = func.Invoke(new People()\n{\n    Id = 10\n});\n\n//参数表达式\nParameterExpression parameterExpression = Expression.Parameter(typeof(People), \"c\");\n//反射获取属性\nFieldInfo fieldId = typeof(People).GetField(\"Id\");\n//通过parameterExpression来获取调用Id\nMemberExpression idExp = Expression.Field(parameterExpression, fieldId);\n//常量表达式\nConstantExpression constant10 = Expression.Constant(10, typeof(int));\n//二元表达式\nBinaryExpression expressionExp = Expression.Equal(idExp, constant10);\nExpression&lt;Func&lt;People, bool&gt;&gt; predicate1 = Expression.Lambda&lt;Func&lt;People, bool&gt;&gt;(expressionExp, new ParameterExpression[1]\n{\n            parameterExpression\n});\n\nFunc&lt;People, bool&gt; func1 = predicate1.Compile();\nbool bResult1 = func1.Invoke(new People()\n{\n    Id = 10\n});\n</code></pre>\n<h3><a id=\"5_127\"></a>5、多条件</h3>\n<p>如果遇到很长的表达式目录树，拼装建议从右往左拼装</p>\n<pre><code class=\"prism language-C#\">Expression&lt;Func&lt;People, bool&gt;&gt; predicate = c =&gt;\n    c.Id.ToString() == \"10\"\n    &amp;&amp; c.Name.Equals(\"张三\")\n    &amp;&amp; c.Age &gt; 35;\nFunc&lt;People, bool&gt; func = predicate.Compile();\nbool bResult = func.Invoke(new People()\n{\n    Id = 10,\n    Name = \"张三\",\n    Age = 36\n});\n\nParameterExpression parameterExpression = Expression.Parameter(typeof(People), \"c\");\n//c.Age &gt; 35\nConstantExpression constant35 = Expression.Constant(35);\nPropertyInfo propAge = typeof(People).GetProperty(\"Age\");\nMemberExpression ageExp = Expression.Property(parameterExpression, propAge);\nBinaryExpression cagExp = Expression.GreaterThan(ageExp, constant35);\n//c.Name.Equals(\"张三\")\nConstantExpression constantrichard = Expression.Constant(\"张三\");\nPropertyInfo propName = typeof(People).GetProperty(\"Name\");\nMemberExpression nameExp = Expression.Property(parameterExpression, propName);\nMethodInfo equals = typeof(string).GetMethod(\"Equals\", new Type[] { typeof(string) });\nMethodCallExpression NameExp = Expression.Call(nameExp, equals, constantrichard);\n//c.Id.ToString() == \"10\"\nConstantExpression constantExpression10 = Expression.Constant(\"10\", typeof(string));\nFieldInfo fieldId = typeof(People).GetField(\"Id\");\nvar idExp = Expression.Field(parameterExpression, fieldId);\nMethodInfo toString = typeof(int).GetMethod(\"ToString\", new Type[0]);\nvar toStringExp = Expression.Call(idExp, toString, Array.Empty&lt;Expression&gt;());\nvar EqualExp = Expression.Equal(toStringExp, constantExpression10);\n//c.Id.ToString() == \"10\"&amp;&amp; c.Name.Equals(\"张三\")&amp;&amp; c.Age &gt; 35\nvar plus = Expression.AndAlso(EqualExp, NameExp);\nvar exp = Expression.AndAlso(plus, cagExp);\nExpression&lt;Func&lt;People, bool&gt;&gt; predicate1 = Expression.Lambda&lt;Func&lt;People, bool&gt;&gt;(exp, new ParameterExpression[1]\n{\n     parameterExpression\n});\nFunc&lt;People, bool&gt; func1 = predicate1.Compile();\nbool bResult1 = func1.Invoke(new People()\n{\n    Id = 10,\n    Name = \"张三\",\n    Age = 36\n});\n</code></pre>\n<h2><a id=\"ExpressionMapper_179\"></a>三、Expression应用之Mapper映射</h2>\n<p>需求：需要把People字段值映射到PeopleCopy字段</p>\n<h3><a id=\"1_183\"></a>1、硬编码</h3>\n<p>性能好，不灵活；不能共用</p>\n<pre><code class=\"prism language-C#\">PeopleCopy peopleCopy0 = new PeopleCopy()\n{\n    Id = people.Id,\n    Name = people.Name,\n    Age = people.Age\n};\n</code></pre>\n<h3><a id=\"2_196\"></a>2、反射</h3>\n<p>灵活，但是性能不好</p>\n<pre><code class=\"prism language-C#\">using System;\n\nnamespace MyExpression.MappingExtend\n{\n    public class ReflectionMapper\n    {\n        /// &lt;summary&gt;\n        /// 反射\n        /// &lt;/summary&gt;\n        /// &lt;typeparam name=\"TIn\"&gt;&lt;/typeparam&gt;\n        /// &lt;typeparam name=\"TOut\"&gt;&lt;/typeparam&gt;\n        /// &lt;param name=\"tIn\"&gt;&lt;/param&gt;\n        /// &lt;returns&gt;&lt;/returns&gt;\n        public static TOut Trans&lt;TIn, TOut&gt;(TIn tIn)\n        {\n            TOut tOut = Activator.CreateInstance&lt;TOut&gt;();\n            foreach (var itemOut in tOut.GetType().GetProperties())\n            {\n                var propIn = tIn.GetType().GetProperty(itemOut.Name);\n                itemOut.SetValue(tOut, propIn.GetValue(tIn)); \n            }\n\n            foreach (var itemOut in tOut.GetType().GetFields())\n            {\n                var fieldIn = tIn.GetType().GetField(itemOut.Name);\n                itemOut.SetValue(tOut, fieldIn.GetValue(tIn)); \n            }\n            return tOut;\n        }\n    }\n}\n</code></pre>\n<p>调用</p>\n<pre><code class=\"prism language-C3\">PeopleCopy peopleCopy1 = ReflectionMapper.Trans&lt;People, PeopleCopy&gt;(people);\n</code></pre>\n<h3><a id=\"3_240\"></a>3、序列化</h3>\n<p>灵活，但是性能不好</p>\n<pre><code class=\"prism language-C#\">using Newtonsoft.Json;\n\nnamespace MyExpression.MappingExtend\n{\n    public class SerializeMapper\n    {\n        /// &lt;summary&gt;\n        /// 序列化\n        /// &lt;/summary&gt;\n        /// &lt;typeparam name=\"TIn\"&gt;&lt;/typeparam&gt;\n        /// &lt;typeparam name=\"TOut\"&gt;&lt;/typeparam&gt;\n        public static TOut Trans&lt;TIn, TOut&gt;(TIn tIn)\n        {\n            string strJson = JsonConvert.SerializeObject(tIn); \n            return JsonConvert.DeserializeObject&lt;TOut&gt;(strJson);\n        }\n    }\n}\n</code></pre>\n<p>调用</p>\n<pre><code class=\"prism language-C#\">PeopleCopy peopleCopy2 = SerializeMapper.Trans&lt;People, PeopleCopy&gt;(people);\n</code></pre>\n<h3><a id=\"4Expression_271\"></a>4、Expression动态拼接+普通缓存</h3>\n<ul><li>把People变成PeopleCopy的过程封装在一个委托中，这个委托通过表达式目录树Compile出来，过程动态拼装适应不同的类型</li><li>第一次生成的时候，保存一个委托在缓存中，如果第二次来，委托就可以直接从缓存中获取到，直接运行委托，效率高</li></ul>\n<pre><code class=\"prism language-C#\">using System;\nusing System.Collections.Generic;\nusing System.Linq.Expressions;\n\nnamespace MyExpression.MappingExtend\n{    \n    public class ExpressionMapper\n    {\n        /// &lt;summary&gt;\n        /// 字典缓存，保存的是委托，委托内部是转换的动作\n        /// &lt;/summary&gt;\n        private static Dictionary&lt;string, object&gt; _Dic = new Dictionary&lt;string, object&gt;();\n\n        /// &lt;summary&gt;\n        /// Expression动态拼接+普通缓存\n        /// &lt;/summary&gt;\n        /// &lt;typeparam name=\"TIn\"&gt;&lt;/typeparam&gt;\n        /// &lt;typeparam name=\"TOut\"&gt;&lt;/typeparam&gt;\n        /// &lt;param name=\"tIn\"&gt;&lt;/param&gt;\n        /// &lt;returns&gt;&lt;/returns&gt;\n        public static TOut Trans&lt;TIn, TOut&gt;(TIn tIn)\n        {\n            string key = $\"funckey_{typeof(TIn).FullName}_{typeof(TOut).FullName}\";\n            if (!_Dic.ContainsKey(key))\n            {\n                ParameterExpression parameterExpression = Expression.Parameter(typeof(TIn), \"p\");\n                List&lt;MemberBinding&gt; memberBindingList = new List&lt;MemberBinding&gt;();\n                foreach (var item in typeof(TOut).GetProperties())\n                {\n                    MemberExpression property = Expression.Property(parameterExpression, typeof(TIn).GetProperty(item.Name));\n                    MemberBinding memberBinding = Expression.Bind(item, property);\n                    memberBindingList.Add(memberBinding);\n                }\n                foreach (var item in typeof(TOut).GetFields())\n                {\n                    MemberExpression property = Expression.Field(parameterExpression, typeof(TIn).GetField(item.Name));\n                    MemberBinding memberBinding = Expression.Bind(item, property);\n                    memberBindingList.Add(memberBinding);\n                }\n                MemberInitExpression memberInitExpression = Expression.MemberInit(Expression.New(typeof(TOut)), memberBindingList.ToArray());\n                Expression&lt;Func&lt;TIn, TOut&gt;&gt; lambda = Expression.Lambda&lt;Func&lt;TIn, TOut&gt;&gt;(memberInitExpression, new ParameterExpression[]\n                {\n                    parameterExpression\n                });\n                Func&lt;TIn, TOut&gt; func = lambda.Compile();//拼装是一次性的\n                _Dic[key] = func;\n            }\n            return ((Func&lt;TIn, TOut&gt;)_Dic[key]).Invoke(tIn);\n        }\n    }\n}\n</code></pre>\n<p>调用</p>\n<pre><code class=\"prism language-C#\">PeopleCopy peopleCopy3 = ExpressionMapper.Trans&lt;People, PeopleCopy&gt;(people);\n</code></pre>\n<h3><a id=\"5Expression_336\"></a>5、Expression动态拼接+泛型缓存</h3>\n<p>泛型缓存，就是为为每一组类型的组合，生成一个副本，性能最高</p>\n<pre><code class=\"prism language-C#\">using System;\nusing System.Collections.Generic;\nusing System.Linq.Expressions;\n\nnamespace MyExpression.MappingExtend\n{\n    /// &lt;summary&gt;\n    /// Expression动态拼接+泛型缓存\n    /// &lt;/summary&gt;\n    /// &lt;typeparam name=\"TIn\"&gt;&lt;/typeparam&gt;\n    /// &lt;typeparam name=\"TOut\"&gt;&lt;/typeparam&gt;\n    public class ExpressionGenericMapper&lt;TIn, TOut&gt;//Mapper`2\n    {\n        private static Func&lt;TIn, TOut&gt; _FUNC = null;\n        static ExpressionGenericMapper()\n        {\n            ParameterExpression parameterExpression = Expression.Parameter(typeof(TIn), \"p\");\n            List&lt;MemberBinding&gt; memberBindingList = new List&lt;MemberBinding&gt;();\n            foreach (var item in typeof(TOut).GetProperties())\n            {\n                MemberExpression property = Expression.Property(parameterExpression, typeof(TIn).GetProperty(item.Name));\n                MemberBinding memberBinding = Expression.Bind(item, property);\n                memberBindingList.Add(memberBinding);\n            }\n            foreach (var item in typeof(TOut).GetFields())\n            {\n                MemberExpression property = Expression.Field(parameterExpression, typeof(TIn).GetField(item.Name));\n                MemberBinding memberBinding = Expression.Bind(item, property);\n                memberBindingList.Add(memberBinding);\n            }\n            MemberInitExpression memberInitExpression = Expression.MemberInit(Expression.New(typeof(TOut)), memberBindingList.ToArray());\n            Expression&lt;Func&lt;TIn, TOut&gt;&gt; lambda = Expression.Lambda&lt;Func&lt;TIn, TOut&gt;&gt;(memberInitExpression, new ParameterExpression[]\n            {\n                    parameterExpression\n            });\n            _FUNC = lambda.Compile();//拼装是一次性的\n        }\n        public static TOut Trans(TIn t)\n        {\n            return _FUNC(t);\n        }\n    }\n}\n</code></pre>\n<p>调用</p>\n<pre><code class=\"prism language-C#\">PeopleCopy peopleCopy4 = ExpressionGenericMapper&lt;People, PeopleCopy&gt;.Trans(people);\n</code></pre>\n<h3><a id=\"6_392\"></a>6、性能比较</h3>\n<p>Expression动态拼接+泛型缓存性能高，而且灵活</p>\n<pre><code class=\"prism language-C#\">long common = 0;\nlong generic = 0;\nlong cache = 0;\nlong reflection = 0;\nlong serialize = 0;\n{\n    Stopwatch watch = new Stopwatch();\n    watch.Start();\n    for (int i = 0; i &lt; 1_000_000; i++)\n    {\n        PeopleCopy peopleCopy = new PeopleCopy()\n        {\n            Id = people.Id,\n            Name = people.Name,\n            Age = people.Age\n        };\n    }\n    watch.Stop();\n    common = watch.ElapsedMilliseconds;\n}\n{\n    Stopwatch watch = new Stopwatch();\n    watch.Start();\n    for (int i = 0; i &lt; 1_000_000; i++)\n    {\n        PeopleCopy peopleCopy = ReflectionMapper.Trans&lt;People, PeopleCopy&gt;(people);\n    }\n    watch.Stop();\n    reflection = watch.ElapsedMilliseconds;\n}\n{\n    Stopwatch watch = new Stopwatch();\n    watch.Start();\n    for (int i = 0; i &lt; 1_000_000; i++)\n    {\n        PeopleCopy peopleCopy = SerializeMapper.Trans&lt;People, PeopleCopy&gt;(people);\n    }\n    watch.Stop();\n    serialize = watch.ElapsedMilliseconds;\n}\n{\n\n    Stopwatch watch = new Stopwatch();\n    watch.Start();\n    for (int i = 0; i &lt; 1_000_000; i++)\n    {\n        PeopleCopy peopleCopy = ExpressionMapper.Trans&lt;People, PeopleCopy&gt;(people);\n    }\n    watch.Stop();\n    cache = watch.ElapsedMilliseconds;\n}\n{\n    Stopwatch watch = new Stopwatch();\n    watch.Start();\n    for (int i = 0; i &lt; 1_000_000; i++)\n    {\n        PeopleCopy peopleCopy = ExpressionGenericMapper&lt;People, PeopleCopy&gt;.Trans(people);\n    }\n    watch.Stop();\n    generic = watch.ElapsedMilliseconds;\n}\n\nConsole.WriteLine($\"common = { common} ms\");\nConsole.WriteLine($\"reflection = { reflection} ms\");\nConsole.WriteLine($\"serialize = { serialize} ms\");\nConsole.WriteLine($\"cache = { cache} ms\");\nConsole.WriteLine($\"generic = { generic} ms\");\n</code></pre>\n<blockquote>\n<p>运行结果</p>\n</blockquote>\n<pre><code class=\"prism language-bash\">common <span class=\"token operator\">=</span> <span class=\"token number\">32</span> ms\nreflection <span class=\"token operator\">=</span> <span class=\"token number\">1026</span> ms\nserialize <span class=\"token operator\">=</span> <span class=\"token number\">2510</span> ms\ncache <span class=\"token operator\">=</span> <span class=\"token number\">236</span> ms\ngeneric <span class=\"token operator\">=</span> <span class=\"token number\">31</span> ms\n</code></pre>\n<h2><a id=\"ExpressionVisitorExpression_476\"></a>四、ExpressionVisitor解析Expression</h2>\n<h3><a id=\"1Expression_478\"></a>1、Expression解析</h3>\n<ul><li>Expression是通过访问者模式进行解析的，官方提供了ExpressionVisitor抽象类</li><li>ExpressionVisitor的Visit方法是解析表达式目录树的一个入口，Visit方法判断Expression是一个什么表达式目录树，走不同的细分方法进行进一步解析</li><li>ExpressionVisitor的VisitBinary方法是对二员表达式的解析，所有复杂的表达式都会拆解成二员表达式进行解析</li></ul>\n<h3><a id=\"2Expression_484\"></a>2、Expression修改</h3>\n<p>自定义一个OperationsVisitor，继承自ExpressionVisitor，复写父类的VisitBinary方法，修改Expression的解析</p>\n<blockquote>\n<p>OperationsVisitor定义</p>\n</blockquote>\n<pre><code class=\"prism language-C#\">using System.Linq.Expressions;\n\nnamespace MyExpression\n{\n    /// &lt;summary&gt;\n    /// 自定义Visitor\n    /// &lt;/summary&gt;\n    public class OperationsVisitor : ExpressionVisitor\n    {\n        /// &lt;summary&gt;\n        /// 覆写父类方法；//二元表达式的访问\n        /// 把表达式目录树中相加改成相减，相乘改成相除\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"b\"&gt;&lt;/param&gt;\n        /// &lt;returns&gt;&lt;/returns&gt;\n        protected override Expression VisitBinary(BinaryExpression b)\n        { \n            if (b.NodeType == ExpressionType.Add)//相加\n            {\n                Expression left = this.Visit(b.Left);\n                Expression right = this.Visit(b.Right);\n                return Expression.Subtract(left, right);//相减\n            }\n            else if (b.NodeType==ExpressionType.Multiply) //相乘\n            {\n                Expression left = this.Visit(b.Left);\n                Expression right = this.Visit(b.Right);\n                return Expression.Divide(left, right); //相除\n            } \n            return base.VisitBinary(b);\n        }\n    }\n}\n</code></pre>\n<blockquote>\n<p>Expression解析转换</p>\n</blockquote>\n<pre><code>Expression&lt;Func&lt;int, int, int&gt;&gt; exp = (m, n) =&gt; m * n + 2;\nConsole.WriteLine(exp.ToString());\nOperationsVisitor visitor = new OperationsVisitor();\nExpression expNew = visitor.Visit(exp);\nConsole.WriteLine(expNew.ToString());\n</code></pre>\n<blockquote>\n<p>运行结果</p>\n</blockquote>\n<pre><code class=\"prism language-bash\"><span class=\"token punctuation\">(</span>m, n<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">&gt;</span> <span class=\"token punctuation\">((</span>m * n<span class=\"token punctuation\">)</span> + <span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span>m, n<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">&gt;</span> <span class=\"token punctuation\">((</span>m / n<span class=\"token punctuation\">)</span> - <span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<h3><a id=\"3_543\"></a>3、封装多条件连接扩展方法</h3>\n<blockquote>\n<p>扩展方法实现</p>\n</blockquote>\n<pre><code class=\"prism language-C#\">/// &lt;summary&gt;\n/// 合并表达式 And Or Not扩展方法\n/// &lt;/summary&gt;\npublic static class ExpressionExtend\n{\n    /// &lt;summary&gt;\n    /// 合并表达式 expr1 AND expr2\n    /// &lt;/summary&gt;\n    /// &lt;typeparam name=\"T\"&gt;&lt;/typeparam&gt;\n    /// &lt;param name=\"expr1\"&gt;&lt;/param&gt;\n    /// &lt;param name=\"expr2\"&gt;&lt;/param&gt;\n    /// &lt;returns&gt;&lt;/returns&gt;\n    public static Expression&lt;Func&lt;T, bool&gt;&gt; And&lt;T&gt;(this Expression&lt;Func&lt;T, bool&gt;&gt; expr1, Expression&lt;Func&lt;T, bool&gt;&gt; expr2)\n    {\n        if (expr1 == null || expr2 == null)\n        {\n            throw new Exception(\"null不能处理\");\n        }\n        ParameterExpression newParameter = Expression.Parameter(typeof(T), \"x\");\n        NewExpressionVisitor visitor = new NewExpressionVisitor(newParameter);\n        Expression left = visitor.Visit(expr1.Body);\n        Expression right = visitor.Visit(expr2.Body);\n        BinaryExpression body = Expression.And(left, right);\n        return Expression.Lambda&lt;Func&lt;T, bool&gt;&gt;(body, newParameter);\n    }\n\n    /// &lt;summary&gt;\n    /// 合并表达式 expr1 or expr2\n    /// &lt;/summary&gt;\n    /// &lt;typeparam name=\"T\"&gt;&lt;/typeparam&gt;\n    /// &lt;param name=\"expr1\"&gt;&lt;/param&gt;\n    /// &lt;param name=\"expr2\"&gt;&lt;/param&gt;\n    /// &lt;returns&gt;&lt;/returns&gt;\n    public static Expression&lt;Func&lt;T, bool&gt;&gt; Or&lt;T&gt;(this Expression&lt;Func&lt;T, bool&gt;&gt; expr1, Expression&lt;Func&lt;T, bool&gt;&gt; expr2)\n    {\n        if (expr1 == null || expr2 == null)\n        {\n            throw new Exception(\"null不能处理\");\n        }\n        ParameterExpression newParameter = Expression.Parameter(typeof(T), \"x\");\n        NewExpressionVisitor visitor = new NewExpressionVisitor(newParameter);\n        Expression left = visitor.Visit(expr1.Body);\n        Expression right = visitor.Visit(expr2.Body);\n        BinaryExpression body = Expression.Or(left, right);\n        return Expression.Lambda&lt;Func&lt;T, bool&gt;&gt;(body, newParameter);\n    }\n\n    /// &lt;summary&gt;\n    /// 表达式取非\n    /// &lt;/summary&gt;\n    /// &lt;typeparam name=\"T\"&gt;&lt;/typeparam&gt;\n    /// &lt;param name=\"expr\"&gt;&lt;/param&gt;\n    /// &lt;returns&gt;&lt;/returns&gt;\n    public static Expression&lt;Func&lt;T, bool&gt;&gt; Not&lt;T&gt;(this Expression&lt;Func&lt;T, bool&gt;&gt; expr)\n    {\n        if (expr == null)\n        {\n            throw new Exception(\"null不能处理\");\n        }\n        ParameterExpression newParameter = expr.Parameters[0];\n        UnaryExpression body = Expression.Not(expr.Body);\n        return Expression.Lambda&lt;Func&lt;T, bool&gt;&gt;(body, newParameter);\n    }\n}\n</code></pre>\n<blockquote>\n<p>自定义Visitor</p>\n</blockquote>\n<pre><code class=\"prism language-C#\">internal class NewExpressionVisitor : ExpressionVisitor\n{\n    public ParameterExpression _NewParameter { get; private set; }\n    public NewExpressionVisitor(ParameterExpression param)\n    {\n        this._NewParameter = param;\n    }\n    \n    protected override Expression VisitParameter(ParameterExpression node)\n    {\n        return this._NewParameter;\n    }\n}\n</code></pre>\n<blockquote>\n<p>数据过滤方法定义</p>\n</blockquote>\n<pre><code class=\"prism language-C#\">/// &lt;summary&gt;\n/// 筛选数据执行\n/// &lt;/summary&gt;\n/// &lt;param name=\"func\"&gt;&lt;/param&gt;\nprivate static void Do(Expression&lt;Func&lt;People, bool&gt;&gt; func)\n{\n    List&lt;People&gt; people = new List&lt;People&gt;()\n    {\n        new People(){Id=4,Name=\"123\",Age=4},\n        new People(){Id=5,Name=\"234\",Age=5},\n        new People(){Id=6,Name=\"345\",Age=6},\n    };\n\n    List&lt;People&gt; peopleList = people.Where(func.Compile()).ToList();\n}\n</code></pre>\n<blockquote>\n<p>Expression拼接</p>\n</blockquote>\n<pre><code class=\"prism language-c#\">Expression&lt;Func&lt;People, bool&gt;&gt; lambda1 = x =&gt; x.Age &gt; 5;\nExpression&lt;Func&lt;People, bool&gt;&gt; lambda2 = x =&gt; x.Id &gt; 5;\nExpression&lt;Func&lt;People, bool&gt;&gt; lambda3 = lambda1.And(lambda2);//且\nExpression&lt;Func&lt;People, bool&gt;&gt; lambda4 = lambda1.Or(lambda2);//或\nExpression&lt;Func&lt;People, bool&gt;&gt; lambda5 = lambda1.Not();//非\nDo(lambda3);\nDo(lambda4);\nDo(lambda5);\n</code></pre>\n<h2><a id=\"ExpressionVisitorToSql_665\"></a>五、ExpressionVisitor应用之ToSql</h2>\n<p>需求：实现ORM框架Expression映射成sql</p>\n<blockquote>\n<p>自定义一个ConditionBuilderVisitor</p>\n</blockquote>\n<p>继承自ExpressionVisitor，复写父类的方法，Expression解析过程中实现sql的拼接</p>\n<pre><code class=\"prism language-C#\">using System;\nusing System.Collections.Generic;\nusing System.Linq.Expressions;\nusing System.Reflection;\n\nnamespace MyExpression\n{\n    public class ConditionBuilderVisitor : ExpressionVisitor\n    {\n        private Stack&lt;string&gt; _StringStack = new Stack&lt;string&gt;();\n\n        /// &lt;summary&gt;\n        /// 返回拼装好的sql条件表达式\n        /// &lt;/summary&gt;\n        /// &lt;returns&gt;&lt;/returns&gt;\n        public string Condition()\n        {\n            string condition = string.Concat(this._StringStack.ToArray());\n            this._StringStack.Clear();\n            return condition;\n        }\n\n        /// &lt;summary&gt;\n        /// 如果是二元表达式\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"node\"&gt;&lt;/param&gt;\n        /// &lt;returns&gt;&lt;/returns&gt;\n        protected override Expression VisitBinary(BinaryExpression node)\n        {\n            if (node == null) throw new ArgumentNullException(\"BinaryExpression\");\n\n            this._StringStack.Push(\")\");\n            base.Visit(node.Right);//解析右边\n            this._StringStack.Push(\" \" + ToSqlOperator(node.NodeType) + \" \");\n            base.Visit(node.Left);//解析左边\n            this._StringStack.Push(\"(\");\n\n            return node;\n        }\n\n        /// &lt;summary&gt;\n        /// 解析属性\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"node\"&gt;&lt;/param&gt;\n        /// &lt;returns&gt;&lt;/returns&gt;\n        protected override Expression VisitMember(MemberExpression node)\n        {\n            if (node == null) throw new ArgumentNullException(\"MemberExpression\");\n            if (node.Expression is ConstantExpression)\n            {\n                var value1 = this.InvokeValue(node);\n                var value2 = this.ReflectionValue(node);\n                this._StringStack.Push(\"'\" + value2 + \"'\");\n            }\n            else\n            {\n                this._StringStack.Push(\" [\" + node.Member.Name + \"] \");\n            }\n            return node;\n        }\n\n        private string ToSqlOperator(ExpressionType type)\n        {\n            switch (type)\n            {\n                case (ExpressionType.AndAlso):\n                case (ExpressionType.And):\n                    return \"AND\";\n                case (ExpressionType.OrElse):\n                case (ExpressionType.Or):\n                    return \"OR\";\n                case (ExpressionType.Not):\n                    return \"NOT\";\n                case (ExpressionType.NotEqual):\n                    return \"&lt;&gt;\";\n                case ExpressionType.GreaterThan:\n                    return \"&gt;\";\n                case ExpressionType.GreaterThanOrEqual:\n                    return \"&gt;=\";\n                case ExpressionType.LessThan:\n                    return \"&lt;\";\n                case ExpressionType.LessThanOrEqual:\n                    return \"&lt;=\";\n                case (ExpressionType.Equal):\n                    return \"=\";\n                default:\n                    throw new Exception(\"不支持该方法\");\n            }\n        }\n\n        private object InvokeValue(MemberExpression member)\n        {\n            var objExp = Expression.Convert(member, typeof(object));//struct需要\n            return Expression.Lambda&lt;Func&lt;object&gt;&gt;(objExp).Compile().Invoke();\n        }\n\n        private object ReflectionValue(MemberExpression member)\n        {\n            var obj = (member.Expression as ConstantExpression).Value;\n            return (member.Member as FieldInfo).GetValue(obj);\n        }\n\n        /// &lt;summary&gt;\n        /// 常量表达式\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"node\"&gt;&lt;/param&gt;\n        /// &lt;returns&gt;&lt;/returns&gt;\n        protected override Expression VisitConstant(ConstantExpression node)\n        {\n            if (node == null) throw new ArgumentNullException(\"ConstantExpression\");\n            this._StringStack.Push(\"\" + node.Value + \"\");\n            return node;\n        }\n        /// &lt;summary&gt;\n        /// 方法表达式\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"m\"&gt;&lt;/param&gt;\n        /// &lt;returns&gt;&lt;/returns&gt;\n        protected override Expression VisitMethodCall(MethodCallExpression m)\n        {\n            if (m == null) throw new ArgumentNullException(\"MethodCallExpression\");\n\n            string format;\n            switch (m.Method.Name)\n            {\n                case \"StartsWith\":\n                    format = \"({0} LIKE '{1}%')\";\n                    break;\n                case \"Contains\":\n                    format = \"({0} LIKE '%{1}%')\";\n                    break;\n                case \"EndsWith\":\n                    format = \"({0} LIKE '%{1}')\";\n                    break;\n                default:\n                    throw new NotSupportedException(m.NodeType + \" is not supported!\");\n            }\n            this.Visit(m.Object);\n            this.Visit(m.Arguments[0]);\n            string right = this._StringStack.Pop();\n            string left = this._StringStack.Pop();\n            this._StringStack.Push(String.Format(format, left, right));\n            return m;\n        }\n    }\n}\n</code></pre>\n<blockquote>\n<p>ConstantSqlString泛型缓存缓存生成的sql</p>\n</blockquote>\n<pre><code class=\"prism language-C#\">using System;\nusing System.Linq;\n\nnamespace MyExpression\n{\n    public class ConstantSqlString&lt;T&gt;\n    {\n        /// &lt;summary&gt;\n        /// 泛型缓存，一个类型一个缓存\n        /// &lt;/summary&gt;\n        private static string FindSql = null;\n\n        /// &lt;summary&gt;\n        /// 获取查询sql\n        /// &lt;/summary&gt;\n        static ConstantSqlString()\n        {\n            Type type = typeof(T);\n            FindSql = $\"Select {string.Join(',', type.GetProperties().Select(c =&gt; $\"[{c.Name}]\").ToList())} from {type.Name}\";\n        }\n\n        /// &lt;summary&gt;\n        /// 获取查询sql+条件筛选\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"exp\"&gt;&lt;/param&gt;\n        /// &lt;returns&gt;&lt;/returns&gt;\n        public static string GetQuerySql(string exp)\n        {\n            return $\"{FindSql} where {exp}\";\n        }\n    }\n}\n</code></pre>\n<blockquote>\n<p>普通多条件</p>\n</blockquote>\n<pre><code class=\"prism language-C#\">Expression&lt;Func&lt;People, bool&gt;&gt; lambda = x =&gt; x.Age &gt; 5\n                                             &amp;&amp; x.Id &gt; 5\n                                             &amp;&amp; x.Name.StartsWith(\"1\") //  like '1%'\n                                             &amp;&amp; x.Name.EndsWith(\"1\") //  like '%1'\n                                             &amp;&amp; x.Name.Contains(\"1\");//  like '%1%' \nConditionBuilderVisitor vistor = new ConditionBuilderVisitor();\nvistor.Visit(lambda);\nstring sql = ConstantSqlString&lt;People&gt;.GetQuerySql(vistor.Condition());\nConsole.WriteLine(sql);\n</code></pre>\n<blockquote>\n<p>外部参数变量</p>\n</blockquote>\n<pre><code class=\"prism language-C#\">string name = \"AAA\";\nExpression&lt;Func&lt;People, bool&gt;&gt; lambda = x =&gt; x.Age &gt; 5 &amp;&amp; x.Name == name || x.Id &gt; 5;\nConditionBuilderVisitor vistor = new ConditionBuilderVisitor();\nvistor.Visit(lambda);\nstring sql = ConstantSqlString&lt;People&gt;.GetQuerySql(vistor.Condition());\nConsole.WriteLine(sql);\n</code></pre>\n<blockquote>\n<p>内部常量多条件</p>\n</blockquote>\n<pre><code class=\"prism language-C#\">Expression&lt;Func&lt;People, bool&gt;&gt; lambda = x =&gt; x.Age &gt; 5 || (x.Name == \"A\" &amp;&amp; x.Id &gt; 5);\nConditionBuilderVisitor vistor = new ConditionBuilderVisitor();\nvistor.Visit(lambda);\nstring sql = ConstantSqlString&lt;People&gt;.GetQuerySql(vistor.Condition());\nConsole.WriteLine(sql);\n</code></pre>\n<blockquote>\n<p>运行结果</p>\n</blockquote>\n<pre><code class=\"prism language-bash\">Select <span class=\"token punctuation\">[</span>Age<span class=\"token punctuation\">]</span>,<span class=\"token punctuation\">[</span>Name<span class=\"token punctuation\">]</span> from People where <span class=\"token variable\"><span class=\"token punctuation\">((</span><span class=\"token punctuation\">((</span><span class=\"token punctuation\">(</span> [Age]  <span class=\"token operator\">&gt;</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span> AND <span class=\"token punctuation\">(</span> [Id]  <span class=\"token operator\">&gt;</span> <span class=\"token number\">5</span><span class=\"token punctuation\">))</span></span> AND <span class=\"token punctuation\">(</span> <span class=\"token punctuation\">[</span>Name<span class=\"token punctuation\">]</span>  LIKE <span class=\"token string\">'1%'</span><span class=\"token punctuation\">))</span> AND <span class=\"token punctuation\">(</span> <span class=\"token punctuation\">[</span>Name<span class=\"token punctuation\">]</span>  LIKE <span class=\"token string\">'%1'</span><span class=\"token punctuation\">))</span> AND <span class=\"token punctuation\">(</span> <span class=\"token punctuation\">[</span>Name<span class=\"token punctuation\">]</span>  LIKE <span class=\"token string\">'%1%'</span><span class=\"token punctuation\">))</span>\nSelect <span class=\"token punctuation\">[</span>Age<span class=\"token punctuation\">]</span>,<span class=\"token punctuation\">[</span>Name<span class=\"token punctuation\">]</span> from People where <span class=\"token variable\"><span class=\"token punctuation\">((</span><span class=\"token punctuation\">(</span> [Age]  <span class=\"token operator\">&gt;</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span> AND <span class=\"token punctuation\">(</span> [Name]  <span class=\"token operator\">=</span> 'AAA'<span class=\"token punctuation\">))</span></span> OR <span class=\"token punctuation\">(</span> <span class=\"token punctuation\">[</span>Id<span class=\"token punctuation\">]</span>  <span class=\"token operator\">&gt;</span> <span class=\"token number\">5</span><span class=\"token punctuation\">))</span>\nSelect <span class=\"token punctuation\">[</span>Age<span class=\"token punctuation\">]</span>,<span class=\"token punctuation\">[</span>Name<span class=\"token punctuation\">]</span> from People where <span class=\"token variable\"><span class=\"token punctuation\">((</span> [Age]  <span class=\"token operator\">&gt;</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span> OR <span class=\"token punctuation\">((</span> [Name]  <span class=\"token operator\">=</span> A<span class=\"token punctuation\">)</span> AND <span class=\"token punctuation\">(</span> [Id]  <span class=\"token operator\">&gt;</span> <span class=\"token number\">5</span><span class=\"token punctuation\">))</span></span><span class=\"token punctuation\">)</span>\n</code></pre>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}