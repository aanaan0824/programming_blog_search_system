{"blogid": "126681391", "writerAge": "码龄2年", "writerBlogNum": "100", "writerCollect": "119", "writerComment": "21", "writerFan": "58", "writerGrade": "4级", "writerIntegral": "1018", "writerName": "独憩", "writerProfileAdress": "writer_image\\profile_126681391.jpg", "writerRankTotal": "18492", "writerRankWeekly": "6414", "writerThumb": "43", "writerVisitNum": "55863", "blog_read_count": "163", "blog_time": "于 2022-09-04 19:32:06 发布", "blog_title": "JavaScript高级，ES6 笔记 第一天", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h1 id=\"main-toc\">垃圾回收机制</h1>\n<p><img alt=\"\" height=\"392\" src=\"image\\b5fd6120403f480490b9706acd268cac.png\" width=\"1200\"/></p>\n<p> <img alt=\"\" height=\"498\" src=\"image\\b10b6f222841491cb165d37e3219bb97.png\" width=\"1149\"/></p>\n<p> 其实最主要的主要是：</p>\n<p><strong>全局变量不会自动回收，只会在页面关闭的时候回收，所以要少使用全局变量；</strong></p>\n<p><strong>局部变量会自动回收，使用完就会自动回收了</strong></p>\n<h3>引用计数</h3>\n<p><img alt=\"\" height=\"373\" src=\"image\\72d04228d878470da9b06f212a592ae6.png\" width=\"1088\"/></p>\n<p>实时的计算内存的引用次数，当其变为0时就销毁内存</p>\n<p> 但是有缺点：嵌套引用会造成内存泄漏的问题：</p>\n<pre><code class=\"language-javascript\">    function fn(){\n        let o1 = {}\n        let o2 = {};\n        o1.a = o2;\n        o2.a = o1\n    }\n\n    fn();</code></pre>\n<p> 代码结束时，o2  o1都有被引用次数，所以使用引用计数不会销毁内存。所以现在的浏览器大多不采用这种方法。</p>\n<h3>标记清除法</h3>\n<p><img alt=\"\" height=\"508\" src=\"image\\446491d2b6434001acc2ddbdc4227134.png\" width=\"1200\"/></p>\n<h1>闭包 </h1>\n<p><img alt=\"\" height=\"150\" src=\"image\\1742955dbed8430eb278e0b0a362cecf.png\" width=\"1200\"/></p>\n<p>例如：</p>\n<pre><code class=\"language-javascript\">    function fn(){\n        let a = 1;\n        function f2(){\n            console.log(a);\n        }\n        f2()\n    }\n    fn()</code></pre>\n<p> 内层函数 f2 调用了外层函数变量 a 吗，这是最简单的写法</p>\n<p><strong>最基础的写法为：</strong></p>\n<p><strong>闭包的最大作用是外部可以访问函数内部的变量！！</strong></p>\n<pre><code class=\"language-javascript\">    function fn(){\n        let a = 1;\n        function f2(){\n            return a\n        }\n        return f2\n    }\n    let sw = fn()()\n    console.log(sw)//1</code></pre>\n<p>也就是说函数fn的返回值为f2函数，所以fn()==f2，fn()()==f2（）从而使得外部可以访问a</p>\n<p><strong>应 用：使用变量a表示函数f2被调用的次数：</strong></p>\n<pre><code class=\"language-javascript\">    function fn(){\n        let a = 0;\n        function f2(){\n            a++\n            console.log(a);\n        }\n        return f2\n    } \n    let sw = fn()\n    sw()</code></pre>\n<p>这样的好处是，a是函数内部的变量，外部不能直接修改这个值，只能通过f2得到，实现了数据私有</p>\n<h1>变量提升</h1>\n<p>这是js中的一种‘缺陷’，允许在变量声明之前被访问（存在于var）</p>\n<p>比如：</p>\n<pre><code class=\"language-javascript\">    console.log(num+'个');\n    var num = 10</code></pre>\n<p>结果为undefined个</p>\n<p>其本质为：</p>\n<pre><code class=\"language-javascript\">    var num\n    console.log(num+'个');\n    num = 10</code></pre>\n<p>把所有的var声明的变量提升到当前作用域的最前面，但是只提升声明，不提升幅值</p>\n<p>let const没有变量提升的问题</p>\n<h1>动态参数和剩余参数</h1>\n<p>需求：求不定数量的数的和：</p>\n<pre><code class=\"language-javascript\">    function add(){\n        let sum = 0;\n        for(let i = 0;i&lt;arguments.length;i++){\n            sum+=arguments[i];\n        }\n        console.log(sum);\n    }\n    add(2,3,4,5,9)</code></pre>\n<p><strong>arguments就称为动态参数</strong>，将输入看成一个数组 （伪数组，不能用pop push等操作）</p>\n<p>第二种方法：</p>\n<pre><code class=\"language-javascript\">    function add(...args){\n        let sum = 0;\n        console.log(args);\n        for(let i = 0;i&lt;args.length;i++){\n            sum+=args[i];\n        }\n        console.log(sum);\n    }\n    add(2,3,4,5,9)</code></pre>\n<p><strong>...args就为剩余参数</strong>，也是将输入看成一个数组（真数组，可以使用pop等操作） ，但是其优点在于可以提取剩余变量，例如刚刚的那个例子，我再加一个需求：最少有两个参数：</p>\n<pre><code class=\"language-javascript\">    function add(a,...args){\n        let sum = 0;\n        console.log(args);\n        for(let i = 0;i&lt;args.length;i++){\n            sum+=args[i];\n        }\n        console.log(sum);\n    }\n    add(2,3,4,5,9)</code></pre>\n<p> 这样的话，会把2给a  ，【3,4,5,9】给agrs，需要注意的是...args只能放最后。</p>\n<h1>展开运算符</h1>\n<p>作用：把数组展开：</p>\n<pre><code class=\"language-javascript\">    const arr = [2,3,4,6];\n    console.log(...arr);//2 3 4 6</code></pre>\n<p> 经典应用为，<strong>得到数组的最大值</strong>（因为数组是不能直接使用math.max的）：</p>\n<pre><code class=\"language-javascript\">    const arr = [2,3,4,6];\n    console.log(Math.max(...arr));//6</code></pre>\n<p>或者，<strong>合并数组：</strong></p>\n<pre><code class=\"language-javascript\">    const arr = [2,3,4,6];\n    console.log([3,4,...arr,99]);//[3, 4, 2, 3, 4, 6, 99]</code></pre>\n<p> </p>\n<h1> 箭头函数（重要）</h1>\n<p>主要作用是 使得代码更简洁，且改变this的指向</p>\n<p>基本形式：</p>\n<pre><code class=\"language-javascript\">    const fn = (x)=&gt;{\n        console.log(x);\n    }\n\n    fn(3)//3</code></pre>\n<p>  如果只有一个形参，可以忽略小括号：</p>\n<pre><code class=\"language-javascript\">\n    const fn = x=&gt;{\n        console.log(x);\n    }\n\n    fn(3)//3</code></pre>\n<p> 当函数只有一行代码时 可以省略大括号：</p>\n<pre><code class=\"language-javascript\">    const fn = x=&gt;console.log(x);\n\n    fn(3)//3</code></pre>\n<p>如果是一行代码 且是return，可以省略：</p>\n<pre><code class=\"language-javascript\">    const fn = x=&gt;x+x;\n    console.log(fn(3));//6</code></pre>\n<p> 箭头函数没有<strong>arguments,</strong>只有<strong>...args:</strong></p>\n<pre><code class=\"language-javascript\">    const fn = (...args)=&gt;{\n        let sum = 0;\n        for(let i = 0;i&lt;args.length;i++){\n            sum+=args[i];\n        }\n        return sum\n    }\n\n    console.log(fn(3,4,5,7));//19</code></pre>\n<h3>this指向</h3>\n<p>一般来说，this是谁调用函数 ，this指向谁</p>\n<p><strong>但是箭头函数不会创造自己的this，而是从自己作用域的上一层沿用this，这个地方this是静态的，是函数声明时所在作用域下的this值</strong></p>\n<pre><code class=\"language-javascript\">    let btn = document.querySelector('button');\n    btn.addEventListener('click',function(){\n        console.log(this);//btn\n    })\n\n    btn.addEventListener('click',()=&gt;{\n        console.log(this);//window\n    })\n</code></pre>\n<p>第一个的this 指向调用者btn </p>\n<p>第二个this 指向的是箭头函数声明时的作用域，也就是上一个作用域，既window</p>\n<p><strong>经典应用：需求是点击一个方块 一秒后背景颜色变红</strong></p>\n<pre><code class=\"language-javascript\">    let divs = document.querySelector('.box')\n\n    divs.addEventListener('click',function(){\n        setTimeout(()=&gt;{\n            this.style.backgroundColor = 'red' //这个this还是指向divs\n        },1000)\n       \n    })\n</code></pre>\n<p> 但是如果setTimeout里面的函数还是用function，那么this指向的是window，因为是window调用了setTimeout</p>\n<h1>数组解构</h1>\n<p>数组解构是将数组的单元值快速批量赋值给变量的方法</p>\n<pre><code class=\"language-javascript\">    const arr = [123,22,33]\n    const[max,min,avr] = arr;\n    console.log(max);//123</code></pre>\n<p> 应用：变量值交换</p>\n<pre><code class=\"language-javascript\">    let a  = 1;\n    let b = 2;\n    [a,b]=[b,a]\n    console.log(a);//2\n    console.log(b);//1\n</code></pre>\n<p><strong> 变量多 单元值少的情况</strong></p>\n<pre><code class=\"language-javascript\">    const[a,b,c,d] = [1,2,3]\n    console.log(a,b,c,d);//1 2 3 undefined</code></pre>\n<p> <strong> 变量少 单元值多的情况</strong></p>\n<pre><code class=\"language-javascript\">    const[a,b] = [1,2,3]\n    console.log(a,b);//1 2 </code></pre>\n<h1><strong> 对象解构</strong></h1>\n<pre><code class=\"language-javascript\">    const person = {\n        name :'aa',\n        age:17\n    }\n\n    const{name,age} = person;\n    console.log(name);//aa\n    console.log(age);//17</code></pre>\n<p> 可以改名：</p>\n<pre><code class=\"language-javascript\">    const person = {\n        name :'aa',\n        age:17\n    }\n\n    const{name:username,age} = person;\n    console.log(username);//aa\n    console.log(age);//17\n</code></pre>\n<p><strong> 多重对象解构：</strong></p>\n<pre><code class=\"language-javascript\">    const pig = {\n        name: 'aa',\n        family:{\n            mom :'bb',\n            papa:'cc',\n            sist:'dd'\n        },\n        age:18\n    }\n\n    const {name,family:{mom,papa,sist}}=pig;\n    console.log(mom);//bb</code></pre>\n<h1> 遍历数组forEach方法</h1>\n<p></p>\n<pre><code class=\"language-javascript\">    const arr = [11,22,33];\n    arr.forEach(function(item,index){\n        console.log(item);\n        console.log(index);\n    })</code></pre>\n<p>结果为：11 0 22 1 33 2</p>\n<p>item必须要写  index可以不写</p>\n<p> 贴一个小案例 可以看一下</p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n    &lt;title&gt;商品渲染&lt;/title&gt;\n    &lt;style&gt;\n        * {\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n        }\n\n        .list {\n            width: 990px;\n            margin: 0 auto;\n            display: flex;\n            flex-wrap: wrap;\n        }\n\n        .item {\n            width: 240px;\n            margin-left: 10px;\n            padding: 20px 30px;\n            transition: all .5s;\n            margin-bottom: 20px;\n        }\n\n        .item:nth-child(4n) {\n            margin-left: 0;\n        }\n\n        .item:hover {\n            box-shadow: 0px 0px 5px rgba(0, 0, 0, 0.2);\n            transform: translate3d(0, -4px, 0);\n            cursor: pointer;\n        }\n\n        .item img {\n            width: 100%;\n        }\n\n        .item .name {\n            font-size: 18px;\n            margin-bottom: 10px;\n            color: #666;\n        }\n\n        .item .price {\n            font-size: 22px;\n            color: firebrick;\n        }\n\n        .item .price::before {\n            content: \"¥\";\n            font-size: 14px;\n        }\n\n        .filter {\n            display: flex;\n            width: 990px;\n            margin: 0 auto;\n            padding: 50px 30px;\n        }\n\n        .filter a {\n            padding: 10px 20px;\n            background: #f5f5f5;\n            color: #666;\n            text-decoration: none;\n            margin-right: 20px;\n        }\n\n        .filter a:active,\n        .filter a:focus {\n            background: #05943c;\n            color: #fff;\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;div class=\"filter\"&gt;\n        &lt;a data-index=\"1\" href=\"javascript:;\"&gt;0-100元&lt;/a&gt;\n        &lt;a data-index=\"2\" href=\"javascript:;\"&gt;100-300元&lt;/a&gt;\n        &lt;a data-index=\"3\" href=\"javascript:;\"&gt;300元以上&lt;/a&gt;\n        &lt;a href=\"javascript:;\"&gt;全部区间&lt;/a&gt;\n    &lt;/div&gt;\n    &lt;div class=\"list\"&gt;\n        &lt;!-- &lt;div class=\"item\"&gt;\n      &lt;img src=\"\" alt=\"\"&gt;\n      &lt;p class=\"name\"&gt;&lt;/p&gt;\n      &lt;p class=\"price\"&gt;&lt;/p&gt;\n    &lt;/div&gt; --&gt;\n    &lt;/div&gt;\n    &lt;script&gt;\n        const goodsList = [\n            {\n                id: '4001172',\n                name: '称心如意手摇咖啡磨豆机咖啡豆研磨机',\n                price: '289.00',\n                picture: 'https://yanxuan-item.nosdn.127.net/84a59ff9c58a77032564e61f716846d6.jpg',\n            },\n            {\n                id: '4001594',\n                name: '日式黑陶功夫茶组双侧把茶具礼盒装',\n                price: '288.00',\n                picture: 'https://yanxuan-item.nosdn.127.net/3346b7b92f9563c7a7e24c7ead883f18.jpg',\n            },\n            {\n                id: '4001009',\n                name: '竹制干泡茶盘正方形沥水茶台品茶盘',\n                price: '109.00',\n                picture: 'https://yanxuan-item.nosdn.127.net/2d942d6bc94f1e230763e1a5a3b379e1.png',\n            },\n            {\n                id: '4001874',\n                name: '古法温酒汝瓷酒具套装白酒杯莲花温酒器',\n                price: '488.00',\n                picture: 'https://yanxuan-item.nosdn.127.net/44e51622800e4fceb6bee8e616da85fd.png',\n            },\n            {\n                id: '4001649',\n                name: '大师监制龙泉青瓷茶叶罐',\n                price: '139.00',\n                picture: 'https://yanxuan-item.nosdn.127.net/4356c9fc150753775fe56b465314f1eb.png',\n            },\n            {\n                id: '3997185',\n                name: '与众不同的口感汝瓷白酒杯套组1壶4杯',\n                price: '108.00',\n                picture: 'https://yanxuan-item.nosdn.127.net/8e21c794dfd3a4e8573273ddae50bce2.jpg',\n            },\n            {\n                id: '3997403',\n                name: '手工吹制更厚实白酒杯壶套装6壶6杯',\n                price: '99.00',\n                picture: 'https://yanxuan-item.nosdn.127.net/af2371a65f60bce152a61fc22745ff3f.jpg',\n            },\n            {\n                id: '3998274',\n                name: '德国百年工艺高端水晶玻璃红酒杯2支装',\n                price: '139.00',\n                picture: 'https://yanxuan-item.nosdn.127.net/8896b897b3ec6639bbd1134d66b9715c.jpg',\n            },\n        ]\n\n        \n\n\n        let list = document.querySelector('.list');\n\n        function get(arr) {\n            let str = ``\n            arr.forEach((item, index) =&gt; {\n                let { id, name, price, picture } = item;\n                str += `&lt;div class=\"item\" id=${id}&gt;\n      &lt;img src=${picture} alt=\"\"&gt;\n      &lt;p class=\"name\"&gt;${name}&lt;/p&gt;\n      &lt;p class=\"price\"&gt;${price}&lt;/p&gt;\n    &lt;/div&gt;`\n            });\n            list.innerHTML = str;\n        }\n\n        get(goodsList)\n\n        let filter = document.querySelector('.filter').querySelectorAll('a');\n        for(let i=0;i&lt;filter.length;i++){\n            filter[i].addEventListener('click',function(){\n               \n                \n                if(this.getAttribute('data-index')==1){\n                    arr = goodsList.filter(item =&gt; item.price &gt; 0 &amp;&amp; item.price &lt;= 100)\n                }\n                else if(this.getAttribute('data-index')==2){\n                    arr = goodsList.filter(item =&gt; item.price &gt; 100 &amp;&amp; item.price &lt;= 300)\n\n                }\n                else if(this.getAttribute('data-index')==3){\n                    arr = goodsList.filter(item =&gt; item.price &gt; 300)\n\n                }\n                else{\n                    arr = goodsList;\n                }\n                get(arr)\n                \n            })\n        }\n\n\n\n\n\n    &lt;/script&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;</code></pre>\n<p> </p>\n<h1 id=\"%E5%88%9B%E5%BB%BA%E7%B1%BB\">创建类</h1>\n<p>需要使用constructor函数来声明参数</p>\n<pre><code class=\"language-javascript\">    class fa{\n        constructor(x,y){\n            this.x = x;\n            this.y = y;\n        }\n        sum(){\n            console.log(this.x+this.y);\n        }\n    }\n\n\nlet a = new fa()</code></pre>\n<h1 id=\"%E5%AD%90%E7%B1%BB%E7%BB%A7%E6%89%BF%EF%BC%9A\">子类继承：</h1>\n<p>利用extends</p>\n<pre><code class=\"language-javascript\">    class fa{\n        constructor(x,y){\n            this.x = x;\n            this.y = y;\n        }\n        sum(){\n            console.log('hhhh');\n        }\n    }\n\n\n    class son extends fa{}\n    let b = new son()\n    b.sum()//hhhh</code></pre>\n<h1 id=\"super%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E5%87%BD%E6%95%B0\">super调用父类函数</h1>\n<p>如果想将子类的参数传到父类并调用父类的函数，需要使用super方法，主要就是可以将子类的参数传给父类</p>\n<pre><code class=\"language-javascript\">    class fa{\n        constructor(x,y){\n            this.x = x;\n            this.y = y;\n        }\n        sum(){\n            console.log(this.x + this.y);;\n        }\n    }\n\n    class son extends fa{\n        constructor(x,y){\n            super(x,y)\n\n        }\n\n    }\n\n\n\n    let a = new son(7,4)\n    a.sum()//11\n</code></pre>\n<p>如果子类本身也有参数和函数，也可以声明super，但是需要注意的是，<strong>super必须在this之前</strong></p>\n<pre><code class=\"language-javascript\">    class fa{\n        constructor(x,y){\n            this.x = x;\n            this.y = y;\n        }\n        sum(){\n            console.log(this.x + this.y);\n        }\n    }\n\n    class son extends fa{\n        constructor(x,y){\n            super(x,y)\n            this.x = x;\n            this.y = y;\n        }\n        jian(){\n            console.log(this.x - this.y);\n        }\n    }\n\n    let a = new son(7,4)\n    a.jian()//3\n    a.sum()//11</code></pre>\n<p></p>\n</div>\n</div>"}