{"blogid": "124953693", "writerAge": "码龄1年", "writerBlogNum": "1", "writerCollect": "3", "writerComment": "0", "writerFan": "1", "writerGrade": "1级", "writerIntegral": "12", "writerName": "第六天945", "writerProfileAdress": "writer_image\\profile_124953693.jpg", "writerRankTotal": "230397", "writerRankWeekly": "1255212", "writerThumb": "2", "writerVisitNum": "1514", "blog_read_count": "1514", "blog_time": "于 2022-05-24 23:29:37 发布", "blog_title": "C#泛型约束", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>泛型约束一共有六种:</p>\n<p>约束的是字母T,程序中调用的T是什么类型,就要用什么样的类型</p>\n<p>1.值类型,where 泛型字母:struct;</p>\n<pre><code class=\"language-cs\">Class Test1&lt;T&gt; where T:struct\n{\n    public T value;\n    \n    public void TestFun&lt;K&gt;(K v) where K:struct\n    {\n        \n    }\n}</code></pre>\n<p>以上是定义了值类型为struct的类,里面有变量和方法</p>\n<p>如果在主函数中声明为</p>\n<p>Test1&lt;Object&gt; t=new Test1&lt;Object&gt;();<br/> Vs会报错</p>\n<p>为何会报错?转到定义可知</p>\n<p>Objcet是引用类型</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\26829f91ac2549cc84e5376d4c648608.jpeg\"/></p>\n<p></p>\n<p style=\"text-align:center;\">换成Test1&lt;int&gt; t=new Test1&lt;int&gt;();</p>\n<p style=\"text-align:center;\">//无报错<br/> //再举例Test1中的函数<br/> t.TestFun&lt;Random&gt;(new Random());<br/> //会报错</p>\n<p style=\"text-align:center;\">因为Random也是引用类型</p>\n<p><img alt=\"\" src=\"image\\2df31453aaa5438b88d6c277a68a070d.jpeg\"/></p>\n<p> 改为t.TestFun&lt;float&gt;(1.4f);</p>\n<p>转到速览定义float可知,float是结构体</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\9d68237c8845493aa3f720088157e71a.jpeg\"/></p>\n<p>2.引用类型,where 泛型字母 class</p>\n<p><span style=\"color:#fe2c24;\"><u>值类型声明的Object和Random在引用类型不会报错,因为约束的字母T就是要用引用类型填入</u></span></p>\n<p>3.存在无参公共构造函数,where 泛型字母:new()</p>\n<p>举例来说 还是定义一个Test类 类中也有变量和函数 此外 再声明两个类 一个有默认构造函数 一个自定义了一个构造函数</p>\n<pre><code>Class Test&lt;T&gt; where T:new ()\n{\n    public T value;\n\n    public void TestFun&lt;K&gt;(K k) where K:new ()\n    {\n    \n    }\n}\nClass Test1\n{\n}\nClass Test2\n{\n    public Test2(int a){}\n}\n</code></pre>\n<p>回到主函数</p>\n<p>Test&lt;Test1&gt; t=new Test&lt;Test1&gt;();//不会报错 test1默认有无参构造函数</p>\n<p>但是 要是将test1换为test2 则会报错 因为test2中的无参构造函数被顶掉了</p>\n<p>当然 要是test1将自己的无参构造函数设置为private 注意这种类型约束说的是无参公共构造函数 将test1中的无参构造函数的访问级别设置为private 则程序会报错</p>\n<p>题外话:结构体中即使写了有参构造 无参构造并不会被顶掉 所以将test1换成struct类型的结构体 不会报错</p>\n<p>那么,抽象类呢?要清楚 抽象类是不能new的 既然不能new 那么Test&lt;Test1&gt; t=new Test&lt;Test1&gt;();会报错</p>\n<p>4某个类本身或者其派生类,where 泛型字母:类名</p>\n<pre><code>class Test&lt;T&gt; where T:Test1\n{\n    public T value;\n    public void TestFun&lt;K&gt;(K v) where T:Test1{};\n}\nclass test1{}\nclass test2:test1{}</code></pre>\n<p>回到主函数声明一个类</p>\n<p>Test&lt;test1&gt;() t=new Test&lt;test1&gt;();//无报错</p>\n<p>Test&lt;test2&gt;() t=new Test&lt;test2&gt;();无报错 test2是test1的派生类</p>\n<p>问号:如果是Object类呢?不可以 Object是所有类的父类 也就是说Object是test1的父类 test1的子类和它本身可以填入 但是语法未规定test1的父类也可以填入</p>\n<p>5.某个接口的派生类型,where 泛型字母:接口名</p>\n<p>接口和4一样 </p>\n<pre><code>class test1:Ifly{}\nc;ass test&lt;T&gt; where T :Ifly\n{\n    public T value;\n    public void TestFun&lt;K&gt;(K k) where T:Ifly{}\n}\n//Main函数\ntest&lt;test1&gt;() t=new test&lt;test1&gt;();\ntest1继承Ifly接口 所以未报错\n</code></pre>\n<p>6.另一个泛型类型本身或派生类型.where 泛型字母:另一个泛型字母</p>\n<pre><code>class test&lt;T,U&gt; where T:U\n{\n    public T value;\n    public void TestFun&lt;K,V&gt;(K k) where T:V{};\n}\n解析:要不U是T本身 要不T是U的派生类\n</code></pre>\n<p>7.问题:以上泛型约束是否可以组合使用</p>\n<p>回答是肯定的.</p>\n<pre><code>class test&lt;T&gt; where T:class,new(){}//这个组合可以</code></pre>\n<pre><code>class test&lt;T&gt; where T:struct,new(){}//报错 \nstruct有公共的无参默认构造函数 再写new()就画蛇添足了\n简而言之 泛型约束之间进行组合使用 无明确规则 语法和实际使用时不冲突就行</code></pre>\n<p>8.如果有多个需要约束的泛型呢?</p>\n<p>举个例子就清楚了</p>\n<pre><code>class test&lt;T,K&gt; where T:class,new() \n                where K:class,new()\n{}</code></pre>\n<p>写完第一个约束 接着写第二个泛型约束就行</p>\n<p>趁热打铁:在泛型六种约束的基础上 写一个单例模式基类</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\f6cf03ed6ea94b06bfd68c8687b864aa.jpeg\"/></p>\n<p> </p>\n</div>\n</div>"}