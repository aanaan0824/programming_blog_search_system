{"blogid": "125987314", "writerAge": "码龄10年", "writerBlogNum": "69", "writerCollect": "477", "writerComment": "838", "writerFan": "713", "writerGrade": "5级", "writerIntegral": "2582", "writerName": "玲娜贝儿~", "writerProfileAdress": "writer_image\\profile_125987314.jpg", "writerRankTotal": "7672", "writerRankWeekly": "348", "writerThumb": "595", "writerVisitNum": "46407", "blog_read_count": "1626", "blog_time": "已于 2022-08-09 19:45:52 修改", "blog_title": "【C++】-- 多态", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E4%B8%80%E3%80%81%E5%A4%9A%E6%80%81%E5%AE%9A%E4%B9%89-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%80%E3%80%81%E5%A4%9A%E6%80%81%E5%AE%9A%E4%B9%89\">一、多态定义</a></p>\n<p id=\"1.%E9%9D%99%E6%80%81%E5%A4%9A%E6%80%81-toc\" style=\"margin-left:40px;\"><a href=\"#1.%E9%9D%99%E6%80%81%E5%A4%9A%E6%80%81\">1.静态多态</a></p>\n<p id=\"2.%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81-toc\" style=\"margin-left:40px;\"><a href=\"#2.%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81\">2.动态多态</a></p>\n<p id=\"%EF%BC%881%EF%BC%89%E8%99%9A%E5%87%BD%E6%95%B0%C2%A0-toc\" style=\"margin-left:80px;\"><a href=\"#%EF%BC%881%EF%BC%89%E8%99%9A%E5%87%BD%E6%95%B0%C2%A0\">（1）虚函数 </a></p>\n<p id=\"%EF%BC%882%EF%BC%89%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E9%87%8D%E5%86%99%C2%A0-toc\" style=\"margin-left:80px;\"><a href=\"#%EF%BC%882%EF%BC%89%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E9%87%8D%E5%86%99%C2%A0\">（2）虚函数的重写 </a></p>\n<p id=\"%EF%BC%883%EF%BC%89%E8%99%9A%E5%87%BD%E6%95%B0%E9%87%8D%E5%86%99%E7%9A%84%E4%B8%A4%E4%B8%AA%E4%BE%8B%E5%A4%96-toc\" style=\"margin-left:80px;\"><a href=\"#%EF%BC%883%EF%BC%89%E8%99%9A%E5%87%BD%E6%95%B0%E9%87%8D%E5%86%99%E7%9A%84%E4%B8%A4%E4%B8%AA%E4%BE%8B%E5%A4%96\">（3）虚函数重写的两个例外</a></p>\n<p id=\"%EF%BC%884%EF%BC%89C%2B%2B11%E7%9A%84final%E5%92%8Coverride-toc\" style=\"margin-left:80px;\"><a href=\"#%EF%BC%884%EF%BC%89C%2B%2B11%E7%9A%84final%E5%92%8Coverride\">（4）C++11的final和override</a></p>\n<p id=\"%EF%BC%885%EF%BC%89%E9%87%8D%E8%BD%BD%E3%80%81%E9%87%8D%E5%86%99%E4%B8%8E%E9%9A%90%E8%97%8F-toc\" style=\"margin-left:80px;\"><a href=\"#%EF%BC%885%EF%BC%89%E9%87%8D%E8%BD%BD%E3%80%81%E9%87%8D%E5%86%99%E4%B8%8E%E9%9A%90%E8%97%8F\">（5）重载、重写与隐藏</a></p>\n<p id=\"%C2%A0%E4%BA%8C%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB-toc\" style=\"margin-left:0px;\"><a href=\"#%C2%A0%E4%BA%8C%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB\"> 二、抽象类</a></p>\n<p id=\"1.%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:40px;\"><a href=\"#1.%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0\">1.纯虚函数</a></p>\n<p id=\"%EF%BC%881%EF%BC%89%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:80px;\"><a href=\"#%EF%BC%881%EF%BC%89%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0\">（1）纯虚函数</a></p>\n<p id=\"%EF%BC%882%EF%BC%89%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%88%E6%8E%A5%E5%8F%A3%E7%B1%BB%EF%BC%89%EF%BC%9A-toc\" style=\"margin-left:80px;\"><a href=\"#%EF%BC%882%EF%BC%89%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%88%E6%8E%A5%E5%8F%A3%E7%B1%BB%EF%BC%89%EF%BC%9A\">（2）抽象类（接口类）：</a></p>\n<p id=\"2.%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#2.%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%C2%A0\">2.接口继承和实现继承 </a></p>\n<p id=\"%C2%A0%EF%BC%881%EF%BC%89%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A0%EF%BC%881%EF%BC%89%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF\">（1）实现继承</a></p>\n<p id=\"%EF%BC%882%EF%BC%89%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%C2%A0-toc\" style=\"margin-left:80px;\"><a href=\"#%EF%BC%882%EF%BC%89%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%C2%A0\">（2）接口继承 </a></p>\n<p id=\"%E4%B8%89%E3%80%81%E5%A4%9A%E6%80%81%E5%8E%9F%E7%90%86-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%89%E3%80%81%E5%A4%9A%E6%80%81%E5%8E%9F%E7%90%86\">三、多态原理</a></p>\n<p id=\"1.%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8-toc\" style=\"margin-left:40px;\"><a href=\"#1.%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8\">1.虚函数表</a></p>\n<p id=\"2.%E5%8E%9F%E7%90%86-toc\" style=\"margin-left:40px;\"><a href=\"#2.%E5%8E%9F%E7%90%86\">2.原理</a></p>\n<p id=\"%EF%BC%881%EF%BC%89%E6%9E%84%E6%88%90%E5%A4%9A%E6%80%81%C2%A0-toc\" style=\"margin-left:80px;\"><a href=\"#%EF%BC%881%EF%BC%89%E6%9E%84%E6%88%90%E5%A4%9A%E6%80%81%C2%A0\">（1）构成多态 </a></p>\n<p id=\"%E2%80%8B%E7%BC%96%E8%BE%91-toc\" style=\"margin-left:80px;\"><a href=\"#%E2%80%8B%E7%BC%96%E8%BE%91\">​编辑</a></p>\n<p id=\"%C2%A0%EF%BC%882%EF%BC%89%E4%B8%8D%E6%9E%84%E6%88%90%E5%A4%9A%E6%80%81-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A0%EF%BC%882%EF%BC%89%E4%B8%8D%E6%9E%84%E6%88%90%E5%A4%9A%E6%80%81\">（2）不构成多态</a></p>\n<p id=\"%EF%BC%883%EF%BC%89%E6%B1%87%E7%BC%96%E5%B1%82%E9%9D%A2%E7%9C%8B%E5%A4%9A%E6%80%81-toc\" style=\"margin-left:80px;\"><a href=\"#%EF%BC%883%EF%BC%89%E6%B1%87%E7%BC%96%E5%B1%82%E9%9D%A2%E7%9C%8B%E5%A4%9A%E6%80%81\">（3）汇编层面看多态</a></p>\n<p id=\"%E5%9B%9B%E3%80%81%E5%8D%95%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%9B%9B%E3%80%81%E5%8D%95%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8\">四、单继承和多继承关系的虚函数表</a></p>\n<p id=\"1.%E5%8D%95%E7%BB%A7%E6%89%BF%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8-toc\" style=\"margin-left:40px;\"><a href=\"#1.%E5%8D%95%E7%BB%A7%E6%89%BF%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8\">1.单继承的虚函数表</a></p>\n<p id=\"%EF%BC%881%EF%BC%89%E8%99%9A%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E6%97%B6%E6%9C%BA-toc\" style=\"margin-left:80px;\"><a href=\"#%EF%BC%881%EF%BC%89%E8%99%9A%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E6%97%B6%E6%9C%BA\">（1）虚表初始化的时机</a></p>\n<p id=\"%EF%BC%882%EF%BC%89%E5%AD%90%E7%B1%BB%E8%99%9A%E8%A1%A8%E7%9A%84%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B-toc\" style=\"margin-left:80px;\"><a href=\"#%EF%BC%882%EF%BC%89%E5%AD%90%E7%B1%BB%E8%99%9A%E8%A1%A8%E7%9A%84%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B\">（2）子类虚表的生成过程</a></p>\n<p id=\"2.%E5%A4%9A%E7%BB%A7%E6%89%BF%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#2.%E5%A4%9A%E7%BB%A7%E6%89%BF%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%C2%A0\">2.多继承的虚函数表 </a></p>\n<p id=\"%E4%BA%94%E3%80%81%E5%A4%9A%E6%80%81%E9%9D%A2%E8%AF%95%E9%A2%98-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BA%94%E3%80%81%E5%A4%9A%E6%80%81%E9%9D%A2%E8%AF%95%E9%A2%98\">五、多态面试题</a></p>\n<p id=\"1.%E9%80%89%E6%8B%A9%E9%A2%98%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#1.%E9%80%89%E6%8B%A9%E9%A2%98%C2%A0\">1.选择题 </a></p>\n<p id=\"2.%E9%97%AE%E7%AD%94%E9%A2%98%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#2.%E9%97%AE%E7%AD%94%E9%A2%98%C2%A0\">2.问答题 </a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h1 id=\"%E4%B8%80%E3%80%81%E5%A4%9A%E6%80%81%E5%AE%9A%E4%B9%89\"><span style=\"color:#956fe7;\">一、多态定义</span></h1>\n<p> 多态是函数调用的多种形态，使我们调用函数更加灵活。多态分为两种：静态多态和动态多态</p>\n<h2 id=\"1.%E9%9D%99%E6%80%81%E5%A4%9A%E6%80%81\"><span style=\"color:#956fe7;\">1.静态多态</span></h2>\n<p>静态多态即函数重载，这里的静态是指编译时:</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\nusing namespace std;\n\nvoid Swap(int&amp; s1, int&amp; s2)\n{\n\tint temp = s1;\n\ts1 = s2;\n\ts2 = temp;\n}\n\nvoid Swap(float&amp; s1, float&amp; s2)\n{\n\tfloat temp = s1;\n\ts1 = s2;\n\ts2 = temp;\n}\n\nvoid Swap(char&amp; s1, char&amp; s2)\n{\n\tchar temp = s1;\n\ts1 = s2;\n\ts2 = temp;\n}\n\nint main()\n{\n\tint a = 1, b = 2;\n\tfloat c = 3.0, d = 4.0;\n\tchar e = 'z', f = 'Z';\n\n\tSwap(a, b);\n\tSwap(c, d);\n\tSwap(e, f);\n\n\treturn 0;\n}</code></pre>\n<p>看起来我们用的是一个函数，实际上这就是静态多态 </p>\n<h2 id=\"2.%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81\"><span style=\"color:#956fe7;\">2.动态多态</span></h2>\n<p>动态多态是指不同类型对象完成一件事的时候产生的动作不一样，那么结果也不一样。 </p>\n<p style=\"margin-left:0;text-align:justify;\">在继承中要构成多态有两个条件，缺一不可：</p>\n<p style=\"margin-left:0;text-align:justify;\">（1）必须通过父类的指针或者引用调用虚函数</p>\n<p style=\"margin-left:0;text-align:justify;\">（2）被调用的函数必须是虚函数，且子类必须对父类的虚函数进行重写</p>\n<p style=\"margin-left:0;text-align:justify;\"></p>\n<p style=\"margin-left:0;text-align:justify;\">动态多态父类指针或引用的指向：</p>\n<p>（1）父类指针或引用指向父类，调用的就是父类虚函数</p>\n<p>（2）父类指针或引用指向哪个子类，调用的就是哪个子类重写的虚函数</p>\n<p>根据切片规则，父类的指针既可以指向父类，又可以指向子类，如果有多个子类，就可以指向不同类型。 </p>\n<h3 id=\"%EF%BC%881%EF%BC%89%E8%99%9A%E5%87%BD%E6%95%B0%C2%A0\"><span style=\"color:#956fe7;\">（1）虚函数 </span></h3>\n<p>被virtual修饰的成员函数叫做虚函数。</p>\n<p><strong>注意：</strong></p>\n<p>（1）只有类的非静态成员函数才可以被 virtual修饰，普通函数不可以。</p>\n<p>（2）虽然虚函数的virtual和虚继承中的virtual是同一个关键字，但是它们之间没有关系。虚函数的vitual是为了实现多态，虚继承中的virtual是为了解决菱形继承的数据冗余和二义性。</p>\n<h3 id=\"%EF%BC%882%EF%BC%89%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E9%87%8D%E5%86%99%C2%A0\"><span style=\"color:#956fe7;\">（2）虚函数的重写</span> </h3>\n<p> 虚函数重写也叫做覆盖，在子类中重写了一个和父类中的虚函数完全相同的虚函数：包括函数名、返回值、参数列表都相同，这时候子类就重写了父类的虚函数。</p>\n<p><strong>注意：</strong></p>\n<p>子类重写的虚函数的函数名、返回值、参数列表和父类一定要完全相同，否则就变成了函数重载，和继承无关。</p>\n<p>如下，Bird类和Dog类就重写了父类的虚函数：</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\nusing namespace std;\n\nclass Animal\n{\npublic:\n\tvirtual void Speak()//父类虚函数\n\t{\n\t\tcout &lt;&lt; \"speak\" &lt;&lt; endl;\n\t}\n};\n\nclass Bird:public Animal\n{\npublic:\n\tvirtual void Speak()//子类重写父类虚函数\n\t{\n\t\tcout &lt;&lt; \"chirp\" &lt;&lt; endl;\n\t}\n};\n\nclass Dog :public Animal\n{\npublic:\n\tvirtual void Speak()//子类重写父类虚函数\n\t{\n\t\tcout &lt;&lt; \"bark\" &lt;&lt; endl;\n\t}\n};\n\n//父类对象:会破坏多态条件，不构成多态\nvoid fun(Animal a)\n{\n\t//传不同类型的对象，调用的是不同的函数，实现了调用的多种形态\n\ta.Speak();\n}\n\n//父类引用-构成多态\nvoid fun1(Animal&amp; a)\n{\n\t//传不同类型的对象，调用的是不同的函数，实现了调用的多种形态\n\ta.Speak();\n}\n\n//父类指针-构成多态\nvoid fun2(Animal* pa)\n{\n\t//传不同类型的对象，调用的是不同的函数，实现了调用的多种形态\n\tpa-&gt;Speak();\n}\n\nint main()\n{\n\tAnimal a;\n\tBird b;\n\tDog d;\n\n\tAnimal *pa = &amp;a;\n\tBird *pb = &amp;b;\n\tDog *pd = &amp;d;\n\n\tfun(a);\n\tfun(b);\n\tfun(d);\n\tcout &lt;&lt; endl;\n\n\tfun1(a);\n\tfun1(b);\n\tfun1(d);\n\tcout &lt;&lt; endl;\n\n\tfun2(pa);\n\tfun2(pb);\n\tfun2(pd);\n\n\treturn 0;\n}\n\n</code></pre>\n<p> 当父类对象调用虚函数时，不构成多态，当父类引用或指针调用虚函数时，构成多态：<img alt=\"\" height=\"332\" src=\"image\\5ba8399f5ce1441887ff1d689fb45033.png\" width=\"809\"/></p>\n<p> 如果去掉父类的虚函数关键字virtual，子类就没有重写父类的虚函数，那么就算传父类指针或父类引用也不会构成多态：</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\nusing namespace std;\n\nclass Animal\n{\npublic:\n\tvoid Speak()//父类普通函数\n\t{\n\t\tcout &lt;&lt; \"speak\" &lt;&lt; endl;\n\t}\n};\n\nclass Bird:public Animal\n{\npublic:\n\tvoid Speak()//子类普通函数\n\t{\n\t\tcout &lt;&lt; \"chirp\" &lt;&lt; endl;\n\t}\n};\n\nclass Dog :public Animal\n{\npublic:\n\tvoid Speak()//子类普通函数\n\t{\n\t\tcout &lt;&lt; \"bark\" &lt;&lt; endl;\n\t}\n};\n\n//父类对象:会破坏多态条件，不构成多态\nvoid fun(Animal a)\n{\n\t//传不同类型的对象，调用的是不同的函数，实现了调用的多种形态\n\ta.Speak();\n}\n\n//父类引用-构成多态\nvoid fun1(Animal&amp; a)\n{\n\t//传不同类型的对象，调用的是不同的函数，实现了调用的多种形态\n\ta.Speak();\n}\n\n//父类指针-构成多态\nvoid fun2(Animal* pa)\n{\n\t//传不同类型的对象，调用的是不同的函数，实现了调用的多种形态\n\tpa-&gt;Speak();\n}\n\nint main()\n{\n\tAnimal a;\n\tBird b;\n\tDog d;\n\n\tAnimal *pa = &amp;a;\n\tBird *pb = &amp;b;\n\tDog *pd = &amp;d;\n\n\tfun(a);\n\tfun(b);\n\tfun(d);\n\tcout &lt;&lt; endl;\n\n\tfun1(a);\n\tfun1(b);\n\tfun1(d);\n\tcout &lt;&lt; endl;\n\n\tfun2(pa);\n\tfun2(pb);\n\tfun2(pd);\n\n\treturn 0;\n}</code></pre>\n<p> 不构成多态：</p>\n<p><img alt=\"\" height=\"328\" src=\"image\\b33fe924abf24e4995229513898d339a.png\" width=\"782\"/></p>\n<p></p>\n<h3 id=\"%EF%BC%883%EF%BC%89%E8%99%9A%E5%87%BD%E6%95%B0%E9%87%8D%E5%86%99%E7%9A%84%E4%B8%A4%E4%B8%AA%E4%BE%8B%E5%A4%96\"><span style=\"color:#956fe7;\">（3）虚函数重写的两个例外</span></h3>\n<p>① 协变（返回值类型是父子关系）</p>\n<p style=\"margin-left:0;text-align:justify;\">子类重写父类虚函数时，与父类虚函数返回值类型不同。即父类虚函数返回父类对象的指针或者引用，子类虚函数返回子类对象的指针或者引用时，称为协变。</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\nusing namespace std;\n\nclass Animal\n{\npublic:\n\tvirtual Animal* Speak()//父类虚函数\n\t{\n\t\tcout &lt;&lt; \"Animal* Animal::Speak()\" &lt;&lt; endl;\n\t\treturn new Animal;//返回父类指针\n\t}\n};\n\nclass Bird :public Animal\n{\npublic:\n\tvirtual Bird* Speak()//子类重写父类虚函数\n\t{\n\t\tcout &lt;&lt; \"Bird* Bird::Speak()\" &lt;&lt; endl;\n\t\treturn new Bird;//返回子类指针\n\t}\n};\n\nint main()\n{\n\tAnimal a;\n\tBird b;\n\n\tAnimal* pa = &amp;a;\n\tpa-&gt;Speak();\n\t\n\tBird* pb = &amp;b;\n\tpb-&gt;Speak();\n\n\treturn 0;\n}\n\n</code></pre>\n<p>父类返回父类指针，子类返回子类指针：</p>\n<p><img alt=\"\" height=\"167\" src=\"image\\4f99d5def5d240d7af7b65425e6c2229.png\" width=\"861\"/></p>\n<p>所以虚函数重写后的返回值不一定相同 ，因为有协变的存在。</p>\n<p> ②析构函数的重写(子类与父类析构函数的名字不同)</p>\n<p style=\"margin-left:0;text-align:justify;\">如果父类的析构函数为虚函数，此时子类析构函数只要定义，无论是否加virtual关键字，都与父类的析构函数构成重写，虽然父类与子类析构函数名字不同。虽然函数名不相同，看起来违背了重写的规则，其实不然，这里可以理解为编译器对析构函数的名称做了特殊处理，编译后析构函数的名称统一处理成destructor。可参考<a href=\"https://blog.csdn.net/gx714433461/article/details/125731105?spm=1001.2014.3001.5501\" title=\"【C++】-- 继承\">【C++】-- 继承</a>第四节的第4小节。</p>\n<p style=\"margin-left:0;text-align:justify;\">把父类析构函数定义为虚函数，子类就可以重写父类的虚函数：</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\nusing namespace std;\n\nclass Animal\n{\npublic:\n\tvirtual ~Animal()\n\t{\n\t\tcout &lt;&lt; \"~Animal()\" &lt;&lt; endl;\n\t}\n};\n\nclass Bird :public Animal\n{\npublic:\n\tvirtual ~Bird()//Bird类和Animal类的析构函数名看起来不同，但是他们构成虚构函数重写\n\t{\n\t\tcout &lt;&lt; \"~Bird()\" &lt;&lt; endl;\n\t}\n};\n\nint main()\n{\n\tAnimal a;\n\tBird b;\n\n\treturn 0;\n}</code></pre>\n<p>由于析构时，子类对象先调用自己的析构函数进行清理，清理完后再自动调用父类的析构函数，所以打印的前两行是Bird类对象调用的析构函数，第3行调用的是Animal类对象的析构函数。<img alt=\"\" height=\"179\" src=\"image\\815f7a5a0d8d438695561aac87fa2731.png\" width=\"782\"/></p>\n<p>但是发现把</p>\n<pre><code class=\"language-cpp\">    virtual ~Animal()</code></pre>\n<p>和</p>\n<pre><code class=\"language-cpp\">    virtual ~Bird()</code></pre>\n<p>中的virtual都去掉，运行结果还是一样。说明在普通场景下，父类和子类的析构函数是否是虚函数，是否构成重写，没什么影响。</p>\n<p>那在什么场景下才有影响呢？</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\nusing namespace std;\n\nclass Animal\n{\npublic:\n\t~Animal()\n\t{\n\t\tcout &lt;&lt; \"~Animal()\" &lt;&lt; endl;\n\t}\n};\n\nclass Bird :public Animal\n{\npublic:\n\t~Bird()//Bird类和Animal类的析构函数名看起来不同，但是他们构成虚构函数重写\n\t{\n\t\tcout &lt;&lt; \"~Bird()\" &lt;&lt; endl;\n\t}\n};\n\nint main()\n{\n\tAnimal* pa = new Animal;\n\tAnimal* pb = new Bird;\n\n\t//多态行为\n\tdelete pa;//pa-&gt;析构函数() + operator delete(pa)\n\tdelete pb;//pb-&gt;析构函数() + operator delete(pb)\n\n\treturn 0;\n}</code></pre>\n<p>delete在释放空间的同时要调用析构函数，需要做两步操作：</p>\n<p>（1）先调用析构函数</p>\n<p>（2）再释放空间</p>\n<p>pa和pb的空间都会被释放，pa指向父类对象，期望调用父类的析构函数，pb指向子类对象，期望调用子类的析构函数，指向父类调父类，指向子类调子类，期望这里达到多态行为，虽然没有明显的函数调用，但是delete操作调了析构函数。</p>\n<p>pb指向子类对象，但是发现没有调用子类析构函数，可能存在内存泄漏：</p>\n<p><img alt=\"\" height=\"159\" src=\"image\\d3f3fcc1d53c47c1a0d08bd78ee4d697.png\" width=\"787\"/></p>\n<p>当子类析构函数不需要清理资源时也就没什么问题，但是当子类析构函数需要清理时，这样做会存在内存泄漏 。因此多态场景下子类和父类的析构函数最好加上virtual关键字完成虚函数重写就不会导致内存泄漏了。所以上面的代码最好不要删掉析构函数前面的virtual。</p>\n<p>另外在继承一文中，说过子类和父类的析构函数构成隐藏。原因就是表面上子类的析构函数个父类的析构函数名不同，但是为了构成重写，编译器会对析构函数名调用时，统一将父类和子类的析构函数名改成destructor( )。统一改成destructor( )构成隐藏的目的就是在这里能够调用同一个函数，达到多态指向父类对象就调父类对象，指向子类对象就调子类对象的的目的。</p>\n<p>因此，父类函数中的virtual不能省，否则子类继承不了父类的virtual属性，无法重写父类的虚函数，如果这个函数是析构函数，那么还会造成内存泄漏。为了保持统一，父类和子类虚函数前面的virtual都不要省。</p>\n<h3 id=\"%EF%BC%884%EF%BC%89C%2B%2B11%E7%9A%84final%E5%92%8Coverride\"><span style=\"color:#956fe7;\">（4）C++11的final和override</span></h3>\n<p>①final：如果一个虚函数不想被重写，可以在虚函数后面加final</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\nusing namespace std;\n\nclass Animal\n{\npublic:\n\tvirtual ~Animal() final//虚函数不想被重写\n\t{\n\t\tcout &lt;&lt; \"~Animal()\" &lt;&lt; endl;\n\t}\n};\n\nclass Bird :public Animal\n{\npublic:\n\tvirtual ~Bird()\n\t{\n\t\tcout &lt;&lt; \"~Bird()\" &lt;&lt; endl;\n\t}\n};\n</code></pre>\n<p> 一旦重写final修饰的虚函数，就会报错：</p>\n<p><img alt=\"\" height=\"256\" src=\"image\\d9637f45fd36414d92607eb0c2f28d20.png\" width=\"1174\"/></p>\n<p>如果一个类不想被继承，可以在这个类后面加final</p>\n<pre><code class=\"language-cpp\">class Animal final//Animal类不想被继承\n{};\n\nclass Bird :public Animal\n{};</code></pre>\n<p> 编译报错：final类无法被继承：</p>\n<p><img alt=\"\" height=\"256\" src=\"image\\e061637052b849d79266801b63ceb481.png\" width=\"1082\"/></p>\n<p> ②override：检查派生类虚函数是否重写了基类某个虚函数，如果没有重写编译报错</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\nusing namespace std;\n\nclass Animal\n{\npublic:\n\tvirtual void Speak()\n\t{\n\t\tcout &lt;&lt; \"speak\" &lt;&lt; endl;\n\t}\n};\n\nclass Bird :public Animal\n{\npublic:\n\tvirtual void Speak(int i) override//用来检查子类是否完成父类虚函数的重写\n\t{\n\t\tcout &lt;&lt; \"chirp\" &lt;&lt; endl;\n\t}\n};</code></pre>\n<p>由于子类重写的虚函数的参数列表和父类虚函数的参数列表不同，导致子类没有成功完成重写父类的虚函数，override检查会报错：</p>\n<p><img alt=\"\" height=\"257\" src=\"image\\d569f7008b0447d3846b873146594f01.png\" width=\"1187\"/></p>\n<h3 id=\"%EF%BC%885%EF%BC%89%E9%87%8D%E8%BD%BD%E3%80%81%E9%87%8D%E5%86%99%E4%B8%8E%E9%9A%90%E8%97%8F\"><span style=\"color:#956fe7;\">（5）重载、重写与隐藏</span></h3>\n<p> 重载、重写和隐藏的对比：</p>\n<p><img alt=\"\" height=\"323\" src=\"image\\5c19475739154dbfb459dc409bce7ed5.png\" width=\"814\"/></p>\n<p></p>\n<h1 id=\"%C2%A0%E4%BA%8C%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB\"><span style=\"color:#956fe7;\"> 二、抽象类</span></h1>\n<p></p>\n<h2 id=\"1.%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0\"><span style=\"color:#956fe7;\">1.纯虚函数</span></h2>\n<h3 id=\"%EF%BC%881%EF%BC%89%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0\"><span style=\"color:#956fe7;\">（1）纯虚函数</span></h3>\n<p>定义：在虚函数的后面写上 =0</p>\n<h3 id=\"%EF%BC%882%EF%BC%89%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%88%E6%8E%A5%E5%8F%A3%E7%B1%BB%EF%BC%89%EF%BC%9A\"><span style=\"color:#956fe7;\">（2）抽象类（接口类）：</span></h3>\n<p><strong>定义：</strong>包含纯虚函数的类</p>\n<p><strong>性质：</strong>抽象类不能实例化出对象。子类继承抽象类后也不能实例化出对象，只有重写纯虚函数，子类才能实例化出对象。</p>\n<p><strong>意义：</strong></p>\n<p>① 能够更好地去表示现实世界中没有实例对象是我抽象类型，如：植物、人、动物</p>\n<p>② 体现接口继承，强制子类去重写虚函数（就算不重写，子类也是抽象类）</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\nusing namespace std;\n\nclass Animal//抽象类\n{\npublic:\n\tvirtual void Speak() = 0;//纯虚函数\n};\n\nclass Bird :public Animal\n{\npublic://没有重写纯虚函数\n};\n\nclass Dog :public Animal\n{\npublic:\n\tvirtual void Speak()//子类重写父类虚函数\n\t{\n\t\tcout &lt;&lt; \"bark\" &lt;&lt; endl;\n\t}\n};</code></pre>\n<p>抽象类不能实例化出对象：</p>\n<pre><code class=\"language-cpp\">int main()\n{\n\tAnimal a;\n    return 0;\n}</code></pre>\n<p> 报错：</p>\n<p><img alt=\"\" height=\"254\" src=\"image\\bab3789875eb40d39d620649668b1261.png\" width=\"900\"/></p>\n<p> 当子类没有重写父类的纯虚函数时，直接把父类的虚函数继承下来了，这个虚函数也是纯虚函数，那么这个子类就是抽象类，不能实例化出对象：</p>\n<pre><code class=\"language-cpp\">int main()\n{\n\tBird b;\n\t\n\treturn 0;\n}\n</code></pre>\n<p>报错： </p>\n<p><img alt=\"\" height=\"262\" src=\"image\\a45f5d34e1ac40ee8b2dc67a9710b50f.png\" width=\"899\"/></p>\n<p> 当子类重写了父类虚函数：</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\nusing namespace std;\n\nclass Animal//抽象类\n{\npublic:\n\tvirtual void Speak() = 0;//纯虚函数\n};\n\nclass Bird :public Animal\n{\npublic:\n\tvirtual void Speak()//子类重写父类纯虚函数\n\t{\n\t\tcout &lt;&lt; \"chirp\" &lt;&lt; endl;\n\t}\n};\n\nclass Dog :public Animal\n{\npublic:\n\tvirtual void Speak()//子类重写父类纯虚函数\n\t{\n\t\tcout &lt;&lt; \"bark\" &lt;&lt; endl;\n\t}\n};\n\nint main()\n{\n\tAnimal* pBird = new Bird;\n\tpBird-&gt;Speak();\n\t\n\tAnimal* pDog = new Dog;\n\tpDog-&gt;Speak();\n\n\treturn 0;\n}</code></pre>\n<p><img alt=\"\" height=\"163\" src=\"image\\8cdf7d4c5f10436b9a9a25b65fd55622.png\" width=\"789\"/></p>\n<p> pBird 和pDog是指向父类的指针，调用了子类虚函数，看起来像是调用了同一个虚函数Speak( )。</p>\n<h2 id=\"2.%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%C2%A0\"><span style=\"color:#956fe7;\">2.接口继承和实现继承 </span></h2>\n<h3 id=\"%C2%A0%EF%BC%881%EF%BC%89%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF\"><span style=\"color:#956fe7;\">（1）实现继承</span></h3>\n<p>普通函数的继承是实现继承，不是接口继承，继承的是函数的实现，可以直接使用这个函数，也是一种复用。</p>\n<h3 id=\"%EF%BC%882%EF%BC%89%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%C2%A0\"><span style=\"color:#956fe7;\">（2）接口继承 </span></h3>\n<p>虚函数包括纯虚函数的继承是接口继承，子类仅仅只继承了父类接口 ，父类没有实现这个接口函数，子类要对纯虚函数进行重写达到多态的目的。</p>\n<p><strong>注意： </strong></p>\n<p>如果为了达到多态目的，那可以把父类接口定义成虚函数，并且定义了后，子类必须要重写父类的虚函数，否则就不要把普通函数定义成虚函数。</p>\n<p></p>\n<h1 id=\"%E4%B8%89%E3%80%81%E5%A4%9A%E6%80%81%E5%8E%9F%E7%90%86\"><span style=\"color:#956fe7;\">三、多态原理</span></h1>\n<h2 id=\"1.%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8\"><span style=\"color:#956fe7;\">1.虚函数表</span></h2>\n<p>了解多态原理前需要了解虚函数表。 </p>\n<p>在<a href=\"https://blog.csdn.net/gx714433461/article/details/124009239\" title=\"【C++】-- 类和对象\">【C++】-- 类和对象</a>一文中，讲过类的大小如何计算，只包含成员变量的大小，不会包含成员函数的大小，那么下面的代码应该打印4</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\nusing namespace std;\n\nclass Animal\n{\npublic:\n\tvirtual void Speak()//父类虚函数\n\t{\n\t\tcout &lt;&lt; \"speak\" &lt;&lt; endl;\n\t}\npublic:\n\tint legs;\n};\n\nint main()\n{\n\tAnimal a;\n\tcout &lt;&lt; \"sizeof(a) = \" &lt;&lt; sizeof(a) &lt;&lt; endl;//Animal类对象的大小\n\treturn 0;\n}</code></pre>\n<p>但是结果却打印8：</p>\n<p> <img alt=\"\" height=\"132\" src=\"image\\851136702f964f7db57300b58d5b1156.png\" width=\"815\"/></p>\n<p> 对象a只有一个成员变量legs，占4个字节。通过监视看到，对象a里面包含两个成员 ，那么另外4个字节一定是_vfptr占用的，且_vfptr里面存放的是一个地址，那么_vfptr一定是个指针：</p>\n<p><img alt=\"\" height=\"193\" src=\"image\\97d7c0d2129c481b9b0666ac8edaf905.png\" width=\"1200\"/></p>\n<p> _vfptr叫做虚函数表指针，其中v是virtual的缩写，f是function的缩写。</p>\n<p>虚函数表也简称虚表。</p>\n<p>由于虚函数的地址要被放到虚函数表中，因此一个含有虚函数的类中都至少有一个虚函数表指针，这个虚函数表指针指向一个虚函数。虚函数表指针用来实现多态。</p>\n<p>那么子类的虚表中都存放了什么呢？对于如下代码</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\nusing namespace std;\n\nclass Animal\n{\npublic:\n\tvirtual void Speak()//父类虚函数\n\t{\n\t\tcout &lt;&lt; \"speak\" &lt;&lt; endl;\n\t}\n\n\tvirtual void run()//父类虚函数\n\t{\n\t\tcout &lt;&lt; \"run\" &lt;&lt; endl;\n\t}\n\n\tvoid jump()//父类普通函数\n\t{\n\t\tcout &lt;&lt; \"jump\" &lt;&lt; endl;\n\t}\npublic:\n\tint legs;\n};\n\nclass Bird :public Animal\n{\npublic:\n\tvirtual void Speak()//子类重写父类虚函数\n\t{\n\t\tcout &lt;&lt; \"chirp\" &lt;&lt; endl;\n\t}\npublic:\n\tstring color;\n};\n\nint main()\n{\n\tAnimal a;\n\tBird b;\n\n\treturn 0;\n}</code></pre>\n<p> 监视：</p>\n<p><img alt=\"\" height=\"357\" src=\"image\\1bca59ef80084af59e1b68dff9e0f8d0.png\" width=\"1119\"/></p>\n<p> 数组也叫做表</p>\n<p>从监视可以发现： </p>\n<p>1.子类对象b中也有一个虚表指针，b对象由两部分构成，一部分是父类继承下来的成员，另一部分是自己的成员。<br/> 2.父类a对象和子类对象b虚表是不一样的，Speak完成了重写，所以b的虚表中存的是重写的Bird::Speak，所以虚函数的重写也叫作覆盖，覆盖就是指虚表中虚函数的覆盖。重写是语法的叫法，覆盖是原理层的叫法。<br/> 3. Run继承下来后是虚函数，所以放进了虚表，Jump也继承下来了，但是不是虚函数，所以不会放进虚表。<br/> 4.虚函数表本质是一个存虚函数指针的指针数组，这个数组最后面放了一个nullptr。<br/> 5.总结一下派生类的虚表生成：<br/>         a.先将基类中的虚表内容拷贝一份到派生类虚表中 <br/>         b.如果派生类重写了基类中某个虚函数，用派生类自己的虚函数覆盖虚表中基类的虚函数 <br/>         c.派生类自己新增加的虚函数按其在派生类中的声明次序增加到派生类虚表的最后。<br/> 6.虚函数存在哪的？虚表存在哪的？<br/>         虚表存的是虚函数指针，不是虚函数，虚函数和普通函数一样的，都是存在代码段的，只是它的指针又存到了虚表中。另外对象中存的不是虚表，存的是虚表指针。虚表在vs下存在代码段里。</p>\n<h2 id=\"2.%E5%8E%9F%E7%90%86\"><span style=\"color:#956fe7;\">2.原理</span></h2>\n<h3 id=\"%EF%BC%881%EF%BC%89%E6%9E%84%E6%88%90%E5%A4%9A%E6%80%81%C2%A0\"><span style=\"color:#956fe7;\">（1）构成多态 </span></h3>\n<p>对于如下代码，子类重写了父类虚函数，且通过父类指针调用虚函数，这就满足了多态的两个条件</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\nusing namespace std;\n\nclass Animal\n{\npublic:\n\tvirtual void Speak()//父类虚函数\n\t{\n\t\tcout &lt;&lt; \"speak\" &lt;&lt; endl;\n\t}\n};\n\nclass Bird :public Animal\n{\npublic:\n\tvirtual void Speak()//子类重写父类虚函数\n\t{\n\t\tcout &lt;&lt; \"chirp\" &lt;&lt; endl;\n\t}\n};\n\nvoid func(Animal* pa)\n{\n\tpa-&gt;Speak();//通过父类指针调用虚函数\n}\n\nint main()\n{\n\tAnimal a;\n\tfunc(&amp;a);\n\n\tBird b;\n\tfunc(&amp;b);\n\n\treturn 0;\n}</code></pre>\n<p> 打印结果：</p>\n<p><img alt=\"\" height=\"172\" src=\"image\\132e74fbecc3491cacf3721204dfa6d2.png\" width=\"964\"/></p>\n<p>为什么引用是父类就调父类的Speak，是子类就调子类的Speak呢？</p>\n<p> 对象a和对象b里面都没有其他成员，只有虚表指针，都是4字节。子类完成父类虚函数重写以后，子类的虚表指针指向的是重写了的子类虚函数：</p>\n<p><img alt=\"\" height=\"267\" src=\"image\\b2a09820824e47618387c2db65a39f47.png\" width=\"1101\"/> 指针或引用调用虚函数是怎么调的呢？</p>\n<p>指针或引用调用虚函数时，不是编译时确定，而是运行时才到指向的对象的虚表中找对应的虚函数调用，当指针或引用指向父类对象时，调用的就是父类的虚表中的虚函数，当指针或引用指向子类对象时，调用的就是子类虚表中的虚函数</p>\n<h3 id=\"%E2%80%8B%E7%BC%96%E8%BE%91\"><img alt=\"\" height=\"287\" src=\"image\\21fc6e9156e249a8af766004ad85b13a.png\" width=\"859\"/></h3>\n<p></p>\n<h3 id=\"%C2%A0%EF%BC%882%EF%BC%89%E4%B8%8D%E6%9E%84%E6%88%90%E5%A4%9A%E6%80%81\"><span style=\"color:#956fe7;\">（2）不构成多态</span></h3>\n<p> ① 如果子类没有重写父类虚函数：</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\nusing namespace std;\n\nclass Animal\n{\npublic:\n\tvirtual void Speak()//父类虚函数\n\t{\n\t\tcout &lt;&lt; \"speak\" &lt;&lt; endl;\n\t}\n\n};\n\nclass Bird :public Animal\n{\npublic:\n};\n\nvoid func(Animal* pa)\n{\n\tpa-&gt;Speak();\n}\n\nint main()\n{\n\tAnimal a;\n\tfunc(&amp;a);\n\n\tBird b;\n\tfunc(&amp;b);\n\n\treturn 0;\n}</code></pre>\n<p> 这时就破坏了多态的条件，那么子类也有虚表，但是子类虚表里的指针存的是Animal的虚函数，而不是Bird的虚函数。不满足多态条件时（子类没有重写父类虚函数/通过父类指针或引用调用虚函数），就不会到虚表里面去找，决定调哪个函数是在编译时确定这个函数的形参是哪个类型，而跟对象没有关系。</p>\n<p><img alt=\"\" height=\"275\" src=\"image\\98148545acd349929a220dfb3a4eab77.png\" width=\"1094\"/></p>\n<p><strong> 总结：</strong></p>\n<p>（1）构成多态，指向谁就调用谁的虚函数，跟对象有关</p>\n<p>（2）当子类没有重写父类虚函数时，不构成多态，调用函数的入参类型是什么，调用的就是哪个的虚函数，跟对象无关，跟入参类型有关</p>\n<p></p>\n<p> ② 不是通过父类指针或引用，而是通过父类对象调用虚函数</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\nusing namespace std;\n\nclass Animal\n{\npublic:\n\tvirtual void Speak()//父类虚函数\n\t{\n\t\tcout &lt;&lt; \"speak\" &lt;&lt; endl;\n\t}\n\npublic:\n\tint legs = 4;\n};\n\nclass Bird :public Animal\n{\npublic:\n\tvirtual void Speak()//子类重写父类虚函数\n\t{\n\t\tcout &lt;&lt; \"chirp\" &lt;&lt; endl;\n\t}\npublic:\n\tstring color;\n};\n\nvoid func(Animal pa)//入参类型为父类对象\n{\n\tpa.Speak();\n}\n\nint main()\n{\n\tAnimal a;\n\tfunc(a);\n\n\tBird b;\n\tb.legs = 2;\n\tfunc(b);\n\n\treturn 0;\n}</code></pre>\n<p>对象是无法实现出多态的，因为如果入参是子类对象，那么指针和引用会把父类那部分切出来，切出来后不是赋值，而是让指针指向子类里面父类的那部分，这个指针无论指向的是父类还是子类，看到的都是父类对象，给父类引用的就是父类对象，给子类引用的是切片出来的父类对象。</p>\n<p>而构成多态时，引用和指针本身并不知道自己指向或引用的是父类对象还是子类对象，指向父类对象，那就指向或引用整个父类对象，指向子类对象，那就那看到的就是子类对象中父类那一部分，对于</p>\n<pre><code class=\"language-cpp\">    a.Speak();</code></pre>\n<p> 编译完成的指令是一样的，虽然传入的实参不同，但是看到的都是父类部分或者子类切片出来的父类部分，都是一样的动作，到对应的地方去找。</p>\n<p>如果是对象的时候为什么不行，如果是对象涉及到切片问题，这个时候的切片不是让我窒息那个你，你给我的是一个父类对析那个，那就把这个父类对象给你，你给我的是个子类对象，就把子类对象中的父类部分切片后给你，调用拷贝构造函数把父类部分切片出来，把父类成员给你；父类对象不会把虚表指针给过去，两者的虚表指针是一样的</p>\n<p>父类对象调用完func后，pa的虚表指针存放的是父类的虚函数地址：</p>\n<p><img alt=\"\" height=\"322\" src=\"image\\7308ad59457e4b619d049e07c364d99a.png\" width=\"1200\"/></p>\n<p></p>\n<p>子类对象调用完func后，pa的虚表指针存放的还是父类的虚函数地址，但是成员变量被修改了：</p>\n<p><img alt=\"\" height=\"333\" src=\"image\\06568f7990964903ac0985ae78fde735.png\" width=\"1200\"/></p>\n<p></p>\n<p> 这是因为多个同类型对象，只有一份虚表，因此虚表当中的内容是一样的，它们的虚表指针都指向这个虚表。</p>\n<p><img alt=\"\" height=\"319\" src=\"image\\4b902e1cf0944976881c3a1d89e65832.png\" width=\"840\"/></p>\n<p>当是子类切片的时候，会把子类切出来的成员变量给func的形参（即父类对象），但不会把_vfptr给过去，因为只有一份虚表，假如切片后把虚表指针也给过去了，会出现混乱，它的虚表指针到底是父类的还是子类的，如果是直接定义出来的，那就是父类的，如果经过子类赋值，那就是子类的，但是父类对象的虚表里面怎么会有子类的虚函数呢？这显然不合理，因此不会把虚表给func的形参（父类对象）。</p>\n<p>指针和引用是指向的，指向父类就是父类对象，指向子类就是子类当中切片出来的父类部分，让指针和引用去指向。而对象要拷贝构造，只是把值给过去。</p>\n<p><strong>总结：</strong>当通过父类对象调用虚函数，切片只会拷贝成员变量，不会拷贝虚表指针</p>\n<h3 id=\"%EF%BC%883%EF%BC%89%E6%B1%87%E7%BC%96%E5%B1%82%E9%9D%A2%E7%9C%8B%E5%A4%9A%E6%80%81\"><span style=\"color:#956fe7;\">（3）汇编层面看多态</span></h3>\n<p> 不构成多态时，编译时直接调用函数的地址</p>\n<p>构成多态时，运行时到指向的对象的虚表中找到要调用的虚函数</p>\n<p><img alt=\"\" height=\"638\" src=\"image\\eec67530988f47688e0c1276f12173c7.png\" width=\"1200\"/></p>\n<p></p>\n<h1 id=\"%E5%9B%9B%E3%80%81%E5%8D%95%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8\"><span style=\"color:#956fe7;\">四、单继承和多继承关系的虚函数表</span></h1>\n<h2 id=\"1.%E5%8D%95%E7%BB%A7%E6%89%BF%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8\"><span style=\"color:#956fe7;\">1.单继承的虚函数表</span></h2>\n<h3 id=\"%EF%BC%881%EF%BC%89%E8%99%9A%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E6%97%B6%E6%9C%BA\"><span style=\"color:#956fe7;\">（1）虚表初始化的时机</span></h3>\n<p>对象中虚表指针是在什么阶段初始化的？虚表在哪个阶段生成？ </p>\n<p>对于如下代码：</p>\n<pre><code class=\"language-cpp\">#define  _CRT_SECURE_NO_WARNINGS  1\n#include&lt;iostream&gt;\nusing namespace std;\n\nclass Animal\n{\npublic:\n\tvirtual void Speak()//父类虚函数\n\t{\n\t\tcout &lt;&lt; \"Animal::speak\" &lt;&lt; endl;\n\t}\n\n\tvirtual void Run()//父类虚函数\n\t{\n\t\tcout &lt;&lt; \"Animal::run\" &lt;&lt; endl;\n\t}\n\n\tvoid Jump()//父类普通函数\n\t{\n\t\tcout &lt;&lt; \"Animal::jump\" &lt;&lt; endl;\n\t}\npublic:\n\tint legs = 4;\n};\n\nclass Bird :public Animal\n{\npublic:\n\tvirtual void Speak()//子类重写父类虚函数\n\t{\n\t\tcout &lt;&lt; \"Bird::chirp\" &lt;&lt; endl;\n\t}\npublic:\n\tstring color = \"Yellow\";\n};\n\nint main()\n{\n\tAnimal a;\n\tBird b;\n\n\treturn 0;\n}</code></pre>\n<p>通过监视F11逐语句查看执行过程发现，定义对象a时，执行步骤如下：</p>\n<p>（1）开始执行Animal的构造函数</p>\n<p>（2）初始化Animal的成员</p>\n<p>（3）将Animal构造函数执行完毕</p>\n<p>发现执行完以上3步之后，虚表指针已经初始化了： </p>\n<p><img alt=\"\" height=\"665\" src=\"image\\32ce37c8d7cc48c9ba3aac24efa01e3b.png\" width=\"854\"/><img alt=\"\" height=\"482\" src=\"image\\7ba10457edab4ffba073cb4d84349c39.png\" width=\"1015\"/></p>\n<p></p>\n<p> 因此，<strong>虚表指针是在构造函数初始化列表阶段初始化的，虚表在编译时就已经生成了。</strong></p>\n<p>一个类中所有的虚函数地址，都会放到虚表中。虚表里面存放的是虚函数地址，虚函数和普通函数一样， 编译完成后，都放在代码段。</p>\n<h3 id=\"%EF%BC%882%EF%BC%89%E5%AD%90%E7%B1%BB%E8%99%9A%E8%A1%A8%E7%9A%84%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B\"><span style=\"color:#956fe7;\">（2）子类虚表的生成过程</span></h3>\n<p>子类的虚表是如何生成的呢？</p>\n<p>父类的虚表中存的是Aniaml的Speak( )和Run( )的地址。生成子类虚表时，会单独开辟一块空间，拷贝一份父类虚表过程中，会将对应虚函数位置覆盖成子类重写了父类的虚函数，如果子类没有重写，那么父类的虚函数就不会被覆盖，保留。所以子类虚表的生成过程是一个<strong>拷贝+覆盖</strong>的过程。</p>\n<p>监视如上代码:</p>\n<p>（1）子类重写了父类的Speak( )虚函数，所以子类会覆盖父类Speak( )位置；</p>\n<p>（2）子类没有重写父类的Run( )虚函数，子类不会覆盖父类Run( )位置；</p>\n<p>（3）父类的Jump( )不是虚函数， 不会出现在虚表中：</p>\n<p><img alt=\"\" height=\"345\" src=\"image\\86697ce793da4a208c1d1e113587a53a.png\" width=\"917\"/></p>\n<p>虚函数的重写是语法层的概念，覆盖是虚表实现层的概念。</p>\n<p>在内存窗口输入虚表地址，发现里面存的是虚函数的地址，虚表作为数组，是如何知道数组结束的呢？VS在虚表结束位置放空指针，表示虚表结束了：</p>\n<p><img alt=\"\" height=\"859\" src=\"image\\23be163c3cd64abe81a11281fea79ee3.png\" width=\"1131\"/></p>\n<p></p>\n<p>假如子类还有虚函数：</p>\n<pre><code class=\"language-cpp\">\tvirtual void Fly()//飞\n\t{\n\t\tcout &lt;&lt; \"virtual Bird::fly\" &lt;&lt; endl;\n\t}\n\n\tvirtual void Sing()//唱歌\n\t{\n\t\tcout &lt;&lt; \"virtual Bird::sing\" &lt;&lt; endl;\n\t}</code></pre>\n<p> 这两个虚函数既不是继承父类虚函数，也没有重写父类虚函数，通过监视看不到子类的这两个虚函数，但是通过内存可以看到：</p>\n<p><img alt=\"\" height=\"613\" src=\"image\\83ed14790e7e491486ad8c16a3f9cd20.png\" width=\"1200\"/></p>\n<p>也可以打印一下虚表中调用的函数：</p>\n<pre><code class=\"language-cpp\">typedef void(*VFunc)();//为虚表指针定义简洁的名称\n\nvoid PrintVFT(VFunc* ptr)//传参虚函数指针数组\n{\n\tprintf(\"虚表地址：%p\\n\",ptr);\n\tfor (int i = 0; ptr[i] != nullptr; i++)\n\t{\n\t\tprintf(\"VFT[%d] : %p-&gt;\", i,ptr[i]);\n\t\tptr[i]();\n\t}\n\tprintf(\"\\n\");\n}\n\nint main()\n{\n\tAnimal a;\n\tPrintVFT((VFunc*)(*((int*)&amp;a)));\n\n\tBird b;\n\tPrintVFT((VFunc*)(*((int*)&amp;b)));\n\n\t//(int*)&amp;a -- 将a的虚表指针强转为int型\n\t//*((int*)&amp;a)) -- 解引用得到虚表指针指向的第一个虚函数地址\n\t//(VFunc*)(*((int*)&amp;a)) -- 将第一个虚函数地址强转为(VFunc*)\n\n\treturn 0;\n}</code></pre>\n<p></p>\n<p><img alt=\"\" height=\"328\" src=\"image\\26b139919d9944b49e385455fb3f99bd.png\" width=\"833\"/></p>\n<h2 id=\"2.%E5%A4%9A%E7%BB%A7%E6%89%BF%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%C2%A0\"><span style=\"color:#956fe7;\">2.多继承的虚函数表 </span></h2>\n<p> 以上是单继承，对于多继承，如何打印虚表函数：</p>\n<pre><code class=\"language-cpp\">#define  _CRT_SECURE_NO_WARNINGS  1\n#include&lt;iostream&gt;\nusing namespace std;\n\nclass Animal\n{\npublic:\n\tvirtual void Color()//颜色\n\t{\n\t\tcout &lt;&lt; \"virtual Animal::color\" &lt;&lt; endl;\n\t}\n\n\tvirtual void Name()//名称\n\t{\n\t\tcout &lt;&lt; \"virtual Animal::name\" &lt;&lt; endl;\n\t}\n};\n\nclass Plant\n{\npublic:\n\tvirtual void Color()//颜色\n\t{\n\t\tcout &lt;&lt; \"virtual Plant::color\" &lt;&lt; endl;\n\t}\n\n\tvirtual void Name()//名称\n\t{\n\t\tcout &lt;&lt; \"virtual Plant::name\" &lt;&lt; endl;\n\t}\n};\n\nclass Coral :public Animal, public Plant\n{\npublic:\n\tvirtual void Color()//子类重写Animal类虚函数\n\t{\n\t\tcout &lt;&lt; \"virtual Coral::color\" &lt;&lt; endl;\n\t}\n\n\tvirtual void Shape()//子类重写Plant类虚函数\n\t{\n\t\tcout &lt;&lt; \"virtual Coral::shape\" &lt;&lt; endl;\n\t}\n};\n\ntypedef void(*VFunc)();//为虚表指针定义简洁的名称\n\nvoid PrintVFT(VFunc* ptr)//传参虚函数指针数组\n{\n\tprintf(\"虚表地址：%p\\n\", ptr);\n\tfor (int i = 0; ptr[i] != nullptr; i++)\n\t{\n\t\tprintf(\"VFT[%d] : %p-&gt;\", i, ptr[i]);\n\t\tptr[i]();\n\t}\n\tprintf(\"\\n\");\n}\n\nint main()\n{\n\t//c继承了两个类，有两个虚表\n\t//c的两张虚表，先继承了Animal，Animal在前面，正好Animal的头4个字节是虚表指针，Plant挨着Animal，Animal完了就是Plant\n\tCoral c;\n\tPrintVFT((VFunc*)(*((int*)&amp;c)));\n\tPrintVFT((VFunc*)(*(int*)((char*)&amp;c + sizeof(Animal))));\n\n\t//(char*)&amp;c -- 取c的地址，强转成char*\n\t//(char*)&amp;c + sizeof(Animal) -- 取c的地址，强转成char*，再跨越一个Animal类的大小\n\n\treturn 0;\n}</code></pre>\n<p>打印发现：<br/> （1）两张虚表都重写了Color( )函数</p>\n<p>（2）但两张虚表都没有重写Name( )函数，都直接继承了Name( )函数</p>\n<p>（3）Shape( )虚函数只放在了第一张虚表中，第二张虚表没有放</p>\n<p></p>\n<p><img alt=\"\" height=\"316\" src=\"image\\ff4bdade4baa432ca114563e0d744b8b.png\" width=\"801\"/></p>\n<h1 id=\"%E4%BA%94%E3%80%81%E5%A4%9A%E6%80%81%E9%9D%A2%E8%AF%95%E9%A2%98\"><span style=\"color:#956fe7;\">五、多态面试题</span></h1>\n<h2 id=\"1.%E9%80%89%E6%8B%A9%E9%A2%98%C2%A0\"><span style=\"color:#956fe7;\">1.选择题</span> </h2>\n<p>1. 下面哪种面向对象的方法可以让你变得富有(  )<br/> A: 继承                   B: 封装                C: 多态               D: 抽象</p>\n<p> 答案： A 当然是继承更富有啦</p>\n<p><br/> 2. ( )是面向对象程序设计语言中的一种机制。这种机制实现了方法的定义与具体的对象无关，而对方法的调用则可以关联于具体的对象。<br/> A: 继承                   B: 模板                 C: 对象的自身引用           D: 动态绑定</p>\n<p>答案： D 动态绑定是函数调用时关联到具体对象</p>\n<p><br/> 3. 面向对象设计中的继承和组合，下面说法错误的是？（ ）<br/> A：继承允许我们覆盖重写父类的实现细节，父类的实现对于子类是可见的，是一种静态复用，也称为白盒复用<br/> B：组合的对象不需要关心各自的实现细节，之间的关系是在运行时候才确定的，是一种动态复用，也称为黑盒复用<br/> C：优先使用继承，而不是组合，是面向对象设计的第二原则<br/> D：继承可以使子类能自动继承父类的接口，但在设计模式中认为这是一种破坏了父类的封装性的表现</p>\n<p>答案: C 尽量少用继承，会破坏封装原则，多用组合，能降低耦合度</p>\n<p><br/> 4. 以下关于纯虚函数的说法,正确的是( )<br/> A：声明纯虚函数的类不能实例化                           B：声明纯虚函数的类是虚基类<br/> C：子类必须实现基类的                                         D：纯虚函数必须是空函数</p>\n<p>答案: A 包含纯虚函数的类叫做抽象类，抽象类不能实例化出对象</p>\n<p><br/> 5. 关于虚函数的描述正确的是( )<br/> A：派生类的虚函数与基类的虚函数具有不同的参数个数和类型<br/> B：内联函数不能是虚函数<br/> C：派生类必须重新定义基类的虚函数<br/> D：虚函数可以是一个static型的函数</p>\n<p>答案: B inline函数没有地址，当inline成为虚函数后，虚表里面要放它的地址，构成多态时，根据虚函数表指针去call这个地址，就不能展开了，就忽略了内联属性，加了虚函数以后就不再是内联函数了。</p>\n<p><br/> 6. 关于虚表说法正确的是（ ）<br/> A：一个类只能有一张虚表<br/> B：基类中有虚函数，如果子类中没有重写基类的虚函数，此时子类与基类共用同一张虚表<br/> C：虚表是在运行期间动态生成的<br/> D：一个类的不同对象共享该类的虚表</p>\n<p>答案: D </p>\n<p>对于A如果是多继承，那么这个类的对象会有多张虚表；</p>\n<p>对于B，监视：</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\nusing namespace std;\n\nclass Animal\n{\npublic:\n\tvirtual void Color()//颜色\n\t{\n\t\tcout &lt;&lt; \"virtual Animal::color\" &lt;&lt; endl;\n\t}\n\n\tvirtual void Name()//名称\n\t{\n\t\tcout &lt;&lt; \"virtual Animal::name\" &lt;&lt; endl;\n\t}\n};\n\nclass Coral :public Animal\n{};\n\nint main()\n{\n\tAnimal a;\n\tCoral c;\n\t\n\treturn 0;\n}</code></pre>\n<p>发现虚表指针不同，虽然虚表指针中存放的虚函数地址相同：</p>\n<p><img alt=\"\" height=\"287\" src=\"image\\5de7b3bebf24458b96734429e58ff5fc.png\" width=\"835\"/></p>\n<p>对于C：虚表在编译时就已经生成了</p>\n<p>对于D：</p>\n<pre><code class=\"language-cpp\">#define  _CRT_SECURE_NO_WARNINGS  1\n#include&lt;iostream&gt;\nusing namespace std;\n\nclass Animal\n{\npublic:\n\tvirtual void Color()//颜色\n\t{\n\t\tcout &lt;&lt; \"virtual Animal::color\" &lt;&lt; endl;\n\t}\n\n\tvirtual void Name()//名称\n\t{\n\t\tcout &lt;&lt; \"virtual Animal::name\" &lt;&lt; endl;\n\t}\n};\n\nint main()\n{\n\tAnimal a;\n\tAnimal a1;\n\n\treturn 0;\n}</code></pre>\n<p></p>\n<p> 监视发现：a和a1的虚表指针地址相同，虚表指针中存放的虚函数地址也相同</p>\n<p><img alt=\"\" height=\"531\" src=\"image\\7809e0e122974791ae851133e143710c.png\" width=\"1200\"/></p>\n<p>7. 假设A类中有虚函数，B继承自A，B重写A中的虚函数，也没有定义任何虚函数，则（ ）<br/> A：A类对象的前4个字节存储虚表地址，B类对象前4个字节不是虚表地址<br/> B：A类对象和B类对象前4个字节存储的都是虚基表的地址<br/> C：A类对象和B类对象前4个字节存储的虚表地址相同<br/> D：A类和B类中的内容完全一样，但是A类和B类使用的不是同一张虚表</p>\n<p>答案：D 同第6题的B</p>\n<p></p>\n<p>8. 下面程序输出结果是什么? （）</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\nusing namespace std;\nclass A\n{\npublic:\n    A(char *s) { cout&lt;&lt;s&lt;&lt;endl; }\n    ~A(){}\n};\nclass B:virtual public A\n{\npublic:\n    B(char *s1,char*s2):A(s1) { cout&lt;&lt;s2&lt;&lt;endl; }\n};\nclass C:virtual public A\n{\npublic:\n    C(char *s1,char*s2):A(s1) { cout&lt;&lt;s2&lt;&lt;endl; }\n};\nclass D:public B,public C\n{\npublic:\n    D(char *s1,char *s2,char *s3,char *s4):B(s1,s2),C(s1,s3),A(s1){ cout&lt;&lt;s4&lt;&lt;endl;}\n};\n\nint main() \n{\n    D *p=new D(\"class A\",\"class B\",\"class C\",\"class D\");\n    delete p;\n    return 0;\n}</code></pre>\n<p>A：class A class B class C class D                    B：class D class B class C class A<br/> C：class D class C class B class A                    D：class A class C class B class D </p>\n<p>答案：A 子类构造函数必须调用父类的构造函数初始化父类的成员，因此执行D的构造函数前必须执行B和C的构造函数，执行B和C的构造函数前必须执行A的构造函数 </p>\n<p>9. 多继承中指针偏移问题？下面说法正确的是( )  </p>\n<pre><code class=\"language-cpp\">class Base1 { public: int _b1; };\nclass Base2 { public: int _b2; };\nclass Derive : public Base1, public Base2 { public: int _d; };\n\nint main()\n{\n    Derive d;\n    Base1* p1 = &amp;d;\n    Base2* p2 = &amp;d;\n    Derive* p3 = &amp;d;\n    return 0;\n}</code></pre>\n<p></p>\n<p> A：p1 == p2 == p3            B：p1 &lt; p2 &lt; p3             C：p1 == p3 != p2              D：p1 != p2 != p3</p>\n<p>答案：C p3作为子类，普通多继承，示意图如下：Derive的成员包含Base1和Base2的成员</p>\n<p class=\"img-center\"><img alt=\"\" height=\"355\" src=\"image\\3bb735010f6043068eb499ad1cf33f50.png\" width=\"377\"/></p>\n<p>10. 以下程序输出结果是什么（ ）</p>\n<pre><code class=\"language-cpp\">class A\n{\npublic:\n    virtual void func(int val = 1){ std::cout&lt;&lt;\"A-&gt;\"&lt;&lt; val &lt;&lt;std::endl;}\n    virtual void test(){ func();}\n};\nclass B : public A\n{\npublic:\n    void func(int val=0){ std::cout&lt;&lt;\"B-&gt;\"&lt;&lt; val &lt;&lt;std::endl; }\n};\n\nint main(int argc ,char* argv[])\n{\n    B*p = new B;\n    p-&gt;test();\n    return 0;\n}</code></pre>\n<p></p>\n<p>A: A-&gt;0            B: B-&gt;1               C: A-&gt;1            D: B-&gt;0          E: 编译出错             F.以上都不正确 </p>\n<p>答案：B，p是子类指针，不是父类指针，test( )调用不构成多态。但有隐藏多态，p是子类指针，会把test传给this，抵用test之后会把p传给this，this在A里面，是父类指针，把p传给了this，父类指针指向了子类对象，父类的指针调func，是一个重写的虚函数，this是父类指针，<strong>子类继承了父类的虚函数，重写了函数实现，但是继承的是父类的接口定义，</strong>比如虽然子类的func函数没有加virtual，但是子类继承了父类的func函数，就是虚函数。所以就算子类重写父类虚函数时，给了缺省参数，但是根本不会用到。用的是<strong>父类接口定义+子类实现</strong></p>\n<h2 id=\"2.%E9%97%AE%E7%AD%94%E9%A2%98%C2%A0\"><span style=\"color:#956fe7;\">2.问答题 </span></h2>\n<p>1. 什么是多态？</p>\n<p>答：不同继承关系的类对象，去调用同一函数，产生了不同的行为</p>\n<p><br/> 2. 什么是重载、重写(覆盖)、重定义(隐藏)？</p>\n<p>答：</p>\n<p>重载（也叫静态多态）：两个函数在同一作用域，函数名和参数相同</p>\n<p>重写（也叫覆盖、动态多态）：两个函数分别在父类和子类的作用域；函数名、参数、返回值都必须相同；两个函数都必须是虚函数</p>\n<p>隐藏（也叫重定义）：两个函数分别在父类和子类的作用域，函数名相同，两个父类和子类的同名函数不构成重写就构成重定义</p>\n<p><br/> 3. 多态的实现原理？</p>\n<p>答：子类重写了父类虚函数，且通过父类指针调用虚函数，这就满足了多态的两个条件。子类完成父类虚函数重写以后，子类的虚表指针指向的是重写了的子类虚函数。指针或引用调用虚函数时，不是编译时确定，而是运行时才到指向的对象的虚表中找对应的虚函数调用，当指针或引用指向父类对象时，调用的就是父类的虚表中的虚函数，当指针或引用指向子类对象时，调用的就是子类虚表中的虚函数。</p>\n<p><br/> 4. inline函数可以是虚函数吗？</p>\n<p>答：不能，因为inline函数没有地址，无法把地址放到虚函数表中。</p>\n<p>inline函数没有地址，当inline成为虚函数后，虚表里面要放它的地址，构成多态时，根据虚函数表指针去call这个地址，就不能展开了，就忽略了内联属性，加了虚函数以后就不再是内联函数了。</p>\n<p><br/> 5. 静态成员可以是虚函数吗？</p>\n<p>答：不能，因为静态成员函数没有this指针，使用类型::成员函数的调用方式无法访问虚函数表，所以静态成员函数无法放进虚函数表。</p>\n<p><br/> 6. 构造函数可以是虚函数吗？</p>\n<p>答：不能，因为对象中的虚函数表指针是在构造函数初始化列表阶段才初始化的。</p>\n<p>假如构造函数是虚函数：</p>\n<p>①调用构造函数虚函数必须要去虚表里面找，这就要求对象必须已经被初始化出来了。</p>\n<p>②要初始化对象，就要调构造函数虚函数，但是对象还没有构造出来，虚表还没有初始化，还找不到构造函数虚函数地址。</p>\n<p>这就陷入了死循环</p>\n<p><br/> 7. 析构函数可以是虚函数吗？什么场景下析构函数是虚函数？</p>\n<p>答：可以，最好把基类的析构函数定义成虚函数。这样子类继承父类后，子类的析构函数也会成为虚函数，在这样的场景下，期望达到多态行为，子类的析构函数会在被调用完成后自动调用父类的析构函数清理父类成员。因为这样才能保证子类对象先清理子类成员再清理父类成员的顺序。多态场景下子类和父类的析构函数最好加上virtual关键字，让子类完成虚函数重写就不会导致内存泄漏了</p>\n<p><br/> 8. 对象访问普通函数快还是虚函数更快？</p>\n<p>答：</p>\n<p>如果是普通对象，那么访问普通函数和虚函数是一样快的。</p>\n<p>如果是指针对象或者是引用对象，则调用的普通函数快，因为构成多态，运行时调用虚函数需要到虚函数表中去查找，需要耗时。</p>\n<p><br/> 9. 虚函数表是在什么阶段生成的，存在哪的？</p>\n<p>答：虚函数表是在编译阶段就生成的，一般情况下存在代码段(常量区)的。</p>\n<p><br/> 10. C++菱形继承的问题？虚继承的原理？</p>\n<p>答：子类对象会有两份父类的成员，菱形继承会导致数据冗余和二义性。</p>\n<p>虚继承通过虚基表指针的偏移量计算出父类成员的起始地址，这样就只需要在内存中存一份父类成员，解决了数据冗余和二义性的问题。</p>\n<p><br/> 11. 什么是抽象类？抽象类的作用？</p>\n<p>答：包含纯虚函数的类叫做抽象类。</p>\n<p>抽象类不能实例化出对象。子类继承抽象类后也是抽象类，没有重写虚函数，不能实例化出对象，只有重写纯虚函数，子类才能实例化出对象。</p>\n<p>① 能够更好地去表示现实世界中没有实例对象是我抽象类型，如：植物、人、动物</p>\n<p>② 体现接口继承，强制子类去重写虚函数（就算不重写，子类也是抽象类）</p>\n<p></p>\n</div>\n</div>"}