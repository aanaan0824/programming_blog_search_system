{"blogid": "123967275", "writerAge": "码龄3年", "writerBlogNum": "10", "writerCollect": "55", "writerComment": "12", "writerFan": "6", "writerGrade": "2级", "writerIntegral": "133", "writerName": "wait疯man", "writerProfileAdress": "writer_image\\profile_123967275.jpg", "writerRankTotal": "93211", "writerRankWeekly": "963278", "writerThumb": "19", "writerVisitNum": "11496", "blog_read_count": "5797", "blog_time": "已于 2022-04-06 10:20:03 修改", "blog_title": "事务的传播机制", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"1.%E5%BD%A2%E8%B1%A1%E8%AF%B4%E6%98%8E%EF%BC%9A-toc\" style=\"margin-left:0px;\"><a href=\"#1.%E5%BD%A2%E8%B1%A1%E8%AF%B4%E6%98%8E%EF%BC%9A\">1.形象说明：</a></p>\n<p id=\"2.%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA%EF%BC%9A-toc\" style=\"margin-left:0px;\"><a href=\"#2.%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA%EF%BC%9A\">2.代码演示：</a></p>\n<p id=\"2.1%C2%A0REQUIRED-toc\" style=\"margin-left:40px;\"><a href=\"#2.1%C2%A0REQUIRED\">2.1 REQUIRED</a></p>\n<p id=\"2.1.1%C2%A0%20%E9%AA%8C%E8%AF%81%E5%85%B1%E7%94%A8%E4%B8%80%E4%B8%AA%E4%BA%8B%E5%8A%A1-toc\" style=\"margin-left:80px;\"><a href=\"#2.1.1%C2%A0%20%E9%AA%8C%E8%AF%81%E5%85%B1%E7%94%A8%E4%B8%80%E4%B8%AA%E4%BA%8B%E5%8A%A1\">2.1.1  验证共用一个事务</a></p>\n<p id=\"2.1.2%C2%A0%20%E9%AA%8C%E8%AF%81%E5%BD%93%E5%89%8D%E6%B2%A1%E6%9C%89%E4%BA%8B%E5%8A%A1%EF%BC%8C%E5%B0%B1%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%BA%8B%E5%8A%A1-toc\" style=\"margin-left:80px;\"><a href=\"#2.1.2%C2%A0%20%E9%AA%8C%E8%AF%81%E5%BD%93%E5%89%8D%E6%B2%A1%E6%9C%89%E4%BA%8B%E5%8A%A1%EF%BC%8C%E5%B0%B1%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%BA%8B%E5%8A%A1\">2.1.2  验证当前没有事务，就新建一个事务</a></p>\n<p id=\"2.2%C2%A0SUPPORTS-toc\" style=\"margin-left:40px;\"><a href=\"#2.2%C2%A0SUPPORTS\">2.2 SUPPORTS</a></p>\n<p id=\"2.2.1%20%E6%94%AF%E6%8C%81%E4%BD%BF%E7%94%A8%E5%BD%93%E5%89%8D%E4%BA%8B%E5%8A%A1-toc\" style=\"margin-left:80px;\"><a href=\"#2.2.1%20%E6%94%AF%E6%8C%81%E4%BD%BF%E7%94%A8%E5%BD%93%E5%89%8D%E4%BA%8B%E5%8A%A1\">2.2.1 支持使用当前事务</a></p>\n<p id=\"2.2.2%C2%A0%E5%A6%82%E6%9E%9C%E5%BD%93%E5%89%8D%E4%BA%8B%E5%8A%A1%E4%B8%8D%E5%AD%98%E5%9C%A8%EF%BC%8C%E5%88%99%E4%B8%8D%E4%BD%BF%E7%94%A8%E4%BA%8B%E5%8A%A1-toc\" style=\"margin-left:80px;\"><a href=\"#2.2.2%C2%A0%E5%A6%82%E6%9E%9C%E5%BD%93%E5%89%8D%E4%BA%8B%E5%8A%A1%E4%B8%8D%E5%AD%98%E5%9C%A8%EF%BC%8C%E5%88%99%E4%B8%8D%E4%BD%BF%E7%94%A8%E4%BA%8B%E5%8A%A1\">2.2.2 如果当前事务不存在，则不使用事务</a></p>\n<p id=\"2.3%C2%A0MANDATORY-toc\" style=\"margin-left:40px;\"><a href=\"#2.3%C2%A0MANDATORY\">2.3 MANDATORY</a></p>\n<p id=\"2.3.1%20%E6%94%AF%E6%8C%81%E4%BD%BF%E7%94%A8%E5%BD%93%E5%89%8D%E4%BA%8B%E5%8A%A1-toc\" style=\"margin-left:80px;\"><a href=\"#2.3.1%20%E6%94%AF%E6%8C%81%E4%BD%BF%E7%94%A8%E5%BD%93%E5%89%8D%E4%BA%8B%E5%8A%A1\">2.3.1 支持使用当前事务</a></p>\n<p id=\"2.3.2%C2%A0%E5%A6%82%E6%9E%9C%E5%BD%93%E5%89%8D%E4%BA%8B%E5%8A%A1%E4%B8%8D%E5%AD%98%E5%9C%A8%EF%BC%8C%E5%88%99%E6%8A%9B%E5%87%BAException-toc\" style=\"margin-left:80px;\"><a href=\"#2.3.2%C2%A0%E5%A6%82%E6%9E%9C%E5%BD%93%E5%89%8D%E4%BA%8B%E5%8A%A1%E4%B8%8D%E5%AD%98%E5%9C%A8%EF%BC%8C%E5%88%99%E6%8A%9B%E5%87%BAException\">2.3.2 如果当前事务不存在，则抛出Exception</a></p>\n<p id=\"2.4%C2%A0REQUIRES_NEW-toc\" style=\"margin-left:40px;\"><a href=\"#2.4%C2%A0REQUIRES_NEW\">2.4 REQUIRES_NEW</a></p>\n<p id=\"2.4.1%20%E5%BD%93%E5%89%8D%E4%BA%8B%E5%8A%A1%E4%B8%8D%E5%AD%98%E5%9C%A8%EF%BC%8C%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%B0%E4%BA%8B%E5%8A%A1-toc\" style=\"margin-left:80px;\"><a href=\"#2.4.1%20%E5%BD%93%E5%89%8D%E4%BA%8B%E5%8A%A1%E4%B8%8D%E5%AD%98%E5%9C%A8%EF%BC%8C%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%B0%E4%BA%8B%E5%8A%A1\">2.4.1 当前事务不存在，创建一个新事务</a></p>\n<p id=\"2.4.2%20%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%BA%8B%E5%8A%A1%EF%BC%8C%E5%BD%93%E5%89%8D%E4%BA%8B%E5%8A%A1%E5%AD%98%E5%9C%A8%EF%BC%8C%E6%8A%8A%E5%BD%93%E5%89%8D%E4%BA%8B%E5%8A%A1%E6%8C%82%E8%B5%B7-toc\" style=\"margin-left:80px;\"><a href=\"#2.4.2%20%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%BA%8B%E5%8A%A1%EF%BC%8C%E5%BD%93%E5%89%8D%E4%BA%8B%E5%8A%A1%E5%AD%98%E5%9C%A8%EF%BC%8C%E6%8A%8A%E5%BD%93%E5%89%8D%E4%BA%8B%E5%8A%A1%E6%8C%82%E8%B5%B7\">2.4.2 新建一个事务，当前事务存在，把当前事务挂起</a></p>\n<p id=\"2.5%C2%A0NOT_SUPPORTED-toc\" style=\"margin-left:40px;\"><a href=\"#2.5%C2%A0NOT_SUPPORTED\">2.5 NOT_SUPPORTED</a></p>\n<p id=\"2.5.1%20%E6%97%A0%E4%BA%8B%E5%8A%A1%E6%89%A7%E8%A1%8C-toc\" style=\"margin-left:80px;\"><a href=\"#2.5.1%20%E6%97%A0%E4%BA%8B%E5%8A%A1%E6%89%A7%E8%A1%8C\">2.5.1 无事务执行</a></p>\n<p id=\"2.5.2%C2%A0%E5%A6%82%E6%9E%9C%E5%BD%93%E5%89%8D%E4%BA%8B%E5%8A%A1%E5%AD%98%E5%9C%A8%EF%BC%8C%E6%8A%8A%E5%BD%93%E5%89%8D%E4%BA%8B%E5%8A%A1%E6%8C%82%E8%B5%B7%E3%80%82-toc\" style=\"margin-left:80px;\"><a href=\"#2.5.2%C2%A0%E5%A6%82%E6%9E%9C%E5%BD%93%E5%89%8D%E4%BA%8B%E5%8A%A1%E5%AD%98%E5%9C%A8%EF%BC%8C%E6%8A%8A%E5%BD%93%E5%89%8D%E4%BA%8B%E5%8A%A1%E6%8C%82%E8%B5%B7%E3%80%82\">2.5.2 如果当前事务存在，把当前事务挂起。</a></p>\n<p id=\"2.6%C2%A0NEVER-toc\" style=\"margin-left:40px;\"><a href=\"#2.6%C2%A0NEVER\">2.6 NEVER</a></p>\n<p id=\"2.6.1%20%E6%97%A0%E4%BA%8B%E5%8A%A1%E6%89%A7%E8%A1%8C-toc\" style=\"margin-left:80px;\"><a href=\"#2.6.1%20%E6%97%A0%E4%BA%8B%E5%8A%A1%E6%89%A7%E8%A1%8C\">2.6.1 无事务执行</a></p>\n<p id=\"2.6.2%C2%A0%E5%A6%82%E6%9E%9C%E5%BD%93%E5%89%8D%E6%9C%89%E4%BA%8B%E5%8A%A1%E5%88%99%E6%8A%9B%E5%87%BAException-toc\" style=\"margin-left:80px;\"><a href=\"#2.6.2%C2%A0%E5%A6%82%E6%9E%9C%E5%BD%93%E5%89%8D%E6%9C%89%E4%BA%8B%E5%8A%A1%E5%88%99%E6%8A%9B%E5%87%BAException\">2.6.2 如果当前有事务则抛出Exception</a></p>\n<p id=\"2.7%C2%A0%C2%A0NESTED-toc\" style=\"margin-left:40px;\"><a href=\"#2.7%C2%A0%C2%A0NESTED\">2.7  NESTED</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<p></p>\n<p></p>\n<p>事务的传播机制有7种，如下图所示：</p>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"250\" src=\"image\\c52027676ed24f9a8e57e5b2b7ebeb2f.png\" width=\"773\"/></p>\n<h1 id=\"1.%E5%BD%A2%E8%B1%A1%E8%AF%B4%E6%98%8E%EF%BC%9A\">1.形象说明：</h1>\n<p>为了更好的理解，下面我们形象的说明一下几种传播机制是什么意思：</p>\n<p>比如你下班回家，有以下几种场景</p>\n<p>0.REQUIRED ------ 就是如果老婆做饭了，你就吃老婆做的饭；如果老婆没有做饭，你就自己做饭吃，反正你就是要吃饭（反正要在事务中运行）；</p>\n<p>1.SUPPORTS ------ 如果老婆做饭了，你就吃老婆做的饭；如果老婆没有做饭，你就不吃（不一定非要在事务中运行）；</p>\n<p>2.MANDATORY ------ 非要吃老婆做的饭，老婆要是没有做饭，你就大发脾气，典型的家暴男；</p>\n<p>3.REQUIRES_NEW ------ 劳资非要吃自己做的饭，就算老婆把饭做好了，你也不吃老婆做的；</p>\n<p>4.NOT_SUPPORTED ------ 劳资就是不吃饭，就算老婆把饭做好了，我也不吃；</p>\n<p>5.NEVER ------ 劳资就是不吃饭，如果老婆把饭做好了，我还要发脾气；</p>\n<p>6.NESTED ------ 暂不做解释，后面会详解；</p>\n<p></p>\n<p>本文主要是想用代码实现这几种传播机制的具体使用；</p>\n<h1 id=\"2.%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA%EF%BC%9A\">2.代码演示：</h1>\n<p>有两张表：</p>\n<p>school表</p>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"223\" src=\"image\\7cfcc510c1414cb5b46df40b838fd658.png\" width=\"374\"/></p>\n<p>student表</p>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"204\" src=\"image\\9afe056cd0d44e8e9636a7b0e155a06a.png\" width=\"365\"/></p>\n<p>我们如何去测试两个方法是否使用的同一个事务呢？就看是否共用同一个数据库连接或者共用同一个会话；</p>\n<h2 id=\"2.1%C2%A0REQUIRED\">2.1 REQUIRED</h2>\n<p>支持使用当前事务，如果当前事务不存在，创建一个新事务。</p>\n<h3 id=\"2.1.1%C2%A0%20%E9%AA%8C%E8%AF%81%E5%85%B1%E7%94%A8%E4%B8%80%E4%B8%AA%E4%BA%8B%E5%8A%A1\">2.1.1  验证共用一个事务</h3>\n<p>schoolService.updateSchool()方法：</p>\n<pre><code class=\"language-java\">@Transactional\n    public void updateSchool(){\n        School school = new School();\n        school.setId(1);\n        school.setName(\"湖南大学\");\n        school.setLocation(\"湖南\");\n        //更新id为1的学校名称为湖南大学，地址为湖南\n        schoolMapper.updateByPrimaryKeySelective(school);\n        \n        //调用另一个方法更新学生信息\n        studentService.updateStudent();\n        System.out.println(1/0);\n    }</code></pre>\n<p>studentService.updateStudent()方法，加了事务的，默认REQUIRED：</p>\n<pre><code class=\"language-java\">@Transactional\n    public void updateStudent(){\n        Student student = new Student();\n        student.setSid(1);\n        student.setAge(25);\n        //更新sid为1的学生年龄为25\n        studentMapper.updateByPrimaryKeySelective(student);\n    }</code></pre>\n<p>如上所示：updateSchool方法是加了事务的，调用完studentService.updateStudent方法后，会报错，如果updateSchool和updateStudent共用同一个事务，updateSchool报错，自身回滚，肯定会带着updateStudent一起回滚；如果不是共用同一个事务，那么updateStudent会执行成功并提交，不会回滚；</p>\n<p><strong>结果：</strong></p>\n<p>updateSchool成功回滚了</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\a7b48f2b2de340b5a45d689eec14ccfd.png\"/></p>\n<p> updateStudent也成功回滚了</p>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"73\" src=\"image\\3d3d1f7f1e4443d89a12939462eec6c0.png\" width=\"402\"/></p>\n<p>看过我写的<a class=\"link-info\" href=\"https://mp.csdn.net/mp_blog/creation/editor/123899022\" title=\"深入理解@Transactional注解的使用和原理\">深入理解@Transactional注解的使用和原理</a>就知道，两个方法会共用同一个数据库连接，也就共用同一个事务，两个方法一起提交或者回滚；</p>\n<h3 id=\"2.1.2%C2%A0%20%E9%AA%8C%E8%AF%81%E5%BD%93%E5%89%8D%E6%B2%A1%E6%9C%89%E4%BA%8B%E5%8A%A1%EF%BC%8C%E5%B0%B1%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%BA%8B%E5%8A%A1\">2.1.2  验证当前没有事务，就新建一个事务</h3>\n<p>schoolService.updateSchool()方法：</p>\n<pre><code class=\"language-java\">  public void updateSchool(){\n        School school = new School();\n        school.setId(1);\n        school.setName(\"湖南大学\");\n        school.setLocation(\"湖南\");\n        //更新id为1的学校名称为湖南大学，地址为湖南\n        schoolMapper.updateByPrimaryKeySelective(school);\n        \n        //调用另一个方法更新学生信息\n        studentService.updateStudent();\n       \n    }</code></pre>\n<p>studentService.updateStudent()方法：</p>\n<pre><code class=\"language-java\">@Transactional\n    public void updateStudent(){\n        Student student = new Student();\n        student.setSid(1);\n        student.setAge(25);\n        //更新sid为1的学生年龄为25\n        studentMapper.updateByPrimaryKeySelective(student);\n        //报错\n        System.out.println(1/0);\n    }</code></pre>\n<p>如上所示：updateSchool方法是没有加事务的，调用studentService.updateStudent方法，updateStudent方法加了事务，并且会报错，如果updateStudent没有新建事务的话，不会回滚，如果是建了事务，就会回滚；</p>\n<p><strong>结果：</strong></p>\n<p>1.控制台提示报错</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\38b50354914646b6948beed193523ac7.png\"/></p>\n<p>2. updateSchool方法没有回滚（将北京大学刚改为湖南大学）</p>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"100\" src=\"image\\d470d2f0c5d54cf295bbdac177b534aa.png\" width=\"304\"/></p>\n<p> 3.updateStudent方法回滚了（将age更新为25）</p>\n<p>                                                <img alt=\"\" height=\"49\" src=\"image\\2d09e19120a642afbcc237fb8823b731.png\" width=\"270\"/></p>\n<p>验证通过；</p>\n<h2 id=\"2.2%C2%A0SUPPORTS\">2.2 SUPPORTS</h2>\n<p>支持使用当前事务，如果当前事务不存在，则不使用事务。</p>\n<h3 id=\"2.2.1%20%E6%94%AF%E6%8C%81%E4%BD%BF%E7%94%A8%E5%BD%93%E5%89%8D%E4%BA%8B%E5%8A%A1\">2.2.1 支持使用当前事务</h3>\n<p>updateSchool方法，加事务，更新id为1的name为“湖南大学”，location为“湖南”，输出1/0，肯定会报错的；</p>\n<pre><code class=\"language-java\">    @Transactional\n    public void updateSchool(){\n        School school = new School();\n        school.setId(1);\n        school.setName(\"湖南大学\");\n        school.setLocation(\"湖南\");\n        schoolMapper.updateByPrimaryKeySelective(school);\n        studentService.updateStudent();\n        System.out.println(1/0);\n    }</code></pre>\n<p>updateStudent方法更新id为1的age为25；</p>\n<pre><code class=\"language-java\">    @Transactional(propagation = Propagation.SUPPORTS)\n    public void updateStudent(){\n        Student student = new Student();\n        student.setSid(1);\n        student.setAge(25);\n        studentMapper.updateByPrimaryKeySelective(student);\n    }</code></pre>\n<p>如上所示：updateSchool方法是加了事务的，studentService.updateStudent方法也加了事务，而且传播机制是SUPPORTS，如果updateSchool和updateStudent共用同一个事务，updateSchool报错，自身回滚，肯定会带着updateStudent一起回滚；如果不是共用同一个事务，那么updateStudent会执行成功并提交，不会回滚；</p>\n<p><strong>结果：</strong></p>\n<p>1.控制台提示报错</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\1cfb1d9728c4446f89955a72224dbf85.png\"/></p>\n<p>2. updateSchool方法回滚（将北京大学刚改为湖南大学）</p>\n<p><img alt=\"\" src=\"image\\a7b48f2b2de340b5a45d689eec14ccfd.png\"/></p>\n<p>3.updateStudent方法回滚（将age改为25）</p>\n<p><img alt=\"\" height=\"73\" src=\"image\\3d3d1f7f1e4443d89a12939462eec6c0.png\" width=\"402\"/></p>\n<p>显然，updateSchool和updateSchool共用同一个事务，正好验证了传播机制为supports，如果当前有事务，就支持使用当前事务；</p>\n<h3 id=\"2.2.2%C2%A0%E5%A6%82%E6%9E%9C%E5%BD%93%E5%89%8D%E4%BA%8B%E5%8A%A1%E4%B8%8D%E5%AD%98%E5%9C%A8%EF%BC%8C%E5%88%99%E4%B8%8D%E4%BD%BF%E7%94%A8%E4%BA%8B%E5%8A%A1\">2.2.2 如果当前事务不存在，则不使用事务</h3>\n<p>updateSchool方法更新id为1的name为“湖南大学”，location为“湖南”，将@Transactional注释掉了，没有加事务</p>\n<pre><code class=\"language-java\">    //@Transactional\n    public void updateSchool(){\n        School school = new School();\n        school.setId(1);\n        school.setName(\"湖南大学\");\n        school.setLocation(\"湖南\");\n        schoolMapper.updateByPrimaryKeySelective(school);\n        studentService.updateStudent();\n    }</code></pre>\n<p>updateStudent方法更新id为1的age为25，事务传播机制为SUPPORTS，打印1/0，将报错</p>\n<pre><code class=\"language-java\">    @Transactional(propagation = Propagation.SUPPORTS)\n    public void updateStudent(){\n        Student student = new Student();\n        student.setSid(1);\n        student.setAge(25);\n        studentMapper.updateByPrimaryKeySelective(student);\n        System.out.println(1/0);\n    }</code></pre>\n<p>如上所示：updateSchool方法没有加事务，studentService.updateStudent方法加了事务，而且传播机制是SUPPORTS，如果updateStudent没有事务，报错就不会回滚，如果有事务，就会回滚；</p>\n<p><strong>结果：</strong></p>\n<p>1.控制台报错</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\e343e65a9860453cbc39c7f50699a3cc.png\"/></p>\n<p> 2.updateSchool方法没有回滚，无事务执行（无事务这个说法其实不准确，任何操作数据库肯定是有事务的）；</p>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"48\" src=\"image\\09f901368e534097a83d3ee141bc3969.png\" width=\"382\"/></p>\n<p> 3.updateStudent方法也没有回滚，也是无事务执行的；</p>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"40\" src=\"image\\76140e9cb195466492bca085b03f287f.png\" width=\"290\"/></p>\n<p></p>\n<p><strong>显然：  </strong>事务传播机制为SUPPORTS的方法，支持使用当前事务，如果当前事务不存在，则不使用事务。</p>\n<p></p>\n<h2 id=\"2.3%C2%A0MANDATORY\">2.3 MANDATORY</h2>\n<p>中文翻译为强制，支持使用当前事务，如果当前事务不存在，则抛出Exception。</p>\n<h3 id=\"2.3.1%20%E6%94%AF%E6%8C%81%E4%BD%BF%E7%94%A8%E5%BD%93%E5%89%8D%E4%BA%8B%E5%8A%A1\">2.3.1 支持使用当前事务</h3>\n<p>updateSchool方法更新id为1的name为“湖南大学”，location为“湖南”，打印1/0，会报错；</p>\n<pre><code class=\"language-java\">    @Transactional\n    public void updateSchool(){\n        School school = new School();\n        school.setId(1);\n        school.setName(\"湖南大学\");\n        school.setLocation(\"湖南\");\n        schoolMapper.updateByPrimaryKeySelective(school);\n        studentService.updateStudent();\n        System.out.println(1/0);\n    }</code></pre>\n<p>updateStudent方法更新id为1的age为25，事务传播机制为MANDATORY</p>\n<pre><code class=\"language-java\">    @Transactional(propagation = Propagation.MANDATORY)\n    public void updateStudent(){\n        Student student = new Student();\n        student.setSid(1);\n        student.setAge(25);\n        studentMapper.updateByPrimaryKeySelective(student);\n    }</code></pre>\n<p><strong>如上所示：</strong>updateSchool方法加事务，studentService.updateStudent方法加了事务，而且传播机制是MANDATORY，如果两者共用一个事务，都会回滚；</p>\n<p><strong>结果：</strong></p>\n<p>1.控制台报错</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\650f316f435c4e579ff462ffaf8ce9ef.png\"/></p>\n<p>2. updateSchool方法回滚（将北京大学刚改为湖南大学）</p>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"48\" src=\"image\\70d66a49e9c742938db0088f11011717.png\" width=\"433\"/></p>\n<p> 3.updateStudent方法回滚（将age改为25）</p>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"59\" src=\"image\\51d9fecb89304bb682c6bea1eb0da224.png\" width=\"325\"/></p>\n<p><strong>显然：</strong> 传播机制为MANDATORY，如果当前有事务，就使用当前事务；</p>\n<p></p>\n<h3 id=\"2.3.2%C2%A0%E5%A6%82%E6%9E%9C%E5%BD%93%E5%89%8D%E4%BA%8B%E5%8A%A1%E4%B8%8D%E5%AD%98%E5%9C%A8%EF%BC%8C%E5%88%99%E6%8A%9B%E5%87%BAException\">2.3.2 如果当前事务不存在，则抛出Exception</h3>\n<p>updateSchool方法更新id为1的name为“湖南大学”，location为“湖南”，没有事务；</p>\n<pre><code class=\"language-java\">    //@Transactional\n    public void updateSchool(){\n        School school = new School();\n        school.setId(1);\n        school.setName(\"湖南大学\");\n        school.setLocation(\"湖南\");\n        schoolMapper.updateByPrimaryKeySelective(school);\n        studentService.updateStudent();\n    }</code></pre>\n<p>updateStudent方法更新id为1的age为25，事务传播机制为MANDATORY；</p>\n<pre><code class=\"language-java\">    @Transactional(propagation = Propagation.MANDATORY)\n    public void updateStudent(){\n        Student student = new Student();\n        student.setSid(1);\n        student.setAge(25);\n        studentMapper.updateByPrimaryKeySelective(student);\n    }</code></pre>\n<p><strong>如上所示：</strong>updateSchool方法没有加事务，studentService.updateStudent方法加了事务，而且传播机制是MANDATORY，就看执行到updateStudent就不会报错；</p>\n<p><strong>结果：</strong></p>\n<p>1.控制台报错</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\c6f954051c1f4d07956580f077f309e4.png\"/></p>\n<p> org.springframework.transaction.IllegalTransactionStateException: No existing transaction found for transaction marked with propagation 'mandatory'</p>\n<p>2.updateSchool方法没有回滚（将北京大学刚改为湖南大学）</p>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"51\" src=\"image\\d9115d485971411e9f0767a51c92d999.png\" width=\"406\"/></p>\n<p> 3.pdateStudent方法直接报错： No existing transaction found for transaction marked with propagation 'mandatory'，传播机制为mandatory的，必须有当前事务存在，不存在就报错；</p>\n<p><strong>综上：</strong>传播机制为MANDATORY，支持使用当前事务，如果当前事务不存在，则抛出Exception。</p>\n<p></p>\n<h2 id=\"2.4%C2%A0REQUIRES_NEW\">2.4 REQUIRES_NEW</h2>\n<p>新建一个新事务；如果当前事务存在，把当前事务挂起。</p>\n<h3 id=\"2.4.1%20%E5%BD%93%E5%89%8D%E4%BA%8B%E5%8A%A1%E4%B8%8D%E5%AD%98%E5%9C%A8%EF%BC%8C%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%B0%E4%BA%8B%E5%8A%A1\">2.4.1 当前事务不存在，创建一个新事务</h3>\n<p>updateSchool方法更新id为1的name为“湖南大学”，location为“湖南”，没有事务；</p>\n<pre><code class=\"language-java\">    //@Transactional\n    public void updateSchool(){\n        School school = new School();\n        school.setId(1);\n        school.setName(\"湖南大学\");\n        school.setLocation(\"湖南\");\n        schoolMapper.updateByPrimaryKeySelective(school);\n        studentService.updateStudent();\n    }</code></pre>\n<p>updateStudent方法更新id为1的age为25，事务传播机制为REQUIRES_NEW，打印1/0，报错；</p>\n<pre><code class=\"language-java\">    @Transactional(propagation = Propagation.MANDATORY)\n    public void updateStudent(){\n        Student student = new Student();\n        student.setSid(1);\n        student.setAge(25);\n        studentMapper.updateByPrimaryKeySelective(student);\n        System.out.println(1/0);\n    }</code></pre>\n<p><strong>如上所示：</strong>updateSchool方法没有加事务，studentService.updateStudent方法加了事务，而且传播机制是REQUIRES_NEW，如果updateStudent方法新建了事务，打印1/0，报错就会回滚，如果没有新建事务，updateStudent方法就不会回滚；</p>\n<p><strong>结果：</strong></p>\n<p>1.控制台报错</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\e158194ee73d46a59a8ba7eed70a5786.png\"/></p>\n<p>2.updateSchool方法没有回滚，无事务执行（无事务这个说法其实不准确，任何操作数据库肯定是有事务的）； </p>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"52\" src=\"image\\ddf7616ec4174b94a4c8310ca50cd2ee.png\" width=\"414\"/></p>\n<p> 3. updateStudent方法回滚（将age改为25）</p>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"50\" src=\"image\\6809456aea9f4483b3c087fb49400412.png\" width=\"275\"/></p>\n<p><strong> 显然：</strong>传播机制为REQUIRES_NEW的，当前没有事务，就新建一个事务，在事务中运行；</p>\n<p></p>\n<h3 id=\"2.4.2%20%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%BA%8B%E5%8A%A1%EF%BC%8C%E5%BD%93%E5%89%8D%E4%BA%8B%E5%8A%A1%E5%AD%98%E5%9C%A8%EF%BC%8C%E6%8A%8A%E5%BD%93%E5%89%8D%E4%BA%8B%E5%8A%A1%E6%8C%82%E8%B5%B7\">2.4.2 新建一个事务，当前事务存在，把当前事务挂起</h3>\n<p>updateSchool方法更新id为1的name为“湖南大学”，location为“湖南”，有事务,打印1/0，报错；</p>\n<pre><code class=\"language-java\">    @Transactional\n    public void updateSchool(){\n        School school = new School();\n        school.setId(1);\n        school.setName(\"湖南大学\");\n        school.setLocation(\"湖南\");\n        schoolMapper.updateByPrimaryKeySelective(school);\n        studentService.updateStudent();\n        System.out.println(1/0);\n    }</code></pre>\n<p>updateStudent方法更新id为1的age为25，事务传播机制为REQUIRES_NEW；</p>\n<pre><code class=\"language-java\">    @Transactional(propagation = Propagation.REQUIRES_NEW)\n    public void updateStudent(){\n        Student student = new Student();\n        student.setSid(1);\n        student.setAge(25);\n        studentMapper.updateByPrimaryKeySelective(student);\n    }</code></pre>\n<p><strong>如上所示：</strong>updateSchool方法有加事务，studentService.updateStudent方法加了事务，而且传播机制是REQUIRES_NEW，如果updateStudent方法新建了另一个事务，updateSchool报错，updateStudent不会回滚，如果不是新建一个事务而是共用一个事务，就会一起回滚；</p>\n<p><strong>结果：</strong></p>\n<p>1.控制台报错</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\131409ab14de4eb1aa15d60dfc8219f3.png\"/></p>\n<p> 2.updateSchool方法回滚（将北京大学刚改为湖南大学）</p>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"43\" src=\"image\\075d89917559445ba7cfa305f6d5c5b7.png\" width=\"388\"/></p>\n<p> 3. updateStudent没有回滚（将age改为25）</p>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"49\" src=\"image\\f3d1fe0cbd4e4bb5affee6c269055bcc.png\" width=\"355\"/></p>\n<p><strong> 显然：</strong>updateStudent新建了另外一个事务，和updateSchool并不是共用一个事务；</p>\n<p><strong>总结：</strong>传播机制是REQUIRES_NEW，新建一个新事务；如果当前事务存在，把当前事务挂起。</p>\n<p>使用场景：被调用方法，不想因为调用方出错而回滚，可以使用REQUIRES_NEW；</p>\n<p></p>\n<h2 id=\"2.5%C2%A0NOT_SUPPORTED\">2.5 NOT_SUPPORTED</h2>\n<p>无事务执行，如果当前事务存在，把当前事务挂起。</p>\n<h3 id=\"2.5.1%20%E6%97%A0%E4%BA%8B%E5%8A%A1%E6%89%A7%E8%A1%8C\">2.5.1 无事务执行</h3>\n<p>updateSchool方法更新id为1的name为“湖南大学”，location为“湖南”，没有事务,打印1/0，报错；</p>\n<pre><code class=\"language-java\">    //@Transactional\n    public void updateSchool(){\n        School school = new School();\n        school.setId(1);\n        school.setName(\"湖南大学\");\n        school.setLocation(\"湖南\");\n        schoolMapper.updateByPrimaryKeySelective(school);\n        studentService.updateStudent();\n    }</code></pre>\n<p>updateStudent方法更新id为1的age为25，事务传播机制为NOT_SUPPORTED；</p>\n<pre><code class=\"language-java\">    @Transactional(propagation = Propagation.NOT_SUPPORTED)\n    public void updateStudent(){\n        Student student = new Student();\n        student.setSid(1);\n        student.setAge(25);\n        studentMapper.updateByPrimaryKeySelective(student);\n        System.out.println(1/0);\n    }</code></pre>\n<p><strong>如上所示：</strong>updateSchool方法没有事务，studentService.updateStudent方法加了事务，而且传播机制是NOT_SUPPORTED，如果updateStudent没有事务，那么在执行打印1/0报错后，也就不会回滚；</p>\n<p><strong>结果：</strong></p>\n<p>1.控制台报错</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\39434fb60791447f8c2f4671fb0d8be6.png\"/></p>\n<p>  2.updateSchool方法不回滚（将北京大学刚改为湖南大学）</p>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"51\" src=\"image\\39b9fc76f8194b1d997aa91ae1fba4c4.png\" width=\"406\"/></p>\n<p>  3. updateStudent没有回滚（将age改为25）</p>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"48\" src=\"image\\182a80322f3444f6a262d59a164bb63b.png\" width=\"347\"/></p>\n<p><strong> 显然：</strong>两个方法都没有在事务中运行，都没有回滚，所以，如果当前没有事务，NOT_SUPPORTED并不会新建一个事务，也是无事务执行；</p>\n<p></p>\n<h3 id=\"2.5.2%C2%A0%E5%A6%82%E6%9E%9C%E5%BD%93%E5%89%8D%E4%BA%8B%E5%8A%A1%E5%AD%98%E5%9C%A8%EF%BC%8C%E6%8A%8A%E5%BD%93%E5%89%8D%E4%BA%8B%E5%8A%A1%E6%8C%82%E8%B5%B7%E3%80%82\">2.5.2 如果当前事务存在，把当前事务挂起。</h3>\n<p>updateSchool方法更新id为1的name为“湖南大学”，location为“湖南”，有事务；</p>\n<pre><code class=\"language-java\">    @Transactional\n    public void updateSchool(){\n        School school = new School();\n        school.setId(1);\n        school.setName(\"湖南大学\");\n        school.setLocation(\"湖南\");\n        schoolMapper.updateByPrimaryKeySelective(school);\n        studentService.updateStudent();\n    }</code></pre>\n<p>updateStudent方法更新id为1的age为25，事务传播机制为NOT_SUPPORTED，打印1/0，报错；</p>\n<pre><code class=\"language-java\">    @Transactional(propagation = Propagation.NOT_SUPPORTED)\n    public void updateStudent(){\n        Student student = new Student();\n        student.setSid(1);\n        student.setAge(25);\n        studentMapper.updateByPrimaryKeySelective(student);\n        System.out.println(1/0);\n    }</code></pre>\n<p><strong>如上所示：</strong>updateSchool方法有事务，studentService.updateStudent方法加了事务，而且传播机制是NOT_SUPPORTED，如果updateStudent没有事务，那么在执行打印1/0报错后，也就不会回滚，而updateSchool检测到报错，如果当前事务有效，updateSchool就会回滚；</p>\n<p><strong>结果：</strong></p>\n<p>1.控制台报错</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\7e18e60de11a4a79ab72d3150899e19e.png\"/></p>\n<p> 2.updateSchool方法回滚（将北京大学刚改为湖南大学）</p>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"33\" src=\"image\\c1a66d46bf0c4692a0ee79f07d31b16f.png\" width=\"298\"/></p>\n<p>   3. updateStudent没有回滚（将age改为25）</p>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"42\" src=\"image\\e528973ed148448eb0ffbdabc79c0a3b.png\" width=\"304\"/></p>\n<p> <strong>显然：</strong>当前有事务的情况下，传播机制为NOT_SUPPORTED的方法无事务运行；</p>\n<p><strong>总结：</strong>事务传播机制为NOT_SUPPORTED，无事务执行，如果当前存在事务，把当前事务挂起；</p>\n<p><strong>使用场景：</strong>被调用方法想无事务运行，但又不影响调用方的事务，可以用NOT_SUPPORTED；</p>\n<p></p>\n<h2 id=\"2.6%C2%A0NEVER\">2.6 NEVER</h2>\n<p>无事务执行，如果当前有事务则抛出Exception。</p>\n<p>这个和MANDATORY就是两个完全相反的极端，一个强制不要事务，一个强制要事务，不满足都会报错；</p>\n<h3 id=\"2.6.1%20%E6%97%A0%E4%BA%8B%E5%8A%A1%E6%89%A7%E8%A1%8C\">2.6.1 无事务执行</h3>\n<p>updateSchool方法更新id为1的name为“湖南大学”，location为“湖南”，没有事务；</p>\n<pre><code class=\"language-java\">    //@Transactional\n    public void updateSchool(){\n        School school = new School();\n        school.setId(1);\n        school.setName(\"湖南大学\");\n        school.setLocation(\"湖南\");\n        schoolMapper.updateByPrimaryKeySelective(school);\n        studentService.updateStudent();\n    }\n</code></pre>\n<p>updateStudent方法更新id为1的age为25，事务传播机制为NEVER，打印1/0，报错；</p>\n<pre><code class=\"language-java\">    @Transactional(propagation = Propagation.NEVER)\n    public void updateStudent(){\n        Student student = new Student();\n        student.setSid(1);\n        student.setAge(25);\n        studentMapper.updateByPrimaryKeySelective(student);\n        System.out.println(1/0);\n    }</code></pre>\n<p><strong>如上所示：</strong>updateSchool方法没有事务，studentService.updateStudent方法加了事务，而且传播机制是NEVER，打印1/0，会报错，如果updateStudent是无事务执行，那么就不会回滚</p>\n<p><strong>结果：</strong></p>\n<p>1.控制台报错</p>\n<p><img alt=\"\" src=\"image\\7e18e60de11a4a79ab72d3150899e19e.png\"/></p>\n<p>2.updateSchool方法不回滚（将北京大学刚改为湖南大学）</p>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"49\" src=\"image\\6f5953f913c645868db0feb025394545.png\" width=\"390\"/></p>\n<p> 3.updateStudent没有回滚（将age改为25）</p>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"47\" src=\"image\\1d7a329786c542db94bb15eece795a03.png\" width=\"340\"/></p>\n<p>  <strong>显然：</strong>updateSchool和updateStudent都没有回滚，都是无事务执行，所以，传播机制为NEVER，如果当前没有事务，则无事务执行；</p>\n<p></p>\n<h3 id=\"2.6.2%C2%A0%E5%A6%82%E6%9E%9C%E5%BD%93%E5%89%8D%E6%9C%89%E4%BA%8B%E5%8A%A1%E5%88%99%E6%8A%9B%E5%87%BAException\">2.6.2 如果当前有事务则抛出Exception</h3>\n<p>updateSchool方法更新id为1的name为“湖南大学”，location为“湖南”，有事务；</p>\n<pre><code class=\"language-java\">    @Transactional\n    public void updateSchool(){\n        School school = new School();\n        school.setId(1);\n        school.setName(\"湖南大学\");\n        school.setLocation(\"湖南\");\n        schoolMapper.updateByPrimaryKeySelective(school);\n        studentService.updateStudent();\n    }</code></pre>\n<p>updateStudent方法更新id为1的age为25，事务传播机制为NEVER；</p>\n<pre><code class=\"language-java\">    @Transactional(propagation = Propagation.NEVER)\n    public void updateStudent(){\n        Student student = new Student();\n        student.setSid(1);\n        student.setAge(25);\n        studentMapper.updateByPrimaryKeySelective(student);\n    }</code></pre>\n<p><strong>如上所示：</strong>updateSchool方法有事务，studentService.updateStudent方法加了事务，而且传播机制是NEVER，当前有事务，就看执行updateStudent方法时到底报不报错；</p>\n<p><strong>结果：</strong></p>\n<p>1.控制台报错</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\6e4d3ef24c7d424db336e702a5733265.png\"/></p>\n<p>2.updateSchool方法回滚（将北京大学刚改为湖南大学）</p>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"34\" src=\"image\\c0a59767f82340ee80e409e168a4ca42.png\" width=\"307\"/></p>\n<p>3. updateStudent直接报错</p>\n<p>org.springframework.transaction.IllegalTransactionStateException: Existing transaction found for transaction marked with propagation 'never' </p>\n<p> <strong>显然：</strong>传播机制为NEVER，如果当前有事务，则报错；</p>\n<p><strong>总结：这种传播机制感觉没啥用途，哈哈，反正我是基本没用过；</strong></p>\n<p></p>\n<h2 id=\"2.7%C2%A0%C2%A0NESTED\">2.7  NESTED</h2>\n<p>嵌套事务，如果当前事务存在，那么在嵌套的事务中执行。如果当前事务不存在，则表现跟REQUIRED一样。</p>\n<p>这个直接说，如果父事务回滚，子事务也会跟着回滚；如果子事务回滚，并抛出异常，父事务肯定会跟着回滚；</p>\n<p>如果当前没有事务，就和REQUIRED,新建一个事务运行；</p>\n<p></p>\n<p>关于@Transactional注解的原理和事务传播机制的原理可以看我上一篇文章：</p>\n<p><a class=\"link-info\" href=\"https://mp.csdn.net/mp_blog/creation/editor/123899022\" title=\"深入理解@Transactional注解的使用和原理\">深入理解@Transactional注解的使用和原理</a></p>\n<p></p>\n</div>\n</div>"}