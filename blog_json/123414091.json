{"blogid": "123414091", "writerAge": "码龄1年", "writerBlogNum": "12", "writerCollect": "43", "writerComment": "3", "writerFan": "786", "writerGrade": "2级", "writerIntegral": "149", "writerName": "小马快跑Ma", "writerProfileAdress": "writer_image\\profile_123414091.jpg", "writerRankTotal": "139936", "writerRankWeekly": "485746", "writerThumb": "24", "writerVisitNum": "15288", "blog_read_count": "6606", "blog_time": "于 2022-03-10 23:19:42 发布", "blog_title": "导致锁表的原因及解决方法", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>一、导致锁表的原因</p>\n<p>1、锁表发生在insert  update 、delete 中；  </p>\n<p>2、锁表的原理是 数据库使用独占式封锁机制，当执行上面的语句时，对表进行锁住，直到发生commite 或者 回滚 或者退出数据库用户； </p>\n<p>3、锁表的原因 ：<br/>   <br/> 1)、A程序执行了对 tableA 的 insert ，并还未 commite时，B程序也对tableA 进行insert 则此时会发生资源正忙的异常 就是锁表；<br/>   <br/> 2)、锁表常发生于并发而不是并行（并行时，一个线程操作数据库时，另一个线程是不能操作数据库的，cpu 和i/o 分配原则）</p>\n<p>4、减少锁表的概率：<br/>    减少insert 、update 、delete 语句执行 到 commite 之间的时间。<br/> 具体点批量执行改为单个执行、优化sql自身的非执行速度<br/>    如果异常对事物进行回滚。</p>\n<p>二、mysql锁表的解决<br/> #查看进程id，然后用kill id杀掉进程<br/> show processlist;</p>\n<p>SELECT * FROM information_schema.PROCESSLIST；</p>\n<p>#查询正在执行的进程<br/> SELECT * FROM information_schema.PROCESSLIST where length(info) &gt;0 ;</p>\n<p><br/> #查询是否锁表<br/> show OPEN TABLES where In_use &gt; 0;</p>\n<p><br/> #查看被锁住的<br/> SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCKS;</p>\n<p>#等待锁定<br/> SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS;</p>\n<p>#杀掉锁表进程<br/> kill 5601</p>\n</div>\n</div>"}