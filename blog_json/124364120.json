{"blogid": "124364120", "writerAge": "码龄4年", "writerBlogNum": "8", "writerCollect": "32", "writerComment": "0", "writerFan": "2", "writerGrade": "1级", "writerIntegral": "96", "writerName": "rayzhang0225", "writerProfileAdress": "writer_image\\profile_124364120.jpg", "writerRankTotal": "120601", "writerRankWeekly": "697518", "writerThumb": "8", "writerVisitNum": "8269", "blog_read_count": "4987", "blog_time": "于 2022-04-23 20:53:00 发布", "blog_title": "redis持久化", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p></p>\n<div class=\"toc\">\n<h3>文章目录</h3>\n<ul><li><a href=\"#_5\">前言</a></li><li><a href=\"#RDB_12\">一、RDB</a></li><li><ul><li><a href=\"#1_13\">1、备份是如何进行的</a></li><li><a href=\"#2_20\">2、持久化过程</a></li><li><a href=\"#3_22\">3、触发方式</a></li><li><ul><li><a href=\"#_26\">自动触发</a></li><li><a href=\"#_42\">手动触发</a></li></ul>\n</li><li><a href=\"#4_57\">4、数据恢复</a></li><li><a href=\"#5rdb_61\">5、停止rdb持久化</a></li><li><a href=\"#6rdb_67\">6、rdb优点和缺点</a></li></ul>\n</li><li><a href=\"#AOF_80\">二、AOF</a></li><li><ul><li><a href=\"#1_81\">1、备份是如何进行的</a></li><li><a href=\"#2_84\">2、持久化过程</a></li><li><a href=\"#3_90\">3、开启设置</a></li><li><a href=\"#4RDBAOF_95\">4、RDB和AOF同时开启</a></li><li><a href=\"#5AOF_98\">5、AOF启动/修复/恢复</a></li><li><a href=\"#6AOF_121\">6、AOF同步频率设置</a></li><li><a href=\"#7AOF_134\">7、AOF优点和缺点</a></li></ul>\n</li><li><a href=\"#_151\">总结</a></li><li><a href=\"#References_157\">References</a></li></ul>\n</div>\n<p></p>\n<hr/>\n<h1><a id=\"_5\"></a>前言</h1>\n<p>由于 redis 是一个内存数据库，所谓内存数据库，就是将数据库中的内容保存在内存中，这与传统的MySQL，Oracle等关系型数据库直接将内容保存到硬盘中相比，内存数据库的读写效率比传统数据库要快的多（内存的读写效率远远大于硬盘的读写效率）。但是保存在内存中也随之带来了一个缺点，一旦断电或者宕机，那么内存数据库中的数据将会全部丢失.<br/> redis持久化是指在指定的时间间隔内将内存中的数据集快照(snapshotting)写入磁盘，恢复时是将快照文件读入内存 redis提供了两种持久化方式</p>\n<ol><li>RDB(Redis DataBase)</li><li>AOF(Append of File)</li></ol>\n<h1><a id=\"RDB_12\"></a>一、RDB</h1>\n<h2><a id=\"1_13\"></a>1、备份是如何进行的</h2>\n<ul><li>redis会单独创建一个子进程(使用fork函数)来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能</li><li>如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效</li><li>RDB的缺点是最后一次持久化后的数据可能丢失<br/> 注： <strong>fork函数的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等） 数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程。</strong></li></ul>\n<h2><a id=\"2_20\"></a>2、持久化过程</h2>\n<p><img alt=\"图片来源于尚硅谷\" src=\"image\\c553bb057fa949f080eb965815aca856.png\"/></p>\n<h2><a id=\"3_22\"></a>3、触发方式</h2>\n<ul><li>自动触发</li><li>手动触发</li></ul>\n<h3><a id=\"_26\"></a>自动触发</h3>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\5eacea159bd24fffaab8b9b0f7df32ba.png\"/></p>\n<ul><li> <p><strong>save</strong>：这里是用来配置触发 redis的 rdb 持久化条件，也就是什么时候将内存中的数据保存到硬盘。比如“save m n”。表示m秒内数据集存在n次修改时，自动触发bgsave（这个命令下面会介绍，手动触发RDB持久化的命令）</p> <pre><code class=\"prism language-python\">save <span class=\"token number\">20</span> <span class=\"token number\">3</span> 表示在<span class=\"token number\">20</span>秒内如果至少有<span class=\"token number\">3</span>个key发生变化，则保存\n</code></pre> <p>当然如果你只是用Redis的缓存功能，不需要持久化，那么你可以注释掉所有的 save 行来停用保存功能。可以直接一个空字符串来实现停用：save “”</p> </li><li> <p><strong>stop-writes-on-bgsave-error</strong>：默认值为yes。当启用了RDB且最后一次后台保存数据失败，Redis是否停止接收数据。这会让用户意识到数据没有正确持久化到磁盘上，否则没有人会注意到灾难（disaster）发生了。如果Redis重启了，那么又可以重新开始接收数据了。</p> </li><li> <p><strong>rdbcompression</strong> ：默认值是yes。对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用LZF算法进行压缩。如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能，但是存储在磁盘上的快照会比较大。</p> </li><li> <p><strong>rdbchecksum</strong> ：默认值是yes。在存储快照后，我们还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能。</p> </li><li> <p><strong>dbfilename</strong> ：设置快照的文件名，默认是 dump.rdb</p> </li><li> <p><strong>dir</strong>：设置快照文件的存放路径，这个配置项一定是个目录，而不能是文件名。默认是和当前配置文件保存在同一目录。</p> </li></ul>\n<p>也就是说通过在配置文件中配置的 save 方式，当实际操作满足该配置形式时就会进行 RDB 持久化，将当前的内存快照保存在 dir 配置的目录中，文件名由配置的 dbfilename 决定。</p>\n<h3><a id=\"_42\"></a>手动触发</h3>\n<p>手动触发Redis进行RDB持久化的命令有两种：</p>\n<p>1、<strong>save</strong></p>\n<p>该命令会阻塞当前Redis服务器，执行save命令期间，Redis不能处理其他命令，直到RDB过程完成为止。<br/> 显然该命令对于内存比较大的实例会造成长时间阻塞，这是致命的缺陷，为了解决此问题，Redis提供了第二种方式。</p>\n<p>2、<strong>bgsave</strong></p>\n<p>执行该命令时，Redis会在后台异步进行快照操作，快照同时还可以响应客户端请求。具体操作是Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短。基本上 Redis 内部所有的RDB操作都是采用 bgsave 命令。</p>\n<p><strong>ps:执行执行 flushall 命令，也会产生dump.rdb文件，但里面是空的.</strong></p>\n<h2><a id=\"4_57\"></a>4、数据恢复</h2>\n<p>将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可，redis就会自动加载文件数据至内存了。Redis 服务器在载入 RDB 文件期间，会一直处于阻塞状态，直到载入工作完成为止。</p>\n<h2><a id=\"5rdb_61\"></a>5、停止rdb持久化</h2>\n<pre><code class=\"prism language-powershell\">redis-<span class=\"token function\">cli</span> config <span class=\"token function\">set</span> save <span class=\"token string\">\"\"</span>\n</code></pre>\n<h2><a id=\"6rdb_67\"></a>6、rdb优点和缺点</h2>\n<ul><li>优点<br/> 1.RDB是一个非常紧凑(compact)的文件，它保存了redis 在某个时间点上的数据集。这种文件非常适合用于进行备份和灾难恢复。<br/> 2.生成RDB文件的时候，redis主进程会fork()一个子进程来处理所有保存工作，主进程不需要进行任何磁盘IO操作。<br/> 3.RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快</li><li>缺点<br/> 1、RDB方式数据没办法做到实时持久化/秒级持久化。因为bgsave每次运行都要执行fork操作创建子进程，属于重量级操作，如果不采用压缩算法(主进程 fork 出子进程，其实是共享一份真实的内存空间，但是为了能在记录快照的时候，也能让主线程处理写操作，采用的是 Copy-On-Write（写时复制）技术，只有需要修改的内存才会复制一份出来，所以内存膨胀到底有多大，看修改的比例有多大)，频繁执行成本过高(影响性能)<br/> 2、RDB文件使用特定二进制格式保存，Redis版本演进过程中有多个格式的RDB版本，存在老版本Redis服务无法兼容新版RDB格式的问题(版本不兼容)<br/> 3、在一定间隔时间做一次备份，所以如果redis意外down掉的话，就会丢失最后一次快照后的所有修改(数据有丢失)</li></ul>\n<h1><a id=\"AOF_80\"></a>二、AOF</h1>\n<h2><a id=\"1_81\"></a>1、备份是如何进行的</h2>\n<p>以日志的形式来记录每个写操作（增量保存），将Redis执行过的所有写指令记录下来(读操作不记录)， 只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p>\n<h2><a id=\"2_84\"></a>2、持久化过程</h2>\n<p>（1）客户端的请求写命令会被append追加到AOF缓冲区内；<br/> （2）AOF缓冲区根据AOF持久化策略[always,everysec,no]将操作sync同步到磁盘的AOF文件中；<br/> （3）AOF文件大小超过重写策略或手动重写时，会对AOF文件rewrite重写，压缩AOF文件容量；<br/> （4）Redis服务重启时，会重新load加载AOF文件中的写操作达到数据恢复的目的；<br/> <img alt=\"在这里插入图片描述\" src=\"image\\be9f67909333417d8d5c33ed4140b943.png\"/></p>\n<h2><a id=\"3_90\"></a>3、开启设置</h2>\n<p>AOF默认不开启，需要将appendonly 设置成yes<br/> <img alt=\"在这里插入图片描述\" src=\"image\\0323902be7db434a9ca64678edaa50d9.png\"/><br/> <strong>PS:AOF文件的保存路径，同RDB的路径一致</strong></p>\n<h2><a id=\"4RDBAOF_95\"></a>4、RDB和AOF同时开启</h2>\n<p>AOF和RDB同时开启，系统默认取AOF的数据（数据不会存在丢失）</p>\n<h2><a id=\"5AOF_98\"></a>5、AOF启动/修复/恢复</h2>\n<ul><li> <p>启动</p> <p>AOF的备份机制和性能虽然和RDB不同, 但是备份和恢复的操作同RDB一样，都是拷贝备份文件，需要恢复时再拷贝到Redis工作目录下，启动系统即加载。</p> </li><li> <p>正常恢复</p>\n<ol><li> <p>修改默认的appendonly no，改为yes</p> </li><li> <p>将有数据的aof文件复制一份保存到对应目录(查看目录：config get dir)</p> </li><li> <p>恢复：重启redis然后重新加载</p> </li></ol> </li><li> <p>异常恢复</p>\n<ol><li> <p>修改默认的appendonly no，改为yes</p> </li><li> <p>如遇到AOF文件损坏，通过/usr/local/bin/redis-check-aof–fix appendonly.aof进行恢复</p> </li><li> <p>备份被写坏的AOF文件</p> </li><li> <p>恢复：重启redis，然后重新加载</p> </li></ol> </li></ul>\n<h2><a id=\"6AOF_121\"></a>6、AOF同步频率设置</h2>\n<ul><li> <p><strong>appendfsync always</strong></p> <p>始终同步，每次Redis的写入都会立刻记入日志；性能较差但数据完整性比较好</p> </li><li> <p><strong>appendfsync everysec</strong></p> <p>每秒同步，每秒记入日志一次，如果宕机，本秒的数据可能丢失。</p> </li><li> <p><strong>appendfsync no</strong></p> <p>redis不主动进行同步，把同步时机交给操作系统。</p> </li></ul>\n<h2><a id=\"7AOF_134\"></a>7、AOF优点和缺点</h2>\n<ul><li> <p><strong>优点</strong></p>\n<ol><li>备份机制更稳健，丢失数据概率更低。</li><li>可读的日志文本，通过操作AOF稳健，可以处理误操作。</li></ol> </li><li> <p>缺点</p>\n<ol><li> <p>比起RDB占用更多的磁盘空间。</p> </li><li> <p>恢复备份速度要慢。</p> </li><li> <p>每次读写都同步的话，有一定的性能压力。</p> </li><li> <p>存在个别Bug，造成恢复不能。</p> </li></ol> </li></ul>\n<h1><a id=\"_151\"></a>总结</h1>\n<p>官方推荐两个都启用；<br/> 如果对数据不敏感，可以选单独用RDB；<br/> 不建议单独用 AOF，因为可能会出现Bug；<br/> 如果只是做纯内存缓存，可以都不用。</p>\n<h1><a id=\"References_157\"></a>References</h1>\n<ul><li><a href=\"https://www.cnblogs.com/ysocean/p/9114268.html\">RDB持久化</a></li></ul>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}