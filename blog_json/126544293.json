{"blogid": "126544293", "writerAge": "码龄1年", "writerBlogNum": "57", "writerCollect": "99", "writerComment": "3", "writerFan": "8", "writerGrade": "3级", "writerIntegral": "597", "writerName": "lans_g", "writerProfileAdress": "writer_image\\profile_126544293.jpg", "writerRankTotal": "29485", "writerRankWeekly": "18882", "writerThumb": "21", "writerVisitNum": "28468", "blog_read_count": "800", "blog_time": "于 2022-08-26 15:27:37 发布", "blog_title": "mysql中count（）函数用法：count（1）和count（*）有什么区别？", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-light\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h3><a id=\"countcount1count_0\"></a>count（*）、count（1）、count（字段）都有什么区别？</h3>\n<p>在我们的日常开发中，经常会遇到计算一张表的行数的情况，通常情况下我们使用一条<code>select count(*) from t </code>语句就完事了。但是大家也可能看到count（）函数的别的用法，比如<code>count（1）</code>、<code>count（字段名）</code>，那么他们和<code>count（*）</code>有什么区别呢？<code>count（*）</code>又是如何进行查询得到我们要的数据呢？本文就带大家一一揭晓。</p>\n<br/>\n<h3><a id=\"count_6\"></a>一、count（*）是如何实现的</h3>\n<p>首先我们要知道，在不同的存储引擎中，count（*）的实现是不一样的。以<code>select count(*) from t</code>这条语句来说：</p>\n<ul><li>在MyISAM中，由于每个表的总行数会作为一个变量存储在磁盘上，所以执行查询的时候只用返回这个变量的值就好了，查询速度比较快；</li><li>而对于我们常用的InnoDB来说，它会一行一行的将数据读取出来，然后对读取的数据进行累计计数，最后得到结果，查询会慢一些；</li></ul>\n<p>这里大家可能就想到了，为什么InnoDB不像MyISAM那样也将总行数存储起来呢？</p>\n<p>注意了，我们这里的读是<strong>快照读</strong>，对于<strong>快照读</strong>来说，InnoDB是通过<strong>MVCC</strong>进行控制的，也就是说我们是可能会读取到历史数据的，<strong>因此读取的总行数并不是确定的</strong>，当然不能一视同仁的返回同一个值了。</p>\n<blockquote>\n<p>如果你还不了解MVCC，可以看我的这篇文章：<a href=\"https://blog.csdn.net/lans_g/article/details/124232192?ops_request_misc=%7B%22request%5Fid%22%3A%22166149862816782395328274%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fblog.%22%7D&amp;request_id=166149862816782395328274&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-124232192-null-null.nonecase&amp;utm_term=mvcc&amp;spm=1018.2226.3001.4450\">MVCC详解，深入浅出简单易懂_lans_g的博客-CSDN博客_mvcc</a></p>\n</blockquote>\n<p>InnoDB的设计者当然也意识到了这个问题，所以他对count（*）操作进行了一定的优化。</p>\n<p>对于上面的这条查询语句来说，无非就是要得到表的总行数嘛，表中的字段值我们并不关心。InnoDB是索引组织表，主键索引树的叶子节点是数据，而普通索引树的叶子节点是主键值。所以，<strong>普通索引树比主键索引树小很多</strong>。对于count(*)这样的操作，遍历哪个索引树得到的结果逻辑上都是一样的。因此，<strong>MySQL优化器会找到最小的那棵索引树来遍历</strong>，这样就提高了检索效率。</p>\n<p>count（参数）是一个聚合函数，对于某一个结果集逐行进行判断，如果该行<strong>参数不为null</strong>，则+1，最后返回累计值。由于count（*）肯定不为null，所以经过优化后，在进行<strong>查询时并不会取出字段的值</strong>，而是逐行进行累加，有多少行就返回几。</p>\n<br/>\n<h3><a id=\"count1count_27\"></a>二、对比count（1）、count（字段名）</h3>\n<p>除了count（*），大家可能会看到这样的写法：count（1）。这是什么意思呢？</p>\n<p>对于<code>count（1）</code>来说，InnoDB遍历整张表的时候，同样<strong>不会取出字段的值</strong>，而是对于返回的每一行后面加一个数字“1”，然后按行累加。是不是和count（*）很类似？事实上，他们的执行效率也是差不多的。</p>\n<p>上文我们说了，<code>count（参数）</code>函数会对参数不为null的行进行计数，因此对于<code>count（字段）</code>来说，会<strong>先读取该字段中的值</strong>，<strong>判断不为null后</strong>，再累加。</p>\n<br/>\n<h3><a id=\"_37\"></a>三、总结一下</h3>\n<p>由于count（1）和count（*）并不会取出字段中的值，因此效率是比较高的，如果按照效率排序的话：</p>\n<p><strong>count(字段)&lt;count(1)≈count( * )</strong>。</p>\n<p>不过既然count（ * ）已经优化了这么多，推荐大家使用count（*）就好了。</p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}