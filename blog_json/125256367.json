{"blogid": "125256367", "writerAge": "码龄3年", "writerBlogNum": "47", "writerCollect": "59", "writerComment": "2", "writerFan": "7", "writerGrade": "3级", "writerIntegral": "497", "writerName": "源世界yu", "writerProfileAdress": "writer_image\\profile_125256367.jpg", "writerRankTotal": "40666", "writerRankWeekly": "368362", "writerThumb": "13", "writerVisitNum": "22911", "blog_read_count": "2594", "blog_time": "已于 2022-06-21 13:44:57 修改", "blog_title": "CMake 常用总结二：CMake 生成静态库与动态库", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<blockquote>\n<p>引言</p>\n<p>CMake 实践帮助我们对 CMake 有一个系统全面的了解，并且有大量示例以供参考，至少在实际项目中可以让我们有能力看懂并修改项目中现有的 CMake 。</p>\n<p>阅读完 CMake 实践文档，认为自己的任务也就结束了，可这样总感觉不是自己的东西，不如整理一下并吸收其中自己认为最有用的东西，这样也能极大的减轻自己的记忆负担。</p>\n<p>与此同时 CMake 实践行文组织过于复杂，不方便遇到问题时快速查阅，所以我做了一些调整与总结，希望能够对读者更加友好。</p>\n<p>本文不能代替 CMake 实践文档，有时间还是把 CMake 实践文档认真阅读一遍。</p>\n</blockquote>\n<h2><a id=\"CMake__10\"></a>CMake 生成库</h2>\n<p>假设我们存在一个这样的任务：</p>\n<ol><li>建立一个静态库和动态库，提供 HelloFunc 函数以供其他程序编程使用，HelloFunc 向终端输出 Hello World 字符串。</li><li>安装头文件与共享库。</li></ol>\n<p>静态库和动态库的区别</p>\n<ul><li>静态库的扩展名一般为“.a”或“.lib”；动态库的扩展名一般为“.so”或“.dll”。</li><li>静态库在编译时会直接整合到目标程序中，编译成功的可执行文件可独立运行（如果程序编译成功，即使离开静态库，程序也是可以独立运行）。</li><li>动态库在编译时不会放到连接的目标程序中，即可执行文件无法单独运行（如果程序编译成功，必须要有动态库的存在程序才可以运行，比如使用windows运行一些游戏程序时，会报缺少 .dll 文件的错误，导致程序无法正常运行，其实就是缺少动态库）。</li></ul>\n<h3><a id=\"CMake__27\"></a>CMake 生成库简单实例</h3>\n<p>按照惯例，我们先来一个简单地实例，以便对 CMake 生成库有一个直观的了解。</p>\n<ol><li> <p>创建以下工程结构</p> <pre><code class=\"prism language-shell\">yxm@192:~/test3$ tree\n<span class=\"token builtin class-name\">.</span>\n├── build\n├── CMakeLists.txt\n└── lib\n    ├── CMakeLists.txt\n    ├── hello.cpp\n    └── hello.h\n\n<span class=\"token number\">2</span> directories, <span class=\"token number\">4</span> files\n</code></pre> </li><li> <p>hello.h中的内容</p> <pre><code class=\"prism language-c++\">#ifndef HELLO_H\n#define Hello_H\n\nvoid HelloFunc();\n\n#endif\n</code></pre> </li><li> <p>hello.cpp中的内容</p> <pre><code class=\"prism language-c++\">#include &lt;iostream&gt;\n#include \"hello.h\"\n\nvoid HelloFunc(){\n    std::cout &lt;&lt; \"Hello World\" &lt;&lt; std::endl;\n}\n</code></pre> </li><li> <p>项目中的cmake内容</p> <pre><code class=\"prism language-cmake\">PROJECT(HELLO)\nADD_SUBDIRECTORY(lib bin)\n</code></pre> </li><li> <p>lib中CMakeLists.txt中的内容</p> <pre><code class=\"prism language-cmake\">SET(LIBHELLO_SRC hello.cpp)\nADD_LIBRARY(hello SHARED ${LIBHELLO_SRC})\n</code></pre> <p>ADD_LIBRARY 指令详细可见下文 CMake 语法。</p> </li><li> <p>外部编译过程：</p>\n<ol><li> <p>进入 build，运行 cmake …</p> </li><li> <p>在 build 目录下，运行 make 命令编译 Makefile 文件，并生成动态库。</p> <p><img alt=\"在这里插入图片描述\" src=\"image\\d23a1301a2124d98a0343b6c3032c475.png\"/></p> </li></ol> </li></ol>\n<h3><a id=\"CMake__95\"></a>CMake 同时构建静态库与动态库</h3>\n<h4><a id=\"_97\"></a>生成动态库与静态库</h4>\n<p>有上面的例子可以看出，使用 ADD_LIBRARY 指令就可以同时构建静态和动态库：</p>\n<pre><code class=\"prism language-cmake\">ADD_LIBRARY(hello SHARED ${LIBHELLO_SRC})\nADD_LIBRARY(hello STATIC ${LIBHELLO_SRC})\n</code></pre>\n<p>但是如果使用这种方式，只会构建一个动态库，不会构建出静态库，虽然静态库的后缀是.a，此时我们可以修改静态库的名字，这样是可以同时构建动态库和静态库：</p>\n<pre><code class=\"prism language-cmake\">ADD_LIBRARY(hello SHARED ${LIBHELLO_SRC})\nADD_LIBRARY(hello_static STATIC ${LIBHELLO_SRC})\n</code></pre>\n<p>但是我们往往<strong>希望他们的名字是相同的，只是后缀不同而已</strong>，此时可以使用 SET_TARGET_PROPERTIES 指令（该指令详细可见下文 CMake 语法），修改lib目录下CMakeLists.txt文件：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token function\">SET</span><span class=\"token punctuation\">(</span>LIBHELLO_SRC hello<span class=\"token punctuation\">.</span>cpp<span class=\"token punctuation\">)</span>\n\n<span class=\"token function\">ADD_LIBRARY</span><span class=\"token punctuation\">(</span>hello_static STATIC $<span class=\"token punctuation\">{<!-- --></span>LIBHELLO_SRC<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n# 对hello_static的重名为hello\n<span class=\"token function\">SET_TARGET_PROPERTIES</span><span class=\"token punctuation\">(</span>hello_static PROPERTIES  OUTPUT_NAME <span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span> <span class=\"token directive keyword\">cmake</span> <span class=\"token expression\">在构建一个新的target 时，会尝试清理掉其他使用这个名字的库，如果没有清理还是会只会构建一个动态库，不会构建出静态库</span></span>\n<span class=\"token function\">SET_TARGET_PROPERTIES</span><span class=\"token punctuation\">(</span>hello_static PROPERTIES CLEAN_DIRECT_OUTPUT <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token function\">ADD_LIBRARY</span><span class=\"token punctuation\">(</span>hello SHARED $<span class=\"token punctuation\">{<!-- --></span>LIBHELLO_SRC<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    \n# 对hello_static的重名为hello\n<span class=\"token function\">SET_TARGET_PROPERTIES</span><span class=\"token punctuation\">(</span>hello PROPERTIES  OUTPUT_NAME <span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token function\">SET_TARGET_PROPERTIES</span><span class=\"token punctuation\">(</span>hello PROPERTIES CLEAN_DIRECT_OUTPUT <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n\n</code></pre>\n<p>外部编译过程：</p>\n<ol><li> <p>进入 build，运行 cmake …</p> </li><li> <p>在 build 目录下，运行 make 命令编译 Makefile 文件，并生成动态库与静态库。</p> <p><img alt=\"在这里插入图片描述\" src=\"image\\2345faf57aa14daead6a6a718a042414.png\"/></p> </li></ol>\n<h4><a id=\"_144\"></a>修改动态库版本号</h4>\n<p>同时我们还可以修改动态库的版本号</p>\n<pre><code class=\"prism language-c++\">// 一般动态库都有一个版本号的关联\nlibhello.so.1.2\nlibhello.so -&gt;libhello.so.1\nlibhello.so.1-&gt;libhello.so.1.2\n</code></pre>\n<p>修改 lib/CMakeLists.txt ，重新构建看看结果：</p>\n<pre><code class=\"prism language-cmake\">SET(LIBHELLO_SRC hello.cpp)\n\nADD_LIBRARY(hello_static STATIC ${LIBHELLO_SRC})\n\nSET_TARGET_PROPERTIES(hello_static PROPERTIES  OUTPUT_NAME \"hello\")\n\nSET_TARGET_PROPERTIES(hello_static PROPERTIES CLEAN_DIRECT_OUTPUT 1)\n\n\nADD_LIBRARY(hello SHARED ${LIBHELLO_SRC})\n    \nSET_TARGET_PROPERTIES(hello PROPERTIES  OUTPUT_NAME \"hello\")\nSET_TARGET_PROPERTIES(hello PROPERTIES CLEAN_DIRECT_OUTPUT 1)\nSET_TARGET_PROPERTIES(hello PROPERTIES VERSION 1.2 SOVERSION 1)\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\6311a818ee304aa5a726ff0bcc6d601a.png\"/></p>\n<h4><a id=\"_179\"></a>安装共享库和头文件</h4>\n<p>本例中我们将 hello 的共享库安装到 &lt;prefix&gt;/lib 目录；将 hello.h 安装到 &lt;prefix&gt;/include/hello 目录，这样共享库才能够被调用。</p>\n<p>修改lib目录下CMakeLists.txt文件：</p>\n<pre><code class=\"prism language-cmake\">SET(LIBHELLO_SRC hello.cpp)\n\nADD_LIBRARY(hello_static STATIC ${LIBHELLO_SRC})\n\nSET_TARGET_PROPERTIES(hello_static PROPERTIES  OUTPUT_NAME \"hello\")\n\nSET_TARGET_PROPERTIES(hello_static PROPERTIES CLEAN_DIRECT_OUTPUT 1)\n\n\nADD_LIBRARY(hello SHARED ${LIBHELLO_SRC})\n    \nSET_TARGET_PROPERTIES(hello PROPERTIES  OUTPUT_NAME \"hello\")\nSET_TARGET_PROPERTIES(hello PROPERTIES CLEAN_DIRECT_OUTPUT 1)\n    \n# 文件放到该目录下\nINSTALL(FILES hello.h DESTINATION include/hello)\n\n# 二进制，静态库，动态库安装都用TARGETS\n# ARCHIVE 特指静态库，LIBRARY 特指动态库，RUNTIME 特指可执行目标二进制。\nINSTALL(TARGETS hello hello_static LIBRARY DESTINATION lib ARCHIVE DESTINATION lib)\n</code></pre>\n<p>外部编译过程：</p>\n<ol><li> <p>进入 build，运行 cmake -DCMAKE_INSTALL_PREFIX=/usr …</p> <p>注意：安装的时候，指定一下路径，放到系统下，-D之后加不加空格都可。</p> <p>注意：直接安装在 usr 系统目录下，以便后续可以直接调用</p> </li><li> <p>在 build 目录下，运行 make 命令编译 Makefile 文件，并生成动态库与静态库。</p> </li><li> <p>在 build 目录下，运行 make install</p> <p><img alt=\"在这里插入图片描述\" src=\"image\\454c05b4d1ca4a7f876d3399f79c63d0.png\"/></p> </li></ol>\n<h4><a id=\"_225\"></a>使用外部动态库和头文件</h4>\n<ol><li> <p>新建一个目录来使用外部共享库和头文件，创建以下工程结构：</p> <pre><code class=\"prism language-shell\">yxm@192:~/test4$ tree\n<span class=\"token builtin class-name\">.</span>\n├── build\n├── CMakeLists.txt\n└── src\n    ├── CMakeLists.txt\n    └── main.cpp\n\n<span class=\"token number\">2</span> directories, <span class=\"token number\">3</span> files\n</code></pre> </li><li> <p>main.cpp中的内容</p> <pre><code class=\"prism language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;hello.h&gt;</span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token function\">HelloFunc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre> </li><li> <p>项目中的CMakeLists.txt内容</p> <pre><code class=\"prism language-cmake\">PROJECT(HELLO)\nADD_SUBDIRECTORY(src bin)\n</code></pre> </li><li> <p>src中CMakeLists.txt中的内容</p> <pre><code class=\"prism language-cmake\">ADD_EXECUTABLE(hello main.cpp)\n</code></pre> </li><li> <p>外部编译过程：</p>\n<ol><li> <p>进入 build，运行 cmake …</p> </li><li> <p>在 build 目录下，运行 make 命令编译 Makefile 文件。注意此时 make 会报错：</p> <p><img alt=\"在这里插入图片描述\" src=\"image\\f5840724268b4c35a1f9e41d069b208a.png\"/></p> </li></ol> </li></ol>\n<p><strong>解决：make 后头文件找不到的问题</strong></p>\n<p>make 时会提示找不到头文件，两种解决方法：</p>\n<ol><li>修改成 include &lt;hello/hello.h&gt; ，但这样修改代码冗余。</li><li>当然也可以使用一下关键字：INCLUDE_DIRECTORIES （详细见下文 CMake 语法）</li></ol>\n<p>这里使用第二种方法，在src下的 CMakeLists.txt 文件中加入头文件搜索路径：</p>\n<pre><code class=\"prism language-cmake\">INCLUDE_DIRECTORIES(/usr/include/hello)\nADD_EXECUTABLE(hello main.cpp) \n</code></pre>\n<p>外部编译过程：</p>\n<ol><li> <p>进入 build，运行 cmake …</p> </li><li> <p>在 build 目录下，运行 make 命令编译 Makefile 文件。注意此时还是 make 会报错：</p> <p><img alt=\"在这里插入图片描述\" src=\"image\\7a55f958411148eaba79664ad28d28c9.png\"/></p> </li></ol>\n<p><strong>解决：找到引用的函数问题</strong></p>\n<p>报错信息：undefined reference to `HelloFunc()'，所以我们需要将 .so 文件关联起来。</p>\n<p>解决方法有两种：</p>\n<ul><li> <p>关键字：LINK_DIRECTORIES 添加非标准的共享库搜索路径</p> <p>指定第三方库所在路径，LINK_DIRECTORIES(/home/myproject/libs)</p> </li><li> <p>关键字：TARGET_LINK_LIBRARIES 添加需要链接的共享库（详细见下文 CMake 语法）</p> </li></ul>\n<p>​ TARGET_LINK_LIBRARIES 的时候，只需要给出动态链接库的名字就行了。</p>\n<p>这里使用第二种方法，在src下的 CMakeLists.txt 文件中添加需要链接的共享库（主要要插在executable的后面）：</p>\n<pre><code class=\"prism language-cmake\">INCLUDE_DIRECTORIES(/usr/include/hello)\nADD_EXECUTABLE(hello main.cpp) \nTARGET_LINK_LIBRARIES(hello libhello.so)\n</code></pre>\n<p>外部编译过程：</p>\n<ol><li> <p>进入 build，运行 cmake …</p> </li><li> <p>在 build 目录下，运行 make 命令编译 Makefile 文件。</p> </li><li> <p>在 build/bin 目录下，运行 ./hello ，执行结果如下：</p> <pre><code class=\"prism language-shell\">yxm@192:~/test4/build$ <span class=\"token builtin class-name\">cd</span> bin/\nyxm@192:~/test4/build/bin$ ./hello \nHello World\n</code></pre> </li><li> <p>注意：如果你的 linux 虚拟机是64位会报错，需要移动动态库到64位下：<br/> <img alt=\"在这里插入图片描述\" src=\"image\\afd9a32006f740f0bbfe3d354d9ee29d.png\"/></p> </li></ol>\n<h4><a id=\"_342\"></a>使用外部静态库</h4>\n<p>上面的例子使用的是外部动态库，如果想要使用外部静态库，步骤也是相同的，只需要将上面例子中.so换成.a即可，不过使用外部静态库不需要头文件。</p>\n<p><code>TARGET_LINK_LIBRARIES(main libhello.a)</code></p>\n<p><strong>补充：</strong></p>\n<p>特殊的环境变量 CMAKE_INCLUDE_PATH 和 CMAKE_LIBRARY_PATH</p>\n<p>注意：这两个是环境变量而不是 cmake 变量，可以在linux的bash中进行设置</p>\n<p>我们上面例子中使用了绝对路径INCLUDE_DIRECTORIES(/usr/include/hello)来指明include路径的位置，我们还可以使用另外一种方式，使用环境变量export CMAKE_INCLUDE_PATH=/usr/include/hello</p>\n<h3><a id=\"CMake__360\"></a>CMake 语法</h3>\n<p><strong>（1）ADD_LIBRARY 语法</strong></p>\n<p>ADD_LIBRARY(hello SHARED ${LIBHELLO_SRC})</p>\n<ul><li>hello：就是正常的库名，生成的名字前面会加上lib，最终产生的文件是libhello.so</li><li>SHARED，动态库 STATIC，静态库</li><li>${LIBHELLO_SRC} ：源文件</li></ul>\n<p><strong>（2）SET_TARGET_PROPERTIES 语法</strong></p>\n<p>这条指令可以用来设置输出的名称，对于动态库，还可以用来指定动态库版本和 API 版本</p>\n<ul><li> <p>对hello_static的重名为hello，例如：SET_TARGET_PROPERTIES(hello_static PROPERTIES OUTPUT_NAME “hello”)</p> </li><li> <p>指定动态库版本和 API 版本，例如：SET_TARGET_PROPERTIES(hello PROPERTIES VERSION 1.2 SOVERSION 1)</p> <p>其中VERSION 指代动态库版本，SOVERSION 指代 API 版本。</p> </li></ul>\n<p><strong>（3）INCLUDE_DIRECTORIES 语法</strong></p>\n<p>找头⽂件：可以用来向工程添加多个特定的头文件搜索路径，路径之间用空格分割</p>\n<p><strong>（4）TARGET_LINK_LIBRARIES 语法</strong></p>\n<p>TARGET_LINK_LIBRARIES 用于从链接库到执⾏⽂件上</p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}