{"blogid": "126584886", "writerAge": "码龄4年", "writerBlogNum": "407", "writerCollect": "3101", "writerComment": "195", "writerFan": "2172", "writerGrade": "7级", "writerIntegral": "9019", "writerName": "前端技术栈", "writerProfileAdress": "writer_image\\profile_126584886.jpg", "writerRankTotal": "1504", "writerRankWeekly": "804", "writerThumb": "412", "writerVisitNum": "769872", "blog_read_count": "408", "blog_time": "于 2022-08-29 14:53:25 发布", "blog_title": "【面试题】面试官：请你实现一个深拷贝，那如果是正则/set/函数怎么拷贝？", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/6d6c1c34596a6680f47d8223b68d24e8.webp?x-oss-process=image/format,png\"/></p>\n<h2>一、面试官灵魂三连问：</h2>\n<ol><li>你知道哪些拷贝的方法？</li><li>让你实现一个深拷贝怎么实现？</li><li>那像正则、Set、Map、函数等如何拷贝？</li></ol>\n<h2>二、浅拷贝方法</h2>\n<p>自己创建一个新对象，来接收你要重新复制或引用的对象值。如果对象属性是基本数据类型，复制的就是基本数据类型的值给新对象；如果属性是引用数据类型，复制的就是内存中的地址，如果一个对象改变了这个属性值，那么会影响到另一个对象。</p>\n<h3>1.Object.assign()</h3>\n<ul><li>不会拷贝对象的继承属性</li><li>不会拷贝对象的不可枚举属性</li><li>可以拷贝symbol类型</li></ul>\n<h3>扩展：什么是对象的不可枚举属性？</h3>\n<p><br/> 对象的每一个属性都有一个描述对象，用来描述和控制该对象的属性行为<br/> 使用Object.getOwnPropertyDescriptor() 方法来获取描述对象<br/> 通过Object.definedProperty() 来设置-----是不是很熟悉，这是vue中数据绑定的方法</p>\n<p><br/> 例如</p>\n<pre><code class=\"language-javascript\">let obj = {\n    name : '123'\n}\nconsole.log(Object.getOwnPropertyDescriptor(obj,'name'))\n/*\n  输出内容\n  configurable：true 能否通过delete删除此属性\n  enumerable ： true  表示属性是可以枚举 即是否通过for in 或 Object.keys() 返回属性\n  value: '123'\n  writable: true 表示能否修改属性的值\n*/\n\n// 设置属性\nObject.defineProperty(obj,'名字',{\n    value:'不可枚举属性',\n    enumerable:false\n})\n</code></pre>\n<h3>扩展：如何知道是“不可枚举属性”？</h3>\n<pre><code class=\"language-javascript\">// 方法一：看颜色\nconsole.log(obj)\n/*\n  输出：\n  {\n    name: \"123\" // 控制台里是深色字体\n    名字: \"不可枚举属性\" // 控制台里是浅色字体\n  }\n*/\n// 方法二：使用以下四个方法\n/*\n  四个操作会忽略enumerable为false\n  for in \n  Object.keys()\n  Object.assign()\n  JSON.stringify()\n*/\n// 我们实测下\nfor(let prop in obj){\n  console.log(prop)\n}\n/*\n  输出:name\n*/\nconsole.log(Object.keys(obj))\n/*\n  输出: ['name']\n*/\nconsole.log(Object.assign({},obj))\n/*\n  输出: {name: '123'}\n*/\nconsole.log(JSON.stringify(obj))\n/*\n  输出: '{\"name\":\"123\"}'\n*\n</code></pre>\n<h3>2.扩展运算符方式</h3>\n<pre><code class=\"language-javascript\">let obj2 = {...obj1}\nlet arr2 = [...arr1] //跟arr.slice()一样的效果\n</code></pre>\n<h3>3.concat拷贝</h3>\n<pre><code class=\"language-javascript\">let arr1 = [1,2,3]\nlet arr2 = arr1.concat()\n</code></pre>\n<h3>4.slice拷贝数组</h3>\n<pre><code class=\"language-javascript\">let arr1 = [1,2,3]\nlet arr2 = arr1.slice()\n</code></pre>\n<h3>手动实现浅拷贝</h3>\n<pre><code class=\"language-javascript\">var deepClone = target =&gt; {\n    //判断是否是对象类型，不是对象类型的话，直接返回本身\n  if ((typeof target === \"object\" || typeof target === 'function') &amp;&amp; target !== null) {\n      //判断目标是数组还是对象\n    const cloneTarget = Array.isArray(target) ? [] : {};\n    for (let prop in target) {\n        //只拷贝自身属性，不拷贝继承属性，所以使用hasOwnProperty(),当属性是继承属性则返回false\n      if (target.hasOwnProperty(prop)) {\n        cloneTarget[prop] = target[prop];\n      }\n    }\n    return cloneTarget;\n  } else {\n    return target;\n  }\n};\n</code></pre>\n<h2>三、深拷贝实现方法</h2>\n<h3>1. JSON.stringify() 实现深拷贝</h3>\n<pre><code class=\"language-javascript\">JSON.parse(JSON.stringify(target)) \n</code></pre>\n<p>缺点：<br/> 1：拷贝的对象中如果存在undefined，function，symbol这几种类型，经过JSON.stringify()序列化后的字符串的这几个键会消失。<br/> 2: 拷贝Date引用类型会变成字符串<br/> 3: 无法拷贝不可枚举属性<br/> 4: 无法拷贝对象的原型链<br/> 5: 拷贝RexExp引用类型会变成空对象<br/> 6: 含有NaN,Infinity,-Infinity 经过JSON序列化后会变成null<br/> 7: 无法拷贝对象循环引用，记对象成环。</p>\n<h3>2.递归实现深拷贝</h3>\n<pre><code class=\"language-javascript\">function deepCopy(target) {\n  if((typeof target !== 'object' || typeof target !== 'function') &amp;&amp; target === null) return false\n    let res = Array.isArray(target) ? [] : {}\n      for(let k in target) {\n        // 如果目标数据上有属性（键）(key)\n        if(target.hasOwnProperty(k)) {\n          // 如果目标数据上属性的值，为object，就递归，不是object，就取到属性值，并放入我们新建的空数组/对象中\n          res[k] = typeof target[k] === 'object' ? deepCopy(target[k]) : target[k]\n        }\n     }\n  return res\n}\n</code></pre>\n<p>测试下</p>\n<pre><code class=\"language-javascript\">// test用例1: null\nvar a = null // false\n// test用例2: 不可枚举属性\nvar b = {name:'张三',like:['girl','cat']}\nObject.defineProperty(b,'age',{\n    value: '18不可枚举属性',\n    enumerable: false\n})\nfor(let prop in b){\n  console.log(prop)\n}\n/*\n'name'\n'like'\n*/\n// test用例3: 非数组、对象的引用类型\nvar c = new Date()\nvar d = deepCopy(c) \nconsole.log(d)\n/*\n  {}\n*/\n// test用例4: \n  const e = {}\n  e.e = e\n  deepClone(e)\n/*\n  出现内存泄漏\n*/\n// test用例5: 对象、数组深层嵌套\nvar i = {rep:'apple',like:['women',{boy:{name:'王五',like:[69,'sex']}}]}\n// 可以\n</code></pre>\n<p>通过测试可以看出</p>\n<p>缺点：<br/> 1: 不可复制不可枚举属性以及symbol类型<br/> 2：只针对普通的引用类型做递归<br/> 3：没有解决对象成环</p>\n<h3>3.使用WeakMap解决对象成环</h3>\n<pre><code class=\"language-javascript\">const isObject = (target) =&gt; (typeof target === 'object' || typeof target === 'function') &amp;&amp; typeof target !== null\nfunction deepClone(target,map = new WeakMap()) {\n  //当weakmap 中已经存在这个对象，直接返回即可，不用在进行拷贝\n  if(map.get(target)) return target\n  if(!isObject(target)) return target\n  // 没有存在 就在weakmap中添加\n  map.set(target,true)\n  let res = Array.isArray(target) ? [] : {}\n  for(let k in target) {\n    if(target.hasOwnProperty(k)) {\n      res[k] = typeof target[k] === 'object' ? deepClone(target[k],map) : target[k]\n    }\n  }\n  return res\n}\n</code></pre>\n<p>使用weakmap的原因是 weakmap并不会给对象增加引用次数，即对象可以被垃圾回收机制清除，不会占据内存，造成浪费性能。</p>\n<h2>四、对非一般引用类型的拷贝方法</h2>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/441989c9f6455798d53ad2ecea02ab0f.webp?x-oss-process=image/format,png\"/></p>\n<p>由于其他类型较多，所以我们可以将这些类型分类后拷贝，首先看一下lodash 枚举出的一些类型。<br/>  </p>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/a4f54642843c7b736c19fca46c8672cd.webp?x-oss-process=image/format,png\"/></p>\n<p>按照类型分为可遍历类型和不可遍历类型。可遍历类型比如Set和Map等，不可遍历类型为RegExp和Date等。</p>\n<h3>扩展：获取数据类型</h3>\n<p>typeof：能准确判断基本数据类型，但一般复杂数据类型无法判断</p>\n<p>instanceof：能准确判断复杂数据类型，但基本数据类型不行</p>\n<p>Object.property.toString.call：全部可以</p>\n<p>现在，假定我们封装好了isObject，isSet，isDate，等</p>\n<h3>1.拷贝Set</h3>\n<pre><code class=\"language-javascript\">  function deepClone (val) {\n      if (isSet(val)) {\n        const set = new Set()\n        val.forEach(item =&gt; {\n          set.add(deepClone(item))\n        })\n      }\n  }\n</code></pre>\n<p>Map类型和Set类型类似，所以不再重复说明。</p>\n<h3>2.拷贝正则和Date</h3>\n<pre><code class=\"language-javascript\">  function deepClone (val) {\n  const Ctor = val.constructor\n  if (isDate(val)) {\n    return new Ctor(+val)\n  } else if (isRegExp(val)) {\n    const reFlags = /\\w*$/;\n    // 此处不用flags的原因在于flags方法返回的修饰符是按照字母顺序排列的\n    const reg = new Ctor(val.source, reFlags.exec(val))\n    reg.lastIndex = val.lastIndex\n    return reg\n  }\n}\n</code></pre>\n<p>其他不可遍历类型类似，每个不可遍历类型有自己的特性，抓住数据类型的特性进行克隆就行。</p>\n<h3>3.拷贝函数</h3>\n<p>lodash对函数的处理为直接返回，这点根据函数的特性也能理解，克隆函数实际并无意义。如果必须实现的话需要考虑箭头函数和普通函数，箭头函数是没有原型的。克隆箭头函数比较简单，直接调用函数的toString方法，然后eval解析即可，普通函数需要正则匹配函数体，再通过new Function生成。</p>\n<p></p>\n<p></p>\n<h1> 总结给大家推荐一个实用面试题库</h1>\n<h3><strong> 1、前端面试题库 （</strong>面试必备）<strong>            <strong>推荐：★★★★★</strong></strong></h3>\n<p>地址：<a href=\"https://mp.weixin.qq.com/s?__biz=MzU5NzA0NzQyNg==&amp;mid=2247485824&amp;idx=3&amp;sn=70cd26a7c0c683de64802f6cb9835003&amp;scene=21#wechat_redirect\" title=\"前端面试题库\">前端面试题库</a></p>\n<h3><strong>2、前端技术导航大全      <strong>推荐：★★★★★</strong></strong></h3>\n<p>地址：<a href=\"https://webstatic-3g8wm74b420bf334-1301145096.tcloudbaseapp.com/webclass/index.html#/\" title=\"前端技术导航大全\">前端技术导航大全</a></p>\n<h3>3、开发者颜色值转换工具   <strong>推荐：★★★★★</strong></h3>\n<p>地址 ：<a href=\"https://color-4gr069g4ea217b7a-1301145096.tcloudbaseapp.com/color/index.html\" title=\"开发者颜色值转换工具\">开发者颜色值转换工具</a></p>\n</div>\n</div>"}