{"blogid": "122389948", "writerAge": "码龄5年", "writerBlogNum": "22", "writerCollect": "1012", "writerComment": "139", "writerFan": "140", "writerGrade": "3级", "writerIntegral": "502", "writerName": "阿丢是丢心心", "writerProfileAdress": "writer_image\\profile_122389948.jpg", "writerRankTotal": "64554", "writerRankWeekly": "287267", "writerThumb": "141", "writerVisitNum": "111585", "blog_read_count": "46744", "blog_time": "于 2022-01-09 11:07:07 发布", "blog_title": "LDA主题模型简介及Python实现", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h2>一、LDA主题模型简介</h2>\n<p>        LDA主题模型主要用于推测文档的主题分布，可以将文档集中每篇文档的主题以概率分布的形式给出根据主题进行主题聚类或文本分类。</p>\n<p>        LDA主题模型不关心文档中单词的顺序，通常使用词袋特征（bag-of-word feature）来代表文档。词袋模型介绍可以参考这篇文章：<a href=\"https://zhuanlan.zhihu.com/p/70314114\" title=\"文本向量化表示——词袋模型 - 知乎\">文本向量化表示——词袋模型 - 知乎</a></p>\n<p>        了解LDA模型，我们需要先了解<strong>LDA的生成模型</strong>，LDA认为一篇文章是怎么形成的呢？</p>\n<p>        LDA模型认为<strong>主题可以由一个词汇分布来表示，而文章可以由主题分布来表示</strong>。</p>\n<p>        比如有两个主题，<strong>美食</strong>和<strong>美妆</strong>。LDA说两个主题可以由词汇分布表示，他们分别是：</p>\n<p style=\"text-align:center;\">{面包：0.4，火锅：0.5，眉笔：0.03，腮红：0.07}<br/> {眉笔：0.4，腮红：0.5，面包：0.03，火锅：0.07}</p>\n<p>        同样，对于两篇文章，LDA认为文章可以由主题分布这么表示：</p>\n<p style=\"text-align:center;\">《美妆日记》{美妆：0.8，美食：0.1，其他：0.1}</p>\n<p style=\"text-align:center;\">《美食探索》{美食：0.8，美妆：0.1，其他：0.1}</p>\n<p>        所以想要生成一篇文章，可以先以一定的概率选取上述某个主题，再以一定的概率选取那个主题下的某个单词，不断重复这两步就可以生成最终文章。</p>\n<p>        在LDA模型中，一篇文档生成的方式如下：</p>\n<p> <img alt=\"\" height=\"141\" src=\"image\\1e830a8d662046aba6fdedaae7baaa7b.png\" width=\"457\"/></p>\n<p>        其中，类似Beta分布是二项式分布的共轭先验概率分布，而狄利克雷分布（Dirichlet分布）是多项式分布的共轭先验概率分布。</p>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"494\" src=\"image\\36667699cd0f48a7bc8e8eebf115ad75.png\" width=\"568\"/></p>\n<p style=\"margin-left:0;\">        如果我们要生成一篇文档，它里面的每个词语出现的概率为：</p>\n<p style=\"margin-left:0;\"><img alt=\"\" height=\"452\" src=\"image\\fcc4ace3fe0344499ed3fbe7de9c146a.png\" width=\"1200\"/></p>\n<p>         更详细的数学推导可以见：<a href=\"https://blog.csdn.net/v_JULY_v/article/details/41209515?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.no_search_link&amp;utm_relevant_index=2\" title=\"通俗理解LDA主题模型_结构之法 算法之道-CSDN博客_lda模型\">通俗理解LDA主题模型_结构之法 算法之道-CSDN博客_lda模型</a></p>\n<p>        看到文章推断其隐藏的主题分布，就是建模的目的。换言之，人类根据文档生成模型写成了各类文章，然后丢给了计算机，相当于计算机看到的是一篇篇已经写好的文章。现在计算机需要根据一篇篇文章中看到的一系列词归纳出当篇文章的主题，进而得出各个主题各自不同的出现概率：主题分布。</p>\n<p>        至于LDA主题模型在计算机中具体是怎么实现的，我们也可以不必细究，现在有很多可以直接用来进行LDA主题分析的包，我们直接用就行。（没错，我就是调包侠）</p>\n<h2>二、Python实现</h2>\n<p>        在用Python进行LDA主题模型分析之前，我先对文档进行了分词和去停用词处理（详情可以看我之前的文章：<a href=\"https://blog.csdn.net/weixin_41168304/article/details/121707533?spm=1001.2014.3001.5501\" title=\"用python对单一微博文档进行分词——jieba分词（加保留词和停用词）_阿丢是丢心心的博客-CSDN博客_jieba 停用词\">用python对单一微博文档进行分词——jieba分词（加保留词和停用词）_阿丢是丢心心的博客-CSDN博客_jieba 停用词</a>）</p>\n<p>        我下面的输入文件也是已经分好词的文件</p>\n<h3>1.导入算法包</h3>\n<pre><code class=\"language-python\">import gensim\nfrom gensim import corpora\nimport matplotlib.pyplot as plt\nimport matplotlib\nimport numpy as np\nimport warnings\nwarnings.filterwarnings('ignore')  # To ignore all warnings that arise here to enhance clarity\n\nfrom gensim.models.coherencemodel import CoherenceModel\nfrom gensim.models.ldamodel import LdaModel\n</code></pre>\n<h3>2.加载数据</h3>\n<p>        先将文档转化为一个二元列表，其中每个子列表代表一条微博：</p>\n<pre><code class=\"language-python\">PATH = \"E:/data/output.csv\"\n\nfile_object2=open(PATH,encoding = 'utf-8',errors = 'ignore').read().split('\\n')  #一行行的读取内容\ndata_set=[]  #建立存储分词的列表\nfor i in range(len(file_object2)):\n    result=[]\n    seg_list = file_object2[i].split()\n    for w in seg_list :  #读取每一行分词\n        result.append(w)\n    data_set.append(result)\nprint(data_set)\n</code></pre>\n<p>        构建词典，语料向量化表示：</p>\n<pre><code class=\"language-python\">dictionary = corpora.Dictionary(data_set)  # 构建词典\ncorpus = [dictionary.doc2bow(text) for text in data_set]  #表示为第几个单词出现了几次</code></pre>\n<h3>3.构建LDA模型</h3>\n<pre><code class=\"language-python\">ldamodel = LdaModel(corpus, num_topics=10, id2word = dictionary, passes=30,random_state = 1)   #分为10个主题\nprint(ldamodel.print_topics(num_topics=num_topics, num_words=15))  #每个主题输出15个单词</code></pre>\n<p>        这是确定主题数时LDA模型的构建方法，一般我们可以用指标来评估模型好坏，也可以用这些指标来确定最优主题数。一般用来评价LDA主题模型的指标有困惑度（perplexity）和主题一致性（coherence），困惑度越低或者一致性越高说明模型越好。一些研究表明perplexity并不是一个好的指标，所以一般我用coherence来评价模型并选择最优主题，但下面代码两种方法我都用了。</p>\n<pre><code class=\"language-python\">#计算困惑度\ndef perplexity(num_topics):\n    ldamodel = LdaModel(corpus, num_topics=num_topics, id2word = dictionary, passes=30)\n    print(ldamodel.print_topics(num_topics=num_topics, num_words=15))\n    print(ldamodel.log_perplexity(corpus))\n    return ldamodel.log_perplexity(corpus)\n#计算coherence\ndef coherence(num_topics):\n    ldamodel = LdaModel(corpus, num_topics=num_topics, id2word = dictionary, passes=30,random_state = 1)\n    print(ldamodel.print_topics(num_topics=num_topics, num_words=10))\n    ldacm = CoherenceModel(model=ldamodel, texts=data_set, dictionary=dictionary, coherence='c_v')\n    print(ldacm.get_coherence())\n    return ldacm.get_coherence()</code></pre>\n<h3>4.绘制主题-coherence曲线，选择最佳主题数</h3>\n<pre><code class=\"language-python\">x = range(1,15)\n# z = [perplexity(i) for i in x]  #如果想用困惑度就选这个\ny = [coherence(i) for i in x]\nplt.plot(x, y)\nplt.xlabel('主题数目')\nplt.ylabel('coherence大小')\nplt.rcParams['font.sans-serif']=['SimHei']\nmatplotlib.rcParams['axes.unicode_minus']=False\nplt.title('主题-coherence变化情况')\nplt.show()</code></pre>\n<p>        最终能得到各主题的词语分布和这样的图形：</p>\n<p><img alt=\"\" height=\"275\" src=\"image\\0834ada9efd3490591e78a021ed5dca9.png\" width=\"406\"/></p>\n<h3> 5.结果输出与可视化</h3>\n<p>        通过上述主题评估，我们发现可以选择5作为主题个数，接下来我们可以再跑一次模型，设定主题数为5，并输出每个文档最有可能对应的主题</p>\n<pre><code class=\"language-python\">from gensim.models import LdaModel\nimport pandas as pd\nfrom gensim.corpora import Dictionary\nfrom gensim import corpora, models\nimport csv\n\n# 准备数据\nPATH = \"E:/data/output1.csv\"\n\nfile_object2=open(PATH,encoding = 'utf-8',errors = 'ignore').read().split('\\n')  #一行行的读取内容\ndata_set=[] #建立存储分词的列表\nfor i in range(len(file_object2)):\n    result=[]\n    seg_list = file_object2[i].split()\n    for w in seg_list :#读取每一行分词\n        result.append(w)\n    data_set.append(result)\n\ndictionary = corpora.Dictionary(data_set)  # 构建词典\ncorpus = [dictionary.doc2bow(text) for text in data_set]\n\nlda = LdaModel(corpus=corpus, id2word=dictionary, num_topics=5, passes = 30,random_state=1)\ntopic_list=lda.print_topics()\nprint(topic_list)\n\nfor i in lda.get_document_topics(corpus)[:]:\n    listj=[]\n    for j in i:\n        listj.append(j[1])\n    bz=listj.index(max(listj))\n    print(i[bz][0])</code></pre>\n<p>        同时我们可以用pyLDAvis对LDA模型结果进行可视化：</p>\n<pre><code class=\"language-python\">import pyLDAvis.gensim\npyLDAvis.enable_notebook()\ndata = pyLDAvis.gensim.prepare(lda, corpus, dictionary)\npyLDAvis.save_html(data, 'E:/data/3topic.html')</code></pre>\n<p>        大概能得到这样的结果：</p>\n<p><img alt=\"\" height=\"909\" src=\"image\\ecd0784b65a7455ea393bde8e413087a.png\" width=\"1200\"/></p>\n<p> 左侧圆圈表示主题，右侧表示各个词语对主题的贡献度。</p>\n<h2>所有代码如下：</h2>\n<pre><code class=\"language-python\">import gensim\nfrom gensim import corpora\nimport matplotlib.pyplot as plt\nimport matplotlib\nimport numpy as np\nimport warnings\nwarnings.filterwarnings('ignore')  # To ignore all warnings that arise here to enhance clarity\n\nfrom gensim.models.coherencemodel import CoherenceModel\nfrom gensim.models.ldamodel import LdaModel\n\n\n\n # 准备数据\nPATH = \"E:/data/output.csv\"\n\nfile_object2=open(PATH,encoding = 'utf-8',errors = 'ignore').read().split('\\n')  #一行行的读取内容\ndata_set=[] #建立存储分词的列表\nfor i in range(len(file_object2)):\n    result=[]\n    seg_list = file_object2[i].split()\n    for w in seg_list :#读取每一行分词\n        result.append(w)\n    data_set.append(result)\nprint(data_set)\n\n\ndictionary = corpora.Dictionary(data_set)  # 构建 document-term matrix\ncorpus = [dictionary.doc2bow(text) for text in data_set]\n#Lda = gensim.models.ldamodel.LdaModel  # 创建LDA对象\n\n#计算困惑度\ndef perplexity(num_topics):\n    ldamodel = LdaModel(corpus, num_topics=num_topics, id2word = dictionary, passes=30)\n    print(ldamodel.print_topics(num_topics=num_topics, num_words=15))\n    print(ldamodel.log_perplexity(corpus))\n    return ldamodel.log_perplexity(corpus)\n\n#计算coherence\ndef coherence(num_topics):\n    ldamodel = LdaModel(corpus, num_topics=num_topics, id2word = dictionary, passes=30,random_state = 1)\n    print(ldamodel.print_topics(num_topics=num_topics, num_words=10))\n    ldacm = CoherenceModel(model=ldamodel, texts=data_set, dictionary=dictionary, coherence='c_v')\n    print(ldacm.get_coherence())\n    return ldacm.get_coherence()\n\n# 绘制困惑度折线图\nx = range(1,15)\n# z = [perplexity(i) for i in x]\ny = [coherence(i) for i in x]\nplt.plot(x, y)\nplt.xlabel('主题数目')\nplt.ylabel('coherence大小')\nplt.rcParams['font.sans-serif']=['SimHei']\nmatplotlib.rcParams['axes.unicode_minus']=False\nplt.title('主题-coherence变化情况')\nplt.show()</code></pre>\n<pre><code class=\"language-python\">from gensim.models import LdaModel\nimport pandas as pd\nfrom gensim.corpora import Dictionary\nfrom gensim import corpora, models\nimport csv\n\n# 准备数据\nPATH = \"E:/data/output1.csv\"\n\nfile_object2=open(PATH,encoding = 'utf-8',errors = 'ignore').read().split('\\n')  #一行行的读取内容\ndata_set=[] #建立存储分词的列表\nfor i in range(len(file_object2)):\n    result=[]\n    seg_list = file_object2[i].split()\n    for w in seg_list :#读取每一行分词\n        result.append(w)\n    data_set.append(result)\n\ndictionary = corpora.Dictionary(data_set)  # 构建 document-term matrix\ncorpus = [dictionary.doc2bow(text) for text in data_set]\n\nlda = LdaModel(corpus=corpus, id2word=dictionary, num_topics=5, passes = 30,random_state=1)\ntopic_list=lda.print_topics()\nprint(topic_list)\n\nresult_list =[]\nfor i in lda.get_document_topics(corpus)[:]:\n    listj=[]\n    for j in i:\n        listj.append(j[1])\n    bz=listj.index(max(listj))\n    result_list.append(i[bz][0])\nprint(result_list)</code></pre>\n<pre><code class=\"language-python\">import pyLDAvis.gensim\npyLDAvis.enable_notebook()\ndata = pyLDAvis.gensim.prepare(lda, corpus, dictionary)\npyLDAvis.save_html(data, 'E:/data/topic.html')</code></pre>\n<p>有需要自取~</p>\n<p>还可以关注我，之后我还会发更多关于数据分析的干货文章~</p>\n</div>\n</div>"}