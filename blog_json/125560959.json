{"blogid": "125560959", "writerAge": "码龄1年", "writerBlogNum": "25", "writerCollect": "2049", "writerComment": "1518", "writerFan": "2633", "writerGrade": "6级", "writerIntegral": "4561", "writerName": "猿力猪", "writerProfileAdress": "writer_image\\profile_125560959.jpg", "writerRankTotal": "4640", "writerRankWeekly": "15864", "writerThumb": "1555", "writerVisitNum": "113013", "blog_read_count": "1494", "blog_time": "已于 2022-07-13 12:16:32 修改", "blog_title": "【Linux网络编程】高并发服务器框架 线程池介绍+线程池封装", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h1 id=\"%E7%9B%AE%E5%BD%95\">目录</h1>\n<p id=\"%E5%89%8D%E8%A8%80-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%89%8D%E8%A8%80\">前言</a></p>\n<p id=\"%E4%B8%80%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%C2%A0-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%80%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%C2%A0\">一、线程池介绍</a></p>\n<p id=\"%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-toc\" style=\"margin-left:40px;\"><a href=\"#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\">💻线程池基本概念</a></p>\n<p id=\"%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86-toc\" style=\"margin-left:40px;\"><a href=\"#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86\">💻线程池组成部分</a></p>\n<p id=\"%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%C2%A0\">💻线程池工作原理 </a></p>\n<p id=\"%E4%BA%8C%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BB%A3%E7%A0%81%E5%B0%81%E8%A3%85-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BA%8C%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BB%A3%E7%A0%81%E5%B0%81%E8%A3%85\">二、线程池代码封装</a></p>\n<p id=\"main.cpp-toc\" style=\"margin-left:40px;\"><a href=\"#main.cpp\">🌈main.cpp</a></p>\n<p id=\"%C2%A0ThreadPool.h-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A0ThreadPool.h\">🌈ThreadPool.h</a></p>\n<p id=\"%C2%A0%C2%A0ThreadPool.cpp-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A0%C2%A0ThreadPool.cpp\">🌈ThreadPool.cpp</a></p>\n<p id=\"%C2%A0ChildTask.h%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A0ChildTask.h%C2%A0\">🌈ChildTask.h </a></p>\n<p id=\"%C2%A0ChildTask.cpp-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A0ChildTask.cpp\">🌈ChildTask.cpp</a></p>\n<p id=\"%C2%A0BaseTask.h-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A0BaseTask.h\">🌈BaseTask.h</a></p>\n<p id=\"%C2%A0BaseTask.cpp-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A0BaseTask.cpp\">🌈BaseTask.cpp</a></p>\n<p id=\"%E4%B8%89%E3%80%81%E6%B5%8B%E8%AF%95%E6%95%88%E6%9E%9C-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%89%E3%80%81%E6%B5%8B%E8%AF%95%E6%95%88%E6%9E%9C\">三、测试效果</a></p>\n<p id=\"%E5%9B%9B%E3%80%81%E6%80%BB%E7%BB%93-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%9B%9B%E3%80%81%E6%80%BB%E7%BB%93\">四、总结</a></p>\n<p id=\"%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%A5%BD%E5%A4%84-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%A5%BD%E5%A4%84\">📌创建线程池的好处</a></p>\n<hr/>\n<h1 id=\"%E5%89%8D%E8%A8%80\">前言</h1>\n<p>本文主要学习<span style=\"color:#be191c;\"><strong>Linux内核编程</strong></span>，结合<span style=\"color:#be191c;\"><strong>Visual Studio 2019</strong></span>进行跨平台编程，内容包括线程池介绍以及线程池封装</p>\n<h1 id=\"%E4%B8%80%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%C2%A0\">一、线程池介绍</h1>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"405\" src=\"image\\25b11019e4bd498192bac62084213f54.png\" width=\"461\"/></p>\n<h2 id=\"%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\">💻线程池基本概念</h2>\n<ul><li><span style=\"color:#be191c;\"><strong>线程池</strong></span>是预先创建线程的一种技术 （服务器真正意义上实现高并发就必须用线程池）</li><li>🌰举个例子：生活中的水池，是装东西的容器，用来装水的，线程池当然就是拿来装线程的</li></ul>\n<blockquote>\n<ul><li>线程池在任务还没有到来之前，创建一定数量的线程，放入空闲队列中，这些线程都是处于阻塞状态，不消耗CPU，但占用较小的内存空间</li><li>当新任务到来时，缓冲池选择一个空闲线程，把任务传入此线程中运行，如果缓冲池已经没有空闲线程，则新建若干个线程，当系统比较空闲时，大部分线程都一直处于暂停状态，线程池自动销毁一部分线程，回收系统资源</li></ul>\n</blockquote>\n<h2 id=\"%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86\">💻<strong>线程池组成部分</strong></h2>\n<blockquote>\n<ul><li><strong>线程池类</strong></li></ul>\n<p>        维护工作者线程队列（包括空闲与忙碌队列）</p>\n<p>        维护一个任务队列</p>\n<p>        维护一个线程池调度器指针</p>\n<ul><li><strong>线程池调度器</strong>（本身也是一个线程）</li></ul>\n<p>        负责线程调度</p>\n<p>        负责任务分配</p>\n<ul><li><strong>工作者线程类</strong>（线程池中的线程类的封装）</li><li><strong>任务队列</strong></li><li><strong>任务接口</strong>（实际的业务逻辑都继承自该接口）</li></ul>\n</blockquote>\n<h2 id=\"%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%C2%A0\">💻<strong>线程池工作原理 </strong></h2>\n<p>根据服务器的需要，来设置线程的数量，可能是10条、20条、30条，根据服务器的承载，10条不代表只能做10个任务，总有任务做的快，有的做的慢，可能可以完成20个任务 </p>\n<p><img alt=\"\" height=\"1074\" src=\"https://img-blog.csdnimg.cn/e1e608aeaca24f439da26619725121cc.gif\" width=\"1200\"/></p>\n<p>🌰举个例子：如上动图所示，当我们服务器收到一个注册业务，是一个服务器要执行的任务，它会进入到任务队列，队列先进先出，顺次执行，任务会唤醒空闲列表当中的一个空闲的线程，接到任务之后，空闲线程会从空闲列表中消失，进入到忙碌列表，去完成对应的任务，完成任务后，从忙碌列表中出去，到空闲列表继续等待新任务</p>\n<p>如果，所有的线程都在忙，都在做任务，这时候登录进来，先进入任务队列，会创建一个新的线程来接这个任务，当所有线程都完成任务，回到空闲列表后，新创建的线程销毁，留下原先设置的对应数量线程（类似，保留老员工，把实习生裁员）</p>\n<blockquote>\n<ul><li><strong>队列：</strong>先进先出</li><li><strong>空闲列表（链表）：</strong>不定长（有的时候可能需要创建新线程来接任务）</li><li><strong>忙碌列表（链表）：</strong>不定长（有的时候可能需要创建新线程来接任务）</li></ul>\n</blockquote>\n<p>话不多说，咱们上号，封装一下线程池相关函数，来进行测试 </p>\n<p><img alt=\"\" height=\"673\" src=\"image\\ebb9ac75e7d74284b42cacac2fff41fd.png\" width=\"1200\"/></p>\n<h1 id=\"%E4%BA%8C%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BB%A3%E7%A0%81%E5%B0%81%E8%A3%85\">二、线程池代码封装</h1>\n<h2 id=\"main.cpp\">🌈main.cpp</h2>\n<ul><li>主函数，设置10条线程，来执行30个任务 </li></ul>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;stdio.h&gt;\n#include \"ThreadPool.h\"\n#include \"ChildTask.h\"\nusing namespace std;\n\nint main()\n{\n\tThreadPool* pool = new ThreadPool(10);//10条线程\n\n\tfor (int i = 0; i &lt; 30; i++)//设置30个任务\n\t{\n\t\tchar buf[40] = { 0 };//初始化\n\t\tsprintf(buf, \"%s%d\", \"任务\", i);\n\n\t\tBaseTask* task = new ChildTask(buf);\n\t\tpool-&gt;pushTask(task);\n\t}\n\n\twhile (1) {}\n\n\treturn 0;\n}</code></pre>\n<h2 id=\"%C2%A0ThreadPool.h\">🌈ThreadPool.h</h2>\n<ul><li>对线程池进行设计，核心包括<strong>最大、最小线程数</strong>，<strong>忙碌列表</strong>，<strong>空闲列表</strong>，<strong>任务队列</strong>，<strong>互斥量</strong>，<strong>条件变量</strong>，以及<strong>线程执行函数</strong></li></ul>\n<pre><code class=\"language-cpp\">#pragma once\n#include &lt;queue&gt;//队列\n#include &lt;list&gt;//链表头文件\n#include &lt;pthread.h&gt;//线程头文件\n#include &lt;algorithm&gt;//find查找\n#include &lt;iostream&gt;\n#include \"BaseTask.h\"\n\nusing namespace std;\n\n#define MIN_NUM 10//最小值 默认参数\n\nclass ThreadPool\n{\npublic:\n\tThreadPool(const int num = MIN_NUM);\n\t~ThreadPool();\n\n\t//判断任务队列是否为空\n\tbool QueueIsEmpty();\n\t//线程互斥量加锁解锁\n\tvoid Lock();\n\tvoid Unlock();\n\t//线程条件变量等待和唤醒\n\tvoid Wait();\n\tvoid WakeUp();\n\n\t//添加任务到任务队列\n\tvoid pushTask(BaseTask* task);\n\t//从任务队列移除任务\n\tBaseTask* popTask(BaseTask* task);\n\n\t//从忙碌回到空闲 工作结束\n\tvoid MoveToIdle(pthread_t id);\n\n\t//从空闲到忙碌 工作开始\n\tvoid MoveToBusy(pthread_t id);\n\n\t//线程执行函数\n\tstatic void* RunTime(void* vo);\n\nprivate:\n\tint threadMinNum;//最大线程数量\n\tint threadMaxNum;//最小线程数量\n\tqueue&lt;BaseTask*&gt;taskQueue;//任务队列\n\tlist&lt;pthread_t&gt;busyList;//线程忙碌列表\n\tlist&lt;pthread_t&gt;idleList;//线程空闲列表\n\tpthread_mutex_t mutex;//互斥量：做锁\n\tpthread_cond_t cond;//条件变量：让线程等待或者唤醒\n};\n\n</code></pre>\n<h2 id=\"%C2%A0%C2%A0ThreadPool.cpp\">🌈ThreadPool.cpp</h2>\n<ul><li>对函数进行参数的设置，核心在于线程执行函数上的设置，在工作前和工作完设置打印，方便我们进行观察</li></ul>\n<pre><code class=\"language-cpp\">#include \"ThreadPool.h\"\n\nThreadPool::ThreadPool(const int num)\n{\n\tthis-&gt;threadMinNum = num;\n\n\t//条件变量、互斥量初始化\n\tpthread_mutex_init(&amp;this-&gt;mutex, NULL);\n\tpthread_cond_init(&amp;this-&gt;cond, NULL);\n\n\tpthread_t id;\n\t//线程num条创建\n\tfor (int i = 0; i &lt; this-&gt;threadMinNum; i++)\n\t{\n\t\t//线程创建\n\t\tpthread_create(&amp;id, NULL, RunTime, this);\n\t\tthis-&gt;idleList.push_back(id);//线程存入空闲列表\n\t}\n}\n\nThreadPool::~ThreadPool()\n{\n}\n//任务队列是否为空\nbool ThreadPool::QueueIsEmpty()\n{\n\treturn this-&gt;taskQueue.empty();\n}\n//线程加锁\nvoid ThreadPool::Lock()\n{\n\tpthread_mutex_lock(&amp;this-&gt;mutex);\n}\n//线程解锁\nvoid ThreadPool::Unlock()\n{\n\tpthread_mutex_unlock(&amp;this-&gt;mutex);\n}\n//线程等待\nvoid ThreadPool::Wait()\n{\n\tpthread_cond_wait(&amp;this-&gt;cond, &amp;this-&gt;mutex);\n}\n//线程唤醒\nvoid ThreadPool::WakeUp()\n{\n\tpthread_cond_signal(&amp;this-&gt;cond);\n}\n//添加任务到任务队列\nvoid ThreadPool::pushTask(BaseTask* task)\n{\n\tLock();\n\ttaskQueue.push(task);\n\tUnlock();\n\tWakeUp();\n}\n//从任务队列移除任务\nBaseTask* ThreadPool::popTask(BaseTask* task)\n{\n\ttask = this-&gt;taskQueue.front();//从队列头取\n\tthis-&gt;taskQueue.pop();//删除队列头\n\n\treturn task;\n}\n//从忙碌回到空闲 工作结束\nvoid ThreadPool::MoveToIdle(pthread_t id)\n{\n\tlist&lt;pthread_t&gt;::iterator iter;\n\titer = find(busyList.begin(), busyList.end(), id);\n\n\tif (iter != busyList.end())\n\t{\n\t\t//从忙碌移除\n\t\tthis-&gt;busyList.erase(iter);\n\t\t//添加到空闲\n\t\tthis-&gt;idleList.push_back(*iter);//this-&gt;idleList.push_back(id)\n\t}\n}\n//从空闲到忙碌 工作开始\nvoid ThreadPool::MoveToBusy(pthread_t id)\n{\n\tlist&lt;pthread_t&gt;::iterator iter;\n\titer = find(idleList.begin(), idleList.end(), id);\n\n\tif (iter != idleList.end())\n\t{\n\t\t//从空闲移除\n\t\tthis-&gt;idleList.erase(iter);\n\t\t//添加到忙碌\n\t\tthis-&gt;busyList.push_back(*iter);//this-&gt;idleList.push_back(id)\n\t}\n}\n//线程执行函数\nvoid* ThreadPool::RunTime(void* vo)\n{\n\t//拿到执行线程自己的id 因为后面要处理忙碌和空闲的情况\n\tpthread_t id = pthread_self();\n\t//确保主线程与子线程分离，子线程结束后，资源自动回收\n\tpthread_detach(id);\n\t//线程参数获取\n\tThreadPool* argThis = (ThreadPool*)vo;\n\n\twhile (true)\n\t{\n\t\targThis-&gt;Lock();\n\t\t//如果任务队列为空 线程则一直等待 \n\t\t//知道任务队列不为空则会被pushTask函数唤醒线程\n\t\twhile (argThis-&gt;QueueIsEmpty())\n\t\t{\n\t\t\targThis-&gt;Wait();\n\t\t}\n\t\targThis-&gt;MoveToBusy(id);\n\n\t\tcout &lt;&lt; \"工作前  任务数:\" &lt;&lt; argThis-&gt;taskQueue.size() &lt;&lt; endl;\n\t\tcout &lt;&lt; \"工作前  busy:\" &lt;&lt; argThis-&gt;busyList.size() &lt;&lt; endl;\n\t\tcout &lt;&lt; \"工作前  idle:\" &lt;&lt; argThis-&gt;idleList.size() &lt;&lt; endl;\n\t\tcout &lt;&lt; \"-----------------------------------------------\" &lt;&lt; endl;\n\t\t//取任务\n\t\tBaseTask* task;\n\t\ttask = argThis-&gt;popTask(task);\n\n\t\targThis-&gt;Unlock();\n\n\t\t//任务工作\n\t\ttask-&gt;working();\n\n\t\t//工作结束\n\t\targThis-&gt;Lock();\n\t\targThis-&gt;MoveToIdle(id);\n\t\targThis-&gt;Unlock();\n\n\t\tcout &lt;&lt; \"工作完  任务数:\" &lt;&lt; argThis-&gt;taskQueue.size() &lt;&lt; endl;\n\t\tcout &lt;&lt; \"工作完  busy:\" &lt;&lt; argThis-&gt;busyList.size() &lt;&lt; endl;\n\t\tcout &lt;&lt; \"工作完  idle:\" &lt;&lt; argThis-&gt;idleList.size() &lt;&lt; endl;\n\t\tcout &lt;&lt; \"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\" &lt;&lt; endl;\n\t}\n\n\treturn nullptr;\n}\n</code></pre>\n<h2 id=\"%C2%A0ChildTask.h%C2%A0\">🌈ChildTask.h </h2>\n<ul><li>子类配置 </li></ul>\n<pre><code class=\"language-cpp\">#pragma once\n#include \"BaseTask.h\"\n#include &lt;iostream&gt;\n#include &lt;unistd.h&gt;//sleep头文件\nusing namespace std;\n\nclass ChildTask :\n\tpublic BaseTask\n{\npublic:\n\tChildTask(char* data);\n\t~ChildTask();\n\tvoid working();\n};\n</code></pre>\n<h2 id=\"%C2%A0ChildTask.cpp\">🌈ChildTask.cpp</h2>\n<ul><li>子类设置延时模拟做任务的时间比较长 </li></ul>\n<pre><code class=\"language-cpp\">#include \"ChildTask.h\"\n\nChildTask::ChildTask(char* data) :BaseTask(data)//参数传给父类\n{\n}\n\nChildTask::~ChildTask()\n{\n}\n\nvoid ChildTask::working()\n{\n\tcout &lt;&lt; this-&gt;data &lt;&lt; \"正在执行......\" &lt;&lt; endl;\n\tsleep(3);//延时3秒 （模拟做业务的时间比较长）\n}\n</code></pre>\n<h2 id=\"%C2%A0BaseTask.h\">🌈BaseTask.h</h2>\n<ul><li>基类设置结构体来装业务 </li></ul>\n<pre><code class=\"language-cpp\">#pragma once\n#include &lt;string.h&gt;\nclass BaseTask\n{\npublic:\n\tBaseTask(char* data);\n\t~BaseTask();\n\tchar data[1024]; //装业务\n\tvirtual void working() = 0;//虚函数\n};\n\n</code></pre>\n<h2 id=\"%C2%A0BaseTask.cpp\">🌈BaseTask.cpp</h2>\n<ul><li>基类配置 </li></ul>\n<pre><code class=\"language-cpp\">#include \"BaseTask.h\"\n\nBaseTask::BaseTask(char* data)\n{\n\tbzero(this-&gt;data, sizeof(this-&gt;data));//清空\n\tmemcpy(this-&gt;data, data, sizeof(data));\n}\n\nBaseTask::~BaseTask()\n{\n\tdelete this-&gt;data;//清除释放\n}\n</code></pre>\n<h1 id=\"%E4%B8%89%E3%80%81%E6%B5%8B%E8%AF%95%E6%95%88%E6%9E%9C\">三、测试效果</h1>\n<ul><li>通过Linux连接VS进行跨平台编程，我们可以清晰的看到有几个线程是在做任务，几个线程是空闲的，整个过程就很清晰直观的展现出来了，如下动图所示： </li></ul>\n<p><img alt=\"\" height=\"1008\" src=\"https://img-blog.csdnimg.cn/e6c67342a32a47cfa29a80ec5ac9ef23.gif\" width=\"1200\"/></p>\n<ul><li>10条线程做30个任务的全部记录，如下如所示：</li></ul>\n<p><img alt=\"\" height=\"1200\" src=\"image\\db32f20cc97e4fa79238cc50ae787596.png\" width=\"963\"/></p>\n<h1 id=\"%E5%9B%9B%E3%80%81%E6%80%BB%E7%BB%93\">四、总结</h1>\n<h2 id=\"%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%A5%BD%E5%A4%84\">📌创建线程池的好处</h2>\n<ul><li>线程池的使用，能让我们搭建的高并发服务器真正意义上做到高并发</li></ul>\n<blockquote>\n<ul><li><strong><span style=\"color:#956fe7;\">降低资源消耗</span></strong></li></ul>\n<p>        通过重复利用自己创建的线程降低线程创建和销毁造成的消耗</p>\n<ul><li><strong><span style=\"color:#956fe7;\">提高响应速度</span></strong></li></ul>\n<p>        当任务到达时，任务可以不需要等待线程创建和销毁就能立即执行</p>\n<ul><li><span style=\"color:#956fe7;\"><strong>提高线程的可管理性</strong></span></li></ul>\n<p>        线程式稀缺资源，如果无限的创建线程，不仅会消耗资源，还会降低系统的稳定性</p>\n<p>        使用线程池可以进行统一分配，调优和监控</p>\n</blockquote>\n<p></p>\n<p><span style=\"color:#38d8f0;\"><strong><em>以上就是本文的全部内容啦！如果对您有帮助，麻烦点赞啦！收藏啦！欢迎各位评论区留言</em>！！！</strong></span></p>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"375\" src=\"https://img-blog.csdnimg.cn/d65b1c3c42934093b5517179f115e8d1.gif\" width=\"667\"/></p>\n<p></p>\n</div>\n</div>"}