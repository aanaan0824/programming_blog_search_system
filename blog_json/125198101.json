{"blogid": "125198101", "writerAge": "码龄10年", "writerBlogNum": "11", "writerCollect": "92", "writerComment": "45", "writerFan": "633", "writerGrade": "2级", "writerIntegral": "197", "writerName": "程序员Rock", "writerProfileAdress": "writer_image\\profile_125198101.jpg", "writerRankTotal": "62051", "writerRankWeekly": "17083", "writerThumb": "49", "writerVisitNum": "2002", "blog_read_count": "2622", "blog_time": "已于 2022-07-08 02:02:19 修改", "blog_title": "C++五子棋人机对战", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%C2%A0%E6%9C%AC%E6%95%99%E7%A8%8B%E9%85%8D%E5%A5%97%E8%A7%86%E9%A2%91-toc\" style=\"margin-left:0px;\"><a href=\"#%C2%A0%E6%9C%AC%E6%95%99%E7%A8%8B%E9%85%8D%E5%A5%97%E8%A7%86%E9%A2%91\"> 本教程配套视频</a></p>\n<p id=\"1.%20%E9%A1%B9%E7%9B%AE%E7%9B%AE%E6%A0%87-toc\" style=\"margin-left:0px;\"><a href=\"#1.%20%E9%A1%B9%E7%9B%AE%E7%9B%AE%E6%A0%87\">1. 项目目标</a></p>\n<p id=\"2.%20%E6%95%88%E6%9E%9C%E6%BC%94%E7%A4%BA-toc\" style=\"margin-left:0px;\"><a href=\"#2.%20%E6%95%88%E6%9E%9C%E6%BC%94%E7%A4%BA\">2. 效果演示</a></p>\n<p id=\"3.%20%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE-toc\" style=\"margin-left:0px;\"><a href=\"#3.%20%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE\">3. 创建项目</a></p>\n<p id=\"%C2%A04.%20%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1-toc\" style=\"margin-left:0px;\"><a href=\"#%C2%A04.%20%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1\"> 4. 项目框架设计</a></p>\n<p id=\"4.1%20%E8%AE%BE%E8%AE%A1%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6-toc\" style=\"margin-left:40px;\"><a href=\"#4.1%20%E8%AE%BE%E8%AE%A1%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6\">4.1 设计项目框架</a></p>\n<p id=\"4.2%20%E6%A0%B9%E6%8D%AE%E8%AE%BE%E8%AE%A1%E6%A1%86%E6%9E%B6%E5%88%9B%E5%BB%BA%E7%B1%BB-toc\" style=\"margin-left:40px;\"><a href=\"#4.2%20%E6%A0%B9%E6%8D%AE%E8%AE%BE%E8%AE%A1%E6%A1%86%E6%9E%B6%E5%88%9B%E5%BB%BA%E7%B1%BB\">4.2 根据设计框架创建类</a></p>\n<p id=\"%C2%A05.%20%E7%BB%99%E7%B1%BB%E6%B7%BB%E5%8A%A0%E4%B8%BB%E8%A6%81%E6%8E%A5%E5%8F%A3-toc\" style=\"margin-left:0px;\"><a href=\"#%C2%A05.%20%E7%BB%99%E7%B1%BB%E6%B7%BB%E5%8A%A0%E4%B8%BB%E8%A6%81%E6%8E%A5%E5%8F%A3\"> 5. 给类添加主要接口</a></p>\n<p id=\"5.1%20%E8%AE%BE%E8%AE%A1%E6%A3%8B%E7%9B%98%E7%B1%BBChess%E7%9A%84%E4%B8%BB%E8%A6%81%E6%8E%A5%E5%8F%A3-toc\" style=\"margin-left:40px;\"><a href=\"#5.1%20%E8%AE%BE%E8%AE%A1%E6%A3%8B%E7%9B%98%E7%B1%BBChess%E7%9A%84%E4%B8%BB%E8%A6%81%E6%8E%A5%E5%8F%A3\">5.1 设计棋盘类Chess的主要接口</a></p>\n<p id=\"%C2%A05.2%20%E8%AE%BE%E8%AE%A1AI%E7%B1%BB%E7%9A%84%E4%B8%BB%E8%A6%81%E6%8E%A5%E5%8F%A3-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A05.2%20%E8%AE%BE%E8%AE%A1AI%E7%B1%BB%E7%9A%84%E4%B8%BB%E8%A6%81%E6%8E%A5%E5%8F%A3\"> 5.2 设计AI类的主要接口</a></p>\n<p id=\"%C2%A05.3%20%E8%AE%BE%E8%AE%A1Man%E7%B1%BB%E7%9A%84%E4%B8%BB%E8%A6%81%E6%8E%A5%E5%8F%A3-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A05.3%20%E8%AE%BE%E8%AE%A1Man%E7%B1%BB%E7%9A%84%E4%B8%BB%E8%A6%81%E6%8E%A5%E5%8F%A3\"> 5.3 设计Man类的主要接口</a></p>\n<p id=\"%C2%A05.4%20%E8%AE%BE%E8%AE%A1ChessGame%E7%9A%84%E4%B8%BB%E8%A6%81%E6%8E%A5%E5%8F%A3-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A05.4%20%E8%AE%BE%E8%AE%A1ChessGame%E7%9A%84%E4%B8%BB%E8%A6%81%E6%8E%A5%E5%8F%A3\"> 5.4 设计ChessGame的主要接口</a></p>\n<p id=\"5.5%20%E6%B7%BB%E5%8A%A0%E5%90%84%E4%B8%AA%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0-toc\" style=\"margin-left:40px;\"><a href=\"#5.5%20%E6%B7%BB%E5%8A%A0%E5%90%84%E4%B8%AA%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0\">5.5 添加各个接口的具体实现</a></p>\n<p id=\"6.%20%E5%AE%9E%E7%8E%B0%E6%B8%B8%E6%88%8F%E6%8E%A7%E5%88%B6-toc\" style=\"margin-left:0px;\"><a href=\"#6.%20%E5%AE%9E%E7%8E%B0%E6%B8%B8%E6%88%8F%E6%8E%A7%E5%88%B6\">6. 实现游戏控制</a></p>\n<p id=\"6.1%20%E6%B7%BB%E5%8A%A0%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98-toc\" style=\"margin-left:40px;\"><a href=\"#6.1%20%E6%B7%BB%E5%8A%A0%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98\">6.1 添加数据成员</a></p>\n<p id=\"6.2%20%E5%AE%9E%E7%8E%B0%E6%B8%B8%E6%88%8F%E6%8E%A7%E5%88%B6%E5%95%8A-toc\" style=\"margin-left:40px;\"><a href=\"#6.2%20%E5%AE%9E%E7%8E%B0%E6%B8%B8%E6%88%8F%E6%8E%A7%E5%88%B6%E5%95%8A\">6.2 实现游戏控制啊</a></p>\n<p id=\"7.%20%E5%88%9B%E5%BB%BA%E6%B8%B8%E6%88%8F%C2%A0-toc\" style=\"margin-left:0px;\"><a href=\"#7.%20%E5%88%9B%E5%BB%BA%E6%B8%B8%E6%88%8F%C2%A0\">7. 创建游戏 </a></p>\n<p id=\"8.%20%E6%A3%8B%E7%9B%98%E7%9A%84%E2%80%9C%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E2%80%9D%E8%AE%BE%E8%AE%A1-toc\" style=\"margin-left:0px;\"><a href=\"#8.%20%E6%A3%8B%E7%9B%98%E7%9A%84%E2%80%9C%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E2%80%9D%E8%AE%BE%E8%AE%A1\">8. 棋盘的“数据成员”设计</a></p>\n<p id=\"9.%20%E4%BD%BF%E7%94%A8%E6%A3%8B%E7%9B%98%E7%B1%BB%E7%9A%84%E2%80%9C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E2%80%9D%20%E5%AF%B9%E6%A3%8B%E7%9B%98%E8%BF%9B%E8%A1%8C%E6%9E%84%E9%80%A0-toc\" style=\"margin-left:0px;\"><a href=\"#9.%20%E4%BD%BF%E7%94%A8%E6%A3%8B%E7%9B%98%E7%B1%BB%E7%9A%84%E2%80%9C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E2%80%9D%20%E5%AF%B9%E6%A3%8B%E7%9B%98%E8%BF%9B%E8%A1%8C%E6%9E%84%E9%80%A0\">9. 使用棋盘类的“构造函数” 对棋盘进行构造</a></p>\n<p id=\"10.%20%E6%A3%8B%E7%9B%98%E7%9A%84%E2%80%9C%E5%88%9D%E5%A7%8B%E5%8C%96%E2%80%9D%20-%20%E6%AD%A3%E5%9C%A8%E6%9B%B4%E6%96%B0-toc\" style=\"margin-left:0px;\"><a href=\"#10.%20%E6%A3%8B%E7%9B%98%E7%9A%84%E2%80%9C%E5%88%9D%E5%A7%8B%E5%8C%96%E2%80%9D%20-%20%E6%AD%A3%E5%9C%A8%E6%9B%B4%E6%96%B0\">10. 棋盘的“初始化” </a></p>\n<p id=\"11.%20%E5%AE%9E%E7%8E%B0%E6%A3%8B%E6%89%8B%E8%B5%B0%E6%A3%8B-toc\" style=\"margin-left:0px;\"><a href=\"#11.%20%E5%AE%9E%E7%8E%B0%E6%A3%8B%E6%89%8B%E8%B5%B0%E6%A3%8B\">11. 实现棋手走棋</a></p>\n<p id=\"11.1%20%E6%A3%8B%E6%89%8B%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96-toc\" style=\"margin-left:40px;\"><a href=\"#11.1%20%E6%A3%8B%E6%89%8B%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96\">11.1 棋手的初始化</a></p>\n<p id=\"11.2%20%E6%A3%8B%E6%89%8B%E8%B5%B0%E6%A3%8B-toc\" style=\"margin-left:40px;\"><a href=\"#11.2%20%E6%A3%8B%E6%89%8B%E8%B5%B0%E6%A3%8B\">11.2 棋手走棋</a></p>\n<p id=\"11.3%20%E5%88%A4%E6%96%AD%E8%90%BD%E5%AD%90%E7%82%B9%E5%87%BB%E4%BD%8D%E7%BD%AE%E6%98%AF%E5%90%A6%E6%9C%89%E6%95%88-toc\" style=\"margin-left:40px;\"><a href=\"#11.3%20%E5%88%A4%E6%96%AD%E8%90%BD%E5%AD%90%E7%82%B9%E5%87%BB%E4%BD%8D%E7%BD%AE%E6%98%AF%E5%90%A6%E6%9C%89%E6%95%88\">11.3 判断落子点击位置是否有效</a></p>\n<p id=\"%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90-toc\" style=\"margin-left:80px;\"><a href=\"#%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90\">原理分析</a></p>\n<p id=\"%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-toc\" style=\"margin-left:80px;\"><a href=\"#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0\">代码实现</a></p>\n<p id=\"12.%20%E5%AE%9E%E7%8E%B0%E6%A3%8B%E7%9B%98%E8%90%BD%E5%AD%90-toc\" style=\"margin-left:0px;\"><a href=\"#12.%20%E5%AE%9E%E7%8E%B0%E6%A3%8B%E7%9B%98%E8%90%BD%E5%AD%90\">12. 实现棋盘落子</a></p>\n<p id=\"12.1%20%E5%AE%9E%E7%8E%B0Chess%E7%B1%BB%E7%9A%84chessDown%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:40px;\"><a href=\"#12.1%20%E5%AE%9E%E7%8E%B0Chess%E7%B1%BB%E7%9A%84chessDown%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0\">12.1 实现Chess类的chessDown成员函数</a></p>\n<p id=\"12.2%20%E4%BF%AE%E6%94%B9%E6%A3%8B%E7%9B%98%E7%9A%84%E6%A3%8B%E5%AD%90%E6%95%B0%E6%8D%AE-toc\" style=\"margin-left:40px;\"><a href=\"#12.2%20%E4%BF%AE%E6%94%B9%E6%A3%8B%E7%9B%98%E7%9A%84%E6%A3%8B%E5%AD%90%E6%95%B0%E6%8D%AE\">12.2 修改棋盘的棋子数据</a></p>\n<p id=\"13.%20%E5%AE%9E%E7%8E%B0AI%E8%B5%B0%E6%A3%8B-toc\" style=\"margin-left:0px;\"><a href=\"#13.%20%E5%AE%9E%E7%8E%B0AI%E8%B5%B0%E6%A3%8B\">13. 实现AI走棋</a></p>\n<p id=\"13.1%20%E8%AE%BE%E8%AE%A1AI%E7%9A%84%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98-toc\" style=\"margin-left:40px;\"><a href=\"#13.1%20%E8%AE%BE%E8%AE%A1AI%E7%9A%84%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98\">13.1 设计AI的数据成员</a></p>\n<p id=\"13.2%20%E5%AF%B9AI%E8%BF%9B%E8%A1%8C%E5%88%9D%E5%A7%8B%E5%8C%96-toc\" style=\"margin-left:40px;\"><a href=\"#13.2%20%E5%AF%B9AI%E8%BF%9B%E8%A1%8C%E5%88%9D%E5%A7%8B%E5%8C%96\">13.2 对AI进行初始化</a></p>\n<p id=\"13.3%20AI%E2%80%9C%E6%80%9D%E8%80%83%E2%80%9D%E6%80%8E%E6%A0%B7%E8%B5%B0%E6%A3%8B-toc\" style=\"margin-left:40px;\"><a href=\"#13.3%20AI%E2%80%9C%E6%80%9D%E8%80%83%E2%80%9D%E6%80%8E%E6%A0%B7%E8%B5%B0%E6%A3%8B\">13.3 AI“思考”怎样走棋</a></p>\n<p id=\"13.3.1%20AI%E5%AF%B9%E8%90%BD%E5%AD%90%E7%82%B9%E8%BF%9B%E8%A1%8C%E8%AF%84%E5%88%86-toc\" style=\"margin-left:80px;\"><a href=\"#13.3.1%20AI%E5%AF%B9%E8%90%BD%E5%AD%90%E7%82%B9%E8%BF%9B%E8%A1%8C%E8%AF%84%E5%88%86\">13.3.1 AI对落子点进行评分</a></p>\n<p id=\"13.3.2%C2%A0%C2%A0AI%E6%A0%B9%E6%8D%AE%E8%AF%84%E5%88%86%E8%BF%9B%E8%A1%8C%E2%80%9C%E6%80%9D%E8%80%83%E2%80%9D-toc\" style=\"margin-left:80px;\"><a href=\"#13.3.2%C2%A0%C2%A0AI%E6%A0%B9%E6%8D%AE%E8%AF%84%E5%88%86%E8%BF%9B%E8%A1%8C%E2%80%9C%E6%80%9D%E8%80%83%E2%80%9D\">13.3.2  AI根据评分进行“思考”</a></p>\n<p id=\"%C2%A012.3.3%20AI%E8%B5%B0%E6%A3%8B-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A012.3.3%20AI%E8%B5%B0%E6%A3%8B\"> 12.3.3 AI走棋</a></p>\n<p id=\"%C2%A012.3.4%20%E6%B5%8B%E8%AF%95-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A012.3.4%20%E6%B5%8B%E8%AF%95\"> 12.3.4 测试</a></p>\n<p id=\"14.%20AI%E7%9A%84BUG-toc\" style=\"margin-left:0px;\"><a href=\"#14.%20AI%E7%9A%84BUG\">14. AI的BUG</a></p>\n<p id=\"15.%20%E5%88%A4%E6%96%AD%E8%83%9C%E8%B4%9F-toc\" style=\"margin-left:0px;\"><a href=\"#15.%20%E5%88%A4%E6%96%AD%E8%83%9C%E8%B4%9F\">15. 判断胜负</a></p>\n<p id=\"15.1%20%E5%AF%B9%E8%83%9C%E8%B4%9F%E8%BF%9B%E8%A1%8C%E5%A4%84%E7%90%86-toc\" style=\"margin-left:40px;\"><a href=\"#15.1%20%E5%AF%B9%E8%83%9C%E8%B4%9F%E8%BF%9B%E8%A1%8C%E5%A4%84%E7%90%86\">15.1 对胜负进行处理</a></p>\n<p id=\"15.2%20%E8%83%9C%E8%B4%9F%E5%88%A4%E5%AE%9A%E5%8E%9F%E7%90%86-toc\" style=\"margin-left:40px;\"><a href=\"#15.2%20%E8%83%9C%E8%B4%9F%E5%88%A4%E5%AE%9A%E5%8E%9F%E7%90%86\">15.2 胜负判定原理</a></p>\n<p id=\"15.%203%20%E5%AE%9E%E7%8E%B0%E8%83%9C%E8%B4%9F%E5%88%A4%E5%AE%9A-toc\" style=\"margin-left:40px;\"><a href=\"#15.%203%20%E5%AE%9E%E7%8E%B0%E8%83%9C%E8%B4%9F%E5%88%A4%E5%AE%9A\">15. 3 实现胜负判定</a></p>\n<p id=\"15.%204%20%E6%B5%8B%E8%AF%95%E6%95%88%E6%9E%9C-toc\" style=\"margin-left:40px;\"><a href=\"#15.%204%20%E6%B5%8B%E8%AF%95%E6%95%88%E6%9E%9C\">15. 4 测试效果</a></p>\n<p id=\"16.%20AI%E8%BF%9B%E4%B8%80%E6%AD%A5%E4%BC%98%E5%8C%96-toc\" style=\"margin-left:0px;\"><a href=\"#16.%20AI%E8%BF%9B%E4%B8%80%E6%AD%A5%E4%BC%98%E5%8C%96\">16. AI进一步优化</a></p>\n<p id=\"AI%E6%8F%90%E5%8D%87-toc\" style=\"margin-left:40px;\"><a href=\"#AI%E6%8F%90%E5%8D%87\">AI提升</a></p>\n<p id=\"17.%20%E5%BC%80%E5%8F%91%E6%8B%93%E5%B1%95-toc\" style=\"margin-left:0px;\"><a href=\"#17.%20%E5%BC%80%E5%8F%91%E6%8B%93%E5%B1%95\">17. 开发拓展</a></p>\n<hr id=\"hr-toc\"/>\n<p>五子棋人机对战，已经有很版本。但是使用纯C++，严格按照C++面向对象思想开发的，却还是很少的，所以准备使用C++面向对象的思想，开发一个完整的五子棋人机对战，对于C++初学者，是很有帮助的哦！</p>\n<h1 id=\"%C2%A0%E6%9C%AC%E6%95%99%E7%A8%8B%E9%85%8D%E5%A5%97%E8%A7%86%E9%A2%91\"><br/><span style=\"color:#fe2c24;\"> <a class=\"link-info\" href=\"https://www.bilibili.com/video/BV1kL4y1P7rY?spm_id_from=333.999.0.0&amp;vd_source=05c3adf2198b00bec5d478e6a244b76b\" title=\"本教程配套视频\">本教程配套视频</a></span></h1>\n<h1 id=\"1.%20%E9%A1%B9%E7%9B%AE%E7%9B%AE%E6%A0%87\">1. 项目目标</h1>\n<ul><li>掌握C++的核心技术</li><li>掌握C++开发项目的方法和流程</li><li>掌握AI算法的基础应用</li></ul>\n<h1 id=\"2.%20%E6%95%88%E6%9E%9C%E6%BC%94%E7%A4%BA\">2. 效果演示</h1>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/ecc66a2dd42b4cd0aea6c149b6203fec.gif\"/></p>\n<p>开局头像，没有看错，就是我哈，棋魂附体 :-)</p>\n<p><img alt=\"\" height=\"291\" src=\"image\\381438f72d54461b81174ae44e0c75be.png\" width=\"701\"/></p>\n<p>准备好 了吗？直接上代码！</p>\n<h1 id=\"3.%20%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE\">3. 创建项目</h1>\n<p>使用VS2019+easyx图形库开发，也可以使用VS的其他版本。</p>\n<p>参考：<a class=\"link-info\" href=\"https://www.bilibili.com/video/BV1244y1J7cV?spm_id_from=333.999.0.0\" title=\"VS2019安装教程\">VS2019安装教程</a>    <a class=\"link-info\" href=\"https://www.bilibili.com/video/BV1M44y1p7Te?spm_id_from=333.999.0.0\" title=\"easyx图形库入门教程\">easyx图形库入门教程</a></p>\n<p> 使用VS2019（或VS2022）创建一个新项目，选择空项目模板。</p>\n<p><img alt=\"\" height=\"680\" src=\"image\\66e20515547b4f01b78f48ed3fab8a7f.png\" width=\"1024\"/></p>\n<p>然后再导入图片素材res目录。因网盘链接不稳定，在评论中回复邮件地址，即发送完整素材。也可以使用自己的素材。</p>\n<p><img alt=\"\" height=\"157\" src=\"image\\a6103f1a2f2c49d292ed04a0473862a6.png\" width=\"650\"/></p>\n<h1 id=\"%C2%A04.%20%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1\"> 4. 项目框架设计</h1>\n<h2 id=\"4.1%20%E8%AE%BE%E8%AE%A1%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6\">4.1 设计项目框架</h2>\n<p>使用C语言开发的初学者，往往直接就在main函数中写详细的过程。使用C++面向对象，就需要“脱胎换骨”，改变开发思路了！不写过程，直接写需要几个类！</p>\n<p><img alt=\"\" height=\"627\" src=\"image\\c800f28170b547a39808c0514b4477bc.png\" width=\"961\"/></p>\n<p>这里，设计了4个类，分别表示棋手，AI, 棋盘，游戏控制。这应该是最符合现实情况的简单设计了，如果是做网络对战版，就还需要添加其它模块。</p>\n<h2 id=\"4.2%20%E6%A0%B9%E6%8D%AE%E8%AE%BE%E8%AE%A1%E6%A1%86%E6%9E%B6%E5%88%9B%E5%BB%BA%E7%B1%BB\">4.2 根据设计框架创建类</h2>\n<p>创建项目框架中描述的4个类。可以使用如下方式创建类：</p>\n<p><img alt=\"\" height=\"834\" src=\"image\\808cb67ab3f54eb8963f8a368b2346fd.png\" width=\"902\"/></p>\n<p> 填写类名，再单击确定即可。</p>\n<p><img alt=\"\" height=\"450\" src=\"image\\62726c3664cd4526acdab468d656e106.png\" width=\"600\"/></p>\n<p>按照这个方式，一共创建4个类：Man, AI, Chess, ChessGame. 创建完后，项目的目录结构如：</p>\n<p><img alt=\"\" height=\"352\" src=\"image\\06a89b62c13c46ddbdcd7b92219bc134.png\" width=\"316\"/></p>\n<h1 id=\"%C2%A05.%20%E7%BB%99%E7%B1%BB%E6%B7%BB%E5%8A%A0%E4%B8%BB%E8%A6%81%E6%8E%A5%E5%8F%A3\"> 5. 给类添加主要接口</h1>\n<h2 id=\"5.1%20%E8%AE%BE%E8%AE%A1%E6%A3%8B%E7%9B%98%E7%B1%BBChess%E7%9A%84%E4%B8%BB%E8%A6%81%E6%8E%A5%E5%8F%A3\">5.1 设计棋盘类Chess的主要接口</h2>\n<p>注意：在给类设计接口时，建议先只考虑对外暴露的“接口”，可以先不用考虑数据成员，对外（public）提供的接口（函数）才是最重要的。</p>\n<p>Chess.h</p>\n<pre><code class=\"language-cpp\">typedef enum {\n\tCHESS_WHITE = -1,  // 白方\n\tCHESS_BLACK = 1    // 黑方\n} chess_kind_t;\n\nstruct ChessPos {\n\tint row;\n\tint col;\n};\n\nclass Chess\n{\npublic:\n\t// 棋盘的初始化：加载棋盘的图片资源，初始化棋盘的相关数据\n\tvoid init();\n\n\t// 判断在指定坐标(x,y)位置，是否是有效点击\n\t// 如果是有效点击，把有效点击的位置(行，列）保存在参数pos中\n\tbool clickBoard(int x, int y, ChessPos* pos);\n\n\t// 在棋盘的指定位置（pos）, 落子（kind）\n\tvoid chessDown(ChessPos* pos, chess_kind_t kind);\n\n\t// 获取棋盘的大小（13线、15线、19线）\n\tint getGradeSize();\n\n\t// 获取指定位置是黑棋，还是白棋，还是空白\n\tint getChessData(ChessPos* pos);\n\tint getChessData(int row, int col);\n\n\t// 判断棋局是否结束\n\tbool checkOver();\n};</code></pre>\n<h2 id=\"%C2%A05.2%20%E8%AE%BE%E8%AE%A1AI%E7%B1%BB%E7%9A%84%E4%B8%BB%E8%A6%81%E6%8E%A5%E5%8F%A3\"> 5.2 设计AI类的主要接口</h2>\n<p>AI.h</p>\n<pre><code class=\"language-cpp\">#include \"Chess.h\"\nclass AI\n{\npublic:\n\tvoid init(Chess* chess);\n\tvoid go();\n};</code></pre>\n<h2 id=\"%C2%A05.3%20%E8%AE%BE%E8%AE%A1Man%E7%B1%BB%E7%9A%84%E4%B8%BB%E8%A6%81%E6%8E%A5%E5%8F%A3\"> 5.3 设计Man类的主要接口</h2>\n<p>Man.h </p>\n<pre><code class=\"language-cpp\">#include \"Chess.h\"\n\nclass Man\n{\npublic:\n\tvoid init(Chess* chess);\n\tvoid go();\n};</code></pre>\n<h2 id=\"%C2%A05.4%20%E8%AE%BE%E8%AE%A1ChessGame%E7%9A%84%E4%B8%BB%E8%A6%81%E6%8E%A5%E5%8F%A3\"> 5.4 设计ChessGame的主要接口</h2>\n<p>ChessGame.h</p>\n<pre><code class=\"language-cpp\">class ChessGame\n{\npublic:\n\tvoid play();\n};</code></pre>\n<h2 id=\"5.5%20%E6%B7%BB%E5%8A%A0%E5%90%84%E4%B8%AA%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0\">5.5 添加各个接口的具体实现</h2>\n<p style=\"margin-left:.0001pt;text-align:justify;\">可以使用如下方式自动生成各接口的具体实现。先不用考虑各个接口的真正实现，直接使用空函数体代替。 </p>\n<p id=\"%E2%80%8B%E7%BC%96%E8%BE%91\" style=\"margin-left:.0001pt;text-align:justify;\"><img alt=\"\" height=\"319\" src=\"image\\4f6db9d47cfa42c185a68e641ad58e8d.png\" width=\"778\"/></p>\n<h1 id=\"6.%20%E5%AE%9E%E7%8E%B0%E6%B8%B8%E6%88%8F%E6%8E%A7%E5%88%B6\" style=\"margin-left:.0001pt;text-align:justify;\">6. 实现游戏控制</h1>\n<p>直接调用各个类定义的接口，实现游戏的主体控制。</p>\n<h2 id=\"6.1%20%E6%B7%BB%E5%8A%A0%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98\">6.1 添加数据成员</h2>\n<p>为了便于调用各个类的功能，在ChessGame中，添加3各数据成员，并再构造函数中初始化这三个数据成员。</p>\n<pre><code class=\"language-cpp\">#include \"Man.h\"\n#include \"AI.h\"\n#include \"Chess.h\"\n\nclass ChessGame\n{\npublic:\n\tChessGame(Man*, AI*, Chess*);\n\tvoid play();\n\nprivate:\n\tMan* man;\n\tAI* ai;\n\tChess* chess;\n};\n\nChessGame::ChessGame(Man* man, AI* ai, Chess* chess)\n{\n\tthis-&gt;man = man;\n\tthis-&gt;ai = ai;\n\tthis-&gt;chess = chess;\n\n\tai-&gt;init(chess);\n\tman-&gt;init(chess);\n}</code></pre>\n<h2 id=\"6.2%20%E5%AE%9E%E7%8E%B0%E6%B8%B8%E6%88%8F%E6%8E%A7%E5%88%B6%E5%95%8A\">6.2 实现游戏控制啊</h2>\n<pre><code class=\"language-cpp\">void ChessGame::play()\n{\n\tchess-&gt;init();\n\twhile (1) {\n\t\tman-&gt;go();\n\t\tif (chess-&gt;checkOver()) {\n\t\t\tchess-&gt;init();;\n\t\t\tcontinue;\n\t\t}\n\n\t\tai-&gt;go();\n\t\tif (chess-&gt;checkOver()) {\n\t\t\tchess-&gt;init();\n\t\t\tcontinue;\n\t\t}\n\t}\n}</code></pre>\n<h1 id=\"7.%20%E5%88%9B%E5%BB%BA%E6%B8%B8%E6%88%8F%C2%A0\">7. 创建游戏 </h1>\n<p>在main函数中，创建游戏。</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include \"ChessGame.h\"\n\nint main(void) {\n\tChess chess;\n\tMan man;\n\tAI ai;\n\tChessGame game(&amp;man, &amp;ai, &amp;chess);\n\n\tgame.play();\n\n\treturn 0;\n}</code></pre>\n<h1 id=\"8.%20%E6%A3%8B%E7%9B%98%E7%9A%84%E2%80%9C%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E2%80%9D%E8%AE%BE%E8%AE%A1\">8. 棋盘的“数据成员”设计</h1>\n<p>为棋盘类，添加private权限的“数据成员”。</p>\n<pre><code class=\"language-cpp\">private:\n\t// 棋盘尺寸\n\tint gradeSize;\n\tfloat margin_x;//49;\n\tint margin_y;// 49;\n\tfloat chessSize; //棋子大小（棋盘方格大小）\n\n\tIMAGE chessBlackImg;\n\tIMAGE chessWhiteImg;\n\n\t// 存储当前游戏棋盘和棋子的情况,空白为0，黑子1，白子-1\n\tvector&lt;vector&lt;int&gt;&gt; chessMap;\n\n\t// 标示下棋方, true:黑棋方  false: AI 白棋方（AI方）\n\tbool playerFlag;</code></pre>\n<p>再补充一下头文件。</p>\n<pre><code class=\"language-cpp\">#include &lt;graphics.h&gt;\n#include &lt;vector&gt;\nusing namespace std;</code></pre>\n<h1 id=\"9.%20%E4%BD%BF%E7%94%A8%E6%A3%8B%E7%9B%98%E7%B1%BB%E7%9A%84%E2%80%9C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E2%80%9D%20%E5%AF%B9%E6%A3%8B%E7%9B%98%E8%BF%9B%E8%A1%8C%E6%9E%84%E9%80%A0\">9. 使用棋盘类的“构造函数” 对棋盘进行构造</h1>\n<p>添加棋盘类的构造函数的定义以及实现。</p>\n<p>Chess.h</p>\n<pre><code class=\"language-cpp\">Chess(int gradeSize, int marginX, int marginY, float chessSize);</code></pre>\n<p>Chess.cpp</p>\n<pre><code class=\"language-cpp\">Chess::Chess(int gradeSize, int marginX, int marginY, float chessSize)\n{\n\tthis-&gt;gradeSize = gradeSize;\n\tthis-&gt;margin_x = marginX;\n\tthis-&gt;margin_y = marginY;\n\tthis-&gt;chessSize = chessSize;\n\tplayerFlag = CHESS_BLACK;\n\n\tfor (int i = 0; i &lt; gradeSize; i++) {\n\t\tvector&lt;int&gt;row;\n\t\tfor (int j = 0; j &lt; gradeSize; j++) {\n\t\t\trow.push_back(0);\n\t\t}\n\t\tchessMap.push_back(row);\n\t}\n}</code></pre>\n<p style=\"margin-left:.0001pt;text-align:justify;\">同时修改main函数的Chess对象的创建。、</p>\n<pre><code class=\"language-cpp\">\t//Chess chess;\n\tChess chess(13, 44, 43, 67.4);</code></pre>\n<h1 id=\"10.%20%E6%A3%8B%E7%9B%98%E7%9A%84%E2%80%9C%E5%88%9D%E5%A7%8B%E5%8C%96%E2%80%9D%20-%20%E6%AD%A3%E5%9C%A8%E6%9B%B4%E6%96%B0\">10. 棋盘的“初始化” </h1>\n<p>对棋盘进行数据初始化，使得能够看到实际的棋盘。</p>\n<pre><code class=\"language-cpp\">void Chess::init()\n{\n\tinitgraph(897, 895);\n\tloadimage(0, \"res/棋盘2.jpg\");\n\n\tmciSendString(\"play res/start.wav\", 0, 0, 0); //需要修改字符集为多字节字符集\n\n\tloadimage(&amp;chessBlackImg, \"res/black.png\", chessSize, chessSize, true);\n\tloadimage(&amp;chessWhiteImg, \"res/white.png\", chessSize, chessSize, true);\n\n\tfor (int i = 0; i &lt; chessMap.size(); i++) {\n\t\tfor (int j = 0; j &lt; chessMap[i].size(); j++) {\n\t\t\tchessMap[i][j] = 0;\n\t\t}\n\t}\n\n\tplayerFlag = true;\n}</code></pre>\n<p>添加头文件和相关库，使得能够播放落子音效。<br/> Chess.cpp</p>\n<pre><code class=\"language-cpp\">#include &lt;mmsystem.h&gt;\n#pragma comment(lib, \"winmm.lib\")\n</code></pre>\n<p> 修改项目的字符集为“多字节字符集”。</p>\n<p><img alt=\"\" height=\"555\" src=\"image\\946113392c6244d3b2525170064de36f.png\" width=\"800\"/></p>\n<p> 测试效果：</p>\n<p><img alt=\"\" height=\"934\" src=\"image\\37e51e38f0504f0091e6520f3133553d.png\" width=\"913\"/></p>\n<h1 id=\"11.%20%E5%AE%9E%E7%8E%B0%E6%A3%8B%E6%89%8B%E8%B5%B0%E6%A3%8B\">11. 实现棋手走棋</h1>\n<p>现在执行程序，除了弹出的棋盘，什么都不能干。因为，棋手的走棋函数，还没有实现哦！现在来实现棋手走棋功能。</p>\n<h2 id=\"11.1%20%E6%A3%8B%E6%89%8B%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96\">11.1 棋手的初始化</h2>\n<p>为棋手类，添加数据成员，表示棋盘</p>\n<p>Man.h</p>\n<pre><code>private:\n\tChess* chess;</code></pre>\n<p>实现棋手对象的初始化。</p>\n<p>Man.cpp</p>\n<pre><code class=\"language-cpp\">void Man::init(Chess* chess)\n{\n\tthis-&gt;chess = chess;\n}</code></pre>\n<p>在ChessGame的构造函数中，实现棋手的初始化。</p>\n<p>ChessGame.cpp</p>\n<pre><code class=\"language-cpp\">ChessGame::ChessGame(Man* man, AI* ai, Chess* chess)\n{\n\tthis-&gt;man = man;\n\tthis-&gt;ai = ai;\n\tthis-&gt;chess = chess;\n\n\tman-&gt;init(chess);  //初始化棋手\n}</code></pre>\n<h2 id=\"11.2%20%E6%A3%8B%E6%89%8B%E8%B5%B0%E6%A3%8B\">11.2 棋手走棋</h2>\n<p>Man.cpp</p>\n<pre><code class=\"language-cpp\">void Man::go(){\n\t// 等待棋士有效落子\n\tMOUSEMSG msg;\n\tChessPos pos;\n\twhile (1) {\n\t\tmsg = GetMouseMsg();\n\t\tif (msg.uMsg == WM_LBUTTONDOWN &amp;&amp; chess-&gt;clickBoard(msg.x, msg.y, &amp;pos)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// 落子\n\tchess-&gt;chessDown(&amp;pos, CHESS_BLACK);\n}</code></pre>\n<h2 id=\"11.3%20%E5%88%A4%E6%96%AD%E8%90%BD%E5%AD%90%E7%82%B9%E5%87%BB%E4%BD%8D%E7%BD%AE%E6%98%AF%E5%90%A6%E6%9C%89%E6%95%88\">11.3 判断落子点击位置是否有效</h2>\n<p>执行程序后，还是没有任何效果，因为落子的有效性还没有判断。</p>\n<h3 id=\"%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90\">原理分析</h3>\n<p><img alt=\"\" height=\"182\" src=\"image\\4758d29b64de4a04a6567a46af2f3bf9.png\" width=\"235\"/></p>\n<p>先计算点击位置附近的4个点的位置，然后再计算点击位置到这四个点之间的距离，如果离某个点的距离小于“阈值”，就认为这个点是落子位置。这个“阈值”， 小于棋子大小的一半即可。我们这里取棋子大小的0.4倍。</p>\n<h3 id=\"%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0\">代码实现</h3>\n<p>Chess.cpp</p>\n<pre><code class=\"language-cpp\">bool Chess::clickBoard(int x, int y, ChessPos* pos)\n{\n\tint col = (x - margin_x) / chessSize;\n\tint row = (y - margin_y) / chessSize;\n\n\tint leftTopPosX = margin_x + chessSize * col;\n\tint leftTopPosY = margin_y + chessSize * row;\n\tint offset = chessSize * 0.4; // 20 鼠标点击的模糊距离上限\n\n\tint len;\n\tint selectPos = false;\n\n\tdo {\n\t\tlen = sqrt((x - leftTopPosX) * (x - leftTopPosX) + (y - leftTopPosY) * (y - leftTopPosY));\n\t\tif (len &lt; offset) {\n\t\t\tpos-&gt;row = row;\n\t\t\tpos-&gt;col = col;\n\t\t\tif (chessMap[pos-&gt;row][pos-&gt;col] == 0) {\n\t\t\t\tselectPos = true;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t// 距离右上角的距离\n\t\tlen = sqrt((x - leftTopPosX - chessSize) * (x - leftTopPosX - chessSize) + (y - leftTopPosY) * (y - leftTopPosY));\n\t\tif (len &lt; offset) {\n\t\t\tpos-&gt;row = row;\n\t\t\tpos-&gt;col = col + 1;\n\t\t\tif (chessMap[pos-&gt;row][pos-&gt;col] == 0) {\n\t\t\t\tselectPos = true;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t// 距离左下角的距离\n\t\tlen = sqrt((x - leftTopPosX) * (x - leftTopPosX) + (y - leftTopPosY - chessSize) * (y - leftTopPosY - chessSize));\n\t\tif (len &lt; offset) {\n\t\t\tpos-&gt;row = row + 1;\n\t\t\tpos-&gt;col = col;\n\t\t\tif (chessMap[pos-&gt;row][pos-&gt;col] == 0) {\n\t\t\t\tselectPos = true;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t// 距离右下角的距离\n\t\tlen = sqrt((x - leftTopPosX - chessSize) * (x - leftTopPosX - chessSize) + (y - leftTopPosY - chessSize) * (y - leftTopPosY - chessSize));\n\t\tif (len &lt; offset) {\n\t\t\tpos-&gt;row = row + 1;\n\t\t\tpos-&gt;col = col + 1;\n\n\t\t\tif (chessMap[pos-&gt;row][pos-&gt;col] == 0) {\n\t\t\t\tselectPos = true;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t} while (0);\n\n\treturn selectPos;\n}</code></pre>\n<p>可以通过打印语句，测试判断是否准确。</p>\n<h1 id=\"12.%20%E5%AE%9E%E7%8E%B0%E6%A3%8B%E7%9B%98%E8%90%BD%E5%AD%90\">12. 实现棋盘落子</h1>\n<h2 id=\"12.1%20%E5%AE%9E%E7%8E%B0Chess%E7%B1%BB%E7%9A%84chessDown%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0\">12.1 实现Chess类的chessDown成员函数</h2>\n<pre><code class=\"language-cpp\">void Chess::chessDown(ChessPos *pos, chess_kind_t kind)\n{\n\tmciSendString(\"play res/down7.WAV\", 0, 0, 0);\n\n\tint x = margin_x + pos-&gt;col * chessSize - 0.5 * chessSize;\n\tint y = margin_y + pos-&gt;row * chessSize - 0.5 * chessSize;\n\n\tif (kind == CHESS_WHITE) {\n\t\tputimagePNG(x, y, &amp;chessWhiteImg);\n\t}\n\telse {\n\t\tputimagePNG(x, y, &amp;chessBlackImg);\n\t}\n\n}</code></pre>\n<p>检查落子效果： <img alt=\"\" height=\"924\" src=\"image\\4954adfe755f44cfafb881bd0ee8fd99.png\" width=\"913\"/></p>\n<p></p>\n<p>棋子背后有黑色背景。这是因为easyx图形库默认不支持背景透明的png格式图片，把透明部分直接渲染为黑色了。解决方案，使用自定义的图形渲染接口，如下：</p>\n<pre><code class=\"language-cpp\">void putimagePNG(int x, int y, IMAGE* picture) //x为载入图片的X坐标，y为Y坐标\n{\n\t// 变量初始化\n\tDWORD* dst = GetImageBuffer();    // GetImageBuffer()函数，用于获取绘图设备的显存指针，EASYX自带\n\tDWORD* draw = GetImageBuffer();\n\tDWORD* src = GetImageBuffer(picture); //获取picture的显存指针\n\tint picture_width = picture-&gt;getwidth(); //获取picture的宽度，EASYX自带\n\tint picture_height = picture-&gt;getheight(); //获取picture的高度，EASYX自带\n\tint graphWidth = getwidth();       //获取绘图区的宽度，EASYX自带\n\tint graphHeight = getheight();     //获取绘图区的高度，EASYX自带\n\tint dstX = 0;    //在显存里像素的角标\n\n\t// 实现透明贴图 公式： Cp=αp*FP+(1-αp)*BP ， 贝叶斯定理来进行点颜色的概率计算\n\tfor (int iy = 0; iy &lt; picture_height; iy++)\n\t{\n\t\tfor (int ix = 0; ix &lt; picture_width; ix++)\n\t\t{\n\t\t\tint srcX = ix + iy * picture_width; //在显存里像素的角标\n\t\t\tint sa = ((src[srcX] &amp; 0xff000000) &gt;&gt; 24); //0xAArrggbb;AA是透明度\n\t\t\tint sr = ((src[srcX] &amp; 0xff0000) &gt;&gt; 16); //获取RGB里的R\n\t\t\tint sg = ((src[srcX] &amp; 0xff00) &gt;&gt; 8);   //G\n\t\t\tint sb = src[srcX] &amp; 0xff;              //B\n\t\t\tif (ix &gt;= 0 &amp;&amp; ix &lt;= graphWidth &amp;&amp; iy &gt;= 0 &amp;&amp; iy &lt;= graphHeight &amp;&amp; dstX &lt;= graphWidth * graphHeight)\n\t\t\t{\n\t\t\t\tdstX = (ix + x) + (iy + y) * graphWidth; //在显存里像素的角标\n\t\t\t\tint dr = ((dst[dstX] &amp; 0xff0000) &gt;&gt; 16);\n\t\t\t\tint dg = ((dst[dstX] &amp; 0xff00) &gt;&gt; 8);\n\t\t\t\tint db = dst[dstX] &amp; 0xff;\n\t\t\t\tdraw[dstX] = ((sr * sa / 255 + dr * (255 - sa) / 255) &lt;&lt; 16)  //公式： Cp=αp*FP+(1-αp)*BP  ； αp=sa/255 , FP=sr , BP=dr\n\t\t\t\t\t| ((sg * sa / 255 + dg * (255 - sa) / 255) &lt;&lt; 8)         //αp=sa/255 , FP=sg , BP=dg\n\t\t\t\t\t| (sb * sa / 255 + db * (255 - sa) / 255);              //αp=sa/255 , FP=sb , BP=db\n\t\t\t}\n\t\t}\n\t}\n}\n</code></pre>\n<p> 再把chessDown中的putimage更换为putimagePNG, 测试效果如下：</p>\n<p><img alt=\"\" height=\"934\" src=\"image\\dbf69e1051a14b6aab831616463bfd40.png\" width=\"913\"/></p>\n<p>如上，黑色背景已经被去除。</p>\n<h2 id=\"12.2%20%E4%BF%AE%E6%94%B9%E6%A3%8B%E7%9B%98%E7%9A%84%E6%A3%8B%E5%AD%90%E6%95%B0%E6%8D%AE\">12.2 修改棋盘的棋子数据</h2>\n<p>在界面上落子之后，还需要修改棋盘的棋子数据。为Chess类添加updateGameMap函数来修改棋子数据。这个方法，是给棋盘对象内部使用的，不需要开放给他人使用，所有把权限设置为private，设置为public也可以，但是从技术角度就不安全了。如果他人直接调用这个函数，就会导致棋盘的数据和界面上看到的数据不一样。</p>\n<p>Chess.h</p>\n<pre><code class=\"language-cpp\">private:\n\tvoid updateGameMap(ChessPos *pos);</code></pre>\n<p>Chess.cpp</p>\n<pre><code class=\"language-cpp\">void Chess::updateGameMap(ChessPos* pos)\n{\n    lastPos = *pos;\n\tchessMap[pos-&gt;row][pos-&gt;col] = playerFlag ? 1 : -1;\n\tplayerFlag = !playerFlag; // 换手\n}</code></pre>\n<p>在落子后，调用updateGameMap更新棋子数据。</p>\n<pre><code class=\"language-cpp\">void Chess::chessDown(ChessPos *pos, chess_kind_t kind)\n{\n\t// ......\n\n\tupdateGameMap(pos);\n}</code></pre>\n<h1 id=\"13.%20%E5%AE%9E%E7%8E%B0AI%E8%B5%B0%E6%A3%8B\">13. 实现AI走棋</h1>\n<p>终于可以设计我们的AI模块了！</p>\n<h2 id=\"13.1%20%E8%AE%BE%E8%AE%A1AI%E7%9A%84%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98\">13.1 设计AI的数据成员</h2>\n<blockquote>\n<ul><li>添加棋盘数据成员，以表示对哪个棋盘下棋。</li><li>添加评分数组, 用来存储AI对棋盘所有落点的价值评估。这也是人机对战最重要的部分。</li></ul>\n</blockquote>\n<p>AI.h </p>\n<pre><code class=\"language-cpp\">private:\n\tChess* chess;\n\t// 存储各个点位的评分情况，作为AI下棋依据\n\tvector&lt;vector&lt;int&gt;&gt; scoreMap;</code></pre>\n<h2 id=\"13.2%20%E5%AF%B9AI%E8%BF%9B%E8%A1%8C%E5%88%9D%E5%A7%8B%E5%8C%96\">13.2 对AI进行初始化</h2>\n<p>AI.cpp</p>\n<pre><code class=\"language-cpp\">void AI::init(Chess* chess)\n{\n    this-&gt;chess = chess;\n\n    int size = chess-&gt;getGradeSize();\n    for (int i = 0; i &lt; size; i++) {\n        vector&lt;int&gt; row;\n        for (int j = 0; j &lt; size; j++) {\n            row.push_back(0);\n        }\n        scoreMap.push_back(row);\n    }\n}</code></pre>\n<h2 id=\"13.3%20AI%E2%80%9C%E6%80%9D%E8%80%83%E2%80%9D%E6%80%8E%E6%A0%B7%E8%B5%B0%E6%A3%8B\">13.3 AI“思考”怎样走棋</h2>\n<p>AI的思考方法，就是对棋盘的所有可能落子点，做评分计算，然后选择一个评分最高的点落子。</p>\n<h3 id=\"13.3.1%20AI%E5%AF%B9%E8%90%BD%E5%AD%90%E7%82%B9%E8%BF%9B%E8%A1%8C%E8%AF%84%E5%88%86\">13.3.1 AI对落子点进行评分</h3>\n<p>对每一个可能的落子点，从该点周围的八个方向，分别计算，确定出每个方向已经有几颗连续的棋子。</p>\n<blockquote>\n<p><strong>棋理格言：敌之好点，即我之好点。</strong><br/> 就是说，每个点，都要考虑，如果敌方占领了这个点，会产生多大的价值，如果我方占领了这个点，又会产生多大的价值。如果我方占领这个点，价值只有1000，但是敌方要是占领了这个点，价值有2000，而在自己在其它位置没有价值更高的点，那么建议直接抢占这个敌方的好点。</p>\n</blockquote>\n<p>兵家必争之地：荆州（隆中对的第一步，就是取荆州）<br/><img alt=\"\" height=\"603\" src=\"image\\e9a974094e334b96accf9bcc61cc1371.png\" width=\"660\"/></p>\n<p></p>\n<p>AI先计算棋手如果在这个位置落子，会有多大的价值。然后再计算自己如果在这个位置落子，有大大价值。具体计算方法，就是计算如果黑棋或者白棋在这个位置落子，那么在这个位置的某个方向上， 一共有连续几个黑子或者连续几个白子。连续的数量越多，价值越大。</p>\n<p><img alt=\"\" height=\"409\" src=\"image\\4544c632392a493e9272b243ac683730.png\" width=\"470\"/></p>\n<p><strong> 常见棋形</strong></p>\n<p>连2：<br/><img alt=\"\" height=\"127\" src=\"image\\593c0d4700954e76a780897becf2c1ad.png\" width=\"344\"/></p>\n<p>活3<br/><img alt=\"\" height=\"143\" src=\"image\\963e7d70a40345aaa008bac5afed75ff.png\" width=\"398\"/></p>\n<p>死3<br/><img alt=\"\" height=\"222\" src=\"image\\e42c6f58ad8f44dd97cc416d7c09c7b3.png\" width=\"487\"/></p>\n<p>活4<br/><img alt=\"\" height=\"247\" src=\"image\\2fa9cab098bb49efa04663d0de908224.png\" width=\"509\"/></p>\n<p>死4<br/><img alt=\"\" height=\"245\" src=\"image\\45c1e38d466749a491cbd9772772d7b8.png\" width=\"584\"/></p>\n<p>连5（赢棋）<br/><img alt=\"\" height=\"250\" src=\"image\\f2a6a76cebc847bd8b4269aa066cacd0.png\" width=\"589\"/></p>\n<p>如果走这个点，产生的棋形以及对应评分：<br/><img alt=\"\" height=\"309\" src=\"image\\f442bc0d65ab4cfca9adb1978df7f8b8.png\" width=\"404\"/></p>\n<p> 用代码实现评分计算<br/> AI.h</p>\n<pre><code>private:\n\tvoid calculateScore();</code></pre>\n<p>AI.cpp</p>\n<pre><code class=\"language-cpp\">void AI::calculateScore()\n{\n    // 统计玩家或者电脑连成的子\n    int personNum = 0;  // 玩家连成子的个数\n    int botNum = 0;     // AI连成子的个数\n    int emptyNum = 0;   // 各方向空白位的个数\n\n    // 清空评分数组\n    for (int i = 0; i &lt; scoreMap.size(); i++) {\n        for (int j = 0; j &lt; scoreMap[i].size(); j++) {\n            scoreMap[i][j] = 0;\n        }\n    }\n\n    int size = chess-&gt;getGradeSize();\n    for (int row = 0; row &lt; size; row++)\n        for (int col = 0; col &lt; size; col++)\n        {\n            // 空白点就算\n            if (chess-&gt;getChessData(row, col) == 0) {\n                // 遍历周围八个方向\n                for (int y = -1; y &lt;= 1; y++) {\n                    for (int x = -1; x &lt;= 1; x++)\n                    {\n                        // 重置\n                        personNum = 0;\n                        botNum = 0;\n                        emptyNum = 0;\n\n                        // 原坐标不算\n                        if (!(y == 0 &amp;&amp; x == 0))\n                        {\n                            // 每个方向延伸4个子\n                            // 对黑棋评分（正反两个方向）\n                            for (int i = 1; i &lt;= 4; i++)\n                            {\n                                int curRow = row + i * y;\n                                int curCol = col + i * x;\n                                if (curRow &gt;= 0 &amp;&amp; curRow &lt; size &amp;&amp;\n                                    curCol &gt;= 0 &amp;&amp; curCol &lt; size &amp;&amp;\n                                    chess-&gt;getChessData(curRow, curCol) == 1) // 真人玩家的子\n                                {\n                                    personNum++;\n                                }\n                                else if (curRow &gt;= 0 &amp;&amp; curRow &lt; size &amp;&amp;\n                                    curCol &gt;= 0 &amp;&amp; curCol &lt; size &amp;&amp;\n                                    chess-&gt;getChessData(curRow, curCol) == 0) // 空白位\n                                {\n                                    emptyNum++;\n                                    break;\n                                }\n                                else            // 出边界\n                                    break;\n                            }\n\n                            for (int i = 1; i &lt;= 4; i++)\n                            {\n                                int curRow = row - i * y;\n                                int curCol = col - i * x;\n                                if (curRow &gt;= 0 &amp;&amp; curRow &lt; size &amp;&amp;\n                                    curCol &gt;= 0 &amp;&amp; curCol &lt; size &amp;&amp;\n                                    chess-&gt;getChessData(curRow, curCol) == 1) // 真人玩家的子\n                                {\n                                    personNum++;\n                                }\n                                else if (curRow &gt;= 0 &amp;&amp; curRow &lt; size &amp;&amp;\n                                    curCol &gt;= 0 &amp;&amp; curCol &lt; size &amp;&amp;\n                                    chess-&gt;getChessData(curRow, curCol) == 0) // 空白位\n                                {\n                                    emptyNum++;\n                                    break;\n                                }\n                                else            // 出边界\n                                    break;\n                            }\n\n                            if (personNum == 1)                      // 杀二\n                                scoreMap[row][col] += 10;\n                            else if (personNum == 2)                 // 杀三\n                            {\n                                if (emptyNum == 1)\n                                    scoreMap[row][col] += 30;\n                                else if (emptyNum == 2)\n                                    scoreMap[row][col] += 40;\n                            }\n                            else if (personNum == 3)                 // 杀四\n                            {\n                                // 量变空位不一样，优先级不一样\n                                if (emptyNum == 1)\n                                    scoreMap[row][col] += 60;\n                                else if (emptyNum == 2)\n                                    scoreMap[row][col] += 200;\n                            }\n                            else if (personNum == 4)                 // 杀五\n                                scoreMap[row][col] += 20000;\n\n                            // 进行一次清空\n                            emptyNum = 0;\n\n                            // 对白棋评分\n                            for (int i = 1; i &lt;= 4; i++)\n                            {\n                                int curRow = row + i * y;\n                                int curCol = col + i * x;\n                                if (curRow &gt; 0 &amp;&amp; curRow &lt; size &amp;&amp;\n                                    curCol &gt; 0 &amp;&amp; curCol &lt; size &amp;&amp;\n                                    chess-&gt;getChessData(curRow, curCol) == -1) // 玩家的子\n                                {\n                                    botNum++;\n                                }\n                                else if (curRow &gt; 0 &amp;&amp; curRow &lt; size &amp;&amp;\n                                    curCol &gt; 0 &amp;&amp; curCol &lt; size &amp;&amp;\n                                    chess-&gt;getChessData(curRow, curCol) == 0) // 空白位\n                                {\n                                    emptyNum++;\n                                    break;\n                                }\n                                else            // 出边界\n                                    break;\n                            }\n\n                            for (int i = 1; i &lt;= 4; i++)\n                            {\n                                int curRow = row - i * y;\n                                int curCol = col - i * x;\n                                if (curRow &gt; 0 &amp;&amp; curRow &lt; size &amp;&amp;\n                                    curCol &gt; 0 &amp;&amp; curCol &lt; size &amp;&amp;\n                                    chess-&gt;getChessData(curRow, curCol) == -1) // 玩家的子\n                                {\n                                    botNum++;\n                                }\n                                else if (curRow &gt; 0 &amp;&amp; curRow &lt; size &amp;&amp;\n                                    curCol &gt; 0 &amp;&amp; curCol &lt; size &amp;&amp;\n                                    chess-&gt;getChessData(curRow, curCol) == 0) // 空白位\n                                {\n                                    emptyNum++;\n                                    break;\n                                }\n                                else            // 出边界\n                                    break;\n                            }\n\n                            if (botNum == 0)                      // 普通下子\n                                scoreMap[row][col] += 5;\n                            else if (botNum == 1)                 // 活二\n                                scoreMap[row][col] += 10;\n                            else if (botNum == 2)\n                            {\n                                if (emptyNum == 1)                // 死三\n                                    scoreMap[row][col] += 25;\n                                else if (emptyNum == 2)\n                                    scoreMap[row][col] += 50;  // 活三\n                            }\n                            else if (botNum == 3)\n                            {\n                                if (emptyNum == 1)                // 死四\n                                    scoreMap[row][col] += 55;\n                                else if (emptyNum == 2)\n                                    scoreMap[row][col] += 10000; // 活四\n                            }\n                            else if (botNum &gt;= 4)\n                                scoreMap[row][col] += 30000;   // 活五，应该具有最高优先级\n                        }\n                    }\n                }\n            }\n        }\n}</code></pre>\n<h3 id=\"13.3.2%C2%A0%C2%A0AI%E6%A0%B9%E6%8D%AE%E8%AF%84%E5%88%86%E8%BF%9B%E8%A1%8C%E2%80%9C%E6%80%9D%E8%80%83%E2%80%9D\">13.3.2  AI根据评分进行“思考”</h3>\n<p>各个落子点的评分确定后，“思考”就很简单了，直接使用“遍历”，找出评分最高的点即可。</p>\n<p>AI.h</p>\n<pre><code class=\"language-cpp\">ChessPos think();  //private权限</code></pre>\n<p></p>\n<p>AI.cpp </p>\n<pre><code class=\"language-cpp\">ChessPos AI::think()\n{\n    // 计算评分\n    calculateScore();\n\n    // 从评分中找出最大分数的位置\n    int maxScore = 0;\n    //std::vector&lt;std::pair&lt;int, int&gt;&gt; maxPoints;\n    vector&lt;ChessPos&gt; maxPoints;\n    int k = 0;\n\n    int size = chess-&gt;getGradeSize();\n    for (int row = 0; row &lt; size; row++) {\n        for (int col = 0; col &lt; size; col++)\n        {\n            // 前提是这个坐标是空的\n            if (chess-&gt;getChessData(row, col) == 0) {\n                if (scoreMap[row][col] &gt; maxScore)          // 找最大的数和坐标\n                {\n                    maxScore = scoreMap[row][col];\n                    maxPoints.clear();\n                    maxPoints.push_back(ChessPos(row, col));\n                }\n                else if (scoreMap[row][col] == maxScore) {   // 如果有多个最大的数，都存起来\n                    maxPoints.push_back(ChessPos(row, col));\n                }\n            }\n        }\n    }\n\n    // 随机落子，如果有多个点的话\n    int index = rand() % maxPoints.size();\n    return maxPoints[index];\n}</code></pre>\n<p>对ChesPos类补充构造函数<br/> Chess.h</p>\n<pre><code class=\"language-cpp\">ChessPos(int r=0, int c=0) :row(r), col(c){}</code></pre>\n<p></p>\n<h3 id=\"%C2%A012.3.3%20AI%E8%B5%B0%E6%A3%8B\"> 12.3.3 AI走棋</h3>\n<p>AI.cpp</p>\n<pre><code class=\"language-cpp\">void AI::go()\n{\n\tChessPos pos = think();\n\tSleep(1000); //假装思考\n    chess-&gt;chessDown(&amp;pos, CHESS_WHITE);\n}</code></pre>\n<p>因为思考速度太快，使用Sleep休眠作为停顿，以提高棋手的“对局体验” :-)</p>\n<h3 id=\"%C2%A012.3.4%20%E6%B5%8B%E8%AF%95\"> 12.3.4 测试</h3>\n<p>检查执行效果：<br/><img alt=\"\" height=\"603\" src=\"image\\685dd6cd19b344638ce04e6bad19a07c.png\" width=\"1168\"/></p>\n<p>当AI在“思考”时，程序崩溃！设置断点后检查，发现ai对象的chess成员指向一个无效内存。因为可以判定，还没有对AI对象进行初始化。检查后发现，之前为AI对象定义了初始化init函数，但是没有调用这个函数。补充如下：</p>\n<p>ChessGame.cpp</p>\n<pre><code class=\"language-cpp\">ChessGame::ChessGame(Man* man, AI* ai, Chess* chess)\n{\n\t//...\n\tai-&gt;init(chess);\n}</code></pre>\n<p>调试后还是发现，程序崩溃：<br/><img alt=\"\" height=\"665\" src=\"image\\057a15fae5b445f08371d4b5e706337d.png\" width=\"1164\"/></p>\n<p>加断点检查发现Chess类的getGradeSize函数返回0. 修改如下：<br/>  </p>\n<pre><code class=\"language-cpp\">int Chess::getGradeSize()\n{\n\treturn gradeSize;\n}</code></pre>\n<p> 测试运行后，发现AI很傻，落子很“臭”：</p>\n<p><img alt=\"\" height=\"934\" src=\"image\\c1be697310674222b23d84774ed83ec8.png\" width=\"913\"/></p>\n<p>加断点调试，发现getChessData函数的返回值始终为0，原来是之前设计这个接口时，使用自动生产的，没有做真正的实现，需改如下：</p>\n<pre><code class=\"language-cpp\">int Chess::getChessData(ChessPos* pos)\n{\n\treturn chessMap[pos-&gt;row][pos-&gt;col];\n}\n\nint Chess::getChessData(int row, int col)\n{\n\treturn chessMap[row][col];\n}</code></pre>\n<p>测试后发现，AI的棋力，已经正常：</p>\n<p><img alt=\"\" height=\"934\" src=\"image\\66d89f2bdc1541c1bdf62f9e55e50b05.png\" width=\"913\"/></p>\n<h1 id=\"14.%20AI%E7%9A%84BUG\">14. AI的BUG</h1>\n<p>现在的AI已经能够走棋了，而且还很不错，但是通过调试，发现AI在某些时候会下“昏招”， 成为“臭棋篓子”， 情况如下：<br/> 当下到这个局面时：<br/><img alt=\"\" height=\"934\" src=\"image\\c77d57fc0952498db3c565179d72ab99.png\" width=\"913\"/><br/> 当棋手在第9行第9列落子时，形成冲4形态时，白棋应该进行阻挡防守，但是白棋却判断错误，在其它位置落子了！<br/><img alt=\"\" height=\"934\" src=\"image\\bf5e19de58d14ee980c107a4d7007858.png\" width=\"913\"/></p>\n<p>通过加断点判断分析，原因是我们对8个方向做了判断，而在每个方向进行判断时，又对反方向进行了判断。最终导致AI在第行第5列的位置进行价值分析时，在正上方和正下方两次判断中，认为改点有“活三”价值，导致这点的价值被重复计算了一次，被累加到 20000，超过了黑棋冲四的价值！解决方法也很简单，就是8个方向，只要判断4次即可（如下图的绿色箭头<br/><img alt=\"\" height=\"595\" src=\"image\\48277a554fba40dc911aefbd60b2c26a.png\" width=\"1130\"/></p>\n<p> 修改后的AI评分方法。</p>\n<pre><code class=\"language-cpp\">void AI::calculateScore()\n{\n\tint personNum = 0; //棋手方（黑棋）多少个连续的棋子\n\tint aiNum = 0; //AI方（白棋）连续有多少个连续的棋子\n\tint emptyNum = 0; // 该方向上空白位的个数\n\n\t// 评分向量数组清零\n\tfor (int i = 0; i &lt; scoreMap.size(); i++) {\n\t\tfor (int j = 0; j &lt; scoreMap[i].size(); j++) {\n\t\t\tscoreMap[i][j] = 0;\n\t\t}\n\t}\n\n\tint size = chess-&gt;getGradeSize();\n\tfor (int row = 0; row &lt; size; row++) {\n\t\tfor (int col = 0; col &lt; size; col++) {\n\t\t\t//对每个点进行计算\n\t\t\tif (chess-&gt;getChessData(row, col)) continue;\n\n\t\t\tfor (int y = -1; y &lt;= 0; y++) {        //Y的范围还是-1， 0\n\t\t\t\tfor (int x = -1; x &lt;= 1; x++) {    //X的范围是 -1,0,1\n\t\t\t\t\tif (y == 0 &amp;&amp; x == 0) continue; \n\t\t\t\t\tif (y == 0 &amp;&amp; x != 1) continue; //当y=0时，仅允许x=1\n\n\t\t\t\t\tpersonNum = 0;\n\t\t\t\t\taiNum = 0;\n\t\t\t\t\temptyNum = 0;\n\n\t\t\t\t\t// 假设黑棋在该位置落子，会构成什么棋型\n\t\t\t\t\tfor (int i = 1; i &lt;= 4; i++) {\n\t\t\t\t\t\tint curRow = row + i * y;\n\t\t\t\t\t\tint curCol = col + i * x;\n\n\t\t\t\t\t\tif (curRow &gt;= 0 &amp;&amp; curRow &lt; size &amp;&amp;\n\t\t\t\t\t\t\tcurCol &gt;= 0 &amp;&amp; curCol &lt; size &amp;&amp;\n\t\t\t\t\t\t\tchess-&gt;getChessData(curRow, curCol) == 1) {\n\t\t\t\t\t\t\tpersonNum++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (curRow &gt;= 0 &amp;&amp; curRow &lt; size &amp;&amp;\n\t\t\t\t\t\t\tcurCol &gt;= 0 &amp;&amp; curCol &lt; size &amp;&amp;\n\t\t\t\t\t\t\tchess-&gt;getChessData(curRow, curCol) == 0) {\n\t\t\t\t\t\t\temptyNum++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// 反向继续计算\n\t\t\t\t\tfor (int i = 1; i &lt;= 4; i++) {\n\t\t\t\t\t\tint curRow = row - i * y;\n\t\t\t\t\t\tint curCol = col - i * x;\n\n\t\t\t\t\t\tif (curRow &gt;= 0 &amp;&amp; curRow &lt; size &amp;&amp;\n\t\t\t\t\t\t\tcurCol &gt;= 0 &amp;&amp; curCol &lt; size &amp;&amp;\n\t\t\t\t\t\t\tchess-&gt;getChessData(curRow, curCol) == 1) {\n\t\t\t\t\t\t\tpersonNum++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (curRow &gt;= 0 &amp;&amp; curRow &lt; size &amp;&amp;\n\t\t\t\t\t\t\tcurCol &gt;= 0 &amp;&amp; curCol &lt; size &amp;&amp;\n\t\t\t\t\t\t\tchess-&gt;getChessData(curRow, curCol) == 0) {\n\t\t\t\t\t\t\temptyNum++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (personNum == 1) { //连2\n\t\t\t\t\t\t//CSDN  程序员Rock\n\t\t\t\t\t\tscoreMap[row][col] += 10;\n\t\t\t\t\t}\n\t\t\t\t\telse if (personNum == 2) {\n\t\t\t\t\t\tif (emptyNum == 1) {\n\t\t\t\t\t\t\tscoreMap[row][col] += 30;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (emptyNum == 2) {\n\t\t\t\t\t\t\tscoreMap[row][col] += 40;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (personNum == 3) {\n\t\t\t\t\t\tif (emptyNum == 1) {\n\t\t\t\t\t\t\tscoreMap[row][col] = 60;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (emptyNum == 2) {\n\t\t\t\t\t\t\tscoreMap[row][col] = 5000; //200\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (personNum == 4) {\n\t\t\t\t\t\tscoreMap[row][col] = 20000;\n\t\t\t\t\t}\n\n\t\t\t\t\t// 假设白棋在该位置落子，会构成什么棋型\n\t\t\t\t\temptyNum = 0;\n\n\t\t\t\t\tfor (int i = 1; i &lt;= 4; i++) {\n\t\t\t\t\t\tint curRow = row + i * y;\n\t\t\t\t\t\tint curCol = col + i * x;\n\n\t\t\t\t\t\tif (curRow &gt;= 0 &amp;&amp; curRow &lt; size &amp;&amp;\n\t\t\t\t\t\t\tcurCol &gt;= 0 &amp;&amp; curCol &lt; size &amp;&amp;\n\t\t\t\t\t\t\tchess-&gt;getChessData(curRow, curCol) == -1) {\n\t\t\t\t\t\t\taiNum++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (curRow &gt;= 0 &amp;&amp; curRow &lt; size &amp;&amp;\n\t\t\t\t\t\t\tcurCol &gt;= 0 &amp;&amp; curCol &lt; size &amp;&amp;\n\t\t\t\t\t\t\tchess-&gt;getChessData(curRow, curCol) == 0) {\n\t\t\t\t\t\t\temptyNum++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (int i = 1; i &lt;= 4; i++) {\n\t\t\t\t\t\tint curRow = row - i * y;\n\t\t\t\t\t\tint curCol = col - i * x;\n\n\t\t\t\t\t\tif (curRow &gt;= 0 &amp;&amp; curRow &lt; size &amp;&amp;\n\t\t\t\t\t\t\tcurCol &gt;= 0 &amp;&amp; curCol &lt; size &amp;&amp;\n\t\t\t\t\t\t\tchess-&gt;getChessData(curRow, curCol) == -1) {\n\t\t\t\t\t\t\taiNum++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (curRow &gt;= 0 &amp;&amp; curRow &lt; size &amp;&amp;\n\t\t\t\t\t\t\tcurCol &gt;= 0 &amp;&amp; curCol &lt; size &amp;&amp;\n\t\t\t\t\t\t\tchess-&gt;getChessData(curRow, curCol) == 0) {\n\t\t\t\t\t\t\temptyNum++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (aiNum == 0) {\n\t\t\t\t\t\tscoreMap[row][col] += 5;\n\t\t\t\t\t}\n\t\t\t\t\telse if (aiNum == 1) {\n\t\t\t\t\t\tscoreMap[row][col] += 10;\n\t\t\t\t\t}\n\t\t\t\t\telse if (aiNum == 2) {\n\t\t\t\t\t\tif (emptyNum == 1) {\n\t\t\t\t\t\t\tscoreMap[row][col] += 25;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (emptyNum == 2) {\n\t\t\t\t\t\t\tscoreMap[row][col] += 50;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (aiNum == 3) {\n\t\t\t\t\t\tif (emptyNum == 1) {\n\t\t\t\t\t\t\tscoreMap[row][col] += 55;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (emptyNum == 2) {\n\t\t\t\t\t\t\tscoreMap[row][col] += 10000;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (aiNum &gt;= 4) {\n\t\t\t\t\t\tscoreMap[row][col] += 30000;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}</code></pre>\n<h1 id=\"15.%20%E5%88%A4%E6%96%AD%E8%83%9C%E8%B4%9F\">15. 判断胜负</h1>\n<p>判断五子棋游戏是否结束。</p>\n<h2 id=\"15.1%20%E5%AF%B9%E8%83%9C%E8%B4%9F%E8%BF%9B%E8%A1%8C%E5%A4%84%E7%90%86\">15.1 对胜负进行处理</h2>\n<p>Chess.cpp</p>\n<pre><code class=\"language-cpp\">bool Chess::checkOver()\n{\n\tif (checkWin()) {\n\t\tSleep(1500);\n\t\tif (playerFlag == false) {  //黑棋赢（玩家赢）,此时标记已经反转，轮到白棋落子\n\t\t\tmciSendString(\"play res/不错.mp3\", 0, 0, 0);\n\t\t\tloadimage(0, \"res/胜利.jpg\");\n\t\t}\n\t\telse {\n\t\t\tmciSendString(\"play res/失败.mp3\", 0, 0, 0);\n\t\t\tloadimage(0, \"res/失败.jpg\");\n\t\t}\n\n\t\t_getch(); // 补充头文件 #include &lt;conio.h&gt;\n\t\treturn true;\n\t}\n\n\treturn false;\n}</code></pre>\n<p>补充头文件 conio.h, 并添加CheckWin的定义和实现。</p>\n<h2 id=\"15.2%20%E8%83%9C%E8%B4%9F%E5%88%A4%E5%AE%9A%E5%8E%9F%E7%90%86\">15.2 胜负判定原理</h2>\n<p>具体的判定原理，就是对刚才的落子位置进行判断，判断该位置在4个方向上是否有5颗连续的同类棋子。</p>\n<p>对于水平位置的判断：<br/><img alt=\"\" height=\"319\" src=\"image\\2208b9fcec484768aedde388a47c2807.png\" width=\"575\"/></p>\n<p>其他方向的判断，原理类似。</p>\n<h2 id=\"15.%203%20%E5%AE%9E%E7%8E%B0%E8%83%9C%E8%B4%9F%E5%88%A4%E5%AE%9A\">15. 3 实现胜负判定</h2>\n<p>添加最近落子位置。</p>\n<p>Chess.h</p>\n<pre><code class=\"language-cpp\">ChessPos lastPos; //最近落子位置, Chess的private数据成员</code></pre>\n<p> 更新最近落子位置。</p>\n<p>Chess.cpp</p>\n<pre><code class=\"language-cpp\">void Chess::updateGameMap(ChessPos* pos)\n{\n\tlastPos = *pos;\n\t//...\n}\n</code></pre>\n<p>实现胜负判定。</p>\n<p>Chess.cpp</p>\n<pre><code class=\"language-cpp\">bool Chess::checkWin()\n{\n\t// 横竖斜四种大情况，每种情况都根据当前落子往后遍历5个棋子，有一种符合就算赢\n\t// 水平方向\n\tint row = lastPos.row;\n\tint col = lastPos.col;\n\n\tfor (int i = 0; i &lt; 5; i++)\n\t{\n\t\t// 往左5个，往右匹配4个子，20种情况\n\t\tif (col - i &gt;= 0 &amp;&amp;\n\t\t\tcol - i + 4 &lt; gradeSize &amp;&amp;\n\t\t\tchessMap[row][col - i] == chessMap[row][col - i + 1] &amp;&amp;\n\t\t\tchessMap[row][col - i] == chessMap[row][col - i + 2] &amp;&amp;\n\t\t\tchessMap[row][col - i] == chessMap[row][col - i + 3] &amp;&amp;\n\t\t\tchessMap[row][col - i] == chessMap[row][col - i + 4])\n\t\t\treturn true;\n\t}\n\n\t// 竖直方向(上下延伸4个)\n\tfor (int i = 0; i &lt; 5; i++)\n\t{\n\t\tif (row - i &gt;= 0 &amp;&amp;\n\t\t\trow - i + 4 &lt; gradeSize &amp;&amp;\n\t\t\tchessMap[row - i][col] == chessMap[row - i + 1][col] &amp;&amp;\n\t\t\tchessMap[row - i][col] == chessMap[row - i + 2][col] &amp;&amp;\n\t\t\tchessMap[row - i][col] == chessMap[row - i + 3][col] &amp;&amp;\n\t\t\tchessMap[row - i][col] == chessMap[row - i + 4][col])\n\t\t\treturn true;\n\t}\n\n\t// “/\"方向\n\tfor (int i = 0; i &lt; 5; i++)\n\t{\n\t\tif (row + i &lt; gradeSize &amp;&amp;\n\t\t\trow + i - 4 &gt;= 0 &amp;&amp;\n\t\t\tcol - i &gt;= 0 &amp;&amp;\n\t\t\tcol - i + 4 &lt; gradeSize &amp;&amp;\n\t\t\t// 第[row+i]行，第[col-i]的棋子，与右上方连续4个棋子都相同\n\t\t\tchessMap[row + i][col - i] == chessMap[row + i - 1][col - i + 1] &amp;&amp;\n\t\t\tchessMap[row + i][col - i] == chessMap[row + i - 2][col - i + 2] &amp;&amp;\n\t\t\tchessMap[row + i][col - i] == chessMap[row + i - 3][col - i + 3] &amp;&amp;\n\t\t\tchessMap[row + i][col - i] == chessMap[row + i - 4][col - i + 4])\n\t\t\treturn true;\n\t}\n\n\t// “\\“ 方向\n\tfor (int i = 0; i &lt; 5; i++)\n\t{\n\t\t// 第[row+i]行，第[col-i]的棋子，与右下方连续4个棋子都相同\n\t\tif (row - i &gt;= 0 &amp;&amp;\n\t\t\trow - i + 4 &lt; gradeSize &amp;&amp;\n\t\t\tcol - i &gt;= 0 &amp;&amp;\n\t\t\tcol - i + 4 &lt; gradeSize &amp;&amp;\n\t\t\tchessMap[row - i][col - i] == chessMap[row - i + 1][col - i + 1] &amp;&amp;\n\t\t\tchessMap[row - i][col - i] == chessMap[row - i + 2][col - i + 2] &amp;&amp;\n\t\t\tchessMap[row - i][col - i] == chessMap[row - i + 3][col - i + 3] &amp;&amp;\n\t\t\tchessMap[row - i][col - i] == chessMap[row - i + 4][col - i + 4])\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}</code></pre>\n<h2 id=\"15.%204%20%E6%B5%8B%E8%AF%95%E6%95%88%E6%9E%9C\">15. 4 测试效果</h2>\n<p>已经能够完美判定胜负了，并能自动开启下一局。</p>\n<p><img alt=\"\" height=\"934\" src=\"image\\57539618b78240a7ad46499aea6e146f.png\" width=\"913\"/></p>\n<p>再把落子音效加上，用户体验就更好了。</p>\n<p>Chess.cpp</p>\n<pre><code class=\"language-cpp\">void Chess::chessDown(ChessPos* pos, chess_kind_t kind)\n{\n\tmciSendString(\"play res/down7.WAV\", 0, 0, 0);\n    //......\n}</code></pre>\n<h1 id=\"16.%20AI%E8%BF%9B%E4%B8%80%E6%AD%A5%E4%BC%98%E5%8C%96\">16. AI进一步优化</h1>\n<p>现在AI的实力，对于一般的五子棋业余爱好者，已经能够秒杀，但是对于业余中的“大佬”，还是力不从心，甚至会屡战屡败，主要原因有两点：</p>\n<blockquote>\n<p>1. 没有对跳三和跳四进行判断。实际上，跳三和跳四的价值与连三连四的价值，是完全相同的。而现在的AI只计算了连三和连四，没有考虑跳三跳四，所以就会错失“好棋”！</p>\n</blockquote>\n<p><img alt=\"\" height=\"272\" src=\"image\\8ed1fefeb28b4083aaec0a921c1e380a.png\" width=\"478\"/></p>\n<p>对于上图，在位置1和位置2，都会形成“跳三”。</p>\n<p><img alt=\"\" height=\"305\" src=\"image\\4b8c583a2cf0485082be436d2a47d2e0.png\" width=\"472\"/></p>\n<p>对于上图在位置3和位置4，都会形成连三.</p>\n<p></p>\n<p><img alt=\"\" height=\"282\" src=\"image\\31980b1ba3a44152b8f8f533793086e4.png\" width=\"470\"/> </p>\n<p>对于上图，在位置1对黑棋形成“跳四”，跳四的价值和“连四”或“冲四”的价值也是相同的！</p>\n<blockquote>\n<p>2. 没有对黑棋设置“禁手”。因为五子棋已经发展到“黑棋先行必胜”的套路，所以职业五子棋比赛，会对黑棋设置以下“禁手”。</p>\n<ul><li>三三禁手</li><li>四四禁手</li><li>长连禁手</li></ul>\n</blockquote>\n<p>三三禁手（如果在该位置主动落子或者被动落子，直接判黑方战败！）</p>\n<p><img alt=\"\" height=\"264\" src=\"image\\153b106cf63c4efbbe3ee05b17058123.png\" width=\"431\"/></p>\n<p> 四四禁手（如果在该位置主动落子或者被动落子，直接判黑方战败！）</p>\n<p><img alt=\"\" height=\"347\" src=\"image\\bdd0213b94c0486da7f3e2def87d0412.png\" width=\"537\"/></p>\n<p>长连禁手（如果在该位置主动落子或者被动落子，直接判黑方战败！）<br/><img alt=\"\" height=\"212\" src=\"image\\385da2f15c594921962700ebb38d9cdd.png\" width=\"487\"/></p>\n<h2 id=\"AI%E6%8F%90%E5%8D%87\">AI提升</h2>\n<ul><li>在计算落子点价值的时候，增加对跳三和跳四的价值判断</li><li>在判断胜负时，增加对黑方禁手的判断。</li></ul>\n<p>通过以上的优化后，业余高手也很难取胜了！但是对专业棋手，还是难以招架！原因在于，目前的AI只根据当前盘面进行判断，静态的最佳座子点。没有对后续步骤进行连续判断。可以使用“搜索树”，进行连续判定，搜索的深度越深，AI的棋力就越深。最终五子棋，就和象棋一样，彻底碾压人类棋手。</p>\n<h1 id=\"17.%20%E5%BC%80%E5%8F%91%E6%8B%93%E5%B1%95\">17. 开发拓展</h1>\n<p>计分以及棋力等级|<br/> 悔棋功能 <br/> 棋力训练（充值送形势判断）<br/> 记棋谱功能<br/> 网络对战功能<br/> 邀请微信好友、QQ好友对战功能<br/> 移植到移动端（Android和IOS）</p>\n<p>---END.</p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n</div>\n</div>"}