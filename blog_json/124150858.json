{"blogid": "124150858", "writerAge": "码龄5年", "writerBlogNum": "1", "writerCollect": "1", "writerComment": "1", "writerFan": "0", "writerGrade": "1级", "writerIntegral": "11", "writerName": "weixin_40343444", "writerProfileAdress": "writer_image\\profile_124150858.jpg", "writerRankTotal": "247746", "writerRankWeekly": "1389192", "writerThumb": "0", "writerVisitNum": "830", "blog_read_count": "793", "blog_time": "已于 2022-04-14 13:22:22 修改", "blog_title": ".NET C# form-data形式传参调用第三方api", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>近期做毕设用到一个第三方的api，尝试前端ajax调用发现跨域报错，只能在后端代码发起请求，由于对api传参方式不够了解，走了很多弯路，特此记录。</p>\n<p>要调用的接口：<a href=\"http://www.atoolbox.net/Api/GetRefuseClassification.php\" title=\"http://www.atoolbox.net/Api/GetRefuseClassification.php\">http://www.atoolbox.net/Api/GetRefuseClassification.php</a></p>\n<p>通过postman调用一切正常</p>\n<p><img alt=\"\" height=\"702\" src=\"image\\6ad1285bc5434a2bb604e8a1b5d8e294.png\" width=\"1035\"/></p>\n<p> 随后开始自信满满用HttpClient发起调用，结果发现返回空数组，但是接口没有报错，说明参数没有传过去，所以接口默认返回了空数组，此时代码如下:</p>\n<pre><code class=\"language-cs\">HttpClient _httpClient = new HttpClient();\nstring json = \"{\\\"ref\\\":\\\"苹果\\\"}\";\nvar data = new StringContent(json, Encoding.UTF8, \"application/json\");\nvar requestUri = \"http://www.atoolbox.net/Api/GetRefuseClassification.php\";\nvar response = await _httpClient.PostAsync(requestUri, data);\nvar result = await response.Content.ReadAsStringAsync();\n</code></pre>\n<p>然后就开始了百度Google各种查HttpClient通过body传参的写法，大家给出的差不多都是这种写法，后来无意中想到会不会是接口只能识别form-data这一种形式，按照这个思路继续找解决方案，最终找到了一种正确的传参写法，如下：</p>\n<pre><code class=\"language-cs\">HttpClient _httpClient = new HttpClient();\nvar postContent = new MultipartFormDataContent();\nstring boundary = string.Format(\"--{0}\", DateTime.Now.Ticks.ToString(\"x\"));\npostContent.Headers.Add(\"ContentType\", $\"multipart/form-data,boundary={boundary}\");\nvar requestUri = \"http://www.atoolbox.net/Api/GetRefuseClassification.php\";\n\n\nvar values = new[]\n{\n    new KeyValuePair&lt;string, string&gt;(\"ref\",\"苹果\")\n};\n\nforeach (var keyValuePair in values)\n{\n    postContent.Add(new StringContent(keyValuePair.Value),\n    String.Format(\"\\\"{0}\\\"\", keyValuePair.Key));\n}\n\nvar response = await _httpClient.PostAsync(requestUri, postContent);\nvar result = await response.Content.ReadAsStringAsync();</code></pre>\n<p>难道真的是只能支持form-data形式传参吗？于是又逮住postman一通折腾，果然有了新的发现。</p>\n<p>（body请求格式可参考这篇文章）</p>\n<p><a href=\"https://blog.csdn.net/weixin_43849277/article/details/120900735\" title=\"Postman中几个body请求格式区别及使用说明_有时候我也会的博客-CSDN博客_postman请求体格式\">Postman中几个body请求格式区别及使用说明_有时候我也会的博客-CSDN博客_postman请求体格式</a></p>\n<p><img alt=\"\" height=\"720\" src=\"image\\c52722409425433aac1822592c776d87.png\" width=\"969\"/></p>\n<p>如上图，通过x-www-form-urlencoded这种方式也可以调通接口，也就是HttpClient肯定有通过x-www-form-urlencoded这种传参方式的写法，多方查证后，写出一种正确代码如下：</p>\n<pre><code class=\"language-cs\">HttpClient _httpClient = new HttpClient();\nstring boundary = string.Format(\"--{0}\", DateTime.Now.Ticks.ToString(\"x\"));\nvar postContent = new MultipartContent();\npostContent.Headers.Add(\"ContentType\", $\"multipart/x-www-form-urlencoded,boundary={boundary}\");\nvar requestUri = \"http://www.atoolbox.net/Api/GetRefuseClassification.php\";\nvar dict = new Dictionary&lt;string, string&gt;();\ndict.Add(\"ref\",\"苹果\");\n\nvar req = new HttpRequestMessage(HttpMethod.Post, requestUri) { Content = new FormUrlEncodedContent(dict) };\nvar res = await _httpClient.SendAsync(req);\nvar result = await res.Content.ReadAsStringAsync();</code></pre>\n<p>通过比较可以发现，用x-www-form-urlencoded的写法使用了HttpRequestMessage包装参数，用form-data的写法使用了MultipartContent包装参数，为什么要这样写，我们有时间继续探索。</p>\n<p></p>\n<p>---------------------------------------------------------------------------------------------------------------------------</p>\n<p>在Google上找到了一篇文章，详细介绍了以下三个class的区别</p>\n<ol><li>WebRequest</li><li>WebClient</li><li>HttpClient </li></ol>\n<p>概括一下就是：</p>\n<p>WebRequest出现最早，最原始（实现类是HttpWebRequest），可以访问api、服务器资源，语法最复杂。</p>\n<p>WebClient出现较晚，是对WebRequest的封装，语法较简洁。</p>\n<p>HtttpClient出现最晚，实现了一些WebRequest和WebClient没有的功能。</p>\n<p>链接如下：</p>\n<p><a href=\"https://www.c-sharpcorner.com/blogs/difference-between-syatemnetwebrequest-and-httpclient-and-webclient-in-c-sharp\" title=\"https://www.c-sharpcorner.com/blogs/difference-between-syatemnetwebrequest-and-httpclient-and-webclient-in-c-sharp\">https://www.c-sharpcorner.com/blogs/difference-between-syatemnetwebrequest-and-httpclient-and-webclient-in-c-sharp</a></p>\n<p>另有一篇中文博客，讲的也很详细，如下：</p>\n<p><a href=\"https://www.jb51.net/article/177025.htm\" title=\"https://www.jb51.net/article/177025.htm\">https://www.jb51.net/article/177025.htm</a></p>\n</div>\n</div>"}