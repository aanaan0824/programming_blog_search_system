{"blogid": "124769364", "writerAge": "码龄2年", "writerBlogNum": "18", "writerCollect": "23", "writerComment": "0", "writerFan": "4", "writerGrade": "2级", "writerIntegral": "189", "writerName": "怎知枪戟再逢只见抵死拼杀", "writerProfileAdress": "writer_image\\profile_124769364.jpg", "writerRankTotal": "66637", "writerRankWeekly": "35921", "writerThumb": "5", "writerVisitNum": "6705", "blog_read_count": "1607", "blog_time": "已于 2022-05-16 10:23:43 修改", "blog_title": "文件包含支持的伪协议", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p></p>\n<div class=\"toc\">\n<h3>文件包含支持的伪协议</h3>\n<ul><li><a href=\"#_2\">一、什么是伪协议？</a></li><li><a href=\"#_20\">二、文件包含支持的伪协议用法</a></li><li><ul><li><a href=\"#font_colorred_size51phpfont_22\"><font color=\"red\" size=\"5\">1、php://</font></a></li><li><ul><li><a href=\"#font_colorgree_size511_phpinputfont_24\"><font color=\"gree\" size=\"5\">1.1 php://input</font></a></li><li><a href=\"#font_colorgree_size512_phpoutputfont_88\"><font color=\"gree\" size=\"5\">1.2 php://output</font></a></li><li><a href=\"#font_colorgree_size513_phpfilterfont_102\"><font color=\"gree\" size=\"5\">1.3 php://filter</font></a></li><li><a href=\"#font_colorgree_size514_phpfont_124\"><font color=\"gree\" size=\"5\">1.4 其它php://伪协议</font></a></li></ul>\n</li><li><a href=\"#font_colorred_size52filefont_127\"><font color=\"red\" size=\"5\">2、file://</font></a></li><li><a href=\"#font_colorred_size53datafont_136\"><font color=\"red\" size=\"5\">3、data://</font></a></li><li><a href=\"#font_colorred_size54pharfont_151\"><font color=\"red\" size=\"5\">4、phar://</font></a></li><li><a href=\"#font_colorred_size55zipfont_166\"><font color=\"red\" size=\"5\">5、zip://</font></a></li></ul>\n</li><li><a href=\"#_186\">三、总结</a></li></ul>\n</div>\n<p></p>\n<hr/>\n<h1><a id=\"_2\"></a>一、什么是伪协议？</h1>\n<p><a href=\"https://www.php.net/manual/zh/wrappers.php\">PHP官方文档</a></p>\n<ul><li>伪协议： 带有URL 风格的封装协议。</li><li>PHP 带有很多内置 URL 风格的封装协议，可用于类似 fopen()、 copy()、 file_exists() 和 filesize() 的文件系统函数。 除了这些封装协议，还能通过 stream_wrapper_register() 来注册自定义的封装协议。</li><li>封装：是php面向对象的其中一个特性，将多个可重复使用的函数封装到一个类里面，在使用时直接实例化该类的某一个方法，获得需要的数据。</li></ul>\n<blockquote>\n<p>file:// — 访问本地文件系统<br/> http:// — 访问 HTTP(s) 网址<br/> ftp:// — 访问 FTP(s) URLs<br/> php:// — 访问各个输入/输出流（I/O streams）<br/> zlib:// — 压缩流<br/> data:// — 数据（RFC 2397）<br/> glob:// — 查找匹配的文件路径模式<br/> phar:// — PHP 归档<br/> ssh2:// — 安全外壳协议 2<br/> rar:// — RAR<br/> ogg:// — 音频流<br/> expect:// — 处理交互式的流</p>\n</blockquote>\n<h1><a id=\"_20\"></a>二、文件包含支持的伪协议用法</h1>\n<p>描述之前，我们先把php.ini的allow_url_fopen 和allow_url_include设置为On。以便对这些伪协议进行分析。</p>\n<h2><a id=\"font_colorred_size51phpfont_22\"></a><font color=\"red\" size=\"5\">1、php://</font></h2>\n<p><em>php:// — 访问各个输入/输出流（I/O streams）</em></p>\n<h3><a id=\"font_colorgree_size511_phpinputfont_24\"></a><font color=\"gree\" size=\"5\">1.1 php://input</font></h3>\n<p><strong>php://input：访问请求的原始数据的只读流。</strong><br/> <mark>注：当enctype=”multipart/form-data”时，php://input是无效的。</mark></p>\n<pre><code>示例：\n</code></pre>\n<p>include会把参数’info’当作文件执行<br/> <img alt=\"在这里插入图片描述\" src=\"image\\2bd125c2b7e64a838f14af67dac7c62e.png\"/><br/> 正常情况下，除非输入的参数刚好是这个目录下的某个文件，<br/> 比如我有个名为alert.php的文件<br/> <img alt=\"在这里插入图片描述\" src=\"image\\2a9ce7652d1d4ce890042eb60015d598.png\"/><br/> 否则就会报错<br/> <img alt=\"在这里插入图片描述\" src=\"image\\f0d4bef889504757834b83e46be2ca33.png\"/><br/> 现在我们利用php://input协议<br/> <img alt=\"在这里插入图片描述\" src=\"image\\aaf9ef0ad48e40838ddb0c0d4a337bbb.png\"/><br/> 截取数据包<br/> <img alt=\"在这里插入图片描述\" src=\"image\\a106e80659294db893ea2ffd57a8305c.png\"/><br/> 在最后面，我们加入要执行的代码<code>&lt;?php echo phpinfo(); ?&gt;</code><br/> <mark>这里输入的实际上就是请求的数据，然后它被当作代码执行了。</mark><br/> <img alt=\"在这里插入图片描述\" src=\"image\\e470b1c24d2442829847e62a32a2cd96.png\"/><br/> 放包<br/> <img alt=\"在这里插入图片描述\" src=\"image\\eea64d5cc13742568f06b30ef193f180.png\"/><br/> <font color=\"purple\" size=\"4\"><b>扩展</b></font></p>\n<p>这里有道关于php://input的ctf题，我们提取部分代码进行分析。<br/> <a href=\"https://blog.csdn.net/niexinming/article/details/52623790\">链接</a><br/> 简单的代码示例：<br/> <mark>file_get_contens($data):将文件内容以字符串形式输出</mark><br/> <img alt=\"在这里插入图片描述\" src=\"image\\dca48c8dc811470dbe658a62cfb5ff25.png\"/></p>\n<p>这里的data被当作文件读取，而实际上，后台并不能找到名为\"a\"的这个文件，所以会报错。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\d41a541355634ff1a03fb133ed6b643f.png\"/><br/> 利用php://input绕过</p>\n<pre><code>现在我们输入的值为空，返回false\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\a7bf4abae52d4f288fd5f8f17ab668fa.png\"/></p>\n<p>用burpsite进行抓包，在最后面输入我们要传进去的值“xxx”（因为根据源代码，只有data为xxx时，才会返回true）<br/> <img alt=\"在这里插入图片描述\" src=\"image\\2583d85f774344e8bc865b0329a1d880.png\"/><br/> 放包<br/> <img alt=\"在这里插入图片描述\" src=\"image\\17b726fbad8945f0bc6995bd2d00fc15.png\"/><br/> 这个时候，后台得到的数据应该是这样子的<br/> <img alt=\"在这里插入图片描述\" src=\"image\\4eeb4249db9a4c55bc101eeb88a1bcdd.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"image\\0fda614c67e64d30a7cc9809c46034b1.png\"/><br/> 若是修改参数<br/> <img alt=\"在这里插入图片描述\" src=\"image\\a3c3357eebcd4fe0a139212dc44c0c20.png\"/><br/> 则会发生和最初一样的报错，文件不存在<br/> <img alt=\"在这里插入图片描述\" src=\"image\\33165ad354e9498eac148caeef5e90f0.png\"/><br/> 也就是说，<code>file_get_contents(\"php://input\")</code>能够获取请求原始数据流。<br/> 按照函数的检测逻辑，\"php://input\"被当作了空的文件来读取，输出的自然也是空字符串。然后，当我们在burpsite上抓包，POST中输入data的时候，后台看见的代码应该是<code>$a =\"\".$data </code><br/> 但是具体是否如此我也不太清楚，网上并没有找到准确的答案。<br/> 像这样的：<br/> <img alt=\"在这里插入图片描述\" src=\"image\\cc2dbf79eb8b48d8988dda7f2420b502.png\"/></p>\n<p><code>这样子也可以</code><br/> <img alt=\"在这里插入图片描述\" src=\"image\\64320a857da74a3f97b4bfcd50c52fe8.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"image\\62c7a0009a0b4ad7a782dc22650ec670.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"image\\5e16e407c92443449f6bd077bed85931.png\"/></p>\n<blockquote>\n<p>经过测试，我发现还有其他一些php伪协议也可以被file_get_contents执行，例如：<br/> php://stdout,php://stdin,php://stderr<br/> php://output,php://memory,php://temp</p>\n</blockquote>\n<h3><a id=\"font_colorgree_size512_phpoutputfont_88\"></a><font color=\"gree\" size=\"5\">1.2 php://output</font></h3>\n<ul><li>php://output 只写的数据流</li><li>php://output允许你以 print 和 echo 一样的方式写入到输出缓冲区。</li></ul>\n<blockquote>\n<p>示例：<br/> <img alt=\"在这里插入图片描述\" src=\"image\\959ca0e24a094c539b24166b2f0b879c.png\"/><br/> 内容并没有被写入。因为php://input是只读流。<br/> <img alt=\"在这里插入图片描述\" src=\"image\\2dbaa80a563a40a5b3fc3f94fd15768f.png\"/><br/> 换成php://output,只写的数据流<br/> <img alt=\"在这里插入图片描述\" src=\"image\\7dcb12b7b7af4e4dbb763ed3ae9b24fd.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"image\\2fd425b8935545138af1e2451bfd0adc.png\"/></p>\n</blockquote>\n<blockquote>\n<p>所谓缓冲区就是，临时存放数据的地方。当我们重新访问时，它就会刷新；<br/> 当我们修改文件中的内容时，它也会刷新自己的内容。像这里的 $f 实际上并没有被创建到相对路径下，而是被放置在缓冲区。</p>\n</blockquote>\n<h3><a id=\"font_colorgree_size513_phpfilterfont_102\"></a><font color=\"gree\" size=\"5\">1.3 php://filter</font></h3>\n<ul><li> <p>php://filter是一种元封装器，是PHP中特有的协议流，设计用于数据流打开时的筛选过滤应用，作用是作为一个“中间流”来处理其他流。</p> </li><li> <p>php://filter目标使用以下的参数作为它路径的一部分。复合过滤链能够在一个路径上指定。</p> </li></ul>\n<table><thead><tr><th>名称</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td>resource=&lt;要过滤的数据流&gt;</td><td>指定了你要筛选过滤的数据流。</td><td>必选</td></tr><tr><td>read=&lt;读链的筛选列表&gt;</td><td>可以设定一个或多个过滤器名称，以管道符分隔</td><td>可选</td></tr><tr><td>write=&lt;写链的筛选列表&gt;</td><td>可以设定一个或多个过滤器名称，以管道符分隔。</td><td>可选</td></tr><tr><td>&lt;；两个链的筛选列表&gt;</td><td>任何没有以 read= 或 write= 作前缀 的筛选器列表会视情况应用于读或写链。</td><td></td></tr></tbody></table>\n<pre><code class=\"prism language-html\">page=php://filter/read=convert.base64-encode/resource=../../../../../../phpstudy_pro\\WWW\\feng\\php_output.php\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\155a093d44aa492d87b4380e9a4484c5.png\"/><br/> 得到：<br/> <code>PD9waHANCgkNCgkkZj1mb3BlbigicGhwOi8vb3V0cHV0IiwiYSIpOw0KCWZ3cml0ZSgkZiwidGhpcyBpcyBhIHNlbnRlbmNlIik7DQoJZmNsb3NlKCRmKTsNCj8+</code><br/> 进行base64解码<br/> <img alt=\"在这里插入图片描述\" src=\"image\\4809a56e56b3407fa81d5922db521ef4.png\"/><br/> 但是如果是有中文的文件，就不好读取了。base64对中文支持并不友好，需要对中文进行编码之后再转base64。这里我就不尝试了。读取的文件都是非中文的。</p>\n<blockquote>\n<p>php://filter可用于读取包含有敏感信息的PHP等源⽂件，使用base64加密是了防止被浏览器当作XML语言解析，导致出错。</p>\n</blockquote>\n<h3><a id=\"font_colorgree_size514_phpfont_124\"></a><font color=\"gree\" size=\"5\">1.4 其它php://伪协议</font></h3>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\40677c2ba73e4b00912826461d7eadc3.png\"/></p>\n<h2><a id=\"font_colorred_size52filefont_127\"></a><font color=\"red\" size=\"5\">2、file://</font></h2>\n<ul><li>常用于读取本地文件</li></ul>\n<blockquote>\n<p>示例：<br/> <img alt=\"在这里插入图片描述\" src=\"image\\d7b6ce7f554e4956abc848066916904b.png\"/></p>\n</blockquote>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\e33df9c1ab254dea8e22933683cc343e.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"image\\d8ec0751e0cb48d082b5f88bb7494f13.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"image\\586723b6af4548cfb267f7ba6049bd61.png\"/></p>\n<h2><a id=\"font_colorred_size53datafont_136\"></a><font color=\"red\" size=\"5\">3、data://</font></h2>\n<ul><li>data://伪协议，是数据流封装器，和php://相似，都是利用了流的概念，将原本的include的文件流重定向到了用户可控制的输入流中，简单来说就是执行文件的包含方法包含了你的输入流，通过包含你输入的payload来实现目的。</li></ul>\n<p>格式：<code>?file=data://text/plain,payload ?&gt;</code><br/> <strong>例1：</strong><br/> <code>?page=data://text/plain,&lt;script&gt;alert(document.cookie)&lt;/script&gt;</code><br/> <img alt=\"在这里插入图片描述\" src=\"image\\bfde221502874e39b3e730a78eca538c.png\"/><br/> <strong>例2：</strong><br/> <code>?page=data://text/plain,&lt;?php system(\"ping 127.0.0.1\");?&gt;</code><br/> <img alt=\"在这里插入图片描述\" src=\"image\\39de6faa140d4ff19ed22dc52dcf2a92.png\"/><strong>例3：</strong><br/> <img alt=\"在这里插入图片描述\" src=\"image\\6004673b223c4a8bbcec10729f80b7b1.png\"/><br/> 如果对特殊字符进行了过滤，可以通过base64编码后再输入<br/> <code>?page=data://text/plain;base64,PD9waHAgZWNobyBwaHBpbmZvKCk7Pz4=</code><br/> <img alt=\"在这里插入图片描述\" src=\"image\\74d3494332284cc094b30b15a8c79b98.png\"/></p>\n<h2><a id=\"font_colorred_size54pharfont_151\"></a><font color=\"red\" size=\"5\">4、phar://</font></h2>\n<ul><li>php解压缩包的一个函数，不管后缀是什么，都当作压缩包来解压。</li><li>格式：</li></ul>\n<pre><code>?file=phar://压缩包名/内部文件名\n例：phar://x.zip/x.php\n步骤：写一个一句话木马shell.php，然后用zip协议压缩为shell.zip，\n再将后缀改为png等其他格式\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\a8e127db83594d8ba2cbe8058e917a46.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"image\\5710fcf5cdfc493188ea26b2d2cf9a06.png\"/></p>\n<p><font color=\"red\"><b>注：</b></font>php 版本大于等于5.3.0，压缩包需要是zip协议压缩，rar不行，将木马文件压缩后，改为其他任意格式的文件都可以正常使用。</p>\n<h2><a id=\"font_colorred_size55zipfont_166\"></a><font color=\"red\" size=\"5\">5、zip://</font></h2>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\7dbaa6f71a424895b6d18388002855b9.png\"/></p>\n<p>源代码：<br/> <img alt=\"在这里插入图片描述\" src=\"image\\14399dea8c6d4aa1a3fbb58b4d2189d5.png\"/><br/> 压缩（zip）<br/> <img alt=\"在这里插入图片描述\" src=\"image\\9df0e54c6b31411cb5c6032727bd2698.png\"/><br/> 为了验证zip函数可以将任意文件当作压缩包来解压，我们修改后缀为bb.txt<br/> <img alt=\"在这里插入图片描述\" src=\"image\\0f580225e6b24faf97b4c3a207d0b619.png\"/><br/> 访问(绝对路径)</p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\b5007fbdcbc54a55a917afdc96a004c0.png\"/><br/> 这里貌似可以直接访问本地文件（但是phar不能）<br/> <img alt=\"在这里插入图片描述\" src=\"image\\9764899b30e141319565a00b3207a6e4.png\"/></p>\n<pre><code>更多的协议与相关测试，以后有时间再补充\n</code></pre>\n<h1><a id=\"_186\"></a>三、总结</h1>\n<ul><li>文件包含的主要函数有：include()、require()、include_once()、require_once()等。</li><li>文件包含支持的伪协议主要有：php://input、php://filter、data://、phar://、zip://等</li><li>伪协议在文件包含漏洞上的使用能够帮助我们绕过一些检测机制（比如包含的文件必须是“file”开头之类的判别，又或者利用data伪协议写入一句话木马）。</li><li>另外，这些协议的使用还有一些使用条件，我并没有写出来。<br/> 大家可以自行去网上查找相关资料。</li></ul>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}