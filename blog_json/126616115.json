{"blogid": "126616115", "writerAge": "码龄6年", "writerBlogNum": "762", "writerCollect": "3164", "writerComment": "102", "writerFan": "1000", "writerGrade": "7级", "writerIntegral": "14899", "writerName": "wespten", "writerProfileAdress": "writer_image\\profile_126616115.jpg", "writerRankTotal": "734", "writerRankWeekly": "503", "writerThumb": "655", "writerVisitNum": "1134804", "blog_read_count": "278", "blog_time": "于 2022-08-31 14:26:40 发布", "blog_title": "MySQL数据库优化", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h2>一、MySQL性能</h2>\n<h3>1、最大数据量</h3>\n<p>抛开数据量和并发数，谈性能都是耍流氓。MySQL没有限制单表最大记录数，它取决于操作系统对文件大小的限制。</p>\n<table><thead><tr><th>文件系统</th><th>单文件大小限制</th></tr></thead><tbody><tr><td>FAT32</td><td>最大4G</td></tr><tr><td>NTFS</td><td>最大64GB</td></tr><tr><td>NTFS5.0</td><td>最大2TB</td></tr><tr><td>EXT2</td><td>块大小为1024字节，文件最大容量16GB；块大小为4096字节，文件最大容量2TB</td></tr><tr><td>EXT3</td><td>块大小为4KB，文件最大容量为4TB</td></tr><tr><td>EXT4</td><td>理论可以大于16TB</td></tr></tbody></table>\n<p>单表行数超过500万行或者单表容量超过2GB，才推荐分库分表。性能由综合因素决定，抛开业务复杂度，影响程度依次是硬件配置、MySQL配置、数据表设计、索引优化。500万这个值仅供参考，并非铁律。博主曾经操作过超过4亿行数据的单表，分页查询最新的20条记录耗时0.6秒，SQL语句大致是：</p>\n<pre><code>select field_1,field_2 from table where id &lt; #{prePageMinId} order by id desc limit 20</code></pre>\n<p>prePageMinId是上一页数据记录的最小ID。虽然当时查询速度还凑合，随着数据不断增长，有朝一日必定不堪重负。</p>\n<p>分库分表是个周期长而风险高的大活儿，应该尽可能在当前结构上优化，比如升级硬件、迁移历史数据等等，实在没辙了再分。</p>\n<h3>2、最大并发数</h3>\n<p>并发数是指同一时刻数据库能处理多少个请求，由max_connections和max_user_connections决定。max_connections是指MySQL实例的最大连接数，上限值是16384，max_user_connections是指每个数据库用户的最大连接数。MySQL会为每个连接提供缓冲区，意味着消耗更多的内存。如果连接数设置太高硬件吃不消，太低又不能充分利用硬件。一般要求两者比值超过10%，计算方法如下：</p>\n<pre><code class=\"hljs\">max_used_connections / max_connections * 100% = 3/100 *100% ≈ 3%</code></pre>\n<p>查看最大连接数与响应最大连接数：</p>\n<pre><code class=\"hljs\">show variables like '%max_connections%';\nshow variables like '%max_user_connections%';</code></pre>\n<p>在配置文件my.cnf中修改最大连接数：</p>\n<pre><code class=\"hljs\">[mysqld]\nmax_connections = 100\nmax_used_connections = 20</code></pre>\n<h3>3、查询耗时0.5秒</h3>\n<p>建议将单次查询耗时控制在0.5秒以内，0.5秒是个经验值，源于用户体验的<strong>3秒原则</strong>。如果用户的操作3秒内没有响应，将会厌烦甚至退出。响应时间=客户端UI渲染耗时+网络请求耗时+应用程序处理耗时+查询数据库耗时，0.5秒就是留给数据库1/6的处理时间。</p>\n<h3>4、MySQL实施原则</h3>\n<p>相比NoSQL数据库，MySQL是个娇气脆弱的家伙。它就像体育课上的女同学，一点纠纷就和同学闹别扭(扩容难)，跑两步就气喘吁吁(容量小并发低)，常常身体不适要请假(SQL约束太多)。如今大家都会搞点分布式，应用程序扩容比数据库要容易得多，所以实施原则是<strong>数据库少干活，应用程序多干活</strong>。</p>\n<ul><li>充分利用但不滥用索引，须知索引也消耗磁盘和CPU。</li><li>不推荐使用数据库函数格式化数据，交给应用程序处理。</li><li>不推荐使用外键约束，用应用程序保证数据准确性。</li><li>写多读少的场景，不推荐使用唯一索引，用应用程序保证唯一性。</li><li>适当冗余字段，尝试创建中间表，用应用程序计算中间结果，用空间换时间。</li><li>不允许执行极度耗时的事务，配合应用程序拆分成更小的事务。</li><li>预估重要数据表（比如订单表）的负载和数据增长态势，提前优化。</li></ul>\n<h2>二、数据库架构与SQL执行过程</h2>\n<h3>1、数据库种类</h3>\n<p>作为一名后端开发人员，务必精通作为存储核心的MySQL或SQL Server，也要积极关注NoSQL数据库，他们已经足够成熟并被广泛采用，能解决特定场景下的性能瓶颈：</p>\n<table><thead><tr><th>分类</th><th>数据库</th><th>特性</th></tr></thead><tbody><tr><td>键值型</td><td><a href=\"https://memcached.org/\" title=\"Memcache\">Memcache</a></td><td>用于内容缓存，大量数据的高访问负载</td></tr><tr><td>键值型</td><td><a href=\"https://redis.io/\" title=\"Redis\">Redis</a></td><td>用于内容缓存，比Memcache支持更多的数据类型，并能持久化数据</td></tr><tr><td>列式存储</td><td><a href=\"https://hbase.apache.org/\" title=\"HBase\">HBase</a></td><td>Hadoop体系的核心数据库，海量结构化数据存储，大数据必备。</td></tr><tr><td>文档型</td><td><a href=\"http://couchdb.apache.org/\" title=\"MongoDb\">MongoDb</a></td><td>知名文档型数据库，也可以用于缓存</td></tr><tr><td>文档型</td><td><a href=\"https://hbase.apache.org/\" title=\"CouchDB\">CouchDB</a></td><td>Apache的开源项目，专注于易用性，支持REST API</td></tr><tr><td>文档型</td><td><a href=\"http://www.sequoiadb.com/cn/\" title=\"SequoiaDB\">SequoiaDB</a></td><td>国内知名文档型数据库</td></tr><tr><td>图形</td><td><a href=\"https://neo4j.com/\" title=\"Neo4J\">Neo4J</a></td><td>用于社交网络构建关系图谱，推荐系统等</td></tr></tbody></table>\n<h3>2、数据库架构</h3>\n<p><img alt=\"\" height=\"348\" src=\"image\\d5855001c7e14eb5ab04566d8ddf4af7.png\" width=\"451\"/></p>\n<p>如上图所示，MySQL 逻辑架构图主要分三层：</p>\n<ol><li>第一层负责连接处理、授权认证等。</li><li>第二层负责编译并优化 SQL。</li><li>第三层是存储引擎。</li></ol>\n<h3>3、SQL 执行过程</h3>\n<ol><li>客户端发送一条 SQL 语句给服务端，服务端的连接器先进行账号/密码、权限等验证，若有异常则直接拒绝请求。</li><li>服务端先查询缓存（MySQL8.0 已取消查询缓存），如果 SQL 语句命中了缓存，则返回缓存中的结果，否则继续处理。</li><li>服务端对 SQL 语句进行词法和语法分析，提取 SQL 中 select 等关键字，来检查 SQL 语句的合法性。</li><li>服务端通过优化器对之前生成的解析树进行优化处理，生成最优的物理执行计划。</li><li>将生成的物理执行计划调用存储引擎的相关接口，进行数据查询和处理。</li><li>处理完成后将结果返回客户端。</li></ol>\n<p>“条条大路通罗马”，优化器的作用就是找到这么多路中最优的那一条。</p>\n<h2>三、数据库表设计 </h2>\n<h3>1、数据类型</h3>\n<p>Mysql是一种关系型数据库，可以很好地支持大数据量的存储，但是一般来说，数据库中的表越小，在它上面执行的查询也就越快。因此，在创建表的时候，为了获得更好的性能，我们可以将表中字段的宽度舍得尽可能小。</p>\n<p>例如：在定义邮政编码这个字段时，如果将其设置为char(255)，显然给数据库增加了不必要的空间，甚至使用varchar这种类型也是多余的，因为char(6)就可以很好地完成了任务。同样的如果可以的话，我们应该是用MEDIUMINT而不是BIGINT来定义整形字段。</p>\n<p>数据类型的选择原则：更简单或者占用空间更小。</p>\n<ul><li>如果长度能够满足，整型尽量使用tinyint、smallint、medium_int而非int。</li><li>如果字符串长度确定，采用char类型。</li><li>如果varchar能够满足，不采用text类型。</li><li>精度要求较高的使用decimal类型，也可以使用BIGINT，比如精确两位小数就乘以100后保存。</li><li>尽量采用timestamp而非datetime。</li></ul>\n<table><thead><tr><th>类型</th><th>占据字节</th><th>描述</th></tr></thead><tbody><tr><td>datetime</td><td>8字节</td><td>'1000-01-01 00:00:00.000000' to '9999-12-31 23:59:59.999999</td></tr><tr><td>timestamp</td><td>4字节</td><td>'1970-01-01 00:00:01.000000' to '2038-01-19 03:14:07.999999'</td></tr></tbody></table>\n<p>相比datetime，timestamp占用更少的空间，以UTC的格式储存自动转换时区。</p>\n<h3>2、避免空值</h3>\n<p>MySQL中字段为NULL时依然占用空间，会使索引、索引统计更加复杂。在可能的情况下，尽量把字段设置为NOT NULL，这样在将来执行查询的时候，数据库不用去比较NULL值。</p>\n<p>从NULL值更新到非NULL无法做到原地更新，容易发生索引分裂影响性能。尽可能将NULL值用有意义的值代替，也能避免SQL语句里面包含is not null的判断。</p>\n<p>对于某些文本字段来说，例如“省份”或者“性别”，我们可以将他们定义为ENUM(枚举)类型。因为在MySQL中，ENUM类型被当做数值型数据来处理，而数值型数据被处理起来的速度要比文本类型要快得多。这样我们又可以提高数据库的性能。</p>\n<h3>3、text类型优化</h3>\n<p>由于text字段储存大量数据，表容量会很早涨上去，影响其他字段的查询性能。建议抽取出来放在子表里，用业务主键关联。</p>\n<h2>四、存储引擎与索引优化</h2>\n<h3>1、存储引擎</h3>\n<p>InnoDB 存储引擎（Storage Engine）是 MySQL 默认之选，所以非常典型。</p>\n<p>存储引擎的主要作用是进行数据的存取和检索，也是真正执行 SQL 语句的组件。</p>\n<p>InnoDB 的整体架构分为两个部分：内存架构和磁盘架构，如图：</p>\n<p><img alt=\"\" height=\"479\" src=\"image\\04f85304e59544b793d0e717b8669f68.png\" width=\"618\"/></p>\n<p>存储引擎的内容非常多，我们在此只需要了解内存架构和磁盘架构的大致组成即可。 </p>\n<p>InnoDB 引擎是面向行存储的，数据都是存储在磁盘的数据页中，数据页里面按照固定的行格式存储着每一行数据。</p>\n<p>行格式主要分为四种类型：Compact、Redundant、Dynamic 和 Compressed，默认为 Compact 格式。</p>\n<p> <img alt=\"\" height=\"188\" src=\"image\\bed61cc2d3a94b5a8efd247d10d829ec.png\" width=\"589\"/></p>\n<p><strong>① 操作系统</strong></p>\n<p>1）局部性原理</p>\n<ul><li>时间局部性：之前被访问过的数据很有可能被再次访问。</li><li>空间局部性：数据和程序都有聚集成群的倾向。</li></ul>\n<p>2）磁盘预读机制</p>\n<p>当计算机访问一个数据时，不仅会加载当前数据所在的数据页，还会将当前数据页相邻的数据页一同加载到内存，磁盘预读的长度一般为页的整倍数，从而有效降低磁盘 I/O 的次数（如果要读取的数据量超过一页的大小，就会触发多次磁盘 I/O 操作）。</p>\n<p> <img alt=\"\" height=\"319\" src=\"image\\9de1de52e5294cf2b583ab103e0b3a31.png\" width=\"570\"/></p>\n<p><strong>② 磁盘和内存的交互</strong></p>\n<p>MySQL 中磁盘的数据需要被交换到内存，才能完成一次 SQL 交互，大致如图： </p>\n<p><img alt=\"\" height=\"316\" src=\"image\\d476ec05bb6e410fad8084a1584c53a9.png\" width=\"512\"/></p>\n<ul><li><strong>扇区</strong>是硬盘读写的基本单位，通常情况下每个扇区的大小是 512B。</li><li><strong>磁盘块</strong>是操作系统（文件系统）读写数据的最小单位，相邻的扇区组合在一起形成一个块，一般是 4KB。</li><li><strong>页</strong>是内存的最小存储单位，页的大小通常为磁盘块大小的 2n 倍。</li><li>InnoDB 的页的默认大小是 16KB，是数倍个操作系统的页。</li></ul>\n<p><strong>③ 随机磁盘 I/O</strong></p>\n<p>MySQL 的数据是一行行存储在磁盘上的，并且这些数据并非物理连续地存储，这样的话要查找数据就无法避免随机在磁盘上读取和写入数据。</p>\n<p>对于 MySQL 来说，当出现大量磁盘随机 I/O 时，大部分时间都被浪费到寻道上，磁盘呼噜呼噜转，就是传输不了多少数据。</p>\n<p><img alt=\"\" height=\"232\" src=\"image\\2d747bf932464b5c86763513194bfa75.png\" width=\"805\"/></p>\n<p>一次磁盘访问由三个动作组成：</p>\n<ul><li>寻道（Seek Time）：磁头移动定位到指定磁道。</li><li>旋转（Rotational Latency）：等待指定扇区从磁头下旋转经过。</li><li>数据传输（Transfer Time）：数据在磁盘与内存之间的实际传输。</li></ul>\n<p>对于存储引擎来说，如何有效降低随机 I/O 是个非常重要的问题。 </p>\n<h3>2、索引分类</h3>\n<ol><li>普通索引：最基本的索引。</li><li>组合索引：多个字段上建立的索引，能够加速复合查询条件的检索。</li><li>唯一索引：与普通索引类似，但索引列的值必须唯一，允许有空值。</li><li>组合唯一索引：列值的组合必须唯一。</li><li>主键索引：特殊的唯一索引，用于唯一标识数据表中的某一条记录，不允许有空值，一般用primary key约束。</li><li>全文索引：用于海量文本的查询，MySQL5.6之后的InnoDB和MyISAM均支持全文索引。由于查询精度以及扩展性不佳，更多的企业选择Elasticsearch。</li></ol>\n<h3>3、索引优化</h3>\n<ol><li>分页查询很重要，如果查询数据量超过30%，MYSQL不会使用索引。</li><li>单表索引数不超过5个、单个索引字段数不超过5个。</li><li>字符串可使用前缀索引，前缀长度控制在5-8个字符。</li><li>字段唯一性太低，增加索引没有意义，如：是否删除、性别。</li><li>合理使用覆盖索引，如下所示：</li></ol>\n<pre><code class=\"hljs\">select login_name, nick_name from member where login_name = ?</code></pre>\n<p>login_name, nick_name两个字段建立组合索引，比login_name简单索引要更快。</p>\n<h3>4、对哪些字段使用索引</h3>\n<p>索引是提高数据库性能的常用方法，他可以令数据库服务器比没有索引快得多的速度检索特定的行，尤其是在查询语句当中包含有MAX(),MIN()和ORDERBY这些命令的时候，性能提高更为明显。</p>\n<p>一般来说，索引应该建立在那些将用于join，where判断和orderby排序的字段上。尽量不要对数据库中某个含有大量重复的值的字段建立索引，对于一个ENUM类型的字段来说，出现大量重复值是很有可能的情况。</p>\n<p>例如customerinfo中的“province”..字段，在这样的字段上建立索引将不会有什么帮助；相反，还有可能降低数据库的性能。我们在创建表的时候可以同时创建合适的索引，也可以使用ALTERTABLE或CREATEINDEX在以后创建索引。</p>\n<p>此外，MySQL从版本3.23.23开始支持全文索引和搜索。全文索引在MySQL中是一个FULLTEXT类型索引，但仅能用于MyISAM类型的表。对于一个大的数据库，将数据装载到一个没有FULLTEXT索引的表中，然后再使用ALTERTABLE或CREATEINDEX创建索引，将是非常快的。但如果将数据装载到一个已经有FULLTEXT索引的表中，执行过程将会非常慢。</p>\n<h3>5、避免函数索引</h3>\n<p>例：</p>\n<pre><code class=\"hljs\">SELECT * FROM t WHERE YEAR(d) &gt;= 2016;</code></pre>\n<p>由于MySQL不像Oracle那样支持函数索引，即使d字段有索引，也会直接全表扫描。</p>\n<p>应改为：</p>\n<pre><code class=\"hljs\">SELECT * FROM t WHERE d &gt;= ‘2016-01-01';</code></pre>\n<h2>五、SQL优化</h2>\n<h3>1、分批处理</h3>\n<p>小时候看到鱼塘挖开小口子放水，水面有各种漂浮物。浮萍和树叶总能顺利通过出水口，而树枝会挡住其他物体通过，有时还会卡住，需要人工清理。MySQL就是鱼塘，最大并发数和网络带宽就是出水口，用户SQL就是漂浮物。不带分页参数的查询或者影响大量数据的update和delete操作，都是树枝，我们要把它打散分批处理，举例说明：</p>\n<p>业务描述：更新用户所有已过期的优惠券为不可用状态。</p>\n<p>SQL语句：</p>\n<pre><code class=\"hljs\">update status=0 FROM `coupon` WHERE expire_date &lt;= #{currentDate} and status=1;</code></pre>\n<p>如果大量优惠券需要更新为不可用状态，执行这条SQL可能会堵死其他SQL，分批处理伪代码如下：</p>\n<pre><code class=\"hljs\">int pageNo = 1;\nint PAGE_SIZE = 100;\nwhile(true) {\n    List&lt;Integer&gt; batchIdList = queryList('select id FROM `coupon` WHERE expire_date &lt;= #{currentDate} and status = 1 limit #{(pageNo-1) * PAGE_SIZE},#{PAGE_SIZE}');\n    if (CollectionUtils.isEmpty(batchIdList)) {\n        return;\n    }\n    update('update status = 0 FROM `coupon` where status = 1 and id in #{batchIdList}')\n    pageNo ++;\n}</code></pre>\n<p> 批量INSERT插入：</p>\n<pre><code class=\"hljs\">INSERT INTO t (id, name) VALUES(1,'Bea');\nINSERT INTO t (id, name) VALUES(2,'Belle');\nINSERT INTO t (id, name) VALUES(3,'Bernice');\n</code></pre>\n<p>优化为：</p>\n<pre><code class=\"hljs\">INSERT INTO t (id, name) VALUES(1,'Bea'), (2,'Belle'),(3,'Bernice');</code></pre>\n<h3>2、操作符&lt;&gt;优化</h3>\n<p>通常&lt;&gt;操作符无法使用索引，举例如下，查询金额不为100元的订单：</p>\n<pre><code class=\"hljs\">select id from orders where amount != 100;</code></pre>\n<p>如果金额为100的订单极少，这种数据分布严重不均的情况下，有可能使用索引。鉴于这种不确定性，采用union聚合搜索结果，改写方法如下：</p>\n<pre><code class=\"hljs\">(select id from orders where amount &gt; 100)\n union all\n(select id from orders where amount &lt; 100 and amount &gt; 0)</code></pre>\n<h3>3、OR优化</h3>\n<p>在Innodb引擎下or无法使用组合索引，比如：</p>\n<pre><code class=\"hljs\">select id，product_name from orders where mobile_no = '13421800407' or user_id = 100;\n</code></pre>\n<p>OR无法命中mobile_no + user_id的组合索引，可采用union，如下所示：</p>\n<pre><code class=\"hljs\">(select id，product_name from orders where mobile_no = '13421800407')\n union\n(select id，product_name from orders where user_id = 100);</code></pre>\n<p>此时id和product_name字段都有索引，查询才最高效。</p>\n<p>用IN来替换OR。</p>\n<p>低效查询：</p>\n<pre><code class=\"hljs\">SELECT * FROM t WHERE LOC_ID = 10 OR LOC_ID = 20 OR LOC_ID = 30;</code></pre>\n<p> 高效查询：</p>\n<pre><code class=\"hljs\">SELECT * FROM t WHERE LOC_IN IN (10,20,30);</code></pre>\n<h3>4、IN优化</h3>\n<ol><li>IN适合主表大子表小，EXIST适合主表小子表大。由于查询优化器的不断升级，很多场景这两者性能差不多一样了。</li><li>尝试改为join查询，举例如下：</li></ol>\n<pre><code class=\"hljs\">select id from orders where user_id in (select id from user where level = 'VIP');\n</code></pre>\n<p>采用JOIN如下所示：</p>\n<pre><code class=\"hljs\">select o.id from orders o left join user u on o.user_id = u.id where u.level = 'VIP';\n</code></pre>\n<p> 子查询在MySQL5.5版本里，内部执行计划器是这样执行的：先查外表再匹配内表，而不是先查内表t2，当外表的数据很大时，查询速度会非常慢。</p>\n<p>在MariaDB10/MySQL5.6版本里，采用join关联方式对其进行了优化。但优化只针对SELECT有效，对UPDATE/DELETE子查询无效，固生产环境应避免使用子查询</p>\n<h3>5、不做列运算</h3>\n<p>通常在查询条件列运算会导致索引失效，如下所示：</p>\n<p>查询当日订单。</p>\n<pre><code class=\"hljs\">select id from order where date_format(create_time，'%Y-%m-%d') = '2019-07-01';\n</code></pre>\n<p>date_format函数会导致这个查询无法使用索引，改写后：</p>\n<pre><code class=\"hljs\">select id from order where create_time between '2019-07-01 00:00:00' and '2019-07-01 23:59:59';\n</code></pre>\n<h3>6、避免Select all</h3>\n<p>如果不查询表中所有的列，避免使用<code>SELECT *</code>，它会进行全表扫描，不能有效利用索引。</p>\n<h3>7、Like优化</h3>\n<p>LIKE双百分号无法使用到索引：</p>\n<p>like用于模糊查询，举个例子（field已建立索引）：</p>\n<pre><code class=\"hljs\">SELECT column FROM table WHERE field like '%keyword%';\n</code></pre>\n<p>这个查询未命中索引，换成下面的写法：</p>\n<pre><code class=\"hljs\">SELECT column FROM table WHERE field like 'keyword%';\n</code></pre>\n<p>去除了前面的%查询将会命中索引，但是产品经理一定要前后模糊匹配呢？全文索引fulltext可以尝试一下，但Elasticsearch才是终极武器。</p>\n<p>目前只有MySQL5.7支持全文索引（支持中文）</p>\n<h3>8、Join优化</h3>\n<p>join的实现是采用Nested Loop Join算法，就是通过驱动表的结果集作为基础数据，通过该结数据作为过滤条件到下一个表中循环查询数据，然后合并结果。如果有多个join，则将前面的结果集作为循环数据，再次到后一个表中查询数据。</p>\n<ol><li>驱动表和被驱动表尽可能增加查询条件，满足ON的条件而少用Where，用小结果集驱动大结果集。</li><li>被驱动表的join字段上加上索引，无法建立索引的时候，设置足够的Join Buffer Size。</li><li>禁止join连接三个以上的表，尝试增加冗余字段。</li></ol>\n<p>例如：我们要将客户基本信息表中没有任何订单的客户删除掉，就可以利用子查询先从销售信息表中将所有发出订单的客户id取出来，然后将结果传递给主查询，如下图所示：</p>\n<p><img alt=\"\" height=\"133\" src=\"image\\7283b0a8c5ba4dd8929376448cf07361.png\" width=\"430\"/></p>\n<p>如果使用连接(JOIN)来完成这个工作，速度将会快很多，尤其是当salesinfo表中对CustomerID建有索引的话，性能将会更好，查询如下：</p>\n<p><img alt=\"\" height=\"121\" src=\"image\\fbef3fbdd0724c4ea1438c4d3f9c2668.png\" width=\"654\"/></p>\n<p>连接(JOIN)之所以更有效率一些，是因为MySQL不需要在内存中创建临时表来完成这个逻辑上 需要两个步骤的查询工作。</p>\n<p>另外，如果你的应用程序有很多JOIN查询，你应该确认两个表中JOIN的字段是被建立过索引的。这样MySQL内部 会启动为你优化JOIN的SQL语句的机制。而且这些被用来JOIN的字段，应该是相同的类型的。</p>\n<p>例如：如果你要把DECIMAL字段和一个INT字段JOIN在一起，MySQL就无法使用他们的索引。对于那些STRING类型，还需要有相同的字符集才行。(两个表的字符集可能不相同)。</p>\n<p>inner join内连接也叫做等值连接，left/right join是外链接。</p>\n<pre><code class=\"hljs\">SELECT A.id,A.name,B.id,B.name FROM A LEFT JOIN B ON A.id=B.id;\nSELECT A.id,A.name,B.id,B.name FROM A RIGHT JOIN ON B A.id= B.id;\nSELECT A.id,A.name,B.id,B.name FROM A INNER JOIN ON A.id =B.id;</code></pre>\n<p>经过多方面的证实inner join性能比较快，因为inner join是等值连接，或许返回的行数比较少。但是我们要记得有些语句隐形的用到了等值连接，如：</p>\n<pre><code class=\"hljs\">SELECT A.id,A.name,B.id,B.name FROM A,B WHERE A.id = B.id;\n</code></pre>\n<p>推荐：能用inner join连接诶就用inner join连接。</p>\n<p>sql中的连接查询有inner join(内连接）、left join(左连接)、right join（右连接）、full join（全连接）四种方式，它们之间其实并没有太大区别，仅仅是查询出来的结果有所不同。</p>\n<p>例如我们有两张表：</p>\n<p><img alt=\"\" height=\"324\" src=\"image\\66ad24e5b6a646c69af4e04fa4f7f1d1.png\" width=\"598\"/></p>\n<p>Orders表通过外键Id_P和Persons表进行关联。</p>\n<p>inner join（内连接），在两张表进行连接查询时，只保留两张表中完全匹配的结果集。</p>\n<p>我们使用inner join对两张表进行连接查询，sql如下：</p>\n<pre><code class=\"hljs\">SELECT p.LastName, p.FirstName, o.OrderNo\nFROM Persons p\nINNER JOIN Orders o\nON p.Id_P=o.Id_P and 1=1  --用and连接多个条件\nORDER BY p.LastName</code></pre>\n<p>查询结果集：</p>\n<p><img alt=\"\" height=\"137\" src=\"image\\1e2cf43b02964a18b705aecd5b24c41e.png\" width=\"614\"/></p>\n<p>此种连接方式Orders表中Id_P字段在Persons表中找不到匹配的，则不会列出来。</p>\n<p>注意：单纯的select * from a,b是笛卡尔乘积。比如a表有5条数据，b表有3条数据，那么最后的结果有5*3=15条数据。</p>\n<p>但是如果对两个表进行关联:select * from a,b where a.id = b.id 意思就变了，此时就等价于：</p>\n<pre><code class=\"hljs\">select * from a inner join b on a.id = b.id。 -- 即就是内连接。</code></pre>\n<p>但是这种写法并不符合规范，可能只对某些数据库管用，如sqlserver。推荐最好不要这样写。最好写成inner join的写法。</p>\n<p>内连接查询 (select * from a join b on a.id = b.id) 与 关联查询 (select * from a , b where a.id = b.id)的区别</p>\n<p>left join,在两张表进行连接查询时，会返回左表所有的行，即使在右表中没有匹配的记录。</p>\n<p>我们使用left join对两张表进行连接查询，sql如下：</p>\n<pre><code class=\"hljs\">SELECT p.LastName, p.FirstName, o.OrderNo\nFROM Persons p\nLEFT JOIN Orders o\nON p.Id_P=o.Id_P\nORDER BY p.LastName</code></pre>\n<p>查询结果如下：</p>\n<p><img alt=\"\" height=\"165\" src=\"image\\2c3956dfa84b4a889956d6776bf3f797.png\" width=\"616\"/></p>\n<p>可以看到，左表（Persons表）中LastName为Bush的行的Id_P字段在右表（Orders表）中没有匹配，但查询结果仍然保留该行。</p>\n<p>right join,在两张表进行连接查询时，会返回右表所有的行，即使在左表中没有匹配的记录。</p>\n<p>我们使用right join对两张表进行连接查询，sql如下：</p>\n<pre><code class=\"hljs\">SELECT p.LastName, p.FirstName, o.OrderNo\nFROM Persons p\nRIGHT JOIN Orders o\nON p.Id_P=o.Id_P\nORDER BY p.LastName</code></pre>\n<p> 查询结果如下：</p>\n<p><img alt=\"\" height=\"164\" src=\"image\\1748920e5081412fbd067f8744970cfb.png\" width=\"622\"/></p>\n<p>Orders表中最后一条记录Id_P字段值为65，在左表中没有记录与之匹配，但依然保留。</p>\n<p>full join,在两张表进行连接查询时，返回左表和右表中所有没有匹配的行。</p>\n<p>我们使用full join对两张表进行连接查询，sql如下：</p>\n<pre><code class=\"hljs\">SELECT p.LastName, p.FirstName, o.OrderNo\nFROM Persons p\nFULL JOIN Orders o\nON p.Id_P=o.Id_P\nORDER BY p.LastName</code></pre>\n<p>查询结果如下：</p>\n<p><img alt=\"\" height=\"192\" src=\"image\\fa4f4ad35c2b42d3ad28a4c7730a75a1.png\" width=\"617\"/></p>\n<p>查询结果是left join和right join的并集。 </p>\n<h3>9、Limit优化</h3>\n<p>limit用于分页查询时越往后翻性能越差，解决的原则：缩小扫描范围，如下所示：</p>\n<pre><code class=\"hljs\">select * from orders order by id desc limit 100000,10 \n耗时0.4秒\nselect * from orders order by id desc limit 1000000,10\n耗时5.2秒</code></pre>\n<p>先筛选出ID缩小查询范围，写法如下：</p>\n<pre><code class=\"hljs\">select * from orders where id &gt; (select id from orders order by id desc  limit 1000000, 1) order by id desc limit 0,10\n耗时0.5秒</code></pre>\n<p>如果查询条件仅有主键ID，写法如下：</p>\n<pre><code class=\"hljs\">select id from orders where id between 1000000 and 1000010 order by id desc\n耗时0.3秒</code></pre>\n<pre><code class=\"hljs\">SELECT * FROM t WHERE 1;\n—–&gt;\nSELECT * FROM t WHERE 1 LIMIT 10;</code></pre>\n<p>如果以上方案依然很慢呢，只好用游标了。</p>\n<p>JDBC使用游标实现分页查询的方法。</p>\n<pre><code class=\"hljs\">/**\n* 一次只从数据库中查询最大maxCount条记录\n* @param sql 传入的sql语句\n* @param startNo 从哪一条记录开始\n* @param maxCount 总共取多少条记录\n*/\npublic void getData(String sql,int startNo,int maxCount){\n Connection conn = ConnectionUtil.getConnection();\n try {\n//  conn.prepareStatement(sql,游标类型,能否更新记录);\n//   游标类型：\n//    ResultSet.TYPE_FORWORD_ONLY:只进游标\n//    ResultSet.TYPE_SCROLL_INSENSITIVE:可滚动。但是不受其他用户对数据库更改的影响。\n//    ResultSet.TYPE_SCROLL_SENSITIVE:可滚动。当其他用户更改数据库时这个记录也会改变。\n//   能否更新记录：\n//    ResultSet.CONCUR_READ_ONLY,只读\n//    ResultSet.CONCUR_UPDATABLE,可更新\n  PreparedStatement pstat = conn.prepareStatement(sql,ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);\n  //最大查询到第几条记录\n  pstat.setMaxRows(startNo+maxCount-1);\n  ResultSet rs = pstat.executeQuery();\n  //将游标移动到第一条记录\n  rs.first();\n//  游标移动到要输出的第一条记录\n  rs.relative(startNo-2);\n  while(rs.next())\n  System.out.println(rs.getInt(1));\n } catch (SQLException e) {\n  e.printStackTrace();\n }\n}\n/**\n* 从数据库中查询所有记录，然后通过游标来获取所需maxCount条记录\n* @param sql 传入的sql语句\n* @param startNo 从哪一条记录开始\n* @param maxCount 总共取多少条记录\n*/\npublic void getDataFromAll(String sql,int startNo,int maxCount){\n Connection conn = ConnectionUtil.getConnection();\n try {\n  PreparedStatement pstat = conn.prepareStatement(sql,ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);\n  ResultSet rs = pstat.executeQuery();\n  rs.first();\n  rs.relative(startNo-1);\n  int i = startNo-1;\n  while(i &lt; startNo + maxCount-1 &amp;&amp; !rs.isAfterLast()){\n  System.out.println(rs.getInt(1));\n  i++;\n  rs.next();\n  }\n } catch (SQLException e) {\n  e.printStackTrace();\n }\n}</code></pre>\n<h3>10、使用联合(UNION)来代替手动创建的临时表</h3>\n<p>MySQL从4.0版本开始支持union查询，他可以把需要使用临时表的两条或更多的select查询合在一个查询中。在客户端查询会话结束的时候，临时表会被自动删除，从而保证数据库整齐、高效。使用union来创建查询的时候，我们只需要用union作为关键字把多个select语句连接起来就可以了，要注意的是所有select语句中的字段数目要相同。</p>\n<p>下面一个例子就演示了一个使用union的查询：</p>\n<p><img alt=\"\" height=\"144\" src=\"image\\678bfeffda8249718838be0ab9cb1593.png\" width=\"375\"/></p>\n<p>当我们可以确认不可能出现重复结果集或者不在乎重复结果集的时候尽量使用union all而不是union，因为union和union all的差异主要是前者需要将两个或者多个结果集合并后再进行唯一性过滤操作，这就会涉及到排序，增加大量的CPU运算，增大资源消耗及延迟。 </p>\n<h3>11、事务</h3>\n<p>尽管我们可以使用子查询(Sub-Queries)、连接(JOIN)和联合(UNION)来创建各种各样的查询，但不是所有的数据库操作，都可以只用一条或少数几条就可以完成的。更多的时候是需要用一系列的语句来完成某种工作。但是在这种情况下，当这个语句块中的某一条语句运行出错的时候，整个语句块的操作就会变得不确定起来。</p>\n<p>设想一下，要把某个数据同时插入两个相关联的表中，可能会出现这样的情况：第一个表中成功更新后，数据库突然出现意外状况，造成第二个表中的操作没有完成，这样就会造成数据的不完整，甚至会破坏数据库中的数据。要避免这种情况，就应该使用事务，它的作用是要么语句块中每条语句都操作成功，要么都失败。</p>\n<p>换句话说，就是可以保持数据库中的数据的一致性和完整性。事务以BEGIN关键字开始，COMMIT关键字结束。在这之间的一条SQL语句操作失败，那么Rollback命令就可以把数据库恢复到begin开始之前的状态。</p>\n<pre><code class=\"hljs\">BEGIN; \nINSERTINTOsalesinfoSETCustomerID=14;\nUPDATEinventorySETQuantity=11WHEREitem='book';\nCOMMIT;</code></pre>\n<p>事务的另一个作用是当多个用户同时使用相同的数据源时，他可以使用锁定数据库的方式来为用户提供一种安全的访问机制，这样可以保证用户的操作不被其它的用户所干扰。</p>\n<p>一般来说，事务必须满足四个条件(ACID)：原子性(Atomicity,或称不可分割性)、一致性(Consistency)、隔离性(Isolation,又称独立性)、持久性(Durability).</p>\n<ul><li><strong>原子性：</strong>一个事物(transaction)中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚(Rollback)到事务开始的状态，就像这个事务从来没有执行过一样。</li><li><strong>一致性：</strong>在事务开始之前和事务结束之后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</li><li><strong>隔离性：</strong>数据库允许多个事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同的级别，包括读未提交(<code>Read uncommitted</code>)、读已提交(<code>Read committed</code>)、可重复读(<code>repeateable read</code>)和串行化(<code>Serializable</code>).</li><li><strong>持久性：</strong>事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li></ul>\n<p><strong>事务的并发问题：</strong></p>\n<ul><li><strong>脏读：</strong>事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据就是脏数据</li><li>不可重复读：事务A多次读取同一事物，事务B在事务A多次读取的过程中，对数据做了更新并提交，导致事务A多次读取同一数据时，结果不一致。</li><li><strong>幻读：</strong>系统管理员A将数据库中的所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。</li><li><strong>小结：</strong>不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表</li></ul>\n<p>MySQL事务隔离级别：</p>\n<p><img alt=\"\" height=\"212\" src=\"image\\10d859ac18ed4c67a9e6666b7bc2aee7.png\" width=\"621\"/></p>\n<p><strong>事务控制语句：</strong></p>\n<p>BEGIN或START TRANSACTION：显式的开启一个事物。</p>\n<ul><li><strong>COMMIT：</strong>也可以使用<code>COMMIT WORK</code>，不过二者是等价的。<code>COMMIT</code>会提交事务，并使已对数据库进行的所有修改成为永久性的。</li><li><strong>Rollback：</strong>也可以使用<code>Rollback work</code>，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改。</li><li><strong>SAVEPOINT identifier：</strong><code>SAVEPOINT</code>允许在事务中创建一个保存点，一个事务中可以有很多个SAVEPOINT；</li><li><strong>RELEASE SAVEPOINT identifier：</strong>删除一个事物的保存点,当没有指定的保存点时，执行该语句会抛出一个异常。</li><li><strong>ROLLBACK TO inditifier：</strong>把事务回滚到标记点。</li><li><strong>SET TRANSACTION:</strong> 用来设置事务的隔离级别。InnoDB存储引擎提供事务的隔离级别有<code>READ UNCOMMITTED</code>、<code>READ COMMITTED</code>、<code>REPEATABLE READ</code>和<code>SERLALIZABLE</code>。</li></ul>\n<h3>12、使用外键</h3>\n<p>锁定表的方法可以维护数据的完整性，但是他却不能保证数据的关联性。这个时候我们可以使用外键。例如：外键可以保证每一条销售记录都指向某一个存在的客户。</p>\n<p>在这里，外键可以把customerinfo表中的customerid映射到salesinfo表中customerid，任何一条没有办法合法customerid的记录都不会被跟新或插入到salesinfo中。</p>\n<pre><code class=\"hljs\">CREATE TABLE customerinfo(customerid int primary key) engine = innodb;\n\nCREATE  TABLE   salesinfo( salesid int not null,customerid  int not null, primary key(customerid,salesid),foreign key(customerid)  references  customerinfo(customerid) on delete cascade)engine = innodb;\n</code></pre>\n<p>注意例子中的参数“on delete cascade”.该参数保证当customerinfo表中的一条客户记录也会被自动删除。如果要在mysql中使用外键，一定要记住在创建表的时候将表的类型定义为事务安全表InnoDB类型。该类型不是mysql表的默认类型。定义的方法是在CREATE TABLE语句中加上engine=innoDB。</p>\n<h3>13、锁定表</h3>\n<p>尽管事务是维护数据库完整性的一个非常好的方法，但却因为他的独占性，有时会影响数据库的性能，尤其是很大的应用系统中。由于在事务执行的过程中，数据库将会被锁定，因此其他的用户请求只能暂时等待直到该事务结束。</p>\n<p>如果一个数据库系统只有少数几个用户来使用，事务造成的影响不会成为太大的问题；但假设有成千上万的用户同时访问一个数据库系统，例如访问一个电子商务网站，就会产生比较严重的响应延迟。</p>\n<p>其实，有些情况下我们可以通过锁定表的方式来获得更好的性能。下面的例子就是锁定表的方法来完成前面一个例子中事务的功能。</p>\n<p><img alt=\"\" height=\"53\" src=\"image\\a648a8b23791468c96d6026e2ec0f862.png\" width=\"691\"/></p>\n<p><img alt=\"\" height=\"40\" src=\"image\\a8b0c75631fb4637ae3d5d0c2b171f78.png\" width=\"593\"/></p>\n<p>这里，我们用一个select语句取出初始数据，通过一些计算，用update语句将新值更新到表中。包含有WRITE关键字的LOCKTABLE语句可以保证在UNLOCKTABLES命令被执行之前，不会有其他访问来对inventory进行插入、更新或者删除的操作。</p>\n<h3>14、避免数据类型不一致</h3>\n<pre><code class=\"hljs\">SELECT * FROM t WHERE id = '19';</code></pre>\n<p>优化为：</p>\n<pre><code class=\"hljs\">SELECT * FROM t WHERE id = 19;</code></pre>\n<h3>15、分组统计可以禁止排序</h3>\n<pre><code class=\"hljs\">SELECT goods_id,count(*) FROM t GROUP BY goods_id;</code></pre>\n<p>默认情况下，MySQL对所有GROUP BY col1，col2…的字段进行排序。如果查询包括GROUP BY，想要避免排序结果的消耗，则可以指定ORDER BY NULL禁止排序。</p>\n<p>优化为：</p>\n<pre><code class=\"hljs\">SELECT goods_id,count(*) FROM t GROUP BY goods_id ORDER BY NULL;</code></pre>\n<h3>16、避免随机取记录</h3>\n<pre><code class=\"hljs\">SELECT * FROM t1 WHERE 1=1 ORDER BY RAND() LIMIT 4;</code></pre>\n<p>MySQL不支持函数索引，会导致全表扫描，优化为：</p>\n<pre><code class=\"hljs\">SELECT * FROM t1 WHERE id &gt;= CEIL(RAND()*1000) LIMIT 4;</code></pre>\n<h3>17、禁止不必要的ORDER BY排序</h3>\n<pre><code class=\"hljs\">SELECT count(1) FROM user u LEFT JOIN user_info i ON u.id = i.user_id WHERE 1 = 1 ORDER BY u.create_time DESC;</code></pre>\n<p>优化为：</p>\n<pre><code class=\"hljs\">SELECT count(1) FROM user u LEFT JOIN user_info i ON u.id = i.user_id;\n</code></pre>\n<h2>六、慢SQL优化</h2>\n<p>负责的项目主要采用阿里云数据库MySQL，最近频繁出现慢SQL告警，执行时间最长的竟然高达5分钟。导出日志后分析，主要原因竟然是<strong>没有命中索引和没有分页处理</strong>。</p>\n<p>慢 SQL，就是跑得很慢的 SQL 语句，你可能会问慢SQL会有啥问题吗？</p>\n<p>MySQL 服务器的资源（CPU、IO、内存等）是有限的，尤其在高并发场景下需要快速处理掉请求，否则一旦出现慢 SQL 就会阻塞掉很多正常的请求，造成大面积的失败/超时等。</p>\n<p><img alt=\"\" height=\"342\" src=\"image\\63078ebe463443d5bdd73cbad200482c.png\" width=\"452\"/></p>\n<p>在遇到慢 SQL 时，不能简单的把原因归结为 SQL 编写问题（虽然这是最常见的因素），实际上导致慢 SQL 有很多因素，大致如下：</p>\n<ol><li>索引设计问题</li><li>SQL 编写问题</li><li>表结构（类型、长度等）设计问题</li><li>锁</li><li>并发对 IO/CPU 资源争用</li><li>服务器硬件</li><li>MySQL 本身的 Bug</li></ol>\n<p>接下来将从以下几个方面分析慢 SQL 的解决之道：</p>\n<p><img alt=\"\" height=\"395\" src=\"image\\24a20b857e9f4fadb07a04f8cc372131.png\" width=\"450\"/> </p>\n<h3>1、慢SQL优化分析流程 </h3>\n<p><strong>1）了解各种 SQL 的执行效率</strong></p>\n<pre><code class=\"hljs\">show status like 'Com_%';  -- 了解各种SQL的执行频率\n</code></pre>\n<ul><li><strong>Com_select    | 1</strong>   执行 select 操作的次数，一次查询只累加 1。</li><li><strong>Com_insert     | 0</strong>   执行 insert 操作的次数，对于批量插入的 insert，只累加一次。</li><li><strong>Com_update   | 0</strong>   执行 update 操作的次数。</li><li><strong>Com_delete    | 0</strong>   执行 delete 操作的次数。</li></ul>\n<p>上述参数对 所有存储引擎 的表操作都会进行累计。</p>\n<p>下面这几个参数只是针对 InnoDB 存储引擎的，累加的算法也略有不同。</p>\n<pre><code class=\"hljs\">show status like 'Innodb_rows_%';\n</code></pre>\n<p>Innodb_rows_deleted     | 1 |          执行 delete 操作删除的行数。<br/> Innodb_rows_inserted    | 50 |        执行 insert 操作插入的行数。<br/> Innodb_rows_read          | 168 |      执行 select 查询返回的行数。<br/> Innodb_rows_updated    | 0 |          执行 updat 操作更新的行数。</p>\n<p>通过以上几个参数，我们可以了解当前数据库的应用是以插入更新为主还是以查询操作为主，以及各种类型的 SQL 大致的执行比例是多少。</p>\n<p>对事务型的应用，通过 Com_commit 和 Com_rollback 可以了解事务提交和回滚的情况，对于回滚操作非常频繁的数据库，可能意味着应用编写存在问题。</p>\n<p><strong>2）定位慢查询</strong></p>\n<p>可以通过以下两种方式定位执行效率较低的 SQL 语句（慢查询的统计通常由运维定期统计）：</p>\n<ol><li>通过慢查询日志定位那些执行效率较低的 SQL 语句。</li><li>慢查询日志在查询结束以后才纪录，所以在应用反映执行效率出现问题时，查询慢查询日志并不能定位问题。这时可以使用 show processlist 命令查看当前 MySQL 在进行的线程，包括线程的状态、是否锁表等，可以实时地查看 SQL 的执行情况，同时对一些锁表操作进行优化。</li></ol>\n<p><strong>show processlist 命令详解</strong></p>\n<p>show processlist 命令只列出前 100 条正在运行的线程信息，如果想全列出需要使用 show full processlist。也可以使用 mysqladmin processlist 语句得到此信息。</p>\n<p>除非有 SUPER 权限，可以看到所有线程。否则，只能看到自己的线程（也就是，与您正在使用的 MySQL 账户相关的线程）。</p>\n<p>本语句会报告 TCP/IP 连接的主机名称（采用 <em>host_name</em>:<em>client_port </em>格式），以方便地判定哪个客户端正在做什么。</p>\n<p>如果得到了“too many connections”错误信息，并且想要了解正在发生的情况，本语句是非常有用的。MySQL保留一个额外的连接，让拥有 SUPER 权限的账户使用，以确保管理员能够随时连接和检查系统（假设没有把此权限给予所有的用户）。</p>\n<pre><code class=\"hljs\">id       # ID标识，要kill一个语句的时候很有用\nuse      # 当前连接用户\nhost     # 显示这个连接从哪个ip的哪个端口上发出\ndb       # 数据库名\ncommand  # 连接状态，一般是休眠（sleep），查询（query），连接（connect），初始化（init）\ntime     # 连接持续时间，单位是秒\nstate    # 显示当前sql语句的状态\ninfo     # 显示这个sql语句</code></pre>\n<p>该命令中最关键的就是 state 列，MySQL 列出的状态主要有以下几种：</p>\n<ul><li><strong>Checking table</strong>：正在检查数据表（这是自动的）。</li><li><strong>Closing tables</strong>：正在将表中修改的数据刷新到磁盘中，同时正在关闭已经用完的表。这是一个很快的操作，如果不是这样的话，就应该确认磁盘空间是否已经满了或者磁盘是否正处于重负中。</li><li><strong>Connect out</strong>：复制从服务器正在连接主服务器。</li><li><strong>Copying to tmp table on disk</strong>：由于临时结果集大于 tmp_table_size，正在将临时表从内存存储转为磁盘存储以此节省内存。</li><li><strong>Creating tmp table</strong>：正在创建临时表以存放部分查询结果。</li><li><strong>deleting from main table</strong>：服务器正在执行多表删除中的第一部分，刚删除第一个表。</li><li><strong>deleting from reference tables</strong>：服务器正在执行多表删除中的第二部分，正在删除其他表的记录。</li><li><strong>Flushing tables</strong>：正在执行FLUSH TABLES，等待其他线程关闭数据表。</li><li><strong>Killed</strong>：发送了一个 kill 请求给某线程，那么这个线程将会检查 kill 标志位，同时会放弃下一个 kill 请求。MySQL 会在每次的主循环中检查 kill 标志位，不过有些情况下该线程可能会过一小段才能死掉。如果该线程程被其他线程锁住了，那么 kill 请求会在锁释放时马上生效。</li><li><strong>Locked</strong>：被其他查询锁住了。</li><li><strong>Sending data</strong>：正在处理 SELECT 查询的记录，同时正在把结果发送给客户端。</li><li><strong>Sorting for group</strong>：正在为 GROUP BY 做排序。</li><li><strong>Sorting for order</strong>：正在为 ORDER BY 做排序。</li><li><strong>Opening tables</strong>：这个过程应该会很快，除非受到其他因素的干扰。例如，在执 ALTER TABLE 或 LOCK TABLE 语句行完以前，数据表无法被其他线程打开。正尝试打开一个表。</li><li><strong>Removing duplicates</strong>：正在执行一个 SELECT DISTINCT 方式的查询，但是 MySQL 无法在前一个阶段优化掉那些重复的记录。因此，MySQL 需要再次去掉重复的记录，然后再把结果发送给客户端。</li><li><strong>Reopen table</strong>：获得了对一个表的锁，但是必须在表结构修改之后才能获得这个锁。已经释放锁，关闭数据表，正尝试重新打开数据表。</li><li><strong>Repair by sorting</strong>：修复指令正在排序以创建索引。</li><li><strong>Repair with keycache</strong>：修复指令正在利用索引缓存一个一个地创建新索引。它会比 Repair by sorting 慢些。</li><li><strong>Searching rows for update</strong>：正在讲符合条件的记录找出来以备更新。它必须在 UPDATE 要修改相关的记录之前就完成了。</li><li><strong>Sleeping</strong>：正在等待客户端发送新请求.：</li><li><strong>System lock</strong>：正在等待取得一个外部的系统锁。如果当前没有运行多个 mysqld 服务器同时请求同一个表，那么可以通过增加 --skip-external-locking 参数来禁止外部系统锁。</li><li><strong>Upgrading lock</strong>：正在尝试取得一个锁表以插入新记录。</li><li><strong>Updating</strong>：正在搜索匹配的记录，并且修改它们。</li><li><strong>User Lock</strong>：正在等待 GET_LOCK()。</li><li><strong>Waiting for tables</strong>：该线程得到通知，数据表结构已经被修改了，需要重新打开数据表以取得新的结构。然后，为了能的重新打开数据表，必须等到所有其他线程关闭这个表。以下几种情况下会产生这个通知：FLUSH TABLES tbl_name, ALTER TABLE, RENAME TABLE, REPAIR TABLE, ANALYZE TABLE 或 OPTIMIZE TABLE。</li><li><strong>waiting for handler insert</strong>：已经处理完了所有待处理的插入操作，正在等待新的请求。</li></ul>\n<p>大部分状态对应很快的操作，只要有一个线程保持同一个状态好几秒钟，那么可能是有问题发生了，需要检查一下。</p>\n<p>还有其他的状态没在上面中列出来，不过它们大部分只是在查看服务器是否有存在错误是才用得着。</p>\n<p><strong>3）连接数</strong></p>\n<p>当数据库连接池被占满时，如果有新的 SQL 语句要执行，只能排队等待，等待连接池中的连接被释放（等待之前的 SQL 语句执行完成）。</p>\n<p>如果监控发现数据库连接池的使用率过高，甚至是经常出现排队的情况，则需要进行调优。</p>\n<p>查看/设置最大连接数：</p>\n<pre><code class=\"hljs\">-- 查看最大连接数\nmysql&gt; show variables like '%max_connection%';\n+-----------------------+-------+\n| Variable_name         | Value |\n+-----------------------+-------+\n| extra_max_connections |       |\n| max_connections       | 2512  |\n+-----------------------+-------+\n2 rows in set (0.00 sec)\n\n-- 重新设置最大连接数\nset global max_connections=1000;</code></pre>\n<p>在 /etc/my.cnf 里面设置数据库的最大连接数：</p>\n<pre><code class=\"hljs\">[mysqld]\nmax_connections = 1000</code></pre>\n<p>查看当前连接数：</p>\n<pre><code class=\"hljs\">mysql&gt; show status like  'Threads%';\n+-------------------+-------+\n| Variable_name     | Value |\n+-------------------+-------+\n| Threads_cached    | 32    |\n| Threads_connected | 10    |\n| Threads_created   | 50    |\n| Threads_rejected  | 0     |\n| Threads_running   | 1     |\n+-------------------+-------+\n5 rows in set (0.00 sec)</code></pre>\n<ul><li>Threads_connected：表示当前连接数。跟 show processlist 结果相同。准确的来说，Threads_running 代表的是当前并发数。</li><li>Threads_running：表示激活的连接数。一般远低于 connected 数值。</li><li>Threads_created：表示创建过的线程数。</li><li>如果我们在 MySQL 服务器配置文件中设置了 thread_cache_size，那么当客户端断开之后，服务器处理此客户的线程将会缓存起来以响应下一个客户而不是销毁（前提是缓存数未达上限）。</li><li>如果发现 Threads_created 值过大的话，表明 MySQL 服务器一直在创建线程，这也是比较耗资源，因此可以适当增加配置文件中 thread_cache_size 值。</li></ul>\n<p>查询服务器 thread_cache_size 的值：</p>\n<pre><code class=\"hljs\">mysql&gt; show variables like 'thread_cache_size';\n+-------------------+-------+\n| Variable_name | Value |\n+-------------------+-------+\n| thread_cache_size | 100 |\n+-------------------+-------+\n1 row in set (0.00 sec)</code></pre>\n<h3>2、执行计划（explain）分析</h3>\n<p>EXPLAIN 命令可以获取 MySQL 如何执行 SELECT 语句的信息，因此平时在进行 SQL 开发时，都要养成用 explain 分析的习惯。</p>\n<h3>3、SQL 优化</h3>\n<p>即使数据库表的索引设置已经比较合理，但 SQL 语句书写不当的话，也会造成索引失效，甚至造成全表扫描，从而拉低性能。 </p>\n<p>开启查询缓存（MySQL 8.0 已废弃该功能）</p>\n<p>大多数的 MySQL 服务器都开启了查询缓存。这是提高性最有效的方法之一，而且这是被 MySQL 的数据库引擎处理的。当有很多相同的查询被执行了多次的时候，这些查询结果会被放到一个缓存中，这样，后续的相同的查询就不用操作表而直接访问缓存结果了。</p>\n<p>这里最主要的问题是，对于程序员来说，这个事情是很容易被忽略的。因为我们的某些查询语句会让 MySQL 不使用缓存。请看下面的示例：</p>\n<pre><code class=\"hljs\">SELECT username FROM user WHERE signup_date &gt;= CURDATE();  -- 不走缓存\nSELECT username FROM user WHERE signup_date &gt;= '2014-06-24';  -- 走缓存</code></pre>\n<p>上面两条 SQL 语句的差别就是 CURDATE() ，MySQL 的查询缓存对这个函数不起作用。所以，像 NOW() 和 RAND() 或是其它的诸如此类的 SQL 函数都不会开启查询缓存，因为这些函数的返回是不确定的。</p>\n<p><img alt=\"\" height=\"318\" src=\"image\\00a329392d2e4b4686837dc4578d9170.png\" width=\"737\"/></p>\n<p><strong>1）使用连接查询代替子查询</strong></p>\n<p>对于数据库来说，在绝大部分情况下，连接会比子查询更快，使用连接的方式，MySQL 优化器一般可以生成更佳的执行计划，更高效地处理查询。</p>\n<p>而子查询往往需要运行重复的查询，子查询生成的临时表上也没有索引， 因此效率会更低。</p>\n<p><strong>2）当只要一行数据时使用 LIMIT 1</strong></p>\n<p>针对非主键的其他查询，加上 LIMIT 1 可以增加性能。这样 MySQL 数据库引擎会在找到一条数据后停止搜索，而不是继续往后查下一条符合记录的数据（否则即使已经查到一条结果，也会继续查询是否还存在等值结果，再返回结果）。</p>\n<p><strong>3）多表关联查询时，小表在前，大表在后</strong></p>\n<p>在 MySQL 中，执行 from 后的表关联查询是从左往右执行的，第一张表会涉及到全表扫描，所以将小表放在前面，先扫小表，扫描快效率较高，在扫描后面的大表，或许只扫描大表的前 100 行就符合返回条件并 return 了。</p>\n<p><strong>4）调整 where 子句中的连接顺序</strong></p>\n<p>MySQL 采用从左往右的顺序解析 where 子句，可以将过滤数据多的条件放在前面，最快速度缩小结果集。</p>\n<p><strong>5）不要使用 ORDER BY RAND( )</strong></p>\n<p>想打乱返回的数据行？随机挑一个数据？但你却不了解这样做有多么可怕的性能问题。</p>\n<p>如果你真的想把返回的数据行打乱了，你有 N 种方法可以达到这个目的。而这样使用只让你的数据库的性能呈指数级的下降。这里的问题是：MySQL会不得不去执行 RAND() 函数（很耗 CPU），而且这是为每一行记录去记行（扫全表），然后再对其排序，就算是用了 limit 1 也无济于事（因为要排序）。</p>\n<p><strong>6）优化 GROUP BY</strong></p>\n<p>使用 GROUP BY 但要避免排序结果的消耗。</p>\n<pre><code class=\"hljs\">GROUP BY … ORDER BY NULL;  -- 禁止排序\n</code></pre>\n<p><strong>7）JOIN 查询</strong></p>\n<p>如果你的应用程序有很多 JOIN 查询，你应该确认两个表中 JOIN 的字段是被建过<strong>索引</strong>的。这样，MySQL 内部会启动为你优化 JOIN 语句的机制。</p>\n<p>而且，这些被用来 JOIN 的字段，应是<strong>相同类型</strong>的。例如：如果你要把 DECIMAL 字段和一个 INT 字段 JOIN 在一起，MySQL 就无法使用它们的索引。对于 STRING 类型，还需要有<strong>相同的字符集</strong>才行（两个表的字符集有可能不一样）。</p>\n<pre><code class=\"hljs\">SELECT company_name FROM users\nLEFT JOIN companies ON users.state = companies.state\nWHERE users.id = ...</code></pre>\n<p>例如以上两个 state 字段应该是被建过索引的，而且应是相当类型、相同字符集的。</p>\n<h3>4、表结构优化 </h3>\n<p><strong>1）永远为每张表创建主键</strong></p>\n<p>我们应该为数据库里的每张表都设置一个 id 作为主键，最好还是 INT 类型的（推荐使用 UNSIGNED 即无符号化），并设置上自动增加的 AUTO_INCREMENT 标志。</p>\n<ul><li>表数据的存储在磁盘中是按照主键顺序存放的，所以使用主键查询数据速度最快。</li><li>INT 类型相比字符串类型，其长度更为固定，查询效率更高。</li><li>还有一些操作需要用到主键，比如集群、分区等。在这些情况下，主键的性能和设置变得非常重要。</li></ul>\n<p>所以建表时一定要带有主键，后续优化效果最好。</p>\n<p><strong>2）固定长度的表会更快</strong></p>\n<p>如果表中的所有字段都是“固定长度”的，整个表会被认为是 “static” 或 “fixed-length”。 例如，表中没有如下类型的字段： VARCHAR、TEXT、BLOB。只要你包括了其中一个这些字段，那么这个表就不是“固定长度静态表”了，这样，MySQL 引擎会用另一种方法来处理。</p>\n<p>固定长度的表会提高性能，因为 MySQL 搜寻得会更快一些，因为这些固定的长度是很容易计算下一个数据的偏移量，所以读取的自然也会很快。而如果字段不是定长的，那么，每一次要找下一条的话，需要程序找到主键。</p>\n<p>并且，固定长度的表也更容易被缓存和重建。不过，唯一的副作用是，固定长度的字段会浪费一些空间，因为定长的字段无论你用不用，他都是要分配那么多的空间。</p>\n<p><strong>3）通过拆分表，提高访问效率</strong></p>\n<p>把数据库中的表按列变成几张表的方法，这样可以降低表的复杂度和字段的数目，从而达到优化的目的。</p>\n<p><strong>4）越小的列会越快</strong></p>\n<p>对于大多数的数据库引擎来说，硬盘操作可能是最重大的瓶颈。所以，把你的数据变得紧凑会对这种情况非常有帮助，因为这减少了对硬盘的访问。</p>\n<p>如果一个表只会有几列罢了（比如说字典表、配置表），那么，我们就没有理由使用 INT 来做主键，使用 MEDIUMINT、SMALLINT 或是更小的 TINYINT 会更经济一些。如果你不需要记录时间，使用 DATE 要比 DATETIME 好得多。</p>\n<p><strong>5）使用 ENUM 而不是 VARCHAR</strong></p>\n<p>ENUM 类型是非常快和紧凑的。实际上其保存的是 TINYINT，但其外表上显示为字符串。这样一来，用这个字段来做一些选项列表变得相当的完美。</p>\n<p>如果你有一个字段，比如“性别”，“国家”，“民族”，“状态”或“部门”，你知道这些字段的取值是有限而且固定的，那么，你应该使用 ENUM 而不是 VARCHAR。</p>\n<h3>5、MySQL 服务端参数优化</h3>\n<p><strong>1）Innodb_buffer_pool_size</strong></p>\n<p>影响性能的最主要参数，一般建议配置为系统总内存的 70-80%，这个参数决定了服务可分配的最大内存。</p>\n<pre><code class=\"hljs\">-- 通过 Buffer Pool 的实时状态信息来确定 InnoDB 的 Buffer Pool 的使用是否高效\nmysql&gt; show status like 'Innodb_buffer_pool_%';\n+---------------------------------------+-------------+\n| Variable_name                         | Value       |\n+---------------------------------------+-------------+\n| Innodb_buffer_pool_dump_status        | not started |\n| Innodb_buffer_pool_load_status        | not started |\n| Innodb_buffer_pool_pages_data         | 446         |\n| Innodb_buffer_pool_bytes_data         | 7307264     |\n| Innodb_buffer_pool_pages_dirty        | 0           |\n| Innodb_buffer_pool_bytes_dirty        | 0           |\n| Innodb_buffer_pool_pages_flushed      | 110         |\n| Innodb_buffer_pool_pages_free         | 12864       |\n| Innodb_buffer_pool_pages_misc         | 2           |\n| Innodb_buffer_pool_pages_total        | 13312       |\n| Innodb_buffer_pool_read_ahead_rnd     | 0           |\n| Innodb_buffer_pool_read_ahead         | 0           |\n| Innodb_buffer_pool_read_ahead_evicted | 0           |\n| Innodb_buffer_pool_read_requests      | 10293       |\n| Innodb_buffer_pool_reads              | 432         |\n| Innodb_buffer_pool_wait_free          | 0           |\n| Innodb_buffer_pool_write_requests     | 380         |\n+---------------------------------------+-------------+\n17 rows in set (0.00 sec)</code></pre>\n<p><strong>2）Innodb_log_buffer_size</strong></p>\n<p>顾名思义，这个参数就是用来设置 Innodb 的 Log Buffer 大小的，系统默认值为 1MB 。 Log Buffer 的主要作用就是缓冲 Log 数据，提高写 Log 的 I/O 性能。</p>\n<p>一般来说，如果你的系统不是写负载非常高且以大事务居多的话， 8MB 以内的大小就完全足够了。</p>\n<pre><code class=\"hljs\">-- 查看innodb_log_buffer_size 设置是否合理\nmysql&gt; show status like 'innodb_log%';\n+---------------------------+-------+\n| Variable_name             | Value |\n+---------------------------+-------+\n| Innodb_log_waits          | 0     |\n| Innodb_log_write_requests | 61    |\n| Innodb_log_writes         | 25    |\n+---------------------------+-------+\n3 rows in set (0.00 sec)</code></pre>\n<p><strong>3）刷盘策略</strong></p>\n<ul><li><strong>Sync_binlog</strong>：这是控制日志刷盘策略的，基于安全一般设置为 1。</li><li><strong>Innodb_flush_log_at_trx_commit</strong>：这个是控制事务日志刷盘策略，基于安全一般设置为 1。</li></ul>\n<p>上面两个参数设置为 1 时最安全，但对于磁盘 I/O 消耗更大；0 时为最大性能，但故障切换时容易丢数据。</p>\n<p><strong>4）InnoDB 性能监控</strong></p>\n<pre><code class=\"hljs\">-- 持续获取状态信息的方法\ncreate table innodb_monitor(a int) engine=innodb; </code></pre>\n<p>创建一个 innodb_monitor 空表后，InnoDB 会每隔 15 秒输出一次信息并记录到 Error Log 中。通过删除该表可停止监控。</p>\n<p>除此之外，我们还可以通过相同的方式打开和关闭 innodb_tablespace_monitor、innodb_lock_monitor、innodb_table_monitor 这三种监控功能。</p>\n<h3>6、硬件优化</h3>\n<p>不同的应用或者进程，对于硬件资源的要求是不同的。比如有计算密集型、I/O 密集型等。</p>\n<ul><li>关系型数据库的要求：多 CPU、高内存、高磁盘 I/O 的一种服务。</li><li>Redis 的要求：单 CPU、高内存、对磁盘要求低。</li></ul>\n<p>对于 MySQL，硬件如何选择和优化呢：</p>\n<ul><li>CPU：多核高频。</li><li>内存：高内存。</li><li>磁盘：选择 SSD；且一般要求做 RAID（磁盘阵列）。</li></ul>\n<p><strong>1. RAID（磁盘阵列）</strong></p>\n<p>根据数据分布和冗余方式，RAID 分为许多级别。不同存储厂商提供的 RAID 卡或设备，其支持的 RAID 级别也不尽相同。以下介绍最常见也是最基本的几种，其他 RAID 级别基本上都是在这几种基础上的改进。 </p>\n<table border=\"0\"><tbody><tr><td> <p><strong>RAID</strong></p> <p><strong>级别</strong></p> </td><td><strong>特性</strong></td><td><strong>优点</strong></td><td><strong>缺点</strong></td></tr><tr><td>RAID 0</td><td>也叫条带化（Stripe），按一定的条带大小（Chunk Size）将数据依次分布到各个磁盘，没有数据冗余。</td><td>数据并发读写速度快，无额外的磁盘空间开销，投资省。</td><td>数据无冗余保护，可靠性差。</td></tr><tr><td>RAID 1</td><td>也叫磁盘镜像（Mirror），两个磁盘一组，所有数据都同时写入两个磁盘，但读时从任一磁盘读都可以。</td><td> <p>数据有完全冗余保护，只要不出现两块镜像磁盘同时损坏，就不会影响使用；</p> <p>可以提高并发读性能。</p> </td><td>容量一定的话，需要 2 倍的磁盘，投资比较大。</td></tr><tr><td>RAID 10</td><td>是 RAID 1 和 RAID 0 的结合，也叫 RAND 1+0。先对磁盘做镜像，再条带话，使其兼具 RAID 1 的可靠性和 RAID 0 的优良并发读写性能。</td><td>可靠性高，并发读写性能优良。</td><td>容量一定的话，需要 2 倍的磁盘，投资比较大。</td></tr><tr><td>RAID 4 </td><td>像 RAID 0 一样对磁盘组条带化，不同的是：需要额外增加一个磁盘，用来写各 Stripe 的校验纠错数据。</td><td> <p>RAID 中的一个磁盘损坏的话，其数据可以通过校验纠错数据计算出来，具有一定容错保护能力；</p> <p>读数据速度快。</p> </td><td> <p>每个 Stripe 上数据的修改都要写校验纠错块，写性能受影响；</p> <p>所有纠错数据都在同一磁盘上，风险大，也会形成一个性能瓶颈；</p> <p>在出现坏盘时，读性能会下降。</p> </td></tr><tr><td>RAID 5</td><td>是对 RAID4 的改进：将每一个条带（Stripe）的校验纠错数据块也分布写到各个磁盘，而不是写到一个特定的磁盘。</td><td>基本同 RAID 4，只是其写性能和数据保护能力要更强一 点。</td><td> <p>写性能不及 RAID 0、 RAID 1 和 RAID 10，容错能力也不及 RAID 1；</p> <p>在出现坏盘时，读性能会下降。</p> </td></tr></tbody></table>\n<p><strong>2. 如何选择 RAID 级别</strong></p>\n<p>了解各种 RAID 级别的特性后，我们就可以根据数据读写的特点、可靠性要求，以及投资预算等来选择合适的 RAID 级别，比如：</p>\n<ul><li>数据读写都很频繁，可靠性要求也很高，最好选择 RAID 10。</li><li>数据读很频繁，写相对较少，对可靠性有一定要求，可以选择 RAID 5。</li><li>数据读写都很频繁，但可靠性要求不高，可以选择 RAID 0。</li></ul>\n<p><strong>3. 虚拟文件卷或软 RAID</strong></p>\n<p>最初，RAID 都是由硬件实现的，要使用 RAID，至少需要有一个 RAID 卡。但现在，一些操作系统中提供的软件包，也模拟实现了一些 RAID 的特性，虽然性能上不如硬 RAID，但相比单个磁盘，性能和可靠性都有所改善。比如：</p>\n<ul><li>Linux下的逻辑卷（Logical Volume）系统 lvm2，支持条带化（Stripe）。</li><li>Linux 下的 MD（Multiple Device）驱动，支持 RAID 0、RAID 1、RAID 4、RAID 5、RAID 6 等。</li></ul>\n<p>在不具备硬件条件的情况下，可以考虑使用上述虚拟文件卷或软 RAID 技术，具体配置方法可参见 Linux 帮助文档。</p>\n</div>\n</div>"}