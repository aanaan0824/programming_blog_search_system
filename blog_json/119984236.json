{"blogid": "119984236", "writerAge": "码龄1年", "writerBlogNum": "96", "writerCollect": "308", "writerComment": "37", "writerFan": "30", "writerGrade": "4级", "writerIntegral": "1264", "writerName": "肥兄", "writerProfileAdress": "writer_image\\profile_119984236.jpg", "writerRankTotal": "222089", "writerRankWeekly": "279093", "writerThumb": "169", "writerVisitNum": "40621", "blog_read_count": "15601", "blog_time": "于 2021-08-29 20:37:56 发布", "blog_title": "Java Stream流（详解）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h1>一、Stream流引入</h1>\n<p>        Lambda表达式，基于Lambda所带来的函数式编程，又引入了一个全新的Stream概念，用于解决集合类库既有的鼻端。<strong>（Lambda表达式详解在上篇博客内容）</strong></p>\n<h3><strong>        现有一个需求：</strong></h3>\n<p><strong>                </strong>将list集合中姓张的元素过滤到一个新的集合中</p>\n<p>                然后将过滤出来的姓张的元素中，再过滤出来长度为3的元素，存储到一个新的集合中</p>\n<p>                <strong>1.用常规方法解决需求</strong></p>\n<pre><code class=\"language-java\">        // 已知的知识来解决需求\n        List&lt;String&gt; list1 = new ArrayList&lt;&gt;();\n        list1.add(\"张老三\");\n        list1.add(\"张小三\");\n        list1.add(\"李四\");\n        list1.add(\"赵五\");\n        list1.add(\"张六\");\n        list1.add(\"王八\");\n\n        ArrayList&lt;String&gt; list2 = new ArrayList&lt;&gt;();\n        // 1.将list集合中姓张的元素过滤到一个新的集合中\n        for(String name : list1){\n            if(name.startsWith(\"张\")){\n                list2.add(name);\n            }\n        }\n        ArrayList list3 = new ArrayList();\n        for (String name : list2) {\n            if (name.length() == 3){\n                list3.add(name);\n            }\n        }\n        System.out.println(list3);\n\n        输出结果：\n            [张老三, 张小三]</code></pre>\n<p><strong>              2.用Stream流操作集合，获取流，过滤操作，打印输出</strong></p>\n<pre><code class=\"language-java\">list1.stream().filter((String name)-&gt;name.startsWith(\"张\")).filter((String name)-&gt;name.length()==3).forEach((String name)-&gt;{\n            System.out.println(\"符合条件的姓名：\" + name);\n        });</code></pre>\n<p>                ( 看不懂没关系，下面会讲到该方法，这里只是用来引入的）</p>\n<h1>二、Stream流的格式</h1>\n<pre><code class=\"language-java\">Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate);\n            -----&gt; 参数：public interface Predicate&lt;T&gt;  (函数式接口)\n                    ----&gt; 抽象方法：boolean test(T t);\n            -----&gt; 参数：public interface Consumer&lt;T&gt;  (函数式接口)\n                    ----&gt; 抽象方法：boolean test(T t);</code></pre>\n<p>     整体代码看来：流式思想 类似于 工厂车间的“流水线”</p>\n<p>                ( 看不懂没关系，下面会讲到该方法，这里只是用来引入的）</p>\n<p></p>\n<h1>三、获取流</h1>\n<p>        根据集合来获取：</p>\n<p>                根据Collection获取流：</p>\n<p>                        Collection接口中有一个stream()方法，可以获取流</p>\n<pre><code class=\"language-java\">        default Stream&lt;E&gt; stream()</code></pre>\n<p>                1.根据List获取流</p>\n<p>                2.根据Set获取流</p>\n<p>                3.根据Map获取流</p>\n<p>                        3.1根据Map集合的键来获取流</p>\n<p>                        3.2根据Map集合的值获取流</p>\n<p>                        3.3根据Map集合的键值对对象获取流</p>\n<p>                4.根据数组获取流</p>\n<h3>        代码演示：</h3>\n<p>                1.根据List集合获取流</p>\n<pre><code class=\"language-java\">        // 创建List集合\n        List&lt;String&gt; list = new ArrayList&lt;&gt;();\n        list.add(\"张老三\");\n        list.add(\"张小三\");\n        list.add(\"李四\");\n        list.add(\"赵五\");\n        list.add(\"张六\");\n        list.add(\"王八\");\n        Stream&lt;String&gt; stream1 = list.stream();</code></pre>\n<p>                2.根据Set集合获取流</p>\n<pre><code class=\"language-java\">        // 创建List集合\n        Set&lt;String&gt; set = new HashSet&lt;&gt;();\n        list.add(\"张老三\");\n        list.add(\"张小三\");\n        list.add(\"李四\");\n        list.add(\"赵五\");\n        list.add(\"张六\");\n        list.add(\"王八\");\n        Stream&lt;String&gt; stream2 = set.stream();</code></pre>\n<p>                3.根据Map集合获取流</p>\n<pre><code class=\"language-java\">        // 创建Map集合\n        Map&lt;Integer,String&gt; map = new HashMap&lt;&gt;();\n        map.put(1,\"张老三\");\n        map.put(2,\"张小三\");\n        map.put(3,\"李四\");\n        map.put(4,\"赵五\");\n        map.put(5,\"张六\");\n        map.put(6,\"王八\");\n\n        // 3.1根据Map集合的键获取流\n        Set&lt;Integer&gt; map1 = map.keySet();\n        Stream&lt;Integer&gt; stream3 = map1.stream();\n        // 3.2根据Map集合的值获取流\n        Collection&lt;String&gt; map2 = map.values();\n        Stream&lt;String&gt; stream4 = map2.stream();\n        // 3.3根据Map集合的键值对对象获取瑞\n        Set&lt;Map.Entry&lt;Integer, String&gt;&gt; map3 = map.entrySet();\n        Stream&lt;Map.Entry&lt;Integer, String&gt;&gt; stream5 = map3.stream();</code></pre>\n<p>                4.根据数组获取流</p>\n<pre><code class=\"language-java\">        // 根据数组获取流\n        String[] arr = {\"张颜宇\",\"张三\",\"李四\",\"赵五\",\"刘六\",\"王七\"};\n        Stream&lt;String&gt; stream6 = Stream.of(arr);</code></pre>\n<p>        </p>\n<h1>四、Stream流的常用方法</h1>\n<p>        Stream流的常用方法：</p>\n<p>                终结方法：返回值类型不再是Stream接口本身类型的方法，例如：forEach方法和count方法</p>\n<p>                非终结方法/延迟方法：返回值类型仍然是Stream接口自身类型的方法，除了终结方法都是延迟方法。例如：filter,limit,skip,map,conat</p>\n<table align=\"center\" border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px;\"><tbody><tr><td style=\"background-color:#aaaaaa;text-align:center;vertical-align:middle;\">方法名称</td><td style=\"background-color:#aaaaaa;text-align:center;vertical-align:middle;\">方法作用</td><td style=\"background-color:#aaaaaa;text-align:center;vertical-align:middle;\">方法种类</td><td style=\"background-color:#aaaaaa;text-align:center;vertical-align:middle;\">是否支持链式调用</td></tr><tr><td style=\"background-color:#ffffff;text-align:center;vertical-align:middle;\">count</td><td style=\"background-color:#ffffff;text-align:center;vertical-align:middle;\">统计个数</td><td style=\"background-color:#ffffff;text-align:center;vertical-align:middle;\">终结方法</td><td style=\"background-color:#ffffff;text-align:center;vertical-align:middle;\">否</td></tr><tr><td style=\"background-color:#ffffff;text-align:center;vertical-align:middle;\">forEach</td><td style=\"background-color:#ffffff;text-align:center;vertical-align:middle;\">逐一处理</td><td style=\"background-color:#ffffff;text-align:center;vertical-align:middle;\">终结方法</td><td style=\"background-color:#ffffff;text-align:center;vertical-align:middle;\">否</td></tr><tr><td style=\"background-color:#eeeeee;text-align:center;vertical-align:middle;\">filter</td><td style=\"background-color:#eeeeee;text-align:center;vertical-align:middle;\">过滤</td><td style=\"background-color:#eeeeee;text-align:center;vertical-align:middle;\">函数拼接</td><td style=\"background-color:#eeeeee;text-align:center;vertical-align:middle;\">是</td></tr><tr><td style=\"background-color:#eeeeee;text-align:center;vertical-align:middle;\">limit</td><td style=\"background-color:#eeeeee;text-align:center;vertical-align:middle;\">取用前几个</td><td style=\"background-color:#eeeeee;text-align:center;vertical-align:middle;\">函数拼接</td><td style=\"background-color:#eeeeee;text-align:center;vertical-align:middle;\">是</td></tr><tr><td style=\"background-color:#eeeeee;text-align:center;vertical-align:middle;\">skip</td><td style=\"background-color:#eeeeee;text-align:center;vertical-align:middle;\">跳过前几个</td><td style=\"background-color:#eeeeee;text-align:center;vertical-align:middle;\">函数拼接</td><td style=\"background-color:#eeeeee;text-align:center;vertical-align:middle;\">是</td></tr><tr><td style=\"background-color:#eeeeee;text-align:center;vertical-align:middle;\">map</td><td style=\"background-color:#eeeeee;text-align:center;vertical-align:middle;\">映射</td><td style=\"background-color:#eeeeee;text-align:center;vertical-align:middle;\">函数拼接</td><td style=\"background-color:#eeeeee;text-align:center;vertical-align:middle;\">是</td></tr><tr><td style=\"background-color:#eeeeee;text-align:center;vertical-align:middle;\">concat</td><td style=\"background-color:#eeeeee;text-align:center;vertical-align:middle;\">组合</td><td style=\"background-color:#eeeeee;text-align:center;vertical-align:middle;\">函数拼接</td><td style=\"background-color:#eeeeee;text-align:center;vertical-align:middle;\">是</td></tr></tbody></table>\n<h2>        方法演示：</h2>\n<h3>                1.count方法：</h3>\n<p>                        long count (); 统计流中的元素，返回long类型数据</p>\n<pre><code class=\"language-java\">        List&lt;String&gt; list = new ArrayList&lt;&gt;();\n        list.add(\"张老三\");\n        list.add(\"张小三\");\n        list.add(\"李四\");\n        list.add(\"赵五\");\n        list.add(\"张六\");\n        list.add(\"王八\");\n\n        long count = list.stream().count();\n        System.out.println(\"集合中的元素个数是：\" + count);\n\n        输出结果：\n            集合中的元素个数是：6</code></pre>\n<h3>                2.filter方法：</h3>\n<p>                        Stream&lt;T&gt; filter(Predicate&lt;? super ?&gt; predicate); 过滤出满足条件的元素</p>\n<p>                                参数Predicate：函数式接口，抽象方法：boolean test （T  t)</p>\n<p>                                Predicate接口：是一个判断接口</p>\n<pre><code class=\"language-java\">        // 获取stream流\n        Stream&lt;String&gt; stream = Stream.of(\"张老三\", \"张小三\", \"李四\", \"赵五\", \"刘六\", \"王七\");\n        // 需求：过去出姓张的元素\n        stream.filter((String name)-&gt;{\n            return name.startsWith(\"张\");\n        }).forEach((String name)-&gt;{\n            System.out.println(\"流中的元素\" + name);\n        });</code></pre>\n<p>                        (上面引入Stream流时，就用到了这个方法）</p>\n<h3>                3.forEach方法</h3>\n<p>                       void forEach(Consumer&lt;? super T&gt; action)：逐一处理流中的元素<br/>             参数 Consumer&lt;? super T&gt; action：函数式接口，只有一个抽象方法：void accept（T t)；</p>\n<p>                        注意：</p>\n<p>                                1.此方法并不保证元素的逐一消费动作在流中是有序进行的（元素可能丢失）</p>\n<p>                                2.Consumer是一个消费接口（可以获取流中的元素进行遍历操作，输出出去），可以使用Lambda表达式</p>\n<pre><code class=\"language-java\">        List&lt;String&gt; list = new ArrayList&lt;&gt;();\n        list.add(\"张老三\");\n        list.add(\"张小三\");\n        list.add(\"李四\");\n        list.add(\"赵五\");\n        list.add(\"张六\");\n        list.add(\"王八\");\n\n        // 函数模型：获取流 --&gt; 注意消费流中的元素\n        list.stream().forEach((String name)-&gt;{\n            System.out.println(name);\n        });\n\n        输出结果：\n            张老三\n            张小三\n            李四\n            赵五\n            张六\n            王八</code></pre>\n<h3>                4.limit方法</h3>\n<p>                        Stream&lt;T&gt; limit(long maxSize);   取用前几个元素</p>\n<p>                        注意：</p>\n<p>                                参数是一个long 类型，如果流的长度大于参数，则进行截取；否则不进行操作</p>\n<pre><code class=\"language-java\">        // 获取流的长度\n        Stream&lt;String&gt; stream1 = Stream.of(\"张老三\", \"张小三\", \"李四\", \"赵五\", \"刘六\", \"王七\");\n        // 需求：保留前三个元素\n        stream1.limit(3).forEach((String name)-&gt;{\n            System.out.println(\"流中的前三个元素是：\" + name);\n        });\n\n        输出结果：\n            流中的前三个元素是：张老三\n            流中的前三个元素是：张小三\n            流中的前三个元素是：李四</code></pre>\n<h3>                5.map方法</h3>\n<p>                        &lt;r&gt; Stream &lt;R&gt; map(Function&lt;? super T,? exception R&gt; mapper;<br/>                             参数Function&lt;T,R&gt;：函数式接口，抽象方法：R apply(T t);<br/>                                 Function&lt;T,R&gt;：其实就是一个类型转换接口（T和R的类型可以一致，也可以不一致）</p>\n<pre><code class=\"language-java\">        // 获取Stream流\n        Stream&lt;String&gt; stream1 = Stream.of(\"11\",\"22\",\"33\",\"44\",\"55\");\n        // 需求：把stream1流中的元素转换为int类型\n        stream1.map((String s)-&gt;{\n           return Integer.parseInt(s); // 将String类型的s进行转换为Integer类型的元素，并返回\n        }).forEach((Integer i)-&gt;{\n            System.out.println(i);  // 将转换后的int类型的元素逐一输出\n        });\n\n        输出结果：\n            11\n            22\n            33\n            44\n            55\n</code></pre>\n<h3>                6.skip方法</h3>\n<p>                    Stream&lt;T&gt; skip(long n);     跳过前几个元素<br/>                     注意：<br/>                         如果流的当前长度大于n，则跳过前n个，否则将会得到一个长度为0的空流</p>\n<pre><code class=\"language-java\">        // 获取stream流\n        Stream&lt;String&gt; stream = Stream.of(\"张老三\", \"张小三\", \"李四\", \"赵五\", \"刘六\", \"王七\");\n\n        stream.skip(3).forEach((String name)-&gt;{\n            System.out.println(\"跳过前三个，打印剩下的\" + name);\n        });\n\n        输出结果：\n            跳过前三个，打印剩下的赵五\n            跳过前三个，打印剩下的刘六\n            跳过前三个，打印剩下的王七\n</code></pre>\n<h3>                7.concat方法</h3>\n<p>    public static &lt;T&gt; Stream&lt;T&gt; concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)<br/>             --&gt; 合并两个流</p>\n<pre><code class=\"language-java\">         Stream&lt;String&gt; stream1 = Stream.of(\"11\",\"22\",\"33\",\"44\",\"55\");\n        Stream&lt;String&gt; stream2 = Stream.of(\"张颜宇\", \"张三\", \"李四\", \"赵五\", \"刘六\", \"王七\");\n\n        // 需求：合并两个流\n        Stream&lt;String&gt; stream = Stream.concat(stream1,stream2);\n        stream.forEach((String name)-&gt;{\n            System.out.print(name);\n        });\n\n        输出结果：\n            1122334455张颜宇张三李四赵五刘六王七</code></pre>\n<h1>五、收集Stream流</h1>\n<p>        Stream流中提供了一个方法，可以把流中的数据收集到单例集合中</p>\n<p>                &lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector);     把流中的数据手机到单列集合中<br/>                     返回值类型是R。R指定为什么类型，就是手机到什么类型的集合<br/>                     参数Collector&lt;? super T, A, R&gt;中的R类型，决定把流中的元素收集到哪个集合中<br/>                     参数Collector如何得到 ？，可以使用 java.util.stream.Collectors工具类中的静态方法：<br/>                         - public static &lt;T&gt; Collector&lt;T, ?, List&lt;T&gt;&gt; toList()：转换为List集合<br/>                         - public static &lt;T&gt; Collector&lt;T, ?, Set&lt;T&gt;&gt; toSet() ：转换为Set集合</p>\n<pre><code class=\"language-java\">        List&lt;String&gt; list2 = new ArrayList&lt;&gt;();\n        list2.add(\"张老三\");\n        list2.add(\"张小三\");\n        list2.add(\"李四\");\n        list2.add(\"赵五\");\n        list2.add(\"张六\");\n        list2.add(\"王八\");\n\n        // 需求：过滤出姓张的并且长度为3的元素\n        Stream&lt;String&gt; stream = list2.stream().filter((String name) -&gt; {\n            return name.startsWith(\"张\");\n        }).filter((String name) -&gt; {\n            return name.length() == 3;\n        });\n\n        // stream 收集到单列集合中\n        List&lt;String&gt; list = stream.collect(Collectors.toList());\n        System.out.println(list);\n\n        // stream 手机到单列集合中\n        Set&lt;String&gt; set = stream.collect(Collectors.toSet());\n        System.out.println(set);</code></pre>\n<p>                        </p>\n</div>\n</div>"}