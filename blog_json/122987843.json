{"blogid": "122987843", "writerAge": "码龄2年", "writerBlogNum": "144", "writerCollect": "10701", "writerComment": "10249", "writerFan": "34487", "writerGrade": "7级", "writerIntegral": "22443", "writerName": "Developer 小马", "writerProfileAdress": "writer_image\\profile_122987843.jpg", "writerRankTotal": "321", "writerRankWeekly": "8", "writerThumb": "7539", "writerVisitNum": "5170207", "blog_read_count": "53163", "blog_time": "已于 2022-03-31 14:47:15 修改", "blog_title": "H5画布 canvas（一）canvas简介、绘制圆形/矩形、案例饼状图绘制", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"main-toc-toc\" style=\"margin-left:40px;\"><a href=\"#main-toc\">1. canvas 简介</a></p>\n<p id=\"1.%20canvas%20%E6%A0%87%E7%AD%BE%E4%BB%8B%E7%BB%8D-toc\" style=\"margin-left:40px;\"><a href=\"#1.%20canvas%20%E6%A0%87%E7%AD%BE%E4%BB%8B%E7%BB%8D\">2. canvas 标签介绍</a></p>\n<p id=\"2.%20canvas%20%E4%B8%8A%E4%B8%8B%E6%96%87%20Context-toc\" style=\"margin-left:40px;\"><a href=\"#2.%20canvas%20%E4%B8%8A%E4%B8%8B%E6%96%87%20Context\">3. canvas 上下文 Context</a></p>\n<p id=\"3.%20%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%9C%A8%20canvas%20%E7%94%BB%E5%B8%83%E4%B8%AD%E7%BB%98%E5%88%B6%E8%A1%A8%E6%A0%BC-toc\" style=\"margin-left:40px;\"><a href=\"#3.%20%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%9C%A8%20canvas%20%E7%94%BB%E5%B8%83%E4%B8%AD%E7%BB%98%E5%88%B6%E8%A1%A8%E6%A0%BC\">4. 案例：在 canvas 画布中绘制表格</a></p>\n<p id=\"4.%20canvas%20%E7%9A%84%20beginPath%20%E7%8A%B6%E6%80%81-toc\" style=\"margin-left:40px;\"><a href=\"#4.%20canvas%20%E7%9A%84%20beginPath%20%E7%8A%B6%E6%80%81\">5. canvas 的 beginPath 状态</a></p>\n<p id=\"6.%20%E7%BB%98%E5%88%B6%E7%9F%A9%E5%BD%A2%20rect-toc\" style=\"margin-left:40px;\"><a href=\"#6.%20%E7%BB%98%E5%88%B6%E7%9F%A9%E5%BD%A2%20rect\">6. 绘制矩形 rect</a></p>\n<p id=\"7.%20%E7%BB%98%E5%88%B6%E5%9C%86%E5%BD%A2%20arc-toc\" style=\"margin-left:40px;\"><a href=\"#7.%20%E7%BB%98%E5%88%B6%E5%9C%86%E5%BD%A2%20arc\">7. 绘制圆形 arc</a></p>\n<p id=\"8.%20%E6%A1%88%E4%BE%8B%EF%BC%9A%E6%A0%B9%E6%8D%AE%E4%B8%80%E7%BB%84%E6%95%B0%E6%8D%AE%E7%BB%98%E5%88%B6%E9%A5%BC%E7%8A%B6%E5%9B%BE-toc\" style=\"margin-left:40px;\"><a href=\"#8.%20%E6%A1%88%E4%BE%8B%EF%BC%9A%E6%A0%B9%E6%8D%AE%E4%B8%80%E7%BB%84%E6%95%B0%E6%8D%AE%E7%BB%98%E5%88%B6%E9%A5%BC%E7%8A%B6%E5%9B%BE\">8. 案例：根据一组数据绘制饼状图</a></p>\n<hr id=\"hr-toc\"/>\n<h2>1. canvas 简介</h2>\n<p>        canvas 是HTML5 提供的一种新标签 <span style=\"color:#fe2c24;\"><strong>&lt;canvas&gt;&lt;/canvas&gt;</strong></span>，与 div 类似，是一个矩形的画布，它可以支持 JavaScript 在上面绘画，控制每一个像素；canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法，可以使得页面更加丰富多彩。当前 canvas 广泛应用于游戏、可视化数据(echarts)、广告等领域。</p>\n<h2 id=\"1.%20canvas%20%E6%A0%87%E7%AD%BE%E4%BB%8B%E7%BB%8D\">2. canvas 标签介绍</h2>\n<p>        canvas 其实就是一个普通的 HTML 标签，需要进行闭合，可以设置宽高、背景色属性，但宽高单位必须是 px，否则就会被忽略；一个 canvas 默认为 300*150 像素。</p>\n<p>        需要注意 canvas 元素的宽高必须使用它自带的属性进行设置，而<span style=\"color:#fe2c24;\">不要用 CSS 选择器控制 canvas 的宽高</span>，否则会造成图像拉伸，除宽高之外的其余属性则可用 CSS。如下简单案例：</p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n\n&lt;head&gt;\n  &lt;meta charset=\"UTF-8\"&gt;\n  &lt;title&gt;canvas标签&lt;/title&gt;\n  &lt;style&gt;\n    #can1 {\n      background-color: cadetblue;\n      border: 2px solid red;\n    }\n  &lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n  &lt;!-- 设置宽高使用canvas标签的属性 --&gt;\n  &lt;canvas id=\"can1\" width=\"300px\" height=\"150px\"&gt;&lt;/canvas&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;</code></pre>\n<p>效果如下：</p>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"252\" src=\"image\\aa18d5dde6234d9b9d0ea3e089195cae.png\" width=\"630\"/></p>\n<h2 id=\"2.%20canvas%20%E4%B8%8A%E4%B8%8B%E6%96%87%20Context\">3. canvas 上下文 Context</h2>\n<p>        <span style=\"color:#fe2c24;\"><strong>Context</strong></span> 是 canvas 的上下文，也就是绘制环境，它是所有绘制操作 api 的入口或者集合；canvas 本身是无法绘制任何内容的，需要使用 JavaScript 进行操作。而 <span style=\"color:#fe2c24;\">Context 正是 JavaScript 操作 canvas 的接口</span>。</p>\n<p>获取上下文分为两步：首先获取 canvas 标签，然后再获取该标签的上下文；</p>\n<pre><code class=\"language-html\">&lt;script&gt;\n  // 1.DOM操作获取canvas标签\n  var canvas = document.getElementById('can1');\n  // 2.获取canvas的上下文（2d渲染）\n  var ctx = canvas.getContext('2d');\n&lt;/script&gt;</code></pre>\n<p>获取 canvas 上下文之后，就可以在画布上进行图形绘制了；上下文 Context 相关属性如下：</p>\n<blockquote>\n<p><span style=\"color:#fe2c24;\"><em>（ctx 是博主定义的获取到的上下文 Context 的变量名，可以随意更换，以下介绍都用ctx）</em></span></p>\n<ul><li> <p><strong>ctx.moveTo(x,y)；</strong>将画笔移动到坐标(x,y)位置</p> </li><li> <p><strong>ctx.lineTo(x,y)；</strong>从当前位置绘制直线到坐标(x,y)位置</p> </li><li> <p><strong>ctx.closePath()；</strong>关闭路径，闭合线条</p> </li><li> <p><strong>ctx.lineWidth；</strong>线宽</p> </li><li> <p><strong>ctx.strokeStyle；</strong>描边颜色，必须用于描边之前</p> </li><li> <p><strong>ctx.stroke()；</strong>渲染直线，相当于描边</p> </li><li> <p><strong>ctx.fillStyle；</strong>填充颜色，必须用于填充之前</p> </li><li> <p><strong>ctx.fill()；</strong>填充，默认为黑色</p> </li></ul>\n</blockquote>\n<p>接下来我们结合这些属性绘制一个简单的正方形：</p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n\n&lt;head&gt;\n  &lt;meta charset=\"UTF-8\"&gt;\n  &lt;title&gt;canvas标签&lt;/title&gt;\n  &lt;style&gt;\n    #can1 {\n      background-color: rgb(204, 216, 216);\n      border: 2px solid red;\n    }\n  &lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n  &lt;!-- 设置宽高使用canvas标签的属性 --&gt;\n  &lt;canvas id=\"can1\" width=\"600px\" height=\"500px\"&gt;&lt;/canvas&gt;\n&lt;/body&gt;\n\n&lt;script&gt;\n  // DOM操作获取canvas标签\n  var canvas = document.getElementById('can1');\n  // 获取canvas的上下文（2d渲染）\n  var ctx = canvas.getContext('2d');\n  // 绘制长方形\n  ctx.moveTo(100, 100); //将画笔移动到坐标 100 100\n  ctx.lineTo(200, 100); //从画笔位置绘制直线到坐标 200 100\n  ctx.lineTo(200, 200); //从当前位置绘制直线到 200 200\n  ctx.lineTo(100, 200); //.从当前位置...\n  ctx.closePath(); //闭合线条\n\n  ctx.lineWidth = 6; //线宽\n\n  ctx.strokeStyle = 'red'; //描边颜色\n  ctx.stroke(); //渲染直线(描边)\n\n  ctx.fillStyle = 'blue'; //填充颜色\n  ctx.fill(); //填充\n&lt;/script&gt;\n\n&lt;/html&gt;</code></pre>\n<p>效果如下：</p>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"563\" src=\"image\\95ff9d185c4e4fbd9713fcc33d46de51.png\" width=\"1010\"/></p>\n<h2 id=\"3.%20%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%9C%A8%20canvas%20%E7%94%BB%E5%B8%83%E4%B8%AD%E7%BB%98%E5%88%B6%E8%A1%A8%E6%A0%BC\">4. 案例：在 canvas 画布中绘制表格</h2>\n<pre><code class=\"language-javascript\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n\n&lt;head&gt;\n  &lt;meta charset=\"UTF-8\"&gt;\n  &lt;title&gt;案例：绘制表格&lt;/title&gt;\n  &lt;style&gt;&lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n  &lt;div&gt;\n    &lt;canvas id=\"table\"&gt;&lt;/canvas&gt;\n  &lt;/div&gt;\n&lt;/body&gt;\n&lt;script&gt;\n  (function () {\n    var canvas = document.getElementById('table'); //获取canvas标签\n    var ctx = canvas.getContext('2d'); //获取上下文\n\n    //设置画布宽高、边框（边框也可使用CSS选择器来设定）\n    canvas.width = 600;\n    canvas.height = 400;\n    canvas.style.border = '2px solid #000';\n    //设置上下文样式\n    ctx.lineWidth = .5;\n    ctx.strokeStyle = '#999';\n\n    //绘制表格\n    var rect_hei = 20; //定义每一行高20px\n    var rect_wit = 40; //定义每一列宽40px\n\n    for (var i = 0; i &lt; canvas.width / rect_hei; i++) { //循环绘制\n      //绘制横线\n      ctx.moveTo(0, i * rect_hei); //从x轴为0的位置开始，每隔一个行高便绘制横线\n      ctx.lineTo(canvas.width, i * rect_hei);\n      ctx.stroke();\n\n      //绘制竖线\n      ctx.moveTo(i * rect_wit, 0); //从y轴为0的位置开始，每隔一个列宽便绘制竖线\n      ctx.lineTo(i * rect_wit, canvas.height);\n      ctx.stroke();\n    }\n  }())\n&lt;/script&gt;\n\n&lt;/html&gt;</code></pre>\n<p>效果如下：</p>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"460\" src=\"image\\bbe4bb4c01344e1bbe1df616c21360e2.png\" width=\"780\"/></p>\n<h2 id=\"4.%20canvas%20%E7%9A%84%20beginPath%20%E7%8A%B6%E6%80%81\">5. canvas 的 beginPath 状态</h2>\n<p>        需要知道，在 canvas 画布中绘制图形是<span style=\"color:#fe2c24;\">基于状态</span>的，意思就是说如果前面已经设置了描边颜色属性 strokeStyle 为某个颜色，那么在这之后的绘制当中，所有线条都会是这个颜色；如果再次设置描边颜色，则所有线条都会成为最新设置的颜色，前面设置的都被覆盖，无法做到颜色不一。如下：</p>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"723\" src=\"image\\80c438cb3c7849b7baa8f3d7045cd2d3.png\" width=\"1200\"/></p>\n<p>而这个时候，为了能够绘制出不同颜色的线条，就需要使用到 beginPath 开启新状态；</p>\n<blockquote>\n<ul><li><strong>ctx.beginPath()；</strong>开启新状态的绘图，前面的设置不会被覆盖；<span style=\"color:#fe2c24;\">新状态可以继承之前状态的样式，但是<strong>在新状态中设置的样式就只能作用在新状态当中</strong>。</span></li></ul>\n</blockquote>\n<p>如下案例：</p>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"719\" src=\"image\\054d7f17e87b494a9abfaa823092a3a4.png\" width=\"1200\"/></p>\n<h2 id=\"6.%20%E7%BB%98%E5%88%B6%E7%9F%A9%E5%BD%A2%20rect\">6. 绘制矩形 rect</h2>\n<p>        如果只是按照步骤：起点 --&gt; 画线 --&gt; 描边 一步一步的绘制一个矩形的话，就太麻烦了，canvas 也提供了一种快速绘制矩形的方法 rect，并且提供了各种属性。语法如下：</p>\n<blockquote>\n<ul><li><strong>ctx.rect(x, y, width, height)；</strong>x, y为矩形左上角坐标， width 和 height 以像素 px 为单位，该语法只规定了矩形的路径，没有填充和描边。</li><li><strong>ctx.strokeRect(x, y, width, height)；</strong>描边矩形，结合绘制与描边。</li><li><strong>ctx.fillRect(x, y, width, height)；</strong>填充矩形，结合绘制与填充</li><li><strong>ctx.clearRect(x, y, width, height)；</strong>清除矩形，相当于橡皮擦，在该矩形范围内的图像都会被擦除。</li></ul>\n</blockquote>\n<p>我们使用 rect 语法绘制一个矩形，只需一句代码即可：</p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n\n&lt;head&gt;\n  &lt;meta charset=\"UTF-8\"&gt;\n  &lt;title&gt;绘制矩形&lt;/title&gt;\n  &lt;style&gt;&lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n  &lt;div&gt;\n    &lt;canvas id=\"table\"&gt;&lt;/canvas&gt;\n  &lt;/div&gt;\n&lt;/body&gt;\n&lt;script&gt;\n  var canvas = document.getElementById('table'); //获取canvas标签\n  var ctx = canvas.getContext('2d'); //获取上下文\n\n  //设置画布宽高、边框（边框也可使用CSS选择器来设定）\n  canvas.width = 600;\n  canvas.height = 400;\n  canvas.style.border = '2px solid #000';\n\n  //快速绘制矩形\n  ctx.rect(100, 100, 50, 50);\n  ctx.stroke();\n\n  //描边矩形\n  ctx.strokeRect(200, 100, 50, 50);\n\n  //填充矩形\n  ctx.fillRect(300, 100, 50, 50);\n&lt;/script&gt;\n\n&lt;/html&gt;</code></pre>\n<p>效果如下：</p>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"460\" src=\"image\\ea6ce80158a748c6b4581476fc952300.png\" width=\"736\"/></p>\n<h2 id=\"7.%20%E7%BB%98%E5%88%B6%E5%9C%86%E5%BD%A2%20arc\">7. 绘制圆形 arc</h2>\n<blockquote>\n<ul><li><strong>ctx.arc(x,y,r,sAngle,eAngle,counterclockwise)；</strong>x、y 为圆心点坐标；r 半径；sAngle 开始角度，圆心到最右边点为 0 度，顺时针方向依次增大；eAngle 结束角度，注意用的是弧度 Π(180°)；counterclockwise：是否是逆时针，true 是逆时针，false 顺时针。</li></ul>\n</blockquote>\n<p>接下来，我们使用 arc 绘制一个圆弧，效果如下：</p>\n<p><em>（提示：弧度与角度的转换公式，<span style=\"color:#fe2c24;\"><strong><span style=\"background-color:#ffd900;\">角度 = 度数 * Math.PI / 180</span></strong></span>）</em></p>\n<p><img alt=\"\" height=\"720\" src=\"image\\8a82de62e3954f82a709b83252272915.png\" width=\"1200\"/></p>\n<h2 id=\"8.%20%E6%A1%88%E4%BE%8B%EF%BC%9A%E6%A0%B9%E6%8D%AE%E4%B8%80%E7%BB%84%E6%95%B0%E6%8D%AE%E7%BB%98%E5%88%B6%E9%A5%BC%E7%8A%B6%E5%9B%BE\">8. 案例：根据一组数据绘制饼状图</h2>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n\n&lt;head&gt;\n  &lt;meta charset=\"UTF-8\"&gt;\n  &lt;title&gt;绘制饼状图&lt;/title&gt;\n  &lt;style&gt;&lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n  &lt;div&gt;\n    &lt;canvas id=\"table\"&gt;&lt;/canvas&gt;\n  &lt;/div&gt;\n&lt;/body&gt;\n&lt;script&gt;\n  var canvas = document.getElementById('table'); //获取canvas标签\n  var ctx = canvas.getContext('2d'); //获取上下文\n\n  //设置画布宽高、边框（边框也可使用CSS选择器来设定）\n  canvas.width = 600;\n  canvas.height = 400;\n  canvas.style.border = '2px solid #000';\n\n  //定义饼状图数据\n  var data = [{\n      'value': 0.2,\n      'color': '#149985',\n      'title': '城市A'\n    },\n    {\n      'value': 0.3,\n      'color': 'red',\n      'title': '城市B'\n    },\n    {\n      'value': 0.4,\n      'color': 'blue',\n      'title': '城市C'\n    },\n    {\n      'value': 0.1,\n      'color': '#999999',\n      'title': '城市D'\n    },\n  ]\n\n  //绘制饼状图\n  var tempAngle = -90; //从-90°开始绘制\n  for (var i = 0; i &lt; data.length; i++) {\n    ctx.beginPath(); //每一次循环都绘制不同的扇区，所以都要开启新状态\n    ctx.moveTo(200, 200); //每一次都回到圆心点开始绘制\n    var angle = data[i].value * 360; //每一个扇区的角度\n    ctx.fillStyle = data[i].color; //颜色填充按照数据遍历\n    var startAngle = tempAngle * Math.PI / 180; //起始角度\n    var endAngle = (tempAngle + angle) * Math.PI / 180; //每一次的结束角度=起始角度+扇区角度\n    ctx.arc(200, 200, 100, startAngle, endAngle);\n    tempAngle = tempAngle + angle; //每次绘制完一次扇区起始角度为原角度加该扇区角度\n    ctx.fill();\n  }\n&lt;/script&gt;\n\n&lt;/html&gt;</code></pre>\n<p>案例效果如下：</p>\n<p><img alt=\"\" height=\"477\" src=\"image\\6aedd60e082a4a61894b06b8fc61327a.png\" width=\"846\"/></p>\n<p><em>饼状图文字的绘制等参见下期：</em><a href=\"https://blog.csdn.net/weixin_53072519/article/details/123044190\" title=\"H5画布 canvas 入门到精通 _ 第二部分\">H5画布 canvas 入门到精通 _ 第二部分</a></p>\n<hr/>\n<p><strong>小结：canvas 绘制基本步骤</strong></p>\n<ul><li>获得上下文：canvas.getContext('2d')</li><li>开始新状态绘制：ctx.beginPath()</li><li>画笔起始点：ctx.moveTo(x, y)</li><li>绘制线：ctx.lineTo(x, y)</li><li>闭合路径：ctx.closePath()</li><li>描边：ctx.stroke()</li></ul>\n<hr/>\n<p>三篇文章速通 canvas：</p>\n<p>➡️ <a href=\"https://blog.csdn.net/weixin_53072519/article/details/122987843\" title=\"第一部分：canvas介绍，绘制圆形、矩形；\">第一部分：canvas介绍，绘制圆形、矩形；</a><br/> ➡️ <a href=\"https://blog.csdn.net/weixin_53072519/article/details/123044190\" title=\"第二部分：绘制文字、图片、坐标系，canva颜色和样式，绘制环境；\">第二部分：绘制文字、图片、坐标系，canva颜色和样式，绘制环境；</a><br/> ➡️ <a href=\"https://blog.csdn.net/weixin_53072519/article/details/123073115\" title=\"第三部分：canvas库Konva.js的使用。\">第三部分：canvas库Konva.js的使用。</a></p>\n</div>\n</div>"}