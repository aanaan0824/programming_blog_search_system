{"blogid": "126238782", "writerAge": "码龄2年", "writerBlogNum": "63", "writerCollect": "864", "writerComment": "972", "writerFan": "1315", "writerGrade": "5级", "writerIntegral": "2904", "writerName": "贤蛋大眼萌", "writerProfileAdress": "writer_image\\profile_126238782.jpg", "writerRankTotal": "6654", "writerRankWeekly": "92", "writerThumb": "703", "writerVisitNum": "34309", "blog_read_count": "818", "blog_time": "于 2022-08-09 00:04:45 发布", "blog_title": "【Vue全家桶】Vue-Router (详解)", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-tomorrow-night\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p></p>\n<div class=\"toc\">\n<h3>Vue-Router</h3>\n<ul><li><ul><li><a href=\"#__2\">🔨 前端路由的发展历程</a></li><li><ul><li><a href=\"#1__10\">1. 后端路由阶段</a></li><li><a href=\"#2__22\">2. 前后端分离</a></li></ul>\n</li><li><a href=\"#__vuerouter_38\">🔧 认识 vue-router</a></li><li><a href=\"#_routerlink_90\">🎈 router-link（补充）</a></li><li><a href=\"#__101\">🔑 路由懒加载</a></li><li><a href=\"#__111\">🔦 动态路由</a></li><li><ul><li><a href=\"#1__113\">1. 动态路由的基本匹配</a></li><li><a href=\"#2__125\">2. 获取动态路由的值</a></li><li><a href=\"#3_NotFound_134\">3. NotFound</a></li></ul>\n</li><li><a href=\"#__142\">🪒 路由的嵌套</a></li><li><a href=\"#__167\">🧷 编程式导航</a></li><li><ul><li><a href=\"#1__169\">1. 代码的页面跳转</a></li><li><a href=\"#2_query__179\">2. query 方式的参数</a></li><li><a href=\"#3__185\">3. 替换当前的位置</a></li><li><a href=\"#4__189\">4. 页面的前后跳转</a></li></ul>\n</li><li><a href=\"#__195\">🔍 动态添加路由</a></li><li><a href=\"#__217\">🎉 路由导航守卫</a></li><li><ul><li><a href=\"#1__234\">1. 登录守卫功能</a></li><li><a href=\"#2__242\">2. 其他导航守卫</a></li></ul>\n</li></ul>\n</li></ul>\n</div>\n<p></p>\n<h2><a id=\"__2\"></a>🔨 前端路由的发展历程</h2>\n<p>路由的概念在软件工程中出现，最早是在后端路由中实现的，原因是web的发展主要经历了这样一些阶段：</p>\n<ul><li>后端路由阶段；</li><li>前后端分离阶段；</li><li>单页面富应用（SPA）；</li></ul>\n<h3><a id=\"1__10\"></a>1. 后端路由阶段</h3>\n<p>​ 早起的网站开发整个HTML页面是由<mark>服务器来渲染</mark> 的，即服务器直接生产渲染好对应的HTML页面, 返回给客户端进行展示。如图：</p>\n<img alt=\"image-20220806105423480\" src=\"image\\image-20220806105423480.png\"/>\n<p>优点：利于SEO优化</p>\n<p>缺点：整个页面由后端人员维护，HTMl代码以及数据对应逻辑会混合一起，编写和维护十分糟糕。</p>\n<h3><a id=\"2__22\"></a>2. 前后端分离</h3>\n<p>​ **前端渲染：**每次请求涉及到的静态资源都会从静态资源服务器获取，这些资源包括HTML+CSS+JS，然后在前端对这些请求回来的资源进行渲染。客户端的每一次请求，都会从静态资源服务器请求文件，这个时候的后端就只是<mark>负责提供API</mark>了。</p>\n<p>​ <strong>前后端分离：</strong></p>\n<ul><li>后端只负责提供API，前端通过Ajax 获取数据后通过JavaScript将数据渲染到页面</li><li>后端专注于数据，前端专注于交互和可视化</li></ul>\n<p><strong>单页面(SPA)富应用阶段：</strong></p>\n<ul><li>在前后端分离的基础上加了一层前端路由，<mark>前端来维护一套路由规则</mark></li><li>核心：改变页面URL，但不进行页面刷新。</li></ul>\n<h2><a id=\"__vuerouter_38\"></a>🔧 认识 vue-router</h2>\n<p>安装 Vue-Router</p>\n<pre><code class=\"prism language-shell\"><span class=\"token function\">npm</span> <span class=\"token function\">install</span> vue-router\n</code></pre>\n<p>步骤：</p>\n<ol><li>创建路由需要映射的组件</li><li>通过createRouter创建路由对象，并且传入<mark>routes和history模式</mark></li><li>使用app注册路由对象（use方法）</li><li>路由使用: 通过和和</li></ol>\n<p><img alt=\"image-20220807164035043\" src=\"image\\2fc4cbcc45c7de1e5fae232f25ad725f.png\"/></p>\n<p><img alt=\"image-20220807164253499\" src=\"image\\e8bf24b350a616e13d728150035770fb.png\"/></p>\n<pre><code class=\"prism language-js\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{<!-- --></span> createRouter<span class=\"token punctuation\">,</span> createWebHashHistory <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"vue-router\"</span>\n\n<span class=\"token keyword\">import</span> Home <span class=\"token keyword\">from</span> <span class=\"token string\">\"../views/Home.vue\"</span>\n<span class=\"token keyword\">import</span> About <span class=\"token keyword\">from</span> <span class=\"token string\">\"../views/About.vue\"</span>\n<span class=\"token comment\">// 创建一个路由：映射关系</span>\n<span class=\"token keyword\">const</span> router <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">createRouter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{<!-- --></span>\n  <span class=\"token literal-property property\">history</span><span class=\"token operator\">:</span> <span class=\"token function\">createWebHashHistory</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">routes</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token punctuation\">{<!-- --></span>\n      <span class=\"token literal-property property\">path</span><span class=\"token operator\">:</span> <span class=\"token string\">\"/\"</span><span class=\"token punctuation\">,</span>\n      <span class=\"token literal-property property\">redirect</span><span class=\"token operator\">:</span> <span class=\"token string\">\"/home\"</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">{<!-- --></span>\n      <span class=\"token literal-property property\">path</span><span class=\"token operator\">:</span> <span class=\"token string\">\"/home\"</span><span class=\"token punctuation\">,</span>\n      <span class=\"token literal-property property\">component</span><span class=\"token operator\">:</span> Home\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">{<!-- --></span>\n      <span class=\"token literal-property property\">path</span><span class=\"token operator\">:</span> <span class=\"token string\">\"/about\"</span><span class=\"token punctuation\">,</span>\n      <span class=\"token literal-property property\">component</span><span class=\"token operator\">:</span> About\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> router\n</code></pre>\n<blockquote>\n<p><strong>补充：路由的其他属性</strong></p>\n<p>name属性：记录路由独一无二的名称;</p>\n<p>meta属性：自定义数据</p>\n</blockquote>\n<h2><a id=\"_routerlink_90\"></a>🎈 router-link（补充）</h2>\n<p>​ router-link事实上有很多属性可以配置：</p>\n<ul><li>to属性： 是一个字符串，或者是一个对象</li><li>replace属性： 设置 replace 属性的话，当点击时，会调用 router.replace()，而不是 router.push()。一般是不使用relace属性，给用户的体验感不是很好。</li><li>active-class属性： 设置激活a元素后应用的class，默认是router-link-active</li><li>exact-active-class属性： 链接精准激活时，应用于渲染的 的 class，默认是router-link-exact-active；</li></ul>\n<h2><a id=\"__101\"></a>🔑 路由懒加载</h2>\n<p>问题：当打包构建应用时，JavaScript 包会变得非常大，影响页面加载</p>\n<p>解决：把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件。同时也可提高首屏渲染的效率。其中，Vue-Router 默认就支持动态来加载组件。因为component可以传入一个组件，也可以接收一个函数，该函数需要放回一个Promise。<mark>import函数就是返回一个Promise</mark></p>\n<p><img alt=\"image-20220807215245227\" src=\"image\\adbc03d34104eec980b636cd65e0319f.png\"/></p>\n<h2><a id=\"__111\"></a>🔦 动态路由</h2>\n<h3><a id=\"1__113\"></a>1. 动态路由的基本匹配</h3>\n<p>将给定匹配模式的路由映射到同一个组件。以根据自己不同的需求加载不同的路由，做到不同的实现及页面的渲染。</p>\n<blockquote>\n<p>动态路由的使用一般是结合角色权限控制一起使用。</p>\n<p>例如：有一个 User 组件，它应该对所有用户进行渲染，但是用户的ID是不同的。我们可以在路径中使用一个动态字段来实现，我们称之为 路径参数。接着在中实现跳转。</p>\n<p><img alt=\"image-20220808130207685\" src=\"image\\4e3ee18b92808b6fe114cf96cc212765.png\"/></p>\n<p><img alt=\"image-20220808130252384\" src=\"image\\9999749afbb104e29f51a2b5d8a650ad.png\"/></p>\n</blockquote>\n<h3><a id=\"2__125\"></a>2. 获取动态路由的值</h3>\n<p>获取动态路由的值(例如上面例子中 用户id 123)，在template中，直接通过 $route.params获取值。</p>\n<ul><li>在created中，通过 this.$route.params获取值</li><li>在setup中，我们要使用 vue-router库给我们提供的一个hook useRoute</li></ul>\n<p><img alt=\"image-20220808130855725\" src=\"image\\64a227ad611987e810e2a8ba5f9c0bb3.png\"/></p>\n<h3><a id=\"3_NotFound_134\"></a>3. NotFound</h3>\n<p>对于没有匹配到相应的路由，我们可以给用户匹配一个固定的页面。<mark>通过 $route.params.pathMatch获取到传入的参数</mark></p>\n<p><img alt=\"image-20220808161621386\" src=\"image\\bebd7eb8a4f350e83c03be9a56398e92.png\"/></p>\n<h2><a id=\"__142\"></a>🪒 路由的嵌套</h2>\n<p>​ 组件的本身也有组件需要内部切换，这个时候就可以采用嵌套路由，在第一层路由中也使用router-view来占位之后需要渲染的组件。</p>\n<p><img alt=\"image-20220808165709796\" src=\"image\\d67092792e2be303138d1433d1fcf584.png\"/></p>\n<pre><code class=\"prism language-js\"><span class=\"token punctuation\">{<!-- --></span>\n      <span class=\"token literal-property property\">path</span><span class=\"token operator\">:</span> <span class=\"token string\">\"/home\"</span><span class=\"token punctuation\">,</span>\n      <span class=\"token function-variable function\">component</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token keyword\">import</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"../views/Home.vue\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n      <span class=\"token literal-property property\">children</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n        <span class=\"token punctuation\">{<!-- --></span>\n          <span class=\"token literal-property property\">path</span><span class=\"token operator\">:</span> <span class=\"token string\">\"/show\"</span><span class=\"token punctuation\">,</span>\n          <span class=\"token function-variable function\">component</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token keyword\">import</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"../views/component/show.vue\"</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n        <span class=\"token punctuation\">{<!-- --></span>\n          <span class=\"token literal-property property\">path</span><span class=\"token operator\">:</span> <span class=\"token string\">\"/detail\"</span><span class=\"token punctuation\">,</span>\n          <span class=\"token function-variable function\">component</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token keyword\">import</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"../views/component/detail.vue\"</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n</code></pre>\n<h2><a id=\"__167\"></a>🧷 编程式导航</h2>\n<h3><a id=\"1__169\"></a>1. 代码的页面跳转</h3>\n<p>通过代码来控制页面的跳转</p>\n<p>栗子：点击一个按钮跳转页面</p>\n<p><img alt=\"image-20220808170931435\" src=\"image\\26d9c07acc1d5042076d16301c0669be.png\"/></p>\n<h3><a id=\"2_query__179\"></a>2. query 方式的参数</h3>\n<p>通过query的方式来传递参数，在界面中通过 $route.query 来获取参数。</p>\n<p><img alt=\"image-20220808171556213\" src=\"image\\594a498b1b1d4359a7c2ba6e831bede7.png\"/></p>\n<h3><a id=\"3__185\"></a>3. 替换当前的位置</h3>\n<p>​ 使用push的特点是压入一个新的页面，那么在用户点击返回时，上一个页面还可以回退，但是如果我们希望当前页面是一个替换 操作，那么可以使用replace。这个时候已经不能回退了。</p>\n<h3><a id=\"4__189\"></a>4. 页面的前后跳转</h3>\n<ol><li>router 的 go 方法（指定向前(向后)跳转几步）</li><li>router 的back 方法 （回溯历史，向后一步）</li><li>router 的forward 方法（历史中前进，向前一步）</li></ol>\n<h2><a id=\"__195\"></a>🔍 动态添加路由</h2>\n<p>场景：根据用户的不同权限，注册不同的路由</p>\n<p><img alt=\"image-20220808215637087\" src=\"image\\9499ac0def6e9ab0606635e260d21539.png\"/></p>\n<p><strong>补充：路由的其他方法</strong></p>\n<p>删除路由有以下三种方式：</p>\n<ul><li>方式一：添加一个name相同的路由；</li><li>方式二：通过removeRoute方法，传入路由的名称；</li><li>方式三：通过addRoute方法的返回值回调；</li></ul>\n<p>router.hasRoute()：检查路由是否存在。</p>\n<p>router.getRoutes()：获取一个包含所有路由记录的数组。</p>\n<h2><a id=\"__217\"></a>🎉 路由导航守卫</h2>\n<blockquote>\n<p>vue-router 提供的导航守卫主要用来通过跳转或取消的方式守卫导航</p>\n</blockquote>\n<p>全局的前置守卫==<code>beforeEach</code>==是在导航触发时会被回调的,它有两个参数：</p>\n<ul><li>to：即将进入的路由Route对象；</li><li>from：即将离开的路由Route对象；</li></ul>\n<p>返回值：</p>\n<ul><li>false：取消当前导航；</li><li>不返回或者undefined：进行默认导航；</li><li>返回一个路由地址：可以是一个String类型的路径也可以是一个对象</li></ul>\n<p><img alt=\"image-20220808235738391\" src=\"image\\e410c248c40784ab5f180336c6887c1a.png\"/></p>\n<h3><a id=\"1__234\"></a>1. 登录守卫功能</h3>\n<p>场景：只有登录了的用户才能看到的页面</p>\n<p><img alt=\"image-20220808233927532\" src=\"image\\39a463bf89da38c9b2c6a9d8fe005a77.png\"/></p>\n<h3><a id=\"2__242\"></a>2. 其他导航守卫</h3>\n<p>​ Vue还提供了很多的其他守卫函数，目的都是在某一个时刻给予回调，可以更好的控制程序的流程或者功能</p>\n<p>[导航守卫](<a href=\"https://router.vuejs.org/zh/guide/advanced/navigation-guards.html\">导航守卫 | Vue Router (vuejs.org)</a>)</p>\n<p>流程：</p>\n<ol><li>导航被触发。</li><li>在失活的组件里调用 beforeRouteLeave 守卫。</li><li>调用全局的 beforeEach 守卫。</li><li>在重用的组件里调用 beforeRouteUpdate 守卫(2.2+)。</li><li>在路由配置里调用 beforeEnter。  解析异步路由组件。</li><li>在被激活的组件里调用 beforeRouteEnter。</li><li>调用全局的 beforeResolve 守卫(2.5+)。</li><li>导航被确认。</li><li>调用全局的 afterEach 钩子。</li><li>触发 DOM 更新。</li><li>调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。</li></ol>\n<p><img alt=\"喜欢就一键三连吧！\" src=\"image\\0bba0676d1b6c8798cac3813f1d93043.png\"/></p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}