{"blogid": "124658245", "writerAge": "码龄3年", "writerBlogNum": "56", "writerCollect": "634", "writerComment": "49", "writerFan": "229", "writerGrade": "3级", "writerIntegral": "758", "writerName": "偶尔躺平的咸鱼", "writerProfileAdress": "writer_image\\profile_124658245.jpg", "writerRankTotal": "21766", "writerRankWeekly": "215144", "writerThumb": "182", "writerVisitNum": "122768", "blog_read_count": "4178", "blog_time": "已于 2022-05-09 08:11:01 修改", "blog_title": "tsne原理以及代码实现（学习笔记）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p></p>\n<div class=\"toc\">\n<h3>文章目录</h3>\n<ul><li><a href=\"#1_tSNE_1\">1. t-SNE的基本概念</a></li><li><a href=\"#2_tSNE_4\">2. t-SNE介绍</a></li><li><ul><li><a href=\"#21_SNE_6\">2.1 SNE（随机邻域嵌入）</a></li><li><a href=\"#22_tSNE_22\">2.2 t-SNE</a></li><li><a href=\"#23_tSNE_31\">2.3 t-SNE的优缺点</a></li><li><ul><li><a href=\"#231_tSNE_32\">2.3.1 t-SNE优点</a></li><li><a href=\"#232_tSNE_36\">2.3.2 t-SNE的缺点</a></li></ul>\n</li></ul>\n</li><li><a href=\"#3__50\">3. 代码实现</a></li><li><ul><li><a href=\"#31__80\">3.1 接口参数解释：</a></li><li><a href=\"#32_99\">3.2方法</a></li></ul>\n</li></ul>\n</div>\n<p></p>\n<h1><a id=\"1_tSNE_1\"></a>1. t-SNE的基本概念</h1>\n<p>t-SNE(t-distributed stochastic neighbor embedding) 是一种非线性降维算法，非常适用于高维数据降维到2维或者3维，并进行可视化。</p>\n<h1><a id=\"2_tSNE_4\"></a>2. t-SNE介绍</h1>\n<p>t-SNE是由SNE(Stochastic Neighbor Embedding, SNE; Hinton and Roweis, 2002)发展而来。</p>\n<h2><a id=\"21_SNE_6\"></a>2.1 SNE（随机邻域嵌入）</h2>\n<p>SNE首先将数据点之间的<strong>高维欧几里德距离</strong>转换为表示<strong>相似性的条件概率</strong>，如（1）式。对于附近的数据点，pj|i相对较高，而对于广泛分离的数据点，pj|i几乎是无穷小的。<br/> <img alt=\"在这里插入图片描述\" src=\"image\\31956106b10d4ea498bd736270853d05.png\"/><br/> 高维数据点xi和xj 的低维对应项yi和yj,可以计算类似的条件概率，我们用qj|i表示。<br/> <img alt=\"在这里插入图片描述\" src=\"image\\3ad1d5729046468ca684c5aeea31bc41.png\"/><br/> 如果映射点yi和yj正确地建模了高维数据点xi和xj之间的相似性，则条件概率pj|i和qj|i将相等。受这一观察结果的启发，SNE的目标是找到一种低维数据表示法，以最小化pj|i和qj|i之间的不匹配。qj|i建模pj|i的信度的自然度量是KullbackLeibler散度。<strong>SNE使用梯度下降法最小化所有数据点上的Kullback-Leibler发散之和。成本函数C由下式给出：</strong><br/> <img alt=\"在这里插入图片描述\" src=\"image\\18831a93bdcb4500ab8331129da4c4de.png\"/><br/> 其中Pi表示给定数据点xi的所有其他数据点上的条件概率分布，Qi表示给定图点yi的所有其他地图点上的条件概率分布。由于Kullback-Leibler散度是<strong>非对称</strong>的，<strong>因此低维映射中成对距离中的不同类型的误差加权不相等</strong>。特别是，使用广泛分离的地图点来表示附近的数据点（即使用一个小的qj|i来模拟一个大的pj|i），但是使用附近的地图点来表示广泛分离的数据点的成本很小。这个小成本来自于在相关Q分布中浪费一些概率质量。<strong>换句话说，SNE成本函数侧重于在地图中保留数据的局部结构。</strong></p>\n<p><strong>SNE的缺点：</strong><br/> 尽管SNE构建了相当好的可视化效果，但它受到<br/> <strong>①难以优化的成本函数</strong><br/> <strong>②拥挤问题</strong><br/> 拥挤问题就是说各个簇聚集在一起，无法区分。比如有一种情况，高维度数据在降维到10维下，可以有很好的表达，但是降维到两维后无法得到可信映射，比如降维如10维中有11个点之间两两等距离的，在二维下就无法得到可信的映射结果(最多3个点)。</p>\n<h2><a id=\"22_tSNE_22\"></a>2.2 t-SNE</h2>\n<p>t-SNE旨在缓解SNE的缺点。t-SNE使用的成本函数在两个方面不同于SNE使用的成本函数：<br/> （1）它使用了具有更简单梯度的SNE成本函数C的<strong>对称版本</strong><br/> <img alt=\"在这里插入图片描述\" src=\"image\\d9ff2a6a31d24174845ecc1f08a8c8d5.png\"/></p>\n<p>（2）它使用<strong>Student-t分布</strong>而<strong>不是高斯分布</strong>来<strong>计算低维空间中两点之间的相似性</strong>。<br/> <img alt=\"在这里插入图片描述\" src=\"image\\ee0c91686c6449e58c86a010ae1ed3a0.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"image\\1a6b0f20b6344c04a55824c9c47b24d2.png\"/></p>\n<h2><a id=\"23_tSNE_31\"></a>2.3 t-SNE的优缺点</h2>\n<h3><a id=\"231_tSNE_32\"></a>2.3.1 t-SNE优点</h3>\n<p>对于不相似的点，用一个较小的距离会产生较大的梯度来让这些点排斥开来。<br/> 这种排斥又不会无限大(梯度中分母)，避免不相似的点距离太远。<br/> t-SNE在低维空间采用重尾分布，以缓解SNE的拥挤问题和优化问题。</p>\n<h3><a id=\"232_tSNE_36\"></a>2.3.2 t-SNE的缺点</h3>\n<p>尽管我们已经证明，t-SNE与其他数据可视化技术相比具有优势，但tSNE有三个潜在的弱点：<br/> <strong>（1）t-SNE在一般降维任务中的表现尚不清楚，</strong><br/> 目前尚不清楚t-SNE将如何执行更一般的降维任务（即当数据的维度不是降到两个或三个维度，而是降到d&gt;3个维度时）。为了简化评估问题，本文只考虑使用t-SNE进行数据可视化。<br/> <strong>（2）t-SNE的相对局部性使其对数据的固有维数的诅咒非常敏感，</strong><br/> 而且t-SNE倾向于保存局部特征，对于本征维数(intrinsic dimensionality)本身就很高的数据集，是不可能完整的映射到2-3维的空间。（部分）解决该问题的一种可能方法是，对从模型中获得的数据表示进行t-SNE，如自编码器。这种深层体系结构可以以更简单的方式表示复杂的非线性函数，因此，学习合适的解决方案需要更少的数据点。例如，对自动编码器生成的数据表示执行t-SNE可能会提高构建的可视化的质量，因为自动编码器比局部方法（如t-SNE）更好地识别高度变化的线性。<br/> <strong>（3）t-SNE不保证收敛到其代价函数的全局最优。</strong><br/> t-SNE的一个主要缺点是代价函数C不是凸的，因此需要选择几个优化参数。构造的解决方案取决于这些优化参数的选择，并且每次从映射点的初始随机配置运行t-SNE时可能会有所不同。<br/> <strong>（4）t-SNE没有唯一最优解，且没有预估部分。</strong><br/> 如果想要做预估，可以考虑降维之后，再构建一个回归方程之类的模型去做。但是要注意，t-sne中距离本身是没有意义，都是概率分布问题。<br/> <strong>（5）训练太慢。</strong><br/> 与许多其他可视化技术一样，t-SNE的计算和内存复杂性是数据点数量的二次方。这使得将标准版本的t-SNE应用于包含超过10000个点的数据集是不可行的。t-SNE的计算复杂度和内存复杂度都是O（n2），有很多基于树的算法在t-sne上做一些改进。</p>\n<h1><a id=\"3__50\"></a>3. 代码实现</h1>\n<pre><code class=\"prism language-python\"><span class=\"token keyword\">from</span> sklearn<span class=\"token punctuation\">.</span>manifold <span class=\"token keyword\">import</span> TSNE\n<span class=\"token keyword\">from</span> sklearn<span class=\"token punctuation\">.</span>datasets <span class=\"token keyword\">import</span> load_iris\n<span class=\"token keyword\">from</span> sklearn<span class=\"token punctuation\">.</span>decomposition <span class=\"token keyword\">import</span> PCA\n<span class=\"token keyword\">import</span> matplotlib<span class=\"token punctuation\">.</span>pyplot <span class=\"token keyword\">as</span> plt\n<span class=\"token comment\"># 加载数据集</span>\niris <span class=\"token operator\">=</span> load_iris<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\"># 共有150个例子， 数据的类型是numpy.ndarray</span>\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>iris<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">.</span>shape<span class=\"token punctuation\">)</span><span class=\"token comment\">#(150,4)</span>\n<span class=\"token comment\"># 对应的标签有0,1,2三种</span>\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>iris<span class=\"token punctuation\">.</span>target<span class=\"token punctuation\">.</span>shape<span class=\"token punctuation\">)</span><span class=\"token comment\">#(150,)</span>\n<span class=\"token comment\"># 使用TSNE进行降维处理。从4维降至2维。</span>\ntsne <span class=\"token operator\">=</span> TSNE<span class=\"token punctuation\">(</span>n_components<span class=\"token operator\">=</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> learning_rate<span class=\"token operator\">=</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>fit_transform<span class=\"token punctuation\">(</span>iris<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># 使用PCA 进行降维处理</span>\npca <span class=\"token operator\">=</span> PCA<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>fit_transform<span class=\"token punctuation\">(</span>iris<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">)</span>\n<span class=\"token comment\"># 设置画布的大小</span>\nplt<span class=\"token punctuation\">.</span>figure<span class=\"token punctuation\">(</span>figsize<span class=\"token operator\">=</span><span class=\"token punctuation\">(</span><span class=\"token number\">12</span><span class=\"token punctuation\">,</span> <span class=\"token number\">6</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\nplt<span class=\"token punctuation\">.</span>subplot<span class=\"token punctuation\">(</span><span class=\"token number\">121</span><span class=\"token punctuation\">)</span>\nplt<span class=\"token punctuation\">.</span>scatter<span class=\"token punctuation\">(</span>tsne<span class=\"token punctuation\">[</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> tsne<span class=\"token punctuation\">[</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> c<span class=\"token operator\">=</span>iris<span class=\"token punctuation\">.</span>target<span class=\"token punctuation\">)</span>\nplt<span class=\"token punctuation\">.</span>subplot<span class=\"token punctuation\">(</span><span class=\"token number\">122</span><span class=\"token punctuation\">)</span>\nplt<span class=\"token punctuation\">.</span>scatter<span class=\"token punctuation\">(</span>pca<span class=\"token punctuation\">[</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> pca<span class=\"token punctuation\">[</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> c<span class=\"token operator\">=</span>iris<span class=\"token punctuation\">.</span>target<span class=\"token punctuation\">)</span>\nplt<span class=\"token punctuation\">.</span>colorbar<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nplt<span class=\"token punctuation\">.</span>show<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<p>运行结果：<br/> <img alt=\"在这里插入图片描述\" src=\"image\\d34f19c04aa249f990f7d4bd655ff224.png\"/></p>\n<h2><a id=\"31__80\"></a>3.1 接口参数解释：</h2>\n<p>sklearn.manifold.TSNE(n_components=2, perplexity=30.0, early_exaggeration=12.0, learning_rate=200.0, n_iter=1000, n_iter_without_progress=300, min_grad_norm=1e-07, metric=’euclidean’, init=’random’, verbose=0, random_state=None, method=’barnes_hut’, angle=0.5)<br/> <strong>参数：</strong><br/> <strong>n_components</strong>：int，可选（默认值：2）嵌入式空间的维度。<br/> <strong>perplexity</strong>：float，可选（默认：30）较大的数据集通常需要更大的perplexity。考虑选择一个介于5和50之间的值。由于t-SNE对这个参数非常不敏感，所以选择并不是非常重要。<br/> <strong>early_exaggeration</strong>：float，可选（默认值：4.0）这个参数的选择不是非常重要。<br/> <strong>learning_rate</strong>：float，可选（默认值：1000）学习率可以是一个关键参数。它应该在100到1000之间。如果在初始优化期间成本函数增加，则早期夸大因子或学习率可能太高。如果成本函数陷入局部最小的最小值，则学习速率有时会有所帮助。<br/> <strong>n_iter</strong>：int，可选（默认值：1000）优化的最大迭代次数。至少应该200。<br/> <strong>n_iter_without_progress</strong>：int，可选（默认值：300，必须是50倍数）在我们中止优化之前，没有进展的最大迭代次数。<br/> 0.17新版​​功能：参数n_iter_without_progress控制停止条件。<br/> <strong>min_grad_norm</strong>：float，可选（默认值：1E-7）如果梯度范数低于此阈值，则优化将被中止。<br/> <strong>metric</strong>：字符串或可迭代的，可选，计算特征数组中实例之间的距离时使用的度量。如果度量标准是字符串，则它必须是scipy.spatial.distance.pdist为其度量标准参数所允许的选项之一，或者是成对列出的度量标准.PAIRWISE_DISTANCE_FUNCTIONS。如果度量是“预先计算的”，则X被假定为距离矩阵。或者，如果度量标准是可调用函数，则会在每对实例（行）上调用它，并记录结果值。可调用应该从X中获取两个数组作为输入，并返回一个表示它们之间距离的值。默认值是“euclidean”，它被解释为欧氏距离的平方。<br/> <strong>init</strong>：字符串，可选（默认值：“random”）嵌入的初始化。可能的选项是“随机”和“pca”。 PCA初始化不能用于预先计算的距离，并且通常比随机初始化更全局稳定。<br/> r<strong>andom_state</strong>：int或RandomState实例或None（默认）<br/> 伪随机数发生器种子控制。如果没有，请使用numpy.random单例。请注意，不同的初始化可能会导致成本函数的不同局部最小值。<br/> <strong>method</strong>：字符串（默认：‘barnes_hut’）<br/> 默认情况下，梯度计算算法使用在O（NlogN）时间内运行的Barnes-Hut近似值。 method ='exact’将运行在O（N ^ 2）时间内较慢但精确的算法上。当最近邻的误差需要好于3％时，应该使用精确的算法。但是，确切的方法无法扩展到数百万个示例。0.17新版​​功能：通过Barnes-Hut近似优化方法。<br/> <strong>angle</strong>：float（默认值：0.5）<br/> 仅当method ='barnes_hut’时才使用这是Barnes-Hut T-SNE的速度和准确性之间的折衷。 ‘angle’是从一个点测量的远端节点的角度大小（在[3]中称为theta）。如果此大小低于’角度’，则将其用作其中包含的所有点的汇总节点。该方法对0.2-0.8范围内该参数的变化不太敏感。小于0.2的角度会迅速增加计算时间和角度，因此0.8会快速增加误差。</p>\n<h2><a id=\"32_99\"></a>3.2方法</h2>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\83e70030877d47c5abbd3352f5f2933c.png\"/><br/> 这部分不用了解太多，知道几个主要的参数如<strong>n_components、n_iter、init</strong>等以及主要的方法<strong>fit_transform就好</strong>了。</p>\n<pre><code class=\"prism language-bash\"><span class=\"token comment\">#流程</span>\ntsne <span class=\"token operator\">=</span> TSNE<span class=\"token punctuation\">(</span>perplexity<span class=\"token operator\">=</span><span class=\"token number\">50</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">#调用TSNE函数</span>\nX_embedded <span class=\"token operator\">=</span> tsne.fit_transform<span class=\"token punctuation\">(</span>X0<span class=\"token punctuation\">)</span> <span class=\"token comment\">#输入数据</span>\nplt.figure<span class=\"token punctuation\">(</span>figsize<span class=\"token operator\">=</span><span class=\"token punctuation\">(</span><span class=\"token number\">12</span>, <span class=\"token number\">6</span><span class=\"token punctuation\">))</span>\nplt.scatter<span class=\"token punctuation\">(</span>X_embedded<span class=\"token punctuation\">[</span>:,0<span class=\"token punctuation\">]</span>, X_embedded<span class=\"token punctuation\">[</span>:,1<span class=\"token punctuation\">]</span>,c<span class=\"token operator\">=</span>y0,cmap<span class=\"token operator\">=</span><span class=\"token string\">'Reds'</span><span class=\"token punctuation\">)</span><span class=\"token comment\"># 根据y值进行可视化 选择颜色值</span>\nplt.colorbar<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">#显示色棒</span>\nplt.show<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\ntsne.embedding_ <span class=\"token comment\">#返回二维数据点的对应的坐标</span>\n</code></pre>\n<blockquote>\n<p>参考链接：https://distill.pub/2016/misread-tsne/</p>\n</blockquote>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}