{"blogid": "123839113", "writerAge": "码龄1年", "writerBlogNum": "58", "writerCollect": "128", "writerComment": "3", "writerFan": "20", "writerGrade": "3级", "writerIntegral": "609", "writerName": "~不羁", "writerProfileAdress": "writer_image\\profile_123839113.jpg", "writerRankTotal": "34130", "writerRankWeekly": "361327", "writerThumb": "69", "writerVisitNum": "78045", "blog_read_count": "3581", "blog_time": "已于 2022-03-31 14:44:12 修改", "blog_title": "c++ 动态数组", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h2><a id=\"_0\"></a>动态数组</h2>\n<hr/>\n<p><strong>相关数组知识连接</strong><br/> <strong><a href=\"https://blog.csdn.net/m0_62870588/article/details/123787052\">数组详解</a></strong><br/> <strong><a href=\"https://blog.csdn.net/m0_62870588/article/details/123866514\">多维数组</a></strong></p>\n<hr/>\n<p>在之前的文章中，讲解了<a href=\"https://blog.csdn.net/m0_62870588/article/details/123787052\">数组</a>的相关知识，那一种<a href=\"https://blog.csdn.net/m0_62870588/article/details/123787052\">数组</a>（数组相关连接：<a href=\"https://blog.csdn.net/m0_62870588/article/details/123787052\">https://blog.csdn.net/m0_62870588/article/details/123787052</a>）又称是静态数组，因为它的大小从头到尾是固定的。在这里将会讲解动态数组的相关知识。动态数组，严格意义上讲并不是<a href=\"https://blog.csdn.net/m0_62870588/article/details/123787052\">数组</a>，程序会使用<a href=\"https://blog.csdn.net/m0_62870588/article/details/123794933\">指针</a>来承载malloc( )或者new操作符动态分配的内存空间，然后在需要更新数组大小或者释放空间的时候使用free () 或者delete。</p>\n<hr/>\n<h3><a id=\"mallocfree_8\"></a>使用malloc()和free()动态分配内存</h3>\n<p>malloc()函数可以在一个叫堆（Heap）的内存空间中分配指定字节数的内存。与作用域中在栈（Stack）中分配内存的局部变量不同，堆中的内存一旦分配，就不会自动释放，直到数据调用free()函数.</p>\n<p><em><strong>使用malloc()</strong></em></p>\n<pre><code class=\"prism language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;iostream&gt;</span></span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">//使用malloc()</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>arr <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token operator\">*</span><span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>ptr <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span> <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i <span class=\"token operator\">&lt;</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\t<span class=\"token operator\">*</span>ptr <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n\t\tcout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token operator\">*</span>ptr <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" \"</span><span class=\"token punctuation\">;</span>\n\t\tptr<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//也可以直接写成 cout &lt;&lt; *(ptr++）&lt;&lt;\" \";</span>\n\t<span class=\"token punctuation\">}</span>\n\tcout <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">free</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\tarr <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n</code></pre>\n<p><strong>运行结果</strong><br/> 展示了malloc()和free()的应用。<br/> <img alt=\"在这里插入图片描述\" src=\"image\\75f729ac118640c0ab9a4beea3773ab9.png\"/><br/> 示例中，先使用malloc()分配了大小为“ 5 * sizeof（int）”字节的内存。malloc()的分配单位是字节，所以要用sizeof操作符获取整形int的字节数。此外，由于malloc()返回 void * 指针，因此也要将返回值转换为需要的指针类型；分配完内存之后我们就用另一个指针来遍历这个动态的数组，最后需要记得用free()函数释放内存。</p>\n<p><strong>对于动态数组来说，因为内存不会自动释放，所以如果遗漏free()，就会发生内存泄漏（Menory Leak），也就是说已分配的内存会一直被占用，别的程序就不能使用这一块内存了。</strong></p>\n<p>举个例子说明一下这个概念，可以用现实生活中更衣室的柜子来类比：更衣室的柜子在出租之后就会被上锁，顾客在使用一段时间后，把东西拿了出来，关上柜子却忘记归还钥匙就离开了。这个情况下管理人员是没有钥匙的，尽管柜子是空的却也不能提供给另外一名顾客使用。堆中的内存也是如此，如果不释放，就算只用那块内存的程序已经终止，那块内存也是处于被占用的状态。</p>\n<p>另一个值得注意的点是，在调用free()函数的时候我们不能使用ptr，而必须使用arr。这是因为ptr在遍历结束之后指向的是动态数组的末尾元素，如果使用free()释放 5 * sizeof（int）字节内存，就会触动到最后一个元素后面的未知的内存段。</p>\n<p><strong>提示：</strong> 在c++程序中，如果使用动态内存分配，一定要让free()或delete与malloc()和new 匹配，即在程序中一次内存分配一定要有相对应的一次相同大小的内存释放。释放多次相同的内存、没有释放内存以及释放内存大小不匹配都是不能接受的。</p>\n<p>此外，在释放内存后将指针重新赋值为NULL是一个非常好的习惯。这是因为对指针用了free()之后不会改变指针的值，也就是指向的地址。在之后的程序中可能会忘记这个内存的地址已经被释放，而再次使用这个指针就会导致程序异常。这个时候如果指针是NULL，就会被许多条检查拦截（就像把指针初始化NULL一样），从而避免许多潜在问题。</p>\n<hr/>\n<h3><a id=\"newdelete_52\"></a>使用new和delete两个操作符</h3>\n<p>malloc()和free()在C语言中就存在了，c++只是继承了他们。为了更好的只支持对象的内存管理，c++引入了new和delete两个操作符。</p>\n<p><em><strong>使用new和delete</strong></em></p>\n<pre><code class=\"prism language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;iostream&gt;</span></span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">//使用new和delete</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>numPtr <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">int</span> <span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\tcout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token operator\">*</span>numPtr <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">delete</span> numPtr<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>arr <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">int</span> <span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>ptr <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span> <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\t<span class=\"token operator\">*</span>ptr <span class=\"token operator\">=</span> i <span class=\"token punctuation\">;</span>\n\t\tcout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token operator\">*</span>ptr <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" \"</span> <span class=\"token punctuation\">;</span>\n\t\tptr<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//也可以直接写成cout &lt;&lt; *(Ptr++) &lt;&lt; \" \" ;</span>\n\t<span class=\"token punctuation\">}</span>\n\tcout <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">delete</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> arr<span class=\"token punctuation\">;</span>\n\tarr <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n</code></pre>\n<p><strong>运行结果</strong><br/> <img alt=\"在这里插入图片描述\" src=\"image\\4b18b75e741043d69bf3cc1ec38e5b23.png\"/><br/> 从示例中可以看出，new和delete在总体上还是malloc()和free()类似的，由于new与类似相关，因此写法上还会更简洁一些。在例子中，使用了两组new/delete对，第一个new分配了一个初始值为3的整数（这里用到了雷子于构造函数的初始方法）这个语句也可以写成“ int * numPtr = new int ;”,这样写的话整型就只有一个未知的初值。这是因为再分配了内存却没有赋值的情况下，该内存段可能还保留着上一次分配后存储的某个值。<br/> 第一组new/delete的语法相对来说比较直观。第二个new后面跟着变量类型以及元素的个数，这样的语法类似于数组的创建，而实际上也表示分配一段能放下5个int大小的内存。这里不需要像使用malloc()那样指定一字节为单位的内存大小，这样也使得程序更具有可读性。对于delete来说，如果用new分配了数组，那么就需要在delete和指针名之间加上一对括号（[]）以表示释放数个指针类型大小的空间，不然只会像delete numPtr那样删除一个元素，这也是new/delete与malloc()/free()的一个重要区别。</p>\n<hr/>\n<p><strong>相关数组知识连接</strong><br/> <strong><a href=\"https://blog.csdn.net/m0_62870588/article/details/123787052\">数组详解</a></strong><br/> <strong><a href=\"https://blog.csdn.net/m0_62870588/article/details/123866514\">多维数组</a></strong></p>\n<hr/>\n<p><em><strong>如果对您有帮助，点赞支持一下吧~</strong></em></p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}