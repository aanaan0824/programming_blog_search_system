{"blogid": "121876993", "writerAge": "码龄14年", "writerBlogNum": "4", "writerCollect": "30", "writerComment": "0", "writerFan": "4", "writerGrade": "1级", "writerIntegral": "80", "writerName": "weiyaonan", "writerProfileAdress": "writer_image\\profile_121876993.jpg", "writerRankTotal": "263059", "writerRankWeekly": "369378", "writerThumb": "4", "writerVisitNum": "8115", "blog_read_count": "3282", "blog_time": "于 2021-12-11 18:10:53 发布", "blog_title": "c++ 中 char 与 string 之间的相互转换问题", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>       首先必须了解，string可以被看成是以字符为元素的一种容器。字符构成序列（字符串）。有时候在字符序列中进行遍历，标准的string类提供了STL容器接口。具有一些成员函数比如begin()、end()，迭代器可以根据他们进行定位。</p>\n<p>注意，与char*不同的是，string不一定以NULL('\\0')结束。string长度可以根据length()得到，string可以根据下标访问。所以，不能将string直接赋值给char*。</p>\n<h1>1、将char *或者char []转换为string</h1>\n<p>可以直接赋值，转换。</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\2d440a1ab04906f7b2b69a8cc9666651.png\"/></p>\n<p></p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\6438d2593846d33f9ed1323a1e5168e9.png\"/></p>\n<h1>2、将string转换为char *或者char []   </h1>\n<p>string 是c++标准库里面其中一个，封装了对字符串的操作 <br/> 把string转换为char* 有 <strong> 3种方法</strong>： <br/> （1）  <strong>调用  string   的   data   函数 </strong><br/> 如： <br/> string str=\"abc\"; <br/> char *p=str.data(); </p>\n<p></p>\n<p><strong>（2）调用  string   的  c_str   函数 </strong></p>\n<p></p>\n<p>如：string str=\"gdfd\"; <br/>     char *p=str.c_str(); </p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\0fb0b83c955ae2af83e610efd06077fd.png\"/></p>\n<pre><code class=\"hljs language-cpp\">语法: \nconst char *c_str();\nc_str()函数返回一个指向正规C字符串的指针, 内容与本string串相同. \n这是为了与c语言兼容，在c语言中没有string类型，故必须通过string类对象的成员函数c_str()把string 对象转换成c中的字符串样式。\n注意：一定要使用strcpy()函数等来操作方法c_str()返回的指针 \n比如：最好不要这样: \nchar* c; \nstring s=\"1234\"; \nc = s.c_str(); //c最后指向的内容是垃圾，因为s对象被析构，其内容被处理\n \n应该这样用： \nchar c[20]; \nstring s=\"1234\"; \nstrcpy(c,s.c_str()); \n这样才不会出错，c_str()返回的是一个临时指针，不能对其进行操作\n \n再举个例子\nc_str() 以 char* 形式传回 string 内含字符串\n如果一个函数要求char*参数，可以使用c_str()方法： \nstring s = \"Hello World!\";\nprintf(\"%s\", s.c_str()); //输出 \"Hello World!\"</code></pre>\n<p><strong>（3）调用  string   的  copy   函数 </strong><br/> 比如 <br/> string str=\"hello\"; <br/> char p[40]; <br/> str.copy(p,5,0); //这里5，代表复制几个字符，0代表复制的位置<br/><strong>*(p+5)='/0';     //要手动加上结束符</strong><br/> cout &lt; &lt;p;</p>\n<p><strong>注意：data只是返回原始数据序列，没有保证会用traits::eos()，或者说'\\0'来作字符串结束.</strong>   当然，可能多数实现都这样做了。   <br/> c_str是标准的做法，返回的char*   一定指向一个合法的用'\\0'终止的C兼容的字符串。   <br/> 所以，如果需要C兼容的字符串，<strong>c_str  是标准的做法，data  并不保证所有STL的实现的一致性</strong>。你或许会问，c_str()的功能包含data()，那还需要data()函数干什么？看看源码：</p>\n<pre><code class=\"hljs language-cpp\">const charT* c_str () const\n{\n\n   if  (length () == 0)\n\n        return \"\";\n\n   terminate ();\n\n   return data ();\n\n}</code></pre>\n<p><br/>        原来c_str()的流程是：先调用terminate()，然后在返回data()。因此如果你对效率要求比较高，而且你的处理又不一定需要以\\0的方式结束，你最好选择data()。但是对于一般的C函数中，需要以const char*为输入参数，你就要使用c_str()函数。<br/>         对于c_str() data()函数，返回的数组都是由string本身拥有，千万不可修改其内容。其原因是许多string实现的时候采用了引用机制，也就是说，有可能几个string使用同一个字符存储空间。而且你不能使用sizeof(string)来查看其大小。详细的解释和实现查看Effective STL的条款15：小心string实现的多样性。<br/>        另外在你的程序中，只在需要时才使用c_str()或者data()得到字符串，每调用一次，下次再使用就会失效，如：定义一个</p>\n<pre><code class=\"hljs language-cpp\">string strinfo(\"this is Winter\");</code></pre>\n<p><br/> （1）最好的方式是：</p>\n<pre><code class=\"hljs language-cpp\">foo(strinfo.c_str());</code></pre>\n<p><br/> （2）也可以这么用：</p>\n<pre><code class=\"hljs language-cpp\">const char* pstr=strinfo.c_str();\nfoo(pstr);</code></pre>\n<p>如果出现下面的操作，已经使pstr无效了。</p>\n<pre><code class=\"hljs\">strinfo += \" Hello!\";\nfoo(pstr);//错误！</code></pre>\n<p>       会遇到什么错误？当你幸运的时候pstr可能只是指向\"this is Winter Hello!\"的字符串，如果不幸运，就会导致程序出现其他问题，总会有一些不可遇见的错误。总之不会是你预期的那个结果。原因为strinfo的数据增多后，而此时内存不够，strinfo有可能会动态更换新内存地址，pstr所指向的地址还为老地址。</p>\n<p></p>\n</div>\n</div>"}