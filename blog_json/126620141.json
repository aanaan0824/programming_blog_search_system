{"blogid": "126620141", "writerAge": "码龄1年", "writerBlogNum": "384", "writerCollect": "368", "writerComment": "25", "writerFan": "14408", "writerGrade": "5级", "writerIntegral": "4057", "writerName": "小芬熊", "writerProfileAdress": "writer_image\\profile_126620141.jpg", "writerRankTotal": "4566", "writerRankWeekly": "390", "writerThumb": "82", "writerVisitNum": "246397", "blog_read_count": "191", "blog_time": "于 2022-08-31 11:12:37 发布", "blog_title": "面试题：SpringBoot 自动装配原理", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h4><a id=\"1_SpringBootApplication_2\"></a>1. @SpringBootApplication注解</h4>\n<p>首先，我们都知道SpringBoot程序的入口是通过@SpringBootApplication注解修饰的一个类，例如：</p>\n<pre><code>@SpringBootApplication\npublic class DemoApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(ConfigApplication.class, args);\n    }\n}\n</code></pre>\n<p>那么这个自动装配的过程肯定就是通过@SpringBootApplication这个注解内部实现来完成的。看一下它的源码：</p>\n<pre><code>@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@SpringBootConfiguration\n@EnableAutoConfiguration\n@ComponentScan(excludeFilters = {\n\t\t@Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),\n\t\t@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })\npublic @interface SpringBootApplication {\n....\n}\n</code></pre>\n<p>@SpringBootApplication这个注解其实是一个复合注解，主要由以下几个部分组成：</p>\n<ul><li>@Target用于设定注解使用范围，这里表明@SpringBootApplication注解可用于类或者接口上。@Retention表明是运行时注解，@Documented表明这个注解应该被 javadoc工具记录，@Inherited表明继承类也可以使用该注解；</li><li>@SpringBootConfiguraion表示要加载SpringBoot相关的一些配置；</li><li>@EnableAutoConfiguration注解用于自动装配，下面细讲；</li><li>@ComponentScan表明需要扫描的包；</li></ul>\n<h4><a id=\"2_EnableAutoConfiguration_37\"></a>2. @EnableAutoConfiguration注解</h4>\n<p>这里重点就是这个@EnableAutoConfiguration注解，它也是一个复合注解。看一下它的源码：</p>\n<pre><code>@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@AutoConfigurationPackage\n@Import(AutoConfigurationImportSelector.class)\npublic @interface EnableAutoConfiguration {\n\t....\n}\n</code></pre>\n<p>（1）其中@Import(AutoConfigurationImportSelector.class)这个注解就是用于<code>自动导入AutoConfigurationImportSelector这个类</code>。<br/> （2）然后<code>AutoConfigurationImportSelector的selectImports()方法</code>通过<code>SpringFactoriesLoader.loadFactoryNames()扫描</code>所有具有<code>META-INF/spring.factories</code>的jar包。其实每一个可以自动装配的jar里都有一个这样的spring.factories文件。<br/> （3）接着就根据这个spring.factories文件里配置的所有<code>JavaConfig自动配置类的全限定名</code>，找到所有对应的class，然后<code>将所有自动配置类加载到Spring容器中</code>。spring.factories文件示例如下：</p>\n<pre><code># Auto Configure\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\n</code></pre>\n<p>org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,<br/> org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,<br/> org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,<br/> org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,<br/> org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,<br/> org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,<br/> org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration<br/> …</p>\n<h4><a id=\"3_applicationpropertiesyml__68\"></a>3. application.properties.yml 配置加载</h4>\n<p>此外，我们通过application.properties.yml配置文件配置的&lt;key,value&gt;键值对属性是通过<code>相关联的某个AutoConfiguration类</code>，<br/> （1）比如application.properties.yml中的<code>server.port=8000</code>这个配置，就是通过<code>ServletWebServerFactoryAutoConfiguration类</code>加载的，这个类就是专门加载Servlet相关配置的一个自动装配类。看一下它的源码：</p>\n<pre><code>@Configuration\n@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)\n@ConditionalOnClass(ServletRequest.class)\n@ConditionalOnWebApplication(type = Type.SERVLET)\n@EnableConfigurationProperties(ServerProperties.class)\n@Import({ ServletWebServerFactoryAutoConfiguration.BeanPostProcessorsRegistrar.class,\n\t\tServletWebServerFactoryConfiguration.EmbeddedTomcat.class,\n\t\tServletWebServerFactoryConfiguration.EmbeddedJetty.class,\n\t\tServletWebServerFactoryConfiguration.EmbeddedUndertow.class })\npublic class ServletWebServerFactoryAutoConfiguration {\n\t......\n}\n</code></pre>\n<p>（2）然后这个ServletWebServerFactoryAutoConfiguration类通过<code>@EnableConfigurationProperties({ServerProperties.class})</code>这个注解来将配置文件中的属性注入到<code>ServerProperties</code>中：</p>\n<pre><code>@ConfigurationProperties(prefix = \"server\", ignoreUnknownFields = true)\npublic class ServerProperties {\n\tprivate Integer port;\n\t......\n}\n</code></pre>\n<p>（3）这个ServerProperties类的属性注入完成之后，又加载到了ServletWebServerFactoryAutoConfiguration类中，然后在SpringBoot启动时就可以获取到配置的端口号了。</p>\n<hr/>\n<p>THE END.</p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}