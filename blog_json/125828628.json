{"blogid": "125828628", "writerAge": "码龄1年", "writerBlogNum": "85", "writerCollect": "2632", "writerComment": "3307", "writerFan": "2911", "writerGrade": "6级", "writerIntegral": "8211", "writerName": "小黎的培培笔录", "writerProfileAdress": "writer_image\\profile_125828628.jpg", "writerRankTotal": "1688", "writerRankWeekly": "250", "writerThumb": "2970", "writerVisitNum": "77666", "blog_read_count": "524", "blog_time": "于 2022-07-26 17:28:48 发布", "blog_title": "「Java 数据结构」：手撕单链表的增删改查及大厂面试题。", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E4%B8%80%E3%80%81%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%80%E3%80%81%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5\">一、单链表的增删改查</a></p>\n<p id=\"1%E3%80%81%E5%88%9B%E5%BB%BA%E7%BB%93%E7%82%B9%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%C2%A0%E2%80%8B%E7%BC%96%E8%BE%91-toc\" style=\"margin-left:40px;\"><a href=\"#1%E3%80%81%E5%88%9B%E5%BB%BA%E7%BB%93%E7%82%B9%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%C2%A0%E2%80%8B%E7%BC%96%E8%BE%91\">1、创建结点        ​</a></p>\n<p id=\"2%E3%80%81%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%B7%BB%E5%8A%A0%E6%93%8D%E4%BD%9C-toc\" style=\"margin-left:40px;\"><a href=\"#2%E3%80%81%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%B7%BB%E5%8A%A0%E6%93%8D%E4%BD%9C\">2、单链表的添加操作</a></p>\n<p id=\"3%E3%80%81%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C-toc\" style=\"margin-left:40px;\"><a href=\"#3%E3%80%81%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C\">3、单链表的删除操作</a></p>\n<p id=\"%C2%A04%E3%80%81%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%9C%89%E6%95%88%E7%BB%93%E7%82%B9%E7%9A%84%E4%B8%AA%E6%95%B0-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A04%E3%80%81%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%9C%89%E6%95%88%E7%BB%93%E7%82%B9%E7%9A%84%E4%B8%AA%E6%95%B0\">4、单链表的有效结点的个数</a></p>\n<p id=\"%E4%BA%8C%E3%80%81%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E9%A2%98-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BA%8C%E3%80%81%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E9%A2%98\">二、大厂面试题</a></p>\n<p id=\"%C2%A01%E3%80%81%E6%96%B0%E6%B5%AA%E5%BE%AE%E5%8D%9A%EF%BC%9A%E6%9F%A5%E6%89%BE%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A01%E3%80%81%E6%96%B0%E6%B5%AA%E5%BE%AE%E5%8D%9A%EF%BC%9A%E6%9F%A5%E6%89%BE%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9\">1、新浪微博：查找单链表中倒数第k个结点</a></p>\n<p id=\"2%E3%80%81%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8F%8D%E8%BD%AC-toc\" style=\"margin-left:40px;\"><a href=\"#2%E3%80%81%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8F%8D%E8%BD%AC\">2、腾讯面试题：单链表的反转</a></p>\n<hr id=\"hr-toc\"/>\n<h1>一、单链表的增删改查</h1>\n<blockquote>\n<h2 id=\"1%E3%80%81%E5%88%9B%E5%BB%BA%E7%BB%93%E7%82%B9%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%C2%A0%E2%80%8B%E7%BC%96%E8%BE%91\">1、创建结点        </h2>\n<p style=\"text-align:center;\">      <img alt=\"\" src=\"image\\272eb243c61f4a06839c3404f60e0932.png\"/>    </p>\n<p>        单链表是由结点连接而成，所以我们首先要创建结点类，用于对结点进行操作。定义data属性 表示序号，定义name属性表示结点存放的数据信息，定义next属性表示指向下一个结点。构造器只需要放入data属性和name属性，重写toString方法方便打印结点信息。</p>\n<pre><code>public class Node {\n    public int data;\n    public String name;\n    public Node next;\n\n    public Node(int data, String name){\n        this.data = data;\n        this.name = name;\n    }\n\n    @Override\n    public String toString() {\n        return \"Node{\" +\n                \"data=\" + data +\n                \", name='\" + name + '\\'' +\n                '}';\n    }\n}</code></pre>\n<h2 id=\"2%E3%80%81%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%B7%BB%E5%8A%A0%E6%93%8D%E4%BD%9C\">2、单链表的添加操作</h2>\n<p><strong>▶ 首先创建头结点</strong></p>\n<p><strong>        </strong>此结点表示链表的头，不存放实际数据的。</p>\n<pre><code>private Node head = new Node(0,\"\");</code></pre>\n<p><strong>▶ 添加操作</strong></p>\n<p style=\"text-align:center;\"><strong><img alt=\"\" src=\"image\\0e31c5c3c1744c75a843e35937736acb.png\"/></strong></p>\n<p><strong>        </strong>将新的结点添加到链表的尾部，我们首先要遍历链表，找到链表的尾部，然后将最后一个结点的next指向新的结点，新结点的next指向NULL，这样就完成了链表的添加操作，这种每次添加到链表的尾部的操作称为尾插法。注意，当我们遍历链表时，需要一个辅助结点temp来进行遍历，因为head头结点不能动。</p>\n<pre><code>public class SingleLinkedList {\n\n    //首先创建头结点，此结点表示链表的头，无具体数据\n    private Node head = new Node(0,\"\");\n\n    //添加结点操作\n    public void addData(Node node){\n\n        Node temp = head;\n\n        while (true){\n            if (temp.next == null){\n                temp.next = node;\n                node.next = null;\n                break;\n            }\n            temp = temp.next;\n        }\n\n    }\n\n}</code></pre>\n<h2 id=\"3%E3%80%81%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C\">3、单链表的删除操作</h2>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\fd445dd6305e4cf4b6e18cfbef9f94d7.png\"/></p>\n<p>        假设我们要删除中间这个结点，我们只需要将这个结点的上一个结点的next指向这个结点的下一个结点（也就是将第一个结点的next指向第三个结点）。</p>\n<pre><code>     public void delData(Node node){\n\n        Node temp = head;\n\n        while (true){\n            //如果是要删除的结点\n            if (temp.next.data == node.data){\n                temp.next = temp.next.next;\n                break;\n            }else if(temp.next == null){\n                System.out.println(\"未找到结点！\");\n                break;\n            }\n            temp = temp.next;\n        }\n    }</code></pre>\n<h2 id=\"%C2%A04%E3%80%81%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%9C%89%E6%95%88%E7%BB%93%E7%82%B9%E7%9A%84%E4%B8%AA%E6%95%B0\"> 4、单链表的有效结点的个数</h2>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\4bb98aa454a842c0a87b4ceb643e097b.png\"/></p>\n<p>        我们可以定义一个计数的变量count，初始化为0，然后循环遍历链表，每遍历到一个结点，count就加一，这样就能求出单链表的有效个数。</p>\n<pre><code>    public int countData(){\n        Node temp = head.next;\n        int count = 0;\n        while (true){\n            if (temp == null){\n                break;\n            }\n            count++;\n            temp = temp.next;\n        }\n\n        return count;\n    }</code></pre>\n<p></p>\n</blockquote>\n<h1 id=\"%E4%BA%8C%E3%80%81%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E9%A2%98\">二、大厂面试题</h1>\n<blockquote>\n<h2 id=\"%C2%A01%E3%80%81%E6%96%B0%E6%B5%AA%E5%BE%AE%E5%8D%9A%EF%BC%9A%E6%9F%A5%E6%89%BE%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9\"> 1、新浪微博：查找单链表中倒数第k个结点</h2>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\9021abef80944e2c8ac7edecb9bcdb1f.png\"/></p>\n<p>         从上图可以看出，假设要找倒数第2个结点，我们该怎么做？不难看出，倒数第二个结点也是顺序的第三个结点，也就是将倒数的结点转换成顺序结点，遍历链表找到顺序结点即可。因为是有明确表示是第几个结点，所以我们需要知道结点的有效个数，前面我们介绍了有效个数的求法，直接用即可。当我们要找倒数第k个结点，我们可以转换成顺序的第（count - k + 1）个结点。比如：k = 2，count = 4， 倒数第2个结点也就是顺序第（4 - 2 + 1 = 3）个结点。</p>\n<pre><code>    public Node referNode(int n){\n\n        //根据前面计算有效个数的方法，求得链表总结点个数\n        int max = countData();\n\n        //计数\n        int count = 1;\n\n        //判断指定的结点是否在范围内\n        if (!(n &gt;= 1 &amp;&amp; n &lt;= max)){\n            throw new RuntimeException(\"没有此结点!\");\n        }\n\n        //辅助结点\n        Node temp = head.next;\n\n        //循环遍历查找\n        while (true){\n            //满足条件，则是我们要找的结点\n            if (count == (max - n + 1)){\n                return temp;\n            }else {\n                temp = temp.next;\n                count++;\n            }\n        }\n\n    }</code></pre>\n<h2 id=\"2%E3%80%81%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8F%8D%E8%BD%AC\">2、腾讯面试题：单链表的反转</h2>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\5b7b7ee343064ab497f7c9ec7d0d8871.png\"/></p>\n<p>         首先创建辅助变量temp用于循环原来的链表，辅助变量temp1记录temp的下一个位置，每遍历到一个结点就插入到新链表的头部，这种方式称为头插法。</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\04007353aa7e42e7add7502a8a41a56e.png\"/></p>\n<pre><code>public void nodeReversal(Node head){\n        //如果链表为空或链表只有一个结点，则不需要反转\n        if (head.next == null || head.next.next == null){\n            return;\n        }\n\n        //辅助变量temp\n        Node temp = head.next;\n        //辅助变量temp1\n        Node temp1 = null;\n\n        //循环遍历\n        while (true){\n            //退出循环的条件\n            if (temp == null){\n                break;\n            }\n\n            //首先将temp的下一个结点给temp1\n            temp1 = temp.next;\n\n            //然后将temp的next指向新链表头headReversal的next（头指向的下一个）\n            temp.next = headReversal.next;\n\n            //再然后将新链表头headReversal的next指向temp结点\n            headReversal.next = temp;\n\n            //最后将temp1记录的结点赋值给temp\n            temp = temp1;\n        }\n        //遍历结束，将新的顺序替换原来的顺序\n        head.next = headReversal.next;\n        //显示链表，这个方法需要自己写\n        showList(head);\n}</code></pre>\n<p></p>\n</blockquote>\n</div>\n</div>"}