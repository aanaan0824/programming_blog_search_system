{"blogid": "122776710", "writerAge": "码龄2年", "writerBlogNum": "52", "writerCollect": "293", "writerComment": "29", "writerFan": "1080", "writerGrade": "3级", "writerIntegral": "633", "writerName": "small建攻", "writerProfileAdress": "writer_image\\profile_122776710.jpg", "writerRankTotal": "32228", "writerRankWeekly": "60582", "writerThumb": "81", "writerVisitNum": "63003", "blog_read_count": "2523", "blog_time": "于 2022-02-03 22:41:50 发布", "blog_title": "Qt中ftp文件传输", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E4%B8%80%E3%80%81%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%80%E3%80%81%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87\">一、前期准备</a></p>\n<p id=\"%E4%BA%8C%E3%80%81Qt%E5%AE%9E%E7%8E%B0%E6%96%87%E6%A1%A3%E4%BC%A0%E8%BE%93-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BA%8C%E3%80%81Qt%E5%AE%9E%E7%8E%B0%E6%96%87%E6%A1%A3%E4%BC%A0%E8%BE%93\">二、Qt实现文档传输</a></p>\n<p id=\"1%E3%80%81%E5%87%86%E5%A4%87ftp%E4%BC%A0%E8%BE%93%E6%89%80%E4%BD%BF%E7%94%A8%E5%88%B0%E7%9A%84%E5%B7%A5%E5%85%B7%EF%BC%88%E5%A4%B4%E6%96%87%E4%BB%B6%EF%BC%89-toc\" style=\"margin-left:40px;\"><a href=\"#1%E3%80%81%E5%87%86%E5%A4%87ftp%E4%BC%A0%E8%BE%93%E6%89%80%E4%BD%BF%E7%94%A8%E5%88%B0%E7%9A%84%E5%B7%A5%E5%85%B7%EF%BC%88%E5%A4%B4%E6%96%87%E4%BB%B6%EF%BC%89\">1、准备ftp传输所使用到的工具（头文件）</a></p>\n<p id=\"2%E3%80%81%E4%BD%BF%E7%94%A8ftp%E5%AF%B9%E8%B1%A1%E5%B7%A5%E5%85%B7-toc\" style=\"margin-left:40px;\"><a href=\"#2%E3%80%81%E4%BD%BF%E7%94%A8ftp%E5%AF%B9%E8%B1%A1%E5%B7%A5%E5%85%B7\">2、使用ftp对象工具</a></p>\n<p id=\"%E6%80%BB%E7%BB%93%EF%BC%9A-toc\" style=\"margin-left:40px;\"><a href=\"#%E6%80%BB%E7%BB%93%EF%BC%9A\">总结：</a></p>\n<p id=\"%E6%8B%93%E5%B1%95%EF%BC%9A-toc\" style=\"margin-left:40px;\"><a href=\"#%E6%8B%93%E5%B1%95%EF%BC%9A\">拓展：</a></p>\n<hr id=\"hr-toc\"/>\n<h1>一、前期准备</h1>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p>首先ls查看目录，文档要是这样的绿标(这个文件夹要是读写权限，chmod 777+“加文件夹名字”)</p>\n<p>如Downloads<img alt=\"\" height=\"463\" src=\"image\\68d4aa28e798407f96d97cf924b04414.png\" width=\"716\"/></p>\n<p>然后输入下面2行命令</p>\n<p>①、配置环境 </p>\n<pre><code>sudo apt-get install vsftpd</code></pre>\n<p>②、修改文档信息 </p>\n<pre><code>sudo gedit /etc/vsftpd.conf</code></pre>\n<p> 注意没有#号的地方，把前面的#去掉</p>\n<p><img alt=\"\" height=\"1200\" src=\"image\\3a07c4b1f60b43868adade041537d973.png\" width=\"728\"/></p>\n<p> 之后就可以用这个文档传输助手进行传输</p>\n<p><img alt=\"\" height=\"364\" src=\"image\\986d90f0a5d543b48cc7a9f17b1ef18f.png\" width=\"672\"/></p>\n<p></p>\n<p><img alt=\"\" height=\"1042\" src=\"image\\a0a1de3d7d1e4d189b1ded20dd2c9d41.png\" width=\"1200\"/></p>\n<p></p>\n<p>        然而我们本篇则是教如何用QT实现ftp文档传输</p>\n<h1 id=\"%E4%BA%8C%E3%80%81Qt%E5%AE%9E%E7%8E%B0%E6%96%87%E6%A1%A3%E4%BC%A0%E8%BE%93\">二、Qt实现文档传输</h1>\n<h2 id=\"1%E3%80%81%E5%87%86%E5%A4%87ftp%E4%BC%A0%E8%BE%93%E6%89%80%E4%BD%BF%E7%94%A8%E5%88%B0%E7%9A%84%E5%B7%A5%E5%85%B7%EF%BC%88%E5%A4%B4%E6%96%87%E4%BB%B6%EF%BC%89\">1、准备ftp传输所使用到的工具（头文件）</h2>\n<p>ftp_sever.h</p>\n<pre><code class=\"language-cpp\">#ifndef FTP_SEVER_H\n#define FTP_SEVER_H\n\n#include &lt;QObject&gt;\n\n#include &lt;QNetworkAccessManager&gt;\n#include &lt;QNetworkReply&gt;\n#include &lt;QUrl&gt;\n\n#include &lt;QFile&gt;\n#include &lt;QFileInfo&gt;\n#include &lt;QDebug&gt;\n#include &lt;QMessageBox&gt;\n#include &lt;QFileDialog&gt;\nclass ftp_sever : public QObject\n{\n    Q_OBJECT\npublic:\n    explicit ftp_sever(QObject *parent = nullptr);\n    //设置登录信息\n    void setFtpAuthrity(const QString &amp;host,const QString&amp; userName,const QString &amp;password,quint16 port = 21);\n    \n    //上传和下载的功能\n    void getFilefromSever(const QString &amp;filename,const QString &amp;path);\n    void putFilefromSever(const QString &amp;filename,const QString &amp;path);\nsignals:\n    void downloadProgressSignal(qint64,qint64);\n    void uploadProgressSignal(qint64,qint64);\n\npublic slots:\n    //下载进度\n    void downloadProgressSlot(qint64,qint64);\n    //下载出错\n    void downloaderrorSlot(QNetworkReply::NetworkError);\n    //下载是否完成\n    void downloadFinishedSlot();\n    \n    //上传进度\n    void uploadProgressSlot(qint64,qint64);\n    //上传是否完成\n    void upLoadFinisheSlot();\n    //上传是否出错\n    void uploadErrorSlot(QNetworkReply::NetworkError err);\nprivate:\n    QUrl mUrl;//网络路径\n    QNetworkAccessManager mNetAccMag; //上传和下载的对象\n    QNetworkReply *putNewReply;       //上传\n    QNetworkReply *getNewReply;       //下载\n    \n    QFile* putfile;\n    QFile* getfile;\n    \n    \n};\n\n#endif // FTP_SEVER_H\n</code></pre>\n<p>ftp_sever.cpp</p>\n<pre><code class=\"language-cpp\">#include \"ftp_sever.h\"\n\nftp_sever::ftp_sever(QObject *parent) : QObject(parent)\n{\n    mUrl.setScheme(\"ftp\");  //设置协议\n}\n\nvoid ftp_sever::setFtpAuthrity(const QString &amp;host, const QString &amp;userName, const QString &amp;password, quint16 port)\n{\n    mUrl.setScheme(\"ftp\");\n    mUrl.setHost(host);\n    mUrl.setUserName(userName);\n    mUrl.setPassword(password);\n    mUrl.setPort(port);\n}\n\nvoid ftp_sever::getFilefromSever(const QString &amp;filename, const QString &amp;path)\n{\n    getfile = new QFile(filename,this);//保存在本地的路径\n    mUrl.setPath(path);                //设置从服务器下载的路径\n\n    if(getfile-&gt;open(QIODevice::WriteOnly))//打开文件\n    {\n        getNewReply = mNetAccMag.get(QNetworkRequest(mUrl));\n        connect(getNewReply,\n                SIGNAL(downloadProgress(qint64,qint64)),\n                this,\n                SLOT(downloadProgressSlot(qint64,qint64)));\n        connect(getNewReply,\n                SIGNAL(finished()),\n                this,\n                SLOT(downloadFinishedSlot())\n                );\n        connect(getNewReply,\n                SIGNAL(error(QNetworkReply::NetworkError)),\n                this,\n                SLOT(downloaderrorSlot(QNetworkReply::NetworkError))\n                );\n\n    }else{\n        delete getNewReply;\n        getNewReply = NULL;\n    }\n}\n\nvoid ftp_sever::putFilefromSever(const QString &amp;filename, const QString &amp;path)\n{\n    putfile = new QFile(filename,this);\n    QString saveFileName = path+\"/\"+QFileInfo(filename).fileName();//文件在服务器上的绝对路径\n    mUrl.setPath(saveFileName);\n\n    if(putfile-&gt;open(QIODevice::ReadOnly)){\n        putNewReply = mNetAccMag.put(QNetworkRequest(mUrl),putfile);\n\n        connect(putNewReply,\n                SIGNAL(uploadProgress(qint64,qint64)),\n                this,\n                SLOT(uploadProgressSlot(qint64,qint64))\n                );\n        connect(putNewReply,\n                SIGNAL(finished()),\n                this,\n                SLOT(upLoadFinisheSlot())\n                );\n        connect(putNewReply,\n                SIGNAL(error(QNetworkReply::NetworkError)),\n                this,\n                SLOT(uploadErrorSlot(QNetworkReply::NetworkError))\n                );\n    }else{\n        delete putfile;\n        putfile = NULL;\n    }\n}\n\n//x表示下载到哪       y表示最多可以下载多少\nvoid ftp_sever::downloadProgressSlot(qint64 x, qint64 y)\n{\n    emit downloadProgressSignal(x,y);\n\n    QByteArray ba = getNewReply-&gt;readAll();\n    if(ba.size())\n    {\n        getfile-&gt;write(ba);\n    }\n}\n\nvoid ftp_sever::downloaderrorSlot(QNetworkReply::NetworkError err)\n{\n    getNewReply-&gt;deleteLater();//等会释放\n    if(getfile){\n        getfile-&gt;close();\n        delete getfile;\n        getfile = NULL;\n    }\n\n    //\n}\n\nvoid ftp_sever::downloadFinishedSlot()\n{\n    getNewReply-&gt;deleteLater();//等会释放，考虑到延迟问题\n    if(getfile){\n        getfile-&gt;close();\n        delete getfile;\n        getfile = NULL;\n    }\n}\n\nvoid ftp_sever::uploadProgressSlot(qint64 x, qint64 y)\n{\n    emit uploadProgressSignal(x,y);\n}\n\nvoid ftp_sever::upLoadFinisheSlot()\n{\n    putNewReply-&gt;deleteLater();//等会释放，考虑到延迟问题\n    if(putfile){\n        putfile-&gt;close();\n        delete putfile;\n        putfile = NULL;\n    }\n}\n\nvoid ftp_sever::uploadErrorSlot(QNetworkReply::NetworkError err)\n{\n    putNewReply-&gt;deleteLater();//等会释放，考虑到延迟问题\n    if(putfile){\n        putfile-&gt;close();\n        delete putfile;\n        putfile = NULL;\n    }\n\n    //\n}\n</code></pre>\n<h2 id=\"2%E3%80%81%E4%BD%BF%E7%94%A8ftp%E5%AF%B9%E8%B1%A1%E5%B7%A5%E5%85%B7\">2、使用ftp对象工具</h2>\n<p>widget.h</p>\n<pre><code class=\"language-cpp\">#ifndef WIDGET_H\n#define WIDGET_H\n\n#include &lt;QWidget&gt;\n#include \"ftp_sever.h\"\n\nnamespace Ui {\nclass Widget;\n}\n\nclass Widget : public QWidget\n{\n    Q_OBJECT\n\npublic:\n    explicit Widget(QWidget *parent = 0);\n    ~Widget();\n\nprivate slots:\n    void on_pushButton_down_clicked();\n\n    void on_pushButton_up_clicked();\n    void downloadProgressSlot(qint64,qint64);\n    void uploadProgressSlot(qint64,qint64);\nprivate:\n    bool getFtpInfo();\nprivate:\n    Ui::Widget *ui;\n\n    ftp_sever mFtpAccmgr;\n    QString ftpHost;\n    QString ftpUserName;\n    QString ftpPsd;\n    qint16 ftpPort;\n\n};\n\n#endif // WIDGET_H\n</code></pre>\n<p>widget.cpp</p>\n<pre><code class=\"language-cpp\">#include \"widget.h\"\n#include \"ui_widget.h\"\n\nWidget::Widget(QWidget *parent) :\n    QWidget(parent),\n    ui(new Ui::Widget)\n{\n    ui-&gt;setupUi(this);\n    connect(&amp;mFtpAccmgr,\n            SIGNAL(downloadProgressSignal(qint64,qint64)),\n            this,\n            SLOT(downloadProgressSlot(qint64,qint64))\n            );\n    connect(&amp;mFtpAccmgr,\n            SIGNAL(uploadProgressSignal(qint64,qint64)),\n            this,\n            SLOT(uploadProgressSlot(qint64,qint64))\n            );\n}\n\nWidget::~Widget()\n{\n    delete ui;\n}\n\nbool Widget::getFtpInfo()\n{\n    //判断是否输入空\n    ftpHost=ui-&gt;lineEdit_host-&gt;text();\n    ftpPort=ui-&gt;lineEdit_port-&gt;text().toInt();\n    ftpPsd=ui-&gt;lineEdit_psd-&gt;text();\n    ftpUserName=ui-&gt;lineEdit_name-&gt;text();\n    if(ftpHost.isEmpty()&amp;&amp;ftpPsd.isEmpty()&amp;&amp;ftpUserName.isEmpty())\n        return false;\n    return true;\n}\n\nvoid Widget::on_pushButton_down_clicked()\n{\n    if(!getFtpInfo())\n    {\n        QMessageBox::critical(this,\"错误提示\",\"输入的端口号、密码或者用户名为空\");\n        return;\n    }\n    mFtpAccmgr.setFtpAuthrity(ftpHost,ftpUserName,ftpPsd,ftpPort);\n\n    QString downPath = ui-&gt;lineEdit_down-&gt;text();//从服务器下载的路径\n    QString filename = QFileInfo(downPath).fileName();\n    if(filename.isEmpty())\n    {\n        QMessageBox::critical(this,\"错误提示\",\"下载路径为空,\");\n        return;\n    }\n    QString savePath = QFileDialog::getSaveFileName(this,\"保存为\",filename);\n    mFtpAccmgr.getFilefromSever(savePath,downPath);\n}\n\n\nvoid Widget::downloadProgressSlot(qint64 x, qint64 y)\n{\n    ui-&gt;progressBar_down-&gt;setMaximum(y);\n    ui-&gt;progressBar_down-&gt;setValue(x);\n}\n\nvoid Widget::on_pushButton_up_clicked()\n{\n    ui-&gt;progressBar_up-&gt;setValue(0);\n    if(!getFtpInfo())\n    {\n        QMessageBox::critical(this,\"错误提示\",\"输入的端口号、密码或者用户名为空\");\n        return;\n    }\n    mFtpAccmgr.setFtpAuthrity(ftpHost,ftpUserName,ftpPsd,ftpPort);\n    QString fileName = QFileDialog::getOpenFileName(this,\"上传的文件\");\n    if(fileName.isEmpty())\n        return;\n    QString savePath = ui-&gt;lineEdit_up-&gt;text();\n    if(savePath.isEmpty())\n        return;\n    mFtpAccmgr.putFilefromSever(fileName,savePath);\n}\n\nvoid Widget::uploadProgressSlot(qint64 x,qint64 y)\n{\n    int fileSize=y/(1024*1024);\n    if(fileSize==0&amp;&amp;y&gt;0)    //当文件小于1m时候\n        fileSize=1;\n\n    int index=x/(1024*1024);\n    if(index==0&amp;&amp;x&gt;0)\n        index=1;\n    //qDebug()&lt;&lt;fileSize&lt;&lt;\" \"&lt;&lt;index;\n    ui-&gt;progressBar_up-&gt;setMaximum(fileSize);\n    ui-&gt;progressBar_up-&gt;setValue(index);\n}\n</code></pre>\n<p>效果展示:</p>\n<p><img alt=\"\" height=\"790\" src=\"https://img-blog.csdnimg.cn/686bd24024d446eb97f6136c9e90ec5e.gif\" width=\"1200\"/></p>\n<h2 id=\"%E6%80%BB%E7%BB%93%EF%BC%9A\">总结：</h2>\n<p>        首先由于不能跨线程，导致通过信号与槽的方式进行传输进度条来展示自己的下载进度</p>\n<p>        然后根据io操作读取文件的路径，文件名</p>\n<h2 id=\"%E6%8B%93%E5%B1%95%EF%BC%9A\">拓展：</h2>\n<pre><code>ifconfig   查看\nipps -ef | grep ftp     查看ftp服务器是否启动\nsudo netstat -anp |grep ftp       查看ftp的端口号</code></pre>\n<p></p>\n</div>\n</div>"}