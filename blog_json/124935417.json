{"blogid": "124935417", "writerAge": "码龄1年", "writerBlogNum": "22", "writerCollect": "54", "writerComment": "0", "writerFan": "4", "writerGrade": "2级", "writerIntegral": "220", "writerName": "Verdure", "writerProfileAdress": "writer_image\\profile_124935417.jpg", "writerRankTotal": "89665", "writerRankWeekly": "495454", "writerThumb": "10", "writerVisitNum": "15538", "blog_read_count": "1911", "blog_time": "于 2022-05-25 17:06:58 发布", "blog_title": "C++——深拷贝和浅拷贝", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h1>1.浅拷贝与深拷贝的区别</h1>\n<blockquote>\n<p>浅拷贝（默认拷贝函数）：将原对象或原数组的引用直接赋给新对象，新数组，新对象/新数组只是原对象的一个引用。</p>\n<p>深拷贝：创建一个新的对象和数组，将原对象的各项属性的“值”（数组的所有元素）拷贝过来，是“值”而不是引用</p>\n<p>深拷贝会在堆内存中另外申请空间来储存数据，从而解决了指针悬挂问题。<strong>当数据成员中有指针时，必须要用深拷贝</strong></p>\n</blockquote>\n<p><img alt=\"\" height=\"296\" src=\"image\\43b7bcd6f11945159a3a4213cb44449d.png\" width=\"635\"/></p>\n<p></p>\n<p>（1）如果拷贝的对象里的元素只有值，没有引用，那么深拷贝与浅拷贝是相同的。</p>\n<p>都会对原有对象复制一份，产生一个新对象，对新对象里的值进行修改不会影响原有对象，新对象与原对象完全分离开。</p>\n<p>（2）如果拷贝的对象里的元素包含引用（像一个列表中储存着另一个列表，存的就是另一个列表的引用），那么浅拷贝和深拷贝是不同的。</p>\n<p>浅拷贝虽然将原有对象复制一份，但是依然保存的是引用，所以对新对象里的引用里的值进行修改，依然会改变原对象里的列表的值，新对象与原对象并没有完全分离开。</p>\n<p>深拷贝不同，它会将原对象里的引用也新创建一个，即新建一个列表，然后放的是新列表的引用，这样就可以将新对象和原对象完全分开。</p>\n<h1>2.为什么要用深拷贝</h1>\n<p>在改变新的数组（对象）时，不会改变原数组（对象）</p>\n<h1>3.有指针时，必须用深拷贝</h1>\n<p>当数据成员中含有指针时，必须用深拷贝</p>\n<p>当用浅拷贝时，新对象的指针与原对象的指针指向了堆上的同一块儿内存，新对象和原对象析构时，新对象先把其指向的动态分配的内存释放了一次，而后原对象析构时又将这块已经释放过的内存再释放一次。对同一块动态内存执行2次以上释放的结果是未定义的，所有会导致内存泄漏或程序崩溃。</p>\n<p>所以需要深拷贝来解决问题，当拷贝对象中有对其他资源（如堆、文件、系统等）的引用时（引用可以是指针或引用）时，对象开辟一块新的资源，而不再对拷贝对象中对其他资源的引用的指针或引用进行单纯的赋值。</p>\n<h1>4.构造深拷贝</h1>\n<pre><code class=\"language-cs\">class MyString\n{\nprivate:\n   char *str;\npublic:\n   MyString(const char *p=nullstr)//缺省构造函数\n       :str(nullptr)\n  {\n     if(p!=nullptr)\n    {\n      int len=strlen(p)+1;\n      str=new char[len];\n      strcpy_s(str,lrn,p);\n     }\n  }\n\n   MyString(const MyString&amp; ms)//拷贝构造函数，深拷贝\n  {\n\t int n = strlen(ms.str) + 1;\n\t *str = new char[n];\n\t strcpy_s = (str, n, ms.str);\n     //int *str\n     // this-&gt;str=new int(*ms.str)\n  }\n\n   ~MyString()//析构函数\n  {\n  }\n}；</code></pre>\n<p></p>\n</div>\n</div>"}