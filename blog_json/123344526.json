{"blogid": "123344526", "writerAge": "码龄4年", "writerBlogNum": "543", "writerCollect": "2140", "writerComment": "161", "writerFan": "1170", "writerGrade": "7级", "writerIntegral": "9851", "writerName": "Peter_Gao_", "writerProfileAdress": "writer_image\\profile_123344526.jpg", "writerRankTotal": "1651", "writerRankWeekly": "10670", "writerThumb": "534", "writerVisitNum": "1539140", "blog_read_count": "5764", "blog_time": "已于 2022-03-09 09:09:02 修改", "blog_title": "C# List.Sort排序", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>C#中，List.Sort() 不仅为我们提供了默认的排序方法，还为我们提供了4种自定义排序的方法，通过默认排序方法，我们无需重写任何Sort()方法的实现代码，就能对单参数类型的List数据进行单一规则的排序，如果通过对这些方法进行改进我们可以轻松做到对多参数、多规则的复杂排序。</p>\n<h1><strong>C#  默认排序方法Sort、Reverse</strong></h1>\n<p>排序Sort,倒序Reverse</p>\n<pre><code class=\"language-html\">//默认是元素第一个字母按升序\nlist.Sort();\n//将List里面元素顺序反转\nlist.Reverse();\n//从第二个元素开始，反转4个元素\n//结果list里最后的顺序变成\"Ha\", \"Jay\", \"Lily\", \"Tom\", \"Hunter\", \"Jim\", \"Kuku\",  \"Locu\"\nlist.Reverse(1,4);</code></pre>\n<p></p>\n<h1><strong>C#自定义排序的4种方法</strong></h1>\n<pre><code class=\"language-cs\">List&lt;T&gt;.Sort();         \nList&lt;T&gt;.Sort(IComparer&lt;T&gt; Comparer);\nList&lt;T&gt;.Sort(int index, int count, IComparer&lt;T&gt; Comparer);\nList&lt;T&gt;.Sort(Comparison&lt;T&gt; comparison);</code></pre>\n<p><br/> 实现目标<br/> 假设存在一个People类，包含Name、Age属性，在客户端中创建List保存多个实例，希望对List中的内容根据Name和Age参数进行排序，排序规则为，先按姓名升序排序，如果姓名相同再按年龄的升序排序：<br/>  </p>\n<pre><code class=\"language-cs\">class People\n{\n    public People(string name, int age) { Name = name; Age = age; }\n    public string Name { get; set; } //姓名\n    public int Age { get; set; }  //年龄\n}\n \n// 客户端\nclass Client\n{\n    static void Main(string[] args)\n    {\n        List&lt;People&gt; peopleList = new List&lt;People&gt;();\n        peopleList.Add(new People(\"张三\", 22));\n        peopleList.Add(new People(\"张三\", 24));\n        peopleList.Add(new People(\"李四\", 18));\n        peopleList.Add(new People(\"王五\", 16));\n        peopleList.Add(new People(\"王五\", 30));\n    }\n}</code></pre>\n<h1>方法一、继承IComparable接口，实现CompareTo()方法</h1>\n<p>对People类继承IComparable接口，实现CompareTo()方法<br/> 该方法为系统默认的方法，单一参数时会默认进行升序排序。但遇到多参数（Name、Age）排序时，我们需要对该默认方法进行修改。</p>\n<p>方法一：People类继承IComparable接口，实现CompareTo()方法<br/> IComparable&lt;T&gt;：定义由值类型或类实现的通用比较方法，旨在创建特定于类型的比较方法以对实例进行排序。<br/> 原理：自行实现的CompareTo()方法会在list.Sort()内部进行元素两两比较，最终实现排序<br/>  </p>\n<pre><code class=\"language-cs\">class People : IComparable&lt;People&gt;\n{\n    public People(string name, int age) { Name = name;Age = age; }\n    public string Name { get; set; }\n    public int Age { get; set; }\n \n    // list.Sort()时会根据该CompareTo()进行自定义比较\n    public int CompareTo(People other)\n    {\n        if (this.Name != other.Name)\n        {\n            return this.Name.CompareTo(other.Name);\n        }\n        else if (this.Age != other.Age)\n        {\n            return this.Age.CompareTo(other.Age);\n        }\n        else return 0;\n    }\n}\n \n// 客户端\npeopleList.Sort();\n \n// OUTPUT:\n//      李四 18\n//      王五 16\n//      王五 30\n//      张三 22\n//      张三 24</code></pre>\n<h1>方法二：增加外部比较类，继承IComparer接口、实现Compare()方法</h1>\n<p>增加People类的外部比较类，继承IComparer接口、实现Compare()方法<br/> 区别于上述继承IComparable的方法，该方法不可在People内继承实现IComparer接口，而是需要新建比较方法类进行接口实现</p>\n<p>方法二：新建PeopleComparer类、继承IComparer接口、实现Compare()方法<br/> 原理：list.Sort()将PeopleComparer类的实例作为参数，在内部使用Compare()方法进行两两比较，最终实现排序（注：上述方法为CompareTo()，此处为Compare()方法）<br/>  </p>\n<pre><code class=\"language-cs\">// 自定义比较方法类\nclass PeopleComparer : IComparer&lt;People&gt;\n{\n    // 区别于CompareTo()单参数，此处为双参数\n    public int Compare(People x, People y)\n    {\n        if (x.Name != y.Name)\n        {\n            return x.Name.CompareTo(y.Name);\n        }\n        else if (x.Age != y.Age)\n        {\n            return x.Age.CompareTo(y.Age);\n        }\n        else return 0;\n    }\n}\n \n// 客户端\n// 传入参数为自定义比较类的实例            \npeopleList.Sort(new PeopleComparer());\n \n// OUTPUT:\n//      李四 18\n//      王五 16\n//      王五 30\n//      张三 22\n//      张三 24</code></pre>\n<p>同理，List&lt;T&gt;.Sort(int index, int count, IComparer&lt;T&gt; Comparer) 方法的参数：待排元素起始索引、待排元素个数、排序方法</p>\n<p></p>\n<h1>方法三、采用泛型委托 Comparison&lt;T&gt;，绑定自定义的比较方法</h1>\n<p><br/> 区别于上述继承接口的方法，此方法的参数为 泛型委托 Comparison&lt;T&gt;</p>\n<p>委托原型：public delegate int Comparison&lt;in T&gt;(T x, T y);<br/> 方法三：依照委托的使用方法，首先创建委托实例MyComparison，并绑定到自定义的比较方法PeopleComparison()上，最终调用list.Sort()时 将委托实例传入<br/> 原理：list.Sort()根据传入的委托方法，进行两两元素比较最终实现排序<br/>  </p>\n<pre><code class=\"language-cs\">// 客户端\nclass Client\n{\n    // 方法0 自定义比较方法\n    public static int PeopleComparison(People p1, People p2)\n    {\n        if (p1.Name != p2.Name)\n        {\n            return p1.Name.CompareTo(p2.Name);\n        }\n        else if (p1.Age != p2.Age)\n        {\n            return p1.Age.CompareTo(p2.Age);\n        }\n        else return 0;\n    }\n \n    static void Main(string[] args)\n    {\n        / 创建list ... /\n        \n        // 方法0 创建委托实例并绑定\n        Comparison&lt;People&gt; MyComparison = PeopleComparison;\n \n        // 传入该实例实现比较方法\n        peopleList.Sort(MyComparison);\n \n        // OUTPUT:\n        //      李四 18\n        //      王五 16\n        //      王五 30\n        //      张三 22\n        //      张三 24\n    }\n}</code></pre>\n<p></p>\n<h1>泛型委托用 <strong>Lambda表达式</strong></h1>\n<p>此外，既然<code>Comparison&lt;T&gt;</code>是泛型委托，则完全可以用 <strong>Lambda表达式</strong> 进行描述：</p>\n<pre><code class=\"language-cs\">// Lambda表达式实现Comparison委托\npeopleList.Sort((p1, p2) =&gt;\n{\n    if (p1.Name != p2.Name)\n    {\n        return p2.Name.CompareTo(p1.Name);\n    }\n    else if (p1.Age != p2.Age)\n    {\n        return p2.Age.CompareTo(p1.Age);\n    }\n    else return 0;\n});\n \n// OUTPUT:\n//      张三 24\n//      张三 22\n//      王五 30\n//      王五 16\n//      李四 18</code></pre>\n<p></p>\n<h1>总结</h1>\n<p><br/> 虽然本文仅使用了List&lt;T&gt;一种容器对Sort()方法进行阐述，但是不同容器的使用Sort()的方法大相径庭，因为核心的原理都是应用两种接口及泛型委托：</p>\n<p>两种接口：IComparable&lt;T&gt; 、 IComparer&lt;T&gt;<br/> 泛型委托：Comparison&lt;T&gt;<br/> 参考<br/> IComparable接口 - Microsoft <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.icomparable-1?view=netframework-4.8\" title=\"IComparable\">IComparable</a><br/> Comparison委托 - Microsoft <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.comparison-1?view=netframework-4.8\" title=\"Comparison\">Comparison</a><br/> IComparer接口 - Microsoft <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.icomparer?view=netframework-4.8\" title=\"IComparer 接口 (System.Collections) | Microsoft Docs\">IComparer 接口 (System.Collections) | Microsoft Docs</a><br/> IComparable和IComparer接口和自定义比较器 - My_Pure <a href=\"https://www.jianshu.com/p/2f2dd4829842\" title=\"C# IComparable和IComparer接口和自定义比较器 - 简书\">C# IComparable和IComparer接口和自定义比较器 - 简书</a></p>\n<p><br/>   附：一个完整的测试Demo</p>\n<pre><code class=\"language-cs\">using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n  \nnamespace ListSort\n{\n    class Program\n    {\n        static void DisplayInfo&lt;T&gt;(List&lt;T&gt; list) {\n            //输出List元素内容\n            foreach(var item in list) {\n                System.Console.Write(\"{0} \",item.ToString());\n            }\n            System.Console.WriteLine(\"\");\n        }\n \n        // 方法3 自定义委托泛型比较方法\n        public static int PeopleComparison(People p1, People p2)\n        {\n            if (p1.Name != p2.Name)\n            {\n                return p1.Name.CompareTo(p2.Name);\n            }\n            else if (p1.Age != p2.Age)\n            {\n                return p1.Age.CompareTo(p2.Age);\n            }\n            else return 0;\n        }\n        static void Main(string[] args)\n        {\n            List&lt;People&gt; peopleList = new List&lt;People&gt;();\n            peopleList.Add(new People(\"张三\", 22));\n            peopleList.Add(new People(\"张三\", 24));\n            peopleList.Add(new People(\"李四\", 18));\n            peopleList.Add(new People(\"王五\", 16));\n            peopleList.Add(new People(\"王五\", 30));\n \n            System.Console.WriteLine(\"排序前原始数据：\");\n            DisplayInfo(peopleList);\n            System.Console.WriteLine(\"------------------------------------\");\n \n            System.Console.WriteLine(\"方法1排序后数据：\");\n            peopleList.Sort();\n            DisplayInfo(peopleList);\n \n            System.Console.WriteLine(\"方法2排序后数据：\");\n            DisplayInfo(peopleList);\n \n            // 方法1 使用IComparer&lt;T&gt;接口。\n            peopleList.Sort(new PeopleComparer());\n  \n            // 方法2 除以上两种方法以外还可以使用另一种方法，在People类中实现IComparable&lt;T&gt;\n            peopleList.Sort();\n            System.Console.WriteLine(\"方法3排序后数据：\");\n            DisplayInfo(peopleList);\n \n            // 方法3 创建泛型委托实例并绑定\n            Comparison&lt;People&gt; MyComparison = PeopleComparison;\n \n            // 传入该实例实现比较方法\n            peopleList.Sort(MyComparison);\n \n            System.Console.WriteLine(\"方法3排序后数据：\");\n            DisplayInfo(peopleList);\n \n            // 方法3 使用Comparison&lt;T&gt;委托，Lambda写法\n            peopleList.Sort((left, right) =&gt;\n            {\n                //先按姓名排序，如果姓名相同再按年龄排序\n                int x = left.Name.CompareTo(right.Name);\n                if(x==0) {\n                    if (left.Age &gt; right.Age)\n                        x = 1;\n                    else if (left.Age == right.Age)\n                        x = 0;\n                    else\n                        x = -1;\n                }\n                return x;\n            });\n  \n        }\n    }\n \n　　//方法一\n    public class People : IComparable&lt;People&gt;\n    {\n        public int Age { get;set;}\n        public string Name { get;set;}\n        public People(string name,int age) {\n            this.Name = name;\n            this.Age = age;\n        }\n \n        public override string ToString() {\n            string result = \"\";\n            result = \"[\"+this.Name+\",\"+ this.Age.ToString()+\"]\";\n            return result;\n \n        }\n \n        public int CompareTo(People other)\n        {\n            int x = this.Name.CompareTo(other.Name);\n            if(x==0) {\n                if (this.Age &gt; other.Age)\n                    x = 1;\n                else if (this.Age == other.Age)\n                    x = 0;\n                else\n                    x = -1;\n            }\n            return x;\n        }\n    }\n \n   //方法二\n   public class PeopleComparer : IComparer&lt;People&gt;\n   {\n       public int Compare(People left, People right)\n       {\n            int x = left.Name.CompareTo(right.Name);\n            if(x==0) {\n                if (left.Age &gt; right.Age)\n                    x = 1;\n                else if (left.Age == right.Age)\n                    x = 0;\n                else\n                    x = -1;\n            }\n            return x;\n       }\n   }\n \n}   </code></pre>\n<p></p>\n</div>\n</div>"}