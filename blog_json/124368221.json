{"blogid": "124368221", "writerAge": "码龄2年", "writerBlogNum": "26", "writerCollect": "92", "writerComment": "5", "writerFan": "11", "writerGrade": "2级", "writerIntegral": "277", "writerName": "吾柳先生", "writerProfileAdress": "writer_image\\profile_124368221.jpg", "writerRankTotal": "84634", "writerRankWeekly": "493115", "writerThumb": "13", "writerVisitNum": "18664", "blog_read_count": "2367", "blog_time": "已于 2022-05-01 20:11:17 修改", "blog_title": "C++八股文之基础知识点总结", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h2><a id=\"C_0\"></a>C++基础</h2>\n<h4><a id=\"1_C_2\"></a>1 C++特点</h4>\n<ol><li>C++在C语言基础上引入了<strong>面对对象</strong>的机制，同时也<strong>兼容C语言</strong>。</li><li>C++有三大特性<font color=\"red\">（1）封装。（2）继承。（3）多态；</font></li><li>C++语言编写出的程序结构清晰、易于扩充，程序<strong>可读性好</strong>。</li><li>C++生成的代码<strong>质量高</strong>，<strong>效率高</strong>，</li><li>C++更加安全，增加了const常量、引用、四类cast转换（static_cast、dynamic_cast、const_cast、reinterpret_cast）、智能指针、try—catch等等；</li><li>C++<strong>可复用性</strong>高，C++引入了<strong>模板</strong>的概念，标准模板库STL（Standard Template Library）。</li></ol>\n<h4><a id=\"2_CC_11\"></a>2 说说C语言和C++的区别</h4>\n<ol><li>C语言是C++的子集，C++可以很好兼容C语言。但是C++又有很多<strong>新特性</strong>，如引用、智能指针、auto变量等。</li><li>C++是<strong>面对对象</strong>的编程语言；C语言是<strong>面对过程</strong>的编程语言。</li><li>C语言有一些不安全的语言特性，如指针使用的潜在危险、强制转换的不确定性、内存泄露等。而C++对此增加了不少新特性来<strong>改善安全性</strong>，如const常量、引用、cast转换、智能指针、try—catch等等；</li><li>C++<strong>可复用性</strong>高，C++引入了<strong>模板</strong>的概念，后面在此基础上，实现了方便开发的标准模板库STL。C++的STL库相对于C语言的函数库<strong>更灵活、更通用</strong>。</li></ol>\n<h4><a id=\"3__C_struct__class__18\"></a>3 说说 C++中 struct 和 class 的区别</h4>\n<ol><li>struct 一般用于描述一个<font color=\"red\">数据结构集合</font>，而 class 是对一个<font color=\"red\">对象数据的封装</font>；</li><li>struct 中默认的访问控制权限<strong>是 public 的</strong>，而 class 中默认的访问控制权限<strong>是 private 的</strong>。</li><li>在继承关系中，struct 默认是<strong>公有继承</strong>，而 class 是<strong>私有继承</strong>；</li><li>class 关键字可以用于定义模板参数，就像 typename，而 struct 不能用于定义模板参数，</li></ol>\n<h4><a id=\"4_include_25\"></a>4 include头文件的顺序以及双引号\"\"和尖括号&lt;&gt;的区别</h4>\n<ol><li> <p>区别：</p> <p>（1）尖括号&lt;&gt;的头文件是<strong>系统文件</strong>，双引号\"\"的头文件是<strong>自定义文件</strong>。</p> <p>（2）编译器预处理阶段查找头文件的路径不一样。</p> </li><li> <p>查找路径：</p> <p>（1）使用尖括号&lt;&gt;的头文件的查找路径：编译器设置的头文件路径–&gt;系统变量。</p> <p>（2）使用双引号\"\"的头文件的查找路径：当前头文件目录–&gt;编译器设置的头文件路径–&gt;系统变量。</p> </li></ol>\n<h4><a id=\"5_CC_39\"></a>5 说说C++结构体和C结构体的区别</h4>\n<p>区别：</p>\n<p>（1）C的结构体内<font color=\"red\">不允许有函数存在</font>，C++<font color=\"cornflowerblue\">允许有内部成员函数，且允许该函数是虚函数</font>。</p>\n<p>（2）C的结构体对内部成员变量的<font color=\"red\">访问权限只能是public</font>，而<font color=\"red\">C++允许public,protected,private三种</font>。</p>\n<p>（3）C语言的结构体是<font color=\"red\">不可以继承的</font>，C++的结构体<font color=\"red\">可继承</font>。</p>\n<p>（4）C 中<font color=\"cornflowerblue\">使用结构体需要加上 struct 关键字</font>，而 <font color=\"red\">C++ 中可以省略</font> struct 关键字直接使用。</p>\n<ol><li> <p>C++ 中的 struct 是对 C 中的 struct 进行了扩充，它们在声明时的区别如下：</p>\n<table><thead><tr><th align=\"center\"></th><th align=\"center\">C</th><th align=\"center\">C++</th></tr></thead><tbody><tr><td align=\"center\">成员函数</td><td align=\"center\">不能有</td><td align=\"center\">可以</td></tr><tr><td align=\"center\">静态成员</td><td align=\"center\">不能有</td><td align=\"center\">可以</td></tr><tr><td align=\"center\">访问控制</td><td align=\"center\">默认public，不能修改</td><td align=\"center\">public/private/protected</td></tr><tr><td align=\"center\">继承关系</td><td align=\"center\">不可以继承</td><td align=\"center\">可从类或者其他结构体继承</td></tr><tr><td align=\"center\">初始化</td><td align=\"center\">不能直接初始化数据成员</td><td align=\"center\">可以</td></tr></tbody></table></li></ol>\n<h4><a id=\"6_CCC_61\"></a>6 导入C函数的关键字是什么，C++编译时和C有什么不同？</h4>\n<ol><li><strong>关键字：<strong>在C++中，导入C函数的关键字是</strong>extern</strong>，表达形式为<strong>extern “C”</strong>， extern \"C\"的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern \"C\"后，会指示编译器这部分代码按<strong>C语言</strong>的进行编译，而不是C++的。</li><li><strong>编译区别：<strong>由于C++支持函数重载，因此编译器编译函数的过程中会将函数的</strong>参数类型</strong>也加到编译后的代码中，而不仅仅是<strong>函数名</strong>；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括<strong>函数名</strong>。</li></ol>\n<h4><a id=\"7_C_66\"></a>7 C++从代码到可执行二进制文件的过程</h4>\n<p>C++和C语言类似，一个C++程序从源码到执行文件，有四个过程，<strong>预编译、编译、汇编、链接</strong>。</p>\n<p><strong>预编译</strong>：这个过程主要的处理操作如下：</p>\n<ul><li> <p>将所有的#define删除，并且展开所有的宏定义</p> </li><li> <p>处理所有的条件预编译指令，如#if、#ifdef</p> </li><li> <p>处理#include预编译指令，将被包含的文件插入到该预编译指令的位置。</p> </li><li> <p>过滤所有的注释</p> </li><li> <p>添加行号和文件名标识。</p> </li></ul>\n<p><strong>编译</strong>：这个过程主要的处理操作如下：</p>\n<ul><li> <p>词法分析：将源代码的字符序列分割成一系列的记号。</p> </li><li> <p>语法分析：对记号进行语法分析，产生语法树。</p> </li><li> <p>语义分析：判断表达式是否有意义。</p> </li><li> <p>代码优化。</p> </li><li> <p>目标代码生成：生成汇编代码。</p> </li><li> <p>目标代码优化。</p> </li></ul>\n<p><strong>汇编</strong>：这个过程主要是将汇编代码转变成机器可以执行的指令。</p>\n<p><strong>链接</strong>：将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。</p>\n<p>链接分为<font color=\"red\">静态链接和动态链接</font>。</p>\n<p><font color=\"cornflowerblue\">静态链接</font>，是在链接的时候就已经把要调用的函数或者过程链接到了生成的可执行文件中，就算你在去把静态库删除也不会影响可执行程序的执行；生成的静态链接库，Windows下以.lib为后缀，Linux下以.a为后缀。</p>\n<p><font color=\"cornflowerblue\">动态链接</font>，是在链接的时候没有把调用的函数代码链接进去，而是在执行的过程中，再去找要链接的函数，生成的可执行文件中没有函数代码，只包含函数的重定位信息，所以当你删除动态库时，可执行程序就不能运行。生成的动态链接库，Windows下以.dll为后缀，Linux下以.so为后缀。</p>\n<h4><a id=\"8__static_105\"></a>8 说说 static关键字的作用</h4>\n<ol><li><strong>定义全局静态变量和局部静态变量</strong>：初始化的静态变量会在数据段分配内存，未初始化的静态变量会在BSS段分配内存。直到程序结束，静态变量始终会维持前值。</li><li><strong>定义静态函数</strong>：静态函数只能在<strong>本源文件</strong>中使用；如<code>static void func();</code></li><li><strong>定义静态变量</strong>。<strong>静态变量只能在本源文件中使用</strong>；</li><li>定义<font color=\"red\">类中的静态成员变量</font>：使用静态数据成员，它既可以被当成全局变量那样去存储，但又被隐藏在类的内部。类中的static静态数据成员拥有一块单独的存储区，而不管创建了多少个该类的对象。所有这些对象的静态数据成员都<strong>共享</strong>这一块静态存储空间。</li><li><strong>定义类中的静态成员函数</strong>：如静态成员函数也是类的一部分，而不是对象的一部分。所有这些对象的静态数据成员都<strong>共享</strong>这一块静态存储空间。</li></ol>\n<p>此外：</p>\n<p>当调用一个对象的非静态成员函数时，系统会把该对象的起始地址赋给成员函数的this指针。而<font color=\"red\"><strong>静态成员函数不属于任何一个对象，因此C++规定静态成员函数没有this指针</strong></font>。既然它没有指向某一对象，也就无法对一个对象中的非静态成员进行访问。</p>\n<h4><a id=\"9__117\"></a>9 数组和指针的区别</h4>\n<ol><li> <p>概念：</p> <p>（1）数组：数组是用于<font color=\"red\">储存多个相同类型数据的集合</font>。 <font color=\"cornflowerblue\">数组名是首元素的地址。</font></p> <p>（2）指针：指针相当于一个<font color=\"red\">变量</font>，它存放的是其它变量在<strong>内存中的地址</strong>。 指针名指向了内存的首地址。</p> </li><li> <p>区别：</p> <p>（1）<strong>赋值</strong>：同类型指针变量可以相互赋值；数组不行，只能一个一个元素的赋值或拷贝</p> <p>（2）<strong>存储方式</strong>：</p> <p>数组：数组在内存中是<font color=\"red\">连续存放的</font>，数组的存储空间，不是在静态区就是在栈上。</p> <p>指针：指针很灵活，它可以指向任意类型的数据。指针的类型说明了它所指向地址空间的内存。由于指针本身就是一个变量，再加上它所存放的也是变量，所以指针的存储空间不能确定。</p> <p>（3）<strong>求sizeof</strong>：</p> <p>数组所占存储空间的内存大小：sizeof（数组名）/sizeof（数据类型）</p> <p>在32位平台下，无论指针的类型是什么，sizeof（指针名）都是4，在64位平台下，无论指针的类型是什么，sizeof（指针名）都是8。</p> </li></ol>\n<h4><a id=\"10__141\"></a>10 说说什么是函数指针，如何定义函数指针，有什么使用场景</h4>\n<ol><li><strong>概念：<strong>函数指针就是</strong>指向函数</strong>的指针变量。每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。</li><li><strong>定义</strong>形式如下：</li></ol>\n<pre><code class=\"prism language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n<span class=\"token keyword\">int</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>f<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \nf <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>func<span class=\"token punctuation\">;</span>  \n</code></pre>\n<ol><li>函数指针的<strong>应用场景</strong>：<strong>回调</strong>（callback）。我们调用别人提供的 API函数(Application Programming Interface,应用程序编程接口)，称为Call；如果别人的库里面调用我们的函数，就叫Callback。</li></ol>\n<h4><a id=\"11__154\"></a>11 静态变量什么时候初始化？</h4>\n<p>对于C语言的全局和静态变量，<font color=\"red\">初始化发生在任何代码执行之前</font>，属于编译期初始化。</p>\n<p>而C++标准规定：全局或静态对象当且仅<strong>当对象<font color=\"red\">首次用到时才进行构造</font></strong>。</p>\n<h4><a id=\"12_nullptr_160\"></a>12 nullptr调用成员函数可以吗？为什么？</h4>\n<p>能。</p>\n<p>原因：因为在<strong>编译时对象</strong>就绑定了<strong>函数地址</strong>，和指针空不空没关系。</p>\n<h4><a id=\"13__166\"></a>13 说说什么是野指针，怎么产生的，如何避免</h4>\n<ol><li> <p><strong>概念</strong>：野指针就是指针指向的位置是不可知的（随机的、不正确的、没有明确限制的）</p> </li><li> <p><strong>产生原因</strong>：释放内存后指针不及时置空（野指针），依然指向了该内存，那么可能出现非法访问的错误。这些我们都要注意避免。</p> </li><li> <p><strong>避免办法</strong>：</p> <p>（1）初始化置NULL</p> <p>（2）申请内存后判空</p> <p>（3）指针释放后置NULL</p> <p>（4）使用智能指针</p> </li></ol>\n<h4><a id=\"14__182\"></a>14 说说静态局部变量，全局变量，局部变量的特点，以及使用场景</h4>\n<ol><li> <p><strong>首先从作用域考虑</strong>：C++里作用域可分为6种：全局，局部，类，语句，命名空间和文件作用域。</p> <p>全局变量：全局作用域，可以通过extern作用于其他非定义的源文件。</p> <p>静态全局变量 ：全局作用域+文件作用域，所以无法在其他文件中使用。</p> <p>局部变量：局部作用域，比如函数的参数，函数内的局部变量等等。</p> <p>静态局部变量 ：局部作用域，只被初始化一次，直到程序结束。</p> </li><li> <p><strong>从所在空间考虑</strong>：除了局部变量在栈上外，其他都在静态存储区。因为静态变量都在静态存储区，所以下次调用函数的时候还是能取到原来的值。</p> </li><li> <p><strong>生命周期</strong>： 局部变量在栈上，出了作用域就回收内存；而全局变量、静态全局变量、静态局部变量都在静态存储区，直到程序结束才会回收内存。</p> </li></ol>\n<h4><a id=\"15__198\"></a>15 说说内联函数和宏函数的区别</h4>\n<p>区别：</p>\n<ol><li><strong>宏定义不是函数</strong>，但是使用起来像函数。预处理器用复制宏代码的方式代替函数的调用，省去了函数压栈退栈过程，提高了效率；<strong>而内联函数本质上是一个函数</strong>，内联函数一般用于函数体的代码比较简单的函数，不能包含复杂的控制语句，while、switch，并且内联函数本身不能直接调用自身。</li><li><strong>宏函数</strong>是在预编译的时候把所有的宏名用宏体来替换，简单的说就是字符串替换 ；<strong>而内联函数</strong>则是在编译的时候进行代码插入，编译器会在每处调用内联函数的地方直接把内联函数的内容展开，这样可以省去函数的调用的开销，提高效率</li><li><strong>宏定义</strong>是<font color=\"red\">没有类型检查的</font>，无论对还是错都是直接替换；<strong>而内联函数</strong>在编译的时候会进行类型的检查，内联函数满足函数的性质，比如有返回值、参数列表等。</li></ol>\n<p><strong>内联函数使用的条件：</strong></p>\n<ul><li>内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率 的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。以下情况不宜使用内联：</li><li>（1）如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。</li><li>（2）如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。</li><li>内联不是什么时候都能展开的，一个好的编译器将会根据函数的定义体，自动地取消不符合要求的内联。</li></ul>\n<h4><a id=\"17_newmalloc_213\"></a>17 说说new和malloc的区别，各自底层实现原理。</h4>\n<ol><li>new是操作符，而malloc是函数。</li><li>new在调用的时候<strong>先分配内存，在调用构造函数，释放的时候调用析构函数</strong>；而malloc没有构造函数和析构函数。</li><li>**malloc需要给定申请内存的大小，**返回的指针需要强转；new会调用构造函数，不用指定内存的大小，返回指针不用强转。</li><li><strong>new可以被重载</strong>；malloc不行</li><li><strong>new分配内存更直接和安全</strong>。</li><li><strong>new发生错误抛出异常</strong>，malloc返回null</li></ol>\n<p><strong>malloc底层实现</strong>：当开辟的空间小于 128K 时，调用 brk（）函数；当开辟的空间大于 128K 时，调用mmap（）。malloc采用的是内存池的管理方式，以减少内存碎片。先申请大块内存作为堆区，然后将堆区分为多个内存块。当用户申请内存时，直接从堆区分配一块合适的空闲快。采用隐式链表将所有空闲块，每一个空闲块记录了一个未分配的、连续的内存地址。</p>\n<p><strong>new底层实现</strong>：关键字new在调用构造函数的时候实际上进行了如下的几个步骤：</p>\n<ol><li>创建一个新的对象</li><li>将构造函数的作用域赋值给这个新的对象（因此this指向了这个新的对象）</li><li>执行构造函数中的代码（为这个新对象添加属性）</li><li>返回新对象</li></ol>\n<h4><a id=\"18_constdefine_231\"></a>18 说说const和define的区别。</h4>\n<p>const用于定义<strong>常量</strong>；而define用于<strong>定义宏</strong>，而宏也可以用于定义常量。都用于常量定义时，它们的区别有：</p>\n<ol><li>const生效于编译的阶段；define生效于预处理阶段。</li><li>const定义的常量，在C语言中<font color=\"red\">是存储在内存中、需要额外的内存空间的</font>；define定义的常量，运行时<font color=\"red\">是直接的操作数，并不会存放在内存中</font>。</li><li>const定义的常量<font color=\"cornflowerblue\">是带类型的</font>；define定义的常量<font color=\"cornflowerblue\">不带类型</font>。因此define定义的常量不利于类型检查。</li></ol>\n<h4><a id=\"19_C_239\"></a>19 说说C++中函数指针和指针函数的区别。</h4>\n<ol><li> <p><strong>定义不同</strong><br/> 指针函数本质是一个函数，其返回值为指针。<br/> 函数指针本质是一个指针，其指向一个函数。</p> </li><li> <p><strong>写法不同</strong></p> <pre><code class=\"prism language-c\">指针函数：<span class=\"token keyword\">int</span> <span class=\"token operator\">*</span><span class=\"token function\">fun</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n函数指针：<span class=\"token keyword\">int</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>fun<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre> </li></ol>\n<h4><a id=\"20_const_int_a_int_const_a_const_int_a_int_const_a_const_int_const_a_255\"></a>20 说说const int *a, int const *a, const int a, int *const a, const int *const a分别是什么，有什么特点。</h4>\n<pre><code class=\"prism language-c\"><span class=\"token number\">1.</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> a<span class=\"token punctuation\">;</span>     <span class=\"token comment\">//指的是a是一个常量，不允许修改。</span>\n<span class=\"token number\">2.</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>a<span class=\"token punctuation\">;</span>    <span class=\"token comment\">//a指针所指向的内存里的值不变，即（*a）不变</span>\n<span class=\"token number\">3.</span> <span class=\"token keyword\">int</span> <span class=\"token keyword\">const</span> <span class=\"token operator\">*</span>a<span class=\"token punctuation\">;</span>    <span class=\"token comment\">//同const int *a;</span>\n<span class=\"token number\">4.</span> <span class=\"token keyword\">int</span> <span class=\"token operator\">*</span><span class=\"token keyword\">const</span> a<span class=\"token punctuation\">;</span>    <span class=\"token comment\">//a指针所指向的内存地址不变，即a不变</span>\n<span class=\"token number\">5.</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> <span class=\"token operator\">*</span><span class=\"token keyword\">const</span> a<span class=\"token punctuation\">;</span>   <span class=\"token comment\">//都不变，即（*a）不变，a也不变</span>\n</code></pre>\n<h4><a id=\"21__265\"></a>21 说说使用指针需要注意什么？</h4>\n<ol><li>定义指针时，先初始化为NULL。</li><li>用malloc或new申请内存之后，应该<strong>立即检查</strong>指针值是否为NULL。防止使用指针值为NULL的内存。</li><li>不要忘记为数组和动态内存<strong>赋初值</strong>。防止将未被初始化的内存作为右值使用。</li><li>避免数字或指针的下标<strong>越界</strong>，特别要当心发生“多1”或者“少1”操作</li><li>动态内存的申请与释放必须配对，防止<strong>内存泄漏</strong></li><li>用free或delete释放了内存之后，立即将指针<strong>设置为NULL</strong>，防止“野指针”</li></ol>\n<h4><a id=\"22__274\"></a>22 说说内联函数和函数的区别，内联函数的作用。</h4>\n<ol><li>内联函数比普通函数多了关键字<strong>inline</strong></li><li>内联函数避免了函数调用的<strong>开销</strong>；普通函数有调用的开销</li><li><font color=\"red\">普通函数在被调用的时候，需要<strong>寻址（函数入口地址）</strong>；内联函数不需要寻址。</font></li><li>内联函数有一定的限制，内联函数体要求<strong>代码简单</strong>，不能包含复杂的结构控制语句；普通函数没有这个要求。</li></ol>\n<p><strong>内联函数的作用</strong>：内联函数在调用时，是将调用表达式用内联函数体来替换。避免函数调用的开销。</p>\n<h4><a id=\"23_C_283\"></a>23 简述C++有几种传值方式，之间的区别是什么？</h4>\n<p>传参方式有这三种：<strong><font color=\"red\">值传递、引用传递、指针传递</font></strong></p>\n<ol><li>值传递：形参即使在函数体内值发生变化，也不会影响实参的值；</li><li>引用传递：形参在函数体内值发生变化，会影响实参的值；</li><li>指针传递：在指针指向没有发生改变的前提下，形参在函数体内值发生变化，会影响实参的值；</li></ol>\n<ul><li><font color=\"red\">值传递用于对象时，整个对象会拷贝一个副本，这样效率低；而引用传递用于对象时，不发生拷贝行为，只是绑定对象，更高效；指针传递同理，但不如引用传递安全。</font></li></ul>\n<h4><a id=\"24_constconst_294\"></a>24 简述const（星号）和（星号）const的区别</h4>\n<pre><code class=\"prism language-c\"><span class=\"token comment\">//const* 是指针常量，*const 是常量指针</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token keyword\">const</span> <span class=\"token operator\">*</span>a<span class=\"token punctuation\">;</span>    <span class=\"token comment\">//a指针所指向的内存里的值不变，即（*a）不变，指针可变</span>\n<span class=\"token keyword\">int</span> <span class=\"token operator\">*</span><span class=\"token keyword\">const</span> a<span class=\"token punctuation\">;</span>    <span class=\"token comment\">//a指针所指向的内存地址不变，即a不变，其所指内存值可变。</span>\n</code></pre>\n<p>详细PDF文件请点击链接下载：<a href=\"https://download.csdn.net/download/m0_47999117/85203190\">详细的PDF文件</a></p>\n<p>声明：本资料基于网络上资源整理，仅供学习。如有侵权，请联系删除。</p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}