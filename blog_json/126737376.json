{"blogid": "126737376", "writerAge": "码龄1年", "writerBlogNum": "92", "writerCollect": "6732", "writerComment": "12588", "writerFan": "13161", "writerGrade": "7级", "writerIntegral": "19716", "writerName": "微凉秋意", "writerProfileAdress": "writer_image\\profile_126737376.jpg", "writerRankTotal": "415", "writerRankWeekly": "1", "writerThumb": "7539", "writerVisitNum": "122995", "blog_read_count": "147", "blog_time": "已于 2022-09-07 07:38:58 修改", "blog_title": "牛客网《剑指offer》专栏刷题练习之二叉树合集", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-github-gist\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<blockquote>\n<p><strong>✅作者简介：热爱后端语言的大学生，CSDN内容合伙人</strong><br/> <strong>✨精品专栏：<a href=\"https://blog.csdn.net/m0_58618795/category_11803944.html?spm=1001.2014.3001.5482\">C++面向对象</a></strong><br/> <strong>🔥系列专栏：<a href=\"https://blog.csdn.net/m0_58618795/category_11905274.html?spm=1001.2014.3001.5482\">剑指offer</a></strong><br/> <strong>📃推荐一款模拟面试、刷题神器👉<a href=\"https://www.nowcoder.com/link/pc_csdncpt_ylqb_c\">注册免费刷题</a></strong></p>\n</blockquote>\n<p></p>\n<div class=\"toc\">\n<h3>二叉树题解目录</h3>\n<ul><li><a href=\"#_8\">🔥前言</a></li><li><a href=\"#1_11\">1、二叉树的下一个结点</a></li><li><ul><li><a href=\"#11_12\">1.1、题目速览</a></li><li><a href=\"#12_15\">1.2、个人题解</a></li><li><ul><li><a href=\"#121_16\">1.2.1、解题思路</a></li><li><a href=\"#122_25\">1.2.2、代码实现</a></li><li><a href=\"#123_67\">1.2.3、代码解析</a></li></ul>\n</li></ul>\n</li><li><a href=\"#2_72\">2、对称的二叉树</a></li><li><ul><li><a href=\"#21_73\">2.1、题目速览</a></li><li><a href=\"#22_76\">2.2、个人题解</a></li><li><ul><li><a href=\"#221_77\">2.2.1、解题思路</a></li><li><a href=\"#222_86\">2.2.2、代码实现</a></li><li><a href=\"#223_113\">2.2.3、代码解析</a></li></ul>\n</li></ul>\n</li></ul>\n</div>\n<p></p>\n<hr/>\n<h1><a id=\"_8\"></a>🔥前言</h1>\n<blockquote>\n<p>本篇文章给大家分享牛客网《剑指offer》专栏中有关二叉树的经典算法题解，我会按照自己的理解与思路帮助大家搞懂算法流程。</p>\n</blockquote>\n<h1><a id=\"1_11\"></a>1、二叉树的下一个结点</h1>\n<h2><a id=\"11_12\"></a>1.1、题目速览</h2>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\2e3137470fb04e408c05ecff3c985132.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"image\\a315366f5c4b4781a35f73d4a975ce2c.png\"/></p>\n<h2><a id=\"12_15\"></a>1.2、个人题解</h2>\n<h3><a id=\"121_16\"></a>1.2.1、解题思路</h3>\n<blockquote>\n<p><strong>1. 我们首先要根据给定输入中的结点指针向父级进行迭代，直到找到该树的根节点；</strong><br/> <strong>2. 然后根据根节点进行中序遍历，当遍历到和给定树节点相同的节点时，下一个节点就是我们的目标返回节点</strong></p>\n</blockquote>\n<p><em>具体步骤：</em></p>\n<ol><li>根据当前结点，利用题目所给条件找到根结点</li><li>书写中序遍历的函数，传入根结点</li><li>将中序遍历的结点储存在结点数组里</li><li>将传入的二叉树结点与数组元素匹配，返回数组的下一个元素</li></ol>\n<h3><a id=\"122_25\"></a>1.2.2、代码实现</h3>\n<pre><code class=\"prism language-cpp\"><span class=\"token comment\">/*\nstruct TreeLinkNode {\n    int val;\n    struct TreeLinkNode *left;\n    struct TreeLinkNode *right;\n    struct TreeLinkNode *next;\n    TreeLinkNode(int x) :val(x), left(NULL), right(NULL), next(NULL) {\n        \n    }\n};\n*/</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    vector<span class=\"token operator\">&lt;</span>TreeLinkNode<span class=\"token operator\">*</span><span class=\"token operator\">&gt;</span>nodes<span class=\"token punctuation\">;</span>\n    TreeLinkNode<span class=\"token operator\">*</span> <span class=\"token function\">GetNext</span><span class=\"token punctuation\">(</span>TreeLinkNode<span class=\"token operator\">*</span> pNode<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n        TreeLinkNode<span class=\"token operator\">*</span> root<span class=\"token operator\">=</span>pNode<span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//利用父指针找到根结点</span>\n        <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>root<span class=\"token operator\">-&gt;</span>next<span class=\"token punctuation\">)</span>    \n            root<span class=\"token operator\">=</span>root<span class=\"token operator\">-&gt;</span>next<span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//调用中序遍历</span>\n        <span class=\"token function\">InOrder</span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> num<span class=\"token operator\">=</span>nodes<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span>num<span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n            TreeLinkNode <span class=\"token operator\">*</span>cur<span class=\"token operator\">=</span>nodes<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>pNode<span class=\"token operator\">==</span>cur<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n                <span class=\"token keyword\">return</span> nodes<span class=\"token punctuation\">[</span>i<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\">//书写中序遍历</span>\n    <span class=\"token keyword\">void</span> <span class=\"token function\">InOrder</span><span class=\"token punctuation\">(</span>TreeLinkNode<span class=\"token operator\">*</span> root<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>root<span class=\"token operator\">==</span><span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">InOrder</span><span class=\"token punctuation\">(</span>root<span class=\"token operator\">-&gt;</span>left<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        nodes<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">InOrder</span><span class=\"token punctuation\">(</span>root<span class=\"token operator\">-&gt;</span>right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h3><a id=\"123_67\"></a>1.2.3、代码解析</h3>\n<ul><li>首先创建动态数组<code>nodes</code>，注意是创建在方法外部，目的是可以在类内任意使用</li><li>创建的<code>root</code>结点并借助<code>while</code>循环通过父指针<code>next</code>找到根结点</li><li>书写<code>InOrder</code>中序遍历函数，将中序遍历结果存入上方创建的<code>nodes</code>数组中</li><li>使用<code>for</code>循环将传入结点<code>pNode</code>与数组元素比较，如果匹配到就返回位置加一的结点</li></ul>\n<h1><a id=\"2_72\"></a>2、对称的二叉树</h1>\n<h2><a id=\"21_73\"></a>2.1、题目速览</h2>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\f8168af7c21b4318a61a376c723bece6.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"image\\9e65162380694f1da5c7aba83092ce57.png\"/></p>\n<h2><a id=\"22_76\"></a>2.2、个人题解</h2>\n<h3><a id=\"221_77\"></a>2.2.1、解题思路</h3>\n<p>前序遍历的时候我们采用的是“根左右”的遍历次序，如果这棵二叉树是对称的，即相应的左右节点交换位置完全没有问题；<br/> 那我们是不是可以尝试“根右左”遍历，按照轴对称图像的性质，这两种次序的遍历结果应该是一样的。<br/> 但是如果相同的方式进行两次，可行但我们不去做，这对时间的消耗太多了，我们不如在遍历的过程就结果比较了。而遍历方式依据前序递归可以使用递归：</p>\n<ol><li>两种方向的前序遍历，同步过程中的当前两个节点，同为空，属于对称的范畴。</li><li>当前两个节点只有一个为空或者节点值不相等，已经不是对称的二叉树了。</li><li>第一个节点的左子树与第二个节点的右子树同步递归对比，第一个节点的右子树与第二个节点的左子树同步递归比较。</li></ol>\n<h3><a id=\"222_86\"></a>2.2.2、代码实现</h3>\n<pre><code class=\"prism language-cpp\"><span class=\"token comment\">/*\nstruct TreeNode {\n    int val;\n    struct TreeNode *left;\n    struct TreeNode *right;\n    TreeNode(int x) :\n            val(x), left(NULL), right(NULL) {\n    }\n};\n*/</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    <span class=\"token keyword\">bool</span> <span class=\"token function\">isSymmetrical</span><span class=\"token punctuation\">(</span>TreeNode<span class=\"token operator\">*</span> pRoot<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">dgfunc</span><span class=\"token punctuation\">(</span>pRoot<span class=\"token punctuation\">,</span>pRoot<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">bool</span> <span class=\"token function\">dgfunc</span><span class=\"token punctuation\">(</span>TreeNode<span class=\"token operator\">*</span> root1<span class=\"token punctuation\">,</span>TreeNode<span class=\"token operator\">*</span> root2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>root1<span class=\"token operator\">==</span><span class=\"token constant\">NULL</span><span class=\"token operator\">&amp;&amp;</span>root2<span class=\"token operator\">==</span><span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>root1<span class=\"token operator\">==</span><span class=\"token constant\">NULL</span><span class=\"token operator\">||</span>root2<span class=\"token operator\">==</span><span class=\"token constant\">NULL</span><span class=\"token operator\">||</span>root1<span class=\"token operator\">-&gt;</span>val<span class=\"token operator\">!=</span>root2<span class=\"token operator\">-&gt;</span>val<span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">dgfunc</span><span class=\"token punctuation\">(</span>root1<span class=\"token operator\">-&gt;</span>left<span class=\"token punctuation\">,</span> root2<span class=\"token operator\">-&gt;</span>right<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">dgfunc</span><span class=\"token punctuation\">(</span>root1<span class=\"token operator\">-&gt;</span>right<span class=\"token punctuation\">,</span>root2<span class=\"token operator\">-&gt;</span>left<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h3><a id=\"223_113\"></a>2.2.3、代码解析</h3>\n<ul><li>编写<code>dgfunc</code>函数，将<code>pRoot</code>传入比较</li><li>前两个if是递归结束的条件： \n  <ul><li>如果结点相同返回<code>true</code></li><li>如果一边为<code>NULL</code>或者左子树与右子树不同，返回<code>false</code></li></ul> </li><li>调用递归，比较左右子树，都相同就返回<code>true</code>，不相同则返回<code>false</code></li></ul>\n<hr/>\n<p><code>还是那句话，牵扯到二叉树就尽量使用递归的方法来解决问题！</code></p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}