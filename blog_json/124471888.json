{"blogid": "124471888", "writerAge": "码龄2年", "writerBlogNum": "91", "writerCollect": "418", "writerComment": "45", "writerFan": "112", "writerGrade": "4级", "writerIntegral": "1314", "writerName": "向上的狼", "writerProfileAdress": "writer_image\\profile_124471888.jpg", "writerRankTotal": "13940", "writerRankWeekly": "13227", "writerThumb": "243", "writerVisitNum": "124774", "blog_read_count": "4212", "blog_time": "已于 2022-04-28 20:36:54 修改", "blog_title": "Java中的Lock详解", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h1>一、简介</h1>\n<p>java.util.concurrent.locks.Lock 是一个类似于synchronized 块的<a href=\"https://so.csdn.net/so/search?q=%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6&amp;spm=1001.2101.3001.7020\" title=\"线程同步机制\">线程同步机制</a>。但是 Lock比 synchronized 块更加灵活。Lock是个接口，有个实现类是ReentrantLock。</p>\n<h1>二、Lock和syncronized的区别</h1>\n<ul><li>synchronized是Java语言的关键字。Lock是一个类。</li><li>synchronized不需要用户去手动释放锁，发生异常或者线程结束时自动释放锁;Lock则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。</li><li>lock可以配置公平策略,实现线程按照先后顺序获取锁。</li><li>提供了trylock方法 可以试图获取锁，获取到或获取不到时，返回不同的返回值 让程序可以灵活处理。</li><li>lock()和unlock()可以在不同的方法中执行,可以实现同一个线程在上一个方法中lock()在后续的其他方法中unlock(),比syncronized灵活的多。</li></ul>\n<h1>三、Lock接口<a href=\"https://so.csdn.net/so/search?q=%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95&amp;spm=1001.2101.3001.7020\" title=\"抽象方法\">抽象方法</a> </h1>\n<ul><li>void lock()：获取锁，如果锁不可用，则出于线程调度的目的，当前线程将被禁用，并且在获取锁之前处于休眠状态。</li></ul>\n<pre><code>Lock lock = ...;\nlock.lock();\ntry{\n    //处理任务\n}catch(Exception ex){\n     \n}finally{\n    lock.unlock();   //释放锁\n}</code></pre>\n<ul><li>boolean tryLock()：如果锁可用立即返回true，如果锁不可用立即返回false；</li><li>boolean tryLock(long time, TimeUnit unit) throws InterruptedException：如果锁可用，则此方法立即返回true。 如果该锁不可用，则当前线程将出于线程调度目的而被禁用并处于休眠状态，直到发生以下三种情况之一为止：①当前线程获取到该锁；②当前线程被其他线程中断，并且支持中断获取锁；③经过指定的等待时间如果获得了锁，则返回true，没获取到锁返回false。</li></ul>\n<pre><code>Lock lock = ...;\nif(lock.tryLock()) {\n     try{\n         //处理任务\n     }catch(Exception ex){\n         \n     }finally{\n         lock.unlock();   //释放锁\n     } \n}else {\n    //如果不能获取锁，则直接做其他事情\n}\n</code></pre>\n<p></p>\n<ul><li>void unlock()：释放锁。释放锁的操作放在finally块中进行，以保证锁一定被被释放，防止死锁的发生。</li></ul>\n<h1>四、ReentrantLock</h1>\n<p><strong>重入锁也叫做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。避免死锁问题的,synchronized也可重入。</strong></p>\n<h2>4.1、synchronized重入测试</h2>\n<pre><code>public class ReentrantDemo {\n    public synchronized  void method1() {\n        System.out.println(\"synchronized method1\");\n        method2();\n    }\n    public synchronized void method2() {\n        System.out.println(\"synchronized method2\");\n    }\n    public static void main(String[] args) {\n        ReentrantDemo reentrantDemo = new ReentrantDemo();\n        reentrantDemo.method1();\n    }\n}\n</code></pre>\n<p>执行结果</p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\20200708103458799.png\"/></p>\n<h2>4.2、ReentrantLock重入测试 </h2>\n<pre><code>public class ReentrantDemo implements Runnable {\n    Lock lock = new ReentrantLock();\n    @Override\n    public void run() {\n        set();\n    }\n    public void set() {\n        try {\n            lock.lock();\n            System.out.println(\"set 方法\");\n            get();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            lock.unlock();// 必须在finally中释放\n        }\n    }\n\n    public void get() {\n\n        try {\n            lock.lock();\n            System.out.println(\"get 方法\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n    public static void main(String[] args) {\n        ReentrantDemo reentrantDemo = new ReentrantDemo();\n        new Thread(reentrantDemo).start();\n    }\n}\n</code></pre>\n<p>测试结果：同一个线程，首先在set方法中获取锁，然后调用get方法，get方法中重复获取同一个锁。两个方法都执行成功。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\20200708103823719.png\"/></p>\n<h1>五、ReentrantReadWriteLock（读写锁） </h1>\n<p><strong>读写锁</strong>，可以分别获取读锁或写锁。也就是说将数据的读写操作分开，分成2个锁来分配给线程，从而使得多个线程可以同时进行读操作。<strong>读锁使用共享模式；写锁使用独占模式</strong>；<strong>读锁可以在没有写锁的时候被多个线程同时持有，写锁是独占的。当有读锁时，写锁就不能获得</strong>；<strong>而当有写锁时，除了获得写锁的这个线程可以获得读锁外，其他线程不能获得读锁</strong></p>\n<ul><li>writeLock()：获取写锁。</li><li>readLock()：获取读锁。<br/> 执行三个线程进行读写操作，并设置一个屏障，线程依次准备就绪后未获取锁之前都在等待，当第三个线程执行 cyclicBarrier.await();后屏障解除，三个线程同时执行。</li></ul>\n<pre><code>public class WriteAndReadLockTest {\n    private static ReentrantReadWriteLock reentrantReadWriteLock = new ReentrantReadWriteLock();\n    private static ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(10, 10,\n            60L, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());\n    private static CyclicBarrier cyclicBarrier = new CyclicBarrier(3);\n    private static int i = 100;\n    public static void main(String[] args) {\n        threadPoolExecutor.execute(()-&gt;{\n            read(Thread.currentThread());\n        });\n        threadPoolExecutor.execute(()-&gt;{\n            write(Thread.currentThread());\n        });\n        threadPoolExecutor.execute(()-&gt;{\n            read(Thread.currentThread());\n        });\n        threadPoolExecutor.shutdown();\n    }\n\n    private static void read(Thread thread) {\n        try {\n            cyclicBarrier.await();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } catch (BrokenBarrierException e) {\n            e.printStackTrace();\n        }\n        reentrantReadWriteLock.readLock().lock();\n        try {\n            System.out.println(\"读线程 \"+ thread.getName() + \" 开始执行, i=\" + i);\n            Thread.sleep(1000);\n            System.out.println(thread.getName() +\" is over!\");\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            reentrantReadWriteLock.readLock().unlock();\n\n        }\n    }\n    private static void write(Thread thread) {\n        try {\n            cyclicBarrier.await();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } catch (BrokenBarrierException e) {\n            e.printStackTrace();\n        }\n        reentrantReadWriteLock.writeLock().lock();\n        try {\n            i++;\n            System.out.println(\"写线程 \"+ thread.getName() + \" is doing, i=\" + i);\n            System.out.println(thread.getName() +\" is over!\");\n        } finally {\n            reentrantReadWriteLock.writeLock().unlock();\n        }\n    }\n}\n</code></pre>\n<p> 执行结果：线程1先获取到了读锁，因为读锁时可以共享的，所有线程3也可以获取到读锁，线程1、3读操作完成后将读锁释放后，线程2才能获取到写锁并开始执行写操作。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\202007081149512.png\"/></p>\n<h1>六、公平锁与非公平锁 </h1>\n<ul><li>公平锁：就是很公平，在并发环境中，每个线程在获取锁时会先查看此锁维护的等待队列，如果为空，或者当前线程线程是等待队列的第一个，就占有锁，否则就会加入到等待队列中，以后会按照FIFO的规则从队列中取到自己</li><li>非公平锁：比较粗鲁，上来就直接尝试占有锁，如果尝试失败，就再采用类似公平锁那种方式</li></ul>\n<h2>6.1、如何实现 </h2>\n<ul><li>ReentrantLock：模式是非公平锁。也可通过构造方法创建公平锁；</li></ul>\n<pre><code>public ReentrantLock() {\n\tsync = new NonfairSync();\n}\npublic ReentrantLock(boolean fair) {\n    sync = fair ? new FairSync() : new NonfairSync();\n}\n</code></pre>\n<ul><li>ReentrantReadWriteLock：默认是非公平锁，也可以通过构造方法创建公平锁；</li></ul>\n<pre><code>public ReentrantReadWriteLock() {\n\tthis(false);\n}\npublic ReentrantReadWriteLock(boolean fair) {\n    sync = fair ? new FairSync() : new NonfairSync();\n    readerLock = new ReadLock(this);\n    writerLock = new WriteLock(this);\n}\n</code></pre>\n<h2>6.2<strong>、</strong>优缺点</h2>\n<p>非公平锁性能高于公平锁性能。首先，在恢复一个被挂起的线程与该线程真正运行之间存在着严重的延迟。而且，非公平锁能更充分的利用cpu的时间片，尽量的减少cpu空闲的状态时间。</p>\n<h1><strong>七、Condition的使用</strong></h1>\n<p>当满足一定条件时，调用Condition的await()方法使当前线程进入休眠状态进行等待。调用Condition的signalAll()方法唤醒因await()进入休眠的线程。</p>\n<p>Lock锁实现同步时需要使用者手动控制锁的获取和释放，其灵活性使得可以实现更复杂的多线程同步和更高的性能，但同时，使用者一定要在获取锁后及时捕获代码运行过程中的异常并在finally代码块中释放锁。</p>\n<p>使用Lock锁及其同步条件来实现一个生产者-消费者模型：</p>\n<pre><code>public class MessageStorageByLock {  \n    private int maxSize;  \n    private List&lt;String&gt; messages;  \n  \n    private final ReentrantLock lock;  \n    private final Condition conditionWrite;//声明两个锁条件  \n    private final Condition conditionRead;  \n    public MessageStorageByLock(int maxSize) {  \n        this.maxSize = maxSize;  \n        messages = new LinkedList&lt;String&gt;();  \n        lock = new ReentrantLock(true);//true修改锁的公平性，为true时，使用lifo队列来顺序获得锁  \n        conditionWrite = lock.newCondition();//调用newCondition()方法，即new ConditionObject();  \n        conditionRead = lock.newCondition();  \n  \n    }  \n    public void set(String message){  \n        //使用锁实现同步，获取所得操作，当锁被其他线程占用时，当前线程将进入休眠  \n        lock.lock();  \n        try{  \n            while(messages.size() == maxSize){  \n                    System.out.print(\"the message buffer is full now,start into wait()\\n\");  \n                    conditionWrite.await();//满足条件时，线程休眠并释放锁。当调用 signalAll()时。线程唤醒并重新获得锁  \n            }  \n            Thread.sleep(100);  \n            messages.add(message);  \n            System.out.print(\"add message:\"+message+\" success\\n\");  \n            conditionRead.signalAll();//唤醒因conditionRead.await()休眠的线程  \n        }catch (InterruptedException e){  \n            e.printStackTrace();  \n        }finally {  \n            lock.unlock();  \n        }  \n    }  \n    public String get(){  \n        String message = null;  \n        lock.lock();  \n        try{  \n            while(messages.size() == 0){  \n                conditionRead.await();  \n                System.out.print(\"the message buffer is empty now,start into wait()\\n\");  \n            }  \n            Thread.sleep(100);  \n            message = ((LinkedList&lt;String&gt;)messages).poll();  \n            System.out.print(\"get message:\"+message+\" success\\n\");  \n            conditionWrite.signalAll();  \n        }catch (InterruptedException e){  \n            e.printStackTrace();  \n        }finally {  \n            lock.unlock();  \n        }  \n        return message;  \n    }  \n}  </code></pre>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px;\"><tbody><tr><td>Modifier and Type</td><td>Method and Description</td></tr><tr><td>void</td><td> <p>lock()</p> <p>获得锁</p> </td></tr><tr><td>void</td><td><code><a href=\"https://blog.csdn.net/java/util/concurrent/locks/Lock.html#lockInterruptibly--\" title=\"lockInterruptibly\">lockInterruptibly</a>()</code> <p>获取锁定，除非当前线程是 <a href=\"https://blog.csdn.net/java/lang/Thread.html#interrupt--\" title=\"interrupted\">interrupted</a> 。</p> </td></tr><tr><td>Condition</td><td><code><a href=\"https://blog.csdn.net/java/util/concurrent/locks/Lock.html#newCondition--\" title=\"newCondition\">newCondition</a>()</code> <p>返回一个新Condition绑定到该实例<code>Lock</code>实例。</p> </td></tr><tr><td>boolean</td><td><code><a href=\"https://blog.csdn.net/java/util/concurrent/locks/Lock.html#tryLock--\" title=\"tryLock\">tryLock</a>()</code> <p>只有在调用时才可以获得锁。</p> </td></tr><tr><td>boolean</td><td><code><a href=\"https://blog.csdn.net/java/util/concurrent/locks/Lock.html#tryLock-long-java.util.concurrent.TimeUnit-\" title=\"tryLock\">tryLock</a>(long time, <a href=\"https://blog.csdn.net/java/util/concurrent/TimeUnit.html\" title=\"TimeUnit\">TimeUnit</a> unit)</code> <p>如果在给定的等待时间内是空闲的，并且当前的线程尚未得到 <a href=\"https://blog.csdn.net/java/lang/Thread.html#interrupt--\" title=\"interrupted，\">interrupted，</a>则获取该锁。</p> </td></tr><tr><td>void</td><td> <p>unlock();</p> <p>释放锁</p> </td></tr></tbody></table>\n<pre><code>package java.util.concurrent.locks;\nimport java.util.concurrent.TimeUnit;\n \npublic interface Lock {\n    void lock();\n \n    void lockInterruptibly() throws InterruptedException;\n \n    boolean tryLock();\n \n    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;\n \n    void unlock();\n \n    Condition newCondition();\n}</code></pre>\n<p><img alt=\"\" height=\"629\" src=\"image\\cd5405f53f6d46c4bca78ca99d0ac5a9.png\" width=\"1193\"/></p>\n<pre><code>package java.util.concurrent.locks;\nimport java.util.concurrent.TimeUnit;\nimport java.util.Date;\n \npublic interface Condition {\n \n    void await() throws InterruptedException;\n \n    void awaitUninterruptibly();\n \n    long awaitNanos(long nanosTimeout) throws InterruptedException;\n \n    boolean await(long time, TimeUnit unit) throws InterruptedException;\n \n    boolean awaitUntil(Date deadline) throws InterruptedException;\n \n    void signal();\n \n    void signalAll();\n}</code></pre>\n<h1>八<strong>、代码举例</strong></h1>\n<h2>8.1<strong>、</strong>Demo1（先演示一下锁的可重入性）</h2>\n<pre><code>package com.szh.lock;\n \n/**\n * 演示锁的可重入性\n */\npublic class Test01 {\n \n    public synchronized void metthod1() {\n        System.out.println(\"同步方法1\");\n        //线程执行 metthod1() 方法,默认 this 作为锁对象,\n        //在 metthod1() 方法中调用了 method2() 方法,注意当前线程还是持有 this 锁对象的\n        //method2() 同步方法默认的锁对象也是 this 对象, 要执行 method2() 必须先获得 this 锁对象,\n        //当前 this 对象被当前线程持有,可以 再次获得 this 对象, 这就是锁的可重入性.\n        //假设锁不可重入的话,可能会造成死锁\n        method2();\n    }\n \n    public synchronized void method2() {\n        System.out.println(\"同步方法2\");\n        method3();\n    }\n \n    public synchronized void method3() {\n        System.out.println(\"同步方法3\");\n    }\n \n    public static void main(String[] args) {\n        Test01 obj=new Test01();\n \n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                obj.metthod1();\n            }\n        }).start();\n    }\n}</code></pre>\n<p><strong>运行结果 </strong></p>\n<h2><img alt=\"\" src=\"image\\20210609121913162.png\"/></h2>\n<h2>8.2<strong>、</strong>Demo2（ReentrantLock的基本使用）</h2>\n<pre><code>package com.szh.lock;\n \nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n \n/**\n * ReentrantLock 的基本使用\n */\npublic class Test02 {\n \n    //定义一个显示锁\n    static Lock lock=new ReentrantLock();\n \n    public static void method() {\n        //先获得锁\n        lock.lock();\n        //for循环此时就是同步代码块\n        for (int i = 0; i &lt; 3; i++) {\n            System.out.println(Thread.currentThread().getName() + \" ---&gt; \" + i);\n        }\n        //释放锁\n        lock.unlock();\n    }\n \n    public static void main(String[] args) {\n        Runnable r=new Runnable() {\n            @Override\n            public void run() {\n                method();\n            }\n        };\n        //启动三个线程\n        new Thread(r).start();\n        new Thread(r).start();\n        new Thread(r).start();\n    }\n}</code></pre>\n<p><strong>运行结果</strong></p>\n<p><img alt=\"\" src=\"image\\2021060912225235.png\"/></p>\n<h2>8.3<strong>、</strong>Demo3（使用Lock锁同步不同方法中的代码块）</h2>\n<pre><code>package com.szh.lock;\n \nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n \n/**\n * 使用 Lock 锁同步不同方法中的同步代码块\n */\npublic class Test03 {\n    //定义锁对象\n    static Lock lock=new ReentrantLock();\n \n    public static void method1() {\n        //经常在 try 代码块中获得 Lock 锁, 在 finally 子句中释放锁\n        try {\n            lock.lock(); //获得锁\n            System.out.println(Thread.currentThread().getName() + \" ---method1--- \" + System.currentTimeMillis());\n            Thread.sleep(1000);\n            System.out.println(Thread.currentThread().getName() + \" ---method1--- \" + System.currentTimeMillis());\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }finally {\n            lock.unlock(); //释放锁\n        }\n    }\n \n    public static void method2() {\n        //经常在 try 代码块中获得 Lock 锁, 在 finally 子句中释放锁\n        try {\n            lock.lock(); //获得锁\n            System.out.println(Thread.currentThread().getName() + \" ---method2--- \" + System.currentTimeMillis());\n            Thread.sleep(1000);\n            System.out.println(Thread.currentThread().getName() + \" ---method2--- \" + System.currentTimeMillis());\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }finally {\n            lock.unlock(); //释放锁\n        }\n    }\n \n    public static void main(String[] args) {\n \n        Runnable r1=new Runnable() {\n            @Override\n            public void run() {\n                method1();\n            }\n        };\n \n        Runnable r2=new Runnable() {\n            @Override\n            public void run() {\n                method2();\n            }\n        };\n \n        new Thread(r1).start();\n        new Thread(r1).start();\n \n        new Thread(r2).start();\n        new Thread(r2).start();\n    }\n}</code></pre>\n<p><strong>运行结果</strong></p>\n<p><img alt=\"\" src=\"image\\20210609122559493.png\"/></p>\n<h2>8.4<strong>、</strong>Demo4（ReentrantLock锁的可重入性） </h2>\n<pre><code>package com.szh.lock;\n \nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n \n/**\n * ReentrantLock 锁的可重入性\n */\npublic class Test04 {\n \n    static class SubThread extends Thread {\n        //定义锁对象\n        private static Lock lock=new ReentrantLock();\n \n        //定义变量\n        private static int num=0;\n \n        @Override\n        public void run() {\n            for (int i = 0; i &lt; 10000; i++) {\n                try {\n                    //可重入锁指可以反复获得该锁\n                    lock.lock();\n                    lock.lock();\n                    num++;\n                }finally {\n                    lock.unlock();\n                    lock.unlock();\n                }\n            }\n        }\n    }\n \n    public static void main(String[] args) throws InterruptedException {\n \n        SubThread t1=new SubThread();\n        SubThread t2=new SubThread();\n \n        t1.start();\n        t2.start();\n \n        t1.join();\n        t2.join();\n \n        System.out.println(SubThread.num);\n    }\n}</code></pre>\n<p><strong>运行结果</strong></p>\n<p><img alt=\"\" src=\"image\\20210609123303813.png\"/></p>\n<h2>8.5<strong>、</strong>Demo5（ReentrantLock的lockInterruptibly()方法）</h2>\n<pre><code>package com.szh.lock;\n \nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n \n/**\n * lockInterruptibly()方法\n *  如果当前线程未被中断则获得锁,\n *  如果当前线程被中断则出现异常.\n */\npublic class Test05 {\n \n    static class Service {\n        private Lock lock=new ReentrantLock(); //定义锁对象\n        public void serviceMethod() {\n            try {\n                //lock.lock();  获得锁, 即使调用了线程的 interrupt() 方法, 也没有真正的中断线程\n                //如果线程被中断了, 不会获得锁, 会产生异常\n                lock.lockInterruptibly();\n                System.out.println(Thread.currentThread().getName() + \" --- begin lock\");\n                //执行一段耗时的操作\n                for (int i = 0; i &lt; Integer.MAX_VALUE; i++) {\n                    new StringBuilder();\n                }\n                System.out.println(Thread.currentThread().getName() + \" --- end lock\");\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            } finally {\n                System.out.println(Thread.currentThread().getName() + \" === 释放锁\");\n                lock.unlock(); //释放锁\n            }\n        }\n    }\n \n    public static void main(String[] args) throws InterruptedException {\n        Service s=new Service();\n \n        Runnable r=new Runnable() {\n            @Override\n            public void run() {\n                s.serviceMethod();\n            }\n        };\n \n        Thread t1=new Thread(r);\n        t1.start();\n        Thread.sleep(50);\n \n        Thread t2=new Thread(r);\n        t2.start();\n        Thread.sleep(50);\n \n        t2.interrupt(); //中断 t2 线程\n    }\n}</code></pre>\n<p><strong>运行结果</strong> </p>\n<p><img alt=\"\" src=\"image\\20210609123933335.png\"/></p>\n<h2>8.6<strong>、</strong>Demo6（lockInterruptibly()方法可以避免死锁） </h2>\n<pre><code>package com.szh.lock;\n \nimport java.util.concurrent.locks.ReentrantLock;\n \n/**\n * 通过 ReentrantLock 锁的 lockInterruptibly() 方法避免死锁的产生\n */\npublic class Test06 {\n \n    static class MyLock implements Runnable {\n \n        //创建两个ReentrantLock等锁对象\n        private static ReentrantLock lock1=new ReentrantLock();\n        private static ReentrantLock lock2=new ReentrantLock();\n \n        int lockNum; //定义整数变量,决定使用哪个锁,偶数用lock1,奇数用lock2\n \n        public MyLock(int lockNum) {\n            this.lockNum=lockNum;\n        }\n \n        @Override\n        public void run() {\n            try {\n                if (lockNum % 2 == 1) { //奇数, 先锁 1, 再锁 2\n                    lock1.lockInterruptibly();\n                    System.out.println(Thread.currentThread().getName() + \"获得锁1，还需要获得锁2\");\n                    Thread.sleep(1000);\n                    lock2.lockInterruptibly();\n                    System.out.println(Thread.currentThread().getName() + \"同时获得了锁1与锁2\");\n                }else { //偶数, 先锁 2, 再锁 1\n                    lock2.lockInterruptibly();\n                    System.out.println(Thread.currentThread().getName() + \"获得了锁2，还需要获得锁1\");\n                    Thread.sleep(1000);\n                    lock1.lockInterruptibly();\n                    System.out.println(Thread.currentThread().getName() + \"同时获得了锁1与锁2\");\n                }\n            }catch (InterruptedException e) {\n                e.printStackTrace();\n            }finally {\n                if (lock1.isHeldByCurrentThread()) { //判断当前线程是否持有该锁\n                    lock1.unlock();\n                }\n                if (lock2.isHeldByCurrentThread()) {\n                    lock2.unlock();\n                }\n                System.out.println(Thread.currentThread().getName() + \"线程退出\");\n            }\n        }\n    }\n \n    public static void main(String[] args) throws InterruptedException {\n        MyLock myLock1=new MyLock(11);\n        MyLock myLock2=new MyLock(22);\n \n        Thread t1=new Thread(myLock1);\n        Thread t2=new Thread(myLock2);\n        t1.start();\n        t2.start();\n \n        //在 main 线程, 等待 3000 ms, 如果还有线程没有结束就中断该线程\n        Thread.sleep(1000 * 3);\n        //可以中断任何一个线程来解决死锁, t2 线程会放弃对锁 1 的申请, 同时释放锁 2, t1 线程会完成它的任务\n        if (t2.isAlive()) {\n            t2.interrupt();\n        }\n    }\n}</code></pre>\n<p><strong>运行结果</strong></p>\n<h2><img alt=\"\" src=\"image\\20210609124757280.png\"/></h2>\n<h2>8.7<strong>、</strong>Demo7（ReentrantLock的tryLock(long time, TimeUnit unit)方法） </h2>\n<pre><code>package com.szh.lock;\n \nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.ReentrantLock;\n \n/**\n * tryLock(long time, TimeUnit unit) 的作用在给定等待时长内,\n * 锁没有被另外的线程持有, 并且当前线程也没有被中断, 则获得该锁.\n * 通过该方法可以实现锁对象的限时等待.\n */\npublic class Test07 {\n \n    static class TimeLock implements Runnable {\n        private static ReentrantLock lock=new ReentrantLock(); //定义锁对象\n \n        @Override\n        public void run() {\n            try {\n                //假设 t1 线程先持有锁, 完成任务需要 4 秒钟,\n                //这个时候 t2 线程尝试获得锁, t2 线程在 3 秒内还没有获得锁的话, 那么它就不再等了，直接放弃\n                if (lock.tryLock(3, TimeUnit.SECONDS)) {\n                    System.out.println(Thread.currentThread().getName() + \"获得锁，执行耗时任务\");\n                    Thread.sleep(1000 * 4);\n                    /*\n                        假设 t1 线程先持有锁, 完成任务需要 2 秒钟\n                        这个时候t2 线程尝试获得锁, t2 线程会一直尝试\n                        在它约定尝试的 3 秒内可以获得锁对象\n                     */\n                    //Thread.sleep(1000 * 2);\n                }else {\n                    System.out.println(Thread.currentThread().getName() + \"没有获得锁\");\n                }\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            } finally {\n                if (lock.isHeldByCurrentThread()) {\n                    lock.unlock();\n                }\n            }\n        }\n    }\n \n    public static void main(String[] args) {\n        TimeLock timeLock=new TimeLock();\n \n        Thread t1=new Thread(timeLock);\n        Thread t2=new Thread(timeLock);\n \n        t1.setName(\"t1\");\n        t2.setName(\"t2\");\n \n        t1.start();\n        t2.start();\n    }\n}</code></pre>\n<p><strong>运行结果 </strong></p>\n<p><img alt=\"\" src=\"image\\20210609124901607.png\"/></p>\n<h2>8.8<strong>、</strong>Demo8（ReentrantLock的tryLock()方法）</h2>\n<pre><code>package com.szh.lock;\n \nimport java.util.concurrent.locks.ReentrantLock;\n \n/**\n * tryLock() 当锁对象没有被其他线程持有的情况下, 才会获得该锁定\n */\npublic class Test08 {\n \n    static class Service {\n        private ReentrantLock lock=new ReentrantLock();\n \n        public void serviceMethod() {\n            try {\n                if (lock.tryLock()) {\n                    System.out.println(Thread.currentThread().getName() + \"获得锁定\");\n                    Thread.sleep(1000 * 3); //模拟执行任务的时长\n                }else {\n                    System.out.println(Thread.currentThread().getName() + \"没有获得锁定\");\n                }\n            }catch (InterruptedException e) {\n                e.printStackTrace();\n            }finally {\n                if (lock.isHeldByCurrentThread()) {\n                    lock.unlock();\n                }\n            }\n        }\n    }\n \n    public static void main(String[] args) throws InterruptedException {\n        Service service=new Service();\n \n        Runnable r=new Runnable() {\n            @Override\n            public void run() {\n                service.serviceMethod();\n            }\n        };\n \n        Thread t1=new Thread(r);\n        t1.start();\n        Thread.sleep(100);\n        Thread t2=new Thread(r);\n        t2.start();\n    }\n}</code></pre>\n<p><strong>运行结果</strong></p>\n<p><img alt=\"\" src=\"image\\20210609124933193.png\"/></p>\n<h2>8.9<strong>、</strong>Demo9（tryLock()方法可以避免死锁）</h2>\n<pre><code>package com.szh.lock;\n \nimport java.util.concurrent.locks.ReentrantLock;\n \n/**\n * 使用 tryLock() 可以避免死锁\n */\npublic class Test09 {\n \n    static class MyLock implements Runnable {\n \n        private static ReentrantLock lock1=new ReentrantLock();\n        private static ReentrantLock lock2=new ReentrantLock();\n \n        private int lockNum;\n \n        public MyLock(int lockNum) {\n            this.lockNum=lockNum;\n        }\n \n        @Override\n        public void run() {\n            if (lockNum % 2 == 0) { //偶数先锁 1, 再锁 2\n                while (true) {\n                    try {\n                        if (lock1.tryLock()) {\n                            System.out.println(Thread.currentThread().getName() + \"获得了锁1，还想获得锁2\");\n                            Thread.sleep(50);\n                            try {\n                                if (lock2.tryLock()) {\n                                    System.out.println(Thread.currentThread().getName() + \"同时获得了锁1与锁2，完成任务了\");\n                                    return;\n                                }\n                            } finally {\n                                if (lock2.isHeldByCurrentThread()) {\n                                    lock2.unlock();\n                                }\n                            }\n                        }\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    } finally {\n                        if (lock1.isHeldByCurrentThread()) {\n                            lock1.unlock();\n                        }\n                    }\n                }\n            }else { //奇数就先锁 2, 再锁 1\n                while (true) {\n                    try {\n                        if (lock2.tryLock()) {\n                            System.out.println(Thread.currentThread().getName() + \"获得了锁2，还想获得锁1\");\n                            Thread.sleep(50);\n                            try {\n                                if (lock1.tryLock()) {\n                                    System.out.println(Thread.currentThread().getName() + \"同时获得了锁1与锁2，完成任务了\");\n                                    return;\n                                }\n                            } finally {\n                                if (lock1.isHeldByCurrentThread()) {\n                                    lock1.unlock();\n                                }\n                            }\n                        }\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    } finally {\n                        if (lock2.isHeldByCurrentThread()) {\n                            lock2.unlock();\n                        }\n                    }\n                }\n            }\n        }\n    }\n \n    public static void main(String[] args) {\n        MyLock lock1=new MyLock(11);\n        MyLock lock2=new MyLock(22);\n \n        Thread t1=new Thread(lock1);\n        Thread t2=new Thread(lock2);\n \n        t1.start();\n        t2.start();\n        //运行后, 使用 tryLock() 尝试获得锁, 不会傻傻的等待, 通过循环不停的再次尝试, 如果等待的时间足够长, 线程总是会获得想要的资源\n    }\n}</code></pre>\n<p><strong>运行结果</strong> </p>\n<p><img alt=\"\" src=\"image\\2021060912500771.png\"/></p>\n<p></p>\n</div>\n</div>"}