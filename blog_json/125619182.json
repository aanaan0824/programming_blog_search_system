{"blogid": "125619182", "writerAge": "码龄1年", "writerBlogNum": "103", "writerCollect": "5465", "writerComment": "4193", "writerFan": "7301", "writerGrade": "7级", "writerIntegral": "13153", "writerName": "三分苦", "writerProfileAdress": "writer_image\\profile_125619182.jpg", "writerRankTotal": "783", "writerRankWeekly": "296", "writerThumb": "4502", "writerVisitNum": "115925", "blog_read_count": "271", "blog_time": "于 2022-07-27 10:09:23 发布", "blog_title": "【 C++ 】string类的模拟实现", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E5%9F%BA%E6%9C%AC%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-toc\" style=\"margin-left:80px;\"><a href=\"#%E5%9F%BA%E6%9C%AC%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F\">1、基本成员变量</a></p>\n<p id=\"%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:80px;\"><a href=\"#%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0\">2、默认成员函数</a></p>\n<p id=\"%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:80px;\"><a href=\"#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\">        构造函数</a></p>\n<p id=\"%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:80px;\"><a href=\"#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0\">        析构函数</a></p>\n<p id=\"%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%88%E6%B7%B1%E6%8B%B7%E8%B4%9D%EF%BC%89-toc\" style=\"margin-left:80px;\"><a href=\"#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%88%E6%B7%B1%E6%8B%B7%E8%B4%9D%EF%BC%89\">        拷贝构造函数（深拷贝）</a></p>\n<p id=\"%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD-toc\" style=\"margin-left:80px;\"><a href=\"#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD\">        赋值运算符重载（深拷贝）</a></p>\n<p id=\"%E5%AE%B9%E9%87%8F%E4%B8%8E%E5%A4%A7%E5%B0%8F%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:80px;\"><a href=\"#%E5%AE%B9%E9%87%8F%E4%B8%8E%E5%A4%A7%E5%B0%8F%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0\">3、容量与大小相关函数</a></p>\n<p id=\"size-toc\" style=\"margin-left:80px;\"><a href=\"#size\">        size</a></p>\n<p id=\"capacity-toc\" style=\"margin-left:80px;\"><a href=\"#capacity\">        capacity</a></p>\n<p id=\"%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:80px;\"><a href=\"#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0\">4、字符串访问相关函数</a></p>\n<p id=\"%E5%A2%9E%E5%8A%A0-toc\" style=\"margin-left:80px;\"><a href=\"#%E5%A2%9E%E5%8A%A0\">        operator[ ]重载</a></p>\n<p id=\"11-toc\" style=\"margin-left:80px;\"><a href=\"#11\">        迭代器</a></p>\n<p id=\"22-toc\" style=\"margin-left:80px;\"><a href=\"#22\">5、增加的相关函数接口</a></p>\n<p id=\"33-toc\" style=\"margin-left:80px;\"><a href=\"#33\">        reserve扩容</a></p>\n<p id=\"44-toc\" style=\"margin-left:80px;\"><a href=\"#44\">        resize</a></p>\n<p id=\"%E5%88%A0%E9%99%A4-toc\" style=\"margin-left:80px;\"><a href=\"#%E5%88%A0%E9%99%A4\">        push_back追加字符</a></p>\n<p id=\"11-toc\" style=\"margin-left:80px;\"><a href=\"#11\">        append追加字符串</a></p>\n<p id=\"22-toc\" style=\"margin-left:80px;\"><a href=\"#22\">        operator+=</a></p>\n<p id=\"33-toc\" style=\"margin-left:80px;\"><a href=\"#33\">        insert</a></p>\n<p id=\"44-toc\" style=\"margin-left:80px;\"><a href=\"#44\">6、删除的相关函数接口</a></p>\n<p id=\"%E6%9F%A5%E6%89%BE-toc\" style=\"margin-left:80px;\"><a href=\"#%E6%9F%A5%E6%89%BE\">        erase</a></p>\n<p id=\"11-toc\" style=\"margin-left:80px;\"><a href=\"#11\">        clear清空数据</a></p>\n<p id=\"22-toc\" style=\"margin-left:80px;\"><a href=\"#22\">7、查找的相关函数接口</a></p>\n<p id=\"33-toc\" style=\"margin-left:80px;\"><a href=\"#33\">        find</a></p>\n<p id=\"11-toc\" style=\"margin-left:80px;\"><a href=\"#11\">8、c_str获取字符串</a></p>\n<p id=\"22-toc\" style=\"margin-left:80px;\"><a href=\"#22\">9、swap交换函数</a></p>\n<p id=\"33-toc\" style=\"margin-left:80px;\"><a href=\"#33\">10、非成员函数</a></p>\n<p id=\"%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD-toc\" style=\"margin-left:80px;\"><a href=\"#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD\">        关系运算符函数重载</a></p>\n<p id=\"%E6%BA%90%E7%A0%81%E6%B1%87%E6%80%BB-toc\" style=\"margin-left:80px;\"><a href=\"#%E6%BA%90%E7%A0%81%E6%B1%87%E6%80%BB\">        &lt;&lt;流插入运算符重载</a></p>\n<p id=\"%3E%3E%E5%92%8C%3C%3C%E9%87%8D%E8%BD%BD-toc\" style=\"margin-left:80px;\"><a href=\"#%3E%3E%E5%92%8C%3C%3C%E9%87%8D%E8%BD%BD\">        &gt;&gt;流提取运算符重载</a></p>\n<p id=\"getline%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:80px;\"><a href=\"#getline%E5%87%BD%E6%95%B0\">        getline函数</a></p>\n<p id=\"%E6%80%BB%E8%A7%88-toc\" style=\"margin-left:80px;\"><a href=\"#%E6%80%BB%E8%A7%88\">11、源码链接</a></p>\n<hr/>\n<h3>1、基本成员变量</h3>\n<blockquote>\n<pre><code class=\"language-cpp\">namespace cpp\n{\n    //使用命名空间防止定义的string类与库里的string类冲突\n\tclass string\n\t{\n\tpublic:\n\t//……\n\tprivate:\n\t\tchar* _str;       //存储字符串\n\t\tsize_t _size;\t  //有效字符个数\n\t\tsize_t _capacity; //实际存储有效字符的空间，不包含'\\0'\n        const static size_t npos;\n\t};\n    const size_t string::npos = -1;\n}</code></pre>\n</blockquote>\n<hr/>\n<h3 id=\"%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0\">2、默认成员函数</h3>\n<h3 id=\"%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\">构造函数</h3>\n<blockquote>\n<p>这里的构造函数最好写成全缺省函数，与标准库里的构造函数相一致</p>\n<pre><code class=\"language-cpp\">//全缺省的默认构造函数\nstring(const char* str = \"\")//标准库里string定义对象的默认值为空串\"\"\n\t//按声明的顺序进行初始化\n\t:_size(strlen(str))\n\t, _capacity(_size)\n{\n\t_str = new char[_capacity + 1];//在堆上为_str开空间，+1是给'\\0'留的\n\tstrcpy(_str, str);//把常量字符串的内容拷贝过去\n}</code></pre>\n</blockquote>\n<hr/>\n<h3 id=\"%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0\">析构函数</h3>\n<blockquote>\n<p>这里string类里的_str是动态开辟建立在堆中的，堆区的空间不能自动销毁因此需要我们手动去销毁。</p>\n<pre><code class=\"language-cpp\">//析构函数\n~string()\n{\n\tif (_str)\n\t{\n\t\tdelete[] _str;\n\t\t_str = nullptr;\n\t\t_size = _capacity = 0;\n\t}\n}</code></pre>\n</blockquote>\n<hr/>\n<h3 id=\"%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%88%E6%B7%B1%E6%8B%B7%E8%B4%9D%EF%BC%89\">拷贝构造函数（深拷贝）</h3>\n<blockquote>\n<p>首先，我们不写，编译器会默认生成一个拷贝构造函数，不过是<span style=\"color:#956fe7;\">值拷贝或者浅拷贝</span>，按字节拷贝的。</p>\n<p><img alt=\"\" height=\"163\" src=\"image\\ea348e15c61d4e93880b650165b0eff4.png\" width=\"583\"/></p>\n<p>浅拷贝针对于日期类这种是非常适合的，不过对于string类这样_str是动态开辟到堆上的，如果使用<span style=\"color:#956fe7;\">值拷贝会导致</span><span style=\"color:#0d0016;\">1、</span><span style=\"color:#956fe7;\">析构两次</span><span style=\"color:#0d0016;\"> 2、</span><span style=\"color:#956fe7;\">一个对象修改会影响另外一个</span>。因此我们需要写深拷贝。</p>\n<p>深拷贝的核心要点在于<span style=\"color:#fe2c24;\">我和你的有一样的值，但是使用的不是同一块空间</span>。</p>\n<p><img alt=\"\" height=\"127\" src=\"image\\6fe2c4bdfd95478dafa8b79cef7b98ce.png\" width=\"561\"/></p>\n<p>深拷贝有两种写法：传统写法和现代写法。</p>\n<ul><li><span style=\"background-color:#fbd4d0;\">1、传统写法：</span></li></ul>\n<p>传统写法就是先开辟一块能够容纳原字符串大小的空间，最后把拷贝的对象的字符串数据拷贝到新开的空间里头即可。</p>\n<pre><code class=\"language-cpp\">//拷贝构造函数\n//不能用浅拷贝，原因如下：1、析构两次 2、一个对象修改会影响另外一个\n//传统写法\n//s2(s1);\nstring(const string&amp; s)\n\t:_size(strlen(s._str))\n\t,_capacity(_size)\n{\n\t_str = new char[_capacity + 1];\n\tstrcpy(_str, s._str);\n}</code></pre>\n<ul><li><span style=\"background-color:#fbd4d0;\">2、现代方法：</span></li></ul>\n<p>传统写法是本分的自己开空间，然后再拷贝数据，而现代方法就是剥削，要完成深拷贝，自己不想干活就安排别人干活，然后窃取别人的劳动成果。</p>\n<p>假如我拿s1去拷贝s2，现代方法就是我<span style=\"color:#956fe7;\">设定了一个tmp对象，拿s1._str的字符串作为参数去给tmp对象完成构造函数，再利用swap函数把tmp对象的_str、_size、_capacity全部与s1的交换即可完成现代方法的深拷贝</span>。但是在这之前注意把s1的数据置空，避免交换后tmp调用析构函数出现析构随机值的错误现象。</p>\n<pre><code class=\"language-cpp\">/*现代写法*/\nstring(const string&amp; s)\n\t:_str(nullptr)\n\t, _size(0)\n\t, _capacity(0)\n{\n\tstring tmp(s._str);//调用构造函数，构造一个字符串作为s.c_str的对象\n\tswap(tmp);\n}</code></pre>\n</blockquote>\n<hr/>\n<h3 id=\"%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD\">赋值运算符重载</h3>\n<blockquote>\n<p>这里和上述拷贝构造函数一样，我们不写编译器会自动生成，不过对于string类的_str来说，在堆上申请的空间需要自己去释放，否则会导致同一块空间析构两次。此深拷贝依旧有传统写法和现代写法。</p>\n<ul><li><span style=\"background-color:#fbd4d0;\">思路：</span></li></ul>\n<p>如若我把s3赋值给s1，这里不能直接进行赋值。要考虑两个问题。</p>\n<ol><li>如若我<span style=\"color:#ff9900;\">s1的空间小于s3</span>，此时直接拷贝过去会导致<span style=\"color:#ff9900;\">越界</span>。</li><li>如若我<span style=\"color:#956fe7;\">s1的空间过分大于s3的空间</span>，又会导致直接拷贝后<span style=\"color:#956fe7;\">空间过渡浪费</span>。只有在我s1和s3的空间差不多大时，才可以直接进行拷贝。</li></ol>\n<p><span style=\"color:#0d0016;\"><strong>综上：</strong></span>先把s1原先指向的空间delete释放掉，再把s1重新开辟和s3一样大的空间，记得多开一个字节，因为还有'\\0'。再利用strcpy把s3的内容拷贝给s1即可。不过要避免一种特殊情况：<span style=\"color:#956fe7;\">自己给自己赋值</span>，如若自己赋值给自己，直接返回，所以加个if条件判断即可。</p>\n<p>如果我new开空间失败了，那么就要抛异常，而先前我依旧释放了s1，此时就把s1给破坏了。为了避免这一点，我们可以<span style=\"color:#956fe7;\">先开空间再拷贝数据最后再释放</span>从而进行优化，具体见下文。</p>\n<ul><li><span style=\"background-color:#fbd4d0;\">1、传统写法：</span></li></ul>\n<pre><code class=\"language-cpp\">//赋值运算符重载 --&gt; 深拷贝\n//s1 = s3  s1.operator=(&amp;s1, s3);\nstring&amp; operator=(const string&amp; s)\n{\n\t//防止自己给自己赋值\n\tif (this != &amp;s)\n\t{\n\t/*\t\n//法一：\n\t\t//先删除原先s1的所有空间，防止赋值后s1过大导致空间浪费，s1过小导致空间不够\n\t\tdelete[] _str;\n\t\t//给s1开辟与s3等价的空间大小，要多开一字节给'\\0'\n\t\t_str = new char[strlen(s._str) + 1];\n\t\tstrcpy(_str, s._str);\n\t*/\n//法二优化\n        //先开辟空间\n\t\tchar* tmp = new char[s._capacity + 1];\n\t\tstrcpy(tmp, s._str);\n\t\tdelete[] _str;\n\t\t_str = tmp;\n\t\t_size = s._size;\n\t\t_capacity = s._capacity;\n\t}\n\treturn *this;\n}</code></pre>\n<p>C语言的动态开辟内存malloc需要检查合法性，而C++的new不需要，new失败的话需要抛异常捕获：</p>\n<pre><code class=\"language-cpp\">int main()\n{\n\ttry\n\t{\n\t\t//C++new失败要抛异常捕获\n\t\t//test_string1();\n\t\ttest_string2();\n\t}\n\tcatch (const exception&amp; e)\n\t{\n\t\tcout &lt;&lt; e.what() &lt;&lt; endl;\n\t}\n\treturn 0;\n}</code></pre>\n<ul><li><span style=\"color:#0d0016;\"><span style=\"background-color:#fbd4d0;\">2、现代写法：</span></span></li></ul>\n<p>这里的现代方法和上文拷贝构造的现代方法没两样，只不过多了个返回值。具体操作如下：</p>\n<pre><code class=\"language-cpp\">//现代写法1：\nstring&amp; operator=(const string&amp; s)\n{\n\tif (this != &amp;s)//避免自己给自己赋值\n\t{\n\t\tstring tmp(s._str);\n\t\tswap(tmp);\n\t}\n\treturn *this;\n}</code></pre>\n<p>这里还有另一种更加简洁的现代方法，<span style=\"color:#956fe7;\">上述写法是引用传参，这里我们可以直接传值传参，让编译器自动调用拷贝构造函数，再把拷贝出来的对象作为右值与左值交换即可</span>。</p>\n<pre><code class=\"language-cpp\">//法二：简洁版\t\n//s1 = s3;\nstring&amp; operator=(string s)//传值传参调用拷贝构造，s就是s3的深拷贝结果\n{\n\tswap(s);//交换这俩对象\n\treturn *this;\n}</code></pre>\n<p>不过这种简洁的版本无法避免自己给自己赋值，但很少会出现自己给自己赋值的行为，除非你有啥癖好。所以上述两种方法都可使用。</p>\n</blockquote>\n<hr/>\n<h3 id=\"%E5%AE%B9%E9%87%8F%E4%B8%8E%E5%A4%A7%E5%B0%8F%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0\">3、容量与大小相关函数</h3>\n<h3 id=\"size\">size</h3>\n<blockquote>\n<p>直接返回隐含this指针指向的_size即为字符串长度</p>\n<pre><code class=\"language-cpp\">//返回字符串的长度\nsize_t size() const //不改变内部成员，最好加上const\n{\n\treturn _size;\n}</code></pre>\n</blockquote>\n<hr/>\n<h3 id=\"capacity\">capacity</h3>\n<blockquote>\n<p>直接返回隐含this指针指向的_capacity即可</p>\n<pre><code class=\"language-cpp\">//返回字符串容量\nsize_t capacity() const //不改变内部成员，最好加上const\n{\n\treturn _capacity;\n}</code></pre>\n</blockquote>\n<hr/>\n<h3 id=\"%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0\">4、字符串访问相关函数</h3>\n<h3 id=\"%E5%A2%9E%E5%8A%A0\">operator[ ]重载</h3>\n<blockquote>\n<p>有了operator[ ]运算符重载，便可以直接用下标+[ ]进行元素访问，不过这里还应提供一个<span style=\"color:#ff9900;\">const版本的operator[ ]运算符重载</span>，<span style=\"color:#956fe7;\">以便于普通对象和const对象均可调用而不会出现权限放大的问题</span>。</p>\n<pre><code class=\"language-cpp\">//版本1：\nchar&amp; operator[](size_t pos)//引用返回，便于后续修改返回的字符\n{\n\tassert(pos &lt; _size);//记得确保pos位置的合法性，不能超过字符串\n\treturn _str[pos]; //返回pos位置字符的引用\n}\n//版本2：\nconst char&amp; operator[](size_t pos) const//引用返回，便于后续修改返回的字符\n{\n\tassert(pos &lt; _size);\n\treturn _str[pos]; //返回pos位置字符的引用\n}</code></pre>\n</blockquote>\n<hr/>\n<h3 id=\"11\">迭代器</h3>\n<blockquote>\n<p>string类的迭代器就是像<span style=\"color:#956fe7;\">字符指针</span>一样的东西</p>\n<ol><li>begin函数的作用就是返回字符串中第一个字符的地址</li><li>end函数的作用就是返回字符串最后一个字符的后一个位置的地址，即'\\0'的地址</li></ol>\n<pre><code class=\"language-cpp\">//版本1：\ntypedef char* iterator;\niterator begin()\n{\n\treturn _str;//返回第一个有效字符的指针\n}\niterator end()\n{\n\treturn _str + _size;//返回最后一个字符后一个位置的地址，即'\\0'的地址\n}</code></pre>\n<p>和上文的operator[ ]重载一样，这里也要写一个const版本的迭代器，以便于后续的const对象也能够调用。</p>\n<pre><code class=\"language-cpp\">//版本2：只读，const对象可调用\ntypedef const char* const_iterator;\nconst_iterator begin() const\n{\n\treturn _str;//返回第一个有效字符的指针\n}\nconst_iterator end() const\n{\n\treturn _str + _size;//返回最后一个字符后一个位置的地址，即'\\0'的地址\n}</code></pre>\n<p>这里还有一种基于迭代器的遍历方式：<strong><span style=\"color:#956fe7;\">范围for</span></strong></p>\n<p>范围for的底层实现原理和迭代器没两样，只不过写法看着很高端。</p>\n<pre><code class=\"language-cpp\">void test_string()\n{\n\tcpp::string s1(\"hello world\");\n\t//迭代器\n\tcpp::string::iterator it = s1.begin();\n\twhile (it != s1.end())\n\t{\n\t\tcout &lt;&lt; *it &lt;&lt; \" \"; //h e l l o   w o r l d\n\t\tit++;\n\t}\n\tcout &lt;&lt; endl;\n\t//范围for\n\tfor (auto&amp; ch : s1) //加上引用，相当于是每个字符的别名，便于修改\n\t{\n\t\tch -= 1;\n\t}\n\tfor (auto&amp; ch : s1)\n\t{\n\t\tcout &lt;&lt; ch &lt;&lt; \" \"; //g d k k n  v n q k c\n\t}\n}</code></pre>\n</blockquote>\n<hr/>\n<h3>5、增加的相关函数接口</h3>\n<h3 id=\"33\">reserve扩容</h3>\n<blockquote>\n<p>reserve扩容只影响_capacity空间，不影响_size，其有以下两点规则</p>\n<ol><li>当n大于对象当前的capacity时，将capacity扩大到n或大于n。</li><li>当n小于对象当前的capacity时，无需操作。</li></ol>\n<pre><code class=\"language-cpp\">//reserve扩容\nvoid reserve(size_t n)\n{\n\tif (n &gt; _capacity)\n\t{\n\t\tchar* tmp = new char[n + 1];//每次开空间一定要多给一个字节给'\\0'\n\t\tstrcpy(tmp, _str);\n        //释放旧空间\n\t\tdelete[] _str;\n        //把新空间赋给_str\n\t\t_str = tmp;\n        //更新容量_capacity\n\t\t_capacity = n;\n\t}\n}</code></pre>\n</blockquote>\n<hr/>\n<h3 id=\"44\">resize</h3>\n<blockquote>\n<p>resize是将字符串调整为n个字符的长度，不仅会改变_size，还会改变_capacity空间。规则如下：</p>\n<ol><li>如果n小于当前的_size长度，将_size缩小到n</li><li>如果n大于当前的_size长度，将_size扩大到n，扩大的字符默认为'\\0'</li></ol>\n<p><img alt=\"\" height=\"163\" src=\"image\\9abc65d90334431db226c1de801c8df8.png\" width=\"656\"/></p>\n<pre><code class=\"language-cpp\">//resize调整大小\nvoid resize(size_t n, char ch = '\\0')\n{\n\t//如果n &lt; _size，就保留前n个字符即可，把下标n置为'\\0'\n\tif (n &lt; _size)\n\t{\n\t\t_size = n;\n\t\t_str[_size] = '\\0';\n\t}\n\telse\n\t{\n\t\t//如果n &gt; _capacity，就要扩容了\n\t\tif (n &gt; _capacity)\n\t\t{\n\t\t\treserve(n);\n\t\t}\n\t\tfor (size_t i = _size; i &lt; n; i++)\n\t\t{\n\t\t\t//把剩余的字符置为ch\n\t\t\t_str[i] = ch;\n\t\t}\n\t\t_size = n;\n\t\t_str[_size] = '\\0';\n\t}\n}</code></pre>\n</blockquote>\n<hr/>\n<h3 id=\"%E5%88%A0%E9%99%A4\">push_back追加字符</h3>\n<blockquote>\n<p>首先要考虑需不需要扩容，如若需要，直接复用reserve函数进行增容，追加字符后，记得把最后一个下标_size对应的值置为'\\0'。</p>\n<pre><code class=\"language-cpp\">//push_back\nvoid push_back(char ch)\n{\n/*法一*/\n\t//先检查是否需要扩容\n\tif (_size == _capacity)\n\t{\n\t\t//复用reserve进行扩容，如果一开始容量为0，记得处理，否则容量*2依旧为0\n\t\treserve(_capacity == 0 ? 4 : _capacity * 2);\n\t}\n\t_str[_size] = ch;\n\t_size++;\n\t_str[_size] = '\\0'; //注意最后一个值恒为'\\0'以确保字符串的完整性\n}</code></pre>\n<p>这里我们还可使用后文写好的<span style=\"color:#956fe7;\">insert尾插字符</span>，因为当insert函数中的pos为_size时即为尾插：</p>\n<pre><code class=\"language-cpp\">//push_back尾插字符\nvoid push_back(char ch)\n{\n\t//法二：复用insert尾插入字符\n\tinsert(_size, ch);\n}</code></pre>\n</blockquote>\n<hr/>\n<h3>append追加字符串</h3>\n<blockquote>\n<p>使用append追加字符串首先要判断是否需要扩容，扩容后利用strcpy函数把追加的字符串拷贝到原字符串末尾即可，不需要额外处理'\\0'，因为strcpy默认把'\\0'拷贝过去。</p>\n<pre><code class=\"language-cpp\">//append\nvoid append(const char* str)\n{\n\t//统计追加字符串后的长度\n\tsize_t len = _size + strlen(str);\n\t//判断是否需要扩容\n\tif (len &gt; _capacity)\n\t{\n\t\treserve(len);\n\t}\n\t//把字符串追加到末尾\n\tstrcpy(_str + _size, str);\n\t_size = len;\n}</code></pre>\n<p>这里也可以使用后文的insert追加字符串来完成，因为当pos为_size时，就是在尾部追加字符串。</p>\n<pre><code class=\"language-cpp\">void append(const char* str)\n{\n\t//法二：复用insert函数\n\tinsert(_size, str);\n}</code></pre>\n</blockquote>\n<hr/>\n<h3 id=\"22\">operator+=</h3>\n<blockquote>\n<p>operator+=可以追加字符、字符串、对象。因此我们可以分开来讨论：</p>\n<ul><li><span style=\"background-color:#edf6e8;\"><strong>追加字符：</strong>直接复用push_back</span></li></ul>\n<pre><code class=\"language-cpp\">//operator+=字符\nstring&amp; operator+=(char ch)\n{\n\t//复用push_back\n\tpush_back(ch);\n\treturn *this;\n}</code></pre>\n<ul><li><span style=\"color:#0d0016;\"><span style=\"background-color:#edf6e8;\"><strong>追加字符串：</strong>直接复用append</span></span></li></ul>\n<pre><code class=\"language-cpp\">//operator+=字符串\nstring&amp; operator+=(const char* str)\n{\n\t//复用append\n\tappend(str);\n\treturn *this;\n}</code></pre>\n</blockquote>\n<hr/>\n<h3>insert</h3>\n<blockquote>\n<p>insert的作用是在指定pos位置往后<span style=\"color:#956fe7;\">插入字符</span><span style=\"color:#494949;\">或</span><span style=\"color:#956fe7;\">字符串</span>。</p>\n<ul><li><span style=\"background-color:#edf6e8;\">insert在pos位置插入字符</span></li></ul>\n<p>这里首先要判断pos的合法性，接下来就要挪动数据了，这里我们优先考虑从最后一个'\\0'位置的下一个位置（_size + 1）开始往前挪动。因此定义end指向'\\0'后一个位置，当end挪到与pos位置重合时停止，最后把插入的字符ch挪到下标pos处。记得最后更新_size++。</p>\n<p><img alt=\"\" height=\"210\" src=\"image\\a4d6f8b2d2e84b5caf2e38d3df5b283e.png\" width=\"730\"/></p>\n<pre><code class=\"language-cpp\">//insert插入字符\nstring&amp; insert(size_t pos, char ch)\n{\n\tassert(pos &lt;= _size);\n\tif (_size == _capacity)\n\t{\n\t\t//复用reserve进行扩容，如果一开始容量为0，记得处理，否则容量*2依旧为0\n\t\treserve(_capacity == 0 ? 4 : _capacity * 2);\n\t}\n\tsize_t end = _size + 1; //最好把end放到_size + 1的位置，防止后续出现整型提升等问题\n\twhile (end &gt; pos)\n\t{\n\t\t_str[end] = _str[end - 1];\n\t\tend--;\n\t}\n\t//当end挪动到pos的位置时停止挪动，并把ch赋到pos的下标处\n\t_str[pos] = ch;\n\t_size += 1;\n\treturn *this;\n}</code></pre>\n<p>测试入下：</p>\n<pre><code class=\"language-cpp\">void test_string()\n{\n\tcpp::string s(\"hello world\");\n\ts.insert(6, '@');\n\ts += '@';\n\tcout &lt;&lt; s.c_str() &lt;&lt; endl; //hello @world@\n\tfor (auto&amp; ch : s)\n\t{\n\t\tcout &lt;&lt; ch &lt;&lt; \" \"; \n\t}\n\tcout &lt;&lt; \"#\" &lt;&lt; endl; //h e l l o   @ w o r l d @ #\n\t\n \ts += '\\0';\n\tfor (auto&amp; ch : s)\n\t{\n\t\tcout &lt;&lt; ch &lt;&lt; \" \"; \n\t}\n\tcout &lt;&lt; \"#\" &lt;&lt; endl; //h e l l o   @ w o r l d @  #\n\ts.insert(0, '@');\n\tcout &lt;&lt; s.c_str() &lt;&lt; endl;//@hello @world@\n}\n</code></pre>\n<ul><li><span style=\"background-color:#edf6e8;\">insert在pos位置插入字符串</span></li></ul>\n<p>首先判断是否需要扩容，接下来挪动数据。定义变量end为_size + len的位置，把pos处往后的字符串整体往后挪动直至空出插入字符串的长度。利用循环+ _str[end] = _str[end - len];来完成。当end挪动到pos + len - 1时结束循环，再利用strncpy函数把插入的字符串拷贝过去即可。</p>\n<p><img alt=\"\" height=\"478\" src=\"image\\330fc087470748d0aa841a9c9676d595.png\" width=\"738\"/></p>\n<pre><code class=\"language-cpp\">//insert插入字符串\nstring&amp; insert(size_t pos, const char* str)\n{\n\tassert(pos &lt;= _size);\n\tsize_t len = strlen(str);\n    if (len == 0)\n\t{\n\t\t//如果传进来的字符串为空，直接返回即可\n\t\treturn *this;\n\t}\n\tif (_size + len &gt; _capacity)\n\t{\n\t\t//判断是否扩容\n\t\treserve(_size + len);\n\t}\n\tsize_t end = _size + len;\n\t//当end &gt;= pos + len时都不结束循环\n\twhile (end &gt;= pos + len)\n\t{\n\t\t_str[end] = _str[end - len];\n\t\tend--;\n\t}\n\t//不能使用strcpy，因为会把\\0也拷过去，就会出错\n\tstrncpy(_str + pos, str, len);\n\t_size += len;\n\treturn *this;\n}</code></pre>\n<p>测试如下：</p>\n<pre><code class=\"language-cpp\">void test_string()\n{\n\tcpp::string s(\"hello world\");\n\ts.insert(0, \"xxx\");\n\tcout &lt;&lt; s.c_str() &lt;&lt; endl;//xxxhello world\n}</code></pre>\n</blockquote>\n<hr/>\n<h3>6、删除的相关函数接口</h3>\n<h3 id=\"%E6%9F%A5%E6%89%BE\">erase</h3>\n<blockquote>\n<p>如果给定删除的长度len为npos无符号值，或者说len + pos的长度&gt;=_size，那么直接把pos位置的值设定为'\\0\\即可，因为此时就是把pos后的所有数据全部删除。出去这种特殊情况，其余的就是从pos + len处开始先前挪动到_size + 1为止。pos后的数据往前覆盖即可。</p>\n<p><img alt=\"\" height=\"325\" src=\"image\\b47a646341f14c97a565724ac09956cf.png\" width=\"828\"/></p>\n<pre><code class=\"language-cpp\">//erase删除\nvoid erase(size_t pos, size_t len = npos)\n{\n    assert(pos &lt; _size);\n\tif (len == npos || pos + len &gt;= _size)\n\t{\n\t\t//这种情况是删除pos后的所有数据，直接把pos处设定为'\\0'即可\n\t\t_str[pos] = '\\0';\n\t\t_size = pos;\n\t}\n\telse\n\t{\n\t\tsize_t begin = pos + len;\n\t\twhile (begin &lt;= _size)\n\t\t{\n\t\t\t_str[begin - len] = _str[begin];\n\t\t\t++begin;\n\t\t}\n\t\t_size -= len;\n\t}\n}</code></pre>\n<p>测试如下：</p>\n<pre><code class=\"language-cpp\">void test_string9()\n{\n\tcpp::string s(\"hello world\");\n\ts.insert(0, \"xxx\");\n\tcout &lt;&lt; s.c_str() &lt;&lt; endl;//xxxhello world\n\ts.erase(0, 3);\n\tcout &lt;&lt; s.c_str() &lt;&lt; endl;//hellow world\n}</code></pre>\n</blockquote>\n<hr/>\n<h3>clear清除数据</h3>\n<blockquote>\n<p>clear函数是用来清除原字符串的所有数据，并不是连空间一并清除了，所以我们只需要把下标0置为'\\0'，并把有效字符个数_size置为0即可。</p>\n<pre><code class=\"language-cpp\">//clear清除数据\nvoid clear()\n{\n\t_str[0] = '\\0';\n\t_size = 0;\n}</code></pre>\n</blockquote>\n<hr/>\n<h3>7、查找的相关函数接口</h3>\n<h3>find</h3>\n<blockquote>\n<p>find函数也分查找字符和字符串</p>\n<ul><li><span style=\"background-color:#edf6e8;\">find查找字符：</span></li></ul>\n<p>直接遍历即可：</p>\n<pre><code class=\"language-cpp\">//find查找字符\t\nsize_t find(char ch, size_t pos = 0)\n{\n\tfor (; pos &lt; _size; pos++)\n\t{\n\t\tif (_str[pos] == ch)\n\t\t\treturn pos;\n\t}\n\t//没找到就返回npos，-1\n\treturn npos; //-1\n}</code></pre>\n<ul><li><span style=\"background-color:#edf6e8;\">find查找字符串：</span></li></ul>\n<p>这里可以直接复用C语言的strstr函数进行查找，不过该函数返回的是地址，想要获得最终的下标直接利用地址相减即可，p - _str</p>\n<pre><code class=\"language-cpp\">size_t find(const char* str, size_t pos = 0)\n{\n\t//直接复用C语言库函数strstr即可，strstr函数返回的是地址\n\tconst char* p = strstr(_str + pos, str);\n\tif (p == nullptr)\n\t{\n\t\treturn npos;\n\t}\n\telse\n\t{\n\t\t//返回下标直接用p - str即可\n\t\treturn p - _str;\n\t}\n}</code></pre>\n</blockquote>\n<hr/>\n<h3>8、c_str获取字符串</h3>\n<blockquote>\n<p>c_str用于获取c类型的字符串，直接返回字符串即可</p>\n<pre><code class=\"language-cpp\">//c_str  获取c形式的字符串\nconst char* c_str() const //最好加上const，便于普通及const对象均可调用\n{\n\treturn _str;\n}</code></pre>\n</blockquote>\n<hr/>\n<h3>9、swap交换函数</h3>\n<blockquote>\n<p>swap函数用于交换两个对象的数据，我们可以通过复用库里的swap函数来完成，但是要在前面加上作用域限定符\"<span style=\"color:#fe2c24;\"><strong>::</strong></span>\"。让编译器在全局域的库里调用swap函数。</p>\n<pre><code class=\"language-cpp\">//swap交换函数\nvoid swap(string&amp; s)\n{\n\tstd::swap(_str, s._str);\n\tstd::swap(_size, s._size);\n\tstd::swap(_capacity, s._capacity);\n}</code></pre>\n</blockquote>\n<hr/>\n<h3>10、非成员函数</h3>\n<h3 id=\"%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD\">关系运算符函数重载</h3>\n<blockquote>\n<p>关系运算符有==、!=、&lt;、&lt;=、&gt;、&gt;=这6类，先前的日期类已经讲解过类似的。这里关系运算符重载我们不把它放到成员函数里头。</p>\n<ul><li><span style=\"background-color:#edf6e8;\">1、operator&lt;</span></li></ul>\n<p>直接借用库函数strcmp进行字符串大小比较即可。此外，和日期类一样，写好了&lt;和==的重载，剩下的4个关系运算符直接复用即可。</p>\n<pre><code class=\"language-cpp\">//1、operator&lt;\nbool operator&lt;(const string&amp; s1, const string&amp; s2)\n{\n\treturn strcmp(s1.c_str(), s2.c_str()) &lt; 0;\n}\t\n//2、operator==\nbool operator==(const string&amp; s1, const string&amp; s2)\n{\n\treturn strcmp(s1.c_str(), s2.c_str()) == 0;\n}</code></pre>\n<p>剩下4个关系运算符复用上面两个：</p>\n<pre><code class=\"language-cpp\">//3、operator&lt;=\nbool operator&lt;=(const string&amp; s1, const string&amp; s2)\n{\n\treturn s1 &lt; s2 || s1 == s2;\n}\n//4、operator&gt;\nbool operator&gt;(const string&amp; s1, const string&amp; s2)\n{\n\treturn !(s1 &lt;= s2);\n}\n//5、operator&gt;=\nbool operator&gt;=(const string&amp; s1, const string&amp; s2)\n{\n\treturn !(s1 &lt; s2);\n}\n//6、operator!=\nbool operator!=(const string&amp; s1, const string&amp; s2)\n{\n\treturn !(s1 == s2);\n}</code></pre>\n</blockquote>\n<hr/>\n<h3 id=\"%E6%BA%90%E7%A0%81%E6%B1%87%E6%80%BB\">&lt;&lt;流插入运算符重载</h3>\n<blockquote>\n<p>这里我们可以通过范围for来完成&lt;&lt;运算符的重载</p>\n<pre><code class=\"language-cpp\">//&lt;&lt;流插入运算符重载\nostream&amp; operator&lt;&lt;(ostream&amp; out, const string&amp; s)\n{\n\tfor (auto ch : s)\n\t{\n\t\tout &lt;&lt; ch;\n\t}\n\treturn out;\n}</code></pre>\n</blockquote>\n<hr/>\n<h3 id=\"%3E%3E%E5%92%8C%3C%3C%E9%87%8D%E8%BD%BD\">&gt;&gt;流提取运算符重载</h3>\n<blockquote>\n<p>这里实现的过程种要注意当遇到空格或换行符时就要停止读取了。此外，<span style=\"color:#956fe7;\">在一开始要记得调用clear函数把原字符串的所有数据给清空</span>，然后才能正常往后输入新的数据，否则新数据会累加到原数据后面，就不是&gt;&gt;预期的效果了。</p>\n<pre><code class=\"language-cpp\">//&gt;&gt;流提取运算符重载\nistream&amp; operator&gt;&gt;(istream&amp; in, string&amp; s)\n{\n\t法一：\n    //要先把原字符串的所有数据给清空才可以输入新的数据，否则会累加到原数据后面，出错\n\ts.clear();\n\tchar ch;\n\tch = in.get();//使用get()函数才能获取空格或者换行字符\n\twhile (ch != ' ' &amp;&amp; ch != '\\n')\n\t{\n\t\ts += ch;\n\t\tch = in.get();\n\t}\n\treturn in;\n}</code></pre>\n<p>这里有个缺陷，如若频繁输入大量字符，那么就会多次扩容，扩容也会在效率上有所损耗，因此我们可以提前开辟一个128字节大小的数组，把每次输进的字符放到数组里头，最后当遇到停止的符号时，+=到字符串s上，如若下标加到127，把数组的字符+=到字符串s上，并充值数组为'\\0'，更新下标为0即可。以此类推。</p>\n<pre><code class=\"language-cpp\">//&gt;&gt;流提取运算符重载\nistream&amp; operator&gt;&gt;(istream&amp; in, string&amp; s)\n{\n    //法二：\n    //要先把原字符串的所有数据给清空才可以输入新的数据，否则会累加到原数据后面，出错\n\ts.clear();\n\tchar ch;\n\tch = in.get();//使用get()函数才能获取空格或者换行字符\n\tchar buff[128] = { '\\0' };\n\tsize_t i = 0;\n\twhile (ch != ' ' &amp;&amp; ch != '\\n')\n\t{\n\t\tbuff[i++] = ch;\n\t\tif (i == 127)\n\t\t{\n\t\t\ts += buff;\n\t\t\tmemset(buff, '\\0', 128);\n\t\t\ti = 0;\n\t\t}\n\t\tch = in.get();\n\t}\n\ts += buff;\n\treturn in;\n}</code></pre>\n</blockquote>\n<hr/>\n<h3 id=\"getline%E5%87%BD%E6%95%B0\">getline函数</h3>\n<blockquote>\n<p>getline函数与上述写的&lt;&lt;流提取运算符重载非常相似，唯一不同的地方在于<span style=\"color:#956fe7;\">getline只有在遇到换行符才停止读取</span>，而<span style=\"color:#956fe7;\">&lt;&lt;在遇到换行符停止外，遇到空格也会停止读取</span>，因此，在&lt;&lt;的基础上改变下if种的判断条件即可：</p>\n<pre><code class=\"language-cpp\">//getline函数\nistream&amp; getline(istream&amp; in, string&amp; s)\n{\n\ts.clear();\n\tchar ch;\n\tch = in.get();\n\t//getline函数只有在遇到换行符才会停止\n\twhile (ch != '\\n')\n\t{\n\t\ts += ch;\n\t\tch = in.get();\n\t}\n\treturn in;\n}</code></pre>\n<p>测试如下：</p>\n<p><img alt=\"\" height=\"142\" src=\"image\\b5fc970b01654602a53efac1b9f715b9.png\" width=\"672\"/></p>\n<p></p>\n</blockquote>\n<hr/>\n<h3 id=\"%E6%80%BB%E8%A7%88\">11、源码链接</h3>\n<blockquote>\n<p>gitee仓库一键传送：<a class=\"link-info\" href=\"https://gitee.com/bit-zy/xzy--c/blob/master/stl_string/stl_string/String.h\" title=\"string类的模拟实现完整版链接\">string类的模拟实现完整版链接</a></p>\n</blockquote>\n</div>\n</div>"}