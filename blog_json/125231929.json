{"blogid": "125231929", "writerAge": "码龄13年", "writerBlogNum": "11", "writerCollect": "51", "writerComment": "18", "writerFan": "15", "writerGrade": "3级", "writerIntegral": "676", "writerName": "柏林春天", "writerProfileAdress": "writer_image\\profile_125231929.jpg", "writerRankTotal": "46447", "writerRankWeekly": "238818", "writerThumb": "12", "writerVisitNum": "58145", "blog_read_count": "1150", "blog_time": "于 2022-06-11 10:33:30 发布", "blog_title": "Marshal函数中文介绍C#", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h1><a id=\"public_static_class_Marshal_0\"></a>public static class Marshal</h1>\n<p>提供用于分配非托管内存、复制非托管内存块、将托管类型转换为非托管类型的方法的集合，以及与非托管代码交互时使用的其他杂项方法。以下是介绍，每个介绍的最后给出了函数签名。</p>\n<p> <br/> 摘要： 表示系统上的默认字符大小;对于 Unicode 系统，默认值为 2，对于 ANSI 系统，默认值为 1。此字段是只读的。</p>\n<h4><a id=\"public_static_readonly_int_SystemDefaultCharSize_6\"></a>public static readonly int SystemDefaultCharSize;</h4>\n<p> <br/> 摘要：表示当前操作系统的双字节字符集 （DBCS） 大小（以字节为单位）的最大大小。此字段是只读的。</p>\n<h4><a id=\"public_static_readonly_int_SystemMaxDBCSCharSize_9\"></a>public static readonly int SystemMaxDBCSCharSize;</h4>\n<p> <br/> 摘要： 递增指定接口上的引用计数。<br/> 参数:<br/> pUnk：要递增的接口引用计数。<br/> 返回结果：pUnk 参数上引用计数的新值。</p>\n<h4><a id=\"public_static_int_AddRefIntPtr_pUnk_15\"></a>public static int AddRef(IntPtr pUnk);</h4>\n<p> <br/> 摘要：从COM任务内存分配器中分配指定大小的内存块。<br/> 参数:<br/> cb：要分配的内存块的大小。<br/> 返回结果：一个整数，表示所分配内存块的地址。此内存必须与 System.Runtime.InteropServices.Marshal.FreeCoTaskMem（System.IntPtr） 一起释放。<br/> 异常:<br/> T：System.OutOfMemoryException：内存不足，无法满足请求。</p>\n<h4><a id=\"public_static_IntPtr_AllocCoTaskMemint_cb_23\"></a>public static IntPtr AllocCoTaskMem(int cb);</h4>\n<p> <br/> 摘要：使用指定的字节数从进程的非托管内存中分配内存。<br/> 参数:<br/> cb：内存中所需的字节数。<br/> 返回结果：指向新分配内存的指针。此内存必须使用 System.Runtime.InteropServices.Marshal.FreeHGlobal（System.IntPtr） 方法释放。<br/> 异常:<br/> T：System.OutOfMemoryException：内存不足，无法满足请求。</p>\n<h4><a id=\"public_static_IntPtr_AllocHGlobalint_cb_31\"></a>public static IntPtr AllocHGlobal(int cb);</h4>\n<p> <br/> 摘要：通过使用指针从进程的非托管内存中分配内存到指定数量的字节。<br/> 参数:<br/> cb：内存中所需的字节数。<br/> 返回结果：指向新分配内存的指针。此内存必须使用 System.Runtime.InteropServices.Marshal.FreeHGlobal（System.IntPtr） 方法释放。<br/> 异常:<br/> T：System.OutOfMemoryException：内存不足，无法满足请求。</p>\n<h4><a id=\"public_static_IntPtr_AllocHGlobalIntPtr_cb_39\"></a>public static IntPtr AllocHGlobal(IntPtr cb);</h4>\n<p> <br/> 摘要：指示来自任何上下文的运行时可调用包装器 （RCW） 是否可用于清理。<br/> 返回结果：如果有任何 RCW 可用于清理，则返回结果;否则，为假。</p>\n<h4><a id=\"public_static_bool_AreComObjectsAvailableForCleanup_43\"></a>public static bool AreComObjectsAvailableForCleanup();</h4>\n<p> <br/> 摘要：获取由指定名字对象标识的接口指针。<br/> 参数:<br/> 名字对象名称：对应于所需接口指针的名称。<br/> 返回结果：一个对象，其中包含对由名字名 Name 参数标识的接口指针的引用。名字对象是一个名称，在本例中，名字对象由接口定义。<br/> 异常:<br/> T：System.Runtime.InteropServices.COMException：未识别的 HRESULT 由非托管 BindToMoniker 方法返回。</p>\n<h4><a id=\"public_static_object_BindToMonikerstring_monikerName_51\"></a>public static object BindToMoniker(string monikerName);</h4>\n<p> <br/> 摘要：更改对象的 COM 可调用包装 （CCW） 句柄的强度。<br/> 参数:<br/> otp：其 CCW 保存引用计数句柄的对象。如果《特定常规武器公约》上的参考计数大于零，则句柄很强;否则，它是弱的。<br/> fIsWeak：true 将 otp 参数上句柄的强度更改为弱，而不考虑其引用计数;false 以重置 otp 上的句柄强度以进行参考计数。</p>\n<h4><a id=\"public_static_void_ChangeWrapperHandleStrengthobject_otp_bool_fIsWeak_57\"></a>public static void ChangeWrapperHandleStrength(object otp, bool fIsWeak);</h4>\n<p> <br/> 摘要：通知运行时清理当前上下文中分配的所有运行时可调用包装 （RCW）。</p>\n<h4><a id=\"public_static_void_CleanupUnusedObjectsInCurrentContext_60\"></a>public static void CleanupUnusedObjectsInCurrentContext();</h4>\n<p> <br/> 摘要：将数据从一维、受管的单精度浮点数数组复制到非托管内存指针。<br/> 参数:<br/> 源：要从中复制的一维数组。<br/> startIndex：源数组中应开始复制的从零开始的索引。<br/> 目标：要复制到的内存指针。<br/> length：要复制的数组元素数。<br/> 异常:<br/> T：System.ArgumentOutOfRangeException： startIndex 和 length 是无效的。<br/> T：System.ArgumentNullException：source、startIndex、destination 或 length 为 null。</p>\n<h4><a id=\"public_static_void_Copyfloat_source_int_startIndex_IntPtr_destination_int_length_71\"></a>public static void Copy(float[] source, int startIndex, IntPtr destination, int length);</h4>\n<p> <br/> 摘要：将数据从一维的受管 System.IntPtr 数组复制到非受管内存指针。<br/> 参数:<br/> 源：要从中复制的一维数组。<br/> startIndex：源数组中应开始复制的从零开始的索引。<br/> 目标：要复制到的内存指针。<br/> length：要复制的数组元素数。<br/> 异常:<br/> T：System.ArgumentNullException：source、destination、startIndex 或 length 为 null。</p>\n<h4><a id=\"public_static_void_CopyIntPtr_source_int_startIndex_IntPtr_destination_int_length_81\"></a>public static void Copy(IntPtr[] source, int startIndex, IntPtr destination, int length);</h4>\n<p> <br/> 摘要：将数据从非托管内存指针复制到托管的单精度浮点数数组。<br/> 参数:<br/> 源：要从中复制的内存指针。<br/> 目标：要复制到的数组。<br/> startIndex：应开始复制的目标数组中从零开始的索引。<br/> length：要复制的数组元素数。<br/> 异常:<br/> T：System.ArgumentNullException：source、destination、startIndex 或 length 为 null。</p>\n<h4><a id=\"public_static_void_CopyIntPtr_source_float_destination_int_startIndex_int_length_91\"></a>public static void Copy(IntPtr source, float[] destination, int startIndex, int length);</h4>\n<p> <br/> 摘要：将数据从非托管内存指针复制到受管系统。IntPtr 阵列。<br/> 参数:<br/> 源：要从中复制的内存指针。<br/> 目标：要复制到的数组。<br/> startIndex：应开始复制的目标数组中从零开始的索引。<br/> length：要复制的数组元素数。<br/> 异常:<br/> T：System.ArgumentNullException：source、destination、startIndex 或 length 为 null。</p>\n<h4><a id=\"public_static_void_CopyIntPtr_source_IntPtr_destination_int_startIndex_int_length_101\"></a>public static void Copy(IntPtr source, IntPtr[] destination, int startIndex, int length);</h4>\n<p> <br/> 摘要：将数据从非托管内存指针复制到托管的 64 位有符号整数数组。<br/> 参数:<br/> 源：要从中复制的内存指针。<br/> 目标：要复制到的数组。<br/> startIndex：应开始复制的目标数组中从零开始的索引。<br/> length：要复制的数组元素数。<br/> 异常:<br/> T：System.ArgumentNullException：source、destination、startIndex 或 length 为 null。</p>\n<h4><a id=\"public_static_void_CopyIntPtr_source_long_destination_int_startIndex_int_length_111\"></a>public static void Copy(IntPtr source, long[] destination, int startIndex, int length);</h4>\n<p> <br/> 摘要：将数据从非托管内存指针复制到托管的 32 位有符号整数数组。<br/> 参数:<br/> 源：要从中复制的内存指针。<br/> 目标：要复制到的数组。<br/> startIndex：应开始复制的目标数组中从零开始的索引。<br/> length：要复制的数组元素数。<br/> 异常:<br/> T：System.ArgumentNullException：source、destination、startIndex 或 length 为 null。</p>\n<h4><a id=\"public_static_void_CopyIntPtr_source_int_destination_int_startIndex_int_length_121\"></a>public static void Copy(IntPtr source, int[] destination, int startIndex, int length);</h4>\n<p> <br/> 摘要：将数据从非托管内存指针复制到托管的双精度浮点数数组。<br/> 参数:<br/> 源：要从中复制的内存指针。<br/> 目标：要复制到的数组。<br/> startIndex：应开始复制的目标数组中从零开始的索引。<br/> length：要复制的数组元素数。<br/> 异常:<br/> T：System.ArgumentNullException：source、destination、startIndex 或 length 为 null。</p>\n<h4><a id=\"public_static_void_CopyIntPtr_source_double_destination_int_startIndex_int_length_131\"></a>public static void Copy(IntPtr source, double[] destination, int startIndex, int length);</h4>\n<p> <br/> 摘要：将数据从非托管内存指针复制到托管的 16 位有符号整数数组。<br/> 参数:<br/> 源：要从中复制的内存指针。<br/> 目标：要复制到的数组。<br/> startIndex：应开始复制的目标数组中从零开始的索引。<br/> length：要复制的数组元素数。<br/> 异常:<br/> T：System.ArgumentNullException：source、destination、startIndex 或 length 为 null。</p>\n<h4><a id=\"public_static_void_CopyIntPtr_source_short_destination_int_startIndex_int_length_141\"></a>public static void Copy(IntPtr source, short[] destination, int startIndex, int length);</h4>\n<p> <br/> 摘要：将数据从非托管内存指针复制到托管的 8 位无符号整数数组。<br/> 参数:<br/> 源：要从中复制的内存指针。<br/> 目标：要复制到的数组。<br/> startIndex：应开始复制的目标数组中从零开始的索引。<br/> length：要复制的数组元素数。<br/> 异常:<br/> T：System.ArgumentNullException：source、destination、startIndex 或 length 为 null。</p>\n<h4><a id=\"public_static_void_CopyIntPtr_source_byte_destination_int_startIndex_int_length_151\"></a>public static void Copy(IntPtr source, byte[] destination, int startIndex, int length);</h4>\n<p> <br/> 摘要：将数据从一维的、受管的 64 位有符号整数数组复制到非托管内存指针。<br/> 参数:<br/> 源：要从中复制的一维数组。<br/> startIndex：源数组中应开始复制的从零开始的索引。<br/> 目标：要复制到的内存指针。<br/> length：要复制的数组元素数。<br/> 异常:<br/> T：System.ArgumentOutOfRangeException： startIndex 和 length 是无效的。<br/> T：System.ArgumentNullException：source、startIndex、destination 或 length 为 null。</p>\n<h4><a id=\"public_static_void_Copylong_source_int_startIndex_IntPtr_destination_int_length_162\"></a>public static void Copy(long[] source, int startIndex, IntPtr destination, int length);</h4>\n<p> <br/> 摘要：将数据从一维的、受管的 32 位有符号整数数组复制到非托管内存指针。<br/> 参数:<br/> 源：要从中复制的一维数组。<br/> startIndex：源数组中应开始复制的从零开始的索引。<br/> 目标：要复制到的内存指针。<br/> length：要复制的数组元素数。<br/> 异常:<br/> T：System.ArgumentOutOfRangeException： startIndex 和 length 是无效的。<br/> T：System.ArgumentNullException：startIndex 或 length 为 null。</p>\n<h4><a id=\"public_static_void_Copyint_source_int_startIndex_IntPtr_destination_int_length_173\"></a>public static void Copy(int[] source, int startIndex, IntPtr destination, int length);</h4>\n<p> <br/> 摘要：将数据从一维、受管的 16 位有符号整数数组复制到非托管内存指针。<br/> 参数:<br/> 源：要从中复制的一维数组。<br/> startIndex：源数组中应开始复制的从零开始的索引。<br/> 目标：要复制到的内存指针。<br/> length：要复制的数组元素数。<br/> 异常:<br/> T：System.ArgumentOutOfRangeException： startIndex 和 length 是无效的。<br/> T：System.ArgumentNullException：source、startIndex、destination 或 length 为 null。</p>\n<h4><a id=\"public_static_void_Copyshort_source_int_startIndex_IntPtr_destination_int_length_184\"></a>public static void Copy(short[] source, int startIndex, IntPtr destination, int length);</h4>\n<p> <br/> 摘要：将数据从一维、受管的双精度浮点数数组复制到非托管内存指针。<br/> 参数:<br/> 源：要从中复制的一维数组。<br/> startIndex：源数组中应开始复制的从零开始的索引。<br/> 目标：要复制到的内存指针。<br/> length：要复制的数组元素数。<br/> 异常:<br/> T：System.ArgumentOutOfRangeException： startIndex 和 length 是无效的。<br/> T：System.ArgumentNullException：source、startIndex、destination 或 length 为 null。</p>\n<h4><a id=\"public_static_void_Copydouble_source_int_startIndex_IntPtr_destination_int_length_195\"></a>public static void Copy(double[] source, int startIndex, IntPtr destination, int length);</h4>\n<p> <br/> 摘要：将数据从一维的托管字符数组复制到非托管内存指针。<br/> 参数:<br/> 源：要从中复制的一维数组。<br/> startIndex：源数组中应开始复制的从零开始的索引。<br/> 目标：要复制到的内存指针。<br/> length：要复制的数组元素数。<br/> 异常:<br/> T：System.ArgumentOutOfRangeException： startIndex 和 length 是无效的。<br/> T：System.ArgumentNullException：startIndex、destination 或 length 为 null。</p>\n<h4><a id=\"public_static_void_Copychar_source_int_startIndex_IntPtr_destination_int_length_206\"></a>public static void Copy(char[] source, int startIndex, IntPtr destination, int length);</h4>\n<p> <br/> 摘要：将数据从一维、受管的 8 位无符号整数数组复制到非托管内存指针。<br/> 参数:<br/> 源：要从中复制的一维数组。<br/> startIndex：源数组中应开始复制的从零开始的索引。<br/> 目标：要复制到的内存指针。<br/> length：要复制的数组元素数。<br/> 异常:<br/> T：System.ArgumentOutOfRangeException： startIndex 和 length 是无效的。<br/> T：System.ArgumentNullException：source、startIndex、destination 或 length 为 null。</p>\n<h4><a id=\"public_static_void_Copybyte_source_int_startIndex_IntPtr_destination_int_length_217\"></a>public static void Copy(byte[] source, int startIndex, IntPtr destination, int length);</h4>\n<p> <br/> 摘要：将数据从非托管内存指针复制到托管字符数组。<br/> 参数:<br/> 源：要从中复制的内存指针。<br/> 目标：要复制到的数组。<br/> startIndex：应开始复制的目标数组中从零开始的索引。<br/> length：要复制的数组元素数。<br/> 异常:<br/> T：System.ArgumentNullException：source、destination、startIndex 或 length 为 null。</p>\n<h4><a id=\"public_static_void_CopyIntPtr_source_char_destination_int_startIndex_int_length_227\"></a>public static void Copy(IntPtr source, char[] destination, int startIndex, int length);</h4>\n<p> <br/> 摘要：聚合具有指定 COM 对象的托管对象。<br/> 参数:<br/> pOuter：外部 I 未知指针。<br/> o：要聚合的对象。<br/> 返回结果：托管对象的内部 IUnknown 指针。<br/> 异常:<br/> T：System.ArgumentException： o 是一个 Windows 运行时对象。<br/> [EditorBrowsable(EditorBrowsableState.Never)]</p>\n<h4><a id=\"public_static_IntPtr_CreateAggregatedObjectIntPtr_pOuter_object_o_237\"></a>public static IntPtr CreateAggregatedObject(IntPtr pOuter, object o);</h4>\n<p> <br/> 摘要： [在 .NET Framework 4.5.1 及更高版本中受支持] 将指定类型的托管对象与指定的 COM 对象聚合。<br/> 参数:<br/> pOuter：外部 I 未知指针。<br/> o：要聚合的托管对象。<br/> 类型参数:<br/> T：要聚合的托管对象的类型。<br/> 返回结果：托管对象的内部 IUnknown 指针。<br/> 异常:<br/> T：System.ArgumentException： o 是一个 Windows 运行时对象。</p>\n<h4><a id=\"public_static_IntPtr_CreateAggregatedObjectTIntPtr_pOuter_T_o_where_T__notnull_248\"></a>public static IntPtr CreateAggregatedObject(IntPtr pOuter, T o) where T : notnull;</h4>\n<p> <br/> 摘要： [在 .NET Framework 4.5.1 及更高版本中受支持] 将指定的 COM 对象包装在指定类型的对象中。<br/> 参数:<br/> o：要包装的对象。<br/> 类型参数:<br/> T：要包装的对象的类型。<br/> TWrapper：要返回的对象的类型。<br/> 返回结果： 新包装的对象。<br/> 异常:<br/> T：System.ArgumentException：T 必须从__ComObject派生而来。-or- T 是 Windows 运行时类型。<br/> T：System.InvalidCastException： o 无法转换为 TWrapper，因为它不支持所有必需的接口。</p>\n<h4><a id=\"public_static_TWrapper_CreateWrapperOfTypeT_TWrapperAllowNull_T_o_260\"></a>public static TWrapper CreateWrapperOfType&lt;T, TWrapper&gt;([AllowNull] T o);</h4>\n<p> <br/> 摘要：将指定的 COM 对象包装在指定类型的对象中。<br/> 参数:<br/> o：要包装的对象。<br/> t：要创建的包装器的类型。<br/> 返回结果：作为所需类型的实例的新包装对象。<br/> 异常:<br/> T：System.ArgumentException： t 必须从__ComObject派生而来。-or- t 是 Windows 运行时类型。<br/> T：System.ArgumentNullException：t 参数为 null。<br/> T：System.InvalidCastException： o 无法转换为目标类型，因为它不支持所有必需的接口。<br/> [EditorBrowsable(EditorBrowsableState.Never)]<br/> [return: NotNullIfNotNull(“o”)]</p>\n<h4><a id=\"public_static_object_CreateWrapperOfTypeobject_o_Type_t_273\"></a>public static object? CreateWrapperOfType(object? o, Type t);</h4>\n<p> <br/> 摘要：释放指定的非托管内存块指向的所有子结构。<br/> 参数:<br/> ptr：指向非托管内存块的指针。<br/> 结构类型：格式化类的类型。这提供了删除 ptr 参数中的缓冲区所需的布局信息。<br/> 异常:<br/> T：System.ArgumentException： structureType 具有自动布局。请改用顺序或显式。<br/> [EditorBrowsable(EditorBrowsableState.Never)]</p>\n<h4><a id=\"public_static_void_DestroyStructureIntPtr_ptr_Type_structuretype_282\"></a>public static void DestroyStructure(IntPtr ptr, Type structuretype);</h4>\n<p> <br/> 摘要：[在 .NET Framework 4.5.1 及更高版本中受支持] 释放指定非托管内存块所指向的指定类型的所有子结构。<br/> 参数:<br/> ptr：指向非托管内存块的指针。<br/> 类型参数:<br/> T：格式化结构的类型。这提供了删除 ptr 参数中的缓冲区所需的布局信息。<br/> 异常:<br/> T：System.ArgumentException：T 有一个自动布局。请改用顺序或显式。</p>\n<h4><a id=\"public_static_void_DestroyStructureTIntPtr_ptr_291\"></a>public static void DestroyStructure(IntPtr ptr);</h4>\n<p> <br/> 摘要：通过将运行时可调用包装 （RCW） 的引用计数设置为 0 来释放对该包装器 （RCW） 的所有引用。<br/> 参数:<br/> o：要发布的 RCW。<br/> 返回结果：与 o 参数关联的 RCW 的引用计数的新值，如果发布成功，则为 0（零）。<br/> 异常:<br/> T：System.ArgumentException： o 不是有效的 COM 对象。<br/> T：System.ArgumentNullException： o is null.</p>\n<h4><a id=\"public_static_int_FinalReleaseComObjectobject_o_300\"></a>public static int FinalReleaseComObject(object o);</h4>\n<p> <br/> 摘要：使用 COM SysFreeString 函数释放 BSTR。<br/> 参数:<br/> ptr：要释放的 BSTR 的地址。</p>\n<h4><a id=\"public_static_void_FreeBSTRIntPtr_ptr_305\"></a>public static void FreeBSTR(IntPtr ptr);</h4>\n<p> <br/> 摘要：释放由非托管 COM 任务内存分配器分配的内存块。<br/> 参数:<br/> ptr：要释放的内存的地址。</p>\n<h4><a id=\"public_static_void_FreeCoTaskMemIntPtr_ptr_310\"></a>public static void FreeCoTaskMem(IntPtr ptr);</h4>\n<p> <br/> 摘要：释放先前从进程的非托管内存中分配的内存。<br/> 参数:<br/> hglobal：由对 System.Runtime.InteropServices.Marshal.AllocHGlobal（System.IntPtr） 的原始匹配调用返回的句柄。</p>\n<h4><a id=\"public_static_void_FreeHGlobalIntPtr_hglobal_315\"></a>public static void FreeHGlobal(IntPtr hglobal);</h4>\n<p> <br/> 摘要：返回指定类型的全局唯一标识符 （GUID），或使用类型库导出程序 （Tlbexp.exe） 使用的算法生成 GUID。<br/> 参数:<br/> 类型：要为其生成 GUID 的类型。<br/> 返回结果： 指定类型的标识符。</p>\n<h4><a id=\"public_static_Guid_GenerateGuidForTypeType_type_321\"></a>public static Guid GenerateGuidForType(Type type);</h4>\n<p> <br/> 摘要：返回指定类型的编程标识符 （ProgID）。<br/> 参数:<br/> type：要获取其 ProgID 的类型。<br/> 返回结果： 指定类型的 ProgID。<br/> 异常:<br/> T：System.ArgumentException：type 参数不是 COM 可以创建的类。该类必须是公共的，具有公共无参数构造函数，并且是 COM 可见的。<br/> T：System.ArgumentNullException：type 参数为 null。</p>\n<h4><a id=\"public_static_string_GenerateProgIdForTypeType_type_330\"></a>public static string? GenerateProgIdForType(Type type);</h4>\n<p> <br/> 摘要：[在 .NET Framework 4.5.1 及更高版本中受支持] 返回一个指针，该指针指向一个 IUnknown 接口，该接口表示指定类型的对象上的指定接口。默认情况下，自定义查询接口访问处于启用状态。<br/> 参数:<br/> o：提供接口的对象。<br/> 类型参数:<br/> T：o的类型。<br/> 接口：要返回的接口类型。<br/> 返回结果：表示接口接口的接口指针。<br/> 异常:<br/> T：System.ArgumentException：TInterface 参数不是接口。-or- 该类型对 COM 不可见。 -or- T 参数是一个开放的泛型类型。<br/> T：System.InvalidCastException：o 参数不支持 TInterface 接口。<br/> T：System.ArgumentNullException：o 参数为 null。</p>\n<h4><a id=\"public_static_IntPtr_GetComInterfaceForObjectT_TInterfaceDisallowNull_T_o_343\"></a>public static IntPtr GetComInterfaceForObject&lt;T, TInterface&gt;([DisallowNull] T o);</h4>\n<p> <br/> 摘要：返回指向 I 未知接口的指针，该接口表示指定对象上的指定接口。默认情况下，自定义查询接口访问处于启用状态。<br/> 参数:<br/> o：提供接口的对象。<br/> T：请求的接口类型。<br/> 返回结果：表示对象的指定接口的接口指针。<br/> 异常:<br/> T：System.ArgumentException：T 参数不是接口。-or- 该类型对 COM 不可见。 -or- T 参数是泛型类型定义。<br/> T：System.InvalidCastException：o 参数不支持请求的接口。<br/> T：System.ArgumentNullException：o 参数为 null。- 或 - T 参数为空。<br/> [EditorBrowsable(EditorBrowsableState.Never)]</p>\n<h4><a id=\"public_static_IntPtr_GetComInterfaceForObjectobject_o_Type_T_355\"></a>public static IntPtr GetComInterfaceForObject(object o, Type T);</h4>\n<p> <br/> 摘要：返回指向 I 未知接口的指针，该接口表示指定对象上的指定接口。自定义查询接口访问由指定的自定义模式控制。<br/> 参数:<br/> o：提供接口的对象。<br/> T：请求的接口类型。<br/> mode：指示是否应用由 System.Runtime.InteropServices.ICustomQueryInterface 提供的 IUnknown：：QueryInterface 自定义项的枚举值之一。<br/> 返回结果：表示对象的接口的接口指针。<br/> 异常:<br/> T：System.ArgumentException：T 参数不是接口。-or- 该类型对 COM 不可见。 -or- T 参数是泛型类型定义。<br/> T：System.InvalidCastException：对象 o 不支持请求的接口。<br/> T：System.ArgumentNullException：o 参数为 null。- 或 - T 参数为空。<br/> [EditorBrowsable(EditorBrowsableState.Never)]</p>\n<h4><a id=\"public_static_IntPtr_GetComInterfaceForObjectobject_o_Type_T_CustomQueryInterfaceMode_mode_368\"></a>public static IntPtr GetComInterfaceForObject(object o, Type T, CustomQueryInterfaceMode mode);</h4>\n<p> <br/> 摘要：从指定的COM对象中检索指定键引用的数据。<br/> 参数:<br/> obj：包含所需数据的 COM 对象。<br/> key：obj 内部哈希表中用于检索数据的键。<br/> 返回结果：由 obj 参数的内部哈希表中的键参数表示的数据。<br/> 异常:<br/> T：System.ArgumentNullException： obj is null.-or- 键为空。<br/> T：System.ArgumentException： obj 不是 COM 对象。-or- obj 是一个 Windows 运行时对象。</p>\n<h4><a id=\"public_static_object_GetComObjectDataobject_obj_object_key_378\"></a>public static object? GetComObjectData(object obj, object key);</h4>\n<p> <br/> 摘要：将非托管函数指针转换为委托。<br/> 参数:<br/> ptr：要转换的非托管函数指针。<br/> t：要返回的委托的类型。<br/> 返回结果：可以强制转换为相应委托类型的委托实例。<br/> 异常:<br/> T：System.ArgumentException：t 参数不是委托或泛型参数。<br/> T：System.ArgumentNullException：ptr 参数为 null。-or- t 参数为空。<br/> [EditorBrowsable(EditorBrowsableState.Never)]</p>\n<h4><a id=\"public_static_Delegate_GetDelegateForFunctionPointerIntPtr_ptr_Type_t_389\"></a>public static Delegate GetDelegateForFunctionPointer(IntPtr ptr, Type t);</h4>\n<p> <br/> 摘要： [在 .NET Framework 4.5.1 及更高版本中受支持] 将非托管函数指针转换为指定类型的委托。<br/> 参数:<br/> ptr：要转换的非托管函数指针。<br/> 类型参数:<br/> TDelegate：要返回的委托的类型。<br/> 返回结果：指定委托类型的实例。<br/> 异常:<br/> T：System.ArgumentException：TDelegate 泛型参数不是委托，或者它是一个开放的泛型类型。<br/> T：System.ArgumentNullException：ptr 参数为 null。</p>\n<h4><a id=\"public_static_TDelegate_GetDelegateForFunctionPointerTDelegateIntPtr_ptr_400\"></a>public static TDelegate GetDelegateForFunctionPointer(IntPtr ptr);</h4>\n<p> <br/> 摘要：检索向 COM 公开时某种类型的虚拟功能表（v 表或 VTBL）中的最后一个插槽。<br/> 参数:<br/> t：表示接口或类的类型。<br/> 返回结果：接口向 COM 公开时的最后一个 VTBL 插槽。如果 t 参数是一个类，则返回的 VTBL 插槽是从该类生成的接口中的最后一个插槽。</p>\n<h4><a id=\"public_static_int_GetEndComSlotType_t_406\"></a>public static int GetEndComSlot(Type t);</h4>\n<p> <br/> 摘要：检索标识所发生异常类型的代码。<br/> 返回结果： 异常的类型。<br/> [EditorBrowsable(EditorBrowsableState.Never)]<br/> [Obsolete(“GetExceptionCode() may be unavailable in future releases.”)]</p>\n<h4><a id=\"public_static_int_GetExceptionCode_412\"></a>public static int GetExceptionCode();</h4>\n<p> <br/> 摘要：将指定的 HRESULT 错误代码转换为相应的 System.Exception 对象。<br/> 参数:<br/> 错误代码：要转换的 HRESULT。<br/> 返回结果：表示转换后的 HRESULT 的对象，如果 HRESULT 值不表示错误代码（例如，S_OK或S_FALSE），则为 null。</p>\n<h4><a id=\"public_static_Exception_GetExceptionForHRint_errorCode_418\"></a>public static Exception? GetExceptionForHR(int errorCode);</h4>\n<p> <br/> 摘要：将指定的 HRESULT 错误代码转换为相应的 System.Exception 对象，并在异常对象的 IErrorInfo 接口中传递其他错误信息。<br/> 参数:<br/> 错误代码：要转换的 HRESULT。<br/> errorInfo：指向 IErrorInfo 接口的指针，提供有关错误的详细信息。您可以指定 IntPtr（0） 以使用当前的 IErrorInfo 接口，或指定 IntPtr（-1） 以忽略当前的 IErrorInfo 接口并仅从错误代码构造异常。<br/> 返回结果：表示转换后的 HRESULT 和从 errorInfo 获取的信息的对象，如果 HRESULT 值不表示错误代码（例如，S_OK或S_FALSE），则为 null。</p>\n<h4><a id=\"public_static_Exception_GetExceptionForHRint_errorCode_IntPtr_errorInfo_425\"></a>public static Exception? GetExceptionForHR(int errorCode, IntPtr errorInfo);</h4>\n<p> <br/> 摘要：检索异常的独立于计算机的描述，以及有关发生异常时线程存在的状态的信息。<br/> 返回结果：指向EXCEPTION_POINTERS结构的指针。</p>\n<h4><a id=\"public_static_IntPtr_GetExceptionPointers_429\"></a>public static IntPtr GetExceptionPointers();</h4>\n<p> <br/> 摘要：将委托转换为可从非托管代码调用的函数指针。<br/> 参数:<br/> d：要传递给非托管代码的委托。<br/> 返回结果：可以传递给非托管代码的值，而非托管代码又可以使用它来调用基础托管委托。<br/> 异常:<br/> T：System.ArgumentException：d 参数是泛型类型定义。<br/> T：System.ArgumentNullException：d 参数为 null。<br/> [EditorBrowsable(EditorBrowsableState.Never)]</p>\n<h4><a id=\"public_static_IntPtr_GetFunctionPointerForDelegateDelegate_d_439\"></a>public static IntPtr GetFunctionPointerForDelegate(Delegate d);</h4>\n<p> <br/> 摘要：[在 .NET Framework 4.5.1 及更高版本中受支持] 将指定类型的委托转换为可从非托管代码调用的函数指针。<br/> 参数:<br/> d：要传递给非托管代码的委托。<br/> 类型参数:<br/> TDelegate：要转换的委托的类型。<br/> 返回结果：可以传递给非托管代码的值，而非托管代码又可以使用它来调用基础托管委托。<br/> 异常:<br/> T：System.ArgumentException：d 参数是泛型类型定义。<br/> T：System.ArgumentNullException：d 参数为 null。</p>\n<h4><a id=\"public_static_IntPtr_GetFunctionPointerForDelegateTDelegateTDelegate_d_where_TDelegate__notnull_450\"></a>public static IntPtr GetFunctionPointerForDelegate(TDelegate d) where TDelegate : notnull;</h4>\n<p> <br/> 摘要：返回指定模块的实例句柄（HINSTANCE）。<br/> 参数:<br/> m：需要其阻碍力的模块。<br/> 返回结果：如果模块没有障碍，则为 -1。<br/> 异常:<br/> T：System.ArgumentNullException：m 参数为 null。</p>\n<h4><a id=\"public_static_IntPtr_GetHINSTANCEModule_m_458\"></a>public static IntPtr GetHINSTANCE(Module m);</h4>\n<p> <br/> 摘要：将指定的异常转换为 HRESULT。<br/> 参数:<br/> e：转换为 HRESULT 的异常。<br/> 返回结果： HRESULT 映射到提供的异常。</p>\n<h4><a id=\"public_static_int_GetHRForExceptionException_e_464\"></a>public static int GetHRForException(Exception? e);</h4>\n<p> <br/> 摘要：返回与使用 System.Runtime.InteropServices.Marshal 执行的 Win32 代码所发生的最后一个错误相对应的 HRESULT。<br/> 返回结果：对应于最后一个 Win32 错误代码的 HRESULT。</p>\n<h4><a id=\"public_static_int_GetHRForLastWin32Error_468\"></a>public static int GetHRForLastWin32Error();</h4>\n<p> <br/> 摘要：从托管对象返回 IDispatch 接口。<br/> 参数:<br/> o：请求其 IDispatch 接口的对象。<br/> 返回结果： o 参数的 IDispatch 指针。<br/> 异常:<br/> T：System.InvalidCastException： o 不支持请求的接口。</p>\n<h4><a id=\"public_static_IntPtr_GetIDispatchForObjectobject_o_476\"></a>public static IntPtr GetIDispatchForObject(object o);</h4>\n<p> <br/> 摘要：从托管对象返回未知接口。<br/> 参数:<br/> o：请求其未知接口的对象。<br/> 返回结果： o 参数的 IUnknown 指针。</p>\n<h4><a id=\"public_static_IntPtr_GetIUnknownForObjectobject_o_482\"></a>public static IntPtr GetIUnknownForObject(object o);</h4>\n<p> <br/> 摘要：返回最后一个非托管函数返回的错误代码，该函数是使用设置了 System.Runtime.InteropServices.DllImportAttribute.SetLastError 标志的平台调用的。<br/> 返回结果：通过调用 Win32 SetLastError 函数设置的最后一个错误代码。</p>\n<h4><a id=\"public_static_int_GetLastWin32Error_486\"></a>public static int GetLastWin32Error();</h4>\n<p> <br/> 摘要： [在 .NET Framework 4.5.1 及更高版本中受支持] 将指定类型的对象转换为 COM VARIANT。<br/> 参数:<br/> obj：要为其获取 COM 变体的对象。<br/> pDstNativeVariant：用于接收与 obj 参数对应的 VARIANT 的指针。<br/> 类型参数:<br/> T：要转换的对象的类型。<br/> [EditorBrowsable(EditorBrowsableState.Never)]</p>\n<h4><a id=\"public_static_void_GetNativeVariantForObjectTAllowNull_T_obj_IntPtr_pDstNativeVariant_495\"></a>public static void GetNativeVariantForObject([AllowNull] T obj, IntPtr pDstNativeVariant);</h4>\n<p> <br/> 摘要：将对象转换为 COM 变体。<br/> 参数:<br/> obj：要为其获取 COM 变体的对象。<br/> pDstNativeVariant：用于接收与 obj 参数对应的 VARIANT 的指针。<br/> 异常:<br/> T：System.ArgumentException：obj 参数是泛型类型的一个实例。<br/> [EditorBrowsable(EditorBrowsableState.Never)]</p>\n<h4><a id=\"public_static_void_GetNativeVariantForObjectobject_obj_IntPtr_pDstNativeVariant_504\"></a>public static void GetNativeVariantForObject(object? obj, IntPtr pDstNativeVariant);</h4>\n<p> <br/> 摘要：返回一个类型的实例，该实例通过指向 COM 对象的指针来表示其 I 未知接口。<br/> 参数:<br/> pUnk：指向 IUnknown 接口的指针。<br/> 返回结果：表示指定的非托管 COM 对象的对象。</p>\n<h4><a id=\"public_static_object_GetObjectForIUnknownIntPtr_pUnk_510\"></a>public static object GetObjectForIUnknown(IntPtr pUnk);</h4>\n<p> <br/> 摘要：将 COM 变体转换为对象。<br/> 参数:<br/> pSrcNativeVariant：指向 COM 变体的指针。<br/> 返回结果：与 pSrcNativeVariant 参数对应的对象。<br/> 异常:<br/> T：System.Runtime.InteropServices.InvalidOleVariantTypeException： pSrcNativeVariant 不是有效的 VARIANT 类型。<br/> T：System.NotSupportedException： pSrcNativeVariant 具有不受支持的类型。<br/> [EditorBrowsable(EditorBrowsableState.Never)]</p>\n<h4><a id=\"public_static_object_GetObjectForNativeVariantIntPtr_pSrcNativeVariant_520\"></a>public static object? GetObjectForNativeVariant(IntPtr pSrcNativeVariant);</h4>\n<p> <br/> 摘要： [在 .NET Framework 4.5.1 及更高版本中受支持] 将 COM VARIANT 转换为指定类型的对象。<br/> 参数:<br/> pSrcNativeVariant：指向 COM 变体的指针。<br/> 类型参数:<br/> T：要将 COM 变体转换为的类型。<br/> 返回结果：与 pSrcNativeVariant 参数对应的指定类型的对象。<br/> 异常:<br/> T：System.Runtime.InteropServices.InvalidOleVariantTypeException： pSrcNativeVariant 不是有效的 VARIANT 类型。<br/> T：System.NotSupportedException： pSrcNativeVariant 具有不受支持的类型。<br/> [EditorBrowsable(EditorBrowsableState.Never)]<br/> [return: MaybeNull]</p>\n<h4><a id=\"public_static_T_GetObjectForNativeVariantTIntPtr_pSrcNativeVariant_533\"></a>public static T GetObjectForNativeVariant(IntPtr pSrcNativeVariant);</h4>\n<p> <br/> 摘要：将 COM VARIANTs 数组转换为对象数组。<br/> 参数:<br/> aSrcNativeVariant：指向 COM VARIANTs 数组的第一个元素的指针。<br/> cVars：aSrcNativeVariant 中 COM VARIANTs 的计数。<br/> 返回结果：对应于 aSrcNativeVariant 的对象数组。<br/> 异常:<br/> T：System.ArgumentOutOfRangeException： cVars 是一个负数。<br/> [EditorBrowsable(EditorBrowsableState.Never)]</p>\n<h4><a id=\"public_static_object_GetObjectsForNativeVariantsIntPtr_aSrcNativeVariant_int_cVars_543\"></a>public static object?[] GetObjectsForNativeVariants(IntPtr aSrcNativeVariant, int cVars);</h4>\n<p> <br/> 摘要： [在 .NET Framework 4.5.1 及更高版本中受支持] 将 COM VARIANT 数组转换为指定类型的数组。<br/> 参数:<br/> aSrcNativeVariant：指向 COM VARIANTs 数组的第一个元素的指针。<br/> cVars：aSrcNativeVariant 中 COM VARIANTs 的计数。<br/> 类型参数:<br/> T：要返回的数组的类型。<br/> 返回结果：对应于 aSrcNativeVariant 的 T 对象数组。<br/> 异常:<br/> T：System.ArgumentOutOfRangeException： cVars 是一个负数。<br/> [EditorBrowsable(EditorBrowsableState.Never)]</p>\n<h4><a id=\"public_static_T_GetObjectsForNativeVariantsTIntPtr_aSrcNativeVariant_int_cVars_555\"></a>public static T[] GetObjectsForNativeVariants(IntPtr aSrcNativeVariant, int cVars);</h4>\n<p> <br/> 摘要：获取包含用户定义方法的虚拟函数表（v-table 或 VTBL）中的第一个插槽。<br/> 参数:<br/> t：表示接口或类的类型。<br/> 返回结果：包含用户定义方法的第一个 VTBL 槽。如果接口基于 IUnknown，则第一个插槽为 3;如果接口基于 IDispatch，则第一个插槽为 7。<br/> 异常:<br/> T：System.ArgumentException： t 在 COM 中不可见。</p>\n<h4><a id=\"public_static_int_GetStartComSlotType_t_563\"></a>public static int GetStartComSlot(Type t);</h4>\n<p> <br/> 摘要：返回指定类型的托管对象，表示 COM 对象。<br/> 参数:<br/> pUnk：指向非托管对象的 I 未知接口的指针。<br/> t：所请求的托管类的类型。<br/> 返回结果：与 System.Type 对象对应的类的实例，该对象表示请求的非托管 COM 对象。<br/> 异常:<br/> T：System.ArgumentException： t 不归因于 System.Runtime.InteropServices.ComImportAttribute。-or- t 是 Windows 运行时类型。</p>\n<h4><a id=\"public_static_object_GetTypedObjectForIUnknownIntPtr_pUnk_Type_t_572\"></a>public static object GetTypedObjectForIUnknown(IntPtr pUnk, Type t);</h4>\n<p> <br/> 摘要：返回与指定类标识符 （CLSID） 关联的类型。<br/> 参数:<br/> clsid：要返回的类型的 CLSID。<br/> 返回结果： System.__ComObject无论 CLSID 是否有效。</p>\n<h4><a id=\"public_static_Type_GetTypeFromCLSIDGuid_clsid_578\"></a>public static Type GetTypeFromCLSID(Guid clsid);</h4>\n<p> <br/> 摘要：检索由 ITypeInfo 对象表示的类型的名称。<br/> 参数:<br/> typeInfo：一个表示 ITypeInfo 指针的对象。<br/> 返回结果：typeInfo 参数指向的类型的名称。<br/> 异常:<br/> T：System.ArgumentNullException：typeInfo 参数为 null。</p>\n<h4><a id=\"public_static_string_GetTypeInfoNameITypeInfo_typeInfo_586\"></a>public static string GetTypeInfoName(ITypeInfo typeInfo);</h4>\n<p> <br/> 摘要：为给定的 I 未知接口创建唯一的运行时可调用包装 （RCW） 对象。<br/> 参数:<br/> 未知：指向未知接口的托管指针。<br/> 返回结果：指定 I 未知接口的唯一 RCW。</p>\n<h4><a id=\"public_static_object_GetUniqueObjectForIUnknownIntPtr_unknown_592\"></a>public static object GetUniqueObjectForIUnknown(IntPtr unknown);</h4>\n<p> <br/> 摘要：表示指定的对象是否表示 COM 对象。<br/> 参数:<br/> o：要检查的对象。<br/> 返回结果： 如果 o 参数是 COM 类型，则为 true;否则，为假。<br/> 异常:<br/> T：System.ArgumentNullException： o is null.</p>\n<h4><a id=\"public_static_bool_IsComObjectobject_o_600\"></a>public static bool IsComObject(object o);</h4>\n<p> <br/> 摘要：指示类型对 COM 客户端是否可见。<br/> 参数:<br/> t：要检查 COM 可见性的类型。<br/> 返回结果： 如果类型对 COM 可见，则为 true;否则，为假。</p>\n<h4><a id=\"public_static_bool_IsTypeVisibleFromComType_t_606\"></a>public static bool IsTypeVisibleFromCom(Type t);</h4>\n<p> <br/> 摘要：返回托管类的非托管形式的字段偏移量。<br/> 参数:<br/> t：指定托管类的值类型或格式化引用类型。必须将 System.Runtime.InteropServices.StructLayoutAttribute 应用于该类。<br/> 字段名称：t 参数中的字段。<br/> 返回结果：由平台调用声明的指定类中的 fieldName 参数的偏移量（以字节为单位）。<br/> 异常:<br/> T：System.ArgumentException：类不能导出为结构，或者字段是非公共的。从 .NET Framework 2.0 版开始，该字段可能是私有的。<br/> T：System.ArgumentNullException：t 参数为 null。<br/> [EditorBrowsable(EditorBrowsableState.Never)]</p>\n<h4><a id=\"public_static_IntPtr_OffsetOfType_t_string_fieldName_617\"></a>public static IntPtr OffsetOf(Type t, string fieldName);</h4>\n<p> <br/> 摘要： [在 .NET Framework 4.5.1 及更高版本中受支持] 返回指定托管类的非托管形式的字段偏移量。<br/> 参数:<br/> 字段名称：T 类型中字段的名称。<br/> 类型参数:<br/> T：托管值类型或格式化引用类型。必须将 System.Runtime.InteropServices.StructLayoutAttribute 特性应用于该类。<br/> 返回结果：由平台调用声明的指定类中的 fieldName 参数的偏移量（以字节为单位）。</p>\n<h4><a id=\"public_static_IntPtr_OffsetOfTstring_fieldName_625\"></a>public static IntPtr OffsetOf(string fieldName);</h4>\n<p> <br/> 摘要：执行一次性方法设置任务，无需调用方法。<br/> 参数:<br/> m：要检查的方法。<br/> 异常:<br/> T：System.ArgumentNullException：m 参数为 null。<br/> T：System.ArgumentException：m 参数不是 System.Reflection.MethodInfo 对象。</p>\n<h4><a id=\"public_static_void_PrelinkMethodInfo_m_633\"></a>public static void Prelink(MethodInfo m);</h4>\n<p> <br/> 摘要：对类上的所有方法执行预链接检查。<br/> 参数:<br/> c：要检查其方法的类。<br/> 异常:<br/> T：System.ArgumentNullException：c 参数为 null。</p>\n<h4><a id=\"public_static_void_PrelinkAllType_c_640\"></a>public static void PrelinkAll(Type c);</h4>\n<p> <br/> 摘要：分配一个受管系统。字符串，将指定数量的字符从非托管 ANSI 字符串复制到其中，并将每个 ANSI 字符加宽为 Unicode。<br/> 参数:<br/> ptr：非托管字符串的第一个字符的地址。<br/> len：要复制的输入字符串的字节计数。<br/> 返回结果：一个托管字符串，如果 ptr 参数的值不为 null，则保存本机 ANSI 字符串的副本;否则，此方法返回 null。<br/> 异常:<br/> T：System.ArgumentException： len 小于零。</p>\n<h4><a id=\"public_static_string_PtrToStringAnsiIntPtr_ptr_int_len_649\"></a>public static string PtrToStringAnsi(IntPtr ptr, int len);</h4>\n<p> <br/> 摘要：将所有字符（直到第一个空字符）从非托管 ANSI 字符串复制到托管系统。字符串，并将每个 ANSI 字符加宽为 Unicode。<br/> 参数:<br/> ptr：非托管字符串的第一个字符的地址。<br/> 返回结果：一个托管字符串，用于保存非托管 ANSI 字符串的副本。如果 ptr 为空，则该方法返回空字符串。</p>\n<h4><a id=\"public_static_string_PtrToStringAnsiIntPtr_ptr_655\"></a>public static string? PtrToStringAnsi(IntPtr ptr);</h4>\n<p> <br/> 摘要：分配一个被管理的系统。String，并将存储在非托管内存中的字符串中指定数量的字符复制到其中。<br/> 参数:<br/> ptr：对于 Unicode 平台，第一个 Unicode 字符的地址。-or-对于 ANSI 平台，第一个 ANSI 字符的地址。<br/> len：要复制的字符数。<br/> 返回结果：一个托管字符串，如果 ptr 参数的值不为 null，则保存本机字符串的副本;否则，此方法返回 null。<br/> 异常:<br/> T：System.ArgumentException： len 小于零。</p>\n<h4><a id=\"public_static_string_PtrToStringAutoIntPtr_ptr_int_len_664\"></a>public static string? PtrToStringAuto(IntPtr ptr, int len);</h4>\n<p> <br/> 摘要：分配一个被管系统。String，并将存储在非被管内存中的字符串中所有字符（直到第一个空字符）复制到其中。<br/> 参数:<br/> ptr：对于 Unicode 平台，第一个 Unicode 字符的地址。-or-对于 ANSI 平台，第一个 ANSI 字符的地址。<br/> 返回结果：一个托管字符串，如果 ptr 参数的值不为 null，则保存非托管字符串的副本;否则，此方法返回 null。</p>\n<h4><a id=\"public_static_string_PtrToStringAutoIntPtr_ptr_670\"></a>public static string? PtrToStringAuto(IntPtr ptr);</h4>\n<p> <br/> 摘要：分配一个被管系统。字符串并将存储在非托管内存中的二进制字符串（BSTR）复制到其中。<br/> 参数:<br/> ptr：非托管字符串的第一个字符的地址。<br/> 返回结果：保存非托管字符串副本的托管字符串。<br/> 异常:<br/> T：System.ArgumentNullException： ptr equals System.IntPtr.Zero.</p>\n<h4><a id=\"public_static_string_PtrToStringBSTRIntPtr_ptr_678\"></a>public static string PtrToStringBSTR(IntPtr ptr);</h4>\n<p> <br/> 摘要：分配一个受管 System.String，并将非托管 Unicode 字符串中所有字符（直到第一个空字符）复制到其中。<br/> 参数:<br/> ptr：非托管字符串的第一个字符的地址。<br/> 返回结果：一个托管字符串，如果 ptr 参数的值不为 null，则保存非托管字符串的副本;否则，此方法返回 null。</p>\n<h4><a id=\"public_static_string_PtrToStringUniIntPtr_ptr_684\"></a>public static string? PtrToStringUni(IntPtr ptr);</h4>\n<p> <br/> 摘要：分配一个受管系统。字符串，并将非托管 Unicode 字符串中指定数量的字符复制到其中。<br/> 参数:<br/> ptr：非托管字符串的第一个字符的地址。<br/> len：要复制的 Unicode 字符数。<br/> 返回结果：一个托管字符串，如果 ptr 参数的值不为 null，则保存非托管字符串的副本;否则，此方法返回 null。</p>\n<h4><a id=\"public_static_string_PtrToStringUniIntPtr_ptr_int_len_691\"></a>public static string PtrToStringUni(IntPtr ptr, int len);</h4>\n<p>参数:<br/> ptr：</p>\n<h4><a id=\"public_static_string_PtrToStringUTF8IntPtr_ptr_694\"></a>public static string? PtrToStringUTF8(IntPtr ptr);</h4>\n<p>参数:<br/> ptr：<br/> 字节长度：</p>\n<h4><a id=\"public_static_string_PtrToStringUTF8IntPtr_ptr_int_byteLen_698\"></a>public static string PtrToStringUTF8(IntPtr ptr, int byteLen);</h4>\n<p> <br/> 摘要： [在 .NET Framework 4.5.1 及更高版本中受支持] 将数据从非托管内存块封送到由泛型类型参数指定的类型的新分配的托管对象。<br/> 参数:<br/> ptr：指向非托管内存块的指针。<br/> 类型参数:<br/> T：要将数据复制到的对象的类型。这必须是格式化的类或结构。<br/> 返回结果：包含 ptr 参数指向的数据的托管对象。<br/> 异常:<br/> T：System.ArgumentException：T 的布局不是连续的或显式的。<br/> T：System.MissingMethodException：T 指定的类没有可访问的无参数构造函数。<br/> [return: MaybeNull]</p>\n<h4><a id=\"public_static_T_PtrToStructureTIntPtr_ptr_710\"></a>public static T PtrToStructure(IntPtr ptr);</h4>\n<p> <br/> 摘要： [在 .NET Framework 4.5.1 及更高版本中受支持] 将数据从非托管内存块封送到指定类型的托管对象。<br/> 参数:<br/> ptr：指向非托管内存块的指针。<br/> 结构：要将数据复制到的对象。<br/> 类型参数:<br/> T：结构的类型。这必须是格式化的类。<br/> 异常:<br/> T：System.ArgumentException：结构布局不是连续的或显式的。</p>\n<h4><a id=\"public_static_void_PtrToStructureTIntPtr_ptr_DisallowNull_T_structure_720\"></a>public static void PtrToStructure(IntPtr ptr, [DisallowNull] T structure);</h4>\n<p> <br/> 摘要：将数据从非托管内存块封送到托管对象。<br/> 参数:<br/> ptr：指向非托管内存块的指针。<br/> 结构：要将数据复制到的对象。这必须是格式化类的实例。<br/> 异常:<br/> T：System.ArgumentException：结构布局不是连续的或显式的。-or- 结构是盒装值类型。<br/> [EditorBrowsable(EditorBrowsableState.Never)]</p>\n<h4><a id=\"public_static_void_PtrToStructureIntPtr_ptr_object_structure_729\"></a>public static void PtrToStructure(IntPtr ptr, object structure);</h4>\n<p> <br/> 摘要：将数据从非托管内存块封送到指定类型的新分配的托管对象。<br/> 参数:<br/> ptr：指向非托管内存块的指针。<br/> 结构类型：要创建的对象的类型。此对象必须表示格式化的类或结构。<br/> 返回结果：包含 ptr 参数所指向的数据的托管对象。<br/> 异常:<br/> T：System.ArgumentException：structureType 参数布局不是顺序的或显式的。-or- 结构类型参数是泛型类型定义。<br/> T：System.ArgumentNullException： structureType is null。<br/> T：System.MissingMethodException：structureType 指定的类没有可访问的无参数构造函数。<br/> [EditorBrowsable(EditorBrowsableState.Never)]</p>\n<h4><a id=\"public_static_object_PtrToStructureIntPtr_ptr_Type_structureType_741\"></a>public static object? PtrToStructure(IntPtr ptr, Type structureType);</h4>\n<p> <br/> 摘要：从 COM 对象请求指向指定接口的指针。<br/> 参数:<br/> pUnk：要查询的接口。<br/> iid：所请求接口的接口标识符 （IID）。<br/> ppv：此方法返回时，包含对返回接口的引用。<br/> 返回结果：指示呼叫成功或失败的 HRESULT。</p>\n<h4><a id=\"public_static_int_QueryInterfaceIntPtr_pUnk_ref_Guid_iid_out_IntPtr_ppv_749\"></a>public static int QueryInterface(IntPtr pUnk, ref Guid iid, out IntPtr ppv);</h4>\n<p> <br/> 摘要： 从非托管内存中读取单个字节。<br/> 参数:<br/> ptr：非托管内存中要从中读取的地址。<br/> 返回结果： 从非托管内存中读取的字节。<br/> 异常:<br/> T：System.AccessViolationException：ptr 不是可识别的格式。-or- ptr 为空。-or- ptr 无效。</p>\n<h4><a id=\"public_static_byte_ReadByteIntPtr_ptr_757\"></a>public static byte ReadByte(IntPtr ptr);</h4>\n<p> <br/> 摘要：从非托管内存中读取给定偏移量（或索引）处的单字节。<br/> 参数:<br/> ptr：非托管内存中要从中读取的基址。<br/> ofs：一个额外的字节偏移量，在读取之前添加到 ptr 参数中。<br/> 返回结果：以给定偏移量从非托管内存读取的字节。<br/> 异常:<br/> T：System.AccessViolationException：基址 （ptr） 加上偏移字节 （ofs） 会生成空地址或无效地址。</p>\n<h4><a id=\"public_static_byte_ReadByteIntPtr_ptr_int_ofs_766\"></a>public static byte ReadByte(IntPtr ptr, int ofs);</h4>\n<p> <br/> 摘要：从非托管内存中读取给定偏移量（或索引）处的单字节。<br/> 参数:<br/> ptr：源对象的非托管内存中的基址。<br/> ofs：一个额外的字节偏移量，在读取之前添加到 ptr 参数中。<br/> 返回结果：以给定偏移量从非托管内存读取的字节。<br/> 异常:<br/> T：System.AccessViolationException：基址 （ptr） 加上偏移字节 （ofs） 会生成空地址或无效地址。<br/> T：System.ArgumentException： ptr 是一个 System.Runtime.InteropServices.ArrayWithOffset 对象。此方法不接受 System.Runtime.InteropServices.ArrayWithOffset 参数。<br/> [EditorBrowsable(EditorBrowsableState.Never)]<br/> [Obsolete(“ReadByte(Object, Int32) may be unavailable in future releases.”)]</p>\n<h4><a id=\"public_static_byte_ReadByteobject_ptr_int_ofs_778\"></a>public static byte ReadByte(object ptr, int ofs);</h4>\n<p> <br/> 摘要：从非托管内存中读取给定偏移量处的 16 位有符号整数。<br/> 参数:<br/> ptr：源对象的非托管内存中的基址。<br/> ofs：一个额外的字节偏移量，在读取之前添加到 ptr 参数中。<br/> 返回结果：以给定偏移量从非托管内存读取的 16 位有符号整数。<br/> 异常:<br/> T：System.AccessViolationException：基址 （ptr） 加上偏移字节 （ofs） 会生成空地址或无效地址。<br/> T：System.ArgumentException： ptr 是一个 System.Runtime.InteropServices.ArrayWithOffset 对象。此方法不接受 System.Runtime.InteropServices.ArrayWithOffset 参数。<br/> [EditorBrowsable(EditorBrowsableState.Never)]<br/> [Obsolete(“ReadInt16(Object, Int32) may be unavailable in future releases.”)]</p>\n<h4><a id=\"public_static_short_ReadInt16object_ptr_int_ofs_790\"></a>public static short ReadInt16(object ptr, int ofs);</h4>\n<p> <br/> 摘要：从非托管内存中读取 16 位有符号整数。<br/> 参数:<br/> ptr：非托管内存中要从中读取的地址。<br/> 返回结果：从非托管内存中读取的 16 位有符号整数。<br/> 异常:<br/> T：System.AccessViolationException：ptr 不是可识别的格式。-or- ptr 为空。-or- ptr 无效。</p>\n<h4><a id=\"public_static_short_ReadInt16IntPtr_ptr_798\"></a>public static short ReadInt16(IntPtr ptr);</h4>\n<p> <br/> 摘要：从非托管内存中读取给定偏移量处的 16 位有符号整数。<br/> 参数:<br/> ptr：非托管内存中要从中读取的基址。<br/> ofs：一个额外的字节偏移量，在读取之前添加到 ptr 参数中。<br/> 返回结果：以给定偏移量从非托管内存读取的 16 位有符号整数。<br/> 异常:<br/> T：System.AccessViolationException：基址 （ptr） 加上偏移字节 （ofs） 会生成空地址或无效地址。</p>\n<h4><a id=\"public_static_short_ReadInt16IntPtr_ptr_int_ofs_807\"></a>public static short ReadInt16(IntPtr ptr, int ofs);</h4>\n<p> <br/> 摘要：从非托管内存中读取给定偏移量的 32 位有符号整数。<br/> 参数:<br/> ptr：源对象的非托管内存中的基址。<br/> ofs：一个额外的字节偏移量，在读取之前添加到 ptr 参数中。<br/> 返回结果：以给定偏移量从非托管内存读取的 32 位有符号整数。<br/> 异常:<br/> T：System.AccessViolationException：基址 （ptr） 加上偏移字节 （ofs） 会生成空地址或无效地址。<br/> T：System.ArgumentException： ptr 是一个 System.Runtime.InteropServices.ArrayWithOffset 对象。此方法不接受 System.Runtime.InteropServices.ArrayWithOffset 参数。<br/> [EditorBrowsable(EditorBrowsableState.Never)]<br/> [Obsolete(“ReadInt32(Object, Int32) may be unavailable in future releases.”)]</p>\n<h4><a id=\"public_static_int_ReadInt32object_ptr_int_ofs_819\"></a>public static int ReadInt32(object ptr, int ofs);</h4>\n<p> <br/> 摘要：从非托管内存中读取给定偏移量的 32 位有符号整数。<br/> 参数:<br/> ptr：非托管内存中要从中读取的基址。<br/> ofs：一个额外的字节偏移量，在读取之前添加到 ptr 参数中。<br/> 返回结果：从非托管内存中读取的 32 位有符号整数。<br/> 异常:<br/> T：System.AccessViolationException：基址 （ptr） 加上偏移字节 （ofs） 会生成空地址或无效地址。</p>\n<h4><a id=\"public_static_int_ReadInt32IntPtr_ptr_int_ofs_828\"></a>public static int ReadInt32(IntPtr ptr, int ofs);</h4>\n<p> <br/> 摘要：从非托管内存中读取 32 位有符号整数。<br/> 参数:<br/> ptr：非托管内存中要从中读取的地址。<br/> 返回结果：从非托管内存中读取的 32 位有符号整数。<br/> 异常:<br/> T：System.AccessViolationException：ptr 不是可识别的格式。-or- ptr 为空。-or- ptr 无效。</p>\n<h4><a id=\"public_static_int_ReadInt32IntPtr_ptr_836\"></a>public static int ReadInt32(IntPtr ptr);</h4>\n<p> <br/> 摘要：从非托管内存中读取 64 位有符号整数。<br/> 参数:<br/> ptr：非托管内存中要从中读取的地址。<br/> 返回结果：从非托管内存中读取的 64 位有符号整数。<br/> 异常:<br/> T：System.AccessViolationException：ptr 不是可识别的格式。-or- ptr 为空。-or- ptr 无效。</p>\n<h4><a id=\"public_static_long_ReadInt64IntPtr_ptr_844\"></a>public static long ReadInt64(IntPtr ptr);</h4>\n<p> <br/> 摘要：从非托管内存中读取给定偏移量的 64 位有符号整数。<br/> 参数:<br/> ptr：非托管内存中要从中读取的基址。<br/> ofs：一个额外的字节偏移量，在读取之前添加到 ptr 参数中。<br/> 返回结果：以给定偏移量从非托管内存读取的 64 位有符号整数。<br/> 异常:<br/> T：System.AccessViolationException：基址 （ptr） 加上偏移字节 （ofs） 会生成空地址或无效地址。</p>\n<h4><a id=\"public_static_long_ReadInt64IntPtr_ptr_int_ofs_853\"></a>public static long ReadInt64(IntPtr ptr, int ofs);</h4>\n<p> <br/> 摘要：从非托管内存中读取给定偏移量的 64 位有符号整数。<br/> 参数:<br/> ptr：源对象的非托管内存中的基址。<br/> ofs：一个额外的字节偏移量，在读取之前添加到 ptr 参数中。<br/> 返回结果：以给定偏移量从非托管内存读取的 64 位有符号整数。<br/> 异常:<br/> T：System.AccessViolationException：基址 （ptr） 加上偏移字节 （ofs） 会生成空地址或无效地址。<br/> T：System.ArgumentException： ptr 是一个 System.Runtime.InteropServices.ArrayWithOffset 对象。此方法不接受 System.Runtime.InteropServices.ArrayWithOffset 参数。<br/> [EditorBrowsable(EditorBrowsableState.Never)]<br/> [Obsolete(“ReadInt64(Object, Int32) may be unavailable in future releases.”)]</p>\n<h4><a id=\"public_static_long_ReadInt64object_ptr_int_ofs_865\"></a>public static long ReadInt64(object ptr, int ofs);</h4>\n<p> <br/> 摘要：从非托管内存中读取处理器本机大小的整数。<br/> 参数:<br/> ptr：非托管内存中要从中读取的地址。<br/> 返回结果：从非托管内存中读取的整数。32 位机器上返回 32 位整数，64 位机器上返回 64 位整数。<br/> 异常:<br/> T：System.AccessViolationException：ptr 不是可识别的格式。-or- ptr 为空。-or- ptr 无效。</p>\n<h4><a id=\"public_static_IntPtr_ReadIntPtrIntPtr_ptr_873\"></a>public static IntPtr ReadIntPtr(IntPtr ptr);</h4>\n<p> <br/> 摘要：从非托管内存中读取处理器在给定偏移处的本机大小整数。<br/> 参数:<br/> ptr：非托管内存中要从中读取的基址。<br/> ofs：一个额外的字节偏移量，在读取之前添加到 ptr 参数中。<br/> 返回结果：以给定偏移量从非托管内存读取的整数。<br/> 异常:<br/> T：System.AccessViolationException：基址 （ptr） 加上偏移字节 （ofs） 会生成空地址或无效地址。</p>\n<h4><a id=\"public_static_IntPtr_ReadIntPtrIntPtr_ptr_int_ofs_882\"></a>public static IntPtr ReadIntPtr(IntPtr ptr, int ofs);</h4>\n<p> <br/> 摘要：从非托管内存中读取处理器的本机大小整数。<br/> 参数:<br/> ptr：源对象的非托管内存中的基址。<br/> ofs：一个额外的字节偏移量，在读取之前添加到 ptr 参数中。<br/> 返回结果：以给定偏移量从非托管内存读取的整数。<br/> 异常:<br/> T：System.AccessViolationException：基址 （ptr） 加上偏移字节 （ofs） 会生成空地址或无效地址。<br/> T：System.ArgumentException： ptr 是一个 System.Runtime.InteropServices.ArrayWithOffset 对象。此方法不接受 System.Runtime.InteropServices.ArrayWithOffset 参数。<br/> [EditorBrowsable(EditorBrowsableState.Never)]<br/> [Obsolete(“ReadIntPtr(Object, Int32) may be unavailable in future releases.”)]</p>\n<h4><a id=\"public_static_IntPtr_ReadIntPtrobject_ptr_int_ofs_894\"></a>public static IntPtr ReadIntPtr(object ptr, int ofs);</h4>\n<p> <br/> 摘要：调整以前使用 System.Runtime.InteropServices.Marshal.AllocCoTaskMem（System.Int32） 分配的内存块的大小。<br/> 参数:<br/> pv：指向使用 System.Runtime.InteropServices.Marshal.AllocCoTaskMem（System.Int32） 分配的内存的指针。<br/> cb：已分配块的新大小。<br/> 返回结果：一个整数，表示重新分配的内存块的地址。此内存必须与 System.Runtime.InteropServices.Marshal.FreeCoTaskMem（System.IntPtr） 一起释放。<br/> 异常:<br/> T：System.OutOfMemoryException：内存不足，无法满足请求。</p>\n<h4><a id=\"public_static_IntPtr_ReAllocCoTaskMemIntPtr_pv_int_cb_903\"></a>public static IntPtr ReAllocCoTaskMem(IntPtr pv, int cb);</h4>\n<p> <br/> 摘要：调整以前使用 System.Runtime.InteropServices.Marshal.AllocHGlobal（System.IntPtr） 分配的内存块的大小。<br/> 参数:<br/> pv：指向使用 System.Runtime.InteropServices.Marshal.AllocHGlobal（System.IntPtr） 分配的内存的指针。<br/> cb：已分配块的新大小。这不是一个指针;它是您正在请求的字节计数，强制转换为类型 System.IntPtr。如果传递指针，则会将其视为大小。<br/> 返回结果：指向重新分配的内存的指针。此内存必须使用 System.Runtime.InteropServices.Marshal.FreeHGlobal（System.IntPtr） 释放。<br/> 异常:<br/> T：System.OutOfMemoryException：内存不足，无法满足请求。</p>\n<h4><a id=\"public_static_IntPtr_ReAllocHGlobalIntPtr_pv_IntPtr_cb_912\"></a>public static IntPtr ReAllocHGlobal(IntPtr pv, IntPtr cb);</h4>\n<p> <br/> 摘要：递减指定接口上的引用计数。<br/> 参数:<br/> pUnk：要释放的接口。<br/> 返回结果：由 pUnk 参数指定的接口上的引用计数的新值。</p>\n<h4><a id=\"public_static_int_ReleaseIntPtr_pUnk_918\"></a>public static int Release(IntPtr pUnk);</h4>\n<p> <br/> 摘要：递减与指定 COM 对象关联的运行时可调用包装 （RCW） 的引用计数。<br/> 参数:<br/> o：要释放的 COM 对象。<br/> 返回结果：与 o 关联的 RCW 的引用计数的新值。此值通常为零，因为 RCW 只保留对包装的 COM 对象的一个引用，而不管调用它的托管客户端的数量如何。<br/> 异常:<br/> T：System.ArgumentException： o 不是有效的 COM 对象。<br/> T：System.NullReferenceException： o is null.</p>\n<h4><a id=\"public_static_int_ReleaseComObjectobject_o_927\"></a>public static int ReleaseComObject(object o);</h4>\n<p> <br/> 摘要：分配一个非托管二进制字符串 （BSTR），并将托管 System.Security.SecureString 对象的内容复制到其中。<br/> 参数:<br/> s：要复制的托管对象。<br/> 返回结果：非托管内存中 s 参数复制到的地址，如果提供了 null 对象，则为 0。<br/> 异常:<br/> T：System.ArgumentNullException：s 参数为 null。<br/> T：System.NotSupportedException：当前计算机未运行 Windows 2000 Service Pack 3 或更高版本。<br/> T：System.OutOfMemoryException：可用内存不足。<br/> [CLSCompliant(false)]</p>\n<h4><a id=\"public_static_IntPtr_SecureStringToBSTRSecureString_s_938\"></a>public static IntPtr SecureStringToBSTR(SecureString s);</h4>\n<p> <br/> 摘要：将托管 System.Security.SecureString 对象的内容复制到从非托管 COM 任务分配器分配的内存块。<br/> 参数:<br/> s：要复制的托管对象。<br/> 返回结果：非托管内存中 s 参数复制到的地址，如果提供了 null 对象，则为 0。<br/> 异常:<br/> T：System.ArgumentNullException：s 参数为 null。<br/> T：System.NotSupportedException：当前计算机未运行 Windows 2000 Service Pack 3 或更高版本。<br/> T：System.OutOfMemoryException：可用内存不足。<br/> [CLSCompliant(false)]</p>\n<h4><a id=\"public_static_IntPtr_SecureStringToCoTaskMemAnsiSecureString_s_949\"></a>public static IntPtr SecureStringToCoTaskMemAnsi(SecureString s);</h4>\n<p> <br/> 摘要：将托管 System.Security.SecureString 对象的内容复制到从非托管 COM 任务分配器分配的内存块。<br/> 参数:<br/> s：要复制的托管对象。<br/> 返回结果：非托管内存中 s 参数复制到的地址，如果提供了 null 对象，则为 0。<br/> 异常:<br/> T：System.ArgumentNullException：s 参数为 null。<br/> T：System.NotSupportedException：当前计算机未运行 Windows 2000 Service Pack 3 或更高版本。<br/> T：System.OutOfMemoryException：可用内存不足。<br/> [CLSCompliant(false)]</p>\n<h4><a id=\"public_static_IntPtr_SecureStringToCoTaskMemUnicodeSecureString_s_960\"></a>public static IntPtr SecureStringToCoTaskMemUnicode(SecureString s);</h4>\n<p> <br/> 摘要：将受管系统的内容复制到非托管内存中，并在复制时转换为 ANSI 格式。<br/> 参数:<br/> s：要复制的托管对象。<br/> 返回结果：非托管内存中将 s 参数复制到的地址，如果提供了 null 对象，则为 0。<br/> 异常:<br/> T：System.ArgumentNullException：s 参数为 null。<br/> T：System.NotSupportedException：当前计算机未运行 Windows 2000 Service Pack 3 或更高版本。<br/> T：System.OutOfMemoryException：可用内存不足。<br/> [CLSCompliant(false)]</p>\n<h4><a id=\"public_static_IntPtr_SecureStringToGlobalAllocAnsiSecureString_s_971\"></a>public static IntPtr SecureStringToGlobalAllocAnsi(SecureString s);</h4>\n<p> <br/> 摘要：将受管系统的内容复制到非受管内存中。<br/> 参数:<br/> s：要复制的托管对象。<br/> 返回结果：在非托管内存中，s 被复制到的地址，如果 s 是长度为 0 的 System.Security.SecureString 对象，则为 0。<br/> 异常:<br/> T：System.ArgumentNullException：s 参数为 null。<br/> T：System.NotSupportedException：当前计算机未运行 Windows 2000 Service Pack 3 或更高版本。<br/> T：System.OutOfMemoryException：可用内存不足。<br/> [CLSCompliant(false)]</p>\n<h4><a id=\"public_static_IntPtr_SecureStringToGlobalAllocUnicodeSecureString_s_982\"></a>public static IntPtr SecureStringToGlobalAllocUnicode(SecureString s);</h4>\n<p> <br/> 摘要：设置指定 COM 对象中指定键所引用的数据。<br/> 参数:<br/> obj：用于存储数据的 COM 对象。<br/> key：COM 对象的内部哈希表中用于存储数据的键。<br/> 数据：要设置的数据。<br/> 返回结果： 如果数据设置成功，则为 true;否则，为假。<br/> 异常:<br/> T：System.ArgumentNullException： obj is null.-or- 键为空。<br/> T：System.ArgumentException： obj 不是 COM 对象。-or- obj 是一个 Windows 运行时对象。</p>\n<h4><a id=\"public_static_bool_SetComObjectDataobject_obj_object_key_object_data_993\"></a>public static bool SetComObjectData(object obj, object key, object? data);</h4>\n<p> <br/> 摘要： [在 .NET Framework 4.5.1 及更高版本中受支持] 返回非托管类型的大小（以字节为单位）。<br/> 类型参数:<br/> T：要返回其大小的类型。<br/> 返回结果：由 T 泛型类型参数指定的类型的大小（以字节为单位）。</p>\n<h4><a id=\"public_static_int_SizeOfT_999\"></a>public static int SizeOf();</h4>\n<p> <br/> 摘要： [在 .NET Framework 4.5.1 及更高版本中受支持] 返回指定类型的对象的非托管大小（以字节为单位）。<br/> 参数:<br/> 结构：要返回其大小的对象。<br/> 类型参数:<br/> T：结构参数的类型。<br/> 返回结果：非托管代码中指定对象的大小（以字节为单位）。<br/> 异常:<br/> T：System.ArgumentNullException：结构参数为 null。</p>\n<h4><a id=\"public_static_int_SizeOfTT_structure_1009\"></a>public static int SizeOf(T structure);</h4>\n<p> <br/> 摘要：返回对象的非托管大小（以字节为单位）。<br/> 参数:<br/> 结构：要返回其大小的对象。<br/> 返回结果：非托管代码中指定对象的大小。<br/> 异常:<br/> T：System.ArgumentNullException：结构参数为 null。<br/> [EditorBrowsable(EditorBrowsableState.Never)]</p>\n<h4><a id=\"public_static_int_SizeOfobject_structure_1018\"></a>public static int SizeOf(object structure);</h4>\n<p> <br/> 摘要：返回非托管类型的大小（以字节为单位）。<br/> 参数:<br/> t：要返回其大小的类型。<br/> 返回结果：非托管代码中指定类型的大小。<br/> 异常:<br/> T：System.ArgumentException：t 参数是泛型类型定义。<br/> T：System.ArgumentNullException：t 参数为 null。<br/> [EditorBrowsable(EditorBrowsableState.Never)]</p>\n<h4><a id=\"public_static_int_SizeOfType_t_1028\"></a>public static int SizeOf(Type t);</h4>\n<p> <br/> 摘要：分配一个 BSTR 并将托管系统的内容复制到其中。<br/> 参数:<br/> s：要复制的托管字符串。<br/> 返回结果：指向 BSTR 的非托管指针，如果 s 为 null，则返回 0。<br/> 异常:<br/> T：System.OutOfMemoryException：可用内存不足。<br/> T：System.ArgumentOutOfRangeException：s 的长度超出范围。</p>\n<h4><a id=\"public_static_IntPtr_StringToBSTRstring_s_1037\"></a>public static IntPtr StringToBSTR(string? s);</h4>\n<p> <br/> 摘要：将受管 System.String 的内容复制到从非托管 COM 任务分配器分配的内存块。<br/> 参数:<br/> s：要复制的托管字符串。<br/> 返回结果：一个整数，表示指向为字符串分配的内存块的指针，如果 s 为 null，则为 0。<br/> 异常:<br/> T：System.OutOfMemoryException：可用内存不足。<br/> T：System.ArgumentOutOfRangeException：s 参数超过操作系统允许的最大长度。</p>\n<h4><a id=\"public_static_IntPtr_StringToCoTaskMemAnsistring_s_1046\"></a>public static IntPtr StringToCoTaskMemAnsi(string? s);</h4>\n<p> <br/> 摘要：将受管 System.String 的内容复制到从非托管 COM 任务分配器分配的内存块。<br/> 参数:<br/> s：要复制的托管字符串。<br/> 返回结果：分配的内存块，如果 s 为空，则返回 0。<br/> 异常:<br/> T：System.OutOfMemoryException：可用内存不足。<br/> T：System.ArgumentOutOfRangeException：s 的长度超出范围。</p>\n<h4><a id=\"public_static_IntPtr_StringToCoTaskMemAutostring_s_1055\"></a>public static IntPtr StringToCoTaskMemAuto(string? s);</h4>\n<p> <br/> 摘要：将受管 System.String 的内容复制到从非托管 COM 任务分配器分配的内存块。<br/> 参数:<br/> s：要复制的托管字符串。<br/> 返回结果：一个整数，表示指向为字符串分配的内存块的指针，如果 s 为 null，则为 0。<br/> 异常:<br/> T：System.ArgumentOutOfRangeException：s 参数超过操作系统允许的最大长度。<br/> T：System.OutOfMemoryException：可用内存不足。</p>\n<h4><a id=\"public_static_IntPtr_StringToCoTaskMemUnistring_s_1064\"></a>public static IntPtr StringToCoTaskMemUni(string? s);</h4>\n<p>参数:<br/> s:</p>\n<h4><a id=\"public_static_IntPtr_StringToCoTaskMemUTF8string_s_1067\"></a>public static IntPtr StringToCoTaskMemUTF8(string? s);</h4>\n<p> <br/> 摘要：将受管 System.String 的内容复制到非托管内存中，在复制时转换为 ANSI 格式。<br/> 参数:<br/> s：要复制的托管字符串。<br/> 返回结果：非托管内存中将 s 复制到的地址，如果 s 为 null，则为 0。<br/> 异常:<br/> T：System.OutOfMemoryException：可用内存不足。<br/> T：System.ArgumentOutOfRangeException：s 参数超过操作系统允许的最大长度。</p>\n<h4><a id=\"public_static_IntPtr_StringToHGlobalAnsistring_s_1076\"></a>public static IntPtr StringToHGlobalAnsi(string? s);</h4>\n<p> <br/> 摘要：将受管 System.String 的内容复制到非托管内存中，如果需要，可转换为 ANSI 格式。<br/> 参数:<br/> s：要复制的托管字符串。<br/> 返回结果：非托管内存中将字符串复制到的地址，如果 s 为 null，则为 0。<br/> 异常:<br/> T：System.OutOfMemoryException：可用内存不足。</p>\n<h4><a id=\"public_static_IntPtr_StringToHGlobalAutostring_s_1084\"></a>public static IntPtr StringToHGlobalAuto(string? s);</h4>\n<p> <br/> 摘要：将受管系统的内容复制到非受管内存中。<br/> 参数:<br/> s：要复制的托管字符串。<br/> 返回结果：非托管内存中将 s 复制到的地址，如果 s 为 null，则为 0。<br/> 异常:<br/> T：System.OutOfMemoryException：该方法无法分配足够的本机堆内存。<br/> T：System.ArgumentOutOfRangeException：s 参数超过操作系统允许的最大长度。</p>\n<h4><a id=\"public_static_IntPtr_StringToHGlobalUnistring_s_1093\"></a>public static IntPtr StringToHGlobalUni(string? s);</h4>\n<p> <br/> 摘要：[在 .NET Framework 4.5.1 及更高版本中受支持] 将数据从指定类型的托管对象封送到非托管内存块。<br/> 参数:<br/> 结构：保存要封送处理的数据的托管对象。该对象必须是格式化类的结构或实例。<br/> ptr：指向非托管内存块的指针，必须在调用此方法之前分配该内存块。<br/> fDeleteOld：在 ptr 参数上调用 System.Runtime.InteropServices.Marshal.DestroyStructure’'1（System.IntPtr） 方法之前，将此方法调用该方法。该块必须包含有效数据。请注意，当内存块已包含数据时传递 false 可能会导致内存泄漏。<br/> 类型参数:<br/> T：托管对象的类型。<br/> 异常:<br/> T：System.ArgumentException：结构是一种引用类型，它不是格式化的类。</p>\n<h4><a id=\"public_static_void_StructureToPtrTDisallowNull_T_structure_IntPtr_ptr_bool_fDeleteOld_1104\"></a>public static void StructureToPtr([DisallowNull] T structure, IntPtr ptr, bool fDeleteOld);</h4>\n<p> <br/> 摘要：将数据从托管对象封送到非托管内存块。<br/> 参数:<br/> 结构：保存要封送处理的数据的托管对象。此对象必须是格式化类的结构或实例。<br/> ptr：指向非托管内存块的指针，必须在调用此方法之前分配该内存块。<br/> fDeleteOld：在 ptr 参数上调用 System.Runtime.InteropServices.Marshal.DestroyStructure（System.IntPtr，System.Type） 方法，然后再调用此方法。该块必须包含有效数据。请注意，当内存块已包含数据时传递 false 可能会导致内存泄漏。<br/> 异常:<br/> T：System.ArgumentException：结构是一种引用类型，它不是格式化的类。 -or- 结构是泛型类型的实例（仅在 .NET Framework 4.5 和更早版本中）。<br/> [EditorBrowsable(EditorBrowsableState.Never)]</p>\n<h4><a id=\"public_static_void_StructureToPtrobject_structure_IntPtr_ptr_bool_fDeleteOld_1114\"></a>public static void StructureToPtr(object structure, IntPtr ptr, bool fDeleteOld);</h4>\n<p> <br/> 摘要：引发具有特定失败 HRESULT 值的异常。<br/> 参数:<br/> 错误代码：对应于所需异常的 HRESULT。</p>\n<h4><a id=\"public_static_void_ThrowExceptionForHRint_errorCode_1119\"></a>public static void ThrowExceptionForHR(int errorCode);</h4>\n<p> <br/> 摘要：基于指定的 IErrorInfo.aspx） 接口，引发具有特定故障 HRESULT 的异常。<br/> 参数:<br/> 错误代码：对应于所需异常的 HRESULT。<br/> errorInfo：指向 IErrorInfo 接口的指针，提供有关错误的详细信息。您可以指定 IntPtr（0） 以使用当前的 IErrorInfo 接口，或指定 IntPtr（-1） 以忽略当前的 IErrorInfo 接口并仅从错误代码构造异常。</p>\n<h4><a id=\"public_static_void_ThrowExceptionForHRint_errorCode_IntPtr_errorInfo_1125\"></a>public static void ThrowExceptionForHR(int errorCode, IntPtr errorInfo);</h4>\n<p> <br/> 摘要：获取指定数组内指定索引处的元素的地址。<br/> 参数:<br/> arr：包含所需元素的数组。<br/> index：所需元素的 arr 参数中的索引。<br/> 返回结果： arr 内的索引地址。<br/> [EditorBrowsable(EditorBrowsableState.Never)]</p>\n<h4><a id=\"public_static_IntPtr_UnsafeAddrOfPinnedArrayElementArray_arr_int_index_1133\"></a>public static IntPtr UnsafeAddrOfPinnedArrayElement(Array arr, int index);</h4>\n<p> <br/> 摘要： [在 .NET Framework 4.5.1 及更高版本中受支持] 获取指定类型数组中指定索引处的元素的地址。<br/> 参数:<br/> arr：包含所需元素的数组。<br/> index：arr 数组中所需元素的索引。<br/> 类型参数:<br/> T：数组的类型。<br/> 返回结果： arr 中索引的地址。</p>\n<h4><a id=\"public_static_IntPtr_UnsafeAddrOfPinnedArrayElementTT_arr_int_index_1142\"></a>public static IntPtr UnsafeAddrOfPinnedArrayElement(T[] arr, int index);</h4>\n<p> <br/> 摘要：将单字节值写入非托管内存。<br/> 参数:<br/> ptr：非托管内存中要写入的地址。<br/> val：要写入的值。<br/> 异常:<br/> T：System.AccessViolationException：ptr 不是可识别的格式。-or- ptr 为空。-or- ptr 无效。</p>\n<h4><a id=\"public_static_void_WriteByteIntPtr_ptr_byte_val_1150\"></a>public static void WriteByte(IntPtr ptr, byte val);</h4>\n<p> <br/> 摘要：以指定的偏移量将单字节值写入非托管内存。<br/> 参数:<br/> ptr：非托管内存中要写入的基址。<br/> ofs：一个额外的字节偏移量，在写入之前添加到 ptr 参数中。<br/> val：要写入的值。<br/> 异常:<br/> T：System.AccessViolationException：基址 （ptr） 加上偏移字节 （ofs） 会生成空地址或无效地址。</p>\n<h4><a id=\"public_static_void_WriteByteIntPtr_ptr_int_ofs_byte_val_1159\"></a>public static void WriteByte(IntPtr ptr, int ofs, byte val);</h4>\n<p> <br/> 摘要：以指定的偏移量将单字节值写入非托管内存。<br/> 参数:<br/> ptr：目标对象的非托管内存中的基址。<br/> ofs：一个额外的字节偏移量，在写入之前添加到 ptr 参数中。<br/> val：要写入的值。<br/> 异常:<br/> T：System.AccessViolationException：基址 （ptr） 加上偏移字节 （ofs） 会生成空地址或无效地址。<br/> T：System.ArgumentException： ptr 是一个 System.Runtime.InteropServices.ArrayWithOffset 对象。此方法不接受 System.Runtime.InteropServices.ArrayWithOffset 参数。<br/> [EditorBrowsable(EditorBrowsableState.Never)]<br/> [Obsolete(“WriteByte(Object, Int32, Byte) may be unavailable in future releases.”)]</p>\n<h4><a id=\"public_static_void_WriteByteobject_ptr_int_ofs_byte_val_1171\"></a>public static void WriteByte(object ptr, int ofs, byte val);</h4>\n<p> <br/> 摘要：以指定的偏移量将 16 位有符号整数值写入非托管内存。<br/> 参数:<br/> ptr：目标对象的非托管内存中的基址。<br/> ofs：一个额外的字节偏移量，在写入之前添加到 ptr 参数中。<br/> val：要写入的值。<br/> 异常:<br/> T：System.AccessViolationException：基址 （ptr） 加上偏移字节 （ofs） 会生成空地址或无效地址。<br/> T：System.ArgumentException： ptr 是一个 System.Runtime.InteropServices.ArrayWithOffset 对象。此方法不接受 System.Runtime.InteropServices.ArrayWithOffset 参数。<br/> [EditorBrowsable(EditorBrowsableState.Never)]<br/> [Obsolete(“WriteInt16(Object, Int32, Int16) may be unavailable in future releases.”)]</p>\n<h4><a id=\"public_static_void_WriteInt16object_ptr_int_ofs_short_val_1183\"></a>public static void WriteInt16(object ptr, int ofs, short val);</h4>\n<p> <br/> 摘要：以指定的偏移量将 16 位有符号整数值写入非托管内存。<br/> 参数:<br/> ptr：目标对象的非托管内存中的基址。<br/> ofs：一个额外的字节偏移量，在写入之前添加到 ptr 参数中。<br/> val：要写入的值。<br/> 异常:<br/> T：System.AccessViolationException：基址 （ptr） 加上偏移字节 （ofs） 会生成空地址或无效地址。<br/> T：System.ArgumentException： ptr 是一个 System.Runtime.InteropServices.ArrayWithOffset 对象。此方法不接受 System.Runtime.InteropServices.ArrayWithOffset 参数。<br/> [EditorBrowsable(EditorBrowsableState.Never)]<br/> [Obsolete(“WriteInt16(Object, Int32, Char) may be unavailable in future releases.”)]</p>\n<h4><a id=\"public_static_void_WriteInt16object_ptr_int_ofs_char_val_1195\"></a>public static void WriteInt16(object ptr, int ofs, char val);</h4>\n<p> <br/> 摘要：将 16 位有符号整数值以指定的偏移量写入非托管内存。<br/> 参数:<br/> ptr：非托管内存中要写入的基址。<br/> ofs：一个额外的字节偏移量，在写入之前添加到 ptr 参数中。<br/> val：要写入的值。<br/> 异常:<br/> T：System.AccessViolationException：基址 （ptr） 加上偏移字节 （ofs） 会生成空地址或无效地址。</p>\n<h4><a id=\"public_static_void_WriteInt16IntPtr_ptr_int_ofs_short_val_1204\"></a>public static void WriteInt16(IntPtr ptr, int ofs, short val);</h4>\n<p> <br/> 摘要：将一个字符作为 16 位整数值写入非托管内存。<br/> 参数:<br/> ptr：非托管内存中要写入的地址。<br/> val：要写入的值。<br/> 异常:<br/> T：System.AccessViolationException：ptr 不是可识别的格式。-or- ptr 为空。-or- ptr 无效。</p>\n<h4><a id=\"public_static_void_WriteInt16IntPtr_ptr_char_val_1212\"></a>public static void WriteInt16(IntPtr ptr, char val);</h4>\n<p> <br/> 摘要：将 16 位整数值写入非托管内存。<br/> 参数:<br/> ptr：非托管内存中要写入的地址。<br/> val：要写入的值。<br/> 异常:<br/> T：System.AccessViolationException：ptr 不是可识别的格式。-or- ptr 为空。-or- ptr 无效。</p>\n<h4><a id=\"public_static_void_WriteInt16IntPtr_ptr_short_val_1220\"></a>public static void WriteInt16(IntPtr ptr, short val);</h4>\n<p> <br/> 摘要：以指定的偏移量将 16 位有符号整数值写入非托管内存。<br/> 参数:<br/> ptr：本机堆中要写入的基址。<br/> ofs：一个额外的字节偏移量，在写入之前添加到 ptr 参数中。<br/> val：要写入的值。<br/> 异常:<br/> T：System.AccessViolationException：基址 （ptr） 加上偏移字节 （ofs） 会生成空地址或无效地址。</p>\n<h4><a id=\"public_static_void_WriteInt16IntPtr_ptr_int_ofs_char_val_1229\"></a>public static void WriteInt16(IntPtr ptr, int ofs, char val);</h4>\n<p> <br/> 摘要：将 32 位有符号整数值写入非托管内存。<br/> 参数:<br/> ptr：非托管内存中要写入的地址。<br/> val：要写入的值。<br/> 异常:<br/> T：System.AccessViolationException：ptr 不是可识别的格式。-or- ptr 为空。-or- ptr 无效。</p>\n<h4><a id=\"public_static_void_WriteInt32IntPtr_ptr_int_val_1237\"></a>public static void WriteInt32(IntPtr ptr, int val);</h4>\n<p> <br/> 摘要：将 32 位有符号整数值以指定的偏移量写入非托管内存。<br/> 参数:<br/> ptr：非托管内存中要写入的基址。<br/> ofs：一个额外的字节偏移量，在写入之前添加到 ptr 参数中。<br/> val：要写入的值。<br/> 异常:<br/> T：System.AccessViolationException：基址 （ptr） 加上偏移字节 （ofs） 会生成空地址或无效地址。</p>\n<h4><a id=\"public_static_void_WriteInt32IntPtr_ptr_int_ofs_int_val_1246\"></a>public static void WriteInt32(IntPtr ptr, int ofs, int val);</h4>\n<p> <br/> 摘要：将 32 位有符号整数值写入非托管内存，偏移量为指定偏移量。<br/> 参数:<br/> ptr：目标对象的非托管内存中的基址。<br/> ofs：一个额外的字节偏移量，在写入之前添加到 ptr 参数中。<br/> val：要写入的值。<br/> 异常:<br/> T：System.AccessViolationException：基址 （ptr） 加上偏移字节 （ofs） 会生成空地址或无效地址。<br/> T：System.ArgumentException： ptr 是一个 System.Runtime.InteropServices.ArrayWithOffset 对象。此方法不接受 System.Runtime.InteropServices.ArrayWithOffset 参数。<br/> [EditorBrowsable(EditorBrowsableState.Never)]<br/> [Obsolete(“WriteInt32(Object, Int32, Int32) may be unavailable in future releases.”)]</p>\n<h4><a id=\"public_static_void_WriteInt32object_ptr_int_ofs_int_val_1258\"></a>public static void WriteInt32(object ptr, int ofs, int val);</h4>\n<p> <br/> 摘要：以指定的偏移量将 64 位有符号整数值写入非托管内存。<br/> 参数:<br/> ptr：非托管内存中要写入的基址。<br/> ofs：一个额外的字节偏移量，在写入之前添加到 ptr 参数中。<br/> val：要写入的值。<br/> 异常:<br/> T：System.AccessViolationException：基址 （ptr） 加上偏移字节 （ofs） 会生成空地址或无效地址。</p>\n<h4><a id=\"public_static_void_WriteInt64IntPtr_ptr_int_ofs_long_val_1267\"></a>public static void WriteInt64(IntPtr ptr, int ofs, long val);</h4>\n<p> <br/> 摘要：将 64 位有符号整数值写入非托管内存。<br/> 参数:<br/> ptr：非托管内存中要写入的地址。<br/> val：要写入的值。<br/> 异常:<br/> T：System.AccessViolationException：ptr 不是可识别的格式。-or- ptr 为空。-or- ptr 无效。</p>\n<h4><a id=\"public_static_void_WriteInt64IntPtr_ptr_long_val_1275\"></a>public static void WriteInt64(IntPtr ptr, long val);</h4>\n<p> <br/> 摘要：以指定的偏移量将 64 位有符号整数值写入非托管内存。<br/> 参数:<br/> ptr：目标对象的非托管内存中的基址。<br/> ofs：一个额外的字节偏移量，在写入之前添加到 ptr 参数中。<br/> val：要写入的值。<br/> 异常:<br/> T：System.AccessViolationException：基址 （ptr） 加上偏移字节 （ofs） 会生成空地址或无效地址。<br/> T：System.ArgumentException： ptr 是一个 System.Runtime.InteropServices.ArrayWithOffset 对象。此方法不接受 System.Runtime.InteropServices.ArrayWithOffset 参数。<br/> [EditorBrowsable(EditorBrowsableState.Never)]<br/> [Obsolete(“WriteInt64(Object, Int32, Int64) may be unavailable in future releases.”)]</p>\n<h4><a id=\"public_static_void_WriteInt64object_ptr_int_ofs_long_val_1287\"></a>public static void WriteInt64(object ptr, int ofs, long val);</h4>\n<p> <br/> 摘要：将处理器的本机大小整数值写入非托管内存。<br/> 参数:<br/> ptr：目标对象的非托管内存中的基址。<br/> ofs：一个额外的字节偏移量，在写入之前添加到 ptr 参数中。<br/> val：要写入的值。<br/> 异常:<br/> T：System.AccessViolationException：基址 （ptr） 加上偏移字节 （ofs） 会生成空地址或无效地址。<br/> T：System.ArgumentException： ptr 是一个 System.Runtime.InteropServices.ArrayWithOffset 对象。此方法不接受 System.Runtime.InteropServices.ArrayWithOffset 参数。<br/> [EditorBrowsable(EditorBrowsableState.Never)]<br/> [Obsolete(“WriteIntPtr(Object, Int32, IntPtr) may be unavailable in future releases.”)]</p>\n<h4><a id=\"public_static_void_WriteIntPtrobject_ptr_int_ofs_IntPtr_val_1299\"></a>public static void WriteIntPtr(object ptr, int ofs, IntPtr val);</h4>\n<p> <br/> 摘要：将处理器本机大小的整数值写入非托管内存，以指定的偏移量写入非托管内存。<br/> 参数:<br/> ptr：非托管内存中要写入的基址。<br/> ofs：一个额外的字节偏移量，在写入之前添加到 ptr 参数中。<br/> val：要写入的值。<br/> 异常:<br/> T：System.AccessViolationException：基址 （ptr） 加上偏移字节 （ofs） 会生成空地址或无效地址。</p>\n<h4><a id=\"public_static_void_WriteIntPtrIntPtr_ptr_int_ofs_IntPtr_val_1308\"></a>public static void WriteIntPtr(IntPtr ptr, int ofs, IntPtr val);</h4>\n<p> <br/> 摘要：将处理器的本机大小整数值写入非托管内存。<br/> 参数:<br/> ptr：非托管内存中要写入的地址。<br/> val：要写入的值。<br/> 异常:<br/> T：System.AccessViolationException：ptr 不是可识别的格式。-or- ptr 为空。-or- ptr 无效。</p>\n<h4><a id=\"public_static_void_WriteIntPtrIntPtr_ptr_IntPtr_val_1316\"></a>public static void WriteIntPtr(IntPtr ptr, IntPtr val);</h4>\n<p> <br/> 摘要：释放使用 System.Runtime.InteropServices.Marshal.SecureStringToBSTR（System.Security.SecureString） 方法分配的 BSTR 指针。<br/> 参数:<br/> s：BSTR 的地址。</p>\n<h4><a id=\"public_static_void_ZeroFreeBSTRIntPtr_s_1321\"></a>public static void ZeroFreeBSTR(IntPtr s);</h4>\n<p> <br/> 摘要：释放使用 System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi（System.Security.SecureString） 方法分配的非托管字符串指针。<br/> 参数:<br/> s：要释放的非托管字符串的地址。</p>\n<h4><a id=\"public_static_void_ZeroFreeCoTaskMemAnsiIntPtr_s_1326\"></a>public static void ZeroFreeCoTaskMemAnsi(IntPtr s);</h4>\n<p> <br/> 摘要：释放使用 System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode（System.Security.SecureString） 方法分配的非托管字符串指针。<br/> 参数:<br/> s：要释放的非托管字符串的地址。</p>\n<h4><a id=\"public_static_void_ZeroFreeCoTaskMemUnicodeIntPtr_s_1331\"></a>public static void ZeroFreeCoTaskMemUnicode(IntPtr s);</h4>\n<p>参数:<br/> s:</p>\n<h4><a id=\"public_static_void_ZeroFreeCoTaskMemUTF8IntPtr_s_1334\"></a>public static void ZeroFreeCoTaskMemUTF8(IntPtr s);</h4>\n<p> <br/> 摘要：释放使用 System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi（System.Security.SecureString） 方法分配的非托管字符串指针。<br/> 参数:<br/> s：要释放的非托管字符串的地址。</p>\n<h4><a id=\"public_static_void_ZeroFreeGlobalAllocAnsiIntPtr_s_1339\"></a>public static void ZeroFreeGlobalAllocAnsi(IntPtr s);</h4>\n<p> <br/> 摘要：释放使用 System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode（System.Security.SecureString） 方法分配的非托管字符串指针。<br/> 参数:<br/> s：要释放的非托管字符串的地址。</p>\n<h4><a id=\"public_static_void_ZeroFreeGlobalAllocUnicodeIntPtr_s_1344\"></a>public static void ZeroFreeGlobalAllocUnicode(IntPtr s);</h4>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}