{"blogid": "126155539", "writerAge": "码龄1年", "writerBlogNum": "7", "writerCollect": "201", "writerComment": "470", "writerFan": "648", "writerGrade": "4级", "writerIntegral": "1050", "writerName": "Duoni.", "writerProfileAdress": "writer_image\\profile_126155539.jpg", "writerRankTotal": "19904", "writerRankWeekly": "372046", "writerThumb": "321", "writerVisitNum": "6310", "blog_read_count": "336", "blog_time": "于 2022-08-04 12:41:12 发布", "blog_title": "【C++·峰顶计划】引用操作及底层原理深析，七夕也要学习哦", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<blockquote>\n<p style=\"text-align:center;\"><strong>Hi！我是Duoni！</strong></p>\n</blockquote>\n<p></p>\n<p><strong><img alt=\"d3801154c39743509738312e129cbba2.jpeg\" src=\"image\\d3801154c39743509738312e129cbba2.jpeg\"/></strong></p>\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%F0%9F%8D%8A%E5%BC%95%E7%94%A8-toc\" style=\"margin-left:0px;\"><a href=\"#%F0%9F%8D%8A%E5%BC%95%E7%94%A8\">🍊引用</a></p>\n<p id=\"%F0%9F%8D%8A%E5%BC%95%E7%94%A8%E4%B8%8E%E5%8F%96%E5%9C%B0%E5%9D%80%E7%AC%A6%E7%9A%84%E5%8C%BA%E5%88%86-toc\" style=\"margin-left:40px;\"><a href=\"#%F0%9F%8D%8A%E5%BC%95%E7%94%A8%E4%B8%8E%E5%8F%96%E5%9C%B0%E5%9D%80%E7%AC%A6%E7%9A%84%E5%8C%BA%E5%88%86\">🍊引用与取地址符的区分</a></p>\n<p id=\"%F0%9F%8D%8A%E5%BC%95%E7%94%A8%E7%9A%84%E7%89%B9%E6%80%A7-toc\" style=\"margin-left:40px;\"><a href=\"#%F0%9F%8D%8A%E5%BC%95%E7%94%A8%E7%9A%84%E7%89%B9%E6%80%A7\">🍊引用的特性</a></p>\n<p id=\"%F0%9F%8D%8A%E5%BC%95%E7%94%A8%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-toc\" style=\"margin-left:40px;\"><a href=\"#%F0%9F%8D%8A%E5%BC%95%E7%94%A8%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF\">🍊引用的应用场景</a></p>\n<p id=\"%F0%9F%8D%8A%E4%BC%A0%E5%80%BC%E8%BF%94%E5%9B%9E%E4%B8%8E%E4%BC%A0%E5%BC%95%E7%94%A8%E8%BF%94%E5%9B%9E-toc\" style=\"margin-left:0px;\"><a href=\"#%F0%9F%8D%8A%E4%BC%A0%E5%80%BC%E8%BF%94%E5%9B%9E%E4%B8%8E%E4%BC%A0%E5%BC%95%E7%94%A8%E8%BF%94%E5%9B%9E\">🍊传值返回与传引用返回</a></p>\n<p id=\"%F0%9F%8D%8A%E4%BC%A0%E5%80%BC%E8%BF%94%E5%9B%9E-toc\" style=\"margin-left:40px;\"><a href=\"#%F0%9F%8D%8A%E4%BC%A0%E5%80%BC%E8%BF%94%E5%9B%9E\">🍊传值返回</a></p>\n<p id=\"%F0%9F%8D%8A%E4%BC%A0%E5%80%BC%E8%BF%94%E5%9B%9E%E7%9A%84%E5%AE%9E%E7%8E%B0-toc\" style=\"margin-left:80px;\"><a href=\"#%F0%9F%8D%8A%E4%BC%A0%E5%80%BC%E8%BF%94%E5%9B%9E%E7%9A%84%E5%AE%9E%E7%8E%B0\">🍊传值返回的实现</a></p>\n<p id=\"%F0%9F%8D%8A%E4%BC%A0%E5%BC%95%E7%94%A8%E8%BF%94%E5%9B%9E-toc\" style=\"margin-left:40px;\"><a href=\"#%F0%9F%8D%8A%E4%BC%A0%E5%BC%95%E7%94%A8%E8%BF%94%E5%9B%9E\">🍊传引用返回</a></p>\n<p id=\"%F0%9F%8D%8A%E4%BC%A0%E5%BC%95%E7%94%A8%E8%BF%94%E5%9B%9E%E7%9A%84%E5%AE%9E%E7%8E%B0-toc\" style=\"margin-left:80px;\"><a href=\"#%F0%9F%8D%8A%E4%BC%A0%E5%BC%95%E7%94%A8%E8%BF%94%E5%9B%9E%E7%9A%84%E5%AE%9E%E7%8E%B0\">🍊传引用返回的实现</a></p>\n<p id=\"%F0%9F%8D%8A%E4%BC%A0%E5%80%BC%E8%BF%94%E5%9B%9E%E4%B8%8E%E4%BC%A0%E5%BC%95%E7%94%A8%E8%BF%94%E5%9B%9E%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9-toc\" style=\"margin-left:0px;\"><a href=\"#%F0%9F%8D%8A%E4%BC%A0%E5%80%BC%E8%BF%94%E5%9B%9E%E4%B8%8E%E4%BC%A0%E5%BC%95%E7%94%A8%E8%BF%94%E5%9B%9E%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9\">🍊传值返回与传引用返回的优缺点</a></p>\n<p id=\"%F0%9F%8D%8A%E5%B8%B8%E5%BC%95%E7%94%A8-toc\" style=\"margin-left:0px;\"><a href=\"#%F0%9F%8D%8A%E5%B8%B8%E5%BC%95%E7%94%A8\">🍊常引用</a></p>\n<p id=\"%F0%9F%8D%8A%E6%9D%83%E9%99%90%E8%A7%84%E5%88%99-toc\" style=\"margin-left:40px;\"><a href=\"#%F0%9F%8D%8A%E6%9D%83%E9%99%90%E8%A7%84%E5%88%99\">🍊权限规则</a></p>\n<p id=\"%F0%9F%8D%8A%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-toc\" style=\"margin-left:40px;\"><a href=\"#%F0%9F%8D%8A%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2\">🍊隐式类型转换</a></p>\n<p id=\"%F0%9F%8D%8A%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB-toc\" style=\"margin-left:0px;\"><a href=\"#%F0%9F%8D%8A%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB\">🍊指针与引用的区别</a></p>\n<p id=\"%F0%9F%8D%8A%E5%BC%95%E7%94%A8%E4%B8%8E%E6%8C%87%E9%92%88%E5%BA%95%E5%B1%82%E5%88%A8%E6%9E%90-toc\" style=\"margin-left:0px;\"><a href=\"#%F0%9F%8D%8A%E5%BC%95%E7%94%A8%E4%B8%8E%E6%8C%87%E9%92%88%E5%BA%95%E5%B1%82%E5%88%A8%E6%9E%90\">🍊引用与指针底层刨析</a></p>\n<p id=\"%F0%9F%8D%8A%E5%BA%95%E5%B1%82%E5%88%A8%E6%9E%90-toc\" style=\"margin-left:40px;\"><a href=\"#%F0%9F%8D%8A%E5%BA%95%E5%B1%82%E5%88%A8%E6%9E%90\">🍊底层刨析</a></p>\n<p id=\"%F0%9F%8D%8A%E6%B1%87%E7%BC%96%E8%A7%A3%E8%AF%BB-toc\" style=\"margin-left:80px;\"><a href=\"#%F0%9F%8D%8A%E6%B1%87%E7%BC%96%E8%A7%A3%E8%AF%BB\">🍊汇编解读</a></p>\n<p id=\"%F0%9F%8D%8A%E5%BC%95%E7%94%A8%E5%AE%9E%E7%8E%B0%E9%83%A8%E5%88%86-toc\" style=\"margin-left:80px;\"><a href=\"#%F0%9F%8D%8A%E5%BC%95%E7%94%A8%E5%AE%9E%E7%8E%B0%E9%83%A8%E5%88%86\">🍊引用实现部分</a></p>\n<p id=\"%F0%9F%8D%8A%E6%8C%87%E9%92%88%E5%AE%9E%E7%8E%B0%E9%83%A8%E5%88%86-toc\" style=\"margin-left:80px;\"><a href=\"#%F0%9F%8D%8A%E6%8C%87%E9%92%88%E5%AE%9E%E7%8E%B0%E9%83%A8%E5%88%86\">🍊指针实现部分</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<p></p>\n<h1 id=\"%F0%9F%8D%8A%E5%BC%95%E7%94%A8\">🍊引用</h1>\n<p></p>\n<p></p>\n<p><strong>引用概念：</strong>引用并不是一个独立定义的变量或其他值，而是一个对已存在的变量或其他值取了一个别名。这一期间编译器不会为他开辟空间（语法角度），它与其引用对象共同使用内存空间，对别名进行操作会影响引用对象。</p>\n<p></p>\n<p></p>\n<blockquote>\n<p style=\"text-align:center;\"><strong>引用用法：类型&amp; 引用变量名 = 引用对象名</strong></p>\n</blockquote>\n<p style=\"text-align:center;\"></p>\n<p style=\"text-align:center;\"></p>\n<pre><code class=\"language-cpp\">int num_a = 6;\nint&amp; num_b = num_a;//num_b是num_a的别名</code></pre>\n<p></p>\n<p></p>\n<p>为了便于理解，我们将取别名再理解为<strong>取外号。</strong></p>\n<p></p>\n<p></p>\n<p>tips：”小狗“被取了别名叫”修勾“。</p>\n<p></p>\n<p></p>\n<hr/>\n<p></p>\n<h2 id=\"%F0%9F%8D%8A%E5%BC%95%E7%94%A8%E4%B8%8E%E5%8F%96%E5%9C%B0%E5%9D%80%E7%AC%A6%E7%9A%84%E5%8C%BA%E5%88%86\">🍊引用与取地址符的区分</h2>\n<p></p>\n<p></p>\n<p><strong>&amp;符在类型名后的是引用</strong></p>\n<p></p>\n<p></p>\n<pre><code class=\"language-cpp\">int num_a = 6;\nint&amp; num_b = num_a;//给变量num_a定义了一个名为num_b的别名</code></pre>\n<p></p>\n<p></p>\n<p><strong>&amp;符在变量名前是取地址</strong></p>\n<p></p>\n<p></p>\n<pre><code class=\"language-cpp\">int num_a = 6;\nint* num_b = &amp;num_a;//取num_a的地址给num_b</code></pre>\n<p></p>\n<p></p>\n<p><strong>附：定义别名真的不会另开空间吗</strong></p>\n<p></p>\n<p></p>\n<pre><code class=\"language-cpp\">int main()\n{\n       int num_a = 6;\n       int&amp; num_b = num_a;//num_b是num_a的别名\n       std::cout &lt;&lt; \"变量num_a的地址：\" &lt;&lt; &amp; num_a &lt;&lt; std::endl;\n       std::cout &lt;&lt; \"别名num_b的地址：\" &lt;&lt; &amp; num_b &lt;&lt; std::endl;\n       return 0;\n}</code></pre>\n<p></p>\n<p></p>\n<p><img alt=\"15fa449c143144b59900353e3e4c231d.png\" src=\"image\\15fa449c143144b59900353e3e4c231d.png\"/></p>\n<p></p>\n<p></p>\n<p></p>\n<p><strong>小结：从语法角度上，定义别名，其别名是和引用对象共占一块空间的。</strong></p>\n<p></p>\n<p></p>\n<p><strong>tips：底层上，引用实际是依靠指针实现的，具体后期深入。</strong></p>\n<p></p>\n<p></p>\n<p><strong>附：对别名的修改会影响到引用对象吗？</strong></p>\n<p></p>\n<p></p>\n<pre><code class=\"language-cpp\">int main()\n{\n       int num_a = 6;\n       int&amp; num_b = num_a;\n       std::cout &lt;&lt; \"引用对象修改前：\" &lt;&lt; num_a &lt;&lt; std::endl;\n       std::cout &lt;&lt; \"别名修改前：\" &lt;&lt; num_b &lt;&lt; std::endl;\n       num_b--;\n       std::cout &lt;&lt; std::endl;\n       std::cout &lt;&lt; \"引用对象修改后：\" &lt;&lt; num_a &lt;&lt; std::endl;\n       std::cout &lt;&lt; \"别名修改后：\" &lt;&lt; num_b &lt;&lt; std::endl;\n       return 0;\n}</code></pre>\n<p></p>\n<p><img alt=\"f8eb612aaf28466895c78d634b462917.png\" src=\"image\\f8eb612aaf28466895c78d634b462917.png\"/></p>\n<p></p>\n<p></p>\n<p><strong>小结：对别名的操作会直接对引用对象进行影响。</strong></p>\n<p></p>\n<p></p>\n<hr/>\n<p></p>\n<p></p>\n<h2 id=\"%F0%9F%8D%8A%E5%BC%95%E7%94%A8%E7%9A%84%E7%89%B9%E6%80%A7\">🍊引用的特性</h2>\n<p></p>\n<p></p>\n<p><strong>1.引用在定义时必须被初始化</strong></p>\n<p></p>\n<p></p>\n<pre><code class=\"language-cpp\">int main()\n{\n       int&amp; val;//错误，引用的定义（使用）必须指明引用对象\n       return 0;\n}</code></pre>\n<p></p>\n<p></p>\n<p><img alt=\"809c08786ef14efea1ff0543f6ea6753.png\" src=\"image\\809c08786ef14efea1ff0543f6ea6753.png\"/></p>\n<p></p>\n<p></p>\n<p><strong>2.一个变量可以有多个引用，而一个别名也可以有多个别名</strong></p>\n<p></p>\n<p></p>\n<pre><code class=\"language-cpp\">int main()\n{\n       int num_a = 2;\n       int&amp; num_1 = num_a;//一个变量可以拥有多个别名\n       int&amp; num_2 = num_a;\n       int&amp; num_3 = num_a;\n       int&amp; num_cp1 = num_1;//一个别名可以拥有多个别名\n       int&amp; num_cp2 = num_1;\n       int&amp; num_cp3 = num_1;\n       std::cout &lt;&lt; \"我们都是变量num_a的别名：\" &lt;&lt; num_1 &lt;&lt; \" \" &lt;&lt; num_2 &lt;&lt; \" \" &lt;&lt; num_3 &lt;&lt; std::endl;\n       std::cout &lt;&lt; \"我们都是别名num_1的别名：\" &lt;&lt; num_cp1 &lt;&lt; \" \" &lt;&lt; num_cp2 &lt;&lt; \" \" &lt;&lt; num_cp3 &lt;&lt; std::endl;\n       return 0;\n}</code></pre>\n<p></p>\n<p><img alt=\"0732a43f6f194855af24f7b2117c37a9.png\" src=\"image\\0732a43f6f194855af24f7b2117c37a9.png\"/></p>\n<p></p>\n<p></p>\n<p><strong>3.引用一旦引用某一实体，就不能够再引用其他实体。</strong></p>\n<p></p>\n<p></p>\n<pre><code class=\"language-cpp\">int main()\n{\n       int val_a = 2;\n       int val_b = 6;\n       int&amp; num_cp = val_a;\n       num_cp = val_b;//num_cp不能够再改变实体，在这只能进行赋值动作\n       std::cout &lt;&lt; &amp;val_a &lt;&lt; std::endl;//观察num_cp十分还是val_a的别名\n       std::cout &lt;&lt; &amp;num_cp &lt;&lt; std::endl;\n       return 0;\n}</code></pre>\n<p></p>\n<p></p>\n<p><img alt=\"69ef9382e4624902be99e74ef08c021a.png\" src=\"image\\69ef9382e4624902be99e74ef08c021a.png\"/></p>\n<p></p>\n<p></p>\n<hr/>\n<p></p>\n<p></p>\n<h2 id=\"%F0%9F%8D%8A%E5%BC%95%E7%94%A8%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF\">🍊引用的应用场景</h2>\n<p></p>\n<p></p>\n<p><strong>1.可用于做参数（输出型参数）</strong></p>\n<p></p>\n<p></p>\n<pre><code class=\"language-cpp\">void Change_Num(int&amp; num_1, int&amp; num_2)//用引用接收参数\n{\n       num_1 = 60;//是否会对原值进行改变？\n       num_2 = 80;\n}\n\nint main()\n{\n       int val_1 = 6;\n       int val_2 = 8;\n       Change_Num(val_1, val_2);//传参\n       std::cout &lt;&lt; \"val_1:\" &lt;&lt; val_1 &lt;&lt; std::endl;\n       std::cout &lt;&lt; \"val_2:\" &lt;&lt; val_2 &lt;&lt; std::endl;\n       return 0;\n}</code></pre>\n<p></p>\n<p><img alt=\"4936535437734be9a770268a2e1e6b28.png\" src=\"image\\4936535437734be9a770268a2e1e6b28.png\"/></p>\n<p></p>\n<p></p>\n<p><strong>优点：提高了传参的效率，相对于指针的传址解引用修改。引用做参数能更加直观、便利的完成操作。</strong></p>\n<p></p>\n<p></p>\n<p><strong>tips：输入型参数与输出型参数是什么？</strong></p>\n<p></p>\n<p></p>\n<blockquote>\n<p>(1)、输入型参数是指：传参处传递的是普通变量，且在函数执行后，不会对外部的实体产生影响。</p>\n</blockquote>\n<p></p>\n<p></p>\n<blockquote>\n<p>(2)、输出型参数是指：传参处传递的是地址，或者在接收参数时使用别名接收，运行后会对外部实体产生影响。</p>\n</blockquote>\n<p></p>\n<p></p>\n<p><strong>2.大型对象的传参，提高效率。（节省了参数拷贝的环节）</strong></p>\n<p></p>\n<p></p>\n<p><strong>3、做返回值</strong>（输出型返回值，调用者可通过返回值修改引用对象。减少返回时的一次临时拷贝，提高效率）</p>\n<p></p>\n<p></p>\n<hr/>\n<h1></h1>\n<p></p>\n<h1 id=\"%F0%9F%8D%8A%E4%BC%A0%E5%80%BC%E8%BF%94%E5%9B%9E%E4%B8%8E%E4%BC%A0%E5%BC%95%E7%94%A8%E8%BF%94%E5%9B%9E\">🍊传值返回与传引用返回</h1>\n<p></p>\n<p></p>\n<h2 id=\"%F0%9F%8D%8A%E4%BC%A0%E5%80%BC%E8%BF%94%E5%9B%9E\">🍊传值返回</h2>\n<p></p>\n<p></p>\n<p>传值返回的意义：函数结束后，通过临时拷贝带回所需要的值。</p>\n<p></p>\n<p></p>\n<pre><code class=\"language-cpp\">int test_return()\n{\n       int num = 6;\n       return num;//第三步对值进行拷贝，产生值的临时拷贝//返回的只是num的一份临时拷贝\n}\n\nint main()//第一步栈空间开辟\n{\n       int val = test_return();//第二步调用函数//第三步接收返回值\n       return 0;\n}</code></pre>\n<p></p>\n<p></p>\n<hr/>\n<p></p>\n<p></p>\n<h3 id=\"%F0%9F%8D%8A%E4%BC%A0%E5%80%BC%E8%BF%94%E5%9B%9E%E7%9A%84%E5%AE%9E%E7%8E%B0\">🍊传值返回的实现</h3>\n<p></p>\n<p></p>\n<p></p>\n<p><strong>进入主函数，main函数在栈帧创建空间，再调用test_return函数，test_return函数在栈帧开辟空间，走到（return num值）的那一步，编译器做了两个动作：</strong></p>\n<p></p>\n<p></p>\n<p><strong>局部变量的生命周期取决于所存储的物理空间，栈空间在函数执行完毕后就会销毁，这也说明函数内的一切局部变量将随着栈空间的销毁而被销毁。</strong></p>\n<p></p>\n<p></p>\n<p><strong>而如果直接将值进行返回，那将是错误的，因为在函数结束后，所有的局部变量空间都被销毁，此时的返回值并不存在，最终形成了一次越界访问的错误，该值也会是一个随机值。</strong></p>\n<p></p>\n<p></p>\n<p><strong>为了返回有效的值，编译器是这么处理的：第一步，当进行到（return num值）时，会对num进行一次临时拷贝，存储它的数据。第二步，再将这一份临时拷贝的数据进行返回拷贝。</strong></p>\n<p></p>\n<p></p>\n<hr/>\n<p></p>\n<p></p>\n<p><strong>附：若函数中所返回值不存放在栈区，那编译器会怎么做？</strong></p>\n<p></p>\n<p></p>\n<pre><code class=\"language-cpp\">int test_return()\n{\n       static int num = 6;//我存放在静态区，栈帧销毁与我无关\n       //int num = 6;\n       return num;\n}</code></pre>\n<p></p>\n<p></p>\n<p><strong>确实，静态变量存放在静态区，栈区的销毁动作也并不能影响到它。但编译器同样还是会进行临时拷贝再返回的动作，因为这么做是最安全的。</strong></p>\n<p></p>\n<p></p>\n<p><strong>小结：只要是传值返回，都会形成临时拷贝。</strong></p>\n<p></p>\n<p></p>\n<hr/>\n<h2></h2>\n<p></p>\n<h2 id=\"%F0%9F%8D%8A%E4%BC%A0%E5%BC%95%E7%94%A8%E8%BF%94%E5%9B%9E\">🍊传引用返回</h2>\n<p></p>\n<p></p>\n<pre><code class=\"language-cpp\">int&amp; test_return()//返回num的别名\n{\n       int num = 6;//局部变量在函数结束后会被销毁\n       return num;\n}\n\nint main()\n{\n       int val = test_return();\n       return 0;\n}</code></pre>\n<p></p>\n<p></p>\n<hr/>\n<h3></h3>\n<p></p>\n<h3 id=\"%F0%9F%8D%8A%E4%BC%A0%E5%BC%95%E7%94%A8%E8%BF%94%E5%9B%9E%E7%9A%84%E5%AE%9E%E7%8E%B0\">🍊传引用返回的实现</h3>\n<p></p>\n<p></p>\n<p><strong>num成为引用对象，别名被返回。但函数结束意味着栈帧中局部变量的销毁，而别名一旦被定义引用对象便无法再修改。此时别名被返回到主函数中，若对别名进行访问，其结果是未被定义且不确定的。（可能是原值，也可能是随机值）</strong></p>\n<p></p>\n<p></p>\n<p><strong>小结;</strong>如果引用对象出了作用域一定被销毁，那么便一定不能使用引用返回，只能使用传值返回。若要使用传引用返回，那么前提一定要保证引用对象出作用域<strong>不被销毁</strong>。</p>\n<p></p>\n<p></p>\n<p><strong>附：</strong>引用对象被销毁后，再次用别名访问，得到的一定是随机值。<strong>因为栈空间销毁后，所有地址都保存着一个随机值，虽然引用对象被销毁，但空间一直存在！</strong></p>\n<p></p>\n<p></p>\n<p><strong>tips：</strong>引用对象是全局变量或静态变量或是存于堆空间，就可使用引用返回。</p>\n<p></p>\n<p></p>\n<hr/>\n<p></p>\n<p></p>\n<h1 id=\"%F0%9F%8D%8A%E4%BC%A0%E5%80%BC%E8%BF%94%E5%9B%9E%E4%B8%8E%E4%BC%A0%E5%BC%95%E7%94%A8%E8%BF%94%E5%9B%9E%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9\">🍊传值返回与传引用返回的优缺点</h1>\n<p></p>\n<p></p>\n<p><strong>传值返回的优缺点</strong></p>\n<p></p>\n<p></p>\n<blockquote>\n<p><strong>优点：安全、稳定，应用范围广</strong></p>\n<p><strong>缺点：需要进行一次临时拷贝，效率低、速度慢</strong></p>\n</blockquote>\n<p></p>\n<p></p>\n<p><strong>传引用返回的优缺点</strong></p>\n<p>   </p>\n<p></p>\n<blockquote>\n<p><strong>优点：不用临时拷贝，直接返回别名、对别名的修改可以直接影响实体、高效</strong></p>\n<p><strong>缺点：要满足使用条件，才可使用（出作用域不被销毁）</strong></p>\n</blockquote>\n<p></p>\n<p></p>\n<hr/>\n<h1></h1>\n<p></p>\n<h1 id=\"%F0%9F%8D%8A%E5%B8%B8%E5%BC%95%E7%94%A8\">🍊常引用</h1>\n<p></p>\n<p></p>\n<p>常引用的意义：<strong>const对引用进行修饰，限制权限。</strong></p>\n<p></p>\n<p></p>\n<hr/>\n<h2></h2>\n<h2 id=\"%F0%9F%8D%8A%E6%9D%83%E9%99%90%E8%A7%84%E5%88%99\">🍊权限规则</h2>\n<p></p>\n<p><strong>1.权限无法被放大</strong></p>\n<p></p>\n<p></p>\n<pre><code class=\"language-cpp\">int main()\n{\n       const int val = 6;//val由const修饰，只可读，不可写\n       int&amp; num = val;//num是变量val的别名，权限发生改变：可读可写。错误！权限被放大\n       return 0;\n}</code></pre>\n<p></p>\n<p></p>\n<p><img alt=\"9a0087a639cf4fefbbeda39439d7aed9.png\" src=\"image\\9a0087a639cf4fefbbeda39439d7aed9.png\"/></p>\n<p></p>\n<p></p>\n<p><strong>2.权限可以平移</strong></p>\n<p></p>\n<p></p>\n<pre><code class=\"language-cpp\">int main()\n{\n       const int val = 6;//权限：可读，不可写\n       const int&amp; num = val;//权限：可读，不可写。正确，权限平移\n       return 0;\n}</code></pre>\n<p></p>\n<p></p>\n<p><strong>3.权限可以被缩小</strong></p>\n<p></p>\n<p></p>\n<pre><code class=\"language-cpp\">int main()\n{\n       int val = 6;//权限：可读，可写\n       const int&amp; num = val;//权限：可读，不可写。正确，权限缩小\n       return 0;\n}</code></pre>\n<p></p>\n<hr/>\n<h2></h2>\n<h2></h2>\n<h2 id=\"%F0%9F%8D%8A%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2\">🍊隐式类型转换</h2>\n<p></p>\n<p></p>\n<p>隐式类型转换的意义：不同类型间的转换，通常情况下，<strong>小类型会隐式转换成大类型</strong>。</p>\n<p></p>\n<p></p>\n<pre><code class=\"language-cpp\">int main()\n{\n       int a = 6;\n       double b = a;\n       //整形变量会向双精度浮点值进行转换，形成一个临时变量进行提升，不会对本体进行改变\n       return 0;\n}</code></pre>\n<p></p>\n<p></p>\n<p>tips：不同类型间的运算或赋值，变量会进行隐式转换。小类型会向大类型进行提升、截断。</p>\n<p></p>\n<p></p>\n<blockquote>\n<p>这一过程是在临时变量上进行实现，因为小类型本身的体量过小，没有办法在本体进行提升，所以本体不会发生改变，但也不会被使用，使用的是提升后的那份临时变量。</p>\n</blockquote>\n<p></p>\n<p></p>\n<p><strong>附：为什么没有发生权限问题？</strong></p>\n<p></p>\n<p></p>\n<blockquote>\n<p>因为在类型转化中将整形a提升为双精度浮点值后，虽然临时变量具有常性，但表达式本身也只是赋值功能，将临时变量赋值给b，并没有发生权限的改变。</p>\n<p></p>\n<p>因为权限规则只对指针和引用有效。</p>\n</blockquote>\n<p></p>\n<p></p>\n<pre><code class=\"language-cpp\">int main()\n{\n       int a = 6;\n       double&amp; b = a;//定义整形a为双精度浮点值b的引用对象，错误！\n       //整形变量会向双精度浮点值进行转换，在临时变量中进行二进制的提升，所以此时临时变量具有常性，权限不能被扩大。错误！\n       return 0;\n}</code></pre>\n<p></p>\n<p><img alt=\"35f21a6955db459ca223e100797b618f.png\" src=\"image\\35f21a6955db459ca223e100797b618f.png\"/></p>\n<p></p>\n<p></p>\n<p>tips：进行隐式类型转换后，临时变量具有常性，所以不能够成为b的引用对象，因为如此的话，具有常性的临时变量权限将受到放大，这是不符合规则的。</p>\n<p></p>\n<p>若要正确的对其进行引用，应该加上const修饰别名，起到权限平移的功能。</p>\n<p></p>\n<pre><code class=\"language-cpp\">       const double&amp; b = a;</code></pre>\n<p></p>\n<p>附：引用的作用在于形成别名，并且对别名具有可访问、可操作的功能，所以会引发类型转化后的权限问题。所以今后在函数参数接收上或具有类型转换的表达式中，最好使用const修饰，提高接收度。</p>\n<p></p>\n<p></p>\n<hr/>\n<h1></h1>\n<h1></h1>\n<h1 id=\"%F0%9F%8D%8A%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB\">🍊指针与引用的区别</h1>\n<p></p>\n<blockquote>\n<p><strong>1.在定义时，引用必须初始化，而指针不要求必须初始化</strong></p>\n<p></p>\n<pre><code class=\"language-cpp\">int main()\n{\n       int&amp; pre;//error:未初始化引用\n       int* ret;\n       return 0;\n}</code></pre>\n<p></p>\n<p><img alt=\"383c2d6c91b44e44a5ba2bfd2b8dfdf2.png\" src=\"image\\383c2d6c91b44e44a5ba2bfd2b8dfdf2.png\"/></p>\n<p></p>\n<p></p>\n<p><strong>2.没有空引用，但有空指针</strong></p>\n<p></p>\n<pre><code class=\"language-cpp\">int main()\n{\n       int&amp; pre = nullptr;//不存在对空的引用\n       int* ret = nullptr;\n       return 0;\n}</code></pre>\n<p></p>\n<p><img alt=\"38f7ef59137248888c7463f488b4a34e.png\" src=\"image\\38f7ef59137248888c7463f488b4a34e.png\"/></p>\n<p></p>\n<p><strong>3.引用在初始化阶段引用一个实体后，就不能再引用其他实体。而指针可以在任何情况下改变指向。（同类型实体）</strong></p>\n<p></p>\n<p>引用举例</p>\n<p></p>\n<pre><code class=\"language-cpp\">using namespace std;\nint main()\n{\n       int num_1 = 5;\n       int num_2 = 10;\n       int&amp; pre = num_1;\n       pre = num_2;\n       cout &lt;&lt; \"pre别名的值:\" &lt;&lt; pre &lt;&lt; \" \" &lt;&lt; \"pre引用对象地址：\" &lt;&lt; &amp;pre &lt;&lt; endl;\n       cout &lt;&lt; \"num_1的地址\" &lt;&lt; &amp;num_1 &lt;&lt; endl;\n       cout &lt;&lt; \"num_2的地址\" &lt;&lt; &amp;num_2 &lt;&lt; endl;\n       return 0;\n}</code></pre>\n<p></p>\n<p><img alt=\"3be9d4aea32e4de8a4e47ec644828592.png\" src=\"image\\3be9d4aea32e4de8a4e47ec644828592.png\"/></p>\n<p></p>\n<p>tips：初始化时别名的引用对象为num_1，尽管后面又被“貌似”的引用num_2,但其只是赋值操作。究其根本就是，别名的赋值操作改变了num_1的值，但并不能改变别名的引用对象。</p>\n<p></p>\n<p>指针举例</p>\n<p></p>\n<pre><code class=\"language-cpp\">int main()\n{\n       int num_1 = 10;\n       int num_2 = 20;\n       cout &lt;&lt; \"num_1：\" &lt;&lt; &amp;num_1 &lt;&lt; \"  \" &lt;&lt; \"num_2：\" &lt;&lt; &amp;num_2 &lt;&lt; endl;\n       int* pre = &amp;num_1;\n       cout &lt;&lt; \"pre初始化指向的实体地址：\" &lt;&lt; \" \" &lt;&lt; pre &lt;&lt; endl;\n       pre = &amp;num_2;\n       cout &lt;&lt; \"pre改变指向的实体地址：\" &lt;&lt; \"   \" &lt;&lt; pre &lt;&lt; endl;\n       return 0;\n}</code></pre>\n<p></p>\n<p><img alt=\"d40332b01b934639a51c414bf59174c4.png\" src=\"image\\d40332b01b934639a51c414bf59174c4.png\"/></p>\n<p></p>\n<p>tips:指针确实可以任意修改指向，而引用则不可以随意改变实体。</p>\n<p></p>\n<p><strong>4.在sizeof操作符中的含义不同，引用的大小取决于引用对象的类型大小，指针的大小取决于系统环境，32位平台下指针大小为：4字节，64位平台下指针大小为：8字节。</strong></p>\n<p></p>\n<pre><code class=\"language-cpp\">int main()\n{\n       short num = 2;\n       short&amp; pre = num;//引用的大小取决于引用对象的类型大小\n       short* p = &amp;num;//指针的大小取决于环境\n       cout &lt;&lt; \"pre:\" &lt;&lt; sizeof(pre) &lt;&lt; \"  \" &lt;&lt; \"p：\" &lt;&lt; sizeof(p) &lt;&lt; endl;\n       return 0;\n}</code></pre>\n<p></p>\n<p><img alt=\"afa9e2bc017c4150a2c94077e6370ae7.png\" src=\"image\\afa9e2bc017c4150a2c94077e6370ae7.png\"/></p>\n<p></p>\n<p><strong>5.引用进行自加的效果会让引用对象的值增加1，指针的自加会让指针向后偏移一个类型大小。</strong></p>\n<p></p>\n<pre><code class=\"language-cpp\">int main()\n{\n       int num = 5;\n       int&amp; pre = num;\n       int* p = &amp;num;\n       cout &lt;&lt; \"pre:\" &lt;&lt; ++pre &lt;&lt; \"  \" &lt;&lt; \"p:\" &lt;&lt; ++p &lt;&lt; endl;\n       //pre++表示引用对象值自加1，指针自加则表示向后访问一个自身类型大小的地址\n       return 0;\n}</code></pre>\n<p></p>\n<p><img alt=\"68a69bd28f1143849e51b85194f82958.png\" src=\"image\\68a69bd28f1143849e51b85194f82958.png\"/></p>\n<p></p>\n<p><strong>6.有多级指针，但没有多级引用。</strong></p>\n<p></p>\n<pre><code class=\"language-cpp\">int main()\n{\n       int num = 5;\n       int* p = &amp;num;\n       int** pp = &amp;p;//有多级指针\n       int&amp; pre = num;\n       int&amp; ppre = pre;//不能形成多级引用，在这只表示：给别名取一个别名\n       return 0;\n}</code></pre>\n<p></p>\n<p><strong>7.访问方式不同：指针需要显式的解引用访问，引用则可以直接使用别名访问。（编译器自己处理）</strong></p>\n<p></p>\n<pre><code class=\"language-cpp\">int main()\n{\n       int num = 2;\n       int&amp; pre = num;\n       int* p = &amp;num;\n       cout &lt;&lt; \"pre:\" &lt;&lt; pre &lt;&lt; \"  \" &lt;&lt; \"p:\" &lt;&lt; *p &lt;&lt; endl;\n       //引用可直接使用别名访问实体对象，指针必须使用解引用才可访问实体对象\n       return 0;\n}</code></pre>\n<p></p>\n<p><img alt=\"121366004d484b2a88302c425247649f.png\" src=\"image\\121366004d484b2a88302c425247649f.png\"/></p>\n<p></p>\n<p><strong>8.引用的使用比指针要安全。</strong></p>\n</blockquote>\n<p></p>\n<p></p>\n<hr/>\n<h1></h1>\n<h1 id=\"%F0%9F%8D%8A%E5%BC%95%E7%94%A8%E4%B8%8E%E6%8C%87%E9%92%88%E5%BA%95%E5%B1%82%E5%88%A8%E6%9E%90\">🍊引用与指针底层刨析</h1>\n<p></p>\n<p>从语法角度来看，引用自身是不开辟空间，是与引用对象共用一块空间。但在底层，引用的实现却并不是如此。</p>\n<p></p>\n<p><strong>先说结论：引用的实现需要开辟空间，并且底层是依靠指针实现，之所以使用方法不同，在于等于引用进行了封装。</strong></p>\n<p></p>\n<hr/>\n<h2></h2>\n<h2 id=\"%F0%9F%8D%8A%E5%BA%95%E5%B1%82%E5%88%A8%E6%9E%90\">🍊底层刨析</h2>\n<p></p>\n<p><strong>代码：</strong></p>\n<pre><code class=\"language-cpp\">int main()\n{\n       int num = 20;\n       int&amp; pre = num;\n       pre = 30;\n       int* p = &amp;num;\n       *p = 40;\n       return 0;\n}</code></pre>\n<p></p>\n<p><strong>汇编：</strong></p>\n<p></p>\n<pre><code class=\"language-cpp\">       int num = 20;\n005F1FDF  mov         dword ptr [num],14h \n       int&amp; pre = num;\n005F1FE6  lea         eax,[num] \n005F1FE9  mov         dword ptr [pre],eax \n       pre = 30;\n005F1FEC  mov         eax,dword ptr [pre] \n005F1FEF  mov         dword ptr [eax],1Eh \n       int* p = &amp;num;\n005F1FF5  lea         eax,[num] \n005F1FF8  mov         dword ptr [p],eax \n       *p = 40;\n005F1FFB  mov         eax,dword ptr [p] \n005F1FFE  mov         dword ptr [eax],28h</code></pre>\n<p></p>\n<hr/>\n<h3></h3>\n<h3 id=\"%F0%9F%8D%8A%E6%B1%87%E7%BC%96%E8%A7%A3%E8%AF%BB\">🍊汇编解读</h3>\n<p></p>\n<blockquote>\n<pre><code class=\"language-cpp\">       int num = 20;\n005F1FDF  mov         dword ptr [num],14h </code></pre>\n<p></p>\n<p>首先创建一个四个字节的空间用于存储整形。dword表示：d指的是double（双倍），word表示两个字节，共四个字节，num是变量名，将八进制的20存进变量中。（mov）代表移动。</p>\n</blockquote>\n<p></p>\n<hr/>\n<p></p>\n<h3 id=\"%F0%9F%8D%8A%E5%BC%95%E7%94%A8%E5%AE%9E%E7%8E%B0%E9%83%A8%E5%88%86\">🍊引用实现部分</h3>\n<p></p>\n<blockquote>\n<pre><code class=\"language-cpp\">       int&amp; pre = num;\n005F1FE6  lea         eax,[num] </code></pre>\n<p></p>\n<p>将num的地址存入到寄存器eax中。</p>\n<p></p>\n<p>lea表示：装入有效地址，操作数必须为地址。</p>\n<p></p>\n<p></p>\n<pre><code class=\"language-cpp\">005F1FE9  mov         dword ptr [pre],eax </code></pre>\n<p></p>\n<p>将寄存器eax中的值移动到pre中。</p>\n<pre><code class=\"language-cpp\">       pre = 30;\n005F1FEC  mov         eax,dword ptr [pre] </code></pre>\n<p></p>\n<p>将pre的值移动至寄存器eax中。</p>\n<p></p>\n<pre><code class=\"language-cpp\">005F1FEF  mov         dword ptr [eax],1Eh </code></pre>\n<p></p>\n<p>将八进制的30移动到存放pre值的寄存器eax中，相当于赋值操作。</p>\n<p></p>\n</blockquote>\n<p></p>\n<p><strong>小结：从汇编代码中，可以证实使用引用是必须开辟空间的。</strong></p>\n<p></p>\n<hr/>\n<p></p>\n<p></p>\n<h3 id=\"%F0%9F%8D%8A%E6%8C%87%E9%92%88%E5%AE%9E%E7%8E%B0%E9%83%A8%E5%88%86\">🍊指针实现部分</h3>\n<p></p>\n<blockquote>\n<pre><code class=\"language-cpp\">       int* p = &amp;num;\n005F1FF5  lea         eax,[num] </code></pre>\n<p></p>\n<p>将变量num的地址存进寄存器eax中。</p>\n<p></p>\n<p></p>\n<pre><code class=\"language-cpp\">005F1FF8  mov         dword ptr [p],eax </code></pre>\n<p></p>\n<p>开辟一个四个字节的指针，将寄存器eax的值存进整形指针p中。</p>\n<pre><code class=\"language-cpp\">       *p = 40;\n005F1FFB  mov         eax,dword ptr [p] </code></pre>\n<p></p>\n<p>将p的值移动到寄存器eax中。</p>\n<p></p>\n<pre><code class=\"language-cpp\">005F1FFE  mov         dword ptr [eax],28h</code></pre>\n<p></p>\n<p>将八进制的40赋值给eax。</p>\n<p></p>\n<p><strong>小结：指针与引用的底层实现相同！</strong></p>\n<p></p>\n</blockquote>\n<p></p>\n<p></p>\n<hr/>\n<p></p>\n<p><strong>附：指针与引用的相似处</strong></p>\n<p></p>\n<p>都可以用作函数参数或返回值（输出型参数、输出型返回值）。</p>\n<p></p>\n<p><strong>tips：</strong>引用的不可多级引用是其的缺点，体现在单链表的实现，不可以使用引用，指针更有优势。</p>\n<p></p>\n<p>小结：指针更为复杂，功能更为强大，可适用的场景更广，但也更为的危险。引用更加的便捷与安全，但适用性还是比指针要狭小一些。</p>\n<p></p>\n<hr/>\n<p></p>\n<blockquote>\n<p style=\"text-align:center;\"><strong>文章到这就结束啦！如果喜欢就关注Duoni叭！</strong></p>\n</blockquote>\n<p></p>\n</div>\n</div>"}