{"blogid": "122149197", "writerAge": "码龄2年", "writerBlogNum": "64", "writerCollect": "3386", "writerComment": "127", "writerFan": "8228", "writerGrade": "4级", "writerIntegral": "1531", "writerName": "有两把刷子", "writerProfileAdress": "writer_image\\profile_122149197.jpg", "writerRankTotal": "10931", "writerRankWeekly": "831", "writerThumb": "649", "writerVisitNum": "238319", "blog_read_count": "149324", "blog_time": "已于 2022-07-03 11:25:53 修改", "blog_title": "2022年最新前端面试题（大前端时代来临卷起来吧小伙子们..持续维护走到哪记到哪）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h1>目录</h1>\n<p></p>\n<p><a class=\"link-info\" href=\"https://blog.csdn.net/qq_54753561/article/details/124240903?spm=1001.2014.3001.5502\" title=\"css经典高频面试题\">css经典高频面试题</a></p>\n<p><a class=\"link-info\" href=\"https://blog.csdn.net/qq_54753561/article/details/124219121?spm=1001.2014.3001.5502\" title=\"前端核心手写面试题看你的核心扎实不扎实\">前端核心手写面试题看你的核心扎实不扎实</a></p>\n<p></p>\n<h1 id=\"js%E9%83%A8%E5%88%86%E9%9D%A2%E8%AF%95%E9%A2%98\">js部分面试题</h1>\n<hr/>\n<h2>js的数据类型（关于数据类型相关的）</h2>\n<p><strong>基本数据类型</strong></p>\n<blockquote>\n<p>ES5的5种：<strong><span style=\"color:#fe2c24;\">Null，undefined，Boolean，Number，String， ES6新增：Symbol表示独一无二的值 ES10新增：BigInt 表示任意大的整数</span></strong></p>\n</blockquote>\n<p><strong>一种引用数据类型</strong>：（本质上是由一组无序的键值对组成）</p>\n<blockquote>\n<p><strong>引用数据类型</strong>: <span style=\"color:#fe2c24;\"><strong>Object</strong></span>。包含Object、Array、 function、Date、RegExp。 JavaScript不支持创建任何自定义类型的数据，也就是说JavaScript中所有值的类型都是上面8中之一。</p>\n</blockquote>\n<h3>null 和 undefined 的区别？</h3>\n<blockquote>\n<p><strong>相同：</strong></p>\n<p>在 if 语句中 null 和 undefined 都会转为false两者用相等运算符比较也是相等</p>\n<p><strong>首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。</strong></p>\n<p><strong>不同：</strong></p>\n<p><strong>undefined 代表的含义是未定义，</strong></p>\n<p>定义了形参，没有传实参，显示undefined</p>\n<p>一般变量声明了但还没有定义的时候会返回 undefined</p>\n<p>对象属性名不存在时，显示undefined</p>\n<p>函数没有写返回值，即没有写return，拿到的是undefined</p>\n<p><strong>null 代表的含义是空对象。也作为对象原型链的终点</strong></p>\n<p>null 主要用于赋值给一些可能会返回对象的变量，作为初始化。</p>\n</blockquote>\n<p></p>\n<h3>ES10新增：BigInt 表示任意大的整数</h3>\n<blockquote>\n<p><strong><code>BigInt</code>数据类型的目的是比<code>Number</code>数据类型支持的范围更大的整数值。在对大整数执行数学运算时，以任意精度表示整数的能力尤为重要。使用<code>BigInt</code>，整数溢出将不再是问题。</strong></p>\n<p>此外，可以安全地使用更加准确时间戳，大整数ID等，而无需使用变通方法。 BigInt目前是第3阶段提案， 一旦添加到规范中，它就是JS 第二个数字数据类型，也将是 JS 第8种基本数据类型：</p>\n</blockquote>\n<pre><code class=\"language-javascript\">要创建BigInt，只需在整数的末尾追加n即可。比较:\nconsole.log(9007199254740995n);    // → 9007199254740995n\nconsole.log(9007199254740995);     // → 9007199254740996\n​\n或者，可以调用BigInt()构造函数\nBigInt(\"9007199254740995\");    // → 9007199254740995n\n​\n// 注意最后一位的数字\n9007199254740992 === 9007199254740993;    // → true\nconsole.log(9999999999999999);    // → 10000000000000000</code></pre>\n<p></p>\n<h3>数据类型存储以及堆栈内存是什么</h3>\n<blockquote>\n<p><strong>基本数据类型</strong>：<strong>直接存储在栈内存中，占据空间小，大小固定，属于被频繁使用的数据</strong>。指的是保存在<strong>栈</strong>内存中的简单数据段；number string 布尔</p>\n<p>引用数据类型：同时存储在栈内存与堆内存中，占据空间大，大小不固定。</p>\n<p><strong>引用数据：类型将指针存在栈中，将值存在堆中。 当我们把对象值赋值给另外一个变量时，复制的是对象的指针，指向同一块内存地址，</strong>意思是，变量中保存的实际上只是一个指针，这个指针指向内存堆中实际的值，数组 对象</p>\n</blockquote>\n<h3>堆(<strong>heap</strong>)和栈(<strong>stack</strong>)有什么区别存储机制</h3>\n<blockquote>\n<p>栈： <strong>是一种连续储存的数据结构，具有先进后出后进先出的性质</strong>。</p>\n<p>通常的操作有入栈（压栈），出栈和栈顶元素。想要读取栈中的某个元素，就是将其之间的所有元素出栈才能完成。</p>\n<p>堆：  <strong>是一种非连续的树形储存数据结构，具有队列优先,先进先出</strong>； 每个节点有一个值，整棵树是经过排序的。特点是根结点的值最小（或最大），且根结点的两个子树也是一个堆。常用来实现优先队列，存取随意。</p>\n</blockquote>\n<p></p>\n<h2>js数据类型判断，条件分支</h2>\n<h3><strong>if语句和逻辑运算</strong></h3>\n<blockquote>\n<p>所有基本类型中Boolean值是false的只有6个，分别是 : 0 NaN ' ' null undefined false 引用类型Boolean值全是true.</p>\n<p>if条件是单个值时，如果是truly值，条件成立， 如果是falsely值，条件不成立</p>\n</blockquote>\n<h3>逻辑运算符以及他们的运算规则?</h3>\n<pre><code class=\"language-javascript\">        &amp;&amp; 逻辑与    两边都是true，才返回true，否则返回false\n        || 逻辑或    两边只要有一个是true，就返回true，否则返回false\n        ！ 逻辑非   用来取一个布尔值相反的值  </code></pre>\n<h3>数据类型判断</h3>\n<pre><code class=\"language-javascript\">typeof 对于基本数据类型判断是没有问题的，但是遇到引用数据类型（如：Array）是不起作用\nconsole.log(typeof 2);    // number\nconsole.log(typeof null); // object\n`instanceof` 只能正确判断引用数据类型  而不能判断基本数据类型，其内部运行机制是判断在其原型链中能否找到该类型的原型\nconsole.log([] instanceof Array);                    // true\nconsole.log(function(){} instanceof Function);       // true\nconsole.log({} instanceof Object);                   // true\nconstructor 似乎完全可以应对基本数据类型和引用数据类型 但如果声明了一个构造函数，并且把他的原型指向了 Array 的原型，所以这种情况下，constructor 也显得力不从心\nconsole.log((true).constructor === Boolean); // true\nconsole.log(('str').constructor === String); // true\nconsole.log(([]).constructor === Array); // true\nconsole.log((function() {}).constructor === Function); // true\nconsole.log(({}).constructor === Object); // true\nconsole.log((2).constructor === Number); // true\nObject.prototype.toString.call() 完美的解决方案，可以通过toString() 来获取每个对象的类型，\n​\n`Object.prototype.toString.call()` 使用 Object 对象的原型方法 toString 来判断数据类型：\n​\nvar a = Object.prototype.toString;\n \nconsole.log(a.call(2));\nconsole.log(a.call(true));\nconsole.log(a.call('str'));\nconsole.log(a.call([]));\nconsole.log(a.call(function(){}));\nconsole.log(a.call({}));\nconsole.log(a.call(undefined));\nconsole.log(a.call(null));\n补充：基本数据类型赋值的时候  赋的是具体的值   引用数据类型传的是地址，一个变另一个跟着变</code></pre>\n<p></p>\n<h3>js数据类型转换</h3>\n<blockquote>\n<p>在JavaScript中类型转换有三种情况：</p>\n<p><strong>转换为数字（调用Number(),parseInt(),parseFloat()方法） </strong></p>\n<p><strong>转换为字符串（调用.toString()或String()方法） </strong></p>\n<p><strong>转换为布尔值（调用Boolean()方法） 还有隐式转换 注意：null、undefined没有.toString方法</strong></p>\n</blockquote>\n<pre><code class=\"language-javascript\">​\n转换为数字\nNumber()：可以把任意值转换成数字，如果要转换的字符串中有不是数字的值，则会返回NaN\n​\nNumber('1')   // 1\nNumber(true)  // 1\nNumber('123s') // NaN\nNumber({})  //NaN\n​\n​\nparseInt(string,radix)：解析一个字符串并返回指定基数的十进制整数，radix是2-36之间的整数，表示被解析字符串的基数。\nparseInt('2') //2\nparseInt('2',10) // 2\nparseInt('2',2)  // NaN\nparseInt('a123')  // NaN  如果第一个字符不是数字或者符号就返回NaN\nparseInt('123a')  // 123\n​\n​\nparseFloat(string)：解析一个参数并返回一个浮点数\n​\nparseFloat('123a')\n//123\nparseFloat('123a.01')\n//123\nparseFloat('123.01')\n//123.01\nparseFloat('123.01.1')\n//123.01\n​\n隐式转换\nlet str = '123'\nlet res = str - 1 //122\nstr+1 // '1231'\n+str+1 // 124\n​\n转换为字符串\n.toString()  ⚠️注意：null,undefined不能调用\n​\nNumber(123).toString()\n//'123'\n[].toString()\n//''\ntrue.toString()\n//'true'\n​\n​\nString() 都能转\nString(123)\n//'123'\nString(true)\n//'true'\nString([])\n//''\nString(null)\n//'null'\nString(undefined)\n//'undefined'\nString({})\n//'[object Object]'\n​\n​\n隐式转换：当+两边有一个是字符串，另一个是其它类型时，会先把其它类型转换为字符串再进行字符串拼接，返回字符串\n​\nlet a = 1\na+'' // '1'\n转换为布尔值\n0, ''(空字符串), null, undefined, NaN会转成false，其它都是true\nBoolean()\nBoolean('') //false\nBoolean(0) //false\nBoolean(1) //true\nBoolean(null) //false\nBoolean(undefined) //false\nBoolean(NaN) //false\nBoolean({}) //true\nBoolean([]) //true\n​\n条件语句\n​\nlet a\nif(a) {\n  //...   //这里a为undefined，会转为false，所以该条件语句内部不会执行\n}\n​\n隐式转换 !!\n​\nlet str = '111'\nconsole.log(!!str) // true\n\n\n{}和[]的valueOf和toString的返回结果？\nvalueOf：返回指定对象的原始值\n​\n对象                  返回值 \nArray               返回数组对象本身。\nBoolean             布尔值。\nDate                存储的时间是从 1970 年 1 月 1 日午夜开始计的毫秒数 UTC。\nFunction            函数本身。\nNumber              数字值。\nObject              对象本身。这是默认情况。\nString              字符串值。\n                    Math 和 Error 对象没有 valueOf 方法。\n​\ntoString：返回一个表示对象的字符串。默认情况下，toString() 方法被每个 Object 对象继承。如果此方法在自定义对象中未被覆盖，\ntoString() 返回 \"[object type]\"，其中 type 是对象的类型。\n​\n({}).valueOf()   //{}\n({}).toString()  //'[object Object]'\n[].valueOf()    //[]\n[].toString()   //''\n​</code></pre>\n<p></p>\n<h3>数据类型相比较objected .is ==和===</h3>\n<blockquote>\n<p>=== 属于<span style=\"color:#fe2c24;\"><strong>严格判断</strong>，<strong>直接判断两者类型是否相同，如果两边的类型不一致时，不会做强制类型准换</strong></span>，不同则返回false如果相同再比较大小，<span style=\"color:#fe2c24;\"><strong>不会进行任何隐式转换对于引用类型来说，比较的都是引用内存地址</strong></span>，所以===这种方式的比较，除非两者存储的内存地址相同才相等，反之false</p>\n<p>== 二等表示值相等。<span style=\"color:#fe2c24;\"><strong>判断操作符两边对象或值是否相等类型可以不同，如果两边的类型不一致，则会进行强制类型转化后再进行比较</strong></span>，使用Number()转换成Number类型在进行判断。例外规则，null==undefined，null/undefined进行运算时不进行隐式类型转换。通常把值转为Boolean值，进行条件判断。Boolean(null)===Boolean(undefined)&gt;false===false 结果为true</p>\n<p><strong>Object.is()在===基础上特别处理了NaN,-0,+0,保证-0与+0不相等，但NaN与NaN相等</strong></p>\n</blockquote>\n<pre><code class=\"language-javascript\">==操作符的强制类型转换规则\n​\n字符串和数字之间的相等比较，将字符串转换为数字之后再进行比较。\n其他类型和布尔类型之间的相等比较，先将布尔值转换为数字后，再应用其他规则进行比较。\nnull 和 undefined 之间的相等比较，结果为真。其他值和它们进行比较都返回假值。\n对象和非对象之间的相等比较，对象先调用 ToPrimitive 抽象操作后，再进行比较。\n如果一个操作值为 NaN ，则相等比较返回 false（ NaN 本身也不等于 NaN ）。\n如果两个操作值都是对象，则比较它们是不是指向同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回true，否则，返回 false。\n​\n    '1' == 1 // true\n    '1' === 1 // false\n    NaN == NaN //false\n    +0 == -0 //true\n    +0 === -0 // true\n    Object.is(+0,-0) //false\n    Object.is(NaN,NaN) //true</code></pre>\n<h3>typeof null 的结果是什么，为什么？</h3>\n<blockquote>\n<p>typeof null 的结果是Object。</p>\n<p><strong>在 JavaScript 第一个版本中，所有值都存储在 32 位的单元中，每个单元包含一个小的 类型标签(1-3 bits)</strong> 以及当前要存储值的真实数据。类型标签存储在每个单元的低位中，共有五种数据类型：</p>\n</blockquote>\n<pre><code class=\"language-javascript\">000: object   - 当前存储的数据指向一个对象。\n  1: int      - 当前存储的数据是一个 31 位的有符号整数。\n010: double   - 当前存储的数据指向一个双精度的浮点数。\n100: string   - 当前存储的数据指向一个字符串。\n110: boolean  - 当前存储的数据是布尔值。</code></pre>\n<blockquote>\n<p>有两种特殊数据类型：</p>\n<ul><li> <p>undefined的值是 (-2)30(一个超出整数范围的数字)；</p> </li><li> <p>null 的值是机器码 NULL 指针(null 指针的值全是 0)</p> </li></ul>\n<p>那也就是说null的类型标签也是000，和Object的类型标签一样，所以会被判定为Object。</p>\n</blockquote>\n<p></p>\n<h2>事件的故事</h2>\n<h3><strong>什么是事件？</strong></h3>\n<blockquote>\n<p><strong>事件是文档和浏览器窗口中发生的特定的交互瞬间，事件就发生了。</strong></p>\n<p>一是直接在标签内直接添加执行语句，</p>\n<p>二是定义执行函数。</p>\n<p>addeventlistener 监听事件</p>\n<p></p>\n<p>事件类型分两种：事件捕获、事件冒泡。</p>\n<p><strong>事件捕获</strong>就是：网景公司提出的事件流叫事件捕获流，由外往内，从事件发生的顶点开始，逐级往下查找，一直到目标元素。</p>\n<p><strong>事件冒泡</strong>：IE提出的事件流叫做事件冒泡就是由内往外，从具体的目标节点元素触发，逐级向上传递，直到根节点。</p>\n<p></p>\n<p>什么是事件流?</p>\n<p><strong>事件流就是，页面接受事件的先后顺序就形成了事件流。</strong></p>\n<p></p>\n<p><strong>自定义事件</strong></p>\n<p>自定义事件，就是自己定义事件类型，自己定义事件处理函数。</p>\n</blockquote>\n<h3>事件委托</h3>\n<blockquote>\n<p><strong>事件委托，</strong>又名事件代理。事件委托就是利用事件冒泡，就是把子元素的事件都绑定到父元素上。如果子元素阻止了事件冒泡，那么委托也就没法实现了</p>\n<p>阻止事件冒泡</p>\n<p>event.stopPropagation() .stop修饰符</p>\n<p>addEventListener(‘click',函数名,true/false) 默认值为false（即 使用事件冒泡）true 事件捕获</p>\n<p>好处：提高性能，减少了事件绑定，从而减少内存占用</p>\n<p><strong>应用场景 在vue中事件委托：</strong></p>\n<p>我们经常遇到vue中v-for一个列表，列表的每一项都绑定了@click处理事件。我们都知道绑定这么多监听，从性能方面来说是不太好的。那我们我们可以通过把每个item的click事件委托给父元素的形式来实现</p>\n</blockquote>\n<h3>封装事件绑定</h3>\n<blockquote>\n<p>我们在封装这个函数的时候可以用addEventListener(事件监听)来实现 ，封装的函数有三个参数，第一个是要绑定事件的元素，第二个是要绑定的事件类型，第三个是事件的执行函数。 调用这个函数 就可以实现给某个元素绑定一个事件了。</p>\n</blockquote>\n<p></p>\n<h3>Javascript 的作用域和作用域链</h3>\n<blockquote>\n<p><strong>作用域：</strong> <strong><span style=\"color:#fe2c24;\">作用域是定义变量的区域，它有一套访问变量的规则</span>，这套规则来管理浏览器引擎如何在当前作用域以及嵌套的作用域中根据变量（标识符）进行变量查找。简单说：函数内部局部作用域，函数外面全局作用域。</strong></p>\n</blockquote>\n<blockquote>\n<p><span style=\"color:#fe2c24;\"><strong>作用域就是一个变量可以使用的范围，主要分为全局作用域和函数作用域</strong></span></p>\n<p>全局作用域就是Js中最外层的作用域，在哪里都可以访问</p>\n<p>函数作用域是js通过函数创建的一个独立作用域，只能在函数内部访问，函数可以嵌套，所以作用域也可以嵌套</p>\n<p>Es6中新增了块级作用域（由大括号包裹，比如：if(){},for(){}等）</p>\n</blockquote>\n<h3>防抖节流</h3>\n<blockquote>\n<p>防抖：<span style=\"color:#fe2c24;\"><strong>所谓防抖，就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。</strong></span></p>\n<p>节流：<span style=\"color:#fe2c24;\"><strong>所谓节流，就是指连续触发事件但是在 n 秒中只执行一次函数。两种方式可以实现，分别是时间戳版和定时器版。</strong></span></p>\n</blockquote>\n<h3>鼠标事件 mouseenter与mouseover区别</h3>\n<blockquote>\n<p>mouseenter： 鼠标进入被绑定事件监听元素节点时触发一次，再次触发是鼠标移出被绑定元素，再次进入时。而当鼠标进入被绑定元素节点触发一次后没有移出，即使鼠标动了也不再触发。</p>\n<p>mouseover： 鼠标进入被绑定事件监听元素节点时触发一次，如果目标元素包含子元素，鼠标移出子元素到目标元素上也会触发。</p>\n<p>mouseenter 不支持事件冒泡 mouseover 会冒泡</p>\n</blockquote>\n<p></p>\n<h2>引用数据类型 object</h2>\n<h3>object的方法</h3>\n<pre><code class=\"language-javascript\">Object.is() 是一种判断两个值是否相同的方法。\n语法：Object.is(value1, value2);\n参数：value1：要比较的第一个值。value2：要比较的第二个值。\n返回值：一个布尔表达式，指示两个参数是否具有相同的值。\n\nObject.assign() 方法用于将所有可枚举的自身属性从一个或多个源对象复制到目标对象。\n语法：Object.assign(target, ...sources)\n参数：target：目标对象——应用源属性的对象，修改后返回。sources：源对象——包含你要应用的属性的对象。\n返回值：修改后的目标对象。\n\n\nObject.entries() ES8的Object.entries是把对象转成键值对数组， [key, value] 对的数组。\n语法：Object.entries(obj)\n参数：obj：要返回其自己的可枚举字符串键属性 [key, value] 对的对象。返回值：给定对象自己的可枚举字符串键属性 [key, value] 对的数组。\nObject.fromEntries则相反，是把键值对数组转为对象\n\nObject.values() 方法返回给定对象自己的可枚举属性值的数组，其顺序与 for...in 循环提供的顺序相同。\n语法：Object.values(obj)\n参数：obj：要返回其可枚举自身属性值的对象。返回值：包含给定对象自己的可枚举属性值的数组。\n\nObject.prototype.hasOwnProperty()\nhasOwnProperty() 方法返回一个布尔值，指示对象是否具有指定的属性作为它自己的属性。\n如果指定的属性是对象的直接属性，则该方法返回 true — 即使值为 null 或未定义。如果该属性是继承的或根本没有声明，则返回 false。\n语法：hasOwnProperty(prop)\n参数：prop：要测试的属性的字符串名称或符号。\n返回值：如果对象将指定的属性作为自己的属性，则返回true；否则为false。\n\nObject.keys()\nObject.keys() 方法用于返回给定对象自己的可枚举属性名称的数组，以与普通循环相同的顺序迭代。\n语法：Object.keys(obj)\n参数：obj：要返回可枚举自身属性的对象。\n返回值：表示给定对象的所有可枚举属性的字符串数组。\n\nObject.prototype.toString()\ntoString() 方法返回一个表示对象的字符串。当对象将被表示为文本值或以期望字符串的方式引用对象时，将自动调用此方法 id。默认情况下，toString() 方法由从 Object 继承的每个对象继承。\n语法：toString()\n返回值：表示对象的字符串。\n\nObject.freeze()\nObject.freeze() 方法冻结一个对象，这意味着它不能再被更改。冻结对象可防止向其添加新属性，防止删除现有属性，防止更改现有属性的可枚举性、可配置性或可写性，并防止更改现有属性的值。它还可以防止其原型被更改。\n语法：Object.freeze(obj)\n参数：obj：要冻结的对象。返回值：传递给函数的对象。\n\nObject.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。 （请打开浏览器控制台以查看运行结果。）\n语法：const me = Object.create(person);\n参数：\nproto：新创建对象的原型对象。\npropertiesObject\n可选。需要传入一个对象，该对象的属性类型参照Object.defineProperties()的第二个参数。如果该参数被指定且不为 undefined，该传入对象的自有可枚举属性(即其自身定义的属性，而不是其原型链上的枚举属性)将为新创建的对象添加指定的属性值和对应的属性描述符。\n返回值\n一个新对象，带着指定的原型对象和属性。</code></pre>\n<p></p>\n<h3>对象和面向对象</h3>\n<blockquote>\n<p>对象：属性和方法的集合叫做对象（万物皆对象）。</p>\n<p>面向对象：首先就是找对象，如果该对象不具备所需要的方法或属性，那就给它添加。 面向对象是一种编程思维的改变。通过原型的方式来实现面向对象编程。</p>\n<p>创建对象的方式(4种)：new Object、字面量、构造函数、原型。</p>\n</blockquote>\n<h3></h3>\n<h3>什么是深拷贝，浅拷贝，浅拷贝 赋值的区别，如何实现</h3>\n<blockquote>\n<p><strong>深拷贝和浅拷贝是针对复杂数据类型来说的，浅拷贝只拷贝一层，而深拷贝是层层拷贝。</strong></p>\n<p>1.浅拷贝：</p>\n<ul><li> <p>将原对象或原数组的引用直接赋给新对象，新数组，新对象只是对原对象的一个引用，而不复制对象本身，新旧对象还是共享同一块内存</p> </li><li> <p>如果<strong>属性是一个基本数据类型，拷贝就是基本类型的值</strong>，<strong>如果属性是引用类型，拷贝的就是内存地址,</strong></p> </li></ul>\n<p>2.深拷贝：</p>\n<ul><li> <p>创建一个新的对象和数组，将原对象的各项属性的“值”（数组的所有元素）拷贝过来，是“值”而不是“引用”</p> </li><li> <p><strong>深拷贝就是把一个对象，从内存中完整的拷贝出来，从堆内存中开辟了新区域，用来存新对象，并且修改新对象不会影响原对象</strong></p> </li></ul>\n<p>3、赋值：</p>\n<p>当我们把一个<strong>对象赋值给一个新的变量时，赋的是该对象在栈中的内存地址，而不是堆中的数据。也就是两个对象</strong></p>\n</blockquote>\n<p>具体实现看开头的手写系列</p>\n<pre><code class=\"language-javascript\">浅拷贝的实现方式：\n   1、object.assign()\n   2、lodash 里面的 _.clone \n   3、...扩展运算符\n   4、 Array.prototype.concat \n   5、 Array.prototype.slice\n​\n    深拷贝的实现方式\n    1、 JSON.parse(JSON.stringify())\n    2、递归操作\n    3、cloneDeep\n    4、Jquery.extend()   \n</code></pre>\n<p></p>\n<h2>数组</h2>\n<p></p>\n<h3>数组的方法</h3>\n<pre><code class=\"language-javascript\">1、sort( )：sort 排序 如果下面参数的正反 控制 升序和降序 ，返回的是从新排序的原数组\n2、splice( )：向数组的指定index处插入 返回的是被删除掉的元素的集合，会改变原有数组；截取类 没有参数，返回空数组，原数组不变；一个参数，从该参数表示的索引位开始截取，直至数组结束，返回截取的 数组，原数组改变；两个参数，第一个参数表示开始截取的索引位，第二个参数表示截取的长度，返回截取的 数组，原数组改变；三个或者更多参数，第三个及以后的参数表示要从截取位插入的值。会改变原数据\n3、pop( )：从尾部删除一个元素 返回被删除掉的元素，改变原有数组。\n4、push( )：向数组的末尾追加 返回值是添加数据后数组的新长度，改变原有数组。\n5、unshift( )：向数组的开头添加 返回值是添加数据后数组的新长度，改变原有数组。\n6、shift( )：从头部删除一个元素 返回被删除掉的元素，改变原有数组。\n7、reverse( )： 原数组倒序  它的返回值是倒序之后的原数组\n8、concat( )：数组合并。\n9、slice( )：数组元素的截取，返回一个新数组，新数组是截取的元素，可以为负值。从数组中截取，如果不传参，会返回原数组。如果只传入一个参数，会从头部开始删除，直到数组结束，原数组不会改变；传入两个参数，第一个是开始截取的索引，第二个是结束截取的索引，不包含结束截取的这一项，原数组不会改变。最多可以接受两个参数。\n10、join( )：讲数组进行分割成为字符串  这能分割一层在套一层就分隔不了了\n11、toString( )：数组转字符串；\n12、toLocaleString( )：将数组转换为本地数组。\n13、forEach( )：数组进行遍历；\n14、map( )：没有return时，对数组的遍历。有return时，返回一个新数组，该新数组的元素是经过过滤(逻辑处理)过的函数。\n15、filter( )：对数组中的每一运行给定的函数，会返回满足该函数的项组成的数组。\n16、every( )：当数组中每一个元素在callback上被返回true时就返回true。（注：every其实类似filter，只不过它的功能是判断是不是数组中的所有元素都符合条件，并且返回的是布尔值）。\n17、some( )：当数组中有一个元素在callback上被返回true时就返回true。（注：every其实类似filter，只不过它的功能是判断是不是数组中的所有元素都符合条件，并且返回的是布尔值）。\n18、reduce( )：回调函数中有4个参数。prev（之前计算过的值），next（之前计算过的下一个的值），index，arr。把数组列表计算成一个\n19.isArray() 判断是否是数组\n20. indexOf  找索如果找到了就会返回当前的一个下标，若果没找到就会反回-1\n21. lastIndexOf 它是从最后一个值向前查找的 找索如果找到了就会返回当前的一个下标，若果没找到就会反回-1\n22. Array.of() 填充单个值\n23. Array.from() 来源是类数组    \n24.fill填充方法 可以传入3各参数 可以填充数组里的值也就是替换 如果一个值全部都替换掉 ，    第一个参数就是值 第二个参数 从起始第几个 第三个参数就是最后一个\nfind  查找这一组数 符合条件的第一个数 给他返回出来\nfindIndex() 查找这一组数 符合条件的第一数的下标 给他返回出来     没有返回 -1  \nkeys 属性名  values属性值  entries属性和属性值\nforEach 循环遍历 有3个参数 无法使用 break continue ， 参数一就是每个元素 参数二就是每个下标 参数三就是每个一项包扩下标和元素\n\n \n### 改变数组本身的api\n1. `pop()`  尾部弹出一个元素\n2. `push()` 尾部插入一个元素\n3. `shift()`  头部弹出一个元素\n4. `unshift()`  头部插入一个元素\n5. `sort([func])` 对数组进行排序,func有2各参数，其返回值小于0，那么参数1被排列到参数2之前，反之参数2排在参数1之前\n6. `reverse()` 原位反转数组中的元素\n7. `splice(pos,deleteCount,...item)`  返回修改后的数组，从pos开始删除deleteCount个元素，并在当前位置插入items\n8. `copyWithin(pos[, start[, end]])` 复制从start到end(不包括end)的元素，到pos开始的索引，返回改变后的数组，浅拷贝\n9. `arr.fill(value[, start[, end]])` 从start到end默认到数组最后一个位置，不包括end，填充val，返回填充后的数组\n其他数组api不改变原数组\n\n\n\n\nmap 映射关系的数组  map 主要就是有返回值可以return 数组   判断的会返回boolean \n1、map()方法返回一个新数组，新数组中的元素为原始数组中的每个元素调用函数处理后得到的值。\n2、map()方法按照原始数组元素顺序依次处理元素。\n\n注意：\nmap()不会对空数组进行检测。\nmap()不会改变原始数组。\nmap() 函数的作用是对数组中的每一个元素进行处理，返回新的元素。\nfilter 满足条件的都能返回 是一个数组\nsome返回boolean 循环数组 只要有一个成员通过了就会返回 true 反而 false\nevery返回boolean 循环数组 只有全部成员通过了就会返回 true 反而 false \nreduce() 累加器 把上一次计算的值，给下一次计算进行相加\nset 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用  \ndelete  [1] delete 可以删除数组中的一向\n**Array.isArray()** 用于确定传递的值是否是一个 [`Array`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array)。\nflat  扁平化 将嵌套的数组 “拉平”，变成一维数组。该方法返回一个新数组，对原数据没有影响。// 参数写的就是代表要扁平到第几层\n\n\n\n//1、every()\nvar arr = [1,56,80,5];\nvar main = arr.every(n =&gt; n &gt; 0);\nconsole.log(main)   //输出:true\n\n//2、some()\nvar arr = [1,-56,80,-5];\nvar main = arr.some(n =&gt; n &gt; 0);\nconsole.log(main)    //输出:true\n\n//3、reducer()\nvar arr = [10,20,30,40]\nlet result = arr.reduce(function(prev,next,index,arr){\n\treturn prev + next;\n})\nconsole.log(result);  //输出:100\n\n// 4、filter  返回满足要求的数组项组成的新数组\nvar arr3 = [3,6,7,12,20,64,35]\nvar result3 = arr3.filter((item,index,arr)=&gt;{\n    return item &gt; 3\n})\nconsole.log(result3)  //[6,7,12,20,64,35]\n\n// 5、map  返回每次函数调用的结果组成的数组\nvar arr4 = [1,2]\nvar result4 = arr4.map((item,index,arr)=&gt;{\n    return `&lt;span&gt;${item}&lt;/span&gt;`\n})\nconsole.log(result4)  \n/*[ '&lt;span&gt;1&lt;/span&gt;',\n  '&lt;span&gt;2&lt;/span&gt;', ]*/\n\n\nES6数组的常用方法：\n\n1、Array.from( )：将对象或字符串转成数组，注意得有length。\n2、Array.of( )： 将一组值转换为数组。\n3、copyWithin(target，start(可选)，end(可选))：数组内数据的复制替换\n\ttarget：从该位置开始替换数据；\n\tstart：从该位置开始读取数据，默认为0；\n\tend：到该位置停止数据的读取，默认为数组的长度\n4、find( )：用于找出第一个符合条件的数组成员。\n5、findIndex( )：返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。\n6、fill(value，start，end)：使用给定值，填充一个数组。\n\tvalue：填充的值；\n\tstart：开始填充的位置；\n\tend：填充结束的位置。\n7、keys( )：对键名的遍历。\n8、values( )：对键值的遍历。\n9、entries( )：对键值对的遍历。\n10、includes( )：数组原型的方法,查找一个数值是否在数组中，只能判断一些简单类型的数据，对于复杂类型的数据无法判断。该方法接受两个参数，分别是查询的数据和初始的查询索引值。\n11、flat( )：用于数组扁平，数组去除未定义。可以去除空项。\n12、flatMap( )：对原数组的每个成员执行一个函数。\n13、Map( )：是一组键值对的结构，具有极快的查找速度。\n14、Set( )：Set和Map类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在Set中，没有重复的key。\n\n\n//1、Array.from()  --   Array.of()\n\tvar  arrayLink = {\n\t\t\"0\":\"a\",\n\t\t\"1\":\"b\",\n\t\t\"2\":\"c\",\n\t\tlength:3\n\t}\n\tvar arr = Array.from(arrayLink)\n\tconsole.log(arr)   // 输出: [a,b,c]\n\tconsole.log(Array.from(\"abcdefg\"))  //输出:[\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"]\n\tconsole.log(Array.of(1,2,3,4,5))  //输出: [1, 2, 3, 4, 5]\n\n//2、copyWithin()\n\tvar arr = [1,2,3,4,5];\n\tvar main = arr.copyWithin(0,3);\n\tconsole.log(main);   //输出:[4,5,3,4,5]\n\n//3、find()\n\tvar arr = [1,-5,2,9,-6];\n\tvar main = arr.find(n =&gt;  n &lt; 0);\n\tconsole.log(main);   //输出:-5\n\n//4、fill()\n\tvar arr = [\"a\",\"b\",\"c\",\"d\"];\n\tconsole.log(arr.fill(7,1,2));//输出:[\"a\",7,\"c\",\"d\"]  \n\n//5、keys()  values()  entries()\n\tvar arr = [\"a\",\"b\",\"c\",\"d\"];\n\tfor(let index of arr.keys()){\n\t\tconsole.log(index);\n\t}\n\tfor(let elem of arr.values()){\n\t\tconsole.log(elem);\n\t}\n\tfor(let [index,elem] of arr.entries()){\n\t\tconsole.log(index,elem);\n\t}  \n\n//6、includes()\n\tlet arr = [12,34,223,45,67]\n\tconsole.log(arr.includes(45))   //输出:true\n\t[1, 2, NaN].includes(NaN)     // true\n\t[1, 2, NaN].indexOf(NaN)      // -1\n\n//7、Map\n\tvar m = new Map([['Michael', 95], ['Bob', 75], ['Tracy', 85]]);\n\tm.get('Michael'); // 95\n\t//初始化Map需要一个二维数组，或者直接初始化一个空Map。Map具有以下方法：\n\tvar m = new Map(); // 空Map\n\tm.set('Adam', 67); // 添加新的key-value\n\tm.set('Bob', 59);\n\tm.has('Adam'); // 是否存在key 'Adam': true\n\tm.get('Adam'); // 67\n\tm.delete('Adam'); // 删除key 'Adam'\n\tm.get('Adam'); // undefined\n\t//由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：\n\tvar m = new Map();\n\tm.set('Adam', 67);\n\tm.set('Adam', 88);\n\tm.get('Adam'); // 88\n\n//8、Set\n\t//要创建一个Set，需要提供一个Array作为输入，或者直接创建一个空Set：\n\tvar s1 = new Set(); // 空Set\n\tvar s2 = new Set([1, 2, 3]); // 含1, 2, 3\n\t//重复元素在Set中自动被过滤：\n\tvar s = new Set([1, 2, 3, 3, '3']);\n\ts; // Set {1, 2, 3, \"3\"}  注意：数字3和字符串'3'是不同的元素\n\t//通过add(key)方法可以添加元素到Set中，可以重复添加，但不会有效果：\n\ts.add(4);\n\ts; // Set {1, 2, 3, 4}\n\ts.add(4);\n\ts; // 仍然是 Set {1, 2, 3, 4}\n\t//通过delete(key)方法可以删除元素：\n\tvar s = new Set([1, 2, 3]);\n\ts; // Set {1, 2, 3}\n\ts.delete(3);\n\ts; // Set {1, 2}</code></pre>\n<h3></h3>\n<h3></h3>\n<h2>字符串</h2>\n<h3>字符串的方法</h3>\n<pre><code class=\"language-javascript\">1、chartAt( )：返回在指定位置的字符；\n2、concat( )：返回新的字符串**，将一个或多个字符串与原字符串连接合并\n3、indexOf( )：检索字符串，返回第一次出现的索引，没有出现则为-1\n4、lastIndexOf(searchValue[ fromIndex]) 返回从字符串尾部开始第一次出现的索引，没有则-1，fromIndex的值相对于从尾部开始的索引\n5、split( )：返回一个以指定分隔符出现位置分隔而成的一个数组，数组元素不包含分隔符\n6、substr( )：从起始索引号提取字符串中指定数目的字符；\n7、substring( )：提取字符串中两个指定的索引号之间的字符；\n8、toLowerCase( )：字符串转小写；\n9、toUpperCase( )：字符串转大写；\n10、valueOf( )：返回某个字符串对象的原始值； \n11、trim( )：删除字符串两边的空格；\n12、trimeState 取出开始的空格\n13、trimeEnd  去除末尾空格\n14、includes(searchString[, position])返回boolean，判断一个字符串是否包含在另一个字符串中，从postition索引开始搜寻，默认0\n15、slice( )：提取字符串片段，并在新的字符串中返回被提取的部分；\n16、search(regexp)返回首次匹配到的索引，没有则-1，执行正则表达式和 String 对象之间的一个搜索匹配\n17、toString()返回一个表示调用对象的字符串，该方法返回指定对象的字符串形式\n18、trim()返回去掉两端空白后的新字符串 还有trimend trimstart\n19、replace() 把指定的字符串替换成为别的字符</code></pre>\n<h3><strong>超长字符串存储到栈内存中</strong></h3>\n<blockquote>\n<p><code>字符串</code>属于<code>基础类型</code>，所以会觉得<code>字符串</code>是存在<code>栈内存</code>中的，但是要知道，V8默认栈内存是<code>984Kib</code>，那如果一个<code>超长字符串 &gt; 984Kib</code>能装的进<code>栈内存</code>吗？</p>\n<p><strong>字符串的内容存于堆内存中，指针存于栈内存中，且相同的字符串指向同一个堆内存地址</strong></p>\n<p><strong>新增或者修改字符串后，如果是一个之前不存在的字符串，则新开辟内存空间，如果是已有的，则直接使用已有的内存空间</strong></p>\n<p>当我们新建一个字符串时，V8会从内存中查找一下是否已经有存在的一样的字符串，找到的话直接复用。如果找不到的话，则开辟一块新的内存空间来存这个字符串，并把地址赋给变量。</p>\n</blockquote>\n<p></p>\n<h2>javascript函数</h2>\n<ul><li> <p><strong>声明函数的几种方式</strong></p> </li></ul>\n<pre><code class=\"language-javascript\">函数声明\nfunction 函数名(参数1，参数2，...){   //要执行的语句 } \n函数表达式\nvar func2=function(b){}//函数表达式\nvar func3=function func4(c){}//命名式函数表达式\nvar func5=(function(n1,n2){})();//立即执行的函数表达式\nreturn function(){ };//作为返回值的函数表达式\nFunction构造器\nvar 变量名 = new Function(\"参数1\",\"参数2\",...,\"参数n\",\"函数体\");  \n立即执行函数\nvar func5=(function(n1,n2){})();//立即执行的函数表达式 ()()</code></pre>\n<ul><li> <p><strong>函数声明与函数表达式的区别</strong></p> </li></ul>\n<blockquote>\n<p>函数声明会将那个函数提升到最前面（即使你写代码的时候在代码块最后才写这个函数），成为全局函数。</p>\n<p>函数声明要指定函数名，而函数表达式不用，可以用作匿名函数。</p>\n</blockquote>\n<p></p>\n<ul><li> <p><strong>函数调用的几种方式</strong></p> </li></ul>\n<blockquote>\n<p>1.直接调用 函数名加上括号 （）</p>\n<p>2.函数表达式 变量名（）</p>\n</blockquote>\n<ul><li> <p><strong>函数的长度</strong></p> </li></ul>\n<blockquote>\n<p>函数的<code>length</code>属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，<code>length</code>属性将失真。</p>\n</blockquote>\n<pre><code class=\"language-javascript\">function fun1(a) { }\nfunction fun2(a, b) { }\nfunction fun3(a, b, c) { }\nfunction fun4(a, b, c, d) { }\nfunction fun5(...args) { }\nfunction fun6(a = 1, b, c, d) { }\n​\nconsole.log(fun1.length) // 1\nconsole.log(fun2.length) // 2\nconsole.log(fun3.length) // 3\nconsole.log(fun4.length) // 4\nconsole.log(fun5.length) // 0\nconsole.log(fun6.length) // 0</code></pre>\n<ul><li> <h3>立即执行函数（iife）和使用场景</h3> </li></ul>\n<blockquote>\n<p>立即执行函数：( function( ){ })( ) 返回值可以为基本数据类型，也能返会任何类型的值。</p>\n<p>写法原因：因为在 javascript 里，括号内部不能包含语句，当解析器对代码进行解释的时候，先碰到了()， 然后碰到function关键字就会自动将()里面的代码识别为函数表达式而不是函数声明。</p>\n<p><strong>作用：立即执行函数会形成一个单独的作用域，我们可以封装一些临时变量或者局部变量，避免污染全局变量。</strong></p>\n<p>使用场景： ①代码在页面加载完成之后，不得不执行一些设置工作，比如时间处理器，创建对象等等。 ②所有的这些工作只需要执行一次，比如只需要显示一个时间。</p>\n<p>③需要一些临时的变量，但是初始化过程结束之后，就再也不会被用到，我们可以用立即执行函数——去将我们所有的代码包裹在它的局部作用域中， 不会让任何变量泄露成全局变量。</p>\n</blockquote>\n<h3>arguments 的对象是什么？</h3>\n<blockquote>\n<p><span style=\"color:#fe2c24;\"><strong>arguments 当我们不知道有多少个参数传进来的时候就用 arguments 来接收，是一个类似于数组的对象，他有length属性，可以arguments[ i ]来访问对象中的元素， 但是它不能用数组的一些方法。</strong></span> 例如push、pop、slice等。arguments虽然不是一个数组，但是它可以转成一个真正的数组。</p>\n<p>取之可以用 展开运算符来 数组和类数组类数组： ①拥有length属性，其它属性(索引)为非负整数；箭头函数里没有arguments ②不具有数组所具有的方法； ③类数组是一个普通对象，而真实的数组是Array类型。</p>\n<p>常见的类数组：arguments，document.querySelectorAll得到的列表，jQuery对象($(\"div\"))；</p>\n</blockquote>\n<h3>this指向的问题（高频）</h3>\n<blockquote>\n<p>在全局的环境下this是指向window 的</p>\n<p>普通函数调用直接调用中的this 会指向 window， 严格模式下this会指向 undefined，自执行函数 this 指向 window，定时器中的 this 指向 window</p>\n<p><strong>在对象里调用的this，指向调用函数的那个对象，</strong></p>\n<p>在构造函数以及类中的this，构造函数配合 new 使用, 而 new 关键字会将构造函数中的 this 指向实例化对象，所以<strong>构造函数中的 this 指向 当前实例化的对象</strong></p>\n<p>方法中的this谁调用就指向谁。</p>\n<p><strong>箭头函数没有自己的 this，箭头函数的this在定义的时候，会继承自外层第一个普通函数的this</strong></p>\n</blockquote>\n<p></p>\n<h3>函数式编程含义：</h3>\n<blockquote>\n<p>函数式编程是一种强调以函数为主的软件开发风格。通过组合纯函数，避免共享状态、可变作用和副作用来构建软件的过程。 目的：使用函数来抽象作用在数据之上的控制流和操作，从而在系统中消除副作用并减少对状态的改变。</p>\n</blockquote>\n<h3>闭包</h3>\n<blockquote>\n<p>1、<span style=\"color:#fe2c24;\"><strong>闭包的概念就是：只有权利访问另一个函数作用域中的变量，一般就是函数包裹着函数。</strong></span></p>\n<p>3、闭包可以重用一个变量，且保证这个变量不会被污染的一种机制。这些变量的值始终保持在内存中，不会被垃圾回收机制处理</p>\n<p>4、闭包的缺点：由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</p>\n<p>5、为什么要用闭包：使用场景 : 防抖、节流、函数套函数避免全局污染</p>\n</blockquote>\n<pre><code class=\"language-javascript\">闭包原理\n函数执行分成两个阶段(预编译阶段和执行阶段)。\n​\n    1.在预编译阶段，如果发现内部函数使用了外部函数的变量，则会在内存中创建一个“闭包”对象并保存对应变量值，\n      如果已存在“闭包”，则只需要增加对应属性值即可。\n    2.执行完后，函数执行上下文会被销毁，函数对“闭包”对象的引用也会被销毁，但其内部函数还持用该“闭包”的引用，\n      所以内部函数可以继续使用“外部函数”中的变量\n​\n利用了函数作用域链的特性，一个函数内部定义的函数会将包含外部函数的活动对象添加到它的作用域链中，函数执行完毕，其执行作用域链销毁，\n但因内部函数的作用域链仍然在引用这个活动对象，所以其活动对象不会被销毁，直到内部函数被烧毁后才被销毁。</code></pre>\n<h3>call、apply、bind封装与区别</h3>\n<blockquote>\n<p>都是来改变this指向和函数的调⽤，实际上call与apply的功能是相同的，只是两者的传参方式不一样，</p>\n<p>call⽅法跟的是⼀个参数列表，</p>\n<p>apply跟⼀个 数组作为参数，call⽅法和apply使⽤后就直接调⽤</p>\n<p>bind 传参后不会立即执行，而是返回一个改变了this指向的函数，这个函数可以继续传参，且执行，需要类似于bind()()两个括号才能调⽤。</p>\n</blockquote>\n<ul><li> <p>call 的性能要比apply好一点（尤其是当函数传递参数超过3个的时候）后期开发 call 多多一点</p> </li><li> <p>call 用扩展运算符就可以吧 apply 来代替了</p> </li></ul>\n<p><strong>bind 返回的函数可以作为构造函数吗？</strong></p>\n<blockquote>\n<p>不可以，会报错的哦，   ERROR &gt; Uncaught TypeError: s is not a constructor</p>\n</blockquote>\n<h3>函数柯里化（卡瑞化、加里化）？</h3>\n<blockquote>\n<p>概念：把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数而且返回结果的新函数的技术。 容易理解的概念：Currying概念其实很简单，只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数（主要是利用闭包实现的）。</p>\n<p>特点：</p>\n<p>①接收单一参数，将更多的参数通过回调函数来搞定；</p>\n<p>②返回一个新函数，用于处理所有的想要传入的参数；</p>\n<p>③需要利用call/apply与arguments对象收集参数；</p>\n<p>④返回的这个函数正是用来处理收集起来的参数。</p>\n<p>作用：能进行部分传值，而传统函数调用则需要预先确定所有实参。如果你在代码某一处只获取了部分实参，然后在另一处确定另一部分实参，这个时候柯里化和偏应用就能派上用场。</p>\n<p>用途：我认为函数柯里化是对闭包的一种应用形式，延迟计算、参数复用、动态生成函数(都是闭包的用途)。</p>\n</blockquote>\n<p></p>\n<h3>柯里化函数例子</h3>\n<blockquote>\n<p>柯里化函数：把一个多参数的函数转化为单参数函数的方法。并且返回接受余下的参数而且返回结果的新函数的技术。</p>\n<p>我的理解就是将一个接受多个参数的函数，转化为接收一个参数，并且不改变输出结果的一种办法。我觉得这就是js的柯里化函数</p>\n</blockquote>\n<pre><code class=\"language-javascript\">// 简单的相加函数\nvar add = function (x,y) {\n    return x + y\n}\n// 调用：\nadd(1,2)\n​\n// 柯里化以后\nvar add = function (x) { //柯里化函数(闭包)\n    return function (y) {\n        return x + y\n    }\n}\nadd(1)(2)</code></pre>\n<blockquote>\n<p>这样做有什么好处，我得理解是在需要的情况下生成一个中间工具，简化代码，并且清晰代码。</p>\n</blockquote>\n<p></p>\n<h3>什么是高阶函数？</h3>\n<blockquote>\n<p>高阶函数只是，将函数作为参数 ， 函数的返回值返回值是函数</p>\n</blockquote>\n<pre><code class=\"language-javascript\">function higherOrderFunction(param,callback){\n    return callback(param);\n}</code></pre>\n<p></p>\n<p></p>\n<h2>构造函数</h2>\n<h3>new的原理</h3>\n<pre><code class=\"language-javascript\">new实际上是在堆内存中开辟一个空间。\n    ①创建一个空对象，构造函数中的this指向这个空对象；\n    ②这个新对象被执行[ [ 原型 ] ]连接；\n    ③执行构造函数方法，属性和方法被添加到this引用的对象中；\n    ④如果构造函数中没有返回其它对象，那么返回this，即创建的这个的新对象，否则，返回构造函数中返回的对象。\n​\nfunction _new(){\n    let target = {};   //创建的新对象\n    let [constructor,...args] = [...arguments];\n       //执行[[原型]]连接,target是constructor的实例\n    target.__proto__ = constructor.prototype;\n        //执行构造函数,将属性或方法添加到创建的空对象上\n    let result = constructor.prototype;\n    if(result &amp;&amp; (typeof (result) == \"object\" || typeof (result) == \"function\")){\n           //如果构造函数执行的结构返回的是一个对象,那么返回这个对象\n        return result;\n    }\n       //如果构造函数返回的不是一个对象,返回创建的对象\n    return target;\n}\n​\n​\n自己理解的new：         \n    new实际上是在堆内存中开辟一个新的空间。首先创建一个空对象obj，然后呢，\n    把这个空对象的原型(__proto__)和构造函数的原型对象(constructor.prototype)连接(说白了就是等于)；\n    然后执行函数中的代码，就是为这个新对象添加属性和方法。最后进行判断其返回值，如果构造函数返回的是一个对象，\n    那就返回这个对象，如果不是，那就返回我们创建的对象。</code></pre>\n<pre>\n</pre>\n<h3>封装一个通用的事件绑定函数</h3>\n<pre><code class=\"language-javascript\">需要点击每个a，来。弹出他们的内容\n&lt;div id=\"div3\"&gt;\n    &lt;a href=\"#\"&gt;a1&lt;/a&gt;&lt;br&gt;\n    &lt;a href=\"#\"&gt;a2&lt;/a&gt;&lt;br&gt;\n    &lt;a href=\"#\"&gt;a3&lt;/a&gt;&lt;br&gt;\n    &lt;a href=\"#\"&gt;a4&lt;/a&gt;&lt;br&gt;\n    &lt;button id='btn1'&gt;加载更多...&lt;/button&gt;\n&lt;/div&gt;\n// 封装通用的事件绑定函数\nfunction bindEvent(elem, type, fn) {\n    elem.addEventListener(type, fn)\n}\n//获取父元素\nconst fu = document.getElementById('div3')\nbindEvent(fu, 'click', function (event) {\n    // console.log(event.target) // 获取触发的元素\n    let target=event.target\n    event.preventDefault() // 阻止默认行为\n    //过滤符合条件的子元素，主要是过滤掉 加载更多 \n    if(target.nodeName.toLowerCase()===\"A\"){\n        alert(target.innerHTML;\n    }\n})</code></pre>\n<p></p>\n<h2>作用域，js的机制</h2>\n<p></p>\n<h3>垃圾回收机制和内存机制</h3>\n<blockquote>\n<p><strong>垃圾回收</strong></p>\n<p>浏览器的js具有自动垃圾回收机制，<strong>垃圾回收机制</strong>也就是自动内存管理机制，垃圾收集器会定期的找出那些不在继续使用的变量，然后释放内存。但是这个过程不是实时的，因为GC开销比较大并且时停止响应其他操作，所以垃圾回收器会按照固定的时间间隔周期性的执行。</p>\n<p><strong>内存泄露</strong></p>\n<p>如果 那些不再使用的变量，它们所占用的内存 不去清除的话就会造成内存泄漏</p>\n<p>内存泄露其实就是我们的<strong>程序中已经动态分配的堆内存，由于某些原因没有得到释放，造成系统内存的浪费导致程序运行速度减慢甚至系统崩溃等严重后果</strong>。</p>\n<p>比如说：</p>\n<p>1、闭包：在闭包中引入闭包外部的变量时，当闭包结束时此对象无法被垃圾回收（GC）。</p>\n<p>2、DOM：当原有的DOM被移除时，子结点引用没有被移除则无法回收</p>\n<p>3、Times计时器泄露</p>\n</blockquote>\n<h3>作用域</h3>\n<blockquote>\n<p><strong>1、作用域</strong></p>\n<p>作用域就是一个变量可以使用的范围，主要分为全局作用域和函数作用域</p>\n<p>全局作用域就是Js中最外层的作用域</p>\n<p>函数作用域是js通过函数创建的一个独立作用域，函数可以嵌套，所以作用域也可以嵌套</p>\n<p>Es6中新增了块级作用域（由大括号包裹，比如：if(){},for(){}等）</p>\n<p><strong>2、自由变量</strong></p>\n<p>当前作用域外的变量都是自由变量，一个变量在当前作用域没有定义，但是被使用了，就会向上级作用域，一层一层依次查找，直至找到为止，如果全局作用域都没有找到这个变量就会报错。这个自由变量查找的过程就是作用域链。</p>\n<p><strong>3、变量提升</strong></p>\n<p>每个var声明的变量，function声明的函数存在变量提升。let const不存在变量提升</p>\n<p>在js中声明之前未定义，会在js的最上方会形成一个预解析池，用来存储声明了但没有先定义的变量名</p>\n<p><strong>4、作用域链：</strong></p>\n<p>作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和 函数 ， 简单来说：内部函数访问外部函数的变量这种链式查找的机制被称为作用域链</p>\n</blockquote>\n<p></p>\n<h3>谈谈JS的运行机制</h3>\n<p>1. js单线程</p>\n<blockquote>\n<p>JavaScript语言的一大特点就是单线程，即同一时间只能做一件事情。</p>\n</blockquote>\n<p>2. js事件循环</p>\n<blockquote>\n<p>js代码执行过程中会有很多任务，这些任务总的分成两类：</p>\n<ul><li> <p>同步任务</p> </li><li> <p>异步任务</p> </li></ul>\n<p>需要注意的是除了同步任务和异步任务，任务还可以更加细分为macrotask(宏任务)和microtask(微任务)，js引擎会优先执行微任务</p>\n</blockquote>\n<pre><code class=\"language-javascript\">微任务包括了 promise 的回调、node 中的 process.nextTick 、对 Dom 变化监听的 MutationObserver。\n​\n宏任务包括了 script 脚本的执行、setTimeout ，setInterval ，setImmediate 一类的定时事件，还有如 I/O 操作、UI 渲\n染等。</code></pre>\n<blockquote>\n<ol><li> <p>首先js 是单线程运行的，在代码执行的时候，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。</p> </li><li> <p>在执行同步代码的时候，如果遇到了异步事件，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务</p> </li><li> <p>当同步事件执行完毕后，再将异步事件对应的回调加入到与当前执行栈中不同的另一个任务队列中等待执行。</p> </li><li> <p>任务队列可以分为宏任务对列和微任务对列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务对列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。</p> </li><li> <p>当微任务对列中的任务都执行完成后再去判断宏任务对列中的任务。</p> </li></ol>\n</blockquote>\n<p>最后可以用下面一道题检测一下收获：</p>\n<pre><code class=\"language-javascript\">setTimeout(function() {\n  console.log(1)\n}, 0);\nnew Promise(function(resolve, reject) {\n  console.log(2);\n  resolve()\n}).then(function() {\n  console.log(3)\n});\nprocess.nextTick(function () {\n  console.log(4)\n})\nconsole.log(5)</code></pre>\n<blockquote>\n<p>第一轮：主线程开始执行，遇到setTimeout，将setTimeout的回调函数丢到宏任务队列中，在往下执行new Promise立即执行，输出2，then的回调函数丢到微任务队列中，再继续执行，遇到process.nextTick，同样将回调函数扔到为任务队列，再继续执行，输出5，当所有同步任务执行完成后看有没有可以执行的微任务，发现有then函数和nextTick两个微任务，先执行哪个呢？process.nextTick指定的异步任务总是发生在所有异步任务之前，因此先执行process.nextTick输出4然后执行then函数输出3，第一轮执行结束。</p>\n<p>第二轮：从宏任务队列开始，发现setTimeout回调，输出1执行完毕，因此结果是25431</p>\n</blockquote>\n<p></p>\n<h3>JS延迟加载的方式</h3>\n<blockquote>\n<p>JavaScript 是单线程（js不走完下面不会走是因为同步）会阻塞DOM的解析，因此也就会阻塞DOM的加载。所以有时候我们希望延迟JS的加载来提高页面的加载速度。</p>\n<p>1.<strong>把JS放在页面的最底部</strong></p>\n<p>2.<strong>script标签的defer属性</strong>：脚本会立即下载但延迟到整个页面加载完毕再执行。该属性对于内联脚本无作用 (即没有 「src」 属性的脚本）。</p>\n<p>3.是在外部JS加载完成后，浏览器空闲时，Load事件触发前执行，<strong>标记为async的脚本</strong>并不保证按照指定他们的先后顺序执行， 该属性对于内联脚本无作用 (即没有 「src」 属性的脚本）。</p>\n<p>4.动态创建script标签，<strong>监听dom加载完毕再引入js文件</strong></p>\n</blockquote>\n<p></p>\n<h3>宏任务和微任务</h3>\n<blockquote>\n<p>js中的一个机制，就是遇到宏任务，先将宏任务放入eventqueue，然后在执行微任务。</p>\n<p>宏任务：setTimeout,setInterval,Ajax,DOM事件</p>\n<p>微任务：Promise async/await</p>\n<p>想明白这个机制 就要理解js单线程。因为JS是单线程语言，只能同时做一件事儿。js任务需要排队顺序执行，如果一个任务时间过长，后边的任务也会等着。假如，我们在请求一个网址时，图片加载很慢，网页总不能一直卡不出来，</p>\n<p>这个时候就可以用异步来解决了，异步的特点不会阻塞代码的执行 ,解决了单线程等待的这个问题</p>\n<p>在执行同步代码的时候，如果遇到了异步事件，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务</p>\n<p>异步和单线程是相辅相成的，js是一门单线程语言，所以需要异步来辅助。</p>\n</blockquote>\n<pre><code class=\"language-javascript\">宏任务macrotask： 可以理解是每次执行栈执行的代码就是一个宏任务(包括每次从事件队列中获取一个事件回调并放到\n   执行栈中执行)。\n   常见的宏任务：script, setTimeout, setInterval, setImmediate, I/O, UI rendering。\n   \n微任务microtask(异步)： 可以理解是在当前task执行结束后立即执行的任务。\n​\n常见的微任务：process.nextTick(Nodejs),Promise.then(), MutationObserver。\n​\n线程，进程?\n线程是最小的执行单元，进程是最小的资源管理单元一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程</code></pre>\n<blockquote>\n<p><strong>内存泄露</strong></p>\n<p>如果 那些不再使用的变量，它们所占用的内存 不去清除的话就会造成内存泄漏</p>\n<p>比如说：</p>\n<p>1、闭包：在闭包中引入闭包外部的变量时，当闭包结束时此对象无法被垃圾回收（GC）。</p>\n<p>2、DOM：当原有的DOM被移除时，子结点引用没有被移除则无法回收</p>\n<p>3、Times计时器泄露</p>\n</blockquote>\n<h3>JS预解析（变量提升），它导致了什么问题？</h3>\n<blockquote>\n<p><strong>JS代码在执行前，浏览器会对js代码进行扫描，默认的把所有带var和function声明的变量进行提前的声明或者定义，遵循先解析后使用的原则。</strong> 变量提升的表现是，在变量或函数声明之前访问变量或调用函数而不会报错。</p>\n<p>原因 JavaScript引擎在代码执行前有一个解析的过程（预编译），创建执行上线文，初始化一些代码执行时需要用到的对象。 当访问一个变量时，会到当前执行上下文中的作用域链中去查找，而作用域链的首端指向的是当前执行上下文的变量对象，这个变量对象是执行上下文的一个属性， 它包含了函数的形参、所有的函数和变量声明，这个对象的是在代码解析的时候创建的。</p>\n<p>首先要知道，JS在拿到一个变量或者一个函数的时候，会有两步操作，即解析和执行。</p>\n<p>1<strong>.在解析阶段 JS会检查语法，并对函数进行预编译。解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来， 变量先赋值为undefined，函数先声明好可使用。在一个函数执行之前，也会创建一个函数执行上下文环境，跟全局执行上下文类似， 不过函数执行上下文会多出this、arguments和函数的参数。</strong></p>\n<p>全局上下文：变量定义，函数声明 函数上下文：变量定义，函数声明，this，arguments</p>\n</blockquote>\n<p>2.在执行阶段，就是按照代码的顺序依次执行。</p>\n<pre><code class=\"language-javascript\">那为什么会进行变量提升呢？主要有以下两个原因：\n\n1、提高性能\n2、容错性更好\n​\n（1）提高性能 在JS代码执行之前，会进行语法检查和预编译，并且这一操作只进行一次。这么做就是为了提高性能，如果没有这一步，\n    那么每次执行代码前都必须重新解析一遍该变量（函数），而这是没有必要的，因为变量（函数）的代码并不会改变，解析一遍就够了。\n    \n    在解析的过程中，还会为函数生成预编译代码。在预编译时，会统计声明了哪些变量、创建了哪些函数，并对函数的代码进行压缩，去除注释、\n    不必要的空白等。这样做的好处就是每次执行函数时都可以直接为该函数分配栈空间（不需要再解析一遍去获取代码中声明了哪些变量，创建了哪些函数），\n    并且因为代码压缩的原因，代码执行也更快了。\n    \n（2）容错性更好 变量提升可以在一定程度上提高JS的容错性，看下面的代码：\n​\n    a = 1\n    var a\n    console.log(a) //1\n    如果没有变量提升，这段代码就会报错导致的问题\nvar tmp = new Date();\n​\nfunction fn(){\n    console.log(tmp);\n    if(false){\n        var tmp = 'hello nanjiu';\n    }\n}\nfn();  // undefined\n        \n    在这个函数中，原本是要打印出外层的tmp变量，但是因为变量提升的问题，内层定义的tmp被提到函数内部的最顶部，\n    相当于覆盖了外层的tmp，所以打印结果为undefined。\n    var tmp = 'hello nan jiu';\n    \n    for (var i = 0; i &lt; tmp.length; i++) {\n        console.log(tmp[i]);\n    }\n    console.log(i); // 13\n​\n由于遍历时定义的i会变量提升成为一个全局变量，在函数结束之后不会被销毁，所以打印出来13。\n总结      \n解析和预编译过程中的声明提升可以提高性能，让函数可以在执行时预先为变量分配栈空间\n声明提升还可以提高JS代码的容错性，使一些不规范的代码也可以正常执行\n函数是一等公民，当函数声明与变量声明冲突时，变量提升时函数优先级更高，会忽略同名的变量声明</code></pre>\n<h3>服务端渲染</h3>\n<blockquote>\n<p><strong>解释：<span style=\"color:#fe2c24;\">服务端渲染的模式下，当用户第一次请求页面时，由服务器把需要的组件或页面渲染成 HTML 字符串，然后把它返回给客户端。客户端拿到手的，是可以直接渲染然后呈现给用户的 HTML 内容，不需要为了生成 DOM 内容自己再去跑一遍 JS 代码</span>。使用服务端渲染的网站，可以说是“所见即所得”，页面上呈现的内容，<span style=\"color:#fe2c24;\">我们在 html 源文件里也能找到</span>。有了服务端渲染，当请求用户页面时，<span style=\"color:#fe2c24;\">返回的body里已经有了首屏的html结构</span>，之后结合css显示出来。<br/>     <br/> 优点：<br/>     ①首屏渲染快(关键性问题)：相比于加载单页应用，我只需要加载当前页面的内容，而不需要像 React 或者 Vue 一样加载全部的 js 文件；<br/>     ②SEO(搜索引擎)优化：不同爬虫工作原理类似，只会爬取源码，不会执行网站的任何脚本<br/>     ③可以生成缓存片段、节能；<br/> ​<br/> 缺点：用户体验较差，不容易维护、通常前端改了部分html或者css，后端也需要改；<br/> ​<br/> 使用场景：vue全家桶或者react全家桶，都是推荐通过服务端渲染来实现路由的。</strong></p>\n</blockquote>\n<h3>Event Loop Event Queue</h3>\n<blockquote>\n<p>在js中我们经常需要同时执行很多件任务，例如，定时器，事件。异步数据，而js是单线程的原因不能同时进行很多件事情，必须等上一件任务执行完了才会执行下一个，需要通过Event Loop 来处理很多任务的执行<br/><br/><strong>因为js是单线程的，代码执行的时候，将不同的函数执行上下文压入到栈中进行有序的执行，<br/> 在执行同步代码的时候，如果遇到了异步事件，js引擎并不会一直等待其返回结果，就是将它挂起，继续执行栈中其他的任务<br/> 当同步任务执行完了，再将异步事件对应的回调加入到与当前执行栈中不同的另一个任务队列中等待执行。<br/> 任务队列分为的宏任务队列和微任务队列，当前的执行栈中执行完，js引擎会首先判断微任务队列是否有任务可以执行有的话，放到栈中执行。<br/> 当微任务队列中的任务执行完了再去判断宏任务中的队列。</strong><br/><br/><br/><strong>为什么会有任务队列呢？</strong><br/> 还是因为 javascript 单线程的原因，单线程，就意味着一个任务一个任务的执行，<br/> 执行完当前任务，执行下一个任务，这样也会遇到一个问题，就比如说，要向服务端通信，加载大量数据，如果是同步执行，<br/> js 主线程就得等着这个通信完成，然后才能渲染数据，<strong>为了高效率的利用cpu, 就有了同步任务和异步任务之分。</strong></p>\n</blockquote>\n<h3>同步和异步的区别？各举一个Js中同步和异步的案例？</h3>\n<blockquote>\n<p>同步：上一件事情没有完成，继续处理上一件事情，只有上一件事情完成了，才会做下一件事情</p>\n<p>异步： 规划要做一件事情,如果是异步事情，不是当前立马去执行这件事情，需要等一定的时间，这样的话，我们不会等着他执行，而是继续执行下面的操作</p>\n<p>对于写程序，同步往往会阻塞，没有数据过来，我就等着，异步则不会阻塞，没数据来我干别的事，有数据来去处理这些数据。</p>\n<p>同步案例：for循环语句，alert(),console.log()等 js大部分都是同步编程</p>\n<p>异步案例：所有定时器，ajax异步请求，所有的事件绑定都是异步;</p>\n<p>举例子</p>\n<p>同步，就是实时处理（如打电话），比如服务器一接收客户端请求，马上响应，这样客户端可以在最短的时间内得到结果，但是如果多个客户端，或者一个客户端发出的请求很频繁，服务器无法同步处理，就会造成涌塞。</p>\n<p>同步如打电话，通信双方不能断（我们是同时进行，同步），你一句我一句，这样的好处是，对方想表达的信息我马上能收到，但是，我在打着电话，我无法做别的事情。</p>\n<p>异步，就是分时处理（如收发短信），服务器接收到客户端请求后并不是立即处理，而是等待服务器比较空闲的时候加以处理，可以避免涌塞。</p>\n</blockquote>\n<p></p>\n<h2>BOM浏览器对象模型</h2>\n<h3>js操作BOM</h3>\n<blockquote>\n<p>浏览器对象模型（BOM ：Browser Object Model）是JavaScript的组成之一，它提供了独立于内容与浏览器窗口进行交互的对象，使用浏览器对象模型可以实现与HTML的交互。它的作用是将相关的元素组织包装起来，提供给程序设计人员使用，从而降低开发人员的劳动量，提高设计Web页面的能力。</p>\n<p>window : alert() , prompt() , confirm() , setInterval() , clearInterval() , setTimeout() , clearTimeout() ;</p>\n<p>history : go(参数) , back() , foward() ;</p>\n<p>location : herf属性.</p>\n<p>1、window.location.href = '你所要跳转到的页面'; 2、window.open('你所要跳转到的页面’); 3、window.history.back(-1):返回上一页 4、window.history.go(-1/1):返回上一页或下一页五、 5、history.go(\"baidu.com\")；</p>\n</blockquote>\n<h3>说出5个以上Math对象中的成员。</h3>\n<blockquote>\n<p>Math.PI 圆周率</p>\n<p>Math.floor() 向下取整</p>\n<p>Math.ceil() 向上取整</p>\n<p>Math.round() 四舍五入版 就近取整</p>\n<p>Math.abs() 绝对值</p>\n<p>Math.max()/Math.min() 求最大和最小值</p>\n<p>Math.random() 获取范围在[0,1)内的随机值</p>\n</blockquote>\n<p></p>\n<h3>setTimeout与setInterval区别与机制</h3>\n<blockquote>\n<p>setTimeout()和setInterval()经常被用来处理延时和定时任务。</p>\n<p><strong>setTimeout</strong>() 方法用于在指定的毫秒数后调用函数或计算表达式</p>\n<p><strong>setInterval</strong>()则可以在每隔指定的毫秒数循环调用函数或表达式，直到clearInterval把它清除。</p>\n</blockquote>\n<pre><code>机制：\n\n因为js是单线程的。浏览器遇到setTimeout 和 setInterval会先执行完当前的代码块，在此之前会把定时器推入浏览器的\n待执行时间队列里面，等到浏览器执行完当前代码之后会看下事件队列里有没有任务，有的话才执行定时器里的代码</code></pre>\n<p></p>\n<h3>window的onload事件和domcontentloaded</h3>\n<blockquote>\n<p>window.onload：当一个资源及其依赖资源已完成加载时，将触发onload事件。 document.onDOMContentLoaded：当初始的HTML文档被完全加载和解析完成之后， DOMContentLoaded事件被触发，而无需等待样式表、图像和子框架的完成加载。 区别： ①onload事件是DOM事件，onDOMContentLoaded是HTML5事件。 ②onload事件会被样式表、图像和子框架阻塞，而onDOMContentLoaded不会。 ③当加载的脚本内容并不包含立即执行DOM操作时，使用onDOMContentLoaded事件是个更好的选择，会比onload事件执行时间更早。</p>\n</blockquote>\n<p></p>\n<h3>cookies，sessionStorage 和 localStorage 的区别?</h3>\n<blockquote>\n<p>cookie：一个大小不超过4K的小型文本数据，一般由服务器生成，可以设置失效时间；若没有设置时间，关闭浏览器cookie失效，若设置了 时间，cookie就会存放在硬盘里，过期才失效，每次http请求，header都携带cookie</p>\n<p>localStorage：5M或者更大，永久有效，窗口或者浏览器关闭也会一直保存，除非手动永久清除或者js代码清除，因此用作持久数据，不参与和服务器的通信</p>\n<p>sessionStorage关闭页面或浏览器后被清除。存 放数据大小为一般为 5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信。</p>\n</blockquote>\n<h3>location、之lnavigator和history</h3>\n<blockquote>\n<p>location 对象存储了当前文档位置（URL）相关的信息，简单地说就是网页地址字符串。使用 window 对象的 location 属性可以访问。</p>\n<p>href会重新定位到一个URL，hash会跳到当前页面中的anchor名字的标记(如果有)，而且页面不会被重新加载</p>\n</blockquote>\n<h3>history</h3>\n<blockquote>\n<p>window 对象给我们提供了一个 history 对象，与浏览器历史记录进行交互。该对象包含用户（在浏览器窗口中） 访问过的 URL。</p>\n<p>history.back 可以后退一个网页</p>\n<p>history.go 可以前进后退 1前进 -1 后退</p>\n<p>history.forward  前进</p>\n</blockquote>\n<h3>navigator对象</h3>\n<blockquote>\n<p>window.navigator`对象包含<strong>有关浏览器的信息</strong>，可以用它来查询一些关于运行当前脚本的应用程序的相关信息</p>\n<p>navigator.appCodeName 只读,任何浏览器中，总是返回 'Gecko'。该属性仅仅是为了保持兼容性。</p>\n<p><code>navigator.appName</code> 只读,返回浏览器的官方名称。不要指望该属性返回正确的值。</p>\n<p><code>navigator.appVersion</code> 只读,返回一个字符串，表示浏览器的版本。不要指望该属性返回正确的值。</p>\n<p><code>navigator.platform</code> 只读,返回一个字符串，表示浏览器的所在系统平台。</p>\n<p><code>navigator.product</code> 只读,返回当前浏览器的产品名称（如，\"Gecko\"）。</p>\n<p><code>navigator.userAgent</code> 只读,返回当前浏览器的用户代理字符串（user agent string）</p>\n</blockquote>\n<p></p>\n<h2>DOM文档对象模型</h2>\n<blockquote>\n<p><strong>DOM是 document 用来表示文档中对象的标准模型，他是由节点和对象组成的结构集合</strong>。在浏览器解析HTML标签时，会构建一个DOM树结构。</p>\n</blockquote>\n<p><strong>操作说明书</strong></p>\n<pre><code class=\"language-javascript\">拿到指定节点\nvar id = document.getElementById(\"id\");  //返回带有指定id的元素\nvar name = document.getElementByTagName(\"li\"); //返回带有指定标签的元素\nvar class = document.getElementByClassName(\"class\"); //返回带有包含执行类名的所有元素节点列表。`\n 创建DOM节点\nvar node = document.createElement(\"div\");\nvar attr = document.createAttribute(\"class\");\nvar text = document.createTextNode(\"菜呀菜\");`\n 插入DOM节点\nnode.appendChild(text) //插入新的子节点\nnode.insertBefore(pre,child) //在node元素内child前加入新元素`\n 删除DOM节点\nnode.removeChild(text) //从父元素删除子元素节点\n 修改DOM节点\nnode.setAttribute(\"class\",\"name\") //修改设置属性节点\nnode.replaceChild(pre,child)  //父节点内新子节点替换旧子节点`\n 常用DOM属性\nnode.innerHtml  //获取/替换元素内容\nnode.parentNode  //元素节点的父节点\nnode.parentElement  //元素节点的父元素节点（一般与Node节点相同）\nnode.firstChild  //属性的第一个节点\nnode.lastChild   //属性的最后一个节点\nnode.nextSibling //节点元素后的兄弟元素（包括回车，空格，换行）\nnode.nextElementSibling //节点元素后的兄弟元素节点\nnode.previousSibling //获取元素的上一个兄弟节点（元素，文本，注释）\nnode.previousElementSibling //获取元素的上一个兄弟节点（只包含元素节点）\nnode.childNodes  //元素节点的子节点（空格，换行默认为文本节点）\nnode.children    //返回当前元素的所有元素节点\nnode.nodeValue   //获取节点值\nnode.nodeName    //获取节点名字\nnode.attributes  //元素节点的属性节点\nnode.getAttribute(\"name\")  //元素节点的某个属性节点\nnode.style.width = \"200px\"  //设置css样式`</code></pre>\n<p></p>\n<h3>常用的api</h3>\n<h3>offset、client、scroll的用法?</h3>\n<blockquote>\n<p>offset系列 经常用于获得元素位置 offsetLeft offsetTop</p>\n<p>client经常用于获取元素大小 clientWidth clientHeight </p>\n<p>scroll 经常用于获取滚动距离 scrollTop scrollLeft</p>\n</blockquote>\n<p></p>\n<h2>js面试题的扩展</h2>\n<p></p>\n<h3>什么是函数式编程? 命令式编程？声明式编程？</h3>\n<blockquote>\n<p><strong>声明式编程：专注于”做什么”而不是”如何去做”。</strong>在更高层面写代码，更关心的是目标，而不是底层算法实现的过程。 如：css, 正则表达式，sql 语句，html, xml…</p>\n<p><strong>命令式编程(过程式编程) : 专注于”如何去做”</strong>，这样不管”做什么”，都会按照你的命令去做。解决某一问题的具体算法实现。</p>\n<p>如： for（）</p>\n<p>函数式编程：把运算过程尽量写成一系列嵌套的函数调用。</p>\n<p>如 ： forEach（）</p>\n</blockquote>\n<p></p>\n<h3>iframe的优缺点有哪些？</h3>\n<blockquote>\n<p>优点：<br/>     ①iframe能够原封不动的把嵌入的网页展现出来；<br/>     ②如果有多个网页引用iframe，那么你只需要修改iframe的内容，就可以实现调用的每一个页面内容的更改，方便快捷。<br/>     ③网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用iframe来嵌套，可以增加代码的可重用。<br/>     ④如果遇到加载缓慢的第三方内容如图标和广告，这些问题可以由iframe来解决。<br/> ​<br/> 缺点：<br/>     ①会产生很多页面不易管理；<br/>     ②iframe框架结构有时会让人感到迷惑，如果框架个数多的话，可能会出现上下、左右滚动条，会分散访问者的注意力，用户体验度差。<br/>     ③代码复杂，无法被一些搜索引擎索引到，这一点很关键，现在的搜索引擎爬虫还不能很好的处理iframe中的内容，所以使用iframe会不利于搜索引擎优化。<br/>     ④很多的移动设备（PDA 手机）无法完全显示框架，设备兼容性差。<br/>     ⑤iframe框架页面会增加服务器的http请求，对于大型网站是不可取的。</p>\n</blockquote>\n<p></p>\n<h3>如何让(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3)的值为true？</h3>\n<pre><code class=\"language-javascript\">\" == \"操作符在左右数据不一致的时候，会先进行隐式转换，该值意味着不是基本数据类型，\n因为如果a是null或者undefined、bool类型都不可能返回true；可以推测a是复杂数据类型。\n​\n方法一：数组的 toString 接口默认调用数组的 join 方法，重新 join 方法\n​\nlet a = [1,2,3];\na.join = a.shift;\nconsole.log(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) //true\n​\n​\n方法二：利用数据劫持(Proxy/Object.definedProperty)\n​\nlet i = 1;\nlet a = new Proxy({},{\n    i:1,\n    get:function(){\n        return () =&gt; this.i++\n    }\n});\nconsole.log(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3);</code></pre>\n<h3>为什么0.1+0.2 ! == 0.3，如何让其相等</h3>\n<pre><code class=\"language-javascript\">在开发过程中遇到类似这样的问题：\n\nlet n1 = 0.1, n2 = 0.2\nconsole.log(n1 + n2)  // 0.30000000000000004\n\n这里得到的不是想要的结果，要想等于0.3，就要把它进行转化：\n\n(n1 + n2).toFixed(2) // 注意，toFixed为四舍五入\n复制代码\ntoFixed(num) 方法可把 Number 四舍五入为指定小数位数的数字。那为什么会出现这样的结果呢？\n\n计算机是通过二进制的方式存储数据的，所以计算机计算0.1+0.2的时候，实际上是计算的两个数的二进制的和</code></pre>\n<h1></h1>\n<h1 id=\"es6%E9%83%A8i%E5%88%86%E9%9D%A2%E8%AF%95%E9%A2%98\">es6部i分面试题</h1>\n<p></p>\n<h3 id=\"1%E3%80%81%20ES6%20%E6%96%B0%E5%A2%9E%E7%89%B9%E6%80%A7\"><span style=\"color:#fe2c24;\">1、 ES6 新增特性</span></h3>\n<blockquote>\n<ol><li> <p>新增了块级作用域(let,const)</p> </li><li> <p>提供了定义类的语法糖(class)</p> </li><li> <p>新增了一种基本数据类型(Symbol)</p> </li><li> <p>新增了变量的解构赋值</p> </li><li> <p>函数参数允许设置默认值，引入了 rest 参数，新增了箭头函数</p> </li><li> <p>数组新增了一些 API，如 isArray / from / of 方法;数组实例新增了entries()，keys() 和 values() 等方法</p> </li><li> <p>对象和数组新增了扩展运算符</p> </li><li> <p>ES6 新增了模块化(import/export)</p> </li><li> <p>ES6 新增了 Set 和 Map 数据结构</p> </li><li> <p>ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例</p> </li><li> <p>ES6 新增了生成器(Generator)和遍历器(Iterator)</p> </li></ol>\n</blockquote>\n<p></p>\n<p></p>\n<h3 id=\"2%E3%80%81require%E4%B8%8Eimport%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E4%BD%BF%E7%94%A8(CommonJS%E8%A7%84%E8%8C%83%E5%92%8Ces6%E8%A7%84%E8%8C%83)\">2、require与import的区别和使用(CommonJS规范和es6规范)</h3>\n<blockquote>\n<p>1、<span style=\"color:#fe2c24;\"><strong>import是ES6中的语法标准也是用来加载模块文件的</strong></span>，import函数可以读取并执行一个JavaScript文件，然后返回该模块的export命令指定输出的代码。<strong>export与export default均可用于导出常量、函数、文件、模块</strong>，<span style=\"color:#fe2c24;\"><strong>export可以有多个，export default只能有一个。</strong></span></p>\n<p>2、<strong>require 定义模块</strong>：<strong>module变量代表当前模块</strong>，它的exports属性是对外的接口。通过exports可以将模块从模块中导出，其他文件加载该模块实际上就是读取module.exports变量，他们可以是变量、函数、对象等。在node中如果用exports进行导出的话系统会系统帮您转成module.exports的，只是导出需要定义导出名。</p>\n<p><strong>require与import的区别</strong></p>\n<p><strong>1，require是CommonJS规范的模块化语法，import是ECMAScript 6规范的模块化语法；</strong></p>\n<p><strong>2，require是运行时加载，import是编译时加载；</strong></p>\n<p><strong>3，require可以写在代码的任意位置，import只能写在文件的最顶端且不可在条件语句或函数作用域中使用；</strong></p>\n<p>4，require通过module.exports导出的值就不能再变化，import通过export导出的值可以改变；</p>\n<p>5；require通过module.exports导出的是exports对象，import通过export导出是指定输出的代码；</p>\n<p>6，require运行时才引入模块的属性所以性能相对较低，import编译时引入模块的属性所所以性能稍高。</p>\n</blockquote>\n<p></p>\n<h3 id=\"3%E3%80%81%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0\"><span style=\"color:#fe2c24;\">3、箭头函数</span></h3>\n<blockquote>\n<p><span style=\"color:#fe2c24;\"><strong>js中我们在调⽤函数的时候经常会遇到this作⽤域的问题，这个时候ES6给我们提箭头函数</strong>。</span></p>\n<p><strong>1、 箭头函数是匿名函数不能作为构造函数，不能使用new</strong></p>\n<p><strong>2、 箭头函数不绑定arguments,取而代之用rest参数…解决，</strong></p>\n<p><strong>3、 this指向不同,箭头函数的this在定义的时候继承自外层第一个普通函数的this </strong></p>\n<p><strong>4、 箭头函数通过call()或apply()调用一个函数,只传入了一个参数,对this并没有影响. </strong></p>\n<p><strong>5、 箭头函数没有prototype(原型)，所以箭头函数本身没有this </strong></p>\n<p><strong>6、 箭头函数不能当做Generator函数,不能使用yield关键字、</strong></p>\n<p><strong>7、 写法不同，箭头函数把function省略掉了 （）=&gt; 也可以吧return 省略调 写法更简洁</strong></p>\n<p><strong>8、箭头函数不能通过call（）、apply（）、bind（）方法直接修改它的this指向。</strong></p>\n</blockquote>\n<p></p>\n<h3 id=\"4%E3%80%81%E7%AE%80%E8%BF%B0%20let%20const%20var%20%E7%9A%84%E5%8C%BA%E5%88%AB%20%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\"><span style=\"color:#fe2c24;\">4、简述 let const var 的区别 以及使用场景</span></h3>\n<ul><li>var let 是用来声明变量的，而const是声明常量的 var</li></ul>\n<blockquote>\n<pre>1.var声明的变量存在变量提升，即变量可以在声明之前调用，值为undefined ​   \n2、一个变量可多次声明，后面的声明会覆盖前面的声明 ​   \n3、在函数中使用var声明变量的时候，该变量是局部的作用域只在函数内部，而如果在函数外部使用 var，该变量是全局的\n</pre>\n</blockquote>\n<ul><li>let</li></ul>\n<blockquote>\n<pre>1、不存在变量提升，let声明变量前，该变量不能使用。就是 let 声明存在暂时性死区 ​      \n2、let命令所在的代码块内有效，在块级作用域内有效，作用域只是在花括号里面 ​      \n3、let不允许在相同作用域中重复声明，注意是相同作用域，不同作用域有重复声明不会报错\n</pre>\n</blockquote>\n<ul><li>const</li></ul>\n<blockquote>\n<pre>1、const声明一个只读的常量，声明后，值就不能改变 ​     \n2、let和const在同一作用域不允许重复声明变量const声明一个只读的常量。一旦声明，常量的值就不能改变，但对于对象和数据这种  引用类型，内存地址不能修改，可以修改里面的值。 ​   \n3、let和const不存在变量提升，即它们所声明的变量一定要在声明后使用，否则报错 \n</pre>\n<p>4、能用const的情况下尽量使用const，大多数情况使用let，避免使用var。 const &gt; let &gt; var const声明的好处，一让阅读代码的人知道该变量不可修改，二是防止在修改代码的过程中无意中修改了该变量导致报错，减少bug的产生</p>\n</blockquote>\n<p></p>\n<h3 id=\"5%E3%80%81map%E5%92%8CforEach%E7%9A%84%E5%8C%BA%E5%88%AB\"><span style=\"color:#fe2c24;\">5、map和forEach的区别</span></h3>\n<blockquote>\n<p><strong>相同点</strong></p>\n<p>都是循环遍历数组中的每一项 <strong>forEach和map方法里每次执行匿名函数都支持3个参数，参数分别是item（当前每一项）、index（索引值）、arr（原数组）</strong>，需要用哪个的时候就写哪个 匿名函数中的this都是指向window 只能遍历数组</p>\n<p><strong>注意</strong>：forEach对于空数组是不会调用回调函数的。</p>\n</blockquote>\n<blockquote>\n<p><strong>不同点</strong></p>\n<p><strong>map方法返回一个新的数组，数组中的元素为原始数组调用函数处理后的值</strong>。(原数组进行处理之后对应的一个新的数组。) <span style=\"color:#fe2c24;\"><strong>map()方法不会改变原始数组 map()方法不会对空数组进行检测 forEach()方法用于调用数组的每个元素，将元素传给回调函数.(没有return，返回值是undefined）</strong></span></p>\n</blockquote>\n<p></p>\n<p></p>\n<h3 id=\"6%E3%80%81promise\"><span style=\"color:#fe2c24;\">6、promise的解释</span></h3>\n<blockquote>\n<p><strong>1、Promise 是异步编程的一种解决方案，主要用于异步计算，支持链式调用，可以解决回调地狱 的问题，自己身上有all、reject、resolve、race 等方法，原型上有then、catch等方法。</strong></p>\n<p><strong>2、可以将异步操作队列化，按照期望的顺序执行，返回符合预期的结果，可以在对象之间传递和操作 promise，帮助我们处理队列</strong></p>\n<p><strong>3、promise 有三个状态：pending[待定]初始状态，fulfilled[实现]操作成功，rejected[被否决]操作失败</strong></p>\n<p><strong>4、Promise 对象状态改变：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。只要这两种情况发生，状态就凝固了，不会再变了</strong></p>\n<p><strong>5、如果不设置回调函数，Promise内部抛出的错误，不会反应到外部，但是写了then 和 catch ，会被then的第二个参数 或 catch所捕获</strong></p>\n</blockquote>\n<ul><li> <h3><span style=\"color:#fe2c24;\"><strong>promise 的 then 为什么可以支持链式调用</strong></span></h3> </li></ul>\n<blockquote>\n<p>promise 的then会返回一个新的 promise 对象，能保证 then 方 可以进行链式调用</p>\n</blockquote>\n<p>补充：</p>\n<h3>Promise.all哪怕一个请求失败了也能得到其余正确的请求结果的解决方案</h3>\n<pre><code class=\"language-javascript\">Promise.all默认只要有一个错误就直接返回错误。promise.all中任何一个promise 出现错误的时候都会执行reject，导致其它正常返回的数据也无法使用\nPromise.all(\n  [\n    Promise.reject({ code: 500, msg: \"服务异常\" }),\n    Promise.resolve({ code: 200, list: [] }),\n    Promise.resolve({ code: 200, list: [] })\n  ].map(p =&gt; p.catch(e =&gt; e))\n)\n  .then(res =&gt; {\n    console.log(\"res=&gt;\", res);\n  })\n  .catch(error =&gt; {\n    console.log(\"error=&gt;\", error);\n  });\nres=&gt; [ { code: 500, msg: '服务异常' },\n  { code: 200, list: [] },\n  { code: 200, list: [] } ]\n核心内容是map方法，map的每一项都是promise，catch方法返回值会被promise.reslove()包裹，这样传进promise.all的数据都是resolved状态的。\n\n// 使用Promise.all 其中id为69的商品,返回失败,会导致整个Promise接受到reject状态.\n// 所以进行改造, p catch 得到的err  为返回失败抛出的信息, 进行置空\n.map(p =&gt; p.catch(err =&gt; '')))</code></pre>\n<h3 id=\"6%E3%80%81async%E3%80%81await\"><span style=\"color:#fe2c24;\">6、async、await的原理</span></h3>\n<blockquote>\n<p><strong>Async 和 await 是一种同步的写法，但还是异步的操作，两个必须配合一起使用</strong></p>\n<p><strong>函数前面的<code>async</code>关键字，表明该函数内部有异步操作。调用该函数时，会立即返回一个<code>Promise</code>对象。</strong></p>\n<p><strong>await 是个运算符，用于组成表达式，await 表达式的运算结果取决于它等的东西，如果是promise则会等待promaise 返回结果，接普通函数直接进行链式调用.</strong></p>\n<p><strong>await 能够获取promise执行的结果 await必须和async一起使用才行，async配合await使用是一个阻塞的异步方法</strong></p>\n<p><strong>如果await后面不是Promise对象, 就直接返回对应的值，只能在async函数中出现, 普通函数直接使用会报错</strong></p>\n<p><strong>await语句后的Promise对象变成reject状态时，那么整个async函数会中断，后面的程序不会继续执行</strong></p>\n</blockquote>\n<p><strong>使用场景：</strong></p>\n<blockquote>\n<p>我在项目中： 需求：执行第一步，将执行第一步的结果返回给第二步使用。在ajax中先拿到一个接口的返回数据，然后使用第一步返回的数据执行第 二步操作的接口调用，达到异步操作。</p>\n</blockquote>\n<p></p>\n<h3 id=\"7%E3%80%81%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC\"><span style=\"color:#fe2c24;\">7、解构赋值</span></h3>\n<blockquote>\n<p><strong>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构赋值</strong></p>\n<p><strong>常见的几种方式有</strong></p>\n<p>1.默认值</p>\n<p>2.交换变量</p>\n<p>3.将剩余数组赋给一个变量</p>\n<p><strong>结构数组和对象字符串区别</strong></p>\n<p><span style=\"color:#fe2c24;\"><strong>对象的解构与数组类似，但有所不同。数组的元素是按次序排列的，变量的取值由它的位置决定；</strong></span></p>\n<p><span style=\"color:#fe2c24;\"><strong>而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。字符串也是可以解构赋值的。字符串被转换成了一个类似数组的对象.</strong></span></p>\n<p><strong>我在项目中</strong>：就是从目标对象或数组中提取自己想要的变量。最常用的场景是：element-ui,vant-ui按需引入，请求接口返回数据，提取想要数据。</p>\n</blockquote>\n<p></p>\n<h3 id=\"8%E3%80%81%20for...in%20%E8%BF%AD%E4%BB%A3%E5%92%8C%20for...of%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB\">8、 for...in 迭代和 for...of 有什么区别</h3>\n<blockquote>\n<p>1、 推荐在循环对象属性的时候，使用 for...in,在遍历数组的时候的时候使用for...of。</p>\n<p>2、 for in遍历的是数组的索引，而for of遍历的是数组元素值</p>\n<p>3、for...of 不能循环普通的对象，需要通过和 Object.keys()搭配使用</p>\n<p>4、for...in 遍历顺序以数字为先 无法遍历 symbol 属性 可以遍历到公有中可枚举的</p>\n<p>5、从遍历对象的角度来说，for···in会遍历出来的为对象的key，但for···of会直接报错。</p>\n</blockquote>\n<p></p>\n<h3 id=\"9%E3%80%81%20generator\">9、 generator 有了解过吗？</h3>\n<blockquote>\n<ul><li> <p>Generator 生成器 也是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同 function *（）{}</p> </li><li> <p>Generator 函数是一个状态机，封装了多个内部状态，除了状态机，还是一个遍历器对象生成函数。</p> </li><li> <p>Generator 是分段执行的, yield （又得）可暂停，next方法可启动。每次返回的是yield后的表达式结果，这使得<code>Generator</code>函数非常适合将异步任务同步化</p> </li><li> <p>Generator <strong><code>并不是为异步而设计出来的，它还有其他功能（对象迭代、控制输出、部署</code>Interator`接口…）</strong></p> </li><li> <p><code>Generator</code>函数返回<code>Iterator</code>对象，因此我们还可以通过<code>for...of</code>进行遍历,原生对象没有遍历接口，通过<code>Generator</code>函数为它加上这个接口，就能使用<code>for...of</code>进行遍历了</p> </li></ul>\n</blockquote>\n<p><strong>promise、Generator、async/await进行比较：</strong></p>\n<blockquote>\n<p><strong>promise和async/await是专门用于处理异步操作的<br/> Generator并不是为异步而设计出来的，它还有其他功能（对象迭代、控制输出、部署Interator接口…）<br/> promise编写代码相比Generator、async更为复杂化，且可读性也稍差<br/> Generator、async需要与promise对象搭配处理异步情况<br/> async实质是Generator的语法糖，相当于会自动执行Generator函数<br/> async使用上更为简洁，将异步代码以同步的形式进行编写，是处理异步编程的最终方案</strong></p>\n</blockquote>\n<p></p>\n<h3 id=\"10%E3%80%81js%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%92%8C%E5%AE%9E%E4%BE%8B%E6%88%90%E5%91%98\"><span style=\"color:#fe2c24;\">10、js构造函数的静态成员和实例成员</span></h3>\n<blockquote>\n<p>js的构造函数（在别的后台语言上叫做类）上可以添加一些成员，可以在构造函数内部的this上添加，可以在构造函数本身上添加，通过这两种方式添加的成员，就分别称为实例成员和静态成员</p>\n<p><span style=\"color:#fe2c24;\"><strong><em>实例成员:构造函数中this上添加的成员</em> 静态成员：构造函数本身上添加的成员</strong></span></p>\n<p><strong><span style=\"color:#fe2c24;\">实例成员，只能由实例化的对象来访问 静态成员，只能由构造函数本身来访问 实例化对象的proto指向构造函数的prototype属性指向的对象，实例化的对象可以访问到它后者身上的成员</span></strong></p>\n</blockquote>\n<p></p>\n<p><strong>构造函数生成实例的执行过程：使用面向对象编程时,new关键字做了什么？</strong></p>\n<blockquote>\n<ol><li> <p>新建了一个Object对象</p> </li><li> <p>修改构造函数this的指向，是其指向新建的Object对象，并且执行构造函数</p> </li><li> <p>为Object对象添加了一个<strong>proto</strong>属性，是其指向构造函数的prototype属性</p> </li><li> <p>将这个Object对象返回出去</p> </li></ol>\n</blockquote>\n<p></p>\n<h3 id=\"11%E3%80%81set%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95%EF%BC%9F\">11、set和map数据结构有哪些常用的属性和方法？</h3>\n<p><strong>set数据的特点是数据是唯一的</strong></p>\n<pre><code class=\"language-javascript\">const set1 = new Set()\n\n增加元素 使用 add\nset2.add(4)\n\n是否含有某个元素 使用 has\nconsole.log(set2.has(2)) \n\n查看长度 使用 size\nconsole.log(set2.size) \n\n删除元素 使用 delete\nset2.delete(2)\n\nsize: 返回Set实例的成员总数。\nadd(value)：添加某个值，返回 Set 结构本身。\ndelete(value)：删除某个值。\nclear()：清除所有成员，没有返回值。</code></pre>\n<p><strong><code>Set</code>的不重复性</strong></p>\n<pre><code class=\"language-javascript\">传入的数组中有重复项，会自动去重\nconst set2 = new Set([1, 2, '123', 3, 3, '123'])\n\nSet`的不重复性中，要注意`引用数据类型和NaN\n两个对象都是不用的指针，所以没法去重\nconst set1 = new Set([1, {name: '孙志豪'}, 2, {name: '孙志豪'}])\n\n如果是两个对象是同一指针，则能去重\nconst obj = {name: '我们一样'}\nconst set2 = new Set([1, obj, 2, obj])\n\nNaN !== NaN，NaN是自身不等于自身的，但是在Set中他还是会被去重\nconst set = new Set([1, NaN, 1, NaN])</code></pre>\n<p></p>\n<p><strong>map数据结构</strong></p>\n<blockquote>\n<p><strong>Map`对比`object`最大的好处就是，key不受`类型限制</strong></p>\n</blockquote>\n<pre><code class=\"language-javascript\">\n定义map\nconst map1 = new Map()\n\n新增键值对 使用 set(key, value)\nmap1.set(true, 1)\n\n判断map是否含有某个key 使用 has(key)\nconsole.log(map1.has('哈哈')) \n\n获取map中某个key对应的value\nconsole.log(map1.get(true)) \n\n删除map中某个键值对 使用 delete(key)\nmap1.delete('哈哈')\n\n\n定义map，也可传入键值对数组集合\nconst map2 = new Map([[true, 1], [1, 2], ['哈哈', '嘻嘻嘻']])\nconsole.log(map2) // Map(3) { true =&gt; 1, 1 =&gt; 2, '哈哈' =&gt; '嘻嘻嘻' }</code></pre>\n<p></p>\n<h3 id=\"12%E3%80%81proxy\">12、proxy 的理解</h3>\n<blockquote>\n<p><strong>Proxy</strong> <strong>对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。</strong></p>\n<p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p>\n</blockquote>\n<p></p>\n<h3>13、Es6中新的数据类型symbol</h3>\n<blockquote>\n<p><span style=\"color:#fe2c24;\"><strong>symbol 是es6 加入的，是一个基本数据类型，它代表的是一个独一无二的值，SYMBOL 值是由 SYMBOL函数生成</strong></span>，<strong>也就是说现在我们定义对象的属性名字可以是原有的字符串 也可以是 symbol 类型的，symbol 可以保证不与其他属性名冲突，减少了bug的产生，</strong></p>\n<p>如果那 symbol 对比的话 就是会返回 false</p>\n<p>symbol 他是一个原始类型的值就，<strong>不可以使用 new 关键字，symbol不是对象 没有迭代器的接口 不能去添加属性值，他是类似于字符串的一种类型</strong></p>\n<p><strong>symbol 不能用来四则运算，否则会报错</strong>，只能用显示的方式转为字符串</p>\n<p>symbol 参数里的 a 表示一种修饰符 对当前创建的 symbol 的一种修饰，作为区分 ，否则会混淆</p>\n</blockquote>\n<p></p>\n<h3 id=\"14%E3%80%81iterator%20%3D%3D%20iteration%20%EF%BC%88%E9%81%8D%E5%8E%86%E5%99%A8%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%89\">14、iterator == iteration （遍历器的概念）</h3>\n<blockquote>\n<p><strong>遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作</strong></p>\n<p>Iterator 的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是 ES6 创造了一种新的遍历命令<code>for...of</code>循环，Iterator 接口主要供<code>for...of</code>消费。</p>\n<p>其实iteration == iterator 有三个作用：</p>\n<ol><li> <p><strong>为各种数据结构，提供一个统一的、简便的访问接口；</strong></p> </li><li> <p><strong>使得数据结构的成员能够按某种次序排列；</strong></p> </li><li> <p><strong>主要供<code>for...of</code>消费</strong></p> </li></ol>\n</blockquote>\n<p></p>\n<h3 id=\"15%E3%80%81Object.assign\">15、Object.assign</h3>\n<blockquote>\n<p>Object.assign可以实现对象的合并。它的语法是这样的： <code>Object.assign(target, ...sources)</code></p>\n<p><code>Object.assign</code>会将source里面的<strong>可枚举属性</strong>复制到<code>target</code>。如果和target的已有属性重名，则会覆盖。同时后续的source会覆盖前面的source的同名属性。</p>\n<p>Object.assign复制的是属性值，如果属性值是一个引用类型，那么复制的其实是引用地址，就会存在引用共享的问题</p>\n<p><code>Array.from()</code>方法就是将一个类数组对象或者可遍历对象转换成一个真正的数组。</p>\n<p>那么什么是类数组对象呢？所谓类数组对象，最基本的要求就是具有length属性的对象。</p>\n</blockquote>\n<p></p>\n<p><strong>1、将类数组对象转换为真正数组：</strong></p>\n<pre><code class=\"language-javascript\">let arrayLike = {\n    0: 'tom', \n    1: '65',\n    2: '男',\n    3: ['jane','john','Mary'],\n    'length': 4\n}\nlet arr = Array.from(arrayLike)\nconsole.log(arr) // ['tom','65','男',['jane','john','Mary']]</code></pre>\n<blockquote>\n<p>那么，如果将上面代码中 <code>length</code> 属性去掉呢？实践证明，答案会是一个长度为0的空数组。</p>\n<p>这里将代码再改一下，就是具有 <code>length</code> 属性，但是对象的属性名不再是数字类型的，而是其他字符串型的，代码如下：</p>\n</blockquote>\n<pre><code class=\"language-javascript\">let arrayLike = {\n    'name': 'tom', \n    'age': '65',\n    'sex': '男',\n    'friends': ['jane','john','Mary'],\n    length: 4\n}\nlet arr = Array.from(arrayLike)\nconsole.log(arr)  // [ undefined, undefined, undefined, undefined ]</code></pre>\n<blockquote>\n<p>会发现结果是长度为4，元素均为 undefined 的数组</p>\n<p>由此可见，要将一个类数组对象转换为一个真正的数组，必须具备以下条件：</p>\n<p>1、<span style=\"color:#fe2c24;\"><strong>该类数组对象必须具有 <code>length</code> 属性，用于指定数组的长度。如果没有 <code>length</code> 属性，那么转换后的数组是一个空数组。</strong></span></p>\n<p>2、该类数组对象的属性名必须为数值型或字符串型的数字</p>\n</blockquote>\n<p></p>\n<h3 id=\"16%E3%80%81%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F\">16、谈谈你对模块化开发的理解？</h3>\n<blockquote>\n<p><strong>我对模块的理解是，一个模块是实现一个特定功能的一组方法</strong>。在最开始的时候，js 只实现一些简单的功能，所以并没有模块的概念 ，但随着程序越来越复杂，代码的模块化开发变得越来越重要。</p>\n<p>由于函数具有独立作用域的特点，最原始的写法是使用函数来作为模块，几个函数作为一个模块，但是这种方式容易造成全局变量的污 染，并且模块间没有联系。</p>\n<p>后面提出了对象写法，<strong>通过将函数作为一个对象的方法来实现</strong>，<strong>这样解决了直接使用函数作为模块的一些缺点</strong>，但是这种办法会暴露所 有的所有的模块成员，外部代码可以修改内部属性的值。</p>\n<p><strong>现在最常用的是立即执行函数的写法，通过利用闭包来实现模块私有作用域的建立，同时不会对全局作用域造成污染。</strong></p>\n</blockquote>\n<p></p>\n<h3 id=\"17%E3%80%81js%20%E7%9A%84%E5%87%A0%E7%A7%8D%E6%A8%A1%E5%9D%97%E8%A7%84%E8%8C%83%EF%BC%9F\">17、js 的几种模块规范？</h3>\n<blockquote>\n<p>js 中现在比较成熟的有四种模块加载方案：</p>\n<ul><li> <p><strong>第一种是 CommonJS 方案</strong>，它通过 require 来引入模块，通过 module.exports 定义模块的输出接口。这种模块加载方案是服务器端的解决方案，它是以同步的方式来引入模块的，因为在服务端文件都存储在本地磁盘，所以读取非常快，所以以同步的方式加载没有问题。但如果是在浏览器端，由于模块的加载是使用网络请求，因此使用异步加载的方式更加合适。</p> </li><li> <p><strong>第二种是 AMD 方案</strong>，这种方案采用异步加载的方式来加载模块，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定义在一个回调函数里，等到加载完成后再执行回调函数。require.js 实现了 AMD 规范。</p> </li><li> <p><strong>第三种是 CMD 方案</strong>，这种方案和 AMD 方案都是为了解决异步模块加载的问题，sea.js 实现了 CMD 规范。它和require.js的区别在于模块定义时对依赖的处理不同和对依赖模块的执行时机的处理不同。</p> </li><li> <p><strong>第四种方案是 ES6 提出的方案，使用 import 和 export 的形式来导入导出模块。</strong></p> </li></ul>\n</blockquote>\n<p></p>\n<p><span style=\"color:#956fe7;\"><strong>加油快通关了，通关了你会有收获的。</strong></span></p>\n<p></p>\n<h2 id=\"vue%E9%9D%A2%E8%AF%95%E9%A2%98\">vue面试题</h2>\n<p></p>\n<h2>核心原理部分</h2>\n<h3><strong>mvc mvvm和mvp的区别</strong>？</h3>\n<blockquote>\n<p>MVVM 就是 Model-View-ViewModel 的缩写，MVVM 将视图和业务逻辑分开。</p>\n<p><strong>View：视图层，Model 数据模型，而 ViewModel 是把两者建立通信的桥梁。</strong></p>\n<p><strong>在 MVVM 框架下，View 和 Model 之间没有直接的联系，而是通过 ViewModel 进行交互。View 和 ViewModel 之间以及 Model 和 ViewModel 之间的交互都是双向的，因此 view 数据的变化会同步到 Model 中，而 Model 数据的变化也会立即反映到 View 上。可以说它们两者是实时更新的，互相影响。</strong> ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而 View 和 Model 之间的同步工作完全是自动的，<strong>因此开发者只需要关注业务逻辑，不需要手动操作 DOM，也不需要关注数据状态的同步问题，这些都由 MVVM 统一管理</strong>，</p>\n<p></p>\n<p>整体看来，MVVM比MVC精简很多，不仅简化了业务与界面的依赖，还解决了数据频繁更新的问题，不用再用选择器操作DOM元素。因为在MVVM中，View不知道Model的存在，Model和ViewModel也观察不到View，这种低耦合模式提高代码的可重用性。</p>\n<p>【优点】</p>\n<p>数据源和视图实现了双向绑定，很好的做到了数据的一致性 相比于mvp各层的耦合度更低，一个viewmodel层可以给多个view层共用。</p>\n<p>【缺点】</p>\n<p>因为使用了dataBinding，增加了大量的内存开销，增加了程序的编译时间，项目越大内存开销越大。 数据绑定使得 Bug 很难被调试。<strong>你看到界面异常了，有可能是你 View 的代码有 Bug，也可能是 Model 的代码有问题</strong></p>\n<p></p>\n<p>MVC 全名是 Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范<br/> - Model（模型）：是应用程序中用于处理应用程序数据逻辑的部分。通常模型对象负责在数据库中存取数据<br/> - View（视图）：是应用程序中处理数据显示的部分。通常视图是依据模型数据创建的<br/> - Controller（控制器）：是应用程序中处理用户交互的部分。通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据,也可以将Model的数据用View显示出来</p>\n<p></p>\n<p>【优点】</p>\n<p>耦合性低，方便维护，可以利于分工协作 重用性高</p>\n<p>【缺点】</p>\n<p>使得项目架构变得复杂，对开发人员要求高</p>\n<p></p>\n<p>MVP MVP 是从经典的模式MVC演变而来，它们的基本思想有相通的地方Controller/Presenter负责逻辑的处理，Model提供数据，View负责显示，在MVP中View并不直接使用Model，它们之间的通信是通过Presenter (MVC中的Controller)来进行的</p>\n</blockquote>\n<p></p>\n<h3>Vue底层实现原理</h3>\n<blockquote>\n<p><strong>vue.js是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter和getter，在数据变动时发布消息给订阅者，</strong>触发相应的监听回调 Vue是一个典型的MVVM框架，模型（Model）只是普通的javascript对象，修改它则-视图（View）会自动更新。这种设计让状态管理变得非常简单而直观</p>\n<p><strong>Observer（数据监听器）</strong> : Observer的核心是通过Object.defineProprtty()来监听数据的变动，这个函数内部可以定义setter和getter，每当数据发生变化，就会触发setter。这时候Observer就要通知订阅者，订阅者就是Watcher</p>\n<p><strong>Compile（指令解析器）</strong> : Compile主要做的事情是解析模板指令，将模板中变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加鉴定数据的订阅者，一旦数据有变动，收到通知，更新-视图</p>\n<p><strong>Watcher（订阅者）</strong> : Watcher订阅者作为Observer和Compile之间通信的桥梁，主要做的事情是：</p>\n<ol><li> <p>在自身实例化时往属性订阅器(dep)里面添加自己</p> </li><li> <p>自身必须有一个update()方法</p> </li><li> <p>待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调</p> </li></ol>\n</blockquote>\n<p></p>\n<h3>Vue模版编译原理。</h3>\n<blockquote>\n<p><strong>vue中的模板template无法被浏览器解析并渲染，因为这不属于浏览器的标准，不是正确的HTML语法，所有需要将template转化成一个JavaScript函数，这样浏览器就可以执行这一个函数并渲染出对应的HTML元素，就可以让视图跑起来了，这一个转化的过程，就成为模板编译。</strong></p>\n<p>Vue 的编译过程就是将 template 转化为 render 函数的过程 分为以下三步</p>\n<p>第一步是将 模板字符串 转换成 element ASTs（解析器）</p>\n<p>第二步是对 AST 进行静态节点标记，主要用来做虚拟DOM的渲染优化（优化器）</p>\n<p>第三步是 使用 element ASTs 生成 render 函数代码字符串（代码生成器）</p>\n</blockquote>\n<p></p>\n<h3>vue虚拟dom，diff算法</h3>\n<blockquote>\n<p>虚拟 DOM，其实就是用对象的方式取代真实的 DOM 操作，把真实的 DOM 操作放在内存当中，在内存中的对象里做模拟操作。当页面打开时浏览器会解析 HTML 元素，构建一颗 DOM 树，将状态全部保存起来，在内存当中模拟我们真实的 DOM 操作，操作完后又会生成一颗 dom 树，两颗 DOM 树进行比较，根据 diff 算法比较两颗 DOM 树不同的地方，只渲染一次不同的地方。</p>\n<p>（个人理解）<strong>虚拟dom他不并不是真实的 dom ，是根据模板生成一个js对象（使用createElement，方法），根据这个js对象再去生成真实的dom，对复杂的文档DOM结构，提供一种方便的工具，进行最小化的DOM操作 ，是可以快速的渲染和高效的更新元素，提高浏览器的性能，</strong></p>\n<p>例如，一个 ul 标签下很多个 li 标签，其中只有一个 li 有变化，这种情况下如果使用新的 ul 去替代旧的 ul,因为这些不必要的 DOM 操作而造成了性能上的浪费，但是如果直接使用虚拟节点覆盖旧节点的话，减少了很多的不必要的 DOM 操作。</p>\n<p>我们在渲染页面的时候 会对新的虚拟dom和旧的虚拟dom进行对比 只渲染不同的地方，而不再是像之前只要发生变化，全部的真实dom都要重新渲染，所以提高了渲染的效率。</p>\n<p><span style=\"color:#fe2c24;\"><strong>缺点：</strong></span><strong>首次渲染大量DOM时，由于多了一层虚拟DOM的计算，会比innerHTML插入慢</strong></p>\n</blockquote>\n<h3><strong>diff算法</strong></h3>\n<blockquote>\n<p><strong>diff 算法是一种通过同层的树节点进行比较的高效算法,比较方式：diff整体策略为：深度优先，同层比较</strong></p>\n<p><strong>diff算法</strong> 当data发生改变 会根据新的数据生成一个新的虚拟dom ，新的虚拟dom和旧的虚拟dom进行对比，这个对比的过程就是diff算法，会找到不同地方，只去渲染不同的地方，总的来说就是减少DOM，重绘和回流。</p>\n</blockquote>\n<p></p>\n<p><strong>为什么要用虚拟DOM来描述真实的DOM呢？</strong></p>\n<blockquote>\n<p>创建真实DOM成本比较高，如果用 js对象来描述一个dom节点，成本比较低，另外我们在频繁操作dom是一种比较大的开销。所以建议用虚拟dom来描述真实dom。</p>\n</blockquote>\n<p></p>\n<h3><strong>响应式原理</strong></h3>\n<pre><code class=\"language-javascript\"> vue的响应式原理？\n   什么是响应式，“响应式”，是指当数据改变后，Vue 会通知到使用该数据的代码。例如，视图渲染中使用了数据，数据改变后，视图也会自动更新。\n   Vue 的响应式原理是核心是通过 ES5 的保护对象的 Object.defindeProperty 中的访问器属性中的 get 和 set 方法，data 中声明的属性都被添加了访问器属性，当读取 data 中的数据时自动调用 get 方法，当修改 data 中的数据时，自动调用 set 方法，检测到数据的变化，会通知观察者 Wacher，观察者 Wacher自动触发重新render 当前组件（子组件不会重新渲染）,生成新的虚拟 DOM 树，Vue 框架会遍历并对比新虚拟 DOM 树和旧虚拟 DOM 树中每个节点的差别，并记录下来，最后，加载操作，将所有记录的不同点，局部修改到真实 DOM 树上。\n​\n   \n   \nObject.defineProperty怎么用， 三个参数？，有什么作用啊？\n     Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。\n     Object.defineProperty(obj, prop, {})\n     obj：需要定义属性的对象\n     prop：需要定义的属性\n     {}：要定义或修改的属性描述符。\n     value: \"18\",         // 设置默认值得\n     enumerable: true,    //这一句控制属性可以枚举 enumerable 改为true 就可以参与遍历了   默认值false\n     writable: true,      // 控制属性可以被修改   默认值false\n     configurable: true,  // 控制属性可以被删除   默认值false\n      get // 当有人读取 prop 的时候  get函数就会调用,并且返回就是 sss 的值\n      set // 当有人修改 prop 的时候  set函数就会调用, 有个参数这个参数就是修改后的值\n​\n     \nObject.defineProperty 能定义symbol类型吗？ \n       在ES6中，由于 Symbol类型的特殊性，用Symbol类型的值来做对象的key与常规的定义或修改不同，而Object.defineProperty 是定        义key为Symbol的属性的方法之一。\n    \n   \n    \nvue2和vue3的响应式原理都有什么区别呢？\nvue2 用的是 Object.defindProperty 但是vue3用的是Proxy \nObject.defindProperty虽然能够实现双向绑定了，但是还是有缺点，只能对对象的属性进行数据劫持，所以会深度遍历整个对象，不管层级有多深，只要数组中嵌套有对象，就能监听到对象的数据变化无法监听到数组的变化，Proxy就没有这个问题，可以监听整个对象的数据变化，所以用vue3.0会用Proxy代替definedProperty。\n​\n上面就是一个典型的例子，当我们点击按钮想要根据数组 arr 的下标改变其元素的时候，你会发现 data 中的数据改变了，但是页面中的数据并没有改变。\n         我会用  this.$set( target, key, value ) 来解决\n       参数：\n         {Object | Array} target\n         {string | number} propertyName/index\n         {any} value \n         第一参数时指定要修改的数据 （target）\n         第二个参数就是你要设置数据的下标或者是属性名\n         第三个参数就是现在要修改的数据 （重新赋的值）\n改变/添加 对象属性的时候:this.$set(data 实例,\"属性名(添加的属性名)\",\"属性值(添加的属性值)\")\n改变/添加 数组属性的时候:this.\\$set(data 实例,数组下标,\"改变后的元素(添加的元素)\")\n​\n原因 ： vue在创建实例的时候把data深度遍历所有属性,并使用 Object.defineProperty 把这些属性全部转为 getter/setter。让 Vue 追踪依赖，在属性被访问和修改时通知变化。所以属性必须在 data 对象上存在才能让 Vue 转换它，这样才能让它是响应的。\n​\n为什么要用  this.$set  呢？ this.$set是干什么的?\n      当你发现你给对象加了一个属性，在控制台能打印出来，但是却没有更新到视图上时，也许这个时候就需要用到this.$set（）这个方法了，简单来说this.$set的功能就是解决这个问题的啦。官方解释：向响应式对象中添加一个属性，并确保这个新属性同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新属性，因为 Vue 无法探测普通的新增属性 (比如 this.myObject.newProperty = 'hi')，你会发现vue官网是vue.set，vue.set的用法\n​\n​\n       \n那 Vue.set 和 this.$set 有什么区别 ？\n    Vue.set( ) 是将 set 函数绑定在 Vue 构造函数上，this.$set() 是将 set 函数绑定在 Vue原型上。 </code></pre>\n<pre>\n</pre>\n<h3>vue双向数据绑定原理？</h3>\n<blockquote>\n<p>是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调从而达到数据和视图同步。</p>\n</blockquote>\n<p><strong>主要分为四部分</strong></p>\n<blockquote>\n<p>1、 observer 主要是负责对Vue数据进行递归遍历，使其数据拥有get和set方法，当有数据给某个对象值赋值，就触发 setter 就监听到数据的变化了。（ 如有变动可拿到最新值并通知订阅者 ）</p>\n<p>2、compile 指令解析器负责绑定数据和指令解析。 将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数。一旦数据有变动，收到通知，更新视图</p>\n<p>3、 订阅者 watcher ： Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是 负责数据监听，当数据发生改变，能调用自身的update()方法，并触发Compile中绑定的更新函数</p>\n<p>4、实现一个订阅器 dep： 采用发布者订阅者模式，用来收集订阅者的 watcher，对监听器 observer 和订阅者 watcher 进行统一管理</p>\n</blockquote>\n<p></p>\n<h3>vue3的Proxy 相比于 vue2的defineProperty 的优势</h3>\n<blockquote>\n<p>在vue3 中<br/><strong>Vue3是通过Object.define.proxy 对对象进行代理，从而实现数据劫持。使用Proxy 的好处是它可以完美的监听到任何方式的数据改变，唯一的缺点是兼容性的问题，因为 Proxy 是 ES6 的语法</strong><br/> ​<br/> Vue3.0 摒弃了 Object.defineProperty，改为基于 Proxy 的观察者机制探索。<br/> 首先说一下 Object.defineProperty 的缺点：<br/> ①<strong> Object.defineProperty 无法监控到数组下标的变化，</strong>导致直接通过数组的下标给数组设置值，不能实施响应。<strong> this.$set()解决</strong><br/> ② <strong>Object.defineProperty 只能劫持对象的属性，</strong>因此我们需要对每个对象的每个属性进行遍历。Vue2.X 里，是通过递归 + 遍历 data 对象来实现对数据的监控的，如果属性值也是对象那么需要深度遍历，显然如果能劫持一个完整的对象才是更好的选择。</p>\n<p><br/><strong>而要取代它的 Proxy 有以下两个优点<br/> 可以劫持整个对象，并返回一个新对象。有多种劫持操作(13 种)</strong><br/> 补充：<br/> Proxy 用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。 mdn<br/> Proxy 是 ES6 新增的一个属性，翻译过来的意思就是代理，用在这里表示由它来“代理”某些操作。Proxy 让我们能够以简洁易懂的方式控制外部对象的访问，其功能非常类似于设计模式中的代理模式。</p>\n<p><br/> ​<br/> 1、<strong>vue 中数组中的某个对象的属性发生变化，视图不更新如何解决?<br/>  Object.defineProperty 无法监控到数组下标的变化，导致直接通过数组的下标给数组设置值，不能实施响应。 this.$set()解决</strong><br/>  问题原因：因为 vue 的检查机制在进行视图更新时无法监测 数组中的对象的某个属性值的变化。解决方案如下<br/> 方案一：利用  this.set(this.obj,key,val)<br/> 例：this.set(this.obj,‘k1’,‘v1’)<br/> 方案二：就利用 Object.assign({}，this.obj)创建新对象  <br/><strong>如果是数组就 Object.assign([]，this.obj)<br/> 如果是对象就 Object.assign({}，this.obj)。</strong></p>\n</blockquote>\n<h3>vue.js的两个核心是什么</h3>\n<blockquote>\n<p>灵活的组件应用，高效的数据绑定</p>\n</blockquote>\n<p></p>\n<h3>渐进式框架的理解,vue数据驱动的理解</h3>\n<blockquote>\n<p><strong>渐进式代表的含义是</strong>：主张最少——它是一个轻量级框架，只做了自己该做的事，没有做不该做的事</p>\n<p><strong>每个框架都不可避免会有自己的一些特点，从而会对使用者有一定的要求，这些要求就是主张，主张有强有弱，它的强势程度会影响在业务开发中的使用方式。</strong></p>\n<p>这里的vue数据驱动的是视图，也就是DOM元素，指的是让DOM的内容随着数据的改变而改变框架的理解</p>\n</blockquote>\n<p></p>\n<h3>Vue的SSR是什么？有什么好处？</h3>\n<blockquote>\n<p>SSR全称<code>Server Side Render</code></p>\n<ul><li> <p>有利于SEO：由于是在服务端，将数据填充进HTML之后再推送到浏览器，所以有利于SEO的爬取</p> </li><li> <p>首屏渲染快</p> </li></ul>\n<p>SSR的缺点：</p>\n<ul><li> <p>开发条件会受到限制，服务器端渲染只支持beforeCreate和created两个钩子；</p> </li><li> <p>当需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于Node.js的运行环境；</p> </li><li> <p>更多的服务端负载。</p> </li></ul>\n</blockquote>\n<p></p>\n<h3>vue3.0 与 vue2.0 的区别</h3>\n<blockquote>\n<p>1.<strong>性能提升</strong></p>\n<p>更小巧，更快速；支持摇树优化。支持 Fragments (支持多个根节点)和跨组件渲染；支持自定义渲染器。</p>\n<p>2.<strong>API 变动</strong></p>\n<p>Vue2使用 选项类型API（Options API） 对比Vue3 合成型API（Composition API）</p>\n<p>optionsApi 使用传统api中，新增一个需求，要在data，methods，computed中修改</p>\n<p>compositionApi 我们可以更加优雅的组织我们的代码，函数，让我们的代码更加有序的组合在一起</p>\n<p>3.<strong>重写虚拟 DOM</strong> (Virtual DOM Rewrite)</p>\n<p>随着虚拟 DOM 重写，减少 运行时（runtime）开销。重写将包括更有效的代码来创建虚拟节点。</p>\n<p><strong>vue3 没有了过滤器</strong></p>\n<p><strong>双向数据绑定</strong> 从 Object.defineProperty() 变成了 proxy，通过下标修改数组变化了视图数据没发生变化 this.$set() vue3不需要</p>\n<ol><li> <p>双向数据绑定原理发生了改变，使用proxy替换Object.defineProerty,使用Proxy的优势：</p> </li></ol>\n<ul><li> <p>可直接监听数组类型的数据变</p> </li><li> <p>监听的目标为对象本身，不需要像Object.defineProperty一样遍历每个属性，有一定的性能提升</p> </li><li> <p>可直接实现对象属性的新增/删除</p> </li></ul>\n<p><strong>setup 函数</strong></p>\n<p>3.0新加入了TypeScript以及PWA支持</p>\n<p>默认使用懒加载</p>\n<p>可以不用加上key</p>\n<p>vue3 的watch监听可以进行终止监听</p>\n</blockquote>\n<p><strong>生命周期有了一定的区别 Vue2--------------vue3</strong></p>\n<pre><code class=\"language-javascript\">beforeCreate  -&gt; setup()    开始创建组件之前，创建的是data和method\ncreated    -&gt; setup()\nbeforeMount  -&gt; onBeforeMount   组件挂载到节点上之前执行的函数。\nmounted    -&gt; onMounted 组件挂载完成后执行的函数\nbeforeUpdate  -&gt; onBeforeUpdate 组件更新之前执行的函数。\nupdated    -&gt; onUpdated 组件更新完成之后执行的函数。\nbeforeDestroy -&gt; onBeforeUnmount    组件挂载到节点上之前执行的函数。\ndestroyed   -&gt; onUnmounted  组件卸载之前执行的函数。\nactivated   -&gt; onActivated  组件卸载完成后执行的函数\ndeactivated  -&gt; onDeactivated</code></pre>\n<p></p>\n<h3>vue 与 react的区别</h3>\n<blockquote>\n<p><strong>相同点 ：</strong></p>\n<ul><li> <p>都是使用了虚拟dom</p> </li><li> <p>组件化开发</p> </li><li> <p>父子之间通信单项数据流</p> </li><li> <p>都支持服务端渲染</p> </li></ul>\n<p><strong>不同点：</strong></p>\n<ul><li> <p>reacct 的jsx vue的是 template</p> </li><li> <p>数据变化，react 手动 setState vue自动响应式处理 proxy object.DefineProperty</p> </li><li> <p>react 单向数据流 ，vue双向数据流</p> </li><li> <p>react 的 redux mobx vue 的vuex 。pinia</p> </li></ul>\n</blockquote>\n<p></p>\n<h2>vue生命周期（11个进行扩展延伸）</h2>\n<p></p>\n<h3>声明周期那几个？每一个生命周期的特点,可以做什么。</h3>\n<pre><code class=\"language-javascript\">beforeCreate() 创建前，这个时候data中的数据，还未定义，所以不能使用\ncreated()创建后 最早开始使用 data和methods中数据的钩子函数\n​\nbeforeMount()挂载前 指令已经解析完毕内存中已经生成dom树，但是尚未挂载到页面中去，此时页面还是旧的。\nmounted()挂载后 dom已经渲染完毕，此时页面和内存中都是最新的数据，最早可以操作DOM元素钩子函数\n​\n beforeUpdate()更新前 当视图层的数据发生改变会执行这个钩子 内存更新，但是DOM节点还未更新，数据没有与页面同步\n updated()更新后 数据更新完成以后触发的方法，DOM节点已经更新\n​\n beforeDestroy()即将销毁 data和methods中的数据此时还是可以使用的，可以做一些释放内存的操作\n destroyed()销毁完毕  组件已经全部销毁，Vue实例已经被销毁，Vue中的任何数据都不可用\n \n 其他三个：\nactivated  被 keep-alive 缓存的组件激活时调用。\ndeactivated 被 keep-alive 缓存的组件停用时调用。\nerrorCaptured 2.5.0+ 新增当捕获一个来自子孙组件的错误时被调用\n​\nVue3.0中的生命周期做了一些改动：\nbeforeCreate  -&gt; setup()    开始创建组件之前，创建的是data和method\ncreated       -&gt; setup()\nbeforeMount   -&gt; onBeforeMount  组件挂载到节点上之前执行的函数。\nmounted       -&gt; onMounted  组件挂载完成后执行的函数\nbeforeUpdate  -&gt; onBeforeUpdate 组件更新之前执行的函数。\nUpdate        - &gt; onUpdated组件更新完成之后执行的函数。\nbeforeDestroy -&gt; onBeforeUnmount    组件挂载到节点上之前执行的函数。\ndestroyed     -&gt; onUnmounted    组件卸载之前执行的函数。\n​\n​\n- vue的实例加载完成是在哪个声明周期完成呢\nbeforeCreate\n- vue的dom挂载完成是在哪个声命周期里呢\nmounted\n​\n1、created mounted 的区别？\ncreated 模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图。\nmounted：在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作。\n​\n​\n2、怎么在created里面操作dom?\nthis.$nextTick()将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。它跟全局方法 Vue.nextTick 一样，不同的是回调的 this 自动绑定到调用它的实例上。\n可以根据打印的顺序看到，在created()钩子函数执行的时候DOM 其实并未进行任何渲染，而此时进行DOM操作并无作用，而在created()里使用this.$nextTick()可以等待dom生成以后再来获取dom对象，而通过this.$nextTick()获取到的值为dom更新之后的值\n​\n setTimeout(() =&gt; {\n      console.log(this.$refs.button);\n });\n \n \n3、那 setTimeout this.$nextTick 什么区别呢？\nsetTimeout 将同步转换为异步 this.$nextTick \n​\n this.$nextTick 将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，\n​\n4、this.$nextTick()是宏任务还是微任务啊？ \n 优先是Promise.then方法，是个微任务，这样可以避免多一次队列，进而少一次UI渲染，节省性能\n​\n​\n5、a页面跳转到b页面周期执行\n页面a----beforeCreate undefined\n页面a----created 1\n页面a----beforeMount 1\n页面a----mounted 1\n页面b----beforeCreate undefined\n页面b----created 1\n页面b----beforeMount 1\n页面a----beforeDestroy 1\n页面a----destroyed 1\n页面b----mounted 1\n​\n​\n6、组件 和 页面周期 的执行顺序\n- 页面beforeCreate undefined\n- 页面created 1\n- 页面beforeMount 1\n- 组件beforeCreate undefined\n- 组件created 5555\n- 组件beforeMount 5555\n- 组件mounted 5555\n- 页面mounted 1\n​\n7、父子组件生命周期执行顺序\n加载渲染过程\n父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted\n代码更新过程\n父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated\n代码销毁过程\n父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed\n代码常用钩子简易版\n父create-&gt;子created-&gt;子mounted-&gt;父mounted\n​\n​\n8、补充单一组件钩子执行顺序\n​\nactivated, deactivated 是组件keep-alive时独有的钩子\nbeforeCreate\ncreated\nbeforeMount\nmounted\nbeforeUpdate\nupdated\nactivated\ndeactivated\nbeforeDestroy\ndestroyed\nerrorCaptured\n​\n​\nwatch\n仅仅是数据发生改变的时候会侦听到；\n只是会检测到你写在watch里的那些属性,没写的就不会触发。\n​\nupdated\n执行到它的时候时候是数据发生变化且界面更新完毕；\n不能监听到路由数据(例如网址中的参数)；\n所有的数据发生变化都会调用(消耗性能)；\n每次触发的代码都是同一个\n​\ncomputed\n1、监控自己定义的变量，不用再data里面声明，函数名就是变量名\n2、适合多个变量或对象进行处理后返回一个值(结果)。若这多个变量发生只要有一个发生变化，结果都会变化。\n3、计算的结果具有缓存,依赖响应式属性变化，响应式属性没有变化，直接从缓存中读取结果。\n4、在内部函数调用的时候不用加()。\n5、必须用return返回\n6、不要在computed 中对data中的数据进行赋值操作，这会形成一个死循环。\n​\nmethods不会被缓存：方法每次都会去重新计算结果。methods 方法表示一个具体的操作，主要书写业务逻辑；\n使用 methods 方法编写的逻辑运算，在调用时 add() 一定要加“()”，methods 里面写的多位方法，调用方法一定要有（）。methods方法页面刚加载时调用一次，以后只有被调用的时候才会被调用。我们在长度框和宽度框的值输入完以后，点击“+” methods 方法调用一次。这里很明显我们采用 methods 会更节省资源。\n​\n​\n使用场景？\n​\nwatch：\n1、watch 函数是不需要调用的。\n2、重点在于监控，监控数据发生变化的时候，执行回调函数操作。\n3、当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch\n4、函数名就是你要监听的数据名字\n5、监控一些input框值的特殊处理，适合一个数据影响多个数据。\n6、数据变化时，执行一些异步操作，或开销比较大的操作\n​\ncomputed：\n在模板中放入太多的逻辑会让模板过重且难以维护，在需要对数据进行复杂处理，且可能多次使用的情况下，尽量采取计算属性的方式\n一个需要的结果受多个数据影响的时候，比如购物车结算金额(受到很多处的价格结算)。\n操作某个属性，执行一些复杂的逻辑，并在多处使用这个结果。\n内部函数中多处要使用到这个结果的。\n1、监控自己定义的变量，不用再data里面声明，函数名就是变量名\n2、适合多个变量或对象进行处理后返回一个值(结果)。若这多个变量发生只要有一个发生变化，结果都会变化。\n3、计算的结果具有缓存,依赖响应式属性变化，响应式属性没有变化，直接从缓存中读取结果。\n4、在内部函数调用的时候不用加()。\n5、必须用return返回\n6、不要在computed 中对data中的数据进行赋值操作，这会形成一个死循环。\n​</code></pre>\n<p></p>\n<h3>一般在哪个生命周期请求异步数据</h3>\n<blockquote>\n<p>可以啊钩子函数中的 <code>created</code>、<code>beforeMount</code>、<code>mounted</code> 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。</p>\n<p>在created中最好</p>\n<p>能更快获取到服务端数据，减少页面加载时间，用户体验更好；</p>\n<p>SSR不支持 beforeMount 、mounted 钩子函数，放在 created 中有助于一致性。</p>\n<p>mounted 在请求完数据之后需要对 dom 进行操作的时候可以用到</p>\n</blockquote>\n<p></p>\n<h3>vue中 methods,computed, watch 的区别</h3>\n<blockquote>\n<p>computed 是vue中的计算属性，具有缓存性，当他的依赖于值，发生改变的时候才会重新调用</p>\n<p>methods 是没有缓存的，只要调用，就会执行，一般结合事件来使用</p>\n<p>watch 没有缓存性 监听data中的属性 属性值只要发生变化就会执行 可以利用他的特性做一些异步的操作</p>\n</blockquote>\n<h3>created和mounted区别？</h3>\n<blockquote>\n<p>created：dom渲染前调用，即通常初始化某些属性值</p>\n<p>mounted：在dom渲染后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作</p>\n</blockquote>\n<h3>生命周期钩子是如何实现的</h3>\n<blockquote>\n<p>Vue 的生命周期钩子核心实现是利用发布订阅模式先把用户传入的的生命周期钩子订阅好（内部采用数组的方式存储）然后在创建组件实例的过程中会一次执行对应的钩子方法（发布）</p>\n</blockquote>\n<p></p>\n<p></p>\n<h2>vuex常问的考点</h2>\n<h3>Vuex严格模式</h3>\n<pre><code class=\"language-javascript\">开启严格模式，仅需在创建 store 的时候传入 strict: true：\n\nconst store = new Vuex.Store({\n  // ...\n  strict: true\n})\n在严格模式下，无论何时发生了状态变更且不是由 mutation 函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到。</code></pre>\n<h3>开发环境与发布环境</h3>\n<p><strong>不要在发布环境下启用严格模式</strong>！严格模式会深度监测状态树来检测不合规的状态变更——请确保在发布环境下关闭严格模式，以避免性能损失。</p>\n<p>类似于插件，我们可以让构建工具来处理这种情况：</p>\n<pre><code class=\"language-javascript\">const store = createStore({\n  // ...\n  strict: process.env.NODE_ENV !== 'production'\n})</code></pre>\n<p></p>\n<h3>vuex是什么， state,getters,mutations,actions,modules的用途和用法</h3>\n<blockquote>\n<p><strong>vuex是一个状态管理工具，所谓状态的是就是数据，采用集中式存储管所有组件的状态，是为了结局中大型项目一个数据共享的问题。vuex 他可以将数据保存到本地，数据是响应式的，能够保持数据页面的共享，提高开发效率。</strong></p>\n</blockquote>\n<p><strong>好处：</strong></p>\n<blockquote>\n<p>能够在 vuex 中集中管理共享的数据，易于开发和后期维护 可以做状态管理、采用localstorage保存信息、数据一直存储在用户的客户端中 存储在 vuex 中的数据都是响应式的，能够实时保持数据与页面的同步，能够高效地实现组件之间的数据共享，提高开发 效率</p>\n</blockquote>\n<p><strong>vuex核心：</strong></p>\n<blockquote>\n<ol><li> <p>state：vuex的基本数据，数据源存放地，用于定义共享的数据。</p> </li><li> <p>getter：从基本数据派生的数据，相当于state的计算属性</p> </li><li> <p>mutation：提交更新数据的方法，唯一 一个可以操作state 中数据的方法，必须是同步的，第一个参数是state，第二个参数是cmmi传过来的数据</p> </li><li> <p>action：action是用来做异步操作的，一般用来发请求，在 action 中写入函数，然后在页面中用dispatch调用，然后在 action 中通过commit 去调用 mutation 通过 mutation 去操作state。</p> </li><li> <p>modules：模块化vuex，可以让每一个模块拥有自己的state、mutation、action、getters,使得结构非常清晰，方便管理</p> </li></ol>\n</blockquote>\n<p></p>\n<h3>详述Vuex运行机制</h3>\n<blockquote>\n<p>运行机制：Vuex提供数据（state），来驱动视图（这里指的是Vue组件），视图通过Dispatch派发Action，在Action中可以进一步做一些异步的操作（例如通过ajax请求后端的接口数据），然后通过Commit提交给Mutations，由Mutations去最终更改state。那么为什么要经过Mutations呢？这是因为我们要在Vue调试工具(Devtools)中记录数据的变化，这样可以通过插件去进行进一步的调试。所以说Mutations中只能是纯同步的操作，如果是有异步操作，那么就需要在Actions中进行处理。如果说没有异步操作，那么可以直接由组件进行Commit操作Mutations。</p>\n</blockquote>\n<pre>\n</pre>\n<h3>高级用法辅助函数（语法糖）</h3>\n<blockquote>\n<p>mapState,mapActions,mapMutations,mapGetters</p>\n<ol><li> <p>辅助函数可以把vuex中的数据和方法映射到vue组件中。达到简化操作的目的</p> </li><li> <p>如何使用：</p> </li></ol>\n<p>Import { mapActions, mapGetters, mapMutations, mapState } from 'vuex'</p>\n<p>computed(){ ...mapState(['数据名字'])}</p>\n</blockquote>\n<p></p>\n<h3><strong>Vuex 页面刷新数据丢失怎么解决</strong></h3>\n<blockquote>\n<p>需要做 vuex 数据持久化 一般使用本地存储的方案来保存数据 可以自己设计存储方案 也可以使用第三方插件</p>\n<p>推荐使用 vuex-persist 插件，它就是为 Vuex 持久化存储而生的一个插件。不需要你手动存取 storage ，而是直接将状态保存至 cookie 或者 localStorage 中</p>\n</blockquote>\n<p></p>\n<h3>Vuex 为什么要分模块并且加命名空间</h3>\n<blockquote>\n<p>模块:由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块。方便管理</p>\n</blockquote>\n<p></p>\n<h2>vue的路由</h2>\n<h3>vue-router(路由原理？路由守卫？)</h3>\n<blockquote>\n<p>由于Vue在开发时对路由支持的不足，于是官方补充了vue-router插件。vue的单页面应用是基于路由和组件的，路由用于设定访问路径，并将路径和组件映射起来。传统的页面应用，是用一些超链接来实现页面切换和跳转的。在vue-router单页面应用中，则是路径之间的切换，实际上就是组件的切换。路由就是SPA（单页应用）的路径管理器。再通俗的说，vue-router就是我们WebApp的链接路径管理系统。</p>\n<p><strong>原理 一般源码中，都会用到 window.history 和 location.hash 原理</strong>：<strong>通过改变浏览器地址URL，在不重新请求页面的情况下，更新页面视图</strong>，通过BOM中的location对象，其中对象中的location.hash储存的是路由的地址、可以赋值改变其URL的地址。而这会触发hashchange事件，而通过window.addEventListener监听hash值然后去匹配对应的路由、从而渲染页面的组件 1.一种是# hash,在地址中加入#以欺骗浏览器，地址的改变是由于正在进行页内导航 2.一种是h5的history,使用URL的Hash来模拟一个完整的URL</p>\n</blockquote>\n<blockquote>\n<p>路由有两种模式 hash和history模式 默认是hash</p>\n<p>vue-router的实现原理(核心)：更新视图但不重新请求页面。</p>\n<p>1、hash ——即地址栏 URL 中的#符号，它的特点在 于：hash 虽然出现 URL 中，但不会被包含在 HTTP 请求中，对后端完全没有影 响，因此改变 hash 不会重新加载页面。</p>\n<p>2、history ——利用了 HTML5 History api 在浏览器中没有# 有浏览器兼容问题</p>\n<p>3、history 模式下，前端的 URL 必须和实际向后端发起请求的 URL 一致，否则返回 404 错误。</p>\n</blockquote>\n<p></p>\n<p><strong>•一：全局的守卫</strong></p>\n<p>无论访问哪一个路径，都会触发全局的钩子函数，位置是调用router的方法 router/index.js</p>\n<blockquote>\n<p><strong>router.beforeEach </strong>全局前置守卫 进入路由之前</p>\n<p></p>\n<p><strong>router.beforeResolve</strong> 全局解析守卫，在beforeRouteEnter调用之后调用</p>\n<p>同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被正确调用</p>\n<p></p>\n<p><strong>router.afterEach</strong> 全局后置钩子 进入路由之后</p>\n<p>你也可以注册全局后置钩子，然而和守卫不同的是，这些钩子不会接受 <code>next</code> 函数也不会改变导航本身：</p>\n</blockquote>\n<p><strong>二：组件级路由守卫 放在要守卫的组件里，跟data和methods同级</strong></p>\n<blockquote>\n<ul><li> <p><strong>beforeRouteEnter </strong>进入路由前,此时实例还没创建,无法获取到zhis</p> </li><li> <p><strong>beforeRouteUpdate </strong>(2.2) 路由复用同一个组件时</p> </li><li> <p><strong>beforeRouteLeave </strong>离开当前路由,此时可以用来保存数据,或数据初始化,或关闭定时器等等</p> </li></ul>\n</blockquote>\n<pre><code class=\"language-javascript\">//在组件内部进行配置,这里的函数用法也是和beforeEach一毛一样\nconst Foo = {\n  template: `...`,\n  beforeRouteEnter (to, from, next) {\n    // 在渲染该组件的对应路由被 confirm 前调用\n    // 不！能！获取组件实例 `this`\n    // 因为当守卫执行前，组件实例还没被创建\n  },\n  beforeRouteUpdate (to, from, next) {\n    // 在当前路由改变，但是该组件被复用时调用\n    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，\n    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。\n    // 可以访问组件实例 `this`\n  },\n  beforeRouteLeave (to, from, next) {\n    // 导航离开该组件的对应路由时调用\n    // 可以访问组件实例 `this`\n  }\n}</code></pre>\n<p></p>\n<p><strong>三：单个路由规则独享的守卫 写在路由配置中，只有访问到这个路径，才能触发钩子函数</strong></p>\n<blockquote>\n<p>beforeEnter:(to,from,next)=&gt;{ alert(\"欢迎来到孙志豪的界面\") next() }</p>\n</blockquote>\n<p></p>\n<p><strong>参数</strong></p>\n<ul><li> <p><strong><code>to: Route</code></strong>: 即将要进入的目标 <a href=\"https://link.juejin.cn/?target=https%3A%2F%2Frouter.vuejs.org%2Fzh%2Fapi%2F%23%E8%B7%AF%E7%94%B1%E5%AF%B9%E8%B1%A1\" title=\"路由对象\">路由对象</a></p> </li><li> <p><strong><code>from: Route</code></strong>: 当前导航正要离开的路由对象</p> </li><li> <p><strong><code>next: Function</code></strong>: 一定要调用该方法来 <strong>resolve</strong> 这个钩子。执行效果依赖 <code>next</code> 方法的调用参数。</p> </li></ul>\n<blockquote>\n<p>重定向用哪个属性？</p>\n<p>redirect:”/路径”</p>\n</blockquote>\n<p></p>\n<h3>vue路由的跳转方式有几种</h3>\n<blockquote>\n<p>1、&lt;router-link to=\"需要跳转到页面的路径\"&gt; 2、this.$router.push()跳转到指定的url，并在history中添加记录，点击回退返回到上一个页面</p>\n<p>3、this.$router.replace()跳转到指定的url，但是history中不会添加记录，点击回退到上上个页面</p>\n<p>4、this.$touter.go(n)向前或者后跳转n个页面，n可以是正数也可以是负数</p>\n</blockquote>\n<h3>router.push、router.replace、router.go、router.back的区别？</h3>\n<blockquote>\n<p><code>router.push</code>：跳转，并向history栈中加一个记录，可以后退到上一个页面</p>\n<p><code>router.replace</code>：跳转，不会向history栈中加一个记录，不可以后退到上一个页面</p>\n<p><code>router.go</code>：传正数向前跳转，传负数向后跳转</p>\n<p><code>router.back</code> 返回到上一级页面</p>\n</blockquote>\n<p></p>\n<h3>vue 路由传参数如何实现、query 和 params</h3>\n<blockquote>\n<p>主要通过 query 和 params 来实现</p>\n<p>(1) query可以使用name和path而params只能使用name</p>\n<p>(2) 使用params传参刷新后不会保存，而query传参刷新后可以保存</p>\n<p>(3) Params在地址栏中不会显示，query会显示</p>\n<p>(4) Params可以和动态路由一起使用，query不可以</p>\n<p>（5）to=”/goods?id=1001”this.然后在接收的页面通过 $route.query.id 来接收</p>\n</blockquote>\n<p></p>\n<h3>路由对象route和router的区别</h3>\n<blockquote>\n<p>route 是“路由信息对象”，包括 path,params,hash,query,fullPath,matched,name 等路由信息参数。</p>\n<p>router 是“路由实例对象”，包括了路由的跳转方法(push、go)，钩子函数等。</p>\n</blockquote>\n<p></p>\n<h3>vue-router 路由钩子函数是什么 执行顺序是什么执行顺序</h3>\n<pre><code class=\"language-javascript\">一、打开页面的任意一个页面，没有发生导航切换。\n全局前置守卫beforeEach (路由器实例内的前置守卫)\n路由独享守卫beforeEnter(激活的路由)\n组件内守卫beforeRouteEnter(渲染的组件)\n全局解析守卫beforeResolve(路由器实例内的解析守卫)\n全局后置钩子afterEach(路由器实例内的后置钩子)\n​\n二、如果是有导航切换的(从一个组件切换到另外一个组件)\n组件内守卫beforeRouteLeave(即将离开的组件)\n全局前置守卫beforeEach (路由器实例内的前置守卫)\n组件内守卫beforeRouteEnter(渲染的组件)\n全局解析守卫beforeResolve(路由器实例内的解析守卫)\n全局后置钩子afterEach(路由器实例内的后置钩子)\n​\n​\n完整的导航解析流程\n导航被触发。\n在失活的组件里调用 beforeRouteLeave 守卫。\n调用全局的 beforeEach 守卫。\n在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。\n在路由配置里调用 beforeEnter。\n解析异步路由组件。\n在被激活的组件里调用 beforeRouteEnter。\n调用全局的 beforeResolve 守卫 (2.5+)。\n导航被确认。\n调用全局的 afterEach 钩子。\n触发 DOM 更新。\n调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。</code></pre>\n<p></p>\n<h3>动态路由：</h3>\n<blockquote>\n<p>动态路由是指路由器能够自动的建立自己的路由表，能够根据实际情况的变化实时地进行调整。用开头，后面跟的值是不确定的。这个值是我们要传递的参数 动态路由匹配本质上就是通过url进行传参</p>\n</blockquote>\n<pre><code class=\"language-javascript\">    比如在写一个商品详情页面的时候，我们的页面结构都一样，只是渲染的数据不同而已，这时候就可以根据商品的不同id去设置动态路由，只需要写一个组件，就可以把每个商品的商品详情映射到同一个组件上去。\n    { \n        path: '/Jqxq/:id', // 路由配置拼接\n        name: 'Jqxq',\n        component: Jqxq\n    }\n    跳转 this.$router.push('/Jqxq/'+ item.id)\n    接收  ： this.$route.params.id</code></pre>\n<p></p>\n<h3>嵌套路由：</h3>\n<blockquote>\n<p>vue项目中，界面通常由多个嵌套的组件构成， 必须先清楚这样一件事,一个&lt;router-view/&gt;对应展示的就是一个组件 因此实现嵌套路由有两个要点: 路由对象中定义子路由 用children实现嵌套路由 组件内&lt;router-view/&gt;的使用.</p>\n</blockquote>\n<p></p>\n<h3>路由配置：</h3>\n<pre><code class=\"language-javascript\">export default new Router({\n    mode: 'history', //路由模式，取值为history与hash\n    base: '/', //打包路径，默认为/，可以修改\n    routes: [\n    {\n        path: string, //路径\n        ccomponent: Component; //页面组件\n        name: string; // 命名路由-路由名称\n        components: { [name: string]: Component }; // 命名视图组件\n        redirect: string | Location | Function; // 重定向\n        props: boolean | string | Function; // 路由组件传递参数\n        alias: string | Array&lt;string&gt;; // 路由别名\n        children: Array&lt;RouteConfig&gt;; // 嵌套子路由\n        // 路由单独钩子\n        beforeEnter?: (to: Route, from: Route, next: Function) =&gt; void; \n        meta: any; // 自定义标签属性，比如：是否需要登录\n        icon: any; // 图标\n        // 2.6.0+\n        caseSensitive: boolean; // 匹配规则是否大小写敏感？(默认值：false)\n        pathToRegexpOptions: Object; // 编译正则的选项\n    }\n    ]\n})</code></pre>\n<h3>怎么定义 vue-router 的动态路由? 怎么获取传过来的值</h3>\n<blockquote>\n<p>在 router 目录下的 index.js 文件中，对 path 属性加上 /:id，使用 route 对象的 params.id 获取</p>\n</blockquote>\n<p></p>\n<h3>Vue-router共有几种模式？默认是那种？</h3>\n<blockquote>\n<p>有两种模式 hash和history模式 默认是hash</p>\n<p>1、hash ——即地址栏 URL 中的#符号，它的特点在 于：hash 虽然出现 URL 中，但不会被包含在 HTTP 请求中，对后端完全没有影 响，因此改变 hash 不会重新加载页面。</p>\n<p>2、history ——利用了 HTML5 History api 在浏览器中没有# 有浏览器兼容问题</p>\n<p>history 模式下，前端的 URL 必须和实际向后端发起请求的 URL 一致，如 地址后加上/items/id。后端如果缺少对 /items/id 的路由处理，将返回 404 错误。</p>\n</blockquote>\n<p></p>\n<h3>路由懒加载</h3>\n<blockquote>\n<p>使用原因：在单页应用中，如果没有应用懒加载，运用 webpack 打包后的文件将会异常的大，造成进入首页时，需要加载的内容过多，延时过长，不利于用户体验，而运用懒加载则可以将页面进行划分，需要的时候加载页面，可以有效的分担首页所承担的加载压力，减少首页加载用时 原理：vue 异步组件技术：异步加载，vue-router 配置路由 , 使用 vue 的异步组件技术 , 实现按需加载。</p>\n<p>{ path: '/home', component: () =&gt; import('@/views/home/home.vue') } // 懒加载</p>\n</blockquote>\n<p></p>\n<h3>能说下 vue-router 中常用的路由模式实现原理吗</h3>\n<blockquote>\n<p><strong>hash 模式</strong><br/> location.hash 的值实际就是 URL 中#后面的东西 它的特点在于：hash 虽然出现 URL 中，但不会被包含在 HTTP 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面。<br/> ​<br/> 可以为 hash 的改变添加监听事件<br/> window.addEventListener(\"hashchange\", funcRef, false);<br/> ​<br/> 每一次改变 hash（window.location.hash），都会在浏览器的访问历史中增加一个记录利用 hash 的以上特点，就可以来实现前端路由“更新视图但不重新请求页面”的功能了<br/> 特点：兼容性好但是不美观<br/> ​<br/><strong>history 模式</strong><br/> 利用了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法。<br/> 这两个方法应用于浏览器的历史记录站，在当前已有的 back、forward、go 的基础之上，它们提供了对历史记录进行修改的功能。这两个方法有个共同的特点：当调用他们修改浏览器历史记录栈后，虽然当前 URL 改变了，但浏览器不会刷新页面，这就为单页应用前端路由“更新视图但不重新请求页面”提供了基础。</p>\n</blockquote>\n<p></p>\n<h2>指令部分进行扩展</h2>\n<h3>vue常用修饰以及常见指令</h3>\n<pre><code class=\"language-javascript\">修饰符\n.stop  阻止事件冒泡\n.cpture 设置事件捕获\n.self  只有当事件作用在元素本身才会触发\n.prevent 阻止默认事件，比如超链接跳转\n.once 事件只能触发一次\n.native 触发js原生的事件\n.number 把文本框的内容转换为数字\n.trim  去除文本框左右空格</code></pre>\n<ul><li> <p>常见指令</p> </li></ul>\n<pre><code class=\"language-javascript\">⑴v-bind：给元素绑定属性\n⑵v-on：给元素绑定事件\n⑶v-html：给元素绑定数据，且该指令可以解析 html 标签\n⑷v-text：给元素绑定数据，不解析标签\n⑸v-model：数据双向绑定\n⑹v-for：遍历数组\n⑺v-if：条件渲染指令，动态在 DOM 内添加或删除 DOM 元素\n⑻v-else：条件渲染指令，必须跟 v-if 成对使用\n⑼v-else-if：判断多层条件，必须跟 v-if 成对使用\n⑽v-cloak：解决插值闪烁问题\n⑾v-once：只渲染元素或组件一次\n⑿v-pre：跳过这个元素以及子元素的编译过程，以此来加快整个项目的编译速度\n⒀v-show：条件渲染指令，将不符合条件的数据隐藏(display:none)</code></pre>\n<h3>v-for 与 v-if 的优先级</h3>\n<blockquote>\n<p>v-for 比 v-if 优先，如果每一次都需要遍历整个数组，将会影响速度，尤其是当之需要渲染很小一部分的时候。</p>\n</blockquote>\n<p></p>\n<h3>vue中key 的作用</h3>\n<blockquote>\n<p>“key 值:用于管理可复用的元素。因为 Vue 会尽可能高效地渲染元素,通常会复用已有元素而不是从头开始渲染。这么做使 Vue 变得非常快,但是这样也不总是符合实际需求。 2.2.0+ 的版本里,当在组件中使用 v-for 时,key 是必须的。”</p>\n<p>key是给每一个vnode的唯一id，也是diff的一种优化策略，可以根据key，更准确， 更快的找到对应的vnode节点，更高效的对比虚拟DOM中每个节点是否是相同节点，相同就复用，不相同就删除旧的创建新的</p>\n</blockquote>\n<p></p>\n<p><strong>key 是使用 index 还是 id 啊</strong></p>\n<blockquote>\n<p>当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。key 的作用主要是为了高效的更新虚拟 DOM。</p>\n<p>举例子：加入写一个带有复选框的列表</p>\n<p>选中第一个节点的复选框，点击删除，vue中是这样操作的，删除后新的数据这时会进行比较，第一个节点的标签一样，值不一样，就会复用原来位置的标签，不会做删除和创建，在第一个节点中是将复选框选中的，当我们看见好像是把第一个删除了，但是点击后去看复选框的时候还是选中在第一个，如果是直接将第一个节点删除了那么复选框就不会选中。</p>\n</blockquote>\n<p></p>\n<h3>vue 初始化页面闪动问题。</h3>\n<blockquote>\n<p>能够解决插值表达式闪烁问题，需要在style中设置样式[v-clock]{display:none}</p>\n</blockquote>\n<p></p>\n<h3>v-if和v-show的区别及使用场景？</h3>\n<blockquote>\n<p>v-if 动态的创建或者销毁元素，为true的时候为显示，为false的时候不显示，要使用v-else必须和v-if紧挨着</p>\n<p>v-show 是控制元素的显示或者隐藏，在我们的标签上会看到有display：block，none</p>\n<p>v-if 有更高的切换消耗，而 v-show 有更高的初始化渲染消耗，一般推荐频繁切换的时候使用 v-show 更好，当我们的判断分支比较多的时候，和首次渲染的时候 使用v-if</p>\n</blockquote>\n<p></p>\n<h3>自定义指令，自定义过滤器</h3>\n<blockquote>\n<p>出了vue自带的指定以外，我们如果需要对dom进行底层操作的时候这里就用到了自定义指令，分为一下</p>\n<p>全局： vue.directive:{\"\",{}} 局部：directives:{指令名：{钩子函数}}</p>\n</blockquote>\n<blockquote>\n<ol><li> <p>bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</p> </li><li> <p>inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</p> </li><li> <p>update：所在组件的 VNode 更新时调用，<strong>但是可能发生在其子 VNode 更新之前</strong>。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。</p> </li><li> <p>componentUpdated：指令所在组件的 VNode <strong>及其子 VNode</strong> 全部更新后调用。</p> </li><li> <p>unbind：只调用一次，指令与元素解绑时调用。</p> </li></ol>\n</blockquote>\n<p><strong>参数</strong>:</p>\n<blockquote>\n<p>el：指令所绑定的元素</p>\n<p>binding：一个对象包含一下，</p>\n<p>name：指令名，不包括 v- 前缀。</p>\n<p>value：指令的绑定值</p>\n</blockquote>\n<pre><code class=\"language-javascript\">补充 ： vue3的自定义指令钩子函数?\n​\ncreated - 自定义指令所在组件, 创建后\nbeforeMount - 就是Vue2.x中的 bind, 自定义指令绑定到 DOM 后调用. 只调用一次, 注意: 只是加入进了DOM, 但是渲染没有完成\nmounted - 就是Vue2.x中的 inserted, 自定义指令所在DOM, 插入到父 DOM 后调用, 渲染已完成(最最重要)\nbeforeUpdate - 自定义指令所在 DOM, 更新之前调用\nupdated - 就是Vue2.x中的 componentUpdated\nbeforeUnmount - 销毁前\nunmounted - 销毁后</code></pre>\n<p></p>\n<p><strong>自定义指令原理</strong></p>\n<blockquote>\n<p>1.在生成 ast 语法树时，遇到指令会给当前元素添加 directives 属性</p>\n<p>2.通过 genDirectives 生成指令代码</p>\n<p>3.在 patch 前将指令的钩子提取到 cbs 中,在 patch 过程中调用对应的钩子</p>\n<p>4.当执行指令对应钩子函数时，调用对应指令定义的方法</p>\n</blockquote>\n<p></p>\n<h2>选项对象和常用api</h2>\n<p></p>\n<h3>什么是过滤器？怎么定义全局和局部过滤器</h3>\n<blockquote>\n<p>过滤器是对 即将显示的数据做进一步的筛选处理，然后显示，过滤器并没有改变原来的数据，只是在原数据的基础上产生新的数据</p>\n<p>全局：</p>\n<p>Vue.filter(‘过滤器名’,funciton(val){})</p>\n<p>局部过滤器，定义在组件内部 filters 属性上.它只能在此组件内部使用.</p>\n<p>filters：{过滤器名:funciton(参数){//逻辑代码}}</p>\n<p>使用： 过滤时间，过滤金钱</p>\n</blockquote>\n<p></p>\n<h3>什么是 mixin ？</h3>\n<blockquote>\n<p>Mixin 使我们能够为 Vue 组件编写可插拔和可重用的功能。 mixin 项目变得复杂的时候，多个组件间有重复的逻辑就会用到mixin</p>\n<p>如果希望在多个组件之间重用一组组件选项，例如生命周期 hook、 方法等，则可以将其编写为 mixin，并在组件中简单的引用它。</p>\n<p>然后将 mixin 的内容合并到组件中。如果你要在 mixin 中定义生命周期 hook，那么它在执行时将优化于组件自已的 hook。</p>\n</blockquote>\n<h3 id=\"articleContentId\">在vue.js中mixin和页面执行顺序问题</h3>\n<blockquote>\n<p><span style=\"color:#fe2c24;\"><strong>mixin中的代码先执行，单文件中的后执行。</strong></span></p>\n<p><strong>mixin的beforeCreate </strong>&gt;<strong> 父beforeCreate</strong> &gt;<strong> mixin的created</strong> &gt; <strong>父created</strong> &gt; <strong>mixin的beforeMount </strong>&gt; <strong>父beforeMount</strong> &gt; <strong>子beforeCreate</strong> &gt; <strong>子created</strong> &gt; <strong>子beforeMount</strong> &gt; <strong>子mounted</strong> &gt; <strong>mixin的mounted</strong> &gt;<strong>父mounted</strong></p>\n</blockquote>\n<p></p>\n<h3>nextTick 使用场景和原理</h3>\n<blockquote>\n<p><span style=\"color:#fe2c24;\"><strong>在下次DOM更新循环结束后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的DOM。使用场景是：可以在created钩子函数中拿到dom节点</strong></span></p>\n<p>nextTick 中的回调是在下次 DOM 更新循环结束之后执行的延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。主要思路就是采用微任务优先的方式调用异步方法去执行 nextTick 包装的方法</p>\n</blockquote>\n<h3>vue的删除数组和原生删除数组的区别delete</h3>\n<blockquote>\n<p><strong>删除数组</strong></p>\n<ol><li> <p>delete只是把数组元素的值变成empty/undefined，元素的键不变，数组长度不变。</p> </li><li> <p>Vue.delete直接删除数组，改变数组的键值和长度。</p> </li></ol>\n<p><strong>删除对象</strong></p>\n<p>两者相同，都会把键名（属性/字段）和键值删除。</p>\n</blockquote>\n<h3>Vue.extend 作用和原理</h3>\n<blockquote>\n<p>官方解释：Vue.extend 使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。</p>\n<p>其实就是一个子类构造器 是 Vue 组件的核心 api 实现思路就是使用原型继承的方法返回了 Vue 的子类 并且利用 mergeOptions 把传入组件的 options 和父类的 options 进行了合并 基础用法</p>\n</blockquote>\n<pre><code class=\"language-javascript\">&lt;div id=\"mount-point\"&gt;&lt;/div&gt;\n// 创建构造器\n/* Vue.extend( options )\n  参数：{Object} options\n  用法：使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象；\n       data 选项是特例，需要注意： 在 Vue.extend() 中它必须是函数；*/\nvar Profile = Vue.extend({\n  template: '&lt;p&gt;{<!-- -->{firstName}} {<!-- -->{lastName}} aka {<!-- -->{alias}}&lt;/p&gt;',\n  data: function () {\n    return {\n      firstName: 'Walter',\n      lastName: 'White',\n      alias: 'Heisenberg'\n    }\n  }\n})\n// 创建 Profile 实例，并挂载到一个元素上。\nnew Profile().$mount('#mount-point')\n​\n// 结果如下：\n&lt;p&gt;Walter White aka Heisenberg&lt;/p&gt;\n​\n/*\n可以看到，extend 创建的是 Vue 构造器，而不是我们平时常写的组件实例，所以不可以通过 new Vue({ components: testExtend }) 来直接使用，需要通过 new Profile().$mount(’#mount-point’) 来挂载到指定的元素上。\n*/\n​</code></pre>\n<p></p>\n<h2>组件模块部分（插槽，单页面，通信）</h2>\n<h3>vue 组件父子，子父，兄弟通信</h3>\n<blockquote>\n<p><strong>父传递子如何传递</strong></p>\n<p>（1）在父组件的子组件标签上绑定一个属性，挂载要传输的变量 ​ （2）在子组件中通过props来接受数据，props可以是数组也可以是对象，接受的数据可以直接使用 props: [\"属性名\"] props:{属性名:数据类型}</p>\n<p>子传递父如何传递</p>\n<p>（1）在父组件的子组件标签上自定义一个事件，然后调用需要的方法 ​ （2）在子组件的方法中通过 this.$emit(\"事件\")来触发在父组件中定义的事件，数据是以参数的形式进行传递的</p>\n<p><strong>兄弟组件如何通信</strong></p>\n<p>（1）找到min.js文件，给他vue挂载一个 公共的 $bus Vue.prototype.$bus = new Vue() ​ （2）传送数据的一方 用this.$bus.$emit('事件名'，'传送的数据') ​ （3）在 接收数据的一方用通过 Bus.$on(\"事件名\",(data)=&gt;{data是接受的数据})</p>\n</blockquote>\n<pre><span style=\"color:#fe2c24;\"><strong>12种组件通信</strong></span> <a class=\"link-info\" href=\"https://blog.csdn.net/qq_54753561/article/details/122281196?spm=1001.2014.3001.5502\" title=\"vue12种通信方式\">vue12种通信方式</a></pre>\n<h3>prop 验证，和默认值</h3>\n<blockquote>\n<p>props:会接收不同的数据类型，常用的数据类型的设置默认值的写法，Number, String, Boolean, Array, Function, Object</p>\n<p>所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级prop 的更新流动到子组件中，但是反过来则不行。这样防止子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。若果在子组件中直接修改prop传递的值，Vue会发出警告，</p>\n</blockquote>\n<p></p>\n<p><strong>方法二：通过 vuex 实现 (要了解)</strong></p>\n<blockquote>\n<p>具体实现：vuex 是一个状态管理工具，主要解决大中型复杂项目的数据共享问题，主要包括 state,actions,mutations,getters 和 modules 5 个要素，主要流程：组件通过 dispatch 到 actions，actions 是异步操作，再 actions中通过 commit 到 mutations，mutations 再通过逻辑操作改变 state，从而同步到组件，更新其数据状态</p>\n</blockquote>\n<p></p>\n<h3>组件中写 name 选项有什么作用</h3>\n<blockquote>\n<p>① 项目使用 keep-alive 时，可搭配组件的 name 进行缓存过滤。 ② DOM 做递归组件时需要调用自身 name ③ vue-devtools 调试工具里显示的组件名称是由 vue 中组件 name 决定的</p>\n</blockquote>\n<p></p>\n<h3>自定义组件</h3>\n<blockquote>\n<p>在vue 中的 component 中新建组件，定义好&lt;template&gt;视图层，&lt;script&gt;逻辑层，&lt;style&gt;css样式层。，然后在页面引入，在components 中注册组件 ，在页面中作为标签来使用。</p>\n<p>在vue中开发，都是用的组件化的思想开发的，组件封装的方式可以使我们的开发效率提高，把单页面的每个模块拆分为一个组件件，</p>\n<p>组件封装的方式解决了我们传统项目，开发效率低，难以维护，复用性低等问题。</p>\n<p>使用：比如说封装一个 swiper 首先我们要定义一个props要接受传递的数据，写入响应的逻辑，在通过import引入到页面注册作为标签使用即可。</p>\n</blockquote>\n<p></p>\n<h3>keep-alive 的作用</h3>\n<blockquote>\n<p>keep-alive是Vue提供给我们一个内置组件，会缓存不活动的组件实例，而不是销毁它们， 作为标签使用 包裹在需要缓存的组件外</p>\n<p>在组件切换过程中 把切换出去的组件保留在内存中，防止重复渲染DOM，减少加载时间及性能消耗，提高用户体验性</p>\n<p><strong>作用：</strong> 比如列表页面进入详情，我们想保存列表滚动的位置，我们就可以使用keep-alive保存列表页面的滚动位置。</p>\n<p>组件使用keep-alive以后会新增两个生命周期 actived() deactived()</p>\n<p>activated（组件激活时使用） 与 deactivated（组价离开时调用）</p>\n<p><strong>有两个参数：</strong> 允许组件有条件的进行缓存。</p>\n<p>include - 包裹的组件名会被缓存</p>\n<p>exclude 包裹的组件名都不会被缓存</p>\n</blockquote>\n<h3>keep-alive 缓存beforDestroy 还会执行吗。</h3>\n<blockquote>\n<p><strong>首先，答案是不会的，准确的说是不会直接调用。</strong> 默认情况下，也就是没有设置keep-alive,当离开当前路由时，会直接调用beforeDestroy和destroyed来销毁。 当组件设置keep-alive后，不会直接调用这个销毁周期函数，而是会在生命周期函数新增两个，activated和deactivated; 当退出的时候会执行deactivated 函数</p>\n</blockquote>\n<h3>VUE组件中的data为什么是一个函数</h3>\n<blockquote>\n<p>Object是引用数据类型，如果不用function返回，<strong>每个组件的data都是内存的同一个地址，一个数据改变了其他也改变了</strong>，这就造成了<strong>数据污染</strong>。如果data是一个函数，每个实例的data都在闭包中，就不会各自影响了</p>\n</blockquote>\n<p></p>\n<h3>组件特性及好处、组件的基本组成</h3>\n<blockquote>\n<p>(1) 特性:<strong>重用性、可指定性、互操作性、高内聚性、</strong>低耦合度</p>\n<p>(2) 好处：组件可以扩展HTML元素、封装可重用代码</p>\n<p>template 结构（html代码）</p>\n<p>script行为</p>\n<p>style样式</p>\n</blockquote>\n<p></p>\n<h3>什么是slot？什么是命名slot？slot怎么使用？</h3>\n<blockquote>\n<p>插槽就是父组件往子组件中插入一些内容。</p>\n<p>有三种方式，默认插槽，具名插槽，作用域插槽</p>\n<ol><li> <p>默认插槽就是把父组件中的数据，显示在子组件中，子组件通过一个slot插槽标签显示父组件中的数据</p> </li><li> <p>具名插槽是在父组件中通过slot属性，给插槽命名，在子组件中通过slot标签，根据定义好的名字填充到对应的位置。这样就可以指定多个可区分的slot，在使用组件时灵活地进行插值。</p> </li><li> <p>作用域插槽是带数据的插槽，子组件提供给父组件的参数，父组件根据子组件传过来的插槽数据来进行不同的展现和填充内容。在标签中通过v-slot=\"\"要穿过来的数据“来接受数据。</p> </li></ol>\n</blockquote>\n<p></p>\n<h3>scoped 原理及穿透方法</h3>\n<blockquote>\n<p>vue 中的 scoped 通过在 DOM 结构以及 css 样式上加唯一不重复的标记：data-v-hash 的方式，以保证唯一(通过 PostCSS 转译)，达到样式私有模块化的目的。</p>\n<p>scoped 的 3 条渲染规则： ① 给 HTML 的 DOM 节点加一个不重复的 data 属性，来表示它的唯一性； ② 在每句 css 选择器末尾（编译后的生成的 css 语句）加一个当前组件的 data 属性选择器来私有化样式； ③ 如果组件内部包含有其他组件，只会给其他组件的最外层标签加上 ddan 当前组件的 data 属性。 补充：</p>\n</blockquote>\n<pre><code class=\"language-javascript\">在做项目中，会遇到这么一个问题，即：引用了第三方组件，需要在组件中局部修改第三方组件的样式，而又不想去除scoped属性造成组件之间的样式污染。那么有哪些解决办法呢？\n①不使用scopeds省略（不推荐）；\n② 在模板中使用两次style标签。\n③scoped穿透：/deep/ &gt;&gt;&gt;</code></pre>\n<p></p>\n<h3>函数式组件使用场景和原理</h3>\n<pre><code class=\"language-javascript\">函数式组件与普通组件的区别\n​\n1.函数式组件需要在声明组件是指定 functional:true\n2.不需要实例化，所以没有this,this通过render函数的第二个参数context来代替\n3.没有生命周期钩子函数，不能使用计算属性，watch\n4.不能通过$emit 对外暴露事件，调用事件只能通过context.listeners.click的方式调用外部传入的事件\n5.因为函数式组件是没有实例化的，所以在外部通过ref去引用组件时，实际引用的是HTMLElement\n6.函数式组件的props可以不用显示声明，所以没有在props里面声明的属性都会被自动隐式解析为prop,而普通组件所有未声明的属性都解析到$attrs里面，并自动挂载到组件根元素上面(可以通过inheritAttrs属性禁止)\n​\n​\n优点 1.由于函数式组件不需要实例化，无状态，没有生命周期，所以渲染性能要好于普通组件 2.函数式组件结构比较简单，代码结构更清晰\n使用场景：\n一个简单的展示组件，作为容器组件使用 比如 router-view 就是一个函数式组件\n“高阶组件”——用于接收一个组件作为参数，返回一个被包装过的组件</code></pre>\n<p></p>\n<h2>vue的项目中问题</h2>\n<h3>单页面应用和多页面应用区别以及优缺点，</h3>\n<blockquote>\n<p>单页面：只有一个html页面，跳转方式是组件之间的切换</p>\n<p>优点：跳转流畅、组件化开发、组件可复用、开发便捷</p>\n<p>缺点：首屏加载过慢</p>\n<p>多页面：有多个页面，跳转方式是页面之间的跳转</p>\n<p>优点：首屏加载块</p>\n<p>缺点：跳转速度慢</p>\n</blockquote>\n<p></p>\n<h3>为什么要使用脚手架</h3>\n<blockquote>\n<p>快速开始一个vue项目，不用手动配置，直接开发</p>\n</blockquote>\n<p></p>\n<h3>口喷axios封装</h3>\n<blockquote>\n<p>首先要安装axios，一般我会在项目的src目录中，新建一个network文件夹,作为我们的网络请求模块，然后在里面新建一个http.js和一个api.js文件和一个reques.js。</p>\n<p>http.js文件用来封装我们的axios basUrl Tiemout，</p>\n<p>api.js用来统一管理我们的接口url,</p>\n<p>request.js中添加请求拦截和响应拦截。在请求拦截中，会给请求头添加token字段，还有loading动画的开启。在响应拦截中，可以做一些loading动画的关闭，还有可以根据后端返回的状态码，做一些检验token是否有效或者过期的操作。</p>\n<p>接着就是做一些axios进行的api接口的封装，这里我用到了async，await封装请求接口函数，这样可以将异步操作同步化操作，代码更加友好，避免回调地域的出现。</p>\n</blockquote>\n<p></p>\n<h3>vue中如何解决跨域问题？</h3>\n<p>在vue开发中实现跨域：在vue项目根目录下找到vue.config.js文件（如果没有该文件则自己创建），在proxy中设置跨域</p>\n<pre><code class=\"language-javascript\">\ndevServer: {\n    proxy: {  //配置跨域\n      '/api': {\n        target: 'http://121.121.67.254:8185/',  //这里后台的地址模拟的;应该填写你们真实的后台接口\n        changOrigin: true,  //允许跨域\n        pathRewrite: {\n          /* 重写路径，当我们在浏览器中看到请求的地址为：http://localhost:8080/api/core/getData/userInfo 时\n            实际上访问的地址是：http://121.121.67.254:8185/core/getData/userInfo,因为重写了 /api\n           */\n          '^/api': '' \n        }\n      },\n    }\n  },</code></pre>\n<p></p>\n<h3>assets和static的区别？</h3>\n<blockquote>\n<p>assets中的文件会经过webpack打包，重新编译，推荐在assets存放js等需要打包编译的文件。</p>\n<p>static中的文件，不会打包编译。static中的文件只是复制一遍。static中建议放一些外部第三方文件，自己的放assets里，别人的放static中。（图片推荐放在static里）</p>\n</blockquote>\n<p></p>\n<h3>Vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？</h3>\n<blockquote>\n<p>不会立即同步执行重新渲染。Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化， Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。</p>\n<p>如果同一个watcher被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环tick中，Vue 刷新队列并执行实际（已去重的）工作。</p>\n</blockquote>\n<p></p>\n<h3>多环境变量</h3>\n<blockquote>\n<p>首先是通过在根目录下创建.env.*（配置文件）文件，development 本地开发环境配置、staging 测试环境配置、production 正式环境配置（生产环境）。因为我在创建的文件中并没有定义很多变量，只定义了基础的env，所以需要在src目录下创建一个config文件夹，创建对应的环境变量文件，用来管理不同的环境。在config中创建对应的文件是为了后期修改起来方便，不需要重启项目，符合开发习惯。之后就是根据需要的环境，在封装的axios中通过解构赋值的方式导入，放在baseURL中就可以使用。</p>\n</blockquote>\n<p></p>\n<h3>element-ui和vant-ui按需引入</h3>\n<blockquote>\n<p>首先安装按需引入的插件，在babel.config.js中添加按需引入的配置，创建一个plugin文件夹，定义一个js文件用来存放按需引入的代码，之后在建好的js文件中首先导入vue，再导入需要的vant-ui插件，通过vue.use()全局注入。修改样式可以用样式穿透 /deep/</p>\n</blockquote>\n<p></p>\n<h3>Vue 解决了什么问题</h3>\n<blockquote>\n<p>① 虚拟 dom：dom 操作时非常耗性能的，不再使用原生的 dom 操作节点，极大的解放 dom 操作，但具体操作的还是 dom，不过是换了一种方式。提供了很多指令当然需要 对 dom 进行底层操作的时候就用到自定义指令</p>\n<p>② 视图、数据、结构分离：使数据的更改更为简单，只需要操作数据就能完成相关操作。</p>\n<p>③ 组件化：把一个单页应用中的各种模块拆分到一个一个单独的组件中，便于开发，以及后期的维护</p>\n</blockquote>\n<p></p>\n<h3>Vue.js 的特点</h3>\n<blockquote>\n<p>简洁：页面由 HTML 模板+Json 数据+Vue 实例组成 数据驱动：自动计算属性和追踪依赖的模板表达式</p>\n<p>组件化：用可复用、解耦的组件来构造页面 轻量：代码量小，不依赖其他库 快速：精确有效批量 DOM 更新 模板友好：可通过 npm，bower 等多种方式安装，很容易融入 Vue 的核心库只关注视图层，并且非常容易学习</p>\n</blockquote>\n<p></p>\n<h3>请说出 vue.cli 项目中 src 目录每个文件夹和文件的用法</h3>\n<blockquote>\n<p>assets 文件夹是放静态资源；</p>\n<p>components 是放组件；</p>\n<p>router 是定义路由相关的配置;</p>\n<p>view 视图；</p>\n<p>app.vue 是一个应用主组件；</p>\n<p>main.js 是入口文件</p>\n</blockquote>\n<p></p>\n<h3>描述下 vue 从初始化页面–&gt;修改数据–&gt;刷新页面 UI 过程？</h3>\n<blockquote>\n<p>当 Vue 进入初始化阶段时，一方面 Vue 会遍历 data 中的属性，并用 Object.defineProperty 将它转化成 getter/setterd 的形式，实现数据劫持；</p>\n<p>另一方面，Vue 的指令编译器 Compiler 对元素节点的各个指令进行解析，初始化视图，并订阅 Watcher 来更新视图，此时 Watcher 会将自己添加到消息订阅器 Dep 中，此时初始化完毕。<br/> 当数据发生变化时，触发 Observer 中 setter 方法，立即调用 Dep.notify( )，Dep 这个数组开始遍历所有的订阅者，并调用其 update 方法，Vue 内部再通过 diff 算法，patch 相应的更新完成对订阅者视图的改变。</p>\n</blockquote>\n<h3>Vue 怎么兼容 IE</h3>\n<blockquote>\n<p>使用 babel-polyfill 插件,和前缀名 hack</p>\n</blockquote>\n<p></p>\n<h3>Vue 怎么重置 data</h3>\n<blockquote>\n<p>使用 Object.assign()，vm.data 可 以 获 取 当 前 状 态 下 的 data ，</p>\n<p>Object.assign(this.$data, this.$options.data())</p>\n</blockquote>\n<p></p>\n<h3>vue-router 登陆权限的判断</h3>\n<blockquote>\n<p>vue-router的登陆权限判断主要是在全局钩子函数中进行的，我们在router.js文件中的定义路由里，将需要登陆权限的页面加上meta属性，值是对象的形式，然后在该对象中自定义一个属性，属性值就是一个Boolean值，这时候在main.js文件的全局钩子函数中进行判断，如果需要跳转的页面的自定义属性值为true，那么将进行判断其是否登录，如果没有登录，则告诉用户登录，如果有登录，那么进行页面跳转。</p>\n</blockquote>\n<p></p>\n<h3>vue-cli 替我们做了哪些工作</h3>\n<blockquote>\n<p>vue-cli 是基于 Vue.js 进行快速开发的完整系统，也可以理解成是很多 npm 包的集合。</p>\n<p>vue-cli 完成的功能：</p>\n<p>.vue 文件 --&gt; .js 文件 ES6 语法 --&gt; ES5 语法 Sass,Less,Stylus --&gt; CSS 对 jpg,png,font 等静态资源的处理 热更新 定义环境变量，区分 dev 和 production 模式 如果开发者需要补充或修改默认设置，需要在 package.json 同级下新建一个 vue.config.js 文件</p>\n</blockquote>\n<p></p>\n<h3>Vue 如何检测数组变化</h3>\n<blockquote>\n<p>数组考虑性能原因没有用 defineProperty 对数组的每一项进行拦截，<strong>而是选择对 7 种数组</strong><span style=\"color:#fe2c24;\"><strong>（push,shift,pop,splice,unshift,sort,reverse）</strong></span><strong>方法进行重写(AOP 切片思想)</strong></p>\n<p>所以在 Vue 中修改，数组的索引和长度是无法监控到的。需要通过以上 7 种变异方法修改数组才会触发数组对应的 watcher 进行更新</p>\n</blockquote>\n<p></p>\n<h3>vue 中使用了哪些设计模式</h3>\n<blockquote>\n<p>1.工厂模式 - 传入参数即可创建实例 虚拟 DOM 根据参数的不同返回基础标签的 Vnode 和组件 Vnode</p>\n<p>2.单例模式 - 整个程序有且仅有一个实例 vuex 和 vue-router 的插件注册方法 install 判断如果系统存在实例就直接返回掉</p>\n<p>3.发布-订阅模式 (vue 事件机制)</p>\n<p>4.观察者模式 (响应式数据原理)</p>\n<p>5.策略模式 策略模式指对象有某个行为,但是在不同的场景中,该行为有不同的实现方案-比如选项的合并策略</p>\n</blockquote>\n<p></p>\n<h3>如何解决vue首屏加载过慢？</h3>\n<blockquote>\n<p>① 把不常改变的库放到 index.html 中，通过 cdn 引入</p>\n</blockquote>\n<p>然后找到 build/webpack.base.conf.js 文件，在 module.exports = { } 中添加以下代码：</p>\n<pre><code class=\"language-javascript\">externals: {\n'vue': 'Vue',\n'vue-router': 'VueRouter',\n'element-ui': 'ELEMENT',\n}</code></pre>\n<blockquote>\n<p>②vue 路由懒加载，图片懒加载，使用异步组件，按需加载</p>\n<p>③ 不生成 map 文件，找到 config/index.js 文件，修改为 productionSourcceMap：false</p>\n<p>④vue 组件尽量不要全局引入</p>\n<p>⑤ 使用更轻量级的工具库</p>\n<p>⑥ 开启 gzip 压缩：这个优化是两方面的，前端将文件打包成.gz 文件，然后通过 nginx 的配置，让浏览器直接解析.gz 文件。</p>\n<p>⑦ 首页单独做服务端渲染：如果首页真的有瓶颈，可以考虑用 node 单独做服务端渲染，而下面的子页面仍用 spa 单页的方式交互。这里不推荐直接用 nuxt.js 服务端渲染方案，因为这样一来增加了学习成本，二来服务端的维护成本也会上升，有时在本机测试没问题，在服务端跑就有问题，为了省心，还是最大限度的使用静态页面较好。</p>\n</blockquote>\n<p></p>\n<h3>Vue和JQuery的区别在哪?为什么放弃JQuery用Vue?</h3>\n<blockquote>\n<p><strong>jQuery是直接操作DOM，Vue不直接操作DOM，Vue的数据与视图是分开的，Vue只需要操作数据就行它是个框架</strong></p>\n<p>jQuery的操作DOM行为是频繁的，而Vue利用虚拟DOM的技术，大大提高了更新DOM时的性能它是个库</p>\n<p><strong>Vue中不倡导直接操作DOM，开发者只需要把大部分精力放在数据层面上</strong></p>\n<p>Vue集成了一些库，大大提高开发效率，例如Route、Vuex等等</p>\n</blockquote>\n<p></p>\n<h3>你都做过哪些Vue的性能优化？</h3>\n<blockquote>\n<p>尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher v-if和v-for不能连用 v-if 和 v-show 区分使用场景 v-for 遍历必须加 key，key 最好是 id 值，且避免同时使用 v-if 如果需要使用v-for给每项元素绑定事件时使用事件代理</p>\n<p>SPA 页面采用keep-alive缓存组件 在更多的情况下，使用v-if替代v-show 使用路由懒加载、异步组件</p>\n<p>防抖、节流 第三方模块按需导入</p>\n<p>长列表滚动到可视区域动态加载,不需要响应式的数据不要放到 data 中（可以Object.freeze() 冻结数据）</p>\n<p>图片懒加载</p>\n<p>SEO优化 预渲染</p>\n<p>服务端渲染SSR 打包优化,</p>\n<p>压缩代码 Tree Shaking/Scope Hoisting</p>\n<p>使用cdn加载第三方模块 多线程打包happypack splitChunks抽离公共文件 sourceMap优化 骨架屏</p>\n<p>PWA 还可以使用缓存(客户端缓存、服务端缓存)优化、服务端开启gzip压缩等。防止内部泄漏，组件销毁后把全局变量和事件销毁</p>\n</blockquote>\n<p></p>\n<h1 id=\"js%E7%9A%84%E5%A4%A7%E5%B1%B1\">js的大山</h1>\n<h3 id=\"%E4%BD%BF%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E6%97%B6%2Cnew%E5%85%B3%E9%94%AE%E5%AD%97%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F\">使用面向对象编程时,new关键字做了什么？</h3>\n<blockquote>\n<ol><li> <p>新建了一个Object对象</p> </li><li> <p>修改构造函数this的指向，是其指向新建的Object对象，并且执行构造函数</p> </li><li> <p>为Object对象添加了一个<strong>proto</strong>属性，是其指向构造函数的prototype属性</p> </li><li> <p>将这个Object对象返回出去</p> </li></ol>\n</blockquote>\n<p></p>\n<p></p>\n<h3 id=\"class%E4%B8%8Eclass%E7%BB%A7%E6%89%BF\"><span style=\"color:#fe2c24;\">es6和es5的继承（继承不用搞那么麻烦，项目中还是用 class）</span></h3>\n<p><strong>原型链继承</strong></p>\n<blockquote>\n<p><strong>父类的实例作为子类的原型,易于实现，<span style=\"color:#fe2c24;\">父类的新增实例与属性子类都能访问，创建子类实例，不能向父类构造函数中传参数。</span></strong></p>\n</blockquote>\n<pre><code class=\"language-javascript\">     原型链继承\n     实现：\n         父类的实例作为子类的原型\n         可以在子类中增加实例属性，如果要新增加原型属性和方法需要在new 父类构造函数的后面\n     优点：\n         简单，易实现 父类的新增实例与属性子类都能访问\n     缺点：\n     \t 无法实现多继承  创建子类实例时，不能向父类构造函数中传参数\n\n    function Person() {\n        this.a = true\n    }\n    Person.prototype.fn = function () {\n        console.log('我是父类')\n    }\n\n    function Son() {\n        this.b = false\n    }\n     这里是关键 创建 Person 的实例 然后赋值给 Son 的原型\n    Son.prototype = new Person()\n    let xiaoming = new Son()\n    xiaoming.fn()\n    console.log(xiaoming.a)\n</code></pre>\n<p><strong>构造函数继承</strong>（伪造对象、经典继承）</p>\n<blockquote>\n<p><strong>不能继承原型属性/方法,可以实现多继承，可以传参，无法复用，</strong></p>\n</blockquote>\n<pre><code class=\"language-javascript\">    构造函数继承\n    实现：\n       在子类内,使用call()调用父类方法,并将父类的this修改为子类\n       的this.相当于是把父类的实例属性复制了一份放到子类的函数内.\n    优点：\n\t   解决了子类构造函数向父类构造函数中传递参数\n       可以实现多继承（call或者apply多个父类）\n    缺点：\n\t   方法都在构造函数中定义，无法复用\n\t   不能继承原型属性/方法，只能继承父类的实例属性和方法\n\n    function Father(age, name) {\n        this.a = '22'\n    }\n    function Children() {\n        Father.call(this)\n    }\n    let Class = new Children()\n    console.log(Class.a);</code></pre>\n<p><strong>组合继承</strong></p>\n<blockquote>\n<p><strong>通过call 对实例属性的继承，原型链对原型方法的继承， 调用多次</strong></p>\n</blockquote>\n<pre><code class=\"language-javascript\">   组合继承\n    实现：\n       组合上述两种方法就是组合继承。用原型链实现对原型属性和方法的继承，\n       借用构造函数技术来实现实例属性的继承。\n    缺点：\n\t   由于调用了两次父类，所以产生了两份实例\n    优点：\n\t   函数可以复用\n\t   不存在引用属性问题\n\t   可以继承属性和方法，并且可以继承原型的属性和方法\n    \n\n    function Father(name) { // 这里的name 就是 Son 传过来的\n        this.name = name\n        this.colors = [1, 2]\n    }\n\n    Father.prototype.sayName = function () {\n        alert(this.name)\n    }\n\n    function Son(name, age) {\n        //继承实例属性，第一次调用Father()\n        Father.call(this, name) // 这里通过 call 传过去 name  继承实例属性\n        this.age = age\n    }\n    Son.prototype = new Father() // 继承父类方法，第二次调用 Father\n    Son.prototype.ff = function () { // 子类的方法\n        console.log('666');\n    }\n    var aa = new Son('小明', 5)\n    aa.colors.push(3)\n    console.log(aa); // 打印了 父类的属性 和方法   以及子类的方法\n    var bb = new Son('小红', 50)\n    aa.colors.push(999999)\n    console.log(bb); // 打印了 父类的属性 和方法   以及子类的方法</code></pre>\n<p><strong>Es6有class继承</strong>:</p>\n<blockquote>\n<p><strong>首先利用class构造一个父类，然后利用extends与super实现子类继承</strong></p>\n</blockquote>\n<pre><code class=\"language-javascript\">ES6类继承extends\nextends关键字主要用于类声明或者类表达式中，以创建一个类，该类是另一个类的子类。其中constructor表示构造函数，一个类中只能有一个构造函数，有多个会报出SyntaxError错误,如果没有显式指定构造方法，则会添加默认的 constructor方法，使用例子如下。\nclass Rectangle {\n    // constructor\n    constructor(height, width) {\n        this.height = height;\n        this.width = width;\n    }\n    \n    // Getter\n    get area() {\n        return this.calcArea()\n    }\n    \n    // Method\n    calcArea() {\n        return this.height * this.width;\n    }\n}\n\nconst rectangle = new Rectangle(10, 20);\nconsole.log(rectangle.area);\n// 输出 200\n\n-----------------------------------------------------------------\n// 继承\nclass Square extends Rectangle {\n\n  constructor(length) {\n    super(length, length);\n    \n    // 如果子类中存在构造函数，则需要在使用“this”之前首先调用 super()。\n    this.name = 'Square';\n  }\n\n  get area() {\n    return this.height * this.width;\n  }\n}\n\nconst square = new Square(10);\nconsole.log(square.area);\n// 输出 100</code></pre>\n<h3 style=\"margin-left:.0001pt;text-align:justify;\">ES5继承和ES6继承的区别：</h3>\n<blockquote>\n<p style=\"margin-left:.0001pt;text-align:justify;\">es5继承首先是在子类中创建自己的this指向，最后将方法添加到this中</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">Child.prototype=new Parent() || Parent.apply(this) || Parent.call(this)</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">es6继承是使用class关键字先创建父类的实例对象this，最后在子类class中修改this</p>\n</blockquote>\n<h3 id=\"javascript%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE\">javascript原型与原型链</h3>\n<blockquote>\n<ol><li> <p><strong>每个函数都有一个prototype属性，被称为显示原型</strong></p> </li><li> <p><strong>每个实例对象都会有<code>_ _proto_ _</code>属性,其被称为隐式原型</strong></p> </li><li> <p><strong>每一个实例对象的隐式原型<code>_ _proto_ _</code>属性指向自身构造函数的显式原型prototype</strong></p> </li><li> <p><strong>每个prototype原型都有一个constructor属性，指向它关联的构造函数。</strong></p> </li></ol>\n</blockquote>\n<p></p>\n<p><strong>原型链</strong></p>\n<blockquote>\n<p><strong>获取对象属性时，如果对象本身没有这个属性，那就会去他的原型<code>__proto__</code>上去找，如果还查不到，就去找原型的原型，一直找到最 顶层(<code>Object.prototype</code>)为止。Object.prototype对象也有proto属性值为null。链式查找机制叫原型链。</strong></p>\n</blockquote>\n<p></p>\n<h3 id=\"javascript%20%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F\">javascript 创建对象的几种方式</h3>\n<blockquote>\n<p>1、我们一般使用字面量的形式直接创建对象</p>\n<p>（1）<strong>第一种是工厂模式</strong>，工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。</p>\n<p>（2）<strong>第二种是构造函数模式</strong>。js 中每一个函数都可以作为构造函数，只要一个函数是通过 new 来调用的，那么我们就可以把它称为构造函数。</p>\n<p>（3）<strong>第三种模式是原型模式</strong>，因为每一个函数都有一个 prototype 属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。</p>\n<p>（4）<strong>第四种模式是组合使用构造函数模式和原型模式</strong>，这是创建自定义类型的最常见方式。</p>\n<p>（5）<strong>第五种模式是动态原型模式</strong>，这一种模式将原型方法赋值的创建过程移动到了构造函数的内部，通过对属性是否存在的判断，可以实现仅在第一次调用函数时对原型对象赋值一次的效果。</p>\n<p>（6）<strong>第六种模式是寄生构造函数模式</strong>，这一种模式和工厂模式的实现基本相同，</p>\n</blockquote>\n<p></p>\n<h3 id=\"%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F\">什么是设计模式？</h3>\n<p><strong>概念：</strong></p>\n<blockquote>\n<p><strong>设计模式</strong><strong>是一套被反复使用的代码，设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 设计模式让代码变得工程化，设计模式是软件工程的基石。</strong></p>\n</blockquote>\n<blockquote>\n<p>1、js工厂模式,去做同样的事情，实现同样的效果,解决多个相似的问题这时候需要使用工厂模式</p>\n<p>2、发布订阅模式,通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p>\n<p>3、单例模式 单例模式 保证一个类仅有一个实例，并提供一个访问它的全局访问点</p>\n</blockquote>\n<p></p>\n<h3 id=\"constructor%EF%BC%8Cproto%EF%BC%8Cprototype%E7%9A%84%E4%B8%89%E8%A7%92%E5%85%B3%E7%B3%BB%E3%80%82\">constructor，proto，prototype的三角关系。</h3>\n<blockquote>\n<p><strong>构造函数的prototype指向原型对象</strong></p>\n<p><strong>实例对象的proto指向构造函数的prototype所指向原型对象</strong></p>\n<p><strong>原型对象的constructor指向构造函数</strong></p>\n</blockquote>\n<p></p>\n<h3 id=\"%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%EF%BC%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9\">面向过程，面向对象，面向过程和面向对象的优缺点</h3>\n<blockquote>\n<p><strong>一、面向过程：面向过程就是分析出实现需求所需要的步骤，通过函数一步一步实现这些步骤，接着依次调用即可。</strong></p>\n<p><strong>二、面向对象：将数据与函数绑定到一起，进行封装，这样能够更快速的开发程序，减少了重复代码的重写过程面向过程：</strong></p>\n<p>优点：性能上它是优于面向对象的，因为类在调用的时候需要实例化，开销过大。</p>\n<p>缺点：不易维护、复用、扩展</p>\n<p>用途：单片机、嵌入式开发、Linux/Unix等对性能要求较高的地方</p>\n<p>面向对象:</p>\n<p><span style=\"color:#fe2c24;\"><strong>面向对象有三大特性：封装，继承，多态。</strong></span></p>\n<p>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护 。</p>\n<p>缺点：性能比面向过程低</p>\n</blockquote>\n<p></p>\n<p></p>\n<h1 id=\"%E6%89%A9%E5%B1%95%E9%9D%A2%E8%AF%95%E9%A2%98\">扩展面试题</h1>\n<h3>spa</h3>\n<blockquote>\n<p>spa 就是我们的单页面应用，spa 应用就是只有一个html页面，在vue中可以通过vue-router 来进行页面的切换的，而非刷新整个页面，可以实现无刷新切换页面的技术</p>\n<p>SPA的原理?<br/> 通过这一点可以用js监听url中hash值的变化 onhashchange 事件在当前 URL 的锚部分(以 '#' 号为开始) 发生改变时触发 。哈希值的变换并不会引发页面的刷新和跳转,当监听到hash变化,就可以动态的切换组件,就可以实现无刷新切换页面技术</p>\n<p></p>\n<p><strong>spa 的优点？</strong><br/><strong>页面切换快：</strong><br/> 页面每次切换跳转时，并不需要做`html`文件的请求，这样就节约了很多`http`发送时延，我们在切换页面的时候速度很快。<br/><strong>用户体验好：</strong><br/> 页面片段间的切换快，在网络环境差的时候, 因为组件已经预先加载好了, 并不需要发送网络请求, 所以用户体验好<br/><strong>转场动画</strong></p>\n<p></p>\n<p><strong>spa 的缺点？</strong><br/> 首屏加载比较慢因为要请求一次html同时还要发送一次js请求，两次请求回来了首屏才会显示<br/> 不利于SEO <br/> seo 效果较差 因为搜索引擎只识别html里面的内容，并不识别js里的内容，因为单页面就是js渲染出来的，影响网站的排名</p>\n</blockquote>\n<h3>mpa</h3>\n<blockquote>\n<p>MPA多页面应用程序 指的就是有多个独立的html页面，每个页面必须重复加载html js css 资源，多页面跳转需要整个页面资源刷新。</p>\n<p><strong>优点</strong><br/> 1、首屏加载速度快<br/> 当我们访问页面的时候，服务器只返回了一个html，页面就展示出来了，只发了一次http请求，所以页面显示非常快.<br/> 2、SEO效果好<br/> 因为搜索引擎在做网站排名的时候，要根据网页的内容给网页排名，搜素引擎只可以识别html内容，多页面就是将内容放在html中，所以排名要好一点。</p>\n<p><strong>缺点</strong><br/> 因为每跳转一个页面都要发送一次http请求，如果网络情况不好的情况下，页面之间来回跳转就会发生明显的卡顿，有的时候半天还加载不出来，影响用户体验。</p>\n<p>转场动画也不好实现</p>\n</blockquote>\n<h3 id=\"1%E3%80%81%20Vue%E4%B8%8EAngular%E4%BB%A5%E5%8F%8AReact%E7%9A%84%E5%8C%BA%E5%88%AB\">1、 Vue与Angular以及React的区别</h3>\n<p>▍Angular</p>\n<blockquote>\n<p>框架比较成熟完整，过于庞大，上手难；</p>\n<p>指令以ng-xxx开头； 由谷歌开发和维护；</p>\n<p>版本1比较适合PC端开发，版本2在往移动端靠；</p>\n<p>不支持低版本浏览器； 内置指令和自定义指令；</p>\n<p>内置过滤器和自定义过滤器； 支持双向数据绑定；</p>\n</blockquote>\n<p>▍Vue</p>\n<blockquote>\n<p>它是一个轻量级框架，其核心库只关注视图层，简单小巧、易学易上手；</p>\n<p>指令以v-xxx开头； 个人维护项目； 适合于移动端开发； 不支持低版本浏览器；</p>\n<p>内置指令和自定义指令； 内置过滤器和自定义过滤器； 支持双向数据绑定；</p>\n<p>使用DOM模板。中心思想：一切都是组件，组件实例之间可以嵌套； 核心库不内置列数AJAX，Route等功能到核心包，而是以插件的方式加载； 基于依赖追踪的观察系统，并且异步队列更新。</p>\n</blockquote>\n<p>▍React</p>\n<blockquote>\n<p>依赖虚拟DOM； 采用特殊的JSX语法； 中心思想：一切都是组件，组件实例之间可以嵌套； 核心库不内置列数AJAX，Route等功能到核心包，而是以插件的方式加载。</p>\n</blockquote>\n<p></p>\n<h3 id=\"2%E3%80%81%20%E8%AF%B7%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8B%E4%BD%A0%E5%AF%B9webpack%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F\">2、 请描述一下你对webpack的理解？</h3>\n<blockquote>\n<p>Webpack Webpack 是一个项目打包工具</p>\n<p>可以压缩代码和图片，把浏览器识别不了的代码转化为能识别的，可以启动一个热加载服务器</p>\n<p><span style=\"color:#fe2c24;\"><strong>配置跨域、路径别名、打包分析、cdn映入、去掉console.log、单独打包第三方模块、ie兼容、eslint规范、图片压缩</strong></span></p>\n</blockquote>\n<p></p>\n<h3 id=\"3%E3%80%81vue2%E5%AF%B9%E6%AF%94vue3\">3、vue2对比vue3</h3>\n<blockquote>\n<p>最大的区别就是： Vue2使用 选项类型API（Options API） 对比Vue3 合成型API（Composition API）</p>\n<ol><li> <p>双向数据绑定原理发生了改变，使用proxy替换Object.defineProerty,使用Proxy的优势：</p> </li></ol>\n<ul><li> <p>可直接监听数组类型的数据变</p> </li><li> <p>监听的目标为对象本身，不需要像Object.defineProperty一样遍历每个属性，有一定的性能提升</p> </li><li> <p>可直接实现对象属性的新增/删除</p> </li></ul>\n<ol><li> <p>默认使用懒加载</p> </li></ol>\n<p>在2.x版本里。不管数据多大，都会在一开始就为其创建观察者，在数据很大时，就会造成性能的问题。在3.x中，只会对渲染出来的数据创建观察者，而且3.x的观察者更高效。</p>\n<p>3.0新加入了TypeScript以及PWA支持</p>\n<p></p>\n<p><strong>生命周期有了一定的区别</strong></p>\n<p>Vue2--------------vue3</p>\n<p>beforeCreate -&gt; setup() 开始创建组件之前，创建的是data和method</p>\n<p>created -&gt; setup()</p>\n<p>beforeMount -&gt; onBeforeMount 组件挂载到节点上之前执行的函数。</p>\n<p>mounted -&gt; onMounted 组件挂载完成后执行的函数</p>\n<p>beforeUpdate -&gt; onBeforeUpdate 组件更新之前执行的函数。</p>\n<p>updated -&gt; onUpdated 组件更新完成之后执行的函数。</p>\n<p>beforeDestroy -&gt; onBeforeUnmount 组件挂载到节点上之前执行的函数。</p>\n<p>destroyed -&gt; onUnmounted 组件卸载之前执行的函数。</p>\n<p>activated -&gt; onActivated 组件卸载完成后执行的函数</p>\n<p>deactivated -&gt; onDeactivated</p>\n</blockquote>\n<p></p>\n<p></p>\n<h3 id=\"4%E3%80%81git\">4、git命令</h3>\n<blockquote>\n<p>1. git init 初始化git仓库 (mac中Command+Shift+. 可以<strong>显示隐藏文件</strong>)</p>\n<p>2. git status 查看文件状态</p>\n<p>3. git add 文件列表 追踪文件</p>\n<p>4. git commit -m 提交信息 向仓库中提交代码</p>\n<p>5. git log 查看提交记录</p>\n<p></p>\n<p><strong>1.分支明细</strong></p>\n<p>（1）主分支（master）：第一次向 git 仓库中提交更新记录时自动产生的一个分支。</p>\n<p>（2）开发分支（develop）：作为开发的分支，基于 master 分支创建。</p>\n<p>（3）功能分支（feature）：作为开发具体功能的分支，基于开发分支创建</p>\n<p></p>\n<p><strong>2.分支命令</strong></p>\n<p>（1）git branch 查看分支</p>\n<p>（2）git branch 分支名称 创建分支</p>\n<p>（3）git checkout 分支名称 切换分支</p>\n<p>（4）git merge 来源分支 合并分支 (备注：必须在master分支上才能合并develop分支)</p>\n<p>（5）git branch -d 分支名称 删除分支（分支被合并后才允许删除）（-D 强制删除）</p>\n<p></p>\n<p><strong>3.暂时保存更改</strong></p>\n<p>（1）存储临时改动：git stash</p>\n<p>（2）恢复改动：git stash pop</p>\n<p></p>\n<p><strong><span style=\"color:#fe2c24;\">更加详细请看<a class=\"link-info\" href=\"https://blog.csdn.net/qq_54753561/article/details/122723569?spm=1001.2014.3001.5502\" title=\"git常用命令\">git常用命令</a></span></strong></p>\n</blockquote>\n<p></p>\n<p><strong>git怎么解决多人冲突？：</strong></p>\n<blockquote>\n<p>是当前修改是左箭头方向，传入的是右箭头的方向，</p>\n<p><span style=\"color:#fe2c24;\"><strong>中间用等于号分割，等号上边是当前修改（本地），下边是传入的修改（线上的代码）。</strong></span></p>\n<p>两人同时提交可能会出现冲突，解决办法是手动修改冲突</p>\n</blockquote>\n<h3></h3>\n<h3 id=\"5%E3%80%81%E5%89%8D%E7%AB%AF%E6%9C%89%E5%93%AA%E4%BA%9B%E9%A1%B5%E9%9D%A2%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%3F\">5、前端有哪些页面优化方法?</h3>\n<pre><code class=\"language-javascript\">- 减少 HTTP请求数\n- 从设计实现层面简化页面\n- 合理设置 HTTP缓存\n- 资源合并与压缩\n- 合并 CSS图片，减少请求数的又一个好办法。\n- 将外部脚本置底（将脚本内容在页面信息内容加载后再加载）\n- 多图片网页使用图片懒加载。\n- 在js中尽量减少闭包的使用\n- 尽量合并css和js文件\n- 尽量使用字体图标或者SVG图标，来代替传统的PNG等格式的图片\n- 减少对DOM的操作\n- 在JS中避免“嵌套循环”和 “死循环”\n- 尽可能使用事件委托（事件代理）来处理事件绑定的操作\n- 浏览器缓存\n- 防抖、节流\n- 资源懒加载、预加载\n- 开启Nginx gzip压缩\n三个方面来说明前端性能优化\n一： webapck优化与开启gzip压缩\n    1.babel-loader用 include 或 exclude 来帮我们避免不必要的转译，不转译node_moudules中的js文件\n    其次在缓存当前转译的js文件，设置loader: 'babel-loader?cacheDirectory=true'\n    2.文件采用按需加载等等\n    3.具体的做法非常简单，只需要你在你的 request headers 中加上这么一句：\n    accept-encoding:gzip\n    4.图片优化，采用svg图片或者字体图标\n    5.浏览器缓存机制，它又分为强缓存和协商缓存\n二：本地存储——从 Cookie 到 Web Storage、IndexedDB\n    说明一下SessionStorage和localStorage还有cookie的区别和优缺点\n三：代码优化\n    1.事件代理\n    2.事件的节流和防抖\n    3.页面的回流和重绘\n    4.EventLoop事件循环机制\n    5.代码优化等等</code></pre>\n<p></p>\n<h1 id=\"node%EF%BC%8C%E7%BD%91%E7%BB%9C\">node，网络</h1>\n<h3 id=\"1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFaxios\">1、什么是axios</h3>\n<blockquote>\n<p>基于promise的http库，可以用在浏览器和node.js，支持promiseAPI，客户端支持防御xsrf</p>\n</blockquote>\n<h3></h3>\n<h3 id=\"2%E3%80%81Node%E6%98%AF%E4%BB%80%E4%B9%88\">2、Node是什么（别看这么简单，有的人一问就懵）</h3>\n<blockquote>\n<p><strong>Node是一个基于Chrome V8引擎的JavaScript代码运行环境。</strong></p>\n<p><strong>浏览器（软件）能够运行JavaScript代码，浏览器就是JavaScript代码的运行环境</strong></p>\n<p><strong>Node（软件）能够运行JavaScript代码，Node就是JavaScript代码的运行环境</strong></p>\n</blockquote>\n<p></p>\n<h3 id=\"3%E3%80%81%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E6%84%8F%E4%B9%89\">3、模块化的意义</h3>\n<blockquote>\n<p>一句话：降低软件的复杂性。使其可控，可维护，可扩展。</p>\n<p>一个功能就是一个模板，多个模板可以组成完整应用，抽离一个模板不会影响其他功能的运行</p>\n</blockquote>\n<p></p>\n<h3 id=\"4%E3%80%81%E7%BD%91%E7%AB%99%E7%9A%84%E7%BB%84%E6%88%90\">4、网站的组成</h3>\n<blockquote>\n<p>网站应用程序主要分为两大部分：客户端和服务器端。客户端：在浏览器中运行的部分，就是用户看到并与之交互的界面程序。使用HTML、CSS、JavaScript构建。服务器端：在服务器中运行的部分，负责存储数据和处理应用逻辑。</p>\n</blockquote>\n<p></p>\n<h3 id=\"5%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8node\">5、为什么要用node</h3>\n<blockquote>\n<p><strong>简单强大，轻量可扩展。</strong></p>\n<p><span style=\"color:#fe2c24;\"><strong>简单体现在node使用的是javascript,json来进行编码</strong></span>，强大体现在非阻塞IO,可以适应分块传输数据，较慢的网络环境，<span style=\"color:#fe2c24;\"><strong>尤其擅长高并发访问</strong></span>，轻量体现在node本身既是代码，又是服务器，前后端使用统一语言;可扩展体现在可以轻松应对多实例，多服务器架构，同时有海量的第三方应用组件。</p>\n</blockquote>\n<p></p>\n<h3 id=\"6%E3%80%81node%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E5%92%8C%E5%90%8C%E6%AD%A5%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%3F\">6、node中的异步和同步怎么理解?</h3>\n<blockquote>\n<p>node是单线程的，异步是通过一次次的循环事件队列来实现的．同步则是说阻塞式的IO,这在高并发环境会是一个很大的性能问题，所以同步一般只在基础框架的启动时使用，用来加载配置文件，初始化程序什么的．</p>\n</blockquote>\n<p></p>\n<h3 id=\"7%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFnpm%EF%BC%9FNpm%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F\">7、什么是npm？Npm的使用场景？</h3>\n<blockquote>\n<p>NPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题。</p>\n<p>使用场景：</p>\n<p>a. 允许用户从NPM服务器下载别人编写的第三方包到本地使用。</p>\n<p>b. 允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。</p>\n<p>c. 允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。</p>\n</blockquote>\n<p></p>\n<h3 id=\"8%E3%80%81get%E4%B8%8Epost%E8%AF%B7%E6%B1%82%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB\">8、get与post请求有什么区别</h3>\n<blockquote>\n<ol><li> <p>get是从服务器上获取数据，post是向服务器传送数据。</p> </li><li> <p>POST比GET安全，因为数据在地址栏上不可见。</p> </li><li> <p>get方式提交的数据最多只能有1024字节，而post则没有此限制。</p> </li><li> <p>GET使用URL或Cookie传参。而POST将数据放在request BODY中。</p> </li><li> <p>GET与POST都有自己的语义，不能随便混用。</p> </li><li> <p>据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基，本可以无视。而在网 络环境差的情况下，两次包的TCP在验证数据包完整 性上，有非常大的优点。post 发送两次，get 只发送一次。</p> </li><li> <p>并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。</p> </li></ol>\n</blockquote>\n<p></p>\n<p></p>\n<h2 id=\"ajax\">ajax</h2>\n<h3 id=\"%E4%BB%80%E4%B9%88%E6%98%AFajax%EF%BC%9Fajax%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F\">什么是ajax？ajax有什么优缺点？</h3>\n<blockquote>\n<p>ajax不是语言，ajax是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术</p>\n<p>优点</p>\n<p>1、最大的一点是页面无刷新，用户的体验非常好。</p>\n<p>2、使用异步方式与服务器通信，具有更加迅速的响应能力。</p>\n<p>缺点</p>\n<p>1、ajax不支持浏览器back按钮。</p>\n<p>2、安全问题 AJAX暴露了与服务器交互的细节。</p>\n<p>3、对搜索引擎的支持比较弱。</p>\n<p>4、破坏了程序的异常机制。</p>\n<p>5、不容易调试</p>\n</blockquote>\n<p></p>\n<h3 id=\"%E5%8E%9F%E7%94%9FAjax%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B\">原生Ajax的创建过程</h3>\n<pre><code class=\"language-javascript\">1.创建xhr 核心对象\nvar xhr=new XMLHttpRequest();\n​\n2.调用open 准备发送\n参数一：请求方式\n参数二: 请求地址\n参数三：true异步，false 同步\nxhr.open('post','http://www.baidu.com/api/search',true)\n​\n3.如果是post请求，必须设置请求头。\nxhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded')\n​\n4.调用send 发送请求 （如果不需要参数，就写null）\nxhr.send('user=tom&amp;age=10&amp;sex=女')\n​\n5.监听异步回调 onreadystatechange\n判断readyState 为4 表示请求完成\n判断status 状态码 为 200 表示接口请求成功\nresponeseText 为相应数据。字符串类型。\nxhr.onreadystatechange=function(){\n    if(xhr.readyState==4){ \n        if(xhr.status==200){\n            console.log(xhr.responseText);\n            var res=JSON.parse(xhr.responseText);\n            console.log(res);\n            if(res.code==1){\n            modal.modal('hide');\n           location.reload();\n       }\n    }\n            \n            \n备注：如果是post请求，想要传json格式数据。\n设置请求头\n​\n1.xhr.setRequestHeader('Content-Type', 'application/json')\n​\nopen发送数据\n2.xhr.open({_id:xxx,user:xxxx,age:xxxx})</code></pre>\n<p></p>\n<h3 id=\"web%E5%AE%89%E5%85%A8%E5%8F%8A%E9%98%B2%E6%8A%A4\">web安全及防护</h3>\n<p></p>\n<h3><strong>1.XSS攻击原理：</strong></h3>\n<blockquote>\n<p><strong><code>XSS</code>(<code>Cross-Site Scripting</code>，跨站脚本攻击)</strong><span style=\"color:#fe2c24;\"><strong>是一种代码注入攻击。攻击者在目标网站上注入恶意代码，当被攻击者登陆网站时就会执行这些恶意代码，这些脚本可以读取 </strong></span><code><span style=\"color:#fe2c24;\"><strong>cookie，</strong></span>session tokens</code>，或者其它敏感的网站信息，对用户进行钓鱼欺诈，甚至发起蠕虫攻击等。</p>\n<p><strong>XSS避免方式：</strong></p>\n<ol><li> <p><code>url</code>参数使用<code>encodeURIComponent</code>方法转义</p> </li><li> <p>尽量不是有<code>InnerHtml</code>插入<code>HTML</code>内容</p> </li><li> <p>使用特殊符号、标签转义符。</p> </li></ol>\n</blockquote>\n<h3><strong>2.CSRF攻击（跨站请求伪造）：</strong></h3>\n<blockquote>\n<p><strong><code>CSRF</code>（<code>Cross-site request forgery</code>）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。</strong></p>\n<p><code>CSRF</code>避免方式：</p>\n<ol><li> <p>添加验证码</p> </li><li> <p>使用token</p>\n<ul><li> <p>服务端给用户生成一个token，加密后传递给用户</p> </li><li> <p>用户在提交请求时，需要携带这个token</p> </li><li> <p>服务端验证token是否正确</p> </li></ul></li></ol>\n</blockquote>\n<h3><strong>3.SQL注入攻击</strong></h3>\n<blockquote>\n<p><strong>就是通过吧SQL命令插入到Web表单递交或输入域名，最终达到欺骗服务器执行恶意的SQL命令。</strong></p>\n<p>解决：表单输入时通过正则表达式将一些特殊字符进行转换</p>\n</blockquote>\n<h3><strong><code>4、DDoS攻击</code></strong></h3>\n<blockquote>\n<p><strong><code>DDoS</code>又叫分布式拒绝服务，全称 <code>Distributed Denial of Service</code>，其原理就是利用大量的请求造成资源过载，导致服务不可用。</strong></p>\n<p><strong>解决：</strong></p>\n<p></p>\n<ol><li> <p>限制单IP请求频率。</p> </li><li> <p>防火墙等防护设置禁止<code>ICMP</code>包等</p> </li><li> <p>检查特权端口的开放</p> </li></ol>\n</blockquote>\n<p></p>\n<h3 id=\"%E4%BD%BF%E7%94%A8%E5%9F%BA%E4%BA%8Etoken%E7%9A%84%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B\">使用基于token的登录流程</h3>\n<blockquote>\n<p>1. 客户端使用用户名跟密码请求登录</p>\n<p>2. 服务端收到请求，去验证用户名与密码</p>\n<p>3. 验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端</p>\n<p>4. 客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里</p>\n<p>5. 客户端每次向服务端请求资源的时候需要带着服务端签发的 Token</p>\n<p>6. 服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据</p>\n</blockquote>\n<h3 id=\"%E7%8A%B6%E6%80%81%E7%A0%81\">状态码</h3>\n<p><strong>常见http状态码分类：</strong></p>\n<pre><code class=\"language-javascript\">    200响应成功\n    301永久重定向\n    302临时重定向\n    304资源缓存\n    403服务器禁止访问\n    404服务器资源未找到\n    500 502服务器内部错误\n    504 服务器繁忙\n    1xx Informational（信息状态码）      接受请求正在处理\n    2xx Success（成功状态码）            请求正常处理完毕\n    3xx Redirection（重定向状态码）      需要附加操作已完成请求\n    4xx Client Error（客户端错误状态码）  服务器无法处理请求\n    5xx Server Error（服务器错误状态码）  服务器处理请求出错</code></pre>\n<h3></h3>\n<h2 id=\"%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2%EF%BC%8C%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F\">浏览器从输入url到渲染页面，发生了什么？</h2>\n<blockquote>\n<p><span style=\"color:#fe2c24;\"><strong>这玩意一定要说全了装逼</strong></span></p>\n<p><strong>用户输入阶段</strong><br/> 合成 URL：浏览区会判断用户输入是合法 URL，比如用户输入的是搜索的关键词，默认的搜索引擎会合成新的，如果符合url规则会根据url协议，在这段内容加上协议合成合法的url <br/>    <br/><strong>查找缓存</strong><br/> 网络进程获取到 URL，先去本地缓存中查找是否有缓存资源，如果有则拦截请求，直接将缓存资源返回给浏览器进程；否则，进入网络请请求阶段；    <br/>     <br/><strong>DNS 解析：</strong><br/> DNS 查找数据缓存服务中是否缓存过当前域名信息，有则直接返回；否则，会进行 DNS 解析返回域名对应的 IP 和端口号，如果没有指定端口号，http 默认 80 端口，https 默认 443。如果是 https 请求，还需要建立 TLS 连接；<br/>     <br/><strong>建立 TCP 连接：</strong><br/> TCP 三次握手与服务器建立连接，然后进行数据的传输；（三次握手开喷）</p>\n<p></p>\n<p><strong>发送 HTTP 请求：</strong><br/> 浏览器首先会向服务器发送请求行，它包含了请求方法、请求 URI 和 HTTP 协议的版本；另外还会发送请求头，告诉服务器一些浏览器的相关信息，比如浏览器内核，请求域名；</p>\n<p></p>\n<p><strong>服务器处理请求：</strong><br/> 服务器首先返回响应行，包括协议版本和状态码，比如状态码 200 表示继续处理该请求；如果是 301，则表示重定向，服务器也会向浏览器发送响应头，包含了一些信息；</p>\n<p></p>\n<p><strong>页面渲染:</strong></p>\n<p>查看响应头的信息，做不同的处理，比如重定向，存储cookie 看看content-type的值，根据不同的资源类型来用不同的解析方式</p>\n<p><br/><span style=\"color:#fe2c24;\"><strong>浏览器渲染原理直接开干.....</strong></span></p>\n<p>浏览器将获取的HTML文档解析成DOM树。<br/> 处理CSS标记，构成层叠样式表模型CSSOM(CSS Object Model)。<br/> 将DOM和CSSOM合并为渲染树(rendering tree)，代表一系列将被渲染的对象。<br/> 渲染树的每个元素包含的内容都是计算过的，它被称之为布局layout。浏览器使用一种流式处理的方法，只需要一次绘制操作就可以布局所有的元素。<br/> 将渲染树的各个节点绘制到屏幕上，这一步被称为绘制painting。</p>\n<p></p>\n<p><strong>断开 TCP 连接：</strong></p>\n<p>数据传输完成，正常情况下 TCP 将四次挥手断开连接。但是如果浏览器或者服务器在HTTP头部加上 Connection: keep-alive，TCP 就会一直保持连接。</p>\n</blockquote>\n<p></p>\n<h2 id=\"%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E3%80%81HTTP%E5%8D%8F%E8%AE%AE\">网络安全、HTTP协议</h2>\n<h3 id=\"TCP%20UDP%20%E5%8C%BA%E5%88%AB\">TCP UDP 区别</h3>\n<blockquote>\n<p>1.`TCP`向上层提供面向连接的可靠服务 ，`UDP`向上层提供无连接不可靠服务。<br/> 2.虽然 `UDP` 并没有 `TCP` 传输来的准确，但是也能在很多实时性要求高的地方有所作为<br/> 3.对数据准确性要求高，速度可以相对较慢的，可以选用`TCP`</p>\n</blockquote>\n<table><thead><tr><th>区别</th><th>UDP</th><th>TCP</th></tr></thead><tbody><tr><td>是否连接</td><td>无连接</td><td>面向连接</td></tr><tr><td>是否可靠</td><td>不可靠传输，不使用流量控制和拥塞控制</td><td>可靠传输，使用流量控制和拥塞控制</td></tr><tr><td>连接对象个数</td><td>支持一对一，一对多，多对一和多对多交互通信</td><td>只能是一对一通信</td></tr><tr><td>传输方式</td><td>面向报文</td><td>面向字节流</td></tr><tr><td>首部开销</td><td>首部开销小，仅8字节</td><td>首部最小20字节，最大60字节</td></tr><tr><td>适用场景</td><td>适用于实时应用（IP电话、视频会议、直播等）</td><td>适用于要求可靠传输的应用，例如文件传输</td></tr></tbody></table>\n<p></p>\n<h3 id=\"Http%E5%92%8CHttps%E5%8C%BA%E5%88%AB%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89\">Http和Https区别（高频）</h3>\n<pre><code class=\"language-javascript\">1.`HTTP` 的URL 以http:// 开头，而HTTPS 的URL 以https:// 开头\n2.`HTTP` 是不安全的，而 HTTPS 是安全的\n3.`HTTP` 标准端口是80 ，而 HTTPS 的标准端口是443\n4.`在OSI` 网络模型中，HTTP工作于应用层，而HTTPS 的安全传输机制工作在传输层\n5.`HTTP` 无法加密，而HTTPS 对传输的数据进行加密，证的网络协议，安全性高于HTTP协议。\n6.`HTTP`无需证书，而HTTPS 需要CA机构wosign的颁发的SSL证书，一般免费证书少，因而需要一定费用。</code></pre>\n<p></p>\n<h3 id=\"GET%E5%92%8CPOST%E5%8C%BA%E5%88%AB%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89\">GET和POST区别（高频）</h3>\n<pre><code class=\"language-javascript\">1.GET在浏览器回退不会再次请求，POST会再次提交请求\n2.GET请求会被浏览器主动缓存，POST不会，要手动设置\n3.GET请求参数会被完整保留在浏览器历史记录里，POST中的参数不会\n4.GET请求在URL中传送的参数是有长度限制的，而POST没有限制\n5.GET参数通过URL传递，POST放在Request body中\n6.GET参数暴露在地址栏不安全，POST放在报文内部更安全\n7.GET一般用于查询信息，POST一般用于提交某种信息进行某些修改操作\n8.GET产生一个TCP数据包；POST产生两个TCP数据包\nGe和post的选择：\n1.私密性的信息请求使用post（如注册、登陆）。\n2.查询信息使用get。</code></pre>\n<p></p>\n<h3 id=\"%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B\" style=\"text-align:justify;\"><strong><strong><strong>三次握手和四次挥手</strong></strong><strong> </strong></strong></h3>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><strong><strong>三次握手：</strong></strong></p>\n<blockquote>\n<p style=\"margin-left:.0001pt;text-align:justify;\">第一次：建立连接时，客户端发送syn包到服务器，等待服务端确认</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">第二次：服务器收到syn包，必须确认客户的syn，同时也发送一个syn包，即syn+ACK包</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">第三次：客户端收到服务器的syn和ack包，向服务器发送确认包ack，发送完毕，客户端和服务端连接成功，完成三次握手</p>\n</blockquote>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><strong><strong>四次挥手：</strong></strong></p>\n<blockquote>\n<p style=\"margin-left:.0001pt;text-align:justify;\">第一次：浏览器发送完数据后，发送fin请求断开连接</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">第二次：服务器发送ack到客户端，确认客户端的断开请求</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">第三次：服务器请求断开fin的请求</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">第四次：客户端确认服务器的断开ack</p>\n</blockquote>\n<h3>POST的content-type几种方式</h3>\n<blockquote>\n<p>POST 方法中对发送数据编码的方式，也就是 <code>Content-Type</code> 有四种方式，其中默认是 <code>application/x-www-form-urlencoded</code>，最方便的是 <code>application/json</code> 。</p>\n<p>四种方式包括：</p>\n<ul><li>application/x-www-form-urlencoded （URL encoded）</li><li>multipart/form-data （键值对型数据）</li><li>application/json (Json 类型数据)</li><li>text/xml （xml）</li></ul>\n<p>传统的ajax请求时候，<code>Content-Type</code>默认为\"文本\"类型。</p>\n<p>传统的form提交的时候，<code>Content-Type</code>默认为\"Form\"类型。</p>\n<p>axios传递字符串的时候，<code>Content-Type</code>默认为\"Form\"类型。</p>\n<p>axios传递对象的时候，<code>Content-Type</code>默认为\"JSON\"类型</p>\n</blockquote>\n<h3 id=\"http1.0%E3%80%81http1.1%E3%80%81http2.0%E7%9A%84%E5%8C%BA%E5%88%AB\">http1.0、http1.1、http2.0的区别</h3>\n<blockquote>\n<ol><li> <p>1和1.0相比，1.1可以一次传输多个文件</p> </li><li> <p>http1.x解析基于文本，</p> </li><li> <p>http2.0采用二进制格式，新增特性 多路复用、header压缩、服务端推送(静态html资源)</p> </li></ol>\n</blockquote>\n<h3>浏览器缓存的作用</h3>\n<blockquote>\n<p>浏览器缓存的作用：减少冗余的数据传输，节省网络带宽，更快加载页面，缓存降低了服务器的要求，有更快的响应</p>\n</blockquote>\n<h3 id=\"http%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BC%93%E5%AD%98\">http如何实现缓存</h3>\n<blockquote>\n<p>个人理解：</p>\n<p>强制缓存：浏览器在加载资源的时候，会根据本地缓存中的headers中的信息(expires,cache-control)是否要强缓存，如果命中的话，则会使用缓存中的资源，否则继续发送请求。</p>\n<p></p>\n<p>协商缓存：客户端向服务端发送请求，服务端检测是否有对应的标识，如果没有服务端会返回客户端对应的标识，客户端在下次请求把标识带过去服务器会验证标识，如果通过了，则会响应304，告诉浏览器读取缓存，如果没有通过则返回请求的资源。</p>\n<p></p>\n<p>两类缓存规则可以同时存在，强制缓存优先级高于对比缓存，也就是说，当执行强制缓存的规则时，如果缓存生效，直接使用缓存，不再执行对比缓存规则。</p>\n<p></p>\n<p>基于对比缓存，不管是否使用缓存都需要向服务器发送请求，那么还用缓存干什么？<br/> 服务端在进行标识比较后，只返回header部分，通过状态码通知客户端使用缓存，不再需要将报文主体部分返回给客户端。</p>\n</blockquote>\n<h3>缓存的资源去哪里了</h3>\n<blockquote>\n<p>memory cache 将资源文件缓存到内存中，下次请求读取的是内存中的<br/> disk cache 将资源存到硬盘中，下次请求从硬盘中读取</p>\n</blockquote>\n<h3>http报文</h3>\n<blockquote>\n<p>HTTP报文就是浏览器和服务器间通信时发送及响应的数据块。<br/> 浏览器向服务器请求数据，发送请求(request)报文；<br/> 服务器向浏览器返回数据，返回响应(response)报文。<br/> 报文信息主要分为两部分：header,数据主体部分(body)</p>\n</blockquote>\n<h3 id=\"%E8%83%BD%E4%B8%8D%E8%83%BD%E8%AF%B4%E4%B8%80%E8%AF%B4%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%EF%BC%9F%E5%90%84%E8%87%AA%E4%BC%98%E5%8A%A3%E5%A6%82%E4%BD%95%EF%BC%9F\">能不能说一说浏览器的本地存储？各自优劣如何？</h3>\n<blockquote>\n<p><strong>浏览器的本地存储主要分为<code>Cookie、WebStorage和IndexDB</code>, 其中<code>WebStorage</code>又可以分为<code>localStorage和sessionStorage</code>。</strong></p>\n<p><strong>共同点: 都是保存在浏览器端、且同源的</strong></p>\n<p><strong>不同点：</strong></p>\n<ol><li> <p><code>cookie</code>数据始终在同源的<code>http</code>请求中携带（即使不需要），即<code>cookie</code>在浏览器和服务器间来回传递。<code>cookie</code>数据还有路径（<code>path</code>）的概念，可以限制<code>cookie</code>只属于某个路径下<code>sessionStorage</code>和<code>localStorage</code>不会自动把数据发送给服务器，仅在本地保存。</p> </li><li> <p><strong>存储大小限制也不同，</strong></p> </li></ol>\n<ul><li> <p><code>cookie</code>数据不能超过4K，<code>sessionStorage和localStorage</code>可以达到5M</p> </li><li> <p><code>sessionStorage</code>：仅在当前浏览器窗口关闭之前有效；</p> </li><li> <p><code>localStorage</code>：始终有效，窗口或浏览器关闭也一直保存，本地存储，因此用作持久数据；</p> </li><li> <p><code>cookie</code>：只在设置的<code>cookie</code>过期时间之前有效，即使窗口关闭或浏览器关闭</p> </li></ul>\n<ol><li> <p><strong>作用域不同</strong></p> </li></ol>\n<ul><li> <p><code>sessionStorage</code>：不在不同的浏览器窗口中共享，即使是同一个页面；</p> </li><li> <p><code>localstorage</code>：在所有同源窗口中都是共享的；也就是说只要浏览器不关闭，数据仍然存在</p> </li><li> <p><code>cookie</code>: 也是在所有同源窗口中都是共享的.也就是说只要浏览器不关闭，数据仍然存在</p> </li></ul>\n</blockquote>\n<p></p>\n</div>\n</div>"}