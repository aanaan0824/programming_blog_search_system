{"blogid": "126538037", "writerAge": "码龄1年", "writerBlogNum": "118", "writerCollect": "175", "writerComment": "42", "writerFan": "46", "writerGrade": "4级", "writerIntegral": "1233", "writerName": "汪泽文666", "writerProfileAdress": "writer_image\\profile_126538037.jpg", "writerRankTotal": "15586", "writerRankWeekly": "13021", "writerThumb": "19", "writerVisitNum": "118405", "blog_read_count": "363", "blog_time": "于 2022-08-26 21:40:15 发布", "blog_title": "Prometheus监控docker容器", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-light\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p></p>\n<div class=\"toc\">\n<h3>Prometheus监控docker容器</h3>\n<ul><li><a href=\"#Prometheus_1\">Prometheus简介</a></li><li><a href=\"#Prometheus_7\">Prometheus特点及组件</a></li><li><ul><li><a href=\"#Prometheus_8\">Prometheus特点</a></li><li><a href=\"#Prometheus_18\">Prometheus的组件</a></li></ul>\n</li><li><a href=\"#Prometheus_30\">Prometheus架构</a></li><li><a href=\"#Prometheus_40\">Prometheus工作流程</a></li><li><a href=\"#Prometheus_51\">Prometheus部署</a></li><li><ul><li><a href=\"#docker_70\">部署docker</a></li><li><ul><li><a href=\"#nodeexporter_82\">部署node-exporter用于搜集硬件和系统信息</a></li><li><a href=\"#cAdvisor_97\">部署cAdvisor，用于搜集容器节点信息</a></li><li><ul><li><a href=\"#Prometheus_112\">配置Prometheus服务</a></li></ul>\n</li><li><a href=\"#grafanaPrometheus_135\">部署grafana服务，对Prometheus做优化</a></li><li><a href=\"#Alertmanager_198\">配置Alertmanager报警</a></li><li><ul><li><a href=\"#_231\">配置邮箱报警</a></li><li><a href=\"#alertmanageryml_239\">配置alertmanager.yml文件</a></li><li><a href=\"#Prometheus_251\">配置Prometheus部分</a></li></ul>\n</li><li><a href=\"#Alertmanager_311\">Alertmanager自定义邮件报警</a></li></ul>\n</li></ul>\n</li></ul>\n</div>\n<p></p>\n<h1><a id=\"Prometheus_1\"></a>Prometheus简介</h1>\n<p><em>说起当下很火的云原生，就不得不提docker和k8s，docker也是现在很多企业都要求会的技术，那么多docker容器怎么知道出没出问题呢？怎么对他们进行监控呢？Prometheus可以较好的解决这些问题，为什么不用zabbix或者其他监控系统呢？至于为什么请往下看</em></p>\n<p>Prometheus是一款开源的监控系统，他的诞生的灵感来自于Google的监控系统Brogmon，这里也说一下我们熟悉的kubernetes(k8s)也是从Google的Brog系统演变而来，早在2012年开始Google就在Soundcloud以开源软件的形式进行研发了，并在2015年对外发布早期版本，在2016年的5月继kubernetes之后第二个加入CNCF基金会的项目，在同年六月发布了1.0版本</p>\n<h1><a id=\"Prometheus_7\"></a>Prometheus特点及组件</h1>\n<h2><a id=\"Prometheus_8\"></a>Prometheus特点</h2>\n<ol><li>多维度数据模型(基于时间序列的key、value键值对)</li><li>灵活的查询和聚合语言promQL</li><li>可以直接在本地存储，不依赖其他的分布式存储</li><li>通过http的pull模型采集时间序列数据</li><li>可以通过pushgateway(Prometheus的可选中间件)实现push模式</li><li>可通过动态服务发现或静态配置发现目标服务器</li><li>支持多种图表和仪表盘，结合grafana</li><li>可以做高可用，对数据做异地备份。</li></ol>\n<h2><a id=\"Prometheus_18\"></a>Prometheus的组件</h2>\n<ol><li>Prometheus server，负责拉取、存储时间序列数据，简单来说就是搜集数据的</li><li>client library(客户端库)，检测应用程序代码，当Prometheus抓取实列的http端点时，客户端库会将所有跟踪的metrics指标的当前状态发送到Prometheus server端。</li></ol>\n<p>metric数据指的是从服务端上获取到的指标数据的统称。metrics指标为时间序列数据，这些数据按相同的时序，以时间维度来存储连续数据的集合。<br/> metric的时序数据分为gauge(仪表盘)，counter(计数器)，histogram(直方图)。</p>\n<ol start=\"4\"><li>push gateway(推送网关)，各个目标主机可以上报数据到push gateway，然后Prometheus server统一从push gateway拉取数据。支持短暂的任务(Prometheus主动获取数据)</li><li>alertmanager 处理报警的报警组件，从Prometheus server端收到alerts后，会进行去重，分组，并路由到相应接收方，发出报警，常用的接收方式有:微信，钉钉，slack，邮件等。</li><li>adhoc 用于数据的查询</li><li>exporter(常用) 暴露指标让任务抓取，通过exporter可以采集metrics数据，然后发送到Prometheus server端，所有向Prometheus server提供监控数据的程序都可以被称为exporter。</li></ol>\n<h1><a id=\"Prometheus_30\"></a>Prometheus架构</h1>\n<p><strong>说一下下图的主要组件:</strong></p>\n<ul><li>retrieval负责在活跃的target主机上抓取监控指标数据</li><li>storage存储主要是把采集到的数据存储到磁盘中</li><li>promQL是Prometheus提供的查询语言模块</li></ul>\n<p><img alt=\"Prometheus架构图\" src=\"image\\25545c8e74b84c9eac73e06f094ca5f2.png\"/></p>\n<h1><a id=\"Prometheus_40\"></a>Prometheus工作流程</h1>\n<ol><li>Prometheus server可定期从活跃的目标主机上(target)拉取监控指标数据，目标主机的监控数据可通过配置静态job或者服务发现的方式被Prometheus server采集到，这种方式默认的pull返回时拉取指标; 也可以通过push gateway把采集的数据上报到Prometheus server中；还可以通过一些组件自带的exporter采集相应组件的数据；</li><li>Prometheus server把采集到的监控指标数据保存到本地磁盘或者数据库；</li><li>Prometheus 采集的监控指标数据按时间序列存储，通过配置报警规则，把触发的报警发送到Alertmanager</li><li>Alertmanager通过配置报警接收方，发送报警到邮件，微信或者钉钉等</li><li>Prometheus自带的web ui界面提供promQL查询语言，可查询监控数据</li><li>grafana可接入Prometheus数据源，把监控数据以图形化形式展示出来</li></ol>\n<p><em>Prometheus为什么适合监控容器</em><br/> 首先Prometheus的可扩展性很强，从上面的架构图也可以看出来，Prometheus拥有很多的组件，而Prometheus的原理是通过HTTP协议进行周期性抓取被监控组件的状态，这样就表示只要组件提供HTTP接口就可以接入监控系统，其次Prometheus是pull模型采集的也就是Prometheus服务端主动取拉取数据，各个被监控的源只需要将自身指标暴露在本地http端口即可，这样就可以通过访问接口来采集指标。</p>\n<h1><a id=\"Prometheus_51\"></a>Prometheus部署</h1>\n<p><strong>环境说明:</strong><br/> 系统:centos7</p>\n<p><a href=\"https://prometheus.io/download/\">Prometheus官网下载地址</a></p>\n<pre><code>[root@prometheus ~]# mkdir /prometheus/\n[root@prometheus ~]# docker run -d --name test -p 9090:9090 prom/prometheus\n[root@prometheus ~]# docker cp test:/etc/prometheus/prometheus.yml /prometheus\n\n[root@prometheus ~]# docker stop test\n[root@prometheus ~]# docker rm test\n</code></pre>\n<p>// 输入IP:9090，看到如下页面说明成功，因为没有添加监控项所以这里没有内容<br/> <img alt=\"\" src=\"image\\6acd70cad19044eaa2c8b1a2f8e2bfda.png\"/></p>\n<h2><a id=\"docker_70\"></a>部署docker</h2>\n<p>// 所有主机都要部署</p>\n<pre><code>[root@prometheus ~]#  yum -y install yum-utils\n\n[root@prometheus ~]# yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo\n\n[root@prometheus ~]# sed -i 's+download.docker.com+mirrors.aliyun.com/docker-ce+' /etc/yum.repos.d/docker-ce.repo\n\n[root@prometheus ~]# yum -y install docker-ce\n[root@prometheus ~]# systemctl enable --now docker.service\n</code></pre>\n<h3><a id=\"nodeexporter_82\"></a>部署node-exporter用于搜集硬件和系统信息</h3>\n<pre><code>// 全部主机都要做\ndocker run -d -p 9100:9100 -v /proc:/host/proc -v /sys:/host/sys -v /:/rootfs --net=host prom/node-exporter --path.procfs /host/proc --path.sysfs /host/sys --collector.filesystem.ignored-mount-points \"^/(sys|proc|dev|host|etc)($|/)\"\n\n--web.listen-address 9100  //默认使用9100端口号\n--path.rootfs：node-exporter使用/host前缀访问主机文件系统\n--collector.filesystem.ignored-mount-points：忽略访问的文件\n--net=host：代替端口映射，如容器有80，需要访问的话就需要加-p选项，不想的话加--net=host就可以直接访问80\n</code></pre>\n<p>浏览器IP:9100/metrics<br/> <img alt=\"\" src=\"image\\0a9ebd5f844445358c718618dbfe206f.png\"/></p>\n<h3><a id=\"cAdvisor_97\"></a>部署cAdvisor，用于搜集容器节点信息</h3>\n<pre><code>// 所有主机都要做\ndocker run -v /:/rootfs:ro -v /var/run:/var/run/:rw -v /sys:/sys:ro -v /var/lib/docker:/var/lib/docker:ro -p 8080:8080 --detach=true --name=cadvisor --net=host google/cadvisor\n\n\n\n--detach=true 是否在后台运行容器true为后台运行，false反之\n</code></pre>\n<p>浏览器IP:8080/containers<br/> <img alt=\"\" src=\"image\\73f06f275dd745afb45dacd954dad7a9.png\"/></p>\n<h4><a id=\"Prometheus_112\"></a>配置Prometheus服务</h4>\n<pre><code>[root@prometheus prometheus]# tail -9 prometheus.yml\n      - targets: [\"localhost:9090\",\"localhost:9100\",\"localhost:8080\"]\n\n  - job_name: \"node1\" \n    static_configs:\n      - targets: [\"192.168.182.131:9100\",\"192.168.182.131:8080\"]\n\n  - job_name: \"node2\"\n    static_configs:\n      - targets: [\"192.168.182.132:9100\",\"192.168.182.132:8080\"]\n\n// 重启服务\n[root@prometheus prometheus]# docker restart Prometheus\n</code></pre>\n<p>浏览器IP:9090<br/> <img alt=\"\" src=\"image\\9a4f9f658c3e4392a54ee6eea145d519.png\"/></p>\n<p>// 看到如下界面说明监控成功<br/> <img alt=\"\" src=\"image\\5b932f6ff91045e09cdbfc2e2d3c771c.png\"/></p>\n<h3><a id=\"grafanaPrometheus_135\"></a>部署grafana服务，对Prometheus做优化</h3>\n<pre><code>[root@prometheus ~]# mkdir /grafana/\n[root@prometheus ~]# chmod 777 -R /grafana/  //这一步很重要\ndocker run -d -p 3000:3000 --name grafana -v /grafana/:/var/lib/grafana -e \"GF_SECURITY_ADMIN_PASSWORD=passwd\" grafana/grafana\n\n在docker-monitor目录下新增grafana目录，在里面创建文件config.monitoring，内容如下\n\nGF_SECURITY_ADMIN_PASSWORD=admin  #grafana管理界面的登录用户密码，用户名是admin\nGF_USERS_ALLOW_SIGN_UP=false  #grafana管理界面是否允许注册，默认不允许\n</code></pre>\n<p>浏览器IP:3000，用户名admin，密码passwd<br/> <img alt=\"\" src=\"image\\69c18c27e3d94cdbbe784f0c98ab878c.png\"/></p>\n<p>// 添加数据源<br/> <img alt=\"\" src=\"image\\87e6b634136b49a8a1aa1702c52bc2f0.png\"/></p>\n<p>// 点击添加<br/> <img alt=\"\" src=\"image\\c91400ddcfd84f758962ff75f843339e.png\"/></p>\n<p>// 选择Prometheus数据源<br/> <img alt=\"\" src=\"image\\b573826552914084b39d5f37d03a8d19.png\"/></p>\n<p>// 连接Prometheus<br/> <img alt=\"\" src=\"image\\264f0baccd274f3c8c4822be997a74a5.png\"/></p>\n<p>// 点击save&amp;test，出现绿色的勾说明添加成功<br/> <img alt=\"在这里插入图片描述\" src=\"image\\36e0f9f2534f471cacc7ead0e1d54f2a.png\"/></p>\n<p>// 使用grafana提供的模板来进行优化界面<br/> <a href=\"https://grafana.com/grafana/dashboards/11074-node-exporter-for-prometheus-dashboard-en-v20201010/\">模板下载地址</a></p>\n<p>可通过下面两种方式获得模板<br/> <img alt=\"\" src=\"image\\69a8663d2f4542e8b831729ba27881a5.png\"/></p>\n<p>有两种方式使用模板<br/> 1 通过模板的id号进行导入<br/> 2将模板下载到本地再进行导入</p>\n<p>// 导入模板<br/> <img alt=\"\" src=\"image\\843c4f1721214c9a9f874c06c76f20f9.png\"/></p>\n<p><img alt=\"\" src=\"image\\1b1e19a790ab4ac4974065a65ce6a88c.png\"/></p>\n<p>// 通过id添加模板，点击load<br/> <img alt=\"\" src=\"image\\57d852d589f94fa9a7d8939ec9aef761.png\"/></p>\n<p><img alt=\"\" src=\"image\\50926266c8bd436a8132f3c3e3d6700f.png\"/></p>\n<p>// 最后呈现的效果<br/> <img alt=\"\" src=\"image\\5f650920eea94d668c4d331b8356ef50.png\"/><br/> // 因为我们要看的是容器的信息，所以找一个和容器相关的模板导入。</p>\n<p>//通过关键字搜索相关模板<br/> <img alt=\"\" src=\"image\\30d9137204e84f0db97de7b51c4d5407.png\"/></p>\n<p>// 可以看到这里有两个容器的运行状态<br/> <img alt=\"\" src=\"image\\7e120e751bde40a3a02c0ab5b0f2bc9d.png\"/></p>\n<p>// 可以选择查看不同节点上的容器，上图是node1节点上的容器，下图是Prometheus上的容器<br/> <img alt=\"\" src=\"image\\3ca056c19cbc47888b1e4f80ddbaa2c3.png\"/></p>\n<h3><a id=\"Alertmanager_198\"></a>配置Alertmanager报警</h3>\n<p>启动AlerManager来接受Prometheus发送的报警信息，并执行各种方式报警。</p>\n<p><img alt=\"\" src=\"image\\80e6fc82159b437ea77a8827c068f038.png\"/></p>\n<p><strong>流程如下：</strong></p>\n<ul><li>Prometheus收集到检测的信息</li><li>根据Prometheus.yml文件定义的rules文件，rules里包括了告警信息</li><li>Prometheus把报警信息push给alertmanager，通过alertmanager配置文件里面定义收件人和发件人</li><li>alertmanager发送文件给邮箱或微信</li></ul>\n<p><strong>告警等级</strong></p>\n<ul><li>Inactive：什么都没发生。</li><li>pending：触发了阈值，但是未满足告警持续时间，也就是for字段</li><li>firing：已触发阈值且满足告警持续时间。警报发送给接收者</li></ul>\n<pre><code>[root@prometheus ~]# mkdir /alertmanager  //创建一个数据目录\n[root@prometheus ~]# docker run -d --name test -p 9093:9093 prom/alertmanager  //创建容器用来获得alertmanager.yml配置文件\n\n[root@prometheus ~]# docker cp test:/etc/alertmanager/alertmanager.yml /alertmanager/\n</code></pre>\n<p>// 浏览器IP:9093，看到下面的页面表示成功，但是因为没有设置任何报警信息所以没有数据<br/> <img alt=\"\" src=\"image\\7b0bd97719374bfca96aabc41fdc1453.png\"/><br/> 这里说一下配置文件中几个重要的参数</p>\n<ul><li>global：全局配置，包括报警解决后的超时时间、SMTP相关配置、各种渠道通知的API地址等</li><li>route：用来设置报警的分发策略，它是一个树状结构，按照深度优先从左向右的顺序进行匹配。</li><li>receivers：配置告警消息接受者信息，例如常用的email、wechat、slack、webhook等消息通知方式</li><li>inhibit_rules：抑制规则配置，当存在与另一组匹配的警报(源)时，抑制规则将禁用与一组匹配的报警(目标)。</li></ul>\n<h4><a id=\"_231\"></a>配置邮箱报警</h4>\n<p><img alt=\"\" src=\"image\\fd548853c8e0451a9c82192515147e04.png\"/><br/> // 开启POP3/SMTP服务并生成授权码<br/> <img alt=\"\" src=\"image\\f13879c1887e45f08e2a4382d72304b6.png\"/></p>\n<p>// 生成授权码<br/> <img alt=\"\" src=\"image\\549e52affbf747b4a486c2f3dca7c835.png\"/></p>\n<h4><a id=\"alertmanageryml_239\"></a>配置alertmanager.yml文件</h4>\n<pre><code>[root@prometheus ~]# docker stop test\n[root@prometheus ~]# docker rm test\n[root@prometheus ~]# docker run -d -p 9093:9093 --name alertmanager -v /alertmanager/alertmanager.yml:/etc/alertmanager/alertmanager.yml prom/alertmanager\n</code></pre>\n<p>// alertmanager.yml文件内容<br/> <img alt=\"\" src=\"image\\b9d5c307e40f4490ac94362d4b85f45f.png\"/></p>\n<h4><a id=\"Prometheus_251\"></a>配置Prometheus部分</h4>\n<p>修改Prometheus.yml的alerting部分，让alertmanager能与Prometheus通信</p>\n<pre><code>[root@prometheus rules]# pwd\n/prometheus/rules\n[root@prometheus rules]# ls\nnode-up.rules\n\n[root@prometheus rules]# vim node-up.rules\ngroups:\n- name: node-up\n  rules:\n  - alert: node-up\n    expr: up{job=\"prometheus\"} == 0  //这个是在Prometheus.yml里面设置的job_name\n    for: 15s\n    labels:\n      severity: 1\n      team: node\n    annotations:\n      summary: \"{<!-- -->{ $labels.instance }} 停止运行超过15s啦!\"\n\n\n[root@prometheus prometheus]# pwd\n/prometheus\n\n[root@prometheus prometheus]# ls\nprometheus.yml  rules\n\n[root@prometheus prometheus]# head -17 prometheus.yml \n# my global config\nglobal:\n  scrape_interval: 15s # Set the scrape interval to every 15 seconds. Default is every 1 minute.\n  evaluation_interval: 15s # Evaluate rules every 15 seconds. The default is every 1 minute.\n  # scrape_timeout is set to the global default (10s).\n\n# Alertmanager configuration\nalerting:\n  alertmanagers:\n    - static_configs:\n        - targets:\n          - 192.168.182.130:9093\n          # - alertmanager:9093\n\n# Load rules once and periodically evaluate them according to the global 'evaluation_interval'.\nrule_files:\n  - \"/usr/local/prometheus/rules/*.rules\"\n</code></pre>\n<p><strong>rule_files为容器内路径，需要将本地node-up.rules文件挂载到容器指定的路径。</strong></p>\n<p><img alt=\"\" src=\"image\\fd880334c9334e17ad0d8881eba5c706.png\"/></p>\n<pre><code>// 随便关闭一个服务模拟故障\n[root@prometheus prometheus]# docker stop node-exporter \nnode-exporter\n</code></pre>\n<p><img alt=\"\" src=\"image\\7aceaee854df4e608efd41606cc8a7a9.png\"/></p>\n<h3><a id=\"Alertmanager_311\"></a>Alertmanager自定义邮件报警</h3>\n<p>创建alertmanager的模板文件</p>\n<pre><code>[root@prometheus alertmanager]# pwd\n/alertmanager\n\n[root@prometheus alertmanager]# mkdir template\n[root@prometheus alertmanager]# cd template/\n[root@prometheus template]# vim email.tmpl\n{<!-- -->{ define \"email.from\" }}572635840@qq.com{<!-- -->{ end }}\n{<!-- -->{ define \"email.to\" }}572635840@qq.com{<!-- -->{ end }}\n{<!-- -->{ define \"email.to.html\" }}\n{<!-- -->{ range .Alerts }}\n=========start==========&lt;br&gt;\n告警程序: prometheus_alert&lt;br&gt;\n告警级别: {<!-- -->{ .Labels.severity }} 级&lt;br&gt;\n告警类型: {<!-- -->{ .Labels.alertname }}&lt;br&gt;\n故障主机: {<!-- -->{ .Labels.instance }}&lt;br&gt;\n告警主题: {<!-- -->{ .Annotations.summary }}&lt;br&gt;\n触发时间: {<!-- -->{ (.StartsAt.Add 28800e9).Format \"2006-01-02 15:04:05\" }} &lt;br&gt;\n=========end==========&lt;br&gt;\n{<!-- -->{ end }}\n{<!-- -->{ end }}\n\n</code></pre>\n<p>// 修改alertmanager文件<br/> <img alt=\"\" src=\"image\\62cbb3e9707d4c2ab47b9d9e4e0e3a56.png\"/></p>\n<pre><code>[root@prometheus alertmanager]# docker stop alertmanager\n[root@prometheus alertmanager]# docker rm alertmanager\n\n[root@prometheus alertmanager]# docker run -d --name alertmanager -p 9093:9093 -v /alertmanager/alertmanager.yml:/etc/alertmanager/alertmanager.yml -v /alertmanager/template:/etc/alertmanager-tmpl prom/alertmanager\n</code></pre>\n<pre><code>// 重启测试alertmanager\n[root@prometheus alertmanager]# docker restart alertmanager\n</code></pre>\n<p><img alt=\"\" src=\"image\\2751f5ad5e9b4a05a94b45c9f6e2029c.png\"/></p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}