{"blogid": "126570618", "writerAge": "码龄7年", "writerBlogNum": "66", "writerCollect": "751", "writerComment": "1325", "writerFan": "1192", "writerGrade": "5级", "writerIntegral": "3252", "writerName": "会敲键盘的肘子", "writerProfileAdress": "writer_image\\profile_126570618.jpg", "writerRankTotal": "5745", "writerRankWeekly": "36", "writerThumb": "1040", "writerVisitNum": "130405", "blog_read_count": "3729", "blog_time": "于 2022-08-28 15:48:26 发布", "blog_title": "猿创征文｜【.Net实用方法总结】 整理并总结System.IO中FileStream类及其方法介绍", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atelier-sulphurpool-light\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<blockquote>\n<p>🐋作者简介：博主是一位.Net开发者，同时也是RPA和低代码平台的践行者。<br/> 🐬个人主页：<a href=\"https://blog.csdn.net/baidu_33146219?type=blog\">会敲键盘的肘子</a><br/> 🐰系列专栏：<a href=\"https://blog.csdn.net/baidu_33146219/category_11968078.html?spm=1001.2014.3001.5482\">.Net实用方法总结</a><br/> 🦀专栏简介：博主针对.Net开发和C站问答过程中遇到的问题进行总结，形成本专栏，希望可以帮助到您解决问题。<br/> 🐶座右铭：总有一天你所坚持的会反过来拥抱你。</p>\n</blockquote>\n<hr/>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\20149cf905ca46f78ca992f76476341b.png\"/></p>\n<blockquote>\n<p>🌈写在前面：</p>\n<p>本文主要介绍<strong>System.IO</strong>命名空间的<strong>FileStream</strong> 类，介绍其常用的方法和示例说明。</p>\n</blockquote>\n<hr/>\n<p><strong>👉本文关键字：System.IO、FileStream类、文件流、方法示例、C#</strong></p>\n<p></p>\n<div class=\"toc\">\n<h3>文章目录</h3>\n<ul><li><ul><li><ul><li><a href=\"#1_SystemIO_21\">1️⃣ System.IO命名空间</a></li><li><a href=\"#2_FileStream_45\">2️⃣ FileStream类</a></li><li><ul><li><a href=\"#__47\">♈ 定义</a></li><li><a href=\"#__55\">⛎ 示例</a></li><li><a href=\"#__147\">♉ 构造函数</a></li><li><ul><li><a href=\"#FileStreamString_FileMode_FileAccess_FileShare_Int32_FileOptions_151\">FileStream(String, FileMode, FileAccess, FileShare, Int32, FileOptions)</a></li><li><a href=\"#FileStreamString_FileMode_FileAccess_FileShare_Int32_Boolean_264\">FileStream(String, FileMode, FileAccess, FileShare, Int32, Boolean)</a></li><li><a href=\"#FileStreamString_FileMode_436\">FileStream(String, FileMode)</a></li></ul>\n</li><li><a href=\"#__504\">♊ 属性</a></li><li><ul><li><a href=\"#CanRead__506\">CanRead 当在派生类中重写时，获取指示当前流是否支持读取的值</a></li><li><a href=\"#CanWrite__535\">CanWrite 当在派生类中重写时，获取指示当前流是否支持写入功能的值</a></li><li><a href=\"#Length__566\">Length 当在派生类中重写时，获取流长度（以字节为单位）</a></li></ul>\n</li><li><a href=\"#__572\">♌ 常用方法</a></li><li><ul><li><a href=\"#Close__574\">Close() 关闭当前流并释放与之关联的所有资源（如套接字和文件句柄）</a></li><li><a href=\"#CopyToStream__582\">CopyTo(Stream) 从当前流中读取字节并将其写入到另一流中</a></li><li><a href=\"#CopyToStream_Int32__618\">CopyTo(Stream, Int32) 使用指定的缓冲区大小，从当前流中读取字节并将其写入到另一流中</a></li><li><a href=\"#CopyToAsyncStream__638\">CopyToAsync(Stream) 从当前流中异步读取字节并将其写入到另一个流中</a></li><li><a href=\"#Dispose__Stream__693\">Dispose() 释放由 Stream 使用的所有资源</a></li><li><a href=\"#ReadByte_Int32_Int32__699\">Read(Byte[], Int32, Int32) 当在派生类中重写时，从当前流读取字节序列，并将此流中的位置提升读取的字节数</a></li><li><a href=\"#ReadAsyncByte_Int32_Int32__772\">ReadAsync(Byte[], Int32, Int32) 从当前流异步读取字节序列，并将流中的位置提升读取的字节数</a></li><li><a href=\"#ReadByte__842\">ReadByte() 从文件中读取一个字节，并将读取位置提升一个字节</a></li><li><a href=\"#WriteByte_Int32_Int32__900\">Write(Byte[], Int32, Int32) 当在派生类中重写时，向当前流中写入字节序列，并将此流中的当前位置提升写入的字节数</a></li><li><a href=\"#WriteAsyncByte_Int32_Int32__930\">WriteAsync(Byte[], Int32, Int32) 将字节序列异步写入当前流，并将流的当前位置提升写入的字节数</a></li><li><a href=\"#WriteByteByte__1000\">WriteByte(Byte) 一个字节写入文件流中的当前位置</a></li><li><a href=\"#Flush__1060\">Flush() 清除此流的缓冲区，使得所有缓冲数据都写入到文件中</a></li><li><a href=\"#FlushAsync__1105\">FlushAsync() 异步清除此流的所有缓冲区并导致所有缓冲数据都写入基础设备中</a></li><li><a href=\"#LockInt64_Int64__FileStream_1117\">Lock(Int64, Int64) 防止其他进程读取或写入 FileStream</a></li><li><a href=\"#UnlockInt64_Int64__1299\">Unlock(Int64, Int64) 允许其他进程访问以前锁定的某个文件的全部或部分</a></li></ul>\n</li><li><a href=\"#__1481\">♍ 注解</a></li><li><a href=\"#__1493\">♎ 更多方法</a></li></ul>\n</li></ul>\n</li></ul>\n</li></ul>\n</div>\n<p></p>\n<h3><a id=\"1_SystemIO_21\"></a>1️⃣ System.IO命名空间</h3>\n<p>.NET中的IO操作命名空间，包含允许<strong>读写文件</strong>和<strong>数据流</strong>的类型以及提供基本<strong>文件和目录支持</strong>的类型。</p>\n<p>我们在.NET中的IO操作，经常需要调用一下几个类。</p>\n<ul><li><strong>FileStream类</strong></li></ul>\n<p>​ 文件流类，负责大文件的拷贝，读写。</p>\n<ul><li><strong>Path类</strong></li></ul>\n<p>​ Path类中方法，基本都是对字符串（文件名）的操作，与实际文件没多大关系。</p>\n<ul><li> <p><strong>File类</strong></p> <p>File类可以进行一些对小文件拷贝、剪切操作，还能读一些文档文件。</p> </li><li> <p><strong>Dirctory类</strong></p> <p>目录操作，创建文件、删除目录，获取目录下文件名等等。</p> </li></ul>\n<h3><a id=\"2_FileStream_45\"></a>2️⃣ FileStream类</h3>\n<h4><a id=\"__47\"></a>♈ 定义</h4>\n<p>为文件提供 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.io.stream?view=net-6.0\">Stream</a>，既支持同步读写操作，也支持异步读写操作。</p>\n<pre><code class=\"prism language-C#\">public class FileStream : System.IO.Stream\n</code></pre>\n<h4><a id=\"__55\"></a>⛎ 示例</h4>\n<p>下面的示例演示了一些 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream?view=net-6.0\">FileStream</a> 构造函数。</p>\n<pre><code class=\"prism language-c#\">using System;\nusing System.IO;\nusing System.Text;\n\nclass Test\n{\n\n    public static void Main()\n    {\n        string path = @\"c:\\temp\\MyTest.txt\";\n\n        // Delete the file if it exists.\n        if (File.Exists(path))\n        {\n            File.Delete(path);\n        }\n\n        //Create the file.\n        using (FileStream fs = File.Create(path))\n        {\n            AddText(fs, \"This is some text\");\n            AddText(fs, \"This is some more text,\");\n            AddText(fs, \"\\r\\nand this is on a new line\");\n            AddText(fs, \"\\r\\n\\r\\nThe following is a subset of characters:\\r\\n\");\n\n            for (int i=1;i &lt; 120;i++)\n            {\n                AddText(fs, Convert.ToChar(i).ToString());\n            }\n        }\n\n        //Open the stream and read it back.\n        using (FileStream fs = File.OpenRead(path))\n        {\n            byte[] b = new byte[1024];\n            UTF8Encoding temp = new UTF8Encoding(true);\n            while (fs.Read(b,0,b.Length) &gt; 0)\n            {\n                Console.WriteLine(temp.GetString(b));\n            }\n        }\n    }\n\n    private static void AddText(FileStream fs, string value)\n    {\n        byte[] info = new UTF8Encoding(true).GetBytes(value);\n        fs.Write(info, 0, info.Length);\n    }\n}\n</code></pre>\n<p>下面的示例演示如何异步写入文件。 此代码在 WPF 应用中运行，该应用具有名为 UserInput 的 TextBlock 和已挂接到名为 Button_Click 的 Click 事件处理程序的按钮。 文件路径需要更改为计算机上存在的文件。</p>\n<pre><code class=\"prism language-c#\">using System;\nusing System.Text;\nusing System.Threading.Tasks;\nusing System.Windows;\nusing System.Windows.Controls;\nusing System.IO;\n\nnamespace WpfApplication1\n{\n    public partial class MainWindow : Window\n    {\n        public MainWindow()\n        {\n            InitializeComponent();\n        }\n\n        private async void Button_Click(object sender, RoutedEventArgs e)\n        {\n            UnicodeEncoding uniencoding = new UnicodeEncoding();\n            string filename = @\"c:\\Users\\exampleuser\\Documents\\userinputlog.txt\";\n\n            byte[] result = uniencoding.GetBytes(UserInput.Text);\n\n            using (FileStream SourceStream = File.Open(filename, FileMode.OpenOrCreate))\n            {\n                SourceStream.Seek(0, SeekOrigin.End);\n                await SourceStream.WriteAsync(result, 0, result.Length);\n            }\n        }\n    }\n}\n</code></pre>\n<h4><a id=\"__147\"></a>♉ 构造函数</h4>\n<p>初始化 FileStream 类的新实例</p>\n<h5><a id=\"FileStreamString_FileMode_FileAccess_FileShare_Int32_FileOptions_151\"></a>FileStream(String, FileMode, FileAccess, FileShare, Int32, FileOptions)</h5>\n<p>使用指定的路径、创建模式、读/写和共享权限、其他 FileStreams 可以具有的对此文件的访问权限、缓冲区大小和附加文件选项初始化 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream?view=net-6.0\">FileStream</a> 类的新实例。</p>\n<pre><code class=\"prism language-C#\">public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options);\n</code></pre>\n<p><strong>参数</strong></p>\n<blockquote>\n<p><code>path</code></p>\n<p><a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.string?view=net-6.0\">String</a></p>\n<p>当前 <code>FileStream</code> 对象将封装的文件的相对路径或绝对路径。</p>\n<p><code>mode</code></p>\n<p><a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filemode?view=net-6.0\">FileMode</a></p>\n<p>用于确定文件的打开或创建方式的枚举值之一。</p>\n<p><code>access</code></p>\n<p><a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.io.fileaccess?view=net-6.0\">FileAccess</a></p>\n<p>枚举值的按位组合，这些枚举值确定 <code>FileStream</code> 对象访问文件的方式。 该常数还可以确定由 <code>FileStream</code> 对象的 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream.canread?view=net-6.0#system-io-filestream-canread\">CanRead</a> 和 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream.canwrite?view=net-6.0#system-io-filestream-canwrite\">CanWrite</a> 属性返回的值。 如果 <code>path</code> 指定磁盘文件，则 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream.canseek?view=net-6.0#system-io-filestream-canseek\">CanSeek</a> 为 <code>true</code>。</p>\n<p><code>share</code></p>\n<p><a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.io.fileshare?view=net-6.0\">FileShare</a></p>\n<p>枚举值的按位组合，这些枚举值确定进程共享文件的方式。</p>\n<p><code>bufferSize</code></p>\n<p><a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.int32?view=net-6.0\">Int32</a></p>\n<p>一个大于零的正 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.int32?view=net-6.0\">Int32</a> 值，表示缓冲区大小。 默认缓冲区大小为 4096。</p>\n<p><code>options</code></p>\n<p><a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.io.fileoptions?view=net-6.0\">FileOptions</a></p>\n<p>枚举值的按位组合，它用于指定其他文件选项。</p>\n</blockquote>\n<p><strong>示例</strong></p>\n<p>以下示例将数据写入文件，然后使用 对象读取 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream?view=net-6.0\">FileStream</a> 数据。</p>\n<pre><code class=\"prism language-c#\">using System;\nusing System.IO;\nusing System.Text;\nusing System.Security.AccessControl;\n\nnamespace FileSystemExample\n{\n    class FileStreamExample\n    {\n        public static void Main()\n        {\n            try\n            {\n                // Create a file and write data to it.\n\n                // Create an array of bytes.\n                byte[] messageByte = Encoding.ASCII.GetBytes(\"Here is some data.\");\n\n                // Create a file using the FileStream class.\n                FileStream fWrite = new FileStream(\"test.txt\", FileMode.Create, FileAccess.ReadWrite, FileShare.None, 8, FileOptions.None);\n\n                // Write the number of bytes to the file.\n                fWrite.WriteByte((byte)messageByte.Length);\n\n                // Write the bytes to the file.\n                fWrite.Write(messageByte, 0, messageByte.Length);\n\n                // Close the stream.\n                fWrite.Close();\n\n                // Open a file and read the number of bytes.\n\n                FileStream fRead = new FileStream(\"test.txt\", FileMode.Open);\n\n                // The first byte is the string length.\n                int length = (int)fRead.ReadByte();\n\n                // Create a new byte array for the data.\n                byte[] readBytes = new byte[length];\n\n                // Read the data from the file.\n                fRead.Read(readBytes, 0, readBytes.Length);\n\n                // Close the stream.\n                fRead.Close();\n\n                // Display the data.\n                Console.WriteLine(Encoding.ASCII.GetString(readBytes));\n\n                Console.WriteLine(\"Done writing and reading data.\");\n            }\n            catch (Exception e)\n            {\n                Console.WriteLine(e);\n            }\n\n            Console.ReadLine();\n        }\n    }\n}\n</code></pre>\n<h5><a id=\"FileStreamString_FileMode_FileAccess_FileShare_Int32_Boolean_264\"></a>FileStream(String, FileMode, FileAccess, FileShare, Int32, Boolean)</h5>\n<p>使用指定的路径、创建模式、读/写和共享权限、缓冲区大小和同步或异步状态初始化 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream?view=net-6.0\">FileStream</a> 类的新实例。</p>\n<pre><code class=\"prism language-C#\">public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, bool useAsync);\n</code></pre>\n<p><strong>参数</strong></p>\n<blockquote>\n<p><code>path</code></p>\n<p><a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.string?view=net-6.0\">String</a></p>\n<p>当前 <code>FileStream</code> 对象将封装的文件的相对路径或绝对路径。</p>\n<p><code>mode</code></p>\n<p><a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filemode?view=net-6.0\">FileMode</a></p>\n<p>用于确定文件的打开或创建方式的枚举值之一。</p>\n<p><code>access</code></p>\n<p><a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.io.fileaccess?view=net-6.0\">FileAccess</a></p>\n<p>枚举值的按位组合，这些枚举值确定 <code>FileStream</code> 对象访问文件的方式。 该常数还可以确定由 <code>FileStream</code> 对象的 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream.canread?view=net-6.0#system-io-filestream-canread\">CanRead</a> 和 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream.canwrite?view=net-6.0#system-io-filestream-canwrite\">CanWrite</a> 属性返回的值。 如果 <code>path</code> 指定磁盘文件，则 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream.canseek?view=net-6.0#system-io-filestream-canseek\">CanSeek</a> 为 <code>true</code>。</p>\n<p><code>share</code></p>\n<p><a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.io.fileshare?view=net-6.0\">FileShare</a></p>\n<p>枚举值的按位组合，这些枚举值确定进程共享文件的方式。</p>\n<p><code>bufferSize</code></p>\n<p><a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.int32?view=net-6.0\">Int32</a></p>\n<p>一个大于零的正 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.int32?view=net-6.0\">Int32</a> 值，表示缓冲区大小。 默认缓冲区大小为 4096。</p>\n<p><code>useAsync</code></p>\n<p><a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.boolean?view=net-6.0\">Boolean</a></p>\n<p>指定使用异步 I/O 还是同步 I/O。 但是，请注意，基础操作系统可能不支持异步 I/O，因此在指定 <code>true</code> 后，根据所用平台，句柄可能同步打开。 当异步打开时，[BeginRead(Byte<a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream.beginread?view=net-6.0#system-io-filestream-beginread%28system-byte%28%29-system-int32-system-int32-system-asynccallback-system-object%29\">], Int32, Int32, AsyncCallback, Object)</a> 和 [BeginWrite(Byte<a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream.beginwrite?view=net-6.0#system-io-filestream-beginwrite%28system-byte%28%29-system-int32-system-int32-system-asynccallback-system-object%29\">], Int32, Int32, AsyncCallback, Object)</a> 方法在执行大量读或写时效果更好，但对于少量的读/写，这些方法速度可能要慢得多。 如果应用程序打算利用异步 I/O，将 <code>useAsync</code> 参数设置为 <code>true</code>。 正确使用异步 I/O 可以使应用程序的速度加快 10 倍，但是如果在没有为异步 I/O 重新设计应用程序的情况下使用异步 I/O，则可能使性能降低 10 倍。</p>\n</blockquote>\n<p><strong>示例</strong></p>\n<p>下面的代码示例演示如何将数据异步写入文件，然后验证数据是否写入正确。 <code>State</code>创建 对象以将信息从主线程传递到 和 <code>EndReadCallback</code> <code>EndWriteCallback</code> 方法。</p>\n<pre><code class=\"prism language-c#\">using System;\nusing System.IO;\nusing System.Threading;\n\nclass FStream\n{\n    static void Main()\n    {\n        // Create a synchronization object that gets\n        // signaled when verification is complete.\n        ManualResetEvent manualEvent = new ManualResetEvent(false);\n\n        // Create random data to write to the file.\n        byte[] writeArray = new byte[100000];\n        new Random().NextBytes(writeArray);\n\n        FileStream fStream =\n            new FileStream(\"Test#@@#.dat\", FileMode.Create,\n            FileAccess.ReadWrite, FileShare.None, 4096, true);\n\n        // Check that the FileStream was opened asynchronously.\n        Console.WriteLine(\"fStream was {0}opened asynchronously.\",\n            fStream.IsAsync ? \"\" : \"not \");\n\n        // Asynchronously write to the file.\n        IAsyncResult asyncResult = fStream.BeginWrite(\n            writeArray, 0, writeArray.Length,\n            new AsyncCallback(EndWriteCallback),\n            new State(fStream, writeArray, manualEvent));\n\n        // Concurrently do other work and then wait\n        // for the data to be written and verified.\n        manualEvent.WaitOne(5000, false);\n    }\n\n    // When BeginWrite is finished writing data to the file, the\n    // EndWriteCallback method is called to end the asynchronous\n    // write operation and then read back and verify the data.\n    static void EndWriteCallback(IAsyncResult asyncResult)\n    {\n        State tempState = (State)asyncResult.AsyncState;\n        FileStream fStream = tempState.FStream;\n        fStream.EndWrite(asyncResult);\n\n        // Asynchronously read back the written data.\n        fStream.Position = 0;\n        asyncResult = fStream.BeginRead(\n            tempState.ReadArray, 0 , tempState.ReadArray.Length,\n            new AsyncCallback(EndReadCallback), tempState);\n\n        // Concurrently do other work, such as\n        // logging the write operation.\n    }\n\n    // When BeginRead is finished reading data from the file, the\n    // EndReadCallback method is called to end the asynchronous\n    // read operation and then verify the data.\n    static void EndReadCallback(IAsyncResult asyncResult)\n    {\n        State tempState = (State)asyncResult.AsyncState;\n        int readCount = tempState.FStream.EndRead(asyncResult);\n\n        int i = 0;\n        while(i &lt; readCount)\n        {\n            if(tempState.ReadArray[i] != tempState.WriteArray[i++])\n            {\n                Console.WriteLine(\"Error writing data.\");\n                tempState.FStream.Close();\n                return;\n            }\n        }\n        Console.WriteLine(\"The data was written to {0} and verified.\",\n            tempState.FStream.Name);\n        tempState.FStream.Close();\n\n        // Signal the main thread that the verification is finished.\n        tempState.ManualEvent.Set();\n    }\n\n    // Maintain state information to be passed to\n    // EndWriteCallback and EndReadCallback.\n    class State\n    {\n        // fStream is used to read and write to the file.\n        FileStream fStream;\n\n        // writeArray stores data that is written to the file.\n        byte[] writeArray;\n\n        // readArray stores data that is read from the file.\n        byte[] readArray;\n\n        // manualEvent signals the main thread\n        // when verification is complete.\n        ManualResetEvent manualEvent;\n\n        public State(FileStream fStream, byte[] writeArray,\n            ManualResetEvent manualEvent)\n        {\n            this.fStream   = fStream;\n            this.writeArray = writeArray;\n            this.manualEvent = manualEvent;\n            readArray = new byte[writeArray.Length];\n        }\n\n        public FileStream FStream\n        { get{ return fStream; } }\n\n        public byte[] WriteArray\n        { get{ return writeArray; } }\n\n        public byte[] ReadArray\n        { get{ return readArray; } }\n\n        public ManualResetEvent ManualEvent\n        { get{ return manualEvent; } }\n    }\n}\n</code></pre>\n<h5><a id=\"FileStreamString_FileMode_436\"></a>FileStream(String, FileMode)</h5>\n<p>使用指定的路径和创建模式初始化 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream?view=net-6.0\">FileStream</a> 类的新实例。</p>\n<pre><code class=\"prism language-C#\">public FileStream (string path, System.IO.FileMode mode);\n</code></pre>\n<p><strong>参数</strong></p>\n<blockquote>\n<p><code>path</code></p>\n<p><a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.string?view=net-6.0\">String</a></p>\n<p>当前 <code>FileStream</code> 对象将封装的文件的相对路径或绝对路径。</p>\n<p><code>mode</code></p>\n<p><a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filemode?view=net-6.0\">FileMode</a></p>\n<p>用于确定文件的打开或创建方式的枚举值之一。</p>\n</blockquote>\n<p><strong>示例</strong></p>\n<p>下面的代码示例演示了如何按字节将数据写入文件，然后验证是否已正确写入数据。</p>\n<pre><code class=\"prism language-c#\">using System;\nusing System.IO;\n\nclass FStream\n{\n    static void Main()\n    {\n        const string fileName = \"Test#@@#.dat\";\n\n        // Create random data to write to the file.\n        byte[] dataArray = new byte[100000];\n        new Random().NextBytes(dataArray);\n\n        using(FileStream\n            fileStream = new FileStream(fileName, FileMode.Create))\n        {\n            // Write the data to the file, byte by byte.\n            for(int i = 0; i &lt; dataArray.Length; i++)\n            {\n                fileStream.WriteByte(dataArray[i]);\n            }\n\n            // Set the stream position to the beginning of the file.\n            fileStream.Seek(0, SeekOrigin.Begin);\n\n            // Read and verify the data.\n            for(int i = 0; i &lt; fileStream.Length; i++)\n            {\n                if(dataArray[i] != fileStream.ReadByte())\n                {\n                    Console.WriteLine(\"Error writing data.\");\n                    return;\n                }\n            }\n            Console.WriteLine(\"The data was written to {0} \" +\n                \"and verified.\", fileStream.Name);\n        }\n    }\n}\n</code></pre>\n<h4><a id=\"__504\"></a>♊ 属性</h4>\n<h5><a id=\"CanRead__506\"></a>CanRead 当在派生类中重写时，获取指示当前流是否支持读取的值</h5>\n<pre><code class=\"prism language-C#\">public abstract bool CanRead { get; }\n</code></pre>\n<p><strong>示例</strong></p>\n<pre><code class=\"prism language-c#\">using System;\nusing System.IO;\n\nclass TestRW\n{\n    public static void Main(String[] args)\n    {\n        FileStream fs = new FileStream(\"MyFile.txt\", FileMode.OpenOrCreate, FileAccess.Read);\n        if (fs.CanRead &amp;&amp; fs.CanWrite)\n        {\n            Console.WriteLine(\"MyFile.txt can be both written to and read from.\");\n        }\n        else if (fs.CanRead)\n        {\n            Console.WriteLine(\"MyFile.txt is not writable.\");\n        }\n    }\n}\n</code></pre>\n<h5><a id=\"CanWrite__535\"></a>CanWrite 当在派生类中重写时，获取指示当前流是否支持写入功能的值</h5>\n<pre><code class=\"prism language-C#\">public abstract bool CanWrite { get; }\n</code></pre>\n<p><strong>示例</strong></p>\n<pre><code class=\"prism language-c#\">using System;\nusing System.IO;\n\nclass TestRW\n{\n  public static void Main(String[] args)\n  {\n    FileStream fs = new FileStream(\"MyFile.txt\", FileMode.OpenOrCreate,\n       FileAccess.Write);\n    if (fs.CanRead &amp;&amp; fs.CanWrite) {\n        Console.WriteLine(\"MyFile.txt can be both written to and read from.\");\n    }\n    else if (fs.CanWrite) {\n        Console.WriteLine(\"MyFile.txt is writable.\");\n    }\n  }\n}\n//This code outputs \"MyFile.txt is writable.\"\n//To get the output message \"MyFile.txt can be both written to and read from.\",\n//change the FileAccess parameter to ReadWrite in the FileStream constructor.\n</code></pre>\n<h5><a id=\"Length__566\"></a>Length 当在派生类中重写时，获取流长度（以字节为单位）</h5>\n<pre><code class=\"prism language-C#\">public abstract long Length { get; }\n</code></pre>\n<h4><a id=\"__572\"></a>♌ 常用方法</h4>\n<h5><a id=\"Close__574\"></a>Close() 关闭当前流并释放与之关联的所有资源（如套接字和文件句柄）</h5>\n<pre><code class=\"prism language-C#\">public virtual void Close ();\n</code></pre>\n<blockquote>\n<p>注意：此方法调用 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.io.stream.dispose?view=net-6.0\">Dispose</a> ，指定 <code>true</code> 以释放所有资源。 不需要专门调用 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.io.stream.close?view=net-6.0\">Close</a> 方法。 请确保 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.io.stream?view=net-6.0\">Stream</a> 已正确释放每个对象。 可以 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.io.stream?view=net-6.0\">Stream</a> <code>using</code> <code>Using</code> 在 Visual Basic) 中 (或块中声明对象，以确保释放流及其所有资源，或者可以显式调用 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.io.stream.dispose?view=net-6.0\">Dispose</a> 方法。</p>\n</blockquote>\n<h5><a id=\"CopyToStream__582\"></a>CopyTo(Stream) 从当前流中读取字节并将其写入到另一流中</h5>\n<pre><code class=\"prism language-C#\">public void CopyTo (System.IO.Stream destination);\n</code></pre>\n<p><strong>参数</strong></p>\n<blockquote>\n<p><code>destination</code></p>\n<p><strong>Stream</strong></p>\n<p>当前流的内容将复制到的流。</p>\n</blockquote>\n<p><strong>示例</strong></p>\n<p>下面的示例将的内容复制 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream?view=net-6.0\">FileStream</a> 到 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.io.memorystream?view=net-6.0\">MemoryStream</a> 中。</p>\n<pre><code class=\"prism language-C#\">// Create the streams.\nMemoryStream destination = new MemoryStream();\n\nusing (FileStream source = File.Open(@\"c:\\temp\\data.dat\",\n    FileMode.Open))\n{\n\n    Console.WriteLine(\"Source length: {0}\", source.Length.ToString());\n\n    // Copy source to destination.\n    source.CopyTo(destination);\n}\n\nConsole.WriteLine(\"Destination length: {0}\", destination.Length.ToString());\n</code></pre>\n<h5><a id=\"CopyToStream_Int32__618\"></a>CopyTo(Stream, Int32) 使用指定的缓冲区大小，从当前流中读取字节并将其写入到另一流中</h5>\n<pre><code class=\"prism language-C#\">public virtual void CopyTo (System.IO.Stream destination, int bufferSize);\n</code></pre>\n<p><strong>参数</strong></p>\n<blockquote>\n<p><code>destination</code></p>\n<p><strong>Stream</strong></p>\n<p>当前流的内容将复制到的流。</p>\n<p><code>bufferSize</code></p>\n<p><strong>Int</strong></p>\n<p>缓冲区的大小。 此值必须大于零。 默认大小为 81920。</p>\n</blockquote>\n<h5><a id=\"CopyToAsyncStream__638\"></a>CopyToAsync(Stream) 从当前流中异步读取字节并将其写入到另一个流中</h5>\n<pre><code class=\"prism language-C#\">public System.Threading.Tasks.Task CopyToAsync (System.IO.Stream destination);\n</code></pre>\n<p><strong>参数</strong></p>\n<blockquote>\n<p><code>destination</code></p>\n<p><strong>Stream</strong></p>\n<p>当前流的内容将复制到的流。</p>\n</blockquote>\n<p><strong>示例</strong></p>\n<p>下面的示例演示如何使用两个 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream?view=net-6.0\">FileStream</a> 对象将文件从一个目录异步复制到另一个目录。 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream?view=net-6.0\">FileStream</a> 类是从 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.io.stream?view=net-6.0\">Stream</a> 类派生的。 请注意， <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.web.ui.webcontrols.button.click?view=net-6.0\">Click</a> 控件的事件处理程序 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.button?view=net-6.0\">Button</a> 使用修饰符标记， <code>async</code> 因为它调用异步方法</p>\n<pre><code class=\"prism language-C#\">using System;\nusing System.Threading.Tasks;\nusing System.Windows;\nusing System.IO;\n\nnamespace WpfApplication\n{\n    public partial class MainWindow : Window\n    {\n        public MainWindow()\n        {\n            InitializeComponent();\n        }\n\n        private async void Button_Click(object sender, RoutedEventArgs e)\n        {\n            string StartDirectory = @\"c:\\Users\\exampleuser\\start\";\n            string EndDirectory = @\"c:\\Users\\exampleuser\\end\";\n\n            foreach (string filename in Directory.EnumerateFiles(StartDirectory))\n            {\n                using (FileStream SourceStream = File.Open(filename, FileMode.Open))\n                {\n                    using (FileStream DestinationStream = File.Create(EndDirectory + filename.Substring(filename.LastIndexOf('\\\\'))))\n                    {\n                        await SourceStream.CopyToAsync(DestinationStream);\n                    }\n                }\n            }\n        }\n    }\n}\n</code></pre>\n<blockquote>\n<p><a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.io.stream.copytoasync?view=net-6.0\">CopyToAsync</a>方法使你可以在不阻塞主线程的情况下执行占用大量资源的 i/o 操作。</p>\n</blockquote>\n<h5><a id=\"Dispose__Stream__693\"></a>Dispose() 释放由 Stream 使用的所有资源</h5>\n<pre><code class=\"prism language-C#\">public void Dispose ();\n</code></pre>\n<h5><a id=\"ReadByte_Int32_Int32__699\"></a>Read(Byte[], Int32, Int32) 当在派生类中重写时，从当前流读取字节序列，并将此流中的位置提升读取的字节数</h5>\n<pre><code class=\"prism language-C#\">public abstract int Read (byte[] buffer, int offset, int count);\n</code></pre>\n<p><strong>参数</strong></p>\n<blockquote>\n<p><code>buffer</code></p>\n<p><a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.byte?view=net-6.0\">Byte</a>[]</p>\n<p>字节数组。 当此方法返回时，此缓冲区包含指定的字符数组，此数组中 <code>offset</code> 和 (<code>offset</code> + <code>count</code> - 1) 之间的值被从当前源中读取的字节所替换。</p>\n<p><code>offset</code></p>\n<p><a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.int32?view=net-6.0\">Int32</a></p>\n<p><code>buffer</code> 中的从零开始的字节偏移量，从此处开始存储从当前流中读取的数据。</p>\n<p><code>count</code></p>\n<p><a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.int32?view=net-6.0\">Int32</a></p>\n<p>要从当前流中最多读取的字节数。</p>\n</blockquote>\n<p><strong>返回</strong></p>\n<blockquote>\n<p><a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.int32?view=net-6.0\">Int32</a></p>\n<p>读入缓冲区中的总字节数。 如果很多字节当前不可用，则总字节数可能小于请求的字节数；如果已到达流结尾，则为零 (0)。</p>\n</blockquote>\n<p><strong>示例</strong></p>\n<p>下面的示例演示如何使用 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.io.stream.read?view=net-6.0\">Read</a> 读取数据块。</p>\n<pre><code class=\"prism language-C#\">using System;\nusing System.IO;\n\npublic class Block\n{\n    public static void Main()\n    {\n        Stream s = new MemoryStream();\n        for (int i = 0; i &lt; 122; i++)\n        {\n            s.WriteByte((byte)i);\n        }\n        s.Position = 0;\n\n        // Now read s into a byte buffer with a little padding.\n        byte[] bytes = new byte[s.Length + 10];\n        int numBytesToRead = (int)s.Length;\n        int numBytesRead = 0;\n        do\n        {\n            // Read may return anything from 0 to 10.\n            int n = s.Read(bytes, numBytesRead, 10);\n            numBytesRead += n;\n            numBytesToRead -= n;\n        } while (numBytesToRead &gt; 0);\n        s.Close();\n\n        Console.WriteLine(\"number of bytes read: {0:d}\", numBytesRead);\n    }\n}\n</code></pre>\n<blockquote>\n<p>使用 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.io.stream.canread?view=net-6.0\">CanRead</a> 属性确定当前实例是否支持读取。 使用 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.io.stream.readasync?view=net-6.0\">ReadAsync</a> 方法从当前流异步读取。</p>\n<p>此方法的实现从当前流中读取最大字节 <code>count</code> 数，并存储从 <code>buffer</code> 开始的字节 <code>offset</code> 。 流中的当前位置按读取的字节数进行高级;但是，如果发生异常，则流中的当前位置保持不变。 实现返回读取的字节数。 在没有任何数据可用时，实现将一直阻止，直到至少可以读取一个字节的数据。 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.io.stream.read?view=net-6.0\">Read</a> 仅在流中没有更多数据且预期没有更多数据（例如关闭套接字或文件结尾） (返回 0) 。 即使尚未到达流的末尾，实现也能够返回比请求的更少的字节。</p>\n</blockquote>\n<h5><a id=\"ReadAsyncByte_Int32_Int32__772\"></a>ReadAsync(Byte[], Int32, Int32) 从当前流异步读取字节序列，并将流中的位置提升读取的字节数</h5>\n<pre><code class=\"prism language-C#\">public System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int count);\n</code></pre>\n<p><strong>参数</strong></p>\n<blockquote>\n<p><code>buffer</code></p>\n<p><a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.byte?view=net-6.0\">Byte</a>[]</p>\n<p>要写入数据的缓冲区。</p>\n<p><code>offset</code></p>\n<p><a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.int32?view=net-6.0\">Int32</a></p>\n<p><code>buffer</code> 中的字节偏移量，从该偏移量开始写入从流中读取的数据。</p>\n<p><code>count</code></p>\n<p><a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.int32?view=net-6.0\">Int32</a></p>\n<p>最多读取的字节数。</p>\n</blockquote>\n<p><strong>返回</strong></p>\n<blockquote>\n<p><a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task-1?view=net-6.0\">Task</a>&lt;<a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.int32?view=net-6.0\">Int32</a>&gt;</p>\n<p>表示异步读取操作的任务。 <code>TResult</code> 参数的值包含读入缓冲区的总字节数。 如果当前可用字节数少于所请求的字节数，则该结果值可小于所请求的字节数；如果已到达流结尾时，则为 0（零）。</p>\n</blockquote>\n<p><strong>示例</strong></p>\n<p>下面的示例演示如何以异步方式从文件读取。 该示例使用 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream?view=net-6.0\">FileStream</a> 类，该类派生自 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.io.stream?view=net-6.0\">Stream</a> 类。</p>\n<pre><code class=\"prism language-C#\">using System;\nusing System.Text;\nusing System.Threading.Tasks;\nusing System.Windows;\nusing System.Windows.Controls;\nusing System.IO;\n\nnamespace WpfApplication1\n{\n    public partial class MainWindow : Window\n    {\n        public MainWindow()\n        {\n            InitializeComponent();\n        }\n\n        private async void Button_Click(object sender, RoutedEventArgs e)\n        {\n            string filename = @\"c:\\Temp\\userinputlog.txt\";\n            byte[] result;\n\n            using (FileStream SourceStream = File.Open(filename, FileMode.Open))\n            {\n                result = new byte[SourceStream.Length];\n                await SourceStream.ReadAsync(result, 0, (int)SourceStream.Length);\n            }\n\n            UserInput.Text = System.Text.Encoding.ASCII.GetString(result);\n        }\n    }\n}\n</code></pre>\n<h5><a id=\"ReadByte__842\"></a>ReadByte() 从文件中读取一个字节，并将读取位置提升一个字节</h5>\n<pre><code class=\"prism language-C#\">public override int ReadByte ();\n</code></pre>\n<p><strong>返回</strong></p>\n<blockquote>\n<p><a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.int32?view=net-6.0\">Int32</a></p>\n<p>强制转换为 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.int32?view=net-6.0\">Int32</a> 的字节；或者如果已到达流的末尾，则为 -1。</p>\n</blockquote>\n<p><strong>示例</strong></p>\n<p>下面的代码示例演示了如何按字节将数据写入文件，然后验证是否已正确写入数据。</p>\n<pre><code class=\"prism language-C#\">using System;\nusing System.IO;\n\nclass FStream\n{\n    static void Main()\n    {\n        const string fileName = \"Test#@@#.dat\";\n\n        // Create random data to write to the file.\n        byte[] dataArray = new byte[100000];\n        new Random().NextBytes(dataArray);\n\n        using(FileStream\n            fileStream = new FileStream(fileName, FileMode.Create))\n        {\n            // Write the data to the file, byte by byte.\n            for(int i = 0; i &lt; dataArray.Length; i++)\n            {\n                fileStream.WriteByte(dataArray[i]);\n            }\n\n            // Set the stream position to the beginning of the file.\n            fileStream.Seek(0, SeekOrigin.Begin);\n\n            // Read and verify the data.\n            for(int i = 0; i &lt; fileStream.Length; i++)\n            {\n                if(dataArray[i] != fileStream.ReadByte())\n                {\n                    Console.WriteLine(\"Error writing data.\");\n                    return;\n                }\n            }\n            Console.WriteLine(\"The data was written to {0} \" +\n                \"and verified.\", fileStream.Name);\n        }\n    }\n}\n</code></pre>\n<h5><a id=\"WriteByte_Int32_Int32__900\"></a>Write(Byte[], Int32, Int32) 当在派生类中重写时，向当前流中写入字节序列，并将此流中的当前位置提升写入的字节数</h5>\n<pre><code class=\"prism language-C#\">public abstract void Write (byte[] buffer, int offset, int count);\n</code></pre>\n<p><strong>参数</strong></p>\n<blockquote>\n<p><code>buffer</code></p>\n<p><a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.byte?view=net-6.0\">Byte</a>[]</p>\n<p>字节数组。 此方法将 <code>count</code> 个字节从 <code>buffer</code> 复制到当前流。</p>\n<p><code>offset</code></p>\n<p><a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.int32?view=net-6.0\">Int32</a></p>\n<p><code>buffer</code> 中的从零开始的字节偏移量，从此处开始将字节复制到当前流。</p>\n<p><code>count</code></p>\n<p><a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.int32?view=net-6.0\">Int32</a></p>\n<p>要写入当前流的字节数。</p>\n</blockquote>\n<blockquote>\n<p>使用 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.io.stream.canwrite?view=net-6.0\">CanWrite</a> 属性确定当前实例是否支持写入。 使用 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.io.stream.writeasync?view=net-6.0\">WriteAsync</a> 方法异步写入当前流。</p>\n<p>如果写入操作成功，则流中的位置将按写入的字节数前进。 如果发生异常，则流中的位置保持不变。</p>\n</blockquote>\n<h5><a id=\"WriteAsyncByte_Int32_Int32__930\"></a>WriteAsync(Byte[], Int32, Int32) 将字节序列异步写入当前流，并将流的当前位置提升写入的字节数</h5>\n<pre><code class=\"prism language-C#\">public System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count);\n</code></pre>\n<p><strong>参数</strong></p>\n<blockquote>\n<p><code>buffer</code></p>\n<p><a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.byte?view=net-6.0\">Byte</a>[]</p>\n<p>从中写入数据的缓冲区。</p>\n<p><code>offset</code></p>\n<p><a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.int32?view=net-6.0\">Int32</a></p>\n<p><code>buffer</code> 中的从零开始的字节偏移量，从此处开始将字节复制到该流。</p>\n<p><code>count</code></p>\n<p><a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.int32?view=net-6.0\">Int32</a></p>\n<p>最多写入的字节数。</p>\n</blockquote>\n<p><strong>返回</strong></p>\n<blockquote>\n<p><a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task?view=net-6.0\">Task</a></p>\n<p>表示异步写入操作的任务。</p>\n</blockquote>\n<p><strong>示例</strong></p>\n<p>下面的示例演示如何异步写入文件。 该示例使用 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream?view=net-6.0\">FileStream</a> 类，该类派生自 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.io.stream?view=net-6.0\">Stream</a> 类。</p>\n<pre><code class=\"prism language-C#\">using System;\nusing System.Text;\nusing System.Threading.Tasks;\nusing System.Windows;\nusing System.Windows.Controls;\nusing System.IO;\n\nnamespace WpfApplication1\n{\n    public partial class MainWindow : Window\n    {\n        public MainWindow()\n        {\n            InitializeComponent();\n        }\n\n        private async void Button_Click(object sender, RoutedEventArgs e)\n        {\n            UnicodeEncoding uniencoding = new UnicodeEncoding();\n            string filename = @\"c:\\Users\\exampleuser\\Documents\\userinputlog.txt\";\n\n            byte[] result = uniencoding.GetBytes(UserInput.Text);\n\n            using (FileStream SourceStream = File.Open(filename, FileMode.OpenOrCreate))\n            {\n                SourceStream.Seek(0, SeekOrigin.End);\n                await SourceStream.WriteAsync(result, 0, result.Length);\n            }\n        }\n    }\n}\n</code></pre>\n<h5><a id=\"WriteByteByte__1000\"></a>WriteByte(Byte) 一个字节写入文件流中的当前位置</h5>\n<pre><code class=\"prism language-C#\">public override void WriteByte (byte value);\n</code></pre>\n<p><strong>参数</strong></p>\n<blockquote>\n<p><code>value</code></p>\n<p><a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.byte?view=net-6.0\">Byte</a></p>\n<p>要写入流的字节。</p>\n</blockquote>\n<p><strong>示例</strong></p>\n<p>下面的代码示例演示如何将数据以字节字节形式写入文件，然后验证数据是否写入正确。</p>\n<pre><code class=\"prism language-C#\">using System;\nusing System.IO;\n\nclass FStream\n{\n    static void Main()\n    {\n        const string fileName = \"Test#@@#.dat\";\n\n        // Create random data to write to the file.\n        byte[] dataArray = new byte[100000];\n        new Random().NextBytes(dataArray);\n\n        using(FileStream\n            fileStream = new FileStream(fileName, FileMode.Create))\n        {\n            // Write the data to the file, byte by byte.\n            for(int i = 0; i &lt; dataArray.Length; i++)\n            {\n                fileStream.WriteByte(dataArray[i]);\n            }\n\n            // Set the stream position to the beginning of the file.\n            fileStream.Seek(0, SeekOrigin.Begin);\n\n            // Read and verify the data.\n            for(int i = 0; i &lt; fileStream.Length; i++)\n            {\n                if(dataArray[i] != fileStream.ReadByte())\n                {\n                    Console.WriteLine(\"Error writing data.\");\n                    return;\n                }\n            }\n            Console.WriteLine(\"The data was written to {0} \" +\n                \"and verified.\", fileStream.Name);\n        }\n    }\n}\n</code></pre>\n<h5><a id=\"Flush__1060\"></a>Flush() 清除此流的缓冲区，使得所有缓冲数据都写入到文件中</h5>\n<pre><code class=\"prism language-C#\">public override void Flush ();\n</code></pre>\n<p><strong>示例</strong></p>\n<p>此代码示例是为 方法提供的较大示例的 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream.lock?view=net-6.0\">Lock</a> 一部分。</p>\n<pre><code class=\"prism language-C#\">// Update the file.\ncase 'W':\n    try\n    {\n        fileStream.Seek(textLength,\n            SeekOrigin.Begin);\n        fileStream.Read(\n            readText, textLength - 1, byteCount);\n        tempString = new String(\n            uniEncoding.GetChars(\n            readText, textLength - 1, byteCount));\n        recordNumber = int.Parse(tempString) + 1;\n        fileStream.Seek(\n            textLength, SeekOrigin.Begin);\n        fileStream.Write(uniEncoding.GetBytes(\n            recordNumber.ToString()),\n            0, byteCount);\n        fileStream.Flush();\n        Console.WriteLine(\n            \"Record has been updated.\");\n    }\n</code></pre>\n<blockquote>\n<p>此方法重写 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.io.stream.flush?view=net-6.0\">Stream.Flush</a>。</p>\n<p>调用 方法 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream.flush?view=net-6.0\">FileStream.Flush</a> 时，也会刷新操作系统 I/O 缓冲区。</p>\n<p>除非显式调用或释放 对象，否则不会刷新 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream.flush?view=net-6.0\">Flush</a> 流的编码器。 设置为 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.io.streamwriter.autoflush?view=net-6.0\">StreamWriter.AutoFlush</a> <code>true</code> 表示数据从缓冲区刷新到流，但不刷新编码器状态。 这允许编码器保留其状态 (部分字符) 以便它可以正确编码下一个字符块。 这种情况会影响 UTF8 和 UTF7，其中某些字符只能在编码器收到相邻字符后进行编码。</p>\n<p>由于缓冲区可用于读取或写入， <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream.flush?view=net-6.0#system-io-filestream-flush\">Flush()</a> 因此 执行以下两个函数：</p>\n<ul><li>以前写入缓冲区的任何数据都复制到文件，并且缓冲区被清除，但编码器状态除外。</li><li>如果 为 且数据以前从文件复制到缓冲区进行读取，则文件中当前位置将减少缓冲区中未读 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.io.bufferedstream.canseek?view=net-6.0\">BufferedStream.CanSeek</a> <code>true</code> 字节数。 然后清除缓冲区。</li></ul>\n</blockquote>\n<h5><a id=\"FlushAsync__1105\"></a>FlushAsync() 异步清除此流的所有缓冲区并导致所有缓冲数据都写入基础设备中</h5>\n<pre><code class=\"prism language-C#\">public System.Threading.Tasks.Task FlushAsync ();\n</code></pre>\n<p><strong>返回</strong></p>\n<blockquote>\n<p><a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task?view=net-6.0\">Task</a></p>\n<p>表示异步刷新操作的任务。</p>\n</blockquote>\n<h5><a id=\"LockInt64_Int64__FileStream_1117\"></a>Lock(Int64, Int64) 防止其他进程读取或写入 FileStream</h5>\n<pre><code class=\"prism language-C#\">[System.Runtime.Versioning.UnsupportedOSPlatform(\"ios\")]\n[System.Runtime.Versioning.UnsupportedOSPlatform(\"macos\")]\n[System.Runtime.Versioning.UnsupportedOSPlatform(\"tvos\")]\npublic virtual void Lock (long position, long length);\n</code></pre>\n<p><strong>参数</strong></p>\n<blockquote>\n<p><code>position</code></p>\n<p><a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.int64?view=net-6.0\">Int64</a></p>\n<p>要锁定的范围的起始处。 此参数的值必须大于或等于零 (0)。</p>\n<p><code>length</code></p>\n<p><a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.int64?view=net-6.0\">Int64</a></p>\n<p>要锁定的范围。</p>\n</blockquote>\n<p><strong>示例</strong></p>\n<p>下面的代码示例演示如何锁定文件的一部分，以便另一个进程无法访问该文件的该部分，即使它具有对文件的读/写访问权限。 在不同的命令窗口中同时运行程序，并使用不同的控制台输入选项进行调查。</p>\n<pre><code class=\"prism language-C#\">using System;\nusing System.IO;\nusing System.Text;\n\nclass FStreamLock\n{\n    static void Main()\n    {\n        UnicodeEncoding uniEncoding = new UnicodeEncoding();\n        string lastRecordText =\n            \"The last processed record number was: \";\n        int textLength = uniEncoding.GetByteCount(lastRecordText);\n        int recordNumber = 13;\n        int byteCount =\n            uniEncoding.GetByteCount(recordNumber.ToString());\n        string tempString;\n\n        using(FileStream fileStream = new FileStream(\n            \"Test#@@#.dat\", FileMode.OpenOrCreate,\n            FileAccess.ReadWrite, FileShare.ReadWrite))\n        {\n            // Write the original file data.\n            if(fileStream.Length == 0)\n            {\n                tempString =\n                    lastRecordText + recordNumber.ToString();\n                fileStream.Write(uniEncoding.GetBytes(tempString),\n                    0, uniEncoding.GetByteCount(tempString));\n            }\n\n            // Allow the user to choose the operation.\n            char consoleInput = 'R';\n            byte[] readText = new byte[fileStream.Length];\n            while(consoleInput != 'X')\n            {\n                Console.Write(\n                    \"\\nEnter 'R' to read, 'W' to write, 'L' to \" +\n                    \"lock, 'U' to unlock, anything else to exit: \");\n\n                if((tempString = Console.ReadLine()).Length == 0)\n                {\n                    break;\n                }\n                consoleInput = char.ToUpper(tempString[0]);\n                switch(consoleInput)\n                {\n                    // Read data from the file and\n                    // write it to the console.\n                    case 'R':\n                        try\n                        {\n                            fileStream.Seek(0, SeekOrigin.Begin);\n                            fileStream.Read(\n                                readText, 0, (int)fileStream.Length);\n                            tempString = new String(\n                                uniEncoding.GetChars(\n                                readText, 0, readText.Length));\n                            Console.WriteLine(tempString);\n                            recordNumber = int.Parse(\n                                tempString.Substring(\n                                tempString.IndexOf(':') + 2));\n                        }\n\n                        // Catch the IOException generated if the\n                        // specified part of the file is locked.\n                        catch(IOException e)\n                        {\n                            Console.WriteLine(\"{0}: The read \" +\n                                \"operation could not be performed \" +\n                                \"because the specified part of the \" +\n                                \"file is locked.\",\n                                e.GetType().Name);\n                        }\n                        break;\n\n                    // Update the file.\n                    case 'W':\n                        try\n                        {\n                            fileStream.Seek(textLength,\n                                SeekOrigin.Begin);\n                            fileStream.Read(\n                                readText, textLength - 1, byteCount);\n                            tempString = new String(\n                                uniEncoding.GetChars(\n                                readText, textLength - 1, byteCount));\n                            recordNumber = int.Parse(tempString) + 1;\n                            fileStream.Seek(\n                                textLength, SeekOrigin.Begin);\n                            fileStream.Write(uniEncoding.GetBytes(\n                                recordNumber.ToString()),\n                                0, byteCount);\n                            fileStream.Flush();\n                            Console.WriteLine(\n                                \"Record has been updated.\");\n                        }\n\n                        // Catch the IOException generated if the\n                        // specified part of the file is locked.\n                        catch(IOException e)\n                        {\n                            Console.WriteLine(\n                                \"{0}: The write operation could not \" +\n                                \"be performed because the specified \" +\n                                \"part of the file is locked.\",\n                                e.GetType().Name);\n                        }\n                        break;\n\n                    // Lock the specified part of the file.\n                    case 'L':\n                        try\n                        {\n                            fileStream.Lock(textLength - 1, byteCount);\n                            Console.WriteLine(\"The specified part \" +\n                                \"of file has been locked.\");\n                        }\n                        catch(IOException e)\n                        {\n                            Console.WriteLine(\n                                \"{0}: The specified part of file is\" +\n                                \" already locked.\", e.GetType().Name);\n                        }\n                        break;\n\n                    // Unlock the specified part of the file.\n                    case 'U':\n                        try\n                        {\n                            fileStream.Unlock(\n                                textLength - 1, byteCount);\n                            Console.WriteLine(\"The specified part \" +\n                                \"of file has been unlocked.\");\n                        }\n                        catch(IOException e)\n                        {\n                            Console.WriteLine(\n                                \"{0}: The specified part of file is \" +\n                                \"not locked by the current process.\",\n                                e.GetType().Name);\n                        }\n                        break;\n\n                    // Exit the program.\n                    default:\n                        consoleInput = 'X';\n                        break;\n                }\n            }\n        }\n    }\n}\n</code></pre>\n<h5><a id=\"UnlockInt64_Int64__1299\"></a>Unlock(Int64, Int64) 允许其他进程访问以前锁定的某个文件的全部或部分</h5>\n<pre><code class=\"prism language-C#\">[System.Runtime.Versioning.UnsupportedOSPlatform(\"ios\")]\n[System.Runtime.Versioning.UnsupportedOSPlatform(\"macos\")]\n[System.Runtime.Versioning.UnsupportedOSPlatform(\"tvos\")]\npublic virtual void Unlock (long position, long length);\n</code></pre>\n<p><strong>参数</strong></p>\n<blockquote>\n<p><code>position</code></p>\n<p><a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.int64?view=net-6.0\">Int64</a></p>\n<p>要取消锁定的范围的开始处。</p>\n<p><code>length</code></p>\n<p><a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.int64?view=net-6.0\">Int64</a></p>\n<p>要取消锁定的范围。</p>\n</blockquote>\n<p><strong>示例</strong></p>\n<p>下面的代码示例演示如何锁定部分文件，以便其他进程即使对文件具有读/写访问权限也无法访问该文件的该部分，然后对该文件的指定部分解除锁定。 在不同的命令窗口中同时运行程序，并使用不同的控制台输入选项进行调查。</p>\n<pre><code class=\"prism language-C#\">using System;\nusing System.IO;\nusing System.Text;\n\nclass FStreamLock\n{\n    static void Main()\n    {\n        UnicodeEncoding uniEncoding = new UnicodeEncoding();\n        string lastRecordText =\n            \"The last processed record number was: \";\n        int textLength = uniEncoding.GetByteCount(lastRecordText);\n        int recordNumber = 13;\n        int byteCount =\n            uniEncoding.GetByteCount(recordNumber.ToString());\n        string tempString;\n\n        using(FileStream fileStream = new FileStream(\n            \"Test#@@#.dat\", FileMode.OpenOrCreate,\n            FileAccess.ReadWrite, FileShare.ReadWrite))\n        {\n            // Write the original file data.\n            if(fileStream.Length == 0)\n            {\n                tempString =\n                    lastRecordText + recordNumber.ToString();\n                fileStream.Write(uniEncoding.GetBytes(tempString),\n                    0, uniEncoding.GetByteCount(tempString));\n            }\n\n            // Allow the user to choose the operation.\n            char consoleInput = 'R';\n            byte[] readText = new byte[fileStream.Length];\n            while(consoleInput != 'X')\n            {\n                Console.Write(\n                    \"\\nEnter 'R' to read, 'W' to write, 'L' to \" +\n                    \"lock, 'U' to unlock, anything else to exit: \");\n\n                if((tempString = Console.ReadLine()).Length == 0)\n                {\n                    break;\n                }\n                consoleInput = char.ToUpper(tempString[0]);\n                switch(consoleInput)\n                {\n                    // Read data from the file and\n                    // write it to the console.\n                    case 'R':\n                        try\n                        {\n                            fileStream.Seek(0, SeekOrigin.Begin);\n                            fileStream.Read(\n                                readText, 0, (int)fileStream.Length);\n                            tempString = new String(\n                                uniEncoding.GetChars(\n                                readText, 0, readText.Length));\n                            Console.WriteLine(tempString);\n                            recordNumber = int.Parse(\n                                tempString.Substring(\n                                tempString.IndexOf(':') + 2));\n                        }\n\n                        // Catch the IOException generated if the\n                        // specified part of the file is locked.\n                        catch(IOException e)\n                        {\n                            Console.WriteLine(\"{0}: The read \" +\n                                \"operation could not be performed \" +\n                                \"because the specified part of the \" +\n                                \"file is locked.\",\n                                e.GetType().Name);\n                        }\n                        break;\n\n                    // Update the file.\n                    case 'W':\n                        try\n                        {\n                            fileStream.Seek(textLength,\n                                SeekOrigin.Begin);\n                            fileStream.Read(\n                                readText, textLength - 1, byteCount);\n                            tempString = new String(\n                                uniEncoding.GetChars(\n                                readText, textLength - 1, byteCount));\n                            recordNumber = int.Parse(tempString) + 1;\n                            fileStream.Seek(\n                                textLength, SeekOrigin.Begin);\n                            fileStream.Write(uniEncoding.GetBytes(\n                                recordNumber.ToString()),\n                                0, byteCount);\n                            fileStream.Flush();\n                            Console.WriteLine(\n                                \"Record has been updated.\");\n                        }\n\n                        // Catch the IOException generated if the\n                        // specified part of the file is locked.\n                        catch(IOException e)\n                        {\n                            Console.WriteLine(\n                                \"{0}: The write operation could not \" +\n                                \"be performed because the specified \" +\n                                \"part of the file is locked.\",\n                                e.GetType().Name);\n                        }\n                        break;\n\n                    // Lock the specified part of the file.\n                    case 'L':\n                        try\n                        {\n                            fileStream.Lock(textLength - 1, byteCount);\n                            Console.WriteLine(\"The specified part \" +\n                                \"of file has been locked.\");\n                        }\n                        catch(IOException e)\n                        {\n                            Console.WriteLine(\n                                \"{0}: The specified part of file is\" +\n                                \" already locked.\", e.GetType().Name);\n                        }\n                        break;\n\n                    // Unlock the specified part of the file.\n                    case 'U':\n                        try\n                        {\n                            fileStream.Unlock(\n                                textLength - 1, byteCount);\n                            Console.WriteLine(\"The specified part \" +\n                                \"of file has been unlocked.\");\n                        }\n                        catch(IOException e)\n                        {\n                            Console.WriteLine(\n                                \"{0}: The specified part of file is \" +\n                                \"not locked by the current process.\",\n                                e.GetType().Name);\n                        }\n                        break;\n\n                    // Exit the program.\n                    default:\n                        consoleInput = 'X';\n                        break;\n                }\n            }\n        }\n    }\n}\n</code></pre>\n<h4><a id=\"__1481\"></a>♍ 注解</h4>\n<p>使用 类可以读取、写入、打开和关闭文件系统上的文件，以及操作其他与文件相关的操作系统句柄，包括管道、标准输入和 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream?view=net-6.0\">FileStream</a> 标准输出。 可以使用 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream.read?view=net-6.0\">Read</a> <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream.write?view=net-6.0\">Write</a> 、、 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.io.stream.copyto?view=net-6.0\">CopyTo</a> 和 方法来执行同步操作，或使用 、、 和 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream.flush?view=net-6.0\">Flush</a> <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream.readasync?view=net-6.0\">ReadAsync</a> <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream.writeasync?view=net-6.0\">WriteAsync</a> <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.io.stream.copytoasync?view=net-6.0\">CopyToAsync</a> <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream.flushasync?view=net-6.0\">FlushAsync</a> 方法来执行异步操作。</p>\n<blockquote>\n<p>注意：</p>\n<p>此类型实现 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.idisposable?view=net-6.0\">IDisposable</a> 接口。 在使用完类型后，您应直接或间接释放类型。 若要直接释放类型，请在 <code>try</code>/<code>catch</code> 块中调用其 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.idisposable.dispose?view=net-6.0\">Dispose</a> 方法。 若要间接释放类型，请使用 <code>using</code>（在 C# 中）或 <code>Using</code>（在 Visual Basic 中）等语言构造。 有关详细信息，请参阅 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.idisposable?view=net-6.0\">IDisposable</a> 接口主题中的“使用实现 IDisposable 的对象”一节。</p>\n</blockquote>\n<p><a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream.isasync?view=net-6.0\">IsAsync</a>属性检测文件句柄是否已异步打开。 使用具有 、 或 参数的构造函数创建 类的实例时，请 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream?view=net-6.0\">FileStream</a> <code>isAsync</code> <code>useAsync</code> 指定 <code>options</code> 此值。 当 属性为 <code>true</code> 时，流利用重叠的 I/O 以异步方式执行文件操作。 但是， <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream.isasync?view=net-6.0\">IsAsync</a> 属性不一定调用 <code>true</code> <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream.readasync?view=net-6.0\">ReadAsync</a> 、 或 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream.writeasync?view=net-6.0\">WriteAsync</a> <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.io.stream.copytoasync?view=net-6.0\">CopyToAsync</a> 方法。 当 属性为 并且调用异步读取和写入操作时，UI 线程仍未被阻止，但实际 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream.isasync?view=net-6.0\">IsAsync</a> <code>false</code> I/O 操作是同步执行的。</p>\n<h4><a id=\"__1493\"></a>♎ 更多方法</h4>\n<blockquote>\n<p>更多方法请查阅官方文档<a href=\"https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream?view=net-6.0\">FileStream类</a>。</p>\n</blockquote>\n<hr/>\n<blockquote>\n<p>⭐写在结尾：</p>\n<p>文章中出现的任何错误请大家批评指出，一定及时修改。</p>\n<p>希望写在这里的小伙伴能给个<strong>三连支持</strong>！</p>\n</blockquote>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}