{"blogid": "119418625", "writerAge": "码龄14年", "writerBlogNum": "125", "writerCollect": "1317", "writerComment": "137", "writerFan": "228", "writerGrade": "6级", "writerIntegral": "6257", "writerName": "彼岸大洋", "writerProfileAdress": "writer_image\\profile_119418625.jpg", "writerRankTotal": "4560", "writerRankWeekly": "38725", "writerThumb": "266", "writerVisitNum": "796276", "blog_read_count": "6427", "blog_time": "于 2021-08-06 14:33:04 发布", "blog_title": "C# OPC UA 客户端开发", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p><em>OPC UA（OPC Unified Architecture）是为了在工业自动化等行业安全可靠地进行数据交换而制定的开放式国际标准规格。由OPC Foundation于2008年发布，之后制定了国际标准IEC62541.跨越设备的种类、操作系统（OS）、制造商的壁垒，可以安全地进行高可靠性的数据交换，作为标准通信协议得到了工业 4.0的推荐。</em><a href=\"https://opcfoundation.org/\">https://opcfoundation.org/</a></p>\n<p>OPC UA开发首先需要一个服务器端：这里使用KEPServer来模拟。首先下载并安装KepServer，基本一路下一步。配置OPC UA:</p>\n<p>在桌面右下角右键点击“OPC UA配置”</p>\n<p><img alt=\"\" height=\"499\" src=\"image\\20210805152145502.png\" width=\"613\"/></p>\n<p>选择网卡和端口号，修改成自己想要的地址。</p>\n<p><img alt=\"\" height=\"644\" src=\"image\\20210805152530486.png\" width=\"1001\"/>服务端测试：下载softing OPC Client 工具并安装。如下图所示连接KepServer </p>\n<p><img alt=\"\" height=\"938\" src=\"image\\20210805152854489.png\" width=\"1104\"/></p>\n<p> 数据节点读写测试：</p>\n<p><img alt=\"\" height=\"779\" src=\"image\\20210805153112820.png\" width=\"872\"/></p>\n<p>有了以上准备后，利用C# 开发自己的OPC UA helper：</p>\n<p>我使用的VS2019，新建.net framework类库项目：修改.net framework版本4.6.2以上，nuget 包管理器里搜索opc.ua.client.选择opc 基金会的开发组件：如下图所示：</p>\n<p><img alt=\"\" height=\"680\" src=\"image\\20210805153516294.png\" width=\"1018\"/></p>\n<p>新建类OPCUAClient.cs</p>\n<pre><code>using Opc.Ua;\nusing Opc.Ua.Client;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\n\nnamespace hg.opc.client\n{\n    public class OPCUAClient\n    {\n        #region Private Fields\n        private ApplicationConfiguration appConfig;\n        private Session clientSession;\n        private bool isConnected = false;                       //是否已经连接过\n        private int reconnectPeriod = 10;               // 重连状态\n        private SessionReconnectHandler sessionReconnectHandler;\n        private EventHandler onConnectedEventHandler;\n        private Dictionary&lt;string, Subscription&gt; subscriptionNodes=new Dictionary&lt;string, Subscription&gt;();        // 系统所有的节点信息\n        #endregion Private Fields\n\n        #region Public Members\n\n        public IUserIdentity UserIdentity { get; set; }= new UserIdentity(new AnonymousIdentityToken());\n        public bool IsConnected { get =&gt; isConnected; private set =&gt; isConnected = value; }\n        public Dictionary&lt;string, Subscription&gt; SubscriptionNodes { get =&gt; subscriptionNodes; set =&gt; subscriptionNodes = value; }\n\n        public event EventHandler OnConnectedEvent\n        {\n            add { onConnectedEventHandler += value; }\n            remove { onConnectedEventHandler -= value; }\n        }\n        #endregion\n\n        #region 构造函数\n        public OPCUAClient()\n        {\n            var certificateValidator = new CertificateValidator();\n            certificateValidator.CertificateValidation += (sender, eventArgs) =&gt;\n            {\n                if (ServiceResult.IsGood(eventArgs.Error))\n                    eventArgs.Accept = true;\n                else if (eventArgs.Error.StatusCode.Code == StatusCodes.BadCertificateUntrusted)\n                    eventArgs.Accept = true;\n                else\n                    throw new Exception(string.Format(\"证书验证错误： {0}: {1}\", eventArgs.Error.Code, eventArgs.Error.AdditionalInfo));\n            };\n\n            certificateValidator.Update(new SecurityConfiguration\n            {\n                AutoAcceptUntrustedCertificates = true,\n                RejectSHA1SignedCertificates = false,\n                MinimumCertificateKeySize = 1024,\n            });\n\n            var configuration = new ApplicationConfiguration\n            {\n                ApplicationName = \"MyOpc_Client\",\n                ApplicationType = ApplicationType.Client,\n                CertificateValidator = certificateValidator,\n                ApplicationUri = string.Empty, \n                ServerConfiguration = new ServerConfiguration\n                {\n                    MaxSubscriptionCount = 100000,\n                    MaxMessageQueueSize = 100000,\n                    MaxNotificationQueueSize = 100000,\n                    MaxPublishRequestCount = 100000,\n                },\n                SecurityConfiguration = new SecurityConfiguration\n                {\n                    AutoAcceptUntrustedCertificates = true,\n                    RejectSHA1SignedCertificates = false,\n                    MinimumCertificateKeySize = 1024,\n                    SuppressNonceValidationErrors = true,\n\n                    ApplicationCertificate = new CertificateIdentifier\n                    {\n                        StoreType = CertificateStoreType.X509Store,\n                        StorePath = \"CurrentUser\\\\My\",\n                    },\n                    TrustedIssuerCertificates = new CertificateTrustList\n                    {\n                        StoreType = CertificateStoreType.X509Store,\n                        StorePath = \"CurrentUser\\\\Root\",\n                    },\n                    TrustedPeerCertificates = new CertificateTrustList\n                    {\n                        StoreType = CertificateStoreType.X509Store,\n                        StorePath = \"CurrentUser\\\\Root\",\n                    }\n                },\n                TransportQuotas = new TransportQuotas\n                {\n                    OperationTimeout = 6000000,\n                    MaxStringLength = int.MaxValue,\n                    MaxByteStringLength = int.MaxValue,\n                    MaxArrayLength = 65535,\n                    MaxMessageSize = 419430400,\n                    MaxBufferSize = 65535,\n                    ChannelLifetime = -1,\n                    SecurityTokenLifetime = -1\n                },\n                ClientConfiguration = new ClientConfiguration\n                {\n                    DefaultSessionTimeout = -1,\n                    MinSubscriptionLifetime = -1,\n                },\n                DisableHiResClock = true\n            };\n\n            configuration.Validate(ApplicationType.Client);\n            appConfig = configuration;\n        }\n        #endregion\n        #region 连接\n        public async Task ConnectServer(string serverUrl)\n        {\n            Disconnect();\n            var endpointDescription = CoreClientUtils.SelectEndpoint(serverUrl, false);\n            var endpointConfiguration = EndpointConfiguration.Create(appConfig);\n            var endpoint = new ConfiguredEndpoint(null, endpointDescription, endpointConfiguration);\n            clientSession = await Task.Run(async ()=&gt; {\n                \n                return await Session.Create(\n                    appConfig,\n                    endpoint,\n                    false,\n                    false,\n                    appConfig.ApplicationName,\n                    60000,\n                    UserIdentity,\n                    new string[] { });\n            });\n            clientSession.KeepAlive += Session_KeepAlive;\n            IsConnected = true;\n            onConnectedEventHandler?.Invoke(this, EventArgs.Empty);\n        }\n\n        private void Session_KeepAlive(Session session, KeepAliveEventArgs e)\n        {\n            try\n            {\n                if (!object.ReferenceEquals(session, this.clientSession))\n                {\n                    return;\n                }\n                if (ServiceResult.IsBad(e.Status))\n                {\n                    if (reconnectPeriod &lt;= 0)\n                    {\n                        return;\n                    }\n                    if (sessionReconnectHandler == null)\n                    {\n                        sessionReconnectHandler = new SessionReconnectHandler();\n                        sessionReconnectHandler.BeginReconnect(session, reconnectPeriod * 1000, Server_ReconnectComplete);\n                    }\n                    return;\n                }\n            }\n            catch (Exception exception)\n            {\n                throw exception;\n            }\n        }\n\n        private void Server_ReconnectComplete(object sender, EventArgs e)\n        {\n            try\n            {\n                if (!ReferenceEquals(sender, sessionReconnectHandler))\n                {\n                    return;\n                }\n                clientSession = sessionReconnectHandler.Session;\n                sessionReconnectHandler.Dispose();\n                sessionReconnectHandler = null;\n            }\n            catch (Exception exception)\n            {\n                throw exception;\n            }\n        }\n\n        public void Disconnect()\n        {\n            if (sessionReconnectHandler != null)\n            {\n                sessionReconnectHandler.Dispose();\n                sessionReconnectHandler = null;\n            }\n\n            if (clientSession != null)\n            {\n                clientSession.Close(10000);\n                clientSession = null;\n            }\n            IsConnected = false;\n        }\n        #endregion\n\n        #region 浏览节点\n\n        public ReferenceDescriptionCollection BrowserNode2(NodeId nodeId)\n        {\n            var browser = new Browser(clientSession);\n            return browser.Browse(nodeId);\n        }\n\n        public ReferenceDescriptionCollection BrowserNode(NodeId nodeId)\n        { \n            var browseDescriptions = new BrowseDescriptionCollection();\n            var browserDesc = new BrowseDescription();\n            browserDesc.NodeId = nodeId;\n            browserDesc.BrowseDirection = BrowseDirection.Forward;\n            browserDesc.ReferenceTypeId = ReferenceTypeIds.Aggregates;\n            browserDesc.IncludeSubtypes = true;\n            browserDesc.NodeClassMask = (uint)(NodeClass.Object | NodeClass.Variable | NodeClass.Method | NodeClass.ReferenceType | NodeClass.ObjectType | NodeClass.View | NodeClass.VariableType | NodeClass.DataType);\n            browserDesc.ResultMask = (uint)BrowseResultMask.All;\n\n            var browseDesc2 = new BrowseDescription();\n            browseDesc2.NodeId = nodeId;\n            browseDesc2.BrowseDirection = BrowseDirection.Forward;\n            browseDesc2.ReferenceTypeId = ReferenceTypeIds.Organizes;\n            browseDesc2.IncludeSubtypes = true;\n            browseDesc2.NodeClassMask = (uint)(NodeClass.Object | NodeClass.Variable | NodeClass.Method | NodeClass.View | NodeClass.ReferenceType | NodeClass.ObjectType | NodeClass.VariableType | NodeClass.DataType);\n            browseDesc2.ResultMask = (uint)BrowseResultMask.All;\n           \n\n            browseDescriptions.Add(browserDesc);\n            browseDescriptions.Add(browseDesc2);\n\n            ReferenceDescriptionCollection references = GetReferenceDescriptionCollection(browseDescriptions);\n            return references;\n        }\n\n        public ReferenceDescriptionCollection GetReferenceDescriptionCollection(BrowseDescriptionCollection browseDescriptions)\n        {\n            try\n            {\n                var referenceDescriptions = new ReferenceDescriptionCollection();\n                var unprocessedOperations = new BrowseDescriptionCollection();\n\n                while (browseDescriptions.Count &gt; 0)\n                {\n                    BrowseResultCollection results = null;\n                    DiagnosticInfoCollection diagnosticInfos = null;\n                    clientSession.Browse(null, null,  0, browseDescriptions,out results,out diagnosticInfos);\n\n                    ClientBase.ValidateResponse(results, browseDescriptions);\n                    ClientBase.ValidateDiagnosticInfos(diagnosticInfos, browseDescriptions);\n\n                    ByteStringCollection continuationPoints = new ByteStringCollection();\n                    for (int i = 0; i &lt; browseDescriptions.Count; i++)\n                    {\n                        if (StatusCode.IsBad(results[i].StatusCode))\n                        {\n                            if (results[i].StatusCode == StatusCodes.BadNoContinuationPoints)\n                            {\n                                unprocessedOperations.Add(browseDescriptions[i]);\n                            }\n                            continue;\n                        }\n\n                        // check if all references have been fetched.\n                        if (results[i].References.Count == 0)\n                        {\n                            continue;\n                        }\n                        referenceDescriptions.AddRange(results[i].References);\n                        if (results[i].ContinuationPoint != null)\n                        {\n                            continuationPoints.Add(results[i].ContinuationPoint);\n                        }\n                    }\n                    ByteStringCollection revisedContiuationPoints = new ByteStringCollection();\n                    while (continuationPoints.Count &gt; 0)\n                    {\n                        // continue browse operation.\n                        clientSession.BrowseNext(\n                            null,\n                            true,\n                            continuationPoints,\n                            out results,\n                            out diagnosticInfos);\n\n                        ClientBase.ValidateResponse(results, continuationPoints);\n                        ClientBase.ValidateDiagnosticInfos(diagnosticInfos, continuationPoints);\n\n                        for (int j = 0; j &lt; continuationPoints.Count; j++)\n                        {\n                            if (StatusCode.IsBad(results[j].StatusCode))\n                            {\n                                continue;\n                            }\n                            if (results[j].References.Count == 0)\n                            {\n                                continue;\n                            }\n\n                            referenceDescriptions.AddRange(results[j].References);\n\n                            if (results[j].ContinuationPoint != null)\n                            {\n                                revisedContiuationPoints.Add(results[j].ContinuationPoint);\n                            }\n                        }\n                        revisedContiuationPoints = continuationPoints;\n                    }\n                    browseDescriptions = unprocessedOperations;\n                }\n                return referenceDescriptions;\n            }\n            catch (Exception exception)\n            {\n                return null;\n            }\n        }\n\n\n        #endregion\n\n        #region Node Write/Read Support\n\n        /// &lt;summary&gt;\n        /// Read a value node from server\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"nodeId\"&gt;node id&lt;/param&gt;\n        /// &lt;returns&gt;DataValue&lt;/returns&gt;\n        public DataValue ReadNode(NodeId nodeId)\n        {\n            ReadValueIdCollection nodesToRead = new ReadValueIdCollection\n            {\n                new ReadValueId( )\n                {\n                    NodeId = nodeId,\n                    AttributeId = Attributes.Value\n                }\n            };\n\n            // read the current value\n            clientSession.Read(\n                null,\n                0,\n                TimestampsToReturn.Neither,\n                nodesToRead,\n                out DataValueCollection results,\n                out DiagnosticInfoCollection diagnosticInfos);\n\n            ClientBase.ValidateResponse(results, nodesToRead);\n            ClientBase.ValidateDiagnosticInfos(diagnosticInfos, nodesToRead);\n\n            return results[0];\n        }\n\n        /// &lt;summary&gt;\n        /// 是否可读写节点\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"nodeId\"&gt;&lt;/param&gt;\n        /// &lt;returns&gt;&lt;/returns&gt;\n        public bool IsWriteableNode(NodeId nodeId)\n        {\n            ReadValueIdCollection nodesToRead = new ReadValueIdCollection\n            {\n                new ReadValueId( )\n                {\n                    NodeId = nodeId,\n                    AttributeId = Attributes.AccessLevel\n                }\n            };\n\n            // read the current value\n            clientSession.Read(\n                null,\n                0,\n                TimestampsToReturn.Neither,\n                nodesToRead,\n                out DataValueCollection results,\n                out DiagnosticInfoCollection diagnosticInfos);\n\n            ClientBase.ValidateResponse(results, nodesToRead);\n            ClientBase.ValidateDiagnosticInfos(diagnosticInfos, nodesToRead);\n\n            DataValue value= results[0];\n            if (value.WrappedValue == Variant.Null)\n            {\n                return true;\n            }\n            return !((byte)value.WrappedValue.Value == 1);\n\n        }\n\n        /// &lt;summary&gt;\n        /// Read a value node from server\n        /// &lt;/summary&gt;\n        /// &lt;typeparam name=\"T\"&gt;type of value&lt;/typeparam&gt;\n        /// &lt;param name=\"tag\"&gt;node id&lt;/param&gt;\n        /// &lt;returns&gt;实际值&lt;/returns&gt;\n        public T ReadNode&lt;T&gt;(string tag)\n        {\n            DataValue dataValue = ReadNode(new NodeId(tag));\n            return (T)dataValue.Value;\n        }\n\n        /// &lt;summary&gt;\n        /// Read a tag asynchronously\n        /// &lt;/summary&gt;\n        /// &lt;typeparam name=\"T\"&gt;The type of tag to read&lt;/typeparam&gt;\n        /// &lt;param name=\"tag\"&gt;tag值&lt;/param&gt;\n        /// &lt;returns&gt;The value retrieved from the OPC&lt;/returns&gt;\n        public Task&lt;T&gt; ReadNodeAsync&lt;T&gt;(string tag)\n        {\n            ReadValueIdCollection nodesToRead = new ReadValueIdCollection\n            {\n                new ReadValueId()\n                {\n                    NodeId = new NodeId(tag),\n                    AttributeId = Attributes.Value\n                }\n            };\n\n            // Wrap the ReadAsync logic in a TaskCompletionSource, so we can use C# async/await syntax to call it:\n            var taskCompletionSource = new TaskCompletionSource&lt;T&gt;();\n            clientSession.BeginRead(\n                requestHeader: null,\n                maxAge: 0,\n                timestampsToReturn: TimestampsToReturn.Neither,\n                nodesToRead: nodesToRead,\n                callback: ar =&gt;\n                {\n                    DataValueCollection results;\n                    DiagnosticInfoCollection diag;\n                    var response = clientSession.EndRead(\n                      result: ar,\n                      results: out results,\n                      diagnosticInfos: out diag);\n\n                    try\n                    {\n                        if (!StatusCode.IsGood(response.ServiceResult))\n                            throw new Exception(string.Format(\"Invalid response from the server. (Response Status: {0})\", response.ServiceResult));\n\n                        if (!StatusCode.IsGood(results[0].StatusCode))\n                            throw new Exception(string.Format(\"Invalid response from the server. (Response Status: {0})\", results[0].StatusCode));\n                        var val = results[0];\n                        taskCompletionSource.TrySetResult((T)val.Value);\n                    }\n                    catch (Exception ex)\n                    {\n                        taskCompletionSource.TrySetException(ex);\n                    }\n                },\n                asyncState: null);\n\n            return taskCompletionSource.Task;\n        }\n\n        /// &lt;summary&gt;\n        /// read several value nodes from server\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"nodeIds\"&gt;all NodeIds&lt;/param&gt;\n        /// &lt;returns&gt;all values&lt;/returns&gt;\n        public List&lt;DataValue&gt; ReadNodes(NodeId[] nodeIds)\n        {\n            ReadValueIdCollection nodesToRead = new ReadValueIdCollection();\n            for (int i = 0; i &lt; nodeIds.Length; i++)\n            {\n                nodesToRead.Add(new ReadValueId()\n                {\n                    NodeId = nodeIds[i],\n                    AttributeId = Attributes.Value\n                });\n            }\n\n            // 读取当前的值\n            clientSession.Read(\n                null,\n                0,\n                TimestampsToReturn.Neither,\n                nodesToRead,\n                out DataValueCollection results,\n                out DiagnosticInfoCollection diagnosticInfos);\n\n            ClientBase.ValidateResponse(results, nodesToRead);\n            ClientBase.ValidateDiagnosticInfos(diagnosticInfos, nodesToRead);\n\n            return results.ToList();\n        }\n\n        /// &lt;summary&gt;\n        /// read several value nodes from server\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"nodeIds\"&gt;all NodeIds&lt;/param&gt;\n        /// &lt;returns&gt;all values&lt;/returns&gt;\n        public Task&lt;List&lt;DataValue&gt;&gt; ReadNodesAsync(NodeId[] nodeIds)\n        {\n            ReadValueIdCollection nodesToRead = new ReadValueIdCollection();\n            for (int i = 0; i &lt; nodeIds.Length; i++)\n            {\n                nodesToRead.Add(new ReadValueId()\n                {\n                    NodeId = nodeIds[i],\n                    AttributeId = Attributes.Value\n                });\n            }\n\n            var taskCompletionSource = new TaskCompletionSource&lt;List&lt;DataValue&gt;&gt;();\n            // 读取当前的值\n            clientSession.BeginRead(\n                null,\n                0,\n                TimestampsToReturn.Neither,\n                nodesToRead,\n                callback: ar =&gt;\n                {\n                    DataValueCollection results;\n                    DiagnosticInfoCollection diag;\n                    var response = clientSession.EndRead(\n                      result: ar,\n                      results: out results,\n                      diagnosticInfos: out diag);\n\n                    try\n                    {\n                        CheckReturnValue(response.ServiceResult);\n                        taskCompletionSource.TrySetResult(results.ToList());\n                    }\n                    catch (Exception ex)\n                    {\n                        taskCompletionSource.TrySetException(ex);\n                    }\n                },\n                asyncState: null);\n\n            return taskCompletionSource.Task;\n        }\n\n        /// &lt;summary&gt;\n        /// read several value nodes from server\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"tags\"&gt;所以的节点数组信息&lt;/param&gt;\n        /// &lt;returns&gt;all values&lt;/returns&gt;\n        public List&lt;T&gt; ReadNodes&lt;T&gt;(string[] tags)\n        {\n            List&lt;T&gt; result = new List&lt;T&gt;();\n            ReadValueIdCollection nodesToRead = new ReadValueIdCollection();\n            for (int i = 0; i &lt; tags.Length; i++)\n            {\n                nodesToRead.Add(new ReadValueId()\n                {\n                    NodeId = new NodeId(tags[i]),\n                    AttributeId = Attributes.Value\n                });\n            }\n\n            // 读取当前的值\n            clientSession.Read(\n                null,\n                0,\n                TimestampsToReturn.Neither,\n                nodesToRead,\n                out DataValueCollection results,\n                out DiagnosticInfoCollection diagnosticInfos);\n\n            ClientBase.ValidateResponse(results, nodesToRead);\n            ClientBase.ValidateDiagnosticInfos(diagnosticInfos, nodesToRead);\n\n            foreach (var item in results)\n            {\n                result.Add((T)item.Value);\n            }\n            return result;\n        }\n\n        /// &lt;summary&gt;\n        /// read several value nodes from server\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"tags\"&gt;all NodeIds&lt;/param&gt;\n        /// &lt;returns&gt;all values&lt;/returns&gt;\n        public Task&lt;List&lt;T&gt;&gt; ReadNodesAsync&lt;T&gt;(string[] tags)\n        {\n            ReadValueIdCollection nodesToRead = new ReadValueIdCollection();\n            for (int i = 0; i &lt; tags.Length; i++)\n            {\n                nodesToRead.Add(new ReadValueId()\n                {\n                    NodeId = new NodeId(tags[i]),\n                    AttributeId = Attributes.Value\n                });\n            }\n\n            var taskCompletionSource = new TaskCompletionSource&lt;List&lt;T&gt;&gt;();\n            // 读取当前的值\n            clientSession.BeginRead(\n                null,\n                0,\n                TimestampsToReturn.Neither,\n                nodesToRead,\n                callback: ar =&gt;\n                {\n                    DataValueCollection results;\n                    DiagnosticInfoCollection diag;\n                    var response = clientSession.EndRead(\n                      result: ar,\n                      results: out results,\n                      diagnosticInfos: out diag);\n\n                    try\n                    {\n                        CheckReturnValue(response.ServiceResult);\n                        List&lt;T&gt; result = new List&lt;T&gt;();\n                        foreach (var item in results)\n                        {\n                            result.Add((T)item.Value);\n                        }\n                        taskCompletionSource.TrySetResult(result);\n                    }\n                    catch (Exception ex)\n                    {\n                        taskCompletionSource.TrySetException(ex);\n                    }\n                },\n                asyncState: null);\n\n            return taskCompletionSource.Task;\n        }\n\n\n\n        /// &lt;summary&gt;\n        /// 0:NodeClass  1:Value  2:AccessLevel  3:DisplayName  4:Description\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"nodeIds\"&gt;&lt;/param&gt;\n        /// &lt;returns&gt;&lt;/returns&gt;\n        public DataValue[] ReadNodeAttributes(List&lt;NodeId&gt; nodeIds)\n        {\n            ReadValueIdCollection nodesToRead = new ReadValueIdCollection();\n            foreach (var nodeId in nodeIds)\n            {\n                NodeId sourceId = nodeId;\n                nodesToRead.Add(new ReadValueId()\n                {\n                    NodeId = sourceId,\n                    AttributeId = Attributes.NodeClass\n                });\n                nodesToRead.Add(new ReadValueId()\n                {\n                    NodeId = sourceId,\n                    AttributeId = Attributes.Value\n                });\n                nodesToRead.Add(new ReadValueId()\n                {\n                    NodeId = sourceId,\n                    AttributeId = Attributes.AccessLevel\n                });\n                nodesToRead.Add(new ReadValueId()\n                {\n                    NodeId = sourceId,\n                    AttributeId = Attributes.DisplayName\n                });\n                nodesToRead.Add(new ReadValueId()\n                {\n                    NodeId = sourceId,\n                    AttributeId = Attributes.Description\n                });\n            }\n\n            // read all values.\n            clientSession.Read(\n                null,\n                0,\n                TimestampsToReturn.Neither,\n                nodesToRead,\n                out DataValueCollection results,\n                out DiagnosticInfoCollection diagnosticInfos);\n\n            ClientBase.ValidateResponse(results, nodesToRead);\n            ClientBase.ValidateDiagnosticInfos(diagnosticInfos, nodesToRead);\n\n            return results.ToArray();\n        }\n\n\n        /// &lt;summary&gt;\n        /// write a note to server(you should use try catch)\n        /// &lt;/summary&gt;\n        /// &lt;typeparam name=\"T\"&gt;The type of tag to write on&lt;/typeparam&gt;\n        /// &lt;param name=\"tag\"&gt;节点名称&lt;/param&gt;\n        /// &lt;param name=\"value\"&gt;值&lt;/param&gt;\n        /// &lt;returns&gt;if success True,otherwise False&lt;/returns&gt;\n        public bool WriteNode&lt;T&gt;(string tag, T value)\n        {\n            WriteValue valueToWrite = new WriteValue()\n            {\n                NodeId = new NodeId(tag),\n                AttributeId = Attributes.Value\n            };\n            valueToWrite.Value.Value = value;\n            valueToWrite.Value.StatusCode = StatusCodes.Good;\n            valueToWrite.Value.ServerTimestamp = DateTime.MinValue;\n            valueToWrite.Value.SourceTimestamp = DateTime.MinValue;\n\n            WriteValueCollection valuesToWrite = new WriteValueCollection\n            {\n                valueToWrite\n            };\n\n            // 写入当前的值\n\n            clientSession.Write(\n                null,\n                valuesToWrite,\n                out StatusCodeCollection results,\n                out DiagnosticInfoCollection diagnosticInfos);\n\n            ClientBase.ValidateResponse(results, valuesToWrite);\n            ClientBase.ValidateDiagnosticInfos(diagnosticInfos, valuesToWrite);\n\n            if (StatusCode.IsBad(results[0]))\n            {\n                throw new ServiceResultException(results[0]);\n            }\n\n            return !StatusCode.IsBad(results[0]);\n        }\n\n        /// &lt;summary&gt;\n        /// Write a value on the specified opc tag asynchronously\n        /// &lt;/summary&gt;\n        /// &lt;typeparam name=\"T\"&gt;The type of tag to write on&lt;/typeparam&gt;\n        /// &lt;param name=\"tag\"&gt;The fully-qualified identifier of the tag. You can specify a subfolder by using a comma delimited name. E.g: the tag `foo.bar` writes on the tag `bar` on the folder `foo`&lt;/param&gt;\n        /// &lt;param name=\"value\"&gt;The value for the item to write&lt;/param&gt;\n        public Task&lt;bool&gt; WriteNodeAsync&lt;T&gt;(string tag, T value)\n        {\n            WriteValue valueToWrite = new WriteValue()\n            {\n                NodeId = new NodeId(tag),\n                AttributeId = Attributes.Value,\n            };\n            valueToWrite.Value.Value = value;\n            valueToWrite.Value.StatusCode = StatusCodes.Good;\n            valueToWrite.Value.ServerTimestamp = DateTime.MinValue;\n            valueToWrite.Value.SourceTimestamp = DateTime.MinValue;\n            WriteValueCollection valuesToWrite = new WriteValueCollection\n            {\n                valueToWrite\n            };\n\n            // Wrap the WriteAsync logic in a TaskCompletionSource, so we can use C# async/await syntax to call it:\n            var taskCompletionSource = new TaskCompletionSource&lt;bool&gt;();\n            clientSession.BeginWrite(\n                requestHeader: null,\n                nodesToWrite: valuesToWrite,\n                callback: ar =&gt;\n                {\n               \n                    var response = clientSession.EndWrite(\n                      result: ar,\n                      results: out StatusCodeCollection results,\n                      diagnosticInfos: out DiagnosticInfoCollection diag);\n\n                    try\n                    {\n                        ClientBase.ValidateResponse(results, valuesToWrite);\n                        ClientBase.ValidateDiagnosticInfos(diag, valuesToWrite);\n                        taskCompletionSource.SetResult(StatusCode.IsGood(results[0]));\n                    }\n                    catch (Exception ex)\n                    {\n                        taskCompletionSource.TrySetException(ex);\n                    }\n                },\n                asyncState: null);\n            return taskCompletionSource.Task;\n        }\n\n        /// &lt;summary&gt;\n        /// 所有的节点都写入成功，返回&lt;c&gt;True&lt;/c&gt;，否则返回&lt;c&gt;False&lt;/c&gt;\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"tags\"&gt;节点名称数组&lt;/param&gt;\n        /// &lt;param name=\"values\"&gt;节点的值数据&lt;/param&gt;\n        /// &lt;returns&gt;所有的是否都写入成功&lt;/returns&gt;\n        public bool WriteNodes(string[] tags, object[] values)\n        {\n            WriteValueCollection valuesToWrite = new WriteValueCollection();\n\n            for (int i = 0; i &lt; tags.Length; i++)\n            {\n                if (i &lt; values.Length)\n                {\n                    WriteValue valueToWrite = new WriteValue()\n                    {\n                        NodeId = new NodeId(tags[i]),\n                        AttributeId = Attributes.Value\n                    };\n                    valueToWrite.Value.Value = values[i];\n                    valueToWrite.Value.StatusCode = StatusCodes.Good;\n                    valueToWrite.Value.ServerTimestamp = DateTime.MinValue;\n                    valueToWrite.Value.SourceTimestamp = DateTime.MinValue;\n                    valuesToWrite.Add(valueToWrite);\n                }\n            }\n\n            // 写入当前的值\n\n            clientSession.Write(\n                null,\n                valuesToWrite,\n                out StatusCodeCollection results,\n                out DiagnosticInfoCollection diagnosticInfos);\n\n            ClientBase.ValidateResponse(results, valuesToWrite);\n            ClientBase.ValidateDiagnosticInfos(diagnosticInfos, valuesToWrite);\n\n            bool result = true;\n            foreach (var r in results)\n            {\n                if (StatusCode.IsBad(r))\n                {\n                    result = false;\n                    break;\n                }\n            }\n\n            return result;\n        }\n\n        private void CheckReturnValue(StatusCode status)\n        {\n            if (!StatusCode.IsGood(status))\n                throw new Exception(string.Format(\"Invalid response from the server. (Response Status: {0})\", status));\n        }\n        #endregion Node Write/Read Support\n\n        #region 订阅\n\n        /// &lt;summary&gt;\n        /// 新增一批订阅，需要指定订阅的关键字，订阅的tag名数组，以及回调方法\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"key\"&gt;关键字&lt;/param&gt;\n        /// &lt;param name=\"tags\"&gt;节点名称数组&lt;/param&gt;\n        /// &lt;param name=\"callback\"&gt;回调方法&lt;/param&gt;\n        public void AddSubscription(string key, string[] tags, Action&lt;string, MonitoredItem, MonitoredItemNotificationEventArgs&gt; callback)\n        {\n            Subscription m_subscription = new Subscription(clientSession.DefaultSubscription);\n\n            m_subscription.PublishingEnabled = true;\n            m_subscription.PublishingInterval = 0;\n            m_subscription.KeepAliveCount = uint.MaxValue;\n            m_subscription.LifetimeCount = uint.MaxValue;\n            m_subscription.MaxNotificationsPerPublish = uint.MaxValue;\n            m_subscription.Priority = 100;\n            m_subscription.DisplayName = key;\n\n            for (int i = 0; i &lt; tags.Length; i++)\n            {\n                var item = new MonitoredItem\n                {\n                    StartNodeId = new NodeId(tags[i]),\n                    AttributeId = Attributes.Value,\n                    DisplayName = tags[i],\n                    SamplingInterval = 100,\n                };\n                item.Notification += (MonitoredItem monitoredItem, MonitoredItemNotificationEventArgs args) =&gt;\n                {\n                    callback?.Invoke(key, monitoredItem, args);\n                };\n                m_subscription.AddItem(item);\n            }\n\n            clientSession.AddSubscription(m_subscription);\n            m_subscription.Create();\n\n            lock (SubscriptionNodes)\n            {\n                if (SubscriptionNodes.ContainsKey(key))\n                {\n                    // remove\n                    SubscriptionNodes[key].Delete(true);\n                    clientSession.RemoveSubscription(SubscriptionNodes[key]);\n                    SubscriptionNodes[key].Dispose();\n                    SubscriptionNodes[key] = m_subscription;\n                }\n                else\n                {\n                    SubscriptionNodes.Add(key, m_subscription);\n                }\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// 新增订阅，需要指定订阅的关键字，订阅的tag名数组，以及回调方法\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"key\"&gt;关键字&lt;/param&gt;\n        /// &lt;param name=\"tags\"&gt;节点名称数组&lt;/param&gt;\n        /// &lt;param name=\"callback\"&gt;回调方法&lt;/param&gt;\n        public void AddSubscription(string key, string tag, Action&lt;string, MonitoredItem, MonitoredItemNotificationEventArgs&gt; callback)\n        {\n            AddSubscription(key, new string[] { tag }, callback);\n        }\n\n        /// &lt;summary&gt;\n        /// 移除订阅消息，如果该订阅消息是批量的，也直接移除\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"key\"&gt;订阅关键值&lt;/param&gt;\n        public void RemoveSubscription(string key)\n        {\n            lock (SubscriptionNodes)\n            {\n                if (SubscriptionNodes.ContainsKey(key))\n                {\n                    // remove\n                    SubscriptionNodes[key].Delete(true);\n                    clientSession.RemoveSubscription(SubscriptionNodes[key]);\n                    SubscriptionNodes[key].Dispose();\n                    SubscriptionNodes.Remove(key);\n                }\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// 移除所有的订阅消息\n        /// &lt;/summary&gt;\n        public void RemoveAllSubscription()\n        {\n            lock (SubscriptionNodes)\n            {\n                foreach (var item in SubscriptionNodes)\n                {\n                    item.Value.Delete(true);\n                    clientSession.RemoveSubscription(item.Value);\n                    item.Value.Dispose();\n                }\n                SubscriptionNodes.Clear();\n            }\n        }\n        #endregion\n    }\n}\n</code></pre>\n<p> 利用上面的OPCUAClient开发的winform程序：</p>\n<p><img alt=\"\" height=\"722\" src=\"image\\20210805154642362.png\" width=\"1077\"/></p>\n<p> 源码下载：<a href=\"https://download.csdn.net/download/elie_yang/20814696\">https://download.csdn.net/download/elie_yang/20814696</a></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n</div>\n</div>"}