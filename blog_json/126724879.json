{"blogid": "126724879", "writerAge": "码龄1年", "writerBlogNum": "54", "writerCollect": "89", "writerComment": "113", "writerFan": "804", "writerGrade": "4级", "writerIntegral": "984", "writerName": "如何写出最优雅的代码", "writerProfileAdress": "writer_image\\profile_126724879.jpg", "writerRankTotal": "21340", "writerRankWeekly": "7016", "writerThumb": "207", "writerVisitNum": "24287", "blog_read_count": "58", "blog_time": "于 2022-09-06 23:13:01 发布", "blog_title": "【C++面向对象程序设计】类与对象（中）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h2 id=\"%E5%89%8D%E8%A8%80\">前言</h2>\n<blockquote>\n<p>本篇博客主要介绍类的六个<strong>默认成员函数及运算符重载</strong>：构造函数、析构函数、拷贝构造函数、赋值运算符重载、取地址操作符重载</p>\n<p></p>\n<p>🎓作者：<strong>如何写出最优雅的代码</strong><br/> 📑如有错误，敬请指正🌹🌹</p>\n<p>💬开发工具：VS2019</p>\n</blockquote>\n<hr/>\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E5%89%8D%E8%A8%80-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%89%8D%E8%A8%80\">前言</a></p>\n<p id=\"1.%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:40px;\"><a href=\"#1.%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\">1. 构造函数</a></p>\n<p id=\"2.%20%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#2.%20%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%C2%A0\">2. 析构函数 </a></p>\n<p id=\"3.%20%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:40px;\"><a href=\"#3.%20%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\">3. 拷贝构造函数</a></p>\n<p id=\"4.%20%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD-toc\" style=\"margin-left:40px;\"><a href=\"#4.%20%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD\">4. 赋值运算符重载</a></p>\n<p id=\"4.1.%20%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD-toc\" style=\"margin-left:80px;\"><a href=\"#4.1.%20%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD\">4.1. 运算符重载</a></p>\n<p id=\"4.2.%20%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD-toc\" style=\"margin-left:80px;\"><a href=\"#4.2.%20%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD\">4.2. 赋值运算符重载</a></p>\n<p id=\"4.3.%20%E6%B5%81%E6%8F%92%E5%85%A5%2F%E6%B5%81%E6%8F%90%E5%8F%96%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD-toc\" style=\"margin-left:80px;\"><a href=\"#4.3.%20%E6%B5%81%E6%8F%92%E5%85%A5%2F%E6%B5%81%E6%8F%90%E5%8F%96%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD\">4.3. 流插入/流提取运算符重载</a></p>\n<p id=\"5.%20const%E6%88%90%E5%91%98%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#5.%20const%E6%88%90%E5%91%98%C2%A0\">5. const成员 </a></p>\n<p id=\"6.%20%E5%8F%96%E5%9C%B0%E5%9D%80%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%8F%8Aconst%E5%8F%96%E5%9C%B0%E5%9D%80%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD-toc\" style=\"margin-left:40px;\"><a href=\"#6.%20%E5%8F%96%E5%9C%B0%E5%9D%80%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%8F%8Aconst%E5%8F%96%E5%9C%B0%E5%9D%80%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD\">6. 取地址运算符重载及const取地址运算符重载</a></p>\n<hr/>\n<p> 补充几个知识点：</p>\n<ol><li>如果一个类中什么成员都没有，简称为空类。</li><li>但空类中并不是什么都没有，任何类在什么都不写的情况下，编译器会自动生成以下六个默认成员函数。<img alt=\"\" height=\"632\" src=\"image\\208f93a0f6fb45c7890df62b2f4345d7.png\" width=\"1003\"/></li><li>默认成员函数：用户没有显示实现，编译器会自动生成的成员函数称为默认成员函数。 </li></ol>\n<h2 id=\"1.%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\">1. 构造函数</h2>\n<p><strong>构造函数是一个特殊的成员函数，名字与类名相同，创建类类型对象时由编译器自动调用</strong>，以保证每个数据成员都有一个合适的初始值，并且<strong>在该对象的整个生命周期内只调用一次。</strong></p>\n<p><strong>构造函数是特殊的成员函数</strong>，虽然命名为构造函数，但构造函数的主要任务并<strong>不是开辟空间创建对象，而是初始化对象。</strong></p>\n<blockquote>\n<p><strong>具有以下特征：</strong></p>\n<ol><li>函数名与类名相同</li><li><strong>无返回值，也不能写void</strong></li><li>对象实例化时编译器<strong>自动调用</strong>对应的构造函数</li><li>构造函数可以重载</li></ol>\n<p>下面编写一个简单的Date类：</p>\n<pre><code class=\"language-cpp\">class Date\n{\npublic:\n\t// 1.无参构造函数\n\tDate()\n\t{}\n\t// 2.带参构造函数\n\tDate(int year, int month, int day)\n\t{\n\t\t_year = year;\n\t\t_month = month;\n\t\t_day = day;\n\t}\n\nprivate:\n\tint _year;\n\tint _month;\n\tint _day;\n};\n\nvoid TestDate()\n{\n\tDate d1; // 调用无参构造函数\n\tDate d2(2015, 1, 1); // 调用带参的构造函数\n\t// 注意：如果通过无参构造函数创建对象时，对象后面不用跟括号，否则就成了函数声明!\n\t// 以下代码的函数：声明了d3函数，该函数无参，返回一个日期类型的对象\n\t// warning C4930: “Date d3(void)”: 未调用原型函数(是否是有意用变量定义的?)\n\tDate d3();\n}\n\nint main()\n{\n\tTestDate();\n\n\treturn 0;\n}</code></pre>\n<p>显示定义的无参构造器：</p>\n<pre><code class=\"language-cpp\">Date()\n\t{}</code></pre>\n<p>显示定义的带参构造器：</p>\n<pre><code class=\"language-cpp\">Date(int year, int month, int day)\n\t{\n\t\t_year = year;\n\t\t_month = month;\n\t\t_day = day;\n\t}</code></pre>\n</blockquote>\n<p><strong>如果类中没有显式定义的构造函数，则C++编译器会自动生成一个无参的默认构造函数，一旦用户显式定义，则编译器将不再生成。</strong></p>\n<p><strong>这里需注意：</strong>C++把类型分为<strong>内置类型（基本类型）和自定义类型</strong>，内置类型就是语言提供的数据类型，如int、char、double……，自定义类型就是使用class、struct、union……自己定义的类型。<strong>编译器生成的默认的构造函数对内置类型不做处理，但会去调用自定义类型的默认构造函数。</strong></p>\n<p>这里由于默认生成的无参构造器对内置类型不做处理是一个小缺陷，C++11中打了补丁<strong>，即：内置类型成员变量在类声明时可以给默认值（缺省值）</strong></p>\n<p><strong>默认构造函数：无参的构造函数和全缺省的构造函数、以及我们没写构造函数时编译器默认生成的无参构造函数都可以认为是默认构造函数。</strong></p>\n<p><strong>综合这里来看，一般推荐在类中只定义一个全缺省的构造函数</strong></p>\n<blockquote>\n<p>显示定义的全缺省构造函数：</p>\n<pre><code class=\"language-cpp\">Date(int year = 1900, int month = 1, int day = 1)\n{\n    _year = year;\n    _month = month;\n    _day = day;\n}</code></pre>\n<p>注意：定义了全缺省的构造函数后，不可以再定义无参的构造函数，因为编译器在创建无参对象时不知道应该调用哪一个构造函数！</p>\n</blockquote>\n<hr/>\n<h2 id=\"2.%20%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%C2%A0\">2. 析构函数 </h2>\n<p>析构函数：与构造函数功能相反，<strong>析构函数不是完成对象本身的销毁</strong>，局部对象的销毁工作是由编译器完成的。而<strong>对象在销毁时会自动调用析构函数，完成对象中资源的清理工作</strong>。</p>\n<blockquote>\n<p><strong>析构函数是特殊的成员函数</strong>，具有以下特征：</p>\n<ol><li>析构函数名是在类名前加上字符~</li><li>无参数无返回值类型（不能写void）</li><li>一个类只能有一个析构函数。若未显示定义，系统会自动生成默认的析构函数。需注意析构函数不能重载</li><li>对象生命周期结束时，C++编译器（或者说系统）自动调用析构函数</li><li>析构函数主要功能是完成资源清理，比如释放malloc开辟的内存。但编译器自动生成的析构函数，对内置类型成员一样不做处理，对自定义类型成员会去调用它的析构函数。结合这点来看，如果一个类中没有申请资源时，析构函数可以不写，直接使用默认生成的析构函数；有资源申请时一定要写，否则会造成资源泄漏</li></ol>\n</blockquote>\n<hr/>\n<h2 id=\"3.%20%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\">3. 拷贝构造函数</h2>\n<p>对一个已经存在的对象，我们想要创建一个和已存在对象一模一样的对象，应该如何做?下面引入拷贝构造函数。</p>\n<p><strong>拷贝构造函数</strong>：只有<strong>单个形参</strong>，该形参<strong>是</strong>对本类<strong>类型对象的引用（一般常用const修饰），</strong>在用<strong>已存在的类类型对象创建新对象时，由编译器自动调用</strong></p>\n<blockquote>\n<p><strong>拷贝构造函数</strong>也是<strong>特殊的成员函数</strong>，具有以下特征：</p>\n<ol><li>拷贝构造函数是<strong>构造函数的一个重载形式</strong>，参数不同构成重载</li><li>拷贝构造函数的<strong>参数只有一个且必须是类类型对象的引用</strong>，<strong>使用传值方式编译器直接报错</strong>，因为会引发无穷递归调用（不使用引用传值，形参是实参的拷贝，创建形参时自动调用拷贝构造函数，就会产生无穷递归调用） <pre><code class=\"language-cpp\">class Date\n{\npublic:\n\tDate(int year = 1900, int month = 1, int day = 1)\n\t{\n\t\t_year = year;\n\t\t_month = month;\n\t\t_day = day;\n\t}\n\n\t// Date(const Date d) // 错误写法：编译报错，会引发无穷递归\n\tDate(const Date&amp; d) // 正确写法\n\t{\n\t\t_year = d._year;\n\t\t_month = d._month;\n\t\t_day = d._day;\n\t}\n\nprivate:\n\tint _year;\n\tint _month;\n\tint _day;\n};\n\nint main()\n{\n\tDate d1;//调用默认构造函数\n\tDate d2(d1);//用已存在的d1创建新对象d2，调用拷贝构造函数\n\n\treturn 0;\n}</code></pre> </li><li><strong>如果显式定义，编译器会生成默认的拷贝构造函数</strong>。默认的拷贝构造函数在创建对象时按内存存储中的字节序完成拷贝，<strong>即浅拷贝，或者称为值拷贝</strong>。同时，默认生成的拷贝构造函数，<strong>对于内置类型是按照字节方式直接拷贝，而自定义类型是调用其拷贝构造函数完成拷贝。</strong></li><li><strong>编译器生成的默认构造函数已经可以完成字节序的值拷贝</strong>了，但特殊情况下仍需自己显式定义，比如自定义的栈，里面存在一个指向malloc开辟的空间的指针，如果只是值拷贝，那么新创建的对象和原先对象中的指针会指向同一块空间，达不到拷贝的要求，这时要显式定义，利用<strong>深拷贝</strong>去解决！</li><li><strong>拷贝构造函数的使用场景</strong>：使用已存在的对象创建新对象、函数传参类型为类类型对象（以实参创建形参的过程）、函数返回值类型为类类型对象（有tmp返回值的拷贝构造和接收变量的拷贝构造）</li><li><strong>为了提高程序效率，一般对象传参时，尽量使用引用类型，返回时根据实际场景，能用引用尽量使用引用。</strong></li></ol>\n</blockquote>\n<hr/>\n<h2 id=\"4.%20%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD\">4. 赋值运算符重载</h2>\n<h3 id=\"4.1.%20%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD\">4.1. 运算符重载</h3>\n<p><strong>C++为了增强代码的可读性引入了运算符重载，运算符重载是具有特殊函数名的函数</strong>，也具有其返回值类型，函数名以及参数列表，其返回值类型与参数列表与普通的函数类似。</p>\n<p>函数名字为：<strong>operator需要重载的运算符符号</strong></p>\n<p>函数原型：<strong>返回值类型 operator操作符(参数列表) {……}</strong></p>\n<p><strong>注意：</strong></p>\n<ol><li>不能通过连接其他非操作符的符号来创建新的操作符，比如operator@、operator#</li><li><strong>重载操作符必须有一个类类型参数</strong></li><li><strong>用于内置类型的运算符，其含义不能改变</strong>，例如：内置类型的整数+，不能改变其含义。这里我们要深入理解<strong>运算符重载的意义</strong>：C++中引入了类与对象，而<strong>运算符重载是为了让这些自定义的对象也能像内置类型数据一样可以使用加减乘除、大小比较、赋值、输入输出等操作符</strong></li><li><strong>作为类成员函数重载时，其形参看起来比操作数目少1，因为成员函数的第一个参数为隐藏的this指针</strong></li><li><strong>    .*    ::    sizeof    ?    .   </strong> 注意<strong>这五个运算符都不能重载</strong></li></ol>\n<p>下面以日期类Date为例，完善运算符重载操作：</p>\n<blockquote>\n<p>下面先给完整的源代码，再结合每一个运算符进行分析：</p>\n<p><strong>Date.h</strong></p>\n<pre><code class=\"language-cpp\">#pragma once\n\n#include &lt;iostream&gt;\n#include &lt;assert.h&gt;\n\nusing namespace std;\n\nclass Date\n{\n\t//友元函数  --  这个函数内部可以使用Date对象访问私有保护成员\n\tfriend ostream&amp; operator&lt;&lt;(ostream&amp; out, const Date&amp; d);\n\tfriend istream&amp; operator&gt;&gt;(istream&amp; in, Date&amp; d);\n\npublic:\n\t//获取某年某月天数\n\t//被频繁调用，所以直接放在类里面定义作为inline\n\tint GetMonthDay(int year, int month)\n\t{\n\t\tstatic int days[13] = { 0,31,28,31,30,31,30,31,31,30,31,30,31 };//频繁调用，static就可以避免重复创建\n\t\tint day = days[month];\n\t\tif (month == 2\n\t\t\t&amp;&amp; ((year % 4 == 0 &amp;&amp; year % 100 != 0) || (year % 400 == 0)))\n\t\t{\n\t\t\tday += 1;\n\t\t}\n\n\t\treturn day;\n\t}\n\n\tbool CheckDate()\n\t{\n\t\tif (_year &gt;= 1\n\t\t\t&amp;&amp; _month &gt; 0 &amp;&amp; _month &lt; 13\n\t\t\t&amp;&amp; _day&gt;0 &amp;&amp; _day &lt;= GetMonthDay(_year, _month))\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t//构造函数会被频繁调用，所以直接放在类里面定义作为inline\n\tDate(int year = 1900, int month = 1, int day = 1)\n\t{\n\t\t_year = year;\n\t\t_month = month;\n\t\t_day = day;\n\n\t\t//if (!CheckDate())\n\t\t//{\n\t\t//\tPrint();\n\t\t//\tcout &lt;&lt; \"日期非法\" &lt;&lt; endl;\n\t\t//}\n\n\t\tassert(CheckDate());\n\t}\n\n\tvoid Print()const;\n\n\tbool operator==(const Date&amp; d)const;\n\tbool operator!=(const Date&amp; d)const;\n\tbool operator&gt;(const Date&amp; d)const;\n\tbool operator&gt;=(const Date&amp; d)const;\n\tbool operator&lt;(const Date&amp; d)const;\n\tbool operator&lt;=(const Date&amp; d)const;\n\n\tDate&amp; operator=(const Date&amp; d)\n\t{\n\t\tif (this != &amp;d)\n\t\t{\n\t\t\t_year = d._year;\n\t\t\t_month = d._month;\n\t\t\t_day = d._day;\n\t\t}\n\n\t\treturn *this;\n\t}\n\n\tDate operator+(int day)const;\n\tDate&amp; operator+=(int day);\n\n\t//++d1;\n\t//d1++;\n\t//直接按特性重载，无法区分\n\t//特殊处理，使用重载区分，后置++重载增加一个int参数跟前置++构成函数重载进行区分\n\tDate&amp; operator++();//前置++\n\tDate operator++(int);//后置++\n\n\n\tDate operator-(int day)const;\n\tDate&amp; operator-=(int day);\n\n\t//--d1;\n\t//d1--;\n\t//直接按特性重载，无法区分\n\t//特殊处理，使用重载区分，后置--重载增加一个int参数跟前置++构成函数重载进行区分\n\tDate&amp; operator--();//前置--\n\tDate operator--(int);//后置--\n\n\t//日期相减\n\tint operator-(const Date&amp; d)const;\n\n\t//void operator&lt;&lt;(ostream&amp; out);//成员函数，左操作数只能是日期类\n\nprivate:\n\tint _year;\n\tint _month;\n\tint _day;\n};\n\n//流插入重载\ninline ostream&amp; operator&lt;&lt;(ostream&amp; out, const Date&amp; d)\n{\n\t//out就是cout的别名\n\tout &lt;&lt; d._year &lt;&lt; \"-\" &lt;&lt; d._month &lt;&lt; \"-\" &lt;&lt; d._day &lt;&lt; endl;//无法访问私有成员，利用友元解决\n\treturn out;\n}\n\n//流提取重载\ninline istream&amp; operator&gt;&gt;(istream&amp; in, Date&amp; d)\n{\n\tin &gt;&gt; d._year &gt;&gt; d._month &gt;&gt; d._day;\n\tassert(d.CheckDate());\n\n\treturn in;\n}</code></pre>\n<hr/>\n<p>Date.cpp</p>\n<pre><code class=\"language-cpp\">#include \"Date.h\"\n\nvoid Date::Print()const\n{\n\tcout &lt;&lt; _year &lt;&lt; \"/\" &lt;&lt; _month &lt;&lt; \"/\" &lt;&lt; _day &lt;&lt; endl;\n}\n\n//任何一个类，只需要实现 &gt; 、== 或者 &lt; 、== 重载即可，后面的比较运算符可以复用他们的重载\n\nbool Date::operator== (const Date&amp; d)const\n{\n\treturn _year == d._year\n\t\t&amp;&amp; _month == d._month\n\t\t&amp;&amp; _day == d._day;\n}\n\nbool Date::operator!=(const Date&amp; d)const\n{\n\treturn !(*this == d);//复用 == 重载\n}\n\nbool Date::operator&gt;(const Date&amp; d)const\n{\n\tif ((_year &gt; d._year)\n\t\t|| (_year == d._year &amp;&amp; _month &gt; d._month)\n\t\t|| (_year == d._year &amp;&amp; _month == d._month &amp;&amp; _day &gt; d._day))\n\t{\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n\nbool Date::operator&gt;=(const Date&amp; d)const\n{\n\treturn (*this &gt; d) || (*this == d);//复用\n}\n\nbool Date::operator&lt;(const Date&amp; d)const\n{\n\treturn !(*this &gt;= d);\n}\n\nbool Date::operator&lt;=(const Date&amp; d)const\n{\n\treturn !(*this &gt; d);\n}\n\nDate Date::operator+(int day)const\n{\n\t//8/24 - 02:56\n\t//Date ret(*this)//拷贝构造\n\tDate ret = *this;//虽然用 = ，但仍是拷贝构造\n\t//两个已经存在的对象才是赋值！！！，正在创建的是拷贝构造\n\tret += day;\n\n\treturn ret;\n}\n\nDate&amp; Date::operator+=(int day)\n{\n\tif (day &lt; 0)\n\t{\n\t\treturn *this -= -day;\n\t}\n\n\t_day += day;\n\twhile (_day &gt; GetMonthDay(_year, _month))\n\t{\n\t\t_day -= GetMonthDay(_year, _month);\n\t\t++_month;\n\t\tif (_month == 13)\n\t\t{\n\t\t\t_year++;\n\t\t\t_month = 1;\n\t\t}\n\t}\n\n\treturn *this;\n}\n\nDate&amp; Date::operator++()//前置++\n{\n\t*this += 1;\n\treturn *this;\n}\n\nDate Date::operator++(int)//后置++\n{\n\tDate tmp(*this);\n\t*this += 1;\n\n\treturn tmp;\n}\n\n\nDate Date::operator-(int day)const\n{\n\tDate ret = *this;\n\tret -= day;\n\treturn ret;\n}\n\nDate&amp; Date::operator-=(int day)\n{\n\t_day -= day;\n\twhile (_day &lt;= 0)\n\t{\n\t\t--_month;\n\t\tif (_month == 0)\n\t\t{\n\t\t\t_year--;\n\t\t\t_month = 12;\n\t\t}\n\n\t\t_day += GetMonthDay(_year, _month);\n\t}\n\n\treturn *this;\n}\n\nDate&amp; Date::operator--()//前置--\n{\n\treturn *this -= 1;\n}\n\nDate Date::operator--(int)//后置--\n{\n\tDate tmp(*this);\n\t*this -= 1;\n\treturn tmp;\n}\n\n//d1 - d2\nint Date::operator-(const Date&amp; d)const\n{\n\tint flag = 1;\n\t//拷贝构造\n\tDate max = *this;\n\tDate min = d;\n\n\tif (*this &lt; d)\n\t{\n\t\t//赋值\n\t\tmax = d;\n\t\tmin = *this;\n\t\tflag = -1;//第一个小，第二个大，结果是负值\n\t}\n\n\tint n = 0;\n\twhile (min != max)\n\t{\n\t\t++min;\n\t\t++n;\n\t}\n\n\treturn n * flag;\n}</code></pre>\n<hr/>\n<p><strong>比较运算符重载：</strong></p>\n<ol><li>我们想让日期类可以像内置类型数据一样进行比较大小，并返回布尔值，在不写运算符重载的情况下显然是不能直接比较的，有了这样的需求，下面通过运算符重载进行操作即可。</li><li>先写其中两个吧，比如 == 和 &gt; 运算符的重载 <pre><code class=\"language-cpp\">bool Date::operator== (const Date&amp; d)const\n{\n\treturn _year == d._year\n\t\t&amp;&amp; _month == d._month\n\t\t&amp;&amp; _day == d._day;\n}\n\nbool Date::operator&gt;(const Date&amp; d)const\n{\n\tif ((_year &gt; d._year)\n\t\t|| (_year == d._year &amp;&amp; _month &gt; d._month)\n\t\t|| (_year == d._year &amp;&amp; _month == d._month &amp;&amp; _day &gt; d._day))\n\t{\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}</code></pre> </li><li>重载函数体里面操作的实际是该对象里的内置类型数据，这时的比较操作符的含义普通数据比较大小的含义一样，不能改变！相信看到这里，<strong>也比较容易理解为什么会有运算符重载的需要了，因为对于自定义类型，并不能简单地像内置类型一样进行比较大小的操作。</strong></li><li><strong>技巧：任何一个类，只需要实现 &gt; 、== 或者 &lt; 、== 重载即可，后面的比较运算符可以复用他们的重载</strong> <pre><code class=\"language-cpp\">bool Date::operator!=(const Date&amp; d)const\n{\n\treturn !(*this == d);//复用 == 重载\n}\n\nbool Date::operator&gt;=(const Date&amp; d)const\n{\n\treturn (*this &gt; d) || (*this == d);//复用\n}\n\nbool Date::operator&lt;(const Date&amp; d)const\n{\n\treturn !(*this &gt;= d);\n}\n\nbool Date::operator&lt;=(const Date&amp; d)const\n{\n\treturn !(*this &gt; d);\n}</code></pre> <p></p> </li></ol>\n<hr/>\n<p><strong>加减运算符重载：日期相减，加减天数都是有意义的，所以可以进行运算符重载，而日期乘除就没有意义，所以可以不用写。有意义的操作符都可以进行重载</strong></p>\n<ol><li>+和+=天数，可以先写+=运算符重载，然后写+时再复用 <pre><code class=\"language-cpp\">Date Date::operator+(int day)const\n{\n\t//8/24 - 02:56\n\t//Date ret(*this)//拷贝构造\n\tDate ret = *this;//虽然用 = ，但仍是拷贝构造\n\t//两个已经存在的对象才是赋值！！！，正在创建的是拷贝构造\n\tret += day;//复用+=\n\n\treturn ret;\n}\n\nDate&amp; Date::operator+=(int day)\n{\n\tif (day &lt; 0)\n\t{\n\t\treturn *this -= -day;\n\t}\n\n\t_day += day;\n\twhile (_day &gt; GetMonthDay(_year, _month))\n\t{\n\t\t_day -= GetMonthDay(_year, _month);\n\t\t++_month;\n\t\tif (_month == 13)\n\t\t{\n\t\t\t_year++;\n\t\t\t_month = 1;\n\t\t}\n\t}\n\n\treturn *this;\n}</code></pre> </li><li>-和-=天数，可以先写-=，然后再写-时复用 <pre><code class=\"language-cpp\">Date Date::operator-(int day)const\n{\n\tDate ret = *this;\n\tret -= day;\n\treturn ret;\n}\n\nDate&amp; Date::operator-=(int day)\n{\n\t_day -= day;\n\twhile (_day &lt;= 0)\n\t{\n\t\t--_month;\n\t\tif (_month == 0)\n\t\t{\n\t\t\t_year--;\n\t\t\t_month = 12;\n\t\t}\n\n\t\t_day += GetMonthDay(_year, _month);\n\t}\n\n\treturn *this;\n}</code></pre> <p><strong>至于为什么要先写+=和-=，再进行复用</strong>，<strong>如果反过来写的话</strong>，<strong>会增加拷贝构造的次数，效率较低</strong>！</p> </li><li>前置++和后置++ <pre><code class=\"language-cpp\">//++d1;\n//d1++;\n//直接按特性重载，无法区分\n//特殊处理，使用重载区分，后置++重载增加一个int参数跟前置++构成函数重载进行区分\nDate&amp; Date::operator++()//前置++\n{\n\t*this += 1;\n\treturn *this;\n}\n\nDate Date::operator++(int)//后置++\n{\n\tDate tmp(*this);\n\t*this += 1;\n\n\treturn tmp;\n}</code></pre> </li><li>前置--和后置-- <pre><code class=\"language-cpp\">//--d1;\n//d1--;\n//直接按特性重载，无法区分\n//特殊处理，使用重载区分，后置--重载增加一个int参数跟前置++构成函数重载进行区分\nDate&amp; Date::operator--()//前置--\n{\n\treturn *this -= 1;\n}\n\nDate Date::operator--(int)//后置--\n{\n\tDate tmp(*this);\n\t*this -= 1;\n\treturn tmp;\n}</code></pre> <strong>为了区分前置和后置的区别，在定义重载时，后置统一增加一个int参数，这样可以使前置和后置构成函数重载，编译之后会形成不同的符号表，运行时再由编译器自动选择前置还是后置</strong></li><li>日期相减 <pre><code class=\"language-cpp\">//d1 - d2\nint Date::operator-(const Date&amp; d)const\n{\n\tint flag = 1;\n\t//拷贝构造\n\tDate max = *this;\n\tDate min = d;\n\n\tif (*this &lt; d)\n\t{\n\t\t//赋值\n\t\tmax = d;\n\t\tmin = *this;\n\t\tflag = -1;//第一个小，第二个大，结果是负值\n\t}\n\n\tint n = 0;\n\twhile (min != max)\n\t{\n\t\t++min;\n\t\t++n;\n\t}\n\n\treturn n * flag;\n}</code></pre> </li></ol>\n</blockquote>\n<h3 id=\"4.2.%20%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD\">4.2. 赋值运算符重载</h3>\n<p>经过前面运算符重载知识的铺垫，理解这里的赋值运算符重载应该会容易许多。</p>\n<p><strong>首先强调的是赋值运算符重载的操作数为两个已经创建好的对象，而在创建新对象过程中使用到该赋值运算符，实际调用的是拷贝构造函数</strong></p>\n<pre><code class=\"language-cpp\">//Date ret(*this)//拷贝构造\nDate ret = *this;//虽然用 = ，但仍是拷贝构造\n//两个已经存在的对象才是赋值！！！，正在创建的是拷贝构造</code></pre>\n<blockquote>\n<p><strong>赋值运算符的重载格式：</strong></p>\n<ol><li><strong>参数类型：const T&amp;</strong>，引用传递可以提高效率（T为类名）</li><li><strong>返回值类型：T&amp;</strong>，返回使用引用传递可以提高返回效率，有返回值的目的是为了支持连续赋值</li><li><strong>检测是否自己给自己赋值</strong>，如果是，那么不做任何处理</li><li><strong>返回*this的引用</strong>：符合连续赋值的含义</li></ol>\n<pre><code class=\"language-cpp\">\tDate&amp; operator=(const Date&amp; d)\n\t{\n\t\tif (this != &amp;d)\n\t\t{\n\t\t\t_year = d._year;\n\t\t\t_month = d._month;\n\t\t\t_day = d._day;\n\t\t}\n\n\t\treturn *this;\n\t}</code></pre>\n<p><strong>注意：</strong></p>\n<ol><li><strong>赋值运算符只能重载成类的成员函数不能重载成全局函数，</strong>因为重载成全局函数后（不在类体内定义），就没有this指针了，需要给两个参数，这时候会出现各种意想不到的结果！另外，赋值运算符重载是类的六个默认成员函数之一，在不显式定义的情况下，编译器也会默认生成一个默认的，若此时用户在类外自己定义了一个全局的赋值运算符重载，就会和默认生成的运算符重载冲突了，因此<strong>赋值运算符只能是类的成员函数</strong>！</li><li>如果我们没有显式定义赋值运算符重载时，编译器会生成一个<strong>默认的赋值运算符重载，并以值的方式逐字节拷贝</strong>。注意：<strong>内置类型成员变量是直接赋值，而自定义类型的成员变量需要调用对应类的赋值运算符重载完成赋值</strong>，这里也<strong>涉及深浅拷贝问题</strong>，像日期类中成员变量都是内置类型的类，可以直接使用默认生成的赋值运算符重载。</li></ol>\n</blockquote>\n<h3 id=\"4.3.%20%E6%B5%81%E6%8F%92%E5%85%A5%2F%E6%B5%81%E6%8F%90%E5%8F%96%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD\">4.3. 流插入/流提取运算符重载</h3>\n<p>为了和普通数据的输入输出规范相对应，即<strong>满足操作数始终在操作符右侧，我们在定义流插入/流提取运算符重载时就不能在类体内定义</strong>，因为在类体内定义时，第一个操作数始终都是类对象的this指针，第一个操作数对应在操作符的左侧，不符合常用规范。</p>\n<p>将其定义与类体外，定义如下：</p>\n<pre><code class=\"language-cpp\">//流插入重载\ninline ostream&amp; operator&lt;&lt;(ostream&amp; out, const Date&amp; d)\n{\n\t//out就是cout的别名\n\tout &lt;&lt; d._year &lt;&lt; \"-\" &lt;&lt; d._month &lt;&lt; \"-\" &lt;&lt; d._day &lt;&lt; endl;//无法访问私有成员，利用友元解决\n\treturn out;\n}\n\n//流提取重载\ninline istream&amp; operator&gt;&gt;(istream&amp; in, Date&amp; d)\n{\n\tin &gt;&gt; d._year &gt;&gt; d._month &gt;&gt; d._day;\n\tassert(d.CheckDate());\n\n\treturn in;\n}</code></pre>\n<p>说明：</p>\n<ol><li>第一个参数传递的是iostream类的对象，out对应cout，in对应cin，在重载函数内部可进行正常的使用，同时保证了该参数是左操作数</li><li>第二个参数是要操作的类对象，是右操作数</li><li>由于输入输出是常用且较短的函数，所以将其定义为内联函数，提高访问效率</li><li>由于该运算符重载定义1在类体外，不能直接访问该类的私有成员属性，所以可以将这两个函数在类体内声明为友元函数 <pre><code class=\"language-cpp\">//友元函数  --  这个函数内部可以使用Date对象访问私有保护成员\nfriend ostream&amp; operator&lt;&lt;(ostream&amp; out, const Date&amp; d);\nfriend istream&amp; operator&gt;&gt;(istream&amp; in, Date&amp; d);</code></pre> </li><li> <p>返回值为iostream是为了支持连续输入和输出，下面是一段测试代码</p> <pre><code class=\"language-cpp\">void TestDate5()\n{\n\tDate d1(2022, 7, 25);\n\tDate d2(2022, 7, 26);\n\n\tcout &lt;&lt; d1 &lt;&lt; d2;\n\tcin &gt;&gt; d1 &gt;&gt; d2;\n\tcout &lt;&lt; d1 &lt;&lt; d2;\n    \n    //对于定义在类体内的流插入，左操作数是类对象，用起来非常的奇怪啊！\n\t//d1.operator&lt;&lt;(cout);\n\t//d1 &lt;&lt; cout;\n}</code></pre> <p></p> </li></ol>\n<hr/>\n<h2 id=\"5.%20const%E6%88%90%E5%91%98%C2%A0\">5. const成员 </h2>\n<p><strong>将const修饰的成员函数称为const成员函数，const修饰成员函数，实际修饰的是该成员函数的隐藏参数，即修饰this指针指向的内容，表明该成员函数中不能对该类的任何成员进行修改。</strong></p>\n<p>上面的运算符重载中，也有一些使用到了const去修饰this指针指向的内容</p>\n<p><strong>格式：返回类型 成员函数名(参数列表) const</strong></p>\n<p><strong>this指针的改变：Date* const this  -&gt; const Date* const this</strong></p>\n<blockquote>\n<p><strong>几个有意思的问题：</strong></p>\n<ol><li>const对象可以调用非const成员函数吗？</li><li>非const对象可以调用const成员函数吗？</li><li>const成员函数内可以调用其他非const成员函数吗？</li><li>非const成员函数内可以调用其他const成员函数吗？</li></ol>\n<hr/>\n<p>答案：</p>\n<ol><li>不可以，因为const对象的值是不可以被修改的，而非const成员函数中this指针指向的内容可以被修改，传递过去属于权限的放大</li><li>可以，因为const成员函数中this指针指向的值不可以被修改，而非const对象传递过去后属于权限的缩小</li><li>不可以，因为const成员函数中this指针指向的内容不能被修改，调用其他非const成员函数时，传递过去的是const对象，属于权限的放大</li><li>可以，非const成员函数内的this指针指向的内容可以被修改，作为参数传递给其他const成员函数时，属于权限的缩小</li></ol>\n<hr/>\n<p>小结：const对象和非const对象都可以调用const成员函数，所以一个类的成员函数能加const就加</p>\n</blockquote>\n<hr/>\n<h2 id=\"6.%20%E5%8F%96%E5%9C%B0%E5%9D%80%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%8F%8Aconst%E5%8F%96%E5%9C%B0%E5%9D%80%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD\">6. 取地址运算符重载及const取地址运算符重载</h2>\n<p><strong>这两个默认成员函数一般不需要重新定义，编译器会默认生成，使用默认生成的取地址重载即可</strong>。只有特殊情况，想让用户取到指定的内容时，才需要重新定义</p>\n<p>本篇博客就到这了~😪😪😪，从下午开始写，码字码到了23点，早点睡吧</p>\n<hr/>\n<p>往期优质博客：</p>\n<p><a class=\"link-info\" href=\"https://blog.csdn.net/m0_62080641/article/details/126721381?spm=1001.2014.3001.5501\" title=\"【C++面向对象程序设计】类与对象的引入、this指针\">【C++面向对象程序设计】类与对象的引入、this指针</a></p>\n<p><a class=\"link-info\" href=\"https://blog.csdn.net/m0_62080641/article/details/126714282?spm=1001.2014.3001.5501\" title=\"【Java从入门到放弃01】：类变量、类方法（static在类中的用法）及main函数细节\">【Java从入门到放弃01】：类变量、类方法（static在类中的用法）及main函数细节</a></p>\n<p><a class=\"link-info\" href=\"https://blog.csdn.net/m0_62080641/article/details/125740648?spm=1001.2014.3001.5501\" title=\"Linux环境搭建（使用云服务器方式）\">Linux环境搭建（使用云服务器方式）</a></p>\n<hr/>\n<blockquote>\n<p id=\"%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A\">学习记录：</p>\n<ul><li>📆本篇博客整理于2022.9.6</li><li>🎓作者：<strong>如何写出最优雅的代码</strong></li><li>📑如有错误，敬请指正🌹🌹</li><li>🥂关注一波不迷路！如果觉得写的不错，看完了别忘了点赞和收藏啊，感谢支持😏😏</li></ul>\n</blockquote>\n</div>\n</div>"}