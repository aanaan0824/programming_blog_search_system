{"blogid": "126703248", "writerAge": "码龄92天", "writerBlogNum": "732", "writerCollect": "892", "writerComment": "83", "writerFan": "982", "writerGrade": "6级", "writerIntegral": "7859", "writerName": "肥肥技术宅", "writerProfileAdress": "writer_image\\profile_126703248.jpg", "writerRankTotal": "2032", "writerRankWeekly": "367", "writerThumb": "151", "writerVisitNum": "119166", "blog_read_count": "105", "blog_time": "于 2022-09-05 13:21:12 发布", "blog_title": "你有用过 java中的栈和队列吗？怎么用栈来实现队列呢", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h1>一、前言</h1>\n<p>本篇文章从栈和队列的定义到 java实现，再到 LeetCode 232题来实现一下，怎么用栈来实现队列</p>\n<p>在今天我开始刷栈和队列相关算法了，在 java中栈和队列的类是 Stack和 Queue， 但是在 java中我好像很少甚至根本就没有写过相关的代码，不知道小伙伴们是不是和我一样，这次就借着刷 LeetCode的机会来重温一下相关的知识</p>\n<h1>二、栈和队列</h1>\n<h2>基础知识</h2>\n<p>栈和队列的基础知识应该是耳熟能详的了吧，栈是<strong>先进后出</strong>，队列是<strong>先进先出</strong>示</p>\n<p>栈有两种实现方式，一种是数组，一种是链表，栈的先进后出如图所示：</p>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/bb20d06df0ad8df289af15379888191e.webp?x-oss-process=image/format,png\"/></p>\n<p>队列的先进先出如图所示：</p>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/af80018acd00440d8bd974930ce6102f.webp?x-oss-process=image/format,png\"/></p>\n<h2>java中的栈</h2>\n<p>在 java中，类 Stack实现了一个标准的先入后出堆栈，通过查看源代码我们可以发现，Stack类实现了 Vector类</p>\n<blockquote>\n<p>Vector类实现了动态数组，和 ArrayList相似，但是两者是不同的</p>\n<ul><li>Vector是同步的</li><li>vector包含了许多方法，这些方法是不属于集合框架的</li></ul>\n</blockquote>\n<p>通过 idea的方法提示，我们可以看到 Stack自定义了以下五个方法他们的作用分别是：</p>\n<ul><li>push：  压栈，也可以称为进栈</li><li>empty：判断当前栈是否为null</li><li>peek:     查看栈顶部对象，不将其删除</li><li>pop:      删除该堆栈的顶部对象，并返回所删除的对象</li><li>search:  返回对象在堆栈中的位置，以 1为基数，0表示理想对象，返回值为 int类型</li></ul>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/8ab67795e25af3cae69d91839cd15f9d.webp?x-oss-process=image/format,png\"/></p>\n<p>下面我们对 Stack类进行方法测试，测试结果如下图所示：</p>\n<ul><li>创建栈对象</li><li>判断当前栈是否为空</li><li>进行压栈，压栈元素为 a</li><li>判断当前栈是否为空</li><li>查看栈顶部对象</li><li>进行压栈，压栈元素为 b</li><li>查看栈顶部对象</li><li>调用父类 Vector的方法，查看当前栈内的元素</li><li>查看元素 a在栈中的位置</li><li>查看元素 b在栈中的位置</li><li>查看栈顶对象，并删除</li><li>调用父类 Vector的方法，查看当前栈内的元素</li></ul>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/f7eb5debcc3d41e516da6673159af0e9.webp?x-oss-process=image/format,png\"/></p>\n<blockquote>\n<p>对栈不熟悉的建议花几分钟去调用方法看一下，虽然可能大概不常用</p>\n</blockquote>\n<h2>java中的队列</h2>\n<p>在 java中的队列是 Queue，但是这个类是一个接口，它定义了队列相关的方法，具体实现要看他的子类</p>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/ac1e6214af0364a2beea8253f77da48e.webp?x-oss-process=image/format,png\"/></p>\n<p>Queue定义的方法如下：</p>\n<ul><li>add：添加元素，失败会抛出异常</li><li>offer：添加元素</li><li>remove：删除元素，失败会抛出异常</li><li>poll：返回第一个元素，并删除</li><li>element：返回第一个元素</li><li>peek：查看栈顶元素，不将其删除</li></ul>\n<p>本篇文章以 LinkedList为例去试验一下队列的几个方法，后面有机会的话，可以专门出一篇文章讲一下队列</p>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/4bb0c18a9ed01fd2c4096e8b069714b2.webp?x-oss-process=image/format,png\"/></p>\n<h1>三、实践</h1>\n<p>俗话说得好，好记性不如烂笔头，有没有学明白试一下就知道了，刚好今天做了 LeetCode上的一道题目，两个知识点都有所涉及</p>\n<h2>LeetCode 232. 用栈实现队列</h2>\n<h3>题目描述</h3>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/807c3ab946b53612bf8eb610e6e5ad84.webp?x-oss-process=image/format,png\"/></p>\n<h3>规定代码格式</h3>\n<p>同时 LeetCode规定了我们实现的代码格式，并告诉我们将要以下面注释部分的方式去实例化和调用我们实现的 MyQueue</p>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/d61cfe91152ede1570e39e3d0af3e426.webp?x-oss-process=image/format,png\"/></p>\n<h3>思路分析</h3>\n<ul><li>通过本篇文章前面的讲解，我们了解了栈和队列的定义和基本方法</li><li>由于栈是<strong>先进后出</strong>，队列是<strong>先进先出</strong>，那么想要用栈来实现队列肯定要有两个栈</li><li>一个栈用来存储元素，第二个栈用来模拟队列的先入先出</li><li>队列中添加元素 in栈中压入元素</li><li>队列中弹出元素，in栈的元素弹出并压入 out栈，全部压入后弹出首元素</li><li>具体如下图所示</li></ul>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/3c21fc70eba4d24faac0cfa06be9b0de.webp?x-oss-process=image/format,png\"/></p>\n<blockquote>\n<p>注意题中 push方法的入参是 int类型</p>\n<p>题中说明：所有操作都是合法的，代表着我们不用判断异常情况</p>\n<p>只能使用栈来实现队列</p>\n</blockquote>\n<h3>代码展示</h3>\n<pre><code>public class MyQueue {\n\n    Stack&lt;Integer&gt; inStack;\n    Stack&lt;Integer&gt; outStack;\n\n    // 构造方法初始化 in栈和 out栈\n    public MyQueue() {\n        inStack = new Stack&lt;&gt;();\n        outStack = new Stack&lt;&gt;();\n    }\n\n    // 添加元素\n    public void push(int x) {\n        inStack.push(x);\n    }\n\n    public int pop() {\n        inToOut();\n        // 弹出 out栈的第一个元素\n        return outStack.pop();\n    }\n\n    public int peek() {\n        inToOut();\n        return outStack.peek();\n    }\n\n    public boolean empty() {\n        return inStack.empty() &amp;&amp; outStack.empty();\n    }\n\n    public void inToOut(){\n        // 如果 out栈中还有元素，则返回\n        if (!outStack.empty()){\n            return;\n        }\n        // 只要 in栈元素中还有数据就弹出并添加到 out栈中\n        while (!inStack.empty()){\n            outStack.push(inStack.pop());\n        }\n    }\n}\n复制代码</code></pre>\n<h3>关于pop方法</h3>\n<p>关于 pop方法在将 inStack栈中的元素压栈到 outStack之后，有的小伙伴可能会有疑问，这里后面为什么没有在把 outStack的元素在压栈会 inStack来保证队列的顺序</p>\n<p>下面我画了一个流程图，来表示执行 push操作和 pop操作过程中队列， inStack和 outStack的元素变化情况</p>\n<p>我们最后可以看到，outStack就是表明了部分队列的元素顺序，所以不用再 pop过程中重新将 outStack内的元素放入到 inStack中</p>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/518a5595780d0731b2bd52fe42e34c09.webp?x-oss-process=image/format,png\"/></p>\n<h3>提交结果</h3>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/9737e2a775c000494eaf5c6308fbde0a.webp?x-oss-process=image/format,png\"/></p>\n<h1>总结</h1>\n<p>事实证明小白刷 LeetCode还是有用的，不仅能学习到更多的知识，也能够对已有的知识加深印象</p>\n</div>\n</div>"}