{"blogid": "126247855", "writerAge": "码龄178天", "writerBlogNum": "53", "writerCollect": "1445", "writerComment": "2140", "writerFan": "4840", "writerGrade": "6级", "writerIntegral": "5572", "writerName": "月亮嚼成星~", "writerProfileAdress": "writer_image\\profile_126247855.jpg", "writerRankTotal": "3060", "writerRankWeekly": "94", "writerThumb": "1912", "writerVisitNum": "34285", "blog_read_count": "336", "blog_time": "于 2022-08-09 17:48:36 发布", "blog_title": "【Java SE】抽象类和接口", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h1><strong>🐳</strong>什么是抽象类？ </h1>\n<p><span style=\"color:#956fe7;\">在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，那么这样的类称为抽象类。</span></p>\n<h1><strong>🐳</strong>如何构造出一个抽象类？</h1>\n<p>在Java中，一个类如果被 abstract 修饰称为抽象类，抽象类中被<span style=\"color:#fe2c24;\"> abstract 修饰</span>的方法称为抽象方法，抽象方法不用给出具体的实现体。</p>\n<pre><code class=\"language-java\">//抽象类\npublic abstract class Shape {\n\n    protected double area;\n    abstract public void draw();//抽象方法\n    public double getarea(){//普通方法\n        return area;\n    }\n\n}</code></pre>\n<p><span style=\"color:#fe2c24;\">注：抽象类也是类，内部可以包含普通方法和属性，甚至构造方法。</span></p>\n<h1><strong>🐳</strong>抽象类有哪些特性？ </h1>\n<p>1. 抽象类不能直接实例化对象 </p>\n<p>2.抽象方法不能是 private 的</p>\n<p><span style=\"color:#fe2c24;\">注意：抽象方法没有加访问限定符时，默认是public.</span></p>\n<p>3. 抽象方法不能被final和static修饰，因为抽象方法要被子类重写</p>\n<p>4. 抽象类必须被继承，并且继承后子类要重写父类中的抽象方法，否则子类也是抽象类，必须要使用 abstract 修饰</p>\n<p>5. 抽象类中不一定包含抽象方法，但是有抽象方法的类一定是抽象类</p>\n<p>6. 抽象类中可以有构造方法，供子类创建对象时，初始化父类的成员变量</p>\n<p>7.抽象类本身不能被实例化, 要想使用, 只能创建该抽象类的子类.，然后让子类重写抽象类中的抽象方法。</p>\n<h1><strong>🐳</strong>问题：普通类也能被继承，普通方法也能被重写，为什么要用抽象类和抽象方法呢？</h1>\n<p><span style=\"color:#fe2c24;\">通常在使用抽象类的场景中实际工作不应该由父类完成, 而应由子类完成. 那么此时如果不小心误用成父类了, 使用普通类编译器是不会报错的。但是父类是抽象类由于抽象类不能实例化就会报错, 让我们尽早发现问题。</span></p>\n<h1><strong>🐳</strong>什么是接口？ </h1>\n<p>Java接口是一系列方法的声明，是一些方法特征的集合<span style=\"color:#fe2c24;\">，一个接口只有方法的特征没有方法的实现</span>，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为（功能）。</p>\n<p>接口可以理解为一种特殊的类，里面全部是由全局常量和公共的抽象方法所组成。<span style=\"color:#fe2c24;\">接口是解决Java无法使用多继承的一种手段</span>，但是接口在实际中更多的作用是制定标准的。或者我们可以直接把接口理解为100%的抽象类，<span style=\"color:#fe2c24;\">即接口中的方法必须全部是抽象方法。（jdk1.8前）</span></p>\n<h1><strong>🐳</strong>如何实现一个接口？</h1>\n<p>接口的定义格式与定义类的格式基本相同，将class关键字换成 <span style=\"color:#fe2c24;\">interface 关键字</span>，就定义了一个接口。 </p>\n<pre><code class=\"language-java\">//接口的定义格式与定义类的格式基本相同，将class关键字换成 interface 关键字，就定义了一个接口。\npublic interface USB {\n\n    public abstract void method1();// public abstract 是固定搭配，可以不写\n\n    void method2();// public abstract 是固定搭配，可以不写\n\n}\n</code></pre>\n<p><span style=\"color:#fe2c24;\"> 注意：接口不能直接使用，必须要有一个\"实现类\"来\"实现\"该接口，实现接口中的所有抽象方法</span></p>\n<pre><code class=\"language-java\">public class 类名称 implements 接口名称{\n\n//.......\n\n}</code></pre>\n<p>注意：子类和父类之间是<span style=\"color:#fe2c24;\">extends </span>继承关系，类与接口之间是 <span style=\"color:#fe2c24;\">implements</span> 实现关系。</p>\n<p> 下面实现一个简单的USB接口：</p>\n<pre><code class=\"language-java\">public interface USB {\n\n void OpenDevice();\n\n void CloseDevice();\n\n}\n\npublic class Mouse implements USB{\n\n    @Override\n    public void OpenDevice() {\n        System.out.println(\"打开鼠标\");\n\n    }\n\n    @Override\n    public void CloseDevice() {\n        System.out.println(\"关闭鼠标\");\n\n    }\n\n    public void Click(){\n        System.out.println(\"鼠标点击\");\n    }\n}\n\n\npublic class KeyBoard implements USB{\n    @Override\n    public void OpenDevice() {\n        System.out.println(\"打开键盘\");\n\n    }\n\n    @Override\n    public void CloseDevice() {\n        System.out.println(\"关闭键盘\");\n\n    }\n\n    public void Input(){\n        System.out.println(\"键盘输入\");\n    }\n}\n\npublic class Computer implements USB{\n    @Override\n    public void OpenDevice() {\n        System.out.println(\"打开电脑\");\n    }\n\n    @Override\n    public void CloseDevice() {\n        System.out.println(\"关闭电脑\");\n    }\n\n    public void UseDevice(USB usb){\n\n        usb.OpenDevice();\n        if(usb instanceof Mouse){\n            Mouse mouse=(Mouse) usb;\n            mouse.Click();\n        } else if (usb instanceof KeyBoard) {\n            KeyBoard keyBoard=(KeyBoard) usb;\n            keyBoard.Input();\n        }\n        usb.CloseDevice();\n\n    }\n}\n\n</code></pre>\n<h1><img alt=\"\" height=\"312\" src=\"image\\47fb41740ff643a39c7ee31c3b832d75.png\" width=\"934\"/><strong>🐳</strong>接口有哪些特性？</h1>\n<p>1. 接口类型是一种引用类型，但是不能直接new接口的对象。</p>\n<p>2. 接口中每一个方法都是public的抽象方法, 即接口中的方法会被隐式的指定为 public abstract（只能是public abstract，其他修饰符都会报错。 </p>\n<p>3. 接口中的方法是不能在接口中实现的，只能由实现接口的类来实现。</p>\n<p>4. 重写接口中方法时，不能使用default访问权限修饰。</p>\n<p>5. 接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量。</p>\n<p>6. 接口中不能有静态代码块和实例代码块和构造方法。</p>\n<p>7. 接口虽然不是类，但是接口编译完成后字节码文件的后缀格式也是.class</p>\n<p>8. 如果类没有实现接口中的<span style=\"color:#fe2c24;\">所有的抽象方法</span>，则类必须设置为抽象类</p>\n<p>9. jdk8中：接口中还可以包含default方法</p>\n<p><br/><span style=\"color:#956fe7;\">在Java中，类和类之间是单继承的，一个类只能有一个父类，即Java中不支持多继承，但是一个类可以实现多个接口。</span></p>\n<h1><strong>🐳</strong>如何去实现多个接口？</h1>\n<pre><code class=\"language-java\">//定义一个动物类\n\nclass Animal{\n    protected String name;\n\n    public Animal(String name){\n        this.name=name;\n    }\n\n}\n\n//下面提供一些有关动物的接口\n\ninterface IRunning{\n\n    void run();\n}\n\ninterface ISwimming{\n    void swim();\n\n}\n\ninterface Iflying{\n    void fly();\n}\n\n//猫会跑\n\nclass Cat extends Animal implements IRunning{\n    public Cat(String name) {\n        super(name);\n    }\n\n    @Override\n    public void run() {\n\n        System.out.println(name+\"正在跑\");\n\n    }\n}\n//鱼会游泳\n\nclass Fish extends Animal implements ISwimming{\n\n    public Fish(String name) {\n        super(name);\n    }\n\n    @Override\n    public void swim() {\n        System.out.println(name+\"正在游泳\");\n    }\n}\n\n//天鹅会跑，会游泳，会飞\n\nclass Swan extends Animal implements IRunning,ISwimming,Iflying{\n\n\n    public Swan(String name) {\n        super(name);\n    }\n\n    @Override\n    public void run() {\n        System.out.println(name+\"正在跑\");\n\n    }\n\n    @Override\n    public void swim() {\n        System.out.println(name+\"正在游泳\");\n\n    }\n\n    @Override\n    public void fly() {\n        System.out.println(name+\"正在飞\");\n\n    }\n}</code></pre>\n<p><span style=\"color:#fe2c24;\">注意：一个类实现多个接口时，每个接口中的抽象方法都要实现，否则类必须设置为抽象类。</span></p>\n<p>上面的代码展示了 Java 面向对象编程中最常见的用法: 一个类继承一个父类, 同时实现多种接口。</p>\n<p>时刻牢记多态的好处, 让程序猿忘记类型. 有了接口之后, 类的使用者就不必关注具体类型,<br/> 而只关注某个类是否具备某种能力。</p>\n<pre><code class=\"language-java\">public static void walk(IRunning running){\n        running.run();\n\n    }</code></pre>\n<p>在这个 walk 方法内部, 我们并不关注到底是哪种动物, 只要参数是会跑的, 就行<br/>  </p>\n<pre><code class=\"language-java\">public class Test {\n    public static void walk(IRunning running){\n        running.run();\n\n    }\n    public static void main(String[] args) {\n        Cat cat=new Cat(\"咪咪\");\n        walk(cat);\n\n    }\n\n}</code></pre>\n<p><img alt=\"\" height=\"375\" src=\"image\\0a7dbc39de774874b923e3eada24978b.png\" width=\"748\"/></p>\n<pre><code class=\"language-java\">class Robot extends Animal implements IRunning{\n\n    public Robot(String name){\n        super(name);\n    }\n\n    @Override\n    public void run() {\n        System.out.println(name + \"正在跑\");\n\n    }\n}\npublic class Test {\n    public static void walk(IRunning running){\n        running.run();\n\n    }\n    public static void main(String[] args) {\n        Cat cat=new Cat(\"咪咪\");\n        walk(cat);\n        walk(new Robot(\"大白\"));\n    }\n\n}</code></pre>\n<p><img alt=\"\" height=\"333\" src=\"image\\cbc3b36d7d8749fe89d9ae8beedf7e8a.png\" width=\"783\"/><br/> 在Java中，类和类之间是单继承的，一个类可以实现多个接口，接口与接口之间可以多继承。即：用接口可以达到多继承的目的。</p>\n<h1><strong>🐳</strong>如何实现接口间的继承</h1>\n<pre><code class=\"language-java\">//把IRunning,ISwimming,Iflying全部继承到IAction上\n\ninterface IAction extends IRunning,ISwimming,Iflying{\n\n}\n\nclass Swan extends Animal implements IAction {\n\n\n    public Swan(String name) {\n        super(name);\n    }\n\n    @Override\n    public void run() {\n        System.out.println(name + \"正在跑\");\n\n    }\n\n    @Override\n    public void swim() {\n        System.out.println(name + \"正在游泳\");\n\n    }\n\n    @Override\n    public void fly() {\n        System.out.println(name + \"正在飞\");\n\n    }\n}\n\npublic class Test {\n\n    public static void main(String[] args) {\n       Swan swan=new Swan(\"白白\");\n       swan.run();\n       swan.swim();\n       swan.fly();\n\n    }\n\n}</code></pre>\n<p><img alt=\"\" height=\"321\" src=\"image\\81cc7d94cdbd473ab87ad6b739356909.png\" width=\"863\"/></p>\n<p> 接口间的继承相当于把多个接口合并在一起。 </p>\n<h1><strong>🐳</strong>抽象类和接口的区别：</h1>\n<p><span style=\"color:#956fe7;\">（1）抽象类可以有构造方法，接口中不能有构造方法。</span></p>\n<p><span style=\"color:#956fe7;\">（2）抽象类中可以有普通成员变量，接口中没有普通成员变量。</span></p>\n<p><span style=\"color:#956fe7;\">（3）抽象类中可以包含静态方法，接口中不能包含静态方法。</span></p>\n<p><span style=\"color:#956fe7;\">（4） 一个类可以实现多个接口，但只能继承一个抽象类。</span></p>\n<p><span style=\"color:#956fe7;\">（5）接口可以被多重实现，抽象类只能被单一继承。</span></p>\n<p><span style=\"color:#956fe7;\">（6）如果抽象类实现接口，则可以把接口中方法映射到抽象类中作为抽象方法而不必实现，而在抽象类的子类中实现接口中方法。</span></p>\n<p><span style=\"color:#956fe7;\">接口和抽象类的相同点：</span></p>\n<p><span style=\"color:#956fe7;\">(1) 都可以被继承。</span></p>\n<p><span style=\"color:#956fe7;\">(2) 都不能被实例化。</span></p>\n<p><span style=\"color:#956fe7;\">(3) 都可以包含方法声明。</span></p>\n<p><span style=\"color:#956fe7;\">(4) 派生类必须实现未实现的方法。</span><br/>  </p>\n<h1><strong>🐳</strong>何为Object类？</h1>\n<p>Object是Java默认提供的一个类。Java里面除了Object类，所有的类都是存在继承关系的。默认会继承Object父类。即所有类的对象都可以使用Object的引用进行接收。<br/>  </p>\n<pre><code class=\"language-java\">public class Test2 {\n    public static void main(String[] args) {\n\n        fun1(new A());\n        fun1(new B());\n    }\n    public static void fun1(Object object){\n        System.out.println(object);\n    }\n}\n\n\nclass A{\n\n}\nclass B{\n\n}\n</code></pre>\n<h1><img alt=\"\" height=\"308\" src=\"image\\79aca1c33dfd494ebd3d442412974b9b.png\" width=\"721\"/></h1>\n<h1><strong>🐳</strong>利用Object类获取对象信息</h1>\n<p>如果要打印对象中的内容，可以直接<span style=\"color:#fe2c24;\">重写Object类中的toString()方法</span></p>\n<pre><code class=\"language-java\">class Animal{\n    protected String name;\n\n    public Animal(String name){\n        this.name=name;\n    }\n\n    @Override\n    public String toString() {\n        return \"Animal{\" +\n                \"name='\" + name + '\\'' +//可以修改\n                '}';\n    }\n}</code></pre>\n<h1><strong>🐳</strong> 利用Object类进行对象比较</h1>\n<p><span style=\"color:#956fe7;\">在Java中，==进行比较时：<br/> a.如果==左右两侧是基本类型变量，比较的是变量中值是否相同<br/> b.如果==左右两侧是引用类型变量，比较的是引用变量地址是否相同<br/> c.如果要比较对象中内容，必须</span><span style=\"color:#fe2c24;\">重写Object中的equals方法</span><span style=\"color:#956fe7;\">，因为</span><span style=\"color:#fe2c24;\">equals方法</span><span style=\"color:#956fe7;\">默认也是按照地址比较的</span></p>\n<pre><code class=\"language-java\"> //Object类中的equals方法\npublic boolean equals(Object obj) {\nreturn (this == obj); // 使用引用中的地址直接来进行比较\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        Cat cat1=new Cat(\"小白\",5);\n        Cat cat2=new Cat(\"小白\",5);\n        int a=10;\n        int b=10;\n        System.out.println(a==b);\n        System.out.println(cat1==cat2);\n        System.out.println(cat1.equals(cat2));\n\n    }\n}\n\nclass Cat{\n    private String name;\n    private int age;\n    public Cat(String name,int age){\n        this.name=name;\n        this.age=age;\n    }\n}</code></pre>\n<p><img alt=\"\" height=\"311\" src=\"image\\4d4e7edd91794ecc9d1b01f4dd2068bd.png\" width=\"781\"/></p>\n<p> 重写equals方法后，然后比较：</p>\n<pre><code class=\"language-java\">   @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Cat cat = (Cat) o;\n        return age == cat.age &amp;&amp; name.equals(cat.name);\n    }\n</code></pre>\n<p><img alt=\"\" height=\"298\" src=\"image\\e153c99623294f328ff655e421df1c9e.png\" width=\"714\"/><br/>  结论：比较对象中内容是否相同的时候，一定要重写equals方法。</p>\n<h1><strong>🐳</strong>hashcode方法</h1>\n<p><span style=\"color:#fe2c24;\">hashcode方法用来确定对象在内存中存储的位置是否相同</span><br/> 事实上hashCode() 在散列表中才有用，在其它情况下没用。在散列表中hashCode() 的作用是获取对象的散列码，进而确定该对象在散列表中的位置。</p>\n<p>我们认为两个名字相同，年龄相同的对象，将存储在同一个位置，如果不重写hashcode()方法</p>\n<pre><code class=\"language-java\">public class Test {\n    public static void main(String[] args) {\n        Cat cat1=new Cat(\"小白\",5);\n        Cat cat2=new Cat(\"小白\",5);\n        System.out.println(cat1.hashCode());\n        System.out.println(cat2.hashCode());\n\n    }\n}\n\nclass Cat{\n    private String name;\n    private int age;\n    public Cat(String name,int age){\n        this.name=name;\n        this.age=age;\n    }\n\n\n}\n</code></pre>\n<p><img alt=\"\" height=\"322\" src=\"image\\a9565ce137254c3ebcc77d69671fecab.png\" width=\"748\"/><br/><span style=\"color:#fe2c24;\"> 注意事项：两个对象的hash值不一样</span></p>\n<p> 像重写equals方法一样，我们也可以重写hashcode()方法。此时我们再来看看。</p>\n<pre><code class=\"language-java\">import java.util.Objects;\n\npublic class Test {\n    public static void main(String[] args) {\n        Cat cat1=new Cat(\"小白\",5);\n        Cat cat2=new Cat(\"小白\",5);\n        System.out.println(cat1.hashCode());\n        System.out.println(cat2.hashCode());\n\n    }\n}\n\nclass Cat{\n    private String name;\n    private int age;\n    public Cat(String name,int age){\n        this.name=name;\n        this.age=age;\n    }\n    @Override\n    public int hashCode() {\n        return Objects.hash(name, age);\n    }\n\n}</code></pre>\n<p> <img alt=\"\" height=\"281\" src=\"image\\bd430766adaa41f2a38776130e980f47.png\" width=\"667\"/></p>\n<p><span style=\"color:#fe2c24;\"> 哈希值一样。</span></p>\n<p>所以必要情况下我们也要<span style=\"color:#fe2c24;\">重写hashcode()方法。</span></p>\n</div>\n</div>"}