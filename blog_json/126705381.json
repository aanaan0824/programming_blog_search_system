{"blogid": "126705381", "writerAge": "码龄5年", "writerBlogNum": "188", "writerCollect": "2927", "writerComment": "436", "writerFan": "628", "writerGrade": "6级", "writerIntegral": "4913", "writerName": "resumebb", "writerProfileAdress": "writer_image\\profile_126705381.jpg", "writerRankTotal": "4240", "writerRankWeekly": "21304", "writerThumb": "614", "writerVisitNum": "392594", "blog_read_count": "124", "blog_time": "已于 2022-09-05 19:16:50 修改", "blog_title": "volatile关键字详解", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h1>volatile的作用</h1>\n<p>        volatile是一个轻量级的synchronized，一般作用于变量，在多线程开发中保证了内存的可见性。相比于synchronized关键字，volatile关键字的执行成本更低，效率更高。</p>\n<h1> volatile的特性</h1>\n<p>多线程三大特性：原子性、可见性、有序性；</p>\n<ul><li>原子性: 是指一个操作是不可中断的。即使是多个线程一起执行的时候,一个操作一旦开始,就不会被其他线程干扰。</li><li>可见性: 是指当一个线程修改了某一个共享变量的值,其他线程是否能够立即知道这个修改。显然,对于串行来说,可见性问题是不存在的。</li><li>有序性: 在并发时,程序的执行可能会出现乱序，给人的直观感觉就是写在前面的代码,会在后面执行，究其原因是指令重排导致的。</li></ul>\n<p>volatile具有三大特性：</p>\n<h3>1.可见性</h3>\n<p>        volatile可以保证不同线程对共享变量进行操作时的可见性，即当一个线程修改了共享变量时，另一个线程可以读取到共享变量被修改后的值。</p>\n<p>        导致内存不可见的主要原因就是Java内存模型中的本地内存和主内存之间的值不一致所导致，例如线程A访问自己本地内存A的X值时，但此时主内存的X值已经被线程B所修改，所以线程A所访问到的值是一个脏数据。<br/>         volatile可以保证内存可见性的关键是volatile的读/写实现了缓存一致性，缓存一致性的主要内容为:</p>\n<p>        每个处理器会通过嗅探总线上的数据来查看自己的数据是否过期，一旦处理器发现自己缓存对应的内存地址被修改，就会将当前处理器的缓存设为无效状态。此时，如果处理器需要获取这个数据需重新从主内存将其读取到本地内存。·当处理器写数据时，如果发现操作的是共享变量，会通知其他处理器将该变量的缓存设为无效状态。</p>\n<p>那缓存一致性是如何实现的呢?可以发现通过volatile修饰的变量，生成汇编指令时会比普通的变量多出一个Lock 指令，这个Lock指令就是volatile关键字可以保证内存可见性的关键，它主要有两个作用:<br/> 1.将当前处理器缓存的数据刷新到主内存。<br/> 2.刷新到主内存时会使得其他处理器缓存的该内存地址的数据无效。</p>\n<h3>2.有序性</h3>\n<p>        volatile通过禁止指令重排来保证代码的执行顺序。</p>\n<p>        为了实现volatile的内存语义，编译器在生成字节码时会通过插入内存屏障来禁止指令重排序。<br/>         内存屏障:内存屏障是一种CPU指令，它的作用是对该指令前和指令后的一些操作产生一定的约束，保证一些操作按顺序执行。</p>\n<h3>3.不能保证原子性</h3>\n<pre><code class=\"language-java\">class VolatoleAtomicityDemo {\n    public volatile static int inc = 0;\n\n    public void increase() {\n        inc++;\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        ExecutorService threadPool = Executors.newFixedThreadPool(5);\n        VolatoleAtomicityDemo volatoleAtomicityDemo = new\n                VolatoleAtomicityDemo();\n        for (int i = 0; i &lt; 5; i++) {\n            threadPool.execute(() -&gt; {\n                for (int j = 0; j &lt; 500; j++) {\n                    volatoleAtomicityDemo.increase();\n                }\n            });\n        }\n        // 等待1.5秒，保证上⾯程序执⾏完成\n        Thread.sleep(1500);\n        System.out.println(inc);\n        threadPool.shutdown();\n    }\n}</code></pre>\n<div>\n<span style=\"color:#3b454e;\">正常情况下，运⾏上⾯的代码理应输出 </span>\n<span style=\"color:#3b454e;\">2500 ，但实际每次输出结果都⼩于 </span>\n<span style=\"color:#3b454e;\">2500 </span>\n<span style=\"color:#3b454e;\">。 </span>\n</div>\n<div>\n<span style=\"color:#3b454e;\">如果 volatile </span>\n<span style=\"color:#3b454e;\">能保证 </span>\n<span style=\"color:#3b454e;\">inc++ </span>\n<span style=\"color:#3b454e;\">操作的原⼦性的话。每个线程中对 </span>\n<span style=\"color:#3b454e;\">inc 变量⾃增完之后， 其他线程可以⽴即看到修改后的值。</span>\n<span style=\"color:#3b454e;\">5 </span>\n<span style=\"color:#3b454e;\">个线程分别进⾏了</span>\n<span style=\"color:#3b454e;\"> 500 </span>\n<span style=\"color:#3b454e;\">次操作，那么最终</span>\n<span style=\"color:#3b454e;\"> inc 的值应该是5*500=2500</span>\n<span style=\"color:#3b454e;\">。 </span>\n</div>\n<div>\n<span style=\"color:#3b454e;\">但是</span>\n<span style=\"color:#3b454e;\"> </span>\n<span style=\"color:#3b454e;\">inc++ </span>\n<span style=\"color:#3b454e;\">其实是⼀个复合操作，包括三步： </span>\n</div>\n<div>\n<span style=\"color:#3b454e;\">1. </span>\n<span style=\"color:#3b454e;\">读取</span>\n<span style=\"color:#3b454e;\"> inc </span>\n<span style=\"color:#3b454e;\">的值。 </span>\n</div>\n<div>\n<span style=\"color:#3b454e;\">2. </span>\n<span style=\"color:#3b454e;\">对</span>\n<span style=\"color:#3b454e;\"> inc </span>\n<span style=\"color:#3b454e;\">加</span>\n<span style=\"color:#3b454e;\"> 1</span>\n<span style=\"color:#3b454e;\">。 </span>\n</div>\n<div>\n<span style=\"color:#3b454e;\">3. </span>\n<span style=\"color:#3b454e;\">将</span>\n<span style=\"color:#3b454e;\"> inc </span>\n<span style=\"color:#3b454e;\">的值写回内存。 </span>\n</div>\n<div>\n<span style=\"color:#3b454e;\">volatile </span>\n<span style=\"color:#3b454e;\">是⽆法保证这三个操作是具有原⼦性的，有可能导致下⾯这种情况出现： </span>\n</div>\n<div>\n<span style=\"color:#3b454e;\">1. </span>\n<span style=\"color:#3b454e;\">线程</span>\n<span style=\"color:#3b454e;\"> 1 </span>\n<span style=\"color:#3b454e;\">对 </span>\n<span style=\"color:#3b454e;\">inc </span>\n<span style=\"color:#3b454e;\">进⾏读取操作之后，还未对其进⾏修改。线程</span>\n<span style=\"color:#3b454e;\">2</span>\n<span style=\"color:#3b454e;\">⼜读取了</span>\n<span style=\"color:#3b454e;\">inc</span>\n<span style=\"color:#3b454e;\">的值并对其进⾏ </span>\n</div>\n<div>\n<span style=\"color:#3b454e;\">修改（</span>\n<span style=\"color:#3b454e;\">+1</span>\n<span style=\"color:#3b454e;\">），再将 </span>\n<span style=\"color:#3b454e;\">inc </span>\n<span style=\"color:#3b454e;\">的值写回内存。 </span>\n</div>\n<div>\n<span style=\"color:#3b454e;\">2. </span>\n<span style=\"color:#3b454e;\">线程</span>\n<span style=\"color:#3b454e;\"> 2 </span>\n<span style=\"color:#3b454e;\">操作完毕后，线程</span>\n<span style=\"color:#3b454e;\"> 1 </span>\n<span style=\"color:#3b454e;\">对 </span>\n<span style=\"color:#3b454e;\">inc </span>\n<span style=\"color:#3b454e;\">的值进⾏修改（</span>\n<span style=\"color:#3b454e;\">+1</span>\n<span style=\"color:#3b454e;\">），再将</span>\n<span style=\"color:#3b454e;\">inc</span>\n<span style=\"color:#3b454e;\">的值写回内存。 </span>\n</div>\n<div>\n<span style=\"color:#3b454e;\">这也就导致两个线程分别对 </span>\n<span style=\"color:#3b454e;\">inc </span>\n<span style=\"color:#3b454e;\">进⾏了⼀次⾃增操作后，</span>\n<span style=\"color:#3b454e;\">inc</span>\n<span style=\"color:#3b454e;\">实际上只增加了</span>\n<span style=\"color:#3b454e;\">1</span>\n<span style=\"color:#3b454e;\">。 </span>\n</div>\n<div>\n<span style=\"color:#3b454e;\">其实，如果想要保证上⾯的代码运⾏正确也⾮常简单，利⽤ </span>\n<span style=\"color:#3b454e;\">synchronized </span>\n<span style=\"color:#3b454e;\">、 </span>\n<span style=\"color:#3b454e;\">Lock 或者</span>\n<span style=\"color:#3b454e;\">AtomicInteger </span>\n<span style=\"color:#3b454e;\">都可以。</span>\n</div>\n</div>\n</div>"}