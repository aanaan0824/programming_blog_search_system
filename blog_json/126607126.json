{"blogid": "126607126", "writerAge": "码龄1年", "writerBlogNum": "35", "writerCollect": "582", "writerComment": "269", "writerFan": "1903", "writerGrade": "4级", "writerIntegral": "1094", "writerName": "风影66666", "writerProfileAdress": "writer_image\\profile_126607126.jpg", "writerRankTotal": "15845", "writerRankWeekly": "3524", "writerThumb": "410", "writerVisitNum": "44893", "blog_read_count": "759", "blog_time": "于 2022-09-01 18:58:50 发布", "blog_title": "Linux环境详解", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><span style=\"color:#38d8f0;\">目录</span></p>\n<p><span style=\"color:#38d8f0;\">vim的详细解绍</span></p>\n<p><span style=\"color:#38d8f0;\">程序运行过程(C)</span></p>\n<p id=\"-toc\" style=\"margin-left:0px;\"><span style=\"color:#38d8f0;\">Linux调试器——gdb</span></p>\n<p style=\"margin-left:0px;\"><span style=\"color:#38d8f0;\">制作进度条</span></p>\n<p style=\"margin-left:0px;\"><span style=\"color:#38d8f0;\">在Linux中使用gitee</span></p>\n<hr id=\"hr-toc\"/>\n<p><span style=\"color:#0d0016;\"><strong>vim的详细解绍</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>vim的概念</strong></span> </p>\n<p><span style=\"color:#0d0016;\"><strong>vim是一个文本编辑器(多模式的编辑器)，从定位上，和记事本没有任何差别，是vi的前身</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>vim的主要三种模式</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>命令模式，插入模式，底行模式</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>三种模式切换</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong><img alt=\"\" height=\"95\" src=\"image\\ec41b1af00584f4885b37431f1a13263.png\" width=\"553\"/> </strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>vim的命令模式</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>光标相关</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>光标除了可以用上下左右键移动外，还能用h(左)，j(下)，k(上)，l(右)</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>光标位置锚点：shift+^——&gt;当前行行首)  shift+$——&gt;当前行行尾</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>gg——&gt;起始行  shift+g——&gt;结束行  n+shift+g——&gt;指定行</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>w/b：按照单词为单位进行前后光标移动</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>文本操作</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>yy：复制当前行</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>nyy：复制当前行及其之后的n行，包括当前行</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>u：撤销误操作</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>p：粘贴</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>np：一次重复粘贴n行</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>dd：删除当前光标所在行，支持ndd</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>dd+p：剪切功能</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>shift+~：快速大小写切换</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>x：左向右删除光标之后的一个字符，支持nx</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>X：右向左删除光标之前的一个字符，也是支持nX</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>r：替换一个字符，即光标所在的字符，支持nr</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>shift+r：替换模式，直接进行多个内容的替换</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>Ctrl+r：撤销最近的撤销</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>vim的底行模式</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>set nu：调出行号</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>set nonu：取消行号</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>vs 文件：多文件操作</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>w：保存</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>q：退出</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>!：强制[w!，q!，wq!]</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>vim的配置</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>创建一个.vimrc的隐藏文件，然后进入该文件进行配置，比如设置行号，然后保存退出，再进入其</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>它文件时就有了行号</strong></span></p>\n<p><img alt=\"\" height=\"24\" src=\"image\\ca41d9800c7b43809aaaa6bb2d31d25f.png\" width=\"337\"/></p>\n<p><img alt=\"\" height=\"19\" src=\"image\\9a9712e83d6a4ddf85abb1a5caabd1b4.png\" width=\"451\"/></p>\n<p><img alt=\"\" height=\"24\" src=\"image\\8d3d9d1101e94b8fa7306ceba12f9ad3.png\" width=\"91\"/></p>\n<p><img alt=\"\" height=\"57\" src=\"image\\b2765f473ffe44d287b162b54e48c3d8.png\" width=\"129\"/></p>\n<p><span style=\"color:#0d0016;\"><strong>不过一般不自己去配置，采用别人已经配置好了的即可，如下链接就是一个简易版的vim配置，只</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>需将其拷贝到Linux上即可</strong></span></p>\n<p>curl -sLf <a href=\"https://gitee.com/HGtz2222/VimForCpp/raw/master/install.sh\" title=\"https://gitee.com/HGtz2222/VimForCpp/raw/master/install.sh\">https://gitee.com/HGtz2222/VimForCpp/raw/master/install.sh</a> -o ./install.sh &amp;&amp; bash ./install.sh</p>\n<p><span style=\"color:#0d0016;\"><strong>注意：vim配置在自己的配置文件中，只会影响自己的操作！</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>程序运行过程(C)</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>一个C语言程序的正常运行有四步：预处理，编译，汇编，链接</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>预处理：头文件展开，去除注释，条件编译，宏替换等</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>下图中的E让程序完成预处理后，就停下来，而-o test.i，则是生成一个临时文件，将预处理后的</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>结果保存在临时文件中，而不是打印在屏幕上</strong></span></p>\n<p><img alt=\"\" height=\"155\" src=\"image\\b588d18469c5477fb42e575cd45d17b4.png\" width=\"498\"/></p>\n<p><span style=\"color:#0d0016;\"><strong>编译：将C语言代码转换成汇编代码</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>下图中的S表示开始进行翻译，在完成翻译后停下来，和上面类似，将翻译后的结果保存至</strong></span><span style=\"color:#0d0016;\"><strong>临时文件中</strong></span></p>\n<p><img alt=\"\" height=\"149\" src=\"image\\58d8af48303644868729811ba37aa5b0.png\" width=\"509\"/></p>\n<p><span style=\"color:#0d0016;\"><strong>汇编：将汇编代码转换成机器可识别代码</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>下图中的c表示开始进行程序的翻译，完成汇编工作后停下来，和上面类似，将翻译后的结果保存</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>至</strong></span><span style=\"color:#0d0016;\"><strong>临时文件中，这里的test.o就等同于vs中的test.obj文件</strong></span></p>\n<p><img alt=\"\" height=\"124\" src=\"image\\33e611eb35414e20ab8c14131a16168a.png\" width=\"777\"/></p>\n<p><span style=\"color:#0d0016;\"><strong>以二进制形式输出到屏幕</strong></span></p>\n<p><img alt=\"\" height=\"159\" src=\"image\\0d5457c646b04d758139caa0f3906cf9.png\" width=\"587\"/></p>\n<p><span style=\"color:#0d0016;\"><strong>链接：生成可执行文件或库文件</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>链接过程是将我们自己的代码中的函数调用，外部数据和库关联起来</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>下图中将链接后的结果保存至一个文件中，这个文件是一个可执行文件，相当于vs中的.exe文件</strong></span></p>\n<p><img alt=\"\" height=\"307\" src=\"image\\550c02528fc6498ea526b30ac595aad8.png\" width=\"487\"/></p>\n<p><strong><span style=\"color:#0d0016;\">上述中的gcc -c test.c -o test.o也可写成gcc -o test.o test.c</span></strong></p>\n<p><span style=\"color:#0d0016;\"><strong>在Linux中，静态库：.a，动态库：.so，都和程序成功运行有关，也就可分为静态链接和动态链接</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>动态链接：比如你在学校，没有电脑使用，需要查资料时，就到网吧去查，从学校到网吧再到学</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>校，就是一个动态链接的过程</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>静态链接：比如你自己买了台电脑，就不再需要去网吧查资料，需要查时，在自己电脑查就可以，</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>这就是静态链接，静态链接也就是将库中的代码拷贝进我自己的可执行程序中。不再需要使用任何</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>库！</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>如下图，gcc默认采用动态链接方式，形成可执行程序 </strong></span></p>\n<p><img alt=\"\" height=\"82\" src=\"image\\df459ddcffa54c0da12ed9233d89988a.png\" width=\"546\"/><img alt=\"\" height=\"47\" src=\"image\\cc6ca72205364344b6437a5eafb728b2.png\" width=\"1075\"/></p>\n<p><span style=\"color:#0d0016;\"><strong>静态链接需要静态库，动态链接需要动态库！</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>如下图，两种链接方式形成的文件占用空间的大小很显著</strong></span></p>\n<p><img alt=\"\" height=\"285\" src=\"image\\2c61c7f4319f4c86a9fc070e27d06300.png\" width=\"567\"/></p>\n<p><span style=\"color:#0d0016;\"><strong>Linux调试器——gdb</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>如果一个程序是可以被调试的，那该程序的二进制文件一定加入了一些debug信息！</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>centos中，默认的可执行程序是debug</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>如下图，要将release版本变为debug版本，则要在后面加-g，而通过对比可看出debug所占的空</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>间要大一些，在debug版本中同时也能看到debug版本中的一些debug信息</strong></span></p>\n<p><img alt=\"\" height=\"615\" src=\"image\\3bb4260c4e03407fb2bce4d7f5d3415d.png\" width=\"767\"/></p>\n<p><span style=\"color:#0d0016;\"><strong>注意：gdb调试程序，必须是debug方式发布，也就是gcc -g</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>调试快捷键</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>下方的test得是一个可执行文件!</strong></span></p>\n<p><img alt=\"\" height=\"22\" src=\"image\\bcf11efabde247b495af037428fb6a55.png\" width=\"375\"/></p>\n<p><span style=\"color:#0d0016;\"><strong>l：每次显示最多10行，可以指定某行</strong></span></p>\n<p><img alt=\"\" height=\"400\" src=\"image\\55b2170d61c84bc299815832ae67df2a.png\" width=\"433\"/></p>\n<p><span style=\"color:#0d0016;\"><strong>b：打断点</strong></span></p>\n<p><img alt=\"\" height=\"43\" src=\"image\\35cc5b93344d463f89505f887551cd14.png\" width=\"439\"/></p>\n<p><span style=\"color:#0d0016;\"><strong>d：删除断点</strong></span></p>\n<p><img alt=\"\" height=\"213\" src=\"image\\6a1cb1daa6484f14a8bbecddba8f9ab4.png\" width=\"715\"/></p>\n<p><span style=\"color:#0d0016;\"><strong>info：显示断点信息，而下方这个y表示这个断点有用，如果是n，则表示这个断电被禁用了</strong></span></p>\n<p><img alt=\"\" height=\"80\" src=\"image\\372e7c7158aa47e29fc83f6e5bad14b4.png\" width=\"661\"/></p>\n<p><span style=\"color:#0d0016;\"><strong>enable：启用断点</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>disable：禁用断点</strong></span></p>\n<p><img alt=\"\" height=\"267\" src=\"image\\d1f38e89551a4214bef0c8a92720c7a3.png\" width=\"690\"/></p>\n<p><span style=\"color:#0d0016;\"><strong>run：直接运行程序</strong></span></p>\n<p><img alt=\"\" height=\"144\" src=\"image\\27204b125d054f40a45718eaea840d4a.png\" width=\"430\"/></p>\n<p><span style=\"color:#0d0016;\"><strong>display：显示变量大小</strong></span></p>\n<p><img alt=\"\" height=\"194\" src=\"image\\65b46ccb53bd44c3a58959d4adf755c5.png\" width=\"355\"/></p>\n<p><span style=\"color:#0d0016;\"><strong>undisplay：取消变量显示大小</strong></span></p>\n<p><img alt=\"\" height=\"120\" src=\"image\\a6ed85cde93546a4a39f865957a8f8e1.png\" width=\"361\"/></p>\n<p><span style=\"color:#0d0016;\"><strong>until：跳转到指定行</strong></span></p>\n<p><img alt=\"\" height=\"60\" src=\"image\\10663da3f8124b73a338c937be417652.png\" width=\"192\"/></p>\n<p><span style=\"color:#0d0016;\"><strong>continue：跳至下一个断点</strong></span></p>\n<p><img alt=\"\" height=\"153\" src=\"image\\68558f8567ba43748d499e5fad058509.png\" width=\"440\"/></p>\n<p> <span style=\"color:#0d0016;\"><strong>finish：执行到当前函数返回，然后停下来等待命令</strong></span></p>\n<p><img alt=\"\" height=\"213\" src=\"image\\f2249141a7d0457ea7d2ebec8c836e63.png\" width=\"462\"/></p>\n<p><span style=\"color:#0d0016;\"><strong>s：相当于vs中的F11，逐语句</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>n：相当于vs中的F10，逐过程，与s不同的是它遇到函数调用，不会进入函数</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>quit：退出函数调用</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>make与Makefile</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>make是一条命令，Makefile是一个文件</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>在vs中，文件的编译顺序我们不需要管，vs自己帮我们去定了，但在Linux需要我们维护文件和文</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>件之间的互相依赖关系</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>只有依赖关系与依赖方法共同作用才能达到形成可执行程序的目的！</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>创建可执行文件</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>下面第一个图第一个红线哪儿必须是table键，后面的-std=c99则是因为test.c中有</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>for(int i = 0;i &lt;=100;++i)，需要c99才能支持 i 这么定义，test依赖于test.c，而test.c形成test，</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>则需要依赖方法</strong></span></p>\n<p><img alt=\"\" height=\"72\" src=\"image\\1e57e5903afc4618aff1b6a89b0b1a02.png\" width=\"333\"/></p>\n<p><span style=\"color:#0d0016;\"><strong>做了上图中的后，只需要make就能执行其上图的黄色的哪一行指令，同时添加一个test的可执行</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>文件，第二次make后出现的提示，表示test文件已经存在了</strong></span></p>\n<p><img alt=\"\" height=\"287\" src=\"image\\e8a37e99bc3e4b80af75e808e31206cb.png\" width=\"478\"/></p>\n<p><span style=\"color:#0d0016;\"><strong>清理可执行文件</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>下方的.PHONY是修饰对应的符号，让符号变成伪目标的概念，总是可以执行的，和上面第二次执</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>行make就有所不同</strong></span></p>\n<p><img alt=\"\" height=\"74\" src=\"image\\ec775f8560bc4b23990f2f074cfd6a61.png\" width=\"160\"/></p>\n<p><img alt=\"\" height=\"76\" src=\"image\\e8426fe54aaf4bbaaf6e5a77a94e1677.png\" width=\"393\"/></p>\n<p><img alt=\"\" height=\"328\" src=\"image\\36cf9bfa97904345b676216588723f4d.png\" width=\"477\"/></p>\n<p><span style=\"color:#0d0016;\"><strong>创建可执行文件只需要make，删除可执行文件是make clean的原因</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>make扫描Makefile文件的时候，默认只会形成一个目标依赖关系，一般是第一个！建议把创建可</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>执行文件放在第一行</strong></span></p>\n<p><img alt=\"\" height=\"128\" src=\"image\\943b7484adfa430a950e9f48074b8200.png\" width=\"284\"/></p>\n<p><img alt=\"\" height=\"39\" src=\"image\\76d08cbe2f1a4e28b28dea4ee2cfbbd0.png\" width=\"320\"/></p>\n<p><span style=\"color:#0d0016;\"><strong>如下图，也可以采用这种方式来配置Makefile文件，在输入make时，$@会被替换为test，而$^会</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>被替换为test.c</strong></span></p>\n<p><img alt=\"\" height=\"100\" src=\"image\\e83e9231322043a4b3f297042acbbe81.png\" width=\"234\"/></p>\n<p><img alt=\"\" height=\"171\" src=\"image\\7de21e1b95894a61b6cd1fb471c849e5.png\" width=\"468\"/></p>\n<p><span style=\"color:#0d0016;\"><strong>制作进度条</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>回车与换行(\\n)的区别</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>回车：回到当前行的最开始</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>换行：列不变，新起一行</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>如下图，在运行下面的代码后，不会立即打印hello Mike!，而是会等程序结束后再打印，但并不</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>是</strong></span><span style=\"color:#0d0016;\"><strong>sleep语句比printf语句先执行</strong></span></p>\n<p><img alt=\"\" height=\"178\" src=\"image\\524ec2a82f7c40c89beaf6a00bafc933.png\" width=\"247\"/></p>\n<p><img alt=\"\" height=\"40\" src=\"image\\c10985ad79374cb9b477058407d1f907.png\" width=\"357\"/></p>\n<p><span style=\"color:#0d0016;\"><strong>原因：</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>printf已经执行，但是数据没有被立即刷新到显示器中！，因为没有\\n，所以字符串会暂时保存至</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>用户C语言级别的缓存区</strong></span></p>\n<p><img alt=\"\" height=\"145\" src=\"image\\4183883dc6384920b9e92f3bb5cc97a0.png\" width=\"613\"/></p>\n<p><span style=\"color:#0d0016;\"><strong>显示器设备刷新策略就是遇到\\n即进行刷新</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>如果想不带\\n，让它快速刷新，就可以调用下图中的函数接口</strong></span></p>\n<p><img alt=\"\" height=\"24\" src=\"image\\45372eee0fc14e9f9dcab62f36029960.png\" width=\"143\"/><span style=\"color:#0d0016;\"><strong> </strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>C程序，默认会打开三个输入输出流</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>stdin：键盘，stdout：显示器，stderr：显示器</strong></span></p>\n<p><img alt=\"\" height=\"102\" src=\"image\\78587361147b408294df32a7454e5dde.png\" width=\"201\"/></p>\n<p><span style=\"color:#0d0016;\"><strong>注意：</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>凡是显示到显示器上面的内容都是字符</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>凡是从键盘读取的内容也是字符</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>键盘与显示器也被称为字符设备！</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>如下图，就是一个简易进度条的代码，\\r是回车，让其每次都从一行的开头刷新，用usleep是以微</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>秒为单位，而sleep则是以秒为单位，会太慢，所以这里用usleep，前面\\033[31m则是printf的配</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>色方案中的一种，来改变颜色</strong></span></p>\n<p><img alt=\"\" height=\"408\" src=\"image\\05817a8d28c14ef8a37579a3f22903f2.png\" width=\"584\"/></p>\n<p><img alt=\"\" height=\"26\" src=\"image\\76769b97cd8a447e86508811b9877e13.png\" width=\"1019\"/></p>\n<p><span style=\"color:#0d0016;\"><strong>在Linux中使用gitee</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>安装git，安装完成后，输入指令可以看到一些信息及其版本</strong></span></p>\n<p><img alt=\"\" height=\"39\" src=\"image\\fe1a3cfcbb9a4317a3a6a7a35ea735dd.png\" width=\"194\"/></p>\n<p><img alt=\"\" height=\"136\" src=\"image\\f3b46d543e704520aa86b401c0ff69ae.png\" width=\"662\"/></p>\n<p><img alt=\"\" height=\"40\" src=\"image\\5529eef74e3b4f32a2201997f1a87b1b.png\" width=\"412\"/></p>\n<p><span style=\"color:#0d0016;\"><strong>将其仓库克隆在Linux上，即把地址拷贝到下面指令的后面即可，完成后可以看到一个新的文件</strong></span></p>\n<p><img alt=\"\" height=\"83\" src=\"image\\c5c14f540a0a46f880b95ec067a73283.png\" width=\"376\"/><span style=\"color:#0d0016;\"><strong> </strong></span> </p>\n<p><img alt=\"\" height=\"24\" src=\"image\\279dd711812b4e0aa5dad7ddf3817fa0.png\" width=\"688\"/></p>\n<p><img alt=\"\" height=\"83\" src=\"image\\1ba637fa8d9d48948ed5ce3f4210a816.png\" width=\"470\"/></p>\n<p><span style=\"color:#0d0016;\"><strong>添加文件，git add  文件 </strong></span></p>\n<p><img alt=\"\" height=\"26\" src=\"image\\1191971b326c4a06984b287f4009940f.png\" width=\"422\"/></p>\n<p><span style=\"color:#0d0016;\"><strong>提交文件，git commit -m 日志，填日志信息</strong></span></p>\n<p><img alt=\"\" height=\"245\" src=\"image\\87ebfd86bae047c58d134eaec2dc08ba.png\" width=\"647\"/></p>\n<p><span style=\"color:#0d0016;\"><strong>如果出现上图所述的情况，就需要输入下图中的信息，邮箱和gitee用户名</strong></span></p>\n<p><img alt=\"\" height=\"47\" src=\"image\\8301af488b9449e787a334824ee39632.png\" width=\"686\"/></p>\n<p><span style=\"color:#0d0016;\"><strong>最后是git push即可，然后就可以在仓库中看到刚上传的文件</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>git status</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>文件被添加后，可以看到将要被提交的文件</strong></span></p>\n<p><img alt=\"\" height=\"151\" src=\"image\\a26eca16099549d88d8ba11466cdfeb2.png\" width=\"487\"/> </p>\n<p><span style=\"color:#0d0016;\"><strong>git log </strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>可以看到提交的文件的日志信息 </strong></span></p>\n<p><img alt=\"\" height=\"122\" src=\"image\\35544d0065b1427b837777ba7c2cb75e.png\" width=\"458\"/> </p>\n</div>\n</div>"}