{"blogid": "125810565", "writerAge": "码龄5年", "writerBlogNum": "170", "writerCollect": "840", "writerComment": "266", "writerFan": "487", "writerGrade": "5级", "writerIntegral": "3991", "writerName": "牧羊女说", "writerProfileAdress": "writer_image\\profile_125810565.jpg", "writerRankTotal": "5261", "writerRankWeekly": "20842", "writerThumb": "209", "writerVisitNum": "576371", "blog_read_count": "1079", "blog_time": "于 2022-07-16 19:27:34 发布", "blog_title": "Python调用C/C++动态链接库", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>最近需要使用Python调用C/C++功能，于是进行了一些相关调研。总体来说，Python调用C功能还算是相对比较简单，主要涉及ctypes这个函数库。</p>\n<p><a href=\"https://docs.python.org/zh-cn/3.7/library/ctypes.html#module-ctypes\" title=\"ctypes\">ctypes</a> 是 Python 的外部函数库。它提供了与 C 兼容的数据类型，并允许调用C共享库中的函数。可使用该模块以纯 Python 形式对这些库进行封装。</p>\n<h3>基本数据类型的使用</h3>\n<p>ctypes定义了一些与C兼容的数据类型：</p>\n<p><img alt=\"\" height=\"755\" src=\"image\\bdcab88e61e94f74a898323e2d11aec5.png\" width=\"722\"/></p>\n<p>本篇主要关注跨语言调用时指针的处理方法，对于更全面的介绍，可参考：<a href=\"https://docs.python.org/zh-cn/3.7/library/ctypes.html#module-ctypes\" title=\"ctypes --- Python 的外部函数库 — Python 3.7.13 文档\">ctypes --- Python 的外部函数库 — Python 3.7.13 文档</a></p>\n<p>下面用一个小例子来介绍Python调用C/C++动态库的方法。</p>\n<p>C代码：</p>\n<pre><code class=\"language-cpp\">#include \"stdio.h\"\n#include &lt;iostream&gt;\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\nusing namespace std;\n\n// test for input char pointer\nvoid print_string(char* str)\n{\n    printf(\"This is c code: print_string().\\n\");\n    printf(\"%s\\n\", str);\n}\n\n// test for input integers and return an integer\nint add_func(int a, int b)\n{\n    printf(\"This is c code: add_func()\\n\");\n    return a + b;\n}\n\n// test for pointer as return value\nint* get_array()\n{\n    int *pa = new int[10];\n\tfor(int i = 0; i &lt; 10; i++)\n\t{\n\t\t\tpa[i] = i;\n\t}\n\treturn pa;\n}\n\nvoid free_array(int *pa)\n{\n\tif(pa)\n\t\tdelete [] pa;\n\n}\n\n#ifdef __cplusplus\n}\n#endif\n</code></pre>\n<p>上面测试代码定义了普通整数的计算并返回整数、输入字符指针并打印、输出整型指针、释放指针等操作。需要注意的是，由于ctypes只与C兼容，而C++因为支持函数重载而在编译时修改函数名，因此，对于C++代码，需要使用C的方式编译。不了解的同学可自行搜索extern \"C\"的用法，本篇不做过多展开。</p>\n<p>将以上代码编译成动态链接库：</p>\n<pre><code>g++ -std=c++11 test_c.c -shared -fPIC -o test_c.so</code></pre>\n<p>接着，我们使用Python来调用该动态库。Python代码：</p>\n<pre><code class=\"language-python\">#!/usr/bin/python\n\nfrom ctypes import *\nimport os\n\n# Load dynamic library\n#lib_path = os.getcwd() + '/test_c.so'\nlib_path = './test_c.so'\nsolib = cdll.LoadLibrary(lib_path)\n\n# Indicate the function arguments type and return value type\nsolib.print_string.argtypes = [c_char_p]\nsolib.print_string.restype = c_void_p\n\n# Call print_string function in C library\nsolib.print_string(b\"Hello Python!\")\n\n# Call add function in C library\nsolib.add_func.argtypes = [c_int, c_int]\nsolib.add_func.restype = c_int\nsum = solib.add_func(100,200)\nprint('Python code: sum = {}'.format(sum))\n\n\n# Call get_array function in C library, the return value is a pointer of integer\nsolib.get_array.restype = POINTER(c_int)\np_array = solib.get_array()\nint_array = [p_array[i] for i in range(10)]\n\nprint(\"Python code: \")\nfor x in int_array:\n    print(x, end = ' ')\n\n# Free the pointer\nsolib.free_array.argtypes = [POINTER(c_int)]\nsolib.free_array.restype = c_void_p\nsolib.free_array(p_array)\n\nprint('\\nEnd Python')</code></pre>\n<p>运行结果：</p>\n<p><img alt=\"\" height=\"198\" src=\"image\\01b587c822b74477ac51d55115a2cf42.png\" width=\"638\"/></p>\n<p>在Python代码调用C动态库时，C库函数的参数和返回值必须是ctypes类型，参数类型使用关键字argtypes定义，对参数的定义必须是以序列的形式，如上面代码中的参数类型定义：</p>\n<p>solib.add_func.argtypes = [c_int, c_int]</p>\n<p>solib.print_string.argtypes = [c_char_p]</p>\n<p>返回值参数类型使用restype定义，如上面代码中的语句：</p>\n<p>solib.add_func.restype = c_int</p>\n<p>solib.get_array.restype = POINTER(c_int)</p>\n<p>其中，get_array函数的返回值使用POINTER(c_int)关键字定义成了int型的指针。</p>\n<h3><strong>用户自定义类型的使用</strong></h3>\n<p>除了基本数据类型，用户还可以使用自定义类型，下面给出一个自定义结构体的测试例子：</p>\n<p>C代码：</p>\n<pre><code class=\"language-cpp\">typedef struct _point\n{\n        int x;\n        int y;\n        char desc[50];\n}Point;\n\nint get_point(Point point)\n{\n        printf(\"x = %d, y = %d, desc = %s\\n\", point.x, point.y, point.desc);\n        return 0;\n}\n</code></pre>\n<p>Python代码：</p>\n<pre><code class=\"language-python\">class Point(Structure):\n        _fields_ = [\n                (\"x\", c_int),\n                (\"y\", c_int),\n                (\"desc\", c_char * 50)\n        ]\n\n\npt = Point(5, 10, b'I am a point.')\nprint(pt.x, pt.y, pt.desc)\n\nsolib.get_point.argtypes = [Point]\nsolib.get_point.restype = c_int\n\n\nsolib.get_point(pt)\n</code></pre>\n<p>Python中定义结构体时，必须继承Structure类，其成员的定义必须使用_fields_属性，否则无法调用C结构体。_fields_属性是一个list，其成员均为2个值的tuple，分别对应结构体成员的名称(C结构体成员名称)和类型，类型为ctypes类型，或者是由ctypes组合而成的新类型(如自己定义的结构体)。</p>\n<p>以上代码的运行结果：</p>\n<p><img alt=\"\" height=\"59\" src=\"image\\0f03a826d1e44a7781db14e3c8ed9d85.png\" width=\"440\"/></p>\n<p> </p>\n<p></p>\n</div>\n</div>"}