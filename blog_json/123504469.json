{"blogid": "123504469", "writerAge": "码龄1年", "writerBlogNum": "103", "writerCollect": "48", "writerComment": "17", "writerFan": "72", "writerGrade": "4级", "writerIntegral": "1172", "writerName": "钟一淼", "writerProfileAdress": "writer_image\\profile_123504469.jpg", "writerRankTotal": "30860", "writerRankWeekly": "57809", "writerThumb": "83", "writerVisitNum": "32593", "blog_read_count": "3398", "blog_time": "已于 2022-03-18 13:05:20 修改", "blog_title": "图论：图的四种最短路径算法", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h1 id=\"main-toc\"><strong>目录：</strong></h1>\n<p id=\"%C2%A01.DFS%EF%BC%88%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95%EF%BC%89-toc\" style=\"margin-left:0px;\"><a href=\"#%C2%A01.DFS%EF%BC%88%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95%EF%BC%89\"> 1.DFS（单源最短路径算法）</a></p>\n<p id=\"%E4%BE%8B%E9%A2%981%EF%BC%9A-toc\" style=\"margin-left:40px;\"><a href=\"#%E4%BE%8B%E9%A2%981%EF%BC%9A\">例题1：</a></p>\n<p id=\"%C2%A0DFS%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90%EF%BC%9A-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A0DFS%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90%EF%BC%9A\"> DFS题目分析：</a></p>\n<p id=\"%E4%BB%A3%E7%A0%81DFS%EF%BC%9A-toc\" style=\"margin-left:80px;\"><a href=\"#%E4%BB%A3%E7%A0%81DFS%EF%BC%9A\">代码DFS：</a></p>\n<p id=\"%C2%A02.Floyed%EF%BC%88%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6On%5E3%EF%BC%89-toc\" style=\"margin-left:0px;\"><a href=\"#%C2%A02.Floyed%EF%BC%88%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6On%5E3%EF%BC%89\"> 2.Floyed（时间复杂度On^3）</a></p>\n<p id=\"1.%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A-toc\" style=\"margin-left:40px;\"><a href=\"#1.%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A\">1.应用场景：</a></p>\n<p id=\"2.%E8%A7%A3%E6%9E%90%E7%AE%97%E6%B3%95%EF%BC%9A%C2%A0%20%C2%A0%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#2.%E8%A7%A3%E6%9E%90%E7%AE%97%E6%B3%95%EF%BC%9A%C2%A0%20%C2%A0%C2%A0\">2.解析算法：    </a></p>\n<p id=\"%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%811%EF%BC%9A-toc\" style=\"margin-left:80px;\"><a href=\"#%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%811%EF%BC%9A\">核心代码1：</a></p>\n<p id=\"%E6%88%91%E7%9A%84%E7%AC%94%E8%AE%B0-toc\" style=\"margin-left:80px;\"><a href=\"#%E6%88%91%E7%9A%84%E7%AC%94%E8%AE%B0\">我的笔记</a></p>\n<p id=\"%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%812%EF%BC%9A-toc\" style=\"margin-left:80px;\"><a href=\"#%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%812%EF%BC%9A\">核心代码2：</a></p>\n<p id=\"%C2%A0Floyd%E4%BE%8B%E9%A2%98%EF%BC%9AAcWing%20854%20Floyd%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A0Floyd%E4%BE%8B%E9%A2%98%EF%BC%9AAcWing%20854%20Floyd%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF\"> Floyd例题：</a></p>\n<p id=\"3.Dijksyta%E7%AE%97%E6%B3%95-toc\" style=\"margin-left:0px;\"><a href=\"#3.Dijksyta%E7%AE%97%E6%B3%95\">3.Dijksyta算法</a></p>\n<p id=\"1.%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A%E5%8D%95%E6%BA%90%E8%B7%AF%E5%BE%84%E6%9C%80%E7%9F%AD%EF%BC%88%E6%88%91%E5%8F%AA%E7%9C%8B%E5%87%BA%E6%9D%A5%E4%BA%86%E8%BF%99%E7%A7%8D%EF%BC%89%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6(On%5E2)-toc\" style=\"margin-left:40px;\"><a href=\"#1.%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A%E5%8D%95%E6%BA%90%E8%B7%AF%E5%BE%84%E6%9C%80%E7%9F%AD%EF%BC%88%E6%88%91%E5%8F%AA%E7%9C%8B%E5%87%BA%E6%9D%A5%E4%BA%86%E8%BF%99%E7%A7%8D%EF%BC%89%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%28On%5E2%29\">1.应用场景：</a></p>\n<p id=\"2.%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0%EF%BC%9A-toc\" style=\"margin-left:40px;\"><a href=\"#2.%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0%EF%BC%9A\">2.算法描述：</a></p>\n<p id=\"1.%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9A-toc\" style=\"margin-left:80px;\"><a href=\"#1.%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9A\">1.初始化：</a></p>\n<p id=\"2.for%EF%BC%9A-toc\" style=\"margin-left:80px;\"><a href=\"#2.for%EF%BC%9A\">2.for：</a></p>\n<p id=\"%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81%EF%BC%9A-toc\" style=\"margin-left:80px;\"><a href=\"#%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81%EF%BC%9A\">核心代码：</a></p>\n<p id=\"3.%E4%BE%8B%E9%A2%98%EF%BC%9A%EF%BC%88%E6%94%B9%E9%A2%98%E7%9B%AE%E6%9D%A5%E6%BA%90%E4%BA%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%EF%BC%89-toc\" style=\"margin-left:40px;\"><a href=\"#3.%E4%BE%8B%E9%A2%98%EF%BC%9A%EF%BC%88%E6%94%B9%E9%A2%98%E7%9B%AE%E6%9D%A5%E6%BA%90%E4%BA%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%EF%BC%89\">3.例题：</a></p>\n<p id=\"%C2%A0%E6%B3%A8%E6%84%8F%EF%BC%9A-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A0%E6%B3%A8%E6%84%8F%EF%BC%9A\"> 注意：</a></p>\n<p id=\"%C2%A0%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%EF%BC%9A-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A0%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%EF%BC%9A\"> 代码如下：</a></p>\n<p id=\"4.SPFA%E7%AE%97%E6%B3%95-toc\" style=\"margin-left:0px;\"><a href=\"#4.SPFA%E7%AE%97%E6%B3%95\">4.SPFA算法</a></p>\n<p id=\"1.%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3%EF%BC%9A-toc\" style=\"margin-left:40px;\"><a href=\"#1.%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3%EF%BC%9A\">1.算法思想：</a></p>\n<p id=\"2.%E6%B3%A8%E6%84%8F%EF%BC%9A-toc\" style=\"margin-left:40px;\"><a href=\"#2.%E6%B3%A8%E6%84%8F%EF%BC%9A\">2.注意：</a></p>\n<p id=\"3.%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A-toc\" style=\"margin-left:40px;\"><a href=\"#3.%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A\">3.算法分析：</a></p>\n<p id=\"4.%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81%EF%BC%9A-toc\" style=\"margin-left:40px;\"><a href=\"#4.%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81%EF%BC%9A\">4.核心代码：</a></p>\n<p id=\"5.%E4%BE%8B%E9%A2%98%EF%BC%9AP3371%20%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%EF%BC%88%E5%BC%B1%E5%8C%96%E7%89%88%EF%BC%89%20-%20%E6%B4%9B%E8%B0%B7%20%7C%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E6%95%99%E8%82%B2%E6%96%B0%E7%94%9F%E6%80%81%20(luogu.com.cn)-toc\" style=\"margin-left:40px;\"><a href=\"#5.%E4%BE%8B%E9%A2%98%EF%BC%9AP3371%20%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%EF%BC%88%E5%BC%B1%E5%8C%96%E7%89%88%EF%BC%89%20-%20%E6%B4%9B%E8%B0%B7%20%7C%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E6%95%99%E8%82%B2%E6%96%B0%E7%94%9F%E6%80%81%20%28luogu.com.cn%29\">5.例题：</a></p>\n<p id=\"%C2%A0%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90%EF%BC%9A-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A0%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90%EF%BC%9A\"> 题目分析：</a></p>\n<p id=\"%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%EF%BC%9A-toc\" style=\"margin-left:80px;\"><a href=\"#%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%EF%BC%9A\">代码如下：</a></p>\n<p id=\"%E6%80%BB%E7%BB%93%EF%BC%9A-toc\" style=\"margin-left:0px;\"><a href=\"#%E6%80%BB%E7%BB%93%EF%BC%9A\">5.总结：</a></p>\n<p><span style=\"color:#956fe7;\"><strong>那让我为大家介绍这四种算法吧！</strong></span></p>\n<h1 id=\"%C2%A01.DFS%EF%BC%88%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95%EF%BC%89\"> <span style=\"color:#0d0016;\">1.DFS（单源最短路径算法）</span></h1>\n<h2 id=\"%E4%BE%8B%E9%A2%981%EF%BC%9A\"><strong><span style=\"color:#0d0016;\">例题1：</span></strong></h2>\n<blockquote>\n<p><span style=\"color:#0d0016;\">        建立一个有向图，n代表城市个数，有m行连接数据，x代表连接初始点，y代表连接点，r代表线权。求城市1到城市5的最短路径。</span></p>\n</blockquote>\n<p><img alt=\"\" height=\"328\" src=\"image\\2461dc7f80a74f1ab39bd09dfed6a054.png\" width=\"662\"/></p>\n<p></p>\n<p><strong>输入：</strong></p>\n<pre><code class=\"language-cpp\">5 8\n1 2 2\n2 3 3\n3 4 4\n4 5 5\n5 3 3\n1 5 10\n3 1 4\n2 5 7</code></pre>\n<p><strong>输出：</strong></p>\n<pre><code>9</code></pre>\n<blockquote>\n<h2 id=\"%C2%A0DFS%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90%EF%BC%9A\"><strong> DFS题目分析</strong>：</h2>\n<p>        用dfs进行搜索的话，递归的出口是什么？-&gt;</p>\n<p>        当然是扫描到最后一个城市的时候，然后记录下此时的路径值，如果之后搜索的测试值比之前的值小，则更新路径的值，搜索完所有的路径后，输出<strong>最小值</strong>，其中用<strong>VIS数组</strong>进行标记和回溯。</p>\n</blockquote>\n<h3 id=\"%E4%BB%A3%E7%A0%81DFS%EF%BC%9A\"><strong>代码DFS：</strong></h3>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\nusing namespace std;\n//从城市1到城市5最短路径为多少？\nint mp[105][105];//图\nint vis[105];//测试数组\nint x, y, r;\nint n; int m;\nint minx = 1000000;\nvoid dfs(int step, int sum) {\n\tif (sum &gt; minx) {\n\t\treturn;\n\t}\n\tif (step == n) {//当扫描到最后一个城市时\t\t\n\t\tif(sum&lt;minx){\n\t\t\tminx = sum;//更新\n\t\t\treturn;\n\t\t}\n\t}\n\tfor (int i = 1; i &lt;=n; i++) {\n\t\tif (mp[step][i] != 0 &amp;&amp;vis[i]==0) {//该点没有被标记，且该点存在连接\n\t\t\tvis[i] = 1;\n\t\t\tdfs(i, sum + mp[step][i]);\n\t\t\tvis[i] = 0;\n\t\t}\n\t}\n}\nint main()\n{\n\tcin &gt;&gt; n&gt;&gt;m;\n\twhile (m--) {\n\t\tcin &gt;&gt; x &gt;&gt; y &gt;&gt; r;\n\t\tmp[x][y] = r;//该图为有向图，是由x到y的距离\n\t}\n\tdfs(1, 0);\n\tcout &lt;&lt; minx &lt;&lt; endl;\n}</code></pre>\n<h1 id=\"%C2%A02.Floyed%EF%BC%88%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6On%5E3%EF%BC%89\"> 2<span style=\"color:#0d0016;\">.Floyed（时间复杂度On^3）</span></h1>\n<h2 id=\"1.%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A\"><span style=\"color:#0d0016;\"><strong>1.应用场景</strong>：</span></h2>\n<p><span style=\"color:#0d0016;\">1.多源最短路径。（缺点：时间复杂度相对较高，但是可以解决负权边问题）</span></p>\n<p><span style=\"color:#0d0016;\">2.找最小环。</span></p>\n<p><span style=\"color:#0d0016;\">3.倍增。</span></p>\n<h2 id=\"2.%E8%A7%A3%E6%9E%90%E7%AE%97%E6%B3%95%EF%BC%9A%C2%A0%20%C2%A0%C2%A0\"><span style=\"color:#0d0016;\">2.解析算法：    </span></h2>\n<p><span style=\"color:#0d0016;\">        通过插入点和中转点来缩短路径，先将图中各点连线都初始化为无穷，再进行建图，中转所有的点，不断更新最小值输出：</span></p>\n<h3 id=\"%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%811%EF%BC%9A\"><span style=\"color:#0d0016;\">核心代码1：</span></h3>\n<pre><code class=\"language-cpp\"> for (int k = 1; k &lt;= n; k++) {//从1到n依次各点进行中转\n        for (int i = 1; i &lt;= n; i++) {\n            for (int j = 1; j &lt;= n; j++) {\n                if (e[i][j] &gt; e[i][k] + e[k][j]) {//如果该路径更短，更新成该路径\n                    e[i][j] = e[i][k] + e[k][j];\n                }\n            }\n        }\n    }</code></pre>\n<h3 id=\"%E6%88%91%E7%9A%84%E7%AC%94%E8%AE%B0\"><strong>我的笔记</strong></h3>\n<p>然后就是<strong>我的笔记</strong>啦：（还是比较详细的）</p>\n<p><img alt=\"\" height=\"894\" src=\"image\\8225ea37ee5847a085d5ec79d8b968d0.png\" width=\"613\"/></p>\n<p>         这里由不得思考一个问题，Floyd算法无非就是动态规划，<span style=\"color:#fe2c24;\"><strong>状态转移方程</strong></span>为<img alt=\"e[i][j]=max(e[i][j],e[i][k]+e[k][j])\" class=\"mathcode\" src=\"https://latex.codecogs.com/gif.latex?e%5Bi%5D%5Bj%5D%3Dmax%28e%5Bi%5D%5Bj%5D%2Ce%5Bi%5D%5Bk%5D&amp;plus;e%5Bk%5D%5Bj%5D%29\"/></p>\n<h3 id=\"%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%812%EF%BC%9A\">核心代码2：</h3>\n<pre><code class=\"language-cpp\">void floyed(){\n    for (int k = 1; k &lt;= n; k++) {//从1到n依次各点进行中转\n        for (int i = 1; i &lt;= n; i++) {\n            for (int j = 1; j &lt;= n; j++) {\n                if (e[i][j] &gt; e[i][k] + e[k][j]) {//如果该路径更短，更新成该路径\n                    e[i][j] = max(e[i][j],e[i][k] + e[k][j]);\n                }\n            }\n        }\n    }\n}</code></pre>\n<h3 id=\"%C2%A0Floyd%E4%BE%8B%E9%A2%98%EF%BC%9AAcWing%20854%20Floyd%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF\"> Floyd例题：</h3>\n<p><strong>AcWing 854 Floyd求最短路</strong></p>\n<p>题目描述：</p>\n<p>给定一个n个点m条边的有向图，图中可能存在重边和自环，边权可能为负数。</p>\n<p>再给定k个询问，每个询问包含两个整数x和y，表示查询从点x到点y的最短距离，如果路径不存在，则输出“impossible”。</p>\n<p>数据保证图中<strong>不存在负权回路</strong>。</p>\n<p><strong>输入格式</strong></p>\n<p>第一行包含三个整数n，m，k</p>\n<p>接下来m行，每行包含三个整数x，y，z，表示点x和点y之间存在一条有向边，边长为z。</p>\n<p>接下来k行，每行包含两个整数x，y，表示询问点x到点y的最短距离。</p>\n<p>输出格式</p>\n<p>共k行，每行输出一个整数，表示询问的结果（<strong>最小路径</strong>），若询问两点间不存在路径，则输出“impossible”。</p>\n<p><strong>数据范围</strong></p>\n<p>1≤n≤200,<br/> 1≤k≤n^2<br/> 1≤m≤20000,<br/> 图中涉及边长绝对值均不超过10000。</p>\n<p><strong>输入：</strong></p>\n<pre><code>3 3 2\n1 2 1\n2 3 2\n1 3 1\n2 1\n1 3</code></pre>\n<p><strong>输出：</strong></p>\n<pre><code class=\"language-cpp\">impossible\n1</code></pre>\n<p><strong>题目注意：</strong></p>\n<p>1.初始图矩阵的建立。</p>\n<p>2.如果有重复的边如何处理。</p>\n<p>3.输出的时候如何判断x，y没有路径。</p>\n<p><strong>代码如下：</strong></p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nconst int INF = 1e9;\nint n, m, k;\nint x, y, r;\nint e[300][300];\nvoid floyed() {\n    for (int k = 1; k &lt;= n; k++) {//从1到n依次各点进行中转\n        for (int i = 1; i &lt;= n; i++) {\n            for (int j = 1; j &lt;= n; j++) {\n                if (e[i][j] &gt; e[i][k] + e[k][j]) {//如果该路径更短，更新成该路径\n                    e[i][j] = max(e[i][j], e[i][k] + e[k][j]);\n                }\n            }\n        }\n    }\n}\nint main()\n{\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;\n    for (int i = 1; i &lt;= n; i++) {//建立初始的图，赋值\n        for (int j = 1; j &lt;= n; j++) {\n            if (i == j) {\n                e[i][j] = 0;\n            }\n            else {\n                e[i][j] = INF;\n            }\n        }\n    }\n    while (m--) {\n        cin &gt;&gt; x &gt;&gt; y &gt;&gt; r;\n        e[x][y] = min(e[x][y], r);//处理重复边的值\n    }\n    floyed();\n    while(k--)\n    {\n        cin &gt;&gt; x &gt;&gt; y;\n        if (e[x][y] &gt; INF / 2) {//说明x到y没有路可以走\n            cout &lt;&lt; \"impossible\" &lt;&lt; endl;\n        }\n        else {\n            cout &lt;&lt; e[x][y] &lt;&lt; endl;//输出最短路径\n        }\n    }\n}\n</code></pre>\n<p>         今天的分享暂时先到这里，明天持续更新.....</p>\n<h1 id=\"3.Dijksyta%E7%AE%97%E6%B3%95\">3.Dijksyta算法</h1>\n<h2 id=\"1.%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A%E5%8D%95%E6%BA%90%E8%B7%AF%E5%BE%84%E6%9C%80%E7%9F%AD%EF%BC%88%E6%88%91%E5%8F%AA%E7%9C%8B%E5%87%BA%E6%9D%A5%E4%BA%86%E8%BF%99%E7%A7%8D%EF%BC%89%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6(On%5E2)\">1.应用场景：</h2>\n<p><strong>单源路径最短（<s>我只看出来了这种</s>）时间复杂度(On^2)</strong></p>\n<p><strong>注意</strong>：不能求<span style=\"color:#fe2c24;\"><strong>负权值</strong></span>.</p>\n<h2 id=\"2.%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0%EF%BC%9A\">2.算法描述：</h2>\n<p>设起点为x，dis[v]表示s到v的最短路径</p>\n<h3 id=\"1.%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9A\"><strong>1.初始化</strong>：</h3>\n<p><strong><span style=\"color:#fe2c24;\">起点初始化为0。其余点初始化为无穷大</span></strong></p>\n<h3 id=\"2.for%EF%BC%9A\"><strong>2.for：</strong></h3>\n<p>a.在没有访问的顶点中找到一个顶点u，使得dis[u]是最小的。（不断搜索到下一个路径最小的点，更新）。</p>\n<p>b.u为已确定的最短路径（将不再对该点及之前的点进行搜索）。</p>\n<h3 id=\"%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81%EF%BC%9A\">核心代码：</h3>\n<pre><code class=\"language-cpp\">int dijkstra(int n, int m) {//n为顶点数，m为起点开始的位置   \n    while (true) {\n        fill(dis, dis + maxn, INF);\n        dis[m] = 0;//初始化起点为0\n        int index = -1;\n        int minx = 0;//定义\n        for (int i = 1; i &lt;= n; i++) {\n            if (!vis[i] &amp;&amp; minx &gt; dis[i]) {//寻找到该点\n                index = i;\n                minx = dis[i];\n            }\n        }\n        if (index == -1) {//说明没有点可以继续搜索了\n            break;//退出循环条件\n        }\n        vis[index] = 1;//已经确定该点为最短路径点了，标记上踢出\n        for (int j = 1; j &lt;= n; j++) {\n            if (dis[j] &gt; dis[index] + mp[index][j]&amp;&amp;vis[j]==0&amp;&amp;mp[index][j]!=INF) {//该点有路可以走\n                dis[j] = dis[index] + mp[index][j];//值得思考有DP思想\n            }\n        }\n    }\n}</code></pre>\n<h2 id=\"3.%E4%BE%8B%E9%A2%98%EF%BC%9A%EF%BC%88%E6%94%B9%E9%A2%98%E7%9B%AE%E6%9D%A5%E6%BA%90%E4%BA%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%EF%BC%89\"><strong>3.例题：</strong></h2>\n<p><strong>（改题目来源于算法笔记）</strong></p>\n<p><img alt=\"\" height=\"522\" src=\"image\\6f89ffe4a1dd4b7487faa4f8c76860cd.png\" width=\"578\"/></p>\n<p><strong>题目要求</strong>：求V0到其他位置s的最短路径。</p>\n<p><strong>输入格式</strong>：</p>\n<p>n为有几个顶点，m为几条边，s为起点。</p>\n<p>第二行到第m+1行输入x,y,r，分别为x结点到y结点，边权为r。</p>\n<p><strong>输出格式：</strong>从s到个顶点的最短路径。</p>\n<p><strong>输入：</strong></p>\n<pre><code>6 8 0\n0 1 1\n0 3 4\n0 4 4\n1 3 2\n2 5 1\n3 2 2\n3 4 3\n4 5 3</code></pre>\n<p><strong>输出：</strong></p>\n<pre><code>0 1 5 3 4 6</code></pre>\n<p> <strong>题目分析</strong>： 不断去找路径最短的那个顶点，标记，搜索下一个最短顶点即可。（图示-&gt;）</p>\n<p><img alt=\"\" height=\"780\" src=\"image\\c336cd08fe20406c9c2fcf64ee60fafb.png\" width=\"348\"/></p>\n<h3 id=\"%C2%A0%E6%B3%A8%E6%84%8F%EF%BC%9A\"><strong> 注意：</strong></h3>\n<p>1.vis数组的标记。</p>\n<p>2.更新顶点，没有路径的点就不进行扫描。</p>\n<p>3.循环的终止条件。</p>\n<h3 id=\"%C2%A0%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%EF%BC%9A\"> 代码如下：</h3>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\nusing namespace std;\nconst int maxn = 1000;//规定一个最大顶点数\nconst int INF = 199999999;\nint n, m, s;\nint mp[maxn][maxn];\nint dis[maxn];\nbool vis[maxn] = { false };\nvoid Dijkstra(int s) {\n\tmemset(dis, 0x7f, sizeof(dis));\n\tdis[s] = 0;\n\tfor (int i = 1; i &lt;= n; i++) {//循环了n次\n\t\tint index = -1;\n\t\tint minx = INF;\n\t\tfor (int j = 0; j &lt; n; j++) {\n\t\t\tif (vis[j] == false &amp;&amp; dis[j] &lt; minx) {\n\t\t\t\tindex = j;//记录这个搜索到的路径最小的点。\n\t\t\t\tminx = dis[j];//更新最小值\n\t\t\t}\n\t\t}\n\t\tif (index == -1) {//没有路可以走了\n\t\t\treturn;\n\t\t}\n\t\tvis[index] = true;//标记该点\n\t\tfor (int i = 0; i &lt; n; i++) {\n\t\t\tif (vis[i] == false &amp;&amp; mp[index][i] != INF &amp;&amp; dis[index] + mp[index][i] &lt; dis[i]) {\n\t\t\t\tdis[i] = dis[index] + mp[index][i];//优化更新dis[i]\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tint x, y, r;\n\tcin &gt;&gt; n &gt;&gt; m &gt;&gt; s;\n\tmemset(mp, 0x7f, sizeof(mp));\n\tfor (int i = 1; i &lt;= m; i++) {\n\t\tcin &gt;&gt; x &gt;&gt; y &gt;&gt; r;\n\t\tmp[x][y] = r;\n\t}\n\tDijkstra(s);//将起点输入进去\n\tfor (int i = 0; i &lt; n; i++) {\n\t\tcout &lt;&lt; dis[i] &lt;&lt; \" \";\n\t}\n\treturn 0;\n}\n</code></pre>\n<p>      完美撒花！继续更新SPFA算法。  </p>\n<h1 id=\"4.SPFA%E7%AE%97%E6%B3%95\">4.SPFA算法</h1>\n<h2 id=\"1.%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3%EF%BC%9A\"><strong>1.算法思想：</strong></h2>\n<p><strong>队列优化，</strong>去掉一些无用的松弛操作，用队列来维护松弛造作的点。继承了<strong>Bellman-Ford算法</strong>的思想，但时间复杂度相对来说提高了很多。</p>\n<p>与BFS的算法有一些类似，利用了STL队列。</p>\n<h2 id=\"2.%E6%B3%A8%E6%84%8F%EF%BC%9A\"><strong>2.注意：</strong></h2>\n<p>虽然大多数情况spfa跑的比较快，但时间复杂度仍为（Onm），主要用应用于有负边权的情况（如果没有负边权，推荐使用<strong>Dijkstra</strong>算法）。利用了<span style=\"color:#fe2c24;\"><strong>邻接表建图</strong></span>，数据结构的基础一定要掌握好，而且该算法很容易超时，被卡，必须要谨慎选择该算法。</p>\n<h2 id=\"3.%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A\"><strong>3.算法分析：</strong></h2>\n<blockquote>\n<p>1.用<strong>dis数组</strong>记录点到有向图的任意一点距离，初始化起点距离为0，其余点均为INF，起点入队。</p>\n<p>2.判断该点是否存在。（未存在就入队，标记）</p>\n<p>3.队首出队，<strong>并将该点标记为没有访问过</strong>，方便下次入队。</p>\n<p>4.遍历以对首为起点的有向边（t,i）,如果<span style=\"color:#fe2c24;\"><strong>dis[i]&gt;dis[t]+w(t,i)</strong></span>,则更新dis[i]。</p>\n<p>5.如果i不在队列中，则入队标记，一直到循环为空。</p>\n</blockquote>\n<h2 id=\"4.%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81%EF%BC%9A\">4.核心代码：</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;queue&gt;\nusing namespace std;\nconst int INF = 1000000000;\nconst int maxn = 1000;\nint dis[maxn];//记录最小路径的数组\nbool vis[maxn];//标记\nstruct node {\n    int s1;//记录结点\n    int side;//边权\n};\nvector&lt;node&gt;mp[maxn];//用vector建立邻接表\nvoid Spfa(int s) {\n    queue&lt;int&gt;v;\n    vis[s] = 1; v.push(s); dis[s] = 0;\n    while (!v.empty()) {\n        int q = v.front();\n        v.pop(); vis[q] = 0;\n        for (int i = 0; i &lt; mp[q].size(); i++) {\n            if (dis[mp[q][i].s1] &gt; dis[q] + mp[q][i].side) {\n                dis[mp[q][i].s1] = dis[q] + mp[q][i].side;//更新最短路径。            \n                if (!vis[mp[q][i].s1]) {//是在更新新的值条件里面判断，一定特别注意这点\n                    v.push(mp[q][i].s1);\n                    vis[mp[q][i].s1] = 1;//标记未标记过的点\n                }\n            }\n        }\n    }\n}</code></pre>\n<p> 完美撒花！！！</p>\n<h2 id=\"5.%E4%BE%8B%E9%A2%98%EF%BC%9AP3371%20%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%EF%BC%88%E5%BC%B1%E5%8C%96%E7%89%88%EF%BC%89%20-%20%E6%B4%9B%E8%B0%B7%20%7C%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E6%95%99%E8%82%B2%E6%96%B0%E7%94%9F%E6%80%81%20(luogu.com.cn)\">5.例题：</h2>\n<p><a href=\"https://www.luogu.com.cn/problem/P3371\" title=\"P3371 【模板】单源最短路径（弱化版） - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\">P3371 【模板】单源最短路径（弱化版） - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>\n<p><strong>题目背景：</strong></p>\n<p>本题测试数据为随机数据，在考试中可能会出现构造数据让SPFA不通过（<s><strong><span style=\"color:#fe2c24;\">但本题可以用SPFA过</span></strong></s>），如有需要请移步 <a href=\"https://www.luogu.org/problemnew/show/P4779\" title=\"P4779\">P4779</a></p>\n<p><strong>题目描述：</strong></p>\n<p>如题，给出一个<span style=\"color:#fe2c24;\"><strong>有向图</strong></span>，请输出从某一点出发到所有点的最短路径长度。</p>\n<h2 id=\"%E2%80%8B\"><img alt=\"\" height=\"278\" src=\"image\\247be8c8773d480e8132c3c41ea53920.png\" width=\"942\"/></h2>\n<p><strong>输入输出样例：</strong></p>\n<p><strong>输入 ：</strong></p>\n<pre><code class=\"language-cpp\">4 6 1\n1 2 2\n2 3 2\n2 4 1\n1 3 5\n3 4 3\n1 4 4</code></pre>\n<p><strong>输出 ：</strong></p>\n<pre><code>0 2 4 3</code></pre>\n<p><img alt=\"\" height=\"329\" src=\"image\\c4b4e8418de546e387b444b8c86e1981.png\" width=\"991\"/><strong> 样例说明：</strong></p>\n<p class=\"img-center\"><img alt=\"\" height=\"422\" src=\"image\\4dae5efb65b67b0b87a40f5d41d387ad.png\" width=\"572\"/></p>\n<p>图片1到3和1到4的文字位置调换</p>\n<h3 id=\"%C2%A0%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90%EF%BC%9A\"><strong> 题目分析</strong>：</h3>\n<p>建立一个<strong>有向图</strong>，输出s到第i个结点的最短距离。（<strong><s><span style=\"color:#fe2c24;\">无疑是套刚刚那个模板</span></s></strong>）</p>\n<h3 id=\"%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%EF%BC%9A\"><strong>代码如下：</strong></h3>\n<pre><code class=\"language-cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn = 10001;\nconst long long INF = 2147483647;\nint dis[maxn];//记录最小路径的数组\nint vis[maxn];//标记\nint n, m, s;\nstruct node {\n    int s1;//记录结点\n    int side;//边权\n};\nvoid init() {\n    for (int i = 1; i &lt;= n; i++) {\n        dis[i] = INF;\n        vis[i] = 0;\n    }\n}\nvector&lt;node&gt;mp[maxn];//用vector建立邻接表\nvoid Spfa(int s) {\n    queue&lt;int&gt;v;   \n    vis[s] = 1; v.push(s); dis[s] = 0;\n    while (!v.empty()) {\n        int q = v.front();\n        v.pop(); vis[q] = 0;\n        for (int i = 0; i &lt; mp[q].size(); i++) {\n            if (dis[mp[q][i].s1] &gt; dis[q] + mp[q][i].side) {\n                dis[mp[q][i].s1] = dis[q] + mp[q][i].side;//更新最短路径。\n                if (vis[mp[q][i].s1]) {\n                    continue;//如果已经标记，则继续下一次循环\n                }\n                v.push(mp[q][i].s1);\n            }\n            \n        }\n    }\n}\nint main()\n{\n    int x, y, r;\n   \n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;\n    init();\n    while (m--) {\n        node h;\n        cin &gt;&gt; x &gt;&gt; y &gt;&gt; r;\n        h.s1 = y;//因为该图为有向图，记录指向的结点\n        h.side = r;//记录路径\n        mp[x].push_back(h);\n    }\n    Spfa(s);\n    for (int i = 1; i &lt;= n; i++) {        \n            cout &lt;&lt; dis[i] &lt;&lt; \" \";\n    }\n} \n</code></pre>\n<p>        于是我-&gt;<img alt=\"\" height=\"612\" src=\"image\\1198a793066d4add87080fb7048c250e.png\" width=\"1200\"/></p>\n<p>         AC了，那SPFA算法就到此结束了，总体来说注意细节，在数据较大时候谨慎使用.</p>\n<h1 id=\"%E6%80%BB%E7%BB%93%EF%BC%9A\">5.总结：</h1>\n<blockquote>\n<p>1.DFS，Dijkstra，SPFA主要解决<strong>单源最短路径</strong>。</p>\n<p>2.Floyed时间复杂度较高，但是可以解决多源最短路径。</p>\n<p>3.Dijkstra虽然效率比较高，但是<strong>无法解决负权值</strong>的问题。</p>\n<p>4.SPFA在数据较大的时候容易被卡，但更加有利于解决有负边权的情况，以及判断是否有负环。</p>\n<p>5.在图论中一定要掌握好<strong>邻接表和邻接矩阵</strong>的建立。</p>\n</blockquote>\n<p>         基础知识充分了解之后，就是形成知识网络练习的过程了，希望阅读该文章后能让自己以及读者在图论方面有更深刻得到理解。图，何止是图！！！</p>\n</div>\n</div>"}