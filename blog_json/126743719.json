{"blogid": "126743719", "writerAge": "码龄1年", "writerBlogNum": "463", "writerCollect": "214", "writerComment": "24", "writerFan": "7781", "writerGrade": "6级", "writerIntegral": "4764", "writerName": "web13985085406", "writerProfileAdress": "writer_image\\profile_126743719.jpg", "writerRankTotal": "3940", "writerRankWeekly": "937", "writerThumb": "49", "writerVisitNum": "187936", "blog_read_count": "14", "blog_time": "于 2022-09-07 13:20:59 发布", "blog_title": "jvm内存和线程信息查看", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p><strong>目录</strong></p>\n<p><a href=\"#1%E3%80%81%E9%80%9A%E8%BF%87jmap%E6%9F%A5%E7%9C%8B%E6%95%B4%E4%BD%93%E4%BF%A1%E6%81%AF%EF%BC%9Ajmap%20-heap%20%3Cpid%3E\">1、通过jmap查看整体信息：jmap -heap</a></p>\n<p><a href=\"#2%E3%80%81%E9%80%9A%E8%BF%87jstat%E6%9F%A5%E7%9C%8Bgc%E7%9A%84%E4%BF%A1%E6%81%AF%EF%BC%9Ajstat%20-gcutil%20%3Cpid%3E%3A%E7%BB%9F%E8%AE%A1gc%E4%BF%A1%E6%81%AF\">2、通过jstat查看gc的信息：jstat -gcutil :统计gc信息</a></p>\n<p><a href=\"#3%E3%80%81%E9%80%9A%E8%BF%87jmap%20%E5%AF%B9jvm%E4%BF%A1%E6%81%AF%E8%BF%9B%E8%A1%8Cdump%EF%BC%8C%E5%9C%A8MAP%E5%B7%A5%E5%85%B7%E4%B8%AD%E6%9F%A5%E7%9C%8B\">3、通过jmap 对jvm信息进行dump，在MAP工具中查看</a></p>\n<p><a href=\"#4%E3%80%81%E5%88%A9%E7%94%A8jstack%E6%9F%A5%E7%9C%8Bjvm%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%83%85%E5%86%B5\">4、利用jstack查看jvm线程的情况</a></p>\n<hr/>\n<h1><a id=\"1jmapjmap_heap_pid_14\"></a>1、通过jmap查看整体信息：jmap -heap </h1>\n<p>[root@localhost ~]# jmap -heap 27900</p>\n<p>Attaching to process ID 27900, please wait…</p>\n<p>Debugger attached successfully.</p>\n<p>Client compiler detected.</p>\n<p>JVM version is 20.45-b01</p>\n<p>using thread-local object allocation.</p>\n<p>Mark Sweep Compact GC</p>\n<p>Heap Configuration: #堆内存初始化配置</p>\n<p>MinHeapFreeRatio = 40 #-XX:MinHeapFreeRatio设置JVM堆最小空闲比率</p>\n<p>MaxHeapFreeRatio = 70 #-XX:MaxHeapFreeRatio设置JVM堆最大空闲比率</p>\n<p>MaxHeapSize = 100663296 (96.0MB) #-XX:MaxHeapSize=设置JVM堆的最大大小</p>\n<p>NewSize = 1048576 (1.0MB) #-XX:NewSize=设置JVM堆的‘新生代’的默认大小</p>\n<p>MaxNewSize = 4294901760 (4095.9375MB) #-XX:MaxNewSize=设置JVM堆的‘新生代’的最大大小</p>\n<p>OldSize = 4194304 (4.0MB) #-XX:OldSize=设置JVM堆的‘老生代’的大小</p>\n<p>NewRatio = 2 #-XX:NewRatio=:老年代/新生代的内存比值。默认的，新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2 ( 该值可以通过参数 –XX:NewRatio 来指定 )</p>\n<p>SurvivorRatio = 8 #-XX:SurvivorRatio=设置年轻代中Eden区与Survivor区的大小比值。即： Eden = 8/10 的新生代空间大小，from = to = 1/10 的新生代空间大小。</p>\n<p>PermSize = 12582912 (12.0MB) #-XX:PermSize=:设置JVM堆的‘持久代’的初始大小</p>\n<p>MaxPermSize = 67108864 (64.0MB) #-XX:MaxPermSize=:设置JVM堆的‘持久代’的最大大小</p>\n<p>Heap Usage:</p>\n<p><strong>New Generation (Eden + 1 Survivor Space): #新生代区内存分布，包含伊甸园区+1个Survivor区</strong></p>\n<p>capacity = 30212096 (28.8125MB)</p>\n<p>used = 27103784 (25.848182678222656MB)</p>\n<p>free = 3108312 (2.9643173217773438MB)</p>\n<p>89.71169693092462% used</p>\n<p><strong>Eden Space: #Eden区内存分布</strong></p>\n<p>capacity = 26869760 (25.625MB)</p>\n<p>used = 26869760 (25.625MB)</p>\n<p>free = 0 (0.0MB)</p>\n<p>100.0% used</p>\n<p><strong>From Space: #其中一个Survivor区的内存分布</strong></p>\n<p>capacity = 3342336 (3.1875MB)</p>\n<p>used = 234024 (0.22318267822265625MB)</p>\n<p>free = 3108312 (2.9643173217773438MB)</p>\n<p>7.001809512867647% used</p>\n<p><strong>To Space: #另一个Survivor区的内存分布</strong></p>\n<p>capacity = 3342336 (3.1875MB)</p>\n<p>used = 0 (0.0MB)</p>\n<p>free = 3342336 (3.1875MB)</p>\n<p>0.0% used</p>\n<p><strong>tenured generation: #当前的Old区内存分布</strong></p>\n<p>capacity = 67108864 (64.0MB)</p>\n<p>used = 67108816 (63.99995422363281MB)</p>\n<p>free = 48 (4.57763671875E-5MB)</p>\n<p>99.99992847442627% used</p>\n<p><strong>Perm Generation: #当前的 “持久代” 内存分布</strong></p>\n<p>capacity = 14417920 (13.75MB)</p>\n<p>used = 14339216 (13.674942016601562MB)</p>\n<p>free = 78704 (0.0750579833984375MB)</p>\n<p>99.45412375710227% used</p>\n<h1><a id=\"2jstatgcjstat_gcutil_pidgc_115\"></a>2、通过jstat查看gc的信息：jstat -gcutil :统计gc信息</h1>\n<p>显示列名</p>\n<p>具体描述</p>\n<p>S0</p>\n<p>年轻代中第一个survivor（幸存区）已使用的占当前容量百分比</p>\n<p>S1</p>\n<p>年轻代中第二个survivor（幸存区）已使用的占当前容量百分比</p>\n<p>E</p>\n<p>年轻代中Eden（伊甸园）已使用的占当前容量百分比</p>\n<p>O</p>\n<p>old代已使用的占当前容量百分比</p>\n<p>P</p>\n<p>perm代已使用的占当前容量百分比</p>\n<p>YGC</p>\n<p>从应用程序启动到采样时年轻代中gc次数</p>\n<p>YGCT</p>\n<p>从应用程序启动到采样时年轻代中gc所用时间(s)</p>\n<p>FGC</p>\n<p>从应用程序启动到采样时old代(全gc)gc次数</p>\n<p>FGCT</p>\n<p>从应用程序启动到采样时old代(全gc)gc所用时间(s)</p>\n<p>GCT</p>\n<p>从应用程序启动到采样时gc用的总时间(s)</p>\n<p>[@jsy19-117-143.localdomain ~]# jstat -gcutil 31257</p>\n<p>S0 S1 E O M CCS YGC YGCT FGC FGCT GCT</p>\n<p>0.00 100.00 20.62 2.48 95.12 92.45 8 0.237 2 0.633 0.871</p>\n<h1><a id=\"3jmap_jvmdumpMAP_168\"></a>3、通过jmap 对jvm信息进行dump，在MAP工具中查看</h1>\n<p>[@jsy19-117~]# jmap -dump:format=b,file=heap.bin 31257</p>\n<p>Dumping heap to /root/heap.bin …</p>\n<p>Heap dump file created</p>\n<p>[@jsy19-117-143.localdomain ~]# ll -h</p>\n<p>total 1.5G</p>\n<p>-rw------- 1 root root 1.5G Nov 3 18:10 heap.bin</p>\n<p>[@jsy19-117-143.localdomain ~]# sz heap.bin</p>\n<p>Starting zmodem transfer. Press Ctrl+C to cancel.</p>\n<p>Transferring heap.bin…</p>\n<p>100% 1485744 KB 9710 KB/sec 00:02:33 0 Errors</p>\n<p>然后利用MAP工具查看具体对象占用的内存情况</p>\n<h1><a id=\"4jstackjvm_193\"></a>4、利用jstack查看jvm线程的情况</h1>\n<p><strong>第一步先找出Java进程ID，我部署在服务器上的Java应用名称为mrf-center：</strong></p>\n<p>1</p>\n<p>root@ubuntu:/#ps-ef|grepmrf-center|grep-vgrep</p>\n<p>2</p>\n<p>root217111114:47pts/300:02:10java-jarmrf-center.jar</p>\n<p>得到进程ID为21711，</p>\n<p><strong>第二步找出该进程内最耗费CPU的线程，可以使用top -Hp pid，输出如下：</strong></p>\n<p><img alt=\"\" src=\"image\\2020110411394671.png\"/></p>\n<p>TIME列就是各个Java线程耗费的CPU时间，CPU时间最长的是线程ID为21742的线程，用时最长</p>\n<p>printf\"%x \"21742</p>\n<p>得到21742的十六进制值为54ee，下面会用到。</p>\n<p>OK，下一步终于轮到jstack上场了，它用来输出进程21711的堆栈信息，然后根据线程ID的十六进制值grep，如下：</p>\n<p><strong>root@ubuntu:/ # jstack21711|grep54ee</strong></p>\n<p>2</p>\n<p>\"PollIntervalRetrySchedulerThread\"prio=10tid=0x00007f950043e000nid=0x54eeinObject.wait()[0x00007f94c6eda000]</p>\n<p>可以看到CPU消耗在PollIntervalRetrySchedulerThread这个类的Object.wait()，我找了下我的代码，定位到下面的代码：</p>\n<p>getLog().info(“Thread [” + getName() + “] is idle waiting…”);</p>\n<p>schedulerThreadState = PollTaskSchedulerThreadState.IdleWaiting;</p>\n<p>long now = System.currentTimeMillis();</p>\n<p>long waitTime = now + getIdleWaitTime();</p>\n<p>long timeUntilContinue = waitTime - now;</p>\n<p>synchronized(sigLock) {<!-- --></p>\n<p>try {<!-- --></p>\n<p>if(!halted.get()) {<!-- --></p>\n<p>sigLock.wait(timeUntilContinue);</p>\n<p>}</p>\n<p>}</p>\n<p>catch (InterruptedException ignore) {<!-- --></p>\n<p>}</p>\n<p>}</p>\n<p>上面的sigLock.wait(timeUntilContinue)就对应了前面的Object.wait()。</p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}