{"blogid": "124173617", "writerAge": "码龄3年", "writerBlogNum": "28", "writerCollect": "78", "writerComment": "3", "writerFan": "3132", "writerGrade": "2级", "writerIntegral": "286", "writerName": "一只流氓的小菜鸟", "writerProfileAdress": "writer_image\\profile_124173617.jpg", "writerRankTotal": "79368", "writerRankWeekly": "2566", "writerThumb": "13", "writerVisitNum": "15649", "blog_read_count": "7756", "blog_time": "于 2022-04-14 15:41:44 发布", "blog_title": "动态代理实现原理", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h2>什么是动态代理</h2>\n<p>首先，动态代理是<code>代理模式</code>的一种实现方式，代理模式除了动态代理还有 <code>静态代理</code>，只不过静态代理能够在编译时期确定类的执行对象，而动态代理只有在运行时才能够确定执行对象是谁。代理可以看作是对最终调用目标的一个封装，<strong>我们能够通过操作代理对象来调用目标类，这样就可以实现调用者和目标对象的解耦合</strong>。</p>\n<p>动态代理的应用场景有很多，最常见的就是 <strong>AOP 的实现、RPC 远程调用、Java 注解对象获取、日志框架、全局性异常处理、事务处理等</strong>。</p>\n<p>动态代理的实现有很多，但是 JDK 动态代理是很重要的一种，下面我们就 JDK 动态代理来深入理解一波。</p>\n<h2>JDK 动态代理</h2>\n<p>首先我们先来看一下动态代理的执行过程</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\1b70ae1bedcbd7ff19c3b0c8b46fd7bd.png\"/></p>\n<p>在 JDK 动态代理中，实现了 <code>InvocationHandler</code> 的类可以看作是 <code>代理类</code>(因为类也是一种对象，所以我们上面为了描述关系，把代理类形容成了代理对象)。JDK 动态代理就是围绕实现了 InvocationHandler 的代理类进行的，比如下面就是一个 InvocationHandler 的实现类，同时它也是一个代理类。</p>\n<pre><code>public class UserHandler implements InvocationHandler {\n\n    private UserDao userDao;\n\n    public UserHandler(UserDao userDao){\n        this.userDao = userDao;\n    }\n\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        saveUserStart();\n        Object obj = method.invoke(userDao, args);\n        saveUserDone();\n        return obj;\n    }\n\n    public void saveUserStart(){\n        System.out.println(\"---- 开始插入 ----\");\n    }\n\n    public void saveUserDone(){\n        System.out.println(\"---- 插入完成 ----\");\n    }\n}\n</code></pre>\n<p>代理类一个最最最重要的方法就是 <code>invoke</code> 方法，它有三个参数</p>\n<ul><li> <p><code>Object proxy</code>: 动态代理对象，关于这个方法我们后面会说。</p> </li><li> <p><code>Method method</code>: 表示最终要执行的方法，method.invoke 用于执行被代理的方法，也就是真正的目标方法</p> </li><li> <p><code>Object[] args</code>: 这个参数就是向目标方法传递的参数。</p> </li></ul>\n<p>我们构造好了代理类，现在就要使用它来实现我们对目标对象的调用，那么如何操作呢？请看下面代码</p>\n<pre><code>public static void dynamicProxy(){\n\n  UserDao userDao = new UserDaoImpl();\n  InvocationHandler handler = new UserHandler(userDao);\n\n  ClassLoader loader = userDao.getClass().getClassLoader();\n  Class&lt;?&gt;[] interfaces = userDao.getClass().getInterfaces();\n\n  UserDao proxy = (UserDao)Proxy.newProxyInstance(loader, interfaces, handler);\n  proxy.saveUser();\n}\n</code></pre>\n<p>如果要用 JDK 动态代理的话，就需要知道<code>目标对象</code>的<strong>类加载器、目标对象的接口，当然还要知道目标对象是谁</strong>。构造完成后，我们就可以调用 <code>Proxy.newProxyInstance</code>方法，然后把类加载器、目标对象的接口、目标对象绑定上去就完事儿了。</p>\n<blockquote>\n<p>这里需要注意一下 <code>Proxy</code> 类，它就是动态代理实现所用到的代理类。</p>\n</blockquote>\n<p>Proxy 位于<code>java.lang.reflect</code> 包下，这同时也旁敲侧击的表明动态代理的本质就是<code>反射</code>。</p>\n<p>下面我们就围绕 JDK 动态代理，来深入理解一下它的原理，以及搞懂为什么动态代理的本质就是反射。</p>\n<h2>动态代理的实现原理</h2>\n<p>在了解动态代理的实现原理之前，我们先来了解一下 InvocationHandler 接口</p>\n<h3>InvocationHandler 接口</h3>\n<p>JavaDoc 告诉我们，InvocationHandler 是一个接口，实现这个接口的类就表示该类是一个代理实现类，也就是代理类。</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\78a8bb4323cb557d01bd81403bd06d2a.png\"/></p>\n<p>InvocationHandler 接口中只有一个 invoke 方法。</p>\n<p>动态代理的优势在于能够很方便的对代理类中方法进行集中处理，而不用修改每个被代理的方法。因为所有被代理的方法（真正执行的方法）都是通过在 InvocationHandler 中的 invoke 方法调用的。所以我们只需要对 invoke 方法进行集中处理。</p>\n<p>invoke 方法只有三个参数</p>\n<pre><code>public Object invoke(Object proxy, Method method, Object[] args)\n        throws Throwable;\n</code></pre>\n<ul><li> <p>proxy：代理对象</p> </li><li> <p>method: 代理对象调用的方法</p> </li><li> <p>args：调用方法中的参数。</p> </li></ul>\n<p>动态代理的整个代理过程不像静态代理那样一目了然，清晰易懂，因为在动态代理的过程中，我们没有看到代理类的真正代理过程，也不明白其具体操作，所以要分析动态代理的实现原理，我们必须借助<code>源码</code>。</p>\n<p>那么问题来了，首先第一步应该从哪分析？如果不知道如何分析的话，干脆就使用<code>倒推法</code>，从后往前找，我们直接先从 <em>Proxy.newProxyInstance</em>入手，看看是否能略知一二。</p>\n<h3>Proxy.newInstance 方法分析</h3>\n<p><strong>Proxy 提供了创建动态代理类和实例的静态方法，它也是由这些方法创建的所有动态代理类的超类</strong>。</p>\n<p>Proxy.newProxyInstance 源码（java.lang.reflect.Proxy）</p>\n<pre><code>public static Object newProxyInstance(ClassLoader loader,\n                                      Class&lt;?&gt;[] interfaces,\n                                      InvocationHandler h)\n  throws IllegalArgumentException\n{\n  Objects.requireNonNull(h);\n\n  final Class&lt;?&gt;[] intfs = interfaces.clone();\n  final SecurityManager sm = System.getSecurityManager();\n  if (sm != null) {\n    checkProxyAccess(Reflection.getCallerClass(), loader, intfs);\n  }\n\n  Class&lt;?&gt; cl = getProxyClass0(loader, intfs);\n\n  try {\n    if (sm != null) {\n      checkNewProxyPermission(Reflection.getCallerClass(), cl);\n    }\n\n    final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);\n    final InvocationHandler ih = h;\n    if (!Modifier.isPublic(cl.getModifiers())) {\n      AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {\n        public Void run() {\n          cons.setAccessible(true);\n          return null;\n        }\n      });\n    }\n    return cons.newInstance(new Object[]{h});\n  } catch (Exception e) {\n    ...\n}\n</code></pre>\n<p>乍一看起来有点麻烦，其实源码都是这样，看起来非常复杂，但是慢慢分析、厘清条理过后就好，最重要的是分析源码不能着急。</p>\n<p>上面这个 Proxy.newProxyInstsance 其实就做了下面几件事，我画了一个流程图作为参考。</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\5379840fcff7f591291aeff3d168b1fa.png\"/></p>\n<p>从上图中我们也可以看出，newProxyInstsance 方法最重要的几个环节就是获得代理类、获得构造器，然后构造新实例。</p>\n<p>对反射有一些了解的同学，应该会知道获得构造器和构造新实例是怎么回事。关于反射，可以参考笔者的这篇文章</p>\n<p>学会反射后，我被录取了！</p>\n<p>所以我们的重点就放在了<strong>获得代理类</strong>，这是最关键的一步，对应源码中的 <em>Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</em> 我们进入这个方法一探究竟</p>\n<pre><code>private static Class&lt;?&gt; getProxyClass0(ClassLoader loader,\n                                           Class&lt;?&gt;... interfaces) {\n  if (interfaces.length &gt; 65535) {\n    throw new IllegalArgumentException(\"interface limit exceeded\");\n  }\n  return proxyClassCache.get(loader, interfaces);\n}\n</code></pre>\n<p>这个方法比较简单，首先会直接判断接口长度是否大于 65535（刚开始看到这里我是有点不明白的，我心想这个判断是要判断什么？interfaces 这不是一个 class 类型吗，从 length 点进去也看不到这个属性，细看一下才明白，这居然是<em>可变参数</em>，<em>Class ...</em> 中的 ... 就是可变参数，所以这个判断我猜测应该是判断接口数量是否大于 65535。）</p>\n<p>然后会直接从 proxyClassCache 中根据 loader 和 interfaces 获取代理对象实例。<strong>如果能够根据 loader 和 interfaces 找到代理对象，将会返回缓存中的对象副本；否则，它将通过 ProxyClassFactory 创建代理类</strong>。</p>\n<p>proxyClassCache.get 就是一系列从缓存中的查询操作，注意这里的 proxyClassCache 其实是一个 <em>WeakCache</em>，WeakCahe 也是位于 java.lang.reflect 包下的一个缓存映射 map，它的主要特点是一个弱引用的 map，但是它内部有一个 SubKey ，这个子键却是强引用的。</p>\n<blockquote>\n<p>这里我们不用去追究这个 proxyClassCache 是如何进行缓存的，只需要知道它的缓存时机就可以了：即在类加载的时候进行缓存。</p>\n</blockquote>\n<p>如果无法找到代理对象，就会通过 ProxyClassFactory 创建代理，ProxyClassFactory 继承于 BiFunction</p>\n<pre><code>private static final class ProxyClassFactory\n        implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;\n    {...}\n</code></pre>\n<p>ProxyClassFactory 里面有两个属性一个方法。</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\a55355af5639cc55710090dafb77359c.png\"/></p>\n<ul><li> <p>proxyClassNamePrefix：这个属性表明使用 ProxyClassFactory 创建出来的代理实例的命名是以 \"$Proxy\" 为前缀的。</p> </li><li> <p>nextUniqueNumber：这个属性表明 ProxyClassFactory 的后缀是使用 AtomicLong 生成的数字</p> </li></ul>\n<p>所以代理实例的命名一般是 <em>、Proxy1</em>这种。</p>\n<p>这个 apply 方法是一个<strong>根据接口和类加载器进行代理实例创建的工厂方法</strong>，下面是这段代码的核心。</p>\n<pre><code>@Override\npublic Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) {\n\n  ...\n    \n  long num = nextUniqueNumber.getAndIncrement();\n  String proxyName = proxyPkg + proxyClassNamePrefix + num;\n\n  byte[] proxyClassFile = ProxyGenerator.generateProxyClass(\n    proxyName, interfaces, accessFlags);\n  try {\n    return defineClass0(loader, proxyName,\n                        proxyClassFile, 0, proxyClassFile.length);\n  } catch (ClassFormatError e) {\n    throw new IllegalArgumentException(e.toString());\n  }\n}\n</code></pre>\n<p>可以看到，代理实例的命名就是我们上面所描述的那种命名方式，只不过它这里加上了 <em>proxyPkg</em> 包名的路径。然后下面就是生成代理实例的关键代码。</p>\n<p>ProxyGenerator.generateProxyClass 我们跟进去是只能看到 .class 文件的，class 文件是虚拟机编译之后的结果，所以我们要看一下 .java 文件源码。.java 源码位于 <em>OpenJDK</em>中的 sun.misc 包中的 ProxyGenerator 下。</p>\n<p>此类的 generateProxyClass() 静态方法的核心内容就是去调用 generateClassFile() 实例方法来生成 Class 文件。方法太长了我们不贴了，这里就大致解释以下其作用：</p>\n<ul><li> <p>第一步：收集所有要生成的代理方法，将其包装成 ProxyMethod 对象并注册到 Map 集合中。</p> </li><li> <p>第二步：收集所有要为 Class 文件生成的字段信息和方法信息。</p> </li><li> <p>第三步：完成了上面的工作后，开始组装 Class 文件。</p> </li></ul>\n<p>而 defineClass0 这个方法我们点进去是 native ，底层是 C/C++ 实现的，于是我又去看了一下 C/C++ 源码，路径在</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\1f21b85ab717f821005c9cc8562d52a4.png\"/></p>\n<p>点开之后的 C/C++ 源码还是挺让人绝望的。</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\b7baa9bcca52187052d98f4493b051dc.png\"/></p>\n<p>不过我们再回头看一下这个 defineClass0 方法，它实际上就是根据上面生成的 proxyClassFile 字节数组来生成对应的实例罢了，所以我们不必再深究 C/C++ 对于代理对象的合成过程了。</p>\n<p>所以总结一下可以看出，JDK 为我们的生成了一个叫 $Proxy0 的代理类，这个类文件放在内存中的，我们在创建代理对象时，就是通过反射获得这个类的构造方法，然后创建的代理实例。</p>\n<p>所以最开始的 dynamicProxy 方法我们反编译后的代码就是这样的</p>\n<pre><code>public final class $Proxy0 extends java.lang.reflect.Proxy implements com.cxuan.dynamic.UserDao {\n  public $Proxy0(java.lang.reflect.InvocationHandler) throws ;\n    Code:\n       0: aload_0\n       1: aload_1\n       2: invokespecial #8                  // Method java/lang/reflect/Proxy.\"&lt;init&gt;\":(Ljava/lang/reflect/InvocationHandler;)V\n       5: return\n</code></pre>\n<p>我们看到代理类继承了 Proxy 类，所以也就决定了 Java 动态代理只能对接口进行代理。</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\265110a8724f4803c61fb6f2a5e33096.png\"/></p>\n<p>于是，上面这个图你应该就可以看懂了。</p>\n<h2>invoke 方法中第一个参数 proxy 的作用</h2>\n<p>细心的小伙伴们可能都发现了，invoke 方法中第一个 proxy 的作用是啥？代码里面好像 proxy 也没用到啊，这个参数的意义是啥呢？它运行时的类型是啥啊？为什么不使用 this 代替呢？</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\b624be6c6a67104e88adda13c9b7d8c5.png\"/></p>\n<p>Stackoverflow 给出了我们一个回答 https://stackoverflow.com/questions/22930195/understanding-proxy-arguments-of-the-invoke-method-of-java-lang-reflect-invoca</p>\n<p>什么意思呢？</p>\n<p>就是说这个 proxy ，它是真正的代理对象，invoke 方法可以返回调用代理对象方法的返回结果，也可以返回对象的真实代理对象，也就是 $Proxy0，这也是它运行时的类型。</p>\n<p>至于为什么不用 this 来代替 proxy，因为实现了 InvocationHandler 的对象中的 this ，指代的还是 InvocationHandler 接口实现类本身，而不是真实的代理对象。</p>\n</div>\n</div>"}