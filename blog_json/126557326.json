{"blogid": "126557326", "writerAge": "码龄21天", "writerBlogNum": "189", "writerCollect": "181", "writerComment": "17", "writerFan": "287", "writerGrade": "5级", "writerIntegral": "1947", "writerName": "π大星的日常", "writerProfileAdress": "writer_image\\profile_126557326.jpg", "writerRankTotal": "11335", "writerRankWeekly": "1018", "writerThumb": "31", "writerVisitNum": "21655", "blog_read_count": "3065", "blog_time": "于 2022-08-27 13:52:20 发布", "blog_title": "MySQL select count(*)计数很慢，有没有优化方案？", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>在日常开发工作中，我经常会遇到需要统计总数的场景，比如：统计订单总数、统计用户总数等。一般我们会使用MySQL 的count函数进行统计，但是随着数据量逐渐增大，统计耗时也越来越长，最后竟然出现慢查询的情况，这究竟是什么原因呢？本篇文章带你一下学习一下。</p>\n<h2>1. MyISAM存储引擎计数为什么这么快？</h2>\n<p>我们总有个错觉，就是感觉MyISAM引擎的<strong>count</strong>计数要比InnoDB引擎更快，实际这不是错觉。</p>\n<p>MyISAM引擎把表的总行数单独记录在磁盘上，查询的时候可以直接返回，不需要再累加统计。</p>\n<p>但是当SQL查询中有where条件的时候，就无法再使用表的总行数了，还是需要乖乖的进行累加统计，查询性能也就跟InnoDB相差无几了。</p>\n<p>为什么MyISAM引擎能够记录表的总行数，InnoDB引擎却不行？</p>\n<p>因为MyISAM引擎不支持事务，只有表锁，所以记录的总行数是准确的。</p>\n<p>而InnoDB引擎支持事务和行锁，存在并发修改的情况。又由于事务的隔离性，会出现不可重复读和幻读，记录的总行数无法保证是准确的。</p>\n<h2>2. 能不能手动实现统计总行数</h2>\n<p>既然InnoDB引擎没有帮我们记录总行数，我们能不能手动记录总行数，比如使用Redis。</p>\n<p>其实也是不行的，使用Redis记录总行数，至少有下面3个问题：</p>\n<ol><li>无法实现事务之间的隔离</li><li>更新丢失，因为i++不是原子操作，当然可以使用Lua脚本实现原子操作，更复杂。</li><li>Redis是非关系型缓存数据库，不能当作关系型持久化数据库使用，一般需要设置过期时间。</li></ol>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/5c9d3b3d28ea0b05323a84e1d383d8cc.webp?x-oss-process=image/format,png\"/></p>\n<p>由上图中得知，虽然Redis计数加1操作放在了事务里面，但是不受事务控制的，在事务没有提交前，其他查询依然读到了最新的总行数，这就是脏读的情况。</p>\n<h2>3. InnoDB引擎能否实现快速计数</h2>\n<p>有一种办法，可以粗略估计表的总行数，就是使用MySQL命令：</p>\n<pre><code>show table status like 'user';\n复制代码</code></pre>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/d988115ebdda8a84b0286dd6fdbddfff.webp?x-oss-process=image/format,png\"/></p>\n<p>真实的总行数有100万行，预估有99万多行，误差在可接受的范围内。</p>\n<p>部分场景适用，比如粗略估计网站的总用户数。</p>\n<h2>4. 四种计数方式的性能差别</h2>\n<p>常见的统计总行数的方式有以下四种：</p>\n<p><strong>count(*) 、 count(常量) 、 count(id) 、 count(字段)</strong></p>\n<p>InnoDB引擎对<strong>count</strong>计数做了优化，会选用数据量较小的非聚簇索引进行统计。</p>\n<p>比如用户表中有三个索引，分别是<strong>主键索引</strong>、<strong>name</strong>索引和<strong>age</strong>索引，使用执行计划查看计数的时候用到了哪个索引？</p>\n<pre><code>CREATE TABLE `user` (\n  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键',\n  `name` varchar(100) DEFAULT NULL COMMENT '姓名',\n  `age` tinyint NOT NULL,\n  PRIMARY KEY (`id`),\n  KEY `idx_name` (`name`),\n  KEY `idx_age` (`age`)\n) ENGINE=InnoDB COMMENT='用户表';\n复制代码</code></pre>\n<pre><code>explain select count(*) from user;\n复制代码</code></pre>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/febdbd23f529f40ad47a4ad10428174d.webp?x-oss-process=image/format,png\"/></p>\n<p>用到了数据量较小的<strong>age</strong>索引。</p>\n<p>count(*) 、 count(常量) 是直接统计表中的总行数，效率较高。</p>\n<p>而 count(id) 还需要把数据返回给MySQL Server端进行累加计数。</p>\n<p>最后 count(字段)需要筛选不为null字段，效率最差。</p>\n<p>四种计数的查询性能从高到低，依次是：</p>\n<blockquote>\n<p>count(*) ≈ count(常量) &gt; count(id) &gt; count(字段)</p>\n</blockquote>\n<p>对于大多数情况，得到计数结果，还是老老实实使用count(*)</p>\n<p>所以推荐使用<strong>select count(*)</strong> ，别跟<strong>select *</strong> 搞混了，不推荐使用<strong>select *</strong> 的。</p>\n</div>\n</div>"}