{"blogid": "126445229", "writerAge": "码龄2年", "writerBlogNum": "145", "writerCollect": "179", "writerComment": "168", "writerFan": "81", "writerGrade": "5级", "writerIntegral": "1940", "writerName": "Pandaconda", "writerProfileAdress": "writer_image\\profile_126445229.jpg", "writerRankTotal": "11275", "writerRankWeekly": "717", "writerThumb": "192", "writerVisitNum": "22660", "blog_read_count": "287", "blog_time": "已于 2022-08-25 11:39:10 修改", "blog_title": "【C++专栏】手撕数据结构与算法", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<blockquote>\n<p>写在前面：<br/> 在这个专栏，我将带着大家一起用 C++ 手撕基础的数据结构与算法，每一讲都有详细的讲解，24 篇文章将近 400 张图，希望能够带领大家快速入门这个课程。数据结构与算法是大学计算机专业课中最重要的一门，学起来必然不轻松，所以遇到困难是非常正常的一件事。相信我，只要能够坚持下去，自己动手敲一遍一定会有不少的收获！</p>\n</blockquote>\n<h1><a id=\"C_3\"></a>C++实现线性表</h1>\n<table><thead><tr><th>专题</th><th>博客地址</th></tr></thead><tbody><tr><td>数组</td><td><a href=\"https://blog.csdn.net/Newin2020/article/details/122926747\">https://blog.csdn.net/Newin2020/article/details/122926747</a></td></tr><tr><td>单向链表</td><td><a href=\"https://blog.csdn.net/Newin2020/article/details/123168450\">https://blog.csdn.net/Newin2020/article/details/123168450</a></td></tr><tr><td>双向循环链表</td><td><a href=\"https://blog.csdn.net/Newin2020/article/details/123189738\">https://blog.csdn.net/Newin2020/article/details/123189738</a></td></tr><tr><td>栈</td><td><a href=\"https://blog.csdn.net/Newin2020/article/details/123209037\">https://blog.csdn.net/Newin2020/article/details/123209037</a></td></tr><tr><td>队列（数组实现）</td><td><a href=\"https://blog.csdn.net/Newin2020/article/details/123722941\">https://blog.csdn.net/Newin2020/article/details/123722941</a></td></tr><tr><td>队列（链表实现）</td><td><a href=\"https://blog.csdn.net/Newin2020/article/details/124179297\">https://blog.csdn.net/Newin2020/article/details/124179297</a></td></tr></tbody></table>\n<h1><a id=\"C_13\"></a>C++实现树</h1>\n<table><thead><tr><th>专题</th><th>博客地址</th></tr></thead><tbody><tr><td>树的三种表示法</td><td><a href=\"https://blog.csdn.net/Newin2020/article/details/124183544\">https://blog.csdn.net/Newin2020/article/details/124183544</a></td></tr><tr><td>二叉树</td><td><a href=\"https://blog.csdn.net/Newin2020/article/details/124544636\">https://blog.csdn.net/Newin2020/article/details/124544636</a></td></tr><tr><td>二叉排序树</td><td><a href=\"https://blog.csdn.net/Newin2020/article/details/124595142\">https://blog.csdn.net/Newin2020/article/details/124595142</a></td></tr><tr><td>二叉树的构建（数组）</td><td><a href=\"https://blog.csdn.net/Newin2020/article/details/124672557\">https://blog.csdn.net/Newin2020/article/details/124672557</a></td></tr><tr><td>线索二叉树</td><td><a href=\"https://blog.csdn.net/Newin2020/article/details/124637090\">https://blog.csdn.net/Newin2020/article/details/124637090</a></td></tr><tr><td>哈夫曼树编码</td><td><a href=\"https://blog.csdn.net/Newin2020/article/details/124804709\">https://blog.csdn.net/Newin2020/article/details/124804709</a></td></tr><tr><td>平衡二叉树</td><td><a href=\"https://blog.csdn.net/Newin2020/article/details/124996861\">https://blog.csdn.net/Newin2020/article/details/124996861</a></td></tr><tr><td>并查集</td><td><a href=\"https://blog.csdn.net/Newin2020/article/details/125123996\">https://blog.csdn.net/Newin2020/article/details/125123996</a></td></tr></tbody></table>\n<h1><a id=\"C_25\"></a>C++实现图</h1>\n<table><thead><tr><th>专题</th><th>博客地址</th></tr></thead><tbody><tr><td>图的概述及实现</td><td><a href=\"https://blog.csdn.net/Newin2020/article/details/124826974\">https://blog.csdn.net/Newin2020/article/details/124826974</a></td></tr><tr><td>图的遍历（DFS、BFS）</td><td><a href=\"https://blog.csdn.net/Newin2020/article/details/125087927\">https://blog.csdn.net/Newin2020/article/details/125087927</a></td></tr><tr><td>最小生成树</td><td><a href=\"https://blog.csdn.net/Newin2020/article/details/125123616\">https://blog.csdn.net/Newin2020/article/details/125123616</a></td></tr><tr><td>最短路径</td><td><a href=\"https://blog.csdn.net/Newin2020/article/details/125151787\">https://blog.csdn.net/Newin2020/article/details/125151787</a></td></tr><tr><td>拓扑排序</td><td><a href=\"https://blog.csdn.net/Newin2020/article/details/125378088\">https://blog.csdn.net/Newin2020/article/details/125378088</a></td></tr><tr><td>关键路径</td><td><a href=\"https://blog.csdn.net/Newin2020/article/details/125396615\">https://blog.csdn.net/Newin2020/article/details/125396615</a></td></tr></tbody></table>\n<h1><a id=\"C_35\"></a>C++实现查找</h1>\n<table><thead><tr><th>专题</th><th>博客地址</th></tr></thead><tbody><tr><td>顺序、二分和哈希查找</td><td><a href=\"https://blog.csdn.net/Newin2020/article/details/125490906\">https://blog.csdn.net/Newin2020/article/details/125490906</a></td></tr></tbody></table>\n<h1><a id=\"C_40\"></a>C++实现排序</h1>\n<table><thead><tr><th>专题</th><th>博客地址</th></tr></thead><tbody><tr><td>冒泡、选择、插入和希尔排序</td><td><a href=\"https://blog.csdn.net/Newin2020/article/details/125493741\">https://blog.csdn.net/Newin2020/article/details/125493741</a></td></tr><tr><td>归并排序、快速排序和堆排序</td><td><a href=\"https://blog.csdn.net/Newin2020/article/details/125497952\">https://blog.csdn.net/Newin2020/article/details/125497952</a></td></tr><tr><td>计数排序、桶排序和基数排序</td><td><a href=\"https://blog.csdn.net/Newin2020/article/details/125501274\">https://blog.csdn.net/Newin2020/article/details/125501274</a></td></tr></tbody></table>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}