{"blogid": "124920585", "writerAge": "码龄2年", "writerBlogNum": "80", "writerCollect": "851", "writerComment": "481", "writerFan": "2787", "writerGrade": "5级", "writerIntegral": "2093", "writerName": "YinJie…", "writerProfileAdress": "writer_image\\profile_124920585.jpg", "writerRankTotal": "9053", "writerRankWeekly": "1713", "writerThumb": "631", "writerVisitNum": "84197", "blog_read_count": "1422", "blog_time": "于 2022-05-27 12:41:40 发布", "blog_title": "Vue3 京东到家项目实战第一篇（首页及登录功能开发） 进阶式掌握vue3完整知识体系", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E9%A1%B9%E7%9B%AE%E9%A6%96%E9%A1%B5%E5%BC%80%E5%8F%91-toc\" style=\"margin-left:0px;\"><a href=\"#%E9%A1%B9%E7%9B%AE%E9%A6%96%E9%A1%B5%E5%BC%80%E5%8F%91\">项目首页开发</a></p>\n<p id=\"%E9%A1%B9%E7%9B%AE%E5%87%86%E5%A4%87-toc\" style=\"margin-left:80px;\"><a href=\"#%E9%A1%B9%E7%9B%AE%E5%87%86%E5%A4%87\">项目准备</a>✌️</p>\n<p id=\"%E6%A0%B7%E5%BC%8F%E5%BC%80%E5%8F%91-toc\" style=\"margin-left:80px;\"><a href=\"#%E6%A0%B7%E5%BC%8F%E5%BC%80%E5%8F%91\">样式开发</a>👍</p>\n<p id=\"%E9%98%B2%E6%8A%96-toc\" style=\"margin-left:80px;\"><a href=\"#%E9%98%B2%E6%8A%96\">防抖</a>👊</p>\n<p id=\"%E5%BA%95%E9%83%A8%E6%A8%AA%E6%9D%A1-toc\" style=\"margin-left:80px;\"><a href=\"#%E5%BA%95%E9%83%A8%E6%A8%AA%E6%9D%A1\">底部横条</a>✌️</p>\n<p id=\"%E7%99%BB%E9%99%86%E6%B3%A8%E5%86%8C%E5%8A%9F%E8%83%BD%E5%BC%80%E5%8F%91-toc\" style=\"margin-left:0px;\"><a href=\"#%E7%99%BB%E9%99%86%E6%B3%A8%E5%86%8C%E5%8A%9F%E8%83%BD%E5%BC%80%E5%8F%91\">登陆注册功能开发</a></p>\n<p id=\"%E6%A0%B7%E5%BC%8F%E7%BC%96%E5%86%99-toc\" style=\"margin-left:80px;\"><a href=\"#%E6%A0%B7%E5%BC%8F%E7%BC%96%E5%86%99\">样式编写</a> 👐</p>\n<p id=\"%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB%E5%AE%9E%E7%8E%B0%E5%9F%BA%E7%A1%80%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E5%8A%9F%E8%83%BD-toc\" style=\"margin-left:80px;\"><a href=\"#%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB%E5%AE%9E%E7%8E%B0%E5%9F%BA%E7%A1%80%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E5%8A%9F%E8%83%BD\">路由守卫实现基础登录校验功能</a>☝️</p>\n<p id=\"%E4%BD%BF%E7%94%A8%20axios%20%E5%8F%91%E9%80%81%E7%99%BB%E5%BD%95%20Mock%20%E8%AF%B7%E6%B1%82-toc\" style=\"margin-left:80px;\"><a href=\"#%E4%BD%BF%E7%94%A8%20axios%20%E5%8F%91%E9%80%81%E7%99%BB%E5%BD%95%20Mock%20%E8%AF%B7%E6%B1%82\">使用 axios 发送登录 Mock 请求</a>👈</p>\n<p id=\"%E8%AF%B7%E6%B1%82%E5%87%BD%E6%95%B0%E7%9A%84%E5%B0%81%E8%A3%85-toc\" style=\"margin-left:80px;\"><a href=\"#%E8%AF%B7%E6%B1%82%E5%87%BD%E6%95%B0%E7%9A%84%E5%B0%81%E8%A3%85\">请求函数的封装</a>🙌</p>\n<p id=\"%E9%80%9A%E8%BF%87%E4%BB%A3%E7%A0%81%E6%8B%86%E5%88%86%E5%A2%9E%E5%8A%A0%E9%80%BB%E8%BE%91%E5%8F%AF%E7%BB%B4%E6%8A%A4%E6%80%A7-toc\" style=\"margin-left:80px;\"><a href=\"#%E9%80%9A%E8%BF%87%E4%BB%A3%E7%A0%81%E6%8B%86%E5%88%86%E5%A2%9E%E5%8A%A0%E9%80%BB%E8%BE%91%E5%8F%AF%E7%BB%B4%E6%8A%A4%E6%80%A7\">通过代码拆分增加逻辑可维护性</a>👏</p>\n<hr id=\"hr-toc\"/>\n<p><strong><span style=\"color:#be191c;\">本项目的源代码在文章末尾哦</span></strong></p>\n<h1 id=\"%E9%A1%B9%E7%9B%AE%E9%A6%96%E9%A1%B5%E5%BC%80%E5%8F%91\">项目首页开发💤</h1>\n<p>我们先看一下在本文中我们这个项目要做的页面，分别是首页，登录和注册页面：</p>\n<p><strong><span style=\"color:#b95514;\"><span style=\"background-color:#fff5e6;\">项目首页：</span></span></strong></p>\n<p><img alt=\"\" height=\"748\" src=\"image\\9604c0509b01461fb1539c09dda8128a.png\" width=\"500\"/></p>\n<p><strong><span style=\"color:#b95514;\"><span style=\"background-color:#fff5e6;\">登录页面：</span></span></strong></p>\n<p><img alt=\"\" height=\"571\" src=\"image\\4c35d2f4d36d4d1e80fa0f9b301af879.png\" width=\"400\"/></p>\n<blockquote>\n<p><strong><span style=\"color:#ed7976;\">注册页面和登录页面相似，这里就不展示了。在本文中我们会完成京东到家项目首页和登录注册页面的样式开发，其中会用到 element-plus 组件库，登录注册会使用 axios 发送 Mock 请求来实现，贴近真实项目开发。</span></strong></p>\n</blockquote>\n<p> </p>\n<h3 id=\"%E9%A1%B9%E7%9B%AE%E5%87%86%E5%A4%87\">项目准备</h3>\n<p>我们通过脚手架已经构建好了项目，如果还不会怎么搭建vue3项目的同学，可以看看我的这篇博客，对vue3有个大概的了解：</p>\n<p><a class=\"link-info has-card\" href=\"https://blog.csdn.net/qq_49900295/article/details/124726599?spm=1001.2014.3001.5501\" title=\"Vue3全家桶入门 （通过vue-cli脚手架搭建todolist项目环境，深入vue3.0核心知识）\"><span class=\"link-card-box\"><span class=\"link-title\">Vue3全家桶入门 （通过vue-cli脚手架搭建todolist项目环境，深入vue3.0核心知识）</span><span class=\"link-link\"><img alt=\"\" class=\"link-link-icon\" src=\"image\\icon-default.png\"/>https://blog.csdn.net/qq_49900295/article/details/124726599?spm=1001.2014.3001.5501</span></span></a><strong><span style=\"color:#1a439c;\"><span style=\"background-color:#eaf4fc;\">首先，在 main.js 中引入项目需要的依赖：</span></span></strong></p>\n<pre><code class=\"language-javascript\">import { createApp } from 'vue'\nimport App from './App.vue'\nimport router from './router'\nimport store from './store'\nimport 'normalize.css'\nimport './style/base.scss'\nimport ElementPlus from 'element-plus'\nimport 'element-plus/dist/index.css'\n\nconst app = createApp(App)\napp.use(store)\napp.use(router)\napp.use(ElementPlus)\napp.mount('#app')\n</code></pre>\n<p><strong><span style=\"color:#1a439c;\"><span style=\"background-color:#eaf4fc;\">这里 normalize.css 和 element-plus 需要我们先安装：</span></span></strong></p>\n<pre><code class=\"language-javascript\">npm install normalize.css --save</code></pre>\n<pre><code class=\"language-javascript\">npm install element-plus --save</code></pre>\n<p></p>\n<blockquote>\n<p><span style=\"background-color:#fefcd8;\">normalize.css 是css的初始化文件，它在默认的HTML元素样式上提供了跨浏览器的高度一致性，总之按装它就完事了，element-plus在我们的项目中可以用到一些弹窗，引入它会非常方便。</span></p>\n</blockquote>\n<p><span style=\"color:#ed7976;\">除了 normalize.css 外，在 main.js 里我们还引入了 base.scss，在这里我们设置了 html 与 body 的字号，方便在样式中使用rem来实现响应式的字体：</span></p>\n<pre><code class=\"language-css\">html {\n    font-size: 100px;\n}\nbody {\n    font-size: .12rem;\n}</code></pre>\n<p><strong><span style=\"color:#1a439c;\"><span style=\"background-color:#eaf4fc;\">下面是项目的 style 目录：</span></span></strong></p>\n<p><img alt=\"\" height=\"104\" src=\"image\\acbd261c21b441aea5fb83d1b5ebc582.png\" width=\"235\"/></p>\n<p><strong><span style=\"color:#1a439c;\"><span style=\"background-color:#eaf4fc;\">在 viriables.scss 文件中我们主要来定义一些颜色变量：</span></span></strong></p>\n<pre><code class=\"language-javascript\">$content-fontcolor: #333;\n$content-bgcolor: #F1F1F1;</code></pre>\n<blockquote>\n<p><span style=\"background-color:#fefcd8;\">因为在各个组件中使用这两个颜色特别多，所以我们可以把它单独拿出来，通过变量的形式我们就可以统一更改颜色，这样就非常方便。</span></p>\n</blockquote>\n<p>下面是 App.vue 中的代码，我们把里面的内容都删掉，我们并不需要 router-link，我们只需要 router-view 渲染子路由就行：</p>\n<pre><code class=\"language-javascript\">&lt;template&gt;\n  &lt;router-view /&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n\nexport default ({\n  name: 'App'\n})\n&lt;/script&gt;</code></pre>\n<h1></h1>\n<h3 id=\"%E6%A0%B7%E5%BC%8F%E5%BC%80%E5%8F%91\">样式开发</h3>\n<p><strong><span style=\"color:#be191c;\"><span style=\"background-color:#fef2f0;\">这是首页的目录结构：</span></span></strong></p>\n<p><img alt=\"\" height=\"203\" src=\"image\\f3f05de56a804e75a1d64b54c476b606.png\" width=\"252\"/></p>\n<blockquote>\n<p><span style=\"background-color:#edf6e8;\">这里HomeView相当于首页的根组件，也就是相当于一个容器里面放着 FooTer，NearBy，StaticView三个子组件，从下图可以看出这三个子组件负责的区域。他们共同构建出了首页的样式。</span></p>\n</blockquote>\n<p> <img alt=\"\" height=\"695\" src=\"image\\4960000af85e44a0bb891277ee4a59d5.jpeg\" width=\"500\"/></p>\n<p><strong><span style=\"color:#be191c;\"><span style=\"background-color:#fef2f0;\">我们看一下 HomeView 中的代码：</span></span></strong></p>\n<pre><code class=\"language-javascript\">&lt;template&gt;\n  &lt;div class=\"wrapper\"&gt;\n    &lt;static-view /&gt;\n    &lt;near-by /&gt;\n  &lt;/div&gt;\n  &lt;foo-ter /&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nimport StaticView from './StaticView.vue'\nimport NearBy from './NearBy.vue'\nimport FooTer from './FooTer.vue'\nexport default {\n  name: 'HomeView',\n  components: {\n    StaticView,\n    NearBy,\n    FooTer\n  }\n}\n&lt;/script&gt;\n\n&lt;style lang=\"scss\"&gt;\n@import '../../style/viriables.scss';\n.wrapper {\n  overflow-y: auto;\n  position: absolute;\n  left: 0;\n  top: 0;\n  right: 0;\n  bottom: .5rem;\n  padding: 0 .18rem .1rem .18rem;\n  .wrapper--content {\n    color: $content-fontcolor;\n  }\n}\n.fl {\n  float: left;\n}\n&lt;/style&gt;\n</code></pre>\n<blockquote>\n<p>我们在 HomeView 中引入三个子组件然后在视图模板中使用引入的子组件。记得要在父组件的 components 中声明引入的子组件。wrapper是 StartView与NearBy组件的容器。</p>\n</blockquote>\n<p>在 wrapper 的样式中有一个<strong><span style=\"color:#b95514;\"><span style=\"background-color:#fff5e6;\"> overflow-y </span></span></strong>，如果不加这个样式的话，首页在拖动滚动条时，Footer 底部就会变成这样：</p>\n<p><img alt=\"\" height=\"407\" src=\"image\\17aa6e88ed684f3c9cbdfb564a99e2a4.png\" width=\"500\"/></p>\n<p>加上 <strong><span style=\"color:#b95514;\"><span style=\"background-color:#fff5e6;\">overflow-y </span></span></strong>后表示可以在y轴放心滚动。</p>\n<blockquote>\n<p><span style=\"background-color:#fefcd8;\">在修改 FooTer 组件样式时，我们想给底部字体10px大小，但是浏览器里默认我们的最小字号是12px，强制修改10px也只会显示12px，我们应该这么修改：</span></p>\n</blockquote>\n<p></p>\n<pre><code class=\"language-css\">.docker__title {\n  font-size: .2rem;\n  transform: scale(.5,.5);\n  transform-origin: center top;\n}</code></pre>\n<p>通过 transform 让元素缩放的方式改变大小，最后要设置它的变换中心点，我们设置水平居中，垂直靠着顶部就正好</p>\n<p></p>\n<h3 id=\"%E9%98%B2%E6%8A%96\">防抖</h3>\n<p><span style=\"color:#ed7976;\">当我们在做到顶部的一个轮播图的时候，因为图片要从服务器中读取，所以加载速度很慢，就会产生一个抖动的现象。比如在图片下面加个文字，看一下网页的加载过程：</span></p>\n<p><img alt=\"\" height=\"383\" src=\"https://img-blog.csdnimg.cn/f1f5bf497d4c486ca1903bbb117a104c.gif\" width=\"600\"/></p>\n<p><strong><span style=\"color:#be191c;\"><span style=\"background-color:#fef2f0;\">因为图片加载的太慢，所以下面的内容会产生这种抖动，我们通过css的方法去解决它：</span></span></strong></p>\n<pre><code class=\"language-css\">.banner {\n  height: 0;\n  overflow: hidden;\n  padding-bottom: 25.4%;\n  &amp;__img {\n    width: 100%;\n  }\n}</code></pre>\n<blockquote>\n<p><strong><span style=\"color:#ad720d;\"><span style=\"background-color:#fefcd8;\">我们先计算一下图片的高宽比，得出是0.254，那这里给个底部内边距百分之25.4指的就是屏幕宽度的百分之25.4，又因为图片的宽度和屏幕宽度一样，所以这就相当于图片的高度。所以我们这么想，就在图片没加载出来之前就会把位置占住。这样就实现了防抖效果。</span></span></strong></p>\n</blockquote>\n<p></p>\n<h3 id=\"%E5%BA%95%E9%83%A8%E6%A8%AA%E6%9D%A1\">底部横条</h3>\n<p><img alt=\"\" height=\"156\" src=\"image\\ed2fd1023de347a087b53f8eb7db8c9c.png\" width=\"631\"/></p>\n<p><strong><span style=\"color:#1c7331;\"><span style=\"background-color:#edf6e8;\">现在我们想给一个底部的条条这个该怎么做呢？这里的难点是我们最外层的盒子有一个padding值，所以我们的横条就不会占满宽度，这个问题应该怎么解决呢？很简单，把这个条条的外边距设置为负的就行</span></span></strong>：</p>\n<pre><code class=\"language-css\">.gap {\n  margin: 0 -.18rem;\n  height: .1rem;\n  background: #F1F1F1;\n}</code></pre>\n<p></p>\n<h1></h1>\n<h1 id=\"%E7%99%BB%E9%99%86%E6%B3%A8%E5%86%8C%E5%8A%9F%E8%83%BD%E5%BC%80%E5%8F%91\">登陆注册功能开发💤</h1>\n<h3 id=\"%E6%A0%B7%E5%BC%8F%E7%BC%96%E5%86%99\">样式编写💥</h3>\n<p><strong><span style=\"color:#1c7331;\"><span style=\"background-color:#edf6e8;\">在 views 目录下的L</span></span></strong><strong><span style=\"color:#1c7331;\"><span style=\"background-color:#edf6e8;\">oginView和RegisterView分别表示登录和注册的页面。</span></span></strong> </p>\n<p><img alt=\"\" height=\"145\" src=\"image\\947ef69e05db41e5950267c37f57e5f0.png\" width=\"246\"/></p>\n<p><strong><span style=\"color:#1c7331;\"><span style=\"background-color:#edf6e8;\">先编写一下基础代码：</span></span></strong></p>\n<pre><code class=\"language-javascript\">&lt;template&gt;\n hello world\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n  name: 'LoginView'\n}\n&lt;/script&gt;\n\n&lt;style scoped lang=\"scss\"&gt;\n\n&lt;/style&gt;\n</code></pre>\n<p><strong><span style=\"color:#1c7331;\"><span style=\"background-color:#edf6e8;\">我们先写一下它的视图模板：</span></span></strong></p>\n<pre><code class=\"language-html\">&lt;template&gt;\n  &lt;div class=\"wrapper\"&gt;\n      &lt;img src=\"http://www.dell-lee.com/imgs/vue3/user.png\" alt=\"\" class=\"wrapper__img\"&gt;\n      &lt;div class=\"wrapper__inp\"&gt;\n          &lt;input type=\"text\" class=\"wrapper__input__content\" /&gt;\n      &lt;/div&gt;\n      &lt;div class=\"wrapper__inp\"&gt;\n          &lt;input type=\"text\" class=\"wrapper__input__content\" /&gt;\n      &lt;/div&gt;\n      &lt;div class=\"wrapper__login-button\"&gt;登录&lt;/div&gt;\n      &lt;div class=\"wrapper__login-link\"&gt;立即注册&lt;/div&gt;\n  &lt;/div&gt;\n&lt;/template&gt;</code></pre>\n<p><strong><span style=\"color:#1c7331;\"><span style=\"background-color:#edf6e8;\">下面我们再写登陆页面的样式：</span></span></strong></p>\n<pre><code class=\"language-css\">\n.wrapper {\n  position: absolute;\n  top: 50%;\n  transform: translateY(-50%);\n  left: 0;\n  right: 0;\n  &amp;__img {\n    display: block;\n    margin: 0 auto .4rem auto;\n    width: .66rem;\n    height: .66rem;\n  }\n  &amp;__input {\n    box-sizing: border-box;\n    height: .48rem;\n    margin: 0 .4rem .16rem .4rem;\n    background: #F9F9F9;\n    padding: 0 .16rem;\n    border: 1px solid rgba(0, 0, 0, .1);\n    border-radius: 6px;\n    &amp;__content {\n      width: 100%;\n      border: 0;\n      background: none;\n      outline: none;\n      line-height: .48rem;\n      font-size: .16rem;\n      color: rgba(0, 0, 0, .5);\n      &amp;::placeholder {\n        color: rgba(0, 0, 0, .5);\n      }\n    }\n  }\n  &amp;__login-button {\n    height: .48rem;\n    line-height: .48rem;\n    margin: .32rem .4rem .16rem .4rem;\n    text-align: center;\n    background: #0091FF;\n    box-shadow: 0 .04rem .08rem 0 rgba(0,145,255,0.32);\n    border-radius: .04rem;\n    color: #fff;\n  }\n  &amp;__login-link {\n    text-align: center;\n    font-size: .14rem;\n    color: rgba(0, 0, 0, .5);\n  }\n}</code></pre>\n<p><strong><span style=\"color:#1c7331;\"><span style=\"background-color:#edf6e8;\">现在我们做一些路由跳转，先修改一下 router 里的 index.js 中的内容：</span></span></strong></p>\n<pre><code class=\"language-javascript\">import { createRouter, createWebHashHistory } from 'vue-router'\nimport HomeView from '../views/home/HomeView.vue'\nimport LoginView from '../views/login/LoginView.vue'\n\nconst routes = [\n  {\n    path: '/',\n    name: 'home',\n    component: HomeView\n  },\n  {\n    path: '/login',\n    name: 'login',\n    component: LoginView\n  }\n]\n\nconst router = createRouter({\n  history: createWebHashHistory(),\n  routes\n})\n\nexport default router</code></pre>\n<p></p>\n<h3 id=\"%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB%E5%AE%9E%E7%8E%B0%E5%9F%BA%E7%A1%80%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E5%8A%9F%E8%83%BD\">路由守卫实现基础登录校验功能💥</h3>\n<p><span style=\"background-color:#f9eda6;\">现在我们想实现一个功能，只有当登陆的时候才能访问首页，否则禁止访问首页</span></p>\n<p><strong><span style=\"color:#1c7331;\"><span style=\"background-color:#edf6e8;\">我们在 index.js 中通过 beforeEach 实现这个功能，先做一下简单的输出：</span></span></strong></p>\n<pre><code class=\"language-javascript\">router.beforeEach((to, from, next) =&gt; {\n  console.log(to, from)\n  next()\n})</code></pre>\n<p><strong><span style=\"color:#ed7976;\">这里 to 指的是要跳转到哪个页面的信息，from 指的是从哪个页面跳转的信息。router.beforEach 的意思就是每次在路由跳转前都要执行这个方法。</span></strong></p>\n<blockquote>\n<p><strong><span style=\"color:#511b78;\"><span style=\"background-color:#efedf6;\">我们每次在跳转前先判断是否登录，如果用户之前登录过就跳转到对应的页面，否则就跳转到登陆页面。但是如果用户没有登录他跳转到登录页面的时候还会 router.beforEach 进行判断，这样他又会跳到登陆页面，这样会一直循环，所以我们在 if 中还得加一个条件，如果跳转的是登陆页面的话就允许跳转。</span></span></strong></p>\n</blockquote>\n<pre><code class=\"language-javascript\">router.beforeEach((to, from, next) =&gt; {\n  const isLogin = false\n  if (isLogin || to.name === 'login') {\n    next()\n  } else {\n    next({ name: 'login' })\n  }\n})</code></pre>\n<p>现在我们的页面默认就会跳转到登陆页面，就算在浏览器路径中让它跳到首页，他也不会跳转。</p>\n<p><strong><span style=\"color:#1c7331;\"><span style=\"background-color:#edf6e8;\">现在我们就去实现当用户点击登陆时候的跳转功能，在 LoginView 里，先给按钮一个点击事件：</span></span></strong></p>\n<pre><code class=\"language-html\">&lt;div class=\"wrapper__login-button\" @click=\"handleLogin\"&gt;登录&lt;/div&gt;</code></pre>\n<p>当点击登陆时，会先判断输入的电话号码是否符合格式，符合与不符合都会有相应的弹窗（这里弹窗是element-plus的组件），当符合格式时就让 isLogin 为 ture，表示在登陆状态：<br/><img alt=\"\" height=\"432\" src=\"image\\3a81f7c86c8d4049a649dd7eb68576db.png\" width=\"400\"/></p>\n<pre><code class=\"language-javascript\">import { ref } from 'vue'\nimport { ElMessage } from 'element-plus'\nimport { useRouter } from 'vue-router'\nexport default {\n  name: 'LoginView',\n  setup () {\n    const router = useRouter()\n    let number = ref('')\n    let password = ref('')\n    let handleLogin = () =&gt; {\n      let reg = /^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$/\n      if (reg.test(number.value)) {\n        open2()\n        localStorage.isLogin = true\n        setTimeout(() =&gt; {\n          router.push({ name: 'home' })\n        }, 2000)\n      } else {\n        open()\n      }\n    }\n    let open = () =&gt; {\n      ElMessage({\n        message: '您输入的电话号码格式错误',\n        type: 'error',\n        duration: 2000\n      })\n    }\n    let open2 = () =&gt; {\n      ElMessage({\n        message: '登陆成功欢迎您',\n        type: 'success',\n        duration: 2000\n      })\n    }\n    return {\n      handleLogin,\n      number,\n      password,\n      open,\n      open2,\n      router\n    }\n  }\n}</code></pre>\n<p><strong><span style=\"color:#1c7331;\"><span style=\"background-color:#edf6e8;\">然后我们完善一下 router 下 登陆路由的配置：</span></span></strong></p>\n<pre><code class=\"language-javascript\">path: '/login',\nname: 'login',\ncomponent: LoginView,\nbeforeEnter (to, from, next) {\n  const isLogin = localStorage.isLogin\n  if (isLogin) {\n    next({ name: 'home' })\n  } else {\n    next()\n  }\n}</code></pre>\n<blockquote>\n<p><span style=\"background-color:#f9eda6;\">路由的 beforeEnter 事件就是当跳转路由之前执行的，如果我们当前已经登录成功，跳转到首页了。如果我们想跳转回登录页面的话就会来到 beforeEnter 判断，登陆成功后 isLogin 这个登录状态就是 true，这样就不会再退回到登录页面，还会跳转到首页。</span></p>\n</blockquote>\n<p>在完成登录页面后，我们照猫画虎继续完成注册页面，把登录页面的内容复制一份，注册页面就比登录页面多了个确认密码，然后去 index.js 中配置路由信息。</p>\n<p><strong><span style=\"color:#be191c;\"><span style=\"background-color:#fef2f0;\">只不过我们还得完成登录与注册页面之间的切换，在登录页面点击立即注册后跳转到注册页面：</span></span></strong></p>\n<p><img alt=\"\" height=\"48\" src=\"image\\748d4c3766a94f23a452d9fdb0957b75.png\" width=\"739\"/></p>\n<pre><code class=\"language-javascript\">let handleRegisterClick = () =&gt; {\n      ElNotification({\n        title: '尊敬的用户您好',\n        message: h('i', { style: 'color: teal' }, '正在跳转到注册页面'),\n        duration: 800\n      })\n      setTimeout(() =&gt; {\n        router.push({ name: 'register' })\n      }, 900)\n    }</code></pre>\n<p><strong><span style=\"color:#be191c;\"><span style=\"background-color:#fef2f0;\">在登录页面单击立即注册时，通过 element-plus 弹框提示，然后跳转路由，注册页面也是相同的操作。</span></span></strong></p>\n<p><img alt=\"\" height=\"737\" src=\"image\\748eecbd75cf412ca52a0cf923ec87f5.png\" width=\"500\"/></p>\n<p></p>\n<h3 id=\"%E4%BD%BF%E7%94%A8%20axios%20%E5%8F%91%E9%80%81%E7%99%BB%E5%BD%95%20Mock%20%E8%AF%B7%E6%B1%82\">使用 axios 发送登录 Mock 请求💥</h3>\n<p>现在我们的登录注册都是前端模拟出来的，现在我们要学习如何在前端调用接口，和后端做交互。</p>\n<p><img alt=\"\" height=\"190\" src=\"image\\af7625963aad4fa298c4a02f13b2d249.png\" width=\"453\"/></p>\n<blockquote>\n<p><span style=\"background-color:#f9eda6;\">在我们的登录组件中，如果用户点击登录了，我们就让登录状态为 true，显然这是不合理的，我们应该先向后端发送请求，如果用户名和密码匹配，才允许登录将状态改为 true。</span></p>\n</blockquote>\n<p><strong><span style=\"color:#1c7892;\"><span style=\"background-color:#e7fafa;\">那我们首先安装一下 axios：</span></span></strong></p>\n<pre><code class=\"language-javascript\">npm install axios ---save</code></pre>\n<p><strong><span style=\"color:#1c7892;\"><span style=\"background-color:#e7fafa;\">把他引入到登录组件中：</span></span></strong></p>\n<pre><code class=\"language-javascript\">import axios from 'axios'</code></pre>\n<p>这里的后端接口是我们通过 fastmock 模拟的后端接口，大家可以通过这个 url 来得到我们这个项目需要用到的数据，下面是我们这个项目的接口文档，可以看到登录是通过发送 post 请求来实现的，后面跟着的有登录的接口地址：</p>\n<p><img alt=\"\" height=\"1200\" src=\"image\\8b71e5771b3a497cb05d5876f46e43c2.jpeg\" width=\"1200\"/></p>\n<p>下面是我们这个项目的接口文档的地址：</p>\n<pre><code class=\"language-javascript\">https://www.fastmock.site/mock/ae8e9031947a302fed5f92425995aa19/jd/</code></pre>\n<blockquote>\n<p><strong><span style=\"color:#ed7976;\">我们给登录按钮加一个点击事件，然后在这个函数里实现我们想要的功能，这里加上 setTimeout 是因为 element-plus 的弹窗有两秒的时间，然后两秒后我们再实现登录跳转就更贴近实际一些。</span></strong></p>\n</blockquote>\n<p><strong><span style=\"color:#1c7892;\"><span style=\"background-color:#e7fafa;\">post 请求中我们还需要把请求的数据返给后端接口， 下面就是登录事件的代码：</span></span></strong></p>\n<pre><code class=\"language-javascript\"> let handleLogin = () =&gt; {\n      axios.post('https://www.fastmock.site/mock/ae8e9031947a302fed5f92425995aa19/jd/api/user/login', {\n        username: username,\n        password: password\n      }).then(() =&gt; {\n        open2()\n        localStorage.isLogin = true\n        setTimeout(() =&gt; {\n          router.push({ name: 'home' })\n        }, 2000)\n      }).catch(() =&gt; {\n        open()\n      })\n    }</code></pre>\n<p>现在当我们点击登录时，就模拟了一个post请求，把输入的内容返回给后端接口，这里的接口只是用来模拟请求过程，并不是我们项目的真实后端接口。</p>\n<p><img alt=\"\" height=\"70\" src=\"image\\a7796a6213ad45da9982bf942623fec9.png\" width=\"812\"/></p>\n<p><strong><span style=\"color:#be191c;\"><span style=\"background-color:#fef2f0;\">注意要把返回内容的格式设置为 json ，因为 fastmock 是这么要求的。</span></span></strong></p>\n<p></p>\n<h3 id=\"%E8%AF%B7%E6%B1%82%E5%87%BD%E6%95%B0%E7%9A%84%E5%B0%81%E8%A3%85\">请求函数的封装💥</h3>\n<p><strong><span style=\"color:#511b78;\"><span style=\"background-color:#efedf6;\">vue3 已经支持 async 和 await 这样的语法，我们重新写一下上一节的代码，输出一下返回的结果：</span></span></strong></p>\n<pre><code class=\"language-javascript\">    let handleLogin = async () =&gt; {\n      const result = await axios.post('https://www.fastmock.site/mock/ae8e9031947a302fed5f92425995aa19/jd/api/user/login', {\n        username: username,\n        password: password\n      // }).then(() =&gt; {\n      //   open2()\n      //   localStorage.isLogin = true\n      //   setTimeout(() =&gt; {\n      //     router.push({ name: 'home' })\n      //   }, 2000)\n      // }).catch(() =&gt; {\n      //   open()\n      // })\n      })\n      console.log(result)\n    }</code></pre>\n<p><strong><span style=\"color:#511b78;\"><span style=\"background-color:#efedf6;\">启动项目，点击登录，result就在控制台中输出出来了：</span></span></strong></p>\n<p><img alt=\"\" height=\"182\" src=\"image\\5e4a7d18108c4557a69b5002a45c8d7b.png\" width=\"738\"/></p>\n<p><strong><span style=\"color:#511b78;\"><span style=\"background-color:#efedf6;\">这里data中的 errno 表示返回的错误个数，如果是0就表示请求发送成功，那么我们继续完善代码：</span></span></strong></p>\n<pre><code class=\"language-javascript\">    let handleLogin = async () =&gt; {\n      const result = await axios.post('https://www.fastmock.site/mock/ae8e9031947a302fed5f92425995aa19/jd/api/user/login', {\n        username: username,\n        password: password\n      })\n      if (result.data.errno === 0) {\n        localStorage.isLogin = true\n        open2()\n        setTimeout(() =&gt; {\n          router.push({ name: 'home' })\n        }, 2000)\n      } else {\n        open()\n      }\n    }</code></pre>\n<p><strong><span style=\"color:#511b78;\"><span style=\"background-color:#efedf6;\">现在我们故意把 url 地址写错：</span></span></strong></p>\n<p><img alt=\"\" height=\"69\" src=\"image\\ee555a0de17b45bca570056e81f2b158.png\" width=\"337\"/></p>\n<p><strong><span style=\"color:#511b78;\"><span style=\"background-color:#efedf6;\">启动项目，看看有什么效果：</span></span></strong></p>\n<p><img alt=\"\" height=\"101\" src=\"image\\299560f731ec4b76a48c222fe2aa0120.png\" width=\"873\"/></p>\n<p><strong><span style=\"color:#ed7976;\">控制台的网络这块就报错了，但是并没有弹窗，这是为什么呢？</span></strong></p>\n<p><strong><span style=\"color:#511b78;\"><span style=\"background-color:#efedf6;\">因为异常会在 await 那里抛出，不会走下面的代码了，自然不会执行弹窗语句，那我们通过 try catch就能解决这个问题：</span></span></strong></p>\n<pre><code class=\"language-javascript\">let handleLogin = async () =&gt; {\n      try {\n        const result = await axios.post('https://www.fastmck.site/mock/ae8e9031947a302fed5f92425995aa19/jd/api/user/login', {\n          username: username,\n          password: password\n        })\n        if (result.data.errno === 0) {\n          localStorage.isLogin = true\n          open2()\n          setTimeout(() =&gt; {\n            router.push({ name: 'home' })\n          }, 2000)\n        } else {\n          open()\n        }\n      } catch (e) {\n        open3()\n      }\n    }</code></pre>\n<p><strong><span style=\"color:#511b78;\"><span style=\"background-color:#efedf6;\">这样在输入错误的 url 时，他就会提示我们请求失败了：</span></span></strong></p>\n<p><img alt=\"\" height=\"519\" src=\"image\\9f9e30df2cb6469f8aea56e1eb92a275.png\" width=\"500\"/></p>\n<blockquote>\n<p><span style=\"background-color:#f9eda6;\">现在我们每发一个请求都要写一段很长的请求地址，后面请求别的接口还得再写这样一段代码，那我们就把它封装一下。</span></p>\n</blockquote>\n<p><strong><span style=\"color:#511b78;\"><span style=\"background-color:#efedf6;\">我们在 src 目录下新建一个 utils 文件，在 request 里封装 post 请求：</span></span></strong></p>\n<p><img alt=\"\" height=\"69\" src=\"image\\b235d40e20814ddf98be416a7f1011eb.png\" width=\"224\"/></p>\n<p><strong><span style=\"color:#511b78;\"><span style=\"background-color:#efedf6;\">我们对 post 请求做了一个封装：</span></span></strong></p>\n<pre><code class=\"language-javascript\">import axios from 'axios'\nexport const post = (url, data = {}) =&gt; {\n  return new Promise((resolve, reject) =&gt; {\n    axios.post(url, data, {\n      baseURL: 'https://www.fastmock.site/mock/ae8e9031947a302fed5f92425995aa19/jd',\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    }).then((response) =&gt; {\n      resolve(response)\n    }, err =&gt; {\n      reject(err)\n    })\n  })\n}\n</code></pre>\n<p><strong><span style=\"color:#511b78;\"><span style=\"background-color:#efedf6;\">这样在 Login 中我们就不需要引入 axios 了，直接把 post 方法引入进来就行：</span></span></strong></p>\n<pre><code class=\"language-javascript\">import { post } from '../../utils/request'</code></pre>\n<p>现在我们的弹窗用的是 element plus 提供的组件，但是用的多了的时候就会有大量冗余的代码，下面我们对他也进行一下封装：</p>\n<pre><code class=\"language-javascript\">    let alertmessage = (thecontent, thetype, theduration) =&gt; {\n      ElMessage({\n        message: thecontent,\n        type: thetype,\n        duration: theduration\n      })\n    }</code></pre>\n<p><strong><span style=\"color:#511b78;\"><span style=\"background-color:#efedf6;\">这样当我们用到弹窗这个功能时，直接指定参数就行了：</span></span></strong></p>\n<p><img alt=\"\" height=\"234\" src=\"image\\866fc27fc1e84d70ab51fc6696d1ded6.png\" width=\"500\"/></p>\n<p>在 register 组件里我们点击注册的时候也是发送 post 请求，和登录页面的实现逻辑相同，只是请求的接口不一样，接口地址在上面的接口文档中有，大家可以自行查看，在这一节中我们封装了请求函数，然后在登录页面和注册页面中使用我们封装的这个函数实现了数据的请求。</p>\n<p><strong><span style=\"color:#511b78;\"><span style=\"background-color:#efedf6;\">现在我们的登录注册页面的功能就大致完成了，启动项目看看最终的效果：</span></span></strong></p>\n<p><img alt=\"\" height=\"383\" src=\"https://img-blog.csdnimg.cn/b7d59872a97d49799a1c6649d9522091.gif\" width=\"600\"/></p>\n<p></p>\n<h3 id=\"%C2%A0\"> </h3>\n<h3 id=\"%E9%80%9A%E8%BF%87%E4%BB%A3%E7%A0%81%E6%8B%86%E5%88%86%E5%A2%9E%E5%8A%A0%E9%80%BB%E8%BE%91%E5%8F%AF%E7%BB%B4%E6%8A%A4%E6%80%A7\">通过代码拆分增加逻辑可维护性💥</h3>\n<blockquote>\n<p><span style=\"background-color:#f9eda6;\">现在我们把各种函数都放在了 setup 中，这样做肯定没有出错，但是这样会让我们的 setup 函数非常长，如果项目做到后面我们要在里面找某一个函数或者变量的时候，都很麻烦，如果把关于登录逻辑的数据和方法都放在 setup 外面的一个函数中，关于注册逻辑的数据和方法放在另一个函数中，这样再把这些函数在 setup 中接收，在 setup 中我们只关心整个页面的实现逻辑就行，这样整个代码的维护性和可读性都大大提高了。</span></p>\n</blockquote>\n<p><strong><span style=\"color:#1a439c;\"><span style=\"background-color:#eaf4fc;\">在登录页面我们把向后端发送登录请求的相关逻辑从 setup 中抽离出来：</span></span></strong></p>\n<pre><code class=\"language-javascript\">const useLoginEffect = () =&gt; {\n  const router = useRouter()\n  let username = ref('')\n  let password = ref('')\n  let handleLogin = async () =&gt; {\n    if (username.value === '' || password.value === '') {\n      alertmessage('输入内容不能为空', 'warning', 1500)\n      return\n    }\n    try {\n      const result = await post('/api/user/login', {\n        username: username,\n        password: password\n      })\n      if (result.data.errno === 0) {\n        localStorage.isLogin = true\n        alertmessage('登录成功欢迎您', 'success', 2000)\n        setTimeout(() =&gt; {\n          router.push({ name: 'home' })\n        }, 2000)\n      } else {\n        alertmessage('登录失败', 'error', 2000)\n      }\n    } catch (e) {\n      alertmessage('请求失败', 'error', 2000)\n    }\n  }\n  return { username, password, handleLogin }\n}</code></pre>\n<p>这里我们重新定义了一个useLoginEffect 函数，然后把需要用到的数据和方法都放进来，最后通过 return 把数据和方法返回出来，以便在 setup 中接收。</p>\n<p><strong><span style=\"color:#1a439c;\"><span style=\"background-color:#eaf4fc;\">我们再把点击注册这个函数的相关逻辑抽离出来：</span></span></strong></p>\n<pre><code class=\"language-javascript\">const useRegisterEffect = () =&gt; {\n  const router = useRouter()\n  let handleRegisterClick = () =&gt; {\n    ElNotification({\n      title: '尊敬的用户您好',\n      message: h('i', { style: 'color: teal' }, '正在跳转到注册页面'),\n      duration: 800\n    })\n    setTimeout(() =&gt; {\n      router.push({ name: 'register' })\n    }, 900)\n  }\n  return { handleRegisterClick }\n}\n</code></pre>\n<p><strong><span style=\"color:#1a439c;\"><span style=\"background-color:#eaf4fc;\">这样我们就把登录页面相关的功能都从 setup 里面抽离了出来，现在再看 setup 里的代码就优雅了许多，浅显易懂：</span></span></strong></p>\n<pre><code class=\"language-javascript\">setup () {\n    const { username, password, handleLogin } = useLoginEffect()\n    const { handleRegisterClick } = useRegisterEffect()\n    return {\n      handleLogin,\n      username,\n      password,\n      handleRegisterClick\n    }\n  }</code></pre>\n<p><span style=\"color:#ed7976;\">在 setup 里我们很清晰的知道这个页面的实现逻辑，如果想修改跳转登录这个函数就去对应的函数里修改就可以，方便了很多。</span></p>\n<p>在注册页面的代码拆分和登录页面的相同，这里就不过多阐述。在本文中我们暂时完成了项目首页和登陆注册页面的样式，实现了登陆注册时向后端发送请求获取数据的功能，最后通过代码拆分增加逻辑可维护性。下一篇文章我们会实现商家展示功能的开发，大家记得关注哦！</p>\n<p></p>\n<p><strong><span style=\"color:#be191c;\"><span style=\"background-color:#fef2f0;\">项目代码地址：</span></span></strong></p>\n<p><strong><span style=\"color:#be191c;\"><span style=\"background-color:#fef2f0;\"><a class=\"link-info has-card\" href=\"https://gitee.com/jie_shao1112/jingdong-home\" title=\"https://gitee.com/jie_shao1112/jingdong-home\"><span class=\"link-card-box\"><span class=\"link-title\">https://gitee.com/jie_shao1112/jingdong-home</span><span class=\"link-link\"><img alt=\"icon-default.png?t=M4AD\" class=\"link-link-icon\" src=\"image\\icon-default.png\"/>https://gitee.com/jie_shao1112/jingdong-home</span></span></a></span></span></strong><br/>  </p>\n</div>\n</div>"}