{"blogid": "123791205", "writerAge": "码龄1年", "writerBlogNum": "45", "writerCollect": "34", "writerComment": "19", "writerFan": "15", "writerGrade": "3级", "writerIntegral": "554", "writerName": "XiLitter", "writerProfileAdress": "writer_image\\profile_123791205.jpg", "writerRankTotal": "31926", "writerRankWeekly": "23012", "writerThumb": "62", "writerVisitNum": "30449", "blog_read_count": "2178", "blog_time": "于 2022-03-30 15:12:03 发布", "blog_title": "php反序列化字符逃逸", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h1>前言</h1>\n<p>在了解php反序列化漏洞后，我又进一步学习了字符逃逸的相关内容。这一部分相对来说是比较难理解的。我也是在网上看了很多篇文章，再次自己总结一下究竟什么是字符逃逸，也方便日后复习。</p>\n<h1>字符逃逸的原理</h1>\n<p>什么是字符逃逸，从字面意思看，就是一些字符被丢弃。我们知道，序列化后的字符串在进行反序列化操作时，会以{}两个花括号进行分界线，花括号以外的内容不会被反序列化。我举一个例子：</p>\n<pre><code class=\"language-php\">&lt;?php\nclass people{\n    public $name = 'aaa';\n    public $sex = 'boy';\n }\n$a = new people();\nprint_r(serialize($a));\n$str='O:6:\"people\":2:{s:4:\"name\";s:3:\"aaa\";s:3:\"sex\";s:3:\"boy\";}123';\nvar_dump(unserialize($str));\n?&gt;</code></pre>\n<p>在序列化字符串后面添加123。</p>\n<p><img alt=\"\" height=\"202\" src=\"image\\9b90039c171046a4b043f4da1235a1f9.png\" width=\"895\"/></p>\n<p>PHP不会报错，并且也不会输出123.说明{}是字符串反序列化时的分界符。当然，在进行反序列化时，是从左到右读取。读取多少取决于s后面的字符长度。</p>\n<p>比如当我们将数字改成5.</p>\n<pre><code class=\"language-php\">&lt;?php\n$str='O:6:\"people\":2:{s:5:\"name\";s:3:\"aaa\";s:3:\"sex\";s:3:\"boy\";}';\nvar_dump(unserialize($str));\n?&gt;</code></pre>\n<p>此时在读取name时，它会将闭合的双引号也读取在内，而需要闭合字符串的双引号被当作字符串处理，这时就会导致语法错误而报错。</p>\n<p>一般触发字符逃逸的前提是这个替换函数str_replace，能将字符串的长度改变。其主要原理就是运用闭合的思想。字符逃逸主要有两种，一种是字符增多，一种是字符减少。</p>\n<h2>字符增多</h2>\n<p>繁杂的文字不如直观的代码，上代码：</p>\n<pre><code class=\"language-php\">&lt;?php\nclass A{\n\tpublic $name = 'aaaaaaaaaaaaaaaaaaaaaaaaaa\";s:6:\"passwd\";s:3:\"123\";}';\n\tpublic $passwd = '1234';\n}\n$ss = new A();\n$str = serialize($ss);\n//echo $str;\nfunction filter($str){\n    return str_replace('aa','bbbb',$str);\n}\n$tt = filter($str);\necho $tt;\n$qq = unserialize($tt);\nvar_dump($qq);\n?&gt;</code></pre>\n<p>大家可能会有一个疑惑？为什么要有这个str_replace函数，我认为可能是想过滤掉用户输入的恶意代码，防止恶意代码执行恶意命令。(主要还是unserialize函数的参数可控)。</p>\n<p>这段代码主要目的就是间接修改passwd的值。</p>\n<pre><code>\";s:6:\"passwd\";s:3:\"123\";}</code></pre>\n<p>这个字符串一共有26字符。我们想要让这段字符串进行反序列化，而<span style=\"color:#fe2c24;\">;}</span>正好将前面闭合，从而将字符串<span style=\"color:#fe2c24;\">\";s:6:\"passwd\";s:4:\"1234\";}</span>逃逸出去。这样就可以间接修改passwd的值了。回过头看代码，序列化字符串中将aa替换为bbbb,这样就多出两个字符。以此类推，我们输入13个aa，就会多出26个字符，正好达到name的字符串长度，成功将<span style=\"color:#fe2c24;\">s:6:\"passwd\";s:3:\"123\";}</span><span style=\"color:#0d0016;\">反序列化。</span></p>\n<p><img alt=\"\" height=\"244\" src=\"image\\47667f34a4304a609b9ebbd48c736a23.png\" width=\"921\"/></p>\n<p>这样就将passwd的值改为123。</p>\n<h1>字符减少</h1>\n<p>无非就是将长字符串替换成短的字符串，其原理大同小异。</p>\n<p>同样的，上代码：</p>\n<pre><code class=\"language-php\">&lt;?php\nclass A{\n\tpublic $name = 'bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\";s:6:\"passwd\";s:3:\"123\";}';\n\tpublic $passwd = '1234\";s:6:\"passwd\";s:3:\"123';\n}\n$ss = new A();\n$str = serialize($ss);\n//echo $str;\nfunction filter($str){\n    return str_replace('bb','a',$str);\n}\n$tt = filter($str);\necho $tt;\n$qq = unserialize($tt);\nvar_dump($qq);\n?&gt;</code></pre>\n<p>同样道理，我们要将<span style=\"color:#fe2c24;\">s:6:\"passwd\";s:3:\"123</span><span style=\"color:#0d0016;\">成功反序列化，那么就要把</span></p>\n<pre><code>\";s:6:\"passwd\";s:27:\"1234</code></pre>\n<p>这段字符串给吃掉。这段字符串一共有25个字符，则我们在name中输入25个bb。就可以达到效果。</p>\n<p><img alt=\"\" height=\"234\" src=\"image\\ab895b151d754094af07180336a98674.png\" width=\"905\"/></p>\n<h1>总结</h1>\n<p>字符逃逸的主要原理就是闭合，和sql注入类似，只不过它判断的是字符串的长度。输入恰好的字符串长度，让无用的部分字符逃逸或吞掉，从而达到我们想要的目的。</p>\n</div>\n</div>"}