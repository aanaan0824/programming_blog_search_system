{"blogid": "123553601", "writerAge": "码龄11年", "writerBlogNum": "130", "writerCollect": "1449", "writerComment": "301", "writerFan": "6088", "writerGrade": "6级", "writerIntegral": "4812", "writerName": "一缕82年的清风", "writerProfileAdress": "writer_image\\profile_123553601.jpg", "writerRankTotal": "18993", "writerRankWeekly": "1424", "writerThumb": "527", "writerVisitNum": "694457", "blog_read_count": "13856", "blog_time": "已于 2022-03-28 13:18:54 修改", "blog_title": "SpringBoot教程(十四) | SpringBoot集成Redis(全网最全)", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h2>一、Redis集成简介</h2>\n<p>Redis是我们Java开发中，使用频次非常高的一个nosql数据库，数据以key-value键值对的形式存储在内存中。redis的常用使用场景，可以做缓存，分布式锁，自增序列等，使用redis的方式和我们使用数据库的方式差不多，首先我们要在自己的本机电脑或者服务器上安装一个redis的服务器，通过我们的java客户端在程序中进行集成，然后通过客户端完成对redis的增删改查操作。redis的Java客户端类型还是很多的，常见的有jedis, redission,lettuce等，所以我们在集成的时候，我们可以选择直接集成这些原生客户端。但是在springBoot中更常见的方式是集成spring-data-redis，这是spring提供的一个专门用来操作redis的项目，封装了对redis的常用操作，里边主要封装了jedis和lettuce两个客户端。相当于是在他们的基础上加了一层门面。</p>\n<p>本篇文章我们就来重点介绍，springBoot通过集成spring-data-redis使用对于redis的常用操作。</p>\n<p>由于不涉及到兼容问题，我们就直接在feature/MybatisPlus分支上开发。</p>\n<h2>二、集成步骤</h2>\n<h3>2.1 添加依赖</h3>\n<p>添加redis所需依赖：</p>\n<pre><code class=\"language-XML\">&lt;!-- 集成redis依赖  --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p>完整pom.xml</p>\n<pre><code class=\"language-XML\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;groupId&gt;com.lsqingfeng.springboot&lt;/groupId&gt;\n    &lt;artifactId&gt;springboot-learning&lt;/artifactId&gt;\n    &lt;version&gt;1.0.0&lt;/version&gt;\n\n    &lt;properties&gt;\n        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;\n        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;\n    &lt;/properties&gt;\n\n    &lt;dependencyManagement&gt;\n        &lt;dependencies&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n                &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;\n                &lt;version&gt;2.6.2&lt;/version&gt;\n                &lt;type&gt;pom&lt;/type&gt;\n                &lt;scope&gt;import&lt;/scope&gt;\n            &lt;/dependency&gt;\n        &lt;/dependencies&gt;\n    &lt;/dependencyManagement&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n\n        &lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\n            &lt;artifactId&gt;lombok&lt;/artifactId&gt;\n            &lt;version&gt;1.18.22&lt;/version&gt;\n            &lt;scope&gt;provided&lt;/scope&gt;\n        &lt;/dependency&gt;\n\n        &lt;!-- mybatis-plus 所需依赖  --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;\n            &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;\n            &lt;version&gt;3.5.1&lt;/version&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;\n            &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt;\n            &lt;version&gt;3.5.1&lt;/version&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.freemarker&lt;/groupId&gt;\n            &lt;artifactId&gt;freemarker&lt;/artifactId&gt;\n            &lt;version&gt;2.3.31&lt;/version&gt;\n        &lt;/dependency&gt;\n\n        &lt;!-- 开发热启动 --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;\n            &lt;optional&gt;true&lt;/optional&gt;\n        &lt;/dependency&gt;\n\n        &lt;!-- MySQL连接 --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;mysql&lt;/groupId&gt;\n            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n            &lt;scope&gt;runtime&lt;/scope&gt;\n        &lt;/dependency&gt;\n\n        &lt;!-- 集成redis依赖  --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n&lt;/project&gt;\n</code></pre>\n<p>这里我们直接引入了spring-boot-starter-data-redis这个springBoot本身就已经提供好了的starter, 我们可以点击去看一下这个starter中包含了哪些依赖：</p>\n<p><img alt=\"\" height=\"744\" src=\"image\\e80a9a8b3b0c4c0eb5ce5697ccd80acf.png\" width=\"1014\"/></p>\n<p></p>\n<p></p>\n<p>可以发现，里面包含了spring-data-redis和 lettuce-core两个核心包，这就是为什么说我们的spring-boot-starter-data-redis默认使用的就是lettuce这个客户端了。</p>\n<p>如果我们想要使用jedis客户端怎么办呢？就需要排除lettuce这个依赖，再引入jedis的相关依赖就可以了。</p>\n<p>那么为什么我们只需要通过引入不同的依赖就能让spring-data-redis可以自由切换客户端呢，这其实就涉及到了springBoot的自动化配置原理。我们可以给大家简单讲解一下。</p>\n<p>springBoot这个框架之所以可以通过各种starter无缝融合其他技术的一大主要原因就是springBoot本身的自动化配置功能。所谓自动化配置就是springBoot本身已经预先设置好了一些常用框架的整合类。然后通过类似于ConditionOn这样的条件判断注解，去辨别你的项目中是否有相关的类（或配置）了，进而进行相关配置的初始化。</p>\n<p>springBoot预设的自动化配置类都位于spring-boot-autoconfigure这个包中，只要我们搭建了springBoot的项目，这个包就会被引入进来。</p>\n<p><img alt=\"\" height=\"1200\" src=\"image\\20894f6b65ec4d6387c55bdd8b80745b.png\" width=\"1014\"/></p>\n<p></p>\n<p></p>\n<p>而这个包下就有一个RedisAutoConfiguration这个类，顾名思义就是Redis的自动化配置。在这个类中，会引入LettuceConnectionConfiguration 和 JedisConnectionConfiguration 两个配置类，分别对应lettuce和jedis两个客户端。</p>\n<p><img alt=\"\" height=\"644\" src=\"image\\c9d6cea61ea64f97898d8035a590d418.png\" width=\"1056\"/></p>\n<p></p>\n<p></p>\n<p>而这个两个类上都是用了ConditionOn注解来进行判断是否加载。</p>\n<p><img alt=\"\" height=\"710\" src=\"image\\305657a0474649a3971f79fad59232ac.png\" width=\"1056\"/></p>\n<p></p>\n<p></p>\n<p>jedis如下；</p>\n<p><img alt=\"\" height=\"480\" src=\"image\\590ee84fd7ee47a8b9ee229c23413f28.png\" width=\"1102\"/></p>\n<p></p>\n<p></p>\n<p>而由于我们的项目自动引入了lettuce-core，而没有引入jedis相关依赖，所以LettuceConnectionConfiguration这个类的判断成立会被加载，而Jedis的判断不成立，所以不会加载。进而lettuce的配置生效，所以我们在使用的使用， 默认就是lettuce的客户端。</p>\n<h3>2.2 添加配置</h3>\n<p>然后我们需要配置连接redis所需的账号密码等信息，这里大家要提前安装好redis,保证我们的本机程序可以连接到我们的redis， 如果不知道redis如何安装，可以参考文章: [Linux系统安装redis6.0.5] <a href=\"https://blog.csdn.net/lsqingfeng/article/details/107359076?ops_request_misc=%7B%22request_id%22%3A%22164663221016780366526405%22%2C%22scm%22%3A%2220140713.130102334.pc_blog.%22%7D&amp;request_id=164663221016780366526405&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-107359076.nonecase&amp;utm_term=redis&amp;spm=1018.2226.3001.4450\" title=\"https://blog.csdn.net/lsqingfeng/article/details/107359076\">https://blog.csdn.net/lsqingfeng/article/details/107359076</a></p>\n<p>常规配置如下： 在application.yml配置文件中配置 redis的连接信息</p>\n<pre><code class=\"language-XML\">spring:\n  redis:\n    host: localhost\n    port: 6379\n    password: 123456\n    database: 0\n\n</code></pre>\n<p>如果有其他配置放到一起：</p>\n<pre><code class=\"language-XML\">server:\n  port: 19191\n\nspring:\n  datasource:\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql://localhost:3306/springboot_learning?serverTimezone=Asia/Shanghai&amp;characterEncoding=utf-8\n    username: root\n    password: root\n  redis:\n    host: localhost\n    port: 6379\n    password: 123456\n    database: 0\n    lettuce:\n      pool:\n        max-idle: 16\n        max-active: 32\n        min-idle: 8\n  devtools:\n    restart:\n      enable: true\n\n\nthird:\n  weather:\n    url: http://www.baidu.com\n    port: 8080\n    username: test\n    cities:\n      - 北京\n      - 上海\n      - 广州\n    list[0]: aaa\n    list[1]: bbb\n    list[2]: ccc\n</code></pre>\n<p>这样我们就可以直接在项目当中操作redis了。如果使用的是集群，那么使用如下配置方式：</p>\n<pre><code>spring:\n  redis:\n    password: 123456\n    cluster:\n      nodes: 10.255.144.115:7001,10.255.144.115:7002,10.255.144.115:7003,10.255.144.115:7004,10.255.144.115:7005,10.255.144.115:7006\n      max-redirects: 3\n</code></pre>\n<p>但是有的时候我们想要给我们的redis客户端配置上连接池。就像我们连接mysql的时候，也会配置连接池一样，目的就是增加对于数据连接的管理，提升访问的效率，也保证了对资源的合理利用。那么我们如何配置连接池呢，这里大家一定要注意了，很多网上的文章中，介绍的方法可能由于版本太低，都不是特别的准确。 比如很多人使用spring.redis.pool来配置，这个是不对的（不清楚是不是老版本是这样的配置的，但是在springboot-starter-data-redis中这种写法不对）。首先是配置文件，由于我们使用的lettuce客户端，所以配置的时候，在spring.redis下加上lettuce再加上pool来配置，具体如下；</p>\n<pre><code>spring:\n  redis:\n    host: 10.255.144.111\n    port: 6379\n    password: 123456\n    database: 0\n    lettuce:\n      pool:\n        max-idle: 16\n        max-active: 32\n        min-idle: 8\n</code></pre>\n<p>如果使用的是jedis,就把lettuce换成jedis（同时要注意依赖也是要换的）。</p>\n<p>但是仅仅这在配置文件中加入，其实连接池是不会生效的。这里大家一定要注意，很多同学在配置文件上加上了这段就以为连接池已经配置好了，其实并没有，还少了最关键的一步，就是要导入一个依赖，不导入的话，这么配置也没有用。</p>\n<pre><code class=\"language-XML\">&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;\n    &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p>之后，连接池才会生效。我们可以做一个对比。 在导包前后，观察RedisTemplate对象的值就可以看出来。</p>\n<p>导入之前： </p>\n<p><img alt=\"\" height=\"920\" src=\"image\\8a92ff4393ec45fcbb83aa46732402fc.png\" width=\"1084\"/></p>\n<p></p>\n<p>导入之后：</p>\n<p><img alt=\"\" height=\"1006\" src=\"image\\95613ca8d4794c7aa353d6c35ee8c2f6.png\" width=\"1054\"/></p>\n<p></p>\n<p></p>\n<p>到入职后，我们的连接池信息才有值，这也印证了我们上面的结论。</p>\n<p>具体的配置信息我们可以看一下源代码，源码中使用RedisProperties 这个类来接收redis的配置参数。</p>\n<p><img alt=\"\" height=\"832\" src=\"image\\046885a0b5314e57a69358aa24480a3c.png\" width=\"992\"/></p>\n<p></p>\n<p></p>\n<h3>2.3 项目中使用</h3>\n<p>我们的配置工作准备就绪以后，我们就可以在项目中操作redis了，操作的话，使用spring-data-redis中为我们提供的 RedisTemplate 这个类，就可以操作了。我们先举个简单的例子，插入一个键值对（值为string）。</p>\n<pre><code class=\"language-java\">package com.lsqingfeng.springboot.controller;\n\nimport com.lsqingfeng.springboot.base.Result;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n/**\n * @className: RedisController\n * @description:\n * @author: sh.Liu\n * @date: 2022-03-08 14:28\n */\n@RestController\n@RequestMapping(\"redis\")\npublic class RedisController {\n\n    private final RedisTemplate redisTemplate;\n\n    public RedisController(RedisTemplate redisTemplate) {\n        this.redisTemplate = redisTemplate;\n    }\n\n    @GetMapping(\"save\")\n    public Result save(String key, String value){\n        redisTemplate.opsForValue().set(key, value);\n        return Result.success();\n    }\n\n}\n\n</code></pre>\n<h2>三、工具类封装</h2>\n<p>我们在前面的代码中已经通过RedisTemplate成功操作了redis服务器，比如set一个字符串，我们可以使用：</p>\n<pre><code class=\"language-java\">redisTemplate.opsForValue().set(key, value);\n</code></pre>\n<p></p>\n<p>来put一个String类型的键值对。而redis中可以支持 string, list, hash,set, zset五种数据格式，这五种数据格式的常用操作，都在RedisTemplate这个类中进行了封装。 操作string类型就是用opsForValue,操作list类型是用listOps, 操作set类型是用setOps等等。我们可以通过查看RedisTemplate这个类中的源码来了解大致有哪些功能。</p>\n<p><img alt=\"\" height=\"690\" src=\"image\\cc4793cddc6a498f8dfaf1b24350e050.png\" width=\"1044\"/></p>\n<p></p>\n<p>而这些功能都在这一个类中，使用起来其实并不是很方便，所有一般情况下，我们都是单独封装一个工具类，来把常用的一些方法进行抽象。操作的时候，直接通过工具类来操作。</p>\n<pre><code class=\"language-java\">\npackage com.lsqingfeng.springboot.utils;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.stereotype.Component;\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * @className: RedisUtil\n * @description:\n * @author: sh.Liu\n * @date: 2022-03-09 14:07\n */\n@Component\npublic class RedisUtil {\n\n    @Autowired\n    private RedisTemplate redisTemplate;\n    /**\n     * 给一个指定的 key 值附加过期时间\n     *\n     * @param key\n     * @param time\n     * @return\n     */\n    public boolean expire(String key, long time) {\n        return redisTemplate.expire(key, time, TimeUnit.SECONDS);\n    }\n    /**\n     * 根据key 获取过期时间\n     *\n     * @param key\n     * @return\n     */\n    public long getTime(String key) {\n        return redisTemplate.getExpire(key, TimeUnit.SECONDS);\n    }\n    /**\n     * 根据key 获取过期时间\n     *\n     * @param key\n     * @return\n     */\n    public boolean hasKey(String key) {\n        return redisTemplate.hasKey(key);\n    }\n    /**\n     * 移除指定key 的过期时间\n     *\n     * @param key\n     * @return\n     */\n    public boolean persist(String key) {\n        return redisTemplate.boundValueOps(key).persist();\n    }\n\n    //- - - - - - - - - - - - - - - - - - - - -  String类型 - - - - - - - - - - - - - - - - - - - -\n\n    /**\n     * 根据key获取值\n     *\n     * @param key 键\n     * @return 值\n     */\n    public Object get(String key) {\n        return key == null ? null : redisTemplate.opsForValue().get(key);\n    }\n\n    /**\n     * 将值放入缓存\n     *\n     * @param key   键\n     * @param value 值\n     * @return true成功 false 失败\n     */\n    public void set(String key, String value) {\n        redisTemplate.opsForValue().set(key, value);\n    }\n\n    /**\n     * 将值放入缓存并设置时间\n     *\n     * @param key   键\n     * @param value 值\n     * @param time  时间(秒) -1为无期限\n     * @return true成功 false 失败\n     */\n    public void set(String key, String value, long time) {\n        if (time &gt; 0) {\n            redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);\n        } else {\n            redisTemplate.opsForValue().set(key, value);\n        }\n    }\n\n    /**\n     * 批量添加 key (重复的键会覆盖)\n     *\n     * @param keyAndValue\n     */\n    public void batchSet(Map&lt;String, String&gt; keyAndValue) {\n        redisTemplate.opsForValue().multiSet(keyAndValue);\n    }\n\n    /**\n     * 批量添加 key-value 只有在键不存在时,才添加\n     * map 中只要有一个key存在,则全部不添加\n     *\n     * @param keyAndValue\n     */\n    public void batchSetIfAbsent(Map&lt;String, String&gt; keyAndValue) {\n        redisTemplate.opsForValue().multiSetIfAbsent(keyAndValue);\n    }\n\n    /**\n     * 对一个 key-value 的值进行加减操作,\n     * 如果该 key 不存在 将创建一个key 并赋值该 number\n     * 如果 key 存在,但 value 不是长整型 ,将报错\n     *\n     * @param key\n     * @param number\n     */\n    public Long increment(String key, long number) {\n        return redisTemplate.opsForValue().increment(key, number);\n    }\n\n    /**\n     * 对一个 key-value 的值进行加减操作,\n     * 如果该 key 不存在 将创建一个key 并赋值该 number\n     * 如果 key 存在,但 value 不是 纯数字 ,将报错\n     *\n     * @param key\n     * @param number\n     */\n    public Double increment(String key, double number) {\n        return redisTemplate.opsForValue().increment(key, number);\n    }\n\n    //- - - - - - - - - - - - - - - - - - - - -  set类型 - - - - - - - - - - - - - - - - - - - -\n\n    /**\n     * 将数据放入set缓存\n     *\n     * @param key 键\n     * @return\n     */\n    public void sSet(String key, String value) {\n        redisTemplate.opsForSet().add(key, value);\n    }\n\n    /**\n     * 获取变量中的值\n     *\n     * @param key 键\n     * @return\n     */\n    public Set&lt;Object&gt; members(String key) {\n        return redisTemplate.opsForSet().members(key);\n    }\n\n    /**\n     * 随机获取变量中指定个数的元素\n     *\n     * @param key   键\n     * @param count 值\n     * @return\n     */\n    public void randomMembers(String key, long count) {\n        redisTemplate.opsForSet().randomMembers(key, count);\n    }\n\n    /**\n     * 随机获取变量中的元素\n     *\n     * @param key 键\n     * @return\n     */\n    public Object randomMember(String key) {\n        return redisTemplate.opsForSet().randomMember(key);\n    }\n\n    /**\n     * 弹出变量中的元素\n     *\n     * @param key 键\n     * @return\n     */\n    public Object pop(String key) {\n        return redisTemplate.opsForSet().pop(\"setValue\");\n    }\n\n    /**\n     * 获取变量中值的长度\n     *\n     * @param key 键\n     * @return\n     */\n    public long size(String key) {\n        return redisTemplate.opsForSet().size(key);\n    }\n\n    /**\n     * 根据value从一个set中查询,是否存在\n     *\n     * @param key   键\n     * @param value 值\n     * @return true 存在 false不存在\n     */\n    public boolean sHasKey(String key, Object value) {\n        return redisTemplate.opsForSet().isMember(key, value);\n    }\n\n    /**\n     * 检查给定的元素是否在变量中。\n     *\n     * @param key 键\n     * @param obj 元素对象\n     * @return\n     */\n    public boolean isMember(String key, Object obj) {\n        return redisTemplate.opsForSet().isMember(key, obj);\n    }\n\n    /**\n     * 转移变量的元素值到目的变量。\n     *\n     * @param key     键\n     * @param value   元素对象\n     * @param destKey 元素对象\n     * @return\n     */\n    public boolean move(String key, String value, String destKey) {\n        return redisTemplate.opsForSet().move(key, value, destKey);\n    }\n\n    /**\n     * 批量移除set缓存中元素\n     *\n     * @param key    键\n     * @param values 值\n     * @return\n     */\n    public void remove(String key, Object... values) {\n        redisTemplate.opsForSet().remove(key, values);\n    }\n\n    /**\n     * 通过给定的key求2个set变量的差值\n     *\n     * @param key     键\n     * @param destKey 键\n     * @return\n     */\n    public Set&lt;Set&gt; difference(String key, String destKey) {\n        return redisTemplate.opsForSet().difference(key, destKey);\n    }\n\n\n    //- - - - - - - - - - - - - - - - - - - - -  hash类型 - - - - - - - - - - - - - - - - - - - -\n\n    /**\n     * 加入缓存\n     *\n     * @param key 键\n     * @param map 键\n     * @return\n     */\n    public void add(String key, Map&lt;String, String&gt; map) {\n        redisTemplate.opsForHash().putAll(key, map);\n    }\n\n    /**\n     * 获取 key 下的 所有  hashkey 和 value\n     *\n     * @param key 键\n     * @return\n     */\n    public Map&lt;Object, Object&gt; getHashEntries(String key) {\n        return redisTemplate.opsForHash().entries(key);\n    }\n\n    /**\n     * 验证指定 key 下 有没有指定的 hashkey\n     *\n     * @param key\n     * @param hashKey\n     * @return\n     */\n    public boolean hashKey(String key, String hashKey) {\n        return redisTemplate.opsForHash().hasKey(key, hashKey);\n    }\n\n    /**\n     * 获取指定key的值string\n     *\n     * @param key  键\n     * @param key2 键\n     * @return\n     */\n    public String getMapString(String key, String key2) {\n        return redisTemplate.opsForHash().get(\"map1\", \"key1\").toString();\n    }\n\n    /**\n     * 获取指定的值Int\n     *\n     * @param key  键\n     * @param key2 键\n     * @return\n     */\n    public Integer getMapInt(String key, String key2) {\n        return (Integer) redisTemplate.opsForHash().get(\"map1\", \"key1\");\n    }\n\n    /**\n     * 弹出元素并删除\n     *\n     * @param key 键\n     * @return\n     */\n    public String popValue(String key) {\n        return redisTemplate.opsForSet().pop(key).toString();\n    }\n\n    /**\n     * 删除指定 hash 的 HashKey\n     *\n     * @param key\n     * @param hashKeys\n     * @return 删除成功的 数量\n     */\n    public Long delete(String key, String... hashKeys) {\n        return redisTemplate.opsForHash().delete(key, hashKeys);\n    }\n\n    /**\n     * 给指定 hash 的 hashkey 做增减操作\n     *\n     * @param key\n     * @param hashKey\n     * @param number\n     * @return\n     */\n    public Long increment(String key, String hashKey, long number) {\n        return redisTemplate.opsForHash().increment(key, hashKey, number);\n    }\n\n    /**\n     * 给指定 hash 的 hashkey 做增减操作\n     *\n     * @param key\n     * @param hashKey\n     * @param number\n     * @return\n     */\n    public Double increment(String key, String hashKey, Double number) {\n        return redisTemplate.opsForHash().increment(key, hashKey, number);\n    }\n\n    /**\n     * 获取 key 下的 所有 hashkey 字段\n     *\n     * @param key\n     * @return\n     */\n    public Set&lt;Object&gt; hashKeys(String key) {\n        return redisTemplate.opsForHash().keys(key);\n    }\n\n    /**\n     * 获取指定 hash 下面的 键值对 数量\n     *\n     * @param key\n     * @return\n     */\n    public Long hashSize(String key) {\n        return redisTemplate.opsForHash().size(key);\n    }\n\n    //- - - - - - - - - - - - - - - - - - - - -  list类型 - - - - - - - - - - - - - - - - - - - -\n\n    /**\n     * 在变量左边添加元素值\n     *\n     * @param key\n     * @param value\n     * @return\n     */\n    public void leftPush(String key, Object value) {\n        redisTemplate.opsForList().leftPush(key, value);\n    }\n\n    /**\n     * 获取集合指定位置的值。\n     *\n     * @param key\n     * @param index\n     * @return\n     */\n    public Object index(String key, long index) {\n        return redisTemplate.opsForList().index(\"list\", 1);\n    }\n\n    /**\n     * 获取指定区间的值。\n     *\n     * @param key\n     * @param start\n     * @param end\n     * @return\n     */\n    public List&lt;Object&gt; range(String key, long start, long end) {\n        return redisTemplate.opsForList().range(key, start, end);\n    }\n\n    /**\n     * 把最后一个参数值放到指定集合的第一个出现中间参数的前面，\n     * 如果中间参数值存在的话。\n     *\n     * @param key\n     * @param pivot\n     * @param value\n     * @return\n     */\n    public void leftPush(String key, String pivot, String value) {\n        redisTemplate.opsForList().leftPush(key, pivot, value);\n    }\n\n    /**\n     * 向左边批量添加参数元素。\n     *\n     * @param key\n     * @param values\n     * @return\n     */\n    public void leftPushAll(String key, String... values) {\n//        redisTemplate.opsForList().leftPushAll(key,\"w\",\"x\",\"y\");\n        redisTemplate.opsForList().leftPushAll(key, values);\n    }\n\n    /**\n     * 向集合最右边添加元素。\n     *\n     * @param key\n     * @param value\n     * @return\n     */\n    public void leftPushAll(String key, String value) {\n        redisTemplate.opsForList().rightPush(key, value);\n    }\n\n    /**\n     * 向左边批量添加参数元素。\n     *\n     * @param key\n     * @param values\n     * @return\n     */\n    public void rightPushAll(String key, String... values) {\n        //redisTemplate.opsForList().leftPushAll(key,\"w\",\"x\",\"y\");\n        redisTemplate.opsForList().rightPushAll(key, values);\n    }\n\n    /**\n     * 向已存在的集合中添加元素。\n     *\n     * @param key\n     * @param value\n     * @return\n     */\n    public void rightPushIfPresent(String key, Object value) {\n        redisTemplate.opsForList().rightPushIfPresent(key, value);\n    }\n\n    /**\n     * 向已存在的集合中添加元素。\n     *\n     * @param key\n     * @return\n     */\n    public long listLength(String key) {\n        return redisTemplate.opsForList().size(key);\n    }\n\n    /**\n     * 移除集合中的左边第一个元素。\n     *\n     * @param key\n     * @return\n     */\n    public void leftPop(String key) {\n        redisTemplate.opsForList().leftPop(key);\n    }\n\n    /**\n     * 移除集合中左边的元素在等待的时间里，如果超过等待的时间仍没有元素则退出。\n     *\n     * @param key\n     * @return\n     */\n    public void leftPop(String key, long timeout, TimeUnit unit) {\n        redisTemplate.opsForList().leftPop(key, timeout, unit);\n    }\n\n    /**\n     * 移除集合中右边的元素。\n     *\n     * @param key\n     * @return\n     */\n    public void rightPop(String key) {\n        redisTemplate.opsForList().rightPop(key);\n    }\n\n    /**\n     * 移除集合中右边的元素在等待的时间里，如果超过等待的时间仍没有元素则退出。\n     *\n     * @param key\n     * @return\n     */\n    public void rightPop(String key, long timeout, TimeUnit unit) {\n        redisTemplate.opsForList().rightPop(key, timeout, unit);\n    }\n}\n</code></pre>\n<p>大家也可以通过阅读这个工具类，深入了解RedisTemplate的用法。使用的时候，只需要注入这个工具类就可以了。</p>\n<h2>四、讲讲序列化</h2>\n<p>redis的序列化也是我们在使用RedisTemplate的过程中需要注意的事情。上面的案例中，其实我们并没有特殊设置redis的序列化方式，那么它其实使用的是默认的序列化方式。RedisTemplate这个类的泛型是&lt;String,Object&gt;,也就是他是支持写入Object对象的，那么这个对象采取什么方式序列化存入内存中就是它的序列化方式。</p>\n<p>那么什么是redis的序列化呢？就是我们把对象存入到redis中到底以什么方式存储的，可以是二进制数据，可以是xml也可以是json。比如说我们经常会将POJO <a href=\"https://cloud.tencent.com/product/cos?from=10680\" title=\"对象存储\">对象存储</a>到 Redis 中，一般情况下会使用 JSON 方式序列化成字符串，存储到 Redis 中 。</p>\n<p>Redis本身提供了一下一种序列化的方式：</p>\n<ul><li>GenericToStringSerializer: 可以将任何对象泛化为字符串并序列化</li><li>Jackson2JsonRedisSerializer: 跟JacksonJsonRedisSerializer实际上是一样的</li><li>JacksonJsonRedisSerializer: 序列化object对象为json字符串</li><li>JdkSerializationRedisSerializer: 序列化java对象</li><li>StringRedisSerializer: 简单的字符串序列化</li></ul>\n<p>如果我们存储的是String类型，默认使用的是StringRedisSerializer 这种序列化方式。如果我们存储的是对象，默认使用的是 JdkSerializationRedisSerializer，也就是Jdk的序列化方式（通过ObjectOutputStream和ObjectInputStream实现，缺点是我们无法直观看到存储的对象内容）。</p>\n<p>我们可以根据redis操作的不同数据类型，设置对应的序列化方式。</p>\n<p><img alt=\"\" height=\"716\" src=\"image\\3e40aa252d924e19ab653c9c6829f46f.png\" width=\"1010\"/></p>\n<p></p>\n<p></p>\n<p>通过观察RedisTemplate的源码我们就可以看出来，默认使用的是JdkSerializationRedisSerializer. 这种序列化最大的问题就是存入对象后，我们很难直观看到存储的内容，很不方便我们排查问题：</p>\n<p><img alt=\"\" height=\"208\" src=\"image\\56f89558309d43fa978a5c358f8a901a.png\" width=\"1018\"/></p>\n<p></p>\n<p></p>\n<p>而一般我们最经常使用的对象序列化方式是： Jackson2JsonRedisSerializer</p>\n<p>设置序列化方式的主要方法就是我们在配置类中，自己来创建RedisTemplate对象，并在创建的过程中指定对应的序列化方式。</p>\n<pre><code class=\"language-java\">import com.fasterxml.jackson.annotation.JsonAutoDetect;\nimport com.fasterxml.jackson.annotation.PropertyAccessor;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.data.redis.connection.RedisConnectionFactory;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;\nimport org.springframework.data.redis.serializer.StringRedisSerializer;\n\n@Configuration\npublic class RedisConfig {\n    @Bean(name = \"redisTemplate\")\n    public RedisTemplate&lt;String, Object&gt; getRedisTemplate(RedisConnectionFactory factory) {\n        RedisTemplate&lt;String, Object&gt; redisTemplate = new RedisTemplate&lt;String, Object&gt;();\n        redisTemplate.setConnectionFactory(factory);\n        \n        StringRedisSerializer stringRedisSerializer = new StringRedisSerializer();\n        \n        redisTemplate.setKeySerializer(stringRedisSerializer); // key的序列化类型\n\n        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);\n        ObjectMapper objectMapper = new ObjectMapper();\n        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);\n        // 方法过期，改为下面代码\n//        objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);\n        objectMapper.activateDefaultTyping(LaissezFaireSubTypeValidator.instance ,\n                ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY);\n        jackson2JsonRedisSerializer.setObjectMapper(objectMapper);\n        jackson2JsonRedisSerializer.setObjectMapper(objectMapper);\n       \n        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer); // value的序列化类型\n        redisTemplate.setHashKeySerializer(stringRedisSerializer);\n        redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);\n        redisTemplate.afterPropertiesSet();\n        return redisTemplate;\n    }\n}\n</code></pre>\n<p>这样使用的时候，就会按照我们设置的json序列化方式进行存储，我们也可以在redis中查看内容的时候方便的查看到属性值。</p>\n<h2>五、分布式锁</h2>\n<p>参考资料：</p>\n<p><a href=\"https://www.cnblogs.com/wangyingshuo/p/14510524.html\" title=\"Redis实现分布式锁的7种方案 - why414 - 博客园\">Redis实现分布式锁的7种方案 - why414 - 博客园</a></p>\n<p>很多场景中，需要使用分布式事务、分布式锁等技术来保证数据最终一致性。有的时候，我们需要保证某一方法同一时刻只能被一个线程执行。<br/> 在单机（单进程）环境中，JAVA提供了很多并发相关API，但在多机（多进程）环境中就无能为力了。</p>\n<p>对于分布式锁，最好能够满足以下几点</p>\n<blockquote>\n<p>可以保证在分布式部署的应用集群中，同一个方法在同一时间只能被一台机器上的一个线程执行<br/> 这把锁要是一把可重入锁（避免死锁）<br/> 这把锁最好是一把阻塞锁<br/> 有高可用的获取锁和释放锁功能<br/> 获取锁和释放锁的性能要好</p>\n</blockquote>\n<p>分布式锁一般有三种实现方式：1. 数据库乐观锁；2. 基于Redis的分布式锁；3. 基于ZooKeeper的分布式锁。本篇文章主要介绍第二种方式。</p>\n<p>一个完美的分布式锁，必须要满足如下四个条件： 1.互斥性。在任意时刻，只有一个客户端能持有锁。<br/> 2.不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。<br/> 3.具有容错性。只要大部分的Redis节点正常运行，客户端就可以加锁和解锁。<br/> 4.解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。</p>\n<p>Redis分布式锁原理：</p>\n<p>锁的实现主要基于redis的<code>SETNX</code>命令</p>\n<p><strong>SETNX key value</strong>将 key 的值设为 value ，当且仅当 key 不存在。若给定的 key 已经存在，则 SETNX 不做任何动作。SETNX 是『SET if Not eXists』(如果不存在，则 SET)的简写。</p>\n<p>**返回值：**设置成功，返回 1 。设置失败，返回 0 。</p>\n<p>使用<code>SETNX</code>完成同步锁的流程及事项如下：</p>\n<ol><li>使用<code>SETNX</code>命令获取锁，若返回0（key已存在，锁已存在）则获取失败，反之获取成功</li><li>为了防止获取锁后程序出现异常，导致其他线程/进程调用<code>SETNX</code>命令总是返回0而进入死锁状态，需要为该key设置一个“合理”的过期时间</li><li>释放锁，使用<code>DEL</code>命令将锁数据删除</li></ol>\n<p>这篇文章中对于Redis中的锁的介绍还是比较全面的。</p>\n<p><a href=\"https://jishuin.proginn.com/p/763bfbd752ed\" title=\"Redis实现分布式锁的8大坑！切记！-技术圈\">Redis实现分布式锁的8大坑！切记！-技术圈</a></p>\n<p>Redis锁的实现方式很多，到时多多少少都有点问题，相对比较完美的方案是使用lua脚本。最完美的解决方案就是使用Redission这个框架里边的RedissionRedLock。具体实现就不给出了，大家可以按照这个思路去查找相关资料。等到我什么时候有时间和精力了再回来补充一下。</p>\n</div>\n</div>"}