{"blogid": "126741903", "writerAge": "码龄140天", "writerBlogNum": "125", "writerCollect": "7", "writerComment": "0", "writerFan": "4", "writerGrade": "4级", "writerIntegral": "1335", "writerName": "叶赫那拉 赫敏", "writerProfileAdress": "writer_image\\profile_126741903.jpg", "writerRankTotal": "19763", "writerRankWeekly": "8815", "writerThumb": "0", "writerVisitNum": "9728", "blog_read_count": "11", "blog_time": "于 2022-09-07 11:19:03 发布", "blog_title": "Lambda表达式介绍和底层实现分析", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p><strong>背景</strong></p>\n<p>如果你的需求需要匿名类来实现，例如是一个只有一个方法的接口，那么匿名类的语法可能看起来比较笨拙和不清晰，尽管匿名类比命名类更简洁，但对于只有一个方法的类来说，即使是匿名类也显得有些麻烦。还有在一些情况下，需要将功能作为参数传递给另一个方法，例如当有人单击页面上按钮时应该采取什么操作，javascript可以通过闭包实现。在java语言中，lambda表达式能够将功能视为方法参数，或将代码视为数据，而且lambda表达式可以更紧凑地表达单方法类的实例，在Swing编程和集合（Collections）编程中优势很明显。</p>\n<p>lambda表达式</p>\n<p>lambda表达式，也被称为闭包，它是推动 Java 8 发布的最重要新特性。lambda允许把函数作为一个方法的参数（函数作为参数传递进方法中）。</p>\n<pre><code>(parameters) -&amp;gt; expression或 (parameters) -&amp;gt;{ statements; }\n\n</code></pre>\n<p>可选类型声明</p>\n<p>不需要声明参数类型，编译器可以统一识别参数值；</p>\n<p>可选的参数圆括号</p>\n<p>一个参数无需定义圆括号，但多个参数需要定义圆括号；</p>\n<p>可选的大括号</p>\n<p>如果主体包含了一个语句，就不需要使用大括号；</p>\n<p>可选的返回关键字</p>\n<p>如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。</p>\n<pre><code>(int x, int y) -&amp;gt; x + y\n() -&amp;gt; 42\n(String s) -&amp;gt; { System.out.println(s); }\n\n</code></pre>\n<p>第一个 lambda 表达式接收 x 和 y 这两个整形参数并返回它们的和；第二个 lambda表达式不接收参数，返回整数 ‘42’；第三个 lambda 表达式接收一个字符串并把它打印到控制台，不返回值。</p>\n<p>了解使用lambda表达式，需要了解函数式接口，lambda用来代替内部类，赋予了Java简单但是强大的函数式编程能力，同时可以认为java支持命令式编程、声明式编程、函数式编程。</p>\n<p>函数式接口</p>\n<pre><code>public interface MyFunctionInterface&amp;lt;T&amp;gt; {\n    public T getValue(T t);\n}\n\n</code></pre>\n<pre><code>public class MyFunctionInterfaceTest {\n    public static void main(String[] args) {\n        testMethod(\"   aaaa  \", s -&amp;gt; s.trim());\n        testMethod(\"   aaaa  \", s -&amp;gt; s.trim().toUpperCase());\n    }\n\n    public static void testMethod(String str,     MyFunctionInterface&amp;lt;String&amp;gt; functionInterface) {\n        System.out.println(functionInterface.getValue(str));\n    }\n}\n\n</code></pre>\n<p>输出结果如下：</p>\n<pre><code>aaaa\nAAAA\n\n</code></pre>\n<pre><code>public interface MyFunctionInterface&amp;lt;T&amp;gt; {\n    public T getValue(T t);\n    public T returnValue(T t);\n}\n\n</code></pre>\n<p>增加一个方法之后，上面就不是函数式接口了，可以看到lambda表达式就会报错。</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\b1dedf8421d7b22e196524aa4e992fb6.png\"/></p>\n<pre><code>@FunctionalInterface\npublic interface MyFunctionInterface&amp;lt;T&amp;gt; {\n\n    public T getValue(T t);\n\n    default void defaultMethod() {\n        System.out.println(\"this is default method\");\n    }\n\n    static void staticMethod() {\n        System.out.println(\"this is static method\");\n    }\n\n\n    public boolean equals(Object obj);\n}\n\n</code></pre>\n<p>我们可以在接口上使用@FunctionalInterface注解，如果使用Intellij IDEA可以在编码的时候就看见报错了，这样做可以检查它是否是一个函数式接口。</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\5fb04b40022d25b12f7b462ce192b63b.png\"/></p>\n<p>通过反编译，可以看到函数式接口其实就是一个普通的java接口类，如下图</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\38924a2af41e18641bdc0363a12d60b8.png\"/></p>\n<p>函数式接口可以作为方法参数传递lambda表达式，但是为了将Lambda表达式作为参数传递，接收Lambda表达式的参数类型必须是与该Lambda表达式兼容的函数式接口的类型。但是我们没必要为每一个lambda表达式创建接口，在jdk的java.util.function包下面已经为我们创建了常用的函数式接口，其中比较核心的是消费型接口（Consumer&lt;T&gt;），供给型接口（Supplier&lt;T&gt;），断言型接口（Predicate&lt;T&gt;），函数型接口（Function&lt;T, R&gt;）四个接口，能够满足大部分应用场景。</p>\n<p>lambda表达式原理分析</p>\n<p>继续使用上面的测试代码，可以在IDEA中使用<br/> jclasslib Bytecode viewer<br/> 插件查看MyFunctionInterface.class源文件。</p>\n<p>安装完jclasslib Bytecode viewer，会在view菜单中出现如下两个选项</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\870a97a45d4ac923e3e18eb34a9d16aa.png\"/></p>\n<p>选择需要反编译的class文件，点击Show Bytecode with Jclasslib选项会出现如下界面</p>\n<p></p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\5ff585c444d88e91f925426326185e82.png\"/></p>\n<p><a href=\"https://ceshiren.com/uploads/default/original/3X/0/8/0818764424c5d6f08db28a397b7d3809931457b5.png\" title=\"1080×391 63 KB\">1080×391 63 KB</a></p>\n<p></p>\n<p>可以看到里面编译器多生成了lambda$main$0和lambda$main$1两个私有静态方法，属性当中多了InnerClasses。我们可以通过Show Bytecode查看一下测试类字节码更详细的反编译结果，找到这两个静态方法。</p>\n<pre><code>// access flags 0x100A\nprivate static synthetic lambda$main$1(Ljava/lang/String;)Ljava/lang/String;\n L0\n  LINENUMBER 6 L0\n  ALOAD 0\n  INVOKEVIRTUAL java/lang/String.trim ()Ljava/lang/String;\n  INVOKEVIRTUAL java/lang/String.toUpperCase ()Ljava/lang/String;\n  ARETURN\n L1\n  LOCALVARIABLE s Ljava/lang/String; L0 L1 0\n  MAXSTACK = 1\n  MAXLOCALS = 1\n\n// access flags 0x100A\nprivate static synthetic lambda$main$0(Ljava/lang/String;)Ljava/lang/String;\n L0\n  LINENUMBER 5 L0\n  ALOAD 0\n  INVOKEVIRTUAL java/lang/String.trim ()Ljava/lang/String;\n  ARETURN\n L1\n  LOCALVARIABLE s Ljava/lang/String; L0 L1 0\n  MAXSTACK = 1\n  MAXLOCALS = 1\n}\n\n</code></pre>\n<p>可以看到两个私有的静态方法干的就是Lambda表达式里面的内容，那么又是如何调用的生成的私有静态方法呢？如下图，通过分析main方法的L0，首先通过INVOKEDYNAMIC 指令调用是MyFunctionInterface的getValue方法的引用，以及后面的BootstrapMethods #0。使用jclasslib Bytecode viewer查看。</p>\n<p></p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\717b1a035540a75c80f2fb964eabc0ac.png\"/></p>\n<p><a href=\"https://ceshiren.com/uploads/default/original/3X/4/f/4f85cb47d8ab702e5bd52b4322c1ffa4a4ca12cd.png\" title=\"1042×446 28 KB\">1042×446 28 KB</a></p>\n<p></p>\n<p>点击#3，进入下面界面</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\8651ae49963a0feb0020ea998cd3c6b8.png\"/></p>\n<p>点击BootstrapMethods #0，进入如下界面</p>\n<p></p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\19d69c5e83b9b14e53dc65c9190ace05.png\"/></p>\n<p><a href=\"https://ceshiren.com/uploads/default/original/3X/d/3/d3def9192fdb996aa24a6a4170b68a6ea3cec660.png\" title=\"920×444 23.3 KB\">920×444 23.3 KB</a></p>\n<p></p>\n<p>点击cp_info #44,进入如下界面</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\0aa043663292fd416b73ad47b10ee379.png\"/></p>\n<p>继续点击相应的方法描述符，我们可以看到最后</p>\n<p></p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\2f56f9d08c2e23d07929c692f736325d.png\"/></p>\n<p><a href=\"https://ceshiren.com/uploads/default/original/3X/c/e/ce717d239e3d1041195de376bff62e9de14dd374.png\" title=\"1080×78 32 KB\">1080×78 32 KB</a></p>\n<p></p>\n<pre><code>(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n\n</code></pre>\n<p>可以看到INVOKEDYNAMIC 后面的一系列指令，最后使用INVOKESTATIC调用</p>\n<pre><code>java/lang/invoke/LambdaMetafactory.metafactory(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n\n</code></pre>\n<p>查看LambdaMetafactory.metafactory的方法，<br/> 里面通过InnerClassLambdaMetafactory生成了CallSite的子类ConstantCallSite，当通过指令调用CallSite会返回函数式接口的实例，而生成接口实例的方式是通过内部类的方式，由于方法比较深，就不继续贴代码了。</p>\n<pre><code>public static CallSite metafactory(MethodHandles.Lookup caller,\n                                   String invokedName,\n                                   MethodType invokedType,\n                                   MethodType samMethodType,\n                                   MethodHandle implMethod,\n                                   MethodType instantiatedMethodType)\n        throws LambdaConversionException {\n    AbstractValidatingLambdaMetafactory mf;\n    mf = new InnerClassLambdaMetafactory(caller, invokedType,\n                                         invokedName, samMethodType,\n                                         implMethod, instantiatedMethodType,\n                                         false, EMPTY_CLASS_ARRAY, EMPTY_MT_ARRAY);\n    mf.validateMetafactoryArgs();\n    return mf.buildCallSite();\n}\n\n</code></pre>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\c3390f2305d1a78abe28645a67e6cae8.png\"/></p>\n<p>CallSite持有<br/> com/para/lambda/MyFunctionInterfaceTest.lambda$main$0方法的句柄，这个句柄会调用该方法。</p>\n<p></p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\887a8f4ca0bca73242446d6d5e870f15.png\"/></p>\n<p><a href=\"https://ceshiren.com/uploads/default/original/3X/9/1/91947f4bf8e391488a553e68b3117d52c5c1cd4d.png\" title=\"952×129 9.05 KB\">952×129 9.05 KB</a></p>\n<p></p>\n<p>所以使用lambda表达式的地方，会在类编译的时候在本类中生成对应的私有静态方法和一个INNERCLASS的访问标识（具体是什么东西没找到资料，注释显示是一个访问标识），该访问标识会调用引导类加载器动态生成内部类，该内部类实现了函数式接口，在实现接口的方法中，会调用编译器生成静态方法，在使用lambda表达式的地方，通过传递内部类实例，来调用函数式接口方法。</p>\n<p>总结</p>\n<p>本文从lambda表达式、函数式接口的介绍和对lambda表达式底层原理的分析来认识java中的函数式编程。函数式接口本身就是一个普通的接口，而lambda表达式本质上和匿名内部类是一样的，只不过条件更加苛刻。使用lamda表达式可以以一种更优雅的方式来编程。</p>\n<p></p>\n</div>\n</div>"}