{"blogid": "125629022", "writerAge": "码龄1年", "writerBlogNum": "65", "writerCollect": "4803", "writerComment": "7282", "writerFan": "10024", "writerGrade": "7级", "writerIntegral": "13219", "writerName": "陈橘又青", "writerProfileAdress": "writer_image\\profile_125629022.jpg", "writerRankTotal": "833", "writerRankWeekly": "6", "writerThumb": "5003", "writerVisitNum": "365460", "blog_read_count": "13093", "blog_time": "已于 2022-07-19 13:17:56 修改", "blog_title": "软件设计实战：基于Java的俄罗斯方块游戏【完整版】", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p><strong> 个人简介</strong></p>\n<blockquote>\n<p>👨🏻‍💻个人主页：<a href=\"https://blog.csdn.net/m0_63947499?spm=1018.2226.3001.5343\" title=\"陈橘又青\">陈橘又青</a></p>\n<p>🏃🏻‍♂️博客记录心情，代码编写人生。</p>\n<p>🌟如果文章对你有用，麻烦关注点赞收藏走一波，感谢支持！</p>\n<p>🌱强力推荐我平时学习编程和准备面试的刷题网站：<a class=\"link-info\" href=\"https://www.nowcoder.com/link/pc_csdncpt_qing_java\" title=\"点这里\">点这里</a>！</p>\n</blockquote>\n<hr/>\n<p><strong>前言</strong></p>\n<blockquote>\n<p>大家好，今天用Java编程实现一个GUI界面的经典俄罗斯方块游戏，以下是完整的开发思路，供大家学习交流。</p>\n</blockquote>\n<p><strong>效果展示</strong></p>\n<p style=\"text-align:center;\"><img alt=\"2700e39389f845d28097f1d157732ab0.gif\" src=\"https://img-blog.csdnimg.cn/2700e39389f845d28097f1d157732ab0.gif\"/></p>\n<hr/>\n<p><strong>目录</strong></p>\n<p style=\"margin-left:0px;\"><a href=\"#%E4%B8%80%E3%80%81%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA\">一、效果展示</a></p>\n<p style=\"margin-left:40px;\">😊<a href=\"#1.%E6%B8%B8%E6%88%8F%E7%95%8C%E9%9D%A2\">1.游戏界面</a></p>\n<p style=\"margin-left:40px;\">😜<a href=\"#2.%E6%B8%B8%E6%88%8F%E7%BB%93%E6%9D%9F\">2.游戏结束</a></p>\n<p style=\"margin-left:0px;\"><a href=\"#%E4%BA%8C%E3%80%81%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D\">二、项目介绍</a></p>\n<p style=\"margin-left:40px;\"><a href=\"#1.%E9%A1%B9%E7%9B%AE%E8%83%8C%E6%99%AF\">1.项目背景</a></p>\n<p style=\"margin-left:40px;\"><a href=\"#2.%E6%80%BB%E4%BD%93%E9%9C%80%E6%B1%82\">2.总体需求</a></p>\n<p style=\"margin-left:80px;\">😍<a href=\"#%E2%91%A0%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91\">①游戏逻辑</a></p>\n<p style=\"margin-left:80px;\">🥰<a href=\"#%E2%91%A1%E6%B8%B8%E6%88%8F%E8%BF%87%E7%A8%8B\">②游戏过程</a></p>\n<p style=\"margin-left:80px;\">🤩<a href=\"#%E2%91%A2%E5%85%B6%E5%AE%83%E8%AE%BE%E8%AE%A1\">③其它功能</a></p>\n<p style=\"margin-left:0px;\"><a href=\"#%E4%B8%89%E3%80%81%E4%BB%A3%E7%A0%81%E5%B1%95%E7%A4%BA%20%C2%A0\">三、代码展示  </a></p>\n<p style=\"margin-left:40px;\">🤗<a href=\"#1.%E4%B8%BB%E7%B1%BB%E5%92%8C%E7%AA%97%E5%8F%A3%E8%AE%BE%E8%AE%A1\">1.主类和窗口设计</a></p>\n<p style=\"margin-left:40px;\">🤠<a href=\"#2.%E5%AD%90%E7%B1%BB%E5%92%8C%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0\">2.子类和方法实现</a></p>\n<p style=\"margin-left:0px;\"><a href=\"#%E5%9B%9B%E3%80%81%E6%80%BB%E7%BB%93\">四、项目总结</a></p>\n<hr/>\n<h1>一、效果展示</h1>\n<h2>1.游戏界面</h2>\n<p><img alt=\"533bb5279d7b43cda967d16b61feb9c9.png\" src=\"image\\533bb5279d7b43cda967d16b61feb9c9.png\"/></p>\n<h2>2.游戏结束</h2>\n<p><img alt=\"af7ee026616c448bbf6e6509cd4fc33a.png\" src=\"image\\af7ee026616c448bbf6e6509cd4fc33a.png\"/></p>\n<hr/>\n<h1>二、项目介绍</h1>\n<h2>1.项目背景</h2>\n<blockquote>\n<p><strong>“俄罗斯方块”</strong>是一个经典的游戏，在游戏中，由小方块组成的不同形状的板块陆续从屏幕上方落下来，玩家通过<u><em>调整板块的位置和方向</em></u>，使它们在屏幕底部拼出完整的横条。这些完整的横条会随即消失，给新落下来的板块腾出空间，同时，玩家得到分数奖励。未被消除掉的方块不断堆积起来，一旦堆到屏幕顶端，玩家便告输，游戏结束。</p>\n</blockquote>\n<h2>2.总体需求</h2>\n<h3>①游戏逻辑</h3>\n<blockquote>\n<p>（1）方块的诞生需要用随机原理，另外，它需要初始化的被放置在游戏界面的顶部。<br/> （2）方块需要自动下降，在下降过程中，还需判断它是否与周围环境发生冲突，能否继续下降。<br/> （3）方块本身可以变形，变形后的方块具有不同的数据，判断的方式又会不一样。<br/> （4）当用户一直按住 ↓ 键的时候，方块需要持续往下掉。</p>\n</blockquote>\n<h3>②游戏过程</h3>\n<blockquote>\n<p>（1） 左右操作。需要监听KeyEvent，让方块左右移动，直到碰到边界。<br/> （2） 变形操作。也要监听KeyEvent，让方块切换形状。<br/> （3） 下降操作。同样监听KeyEvent，让方块快速的下降。<br/> （4）当诞生的方块出世与其他方块冲突时，判定游戏结束。</p>\n</blockquote>\n<h3>③其它功能</h3>\n<blockquote>\n<p>（1）用户可以通过单击界面上提供的按钮，随时暂停与继续游戏 。</p>\n<p>（2）用户可以通过单机界面上提供的按钮，重新开始游戏。</p>\n</blockquote>\n<hr/>\n<h1>三、代码展示  </h1>\n<h2>1.主类和窗口设计</h2>\n<p><strong>设计游戏窗口的图形化界面以及各功能按钮。</strong></p>\n<pre><code>import java.awt.*;\nimport java.awt.event.*;\nimport java.io.*;\nimport java.util.*;\nimport javax.imageio.*;\nimport javax.swing.*;\nimport javax.swing.Timer;\npublic class MyGame extends JFrame {\n    public MyGame(){\n        GameBody gamebody=new GameBody();\n        gamebody.setBounds(5,10,500,600);  //\n        gamebody.setOpaque(false);\n        gamebody.setLayout(null);\n        addKeyListener(gamebody);\n        add(gamebody);\n        \n        int w=Toolkit.getDefaultToolkit().getScreenSize().width;\n        int h=Toolkit.getDefaultToolkit().getScreenSize().height;\n        final JButton login=new JButton(new ImageIcon(\"image/cxks.png\"));\n        login.setContentAreaFilled(false);\n        login.setMargin(new Insets(0,0,0,0));\n        login.setBorderPainted(false);\n        login.setBounds(340,320,120,26);\n        gamebody.add(login);\n\n        login.addActionListener(new ActionListener(){\n            public void actionPerformed(ActionEvent e) {    //登录的按钮\n                if(e.getSource()==login){\n                    requestFocus(true);    //获得焦点，不用失去焦点\n                    gamebody.resetMap();   //重置地图\n                    gamebody.drawWall();   //冲重新绘制边界墙体\n                    gamebody.createshape();   //重新产生新的地图\n                    gamebody.setStart(false);  //唤醒定时下落的线程\n                    gamebody.score=0;       //将分数置为零\n                    repaint();\n                }\n            }\n        });\n\n        final JButton pauselogin=new JButton(new ImageIcon(\"image/zt.png\"));\n        pauselogin.setContentAreaFilled(false);\n        pauselogin.setMargin(new Insets(0,0,0,0));\n        pauselogin.setBorderPainted(false);\n        pauselogin.setBounds(340,370,120,26);\n        gamebody.add(pauselogin);\n\n        pauselogin.addMouseListener(new MouseListener(){   //暂停的按钮\n            //鼠标点击事件，可以分别判断不同的事件，做出不同的反应\n            public void mouseClicked(MouseEvent e){\n                if(e.getButton()==e.BUTTON1 ){     //单击左键暂停\n                    gamebody.setStart(true);   //将自动下落线程关闭\n                    //requestFocus(true);    //同时整个JFrame失去焦点，无法操作，但可以点击按钮\n                }\n                else if(e.getButton()==e.BUTTON3 ){   //右击暂停，继续游戏\n                    gamebody.setStart(false);   //唤醒自动下落线程\n                    requestFocus(true);\n                }\n           /*     if(e.getClickCount()==2){     //左键双击，也可以继续游戏\n                    gamebody.setStart(false);\n                    requestFocus(true);\n                }*/\n            }\n            public void mouseEntered(MouseEvent e){}\n            public void mouseExited(MouseEvent e){}\n            public void mousePressed(MouseEvent e){}\n            public void mouseReleased(MouseEvent e){}\n\n        });\n\n        setTitle(\"俄罗斯方块\");\n        setResizable(false);\n        setFocusable(true);\n        setBounds((w-500)/2,(h-600)/2,500,600);\n        setLayout(null);\n\n        setVisible(true);\n        setDefaultCloseOperation(3);\n    }\n    public static void main(String[] args) {\n        new MyGame();\n    }\n</code></pre>\n<h2>2.子类和方法实现</h2>\n<p><strong>①创建需要定义的局部变量和游戏GameBody类。</strong></p>\n<pre><code>class GameBody extends JPanel implements KeyListener{\n        private int shapeType=-1;  //定义方块的类型  定义的为7种\n        private int shapeState=-1; //定义方块为何种状态，每种都有四种状态\n        private int nextshapeType=-1;  //定义下一块产生的类型\n        private int nextshapeState=-1;  //定义下一块的方块的状态\n        private final int CELL=25;   //定义方格的大小\n        private int score=0;    //定义显示的成绩\n        private int left;       //定义初始图形与两边的墙的距离\n        private int top;        //定义初始图形与上下墙的距离\n        private int i=0;        //表示列\n        private int j=0;        //表示行\n        public int flag=0;\n        public  volatile boolean start=false;  //暂停的判断条件，为轻量锁，保持同步的\n        Random randomcolor=new Random();\n        Random random=new Random();</code></pre>\n<p><strong>②定义地图的大小，初始化地图并画出围墙 。</strong></p>\n<pre><code>        //定义地图的大小，创建二位的数组\n        int[][] map=new int[13][23];\n\n        //初始化地图\n        public void resetMap(){\n            for(i=0;i&lt;12;i++){\n                for(j=0;j&lt;22;j++){  //遍历的范围不能小\n                    map[i][j]=0;\n                }\n            }\n        }\n\n        //画围墙的方法\n        public void drawWall(){\n            for(j=0;j&lt;22;j++)  //0到21行\n            {\n                map[0][j]=2;\n                map[11][j]=2;    //第0行和第11行为墙\n            }\n            for(i=0;i&lt;12;i++){  //0到11列\n                map[i][21]=2;    //第21行划墙\n            }\n        }</code></pre>\n<p><strong> ③定义随机的图形种类和产生图形的方法。</strong></p>\n<pre><code>private final int[][][] shapes=new int[][][]{\n                // i\n                {       { 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0 },\n                        { 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0 },\n                        { 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0 },\n                        { 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0 } },\n                // s\n                {\t\t{ 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },\n                        { 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 },\n                        { 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },\n                        { 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 } },\n                // z\n                {\t\t{ 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 },\n                        { 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 },\n                        { 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 },\n                        { 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 } },\n                // j\n                {\t\t{ 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0 },\n                        { 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 },\n                        { 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 },\n                        { 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },\n                // o\n                {\t\t{ 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },\n                        { 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },\n                        { 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },\n                        { 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },\n                // l\n                {\t\t{ 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0 },\n                        { 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },\n                        { 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 },\n                        { 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },\n                // t\n                {\t\t{ 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 },\n                        { 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 },\n                        { 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },\n                        { 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0 } }\n        };\n        //产生新图形的方法\n        public void createshape(){\n            if(shapeType==-1&amp;&amp;shapeState==-1){\n                shapeType = random.nextInt(shapes.length);\n                shapeState = random.nextInt(shapes[0].length);\n            }else{\n                shapeType=nextshapeType;\n                shapeState=nextshapeState;\n            }\n            nextshapeType = random.nextInt(shapes.length);\n            nextshapeState = random.nextInt(shapes[0].length);\n            //shapeType=(int)(Math.random()*1000)%7;   //在7中类型中随机选取\n            //shapeState=(int)(Math.random()*1000)%4;  //在四种状态中随机选取\n            left=4; top=0;  //图形产生的初始位置为（4,0）</code></pre>\n<p><strong>④判断游戏实时进行状态 。</strong></p>\n<pre><code>if(gameOver(left,top)==1){\n                resetMap();\n                drawWall();\n                score=0;\n                JOptionPane.showMessageDialog(null, \"GAME OVER\");\n            }\n        }\n        //遍历[4][4]数组产生的方块并判断状态\n        public int judgeState(int left,int top,int shapeType,int shapeState){\n            for(int a=0;a&lt;4;a++){\n                for(int b=0;b&lt;4;b++){\n                    if(((shapes[shapeType][shapeState][a*4+b]==1 &amp;&amp;   //遍历数组中为1的个数，即判断是否有图形\n                            map[left+b+1][top+a]==1))||                   //判断地图中是否还有障碍物\n                            ((shapes[shapeType][shapeState][a*4+b]==1 &amp;&amp;   //遍历数组中为1的个数，即判断是否有图形\n                                    map[left+b+1][top+a]==2))){                   //判断是否撞墙\n                        return 0;    //表明无法不能正常运行\n                    }\n                }\n            }\n            return 1;\n        }\n</code></pre>\n<p><strong>⑤创建键盘事件监听。</strong></p>\n<pre><code> public void keyPressed(KeyEvent e){\n            switch(e.getKeyCode()){\n                case KeyEvent.VK_LEFT:\n                    leftMove();//调用左移的方法\n                    repaint();\n                    break;\n                case KeyEvent.VK_RIGHT:\n                    rightMove();//调用右移的方法\n                    repaint();\n                    break;\n                case KeyEvent.VK_DOWN:\n                    downMove();//调用左移的方法\n                    repaint();\n                    break;\n                case KeyEvent.VK_UP:\n                    turnShape();//调用变形的方法\n                    repaint();\n                    break;\n            }\n            }\n        }\n        public void keyReleased(KeyEvent e) {\n        }\n        public void keyTyped(KeyEvent e) {\n        }\n        //创建左移的方法\n        public void leftMove(){\n            if(judgeState(left-1,top,shapeType,shapeState)==1){\n                left-=1;\n            }\n        }\n        //创建右移的方法\n        public void rightMove(){\n            if(judgeState(left+1,top,shapeType,shapeState)==1){\n                left+=1;\n            };\n        }\n        //创建下移的方法\n        public void downMove(){\n            if(judgeState(left,top+1,shapeType,shapeState)==1){  //判断有图形\n                top+=1;\n                deleteLine();   //判断下移后是否有满行\n            }\n            if(judgeState(left,top+1,shapeType,shapeState)==0){   //判断没有图形\n\n                addshape(left,top,shapeType,shapeState);\n                createshape();\n                deleteLine();\n            }\n        }\n        //创建旋转变形的方法\n        public void turnShape(){\n            int tempshape=shapeState;\n            shapeState=(shapeState+1)%4; //在四中的状态中选取\n            if(judgeState(left,top,shapeType,shapeState)==1){\n\n            }\n            if(judgeState(left,top,shapeType,shapeState)==0){\n                shapeState=tempshape;   //没有图形，不能进行旋转，还原原来状态\n            }\n            repaint();\n        }\n</code></pre>\n<p><strong>⑥绘制界面中的各文字及图形 。</strong></p>\n<pre><code>public void paintComponent(Graphics g){\n            super.paintComponent(g);\n            int t=randomcolor.nextInt(5);\n            int count=randomcolor.nextInt(5);\n            Color[] color=new Color[]{Color.pink,Color.green,Color.red,Color.yellow,Color.blue};\n            //绘制围墙\n            for(j=0;j&lt;22;j++){\n                for(i=0;i&lt;12;i++){\n                    if(map[i][j]==2){//判断是否为墙并绘制\n                        g.setColor(Color.blue);\n                        g.fill3DRect(i*CELL,j*CELL,CELL,CELL,true);\n                    }\n                    if(map[i][j]==0){//判断是否为墙并绘制\n                        g.setColor(Color.red);\n                        g.drawRoundRect(i*CELL,j*CELL,CELL,CELL,6,6);}\n                }\n            }\n            //绘制正在下落的图形\n            for(int k=0;k&lt;16;k++){\n                if(shapes[shapeType][shapeState][k]==1){\n                    g.setColor(Color.red);\n                    g.fill3DRect((left+k%4+1)*CELL,(top+k/4)*CELL,CELL,CELL,true);  //left\\top为左上角的坐标\n                }\n            }\n            //绘制落下的图形\n            for(j=0;j&lt;22;j++){\n                for(i=0;i&lt;12;i++){\n                    if(map[i][j]==1){\n                        g.setColor(Color.green);\n                        g.fill3DRect(i*CELL,j*CELL,CELL,CELL,true);\n                    }\n                }\n            }\n            //显示右边预览图形\n            for(int i = 0; i &lt; 4; i++) {\n                for(int j = 0; j &lt; 4; j++){\n                    if(shapes[nextshapeType][nextshapeState][i*4+j] == 1) {\n                        g.setColor(Color.red);\n                        g.fill3DRect(375+(j*(CELL-10)),190+(i*(CELL-10)), CELL-10, CELL-10,true);\n                    }\n                }\n            }\n            //添加右边预览图形方格\n            for(int i = 0; i &lt; 5; i++) {\n                for(int j = 0; j &lt; 5; j++){\n                    g.setColor(Color.blue);\n                    g.drawRoundRect(360+(j*(CELL-10)),175+(i*(CELL-10)),CELL-10, CELL-10,3,3);\n                }\n            }\n            g.setFont(new Font(\"楷书\",Font.BOLD,20));\n            g.setColor(Color.BLACK);\n            g.drawString(\"游戏分数:\", 310, 70);\n            g.setColor(Color.pink);\n            g.drawString(score+\" \", 420, 70);\n            g.setColor(Color.BLACK);\n            g.drawString(\"  分\", 450, 70);\n            g.setColor(Color.BLACK);\n            g.setFont(new Font(\"黑体\",Font.BOLD,14));\n            g.drawString(\"提示：左击暂停,右击继续。\", 305, 430);\n            g.setColor(Color.blue);\n            g.drawString(\"Next square\", 358, 268);\n        }\n        //创建添加新图形到地图的方法\n        public void addshape(int left,int top,int shapeType,int shapeState){\n            int temp=0;\n            for(int a=0;a&lt;4;a++){\n                for(int b=0;b&lt;4;b++){   //对存储方块队的[4][4]数组遍历\n                    if(map[left+b+1][top+a]==0){ //表明[4][4]数组没有方块\n\n                        map[left+b+1][top+a]=shapes[shapeType][shapeState][temp];\n                    }\n                    temp++;\n                }\n            }\n        }</code></pre>\n<p><strong>⑦创建监听器，消行方法等其它函数。</strong></p>\n<pre><code>public void deleteLine(){\n            int tempscore=0;      //定义满行的列个数满足1\n            for(int a=0;a&lt;22;a++){   //对地图进行遍历\n                for(int b=0;b&lt;12;b++){\n                    if(map[b][a]==1){    //表示找到满行\n                        tempscore++;     // 记录一行有多少个1\n                        if(tempscore==10){\n                            score+=10;\n                            for(int k=a;k&gt;0;k--){     //从满行开始回历\n                                for(int c=1;c&lt;12;c++){\n                                    map[c][k]=map[c][k-1];  //将图形整体下移一行\n                                }\n                            }\n                        }\n                    }\n                }\n                tempscore=0;\n            }\n        }\n        //判断游戏结束，1、判断新块的状态是否不存在，即judgeState()==0\n        //2、判断初始产生的位置是否一直为1；\n        public int gameOver(int left,int top){\n            if(judgeState(left,top,shapeType,shapeState)==0){\n                return 1;\n            }\n            return 0;\n        }\n        //创建构造方法\n        public GameBody(){\n            resetMap();\n            drawWall();\n            createshape();\n            //Timer timer=new Timer(1000,new TimeListener());\n            Thread timer=new Thread(new\tTimeListener());\n            timer.start();\n        }\n\n        public void setStart(boolean start){   //改变start值的方法\n            this.start=start;\n        }\n        //创建定时下落的监听器\n        class TimeListener implements Runnable{\n            public void run(){\n                while(true){\n                    if(!start){\n                        try{\n                            repaint();\n                            if(judgeState(left,top+1,shapeType,shapeState)==1){\n                                top+=1;\n                                deleteLine();}\n                            if(judgeState(left,top+1,shapeType,shapeState)==0){\n                                if(flag==1){\n                                    addshape(left,top,shapeType,shapeState);\n                                    deleteLine();\n                                    createshape();\n                                    flag=0;\n                                }\n                                flag=1;\n                            }\n                            Thread.sleep(800);\n                        }catch(Exception e){\n                            e.getMessage();\n                        }\n                    }\n                }\n            }\n        }\n    }\n} </code></pre>\n<hr/>\n<h1>四、项目总结</h1>\n<blockquote>\n<p><strong>Java语言是当今流行的网络编程语言，它具有面向对象、跨平台、分布应用等特点。而俄罗斯方块游戏的设计工作复杂且富有挑战性，它包含的内容多，涉及的知识广泛，与图形界面联系较大，包括界面的显示与更新、数据收集等，在设计的过程中，必将运用到各方面的知识，这对于设计者而言，是个很好的锻炼机会。<br/> 俄罗斯方块游戏的实现可以使开发者巩固所学基本知识，深刻掌握Java语言的重要概念及其面向对象的特性，增进Java语言编辑基本功，拓宽常用类库的应用，培养熟练地应用面向对象的思想和设计方法解决实际问题的能力，为今后从事实际开发工作打下坚实的基础。</strong></p>\n</blockquote>\n<hr/>\n<p style=\"text-align:center;\"><img alt=\"32a491a4058942ac8315607151375b3c.png\" src=\"image\\32a491a4058942ac8315607151375b3c.png\"/></p>\n<p></p>\n</div>\n</div>"}