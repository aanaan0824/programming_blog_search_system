{"blogid": "124142874", "writerAge": "码龄179天", "writerBlogNum": "2", "writerCollect": "31", "writerComment": "4", "writerFan": "2", "writerGrade": "1级", "writerIntegral": "39", "writerName": "雨 巷", "writerProfileAdress": "writer_image\\profile_124142874.jpg", "writerRankTotal": "187075", "writerRankWeekly": "364708", "writerThumb": "6", "writerVisitNum": "3634", "blog_read_count": "2625", "blog_time": "于 2022-04-13 11:22:26 发布", "blog_title": "Redis介绍和使用", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>一、redis简介<br/> 简单来说 redis 就是一个数据库，不过与传统数据库不同的是 redis 的数据是存在内存中的，所以读写速度非常快，因此 redis 被广泛应用于缓存方向。另外，redis 也经常用来做分布式锁。</p>\n<p>二、为什么要用 redis/为什么要用缓存？<br/> 主要从“高性能”和“高并发”这两点来看待这个问题。<br/> 高性能：<br/> 假如用户第一次访问数据库中的某些数据，这个过程会比较慢，因为是从硬盘上读取的。如果该用户访问的数据存在缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存是直接操作内存，所以速度相对硬盘要快很多。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！<br/> 高并发：<br/> redis适合少写多读，符合缓存的适用要求。<br/> 官方数据表示Redis读的速度是十几万次/s,写的速度是八万次左右/s 。单机redis支撑万级，如果十万以上建议用redis replication模式，也就是集群模式；</p>\n<p>三、redis 常见数据结构(5种)<br/> 1.String(字符串)</p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZuoIOW3tw==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\11a43788b1bc471ebd2ef6e8654fc359.jpg\"/>常用命令:set,get,decr,incr,mget 等。<br/> String数据结构是简单的key-value类型，value其实不仅可以是String，也可以是数字。 常规key-value缓存应用:常规计数、定时器并发控制等。</p>\n<p><br/> 2.Hash(哈希)</p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZuoIOW3tw==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\b619549a6d1a4c9ba95d3e1f7fed43c0.jpg\"/>常用命令:hget,hset,hgetall 等。<br/> hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值。 比如我们可以用 hash 数据结构来存储地址信息等。</p>\n<p><br/> 3.List(列表)</p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZuoIOW3tw==,size_17,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\0a7d1cb15e5b48fb8eff81eda7a8131b.jpg\"/>常用命令: lpush,rpush,lpop,rpop,lrange等<br/> list 就是链表，Redis list的应用场景非常多，比如消息队列就可以用Redis的 list 结构来实现。list 的实现为一个双向链表，即可以支持反向查找和遍历，方便操作，不过带来了部分额外的内存开销。</p>\n<p>4.Set(集合)</p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZuoIOW3tw==,size_16,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\f181fa87e411483689c21e5852af2d77.jpg\"/>常用命令： sadd,spop,smembers,sunion 等<br/> set 对外提供的功能与list类似是一个列表的功能，特殊之处在于 set是可以自动排重的。当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。可以基于 set 轻易实现交集、并集、差集的操作。<br/> 比如：在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程，具体命令如下：<br/> sinterstore key1 key2 key3     //将交集存在key1内</p>\n<p>5.zset(有序集合)</p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZuoIOW3tw==,size_15,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\f138c51c268d4c8fb0e489eedaf4f367.jpg\"/>常用命令： zadd,zrange,zrem,zcard等<br/> zset 类似于 Java 的 SortedSet 和 HashMap 的结合体，一方面它是一个 set，保证了内部 value 的唯一性，另一方面它可以给每个 value 赋予一个 score，代表这个 value 的排序权重。举例:在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜等信息，适合使用 Redis 中的 Sorted Set 结构进行存储。</p>\n<p>四、redis 设置过期时间(非特殊情况，redis都要设置过期时间！！！)<br/> redis中有个设置时间过期的功能，即对存储在 redis 数据库中的值可以设置一个过期时间。作为一个缓存数据库，这是非常实用的。如我们一般项目中的 token 或者一些登录信息，尤其是短信验证码都是有时间限制的，按照传统的数据库处理方式，一般都是自己判断过期，这样无疑会严重影响项目性能。<br/> 我们 set key 的时候，都可以给一个 expire time，就是过期时间，通过过期时间我们可以指定这个 key 可以存活的时间。</p>\n<p>现在假如我们设置了一个key的过期时间是五分钟，那么五分钟之后，redis是怎么对key进行删除的？（以下简单介绍，大家了解就好）<br/> 1.定期删除+惰性删除。<br/> 定期删除：redis默认是每隔 100ms 就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。注意这里是随机抽取的。为什么要随机呢？你想一想假如 redis 存了几十万个 key ，每隔100ms就遍历所有的设置过期时间的 key 的话，就会给 CPU 带来很大的负载！<br/> 惰性删除：定期删除可能会导致很多过期 key 到了时间并没有被删除掉。所以就有了惰性删除。假如你的过期 key，靠定期删除没有被删除掉，还停留在内存里，除非你的系统去查一下那个 key，才会被redis给删除掉。这就是所谓的惰性删除，也是够懒的哈！</p>\n<p>2.redis 内存淘汰机制<br/> 通过定期和惰性删除，还是有可能漏掉了很多过期 key（如果定期删除漏掉了很多过期 key，然后你也没及时去查，也就没走惰性删除），此时会怎么样？<br/> 后果：如果大量过期key堆积在内存里，导致redis内存块耗尽了。<br/> 怎么解决这个问题呢？<br/> redis 提供 6种数据淘汰策略：<br/> volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰<br/> volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰<br/> volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰<br/> allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）<br/> allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰<br/> no-eviction：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。（这个个人不建议使用）<br/> Redis4.0版本后增加以下两种：<br/> volatile-lfu：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰<br/> allkeys-lfu：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的key</p>\n<p>五、Redis常用命令<br/> 这里只列举本人在实际项目中常用到的redis命令，完整版可通过菜鸟教程相关章节了解。<br/> 完整命令网址:https://www.runoob.com/redis/redis-strings.html</p>\n<p>1.String字符串命令<br/> 1.1 set/get<br/> set key value</p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZuoIOW3tw==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\761a5f66f4cc45d58d034d414fb71627.png\"/>解释：设置指定 key 的值,将value关联到key。如果key已经持有其他值，则覆写旧值，无视类型。<br/> get key<br/> 解释:获取指定 key 的值,如果key不存在则返回null<br/> 应用场景：方法a整合统计得到值,set缓存该值，方法b使用get获取的情况。</p>\n<p>1.2 mGet<br/> MGET key1 [key2..]</p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZuoIOW3tw==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\b01f12a3114c43b99a04911e5eb5a652.png\"/>解释:获取所有(一个或多个)给定 key 的值,命令返回所有(一个或多个)给定 key 的值。 如果给定的 key 里面，有某个 key 不存在，那么这个 key 返回特殊值null<br/> 应用场景:一次性获取key为张三、李四、王五这三个对应的value值。</p>\n<p>1.3 incr/decr<br/> INCR key</p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZuoIOW3tw==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\cc0ea83d37e3499398c224cfb501d466.png\"/>解释:将key中储存的数字值加1，如果key不存在则自动创建并加1<br/> 应用场景:<br/> 1.统计每个设备被使用的次数,,每次累加1次。<br/> 2.定时器通过指定key对应的value值，判断方法是否执行过。<br/> Decr key（将 key 中储存的数字值减1）</p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZuoIOW3tw==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\3f62055b2bd449f182fbb31860880527.png\"/>解释和应用场景，参考incr。</p>\n<p>1.4 incrBy/decrBy<br/> INCRBY key increment<br/> 解释:将 key 所储存的值加上给定的增量值increment,INCR key相当于INCRBY key 1<br/> 应用场景:统计每个设备被使用的次数,每次累加increment次。<br/> DECRBY key decrement(key 所储存的值减去给定的减量值decrement)<br/> 解释和应用场景，参考incrBy</p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZuoIOW3tw==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\994c720f9eef40a2b36b5c9d3bf18b15.png\"/></p>\n<p>2. Hash哈希命令<br/> 2.1 Hdel<br/> HDEL key field1 [field2](删除一个或多个哈希表字段)</p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZuoIOW3tw==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\887a543aa0694adfbb397e6d8aa7af70.png\"/></p>\n<p>2.2 Hexists<br/> HEXISTS key field</p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZuoIOW3tw==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\02b6705a6a994b3aa39ee8c1f06b3522.png\"/>解释:查看哈希表 key 中，指定的字段是否存在。返回0(不存在)或者1(存在)<br/> 应用场景:哈希表里缓存着存在用户今日实时的消费，定时器方法通过判断哈希是否存在决定是否更新该用户mysql里的消费总金额。</p>\n<p><br/> 2.3 Hget<br/> HGET key field</p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZuoIOW3tw==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\ce181b9285f34a059a6e0f9d41f2dcd2.png\"/>解释:通过整个哈希表的key和哈希表里的key(field)中指定字段的值<br/> 应用场景:哈希表里存放某天的用户id对应的使用设备次数,通过日期和用户id获取这个用户的使用设备次数</p>\n<p>2.4 HgetAll<br/> HGETALL key</p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZuoIOW3tw==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\c2ebda2991d94012b27a49927a8073c5.png\"/>解释:获取在哈希表中指定 key 的所有字段和值。<br/> 应用场景:定时器方法获取哈希表所有字段和值，统计整合存入数据库。</p>\n<p><br/> 2.5 Hincrby<br/> HINCRBY key field increment </p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZuoIOW3tw==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\aa7bec9f71ba41f09a7e1cf0f3a6fc32.png\"/>解释:为哈希表 key 中的指定字段的整数值加上增量 increment<br/> 应用场景:因为小江表现优秀，老板决定给致上(哈希表key)的小江(指定字段)，工资加10块钱以表奖励。</p>\n<p>2.6 Hkeys<br/> HKEYS key</p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZuoIOW3tw==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\3d20caab44de4beb8cd6353c587940ad.png\"/>解释:获取哈希表key下所有的key<br/> 应用场景:哈希表记录今日的用户消费情况，现在想知道今日有哪些用户消费了</p>\n<p><br/> 2.7 Hlen<br/> HLEN key</p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZuoIOW3tw==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\9fd34e1affe34e4584a950cbca02fdc5.png\"/>解释：获取哈希表key下key的数量<br/> 应用场景:哈希表记录今日的用户消费情况，现在想知道今日有多少用户消费了</p>\n<p><br/> 2.8 Hmget<br/> HMGET key field1 [field2]</p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZuoIOW3tw==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\acca781c374b491fa31b972444081b27.png\"/>解释:获取所有给定字段的值<br/> 应用场景:哈希表记录今日的用户消费情况，现在想拿到今日张三李四王五这三个人的消费情况</p>\n<p>2.9 Hmset<br/> HMSET key field1 value1 [field2 value2 ]</p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZuoIOW3tw==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\418a88e5c2da4356a7e1ab0d43839b06.png\"/>解释:同时将多个 field-value (域-值)对新增到哈希表 key 中<br/> 应用场景:新增几台设备，将设备的属性新增进缓存设备属性的哈希表里</p>\n<p><br/> 2.10 Hset<br/> HSET key field value</p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZuoIOW3tw==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\cc6044c9a4424f2c850cee29c7d86ac8.png\"/>解释:将哈希表 key 中的字段 field 的值设为 value <br/> 应用场景:新增了一个设备，将设备的属性新增进缓存设备属性的哈希表里</p>\n<p><br/> 2.11 hsetnx<br/> HSETNX key field value</p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZuoIOW3tw==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\3cfb066763ad4498bc915d952a4b0cb9.png\"/>解释:用于为哈希表中不存在的的字段赋值<br/> 应用场景:哈希表记录今日的用户第一笔消费情况,当用户已存在哈希表里，不赋值。否则，赋值。</p>\n<p>3. list列表命令<br/> 3.1 Lrange<br/> LRANGE key start stop</p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZuoIOW3tw==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\ddbc25100da742c28a4594526d3b8e2e.png\"/>解释:获取列表指定范围内的元素,不会移除元素</p>\n<p>3.2 Llen<br/> LLEN key</p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZuoIOW3tw==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\08b600eee9984199a821cdf270bc1da3.png\"/>解释:获取列表的长度<br/> 应用场景:消息队列，获取队列list的长度，判断是否需要执行任务。如果长度为0，则表示无消息需要执行。</p>\n<p><br/> 3.3 Lpop<br/> LPOP key</p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZuoIOW3tw==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\c5854870d2ab4e2796d7e48c82e69126.png\"/>解释:获取并移除list左边第一个元素<br/> 应用场景:消息队列，按顺序处理。获取当前第一个元素，执行任务。</p>\n<p><br/> 3.4 lpush<br/> LPUSH key value1 [value2]</p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZuoIOW3tw==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\74739b1920254cd6a90e564e45aa1c36.png\"/>解释:将一个或多个值 value 插入到list列表 key 的表头 如果有多个 value 值，那么各个 value 值按从左到右的顺序依次插入到表头：比如对一个空列表 mylist 执行 LPUSH mylist a b c ，则结果列表为 c b a ，等同于执行执行命令 LPUSH mylist a 、 LPUSH mylist b 、 LPUSH mylist c<br/> 应用场景:消息队列，按顺序处理。vip用户优先发送消息，直接不讲道理插入队列表头。</p>\n<p><br/> 3.5 rpush<br/> RPUSH key value1 [value2]</p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZuoIOW3tw==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\6063d092ab614377be565f416e432e90.png\"/>解释:将一个或多个值 value 插入到List列表 key 的表尾(最右边)<br/> 应用场景:消息队列，按顺序处理。将需要处理的元素插入最右边，排队等待处理</p>\n<p>4. set集合命令<br/> 4.1 Sadd<br/> SADD key member1 [member2]</p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZuoIOW3tw==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\7cc2d1aee30146de96ef383968a364d8.png\"/>解释:将一个或者多个值放到set中<br/> 应用场景:用户可多次使用设备，set存放使用过设备的用户(去重)</p>\n<p><br/> 4.2 Sismember<br/> SISMEMBER key member</p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZuoIOW3tw==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\1c6a94e6a2b145228b91602383bdfe88.png\"/>解释:判断 member 元素是否是集合 key 的成员<br/> 应用场景:用户可多次使用设备，set存放使用过设备的用户,现在想知道某个用户有没有使用过</p>\n<p><br/> 4.3 Srandmember<br/> SRANDMEMBER key [count]</p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZuoIOW3tw==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\1a54e481383946e38f4f31c6711eea97.png\"/>解释:随机返回set中的count个数据<br/> 应用场景:从有获奖资格的用户里，抽取count个幸运用户</p>\n<p><br/> 4.4 scard<br/> SCARD key</p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZuoIOW3tw==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\36b50acc85f74a5e86ce00d149229a64.png\"/>解释:获取key集合的成员数<br/> 应用场景:用户可多次使用设备，set存放使用过设备的用户,现在想知道有多少用户使用过</p>\n<p>5. zset有序集合命令<br/> 5.1 Zadd<br/> ZADD key score1 member1 [score2 member2]</p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZuoIOW3tw==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\d753ab15da5f402f85c4d42fcb7648a2.png\"/>解释:向有序集合添加一个或多个成员，或者更新已存在成员的分数<br/> 应用场景:抽奖活动，抽奖规则与参加顺序有关。添加多位参与者。</p>\n<p>5.2 Zcard<br/> ZCARD key<br/><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZuoIOW3tw==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\1ffb851e97c24661a886755828867303.png\"/>解释:获取有序集合的成员数<br/> 应用场景:抽奖活动，抽奖规则与参加顺序有关。现在想知道有多少参与者。</p>\n<p>5.3 Zrange<br/> ZRANGE key start stop [WITHSCORES]</p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZuoIOW3tw==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\5221accd7ea54e5cb4ebb3e84760f0d6.png\"/>通过索引区间返回有序集合指定区间内的成员<br/>  </p>\n</div>\n</div>"}