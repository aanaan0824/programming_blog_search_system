{"blogid": "126636716", "writerAge": "码龄9年", "writerBlogNum": "173", "writerCollect": "476", "writerComment": "56", "writerFan": "139", "writerGrade": "7级", "writerIntegral": "11090", "writerName": "我爱看明朝", "writerProfileAdress": "writer_image\\profile_126636716.jpg", "writerRankTotal": "1434", "writerRankWeekly": "13124", "writerThumb": "124", "writerVisitNum": "1897127", "blog_read_count": "494", "blog_time": "于 2022-09-01 09:55:05 发布", "blog_title": "分布式锁的3种实现", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-light\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h1><a id=\"3_1\"></a>分布式锁的3种实现</h1>\n<p>我们在线上部署只有一个应用实例的时候，我们可用sychronized、lock来加锁，但是当部署了多个实例，实例间要对资源进行加锁，就要使用分布式锁了。</p>\n<p>我们这里介绍3种分布锁的实现方式：</p>\n<ol><li>db</li><li>redis</li><li>zk</li></ol>\n<h2><a id=\"_9\"></a>数据库</h2>\n<p>数据库实现分布式锁的原理有两种一种基于悲观锁，一种基于乐观锁。spring帮助我们提供了一套shedlock的分布式锁。</p>\n<ol><li>悲观锁 shedlock</li><li>乐观锁</li></ol>\n<h2><a id=\"zk_14\"></a>zk</h2>\n<p>我们知道zk的节点分为持久节点、持久顺序节点、临时节点、临时顺序节点。</p>\n<p>持久节点： 创建后一直存在，直到主动删除此节点。</p>\n<p>持久顺序节点：创建后一直存在，知道主动删除此节点，在zk中，每个父节点会为它的第一级子节点维护一份时序，记录每个子节点创建的先后顺序。</p>\n<p>临时节点：在客户端会话失效后节点自动清除，临时节点下面不能创建子节点。</p>\n<p>临时顺序节点；在客户端会话失效后节点自动清除，临时节点下面不能创建子节点。</p>\n<p>我们可以利用持久节点 + 临时顺序节点的特性来创建分布式锁。</p>\n<p>zk持久节点 + 临时顺序节点 ： 当客户端尝试获取锁，没有持久节点创建，同时创建临时顺<br/> 序节点，当临时顺序节点是最小的节点，则获取到锁，否则监听，当自己持有的临时顺序节点是最小的则获取锁。</p>\n<h2><a id=\"redis_33\"></a>redis</h2>\n<p>我们也可以利用redis的单线程特性，来实现分布式锁。</p>\n<ol><li>利用set和expire实现锁</li><li>利用set ex x nx</li><li>利用redisson</li><li>利用redisson + redlock</li></ol>\n<h2><a id=\"setexpire_40\"></a>set和expire</h2>\n<p>我们可以分别利用set命令实现加锁及expire处理死锁问题或进程意外退出没有释放锁。<br/> 这种方案有缺点就是set和expire不是原子执行，当set执行完进程崩溃了，锁就永远无法释放。</p>\n<h2><a id=\"set_ex_px_nx_44\"></a>set ex px nx</h2>\n<p>我们可以利用set ex px nx的方案来实现保障set和expire的原子性。</p>\n<p>但是设置过期时间这个方案有缺点，过期时间设置的长了，导致效率低下，太短又会存在过期时间太短，业务逻辑还未执行完，锁被释放了。</p>\n<h2><a id=\"redisson_49\"></a>redisson</h2>\n<p>redisson可以避免过期时间太长太短的问题，有一个守护进程，定时判断，锁是否存在，存在则延长锁的到期时间。<br/> redisson： 是一个在redis的基础上实现的java驻内存数据网路，redisson底层采用netty网络框架。</p>\n<h2><a id=\"redissonredlock_54\"></a>redisson封装的redlock</h2>\n<p>由于单台redis机器，会存在机器故障挂掉的可能性，因此在上面的基础上，又提出了redlock：5台不同步的master，当获得锁时分别从这5台机器上获取锁，当大于等于3台获取到锁，则认为获取到了锁。</p>\n<p>redisson给我们封装好了api。</p>\n<h2><a id=\"_61\"></a>参考</h2>\n<p><a href=\"https://blog.csdn.net/waltonhuang/article/details/106555195\">schedulerlock分布式锁原理</a></p>\n<p><a href=\"https://www.cnblogs.com/liuqingzheng/p/11080501.html\">什么是分布式锁？实现分布式锁的三种方式</a><br/> <a href=\"https://www.jianshu.com/p/7e47a4503b87\">redlock： redis分布式锁最牛逼的实现</a></p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}