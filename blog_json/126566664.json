{"blogid": "126566664", "writerAge": "码龄4年", "writerBlogNum": "58", "writerCollect": "9", "writerComment": "5", "writerFan": "3", "writerGrade": "3级", "writerIntegral": "632", "writerName": "dfnsyyds", "writerProfileAdress": "writer_image\\profile_126566664.jpg", "writerRankTotal": "30335", "writerRankWeekly": "24730", "writerThumb": "21", "writerVisitNum": "12441", "blog_read_count": "182", "blog_time": "于 2022-09-04 10:15:06 发布", "blog_title": "排序1：快速排序(三种)、归并排序、计数排序", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h1><a id=\"_2\"></a>快排</h1>\n<p><strong>1. hoare法</strong></p>\n<ul><li>思路：</li></ul>\n<blockquote>\n<ol><li>每次确定一个key【首元素】位置，从此分了两个区间：【0，key-1】，【key+1，end】。</li><li>每个内部排序是双循环：取第一个为key，R先走，R找小，L找大，注意不要越界。每次循环<strong>内部做交换，为交换大小值</strong>。最后<strong>外面再交换的是相遇位置和keyi做交换</strong>。</li><li>分析：L、R相遇位置是否永远能keyi做交换。即是否相遇位置永小于key。<br/> 如果L先遇R：因为<strong>R先起步，R位置停在小于key处</strong>，可以交换。<br/> 如果R先遇L：因为上次L交换完R，L处已经是小于key的值了。</li><li>总之，以R先找小的快排，最后<strong>直接交换相遇位置和keyi。</strong></li></ol>\n</blockquote>\n<p>代码分析：</p>\n<blockquote>\n<ol><li>局部Sort的参数：需要给L、R区间范围，已经数组名。<br/> 递归或非递归总体：需要给L、R、数组名，所以两个函数的参数一样。</li><li><strong>出错</strong>：递归的出口应该在快排本身上</li><li>每个partSort()中没有递归，只是在不断交换做key的定位。</li><li>R先行，找小，（等于也略过。） 先写越界判断再比较值，因C语言错误读不报错。</li><li><strong>递归出口</strong>：快排是不断在以key为间隔的两个区间做排序。递归出口是：L&gt;=R。什么时候可能：L&gt;=R：如果经过一轮快排，<strong>key定在末尾</strong>，那么<strong>右区间【key+1, end】，此时key+1&gt;end。</strong>，且左区间是:【L，keyi-1】，**不小心当然多写一个成【L,keyi】也没事。</li></ol>\n</blockquote>\n<ul><li>代码：</li></ul>\n<pre><code class=\"prism language-c\">\n<span class=\"token keyword\">int</span> <span class=\"token function\">partSort_hoare</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token operator\">*</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> L<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> R<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token keyword\">int</span> keyi <span class=\"token operator\">=</span> L<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> key <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>L<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>L <span class=\"token operator\">&lt;</span> R<span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\t<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>L<span class=\"token operator\">&lt;</span> R <span class=\"token operator\">&amp;&amp;</span> a<span class=\"token punctuation\">[</span>R<span class=\"token punctuation\">]</span> <span class=\"token operator\">&gt;=</span> key<span class=\"token punctuation\">)</span>\n\t\t\tR<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>L <span class=\"token operator\">&lt;</span> R <span class=\"token operator\">&amp;&amp;</span> a<span class=\"token punctuation\">[</span>L<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;=</span> key<span class=\"token punctuation\">)</span>\n\t\t\tL<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token function\">Swap</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">[</span>L<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">[</span>R<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token comment\">// 此时，两个应该相遇了，直接交换</span>\n\t<span class=\"token keyword\">int</span> meeti <span class=\"token operator\">=</span> L<span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">Swap</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">[</span>keyi<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">[</span>L<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">return</span> meeti<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">quickSortBy_hoare</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token operator\">*</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> L<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> R<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>L <span class=\"token operator\">&gt;=</span> R<span class=\"token punctuation\">)</span>\n\t\t<span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> keyi <span class=\"token operator\">=</span> <span class=\"token function\">partSort_hoare</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> L<span class=\"token punctuation\">,</span> R<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">quickSortBy_hoare</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> L<span class=\"token punctuation\">,</span> keyi<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">quickSortBy_hoare</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> keyi <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> R<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token keyword\">int</span> a<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{<!-- --></span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">11</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">44</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">7</span><span class=\"token punctuation\">,</span> <span class=\"token number\">66</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">quickSortBy_hoare</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">PrintArray</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n</code></pre>\n<ul><li>时间复杂度分析：</li></ul>\n<blockquote>\n<p>每次分为两个区间，时间复杂度是：树的深度次局部sort()，而每层接近堆n个数做排序移动，所以总体是<strong>O(NlogN)</strong>。</p>\n</blockquote>\n<ul><li>空间复杂度：</li></ul>\n<blockquote>\n<p>因为做栈递归，需要参数使用函数栈帧，也就是上面说的递归树的深度次，<strong>O(logN)</strong>。</p>\n</blockquote>\n<ul><li>稳定性分析：</li></ul>\n<blockquote>\n<p><strong>不稳定。比如 5， 5 ，6 ，7 ,1，2, 3</strong> 做快排，第一个5因为选为k，最后会在中间，和第二个5相对位置发生了改变。</p>\n</blockquote>\n<ul><li>犯过的错：<br/> <img alt=\"请添加图片描述\" src=\"image\\6ecb47b1583e42b89111c44033a8544c.png\"/></li></ul>\n<blockquote>\n<ol><li>要交换的是&amp;a[keyi]，而不是key值，我为了比较方便写了key变量。</li><li>递归是在Quick函数中，每次的partSort不做递归。</li></ol>\n</blockquote>\n<h3><a id=\"_78\"></a>当快排面对基本有序时，选取的数字过于小，每次做完，分的区间不够均匀，可能某一边过多、过少。</h3>\n<p><strong>2. 三数取中的挖坑法</strong></p>\n<ol><li>三数取中：<br/> 注意是<strong>要拿数组下标，所以传入数组。</strong></li></ol>\n<pre><code class=\"prism language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">getMidIndex</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token operator\">*</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> l<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> r<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token keyword\">int</span> mid <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>l <span class=\"token operator\">+</span> r<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>l<span class=\"token punctuation\">]</span><span class=\"token operator\">&gt;</span>a<span class=\"token punctuation\">[</span>r<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>r<span class=\"token punctuation\">]</span> <span class=\"token operator\">&gt;</span> a<span class=\"token punctuation\">[</span>mid<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\t\t\t<span class=\"token keyword\">return</span> r<span class=\"token punctuation\">;</span>\n\t\t<span class=\"token comment\">// mid &gt; r </span>\n\t\t<span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>l<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> a<span class=\"token punctuation\">[</span>mid<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\t\t\t<span class=\"token keyword\">return</span> l<span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">else</span>\n\t\t\t<span class=\"token keyword\">return</span> mid<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token comment\">// l&lt;r</span>\n\t<span class=\"token keyword\">else</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>mid<span class=\"token punctuation\">]</span> <span class=\"token operator\">&gt;</span> a<span class=\"token punctuation\">[</span>r<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\t\t\t<span class=\"token keyword\">return</span> r<span class=\"token punctuation\">;</span>\n\t\t<span class=\"token comment\">//  l &lt; r  , mid &lt; r 比mid 和l</span>\n\t\t<span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>mid<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> a<span class=\"token punctuation\">[</span>l<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\t\t\t<span class=\"token keyword\">return</span> l<span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">else</span>\n\t\t\t<span class=\"token keyword\">return</span> mid<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n</code></pre>\n<ol start=\"2\"><li>挖坑法快排：</li></ol>\n<ul><li>代码：</li></ul>\n<pre><code class=\"prism language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">getMidIndex</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token operator\">*</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> l<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> r<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token keyword\">int</span> mid <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>l <span class=\"token operator\">+</span> r<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>l<span class=\"token punctuation\">]</span><span class=\"token operator\">&gt;</span>a<span class=\"token punctuation\">[</span>r<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>r<span class=\"token punctuation\">]</span> <span class=\"token operator\">&gt;</span> a<span class=\"token punctuation\">[</span>mid<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\t\t\t<span class=\"token keyword\">return</span> r<span class=\"token punctuation\">;</span>\n\t\t<span class=\"token comment\">// mid &gt; r </span>\n\t\t<span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>l<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> a<span class=\"token punctuation\">[</span>mid<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\t\t\t<span class=\"token keyword\">return</span> l<span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">else</span>\n\t\t\t<span class=\"token keyword\">return</span> mid<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token comment\">// l&lt;r</span>\n\t<span class=\"token keyword\">else</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>mid<span class=\"token punctuation\">]</span> <span class=\"token operator\">&gt;</span> a<span class=\"token punctuation\">[</span>r<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\t\t\t<span class=\"token keyword\">return</span> r<span class=\"token punctuation\">;</span>\n\t\t<span class=\"token comment\">//  l &lt; r  , mid &lt; r 比mid 和l</span>\n\t\t<span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>mid<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> a<span class=\"token punctuation\">[</span>l<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\t\t\t<span class=\"token keyword\">return</span> l<span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">else</span>\n\t\t\t<span class=\"token keyword\">return</span> mid<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">partSort_hole</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token operator\">*</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> L<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> R<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token keyword\">int</span> mid <span class=\"token operator\">=</span> <span class=\"token function\">getMidIndex</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> L<span class=\"token punctuation\">,</span> R<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">Swap</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">[</span>mid<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">[</span>L<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> keyi <span class=\"token operator\">=</span> L<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> key <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>L<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> hole <span class=\"token operator\">=</span> keyi<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>L <span class=\"token operator\">&lt;</span> R<span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\t<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>L <span class=\"token operator\">&lt;</span> R <span class=\"token operator\">&amp;&amp;</span> key <span class=\"token operator\">&lt;=</span> a<span class=\"token punctuation\">[</span>R<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\t\t\tR<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n\t\ta<span class=\"token punctuation\">[</span>hole<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>R<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\t\thole <span class=\"token operator\">=</span> R<span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>L <span class=\"token operator\">&lt;</span> R <span class=\"token operator\">&amp;&amp;</span> a<span class=\"token punctuation\">[</span>L<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;=</span> key<span class=\"token punctuation\">)</span>\n\t\t\tL<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n\t\ta<span class=\"token punctuation\">[</span>hole<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>L<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\t\thole <span class=\"token operator\">=</span> L<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\ta<span class=\"token punctuation\">[</span>L<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> key<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> meeti <span class=\"token operator\">=</span> L<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">return</span> meeti<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">quickSortBy_hole</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token operator\">*</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> L<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> R<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>L <span class=\"token operator\">&gt;=</span> R<span class=\"token punctuation\">)</span>\n\t\t<span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> keyi <span class=\"token operator\">=</span> <span class=\"token function\">partSort_hole</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> L<span class=\"token punctuation\">,</span> R<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">quickSortBy_hole</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> L<span class=\"token punctuation\">,</span> keyi<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">quickSortBy_hole</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> keyi<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> R<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<ul><li>代码分析：</li></ul>\n<blockquote>\n<p>挖坑法<strong>和霍尔方法非常相似</strong>，但是记得要等号也要跳过，递归给出口，时刻要更新坑位。找到一个值后，把这个值填入上一个坑，随后坑位做更新。<br/> 且先取中间。<br/> R找小，找到小，就填坑。<br/> L找大 填坑。<br/> 最外面，相遇位置，填入key。<br/> 因为一开始keyi位置空出来了，把R找到小的填过来，小的前去了，之后L找到的大的，填到之前R找到的位置，R在后面，所以使得大的后去了</p>\n</blockquote>\n<ul><li><strong>遇到的BUG问题：</strong></li></ul>\n<ol><li>卡在指针挪不到后面了：F5按，<strong>L和R都卡着不动了</strong>。查旧的记录才反应过来，其实仔细想想，肯定是指针挪动的条件不符合了，我忽略了等于号。<br/> <strong>相等也应该掠过。</strong><br/> <strong>相等也应该掠过。</strong><br/> <strong>相等也应该掠过。</strong></li></ol>\n<p><img alt=\"请添加图片描述\" src=\"image\\c163d8cc051e4393b9432717b1617144.png\"/><br/> <strong>2. 还是卡着不动</strong><br/> <strong>递归没有出口</strong>：太阳你个麻麻，找了半个小时。<br/> <strong>快排是递归，要有出口，所有递归都要有出口</strong><br/> <strong>快排是递归，要有出口，所有递归都要有出口</strong><br/> <strong>快排是递归，要有出口，所有递归都要有出口</strong></p>\n<p><strong>3. 前后指针法【也利用三数取中】</strong><br/> 思路：【也先做三数取中】</p>\n<blockquote>\n<p>描述：prev和cur一开始挨着，且prev处是key值，cr找到大于等于key的值，就继续往后走，prev不动。【因为希望prev和cur之间夹着大于或等于key的值】cur找到小于，就和prev的下一个交换。总之，cur找到小就让prev++做交换。</p>\n<ol><li>使用指针：prev、cur。</li><li>prev一开始是keyi，cur是prev的下一个</li><li>cur遍历【1，R】，寻找所有小于key的位置。</li><li>当a【cur】&gt;=key，就略过，做加加：cur++，因为cur要找小。此时，prev和cur中间夹着大于和等于的值。</li><li>如果a【cur】&lt;key，prev++，prev来到了大于或等于的位置，可以与cur位置做交换。这样就使得cur位置的小于key的值挪到前面，prev位大于的值挪到后面了。这时cur继续加加，往后走。最后一轮下来，cur做完后，所有大的值都在靠后，而小的值在前。且此时，prev位置，一定是小于key的值，因为它之前与cur一直在做交换。</li><li>最后做keyi与prev的交换。且返回prev，因为位置固定了。</li></ol>\n</blockquote>\n<p>代码（普通版本）</p>\n<pre><code class=\"prism language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">partSort_frontAback</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token operator\">*</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> L<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> R<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token keyword\">int</span> key <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>L<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> keyi <span class=\"token operator\">=</span> L<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> cur <span class=\"token operator\">=</span> L <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> prev <span class=\"token operator\">=</span> L<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>cur <span class=\"token operator\">&lt;=</span> R<span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\t<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>cur<span class=\"token operator\">&lt;=</span>R <span class=\"token operator\">&amp;&amp;</span> a<span class=\"token punctuation\">[</span>cur<span class=\"token punctuation\">]</span><span class=\"token operator\">&gt;=</span>key<span class=\"token punctuation\">)</span>\n\t\t<span class=\"token punctuation\">{<!-- --></span>\n\t\t\tcur<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>cur <span class=\"token operator\">&lt;=</span> R <span class=\"token operator\">&amp;&amp;</span> a<span class=\"token punctuation\">[</span>cur<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> key<span class=\"token punctuation\">)</span>\n\t\t<span class=\"token punctuation\">{<!-- --></span>\n\t\t\tprev<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n\t\t\t<span class=\"token function\">Swap</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">[</span>cur<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">[</span>prev<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\tcur<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token function\">Swap</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">[</span>prev<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">[</span>keyi<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">return</span> prev<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">quickSortBy_frontAback</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token operator\">*</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> L<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> R<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>L <span class=\"token operator\">&gt;=</span> R<span class=\"token punctuation\">)</span>\n\t\t<span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> keyi <span class=\"token operator\">=</span> <span class=\"token function\">partSort_frontAback</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> L<span class=\"token punctuation\">,</span> R<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">quickSortBy_frontAback</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> L<span class=\"token punctuation\">,</span> keyi<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">quickSortBy_frontAback</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> keyi<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> R<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>代码（升级版）<br/> 改进思路：</p>\n<blockquote>\n<ol><li>cur处不管大于还是小于key都要往后走。</li><li>如果cur到了小于位置，但prev和cur挨着【prev下一位是cur】，那就prev只往后走【因为prev和cur之间只能夹着大于等于，小于要略过】，prev加加就行。</li></ol>\n</blockquote>\n<pre><code class=\"prism language-c\"><span class=\"token comment\">// 不管咋样，cur++。内部只有在cur小于时，才有prev的操作</span>\n<span class=\"token comment\">// 最后prev是小于位置</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">partSort_frontAback</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token operator\">*</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> L<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> R<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token keyword\">int</span> mid <span class=\"token operator\">=</span> <span class=\"token function\">getMidIndex</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> L<span class=\"token punctuation\">,</span> R<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">Swap</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">[</span>mid<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">[</span>L<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> key <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>L<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> keyi <span class=\"token operator\">=</span> L<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> prev <span class=\"token operator\">=</span> L<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> cur <span class=\"token operator\">=</span> L <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>cur<span class=\"token operator\">&lt;=</span>R<span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>cur<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> key<span class=\"token punctuation\">)</span>\n\t\t<span class=\"token punctuation\">{<!-- --></span>\n\t\t\tprev<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n\t\t\t<span class=\"token function\">Swap</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">[</span>prev<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">[</span>cur<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t\tcur<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token function\">Swap</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">[</span>prev<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">[</span>keyi<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">return</span> prev<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n</code></pre>\n<ul><li>代码分析：</li></ul>\n<blockquote>\n<p>总之，改进就是cur一直++，只有cur在小于key位置，才动prev，让prev++，再交换。最后再prev一定是小于位置，与开头交换。再返回prev。</p>\n</blockquote>\n<h3><a id=\"_277\"></a>快排的非递归写法</h3>\n<ul><li>思路：需要借助栈。把以前递归做的左右区间排序交给了栈去做，利用栈去存参数，然后取出去做排序。</li><li>注意点：</li></ul>\n<ol><li>如图，参数别混。<strong>我犯了错</strong></li><li>可以判断一下，该区间是否只有一个值。<br/> <img alt=\"请添加图片描述\" src=\"image\\975546b5b438447590c6eb12f78402d3.png\"/></li></ol>\n<ul><li>时间复杂度：<br/> 树的深度是logN次，而每次共n个数。总之<strong>O(NlogN)</strong>。</li><li>空间复杂度：<br/> 在栈递的调用上，需要树的深度层：O(logN)。</li></ul>\n<h1><a id=\"_288\"></a>归并排序</h1>\n<ul><li>整体流程：</li></ul>\n<p><img alt=\"请添加图片描述\" src=\"image\\df8d4f0c022a4836bd32f43a685e7767.png\"/><br/> 先递归拆分到只剩下一个值或没有值。</p>\n<p>将序列拆到每个数字一组（每个数字看作已有序的数组），然后两两合并，不断两两合并。<br/> 每个数字一组时的归并：第一组：比较两个数组的头进行比较，选取较小的，放到头部，发现左边已经空了，把右边依次放进去。第二组：同第一组。<img alt=\"请添加图片描述\" src=\"image\\a73720806df24c17a2f6b0c2b2a15aaa.png\"/><br/> 两个数字一组时的归并：<br/> 第一组：左序列和右序列头部左比较，<strong>右边头更小</strong>则挪到新数组中。如下<strong>挪9后，右序列头部变成了17</strong>，此时<strong>还是右边头更小</strong>，当一个序列（这里是右序列）空了后，把左边依次挪到到新数组中。<br/> <img alt=\"请添加图片描述\" src=\"image\\038469a553c74774b43f23927bcf084b.png\"/><br/> 但是有多余剩下了两组数据。<br/> 最后做两组的归并，还是比两个有序序列的头部，然后挪动到新数组。<img alt=\"请添加图片描述\" src=\"image\\1e7a9cdd63a04cb6b9a21ecc7ad3ba8e.png\"/><br/> <strong>递归思路：</strong><br/> <strong>所有子区间有序才可以做归并，所以递归拆到每个数组只剩下一个数</strong><br/> 做法：每次取中，然后从拆开。借助第三方数组做归并，归并到第三方数组，再把归并结果拷贝回原数组。再对原数组做归并。<br/> 什么时候是大于等于。</p>\n<ul><li>代码：</li></ul>\n<pre><code class=\"prism language-c\">\n<span class=\"token keyword\">void</span> <span class=\"token function\">_mergeSort</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token operator\">*</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token operator\">*</span> tmp<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> left<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> right<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>left <span class=\"token operator\">&gt;=</span> right<span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\t<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>left<span class=\"token operator\">&gt;</span>right<span class=\"token punctuation\">)</span>\n\t\t\t<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"存在大于情况\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token keyword\">int</span> mid <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>left <span class=\"token operator\">+</span> right<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">_mergeSort</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> tmp<span class=\"token punctuation\">,</span> left<span class=\"token punctuation\">,</span> mid<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">_mergeSort</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> tmp<span class=\"token punctuation\">,</span> mid<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> begin1 <span class=\"token operator\">=</span> left<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> end1 <span class=\"token operator\">=</span> mid<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> begin2 <span class=\"token operator\">=</span> mid<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> end2 <span class=\"token operator\">=</span> right<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> left<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>begin1 <span class=\"token operator\">&lt;=</span> end1 <span class=\"token operator\">&amp;&amp;</span> begin2 <span class=\"token operator\">&lt;=</span> end2<span class=\"token punctuation\">)</span>\n\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>begin1<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> a<span class=\"token punctuation\">[</span>begin2<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\t\t\ttmp<span class=\"token punctuation\">[</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>begin1<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">else</span>\n\t\t\ttmp<span class=\"token punctuation\">[</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>begin2<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>begin1 <span class=\"token operator\">&lt;=</span> end1<span class=\"token punctuation\">)</span>\n\t\ttmp<span class=\"token punctuation\">[</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>begin1<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>begin2<span class=\"token operator\">&lt;=</span>end2<span class=\"token punctuation\">)</span>\n\t\ttmp<span class=\"token punctuation\">[</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>begin2<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> left<span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;=</span> right<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n\t\ta<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> tmp<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n\n <span class=\"token keyword\">void</span> <span class=\"token function\">MergeSort</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token operator\">*</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token keyword\">int</span><span class=\"token operator\">*</span> tmp <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token operator\">*</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>tmp <span class=\"token operator\">==</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span>\n\t\t<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"malloc fail\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">_mergeSort</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> tmp<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">free</span><span class=\"token punctuation\">(</span>tmp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<ul><li>代码分析：</li></ul>\n<blockquote>\n<p>// 归并的核心：需要一个临时数组上做归并，再把结果返回给原始数组。<br/> // 归并需要两个有序的区间，且两个区间都有序所以一开始拆到单个数字【因为算有序】才行<br/> // 以mid拆，拆两个区间。<br/> // 递归不能一直这样下去，需要出口：left&gt;=right，=时，是只有一个数字，大于不存在。<br/> // 第一次下到这里来说明两个区间有序了。<br/> // 两个区间开始比较，比较需要两个都存在。<br/> // 在tmp上做归并：给tmp赋值，需要从left开始。<br/> // 赋值过程中已经做了++。所以while就够了<br/> // 最后再把归并结果给a：<br/> 最后注意参数：给的是n<br/> MergeSort(a, sizeof(a) / sizeof(int))。</p>\n</blockquote>\n<p>此外，<strong>所有递归且需要分区间去做的这种，都需要写一个核心递归子函数。</strong></p>\n<ul><li>过程的部分描述：<br/> 递归中，归并的两个区间，不一定长度一样，但是都一定有序。<br/> <img alt=\"请添加图片描述\" src=\"image\\be0ce793381b450bbb5eb15d1edc350f.png\"/></li><li><strong>过程的部分描述：</strong> 比如这里这一部分，看出，对于【0,4】=&gt;【0,2】【3,4】，其中【0,2】=&gt;【0，1】，【1，2】，其中【0,1】=&gt;【0，0】、【1,1】。<br/> 此时，【0,0】为参数调用merge_sort直接返回了，然后来到【1,1】，【1，1】也返回，来到了【0,1】这一段就往下走，排序好00和11。以【0,1】为左区间的【0,2】做完第一行递归。然后它继续做【2,2】，然后【2,2】直接有序，随后递归返回，做的是【0,2】的【0,1】和【2,2】的归并。<br/> 这里发现<strong>归并的递归实现，左右区间不一定等长，且不用担心左区间存在而右区间不存在，因为每次都会取中做拆分。</strong><br/> <strong>非递归的归并排序</strong><br/> 归并简单来说：<br/> 如下图，从a中取数字做归并拷贝到tmp中，再拷贝回a，再重复之前操作。<br/> <img alt=\"请添加图片描述\" src=\"image\\e09e94b0754048b6aceed479da9d0784.png\"/></li><li><strong>非递归写法</strong>：<br/> <strong>引言：</strong> 递归写法中，因为每次对区间求mid，然后分左右区间，所以所有区间都不是单一存在的，有一个区间就有另外一个和要做归并的区间。但是如果利用非递归写法，从【1,1】归并，然后【2,2】归并，最后【4，4】，过程中借助gap变量。而这样的<strong>缺点就是：</strong> <strong>需要判断归并整体能否按当前的gap完美划分</strong>。<br/> 总之，利用gap的变化，然后通过i控制第几组做归并，一组有两个区间，因为gap固定，gap是一个区间的数数量，因为递归有出口，判断到left&gt;=right会return，而非递归gap固定，会面临：</li></ul>\n<ol><li>第二个区间不够</li><li>第二个区间不存在</li><li>第一个区间不完整<br/> 以上三个情况，第二个和第三个都可以停止归并，而第一个需要修改end2的区间末尾。所以2、3情况合并后，可以写成 begin2&gt;=n。直接break。但是写end1&gt;=n不能包括第二个不存在的情况。所以写begin2&gt;=n。<br/> 如果是区间2不完整，因为经过了上面的begin2&gt;=n判断，没有做break。那么是end2&gt;=n后，做end2的修改：end2=n-1;继续做merge即可。</li><li>递归和非递归的表面区别是：非递归一次性做1个组的两个区间一般长度一致，而递归中1组的两个区间不一定长度一致。</li></ol>\n<ul><li>代码：</li></ul>\n<pre><code class=\"prism language-c\"> <span class=\"token keyword\">void</span> <span class=\"token function\">merge_NoR</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token operator\">*</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token operator\">*</span> tmp<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> begin1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> end1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> begin2<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> end2<span class=\"token punctuation\">)</span>\n <span class=\"token punctuation\">{<!-- --></span>\n\t <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> begin1<span class=\"token punctuation\">;</span>\n\t <span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> begin1<span class=\"token punctuation\">;</span>\n\t <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>begin1 <span class=\"token operator\">&lt;=</span> end1 <span class=\"token operator\">&amp;&amp;</span> begin2 <span class=\"token operator\">&lt;=</span> end2<span class=\"token punctuation\">)</span>\n\t <span class=\"token punctuation\">{<!-- --></span>\n\t\t <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>begin1<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> a<span class=\"token punctuation\">[</span>begin2<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\t\t\t tmp<span class=\"token punctuation\">[</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>begin1<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\t\t <span class=\"token keyword\">else</span>\n\t\t\t tmp<span class=\"token punctuation\">[</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>begin2<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\t <span class=\"token punctuation\">}</span>\n\t <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>begin1 <span class=\"token operator\">&lt;=</span> end1<span class=\"token punctuation\">)</span>\n\t\t tmp<span class=\"token punctuation\">[</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>begin1<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\t <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>begin2 <span class=\"token operator\">&lt;=</span> end2<span class=\"token punctuation\">)</span>\n\t\t tmp<span class=\"token punctuation\">[</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>begin2<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\t <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;=</span> end2<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n\t\t a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> tmp<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n <span class=\"token punctuation\">}</span>\n\n <span class=\"token comment\">// 思路是：对一个数组，gap个为1组，每两个gap，做归并。</span>\n <span class=\"token comment\">// 归并区间：0组：【0，0】和【1，1】，1组:【2,2】【3,3】</span>\n <span class=\"token comment\">//\t\t\t和下面对应起来了\ti=0,【0，0】，【1，1】之后，第二组，i=1时，【2,2】【3,3】</span>\n <span class=\"token comment\">// gap 一开始是1，第0组，区间1：[i, i+gap-1], 区间2[i+gap, i+2*gap-1]，</span>\n <span class=\"token comment\">// \t\t\t\t\t做第二组归并，i+=2gap：原因如下：</span>\n <span class=\"token comment\">//\t\t\t\t\t而i的范围：i不可以超过n-1，现在我不确定，i只小于n-1，那加上gap会不会超，</span>\n <span class=\"token comment\">//\t\t\t\t\t\t所以用i&lt;n判断即可，因为 i = i+2gap后，i超了n-1，就不用做了。</span>\n <span class=\"token comment\">//\t\t\t\t\t\t剩余情况，都在以下，第一个不够或第二个没有或不够。</span>\n <span class=\"token comment\">//\t\t\t\t\t一组两个区间共有2*gap数，下一组的起始是：i+2*gap，所以不是i++，是i+=2gap</span>\n <span class=\"token comment\">//\t\t\t\t\t如果此时，起始不存在，即 第一个区间数量不够</span>\n <span class=\"token comment\">// \t\t\t\t\t\t\t\t\t\t   第二个区间数量不够</span>\n <span class=\"token comment\">//\t\t\t\t\t\t\t\t\t\t   第二个区间不存在</span>\n <span class=\"token comment\">//\t\t\t\t\t如果第一个区间不够，不用归并，因为这个区间已经有序了，后序gap增大，一定会归并上的，它可能算第二个小区间不存在情况或不够情况或第一个不够的情况</span>\n <span class=\"token comment\">//\t\t\t\t\t\t第二个区间不存在，也不用归并，</span>\n <span class=\"token comment\">//\t\t\t\t\t\t第二个不够，改右区间为end2</span>\n <span class=\"token comment\">//\t\t\t\t\t    ```所以第一个不够和第二个不存在，是同一种情况，直接判断第二个不存在，不做归并</span>\n <span class=\"token comment\">//\t\t\t\t\t\t```所以只在意第二个不够的情况，改end</span>\n <span class=\"token comment\">//\t\t\t\t\t\t如果第二个不存在就不归并 \t，这个情况也包括了第一个不完整。或者第一个不完整的条件也一样\t\t\t\t</span>\n <span class=\"token comment\">//\t\t\t\t\t\t\t判断第二个区间不存在，begin2&gt;=n，说明2区间越界了。就停止。不做merge</span>\n <span class=\"token comment\">//\t\t\t\t\t\t   begin2&gt;=n和end1&gt;=n，都做break。左区间不够或第二个不存在，都不做归并。</span>\n <span class=\"token comment\">//\t\t\t\t\t\t```但是也判断第二个区间数量不够,end2&gt;=n，说明gap个数量的区间2，超了。</span>\n <span class=\"token comment\">//\t\t\t\t\t\t```修正end2，所以把变量都取出来，</span>\n <span class=\"token comment\">//\t\t\t\t\t\t\t\t使得作为begin和end变量都能变。</span>\n <span class=\"token comment\">//\t\t\t\t\t\t\t</span>\n <span class=\"token comment\">//\t\t\t\t\t\t```</span>\n <span class=\"token comment\">// gap需要变化。gap是每个区间中数的数量，一开始是1。对gap做循环</span>\n <span class=\"token comment\">// </span>\n <span class=\"token keyword\">void</span> <span class=\"token function\">MergeSort_NoR</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token operator\">*</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span>\n <span class=\"token punctuation\">{<!-- --></span>\n\t <span class=\"token keyword\">int</span><span class=\"token operator\">*</span> tmp <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token operator\">*</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>tmp <span class=\"token operator\">==</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span>\n\t <span class=\"token punctuation\">{<!-- --></span>\n\t\t <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"malloc fail \\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t <span class=\"token function\">exit</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t <span class=\"token punctuation\">}</span>\n\t <span class=\"token keyword\">int</span> gap <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\t <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>gap <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">)</span>\n\t <span class=\"token punctuation\">{<!-- --></span>\n\t\t <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">+=</span><span class=\"token number\">2</span><span class=\"token operator\">*</span>gap<span class=\"token punctuation\">)</span>\n\t\t <span class=\"token punctuation\">{<!-- --></span>\n\t\t\t <span class=\"token keyword\">int</span> begin1 <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n\t\t\t <span class=\"token keyword\">int</span> end1 <span class=\"token operator\">=</span> i <span class=\"token operator\">+</span> gap <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\t\t\t <span class=\"token keyword\">int</span> begin2 <span class=\"token operator\">=</span> i <span class=\"token operator\">+</span> gap<span class=\"token punctuation\">;</span>\n\t\t\t <span class=\"token keyword\">int</span> end2 <span class=\"token operator\">=</span> i <span class=\"token operator\">+</span> <span class=\"token number\">2</span> <span class=\"token operator\">*</span> gap <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\t\t\t <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>end1 <span class=\"token operator\">&gt;=</span> n<span class=\"token punctuation\">)</span>\n\t\t\t\t <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n\t\t\t <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>end2 <span class=\"token operator\">&gt;=</span> n<span class=\"token punctuation\">)</span>\n\t\t\t\t end2 <span class=\"token operator\">=</span> n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\t\t\t <span class=\"token function\">merge_NoR</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> tmp<span class=\"token punctuation\">,</span> begin1<span class=\"token punctuation\">,</span> end1<span class=\"token punctuation\">,</span> begin2<span class=\"token punctuation\">,</span> end2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t <span class=\"token punctuation\">}</span>\n\t\t gap <span class=\"token operator\">*=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n\t <span class=\"token punctuation\">}</span>\n\t <span class=\"token function\">free</span><span class=\"token punctuation\">(</span>tmp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n <span class=\"token punctuation\">}</span>\n\n</code></pre>\n<ul><li>犯的错：<br/> 如下图：我犯了的错，发现排序结果数组a没有改变，调试F11发现每趟归并时，tmp改变了而a没有变，然后代码运行中最下面的赋值循环没进去，所以断定是范围给错了，最后再查，发现是赋值的时候，使用j=i，不能在for下面定义，此时i已经变了，<strong>int j = begin1应该放在最开始。</strong><br/> <img alt=\"请添加图片描述\" src=\"image\\112db51d684b4a5c80983465ec70d55e.png\"/></li><li>归并时间复杂度：<br/> 从递归上理解，相当于每次做n个数的排序，然后做logn层。所以是Onlogn。<br/> <img alt=\"请添加图片描述\" src=\"image\\df8d4f0c022a4836bd32f43a685e7767.png\"/></li><li>归并空间复杂度：<br/> 递归的栈调用相当于树的深度：O(logn)。</li><li>归并的稳定性：<br/> 归并是稳定的，因为归并两个区间都是挨着的，可以让相等情况不挪动，能保证稳定。</li></ul>\n<h1><a id=\"_480\"></a>内排序和外排序</h1>\n<ul><li>内排序：在内存中就可以排序。</li><li>外排序：数据量较大，比如有10亿个整数，内存中放不下，数据在磁盘文件中，需要外排序。<br/> 归并排序既适应外排序、又适应内排序。</li><li>场景：<br/> <img alt=\"请添加图片描述\" src=\"image\\2c0e39b2d5194191a1030ab7f34a5a41.png\"/><br/> 分析：10亿整数，40亿字节（<strong>10亿字节=1G</strong>），数据4G，内存512M，需要切8份数据。<br/> 做法：可以切文件，但是切到每份文件1个再排序太费劲了。所以可以对该文件每次读1/8，然后先对这1/8做排序，再存为一个文件。最后得到8个排序好的子文件。<br/> 如下图：得到8个有序小文件。<br/> <img alt=\"请添加图片描述\" src=\"image\\448309335e374b67b77318f6514215b3.png\"/><br/> 接着，小文件两两归并：生成大小为2倍的当中进行归并。<br/> <img alt=\"请添加图片描述\" src=\"image\\9322efe8bdf94cd781c8eb8a061bbbe9.png\"/><br/> 其中A1、A2做归并，并不会直接将两个512MB的文件读入到内存，而是从两个文件中每次读取一个数字进内存，然后进行比较，小的再写入归并后的文件。<br/> 之后操作1G文件，读取也只是从两个1G文件中读取1个数字，<strong>512MB内存没问题，并不是一次性打开1G文件。</strong>（打游戏同理，并不是直接在内存中打开几十G的游戏文件）</li></ul>\n<h1><a id=\"_496\"></a>比较排序</h1>\n<ul><li>介绍：这是一种统计密集数据的计数方式。适合比较数据较密集的数组。</li><li>思想：先创建临时数组count，数量与待排序的a同为n，且利用memset把数组初始化为0。第一次对待排序数组a遍历找出【a】max、min。第二次遍历时用每个a【i】- min，得到差j，在差位置j处做++，该数字有几个，就会加几次。最后，通过遍历count数组，如果当前cout【j】不是0，说明有值，且因为j是数组中数字与min的差，所以通过遍历count【j】先遍历到的，就是a中的较小小值，加上min，就是原始值。</li><li>注意点：<br/> 巧妙之处：</li></ul>\n<ol><li>存count时，给下标为a【i】-min位置做++。这样在当前数与min的差值处存了值，且count【j】值++次数数字表示有几个数相同。此外，<strong>做a【i】- min时已经在做排序了。</strong></li><li>在给a返值时，通过遍历count【j】，此外用while【count–】，可以对a赋值相同数字次数。给a值时，用j+min，得到原始值。</li></ol>\n<pre><code class=\"prism language-c\"><span class=\"token keyword\">void</span> <span class=\"token function\">CountSort</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token operator\">*</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token keyword\">int</span> max <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> min <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">&gt;</span> max<span class=\"token punctuation\">)</span>\n\t\t\tmax <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> min<span class=\"token punctuation\">)</span>\n\t\t\tmin <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token keyword\">int</span> range <span class=\"token operator\">=</span> max <span class=\"token operator\">-</span> min <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span><span class=\"token operator\">*</span> count <span class=\"token operator\">=</span> <span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token operator\">*</span>range<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">memset</span><span class=\"token punctuation\">(</span>count <span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token operator\">*</span>range<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\tcount<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">-</span> min<span class=\"token punctuation\">]</span><span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> range<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\t<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>count<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token operator\">--</span><span class=\"token punctuation\">)</span>\n\t\t<span class=\"token punctuation\">{<!-- --></span>\n\t\t\ta<span class=\"token punctuation\">[</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> j<span class=\"token operator\">+</span>min<span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">}</span>\n\n</code></pre>\n<h1><a id=\"_534\"></a>时间复杂度分析：</h1>\n<p>归并排序：<br/> 宏观上，虽然每一层的区间数量不同，但是每层总共对N个数字做归并，高度是LogN，所以总时间复杂度：O(NlogN)。<br/> 希尔排序：<br/> 时间复杂度O(n^1.3)<br/> <img alt=\"请添加图片描述\" src=\"image\\61d48012d8904f98938646fcf340eaa8.png\"/><br/> 缺点：需要O(N)时间复杂度</p>\n<p>注意快排和归并排序传入的参数大小不一样。</p>\n<h1><a id=\"_544\"></a>稳定性分析</h1>\n<p>冒泡、插入、归并是稳定的，剩下都不稳定</p>\n<h1><a id=\"_547\"></a>冒泡</h1>\n<pre><code class=\"prism language-c\"><span class=\"token keyword\">void</span> <span class=\"token function\">BubbleSort</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token operator\">*</span>a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&gt;=</span> i <span class=\"token punctuation\">;</span> j<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span>\n\t\t<span class=\"token punctuation\">{<!-- --></span>\n\t\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> a<span class=\"token punctuation\">[</span>j <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\t\t\t\t<span class=\"token function\">Swap</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">[</span>j<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>思路：<br/> 每次让最大或最小的下去或上去，且遍历范围每次要少1。所以必须双层循环。</p>\n<blockquote>\n<ol><li>双层循环外层控制每次固定的位置，范围：i：【0, n-2】，因为n个数，做n-1次排序即可。剩余一个绝对有序。</li><li>内层循环，j = i，相当于依次固定【0，n-1】中第一个，让小于上浮，让j减减，所以j&gt;=i，不必&gt;= 0，因为每次固定最上面一个。<br/> 稳定性分析：</li></ol>\n</blockquote>\n<p><strong>冒泡排序是稳定的</strong>，因为遇到等于情况，可以不做交换。</p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}