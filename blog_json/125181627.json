{"blogid": "125181627", "writerAge": "码龄3年", "writerBlogNum": "5", "writerCollect": "570", "writerComment": "11", "writerFan": "85", "writerGrade": "2级", "writerIntegral": "155", "writerName": "程序员_Cc", "writerProfileAdress": "writer_image\\profile_125181627.jpg", "writerRankTotal": "90551", "writerRankWeekly": "115329", "writerThumb": "92", "writerVisitNum": "37475", "blog_read_count": "26338", "blog_time": "于 2022-06-09 15:11:01 发布", "blog_title": "2022年最新前端面试题，持续更新", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>【js面试题】<br/> 1、js数据类型</p>\n<pre><code>基本数据类型\nNumber、String、Boolean、Null、Undefined、Symbol、bigInt\n引用数据类型\nobject、Array、Date、Function、RegExp</code></pre>\n<p>2、js变量和函数声明的提升</p>\n<pre><code>在js中变量和函数的声明会提升到最顶部执行\n函数的提升高于变量的提升\n函数内部如果用 var 声明了相同名称的外部变量，函数将不再向上寻找。\n匿名函数不会提升。</code></pre>\n<p>3、闭包</p>\n<pre><code>闭包就是能够读取其他函数内部变量的函数\n闭包基本上就是一个函数内部返回一个函数\n好处\n可以读取函数内部的变量\n将变量始终保持在内存中\n可以封装对象的私有属性和私有方法\n坏处\n比较耗费内存、使用不当会造成内存溢出的问题</code></pre>\n<p>4、== 和 ===的区别</p>\n<pre><code>==是非严格意义上的相等\n值相等就相等\n===是严格意义上的相等，会比较两边的数据类型和值大小\n值和引用地址都相等才相等</code></pre>\n<p>5、this</p>\n<pre><code>this总是指向函数的直接调用者\n如果有new关键字，this指向new出来的对象\n在事件中，this指向触发这个事件的对象</code></pre>\n<p>6、js数组和对象的遍历方式</p>\n<pre><code>for in\nfor\nforEach\nfor-of</code></pre>\n<p>7、map与forEach的区别</p>\n<pre><code>forEach 方法，是最基本的方法，就是遍历与循环，默认有 3 个传参：分别是遍历的数组内\n容 item、数组索引 index、和当前遍历数组 Array\nmap 方法，基本用法与 forEach 一致，但是不同的，它会返回一个新的数组，所以 callback\n需要有 return 值，如果没有，会返回 undefined</code></pre>\n<p>8、箭头函数与普通函数的区别?</p>\n<pre><code>函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象\n不可以当作构造函数，也就是说，不可以使用 new 命令，否则会抛出一个错误\n不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 Rest 参数代替\n不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数</code></pre>\n<p>9、同源策略</p>\n<pre><code>同源指的是域名、协议、端口号相同</code></pre>\n<p>10、如何解决跨域</p>\n<pre><code>jsonp跨域\ndocument.domain + iframe 跨域\nnodejs中间件代理跨域\n后端在头部信息里面设置安全域名</code></pre>\n<p>11、严格模式的限制</p>\n<pre><code>变量必须声明后再使用\n函数的参数不能有同名属性，否则报错\n不能使用 with 语句\n禁止 this 指向全局对象</code></pre>\n<p>12、es6新增</p>\n<pre><code>新增模板字符串\n箭头函数\nfor-of（用来遍历数据—例如数组中的值。）\nES6 将 Promise 对象纳入规范，提供了原生的 Promise 对象。\n增加了 let 和 const 命令，用来声明变量。\n还有就是引入 module 模块的概念</code></pre>\n<p>13、attribute 和 property 的区别是什么?</p>\n<pre><code>attribute 是 dom 元素在文档中作为 html 标签拥有的属性\nproperty 就是 dom 元素在 js 中作为对象拥有的属性。\n对于 html 的标准属性来说，attribute 和 property 是同步的，是会自动更新的\n但是对于自定义的属性来说，他们是不同步的</code></pre>\n<p>14、let和const 的区别是什么?</p>\n<pre><code>let 命令不存在变量提升，如果在 let 前使用，会导致报错\n如果块区中存在 let 和 const 命令，就会形成封闭作用域\n不允许重复声明\nconst定义的是常量，不能修改，但是如果定义的是对象，可以修改对象内部的数据</code></pre>\n<p>15、内存泄漏</p>\n<pre><code>定义：程序中己动态分配的堆内存由于某种原因程序未释放或无法释放引发的各种问题。\njs中可能出现的内存泄漏情况：结果：变慢，崩溃，延迟大等\njs中可能出现的内存泄漏原因\n全局变量\ndom 清空时，还存在引用\n定时器未清除\n子元素存在引起的内存泄露</code></pre>\n<p><br/> 16、script 引入方式?</p>\n<pre><code>html 静态 &lt;script&gt; 引入\njs 动态插入 &lt;script&gt;\n&lt;script defer&gt; : 异步加载，元素解析完成后执行\n&lt;script async&gt; : 异步加载，但执行时会阻塞元素渲染</code></pre>\n<p>17、数组(array)方法</p>\n<pre><code>map : 遍历数组，返回回调返回值组成的新数组\nforEach : 无法 break ，可以用 try/catch 中 throw new Error 来停止\nfilter : 过滤\nsome : 有一项返回 true ，则整体为 true\nevery : 有一项返回 false ，则整体为 false\njoin : 通过指定连接符生成字符串\npush / pop : 末尾推入和弹出，改变原数组， 返回推入/弹出项\nunshift / shift : 头部推入和弹出，改变原数组，返回操作项\nsort(fn) / reverse : 排序与反转，改变原数组\nconcat : 连接数组，不影响原数组， 浅拷贝\nslice(start, end) : 返回截断后的新数组，不改变原数组\nsplice(start,number,value…): 返回删除元素组成的数组，value 为插入项，改变原数组\nindexOf / lastIndexOf(value, fromIndex) : 查找数组项，返回对应的下标\nreduce / reduceRight(fn(prev, cur) ，defaultPrev) : 两两执行，\nprev 为上次化简函数的return 值，cur 为当前值(从第二项开始)</code></pre>\n<p>18、JavaScript 深浅拷贝?</p>\n<pre><code>浅拷贝\nObject.assign\n深拷贝\n可以通过 JSON.parse(JSON.stringify(object)) 来解决</code></pre>\n<p>19、说说异步编程的实现方式?</p>\n<pre><code>回调函数\n优点：简单、容易理解\n缺点：不利于维护、代码耦合高\n事件监听\n优点：容易理解，可以绑定多个事件，每个事件可以指定多个回调函数\n缺点：事件驱动型，流程不够清晰\n发布/订阅(观察者模式)\n类似于事件监听，但是可以通过‘消息中心’，了解现在有多少发布者，多少订阅者\nPromise 对象\n优点：可以利用 then 方法，进行链式写法；可以书写错误时的回调函数\n缺点：编写和理解，相对比较难\nGenerator 函数\n优点：函数体内外的数据交换、错误处理机制\n缺点：流程管理不方便\nasync 函数\n优点：内置执行器、更好的语义、更广的适用性、返回的是 Promise、结构清晰\n缺点：错误处理机制</code></pre>\n<p>20、说说面向对象编程思想?</p>\n<pre><code>基本思想是使用对象，类，继承，封装等基本概念来进行程序设计\n优点\n易维护\n易扩展\n开发工作的重用性、继承性高，降低重复工作量。\n缩短了开发周期</code></pre>\n<p>21、项目性能优化</p>\n<pre><code>减少 HTTP 请求数\n减少 DNS 查询\n使用 CDN\n避免重定向\n图片懒加载\n减少 DOM 元素数量\n减少 DOM 操作\n使用外部 JavaScript 和 CSS\n压缩 JavaScript、CSS、字体、图片等\n优化 CSS Sprite\n使用 iconfont\n多域名分发划分内容到不同域名\n尽量减少 iframe 使用\n避免图片 src 为空\n把样式表放在 link 中\n把 JavaScript 放在页面底部</code></pre>\n<p>22、什么是单线程，和异步的关系？</p>\n<pre><code>单线程 ：只有一个线程，只能做一件事\n原因 ： 避免 DOM 渲染的冲突\n浏览器需要渲染 DOM\nJS 可以修改 DOM 结构\nJS 执行的时候，浏览器 DOM 渲染会暂停\n两段 JS 也不能同时执行（都修改 DOM 就冲突了）\nwebworker 支持多线程，但是不能访问 DOM\n解决方案 ：异步</code></pre>\n<p><br/> 23、说说负载均衡？</p>\n<pre><code>单台服务器共同协作，不让其中某一台或几台超额工作，发挥服务器的最大作用\nhttp 重定向负载均衡：调度者根据策略选择服务器以 302 响应请求，\n缺点只有第一次有效果，后续操作维持在该服务器 dns 负载均衡：解析域名时，\n访问多个 ip 服务器中的一个（可监控性较弱）原因 - 避免 DOM 渲染的冲突\n反向代理负载均衡：访问统一的服务器，由服务器进行调度访问实际的某个服务器，\n对统一的服务器要求大，性能受到 服务器群的数量</code></pre>\n<p>24、作用域链？</p>\n<pre><code>作用域链可以理解为一组对象列表，包含 父级和自身的变量对象，\n因此我们便能通过作用域链访问到父级里声明的变量或者函数</code></pre>\n<p><br/> 25、什么是原型、原型链、继承？</p>\n<pre><code>所有的函数都有prototype属性（原型）\n所有的对象都有__proto__属性\n在Javascript中，每个函数都有一个原型属性prototype指向自身的原型，\n而由这个函数创建的对象也有一个proto属性指向这个原型，\n而函数的原型是一个对象，所以这个对象也会有一个proto指向自己的原型，\n这样逐层深入直到Object对象的原型，这样就形成了原型链。</code></pre>\n<p><br/> 26、JS垃圾回收机制是怎样的？</p>\n<pre><code>1.概述\n\njs的垃圾回收机制是为了防止内存泄漏（已经不需要的某一块内存还一直存在着），\n垃圾回收机制就是不停歇的寻找这些不再使用的变量，并且释放掉它所指向的内存。\n在JS中，JS的执行环境会负责管理代码执行过程中使用的内存。\n\n2.变量的生命周期\n\n当一个变量的生命周期结束之后，它所指向的内存就会被释放。js有两种变量，\n局部变量和全局变量，局部变量是在他当前的函数中产生作用，当该函数结束之后，\n该变量内存会被释放，全局变量的话会一直存在，直到浏览器关闭为止。\n\n3.js垃圾回收方式\n有两种方式： 标记清除、引用计数\n\n标记清除：大部分浏览器使用这种垃圾回收，当变量进入执行环境(声明变量）的时候，\n垃圾回收器将该变量进行了标记，当该变量离开环境的时候，将其再度标记，随之进行删除。\n\n引用计数：这种方式常常会引起内存的泄露，主要存在于低版本的浏览器。\n它的机制就是跟踪某一个值得引用次数，当声明一个变量并且将一个引用类型\n赋值给变量得时候引用次数加1，当这个变量指向其他一个时引用次数减1，\n当为0时出发回收机制进行回收。</code></pre>\n<p>27、逐进增强和优雅降级</p>\n<p>逐进增强</p>\n<pre><code>针对低版本浏览器进行构建页面，保证最基本的功能，\n然后再针对高版本浏览器进行效果、交互等改进和追加功能达到更好的用户体验。</code></pre>\n<p><br/> 优雅降级</p>\n<pre><code>一开始就构建完整的功能，然后再针对低版本浏览器进行兼容</code></pre>\n<p><br/> 【vue面试题】<br/> 1、vue优点</p>\n<pre><code>轻量级\n速度快\n简单易学\n低耦合\n可重用性\n独立开发\n文档齐全，且文档为中文文档</code></pre>\n<p>2、vue父组件向子组件传递数据</p>\n<pre><code>props</code></pre>\n<p><br/> 3、子组件向父组件传递事件</p>\n<pre><code>$emit\n$refs\nprops的函数闭包用法</code></pre>\n<p><br/> 4、v-show和v-if指令的共同点和不同点</p>\n<pre><code>相同点:都可以控制dom元素的显示和隐藏\n\n不同点:v-show只是改变display属性，dom元素并未消失，切换时不需要重新渲染页面\n\nv-if直接将dom元素从页面删除，再次切换需要重新渲染页面</code></pre>\n<p>5、如何让CSS只在当前组件中起作用</p>\n<pre><code>scoped</code></pre>\n<p>6、&lt;keep-alive&gt;&lt;/keep-alive&gt;的作用是什么</p>\n<pre><code>主要是用于需要频繁切换的组件时进行缓存，不需要重新渲染页面</code></pre>\n<p><br/> 7、如何获取dom</p>\n<pre><code>给dom元素加ref=‘refname’,然后通过this.$refs.refname进行获取dom元素</code></pre>\n<p>8、说出几种vue当中的指令和它的用法</p>\n<pre><code>v-model\n\nv-on\n\nv-html\n\nv-text\n\nv-once\n\nv-if\n\nv-show</code></pre>\n<p>9、vue-loader是什么？它的用途是什么？</p>\n<pre><code>vue文件的一个加载器，将template/js/style转换为js模块\n\n用途:js可以写es6、style样式</code></pre>\n<p>10、为什么用key</p>\n<pre><code>给每个dom元素加上key作为唯一标识 ，diff算法可以正确的识别这个节点，使页面渲染更加迅速。</code></pre>\n<p>11、axios及安装？</p>\n<pre><code>vue项目中使用ajax时需要axios插件\n\n下载方式cnpm install axios --save</code></pre>\n<p>12、v-model的使用</p>\n<pre><code>v-model用于表单的双向绑定，可以实时修改数据</code></pre>\n<p>13、请说出vue.cli项目中src目录每个文件夹和文件的用法</p>\n<pre><code>components存放组件\n\napp.vue主页面入口\n\nindex.js主文件入口\n\nass存放静态资源文件</code></pre>\n<p>14、分别简述computed和watch的使用场景</p>\n<pre><code>用官网的一句话来说，所有需要用到计算的都应该使用计算属性。\n多条数据影响一条数据时使用计算属性，使用场景购物车。\n\n如果是一条数据更改，影响多条数据时，使用watch，使用场景搜索框。</code></pre>\n<p>15、v-on可以监听多个方法吗？</p>\n<pre><code>可以，比如 v-on=“onclick,onbure”</code></pre>\n<p>16、$nextTick的使用</p>\n<pre><code>在data()中的修改后，页面中无法获取data修改后的数据，\n使用$nextTick时，当data中的数据修改后，可以实时的渲染页面</code></pre>\n<p><br/> 17、vue组件中data为什么必须是一个函数？</p>\n<pre><code>因为javaScript的特性所导致，在component中，\ndata必须以函数的形式存在，不可以是对象。\n\n组件中的data写成一个函数，数据以函数返回值的形式定义，\n这样每次复用组件的时候，都会返回一份新的data，\n相当于每个组件实例都有自己私有的数据空间，\n他们值负责各自维护数据，不会造成混乱。\n而单纯的写成对象形式，就是所有组件实例共用了一个data，\n这样改一个全部都会修改。</code></pre>\n<p>18、渐进式框架的理解</p>\n<pre><code>主张最少\n\n可以根据不同的需求选择不同的层级</code></pre>\n<p>19、vue在双向数据绑定是如何实现的？</p>\n<pre><code>vue双向数据绑定是通过数据劫持、组合、发布订阅模式的方式来实现的，\n也就是说数据和视图同步，数据发生变化，视图跟着变化，\n视图变化，数据也随之发生改变\n\n核心：关于vue双向数据绑定，其核心是Object.defineProperty()方法</code></pre>\n<p>20、单页面应用和多页面应用区别及缺点</p>\n<pre><code>单页面应用（SPA），通俗的说就是指只有一个主页面的应用，\n浏览器一开始就加载所有的js、html、css。\n所有的页面内容都包含在这个主页面中。但在写的时候，还是分开写，\n然后再加护的时候有路由程序动态载入，单页面的页面跳转，\n仅刷新局部资源。多用于pc端。\n\n多页面（MPA），就是一个应用中有多个页面，页面跳转时是整页刷新\n\n单页面的优点：用户体验好，快，内容的改变不需要重新加载整个页面，\n基于这一点spa对服务器压力较小；前后端分离，页面效果会比较酷炫\n\n单页面缺点：不利于seo；导航不可用，如果一定要导航需要自行实现前进、\n后退。初次加载时耗时多；页面复杂度提高很多。</code></pre>\n<p>21、Vue 项目中为什么要在列表组件中写 key，其作用是什么？</p>\n<pre><code>key是给每一个vnode的唯一id,可以依靠key,更准确, \n更快的拿到oldVnode中对应的vnode节点。\n\n更准确\n因为带key就不是就地复用了，\n在sameNode函数 a.key === b.key对比中可以避免就地复用的情况。\n所以会更加准确。\n更快\n利用key的唯一性生成map对象来获取对应节点，比遍历方式更快。</code></pre>\n<p><br/> 22、父组件和子组件生命周期钩子执行顺序是什么？</p>\n<pre><code>加载渲染过程\n父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted\n\n子组件更新过程\n父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated\n\n父组件更新过程\n父 beforeUpdate -&gt; 父 updated\n\n销毁过程\n父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed</code></pre>\n<p>23、谈一谈你对 nextTick 的理解？</p>\n<pre><code>当你修改了data的值然后马上获取这个dom元素的值，\n是不能获取到更新后的值，你需要使用$nextTick这个回调，\n让修改后的data值渲染更新到dom元素之后在获取，才能成功。</code></pre>\n<p>24、vue组件中data为什么必须是一个函数？</p>\n<pre><code>因为JavaScript的特性所导致，在component中，\ndata必须以函数的形式存在，不可以是对象。\n组建中的data写成一个函数，数据以函数返回值的形式定义，\n这样每次复用组件的时候，都会返回一份新的data，\n相当于每个组件实例都有自己私有的数据空间，\n它们只负责各自维护的数据，不会造成混乱。\n而单纯的写成对象形式，就是所有的组件实例共用了一个data，\n这样改一个全都改了。</code></pre>\n<p>25、vue和jQuery的区别</p>\n<pre><code>jQuery是使用选择器（$）选取DOM对象，对其进行赋值、取值、事件绑定等操作，\n其实和原生的HTML的区别只在于可以更方便的选取和操作DOM对象，\n而数据和界面是在一起的。\n比如需要获取label标签的内容：$(\"lable\").val();,\n它还是依赖DOM元素的值。\nVue则是通过Vue对象将数据和View完全分离开来了。\n对数据进行操作不再需要引用相应的DOM对象，可以说数据和View是分离的，\n他们通过Vue对象这个vm实现相互的绑定。这就是传说中的MVVM。</code></pre>\n<p>26、delete和Vue.delete删除数组的区别</p>\n<pre><code>delete只是被删除的元素变成了 empty/undefined 其他的元素的键值还是不变。\nVue.delete 直接删除了数组 改变了数组的键值。</code></pre>\n<p>27、SPA首屏加载慢如何解决</p>\n<pre><code>安装动态懒加载所需插件；使用CDN资源。</code></pre>\n<p>28、vue项目是打包了一个js文件，一个css文件，还是有多个文件？</p>\n<pre><code>根据vue-cli脚手架规范，一个js文件，一个CSS文件。</code></pre>\n<p>29、vue更新数组时触发视图更新的方法</p>\n<pre><code>push()；\npop()；\nshift()；\nunshift()；\nsplice()；\nsort()；\nreverse()</code></pre>\n<p>30、什么是 vue 生命周期？有什么作用？</p>\n<pre><code>每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，\n需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。\n同时在这个过程中也会运行一些叫做 生命周期钩子 的函数，\n这给了用户在不同阶段添加自己的代码的机会。</code></pre>\n<p>31、第一次页面加载会触发哪几个钩子？</p>\n<pre><code>beforeCreate， created， beforeMount， mounted</code></pre>\n<p>32、vue获取数据在一般在哪个周期函数</p>\n<pre><code>created\nbeforeMount\nmounted</code></pre>\n<p>33、created和mounted的区别</p>\n<pre><code>created:在模板渲染成html前调用，\n即通常初始化某些属性值，然后再渲染成视图。\n\nmounted:在模板渲染成html后调用，通常是初始化页面完成后，\n再对html的dom节点进行一些需要的操作。</code></pre>\n<p>34、vue生命周期的理解</p>\n<pre><code>总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后。\n\n创建前/后： 在beforeCreated阶段，vue实例的挂载元素$el和数据对象data都为undefined，\n还未初始化。\n\n在created阶段，vue实例的数据对象data有了，$el还没有。\n\n载入前/后：在beforeMount阶段，vue实例的$el和data都初始化了，\n但还是挂载之前为虚拟的dom节点，data.message还未替换。\n\n在mounted阶段，vue实例挂载完成，data.message成功渲染。\n\n更新前/后：当data变化时，会触发beforeUpdate和updated方法。\n\n销毁前/后：在执行destroy方法后，对data的改变不会再触发周期函数，\n说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在。</code></pre>\n<p>35、vuex是什么？</p>\n<pre><code>vue框架中状态管理。</code></pre>\n<p>36、vuex有哪几种属性？</p>\n<pre><code>有五种，State、 Getter、Mutation 、Action、 Module\nstate： 基本数据(数据源存放地)\ngetters： 从基本数据派生出来的数据\nmutations ： 提交更改数据的方法，同步！\nactions ： 像一个装饰器，包裹mutations，使之可以异步。\nmodules ： 模块化Vuex</code></pre>\n<p>37、vue全家桶</p>\n<pre><code>vue-cli、vuex、vueRouter、Axios</code></pre>\n<p>38、vue-cli 工程常用的 npm 命令有哪些?</p>\n<pre><code>npm install 下载 node_modules 资源包的命令\nnpm run dev 启动 vue-cli 开发环境的 npm 命令\nnpm run build vue-cli 生成 生产环境部署资源 的 npm 命令\nnpm run build–report 用于查看 vue-cli 生产环境部署资源文件大小的 npm 命令</code></pre>\n<p><br/> 39、请说出 vue-cli 工程中每个文件夹和文件的用处?</p>\n<pre><code>build 文件夹是保存一些 webpack 的初始化配置。\nconfig 文件夹保存一些项目初始化的配置\nnode_modules 是 npm 加载的项目依赖的模块\nsrc 目录是我们要开发的目录:\nassets 用来放置图片\ncomponents 用来放组件文件\napp.vue 是项目入口文件\nmain.js 项目的核心文件</code></pre>\n<p><br/> 40、v-if 和 v-show 有什么区别</p>\n<pre><code>共同点：都是动态显示 DOM 元素\n区别点：\nv-if 是动态的向 DOM 树内添加或者删除 DOM 元素\nv-show 是通过设置 DOM 元素的 display 样式属性控制显隐\nv-if 切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件\nv-show 只是简单的基于 css 切换\n性能消耗\nv-if 有更高的切换消耗\nv-show 有更高的初始渲染消耗\n使用场景\nv-if 适合运营条件不大可能改变\nv-show 适合频繁切换</code></pre>\n<p><br/> 41、v-for 与 v-if 的优先级?</p>\n<pre><code>v-for 和 v-if 同时使用，有一个先后运行的优先级，\nv-for 比 v-if 优先级更高，\n这就说明在v-for 每次的循环赋值中每一次调用 v-if 的判断，\n所以不推荐 v-if 和 v-for 在同一个标签中同时使用。</code></pre>\n<p>42、 vue 常用的修饰符?</p>\n<pre><code>事件修饰符\n\n.stop 阻止事件继续传播\n.prevent 阻止标签默认行为\n.capture 使用事件捕获模式，即元素自身触发的事件先在此处处理，然后才交由内部元素进行处理\n.self 只当在 event.target 是当前元素自身时触发处理函数\n.once 事件只会触发一次\n.passive 告诉浏览器你不想阻止事件的默认行为\nv-model 的修饰符\n\n.lazy 通过这个修饰符，转变为在 change 事件再同步\n.number 自动将用户输入值转化为数值类型\n.trim 自动过滤用户输入的收尾空格</code></pre>\n<pre><code>键盘事件修饰符\n\n.enter\n.tab\n.delete (捕获“删除”和“退格”键)\n.esc\n.space\n.up\n.down\n.left\n.right</code></pre>\n<pre><code>系统修饰符\n\n.ctrl\n.alt\n.shift\n.meta</code></pre>\n<pre><code>鼠标按钮修饰符\n\n.left\n.right\n.middle</code></pre>\n<p><br/> 43、vue 事件中如何使用 event 对象?</p>\n<pre><code>获取事件对象，方法参数传递 $event 。注意在事件中要使用 $ 符号\n&lt;button @click=\"Event($event)\"&gt;事件对象&lt;/button&gt;</code></pre>\n<p><br/> 44、组件传值方式有哪些</p>\n<pre><code>父传子：子组件通过props[‘xx’] 来接收父组件传递的属性 xx 的值\n子传父：子组件通过 this.$emit(‘fnName’,value) 来传递,\n父组件通过接收 fnName 事件方法来接收回调\n其他方式：通过创建一个bus，进行传值\n使用Vuex</code></pre>\n<p><br/> 45、vue 中子组件调用父组件的方法?</p>\n<pre><code>直接在子组件中通过 this.$parent.event 来调用父组件的方法。\n在子组件里用$emit()向父组件触发一个事件，父组件监听这个事件就行了。\n父组件把方法传入子组件中，在子组件里直接调用这个方法。\n46、 如何让 CSS 只在当前组件中起作用？\n在组件中的 style 前面加上 scoped</code></pre>\n<p>47、如何获取 dom?</p>\n<pre><code>ref=\"domName\" 用法：this.$refs.domName</code></pre>\n<p>48、vue路由跳转</p>\n<pre><code>(一)声明式导航router-link\n\n不带参数：\n// 注意：router-link中链接如果是'/'开始就是从根路由开始，\n如果开始不带'/'，则从当前路由开始。\n&lt;router-link :to=\"{name:'home'}\"&gt;  \n&lt;router-link :to=\"{path:'/home'}\"&gt; //name,path都行, 建议用name \n带参数：\n&lt;router-link :to=\"{name:'home', params: {id:1}}\"&gt;\n&lt;router-link :to=\"{name:'home', query: {id:1}}\"&gt;  \n&lt;router-link :to=\"/home/:id\"&gt;  \n//传递对象\n&lt;router-link \n    :to=\"{\n        name:'detail', \n        query: {item:JSON.stringify(obj)}\n    }\"&gt;&lt;/router-link&gt; </code></pre>\n<p>(二)this.$router.push()</p>\n<pre><code>不带参数：\nthis.$router.push('/home')\nthis.$router.push({name:'home'})\nthis.$router.push({path:'/home'})\n\n\nquery传参\n1.路由配置：\nname: 'home',\npath: '/home'\n2.跳转：\nthis.$router.push({name:'home',query: {id:'1'}})\nthis.$router.push({path:'/home',query: {id:'1'}})\n3.获取参数\nhtml取参: $route.query.id\nscript取参: this.$route.query.id\n\n\nparams传参\n1.路由配置：\nname: 'home',\npath: '/home/:id'(或者path: '/home:id')\n2.跳转：\nthis.$router.push({name:'home',params: {id:'1'}})\n注意：\n// 只能用 name匹配路由不能用path\n// params传参数(类似post)  路由配置 path: \"/home/:id\" \n或者 path: \"/home:id\"否则刷新参数消失\n3.获取参数\nhtml取参:$route.params.id \nscript取参:this.$route.params.id\n\n\n直接通过path传参\n1.路由配置：\nname: 'home',\npath: '/home/:id'\n2.跳转：\nthis.$router.push({path:'/home/123'}) \n或者：\nthis.$router.push('/home/123') \n3.获取参数：\nthis.$route.params.id\n\n\nparams和query的区别\nquery类似 get，跳转之后页面 url后面会拼接参数，类似?id=1。\n非重要性的可以这样传，密码之类还是用params，刷新页面id还在。\nparams类似 post，跳转之后页面 url后面不会拼接参数。</code></pre>\n<p><br/><br/> (三)this.$router.replace()</p>\n<p>用法同上<br/> (四)this.$router.go(n)</p>\n<pre><code>向前或者向后跳转n个页面，n可为正整数或负整数\n区别:\n\nthis.$router.push\n跳转到指定url路径，并在history栈中添加一个记录，\n点击后退会返回到上一个页面\n\nthis.$router.replace\n跳转到指定url路径，但是history栈中不会有记录，\n点击返回会跳转到上上个页面 (就是直接替换了当前页面)\n\nthis.$router.go(n)\n向前或者向后跳转n个页面，n可为正整数或负整数</code></pre>\n<p><br/> 49、Vue.js 双向绑定的原理</p>\n<pre><code>Vue.js 2.0 采用数据劫持（Proxy 模式）\n结合发布者-订阅者模式（PubSub 模式）的方式，\n通过 Object.defineProperty()来劫持各个属性的 setter，getter，\n在数据变动时发布消息给订阅者，触发相应的监听回调。\n\n每个组件实例都有相应的watcher程序实例，\n它会在组件渲染的过程中把属性记录为依赖，\n之后当依赖项的setter被调用时，会通知watcher重新计算，\n从而致使它关联的组件得以更新。\n\nVue.js 3.0, 放弃了Object.defineProperty ，\n使用更快的ES6原生 Proxy (访问对象拦截器, 也称代理器)</code></pre>\n<p>50、Computed和Watch的区别</p>\n<pre><code>computed 计算属性 : 依赖其它属性值,并且 computed 的值有缓存,\n只有它依赖的 属性值发生改变,下一次获取 computed 的值时才会重新计算 computed 的值。\n\nwatch 侦听器 : 更多的是观察的作用,无缓存性,\n类似于某些数据的监听回调,每 当监听的数据变化时都会执行回调进行后续操作。\n\n运用场景：\n\n当我们需要进行数值计算,并且依赖于其它数据时,\n应该使用 computed,因为可以利用 computed的缓存特性,\n避免每次获取值时,都要重新计算。\n当我们需要在数据变化时执行异步或开销较大的操作时,\n应该使用 watch,使用 watch 选项允许我们执行异步操作 ( 访问一个 API ),\n限制我们执行该操作的频率, 并在我们得到最终结果前,\n设置中间状态。这些都是计算属性无法做到的。\n多个因素影响一个显示，用Computed；\n一个因素的变化影响多个其他因素、显示，用Watch;\nComputed 和 Methods 的区别\n\ncomputed: 计算属性是基于它们的依赖进行缓存的,\n只有在它的相关依赖发生改变时才会重新求值对于 method ，只要发生重新渲染，\nmethod 调用总会执行该函数</code></pre>\n<p><br/> 51、过滤器 (Filter)</p>\n<pre><code>在Vue中使用filters来过滤(格式化)数据，filters不会修改数据，\n而是过滤(格式化)数据，改变用户看到的输出\n（计算属性 computed ，方法 methods 都是通过修改数据来处理数据格式的输出显示。\n使用场景： 比如需要处理时间、数字等的的显示格式；</code></pre>\n<p><br/> 52、axios是什么</p>\n<pre><code>易用、简洁且高效的http库， 支持node端和浏览器端，支持Promise，支持拦截器等高级配置。</code></pre>\n<p>53、sass是什么？如何在vue中安装和使用？</p>\n<pre><code>sass是一种CSS预编译语言安装和使用步骤如下。\n\n用npm安装加载程序（ sass-loader、 css-loader等加载程序)。\n在 webpack.config.js中配置sass加载程序。</code></pre>\n<p><br/> 54、Vue.js页面闪烁</p>\n<pre><code>Vue. js提供了一个v-cloak指令，该指令一直保持在元素上，\n直到关联实例结束编译。当和CSS一起使用时，\n这个指令可以隐藏未编译的标签，直到实例编译结束。用法如下。\n   \n [v-cloak]{ \n     display:none; \n    } \n    &lt;div v-cloak&gt;{<!-- -->{ title }}&lt;/div&gt;</code></pre>\n<p><br/> 55、如何解决数据层级结构太深的问题</p>\n<pre><code>在开发业务时，经常会岀现异步获取数据的情况，\n有时数据层次比较深，如以下代码: span 'v-text=\"a.b.c.d\"&gt;, \n可以使用vm.$set手动定义一层数据: vm.$set(\"demo\"，a.b.c.d)</code></pre>\n<p>56、vue常用指令</p>\n<pre><code>v-model 多用于表单元素实现双向数据绑定（同angular中的ng-model）\nv-bind 动态绑定 作用： 及时对页面的数据进行更改\nv-on:click 给标签绑定函数，可以缩写为@，例如绑定一个点击函数 函数必须写在methods里面\nv-for 格式： v-for=“字段名 in(of) 数组json” 循环数组或json(同angular中的ng-repeat)\nv-show 显示内容 （同angular中的ng-show）\nv-hide 隐藏内容（同angular中的ng-hide）\nv-if 显示与隐藏 （dom元素的删除添加 同angular中的ng-if 默认值为false）\nv-else-if 必须和v-if连用\nv-else 必须和v-if连用 不能单独使用 否则报错 模板编译错误\nv-text 解析文本\nv-html 解析html标签\nv-bind:class 三种绑定方法\n对象型 ‘{red:isred}’\n三元型 ‘isred?“red”:“blue”’\n数组型 ‘[{red:“isred”},{blue:“isblue”}]’\nv-once 进入页面时 只渲染一次 不在进行渲染\nv-cloak 防止闪烁\nv-pre 把标签内部的元素原位输出</code></pre>\n<p>57、$route和$router的区别</p>\n<pre><code>$route是“路由信息对象”，包括path，params，hash，query，\nfullPath，matched，name等路由信息参数。\n$router是“路由实例”对象包括了路由的跳转方法，钩子函数等</code></pre>\n<p>58、怎样理解 Vue 的单项数据流</p>\n<pre><code>数据总是从父组件传到子组件，子组件没有权利修改父组件传过来的数据，\n只能请求父组件对原始数据进行修改。这样会防止从子组件意外改变父组件的状态，\n从而导致你的应用的数据流向难以理解。\n注意：在子组件直接用 v-model 绑定父组件传过来的 props 这样是不规范的写法，\n开发环境会报警告。\n如果实在要改变父组件的 props 值可以再data里面定义一个变量，\n并用 prop 的值初始化它，之后用$emit 通知父组件去修改。</code></pre>\n<p><br/> 59、虚拟DOM是什么？有什么优缺点？</p>\n<pre><code>由于在浏览器中操作DOM是很昂贵的。频繁操作DOM，\n会产生一定性能问题。这就是虚拟Dom的产生原因。\nVue2的Virtual DOM 借鉴了开源库 snabbdom 的实现。\nVirtual DOM本质就是用一个原生的JS对象去描述一个DOM节点，是对真实DOM的一层抽象。</code></pre>\n<pre><code>优点：\n1、保证性能下限：框架的虚拟DOM需要适配任何上层API可能产生的操作，\n他的一些DOM操作的实现必须是普适的，所以它的性能并不是最优的；\n但是比起粗暴的DOM操作性能要好很多，\n因此框架的虚拟DOM至少可以保证在你不需要手动优化的情况下，\n依然可以提供还不错的性能，既保证性能的下限。\n2、无需手动操作DOM：我们不需手动去操作DOM，\n只需要写好 View-Model的 代码逻辑，框架会根据虚拟DOM和数据双向绑定，\n帮我们以可预期的方式更新视图，极大提高我们的开发效率。\n3、跨平台：虚拟DOM本质上是JavaScript对象，而DOM与平台强相关，\n相比之下虚拟DOM可以进行更方便地跨平台操作，例如服务器端渲染、weex开发等等。</code></pre>\n<pre><code>缺点：\n1、无法进行极致优化：虽然虚拟DOM + 合理的优化，\n足以应对大部分应用的性能需要，\n但在一些性能要求极高的应用中虚拟DOM无法进行针对性的极致优化。\n2、首次渲染大量DOM时，由于多了一层DOM计算，会比innerHTML插入慢。</code></pre>\n<p><br/> 60、Vuex 页面刷新数据丢失怎么解决？</p>\n<pre><code>需要做 vuex 数据持久化，一般使用本地储存的方案来保存数据，\n可以自己设计存储方案，也可以使用第三方插件。\n推荐使用 vuex-persist (脯肉赛斯特)插件，\n它是为 Vuex 持久化储存而生的一个插件。不需要你手动存取 storage，\n而是直接将状态保存至 cookie 或者 localStorage中。</code></pre>\n<p><br/> 61、Vuex 为什么要分模块并且加命名空间？</p>\n<pre><code>模块： 由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。\n当应用变得非常复杂时，store 对象就有可能会变得相当臃肿。\n为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。\n每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块。</code></pre>\n<pre><code>命名空间： 默认情况下，模块内部的 action、mutation、getter\n是注册在全局命名空间的 — 这样使得多个模块能够对同一 mutation 或 action 做出响应。\n如果希望你的模块具有更高的封装度和复用性，\n你可以通过添加 namespaced:true 的方式使其成为带命名的模块。\n当模块被注册后，他所有 getter、action、及 mutation 都会自动根据模块注册的路径调整命名。</code></pre>\n<p>62、vue 中使用了哪些设计模式？</p>\n<pre><code>1、工厂模式 - 传入参数即可创建实例\n虚拟 DOM 根据参数的不同返回基础标签的 Vnode 和组件 Vnode。\n2、单例模式 - 整个程序有且仅有一个实例\nvuex 和 vue-router 的插件注册方法 install 判断如果系统存在实例就直接返回掉。\n3、发布-订阅模式。（vue 事件机制）\n4、观察者模式。（响应式数据原理）\n5、装饰器模式（@装饰器的用法）\n6、策略模式，策略模式指对象有某个行为，但是在不同的场景中，\n该行为有不同的实现方案 - 比如选项的合并策略。</code></pre>\n<p><br/> 63、你都做过哪些 Vue 的性能优化？</p>\n<pre><code>这里只列举针对 Vue 的性能优化，整个项目的性能优化是一个大工程。\n\n对象层级不要过深，否则性能就会差。\n不需要响应式的数据不要放在 data 中（可以使用 Object.freeze() 冻结数据）\nv-if 和 v-show 区分使用场景\ncomputed 和 watch 区分场景使用\nv-for 遍历必须加 key，key最好是id值，且避免同时使用 v-if\n大数据列表和表格性能优化 - 虚拟列表 / 虚拟表格\n防止内部泄露，组件销毁后把全局变量和时间销毁\n图片懒加载\n路由懒加载\n异步路由\n第三方插件的按需加载\n适当采用 keep-alive 缓存组件\n防抖、节流的运用\n服务端渲染 SSR or 预渲染</code></pre>\n<p>64、Vue.set 方法原理<br/>  </p>\n<pre><code>在两种情况下修改 Vue 是不会触发视图更新的。\n\n1、在实例创建之后添加新的属性到实例上（给响应式对象新增属性）\n2、直接更改数组下标来修改数组的值。\nVue.set 或者说是 $set 原理如下\n因为响应式数据 我们给对象和数组本身新增了__ob__属性，代表的是 Observer 实例。\n当给对象新增不存在的属性，首先会把新的属性进行响应式跟踪 \n然后会触发对象 ob 的dep收集到的 watcher 去更新，\n当修改数组索引时我们调用数组本身的 splice 方法去更新数组。</code></pre>\n<p><br/> 65、函数式组件使用场景和原理</p>\n<pre><code>函数式组件与普通组件的区别\n\n1、函数式组件需要在声明组件时指定 functional:true\n2、不需要实例化，所以没有this，this通过render函数的第二个参数context代替\n3、没有生命周期钩子函数，不能使用计算属性，watch\n4、不能通过$emit对外暴露事件，\n   调用事件只能通过context.listeners.click的方式调用外部传入的事件\n5、因为函数组件时没有实例化的，所以在外部通过ref去引用组件时，\n   实际引用的是HTMLElement\n6、函数式组件的props可以不用显示声明，\n   所以没有在props里面声明的属性都会被自动隐式解析为prop，\n   而普通的组件所有未声明的属性都解析到$attrs里面，\n   并自动挂载到组件根元素上（可以通过inheritAttrs属性禁止）</code></pre>\n<pre><code>优点：1.由于函数组件不需要实例化，无状态，没有生命周期，\n所以渲染性要好于普通组件2.函数组件结构比较简单，代码结构更清晰</code></pre>\n<pre><code class=\"language-javascript\">使用场景：\n\n一个简单的展示组件，作为容器组件使用 比如 router-view 就是一个函数式组件。 \n“高阶组件”—用于接受一个组件为参数，返回一个被包装过的组件。\n相关代码如下：\n\n// 带有functional的属性的就是函数式组件 \nif (isTrue(Ctor.options.functional)) { \n    return createFunctionalComponent(\n        Ctor,\n        propsData,\n        data,\n        context, \n        children);\n     } \n    const listeners = data.on;\n     data.on = data.nativeOn; \n    // 安装组件相关钩子 （函数式组件没有调用此方法，从而性能高于普通组件）\n    installComponentHooks(data); \n</code></pre>\n<p>66、子组件为何不可以修改父组件传递的 Prop？</p>\n<pre><code>所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：\n父级 prop 的更新会向下流动到子组件中，但是反过来则不行。\n这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。</code></pre>\n<p>67、vue项目创建、路由配置、环境配置以及组件传值等</p>\n<p></p>\n<p>【css、html面试题】<br/> HTML和HTML5有什么区别？</p>\n<pre><code>主要有三个区别：\n\n1、文档声明区别\n\nHTML：超文本标记语言，一种纯文本类型的语言。\n\nHTML5.0：文档声明HTML5方便书写，精简，有利于程序员快速的阅读和开发。\n\n2、结构语义区别\n\nhtml：没有体现结构语义化的标签，如：&lt;div id=\"nav\"&gt;&lt;/div&gt;\n\nhtml5：添加了许多具有语义化的标签，如：&lt;article&gt;、&lt;aside&gt;、&lt;audio&gt;、&lt;bdi&gt;...\n\n3、绘图区别\n\nHTML：指可伸缩矢量图形，用于定义网络的基于矢量的图形。\n\nHTML5：HTML5的canvas元素使用脚本（通常使用JavaScript）在网页上绘制图像，\n可以控制画布每一个像素。</code></pre>\n<p>什么是盒子模型？</p>\n<pre><code>一个盒子我们会分成几个部分：内容区(content)、内边距(padding)、\n边框(border)、外边距(margin)，\n也就是盒模型的组成由margin，padding，boder，content组成\n盒子模型分为标准盒子模型和IE盒子模型</code></pre>\n<p><br/> 如何理解HTML5语义化？</p>\n<pre><code>HTML语义化标签\nheader – 标题\nnav – 导航\narticle – 文章\nsection – 节或段\naside – 侧边栏\nfooter – 页脚</code></pre>\n<p><br/> 语义化的好处？</p>\n<pre><code>在没有css代码的情况下，也能很好的呈现内容结构、代码结构（让非技术员也能看懂代码）\n提高用户体验，比如：title，alt用于解释名词和图片信息\n利于SEO。语义化能和搜索引擎建立更好的联系，优化搜索\n便于团队开发与维护，语义化更具有可读性</code></pre>\n<p><br/> cookies、sessionStorage、localStorage的区别是什么？(浏览器)<br/>  </p>\n<pre><code>1、cookie\n（1）本身用于客户端和服务端通信\n（2）但是它有本地存储的功能，于是就被“借用”\n（3）document.cookie = …获取和修改即可\n（4）cookie用于存储的缺点\n①存储量太小，只有4kb\n②所有http请求都带着，会影响获取资源的效率\n③api简单，需要封装才能用document.cookie</code></pre>\n<p></p>\n<pre><code>2、localStorage,sesseionStorage\n（1）html5专门为存储而设计，最大容量5M\n（2）api简单易用\n（3）lcoalStorage.setItem(key, value);localStorage.getItem(key);\n（4）ios safari隐藏模式下:localStorage.getItem会报错，建议统一使用try-catch封装</code></pre>\n<p></p>\n<pre><code>3、sessionStorage用于本地存储一个会话（session）中的数据，\n这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。\n因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。\n而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。</code></pre>\n<p><br/> 常见的浏览器内核有哪些？</p>\n<pre><code>**Trident内核：**代表浏览器是ie浏览器，因此Trident内核又称E内核，\n  此内核只能用于Windows平台，并且不是开源的。\n\n**Gecko内核：**代表浏览器是Firefox浏览器。Gecko内核是开源的，\n  最大优势是可以跨平台。\n\n**Webkit内核:代表浏览器是Safari(苹果的浏览器)以及低版本的谷歌浏览器，\n  是开源的项目。\n\n**Presto内核：**代表浏览器是Opera浏览器(中文译为“欧朋浏览器”)，\n  Presto内核是世界公认最快的渲染速度的引擎，但是在2013年之后，\n  Open宣布加入谷歌阵营，弃用了该内核。\n\n**Blink内核：**由谷歌和Opera开发，2013年4月发布，现在Chrome内核是Blink。</code></pre>\n<p>谈谈你对web标准以及W3C的理解？</p>\n<pre><code>web标准：\n\n    web标准主要分为结构、表现、行为3部分\n\n    结构：指我们平时在body里面写的标签，主要是由HTML标签组成\n\n    表现：指更加丰富HTML标签样式，主要由CSS样式组成\n\n    行为：指页面和用户的交互，主要由JS部分组成</code></pre>\n<p>W3C：</p>\n<pre><code>W3C对web标准提出了规范化的要求，即代码规范\n\n对结构的要求\n\n1、标签字母要小写\n\n2、标签要闭合\n\n3、标签不允许随意嵌套</code></pre>\n<p>对表现和行为的要求</p>\n<pre><code>1、建议使用外链CSS和js脚本，实现结构与表现分离、结构与行为分离，\n能提高页面的渲染效率，更快地显示网页内容</code></pre>\n<p>如何实现浏览器响应式布局？</p>\n<pre><code>常用如下\n    使用媒体查询（@media）\n    使用flex弹性布局\n    使用百分比单位\n    使用rem单位\n    使用VH、HW单位\n\n推荐一种冷门万能自适应方式：tranfrom:scale(动态比值)</code></pre>\n<p><br/> CSS选择器以及优先级的理解？</p>\n<pre><code>常用的CSS选择器\n\n    ID选择器、类选择器、标签选择器、属性选择器、伪类选择器、后代选择器\n\n权重划分\n\n  在同一层级下：\n\n  !important &gt; 内联样式 &gt; ID选择器 &gt; 类选择器 &gt; （标签选择器、伪类选择器、属性选择器）\n\n不同层级下：\n\n    正常来说权重值越高的优先级越高，但是一直以来没有具体的权重值划分，\n    所以目前大多数开发中层级越深的优先级越高</code></pre>\n<p>谈谈你对回流和重绘的理解？</p>\n<pre><code>什么是回流？\n\n当一个元素自身的宽高，布局，显示或隐藏，或元素内部的文字结构发生变化\n，导致需要重新构建页面的时候，就产生了回流</code></pre>\n<pre><code>什么是重绘？\n\n当一个元素自身的宽高，布局，及显示或隐藏没有改变，\n而只是改变了元素的外观风格的时候，就产生了重绘</code></pre>\n<pre><code>什么时候会进行回流？\n\n添加或者删除可见的 DOM 元素的时候\n元素的位置发生改变\n元素的尺寸发生改变\n内容改变\n页面第一次渲染的时候</code></pre>\n<pre><code>什么时候会进行重绘？\n\n列举一些相关的 CSS 样式：color、background、\nbackground-size、visibility、box-shadow</code></pre>\n<p>opacity: 0、visibility: hidden、display: none有什么区别？</p>\n<pre><code>opacity=0，该元素隐藏起来了，但不会改变页面布局，\n并且，如果该元素已经绑定一些事件，如click事件，\n那么点击该区域，也能触发点击事件的\n\nvisibility=hidden，该元素隐藏起来了，\n但不会改变页面布局，但是不会触发该元素已经绑定的事件\n\ndisplay=none，把元素隐藏起来，并且会改变页面布局，\n可以理解成在页面中把该元素删除掉一样</code></pre>\n<p>css 预处理器</p>\n<pre><code>less\nsass</code></pre>\n<p>&lt;img&gt;的 title 和 alt 有什么区别</p>\n<pre><code>通常当鼠标滑动到元素上的时候显示\nalt 是&lt;img&gt; 的特有属性，是图片内容的等价描述，\n用于图片无法加载显示、读屏器阅读图片。可提图片高可访问性，\n除了纯装饰图片外都必须设置有意义的值，搜索引擎会重点分析。</code></pre>\n<p>行内元素和块级元素有哪些？img属于什么元素</p>\n<pre><code>块元素\naddress – 地址\nblockquote – 块引用\ncenter – 举中对齐块\ndir – 目录列表\ndiv – 常用块级容易，也是CSS layout的主要标签\ndl – 定义列表\nfieldset – form控制组\nform – 交互表单\nh1 – 大标题\nh2 – 副标题\nh3 – 3级标题\nh4 – 4级标题\nh5 – 5级标题\nh6 – 6级标题\nhr – 水平分隔线\nisindex – input prompt\nmenu – 菜单列表\nnoframes – frames可选内容，（对于不支持frame的浏览器显示此区块内容\nnoscript – 可选脚本内容（对于不支持script的浏览器显示此内容）\nol – 有序表单\np – 段落\npre – 格式化文本\ntable – 表格\nul – 无序列表</code></pre>\n<pre><code>内联元素\na – 锚点\nabbr – 缩写\nacronym – 首字\nb – 粗体(不推荐)\nbdo – bidi override\nbig – 大字体\nbr – 换行\ncite – 引用\ncode – 计算机代码(在引用源码的时候需要)\ndfn – 定义字段\nem – 强调\nfont – 字体设定(不推荐)\ni – 斜体\nimg – 图片\ninput – 输入框\nkbd – 定义键盘文本\nlabel – 表格标签\nq – 短引用\ns – 中划线(不推荐)\nsamp – 定义范例计算机代码\nselect – 项目选择\nsmall – 小字体文本\nspan – 常用内联容器，定义文本内区块\nstrike – 中划线\nstrong – 粗体强调\nsub – 下标\nsup – 上标\ntextarea – 多行文本输入框\ntt – 电传文本\nu – 下划线</code></pre>\n<pre><code>img属于行内替换元素，效果与块元素一致</code></pre>\n<p>表单中readonly和disabled的区别？</p>\n<pre><code>共同点：能够使用户不能改变表单中的内容</code></pre>\n<p></p>\n<pre><code>不同点：\n1、readonly只对input和textarea有效，但是disabled对所有的表单元素都是有效的，\n   包括radio、checkbox\n2、readonly可以获取到焦点，只是不能修改。\n   disabled设置的文本框无法获取焦点\n3、如果表单的字段是disabled，则该字段不会发送（表单传值）和序列化</code></pre>\n<p><br/> 浏览器</p>\n<pre><code>1、浏览器中输入url到网页显示，整个过程发生了什么\n\n域名解析\n发起tcp三次握手\n建立tcp连接之后发起htttp请求\n服务器端响应http请求，浏览器得到html代码\n浏览器器解析html代码，并请求html代码中的资源\n浏览器对页面进行渲染呈现给用户</code></pre>\n<p>2、cookie的弊端</p>\n<pre><code>每个特定的域名下最多生成的cookie的个数有限制\nIE和Opera会清理近期最少使用的cookie，firefox会随机清理cookie\ncookie最大为4096字节，为了兼容一般不超过4095字节\n安全性问题，如果cookie被人劫持，就可以获得所有的session信息</code></pre>\n<p>3、主流浏览器及内核</p>\n<blockquote>\n<p>Google chrome：webkit/blink<br/> safari：webkit<br/> IE：trident<br/> firefox：gecko<br/> Opera：presto/webkit/blink</p>\n</blockquote>\n<p>4、sessionStorage和localStorage的区别</p>\n<blockquote>\n<p>sessionStorage用于本地存储一个会话session中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据会被销毁。<br/> localStorage用于持久化的本地存储，除非主动删除数据，否则数据永远不会过期的。</p>\n</blockquote>\n<p>5、谈谈对bfc规范的理解</p>\n<blockquote>\n<p>bfc是block formatting context即格式化上下文<br/> bfc是页面css视觉渲染的一部分，用于决定块盒子的布局及浮动相互影响范围的一个区域<br/> bfc最重要的一个效果是，让处于bfc内部与外部的元素相互隔离，使内外的元素的定位不会相互影响</p>\n</blockquote>\n<p>6、请说出至少三种减少页面加载时间的方法</p>\n<blockquote>\n<p>尽量减少页面中重复的http请求<br/> css样式放置在文件头部、js脚本放置在文件末尾<br/> 压缩合并js、css代码<br/> 服务器开启gzip压缩</p>\n</blockquote>\n<p>7、 如何进行网站性能优化？</p>\n<blockquote>\n<p>content 方面<br/> 减少 HTTP 请求：合并文件、CSS 精灵、inline Image<br/> 减少 DNS 查询：DNS 缓存、将资源分布到恰当数量的主机名<br/> 减少 DOM 元素数量<br/> Server 方面<br/> 使用 CDN<br/> 配置 Etag<br/> 对组件使用 Gzip 压缩<br/> Cookie 方面<br/> 减少cookie大小<br/> css 方面<br/> 将样式表放到页面顶部<br/> 不使用 CSS 表达式<br/> 使用 &lt;link&gt; 不使用 @import<br/> Javascript 方面<br/> 将脚本放到页面底部<br/> 将 javascript 和 css 从外部引入<br/> 压缩 javascript 和 css<br/> 删除不需要的脚本<br/> 减少 DOM 访问<br/> 图片方面<br/> 优化图片：根据实际颜色需要选择色深、压缩<br/> 优化 css 精灵<br/> 不要在 HTML 中拉伸图片</p>\n</blockquote>\n<p><br/> 8、浏览器存储？</p>\n<blockquote>\n<p>短暂性的时候，我们只需要将数据存在内存中，只在运行时可用<br/> 持久性存储，可以分为 浏览器端 与 服务器端<br/> 浏览器:<br/> cookie : 通常用于存储用户身份，登录状态等，http 中自动携带， 体积上限为 4K ， 可自行设置过期时间<br/> localStorage / sessionStorage : 长久储存/窗口关闭删除， 体积限制为 4~5M<br/> indexDB<br/> 服务器<br/> 分布式缓存 redis<br/> 数据库</p>\n</blockquote>\n<p><br/> 9、get / post？</p>\n<blockquote>\n<p>get : 缓存、请求长度受限、会被历史保存记录<br/> 无副作用(不修改资源)，幂等(请求次数与资源无关)的场景<br/> post : 安全、大数据、更多编码类型</p>\n</blockquote>\n<p><br/> 10、安全性问题？</p>\n<blockquote>\n<p>XSS 攻击: 注入恶意代码<br/> cookie 设置 httpOnly<br/> 转义页面上的输入内容和输出内容<br/> CSRF : 跨站请求伪造，防护:<br/> get 不修改数据<br/> 不被第三方网站访问到用户的 cookie<br/> 设置白名单，不被第三方网站请求<br/> 请求校验</p>\n</blockquote>\n<p>【性能优化】<br/> 1、性能优化的几个方面?</p>\n<pre><code>资源压缩合并,减少HTTP请求\n非核心代码异步加载\n利用浏览器缓存\n使用CDN\n预解析DNS</code></pre>\n<p>2、异步加载?</p>\n<pre><code>动态脚本加载\ndefer\nasync</code></pre>\n<p>3、加载方式区别？</p>\n<pre><code>defer是在html解析完毕才执行,如果有多个则按加载顺序执行\nasync是加载完毕后立即执行,如果是多个,执行顺序与加载顺序无关</code></pre>\n<p>4、预加载?</p>\n<pre><code>在开发中，可能会遇到这样的情况。有些资源不需要马上用到，\n但是希望尽早获取，这时候就可以使用预加载。\n预加载其实是声明式的 fetch ，强制浏览器请求资源，\n并且不会阻塞 onload 事件，可以使用以下代码开启预加载\n&lt;link rel=\"preload\" href=\"http://example.com\"&gt;\n预加载可以一定程度上降低首屏的加载时间，\n因为可以将一些不影响首屏但重要的文件延后加载，唯一缺点就是兼容性不好。</code></pre>\n<p>5、DNS 预解析?</p>\n<pre><code>DNS 解析也是需要时间的，可以通过预解析的方式来预先获得域名所对应的 IP。\n\n&lt;meta http-equiv='x-dns-prefetch-control' content='on'&gt;\n&lt;link rel=\"dns-prefetch\" href=\"//yuchengkai.cn\"&gt;\n\n在https协议中默认a标签不会开启预解析,因此需要手动设置meta</code></pre>\n<p>6、懒执行?</p>\n<pre><code>懒执行就是将某些逻辑延迟到使用时再计算。\n该技术可以用于首屏优化，对于某些耗时逻辑并不需要在首屏就使用的，\n就可以使用懒执行。懒执行需要唤醒，一般可以通过定时器或者事件的调用来唤醒。</code></pre>\n<p>7、懒加载?</p>\n<pre><code>懒加载就是将不关键的资源延后加载。\n\n懒加载的原理就是只加载自定义区域（通常是可视区域，\n但也可以是即将进入可视区域）内需要加载的东西。对于图片来说，\n先设置图片标签的 src 属性为一张占位图，\n将真实的图片资源放入一个自定义属性中，当进入自定义区域时，\n就将自定义属性替换为 src 属性，这样图片就会去下载资源，实现了图片懒加载。\n\n懒加载不仅可以用于图片，也可以使用在别的资源上。比如进入可视区域才开始播放视频等等。</code></pre>\n<p>【react面试题】<br/> 1、什么时候使用状态管理器?</p>\n<pre><code>从项目的整体看\n目用户的使用方式复杂\n不同身份的用户有不同的使用方式（比如普通用户和管理员）\n多个用户之间可以协作\n与服务器大量交互，或者使用了 WebSocket\nView 要从多个来源获取数据\n从组件角度看\n某个组件的状态，需要共享\n某个状态需要在任何地方都可以拿到\n一个组件需要改变全局状态\n一个组件需要改变另一个组件的状态\n组件有相当大量的，随时间变化的数据\nstate 需要有一个单一可靠数据源\n所有 state 放在顶层组件已经无法满足需求了</code></pre>\n<p>2、说说 React 有什么特点?</p>\n<pre><code>它使用**虚拟 DOM **而不是真正的 DOM。\n它可以用服务器端渲染。\n它遵循单向数据流或数据绑定</code></pre>\n<p>3、列出 React 的一些主要优点?</p>\n<pre><code>它提高了应用的性能\n可以方便地在客户端和服务器端使用\n由于 JSX，代码的可读性很好\nReact 很容易与 Meteor，Angular 等其他框架集成\n使用 React，编写 UI 测试用例变得非常容易</code></pre>\n<p>4、什么是 JSX?</p>\n<p></p>\n<pre><code>它 JSX 是 J avaScript XML 的简写。是 React 使用的一种文件，\n它利用 JavaScript 的表现力和类似 HTML 的模板语法。\n这使得 HTML 文件非常容易理解。此文件能使应用非常可靠，并能够提高其性能。\n例子\nrender() {\n    return(\n         &lt;div&gt;\n            &lt;h1&gt; Hello World &lt;/h1&gt;\n        &lt;/div&gt;\n     )\n}</code></pre>\n<p>5、说说为什么浏览器无法读取 JSX?</p>\n<pre><code>浏览器只能处理 JavaScript 对象，而不能读取常规 JavaScript 对象中的 JSX。\n所以为了使浏览器能够读取 JSX，首先，\n需要用像 Babel 这样的 JSX 转换器将 JSX 文件转换为\nJavaScript 对象，然后再将其传给浏览器</code></pre>\n<p>6、你理解“在 React 中，一切都是组件”这句话?</p>\n<pre><code>组件是 React 应用 UI 的构建块。这些组件将整个 UI 分成小的独立并可重用的部分。\n每个组件彼此独立，而不会影响 UI 的其余部分</code></pre>\n<p>7、 React 中 render()的目的?</p>\n<pre><code>每个 React 组件强制要求必须有一个 render()。它返回一个 React 元素，\n是原生 DOM 组件的表示。如果需要渲染多个 HTML 元素，\n则必须将它们组合在一个封闭标记内，例如&lt;form&gt;、&lt;group&gt;、&lt;div&gt; 等。\n此函数必须保持纯净，即必须每次调用时都返回相同的结果</code></pre>\n<p>8、什么是 Props?</p>\n<pre><code>Props 是 React 中属性的简写。它们是只读组件，必须保持纯，即不可变。\n它们总是在整个应用中从父组件传递到子组件。子组件永远不能将 prop 送回父组件。\n这有助于维护单向数据流，通常用于呈现动态生成的数据</code></pre>\n<p>9、React 中的状态是什么？</p>\n<pre><code>状态是 React 组件的核心，是数据的来源，必须尽可能简单。\n基本上状态是确定组件呈现和行为的对象。与 Props 不同，\n它们是可变的，并创建动态和交互式组件。可以通过this.state() 访问它们。</code></pre>\n<p>10、区分状态和 Props?</p>\n<pre><code>条件    State    Props\n从父组件中接受初始值    Yes    Yes\n父组件可以改变值    No    Yes\n在组件中设置默认值    No    Yes\n在组件的内部变化    Yes    No\n设置子组件的初始值    Yes    Yes\n在子组件的内部改变    No    Yes</code></pre>\n<p>11、如何更新组件的状态?</p>\n<pre><code>使用this.setState()更新组件的状态</code></pre>\n<p>12、React 组件生命周期的阶段是什么?</p>\n<pre><code>React 组件的生命周期有三个不同的阶段：\n初始渲染阶段：这是组件即将开始其生命之旅并进入 DOM 的阶段。\n更新阶段：一旦组件被添加到 DOM，它只有在 prop 或状态发生变化时才可能更新和重新渲染。\n这些只发生在这个阶段\n卸载阶段：这是组件生命周期的最后阶段，组件被销毁并从 DOM 中删除</code></pre>\n<p>13、你对 React 的 refs 有什么了解?</p>\n<pre><code>Refs 是 React 中引用的简写。\n它是一个有助于存储对特定的 React 元素或组件的引用的属性，\n它将由组件渲染配置函数返回。用于对 render()返回的特定元素或组件的引用。\n当需要进行 DOM 测量或向组件添加方法时，它们会派上用场\n列出一些应该使用 refs 的情况?\n需要管理焦点、选择文本或媒体播放时\n触发式动画\n与第三方 DOM 库集成</code></pre>\n<p>14、如何模块化 React 中的代码?</p>\n<pre><code>可以使用 export 和 import 属性来模块化代码。它们有助于在不同的文件中单独编写组件</code></pre>\n<p>15、什么是高阶组件 HOC?</p>\n<pre><code>高阶组件是重用组件逻辑的高级方法，是一种源于 React 的组件模式。\n HOC 是自定义组件，在它之内包含另一个组件。它们可以接受子组件提供的任何动态，\n但不会修改或复制其输入组件中的任何行为。你可以认为 HOC 是“纯（Pure）”组件</code></pre>\n<p>16、你能用 HOC 做什么?</p>\n<pre><code>HOC 可用于许多任务:\n用代码重用，逻辑和引导抽象\n渲染劫持\n状态抽象和控制\nProps 控制</code></pre>\n<p>17、 React 中 key 的重要性是什么?</p>\n<pre><code>key 用于识别唯一的 Virtual DOM 元素及其驱动 UI 的相应数据。\n它们通过回收 DOM 中当前所有的元素来帮助 React 优化渲染。\n这些 key 必须是唯一的数字或字符串，React 只是重新排序元素而不是重新渲染它们。\n这可以提高应用程序的性能</code></pre>\n<p>18、MVC 框架的主要问题是什么?</p>\n<pre><code>key 用对 DOM 操作的代价非常高\n程序运行缓慢且效率低下\n内存浪费严重\n由于循环依赖性，组件模型需要围绕 models 和 views 进行创建</code></pre>\n<p>19、请你解释一下 Flux?</p>\n<pre><code>\nFlux 是一种强制单向数据流的架构模式。它控制派生数据，\n并使用具有所有数据权限的中心store 实现多个组件之间的通信。\n整个应用中的数据更新必须只能在此处进行。\n Flux 为应用提供稳定性并减少运行时的错误。</code></pre>\n<p>20、你对“单一事实来源”有什么理解</p>\n<pre><code>Redux 使用 “store” 将程序的整个状态存储在同一个地方。\n因此所有组件的状态都存储在store 中，\n并且它们从 store 本身接收更新。\n单一状态树可以更容易地跟踪随时间的变化，\n并调试或检查程序。</code></pre>\n<p>21、列出 Redux 的组件?</p>\n<pre><code>Redux 由以下组件组成:\nAction 这是一个用来描述发生了什么事情的对象\nReducer 这是一个确定状态将如何变化的地方\nStore 整个程序的状态/对象树保存在 Store 中\nView 查只显示 Store 提供的数据</code></pre>\n<p>22、 Store 在 Redux 中的意义是什么?</p>\n<pre><code>store 是一个 JavaScript 对象，它可以保存程序的状态，\n并提供一些方法来访问状态、调度操作和注册侦听器。\n应用程序的整个状态/对象树保存在单一存储中。\n因此，Redux 非常简单且是可预测的。\n我们可以将中间件传递到 store 来处理数据，并记录改变存储状态的各种操作。\n所有操作都通过 Reducer 返回一个新状态</code></pre>\n<p>23、 Redux 有哪些优点?</p>\n<pre><code>结果的可预测性\n可维护性\n服务器端渲染\n易于测试 -</code></pre>\n<p>24、 什么是 React 路由?</p>\n<pre><code>React 路由是一个构建在 React 之上的强大的路由库，\n它有助于向应用程序添加新的屏幕和流。这使 URL 与网页上显示的数据保持同步。\n它负责维护标准化的结构和行为，并用于开发单页 Web 应用。 React 路由有一个简单的 API。</code></pre>\n<p>25、说说你对 React 的渲染原理的理解?</p>\n<pre><code>单向数据流。React 是一个 MVVM 框架，\n简单来说是在 MVC 的模式下在前端部分拆分出数据层和视图层。\n单向数据流指的是只能由数据层的变化去影响视图层的变化，而不能反过来（除非双向绑定）\n数据驱动视图。我们无需关注页面的 DOM，只需要关注数据即可\n渲染过程，生命周期……\nsetState()大部分时候是异步执行的，提升性能。\n</code></pre>\n<p>26、React 中三种构建组件的方式?</p>\n<blockquote>\n<p>React.createClass()、ES6 class 和无状态函数。</p>\n</blockquote>\n<p><br/> 【JQuery面试题】<br/> 说出jQuery中常见的几种函数以及他们的含义是什么?</p>\n<pre><code>（1）get()取得所有匹配的DOM元素集合；\n（2）get(index)取得其中一个匹配的元素.index表示取得第几个匹配的元素；\n（3）append(content)向每个匹配的元素内部追加内容；\n（4）after(content)在每个匹配的元素之后插入内容；\n（5）html()/html(var)取得或设置匹配元素的html内容；\n（6）find(expr)搜索所有与指定表达式匹配的元素；\n（7）bind(type,[data],fn)为每个匹配元素的特定事件绑定事件处理函数；\n（8）empty()删除匹配的元素集合中所有的子节点；\n（9）hover(over,out)一个模仿悬停事件(鼠标移动到一个对象上面及移出这个对象)的方法；\n（10）attr(name)取得第一个匹配元素的属性值。</code></pre>\n<p>jQuery 能做什么？</p>\n<pre><code>获取页面的元素；修改页面的外观；改变页面大的内容；响应用户的页面操作；为页面添加动\n态效果；无需刷新页面，即可以从服务器获取信息；简化常见的javascript任务。\n\n如何将一个HTML元素添加到DOM树中的？\n可以通过appendTo()方法在指定的DOM元素末尾添加一个现存的元素或者一个新的HTML元素。</code></pre>\n<p>什么是jQuery? jQuer能做什么？</p>\n<pre><code>jQuery是一套JavaScript的库，它简化了使用Javascript进行网页特效开发的一些复杂性，\n提供了对常见任务的自动化和复杂任务的简化</code></pre>\n<p>jQuery的作用</p>\n<pre><code>快速获取文档元素\n提供漂亮的页面动态效果\n创建Ajax无刷新网页\n提供对JavaScript语言的增强\n增强的事件处理\n更改网页内容\nJQuery可以修改网页中的内容,比如更改网页的文本、\n插入或转网页图像, jQuery简化了原本使用JavaScript代码需要处理的方式。</code></pre>\n<p>JQuery 的优点</p>\n<pre><code>1.利用css的选择器提供高速的元素查找行为。\n2.提供了一个抽象层来标准化各种常见的任务，可以解决各种浏览器的兼容问题。\n3.将复杂的代码简化，提供连缀编程模式，大大简化了代码的操作。</code></pre>\n<p></p>\n</div>\n</div>"}