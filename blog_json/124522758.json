{"blogid": "124522758", "writerAge": "码龄1年", "writerBlogNum": "19", "writerCollect": "2056", "writerComment": "1005", "writerFan": "2713", "writerGrade": "5级", "writerIntegral": "3587", "writerName": "小张﹉", "writerProfileAdress": "writer_image\\profile_124522758.jpg", "writerRankTotal": "7465", "writerRankWeekly": "83142", "writerThumb": "1617", "writerVisitNum": "37836", "blog_read_count": "1063", "blog_time": "已于 2022-07-17 18:47:47 修改", "blog_title": "汉诺塔以及C语言练手经典题", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\" style=\"text-align:center;\"><strong>目录</strong></p>\n<p id=\"%E5%89%8D%E8%A8%80%C2%A0-toc\" style=\"margin-left:0px;text-align:center;\"><a href=\"#%E5%89%8D%E8%A8%80%C2%A0\">前言 (很重要)</a></p>\n<p id=\"%C2%A0%C2%A0%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E9%80%92%E5%BD%92%E6%B1%82%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98-toc\" style=\"margin-left:0px;text-align:center;\"><a href=\"#%C2%A0%C2%A0%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E9%80%92%E5%BD%92%E6%B1%82%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98\">  ​​​​​​递归求汉诺塔问题</a></p>\n<p id=\"%C2%A0%E9%80%92%E5%BD%92%E6%B1%82%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97-toc\" style=\"margin-left:0px;text-align:center;\"><a href=\"#%C2%A0%E9%80%92%E5%BD%92%E6%B1%82%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97\"> 递归求斐波那契数列</a></p>\n<p id=\"%C2%A0%E6%95%B0%E5%AD%97%E9%87%91%E5%AD%97%E5%A1%94-toc\" style=\"margin-left:0px;text-align:center;\"><a href=\"#%C2%A0%E6%95%B0%E5%AD%97%E9%87%91%E5%AD%97%E5%A1%94\"> 数字金字塔</a></p>\n<p id=\"%E5%A4%A7%E5%B0%8F%E5%86%99%E5%AD%97%E6%AF%8D%E7%9A%84%E8%BD%AC%E6%8D%A2-toc\" style=\"margin-left:0px;text-align:center;\"><a href=\"#%E5%A4%A7%E5%B0%8F%E5%86%99%E5%AD%97%E6%AF%8D%E7%9A%84%E8%BD%AC%E6%8D%A2\">大小写字母的转换</a></p>\n<p id=\"%C2%A0%C2%A0%E2%80%8B%E7%BC%96%E8%BE%91%C2%A0-toc\" style=\"margin-left:0px;text-align:center;\"><a href=\"#%C2%A0%C2%A0%E2%80%8B%E7%BC%96%E8%BE%91%C2%A0\">  ​编辑 </a></p>\n<p id=\"%C2%A0%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E7%B4%A0%E6%95%B0-toc\" style=\"margin-left:0px;text-align:center;\"><a href=\"#%C2%A0%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E7%B4%A0%E6%95%B0\"> 判断是否为素数</a></p>\n<p id=\"%E7%BB%93%E6%9D%9F%E8%AF%AD%C2%A0-toc\" style=\"margin-left:0px;text-align:center;\"><a href=\"#%E7%BB%93%E6%9D%9F%E8%AF%AD%C2%A0\">结束语 </a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h1 id=\"%E5%89%8D%E8%A8%80%C2%A0\">前言 (很重要)</h1>\n<blockquote>\n<p>        大家好，这里是小张，今天是五一劳动节，小张在这里祝<strong>大家劳动节快乐</strong>，然后今天给大家带来的是<strong>C语言入门经典题目详解。</strong></p>\n<p><strong>         另外有很多小伙伴们在学习算法的时候，只去学习一些关于算法理论的知识，并不知道自己的代码实战能力如何，也不清楚到底对该算法的了解有多深，所以在这里小张给大家推荐一个很棒的平台，在这里有很多的面试和算法题，也有很多的面试和求职的机会，大家可以点击下方链接进入牛客网刷算法真题，提高自己代码实战能力，早日拿到满意的offer！</strong><br/><a class=\"link-info\" href=\"https://www.nowcoder.com/exam/oj/ta?tpId=13&amp;fromPut=pc_csdncpt_xiaozhang_jzsf\" title=\"点击这里进入牛客网刷算法面试真题提高实战能力\">点击这里进入牛客网刷算法面试真题提高实战能力</a></p>\n</blockquote>\n<h1 id=\"%C2%A0%C2%A0%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E9%80%92%E5%BD%92%E6%B1%82%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98\">  ​​​​​​递归求汉诺塔问题</h1>\n<p><strong>汉诺塔</strong>（Tower of Hanoi），又称<strong>河内塔</strong>，是一个源于<a href=\"https://baike.baidu.com/item/%E5%8D%B0%E5%BA%A6/121904\" title=\"印度\">印度</a>古老传说的<a href=\"https://baike.baidu.com/item/%E7%9B%8A%E6%99%BA%E7%8E%A9%E5%85%B7/223159\" title=\"益智玩具\">益智玩具</a>。<a href=\"https://baike.baidu.com/item/%E5%A4%A7%E6%A2%B5%E5%A4%A9/711550\" title=\"大梵天\">大梵天</a>创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令<a href=\"https://baike.baidu.com/item/%E5%A9%86%E7%BD%97%E9%97%A8/1796550\" title=\"婆罗门\">婆罗门</a>把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。</p>\n<p>当只有一个盘子的时候可以直接从A移动到C：<strong>A-&gt;C</strong><br/><img alt=\"64fe0d6475a75956eda092da06f0ad86.gif\" src=\"https://img-blog.csdnimg.cn/img_convert/64fe0d6475a75956eda092da06f0ad86.gif\"/></p>\n<p>当有两个盘子的时候，就需要借助中转站B：<strong>A-&gt;B A-&gt;C B-&gt;C</strong></p>\n<p><img alt=\"b92c952b976bd09f1c13eb5a7b5297a2.gif\" src=\"https://img-blog.csdnimg.cn/img_convert/b92c952b976bd09f1c13eb5a7b5297a2.gif\"/></p>\n<p></p>\n<p> 当有三个盘子的时候，就需要借助中转站B和C：<strong>A-&gt;C A-&gt;B C-&gt;B A-&gt;C B-&gt;A B-&gt;C A-&gt;C</strong></p>\n<p><img alt=\"581b6c9f27f0609a6cd9c22b52c3b4bb.gif\" src=\"https://img-blog.csdnimg.cn/img_convert/581b6c9f27f0609a6cd9c22b52c3b4bb.gif\"/></p>\n<p>思路 </p>\n<ol><li>将 n-1个环先放到B柱子上</li><li>将A柱子上的最后一个环移动到C柱子上</li><li> 将n-1个环从B柱子移动到C柱子上</li></ol>\n<p>既然我们知道了思路那么我们来试试运用代码来实现：</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\nusing namespace std;\nvoid move(char pos1,char pos2)\n{\n\tcout &lt;&lt; \"     从\" &lt;&lt; pos1 &lt;&lt; \"移动到\" &lt;&lt; pos2 &lt;&lt; endl;\n}\nvoid hanoi(int n,char pos1, char pos2, char pos3)\n{\n\tif (n == 1)\n\t{\n\t\tmove(pos1, pos3);\n\t}\n\telse\n\t{\n\t\thanoi(n - 1, pos1, pos3, pos2);//把n-1个从起始位置pos1移动到pos2，pos3不就成了中转站//中转站：负责将两个位置的汉诺塔进行换位置以至于移动到预期的位置\n\t\tmove(pos1, pos3);\n\t\thanoi(n - 1, pos2, pos1, pos3);//再把n-1个从起始位置pos2移动到pos3，pos1不就成了中转站\n\t}\n}\nint main()\n{\n\tint n = 0;\n\tcout &lt;&lt; \"请输入您要进行几个汉诺塔的移动\" &lt;&lt; endl;\n\tcin &gt;&gt; n;\n\tcout &lt;&lt; \"现在开始进行移动\" &lt;&lt; endl;\n\thanoi(n, 'A', 'B', 'C');\n\treturn 0;\n}\n</code></pre>\n<p> 运行结果如下：<br/>  <img alt=\"2656207b29014ccc8f1ee908c4d7c654.png\" src=\"image\\2656207b29014ccc8f1ee908c4d7c654.png\"/> </p>\n<h1 id=\"%C2%A0%E9%80%92%E5%BD%92%E6%B1%82%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97\"> 递归求斐波那契数列</h1>\n<p>        那么什么叫做斐波那契数列呢，<strong>斐波那契数列</strong>指的是这样一个数列：1，1，2，3，5，8，13，21，34，55，89...这个数列从第3项开始，每一项都等于前两项之和。</p>\n<p> 意思就是说数列的前两项都是1，后面的都是前两项之和，那么我们知道了原理，现在就开始写求斐波那契数列的代码：</p>\n<pre><code class=\"language-cpp\">int fin(int n){if (n == 2 || n == 1)//如果此时n为1或者n为2那么它的斐波那契数列就是1{return 1;}else{return fin(n- 1) + fin(n - 2);//如果不是前两项，那么它就返回前两项之和}}</code></pre>\n<p> 这一块是运用了递归进行求解</p>\n<p>整体代码如下：</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\nusing namespace std;\nint fin(int n)\n{\n\tif (n == 2 || n == 1)//可以改成if(n&lt;=2)\n\t{\n\t\treturn 1;\n\t}\n\telse\n\t{\n\t\treturn fin(n- 1) + fin(n - 2);\n\t}\n}\nint main()\n{\n\tint n = 0;\n\tcin &gt;&gt; n;\n\tint sum = fin(n);\n\tcout &lt;&lt; sum &lt;&lt; endl;\n\treturn 0;\n}</code></pre>\n<p>递归的话好理解，但是计算机要<strong>执行多次重复的计算</strong>，会使工作量大大的增加，比如此时的斐波那契数列的递归，<strong>如果输入的值过大，那么就会计算很长时间</strong>，例如输入60，我的电脑就要至少计算十分钟左右，很长时间出不来结果：</p>\n<p> <img alt=\"7d2d1a866b71432893c0a34d989827b7.png\" src=\"image\\7d2d1a866b71432893c0a34d989827b7.png\"/> </p>\n<p>于是我们对于斐波那契数列可以使用非递归的方法，代码如下：<br/>  </p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\nusing namespace std;\nint main()\n{\n\tint i = 0, j = 0, n = 0, sum = 0, a = 0, b = 0;\n\tcin &gt;&gt; n;\n\tif (n &lt;= 2)\n\t{\n\t\tsum = 1;\n\t}\n\telse if (n &gt; 2)\n\t{\n\t\ta = 1;\n\t\tb = 1;\n\t\tfor (i = 0; i &lt; n - 2; i++)\n\t\t{\n\t\t\tsum = a + b;\n\t\t\ta = b;\n\t\t\tb = sum;\n\t\t}\n\t}\n\tcout &lt;&lt; sum &lt;&lt; endl;\n\treturn 0;\n}</code></pre>\n<p> 此时就能大大的提高计算的效率</p>\n<p> <img alt=\"aff0f91ed9514f5995eebd4be0e76c70.png\" src=\"image\\aff0f91ed9514f5995eebd4be0e76c70.png\"/>  </p>\n<p></p>\n<h1 id=\"%C2%A0%E6%95%B0%E5%AD%97%E9%87%91%E5%AD%97%E5%A1%94\"> 数字金字塔</h1>\n<p>    1<br/>    1 1<br/>   1 1 1<br/>  1 1 1 1<br/> 1 1 1 1 1</p>\n<p>我们首先来观察这个金字塔，在第一行的1前面有四个空格，在第二行1的前面有三个空格，在第三行1的前面有二个空格，在第四行1的前面有一个空格，在第五行1的前面有0个空格。于是根据等差数列的通项公式可以得到在<strong>第i行有5-i个空格</strong>，那么这块的代码如下：<br/>  </p>\n<pre><code class=\"language-cpp\">int j = 0;for (j = 0; j &lt; 5-i; j++){cout &lt;&lt; \" \";//打印空格}</code></pre>\n<p>此时再来观察1的个数，在第一行有一个1，在第二行有两个1，在第三行有三个1，在第四行有四个1，在第五行1有五个1，于是在<strong>第n行的话就有n个1，</strong>这一块的代码如下：</p>\n<pre><code class=\"language-cpp\">for (j = 0; j &lt; i; j++){cout &lt;&lt; n&lt;&lt;\" \";//打印数字}</code></pre>\n<p> 总体代码如下：<br/>  </p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\nusing namespace std;\nint main()\n{\n\tint i = 0, n = 0;\n\tcin &gt;&gt; n;\n\tfor (i = 1; i &lt;= 5; i++)\n\t{\n\t\tint j = 0;\n\t\tfor (j = 0; j &lt; 5-i; j++)\n\t\t{\n\t\t\tcout &lt;&lt; \" \";\n\t\t}\n\t\tfor (j = 0; j &lt; i; j++)\n\t\t{\n\t\t\tcout &lt;&lt; n&lt;&lt;\" \";\n\t\t}\n\t\tcout &lt;&lt; endl;\n\t}\n\treturn 0;\n}</code></pre>\n<p> 运行结果如下：<br/>  <img alt=\"8f876fc06af1485ea945c740ec3dcb6d.png\" src=\"image\\8f876fc06af1485ea945c740ec3dcb6d.png\"/> </p>\n<h1 id=\"%E5%A4%A7%E5%B0%8F%E5%86%99%E5%AD%97%E6%AF%8D%E7%9A%84%E8%BD%AC%E6%8D%A2\">大小写字母的转换</h1>\n<h1 id=\"%C2%A0%C2%A0%E2%80%8B%E7%BC%96%E8%BE%91%C2%A0\">  <img alt=\"c5a8f5f329864b029e8dc59049d58b6b.png\" src=\"image\\c5a8f5f329864b029e8dc59049d58b6b.png\"/> </h1>\n<p>这是一张ASCII码表，我们不难看出<strong>大小写字母之间的差值为32</strong>，所以我们就可以利用这个差值来进行大小写字母的转换：<br/> 代码如下：</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\nusing namespace std;\nint main()\n{\n\tchar arr[100];\n\tgets_s(arr);\n\tint i = 0, count = 0;\n\twhile (arr[i] != '\\0')\n\t{\n\t\tcount++;\n\t\ti++;\n\t}\n\tfor (i = 0; i &lt; count; i++)\n\t{\n\t\tif (arr[i] &gt;= 'a'&amp;&amp;arr[i] &lt;= 'z')\n\t\t{\n\t\t\tarr[i] = arr[i] - 32;\n\t\t\tcout &lt;&lt; arr[i] ;\n\t\t}\n\t\telse if (arr[i] &gt;= 'A'&amp;&amp;arr[i] &lt;= 'Z')\n\t\t{\n\t\t\tarr[i] = arr[i] + 32;\n\t\t\tcout &lt;&lt; arr[i];\n\t\t}\n\t}\n\treturn 0;\n}</code></pre>\n<p> 其中的EOF是一个计算机术语，为<strong>End Of File的缩写</strong>，在操作系统中表示资料源无更多的资料可读取。资料源通常称为档案或串流。通常在文本的最后存在此字符表示资料结束。在控制台中可以<strong>通过CTRL+Z再按回车健结束</strong>。</p>\n<p>运行结果如下：</p>\n<p> <img alt=\"a5e8d117125040859beb32e9afef7e4a.png\" src=\"image\\a5e8d117125040859beb32e9afef7e4a.png\"/> </p>\n<h1 id=\"%C2%A0%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E7%B4%A0%E6%95%B0\"> 判断是否为素数</h1>\n<p>首先我们应该知道什么是素数，“<strong>素数一般指质数。质数是指在大于1的自然数中，除了1和它本身以外不再有其他因数的自然数。</strong>” 我们现在知道了素数的原理，那我们现在就开始写代码。</p>\n<p>首先应该判断是否为素数，代码如下：</p>\n<pre><code class=\"language-cpp\">bool is_prime(int i)//布尔类型{int j = 0;for (j = 2; j &lt; i; j++)//从二到它自身进行遍历{if (i%j == 0){return false;//不是素数，返回false}}if (j == i){return true;//是素数，返回true}}</code></pre>\n<p>这一块的代码是运用了布尔类型判断一个数是否为素数，<strong>如果一个数从二到自身前一个数都不能被整除的话，那么它就是素数，此时布尔类型返回true。</strong></p>\n<p>到了这里可能会有小伙伴不太理解什么是布尔类型，那我们就在此解释一下吧：</p>\n<p><strong>在c99种引入了布尔类型</strong>（ bool）</p>\n<ol><li>布尔类型只有两个值，false 和 true。</li><li>通常用来判断条件是否成立。</li><li>C语言语法规定，如果变量值为 0 就是 false，否则为 true,布尔变量只有这两个值。 </li></ol>\n<p>整体代码如下：</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\nusing namespace std;\nbool is_prime(int i)\n{\n\tint j = 0;\n\tfor (j = 2; j &lt; i; j++)\n\t{\n\t\tif (i%j == 0)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (j == i)\n\t{\n\t\treturn true;\n\t}\n}\nint main()\n{\n\tint i = 0;\n\twhile (cin &gt;&gt; i)\n\t{\n\t\tif (is_prime(i))\n\t\t{\n\t\t\tcout &lt;&lt; i &lt;&lt; \"是素数\" &lt;&lt; endl;\n\t\t}\n\t\telse if (!is_prime(i))\n\t\t{\n\t\t\tcout &lt;&lt; i &lt;&lt; \"不是素数\" &lt;&lt; endl;\n\t\t}\n\t}\n\treturn 0;\n}</code></pre>\n<p>运行结果如下：<br/>   <img alt=\"5589a900eb1540f0b3e1b242889807d3.png\" src=\"image\\5589a900eb1540f0b3e1b242889807d3.png\"/>  </p>\n<h1 id=\"%E7%BB%93%E6%9D%9F%E8%AF%AD%C2%A0\">结束语 </h1>\n<p>         到了这里今天的全波内容就已经全部的结束了，希望小张的这些题目的讲解可以<strong>给大家带来帮助</strong>，同时也希望大家可以<strong>多多支持支持小张，小张在这里提前谢谢大家啦！</strong></p>\n<p><img alt=\"b3d1ec2fa19547b58f4d46c278396fd6.png\" src=\"image\\b3d1ec2fa19547b58f4d46c278396fd6.png\"/></p>\n<p></p>\n<p></p>\n</div>\n</div>"}