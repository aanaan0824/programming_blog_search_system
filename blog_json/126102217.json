{"blogid": "126102217", "writerAge": "码龄1年", "writerBlogNum": "25", "writerCollect": "2049", "writerComment": "1518", "writerFan": "2633", "writerGrade": "6级", "writerIntegral": "4561", "writerName": "猿力猪", "writerProfileAdress": "writer_image\\profile_126102217.jpg", "writerRankTotal": "4640", "writerRankWeekly": "15864", "writerThumb": "1555", "writerVisitNum": "113072", "blog_read_count": "2878", "blog_time": "于 2022-08-01 17:09:52 发布", "blog_title": "【OpenCV】红绿灯识别 轮廓识别 C++ OpenCV 案例实现", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h1 id=\"%E7%9B%AE%E5%BD%95\">目录</h1>\n<p id=\"%E5%89%8D%E8%A8%80-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%89%8D%E8%A8%80\">前言</a></p>\n<p id=\"%E4%B8%80%E3%80%81%E8%BD%AE%E5%BB%93%E8%AF%86%E5%88%AB%E7%9B%B8%E5%85%B3%E5%8E%9F%E7%90%86-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%80%E3%80%81%E8%BD%AE%E5%BB%93%E8%AF%86%E5%88%AB%E7%9B%B8%E5%85%B3%E5%8E%9F%E7%90%86\">一、轮廓识别相关原理</a></p>\n<p id=\"%E4%BB%80%E4%B9%88%E6%98%AF%E8%BD%AE%E5%BB%93%E6%A3%80%E6%B5%8B%EF%BC%9F%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BD%AE%E5%BB%93%E6%A3%80%E6%B5%8B%EF%BC%9F%C2%A0\">什么是轮廓检测？ </a></p>\n<p id=\"findContours%E5%87%BD%E6%95%B0%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#findContours%E5%87%BD%E6%95%B0%C2%A0\">轮廓提取函数  findContours</a></p>\n<p id=\"%E4%BA%8C%E3%80%81%E6%A1%88%E4%BE%8B%E5%AE%9E%E7%8E%B0-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BA%8C%E3%80%81%E6%A1%88%E4%BE%8B%E5%AE%9E%E7%8E%B0\">二、案例实现</a></p>\n<p id=\"Step1%EF%BC%9A%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE-toc\" style=\"margin-left:40px;\"><a href=\"#Step1%EF%BC%9A%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE\">Step1：初始化配置</a></p>\n<p id=\"Step2%EF%BC%9A%E8%BF%9B%E8%A1%8C%E5%B8%A7%E5%A4%84%E7%90%86-toc\" style=\"margin-left:40px;\"><a href=\"#Step2%EF%BC%9A%E8%BF%9B%E8%A1%8C%E5%B8%A7%E5%A4%84%E7%90%86\">Step2：进行帧处理</a></p>\n<p id=\"Step2%EF%BC%9A%E8%86%A8%E8%83%80%E8%85%90%E8%9A%80%E5%A4%84%E7%90%86-toc\" style=\"margin-left:40px;\"><a href=\"#Step2%EF%BC%9A%E8%86%A8%E8%83%80%E8%85%90%E8%9A%80%E5%A4%84%E7%90%86\">Step3：膨胀腐蚀处理</a></p>\n<p id=\"Step3%EF%BC%9A%E7%BA%A2%E7%BB%BF%E7%81%AF%E6%8F%90%E7%A4%BA%E5%88%A4%E6%96%AD-toc\" style=\"margin-left:40px;\"><a href=\"#Step3%EF%BC%9A%E7%BA%A2%E7%BB%BF%E7%81%AF%E6%8F%90%E7%A4%BA%E5%88%A4%E6%96%AD\">Step4：红绿灯提示判断</a></p>\n<p id=\"Step4%EF%BC%9A%E8%BD%AE%E5%BB%93%E6%8F%90%E5%8F%96-toc\" style=\"margin-left:40px;\"><a href=\"#Step4%EF%BC%9A%E8%BD%AE%E5%BB%93%E6%8F%90%E5%8F%96\">Step5：轮廓提取</a></p>\n<p id=\"%C2%A0Step4%EF%BC%9A%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A0Step4%EF%BC%9A%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4\">Step4：判断是否相交</a></p>\n<p id=\"%E6%A1%88%E4%BE%8B%E6%95%88%E6%9E%9C-toc\" style=\"margin-left:40px;\"><a href=\"#%E6%A1%88%E4%BE%8B%E6%95%88%E6%9E%9C\">🚀案例效果</a></p>\n<p id=\"%F0%9F%92%A1%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81-toc\" style=\"margin-left:40px;\"><a href=\"#%F0%9F%92%A1%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81\">💡完整代码</a></p>\n<p id=\"%E4%B8%89%E3%80%81%E6%80%BB%E7%BB%93-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%89%E3%80%81%E6%80%BB%E7%BB%93\">三、总结</a></p>\n<hr/>\n<h1 id=\"%E5%89%8D%E8%A8%80\">前言</h1>\n<p>本文以实现行车过程当中的<span style=\"color:#be191c;\"><strong>红绿灯识别</strong></span>为目标，核心的内容包括：<span style=\"color:#be191c;\"><strong>OpenCV轮廓识别原理</strong></span>以及<span style=\"color:#be191c;\"><strong>OpenCV红绿灯识别</strong></span>的实现具体步骤</p>\n<h1 id=\"%E4%B8%80%E3%80%81%E8%BD%AE%E5%BB%93%E8%AF%86%E5%88%AB%E7%9B%B8%E5%85%B3%E5%8E%9F%E7%90%86\"><strong>一、轮廓识别相关原理</strong></h1>\n<p><img alt=\"\" src=\"image\\9dfb9a0f6dee40a0b05f2a6f01ffd0e4.png\"/></p>\n<h2 id=\"%E4%BB%80%E4%B9%88%E6%98%AF%E8%BD%AE%E5%BB%93%E6%A3%80%E6%B5%8B%EF%BC%9F%C2%A0\">什么是轮廓检测？ </h2>\n<ul><li>目前轮廓检测方法有两类，一类是利用传统的边缘检测算子检测目标轮廓，另一类是从人类视觉系统中提取可以使用的数学模型完成目标轮廓检测</li></ul>\n<p><img alt=\"\" height=\"408\" src=\"image\\0a70a07b26404800a661e3005d72e7b3.png\" width=\"1107\"/> </p>\n<h2 id=\"findContours%E5%87%BD%E6%95%B0%C2%A0\">轮廓提取函数  <strong>findContours</strong></h2>\n<blockquote>\n<p><strong>📍函数原型: </strong>findContours( InputOutputArray <span style=\"color:#4da8ee;\">image</span>, OutputArrayOfArrays <span style=\"color:#4da8ee;\">contours</span>,<br/>                               OutputArray<span style=\"color:#4da8ee;\"> hierarchy</span><span style=\"color:#494949;\">,</span><span style=\"color:#4da8ee;\"> int mode</span>,<br/>                               int method, Point offset=<span style=\"color:#4da8ee;\">Point()</span>);</p>\n</blockquote>\n<blockquote>\n<p><strong>📍参数：</strong></p>\n<p></p>\n<p><span style=\"color:#4da8ee;\"><strong>1️⃣image：</strong></span>单通道图像矩阵，可以是灰度图，但更常用的是二值图像，一般是经过Canny、拉普拉斯等边缘检测算子处理过的二值图像</p>\n<p></p>\n<p><strong><span style=\"color:#4da8ee;\">2️⃣contours:</span> </strong> 定义为“vector&lt;vector&lt;Point&gt;&gt; contours”，是一个向量，并且是一个双重向量，向量内每个元素保存了一组由连续的Point点构成的点的集合的向量，每一组Point点集就是一个轮廓。有多少轮廓，向量contours就有多少元素</p>\n<p></p>\n<p><strong><span style=\"color:#4da8ee;\">3️⃣hierarchy:</span> </strong> 也是一个向量，向量内每个元素保存了一个包含4个int整型的数组。向量内的元素和轮廓向量contours内的元素是一一对应的，向量的容量相同</p>\n<p></p>\n<p><span style=\"color:#4da8ee;\"><strong>4️⃣int mode: </strong></span></p>\n<p>取值一：CV_CHAIN_APPROX_NONE 保存物体边界上所有连续的轮廓点到 contours向量内</p>\n<p>取值二：CV_CHAIN_APPROX_SIMPLE 仅保存轮廓的拐点信息，把所有轮廓拐点处的点保存入contours向量内，拐点与拐点之间直线段上的信息点不予保留</p>\n<p>取值三和四：CV_CHAIN_APPROX_TC89_L1，CV_CHAIN_APPROX_TC89_KCOS使用teh-Chinl chain 近似算法</p>\n<p></p>\n<p><span style=\"color:#4da8ee;\"><strong>5️⃣Point：</strong></span> Point偏移量，所有的轮廓信息相对于原始图像对应点的偏移量，相当于在每一个检测出的轮廓点上加上该偏移量，并且Point还可以是负值！</p>\n</blockquote>\n<p><strong>参数详解引用出处：</strong><a href=\"https://blog.csdn.net/dcrmg/article/details/51987348#\" title=\"findContours函数参数详解_-牧野-的博客-CSDN博客_findcontours函数\">findContours函数参数详解_-牧野-的博客-CSDN博客_findcontours函数</a> </p>\n<p> </p>\n<h1 id=\"%E4%BA%8C%E3%80%81%E6%A1%88%E4%BE%8B%E5%AE%9E%E7%8E%B0\">二、案例实现</h1>\n<ul><li>这是本案例所用到的素材，如下图所示： </li></ul>\n<p><img alt=\"\" height=\"1200\" src=\"image\\48afc30206f8497291bdf23760c4b3a8.png\" width=\"1200\"/></p>\n<p><strong>PS：</strong>视频的效果比较好，如果方便的话可以自行外出拍摄取材</p>\n<p> </p>\n<h2 id=\"Step1%EF%BC%9A%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE\">Step1：初始化配置</h2>\n<ul><li>做好准备工作，创建我们需要的内容，设置亮度参数，以及我们导入的视频路径</li></ul>\n<pre><code class=\"language-cpp\">    int redCount = 0;\n    int greenCount = 0;\n\n    Mat frame;\n    Mat img;\n    Mat imgYCrCb;\n    Mat imgGreen;\n    Mat imgRed;\n\n    // 亮度参数\n    double a = 0.3;\n    double b = (1 - a) * 125;\n\n    VideoCapture capture(\"C:/Users/86177/Desktop/image/123.mp4\");//导入视频的路径\n    if (!capture.isOpened())\n    {\n        cout &lt;&lt; \"Start device failed!\\n\" &lt;&lt; endl;//启动设备失败！\n        return -1;\n    }\n</code></pre>\n<h2 id=\"Step2%EF%BC%9A%E8%BF%9B%E8%A1%8C%E5%B8%A7%E5%A4%84%E7%90%86\">Step2：进行帧处理</h2>\n<ul><li>调整视频亮度，分解YCrCb的三个成分，拆分红色和绿色，方便对红绿两种颜色进行特征提取</li></ul>\n<pre><code class=\"language-cpp\">    // 帧处理\n    while (1)\n    {\n        capture &gt;&gt; frame;\n        //调整亮度\n        frame.convertTo(img, img.type(), a, b);\n\n        //转换为YCrCb颜色空间\n        cvtColor(img, imgYCrCb, CV_BGR2YCrCb);\n\n        imgRed.create(imgYCrCb.rows, imgYCrCb.cols, CV_8UC1);\n        imgGreen.create(imgYCrCb.rows, imgYCrCb.cols, CV_8UC1);\n\n        //分解YCrCb的三个成分\n        vector&lt;Mat&gt; planes;\n        split(imgYCrCb, planes);\n        // 遍历以根据Cr分量拆分红色和绿色\n        MatIterator_&lt;uchar&gt; it_Cr = planes[1].begin&lt;uchar&gt;(),\n                it_Cr_end = planes[1].end&lt;uchar&gt;();\n        MatIterator_&lt;uchar&gt; it_Red = imgRed.begin&lt;uchar&gt;();\n        MatIterator_&lt;uchar&gt; it_Green = imgGreen.begin&lt;uchar&gt;();\n\n        for (; it_Cr != it_Cr_end; ++it_Cr, ++it_Red, ++it_Green)\n        {\n            // RED, 145&lt;Cr&lt;470 红色\n            if (*it_Cr &gt; 145 &amp;&amp; *it_Cr &lt; 470)\n                *it_Red = 255;\n            else\n                *it_Red = 0;\n\n            // GREEN 95&lt;Cr&lt;110 绿色\n            if (*it_Cr &gt; 95 &amp;&amp; *it_Cr &lt; 110)\n                *it_Green = 255;\n            else\n                *it_Green = 0;\n        }</code></pre>\n<h2 id=\"Step2%EF%BC%9A%E8%86%A8%E8%83%80%E8%85%90%E8%9A%80%E5%A4%84%E7%90%86\">Step3：膨胀腐蚀处理</h2>\n<ul><li>去除其他噪点，提高我们需要的红绿灯的特征</li></ul>\n<pre><code class=\"language-cpp\">        //膨胀和腐蚀\n        dilate(imgRed, imgRed, Mat(15, 15, CV_8UC1), Point(-1, -1));\n        erode(imgRed, imgRed, Mat(1, 1, CV_8UC1), Point(-1, -1));\n        dilate(imgGreen, imgGreen, Mat(15, 15, CV_8UC1), Point(-1, -1));\n        erode(imgGreen, imgGreen, Mat(1, 1, CV_8UC1), Point(-1, -1));\n\n        redCount = processImgR(imgRed);\n        greenCount = processImgG(imgGreen);\n        cout &lt;&lt; \"red:\" &lt;&lt; redCount &lt;&lt; \";  \" &lt;&lt; \"green:\" &lt;&lt; greenCount &lt;&lt; endl;</code></pre>\n<h2 id=\"Step3%EF%BC%9A%E7%BA%A2%E7%BB%BF%E7%81%AF%E6%8F%90%E7%A4%BA%E5%88%A4%E6%96%AD\">Step4：红绿灯提示判断</h2>\n<ul><li>加入红绿灯识别结果显示，方便我们查看效果</li></ul>\n<pre><code class=\"language-cpp\">        if(redCount == 0 &amp;&amp; greenCount == 0)\n        {\n            cv::putText(frame, \"lights out\", Point(40, 150), cv::FONT_HERSHEY_SIMPLEX, 2, cv::Scalar(255, 255, 255), 8, 8, 0);\n        }else if(redCount &gt; greenCount)\n        {\n            cv::putText(frame, \"red light\", Point(40, 150), cv::FONT_HERSHEY_SIMPLEX, 2, cv::Scalar(0, 0, 255), 8, 8, 0);\n        }else{\n            cv::putText(frame, \"green light\", Point(40, 150), cv::FONT_HERSHEY_SIMPLEX, 2, cv::Scalar(0, 255, 0), 8, 8, 0);\n        }</code></pre>\n<p><img alt=\"\" height=\"814\" src=\"image\\31353ee2e65e4d819b711358fe12d9b9.png\" width=\"1200\"/> <img alt=\"\" height=\"814\" src=\"image\\bf517f81ce0b47ac82b787e15a6d83af.png\" width=\"1200\"/></p>\n<h2 id=\"Step4%EF%BC%9A%E8%BD%AE%E5%BB%93%E6%8F%90%E5%8F%96\">Step5：轮廓提取</h2>\n<ul><li>分别对红灯和绿灯进行轮廓特征提取，提高辨识度</li></ul>\n<pre><code class=\"language-cpp\">int processImgR(Mat src)\n{\n    Mat tmp;\n\n    vector&lt;vector&lt;Point&gt;&gt; contours;\n    vector&lt;Vec4i&gt; hierarchy;\n    vector&lt;Point&gt; hull;\n\n    CvPoint2D32f tempNode;\n    CvMemStorage* storage = cvCreateMemStorage();\n    CvSeq* pointSeq = cvCreateSeq(CV_32FC2, sizeof(CvSeq), sizeof(CvPoint2D32f), storage);\n\n    Rect* trackBox;\n    Rect* result;\n    int resultNum = 0;\n\n    int area = 0;\n    src.copyTo(tmp);\n\n    //提取轮廓\n    findContours(tmp, contours, hierarchy, CV_RETR_CCOMP, CV_CHAIN_APPROX_SIMPLE);\n\n    if (contours.size() &gt; 0)\n    {\n        trackBox = new Rect[contours.size()];\n        result = new Rect[contours.size()];\n\n        //确定要跟踪的区域\n        for (int i = 0; i &lt; contours.size(); i++)\n        {\n            cvClearSeq(pointSeq);\n            // 获取凸包的点集\n            convexHull(Mat(contours[i]), hull, true);\n            int hullcount = (int)hull.size();\n            // 凸包的保存点\n            for (int j = 0; j &lt; hullcount - 1; j++)\n            {\n                tempNode.x = hull[j].x;\n                tempNode.y = hull[j].y;\n                cvSeqPush(pointSeq, &amp;tempNode);\n            }\n\n            trackBox[i] = cvBoundingRect(pointSeq);\n        }\n\n        if (isFirstDetectedR)\n        {\n            lastTrackBoxR = new Rect[contours.size()];\n            for (int i = 0; i &lt; contours.size(); i++)\n                lastTrackBoxR[i] = trackBox[i];\n            lastTrackNumR = contours.size();\n            isFirstDetectedR = false;\n        }\n        else\n        {\n            for (int i = 0; i &lt; contours.size(); i++)\n            {\n                for (int j = 0; j &lt; lastTrackNumR; j++)\n                {\n                    if (isIntersected(trackBox[i], lastTrackBoxR[j]))\n                    {\n                        result[resultNum] = trackBox[i];\n                        break;\n                    }\n                }\n                resultNum++;\n            }\n            delete[] lastTrackBoxR;\n            lastTrackBoxR = new Rect[contours.size()];\n            for (int i = 0; i &lt; contours.size(); i++)\n            {\n                lastTrackBoxR[i] = trackBox[i];\n            }\n            lastTrackNumR = contours.size();\n        }\n\n        delete[] trackBox;\n    }\n    else\n    {\n        isFirstDetectedR = true;\n        result = NULL;\n    }\n    cvReleaseMemStorage(&amp;storage);\n\n    if (result != NULL)\n    {\n        for (int i = 0; i &lt; resultNum; i++)\n        {\n            area += result[i].area();\n        }\n    }\n    delete[] result;\n\n    return area;\n}\n\nint processImgG(Mat src)\n{\n    Mat tmp;\n\n    vector&lt;vector&lt;Point&gt; &gt; contours;\n    vector&lt;Vec4i&gt; hierarchy;\n    vector&lt; Point &gt; hull;\n\n    CvPoint2D32f tempNode;\n    CvMemStorage* storage = cvCreateMemStorage();\n    CvSeq* pointSeq = cvCreateSeq(CV_32FC2, sizeof(CvSeq), sizeof(CvPoint2D32f), storage);\n\n    Rect* trackBox;\n    Rect* result;\n    int resultNum = 0;\n\n    int area = 0;\n\n    src.copyTo(tmp);\n    //提取轮廓\n    findContours(tmp, contours, hierarchy, CV_RETR_CCOMP, CV_CHAIN_APPROX_SIMPLE);\n\n    if (contours.size() &gt; 0)\n    {\n        trackBox = new Rect[contours.size()];\n        result = new Rect[contours.size()];\n\n        // 确定要跟踪的区域\n        for (int i = 0; i &lt; contours.size(); i++)\n        {\n            cvClearSeq(pointSeq);\n            // 获取凸包的点集\n            convexHull(Mat(contours[i]), hull, true);\n            int hullcount = (int)hull.size();\n            // 保存凸包的点\n            for (int j = 0; j &lt; hullcount - 1; j++)\n            {\n                tempNode.x = hull[j].x;\n                tempNode.y = hull[j].y;\n                cvSeqPush(pointSeq, &amp;tempNode);\n            }\n\n            trackBox[i] = cvBoundingRect(pointSeq);\n        }\n\n        if (isFirstDetectedG)\n        {\n            lastTrackBoxG = new Rect[contours.size()];\n            for (int i = 0; i &lt; contours.size(); i++)\n                lastTrackBoxG[i] = trackBox[i];\n            lastTrackNumG = contours.size();\n            isFirstDetectedG = false;\n        }\n        else\n        {\n            for (int i = 0; i &lt; contours.size(); i++)\n            {\n                for (int j = 0; j &lt; lastTrackNumG; j++)\n                {\n                    if (isIntersected(trackBox[i], lastTrackBoxG[j]))\n                    {\n                        result[resultNum] = trackBox[i];\n                        break;\n                    }\n                }\n                resultNum++;\n            }\n            delete[] lastTrackBoxG;\n            lastTrackBoxG = new Rect[contours.size()];\n            for (int i = 0; i &lt; contours.size(); i++)\n            {\n                lastTrackBoxG[i] = trackBox[i];\n            }\n            lastTrackNumG = contours.size();\n        }\n\n        delete[] trackBox;\n    }\n    else\n    {\n        isFirstDetectedG = true;\n        result = NULL;\n    }\n    cvReleaseMemStorage(&amp;storage);\n\n    if (result != NULL)\n    {\n        for (int i = 0; i &lt; resultNum; i++)\n        {\n            area += result[i].area();\n        }\n    }\n    delete[] result;\n\n    return area;\n}\n</code></pre>\n<p><img alt=\"\" height=\"785\" src=\"image\\7c0d16fb7f444501ad599c120f219e86.png\" width=\"1200\"/> <img alt=\"\" height=\"1200\" src=\"image\\95a70c89b7b94f778f095d7853546114.png\" width=\"1200\"/></p>\n<h2 id=\"%C2%A0Step4%EF%BC%9A%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4\">Step4：判断是否相交</h2>\n<pre><code class=\"language-cpp\">//确定两个矩形区域是否相交\nbool isIntersected(Rect r1, Rect r2)\n{\n    int minX = max(r1.x, r2.x);\n    int minY = max(r1.y, r2.y);\n    int maxX = min(r1.x + r1.width, r2.x + r2.width);\n    int maxY = min(r1.y + r1.height, r2.y + r2.height);\n\n    if (minX &lt; maxX &amp;&amp; minY &lt; maxY)\n        return true;\n    else\n        return false;\n}\n</code></pre>\n<h2 id=\"%E6%A1%88%E4%BE%8B%E6%95%88%E6%9E%9C\">🚀案例效果</h2>\n<p><img alt=\"\" height=\"816\" src=\"https://img-blog.csdnimg.cn/c26cb31e6944475b8040e8244284c1c4.gif\" width=\"1200\"/></p>\n<p><img alt=\"\" height=\"1200\" src=\"https://img-blog.csdnimg.cn/859d91f58c584b2292d83f8fe8a01723.gif\" width=\"1200\"/></p>\n<p><img alt=\"\" height=\"816\" src=\"https://img-blog.csdnimg.cn/b5d0151a28944391bc299482fb297e50.gif\" width=\"1200\"/></p>\n<h2 id=\"%F0%9F%92%A1%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81\"><strong>💡完整代码</strong></h2>\n<pre><code class=\"language-cpp\">#include \"opencv2/opencv.hpp\"\n#include \"opencv2/imgproc.hpp\"\n#include &lt;windows.h&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\nusing namespace cv;\n\n// Function headers\nint processImgR(Mat);\nint processImgG(Mat);\nbool isIntersected(Rect, Rect);\n\n// Global variables\nbool isFirstDetectedR = true;\nbool isFirstDetectedG = true;\nRect* lastTrackBoxR;\nRect* lastTrackBoxG;\nint lastTrackNumR;\nint lastTrackNumG;\n\n//主函数\nint main()\n{\n    int redCount = 0;\n    int greenCount = 0;\n\n    Mat frame;\n    Mat img;\n    Mat imgYCrCb;\n    Mat imgGreen;\n    Mat imgRed;\n\n    // 亮度参数\n    double a = 0.3;\n    double b = (1 - a) * 125;\n\n    VideoCapture capture(\"C:/Users/86177/Desktop/image/123.mp4\");//导入视频的路径\n    if (!capture.isOpened())\n    {\n        cout &lt;&lt; \"Start device failed!\\n\" &lt;&lt; endl;//启动设备失败！\n        return -1;\n    }\n\n    // 帧处理\n    while (1)\n    {\n        capture &gt;&gt; frame;\n        //调整亮度\n        frame.convertTo(img, img.type(), a, b);\n\n        //转换为YCrCb颜色空间\n        cvtColor(img, imgYCrCb, CV_BGR2YCrCb);\n\n        imgRed.create(imgYCrCb.rows, imgYCrCb.cols, CV_8UC1);\n        imgGreen.create(imgYCrCb.rows, imgYCrCb.cols, CV_8UC1);\n\n        //分解YCrCb的三个成分\n        vector&lt;Mat&gt; planes;\n        split(imgYCrCb, planes);\n        // 遍历以根据Cr分量拆分红色和绿色\n        MatIterator_&lt;uchar&gt; it_Cr = planes[1].begin&lt;uchar&gt;(),\n                it_Cr_end = planes[1].end&lt;uchar&gt;();\n        MatIterator_&lt;uchar&gt; it_Red = imgRed.begin&lt;uchar&gt;();\n        MatIterator_&lt;uchar&gt; it_Green = imgGreen.begin&lt;uchar&gt;();\n\n        for (; it_Cr != it_Cr_end; ++it_Cr, ++it_Red, ++it_Green)\n        {\n            // RED, 145&lt;Cr&lt;470 红色\n            if (*it_Cr &gt; 145 &amp;&amp; *it_Cr &lt; 470)\n                *it_Red = 255;\n            else\n                *it_Red = 0;\n\n            // GREEN 95&lt;Cr&lt;110 绿色\n            if (*it_Cr &gt; 95 &amp;&amp; *it_Cr &lt; 110)\n                *it_Green = 255;\n            else\n                *it_Green = 0;\n        }\n\n        //膨胀和腐蚀\n        dilate(imgRed, imgRed, Mat(15, 15, CV_8UC1), Point(-1, -1));\n        erode(imgRed, imgRed, Mat(1, 1, CV_8UC1), Point(-1, -1));\n        dilate(imgGreen, imgGreen, Mat(15, 15, CV_8UC1), Point(-1, -1));\n        erode(imgGreen, imgGreen, Mat(1, 1, CV_8UC1), Point(-1, -1));\n\n        redCount = processImgR(imgRed);\n        greenCount = processImgG(imgGreen);\n        cout &lt;&lt; \"red:\" &lt;&lt; redCount &lt;&lt; \";  \" &lt;&lt; \"green:\" &lt;&lt; greenCount &lt;&lt; endl;\n\n        if(redCount == 0 &amp;&amp; greenCount == 0)\n        {\n            cv::putText(frame, \"lights out\", Point(40, 150), cv::FONT_HERSHEY_SIMPLEX, 2, cv::Scalar(255, 255, 255), 8, 8, 0);\n        }else if(redCount &gt; greenCount)\n        {\n            cv::putText(frame, \"red light\", Point(40, 150), cv::FONT_HERSHEY_SIMPLEX, 2, cv::Scalar(0, 0, 255), 8, 8, 0);\n        }else{\n            cv::putText(frame, \"green light\", Point(40, 150), cv::FONT_HERSHEY_SIMPLEX, 2, cv::Scalar(0, 255, 0), 8, 8, 0);\n        }\n\n        imshow(\"video\", frame);\n        imshow(\"Red\", imgRed);\n        imshow(\"Green\", imgGreen);\n\n        // Handle with the keyboard input\n        if (cvWaitKey(20) == 'q')\n            break;\n    }\n\n    return 0;\n}\n\nint processImgR(Mat src)\n{\n    Mat tmp;\n\n    vector&lt;vector&lt;Point&gt;&gt; contours;\n    vector&lt;Vec4i&gt; hierarchy;\n    vector&lt;Point&gt; hull;\n\n    CvPoint2D32f tempNode;\n    CvMemStorage* storage = cvCreateMemStorage();\n    CvSeq* pointSeq = cvCreateSeq(CV_32FC2, sizeof(CvSeq), sizeof(CvPoint2D32f), storage);\n\n    Rect* trackBox;\n    Rect* result;\n    int resultNum = 0;\n\n    int area = 0;\n    src.copyTo(tmp);\n\n    //提取轮廓\n    findContours(tmp, contours, hierarchy, CV_RETR_CCOMP, CV_CHAIN_APPROX_SIMPLE);\n\n    if (contours.size() &gt; 0)\n    {\n        trackBox = new Rect[contours.size()];\n        result = new Rect[contours.size()];\n\n        //确定要跟踪的区域\n        for (int i = 0; i &lt; contours.size(); i++)\n        {\n            cvClearSeq(pointSeq);\n            // 获取凸包的点集\n            convexHull(Mat(contours[i]), hull, true);\n            int hullcount = (int)hull.size();\n            // 凸包的保存点\n            for (int j = 0; j &lt; hullcount - 1; j++)\n            {\n                tempNode.x = hull[j].x;\n                tempNode.y = hull[j].y;\n                cvSeqPush(pointSeq, &amp;tempNode);\n            }\n\n            trackBox[i] = cvBoundingRect(pointSeq);\n        }\n\n        if (isFirstDetectedR)\n        {\n            lastTrackBoxR = new Rect[contours.size()];\n            for (int i = 0; i &lt; contours.size(); i++)\n                lastTrackBoxR[i] = trackBox[i];\n            lastTrackNumR = contours.size();\n            isFirstDetectedR = false;\n        }\n        else\n        {\n            for (int i = 0; i &lt; contours.size(); i++)\n            {\n                for (int j = 0; j &lt; lastTrackNumR; j++)\n                {\n                    if (isIntersected(trackBox[i], lastTrackBoxR[j]))\n                    {\n                        result[resultNum] = trackBox[i];\n                        break;\n                    }\n                }\n                resultNum++;\n            }\n            delete[] lastTrackBoxR;\n            lastTrackBoxR = new Rect[contours.size()];\n            for (int i = 0; i &lt; contours.size(); i++)\n            {\n                lastTrackBoxR[i] = trackBox[i];\n            }\n            lastTrackNumR = contours.size();\n        }\n\n        delete[] trackBox;\n    }\n    else\n    {\n        isFirstDetectedR = true;\n        result = NULL;\n    }\n    cvReleaseMemStorage(&amp;storage);\n\n    if (result != NULL)\n    {\n        for (int i = 0; i &lt; resultNum; i++)\n        {\n            area += result[i].area();\n        }\n    }\n    delete[] result;\n\n    return area;\n}\n\nint processImgG(Mat src)\n{\n    Mat tmp;\n\n    vector&lt;vector&lt;Point&gt; &gt; contours;\n    vector&lt;Vec4i&gt; hierarchy;\n    vector&lt; Point &gt; hull;\n\n    CvPoint2D32f tempNode;\n    CvMemStorage* storage = cvCreateMemStorage();\n    CvSeq* pointSeq = cvCreateSeq(CV_32FC2, sizeof(CvSeq), sizeof(CvPoint2D32f), storage);\n\n    Rect* trackBox;\n    Rect* result;\n    int resultNum = 0;\n\n    int area = 0;\n\n    src.copyTo(tmp);\n    //提取轮廓\n    findContours(tmp, contours, hierarchy, CV_RETR_CCOMP, CV_CHAIN_APPROX_SIMPLE);\n\n    if (contours.size() &gt; 0)\n    {\n        trackBox = new Rect[contours.size()];\n        result = new Rect[contours.size()];\n\n        // 确定要跟踪的区域\n        for (int i = 0; i &lt; contours.size(); i++)\n        {\n            cvClearSeq(pointSeq);\n            // 获取凸包的点集\n            convexHull(Mat(contours[i]), hull, true);\n            int hullcount = (int)hull.size();\n            // 保存凸包的点\n            for (int j = 0; j &lt; hullcount - 1; j++)\n            {\n                tempNode.x = hull[j].x;\n                tempNode.y = hull[j].y;\n                cvSeqPush(pointSeq, &amp;tempNode);\n            }\n\n            trackBox[i] = cvBoundingRect(pointSeq);\n        }\n\n        if (isFirstDetectedG)\n        {\n            lastTrackBoxG = new Rect[contours.size()];\n            for (int i = 0; i &lt; contours.size(); i++)\n                lastTrackBoxG[i] = trackBox[i];\n            lastTrackNumG = contours.size();\n            isFirstDetectedG = false;\n        }\n        else\n        {\n            for (int i = 0; i &lt; contours.size(); i++)\n            {\n                for (int j = 0; j &lt; lastTrackNumG; j++)\n                {\n                    if (isIntersected(trackBox[i], lastTrackBoxG[j]))\n                    {\n                        result[resultNum] = trackBox[i];\n                        break;\n                    }\n                }\n                resultNum++;\n            }\n            delete[] lastTrackBoxG;\n            lastTrackBoxG = new Rect[contours.size()];\n            for (int i = 0; i &lt; contours.size(); i++)\n            {\n                lastTrackBoxG[i] = trackBox[i];\n            }\n            lastTrackNumG = contours.size();\n        }\n\n        delete[] trackBox;\n    }\n    else\n    {\n        isFirstDetectedG = true;\n        result = NULL;\n    }\n    cvReleaseMemStorage(&amp;storage);\n\n    if (result != NULL)\n    {\n        for (int i = 0; i &lt; resultNum; i++)\n        {\n            area += result[i].area();\n        }\n    }\n    delete[] result;\n\n    return area;\n}\n\n//确定两个矩形区域是否相交\nbool isIntersected(Rect r1, Rect r2)\n{\n    int minX = max(r1.x, r2.x);\n    int minY = max(r1.y, r2.y);\n    int maxX = min(r1.x + r1.width, r2.x + r2.width);\n    int maxY = min(r1.y + r1.height, r2.y + r2.height);\n\n    if (minX &lt; maxX &amp;&amp; minY &lt; maxY)\n        return true;\n    else\n        return false;\n}\n</code></pre>\n<h1 id=\"%E4%B8%89%E3%80%81%E6%80%BB%E7%BB%93\">三、总结</h1>\n<blockquote>\n<ul><li>本文主要讲解<span style=\"color:#be191c;\"><strong>OpenCV轮廓识别原理</strong></span>以及<span style=\"color:#be191c;\"><strong>OpenCV红绿灯识别</strong></span>的实现具体步骤</li><li>OpenCV还是有很多识别的库函数可以用，接下来继续探索，结合生活实际继续做一些有意思的案例</li></ul>\n</blockquote>\n<p><span style=\"color:#38d8f0;\"><strong><em>以上就是本文的全部内容啦！如果对您有帮助，麻烦点赞啦！收藏啦！欢迎各位评论区留言</em>！！ !</strong> </span></p>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"369\" src=\"https://img-blog.csdnimg.cn/93f7366f85354e50a1eb8393367608f7.gif\" width=\"675\"/> </p>\n</div>\n</div>"}