{"blogid": "126102217", "writerAge": "ç é¾„1å¹´", "writerBlogNum": "25", "writerCollect": "2049", "writerComment": "1518", "writerFan": "2633", "writerGrade": "6çº§", "writerIntegral": "4561", "writerName": "çŒ¿åŠ›çŒª", "writerProfileAdress": "writer_image\\profile_126102217.jpg", "writerRankTotal": "4640", "writerRankWeekly": "15864", "writerThumb": "1555", "writerVisitNum": "113072", "blog_read_count": "2878", "blog_time": "äºÂ 2022-08-01 17:09:52Â å‘å¸ƒ", "blog_title": "ã€OpenCVã€‘çº¢ç»¿ç¯è¯†åˆ« è½®å»“è¯†åˆ« C++ OpenCV æ¡ˆä¾‹å®ç°", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h1 id=\"%E7%9B%AE%E5%BD%95\">ç›®å½•</h1>\n<p id=\"%E5%89%8D%E8%A8%80-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%89%8D%E8%A8%80\">å‰è¨€</a></p>\n<p id=\"%E4%B8%80%E3%80%81%E8%BD%AE%E5%BB%93%E8%AF%86%E5%88%AB%E7%9B%B8%E5%85%B3%E5%8E%9F%E7%90%86-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%80%E3%80%81%E8%BD%AE%E5%BB%93%E8%AF%86%E5%88%AB%E7%9B%B8%E5%85%B3%E5%8E%9F%E7%90%86\">ä¸€ã€è½®å»“è¯†åˆ«ç›¸å…³åŸç†</a></p>\n<p id=\"%E4%BB%80%E4%B9%88%E6%98%AF%E8%BD%AE%E5%BB%93%E6%A3%80%E6%B5%8B%EF%BC%9F%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BD%AE%E5%BB%93%E6%A3%80%E6%B5%8B%EF%BC%9F%C2%A0\">ä»€ä¹ˆæ˜¯è½®å»“æ£€æµ‹ï¼Ÿ </a></p>\n<p id=\"findContours%E5%87%BD%E6%95%B0%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#findContours%E5%87%BD%E6%95%B0%C2%A0\">è½®å»“æå–å‡½æ•°  findContours</a></p>\n<p id=\"%E4%BA%8C%E3%80%81%E6%A1%88%E4%BE%8B%E5%AE%9E%E7%8E%B0-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BA%8C%E3%80%81%E6%A1%88%E4%BE%8B%E5%AE%9E%E7%8E%B0\">äºŒã€æ¡ˆä¾‹å®ç°</a></p>\n<p id=\"Step1%EF%BC%9A%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE-toc\" style=\"margin-left:40px;\"><a href=\"#Step1%EF%BC%9A%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE\">Step1ï¼šåˆå§‹åŒ–é…ç½®</a></p>\n<p id=\"Step2%EF%BC%9A%E8%BF%9B%E8%A1%8C%E5%B8%A7%E5%A4%84%E7%90%86-toc\" style=\"margin-left:40px;\"><a href=\"#Step2%EF%BC%9A%E8%BF%9B%E8%A1%8C%E5%B8%A7%E5%A4%84%E7%90%86\">Step2ï¼šè¿›è¡Œå¸§å¤„ç†</a></p>\n<p id=\"Step2%EF%BC%9A%E8%86%A8%E8%83%80%E8%85%90%E8%9A%80%E5%A4%84%E7%90%86-toc\" style=\"margin-left:40px;\"><a href=\"#Step2%EF%BC%9A%E8%86%A8%E8%83%80%E8%85%90%E8%9A%80%E5%A4%84%E7%90%86\">Step3ï¼šè†¨èƒ€è…èš€å¤„ç†</a></p>\n<p id=\"Step3%EF%BC%9A%E7%BA%A2%E7%BB%BF%E7%81%AF%E6%8F%90%E7%A4%BA%E5%88%A4%E6%96%AD-toc\" style=\"margin-left:40px;\"><a href=\"#Step3%EF%BC%9A%E7%BA%A2%E7%BB%BF%E7%81%AF%E6%8F%90%E7%A4%BA%E5%88%A4%E6%96%AD\">Step4ï¼šçº¢ç»¿ç¯æç¤ºåˆ¤æ–­</a></p>\n<p id=\"Step4%EF%BC%9A%E8%BD%AE%E5%BB%93%E6%8F%90%E5%8F%96-toc\" style=\"margin-left:40px;\"><a href=\"#Step4%EF%BC%9A%E8%BD%AE%E5%BB%93%E6%8F%90%E5%8F%96\">Step5ï¼šè½®å»“æå–</a></p>\n<p id=\"%C2%A0Step4%EF%BC%9A%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A0Step4%EF%BC%9A%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4\">Step4ï¼šåˆ¤æ–­æ˜¯å¦ç›¸äº¤</a></p>\n<p id=\"%E6%A1%88%E4%BE%8B%E6%95%88%E6%9E%9C-toc\" style=\"margin-left:40px;\"><a href=\"#%E6%A1%88%E4%BE%8B%E6%95%88%E6%9E%9C\">ğŸš€æ¡ˆä¾‹æ•ˆæœ</a></p>\n<p id=\"%F0%9F%92%A1%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81-toc\" style=\"margin-left:40px;\"><a href=\"#%F0%9F%92%A1%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81\">ğŸ’¡å®Œæ•´ä»£ç </a></p>\n<p id=\"%E4%B8%89%E3%80%81%E6%80%BB%E7%BB%93-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%89%E3%80%81%E6%80%BB%E7%BB%93\">ä¸‰ã€æ€»ç»“</a></p>\n<hr/>\n<h1 id=\"%E5%89%8D%E8%A8%80\">å‰è¨€</h1>\n<p>æœ¬æ–‡ä»¥å®ç°è¡Œè½¦è¿‡ç¨‹å½“ä¸­çš„<span style=\"color:#be191c;\"><strong>çº¢ç»¿ç¯è¯†åˆ«</strong></span>ä¸ºç›®æ ‡ï¼Œæ ¸å¿ƒçš„å†…å®¹åŒ…æ‹¬ï¼š<span style=\"color:#be191c;\"><strong>OpenCVè½®å»“è¯†åˆ«åŸç†</strong></span>ä»¥åŠ<span style=\"color:#be191c;\"><strong>OpenCVçº¢ç»¿ç¯è¯†åˆ«</strong></span>çš„å®ç°å…·ä½“æ­¥éª¤</p>\n<h1 id=\"%E4%B8%80%E3%80%81%E8%BD%AE%E5%BB%93%E8%AF%86%E5%88%AB%E7%9B%B8%E5%85%B3%E5%8E%9F%E7%90%86\"><strong>ä¸€ã€è½®å»“è¯†åˆ«ç›¸å…³åŸç†</strong></h1>\n<p><img alt=\"\" src=\"image\\9dfb9a0f6dee40a0b05f2a6f01ffd0e4.png\"/></p>\n<h2 id=\"%E4%BB%80%E4%B9%88%E6%98%AF%E8%BD%AE%E5%BB%93%E6%A3%80%E6%B5%8B%EF%BC%9F%C2%A0\">ä»€ä¹ˆæ˜¯è½®å»“æ£€æµ‹ï¼Ÿ </h2>\n<ul><li>ç›®å‰è½®å»“æ£€æµ‹æ–¹æ³•æœ‰ä¸¤ç±»ï¼Œä¸€ç±»æ˜¯åˆ©ç”¨ä¼ ç»Ÿçš„è¾¹ç¼˜æ£€æµ‹ç®—å­æ£€æµ‹ç›®æ ‡è½®å»“ï¼Œå¦ä¸€ç±»æ˜¯ä»äººç±»è§†è§‰ç³»ç»Ÿä¸­æå–å¯ä»¥ä½¿ç”¨çš„æ•°å­¦æ¨¡å‹å®Œæˆç›®æ ‡è½®å»“æ£€æµ‹</li></ul>\n<p><img alt=\"\" height=\"408\" src=\"image\\0a70a07b26404800a661e3005d72e7b3.png\" width=\"1107\"/> </p>\n<h2 id=\"findContours%E5%87%BD%E6%95%B0%C2%A0\">è½®å»“æå–å‡½æ•°  <strong>findContours</strong></h2>\n<blockquote>\n<p><strong>ğŸ“å‡½æ•°åŸå‹: </strong>findContours( InputOutputArray <span style=\"color:#4da8ee;\">image</span>, OutputArrayOfArrays <span style=\"color:#4da8ee;\">contours</span>,<br/>                               OutputArray<span style=\"color:#4da8ee;\"> hierarchy</span><span style=\"color:#494949;\">,</span><span style=\"color:#4da8ee;\"> int mode</span>,<br/>                               int method, Point offset=<span style=\"color:#4da8ee;\">Point()</span>);</p>\n</blockquote>\n<blockquote>\n<p><strong>ğŸ“å‚æ•°ï¼š</strong></p>\n<p></p>\n<p><span style=\"color:#4da8ee;\"><strong>1ï¸âƒ£imageï¼š</strong></span>å•é€šé“å›¾åƒçŸ©é˜µï¼Œå¯ä»¥æ˜¯ç°åº¦å›¾ï¼Œä½†æ›´å¸¸ç”¨çš„æ˜¯äºŒå€¼å›¾åƒï¼Œä¸€èˆ¬æ˜¯ç»è¿‡Cannyã€æ‹‰æ™®æ‹‰æ–¯ç­‰è¾¹ç¼˜æ£€æµ‹ç®—å­å¤„ç†è¿‡çš„äºŒå€¼å›¾åƒ</p>\n<p></p>\n<p><strong><span style=\"color:#4da8ee;\">2ï¸âƒ£contours:</span> </strong> å®šä¹‰ä¸ºâ€œvector&lt;vector&lt;Point&gt;&gt; contoursâ€ï¼Œæ˜¯ä¸€ä¸ªå‘é‡ï¼Œå¹¶ä¸”æ˜¯ä¸€ä¸ªåŒé‡å‘é‡ï¼Œå‘é‡å†…æ¯ä¸ªå…ƒç´ ä¿å­˜äº†ä¸€ç»„ç”±è¿ç»­çš„Pointç‚¹æ„æˆçš„ç‚¹çš„é›†åˆçš„å‘é‡ï¼Œæ¯ä¸€ç»„Pointç‚¹é›†å°±æ˜¯ä¸€ä¸ªè½®å»“ã€‚æœ‰å¤šå°‘è½®å»“ï¼Œå‘é‡contourså°±æœ‰å¤šå°‘å…ƒç´ </p>\n<p></p>\n<p><strong><span style=\"color:#4da8ee;\">3ï¸âƒ£hierarchy:</span> </strong> ä¹Ÿæ˜¯ä¸€ä¸ªå‘é‡ï¼Œå‘é‡å†…æ¯ä¸ªå…ƒç´ ä¿å­˜äº†ä¸€ä¸ªåŒ…å«4ä¸ªintæ•´å‹çš„æ•°ç»„ã€‚å‘é‡å†…çš„å…ƒç´ å’Œè½®å»“å‘é‡contourså†…çš„å…ƒç´ æ˜¯ä¸€ä¸€å¯¹åº”çš„ï¼Œå‘é‡çš„å®¹é‡ç›¸åŒ</p>\n<p></p>\n<p><span style=\"color:#4da8ee;\"><strong>4ï¸âƒ£int mode: </strong></span></p>\n<p>å–å€¼ä¸€ï¼šCV_CHAIN_APPROX_NONE ä¿å­˜ç‰©ä½“è¾¹ç•Œä¸Šæ‰€æœ‰è¿ç»­çš„è½®å»“ç‚¹åˆ° contourså‘é‡å†…</p>\n<p>å–å€¼äºŒï¼šCV_CHAIN_APPROX_SIMPLE ä»…ä¿å­˜è½®å»“çš„æ‹ç‚¹ä¿¡æ¯ï¼ŒæŠŠæ‰€æœ‰è½®å»“æ‹ç‚¹å¤„çš„ç‚¹ä¿å­˜å…¥contourså‘é‡å†…ï¼Œæ‹ç‚¹ä¸æ‹ç‚¹ä¹‹é—´ç›´çº¿æ®µä¸Šçš„ä¿¡æ¯ç‚¹ä¸äºˆä¿ç•™</p>\n<p>å–å€¼ä¸‰å’Œå››ï¼šCV_CHAIN_APPROX_TC89_L1ï¼ŒCV_CHAIN_APPROX_TC89_KCOSä½¿ç”¨teh-Chinl chain è¿‘ä¼¼ç®—æ³•</p>\n<p></p>\n<p><span style=\"color:#4da8ee;\"><strong>5ï¸âƒ£Pointï¼š</strong></span> Pointåç§»é‡ï¼Œæ‰€æœ‰çš„è½®å»“ä¿¡æ¯ç›¸å¯¹äºåŸå§‹å›¾åƒå¯¹åº”ç‚¹çš„åç§»é‡ï¼Œç›¸å½“äºåœ¨æ¯ä¸€ä¸ªæ£€æµ‹å‡ºçš„è½®å»“ç‚¹ä¸ŠåŠ ä¸Šè¯¥åç§»é‡ï¼Œå¹¶ä¸”Pointè¿˜å¯ä»¥æ˜¯è´Ÿå€¼ï¼</p>\n</blockquote>\n<p><strong>å‚æ•°è¯¦è§£å¼•ç”¨å‡ºå¤„ï¼š</strong><a href=\"https://blog.csdn.net/dcrmg/article/details/51987348#\" title=\"findContourså‡½æ•°å‚æ•°è¯¦è§£_-ç‰§é‡-çš„åšå®¢-CSDNåšå®¢_findcontourså‡½æ•°\">findContourså‡½æ•°å‚æ•°è¯¦è§£_-ç‰§é‡-çš„åšå®¢-CSDNåšå®¢_findcontourså‡½æ•°</a> </p>\n<p> </p>\n<h1 id=\"%E4%BA%8C%E3%80%81%E6%A1%88%E4%BE%8B%E5%AE%9E%E7%8E%B0\">äºŒã€æ¡ˆä¾‹å®ç°</h1>\n<ul><li>è¿™æ˜¯æœ¬æ¡ˆä¾‹æ‰€ç”¨åˆ°çš„ç´ æï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºï¼š </li></ul>\n<p><img alt=\"\" height=\"1200\" src=\"image\\48afc30206f8497291bdf23760c4b3a8.png\" width=\"1200\"/></p>\n<p><strong>PSï¼š</strong>è§†é¢‘çš„æ•ˆæœæ¯”è¾ƒå¥½ï¼Œå¦‚æœæ–¹ä¾¿çš„è¯å¯ä»¥è‡ªè¡Œå¤–å‡ºæ‹æ‘„å–æ</p>\n<p> </p>\n<h2 id=\"Step1%EF%BC%9A%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE\">Step1ï¼šåˆå§‹åŒ–é…ç½®</h2>\n<ul><li>åšå¥½å‡†å¤‡å·¥ä½œï¼Œåˆ›å»ºæˆ‘ä»¬éœ€è¦çš„å†…å®¹ï¼Œè®¾ç½®äº®åº¦å‚æ•°ï¼Œä»¥åŠæˆ‘ä»¬å¯¼å…¥çš„è§†é¢‘è·¯å¾„</li></ul>\n<pre><code class=\"language-cpp\">    int redCount = 0;\n    int greenCount = 0;\n\n    Mat frame;\n    Mat img;\n    Mat imgYCrCb;\n    Mat imgGreen;\n    Mat imgRed;\n\n    // äº®åº¦å‚æ•°\n    double a = 0.3;\n    double b = (1 - a) * 125;\n\n    VideoCapture capture(\"C:/Users/86177/Desktop/image/123.mp4\");//å¯¼å…¥è§†é¢‘çš„è·¯å¾„\n    if (!capture.isOpened())\n    {\n        cout &lt;&lt; \"Start device failed!\\n\" &lt;&lt; endl;//å¯åŠ¨è®¾å¤‡å¤±è´¥ï¼\n        return -1;\n    }\n</code></pre>\n<h2 id=\"Step2%EF%BC%9A%E8%BF%9B%E8%A1%8C%E5%B8%A7%E5%A4%84%E7%90%86\">Step2ï¼šè¿›è¡Œå¸§å¤„ç†</h2>\n<ul><li>è°ƒæ•´è§†é¢‘äº®åº¦ï¼Œåˆ†è§£YCrCbçš„ä¸‰ä¸ªæˆåˆ†ï¼Œæ‹†åˆ†çº¢è‰²å’Œç»¿è‰²ï¼Œæ–¹ä¾¿å¯¹çº¢ç»¿ä¸¤ç§é¢œè‰²è¿›è¡Œç‰¹å¾æå–</li></ul>\n<pre><code class=\"language-cpp\">    // å¸§å¤„ç†\n    while (1)\n    {\n        capture &gt;&gt; frame;\n        //è°ƒæ•´äº®åº¦\n        frame.convertTo(img, img.type(), a, b);\n\n        //è½¬æ¢ä¸ºYCrCbé¢œè‰²ç©ºé—´\n        cvtColor(img, imgYCrCb, CV_BGR2YCrCb);\n\n        imgRed.create(imgYCrCb.rows, imgYCrCb.cols, CV_8UC1);\n        imgGreen.create(imgYCrCb.rows, imgYCrCb.cols, CV_8UC1);\n\n        //åˆ†è§£YCrCbçš„ä¸‰ä¸ªæˆåˆ†\n        vector&lt;Mat&gt; planes;\n        split(imgYCrCb, planes);\n        // éå†ä»¥æ ¹æ®Cråˆ†é‡æ‹†åˆ†çº¢è‰²å’Œç»¿è‰²\n        MatIterator_&lt;uchar&gt; it_Cr = planes[1].begin&lt;uchar&gt;(),\n                it_Cr_end = planes[1].end&lt;uchar&gt;();\n        MatIterator_&lt;uchar&gt; it_Red = imgRed.begin&lt;uchar&gt;();\n        MatIterator_&lt;uchar&gt; it_Green = imgGreen.begin&lt;uchar&gt;();\n\n        for (; it_Cr != it_Cr_end; ++it_Cr, ++it_Red, ++it_Green)\n        {\n            // RED, 145&lt;Cr&lt;470 çº¢è‰²\n            if (*it_Cr &gt; 145 &amp;&amp; *it_Cr &lt; 470)\n                *it_Red = 255;\n            else\n                *it_Red = 0;\n\n            // GREEN 95&lt;Cr&lt;110 ç»¿è‰²\n            if (*it_Cr &gt; 95 &amp;&amp; *it_Cr &lt; 110)\n                *it_Green = 255;\n            else\n                *it_Green = 0;\n        }</code></pre>\n<h2 id=\"Step2%EF%BC%9A%E8%86%A8%E8%83%80%E8%85%90%E8%9A%80%E5%A4%84%E7%90%86\">Step3ï¼šè†¨èƒ€è…èš€å¤„ç†</h2>\n<ul><li>å»é™¤å…¶ä»–å™ªç‚¹ï¼Œæé«˜æˆ‘ä»¬éœ€è¦çš„çº¢ç»¿ç¯çš„ç‰¹å¾</li></ul>\n<pre><code class=\"language-cpp\">        //è†¨èƒ€å’Œè…èš€\n        dilate(imgRed, imgRed, Mat(15, 15, CV_8UC1), Point(-1, -1));\n        erode(imgRed, imgRed, Mat(1, 1, CV_8UC1), Point(-1, -1));\n        dilate(imgGreen, imgGreen, Mat(15, 15, CV_8UC1), Point(-1, -1));\n        erode(imgGreen, imgGreen, Mat(1, 1, CV_8UC1), Point(-1, -1));\n\n        redCount = processImgR(imgRed);\n        greenCount = processImgG(imgGreen);\n        cout &lt;&lt; \"red:\" &lt;&lt; redCount &lt;&lt; \";  \" &lt;&lt; \"green:\" &lt;&lt; greenCount &lt;&lt; endl;</code></pre>\n<h2 id=\"Step3%EF%BC%9A%E7%BA%A2%E7%BB%BF%E7%81%AF%E6%8F%90%E7%A4%BA%E5%88%A4%E6%96%AD\">Step4ï¼šçº¢ç»¿ç¯æç¤ºåˆ¤æ–­</h2>\n<ul><li>åŠ å…¥çº¢ç»¿ç¯è¯†åˆ«ç»“æœæ˜¾ç¤ºï¼Œæ–¹ä¾¿æˆ‘ä»¬æŸ¥çœ‹æ•ˆæœ</li></ul>\n<pre><code class=\"language-cpp\">        if(redCount == 0 &amp;&amp; greenCount == 0)\n        {\n            cv::putText(frame, \"lights out\", Point(40, 150), cv::FONT_HERSHEY_SIMPLEX, 2, cv::Scalar(255, 255, 255), 8, 8, 0);\n        }else if(redCount &gt; greenCount)\n        {\n            cv::putText(frame, \"red light\", Point(40, 150), cv::FONT_HERSHEY_SIMPLEX, 2, cv::Scalar(0, 0, 255), 8, 8, 0);\n        }else{\n            cv::putText(frame, \"green light\", Point(40, 150), cv::FONT_HERSHEY_SIMPLEX, 2, cv::Scalar(0, 255, 0), 8, 8, 0);\n        }</code></pre>\n<p><img alt=\"\" height=\"814\" src=\"image\\31353ee2e65e4d819b711358fe12d9b9.png\" width=\"1200\"/> <img alt=\"\" height=\"814\" src=\"image\\bf517f81ce0b47ac82b787e15a6d83af.png\" width=\"1200\"/></p>\n<h2 id=\"Step4%EF%BC%9A%E8%BD%AE%E5%BB%93%E6%8F%90%E5%8F%96\">Step5ï¼šè½®å»“æå–</h2>\n<ul><li>åˆ†åˆ«å¯¹çº¢ç¯å’Œç»¿ç¯è¿›è¡Œè½®å»“ç‰¹å¾æå–ï¼Œæé«˜è¾¨è¯†åº¦</li></ul>\n<pre><code class=\"language-cpp\">int processImgR(Mat src)\n{\n    Mat tmp;\n\n    vector&lt;vector&lt;Point&gt;&gt; contours;\n    vector&lt;Vec4i&gt; hierarchy;\n    vector&lt;Point&gt; hull;\n\n    CvPoint2D32f tempNode;\n    CvMemStorage* storage = cvCreateMemStorage();\n    CvSeq* pointSeq = cvCreateSeq(CV_32FC2, sizeof(CvSeq), sizeof(CvPoint2D32f), storage);\n\n    Rect* trackBox;\n    Rect* result;\n    int resultNum = 0;\n\n    int area = 0;\n    src.copyTo(tmp);\n\n    //æå–è½®å»“\n    findContours(tmp, contours, hierarchy, CV_RETR_CCOMP, CV_CHAIN_APPROX_SIMPLE);\n\n    if (contours.size() &gt; 0)\n    {\n        trackBox = new Rect[contours.size()];\n        result = new Rect[contours.size()];\n\n        //ç¡®å®šè¦è·Ÿè¸ªçš„åŒºåŸŸ\n        for (int i = 0; i &lt; contours.size(); i++)\n        {\n            cvClearSeq(pointSeq);\n            // è·å–å‡¸åŒ…çš„ç‚¹é›†\n            convexHull(Mat(contours[i]), hull, true);\n            int hullcount = (int)hull.size();\n            // å‡¸åŒ…çš„ä¿å­˜ç‚¹\n            for (int j = 0; j &lt; hullcount - 1; j++)\n            {\n                tempNode.x = hull[j].x;\n                tempNode.y = hull[j].y;\n                cvSeqPush(pointSeq, &amp;tempNode);\n            }\n\n            trackBox[i] = cvBoundingRect(pointSeq);\n        }\n\n        if (isFirstDetectedR)\n        {\n            lastTrackBoxR = new Rect[contours.size()];\n            for (int i = 0; i &lt; contours.size(); i++)\n                lastTrackBoxR[i] = trackBox[i];\n            lastTrackNumR = contours.size();\n            isFirstDetectedR = false;\n        }\n        else\n        {\n            for (int i = 0; i &lt; contours.size(); i++)\n            {\n                for (int j = 0; j &lt; lastTrackNumR; j++)\n                {\n                    if (isIntersected(trackBox[i], lastTrackBoxR[j]))\n                    {\n                        result[resultNum] = trackBox[i];\n                        break;\n                    }\n                }\n                resultNum++;\n            }\n            delete[] lastTrackBoxR;\n            lastTrackBoxR = new Rect[contours.size()];\n            for (int i = 0; i &lt; contours.size(); i++)\n            {\n                lastTrackBoxR[i] = trackBox[i];\n            }\n            lastTrackNumR = contours.size();\n        }\n\n        delete[] trackBox;\n    }\n    else\n    {\n        isFirstDetectedR = true;\n        result = NULL;\n    }\n    cvReleaseMemStorage(&amp;storage);\n\n    if (result != NULL)\n    {\n        for (int i = 0; i &lt; resultNum; i++)\n        {\n            area += result[i].area();\n        }\n    }\n    delete[] result;\n\n    return area;\n}\n\nint processImgG(Mat src)\n{\n    Mat tmp;\n\n    vector&lt;vector&lt;Point&gt; &gt; contours;\n    vector&lt;Vec4i&gt; hierarchy;\n    vector&lt; Point &gt; hull;\n\n    CvPoint2D32f tempNode;\n    CvMemStorage* storage = cvCreateMemStorage();\n    CvSeq* pointSeq = cvCreateSeq(CV_32FC2, sizeof(CvSeq), sizeof(CvPoint2D32f), storage);\n\n    Rect* trackBox;\n    Rect* result;\n    int resultNum = 0;\n\n    int area = 0;\n\n    src.copyTo(tmp);\n    //æå–è½®å»“\n    findContours(tmp, contours, hierarchy, CV_RETR_CCOMP, CV_CHAIN_APPROX_SIMPLE);\n\n    if (contours.size() &gt; 0)\n    {\n        trackBox = new Rect[contours.size()];\n        result = new Rect[contours.size()];\n\n        // ç¡®å®šè¦è·Ÿè¸ªçš„åŒºåŸŸ\n        for (int i = 0; i &lt; contours.size(); i++)\n        {\n            cvClearSeq(pointSeq);\n            // è·å–å‡¸åŒ…çš„ç‚¹é›†\n            convexHull(Mat(contours[i]), hull, true);\n            int hullcount = (int)hull.size();\n            // ä¿å­˜å‡¸åŒ…çš„ç‚¹\n            for (int j = 0; j &lt; hullcount - 1; j++)\n            {\n                tempNode.x = hull[j].x;\n                tempNode.y = hull[j].y;\n                cvSeqPush(pointSeq, &amp;tempNode);\n            }\n\n            trackBox[i] = cvBoundingRect(pointSeq);\n        }\n\n        if (isFirstDetectedG)\n        {\n            lastTrackBoxG = new Rect[contours.size()];\n            for (int i = 0; i &lt; contours.size(); i++)\n                lastTrackBoxG[i] = trackBox[i];\n            lastTrackNumG = contours.size();\n            isFirstDetectedG = false;\n        }\n        else\n        {\n            for (int i = 0; i &lt; contours.size(); i++)\n            {\n                for (int j = 0; j &lt; lastTrackNumG; j++)\n                {\n                    if (isIntersected(trackBox[i], lastTrackBoxG[j]))\n                    {\n                        result[resultNum] = trackBox[i];\n                        break;\n                    }\n                }\n                resultNum++;\n            }\n            delete[] lastTrackBoxG;\n            lastTrackBoxG = new Rect[contours.size()];\n            for (int i = 0; i &lt; contours.size(); i++)\n            {\n                lastTrackBoxG[i] = trackBox[i];\n            }\n            lastTrackNumG = contours.size();\n        }\n\n        delete[] trackBox;\n    }\n    else\n    {\n        isFirstDetectedG = true;\n        result = NULL;\n    }\n    cvReleaseMemStorage(&amp;storage);\n\n    if (result != NULL)\n    {\n        for (int i = 0; i &lt; resultNum; i++)\n        {\n            area += result[i].area();\n        }\n    }\n    delete[] result;\n\n    return area;\n}\n</code></pre>\n<p><img alt=\"\" height=\"785\" src=\"image\\7c0d16fb7f444501ad599c120f219e86.png\" width=\"1200\"/> <img alt=\"\" height=\"1200\" src=\"image\\95a70c89b7b94f778f095d7853546114.png\" width=\"1200\"/></p>\n<h2 id=\"%C2%A0Step4%EF%BC%9A%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4\">Step4ï¼šåˆ¤æ–­æ˜¯å¦ç›¸äº¤</h2>\n<pre><code class=\"language-cpp\">//ç¡®å®šä¸¤ä¸ªçŸ©å½¢åŒºåŸŸæ˜¯å¦ç›¸äº¤\nbool isIntersected(Rect r1, Rect r2)\n{\n    int minX = max(r1.x, r2.x);\n    int minY = max(r1.y, r2.y);\n    int maxX = min(r1.x + r1.width, r2.x + r2.width);\n    int maxY = min(r1.y + r1.height, r2.y + r2.height);\n\n    if (minX &lt; maxX &amp;&amp; minY &lt; maxY)\n        return true;\n    else\n        return false;\n}\n</code></pre>\n<h2 id=\"%E6%A1%88%E4%BE%8B%E6%95%88%E6%9E%9C\">ğŸš€æ¡ˆä¾‹æ•ˆæœ</h2>\n<p><img alt=\"\" height=\"816\" src=\"https://img-blog.csdnimg.cn/c26cb31e6944475b8040e8244284c1c4.gif\" width=\"1200\"/></p>\n<p><img alt=\"\" height=\"1200\" src=\"https://img-blog.csdnimg.cn/859d91f58c584b2292d83f8fe8a01723.gif\" width=\"1200\"/></p>\n<p><img alt=\"\" height=\"816\" src=\"https://img-blog.csdnimg.cn/b5d0151a28944391bc299482fb297e50.gif\" width=\"1200\"/></p>\n<h2 id=\"%F0%9F%92%A1%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81\"><strong>ğŸ’¡å®Œæ•´ä»£ç </strong></h2>\n<pre><code class=\"language-cpp\">#include \"opencv2/opencv.hpp\"\n#include \"opencv2/imgproc.hpp\"\n#include &lt;windows.h&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\nusing namespace cv;\n\n// Function headers\nint processImgR(Mat);\nint processImgG(Mat);\nbool isIntersected(Rect, Rect);\n\n// Global variables\nbool isFirstDetectedR = true;\nbool isFirstDetectedG = true;\nRect* lastTrackBoxR;\nRect* lastTrackBoxG;\nint lastTrackNumR;\nint lastTrackNumG;\n\n//ä¸»å‡½æ•°\nint main()\n{\n    int redCount = 0;\n    int greenCount = 0;\n\n    Mat frame;\n    Mat img;\n    Mat imgYCrCb;\n    Mat imgGreen;\n    Mat imgRed;\n\n    // äº®åº¦å‚æ•°\n    double a = 0.3;\n    double b = (1 - a) * 125;\n\n    VideoCapture capture(\"C:/Users/86177/Desktop/image/123.mp4\");//å¯¼å…¥è§†é¢‘çš„è·¯å¾„\n    if (!capture.isOpened())\n    {\n        cout &lt;&lt; \"Start device failed!\\n\" &lt;&lt; endl;//å¯åŠ¨è®¾å¤‡å¤±è´¥ï¼\n        return -1;\n    }\n\n    // å¸§å¤„ç†\n    while (1)\n    {\n        capture &gt;&gt; frame;\n        //è°ƒæ•´äº®åº¦\n        frame.convertTo(img, img.type(), a, b);\n\n        //è½¬æ¢ä¸ºYCrCbé¢œè‰²ç©ºé—´\n        cvtColor(img, imgYCrCb, CV_BGR2YCrCb);\n\n        imgRed.create(imgYCrCb.rows, imgYCrCb.cols, CV_8UC1);\n        imgGreen.create(imgYCrCb.rows, imgYCrCb.cols, CV_8UC1);\n\n        //åˆ†è§£YCrCbçš„ä¸‰ä¸ªæˆåˆ†\n        vector&lt;Mat&gt; planes;\n        split(imgYCrCb, planes);\n        // éå†ä»¥æ ¹æ®Cråˆ†é‡æ‹†åˆ†çº¢è‰²å’Œç»¿è‰²\n        MatIterator_&lt;uchar&gt; it_Cr = planes[1].begin&lt;uchar&gt;(),\n                it_Cr_end = planes[1].end&lt;uchar&gt;();\n        MatIterator_&lt;uchar&gt; it_Red = imgRed.begin&lt;uchar&gt;();\n        MatIterator_&lt;uchar&gt; it_Green = imgGreen.begin&lt;uchar&gt;();\n\n        for (; it_Cr != it_Cr_end; ++it_Cr, ++it_Red, ++it_Green)\n        {\n            // RED, 145&lt;Cr&lt;470 çº¢è‰²\n            if (*it_Cr &gt; 145 &amp;&amp; *it_Cr &lt; 470)\n                *it_Red = 255;\n            else\n                *it_Red = 0;\n\n            // GREEN 95&lt;Cr&lt;110 ç»¿è‰²\n            if (*it_Cr &gt; 95 &amp;&amp; *it_Cr &lt; 110)\n                *it_Green = 255;\n            else\n                *it_Green = 0;\n        }\n\n        //è†¨èƒ€å’Œè…èš€\n        dilate(imgRed, imgRed, Mat(15, 15, CV_8UC1), Point(-1, -1));\n        erode(imgRed, imgRed, Mat(1, 1, CV_8UC1), Point(-1, -1));\n        dilate(imgGreen, imgGreen, Mat(15, 15, CV_8UC1), Point(-1, -1));\n        erode(imgGreen, imgGreen, Mat(1, 1, CV_8UC1), Point(-1, -1));\n\n        redCount = processImgR(imgRed);\n        greenCount = processImgG(imgGreen);\n        cout &lt;&lt; \"red:\" &lt;&lt; redCount &lt;&lt; \";  \" &lt;&lt; \"green:\" &lt;&lt; greenCount &lt;&lt; endl;\n\n        if(redCount == 0 &amp;&amp; greenCount == 0)\n        {\n            cv::putText(frame, \"lights out\", Point(40, 150), cv::FONT_HERSHEY_SIMPLEX, 2, cv::Scalar(255, 255, 255), 8, 8, 0);\n        }else if(redCount &gt; greenCount)\n        {\n            cv::putText(frame, \"red light\", Point(40, 150), cv::FONT_HERSHEY_SIMPLEX, 2, cv::Scalar(0, 0, 255), 8, 8, 0);\n        }else{\n            cv::putText(frame, \"green light\", Point(40, 150), cv::FONT_HERSHEY_SIMPLEX, 2, cv::Scalar(0, 255, 0), 8, 8, 0);\n        }\n\n        imshow(\"video\", frame);\n        imshow(\"Red\", imgRed);\n        imshow(\"Green\", imgGreen);\n\n        // Handle with the keyboard input\n        if (cvWaitKey(20) == 'q')\n            break;\n    }\n\n    return 0;\n}\n\nint processImgR(Mat src)\n{\n    Mat tmp;\n\n    vector&lt;vector&lt;Point&gt;&gt; contours;\n    vector&lt;Vec4i&gt; hierarchy;\n    vector&lt;Point&gt; hull;\n\n    CvPoint2D32f tempNode;\n    CvMemStorage* storage = cvCreateMemStorage();\n    CvSeq* pointSeq = cvCreateSeq(CV_32FC2, sizeof(CvSeq), sizeof(CvPoint2D32f), storage);\n\n    Rect* trackBox;\n    Rect* result;\n    int resultNum = 0;\n\n    int area = 0;\n    src.copyTo(tmp);\n\n    //æå–è½®å»“\n    findContours(tmp, contours, hierarchy, CV_RETR_CCOMP, CV_CHAIN_APPROX_SIMPLE);\n\n    if (contours.size() &gt; 0)\n    {\n        trackBox = new Rect[contours.size()];\n        result = new Rect[contours.size()];\n\n        //ç¡®å®šè¦è·Ÿè¸ªçš„åŒºåŸŸ\n        for (int i = 0; i &lt; contours.size(); i++)\n        {\n            cvClearSeq(pointSeq);\n            // è·å–å‡¸åŒ…çš„ç‚¹é›†\n            convexHull(Mat(contours[i]), hull, true);\n            int hullcount = (int)hull.size();\n            // å‡¸åŒ…çš„ä¿å­˜ç‚¹\n            for (int j = 0; j &lt; hullcount - 1; j++)\n            {\n                tempNode.x = hull[j].x;\n                tempNode.y = hull[j].y;\n                cvSeqPush(pointSeq, &amp;tempNode);\n            }\n\n            trackBox[i] = cvBoundingRect(pointSeq);\n        }\n\n        if (isFirstDetectedR)\n        {\n            lastTrackBoxR = new Rect[contours.size()];\n            for (int i = 0; i &lt; contours.size(); i++)\n                lastTrackBoxR[i] = trackBox[i];\n            lastTrackNumR = contours.size();\n            isFirstDetectedR = false;\n        }\n        else\n        {\n            for (int i = 0; i &lt; contours.size(); i++)\n            {\n                for (int j = 0; j &lt; lastTrackNumR; j++)\n                {\n                    if (isIntersected(trackBox[i], lastTrackBoxR[j]))\n                    {\n                        result[resultNum] = trackBox[i];\n                        break;\n                    }\n                }\n                resultNum++;\n            }\n            delete[] lastTrackBoxR;\n            lastTrackBoxR = new Rect[contours.size()];\n            for (int i = 0; i &lt; contours.size(); i++)\n            {\n                lastTrackBoxR[i] = trackBox[i];\n            }\n            lastTrackNumR = contours.size();\n        }\n\n        delete[] trackBox;\n    }\n    else\n    {\n        isFirstDetectedR = true;\n        result = NULL;\n    }\n    cvReleaseMemStorage(&amp;storage);\n\n    if (result != NULL)\n    {\n        for (int i = 0; i &lt; resultNum; i++)\n        {\n            area += result[i].area();\n        }\n    }\n    delete[] result;\n\n    return area;\n}\n\nint processImgG(Mat src)\n{\n    Mat tmp;\n\n    vector&lt;vector&lt;Point&gt; &gt; contours;\n    vector&lt;Vec4i&gt; hierarchy;\n    vector&lt; Point &gt; hull;\n\n    CvPoint2D32f tempNode;\n    CvMemStorage* storage = cvCreateMemStorage();\n    CvSeq* pointSeq = cvCreateSeq(CV_32FC2, sizeof(CvSeq), sizeof(CvPoint2D32f), storage);\n\n    Rect* trackBox;\n    Rect* result;\n    int resultNum = 0;\n\n    int area = 0;\n\n    src.copyTo(tmp);\n    //æå–è½®å»“\n    findContours(tmp, contours, hierarchy, CV_RETR_CCOMP, CV_CHAIN_APPROX_SIMPLE);\n\n    if (contours.size() &gt; 0)\n    {\n        trackBox = new Rect[contours.size()];\n        result = new Rect[contours.size()];\n\n        // ç¡®å®šè¦è·Ÿè¸ªçš„åŒºåŸŸ\n        for (int i = 0; i &lt; contours.size(); i++)\n        {\n            cvClearSeq(pointSeq);\n            // è·å–å‡¸åŒ…çš„ç‚¹é›†\n            convexHull(Mat(contours[i]), hull, true);\n            int hullcount = (int)hull.size();\n            // ä¿å­˜å‡¸åŒ…çš„ç‚¹\n            for (int j = 0; j &lt; hullcount - 1; j++)\n            {\n                tempNode.x = hull[j].x;\n                tempNode.y = hull[j].y;\n                cvSeqPush(pointSeq, &amp;tempNode);\n            }\n\n            trackBox[i] = cvBoundingRect(pointSeq);\n        }\n\n        if (isFirstDetectedG)\n        {\n            lastTrackBoxG = new Rect[contours.size()];\n            for (int i = 0; i &lt; contours.size(); i++)\n                lastTrackBoxG[i] = trackBox[i];\n            lastTrackNumG = contours.size();\n            isFirstDetectedG = false;\n        }\n        else\n        {\n            for (int i = 0; i &lt; contours.size(); i++)\n            {\n                for (int j = 0; j &lt; lastTrackNumG; j++)\n                {\n                    if (isIntersected(trackBox[i], lastTrackBoxG[j]))\n                    {\n                        result[resultNum] = trackBox[i];\n                        break;\n                    }\n                }\n                resultNum++;\n            }\n            delete[] lastTrackBoxG;\n            lastTrackBoxG = new Rect[contours.size()];\n            for (int i = 0; i &lt; contours.size(); i++)\n            {\n                lastTrackBoxG[i] = trackBox[i];\n            }\n            lastTrackNumG = contours.size();\n        }\n\n        delete[] trackBox;\n    }\n    else\n    {\n        isFirstDetectedG = true;\n        result = NULL;\n    }\n    cvReleaseMemStorage(&amp;storage);\n\n    if (result != NULL)\n    {\n        for (int i = 0; i &lt; resultNum; i++)\n        {\n            area += result[i].area();\n        }\n    }\n    delete[] result;\n\n    return area;\n}\n\n//ç¡®å®šä¸¤ä¸ªçŸ©å½¢åŒºåŸŸæ˜¯å¦ç›¸äº¤\nbool isIntersected(Rect r1, Rect r2)\n{\n    int minX = max(r1.x, r2.x);\n    int minY = max(r1.y, r2.y);\n    int maxX = min(r1.x + r1.width, r2.x + r2.width);\n    int maxY = min(r1.y + r1.height, r2.y + r2.height);\n\n    if (minX &lt; maxX &amp;&amp; minY &lt; maxY)\n        return true;\n    else\n        return false;\n}\n</code></pre>\n<h1 id=\"%E4%B8%89%E3%80%81%E6%80%BB%E7%BB%93\">ä¸‰ã€æ€»ç»“</h1>\n<blockquote>\n<ul><li>æœ¬æ–‡ä¸»è¦è®²è§£<span style=\"color:#be191c;\"><strong>OpenCVè½®å»“è¯†åˆ«åŸç†</strong></span>ä»¥åŠ<span style=\"color:#be191c;\"><strong>OpenCVçº¢ç»¿ç¯è¯†åˆ«</strong></span>çš„å®ç°å…·ä½“æ­¥éª¤</li><li>OpenCVè¿˜æ˜¯æœ‰å¾ˆå¤šè¯†åˆ«çš„åº“å‡½æ•°å¯ä»¥ç”¨ï¼Œæ¥ä¸‹æ¥ç»§ç»­æ¢ç´¢ï¼Œç»“åˆç”Ÿæ´»å®é™…ç»§ç»­åšä¸€äº›æœ‰æ„æ€çš„æ¡ˆä¾‹</li></ul>\n</blockquote>\n<p><span style=\"color:#38d8f0;\"><strong><em>ä»¥ä¸Šå°±æ˜¯æœ¬æ–‡çš„å…¨éƒ¨å†…å®¹å•¦ï¼å¦‚æœå¯¹æ‚¨æœ‰å¸®åŠ©ï¼Œéº»çƒ¦ç‚¹èµå•¦ï¼æ”¶è—å•¦ï¼æ¬¢è¿å„ä½è¯„è®ºåŒºç•™è¨€</em>ï¼ï¼ !</strong> </span></p>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"369\" src=\"https://img-blog.csdnimg.cn/93f7366f85354e50a1eb8393367608f7.gif\" width=\"675\"/> </p>\n</div>\n</div>"}