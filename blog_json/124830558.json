{"blogid": "124830558", "writerAge": "码龄2年", "writerBlogNum": "8", "writerCollect": "96", "writerComment": "6", "writerFan": "2", "writerGrade": "2级", "writerIntegral": "131", "writerName": "有意悠悠", "writerProfileAdress": "writer_image\\profile_124830558.jpg", "writerRankTotal": "108183", "writerRankWeekly": "579189", "writerThumb": "37", "writerVisitNum": "29792", "blog_read_count": "9287", "blog_time": "已于 2022-05-30 23:35:00 修改", "blog_title": "Java反射（通俗易懂）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"-toc\" style=\"margin-left:0px;\"></p>\n<p id=\"1%E3%80%81%E5%8F%8D%E5%B0%84%E4%BB%8B%E7%BB%8D-toc\" style=\"margin-left:0px;\"><a href=\"#1%E3%80%81%E5%8F%8D%E5%B0%84%E4%BB%8B%E7%BB%8D\">1、反射介绍</a></p>\n<p id=\"2%E3%80%81%E5%8F%8D%E5%B0%84API-toc\" style=\"margin-left:0px;\"><a href=\"#2%E3%80%81%E5%8F%8D%E5%B0%84API\">2、反射API</a></p>\n<p id=\"2.1%20%E8%8E%B7%E5%8F%96%E7%B1%BB%E5%AF%B9%E5%BA%94%E7%9A%84%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%89%E7%A7%8D%EF%BC%89-toc\" style=\"margin-left:40px;\"><a href=\"#2.1%20%E8%8E%B7%E5%8F%96%E7%B1%BB%E5%AF%B9%E5%BA%94%E7%9A%84%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%89%E7%A7%8D%EF%BC%89\">2.1 获取类对应的字节码的对象（三种）</a></p>\n<p id=\"2.2%20%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-toc\" style=\"margin-left:40px;\"><a href=\"#2.2%20%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95\">2.2 常用方法</a></p>\n<p id=\"3%E3%80%81%E5%8F%8D%E5%B0%84%E7%9A%84%E5%BA%94%E7%94%A8-toc\" style=\"margin-left:0px;\"><a href=\"#3%E3%80%81%E5%8F%8D%E5%B0%84%E7%9A%84%E5%BA%94%E7%94%A8\">3、反射的应用</a></p>\n<p id=\"3.1%20%E5%88%9B%E5%BB%BA%20%3A%20%E6%B5%8B%E8%AF%95%E7%89%A9%E6%96%99%E7%B1%BB-toc\" style=\"margin-left:40px;\"><a href=\"#3.1%20%E5%88%9B%E5%BB%BA%20%3A%20%E6%B5%8B%E8%AF%95%E7%89%A9%E6%96%99%E7%B1%BB\">3.1 创建 : 测试物料类</a></p>\n<p id=\"3.2%20%E8%8E%B7%E5%8F%96%E7%B1%BB%E5%AF%B9%E8%B1%A1-toc\" style=\"margin-left:40px;\"><a href=\"#3.2%20%E8%8E%B7%E5%8F%96%E7%B1%BB%E5%AF%B9%E8%B1%A1\">3.2 获取类对象</a></p>\n<p id=\"3.3%20%E8%8E%B7%E5%8F%96%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-toc\" style=\"margin-left:40px;\"><a href=\"#3.3%20%E8%8E%B7%E5%8F%96%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F\">3.3 获取成员变量</a></p>\n<p id=\"3.4%20%E9%80%9A%E8%BF%87%E5%AD%97%E8%8A%82%E7%A0%81%E5%AF%B9%E8%B1%A1%E8%8E%B7%E5%8F%96%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95-toc\" style=\"margin-left:40px;\"><a href=\"#3.4%20%E9%80%9A%E8%BF%87%E5%AD%97%E8%8A%82%E7%A0%81%E5%AF%B9%E8%B1%A1%E8%8E%B7%E5%8F%96%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95\">3.4 通过字节码对象获取类的成员方法</a></p>\n<p id=\"3.5%20%E9%80%9A%E8%BF%87%E5%AD%97%E8%8A%82%E7%A0%81%E5%AF%B9%E8%B1%A1%E8%8E%B7%E5%8F%96%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-toc\" style=\"margin-left:40px;\"><a href=\"#3.5%20%E9%80%9A%E8%BF%87%E5%AD%97%E8%8A%82%E7%A0%81%E5%AF%B9%E8%B1%A1%E8%8E%B7%E5%8F%96%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95\">3.5 通过字节码对象获取类的构造方法</a></p>\n<p id=\"4%E3%80%81%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1-toc\" style=\"margin-left:0px;\"><a href=\"#4%E3%80%81%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1\">4、创建对象</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h1 id=\"1%E3%80%81%E5%8F%8D%E5%B0%84%E4%BB%8B%E7%BB%8D\">1、反射介绍</h1>\n<p>        Reflection(反射) 是 Java 程序开发语言的特征之一，它允许运行中的 Java 程序对自身进行检查。被private封装的资源只能类内部访问，外部是不行的，但反射能直接操作类私有属性。反射可以在运行时获取一个类的所有信息，（包括成员变量，成员方法，构造器等），并且可以操纵类的字段、方法、构造器等部分。</p>\n<p>        要想解剖一个类，必须先要获取到该类的字节码文件对象。而解剖使用的就是Class类中的方法。所以先要获取到每一个字节码文件对应的Class类型的对象。</p>\n<p>        <strong><span style=\"color:#956fe7;\">反射就是把java类中的各种成分映射成一个个的Java对象</span></strong>。<br/>         例如：一个类有：成员变量、方法、构造方法、包等等信息，利用反射技术可以对一个类进行解剖，把一个个组成部分映射成一个个对象。（其实：一个类中这些成员方法、构造方法、在加入类中都有一个类来描述）<br/>         <strong>加载的时候：</strong>Class对象的由来是将 .class 文件读入内存，并为之创建一个Class对象。</p>\n<p>        <span style=\"color:#fe2c24;\"><strong>Class类</strong></span></p>\n<p>        <span style=\"color:#956fe7;\"><strong>Class 类的实例表示正在运行的 Java 应用程序中的类和接口</strong></span>。也就是jvm中有N多的实例每个类都有该Class对象。（包括基本数据类型）<br/>         Class 没有公共构造方法。Class 对象是在加载类时由 Java 虚拟机以及通过调用类加载器中的defineClass 方法自动构造的。也就是这不需要我们自己去处理创建，JVM已经帮我们创建好了。</p>\n<p>        我们知道Spring框架可以帮我们创建和管理对象。需要对象时，我们无需自己手动new对象，直接从Spring提供的容器中的Beans获取即可。<strong>Beans底层其实就是一个Map&lt;String,Object&gt;，最终通过getBean(“user”)来获取</strong>。而这其中最核心的实现就是利用反射技术。   </p>\n<p><em><strong><span style=\"color:#fe2c24;\">        Bean</span></strong></em></p>\n<p><em>        1、Java面向对象，对象有方法和属性，那么就需要<strong>对象实例来调用方法和属性（即实例化）；</strong></em></p>\n<p><em>        2、凡是有方法或属性的类都需要实例化，这样才能具象化去使用这些方法和属性；</em></p>\n<p><em>        3、规律：<strong><span style=\"color:#956fe7;\">凡是子类及带有方法或属性的类都要加上注册Bean到Spring IoC的注解</span>；（</strong>@Component , @Repository , @ Controller , @Service , @Configration<strong>）</strong></em></p>\n<p><em>        4、<span style=\"color:#956fe7;\">把Bean理解为类的代理或代言人（实际上确实是通过反射、代理来实现的），这样它就能代表类拥有该拥有的东西了</span></em></p>\n<p><em>        5、在Spring中，<strong>你标识一个@符号，那么Spring就会来看看，并且从这里拿到一个Bean（注册）或者给出一个Bean（使用）</strong></em></p>\n<h1 id=\"2%E3%80%81%E5%8F%8D%E5%B0%84API\">2、反射API</h1>\n<h2 id=\"2.1%20%E8%8E%B7%E5%8F%96%E7%B1%BB%E5%AF%B9%E5%BA%94%E7%9A%84%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%89%E7%A7%8D%EF%BC%89\">2.1 获取类对应的字节码的对象（三种）</h2>\n<p><strong>①</strong> 调用某个类的对象的getClass()方法，即：对象.getClass()；</p>\n<pre><code class=\"language-java\">Person p = new Person();\nClass clazz = p.getClass();</code></pre>\n<p><strong><span style=\"color:#fe2c24;\">        注意：</span></strong>此处使用的是Object类中的getClass()方法，因为所有类都继承Object类，所以调用Object类中的getClass()方法来获取。</p>\n<p><strong>②</strong> 调用类的class属性类获取该类对应的Class对象，即：类名.class</p>\n<pre><code class=\"language-java\">Class clazz = Person.class;</code></pre>\n<p><strong>③</strong> 使用Class类中的forName()静态方法（最安全，性能最好）即：Class.forName(“类的全路径”)</p>\n<pre><code class=\"language-java\">Class clazz = Class.forName(\"类的全路径\");</code></pre>\n<p><strong><span style=\"color:#fe2c24;\">        注意：</span></strong>在运行期间，一个类，只有一个Class对象产生。</p>\n<p>        三种方式常用第三种，第一种对象都有了还要反射干什么。第二种需要导入类的包，依赖太强，不导包就抛编译错误。</p>\n<h2 id=\"2.2%20%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95\">2.2 常用方法</h2>\n<p>        当我们获得了想要操作的类的Class对象后，可以通过Class类中的方法获取和查看该类中的方法和属性。</p>\n<pre><code class=\"language-java\">//获取包名、类名\nclazz.getPackage().getName()//包名\nclazz.getSimpleName()//类名\nclazz.getName()//完整类名\n\n//获取成员变量定义信息\ngetFields()//获取所有公开的成员变量,包括继承变量\ngetDeclaredFields()//获取本类定义的成员变量,包括私有,但不包括继承的变量\ngetField(变量名)\ngetDeclaredField(变量名)\n\n//获取构造方法定义信息\ngetConstructor(参数类型列表)//获取公开的构造方法\ngetConstructors()//获取所有的公开的构造方法\ngetDeclaredConstructors()//获取所有的构造方法,包括私有\ngetDeclaredConstructor(int.class,String.class)\n\n//获取方法定义信息\ngetMethods()//获取所有可见的方法,包括继承的方法\ngetMethod(方法名,参数类型列表)\ngetDeclaredMethods()//获取本类定义的的方法,包括私有,不包括继承的方法\ngetDeclaredMethod(方法名,int.class,String.class)\n\n//反射新建实例\nclazz.newInstance();//执行无参构造创建对象\nclazz.newInstance(222,\"韦小宝\");//执行有参构造创建对象\nclazz.getConstructor(int.class,String.class)//获取构造方法\n\n//反射调用成员变量\nclazz.getDeclaredField(变量名);//获取变量\nclazz.setAccessible(true);//使私有成员允许访问\nf.set(实例,值);//为指定实例的变量赋值,静态变量,第一参数给null\nf.get(实例);//访问指定实例变量的值,静态变量,第一参数给null\n\n//反射调用成员方法\nMethod m = Clazz.getDeclaredMethod(方法名,参数类型列表);\nm.setAccessible(true);//使私有方法允许被调用\nm.invoke(实例,参数数据);//让指定实例来执行该方法</code></pre>\n<h1 id=\"3%E3%80%81%E5%8F%8D%E5%B0%84%E7%9A%84%E5%BA%94%E7%94%A8\">3、反射的应用</h1>\n<h2 id=\"3.1%20%E5%88%9B%E5%BB%BA%20%3A%20%E6%B5%8B%E8%AF%95%E7%89%A9%E6%96%99%E7%B1%BB\">3.1 测试物料类</h2>\n<p>创建包: com.reflection<br/> 创建类: Student.java*</p>\n<pre><code class=\"language-java\">package com.review;\n/*本类用于复习反射的物料类*/\npublic class Student {\n    //1.定义成员变量\n    private String name;\n    public int age;\n\n    //2.给被封装属性提供get与set方法\n    public String getName() {\n        return name;\n    }\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    //3.生成本类的无参构造与全参构造\n    public Student(){}\n    public Student(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n    //4.提供本类的普通方法\n    public void play(){\n        System.out.println(\"不玩游戏，学Java！\");\n    }\n    public void sunDay(int n){\n        System.out.println(\"卷起来，没有假！\");\n    }\n    //5.为了查看学生对象的具体属性与属性值，重写toString()\n    @Override\n    public String toString() {\n        return \"Student{\" +\n                \"name='\" + name + '\\'' +\n                \", age=\" + age +\n                '}';\n    }\n}</code></pre>\n<h2 id=\"3.2%20%E8%8E%B7%E5%8F%96%E7%B1%BB%E5%AF%B9%E8%B1%A1\">3.2 获取类对象</h2>\n<p>由于经常使用的是第三种方法，所以以下使用第三种。</p>\n<p>创建包: com.reflection<br/> 创建类: TestReflect.java</p>\n<pre><code class=\"language-java\">/*本类用于反射的测试*/\npublic class TestReflect {\n    //1.可以创建程序的入口函数main()--此处不用\n    //2.通过单元测试方法，获取目标类Student对应的字节码对象\n    @Test\n    public void getClazz() throws ClassNotFoundException {\n        //练习获取字节码对象的3种方式\n        Class&lt;?&gt; clazz1 = Class.forName(\"com.review.Student\");\n        Class&lt;?&gt; clazz2 = Student.class;\n        Class&lt;?&gt; clazz3 = new Student().getClass();\n\n        //打印的是Student类对应的字节码对象\n        System.out.println(clazz1);//class com.reflection.Student\n        //获取Student类对应的字节码对象clazz1的名字\n        System.out.println(clazz1.getName());//com.reflection.Student\n        //通过Student类对应的字节码对象，获取Student类的类名\n        System.out.println(clazz1.getSimpleName());\n        //通过Student类对应的字节码对象，获取Student类对应的包对象\n        System.out.println(clazz1.getPackage());\n        //通过Student类对应的字节码对象，先获取Student类对应的包对象，再获取这个包对象的名字\n        System.out.println(clazz1.getPackage().getName());\n    }\n}</code></pre>\n<h2 id=\"3.3%20%E8%8E%B7%E5%8F%96%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F\">3.3 获取成员变量</h2>\n<pre><code class=\"language-java\">/**本类用来测试反射*/\npublic class TestReflect {\n\t//3.通过单元测试方法练习引用类型数组的定义与遍历\n    @Test\n    public void getStu() {\n        //1.创建Student类的3个对象\n        Student s1 = new Student(\"张三\", 3);\n        Student s2 = new Student(\"李四\", 4);\n        Student s3 = new Student(\"王五\", 5);\n        //2.创建数组将刚刚的3个对象存入数组中\n        Student[] s = {s1, s2, s3};\n        //3.直接打印数组，查看数组中的元素\n        System.out.println(Arrays.toString(s));\n        //4.遍历学生数组，拿到每一个学生对象，做进一步的操作\n        for (Student stu : s) {\n            //System.out.println(stu);\n            stu.play();//通过遍历到的对象，执行play()\n            System.out.println(stu.age);//通过遍历到的对象，打印age属性\n        }\n    }\n\n\t//4.通过单元测试方法，获取Student类中的成员变量\n    @Test\n    public void getFie() throws ClassNotFoundException {\n        //1.获取Student类对应的字节码对象\n        Class&lt;?&gt; clazz = Class.forName(\"com.review.Student\");\n        //2.通过Student类对应的字节码对象获取Student类中的成员变量们\n        Field[] fs = clazz.getFields();\n        //3.遍历数组，获取Student类中的每个成员变量的具体信息\n        /*注意！目前成员变量的修饰符必须是public的才能获取到*/\n        for(Field f : fs){\n            System.out.println(f.getName());//通过本轮循环到的字段对象获取字段名\n            System.out.println(f.getType());//通过本轮循环到的字段对象获取字段的类型\n        }\n\n    }\n}</code></pre>\n<h2 id=\"3.4%20%E9%80%9A%E8%BF%87%E5%AD%97%E8%8A%82%E7%A0%81%E5%AF%B9%E8%B1%A1%E8%8E%B7%E5%8F%96%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95\">3.4 通过字节码对象获取类的成员方法</h2>\n<pre><code class=\"language-java\">/**本类用来测试反射*/\npublic class TestReflect {\n    //5.通过单元测试方法，获取Student类中的成员方法\n    @Test\n    public void getFunction() {\n        //1.获取Student类对应的字节码对象\n        Class&lt;?&gt; clazz = Class.forName(\"com.review.Student\");\n        //2.通过Student类对应的字节码对象获取Student类中的成员方法们\n        Method[] ms = clazz.getMethods();\n        //3.通过高效for循环遍历数组，拿到每一个方法对象\n        for (Method m : ms) {\n            System.out.println(m);//直接打印遍历到的方法对象\n            System.out.println(m.getName());//通过方法对象获取方法名\n            Class&lt;?&gt;[] pt = m.getParameterTypes();//通过方法对象获取方法所有参数的数组\n            System.out.println(Arrays.toString(pt));//打印方法参数的数组\n        }\n\n    }\n}</code></pre>\n<h2 id=\"3.5%20%E9%80%9A%E8%BF%87%E5%AD%97%E8%8A%82%E7%A0%81%E5%AF%B9%E8%B1%A1%E8%8E%B7%E5%8F%96%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95\">3.5 通过字节码对象获取类的构造方法</h2>\n<pre><code class=\"language-java\">/**本类用来测试反射*/\npublic class TestReflect {\n    //6.通过单元测试方法，获取Student类中的构造方法\n    @Test\n    public void getCons() {\n        //1.获取字节码对象\n        Class&lt;?&gt; clazz = Class.forName(\"com.review.Student\");\n        //2.通过字节码对象获取目标类Student的构造方法们\n        Constructor&lt;?&gt;[] cs = clazz.getConstructors();\n        //3.通过高效for循环遍历数组\n        for(Constructor c : cs){\n            System.out.println(c.getName());//打印本轮遍历到的构造方法的名字\n            Class[] pt = c.getParameterTypes();//通过本轮遍历到的构造函数对象获取构造函数的参数类型\n            System.out.println(Arrays.toString(pt));//打印参数类型\n        }\n    }\n}</code></pre>\n<h1 id=\"4%E3%80%81%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1\">4、创建对象</h1>\n<pre><code class=\"language-java\">/**本类用来测试反射*/\npublic class TestReflect {\n//7.通过单元测试方法，创建Student目标类的对象\n    @Test\n    public void getObject() throws Exception {\n        //1.获取字节码对象\n        Class&lt;?&gt; clazz = Class.forName(\"com.review.Student\");\n        \n        //2.通过反射技术创建目标类的对象,注意抛出异常\n        /*反射创建对象方案1：\n            使用 目标类 的 无参构造 创建对象\n        */\n        Object o = clazz.newInstance();\n        System.out.println(o);//这一步已经获取到了对象Student{name='null', age=0}\n\n        /*反射创建对象方案2：\n            使用 目标类 的 全参构造 创建对象\n        * 思路：\n        * 1.先获取指定的构造函数对象,注意需要指定构造函数的参数，传入的是.class字节码对象\n        * 2.通过刚刚获取到的构造函数对象创建Student目标类的对象，并且给对象的属性赋值\n        * */\n\n        //3.获取目标类中指定的全参构造\n        Constructor&lt;?&gt; c = clazz.getConstructor(String.class, int.class);\n        //System.out.println(c);\n\n        //4.通过获取到的构造函数：创建对象 + 给对象的属性赋值\n        Object o2 = c.newInstance(\"赵六\", 6);\n        System.out.println(o2);\n    }\n}\n</code></pre>\n<p>参考链接1：<a href=\"https://blog.csdn.net/sinat_38259539/article/details/71799078\" title=\"Java基础之—反射（非常重要）_敬业小码哥的博客-CSDN博客_jvav\">Java基础之—反射（非常重要）_敬业小码哥的博客-CSDN博客_jvav</a></p>\n<p>参考链接2：<a href=\"https://blog.csdn.net/weixin_43884234/article/details/115056812\" title=\"一起学JAVA 反射学习(超详细)_程序媛 泡泡的博客-CSDN博客_java反射技术\">一起学JAVA 反射学习(超详细)_程序媛 泡泡的博客-CSDN博客_java反射技术</a></p>\n</div>\n</div>"}