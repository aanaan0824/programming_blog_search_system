{"blogid": "126618220", "writerAge": "码龄1年", "writerBlogNum": "333", "writerCollect": "425", "writerComment": "12", "writerFan": "23796", "writerGrade": "5级", "writerIntegral": "3692", "writerName": "m0_67391270", "writerProfileAdress": "writer_image\\profile_126618220.jpg", "writerRankTotal": "5040", "writerRankWeekly": "328", "writerThumb": "94", "writerVisitNum": "209847", "blog_read_count": "845", "blog_time": "于 2022-08-31 10:10:24 发布", "blog_title": "通俗的解释什么是Docker，一文搞懂", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h1><a id=\"Docker_2\"></a>一、初识Docker</h1>\n<h1><a id=\"11Docker_5\"></a>1.1.什么是Docker</h1>\n<p>微服务虽然具备各种各样的优势，但服务的拆分通用给部署带来了很大的麻烦。</p>\n<ul><li>分布式系统中，依赖的组件非常多，不同组件之间部署时往往会产生一些冲突。</li><li>在数百上千台服务中重复部署，环境不一定一致，会遇到各种问题</li></ul>\n<h3><a id=\"111_13\"></a>1.1.1.应用部署的环境问题</h3>\n<p>大型项目组件较多，运行环境也较为复杂，部署时会碰到一些问题：</p>\n<ul><li>依赖关系复杂，容易出现兼容性问题</li><li>开发、测试、生产环境有差异</li></ul>\n<p><img alt=\"\" src=\"image\\34c85e5adf562025688782d546ed4c63.png\"/></p>\n<p>例如一个项目中，部署时需要依赖于<a href=\"https://www.zhihu.com/searchq=node.js&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2490748104%7D\" title=\"node.js\">node.js</a>、Redis、RabbitMQ、MySQL等，这些服务部署时所需要的<a href=\"https://www.zhihu.com/searchq=%E5%87%BD%E6%95%B0%E5%BA%93&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2490748104%7D\" title=\"函数库\">函数库</a>、依赖项各不相同，甚至会有冲突。给部署带来了极大的困难。</p>\n<h3><a id=\"112Docker_24\"></a>1.1.2.Docker解决依赖兼容问题</h3>\n<p>而Docker确巧妙的解决了这些问题，Docker是如何实现的呢？</p>\n<p>Docker为了解决依赖的兼容问题的，采用了两个手段：</p>\n<ul><li>将应用的Libs（函数库）、Deps（依赖）、配置与应用一起打包</li><li>将每个应用放到一个隔离<strong>容器</strong>去运行，避免互相干扰</li></ul>\n<p><img alt=\"\" src=\"image\\a39542f68a692b7187c71ce4996ca21b.png\"/></p>\n<p>这样打包好的应用包中，既包含应用本身，也保护应用所需要的Libs、Deps，无需再操作系统上安装这些，自然就不存在不同应用之间的兼容问题了。</p>\n<p>虽然解决了不同应用的兼容问题，但是开发、测试等环境会存在差异，操作系统版本也会有差异，怎么解决这些问题呢？</p>\n<h3><a id=\"113Docker_39\"></a>1.1.3.Docker解决操作系统环境差异</h3>\n<p>要解决不同操作系统环境差异问题，必须先了解操作系统结构。以一个Ubuntu操作系统为例，结构如下：</p>\n<p><img alt=\"\" src=\"image\\2d24aee242daa86e172b908409bc4d6e.png\"/></p>\n<p>结构包括：</p>\n<ul><li>计算机硬件：例如CPU、内存、磁盘等</li><li>系统内核：所有Linux发行版的内核都是Linux，例如CentOS、Ubuntu、Fedora等。内核可以与计算机硬件交互，对外提供<strong>内核指令</strong>，用于操作计算机硬件。</li><li>系统应用：操作系统本身提供的应用、函数库。这些函数库是对内核指令的封装，使用更加方便。</li></ul>\n<p>应用于计算机交互的流程如下：</p>\n<p>1）应用调用操作系统应用（函数库），实现各种功能</p>\n<p>2）系统函数库是对内核指令集的封装，会调用内核指令</p>\n<p>3）内核指令操作计算机硬件</p>\n<p>Ubuntu和CentOSpringBoot都是基于Linux内核，无非是系统应用不同，提供的函数库有差异：</p>\n<p><img alt=\"\" src=\"image\\e4a61f3af8757a0c06538099d322d25c.png\"/></p>\n<p>此时，如果将一个Ubuntu版本的MySQL应用安装到CentOS系统，MySQL在调用Ubuntu函数库时，会发现找不到或者不匹配，就会报错了：</p>\n<p><img alt=\"\" src=\"image\\d92f38ba5e19454ad79195076ffe9bda.png\"/></p>\n<p>Docker如何解决不同系统环境的问题？</p>\n<ul><li>Docker将用户程序与所需要调用的系统(比如Ubuntu)函数库一起打包</li><li>Docker运行到不同操作系统时，直接基于打包的函数库，借助于操作系统的Linux内核来运行</li></ul>\n<p>如图：</p>\n<p><img alt=\"\" src=\"image\\bafbbbab6c1206fbeed6fc0ea03932cd.png\"/></p>\n<h3><a id=\"114_76\"></a>1.1.4.小结</h3>\n<p>Docker如何解决大型项目依赖关系复杂，不同组件依赖的兼容性问题？</p>\n<ul><li>Docker允许开发中将应用、依赖、函数库、配置一起<strong>打包</strong>，形成可移植镜像</li><li>Docker应用运行在容器中，使用沙箱机制，相互<strong>隔离</strong></li></ul>\n<p>Docker如何解决开发、测试、生产环境有差异的问题？</p>\n<ul><li>Docker镜像中包含完整运行环境，包括系统函数库，仅依赖系统的Linux内核，因此可以在任意Linux操作系统上运行</li></ul>\n<p>Docker是一个快速交付应用、运行应用的技术，具备下列优势：</p>\n<ul><li>可以将程序及其依赖、运行环境一起打包为一个镜像，可以迁移到任意Linux操作系统</li><li>运行时利用沙箱机制形成隔离容器，各个应用互不干扰</li><li>启动、移除都可以通过一行命令完成，方便快捷</li></ul>\n<h3><a id=\"12DockerhttpswwwzhihucomsearchqE8999AE68B9FE69CBAsearch_sourceEntityhybrid_search_sourceEntityhybrid_search_extra7B22sourceType223A22answer222C22sourceId223A24907481047D__93\"></a>1.2.Docker和<a href=\"https://www.zhihu.com/searchq=%E8%99%9A%E6%8B%9F%E6%9C%BA&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2490748104%7D\" title=\"虚拟机\">虚拟机</a>的区别</h3>\n<p>Docker可以让一个应用在任何操作系统中非常方便的运行。而以前我们接触的虚拟机，也能在一个操作系统中，运行另外一个操作系统，保护系统中的任何应用。</p>\n<p>两者有什么差异呢？</p>\n<p><strong>虚拟机</strong>（virtual machine）是在操作系统中<strong>模拟</strong>硬件设备，然后运行另一个操作系统，比如在 Windows 系统里面运行 Ubuntu 系统，这样就可以运行任意的Ubuntu应用了。</p>\n<p><strong>Docker</strong>仅仅是封装函数库，并没有模拟完整的操作系统，如图：</p>\n<p><img alt=\"\" src=\"image\\41b734c347c0377bb7bd9878db3dbe36.png\"/></p>\n<p>对比来看：</p>\n<p><img alt=\"\" src=\"image\\c35a1d84a9054df81213485e623018aa.png\"/></p>\n<p>小结：</p>\n<p>Docker和虚拟机的差异：</p>\n<ul><li>docker是一个系统进程；虚拟机是在操作系统中的操作系统</li><li>docker体积小、启动速度快、性能好；虚拟机体积大、启动速度慢、性能一般</li></ul>\n<h3><a id=\"13Docker_116\"></a>1.3.Docker架构</h3>\n<h3><a id=\"131_118\"></a>1.3.1.镜像和容器</h3>\n<p>Docker中有几个重要的概念：</p>\n<p><strong>镜像（Image）</strong>：Docker将应用程序及其所需的依赖、函数库、环境、配置等文件打包在一起，称为镜像。</p>\n<p><strong>容器（Container）</strong>：镜像中的应用程序运行后形成的进程就是<strong>容器</strong>，只是Docker会给容器进程做隔离，对外不可见。</p>\n<p>一切应用最终都是代码组成，都是硬盘中的一个个的字节形成的<strong>文件</strong>。只有运行时，才会加载到内存，形成进程。</p>\n<p>而<strong>镜像</strong>，就是把一个应用在硬盘上的文件、及其运行环境、部分系统函数库文件一起打包形成的文件包。这个文件包是只读的。</p>\n<p><strong>容器</strong>呢，就是将这些文件中编写的程序、函数加载到内存中允许，形成进程，只不过要隔离起来。因此一个镜像可以启动多次，形成多个容器进程。</p>\n<p><img alt=\"\" src=\"image\\c4dca3495a2b639464149f7c5e6d7c7f.png\"/></p>\n<p>例如你下载了一个QQ，如果我们将QQ在磁盘上的运行<strong>文件</strong>及其运行的操作系统依赖打包，形成QQ镜像。然后你可以启动多次，双开、甚至三开QQ，跟多个妹子聊天。</p>\n<h3><a id=\"132DockerHub_136\"></a>1.3.2.DockerHub</h3>\n<p>开源应用程序非常多，打包这些应用往往是重复的劳动。为了避免这些重复劳动，人们就会将自己打包的应用镜像，例如Redis、MySQL镜像放到网络上，共享使用，就像GitHub的代码共享一样。</p>\n<ul><li>DockerHub：DockerHub是一个官方的Docker镜像的托管平台。这样的平台称为Docker Registry。</li><li>国内也有类似于DockerHub 的公开服务，比如<a href=\"https://link.zhihu.com/target=https%3A//c.163yun.com/hub\" title=\"网易云镜像服务\">网易云镜像服务</a>、<a href=\"https://link.zhihu.com/target=https%3A//cr.console.aliyun.com/\" title=\"阿里云镜像库\">阿里云镜像库</a>等。</li></ul>\n<p>我们一方面可以将自己的镜像共享到DockerHub，另一方面也可以从DockerHub拉取镜像：</p>\n<p><img alt=\"\" src=\"image\\602f9a90b8b811d434a9cdbb8e807757.png\"/></p>\n<h3><a id=\"133Docker_147\"></a>1.3.3.Docker架构</h3>\n<p>我们要使用Docker来操作镜像、容器，就必须要安装Docker。</p>\n<p>Docker是一个CS架构的程序，由两部分组成：</p>\n<ul><li>服务端(server)：Docker守护进程，负责处理Docker指令，管理镜像、容器等</li><li><a href=\"https://www.zhihu.com/searchq=%E5%AE%A2%E6%88%B7%E7%AB%AF&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2490748104%7D\" title=\"客户端\">客户端</a>(client)：通过命令或RestAPI向Docker服务端发送指令。可以在本地或远程向服务端发送指令。</li></ul>\n<p>如图：</p>\n<p><img alt=\"\" src=\"image\\db2ded933474d20de63f65402a76f939.png\"/></p>\n<h3><a id=\"134_160\"></a>1.3.4.小结</h3>\n<p>镜像：</p>\n<ul><li>将应用程序及其依赖、环境、配置打包在一起</li></ul>\n<p>容器：</p>\n<ul><li>镜像运行起来就是容器，一个镜像可以运行多个容器</li></ul>\n<p>Docker结构：</p>\n<ul><li>服务端：接收命令或远程请求，操作镜像或容器</li><li>客户端：发送命令或者请求到Docker服务端</li></ul>\n<p>DockerHub：</p>\n<ul><li>一个镜像托管的服务器，类似的还有阿里云镜像服务，统称为DockerRegistry1.4.安装Docker</li></ul>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}