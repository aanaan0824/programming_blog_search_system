{"blogid": "126686318", "writerAge": "码龄1年", "writerBlogNum": "111", "writerCollect": "557", "writerComment": "668", "writerFan": "1102", "writerGrade": "5级", "writerIntegral": "2377", "writerName": "逆风飞翔的小叔", "writerProfileAdress": "writer_image\\profile_126686318.jpg", "writerRankTotal": "7913", "writerRankWeekly": "1819", "writerThumb": "504", "writerVisitNum": "558621", "blog_read_count": "1662", "blog_time": "于 2022-09-04 14:36:42 发布", "blog_title": "springboot 整合使用redis发布订阅功能", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h1>前言</h1>\n<p></p>\n<p>发布订阅作为一种设计思想在很多开源组件中都有体现，比如大家熟知的消息中间件等，可谓把发布订阅这一思想体现的淋漓尽致了；</p>\n<p></p>\n<h1>一、redis发布订阅简介</h1>\n<p></p>\n<p>Redis发布订阅（pub/sub）是一种消息通信模式：发送者（pub）发送消息，订阅者（sub）接收信息。可以参考下面两张图进行理解。</p>\n<p><img alt=\"\" height=\"715\" src=\"image\\c4b98739aa344f7eae072e739292c835.png\" width=\"1200\"/></p>\n<p> </p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\82246180baee49078bcff25b177588ab.jpeg\"/></p>\n<p></p>\n<h1>二、几个核心概念解释</h1>\n<p></p>\n<h2>1.频道</h2>\n<p></p>\n<p>频道（channel）类似于一个快递柜，快递员往里面放快递，收件人去里面取快递。管道（channel）是由中间件（redis）提供的，一个redisServer中有多个channel。</p>\n<p></p>\n<h2>2、消息发布者</h2>\n<p></p>\n<p>可以理解为消息的生产者，消息发布者通过中间件（redis、mq等）向某个频道（管道）发送消息。</p>\n<p></p>\n<h2>3、消息接收者 </h2>\n<p></p>\n<p>也可以理解为消息消费者，消息接收者通过订阅某个频道（管道）来接收发布者发布的消息。</p>\n<p></p>\n<blockquote>\n<p>发布者无需关心是否有人接收消息，发布者只需要把消息发布到某个管道中即可；</p>\n</blockquote>\n<p></p>\n<h1>三、适用场景</h1>\n<p></p>\n<p>1、核心业务完成后，非核心业务需要记录日志，发邮件，发短信之类的操作，一般来说，通过这种方式，核心业务与非核心业务起到了一个解耦的作用；</p>\n<p></p>\n<p>2、事件订阅，比如订阅UP主，博主相关的消息等；</p>\n<p></p>\n<p>3、监听事件，比如在分布式微服务场景下，当应用A的某个数据发生变化时，应用B需要同步更新自己的数据做自身业务操作，对于应用A来说并不关心哪个应用，就可以通过这种方式实现；</p>\n<p></p>\n<p></p>\n<h1>四、与springboot的整合</h1>\n<p></p>\n<h3>1、导入基础依赖</h3>\n<p></p>\n<pre><code class=\"language-java\">        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;\n        &lt;/dependency&gt;</code></pre>\n<p></p>\n<h3>2、配置文件</h3>\n<p></p>\n<pre><code class=\"language-java\">spring:\n  datasource:\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql://IP:3306/school?autoReconnect=true&amp;useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=GMT%2B8&amp;useSSL=false\n    username: root\n    password: root\n    druid:\n      max-active: 100\n      initial-size: 10\n      max-wait: 60000\n      min-idle: 5\n\n  redis:\n    host: localhost\n    port:  6379\n\n  cache:\n    type: redis</code></pre>\n<p></p>\n<h3>3、自定义RedisSubConfig</h3>\n<p></p>\n<p>往容器（RedisMessageListenerContainer）内添加<strong>消息监听器，</strong>注意，container的参数列表是可以传多个监听器的，但是要<strong>定义监听器的bean</strong>。在<strong>定义监听器</strong>的方法体内绑定消息<strong>处理器</strong>和<strong>管道（channel），</strong>一个监听器可以监听多个管道，可以通过数组或者添加多个channel的方式定义；</p>\n<p></p>\n<pre><code class=\"language-java\">import org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.data.redis.connection.RedisConnectionFactory;\nimport org.springframework.data.redis.listener.ChannelTopic;\nimport org.springframework.data.redis.listener.RedisMessageListenerContainer;\n\n@Configuration\npublic class RedisSubConfig {\n\n    @Bean\n    public RedisMessageListenerContainer container(RedisConnectionFactory factory, RedisMessageListener listener) {\n        RedisMessageListenerContainer container = new RedisMessageListenerContainer();\n        container.setConnectionFactory(factory);\n        //订阅频道redis.news 和 redis.life  这个container 可以添加多个 messageListener\n        container.addMessageListener(listener, new ChannelTopic(\"redis.user\"));\n        //container.addMessageListener(listener, new ChannelTopic(\"redis.news\"));\n        return container;\n    }\n\n}</code></pre>\n<p></p>\n<h3>4、自定义消息监听器</h3>\n<p></p>\n<p><strong>需要实现MessageListener 接口，</strong>重写里面的onMessage方法，方法体内需要创建一个MessageListenerAdapter（这是一种规范写法，用于绑定消息处理器和监听器）。</p>\n<p></p>\n<p>这种写法和很多消息中间件对应的API很相似，即通过一个监听的代码块来完成监听到消息后具体的业务操作；</p>\n<p></p>\n<pre><code class=\"language-java\">import org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.data.redis.connection.Message;\nimport org.springframework.data.redis.connection.MessageListener;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class RedisMessageListener implements MessageListener {\n\n    @Autowired\n    private RedisTemplate redisTemplate;\n\n    @Override\n    public void onMessage(Message message, byte[] pattern) {\n\n        // 获取消息\n        byte[] messageBody = message.getBody();\n        // 使用值序列化器转换\n        Object msg = redisTemplate.getValueSerializer().deserialize(messageBody);\n        // 获取监听的频道\n        byte[] channelByte = message.getChannel();\n        // 使用字符串序列化器转换\n        Object channel = redisTemplate.getStringSerializer().deserialize(channelByte);\n        // 渠道名称转换\n        String patternStr = new String(pattern);\n        System.out.println(patternStr);\n        System.out.println(\"---频道---: \" + channel);\n        System.out.println(\"---消息内容---: \" + msg);\n    }\n}</code></pre>\n<p></p>\n<h3>5、redistemplate的序列化</h3>\n<p></p>\n<pre><code class=\"language-java\">    @Bean\n    public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory) {\n        RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;&gt;();\n        template.setConnectionFactory(connectionFactory);\n        //使用Jackson2JsonRedisSerializer来序列化和反序列化redis的value值\n        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);\n        ObjectMapper mapper = new ObjectMapper();\n        mapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);\n        mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);\n        jackson2JsonRedisSerializer.setObjectMapper(mapper);\n        template.setValueSerializer(jackson2JsonRedisSerializer);\n        //使用StringRedisSerializer来序列化和反序列化redis的key值\n        template.setKeySerializer(new StringRedisSerializer());\n        template.afterPropertiesSet();\n        return template;\n    }</code></pre>\n<p></p>\n<h3>6、功能测试</h3>\n<p></p>\n<p>下面写一个测试的接口，模拟业务处理完毕后，向 redis.user 这个通道发送一条消息，看看监听器中是否能够正常接收到消息即可；</p>\n<p></p>\n<pre><code class=\"language-java\">@RestController\npublic class RedisPubController {\n\n    @Autowired\n    private RedisTemplate redisTemplate;\n\n    @GetMapping(\"/getUserById\")\n    public String getUserById(String userId){\n        //TODO 执行主业务\n        redisTemplate.convertAndSend(\"redis.user\", userId);\n        return \"hello:\" + userId;\n    }\n\n}</code></pre>\n<p></p>\n<p>启动工程后调用接口：</p>\n<blockquote>\n<p><a href=\"http://localhost:8083/getByUserIdId?id=1\" title=\"http://localhost:8083/getByUserIdId?userId=1\">http://localhost:8083/getByUserIdId?userId=1</a></p>\n</blockquote>\n<p></p>\n<p>通过断点可以观察发现，通道中的消息被监听器逻辑监听到了，接下来就可以愉快的处理自己的业务了；</p>\n<p></p>\n<p><img alt=\"\" height=\"550\" src=\"image\\a8da46e68b3d4db481e5cefdd0b4c8da.png\" width=\"1054\"/></p>\n<p> </p>\n<p>本篇通过案例演示了如何基于springboot整合使用redis的发布订阅功能，更多的细节需要结合实际的开发场景进行完善，本篇到此结束，最后感谢观看！</p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n</div>\n</div>"}