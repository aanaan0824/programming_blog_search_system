{"blogid": "126743305", "writerAge": "码龄24天", "writerBlogNum": "52", "writerCollect": "0", "writerComment": "1", "writerFan": "131", "writerGrade": "3级", "writerIntegral": "520", "writerName": "web15635271136", "writerProfileAdress": "writer_image\\profile_126743305.jpg", "writerRankTotal": "39013", "writerRankWeekly": "8556", "writerThumb": "0", "writerVisitNum": "2513", "blog_read_count": "9", "blog_time": "于 2022-09-07 12:42:58 发布", "blog_title": "Jvm 内存模型", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p><strong>目录</strong></p>\n<p><a href=\"#%E4%B8%80%E3%80%81%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B\">一、内存模型</a></p>\n<p><a href=\"#1.jvm%E7%BA%BF%E7%A8%8B\">1.jvm线程</a></p>\n<p><a href=\"#2.%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88\">2.虚拟机栈</a></p>\n<p><a href=\"#1.%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8\">1.局部变量表</a></p>\n<p><a href=\"#%E2%80%8B%C2%A02.%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88\">?</a></p>\n<p><a href=\"#%C2%A02.%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88\">?2.操作数栈</a></p>\n<p><a href=\"#3.%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5\">3.动态链接</a></p>\n<p><a href=\"#4.%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80\">4.方法返回地址</a></p>\n<p><a href=\"#5.%E4%B8%80%E4%BA%9B%E9%99%84%E5%8A%A0%E4%BF%A1%E6%81%AF%C2%A0\">5.一些附加信息?</a></p>\n<p><a href=\"#2.%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8\">3.程序计数器</a></p>\n<p><a href=\"#4.%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88\">4.本地方法栈</a></p>\n<p><a href=\"#5.%E5%A0%86\">5.堆</a></p>\n<p><a href=\"#%E5%AE%9A%E4%B9%89\">定义</a></p>\n<p><a href=\"#%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D\">对象分配</a></p>\n<p><a href=\"#%E8%AE%BE%E7%BD%AE%E5%A4%A7%E5%B0%8F\">?设置参数</a></p>\n<p><a href=\"#TLAB\">TLAB</a></p>\n<p><a href=\"#%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8BGC\">GC</a></p>\n<p><a href=\"#%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90\">逃逸分析</a></p>\n<p><a href=\"#6.%E6%96%B9%E6%B3%95%E5%8C%BA\">6.方法区</a></p>\n<p><a href=\"#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0\">字符串常量池</a></p>\n<p><a href=\"#intern%E4%BD%BF%E7%94%A8%C2%A0\">intern使用?</a></p>\n<p><a href=\"#7.%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%C2%A0\">7.执行引擎?</a></p>\n<hr/>\n<p>--------------------------------------------------------------------------------------------------------------------------------</p>\n<h1><a id=\"_52\"></a>一、内存模型</h1>\n<h2><a id=\"1jvm_55\"></a>1.jvm线程</h2>\n<p>内存是非常重要的系统资源,是硬盘和CPU的中间仓库及桥梁,承载着操作系统和应用程序的实时运行。JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略,保证了JVM的高效稳定运行。不同的JVM对于内存的划分方式和管理机制存在着部分差异。</p>\n<p><img alt=\"\" src=\"image\\78388b595914415b8ea761aa77d6ac26.png\"/></p>\n<p>Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区,其中有一些会随着虚拟机启动而创建,随着虚拟机退出而销毁。另外一些则是与线程一一对应的,这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。</p>\n<ul><li>每个线程:独立包括程序计数器、栈、本地栈</li><li>线程间共享:堆、堆外内存(永久代或元空间、代码缓存)</li><li>线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行</li><li>在Hotspot JVM里,每个线程都与操作系统的本地线程直接映射。个Java线程准备好执行以后,此时一个操作系统的本地线程也同时创建。Java线程执行终止后,本地线程也会回收。</li><li>操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功,它就会调用Java线程中的run()方法</li></ul>\n<p><strong>jvm线程</strong></p>\n<p>如果你使用 jconsole或者是任何一个调试工具,都能看到在后台有许多线程在运行。这些后台线程不包括调用 public static void main( string[]args)的main线程以及所有这个maih线程自己创建的线程。这些主要的后台系统线程在 Hotspot J里主要是以下几个：</p>\n<ul><li><strong>虚拟机线程</strong>:这种线程的操作是需要达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点,这样堆才不会变化。这种线程的执行类型包括〃stop-the-world\"的垃圾收集,线程栈收集,线程挂起以及偏向锁撤销。</li><li><strong>周期任务线程</strong>:这种线程是时间周期事件的体现(比如中断),他们一般用于周期性操作的调度执行。</li><li><strong>GC线程</strong>:这种线程对在JVM里不同种类的垃圾收集行为提供了支持。</li><li><strong>编译线程</strong>:这种线程在运行时会将字节码编译成到本地代码。</li><li><strong>信号调度线程</strong>:这种线程接收信号并发送给jvm,在它内部通过调用适当的方法进行处理。</li></ul>\n<h2><a id=\"2_80\"></a>2.虚拟机栈</h2>\n<p><img alt=\"\" src=\"image\\3de20a5e52844560b21ed300f7a6438e.png\"/></p>\n<p><strong>Java虚拟机栈是什么</strong></p>\n<ul><li>Java虚拟机栈( Java virtual Machine stack),早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈,其内部保存一个个的栈帧( Stack frame),对应着一次次的Java方法调用。</li><li>是线程私有的</li></ul>\n<p>每个栈帧中存储着:</p>\n<ul><li>局部变量表(Local Variab1es)</li><li>操作数栈( Operand stack)(或表达式栈)</li><li>动态链接( Dynamic Linking)(或指向运行时常量池的方法引用)</li><li>方法返回地址( Return address)(或方法正常退出或者异常退出的定义)</li><li>一些附加信息</li></ul>\n<p><strong>生命周期</strong></p>\n<ul><li>生命周期和线程一致。</li></ul>\n<p><strong>作用</strong></p>\n<ul><li>主管Java程序的运行,它保存方法的局部变量、部分结果,并参与方法的调用和返回。</li></ul>\n<p><strong>说明</strong></p>\n<ul><li>栈是运行时的单位,而堆是存储的单位。</li></ul>\n<p><strong>栈的特点(优点)</strong></p>\n<ul><li>栈是一种快速有效的分配存储方式,访问速度仅次于程序计数器。</li><li>JVM直接对Java栈的操作只有两个：1.每个方法执行,伴随着进栈(入栈、压栈)，2.执行结束后的出栈工作</li><li>对于栈来说不存在垃圾回收问题</li></ul>\n<p><strong>栈可能出现的异常</strong></p>\n<ul><li>如果釆用固定大小的Java虚拟机栈,那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量,Java虚拟机将会抛出一个StackOverFlowError异常。</li><li>如果Java虚拟机栈可以动态扩展,并且在尝试扩展的时候无法中请到足够的内存,或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈,那Java虚拟机将会抛出一个 OutOfMemoryError异常。</li><li>使用参数-Xss选项来设置线程的最大栈空间,栈的大小直接决定了函数调用的最大可达深度。</li></ul>\n<p>举例：</p>\n<pre><code>public class Test1 {\n    static int i=0;\n    public static void main(String[] args) {\n        test();\n    }\n    public static void test(){\n        System.out.println(++i);\n        test();\n    }\n}\n</code></pre>\n<p>JVM参数：</p>\n<pre><code>-Xss512K -XX:+PrintFlagsFinal\n</code></pre>\n<p><img alt=\"\" src=\"image\\330964ddf4194d0ca3314397801ee7e7.png\"/><img alt=\"\" src=\"image\\bca2680e0b5f4256813fcd0c26f898f6.png\"/></p>\n<p>执行了5074次</p>\n<p><img alt=\"\" src=\"image\\047eabe310fb4a45bd2e44d2429d274f.png\"/></p>\n<p>-Xss修改为256K 执行了2331次</p>\n<p><strong>栈运行原理</strong></p>\n<ul><li>不同线程中所包含的栈是不允许存在相互引用的,即不可能在一个栈帧之中引用另外一个线程的栈帧。</li><li>如果当前方法调用了其他方法,方法返回之际,当前栈帧会传回此方法的执行结果给前一个栈帧,接着,虚拟机会丢弃当前栈帧,使得前一个栈帧重新成为当前栈帧。</li><li>Java方法有两种返回函数的方式,一种是正常的函数返回,使用 return指令;另外一种是抛岀异常。不管使用哪种方式,都会导致栈帧被弹出。</li></ul>\n<h3><a id=\"1_153\"></a>1.局部变量表</h3>\n<ul><li>局部变量表也被称之为局部变量数组或本地变量表</li><li>定义为一个数字数组,主要用于存储方法参数和定义在方法体内的局部变量，这些数据类型包括各类基本数据类型、对象引用( reference),以及returnAddress类型。</li><li>由于局部变量表是建立在线程的栈上,是线程的私有数据,因此不存在数据安全问题</li><li>局部变量表所需的容量大小是在编译期确定下来的,并保存在方法的code属性的 maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的</li><li>方法嵌套调用的次数由栈的大小决定。一般来说,栈越大,方法嵌套调用次数越多。对一个函数而言,它的参数和局部变量越多,使得局部变量表膨胀,它的栈帧就越大,以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间,导致其嵌套调用次数就会减少。</li><li>局部变量表中的变量只在当前方法调用中有效。在方法执行时,虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后,随着方法栈帧的销毁,局部变量表也会随之销毁。</li></ul>\n<p><strong>补充说明：</strong></p>\n<ul><li>在栈帧中,与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时,虚拟机使用局部变量表完成方法的传递。</li><li>局部变量表中的变量也是重要的垃圾回收根节点,只要被局部变量表中直接或间接引用的对象都不会被回收。</li></ul>\n<p><strong>slot变量槽</strong></p>\n<p>局部变量表,最基本的存储单元是slot</p>\n<ul><li>byte、 short、char在存储前被转换为int, boolean也被转换为int,0表示false,非0表示true。</li><li>long和 double则占据两个solt</li></ul>\n<p>请看下面的示例使用jclasslib插件查看，序号0为this，序号1double占两个 3开始是long</p>\n<pre><code>public class Test3 {\n    public void localvarl() {\n        double c=0;\n        long f=0;\n        byte a=0;\n        int b=0;\n        boolean d=false;\n        float e=0f;\n        char g=0;\n    }\n}\n</code></pre>\n<p><img alt=\"\" src=\"image\\6edada1fd8b243c0b9bdddc98a00c0e9.png\"/></p>\n<p><strong>slot重复利用</strong></p>\n<pre><code>public class Test3 {\n    public void localvarl() {\n        int a = 0;\n        System.out.println(a);\n        int b = 0;\n    }\n    public void localvarl1() {\n        {\n            int a = 0;\n            System.out.println(a);\n        }\n        int b = 0;\n    }\n}\n</code></pre>\n<h3><a id=\"httpsimgblogcsdnimgcnd2e0d4b6b2d1457ba32175b595c54cc4pngxossprocessimagewatermarktype_d3F5LXplbmhlaQshadow_50text_Q1NETiBA5LiJ56yg54i3size_20color_FFFFFFt_70g_sex_16_207\"></a><img alt=\"\" src=\"image\\d2e0d4b6b2d1457ba32175b595c54cc4.png\"/></h3>\n<p><img alt=\"\" src=\"image\\06f724e48a4d42da9c6b6d0cf114c4ef.png\"/></p>\n<h3><a id=\"2_211\"></a>2.操作数栈</h3>\n<p>每一个独立的栈帧中除了包含局部变量表以外,还包含一个后进先出(Last-In- First-0ut)的操作数栈,也可以称之为表达式栈( Expression Stack)。</p>\n<p>操作数栈,主要用于保存计算过程的中间结果,同时作为计算过程中变量临时的存储空间。</p>\n<p>操作数栈就是JVM执行引擎的一个工作区,当一个方法刚开始执行的时候,一个新的栈帧也会随之被创建出来,这个方法的操作数栈是空的。</p>\n<p>每一个操作数栈都会拥有一个明确的栈深度用于存储数值,其所需的最大深度在编译期就定义好了</p>\n<p>操作数栈,在方法执行过程中,根据字节码指令,往栈中写入数据或提取数据,即入栈(push)/出栈(pop)。</p>\n<ul><li>某些字节码指令将值压入操作数栈,其余的字节码指令将操作数出栈。使用它们后再把结果压入栈</li><li>比如:执行复制、交换、求和等操作</li></ul>\n<p>举例：</p>\n<ol><li> <p>iconst_1读取（入栈）pc寄存器0 ，istore_1(出栈)放到局部变量表pc寄存器1</p> </li><li> <p>iconst_2读取（入栈）pc寄存器2 ，istore_2(出栈)放到局部变量表pc寄存器3</p> </li><li> <p>iload_1 pc寄存器4、iload_2 pc寄存器5读取局部变量表 1,2的值</p> </li><li> <p>iaddpc寄存器6出栈计算结果放回操作数栈</p> </li><li> <p>istore_3 pc寄存器7将结果出栈存储到局部变量表</p> <p>public class Test4 {<!-- --><br/> public void test4(){<!-- --><br/> int i=1;<br/> int j=2;<br/> int c=i+j;<br/> }<br/> }</p> </li></ol>\n<p><img alt=\"\" src=\"image\\dc521bae5ab8443896fa60ac4f7808b3.png\"/></p>\n<p><strong>栈顶缓存技术</strong></p>\n<p>由于操作数是存储在内存中的,因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题, Hotspot JVM的设计者们提出了栈顶缓存(ToS,Top-of- Stack Cashing)技术,将栈顶元素全部缓存在物理CPU的寄存器中,以此降低对内存的读/写次数,提升执行引擎的执行效率。</p>\n<h3><a id=\"3_248\"></a>3.动态链接</h3>\n<p>每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接( Dynamic Linking)。比如: invokedynamic指令在Java源文件被编译到字节码文件中时,所有的变量和方法引用都作为符号引用( Symbolic Reference)保存在 class文件的常量池里。比如:描述一个方法调用了另外的其他方法时,就是通过常量池中指向方法的符号引用来表示的,那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。</p>\n<h3><a id=\"4_252\"></a>4.方法返回地址</h3>\n<p>方法退出后都返回到该方法被调用的位置,存放调用该方法的pc寄存器的值。</p>\n<p>一个方法的结束,有两种方式:</p>\n<ul><li>正常执行完成：调用该方法的指令的下一条指令的地址</li><li>非正常退出(异常)：返回地址是要通过异常表来确定,栈帧中一般不会保存这部分信息</li></ul>\n<p><img alt=\"\" src=\"image\\50c929aff61d4d849d8458f4268a56d1.png\"/></p>\n<h3><a id=\"5_263\"></a>5.一些附加信息</h3>\n<p>栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如,对程序调试提供支持的信息。</p>\n<h2><a id=\"3_267\"></a>3.程序计数器</h2>\n<ul><li>它是一块很小的内存空间,几乎可以忽略不记。也是运行速度最快的存储区域。</li><li>在JVM规范中,每个线程都有它自己的程序计数器,是线程私有的,生命周期与线程的生命周期保持一致。</li><li>任何时间一个线程都只有一个方法在执行,也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址;或者,如果是在执行 native方法,则是未指定值( undefned)。</li><li>它是程序控制流的指示器,分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</li><li>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</li><li>它是唯一一个在Java虚拟机规范中没有规定任何 OutOtMemoryError情况的区域。</li></ul>\n<p><strong>作用</strong>：PC寄存器用来存储指向下一条指令的地址也即将要执行的指令代码。由执行引擎读取下一条指令</p>\n<p><img alt=\"\" src=\"image\\63aeb2d38d4d44719f0b0811ea1901c7.png\"/></p>\n<p><strong>CPU时间片</strong></p>\n<p>CPU时间片即CPU分配给各个程序的时间,每个线程被分配一个时间段,称作它的时间片</p>\n<p>在宏观上:我们可以同时打开多个应用程序,每个程序并行不悖,同时运行。</p>\n<p>在微观上:由于只有一个CPU,一次只能处理程序要求的一部分如何处理公平,一种方法就是引入时间片,每个程序轮流执行。</p>\n<p><strong>常见问题：</strong></p>\n<p>PC寄存器为什么会被设定为线程私有</p>\n<ul><li>我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法,CPU会不停地做任务切换,这样必然导致经常中断或恢复,如何保证分毫无差呢为了能够准确地记录各个线程正在执行的当前字节码指令地址,最好的办法自然是为每一个线程都分配一个PC寄存器,这样一来各个线程之间便可以进行独立计算,从而不会出现相互干扰的情况。</li><li>由于CPU时间片轮限制,众多线程在并发执行过程中,任何一个确定的时刻,一个处理器或者多核处理器中的一个内核,只会执行某个线程中的一条指令。</li><li>这样必然导致经常中断或恢复,如何保证分毫无差呢每个线程在创建后,都会产生自己的程序计数器和栈帧,程序计数器在各个线程之间互不影响。</li></ul>\n<p><strong>举例：</strong></p>\n<p><img alt=\"\" src=\"image\\5ce4dfc908a440bf9cf48a3185d817e8.png\"/></p>\n<h2><a id=\"4_301\"></a>4.本地方法栈</h2>\n<p><img alt=\"\" src=\"image\\531e510410894c759104c62fa1a82fdf.png\"/></p>\n<p><strong>本地方法接口</strong></p>\n<p>简单地讲,一个 Native Method就是一个Java调用非Java代码的接口。一个Native method是这样一个Java方法:该方法的实现由非Java语言实现,比如C。</p>\n<p><strong>本地方法栈</strong></p>\n<p>本地方法栈用于管理本地方法的调用。是线程私有的</p>\n<p>如果线程请求分配的栈容量超过本地方法栈允许的最大容量,Java虚拟机将会抛出一个 StackOverflowError异常。</p>\n<p>如果本地方法栈可以动态扩展,并且在尝试扩展的时候无法申请到足够的内存,或者在创建新的线程时没有足够的内存去创建对应的本地方法栈,那么Java虚拟机将会抛出一个 outofmemoryerror异常。</p>\n<h2><a id=\"5_318\"></a>5.堆</h2>\n<h3><a id=\"_321\"></a><strong>定义</strong></h3>\n<ul><li>一个JVM实例只存在一个堆内存,堆也是Java内存管理的核心区域。</li><li>《Java虚拟机规范》中对Java堆的描述是:所有的对象实例以及数组都应在运行时分配在堆上。</li><li>数组和对象可能永远不会存储在栈上,因为栈帧中保存引用,这个引用指向对象或者数组在堆中的位置。</li><li>在方法结束后,堆中的对象不会马上被移除,仅仅在垃圾收集的时候才会被移除.</li><li>堆,是GC( Garbage Collection,垃圾收集器)执行垃圾回收的重点区域。</li></ul>\n<h3><a id=\"_329\"></a>对象分配</h3>\n<p>针对不同年龄段的对象分配原则如下所示:</p>\n<ul><li>优先分配到Eden</li><li>如果对象在Eden出生并经过第一次 Minor GC后仍然存活,并且能被 Survivor容纳的话,将被移动到 Survivor空间中,并将对象年龄设为1。对象在Survivor区中每熬过一次 Minor GC,年龄就增加1岁,当它的年龄增加到一定程度(默认为15岁,其实每个JVM、每个GC都有所不同)时,就会被晋升到老年代中</li><li>大对象直接分配到老年代,尽量避免程序中出现过多的大对象</li><li>长期存活的对象分配到老年代</li><li>动态对象年龄判断如果 Survivor区中相同年龄的所有对象大小的总和大于 Survivor空间的一半,年龄大于或等于该年龄的对象可以直接进入老年代,无须等到MaxtenuringThreshold中要求的年龄</li></ul>\n<p><img alt=\"\" src=\"image\\be6b7ee06c424d03bddeac3aff56f690.png\"/></p>\n<p>示例：</p>\n<p>借助jvisualvm 的visual gc可以看到 eden、s0、s1、old区的分配情况，通过修改byte[]数组大小可以让其分配不同方式，可能进入eden区，可能直接进入old区</p>\n<pre><code>public class Test6 {\n    byte[] buffer = new byte[1024 * 1024*1];\n\n    public static void main(String[] args) {\n        ArrayList&lt;Test6&gt; list = new ArrayList&lt;&gt;();\n        while (true){\n            list.add(new Test6());\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n        }\n    }\n}\n</code></pre>\n<p><img alt=\"\" src=\"image\\5addf895e559403a91bdd3836438ef1e.png\"/></p>\n<h3><a id=\"_364\"></a>设置参数</h3>\n<p>官网地址：<a href=\"https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html\" title=\"https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html\">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html</a></p>\n<p><img alt=\"\" src=\"image\\a41207fd9aa34069880dfb49dbb8c02e.png\"/></p>\n<ul><li>默认-XX: NewRatio=2,表示新生代占1,老年代占2,新生代占整个堆的1/3</li><li>可以修改-XX: NewRatio=4,表示新生代占1,老年代占4,新生代占整个堆的1/5</li><li>Eden空间和 Survivor空间缺省所占的比例是8:1:1 可以通过“-XX: SurvivorRatio”调整这个空间比例。比如-x: Survivorratio=8</li></ul>\n<p><img alt=\"\" src=\"image\\55af7c9c7db54abc81cbc897fc4ef71c.png\"/></p>\n<p><img alt=\"\" src=\"image\\f8fa6841306348be934b8724e463739a.png\"/></p>\n<p><strong>空间担保</strong></p>\n<p>在发生<strong>Minor GC</strong>之前，虚拟机会检查<strong>老年代最大可用的连续空间</strong>是否<strong>大于新生代所有对象的总空间</strong>，如果大于，则此次<strong>Minor GC是安全的</strong>，如果小于，则虚拟机会查看<strong>HandlePromotionFailure</strong>设置值是否允许担保失败。如果HandlePromotionFailure=true，那么会继续检查老年代最大可用连续空间是否大于<strong>历次晋升到老年代的对象的平均大小</strong>，如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；如果小于或者HandlePromotionFailure=false，则改为进行一次Full GC。</p>\n<h3><a id=\"TLAB_382\"></a>TLAB</h3>\n<p><img alt=\"\" src=\"image\\4b04039bc6a340aab37f49eeebc463c5.png\"/></p>\n<p><img alt=\"\" src=\"image\\7aac640e9fe042fd8e20f6d5d9d4e875.png\"/></p>\n<p><strong>为什么有TLAB</strong></p>\n<ul><li>堆区是线程共享区域,任何线程都可以访问到堆区中的共享数据</li><li>由于对象实例的创建在JVM中非常频繁,因此在并发环境下从堆区中划分内存空间是线程不安全的</li><li>为避免多个线程操作同一地址,需要使用加锁等机制,进而影响分配速度。</li></ul>\n<p><strong>定义</strong></p>\n<ul><li>从内存模型而不是垃圾收集的角度,对Eden区域继续进行划分,JVM为每个线程分配了一个私有缓存区域,它包含在Eden空间内</li><li>多线程同时分配内存时,使用TLAB可以避免一系列的非线程安全问题,同时还能够提升内存分配的吞吐量,称为快速分配策略。</li><li>一旦对象在TLAB空间分配内存失败时,JVM就会尝试着通过使用加锁机制确保数据操作的原子性,从而直接在Eden空间中分配内存。</li><li>在程序中,开发人员可以通过选项“-XX: UseTLAB”设置是否开启TLAB空间。</li><li>默认情况下,TLAB空间的内存非常小,仅占有整个Eden空间的1%,当然我们可以通过选项“-XX: TLABWasteTargetPercent”设置TLAB空间所占用Eden空间的百分比大小。</li></ul>\n<h3><a id=\"GC_402\"></a><strong>GC</strong></h3>\n<p>JVM在进行GC时,并非每次都对上面三个内存(新生代、老年代;方法区)区域一起回收的,大部分时候回收的都是指新生代。<br/> 针对 Hotspot VN的实现,GC按照回收区域又分为两大种类型:一种是部分收集( PartialGC),一种是整堆收集(Full GC)<br/> 部分收集:不是完整收集整个]ava堆的垃圾收集。其中又分为:</p>\n<ul><li>新生代收集( Minor GC/ Young GC):只是新生代的垃圾收集</li><li>老年代收集( Major GC/ old GC):只是老年代的垃圾收集。目前,只有 CMS GC会有单独收集老年代的行为。ˇ注意,很多时候 Major GC会和Full GC混淆使用,需要具体分辨是老年代回收还是整堆回收。</li><li>混合收集( Mixed GC):收集整个新生代以及部分老年代的垃圾收集，目前,只有G1GC会有这种行为</li><li>整堆收集(Full GC):收集整个java堆和方法区的垃圾收集。</li></ul>\n<p><strong>年轻代GC( Minor GC)触发机制:</strong></p>\n<ul><li>当年轻代空间不足时,就会触发 Minor GC,这里的年轻代满指的是Eden代满, Survivor满不会引发GC。(每次 Minor Gc会清理年轻代的内存。)</li><li>因为Java对象大多都具备朝生夕灭的特性,所以 Minor gc非常频繁,一般回收速度也比较快。这一定义既清晰又易于理解</li><li>Minor gc会引发STW,暂停其它用户的线程,等垃圾回收结束,用户线程才恢复运行</li></ul>\n<p><strong>老年代GC( Major GC/FullGC)触发机制:</strong></p>\n<ul><li>指发生在老年代的GC,对象从老年代消失时,我们说“ Major GC”或“Fu11GC发生了。</li><li>出现了 Major GC,经常会伴随至少一次的 Minor GC(但非绝对的,在Parallel Scavenge收集器的收集策略里就有直接进行 Major GC的策略选择过程)</li><li>也就是在老年代空间不足时,会先尝试触发 Minor GC。如果之后空间还不足,则触发 Major GC</li><li>Major GC的速度一般会比 Minor gc慢10倍以上,STW的时间更长。</li></ul>\n<p><strong>触发FullGc执行的情况有如下五种:</strong></p>\n<ul><li>(1)调用 System. gc()时,系统建议执行Fu11GC,但是不必然执行</li><li>(2)老年代空间不足</li><li>(3)方法区空间不足</li><li>(4)通过 Minor GC后进入老年代的平均大小大于老年代的可用内存</li><li>(5)由Eden区、 from区向 from区复制时,对象大小大于 To Space可用内存,则把该对象转存到老年代,且老年代的可用内存小于该对象大小</li></ul>\n<p>说明:full gc是开发或调优中尽量要避免的。这样暂时时间会短一些。</p>\n<p><strong>为什么需要把Java堆分代</strong><br/> 不分代就不能正常工作了吗其实不分代完全可以,分代的唯一理由就是优化GC性能。如果没有分代,那所有的对象都在一块,就如同把一个学校的人都关在一个教室。GC的时候要找到哪些对象没用,这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的,如果分代的话,把新创建的对象放到某一地方,当GC的时候先把这块存储“朝生夕死”对象的区域进行回收,这样就会腾出很大的空间出来。</p>\n<p><img alt=\"\" src=\"image\\9249b68a2fbf43e59891130b907cd0d1.png\"/></p>\n<h3><a id=\"_441\"></a>逃逸分析</h3>\n<p>逃逸分析的基本行为就是分析对象动态作用域:</p>\n<ul><li>当一个对象在方法中被定义后,对象只在方法内部使用,则认为没有发生逃逸。</li><li>当一个对象在方法中被定义后,它被外部方法所引用,则认为发生逃逸。例如作为调用参数传递到其他地方中。</li></ul>\n<p><strong>优化</strong></p>\n<ul><li>同步省略（消除）。如果一个对象被发现只能从一个线程被访问到,那么对于这个对象的操作可以不考虑同步。</li><li>栈上分配。将堆分配转化为栈分配。如果一个对象在子程序中被分配,要使指向该对象的指针永远不会逃逸,对象可能是栈分配的候选,而不是堆分配，配合标量替换</li><li>分离对象或标量替换。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到,那么对象的部分(或全部)可以不存储在内存,而是存储在CPU寄存器中。如图：</li></ul>\n<p><img alt=\"\" src=\"image\\4827509637d14c8e819c8add56d8b885.png\"/></p>\n<p><strong>逃逸分析一定快吗？</strong></p>\n<p>无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的,这其实也是一个相对耗时的过程。<br/> 一个极端的例子,就是经过逃逸分析之后,发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</p>\n<h2><a id=\"6_461\"></a>6.方法区</h2>\n<p><img alt=\"\" src=\"image\\e930f45556484d7c90ac00809f1662fc.png\"/></p>\n<p><img alt=\"\" src=\"image\\46b5f5eac2204d29b95ad47391e4ea65.png\"/></p>\n<p>存储已被虚拟机加载的类型信息、运行时常量池、静态变量、JIT代码缓存、域(field)信息、方法信息等</p>\n<p>元空间和永久代最大区别：元空间不在虚拟机设置的内存中，而是使用本地内存</p>\n<h3><a id=\"_472\"></a>字符串常量池</h3>\n<p>字符串常量池中是不会存储相同容的字符串的。常量池是一个固定大小的 Hashtable,默认值大小长度是1009。如果放进 string非常多,就会造成Hash冲突严重，性能下降，jdk8常量池在堆中</p>\n<p>string类型的常量池比较特殊。它的主要使用方法有两种。</p>\n<ul><li>直接使用双引号声明出来的 string对象会直接存储在常量池中，比如:String info=“com”;</li><li>可以使用 string提供的intern()方法。</li></ul>\n<p><strong>字符串拼接</strong></p>\n<ul><li> <p>常量与常量的拼接结果在常量池,原理是编译期优化</p> </li><li> <p>常量池中不会存在相同内容的常量。</p> </li><li> <p>只要其中有一个是变量,结果就在堆中。变量拼接的原理是 Stringbuilder</p> </li><li> <p>如果拼接的结果调用 intern()方法,则主动将常量池中还没有的字符串对象放入池中,并返回此对象地址。</p> <p>public class Test7 {<!-- --><br/> public static void main(String[] args) {<!-- --><br/> test7();<br/> }<br/> public static void test7() {<!-- --><br/> String a=“a”+“b”+“c”;<br/> String b=“d”;<br/> String c=b+“e”;</p> <pre><code>}\n</code></pre> <p>}</p> </li></ul>\n<p><img alt=\"\" src=\"image\\2019f2fbeed74c3982ae28b4b3cbf1df.png\"/></p>\n<h3><a id=\"intern_502\"></a>intern使用</h3>\n<pre><code>public class Test8 {\n    public static void main(String[] args) {\n        test8();\n//        test8_1();\n    }\n    public static void test8() {\n        String a=new String(\"a\");\n        String intern = a.intern();\n        String a1=\"a\";\n        System.out.println(a==intern);//false\n        System.out.println(a==a1);//false\n        System.out.println(a1==intern);//true\n    }\n\n    public static void test8_1() {\n        String a=new String(\"a\")+new String(\"b\");\n        String intern = a.intern();\n        String a1=\"ab\";\n        System.out.println(a==intern);//true\n        System.out.println(a==a1);//true\n        System.out.println(a1==intern);//true\n    }\n}\n</code></pre>\n<p><img alt=\"\" src=\"image\\c7e01d5a251540b587c68f61a0107e81.png\"/></p>\n<h2><a id=\"7_530\"></a>7.执行引擎</h2>\n<p>解释器:当Java虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方式执行,将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</p>\n<p>JIT编译器:就是虚拟机将源代码直接编译成和本地机器平台相关的机器语言，在一定周期内代码被调用执行频率而定，热点代码会做jit编译进行优化</p>\n<p>现在JVM在执行Java代码的时候,通常都会将解释执行与编译执行二者结合起来进行。</p>\n<p><img alt=\"\" src=\"image\\98efc72d449c4b67af280bf58bedaa8f.png\"/></p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}