{"blogid": "124908384", "writerAge": "码龄2年", "writerBlogNum": "70", "writerCollect": "3157", "writerComment": "3023", "writerFan": "12179", "writerGrade": "6级", "writerIntegral": "8029", "writerName": "程序猿追", "writerProfileAdress": "writer_image\\profile_124908384.jpg", "writerRankTotal": "1707", "writerRankWeekly": "74", "writerThumb": "2789", "writerVisitNum": "110952", "blog_read_count": "4391", "blog_time": "已于 2022-07-12 15:18:04 修改", "blog_title": "【算法合集】深搜广搜Prim与Kruskal", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<blockquote>\n<p>✅🎡个人主页：<a href=\"https://blog.csdn.net/aasd23?spm=1000.2115.3001.5343\" title=\"程序猿追\">程序猿追</a></p>\n<p>✅🎡系列专栏：<a href=\"https://blog.csdn.net/aasd23/category_11805404.html?spm=1001.2014.3001.5482\" title=\"算法合集\">算法合集</a></p>\n<p>✅🎡目前状态：创建Java学习之路（零基础到就业实战）系列，目前更新到JAVAWEB开发</p>\n<p>✅🎡作者简介：大家好，我是程序猿追，全栈领域新星创作者，算法爱好者，常在作者周榜排名前30，某不知名的 ACMer</p>\n<p>✅🎡推荐一款刷题面试找工作三不误的网站——<a href=\"https://www.nowcoder.com/link/pc_csdncpt_cxyz_sf\" title=\"牛客网\">牛客网</a></p>\n<p>✅🎡个人名言：不积跬步无以至千里，趁年轻，使劲拼，给未来的自己一个交代！</p>\n</blockquote>\n<p></p>\n<p><strong>目录</strong></p>\n<p style=\"margin-left:0px;\"><a href=\"#%E4%B8%80%E3%80%81%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2\">一、深度优先搜索</a></p>\n<p style=\"margin-left:40px;\"><a href=\"#%F0%9F%93%B8%E5%AE%9E%E9%99%85%E9%97%AE%E9%A2%98\">📸实际问题</a></p>\n<p style=\"margin-left:0px;\"><a href=\"#%E4%BA%8C%E3%80%81%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2\">二、广度优先搜索</a></p>\n<p style=\"margin-left:40px;\"><a href=\"#%F0%9F%93%B8%E5%AE%9E%E9%99%85%E9%97%AE%E9%A2%98\">📸实际问题</a></p>\n<p style=\"margin-left:0px;\"><a href=\"#%E4%B8%89%E3%80%81prim%20%E7%AE%97%E6%B3%95\">三、prim 算法</a></p>\n<p style=\"margin-left:40px;\"><a href=\"#%F0%9F%93%B8%E5%AE%9E%E9%99%85%E9%A2%98%E7%9B%AE\">📸实际题目</a></p>\n<p style=\"margin-left:0px;\"><a href=\"#%E5%9B%9B%E3%80%81Kruskal%E7%AE%97%E6%B3%95\">四、Kruskal算法</a></p>\n<p style=\"margin-left:40px;\"><a href=\"#%F0%9F%93%B8%E5%AE%9E%E9%99%85%E9%A2%98%E7%9B%AE\">📸实际题目</a></p>\n<p style=\"margin-left:0px;\"><a href=\"#%E4%BA%94%E3%80%81%E5%B0%8F%E7%BB%93\">五、小结</a></p>\n<hr/>\n<p></p>\n<h1>一、深度优先搜索</h1>\n<blockquote>\n<p><strong>深度优先搜索（DFS）</strong>又叫深搜，我们可以这么理解，DFS 像一个很固执的一个人（不撞南墙不回头，不见黄河不死心），只要你这里有路我就一定会去走，而且一条路走到底的那种（燕子~没你我怎么活呀，开玩笑了）。</p>\n<p>我们先来看看效果图。（对了，上次有小伙伴问，你这效果图是怎么实现的呀，我是在这个<a class=\"link-info\" href=\"https://visualgo.net/en\" title=\"网站\">网站</a>上绘制效果图的）</p>\n</blockquote>\n<p><img alt=\"3529eb83618c4b0589d3148c31103d39.gif\" src=\"https://img-blog.csdnimg.cn/3529eb83618c4b0589d3148c31103d39.gif\"/>​</p>\n<p></p>\n<p><strong>看完效果图后感觉是不是挺通俗易懂的？好，我们来看看 DFS 的模板。</strong></p>\n<div>\n<pre><code class=\"language-cpp\">dfs(int u)\n{\n    if(找到了||走不下去了)\n    {\n        return；\n\n    }\n    开始下一个情况（dfs(u+1)）;\n\n}</code></pre>\n</div>\n<h2><strong>📸实际问题</strong></h2>\n<p><strong>我们来看看一个经典的问题——n皇后问题。我们先来看看题目。</strong></p>\n<blockquote>\n<p>给定一个n*n的棋盘，棋盘中有一些位置不能放皇后。<br/> 现在要向棋盘中放入n个黑皇后和n个白皇后，使任意的两个黑皇后都不在同一行、同一列或同一条对角线上<br/> 任意的两个白皇后都不在同一行、同一列或同一条对角线上。</p>\n</blockquote>\n<p><strong>我们来看看代码</strong></p>\n<div>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N = 20;\n\nint n;\nchar g[N][N];\nint l[N],ug[N],ng[N];\n\nvoid dfs(int u)\n{\n    if(u == n)\n    {\n        for(int i = 0; i &lt; n; i ++)\n        {\n            cout &lt;&lt; g[i] &lt;&lt; endl;\n        }\n        cout &lt;&lt; endl;\n        return ;\n    }\n    for(int i = 0; i &lt; n; i ++)\n    {\n        if(!l[i] &amp;&amp; !ug[i + u] &amp;&amp; !ng[i - u + n])\n        {\n            g[u][i] = 'Q';\n            l[i] = ug[i + u] = ng[i - u + n] = 1;\n            dfs(u + 1);\n            l[i] = ug[i + u] = ng[i - u + n] = 0;\n            g[u][i] = '.';\n        }\n    }\n\n}\nint main()\n{\n    cin &gt;&gt; n;\n    \n    for(int i = 0; i &lt; n; i ++)\n    {\n        for(int j = 0; j &lt; n; j ++) \n        {\n            g[i][j] = '.';\n        }\n    }\n    \n    dfs(0);\n    \n    return 0;\n}\n\n</code></pre>\n</div>\n<p></p>\n<p><img alt=\"d4473014d3a74064b04a50c0181863c8.png\" src=\"image\\d4473014d3a74064b04a50c0181863c8.png\"/>​</p>\n<p></p>\n<h1>二、广度优先搜索</h1>\n<blockquote>\n<p><strong>广度优先搜索（BFS）</strong>又叫广搜，它像一个有远见的人，它是一层一层来实现搜索的，也挺像下楼梯的。</p>\n<p><strong>思路：</strong></p>\n<p>  1.先初始化队列 q；<br/>   2.从起点开始访问，并且改变他的状态为已经访问；<br/>   3.如果他的队列非空，取出首个元素，将它弹出！<br/>   4.如果u == 目标状态，然后对所以与 u 邻近的点进入队列；<br/>   5.标记它已经被访问！</p>\n</blockquote>\n<p>我们先来看看效果图</p>\n<p><img alt=\"5fb58338f9ff4431ab2421162133c0e5.gif\" src=\"https://img-blog.csdnimg.cn/5fb58338f9ff4431ab2421162133c0e5.gif\"/>​</p>\n<p>我们来看看模板</p>\n<div>\n<pre><code class=\"language-cpp\">queue&lt;int&gt; q;\nst[0] = true; // 表示1号点已经被遍历过\nq.push(0);\n\nwhile (q.size())\n{\n    int t = q.front();\n    q.pop();\n\n    for (int i = h[t]; i != -1; i = ne[i])\n    {\n        int j = e[i];\n        if (!s[j])\n        {\n            st[j] = true; // 表示点j已经被遍历过\n            q.push(j);\n        }\n    }\n}</code></pre>\n</div>\n<p></p>\n<h2>📸实际问题</h2>\n<p><img alt=\"63405698705642ae9e50e09d689bd95c.png\" src=\"image\\63405698705642ae9e50e09d689bd95c.png\"/>​</p>\n<p></p>\n<p><img alt=\"ff90c126b7fb4f89b51196f9dbd4008c.png\" src=\"image\\ff90c126b7fb4f89b51196f9dbd4008c.png\"/>​</p>\n<p>来看看代码</p>\n<div>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;bits/stdc++.h&gt;\n#define x first\n#define y second\n\nusing namespace std;\n\nconst int N = 1000 + 10;\n\nint n;\ntypedef pair&lt;int,int&gt; PII;\nPII q[N * N];\nbool st[N][N];\nchar g[N][N];\n\nint dx[4] = {-1, 0, 1, 0},dy[4] = {0, 1, 0, -1};\n\nvoid bfs(int sx, int sy, int &amp;tl, int &amp;bd)\n{\n\n    int tt = 0,hh = 0;\n\n    st[sx][sy] = true;\n    q[0] = {sx, sy};\n\n    while(hh &lt;= tt)\n    {\n        PII t = q[hh ++];\n        tl ++;\n        bool is_bd = false;\n\n        for(int i = 0; i &lt; 4; i ++)\n        {\n            int x = t.x + dx[i],y = t.y + dy[i];\n            if(x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= n || st[x][y]) continue;\n            if(g[x][y] == '.')\n            {\n                is_bd = true;\n                continue;\n            }\n\n            st[x][y] = true;\n            q[++ tt] = {x, y};\n        }\n\n        if(is_bd) bd++;\n    }\n\n}\n\nint main(){\n\n   cin &gt;&gt; n;\n   \n   for(int i = 0;i &lt; n;i++) cin &gt;&gt; g[i];\n\n   int cnt  = 0;\n\n   for(int i = 0;i &lt; n;i++)\n    for(int j = 0;j &lt; n;j++)\n    {\n        if(!st[i][j] &amp;&amp; g[i][j] == '#')\n        {\n            int tl = 0,bd = 0;\n\n            bfs(i, j, tl, bd);\n\n            if(tl == bd) cnt ++;\n        }\n    }\n\n    cout &lt;&lt; cnt &lt;&lt; endl;\n    return 0;\n}\n</code></pre>\n</div>\n<p><img alt=\"c8dd3f733c144fccb91bdf3856510f60.png\" src=\"image\\c8dd3f733c144fccb91bdf3856510f60.png\"/>​</p>\n<p></p>\n<blockquote>\n<p>看到这里感觉这么样？对 dfs 与 bfs 有了更新的认识吗？我们接下来再来看看两大算法。</p>\n<p><img alt=\"6cdec1e1af044bfdb5c4937e72d74912.jpeg\" src=\"image\\6cdec1e1af044bfdb5c4937e72d74912.jpeg\"/></p>\n<p></p>\n</blockquote>\n<blockquote>\n<p><strong>扩展：什么是最小生成树？</strong></p>\n<p>给定一个无向图，如果它的某个子图中任意两个顶点都互相连通并且是一棵树，那么这棵树就叫生成树。如果边上有权值，那么使得边权和最小的生成树叫做最小生成树（MST,Minimum Spanning Tree）。</p>\n</blockquote>\n<p>那么下面我们要讲的两大算法就是与最小生成树有关的。</p>\n<p></p>\n<h1>三、prim 算法</h1>\n<blockquote>\n<p><strong>prim 算法也像一个有远见的人</strong>，他选择一个节点（假设这个节点上有 n 条边），直接来找这 n 条边上最小的边，然后选择这条最小的边选完之后剩下（n - 1）。再选择连接的最小的边的节点（假设这个节点上有 m 条边）（在 m + n - 1 条边是哪个选择）。选完之后剩下（m + n - 2），依次类推。我们来看看效果图。</p>\n</blockquote>\n<p><img alt=\"ebfbad2a200a49c4bfbae746afc74899.gif\" src=\"https://img-blog.csdnimg.cn/ebfbad2a200a49c4bfbae746afc74899.gif\"/>​</p>\n<p><strong> 算法模板</strong></p>\n<div>\n<pre><code class=\"language-cpp\">int prim()\n{\n    memset(dist, 0x3f, sizeof dist);\n    int res = 0;\n    dist[1] = 0;\n    for(int i = 0; i &lt; n; i ++)\n    {\n        int t = -1;\n        for(int j = 1; j &lt;= n; j ++)\n        if(!st[j] &amp;&amp; (t == -1 || dist[j] &lt; dist[t]))\n           t = j;\n           st[t] = true;\n           res += dist[t];\n        for(int j = 1; j &lt;= n; j ++)\n            if(dist[j] &gt; g[t][j] &amp;&amp; !st[i])\n                {\n                    dist[j] = g[t][j];\n                    pre[j] = t;\n                }\n    }\n    return res;\n}</code></pre>\n</div>\n<h2>📸实际题目</h2>\n<blockquote>\n<p>给定一个n个点m条边的无向图，图中可能存在重边和自环，边权可能为负数。</p>\n<p>求最小生成树的树边权重之和，如果最小生成树不存在则输出 impossible。</p>\n<p>给定一张边带权的无向图G=(V, E)，其中V表示图中点的集合，E表示图中边的集合，n=|V|，m=|E|。</p>\n<p>由V中的全部n个顶点和E中n-1条边构成的无向连通子图被称为G的一棵生成树，其中边的权值之和最小的生成树被称为无向图G的最小生成树。</p>\n</blockquote>\n<p></p>\n<p>这里我们看到上面的效果图，我们可以构成一组数据，如果这组数据没有输出 impossible，那么它存在最小生成树。</p>\n<div>\n<pre><code class=\"language-cpp\">9 16\n0 1 8\n0 2 12\n1 4 9\n1 3 25\n1 2 13\n2 6 21\n2 3 14\n2 6 12\n3 5 8\n3 7 12\n3 8 16\n4 5 19\n4 3 20\n5 7 11\n7 8 6\n6 8 11</code></pre>\n</div>\n<p><img alt=\"00b9a0f4788e46e7a5e44f0ea254fcff.png\" src=\"image\\00b9a0f4788e46e7a5e44f0ea254fcff.png\"/>​</p>\n<p></p>\n<h1>四、Kruskal算法</h1>\n<blockquote>\n<p><strong>Kruskal算法</strong>它很像一个比较莽撞的人，它直接选择最短的边，只要它满足最小生成树的条件，那么这条边就可行。 我们先来看看效果图。</p>\n<p></p>\n</blockquote>\n<p></p>\n<p><img alt=\"e35f9fbcd9454b46aaa87818211fb624.gif\" src=\"https://img-blog.csdnimg.cn/e35f9fbcd9454b46aaa87818211fb624.gif\"/>​</p>\n<p></p>\n<blockquote>\n<p><strong>思路：</strong></p>\n<p>①将所有边按权重从小到大排序</p>\n<p>②枚举每条边 a,b，权重是c</p>\n<p>if a,b不连通 </p>\n<p>​    将这条边加入集合</p>\n</blockquote>\n<h2>📸实际题目</h2>\n<p>同样是上面的题目与数据</p>\n<blockquote>\n<p>给定一个n个点m条边的无向图，图中可能存在重边和自环，边权可能为负数。</p>\n<p>求最小生成树的树边权重之和，如果最小生成树不存在则输出 impossible。</p>\n<p>给定一张边带权的无向图G=(V, E)，其中V表示图中点的集合，E表示图中边的集合，n=|V|，m=|E|。</p>\n<p>由V中的全部n个顶点和E中n-1条边构成的无向连通子图被称为G的一棵生成树，其中边的权值之和最小的生成树被称为无向图G的最小生成树。</p>\n</blockquote>\n<p>我们来看看代码是如何实现的。</p>\n<div>\n<pre><code class=\"language-cpp\">#include&lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\nconst int N = 2e5+5;\nint n,m;\n\nstruct Edge\n{\n\tint u, v, w;\n\tbool operator&lt;(const Edge &amp;a) const\n\t{\n\t\treturn w&lt;a.w;\n\t}\n}edge[N];\n\nint p[N];\nint find(int x)\n{\n\treturn p[x] == x ? x : p[x] = find(p[x]);\n}\n\n\nint main()\n{\n\tint n, m;\n\tscanf(\"%d%d\",&amp;n, &amp;m);\n\tfor(int i=0;i&lt;m;i++)\n    {\n\t\tint u, v, w;\n\t\tscanf(\"%d%d%d\",&amp;u, &amp;v, &amp;w);\n\t\tedge[i] = {u,v,w};\n\t}\n\tsort(edge, edge + m);\n\t\n\tfor(int i = 1; i &lt;= n; i ++) p[i] = i;\n\t\n\tint cnt = 0, sum = 0;\n\t\n\tfor(int i = 0; i &lt; m; i ++)\n    {\n\t\tint a = edge[i].u, b=edge[i].v, w = edge[i].w;\n\t\ta = find(a);\n\t\tb = find(b);\n\t\tif(a != b)\n\t\t{\n\t\t\tcnt ++;\n\t\t\tsum += w;\n\t\t\tp[a] = b;\n\t\t}\n\t}\n\tif(cnt &lt; n - 1) puts(\"impossible\");\n\telse printf(\"%d\", sum);\n}\n</code></pre>\n</div>\n<p><img alt=\"6299b897cac04905a2ff811161df3d20.png\" src=\"image\\6299b897cac04905a2ff811161df3d20.png\"/>​</p>\n<p> 用同样的数据，不同的算法得到相同的结果，没毛病。</p>\n<p></p>\n<h1>五、小结</h1>\n<p>我们来看看时间复杂度的分析</p>\n<blockquote>\n<p><strong>BFS的复杂度分析</strong><br/> 最坏的情况下，空间复杂度为O（v）。</p>\n<p>每个顶点均需搜索一次，时间复杂度T1=O（v），每条边至少访问1次，时间复杂度为O(E)，算法总的时间复 度为O(|V|+|E|)。</p>\n<p>查找每个顶点的邻接点所需时间为O(V)，即该节点所在的该行该列。又有n个顶点，故算总的时间复杂度为O(|V|^2)。</p>\n<p></p>\n<p><strong>DFS复杂度分析</strong><br/> 它的空问复杂度为O(V）。</p>\n<p>查找所有顶点的邻接点所需时间为O(E)，访问顶点的邻接点所花时间为O（V）,此时，总的时间复杂度为O(V+E)。</p>\n<p>查找每个顶点的邻接点所需时间为O(V)，要查找整个矩阵，故总的时间度为O(V^2)。 </p>\n<p></p>\n<p>注意： v为图的顶点数，E为边数。</p>\n</blockquote>\n<p> </p>\n<blockquote>\n<p>算法对程序员来说及其重要，语言和开发平台不断变化，但是万变不离其宗的是那些算法和理论，依稀记得我那个玩的很好的一个学长（在大二就拿到了 offer），他告诉我想找一个好的工作，那刷题一定是必不可少的</p>\n<p>现在算法刷题平台还是蛮多的，给大家介绍一个我认为与大厂关联最深的平台——<a href=\"https://www.nowcoder.com/link/pc_csdncpt_cxyz_sf\" title=\"牛客网\">牛客网</a></p>\n</blockquote>\n</div>\n</div>"}