{"blogid": "121068558", "writerAge": "码龄4年", "writerBlogNum": "46", "writerCollect": "23", "writerComment": "8", "writerFan": "2", "writerGrade": "3级", "writerIntegral": "483", "writerName": "福尔财斯.包子蔡", "writerProfileAdress": "writer_image\\profile_121068558.jpg", "writerRankTotal": "167196", "writerRankWeekly": "431758", "writerThumb": "18", "writerVisitNum": "13572", "blog_read_count": "3338", "blog_time": "于 2021-10-31 19:56:25 发布", "blog_title": "C#基础——Hashset类", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h2><span style=\"color:#1a439c;\">HashSet基础概念</span></h2>\n<p>HashSet 是 <strong><span style=\"color:#ed7976;\"><code>System.Collections.Generic</code> </span></strong>命名空间下的 <code>HashSet&lt;T&gt;</code> 类，是一个高性能且无序的集合。</p>\n<p>因为HashSet是无序的，所以它既不能做排序操作，又不能像数组那样索引。在 <span style=\"color:#be191c;\"><span style=\"background-color:#fefcd8;\">HashSet 上只能使用foreach</span></span>来进行迭代，而无法使用for循环。</p>\n<p>HashSet中的元素不重复（可以存放单一的null），即具有<span style=\"color:#be191c;\"><span style=\"background-color:#fefcd8;\">元素唯一性，</span></span>若向 HashSet 中插入重复元素，其内部会忽视此次操作，不会报出异常。因此若想拥有一个具有唯一值的集合，HashSet将会是一个具有超高效检索性能的极佳选择（例子：见Leecode刷题第三题）。</p>\n<pre><code>static void Main(string[] args)\n        {\n            HashSet&lt;string&gt; hashSet = new HashSet&lt;string&gt;();\n            hashSet.Add(\"A\");\n            hashSet.Add(\"B\");\n            hashSet.Add(\"C\");\n            hashSet.Add(\"D\");\n            hashSet.Add(\"D\");\n            Console.WriteLine(\"The number of elements is: {0}\", hashSet.Count);\n            Console.ReadKey();\n        }\n\n————————————————\n版权声明：本文为CSDN博主「一线码农」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/huangxinchen520/article/details/111477946</code></pre>\n<p>例如上述这段代码的输出结果就是：ABCD，最后一个重复的D被忽略了。</p>\n<h2><span style=\"color:#1a439c;\"><strong>HashSet的一些常用方法：</strong></span></h2>\n<p>1）在HashSet中查找是否含有某元素：Contains方法</p>\n<p>示例：</p>\n<pre><code>hashSet.Contains(\"D\")</code></pre>\n<p>2）在HashSet中移除某元素：Remove 方法</p>\n<p>示例：</p>\n<pre><code>hashSet.Remove(item);</code></pre>\n<p>3）删除 HashSet 中的所有元素： Clear 方法</p>\n<h3><span style=\"color:#79c6cd;\">HashSet对于集合Set的一些操作：</span></h3>\n<p>4）判断 HashSet 是否为某一个集合的完全子集：IsProperSubsetOf方法</p>\n<pre><code>HashSet&lt;string&gt; setA = new HashSet&lt;string&gt;() { \"A\", \"B\", \"C\", \"D\" };\nHashSet&lt;string&gt; setB = new HashSet&lt;string&gt;() { \"A\", \"B\", \"C\", \"X\" };\nHashSet&lt;string&gt; setC = new HashSet&lt;string&gt;() { \"A\", \"B\", \"C\", \"D\", \"E\" };\nif (setA.IsProperSubsetOf(setC)) //是子集输出1，不是输出0\n   Console.WriteLine(\"setC contains all elements of setA.\");\nif (!setA.IsProperSubsetOf(setB))\n   Console.WriteLine(\"setB does not contains all elements of setA.\");\n</code></pre>\n<p>5）集合的合并：UnionWith方法</p>\n<pre><code>HashSet&lt;string&gt; setA = new HashSet&lt;string&gt;() { \"A\", \"B\", \"C\", \"D\", \"E\" };\nHashSet&lt;string&gt; setB = new HashSet&lt;string&gt;() { \"A\", \"B\", \"C\", \"X\", \"Y\" };\nsetA.UnionWith(setB);\nforeach(string str in setA)\n{\n   Console.WriteLine(str);\n}\n//最终setA的输出结果是ABCDEXY</code></pre>\n<p>最终setA会输出setA和setB中的所有元素</p>\n<p>6）两个 HashSet 的交集：IntersectWith 方法</p>\n<pre><code>setA.IntersectWith(setB);</code></pre>\n<p>输出结果是setA和setB集合中都有的元素</p>\n<p>7）集合减，时间复杂度是 O(N)：ExceptWith 方法</p>\n<pre><code>setA.ExceptWith(setB);</code></pre>\n<p>输出setA集合中有但setB集合中没有的元素</p>\n<p>8）两个集合都不全有的元素：SymmetricExceptWith 方法</p>\n<pre><code>HashSet&lt;string&gt; setA = new HashSet&lt;string&gt;() { \"A\", \"B\", \"C\", \"D\", \"E\" };\nHashSet&lt;string&gt; setB = new HashSet&lt;string&gt;() { \"A\", \"X\", \"C\", \"Y\" };\nsetA.SymmetricExceptWith(setB);\nforeach (string str in setA)\n{\n  Console.WriteLine(str);\n}\n//对于这个示例，最终输出结果是BDEXY</code></pre>\n</div>\n</div>"}