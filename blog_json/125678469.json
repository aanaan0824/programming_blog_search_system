{"blogid": "125678469", "writerAge": "码龄2年", "writerBlogNum": "27", "writerCollect": "534", "writerComment": "547", "writerFan": "1848", "writerGrade": "5级", "writerIntegral": "1967", "writerName": "一码超人", "writerProfileAdress": "writer_image\\profile_125678469.jpg", "writerRankTotal": "9640", "writerRankWeekly": "1202", "writerThumb": "673", "writerVisitNum": "29819", "blog_read_count": "1607", "blog_time": "于 2022-07-08 15:36:33 发布", "blog_title": "java-AOP代理的三种实现方式【必须收藏】", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p><strong>业务场景：首先你有了一个非常好的前辈无时无刻的在“教育”你。有这么一天，它叫你将它写好的一个方法进行改进测试，这时出现了功能迭代的情况。然后前辈好好“教育”你的说，不行改我的代码！改就腿打折！悲催的你有两条路可走，拿出你10年跆拳道的功夫去火拼一波然后拍拍屁股潇洒走人，要么就是悲催的开始百度。。。这时你会发现，我擦怎么把AOP代理这种事给忘了？【其实在我们工作中很少去手写它，但是它又是很常见的在使用（控制台日志）】</strong></p>\n<p>怎么办？打赢送手镯，打输睡大觉？</p>\n<p>兄弟，信我的！</p>\n<p>写吧。。。</p>\n<p><strong>AOP是一种设计思想，是软件设计领域中的面向切面编程，它是面向对象编程的一种补充和完善，它以通过预编译方式和运行期动态代理方式实现在不修改源代码的情况下给程序动态统一添加额外功能的一种技术。</strong></p>\n<p><strong>利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的<a href=\"https://so.csdn.net/so/search?q=%E8%80%A6%E5%90%88%E5%BA%A6&amp;spm=1001.2101.3001.7020\" title=\"耦合度\">耦合度</a>降低，提高程序的可重用性，同时提高了开发的效率</strong></p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\49aa9da5bd11b7e1bfa9683b6ad7c465.png\"/></p>\n<p><strong>简单说就是在不影响原有功能代码的情况下进行扩展，浸入少。</strong></p>\n<p><strong>废话不多说，开搞！</strong></p>\n<p><strong>1、JDK实现</strong></p>\n<p><img alt=\"\" height=\"510\" src=\"image\\9a7eea349eb5462b8d789dbd85d5e4ef.png\" width=\"483\"/></p>\n<p> </p>\n<pre>MyAop</pre>\n<pre><code class=\"language-java\">package com.example.quasar.aop;\n\n\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\n\n//继承InvocationHandler接口实现\npublic class MyAop implements InvocationHandler {\n    private Object object;\n\n    public MyAop(Object object) {\n        this.object = object;\n    }\n\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        //前置\n        System.out.println(\"前置运行\");\n        Object invoke = method.invoke(this.object, args);\n        //后置\n        System.out.println(\"后置运行\");\n        return invoke;\n    }\n}\n</code></pre>\n<p> </p>\n<pre>IndexService</pre>\n<pre><code class=\"language-java\">package com.example.quasar.service;\n\n\npublic interface IndexService {\n    public void run();\n    public void run1();\n}\n</code></pre>\n<pre>IndexServiceImpl\n</pre>\n<p> </p>\n<pre><code class=\"language-java\">package com.example.quasar.service.impl;\n\nimport com.example.quasar.service.IndexService;\n\npublic class IndexServiceImpl implements IndexService {\n    @Override\n    public void run() {\n        System.out.println(\"运行了\");\n    }\n\n    @Override\n    public void run1() {\n        System.out.println(\"运行了1\");\n    }\n}\n</code></pre>\n<pre>QuasarApplication</pre>\n<pre><code class=\"language-java\">package com.example.quasar;\nimport com.example.quasar.aop.MyAop;\nimport com.example.quasar.service.IndexService;\nimport com.example.quasar.service.impl.IndexServiceImpl;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\nimport java.lang.reflect.Proxy;\n\n@SpringBootApplication\npublic class QuasarApplication {\n\n    public static void main(String[] args) {\n        //实现类实例化\n        IndexService indexService = new IndexServiceImpl();\n        //将实例传入aop\n        MyAop myAop = new MyAop(indexService);\n        //通过Proxy.newProxyInstance实现代理\n        IndexService o = (IndexService) Proxy.newProxyInstance(IndexServiceImpl.class.getClassLoader(), new Class[]{IndexService.class}, myAop);\n        //执行实现方法\n        o.run();\n        o.run1();\n    }\n\n}\n</code></pre>\n<p> 执行结果</p>\n<p><img alt=\"\" height=\"1040\" src=\"image\\5eb085e95c5e4fff8c692ed3e0033dca.png\" width=\"1200\"/></p>\n<p><strong> 2、CGLIB实现</strong></p>\n<p>如果项目中，已经使用了Spring，可以忽略导入上述两个包。因为在spring-core中已经集成了。否则需要引入该包，百度去找。</p>\n<p><img alt=\"\" height=\"581\" src=\"image\\9271c547412345dca6e253f4c41f790c.png\" width=\"488\"/></p>\n<p> </p>\n<pre>MyAop</pre>\n<pre><code class=\"language-java\">package com.example.quasar.aop;\n\npublic class MyAop {\n    public void befor() {\n        System.out.println(\"befor...\");\n    }\n    public void after() {\n        System.out.println(\"after...\");\n    }\n}\n</code></pre>\n<p> </p>\n<pre>IndexService</pre>\n<pre><code class=\"language-java\">package com.example.quasar.service;\n\n\npublic interface IndexService {\n    public void run();\n    public void run1();\n}\n</code></pre>\n<pre>IndexServiceImpl</pre>\n<pre><code class=\"language-java\">package com.example.quasar.service.impl;\n\nimport com.example.quasar.service.IndexService;\n\npublic class IndexServiceImpl implements IndexService {\n    @Override\n    public void run() {\n        System.out.println(\"运行了\");\n    }\n\n    @Override\n    public void run1() {\n        System.out.println(\"运行了1\");\n    }\n}\n</code></pre>\n<p> </p>\n<pre>QuasarApplication</pre>\n<pre><code class=\"language-java\">package com.example.quasar;\nimport com.example.quasar.aop.MyAop;\nimport com.example.quasar.service.IndexService;\nimport com.example.quasar.service.impl.IndexServiceImpl;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.cglib.proxy.Enhancer;\nimport org.springframework.cglib.proxy.MethodInterceptor;\nimport org.springframework.cglib.proxy.MethodProxy;\n\nimport java.lang.reflect.Method;\n\n@SpringBootApplication\npublic class QuasarApplication {\n\n    public static void main(String[] args) {\n        //实现类实例化\n        IndexService indexService = new IndexServiceImpl();\n        // 代理类 ，采用cglib，底层创建目标类的子类\n        MyAop myAop = new MyAop();\n        // 核心类\n        Enhancer enhancer = new Enhancer();\n        //确定父类\n        enhancer.setSuperclass(indexService.getClass());\n        enhancer.setCallback(new MethodInterceptor() {\n            @Override\n            public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {\n                //前置\n                myAop.after();\n                // 执行目标类的方法\n                Object obj = method.invoke(indexService, args);\n                //后置\n                myAop.befor();\n                return obj;\n            }\n        });\n        // 3.4 创建代理\n        IndexService proxService = (IndexService) enhancer.create();\n        proxService.run();\n        proxService.run1();\n    }\n\n}\n</code></pre>\n<p>执行结果</p>\n<p><img alt=\"\" height=\"1040\" src=\"image\\34dd0286d0bb4f939dfebb1c99906410.png\" width=\"1200\"/> </p>\n<p><strong> 3、boot注解实现【注意只对bean有效】</strong></p>\n<p><img alt=\"\" height=\"762\" src=\"image\\b95b4842e07b48b593cc3045ddbd4524.png\" width=\"500\"/></p>\n<p> </p>\n<pre>MyAop</pre>\n<pre><code class=\"language-java\">package com.v1.aop;\n\nimport org.aspectj.lang.JoinPoint;\nimport org.aspectj.lang.ProceedingJoinPoint;\nimport org.aspectj.lang.annotation.Around;\nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.annotation.Before;\nimport org.springframework.stereotype.Component;\n\n@Aspect\n@Component\npublic class MyAop {\n    //*号作用：com.v1.service.impl下的所有类和所有方法\n    @Before(value = \"within(com.v1.service.impl.*)\")\n    public void before(JoinPoint joinPoint) {\n        System.out.println(\"before开始执行查询.......\");\n        System.out.println(\"正在执行的目标类是: \" + joinPoint.getTarget());\n        System.out.println(\"正在执行的目标方法是: \" + joinPoint.getSignature().getName());\n    }\n    //*号作用：com.v1.controller下的所有类和所有方法\n    @Around(value = \"execution(* com.v1.controller.*.*(..))\")\n    public Object aroud(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {\n        System.out.println(\"aroud环绕通知开始.......\");\n        System.out.println(\"执行的目标类 = \" + proceedingJoinPoint.getTarget());\n        System.out.println(\"执行的目标方法 = \" + proceedingJoinPoint.getSignature().getName());\n        // 必须方法目标方法\n        Object proceed = proceedingJoinPoint.proceed();\n        System.out.println(\"aroud环绕通知结束.......\");\n        // 将目标方法的返回值进行返回，否则调用目标方法的方法无法获取到返回值\n        return proceed;\n    }\n\n}\n</code></pre>\n<p><strong>非常简单，直接就根据注解进行代理了！</strong></p>\n<p><strong>注解参数可以具体在咱们csdn平台去查一下，有很多文章讲的很细的！</strong></p>\n<p> 执行结果</p>\n<p>发个请求跑一下</p>\n<p><img alt=\"\" height=\"1040\" src=\"image\\78c36a8f98664e0aa5d0cdf7aa6f9c6a.png\" width=\"1200\"/></p>\n<p> <img alt=\"\" height=\"846\" src=\"image\\a2b287b34a2b4c5fba6f8fb74c4afc99.png\" width=\"1200\"/></p>\n<p> <img alt=\"\" height=\"1040\" src=\"image\\dde222c09ae543e2ab9bc457960d2e6b.png\" width=\"1200\"/></p>\n<p> 真是非常好用，注解真是简单的不要不要的！</p>\n<p> 再此可以点一个小小的关注嘛？我会继续努力爬坑！！！</p>\n</div>\n</div>"}