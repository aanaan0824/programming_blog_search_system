{"blogid": "126743164", "writerAge": "码龄24天", "writerBlogNum": "53", "writerCollect": "2", "writerComment": "0", "writerFan": "146", "writerGrade": "3级", "writerIntegral": "540", "writerName": "web13091983258", "writerProfileAdress": "writer_image\\profile_126743164.jpg", "writerRankTotal": "35945", "writerRankWeekly": "8680", "writerThumb": "0", "writerVisitNum": "2861", "blog_read_count": "11", "blog_time": "于 2022-09-07 12:26:04 发布", "blog_title": "JVM - 直接内存", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h2><a id=\"_JVM___2\"></a># <code>JVM</code> - 直接内存</h2>\n<blockquote>\n<p><code>JDK</code>版本：<code>1.8</code></p>\n</blockquote>\n<h3><a id=\"_1Direct_Memory_7\"></a># 1、直接内存(<code>Direct Memory</code>)</h3>\n<p>直接内存(<code>Direct Memory</code>)并不是虚拟机运行时数据区的一部分，也不是《<code>Java</code>虚拟机规范》中定义的内存区域。但是这部分内存也会被频繁地使用，而且也会导致<code>OutOfMemeory</code>异常。</p>\n<p>在<code>JDK 1.4</code>版本中引入了<code>NIO</code>类，引入了一种基于通道(<code>Channel</code>)于缓冲区(<code>Buffer</code>)的<code>I/O</code>方式，它可以直接调用<code>Native</code>函数分配堆外内存空间，然后通过存储在堆中的<code>DirectByteBuffer</code>对象作为这块空间的引用以此来对其进行操作。这样就避开了<code>JVM</code>于操作系统之间的内存屏障，减少了在<code>Java</code>堆与<code>Native</code>堆中进行来回复制的额外开销，在某些场景中可以显著提高性能。同时访问直接内存的速度也会优于<code>Java</code>堆，即读写性能高。</p>\n<p>本机直接内存的分配是不会受到<code>JVM</code>堆内存大小的限制，但是它还是会受到本机总内存(包括物理内存，<code>SWAP</code>分区或者分页文件)的大小以及处理器寻址空间的限制。一般在配置虚拟机参数时，会根据实际内存设置<code>-Xmx</code>等参数信息，但经常忽略掉直接内存，使得各个内存区域总和大于物理内存限制(包括物理和操作系统级的限制)，从而导致动态进行扩展时出现<code>OutOfMemory</code>异常。</p>\n<p>也正是因为直接内存不是虚拟机运行时数据区的一部分，直接内存不受<code>JVM</code>内存回收管理，所以其分配回收成本也较高。直接内存大小可通过<code>MaxDirectMemorySize</code>选项进行配置，如果不进行指定默认与堆空间的<code>-Xmx</code>参数值保持一致。</p>\n<h3><a id=\"_2_17\"></a># 2、直接内存与非直接内存差异</h3>\n<p>使用非直接内存进行<code>IO</code>读写文件时，需要与物理磁盘进行交互。在执行读写操作时，<code>JVM</code>与<code>OS</code>直接存在内存屏障，所以进行数据的交互时就会进行来回复制。换而言之就是需要由用户态切换到内核态，内核态中需要同时维护两份重复数据，这样带来的额外性能开销是非常大的。</p>\n<p>如下为非直接内存<code>JVM</code>与<code>OS</code>之间的数据交互图：</p>\n<p><img alt=\"非直接内存\" src=\"image\\c897fc7c596b4670bc16c8ef9301bf1d.png\"/></p>\n<p>使用直接内存进行<code>IO</code>读写文件时，直接调用<code>Native</code>函数分配堆外内存空间，并且这部分内存可以通过存储在堆中的<code>DirectByteBuffer</code>对象对其进行操作，避免了内存屏障同时也只需要维护一份数据。避免了不必要的性能开销。</p>\n<p>如下为直接内存<code>JVM</code>与<code>OS</code>之间的数据交互图：</p>\n<p><img alt=\"直接内存\" src=\"image\\8d92b207a551486bac5d4184ebfd373f.png\"/></p>\n<hr/>\n<p><a href=\"https://github.com/kapbc/Java-Kapcb\">GitHub源码地址</a>：<code>https://github.com/kapbc/Java-Kapcb/tree/master/src/main/java/com/kapcb/ccc/jvm</code></p>\n<blockquote>\n<p>备注：此文为笔者学习<code>JVM</code>的笔记，鉴于本人技术有限，文中难免出现一些错误，感谢大家批评指正。</p>\n</blockquote>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}