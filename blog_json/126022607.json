{"blogid": "126022607", "writerAge": "码龄158天", "writerBlogNum": "22", "writerCollect": "214", "writerComment": "306", "writerFan": "127", "writerGrade": "4级", "writerIntegral": "1244", "writerName": "Node_Hao", "writerProfileAdress": "writer_image\\profile_126022607.jpg", "writerRankTotal": "15734", "writerRankWeekly": "658", "writerThumb": "308", "writerVisitNum": "9850", "blog_read_count": "1247", "blog_time": "已于 2022-08-26 15:15:15 修改", "blog_title": "[Java] 字符串底层剖析与常见面试题", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p> <img alt=\"在这里插入图片描述\" src=\"https://img-blog.csdnimg.cn/cbb6468f0f6340498374353697dbc0cd.gif#pic_center%23pic_center\"/></p>\n<blockquote>\n<p><img alt=\"\" height=\"16\" src=\"image\\cb2be72a3c2b4b59b1128abf613b8abe.png\" width=\"16\"/><span style=\"background-color:#ff9900;\">专栏简介 :java语法</span></p>\n<p><img alt=\"\" height=\"16\" src=\"image\\4366a93aaa3142b5a0f16c7a2200339b.png\" width=\"16\"/><span style=\"background-color:#38d8f0;\">创作目标:从不一样的角度,用通俗易懂的方式,总结归纳java语法知识.</span></p>\n<p><img alt=\"\" height=\"15\" src=\"image\\52a3437a932f4621b25533c330f7c6cb.png\" width=\"15\"/><span style=\"background-color:#a2e043;\">希望在提升自己的同时,帮助他人,与大家一起共同进步,互相成长.</span></p>\n<p><img alt=\"\" height=\"15\" src=\"image\\14aa2f0648ae44a299b8f9832af57d2c.png\" width=\"15\"/><span style=\"background-color:#fbd4d0;\">学历代表过去,能力代表现在,学习能力代表未来!</span></p>\n</blockquote>\n<p></p>\n<blockquote>\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E5%89%8D%E8%A8%80-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%89%8D%E8%A8%80\">前言</a></p>\n<p id=\"%E4%B8%80.%E8%AE%A4%E8%AF%86String%E7%B1%BB%3A-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%80.%E8%AE%A4%E8%AF%86String%E7%B1%BB%3A\">一.认识String类:</a></p>\n<p id=\"%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A01.%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%3A-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A01.%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%3A\">1.创建字符串:</a></p>\n<p id=\"%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0(StringTable)%3A-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%28StringTable%29%3A\">2.字符串常量池(StringTable):</a></p>\n<p id=\"%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%3Eintern%E6%96%B9%E6%B3%95-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%3Eintern%E6%96%B9%E6%B3%95\">     [ intern方法]</a></p>\n<p id=\"%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.%E7%90%86%E8%A7%A3%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8D%E5%8F%AF%E5%8F%98%3A-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.%E7%90%86%E8%A7%A3%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8D%E5%8F%AF%E5%8F%98%3A\">3.理解字符串不可变:</a></p>\n<p id=\"1.%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%E6%BA%90%E7%A0%81%E5%B7%B2%E6%8F%8F%E8%BF%B0%E7%9A%84%E5%BE%88%E6%B8%85%E6%A5%9A%3A-toc\" style=\"margin-left:80px;\"><a href=\"#1.%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%E6%BA%90%E7%A0%81%E5%B7%B2%E6%8F%8F%E8%BF%B0%E7%9A%84%E5%BE%88%E6%B8%85%E6%A5%9A%3A\">        </a></p>\n<p id=\"%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%BF%AE%E6%94%B9%E4%B8%8E%E6%8B%BC%E6%8E%A5-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%BF%AE%E6%94%B9%E4%B8%8E%E6%8B%BC%E6%8E%A5\">4.字符串的修改与拼接</a></p>\n<p id=\"%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BF%AE%E6%94%B9-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BF%AE%E6%94%B9\">        1.字符串修改</a></p>\n<p id=\"%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5\">        2.字符串拼接</a></p>\n<p id=\"%C2%A05.new%20String%E7%9A%84%E8%AE%A8%E8%AE%BA-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A05.new%20String%E7%9A%84%E8%AE%A8%E8%AE%BA\"> 5.new String的讨论</a></p>\n<p id=\"%E4%B8%89.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%89.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C\">三.字符串常见操作</a></p>\n<p id=\"1.%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83-toc\" style=\"margin-left:40px;\"><a href=\"#1.%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83\">1.字符串比较</a></p>\n<p id=\"2.%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE-toc\" style=\"margin-left:40px;\"><a href=\"#2.%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE\">2.字符串查找</a></p>\n<p id=\"3.%E8%BD%AC%E6%8D%A2-toc\" style=\"margin-left:40px;\"><a href=\"#3.%E8%BD%AC%E6%8D%A2\">3.转换</a></p>\n<p id=\"%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A01)%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A01%29%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2\">        1)数组与字符串转换</a></p>\n<p id=\"%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A02)%E5%A4%A7%E5%B0%8F%E5%86%99%E8%BD%AC%E6%8D%A2-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A02%29%E5%A4%A7%E5%B0%8F%E5%86%99%E8%BD%AC%E6%8D%A2\">        2)大小写转换</a></p>\n<p id=\"%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A03)%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B0%E7%BB%84-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A03%29%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B0%E7%BB%84\">        3)字符串转数组</a></p>\n<p id=\"%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A04)%E6%A0%BC%E5%BC%8F%E5%8C%96-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A04%29%E6%A0%BC%E5%BC%8F%E5%8C%96\">        4)格式化</a></p>\n<p id=\"4.%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9B%BF%E6%8D%A2-toc\" style=\"margin-left:40px;\"><a href=\"#4.%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9B%BF%E6%8D%A2\">4.字符串替换</a></p>\n<p id=\"5.%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%86%E5%88%86-toc\" style=\"margin-left:40px;\"><a href=\"#5.%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%86%E5%88%86\">5.字符串拆分</a></p>\n<p id=\"%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A01)%E5%AE%9E%E7%8E%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%86%E5%88%86%E5%A4%84%E7%90%86-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A01%29%E5%AE%9E%E7%8E%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%86%E5%88%86%E5%A4%84%E7%90%86\">        1)实现字符串拆分处理</a></p>\n<p id=\"%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202)%E9%83%A8%E5%88%86%E6%8B%86%E5%88%86%E5%A4%84%E7%90%86-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202%29%E9%83%A8%E5%88%86%E6%8B%86%E5%88%86%E5%A4%84%E7%90%86\">        2)部分拆分处理</a></p>\n<p id=\"%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A03)%E6%8B%86%E5%88%86%E7%BD%91%E5%9D%80-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A03%29%E6%8B%86%E5%88%86%E7%BD%91%E5%9D%80\">         3)拆分网址</a></p>\n<p id=\"%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A04)%E5%A4%9A%E6%AC%A1%E6%8B%86%E5%88%86%20(%E5%BC%80%E5%8F%91%E4%B8%AD%E5%B8%B8%E7%94%A8)-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A04%29%E5%A4%9A%E6%AC%A1%E6%8B%86%E5%88%86%20%28%E5%BC%80%E5%8F%91%E4%B8%AD%E5%B8%B8%E7%94%A8%29\">        4)多次拆分 (开发中常用)</a></p>\n<p id=\"6.%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%88%AA%E5%8F%96-toc\" style=\"margin-left:40px;\"><a href=\"#6.%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%88%AA%E5%8F%96\">6.字符串截取</a></p>\n<p id=\"7.%E5%85%B6%E4%BB%96%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95-toc\" style=\"margin-left:40px;\"><a href=\"#7.%E5%85%B6%E4%BB%96%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95\">7.其他操作方法</a></p>\n<p id=\"%E5%9B%9B.StringBuffer%E4%B8%8EStringBuilder-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%9B%9B.StringBuffer%E4%B8%8EStringBuilder\">四.StringBuffer与StringBuilder</a></p>\n<p style=\"margin-left:0px;\"></p>\n<p id=\"String%E7%B1%BB%E7%AC%94%E8%AF%95%E9%A2%98%3A-toc\" style=\"margin-left:0px;\"><a href=\"#String%E7%B1%BB%E7%AC%94%E8%AF%95%E9%A2%98%3A\">五.String类笔试题:</a></p>\n<p id=\"1.%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6-toc\" style=\"margin-left:80px;\"><a href=\"#1.%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6\">1.第一个只出现一次的字符</a></p>\n<p id=\"2)%E8%AE%A1%E7%AE%97%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6%C2%A0-toc\" style=\"margin-left:80px;\"><a href=\"#2%29%E8%AE%A1%E7%AE%97%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6%C2%A0\">2)计算字符串最后一个单词的长度 </a></p>\n<p id=\"%C2%A03)%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A03%29%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2\">3)验证回文串</a></p>\n<p id=\"%C2%A04)%E5%AD%97%E7%AC%A6%E9%9B%86%E5%90%88-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A04%29%E5%AD%97%E7%AC%A6%E9%9B%86%E5%90%88\">4)字符集合</a></p>\n<p id=\"%E6%80%BB%E7%BB%93-toc\" style=\"margin-left:0px;\"><a href=\"#%E6%80%BB%E7%BB%93\">总结</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n</blockquote>\n<p></p>\n<hr/>\n<h1 id=\"%E5%89%8D%E8%A8%80\"><a id=\"_7\"></a>前言</h1>\n<blockquote>\n<p>  <img alt=\"\" height=\"21\" src=\"image\\1100c2229909472baac985ab90d8d395.png\" width=\"21\"/>  Hello!大家好!今天给大家带来的是,j<span style=\"color:#fe2c24;\">avaSE中的字符串语法讲解</span>,<span style=\"color:#38d8f0;\">旨在从更深入更底层的视角去剖析字符串在内存中的存储结构</span>,便于大家更深入的理解.在学习字符串底层逻辑的同时还能了解到更多关联知识,<span style=\"color:#38d8f0;\">开拓视野并完善知识体系.</span></p>\n</blockquote>\n<hr/>\n<h1 id=\"%E4%B8%80.%E8%AE%A4%E8%AF%86String%E7%B1%BB%3A\"><span style=\"background-color:#38d8f0;\">一.认识String类:</span></h1>\n<p>         观察String类的源码我们可以发现,String为一个引用类型指向一个由<span style=\"color:#fe2c24;\">value和hash</span>组成的对象(JDK1.8),<span style=\"color:#fe2c24;\">value又指向一个char类型的数组</span>.但JDK1.9中String为一个引用类型指向一个由value,hash,coder,hashIsZero组成的对象,value指向一个byte类型的数组.<span style=\"color:#fe2c24;\">改动的目的是coder为byte编码更加节省空间.</span><span style=\"color:#0d0016;\">由于改动不影响理解,所以之后的内容都按</span><span style=\"color:#38d8f0;\">JDK1.8来讲解.</span></p>\n<p><img alt=\"\" height=\"564\" src=\"image\\3aaf6afdbeff48ad9945670d27bb91af.png\" width=\"1200\"/></p>\n<p><img alt=\"\" height=\"521\" src=\"image\\23db0b9e635e460eb2a38c111688f14f.png\" width=\"952\"/></p>\n<h2 id=\"%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A01.%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%3A\">1.创建字符串:</h2>\n<p>        <span style=\"color:#fe2c24;\">常见的构造字符串的方式:</span></p>\n<div>\n<pre><code class=\"language-java\">//方法一:\nString str = \"Hello World\";\n\n//方法二:\n2.String str = new String(\"Hello World\");\n\n//方法三:\n3.char[ ] array  = {'a','b','c'};\n  String str  = new String(array);</code></pre>\n</div>\n<blockquote>\n<p>       每种创建字符串的方式所创建的<span style=\"color:#fe2c24;\">对象数量都不相同,</span>例如方法一创建2个对象,方法二创建3个对象,方法三创建4个对象.</p>\n</blockquote>\n<p>        <span style=\"color:#38d8f0;\">注意:String为引用类型,String str = \"Hello World\";的内存布局如下:</span><span style=\"color:#0d0016;\">(以下是为了方便理解的简图,更底层的讲解在字符串常量池部分)</span></p>\n<p><img alt=\"\" height=\"531\" src=\"image\\ae63f501c2174cb899d3aa29581ac707.png\" width=\"989\"/></p>\n<p></p>\n<hr/>\n<h2 id=\"%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0(StringTable)%3A\">2.字符串常量池(StringTable):</h2>\n<blockquote>\n<p>        \"池\"\"是编程中一中常见的,提升效率的方式,在java程序中类似1,2,3,true,false,.\"hello\" 这些常见的字面值常量会频繁的使用,为了<span style=\"color:#38d8f0;\">提升程序效率节省内存</span>,java为<span style=\"color:#fe2c24;\">8种基本数据类型和String类</span>都提供了常量池.</p>\n</blockquote>\n<p>        例如:小美没有男朋友的时候想吃瓜子必须从瓜子池中取出一个瓜子嗑瓜子,小美觉得这样太麻烦,于是她找了一个男朋友小明,小明把嗑好的瓜子收集在一起等待小美食用,从此以后小美吃瓜子的效率大大提升了.</p>\n<blockquote>\n<p>        JDK1.6时<span style=\"color:#fe2c24;\">StringTable</span>存放在永久代,由于永久代使用JVM内存默认空间较小且垃圾回收评率较低,于是JDK1.7时存放在堆区,JDK1.8时存放在<span style=\"color:#fe2c24;\">元空间(本质还是堆区)</span>,这样做的好处是和其他对象一样需要<span style=\"color:#38d8f0;\">调优应用时调整堆的大小即可</span>.</p>\n</blockquote>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px;\"><tbody><tr><td>JDK版本</td><td>字符串常量池位置</td><td>大小设置</td></tr><tr><td>1.6</td><td>永久代</td><td>固定大小:1009</td></tr><tr><td>1.7</td><td>堆</td><td>可设置:默认60013</td></tr><tr><td>1.8</td><td>元空间(堆)</td><td>可设置:最小1009</td></tr></tbody></table>\n<p>        通过以下代码剖析StringTable在内存中的存储方式. </p>\n<div>\n<pre><code class=\"language-java\">public static void main(String[] args) {\n        String str1 = \"Hello\";\n        String str2 = \"Hello\";\n        String str3 = new String(\"world\");\n        String str4 = new String(\"world\");\n    }</code></pre>\n</div>\n<blockquote>\n<p>         注意:像\"hello\",\"world\"这类常见字符串,<span style=\"color:#fe2c24;\">编译时期已创建好并存放于字符串池</span>.字符串常量池会返回一个<span style=\"color:#fe2c24;\">String对象引用</span>,当创建String str1 = \"hello\"时,先在字符串常量池中找,找到了<span style=\"color:#38d8f0;\">直接将字符串引用赋值给str1</span>.<img alt=\"\" height=\"1000\" src=\"image\\80292a4f373043338229e89fd5b931a4.png\" width=\"1200\"/></p>\n</blockquote>\n<p>         通过以上案例可以看出:1.<span style=\"color:#38d8f0;\">只要new都会产生一个唯一的对象</span>,2.<span style=\"color:#38d8f0;\">常量串创建String对象更高效.</span></p>\n<h3 id=\"%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%3Eintern%E6%96%B9%E6%B3%95\">     [ intern方法]</h3>\n<p><img alt=\"\" height=\"820\" src=\"image\\b35bb3a694c54aeeb1a91e15c18287b7.png\" width=\"1200\"/></p>\n<blockquote>\n<p>        <span style=\"color:#fe2c24;\">intern()</span>方法是一个Native方法(底层由C++实现无法观察到源码),其作用是将String创建的对象收到入池.如:</p>\n</blockquote>\n<div>\n<pre><code class=\"language-java\">char[] arr = new char[]{'h','e','l','l','o'};\nString str = new String(arr).intern();\nString str2 = \"hello\";\nSystem.out.println(str==str2);//输出true</code></pre>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/b6774b8311214f1c2ec8fe5e3837e186.gif\"/></p> 正在上传…重新上传取消正在上传…重新上传取消正在上传…重新上传取消\n</div>\n<p><img alt=\"\" height=\"642\" src=\"image\\e7dc1af565334cc281eee3d4a5e6c067.png\" width=\"1200\"/></p>\n<blockquote>\n<p>        调用<span style=\"color:#fe2c24;\">intern()</span>方法来创建字符串时,先到<span style=\"color:#fe2c24;\">字符串常量池</span>中寻找有没有与要创建的字符串<span style=\"color:#fe2c24;\">equals</span>相等的字符串.</p>\n<ul><li>如果有则返回字符串常量池中的地址.</li><li>如果没有则创建str到字符串常量池中并返回str的地址. </li></ul>\n</blockquote>\n<p>       如果上面例子中的String str2先创建,此时<span style=\"color:#38d8f0;\">字符串常量池已有\"hello</span>\",那么str.intern()就不会入池,并且创建一个新的对象.最后结果一定是<span style=\"color:#fe2c24;\">false</span>.</p>\n<blockquote>\n<p>        <span style=\"color:#fe2c24;\">注意</span>:char创建的字符数组的引用赋值给字符串时,并不会把本身引用直接赋值给字符串,因为如果这样做的话一但<span style=\"color:#38d8f0;\">改变</span><span style=\"color:#fe2c24;\">字符数组</span><span style=\"color:#38d8f0;\">那么</span><span style=\"color:#fe2c24;\">字符串</span><span style=\"color:#38d8f0;\">也会跟着改变</span>,所以需要<span style=\"color:#fe2c24;\">拷贝</span>(copyof)一份对象再赋值给字符串</p>\n</blockquote>\n<hr/>\n<h2 id=\"%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.%E7%90%86%E8%A7%A3%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8D%E5%8F%AF%E5%8F%98%3A\">3.理解字符串不可变:</h2>\n<h3 id=\"1.%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%E6%BA%90%E7%A0%81%E5%B7%B2%E6%8F%8F%E8%BF%B0%E7%9A%84%E5%BE%88%E6%B8%85%E6%A5%9A%3A\">        1.字符串是不可变的源码已描述的很清楚:</h3>\n<p><img alt=\"\" height=\"619\" src=\"image\\53a11f92577e4eb98ee72d4a309b9241.png\" width=\"1200\"/></p>\n<p>        <strong>该图可以清晰的看出:</strong></p>\n<blockquote>\n<ul><li>String类中的字符实际保存在,内部维护的value数组中.</li><li>String被final所修饰只能表示该类不能被继承.</li><li>value被final所修饰表明vale自身的值不能改变,即value引用的指向不能改变,但引用空间中的值可以被修改.</li><li>private才是字符串真正不能被修改的原因,被private修饰且没有提供可修改的公共接口.如setvalue().</li></ul>\n</blockquote>\n<h3 id=\"%C2%A02.%E6%89%80%E6%9C%89%E6%B6%89%E5%8F%8A%E5%88%B0%E5%8F%AF%E8%83%BD%E4%BF%AE%E6%94%B9%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%86%85%E5%AE%B9%E7%9A%84%E6%93%8D%E4%BD%9C%E9%83%BD%E6%98%AF%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%B0%E5%AF%B9%E8%B1%A1%2C%E6%94%B9%E5%8F%98%E7%9A%84%E6%98%AF%E6%96%B0%E5%AF%B9%E8%B1%A1.\">         2.所有涉及到可能修改字符串内容的操作都是创建一个新对象,改变的是新对象.</h3>\n<p>        由于博主使用JDK1.9不方便展示源码细节,感兴趣的朋友使用JDK1.8可以按住ctrl+鼠标左键在IDEAL中查看.</p>\n<hr/>\n<h2 id=\"%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%BF%AE%E6%94%B9%E4%B8%8E%E6%8B%BC%E6%8E%A5\">4.字符串的修改与拼接</h2>\n<h3 id=\"%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BF%AE%E6%94%B9\">        1.字符串修改</h3>\n<p>        所有涉及到字符串修改的操作和方法都会新建一个对象效率非常低下,如果要修改建议使用<span style=\"background-color:#fbd4d0;\">StringBuffer</span>或<span style=\"background-color:#fbd4d0;\">StringBuilder.</span></p>\n<pre><code class=\"language-java\">public static void main(String[] args) {\n        long start = System.currentTimeMillis();\n        String str = \"\";\n        for (int i = 0; i &lt; 10000; i++) {\n            str+=\"w\";\n        }\n        long end = System.currentTimeMillis();\n        System.out.println(end-start);\n\n        StringBuilder str1 = new StringBuilder(\"\");\n        start = System.currentTimeMillis();\n        for (int i = 0; i &lt; 10000; i++) {\n            str1.append(\"w\");\n        }\n        end = System.currentTimeMillis();\n        System.out.println(end-start);\n\n        StringBuffer str2 = new StringBuffer(\"\");\n        start = System.currentTimeMillis();\n        for (int i = 0; i &lt; 10000; i++) {\n            str2.append(\"w\");\n        }\n        end = System.currentTimeMillis();\n        System.out.println(end-start);\n}\n//19\n//1\n//1</code></pre>\n<hr/>\n<p></p>\n<h3 id=\"%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5\">        2.字符串拼接</h3>\n<pre><code class=\"language-java\">public static void test(){\n        String str1 = \"1\";\n        String str2 = \"2\";\n        String str3 = \"12\";\n        String str4 = str1+str2;\n        System.out.println(str3==str4);//false\n    }</code></pre>\n<blockquote>\n<p>str3在<span style=\"background-color:#fbd4d0;\">字符串常量</span>区,str4在<span style=\"background-color:#fbd4d0;\">堆上</span>. 二者地址必然不同. </p>\n</blockquote>\n<p><span style=\"background-color:#ff9900;\">str1+str2的微观操作解释: </span></p>\n<pre><code class=\"language-java\">0 ldc #14 &lt;a&gt;     //字符串常量池中的\"a\"\n 2 astore_1        //存放在局部变量表索引1位置处(当前方法为非静态，0处存放的是this)\n 3 ldc #15 &lt;b&gt;     //字符串常量池中的\"b\"\n 5 astore_2        //存放在局部变量表索引2位置处\n 6 ldc #16 &lt;ab&gt;    //字符串常量池中的\"ab\"\n 8 astore_3        //存放在局部变量表索引3位置处\n 9 new #9 &lt;java/lang/StringBuilder&gt;  //堆上创建StringBuilder\n12 dup                               //将堆上对象的地址复制到局部变量表中\n13 invokespecial #10 &lt;java/lang/StringBuilder.&lt;init&gt;&gt;   //init构造器初始化\n16 aload_1                                              //取出局部变量表中的\"a\"\n17 invokevirtual #11 &lt;java/lang/StringBuilder.append&gt;   //调用StringBuilder的append方法，将\"a\"添加apperd(\"a\")   \n20 aload_2                                              //取出局部变量表中的\"b\"\n21 invokevirtual #11 &lt;java/lang/StringBuilder.append&gt;   //调用StringBuilder的append方法，将\"b\"添加apperd(\"b\")  \n24 invokevirtual #12 &lt;java/lang/StringBuilder.toString&gt; //toString()转为字符串，\"ab\"\n27 astore 4                                             //\"ab\"存放在局部变量表索引4位置处\n29 return                                               //返回\n</code></pre>\n<p>  <span style=\"background-color:#38d8f0;\"> 由此可观察到字符串创建的三步骤: </span></p>\n<pre><code class=\"language-java\"> 9 new #9 &lt;java/lang/StringBuilder&gt;  //堆上创建StringBuilder\n12 dup                               //将堆上对象的地址复制到局部变量表中\n13 invokespecial #10 &lt;java/lang/StringBuilder.&lt;init&gt;&gt;   //init构造器初始化</code></pre>\n<blockquote>\n<p>间接说明<span style=\"background-color:#fbd4d0;\">new</span>关键字不是原子性的. </p>\n</blockquote>\n<ol><li> 堆上分配空间.</li><li>局部变量表储存对象的引用.</li><li>构造器初始化.</li></ol>\n<p><span style=\"background-color:#ff9900;\">str1+str2的宏观操作解释:</span></p>\n<ol><li>首先构建对象StringBuilder sb = new StringBuilder();</li><li><span style=\"background-color:#fbd4d0;\">sb.append(\"a\");</span></li><li><span style=\"background-color:#fbd4d0;\">sb.append(\"b\");</span></li><li><span style=\"background-color:#fbd4d0;\">sb.toString()</span>;//将缓冲区中的字符串对象返回.</li></ol>\n<hr/>\n<p>[<span style=\"background-color:#a2e043;\">拓展</span>]</p>\n<p><strong>字符串拼接操作不一定必须使用StringBuilder.</strong></p>\n<p>         如果拼接符号左右均是<span style=\"background-color:#fbd4d0;\">字符常量</span>或<span style=\"color:#0d0016;\"><span style=\"background-color:#fbd4d0;\">常量引用</span>(</span>被<span style=\"background-color:#fbd4d0;\">final修饰</span>),则仍然使用编译器优化而非<strong>StringBuilder.</strong></p>\n<pre><code class=\"language-java\">public static void test1(){\n        final String str1 = \"a\";\n        final String str2 = \"b\";\n        String str3 = \"ab\";\n        String str4 = str1+str2;\n        System.out.println(str3==str4);//true\n    }</code></pre>\n<p><img alt=\"\" height=\"334\" src=\"image\\bac8f44f65ff4d618d33c7392aa07743.png\" width=\"790\"/></p>\n<hr/>\n<p>总得来说字符串拼接需要<span style=\"background-color:#fbd4d0;\">注意四点</span>:</p>\n<ol><li>常量与常量的拼接结果在字符串常量池中,原理是编译器优化.</li><li>常量池中不会存在相同的内容.</li><li>只要拼接对象有一个是变量,结果就在<span style=\"background-color:#fbd4d0;\">堆上的非字符串常量</span>中,原理是StringBuilder字符串缓冲区.</li><li>拼接结果调用<span style=\"background-color:#fbd4d0;\">intern()</span>方法,将字符串常量池中没有的对象放入,<span style=\"color:#fe2c24;\">返回该对象的地址</span>.</li></ol>\n<blockquote>\n<p>常量或者被final修饰的变量,在编译器可以确定所以防止常量池中.</p>\n<p>变量由于其引用地址不确定所以不能放入常量池只能在堆上创建.</p>\n</blockquote>\n<hr/>\n<p><strong><span style=\"background-color:#a2e043;\">[常见面试题测试]:</span></strong></p>\n<pre><code class=\"language-java\">public static void test2() {\n        String str1 = \"a\"+\"b\"+\"c\";\n        String str2 = \"abc\";\n        System.out.println(str1==str2);\n        System.out.println(str1.equals(str2));\n    }\n//true\n//true</code></pre>\n<blockquote>\n<p> str1中拼接的都是<span style=\"background-color:#fbd4d0;\">字符串常量</span>编译期就已确定.</p>\n</blockquote>\n<pre><code class=\"language-java\">public static void test3(){\n        String str1 = \"hello\";\n        String str2 = \"world\";\n\n        String str3 = \"helloworld\";\n        String str4 = \"hello\"+\"world\";\n        String str5 = str1+\"world\";\n        String str6 = \"hello\"+str2;\n        String str7 = str1+str2;\n        System.out.println(str3==str4);//true\n        System.out.println(str3==str5);//false\n        System.out.println(str3==str6);//false\n        System.out.println(str3==str7);//false\n        System.out.println(str5==str6);//false\n        System.out.println(str5==str7);//false\n        System.out.println(str6==str7);//false\n        String str8 = str6.intern();\n        System.out.println(str3==str8);//true\n    }</code></pre>\n<pre><code class=\"language-java\"> String str5 = str1+\"world\";//此时str1为一个引用变量</code></pre>\n<blockquote>\n<p>拼接前后出现变量则存放在<span style=\"background-color:#fbd4d0;\">堆空间</span>中,与<span style=\"background-color:#fbd4d0;\">字符串常量池</span>中的地址必然不一样.</p>\n</blockquote>\n<pre><code class=\"language-java\">String str3 = \"helloworld\";\nString str8 = str6.intern();\nSystem.out.println(str3==str8);//true</code></pre>\n<blockquote>\n<p>此时<span style=\"background-color:#fbd4d0;\">字符串常量池</span>中已有\"helloworld\",调用<span style=\"background-color:#fbd4d0;\">intern()</span>会返回字符串常量池中的地址,被str8接收那么二者地址必然一样,</p>\n</blockquote>\n<hr/>\n<h2 id=\"%C2%A05.new%20String%E7%9A%84%E8%AE%A8%E8%AE%BA\"> 5.new String的讨论</h2>\n<p>[<span style=\"background-color:#a2e043;\">讨论一</span>]</p>\n<pre><code class=\"language-java\"> String s = new String(\"ab\");</code></pre>\n<p><span style=\"background-color:#fbd4d0;\">new String(\"ab\")</span>为什么会创建两个对象?</p>\n<p><img alt=\"\" height=\"461\" src=\"image\\2a9cb33d6e3c431db73056a8638f7452.png\" width=\"890\"/></p>\n<blockquote>\n<ol><li><span style=\"background-color:#fbd4d0;\">堆</span>上创建了一个.</li><li> <span style=\"background-color:#fbd4d0;\">字符串常量池</span>中创建了一个,如果之前没有的话.</li></ol>\n</blockquote>\n<pre><code class=\"language-java\"> public static void test4(){\n        String s = new String(\"a\")+new String(\"b\");//创建了几个对象?\n        System.out.println(s);\n    }</code></pre>\n<ul><li>对象一:<span style=\"background-color:#fbd4d0;\">new StringBuilder().</span></li><li>对象二:<span style=\"background-color:#fbd4d0;\">new String(\"a\").</span></li><li>对象三:字符串常量池中的<span style=\"background-color:#fbd4d0;\">\"a\".</span></li><li>对象四:<span style=\"background-color:#fbd4d0;\">new String(\"b\").</span></li><li>对象五:字符串常量池中的<span style=\"background-color:#fbd4d0;\">\"b\".</span></li><li>对象六:<span style=\"background-color:#fbd4d0;\">StringBuilder.toString().</span></li></ul>\n<blockquote>\n<p><span style=\"background-color:#fbd4d0;\">StringBuilder.toString()</span>.<span style=\"color:#0d0016;\">剖析:</span></p>\n<p>该操作相当于把<span style=\"background-color:#fbd4d0;\">字符串缓冲区</span>中的字符串对象返回,但不会返回到<span style=\"background-color:#fbd4d0;\">字符串常量池</span>,只会在堆上创建一个对象 <span style=\"background-color:#fbd4d0;\">new String(\"ab\")</span>.</p>\n</blockquote>\n<p> <img alt=\"\" height=\"545\" src=\"image\\1e22c928793c430bbea81c80442dd8d8.png\" width=\"784\"/></p>\n<p> 我们发现没有<strong>idc指令</strong>,其实就是拼接完没有往常量池中放一份.</p>\n<p>[<span style=\"background-color:#a2e043;\">讨论二</span>]</p>\n<pre><code class=\"language-java\">public static void test5(){\n        String str1 = new String(\"1\");\n        str1.intern();//字符串常量池中已有\"1\"\n        String str2 = \"1\";\n        System.out.println(str1==str2);//false\n        \n        String str3 = new String(\"1\")+new String(\"1\");\n        str3.intern();//字符串常量池中没有\"11\"\n        String str4 = \"11\";\n        System.out.println(str3==str4);//true\n    }</code></pre>\n<blockquote>\n<p>        str1在先在<span style=\"background-color:#fbd4d0;\">堆</span>上创建一个对象,再到<span style=\"background-color:#fbd4d0;\">字符串常量池</span>中创建一个对象,str1指向的是<span style=\"background-color:#fbd4d0;\">堆</span>上的对象.因为常量池中已有\"1\",所以<span style=\"background-color:#fbd4d0;\">str1.intern();</span>没有任何效果.st1与str2地址不一致.</p>\n<p>        str3拼接的对象创建在<span style=\"background-color:#fbd4d0;\">堆</span>上,且不会在<span style=\"background-color:#fbd4d0;\">字符串常量池</span>中创建(<span style=\"color:#38d8f0;\">原理上文已阐述</span>),因此 <span style=\"background-color:#fbd4d0;\">str3.intern();</span>这项操作会把str3所指对象置于常量池中.str3与str4地址一致.</p>\n</blockquote>\n<hr/>\n<p></p>\n<h1 id=\"%E4%B8%89.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C\"><span style=\"color:#0d0016;\"><span style=\"background-color:#38d8f0;\">三.字符串常见操作</span></span></h1>\n<h2 id=\"1.%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83\">1.字符串比较</h2>\n<p>        字符串比较是比较常见的操作之一,java提供了四种比较方式.</p>\n<h3 id=\"%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A01)%3D%3D%E6%AF%94%E8%BE%83%E6%98%AF%E5%90%A6%E5%BC%95%E7%94%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1\">        1)==比较是否引用同一个对象</h3>\n<blockquote>\n<p>注意:对于<span style=\"background-color:#fbd4d0;\">内置类型</span>==比较的是变量中的值,对于<span style=\"background-color:#fbd4d0;\">引用类型</span>则比较的是地址.</p>\n</blockquote>\n<pre><code class=\"language-java\"> public static void test7(){\n        int a = 10;\n        int b = 3;\n        int c = 10;\n        System.out.println(a==b);//false\n        System.out.println(a==c);//true\n\n        String s1 = \"hello\";\n        String s2 = new String(\"hello\");\n        String s3 = \"hello\";\n        System.out.println(s1==s2);//false\n        System.out.println(s2==s3);//true\n    }</code></pre>\n<h3 id=\"%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202)boolean%20equals(Object%20anObject)%E6%96%B9%E6%B3%95%3A%E6%8C%89%E5%AD%97%E7%AC%A6%E5%A4%A7%E5%B0%8F%E9%A1%BA%E5%BA%8F%E6%AF%94%E8%BE%83.\">        2)boolean equals(Object anObject)方法:按字符大小顺序比较.</h3>\n<blockquote>\n<p>父类中的<span style=\"background-color:#fbd4d0;\">equals()</span>方法同样是比较地址,只不过String<span style=\"background-color:#fbd4d0;\">重写</span>了该方法.</p>\n</blockquote>\n<p><img alt=\"\" height=\"569\" src=\"image\\ff2fdab83a4d4db88e444f2c42e587cb.png\" width=\"1200\"/></p>\n<h3 id=\"%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A03)int%20compareTo(String%20s)%E6%96%B9%E6%B3%95%3A%E6%8C%89%E5%AD%97%E5%85%B8%E5%BA%8F%E6%AF%94%E8%BE%83\">        3)int compareTo(String s)方法:按字典序比较</h3>\n<blockquote>\n<p>与equals()不同的是equals返回的是boolean类型的值,compareTo返回的是int类型的值.</p>\n<ul><li>先按照字典次序比较,如果出现不相等的字符,直接返回两字符大小的差值.</li><li>如果前k个字符相等(k为最小字符串的长度),返回两字符串长度的差值.</li></ul>\n</blockquote>\n<pre><code class=\"language-java\"> public static void test8(){\n        String s1 = \"abc\";\n        String s2 = \"ac\";\n        String s3 = \"abc\";\n        String s4 = \"abcdef\";\n        System.out.println(s1.compareTo(s2));//字符差值为1\n        s1.compareTo(s3);//相同0\n        s1.compareTo(s4);//长度差值-3\n    }</code></pre>\n<h3 id=\"%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A04)int%20compareToIgnoreCase(String%20s)%E6%96%B9%E6%B3%95%3A%E4%B8%8EcompareTo%E6%96%B9%E6%B3%95%E7%9B%B8%E5%90%8C%E5%8F%AA%E6%98%AF%E5%BF%BD%E7%95%A5%E5%A4%A7%E5%B0%8F%E5%86%99.\">         4)int compareToIgnoreCase(String s)方法:与compareTo方法相同只是忽略大小写.</h3>\n<pre><code class=\"language-java\">public static void test8(){\n        String s1 = \"abc\";\n        String s2 = \"ac\";\n        String s3 = \"Abc\";\n        String s4 = \"abcdef\";\n        System.out.println(s1.compareTo(s2));//字符差值为1\n        s1.compareTo(s3);//相同0\n        s1.compareTo(s4);//长度差值-3\n    }</code></pre>\n<hr/>\n<p></p>\n<h2 id=\"2.%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE\">2.字符串查找</h2>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px;\"><tbody><tr><td>方法</td><td>功能</td></tr><tr><td>charAt(char index)</td><td>返回index位置上的字符,如果index为负数或者越界,抛出异常IndexOutOfBoundsException异常.</td></tr><tr><td> <p>int indexOf(char</p> <p> ch)</p> </td><td>返回ch第一次出现的位置,没有返回-1.</td></tr><tr><td>int indexOf(char ch,int fromIndex)</td><td>从fromIndex位置开始找ch第一次出现的位置,没有返回-1.</td></tr><tr><td>int indexOf(String str)</td><td>返回str第一次出现的位置,没有返回-1.</td></tr><tr><td>int indexOf(String str,int fromIndex)</td><td>从fromIndex位置开始找第一次出现的str的位置,没有返回-1.</td></tr><tr><td>int lastIndexOf(char ch)</td><td>从后往前寻找ch第一次出现的位置,没有返回的-1.</td></tr><tr><td>int lastIndexOf(char ch,int fromIndex)</td><td>从fromIndex开始从后往前寻找第一次出现ch的位置,没有返回-1.</td></tr><tr><td>int lastIndeOf(String str)</td><td>从后往前寻找str第一次出现的位置,没有返回-1.</td></tr><tr><td>int lastIndexOF(String str,int fromIndex)</td><td>从Index位置开始从后往前寻找str第一次出现的位置,没有返回-1.</td></tr></tbody></table>\n<p></p>\n<pre><code class=\"language-java\">public static void test9(){\n        String str = \"aaabbbcccaabbccdd\";\n        System.out.println(str.charAt(3));//b\n        System.out.println(str.indexOf('b'));//3\n        System.out.println(str.indexOf('b',6));//11\n        System.out.println(str.indexOf(\"bbb\"));//3\n        System.out.println(str.lastIndexOf('c'));//14\n        System.out.println(str.lastIndexOf('b',6));//5\n    }</code></pre>\n<blockquote>\n<p>注意:上述方法都是实例方法. </p>\n</blockquote>\n<hr/>\n<p></p>\n<h2 id=\"3.%E8%BD%AC%E6%8D%A2\">3.转换</h2>\n<h3 id=\"%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A01)%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2\">        1)数组与字符串转换</h3>\n<pre><code class=\"language-java\">public static void test10(){\n        String s1 = String.valueOf(123);//整形转字符串\n        String s2 = String.valueOf(12.3);//浮点型转字符串\n        String s3 = String.valueOf(true);//布尔型转字符串\n        String s4 = String.valueOf(new Student(\"zhangsan\",18));\n        System.out.println(s1);\n        System.out.println(s2);\n        System.out.println(s3);\n        System.out.println(s4);\n        System.out.println(\"============================================\");\n        //字符串转数组\n        int x = Integer.parseInt(s1);\n        double y = Double.parseDouble(s2);\n        System.out.println(x);\n        System.out.println(y);\n    }</code></pre>\n<blockquote>\n<p> 注意:以上为<span style=\"background-color:#fbd4d0;\">静态方法.</span></p>\n</blockquote>\n<h3 id=\"%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A02)%E5%A4%A7%E5%B0%8F%E5%86%99%E8%BD%AC%E6%8D%A2\">        2)大小写转换</h3>\n<pre><code class=\"language-java\">public static void test10(){\n        String str1 = \"abcdef\";\n        String str2 = \"ABCDEF\";\n        System.out.println(str1.toUpperCase().equals(str2));//true\n        System.out.println(str2.toLowerCase().equals(str1));//true\n}</code></pre>\n<h3 id=\"%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A03)%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B0%E7%BB%84\">        3)字符串转数组</h3>\n<pre><code class=\"language-java\">public static void test10(){\n        String s = \"hello\";\n        //字符串转数组\n        char[] ch = s.toCharArray();\n        for (int i = 0; i &lt; ch.length; i++) {\n            System.out.print(ch[i]+\" \");\n        }\n        //数组转字符串\n        String s1 = new String(ch);\n        System.out.println(s1);\n}</code></pre>\n<h3 id=\"%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A04)%E6%A0%BC%E5%BC%8F%E5%8C%96\">        4)格式化</h3>\n<pre><code class=\"language-java\">public static void test10(){\n        String s = String.format(\"%d-%d-%d\",2019,8,19);\n        System.out.println(s);//2019-8-19\n}</code></pre>\n<hr/>\n<p></p>\n<h2 id=\"4.%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9B%BF%E6%8D%A2\">4.字符串替换</h2>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px;\"><tbody><tr><td>方法</td><td>功能</td></tr><tr><td>String replaceAll(String regex,String replacement)</td><td>替换所有指定内容</td></tr><tr><td>String replaceFirst(String regex,String replacement)</td><td>替换首个指定内容</td></tr></tbody></table>\n<pre><code class=\"language-java\">  public static void test10(){\n        String str = \"helloworld\";\n        System.out.println(str.replace(\"l\",\"_\"));//he__owor_d\n        System.out.println(str.replaceFirst(\"l\",\"_\"));//he_loworld\n}</code></pre>\n<hr/>\n<p></p>\n<h2 id=\"5.%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%86%E5%88%86\">5.字符串拆分</h2>\n<p>        可以将一个完整的字符串按照指定的<span style=\"background-color:#fbd4d0;\">分隔符</span>划分为若干个子字符串.</p>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px;\"><tbody><tr><td>方法</td><td>功能</td></tr><tr><td>String[] split(String regex)</td><td>将字符串区别拆分</td></tr><tr><td>String[] split(String regex,int limit)</td><td>将字符串以指定形式拆分为limit组.</td></tr></tbody></table>\n<h3 id=\"%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A01)%E5%AE%9E%E7%8E%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%86%E5%88%86%E5%A4%84%E7%90%86\">        1)实现字符串拆分处理</h3>\n<pre><code class=\"language-java\">public static void test10(){\n        String str = \"hello world hello friend\";\n        String[] str2 = str.split(\" \");\n        for (String str1:str2) {\n            System.out.print(str1+\" \");\n        }\n}</code></pre>\n<h3 id=\"%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202)%E9%83%A8%E5%88%86%E6%8B%86%E5%88%86%E5%A4%84%E7%90%86\">        2)部分拆分处理</h3>\n<pre><code class=\"language-java\">public static void test10(){\n        String str = \"hello world hello friend\";\n        String[] str2 = str.split(\" \",2);\n        for (String str1:str2) {\n            System.out.print(str1);\n        }\n}</code></pre>\n<h3 id=\"%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A03)%E6%8B%86%E5%88%86%E7%BD%91%E5%9D%80\">         3)拆分网址</h3>\n<pre><code class=\"language-java\">public static void test10(){\n        String str = \"192.168.1.1\" ;\n        String[] result = str.split(\"\\\\.\") ;\n        for(String s: result) {\n            System.out.println(s);\n        }\n}</code></pre>\n<blockquote>\n<p>注意:</p>\n<ul><li>如果是\"|\",\"+\",\".\"等有含义字符需要加上转义字符 <span style=\"background-color:#fef2f0;\">\"\\\\\"</span>.</li><li>如果是\"\\\"就得写成<span style=\"background-color:#fbd4d0;\">\"\\\\\\\\\".</span></li><li>如果一个字符串有多个分隔符可以用\"|\"做连字符.</li></ul>\n</blockquote>\n<pre><code class=\"language-java\">public static void test10(){\n        String str = \"name|hansan&amp;age=18\";\n        String[] str2 = str.split(\"&amp;|=|\\\\|\");//[name=zhangsan,age=18]\n        for (String str1:\n             str2) {\n            System.out.println(str1);\n        }\n}</code></pre>\n<p></p>\n<h3 id=\"%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A04)%E5%A4%9A%E6%AC%A1%E6%8B%86%E5%88%86%20(%E5%BC%80%E5%8F%91%E4%B8%AD%E5%B8%B8%E7%94%A8)\">        4)多次拆分 (开发中常用)</h3>\n<pre><code class=\"language-java\">public static void test10(){\n        String str = \"name=zhansan&amp;age=18\";\n        String[] str2 = str.split(\"&amp;\");//[name=zhangsan,age=18]\n        for (int i = 0; i &lt; str2.length; i++) {\n            String[] temp = str2[i].split(\"=\");//[name,zhangsan,age,18]\n            System.out.println(temp[0]+\"=\"+temp[1]);\n        }\n}</code></pre>\n<hr/>\n<p></p>\n<h2 id=\"6.%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%88%AA%E5%8F%96\">6.字符串截取</h2>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px;\"><tbody><tr><td>方法</td><td>功能</td></tr><tr><td>String subString(int beginIndex)</td><td>从指定索引截取到末尾</td></tr><tr><td>String subString(int beginIndex,int endIndex)</td><td>截取部分内容</td></tr></tbody></table>\n<pre><code class=\"language-java\">public static void test10(){\n        String str = \"HelloWold\";\n        System.out.println(str.substring(5));//world\n        System.out.println(str.substring(0,5));//hello\n}</code></pre>\n<hr/>\n<p></p>\n<h2 id=\"7.%E5%85%B6%E4%BB%96%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95\">7.其他操作方法</h2>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px;\"><tbody><tr><td>方法</td><td>功能</td></tr><tr><td>String trim()</td><td>去掉字符串左右两边空格,保留中间空格</td></tr></tbody></table>\n<pre><code class=\"language-java\">public static void test10(){\n        String str = \"  Hello Wold  \";\n        System.out.println(str.trim());\n}</code></pre>\n<blockquote>\n<p><span style=\"background-color:#fbd4d0;\">trim()</span>方法会去掉左右两边的空格,制表符,回车键等..... </p>\n</blockquote>\n<hr/>\n<h1 id=\"%E5%9B%9B.StringBuffer%E4%B8%8EStringBuilder\"><span style=\"color:#0d0016;\"><span style=\"background-color:#38d8f0;\">四.StringBuffer与StringBuilder</span></span></h1>\n<p>        由于String类的不可变性,为了方便字符串的修,java提供了两种类StringBuffer和StringBuilder.接下来介绍常见的操作方法.</p>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px;\"><tbody><tr><td>方法</td><td>功能</td></tr><tr><td>StringBuilder append(String str)</td><td>尾部追加,相当于字符串的+=,可以追加: \n    <table><tbody><tr><td>boolean、char、char[]、<br/> double、float、int、long、Object、String、StringBuilder的变量</td></tr></tbody></table></td></tr><tr><td>char charAt(int index)</td><td>获取index位置的字符</td></tr><tr><td>int length()</td><td>获取字符串的长度</td></tr><tr><td>int capaticy</td><td>获取底层底层保存字符串空间的总的大小</td></tr><tr><td>void ensureCapaticy(int mininmumCapacity)</td><td>扩容</td></tr><tr><td>int indexOf(String str)</td><td>返回str第一次出现的位置</td></tr><tr><td>int indexOf(String str,int fromIndex)</td><td>从下标fromIndex开始返回第一次出现str的位置</td></tr><tr><td>int lastIndexOf(String str)</td><td>返回最后一次出现str的位置</td></tr><tr><td>int lastIndexOf(String str,int fromIndex)</td><td>从下标fromIndex开始返回最后一次出现strf的位置.</td></tr><tr><td>StringBuilder insert(int offset,String str)</td><td>在offset位置插入:八种基本数据类型,或String类型或Object类型</td></tr><tr><td>StringBuilder deleteCharAt(int index)</td><td>删除下标为index位置的元素</td></tr><tr><td>StringBuilder delete(int start,int end)</td><td>删除区间[strat,end)之间的元素</td></tr><tr><td>StringBuilder replace(int start,int end,String str)</td><td>将区间[start,end)之间的元素替换为str</td></tr><tr><td>String subString(int start)</td><td>从start开始一直到末尾的字符,以String类型返回</td></tr><tr><td>String subString(int start,int end)</td><td>将[start,end)区间的字符,以String类型返回.</td></tr><tr><td>StringBuilder reverse()</td><td>反转字符串</td></tr><tr><td>String toStrng()</td><td>将字符串按String的方式返回</td></tr><tr><td>void setCharAt(int index,char ch)</td><td>将index位置的字符替换为ch</td></tr></tbody></table>\n<pre><code class=\"language-java\">public static void test10(){\n        StringBuilder sb1 = new StringBuilder(\"hello\");\n        StringBuilder sb2 = sb1;\n        sb1.append(\"world\");//helloworld\n        sb1.append(123);//hellloworld123\n        System.out.println(sb1==sb2);//true\n        System.out.println(sb1.charAt(0));//获取0号位上的字符\n        System.out.println(sb1.length());//获取字符串的长度\n        System.out.println(sb1.capacity());//\n        sb1.setCharAt(0,'H');//Helloworld123\n        sb1.insert(0,\"Helloworld!!!\");//Helloworld!!!Helloworld123\n        System.out.println(sb1.indexOf(\"Hello\"));//获取Hello第一次出现的位置\n        System.out.println(sb1.lastIndexOf(\"Hello\"));//获取Hello最后一次出现的位置\n        sb1.deleteCharAt(0);//elloworld!!!Helloworld123\n        sb1.delete(0,5);//orld!!!Helloworld123\n        String str = sb1.substring(0,5);//orld!\n        System.out.println(str);\n        sb1.reverse();//321dlrowolleH!!!dlro\n        str = sb1.toString();\n        System.out.println(str);\n}\n</code></pre>\n<blockquote>\n<p>注意:String 与 StringBuilder不能直接转换</p>\n<ul><li>String转StringBuilder:利用StringBuilder的构造方法,或<span style=\"background-color:#fbd4d0;\">append()</span>方法.</li><li>StringBuilder转String:利用<span style=\"background-color:#fbd4d0;\">toString</span>方法.</li></ul>\n</blockquote>\n<hr/>\n<p><span style=\"background-color:#a2e043;\">[面试题 ]</span></p>\n<p>1.String,StringBuilder与StringBuffer的区别?</p>\n<ul><li>String不可修改,StringBuilder与StringBuffer可以修改且大部分功能相似.</li><li>StringBuffer采用同步处理线程更安全,但速度慢一点.StringBuilder未采用同步处理线程不安全,但速度更快.</li></ul>\n<p>2.以下共创建几个对象?<span style=\"background-color:#fbd4d0;\">[前提不考虑字符串常量池中存在]</span></p>\n<pre><code class=\"language-java\">String str1 = new String(\"hello\");//2\nString str2 = new String(\"world\")+new String(\"hehe\");//6</code></pre>\n<h1 id=\"String%E7%B1%BB%E7%AC%94%E8%AF%95%E9%A2%98%3A\"><span style=\"background-color:#38d8f0;\">五.String类笔试题:</span></h1>\n<h3 id=\"1.%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6\">1.第一个只出现一次的字符</h3>\n<p><img alt=\"\" height=\"953\" src=\"image\\0189881be2364fe0bfc7ca4bc8e5f4d2.png\" width=\"876\"/></p>\n<blockquote>\n<p>        由于只考虑小写字母,所以我们可以定义一个大小为<span style=\"background-color:#fbd4d0;\">26的整形数组</span>,每个字符<span style=\"background-color:#fbd4d0;\">-'a'</span>就会得到它数组中对于的位置, 该字符出现一次就给数组该位置的元素＋1,最后遍历字符串,如果字符在<span style=\"background-color:#fbd4d0;\">count数组</span>中对应的元素为一就返回该字符.</p>\n</blockquote>\n<pre><code class=\"language-java\">public static int firstUniqChar(String s) {//第一个只出现一次的字符\n        int[] count = new int[26];\n        for (int i = 0; i &lt; s.length(); i++) {\n            char ch = s.charAt(i);\n            count[ch-'a']++;\n        }\n        for (int i = 0; i &lt; s.length(); i++) {\n            char ch = s.charAt(i);\n            if (count[ch-'a']==1){\n                return i;\n            }\n        }\n        return -1;\n    }</code></pre>\n<hr/>\n<p></p>\n<h3 id=\"2)%E8%AE%A1%E7%AE%97%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6%C2%A0\">2)计算字符串最后一个单词的长度 </h3>\n<p><img alt=\"\" height=\"862\" src=\"image\\c18dfd367ca14318959151b47995c066.png\" width=\"1200\"/> 方法一:</p>\n<blockquote>\n<p>        用字符串的内置方法<span style=\"background-color:#fbd4d0;\">String[] split()</span>方法,以空格分隔字符串并保存与字符串数组中,返回数组最后一个元素即可. </p>\n</blockquote>\n<pre><code class=\"language-java\">import java.io.InputStream;\nimport java.util.Scanner;\npublic class Main{\n     public  static void  main(String [] args) throws Exception{\n        Scanner scanner = new Scanner(System.in);\n        String str  = scanner.nextLine();\n        String[] str1 = str.split(\" \");\n        String str2 = str1[str1.length-1];\n        System.out.println(str2.length());\n     }\n}</code></pre>\n<p> 方法二:</p>\n<blockquote>\n<p>        <span style=\"color:#fe2c24;\"> 更底层的做法较为推荐</span>,将字符串转换为字符数组,从后往前遍历数组,遇到空格返回数组长度-1与空格下标的<span style=\"background-color:#fbd4d0;\">差值</span>即可.</p>\n</blockquote>\n<pre><code class=\"language-java\">import java.io.InputStream;\nimport java.util.Scanner;\npublic class Main{\n     public  static void  main(String [] args) throws Exception{\n        Scanner scanner = new Scanner(System.in);\n        String str  = scanner.nextLine();\n        char[] arr = str.toCharArray();\n        int index = -1;\n        for(int i = arr.length-1;i&gt;=0;i--){\n           if(arr[i]==' '){\n               index = i;\n               break;\n           }\n       }\n         System.out.println(arr.length-1-index);\n     }\n}</code></pre>\n<hr/>\n<p></p>\n<h3 id=\"%C2%A03)%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2\"> 3)验证回文串</h3>\n<p><img alt=\"\" height=\"877\" src=\"image\\6c4158d179b64a7387063e8d6bfdfe97.png\" width=\"890\"/></p>\n<blockquote>\n<p>        题中明确说明只考虑数字字符和字母,所以我们可以构造一个方法判断字符串是否合法,涉及到包装类<span style=\"background-color:#fbd4d0;\">Character</span>的内置方法<span style=\"background-color:#fbd4d0;\">isDigit()</span>和<span style=\"background-color:#fbd4d0;\">isLetter().</span>题中强调不考虑字符的大小写,所以我们首先将字符串全部转换为小写或大写,然后定义首尾指针left和right比较字符串即可,注意比较时首先要满足<span style=\"background-color:#fbd4d0;\">left&lt;right</span>再考虑是否合法,比较后一定要记得<span style=\"background-color:#fbd4d0;\">移动指针</span>. </p>\n</blockquote>\n<pre><code class=\"language-java\"> public boolean isTrue(char ch){\n        if(Character.isDigit(ch)||Character.isLetter(ch)){\n            return true;\n        }\n        return false;\n    }\n    public boolean isPalindrome(String s) {\n        String str = s.toLowerCase();\n        int left = 0;\n        int rigth = str.length()-1;\n        while (left&lt;rigth){\n            while (left&lt;rigth&amp;&amp;!isTrue(str.charAt(left))){\n                left++;\n            }\n            while (left&lt;rigth&amp;&amp;!isTrue(str.charAt(rigth))){\n                rigth--;\n            }\n            if (str.charAt(left)!=str.charAt(rigth)){\n                return false;\n            }\n            left++;\n            rigth--;\n        }\n        return true;\n        \n    }</code></pre>\n<h3></h3>\n<hr/>\n<h3 id=\"%C2%A04)%E5%AD%97%E7%AC%A6%E9%9B%86%E5%90%88\"> 4)字符集合</h3>\n<p><img alt=\"\" height=\"981\" src=\"image\\c5694782988a42cb8e9baab8dbb3d1ae.png\" width=\"1200\"/></p>\n<blockquote>\n<p>         创建一个<span style=\"background-color:#fbd4d0;\">布尔数组</span>大小为所有字母的编码之和(<span style=\"background-color:#fbd4d0;\">122-65</span>),由于布尔数组默认初始化为<span style=\"background-color:#fbd4d0;\">false,</span>所以我们可以判断如果字符串对应的数组下标为<span style=\"background-color:#fbd4d0;\">false</span>,我们就将它拼接给<span style=\"background-color:#fbd4d0;\">StringBuilder</span>对象,并将该下标对应元素置为<span style=\"background-color:#fbd4d0;\">true</span>.最后以<span style=\"background-color:#fbd4d0;\">toString()</span>返回StringBuilde对象并打印即可.</p>\n</blockquote>\n<pre><code class=\"language-java\">public static String test(String s){\n        boolean[] arr = new boolean[58];\n        StringBuilder str = new StringBuilder();\n        for(int i = 0;i&lt;s.length();i++){\n               char ch = s.charAt(i);\n               if(arr[ch-'A']==false){\n                   str.append(ch);\n                   arr[ch-'A'']=true;\n               }\n           }\n        return str.toString();\n    }\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        while (scanner.hasNextLine()) { // 注意 while 处理多个 case\n           String s = scanner.nextLine();\n            System.out.println(test(s));\n        }\n    }</code></pre>\n<hr/>\n<p></p>\n<h1 id=\"%E6%80%BB%E7%BB%93\"><a id=\"_45\"></a>总结</h1>\n<blockquote>\n<p>        以上就是字符串深入剖析的全部内容,从<span style=\"color:#38d8f0;\">字符串最底层的常量池到基本操作方法和面试题</span>1万5千多字,码子字易如果对你有亿点点帮助和启发麻烦不要吝啬三连哦!</p>\n</blockquote>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\b34406e382cf4f6a86fcc843280836a2.jpeg\"/></p>\n<p></p>\n<p></p>\n</div>\n</div>"}