{"blogid": "122483942", "writerAge": "码龄1年", "writerBlogNum": "6", "writerCollect": "334", "writerComment": "20", "writerFan": "4171", "writerGrade": "2级", "writerIntegral": "229", "writerName": "奥利奥好吃呀", "writerProfileAdress": "writer_image\\profile_122483942.jpg", "writerRankTotal": "58739", "writerRankWeekly": "8200", "writerThumb": "147", "writerVisitNum": "30046", "blog_read_count": "22386", "blog_time": "于 2022-01-13 23:46:05 发布", "blog_title": "神经网络学习笔记1——BP神经网络原理到编程实现（matlab，python）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h1 id=\"%E5%85%88%E8%A1%A8%E8%BE%BE%E4%B8%80%E4%B8%8B%E6%AD%89%E6%84%8F%E5%90%A7\">先表达一下歉意吧</h1>\n<p>不好意思拖了这么久才整理，弄完考试的事情就在研究老师给安排的新任务，一时间还有点摸不到头脑，就直接把百度网盘链接放在视频下面了但是最近才发现那个链接发出来了看不到，所以现在有时间了就来重新整理一下！</p>\n<p>（发了之后看好多人管我要，我还奇怪，原来是没法出去o(╥﹏╥)o）</p>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"228\" src=\"image\\7d1b2b5db3f044f38dbb75338d023ddb.png\" width=\"357\"/></p>\n<div>\n<hr/>\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E5%85%88%E8%A1%A8%E8%BE%BE%E4%B8%80%E4%B8%8B%E6%AD%89%E6%84%8F%E5%90%A7-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%85%88%E8%A1%A8%E8%BE%BE%E4%B8%80%E4%B8%8B%E6%AD%89%E6%84%8F%E5%90%A7\">先表达一下歉意吧</a></p>\n<p id=\"-toc\" style=\"margin-left:40px;\"></p>\n<p id=\"%E4%B8%8B%E9%9D%A2%E6%98%AF%E8%A7%86%E9%A2%91%E5%9C%B0%E5%9D%80%E5%92%8C%E4%BB%A3%E7%A0%81%E6%95%B0%E6%8D%AE-toc\" style=\"margin-left:40px;\"><a href=\"#%E4%B8%8B%E9%9D%A2%E6%98%AF%E8%A7%86%E9%A2%91%E5%9C%B0%E5%9D%80%E5%92%8C%E4%BB%A3%E7%A0%81%E6%95%B0%E6%8D%AE\">下面是视频地址和代码数据</a></p>\n<p id=\"BP%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0_%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9_bilibili-toc\" style=\"margin-left:0px;\"><a href=\"#BP%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0_%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9_bilibili\">BP神经网络原理及编程实现_哔哩哔哩_bilibili</a></p>\n<p id=\"bp%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-toc\" style=\"margin-left:0px;\"><a href=\"#bp%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86\">1.bp神经网络原理</a></p>\n<p id=\"%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A01.1%E5%89%8D%E5%90%91%E4%BC%A0%E6%92%AD-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A01.1%E5%89%8D%E5%90%91%E4%BC%A0%E6%92%AD\">        1.1前向传播</a></p>\n<p id=\"%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A01.2%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A01.2%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD\">        1.2反向传播</a></p>\n<p id=\"%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A01.3%20%E6%B5%8B%E8%AF%95%E6%A8%A1%E5%9E%8B-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A01.3%20%E6%B5%8B%E8%AF%95%E6%A8%A1%E5%9E%8B\">        1.3 测试模型</a></p>\n<p id=\"2.%E4%B8%A4%E4%B8%AA%E9%A1%B9%E7%9B%AE%E7%9A%84matlab%E5%AE%9E%E7%8E%B0%E5%92%8Cpython%E5%AE%9E%E7%8E%B0-toc\" style=\"margin-left:0px;\"><a href=\"#2.%E4%B8%A4%E4%B8%AA%E9%A1%B9%E7%9B%AE%E7%9A%84matlab%E5%AE%9E%E7%8E%B0%E5%92%8Cpython%E5%AE%9E%E7%8E%B0\">2.两个项目的matlab实现和python实现</a></p>\n<p id=\"%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A02.1%E8%AF%AD%E9%9F%B3%E6%95%B0%E6%8D%AE%E5%88%86%E7%B1%BB%E9%A2%84%E6%B5%8B-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A02.1%E8%AF%AD%E9%9F%B3%E6%95%B0%E6%8D%AE%E5%88%86%E7%B1%BB%E9%A2%84%E6%B5%8B\">        2.1语音数据分类预测</a></p>\n<p id=\"%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0matlab%E5%AE%9E%E7%8E%B0%E5%A6%82%E4%B8%8B-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0matlab%E5%AE%9E%E7%8E%B0%E5%A6%82%E4%B8%8B\">                matlab实现如下</a></p>\n<p id=\"%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A02.2%20%E8%9D%B4%E8%9D%B6%E8%8A%B1%E5%88%86%E7%B1%BB%E9%A2%84%E6%B5%8B-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A02.2%20%E8%9D%B4%E8%9D%B6%E8%8A%B1%E5%88%86%E7%B1%BB%E9%A2%84%E6%B5%8B\">        2.2 蝴蝶花分类预测</a></p>\n<p id=\"%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A02.2.1matlab%E7%A8%8B%E5%BA%8F%E5%A6%82%E4%B8%8B-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A02.2.1matlab%E7%A8%8B%E5%BA%8F%E5%A6%82%E4%B8%8B\">                2.2.1matlab程序如下</a></p>\n<p id=\"%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A02.2.2%20python%E5%AE%9E%E7%8E%B0%E5%92%8C%E6%A1%86%E6%9E%B6%E5%A6%82%E4%B8%8B-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A02.2.2%20python%E5%AE%9E%E7%8E%B0%E5%92%8C%E6%A1%86%E6%9E%B6%E5%A6%82%E4%B8%8B\">                 2.2.2 python实现和框架如下</a></p>\n<p id=\"3.%E5%BF%83%E5%BE%97%E5%88%86%E4%BA%AB-toc\" style=\"margin-left:0px;\"><a href=\"#3.%E5%BF%83%E5%BE%97%E5%88%86%E4%BA%AB\">3.心得分享</a></p>\n<hr id=\"hr-toc\"/>\n<h2 id=\"%E4%B8%8B%E9%9D%A2%E6%98%AF%E8%A7%86%E9%A2%91%E5%9C%B0%E5%9D%80%E5%92%8C%E4%BB%A3%E7%A0%81%E6%95%B0%E6%8D%AE\">下面是视频地址和代码数据</h2>\n<div class=\"csdn-video-box\">\n<iframe allowfullscreen=\"true\" data-mediaembed=\"bilibili\" id=\"l2GTgNdv-1642085473693\" src=\"https://player.bilibili.com/player.html?aid=464978718\"></iframe>\n<p>BP神经网络原理及编程实现</p>\n</div>\n<h1 id=\"BP%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0_%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9_bilibili\"><a href=\"https://www.bilibili.com/video/BV1UL411j786?spm_id_from=333.999.0.0\" title=\"BP神经网络原理及编程实现_哔哩哔哩_bilibili\">BP神经网络原理及编程实现_哔哩哔哩_bilibili</a></h1>\n<p>python，matlab代码，还有数据集放在这里了</p>\n<p>链接：https://pan.baidu.com/s/1-onLcVrPR7csFWJkxhIMsg<br/> 提取码：j3z6</p>\n<p>感觉有帮助的话，可以点个赞支持一下，真的每次被赞的时候还是挺开心的哈哈(*^▽^*)</p>\n<h1 id=\"bp%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86\">1.bp神经网络原理</h1>\n<p>        bp神经网络主要由三部分组成，分别是前向传播，反向传播，测试模型。其中前向传播主要是计算模型当前的预测结果，反向传播是对模型进行修正得到能达到预测效果的模型，测试模型是看我们最后通过反向传播得到的模型能否识别出我们想要的分类，好下面我来分别介绍他们的原理~</p>\n<h2 id=\"%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A01.1%E5%89%8D%E5%90%91%E4%BC%A0%E6%92%AD\">        1.1前向传播</h2>\n<p>        我就拿一个三层的网络来举例说明，同时也是我后面讲得第一个项目，这样理论实践相结合，比较方便理解。</p>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"186\" src=\"image\\30f154d39b304e59858eb4f11d3f68af.png\" width=\"305\"/></p>\n<p>这是一个基础的三层神经网络，按顺序分别是输入层，隐藏层，输出层，我们先按照一个节点来看，这样方便理解，我把传播的公式放在下面</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\bcc864ec49b1454b8e65e714d4cb6f7e.png\"/></p>\n<p>其中a1作为输入的一个特征，在这里我们把特征数字化表示成一个数字</p>\n<p>w代表权重，其实按我理解，就是a1占多少分量，这个特征对我们识别目标帮助有多大</p>\n<p>b是一个偏差，方便我们对a2也就是下一个节点的值进行调整 </p>\n<p>z代表节点激活，这里用到了归激活函数sigmoid，对节点进行激活，按照我的理解sigmoid是一个归一化函数他要把归一化到0-1之间，方便收敛和标签值比较，判断误差，这样通过缩小误差来达到模型的预测功能。</p>\n<p>最后的得到的z3是前向传播的结果也就是我们模型预测结果分类标签。</p>\n<h2 id=\"%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A01.2%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD\">        1.2反向传播</h2>\n<p>        得到了前向传播的结果，相当于是一组用来训练的数据，我们要通过这次前向传播得到的结果和我们的分类标签相减得到误差。</p>\n<p>        我们希望缩小误差让我们的模型有更好的训练效果，这时候就要用到反向传播们这里用的是梯度下降法，让误差按照梯度的方向减小，最后训练打到我们预期的效果。</p>\n<p>         还是用我们刚才的神经网络</p>\n<p style=\"text-align:center;\">        <img alt=\"\" src=\"image\\f2dd8645fb044c7b9df3a72a4d8fbbc2.png\"/></p>\n<p>        这里是做的一个链式求导，可以左右对应着看，因为E对b直接进行求导得不到结果，通过链式展开，配合着左边的公式，其中每一部都是可以求出来的，结果如红字表示，这里感觉文字不太方便表述，要是实在还不清楚，就看一下最前面分享的视频，里面讲解的还是比较细致的</p>\n<p>        然后求w1,w2同理</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\6a3c5eebcc3d445aba3bc73c905138f7.png\"/></p>\n<p>         这样我们就能通过反向传播的到,b1,b2,w1,w2的变化率，然后和最开始随机得到的w和b进行运算就得到了我们通过这一组数据训练后的结果，在这里最重要的就是权重和偏差的数值了！</p>\n<h2 id=\"%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A01.3%20%E6%B5%8B%E8%AF%95%E6%A8%A1%E5%9E%8B\">        1.3 测试模型</h2>\n<p>        理解了前面两个测试模型其实就很好理解了，这里其实主要也是前向传播，我们用训练好的模型对测试集进行目标分类，在通过</p>\n<p>        正确预测/训练集总数 * 100% = 模型的准确率</p>\n<h1 id=\"2.%E4%B8%A4%E4%B8%AA%E9%A1%B9%E7%9B%AE%E7%9A%84matlab%E5%AE%9E%E7%8E%B0%E5%92%8Cpython%E5%AE%9E%E7%8E%B0\">2.两个项目的matlab实现和python实现</h1>\n<p>        对于这个程序要是看不懂的地方我记得在视频中有逐行对应的讲解，这里我们就大致标注一下</p>\n<h2 id=\"%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A02.1%E8%AF%AD%E9%9F%B3%E6%95%B0%E6%8D%AE%E5%88%86%E7%B1%BB%E9%A2%84%E6%B5%8B\">        2.1语音数据分类预测</h2>\n<h3 id=\"%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0matlab%E5%AE%9E%E7%8E%B0%E5%A6%82%E4%B8%8B\">                matlab实现如下</h3>\n<pre><code>%% 清空环境变量\nclc\nclear\n\n%% 训练数据预测数据提取及归一化\n\n%1.下载四类语音信号\nload data1 c1\nload data2 c2\nload data3 c3\nload data4 c4\n\n%2.四个特征信号矩阵合成一个矩阵\ndata(1:500,:)=c1(1:500,:);\ndata(501:1000,:)=c2(1:500,:);\ndata(1001:1500,:)=c3(1:500,:);\ndata(1501:2000,:)=c4(1:500,:);\n\n%3.从1到2000间随机排序\nk=rand(1,2000);%生成0-1之中2000个随机数\n[m,n]=sort(k);%对k进行从从小到大的排序，序结果放入m（1*2000）向量，n（1*2000）为原数据对应的索引号\n\n%4.输入输出数据\ninput=data(:,2:25);%取出data中2到25列数据构成新矩阵input\noutput1 =data(:,1);%取出data中第一列数据构成矩阵output1\n\n%5.把输出从1维变成4维\nfor i=1:2000\n    switch output1(i)\n        case 1\n            output(i,:)=[1 0 0 0];\n        case 2\n            output(i,:)=[0 1 0 0];\n        case 3\n            output(i,:)=[0 0 1 0];\n        case 4\n            output(i,:)=[0 0 0 1];\n    end\nend\n\n%6.随机提取1500个样本为训练样本，500个样本为预测样本\ninput_train=input(n(1:1500),:)';\noutput_train=output(n(1:1500),:)';\ninput_test=input(n(1501:2000),:)';\noutput_test=output(n(1501:2000),:)';\n\n%7.输入数据归一化\n[inputn,inputps]=mapminmax(input_train);%归一化到[-1,1]之间，inputps用来作下一次同样的归一化\n%%8.网络结构初始化，设置节点输入层，隐藏层，输出层\ninnum=24;\nmidnum=25;%选择多少个节点才比较好？\noutnum=4;\n \n\n%9.权值初始化\nw1=rands(midnum,innum);%随机给定隐藏层和是输入层间的初始神经元权重   W1= net. iw{1, 1};\nb1=rands(midnum,1);%中间各层神经元阈值  B1 = net.b{1};\nw2=rands(midnum,outnum);%中间层到输出层的权值  W2 = net.lw{2,1};\nb2=rands(outnum,1);%输出层各神经元阈值  B2 = net. b{2}\n\n%10.权重，偏差重新赋值\nw2_1=w2;w2_2=w2_1;%把w2中的值分别配给w1w2\nw1_1=w1;w1_2=w1_1;\nb1_1=b1;b1_2=b1_1;\nb2_1=b2;b2_2=b2_1;\n\n%11.学习率\nxite=0.1   %权值阈值更新\nalfa=0.01; %学习速率，这里设置为0.01\n\n%%12 网络训练\n%(1)大循环\nfor ii=1:10\n    E(ii)=0;\n    for i=1:1:1500\n       %% （2）网络预测输出 \n        x=inputn(:,i);\n        % (3)隐含层输出\n        for j=1:1:midnum\n            I(j)=inputn(:,i)'*w1(j,:)'+b1(j); \n            Iout(j)=1/(1+exp(-I(j)));\n        end\n        % (4)输出层输出\n        yn=w2'*Iout'+b2;\n        \n       %%(5) 权值阀值修正\n        %计算误差\n        e=output_train(:,i)-yn;     \n        E(ii)=E(ii)+sum(abs(e));\n        \n        %计算权值变化率\n        dw2=e*Iout;\n        db2=e';\n        \n        for j=1:1:midnum\n            S=1/(1+exp(-I(j)));\n            FI(j)=S*(1-S);\n        end      \n        for k=1:1:innum\n            for j=1:1:midnum\n                dw1(k,j)=FI(j)*x(k)*(e(1)*w2(j,1)+e(2)*w2(j,2)+e(3)*w2(j,3)+e(4)*w2(j,4));\n                db1(j)=FI(j)*(e(1)*w2(j,1)+e(2)*w2(j,2)+e(3)*w2(j,3)+e(4)*w2(j,4));\n            end\n        end\n          %（6）权值阈值更新，学习率在这用 \n        w1=w1_1+xite*dw1';\n        b1=b1_1+xite*db1';\n        w2=w2_1+xite*dw2';\n        b2=b2_1+xite*db2';\n        \n        w1_2=w1_1;w1_1=w1;\n        w2_2=w2_1;w2_1=w2;\n        b1_2=b1_1;b1_1=b1;\n        b2_2=b2_1;b2_1=b2;\n    end\nend\n \n\n%%13 语音特征信号分类\ninputn_test=mapminmax('apply',input_test,inputps);\n\nfor ii=1:1\n    for i=1:500%1500\n        %隐含层输出\n        for j=1:1:midnum\n            I(j)=inputn_test(:,i)'*w1(j,:)'+b1(j);\n            Iout(j)=1/(1+exp(-I(j)));\n        end\n        \n        fore(:,i)=w2'*Iout'+b2;\n    end\nend\n\n\n\n%% 14结果分析\n%（1）根据网络输出找出数据属于哪类\nfor i=1:500\n    output_fore(i)=find(fore(:,i)==max(fore(:,i)));\nend\n\n%（2）BP网络预测误差\nerror=output_fore-output1(n(1501:2000))';\n\n\n\n%画出预测语音种类和实际语音种类的分类图\nfigure(1)\nplot(output_fore,'r')\nhold on\nplot(output1(n(1501:2000))','b')\nlegend('预测语音类别','实际语音类别')\n\n%画出误差图\nfigure(2)\nplot(error)\ntitle('BP网络分类误差','fontsize',12)\nxlabel('语音信号','fontsize',12)\nylabel('分类误差','fontsize',12)\n\n%print -dtiff -r600 1-4\n\nk=zeros(1,4);  \n%找出判断错误的分类属于哪一类\nfor i=1:500\n    if error(i)~=0               %~表示非也就是error不等于0是\n        [b,c]=max(output_test(:,i));\n        switch c\n            case 1 \n                k(1)=k(1)+1;\n            case 2 \n                k(2)=k(2)+1;\n            case 3 \n                k(3)=k(3)+1;\n            case 4 \n                k(4)=k(4)+1;\n        end\n    end\nend\n\n%找出每类的个体和\nkk=zeros(1,4);\nfor i=1:500\n    [b,c]=max(output_test(:,i));\n    switch c\n        case 1\n            kk(1)=kk(1)+1;\n        case 2\n            kk(2)=kk(2)+1;\n        case 3\n            kk(3)=kk(3)+1;\n        case 4\n            kk(4)=kk(4)+1;\n    end\nend\n\n%正确率\nrightridio=(kk-k)./kk</code></pre>\n<p>  这个我在程序中进行了比较详细的备注，数据集在前面网盘链接中可以获取，这个项目的python文件是我完全仿照matlab中写了，流程基本一样，不太具有再利用价值，所以可以看下视频中的思路和讲解。</p>\n<h2 id=\"%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A02.2%20%E8%9D%B4%E8%9D%B6%E8%8A%B1%E5%88%86%E7%B1%BB%E9%A2%84%E6%B5%8B\">        2.2 蝴蝶花分类预测</h2>\n<p>        这里需要注意的是这里数据集是已经打乱好的数据，python中不在是墨守成规的仿照matlab文件，而是写好了一个框架，虽然是打乱的数据集，但是也配备了随机抽取数据的函数，方便大家拿了就用！！</p>\n<p>这里用的改进的bp神经网路，动量下降法进行加速收敛大致步骤原理公式如下</p>\n<div>\n<span style=\"color:#000000;\">Step 1</span>\n<span style=\"color:#000000;\">：初始化数据，设定各层节点数和学习效率等值。 </span>\n</div>\n<div>\n<span style=\"color:#000000;\">Step 2</span>\n<span style=\"color:#000000;\">：输入层 </span>\n<span style=\"color:#000000;\">FA </span>\n<span style=\"color:#000000;\">输入样品，计算出隐层 </span>\n<span style=\"color:#000000;\">FB </span>\n<span style=\"color:#000000;\">活动。 </span>\n</div>\n<div>\n<span style=\"color:#000000;\">b(ki)=logsig(a*V(:,ki)+Pi(ki)) </span>\n</div>\n<div>\n<span style=\"color:#000000;\">Step 3</span>\n<span style=\"color:#000000;\">：计算出输出层 </span>\n<span style=\"color:#000000;\">FC </span>\n<span style=\"color:#000000;\">活动。 </span>\n</div>\n<div>\n<span style=\"color:#000000;\">c(kj)=logsig(b*W(:,kj)+Tau(kj)) </span>\n</div>\n<div>\n<span style=\"color:#000000;\">Step 4</span>\n<span style=\"color:#000000;\">：网络输出和期望输出相比较，计算出输出层 </span>\n<span style=\"color:#000000;\">FC </span>\n<span style=\"color:#000000;\">的错误。 </span>\n</div>\n<div>\n<span style=\"color:#000000;\">d=c.*(1-c).*(ck-c) </span>\n</div>\n<div>\n<span style=\"color:#000000;\">Step 5</span>\n<span style=\"color:#000000;\">：反传，计算出隐层 </span>\n<span style=\"color:#000000;\">FB </span>\n<span style=\"color:#000000;\">的错误。 </span>\n</div>\n<div>\n<span style=\"color:#000000;\">e=b.*(1-b).*(d*W') </span>\n</div>\n<div>\n<span style=\"color:#000000;\">Step 6</span>\n<span style=\"color:#000000;\">：修改 </span>\n<span style=\"color:#000000;\">FC </span>\n<span style=\"color:#000000;\">层和 </span>\n<span style=\"color:#000000;\">FB </span>\n<span style=\"color:#000000;\">之间的权值 </span>\n<span style=\"color:#000000;\">wij</span>\n<span style=\"color:#000000;\">。 </span>\n</div>\n<div>\n<span style=\"color:#000000;\">DeltaW(ki,kj)=Alpha*b(ki)*d(kj)+Gamma*DeltaWOld(ki,kj) </span>\n</div>\n<div>\n<span style=\"color:#000000;\">W=W+DeltaW </span>\n</div>\n<div>\n<span style=\"color:#000000;\">Step 7</span>\n<span style=\"color:#000000;\">：修改 </span>\n<span style=\"color:#000000;\">FA </span>\n<span style=\"color:#000000;\">层和 </span>\n<span style=\"color:#000000;\">FB </span>\n<span style=\"color:#000000;\">之间的权值 </span>\n<span style=\"color:#000000;\">vhj</span>\n<span style=\"color:#000000;\">。 </span>\n</div>\n<div>\n<span style=\"color:#000000;\">DeltaV(kh,ki)=Beta*a(kh)*e(ki) </span>\n</div>\n<div>\n<span style=\"color:#000000;\">V=V+DeltaV </span>\n</div>\n<div>\n<span style=\"color:#000000;\">Step 8</span>\n<span style=\"color:#000000;\">：修改偏差。 </span>\n</div>\n<div>\n<span style=\"color:#000000;\">重复 </span>\n<span style=\"color:#000000;\">Step 2</span>\n<span style=\"color:#000000;\">～</span>\n<span style=\"color:#000000;\">Step 8</span>\n<span style=\"color:#000000;\">，直到输出层 </span>\n<span style=\"color:#000000;\">FC </span>\n<span style=\"color:#000000;\">的错误足够小。</span>\n</div>\n<h3 id=\"%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A02.2.1matlab%E7%A8%8B%E5%BA%8F%E5%A6%82%E4%B8%8B\">                2.2.1matlab程序如下</h3>\n<pre><code>clc %清屏\nclear all; %删除 workplace 变量\nclose all; %关掉显示图形窗口\nformat long \n% Initial \n% parameters for the NN structure \nh=4; \ni=3; \nj=3; \nAlpha=0.9; \nBeta=0.5; \nGamma=0.85; \nTor=0.0005; \nMaxepoch=2000;\nAccuracy=0; \nNtrain=115; \nNtest=35; \n%随机赋值 [-1, +1] \nV=2*(rand(h,i)-0.5); \nW=2*(rand(i,j)-0.5); \nPi=2*(rand(1,i)-0.5); \nTau=2*(rand(1,j)-0.5); \nDeltaWOld(i,j)=0; \nDeltaVOld(h,i)=0; \nDeltaPiOld(i)=0; \nDeltaTauOld(j)=0; \n% the learning process \nEpoch=1; \nError=10; \n%加载数据\nload data.dat \nOdesired=data(:,2); \n% normalize the input data to rang [-1 +1] \ndatanew=data(:,3:6); \nmaxv=max(max(datanew)); \nminv=min(min(datanew)); \ndatanorm=2*((datanew-minv)/(maxv-minv)-0.5); \nwhile Error&gt;Tor \n Err(Epoch)=0; \n for k=1:Ntrain % k = the index of tranning set \n a=datanorm(k,:); \n % set the desired output ck[j] \n if data(k,2)==0 \n ck=[1 0 0]; \n elseif data(k,2)==1 \n ck=[0 1 0]; \n else \n ck=[0 0 1]; \n end; \n % calculate the hidden nodes activation \n for ki=1:i \n b(ki)=logsig(a*V(:,ki)+Pi(ki)); \n end; \n % calculate the output nodes activation \n for kj=1:j \n c(kj)=logsig(b*W(:,kj)+Tau(kj)); \n end; \n % calculate error in output Layer FC \n d=c.*(1-c).*(ck-c); \n % calculate error in hidden layer FB \n e=b.*(1-b).*(d*W'); \n % adjust weights Wij between FB and FC \n for ki=1:i \n for kj=1:j \n DeltaW(ki,kj)=Alpha*b(ki)*d(kj)+Gamma*DeltaWOld(ki,kj); \n end \n end; \n W=W+DeltaW; \n DeltaWOld=DeltaW; \n % adjust weights Vij between FA and FB \n for kh=1:h \n for ki=1:i \n DeltaV(kh,ki)=Beta*a(kh)*e(ki); \n end\nend; \n V=V+DeltaV; \n DeltaVold=DeltaV; \n % adjust thresholds Pi and Tau \n DeltaPi=Beta*e+Gamma*DeltaPiOld; \n Pi=Pi+DeltaPi; \n DeltaPiold=DeltaPi; \n DeltaTau=Alpha*d+Gamma*DeltaTauOld; \n Tau=Tau+DeltaTau; \n DeltaTauold=DeltaTau; \n % the error is the max of d(1),d(2),d(3) \n Err(Epoch)=Err(Epoch)+0.5*(d(1)*d(1)+d(2)*d(2)+d(3)*d(3)); \n end %for k=1:Ntrain \n Err(Epoch)=Err(Epoch)/Ntrain; \n Error=Err(Epoch); \n % the training stops when iterate is too much \n if Epoch &gt; Maxepoch \n break; \n end \n Epoch = Epoch +1; % update the iterate number \nend \n% test data \nfor k=1:Ntest % k = the index of test set \n a=datanorm(Ntrain+k,:); \n % calculate the hidden nodes activation \n for ki=1:i \n b(ki)=logsig(a*V(:,ki)+Pi(ki)); \n end; \n % calculate the output of test sets \n for kj=1:j \n c(kj)=logsig(b*W(:,kj)+Tau(kj)); \n end; \n % transfer the output to one field format \n if (c(1)&gt; 0.9) \n Otest(k)=0; \n elseif (c(2)&gt; 0.9) \n Otest(k)=1; \n elseif (c(3)&gt; 0.9) \n Otest(k)=2; \n else \n Otest(k)=3; \n end; \n % calculate the accuracy of test sets \n if Otest(k)==Odesired(Ntrain+k) \n Accuracy=Accuracy+1; \n end; \nend; % k=1:Ntest \n% plot the error \nplot(Err); \n% plot the NN output and desired output during test \nN=1:Ntest; \nfigure; plot(N,Otest,'b-',N,Odesired(116:150),'r-'); \n% display the accuracy \nAccuracy = 100*Accuracy/Ntest; \nt=['正确率: ' num2str(Accuracy) '%' ]; \ndisp(t);</code></pre>\n<h3 id=\"%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A02.2.2%20python%E5%AE%9E%E7%8E%B0%E5%92%8C%E6%A1%86%E6%9E%B6%E5%A6%82%E4%B8%8B\">                 2.2.2 python实现和框架如下</h3>\n<p>        每一部分具体的功能都进行了标注</p>\n<pre><code class=\"language-python\">import math\nimport random\nimport numpy\nfrom sklearn import preprocessing\nimport time\nimport xlwt\nimport matplotlib.pyplot as plt\n\n\nrandom.seed(0)\n\ndef read_data(dir_str):\n    '''\n    读取txt文件中的数据\n    数据内容：科学计数法保存的多行多列数据\n    输入：txt文件的路径\n    输出：小数格式的数组，行列与txt文件中相同\n    '''\n    data_temp = []\n    with open(dir_str) as fdata:\n        while True:\n            line=fdata.readline()\n            if not line:\n                break\n            data_temp.append([float(i) for i in line.split()])\n    return numpy.array(data_temp)\n\n\ndef randome_init_train_test(data, n_tr):\n    ''' 随机划分训练集和测试集 '''\n    # sklearn提供一个将数据集切分成训练集和测试集的函数train_test_split\n    train_index = numpy.random.choice(data.shape[0], size=n_tr, replace=False, p=None)\n    train_data = data[train_index]  \n    test_index = numpy.delete(numpy.arange(data.shape[0]),train_index)  # 删除train_index对应索引的行数\n    test_data = data[test_index] \n    return train_data, test_data\n\n\ndef min_max_normalization(np_array):\n    ''' 离差标准化，(Xi-min(X))/(max(X)-min(X)) '''\n    min_max_scaler = preprocessing.MinMaxScaler()  \n    ret = min_max_scaler.fit_transform(np_array)  \n    return ret\n\n\ndef label_to_value(label):\n    ''' 标签转换为对应输出值 (由于输出层结构，需要修改输出数据结构)'''\n    switch = {\n        0.0: [1,0,0],\n        1.0: [0,1,0],\n        2.0: [0,0,1]\n    }\n    return switch[label]\n\n\ndef value_to_label(value):\n    ''' 神经网络输出值转换为对应标签 '''\n    return value.index(max(value)) \n\n\ndef rand(min, max):\n    ''' 随机取[a, b]范围内的值 '''\n    return (max - min) * random.random() + min\n\n\ndef make_matrix(m, n, fill=0.0):    # 生成多维矩阵\n    mat = []\n    for i in range(m):\n        mat.append([fill] * n)\n    return mat\n\n\ndef sigmoid(x):\n    return 1.0 / (1.0 + math.exp(-x))\n\n\ndef sigmoid_derivative(x):\n    return x * (1 - x)\n\n\nclass BPNeuralNetwork:\n    def __init__(self):  # 设置在BP神经网络中用到的参数\n        self.input_n = 0\n        self.hidden_n = 0\n        self.output_n = 0\n        self.input_values = []  # [1.0] * self.input_n\n        self.hidden_values = []  # [1.0] * self.hidden_n\n        self.output_values = []  # [1.0] * self.output_n\n        self.input_weights = []\n        self.output_weights = []\n        self.input_correction = []                     # dw1\n        self.output_correction = []                    # dw2\n        self.input_bias = []\n        self.output_bias = []\n\n    def setup(self, ni, nh, no):  # 参数设置\n        self.input_n = ni\n        self.hidden_n = nh\n        self.output_n = no\n        # init\n        self.input_values = [1.0] * self.input_n    # 输入层神经元输出（输入特征）\n        self.hidden_values = [1.0] * self.hidden_n  # 中间层神经元输出\n        self.output_values = [1.0] * self.output_n  # 隐藏层神经元输出（预测结果）\n        self.input_weights = make_matrix(self.input_n, self.hidden_n)\n        self.output_weights = make_matrix(self.hidden_n, self.output_n)\n        # 初始随机赋值，在范围[-1, +1]内\n        for i in range(self.input_n):\n            for h in range(self.hidden_n):\n                self.input_weights[i][h] = rand(-1, 1)\n        for h in range(self.hidden_n):\n            for o in range(self.output_n):\n                self.output_weights[h][o] = rand(-1, 1)\n        self.input_correction = make_matrix(self.input_n, self.hidden_n)\n        self.output_correction = make_matrix(self.hidden_n, self.output_n)\n        self.input_bias = [0.0] * self.input_n\n        self.output_bias = [0.0] * self.output_n\n\n    def predict(self, inputs):  # 前向传播（在train中套在反向传播的train前面）\n        # 输入层计算\n        for i in range(self.input_n - 1):\n            self.input_values[i] = inputs[i]\n        # 隐藏层计算\n        for j in range(self.hidden_n):\n            total = 0.0\n            for i in range(self.input_n):\n                total += self.input_values[i] * self.input_weights[i][j]\n            self.hidden_values[j] = sigmoid(total + self.input_bias[i])\n        # 输出层计算\n        for k in range(self.output_n):\n            total = 0.0\n            for j in range(self.hidden_n):\n                total += self.hidden_values[j] * self.output_weights[j][k]\n            self.output_values[k] = sigmoid(total + self.output_bias[j])\n        return self.output_values[:]\n\n    def back_propagate(self, case, label, learn, correct):\n        # 前向预测\n        self.predict(case)\n        # 计算输出层的误差 w2\n        output_deltas = [0.0] * self.output_n\n        for o in range(self.output_n):\n            error = label[o] - self.output_values[o]\n            output_deltas[o] = sigmoid_derivative(self.output_values[o]) * error\n        # 计算隐藏层的误差 w1\n        hidden_deltas = [0.0] * self.hidden_n\n        for h in range(self.hidden_n):\n            error = 0.0\n            for o in range(self.output_n):\n                error += output_deltas[o] * self.output_weights[h][o]\n            hidden_deltas[h] = sigmoid_derivative(self.hidden_values[h]) * error\n        # 更新隐藏-输出层权重 b2\n        for h in range(self.hidden_n):\n            for o in range(self.output_n):\n                change = output_deltas[o] * self.hidden_values[h]\n                self.output_weights[h][o] += learn * change + correct * self.output_correction[h][o]\n                self.output_correction[h][o] = change\n                self.output_bias[o] += learn * change\n        # 更新输入-隐藏层权重 b1\n        for i in range(self.input_n):\n            for h in range(self.hidden_n):\n                change = hidden_deltas[h] * self.input_values[i]\n                self.input_weights[i][h] += learn * change + correct * self.input_correction[i][h]\n                self.input_correction[i][h] = change\n                self.input_bias[h] += learn * change\n\n        # 计算样本的均方误差\n        error = 0.0\n        for o in range(len(label)):\n            error += 0.5 * (label[o] - self.output_values[o]) ** 2\n        return error\n\n    def train(self, datas, labels, epochs=5000, learn=0.05, correct=0.1, stop_error=0.001):\n        for j in range(epochs):\n            error = 0.0\n            for i in range(len(datas)):\n                label = labels[i]\n                data = datas[i]\n                error += self.back_propagate(data, label, learn, correct)\n            if error &lt;= stop_error:\n                return j+1\n        return epochs\n\ndef save_excel(datas, output_file):\n    # 将数据保存到新的excel表格里\n    # 因为xls文件支持最大数据行数为65536，所以大文件输出成几个小文件，每个小文件有MAX_EXCEL_ROWS行数据\n    MAX_EXCEL_ROWS = 60000\n    for no in range(0, datas.__len__()//MAX_EXCEL_ROWS + 1):\n        sheet_name = 'sheet' + str(no+1)\n        output_file_name = output_file.split('.')[0] + str(no+1) + '.' + output_file.split('.')[-1]\n        print('输出文件：', output_file_name)\n        excel = xlwt.Workbook() \n        sh = excel.add_sheet(sheet_name)\n        for i, data in enumerate(datas[no*MAX_EXCEL_ROWS:(no+1)*MAX_EXCEL_ROWS]):\n            for j, d in enumerate(data):\n                sh.write(i, j, d)\n        try:\n            excel.save(output_file_name)\n        except:\n            xxx = input('输出异常!!请检查输出路径是否异常或文件是否已存在(需删除已存在文件)。然后输入任意键即可...')\n            no = no - 1\n    print('结束gool luck')\n\nif __name__ == '__main__':\n    n_tr = 115\n    input_nodes = 4\n    hidden_nodes = 3        #\n    output_nodes = 3\n    epochs = 1000           \n    learn_rate = 0.5       # 学习率\n    momentum_rate = 0.09    # 动量参数\n    correct_rate = 0.1      # 矫正率\n\n    data = read_data(r\"D:\\优化大作业\\BPNN_Butterfly classification\\data.txt\")\n    normal_data = min_max_normalization(data[:, 2:])  # 变量归一化\n    data = numpy.concatenate((data[:, 1:2],normal_data),axis=1)  # 取出输出的结果和标准化的数据拼接在一起\n    tr, te = randome_init_train_test(data, n_tr)  # 随机划分训练集和测试集\n    tr_in = tr[:, 1:]\n    tr_out = [label_to_value(v[0]) for v in tr[:, :1]]  # 由于输出层使用3个节点，需要修改输出数据结构\n    n_true = 0      # 统计正确预测数量\n\n    nn = BPNeuralNetwork()  \n    nn.setup(input_nodes, hidden_nodes, output_nodes)   # 设置BP神经网络框架\n    st = time.perf_counter()\n    epoch = nn.train(tr_in, tr_out, epochs, learn_rate, correct_rate)   # train(self, datas, labels, epochs=5000, learn=0.05, correct=0.1, stop_error=0.001)\n    print('epoch:', epoch, '\\nTrain_time:', time.perf_counter() - st)\n    pre = []\n    for t in te:\n        t_in = t[1:]\n        label = value_to_label(nn.predict(t_in))\n        if label == t[0]:\n            n_true += 1\n        # print(t, label)\n        pre.append([label])\n    \n    # 输出统计结果\n    accuracy = n_true/(data.shape[0]-n_tr)\n    print('accuracy:', accuracy)\n    print(nn.input_bias, nn.output_bias)\n    # numpy.savetxt(r'bpnn_param\\input_weights.txt', (nn.input_weights), fmt='%s')\n    # numpy.savetxt(r'bpnn_param\\output_weights.txt', (nn.output_weights), fmt='%s')\n    # numpy.savetxt(r'bpnn_param\\input_correction.txt', (nn.input_correction), fmt='%s')\n    # numpy.savetxt(r'bpnn_param\\output_correction.txt', (nn.output_correction), fmt='%s')\n\n    # 将数据保存到新的excel表格里\n    te_pre = numpy.concatenate((te, numpy.array(pre)), axis=1)\n    save_excel(te_pre, 'test_result.xls')\n\n    # 绘制准确率曲线\n    x_axis_data = [i for i in range(35)]\n    y_axis_data1 = te[:, :1]    # 真实结果\n    y_axis_data2 = pre          # 预测结果\n    plt.xlabel('测试集数', fontproperties='SimHei')\n    plt.ylabel('预测分类', fontproperties='SimHei')\n    plt.plot(x_axis_data, y_axis_data1, color='blue', label='真实结果' )\n    plt.plot(x_axis_data, y_axis_data2, color='red', label='预测结果')\n    plt.show()</code></pre>\n<h1 id=\"3.%E5%BF%83%E5%BE%97%E5%88%86%E4%BA%AB\">3.心得分享</h1>\n<p>        经过自己的学习和研究，感觉可以先看懂公式，然后把程序导进去，用好断点，一步一步步进或者调试模式，看看得到的程序的结果和应该得出的结果得维数是不是相同，数据是否合理，研究透之后可以多自己写一写练一练，基本就没啥问题啦~</p>\n<p>        up也是刚开始学习，有什么问题可以多多交流，互相学习~</p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n</div>\n<p></p>\n</div>\n</div>"}