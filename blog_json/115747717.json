{"blogid": "115747717", "writerAge": "码龄6年", "writerBlogNum": "204", "writerCollect": "5003", "writerComment": "272", "writerFan": "1314", "writerGrade": "5级", "writerIntegral": "3708", "writerName": "非晚非晚", "writerProfileAdress": "writer_image\\profile_115747717.jpg", "writerRankTotal": "7624", "writerRankWeekly": "23390", "writerThumb": "806", "writerVisitNum": "287272", "blog_read_count": "11814", "blog_time": "已于 2022-03-20 21:13:26 修改", "blog_title": "一文详解C++多线程", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p></p>\n<div class=\"toc\">\n<h3>文章目录</h3>\n<ul><li><a href=\"#1__1\">1. 多线程</a></li><li><ul><li><a href=\"#11__8\">1.1 多进程与多线程</a></li><li><a href=\"#12__30\">1.2 多线程理解</a></li><li><a href=\"#13__39\">1.3 创建线程</a></li><li><a href=\"#14_joindetach_96\">1.4 join与detach方式</a></li><li><ul><li><a href=\"#1join_108\">（1）join举例</a></li><li><a href=\"#2detach_143\">（2）detach举例</a></li></ul>\n</li><li><a href=\"#15_this_thread_178\">1.5 this_thread</a></li></ul>\n</li><li><a href=\"#2_mutex_199\">2. mutex</a></li><li><ul><li><a href=\"#21_lockunlock_210\">2.1 lock与unlock</a></li><li><a href=\"#22_lock_guard_303\">2.2 lock_guard</a></li><li><a href=\"#23_unique_lock_349\">2.3 unique_lock</a></li></ul>\n</li><li><a href=\"#3_condition_variable_408\">3. condition_variable</a></li><li><ul><li><a href=\"#31_wait_426\">3.1 wait</a></li><li><a href=\"#32_wait_for_477\">3.2 wait_for</a></li></ul>\n</li><li><a href=\"#4__531\">4. 线程池</a></li><li><ul><li><a href=\"#41__532\">4.1 概念</a></li><li><a href=\"#42__545\">4.2 线程池的实现</a></li></ul>\n</li></ul>\n</div>\n<p></p>\n<h1><a id=\"1__1\"></a>1. 多线程</h1>\n<p>传统的C++（C++11之前）中并没有引入线程这个概念，在C++11出来之前，如果我们想要在C++中实现多线程，需要借助操作系统平台提供的API，比如Linux的&lt;pthread.h&gt;，或者windows下的&lt;windows.h&gt; 。</p>\n<p>C++11提供了语言层面上的多线程，包含在头文件&lt;thread&gt;中。它解决了跨平台的问题，提供了<code>管理线程、保护共享数据、线程间同步操作、原子操作等类</code>。C++11 新标准中引入了5个头文件来支持多线程编程，如下图所示：<br/> <img alt=\"在这里插入图片描述\" src=\"image\\20210428113430200.png\"/></p>\n<h2><a id=\"11__8\"></a>1.1 多进程与多线程</h2>\n<ul><li><strong>多进程并发</strong></li></ul>\n<p>使用多进程并发是将一个应用程序划分为多个独立的进程（每个进程只有一个线程），这些独立的进程间可以互相通信，共同完成任务。由于操作系统对进程提供了大量的保护机制，<code>以避免一个进程修改了另一个进程的数据，使用多进程比多线程更容易写出安全的代码</code>。但是这也造就了多进程并发的两个缺点：</p>\n<blockquote>\n<ol><li>在进程间的通信，无论是使用信号、套接字，还是文件、管道等方式，其使用要么<code>比较复杂</code>，要么就是<code>速度较慢</code>或者两者兼而有之。</li><li>运行多个线程的<code>开销很大</code>，操作系统要<code>分配很多的资源来对这些进程进行管理</code>。</li></ol>\n</blockquote>\n<p>由于多个进程并发完成同一个任务时，不可避免的是：<code>操作同一个数据和进程间的相互通信，上述的两个缺点也就决定了多进程的并发不是一个好的选择</code>。</p>\n<ul><li><strong>多线程并发</strong></li></ul>\n<p>多线程并发指的是在同一个进程中执行多个线程。</p>\n<p><strong>优点</strong>：</p>\n<blockquote>\n<p>有操作系统相关知识的应该知道，<code>线程是轻量级的进程</code>，每个线程可以独立的运行不同的指令序列，但是线程不独立的拥有资源，依赖于创建它的进程而存在。也就是说，<code>同一进程中的多个线程共享相同的地址空间，可以访问进程中的大部分数据，指针和引用可以在线程间进行传递</code>。这样，同一进程内的多个线程能够很方便的进行数据共享以及通信，也就比进程更适用于并发操作。</p>\n</blockquote>\n<p><strong>缺点</strong>：</p>\n<blockquote>\n<p>由于缺少操作系统提供的保护机制，在多线程共享数据及通信时，就需要<code>程序员做更多的工作</code>以保证对共享数据段的操作是以预想的操作顺序进行的，并且要极力的避免死锁(deadlock)。</p>\n</blockquote>\n<p>摘自《C++ 并发编程》</p>\n<h2><a id=\"12__30\"></a>1.2 多线程理解</h2>\n<ul><li>单CPU内核的多个线程。</li></ul>\n<p>一个时间片运行一个线程的代码，并不是真正意义的并行计算。<br/> <img alt=\"在这里插入图片描述\" src=\"image\\20210416084451659.png\"/></p>\n<ul><li>多个cpu或者多个内核</li></ul>\n<p>可以做到真正的并行计算。<br/> <img alt=\"在这里插入图片描述\" src=\"image\\2021041608452349.png\"/></p>\n<h2><a id=\"13__39\"></a>1.3 创建线程</h2>\n<p>创建线程很简单，只需要把函数添加到线程当中即可。</p>\n<ul><li>形式1：</li></ul>\n<pre><code class=\"prism language-cpp\">std<span class=\"token operator\">::</span>thread myThread <span class=\"token punctuation\">(</span> thread_fun<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//函数形式为void thread_fun()</span>\nmyThread<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//同一个函数可以代码复用，创建多个线程</span>\n</code></pre>\n<ul><li>形式2：</li></ul>\n<pre><code class=\"prism language-cpp\">std<span class=\"token operator\">::</span>thread myThread <span class=\"token punctuation\">(</span> <span class=\"token function\">thread_fun</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nmyThread<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//函数形式为void thread_fun(int x)</span>\n<span class=\"token comment\">//同一个函数可以代码复用，创建多个线程</span>\n</code></pre>\n<ul><li>形式3：</li></ul>\n<pre><code class=\"prism language-cpp\">std<span class=\"token operator\">::</span>thread <span class=\"token punctuation\">(</span>thread_fun<span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">detach</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//直接创建线程，没有名字</span>\n<span class=\"token comment\">//函数形式为void thread_fun(int x)</span>\n</code></pre>\n<ul><li>代码举例</li></ul>\n<p>使用g++编译下列代码的方式：<code>g++ test.cc -o test -l pthread</code></p>\n<pre><code class=\"prism language-cpp\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream&gt;</span></span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;thread&gt;</span></span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">thread_1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n    cout<span class=\"token operator\">&lt;&lt;</span><span class=\"token string\">\"子线程1\"</span><span class=\"token operator\">&lt;&lt;</span>endl<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">thread_2</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n    cout<span class=\"token operator\">&lt;&lt;</span><span class=\"token string\">\"x:\"</span><span class=\"token operator\">&lt;&lt;</span>x<span class=\"token operator\">&lt;&lt;</span>endl<span class=\"token punctuation\">;</span>\n  cout<span class=\"token operator\">&lt;&lt;</span><span class=\"token string\">\"子线程2\"</span><span class=\"token operator\">&lt;&lt;</span>endl<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n  thread first <span class=\"token punctuation\">(</span> thread_1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>     <span class=\"token comment\">// 开启线程，调用：thread_1()</span>\n  thread second <span class=\"token punctuation\">(</span>thread_2<span class=\"token punctuation\">,</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 开启线程，调用：thread_2(100)</span>\n  <span class=\"token comment\">//thread third(thread_2,3);//开启第3个线程，共享thread_2函数。</span>\n  std<span class=\"token operator\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"主线程\\n\"</span><span class=\"token punctuation\">;</span>\n\n  first<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//必须说明添加线程的方式            </span>\n  second<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n  std<span class=\"token operator\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"子线程结束.\\n\"</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//必须join完成</span>\n  <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h2><a id=\"14_joindetach_96\"></a>1.4 join与detach方式</h2>\n<p>当线程启动后，一定要在和线程相关联的thread销毁前，<strong>确定以何种方式等待线程执行结束</strong>。比如上例中的join。</p>\n<ul><li>detach方式，启动的线程自主在后台运行，当前的代码继续往下执行，不等待新线程结束。</li><li>join方式，等待启动的线程完成，才会继续往下执行。</li></ul>\n<p>可以使用joinable判断是join模式还是detach模式。</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>myThread<span class=\"token punctuation\">.</span><span class=\"token function\">joinable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> foo<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h3><a id=\"1join_108\"></a>（1）join举例</h3>\n<p>下列代码中，join后面的代码不会被执行，除非子线程结束。</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream&gt;</span></span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;thread&gt;</span></span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">thread_1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token comment\">//cout&lt;&lt;\"子线程1111\"&lt;&lt;endl;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">thread_2</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token comment\">//cout&lt;&lt;\"子线程2222\"&lt;&lt;endl;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n    thread first <span class=\"token punctuation\">(</span> thread_1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>     <span class=\"token comment\">// 开启线程，调用：thread_1()</span>\n    thread second <span class=\"token punctuation\">(</span>thread_2<span class=\"token punctuation\">,</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 开启线程，调用：thread_2(100)</span>\n\n    first<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>                <span class=\"token comment\">// pauses until first finishes 这个操作完了之后才能destroyed</span>\n    second<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>               <span class=\"token comment\">// pauses until second finishes//join完了之后，才能往下执行。</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{<!-- --></span>\n        std<span class=\"token operator\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"主线程\\n\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h3><a id=\"2detach_143\"></a>（2）detach举例</h3>\n<p>下列代码中，主线程不会等待子线程结束。如果主线程运行结束，程序则结束。</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream&gt;</span></span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;thread&gt;</span></span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">thread_1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{<!-- --></span>\n        cout<span class=\"token operator\">&lt;&lt;</span><span class=\"token string\">\"子线程1111\"</span><span class=\"token operator\">&lt;&lt;</span>endl<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">thread_2</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{<!-- --></span>\n        cout<span class=\"token operator\">&lt;&lt;</span><span class=\"token string\">\"子线程2222\"</span><span class=\"token operator\">&lt;&lt;</span>endl<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n    thread first <span class=\"token punctuation\">(</span> thread_1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>     <span class=\"token comment\">// 开启线程，调用：thread_1()</span>\n    thread second <span class=\"token punctuation\">(</span>thread_2<span class=\"token punctuation\">,</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 开启线程，调用：thread_2(100)</span>\n\n    first<span class=\"token punctuation\">.</span><span class=\"token function\">detach</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>                \n    second<span class=\"token punctuation\">.</span><span class=\"token function\">detach</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>            \n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{<!-- --></span>\n        std<span class=\"token operator\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"主线程\\n\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h2><a id=\"15_this_thread_178\"></a>1.5 this_thread</h2>\n<p>this_thread是一个类，它有4个功能函数，具体如下：</p>\n<table><thead><tr><th>函数</th><th>使用</th><th>说明</th></tr></thead><tbody><tr><td>get_id</td><td>std::this_thread::get_id()</td><td>获取线程id</td></tr><tr><td>yield</td><td>std::this_thread::yield()</td><td>放弃线程执行，回到就绪状态</td></tr><tr><td>sleep_for</td><td>std::this_thread::sleep_for(std::chrono::seconds(1));</td><td>暂停1秒</td></tr><tr><td>sleep_until</td><td>如下</td><td>一分钟后执行吗，如下</td></tr></tbody></table>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">using</span> std<span class=\"token operator\">::</span>chrono<span class=\"token operator\">::</span>system_clock<span class=\"token punctuation\">;</span>\nstd<span class=\"token operator\">::</span>time_t tt <span class=\"token operator\">=</span> system_clock<span class=\"token operator\">::</span><span class=\"token function\">to_time_t</span><span class=\"token punctuation\">(</span>system_clock<span class=\"token operator\">::</span><span class=\"token function\">now</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">struct</span> std<span class=\"token operator\">::</span>tm <span class=\"token operator\">*</span> ptm <span class=\"token operator\">=</span> std<span class=\"token operator\">::</span><span class=\"token function\">localtime</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>tt<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ncout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Waiting for the next minute to begin...\\n\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token operator\">++</span>ptm<span class=\"token operator\">-</span><span class=\"token operator\">&gt;</span>tm_min<span class=\"token punctuation\">;</span> <span class=\"token comment\">//加一分钟</span>\nptm<span class=\"token operator\">-</span><span class=\"token operator\">&gt;</span>tm_sec <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//秒数设置为0</span>\n<span class=\"token comment\">//暂停执行，到下一整分执行</span>\nthis_thread<span class=\"token operator\">::</span><span class=\"token function\">sleep_until</span><span class=\"token punctuation\">(</span>system_clock<span class=\"token operator\">::</span><span class=\"token function\">from_time_t</span><span class=\"token punctuation\">(</span><span class=\"token function\">mktime</span><span class=\"token punctuation\">(</span>ptm<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h1><a id=\"2_mutex_199\"></a>2. mutex</h1>\n<p>mutex头文件主要声明了与互斥量(mutex)相关的类。mutex提供了4种互斥类型，如下表所示。</p>\n<table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>std::mutex</td><td>最基本的 Mutex 类。</td></tr><tr><td>std::recursive_mutex</td><td>递归 Mutex 类。</td></tr><tr><td>std::time_mutex</td><td>定时 Mutex 类。</td></tr><tr><td>std::recursive_timed_mutex</td><td>定时递归 Mutex 类。</td></tr></tbody></table>\n<p>std::mutex 是C++11 中最基本的互斥量，std::mutex 对象提供了独占所有权的特性——即不支持递归地对 std::mutex 对象上锁，而 std::recursive_lock 则可以递归地对互斥量对象上锁。</p>\n<h2><a id=\"21_lockunlock_210\"></a>2.1 lock与unlock</h2>\n<p>mutex常用操作：</p>\n<blockquote>\n<ul><li>lock()：资源上锁</li><li>unlock()：解锁资源</li><li>trylock()：查看是否上锁，它有下列3种类情况：</li></ul>\n<blockquote>\n<p>（1）未上锁返回false，并锁住；<br/> （2）其他线程已经上锁，返回true；<br/> （3）同一个线程已经对它上锁，将会产生死锁。</p>\n</blockquote>\n</blockquote>\n<p><strong>死锁</strong>：是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种<strong>阻塞的现象</strong>，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</p>\n<p>下面结合实例对lock和unlock进行说明。</p>\n<p><strong>同一个mutex变量</strong>上锁之后，一个时间段内，只允许一个线程访问它。例如：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream&gt;</span>       </span><span class=\"token comment\">// std::cout</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;thread&gt;</span>         </span><span class=\"token comment\">// std::thread</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;mutex&gt;</span>          </span><span class=\"token comment\">// std::mutex</span>\n\nstd<span class=\"token operator\">::</span>mutex mtx<span class=\"token punctuation\">;</span>           <span class=\"token comment\">// mutex for critical section</span>\n\n<span class=\"token keyword\">void</span> print_block <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">,</span> <span class=\"token keyword\">char</span> c<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n  <span class=\"token comment\">// critical section (exclusive access to std::cout signaled by locking mtx):</span>\n  mtx<span class=\"token punctuation\">.</span><span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">&lt;</span>n<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span> std<span class=\"token operator\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> c<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n  std<span class=\"token operator\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">'\\n'</span><span class=\"token punctuation\">;</span>\n  mtx<span class=\"token punctuation\">.</span><span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">int</span> main <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n  std<span class=\"token operator\">::</span>thread th1 <span class=\"token punctuation\">(</span>print_block<span class=\"token punctuation\">,</span><span class=\"token number\">50</span><span class=\"token punctuation\">,</span><span class=\"token string\">'*'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//线程1：打印*</span>\n  std<span class=\"token operator\">::</span>thread th2 <span class=\"token punctuation\">(</span>print_block<span class=\"token punctuation\">,</span><span class=\"token number\">50</span><span class=\"token punctuation\">,</span><span class=\"token string\">'$'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//线程2：打印$</span>\n\n  th1<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  th2<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>输出：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token operator\">*</span>\n$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\n</code></pre>\n<p>如果是<strong>不同mutex变量</strong>，因为不涉及到同一资源的竞争，<strong>所以下列代码运行可能会出现交替打印的情况，或者另一个线程可以修改共同的全局变量！！！</strong>：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream&gt;</span>       </span><span class=\"token comment\">// std::cout</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;thread&gt;</span>         </span><span class=\"token comment\">// std::thread</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;mutex&gt;</span>          </span><span class=\"token comment\">// std::mutex</span>\n\nstd<span class=\"token operator\">::</span>mutex mtx_1<span class=\"token punctuation\">;</span>           <span class=\"token comment\">// mutex for critical section</span>\nstd<span class=\"token operator\">::</span>mutex mtx_2<span class=\"token punctuation\">;</span>           <span class=\"token comment\">// mutex for critical section</span>\n\n<span class=\"token keyword\">int</span> test_num <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">void</span> print_block_1 <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">,</span> <span class=\"token keyword\">char</span> c<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n  <span class=\"token comment\">// critical section (exclusive access to std::cout signaled by locking mtx):</span>\n  mtx_1<span class=\"token punctuation\">.</span><span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">&lt;</span>n<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n      <span class=\"token comment\">//std::cout &lt;&lt; c;</span>\n      test_num <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n      std<span class=\"token operator\">::</span>cout<span class=\"token operator\">&lt;&lt;</span>test_num<span class=\"token operator\">&lt;&lt;</span>std<span class=\"token operator\">::</span>endl<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  std<span class=\"token operator\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">'\\n'</span><span class=\"token punctuation\">;</span>\n  mtx_1<span class=\"token punctuation\">.</span><span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">void</span> print_block_2 <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">,</span> <span class=\"token keyword\">char</span> c<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n  <span class=\"token comment\">// critical section (exclusive access to std::cout signaled by locking mtx):</span>\n  mtx_2<span class=\"token punctuation\">.</span><span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  test_num <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">&lt;</span>n<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n      <span class=\"token comment\">//std::cout &lt;&lt; c;</span>\n      test_num <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n      std<span class=\"token operator\">::</span>cout<span class=\"token operator\">&lt;&lt;</span>test_num<span class=\"token operator\">&lt;&lt;</span>std<span class=\"token operator\">::</span>endl<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  mtx_2<span class=\"token punctuation\">.</span><span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">int</span> main <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n  std<span class=\"token operator\">::</span>thread th1 <span class=\"token punctuation\">(</span>print_block_1<span class=\"token punctuation\">,</span><span class=\"token number\">10000</span><span class=\"token punctuation\">,</span><span class=\"token string\">'*'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  std<span class=\"token operator\">::</span>thread th2 <span class=\"token punctuation\">(</span>print_block_2<span class=\"token punctuation\">,</span><span class=\"token number\">10000</span><span class=\"token punctuation\">,</span><span class=\"token string\">'$'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  th1<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  th2<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h2><a id=\"22_lock_guard_303\"></a>2.2 lock_guard</h2>\n<p>创建lock_guard对象时，它将尝试获取提供给它的互斥锁的所有权。当控制流离开lock_guard对象的作用域时，lock_guard析构并释放互斥量。</p>\n<p><strong>lock_guard的特点：</strong></p>\n<ul><li>创建即加锁，<strong>作用域结束自动析构并解锁</strong>，无需手工解锁</li><li><strong>不能中途解锁</strong>，必须等作用域结束才解锁</li><li>不能复制</li></ul>\n<p>代码举例</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;thread&gt;</span></span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;mutex&gt;</span></span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream&gt;</span></span>\n\n<span class=\"token keyword\">int</span> g_i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\nstd<span class=\"token operator\">::</span>mutex g_i_mutex<span class=\"token punctuation\">;</span>  <span class=\"token comment\">// protects g_i，用来保护g_i</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">safe_increment</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">const</span> std<span class=\"token operator\">::</span>lock_guard<span class=\"token operator\">&lt;</span>std<span class=\"token operator\">::</span>mutex<span class=\"token operator\">&gt;</span> <span class=\"token function\">lock</span><span class=\"token punctuation\">(</span>g_i_mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token operator\">++</span>g_i<span class=\"token punctuation\">;</span>\n    std<span class=\"token operator\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> std<span class=\"token operator\">::</span>this_thread<span class=\"token operator\">::</span><span class=\"token function\">get_id</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\": \"</span> <span class=\"token operator\">&lt;&lt;</span> g_i <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">'\\n'</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// g_i_mutex自动解锁</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\tstd<span class=\"token operator\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"main id: \"</span> <span class=\"token operator\">&lt;&lt;</span>std<span class=\"token operator\">::</span>this_thread<span class=\"token operator\">::</span><span class=\"token function\">get_id</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">&lt;&lt;</span>std<span class=\"token operator\">::</span>endl<span class=\"token punctuation\">;</span>\n    std<span class=\"token operator\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"main: \"</span> <span class=\"token operator\">&lt;&lt;</span> g_i <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">'\\n'</span><span class=\"token punctuation\">;</span>\n\n    std<span class=\"token operator\">::</span>thread <span class=\"token function\">t1</span><span class=\"token punctuation\">(</span>safe_increment<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    std<span class=\"token operator\">::</span>thread <span class=\"token function\">t2</span><span class=\"token punctuation\">(</span>safe_increment<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    t1<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    t2<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    std<span class=\"token operator\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"main: \"</span> <span class=\"token operator\">&lt;&lt;</span> g_i <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">'\\n'</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>说明：</p>\n<ol><li>该程序的功能为，每经过一个线程，g_i 加1。</li><li>因为涉及到共同资源g_i ，所以需要一个共同mutex：g_i_mutex。</li><li>main线程的id为1，所以下次的线程id依次加1。</li></ol>\n<h2><a id=\"23_unique_lock_349\"></a>2.3 unique_lock</h2>\n<p>简单地讲，unique_lock 是 lock_guard 的升级加强版，它具有 lock_guard 的所有功能，同时又具有其他很多方法，使用起来更强灵活方便，能够应对更复杂的锁定需要。</p>\n<p><strong>unique_lock的特点：</strong></p>\n<ul><li>创建时可以不锁定（通过指定第二个参数为std::defer_lock），而在需要时再锁定</li><li><strong>可以随时加锁解锁</strong></li><li><strong>作用域规则同 lock_grard，析构时自动释放锁</strong></li><li>不可复制，可移动</li><li>条件变量需要该类型的锁作为参数（此时必须使用unique_lock）</li></ul>\n<p>所有 lock_guard 能够做到的事情，都可以使用 unique_lock 做到，反之则不然。那么何时使lock_guard呢？很简单，需要使用锁的时候，首先考虑使用 lock_guard，因为lock_guard是最简单的锁。</p>\n<p>下面是代码举例：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;mutex&gt;</span></span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;thread&gt;</span></span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream&gt;</span></span>\n<span class=\"token keyword\">struct</span> Box <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">explicit</span> <span class=\"token function\">Box</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> num<span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> num_things<span class=\"token punctuation\">{<!-- --></span>num<span class=\"token punctuation\">}</span> <span class=\"token punctuation\">{<!-- --></span><span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">int</span> num_things<span class=\"token punctuation\">;</span>\n    std<span class=\"token operator\">::</span>mutex m<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">transfer</span><span class=\"token punctuation\">(</span>Box <span class=\"token operator\">&amp;</span>from<span class=\"token punctuation\">,</span> Box <span class=\"token operator\">&amp;</span>to<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> num<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token comment\">// defer_lock表示暂时unlock，默认自动加锁</span>\n    std<span class=\"token operator\">::</span>unique_lock<span class=\"token operator\">&lt;</span>std<span class=\"token operator\">::</span>mutex<span class=\"token operator\">&gt;</span> <span class=\"token function\">lock1</span><span class=\"token punctuation\">(</span>from<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">,</span> std<span class=\"token operator\">::</span>defer_lock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    std<span class=\"token operator\">::</span>unique_lock<span class=\"token operator\">&lt;</span>std<span class=\"token operator\">::</span>mutex<span class=\"token operator\">&gt;</span> <span class=\"token function\">lock2</span><span class=\"token punctuation\">(</span>to<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">,</span> std<span class=\"token operator\">::</span>defer_lock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">//两个同时加锁</span>\n    std<span class=\"token operator\">::</span><span class=\"token function\">lock</span><span class=\"token punctuation\">(</span>lock1<span class=\"token punctuation\">,</span> lock2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//或者使用lock1.lock()</span>\n\n    from<span class=\"token punctuation\">.</span>num_things <span class=\"token operator\">-</span><span class=\"token operator\">=</span> num<span class=\"token punctuation\">;</span>\n    to<span class=\"token punctuation\">.</span>num_things <span class=\"token operator\">+</span><span class=\"token operator\">=</span> num<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//作用域结束自动解锁,也可以使用lock1.unlock()手动解锁</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n    Box <span class=\"token function\">acc1</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    Box <span class=\"token function\">acc2</span><span class=\"token punctuation\">(</span><span class=\"token number\">50</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    std<span class=\"token operator\">::</span>thread <span class=\"token function\">t1</span><span class=\"token punctuation\">(</span>transfer<span class=\"token punctuation\">,</span> std<span class=\"token operator\">::</span><span class=\"token function\">ref</span><span class=\"token punctuation\">(</span>acc1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> std<span class=\"token operator\">::</span><span class=\"token function\">ref</span><span class=\"token punctuation\">(</span>acc2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    std<span class=\"token operator\">::</span>thread <span class=\"token function\">t2</span><span class=\"token punctuation\">(</span>transfer<span class=\"token punctuation\">,</span> std<span class=\"token operator\">::</span><span class=\"token function\">ref</span><span class=\"token punctuation\">(</span>acc2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> std<span class=\"token operator\">::</span><span class=\"token function\">ref</span><span class=\"token punctuation\">(</span>acc1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    t1<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    t2<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    std<span class=\"token operator\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"acc1 num_things: \"</span> <span class=\"token operator\">&lt;&lt;</span> acc1<span class=\"token punctuation\">.</span>num_things <span class=\"token operator\">&lt;&lt;</span> std<span class=\"token operator\">::</span>endl<span class=\"token punctuation\">;</span>\n    std<span class=\"token operator\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"acc2 num_things: \"</span> <span class=\"token operator\">&lt;&lt;</span> acc2<span class=\"token punctuation\">.</span>num_things <span class=\"token operator\">&lt;&lt;</span> std<span class=\"token operator\">::</span>endl<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>说明：</p>\n<ol><li>该函数的作用是，从一个结构体中的变量减去一个num，加载到另一个结构体的变量中去。</li><li>std::mutex m;在结构体中，mutex不是共享的。但是只需要一把锁也能锁住，因为引用传递后，同一把锁传给了两个函数。</li><li>cout需要在join后面进行，要不然cout的结果不一定是最终算出来的结果。</li><li>std::ref 用于包装按引用传递的值。</li><li>std::cref 用于包装按const引用传递的值。</li></ol>\n<h1><a id=\"3_condition_variable_408\"></a>3. condition_variable</h1>\n<p>condition_variable的头文件有两个variable类，一个是condition_variable，另一个是condition_variable_any。condition_variable必须结合unique_lock使用。condition_variable_any可以使用任何的锁。下面以condition_variable为例进行介绍。</p>\n<p><strong>condition_variable条件变量可以阻塞（wait、wait_for、wait_until）调用的线程直到使用（notify_one或notify_all）通知恢复为止</strong>。condition_variable是一个类，这个类既有构造函数也有析构函数，使用时需要构造对应的condition_variable对象，调用对象相应的函数来实现上面的功能。</p>\n<table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>condition_variable</td><td>构建对象</td></tr><tr><td>析构</td><td>删除</td></tr><tr><td>wait</td><td>Wait until notified</td></tr><tr><td>wait_for</td><td>Wait for timeout or until notified</td></tr><tr><td>wait_until</td><td>Wait until notified or time point</td></tr><tr><td>notify_one</td><td>解锁一个线程，如果有多个，则未知哪个线程执行</td></tr><tr><td>notify_all</td><td>解锁所有线程</td></tr><tr><td>cv_status</td><td>这是一个类，表示variable 的状态，如下所示</td></tr></tbody></table>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">enum</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">cv_status</span> <span class=\"token punctuation\">{<!-- --></span> no_timeout<span class=\"token punctuation\">,</span> timeout <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h2><a id=\"31_wait_426\"></a>3.1 wait</h2>\n<p>当前线程调用 wait() 后将被阻塞(此时当前线程应该获得了锁（mutex），不妨设获得锁 lck)，直到另外某个线程调用 notify_* 唤醒了当前线程。</p>\n<p>在线程被阻塞时，<strong>该函数会自动调用 lck.unlock() 释放锁，使得其他被阻塞在锁竞争上的线程得以继续执行</strong>。另外，一旦当前线程获得通知(notified，通常是另外某个线程调用 notify_* 唤醒了当前线程)，wait()函数也是自动调用 lck.lock()，使得lck的状态和 wait 函数被调用时相同。</p>\n<p>代码示例：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream&gt;</span>           </span><span class=\"token comment\">// std::cout</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;thread&gt;</span>             </span><span class=\"token comment\">// std::thread, std::this_thread::yield</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;mutex&gt;</span>              </span><span class=\"token comment\">// std::mutex, std::unique_lock</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;condition_variable&gt;</span> </span><span class=\"token comment\">// std::condition_variable</span>\n\nstd<span class=\"token operator\">::</span>mutex mtx<span class=\"token punctuation\">;</span>\nstd<span class=\"token operator\">::</span>condition_variable cv<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">int</span> cargo <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">bool</span> <span class=\"token function\">shipment_available</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span><span class=\"token keyword\">return</span> cargo<span class=\"token operator\">!=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> consume <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">&lt;</span>n<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n        std<span class=\"token operator\">::</span>unique_lock<span class=\"token operator\">&lt;</span>std<span class=\"token operator\">::</span>mutex<span class=\"token operator\">&gt;</span> <span class=\"token function\">lck</span><span class=\"token punctuation\">(</span>mtx<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//自动上锁</span>\n        <span class=\"token comment\">//第二个参数为false才阻塞（wait），阻塞完即unlock，给其它线程资源</span>\n        cv<span class=\"token punctuation\">.</span><span class=\"token function\">wait</span><span class=\"token punctuation\">(</span>lck<span class=\"token punctuation\">,</span>shipment_available<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// consume:</span>\n        std<span class=\"token operator\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> cargo <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">'\\n'</span><span class=\"token punctuation\">;</span>\n        cargo<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">int</span> main <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n    std<span class=\"token operator\">::</span>thread consumer_thread <span class=\"token punctuation\">(</span>consume<span class=\"token punctuation\">,</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">&lt;</span><span class=\"token number\">10</span><span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token comment\">//每次cargo每次为0才运行。</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token function\">shipment_available</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> std<span class=\"token operator\">::</span>this_thread<span class=\"token operator\">::</span><span class=\"token function\">yield</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        std<span class=\"token operator\">::</span>unique_lock<span class=\"token operator\">&lt;</span>std<span class=\"token operator\">::</span>mutex<span class=\"token operator\">&gt;</span> <span class=\"token function\">lck</span><span class=\"token punctuation\">(</span>mtx<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        cargo <span class=\"token operator\">=</span> i<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        cv<span class=\"token punctuation\">.</span><span class=\"token function\">notify_one</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    consumer_thread<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>说明：</p>\n<ol><li>主线程中的while，每次在cargo=0才运行。</li><li>每次cargo被置为0，会通知子线程unblock(非阻塞)，也就是子线程可以继续往下执行。</li><li>子线程中cargo被置为0后，wait又一次启动等待。也就是说shipment_available为false，则等待。</li></ol>\n<h2><a id=\"32_wait_for_477\"></a>3.2 wait_for</h2>\n<p>与std::condition_variable::wait() 类似，不过 wait_for可以指定一个时间段，<strong>在当前线程收到通知或者指定的时间 rel_time 超时之前，该线程都会处于阻塞状态。</strong> 而一旦超时或者收到了其他线程的通知，wait_for返回，剩下的处理步骤和 wait()类似。</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">Rep</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Period</span><span class=\"token operator\">&gt;</span>\n  cv_status wait_for <span class=\"token punctuation\">(</span>unique_lock<span class=\"token operator\">&lt;</span>mutex<span class=\"token operator\">&gt;</span><span class=\"token operator\">&amp;</span> lck<span class=\"token punctuation\">,</span>\n                      <span class=\"token keyword\">const</span> chrono<span class=\"token operator\">::</span>duration<span class=\"token operator\">&lt;</span>Rep<span class=\"token punctuation\">,</span>Period<span class=\"token operator\">&gt;</span><span class=\"token operator\">&amp;</span> rel_time<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>另外，wait_for 的重载版本的最后一个参数pred表示 wait_for的预测条件，只有当 pred条件为false时调用 wait()才会阻塞当前线程，并且在收到其他线程的通知后只有当 pred为 true时才会被解除阻塞。</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">Rep</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Period</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Predicate</span><span class=\"token operator\">&gt;</span>\n       <span class=\"token keyword\">bool</span> wait_for <span class=\"token punctuation\">(</span>unique_lock<span class=\"token operator\">&lt;</span>mutex<span class=\"token operator\">&gt;</span><span class=\"token operator\">&amp;</span> lck<span class=\"token punctuation\">,</span>\n                      <span class=\"token keyword\">const</span> chrono<span class=\"token operator\">::</span>duration<span class=\"token operator\">&lt;</span>Rep<span class=\"token punctuation\">,</span>Period<span class=\"token operator\">&gt;</span><span class=\"token operator\">&amp;</span> rel_time<span class=\"token punctuation\">,</span> Predicate pred<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>代码示例：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream&gt;</span>           </span><span class=\"token comment\">// std::cout</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;thread&gt;</span>             </span><span class=\"token comment\">// std::thread</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;chrono&gt;</span>             </span><span class=\"token comment\">// std::chrono::seconds</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;mutex&gt;</span>              </span><span class=\"token comment\">// std::mutex, std::unique_lock</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;condition_variable&gt;</span> </span><span class=\"token comment\">// std::condition_variable, std::cv_status</span>\n\nstd<span class=\"token operator\">::</span>condition_variable cv<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">int</span> value<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">read_value</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n  std<span class=\"token operator\">::</span>cin <span class=\"token operator\">&gt;&gt;</span> value<span class=\"token punctuation\">;</span>\n  cv<span class=\"token punctuation\">.</span><span class=\"token function\">notify_one</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">int</span> main <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n  std<span class=\"token operator\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Please, enter an integer (I'll be printing dots): \\n\"</span><span class=\"token punctuation\">;</span>\n  std<span class=\"token operator\">::</span>thread th <span class=\"token punctuation\">(</span>read_value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  std<span class=\"token operator\">::</span>mutex mtx<span class=\"token punctuation\">;</span>\n  std<span class=\"token operator\">::</span>unique_lock<span class=\"token operator\">&lt;</span>std<span class=\"token operator\">::</span>mutex<span class=\"token operator\">&gt;</span> <span class=\"token function\">lck</span><span class=\"token punctuation\">(</span>mtx<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>cv<span class=\"token punctuation\">.</span><span class=\"token function\">wait_for</span><span class=\"token punctuation\">(</span>lck<span class=\"token punctuation\">,</span>std<span class=\"token operator\">::</span>chrono<span class=\"token operator\">::</span><span class=\"token function\">seconds</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token operator\">==</span>std<span class=\"token operator\">::</span>cv_status<span class=\"token operator\">::</span>timeout<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    std<span class=\"token operator\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">'.'</span> <span class=\"token operator\">&lt;&lt;</span> std<span class=\"token operator\">::</span>endl<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  std<span class=\"token operator\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"You entered: \"</span> <span class=\"token operator\">&lt;&lt;</span> value <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">'\\n'</span><span class=\"token punctuation\">;</span>\n\n  th<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<ol><li>通知或者超时都会解锁，所以主线程会一直打印。</li><li>示例中只要过去一秒，就会不断的打印。</li></ol>\n<h1><a id=\"4__531\"></a>4. 线程池</h1>\n<h2><a id=\"41__532\"></a>4.1 概念</h2>\n<p>在一个程序中，如果我们需要多次使用线程，这就意味着，需要多次的创建并销毁线程。而创建并销毁线程的过程势必会消耗内存，线程过多会带来调动的开销，进而影响缓存局部性和整体性能。</p>\n<p>线程的创建并销毁有以下一些缺点：</p>\n<ul><li>创建太多线程，将会浪费一定的资源，有些线程未被充分使用。</li><li>销毁太多线程，将导致之后浪费时间再次创建它们。</li><li>创建线程太慢，将会导致长时间的等待，性能变差。</li><li>销毁线程太慢，导致其它线程资源饥饿。</li></ul>\n<p>线程池维护着多个线程，这避免了在处理短时间任务时，创建与销毁线程的代价。</p>\n<h2><a id=\"42__545\"></a>4.2 线程池的实现</h2>\n<p>因为程序边运行边创建线程是比较耗时的，所以我们通过池化的思想：在程序开始运行前创建多个线程，这样，程序在运行时，只需要从线程池中拿来用就可以了．大大提高了程序运行效率．</p>\n<p>一般线程池都会有以下几个部分构成：</p>\n<ol><li>线程池管理器（ThreadPoolManager）:用于创建并管理线程池，也就是线程池类</li><li><strong>工作线程（WorkThread）:</strong> 线程池中线程</li><li><strong>任务队列task:</strong> 用于存放没有处理的任务。提供一种缓冲机制。</li><li>append：用于添加任务的接口</li></ol>\n<p>线程池实现代码：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token macro property\">#<span class=\"token directive keyword\">ifndef</span> _THREADPOOL_H</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> _THREADPOOL_H</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;vector&gt;</span></span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;queue&gt;</span></span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;thread&gt;</span></span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream&gt;</span></span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdexcept&gt;</span></span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;condition_variable&gt;</span></span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;memory&gt;</span> </span><span class=\"token comment\">//unique_ptr</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;assert.h&gt;</span></span>\n\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> MAX_THREADS <span class=\"token operator\">=</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//最大线程数目</span>\n\n<span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> T<span class=\"token operator\">&gt;</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">threadPool</span>\n<span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    <span class=\"token function\">threadPool</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> number <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//默认开一个线程</span>\n    <span class=\"token operator\">~</span><span class=\"token function\">threadPool</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    std<span class=\"token operator\">::</span>queue<span class=\"token operator\">&lt;</span>T <span class=\"token operator\">*</span><span class=\"token operator\">&gt;</span> tasks_queue<span class=\"token punctuation\">;</span>\t\t   <span class=\"token comment\">//任务队列</span>\n\n    <span class=\"token keyword\">bool</span> <span class=\"token function\">append</span><span class=\"token punctuation\">(</span>T <span class=\"token operator\">*</span>request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//往请求队列＜task_queue＞中添加任务&lt;T *&gt;</span>\n\n<span class=\"token keyword\">private</span><span class=\"token operator\">:</span>\n    <span class=\"token comment\">//工作线程需要运行的函数,不断的从任务队列中取出并执行</span>\n    <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token function\">worker</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>arg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">private</span><span class=\"token operator\">:</span>\n    std<span class=\"token operator\">::</span>vector<span class=\"token operator\">&lt;</span>std<span class=\"token operator\">::</span>thread<span class=\"token operator\">&gt;</span> work_threads<span class=\"token punctuation\">;</span> <span class=\"token comment\">//工作线程</span>\n\n    std<span class=\"token operator\">::</span>mutex queue_mutex<span class=\"token punctuation\">;</span>\n    std<span class=\"token operator\">::</span>condition_variable condition<span class=\"token punctuation\">;</span>  <span class=\"token comment\">//必须与unique_lock配合使用</span>\n    <span class=\"token keyword\">bool</span> stop<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//end class</span>\n\n<span class=\"token comment\">//构造函数，创建线程</span>\n<span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> T<span class=\"token operator\">&gt;</span>\nthreadPool<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">&gt;</span><span class=\"token operator\">::</span><span class=\"token function\">threadPool</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> number<span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token function\">stop</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>number <span class=\"token operator\">&lt;=</span> <span class=\"token number\">0</span> <span class=\"token operator\">||</span> number <span class=\"token operator\">&gt;</span> MAX_THREADS<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">throw</span> std<span class=\"token operator\">::</span><span class=\"token function\">exception</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> number<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{<!-- --></span>\n        std<span class=\"token operator\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"created Thread num is : \"</span> <span class=\"token operator\">&lt;&lt;</span> i <span class=\"token operator\">&lt;&lt;</span>std<span class=\"token operator\">::</span>endl<span class=\"token punctuation\">;</span>\n        work_threads<span class=\"token punctuation\">.</span><span class=\"token function\">emplace_back</span><span class=\"token punctuation\">(</span>worker<span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//添加线程</span>\n        <span class=\"token comment\">//直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程。</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> T<span class=\"token operator\">&gt;</span>\n<span class=\"token keyword\">inline</span> threadPool<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">&gt;</span><span class=\"token operator\">::</span><span class=\"token operator\">~</span><span class=\"token function\">threadPool</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\n    std<span class=\"token operator\">::</span>unique_lock<span class=\"token operator\">&lt;</span>std<span class=\"token operator\">::</span>mutex<span class=\"token operator\">&gt;</span> <span class=\"token function\">lock</span><span class=\"token punctuation\">(</span>queue_mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    stop <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n\n    condition<span class=\"token punctuation\">.</span><span class=\"token function\">notify_all</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> <span class=\"token operator\">&amp;</span>ww <span class=\"token operator\">:</span> work_threads<span class=\"token punctuation\">)</span>\n        ww<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//可以在析构函数中join</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">//添加任务</span>\n<span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> T<span class=\"token operator\">&gt;</span>\n<span class=\"token keyword\">bool</span> threadPool<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">&gt;</span><span class=\"token operator\">::</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span>T <span class=\"token operator\">*</span>request<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token comment\">/*操作工作队列时一定要加锁，因为他被所有线程共享*/</span>\n    queue_mutex<span class=\"token punctuation\">.</span><span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//同一个类的锁</span>\n    tasks_queue<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    queue_mutex<span class=\"token punctuation\">.</span><span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    condition<span class=\"token punctuation\">.</span><span class=\"token function\">notify_one</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//线程池添加进去了任务，自然要通知等待的线程</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">//单个线程</span>\n<span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> T<span class=\"token operator\">&gt;</span>\n<span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>threadPool<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">&gt;</span><span class=\"token operator\">::</span><span class=\"token function\">worker</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>arg<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n    threadPool <span class=\"token operator\">*</span>pool <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>threadPool <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>arg<span class=\"token punctuation\">;</span>\n    pool<span class=\"token operator\">-</span><span class=\"token operator\">&gt;</span><span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//线程运行</span>\n    <span class=\"token keyword\">return</span> pool<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> T<span class=\"token operator\">&gt;</span>\n<span class=\"token keyword\">void</span> threadPool<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">&gt;</span><span class=\"token operator\">::</span><span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>stop<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{<!-- --></span>\n        std<span class=\"token operator\">::</span>unique_lock<span class=\"token operator\">&lt;</span>std<span class=\"token operator\">::</span>mutex<span class=\"token operator\">&gt;</span> <span class=\"token function\">lk</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token operator\">-</span><span class=\"token operator\">&gt;</span>queue_mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">/*　unique_lock() 出作用域会自动解锁　*/</span>\n        <span class=\"token keyword\">this</span><span class=\"token operator\">-</span><span class=\"token operator\">&gt;</span>condition<span class=\"token punctuation\">.</span><span class=\"token function\">wait</span><span class=\"token punctuation\">(</span>lk<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">{<!-- --></span> <span class=\"token keyword\">return</span> <span class=\"token operator\">!</span><span class=\"token keyword\">this</span><span class=\"token operator\">-</span><span class=\"token operator\">&gt;</span>tasks_queue<span class=\"token punctuation\">.</span><span class=\"token function\">empty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//如果任务为空，则wait，就停下来等待唤醒</span>\n        <span class=\"token comment\">//需要有任务，才启动该线程，不然就休眠</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token operator\">-</span><span class=\"token operator\">&gt;</span>tasks_queue<span class=\"token punctuation\">.</span><span class=\"token function\">empty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token comment\">//任务为空，双重保障</span>\n        <span class=\"token punctuation\">{<!-- --></span>\n            <span class=\"token function\">assert</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token operator\">&amp;&amp;</span><span class=\"token string\">\"断了\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//实际上不会运行到这一步，因为任务为空，wait就休眠了。</span>\n            <span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">else</span>\n        <span class=\"token punctuation\">{<!-- --></span>\n            T <span class=\"token operator\">*</span>request <span class=\"token operator\">=</span> tasks_queue<span class=\"token punctuation\">.</span><span class=\"token function\">front</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            tasks_queue<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">)</span><span class=\"token comment\">//来任务了，开始执行</span>\n                request<span class=\"token operator\">-</span><span class=\"token operator\">&gt;</span><span class=\"token function\">process</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">endif</span></span>\n</code></pre>\n<p>说明：</p>\n<ul><li>构造函数创建所需要的线程数</li><li>一个线程对应一个任务，任务随时可能完成，线程则可能休眠，所以任务用队列queue实现（线程数量有限），线程用采用wait机制。</li><li>任务在不断的添加，有可能大于线程数，处于队首的任务先执行。</li><li>只有添加任务(append)后，才开启线程condition.notify_one()。</li><li>wait表示，任务为空时，则线程休眠，等待新任务的加入。</li><li>添加任务时需要添加锁，因为共享资源。</li></ul>\n<p>测试代码：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">\"mythread.h\"</span></span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;string&gt;</span></span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;math.h&gt;</span></span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Task</span>\n<span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    <span class=\"token keyword\">void</span> <span class=\"token function\">process</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token comment\">//cout &lt;&lt; \"run.........\" &lt;&lt; endl;</span>\n        <span class=\"token comment\">//测试任务数量</span>\n        <span class=\"token keyword\">long</span> i<span class=\"token operator\">=</span><span class=\"token number\">1000000</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>i<span class=\"token operator\">!=</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{<!-- --></span>\n            <span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token function\">sqrt</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            i<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n    threadPool<span class=\"token operator\">&lt;</span>Task<span class=\"token operator\">&gt;</span> <span class=\"token function\">pool</span><span class=\"token punctuation\">(</span><span class=\"token number\">6</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//6个线程，vector</span>\n    std<span class=\"token operator\">::</span>string str<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{<!-- --></span>\n            Task <span class=\"token operator\">*</span>tt <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token function\">Task</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\">//使用智能指针</span>\n            pool<span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span>tt<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//不停的添加任务，任务是队列queue，因为只有固定的线程数</span>\n            cout<span class=\"token operator\">&lt;&lt;</span><span class=\"token string\">\"添加的任务数量： \"</span><span class=\"token operator\">&lt;&lt;</span>pool<span class=\"token punctuation\">.</span>tasks_queue<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">&lt;&lt;</span>endl<span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">delete</span> tt<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<hr/>\n<p>参考：</p>\n<p>C++11线程池实现github：<a href=\"https://github.com/progschj/ThreadPool\">https://github.com/progschj/ThreadPool</a></p>\n<p>C++11线程池的两种实现：<a href=\"https://blog.csdn.net/liushengxi_root/article/details/83932654\">https://blog.csdn.net/liushengxi_root/article/details/83932654</a></p>\n<p><a href=\"https://blog.csdn.net/yockie/article/details/8838686?utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control\">原子操作</a>(类似于互斥，但更接近底层实现，效率更高。还没更新)</p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}