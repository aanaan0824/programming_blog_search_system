{"blogid": "119085506", "writerAge": "码龄5年", "writerBlogNum": "16", "writerCollect": "64", "writerComment": "16", "writerFan": "15", "writerGrade": "3级", "writerIntegral": "555", "writerName": "无畏源于无知", "writerProfileAdress": "writer_image\\profile_119085506.jpg", "writerRankTotal": "383318", "writerRankWeekly": "133115", "writerThumb": "34", "writerVisitNum": "70214", "blog_read_count": "2562", "blog_time": "于 2021-07-25 19:12:39 发布", "blog_title": "C#中的Where的使用", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h2 style=\"text-align:left;\"><strong><strong><strong>一、约束</strong></strong></strong></h2>\n<p>约束类型包括基类约束、构造函数约束、接口约束、参数约束等。如：</p>\n<pre><code>public class FateherTest\n{\n}\n//where的用法 接口约束IComparable 和构造函数约束new(), 基类约束 FatherTest\npublic class TestA&lt;T&gt; where T : FateherTest, IComparable, new()\n{\n}\n\npublic class TestB\n{\n //限制传递参数的类型必须继承IComparable 参数类型约束\n    public int Caculate&lt;T&gt;(T t) where T : IComparable\n    {\n        throw new NotImplementedException();\n    }\n}</code></pre>\n<h2>二、<strong><strong><strong>集合条件查询</strong></strong></strong></h2>\n<h3><strong><strong><strong>1.使用方法</strong></strong></strong></h3>\n<pre><code class=\"language-cs\">  List&lt;InstanceB&gt; list = new List&lt;InstanceB&gt;();\n  //返回b.value的值 ==2的 IEnumerable对象\n  list.Where((b) =&gt; b.value == 2).ToList();\n  Dictionary&lt;int, InstanceB&gt; dic = new Dictionary&lt;int, InstanceB&gt;();\n  //TSource是 KeyValuePair&lt;TKey, TValue&gt;\n  dic.Where((b) =&gt; b.Value.value== 2);</code></pre>\n<h3>2.如何实现的</h3>\n<p>在System.linq命名空间下的Enumerable类里面实现了IEnumerable的扩展方法.如下:</p>\n<pre><code class=\"language-cs\"> //返回值是IEnumerable&lt;T&gt;迭代器对象\n\n public static IEnumerable&lt;TSource&gt; Where&lt;TSource&gt;(\n      this IEnumerable&lt;TSource&gt; source,\n      Func&lt;TSource, bool&gt; predicate)\n    {\n      if (source == null)\n        throw Error.ArgumentNull(nameof (source));\n      if (predicate == null)\n        throw Error.ArgumentNull(nameof (predicate));\n      switch (source)\n      {\n        case Enumerable.Iterator&lt;TSource&gt; _:\n          return ((Enumerable.Iterator&lt;TSource&gt;) source).Where(predicate);\n        case TSource[] _:\n          return (IEnumerable&lt;TSource&gt;) new Enumerable.WhereArrayIterator&lt;TSource&gt;((TSource[]) source, predicate);\n        case List&lt;TSource&gt; _:\n          return (IEnumerable&lt;TSource&gt;) new Enumerable.WhereListIterator&lt;TSource&gt;((List&lt;TSource&gt;) source, predicate);\n        default:\n          return (IEnumerable&lt;TSource&gt;) new Enumerable.WhereEnumerableIterator&lt;TSource&gt;(source, predicate);\n      }\n    }</code></pre>\n<p> 当我们调用List.Where扩展方法时返回了一个WhereListIterator对象：</p>\n<p><span style=\"background-color:#ffff00;\"><span style=\"color:#1f497d;\">reurn  (IEnumerable&lt;TSource&gt;) new Enumerable.WhereListIterator&lt;TSource&gt;((TSource[]) source, predicate) 返回一个whereListIterator对象。其中 TSource就是InstanceB类型</span></span></p>\n<p>我们可查看 WhereListIterator 这个类，它继承了：<span style=\"color:#1f497d;\">Enumerable.Iterator&lt;TResult&gt;：</span><strong><span style=\"color:#1f497d;\"><strong>IEnumerable&lt;TSource&gt; .</strong></span></strong>其本身实现了迭代器的功能，查看MoveNext方法：</p>\n<pre><code class=\"language-cs\">      public override bool MoveNext()\n      {\n        if (this.state == 1)\n        {\n          while (this.index &lt; this.source.Length)\n          {\n            TSource source = this.source[this.index];\n            ++this.index;\n            if (this.predicate(source))\n            {\n              this.current = source;\n              return true;\n            }\n          }\n          this.Dispose();\n        }\n        return false;\n      }</code></pre>\n<p><strong><span style=\"color:#1f497d;\"><strong>    </strong></span></strong><span style=\"color:#0d0016;\">只有通过predictate的检测之后MoveNext才会返回true.调用Tolist的时候回调用 IEnumrable的扩展方法Tolist 调用创建一个List&lt;T&gt;对象返回。只不过构造函数是使用集合做的初始化，如下：</span></p>\n<pre><code>    [__DynamicallyInvokable]\n\n    public List(IEnumerable&lt;T&gt; collection)\n    {\n      if (collection == null)\n        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.collection);\n\n      if (collection is ICollection&lt;T&gt; objs)\n      {\n        int count = objs.Count;\n        if (count == 0)\n        {\n          this._items = List&lt;T&gt;._emptyArray;\n        }\n        else\n        {\n          this._items = new T[count];\n          objs.CopyTo(this._items, 0);\n          this._size = count;\n        }\n      }\n      else\n      {\n        this._size = 0;\n        this._items = List&lt;T&gt;._emptyArray;\n        foreach (T obj in collection)\n          this.Add(obj);\n      }\n    }</code></pre>\n<p><span style=\"color:#0d0016;\">上面使用foreach会调用WhereListIterator 的MoveNext.直到返回false结束。而上面的MoveNext用来Func委托函数做筛选。</span></p>\n<p><span style=\"color:#0d0016;\">我们还可以做如下操作：</span></p>\n<pre><code>var  whereListIt  = list.Where((b) =&gt; b.value &gt;1) \n Func&lt;InstanceB,InstanceB&gt; func = delegate (InstanceB b)\n {\n     b.value = 3;\n     return b;\n  };\nnewList = whereListIt.Select(func).ToList();</code></pre>\n<p><strong><span style=\"color:#1f497d;\"><strong>筛选出第一次b.value &gt;1的独享 第二次将筛选对象的value都设置为3.</strong></span></strong></p>\n<pre><code>      public override bool MoveNext()\n      {\n        if (this.state == 1)\n        {\n          while (this.index &lt; this.source.Length)\n          {\n            TSource source = this.source[this.index];\n            ++this.index;\n            if (this.predicate == null || this.predicate(source))\n            {\n//这里可以看出Selector是对source进行操作，并不是筛选。\n              this.current = this.selector(source);\n              return true;\n            }\n          }\n          this.Dispose();\n        }\n        return false;\n      }</code></pre>\n<p>几个类结构如下：</p>\n<ol><li>WhereListIterator:Enumerable.Iterator&lt;TResult&gt;：IEnumerable&lt;TSource&gt;</li><li>WhereListIterator:Enumerable.Iterator&lt;TResult&gt;：IEnumerable&lt;TSource&gt;</li></ol>\n<p>  所以有连续的操作如：</p>\n<pre><code>list.Where((b) =&gt; b.value == 2).where((b) =&gt; b.value == 2)\nFunc&lt;InstanceB,InstanceB&gt; func = delegate (InstanceB b)\n        {\n            b.value = 3;\n            return b;\n        };\nlist.Select(t).Select(t)</code></pre>\n<p style=\"margin-left:21pt;\"><span style=\"color:#000000;\">也可以有组合的操作</span></p>\n<pre><code>list.Where((b) =&gt; b.value == 2).Select(t)\n\n原因是连续操作内部做了 Combine操作：下面是Selector调用Selector即：Selector.Selector\npublic override IEnumerable&lt;TResult2&gt; Select&lt;TResult2&gt;(\n        Func&lt;TResult, TResult2&gt; selector) {\n        return (IEnumerable&lt;TResult2&gt;) new Enumerable.SelectEnumerableIterator&lt;TSource, TResult2&gt;(this._source, Enumerable.CombineSelectors&lt;TSource, TResult, TResult2&gt;(this._selector, selector));\n}\n组合操作做了组合：下面是Selector.Where的组合操作\npublic override IEnumerable&lt;TResult&gt; Where(Func&lt;TResult, bool&gt; predicate) =&gt; (IEnumerable&lt;TResult&gt;) new Enumerable.WhereEnumerableIterator&lt;TResult&gt;((IEnumerable&lt;TResult&gt;) this, predicate);</code></pre>\n<p><span style=\"color:#1f497d;\">/</span><span style=\"color:#0d0016;\">组合操作时会把This当前对象传递到下个对象<span style=\"background-color:#ffff00;\">WhereEnumerableIterator。</span>而<span style=\"background-color:#ffff00;\">WhereEnumerableIterator在MoveNext中的操作如下：</span>   </span></p>\n<ul><li><span style=\"color:#0d0016;\"> 取了上个对象的迭代器，先做处理。</span></li><li><span style=\"color:#0d0016;\">调用了上个对象的MoveNext对Selector的Func进行了调用，之后再调用this.predicate做筛选。</span></li></ul>\n<h3>3.从设计模式的角度</h3>\n<p>对于List、Dictionary和Array</p>\n<ul><li>使用扩展方法扩展扩展IEnumrable的功能，而不修改IEnurable接口内容。</li><li>实现新的类对象，持有IEnumrable对象做迭代处理，使用的是组合的方式而不是继承的方式。</li><li>新创建的对象分别代表不同的操作，继承同一个父类，因此不同对象之间使用组合模式可以相互组合，实现复杂的操作。</li></ul>\n<p>现在又要给这些数据集合添加功能是筛选.实现方法有以下两种：</p>\n<p>    1.新写一个接口让这些集合实现，利用迭代的功能实现筛选。坏处是某个对象都需要实现这个方法。破坏了原有类的结构。</p>\n<p>    2.由于筛选功能只是用到了迭代器，因此可以：</p>\n<ul><li>使用扩展方法扩展扩展IEnumrable的功能，而不修改IEnurable接口内容。</li><li>实现新的类对象，持有IEnumrable对象做迭代处理，使用的是组合的方式而不是继承的方式。</li><li>新创建的对象分别代表不同的操作，继承同一个父类，因此不同对象之间使用组合模式可以相互组合，实现复杂的操作。</li></ul>\n<p></p>\n<p style=\"margin-left:21pt;\"></p>\n<p style=\"margin-left:23.8pt;\"></p>\n<p><strong> </strong></p>\n</div>\n</div>"}