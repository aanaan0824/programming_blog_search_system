{"blogid": "125701955", "writerAge": "码龄1年", "writerBlogNum": "22", "writerCollect": "617", "writerComment": "40", "writerFan": "153", "writerGrade": "2级", "writerIntegral": "375", "writerName": "不秃也很强", "writerProfileAdress": "writer_image\\profile_125701955.jpg", "writerRankTotal": "48233", "writerRankWeekly": "184642", "writerThumb": "119", "writerVisitNum": "40461", "blog_read_count": "2069", "blog_time": "已于 2022-07-10 10:44:12 修改", "blog_title": "链表基础知识详解（非常详细简单易懂）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h1>概述：</h1>\n<p>      链表作为 C 语言中一种基础的数据结构，在平时写程序的时候用的并不多，但在操作系统里面使用的非常多。不管是RTOS还是Linux等使用非常广泛，所以必须要搞懂链表，链表分为单向链表和双向链表，单向链表很少用，使用最多的还是双向链表。单向链表懂了双向链表自然就会了。</p>\n<p id=\"main-toc\"><strong>文章目录</strong></p>\n<p id=\"%E4%B8%80%E3%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E6%A6%82%E5%BF%B5-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%80%E3%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E6%A6%82%E5%BF%B5\">一、链表的概念</a></p>\n<p id=\"%C2%A0%E9%93%BE%E8%A1%A8%E7%9A%84%E6%9E%84%E6%88%90%EF%BC%9A-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A0%E9%93%BE%E8%A1%A8%E7%9A%84%E6%9E%84%E6%88%90%EF%BC%9A\"> 链表的构成：</a></p>\n<p id=\"%E9%93%BE%E8%A1%A8%E7%9A%84%E6%93%8D%E4%BD%9C%3A-toc\" style=\"margin-left:40px;\"><a href=\"#%E9%93%BE%E8%A1%A8%E7%9A%84%E6%93%8D%E4%BD%9C%3A\">链表的操作:</a></p>\n<p id=\"%C2%A0%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A0%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8\"> 双向链表</a></p>\n<p id=\"%E9%93%BE%E8%A1%A8%E4%B8%8E%E6%95%B0%E7%BB%84%E7%9A%84%E5%AF%B9%E6%AF%94-toc\" style=\"margin-left:40px;\"><a href=\"#%E9%93%BE%E8%A1%A8%E4%B8%8E%E6%95%B0%E7%BB%84%E7%9A%84%E5%AF%B9%E6%AF%94\">链表与数组的对比</a></p>\n<p id=\"%E4%BA%8C%E3%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%9B%E5%BB%BA-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BA%8C%E3%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%9B%E5%BB%BA\">二、链表的创建</a></p>\n<p id=\"%C2%A0%E4%B8%89%E3%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E9%81%8D%E5%8E%86-toc\" style=\"margin-left:0px;\"><a href=\"#%C2%A0%E4%B8%89%E3%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E9%81%8D%E5%8E%86\"> 三、链表的遍历</a></p>\n<p id=\"%E5%9B%9B%E3%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E9%87%8A%E6%94%BE-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%9B%9B%E3%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E9%87%8A%E6%94%BE\">四、链表的释放</a></p>\n<p id=\"%C2%A0%E4%BA%94%E3%80%81%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9%E7%9A%84%E6%9F%A5%E6%89%BE-toc\" style=\"margin-left:0px;\"><a href=\"#%C2%A0%E4%BA%94%E3%80%81%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9%E7%9A%84%E6%9F%A5%E6%89%BE\"> 五、链表节点的查找</a></p>\n<p id=\"%E5%85%AD%E3%80%81%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9%E7%9A%84%E5%88%A0%E9%99%A4-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%85%AD%E3%80%81%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9%E7%9A%84%E5%88%A0%E9%99%A4\">六、链表节点的删除</a></p>\n<p id=\"%E4%B8%83%E3%80%81%E9%93%BE%E8%A1%A8%E4%B8%AD%E6%8F%92%E5%85%A5%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%83%E3%80%81%E9%93%BE%E8%A1%A8%E4%B8%AD%E6%8F%92%E5%85%A5%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9\">七、链表中插入一个节点</a></p>\n<p id=\"%E5%85%AB%E3%80%81%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%85%AB%E3%80%81%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F\">八、链表排序</a></p>\n<p id=\"%E4%B9%9D%E3%80%81%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E9%81%8D%E5%8E%86-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B9%9D%E3%80%81%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E9%81%8D%E5%8E%86\">九、双向链表的创建和遍历</a></p>\n<p id=\"%C2%A0%E5%8D%81%E3%80%81%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9-toc\" style=\"margin-left:0px;\"><a href=\"#%C2%A0%E5%8D%81%E3%80%81%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9\"> 十、双向链表插入节点</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h1 id=\"%E4%B8%80%E3%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E6%A6%82%E5%BF%B5\">一、链表的概念</h1>\n<p>定义：</p>\n<p>      链表是一种物理存储上非连续，数据元素的逻辑顺序通过链表中的指针链接次序，实现的一种线性存储结构。</p>\n<p>特点：</p>\n<p>      链表由一系列节点（链表中每一个元素称为节点）组成，节点在运行时动态生成 （malloc），每个节点包括两个部分：</p>\n<p>     一个是存储数据元素的<strong>数据域</strong></p>\n<p>     另一个是存储下一个节点地址的<strong>指针域</strong></p>\n<p><img alt=\"\" height=\"154\" src=\"image\\92f50c18ef4a40c3bdb364bfaca97911.png\" width=\"841\"/></p>\n<p style=\"text-align:center;\">图1 单向链表</p>\n<p style=\"text-align:center;\"></p>\n<h2 id=\"%C2%A0%E9%93%BE%E8%A1%A8%E7%9A%84%E6%9E%84%E6%88%90%EF%BC%9A\"> <strong>链表的构成：</strong></h2>\n<p>      链表由一个个节点构成，每个节点一般采用结构体的形式组织，例如：</p>\n<pre><code>typedef struct student｛\n int num；\n char name[20]；\n struct student *next；\n }STU;</code></pre>\n<p>      链表节点分为两个域</p>\n<p>      数据域：存放各种实际的数据，如：num、score等</p>\n<p>      指针域：存放下一节点的首地址，如：next等.</p>\n<p><img alt=\"\" height=\"359\" src=\"image\\86f0e5523d5b4dbdb521008d3f3f88a0.png\" width=\"1200\"/></p>\n<p style=\"text-align:center;\">图2 节点内嵌在一个数据结构中</p>\n<h2 id=\"%E9%93%BE%E8%A1%A8%E7%9A%84%E6%93%8D%E4%BD%9C%3A\"><strong>链表的操作:</strong></h2>\n<p>      链表最大的作用是通过节点把离散的数据链接在一起，组成一个表，这大概就是链表 的字面解释了吧。 链表常规的操作就是节点的插入和删除，为了顺利的插入，通常一条链 表我们会人为地规定一个根节点，这个根节点称为生产者。通常根节点还会有一个节点计 数器，用于统计整条链表的节点个数，具体见图2中的 root_node。</p>\n<p><img alt=\"\" height=\"257\" src=\"image\\348e220ab4fb4cc2801496e34365c0b2.png\" width=\"1200\"/></p>\n<p style=\"text-align:center;\">图3带根节点的链表</p>\n<h2 id=\"%C2%A0%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8\"> <strong>双向链表</strong></h2>\n<p>      双向链表与单向链表的区别就是节点中有两个节点指针，分别指向前后两个节点，其 它完全一样。有关双向链表的文字描述参考单向链表小节即可，有关双向链表的示意图具 体见图3</p>\n<p><img alt=\"\" height=\"286\" src=\"image\\8c7ddf0aba4545e1a6e72abdc9d68084.png\" width=\"1200\"/></p>\n<p style=\"text-align:center;\">图4双向链表</p>\n<h2 id=\"%E9%93%BE%E8%A1%A8%E4%B8%8E%E6%95%B0%E7%BB%84%E7%9A%84%E5%AF%B9%E6%AF%94\"><strong>链表与数组的对比</strong></h2>\n<p>      在很多公司的嵌入式面试中，通常会问到链表和数组的区别。在 C 语言中，链表与数 组确实很像，两者的示意图具体见图4，这里以双向链表为例。</p>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"373\" src=\"image\\eedb9c025a1e47e39ac98316011b6634.png\" width=\"1200\"/>图5 链表与数组的对比</p>\n<p>      链表是通过节点把离散的数据链接成一个表，通过对节点的插入和删除操作从而实现 对数据的存取。而数组是通过开辟一段连续的内存来存储数据，这是数组和链表最大的区 别。数组的每个成员对应链表的节点，成员和节点的数据类型可以是标准的 C 类型或者是 用户自定义的结构体。数组有起始地址和结束地址，而链表是一个圈，没有头和尾之分， 但是为了方便节点的插入和删除操作会人为的规定一个根节点。</p>\n<h1 id=\"%E4%BA%8C%E3%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%9B%E5%BB%BA\">二、链表的创建</h1>\n<p>第一步：创建一个节点</p>\n<p><img alt=\"\" height=\"48\" src=\"image\\0752f3ea14114a7685f62518244cf246.png\" width=\"199\"/></p>\n<p> 第二步：创建第二个节点，将其放在第一个节点的后面（第一的节点的指针域保存第二个节点的地址）</p>\n<p><img alt=\"\" height=\"42\" src=\"image\\20feaccf3f0e495ca7a9e82c49f00800.png\" width=\"358\"/></p>\n<p>第三步：再次创建节点，找到原本链表中的最后一个节点，接着讲最后一个节点的指针域保存新节点的地址，以此内推。</p>\n<p><img alt=\"\" height=\"42\" src=\"image\\ea67f1e425854ff2bea38cdbda16ee20.png\" width=\"549\"/></p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n//定义结点结构体\ntypedef struct student\n{\n    //数据域\n    int num;\t\t//学号\n    int score;      //分数\n    char name[20];  //姓名\n    //指针域\n    struct student *next;\n}STU;\n\nvoid link_creat_head(STU **p_head,STU *p_new)\n{\n    STU *p_mov = *p_head;\n    if(*p_head == NULL)\t//当第一次加入链表为空时，head执行p_new\n    {\n        *p_head = p_new;\n        p_new-&gt;next=NULL;\n    }\n    else //第二次及以后加入链表\n    {\n        while(p_mov-&gt;next!=NULL)\n        {\n            p_mov=p_mov-&gt;next;\t//找到原有链表的最后一个节点\n        }\n\n        p_mov-&gt;next = p_new;\t//将新申请的节点加入链表\n        p_new-&gt;next = NULL;\n    }\n}\n\nint main()\n{\n    STU *head = NULL,*p_new = NULL;\n    int num,i;\n    printf(\"请输入链表初始个数:\\n\");\n    scanf(\"%d\",&amp;num);\n    for(i = 0; i &lt; num;i++)\n    {\n        p_new = (STU*)malloc(sizeof(STU));//申请一个新节点\n        printf(\"请输入学号、分数、名字:\\n\"); //给新节点赋值\n        scanf(\"%d %d %s\",&amp;p_new-&gt;num,&amp;p_new-&gt;score,p_new-&gt;name);\n\n        link_creat_head(&amp;head,p_new);\t//将新节点加入链表\n    }\n}\n</code></pre>\n<h1 id=\"%C2%A0%E4%B8%89%E3%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E9%81%8D%E5%8E%86\"> 三、链表的遍历</h1>\n<p>第一步：输出第一个节点的数据域，输出完毕后，让指针保存后一个节点的地址</p>\n<p><img alt=\"\" height=\"121\" src=\"image\\220bbe53929e4ab5b98b4b2c3e9e900e.png\" width=\"574\"/></p>\n<p> 第二步：输出移动地址对应的节点的数据域，输出完毕后，指针继续后移 </p>\n<p> <img alt=\"\" height=\"188\" src=\"image\\37a23e1d9da24726b7e4254fefcda8ce.png\" width=\"1136\"/></p>\n<p> 第三步：以此类推，直到节点的指针域为NULL</p>\n<pre><code>//链表的遍历\nvoid link_print(STU *head)\n{\n    STU *p_mov;\n    //定义新的指针保存链表的首地址，防止使用head改变原本链表\n    p_mov = head;\n    //当指针保存最后一个结点的指针域为NULL时，循环结束\n    while(p_mov!=NULL)\n    {\n        //先打印当前指针保存结点的指针域\n        printf(\"num=%d score=%d name:%s\\n\",p_mov-&gt;num,\\\n               p_mov-&gt;score,p_mov-&gt;name);\n\n        //指针后移，保存下一个结点的地址\n        p_mov = p_mov-&gt;next;\n    }\n}</code></pre>\n<h1 id=\"%E5%9B%9B%E3%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E9%87%8A%E6%94%BE\">四、链表的释放</h1>\n<p>重新定义一个指针q，保存p指向节点的地址，然后p后移保存下一个节点的地址，然后释放q对应的节点，以此类推，直到p为NULL为止</p>\n<p><img alt=\"\" height=\"100\" src=\"image\\7e0d1026e5024566910a953558d561e1.png\" width=\"490\"/><img alt=\"\" height=\"104\" src=\"image\\89a6c20e49d2495ca39ab75ce74691a3.png\" width=\"492\"/></p>\n<pre><code> //链表的释放\n void link_free(STU **p_head)\n {\n   //定义一个指针变量保存头结点的地址\n   STU *pb=*p_head;\n\n  while(*p_head!=NULL)\n  {\n   //先保存p_head指向的结点的地址\n   pb=*p_head;\n   //p_head保存下一个结点地址\n   *p_head=(*p_head)‐&gt;next;\n   //释放结点并防止野指针\n   free(pb);\n   pb = NULL;\n  }\n }</code></pre>\n<h1 id=\"%C2%A0%E4%BA%94%E3%80%81%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9%E7%9A%84%E6%9F%A5%E6%89%BE\"> 五、链表节点的查找</h1>\n<p>      先对比第一个结点的数据域是否是想要的数据，如果是就直接返回，如果不是则继续查找下 一个结点，如果到达最后一个结点的时候都没有匹配的数据，说明要查找数据不存在</p>\n<p></p>\n<pre><code>\n//链表的查找\n//按照学号查找\nSTU * link_search_num(STU *head,int num)\n{\n    STU *p_mov;\n    //定义的指针变量保存第一个结点的地址\n    p_mov=head;\n    //当没有到达最后一个结点的指针域时循环继续\n    while(p_mov!=NULL)\n    {\n        //如果找到是当前结点的数据，则返回当前结点的地址\n        if(p_mov-&gt;num == num)//找到了\n        {\n            return p_mov;\n        }\n        //如果没有找到，则继续对比下一个结点的指针域\n        p_mov=p_mov-&gt;next;\n    }\n\n    //当循环结束的时候还没有找到，说明要查找的数据不存在，返回NULL进行标识\n    return NULL;//没有找到\n}\n\n//按照姓名查找\nSTU * link_search_name(STU *head,char *name)\n{\n    STU *p_mov;\n    p_mov=head;\n    while(p_mov!=NULL)\n    {\n        if(strcmp(p_mov-&gt;name,name)==0)//找到了\n        {\n            return p_mov;\n        }\n        p_mov=p_mov-&gt;next;\n    }\n    return NULL;//没有找到\n}</code></pre>\n<h1 id=\"%E5%85%AD%E3%80%81%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9%E7%9A%84%E5%88%A0%E9%99%A4\">六、链表节点的删除</h1>\n<p>      如果链表为空，不需要删除 如果删除的是第一个结点，则需要将保存链表首地址的指针保存第一个结点的下一个结点的 地址 如果删除的是中间结点，则找到中间结点的前一个结点，让前一个结点的指针域保存这个结 点的后一个结点的地址即可</p>\n<pre><code>//链表结点的删除\nvoid link_delete_num(STU **p_head,int num)\n{\n    STU *pb,*pf;\n    pb=pf=*p_head;\n    if(*p_head == NULL)//链表为空，不用删\n    {\n        printf(\"链表为空，没有您要删的节点\");\\\n        return ;\n    }\n    while(pb-&gt;num != num &amp;&amp; pb-&gt;next !=NULL)//循环找，要删除的节点\n    {\n        pf=pb;\n        pb=pb-&gt;next;\n    }\n    if(pb-&gt;num == num)//找到了一个节点的num和num相同\n    {\n        if(pb == *p_head)//要删除的节点是头节点\n        {\n            //让保存头结点的指针保存后一个结点的地址\n            *p_head = pb-&gt;next;\n        }\n        else\n        {\n            //前一个结点的指针域保存要删除的后一个结点的地址\n            pf-&gt;next = pb-&gt;next;\n        }\n\n        //释放空间\n        free(pb);\n        pb = NULL;\n    }\n    else//没有找到\n    {\n        printf(\"没有您要删除的节点\\n\");\n    }\n}</code></pre>\n<h1 id=\"%E4%B8%83%E3%80%81%E9%93%BE%E8%A1%A8%E4%B8%AD%E6%8F%92%E5%85%A5%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9\">七、链表中插入一个节点</h1>\n<p>链表中插入一个结点，按照原本链表的顺序插入，找到合适的位置</p>\n<p><img alt=\"\" height=\"127\" src=\"image\\0f26fb9a1388439fb6e3f04ab8924995.png\" width=\"463\"/></p>\n<p> 情况（按照从小到大）：</p>\n<p>      如果链表没有结点，则新插入的就是第一个结点。</p>\n<p>      如果新插入的结点的数值最小，则作为头结点。</p>\n<p>      如果新插入的结点的数值在中间位置，则找到前一个，然后插入到他们中间。</p>\n<p>      如果新插入的结点的数值最大，则插入到最后。</p>\n<pre><code>//链表的插入：按照学号的顺序插入\nvoid link_insert_num(STU **p_head,STU *p_new)\n{\n    STU *pb,*pf;\n    pb=pf=*p_head;\n    if(*p_head ==NULL)// 链表为空链表\n    {\n        *p_head = p_new;\n        p_new-&gt;next=NULL;\n        return ;\n    }\n    while((p_new-&gt;num &gt;= pb-&gt;num)  &amp;&amp; (pb-&gt;next !=NULL) )\n    {\n        pf=pb;\n        pb=pb-&gt;next;\n    }\n\n    if(p_new-&gt;num &lt; pb-&gt;num)//找到一个节点的num比新来的节点num大，插在pb的前面\n    {\n        if(pb== *p_head)//找到的节点是头节点，插在最前面\n        {\n            p_new-&gt;next= *p_head;\n            *p_head =p_new;\n        }\n        else\n        {\n            pf-&gt;next=p_new;\n            p_new-&gt;next = pb;\n        }\n    }\n    else//没有找到pb的num比p_new-&gt;num大的节点，插在最后\n    {\n        pb-&gt;next =p_new;\n        p_new-&gt;next =NULL;\n    }\n}</code></pre>\n<h1 id=\"%E5%85%AB%E3%80%81%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F\">八、链表排序</h1>\n<p>      如果链表为空，不需要排序。</p>\n<p>      如果链表只有一个结点，不需要排序。</p>\n<p>      先将第一个结点与后面所有的结点依次对比数据域，只要有比第一个结点数据域小的，则交 换位置。</p>\n<p>       交换之后，拿新的第一个结点的数据域与下一个结点再次对比，如果比他小，再次交换，依 次类推。</p>\n<p>      第一个结点确定完毕之后，接下来再将第二个结点与后面所有的结点对比，直到最后一个结 点也对比完毕为止。</p>\n<pre><code>//链表的排序\nvoid link_order(STU *head)\n{\n    STU *pb,*pf,temp;\n    pf=head;\n\n    if(head==NULL)\n    {\n        printf(\"链表为空,不用排序\\n\");\n        return ;\n    }\n\n    if(head-&gt;next ==NULL)\n    {\n        printf(\"只有一个节点，不用排序\\n\");\n        return ;\n    }\n\n    while(pf-&gt;next !=NULL)//以pf指向的节点为基准节点，\n    {\n        pb=pf-&gt;next;//pb从基准元素的下个元素开始\n        while(pb!=NULL)\n        {\n            if(pf-&gt;num &gt; pb-&gt;num)\n            {\n                temp=*pb;\n                *pb=*pf;\n                *pf=temp;\n\n                temp.next=pb-&gt;next;\n                pb-&gt;next=pf-&gt;next;\n                pf-&gt;next=temp.next;\n            }\n            pb=pb-&gt;next;\n        }\n        pf=pf-&gt;next;\n    }\n}</code></pre>\n<h1 id=\"%E4%B9%9D%E3%80%81%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E9%81%8D%E5%8E%86\">九、双向链表的创建和遍历</h1>\n<p>第一步：创建一个节点作为头节点，将两个指针域都保存NULL</p>\n<p><img alt=\"\" height=\"82\" src=\"image\\5790d7cc3c634805939fb5ddd41637d1.png\" width=\"251\"/></p>\n<p>第二步：先找到链表中的最后一个节点，然后让最后一个节点的指针域保存新插入节点的地址，新插入节点的两个指针域，一个保存上一个节点的地址，一个保存NULL</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n//定义结点结构体\ntypedef struct student\n{\n    //数据域\n    int num;\t\t//学号\n    int score;      //分数\n    char name[20];  //姓名\n\n    //指针域\n    struct student *front;  //保存上一个结点的地址\n    struct student *next;   //保存下一个结点的地址\n}STU;\n\nvoid double_link_creat_head(STU **p_head,STU *p_new)\n{\n    STU *p_mov=*p_head;\n    if(*p_head==NULL)\t\t\t\t//当第一次加入链表为空时，head执行p_new\n    {\n        *p_head = p_new;\n        p_new-&gt;front = NULL;\n        p_new-&gt;next = NULL;\n    }\n    else\t//第二次及以后加入链表\n    {\n        while(p_mov-&gt;next!=NULL)\n        {\n            p_mov=p_mov-&gt;next;\t//找到原有链表的最后一个节点\n        }\n        p_mov-&gt;next = p_new;\t\t//将新申请的节点加入链表\n        p_new-&gt;front = p_mov;\n        p_new-&gt;next = NULL;\n    }\n}\n\n\nvoid double_link_print(STU *head)\n{\n    STU *pb;\n    pb=head;\n    while(pb-&gt;next!=NULL)\n    {\n        printf(\"num=%d score=%d name:%s\\n\",pb-&gt;num,pb-&gt;score,pb-&gt;name);\n        pb=pb-&gt;next;\n    }\n    printf(\"num=%d score=%d name:%s\\n\",pb-&gt;num,pb-&gt;score,pb-&gt;name);\n\n    printf(\"***********************\\n\");\n\n    while(pb!=NULL)\n    {\n        printf(\"num=%d score=%d name:%s\\n\",pb-&gt;num,pb-&gt;score,pb-&gt;name);\n        pb=pb-&gt;front;\n    }\n}\n\nint main()\n{\n    STU *head=NULL,*p_new=NULL;\n    int num,i;\n    printf(\"请输入链表初始个数:\\n\");\n    scanf(\"%d\",&amp;num);\n    for(i=0;i&lt;num;i++)\n    {\n        p_new=(STU*)malloc(sizeof(STU));//申请一个新节点\n        printf(\"请输入学号、分数、名字:\\n\");\t//给新节点赋值\n        scanf(\"%d %d %s\",&amp;p_new-&gt;num,&amp;p_new-&gt;score,p_new-&gt;name);\n        double_link_creat_head(&amp;head,p_new);\t//将新节点加入链表\n    }\n\n    double_link_print(head);\n}\n</code></pre>\n<h1 id=\"%C2%A0%E5%8D%81%E3%80%81%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9\"> 十、双向链表插入节点</h1>\n<p>按照顺序插入结点</p>\n<p><img alt=\"\" height=\"184\" src=\"image\\2f9617fd9d0847479ef71feb1219529f.png\" width=\"400\"/></p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n//定义结点结构体\ntypedef struct student\n{\n    //数据域\n    int num;\t\t//学号\n    int score;      //分数\n    char name[20];  //姓名\n\n    //指针域\n    struct student *front;  //保存上一个结点的地址\n    struct student *next;   //保存下一个结点的地址\n}STU;\n\nvoid double_link_creat_head(STU **p_head,STU *p_new)\n{\n    STU *p_mov=*p_head;\n    if(*p_head==NULL)\t\t\t\t//当第一次加入链表为空时，head执行p_new\n    {\n        *p_head = p_new;\n        p_new-&gt;front = NULL;\n        p_new-&gt;next = NULL;\n    }\n    else\t//第二次及以后加入链表\n    {\n        while(p_mov-&gt;next!=NULL)\n        {\n            p_mov=p_mov-&gt;next;\t//找到原有链表的最后一个节点\n        }\n        p_mov-&gt;next = p_new;\t\t//将新申请的节点加入链表\n        p_new-&gt;front = p_mov;\n        p_new-&gt;next = NULL;\n    }\n}\n\n\nvoid double_link_print(STU *head)\n{\n    STU *pb;\n    pb=head;\n    while(pb-&gt;next!=NULL)\n    {\n        printf(\"num=%d score=%d name:%s\\n\",pb-&gt;num,pb-&gt;score,pb-&gt;name);\n        pb=pb-&gt;next;\n    }\n    printf(\"num=%d score=%d name:%s\\n\",pb-&gt;num,pb-&gt;score,pb-&gt;name);\n\n    printf(\"***********************\\n\");\n\n    while(pb!=NULL)\n    {\n        printf(\"num=%d score=%d name:%s\\n\",pb-&gt;num,pb-&gt;score,pb-&gt;name);\n        pb=pb-&gt;front;\n    }\n}\n\n//双向链表的删除\nvoid double_link_delete_num(STU **p_head,int num)\n{\n    STU *pb,*pf;\n    pb=*p_head;\n    if(*p_head==NULL)//链表为空，不需要删除\n    {\n        printf(\"链表为空，没有您要删除的节点\\n\");\n        return ;\n    }\n    while((pb-&gt;num != num) &amp;&amp; (pb-&gt;next != NULL) )\n    {\n        pb=pb-&gt;next;\n    }\n    if(pb-&gt;num == num)//找到了一个节点的num和num相同，删除pb指向的节点\n    {\n        if(pb == *p_head)//找到的节点是头节点\n        {\n            if((*p_head)-&gt;next==NULL)//只有一个节点的情况\n            {\n                *p_head=pb-&gt;next;\n            }\n            else//有多个节点的情况\n            {\n                *p_head = pb-&gt;next;//main函数中的head指向下个节点\n                (*p_head)-&gt;front=NULL;\n            }\n        }\n        else//要删的节点是其他节点\n        {\n            if(pb-&gt;next!=NULL)//删除中间节点\n            {\n                pf=pb-&gt;front;//让pf指向找到的节点的前一个节点\n                pf-&gt;next=pb-&gt;next; //前一个结点的next保存后一个结点的地址\n                (pb-&gt;next)-&gt;front=pf; //后一个结点的front保存前一个结点的地址\n            }\n            else//删除尾节点\n            {\n                pf=pb-&gt;front;\n                pf-&gt;next=NULL;\n            }\n        }\n\n        free(pb);//释放找到的节点\n\n    }\n    else//没找到\n    {\n        printf(\"没有您要删除的节点\\n\");\n    }\n}\n\nint main()\n{\n    STU *head=NULL,*p_new=NULL;\n    int num,i;\n    printf(\"请输入链表初始个数:\\n\");\n    scanf(\"%d\",&amp;num);\n    for(i=0;i&lt;num;i++)\n    {\n        p_new=(STU*)malloc(sizeof(STU));//申请一个新节点\n        printf(\"请输入学号、分数、名字:\\n\");\t//给新节点赋值\n        scanf(\"%d %d %s\",&amp;p_new-&gt;num,&amp;p_new-&gt;score,p_new-&gt;name);\n        double_link_creat_head(&amp;head,p_new);\t//将新节点加入链表\n    }\n\n    double_link_print(head);\n\n    printf(\"请输入您要删除的节点的num\\n\");\n    scanf(\"%d\",&amp;num);\n    double_link_delete_num(&amp;head,num);\n    double_link_print(head);\n\n}\n</code></pre>\n<p></p>\n<p></p>\n</div>\n</div>"}