{"blogid": "125291396", "writerAge": "码龄5年", "writerBlogNum": "56", "writerCollect": "83", "writerComment": "6", "writerFan": "22", "writerGrade": "3级", "writerIntegral": "740", "writerName": "丿灬鑫崽丶", "writerProfileAdress": "writer_image\\profile_125291396.jpg", "writerRankTotal": "26722", "writerRankWeekly": "214977", "writerThumb": "11", "writerVisitNum": "36920", "blog_read_count": "913", "blog_time": "于 2022-06-15 13:32:03 发布", "blog_title": "C#：异步编程", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>异步操作表示执行某项操作之后不等待操作结束，但可以在操作结束后收到通知。</p>\n<p>示例：</p>\n<pre><code class=\"language-cs\">    public static class demo13\n    {\n        public static void Send(IPAddress address, int port)\n        {\n            var client = new TcpClient();\n            try\n            {\n                client.Connect(address, port);\n                client.GetStream().Write(Encoding.ASCII.GetBytes(\"Hello\"));\n            }\n            catch (Exception e)\n            {\n                Console.WriteLine(e);\n                throw;\n            }\n            finally\n            {\n                client.Close();\n            }\n        }\n    }</code></pre>\n<p>示例是一个调用阻塞操作的例子。tcp连接的方法就是一个阻塞操作，只有连接成功或是失败的时候才会回复。发送数据也是同样的。线程阻塞的时候操作系统会调度这些执行操作的线程进入等待状态，等到操作完成后再重新把线程放入待运行队列中并调度执行。</p>\n<p>这种方式会出现一个问题，如果我们要同时管理多个tcp连接，那么我们就需要创建很多的线程，每个线程分配的栈空间加起来就会消耗很多的内存。在linux平台下，一个线程栈会默认分配8~10M的空间，也就是说太多的线程就会导致内存空间不足。并且操作系统调度线程需要的时间也会变长，会导致性能下降。<br/>  </p>\n<h2>Event Loop</h2>\n<hr/>\n<p>解决多线程缺陷的方法之一就是使用Event Loop。</p>\n<p>Event Loop事件循环机制。程序有一个或多个线程专门用于捕获对象检查状态，把执行的阻塞操作换为非阻塞操作，再注册事件以在处理完成后收到通知。js中的异步就是使用的事件循环机制实现的。</p>\n<p></p>\n<h2>APM</h2>\n<hr/>\n<p>异步编程模型，.NET提供的基于异步回调的操作。</p>\n<p>.NET Core在不同的系统上使用不同的方式实现APM。在windows上是通过IOCP（一组支持多个同时发生异步I/O操作的接口）实现的；在Linux上是通过epoll（多路复用IO接口）实现的；而在mac上是通过kqueue接口实现的。虽然针对不同的系统使用的方式不同，但是实现出来的功能是相同的。</p>\n<p>示例：</p>\n<pre><code class=\"language-cs\">    public static class demo11\n    {\n        public static void Send(IPAddress address, int port)\n        {\n            var client = new TcpClient();\n            // 开始异步连接\n            client.BeginConnect(address,port,ar =&gt;\n            {\n                // 无论成功还是失败都会调用这个回调\n                try\n                {\n                    client.EndConnect(ar);\n                }\n                catch (Exception e) {\n                    Console.WriteLine(e);\n                    client.Close();\n                }\n\n                var bytes = Encoding.ASCII.GetBytes(\"Hello\");\n                var stream = client.GetStream();\n                stream.BeginWrite(bytes, 0, bytes.Length, result =&gt;\n                {\n                    try\n                    {\n\n                    }\n                    catch (Exception e)\n                    {\n                        Console.WriteLine(e);\n                    }\n                    finally\n                    {\n                        client.Close();\n                    }\n                },null);\n            },null);\n        }\n    }</code></pre>\n<p></p>\n<h2>TPL</h2>\n<hr/>\n<p>任务并行库。由于基于回调的异步操作的通用性不够强，.NET在此基础之上又封装了一层以任务（Task）为基础的接口。</p>\n<p>TPL最大的特点就是分离了执行异步操作与注册回调的处理。这样一来，我们就可以让任何异步操作都具有相同的方法注册回调、等待结束和处理错误。并且为支持之后的async、await打下了基础。</p>\n<p>示例：</p>\n<pre><code class=\"language-cs\">    public static class demo12\n    {\n        public static void test(IPAddress address, int port)\n        {\n            // 创建1万个Task\n            var tasks = new Task[10000];\n            for (var i = 0; i &lt; tasks.Length; i++)\n            {\n                // SendAsync 本身就是一个异步方法\n                tasks[i] = SendAsync(address, port);\n            }\n            // 等待所有异步操作执行完成\n            Task.WaitAll(tasks);\n        }\n\n        public static Task SendAsync(IPAddress address, int port)\n        {\n            var client = new TcpClient();\n            // 异步连接\n            var task = client.ConnectAsync(address, port);\n            var a = new TaskFactory();\n\n            // 异步发送数据\n            var task1 = task.ContinueWith(t =&gt; {\n                var bytes = Encoding.ASCII.GetBytes(\"Hello\");\n                var stream = client.GetStream();\n                // 返回一个新的task\n                // 这里会产生Task&lt;Task&gt;嵌套\n                // 在外部使用Unwrap方法解包\n                return stream.WriteAsync(bytes,0,bytes.Length);\n            }).Unwrap();\n\n            // 异步处理发送结果\n            var task2 = task1.ContinueWith(t =&gt; {\n                if (t.IsFaulted)\n                {\n                    // 失败\n                }\n                else if (t.IsCompleted)\n                { \n                    // 完成\n                }\n                client.Close();\n            });\n            return task2;\n        }\n    }</code></pre>\n<p></p>\n<h2>async和await</h2>\n<hr/>\n<p>由TPL支持，极大的简化了异步方法的编写。</p>\n<p>async用于标记方法，标记的方法会使用await执行异步操作。然后把整个方法合并成一个异步操作。</p>\n<p>示例：</p>\n<pre><code class=\"language-cs\">    public static class demo14\n    {\n        // async关键字是给编译器看的，为了生产状态机\n        public static async Task SendAsync(IPAddress address, int port)\n        {\n            var client = new TcpClient();\n            try\n            {\n                // 异步连接\n                await client.ConnectAsync(address,port);\n                // 连接成功后会从这里继续开始执行\n                // 失败时会抛出异常并在下面的catch块中被捕捉\n\n                var bytes = Encoding.ASCII.GetBytes(\"Hello\");\n                var stream = client.GetStream();\n                // 异步发送数据\n                await stream.WriteAsync(bytes,0,bytes.Length);\n                // 发送成功后会从这里继续开始执行\n                // 失败时会抛出异常并在下面的catch块中被捕捉\n                Console.WriteLine(\"发送完成\");\n            }\n            catch (Exception e)\n            {\n                Console.WriteLine(e);\n            }\n            finally\n            {\n                client.Close();\n            }\n        }\n    }</code></pre>\n<p>前面的示例异步读取字符串中的行。 读取每一行后，代码将枚举字符串中的每个单词。 调用方将使用 <code>await foreach</code> 语句枚举每个单词。 当需要从源字符串异步读取下一行时，该方法将等待。</p>\n<p></p>\n<h2>取消任务</h2>\n<hr/>\n<p>在.Net和C#中运行异步代码相当简单，但是我们有时候需要<strong>取消正在进行的异步操作</strong>，这时我们可以通过CancellationToken来取消任务。</p>\n<p><strong>1. 可重复执行的耗时方法。</strong>示例：</p>\n<pre><code class=\"language-cs\">Task _task = null;\nCancellationTokenSource _cts = null;\n\nprivate void Refresh()\n{\n  if(this._task != null &amp;&amp; !this._task.IsCompleted)\n    this._cts.Cancel();\n  //\n  this._cts = new CancellationTokenSource();\n  this._task = Task.Run(() =&gt; {\n    if(this._cts.IsCancellationRequested)\n      return;\n    \n    //do something\n  }, this._cts.Token);\n}\n\n</code></pre>\n<p><strong>2. 生命周期结束取消未完成任务。</strong>示例：</p>\n<pre><code class=\"language-cs\">//本地变量\nTask _task = null;\nCancellationTokenSource _cts = null;\n\n//初始化时，开启倒计时任务\nprivate void Init()\n{\n  this._cts = new CancellationTokenSource();\n  this._task = Task.Run(() =&gt; {\n    if(this._cts.IsCancellationRequested)\n      return;\n\n    //do something\n  },  this._cts.Token)\n}\n\n//退出时，取消未完成任务\nprivate void Exit()\n{\n  if(this._task != null &amp;&amp; !this._task.IsCompleted)\n    this._cts.Cancel();\n}\n</code></pre>\n<p></p>\n<p>参考：<a class=\"link-info\" href=\"https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/async/\" title=\"Microsoft C# 异步编程\">Microsoft C# 异步编程</a></p>\n</div>\n</div>"}