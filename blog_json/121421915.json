{"blogid": "121421915", "writerAge": "码龄5年", "writerBlogNum": "5", "writerCollect": "20", "writerComment": "0", "writerFan": "4", "writerGrade": "2级", "writerIntegral": "177", "writerName": "Trinity_Force", "writerProfileAdress": "writer_image\\profile_121421915.jpg", "writerRankTotal": "279784", "writerRankWeekly": "322739", "writerThumb": "4", "writerVisitNum": "17871", "blog_read_count": "3254", "blog_time": "于 2021-11-19 14:44:10 发布", "blog_title": "C#Socket通信，解决粘包和分包问题", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>源码下载，学习的时候做的，现在可以做到一个服务端对应多个客户端同时接受消息，也解决了分包和粘包的问题，欢迎下载</p>\n<p><a class=\"has-card\" href=\"https://download.csdn.net/download/Trinity_Force/44900216\" title=\"(16条消息) 网络通信编程学习.7z-C#文档类资源-CSDN文库\"><span class=\"link-card-box\"><span class=\"link-title\">(16条消息) 网络通信编程学习.7z-C#文档类资源-CSDN文库</span><span class=\"link-link\"><img alt=\"\" class=\"link-link-icon\" src=\"image\\icon-default.png\"/>https://download.csdn.net/download/Trinity_Force/44900216</span></span></a></p>\n<h1>什么是粘包分包</h1>\n<ol><li>TCP是<span style=\"color:#fa0000;\">面向连接</span>的协议</li><li>TCP是点到点的通信</li><li>TCP提供可靠的传输服务</li><li>TCP协议提供全双工的通信</li><li>TCP协议面向<span style=\"color:#fa0000;\">字节流</span>进行传输的，可以对用户的数据进行拆分或合并</li></ol>\n<p style=\"margin-left:0;\">        TCP协议是面向字节流传输的，TCP协议会保证字节流传输时顺序不会改变，不会丢失内容，但是TCP协议会灵活的拆分或者合并用户Socket.Send(buffer)出来的内容，将小的数据整合发送或者是将大的数据拆开发送。</p>\n<p style=\"margin-left:0;\">        所以在实际的编程中就会出现服务端一次Receive就收到了客户端多次Send的数据（“粘包”），或者是客户端只Send了一次，服务端却要多次Receive才能完整接收。</p>\n<p style=\"margin-left:0;\"><strong>粘包示例</strong>：客户端发送了一万条“Hello”到服务端，结果服务端收到的是这样的</p>\n<p style=\"margin-left:0;\"><img alt=\"\" height=\"482\" src=\"image\\bbdfb30ccf2a476294e8742b456c6d7b.png\" width=\"802\"/></p>\n<p><strong>分包示例</strong>：客户端发送了一大串“a”到服务端，结果服务端是分三次收到的。</p>\n<p><img alt=\"\" height=\"479\" src=\"image\\c42be442909f4cdc9c2c6ada75ec66b6.png\" width=\"1200\"/></p>\n<h2> 解决方法</h2>\n<p style=\"margin-left:0;\">自己自定义报文格式，发送时根据固定的格式封包，接收时再按照这个格式解包</p>\n<p style=\"margin-left:0;\"><strong>1 数据包首部添加数据包长度</strong></p>\n<p style=\"margin-left:0;\">接收到数据时，先解析首部的“数据包长度”，再解析数据包内容，如果数据包内容的长度不足数据包首部规定的长度，则认为出现了“分包”，需要等待接收下一个数据包，直到传输完整。如果数据包内容的长度大于数据包首部规定的长度，则出现了“粘包”需要认为将粘包分开。</p>\n<p style=\"margin-left:0;\"><strong>2 数据包结尾添加固定的分隔符</strong></p>\n<p style=\"margin-left:0;\">接收到数据后，如果出现结尾标识，则人为将粘包分开，如果一个包中没有结尾标识，则认为出现了“分包”，需要等待下一个数据包，直到出现结尾标识</p>\n<p style=\"margin-left:0;\"><strong>客户端发送时的封包方法</strong></p>\n<pre><code class=\"language-cs\">private void BtnSend_Click(object sender, EventArgs e)\n        {\n            byte[] dataToBeSend = GetSendData(TextSendData.Text.Trim());\n            if (int.TryParse(textRepeatTimes.SelectedItem.ToString(), out int times))\n            {\n                int dataSize = 0;\n                for (int i = 0; i &lt; times; i++)\n                {\n                    dataSize += ClientSocket.Send(dataToBeSend);\n                }\n                ShowReceiveDataWithDelegate($\"共发送{dataSize}字节的数据\");\n            }\n        }\n\n        private byte[] GetSendData(string text)\n        {\n            //数据包内容\n            byte[] content = Encoding.Default.GetBytes(text);\n            //数据包头部\n            byte[] header = new byte[4];\n            ConvertIntToByteArray(content.Length, ref header);\n            //最终封装好的数据包，数据包首位 0 消息 1 文件，2-5位 数据长度\n            byte[] dataToBeSend = new byte[content.Length + 5];\n            dataToBeSend[0] = 0;\n            Array.Copy(header, 0, dataToBeSend, 1, header.Length);\n            Array.Copy(content, 0, dataToBeSend, 5, content.Length);\n            return dataToBeSend;\n        }\n\n        /// &lt;summary&gt;\n        /// 把int32类型的数据转存到4个字节的byte数组中\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"m\"&gt;int32类型的数据\n        /// &lt;param name=\"arry\"&gt;4个字节大小的byte数组\n        /// &lt;returns&gt;&lt;/returns&gt;\n        private bool ConvertIntToByteArray(Int32 m, ref byte[] arry)\n        {\n            if (arry == null) return false;\n            if (arry.Length &lt; 4) return false;\n            arry[0] = (byte)(m &amp; 0xFF);\n            arry[1] = (byte)((m &amp; 0xFF00) &gt;&gt; 8);\n            arry[2] = (byte)((m &amp; 0xFF0000) &gt;&gt; 16);\n            arry[3] = (byte)((m &gt;&gt; 24) &amp; 0xFF);\n            return true;\n        }</code></pre>\n<p style=\"margin-left:0;\">服务端解包类</p>\n<pre><code class=\"language-cs\">using System;\nusing System.Collections.Generic;\n\nnamespace AsyncSocketServer\n{\n    /// &lt;summary&gt;\n    /// SocketTCP通信解包类，包格式为：内容类型（1位）内容长度（4位）剩余。。\n    /// 读取完DataList的数据后请务必执行Clear方法();\n    /// &lt;/summary&gt;\n    public class SocketTcpPack\n    {\n        /// &lt;summary&gt;\n        /// 接收是否完成了\n        /// &lt;/summary&gt;\n        public bool IsComplete = false;\n\n        /// &lt;summary&gt;\n        /// 接收缓存\n        /// &lt;/summary&gt;\n        public byte[] Buffer;\n\n        /// &lt;summary&gt;\n        /// 下次接收从Buffer的哪里开始写入\n        /// &lt;/summary&gt;\n        public int Offset = 0;\n\n        /// &lt;summary&gt;\n        /// 下次写入Buffer的长度\n        /// &lt;/summary&gt;\n        public int Size;\n\n        /// &lt;summary&gt;\n        /// 接收到的数据\n        /// &lt;/summary&gt;\n        public List&lt;ReceiveDataModel&gt; DataList = new List&lt;ReceiveDataModel&gt;();\n\n        /// &lt;summary&gt;\n        /// 缓存长度\n        /// &lt;/summary&gt;\n        private readonly int BufferLength;\n\n        public SocketTcpPack(int bufferLength = 1024)\n        {\n            BufferLength = bufferLength;\n            Buffer = new byte[BufferLength];\n            Size = BufferLength;\n        }\n\n        /// &lt;summary&gt;\n        /// 处理接收到的数据\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"currentDataSize\"&gt;接收到的数据长度，Socket.Receive()方法返回的数值&lt;/param&gt;\n        public void UntiePack(int currentDataSize)\n        {\n            //Size != BufferLength说明Buffer中保留了一些上次接收的数据，要把这部分数据长度加上\n            int dataSize = currentDataSize;\n            if (Size != BufferLength)\n            {\n                dataSize += Offset;\n            }\n\n            if (DataList.Count == 0)\n            {\n                SplitData(Buffer, dataSize);\n            }\n            else\n            {\n                //取出DataList中的最后一个元素，通过判断这个元素是否完整来判断是有分包需要补充完整\n                ReceiveDataModel LastReceiveData = DataList[DataList.Count - 1];\n                if (LastReceiveData.IsComplete)\n                {\n                    SplitData(Buffer, dataSize);\n                }\n                else\n                {\n                    //最后一个包的剩余长度\n                    int remainingDataLength = LastReceiveData.DataLength - LastReceiveData.Content.Length;\n                    //剩余长度 &lt; 本次接收的数据长度，说明这一次接收就可以把上一个分包补充完整\n                    if (remainingDataLength &lt; dataSize)\n                    {\n                        int realLength = LastReceiveData.Content.Length;\n                        byte[] b = new byte[LastReceiveData.DataLength];\n                        Array.Copy(LastReceiveData.Content, 0, b, 0, LastReceiveData.Content.Length);\n                        LastReceiveData.Content = b;\n                        Array.Copy(Buffer, 0, LastReceiveData.Content, realLength, remainingDataLength);\n\n                        //继续处理剩下的数据\n                        byte[] last = new byte[dataSize - remainingDataLength];\n                        Array.Copy(Buffer, remainingDataLength, last, 0, last.Length);\n                        SplitData(last, last.Length);\n                    }\n                    //剩余长度 &gt; 本次接收的数据长度，说明这一次接收还不能把上一个分包补充完整，还需要继续等待接收\n                    else if (remainingDataLength &gt; dataSize)\n                    {\n                        int realLength = LastReceiveData.Content.Length;\n                        byte[] b = new byte[LastReceiveData.Content.Length + dataSize];\n                        Array.Copy(LastReceiveData.Content, 0, b, 0, LastReceiveData.Content.Length);\n                        LastReceiveData.Content = b;\n                        Array.Copy(Buffer, 0, LastReceiveData.Content, realLength, dataSize);\n\n                        Offset = 0;\n                        Size = BufferLength;\n                        Buffer = new byte[BufferLength];\n                    }\n                    else\n                    {\n                        int realLength = LastReceiveData.Content.Length;\n                        byte[] b = new byte[LastReceiveData.DataLength];\n                        Array.Copy(LastReceiveData.Content, 0, b, 0, LastReceiveData.Content.Length);\n                        LastReceiveData.Content = b;\n                        Array.Copy(Buffer, 0, LastReceiveData.Content, realLength, remainingDataLength);\n\n                        Offset = 0;\n                        Size = BufferLength;\n                        Buffer = new byte[BufferLength];\n                        IsComplete = true;\n                    }\n                }\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// 处理byte[]前5位就是包首部的这种数据\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"data\"&gt;byte[]&lt;/param&gt;\n        /// &lt;param name=\"dataSize\"&gt;内容的实际长度&lt;/param&gt;\n        private void SplitData(byte[] data, int dataSize)\n        {\n            //长度 &lt;= 5 说明包首部还没有接收完成，需要继续接收\n            if (dataSize &lt;= 5)\n            {\n                byte[] temp = new byte[BufferLength];\n                Array.Copy(data, 0, temp, 0, dataSize);\n                Buffer = temp;\n                Offset = dataSize;\n                Size = BufferLength - dataSize;\n                IsComplete = true;\n                return;\n            }\n\n            //包首部\n            byte[] header = new byte[5];\n            //包内容\n            byte[] content = new byte[dataSize - 5];\n\n            Array.Copy(data, 0, header, 0, 5);\n            Array.Copy(data, 5, content, 0, dataSize - 5);\n\n            //包内容长度\n            int dataLength = BitConverter.ToInt32(header, 1);\n\n            //dataLength &lt; content.Length 说明本次接收的数据中已经包含一个完整的包，将这个完整的包取出后继续处理剩下的数据\n            if (dataLength &lt; content.Length)\n            {\n                //发生了粘包\n                byte[] b = new byte[dataLength];\n                Array.Copy(content, 0, b, 0, dataLength);\n                ReceiveDataModel receiveData = new ReceiveDataModel()\n                {\n                    DataType = header[0],\n                    DataLength = dataLength,\n                    Content = b\n                };\n                DataList.Add(receiveData);\n                byte[] last = new byte[content.Length - dataLength];\n                Array.Copy(content, dataLength, last, 0, last.Length);\n                SplitData(last, last.Length);\n            }\n            //dataLength &gt;= content.Length 说明本次接收的数据不完整，保存后继续接收\n            else if (dataLength &gt;= content.Length)\n            {\n                //发生了分包或者什么都没发生\n                ReceiveDataModel receiveData = new ReceiveDataModel()\n                {\n                    DataType = header[0],\n                    DataLength = dataLength,\n                    Content = content\n                };\n                DataList.Add(receiveData);\n                Offset = 0;\n                Size = BufferLength;\n                Buffer = new byte[BufferLength];\n                if (dataLength == content.Length) IsComplete = true;\n            }\n        }\n\n        public void Clear()\n        {\n            if (DataList.Count &gt; 0)\n            {\n                DataList.Clear();\n                IsComplete = false;\n            }\n        }\n    }\n}</code></pre>\n<p>发送时调用这个类</p>\n<pre><code class=\"language-cs\">using System;\nusing System.Collections.Generic;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Text;\nusing System.Windows.Forms;\n\nnamespace AsyncSocketServer\n{\n    public partial class Server : Form\n    {\n        public Server()\n        {\n            InitializeComponent();\n        }\n\n        /// &lt;summary&gt;\n        /// 存储客户端连接\n        /// &lt;/summary&gt;\n        private Dictionary&lt;string, Socket&gt; ClientSocketList = new Dictionary&lt;string, Socket&gt;();\n\n        /// &lt;summary&gt;\n        /// 接收数据缓冲区\n        /// &lt;/summary&gt;\n        private Dictionary&lt;string, SocketTcpPack&gt; ReceiveBufferDic = new Dictionary&lt;string, SocketTcpPack&gt;();\n\n        /// &lt;summary&gt;\n        /// 开始监听\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"sender\"&gt;&lt;/param&gt;\n        /// &lt;param name=\"e\"&gt;&lt;/param&gt;\n        private void BtnStartListen_Click(object sender, EventArgs e)\n        {\n            if (!IPAddress.TryParse(TextIP.Text.Trim(), out IPAddress ip))\n            {\n                MessageBox.Show(\"不正确的IP地址\");\n                return;\n            };\n\n            if (!int.TryParse(TextPort.Text.Trim(), out int port))\n            {\n                MessageBox.Show(\"不正确的端口号\");\n                return;\n            }\n\n            //创建Socket\n            Socket socketServer = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);\n            IPEndPoint pEndPoint = new IPEndPoint(ip, port);\n            //绑定IP和端口\n            socketServer.Bind(pEndPoint);\n            //开始监听\n            socketServer.Listen(10);\n            ShowReceiveDataWithDelegate(\"监听成功\");\n            //接收连接\n            socketServer.BeginAccept(Accept, socketServer);\n        }\n\n        /// &lt;summary&gt;\n        /// BeginAccept的回调\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"result\"&gt;&lt;/param&gt;\n        private void Accept(IAsyncResult result)\n        {\n            Socket socket = (Socket)result.AsyncState;\n            Socket clientSocket = socket.EndAccept(result);\n            string clientIP = clientSocket.RemoteEndPoint.ToString();\n            ClientSocketList.Add(clientIP, clientSocket);\n            CmbSocket.BeginInvoke(new EventHandler(delegate\n            {\n                CmbSocket.Items.Add(clientIP);\n            }));\n            ShowReceiveDataWithDelegate(\"连接成功\");\n\n            SocketTcpPack tcpPack = new SocketTcpPack(1024);\n            ReceiveBufferDic.Add(clientIP, tcpPack);\n            //开始接受客户端消息\n            clientSocket.BeginReceive(ReceiveBufferDic[clientIP].Buffer, ReceiveBufferDic[clientIP].Offset, ReceiveBufferDic[clientIP].Size, SocketFlags.None, Receive, clientSocket);\n            //接受下一个连接\n            socket.BeginAccept(Accept, socket);\n        }\n\n        /// &lt;summary&gt;\n        /// BeginReceive的回调\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"result\"&gt;&lt;/param&gt;\n        private void Receive(IAsyncResult result)\n        {\n            Socket socket = (Socket)result.AsyncState;\n            try\n            {\n                string clientIP = socket.RemoteEndPoint.ToString();\n                int dataSize = socket.EndReceive(result);\n                if (dataSize &gt; 0)\n                {\n                    //对接收到的消息进行解包\n                    ReceiveBufferDic[clientIP].UntiePack(dataSize);\n                    if (ReceiveBufferDic[clientIP].IsComplete)\n                    {\n                        foreach (var item in ReceiveBufferDic[clientIP].DataList)\n                        {\n                            string str = Encoding.Default.GetString(item.Content, 0, item.DataLength);\n                            ShowReceiveDataWithDelegate($\"{socket.RemoteEndPoint}发来消息：{str}\");\n                        }\n                        ReceiveBufferDic[clientIP].Clear();\n                    }\n                }\n\n                //接收下一条消息\n                socket.BeginReceive(ReceiveBufferDic[clientIP].Buffer, ReceiveBufferDic[clientIP].Offset, ReceiveBufferDic[clientIP].Size, SocketFlags.None, Receive, socket);\n            }\n            catch (SocketException)\n            {\n                string ip = socket.RemoteEndPoint.ToString();\n                Close(ip);\n            }\n        }\n\n        private void BtnSend_Click(object sender, EventArgs e)\n        {\n            if (CmbSocket.SelectedIndex &lt; 0)\n            {\n                MessageBox.Show(\"请选择客户端IP\");\n                return;\n            }\n            string clientIP = CmbSocket.SelectedItem.ToString();\n            Socket clientSocket = ClientSocketList[clientIP];\n            byte[] data = Encoding.Default.GetBytes(TextSendData.Text.Trim());\n\n            clientSocket.BeginSend(data, 0, data.Length, SocketFlags.None, (result) =&gt;\n            {\n                Socket socket = (Socket)result.AsyncState;\n                socket.EndSend(result);\n            }, clientSocket);\n            TextSendData.Clear();\n        }\n\n        private void ShowReceiveDataWithDelegate(string msgContent)\n        {\n            IAsyncResult result = ListReveiveData.BeginInvoke(new EventHandler(delegate\n                {\n                    ListReveiveData.Items.Add($\"{ListReveiveData.Items.Count} {DateTime.Now.ToString(\"yyyy-MM-dd HH:mm:ss\")} ：{msgContent}\");\n                    ListReveiveData.SelectedIndex = ListReveiveData.Items.Count - 1;\n                }));\n            ListReveiveData.EndInvoke(result);\n        }\n\n        private void Close(string ip)\n        {\n            ShowReceiveDataWithDelegate($\"客户端{ip}断开连接\");\n            ClientSocketList.Remove(ip);\n            ReceiveBufferDic.Remove(ip);\n            CmbSocket.BeginInvoke(new EventHandler(delegate\n            {\n                CmbSocket.Items.Remove(ip);\n            }));\n        }\n    }\n}</code></pre>\n<p>其他</p>\n<pre><code class=\"language-cs\">namespace AsyncSocketServer\n{\n/// &lt;summary&gt;\n/// Socket接收 数据类型\n/// &lt;/summary&gt;\npublic class ReceiveDataModel\n{\n    /// &lt;summary&gt;\n    /// 数据类型 0 文本，1 文件\n    /// &lt;/summary&gt;\n    public byte DataType { get; set; }\n\n    /// &lt;summary&gt;\n    /// 数据长度\n    /// &lt;/summary&gt;\n    public int DataLength { get; set; }\n\n    /// &lt;summary&gt;\n    /// 数据\n    /// &lt;/summary&gt;\n    public byte[] Content { get; set; }\n\n    public bool IsComplete\n    {\n        get\n        {\n            if (DataLength == 0) return false;\n            return DataLength == Content.Length;\n        }\n    }\n}\n}</code></pre>\n<p></p>\n</div>\n</div>"}