{"blogid": "126499565", "writerAge": "码龄2年", "writerBlogNum": "153", "writerCollect": "2306", "writerComment": "921", "writerFan": "9381", "writerGrade": "5级", "writerIntegral": "4268", "writerName": "前端老实人", "writerProfileAdress": "writer_image\\profile_126499565.jpg", "writerRankTotal": "4179", "writerRankWeekly": "2008", "writerThumb": "1695", "writerVisitNum": "326490", "blog_read_count": "1737", "blog_time": "于 2022-08-24 16:34:04 发布", "blog_title": "Vue实现登录功能全套详解（含封装axios）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"Vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%AE%9E%E7%8E%B0%E7%99%BB%E5%BD%95%E5%A4%A7%E8%87%B4%E6%80%9D%E8%B7%AF%EF%BC%9A-toc\" style=\"margin-left:0px;\"><a href=\"#Vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%AE%9E%E7%8E%B0%E7%99%BB%E5%BD%95%E5%A4%A7%E8%87%B4%E6%80%9D%E8%B7%AF%EF%BC%9A\">Vue项目中实现登录大致思路：</a></p>\n<p id=\"%E7%94%A8%E5%88%B0%E7%9A%84%E5%85%B3%E9%94%AE%E6%96%87%E4%BB%B6-toc\" style=\"margin-left:80px;\"><a href=\"#%E7%94%A8%E5%88%B0%E7%9A%84%E5%85%B3%E9%94%AE%E6%96%87%E4%BB%B6\">用到的关键文件</a></p>\n<p id=\"%C2%A0%E4%B8%80%E3%80%81%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6-toc\" style=\"margin-left:0px;\"><a href=\"#%C2%A0%E4%B8%80%E3%80%81%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6\"> 一、安装插件</a></p>\n<p id=\"%E4%BA%8C%E3%80%81%E5%88%9B%E5%BB%BAstore%C2%A0-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BA%8C%E3%80%81%E5%88%9B%E5%BB%BAstore%C2%A0\">二、创建store </a></p>\n<p id=\"%E4%B8%89%E3%80%81%E5%B0%81%E8%A3%85axios-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%89%E3%80%81%E5%B0%81%E8%A3%85axios\">三、封装axios</a></p>\n<p id=\"qs%20vue%20%E6%8F%92%E4%BB%B6-toc\" style=\"margin-left:80px;\"><a href=\"#qs%20vue%20%E6%8F%92%E4%BB%B6\">qs vue 插件</a></p>\n<p id=\"api.js%E7%9A%84%E4%BD%9C%E7%94%A8%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#api.js%E7%9A%84%E4%BD%9C%E7%94%A8%C2%A0\">api.js的作用 </a></p>\n<p id=\"%E5%9B%9B%E3%80%81%E8%B7%AF%E7%94%B1%E6%8B%A6%E6%88%AA-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%9B%9B%E3%80%81%E8%B7%AF%E7%94%B1%E6%8B%A6%E6%88%AA\">四、路由拦截</a></p>\n<p id=\"%E4%BA%94%E3%80%81%E7%99%BB%E5%BD%95%E9%A1%B5%E9%9D%A2%E5%AE%9E%E9%99%85%E4%BD%BF%E7%94%A8-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BA%94%E3%80%81%E7%99%BB%E5%BD%95%E9%A1%B5%E9%9D%A2%E5%AE%9E%E9%99%85%E4%BD%BF%E7%94%A8\">五、登录页面实际使用</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h1>Vue项目中实现登录大致思路：</h1>\n<p>1、第一次登录的时候，前端调后端的登陆接口，发送用户名和密码</p>\n<p>2、后端收到请求，验证用户名和密码，验证成功，就给前端返回一个token</p>\n<p>3、前端拿到token，将token存储到localStorage和vuex中，并跳转路由页面</p>\n<p>4、前端每次跳转路由，就判断 localStroage 中有无 token ，没有就跳转到登录页面，有则跳转到对应路由页面</p>\n<p>5、每次调后端接口，都要在请求头中加token</p>\n<p>6、后端判断请求头中有无token，有token，就拿到token并验证token，验证成功就返回数据，验证失败（例如：token过期）就返回401，请求头中没有token也返回401</p>\n<p>7、如果前端拿到状态码为401，就清除token信息并跳转到登录页面</p>\n<h3 id=\"%E7%94%A8%E5%88%B0%E7%9A%84%E5%85%B3%E9%94%AE%E6%96%87%E4%BB%B6\">用到的关键文件</h3>\n<p><img alt=\"\" height=\"232\" src=\"image\\81aef141836d4f8294e7db3e12260b5b.png\" width=\"321\"/></p>\n<h1 id=\"%C2%A0%E4%B8%80%E3%80%81%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6\"> 一、安装插件</h1>\n<pre><code>npm install axios; // 安装axios\nnpm install vuex  // 安装vuex</code></pre>\n<p>补充： </p>\n<ul><li>创建store是必须的！</li><li>token一定要存在storage缓存中，否则刷新一下，store会重新被加载，token就没了；</li><li>那存在store是不是多余了，这个也是为了数据统一管理吧，也是数据可视化，因为缓存中的数据代码中是看不见的。（为了代码更容易让别人理解所以加上vuex，不加也不影响做登录）</li></ul>\n<h1 id=\"%E4%BA%8C%E3%80%81%E5%88%9B%E5%BB%BAstore%C2%A0\">二、创建store </h1>\n<pre><code class=\"language-javascript\">\nimport Vue from 'vue'\nimport Vuex from 'vuex'\nVue.use(Vuex);\n// 用Vuex.Store对象用来记录token\nconst store = new Vuex.Store({\n\n  state: {\n    // 存储token\n    token:\"\",\n    userName:\"\" // 可选\n  },\n  getters: {\n\tgetToken(state){\n\t\treturn state.token || localStorage.getItem(\"token\") || \"\";\n\t}\n  },\n  mutations: {\n    // 修改token，并将token存入localStorage\n    setToken(state,token) {\n      state.token = token;\n      localStorage.setItem('token', token);\n      console.log('store、localstorage保存token成功！');\n    },\n    delToken(state) {\n      state.token = \"\";\n      localStorage.removeItem(\"token\");\n    },\n    // 可选\n    setUserInfo(state, userName) {\n      state.userName = userName;\n    }\n  },\n\n actions: {\n   // removeToken: (context) =&gt; {\n     // context.commit('setToken')\n   // }\n },\n});\n  \nexport default store;\n</code></pre>\n<p>引用到main.js</p>\n<pre><code class=\"language-javascript\">import store from './store'\nnew Vue({\n  router,\n  store,\n  render: h =&gt; h(App),\n}).$mount('#app')\n</code></pre>\n<p></p>\n<h1 id=\"%E4%B8%89%E3%80%81%E5%B0%81%E8%A3%85axios\">三、封装axios</h1>\n<p>request.js文件用来封装我们的axios</p>\n<h3 id=\"qs%20vue%20%E6%8F%92%E4%BB%B6\">qs vue 插件</h3>\n<p>里面有用到qs，这里我门讲解下他的作用：</p>\n<p>get方法：我们通过定义一个get函数，get函数有两个参数，第一个参数表示我们要请求的url地址，第二个参数是我们要携带的请求参数。get函数返回一个promise对象，当axios其请求成功时resolve服务器返回 值，请求失败时reject错误值。最后通过export抛出get函数。</p>\n<p>post方法：原理同get基本一样，但是要注意的是，post方法必须要使用对提交从参数对象进行序列化的操作，所以这里我们通过node的qs模块来序列化我们的参数。这个很重要，如果没有序列化操作，后台是拿不到你提交的数据的。这就是文章开头我们import QS from ‘qs’;的原因。</p>\n<p>简单来说，qs 是一个增加了一些安全性的查询字符串解析和序列化字符串的库。</p>\n<p>在项目中使用命令行工具输入：npm install qs<br/> 安装完成后在需要用到的组件中：import qs from 'qs’<br/> 具体使用中我查看了：qs.parse()和qs.stringify()</p>\n<p>这两种方法虽然都是序列化，但是还是有区别的。<br/> qs.parse()是将URL解析成对象的形式<br/> qs.stringify()是将对象 序列化成URL的形式，以&amp;进行拼接</p>\n<pre><code class=\"language-javascript\">// 封装axios\nimport axios from 'axios'\n// 序列化\nimport QS from 'qs';\n// vuex\nimport store from '../store/index'\n\n//这一步的目的是判断出当前是开发环境还是生成环境，方法不止一种，达到目的就行\n// if(process.env.NODE_ENV==\"development\"){\n//   baseURL=''\n// }else{\n//   baseURL=''\n// }\n\n// 使用自定义的配置文件发送请求\nconst instance = axios.create({\n    baseURL: '',\n    timeout: 80000,\n    headers: {\n        // 'Content-Type': 'application/json;charset=UTF-8',\n        // 'custome-header':'tianliangjiaoyu'\n    }\n});\n// post请求的时候，我们需要加上一个请求头，所以可以在这里进行一个默认的设置，即设置post的请求头为\naxios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded;charset=UTF-8';\n// 添加请求拦截器\ninstance.interceptors.request.use(function (config) {\n    // 每次发送请求之前判断vuex中是否存在token        \n    // 如果存在，则统一在http请求的header都加上token，这样后台根据token判断你的登录情况\n    // 即使本地存在token，也有可能token是过期的，所以在响应拦截器中要对返回状态进行判断 \n    const token = store.getters.getToken;\n    if (token) {\n        // 已经登录成功，统一添加token\n        config.headers.Authorization = `Bearer ${token}`\n    }\n    // token &amp;&amp; (config.headers.Authorization = token);\n    return config;\n}, function (error) {\n    // 对请求错误做些什么\n    return Promise.reject(error);\n});\n\n// 这里说一下token，一般是在登录完成之后，将用户的token通过localStorage或者cookie存在本地，\n// 然后用户每次在进入页面的时候（即在main.js中），会首先从本地存储中读取token，如果token存在说明用户已经登陆过，\n// 则更新vuex中的token状态。然后，在每次请求接口的时候，都会在请求的header中携带token，\n// 后台人员就可以根据你携带的token来判断你的登录是否过期，如果没有携带，则说明没有登录过。\n// 添加响应拦截器\ninstance.interceptors.response.use(function (response) {\n    if (response.status === 200) {\n        return Promise.resolve(response);\n    } else {\n        return Promise.reject(response);\n    }\n}, function (error) {\n    // 对响应错误做点什么\n    if (error.response.status) {\n        switch (error.response.status) {\n            // 401: 未登录\n            // 未登录则跳转登录页面，并携带当前页面的路径\n            // 在登录成功后返回当前页面，这一步需要在登录页操作。                \n            case 401:\n                router.replace({\n                    path: '/login',\n                    query: {\n                        redirect: router.currentRoute.fullPath\n                    }\n                });\n                break;\n            // 403 token过期\n            // 登录过期对用户进行提示\n            // 清除本地token和清空vuex中token对象\n            // 跳转登录页面                \n            case 403:\n                this.$message({\n                    message: '登录过期，请重新登录',\n                    duration: 1000,\n                    type: 'success'\n                });\n                // 清除token\n                localStorage.removeItem('token');\n                store.commit('loginSuccess', null);\n                // 跳转登录页面，并将要浏览的页面fullPath传过去，登录成功后跳转需要访问的页面 \n                setTimeout(() =&gt; {\n                    router.replace({\n                        path: '/login',\n                        query: {\n                            redirect: router.currentRoute.fullPath\n                        }\n                    });\n                }, 1000);\n                break;\n\n            // 404请求不存在\n            case 404:\n                this.$message({\n                    message: '网络请求不存在',\n                    duration: 1500,\n                    type: 'success'\n\n                });\n                break;\n            // 其他错误，直接抛出错误提示\n            default:\n                this.$message({\n                    message: error.response.data.message,\n                    duration: 1500,\n                    type: 'success'\n\n                });\n        }\n        return Promise.reject(error.response);\n    }\n});\n\n/** \n * get方法，对应get请求 \n * @param {String} url [请求的url地址] \n * @param {Object} params [请求时携带的参数] \n */\nexport function get(url, params) {\n    return new Promise((resolve, reject) =&gt; {\n        instance.get(url, {\n            params: params\n        })\n            .then(res =&gt; {\n                resolve(res.data);\n            })\n            .catch(err =&gt; {\n                reject(err.data)\n            })\n    });\n}\n/** \n * post方法，对应post请求 \n * @param {String} url [请求的url地址] \n * @param {Object} params [请求时携带的参数] \n */\nexport function post(url, params, headers) {\n    return new Promise((resolve, reject) =&gt; {\n        instance.post(url, QS.stringify(params), headers)\n            .then(res =&gt; {\n                resolve(res.data);\n            })\n            .catch(err =&gt; {\n                reject(err.data)\n            })\n    });\n}\n\n</code></pre>\n<p>要注意的是，上面的this.$message方法，是我引入的element库中的轻提示组件，你根据你的ui库，对应使用你的一个提示组件。 </p>\n<p>这里说一下token，一般是在登录完成之后，将用户的token通过localStorage或者cookie存在本地，然后用户每次在进入页面的时候（即在main.js中），会首先从本地存储中读取token，如果token存在说明用户已经登陆过，则更新vuex中的token状态。然后，在每次请求接口的时候，都会在请求的header中携带token，后台人员就可以根据你携带的token来判断你的登录是否过期，如果没有携带，则说明没有登录过。</p>\n<blockquote>\n<p>axios.get()方法和axios.post()在提交数据时参数的书写方式还是有区别的。区别就是，get的第二个参数是一个{}，然后这个对象的params属性值是一个参数对象的。而post的第二个参数就是一个参数对象。两者略微的区别要留意哦！</p>\n</blockquote>\n<h2 id=\"api.js%E7%9A%84%E4%BD%9C%E7%94%A8%C2%A0\">api.js的作用 </h2>\n<p><strong>这里我们补充一个知识点：</strong></p>\n<p>api文件的作用就是接口统一管理</p>\n<p>这里我们定义了一个postLogin方法，这个方法有一个参数p，p是我们请求接口时携带的参数对象。而后调用了我们封装的post方法，post方法的第一个参数是我们的接口地址，第二个参数是postLogin的p参数，即请求接口时携带的参数对象。最后通过export统一导出apiFun对象</p>\n<pre><code class=\"language-javascript\">import {get,post} from './request'\n\nlet apiFun = null;\napiFun.postLogin = p =&gt; post('api/v1/users/my_address/address_edit_before', p)\nexport default apiFun;\n</code></pre>\n<p>然后在我们的mian.js文件中定义成全局变量，方便调用</p>\n<pre><code class=\"language-javascript\">import apiFun from \"./network/api\";\n\nVue.prototype.$apiFun = apiFun;//请求接口api</code></pre>\n<p>然后在我们的页面中可以这样调用我们的api接口：</p>\n<pre><code class=\"language-javascript\">// 调用api接口，并且提供了两个参数                \n           this.$apiFun.postLogin({                    \n                type: 0,                    \n                sort: 1                \n            }).then(res =&gt; {\n                // 获取数据成功后的其他操作\n                ………………                \n            })  </code></pre>\n<p>api接口管理的一个好处就是，我们把api统一集中起来，如果后期需要修改接口，我们就直接在api.js中找到对应的修改就好了，而不用去每一个页面查找我们的接口然后再修改会很麻烦.</p>\n<h1 id=\"%E5%9B%9B%E3%80%81%E8%B7%AF%E7%94%B1%E6%8B%A6%E6%88%AA\">四、路由拦截</h1>\n<pre><code class=\"language-javascript\">import Vue from \"vue\"\nimport Router from \"vue-router\"\nimport Home from '../views/Home.vue'\nimport store from '../store/index'\n\nVue.use(Router)\nlet routes = [\n\n    {\n        path: '/',\n        name: 'Home',\n        component: Home,\n        // 重定向\n        redirect: '/publiccloud',\n        children: [\n            {\n                path: '/publiccloud',\n                name: '公有云用户管理',\n                component: () =&gt; import('../views/publicCloud/PublicCloud.vue')\n            },\n            {\n                path: '/admin',\n                name: '管理员管理',\n                component: () =&gt; import('../views/admin/Admin.vue')\n            }\n        ]\n    },\n    // 登陆页面\n    {\n        path: \"/Login\",\n        name: \"登录页面\",\n        component: () =&gt; import('../views/login/Login.vue')\n    },\n];\n\nlet router = new Router({\n    routes,\n    mode: 'history',\n    // 全局配置激活路由的class类名，处与活跃（动态）就会用上这个类名\n    linkActiveClass: 'active'\n})\n\n\n// 设置路由守卫，在进页面之前，判断有token，才进入页面，否则返回登录页面\nif (storage.get(\"token\")) {\n    store.commit(\"setToken\", localStorage.getItem(\"token\"));\n  }\nrouter.beforeEach((to, from, next) =&gt; {\n    // 设置路由守卫，在进页面之前，判断有token，才进入页面\n        if (token) {\n            next('/')\n        } else {\n            // 没有token就调用后端接口，跳转地址\n            getAddress().then((res) =&gt; {\n              if (res.data.code === 200) {\n                location.href = res.data.data.redirectUri\n              }\n            })\n        }\n});\nexport default router</code></pre>\n<h1 id=\"%E4%BA%94%E3%80%81%E7%99%BB%E5%BD%95%E9%A1%B5%E9%9D%A2%E5%AE%9E%E9%99%85%E4%BD%BF%E7%94%A8\">五、登录页面实际使用</h1>\n<pre><code class=\"language-javascript\">\n\nsubmitForm(formName) {\n      this.$refs[formName].validate(valid =&gt; {\n        if (valid) {\n          let that = this;\n          // console.log('username',this.loginForm.username)\n          // 通过校验规则后进入校验用户名密码是否正确\n          // 没有后台接口可以自定义一个函数来模拟，替换postLogin\n          this.$apiFun.postLogin(this.loginForm.username, this.loginForm.password)\n            .then(res =&gt; {\n              console.log(res);\n              \n               that.$store.commit(\"setToken\", res.data.token);\n               that.$store.commit(\"setUserInfo\", res.data.account);\n\n              this.$notify({\n                title: \"登录成功\",\n                type: \"success\",\n                showClose: false,\n                duration: 1000\n              });\n              setTimeout(() =&gt; {\n                // 此时要判断/login后面的参数redirect，若无参数，进入主页；\n                this.$router.push(\"/index\");\n                // 若有参数则参数为未有权限的那个路由，跳转到那个路由\n                // this.$router.push(***); -- 具体要自己在这实现\n              }, 1000);\n            })\n            .catch(error =&gt; {\n            // 错误分为 status-请求错误 和 code-账号密码错误\n              this.$message.error(error);\n              console.log(error);\n            });\n        } else {\n        // 不符合前端校验\n          this.$message.error('format error：'+error);\n          console.log('format error：',error);\n          return false;\n        }\n      });\n    }\n</code></pre>\n<p>如果喜欢，就给个❤吧</p>\n<p>想认识博主的话这里哦👇</p>\n</div>\n</div>"}