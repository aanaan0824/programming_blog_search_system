{"blogid": "126493903", "writerAge": "码龄1年", "writerBlogNum": "91", "writerCollect": "6699", "writerComment": "12541", "writerFan": "13070", "writerGrade": "7级", "writerIntegral": "19618", "writerName": "微凉秋意", "writerProfileAdress": "writer_image\\profile_126493903.jpg", "writerRankTotal": "415", "writerRankWeekly": "1", "writerThumb": "7505", "writerVisitNum": "122029", "blog_read_count": "1324", "blog_time": "于 2022-08-25 06:15:00 发布", "blog_title": "【Rust指南】结合String深入理解Rust语言的Slice（切片）类型", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-github-gist\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\0445dea7ffb04854838e8841b0f6b812.png\"/><br/> </p>\n<div class=\"toc\">\n<h3>文章目录</h3>\n<ul><li><a href=\"#_2\">前言</a></li><li><a href=\"#Rust_Slice_6\">Rust Slice（切片）类型</a></li><li><ul><li><a href=\"#_10\">一、编写处理字符串的函数</a></li><li><ul><li><a href=\"#1_12\">1、目标函数特点</a></li><li><a href=\"#2String_17\">2、使用String粗略实现</a></li><li><a href=\"#3_49\">3、使用字符串切片完整实现</a></li></ul>\n</li><li><a href=\"#_83\">二、字符串切片及其与字符串的区别</a></li><li><a href=\"#_131\">三、非字符串切片的使用</a></li></ul>\n</li></ul>\n</div>\n<p></p>\n<h1><a id=\"_2\"></a>前言</h1>\n<p>  书接上文，本篇博客将通过结合有关字符串的Rust案例来深入理解并掌握<code>Slice</code>类型。旨在精准的学会切片类型的创建、作为函数的参数以及返回值以及语法糖的扩展等，同时也会分享到其他数据类型的切片，例如数组。</p>\n<hr/>\n<h1><a id=\"Rust_Slice_6\"></a>Rust Slice（切片）类型</h1>\n<p><strong>切片（Slice）是对数据值的部分引用，是一种不持有所有权的数据类型。</strong></p>\n<p>切片这个名字往往出现在生物课上，我们做样本玻片的时候要从生物体上获取切片，以供在显微镜上观察。在 Rust 中，切片的意思大致也是这样，只不过它属于数据的取材引用。</p>\n<h2><a id=\"_10\"></a>一、编写处理字符串的函数</h2>\n<p>这里提供两种实现方法：一是通过以往的知识直接用String类型来解答，另一种是学习过本文的字符串切片类型后再去解答。</p>\n<h3><a id=\"1_12\"></a>1、目标函数特点</h3>\n<ul><li>接收字符串作为参数</li><li>返回它在这个字符串里找到的第一个单词</li><li>如果没有找到空格，将字符串全部返回</li></ul>\n<h3><a id=\"2String_17\"></a>2、使用String粗略实现</h3>\n<p><em>既然是找到第一个单词，不妨找到第一个空格所在的索引，后续从头开始打印到索引位置即可：</em></p>\n<pre><code class=\"prism language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token macro property\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"切片的学习\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> <span class=\"token keyword\">mut</span> s <span class=\"token operator\">=</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello world\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> index<span class=\"token operator\">=</span><span class=\"token function\">first_world</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    s<span class=\"token punctuation\">.</span><span class=\"token function\">clear</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//这里清空s字符串，但是仍然可以得到第一个空格的索引</span>\n    <span class=\"token macro property\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"第一个空格出现的索引为：{}\"</span><span class=\"token punctuation\">,</span>index<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">first_world</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">str</span><span class=\"token punctuation\">:</span><span class=\"token operator\">&amp;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">-&gt;</span><span class=\"token keyword\">usize</span><span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">let</span> bytes<span class=\"token operator\">=</span><span class=\"token keyword\">str</span><span class=\"token punctuation\">.</span><span class=\"token function\">as_bytes</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span><span class=\"token operator\">&amp;</span>item<span class=\"token punctuation\">)</span> <span class=\"token keyword\">in</span> bytes<span class=\"token punctuation\">.</span><span class=\"token function\">iter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">enumerate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token keyword\">if</span> item<span class=\"token operator\">==</span><span class=\"token char\">b' '</span><span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token keyword\">return</span> i<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">str</span><span class=\"token punctuation\">.</span><span class=\"token function\">len</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p><em>运行结果：</em></p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\1116d850a7c64e15afca300b719e1e71.png\"/></p>\n<blockquote>\n<p>这里创建<code>String</code>类型的<code>s</code>并赋值<code>\"hello world\"</code>，第一个空格的索引应为5，接下来用<code>first_world</code>函数来实现。</p>\n</blockquote>\n<blockquote>\n<p>  函数形参的类型是String的引用，返回值是<code>usize</code>，<code>str.as_bytes()</code>含义为将str字符串转换为一个<strong>字节数组</strong><code>bytes</code>，然后我们开始用<code>for</code>循环对字节数组遍历：<br/>   <strong>for(i,&amp;item) in bytes.iter().enumerate()</strong> 中 <code>(i,&amp;iten)</code> 是一个元组，i是元组的索引，即每个i对应着一个<code>item</code>，要注意它是一个<strong>引用</strong>，我们加上<code>&amp;</code>之后解引用就成了一个<code>u8</code>类型的值了；然后<code>bytes.iter()</code>是该字节数组的一个迭代器，会依次返回字节数组里的元素；<code>enumerate()</code>方法会将迭代器遍历的元素包装成一个个的小元组，而刚开始for循环里的元组实际上是一个<strong>模式匹配</strong>，用来<strong>解构</strong>返回的小元组从而得到字节数组中每个索引和每个索引对应的元素值。<br/>   将每个元素值和<code>b' '</code>(b’A’是字节的数据类型<code>' '</code>内用来放置特定的字节，这里我直接填上一个<strong>空格</strong>)比较，如果相等就返回索引，也就是第一个空格的索引，如果遍历到最后都没有空格，那就返回整个字符串的长度。</p>\n</blockquote>\n<blockquote>\n<p>在主函数中调用<code>first_world</code>方法，注意里面传入的是字符串的引用，而且必须加上<code>&amp;</code>，这点是不同于C++的。并用<code>index</code>接收该函数的返回值。虽然程序写完了而且可以得到正确结果，但其实是有<code>bug</code>存在的：此时的字符串s和索引并没有关联，如果我把字符串清空，此时仍然可以输出索引位置，这很明显是不合理的，因此就要使用接下来分享的字符串切片来解决这个bug。</p>\n</blockquote>\n<h3><a id=\"3_49\"></a>3、使用字符串切片完整实现</h3>\n<pre><code class=\"prism language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token macro property\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"切片的学习\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> <span class=\"token keyword\">str</span><span class=\"token operator\">=</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello rust\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> new_str<span class=\"token operator\">=</span><span class=\"token function\">first_world_slice</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span><span class=\"token keyword\">str</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token comment\">//str.clear();不可将变量同时借用为可变和不可变的状态</span>\n    <span class=\"token macro property\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"字符串中第一个单词是：{}\"</span><span class=\"token punctuation\">,</span>new_str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">first_world_slice</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">:</span><span class=\"token operator\">&amp;</span><span class=\"token keyword\">str</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-&gt;</span><span class=\"token operator\">&amp;</span><span class=\"token keyword\">str</span><span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">let</span> bytes<span class=\"token operator\">=</span>s<span class=\"token punctuation\">.</span><span class=\"token function\">as_bytes</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span><span class=\"token operator\">&amp;</span>it<span class=\"token punctuation\">)</span> <span class=\"token keyword\">in</span> bytes<span class=\"token punctuation\">.</span><span class=\"token function\">iter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">enumerate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token keyword\">if</span> it<span class=\"token operator\">==</span><span class=\"token char\">b' '</span><span class=\"token punctuation\">{<!-- --></span>\n            <span class=\"token keyword\">return</span> <span class=\"token operator\">&amp;</span>s<span class=\"token punctuation\">[</span><span class=\"token punctuation\">..</span>i<span class=\"token punctuation\">]</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token operator\">&amp;</span>s<span class=\"token punctuation\">[</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p><em>运行效果：</em></p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\205ca5e433344fc7a94b4e4190e868df.png\"/></p>\n<hr/>\n<blockquote>\n<p>这里主函数调用函数时传参传入的是<code>&amp;str[. .]</code>，即为字符串<code>str</code>转换为完整的字符串切片类型；函数内的返回部分也做了修改，存在空格的话就直接返回其索引前的字符串切片，如果没有空格则返回整个字符串。如果这时候执行<code>str.clear()</code>，编译器就会提示错误，原因就是违反了变量租借的原则，由此可见Rust语言可以使一些<code>API</code>变得简单通用且可以在编译阶段就能阻止错误的发生。</p>\n</blockquote>\n<p> 细心观察的朋友可以看到函数的返回值被我改成了字符串切片类型，这样就可以传入字符串或者字符串切片两种类型的参数了：</p>\n<ul><li>传入的参数如果使字符串切片就直接写入</li><li>如果传入的是字符串类型，那么就创建一个完整的字符串切片即可</li><li>定义函数时使用字符串切片来代替字符串引用会使我们的<code>API</code>更加通用，且不会损失功能</li></ul>\n<h2><a id=\"_83\"></a>二、字符串切片及其与字符串的区别</h2>\n<p><em>最简单、最常用的数据切片类型是字符串切片（String Slice）</em></p>\n<p>例如：</p>\n<pre><code class=\"prism language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">let</span> s <span class=\"token operator\">=</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"broadcast\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">let</span> part1 <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>s<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">..</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> part2 <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>s<span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">..</span><span class=\"token number\">9</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token macro property\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"{}={}+{}\"</span><span class=\"token punctuation\">,</span> s<span class=\"token punctuation\">,</span> part1<span class=\"token punctuation\">,</span> part2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">//运行结果：broadcast=broad+cast</span>\n</code></pre>\n<ul><li>Rust 中的字符串类型实质上记录了字符在内存中的起始位置和其长度 \n  <ul><li><code>part1</code>在内存中的起始位置和字符串s一致</li><li><code>part2</code>在内存中的起始位置指向字符<code>c</code></li><li><code>s</code>的长度为9，part1长度为5，part2长度为4</li></ul> </li><li><code>&amp;s[x..y]</code>就是字符串切片类型的格式，取值上是前开后闭的：<span class=\"katex--inline\"><span class=\"katex\"><span class=\"katex-mathml\">\n     \n      \n       \n        \n         [\n        \n        \n         x\n        \n        \n         ,\n        \n        \n         y\n        \n        \n         )\n        \n       \n       \n        [x,y)\n       \n      \n     </span><span class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 1em; vertical-align: -0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em;\">y</span><span class=\"mclose\">)</span></span></span></span></span>\n<ul><li><code>. .y</code> 等价于 <code>0. .y</code></li><li><code>x. .</code> 等价于位置 x 到数据结束</li><li><code>. .</code> 等价于位置 0 到结束</li></ul> </li><li>注意事项 \n  <ul><li>字符串切片的范围索引必须发生在有效的<code>utf-8</code>字符边界内 \n    <ul><li>这是编码问题，后续文章会详细说明</li></ul> </li><li>如果尝试从一个多字节的字符串切片中创建字符串切片，程序会报错并退出 \n    <ul><li>这是因为切片类型是没有所有权的</li></ul> </li></ul> </li></ul>\n<hr/>\n<p>实际上，到目前为止你一定疑惑为什么每一次使用字符串都要这样写<code>String::from(\"runoob\")</code> ，直接写 <code>\"runoob\"</code> 不行吗？</p>\n<p>事已至此我们必须分辨这两者概念的区别了。在 Rust 中有两种常用的字符串类型：<code>str</code> 和 <code>String</code> :</p>\n<ul><li>str 是 Rust 核心语言类型，就是本章一直在讲的字符串切片<code>（String Slice）</code>，常常以引用的形式出现（<code>&amp;str</code>）。</li></ul>\n<p><strong>凡是用双引号包括的字符串常量整体的类型性质都是 &amp;str ：</strong></p>\n<pre><code class=\"prism language-rust\"><span class=\"token keyword\">let</span> s <span class=\"token operator\">=</span> <span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>这里的 s 就是一个 &amp;str 类型的变量。</p>\n<ul><li> <p>String 和 str 除了同样拥有一个字符开始位置属性和一个字符串长度属性以外还有一个容量（<code>capacity</code>）属性。</p> </li><li> <p>String 和 str 都支持切片，切片的结果是 &amp;str 类型的数据。</p> </li></ul>\n<p><strong>注意：切片结果必须是引用类型，但开发者必须自己明示这一点</strong></p>\n<h2><a id=\"_131\"></a>三、非字符串切片的使用</h2>\n<p><em>除了字符串以外，其他一些线性数据结构也支持切片操作，例如数组：</em></p>\n<pre><code class=\"prism language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">let</span> arr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">7</span><span class=\"token punctuation\">,</span> <span class=\"token number\">9</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> part <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>arr<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">..</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> part<span class=\"token punctuation\">.</span><span class=\"token function\">iter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token macro property\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"{}\"</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">//运行结果为：3 5</span>\n</code></pre>\n<blockquote>\n<p>这里的<code>part</code>是一个数组的切片，起始元素为arr数组的索引1的值，最后一个元素应为arr数组索引2的值<br/> 然后利用迭代器依次返回数组切片的元素值</p>\n</blockquote>\n<hr/>\n<p><code>上面的解释中用到了很多Rust的基本类型知识，如果对于Rust基本类型不熟悉的朋友可以看一下本专栏里的文章。</code></p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}