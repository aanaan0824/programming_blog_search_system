{"blogid": "126705837", "writerAge": "码龄2年", "writerBlogNum": "523", "writerCollect": "1025", "writerComment": "79", "writerFan": "609", "writerGrade": "6级", "writerIntegral": "5666", "writerName": "在森林中麋了鹿", "writerProfileAdress": "writer_image\\profile_126705837.jpg", "writerRankTotal": "3068", "writerRankWeekly": "5332", "writerThumb": "194", "writerVisitNum": "319387", "blog_read_count": "85", "blog_time": "已于 2022-09-05 15:47:06 修改", "blog_title": "Spark 内核 (二) --------- Spark 部署模式", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-light\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p></p>\n<div class=\"toc\">\n<h3>目录</h3>\n<ul><li><a href=\"#YARN__17\">一、YARN 模式运行机制</a></li><li><ul><li><a href=\"#1_YARN_Cluster__18\">1. YARN Cluster 模式</a></li><li><a href=\"#2_YARN_Client__33\">2. YARN Client 模式</a></li></ul>\n</li><li><a href=\"#Standalone__56\">二、Standalone 模式运行机制</a></li><li><ul><li><a href=\"#1_Standalone_Cluster__61\">1. Standalone Cluster 模式</a></li><li><a href=\"#2_Standalone_Client__65\">2. Standalone Client 模式</a></li></ul>\n</li></ul>\n</div>\n<p></p>\n<hr/>\n<p>Spark 支持多种集群管理器（Cluster Manager），分别为：</p>\n<ul><li> <p>Standalone：独立模式，Spark 原生的简单集群管理器，自带完整的服务，可单独部署到一个集群中，无需依赖任何其他资源管理系统，使用 Standalone 可以很方便地搭建一个集群；</p> </li><li> <p>Hadoop YARN：统一的资源管理机制，在上面可以运行多套计算框架，如 MR、Storm等。根据 Driver 在集群中的位置不同，分为 yarn client (集群外) 和 yarn cluster (集群内部)</p> </li><li> <p>Apache Mesos：一个强大的分布式资源管理框架，它允许多种不同的框架部署在其上，包括 Yarn。</p> </li><li> <p>K8S : 容器式部署环境。</p> </li></ul>\n<p>实际上，除了上述这些通用的集群管理器外，Spark 内部也提供了方便用户测试和学习的本地集群部署模式和 Windows 环境。由于在实际工厂环境下使用的绝大多数的集群管理器是 Hadoop YARN，因此我们关注的重点是 Hadoop YARN 模式下的 Spark 集群部署。</p>\n<h1><a id=\"YARN__17\"></a>一、YARN 模式运行机制</h1>\n<h2><a id=\"1_YARN_Cluster__18\"></a>1. YARN Cluster 模式</h2>\n<p>1）执行脚本提交任务，实际是启动一个 SparkSubmit 的 JVM 进程；<br/> 2）SparkSubmit 类中的 main 方法反射调用 YarnClusterApplication 的 main 方法；<br/> 3）YarnClusterApplication 创建 Yarn 客户端，然后向 Yarn 服务器发送执行指令：<code>bin/java ApplicationMaster</code>；<br/> 4）Yarn 框架收到指令后会在指定的 NM 中启动 ApplicationMaster；<br/> 5）ApplicationMaster 启动 Driver 线程，执行用户的作业；<br/> 6） AM 向 RM 注册，申请资源；<br/> 7） 获取资源后 AM 向 NM 发送指令：<code>bin/java YarnCoarseGrainedExecutorBackend</code>；<br/> 8） CoarseGrainedExecutorBackend 进程会接收消息，跟 Driver 通信，注册已经启动的 Executor；然后启动计算对象 Executor 等待接收任务<br/> 9） Driver 线程继续执行完成作业的调度和任务的执行。<br/> 10） Driver 分配任务并监控任务的执行。</p>\n<p>注意：SparkSubmit、ApplicationMaster 和 CoarseGrainedExecutorBackend 是独立的进程；Driver<br/> 是独立的线程；Executor 和 YarnClusterApplication 是对象。<br/> <img alt=\"在这里插入图片描述\" src=\"image\\a5984294d9a14f76a10077474b344bb7.png\"/></p>\n<h2><a id=\"2_YARN_Client__33\"></a>2. YARN Client 模式</h2>\n<p>1）执行脚本提交任务，实际是启动一个 SparkSubmit 的 JVM 进程；<br/> 2）SparkSubmit 类中的 main 方法反射调用用户代码的 main 方法；<br/> 3）启动 Driver 线程，执行用户的作业，并创建 ScheduleBackend；<br/> 4）YarnClientSchedulerBackend 向 RM 发送指令：<code>bin/java ExecutorLauncher</code>；<br/> 5）Yarn 框架收到指令后会在指定的 NM 中启动 ExecutorLauncher（实际上还是调 ApplicationMaster 的 main 方法）；</p>\n<pre><code class=\"prism language-scala\"><span class=\"token keyword\">object</span> ExecutorLauncher <span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token keyword\">def</span> main<span class=\"token punctuation\">(</span>args<span class=\"token operator\">:</span> Array<span class=\"token punctuation\">[</span><span class=\"token builtin\">String</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">Unit</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{<!-- --></span>\n\t\tApplicationMaster<span class=\"token punctuation\">.</span>main<span class=\"token punctuation\">(</span>args<span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>6）AM 向 RM 注册，申请资源；<br/> 7）获取资源后 AM 向 NM 发送指令：<code>bin/java CoarseGrainedExecutorBackend</code>；<br/> 8）CoarseGrainedExecutorBackend 进程会接收消息，跟 Driver 通信，注册已经启动的Executor；然后启动计算对象 Executor 等待接收任务<br/> 9）Driver 分配任务并监控任务的执行；</p>\n<p>注意：SparkSubmit、ApplicationMaster 和 YarnCoarseGrainedExecutorBackend 是独立的进程；Executor 和 Driver 是对象。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\cf016b0bc86f4027b64b5e23f0c41eee.png\"/></p>\n<h1><a id=\"Standalone__56\"></a>二、Standalone 模式运行机制</h1>\n<p>Standalone 集群有 2 个重要组成部分，分别是：</p>\n<ul><li>Master(RM)：是一个进程，主要负责资源的调度和分配，并进行集群的监控等职责；</li><li>Worker(NM)：是一个进程，一个 Worker 运行在集群中的一台服务器上，主要负责两个职责，一个是用自己的内存存储 RDD 的某个或某些 partition；另一个是启动其他进程和线程( Executor )，对 RDD 上的 partition 进行并行的处理和计算。</li></ul>\n<h2><a id=\"1_Standalone_Cluster__61\"></a>1. Standalone Cluster 模式</h2>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\c675292e59a242d48ea1e367342e4fa8.png\"/><br/> 在 Standalone Cluster 模式下，任务提交后，Master 会找到一个 Worker 启动 Driver。Driver 启动后向 Master 注册应用程序，Master 根据 submit 脚本的资源需求找到内部资源至少可以启动一个 Executor 的所有 Worker，然后在这些 Worker 之间分配 Executor，Worker 上的 Executor 启动后会向 Driver 反向注册，所有的 Executor 注册完成后，Driver 开始执行 main函数，之后执行到 Action 算子时，开始划分 Stage，每个 Stage 生成对应的 taskSet，之后将Task 分发到各个 Executor 上执行。</p>\n<h2><a id=\"2_Standalone_Client__65\"></a>2. Standalone Client 模式</h2>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\20bb17f7f5554cdf8c214e7e2de05b78.png\"/><br/> 在 Standalone Client 模式下，Driver 在任务提交的本地机器上运行。Driver 启动后向 Master 注册应用程序，Master 根据 submit 脚本的资源需求找到内部资源至少可以启动一个Executor 的所有 Worker，然后在这些 Worker 之间分配 Executor，Worker 上的 Executor 启动后会向 Driver 反向注册，所有的 Executor 注册完成后，Driver 开始执行 main 函数，之后执行到 Action 算子时，开始划分 Stage，每个 Stage 生成对应的 TaskSet，之后将 Task 分发到各个 Executor 上执行。</p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}