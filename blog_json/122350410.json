{"blogid": "122350410", "writerAge": "码龄6年", "writerBlogNum": "8", "writerCollect": "26", "writerComment": "3", "writerFan": "9", "writerGrade": "2级", "writerIntegral": "254", "writerName": "Ivan the terrible", "writerProfileAdress": "writer_image\\profile_122350410.jpg", "writerRankTotal": "203340", "writerRankWeekly": "55375", "writerThumb": "7", "writerVisitNum": "17505", "blog_read_count": "1061", "blog_time": "于 2022-01-06 19:14:33 发布", "blog_title": "WPF绑定数据，增删改后实时更新TreeView/ListView", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>WPF的界面的确好看，也引入了很多新功能，和winform相比更先进更强大......那么狗儿蛋，代价是什么？<br/> 代价就是WPF学起来比较费力。</p>\n<p>数据绑定是WPF的特色之一，可以省去写代码更新UI界面的工作。这次打算做一个管理数据的小软件，自然的我也打算在界面上弄个TreeView，然后把它和数据源绑定，实现的效果是这样：</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\b09a92211f9449b28b5a6414184e02f0.png\"/></p>\n<p> OK，起初一切都很顺利。我在设计器里布了一个TreeView，代码是下面这样：</p>\n<pre><code class=\"language-XML\">&lt;TreeView x:Name=\"TreePoints\"  AllowDrop=\"True\" &gt;\n    &lt;TreeView.Resources&gt;\n        &lt;HierarchicalDataTemplate DataType=\"{x:Type local:ScanCollection}\" ItemsSource=\"{Binding Points}\"&gt;\n            &lt;materialDesign:ColorZone        Mode=\"PrimaryLight\"        CornerRadius=\"6\" Padding=\"2\"&gt;\n                &lt;TextBlock Text=\"{Binding Path=Name}\" FontSize=\"14\"/&gt;\n            &lt;/materialDesign:ColorZone&gt;\n        &lt;/HierarchicalDataTemplate&gt;\n        &lt;DataTemplate DataType=\"{x:Type local:ScanPoint}\"&gt;\n            &lt;StackPanel Orientation=\"Horizontal\"&gt;\n                &lt;TextBlock Text=\"{Binding Path=Name}\" Margin=\"4 0\"&gt;&lt;/TextBlock&gt;\n                &lt;TextBlock Text=\"{Binding Converter={StaticResource V3ToStringConverter}}\" Margin=\" 4 0\"&gt;&lt;/TextBlock&gt;\n            &lt;/StackPanel&gt;\n        &lt;/DataTemplate&gt;\n    &lt;/TreeView.Resources&gt;\n&lt;/TreeView&gt;</code></pre>\n<p>然后准备一个List装数据，在程序初始化时候把TreeView的ItemSource绑好。</p>\n<pre><code class=\"language-cs\"> public MainWindow()\n        {\n            InitializeComponent();            \n            scans = new List&lt;ScanCollection&gt;();\n            TreePoints.DataContext = scans;\n        }</code></pre>\n<p>然后调试~~~~</p>\n<p>啊咧，当给List添加或者删除成员时，这个界面完全没有反映嘛！</p>\n<p>想了想，这是因为C#里，List其实是一个指针，List里面的内容随便怎么变化指针的值是压根不变的。于是WPF就会认为没必要更新界面。</p>\n<p>于是解决方案之一就是把TreeView的数据源换成一个新的List，然后再换回来，就像这样：</p>\n<pre><code class=\"language-cs\">TreePoints.DataContext = new List&lt;ScanCollections&gt;(){};\nTreePoints.DataContext = scans;</code></pre>\n<p>这不是找事么...违背了数据绑定的初衷。有没有更好的办法？</p>\n<p>搜了一圈，答案是使用ObservableCollection来代替List，那么就动手把数据源改成这样：</p>\n<pre><code>scans = new ObservableCollection&lt;ScanCollection&gt;();\nTreePoints.DataContext = scans;</code></pre>\n<p>运行起来，还是不行。Emm...到底哪里不对</p>\n<p>再翻一翻，发现TreeView的绑定中应当指定 UpdateSourceTrigger，因此需要设计器中这样修改：</p>\n<pre><code>&lt;TreeView x:Name=\"TreePoints\"  AllowDrop=\"True\" ItemsSource=\"{Binding UpdateSourceTrigger=PropertyChanged}\"&gt;</code></pre>\n<p>再次编译调试，OK啦</p>\n</div>\n</div>"}