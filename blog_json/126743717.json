{"blogid": "126743717", "writerAge": "码龄2年", "writerBlogNum": "93", "writerCollect": "14", "writerComment": "0", "writerFan": "10", "writerGrade": "4级", "writerIntegral": "946", "writerName": "_She001", "writerProfileAdress": "writer_image\\profile_126743717.jpg", "writerRankTotal": "23864", "writerRankWeekly": "8210", "writerThumb": "15", "writerVisitNum": "9312", "blog_read_count": "15", "blog_time": "于 2022-09-07 13:26:08 发布", "blog_title": "面试算法 打家劫舍 (1) 算法：递归，迭代动态规划", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>1.题目：打家劫舍<br/> 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。<br/> 给定一个代表每个房屋存放金额的非负整数数组，计算你不触动警报装置的情况下，一夜之内能够偷窃到的最高金额。<br/> 输入:[1,2,3,1]      输出:4<br/> 输入:[2,7,9,3,1]     输出:12</p>\n<hr/>\n<p>2.算法：</p>\n<p>1.递归<br/> 2.迭代的动态规划 <br/> 3.空间复杂度 缩小的迭代动态规划 </p>\n<hr/>\n<p>3.算法思想：（说不清！  bibi  看视频）</p>\n<p>算法思想都是差不多的,都是从最低为开始找 最优的解（或者说是最大能取到的数值）。</p>\n<hr/>\n<p>4.代码：</p>\n<pre><code class=\"hljs\">/*************************************************\n作者：She001\n时间:2022/9/7\n题目：打家劫舍\n你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。\n给定一个代表每个房屋存放金额的非负整数数组，计算你不触动警报装置的情况下，一夜之内能够偷窃到的最高金额。\n输入:[1,2,3,1]      输出:4\n输入:[2,7,9,3,1]     输出:12\n\n算法： \n1.递归\n2.迭代的动态规划 \n3.空间复杂度 缩小的迭代动态规划 \n\n***************************************************/\n\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n//\n//算法：\n//1. 递归\n\nint max(int a,int b)//两个数，返回最大的数 \n{\n\tif(a&gt;b)\n\t{\n\t\treturn a;\n\t}\n\telse\n\t{\n\t\treturn b;\n\t}\n}\n\n\n//因为我们是从  第一间房子 开始 遍历，  所以我们 需要一直从  下标数组最大的地方一直往前面递归，  这样我们就可以从开始的时候 规划最大的金额！ \nint fangfa_1(int num[],int index)//num 金额数组，   index   到达的房子\n{\n\tif(num==NULL  ||   index&lt;0)//从最大的下标开始，所以我们需要在到达下标 小于 0  的时候停止， 这时候没有房子可以偷窃， 所以返回 0 \n\t{\n\t\treturn 0;\n\t}\n\tif(index==0)//当只有一个房子的时候，我们直接进入，他的上一个 递归会决定他是否需要返回数值！ \n\t{\n\t\treturn  num[0]; \n\t}\n\tif(index&gt;0)\n\t{\n\t\treturn max(fangfa_1(num,index-1),fangfa_1(num,index-2)+num[index]);//代表着 在不选这个点，选着下一个点，， 和选了当前的节点的时候  加上 下一个的下一个节点  index -2  这个坐标节点，因为这个是不连续的！\n\t\t// 他的每个节点 都会有一个最优的解，所以他在遍历 每种情况选出最大的数值，，并且每次遍历 都会利用之前的点，来判断当前的坐标点，是否需要选着！！！！ \n\t}\t\n}  \n\n\n//算法：迭代动态规划：\nint  fangfa_2(int num[],const int n)//num 数组， 数组的元素数量 n\n{\n\tif(num==NULL  ||   n==0)//s数组是空的，  元素的数量是 0  返回金额为 0   \n\t{\n\t\treturn 0;\n\t}\n\tif(n==1)//当只有一个房子的时候，我们直接进入，他的上一个 递归会决定他是否需要返回数值！ \n\t{\n\t\treturn  num[0]; \n\t}\n\t\n\t\n\t///建立DP  空间   来存储数据\n\t int DP[n]={0};\n\t \n\t //DP 空间初始化  \n\t DP[0]=num[0];\n\t DP[1]=max(num[0],num[1]);\n\t //方法和上面的差不多，都是从小的时候开始求取  最优解 \n\t for(int i=2;i&lt;n;i++)\n\t {\n\t \t DP[i]=max(DP[i-1],DP[i-2]+num[i]);\t\n\t }\n\t return DP[n-1]; \n} \n\n \n //算法：3.空间复杂度 缩小的迭代动态规划 \nint  fangfa_3(int num[],const int n)//num 数组， 数组的元素数量 n\n{\n\tif(num==NULL  ||   n==0)//s数组是空的，  元素的数量是 0  返回金额为 0   \n\t{\n\t\treturn 0;\n\t}\n\tif(n==1)//当只有一个房子的时候，我们直接进入，他的上一个 递归会决定他是否需要返回数值！ \n\t{\n\t\treturn  num[0]; \n\t}\n\t\n\t\n\t///建立DP  空间   来存储数据\n\t int DP[2];//这里减少空间复杂度 \n\t \n\t //DP 空间初始化  \n\t DP[0]=num[0];\n\t DP[1]=max(num[0],num[1]);\n\t int pp=0;\n\t //方法和上面的差不多，都是从小的时候开始求取  最优解 \n\t for(int i=2;i&lt;n;i++)\n\t {\n\t \t pp=DP[1];\n\t \t DP[1]=max(DP[1],DP[0]+num[i]);\n\t\t DP[0]=pp;\t\n\t }\n\t return DP[1]; \n} \n\n \n\n\nint main()\n{\n\n\tint num[]={1,2,3,1};\n\tint num1[]={2,7,9,3,1};\n\t\n\t//递归 \n\tint a=fangfa_1(num,3);//这个后面的数字是 进入的房子， 房子从0 开始， 所以最大为  n-1  .\n\tint a1=fangfa_1(num1,4);\n\tcout&lt;&lt;\"a = \"&lt;&lt;a&lt;&lt;endl;\n\tcout&lt;&lt;\"a1= \"&lt;&lt;a1&lt;&lt;endl;\n\t\n\t///迭代的动态规划 \n\t int b=fangfa_2(num,4);//后面的数字是元素个数！ \n\tint b1=fangfa_2(num1,5);\n\tcout&lt;&lt;\"b = \"&lt;&lt;b&lt;&lt;endl;\n\tcout&lt;&lt;\"b1= \"&lt;&lt;b1&lt;&lt;endl;\n\t\n\t//.空间复杂度 缩小的迭代动态规划 \n\t int c=fangfa_3(num,4);//后面的数字是元素个数！ \n\tint c1=fangfa_3(num1,5);\n\tcout&lt;&lt;\"c = \"&lt;&lt;c&lt;&lt;endl;\n\tcout&lt;&lt;\"c1= \"&lt;&lt;c1&lt;&lt;endl;\n\t \n\t\n\treturn \t0;\n} </code></pre>\n<hr/>\n<p>5.DP思想：</p>\n<p><strong>这就是DP</strong>（动态规划，dynamic programming）.</p>\n<p><strong>　　将一个问题拆成几个子问题，分别求解这些子问题，即可推断出大问题的解</strong>。</p>\n<p></p>\n<h2>2. 几个简单的概念</h2>\n<p>【<a href=\"https://www.zhihu.com/search?q=%E6%97%A0%E5%90%8E%E6%95%88%E6%80%A7&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A613096905%7D\" title=\"无后效性\">无后效性</a>】</p>\n<p>　　一旦f(n)确定，“我们如何凑出f(n)”就再也用不着了。</p>\n<p>　　要求出f(15)，只需要知道f(14),f(10),f(4)的值，而f(14),f(10),f(4)是如何算出来的，对之后的问题没有影响。</p>\n<p><strong>　　“未来与过去无关”，</strong>这就是<strong>无后效性</strong>。</p>\n<p>　　（严格定义：如果给定某一阶段的状态，则在这一阶段以后过程的发展不受这阶段以前各段状态的影响。）</p>\n<p></p>\n<p>【<a href=\"https://www.zhihu.com/search?q=%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A613096905%7D\" title=\"最优子结构\">最优子结构</a>】</p>\n<p>　　回顾我们对f(n)的定义：我们记“凑出n所需的<strong>最少</strong>钞票数量”为f(n).</p>\n<p>　　f(n)的定义就已经蕴含了“最优”。利用w=14,10,4的<strong>最优</strong>解，我们即可算出w=15的<strong>最优</strong>解。</p>\n<p>　　大问题的<strong>最优解</strong>可以由小问题的<strong>最优解</strong>推出，这个性质叫做“<a href=\"https://www.zhihu.com/search?q=%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84%E6%80%A7%E8%B4%A8&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A613096905%7D\" title=\"最优子结构性质\">最优子结构性质</a>”。</p>\n<p></p>\n<p>　　引入这两个概念之后，我们如何判断一个问题能否使用DP解决呢？</p>\n<p></p>\n<p><strong>　　能将大问题拆成几个小问题，且满足无后效性、最优子结构性质。</strong></p>\n<hr/>\n<p>说说我所理解的dp思想</p>\n<p>dp一般用于解决多阶段决策问题，即每个阶段都要做一个决策，全部的决策是一个决策序列，要你求一个最好的决策序列使得这个问题有最优解。</p>\n<p>将待求解的问题分为若干个相互联系的子问题，只在第一次遇到的时候求解，然后将这个子问题的答案保存下来，下次又遇到的时候直接拿过来用即可。</p>\n<p>dp和分治的不同之处在于分治分解而成的子问题必须没有联系（有联系的话就包含大量重复的子问题，那么这个问题就不适宜分治，虽然分治也能解决，但是时间复杂度太大，不划算），所以用dp的问题和用分治的问题的根本区别在于分解成的子问题之间有没有联系，这些子问题有没有重叠，即有没有重复子问题。</p>\n<p>dp和贪心的不同之处在于每一次的贪心都是做出不可撤回的决策（即每次局部最优），而在dp中还有考察每个最优决策子序列中是否包含最优决策子序列，即是否具有最优子结构性质，贪心中每一步都只顾眼前最优，并且当前的选择是不会依赖以前的选择的，而dp，在选择的时候是从以前求出的若干个与本步骤相关的子问题中选最优的那个，加上这一步的值来构成这一步那个子问题的最优解。<br/>  </p>\n<p></p>\n</div>\n</div>"}