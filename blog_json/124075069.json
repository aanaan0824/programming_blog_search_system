{"blogid": "124075069", "writerAge": "码龄1年", "writerBlogNum": "17", "writerCollect": "248", "writerComment": "526", "writerFan": "1481", "writerGrade": "4级", "writerIntegral": "1148", "writerName": "施律.", "writerProfileAdress": "writer_image\\profile_124075069.jpg", "writerRankTotal": "52817", "writerRankWeekly": "215221", "writerThumb": "453", "writerVisitNum": "22050", "blog_read_count": "2381", "blog_time": "已于 2022-04-10 16:02:44 修改", "blog_title": "关于时间的函数，让你成为掌控时间的强者", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p><span style=\"color:#a2e043;\"><strong>我大概</strong></span><span style=\"color:#a2e043;\"><strong>是乏</strong></span><span style=\"color:#a2e043;\"><strong>了，横竖都开心不起来，站起身来皱了眉头，这悲伤是没来由的。</strong></span><span style=\"color:#956fe7;\"><strong>作为一个曾经长期掌控不了系统时间的初级程序猿，在经过几天的探索以后，心血来潮总结下来分享给小伙伴们。小伙伴们或许会很期待吧，一篇博客如何让自己</strong></span><span style=\"color:#fe2c24;\"><strong>成为掌控时间的强者</strong></span><span style=\"color:#956fe7;\"><strong>呢？多说无益，开始正文！</strong></span></p>\n<p id=\"main-toc\"></p>\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E4%BB%8A%E5%A4%A9%E6%98%AF%E5%87%A0%E5%8F%B7%EF%BC%9F-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BB%8A%E5%A4%A9%E6%98%AF%E5%87%A0%E5%8F%B7%EF%BC%9F\">今天是几号？</a></p>\n<p id=\"time_t%20%E5%9E%8B%EF%BC%9A%E6%97%A5%E5%8E%86%E6%97%B6%E9%97%B4-toc\" style=\"margin-left:40px;\"><a href=\"#time_t%20%E5%9E%8B%EF%BC%9A%E6%97%A5%E5%8E%86%E6%97%B6%E9%97%B4\">time_t 型：日历时间</a></p>\n<p id=\"time%20%E5%87%BD%E6%95%B0%EF%BC%9A%E4%BB%A5%E6%97%A5%E5%8E%86%E6%97%B6%E9%97%B4%E7%9A%84%E5%BD%A2%E5%BC%8F%E6%9D%A5%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E6%97%B6%E9%97%B4-toc\" style=\"margin-left:40px;\"><a href=\"#time%20%E5%87%BD%E6%95%B0%EF%BC%9A%E4%BB%A5%E6%97%A5%E5%8E%86%E6%97%B6%E9%97%B4%E7%9A%84%E5%BD%A2%E5%BC%8F%E6%9D%A5%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E6%97%B6%E9%97%B4\">time 函数：以日历时间的形式来获取当前时间</a></p>\n<p id=\"tm%20%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%9A%E5%88%86%E8%A7%A3%E6%97%B6%E9%97%B4%EF%BC%88%E6%92%95%E8%A3%82%E6%97%B6%E9%97%B4%EF%BC%89-toc\" style=\"margin-left:40px;\"><a href=\"#tm%20%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%9A%E5%88%86%E8%A7%A3%E6%97%B6%E9%97%B4%EF%BC%88%E6%92%95%E8%A3%82%E6%97%B6%E9%97%B4%EF%BC%89\">tm 结构体：分解时间（撕裂时间）</a></p>\n<p id=\"localtime%20%E5%87%BD%E6%95%B0%EF%BC%9A%E6%8A%8A%E6%97%A5%E5%8E%86%E6%97%B6%E9%97%B4%E8%BD%AC%E6%8D%A2%E6%88%90%E8%A1%A8%E7%A4%BA%E6%9C%AC%E5%9C%B0%E6%97%B6%E9%97%B4%E7%9A%84%E5%88%86%E8%A7%A3%E6%97%B6%E9%97%B4-toc\" style=\"margin-left:40px;\"><a href=\"#localtime%20%E5%87%BD%E6%95%B0%EF%BC%9A%E6%8A%8A%E6%97%A5%E5%8E%86%E6%97%B6%E9%97%B4%E8%BD%AC%E6%8D%A2%E6%88%90%E8%A1%A8%E7%A4%BA%E6%9C%AC%E5%9C%B0%E6%97%B6%E9%97%B4%E7%9A%84%E5%88%86%E8%A7%A3%E6%97%B6%E9%97%B4\">localtime 函数：把日历时间转换成表示本地时间的分解时间</a></p>\n<p id=\"gmtime%20%E5%87%BD%E6%95%B0%EF%BC%9A%E6%8A%8A%E6%97%A5%E5%8E%86%E6%97%B6%E9%97%B4%E8%BD%AC%E6%8D%A2%E6%88%90UTC%E5%88%86%E8%A7%A3%E6%97%B6%E9%97%B4-toc\" style=\"margin-left:40px;\"><a href=\"#gmtime%20%E5%87%BD%E6%95%B0%EF%BC%9A%E6%8A%8A%E6%97%A5%E5%8E%86%E6%97%B6%E9%97%B4%E8%BD%AC%E6%8D%A2%E6%88%90UTC%E5%88%86%E8%A7%A3%E6%97%B6%E9%97%B4\">gmtime 函数：把日历时间转换成UTC分解时间</a></p>\n<p id=\"asctime%20%E5%87%BD%E6%95%B0%EF%BC%9A%E6%8A%8A%E5%88%86%E8%A7%A3%E6%97%B6%E9%97%B4%E8%BD%AC%E6%8D%A2%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2-toc\" style=\"margin-left:40px;\"><a href=\"#asctime%20%E5%87%BD%E6%95%B0%EF%BC%9A%E6%8A%8A%E5%88%86%E8%A7%A3%E6%97%B6%E9%97%B4%E8%BD%AC%E6%8D%A2%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2\">asctime 函数：把分解时间转换成字符串</a></p>\n<p id=\"ctime%20%E5%87%BD%E6%95%B0%EF%BC%9A%E6%8A%8A%E6%97%A5%E5%8E%86%E6%97%B6%E9%97%B4%E8%BD%AC%E6%8D%A2%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2-toc\" style=\"margin-left:40px;\"><a href=\"#ctime%20%E5%87%BD%E6%95%B0%EF%BC%9A%E6%8A%8A%E6%97%A5%E5%8E%86%E6%97%B6%E9%97%B4%E8%BD%AC%E6%8D%A2%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2\">ctime 函数：把日历时间转换成字符串</a></p>\n<p id=\"difftime%20%E5%87%BD%E6%95%B0%EF%BC%9A%E6%B1%82%E6%97%B6%E9%97%B4%E5%B7%AE-toc\" style=\"margin-left:40px;\"><a href=\"#difftime%20%E5%87%BD%E6%95%B0%EF%BC%9A%E6%B1%82%E6%97%B6%E9%97%B4%E5%B7%AE\">difftime 函数：求时间差</a></p>\n<p id=\"%E6%B1%82%E6%98%9F%E6%9C%9F-toc\" style=\"margin-left:0px;\"><a href=\"#%E6%B1%82%E6%98%9F%E6%9C%9F\">求星期</a></p>\n<p id=\"mktime%20%E5%87%BD%E6%95%B0%EF%BC%9A%E4%B8%A4%E6%9E%81%E5%8F%8D%E8%BD%AC-toc\" style=\"margin-left:40px;\"><a href=\"#mktime%20%E5%87%BD%E6%95%B0%EF%BC%9A%E4%B8%A4%E6%9E%81%E5%8F%8D%E8%BD%AC\">mktime 函数：两极反转</a></p>\n<p id=\"%E5%AE%8C%E7%BB%93-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%AE%8C%E7%BB%93\">完结</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<p></p>\n<p></p>\n<h1 id=\"%E4%BB%8A%E5%A4%A9%E6%98%AF%E5%87%A0%E5%8F%B7%EF%BC%9F\">今天是几号？</h1>\n<p>先来上本篇博客的第一段代码，小伙伴们来学习一下如何获取当前日期及时间：</p>\n<pre><code class=\"language-cpp\">//time01\n\n#include &lt;stdio.h&gt;\n#include &lt;time.h&gt;\n\nvoid put_date(const struct tm* timer)\n{\n\tchar* wday_name[] = { \"日\",\"一\",\"二\",\"三\",\"四\",\"五\",\"六\" };\n\n\tprintf(\"%4d年%02d月%02d日(%s)%02d时%02d分%02d秒\", timer-&gt;tm_year + 1900,      //年\n\t\ttimer-&gt;tm_mon + 1,                  //月\n\t\ttimer-&gt;tm_mday,                     //日\n\t\twday_name[timer-&gt;tm_wday],          //星期\n\t\ttimer-&gt;tm_hour,                     //时\n\t\ttimer-&gt;tm_min,                      //分\n\t\ttimer-&gt;tm_sec);                     //秒\n}\n\nint main()\n{\n\ttime_t current;                     //日历时间\n\tstruct tm* timer;                   //分解时间（结构体）\n\n\ttime(&amp;current);                     //获取当前时间\n\ttimer = localtime(&amp;current);        //转换成分解时间（本地时间）\n\n\tprintf(\"当前日期和时间是\");\n\tput_date(timer);\n\tprintf(\"。\\n\");\n\n\treturn 0;\n}</code></pre>\n<h2 id=\"time_t%20%E5%9E%8B%EF%BC%9A%E6%97%A5%E5%8E%86%E6%97%B6%E9%97%B4\">time_t 型：日历时间</h2>\n<p><strong>time_t 型，又称为日历时间</strong>，其实它很像int型和double型一样，能够进行加减乘除运算的算数型。具体等同于哪个类型取决于编程环境（不光决定日历时间的类型，还决定了其具体的值）。使用它需要加上&lt;time.h&gt;头文件定义。在大多数编译环境中把time_t 型等同于int型或long型，以<span style=\"color:#956fe7;\"><strong>格林尼治标准时间，也就是1970年1月1日0时0分0秒后经过的秒数作为日历时间的具体值。</strong></span></p>\n<p></p>\n<h2 id=\"time%20%E5%87%BD%E6%95%B0%EF%BC%9A%E4%BB%A5%E6%97%A5%E5%8E%86%E6%97%B6%E9%97%B4%E7%9A%84%E5%BD%A2%E5%BC%8F%E6%9D%A5%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E6%97%B6%E9%97%B4\">time 函数：以日历时间的形式来获取当前时间</h2>\n<p>且看下表：</p>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px;\"><tbody><tr><td></td><td>time</td></tr><tr><td>头文件</td><td>#include &lt;time.h&gt;</td></tr><tr><td>格式</td><td>time_t time(time_t *timer);</td></tr><tr><td>功能</td><td>决定当前的日历时间。未定义该值的表现形式</td></tr><tr><td>返回值</td><td>用所在编译环境中的最佳逼近返回求出的日历时间。若日历时间无效则返回值（time_t）1，当timer不为空指针时，将返回值赋给timer指向的对象。</td></tr></tbody></table>\n<p>此函数在求出日历时间的基础上，<span style=\"color:#956fe7;\"><strong>把日历时间存入参数timer指向的对象中，同时返回日历时间。</strong></span>因此我们可以根据不同的用途和个人喜好来选择各种调用方式。</p>\n<p>我们通过运用<span style=\"color:#956fe7;\"><strong>time(&amp;current);</strong></span> ，把指向变量current的指针作为参数传递给了<strong>time</strong>函数。</p>\n<h2 id=\"tm%20%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%9A%E5%88%86%E8%A7%A3%E6%97%B6%E9%97%B4%EF%BC%88%E6%92%95%E8%A3%82%E6%97%B6%E9%97%B4%EF%BC%89\">tm 结构体：分解时间（撕裂时间）</h2>\n<p>尝试一下用<strong><span style=\"color:#4da8ee;\">time_t型</span></strong>来表示时间的我们知道,它所表示的是我们极其不易理解的：</p>\n<p><img alt=\"\" height=\"59\" src=\"image\\2a5d17e40c624ef28d81577209e6b840.png\" width=\"217\"/></p>\n<p></p>\n<p>因此，我们可以使用另外一个表示方法，<strong>就是被成为撕裂时间的<span style=\"color:#956fe7;\">tm结构体</span>类型。</strong></p>\n<p>我们把<span style=\"color:#956fe7;\"><strong>tm 结构体</strong></span>拿出来看看：</p>\n<pre><code class=\"language-cpp\">struct tm{\n    int tm_sec;            //秒（0-61）\n    int tm_min;            //分（0-59）\n    int tm_hour;           //时（0-23）\n    int tm_mday;           //日（0-31）\n    int tm_mon;            //从一月开始的月份（0-11）\n    int tm_year;           //从1900开始的年份\n    int tm_wday;           //星期：星期日-星期六（0-6）\n    int tm_yday;           //从1月1日开始的天数（0-365）\n}；</code></pre>\n<p>小伙伴们可以通过代码中的注释来理解各个成员表示的值。而当我们在浏览到秒的成员tm_min的值设在<span style=\"color:#a2e043;\">0-61</span>，是因为考虑到了<span style=\"color:#956fe7;\"><strong>”闰秒“</strong></span>。</p>\n<h2 id=\"localtime%20%E5%87%BD%E6%95%B0%EF%BC%9A%E6%8A%8A%E6%97%A5%E5%8E%86%E6%97%B6%E9%97%B4%E8%BD%AC%E6%8D%A2%E6%88%90%E8%A1%A8%E7%A4%BA%E6%9C%AC%E5%9C%B0%E6%97%B6%E9%97%B4%E7%9A%84%E5%88%86%E8%A7%A3%E6%97%B6%E9%97%B4\">localtime 函数：把日历时间转换成表示本地时间的分解时间</h2>\n<p><span style=\"color:#fe2c24;\"><strong>localtime 函数（通过tm结构体）用于把日历时间的值转换成分解时间。</strong></span></p>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px;\"><tbody><tr><td></td><td><strong>localtime</strong></td></tr><tr><td>头文件</td><td><strong>#include &lt;time.h&gt;</strong></td></tr><tr><td>格式</td><td><strong>struct tm*localtime(const time_t *timer);</strong></td></tr><tr><td>功能</td><td>把timer指向的日历时间转换成用本地时间表示的分解时间</td></tr><tr><td>返回值</td><td>返回指向转换后的对象的指针</td></tr></tbody></table>\n<p>正如locattime的字面以四所示，转换后得到的是本地时间。我们来看看它的表示图：</p>\n<p><img alt=\"\" height=\"615\" src=\"image\\d5e3de5916304ee2a212a1996b50fc08.png\" width=\"1068\"/></p>\n<p></p>\n<p> 最后我们再来分析一下 time01 程序。</p>\n<p><strong>（1）在main函数中，我们运用了time 函数以time_t 型的日历时间的形式获取当前时间，将其转换成分解时间，即tm 结构体。</strong></p>\n<p><strong>（2）如何再使用 put_date 接受转换后的结构，并用公历纪元显示分解时间；</strong></p>\n<p><strong>（3）最后，在tm_year 桑加上1900，在tm_mon上加上1，由于表示星期的tm_wday从星期日到星期六分别对应0到6，因此可以利用数组wday_name 将其转换后中文字符串”日“，”一“，…”六“并显示出来。</strong></p>\n<h2 id=\"gmtime%20%E5%87%BD%E6%95%B0%EF%BC%9A%E6%8A%8A%E6%97%A5%E5%8E%86%E6%97%B6%E9%97%B4%E8%BD%AC%E6%8D%A2%E6%88%90UTC%E5%88%86%E8%A7%A3%E6%97%B6%E9%97%B4\">gmtime 函数：把日历时间转换成UTC分解时间</h2>\n<p>只讲本地时间的话可谓太吝啬了，接下来我将给小伙伴们带来协调时间时（即UTC）。</p>\n<p>gmtime 函数是用来执行UTC的函数，且看下表;</p>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px;\"><tbody><tr><td></td><td><strong>gmtime</strong></td></tr><tr><td>头文件</td><td><strong>#include &lt;time.h&gt;</strong></td></tr><tr><td>格式</td><td><strong>struct tm *gmtime(const time_t *timer);</strong></td></tr><tr><td>功能</td><td>把timer指向的日历时间转换成用协调时间时表示的分解时间</td></tr><tr><td>返回值</td><td>返回指向转换后的对象的指针</td></tr></tbody></table>\n<p>我们来看看如何运用gmtime函数，代码其实跟 time01 如出一辙：</p>\n<pre><code class=\"language-cpp\">//time02\n\n#include &lt;stdio.h&gt;\n#include &lt;time.h&gt;\n\nvoid put_date(const struct tm* timer)\n{\n\tchar* wday_name[] = { \"日\",\"一\",\"二\",\"三\",\"四\",\"五\",\"六\" };\n\n\tprintf(\"%4d年%02d月%02d日(%s)%02d时%02d分%02d秒\", timer-&gt;tm_year + 1900,\n\t\ttimer-&gt;tm_mon + 1,\n\t\ttimer-&gt;tm_mday,\n\t\twday_name[timer-&gt;tm_wday],\n\t\ttimer-&gt;tm_hour,\n\t\ttimer-&gt;tm_min,\n\t\ttimer-&gt;tm_sec);\n}\n\nint main()\n{\n\ttime_t current;\n\tstruct tm* timer;\n\n\ttime(&amp;current);\n\ttimer = gmtime(&amp;current);\n\n\tprintf(\"当前日期和时间用UTC表示是\");\n\tput_date(timer);\n\tprintf(\"。\\n\");\n\n\treturn 0;\n}</code></pre>\n<p><span style=\"color:#a2e043;\"><strong>其实就是把timer = localtime(&amp;current); 改为timer = gmtime(&amp;current); 。</strong></span></p>\n<h2 id=\"asctime%20%E5%87%BD%E6%95%B0%EF%BC%9A%E6%8A%8A%E5%88%86%E8%A7%A3%E6%97%B6%E9%97%B4%E8%BD%AC%E6%8D%A2%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2\">asctime 函数：把分解时间转换成字符串</h2>\n<p>再给小伙伴们分享一个函数，它可以把分解时间转换成字符串，能简单地表示出当前日期和时间，何乐而不为呢？且看下面代码：</p>\n<pre><code class=\"language-cpp\">//time03\n\n#include &lt;stdio.h&gt;\n#include &lt;time.h&gt;\n\nint main()\n{\n\ttime_t current = time(NULL);\n\n\tprintf(\"当前日期和时间：%s\", asctime(localtime(&amp;current)));\n\n\treturn 0;\n}</code></pre>\n<p><strong><span style=\"color:#956fe7;\">asctime 函数是把分解时间转换成字符串形式的函数。</span></strong><span style=\"color:#4da8ee;\">它生成和返回的字符串从左到右按星期/月/日/时/分/秒/年的顺序排列，用空白字符与冒号”：“隔开</span>。</p>\n<p><img alt=\"\" height=\"677\" src=\"image\\266dc0b9605d49339be3ff1770d185c2.png\" width=\"1200\"/></p>\n<p> 我们可以看到，星期和月中分别存有其英语单词开头的3个字母（开头的字母是大写字母，而第2个和第3个是小写字母）。我们再来看看它的表：</p>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px;\"><tbody><tr><td></td><td><strong>asctime</strong></td></tr><tr><td>头文件</td><td><strong>#include &lt;time.h&gt;</strong></td></tr><tr><td>格式</td><td><strong>char *asctime(const struct tm *timeptr);</strong></td></tr><tr><td>功能</td><td> <p>把timeptr指向的结构体的分解时间转换成下面这种形式的字符串</p> <p>Sun Apr 10 13:13:09:00 2022</p> </td></tr><tr><td>返回值</td><td>返回指向转换后的对象的指针</td></tr></tbody></table>\n<h2 id=\"ctime%20%E5%87%BD%E6%95%B0%EF%BC%9A%E6%8A%8A%E6%97%A5%E5%8E%86%E6%97%B6%E9%97%B4%E8%BD%AC%E6%8D%A2%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2\">ctime 函数：把日历时间转换成字符串</h2>\n<p><span style=\"color:#4da8ee;\"><strong>使用asctime函数时，我们为了把time_t型的日历时间转换成tm 结构体的分解时间，需要实现调用localtime 函数。这样一来，把日历时间转换成字符串就需要两个步骤了，未免太过于繁琐。ctime 函数就不一样了，只需一步便可！</strong></span></p>\n<pre><code class=\"language-cpp\">//time04\n\n#include &lt;stdio.h&gt;\n#include &lt;time.h&gt;\n\nint main()\n{\n\ttime_t current = time(NULL);\n\n\tprintf(\"当前日期和时间：%s\", ctime(&amp;current));\n\n\treturn 0;\n}</code></pre>\n<p>ctime 表如下：</p>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px;\"><tbody><tr><td></td><td><strong>ctime</strong></td></tr><tr><td>头文件</td><td><strong>#include &lt;time.h&gt;</strong></td></tr><tr><td>格式</td><td><strong>char *ctime(const time_t *timer);</strong></td></tr><tr><td>功能</td><td>把timer指向的日历时间转换成与asctime函数具有相同字符串形式的本地时间，相当于asctime（localtime（timer））</td></tr><tr><td>返回值</td><td>返回以分解时间为实际参数的asctime函数返回的指针</td></tr></tbody></table>\n<p></p>\n<h2 id=\"difftime%20%E5%87%BD%E6%95%B0%EF%BC%9A%E6%B1%82%E6%97%B6%E9%97%B4%E5%B7%AE\">difftime 函数：求时间差</h2>\n<p>接下来我讲给你们带来如何利用time函数获取的日历时间来计算处理时间。先上代码：</p>\n<pre><code class=\"language-cpp\">//time05\n\n#include &lt;time.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main()\n{\n\tint a, b, c, d;\n\tint x;\n\ttime_t start, end;\n\n\tsrand(time(NULL));\n\n\ta = rand() % 100;\n\tb = rand() % 100;\n\tc = rand() % 100;\n\td = rand() % 100;\n\n\tprintf(\"%d+%d+%d+%d等于多少：\", a, b, c, d);\n\n\tstart = time(NULL);\n\n\twhile (1)\n\t{\n\t\tscanf(\"%d\", &amp;x);\n\t\tif (x == a + b + c + d)\n\t\t\tbreak;\n\t\tprintf(\"回答错误！！\\n请重新输入：\");\n\t}\n\n\tend = time(NULL);\n\n\tprintf(\"用时%.0f秒。\\n\", difftime(end, start));\n\n\treturn 0;\n}</code></pre>\n<p><span style=\"color:#4da8ee;\">p<strong>rintf(\"用时%.0f秒。\\n\", difftime(end, start)); 通过调用difftime 函数用来求两个日历时间的差。它的用法极其简单，把两个time_t 型的值作为参数（end-start）给出就行，并以秒为单位的double型数值的形式返回时间差。</strong></span></p>\n<p>我们再来看看difftime的表：</p>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px;\"><tbody><tr><td></td><td><strong>difftime</strong></td></tr><tr><td>头文件</td><td><strong>#include &lt;time.h&gt;</strong></td></tr><tr><td>格式</td><td><strong>double difftime(time_t time1,time_t time0);</strong></td></tr><tr><td>功能</td><td>计算两个日历时间的差time1 - time0</td></tr><tr><td>返回值</td><td>以秒为单位表示求得的时间差，将其作为double 型返回</td></tr></tbody></table>\n<p></p>\n<h1 id=\"%E6%B1%82%E6%98%9F%E6%9C%9F\">求星期</h1>\n<h2 id=\"mktime%20%E5%87%BD%E6%95%B0%EF%BC%9A%E4%B8%A4%E6%9E%81%E5%8F%8D%E8%BD%AC\">mktime 函数：两极反转</h2>\n<p>前面讲述了如果将日历时间转换成分解时间，现在我再来讲讲如何将本地时间的分解时间转换成日历时间，那就是使用mktime 函数，它的功能与localtime 函数进行的转换正好相反。</p>\n<p>而且，这函数还带来了<span style=\"color:#956fe7;\"><strong>意外之喜</strong></span>。<span style=\"color:#a2e043;\"><strong>它可以计算并设定结构体的星期和一年中经过的天数的值</strong></span>。利用该功能的话，咱只需设定分解时间的年/月/日并调用<strong>mktime 函数</strong>，就能求出对应的星期。</p>\n<p>我们来看看它的流程图：</p>\n<p></p>\n<p></p>\n<p></p>\n<p><img alt=\"\" height=\"691\" src=\"image\\00a9cedf093e4094bf7febb79b4d9213.png\" width=\"1200\"/></p>\n<p>这可真是<span style=\"color:#fe2c24;\"><strong>两极反转</strong></span>啊！</p>\n<p>最后，用一段华丽的代码了却此博客：</p>\n<pre><code class=\"language-cpp\">//time06\n\n#include &lt;time.h&gt;\n#include &lt;stdio.h&gt;\n\nint dayofweek(int year, int month, int day)\n{\n\tstruct tm t;\n\tt.tm_year = year - 1900;\n\tt.tm_mon = month - 1;\n\tt.tm_mday = day;\n\tt.tm_hour = 0;\n\tt.tm_min = 0;\n\tt.tm_sec = 0;\n\tt.tm_isdst = -1;\n\n\tif (mktime(&amp;t) == (time_t)-1)\n\t\treturn -1;\n\treturn t.tm_wday;\n}\n\nint main()\n{\n\tint y, m, d, w;\n\tchar* ws[] = { \"日\",\"一\",\"二\",\"三\",\"四\",\"五\",\"六\" };\n\n\tprintf(\"求星期。\\n\");\n\tprintf(\"年：\");\t\tscanf(\"%d\", &amp;y);\n\tprintf(\"月：\");\t\tscanf(\"%d\", &amp;m);\n\tprintf(\"日：\");\t\tscanf(\"%d\", &amp;d);\n\n\tw = dayofweek(y, m, d);\n\n\tif (w != -1)\n\t\tprintf(\"这一天是星期%s。\\n\", ws[w]);\n\telse\n\t\tprintf(\"无法求出星期。\\n\");\n\n\treturn 0;\n}</code></pre>\n<p><img alt=\"\" height=\"677\" src=\"image\\209738d318c141dfbdda2d955bbf0388.png\" width=\"1200\"/></p>\n<p></p>\n<p></p>\n<p></p>\n<p>time06 中定义的<span style=\"color:#4da8ee;\"><strong>dayofweek 函数</strong></span>会根据接受的<strong>年/月/日</strong>这3个值来生成分解时间，然后再调用mktime 函数，之后函数会通过<strong>”附赠“</strong>的功能直接返回成员函数<strong>tm_wday </strong>中设定的值，值为0是星期日……</p>\n<p>此外，<span style=\"color:#a2e043;\"><strong>mktime函数返回错误时，说明程序有可能求出了错误的星期数值，因此函数dayofweek 会返回 -1</strong></span>。</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\1d56714b92024beb8ea113afd114e569.png\"/></p>\n<p></p>\n<h1 id=\"%E5%AE%8C%E7%BB%93\">完结</h1>\n<p><span style=\"color:#956fe7;\"><strong>很</strong></span><span style=\"color:#fe2c24;\"><strong>感激阅读到这里的你</strong></span><span style=\"color:#956fe7;\"><strong>，相信阅读完的你已经成为了</strong></span><span style=\"color:#fe2c24;\"><strong>掌控时间的强者</strong></span><span style=\"color:#956fe7;\"><strong>了吧！</strong><strong>精彩并不止于这些，学有余力的小伙伴可以看看下面这些博客，都是</strong><strong>有着</strong></span><span style=\"color:#fe2c24;\"><strong>极多的技巧与干货❤！</strong></span></p>\n<p><a href=\"https://blog.csdn.net/qq_64263760/article/details/122880908\" title=\"C语言小游戏（一）----猜数游戏_施律.的博客-CSDN博客_c语言猜数游戏次数限制\">C语言小游戏（一）----猜数游戏_施律.的博客-CSDN博客_c语言猜数游戏次数限制</a></p>\n<p><strong><a href=\"https://blog.csdn.net/qq_64263760/article/details/124053651\" title=\"《斗破CPP》 第壹章 ---- 初窥CPP_施律.的博客-CSDN博客\">《斗破CPP》 第壹章 ---- 初窥CPP_施律.的博客-CSDN博客</a></strong></p>\n<p><a href=\"https://blog.csdn.net/qq_64263760/article/details/124065720\" title=\"《斗破CPP》 第贰章（上） ---- 初识分支句_施律.的博客-CSDN博客\">《斗破CPP》 第贰章（上） ---- 初识分支句_施律.的博客-CSDN博客</a></p>\n<p><span style=\"color:#956fe7;\"><strong>如果觉得本篇博客对正在学习编程的你有帮助的话，</strong><strong>请给施律.</strong></span><span style=\"color:#fe2c24;\"><strong>多一点的支持与关注</strong></span><span style=\"color:#956fe7;\"><strong>！未来的一段时间里</strong></span><span style=\"color:#fe2c24;\"><strong>施律.将和小伙伴们一起在编程的道路是越来越远</strong></span><span style=\"color:#956fe7;\"><strong>，希望下次的我能为大家奉上更好的博客内容，也</strong></span><span style=\"color:#fe2c24;\"><strong>希望下次的博客有你</strong></span><span style=\"color:#956fe7;\"><strong>！</strong></span></p>\n</div>\n</div>"}