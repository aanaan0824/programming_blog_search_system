{"blogid": "126743602", "writerAge": "码龄1年", "writerBlogNum": "577", "writerCollect": "827", "writerComment": "56", "writerFan": "6232", "writerGrade": "6级", "writerIntegral": "6209", "writerName": "embelfe_segge", "writerProfileAdress": "writer_image\\profile_126743602.jpg", "writerRankTotal": "2685", "writerRankWeekly": "1544", "writerThumb": "105", "writerVisitNum": "294756", "blog_read_count": "6", "blog_time": "于 2022-09-07 13:12:44 发布", "blog_title": "JVM之PC寄存器", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h1><a id=\"JVMPC_2\"></a>JVM之PC寄存器</h1>\n<hr/>\n<h2><a id=\"_7\"></a>目录：</h2>\n<ol><li>JVM体系结构概览</li><li>JVM之PC寄存器</li></ol>\n<hr/>\n<h3><a id=\"1_JVM_15\"></a>1. JVM体系结构概览</h3>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\20190514235224246.png\"/></p>\n<hr/>\n<h3><a id=\"2_JVMPC_21\"></a>2. JVM之PC寄存器</h3>\n<ol><li> <p>PC寄存器（ PC register ）：每个线程启动的时候，都会创建一个PC（Program Counter，程序计数器）寄存器。PC寄存器里保存有当前正在执行的JVM指令的地址。 每一个线程都有它自己的PC寄存器，也是该线程启动时创建的。保存下一条将要执行的指令地址的寄存器是 ：PC寄存器。PC寄存器的内容总是指向下一条将被执行指令的地址，这里的地址可以是一个本地指针，也可以是在方法区中相对应于该方法起始指令的偏移量。</p> </li><li> <p>每个线程都有一个程序计数器，是线程私有的,就是一个指针，指向方法区中的方法字节码（用来存储指向下一条指令的地址,也即将要执行的指令代码），由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不记。</p> </li><li> <p>这块内存区域很小，它是当前线程所执行的字节码的行号指示器，字节码解释器通过改变这个计数器的值来选取下一条需要执行的字节码指令。</p> </li><li> <p>如果执行的是一个Native方法，那这个计数器是空的。</p> </li></ol>\n<p>举例：如值日表，又如test1()调用test2()，test2()调用test3()，肯定顺序执行，就是pc寄存器的作用。</p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}