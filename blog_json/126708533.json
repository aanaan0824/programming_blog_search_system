{"blogid": "126708533", "writerAge": "码龄14年", "writerBlogNum": "221", "writerCollect": "4611", "writerComment": "306", "writerFan": "624", "writerGrade": "7级", "writerIntegral": "10227", "writerName": "土豆西瓜大芝麻", "writerProfileAdress": "writer_image\\profile_126708533.jpg", "writerRankTotal": "1462", "writerRankWeekly": "11942", "writerThumb": "969", "writerVisitNum": "1115970", "blog_read_count": "145", "blog_time": "于 2022-09-05 17:07:12 发布", "blog_title": "使用Supervisor进行监控进程并实现自动重启", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h1>1.什么是进程守护系统？　　</h1>\n<p>　　进程守护系统，用于监控指定的进程，当发现目标进程不再正常工作时，就关闭该进程，并重启它。</p>\n<p>　　在什么情况下使用进程守护系统了？比如说，我们的某个服务器软件，在上线后出现一个严重的bug，该bug虽然很难出现，但是只要一出现，整个服务都会停掉（进程没有崩溃，只是不再提供服务）。此时，重启服务软件，又会开始正常工作。</p>\n<p>　　对于这样严重的bug，必须要查清楚并解决掉的。但是，基于以下两个原因：</p>\n<ul><li>系统已经对用户开放，服务不能停。不可能说系统先下线，直到bug被解决掉后再重新上线。</li><li>bug很难重现，可能需要加日志，不断地跟踪排查，这很可能是一场持久战。</li></ul>\n<p>　 　为了让系统继续线上运行，在bug解决之前，必须要保证系统停止服务之后，能迅速重新启动恢复服务。此时，使用进程守护系统是最恰当不过的了。</p>\n<p>　　 Supervisor就是为达到这一目的，实现了一个进程守护系统。一个守护者程序，可以守护同一台机器上的多个进程。Supervisor是一个基于Python开发的Linux系统上的进程监控工具。可以很方便的监听、启动、停止和重启一个或多个进程。通过 Supervisor 管理的进程，当进程意外被 Kill 时，Supervisor 会自动将它重启，可以很方便地做到进程自动恢复的目的，而无需自己编写 shell 脚本来管理进程。<img alt=\"\" height=\"480\" src=\"image\\b0d54deea81541c1adbb27693da21661.png\" width=\"864\"/></p>\n<h1> 2.进程守护系统的实现及使用</h1>\n<p>　　 Supervisor守护者对被守护进程的管理使用的是心跳机制，其原理描述如下：</p>\n<ol><li>被守护进程定时向守护者报告（发送心跳），以表明自己是在正常提供服务。</li><li>如果守护者发现某个被守护进程连续一段时间都没有心跳过来，就关闭对应的进程，然后再启动对应的程序。</li></ol>\n<p>        在supervisor的配置⽂件中，把要管理的进程的可执行文件的路径写进去，通过配置command这个参数，把这些被管理的进程当作supervisor的子进程来启动，获取到该进程的pid，然后再对该pid进行监控，当子进程挂掉的时候，父进程可以准确获取子进程挂掉的信息，可以选择是否⾃⼰启动和报警。</p>\n<h1>3. 安装配置Supervisor</h1>\n<div>\n<pre><code class=\"hljs language-bash\"><span class=\"hljs-comment\">#Ubuntu安装Supervisor</span>\napt install -y supervisor\n<span class=\"hljs-comment\">#supervisor开机自启：</span>\nsystemctl <span class=\"hljs-built_in\">enable</span> supervisor\n<span class=\"hljs-comment\"># 开始运行</span>\nsystemctl start supervisor\n<span class=\"hljs-comment\"># 查看supervisord服务状态</span>\nsystemctl status supervisord \n<span class=\"hljs-comment\"># 查看是否存在supervisord进程</span>\nps -aux|grep supervisord    </code></pre>\n</div>\n<p><strong>编辑配置文件</strong><br/> vim /etc/supervisord.conf,增加如下内容，以方便使用web页面查看被守护进程的信息及操作。</p>\n<div>\n<pre><code class=\"hljs language-bash\">[inet_http_server]        <span class=\"hljs-comment\">#HTTP服务器，提供web管理界面</span>\nport=0.0.0.0:9001         <span class=\"hljs-comment\">#Web管理后台运行的IP和端口，云服务器注意开放该端口</span>\nusername=admin            <span class=\"hljs-comment\">#登录管理后台的用户名</span>\npassword=admin            <span class=\"hljs-comment\">#登录管理后台的密码</span></code></pre>\n</div>\n<p><strong>添加一个被守护进程的配置文件</strong></p>\n<div>\n<pre><code class=\"hljs language-bash\"><span class=\"hljs-comment\">#以test为例</span>\n<span class=\"hljs-built_in\">cd</span> /etc/supervisor/conf.d/\n<span class=\"hljs-comment\">#创建开机启动脚本配置文件</span>\n<span class=\"hljs-built_in\">touch</span> test.conf\n<span class=\"hljs-comment\">#编辑/etc/supervisor/conf.d/test.conf</span>\nvim /etc/supervisor/conf.d/test.conf</code></pre>\n</div>\n<p>内如如下：</p>\n<div>\n<pre><code class=\"hljs language-bash\">[program:api]\n<span class=\"hljs-comment\">#执行文件的路径</span>\ndirectory=/home/ok/test/\n<span class=\"hljs-comment\">#执行的命令</span>\n<span class=\"hljs-built_in\">command</span>=bash test.sh\n<span class=\"hljs-comment\">#随supervisor启动</span>\nautostart = <span class=\"hljs-literal\">true</span>\n<span class=\"hljs-comment\">#启动10秒后没有异常退出，就表示进程正常启动</span>\nstartsecs = 10\n<span class=\"hljs-comment\">#程序退出后自动重启</span>\nautorestart = <span class=\"hljs-literal\">true</span>\n<span class=\"hljs-comment\">#启动失败自动重试次数</span>\nstartretries = 2\n<span class=\"hljs-comment\">#执行命令的用户</span>\nuser = ok\n<span class=\"hljs-comment\">#用来杀死进程的信号</span>\nstopsignal=KILL               \n<span class=\"hljs-comment\">#日志路径</span>\nstdout_logfile=/home/ok/test/tornado_16018.<span class=\"hljs-built_in\">log</span></code></pre>\n</div>\n<p>因为supervisor已经被设置成了开机自启动，而这里，我们又设置了test.sh随着supervisor而自启动。test.sh的内容如下：</p>\n<pre><code class=\"language-bash\">#!/bin/bash\n#echo \"hello world\"\nsleep 10\ncd /home/ok/test/\n./a.out\n#也可以是./a.out &amp;</code></pre>\n<p>其中a.out是我们写的测试程序，主要是测试stl的map的插入与查询功能；</p>\n<p><strong>验证</strong></p>\n<p>重启电脑后，使用web页面查看守护进程工作情况。浏览器访问IP地址端口</p>\n<blockquote>\n<p>http://0.0.0.0:9001</p>\n</blockquote>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\241d2133635d46299843874f88236995.png\"/><br/> 已经开始运行并监控，如果进程挂掉将重启，但是supervisor不支持跨机器的进程监控，一个supervisord只能监控本机上的程序，大大限制了supervisor的使用。</p>\n<p> 查看pstree，supvervisor确实是1号进程的子进程。<img alt=\"\" height=\"655\" src=\"image\\fe3d7f45140b4a01a9106328ec8b24cc.png\" width=\"746\"/></p>\n<p> 我们使用kill -9 pid的方式杀掉a.out后，supervisor确实会再启动一个a.out，这可以可以通过日志查看。</p>\n<p><img alt=\"\" height=\"311\" src=\"image\\b247b785084949878b51655ddadc59b5.png\" width=\"495\"/></p>\n<p> 这里面，supervisor首页显示的pid实际是test.sh对应的进程id，而日志里面的是a.out对应的进程id。</p>\n<p>通过上述测试过程，我们发现，supervisor除了可以监控进程外，其实还可以把某个程序设置为开机启动。</p>\n<p>注意，这里面如果要求用户的程序在全局只能有1份同时在运行，那么脚本里面还需要增加其他的内容，例如判断当前进程列表里面是否已经存在该进程，如果存在，则不再启动，否则则启动。相关内容可以参考：<a href=\"https://blog.csdn.net/andylauren/article/details/52251826\" title=\"linux 进程(关于守护进程、检查一个进程是否活着、如何写一个进程号文件)_andylauren的博客-CSDN博客\">linux 进程(关于守护进程、检查一个进程是否活着、如何写一个进程号文件)_andylauren的博客-CSDN博客</a></p>\n<p>有了supervisor之后我们可以直接借助它来实现我们的守护进程，而不用再像<a href=\"https://blog.csdn.net/dream_1996/article/details/73467969\" title=\"创建守护进程为什么要fork两次_TerryZjl的博客-CSDN博客_守护进程fork两次\">创建守护进程为什么要fork两次_TerryZjl的博客-CSDN博客_守护进程fork两次</a>介绍的那样来回折腾。<br/> 参考链接：https://blog.csdn.net/weixin_46415378/article/details/124229507</p>\n</div>\n</div>"}