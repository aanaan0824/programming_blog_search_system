{"blogid": "122633926", "writerAge": "码龄2年", "writerBlogNum": "13", "writerCollect": "72", "writerComment": "41", "writerFan": "421", "writerGrade": "2级", "writerIntegral": "328", "writerName": "李奇同学喵喵呜～", "writerProfileAdress": "writer_image\\profile_122633926.jpg", "writerRankTotal": "55195", "writerRankWeekly": "959470", "writerThumb": "109", "writerVisitNum": "24585", "blog_read_count": "10131", "blog_time": "于 2022-02-14 13:18:22 发布", "blog_title": "static和const的作用与区别", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p><strong>const定义的常量在超出其<a href=\"https://so.csdn.net/so/search?q=%E4%BD%9C%E7%94%A8%E5%9F%9F&amp;spm=1001.2101.3001.7020\" title=\"作用域\">作用域</a>之后其空间会被释放，而static定义的静态常量在函数执行后不会释放其存储空间。</strong></p>\n<p>我们先来说static.</p>\n<p> </p>\n<p>static主要有三个作用：</p>\n<p><strong>1.修饰局部变量，成为静态局部变量</strong></p>\n<p><strong>2.修饰全局变量，成为静态全局变量</strong></p>\n<p><strong>3.修饰函数，成为静态函数</strong></p>\n<p>我们一个一个来解释.</p>\n<p><strong>1.修饰局部变量。成为静态局部变量</strong></p>\n<p>我们先来看下面这一段程序：</p>\n<pre><code>#include&lt;stdio.h&gt;\nvoid test()\n{\n\tint a = 5;\n\ta++;\n\tprintf(\"%d\", a);\n}\nint main()\n{\n\tint i = 0;\n\twhile (i &lt; 10)\n\t{\n\t\ttest();\n\t\ti++;\n\t}\n}</code></pre>\n<p>输出结果是多少呢？</p>\n<p>我们看到主函数一个循环是循环10次test函数，然后每执行一次test，都会打印一次a，a从6开始每次都+1（因为a++在前面，所以从6开始）.</p>\n<p>所以结果应该是6 7 8 9 10 11 12 13 14 15</p>\n<p>那结果是不是如我们所想的呢？</p>\n<p>我们来看一下运行结果：</p>\n<p><img alt=\"\" height=\"252\" src=\"image\\515bd35c60454d1dac083d75c2cc454a.png\" width=\"673\"/></p>\n<p>这...？好像不符合我们的猜想诶。</p>\n<p>为什么会出现10个6呢？</p>\n<p>我们仔细想一下，便可以大致知道问题所在。</p>\n<p>就是每一次进入循环的时候a都被重置了，所以不会一直加下去。</p>\n<p>这是为什么呢？</p>\n<p>因为a是我们所创建的一个临时变量，它会随着函数的结束而被销毁，下次再进来时，会被重新创建。</p>\n<p>所以会造成我们刚才那种结果。</p>\n<p>那我们就要输出那样6-15这样的结果该怎么做呢？</p>\n<p>我们可以在test函数里面int前面加上一个static</p>\n<p>这样可以让这个局部变量随着函数的结束而不会被销毁，原理稍后会解释的</p>\n<p>改成如下：</p>\n<pre><code>void test()\n{\n\tstatic int a = 5;\n\ta++;\n\tprintf(\"%d \", a);\n}</code></pre>\n<p></p>\n<p></p>\n<p>这样我们再运行一次，来看看结果吧</p>\n<p><img alt=\"\" height=\"550\" src=\"image\\06814e7e0cc340d48762b697258ce2b0.png\" width=\"1017\"/></p>\n<p>符合我们的猜想了。</p>\n<p>那具体为什么是这样呢？这里就要说到数据在内存中存储的三个区域</p>\n<p><strong>栈区   堆区  静态区</strong></p>\n<p><strong>栈区：存放局部变量和函数参数等的地方。栈区的作用范围过了之后会自动回收栈区分配的内存，不需要手动管理。</strong></p>\n<p><strong>堆区：由比如malloc，realloc等函数所主动申请的内存，使用完之后须用free释放内存，若申请完之后忘记释放内存，则很容易造成内存泄漏。</strong></p>\n<p><strong>静态区：静态变量和全局变量所存储的区域，一旦静态区的内存被分配，直到程序全部结束之后才会被释放。</strong></p>\n<p>静态区这个换而言之：<strong>静态区的生命周期和程序的生命周期是一样的，出了作用范围不会被销毁（上面static int a =5）这个例子，相当于作用范围不变，但生命周期延长了。</strong></p>\n<p><strong>那么上面那个例子我们也可以进行解释原理了：</strong></p>\n<p><strong>static修饰局部变量时，实际改变的是变量的存储位置，原来在栈区，被修饰后放在了静态区。</strong></p>\n<p><strong>所以说除了作用范围之后不会被销毁。</strong></p>\n<p></p>\n<p><strong>2.static修饰全局变量</strong></p>\n<p>现在vs编译器里面创建两个源文件：test1.cpp，test2.cpp</p>\n<p>我们首先在文件test1.cpp里面创建一个全局变量，如下：</p>\n<p><img alt=\"\" height=\"322\" src=\"image\\7c4437b3cb0542088b946c7473e313f0.png\" width=\"511\"/></p>\n<p> </p>\n<p> 紧接着，我们知道引用别的文件里的全局变量需要extern这个函数，所以我们再test2.cpp这个文件里引用一下这个全局变量。</p>\n<p><img alt=\"\" height=\"388\" src=\"image\\8fd07f25e01d4b619cfbecb81ce6e4fd.png\" width=\"567\"/></p>\n<p>下面看输出结果：</p>\n<p></p>\n<p> <img alt=\"\" height=\"472\" src=\"image\\5287ee241edb4197b36596a380b6bf5d.png\" width=\"676\"/></p>\n<p> 完美的输出了外部的文件。</p>\n<p>但是如果我们再test1.cpp里面的全局变量前面加上static，我们可以看一下程序能否成功运行。</p>\n<p><img alt=\"\" height=\"316\" src=\"image\\0314ee0d486e40509145b8d9a88bb166.png\" width=\"457\"/></p>\n<p>我们运行这段程序：</p>\n<p><img alt=\"\" height=\"763\" src=\"image\\27e2ffb61f5e4796bfd22a16903cef3c.png\" width=\"1200\"/> </p>\n<p>程序出错了.</p>\n<p>我们看错误原因：无法解析的外部符号。</p>\n<p>这是为什么啊，我们明明已经用了extern这个函数来调用外部文件里的那个全局变量了啊，为什么无法解析呢？</p>\n<p> </p>\n<p> 那肯定是static捣的鬼嘛，它在这里发挥了什么作用呢？</p>\n<p><strong>一个全局变量本来是具有外部属性的，但是被static修饰后，外部属性就变成了内部连接属性，只能在自己所在的源文件内使用，不能在其他文件内使用。</strong></p>\n<p></p>\n<p><strong>这样呢，被static修饰后的全局变量给我们的感觉是作用域变小了（只能在自己文件内部使用，不能在别的文件内使用），但实质是链接属性变了。</strong></p>\n<p><strong>3.static修饰函数</strong></p>\n<p>这个和那个修饰全局变量的类似。</p>\n<p>还是创建两个源文件test1.c、test2.c。（此时文件名后缀为.c，不是.cpp，在c++环境中无法看到这种效果）</p>\n<p>我们在test1.cpp文件里写如下的段程序：</p>\n<p><img alt=\"\" height=\"398\" src=\"image\\2b0c536b56ab463ca6526d3793f3e9c4.png\" width=\"530\"/></p>\n<p> </p>\n<p> 紧接着我们在test2.c里面写Add函数内容。</p>\n<p><img alt=\"\" height=\"313\" src=\"image\\aa21c56a0af747bdb53a1858d44ecf97.png\" width=\"506\"/></p>\n<p> </p>\n<p>结果：</p>\n<p><img alt=\"\" height=\"511\" src=\"image\\249c403e46684a66bcecca8e29c7ea6d.png\" width=\"931\"/></p>\n<p> 完美的输出了我们想要的结果。</p>\n<p></p>\n<p>但如果我们在test2.c里面的Add函数里面加上static：</p>\n<p><img alt=\"\" height=\"357\" src=\"image\\e77a594f7abb43d59038d5389edd3271.png\" width=\"547\"/></p>\n<p>再次运行 :</p>\n<p><img alt=\"\" height=\"918\" src=\"image\\1763434bd5d74e13bdd483fb74682903.png\" width=\"1200\"/></p>\n<p></p>\n<p>发生错误。</p>\n<p>错误原因也是无法解析的外部符号。</p>\n<p>错误呢，和上个修饰全局变量一样：</p>\n<p><strong> 一个函数本来是具有外部连接属性的，但是被static修饰后，外部链接属性就变成了内部连接属性，只能在自己所在的源文件内部使用，不能在其他文件内部使用了。</strong></p>\n<p></p>\n<p><strong>再来说一下const</strong></p>\n<p><strong>如果把const放在变量类型名前，说明这个变量的值是保持不变的，该变量必须在定义时初始化，初始化后对它进行的任何赋值都是非法的。</strong></p>\n<p>1.const修饰常变量<br/> 例如：</p>\n<p>int a=5；</p>\n<p>a=6；</p>\n<p>此时a的值被修改为6。</p>\n<p>const int a=5；</p>\n<p> 此时变量a的值便可再被修改</p>\n<p>若仍写a=6，则程序便会出现错误。</p>\n<p>2.const修饰常量静态字符串</p>\n<p>例如：</p>\n<p>const char* str=\"fdsafdsa\";</p>\n<p>如果没有const的修饰，我们可能会在后面有意无意的写str[4]=’x’这样的语句，这样会导致对只读内存区域的赋值，然后程序会立刻异常终止。有了const，这个错误就能在程序被编译的时候就立即检查出来，这就是const的好处。让逻辑错误在编译期被发现。</p>\n<p>3.修饰函数的参数</p>\n<p>直接举例子说明：</p>\n<p>1.防止指针修改指针指向的内容内容</p>\n<p>我们写以下函数</p>\n<p>void String(char* str1,const char* arr2);</p>\n<p>这个时候我们可以在String这个函数里面修改arr1内容，但是如果修改arr2程序便会报错，此时arr2不可再被修改。</p>\n<p>或：</p>\n<p>2.防止指针修改指针指向的地址</p>\n<p>void Swap(int* const p1,int* const p2);</p>\n<p>此时p1和p2指向的地址便不可再被修改。</p>\n<p></p>\n<p>以上就是static和const的大致区别，当然会有很多的遗漏之处，欢迎补充！</p>\n</div>\n</div>"}