{"blogid": "124641687", "writerAge": "码龄1年", "writerBlogNum": "31", "writerCollect": "1135", "writerComment": "1392", "writerFan": "2532", "writerGrade": "6级", "writerIntegral": "4874", "writerName": "蒋灵瑜的笔记本", "writerProfileAdress": "writer_image\\profile_124641687.jpg", "writerRankTotal": "3399", "writerRankWeekly": "163", "writerThumb": "1592", "writerVisitNum": "27609", "blog_read_count": "1094", "blog_time": "已于 2022-09-04 17:52:04 修改", "blog_title": "【C语言】扫雷小游戏的实现（爆炸展开）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p class=\"img-center\"><img alt=\"ac8fa778091dd927be6c2c46f5507599.gif\" src=\"https://img-blog.csdnimg.cn/img_convert/ac8fa778091dd927be6c2c46f5507599.gif\"/></p>\n<hr/>\n<p style=\"text-align:center;\">💬推荐一款模拟面试、刷题神器 、从基础到大厂面试题：👉<a href=\"https://www.nowcoder.com/link/pc_csdncpt_jlydbjb_c\" title=\"点击跳转刷题网站进行注册学习\">点击跳转刷题网站进行注册学习</a> </p>\n<hr/>\n<p> <img alt=\"\" height=\"48\" src=\"https://img-blog.csdnimg.cn/img_convert/0a78b01e3c22de1dc1b7f5a96096b19a.gif\" width=\"48\"/>各位朋友们大家好呀！今天又又是游戏整活环节，先介绍一下这个版本的扫雷游戏完善的一些功能：</p>\n<p><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/dc5ec4cc18d1816a904aad785e8b2117.gif\"/>1、运气够好的话，首次选中的坐标3*3方格内如果没有安置地雷，将会为玩家展开一片空白区域【终于可以不用一个个手动排雷了】</p>\n<p><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/dbc34fa2913321f1661c1b0543676e73.gif\"/>2、添加了插旗/取消插旗功能，优化排雷过程；</p>\n<p><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/4f09f67379212700c3ef558aaee4dec9.gif\"/>3、新增了玩家首次获胜后再也不想玩第二次的功能</p>\n<p id=\"u5cf24fdd\">​<img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/4f09f67379212700c3ef558aaee4dec9.gif\"/>​4、拿着铲子的不一定是黄金矿工，还有可能是拆弹专家~</p>\n<p id=\"u466943c8\">核心思想：创建两个二维数组，show数组用于排雷的下棋界面，mine数组用于铺设地雷。</p>\n<h1><img alt=\"\" height=\"48\" src=\"https://img-blog.csdnimg.cn/img_convert/0a78b01e3c22de1dc1b7f5a96096b19a.gif\" width=\"48\"/>​<span style=\"color:#956fe7;\">1、game.h</span></h1>\n<div>\n<pre><code class=\"language-cpp\">#pragma once\n#define _CRT_SECURE_NO_WARNINGS 1\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;time.h&gt;\n#define ROW 9//用于展示的二维数组行的长度\n#define COL 9//用于展示的二维数组列的长度\n#define ROWS ROW+2//创建稍大的二维数组，防止判断时越界\n#define COLS COL+2//创建稍大的二维数组，防止判断时越界\n#define NUMS 10//雷的个数\nvoid BoardInit(char arr[ROWS][COLS], int rows, int cols,char a);//初始化二维数组\nvoid BoardPrint(char arr[ROWS][COLS], int row, int col);//打印二维数组\nvoid GenerateMine(char mine[ROWS][COLS], int row, int col);//生成雷\nvoid CheckMine(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col);//排查雷\nvoid Flag(char show[ROWS][COLS], int x, int y);//插旗\nvoid FlagCancel(char show[ROWS][COLS], int x, int y);//取消插旗\nvoid Expand(char mine[ROWS][COLS], char show[ROWS][COLS], int x, int y);//展开\nint Victory(char show[ROWS][COLS], int row, int col);//判断胜利</code></pre>\n</div>\n<blockquote>\n<p>先看一下整体轮廓，从这几个头文件可以看出小游戏的功能和逻辑~</p>\n</blockquote>\n<h1 id=\"Xv9QY\"><img alt=\"\" height=\"48\" src=\"https://img-blog.csdnimg.cn/img_convert/0a78b01e3c22de1dc1b7f5a96096b19a.gif\" width=\"48\"/>​<span style=\"color:#956fe7;\">2、game.c</span></h1>\n<h2 id=\"UyOMZ\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/dc5ec4cc18d1816a904aad785e8b2117.gif\"/>​<span style=\"color:#ed7976;\">2.1初始化二维数组</span></h2>\n<div>\n<pre><code class=\"language-cpp\">#include \"game.h\"\nvoid BoardInit(char arr[ROWS][COLS], int rows, int cols,char a)//初始化二维数组\n{\n\tfor (int i = 0; i &lt; rows; i++)\n\t{\n\t\tfor (int j = 0; j &lt; cols; j++)\n\t\t{\n\t\t\tarr[i][j] = a;\n\t\t}\n\t}\n}</code></pre>\n</div>\n<blockquote>\n<p> 由于创建了两个二维数组，需要将show棋盘初始化为'*'，mine棋盘初始化为'0',故在此函数中新增了第四个参数，用于保证两个数组初始化结果的不同。</p>\n</blockquote>\n<h2> <img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/dc5ec4cc18d1816a904aad785e8b2117.gif\"/><span style=\"color:#ed7976;\">2.2打印二维数组</span></h2>\n<pre><code class=\"language-cpp\">void BoardPrint(char arr[ROWS][COLS], int row, int col)//打印二维数组\n{\n\tfor (int j = 0; j &lt;= col; j++)\n\t\tprintf(\"%d \", j);\n\tprintf(\"\\n\");\n\tfor (int i = 1; i &lt;= row; i++)\n\t{\n\t\tprintf(\"%d \", i);\n\t\tfor (int j = 1; j &lt;= col; j++)\n\t\t{\n\t\t\tprintf(\"%c \", arr[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}</code></pre>\n<blockquote>\n<p> 打印二维数组，用for循环打印出行与列，方便排雷时输入坐标。如下图所示：</p>\n</blockquote>\n<p><img alt=\"\" height=\"639\" src=\"image\\bbc172ebd94b4ef2a4d4a9d0daabdabb.png\" width=\"1200\"/></p>\n<h2><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/dc5ec4cc18d1816a904aad785e8b2117.gif\"/><span style=\"color:#ed7976;\">2.3生成雷</span></h2>\n<pre><code class=\"language-cpp\">void GenerateMine(char mine[ROWS][COLS], int row, int col)//生成雷\n{\n\tint i = NUMS;\n\twhile(i)\n\t{\n\t\tint x = rand() % row + 1;\n\t\tint y = rand() % col + 1;\n\t\tif (mine[x][y] != '1')\n\t\t{\n\t\t\tmine[x][y] = '1';//字符1是雷\n\t\t\ti--;\n\t\t}\n\t}\n}</code></pre>\n<blockquote>\n<p> 使用rand函数随机生成雷的坐标，将雷埋入mine数组。注意记得在main函数使用srand函数。</p>\n</blockquote>\n<h2 id=\"ojJJ0\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/dc5ec4cc18d1816a904aad785e8b2117.gif\"/><span style=\"color:#ed7976;\">2.4插旗&amp;取消插旗</span></h2>\n<pre><code class=\"language-cpp\">void Flag(char show[ROWS][COLS], int x,int y)//插旗\n{\n\tif (show[x][y] == '*')\n\t{\n\t\tshow[x][y] = 'F';\n\t}\n\telse\n\t\tprintf(\"非法插旗！\\n\");    \n}\nvoid FlagCancel(char show[ROWS][COLS], int x, int y)//取消插旗\n{\n\tif (show[x][y] == 'F')\n\t{\n\t\tshow[x][y] = '*';\n\t}\n\telse\n\t\tprintf(\"非法取消插旗！\\n\");\n}</code></pre>\n<blockquote>\n<p> 用'F'替代'*',注意需要检查坐标是否已经被排查。</p>\n</blockquote>\n<h2><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/dc5ec4cc18d1816a904aad785e8b2117.gif\"/><span style=\"color:#ed7976;\">2.5显示输入坐标3*3范围雷的个数</span></h2>\n<pre><code class=\"language-cpp\">void MineHint(char mine[ROWS][COLS], char show[ROWS][COLS], int x, int y)//显示周边几个雷\n{\n\tint sum=mine[x - 1][y - 1] + mine[x - 1][y] + mine[x - 1][y + 1]\n\t\t+ mine[x][y - 1] + mine[x][y + 1] + mine[x + 1][y + 1]\n\t\t+ mine[x + 1][y] + mine[x + 1][y - 1] - 8 * '0';\n\tshow[x][y] = '0' + sum;\n}</code></pre>\n<blockquote>\n<p id=\"u58ae513c\">解析：统计mine周边3*3范围内字符的和，减去8个字符0，差值即为3*3范围内地雷的个数sum，将其坐标置为'0' + sum。</p>\n</blockquote>\n<h2><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/dc5ec4cc18d1816a904aad785e8b2117.gif\"/><span style=\"color:#ed7976;\">2.6展开功能（递归）</span></h2>\n<pre><code class=\"language-cpp\">void Expand(char mine[ROWS][COLS], char show[ROWS][COLS], int x, int y)//展开\n{\n\tif (mine[x - 1][y - 1] + mine[x - 1][y] + mine[x - 1][y + 1]\n\t\t+ mine[x][y - 1] + mine[x][y + 1] + mine[x + 1][y + 1]\n\t\t+ mine[x + 1][y] + mine[x + 1][y - 1] - 8 * '0'== 0)\n\t{\n\t\tshow[x][y] = ' ';\n\t\tif (show[x - 1][y - 1] == '*')\n\t\t\tExpand(mine, show, x - 1, y - 1);\n\t\tif (show[x - 1][y] == '*')\n\t\t\tExpand(mine, show, x - 1, y);\n\t\tif (show[x - 1][y + 1] == '*')\n\t\t\tExpand(mine, show, x - 1,y+1); \n\t\tif (show[x][y - 1] == '*')\n\t\t\tExpand(mine, show, x, y - 1);\n\t\tif (show[x][y + 1] == '*')\n\t\t\tExpand(mine, show, x, y + 1);\n\t\tif (show[x + 1][y + 1] == '*')\n\t\t\tExpand(mine, show, x + 1, y + 1);\n\t\tif (show[x + 1][y] == '*')\n\t\t\tExpand(mine, show, x + 1, y);\n\t\tif (show[x + 1][y - 1] == '*')\n\t\t\tExpand(mine, show, x + 1, y + 1);\n\t}\n\telse\n\t\tMineHint(mine, show, x, y);\n}</code></pre>\n<blockquote>\n<p id=\"u6bab25c4\">解析：如果输入坐标3*3范围内另8个点坐标和减去8*'0'等于0，说明周边没有雷，将其坐标置为空，并对其周边8个点进行判断递归，若点未判断过（'*'），则进行递归，若已判断，将显示该点周围地雷个数。如下图所示：</p>\n</blockquote>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\021f7e5bddb7986f907b12594e350abe.png\"/></p>\n<h2><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/dc5ec4cc18d1816a904aad785e8b2117.gif\"/><span style=\"color:#ed7976;\">2.7判断胜利</span></h2>\n<pre><code class=\"language-cpp\">int Victory(char show[ROWS][COLS], int row, int col)//判断胜利\n{\n\tint count = 0;//统计剩余*的数量\n\tfor (int i = 1; i &lt;= row; i++)\n\t{\n\t\tfor (int j = 1; j &lt;= col; j++)\n\t\t{\n\t\t\tif (show[i][j] == '*'|| show[i][j] == 'F')\n\t\t\t\tcount++;\n\t\t}\n\t}\n\tif (count == NUMS)\n\t{\n\t\tprintf(\"恭喜获胜！\\n\");\n\t\treturn 1;\n\t}\n\telse\n\t\treturn 0;\n}</code></pre>\n<blockquote>\n<p id=\"u4f32aa0b\">遍历show数组，统计'*'与'F'的个数，若count和地雷书数NUMS相等，则认为游戏胜利！</p>\n</blockquote>\n<h2 id=\"dYvxa\"><span style=\"color:#6eaad7;\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/dc5ec4cc18d1816a904aad785e8b2117.gif\"/></span><span style=\"color:#ed7976;\">2.8排查雷</span></h2>\n<pre><code class=\"language-cpp\">void GameMenu()\n{\n\tprintf(\"#######1、排雷########\\n\");\n\tprintf(\"#######2、插旗########\\n\");\n\tprintf(\"#######3、取消插旗####\\n\");\n\tprintf(\"请选择：\");\n}\nvoid CheckMine(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col)//排查雷\n{\n\tint x = 0;\n\tint y = 0;\n\twhile (1)\n\t{\n\t\tGameMenu();\n\t\tint input = 0;\n\t\tscanf(\"%d\", &amp;input);\n\t\tif (input != 1 &amp;&amp; input != 2 &amp;&amp; input != 3)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tprintf(\"请输入坐标：\");\n\t\tscanf(\"%d%d\", &amp;x, &amp;y);\n\t\tif (input == 1)\n\t\t{\n\t\t\tif (x &gt; 0 &amp;&amp; x &lt;= row &amp;&amp; y &gt; 0 &amp;&amp; y &lt;= col)\n\t\t\t{\n\t\t\t\tif (show[x][y] == '*' &amp;&amp; mine[x][y] != '1')\n\t\t\t\t{\n\t\t\t\t\tExpand(mine, show, x, y);//展开\n\t\t\t\t\tBoardPrint(show, row, col);//打印二维数组\n\t\t\t\t\tif (Victory(show, row, col) == 1)//判断胜利\n\t\t\t\t\t{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (mine[x][y] == '1')\n\t\t\t\t{\n\t\t\t\t\tprintf(\"被雷炸死了！\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tprintf(\"坐标非法！请重新输入！\\n\");\n\t\t\t}\n\t\t\telse\n\t\t\t\tprintf(\"坐标非法！请重新输入！\\n\");\n\t\t}\n\t\telse if (input == 2)\n\t\t{\n\t\t\tFlag(show, x, y);\n\t\t\tBoardPrint(show, row, col);//打印二维数组\n\t\t}\n\t\telse if (input == 3)\n\t\t{\n\t\t\tFlagCancel(show, x, y);\n\t\t\tBoardPrint(show, row, col);//打印二维数组\n\t\t}\n\t\telse\n\t\t\tprintf(\"输入错误！请重新选择：\\n\");\n\t}\n\tBoardPrint(mine, row, col);//打印二维数组\n}</code></pre>\n<blockquote>\n<p id=\"u6a179e5d\">每次排雷前会让玩家选择排雷/插旗/取消插旗，如果输入的不是规定数字，会被continue直接重置回循环的起点。排查雷接口基本上是上述接口的调用和循环及判断语句的应用。细心梳理逻辑，勤加调试，问题不大。</p>\n</blockquote>\n<h1><img alt=\"\" height=\"48\" src=\"https://img-blog.csdnimg.cn/img_convert/0a78b01e3c22de1dc1b7f5a96096b19a.gif\" width=\"48\"/><span style=\"color:#956fe7;\"><strong>3、text.c</strong></span></h1>\n<pre><code class=\"language-cpp\">#include \"game.h\"\nvoid menu()\n{\n\tprintf(\"#######################\\n\");\n\tprintf(\"########1、play########\\n\");\n\tprintf(\"########2、exit########\\n\");\n\tprintf(\"#######################\\n\");\n}\nvoid game()\n{\n\tchar show[ROWS][COLS] = { 0 };\n\tchar mine[ROWS][COLS] = { 0 };\n\tBoardInit(show, ROWS, COLS, '*');//初始化二维数组\n\tBoardInit(mine, ROWS, COLS, '0');//初始化二维数组\n\tGenerateMine(mine, ROW, COL);//生成雷\n\tBoardPrint(show, ROW, COL);//打印二维数组\n\tCheckMine(mine, show, ROW, COL);//排查雷\n}\nint main()\n{\n\tint input = 0;\n\tsrand((unsigned)time(NULL));\n\tdo\n\t{\n\t\tmenu();\n\t\tprintf(\"请选择：\");\n\t\tscanf(\"%d\", &amp;input);\n\t\tif (input == 1)\n\t\t\tgame();\n\t\telse if (input == 2)\n\t\t{\n\t\t\tprintf(\"游戏已退出！\\n\");\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t\tprintf(\"输入错误！请重新输入！\\n\");\n\t} while (1);\n\treturn 0;\n}</code></pre>\n<h1><img alt=\"\" height=\"48\" src=\"https://img-blog.csdnimg.cn/img_convert/0a78b01e3c22de1dc1b7f5a96096b19a.gif\" width=\"48\"/><span style=\"color:#956fe7;\">4、运行截图</span></h1>\n<p><img alt=\"\" height=\"639\" src=\"image\\c7845e8118a9420c8416104408310c8e.png\" width=\"1200\"/></p>\n<blockquote>\n<p></p>\n<p id=\"u5bcbff15\">有插旗功能玩着还是挺舒服的，不会忘记雷区，插错旗也可以取消。当旗帜和*的数量等于设定的雷的数量时，游戏获胜！</p>\n<p id=\"u5a8a23cd\">游戏挺好玩的（</p>\n</blockquote>\n<hr/>\n<p></p>\n<p id=\"u78a42b14\"><span style=\"color:#fe2c24;\">关注！点赞！评论！收藏！关注！点赞！评论！收藏！关注！点赞！评论！收藏！关注！点赞！评论！收藏！关注！点赞！评论！收藏！</span></p>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/b065b7d3f1fa2e866c6eb22426979693.gif\"/></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n</div>\n</div>"}