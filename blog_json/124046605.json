{"blogid": "124046605", "writerAge": "码龄2年", "writerBlogNum": "51", "writerCollect": "1074", "writerComment": "233", "writerFan": "1049", "writerGrade": "4级", "writerIntegral": "996", "writerName": "嵌入式创客工坊", "writerProfileAdress": "writer_image\\profile_124046605.jpg", "writerRankTotal": "22025", "writerRankWeekly": "16075", "writerThumb": "266", "writerVisitNum": "124888", "blog_read_count": "1688", "blog_time": "已于 2022-04-15 22:50:24 修改", "blog_title": "STM32系列(HAL库)——F103C8T6驱动WS2812全彩RGB模块（PWM+DMA方式）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h2>1.软件准备</h2>\n<p>(1)编程平台：<a href=\"https://so.csdn.net/so/search?q=Keil5\" title=\"Keil5\">Keil5</a></p>\n<p>(2)CubeMX</p>\n<h2>2.硬件准备</h2>\n<p>(1)某宝买的RGB模块（4个灯珠级联）</p>\n<p><img alt=\"\" height=\"222\" src=\"image\\8d88d43f01154d729297fc9d071d38f9.png\" width=\"333\"/></p>\n<p></p>\n<p>(2)F1的板子，本例使用经典F103C8T6</p>\n<p><img alt=\"\" height=\"151\" src=\"image\\e10a7d57a76440bdac2d6310c76f0771.jpg\" width=\"333\"/></p>\n<p>(3)ST-link 下载器</p>\n<p><img alt=\"\" height=\"255\" src=\"image\\6108cfea4ecf4ee2b96d31679e15e5d7.jpg\" width=\"333\"/></p>\n<p>(4)杜邦线若干</p>\n<p><img alt=\"\" height=\"144\" src=\"image\\8edc235a99de47859ca4c973632b1864.png\" width=\"333\"/></p>\n<h2>3.模块资料</h2>\n<h3><a name=\"t3\"></a>(1)模块简介：</h3>\n<p>没什么比手册讲得更加清楚了，模块中文数据手册：<a class=\"link-info\" href=\"https://wenku.baidu.com/view/0925958fba68a98271fe910ef12d2af90342a80e.html\" title=\"ws2812b中文资料_数据手册_参数\">ws2812b中文资料_数据手册_参数</a></p>\n<h3>(2)驱动原理:</h3>\n<p class=\"img-center\"><img alt=\"\" height=\"441\" src=\"image\\837ec30687ca456a9119c659d827615f.png\" width=\"777\"/></p>\n<p>         以上这是数据手册中提到的，WS2812驱动用的是单线归零码的通讯方式。不同占空比的方波代表1码或者0码，这里不同的占空比就是  0码或1码高电平时间 / 方波周期时间 。对于本次例程，我们就是改变PWM的占空比实现0码或1码的传输。</p>\n<h3>(3)PWM+DMA原理:</h3>\n<p>        关于DMA的详细解析，我推荐这篇文章：<a class=\"link-info\" href=\"https://blog.csdn.net/as480133937/article/details/104927922\" title=\"DMA原理，步骤超细详解，一文看懂DMA\">DMA原理，步骤超细详解，一文看懂DMA</a></p>\n<p>        PWM+DMA可以实现数量和占空比可控的脉冲，具体实现原理是在开启DMA的情况下，定时器在每次计数满后，会自动将DMA传输过来的数据作为新一轮的比较数值。如果DMA传输的数据每次不同，那么每次的方波占空比就不一样的。在本例程中，我们将数据存放在一个数组，通过DMA传输数组的内容，根据数组中数据的个数和每个数据的大小，就能实现数量和占空比可控的PWM。</p>\n<h1 id=\"3.CubeMX%E9%85%8D%E7%BD%AE\">4.CubeMX配置</h1>\n<h3 id=\"%EF%BC%881%EF%BC%89%C2%A0%E8%8A%AF%E7%89%87%E9%80%89%E6%8B%A9\"><a name=\"t8\"></a>(1)芯片选择</h3>\n<p class=\"img-center\"><img alt=\"\" height=\"594\" src=\"image\\9ebf2621ec9840b39fc483aef7624954.png\" width=\"777\"/></p>\n<h3><a name=\"t9\"></a><a name=\"t7\"></a> (2)配置RCC、SYS、时钟树</h3>\n<p class=\"img-center\"><img alt=\"\" height=\"534\" src=\"image\\7e1dfbd60d714583897a137c770ff2be.png\" width=\"777\"/></p>\n<p style=\"text-align:center;\">配置RCC</p>\n<p class=\"img-center\"><img alt=\"\" height=\"534\" src=\"image\\1b310b1d3c754cf2899fa969978bef6d.png\" width=\"777\"/></p>\n<p style=\"text-align:center;\">配置SYS</p>\n<p class=\"img-center\"><img alt=\"\" height=\"534\" src=\"image\\d573758ae1834a93aa54a409e4e71ee0.png\" width=\"777\"/></p>\n<p style=\"text-align:center;\">配置时钟树</p>\n<h3>(3)配置定时器TIM1</h3>\n<p class=\"img-center\"><img alt=\"\" height=\"487\" src=\"image\\eb4bfecfa53945a0adb9788e0fd02f3f.png\" width=\"777\"/></p>\n<p>         在定时器配置中，我们根据WS2812的最大传输速率800kbps，设置定时器不分频和计数周期为89+1，这样下来波形的频率为  72M /（89+1） = 800K  ，并且一个波形的周期为  1 / 800 = 1.25us</p>\n<h3>(4)开启DMA</h3>\n<p class=\"img-center\"><img alt=\"\" height=\"483\" src=\"image\\6665dcfa683a493e95cfa85c4714ab3b.png\" width=\"777\"/></p>\n<h3> (5）设置路径、生成代码工程 </h3>\n<p></p>\n<h1>5、<a href=\"https://so.csdn.net/so/search?q=Keil5&amp;spm=1001.2101.3001.7020\" title=\"Keil5\">Keil5</a>代码</h1>\n<h3>(1)创建RGB.c和RGB.h文件</h3>\n<h3><a name=\"t18\"></a><a name=\"t16\"></a><a name=\"t12\"></a>(2)添加上述的RGB.c文件进工程</h3>\n<p><a href=\"https://blog.csdn.net/lwb450921/article/details/122293440?spm=1001.2014.3001.5501\" title=\"——————上述两步参考之前系列教学步骤，在此不再赘述(点击跳转)\">——————上述两步参考之前系列教学步骤，在此不再赘述(点击跳转)</a></p>\n<h3>(3)RGB.c和RGB.h代码</h3>\n<p style=\"text-align:center;\"> <span style=\"color:#fe2c24;\">RGB.h</span></p>\n<pre><code class=\"language-cs\">#ifndef __RGB_H\n#define __RGB_H\n#include \"main.h\"\n#define Hight_Data            ( 64  )                           //1 码相对计数值\n#define Low_Data              ( 36  )                           //0 码相对计数值\n#define Reste_Data            ( 80  )                           //80 复位电平相对计数值\n#define Led_Num               (  4  )                           //WS2812灯个数\n#define Led_Data_Len          ( 24  )                           //WS2812数据长度，单个需要24个字节\n#define WS2812_Data_Len   (Led_Num * Led_Data_Len)              //ws2812级联后需要的数组长度\n\n//uint16_t RGB_buffur[Reste_Data + WS2812_Data_Len] = { 0 }; //数据缓存数组\n\n\nvoid WS2812_Display_1(uint32_t Color, uint16_t num);\nvoid WS2812_Display_2( uint8_t red, uint8_t green, uint8_t blue,uint16_t num);\n\nvoid WS2812_Number_4(uint32_t Color1,uint32_t Color2,uint32_t Color3,uint32_t Color4);//封装好的四个灯函数，只需要分别输入四个灯的颜色即可\n\n\n#endif\n\n\n</code></pre>\n<p style=\"text-align:center;\"><span style=\"color:#fe2c24;\"> RGB.c</span></p>\n<pre><code class=\"language-cs\">#include \"RGB.h\"\n#include \"main.h\"\n#include \"tim.h\"\n\nuint16_t RGB_buffur[Reste_Data + WS2812_Data_Len] = { 0 }; //数据缓存数组\n\nvoid WS2812_Display_1(uint32_t Color, uint16_t num)\n{\n   \n    //指针偏移:需要跳过复位信号的N个0\n    uint16_t* p = (RGB_buffur + Reste_Data) + (num * Led_Data_Len);\n    \n    for (uint8_t i = 0; i &lt; 8; ++i)         \n\tp[i+8]= (((Color &lt;&lt; i) &amp; 0X800000) ? Hight_Data :Low_Data);\n    for (uint8_t i = 8; i &lt; 16; ++i)\n\tp[i-8]= (((Color &lt;&lt; i) &amp; 0X800000) ? Hight_Data :Low_Data);\n    for (uint8_t i = 16; i &lt; 24; ++i)\n\tp[i]= (((Color &lt;&lt; i) &amp; 0X800000) ? Hight_Data :Low_Data);  \n       \n}\n\n\nvoid WS2812_Display_2( uint8_t red, uint8_t green, uint8_t blue,uint16_t num)\n{\n            \n            uint8_t i;\n            uint32_t Color=(green &lt;&lt; 16 | red &lt;&lt; 8 | blue);//将2个8位数据合并转化为32位数据类型\n    \n            //指针偏移:需要跳过复位信号的N个0\n            uint16_t* p = (RGB_buffur + Reste_Data) + (num * Led_Data_Len);\n    \n            for (i = 0; i &lt; 24; ++i)    //对数组进行编辑\n\t\t\tp[i]= (((Color &lt;&lt; i) &amp; 0X800000) ? Hight_Data : Low_Data);\t\n                        \n}\n\n\nvoid WS2812_Number_4(uint32_t Color1,uint32_t Color2,uint32_t Color3,uint32_t Color4)\n{\n    \n    uint16_t  RGB_Buff_4[Reste_Data + 4 * WS2812_Data_Len] = { 0 };\n    uint16_t* p;\n    uint32_t Color;\n    \n    for( uint8_t k=0;k&lt;4;k++)\n  {      \n      switch (k)    //进行指针偏移\n      {\n        case 0: p= (RGB_Buff_4 + Reste_Data) + (0 * Led_Data_Len),Color=Color1;break;\n        case 1: p= (RGB_Buff_4 + Reste_Data) + (1 * Led_Data_Len),Color=Color2;break;\n        case 2: p= (RGB_Buff_4 + Reste_Data) + (2 * Led_Data_Len),Color=Color3;break;\n        case 3: p= (RGB_Buff_4 + Reste_Data) + (3 * Led_Data_Len),Color=Color4;break;\n        default : ;break;     \n      }\n      \n     for (uint8_t i = 0; i &lt; 8; ++i)   //对数组进行编辑\n    {   \n        for (uint8_t i = 0; i &lt; 8; ++i)\n        p[i+8]= (((Color &lt;&lt; i) &amp; 0X800000) ? Hight_Data :Low_Data);\n        for (uint8_t i = 8; i &lt; 16; ++i)\n        p[i-8]= (((Color &lt;&lt; i) &amp; 0X800000) ? Hight_Data :Low_Data);\n        for (uint8_t i = 16; i &lt; 24; ++i)\n        p[i]= (((Color &lt;&lt; i) &amp; 0X800000) ? Hight_Data :Low_Data);\n    } \n   \n }   \n  \n    HAL_TIM_PWM_Start_DMA(&amp;htim1,TIM_CHANNEL_1,(uint32_t *)RGB_Buff_4,(176));//启动DMA传输\n    \n}\n\n //  DMA 传输完成回调函数\nvoid HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)\n{\n    HAL_TIM_PWM_Stop_DMA(&amp;htim1,TIM_CHANNEL_1);\n}\n\n\n\n</code></pre>\n<h3>(4)main函数</h3>\n<pre><code class=\"language-cs\">#include \"RGB.h\"\n\n\n\nint main(void)\n{\n \n  extern uint16_t RGB_buffur[Reste_Data + WS2812_Data_Len];\n \n  HAL_Init();\n \n  SystemClock_Config();\n\n  MX_GPIO_Init();\n  MX_DMA_Init();\n  MX_TIM1_Init();\n  /* USER CODE BEGIN 2 */\n\n//        //点亮4个灯\n//        WS2812_Display_1(0x180000, 0);\n//        WS2812_Display_1(0x001800, 1);\n//        WS2812_Display_1(0x000018, 2);\n//        WS2812_Display_1(0x181818, 3);\n//        HAL_TIM_PWM_Start_DMA(&amp;htim1,TIM_CHANNEL_1,(uint32_t *)RGB_buffur,(176));//启动DMA传输        \n\n\n//        //以下代码和上述效果一致，只是颜色数据表示形式不一样\n//        WS2812_Display_2( 22 , 0 , 0, 0);\n//        WS2812_Display_2(  0 , 22, 0, 1);\n//        WS2812_Display_2(  0 , 0, 22, 2);\n//        WS2812_Display_2( 22, 22 , 22, 3);\n//        HAL_TIM_PWM_Start_DMA(&amp;htim1,TIM_CHANNEL_1,(uint32_t *)RGB_buffur,(176));//启动DMA传输 \n\n \n \n  while (1)\n  {\n      \n      //流水效果\n    WS2812_Number_4(0x180000,0x001800,0x000018,0);\n    HAL_Delay(500);\n    WS2812_Number_4(0,0x180000,0x001800,0x000018);\n    HAL_Delay(500);\n    WS2812_Number_4(0x000018,0,0x180000,0x001800);\n    HAL_Delay(500);\n    WS2812_Number_4(0x001800,0x000018,0,0x180000);\n    HAL_Delay(500);\n     \n    \n  }\n \n}</code></pre>\n<p>        因时间问题，代码没有做过多注释。后续再补上。</p>\n<h1>6.接线图及效果</h1>\n<p>        关于接线：定时器1的通道1为PA8，将PA8和模块IN引脚连接，并注意供电充足即可。</p>\n<p class=\"img-center\"><img alt=\"\" height=\"187\" src=\"https://img-blog.csdnimg.cn/88ac33209f7a42559268c3f9c82d7acb.gif\" width=\"333\"/></p>\n<p style=\"text-align:center;\"></p>\n<p class=\"img-center\"><img alt=\"\" height=\"321\" src=\"image\\5af5fcc953fe4b3fa21579e057683b95.png\" width=\"333\"/></p>\n<h2 style=\"text-align:center;\">  本例程源码下载：<a href=\"https://gitee.com/LiaoWenBin2001/csdn-project-source-code\" title=\"点击跳转\">点击跳转</a> </h2>\n</div>\n</div>"}