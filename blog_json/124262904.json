{"blogid": "124262904", "writerAge": "码龄2年", "writerBlogNum": "38", "writerCollect": "61", "writerComment": "16", "writerFan": "87", "writerGrade": "3级", "writerIntegral": "461", "writerName": "是饿梦啊", "writerProfileAdress": "writer_image\\profile_124262904.jpg", "writerRankTotal": "42620", "writerRankWeekly": "84720", "writerThumb": "73", "writerVisitNum": "23506", "blog_read_count": "4514", "blog_time": "于 2022-04-22 00:04:56 发布", "blog_title": "拓扑排序（Topological sorting）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<blockquote>\n<p>拓扑排序指的是<strong>有向无环图</strong>（DAG）；</p>\n<p>学过计算机网络的知道计算机网络中有一个拓扑结构；</p>\n<p>下面就是一个拓扑结构；</p>\n<p>那拓扑序就是，图中任意一对顶点u和v，若边&lt;u,v&gt;∈E(G)，则u在线性序列中出现在v之前</p>\n<p>我们可以发现拓扑序不是唯一的；</p>\n<p>接下来，我们需要知道一个概念——<strong>度</strong>：</p>\n<p>对于有向图的某个结点来说，我们把指向它的边的数量叫做<strong>入度</strong>；</p>\n<p>把从它发出的边的数量称为<strong>出度</strong>，这个都很好理解吧；</p>\n</blockquote>\n<p class=\"img-center\"><img alt=\"\" height=\"222\" src=\"image\\7a728ff23eeb4ee3bfc3cc0690dade3d.png\" width=\"342\"/></p>\n<p><strong>如何获得一个拓扑序：</strong> </p>\n<blockquote>\n<p>我们先来找一个最容易理解的例子，那就是食物链，对一个自然界的食物链来说，一定存在拓扑序；</p>\n<p><strong>第一：不存在环；</strong></p>\n<p><strong>第二：有向；</strong></p>\n<p>接下来我们来看看如何获得一个拓扑序，我们观察最左面的结点，一定是没有指向它的边，也就是入度为零，最右边的结点呢，是一定不存在它指向别人的边的，如果有，那么它就不是最右边的点也就是出度为零；</p>\n<p>那就是说，所有入度为零的点都可以作为起点，我们开一个数组记录入度的值；</p>\n<p>至于如何使用邻接表存边，这就不展开解释了，可以参考这个：<a class=\"link-info\" href=\"https://blog.csdn.net/qq_47982709/article/details/123910900\" title=\"传送门\">传送门</a></p>\n<p>其实，拓扑排序也是bfs的一个简单应用，我们需要借助队列来实现；</p>\n<p>首先，我们遍历存储入度的数组，获得可以作为起点的结点，将其加入队列；</p>\n<p>接下来就可以愉快的遍历了，没当我们遍历到一个点的时候，我们让它的入度--；</p>\n<p>这样做的意义就是，判断指向这个点的边是不是都遍历过了，因为我们要保证拓扑序最重要的一个特点：&lt;u,v&gt;的边中，u一定在v的前面出现；</p>\n<p>如果这个点所有的边都遍历过的话，是不是也就是说这个点已经没有指向它的边了，也就是说这个点可以作为一个起点了，那我们将它加入队列；循环这个操作，知道队列为空；</p>\n</blockquote>\n<p><a href=\"https://www.luogu.com.cn/problem/P4017\" title=\"最大食物链计数 - 洛谷\">最大食物链计数 - 洛谷</a></p>\n<blockquote>\n<p>有了上面的介绍，我们直接来看这个题；我们要求最大食物链数量；</p>\n<p>这个最大，我们不要理解错了，这个指的就是，我们需要从一个入度为零的点开始到一个出度为零的点；计算给出的食物网中，食物链的数量；</p>\n<p>这里题，我们需要不仅需要记录一下入度还要记录一下出度，因为我们要计算食物链的数量，食物链的最后一个结点，是不是就是出度为零的点；</p>\n<p>然后食物链的数量的话，是不是就是一个简答的dp啊；然后我们这个题就做完了；</p>\n</blockquote>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;cmath&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\n#include&lt;unordered_map&gt;\n#define x first\n#define y second \n#define _for(i,s,t) for(int i = (s);i &lt;=t ; i++)\n#define FAST ios::sync_with_stdio(false); cin.tie(0);cout.tie(0);\n\nusing namespace std;\n\ntypedef unsigned long long ULL;\ntypedef long long LL;\ntypedef pair&lt;int,int&gt; PII;\n\nconst int N = 5010,M = 500010,INF = 0x3f3f3f3f,mod = 80112002;\n\nint h[N],e[M],ne[M],idx;\nint d[N],c[N],f[N],q[N];\nint n,m;\n\nvoid add(int a,int b)\n{\n\te[idx] = b;\n\tne[idx] = h[a];\n\th[a] = idx++;\n}\n\nvoid topsort()\n{\n\tint hh = 0,tt = -1;\n\t\n\tfor(int i =1 ;i&lt;= n;i++)\n\t{\n\t\tif(!d[i])\n\t\t{\n\t\t\tq[++tt] = i;\n\t\t\tf[i] = 1; \n\t\t}\n\t}\n\t\n\twhile(hh &lt;= tt)\n\t{\n\t\tint t = q[hh++];\n\t\t\n\t\tfor(int i = h[t]; i!= -1 ; i = ne[i])\n\t\t{\n\t\t\tint j = e[i];\n\t\t\td[j]--;\n\t\t\tf[j] = (f[j] + f[t]) % mod;\n\t\t\t\n\t\t\tif(d[j] == 0)q[++tt] = j; \t\t\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&amp;n,&amp;m);\n\t\n\tmemset(h,-1,sizeof h);\n\t\t\n\tfor(int i = 1 ;i&lt;= m ;i ++)\n\t{\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&amp;a,&amp;b);\n\t\tadd(a,b);\n\t\td[b]++,c[a]++;\n\t}\n\t\n\ttopsort();\n\t\n\tint res = 0;\n\t\n\tfor(int i = 1; i&lt;= n ;i++)\n\t{\n\t\tif(!c[i])\n\t\t{\n\t\t\tres = (res + f[i]) % mod;\n\t\t}\n\t}\n\tprintf(\"%d\",res);\n\t\n\treturn 0;\n} \n</code></pre>\n<p><a href=\"https://www.luogu.com.cn/problem/P1137\" title=\"旅行计划 - 洛谷\">旅行计划 - 洛谷</a></p>\n<blockquote>\n<p>这个题，我们根据题意是不是知道这个是一个DAG，我们需要计算的是以城市 i 为终点最多能够游览多少个城市；这个是不是也是在一个拓扑序上做一个简单的dp就行了，我们记录一下最大值即可；</p>\n</blockquote>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;cmath&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\n#include&lt;unordered_map&gt;\n#define x first\n#define y second \n#define _for(i,s,t) for(int i = (s);i &lt;=t ; i++)\n#define FAST ios::sync_with_stdio(false); cin.tie(0);cout.tie(0);\n\nusing namespace std;\n\ntypedef unsigned long long ULL;\ntypedef long long LL;\ntypedef pair&lt;int,int&gt; PII;\n\nconst int N = 100010,M = 2 * N ,INF = 0x3f3f3f3f;\n\nint n,m;\n\nint h[N],e[M],ne[M],idx;\n\nint d[N],q[N],f[N];\n\nint hh = 0, tt = -1;\n\nvoid add(int a,int b)\n{\n\te[idx] = b;\n\tne[idx] = h[a];\n\th[a] = idx ++;\n} \n\nvoid topsort()\n{\n\tfor(int i =1 ;i&lt;= n ;i ++)\n\t{\n\t\tif(!d[i])\n\t\t{\n\t\t\tq[++tt] = i;\n\t\t\tf[i] = 1;\n\t\t}\n\t}\n\t\n\twhile(hh &lt;= tt)\n\t{\n\t\tint t = q[hh++];\n\t\t\n\t\tfor(int i =h[t]; i != -1 ;i = ne[i])\n\t\t{\n\t\t\tint j = e[i];\n\t\t\tf[j] = max(f[j] , f[t] + 1);\n\t\t\td[j]--;\n\t\t\tif(d[j] == 0)q[++tt] = j;\n\t\t}\n\t}\n\t\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&amp;n,&amp;m);\n\t\n\tmemset(h,-1,sizeof h);\n\t \n\tfor(int i = 1;i &lt;= m ;i ++)\n\t{\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&amp;a,&amp;b);\n\t\tadd(a,b);\n\t\td[b] ++;\n\t}\n\t\n\ttopsort();\n\t\n\t\n\tfor(int i =1; i&lt;= n; i++)\n\t{\n\t\tprintf(\"%d\\n\",f[i]);\n\t}\n\t\n\treturn 0;\n} </code></pre>\n</div>\n</div>"}