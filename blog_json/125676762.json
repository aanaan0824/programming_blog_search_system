{"blogid": "125676762", "writerAge": "码龄7年", "writerBlogNum": "131", "writerCollect": "235", "writerComment": "24", "writerFan": "23", "writerGrade": "5级", "writerIntegral": "3114", "writerName": "勤天", "writerProfileAdress": "writer_image\\profile_125676762.jpg", "writerRankTotal": "12403", "writerRankWeekly": "48181", "writerThumb": "59", "writerVisitNum": "256291", "blog_read_count": "573", "blog_time": "于 2022-07-08 13:45:59 发布", "blog_title": "PHP+Redis实现分布式锁", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E4%B8%80%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%A6%82%E8%BF%B0-toc\" style=\"margin-left:40px;\"><a href=\"#%E4%B8%80%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%A6%82%E8%BF%B0\">一、分布式锁概述</a></p>\n<p id=\"%E4%BA%8C%E3%80%81redis%E5%AE%9E%E7%8E%B0%E9%94%81%E7%9A%84%E5%91%BD%E4%BB%A4-toc\" style=\"margin-left:40px;\"><a href=\"#%E4%BA%8C%E3%80%81redis%E5%AE%9E%E7%8E%B0%E9%94%81%E7%9A%84%E5%91%BD%E4%BB%A4\">二、redis实现锁的命令</a></p>\n<p id=\"1%E3%80%81redis%E5%AE%9E%E7%8E%B0%E9%94%81%E7%9A%84%E5%91%BD%E4%BB%A4-toc\" style=\"margin-left:80px;\"><a href=\"#1%E3%80%81redis%E5%AE%9E%E7%8E%B0%E9%94%81%E7%9A%84%E5%91%BD%E4%BB%A4\">1、redis实现锁的命令</a></p>\n<p id=\"3%E3%80%81%E9%87%8A%E6%94%BE%E9%94%81%E7%9A%84%E6%AD%A5%E9%AA%A4-toc\" style=\"margin-left:80px;\"><a href=\"#3%E3%80%81%E9%87%8A%E6%94%BE%E9%94%81%E7%9A%84%E6%AD%A5%E9%AA%A4\">3、释放锁的步骤</a></p>\n<p id=\"%E4%B8%89%E3%80%81PHP%2Bredis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%A4%BA%E4%BE%8B-toc\" style=\"margin-left:40px;\"><a href=\"#%E4%B8%89%E3%80%81PHP%2Bredis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%A4%BA%E4%BE%8B\">三、PHP+redis分布式锁示例</a></p>\n<p id=\"%E5%9B%9B%E3%80%81redis%E9%9B%86%E7%BE%A4%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%9B%9B%E3%80%81redis%E9%9B%86%E7%BE%A4%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81\">四、redis集群分布式锁</a></p>\n<p id=\"-toc\" style=\"margin-left:80px;\"></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h2>一、分布式锁概述</h2>\n<p></p>\n<p>        在分布式环境下，各个线程通过对公共资源的抢占，能够使一个代码块在同一时间只能被一个机器的一个线程执行，这个机制就是分布式锁。</p>\n<p>        分布式锁主要用于在分布式环境中保护跨进程、跨主机、跨网络的共享资源实现互斥访问，以达到保证数据的一致性</p>\n<p>实现锁的操作主要有两个，即lock()和unlock()。</p>\n<p></p>\n<p>分布式锁实现的注意点：</p>\n<p>1）互斥: 任意时刻, 只能有一个客户端获得锁</p>\n<p>2）不会死锁: 客户端持有锁期间崩溃, 没有主动解除锁, 能保证后续的其他客户端获得锁</p>\n<p>3）锁归属标识: 加锁和解锁的必须是同一个客户端, 客户端不能解掉非自己持有的锁(锁应具备标识)</p>\n<p>4）如果是Redis集群, 还得考虑具有容错性: 只要大部分Redis节点正常运行, 客户端就可以加锁和解锁.</p>\n<p></p>\n<h2 id=\"%E4%BA%8C%E3%80%81redis%E5%AE%9E%E7%8E%B0%E9%94%81%E7%9A%84%E5%91%BD%E4%BB%A4\">二、redis实现锁的命令</h2>\n<p></p>\n<h3 id=\"1%E3%80%81redis%E5%AE%9E%E7%8E%B0%E9%94%81%E7%9A%84%E5%91%BD%E4%BB%A4\">1、redis实现锁的命令</h3>\n<p></p>\n<pre><code>set key value NX EX</code></pre>\n<p>\"NX\" 仅在key不存在时加锁, 满足条件1: 互斥型</p>\n<p>\"EX\" 设置锁过期时间(秒）, 满足条件2: 避免死锁</p>\n<p></p>\n<p>上面这个set命令拆解开就是：</p>\n<pre><code>setnx cache_key random_value \nexpire cache_key 30</code></pre>\n<p>虽然这两组命令执行的效果一样，但是第二个是非原子性操作，如果执行了setnx成功，但是expire失败的话，就会造成这个key一直存在了，无法释放的情况（死锁）。</p>\n<p></p>\n<p>2、使用随机数增加锁标识</p>\n<pre><code class=\"language-php\">public function lock(){\n    // 生成随机值\n    $this-&gt;lockValue = md5(uniqid());\n    return $this-&gt;redis-&gt;set($this-&gt;scene, $this-&gt;lockValue , ['NX', 'EX' =&gt; $this-&gt;expire]);\n}</code></pre>\n<p>使用锁标识（增加随机数）的原因：避免某个客户端获取锁后做其他操作过久而导致锁被自动释放，但该客户端以为还获得锁，这时假设其他客户端获取了锁，但上个客户端删除锁继而导致本客户端的锁被删除，总而言之客户端只能删除自己的锁，通过锁标识进行判断</p>\n<p></p>\n<h3 id=\"3%E3%80%81%E9%87%8A%E6%94%BE%E9%94%81%E7%9A%84%E6%AD%A5%E9%AA%A4\">3、释放锁的步骤</h3>\n<p></p>\n<ul><li>get 所持有锁</li><li>判断这个锁是否自己所持有</li><li>删除持有锁</li></ul>\n<p></p>\n<p>所以，这三步要保证原子性，用lua脚本来执行，redis官方已经提供脚本文件。</p>\n<p></p>\n<pre><code class=\"language-php\">if redis.call(\"get\",KEYS[1]) == ARGV[1] then\n  return redis.call(\"del\",KEYS[1])\nelse\n  return 0\nend</code></pre>\n<p>       <span style=\"color:#fe2c24;\"> lua 脚本中执行 get 和 del 是原子性的, 整个lua脚本会被当做一条命令来执行，即使 get 后锁刚好过期, 此时也不会被其他客户端加锁，直到eval命令执行完成，Redis才会执行其他命令。</span>如果不用原子性，还是会导致该锁被其他客户端获得，但上客户端已经判断过（自己所持有），进一步会删除该锁。</p>\n<p></p>\n<pre><code class=\"language-php\">/**\n * 解锁\n */\npublic function unLock(){\n    $script = &lt;&lt;&lt;LUA\n        local key=KEYS[1]\n        local value=ARGV[1]\n        if(redis.call('get', key) == value)\n        then\n            return redis.call('del', key)\n        end\n    LUA;\n    \n    // 执行lua脚本\n    $this-&gt;redis-&gt;eval($script, [$this-&gt;scene, $this-&gt;lockValue], 1);\n}</code></pre>\n<p></p>\n<p>eval方法的参数 3个，第一个是脚本代码（具体执行的代码），第二个是一个数组，参数数组，第三个参数是个整数，表示第key参数的数量，lua代码中的KEYS数量（不包括ARGV数量）</p>\n<p></p>\n<h2 id=\"%E4%B8%89%E3%80%81PHP%2Bredis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%A4%BA%E4%BE%8B\">三、PHP+redis分布式锁示例</h2>\n<p></p>\n<pre><code class=\"language-php\">&lt;?php\n\n/**\n * redis 分布式锁\n */\n\nclass Lock{\n\n    private $config;\n    private $redis;\n\n    public function __construct($config = []){\n        $this-&gt;config = $config ? $config : ['host' =&gt; '127.0.0.1', 'port' =&gt; 6379];\n        $this-&gt;redis = $this-&gt;connect();\n    }\n\n    public function connect(){\n        $redis = new Redis();\n        $redis-&gt;connect($this-&gt;config['host'], $this-&gt;config['port']);\n        return $redis;\n    }\n\n    /**\n     * @param $scene 锁场景\n     * @param $expire 锁有效期\n     * @return bool\n     */\n    public function lock($scene = null , $expire = 10){\n        if (!$scene || !$expire){\n            return false;\n        }\n\n        // 生成随机值，锁标识\n        $lockId = md5(uniqid());\n        $result = $this-&gt;redis-&gt;set($scene, $lockId, ['NX', 'EX' =&gt; $expire]) ;\n\n        if($result)\n            return $lockId;\n        else\n            return $result;\n    }\n\n    /**\n     * 解锁\n     */\n    public function unLock($scene, $lockId){\n\n        $lua = &lt;&lt;&lt;SCRIPT\n       local key=KEYS[1]\n            local value=ARGV[1]\n            if(redis.call('get', key) == value)\n            then\n                return redis.call('del', key)\n            end\nSCRIPT;\n        // 执行lua脚本\n        return $this-&gt;redis-&gt;eval($lua, [$scene, $lockId], 1);\n    }\n}\n\n\n$lock = new Lock();\n\n第一次加锁\n$res = $lock-&gt;Lock(\"test\", 30);\nvar_dump($res); // 返回lockId\n\necho \"&lt;br&gt;\";\n\n第二次加锁\n$res1 = $lock-&gt;Lock(\"test\", 25);\nvar_dump($res1); //加锁失败 false\n\n//解锁\nif($res){\n    $lock -&gt; unLock(\"test\", $res);\n}</code></pre>\n<p></p>\n<p></p>\n<h2 id=\"%E5%9B%9B%E3%80%81redis%E9%9B%86%E7%BE%A4%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81\">四、redis集群分布式锁</h2>\n<p></p>\n<p>Redis 集群相对单机来说, 需要考虑一个 容错性, 设计上更为复杂</p>\n<p></p>\n<p>RedLock 算法：官方给出了一个 RedLock 算法</p>\n<p>情景: 当前有N个完全独立的Redis master节点, 分别部署在不同的主机上</p>\n<p>客户端获取锁的操作:</p>\n<ol><li>使用相同key和唯一值(作为value)同时向这N个redis节点请求锁, 锁的超时时间应该 &gt;&gt; 超时时间(考虑到请求耗时), 若某个节点阻塞了了应尽快跳过</li><li>计算步骤1消耗的时间, 若总消耗时间超过超时时间, 则认为锁失败. 客户端需在大多数(超过一半)的节点上成功获取锁, 才认为是锁成功.</li><li>如果锁成功了, 则该锁有效时间就是 锁原始有效时间 - 步骤1消耗的时间</li><li>如果锁失败了(超时或无法获取超过一半 N/2 + 1 实例的锁), 客户端会到每个节点释放锁(是每个, 即使之前认为加锁失败的节点)</li></ol>\n<p></p>\n<h3></h3>\n<p></p>\n</div>\n</div>"}