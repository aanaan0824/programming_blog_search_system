{"blogid": "123391835", "writerAge": "码龄6年", "writerBlogNum": "20", "writerCollect": "754", "writerComment": "96", "writerFan": "64", "writerGrade": "4级", "writerIntegral": "913", "writerName": "无枫丶", "writerProfileAdress": "writer_image\\profile_123391835.jpg", "writerRankTotal": "22282", "writerRankWeekly": "83637", "writerThumb": "193", "writerVisitNum": "180480", "blog_read_count": "7506", "blog_time": "于 2022-03-10 08:15:23 发布", "blog_title": "Elasticsearch8.0版本中Elasticsearch Java API Client客户端的基本使用方法", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<blockquote>\n<p>关于Elasticsearch Java API Client客户端如何连接以及如何对索引和文档进行基本的增删改查操作请查看我的上一篇博文：<a href=\"https://blog.csdn.net/anjiongyi/article/details/123328856\" title=\"Elasticsearch RestHighLevelClient 已标记为被弃用 它的替代方案 Elasticsearch Java API Client 的基础教程及迁移方案_无枫的博客，分享Java及Vue方向的技术文章-CSDN博客\">Elasticsearch RestHighLevelClient 已标记为被弃用 它的替代方案 Elasticsearch Java API Client 的基础教程及迁移方案_无枫的博客，分享Java及Vue方向的技术文章-CSDN博客</a></p>\n</blockquote>\n<p> 本篇主要描述在Elasticsearch Java API Client客户端中如何进行批量操作，以及如何进行各种条件及类型的查询（Search）方法。</p>\n<p></p>\n<h1>1. 批量添加文档</h1>\n<pre><code class=\"language-java\">// 创建客户端连接部分\nRestClient restClient = RestClient.builder(\n        new HttpHost(\"localhost\", 9200)).build();\nElasticsearchTransport transport = new RestClientTransport(\n        restClient, new JacksonJsonpMapper());\nElasticsearchClient client = new ElasticsearchClient(transport);\n\n// 构建一个批量操作BulkOperation的集合\nList&lt;BulkOperation&gt; bulkOperations = new ArrayList&lt;&gt;();\n// 向集合添加数据\nbulkOperations.add(new BulkOperation.Builder().create(d-&gt; d.document(new Test(\"zhangsan\", \"男\", 30)).id(\"3001\").index(\"newapi\")).build());\nbulkOperations.add(new BulkOperation.Builder().create(d-&gt; d.document(new Test(\"lisi\", \"女\", 30)).id(\"3002\").index(\"newapi\")).build());\nbulkOperations.add(new BulkOperation.Builder().create(d-&gt; d.document(new Test(\"wangwu\", \"男\", 40)).id(\"3003\").index(\"newapi\")).build());\nbulkOperations.add(new BulkOperation.Builder().create(d-&gt; d.document(new Test(\"wangwu1\", \"女\", 40)).id(\"3004\").index(\"newapi\")).build());\nbulkOperations.add(new BulkOperation.Builder().create(d-&gt; d.document(new Test(\"wangwu2\", \"男\", 50)).id(\"3005\").index(\"newapi\")).build());\nbulkOperations.add(new BulkOperation.Builder().create(d-&gt; d.document(new Test(\"wangwu3\", \"男\", 50)).id(\"3006\").index(\"newapi\")).build());\nbulkOperations.add(new BulkOperation.Builder().create(d-&gt; d.document(new Test(\"wangwu33\", \"男\", 50)).id(\"3007\").index(\"newapi\")).build());\nbulkOperations.add(new BulkOperation.Builder().create(d-&gt; d.document(new Test(\"wangwu333\", \"男\", 50)).id(\"3008\").index(\"newapi\")).build());\n// 使用bulk方法执行批量操作并获得响应\nBulkResponse response = client.bulk(e-&gt;e.index(\"newapi\").operations(bulkOperations));\n// 打印结果\nSystem.out.println(response.took());\nSystem.out.println(response.items());\n\n// 关闭客户端连接部分\ntransport.close();\nrestClient.close();</code></pre>\n<p>首先需要创建ES客户端连接，然后构建一个批量操作BulkOperation的ArrayList集合，并向其添加你需要插入的文档数据，这里新版客户端可以直接传入Java对象，ES会在内部自行处理。</p>\n<p>使用ES客户端的bulk方法进行批量操作并获得批量操作的响应结果，最后打印出结果即可。</p>\n<p></p>\n<h1>2. 批量删除文档</h1>\n<pre><code class=\"language-java\">// 创建ES客户端部分\nRestClient restClient = RestClient.builder(\n        new HttpHost(\"localhost\", 9200)).build();\nElasticsearchTransport transport = new RestClientTransport(\n        restClient, new JacksonJsonpMapper());\nElasticsearchClient client = new ElasticsearchClient(transport);\n\n// 构建批量操作对象BulkOperation的集合\nList&lt;BulkOperation&gt; bulkOperations = new ArrayList&lt;&gt;();\n\n// 向集合中添加需要删除的文档id信息\nbulkOperations.add(new BulkOperation.Builder().delete(d-&gt; d.index(\"newapi\").id(\"3001\")).build());\nbulkOperations.add(new BulkOperation.Builder().delete(d-&gt; d.index(\"newapi\").id(\"3002\")).build());\nbulkOperations.add(new BulkOperation.Builder().delete(d-&gt; d.index(\"newapi\").id(\"3003\")).build());\n\n// 调用客户端的bulk方法，并获取批量操作响应结果\nBulkResponse response = client.bulk(e-&gt;e.index(\"newapi\").operations(bulkOperations));\nSystem.out.println(response.took());\nSystem.out.println(response.items());\n\n// 关闭ES客户端部分\ntransport.close();\nrestClient.close();</code></pre>\n<p>与批量添加文档类似，首先需要创建ES客户端，同样使用BulkOperation集合来存储批量操作的内容，不同的是这次使用BulkOperationBuilder的delete方法构建批量删除操作，最后调用ES客户端的bulk方法执行，获取的响应结果同样为BulkResponse类型。</p>\n<h1>3. 分页查询</h1>\n<pre><code class=\"language-java\">// 分页查询\nSearchResponse&lt;Test&gt; response3 = client.search(s -&gt; s\n                .index(\"newapi\")\n                .query(q -&gt; q\n                        .matchAll(m -&gt; m)\n                )\n                .from(4)\n                .size(2)\n        , Test.class);\nSystem.out.println(response3.took());\nSystem.out.println(response3.hits().total().value());\nresponse3.hits().hits().forEach(e -&gt; System.out.println(e.source().toString()));</code></pre>\n<p>Elasticsearch Java API Client客户端中的分页查询主要使用SearchResponse的from和size方法传入参数，其中from代表数据开始的下表位置，size代表每次查询需要获取到的文档数量。</p>\n<p></p>\n<h1>4. 查询排序</h1>\n<pre><code class=\"language-java\">// 查询排序\nSearchResponse&lt;Test&gt; response4 = client.search(s -&gt; s\n                .index(\"newapi\")\n                .query(q -&gt; q\n                        .matchAll(m -&gt; m)\n                )\n                .sort(sort -&gt; sort\n                        .field(f -&gt; f\n                                .field(\"age\")\n                                .order(SortOrder.Desc)\n                        )\n                )\n        , Test.class);\nSystem.out.println(response4.took());\nSystem.out.println(response4.hits().total().value());\nresponse4.hits().hits().forEach(e -&gt; System.out.println(e.source().toString()));</code></pre>\n<p>Elasticsearch Java API Client客户端中的查询排序主要使用sort方法传入排序参数，我这里使用了lambda形式传入参数。与RestAPI一致，需要传入field名称以及排序方式，如ASC、DESC。</p>\n<h1>5. 过滤字段</h1>\n<pre><code class=\"language-java\">// 过滤字段\nSearchResponse&lt;Test&gt; response5 = client.search(s -&gt; s\n                .index(\"newapi\")\n                .query(q -&gt; q\n                        .matchAll(m -&gt; m)\n                )\n                .sort(sort -&gt; sort\n                        .field(f -&gt; f\n                                .field(\"age\")\n                                .order(SortOrder.Desc)\n                        )\n                )\n                .source(source -&gt; source\n                                .filter(f -&gt; f\n                                  .includes(\"name\")\n                                  .excludes(\"\")\n                                )\n                )\n        , Test.class);\nSystem.out.println(response5.took());\nSystem.out.println(response5.hits().total().value());\nresponse5.hits().hits().forEach(e -&gt; System.out.println(e.source().toString()));</code></pre>\n<p>Elasticsearch Java API Client客户端中的过滤字段同样使用source传入参数，与RestAPI相同，使用includes和excludes来标记白名单或黑名单模式，其中includes代表白名单，只返回指定的字段。excludes代表黑名单，不返回指定的字段。</p>\n<h1>7. 组合查询</h1>\n<pre><code class=\"language-java\">// 组合查询\nSearchResponse&lt;Test&gt; response6 = client.search(s -&gt; s\n                .index(\"newapi\")\n                .query(q -&gt; q\n                        .bool(b -&gt; b\n                                .must(must -&gt; must\n                                        .match(m -&gt; m\n                                                .field(\"age\")\n                                                .query(30)\n                                        )\n                                )\n                                .must(must -&gt; must\n                                        .match(m -&gt; m\n                                                .field(\"sex\")\n                                                .query(\"男\")\n                                        )\n                                )\n                                .should(should -&gt; should\n                                        .match(m -&gt; m\n                                                .field(\"age\")\n                                                .query(30)\n                                        )\n                                )\n                                .should(should -&gt; should\n                                        .match(m -&gt; m\n                                                .field(\"age\")\n                                                .query(40)\n                                        )\n                                )\n                        )\n                )\n        , Test.class);\nSystem.out.println(response6.took());\nSystem.out.println(response6.hits().total().value());\nresponse6.hits().hits().forEach(e -&gt; System.out.println(e.source().toString()));</code></pre>\n<p>Elasticsearch Java API Client客户端中的组合查询，与RestAPI保持一直，使用bool下的must或should来代表必须满足某条件或只需满足某条件。</p>\n<h1>8. 范围查询</h1>\n<pre><code class=\"language-java\">// 范围查询\nSearchResponse&lt;Test&gt; response7 = client.search(s -&gt; s\n                .index(\"newapi\")\n                .query(q -&gt; q\n                        .range(r -&gt; r\n                                .field(\"age\")\n                                .gte(JsonData.of(30))\n                                .lt(JsonData.of(40))\n                        )\n                )\n        , Test.class);\nSystem.out.println(response7.took());\nSystem.out.println(response7.hits().total().value());\nresponse7.hits().hits().forEach(e -&gt; System.out.println(e.source().toString()));</code></pre>\n<p>Elasticsearch Java API Client客户端中的范围查询，与组合查询不同的是，使用了range而不是bool。field参数代表需要判断的字段，ge、gte、lt、lte分别代表大于、大于等于、小于、小于等于。</p>\n<h1>9. 模糊查询</h1>\n<pre><code class=\"language-java\">// 模糊查询\nSearchResponse&lt;Test&gt; response8 = client.search(s -&gt; s\n                .index(\"newapi\")\n                .query(q -&gt; q\n                        .fuzzy(f -&gt; f\n                                .field(\"name\")\n                                .value(\"wangwu\")\n                                .fuzziness(\"1\"))\n                )\n        , Test.class);\nSystem.out.println(response8.took());\nSystem.out.println(response8.hits().total().value());\nresponse8.hits().hits().forEach(e -&gt; System.out.println(e.source().toString()));</code></pre>\n<p>Elasticsearch Java API Client客户端中的模糊查询，使用fuzzy而不是like，其中field代表需要判断的字段名称，value代表需要模糊查询的关键词，fuzziness代表可以与关键词有误差的字数，可选值为0、1、2这三项。</p>\n<h1>10. 高亮查询</h1>\n<pre><code class=\"language-java\">// 高亮查询\nSearchResponse&lt;Test&gt; response9 = client.search(s -&gt; s\n                .index(\"newapi\")\n                .query(q -&gt; q\n                        .term(t -&gt; t\n                                .field(\"name\")\n                                .value(\"wangwu\")\n                        )\n                )\n                .highlight(h -&gt; h\n                        .fields(\"name\", f -&gt; f\n                                .preTags(\"&lt;font color='red'&gt;\")\n                                .postTags(\"&lt;/font&gt;\")\n                        )\n                )\n        , Test.class);\nSystem.out.println(response9.took());\nSystem.out.println(response9.hits().total().value());\nresponse9.hits().hits().forEach(e -&gt; {\n    System.out.println(e.source().toString());\n    for (Map.Entry&lt;String, List&lt;String&gt;&gt; entry : e.highlight().entrySet()) {\n        System.out.println(\"Key = \" + entry.getKey());\n        entry.getValue().forEach(System.out::println);\n    }\n});</code></pre>\n<p>Elasticsearch Java API Client客户端中的高亮查询，主要用于给查询出的关键词添加一个标识符，便于前端展示。使用highlight字段，其中fields的key代表需要标记的字段名称，preTags代表需要添加标记的前缀，postTags代表需要添加标记的后缀。同时响应的获取方式也有所改变，具体可以参照上述代码。</p>\n<h1>11. 聚合查询</h1>\n<pre><code class=\"language-java\">// 聚合查询\nSearchResponse&lt;Test&gt; response10 = client.search(s -&gt; s\n                .index(\"newapi\")\n                .aggregations(\"maxAge\", a -&gt; a\n                        .max(m -&gt; m\n                                .field(\"age\")\n                        )\n                )\n        , Test.class);\nSystem.out.println(response10.took());\nSystem.out.println(response10.hits().total().value());\nresponse10.hits().hits().forEach(e -&gt; {\n    System.out.println(e.source().toString());\n});\nfor (Map.Entry&lt;String, Aggregate&gt; entry : response10.aggregations().entrySet()) {\n    System.out.println(\"Key = \" + entry.getKey() + \", Value = \" + entry.getValue().max().value());\n}</code></pre>\n<p>Elasticsearch Java API Client客户端中的聚合查询，主要用于数据的统计，这里演示一下获取最大值。首先使用的是aggregations方法，aggregations方法的key可以自行起名，max代表最大值，可以参照api获取更多的查询方式，这里只演示下max方法，其他方法与其类似。field代表需要获取最大值的字段名称。响应的获取方式也有所不同，需要拿到响应中的aggregations参数，我这里直接进行Map循环以获取统计出的最大值数据。</p>\n<h1>12. 分组查询</h1>\n<pre><code class=\"language-java\">// 分组查询\nSearchResponse&lt;Test&gt; response11 = client.search(s -&gt; s\n                .index(\"newapi\")\n                .size(100)\n                .aggregations(\"ageGroup\", a -&gt; a\n                        .terms(t -&gt; t\n                                .field(\"age\")\n                        )\n                )\n        , Test.class);\nSystem.out.println(response11.took());\nSystem.out.println(response11.hits().total().value());\nresponse11.hits().hits().forEach(e -&gt; {\n    System.out.println(e.source().toString());\n});\nAggregate aggregate = response11.aggregations().get(\"ageGroup\");\nLongTermsAggregate lterms = aggregate.lterms();\nBuckets&lt;LongTermsBucket&gt; buckets = lterms.buckets();\nfor (LongTermsBucket b : buckets.array()) {\n    System.out.println(b.key() + \" : \" + b.docCount());\n}</code></pre>\n<p>Elasticsearch Java API Client客户端中的分组查询，也是属于聚合查询的一部分，所以同样使用aggregations方法，并使用terms方法来代表分组查询，field传入需要分组的字段，最后通过响应中的aggregations参数来获取，这里需要根据数据的类型来获取最后的分组结果，我这里因为统计的是数字类型，所以使用LongTermsAggregate来获取结果，最后打印出docCount属性即可。</p>\n</div>\n</div>"}