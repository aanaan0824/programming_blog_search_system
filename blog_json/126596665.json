{"blogid": "126596665", "writerAge": "码龄2年", "writerBlogNum": "93", "writerCollect": "5012", "writerComment": "5432", "writerFan": "4920", "writerGrade": "7级", "writerIntegral": "13448", "writerName": "一名不会打字的程序员", "writerProfileAdress": "writer_image\\profile_126596665.jpg", "writerRankTotal": "786", "writerRankWeekly": "73", "writerThumb": "5234", "writerVisitNum": "78453", "blog_read_count": "1566", "blog_time": "已于 2022-08-30 09:51:39 修改", "blog_title": "【C++难点收录】“为什么C++难，你真的理解了这些吗？”《常见面试题》", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-github-gist\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p><img alt=\"在这里插入图片描述\" src=\"https://img-blog.csdnimg.cn/f7f5e8f696074d79bb7c7cfaab2ea5d2.gif#pic_center\"/></p>\n<blockquote>\n<p>🐧<strong>主页详情</strong>：<a href=\"https://blog.csdn.net/weixin_51568389?spm=1011.2435.3001.5343\">个人主页</a><br/> 📢<strong>作者简介</strong>：🏅物联网领域创作者🏅 and 🏅阿里专家博主🏅 and 🏅华为云享专家🏅<br/> ✍️<strong>人生格言</strong>：最慢的步伐不是跬步，而是徘徊；最快的脚步不是冲刺，而是坚持。<br/> 🧑‍💻<strong>人生目标</strong>：成为一名合格的程序员，做未完成的梦：实现财富自由。<br/> 🚩<strong>技术方向</strong>：NULL<br/> 🀄如果觉得博主的文章还不错的话，请三连支持一下博主哦<br/> 💬给大家介绍一个我一直在用的求职刷题收割offe👉<a href=\"https://www.nowcoder.com/link/pc_csdncpt_choice_c\">点击进入网站</a></p>\n</blockquote>\n<blockquote>\n<p>🏫<strong>系列专栏</strong>(<strong>免费</strong>)：<br/> 1️⃣ <a href=\"https://blog.csdn.net/weixin_51568389/category_11830402.html\">C语言进阶</a><br/> 2️⃣ <a href=\"https://blog.csdn.net/weixin_51568389/category_11816257.html\">数据结构与算法(C语言版)</a><br/> 3️⃣ <a href=\"https://blog.csdn.net/weixin_51568389/category_11846393.html\">Linux宝典</a><br/> 4️⃣ <a href=\"https://blog.csdn.net/weixin_51568389/category_11913272.html\">C++从入门到精通</a><br/> 5️⃣ <a href=\"https://blog.csdn.net/weixin_51568389/category_11849487.html?spm=1001.2014.3001.5482\">C++从入门到实战</a><br/> 6️⃣ <a href=\"https://blog.csdn.net/weixin_51568389/category_11865484.html\">JavaScript从入门到精通</a><br/> 7️⃣<a href=\"https://blog.csdn.net/weixin_51568389/category_11855792.html\">101算法JavaScript描述</a><br/> 8️⃣<a href=\"https://blog.csdn.net/weixin_51568389/category_11919872.html\">微信小程序零基础开发</a><br/> 9️⃣<a href=\"https://blog.csdn.net/weixin_51568389/category_11908469.html?spm=1001.2014.3001.5482\">牛客网刷题笔记</a><br/> 🔟<a href=\"https://blog.csdn.net/weixin_51568389/category_11950200.html\">计算机行业知识(补充)</a></p>\n</blockquote>\n<p></p>\n<div class=\"toc\">\n<h3>文章目录</h3>\n<ul><li><a href=\"#_24\">前言</a></li><li><a href=\"#_27\">类与对象</a></li><li><ul><li><a href=\"#this_33\">隐含this指针</a></li><li><a href=\"#_95\">构造函数和析构函数</a></li><li><a href=\"#_127\">拷贝构造</a></li></ul>\n</li><li><a href=\"#_196\">内存管理</a></li><li><ul><li><a href=\"#operator_newoperator_delete_265\">operator new和operator delete函数</a></li></ul>\n</li><li><a href=\"#_314\">模板</a></li><li><ul><li><a href=\"#_431\">引用的奇淫飞技</a></li></ul>\n</li><li><a href=\"#string_437\">string</a></li><li><ul><li><a href=\"#string_439\">模仿实现string</a></li></ul>\n</li><li><a href=\"#_715\">面试题</a></li></ul>\n</div>\n<p></p>\n<h1><a id=\"_24\"></a>前言</h1>\n<blockquote>\n<p>众所周知，C++为什么会难，到底难在哪里？小编通过本文告诉你；坑已填好，欢迎路过。</p>\n</blockquote>\n<h1><a id=\"_27\"></a>类与对象</h1>\n<p>临时变量具有常性（函数，引用）</p>\n<p>内联函数没有地址</p>\n<h2><a id=\"this_33\"></a>隐含this指针</h2>\n<pre><code class=\"prism language-c++\">class Data\n{\nvoid Init(int year=0,int month=3,int day=4)\n    {\n      _year=year;\n        _month=month;\n        _day=day;\n        \n        //类似于\n        this-&gt;_year=year;\n        this-&gt;_month=month;\n        this-&gt;_day=day;\n    }\n    \n};\n</code></pre>\n<p>this指针存在栈上，因为它是一个形参</p>\n<p><img alt=\"image-20220822080811313\" src=\"image\\f2f91225783946d5c9872e6c090e2924.png\"/></p>\n<pre><code class=\"prism language-c++\">#include&lt;iostream&gt;\nusing namespace std;\n\nclass A\n{\npublic:\n  \n\tvoid print()\n\t{\n\t\tcout &lt;&lt; _a2 &lt;&lt; endl;//this-&gt;_a2\n\t}\n\tvoid show()\n\t{\n\t\tcout &lt;&lt; \"show()\"&lt;&lt;endl;\n\t}\nprivate:\n\tint _a2;\n};\n\nint main()\n{\n\n\tA *p = NULL;//p-&gt;print(p);\n\tp-&gt;print();//这一行会引发什么？编译不通过？程序崩溃？正常运行？//崩溃\n\tp-&gt;show();//这一行会引发什么？编译不通过？程序崩溃？正常运行？//正常运行\n\t//成员函数存在公共的代码段，所以p-&gt;show()这里不会取p指向的对象上找\n\t//访问成员函数，才会去找\n\n\tA a;\n\ta.print();//p-&gt;print(&amp;a);\n\n\treturn 0;\n}\n</code></pre>\n<h2><a id=\"_95\"></a>构造函数和析构函数</h2>\n<pre><code class=\"prism language-c++\">Date d1;//我们不写编译器生成 2，全缺省的 3.无参数的  -》 默认构造函数 -》不传参数可以调用的\n</code></pre>\n<p>我们不写，编译器生成构造函数和析构函数</p>\n<p>内置类型/基本类型 （int/char）不会处理</p>\n<p>自定义类型 调用它的构造函数初始化/析构函数(new /delete)</p>\n<pre><code class=\"prism language-c++\">class Time\n{\n\t~Time()\n\t{\n\t\n\t}\n};\nclass Date\n{\nprivate:\n\tint _size;\n\tint _capaciti;\n\t\n\tTime _t;//自定义类型\n\n};\n\n</code></pre>\n<h2><a id=\"_127\"></a>拷贝构造</h2>\n<pre><code class=\"prism language-c++\">#include&lt;iostream&gt;\nusing namespace std;\n\nclass Date\n{ \npublic:\n\tDate(int year = 0, int month = 3, int day = 4)\n\t{\n\t\t_year = year;\n\t\t_month = month;\n\t\t_day = day;\n\t}\n    //err\n\t/*Date(Date d2)\n\t{\n\t\t_year = d2._year;\n\t\t_month = d2._month;\n\t\t_day = d2._day;\n\t}*/\nprivate:\n\tint _year;\n\tint _month;\n\tint _day;\n};\nint main()\n{\n\n\tDate d1(2022,10,10);\n\t\n    //这两个写法都调用拷贝构造\n\tDate d2(d1);//调用拷贝构造\n\tDate d3 = d2;\n    \n\treturn 0;\n}\n</code></pre>\n<p><img alt=\"image-20220822102953807\" src=\"image\\06569510c0184c83f7b971e325cdc9bd.png\"/></p>\n<p>有三种传参方式：</p>\n<ol><li>传值（d2）传参需要拷贝构造，然后拷贝的时候会发生递归，不会构造</li><li>传址（*d2）</li><li>传引用（&amp;d2）会直接构造，因为引用是它的别名，直接进入了</li></ol>\n<p>建议：传入引用</p>\n<pre><code class=\"prism language-c++\">\tDate(Date&amp; d2)//类似于 Date &amp;d2=d1;\n\t{\n\t\t_year = d2._year;\n\t\t_month = d2._month;\n\t\t_day = d2._day;\n\t}\n</code></pre>\n<p>然后我们把赋值反过来：<code>d2._day=__day;</code>编译运行通过了</p>\n<p><img alt=\"image-20220822104700034\" src=\"image\\4a7fdd986b5380166d847262afde0772.png\"/></p>\n<p>这是因为我们把未初始的_day赋值给了d2，未初始化都是随机值，这里也是引用，改变了原有的值，所以需要加上<strong>const</strong>防止改变</p>\n<pre><code class=\"prism language-c++\">Date(const Date&amp; d2)\n</code></pre>\n<h1><a id=\"_196\"></a>内存管理</h1>\n<pre><code class=\"prism language-c++\">int globalVar = 1;\nstatic int staticGlobalVar = 1;\nvoid Test()\n{\nstatic int staticVar = 1;\nint localVar = 1;\nint num1[10] = {1, 2, 3, 4};\nchar char2[] = \"abcd\";\nchar* pChar3 = \"abcd\";\nint* ptr1 = (int*)malloc(sizeof (int)*4);\nint* ptr2 = (int*)calloc(4, sizeof(int));\nint* ptr3 = (int*)realloc(ptr2, sizeof(int)*4);\nfree (ptr1);\nfree (ptr3);\n}\n</code></pre>\n<pre><code>1. 选择题：\n选项: A.栈 B.堆 C.数据段 D.代码段\nglobalVar在哪里？____ staticGlobalVar在哪里？____\nstaticVar在哪里？____ localVar在哪里？____\nnum1 在哪里？____\nchar2在哪里？____ *char2在哪里？___\npChar3在哪里？____ *pChar3在哪里？____\nptr1在哪里？____ *ptr1在哪里？____\n\n答案：CCCAAAAADAB\n\n2. 填空题：\nsizeof(num1) = ____;\nsizeof(char2) = ____; strlen(char2) = ____;\nsizeof(pChar3) = ____; strlen(pChar3) = ____;\nsizeof(ptr1) = ____;\n\n\n答案：40，5，4，4/8，4，4/8\n</code></pre>\n<p><img alt=\"image-20220823173904630\" src=\"image\\04e0c786cb8230bd82403b29ce6444a6.png\"/></p>\n<blockquote>\n<p><img alt=\"image-20220823174715516\" src=\"image\\6a0749d3900f978831709f8c0f92a54a.png\"/></p>\n<p>【说明】</p>\n<ol><li> <p>栈又叫堆栈，非静态局部变量/函数参数/返回值等等，栈是向下增长的。</p> </li><li> <p>内存映射段是高效的I/O映射方式，用于装载一个共享的动态内存库。用户可使用系统接口创建共享共<br/> 享内存，做进程间通信。（Linux课程如果没学到这块，现在只需要了解一下）</p> </li><li> <p>堆用于程序运行时动态内存分配，堆是可以上增长的。</p> </li><li> <p>数据段–存储全局数据和静态数据。</p> </li><li> <p>代码段–可执行的代码/只读常量。</p> </li></ol>\n</blockquote>\n<p>操作系统内存管理：</p>\n<ol><li> <p>分段：不同用途数据放到不同的区域，就像我们现实中也会对省市乡级划分区域为一样</p> </li><li> <p>分页：</p> </li></ol>\n<p>填空题</p>\n<p><img alt=\"image-20220823174239686\" src=\"image\\dda4edd3a2f9e447b561f135ae00347f.png\"/></p>\n<h2><a id=\"operator_newoperator_delete_265\"></a>operator new和operator delete函数</h2>\n<p>我们相同的方法不同的操作来申请空间</p>\n<pre><code class=\"prism language-c++\">A* p1=(A*)malloc(sizeof(A));\nA* p2=new A;//会调用构造函数\nA* p3 = (A*)operator new(sizeof(A));\n</code></pre>\n<p>operator new和malloc的区别？我们先来看看申请空间错误的情况是什么样，首先是malloc:</p>\n<blockquote>\n<p><img alt=\"image-20220823211307051\" src=\"image\\1a88ec1d058c8c794d0d3380ea05259b.png\"/></p>\n<p>代码：</p>\n<pre><code class=\"prism language-c++\">size_t size = 2;//无符号类型\nvoid *p4 = malloc(1024 * 1024 * 1024 * size);\n</code></pre>\n<p><img alt=\"image-20220823211703049\" src=\"image\\8ca6f1c7a80c188d8a751b277771a585.png\"/></p>\n</blockquote>\n<p>这里我们申请失败返回0，我们再看operator new:</p>\n<blockquote>\n<p>代码：</p>\n<pre><code class=\"prism language-c++\">void *p5 = operator new(1024 * 1024 * 1024 * size);\ncout &lt;&lt; p5 &lt;&lt; endl;\n</code></pre>\n<p><img alt=\"image-20220823211930509\" src=\"image\\760638c768ede2f87e5ca4be22d25e48.png\"/></p>\n</blockquote>\n<p>这里失败抛出异常（面对对象处理错误的方式）</p>\n<blockquote>\n<p>结论：</p>\n<p>使用方式都一样，处理错误的方式不太一样</p>\n</blockquote>\n<p>operator new销毁方式:<code>operator delete(p5);</code></p>\n<p><strong>最后：这里我们要注意，为什么在.h文件不用包含任何头文件库和命名空间，是因为我在.cpp中包含头文件的前面先加入了需要编译后展开的using 和头文件，如果命名空间放到文件后，string.h头文件就会找不到cout和cin，因为需要展开才能使用到（先后问题）</strong></p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\de8f1eb406b741fc86fc82a047b147ef.png\"/></p>\n<h1><a id=\"_314\"></a>模板</h1>\n<p><code>T ADD(T&amp;a,T&amp;b)</code>ADD(a1,a2)T的类型是编译器自己推导的(隐式),</p>\n<p>ADD(a1,a2)(显示）</p>\n<p>我们用模板实现栈：</p>\n<pre><code class=\"prism language-c++\">#include&lt;iostream&gt;\n#include&lt;assert.h&gt;\nusing namespace std;\ntemplate&lt;class T&gt;\nclass stack\n{\npublic:\n\tstack()\n\t\t:_a(nullptr)\n\t\t, _size(0)\n\t\t, _capcity(0)\n\t{}\n\n\t~stack()\n\t{\n\t\n\t\tdelete[]_a;\n\t\t_a = nullptr;\n\t\t_size = 0;\n\t\t_capcity = 0;\n\t}\n\t//这里为了访问私有通过公共接口返回_size\n\tsize_t size()\n\t{\n\t\treturn _size;\n\t}\n\t\n\t//类里面声明，类外面定义stack&lt;T&gt;是一个类型\n\tT&amp; operator[](size_t i);\n\tvoid push_back(const T&amp;x);\n\tvoid pop_back();\n\n\nprivate:\n\tT*_a;\n\tsize_t _size;\n\tsize_t _capcity;\n\n};\n\ntemplate&lt;class T&gt;\nT&amp; stack&lt;T&gt;::operator[](size_t i)\n{\n\tassert(i &lt;_size);\n\treturn _a[i];\n}\n\n\ntemplate&lt;class T&gt;//声明模板类型T，因为已经与类分离了,函数类型是stack&lt;T&gt;\nvoid stack&lt;T&gt;::push_back(const T&amp;x)\n{\n\t//空间不够，需要增容\n\tif (_size == _capcity)\n\t{\n\t\tint newcapticy = _capcity == 0 ? 2 : _capcity * 2;\n\t\tT*tmp = new T[newcapticy];\n\t\t//\n\t\tif (_a)\n\t\t{\n\t\t\t//把旧的数据拷贝到新的空间\n\t\t\tmemcpy(tmp, _a, sizeof(T)*_size);\n\t\t\tdelete[]_a;\n\t\t\t\n\t\t}\n\t\t_a = tmp;\n\t\t_capcity = newcapticy;\n\t}\n\t_a[_size] = x;\n\t_size++;\n}\n\ntemplate&lt;class T&gt;\nvoid stack&lt;T&gt;::pop_back()\n{\n\tassert(_size &gt; 0);\n\t_size--;\n}\n\n\nint main()\n{\n\n\tstack&lt;int&gt;v1;\n\tv1.push_back(1);\n\tv1.push_back(2);\n\tv1.push_back(3);\n\tv1.push_back(4);\n\tv1.push_back(5);\n\tv1.push_back(6);\n\tfor (size_t i = 0; i &lt; v1.size(); i++)\n\t{\n\t\tv1[i] *= 2;\n\t}\n\n\n\tfor (size_t i = 0; i &lt; v1.size(); i++)\n\t{\n\t\t//这里的v1[i]会调用opertor[]第i个数据\n\t\tcout &lt;&lt; v1[i]&lt;&lt;\" \";\n\t}\n\tcout &lt;&lt; endl;\n\n\treturn 0;\n}\n</code></pre>\n<h2><a id=\"_431\"></a>引用的奇淫飞技</h2>\n<p>当我们要修改函数返回的值，只能加上引用，否则会报错“不可修改的左值”，还可以减少拷贝</p>\n<p><img alt=\"image-20220824154121996\" src=\"image\\670b764d4a770e8ceb233afc7fac3454.png\"/></p>\n<h1><a id=\"string_437\"></a>string</h1>\n<h2><a id=\"string_439\"></a>模仿实现string</h2>\n<p>我们创建一个string.h头文件</p>\n<pre><code class=\"prism language-c++\">class string\n\t{\n\tpublic:\n\t\tstring():_str(nullptr){}\n\t\tstring(char*str) :_str(str){}\n\t\tsize_t size()\n\t\t{\n\t\t\treturn strlen(_str);\n\t\t}\n\t\tchar&amp; operator[](size_t i)\n\t\t{\n\t\t\treturn _str[i];\n\t\t}\n\t\n\n\tprivate:\n\t\tchar*  _str;\n};\n</code></pre>\n<p>既然模仿，那肯定得有自己的sting，我们namespace一个名字，不然库的string会搞混：</p>\n<pre><code class=\"prism language-c++\">namespace copy\n{\n\tclass string\n    {\n        .....\n    };\n}\n</code></pre>\n<p>我们再写一个测试函数变量字符串：</p>\n<pre><code class=\"prism language-c++\">void test_string1()\n\t{\n\t\tstring s2();\n\t\tstring s1(\"helllo\");\n\t\tfor (size_t i = 0; i &lt; s1.size(); i++)\n\t\t{\n\t\t\n\t\t\tstd::cout &lt;&lt; s1[i] &lt;&lt; \" \";\n\t\t}\n\t\tstd::cout &lt;&lt; std::endl;\n\t}\n</code></pre>\n<p>然后在.cpp源文件中这样写：</p>\n<pre><code class=\"prism language-c++\">#include&lt;iostream&gt;\n#include\"string.h\"\nusing namespace std;\n\n\nint main()\n{\n\tcopy::test_string1();\n}\n</code></pre>\n<p><img alt=\"image-20220825150041110\" src=\"image\\2338c07642ab6d91603035deacae8c1c.png\"/></p>\n<p>遍历没有问题，那我们修改呢？崩溃了，原因是函数都存在栈中，字符串在代码段中，不能修改。</p>\n<p><img alt=\"image-20220825150513024\" src=\"image\\a661c961177b49b0362da947d0c6a09f.png\"/></p>\n<p><img alt=\"image-20220825150218268\" src=\"image\\9e95fdfb2c8e4a6640bdfa688100df94.png\"/></p>\n<p>我们知道一个string的库函数接口不止有修改还有插入还有空间不够怎么办？我们尝试在堆上申请空间，让指针指向这个堆，并且把字符串拷贝到堆里。</p>\n<p><img alt=\"image-20220825150756677\" src=\"image\\f6a158c7b9e5ff163e3c0af7cfbd84f0.png\"/></p>\n<p>那应该在哪里开辟一段空间呢？在构造函数中，malloc和new可以完成，但这里是自定义类型，内置类型它们效果一样，所有我们用new，那申请多少个空间好呢？</p>\n<pre><code class=\"prism language-c++\">string(char*str):_str(new char[strlen(str)+1]){}\n</code></pre>\n<p>计算字符串大小，并+1，因为在我们使用字符串的时候，后面都带有\\0，而在在c_str接口的时候也是需要一个默认\\0；</p>\n<p>最后拷贝：<code>strcpy(_str, str)</code></p>\n<p>然后，再实现一个空字符串遍历，默认的std::string s2;遍历不会报错，而我们的现在会崩溃，原因是，我们用this指针指向str这个空字符默认只有\\0我们对空解引用就出错了；这里不能直接给他<code>nullptr</code>,new一个给他；</p>\n<pre><code class=\"prism language-c++\">string():_str(new char[1])\n\t\t{\n\t\t\t_str[0] = '\\0';\n\n\t\t}\n</code></pre>\n<p>析构函数：</p>\n<pre><code class=\"prism language-c++\">~string()\n\t\t{\n\t\t\tdelete[]_str;\n\t\t\t_str = nullptr;\n\t\t}\n</code></pre>\n<pre><code class=\"prism language-c++\">string s1(\"helllo\");\nstring s2(s1);\n</code></pre>\n<p>上面代码会崩溃，原因是s2拷贝了s1的字符串和空间，因为我们没有写拷贝构造函数，编译器默认生成，这会造成同一个空间被析构两次【浅拷贝】</p>\n<p>深拷贝：(把~string(){}注释掉，不然一样报错)</p>\n<pre><code class=\"prism language-c++\">//s2=s1;\n\t\tstring&amp; operator=(const string&amp; s)\n\t\t{\n\t\t\tif (this != &amp;s)\n\t\t\t{\n\t\t\tchar*tmp = new char[strlen(s._str) + 1];\n\t\t\tstrcpy( tmp,s._str);\n\t\t\tdelete[]_str;\n\t\t\t_str = tmp;\n\t\t\t}\n\t\t\t\n\t\t\treturn *this;\n\t\t}\n</code></pre>\n<p>底层原理：</p>\n<pre><code class=\"prism language-c++\">using namespace std;\n\nnamespace test{\n\n\tclass string\n\t{\n\tpublic:\n\t\t\n\t\ttypedef char* iterator;\n\t\titerator begin()\n\t\t{\n\t\t\treturn _str;\n\t\t}\n\t\titerator end()\n\t\t{\n\t\t\treturn _str + _size;\n\t\t}\n\n\t\t//这里需要对它解引用，不能直接nullptr(默认为空)\n\t\tstring(char* str=\"\") :_str(new char[strlen(str)+1])\n\t\t{\n\t\t\tstrcpy( _str,str);\n\t\t}\n\t\t//传统手法\n\t\t//s2(s1)\n\t\t/*string(const string &amp;s)\n\t\t\t:_str(new char [strlen(_str)+1])\n\t\t{\n\t\t\tstrcpy(_str, s._str);\n\t\t}\n\t\n\t\t//现代手法\n\t\t//s2(s1)\n\t\tstring(string &amp; s) :_str(nullptr)\n\t\t{\n\t\t\tstring tmp(s._str);\n\t\t\tswap(_str, s._str);\n\t\t\t\n\t\t}\n\t\t//s2=s3;\n\t\tstring&amp;operator=(string s)\n\t\t{\n\t\t\tswap(_str, s._str);\n\t\t\treturn *this;\n\t\t}\n\t\t//const s2=s3;\n\t\tstring&amp;operator=(const string&amp; s)\n\t\t{\n\t\t\tif (this != &amp;s)\n\t\t\t{\n\t\t\t\tstring tmp(s._str);\n\t\t\tswap(_str,tmp._str);//等同swap(_str, s._str);\n\t\t\treturn *this;\n\t\t\t\n\t\t\t}\n\t\t}\n\t\tstring(){}\n\t\t\n\t\t\n\t\tsize_t size()\n\t\t{\n\t\t\treturn strlen(_str);\n\t\t}\n\t\t\n\t\tconst char* c_str()\n\t\t{\n\t\t\treturn _str;\n\t\t}\n\n\t\tchar&amp; operator[](const size_t&amp; i)\n\t\t{\n\t\t\treturn _str[i];\n\t\t}\n\n\n\t\t~string()\n\t\t{\n\t\t\tdelete[]_str;\n\t\t\t_str = nullptr;\n\t\t}*/\n\n\tprivate:\n\t\tchar* _str;\n\t\tsize_t _size;\n\t\tsize_t _capacity;\n\t};\n\n\tvoid test_string1()\n\t{\n\n\t\tstring s1(\"hello world\");\n\t\tstring s3=\"world\";\n\t\t\n\t\t\n\t\tfor (size_t i = 0; i &lt; s1.size(); i++)\n\t\t{\n\t\t\ts1[i] += 1;\n\t\t\tcout &lt;&lt; s1[i]&lt;&lt; \" \";\n\t\t}\n\t\tcout &lt;&lt; endl;\n\t\tstring s2 = s3;\n\t\tcout &lt;&lt; s2.c_str() &lt;&lt; endl;\n\n\t\t\n\t}\n\tvoid test_string2()\n\t{\n\t\tstring s1(\"hello world\");\n\t\tstring s2(s1);\n\t\tcout &lt;&lt; s2.c_str() &lt;&lt; endl;\n\t}\n\tvoid test_string3()\n\t{\n\t\tstring s1(\"hello world\");\n\t\tstring::iterator it = s1.begin();\n\t\twhile (it != s1.end())\n\t\t{\n\t\t\tcout &lt;&lt; *it &lt;&lt; \" \";\n\t\t\t++it;\n\t\t}\n\t\t\n\t\tcout &lt;&lt; endl;\n\t\tfor (auto e : s1)\n\t\t{\n\t\t\tcout &lt;&lt; e &lt;&lt; \" \";\n\t\t}\n\t\tcout &lt;&lt; endl;\n\t}\n\n\n}\n</code></pre>\n<p><img alt=\"image-20220826071654086\" src=\"image\\266ffde1aacff5862af3b50c04729225.png\"/></p>\n<h1><a id=\"_715\"></a>面试题</h1>\n<ol><li><strong>为什么空类占1一个字节，不是0？</strong></li></ol>\n<p>一个字节不是为了存取数据，而是占位</p>\n<p>当我们实例化一个对象，A1 a;我们需要用它，如果字节0，那我们怎么找它调用呢？</p>\n<pre><code class=\"prism language-c++\">class A1\n{\nvoid printf();\n};\nint main()\n{\n    A1 a;\n    return 0;\n}\n</code></pre>\n<ol start=\"2\"><li><strong>static</strong></li></ol>\n<pre><code class=\"prism language-c++\">int Add()\n{\n\tstatic int c=1;//只会初始化一次\n\tc=a+d;\n\treturn c\n}\n</code></pre>\n<ol start=\"3\"><li> <p><strong>全局变量和static变量有什么区别？</strong></p> </li><li> <p><strong>malloc/calloc/realloc有什么取别</strong></p> </li></ol>\n<p>​ malloc:申请空间</p>\n<p>​ calloc:申请空间加初始化为0；</p>\n<p>​ realloc：对已有的空间进行扩容</p>\n<ol start=\"5\"><li> <p><strong>malloc/free和new/delete的区别</strong><br/> malloc/free和new/delete的共同点是：都是从堆上申请空间，并且需要用户手动释放。不同的地方是：</p>\n<ol><li> <p>malloc和free是函数，new和delete是操作符</p> </li><li> <p>malloc申请的空间不会初始化，new可以初始化</p> </li><li> <p>malloc申请空间时，需要手动计算空间大小并传递，new只需在其后跟上空间的类型即可</p> </li><li> <p>malloc的返回值为void*, 在使用时必须强转，new不需要，因为new后跟的是空间的类型</p> </li><li> <p>malloc申请空间失败时，返回的是NULL，因此使用时必须判空，new不需要，但是new需要捕获异常</p> </li><li> <p>申请自定义类型对象时，malloc/free只会开辟空间，不会调用构造函数与析构函数，而new在申请空间<br/> 后会调用构造函数完成对象的初始化，delete在释放空间前会调用析构函数完成空间中资源的清理</p> </li><li> <p>出现内存泄漏，影响很大，如操作系统、后台服务等等，出现内存泄漏会<br/> 导致响应越来越慢，最终卡死</p> </li></ol> </li><li> <p><strong>内存泄漏</strong></p>\n<ol start=\"6\"><li>1 什么是内存泄漏，内存泄漏的危害<br/> 什么是内存泄漏：内存泄漏指因为疏忽或错误造成程序未能释放已经不再使用的内存的情况。内存泄漏并不<br/> 是指内存在物理上的消失，而是应用程序分配某段内存后，因为设计错误，失去了对该段内存的控制，因而<br/> 造成了内存的浪费。<br/> 内存泄漏的危害：长期运行的程序</li></ol> </li></ol>\n<pre><code class=\"prism language-c++\">void MemoryLeaks()\n{\n// 1.内存申请了忘记释放\nint* p1 = (int*)malloc(sizeof(int));\nint* p2 = new int;\n// 2.异常安全问题\nint* p3 = new int[10];\nFunc(); // 这里Func函数抛异常导致 delete[] p3未执行，p3没被释放.\ndelete[] p3;\n}\n</code></pre>\n<ol start=\"7\"><li> <p><strong>如何避免内存泄漏</strong></p>\n<ol start=\"7\"><li> <p>1工程前期良好的设计规范，养成良好的编码规范，申请的内存空间记着匹配的去释放。ps：这个理想状<br/> 态。但是如果碰上异常时，就算注意释放了，还是可能会出问题。需要下一条智能指针来管理才有保<br/> 证.</p> <p>7.2 采用RAII思想或者智能指针来管理资源。</p> <p>7.3 有些公司内部规范使用内部实现的私有内存管理库。这套库自带内存泄漏检测的功能选项。</p> <p>7.4 出问题了使用内存泄漏工具检测。ps：不过很多工具都不够靠谱，或者收费昂贵。</p>\n<blockquote>\n<p>总结一下:<br/> 内存泄漏非常常见，解决方案分为两种：1、事前预防型。如智能指针等。2、事后查错型。如泄漏检测工<br/> 具。</p>\n</blockquote> </li></ol> </li><li> <p><strong>如何一次在堆上申请4G的内存？</strong></p> </li></ol>\n<pre><code class=\"prism language-c++\">// 将程序编译成x64的进程，运行下面的程序试试？\n#include &lt;iostream&gt;\nusing namespace std;\nint main()\n{\nvoid* p = new char[0xfffffffful];\ncout &lt;&lt; \"new:\" &lt;&lt; p &lt;&lt; endl;\nreturn 0;\n}\n</code></pre>\n<ol start=\"9\"><li><strong>实现一个string</strong></li></ol>\n<pre><code class=\"prism language-c++\">//这里需要对它解引用，不能直接nullptr(默认为空)\n\t\tstring(char* str = \"\") :_str(new char[strlen(str) + 1]), _size(0)\n\t\t{\n\t\t\tstrcpy(_str, str);\n\t\t}\n\t\tstring()\n\t\t{\n\t\t}\n\t\t\n\t\t//深拷贝-》传统手法\n\t\t//s1=s2;\n\t\tstring&amp;operator=(string &amp; s)\n\t\t{\n\t\t\tif (this != &amp;s)\n\t\t\t{\n\t\t\t\tchar * tmp = new char[strlen(s._str) + 1];\n\t\t\t\tstrcpy(tmp, s._str);\n\t\t\t\tdelete[]_str;\n\t\t\t\t_str = tmp;\n\n\t\t\t}\n\t\t\treturn *this;\n\t\t}\n\n\t\t//s2(s1)\n\t\tstring(const string &amp;s)\n\t\t\t:_str(new char[strlen(_str) + 1])\n\t\t{\n\t\t\tstrcpy(_str, s._str);\n\t\t}\n\n\t\t深拷贝-》现代手法\n\t\ts2(s1)\n\t\t//string(string &amp; s) :_str(nullptr)\n\t\t//{\n\t\t//\tstring tmp(s._str);\n\t\t//\tswap(_str, s._str);\n\n\t\t//}\n\t\ts1=s2;\n\t\t//这里最巧的就是传值操作\n\t\t//string&amp;operator=(string s)\n\t\t//{\n\t\t//\tswap(_str, s._str);\n\t\t//\treturn *this;\n\t\t//}\n\t\tconst s2=s3;\n\t\t//string&amp;operator=(const string&amp; s)\n\t\t//{\n\t\t//\tif (this != &amp;s)\n\t\t//\t{\n\t\t//\t\tstring tmp(s._str);\n\t\t//\t\tswap(_str, tmp._str);//等同swap(_str, s._str);\n\t\t//\t\treturn *this;\n\n\t\t//\t}\n\t\t//}\n</code></pre>\n<ol start=\"10\"><li><strong>vector插入数据如何实现的？</strong></li></ol>\n<p>（增容次数更多，效率更低，因为每次增容都要付出代价）</p>\n<p>2倍：相对而言效率更好，但是浪费的空间更多。插入1067个数据，（倒数最后一个1024*2）最终到2048，浪费970多个</p>\n<p>1.5倍：1067个数据，总容量1599（倒数一个1066*1.5）</p>\n<p>答：增容多少是一种旋转，各有利弊，均衡一点，可以使用reserve（1067）；</p>\n<ol start=\"11\"><li>为什么会有list？</li></ol>\n<p>vector的缺点是什么？</p>\n<p>答：1.头部和中部的插入删除效率低，O(N)，因为需要挪动数据；</p>\n<p>​ 2.插入数据空间不勾 需要增容，增容需要开新空间、拷贝数据、释放旧空间，会付出很大的代价</p>\n<p>优点：</p>\n<p>1.支持下标的随机访问、间接的就很好的支持排二分查找、堆算法等等</p>\n<p>list出现就是为了解决vector的缺陷</p>\n<p>优点：</p>\n<p>1.list头部、中间插入不再需要挪动数据，效率高O(1)</p>\n<p>2.list插入数据是新增节点，不再需要增容</p>\n<p>缺点：</p>\n<p>1.不支持随机访问。</p>\n<p>所有实际使用中vector和list是相互相成的两个容器</p>\n<ol start=\"11\"><li>什么是迭代器失效</li></ol>\n<ul><li>如果对大家有帮助，请三连支持一下！</li><li>有问题欢迎评论区留言，及时帮大家解决！</li></ul>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}