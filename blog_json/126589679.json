{"blogid": "126589679", "writerAge": "码龄1年", "writerBlogNum": "49", "writerCollect": "252", "writerComment": "470", "writerFan": "1273", "writerGrade": "4级", "writerIntegral": "1530", "writerName": "beyond.myself", "writerProfileAdress": "writer_image\\profile_126589679.jpg", "writerRankTotal": "12428", "writerRankWeekly": "1574", "writerThumb": "562", "writerVisitNum": "27852", "blog_read_count": "275", "blog_time": "已于 2022-09-03 11:45:27 修改", "blog_title": "linux篇【6】：进程等待", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E4%B8%80.fork%E5%87%BD%E6%95%B0%E5%88%9D%E8%AF%86-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%80.fork%E5%87%BD%E6%95%B0%E5%88%9D%E8%AF%86\">一.fork函数初识</a></p>\n<p id=\"1.%E6%A6%82%E5%BF%B5-toc\" style=\"margin-left:40px;\"><a href=\"#1.%E6%A6%82%E5%BF%B5\">1.概念</a></p>\n<p id=\"2.%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%85%B1%E4%BA%ABfork%E4%B9%8B%E5%89%8D%E5%92%8Cfork%E4%B9%8B%E5%90%8E%E7%9A%84%E6%89%80%E6%9C%89%E4%BB%A3%E7%A0%81%EF%BC%8C%E5%8F%AA%E4%B8%8D%E8%BF%87%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%8F%AA%E8%83%BD%E6%89%A7%E8%A1%8Cfork%E4%B9%8B%E5%90%8E%E7%9A%84-toc\" style=\"margin-left:40px;\"><a href=\"#2.%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%85%B1%E4%BA%ABfork%E4%B9%8B%E5%89%8D%E5%92%8Cfork%E4%B9%8B%E5%90%8E%E7%9A%84%E6%89%80%E6%9C%89%E4%BB%A3%E7%A0%81%EF%BC%8C%E5%8F%AA%E4%B8%8D%E8%BF%87%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%8F%AA%E8%83%BD%E6%89%A7%E8%A1%8Cfork%E4%B9%8B%E5%90%8E%E7%9A%84\">2.父子进程共享fork之前和fork之后的所有代码，只不过子进程只能执行fork之后的</a></p>\n<p id=\"3.fork%E4%B9%8B%E5%90%8E%EF%BC%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%3F-toc\" style=\"margin-left:40px;\"><a href=\"#3.fork%E4%B9%8B%E5%90%8E%EF%BC%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%3F\">3.fork之后，操作系统做了什么?</a></p>\n<p id=\"%E8%BF%9B%E7%A8%8B%E5%85%B7%E6%9C%89%E7%8B%AC%E7%AB%8B%E6%80%A7%EF%BC%8C%E4%BB%A3%E7%A0%81%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BF%85%E9%A1%BB%E7%8B%AC%E7%AB%8B%E7%9A%84-toc\" style=\"margin-left:80px;\"><a href=\"#%E8%BF%9B%E7%A8%8B%E5%85%B7%E6%9C%89%E7%8B%AC%E7%AB%8B%E6%80%A7%EF%BC%8C%E4%BB%A3%E7%A0%81%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BF%85%E9%A1%BB%E7%8B%AC%E7%AB%8B%E7%9A%84\">进程具有独立性，代码和数据必须独立的</a></p>\n<p id=\"%E5%86%99%E6%97%B6%E6%8B%B7%E8%B4%9D-toc\" style=\"margin-left:80px;\"><a href=\"#%E5%86%99%E6%97%B6%E6%8B%B7%E8%B4%9D\">写时拷贝</a></p>\n<p id=\"fork%E5%B8%B8%E8%A7%84%E7%94%A8%E6%B3%95-toc\" style=\"margin-left:80px;\"><a href=\"#fork%E5%B8%B8%E8%A7%84%E7%94%A8%E6%B3%95\">fork常规用法</a></p>\n<p id=\"fork%E8%B0%83%E7%94%A8%E5%A4%B1%E8%B4%A5%E7%9A%84%E5%8E%9F%E5%9B%A0-toc\" style=\"margin-left:80px;\"><a href=\"#fork%E8%B0%83%E7%94%A8%E5%A4%B1%E8%B4%A5%E7%9A%84%E5%8E%9F%E5%9B%A0\">fork调用失败的原因</a></p>\n<p id=\"4.Fork%E5%90%8E%E5%AD%90%E8%BF%9B%E7%A8%8B%E4%BF%9D%E7%95%99%E4%BA%86%E7%88%B6%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BB%80%E4%B9%88%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#4.Fork%E5%90%8E%E5%AD%90%E8%BF%9B%E7%A8%8B%E4%BF%9D%E7%95%99%E4%BA%86%E7%88%B6%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BB%80%E4%B9%88%EF%BC%9F\">4.Fork后子进程保留了父进程的什么？</a></p>\n<p id=\"5.fork%E5%92%8Cexec%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-toc\" style=\"margin-left:40px;\"><a href=\"#5.fork%E5%92%8Cexec%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8\">5.fork和exec系统调用</a></p>\n<p id=\"%E4%BA%8C.%E8%BF%9B%E7%A8%8B%E7%BB%88%E6%AD%A2-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BA%8C.%E8%BF%9B%E7%A8%8B%E7%BB%88%E6%AD%A2\">二.进程终止</a></p>\n<p id=\"1.%E5%B8%B8%E8%A7%81%E8%BF%9B%E7%A8%8B%E9%80%80%E5%87%BA-toc\" style=\"margin-left:40px;\"><a href=\"#1.%E5%B8%B8%E8%A7%81%E8%BF%9B%E7%A8%8B%E9%80%80%E5%87%BA\">1.常见进程退出</a></p>\n<p id=\"2.%E5%85%B3%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%BB%88%E6%AD%A2%E7%9A%84%E6%AD%A3%E7%A1%AE%E8%AE%A4%E8%AF%86-toc\" style=\"margin-left:40px;\"><a href=\"#2.%E5%85%B3%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%BB%88%E6%AD%A2%E7%9A%84%E6%AD%A3%E7%A1%AE%E8%AE%A4%E8%AF%86\">2.关于进程终止的正确认识</a></p>\n<p id=\"%EF%BC%881%EF%BC%89%E8%BF%9B%E7%A8%8B%E9%80%80%E5%87%BA%E7%A0%81-toc\" style=\"margin-left:80px;\"><a href=\"#%EF%BC%881%EF%BC%89%E8%BF%9B%E7%A8%8B%E9%80%80%E5%87%BA%E7%A0%81\">（1）进程退出码</a></p>\n<p id=\"%C2%A0echo%20%24%3F%20%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E9%80%80%E5%87%BA%E7%A0%81-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A0echo%20%24%3F%20%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E9%80%80%E5%87%BA%E7%A0%81\"> echo $? 查看进程退出码</a></p>\n<p id=\"%EF%BC%882%EF%BC%89%E5%85%B3%E4%BA%8E%E7%BB%88%E6%AD%A2%E7%9A%84%E5%B8%B8%E8%A7%81%E5%81%9A%E6%B3%95%E2%80%94%E2%80%94exit()-toc\" style=\"margin-left:80px;\"><a href=\"#%EF%BC%882%EF%BC%89%E5%85%B3%E4%BA%8E%E7%BB%88%E6%AD%A2%E7%9A%84%E5%B8%B8%E8%A7%81%E5%81%9A%E6%B3%95%E2%80%94%E2%80%94exit%28%29\">（2）关于终止的常见做法——exit()</a></p>\n<p id=\"%EF%BC%883%EF%BC%89exit%E5%92%8C_exit-toc\" style=\"margin-left:80px;\"><a href=\"#%EF%BC%883%EF%BC%89exit%E5%92%8C_exit\">（3）exit和_exit</a></p>\n<p id=\"%EF%BC%884%EF%BC%89%E5%85%B3%E4%BA%8E%E7%BB%88%E6%AD%A2%EF%BC%8C%E5%86%85%E6%A0%B8%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%3F-toc\" style=\"margin-left:80px;\"><a href=\"#%EF%BC%884%EF%BC%89%E5%85%B3%E4%BA%8E%E7%BB%88%E6%AD%A2%EF%BC%8C%E5%86%85%E6%A0%B8%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%3F\">（4）关于终止，内核做了什么?</a></p>\n<p id=\"%E4%B8%89.%E8%BF%9B%E7%A8%8B%E7%AD%89%E5%BE%85-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%89.%E8%BF%9B%E7%A8%8B%E7%AD%89%E5%BE%85\">三.进程等待</a></p>\n<p id=\"1.%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E8%BF%9B%E7%A8%8B%E7%AD%89%E5%BE%85-toc\" style=\"margin-left:40px;\"><a href=\"#1.%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E8%BF%9B%E7%A8%8B%E7%AD%89%E5%BE%85\">1.为什么要进行进程等待</a></p>\n<p id=\"%E2%91%A0%E4%B8%BA%E4%BA%86%E8%A7%A3%E5%86%B3%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98-toc\" style=\"margin-left:80px;\"><a href=\"#%E2%91%A0%E4%B8%BA%E4%BA%86%E8%A7%A3%E5%86%B3%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98\">①为了解决僵尸进程内存泄漏问题</a></p>\n<p id=\"%E2%91%A1%E4%B8%BA%E4%BA%86%E8%8E%B7%E5%8F%96%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%80%80%E5%87%BA%E7%8A%B6%E6%80%81-toc\" style=\"margin-left:80px;\"><a href=\"#%E2%91%A1%E4%B8%BA%E4%BA%86%E8%8E%B7%E5%8F%96%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%80%80%E5%87%BA%E7%8A%B6%E6%80%81\">②为了获取子进程的退出状态</a></p>\n<p id=\"2.wait%E4%B8%8Ewaitpid-toc\" style=\"margin-left:40px;\"><a href=\"#2.wait%E4%B8%8Ewaitpid\">2.wait与waitpid</a></p>\n<p id=\"int*%20status%EF%BC%9A%E6%98%AF%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0%EF%BC%8C%E9%87%8D%E7%82%B9%E8%AF%B4%EF%BC%9A%E5%8F%AA%E9%9C%80%E8%A6%81%E5%85%B3%E5%BF%83%E6%94%B9%E6%95%B4%E6%95%B0%E7%9A%84%E4%BD%8E16%E4%B8%AA%E6%AF%94%E7%89%B9%E4%BD%8D!-toc\" style=\"margin-left:80px;\"><a href=\"#int*%20status%EF%BC%9A%E6%98%AF%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0%EF%BC%8C%E9%87%8D%E7%82%B9%E8%AF%B4%EF%BC%9A%E5%8F%AA%E9%9C%80%E8%A6%81%E5%85%B3%E5%BF%83%E6%94%B9%E6%95%B4%E6%95%B0%E7%9A%84%E4%BD%8E16%E4%B8%AA%E6%AF%94%E7%89%B9%E4%BD%8D!\">int* status：是一个整数，重点说：只需要关心改整数的低16个比特位!</a></p>\n<p id=\"%EF%BC%881%EF%BC%89%E4%BD%8E16%E4%B8%AA%E6%AF%94%E7%89%B9%E4%BD%8D%E7%9A%84%E6%AC%A1%E4%BD%8E8%E6%AF%94%E7%89%B9%E4%BD%8D%EF%BC%88%E6%AC%A1%E4%BD%8E8%E6%AF%94%E7%89%B9%E4%BD%8D%EF%BC%89%20%E6%98%AF%E9%80%80%E5%87%BA%E7%A0%81-toc\" style=\"margin-left:80px;\"><a href=\"#%EF%BC%881%EF%BC%89%E4%BD%8E16%E4%B8%AA%E6%AF%94%E7%89%B9%E4%BD%8D%E7%9A%84%E6%AC%A1%E4%BD%8E8%E6%AF%94%E7%89%B9%E4%BD%8D%EF%BC%88%E6%AC%A1%E4%BD%8E8%E6%AF%94%E7%89%B9%E4%BD%8D%EF%BC%89%20%E6%98%AF%E9%80%80%E5%87%BA%E7%A0%81\">（1）低16个比特位的次低8比特位（次低8比特位） 是退出码</a></p>\n<p id=\"%EF%BC%882%EF%BC%89%E4%BD%8E8%E4%B8%AA%E6%AF%94%E7%89%B9%E4%BD%8D%E6%98%AF%E7%BB%88%E6%AD%A2%E4%BF%A1%E5%8F%B7-toc\" style=\"margin-left:80px;\"><a href=\"#%EF%BC%882%EF%BC%89%E4%BD%8E8%E4%B8%AA%E6%AF%94%E7%89%B9%E4%BD%8D%E6%98%AF%E7%BB%88%E6%AD%A2%E4%BF%A1%E5%8F%B7\">（2）低8个比特位是终止信号</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<p></p>\n<p></p>\n<h1 id=\"%E4%B8%80.fork%E5%87%BD%E6%95%B0%E5%88%9D%E8%AF%86\"><span style=\"color:#333333;\"><strong>一.fork</strong></span><span style=\"color:#333333;\"><strong>函数初识</strong></span></h1>\n<h2 id=\"1.%E6%A6%82%E5%BF%B5\">1.概念</h2>\n<div>\n<span style=\"color:#333333;\">在linux</span>\n<span style=\"color:#333333;\">中</span>\n<span style=\"color:#333333;\">fork</span>\n<span style=\"color:#333333;\">函数是非常重要的函数，它从已存在进程中创建一个新进程。新进程为子进程，而原进程为父进程。 </span>\n</div>\n<div>\n<div>\n<span style=\"color:#333333;\">#include &lt;unistd.h&gt;</span>\n</div>\n<div>\n<span style=\"color:#333333;\">pid_t fork(void); </span>\n</div>\n<div>\n<span style=\"color:#333333;\">返回值：子进程中返回</span>\n<span style=\"color:#333333;\">0</span>\n<span style=\"color:#333333;\">，父进程返回子进程</span>\n<span style=\"color:#333333;\">id</span>\n<span style=\"color:#333333;\">，出错返回</span>\n<span style=\"color:#333333;\">-1</span>\n</div>\n<div></div>\n</div>\n<div>\n<span style=\"color:#494949;\">进程调用fork，当控制转移到内核中的fork代码后，内核做： </span>\n</div>\n<div>\n<span style=\"color:#494949;\">        ①分配新的内存块和内核数据结构给子进程 </span>\n</div>\n<div>\n<span style=\"color:#494949;\">        ②将父进程部分数据结构内容拷贝至子进程 </span>\n</div>\n<div>\n<span style=\"color:#494949;\">        ③添加子进程到系统进程列表当中（链进运行队列）</span>\n</div>\n<div>\n<span style=\"color:#494949;\">        ④fork返回，开始调度器调度</span>\n</div>\n<div></div>\n<div>\n<span style=\"color:#333333;\">当一个进程调用</span>\n<span style=\"color:#333333;\">fork</span>\n<span style=\"color:#333333;\">之后，就有两个二进制代码相同的进程。而且它们都运行到相同的地方。但每个进程都将可以开始它们自己的旅程，看如下程序</span>\n</div>\n<div>\n<img alt=\"\" height=\"466\" src=\"image\\584bb085779c4e56a4359a5c1908d6ee.png\" width=\"773\"/>\n</div>\n<p></p>\n<h2 id=\"2.%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%85%B1%E4%BA%ABfork%E4%B9%8B%E5%89%8D%E5%92%8Cfork%E4%B9%8B%E5%90%8E%E7%9A%84%E6%89%80%E6%9C%89%E4%BB%A3%E7%A0%81%EF%BC%8C%E5%8F%AA%E4%B8%8D%E8%BF%87%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%8F%AA%E8%83%BD%E6%89%A7%E8%A1%8Cfork%E4%B9%8B%E5%90%8E%E7%9A%84\">2.父子进程共享fork之前和fork之后的所有代码，只不过子进程只能执行fork之后的</h2>\n<p>fork之前父进程独立执行，fork之后， 父子两个执行流分别执行。</p>\n<p>那么fork之后，是否只有fork之后的代码是被父子进程共享的? ?<br/> fork之后，父子共享所有的代码，但fork之前的代码也是父子共享的，只不过子进程只能执行fork之后的<br/> 子进程执行的后续代码! =共享的所有代码，只不过子进程只能从这里开始执行! !</p>\n<p>为什么呢：</p>\n<p>CPU中有一个程序计数器叫eip，用途是eip叫做，保存当前正在执行指令的下一条指令!<br/> eip程序计数器会拷贝给子进程，子进程便从该eip所指向的代码处开始执行啦! !</p>\n<p><u>如果我想让子进程拿到fork之前的代码，可以让子进程把CPU中的eip改成main函数入口就可以执行fork之前的代码。</u></p>\n<p><img alt=\"\" height=\"359\" src=\"image\\b0400703fb2343dc96257bbe47c11080.png\" width=\"555\"/></p>\n<h2 id=\"3.fork%E4%B9%8B%E5%90%8E%EF%BC%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%3F\">3.fork之后，操作系统做了什么?</h2>\n<p>进程=内核的进程数据结构+进程的代码和数据<br/> 创建子进程的内核数据结构(struct task_ struct + struct mm_ struct +页表) +代码继承父进程，数据以写时拷贝的方式，来进行共享或者独立!<br/>  </p>\n<h3 id=\"%E8%BF%9B%E7%A8%8B%E5%85%B7%E6%9C%89%E7%8B%AC%E7%AB%8B%E6%80%A7%EF%BC%8C%E4%BB%A3%E7%A0%81%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BF%85%E9%A1%BB%E7%8B%AC%E7%AB%8B%E7%9A%84\">进程具有独立性，代码和数据必须独立的</h3>\n<p>数据通过写时拷贝保证独立性<br/> 代码因为是只读的，不可修改</p>\n<h3 id=\"%E5%86%99%E6%97%B6%E6%8B%B7%E8%B4%9D\"><strong><span style=\"color:#333333;\">写时拷贝 </span></strong></h3>\n<div></div>\n<div>\n<span style=\"color:#333333;\">通常，父子代码共享，父子再不写入时，数据也是共享的，当任意一方试图写入，便以写时拷贝的方式各自一份副 本。</span>\n</div>\n<div></div>\n<h3 id=\"fork%E5%B8%B8%E8%A7%84%E7%94%A8%E6%B3%95\"><span style=\"color:#333333;\"><strong>fork</strong></span><span style=\"color:#333333;\"><strong>常规用法 </strong></span></h3>\n<div></div>\n<div>\n<span style=\"color:#777777;\">一个父进程希望复制自己，使父子进程同时执行不同的代码段。例如，父进程等待客户端请求，生成子 </span>\n</div>\n<div>\n<span style=\"color:#777777;\">进程来处理请求。 </span>\n</div>\n<div>\n<span style=\"color:#777777;\">一个进程要执行一个不同的程序。例如子进程从</span>\n<span style=\"color:#777777;\">fork</span>\n<span style=\"color:#777777;\">返回后，调用</span>\n<span style=\"color:#777777;\">exec</span>\n<span style=\"color:#777777;\">函数。 </span>\n</div>\n<div></div>\n<h3 id=\"fork%E8%B0%83%E7%94%A8%E5%A4%B1%E8%B4%A5%E7%9A%84%E5%8E%9F%E5%9B%A0\"><span style=\"color:#333333;\"><strong>fork</strong></span><span style=\"color:#333333;\"><strong>调用失败的原因 </strong></span></h3>\n<div></div>\n<div>\n<span style=\"color:#777777;\">系统中有太多的进程 </span>\n</div>\n<div>\n<span style=\"color:#777777;\">实际用户的进程数超过了限制 </span>\n</div>\n<p></p>\n<h2 id=\"4.Fork%E5%90%8E%E5%AD%90%E8%BF%9B%E7%A8%8B%E4%BF%9D%E7%95%99%E4%BA%86%E7%88%B6%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BB%80%E4%B9%88%EF%BC%9F\">4.Fork后子进程保留了父进程的什么？</h2>\n<p>A.环境变量</p>\n<p>B.父进程的文件锁，pending alarms和pending signals</p>\n<p>C.当前工作目录</p>\n<p>D.进程号</p>\n<p>fork函数功能是通过复制父进程，创建一个新的子进程。</p>\n<ul><li>A选项正确：环境变量默认会继承于父进程，与父进程相同</li><li>B选项错误：信号相关信息各自独立，并不会复制</li><li>C选项正确：工作路径也相同</li><li>D选项错误：每个进程都有自己独立的标识符</li></ul>\n<p>根据理解分析，正确选项为A和C选项</p>\n<h2 id=\"5.fork%E5%92%8Cexec%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8\">5.fork和exec系统调用</h2>\n<ul><li>fork生成的进程是当前进程的一个相同副本（fork调用通过复制父进程创建子进程，子进程与父进程运行的代码和数据完全一样）</li><li>fork系统调用与clone系统调用的工作原理基本相同（fork创建子进程就是在内核中通过调用clone实现）</li></ul>\n<ul><li>exec是<strong>程序替换函数</strong>，本身并不创建进程</li><li>clone函数的功能是创建一个pcb，fork创建进程以及后边的创建线程本质内部调用的clone函数实现，而exec函数中本身并不创建进程，而是程序替换，因此工作机理并不相同</li></ul>\n<h1 id=\"%E4%BA%8C.%E8%BF%9B%E7%A8%8B%E7%BB%88%E6%AD%A2\">二.<span style=\"color:#333333;\"><strong>进程终止 </strong></span></h1>\n<h2 id=\"1.%E5%B8%B8%E8%A7%81%E8%BF%9B%E7%A8%8B%E9%80%80%E5%87%BA\">1.常见进程退出</h2>\n<div>\n ________________________________\n</div>\n<div>\n 常见进程退出:                                         |         \n <br/> 1.代码跑完，结果正确                            | \n <br/> 2.代码跑完,结果不正确                           | \n <br/> 3.代码没跑完，程序异常了                     | \n <br/> ——————————————————\n</div>\n<div></div>\n<h2 id=\"2.%E5%85%B3%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%BB%88%E6%AD%A2%E7%9A%84%E6%AD%A3%E7%A1%AE%E8%AE%A4%E8%AF%86\">2.关于<span style=\"color:#333333;\"><strong>进程终止</strong></span>的正确认识</h2>\n<p>C/C++的时候，main函数为什么 return 0; ？<br/> a.return 0，给谁return<br/> b.为何是0?其他值可以吗?</p>\n<p><br/> return 0表示进程代码跑完，结果正确<br/> return 非零：结果不正确</p>\n<p><u>在main函数中return代表进程结束。其他非main 函数return 代表函数调用结束</u></p>\n<h3 id=\"%EF%BC%881%EF%BC%89%E8%BF%9B%E7%A8%8B%E9%80%80%E5%87%BA%E7%A0%81\">（1）进程退出码</h3>\n<p>代码跑完，结果正确就没什么好说的就exit(0)/return 0返回码是0；如果代码跑完，结果不正确，那我们最想知道的是失败的原因!<br/> 所以:<u><strong>非零标识不同的原因! 比如</strong></u>exit(13)<br/> return X的X叫做<strong>进程退出码，</strong>表征进程退出的信息，是让父进程读取的! !</p>\n<h3 id=\"%C2%A0echo%20%24%3F%20%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E9%80%80%E5%87%BA%E7%A0%81\"> echo $? 查看进程退出码</h3>\n<p><img alt=\"\" height=\"404\" src=\"image\\99d0141bee004001b5e81d7caf8ec0b0.png\" width=\"455\"/></p>\n<p> echo $? ：在bash中，最近一次执行完毕时，对应进程的退出码</p>\n<p>解释这里：第一次 echo $? 打印了进程退出码 123 ，第二次 echo $? 打印的是上一次 echo $?的进程退出码，因为上一次 echo $? 执行成功了，所以进程退出码是0,。</p>\n<p>一般而言，失败的非零值我该如何设置呢? ?以及默认表达的含义?<br/> 可以自定义，也可以用系统定义的sterror。<br/> 错误码退出码可以对应不同的错误原因，方便定位问题!</p>\n<h3 id=\"%EF%BC%882%EF%BC%89%E5%85%B3%E4%BA%8E%E7%BB%88%E6%AD%A2%E7%9A%84%E5%B8%B8%E8%A7%81%E5%81%9A%E6%B3%95%E2%80%94%E2%80%94exit()\">（2）关于终止的常见做法——exit()</h3>\n<p>1. <u>在main函数中return代表进程结束。其他非main 函数return 代表函数调用结束</u><br/> 2.在自己的代码任意地点中main函数/非main函数，调用exit()都叫进程退出，exit(X)中的X是退出码</p>\n<h3 id=\"%EF%BC%883%EF%BC%89exit%E5%92%8C_exit\">（3）exit和_exit</h3>\n<p>exit终止进程刷新缓冲区<br/> exit直接中止进程，不会有任何刷新操作</p>\n<p><u>终止进程推荐exit或main函数中的return。</u><br/><img alt=\"\" height=\"351\" src=\"image\\3a110feb97874feca6a582cfa606d446.png\" width=\"630\"/></p>\n<h3 id=\"%EF%BC%884%EF%BC%89%E5%85%B3%E4%BA%8E%E7%BB%88%E6%AD%A2%EF%BC%8C%E5%86%85%E6%A0%B8%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%3F\">（4）关于终止，内核做了什么?</h3>\n<p>进程 = 内核结构 + 进程代码 和 数据<br/> 进程代码 和 数据一定会释放，但是 task/struct &amp;&amp; mm_ struct:操作系统可能并不会释放该进程的内核数据结构<br/> 因为再次创建对象:1.开辟空间 2.初始化 都要花时间。<br/> linux会维护一张废弃的数据结构链表叫 obj，若释放进程，对应的进程的数据结构会被维护到这个链表中，这个链表没有释放空间，只是被设成无效，需要时就拿，节省开辟时间（这样的链表也称 内核的数据结构缓冲池，操作系统叫：slab分派器）</p>\n<p><img alt=\"\" height=\"194\" src=\"image\\17ca59bfa29a49c481c66d54caef6546.png\" width=\"500\"/></p>\n<h1 id=\"%E4%B8%89.%E8%BF%9B%E7%A8%8B%E7%AD%89%E5%BE%85\">三.<span style=\"color:#333333;\"><strong>进程等待</strong></span></h1>\n<h2 id=\"1.%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E8%BF%9B%E7%A8%8B%E7%AD%89%E5%BE%85\">1.为什么要进行进程等待</h2>\n<h3 id=\"%E2%91%A0%E4%B8%BA%E4%BA%86%E8%A7%A3%E5%86%B3%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98\"><span style=\"color:#494949;\">①为了解决僵尸进程内存泄漏问题</span></h3>\n<p><span style=\"color:#494949;\">子进程退出，父进程如果不管不顾，就可能造成‘僵尸进程’的问题，进而造成内存泄漏。进程一旦变成僵尸状态，那就刀枪不入，“杀人不眨眼”的kill -9 也无能为力。</span></p>\n<h3 id=\"%E2%91%A1%E4%B8%BA%E4%BA%86%E8%8E%B7%E5%8F%96%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%80%80%E5%87%BA%E7%8A%B6%E6%80%81\">②为了获取子进程的退出状态</h3>\n<div>\n<span style=\"color:#777777;\">父进程派给子进程的任务完成的如何，我们需要知道。如，子进程运行完成，结果对还是不对， </span>\n</div>\n<div>\n<span style=\"color:#777777;\">或者是否正常退出。 </span>\n</div>\n<p></p>\n<h2 id=\"2.wait%E4%B8%8Ewaitpid\">2.wait与waitpid</h2>\n<p>wait()的方案可以解决回收子进程z状态，让子进程进入X十<br/><img alt=\"\" height=\"193\" src=\"image\\a3be7cef3ccc4596bbfc0017887b1261.png\" width=\"745\"/></p>\n<p>pid_ t (int) 的返回值 :<br/> &gt;0:等待子进程成功，返回值就是子进程的pid<br/> &lt;0:等待失败</p>\n<p>第一个参数 pid:<br/> &gt;0:是几，就代表等待哪一个子进程退出，比如pid=1234， 指定等待<br/> -1:等待任意进程退出</p>\n<p>第三个参数 option:</p>\n<p>0:<span style=\"color:#956fe7;\"><strong>阻塞等待</strong></span>（就是父进程等待子进程死，子进程死后就回收它）</p>\n<p>当options被设置为WNOHANG则函数非阻塞，且当没有子进程退出时，waitpid返回0</p>\n<h3 id=\"int*%20status%EF%BC%9A%E6%98%AF%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0%EF%BC%8C%E9%87%8D%E7%82%B9%E8%AF%B4%EF%BC%9A%E5%8F%AA%E9%9C%80%E8%A6%81%E5%85%B3%E5%BF%83%E6%94%B9%E6%95%B4%E6%95%B0%E7%9A%84%E4%BD%8E16%E4%B8%AA%E6%AF%94%E7%89%B9%E4%BD%8D!\">int* status：是一个整数，重点说：只需要关心改整数的低16个比特位!</h3>\n<p><img alt=\"\" height=\"347\" src=\"image\\392e69df35254d3f94456f0fc9fb1194.png\" width=\"1190\"/></p>\n<h3 id=\"%EF%BC%881%EF%BC%89%E4%BD%8E16%E4%B8%AA%E6%AF%94%E7%89%B9%E4%BD%8D%E7%9A%84%E6%AC%A1%E4%BD%8E8%E6%AF%94%E7%89%B9%E4%BD%8D%EF%BC%88%E6%AC%A1%E4%BD%8E8%E6%AF%94%E7%89%B9%E4%BD%8D%EF%BC%89%20%E6%98%AF%E9%80%80%E5%87%BA%E7%A0%81\">（1）低16个比特位的次低8比特位（次低8比特位） 是退出码</h3>\n<p>证明：让子进程先睡眠5秒，然后退出，退出码设为0。子进程睡眠5秒期间父进程用 wait/waitpid 设成阻塞态，已知返回值：</p>\n<p><span style=\"color:#1c7331;\">pid_ t (int) 的返回值 :<br/> &gt;0:等待子进程成功，返回值就是子进程的pid<br/> &lt;0:等待失败</span></p>\n<p>利用ret接收返回值，当接收成功时，打印ret(这里的ret就是<span style=\"color:#494949;\">子进程的pid)，</span></p>\n<p><span style=\"color:#494949;\">并打印</span>(status&gt;&gt;8) &amp;0xFF ，status&gt;&gt;8是 次低8比特位开始，与上0xFF(8个1)，就是退出码。我们会发现status中的退出码确实记录了子进程的退出码</p>\n<p><img alt=\"\" height=\"1065\" src=\"image\\4afa6e0faa76408cafe6b836ac5b785e.png\" width=\"1200\"/></p>\n<h3 id=\"%EF%BC%882%EF%BC%89%E4%BD%8E8%E4%B8%AA%E6%AF%94%E7%89%B9%E4%BD%8D%E6%98%AF%E7%BB%88%E6%AD%A2%E4%BF%A1%E5%8F%B7\">（2）低8个比特位是终止信号</h3>\n<p><span style=\"color:#fe2c24;\"><strong>（kill -l 可查退出信号，异常就是因为收到信号，status&amp;0x7F 可打印终止信号）</strong></span></p>\n<p> <span style=\"color:#fe2c24;\"><strong>status&amp;0x7F：</strong></span>status的低8位与上111 1111 ，就可得到终止信号<img alt=\"\" height=\"347\" src=\"image\\392e69df35254d3f94456f0fc9fb1194.png\" width=\"1190\"/></p>\n<p><strong>没有0号信号：</strong></p>\n<p><img alt=\"\" height=\"485\" src=\"image\\bbf65b473f20497b97aa711e2bab2e74.png\" width=\"1200\"/></p>\n<p>另一个接收</p>\n<p></p>\n<div>\n<span style=\"color:#333333;\">WIFEXITED(status): </span>\n<span style=\"color:#333333;\">若为正常终止子进程返回的状态，则为真。（查看进程是否是正常退出） </span>\n</div>\n<div>\n<span style=\"color:#333333;\">WEXITSTATUS(status): </span>\n<span style=\"color:#333333;\">若</span>\n<span style=\"color:#333333;\">WIFEXITED</span>\n<span style=\"color:#333333;\">非零，提取子进程退出码。（查看进程的退出码）</span>\n</div>\n<div></div>\n<p><img alt=\"\" height=\"391\" src=\"image\\505718ec582045809584c9f767fb5517.png\" width=\"1099\"/></p>\n<p> <img alt=\"\" height=\"91\" src=\"image\\3a46b010268d42f198650a3e4f923cee.png\" width=\"468\"/></p>\n<p> waitpid():<br/> 阻塞等待和非阻塞等待</p>\n<p>当我们调用某些函数的时候，因为条件不就绪，需要我们阻塞等待，本质:就是当前进<br/> 程自己变成阻塞状态，等条件就绪的时候，在被唤醒!（这里的条件不就绪可能是任意的软硬件条件!）</p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n</div>\n</div>"}