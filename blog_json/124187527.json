{"blogid": "124187527", "writerAge": "码龄3年", "writerBlogNum": "23", "writerCollect": "126", "writerComment": "12", "writerFan": "11", "writerGrade": "2级", "writerIntegral": "302", "writerName": "Code_Xiaotian", "writerProfileAdress": "writer_image\\profile_124187527.jpg", "writerRankTotal": "47790", "writerRankWeekly": "87369", "writerThumb": "59", "writerVisitNum": "22438", "blog_read_count": "5180", "blog_time": "已于 2022-04-18 16:39:56 修改", "blog_title": "MyBatis Plus详细教程", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFMybatisPlus-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFMybatisPlus\">一、什么是MybatisPlus</a></p>\n<p id=\"%E4%BA%8C%E3%80%81%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BA%8C%E3%80%81%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8\">二、快速入门</a></p>\n<p id=\"1%E3%80%81%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93mybatis_plus-toc\" style=\"margin-left:40px;\"><a href=\"#1%E3%80%81%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93mybatis_plus\">2.1、创建数据库mybatis_plus</a></p>\n<p id=\"2%E3%80%81%E5%88%9B%E5%BB%BAuser%E8%A1%A8-toc\" style=\"margin-left:40px;\"><a href=\"#2%E3%80%81%E5%88%9B%E5%BB%BAuser%E8%A1%A8\">2.2、创建user表</a></p>\n<p id=\"3%E3%80%81%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE-toc\" style=\"margin-left:40px;\"><a href=\"#3%E3%80%81%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE\">2.3、插入数据</a></p>\n<p id=\"4%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B9%E7%9B%AE-toc\" style=\"margin-left:40px;\"><a href=\"#4%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B9%E7%9B%AE\">2.4、初始化项目</a></p>\n<p id=\"5%E3%80%81%E6%B7%BB%E5%8A%A0%E4%BE%9D%E8%B5%96-toc\" style=\"margin-left:40px;\"><a href=\"#5%E3%80%81%E6%B7%BB%E5%8A%A0%E4%BE%9D%E8%B5%96\">2.5、添加依赖</a></p>\n<p id=\"6%E3%80%81%E9%85%8D%E7%BD%AE(%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93)-toc\" style=\"margin-left:40px;\"><a href=\"#6%E3%80%81%E9%85%8D%E7%BD%AE%28%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%29\">2.6、配置(连接数据库)</a></p>\n<p id=\"7%E3%80%81%E7%BC%96%E7%A0%81-toc\" style=\"margin-left:40px;\"><a href=\"#7%E3%80%81%E7%BC%96%E7%A0%81\">2.7、编码</a></p>\n<p id=\"8%E3%80%81%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8-toc\" style=\"margin-left:40px;\"><a href=\"#8%E3%80%81%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8\">2.8、开始使用</a></p>\n<p id=\"9%E3%80%81%E5%B0%8F%E7%BB%93-toc\" style=\"margin-left:40px;\"><a href=\"#9%E3%80%81%E5%B0%8F%E7%BB%93\">2.9、小结</a></p>\n<p id=\"%E4%B8%89%E3%80%81%E9%85%8D%E7%BD%AE%E6%97%A5%E5%BF%97-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%89%E3%80%81%E9%85%8D%E7%BD%AE%E6%97%A5%E5%BF%97\">三、配置日志</a></p>\n<p id=\"%E2%80%8B-toc\" style=\"margin-left:0px;\"><a href=\"#%E2%80%8B\">​</a></p>\n<p id=\"%E5%9B%9B%E3%80%81CRUD-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%9B%9B%E3%80%81CRUD\">四、CRUD</a></p>\n<p id=\"4.1%E3%80%81%E6%8F%92%E5%85%A5%E6%B5%8B%E8%AF%95-toc\" style=\"margin-left:40px;\"><a href=\"#4.1%E3%80%81%E6%8F%92%E5%85%A5%E6%B5%8B%E8%AF%95\">4.1、插入测试</a></p>\n<p id=\"4.2%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89ID%E7%94%9F%E6%88%90%E5%99%A8-toc\" style=\"margin-left:40px;\"><a href=\"#4.2%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89ID%E7%94%9F%E6%88%90%E5%99%A8\">4.2、自定义ID生成器</a></p>\n<p id=\"4.2.1%E3%80%81UUID-toc\" style=\"margin-left:80px;\"><a href=\"#4.2.1%E3%80%81UUID\">4.2.1、UUID</a></p>\n<p id=\"4.2.2%E3%80%81SnowFlake%EF%BC%88%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95%EF%BC%89-toc\" style=\"margin-left:80px;\"><a href=\"#4.2.2%E3%80%81SnowFlake%EF%BC%88%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95%EF%BC%89\">4.2.2、SnowFlake（雪花算法）</a></p>\n<p id=\"4.3%E3%80%81%E6%9B%B4%E6%96%B0%E6%93%8D%E4%BD%9C-toc\" style=\"margin-left:40px;\"><a href=\"#4.3%E3%80%81%E6%9B%B4%E6%96%B0%E6%93%8D%E4%BD%9C\">4.3、更新操作</a></p>\n<p id=\"%E4%BA%94%E3%80%81%E8%87%AA%E5%8A%A8%E5%A1%AB%E5%85%85-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BA%94%E3%80%81%E8%87%AA%E5%8A%A8%E5%A1%AB%E5%85%85\">五、自动填充</a></p>\n<p id=\"1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E8%87%AA%E5%8A%A8%E5%A1%AB%E5%85%85-toc\" style=\"margin-left:40px;\"><a href=\"#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E8%87%AA%E5%8A%A8%E5%A1%AB%E5%85%85\">5.1、什么是自动填充</a></p>\n<p id=\"2%E3%80%81%E8%87%AA%E5%8A%A8%E5%A1%AB%E5%85%85%E6%96%B9%E5%BC%8F-toc\" style=\"margin-left:40px;\"><a href=\"#2%E3%80%81%E8%87%AA%E5%8A%A8%E5%A1%AB%E5%85%85%E6%96%B9%E5%BC%8F\">5.2、自动填充方式</a></p>\n<p id=\"%E5%85%AD%E3%80%81%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%85%AD%E3%80%81%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81\">六、乐观锁和悲观锁</a></p>\n<p id=\"6.1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E4%B9%90%E8%A7%82%E9%94%81-toc\" style=\"margin-left:40px;\"><a href=\"#6.1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E4%B9%90%E8%A7%82%E9%94%81\">6.1、什么是乐观锁</a></p>\n<p id=\"6.2%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%82%B2%E8%A7%82%E9%94%81-toc\" style=\"margin-left:40px;\"><a href=\"#6.2%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%82%B2%E8%A7%82%E9%94%81\">6.2、什么是悲观锁</a></p>\n<p id=\"6.3%E3%80%81%E9%85%8D%E7%BD%AE%E4%B9%90%E8%A7%82%E9%94%81-toc\" style=\"margin-left:40px;\"><a href=\"#6.3%E3%80%81%E9%85%8D%E7%BD%AE%E4%B9%90%E8%A7%82%E9%94%81\">6.3、配置乐观锁</a></p>\n<p id=\"6.3.1%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%B7%BB%E5%8A%A0version%E5%AD%97%E6%AE%B5-toc\" style=\"margin-left:80px;\"><a href=\"#6.3.1%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%B7%BB%E5%8A%A0version%E5%AD%97%E6%AE%B5\">6.3.1、数据库中添加version字段</a></p>\n<p id=\"6.3.2%E3%80%81%E5%90%8C%E6%AD%A5%E5%AE%9E%E4%BD%93%E7%B1%BB-toc\" style=\"margin-left:80px;\"><a href=\"#6.3.2%E3%80%81%E5%90%8C%E6%AD%A5%E5%AE%9E%E4%BD%93%E7%B1%BB\">6.3.2、同步实体类</a></p>\n<p id=\"6.3.3%E3%80%81%E9%85%8D%E7%BD%AE%E6%8F%92%E4%BB%B6-toc\" style=\"margin-left:80px;\"><a href=\"#6.3.3%E3%80%81%E9%85%8D%E7%BD%AE%E6%8F%92%E4%BB%B6\">6.3.3、配置插件</a></p>\n<p id=\"6.3.4%E3%80%81%E6%B5%8B%E8%AF%95%E4%B9%90%E8%A7%82%E9%94%81-toc\" style=\"margin-left:80px;\"><a href=\"#6.3.4%E3%80%81%E6%B5%8B%E8%AF%95%E4%B9%90%E8%A7%82%E9%94%81\">6.3.4、测试乐观锁</a></p>\n<p id=\"%E4%B8%83%E3%80%81%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%83%E3%80%81%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5\">七、增删改查</a></p>\n<p id=\"7.1%E3%80%81%E6%9F%A5%E8%AF%A2%E6%93%8D%E4%BD%9C-toc\" style=\"margin-left:40px;\"><a href=\"#7.1%E3%80%81%E6%9F%A5%E8%AF%A2%E6%93%8D%E4%BD%9C\">7.1、查询操作</a></p>\n<p id=\"7.2%E3%80%81%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2-toc\" style=\"margin-left:40px;\"><a href=\"#7.2%E3%80%81%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2\">7.2、分页查询</a></p>\n<p id=\"7.3%E3%80%81%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C-toc\" style=\"margin-left:40px;\"><a href=\"#7.3%E3%80%81%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C\">7.3、删除操作</a></p>\n<p id=\"7.4%E3%80%81%E9%80%BB%E8%BE%91%E5%88%A0%E9%99%A4-toc\" style=\"margin-left:40px;\"><a href=\"#7.4%E3%80%81%E9%80%BB%E8%BE%91%E5%88%A0%E9%99%A4\">7.4、逻辑删除</a></p>\n<p id=\"%E5%85%AB%E3%80%81%E6%89%A7%E8%A1%8CSQL%E5%88%86%E6%9E%90%E6%89%93%E5%8D%B0-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%85%AB%E3%80%81%E6%89%A7%E8%A1%8CSQL%E5%88%86%E6%9E%90%E6%89%93%E5%8D%B0\">八、执行SQL分析打印</a></p>\n<p id=\"8.1%E3%80%81p6spy%E4%BE%9D%E8%B5%96%E5%BC%95%E5%85%A5-toc\" style=\"margin-left:40px;\"><a href=\"#8.1%E3%80%81p6spy%E4%BE%9D%E8%B5%96%E5%BC%95%E5%85%A5\">8.1、p6spy依赖引入</a></p>\n<p id=\"8.2%E3%80%81application.yml%E9%85%8D%E7%BD%AE-toc\" style=\"margin-left:40px;\"><a href=\"#8.2%E3%80%81application.yml%E9%85%8D%E7%BD%AE\">8.2、application.yml配置</a></p>\n<p id=\"8.3%E3%80%81spy.properties%E9%85%8D%E7%BD%AE-toc\" style=\"margin-left:40px;\"><a href=\"#8.3%E3%80%81spy.properties%E9%85%8D%E7%BD%AE\">8.3、spy.properties配置</a></p>\n<p id=\"8.4%E3%80%81%E6%B5%8B%E8%AF%95-toc\" style=\"margin-left:40px;\"><a href=\"#8.4%E3%80%81%E6%B5%8B%E8%AF%95\">8.4、测试</a></p>\n<p id=\"%E4%B9%9D%E3%80%81%E6%9D%A1%E4%BB%B6%E6%9E%84%E9%80%A0%E5%99%A8-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B9%9D%E3%80%81%E6%9D%A1%E4%BB%B6%E6%9E%84%E9%80%A0%E5%99%A8\">九、条件构造器</a></p>\n<p id=\"9.1%E3%80%81%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA-toc\" style=\"margin-left:40px;\"><a href=\"#9.1%E3%80%81%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA\">9.1、代码演示</a></p>\n<p id=\"%E5%8D%81%E3%80%81%E4%BB%A3%E7%A0%81%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E5%99%A8-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%8D%81%E3%80%81%E4%BB%A3%E7%A0%81%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E5%99%A8\">十、代码自动生成器</a></p>\n<p id=\"10.1%E3%80%81EasyCode-toc\" style=\"margin-left:40px;\"><a href=\"#10.1%E3%80%81EasyCode\">10.1、EasyCode</a></p>\n<p id=\"10.2%E3%80%81%E5%8A%9F%E8%83%BD-toc\" style=\"margin-left:40px;\"><a href=\"#10.2%E3%80%81%E5%8A%9F%E8%83%BD\">10.2、功能</a></p>\n<p id=\"10.3%E3%80%81%E6%93%8D%E4%BD%9C-toc\" style=\"margin-left:40px;\"><a href=\"#10.3%E3%80%81%E6%93%8D%E4%BD%9C\">10.3、操作</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h1 id=\"%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFMybatisPlus\">一、什么是MybatisPlus</h1>\n<blockquote>\n<p>为什么要学MybatisPlus？</p>\n</blockquote>\n<p>MybatisPlus可以节省大量时间，所有的CRUD代码都可以自动化完成</p>\n<p>MyBatis-Plus是一个MyBatis的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。</p>\n<p><strong>特性：</strong></p>\n<ul><li> <p><strong>无侵入</strong>：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑</p> </li><li> <p><strong>损耗小</strong>：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作</p> </li><li> <p><strong>强大的 CRUD 操作</strong>：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求</p> </li><li> <p><strong>支持 Lambda 形式调用</strong>：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错</p> </li><li> <p><strong>支持主键自动生成</strong>：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题</p> </li><li> <p><strong>支持 ActiveRecord 模式</strong>：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作</p> </li><li> <p><strong>支持自定义全局通用操作</strong>：支持全局通用方法注入（ Write once, use anywhere ）</p> </li><li> <p><strong>内置代码生成器</strong>：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用</p> </li><li> <p><strong>内置分页插件</strong>：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询</p> </li><li> <p><strong>分页插件支持多种数据库</strong>：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库</p> </li><li> <p><strong>内置性能分析插件</strong>：可输出 SQL 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询</p> </li><li> <p><strong>内置全局拦截插件</strong>：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作</p> </li></ul>\n<h1 id=\"%E4%BA%8C%E3%80%81%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8\">二、快速入门</h1>\n<h2 id=\"1%E3%80%81%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93mybatis_plus\">2.1、创建数据库mybatis_plus</h2>\n<h2 id=\"2%E3%80%81%E5%88%9B%E5%BB%BAuser%E8%A1%A8\">2.2、创建user表</h2>\n<pre><code class=\"language-sql\">DROP TABLE IF EXISTS user;\n​\nCREATE TABLE user\n(\n    id BIGINT(20) NOT NULL COMMENT '主键ID',\n    name VARCHAR(30) NULL DEFAULT NULL COMMENT '姓名',\n    age INT(11) NULL DEFAULT NULL COMMENT '年龄',\n    email VARCHAR(50) NULL DEFAULT NULL COMMENT '邮箱',\n    PRIMARY KEY (id)\n);</code></pre>\n<h2 id=\"3%E3%80%81%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE\">2.3、插入数据</h2>\n<pre><code class=\"language-sql\">DELETE FROM user;\n​\nINSERT INTO user (id, name, age, email) VALUES\n(1, 'Jone', 18, 'test1@baomidou.com'),\n(2, 'Jack', 20, 'test2@baomidou.com'),\n(3, 'Tom', 28, 'test3@baomidou.com'),\n(4, 'Sandy', 21, 'test4@baomidou.com'),\n(5, 'Billie', 24, 'test5@baomidou.com');</code></pre>\n<h2 id=\"4%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B9%E7%9B%AE\">2.4、初始化项目</h2>\n<p>快速初始化一个空的spring boot 项目</p>\n<h2 id=\"5%E3%80%81%E6%B7%BB%E5%8A%A0%E4%BE%9D%E8%B5%96\">2.5、添加依赖</h2>\n<p>引用spring boot starter 父工程</p>\n<pre><code class=\"language-XML\">&lt;parent&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n    &lt;version&gt;2.6.5&lt;/version&gt;\n    &lt;relativePath/&gt;\n&lt;/parent&gt;</code></pre>\n<p>引入spring-boot-starter、spring-boot-starter-test、mybatis-plus-boot-starter、h2依赖：</p>\n<pre><code class=\"language-XML\">&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n        &lt;scope&gt;test&lt;/scope&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;com.baomidou&lt;/groupId&gt;\n        &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;\n        &lt;version&gt;3.5.1&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;mysql&lt;/groupId&gt;\n        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;</code></pre>\n<p>注意：尽量不要同时导入mybatis和mybatis_plus,版本差异</p>\n<h2 id=\"6%E3%80%81%E9%85%8D%E7%BD%AE(%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93)\">2.6、配置(连接数据库)</h2>\n<p>在application.yml配置文件中添加MySQL数据库的相关配置：</p>\n<pre><code class=\"language-XML\"># DataSource Config\nspring:\n  datasource:\n    username: root\n    password: 123456\n    url: jdbc:mysql:///mybatis_plus?userUnicode=true&amp;characterEncoding=utf-8\n    driver-class-name: com.mysql.cj.jdbc.Driver</code></pre>\n<pre>​</pre>\n<p>在spring boot启动类中添加@MapperScan注解，扫描Mapper文件夹：</p>\n<pre><code class=\"language-java\">@SpringBootApplication\n@MapperScan(\"com.wen.mybatis_plus.mapper\")  //扫描mapper\npublic class MybatisPlusApplication {\n​\n    public static void main(String[] args) {\n        SpringApplication.run(MybatisPlusApplication.class, args);\n    }\n​\n}</code></pre>\n<h2 id=\"7%E3%80%81%E7%BC%96%E7%A0%81\">2.7、编码</h2>\n<p>编写实体类User.java（此处使用Lombok简化代码）</p>\n<pre><code class=\"language-java\">import lombok.Data;\n​\n@Data\npublic class User {\n    private Long id;\n    private String name;\n    private Integer age;\n    private String email;\n}</code></pre>\n<p>编写Mapper包下的UserMapper接口</p>\n<pre><code class=\"language-java\">import com.baomidou.mybatisplus.core.mapper.BaseMapper;\nimport com.wen.mybatis_plus.pojo.User;\nimport org.apache.ibatis.annotations.Mapper;\n​\n//再对应的mapper上面实现基本的接口 BaseMapper\n@Mapper\npublic interface UserMapper extends BaseMapper&lt;User&gt; {\n    //所有的CRUD都已经完成\n    //不需要像以前一样配置一大堆文件：pojo-dao（连接mybatis，配置mapper.xml文件）==&gt;service-controller\n}</code></pre>\n<blockquote>\n<p><strong>注意：</strong></p>\n<p><strong>要在主启动类上去扫描mapper包下的所有接口：@MapperScan(\"com.wen.mybatis_plus.mapper\")</strong></p>\n</blockquote>\n<h2 id=\"8%E3%80%81%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8\">2.8、开始使用</h2>\n<p>添加测试类，进行功能测试：</p>\n<pre><code class=\"language-java\">@SpringBootTest\nclass MybatisPlusApplicationTests {\n​\n    //继承了BaseMapper所有的方法，可以编写自己的扩展方法\n    @Autowired\n    private UserMapper userMapper;\n​\n    @Test\n    public void testSelect(){\n        System.out.println(\"--------selectAll method test-------\");\n        //查询全部用户，参数是一个Wrapper，条件构造器，先不使用为null\n        List&lt;User&gt; userList = userMapper.selectList(null);\n        userList.forEach(System.out::println);\n    }</code></pre>\n<blockquote>\n<p><strong>提示：</strong></p>\n<p><strong>UserMapper中的selectList()方法的参数为MP内置的条件封装器Wrapper，所以不填写就是无任何条件</strong>。</p>\n</blockquote>\n<p>控制台输出：</p>\n<p>User(id=1, name=Jone, age=18, email=<a href=\"mailto:test1@baomidou.com\">test1@baomidou.com</a>) User(id=2, name=Jack, age=20, email=<a href=\"mailto:test2@baomidou.com\">test2@baomidou.com</a>) User(id=3, name=Tom, age=28, email=<a href=\"mailto:test3@baomidou.com\">test3@baomidou.com</a>) User(id=4, name=Sandy, age=21, email=<a href=\"mailto:test4@baomidou.com\">test4@baomidou.com</a>) User(id=5, name=Billie, age=24, email=<a href=\"mailto:test5@baomidou.com\">test5@baomidou.com</a>)</p>\n<h2 id=\"9%E3%80%81%E5%B0%8F%E7%BB%93\">2.9、小结</h2>\n<p>以上几个步骤就已经实现User表的CRUD功能，甚至连XML文件都不用编写，以上步骤可以看出集成MyBatis-Plus非常的简单，只需要引入starter工程，并配置mapper扫描路径即可。方法都是MyBatis-Plus写好的，直接引用即可。</p>\n<h1 id=\"%E4%B8%89%E3%80%81%E9%85%8D%E7%BD%AE%E6%97%A5%E5%BF%97\">三、配置日志</h1>\n<blockquote>\n<p>所有的SQL都是不可见的，所以在后台是希望看到SQL是怎么执行的，就必须要配置日志。</p>\n</blockquote>\n<p>在.yml配置文件中配置日志：</p>\n<pre><code class=\"language-XML\">#配置日志\nmybatis-plus:\n  configuration:\n    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl</code></pre>\n<p></p>\n<h1 id=\"%E2%80%8B\"><img alt=\"\" height=\"333\" src=\"image\\806ff53d97dc4a148112068243e834e6.png\" width=\"840\"/></h1>\n<p></p>\n<h1 id=\"%E5%9B%9B%E3%80%81CRUD\">四、CRUD</h1>\n<h2 id=\"4.1%E3%80%81%E6%8F%92%E5%85%A5%E6%B5%8B%E8%AF%95\">4.1、插入测试</h2>\n<pre><code class=\"language-java\">//测试插入\n@Test\npublic void testInsert(){\n    User user = new User();\n    user.setName(\"小文\");\n    user.setAge(21);\n    user.setEmail(\"2312103645@qq.com\");\n​\n    int insert = userMapper.insert(user);//如果没有设置id，那么会自动生成id\n    System.out.println(insert);//受影响行数\n    System.out.println(user);//id会自动回填\n}</code></pre>\n<p> <img alt=\"\" height=\"231\" src=\"image\\1cc5dce6bf354dd88290d5c6b6d6734f.png\" width=\"1135\"/></p>\n<p></p>\n<p></p>\n<blockquote>\n<p>数据库插入ID默认值为全局唯一ID</p>\n</blockquote>\n<h2 id=\"4.2%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89ID%E7%94%9F%E6%88%90%E5%99%A8\">4.2、自定义ID生成器</h2>\n<p>在复杂分布式系统中，往往需要大量的数据和消息进行唯一标识。比如支付宝每一个账号在数据库分表后都需要有一个<strong>唯一</strong>ID做标识。此时一个能够生成全局唯一ID的系统是非常必要的。</p>\n<p>所以，生成的ID需要具备一下特点：</p>\n<ol><li> <p>全局唯一性：不能出现重复的ID号，既然是唯一标识，这是最基本的要求。</p> </li><li> <p>趋势递增：在MySQL InnoDB引擎中使用的是聚集索引，由于多数RDBMS使用B-tree的数据结构来存储索引数据，在主键的选择上面我们应该尽量使用有序的主键保证写入性能。</p> </li><li> <p>单调递增：保证下一个ID一定大于上一个ID，例如事务版本号、IM增量消息、排序等特殊需求。</p> </li><li> <p>信息安全：如果ID是连续的，恶意用户的扒取工作就非常容易做了，直接按照顺序下载指定URL即可；如果是订单号就更危险了，竞对可以直接知道我们一天的单量。所以在一些应用场景下，会需要ID无规则、不规则。</p> </li></ol>\n<blockquote>\n<p>上述123对应三类不同的场景，3和4需求还是互斥的，无法使用同一个方案满足。</p>\n</blockquote>\n<blockquote>\n<p>在这里只讲两种自动生成ID的方案UUID和SnowFlake</p>\n</blockquote>\n<p>可以查看有哪些方法，查看源码：</p>\n<p>在用户ID上添加@TableId注解，里面的值便是使用主键自动生成的方法</p>\n<blockquote>\n<p>自 3.3.0 开始,默认使用雪花算法+UUID(不含中划线)</p>\n</blockquote>\n<pre><code class=\"language-java\">@Data\npublic class User {\n    //对应数据库中的主键（UUID、自增id、雪花算法、redis、zookeeper）\n    @TableId(type = IdType.ASSIGN_ID)\n    private Long id;\n    private String name;\n    private Integer age;\n    private String email;\n}</code></pre>\n<blockquote>\n<p>点击 IdType查看源码看有哪些自动生成方法</p>\n</blockquote>\n<pre><code class=\"language-java\">/**\n * 生成ID类型枚举类\n *\n * @author hubin\n * @since 2015-11-10\n */\n@Getter\npublic enum IdType {\n    /**\n     * 数据库ID自增\n     * &lt;p&gt;该类型请确保数据库设置了 ID自增 否则无效&lt;/p&gt;\n     */\n    AUTO(0),\n    /**\n     * 该类型为未设置主键类型(注解里等于跟随全局,全局里约等于 INPUT)\n     */\n    NONE(1),\n    /**\n     * 用户输入ID\n     * &lt;p&gt;该类型可以通过自己注册自动填充插件进行填充&lt;/p&gt;\n     */\n    INPUT(2),\n​\n    /* 以下3种类型、只有当插入对象ID 为空，才自动填充。 */\n    /**\n     * 分配ID (主键类型为number或string）,\n     * 默认实现类 {@link com.baomidou.mybatisplus.core.incrementer.DefaultIdentifierGenerator}(雪花算法)\n     *\n     * @since 3.3.0\n     */\n    ASSIGN_ID(3),\n    /**\n     * 分配UUID (主键类型为 string)\n     * 默认实现类 {@link com.baomidou.mybatisplus.core.incrementer.DefaultIdentifierGenerator}(UUID.replace(\"-\",\"\"))\n     */\n    ASSIGN_UUID(4);\n​\n    private final int key;\n​\n    IdType(int key) {\n        this.key = key;\n    }\n}   </code></pre>\n<h3 id=\"4.2.1%E3%80%81UUID\">4.2.1、UUID</h3>\n<p>UUID(Universally Unique Identifier)的标准型式包含32个16进制数字，以连字号分为五段，形式为8-4-4-4-12的36个字符，示例：<code>550e8400-e29b-41d4-a716-446655440000</code>，到目前为止业界一共有5种方式生成UUID，详情见IETF发布的UUID规范 <a href=\"http://www.ietf.org/rfc/rfc4122.txt\" title=\"A Universally Unique IDentifier (UUID) URN Namespace\">A Universally Unique IDentifier (UUID) URN Namespace</a>。</p>\n<p>优点：</p>\n<ul><li> <p>性能非常高：本地生成，没有网络消耗。</p> </li></ul>\n<p>缺点：</p>\n<ul><li> <p>没有排序，无法保证趋势递增。</p> </li><li> <p>UUID往往使用字符串存储，查询的效率比较低。</p> </li><li> <p>不易于存储：UUID太长，16字节128位，通常以36长度的字符串表示，很多场景不适用。</p> </li><li> <p>信息不安全：基于MAC地址生成UUID的算法可能会造成MAC地址泄露，这个漏洞曾被用于寻找梅丽莎病毒的制作者位置。</p> </li><li> <p>ID作为主键时在特定的环境会存在一些问题，比如做DB主键的场景下，UUID就非常不适用：</p>\n<ul><li> <p>MySQL官方有明确的建议主键要尽量越短越好[4]，36个字符长度的UUID不符合要求。</p> </li><li> <p>对MySQL索引不利：如果作为数据库主键，在InnoDB引擎下，UUID的无序性可能会引起数据位置频繁变动，严重影响性能。</p> </li></ul></li></ul>\n<h3 id=\"4.2.2%E3%80%81SnowFlake%EF%BC%88%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95%EF%BC%89\">4.2.2、SnowFlake（雪花算法）</h3>\n<p>这种方案大致来说是一种以划分命名空间（UUID也算，由于比较常见，所以单独分析）来生成ID的一种算法，这种方案把64-bit分别划分成多段，分开来标示机器、时间等，比如在snowflake中的64-bit分别表示如下图（图片来自网络）所示：</p>\n<p><img alt=\"\" height=\"149\" src=\"image\\a57dd106bc1a4f68bbb48aff6974c358.png\" width=\"645\"/></p>\n<p></p>\n<p></p>\n<p>41-bit的时间可以表示（1L&lt;&lt;41）/(1000L<em>3600</em>24*365)=69年的时间，10-bit机器可以分别表示1024台机器。如果我们对IDC划分有需求，还可以将10-bit分5-bit给IDC，分5-bit给工作机器。这样就可以表示32个IDC，每个IDC下可以有32台机器，可以根据自身需求定义。12个自增序列号可以表示2^12个ID，理论上snowflake方案的QPS约为409.6w/s，这种分配方式可以保证在任何一个IDC的任何一台机器在任意毫秒内生成的ID都是不同的。</p>\n<blockquote>\n<p>核心思想：</p>\n<p>使用41bit作为毫秒数，10bit作为机器的ID(5个bit是数据中心，5个bit的机器ID)，12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生4096个ID），最后还有一个符号位，永远是0,。</p>\n</blockquote>\n<p>优点：</p>\n<ul><li> <p>毫秒数在高位，自增序列在低位，整个ID都是趋势递增的。</p> </li><li> <p>不依赖数据库等第三方系统，以服务的方式部署，稳定性更高，生成ID的性能也是非常高的。</p> </li><li> <p>可以根据自身业务特性分配bit位，非常灵活。</p> </li></ul>\n<p>缺点：</p>\n<ul><li> <p>强依赖机器时钟，如果机器上时钟回拨，会导致发号重复或者服务会处于不可用状态。</p> </li></ul>\n<h2 id=\"4.3%E3%80%81%E6%9B%B4%E6%96%B0%E6%93%8D%E4%BD%9C\">4.3、更新操作</h2>\n<blockquote>\n<p>所有的SQL都是自动配置的</p>\n</blockquote>\n<pre><code class=\"language-java\">//测试更新\n@Test\npublic void testUpdate(){\n    User user = new User();\n    //可以通过条件自动拼接动态SQL\n    user.setId(5L);\n    user.setName(\"id:5,修改过后\");\n    //updateById 参数是一个对象！\n    int i = userMapper.updateById(user);\n    System.out.println(i);\n}</code></pre>\n<blockquote>\n<p>注意：updateById 参数是一个对象！而不是ID</p>\n</blockquote>\n<p><img alt=\"\" height=\"188\" src=\"image\\5a1e2b3cef424b3b9f8c6b62164e0e14.png\" width=\"360\"/></p>\n<p></p>\n<p></p>\n<p><img alt=\"\" height=\"86\" src=\"image\\658d373b8b4b4496b62779065b43dfe6.png\" width=\"1086\"/></p>\n<p> <img alt=\"\" height=\"154\" src=\"image\\b2fe11e128064f2ca1399cebcc31145b.png\" width=\"665\"/></p>\n<p></p>\n<p></p>\n<h1 id=\"%E4%BA%94%E3%80%81%E8%87%AA%E5%8A%A8%E5%A1%AB%E5%85%85\">五、自动填充</h1>\n<h2 id=\"1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E8%87%AA%E5%8A%A8%E5%A1%AB%E5%85%85\">5.1、什么是自动填充</h2>\n<p>在常用业务中有些属性需要配置一些默认值，MyBatis-Plus提供了实现此功能的插件,也就是自动填充功能。比如创建时间、修改时间这些操作一般都是自动化完成的，是不用去手动更新的。</p>\n<h2 id=\"2%E3%80%81%E8%87%AA%E5%8A%A8%E5%A1%AB%E5%85%85%E6%96%B9%E5%BC%8F\">5.2、自动填充方式</h2>\n<blockquote>\n<p><strong>方式一：数据库级别（不建议使用）</strong></p>\n</blockquote>\n<p>1、在表中新增字段create_time,update_time</p>\n<p><img alt=\"\" height=\"445\" src=\"image\\9f83655dbea24312829ce17e7a9dfb3c.png\" width=\"861\"/></p>\n<p></p>\n<p></p>\n<blockquote>\n<p>注意：在create_time里除了没有勾选根据当前时间戳更新外其他步骤都一样！</p>\n</blockquote>\n<p>2、在此测试插入方法，需要将实体类同步！！</p>\n<pre><code class=\"language-java\">private Data createTime;\nprivate Data updateTime;</code></pre>\n<p>3、在此更新查看</p>\n<pre><code class=\"language-java\">//测试更新\n@Test\npublic void testUpdate(){\n    User user = new User();\n    //可以通过条件自动拼接动态SQL\n    user.setId(5l);\n    user.setName(\"id:5,修改过后\");\n    user.setAge(25);\n    //updateById 参数是一个对象！\n    int i = userMapper.updateById(user);\n    System.out.println(i);\n}</code></pre>\n<p>4、查看时间戳是否更新</p>\n<p><img alt=\"\" height=\"206\" src=\"image\\4c4ce5cfa40b47ef975b2a2101b47fe8.png\" width=\"1113\"/></p>\n<p></p>\n<p></p>\n<blockquote>\n<p><strong>方式二：代码级别</strong> </p>\n</blockquote>\n<p>1、删除数据库的默认值，更新操作</p>\n<p><img alt=\"\" height=\"438\" src=\"image\\b7ffb03b31ae46e6b818e826993d0d5a.png\" width=\"847\"/></p>\n<p></p>\n<p></p>\n<p>2、注解填充字段 <code>@TableField(.. fill = FieldFill.INSERT)</code> 生成器策略部分也可以配置！</p>\n<pre><code class=\"language-java\">//注解填充字段 @TableField(.. fill = FieldFill.INSERT) 生成器策略部分也可以配置！\n@TableField(fill = FieldFill.INSERT)\nprivate Data createTime;\n@TableField(fill = FieldFill.INSERT_UPDATE)\nprivate Data updateTime;</code></pre>\n<p>3、自定义实现类 MyMetaObjectHandler 处理这个注解</p>\n<p><img alt=\"\" height=\"173\" src=\"image\\a2b678b5a0e040e19cd882203bc6b430.png\" width=\"210\"/></p>\n<p></p>\n<p></p>\n<pre><code class=\"language-java\">@Slf4j\n@Component\npublic class MyMetaObjectHandler implements MetaObjectHandler {\n    //插入时的填充策略\n    @Override\n    public void insertFill(MetaObject metaObject) {\n        log.info(\"start intsert fill ....\");\n        //strictInsertFill(MetaObject metaObject, String fieldName, Class&lt;T&gt; fieldType, E fieldVal)\n        this.strictInsertFill(metaObject,\"createTime\", LocalDateTime.class,LocalDateTime.now());// 起始版本 3.3.0(推荐使用)\n    }\n​\n    //更新时的填充策略\n    @Override\n    public void updateFill(MetaObject metaObject) {\n        log.info(\"start update fill ....\");\n        this.strictUpdateFill(metaObject, \"updateTime\", LocalDateTime.class, LocalDateTime.now()); // 起始版本 3.3.0(推荐)\n    }\n}</code></pre>\n<h1 id=\"%E5%85%AD%E3%80%81%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81\">六、乐观锁和悲观锁</h1>\n<h2 id=\"6.1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E4%B9%90%E8%A7%82%E9%94%81\">6.1、什么是乐观锁</h2>\n<blockquote>\n<p>乐观锁：十分乐观，认为不会出现问题，无论干什么都不会去上锁，如果出现问题，就再次更新测试值</p>\n</blockquote>\n<p>乐观锁是对于数据冲突保持一种乐观态度，操作数据时不会对操作的数据进行加锁（这使得多个任务可以并行的对数据进行操作），只有到数据提交的时候才通过一种机制来验证数据是否存在冲突(一般实现方式是通过加版本号然后进行版本号的对比方式实现);</p>\n<p>特点：乐观锁是一种并发类型的锁，其本身不对数据进行加锁而是通过业务实现锁的功能，不对数据进行加锁就意味着允许多个请求同时访问数据，同时也省掉了对数据加锁和解锁的过程，这种方式因为节省了悲观锁加锁的操作，所以可以一定程度的的提高操作的性能，不过在并发非常高的情况下，会导致大量的请求冲突，冲突导致大部分操作无功而返而浪费资源，所以在高并发的场景下，乐观锁的性能却反而不如悲观锁。</p>\n<h2 id=\"6.2%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%82%B2%E8%A7%82%E9%94%81\">6.2、什么是悲观锁</h2>\n<blockquote>\n<p>悲观锁：十分悲观，认为总是出现问题，无论干什么都会上锁，再去操作</p>\n</blockquote>\n<p>悲观锁是基于一种悲观的态度类来防止一切数据冲突，它是以一种预防的姿态在修改数据之前把数据锁住，然后再对数据进行读写，在它释放锁之前任何人都不能对其数据进行操作，直到前面一个人把锁释放后下一个人数据加锁才可对数据进行加锁，然后才可以对数据进行操作，一般数据库本身锁的机制都是基于悲观锁的机制实现的;</p>\n<p>特点：可以完全保证数据的独占性和正确性，因为每次请求都会先对数据进行加锁， 然后进行数据操作，最后再解锁，而加锁释放锁的过程会造成消耗，所以性能不高;</p>\n<h2 id=\"6.3%E3%80%81%E9%85%8D%E7%BD%AE%E4%B9%90%E8%A7%82%E9%94%81\">6.3、配置乐观锁</h2>\n<blockquote>\n<p>本文主要讲解乐观锁机制</p>\n</blockquote>\n<p>乐观锁实现方式：</p>\n<ul><li> <p>取出记录时，获取当前version</p> </li><li> <p>更新时，带上这个version</p> </li><li> <p>执行更新时，set version = newVersion where version = oldVersion</p> </li><li> <p>如果version不对，就更新失败</p> </li></ul>\n<blockquote>\n<p>当要更新一条记录时，是希望这条记录没有被更新的</p>\n</blockquote>\n<pre><code class=\"language-sql\">-- 乐观锁：1、先查询，获取版本号 version=1\n-- A线程\nupdate user name = \"tian\" ,version = version +1\nwhere id = 2 and version = 1\n-- 如果B线程抢先完成，这个时候version=2，就会导致A线程修改失败\n-- B线程\nupdate user name = \"tian\" ,version = version +1\nwhere id = 2 and version = 1</code></pre>\n<blockquote>\n<p>测试MP的乐观锁插件</p>\n</blockquote>\n<h3 id=\"6.3.1%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%B7%BB%E5%8A%A0version%E5%AD%97%E6%AE%B5\">6.3.1、数据库中添加version字段</h3>\n<p><img alt=\"\" height=\"513\" src=\"image\\951bb3483d174467b471f13d4430ff9a.png\" width=\"892\"/></p>\n<p></p>\n<p></p>\n<p>添加完成后查看是否更改完成</p>\n<p><img alt=\"\" height=\"263\" src=\"image\\69d804dd10114e4d9482c8ed48682f1a.png\" width=\"1175\"/></p>\n<p></p>\n<p></p>\n<h3 id=\"6.3.2%E3%80%81%E5%90%8C%E6%AD%A5%E5%AE%9E%E4%BD%93%E7%B1%BB\">6.3.2、同步实体类</h3>\n<blockquote>\n<p>记得在实体类上加上@Version注解</p>\n</blockquote>\n<pre><code class=\"language-java\">@Version    //乐观锁version注解\nprivate Integer version;</code></pre>\n<p><img alt=\"\" height=\"389\" src=\"image\\85cdb4d950484a2eb33ffb7ef2cdd58a.png\" width=\"661\"/></p>\n<p></p>\n<p></p>\n<h3 id=\"6.3.3%E3%80%81%E9%85%8D%E7%BD%AE%E6%8F%92%E4%BB%B6\">6.3.3、配置插件</h3>\n<p>spring xml 方式：</p>\n<pre><code class=\"language-XML\">&lt;bean class=\"com.baomidou.mybatisplus.extension.plugins.inner.OptimisticLockerInnerInterceptor\" id=\"optimisticLockerInnerInterceptor\"/&gt;\n​\n&lt;bean id=\"mybatisPlusInterceptor\" class=\"com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor\"&gt;\n    &lt;property name=\"interceptors\"&gt;\n        &lt;list&gt;\n            &lt;ref bean=\"optimisticLockerInnerInterceptor\"/&gt;\n        &lt;/list&gt;\n    &lt;/property&gt;\n&lt;/bean&gt;</code></pre>\n<pre>​</pre>\n<blockquote>\n<p>这里讲解的是springboot的注解方式</p>\n</blockquote>\n<p>spring boot 的注解方式</p>\n<pre><code class=\"language-java\">@Bean\npublic MybatisPlusInterceptor mybatisPlusInterceptor() {\n    MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();\n    interceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor());\n    return interceptor;\n}</code></pre>\n<p>首先创建配置类文件config，在该文件下创建配置类MyBatisPlusConfig，该类需要添加三个注解：</p>\n<pre><code class=\"language-java\">@Configuration  //配置类\n@MapperScan(\"com.wen.mybatis_plus.mapper\")  //扫描mapper\n@EnableTransactionManagement    //自动管理事务，默认是开启的</code></pre>\n<blockquote>\n<p>@MapperScan()是将原先MybatisPlusApplication中的扫描换到这里的,所以MybatisPlusApplication中就不需要@MapperScan()，在该配置类里添加@MapperScan()即可</p>\n</blockquote>\n<p>创建完MyBatisPlusConfig类并添加完注解后，就可以将上面的组件的注解方式填入进来</p>\n<pre><code class=\"language-java\">@Configuration  //配置类\n@MapperScan(\"com.wen.mybatis_plus.mapper\")  //扫描mapper\n@EnableTransactionManagement\npublic class MyBatisPlusConfig {\n    //注册乐观锁插件\n    @Bean\n    public MybatisPlusInterceptor mybatisPlusInterceptor() {\n        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();\n        interceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor());\n        return interceptor;\n    }\n}</code></pre>\n<p>此时乐观锁就已经配置完成了！</p>\n<p><img alt=\"\" height=\"506\" src=\"image\\7b54e94718504fc2bf0955a4ddbec7ac.png\" width=\"1170\"/></p>\n<p></p>\n<p></p>\n<h3 id=\"6.3.4%E3%80%81%E6%B5%8B%E8%AF%95%E4%B9%90%E8%A7%82%E9%94%81\">6.3.4、测试乐观锁</h3>\n<p>在测试类中分别对成功与失败进行测试</p>\n<p>测试成功：</p>\n<pre><code class=\"language-java\">//测试成功的乐观锁\n@Test\nvoid testOptimisticLocker_success() {\n    //1.查询用户信息\n    User user = userMapper.selectById(1l);\n    //2.修改用户信息\n    user.setName(\"tian\");\n    user.setAge(21);\n    //3.执行更新操作\n    userMapper.updateById(user);\n}</code></pre>\n<p>结果如下：</p>\n<p><img alt=\"\" height=\"413\" src=\"image\\6a5824ec48ab493dbdad2e41e1aab84e.png\" width=\"1200\"/></p>\n<p></p>\n<p></p>\n<p>测试失败：</p>\n<blockquote>\n<p>模拟多线程的方式执行插队操作</p>\n</blockquote>\n<pre><code class=\"language-java\">@Test\nvoid testOptimisticLocker_failure() {\n    //模拟多线程实现插队效果\n    //线程1\n    User user = userMapper.selectById(1l);\n    user.setName(\"tian\");\n    user.setAge(21);\n    //线程2\n    User user2 = userMapper.selectById(1l);\n    user2.setName(\"xiaotian\");\n    user2.setAge(19);\n    userMapper.updateById(user2);   //在这里插队\n​\n    userMapper.updateById(user);    //如果没有乐观锁就会覆盖插队线程的值\n}</code></pre>\n<p>查看控制台输出：</p>\n<p><img alt=\"\" height=\"824\" src=\"image\\fa46eb7d1b52445eae2e4474142314af.png\" width=\"1200\"/></p>\n<p></p>\n<p>从数据库看结果：</p>\n<p><img alt=\"\" height=\"223\" src=\"image\\2e609a51628348c1b882abd375cd86d4.png\" width=\"759\"/></p>\n<p></p>\n<h1 id=\"%E4%B8%83%E3%80%81%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5\">七、增删改查</h1>\n<h2 id=\"7.1%E3%80%81%E6%9F%A5%E8%AF%A2%E6%93%8D%E4%BD%9C\">7.1、查询操作</h2>\n<p>1.通过Id查询用户</p>\n<pre><code class=\"language-java\">//测试查询\n@Test\npublic void testSelectById(){\n    User user = userMapper.selectById(1L);\n    System.out.println(user);\n}</code></pre>\n<p>结果：</p>\n<p><img alt=\"\" height=\"119\" src=\"image\\934e909b18864aa7824f32c9db419c53.png\" width=\"807\"/></p>\n<p></p>\n<p>2.批量查询</p>\n<pre><code class=\"language-java\">//批量查询\n@Test\npublic void selectBatchIds(){\n    List&lt;User&gt; users = userMapper.selectBatchIds(Arrays.asList(1, 2, 3));\n    users.forEach(System.out::println);\n}</code></pre>\n<blockquote>\n<p>批量查询通过selectBatchIds方法，方法内放入的是集合，可以通过源码看</p>\n</blockquote>\n<p>selectBatchIds方法源码：</p>\n<pre><code class=\"language-java\">/**\n * 查询（根据ID 批量查询）\n *\n * @param idList 主键ID列表(不能为 null 以及 empty)\n */\nList&lt;T&gt; selectBatchIds(@Param(Constants.COLLECTION) Collection&lt;? extends Serializable&gt; idList);</code></pre>\n<blockquote>\n<p>可以看到参数是Collection也就是集合，这里使用的是Arrays集合</p>\n</blockquote>\n<p>结果：<img alt=\"\" height=\"196\" src=\"image\\4d744ff6790e42659490d1a70197cbf3.png\" width=\"1094\"/></p>\n<p></p>\n<p>3.条件查询</p>\n<blockquote>\n<p>通过自定义条件查询</p>\n</blockquote>\n<pre><code class=\"language-java\">//条件查询\n@Test\npublic void selectByMap(){\n    HashMap&lt;String,Object&gt; map = new HashMap&lt;&gt;();\n    //自定义查询\n    map.put(\"name\",\"小文\");\n    map.put(\"age\",20);\n    List&lt;User&gt; users = userMapper.selectByMap(map);\n    users.forEach(System.out::println);\n}</code></pre>\n<blockquote>\n<p>可以看出，map类的参数（字段名，参数）会被MySQLPlus自动组合成查询条件</p>\n</blockquote>\n<p> <img alt=\"\" height=\"142\" src=\"image\\a83bc0fc21af48bca732a71372d2867e.png\" width=\"1069\"/></p>\n<p></p>\n<p></p>\n<h2 id=\"7.2%E3%80%81%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2\">7.2、分页查询</h2>\n<ul><li> <p>原始的limit进行分页</p> </li><li> <p>pageHelper第三方插件</p> </li><li> <p>MyBatisPlus内置分页插件</p> </li></ul>\n<blockquote>\n<p>支持数据库：</p>\n</blockquote>\n<ul><li> <p>mysql，oracle，db2，h2，hsql，sqlite，postgresql，sqlserver，Phoenix，Gauss ，clickhouse，Sybase，OceanBase，Firebird，cubrid，goldilocks，csiidb</p> </li><li> <p>达梦数据库，虚谷数据库，人大金仓数据库，南大通用(华库)数据库，南大通用数据库，神通数据库，瀚高数据库</p> </li></ul>\n<blockquote>\n<p>属性介绍</p>\n</blockquote>\n<table><thead><tr><th>属性名</th><th>类型</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>overflow</td><td>boolean</td><td>false</td><td>溢出总页数后是否进行处理(默认不处理)</td></tr><tr><td>maxLimit</td><td>Long</td><td></td><td>单页分页条数限制(默认无限制)</td></tr><tr><td>dbType</td><td>DbType</td><td></td><td>数据库类型(根据类型获取应使用的分页方言)</td></tr><tr><td>dialect</td><td>IDialect</td><td></td><td>方言实现类</td></tr></tbody></table>\n<blockquote>\n<p>建议单一数据库类型的均设置 dbType</p>\n</blockquote>\n<p></p>\n<blockquote>\n<p>如何使用MyBatisPlus内页插件？</p>\n</blockquote>\n<p>1、配置拦截器组件即可</p>\n<pre><code class=\"language-java\">/**\n * 注册插件\n */\n@Bean\npublic MybatisPlusInterceptor paginationInterceptor() {\n​\n    MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();\n    // 添加分页插件\n    PaginationInnerInterceptor pageInterceptor = new PaginationInnerInterceptor();\n    // 设置请求的页面大于最大页后操作，true调回到首页，false继续请求。默认false\n    pageInterceptor.setOverflow(false);\n    // 单页分页条数限制，默认无限制\n    pageInterceptor.setMaxLimit(500L);\n    // 设置数据库类型\n    pageInterceptor.setDbType(DbType.MYSQL);\n​\n    interceptor.addInnerInterceptor(pageInterceptor);\n    return interceptor;\n}</code></pre>\n<p>2、分页组件测试</p>\n<pre><code class=\"language-java\">//测试MybatisPlus分页插件\n@Test\npublic void testMybatisPlus_Page(){\n    // 两个参数：current的值默认是1，从1开始，不是0。size是每一页的条数。\n    Page&lt;User&gt; page = new Page&lt;&gt;(1, 4);\n    userMapper.selectPage(page,null);\n    page.getRecords().forEach(System.out::println);\n}</code></pre>\n<p>结果分析：</p>\n<p><img alt=\"\" height=\"346\" src=\"image\\b3da6fd28d50463896a9d20d629c9698.png\" width=\"1139\"/></p>\n<p></p>\n<p>查询第二页试试看</p>\n<p><img alt=\"\" height=\"263\" src=\"image\\76e566fdbc4c44458ad358f7dea1de9e.png\" width=\"1136\"/></p>\n<p></p>\n<blockquote>\n<p>除此之外，Page 的方法还有很多比如：</p>\n</blockquote>\n<pre><code class=\"language-java\">//page的其他方法\nSystem.out.println(\"当前页：\" + page.getCurrent());\nSystem.out.println(\"总页数：\" + page.getPages());\nSystem.out.println(\"记录数：\" + page.getTotal());\nSystem.out.println(\"是否有上一页：\" + page.hasPrevious());\nSystem.out.println(\"是否有下一页：\" + page.hasNext());</code></pre>\n<p>结果：</p>\n<p> <img alt=\"\" height=\"313\" src=\"image\\67d5254e96b7463ba6086df58c91b4bf.png\" width=\"987\"/></p>\n<p></p>\n<h2 id=\"7.3%E3%80%81%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C\">7.3、删除操作</h2>\n<blockquote>\n<p>跟查询操作相似，就不详细讲解，直接上代码了</p>\n</blockquote>\n<pre><code class=\"language-java\">//测试删除\n@Test\npublic void testDeleteById(){\n    userMapper.deleteById(4L);\n}\n​\n//批量删除\n@Test\npublic void testDeleteBatchId(){\n    userMapper.deleteBatchIds(Arrays.asList(1L,2L));\n}\n​\n//通过map删除\n@Test\npublic void testdeleteByMap(){\n    Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();\n    map.put(\"name\",\"xiaotian\");\n    userMapper.deleteByMap(map);\n}</code></pre>\n<h2 id=\"7.4%E3%80%81%E9%80%BB%E8%BE%91%E5%88%A0%E9%99%A4\">7.4、逻辑删除</h2>\n<blockquote>\n<p>物理删除：从数据库中直接删除</p>\n<p>逻辑删除：在数据库中没有被删除，而是通过一个变量来让它失效。 deleted=0 ==》deleted=1</p>\n</blockquote>\n<p>管理员可以查看被删除的记录，防止数据丢失，相当于回收站。</p>\n<p>测试：</p>\n<p>1、在数据表中增加一个deleted字段</p>\n<p><img alt=\"\" height=\"437\" src=\"image\\5d0b7569ac3f4327a968aacf6091bb83.png\" width=\"892\"/></p>\n<p></p>\n<p>2、同步实体类，在实体类上加上@TableLogic 注解</p>\n<pre><code class=\"language-java\">@TableLogic //逻辑删除\nprivate Integer deleted;</code></pre>\n<p>3、配置application.yml文件</p>\n<pre><code class=\"language-XML\">#配置日志\nmybatis-plus:\n  global-config:\n    db-config:\n      logic-delete-field: flag # 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置步骤2)\n      logic-delete-value: 1 # 逻辑已删除值(默认为 1)\n      logic-not-delete-value: 0 # 逻辑未删除值(默认为 0)</code></pre>\n<p>4、测试</p>\n<p>在这里直接使用之前的delete测试</p>\n<pre><code class=\"language-java\">//测试删除\n@Test\npublic void testDeleteById(){\n    userMapper.deleteById(4L);\n}</code></pre>\n<blockquote>\n<p>查看日志输出可以看到，delete的语句以经发生了更改</p>\n<p>实质上就是update（修改）语句，将deleted字段从1修改为0</p>\n</blockquote>\n<p><img alt=\"\" height=\"100\" src=\"image\\0ad718a2e0204a839026f6a3b1c3c19a.png\" width=\"1149\"/>  </p>\n<p></p>\n<p>5、对Id为4的用户进行查询</p>\n<pre><code class=\"language-java\">//测试查询\n@Test\npublic void testSelectById(){\n    User user = userMapper.selectById(4L);\n    System.out.println(user);\n}</code></pre>\n<blockquote>\n<p>查看日志输出可以看到，seletc的语句以经发生了更改</p>\n<p>增加了deleted的判断语句，判断deleted是否为1，为1则能搜索，0则不能</p>\n</blockquote>\n<p> <img alt=\"\" height=\"120\" src=\"image\\92f314a0b65a4c48b7187486a2ece132.png\" width=\"1080\"/></p>\n<p></p>\n<p>6、小结</p>\n<p>只对自动注入的SQL有效：</p>\n<ul><li> <p>插入: 不作限制</p> </li><li> <p>查找: 追加 where 条件过滤掉已删除数据,且使用 wrapper.entity 生成的 where 条件会忽略该字段</p> </li><li> <p>更新: 追加 where 条件防止更新到已删除数据,且使用 wrapper.entity 生成的 where 条件会忽略该字段</p> </li><li> <p>删除: 转变为 更新</p> </li></ul>\n<p>比如：</p>\n<p>删除语句转化为：update user set deleted=1 where id = 1 and deleted=0</p>\n<p>查找语句转化为：select id,name,deleted from user where deleted=0</p>\n<blockquote>\n<p>注意事项：</p>\n<ul><li> <p>逻辑删除是为了方便数据恢复和保护数据本身价值等等的一种方案，但实际就是删除。</p> </li><li> <p>如果你需要频繁查出来看就不应使用逻辑删除，而是以一个状态去表示。</p> </li></ul>\n</blockquote>\n<h1 id=\"%E5%85%AB%E3%80%81%E6%89%A7%E8%A1%8CSQL%E5%88%86%E6%9E%90%E6%89%93%E5%8D%B0\">八、执行SQL分析打印</h1>\n<blockquote>\n<p>可输出 SQL 语句以及其执⾏时间，建议开发测试时启⽤该功能，能快速揪出慢查询</p>\n<p>注意：PerformanceInterceptor在3.2.0被移除了，如果想进⾏性能分析，⽤第三⽅的，官⽅这样写的“该插件 3.2.0 以上版本移除 推荐使⽤第三⽅扩展 执⾏SQL分析打印 功能”。也就是p6spy。</p>\n</blockquote>\n<p>使用步骤：</p>\n<h2 id=\"8.1%E3%80%81p6spy%E4%BE%9D%E8%B5%96%E5%BC%95%E5%85%A5\">8.1、p6spy依赖引入</h2>\n<p>Maven:</p>\n<pre><code class=\"language-XML\">&lt;dependency&gt;\n  &lt;groupId&gt;p6spy&lt;/groupId&gt;\n  &lt;artifactId&gt;p6spy&lt;/artifactId&gt;\n  &lt;version&gt;最新版本&lt;/version&gt; &lt;!--这里用的是&gt;3.9.1版本--&gt;\n&lt;/dependency&gt;</code></pre>\n<h2 id=\"8.2%E3%80%81application.yml%E9%85%8D%E7%BD%AE\">8.2、application.yml配置</h2>\n<pre><code class=\"language-XML\">spring:\n  datasource:\n    driver-class-name: com.p6spy.engine.spy.P6SpyDriver\n    url: jdbc:p6spy:h2:mem:test\n    ...</code></pre>\n<blockquote>\n<p>注意： driver-class-name 为 p6spy 提供的驱动类 url 前缀为 jdbc:p6spy 跟着冒号为对应数据库连接地址</p>\n</blockquote>\n<p>实际配置为：</p>\n<pre><code class=\"language-XML\">spring:\n  datasource:\n    username: root\n    password: 123456\n    driver-class-name: com.p6spy.engine.spy.P6SpyDriver\n    url: jdbc:p6spy:mysql:///mybatis_plus?userUnicode=true&amp;characterEncoding=utf-8</code></pre>\n<p> <img alt=\"\" height=\"478\" src=\"image\\96eb241c78e745049507c29b444c21a6.png\" width=\"1200\"/></p>\n<p></p>\n<h2 id=\"8.3%E3%80%81spy.properties%E9%85%8D%E7%BD%AE\">8.3、spy.properties配置</h2>\n<pre><code class=\"language-XML\">#3.2.1以上使用\nmodulelist=com.baomidou.mybatisplus.extension.p6spy.MybatisPlusLogFactory,com.p6spy.engine.outage.P6OutageFactory\n#3.2.1以下使用或者不配置\n#modulelist=com.p6spy.engine.logging.P6LogFactory,com.p6spy.engine.outage.P6OutageFactory\n# 自定义日志打印\nlogMessageFormat=com.baomidou.mybatisplus.extension.p6spy.P6SpyLogger\n#日志输出到控制台\nappender=com.baomidou.mybatisplus.extension.p6spy.StdoutLogger\n# 使用日志系统记录 sql\n#appender=com.p6spy.engine.spy.appender.Slf4JLogger\n# 设置 p6spy driver 代理\nderegisterdrivers=true\n# 取消JDBC URL前缀\nuseprefix=true\n# 配置记录 Log 例外,可去掉的结果集有error,info,batch,debug,statement,commit,rollback,result,resultset.\nexcludecategories=info,debug,result,commit,resultset\n# 日期格式\ndateformat=yyyy-MM-dd HH:mm:ss\n# 实际驱动可多个\n#driverlist=org.h2.Driver\n# 是否开启慢SQL记录\noutagedetection=true\n# 慢SQL记录标准 2 秒\noutagedetectioninterval=2</code></pre>\n<p><img alt=\"\" height=\"569\" src=\"image\\f50ef71fc30f47e6a433f9fd0543b14f.png\" width=\"1200\"/></p>\n<p></p>\n<h2 id=\"8.4%E3%80%81%E6%B5%8B%E8%AF%95\">8.4、测试</h2>\n<p>这里使用之前的分页查询来测试一下</p>\n<pre><code class=\"language-java\">//测试MybatisPlus分页插件\n@Test\npublic void testMybatisPlus_Page(){\n    // 两个参数：current的值默认是1，从1开始，不是0。size是每一页的条数。\n    Page&lt;User&gt; page = new Page&lt;&gt;(2, 4);\n    userMapper.selectPage(page,null);\n    page.getRecords().forEach(System.out::println);\n    //page的其他方法\n    System.out.println(\"当前页：\" + page.getCurrent());\n    System.out.println(\"总页数：\" + page.getPages());\n    System.out.println(\"记录数：\" + page.getTotal());\n    System.out.println(\"是否有上一页：\" + page.hasPrevious());\n    System.out.println(\"是否有下一页：\" + page.hasNext());\n}</code></pre>\n<p>查看日志输出</p>\n<p> <img alt=\"\" height=\"389\" src=\"image\\d6027a700fd348178786bd23ca3a410d.png\" width=\"1002\"/></p>\n<p></p>\n<p></p>\n<blockquote>\n<p>因为在配置文件中设置了慢SQL的检查，为2s，所以这里的查询可以通过</p>\n<p>但是只要超过了时长就会抛出异常</p>\n</blockquote>\n<p><img alt=\"\" height=\"123\" src=\"image\\62e3cca32ec24f0cae88a0bdb6fab725.png\" width=\"278\"/></p>\n<p></p>\n<p></p>\n<h1 id=\"%E4%B9%9D%E3%80%81%E6%9D%A1%E4%BB%B6%E6%9E%84%E9%80%A0%E5%99%A8\">九、条件构造器</h1>\n<blockquote>\n<p>Wrapper，可以通过其构造复杂的SQL</p>\n</blockquote>\n<p><img alt=\"\" height=\"763\" src=\"image\\b21f51efab564f7a97c3e1485c2b8258.png\" width=\"163\"/></p>\n<p></p>\n<p></p>\n<blockquote>\n<p>注意：</p>\n<p>1、耦合性高</p>\n<p>2、传输wrapper相当于conroller用map接收值，后期维护极为困难</p>\n<p>所以这里只是采取少量代码进行演示</p>\n</blockquote>\n<h2 id=\"9.1%E3%80%81%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA\">9.1、代码演示</h2>\n<p>1、查询name、邮箱不为空且年龄大于等于20的用户</p>\n<pre><code class=\"language-java\">@Test\nvoid WrapperTest(){\n    //查询name、邮箱不为空且年龄大于等于20的用户\n    QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;();\n    wrapper\n            .isNotNull(\"name\")\n            .isNotNull(\"email\")\n            .ge(\"age\",12);\n    userMapper.selectList(wrapper).forEach(System.out::println);\n}</code></pre>\n<p><img alt=\"\" height=\"264\" src=\"image\\1b25b2fb83814658832479efb682ef5e.png\" width=\"1200\"/></p>\n<p></p>\n<p></p>\n<p>2、查询姓名为小文的用户</p>\n<pre><code class=\"language-java\">@Test\nvoid WrapperTest2(){\n    //查询姓名为小文的用户\n    QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;();\n    wrapper.eq(\"name\",\"小文\");    //equals\n    User user = userMapper.selectOne(wrapper); \n    System.out.println(user);\n}</code></pre>\n<p><img alt=\"\" height=\"285\" src=\"image\\d6685095f47047b384e80b1afb590ae9.png\" width=\"1155\"/></p>\n<p></p>\n<p></p>\n<blockquote>\n<p>注意：</p>\n<p>查询一个数据出现多个结果就使用List或map</p>\n</blockquote>\n<p>3、查询年龄在19-23之间的用户</p>\n<pre><code class=\"language-java\">@Test\nvoid WrapperTest3(){\n    //查询年龄在19-23之间的用户\n    QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;();\n    wrapper.between(\"age\", 19, 23);\n    Long count = userMapper.selectCount(wrapper);//查询结果数\n    System.out.println(count);\n}</code></pre>\n<p></p>\n<p>4、查询年龄在19-23之间的用户</p>\n<pre><code class=\"language-java\">@Test\nvoid WrapperTest3(){\n    //查询年龄在19-23之间的用户\n    QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;();\n    wrapper.between(\"age\", 19, 23);\n    Long count = userMapper.selectCount(wrapper);//查询结果数\n    System.out.println(count);\n}</code></pre>\n<p> <img alt=\"\" height=\"249\" src=\"image\\ee3c84bfb7834ba4947a7475fb04f9cf.png\" width=\"1194\"/></p>\n<p></p>\n<p></p>\n<blockquote>\n<p>这里的方法取值范围是左开右闭！</p>\n</blockquote>\n<p>5、模糊查询</p>\n<pre><code class=\"language-java\">@Test\nvoid WrapperTest4(){\n    QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;();\n    wrapper\n            .notLike(\"name\",\"a\")    //查询姓名中不包含a的用户\n            .likeRight(\"email\",\"t\");   //左和右是代表%的位置 两边都要匹配则为%e%，这里是email以t开头的 t%\n    List&lt;Map&lt;String, Object&gt;&gt; maps = userMapper.selectMaps(wrapper);\n    maps.forEach(System.out::println);\n}</code></pre>\n<p> <img alt=\"\" height=\"295\" src=\"image\\e0a097c8a6804d7e86432b0baba8a22f.png\" width=\"1200\"/></p>\n<p></p>\n<p></p>\n<p>6、联表查询</p>\n<pre><code class=\"language-java\">//联表查询\n@Test\nvoid WrapperTest5(){\n    QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;();\n    wrapper.inSql(\"id\",\"select id from user where id &lt; 4\");\n    List&lt;Object&gt; objects = userMapper.selectObjs(wrapper);\n    objects.forEach(System.out::println);\n}</code></pre>\n<p> <img alt=\"\" height=\"245\" src=\"image\\d88bff5a32e94bcaa4c835233425a908.png\" width=\"1200\"/></p>\n<p></p>\n<p></p>\n<p>7、通过ID进行排序</p>\n<pre><code class=\"language-java\">@Test\nvoid WrapperTest6(){\n    //通过ID进行排序\n    QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;();\n    wrapper.orderByAsc(\"id\");   //通过id升序\n    List&lt;User&gt; users = userMapper.selectList(wrapper);\n    users.forEach(System.out::println);\n}</code></pre>\n<p><img alt=\"\" height=\"292\" src=\"image\\cbcf8d9ab9f14bd89c63ce750bcec507.png\" width=\"1131\"/></p>\n<p></p>\n<p></p>\n<h1 id=\"%E5%8D%81%E3%80%81%E4%BB%A3%E7%A0%81%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E5%99%A8\">十、代码自动生成器</h1>\n<blockquote>\n<p>MybatisPlus看官方文档即可，这里讲一个Idea插件Easy Code代码生成器</p>\n</blockquote>\n<h2 id=\"10.1%E3%80%81EasyCode\">10.1、EasyCode</h2>\n<p>EasyCode是基于IntelliJ IDEA Ultimate版开发的一个代码生成插件，主要通过自定义模板（基于velocity）来生成各种你想要的代码。通常用于生成Entity、Dao、Service、Controller。如果你动手能力强还可以用于生成HTML、JS、PHP等代码。理论上来说只要是与数据有关的代码都是可以生成的。</p>\n<p><strong>支持的数据库类型：</strong></p>\n<blockquote>\n<ol><li> <p>MySQL</p> </li><li> <p>SQL Server</p> </li><li> <p>Oracle</p> </li><li> <p>PostgreSQL</p> </li><li> <p>Sqlite</p> </li><li> <p>Sybase</p> </li><li> <p>Derby</p> </li><li> <p>DB2</p> </li><li> <p>HSQLDB</p> </li><li> <p>H2</p> </li></ol>\n<p>当然支持的数据库类型也会随着Database Tool插件的更新同步更新。</p>\n</blockquote>\n<h2 id=\"10.2%E3%80%81%E5%8A%9F%E8%83%BD\">10.2、功能</h2>\n<ul><li> <p>支持多表同时操作</p> </li><li> <p>支持同时生成多个模板</p> </li><li> <p>支持自定义模板</p> </li><li> <p>支持自定义类型映射（支持正则）</p> </li><li> <p>支持自定义附加列</p> </li><li> <p>支持列附加属性</p> </li><li> <p>所有配置项目支持分组模式，在不同项目（或选择不同数据库时），只需要切换对应的分组，所有配置统一变化</p> </li></ul>\n<h2 id=\"10.3%E3%80%81%E6%93%8D%E4%BD%9C\">10.3、操作</h2>\n<p>1、安装EasyCode</p>\n<p><img alt=\"\" height=\"721\" src=\"image\\54f84dbb9dd84910b3cfef7858f5c42e.png\" width=\"998\"/></p>\n<p></p>\n<p>2、建立数据库</p>\n<p>这里就不再多说了，就用之前的数据库即可</p>\n<p>3、在IDEA配置连接数据库</p>\n<p><img alt=\"\" height=\"347\" src=\"image\\685fd53a9071469ea997d8b9ef70efd1.png\" width=\"390\"/></p>\n<p></p>\n<p></p>\n<blockquote>\n<p>这里也不多说了，就是idea连接自己的数据库</p>\n</blockquote>\n<p>4、使用EasyCode</p>\n<p>在对应的字段上右键，就可以看到多出一个EasyCode，点击然后选择生成<img alt=\"\" height=\"359\" src=\"image\\5ce7b08bfa3b489aa0da987d400123bb.png\" width=\"424\"/></p>\n<p></p>\n<p></p>\n<p>5、开始生成代码</p>\n<p><img alt=\"\" height=\"369\" src=\"image\\efbefe9b43fd4f9db3dd693276d1c58e.png\" width=\"502\"/></p>\n<p></p>\n<p>勾选需要生成的代码，点击OK即可</p>\n<p><img alt=\"\" height=\"369\" src=\"image\\0ff145a2f0344dfa9e69c6ed5a42ffc3.png\" width=\"502\"/></p>\n<p></p>\n<p></p>\n<p>6、效果图</p>\n<p></p>\n<p><img alt=\"\" height=\"272\" src=\"image\\451ba3169080476181a8eab94df82f87.png\" width=\"313\"/></p>\n<p></p>\n<blockquote>\n<p>这些就是自动生成的代码了，代码你成熟了，应该自己生成了&lt;狗头&gt;</p>\n</blockquote>\n</div>\n</div>"}