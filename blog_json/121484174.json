{"blogid": "121484174", "writerAge": "码龄3年", "writerBlogNum": "195", "writerCollect": "57", "writerComment": "13", "writerFan": "42", "writerGrade": "4级", "writerIntegral": "1342", "writerName": "黄子毅", "writerProfileAdress": "writer_image\\profile_121484174.jpg", "writerRankTotal": "17771", "writerRankWeekly": "167086", "writerThumb": "20", "writerVisitNum": "53814", "blog_read_count": "957", "blog_time": "于 2021-11-22 09:24:31 发布", "blog_title": "精读《Rust 是 JS 基建的未来》", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<div id=\"js_content\">\n<p>Rust Is The Future of JavaScript Infrastructure 这篇文章讲述了 Rust 正在 JS 基建圈流行的事实：Webpack、Babel、Terser、Prettier、ESLint 这些前些年才流行起来的工具都已有了 Rust 替代方案，且性能有着 10～100 倍的提升。</p>\n<p>前端基建的迭代浪潮从未停歇，当上面这些工具给 Gulp、js-beautify、tslint 等工具盖上棺材盖时，基于 Rust 的新一代构建工具已经悄悄将棺材盖悬挂在 webpack、babel、prettier、terser、eslint 它们头上，不知道哪天就会盖上。</p>\n<p>原文已经有了不错的 <a href=\"\">中文翻译</a>，值得一提的是，原文一些英文名词对应着特定中文解释，记录如下：</p>\n<ul><li><p>low-level programming：低级编程 底层编程。</p></li><li><p>ergonomics：人体工程学 人机工程学。</p></li><li><p>opinionated：自以为是，固执的 开箱即用的。</p></li><li><p>critical adoption：批判性采用 技术选型临界点。</p></li></ul>\n<h2>精读</h2>\n<p>本文不会介绍 Rust 如何使用，而会重点介绍原文提到的 Rust 工具链的一些基本用法，如果你感兴趣，可以立刻替换现有的工具库！</p>\n<h3>swc</h3>\n<p>swc 是基于 Rust 开发的一系列编译、打包、压缩等工具，并且被广泛应用于更多更上层的 JS 基建，大大推动了 Rust 在 JS 基建的影响力，所以要第一个介绍。</p>\n<p>swc 提供了一系列原子能力，涵盖构建与运行时：</p>\n<h4>@swc/cli</h4>\n<p><code>@swc/cli</code> 可以同时构建 js 与 ts 文件：</p>\n<pre class=\"has\"><code class=\"language-go\">const a = 1</code></pre>\n<pre class=\"has\"><code class=\"language-go\">npm i -D @swc/cli\nnpx swc ./main.ts\n\n# output:\n# Successfully compiled 1 file with swc.\n# var a = 1;</code></pre>\n<p>具体功能与 babel 类似，都可以让浏览器支持先进语法或者 ts，只是 <code>@swc/cli</code> 比 babel 快了至少 20 倍。可以通过 <code>.swcrc</code> 文件做 自定义配置。</p>\n<h4>@swc/core</h4>\n<p>你可以利用 <code>@swc/core</code> 制作更上层的构建工具，所以它是 <code>@swc/cli</code> 的开发者调用版本。基本 API 来自官网开发者文档：</p>\n<pre class=\"has\"><code class=\"language-go\">const swc = require(\"@swc/core\");\n\nswc\n  .transform(\"source code\", {\n    // Some options cannot be specified in .swcrc\n    filename: \"input.js\",\n    sourceMaps: true,\n    // Input files are treated as module by default.\n    isModule: false,\n\n    // All options below can be configured via .swcrc\n    jsc: {\n      parser: {\n        syntax: \"ecmascript\",\n      },\n      transform: {},\n    },\n  })\n  .then((output) =&gt; {\n    output.code; // transformed code\n    output.map; // source map (in string)\n  });</code></pre>\n<p>其实就是把 cli 调用改成了 node 调用。</p>\n<h4>@swc/wasm-web</h4>\n<p><code>@swc/wasm-web</code> 可以在浏览器运行时调用 wsm 版的 swc，以得到更好的性能。下面是官方的例子：</p>\n<pre class=\"has\"><code class=\"language-go\">import { useEffect, useState } from \"react\";\nimport initSwc, { transformSync } from \"@swc/wasm-web\";\n\nexport default function App() {\n  const [initialized, setInitialized] = useState(false);\n\n  useEffect(() =&gt; {\n    async function importAndRunSwcOnMount() {\n      await initSwc();\n      setInitialized(true);\n    }\n    importAndRunSwcOnMount();\n  }, []);\n\n  function compile() {\n    if (!initialized) {\n      return;\n    }\n    const result = transformSync(`console.log('hello')`, {});\n    console.log(result);\n  }\n\n  return (\n    &lt;div className=\"App\"&gt;\n      &lt;button onClick={compile}&gt;Compile&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}</code></pre>\n<p>这个例子可以在浏览器运行时做类似 babel 的事情，无论是低代码平台还是在线 coding 平台都可以用它做运行时编译。</p>\n<h4>@swc/jest</h4>\n<p><code>@swc/jest</code> 提供了 Rust 版本的 jest 实现，让 jest 跑得更快。使用方式也很简单，首先安装：</p>\n<pre class=\"has\"><code class=\"language-go\">npm i @swc/jest</code></pre>\n<p>然后在 <code>jest.config.js</code> 配置文件中，将 ts 文件 compile 指向 <code>@swc/jest</code> 即可：</p>\n<pre class=\"has\"><code class=\"language-go\">module.exports = {\n  transform: {\n    \"^.+\\\\.(t|j)sx?$\": [\"@swc/jest\"],\n  },\n};</code></pre>\n<h4>swc-loader</h4>\n<p><code>swc-loader</code> 是针对 webpack 的 loader 插件，代替 <code>babel-loader</code>：</p>\n<pre class=\"has\"><code class=\"language-go\">module: {\n  rules: [\n    {\n      test: /\\.m?js$/,\n      exclude: /(node_modules)/,\n      use: {\n        // `.swcrc` can be used to configure swc\n        loader: \"swc-loader\"\n      }\n    }\n  ];\n}</code></pre>\n<h4>swcpack</h4>\n<p>增强了多文件 bundle 成一个文件的功能，基本可以认为是 swc 版本的 webpack，当然性能也会比 <code>swc-loader</code> 方案有进一步提升。</p>\n<p>截至目前，该功能还在测试阶段，只要安装了 <code>@swc/cli</code> 就可使用，通过创建 <code>spack.config.js</code> 后执行 <code>npx spack</code> 即可运行，和 webpack 的使用方式一样。</p>\n<h3>Deno</h3>\n<p>Deno 的 linter、code formatter、文档生成器采用 swc 构建，因此也算属于 Rust 阵营。</p>\n<p>Deno 是一种新的 js/ts 运行时，所以我们总喜欢与 node 进行类比。quickjs 也一样，这三个都是一种对 js 语言的运行器，作为开发者，需求永远是更好的性能、兼容性与生态，三者几乎缺一不可，所以当下虽然不能完全代替 Nodejs，但作为高性能替代方案是很香的，可以基于他们做一些跨端跨平台的解析器，比如 kraken 就是基于 quickjs + flutter 实现的一种高性能 web 渲染引擎，是 web 浏览器的替代方案，作为一种跨端方案。</p>\n<h3>esbuild</h3>\n<p>esbuild 是较早被广泛使用的新一代 JS 基建，是 JS 打包与压缩工具。虽然采用 Go 编写，但性能与 Rust 不相上下，可以与 Rust 风潮放在一起看。</p>\n<p>esbuild 目前有两个功能：编译和压缩，理论上分别可代替 babel 与 terser。</p>\n<p>编译功能的基本用法：</p>\n<pre class=\"has\"><code class=\"language-go\">require('esbuild').transformSync('let x: number = 1', {\n  loader: 'ts',\n})\n\n// 'let x = 1;\\n'</code></pre>\n<p>压缩功能的基本用法：</p>\n<pre class=\"has\"><code class=\"language-go\">require('esbuild').transformSync('fn = obj =&gt; { return obj.x }', {\n  minify: true,\n})\n\n// 'fn=n=&gt;n.x;\\n'</code></pre>\n<p>压缩功能比较稳定，适合用在生产环境，而编译功能要考虑兼容 webpack 的地方太多，在成熟稳定后才考虑能在生产环境使用，目前其实已经有不少新项目已经在生产环境使用 esbuild 的编译功能了。</p>\n<p>编译功能与 <code>@swc</code> 类似，但因为 Rust 支持编译到 wsm，所以 <code>@swc</code> 提供了 web 运行时编译能力，而 esbuild 目前还没有看到这种特性。</p>\n<h3>Rome</h3>\n<p>Rome 是 Babel 作者做的基于 Nodejs 的前端基建全家桶，包含但不限于 Babel, ESLint, webpack, Prettier, Jest。目前 计划使用 Rust 重构，虽然还没有实现，但我们姑且可以把 Rome 当作 Rust 的一员。</p>\n<p><code>rome</code> 是个全家桶 API，所以你只需要 <code>yarn add rome</code> 就完成了所有环境准备工作。</p>\n<ul><li><p><code>rome bundle</code> 打包项目。</p></li><li><p><code>rome compile</code> 编译单个文件。</p></li><li><p><code>rome develop</code> 调试项目。</p></li><li><p><code>rome parse</code> 解析文件抽象语法树。</p></li><li><p><code>rome analyzeDependencies</code> 分析依赖。</p></li></ul>\n<p>Rome 还将文件格式化与 Lint 合并为了 <code>rome check</code> 命令，并提供了友好 UI 终端提示。</p>\n<p>其实我并不太看好 Rome，因为它负担太重了，测试、编译、Lint、格式化、压缩、打包的琐碎事情太多，把每一块交给社区可能会做得更好，这不现在还在重构中，牵一发而动全身。</p>\n<h3>NAPI-RS</h3>\n<p>NAPI-RS 提供了高性能的 Rust 到 Node 的衔接层，可以将 Rust 代码编译后成为 Node 可调用文件。下面是官网的例子：</p>\n<pre class=\"has\"><code class=\"language-go\">#[js_function(1)]\nfn fibonacci(ctx: CallContext) -&gt; Result&lt;JsNumber&gt; {\n  let n = ctx.get::&lt;JsNumber&gt;(0)?.try_into()?;\n  ctx.env.create_int64(fibonacci_native(n))\n}</code></pre>\n<p>上面写了一个斐波那契数列函数，直接调用了 <code>fibonacci_native</code> 函数实现。为了让这个方法被 Node 调用，首先安装 CLI：<code>npm i @napi-rs/cli</code>。</p>\n<p>由于环境比较麻烦，因此需要利用这个脚手架初始化一个工作台，我们在里面写 Rust，然后再利用固定的脚本发布 npm 包。执行 <code>napi new</code> 创建一个项目，我们发现入口文件肯定是个 js，毕竟要被 node 引用，大概长这样（我创建了一个 <code>myLib</code> 包）：</p>\n<pre class=\"has\"><code class=\"language-go\">const { loadBinding } = require('@node-rs/helper')\n\n/**\n * __dirname means load native addon from current dir\n * 'myLib' is the name of native addon\n * the second arguments was decided by `napi.name` field in `package.json`\n * the third arguments was decided by `name` field in `package.json`\n * `loadBinding` helper will load `myLib.[PLATFORM].node` from `__dirname` first\n * If failed to load addon, it will fallback to load from `myLib-[PLATFORM]`\n */\nmodule.exports = loadBinding(__dirname, 'myLib', 'myLib')</code></pre>\n<p>所以 loadBinding 才是入口，同时项目文件夹下存在三个系统环境包，分别供不同系统环境调用：</p>\n<ul><li><p><code>@cool/core-darwin-x64</code> macOS x64 平台。</p></li><li><p><code>@cool/core-win32-x64</code> Windows x64 平台。</p></li><li><p><code>@cool/core-linux-arm64-gnu</code> Linux aarch64 平台。</p></li></ul>\n<p><code>@node-rs/helper</code> 这个包的作用是引导 node 执行预编译的二进制文件，<code>loadBinding</code> 函数会尝试加载当前平台识别的二进制包。</p>\n<p>将 <code>src/lib.rs</code> 的代码改成上面斐波那契数列的代码后，执行 <code>npm run build</code> 编译。注意在编译前需要安装 rust 开发环境，只要一行脚本即可安装，具体看 rustup.rs。然后把当前项目整体当作 node 包发布即可。</p>\n<p>发布后，就可以在 node 代码中引用啦：</p>\n<pre class=\"has\"><code class=\"language-go\">import { fibonacci } from 'myLib'\n\nfunction hello() {\n  let result = fibonacci(10000)\n  console.log(result)\n  return result\n}</code></pre>\n<p>NAPI-RS 作为 Rust 与 Node 的桥梁，很好的解决了 Rust 渐进式替换现有 JS 工具链的问题。</p>\n<h3>Rust + WebAssembly</h3>\n<p>Rust + WebAssembly 说明 Rust 具备编译到 wsm 的能力，虽然编译后代码性能会变得稍慢，但还是比 js 快很多，同时由于 wsm 的可移植性，让 Rust 也变得可移植了。</p>\n<p>其实 Rust 支持编译到 WebAssembly 也不奇怪，因为本来 WebAssembly 的定位之一就是作为其他语言的目标编译产物，然后它本身支持跨平台，这样它就很好的完成了传播的使命。</p>\n<p>WebAssembly 是一个基于栈的虚拟机 (stack machine)，所以跨平台能力一流。</p>\n<p>想要将 Rust 编译为 wsm，除了安装 Rust 开发环境外，还要安装 wasm-pack。</p>\n<p>安装后编译只需执行 <code>wasm-pack build</code> 即可。更多用法可以查看 API 文档。</p>\n<h3>dprint</h3>\n<p>dprint 是用 rust 编写的 js/ts 格式化工具，并提供了 dprint-node 版本，可以直接作为 node 包，通过 npm 安装使用，从 源码 可以看到，使用 NAPI-RS 实现。</p>\n<p><code>dprint-node</code> 可以直接在 Node 中使用：</p>\n<pre class=\"has\"><code class=\"language-go\">const dprint = require('dprint-node');\ndprint.format(filePath, code, options);</code></pre>\n<p>参数文档。</p>\n<h3>Parcel</h3>\n<p>Parcel 严格来说算是上一代 JS 基建，它出现在 Webpack 之后，Rust 风潮之前。不过由于它已经采用 SWC 重写，所以姑且算是跟上了时髦。</p>\n<h2>总结</h2>\n<p>前端全家桶已经有了一整套 Rust 实现，只是对于存量项目的编译准确性需要大量验证，我们还需要时间等待这些库的成熟度。</p>\n<p>但毫无疑问的是，Rust 语言对 JS 基建支持已经较为完备了，剩下的只是工具层逻辑覆盖率的问题，都可以随时间而解决。而用 Rust 语言重写后的逻辑带来的巨幅性能提升将为社区注入巨大活力，就像原文说的，前端社区可以为了巨大性能提升而引入 Rust 语言，即便这可能导致为社区贡献门槛的提高。</p>\n<blockquote>\n<p>讨论地址是：精读《Rust 是 JS 基建的未来》· Issue #371 · dt-fe/weekly</p>\n</blockquote>\n<p><strong>如果你想参与讨论，请 点击这里，每周都有新的主题，周末或周一发布。前端精读 - 帮你筛选靠谱的内容。</strong></p>\n<blockquote>\n<p>关注 <strong>前端精读微信公众号</strong></p>\n</blockquote>\n<img alt=\"c88562e5a313dbf93c9f3efc9bd26f45.png\" src=\"image\\c88562e5a313dbf93c9f3efc9bd26f45.png\" width=\"200\"/>\n<blockquote>\n<p>版权声明：自由转载-非商用-非衍生-保持署名（创意共享 3.0 许可证）</p>\n</blockquote>\n</div>\n</div>\n</div>"}