{"blogid": "124042188", "writerAge": "码龄9年", "writerBlogNum": "116", "writerCollect": "177", "writerComment": "113", "writerFan": "25", "writerGrade": "4级", "writerIntegral": "1248", "writerName": "故里2130", "writerProfileAdress": "writer_image\\profile_124042188.jpg", "writerRankTotal": "16110", "writerRankWeekly": "6433", "writerThumb": "37", "writerVisitNum": "76029", "blog_read_count": "1550", "blog_time": "已于 2022-05-14 14:20:58 修改", "blog_title": "c#中使用BackgroundWorker", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>在客户端中，为了防止界面假死状态，或者不能拖动界面，可以使用BackgroundWorker。</p>\n<p>1.在界面上拖动一个BackgroundWorker，label，进度条和2个button控件。BackgroundWorker也可以选择在cs文件中new。</p>\n<p><img alt=\"\" height=\"865\" src=\"image\\9696511d651a411bbfdc222c5aa5bdd4.png\" width=\"1014\"/></p>\n<p>2.bgWorker_DoWork事件中接收到bgWorker.RunWorkerAsync(\"11111\")</p>\n<p><img alt=\"\" height=\"650\" src=\"image\\878b9176949549b3af3a92cf3f8b9db1.png\" width=\"868\"/></p>\n<p>3.bgWorker_ProgessChanged事件中接收到bgWorker.ReportProgress方法传递过来的参数</p>\n<p><img alt=\"\" height=\"708\" src=\"image\\a671282f5fb342369bd875e501251077.png\" width=\"956\"/></p>\n<p> 4.bgWorker_WorkerCompleted事件中主要处理线程暂停或者终止时的提示</p>\n<p><img alt=\"\" height=\"670\" src=\"image\\3232baac85854f8dbf4391fb2f0e3b2c.png\" width=\"946\"/></p>\n<p>5.中途取消操作后，也就是执行bgWorker.CancelAsync()此方法。bgWorker.CancellationPending会变成true</p>\n<p><img alt=\"\" height=\"134\" src=\"image\\9a7511d971f241dfa265f2c50292e9bc.png\" width=\"510\"/></p>\n<p></p>\n<p><img alt=\"\" height=\"821\" src=\"image\\92cc3eb6b4084d1da265294df510e371.png\" width=\"1099\"/></p>\n<p></p>\n<p></p>\n<p>所有代码：</p>\n<pre><code class=\"language-cs\">    public partial class Form1 : Form\n    {\n\n        public Form1()\n        {\n            InitializeComponent();\n        }\n\n        private void btnStart_Click(object sender, EventArgs e)\n        {\n            if (bgWorker.IsBusy)              //判断是否正在运行异步操作\n                return;\n            this.progressBar1.Maximum = 100;  //设置进度条最大值\n            this.btnStart.Enabled = false;\n            this.btnStop.Enabled = true;\n            bgWorker.RunWorkerAsync(\"11111\");   //给业务传递参数，就是把前台的要处理的参数传递进去\n        }\n\n        public void bgWorker_DoWork(object sender, DoWorkEventArgs e)\n        {\n            //业务处理\n            object s = e.Argument;   //这的e.Argument就是上面传递的参数 11111\n            for (int i = 0; i &lt;= this.progressBar1.Maximum; i++)\n            {\n                if (bgWorker.CancellationPending)     //此处关联的是btnStop_Click事件中的这个bgWorker.CancelAsync();如果这个触发了，那么就会停止。\n                {\n                    e.Cancel = true;\n                    return;\n                }\n                else\n                {\n                    bgWorker.ReportProgress(i, \"222222\"); //向bgWorker_ProgessChanged事件传递参数，第一个是进度的参数，第二个是你要处理业务的参数\n                    System.Threading.Thread.Sleep(1);\n                }\n            }\n        }\n\n        public void bgWorker_ProgessChanged(object sender, ProgressChangedEventArgs e)\n        {\n            //页面处理\n            string state = (string)e.UserState;//接收上bgWorker.ReportProgress方法传递过来的参数userState\n            this.progressBar1.Value = e.ProgressPercentage;\n            this.label1.Text = \"处理进度:\" + Convert.ToString(e.ProgressPercentage) + \"%\";\n            //label2.Text = e.ProgressPercentage.ToString();\n        }\n\n        public void bgWorker_WorkerCompleted(object sender, RunWorkerCompletedEventArgs e)\n        {\n            if (e.Error != null)\n            {\n                MessageBox.Show(e.Error.ToString());\n                return;\n            }\n            if (!e.Cancelled)\n                this.label1.Text = \"处理完毕!\";\n            else\n                this.label1.Text = \"处理终止!\";\n\n        }\n\n        private void btnStop_Click(object sender, EventArgs e)\n        {\n            this.btnStart.Enabled = true;\n            this.btnStop.Enabled = false;\n            bgWorker.CancelAsync();\n        }\n\n    }</code></pre>\n<p>多个线程的话，在A_DoWork开启另外一个bw,可以一直套用。</p>\n<p></p>\n<p><img alt=\"\" height=\"230\" src=\"image\\568a2156418648f7a7dab86870bfc93c.png\" width=\"492\"/></p>\n<p></p>\n<p>总结。</p>\n<p>主要是3个事件：</p>\n<p>bgWorker_DoWork：业务内部处理大量数据的地方，后台默默处理数据。（关于界面控件的东西，这里不要出现，比如给控件赋值，这里不要出现）</p>\n<p>bgWorker_ProgessChanged：每次业务内部处理完成一部分时，就会告诉界面我处理了什么，主要是给前台显示信息。（这里可以与前台一起交互）</p>\n<p>bgWorker_WorkerCompleted：终止或者完成后就会进入（这里可以是完成数据后，给控件赋值）</p>\n<p>3个方法：</p>\n<p>RunWorkerAsync：向业务内部传递处理数据的方法，传递集合，数值之类的</p>\n<p>ReportProgress：把处理的进度告诉界面</p>\n<p>CancelAsync：取消操作会执行此方法</p>\n<p></p>\n<p></p>\n<p></p>\n</div>\n</div>"}