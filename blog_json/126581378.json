{"blogid": "126581378", "writerAge": "码龄10年", "writerBlogNum": "69", "writerCollect": "477", "writerComment": "838", "writerFan": "713", "writerGrade": "5级", "writerIntegral": "2582", "writerName": "玲娜贝儿~", "writerProfileAdress": "writer_image\\profile_126581378.jpg", "writerRankTotal": "7672", "writerRankWeekly": "348", "writerThumb": "595", "writerVisitNum": "46441", "blog_read_count": "441", "blog_time": "已于 2022-08-31 16:02:15 修改", "blog_title": "【C++】-- AVL树详解", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E4%B8%80%E3%80%81%E6%A6%82%E5%BF%B5-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%80%E3%80%81%E6%A6%82%E5%BF%B5\">一、AVL树概念</a></p>\n<p id=\"1.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%BC%BA%E7%82%B9%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#1.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%BC%BA%E7%82%B9%C2%A0\">1.二叉搜索树的缺点 </a></p>\n<p id=\"2.AVL%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#2.AVL%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5%C2%A0\">2.AVL树的概念 </a></p>\n<p id=\"%E4%BA%8C%E3%80%81AVL%E6%A0%91%E5%AE%9A%E4%B9%89-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BA%8C%E3%80%81AVL%E6%A0%91%E5%AE%9A%E4%B9%89\">二、AVL树定义</a></p>\n<p id=\"1.AVL%E6%A0%91%E8%8A%82%E7%82%B9%E5%AE%9A%E4%B9%89-toc\" style=\"margin-left:40px;\"><a href=\"#1.AVL%E6%A0%91%E8%8A%82%E7%82%B9%E5%AE%9A%E4%B9%89\">1.AVL树节点定义</a></p>\n<p id=\"%C2%A02.AVL%E6%A0%91%E5%AE%9A%E4%B9%89-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A02.AVL%E6%A0%91%E5%AE%9A%E4%B9%89\"> 2.AVL树定义</a></p>\n<p id=\"%E4%B8%89.AVL%E6%A0%91%E6%8F%92%E5%85%A5%C2%A0-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%89.AVL%E6%A0%91%E6%8F%92%E5%85%A5%C2%A0\">三、AVL树插入 </a></p>\n<p id=\"1.%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9-toc\" style=\"margin-left:40px;\"><a href=\"#1.%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9\">1.插入节点</a></p>\n<p id=\"2.%E6%8E%A7%E5%88%B6%E5%B9%B3%E8%A1%A1%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#2.%E6%8E%A7%E5%88%B6%E5%B9%B3%E8%A1%A1%C2%A0\">2.控制平衡 </a></p>\n<p id=\"%C2%A0%EF%BC%881%EF%BC%89%E6%9B%B4%E6%96%B0%E5%B9%B3%E8%A1%A1%E5%9B%A0%E5%AD%90-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A0%EF%BC%881%EF%BC%89%E6%9B%B4%E6%96%B0%E5%B9%B3%E8%A1%A1%E5%9B%A0%E5%AD%90\">（1）更新平衡因子</a></p>\n<p id=\"%EF%BC%882%EF%BC%89%E6%97%8B%E8%BD%AC-toc\" style=\"margin-left:80px;\"><a href=\"#%EF%BC%882%EF%BC%89%E6%97%8B%E8%BD%AC\">（2）旋转</a></p>\n<p id=\"%E2%91%A0%E5%8F%B3%E5%8D%95%E6%97%8B-toc\" style=\"margin-left:80px;\"><a href=\"#%E2%91%A0%E5%8F%B3%E5%8D%95%E6%97%8B\">        </a> <a href=\"#%E2%91%A0%E5%8F%B3%E5%8D%95%E6%97%8B\">①右单旋</a></p>\n<p id=\"%E2%91%A1%E5%B7%A6%E5%8D%95%E6%97%8B-toc\" style=\"margin-left:80px;\"><a href=\"#%E2%91%A1%E5%B7%A6%E5%8D%95%E6%97%8B\">         </a><a href=\"#%E2%91%A1%E5%B7%A6%E5%8D%95%E6%97%8B\">②左单旋</a></p>\n<p id=\"%C2%A0%E2%91%A2%E5%B7%A6%E5%8F%B3%E5%8F%8C%E6%97%8B-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A0%E2%91%A2%E5%B7%A6%E5%8F%B3%E5%8F%8C%E6%97%8B\">        </a><a href=\"#%C2%A0%E2%91%A2%E5%B7%A6%E5%8F%B3%E5%8F%8C%E6%97%8B\"> ③左右双旋</a></p>\n<p id=\"%E2%91%A3%E5%8F%B3%E5%B7%A6%E5%8F%8C%E6%97%8B%E2%80%8B%E7%BC%96%E8%BE%91-toc\" style=\"margin-left:80px;\"><a href=\"#%E2%91%A3%E5%8F%B3%E5%B7%A6%E5%8F%8C%E6%97%8B%E2%80%8B%E7%BC%96%E8%BE%91\">        </a> <a href=\"#%E2%91%A3%E5%8F%B3%E5%B7%A6%E5%8F%8C%E6%97%8B%E2%80%8B%E7%BC%96%E8%BE%91\">④右左双旋</a></p>\n<p id=\"%E5%9B%9B%E3%80%81AVL%E6%A0%91%E6%9F%A5%E6%89%BE-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%9B%9B%E3%80%81AVL%E6%A0%91%E6%9F%A5%E6%89%BE\">四、AVL树查找</a></p>\n<p id=\"%E4%BA%94%E3%80%81AVL%E6%A0%91%E9%AB%98%E5%BA%A6%C2%A0-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BA%94%E3%80%81AVL%E6%A0%91%E9%AB%98%E5%BA%A6%C2%A0\">五、AVL树高度 </a></p>\n<p id=\"%C2%A0%E5%85%AD%E3%80%81%E6%A3%80%E6%9F%A5AVL%E6%A0%91%E6%98%AF%E5%90%A6%E5%B9%B3%E8%A1%A1-toc\" style=\"margin-left:0px;\"><a href=\"#%C2%A0%E5%85%AD%E3%80%81%E6%A3%80%E6%9F%A5AVL%E6%A0%91%E6%98%AF%E5%90%A6%E5%B9%B3%E8%A1%A1\"> 六、判断是否为AVL树</a></p>\n<p id=\"%E4%B8%83%E3%80%81AVL%E6%A0%91%E9%81%8D%E5%8E%86-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%83%E3%80%81AVL%E6%A0%91%E9%81%8D%E5%8E%86\">七、AVL树遍历</a></p>\n<p id=\"%E5%85%AB%E3%80%81%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%85%AB%E3%80%81%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6\">八、时间复杂度</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h1 id=\"%E4%B8%80%E3%80%81%E6%A6%82%E5%BF%B5\"><span style=\"color:#956fe7;\">一、AVL树概念</span></h1>\n<h2 id=\"1.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%BC%BA%E7%82%B9%C2%A0\"><span style=\"color:#956fe7;\">1.二叉搜索树的缺点 </span></h2>\n<p> map/multimap/set/multiset的底层都按照二叉搜索树实现，但是在<a href=\"https://mp.csdn.net/mp_blog/creation/editor/126101877\" title=\"【C++】-- 搜索二叉树\">【C++】-- 搜索二叉树</a>一文中已经了解到二叉搜索树的缺点在于，假如向树中插入的元素有序或者接近有序时，二叉搜索树就会退化成单支树，时间复杂度会退化成O(N)，相当于在顺序表中搜索元素，效率低下。所以map/multimap/set/multiset的底层结构对二叉搜索树做了处理，采用平衡树来实现。</p>\n<h2 id=\"2.AVL%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5%C2%A0\"><span style=\"color:#956fe7;\">2.AVL树的概念</span> </h2>\n<p>如何避免二叉树搜索树会退化成单支树的缺点呢？</p>\n<p>向二叉搜索树中插入新结点后，如果能保证每个结点的左右子树高度之差的绝对值不超过1(需要对树中的结点进行调整)，即可降低树的高度，从而减少平均搜索长度。为什么高度差的绝对值不超过1而不是0呢？因为如果高度差的绝对值不超过0，那么二叉树就变成满二叉树了，因此绝对值不能超过1。这就引入了平衡二叉树的概念：</p>\n<p>一棵AVL树或者是空树，或者是具有以下性质的二叉搜索树：</p>\n<p>(1)它的左右子树都是AVL树<br/> (2)左右子树高度之差(简称平衡因子=右子树高度-左子树高度)的绝对值不超过1(-1/0/1)</p>\n<p class=\"img-center\"><img alt=\"\" height=\"221\" src=\"image\\cabc5dc0557f4f4f807e64be2ead4915.png\" width=\"339\"/></p>\n<p> 如果一棵二叉搜索树是高度平衡的，它就是AVL树。如果它有n个结点，其高度可保持在，搜索时<br/> 间复杂度O（<img alt=\"\" height=\"24\" src=\"image\\7b0bd4af87ed49f79720478212fc99a1.png\" width=\"54\"/>）。</p>\n<h1 id=\"%E4%BA%8C%E3%80%81AVL%E6%A0%91%E5%AE%9A%E4%B9%89\"><span style=\"color:#956fe7;\">二、AVL树定义</span></h1>\n<p>由于要实现AVL树的增删改查，所以定义AVL树的节点，就需要定义parent，否则插入节点时，不知道要链接到树里面哪个节点下面。</p>\n<h2 id=\"1.AVL%E6%A0%91%E8%8A%82%E7%82%B9%E5%AE%9A%E4%B9%89\"><span style=\"color:#956fe7;\">1.AVL树节点定义</span></h2>\n<p>节点定义：</p>\n<pre><code class=\"language-cpp\">#pragma once\n#include&lt;iostream&gt;\nusing namespace std;\n\ntemplate&lt;class K,class V&gt;\nclass AVLTreeNode\n{\n\tAVLTreeNode&lt;K, V&gt;* _left;//左子树\n\tAVLTreeNode&lt;K, V&gt;* _right;//右子树\n\tAVLTreeNode&lt;K, V&gt;* _parent;//父亲\n\n\tint _bf;//平衡因子\n\n\tpair&lt;K, V&gt; _kv;//节点\n\n\tAVLTreeNode(const pair&lt;K, V&gt;&amp;, kv)\n\t{\n\t\t:_left(nullptr)\n\t\t,_right(nullptr)\n\t\t,_parent(nullptr)\n\t\t,_bf(0)\n\t\t, _kv(kv)\n\t}\n\t{}\n\n};</code></pre>\n<h2 id=\"%C2%A02.AVL%E6%A0%91%E5%AE%9A%E4%B9%89\"> <span style=\"color:#956fe7;\">2.AVL树定义</span></h2>\n<pre><code class=\"language-cpp\">template&lt;class K,class V&gt;\nstruct AVLTree\n{\n\ttypedef AVLTreeNode&lt;K, V&gt; Node;\npublic:\n\t\t//构造函数\n\tAVLTree()\n\t\t:_root(nullptr)\n\t{}\n\n\tvoid _Destroy(Node* root)\n\t{\n\t\tif (root == nullptr)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\t_Destroy(root-&gt;_left);\n\t\t_Destroy(root-&gt;_right);\n\n\t\tdelete root;\n\t}\n\n    //重载operator[]\n\tV&amp; operator[](const K&amp; key)\n\t{\n\t\tpair&lt;Node*, bool&gt; ret = Insert(make_pair(key, V()));\n\t\treturn ret.first-&gt;_kv.second;\n\t}\n\n\t//析构函数\n\t~AVLTree()\n\t{\n\t\t_Destroy(_root);\n\t\t_root = nullptr;\n\t}\n\nprivate:\n\tNode* _root;\n};</code></pre>\n<h1 id=\"%E4%B8%89.AVL%E6%A0%91%E6%8F%92%E5%85%A5%C2%A0\"><span style=\"color:#956fe7;\">三、AVL树插入 </span></h1>\n<h2 id=\"1.%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9\"><span style=\"color:#956fe7;\">1.插入节点</span></h2>\n<p>插入节点需要先判断树是否为空：</p>\n<p>（1）若为空，让该节点作为根节点</p>\n<p>（2）若不为空，分3种情况：</p>\n<p>①key比当前节点小，向左走</p>\n<p>②key比当前节点大，向右走</p>\n<p>③相等，插入失败</p>\n<p>如果没找到节点，那么需要插入新节点</p>\n<pre><code class=\"language-cpp\">\tbool Insert(const pair&lt;K, V&gt;&amp; kv)\n\t{\n\t\t//1.空树\n\t\tif (_root == nullptr)\n\t\t{\n\t\t\t_root = new Node(kv);\n\t\t\treturn true;\n\t\t}\n\n\t\t//2.非空树\n\t\tNode* parent = _root, * cur = _root;\n\t\twhile (cur)\n\t\t{\n\t\t\tif (cur-&gt;_kv.first &gt; kv.first)//向左找\n\t\t\t{\n\t\t\t\tparent = cur;\n\t\t\t\tcur = cur-&gt;_left;\n\t\t\t}\n\t\t\telse if (cur-&gt;_kv.first &lt; kv.first)//向右找\n\t\t\t{\n\t\t\t\tparent = cur;\n\t\t\t\tcur = cur-&gt;_right;\n\t\t\t}\n\t\t\telse//找到了\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t//没找到，需要插入\n\t\tcur = new Node(kv);\n\t\tif (parent-&gt;_kv.first &lt; cur-&gt;_kv.first)\n\t\t{\n\t\t\tparent-&gt;_right = cur;\n\t\t\tcur-&gt;_parent = parent;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tparent-&gt;_left = cur;\n\t\t\tcur-&gt;_parent = parent;\n\t\t}\n\n\t\treturn true;\n\t}</code></pre>\n<p class=\"img-center\"><img alt=\"\" height=\"142\" src=\"image\\767e98a792c6475aacdb87ddb457d3fe.png\" width=\"220\"/></p>\n<h2 id=\"2.%E6%8E%A7%E5%88%B6%E5%B9%B3%E8%A1%A1%C2%A0\"><span style=\"color:#956fe7;\">2.控制平衡 </span></h2>\n<h3 id=\"%C2%A0%EF%BC%881%EF%BC%89%E6%9B%B4%E6%96%B0%E5%B9%B3%E8%A1%A1%E5%9B%A0%E5%AD%90\"><span style=\"color:#956fe7;\">（1）更新平衡因子</span></h3>\n<p> 一个节点的平衡因子是否需要更新，取决于它的左右子树的高度是否发生变化。插入一个节点，如果它的父亲的平衡因子需要更新，那么它所在这条路径的从父亲到根的所有节点的平衡因子都需要更新。因此</p>\n<p>①如果新增节点是父亲的左子树，那么parent-&gt;_bf--</p>\n<p>②如果新增节点是父亲的右子树，那么parent-&gt;_bf++</p>\n<p>更新后： </p>\n<p>        a.如果parent-&gt;_bf=0，则停止更新</p>\n<p>        b.如果parent-&gt;_bf==1||-1，需要继续往上更新（说明以parent为根的子树高度变了，由0变成了1或-1，有可能导致parent的parent的平衡因子=2或=-2）</p>\n<p>        c.如果parent-&gt;_bf=2||-2已经不平衡了，那么需要旋转处理</p>\n<pre><code class=\"language-cpp\">\t\t//控制平衡\n\t\t//1.更新平衡因子\n\t\twhile (cur != root)\n\t\t{\n\t\t\tif (parent-&gt;_left == cur)//新节点插入到parent左孩子，parent的左子树变高了，平衡因子-1\n\t\t\t{\n\t\t\t\tparent-&gt;_bf--;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tparent-&gt;_bf++;\n\t\t\t}\n\n\t\t\t\n\t\t\tif (parent-&gt;_bf == 0)\n\t\t\t{\n\t\t\t\t//已经平衡，停止更新\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if(parent-&gt;_bf == 1 || parent-&gt;_bf == -1)\n\t\t\t{\n\t\t\t\t//说明以parent为根的子树高度变了，由0变成了1或-1，有可能影响parent的parent的平衡因子，需要继续往上更新\n\t\t\t\tcur = parent;\n\t\t\t\tparent = parent-&gt;_parent;\n\t\t\t}\n\t\t\telse if (parent-&gt;_bf == 2 || parent-&gt;_bf == -2)\n\t\t\t{\n\t\t\t\t//已经出现了不平衡，需要旋转处理\n\t\t\t\tif (parent-&gt;_bf == -2)\n\t\t\t\t{\n\t\t\t\t\tif (cur-&gt;_bf == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\t//右单旋\n\t\t\t\t\t\tRotateR(parent);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//插入新节点之前，树已经不平衡了\n\t\t\t\tassert(false);\n\t\t\t}\n\t\t}</code></pre>\n<h3 id=\"%EF%BC%882%EF%BC%89%E6%97%8B%E8%BD%AC\"><span style=\"color:#956fe7;\">（2）旋转</span></h3>\n<p>旋转处理有4种：右单旋、左单旋、右左单旋、左右单旋</p>\n<h3 id=\"%E2%91%A0%E5%8F%B3%E5%8D%95%E6%97%8B\"><span style=\"color:#956fe7;\"><strong>①右单旋</strong></span></h3>\n<p>将新节点插入到较高左子树的左侧，即左左-----右单旋</p>\n<p> 插入新节点前，AVL树是平衡的，新节点插入到10的左子树，那么10的左子树增加了一层，导致以20为根的二叉树不平衡。为了让20平衡，只能让20的左子树的高度减小一层，并把10的右子树的高度增加一层。</p>\n<p>因此，要把10的左子树往上提，把20转下来，因为20比10大，只能把20放在10的右子树，10的右子树比10大，比20小，因此只能把10的右子树放在20的左子树。再更新节点平衡因子。</p>\n<p><strong>抽象图：</strong></p>\n<p><img alt=\"\" height=\"400\" src=\"image\\a02d63188770491caa94351be641e525.png\" width=\"1200\"/></p>\n<p></p>\n<p></p>\n<p></p>\n<p> 需要考虑的情况：</p>\n<p>（1）10的右孩子可能存在，也可能不存在</p>\n<p>（2）20可能是根节点，也可能是子树；如果是根节点，旋转后，要更新根节点。如果是子树，可能是左子树也可能是右子树，就把20原来的父亲的左或右指向10。</p>\n<pre><code class=\"language-cpp\">\tvoid RotateR(Node* parent)\n\t{\n\t\tNode* subL = parent-&gt;_left;\n\t\tNode* subLR = nullptr;\n\t\t\n\t\tif (subL)\n\t\t{\n\t\t\tsubLR = subL-&gt;_right;\n\t\t}\n\t\t//1.左子树的右子树变我的左子树\n\t\tparent-&gt;_left = subLR;\n\n\t\tif (subLR)\n\t\t{\n\t\t\tsubLR-&gt;_parent = parent;\n\t\t}\n\n\t\t//左子树变父亲\n\t\tsubL-&gt;_right = parent;\n\t\tNode* parentParent = parent-&gt;_parent;\n\t\tparent-&gt;_parent = subL;\n\t\t\n\n\t\tif (parent == _root)//parent是根\n\t\t{\n\t\t\t_root = subL;\n\t\t\t_root-&gt;_parent = nullptr;\n\t\t}\n\t\telse//parent不是根，是子树\n\t\t{\n\t\t\tif (parentParent-&gt;_left == parent)\n\t\t\t{\n\t\t\t\t//parent是自己父亲的左子树,将subL作为parent父亲的左孩子\n\t\t\t\tparentParent-&gt;_left = subL;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//parent是自己父亲的右子树,将subL作为parent父亲的右孩子\n\t\t\t\tparentParent-&gt;_right = subL;\n\t\t\t}\n\t\t\t\n\t\t\t//subL的父亲就是parent的父亲\n\t\t\tsubL-&gt;_parent = parentParent;\n\t\t}\n\n\t\t//更新平衡因子\n\t\tsubL-&gt;_bf = parent-&gt;_bf = 0;\n\t}</code></pre>\n<p></p>\n<p><strong>具象图：</strong></p>\n<p>h=0的情况：</p>\n<p>20变成10的左子树，10的左子树为空，不用考虑 </p>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"282\" src=\"image\\7d3cbe8c23a44f90808e887d61292214.png\" width=\"900\"/></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p>h=1的情况：</p>\n<p>20变成10的右子树，10的右子树12变成20的左子树</p>\n<p> <img alt=\"\" height=\"400\" src=\"image\\ec1dbdc8458240a18a15c013e073d730.png\" width=\"1032\"/></p>\n<p></p>\n<p></p>\n<p></p>\n<p>h=2的情况：</p>\n<p> 20变成10的左子树，10的右子树12变成20的左子树​​​​​​​<img alt=\"\" height=\"488\" src=\"image\\e36dd3cba6544702991a47cd4a56f62c.png\" width=\"1200\"/></p>\n<p></p>\n<p></p>\n<h3 id=\"%E2%91%A1%E5%B7%A6%E5%8D%95%E6%97%8B\"><span style=\"color:#956fe7;\"><strong>②左单旋</strong></span></h3>\n<p> 新节点插入到较高右子树的右侧，即右右-----左单旋</p>\n<p> 插入新节点前，AVL树是平衡的，新节点插入到20的右子树，那么20的右子树增加了一层，导致以10为根的二叉树不平衡。为了让10平衡，只能让10的右子树的高度减小一层，并把20的左子树的高度增加一层。</p>\n<p>因此，要把20的右子树往上提，把10转下来，因为10比20小，只能把10放在20的左子树，20的左子树比20小，比10大，因此只能把20的左子树放在10的右子树。再更新节点平衡因子。</p>\n<p><strong>抽象图：</strong></p>\n<p><img alt=\"\" height=\"387\" src=\"image\\4a5a6bdd9d954cfe964e9d396a50098d.png\" width=\"1200\"/></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p>需要考虑的情况：</p>\n<p>（1）20的左孩子可能存在，也可能不存在</p>\n<p>（2）10可能是根节点，也可能是子树；如果是根节点，旋转后，要更新根节点。如果是子树，可能是左子树也可能是右子树，就把10原来的父亲的左或右指向20。</p>\n<pre><code class=\"language-cpp\">\tvoid RotateL(Node* parent)\n\t{\n\t\tNode* subR = parent-&gt;_right;\n\t\tNode* subRL = nullptr;\n\t\t\n\t\tif (subR)\n\t\t{\n\t\t\tsubRL = subR-&gt;_left;\n\t\t}\n\t\t\t\n\t\t//1.右子树的左子树变我的右子树\n\t\tparent-&gt;_right = subRL;\n\n\t\tif (subRL)\n\t\t{\n\t\t\tsubRL-&gt;_parent = parent;\n\t\t}\n\n\t\t//2.右子树变父亲\n\t\tsubR-&gt;_left = parent;\n\t\tNode* parentParent = parent-&gt;_parent;\n\t\tparent-&gt;_parent = subR;\n\t\t\n\t\tif (parent == _root)//parent是根\n\t\t{\n\t\t\t_root = parent;\n\t\t\t_root-&gt;_parent = nullptr;\n\t\t}\n\t\telse//parent不是根，是子树\n\t\t{\n\t\t\tif (parentParent-&gt;_left == parent)\n\t\t\t{\n\t\t\t\t//parent是自己父亲的左子树,将subR作为parent父亲的左孩子\n\t\t\t\tparentParent-&gt;_left = subR;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//parent是自己父亲的右子树,将subR作为parent父亲的右孩子\n\t\t\t\tparentParent-&gt;_right = subR;\n\t\t\t}\n\n\t\t\t//subR的父亲就是parent的父亲\n\t\t\tsubR-&gt;_parent = parentParent;\n\t\t}\n\n\t\t//更新平衡因子\n\t\tsubR-&gt;_bf = parent-&gt;_bf = 0;\n\t}</code></pre>\n<p><strong>具象图：</strong></p>\n<p>h=0的情况：</p>\n<p>10变成20的左子树，20的左子树为空，不考虑</p>\n<p><img alt=\"\" height=\"243\" src=\"image\\c9c89bffd442421eafc2e4f97898fb97.png\" width=\"912\"/></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p>h=1的情况：</p>\n<p>10变成20的左子树，20的左子树变成10的右子树</p>\n<p><img alt=\"\" height=\"357\" src=\"image\\b7a750f3fbaa48d3a44c7c68e34a544a.png\" width=\"1102\"/></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p>h=2的情况： </p>\n<p> 10变成20的左子树，20的左子树变成10的右子树​​​​​​​<img alt=\"\" height=\"552\" src=\"image\\e9ad84e64473429f875bf47e13cd24e7.png\" width=\"1200\"/></p>\n<p></p>\n<p></p>\n<p></p>\n<h3 id=\"%C2%A0%E2%91%A2%E5%B7%A6%E5%8F%B3%E5%8F%8C%E6%97%8B\"> <span style=\"color:#956fe7;\"><strong>③左右双旋</strong></span></h3>\n<p> 新节点插入较高左子树的右侧---左右：先左单旋再右单旋</p>\n<p>插入新节点前，AVL树是平衡的，新节点插入到20的左子树，那么20的左子树增加了一层，导致以30为根的二叉树不平衡。为了让30平衡，只能让30的左子树的高度减小一层。</p>\n<p>现在30左子树的高度是h+1，但是现在不能把10进行右单旋，因为要把10右单旋，那么20和30都必须处于10的右子树，这办不到。因此要分为两步：</p>\n<p>（1）先把10左单旋</p>\n<p>（2）再把20右单旋</p>\n<p><img alt=\"\" height=\"477\" src=\"image\\7b31361feea246119a63fb9a18ab93eb.png\" width=\"1200\"/></p>\n<p></p>\n<pre><code class=\"language-cpp\">void RotateLR(Node* parent)\n\t{\n\t\tNode* subL = parent-&gt;_left;\n\t\tNode* subLR = subL-&gt;_right;\n\t\tint bf = 0;\n\t\t\n\t\tif (subLR)\n\t\t{\n\t\t\tbf = subLR-&gt;_bf;\n\t\t}\n\t\t\n\n\t\tRotateL(parent-&gt;_left);\n\t\tRotateR(parent);\n\n\t\t//平衡因子调节还需要分析\n\t\tif (bf == -1)\n\t\t{\n\t\t\tsubL-&gt;_bf = 0;\n\t\t\tparent-&gt;_bf = 1;\n\t\t\tsubLR-&gt;_bf = 0;\n\t\t}\n\t\telse if (bf == 1)\n\t\t{\n\t\t\tparent-&gt;_bf = 0;\n\t\t\tsubL-&gt;_bf = -1;\n\t\t\tsubLR-&gt;_bf = 0;\n\t\t}\n\t\telse if (bf == 0)\n\t\t{\n\t\t\tparent-&gt;_bf = 0;\n\t\t\tsubL-&gt;_bf = 0;\n\t\t\tsubLR-&gt;_bf = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tassert(false);\n\t\t}\n\t}</code></pre>\n<p></p>\n<p></p>\n<h3 id=\"%E2%91%A3%E5%8F%B3%E5%B7%A6%E5%8F%8C%E6%97%8B%E2%80%8B%E7%BC%96%E8%BE%91\"><span style=\"color:#956fe7;\">④右左双旋</span></h3>\n<p>新节点插入较高右子树的左侧---右左：先右单旋再左单旋</p>\n<p>插入新节点前，AVL树是平衡的，新节点插入到30的右子树，那么30的右子树增加了一层，导致以10为根的二叉树不平衡。为了让10平衡，只能让10的右子树的高度减小一层。 </p>\n<p>现在10右子树的高度是h+1，但是现在不能把30进行左单旋，因为要把30左单旋，那么10和20都必须处于30的左子树，这办不到。因此要分为两步：</p>\n<p>（1）先把20右单旋</p>\n<p>（2）再把10左单旋</p>\n<h3 id=\"%E2%80%8B%E7%BC%96%E8%BE%91\"><img alt=\"\" height=\"525\" src=\"image\\134c6b5c56344898ad3ea377d1658aa6.png\" width=\"1200\"/></h3>\n<p></p>\n<pre><code class=\"language-cpp\">\tvoid RotateRL(Node* parent)\n\t{\n\t\tNode* subR = parent-&gt;_right;\n\t\tNode* subRL = subR-&gt;_left;\n\t\tint bf = 0;\n\n\t\tif (subRL)\n\t\t{\n\t\t\tbf = subRL-&gt;_bf;\n\t\t}\n\t\t\n\n\t\t//先右旋再左旋\n\t\tRotateR(parent-&gt;_right);\n\t\tRotateL(parent);\n\n\t\t//平衡因子调节还需要具体分析\n\t\tif (bf == 1)\n\t\t{\n\t\t\tparent-&gt;_bf = -1;\n\t\t\tsubR-&gt;_bf = 0;\t\t\t\n\t\t\tsubRL-&gt;_bf = 0;\n\t\t}\n\t\telse if (bf == -1)\n\t\t{\n\t\t\tparent-&gt;_bf = 0;\n\t\t\tsubR-&gt;_bf = 1;\n\t\t\tsubRL-&gt;_bf = 0;\n\t\t}\n\t\telse if (bf == 0)\n\t\t{\n\t\t\tparent-&gt;_bf = 0;\n\t\t\tsubR-&gt;_bf = 0;\n\t\t\tsubRL-&gt;_bf = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tassert(false);\n\t\t}\n\t}</code></pre>\n<p></p>\n<h1 id=\"%E5%9B%9B%E3%80%81AVL%E6%A0%91%E6%9F%A5%E6%89%BE\"><span style=\"color:#956fe7;\">四、AVL树查找</span></h1>\n<p>查找比较简单：</p>\n<p>（1）如果key比当前节点大，那就继续向右查找；</p>\n<p>（2）如果key比当前节点小，那就继续向左查找；</p>\n<p>（3）如果key恰好等于当前节点，找到了</p>\n<pre><code class=\"language-cpp\">\tNode* Find(const K&amp; key)\n\t{\n\t\tNode* cur = _root;\n\t\twhile (cur)\n\t\t{\n\t\t\tif (cur.first &lt; key)//比当前节点大，向右查找\n\t\t\t{\n\t\t\t\tcur = cur-&gt;_right;\n\t\t\t}\n\t\t\telse if (cur.first &gt; key)//比当前节点小，向左查找\n\t\t\t{\n\t\t\t\tcur = cur-&gt;_left;\n\t\t\t}\n\t\t\telse//等于当前节点，找到了\n\t\t\t{\n\t\t\t\treturn cur;\n\t\t\t}\n\t\t}\n\t\treturn nullptr;\n\t}</code></pre>\n<h1 id=\"%E4%BA%94%E3%80%81AVL%E6%A0%91%E9%AB%98%E5%BA%A6%C2%A0\"><span style=\"color:#956fe7;\">五、AVL树高度 </span></h1>\n<p>计算树高度肯定要递归计算：</p>\n<p>（1）计算左右子树的高度</p>\n<p>（2）谁的高度大，那AVL树的高度就为较高子树的高度+1</p>\n<pre><code class=\"language-cpp\">\t//求树的高度\n\tint Height(Node* root)\n\t{\n\t\tif (root == nullptr)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\n\t\tint leftHeight = Height(root-&gt;_left);\n\t\tint rightHeight = Height(root-&gt;_right);\n\n\t\treturn leftHeight &gt; rightHeight ? leftHeight + 1 : rightHeight + 1;\n\t}</code></pre>\n<h1 id=\"%C2%A0%E5%85%AD%E3%80%81%E6%A3%80%E6%9F%A5AVL%E6%A0%91%E6%98%AF%E5%90%A6%E5%B9%B3%E8%A1%A1\"><span style=\"color:#956fe7;\"> 六、判断是否为AVL树</span></h1>\n<p>检查树是否是AVL树：</p>\n<p>（1）获取左右子树高度</p>\n<p>（2）根据左右子树高度计算平衡因子</p>\n<p>（3）当平衡因子&lt;=2 || -2时就是平衡的</p>\n<pre><code class=\"language-cpp\">\tbool _IsBanlance(Node* root)\n\t{\n\t\tif (root == nullptr)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\n\t\tint leftHeight = Height(root-&gt;_left);\n\t\tint rightHeight = Height(root-&gt;_right);\n\n\t\t//检查平衡因子是否正确\n\t\tif (rightHeight - leftHeight != root-&gt;_bf)\n\t\t{\n\t\t\tcout &lt;&lt; \"平衡因子异常：\" &lt;&lt; root-&gt;_kv.first &lt;&lt; endl;\n\t\t\treturn false;\n\t\t}\n\n\t\treturn abs(rightHeight - leftHeight) &lt; 2\n\t\t\t&amp;&amp; _IsBanlance(root-&gt;_left)\n\t\t\t&amp;&amp; _IsBanlance(root-&gt;_right);\n\t}\n\n\t//判断是否是AVL树\n\tbool IsAVLTree()\n\t{\n\t\treturn _IsBanlance(_root);\n\t}</code></pre>\n<h1 id=\"%E4%B8%83%E3%80%81AVL%E6%A0%91%E9%81%8D%E5%8E%86\"><span style=\"color:#956fe7;\">七、AVL树遍历</span></h1>\n<p>遍历也很简单：递归遍历左子树和右子树即可 </p>\n<pre><code class=\"language-cpp\">\tvoid _InOrder(Node* root)\n\t{\n\t\tif (root == nullptr)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\t_InOrder(root-&gt;_left);\n\t\tcout &lt;&lt; root-&gt;_kv.first &lt;&lt; \":\" &lt;&lt; root-&gt;_kv.second &lt;&lt; endl;\n\t\t_InOrder(root-&gt;_right);\n\t}\n\n\tvoid InOrder()\n\t{\n\t\t_InOrder(_root);\n\t}</code></pre>\n<h1 id=\"%E5%85%AB%E3%80%81%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6\"><span style=\"color:#956fe7;\">八、时间复杂度</span></h1>\n<p>AVL树的操作时，需要找到位置，因此时间复杂度为高度次，即O(<img alt=\"\" height=\"17\" src=\"image\\562321f7fcf740d795ff8a99e9711ed4.png\" width=\"39\"/>) 。</p>\n<p></p>\n</div>\n</div>"}