{"blogid": "126690070", "writerAge": "码龄2年", "writerBlogNum": "152", "writerCollect": "432", "writerComment": "21", "writerFan": "36", "writerGrade": "5级", "writerIntegral": "1818", "writerName": "爱喝牛奶~", "writerProfileAdress": "writer_image\\profile_126690070.jpg", "writerRankTotal": "10971", "writerRankWeekly": "2627", "writerThumb": "277", "writerVisitNum": "35749", "blog_read_count": "78", "blog_time": "已于 2022-09-07 14:22:57 修改", "blog_title": "Vue——全局组件、局部组件、组件的嵌套、单文件组件、组件的属性、v-slot: 插槽、css的作用域、面试题（组件基础）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E7%BB%84%E4%BB%B6%E5%9F%BA%E7%A1%80%EF%BC%88%E9%9D%A2%E8%AF%95%EF%BC%89-toc\" style=\"margin-left:0px;\"><a href=\"#%E7%BB%84%E4%BB%B6%E5%9F%BA%E7%A1%80%EF%BC%88%E9%9D%A2%E8%AF%95%EF%BC%89\">组件基础（面试）</a></p>\n<p id=\"1.%E5%85%A8%E5%B1%80%E7%BB%84%E4%BB%B6%3A-toc\" style=\"margin-left:0px;\"><a href=\"#1.%E5%85%A8%E5%B1%80%E7%BB%84%E4%BB%B6%3A\">1.全局组件:</a></p>\n<p id=\"2.%E5%B1%80%E9%83%A8%E7%BB%84%E4%BB%B6%3A-toc\" style=\"margin-left:0px;\"><a href=\"#2.%E5%B1%80%E9%83%A8%E7%BB%84%E4%BB%B6%3A\">2.局部组件:</a></p>\n<p id=\"%C2%A03.%E7%BB%84%E4%BB%B6%E7%9A%84%E5%B5%8C%E5%A5%97%3A-toc\" style=\"margin-left:0px;\"><a href=\"#%C2%A03.%E7%BB%84%E4%BB%B6%E7%9A%84%E5%B5%8C%E5%A5%97%3A\"> 3.组件的嵌套:</a></p>\n<p id=\"4.%E5%8D%95%E6%96%87%E4%BB%B6%E7%BB%84%E4%BB%B6%3A-toc\" style=\"margin-left:0px;\"><a href=\"#4.%E5%8D%95%E6%96%87%E4%BB%B6%E7%BB%84%E4%BB%B6%3A\">4.单文件组件:</a></p>\n<p id=\"5.%E7%BB%84%E4%BB%B6%E7%9A%84%E5%B1%9E%E6%80%A7-toc\" style=\"margin-left:0px;\"><a href=\"#5.%E7%BB%84%E4%BB%B6%E7%9A%84%E5%B1%9E%E6%80%A7\">5.组件的属性</a></p>\n<p id=\"6.v-slot%3A%20%E6%8F%92%E6%A7%BD-toc\" style=\"margin-left:0px;\"><a href=\"#6.v-slot%3A%20%E6%8F%92%E6%A7%BD\">6.v-slot: 插槽</a></p>\n<p id=\"7.%E7%BB%84%E4%BB%B6%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6%E5%92%8C%E5%8E%9F%E7%94%9F%E4%BA%8B%E4%BB%B6-toc\" style=\"margin-left:0px;\"><a href=\"#7.%E7%BB%84%E4%BB%B6%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6%E5%92%8C%E5%8E%9F%E7%94%9F%E4%BA%8B%E4%BB%B6\">7.组件的自定义事件和原生事件</a></p>\n<p id=\"7.css%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F-toc\" style=\"margin-left:0px;\"><a href=\"#7.css%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F\">8.css的作用域</a></p>\n<p id=\"7.%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E7%BB%84%E4%BB%B6%E5%9F%BA%E7%A1%80%EF%BC%89-toc\" style=\"margin-left:0px;\"><a href=\"#7.%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E7%BB%84%E4%BB%B6%E5%9F%BA%E7%A1%80%EF%BC%89\">9.面试题（组件基础）</a></p>\n<p id=\"1%20%40%20%E6%98%AF%E4%B8%80%E4%B8%AA%E5%85%B3%E9%94%AE%E5%AD%97%2C%E5%9C%A8%E5%BC%95%E5%85%A5%E7%9A%84%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E4%B8%AD%20%E5%AE%83%E4%BB%A3%E8%A1%A8src%E7%9B%AE%E5%BD%95-toc\" style=\"margin-left:40px;\"><a href=\"#1%20%40%20%E6%98%AF%E4%B8%80%E4%B8%AA%E5%85%B3%E9%94%AE%E5%AD%97%2C%E5%9C%A8%E5%BC%95%E5%85%A5%E7%9A%84%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E4%B8%AD%20%E5%AE%83%E4%BB%A3%E8%A1%A8src%E7%9B%AE%E5%BD%95\">1 @ 是一个关键字,在引入的文件路径中 它代表src目录</a></p>\n<p id=\"2%20template%3A%E7%BB%84%E4%BB%B6%E7%9A%84%E6%A8%A1%E6%9D%BF%E4%B8%AD%E5%8F%AA%E8%83%BD%E6%9C%89%E4%B8%80%E4%B8%AA%E6%A0%B9%E8%8A%82%E7%82%B9-toc\" style=\"margin-left:40px;\"><a href=\"#2%20template%3A%E7%BB%84%E4%BB%B6%E7%9A%84%E6%A8%A1%E6%9D%BF%E4%B8%AD%E5%8F%AA%E8%83%BD%E6%9C%89%E4%B8%80%E4%B8%AA%E6%A0%B9%E8%8A%82%E7%82%B9\">2 template:组件的模板中只能有一个根节点</a></p>\n<p id=\"3%20v-slot%3A%20%E6%8F%92%E6%A7%BD%2C%20%E5%85%B7%E5%90%8D%E6%8F%92%E6%A7%BD%20slot%2Cslot-scope%E8%BF%87%E6%97%B6%E4%BA%86%202.6.0%E4%BD%BF%E7%94%A8v-slot-toc\" style=\"margin-left:40px;\"><a href=\"#3%20v-slot%3A%20%E6%8F%92%E6%A7%BD%2C%20%E5%85%B7%E5%90%8D%E6%8F%92%E6%A7%BD%20slot%2Cslot-scope%E8%BF%87%E6%97%B6%E4%BA%86%202.6.0%E4%BD%BF%E7%94%A8v-slot\">3 v-slot: 插槽, 具名插槽 slot,slot-scope过时了 2.6.0使用v-slot</a></p>\n<p id=\"4%20%E7%BB%84%E4%BB%B6%E7%9A%84data%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%AA%E5%87%BD%E6%95%B0%E7%84%B6%E5%90%8E%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%2C%E4%BB%A5%E5%89%8D%E4%BD%BF%E7%94%A8vm%E6%97%B6%E9%83%BD%E6%98%AF%E4%B8%AA%E5%AF%B9%E8%B1%A1-toc\" style=\"margin-left:40px;\"><a href=\"#4%20%E7%BB%84%E4%BB%B6%E7%9A%84data%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%AA%E5%87%BD%E6%95%B0%E7%84%B6%E5%90%8E%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%2C%E4%BB%A5%E5%89%8D%E4%BD%BF%E7%94%A8vm%E6%97%B6%E9%83%BD%E6%98%AF%E4%B8%AA%E5%AF%B9%E8%B1%A1\">4 组件的data为什么是个函数然后返回对象,以前使用vm时都是个对象</a></p>\n<p id=\"5%20scoped%3A%20%C2%A0style%E6%A0%87%E7%AD%BE%E7%9A%84scoped%3D%22scoped%22%20%E7%94%9F%E6%88%90css%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%8F%AA%E6%9C%89%E5%BD%93%E5%89%8D%E7%BB%84%E4%BB%B6%E5%86%85%E9%83%A8%E7%9A%84%E9%80%89%E6%8B%A9%E5%99%A8%E7%94%9F%E6%95%88-toc\" style=\"margin-left:40px;\"><a href=\"#5%20scoped%3A%20%C2%A0style%E6%A0%87%E7%AD%BE%E7%9A%84scoped%3D%22scoped%22%20%E7%94%9F%E6%88%90css%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%8F%AA%E6%9C%89%E5%BD%93%E5%89%8D%E7%BB%84%E4%BB%B6%E5%86%85%E9%83%A8%E7%9A%84%E9%80%89%E6%8B%A9%E5%99%A8%E7%94%9F%E6%95%88\">5 scoped:  style标签的scoped=\"scoped\" 生成css的使用作用域只有当前组件内部的选择器生效</a></p>\n<p id=\"6%20%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81%E7%9A%84%E9%A1%BA%E5%BA%8F-toc\" style=\"margin-left:40px;\"><a href=\"#6%20%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81%E7%9A%84%E9%A1%BA%E5%BA%8F\">6 数据劫持的顺序</a></p>\n<p id=\"7%C2%A0%E5%9C%A8%E4%BD%BF%E7%94%A8%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%87%BD%E6%95%B0%E5%90%8D%E5%92%8C%20data%20%E6%95%B0%E6%8D%AE%E6%BA%90%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8F%AF%E4%BB%A5%20%E5%90%8C%E5%90%8D%E5%90%97%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#7%C2%A0%E5%9C%A8%E4%BD%BF%E7%94%A8%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%87%BD%E6%95%B0%E5%90%8D%E5%92%8C%20data%20%E6%95%B0%E6%8D%AE%E6%BA%90%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8F%AF%E4%BB%A5%20%E5%90%8C%E5%90%8D%E5%90%97%EF%BC%9F\">7 在使用计算属性的时候，函数名和 data 数据源中的数据可以 同名吗？</a></p>\n<p id=\"8%E3%80%81%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84%E9%A1%B9%E7%9B%AE-toc\" style=\"margin-left:40px;\"><a href=\"#8%E3%80%81%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84%E9%A1%B9%E7%9B%AE\">8、怎么跑起来的项目</a></p>\n<p id=\"9%E3%80%81%E5%A6%82%E6%9E%9Cel%E5%92%8C%24mount%E9%83%BD%E5%86%99%E4%BA%86%EF%BC%8C%E4%BC%9A%E4%B8%8D%E4%BC%9A%E5%86%B2%E7%AA%81-toc\" style=\"margin-left:40px;\"><a href=\"#9%E3%80%81%E5%A6%82%E6%9E%9Cel%E5%92%8C%24mount%E9%83%BD%E5%86%99%E4%BA%86%EF%BC%8C%E4%BC%9A%E4%B8%8D%E4%BC%9A%E5%86%B2%E7%AA%81\">9、如果el和$mount都写了，会不会冲突</a></p>\n<p id=\"10%E3%80%81Vue%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%EF%BC%9A-toc\" style=\"margin-left:40px;\"><a href=\"#10%E3%80%81Vue%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%EF%BC%9A\">10、Vue加载流程：</a></p>\n<p id=\"11%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFDIFF-toc\" style=\"margin-left:40px;\"><a href=\"#11%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFDIFF\">11、什么是DIFF</a></p>\n<p id=\"12%E3%80%81DIFF%E7%AE%97%E6%B3%95%E7%9A%84%E8%BF%87%E7%A8%8B%20%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89-toc\" style=\"margin-left:40px;\"><a href=\"#12%E3%80%81DIFF%E7%AE%97%E6%B3%95%E7%9A%84%E8%BF%87%E7%A8%8B%20%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89\">12、DIFF算法的过程 （了解）</a></p>\n<p id=\"13%E3%80%81%E4%B8%8B%E5%88%97%E5%AF%B9%20Vue%20%E5%8E%9F%E7%90%86%E7%9A%84%E5%8F%99%E8%BF%B0%EF%BC%8C%E5%93%AA%E4%BA%9B%E6%98%AF%E6%AD%A3%E7%A1%AE%E7%9A%84%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#13%E3%80%81%E4%B8%8B%E5%88%97%E5%AF%B9%20Vue%20%E5%8E%9F%E7%90%86%E7%9A%84%E5%8F%99%E8%BF%B0%EF%BC%8C%E5%93%AA%E4%BA%9B%E6%98%AF%E6%AD%A3%E7%A1%AE%E7%9A%84%EF%BC%9F\">13、下列对 Vue 原理的叙述，哪些是正确的？</a></p>\n<p id=\"14%E3%80%81%E5%AF%B9%E4%BA%8E%20Vue%20%E4%B8%AD%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%8E%9F%E7%90%86%E7%9A%84%E8%AF%B4%E6%B3%95%EF%BC%8C%E4%B8%8B%E5%88%97%E5%93%AA%E9%A1%B9%E6%98%AF%E4%B8%8D%E6%AD%A3%E7%A1%AE%E7%9A%84%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#14%E3%80%81%E5%AF%B9%E4%BA%8E%20Vue%20%E4%B8%AD%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%8E%9F%E7%90%86%E7%9A%84%E8%AF%B4%E6%B3%95%EF%BC%8C%E4%B8%8B%E5%88%97%E5%93%AA%E9%A1%B9%E6%98%AF%E4%B8%8D%E6%AD%A3%E7%A1%AE%E7%9A%84%EF%BC%9F\">14、对于 Vue 中响应式数据原理的说法，下列哪项是不正确的？</a></p>\n<p id=\"%C2%A015%E3%80%81%C2%A0%E4%B8%8B%E5%88%97%E8%AF%B4%E6%B3%95%E4%B8%8D%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%98%AF%E5%93%AA%E9%A1%B9%EF%BC%9F-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A015%E3%80%81%C2%A0%E4%B8%8B%E5%88%97%E8%AF%B4%E6%B3%95%E4%B8%8D%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%98%AF%E5%93%AA%E9%A1%B9%EF%BC%9F\"> 15、 下列说法不正确的是哪项？</a></p>\n<p id=\"16%E3%80%81%E9%9D%A2%E8%AF%95%E8%80%83%E7%82%B9-toc\" style=\"margin-left:40px;\"><a href=\"#16%E3%80%81%E9%9D%A2%E8%AF%95%E8%80%83%E7%82%B9\">16、面试考点</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<p></p>\n<p></p>\n<h1 id=\"%E7%BB%84%E4%BB%B6%E5%9F%BA%E7%A1%80%EF%BC%88%E9%9D%A2%E8%AF%95%EF%BC%89\">组件基础（面试）</h1>\n<p> 组件一：</p>\n<pre><code class=\"language-html\">\t&lt;div id='app'&gt;\n\t\t&lt;Box&gt;&lt;/Box&gt;\n\t&lt;/div&gt;\n\t&lt;script&gt;\n\t\tvar vm = new Vue({\n\t\t\tel: '#app',\n\t\t\tdata: {},\n\t\t\tmethods: {},\n\t\t\tcomponents: {\n\t\t\t\tBox: {\n\t\t\t\t\ttemplate: `&lt;div&gt;\n\t\t\t\t\t              &lt;h1&gt;6666&lt;/h1&gt;\n\t\t\t\t\t\t           &lt;p&gt;hello&lt;/p&gt;\n\t\t\t\t\t               &lt;/div&gt;`\n\t\t\t\t}\n\t\t\t},\n\t\t})\n\t&lt;/script&gt;</code></pre>\n<h1></h1>\n<p>组件二：</p>\n<pre><code class=\"language-html\">&lt;div id='app'&gt;\n\t\t\t&lt;Box&gt;&lt;/Box&gt;\n\t\t&lt;/div&gt;\n\t\t&lt;script&gt;\n\t\t\tlet a1 = {\n\t\t\t\ttemplate: `&lt;div&gt;\n\t\t\t\t\t              &lt;h1&gt;6666&lt;/h1&gt;\n\t\t\t\t\t\t           &lt;p&gt;hello&lt;/p&gt;\n\t\t\t\t\t               &lt;/div&gt;`\n\t\t\t}\n\t\t\tvar vm = new Vue({\n\t\t\t\tel: '#app',\n\t\t\t\tdata: {},\n\t\t\t\tmethods: {},\n\t\t\t\tcomponents: {\n\t\t\t\t\t//注册组件\n\t\t\t\t\tBox: a1\n\t\t\t\t}\n\t\t\t})\n\t\t&lt;/script&gt;</code></pre>\n<h1></h1>\n<p>组件三：</p>\n<pre><code class=\"language-html\">\t&lt;div id='app'&gt;\n\t\t\t&lt;Box&gt;&lt;/Box&gt;\n\t\t&lt;/div&gt;\n\t\t&lt;script type=\"module\"&gt;\t\t\n\t\t   //1.导入\n\t\t\timport Box from \"./componnets/Box.js\"\n\t\t\tvar vm = new Vue({\n\t\t\t\tel: '#app',\n\t\t\t\tdata: {},\n\t\t\t\tmethods: {},\n\t\t\t\tcomponents: {\n\t\t\t\t\tBox\n\t\t\t\t}\n\t\t\t})\n\t\t&lt;/script&gt;</code></pre>\n<h1></h1>\n<p>组件四：</p>\n<pre><code class=\"language-html\">&lt;div id='app'&gt;\n\t\t\t&lt;Box&gt;&lt;/Box&gt;\n\t\t\t&lt;Box2&gt;&lt;/Box2&gt;\n\t\t&lt;/div&gt;\n\t\t&lt;script type=\"module\"&gt;\t\t\n\t\t   //1.导入\n\t\t\timport Box from \"./componnets/Box.js\"\n\t\t\tvar vm = new Vue({\n\t\t\t\tel: '#app',\n\t\t\t\tdata: {},\n\t\t\t\tmethods: {},\n\t\t\t\tcomponents: {\n\t\t\t\t\t//2.注册组件\n\t\t\t\t\tBox,\n\t\t\t\t\tBox2:{\n\t\t\t\t\t\ttemplate:`&lt;div&gt;\n\t\t\t\t\t\t       &lt;h1&gt;666-box2&lt;/h1&gt;\n\t\t\t\t\t\t\t   &lt;p @click=\"fn\"&gt;{<!-- -->{msg}}&lt;/p&gt;\n\t\t\t\t\t\t &lt;/div&gt;`,\n\t\t\t\t\t\tdata:function(){\n\t\t\t\t\t\t\treturn {msg:\"msg66666\"}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tmethods:{\n\t\t\t\t\t\t\tfn(){console.log(\"Box2组件的方法\")}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfilters: {},\n\t\t\t\t\t\twatch: {},\n\t\t\t\t\t\tcomputed: {},\n\t\t\t\t\t\tdirectives: {},\n\t\t\t\t\t\tbeforeCreate() {},\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tfilters: {},\n\t\t\t\twatch: {},\n\t\t\t\tcomputed: {},\n\t\t\t\tdirectives: {},\n\t\t\t\tbeforeCreate() {},\n\t\t\t})\n\t\t&lt;/script&gt;</code></pre>\n<p></p>\n<p></p>\n<h1 id=\"1.%E5%85%A8%E5%B1%80%E7%BB%84%E4%BB%B6%3A\">1.全局组件:</h1>\n<p>全局:所有组件共同的功能(指令,过滤器,组件)</p>\n<blockquote>\n<p><strong>组件的属性不能用大写字母</strong></p>\n<p>注册组件时，组件名不要用系统已经使用过的，组件template模板中，只能有一个根元素<br/><strong>组件的名字可以用驼峰命名法,但是使用的时候必须用连字符</strong><br/> 全局注册的组件使用时不能使用单标签(不会报错,但是只能使用一次 多次使用只显示第一个)</p>\n<p><strong>注册的组件不要跟系统标签同名</strong></p>\n</blockquote>\n<h1 id=\"2.%E5%B1%80%E9%83%A8%E7%BB%84%E4%BB%B6%3A\"><br/> 2.局部组件:</h1>\n<blockquote>\n<p>局部:只有当前组件的功能(指令,过滤器,组件)</p>\n<p>一个vm（根组件）实例可以有多个局部组件,但是只能供当前vm实例使用</p>\n</blockquote>\n<p></p>\n<h1 id=\"%C2%A03.%E7%BB%84%E4%BB%B6%E7%9A%84%E5%B5%8C%E5%A5%97%3A\"> 3.组件的嵌套:</h1>\n<blockquote>\n<p>.vue文件既可以是一个页面,也可以是一个组件<br/> 它可以被别人.vue文件引入 然后作为组件使用</p>\n</blockquote>\n<p></p>\n<pre><code class=\"language-html\">\t&lt;style type=\"text/css\"&gt;\n\t\t\t.app {\n\t\t\t\twidth: 400px;\n\t\t\t\theight: 900px;\n\t\t\t\tbackground-color: gold;\n\t\t\t}\n\t\t\t.box1 {\n\t\t\t\twidth: 200px;\n\t\t\t\theight: 200px;\n\t\t\t\tbackground-color: darkorange;\n\t\t\t\tmargin: 20px;\n\t\t\t}\n\t\t\t.box11{\n\t\t\t\twidth: 100px;\n\t\t\t\theight: 50px;\n\t\t\t\tbackground-color: hotpink;\n\t\t\t\tmargin: 20px;\n\t\t\t}\n\t\t&lt;/style&gt;\n\t\t&lt;div id='app' class=\"app\"&gt;\n\t\t\t&lt;Box1&gt;&lt;/Box1&gt;\n\t\t\t&lt;Box1&gt;&lt;/Box1&gt;\n\t\t\t&lt;Box2&gt;&lt;/Box2&gt;\n\t\t\t&lt;p&gt;{<!-- -->{msg|box1tool}}&lt;/p&gt;\n\t\t\t&lt;p v-color2=\"'blue'\" v-color&gt;{<!-- -->{msg|alltool1}}&lt;/p&gt;\n\t\t\t&lt;allbox&gt;&lt;/allbox&gt;\n\t\t&lt;/div&gt;\n\t\t&lt;script&gt;\n\t\t\t// 全局:所有组件共同的功能(指令,过滤器,组件) \n\t\t\t// 局部:只有当前组件的功能(指令,过滤器,组件)\n\t\t\tVue.filter(\"alltool1\",function(str){\n\t\t\t\treturn str+\"-alltool1\"\n\t\t\t})\n\t\t\tVue.filter(\"alltool2\",function(str){  //注册过滤器\n\t\t\t\treturn str+\"-alltool1\"\n\t\t\t})\n\t\t\tVue.directive(\"color\",function(el,obj){  //注册全局自定义指令\n\t\t\t\tel.style.color=obj.value||\"red\"\n\t\t\t})\n\t\t\tVue.component(\"allbox\",{\n\t\t\t\ttemplate:\"&lt;div&gt;6666allbox&lt;/div&gt;\"\t\t\t\n\t\t\t})\n\t\t\tvar vm = new Vue({\n\t\t\t\tel: '#app',\n\t\t\t\tdata: {\n\t\t\t\t\tmsg:\"appdata\"\n\t\t\t\t},\n\t\t\t\tmethods: {},\n\t\t\t\tcomponents: {\n\t\t\t\t\tBox1: {  // 不能访问上面的data\n\t\t\t\t\t\ttemplate: `&lt;div class=\"box1\"&gt;\n\t\t\t\t\t\t &lt;p&gt;{<!-- -->{msg|box1tool}}&lt;/p&gt;\n\t\t\t\t\t\t  &lt;p v-color2=\"'blue'\" v-color&gt;{<!-- -->{msg|alltool1}}&lt;/p&gt;\n\t\t\t\t\t\t  &lt;Box11&gt;&lt;/Box11&gt;\n\t\t\t\t\t\t  &lt;allbox/&gt;\t\n\t\t\t\t\t\t &lt;/div&gt;`,\n\t\t\t\t\t\tdata: function() {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tmsg: \"hello\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tmethods: {},\n\t\t\t\t\t\tfilters: {\n\t\t\t\t\t\t\tbox1tool(str) {\n\t\t\t\t\t\t\t\treturn str + \"box1-filter\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tdirectives:{\n\t\t\t\t\t\t\tcolor2:{\n\t\t\t\t\t\t\t\tinserted(el,obj){\n\t\t\t\t\t\t\t\t\tel.style.background=obj.value||\"red\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcomponents:{\n\t\t\t\t\t\t\tBox11:{   //组件的嵌套\n\t\t\t\t\t\t\t\ttemplate:`&lt;div class=\"box11\"&gt;\n\t\t\t\t\t\t\t\t         &lt;h1&gt;box11&lt;/h1&gt;\n\t\t\t\t\t\t\t\t &lt;/div&gt;`\n\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tBox2:{\n\t\t\t\t\t\ttemplate:`&lt;div&gt;\n\t\t\t\t\t\t        &lt;h1&gt;{<!-- -->{msg|box1tool}}&lt;/h1&gt;\n\t\t\t\t\t\t\t\t &lt;h1&gt;{<!-- -->{msg|alltool1}}&lt;/h1&gt;\n\t\t\t\t\t\t&lt;/div&gt;`,\n\t\t\t\t\t\tdata:function(){\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tmsg:\"box2data\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t&lt;/script&gt;</code></pre>\n<p></p>\n<h1 id=\"4.%E5%8D%95%E6%96%87%E4%BB%B6%E7%BB%84%E4%BB%B6%3A\">4.单文件组件:</h1>\n<p>vue create init ==&gt;下载后启动，就会自己生成vue页面</p>\n<blockquote>\n<p>引入:@1官方脚手架 @2挂载vm对象 @3组件引入并渲染到vm中</p>\n<p>单文件组件也有全局组件和局部组件<br/> 只是把一个组件单独写在一个.vue文件中,供别的组件引入然后注册<br/> 引入文件时:一般使用相对路径  上一下用../  同级使用./   下级使用/   <strong>@ 代表src文件夹</strong></p>\n<p><strong>注册的组件名不能跟Vue中的和原生DOM的重名，注册的名字是驼峰，使用时就用连字符</strong></p>\n<p>注册的组件，使用时可以用双标签也可以用单标签：如果有插槽必须使用双标签</p>\n</blockquote>\n<blockquote>\n<p>如果.Vue的script注释了，在打包的时候Vue的打包环境，会帮我们把这个文件解析为一个对象，然后给这个对象添加一个template属性，值为解析的&lt;template&gt;页面模板</p>\n<p></p>\n<p>==&gt;所以.Vue文件中可以没有script，style标签，但是不能没有template（注册组件的时候有就可以了，没有导出语法，加载器 脚手架会去创建对象）</p>\n<p>（至少有一个模板或者render函数）</p>\n<p>不写script标签==&gt;称为静态组件</p>\n</blockquote>\n<blockquote>\n<p> 每一个组件内部只能有一个根元素，不要在根元素上写v-for</p>\n<p>style标签可以写多个，也可以不写 </p>\n</blockquote>\n<blockquote>\n<p> 在项目下创建vue.config.js 就是vue的打包配置文件:</p>\n<p>const { defineConfig } = require('@vue/cli-service')</p>\n<p>module.exports = defineConfig({<!-- --></p>\n<p>  transpileDependencies: true,</p>\n<p>  lintOnSave:false//关闭eslint的严格模式检测</p>\n<p>})</p>\n</blockquote>\n<pre><code class=\"language-html\">&lt;div id=\"app\"&gt;\n\t\t\t&lt;nav1 son-proprety=\"子组件使用时属性传进去的值\"&gt;&lt;/nav1&gt;\t\n\t\t\t&lt;content1 img2src=\"./img/2.png\"&gt;&lt;/content1&gt;\n\t\t&lt;/div&gt;\n\t\t\n\t\t&lt;div id=\"app2\"&gt;\n\t\t\t&lt;nav1 son-proprety=\"子组件使用时属性传进去的值2\"&gt;&lt;/nav1&gt;\n\t\t\t&lt;content1 img2src=\"./img/2.png\"&gt;&lt;/content1&gt;\t\n\t\t&lt;/div&gt;\n\t\t&lt;script type=\"text/javascript\"&gt;\n\t\t   //祖册全局组件\n\t\t\tVue.component(\"nav1\",{\n\t\t\t\tdata(){return {sondata:\"子组件的数据\"}},\n\t\t\t\ttemplate:`&lt;div&gt;&lt;h1&gt;{<!-- -->{sondata}}&lt;/h1&gt;&lt;p&gt;{<!-- -->{sonProprety}}&lt;/p&gt;&lt;/div&gt;`,\n\t\t\t\tprops:[\"sonProprety\"]\n\t\t\t})\n\t\t\t\n\t\t\t\n\t\t\t// let content1={\n\t\t\t// \t\t\tdata(){return {img1:\"./img/1.png\"}},\n\t\t\t// \t\t\ttemplate:`&lt;div&gt;&lt;img :src=\"img1\"/&gt;&lt;img :src=\"img2src\"/&gt;&lt;/div&gt;`,\n\t\t\t// \t\t\tprops:[\"img2src\"]\n\t\t\t// \t\t}\n\t\t\t\n\t\t\t\n\t\t\tnew Vue({\n\t\t\t\tel:\"#app\",\n\t\t\t\tdata:{},\n\t\t\t\tcomponents:{\n\t\t\t\t\t// content1\n\t\t\t\t\t//注册局部组件\n\t\t\t\t\tcontent1:{\n\t\t\t\t\t\t\t\tdata(){return {img1:\"./img/1.png\"}},\n\t\t\t\t\t\t\t\ttemplate:`&lt;div&gt;&lt;img :src=\"img1\"/&gt;&lt;img :src=\"img2src\"/&gt;&lt;/div&gt;`,\n\t\t\t\t\t\t\t\tprops:[\"img2src\"]\n\t\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t\tnew Vue({\n\t\t\t\tel:\"#app2\",\n\t\t\t\tdata:{}\t\t\t\t\n\t\t\t})\n\t\t&lt;/script&gt;</code></pre>\n<p><strong>组件一：</strong></p>\n<p><strong>index.html</strong></p>\n<pre><code class=\"language-html\">&lt;style type=\"text/css\"&gt;\n\t\t\t.nav1{\n\t\t\t\twidth: 100%;\n\t\t\t\theight: 40px;\n\t\t\t\tbackground-color: gainsboro;\n\t\t\t\tdisplay: flex;\n\t\t\t\tjustify-content: flex-start;\n\t\t\t\tflex-wrap: nowrap;\n\t\t\t}\n\t\t\t.nav1 div{\n\t\t\t\tmargin-left: 20px;\n\t\t\t\tline-height: 40px;\n\t\t\t}\n\t\t\t.newsbox{\n\t\t\t\twidth: 100%;\n\t\t\t\tpadding: 20px;\n\t\t\t\tmargin: 30px;\n\t\t\t\tbackground-color: paleturquoise;\n\t\t\t}\n\t\t&lt;/style&gt;\n\t\t&lt;div id='app'&gt;\n\t\t\t&lt;Nav1&gt;&lt;/Nav1&gt;\n\t\t\t&lt;news-box v-for=\"el in 10\"&gt;&lt;/news-box&gt;  &lt;!-- 组件循环10次 --&gt;\n\t\t\t&lt;Footer1&gt;&lt;/Footer1&gt;\n\t\t&lt;/div&gt;\n\t\t&lt;script type=\"module\"&gt;\n\t\timport NewsBox from \"./com/NewsBox.js\"\n\t\timport Footer1 from \"./com/Footer1.js\"\n\t\t\tvar vm = new Vue({\n\t\t\t\tel: '#app',\n\t\t\t\tdata: {},\n\t\t\t\tmethods: {},\n\t\t\t\tcomponents:{\n\t\t\t\t\tNav1:{\n\t\t\t\t\t\ttemplate:`&lt;div class=\"nav1\"&gt;\n\t\t\t\t\t\t       &lt;div&gt;btn&lt;/div&gt;\n\t\t\t\t\t\t\t    &lt;div&gt;btn&lt;/div&gt;\n\t\t\t\t\t\t\t\t &lt;div&gt;btn&lt;/div&gt;\n\t\t\t\t\t\t\t\t  &lt;div&gt;btn&lt;/div&gt;\n\t\t\t\t\t\t\t\t   &lt;div&gt;btn&lt;/div&gt;\n\t\t\t\t\t\t\t\t    &lt;div&gt;btn&lt;/div&gt;\n\t\t\t\t\t\t&lt;/div&gt;`\n\t\t\t\t\t},\n\t\t\t\t\tNewsBox:NewsBox,\n\t\t\t\t\tFooter1\n\t\t\t\t}\n\t\t\t})\n\t\t&lt;/script&gt;</code></pre>\n<p><strong>com/NewsBox.js</strong></p>\n<pre><code class=\"language-javascript\">export default {\n\ttemplate:`&lt;div class=\"newsbox\"&gt;\n\t       &lt;h2 @click=\"fn\"&gt;新闻标题&lt;/h2&gt;\n\t\t   &lt;p&gt;新闻内容啊&lt;/p&gt;\n\t&lt;/div&gt;`,\n\tmethods:{\n\t\tfn(){\n\t\t\tconsole.log(666666)\n\t\t}\n\t}\n}</code></pre>\n<p><strong>com/Footer1.js</strong></p>\n<pre><code class=\"language-javascript\">export default {\n\ttemplate:`&lt;div&gt;footer&lt;/div&gt;`,\n\tmounted(){\n\t\tconsole.log(\"Footer1挂载到页面时就会运行\")\n\t}\n}</code></pre>\n<p></p>\n<p><strong>组件二：</strong></p>\n<p>main.js</p>\n<pre><code class=\"language-javascript\">import Vue from 'vue'\nimport App from './App.vue'\n\nnew Vue({\n  render: h =&gt; h(App),\n}).$mount('#app')\n\n</code></pre>\n<p>App.vue</p>\n<pre><code class=\"language-javascript\">&lt;template&gt;\n\t&lt;div&gt;\n\t\t&lt;Nav1/&gt;\n\t\t&lt;Nav1&gt;&lt;/Nav1&gt;\n\t\t&lt;Box1&gt;&lt;/Box1&gt;\n\t\t&lt;!-- &lt;box-div2&gt;&lt;/box-div2&gt; --&gt;\n\t\t&lt;BoxDiv2&gt;&lt;/BoxDiv2&gt;\n\t\t&lt;!-- &lt;br&gt; --&gt;\n\t\t&lt;hqyj&gt;123123&lt;/hqyj&gt;\n\t&lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\n\timport Nav1 from \"./Nav1.vue\"\n\t// import Box1 from \"./Box1.vue\"\n\t//1.@代表了src目录的意思\n\timport Box1 from \"@/Box1.vue\"\n\t//2.注册的组件名不能跟vue中的和原生DOM的重名,注册的名字是驼峰 使用时就用连字符\n\timport BoxDiv2 from \"@/com/BoxDiv2.vue\"\n\t//3.注册的组件 使用时可以用双标签也可以用单标签: 如果有插槽必须用双标签\t\n\texport default {\n\t\tcomponents: {\n\t\t\tNav1,\n\t\t\tBox1:Box1,\n\t\t\tBoxDiv2,\n\t\t\t// boxdiv2\n\t\t}\n\t}\n&lt;/script&gt;\n&lt;style&gt;\n&lt;/style&gt;\n</code></pre>\n<p></p>\n<h1 id=\"5.%E7%BB%84%E4%BB%B6%E7%9A%84%E5%B1%9E%E6%80%A7\">5.组件的属性</h1>\n<blockquote>\n<p>属性有两种写法:简单声明和详细描述:</p>\n<p>4.1.简单声明<br/> props:[\"prop1\",\"prop2\"]</p>\n<p>4.2对属性做详细的描述</p>\n</blockquote>\n<blockquote>\n<p> 属性可以多传  但是注册了的属性就必须传 不然有可能会在使用时因为取值问题出BUG</p>\n<p>属性名不要(不是不能)用vue官方或者原生标签已经签名过的名字:比如id  class  href</p>\n<p>属性的类型验证只是一种验证提示 不会阻止程序运行</p>\n</blockquote>\n<p><strong>App.vue</strong></p>\n<pre><code class=\"language-javascript\">&lt;template&gt;\n\t&lt;div&gt;\n\t\t&lt;Nav1&gt;&lt;/Nav1&gt;\n\t\t&lt;box pro=\"title\"&gt;&lt;/box&gt;\n\t\t&lt;box :pro=\"title\"&gt;&lt;/box&gt;\n\t\t&lt;Goods :title1=\"arr[0].title\" :price=\"arr[0].price\"&gt;&lt;/Goods&gt;\n\t\t&lt;Goods :title1=\"arr[1].title\" :price=\"arr[1].price\"&gt;&lt;/Goods&gt;\n\t\t&lt;Goods title1=\"水煮肉片\" price=\"12\"&gt;&lt;/Goods&gt;\n\t\t&lt;Goods2 :obj1=\"arr[0]\"&gt;&lt;/Goods2&gt;\n\t\t&lt;Goods2 v-for=\"el in arr\" :obj1=\"el\"&gt;&lt;/Goods2&gt;\n\t&lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\n\timport Nav1 from \"@/components/Nav1.vue\"\t\n\timport box from \"@/components/box.vue\"\n\timport Goods from \"@/components/Goods.vue\"\n\timport Goods2 from \"@/components/Goods2.vue\"\n\texport default {\n\t\tdata() {\n\t\t\treturn {\n\t\t\t\tmsg: \"hello\",\n\t\t\t\ttitle:\"app组件的数据\",\n\t\t\t\tarr:[{title:\"鱼香肉丝\",price:18,id:12},\n\t\t\t\t{title:\"鱼香肉丝2\",price:181,id:122},\n\t\t\t\t{title:\"鱼香肉丝3\",price:183,id:123}\n\t\t\t\t]\n\t\t\t}\n\t\t},\n\t\tcomponents:{\n\t\t\tNav1,\n\t\t\tbox,\n\t\t\tGoods,\n\t\t\tGoods2\n\t\t}\n\t}\n&lt;/script&gt;\n&lt;style&gt;\n\t\n&lt;/style&gt;</code></pre>\n<p><strong> box.vue</strong></p>\n<pre><code class=\"language-javascript\">&lt;template&gt;\n\t&lt;div&gt;\n\t\t&lt;h1&gt;{<!-- -->{boxtitle}}&lt;/h1&gt;\n\t\t&lt;!-- &lt;h2&gt;{<!-- -->{title}}&lt;/h2&gt; --&gt;\n\t\t&lt;h2&gt;{<!-- -->{pro}}&lt;/h2&gt;\n\t&lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\n\texport default {\n\t\t//注册组件的属性\n\t\tprops:[\"pro\"],\n\t\tdata() {\n\t\t\treturn {\n\t\t\t\tboxtitle: \"组件自己的数据\"\n\t\t\t}\n\t\t},\n\t\tmethods:{\n\t\t}\n\t}\n&lt;/script&gt;\n&lt;style&gt;\n&lt;/style&gt;\n</code></pre>\n<p><strong>Godds2.vue</strong></p>\n<pre><code class=\"language-javascript\">&lt;template&gt;\n\t&lt;div&gt;\n\t\t&lt;p&gt;{<!-- -->{obj1.title}}----------{<!-- -->{obj1.price}}&lt;/p&gt;\n\t&lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\n\texport default {\n\t\tprops:[\"obj1\"]\n\t}\n&lt;/script&gt;\n&lt;style&gt;\n&lt;/style&gt;\n</code></pre>\n<p></p>\n<p><strong>组件的属性的类型验证</strong></p>\n<p>如果不按照规定传，就会报警告，不会报错</p>\n<pre><code class=\"language-javascript\">props: {\n\tpropA: Number,\t\t// 基础的类型检查 (`null` 匹配任何类型)\n\tpropB: [String, Number],\t// 多个可能的类型\n\tpropC: {\ttype: String,\n     \t\t required: true\t// 必填的字符串\n   \t},\n\tpropD: {\ttype: Number,\n      \t\tdefault: 100\t// 带有默认值的数字\n    \t},\n\tpropE: {\ttype: Object,\t// 带有默认值的对象或者数组填Array\n\t\tdefault: function () {\t// 不建议直接填对象(因为对象直接量会一直占用内存),一般使用工厂函数,调用时才创建对象节省资源(面试)\n        \t\treturn { message: 'hello' }\n      \t\t}\n    \t},\n\tpropF: {\n      \t\tvalidator: function (value) {// 自定义验证函数返回为true就代表数据符合我们规定\n\t\t\treturn ['success', 'warning', 'danger'].indexOf(value) !== -1\n      \t\t}\n    \t}\n  }</code></pre>\n<p>例子：</p>\n<p><strong>App.vue</strong></p>\n<pre><code class=\"language-javascript\">&lt;template&gt;\n\t&lt;div&gt;\n\t\t&lt;Box  :title=\"msg\" :count=\"c\"&gt;&lt;/Box&gt;\n\t\t&lt;Box  :title=\"msg\" :count=\"c\" color1=\"blue\"&gt;&lt;/Box&gt;\n\t&lt;Box  :title=\"msg\" :count=\"c\" :pro1=\"pro1\"&gt;&lt;/Box&gt;\n\t&lt;Box  :title=\"msg\" :count=\"c\" :pro1=\"pro2\"&gt;&lt;/Box&gt;\n\t&lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\n\timport Box from \"@/components/Box.vue\"\n\texport default {\n\t\tdata() {\n\t\t\treturn {\n\t\t\t\tmsg:\"200\",\n\t\t\t\tc:\"hello\",\n\t\t\t\t// c:[\"hello\",100]\n\t\t\t\tpro1:\"success\",\n\t\t\t\tpro2:\"test\"\n\t\t\t}\n\t\t},\n\t   components:{\n\t\t   Box\n\t   }\n\t}\n&lt;/script&gt;\n&lt;style&gt;\n&lt;/style&gt;</code></pre>\n<p><strong>Box.vue</strong></p>\n<pre><code class=\"language-javascript\">&lt;template&gt;\n\t&lt;div&gt;\n\t\t&lt;!-- &lt;h1&gt;{<!-- -->{title.subStr(1)}}&lt;/h1&gt; --&gt;\n\t\t&lt;h1&gt;{<!-- -->{title}}&lt;/h1&gt;\n\t\t&lt;p&gt;{<!-- -->{count}}&lt;/p&gt;\n\t\t&lt;div :style=\"{color:color1}\"&gt;666&lt;/div&gt;\n\t\t&lt;p&gt;{<!-- -->{pro1}}&lt;/p&gt;\n\t&lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\n\texport default {\n\t\t//直接注册组件的属性\n\t\t// props:[\"title\"]\n\t\t//配置的方式注册组件的属性\n\t\tprops:{\n\t\t\ttitle:String,\n\t\t\tcount:[Number,String],\n\t\t\tcolor1:{\n\t\t\t\tdefault:\"red\",\n\t\t\t\ttype:String\n\t\t\t},\n\t\t\tpro1:{\n\t\t\t\tvalidator:function(v){\n\t\t\t\t\tvar arr=[\"success\",\"danger\",\"info\",\"parimary\"]\n\t\t\t\t\treturn arr.includes(v)\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tdata() {\n\t\t\treturn {\n\t\t\t\t\n\t\t\t}\n\t\t},\n\t}\n&lt;/script&gt;\n&lt;style&gt;\n&lt;/style&gt;\n</code></pre>\n<p></p>\n<h1 id=\"6.v-slot%3A%20%E6%8F%92%E6%A7%BD\">6.v-slot: 插槽</h1>\n<blockquote>\n<p><strong>具名插槽 slot,slot-scope过时了 2.6.0使用v-slot</strong><br/> 语法:v-slot:插槽名   语法糖:#插槽名<br/><strong>没有指定插槽名就是默认插入到插槽,不给插槽插入数据的话,就会使用组件的slot中的数据</strong><br/> 插槽名不用使用引号引起来,直接写变量名<br/><strong>插入的内容必须是template标签或者组件 不能是原生的元素</strong></p>\n<p></p>\n<p>一般用在UI项目框架中</p>\n</blockquote>\n<blockquote>\n<p> 插槽的传值技术==&gt;数据共享，共用</p>\n</blockquote>\n<blockquote>\n<p><strong>  设计组件里面:(Box.vue)</strong></p>\n<p>    默认槽位:&lt; slot&gt; &lt; /slot&gt;</p>\n<p>    具名槽位:&lt; slot name=\"s1\"&gt; &lt; /slot&gt;  &lt; slot name=\"s2\"&gt; &lt; /slot&gt;</p>\n<p></p>\n<p><strong>  使用组件时: （APP.vue）</strong></p>\n<p>     &lt; 组件名&gt; 尖括号中的东西插入默认槽位 &lt; /组件名&gt;</p>\n<p>     &lt; 组件名&gt;</p>\n<p>             &lt; template v-slot:s2&gt;插入东西必须放这个标签中,老版本不用&lt; template&gt;</p>\n<p>             &lt; template #s1&gt;插入东西必须放这个标签中,老版本不用&lt; template&gt;</p>\n<p>    &lt; /组件名&gt;</p>\n</blockquote>\n<pre><code class=\"language-html\">//设计组件: .vue组件文件中\n&lt;template&gt;\n&lt;!-- 页面的顺序由下面slot的顺序决定--&gt;\n&lt;div class=\"content1\"&gt;\n    &lt;slot&gt;&lt;/slot&gt;\n&lt;!-- 默认插槽，没有指定名字--&gt;\n    &lt;slot name=\"slot1\"&gt;&lt;/slot&gt;\n    &lt;h1&gt;{<!-- -->{contentData.title}}&lt;/h1&gt;\n    &lt;h2&gt;{<!-- -->{contentData.dt}}&lt;/h2&gt;\n    &lt;slot name=\"slot3\"&gt;你不给我数据到3号插槽中  我就会默认显示出来&lt;/slot&gt;\n    &lt;p&gt;{<!-- -->{contentData.text}}&lt;/p&gt;\n    &lt;slot name=\"slot2\"&gt;&lt;/slot&gt;\n&lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nexport default{\n    props:{\n        contentData:{\n            type:Object,\n            default:()=&gt;{return {title:\"0\",dt:\"0\",text:\"0\"}}\n        }\n    }\n}\n&lt;/script&gt;\n//使用组件: .vue页面文件中\n&lt;template&gt;\n&lt;div&gt;  \n  &lt;content2 :contentData=\"arr[1]\"&gt;\n        &lt;template #slot1&gt;\n            &lt;img src=\"../assets/28.jpg\"&gt;\n        &lt;/template&gt;\n    \n        &lt;template #slot2&gt;  //写法1\n            &lt;p&gt;我在外部插入插槽的数据,不是子组件中的数据,也不是属性传进去的数据&lt;/p&gt;\n        &lt;/template&gt;\n        \n        &lt;template v-slot:slot3&gt;   //写法2\n            666\n        &lt;/template&gt;         \n        &lt;p&gt;我并没有指定插入到哪里&lt;/p&gt;\n  &lt;/content2&gt;\n&lt;/div&gt;  \n&lt;/template&gt;</code></pre>\n<p>APP.vue</p>\n<pre><code class=\"language-javascript\">&lt;template&gt;\n  &lt;div class=\"app\"&gt;\n    &lt;Box msg=\"mymsg\" title=\"标题\"&gt;\n      &lt;b&gt;插槽的槽位&lt;/b&gt;\n    &lt;/Box&gt;\n    &lt;Box msg=\"mymsg\" title=\"标题\"&gt; 666 &lt;/Box&gt;\n    &lt;Box&gt;\n      &lt;b&gt;默认插槽的槽位&lt;/b&gt;\n      &lt;template v-slot:s1&gt;\n        &lt;b&gt;具名插槽的槽位&lt;/b&gt;\n      &lt;/template&gt;\n    &lt;/Box&gt;\n    &lt;Box&gt;\n      &lt;b&gt;默认插槽的槽位&lt;/b&gt;\n      &lt;template #s1&gt;\n        &lt;b&gt;2222&lt;/b&gt;\n      &lt;/template&gt;\n    &lt;/Box&gt;\n    &lt;!-- 这种写法 并非嵌套 也不是父子组件关系 --&gt;\n    &lt;Box&gt;\n      &lt;b&gt;默认插槽的槽位&lt;/b&gt;\n      &lt;Box2&gt; &lt;/Box2&gt;\n      &lt;template #s1&gt;\n        &lt;b&gt;2222&lt;/b&gt;\n      &lt;/template&gt;\n    &lt;/Box&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nimport Box from \"@/components/Box.vue\";\nimport Box2 from \"@/components/Box2.vue\";\n\nexport default {\n  data() {\n    return {};\n  },\n  components: {\n    Box,\n    Box2,\n  },\n};\n&lt;/script&gt;\n&lt;style&gt;\n.app {\n  width: 100%;\n  min-height: 300px;\n  background-color: honeydew;\n  padding: 0px;\n  border: 1px honeydew solid;\n}\n&lt;/style&gt;\n</code></pre>\n<p>Box.vue</p>\n<pre><code class=\"language-javascript\">&lt;template&gt;\n  &lt;div class=\"box\"&gt;\n    &lt;div class=\"s\"&gt;\n      &lt;slot&gt;&lt;/slot&gt;\n      &lt;!-- 默认槽位--&gt;\n    &lt;/div&gt;\n    &lt;h1&gt;{<!-- -->{ title }}&lt;/h1&gt;\n    &lt;div&gt;{<!-- -->{ msg }}&lt;/div&gt;\n    &lt;slot name=\"s1\"&gt;&lt;/slot&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nexport default {\n  props: [\"msg\", \"title\"],\n};\n&lt;/script&gt;\n&lt;style scoped=\"scoped\"&gt;\n.box {\n  width: 100%;\n  min-height: 100px;\n  background-color: goldenrod;\n  margin: 20px;\n}\n.s {\n  width: 60px;\n  height: 60px;\n  background-color: ghostwhite;\n}\n&lt;/style&gt;</code></pre>\n<p> Box2.vue</p>\n<pre><code class=\"language-javascript\">&lt;template&gt;\n\t&lt;i&gt;box3&lt;/i&gt;\n&lt;/template&gt;\n</code></pre>\n<p></p>\n<p></p>\n<h1 id=\"7.%E7%BB%84%E4%BB%B6%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6%E5%92%8C%E5%8E%9F%E7%94%9F%E4%BA%8B%E4%BB%B6\">7.组件的自定义事件和原生事件</h1>\n<blockquote>\n<p>事件的三要素：事件源target  事件类型type 监听器handler</p>\n<p> 在组件内部触发事件  this.$emit(\"事件名\",参数1,参数2.....)</p>\n<p> 使用组件时 绑定监听器,内部触发事件时 监听器就会调用</p>\n</blockquote>\n<pre><code class=\"language-javascript\">//1.在原生组件(就是html标签)中  事件是由系统来设计触发条件的:\n&lt;div @click=\"fn\"&gt;点我&lt;/div&gt;\n\n//2.在自定义组件中,事件是由自己来设计什么时候触发的:\n\n//绑定事件:\n&lt;mydiv @myclick=\"fn\"&gt;点我&lt;/mydiv&gt;\n\n//事件设计:\n//在mydiv组件内部,你可以在你想要的条件下去触发事件\nthis.$emit(\"myclick\",\"要给触发的事件的函数传入值\")//这个代码放在你想触发自定义事件的地方\n\n\n//3.如果希望组件绑定原生事件(事件的触发条件设计由系统设计)\n//给事件绑定事件修饰符   .native\n&lt;mydiv @click.native=\"fn\"&gt;点我&lt;/mydiv&gt;//事件名必须是系统存在的事件</code></pre>\n<p>APP.vue</p>\n<pre><code class=\"language-javascript\">&lt;template&gt;\n  &lt;div&gt;\n    &lt;button @click=\"clicked\"&gt;点击&lt;/button&gt;\n    &lt;!--原生的点击事件 --&gt;\n    &lt;Box v-on:myevent=\"fn\"&gt;&lt;/Box&gt;\n    &lt;!-- 自己设计的事件的触发条件由自己决定，比如myevent就是两种方式可以触发：count=5，或者挂载完之后 --&gt;\n    &lt;Box2 v-on:click=\"fn2\"&gt;&lt;/Box2&gt;\n    &lt;!-- 自定义事件，并不是上面的原生点击事件 --&gt;\n    &lt;Box3 v-on:click.native=\"fn3\"&gt;&lt;/Box3&gt;\n    &lt;!-- native就是让这个自定义事件变为原生事件 ，只要点击就会触发，但是不能写myevent.native,只能写官方的--&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nimport Box from \"./Box.vue\";\nimport Box2 from \"./Box2.vue\";\nimport Box3 from \"./Box3.vue\";\nexport default {\n  methods: {\n    clicked(e) {\n      //事件的三要素: 事件源 target  事件类型type  监听器handler\n      console.log(\"66666原生事件触发了\", e);\n    },\n    fn() {\n      //Box组件是事件源   myevent是Box组件绑定的事件类型   fn是Box组件上面绑定的监听器\n      // fn要 myevent触发了就会运行  myevent事件什么条件下才会触发呢?\n      //myevent由Box组件内部自己设计 什么时候触发:比如\n      console.log(\"fn66666666666\", arguments); //100，200\n    },\n    fn2() {\n      console.log(\"fn26666666666\");\n    },\n    fn3() {\n      console.log(\"fn36666666666\");\n    },\n  },\n  components: {\n    Box,\n    Box2,\n    Box3,\n  },\n};\n&lt;/script&gt;\n&lt;style scoped=\"scoped\"&gt;\n&lt;/style&gt;\n</code></pre>\n<p>Box.vue</p>\n<pre><code class=\"language-javascript\">&lt;template&gt;\n  &lt;div&gt;\n    &lt;button @click=\"add\"&gt;增加&lt;/button&gt;\n    &lt;p&gt;{<!-- -->{ count }}&lt;/p&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nexport default {\n  data() {\n    return {\n      count: 0,\n    };\n  },\n  methods: {\n    add() {\n      this.count++;\n    },\n  },\n  watch: {\n    //绑定一个监听器，当count=5的时候，自己设定的那个事件就会触发\n    count(v) {\n      if (v == 5) {\n        //触发组件内的事件\n        this.$emit(\"myevent\", 100, 200); //myevent触发的时候，就会给绑的那个事件fn传值\n      }\n    },\n  },\n  mounted() {\n    //当挂载完之后，自己设定的那个事件就会触发\n    this.$emit(\"myevent\");\n  },\n};\n&lt;/script&gt;\n&lt;style&gt;\n&lt;/style&gt;\n</code></pre>\n<p> Box2.vue</p>\n<pre><code class=\"language-javascript\">&lt;template&gt;\n\t&lt;div&gt;\n\t\t&lt;button @click=\"x\"&gt;box2&lt;/button&gt;\n\t&lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\n\texport default {\n\t\tmethods:{\n\t\t\tx(){\n\t\t\t\tthis.$emit(\"click\")\n\t\t\t}\n\t\t}\n\t}\n&lt;/script&gt;\n&lt;style&gt;\n&lt;/style&gt;\n</code></pre>\n<p> Box3.vue</p>\n<pre><code class=\"language-javascript\">&lt;template&gt;\n  &lt;div&gt;\n    &lt;button&gt;box3&lt;/button&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nexport default {};\n&lt;/script&gt;\n&lt;style&gt;\n&lt;/style&gt;\n</code></pre>\n<h1></h1>\n<h1 id=\"7.css%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F\">8.css的作用域</h1>\n<blockquote>\n<p>局部样式/CSS作用域的实现和原理</p>\n<p>在style标签中添加一个scoped</p>\n<p>原理就是vue的插件webpack打包时会:</p>\n<p>把当前组件模板中的每一个元素添加一个相同的哈希值命名的属性名</p>\n<p>并且为添加了scoped的style中的样式选择器上添加一个属性选择器</p>\n<p></p>\n<p> scoped:  style标签的<strong>scoped=\"scoped\"</strong> 生成css的使用作用域只有当前组件内部的选择器生效</p>\n<p>vue文件中可以出现多个style标签  凡是添加了scoped属性的,里面的选择器就会被修改  没添加scoped属性的就不会被修改</p>\n</blockquote>\n<p>app.vue</p>\n<pre><code class=\"language-javascript\">&lt;template&gt;\n\t&lt;div&gt;\n\t\t&lt;h1 class=\"apptitle\"&gt;app组件&lt;/h1&gt;\n\t\t&lt;Box1&gt;&lt;/Box1&gt;\n\t\t&lt;Box2&gt;&lt;/Box2&gt;\n\t&lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\n//谁先引入，谁先打包，那么后面引入的样式就会显示\n\timport Box2 from \"@/components/Box2.vue\"\n\timport Box1 from \"@/components/Box1.vue\"\n\texport default {\n\t\tcomponents: {\n\t\t\tBox1,\n\t\t\tBox2\t\t\t\n\t\t}\n\t}\n&lt;/script&gt;\n&lt;style&gt;\n\t.apptitle{\n\t\tcolor: red;\n\t}\n&lt;/style&gt;\n</code></pre>\n<p>main.js</p>\n<pre><code class=\"language-javascript\">import Vue from 'vue'\nimport \"./index.css\"\nimport App from './App.vue'\nnew Vue({\n  render: h =&gt; h(App),\n}).$mount('#app')\n</code></pre>\n<p> Box1.vue</p>\n<pre><code class=\"language-javascript\">&lt;template&gt;\n\t&lt;div&gt;\n\t\t&lt;h1 class=\"title\"&gt;box1页面&lt;/h1&gt;\n\t&lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\n\texport default {\n\t}\n&lt;/script&gt;\n&lt;style scoped=\"scoped\"&gt;\n\t.title{\n\t\tcolor: yellow;\n\t}\n&lt;/style&gt;\n</code></pre>\n<p></p>\n<h1 id=\"7.%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E7%BB%84%E4%BB%B6%E5%9F%BA%E7%A1%80%EF%BC%89\">9.面试题（组件基础）</h1>\n<p>组件中的基础语法常见的面试题方向:</p>\n<blockquote>\n<h2 id=\"1%20%40%20%E6%98%AF%E4%B8%80%E4%B8%AA%E5%85%B3%E9%94%AE%E5%AD%97%2C%E5%9C%A8%E5%BC%95%E5%85%A5%E7%9A%84%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E4%B8%AD%20%E5%AE%83%E4%BB%A3%E8%A1%A8src%E7%9B%AE%E5%BD%95\">1 @ 是一个关键字,在引入的文件路径中 它代表src目录</h2>\n</blockquote>\n<blockquote>\n<h2 id=\"2%20template%3A%E7%BB%84%E4%BB%B6%E7%9A%84%E6%A8%A1%E6%9D%BF%E4%B8%AD%E5%8F%AA%E8%83%BD%E6%9C%89%E4%B8%80%E4%B8%AA%E6%A0%B9%E8%8A%82%E7%82%B9\">2 template:组件的模板中只能有一个根节点</h2>\n</blockquote>\n<blockquote>\n<h2 id=\"3%20v-slot%3A%20%E6%8F%92%E6%A7%BD%2C%20%E5%85%B7%E5%90%8D%E6%8F%92%E6%A7%BD%20slot%2Cslot-scope%E8%BF%87%E6%97%B6%E4%BA%86%202.6.0%E4%BD%BF%E7%94%A8v-slot\">3 v-slot: 插槽, 具名插槽 slot,slot-scope过时了 2.6.0使用v-slot</h2>\n<p>语法:v-slot:插槽名   语法糖:#插槽名<br/> 没有指定插槽名就是默认插入到插槽,不给插槽插入数据的话,就会使用组件的slot标签的尖括号中的数据<br/> 插槽名不用使用引号引起来,直接写变量名<br/> 插入的内容必须是template标签或者组件 不能是原生的元素</p>\n</blockquote>\n<blockquote>\n<h2 id=\"4%20%E7%BB%84%E4%BB%B6%E7%9A%84data%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%AA%E5%87%BD%E6%95%B0%E7%84%B6%E5%90%8E%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%2C%E4%BB%A5%E5%89%8D%E4%BD%BF%E7%94%A8vm%E6%97%B6%E9%83%BD%E6%98%AF%E4%B8%AA%E5%AF%B9%E8%B1%A1\">4 组件的data为什么是个函数然后返回对象,以前使用vm时都是个对象</h2>\n<p>（组件是vue核心，组件最大的特点就是:复用）</p>\n<p>数据源必须写成函数的形式，如果是对象的形式的话，那就是共用一个对象，就可以把数据源修改了。只有一个的数据源可以不是函数，就是跟组件（new Vue）,因为它不会被复用</p>\n<p></p>\n<p>组件和挂载到界面的vm对象的区别，vm挂载到页面上时，触发了钩子函数的，data生成了，页面上使用的数据就是data容器中渲染上去的，而且页面只有一个vm对象，所以的vm生成完毕(mouted)时data必须存在</p>\n<p></p>\n<p>组件是引入和注册以后不一定使用的，比如for循环0次就是组件对象生成了的，但是使用0次，所以组件对象并没有使用自己的data容器去渲染数据，造成资源浪费，解决方案就是懒加载：当使用data时去调用，才生成data对象</p>\n<p></p>\n<p>组件的data 设计成function的用义:组件可以多次使用,每使用一次,函数被调用一次则创建出不同的数据对象,实现同名组件的数据可以相互独立</p>\n<p></p>\n<p><strong>组件中的data是函数的设计是因为：</strong></p>\n<p>1、组件被复用时，data数据源才不会共用</p>\n<p>2、函数的设计就像懒加载一样，当使用组件时，数据源的对象才会创建，这样设计性能更好</p>\n</blockquote>\n<blockquote>\n<h2 id=\"5%20scoped%3A%20%C2%A0style%E6%A0%87%E7%AD%BE%E7%9A%84scoped%3D%22scoped%22%20%E7%94%9F%E6%88%90css%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%8F%AA%E6%9C%89%E5%BD%93%E5%89%8D%E7%BB%84%E4%BB%B6%E5%86%85%E9%83%A8%E7%9A%84%E9%80%89%E6%8B%A9%E5%99%A8%E7%94%9F%E6%95%88\">5 scoped:  style标签的scoped=\"scoped\" 生成css的使用作用域只有当前组件内部的选择器生效</h2>\n</blockquote>\n<blockquote>\n<h2 id=\"6%20%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81%E7%9A%84%E9%A1%BA%E5%BA%8F\">6 数据劫持的顺序</h2>\n<p>本题是实际测试，答案背下一题的</p>\n<p></p>\n<p>this组件对象有很多属性和方法，都是劫持的“别人”的，比如data methods props，所以就有顺序，优先级的问题，写项目的时候要注意</p>\n<p></p>\n<p>this在构建时，给this设置成员的时间顺序：<strong>data&gt;props属性&gt;方法&gt;计算属性&gt;事件中给this添加的</strong> （后劫持就会在页面中显示）</p>\n<p>==&gt;使用时的优先级：<strong>data&lt;props属性&lt;方法&lt;计算属性&gt;&lt;事件中给this添加的</strong> </p>\n<p></p>\n<p><strong><span style=\"color:#24292e;\">初始化顺序为 computed,methods,data,props  ==&gt;  </span></strong>实际并非如此 猜测是脚手架的导致的打包顺序还有vue的版本导致的劫持顺序不一样</p>\n<p></p>\n<p><span style=\"color:#24292e;\">如果eslint 配置比较严格的话，同名是编译不通过的。</span></p>\n</blockquote>\n<p></p>\n<blockquote>\n<h2 id=\"7%C2%A0%E5%9C%A8%E4%BD%BF%E7%94%A8%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%87%BD%E6%95%B0%E5%90%8D%E5%92%8C%20data%20%E6%95%B0%E6%8D%AE%E6%BA%90%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8F%AF%E4%BB%A5%20%E5%90%8C%E5%90%8D%E5%90%97%EF%BC%9F\">7 <strong>在使用计算属性的时候，函数名和 </strong><span style=\"color:#000000;\"><strong>data </strong></span><span style=\"color:#000000;\"><strong>数据源中的数据可以 </strong></span><span style=\"color:#000000;\"><strong>同名吗？</strong></span></h2>\n<div>\n<span style=\"color:#24292e;\">可以同名，但 data 会覆盖 methods。并且本就不该同名，同名说明你命名不规范。 </span>\n</div>\n<div></div>\n<div>\n<span style=\"color:#24292e;\">覆盖的原因是 Props、methods、data、computed、watch 都是在 initState 函数中被初始 </span>\n</div>\n<div>\n<span style=\"color:#24292e;\">化的。</span>\n</div>\n<div>\n<span style=\"color:#956fe7;\"><strong>初始化顺序为 computed,methods,data,props （CMDP）</strong></span>\n</div>\n<div>\n<span style=\"color:#24292e;\">本质上这些都是要挂载到 this 上面 的，你如果重名的话，后面出现的属性自然而然会覆盖之前挂载的属性了。</span>\n</div>\n<div></div>\n</blockquote>\n<p></p>\n<pre><code class=\"language-javascript\"> Vue.prototype._init = function (options?: Object) {\n   initLifecycle(vm) //1.初始化生命周期的函数\n   initEvents(vm) //初始化事件\n   initRender(vm)//生成vnode的模板\n   callHook(vm, 'beforeCreate')//触发beforeCreate钩子\n   initInjections(vm) //接受提供者提供的数据\n   initState(vm)//初始化状态:具体过程在下面函数中\n   initProvide(vm) //给别人提供数据\n   callHook(vm, 'created')//触发created钩子\n }\n \n export function initState (vm: Component) {\n   vm._watchers = []\n   const opts = vm.$options\n   if (opts.props) initProps(vm, opts.props) //有属性就初始化属性\n   if (opts.methods) initMethods(vm, opts.methods)//有方法就初始化方法\n   if (opts.data) {//有数据源就初始化数据源\n     initData(vm)\n   } else {\n     observe(vm._data = {}, true /* asRootData */)//没有就监听自带的数据源\n   }\n   if (opts.computed) initComputed(vm, opts.computed)//有计算属性就初始化计算属性\n   if (opts.watch &amp;&amp; opts.watch !== nativeWatch) {\n     initWatch(vm, opts.watch)//对属性监听\n   }\n }\n //源码分析的结果:属性props&gt;方法methods&gt;数据源data&gt;计算属性computed&gt;对属性监听watch</code></pre>\n<h1></h1>\n<h1></h1>\n<blockquote>\n<h2 id=\"8%E3%80%81%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84%E9%A1%B9%E7%9B%AE\"><strong>8、怎么跑起来的项目</strong></h2>\n<p>1、npm run dev   源代码 .vue文       webpack:vue集成的环境</p>\n<p></p>\n<p>2、vue文件，编程了一个对象，把模板解析了，sass，scoped等等</p>\n<p></p>\n<p>3、静态项目：html,css,js        （8080托管）</p>\n<p></p>\n<p>==&gt;用户浏览器 访问</p>\n<p>render先执行，再去挂载$mount('#app')</p>\n</blockquote>\n<p></p>\n<blockquote>\n<h2 id=\"9%E3%80%81%E5%A6%82%E6%9E%9Cel%E5%92%8C%24mount%E9%83%BD%E5%86%99%E4%BA%86%EF%BC%8C%E4%BC%9A%E4%B8%8D%E4%BC%9A%E5%86%B2%E7%AA%81\">9、如果el和$mount都写了，会不会冲突</h2>\n<p>不会，而且$mount的优先级更高</p>\n</blockquote>\n<p></p>\n<blockquote>\n<h2 id=\"10%E3%80%81Vue%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%EF%BC%9A\">10、Vue加载流程：</h2>\n<p>1)每一个组件在加载时，都会调用vue内部的render函数来把这个组件的template选项的模板解析为一个JS对象</p>\n<p>这个对象跟DOM节点对象“长得一摸一样”，就是为了后来的渲染</p>\n<p></p>\n<p>2.然后是数据劫持代理监听等等</p>\n<p>底层有一种设计：发布/订阅设计  其实就是泄漏一个watcher函数去订阅（监听），数据的改变（底层JS语法就是defInedproty，v3是proxy）</p>\n<p>当数据发生变化以后：</p>\n<p>当状态（数据）变更的时候，重新构造一棵树的对象树。然后用新的树和旧的树进行比较（diff），记录两棵树差异，把第二课树所记录的差异应用到第一颗树所构建的真正的DOM树上（patch），视图就更新了</p>\n<p>旧VNode树=&gt;树VNode树=&gt;刷新页面==&gt;错误想法</p>\n<p>旧VNode树 和 生成的新VNode树 比较差异，然后更新DOM（刷新页面）==&gt;正确思想，实现这个过程的代码就是DIFF算法</p>\n<p>比较的过程是：一层一层的的比较，父组件和父组件，并不会把父组件跟子组件比较，同层级时，从两边到中间</p>\n<p>比较的过程中，发现差异（组件/标签类型，文本，属性值，注释等等），就会异步去给DOM打补丁（操作页面）</p>\n</blockquote>\n<p></p>\n<blockquote>\n<h2 id=\"11%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFDIFF\">11、什么是DIFF</h2>\n<p>用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文 档当中</p>\n<p>当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较(diff)，记录两棵树差异</p>\n<p>把第二棵树所记录的差异应用到第一棵树所构建的真正的DOM树上(patch)，视图就更新了</p>\n</blockquote>\n<p></p>\n<blockquote>\n<h2 id=\"12%E3%80%81DIFF%E7%AE%97%E6%B3%95%E7%9A%84%E8%BF%87%E7%A8%8B%20%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89\">12、DIFF算法的过程 （了解）</h2>\n<p>当数据发生改变时，订阅者watcher就会调用patch给真实的DOM打补丁</p>\n<p>通过sameVnode进行判断，相同则调用patchVnode方法</p>\n<p>patchVnode做了以下操作：</p>\n<p>找到对应的真实dom，称为el</p>\n<p>如果都有都有文本节点且不相等，将el文本节点设置为Vnode的文本节点</p>\n<p>如果oldVnode有子节点而VNode没有，则删除el子节点</p>\n<p>如果oldVnode没有子节点而VNode有，则将VNode的子节点真实化后添加到el</p>\n<p>如果两者都有子节点，则执行updateChildren函数比较子节点</p>\n<p>updateChildren主要做了以下操作：</p>\n<p>设置新旧VNode的头尾指针</p>\n<p>新旧头尾指针进行比较，循环向中间靠拢，根据情况调用patchVnode进行patch重复流程、调用createElem创建一个新节点，从哈希表寻找 key一致的VNode 节点再分情况操作</p>\n</blockquote>\n<blockquote>\n<h2 id=\"13%E3%80%81%E4%B8%8B%E5%88%97%E5%AF%B9%20Vue%20%E5%8E%9F%E7%90%86%E7%9A%84%E5%8F%99%E8%BF%B0%EF%BC%8C%E5%93%AA%E4%BA%9B%E6%98%AF%E6%AD%A3%E7%A1%AE%E7%9A%84%EF%BC%9F\">13、下列对 Vue 原理的叙述，哪些是正确的？</h2>\n<p>A. Vue 中的数组变更通知，通过拦截数组操作方法而实现<br/> B. 编译器目标是创建渲染函数，渲染函数执行后将得到 VNode 树<br/> C. 组件内 data 发生变化时会通知其对应 watcher，执行异步更新<br/> D. patching 算法首先进行同层级比较，可能执行的操作是节点的增加、删除和更新</p>\n<p>选ABCD</p>\n</blockquote>\n<blockquote>\n<h2 id=\"14%E3%80%81%E5%AF%B9%E4%BA%8E%20Vue%20%E4%B8%AD%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%8E%9F%E7%90%86%E7%9A%84%E8%AF%B4%E6%B3%95%EF%BC%8C%E4%B8%8B%E5%88%97%E5%93%AA%E9%A1%B9%E6%98%AF%E4%B8%8D%E6%AD%A3%E7%A1%AE%E7%9A%84%EF%BC%9F\">14、对于 Vue 中响应式数据原理的说法，下列哪项是不正确的？</h2>\n<p>A. 采用数据劫持方式，即 Object.defineProperty() 劫持 data 中各属性，实现响应式数据<br/> B. 视图中的变化会通过 watcher 更新 data 中的数据<br/> C. 若 data 中某属性多次发生变化，watcher 仅会进入更新队列一次<br/> D. 通过编译过程进行依赖收集</p>\n<p>选BD</p>\n</blockquote>\n<blockquote>\n<h2 id=\"%C2%A015%E3%80%81%C2%A0%E4%B8%8B%E5%88%97%E8%AF%B4%E6%B3%95%E4%B8%8D%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%98%AF%E5%93%AA%E9%A1%B9%EF%BC%9F\"> 15、 下列说法不正确的是哪项？</h2>\n<p>A. key 的作用主要是为了高效地更新虚拟 DOM<br/> B. 若指定了组件的 template 选项，render 函数不会执行<br/> C. 使用 vm.$nextTick 可以确保获得 DOM 异步更新的结果<br/> D. 若没有 el 选项，vm.$mount(dom) 可将 Vue 实例挂载于指定元素上</p>\n<p>选B</p>\n</blockquote>\n<blockquote>\n<h2 id=\"16%E3%80%81%E9%9D%A2%E8%AF%95%E8%80%83%E7%82%B9\">16、面试考点</h2>\n<p>1、编译器的目的是为了调用render函数，返回VNode节点树</p>\n<p>2、patch函数运行期间，是边比较边异步操作DOM</p>\n<p>3、差异比较的顺序是 同层比较完毕，才会比较下层</p>\n<p>4、同层差异比较是从两端到中间（具体的指针替换过程，自行查阅）</p>\n<p>5、sameNode函数比较了哪些 ：唯一key、元素名tag、数据data、注释isComment</p>\n<p><img alt=\"\" height=\"606\" src=\"image\\9c9d0c6db1c34b2886e153b4126caf24.png\" width=\"946\"/></p>\n<p></p>\n</blockquote>\n</div>\n</div>"}