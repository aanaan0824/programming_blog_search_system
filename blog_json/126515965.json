{"blogid": "126515965", "writerAge": "码龄2年", "writerBlogNum": "443", "writerCollect": "8399", "writerComment": "340", "writerFan": "955", "writerGrade": "7级", "writerIntegral": "11455", "writerName": "woshicver", "writerProfileAdress": "writer_image\\profile_126515965.jpg", "writerRankTotal": "1120", "writerRankWeekly": "暂无排名", "writerThumb": "1202", "writerVisitNum": "1092964", "blog_read_count": "3583", "blog_time": "于 2022-08-24 21:16:23 发布", "blog_title": "使用 Python为你的在线会议创建一个假的摄像头", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<div id=\"js_content\">\n<p>想象一下。你正在参加在线会议，出于某种原因，你并不想打开摄像头。但是如果你看到其他人都打开了，你觉得你也得打开，所以迅速整理自己的头发，确保衣着整洁，然后不情愿地打开相机。我们都经历过这种情况。</p>\n<p>有一个好消息。在 Python 的帮助下，不再强制开启摄像头。将向你展示如何为你的在线会议创建一个假的摄像头，如下所示：</p>\n<img alt=\"a2ee4065ea9b705d08e66ec59ccec36e.gif\" src=\"https://img-blog.csdnimg.cn/img_convert/a2ee4065ea9b705d08e66ec59ccec36e.gif\"/>\n<img alt=\"d82f44ce06650e6dbc7ec36e1d324c2e.gif\" src=\"https://img-blog.csdnimg.cn/img_convert/d82f44ce06650e6dbc7ec36e1d324c2e.gif\"/>\n<img alt=\"aadc4345edf8cb12b0c7c494aa571a2a.gif\" src=\"https://img-blog.csdnimg.cn/img_convert/aadc4345edf8cb12b0c7c494aa571a2a.gif\"/>\n<p>当然，这张脸不一定是比尔盖茨的，它也可以是你自己。</p>\n<p>现在将向你展示如何在 Python 中编写代码。在文章的最后，将解释如何为自己使用这个假的摄像头。</p>\n<h3>创建一个简单的假网络摄像头</h3>\n<p>首先，我们将导入一些模块，尤其是 openCV。</p>\n<pre class=\"has\"><code class=\"language-go\">import cv2\nimport numpy as np\nimport pickle\nimport pyaudio\nimport struct\nimport math\nimport argparse\nimport os</code></pre>\n<p>接下来我们将创建一个函数来从视频中提取所有帧：</p>\n<pre class=\"has\"><code class=\"language-go\">def read_frames(file, video_folder):\n    frames = []\n    cap = cv2.VideoCapture(os.path.join('videos', video_folder, file))\n    frame_rate = cap.get(cv2.CAP_PROP_FPS)\n    if not cap.isOpened():\n        print(\"Error opening video file\")\n    while cap.isOpened():\n        ret, frame = cap.read()\n        if ret:\n            frames.append(frame)\n        else:\n            break\n    cap.release()\n    return frames, frame_rate</code></pre>\n<p>现在我们有了框架，我们可以创建一个循环，一个接一个地显示它们。当到达最后一帧时，我们向后播放视频，然后当我们到达第一帧时，我们将向前播放，我们将永远重复这个过程。这样就不会出现从最后一帧到第一帧的突然过渡。我们也会这样做，以便我们可以按“q”停止网络摄像头。</p>\n<pre class=\"has\"><code class=\"language-go\">frames, frame_rate = read_frames('normal.mov', 'bill_gates')\n\ndef next_frame_index(i, reverse):\n    if i == len(frames) - 1:\n        reverse = True\n    if i == 0:\n        reverse = False\n    if not reverse:\n        i += 1\n    else:\n        i -= 1\n    return i, reverse\n\n\nrev = False\ni = 0\nwhile True:\n    frame = frames[i]\n    cv2.imshow('Webcam', frame)\n    pressed_key = cv2.waitKey(int(1000/frame_rate)) &amp; 0xFF\n    if pressed_key == ord(\"q\"):\n        break\n    i, rev = next_frame_index(i, mode, rev)</code></pre>\n<p style=\"text-align:left;\">有了这个，我们就有了一个可以无缝播放的简单网络摄像头。</p>\n<img alt=\"ae7978558760649526c6215382cb0ae3.gif\" src=\"https://img-blog.csdnimg.cn/img_convert/ae7978558760649526c6215382cb0ae3.gif\"/>\n<p>但我们并不止步于此。</p>\n<p>添加不同的模式</p>\n<p>如果我们的假网络摄像头头像可以做的不仅仅是被动地凝视，那将更有说服力。例如，有时在开会时，你需要点头表示同意、微笑、交谈或做其他事情。</p>\n<p>所以我们希望我们的网络摄像头有多种“模式”，我们可以随时通过按下键盘上的一个键来切换。</p>\n<p>为此，你需要为每种模式录制一个简短的录音，例如你只是微笑的录音。然后我们可以从每个视频中读取帧，并将它们存储在字典中。当我们检测到按键（例如，“s”切换到“微笑模式”）时，我们将活动模式更改为新模式并开始播放相应视频中的帧。</p>\n<pre class=\"has\"><code class=\"language-go\">video_files = [file for file in os.listdir(os.path.join('videos', folder))\n               if file not in ['transitions_dict.p', '.DS_Store']]\nframes, frame_rates = {}, {}\n\nfor file in video_files:\n    mode_name = file.split('.')[0]\n    frames[mode_name], frame_rates[mode_name] = read_frames(file, folder)\nmodes = list(frames.keys())\ncommands = {mode[0]: mode for mode in modes if mode != 'normal'}\n\nmode = \"normal\"\nframe_rate = frame_rates[mode]\nrev = False\ni = 0\nwhile True:\n    frame = frames[mode][i]\n    cv2.imshow('Webcam', frame)\n    pressed_key = cv2.waitKey(int(1000/frame_rate)) &amp; 0xFF\n    if pressed_key == ord(\"q\"):\n        break\n    for command, new_mode in commands.items():\n        if pressed_key == ord(command):\n            i, mode, frame_rate = change_mode(mode, new_mode, i)\n    i, rev = next_frame_index(i, mode, rev)</code></pre>\n<p>默认情况下，这样做是为了切换到指定模式，键盘命令是模式名称的第一个字母。现在我把这个'change_mode'函数作为一个黑盒子，稍后会解释它。</p>\n<img alt=\"3fa04038727ab0d08e2acaca7b718c0a.gif\" src=\"https://img-blog.csdnimg.cn/img_convert/3fa04038727ab0d08e2acaca7b718c0a.gif\"/>\n<h3>优化过渡</h3>\n<p>所以我们想从一个视频切换到另一个，比如说从正常模式到点头模式。如何以最佳方式从一个模式过渡到另一个模式（即过渡尽可能平滑）？</p>\n<p>当我们进行过渡时，我们希望转到与我们当前所处的最相似的新模式的框架。</p>\n<p>为此，我们可以首先定义图像之间的距离度量。这里使用一个简单的欧几里得距离，它查看两个图像的每个像素之间的差异。</p>\n<p>有了这个距离，我们现在可以找到最接近我们当前的图像，并切换到这个。例如，如果我们想从普通模式过渡到点头模式，并且我们在普通视频的第 132 帧，我们将知道我们必须转到点头视频的第 86 帧才能获得最平滑的过渡。</p>\n<p>我们可以为每一帧以及从每种模式到所有其他模式预先计算所有这些最佳转换。这样我们就不必在每次想要切换模式时都重新计算。还压缩了图像，以便计算执行时间更短。我们还将存储图像之间的最佳距离。</p>\n<pre class=\"has\"><code class=\"language-go\">video_files = [file for file in os.listdir(os.path.join('videos', video_folder))\n                       if file not in ['transitions_dict.p', '.DS_Store']]\nframes = {}\nfor file in video_files:\n    mode_name = file.split('.')[0]\n    frames[mode_name] = read_frames(file, video_folder)\nmodes = list(frames.keys())\n\ncompression_ratio = 10\nheight, width = frames[\"normal\"][0].shape[:2]\nnew_height, new_width = height // compression_ratio, width // compression_ratio, \n\ndef compress_img(img):\n    return cv2.resize(img.mean(axis=2), (new_width, new_height))\n\n  \nframes_compressed = {mode: np.array([compress_img(img) for img in frames[mode]]) for mode in modes}\n\ntransitions_dict = {mode:{} for mode in modes}\n\nfor i in range(len(modes)):\n    for j in tqdm(range(i+1, len(modes))):\n        mode_1, mode_2 = modes[i], modes[j]\n        diff = np.expand_dims(frames_compressed[mode_1], axis=0) - np.expand_dims(frames_compressed[mode_2], axis=1)\n        dists = np.linalg.norm(diff, axis=(2, 3))\n        transitions_dict[mode_1][mode_2] = (dists.argmin(axis=0), dists.min(axis=0))\n        transitions_dict[mode_2][mode_1] = (dists.argmin(axis=1), dists.min(axis=1))\n\npickle.dump(transitions_dict, open(os.path.join('videos', video_folder, 'transitions_dict.p'), 'wb'))</code></pre>\n<p>现在可以展示“change_mode”函数，该函数从预先计算的字典中检索要转换到的最佳帧。这样做是为了如果你按下例如“s”切换到微笑模式，再次按下它将切换回正常模式。</p>\n<pre class=\"has\"><code class=\"language-go\">def change_mode(current_mode, toggled_mode, i):\n    if current_mode == toggled_mode:\n        toggled_mode = 'normal'\n\n    new_i = transitions_dict[current_mode][toggled_mode][0][i]\n    dist = transitions_dict[current_mode][toggled_mode][1][i]\n    \n    return new_i, toggled_mode, frame_rates[toggled_mode]</code></pre>\n<p>我们还可以添加另一项改进使我们的过渡更加无缝，不是总是立即切换模式，而是等待一段时间以获得更好的过渡。例如，如果我们的头像在点头，我们可以等到头部通过中间位置才转换到正常模式。为此，我们将引入一个时间窗口（这里我将其设置为 0.5 秒），这样我们将在切换模式之前等待在此窗口内转换的最佳时间。</p>\n<pre class=\"has\"><code class=\"language-go\">switch_mode_max_delay_in_s = 0.5\n\n\ndef change_mode(current_mode, toggled_mode, i):\n    if current_mode == toggled_mode:\n        toggled_mode = 'normal'\n\n    # Wait for the optimal frame to transition within acceptable window\n    max_frames_delay = int(frame_rate * switch_mode_max_delay_in_s)\n    global rev\n    if rev:\n        frames_to_wait = max_frames_delay-1 - transitions_dict[current_mode][toggled_mode][1][max(0, i+1 - max_frames_delay):i+1].argmin()\n    else:\n        frames_to_wait = transitions_dict[current_mode][toggled_mode][1][i:i + max_frames_delay].argmin()\n    print(f'Wait {frames_to_wait} frames before transitioning')\n    for _ in range(frames_to_wait):\n        i, rev = next_frame_index(i, current_mode, rev)\n        frame = frames[mode][i]\n        cv2.imshow('Frame', frame)\n        cv2.waitKey(int(1000 / frame_rate))\n\n    new_i = transitions_dict[current_mode][toggled_mode][0][i]\n    dist = transitions_dict[current_mode][toggled_mode][1][i]\n    \n    return new_i, toggled_mode, frame_rates[toggled_mode]</code></pre>\n<p>现在我们的过渡更加顺畅。但是，它们有时可能很明显。所以另一个想法是有目的地为视频添加冻结，就像那些在不稳定连接时可能发生的冻结一样（就是如果网络不稳定视频就卡住了），并使用它们来掩盖过渡（我们将使冻结持续时间与两个图像之间的距离成比例）。我们还将添加随机冻结，这样模式就不会变得明显。所以我们添加了这些新的代码：</p>\n<pre class=\"has\"><code class=\"language-go\"># In the change_mode function:\n\n    dist = transitions_dict[current_mode][toggled_mode][1][i]\n    if freezes:\n        freeze_duration = int(transition_freeze_duration_constant * dist)\n        cv2.waitKey(freeze_duration)\n    \n    \n# In the main loop:\n\n    # Random freezes\n    if freezes:\n        if np.random.randint(frame_rate * 10) == 1:\n            nb_frames_freeze = int(np.random.uniform(0.2, 1.5) * frame_rate)\n            for _ in range(nb_frames_freeze):\n                cv2.waitKey(int(1000 / frame_rate))\n                i, rev = next_frame_index(i, mode, rev)</code></pre>\n<p>使用或不使用这些冻结保留为选项。</p>\n<p>好的，现在我们已经真正涵盖了这些过渡的基础。我们还能为网络摄像头添加什么？</p>\n<h3>语音检测</h3>\n<p>另一件有趣的事情是添加语音检测，这样当我们说话时，视频里的“我”就会说话。</p>\n<p>这是使用 pyaudio 完成的。感谢这个 stackoverflow 线程(https://stackoverflow.com/questions/4160175/detect-tap-with-pyaudio-from-live-mic)。</p>\n<p>基本上，这个想法是查看一段时间内来自麦克风的声音的平均幅度，如果它足够高，可以认为我们一直在说话。最初这段代码是为了检测敲击噪音，但它也可以很好地检测语音。</p>\n<pre class=\"has\"><code class=\"language-go\">AMPLITUDE_THRESHOLD = 0.010\nFORMAT = pyaudio.paInt16\nSHORT_NORMALIZE = (1.0/32768.0)\nCHANNELS = 1\nRATE = 44100\nINPUT_BLOCK_TIME = 0.025\nINPUT_FRAMES_PER_BLOCK = int(RATE*INPUT_BLOCK_TIME)\n\n\ndef get_rms(block):\n    count = len(block)/2\n    format = \"%dh\" % count\n    shorts = struct.unpack(format, block)\n\n    sum_squares = 0.0\n    for sample in shorts:\n        n = sample * SHORT_NORMALIZE\n        sum_squares += n*n\n    return math.sqrt( sum_squares / count )\n\n\npa = pyaudio.PyAudio()\n\nstream = pa.open(format=FORMAT,\n                 channels=CHANNELS,\n                 rate=RATE,\n                 input=True,\n                 frames_per_buffer=INPUT_FRAMES_PER_BLOCK)\n\n\ndef detect_voice():\n    error_count = 0\n    voice_detected = False\n    \n    try:\n        block = stream.read(INPUT_FRAMES_PER_BLOCK, exception_on_overflow=False)\n    except (IOError, e):\n        error_count += 1\n        print(\"(%d) Error recording: %s\" % (error_count, e))\n\n    amplitude = get_rms(block)\n    if amplitude &gt; AMPLITUDE_THRESHOLD:\n        voice_detected = True\n    return voice_detected</code></pre>\n<p>现在我们可以将它添加到主循环中。这样做是为了在切换回正常模式之前，我们需要在一定数量的连续帧内检测到没有声音，这样我们就不会太频繁地切换。</p>\n<pre class=\"has\"><code class=\"language-go\"># In the main loop:\n  \n  if voice_detection:\n      if detect_voice():\n          quiet_count = 0\n          if mode != \"talking\":\n              i, mode, frame_rate = change_mode(mode, \"talking\", i)\n      else:\n          if mode == \"talking\":\n              quiet_count += 1\n              if quiet_count &gt; stop_talking_threshold:\n                  quiet_count = 0\n                  i, mode, frame_rate = change_mode(mode, \"normal\", i)</code></pre>\n<p>现在，当我们通过麦克风说话时，我们可以让我们的头像开始和停止说话。我这样做是为了通过按“v”来激活或停用语音检测。</p>\n<img alt=\"c3ed523cb2d1e7b5371f82af0366d501.gif\" src=\"https://img-blog.csdnimg.cn/img_convert/c3ed523cb2d1e7b5371f82af0366d501.gif\"/>\n<p>这些都是迄今为止实现的所有功能。欢迎提出进一步改进的建议。</p>\n<h3>如何使用假网络摄像头</h3>\n<p>首先，从这里下载所有代码：https://github.com/FrancoisLeRoux1/Fake-webcam</p>\n<p>你要做的是录制一些你自己的视频（在我的 Mac 上，为此使用了 Photo Booth 应用程序），并将它们放在“视频”文件夹内的一个新文件夹中。你将能够为不同的设置创建不同的文件夹，例如，你可以在其中穿不同的衬衫，或者让你的头发看起来不同。</p>\n<p>这些视频可以而且应该很短（大约 10 秒的视频），否则如果你拍摄较长的视频，计算最佳过渡可能需要很长时间。你需要一个名为“normal”的视频，这将是你的默认模式。</p>\n<p>然后，如果你想让你的化身说话，你必须录制一个名为“talking”的视频，你说的是随机的胡言乱语。</p>\n<p>在此之后，你可以录制你想要的任何其他模式（例如，“微笑”、“点头”、“再见”……）。默认情况下，激活/停用这些模式的命令将是其名称的第一个字母（例如，对于“微笑”，请按“s”）。</p>\n<p>然后你必须计算最佳转换。为此，只需运行脚本 compute-transitions.py</p>\n<img alt=\"0c33cfffa8d57d586448600ef3e48dea.png\" src=\"image\\0c33cfffa8d57d586448600ef3e48dea.png\"/>\n<p>这应该需要几分钟。</p>\n<p>然后当你完成后，你就可以启动你的假网络摄像头了。为此，请运行 fake-webcam.py 脚本。你需要指定视频所在的“视频”内的文件夹。你还可以指定是否要使用冻结。</p>\n<img alt=\"a66e2e3806b2c488a5927de1d929c29b.png\" src=\"image\\a66e2e3806b2c488a5927de1d929c29b.png\"/>\n<img alt=\"f0e6a773239896a824f4b34beb1145c3.png\" src=\"image\\f0e6a773239896a824f4b34beb1145c3.png\"/>\n<p>所以现在你应该让你的假相机运行起来。接下来，你可以将其设置为在线会议的网络摄像头。为此，我使用了 OBS：https://obsproject.com/</p>\n<p>选择正确的 Python 窗口作为源，然后单击 Start Virtual Camera。</p>\n<img alt=\"ddb5e53707d388de9eb8726c03b272e9.png\" src=\"image\\ddb5e53707d388de9eb8726c03b272e9.png\"/>\n<p>你现在应该可以在你最喜欢的在线会议应用程序中选择此虚拟摄像头作为你的网络摄像头了！</p>\n<p><strong>☆ END ☆</strong></p>\n<p>如果看到这里，说明你喜欢这篇文章，请转发、点赞。微信搜索「uncle_pn」，欢迎添加小编微信「 woshicver」，每日朋友圈更新一篇高质量博文。</p>\n<p style=\"text-align:center;\"><strong><strong>↓</strong>扫描二维码添加小编↓</strong></p>\n<p style=\"text-align:center;\"><img alt=\"0e936fe3f8aac45f1db2aec19cc35a67.jpeg\" src=\"image\\0e936fe3f8aac45f1db2aec19cc35a67.jpeg\"/></p>\n</div>\n</div>\n</div>"}