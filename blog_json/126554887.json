{"blogid": "126554887", "writerAge": "码龄1年", "writerBlogNum": "45", "writerCollect": "67", "writerComment": "3", "writerFan": "12", "writerGrade": "3级", "writerIntegral": "468", "writerName": "No  Iverson", "writerProfileAdress": "writer_image\\profile_126554887.jpg", "writerRankTotal": "34533", "writerRankWeekly": "9093", "writerThumb": "11", "writerVisitNum": "8162", "blog_read_count": "300", "blog_time": "已于 2022-09-04 19:54:00 修改", "blog_title": "stm32、IO口、中断、串口、定时器讲解", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p><strong>目录</strong></p>\n<p style=\"margin-left:80px;\"><a href=\"#%E4%B8%80%E3%80%81IO%E5%8F%A3%E7%9A%84%E5%85%AB%E7%A7%8D%E6%A8%A1%E5%BC%8F\">一、IO口的八种模式</a></p>\n<p style=\"margin-left:80px;\"><a href=\"#%E4%BA%8C%E3%80%81IO%E5%8F%A3%E7%9A%84%E9%85%8D%E7%BD%AE\">二、IO口的配置</a></p>\n<p style=\"margin-left:80px;\"><a href=\"#%E4%B8%89%E3%80%81%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD%E9%85%8D%E7%BD%AE\">三、外部中断配置</a></p>\n<p style=\"margin-left:80px;\"><a href=\"#%E5%9B%9B%E3%80%81%E4%B8%B2%E5%8F%A3%E9%85%8D%E7%BD%AE\">四、串口配置</a></p>\n<p style=\"margin-left:80px;\"><a href=\"#%E4%BA%94%E3%80%81%E5%AE%9A%E6%97%B6%E5%99%A8%E9%85%8D%E7%BD%AE\">五、定时器配置</a></p>\n<p style=\"margin-left:80px;\"><a href=\"#%E5%85%AD%E3%80%81%E9%A1%B9%E7%9B%AE\">六、项目</a></p>\n<hr/>\n<h3>一、IO口的八种模式</h3>\n<p><strong>输入</strong></p>\n<p>浮空输入：浮空，顾名思义，就相当与此端口在默认情况下什么都不接，呈高阻态，这种设置在数据传输时用的比较多。</p>\n<p>上拉输入：即通过一个上拉电阻，使它接到vcc</p>\n<p>下拉输入：即通过一个下拉电阻，使它接到gnd</p>\n<p>模拟输入：一般用于adc数模转换</p>\n<p><strong>输出</strong></p>\n<p>推挽输出：既可以输出高电平，也可以输出低电平</p>\n<p>复用推挽输出：一般是一些复用端口再用，比如uart、iic等</p>\n<p>开漏输出：:输出端相当于三极管的集电极. 要得到高电平状态需要上拉电阻才行. 适合于做电流型的驱动,其吸收电流的能力相对强(一般20mA以内).</p>\n<p>复用开漏输出 ：一般用于内外设功能（TX1,MOSI,MISO.SCK.SS）</p>\n<h3>二、IO口的配置</h3>\n<blockquote>\n<p><strong>1. 时钟使能</strong></p>\n<p><strong>2. 配置GPIO</strong></p>\n<p><strong>3. 初始化GPIO</strong></p>\n</blockquote>\n<p><strong>此图片用于M3内核</strong> </p>\n<p style=\"text-align:center;\"><img alt=\"d7ba40a19ab145038a248de6a285f2f7.png\" src=\"image\\d7ba40a19ab145038a248de6a285f2f7.png\"/></p>\n<pre><code class=\"language-cpp\">/*-------led-------*/\n\n#include \"led.h\"\n\nvoid led_Init(void)\n{\n\tGPIO_InitTypeDef led;\n\t\n\t//1.时钟使能\n\n\tRCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC ,  ENABLE);\n\t\n\t//2.配置GPIO\n\t\n\t\tled.GPIO_Mode = GPIO_Mode_Out_PP ;\n\t\tled.GPIO_Pin  = GPIO_Pin_13;\n\t\tled.GPIO_Speed = GPIO_Speed_50MHz;\n\t\n\t//3.初始化GPIO\n\t\n\t GPIO_Init(GPIOC,  &amp;led);\n}\n\n/*-------shake-------*/\n\n#include \"shake.h\"\n\nvoid shake_Init()\n{\n\t\tGPIO_InitTypeDef shake;\n\n\t\n\t//1.使能时钟\n\t\n\t\tRCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA ,  ENABLE);\n\t\n\t//2.配置GPIO\n\t\n\tshake.GPIO_Mode = GPIO_Mode_IPD;\n \tshake.GPIO_Pin  =   GPIO_Pin_4;\n\tshake.GPIO_Speed = GPIO_Speed_10MHz;\n\t\n\t//3.初始化GPIO\n\t\n\t\tGPIO_Init(GPIOA,  &amp;shake);\n\t\n}\n\n/*-------relay-------*/\n\n#include \"relay.h\"\n\nvoid relay_Init()\n{\n\tGPIO_InitTypeDef relay;\n\t\n\t//1.使能时钟\n\t\n\tRCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA ,  ENABLE);\n\n\t\n\t//2.配置GPIO\n\t\n\trelay.GPIO_Mode = GPIO_Mode_Out_PP;\n\trelay.GPIO_Pin  = GPIO_Pin_3;\n\trelay.GPIO_Speed = GPIO_Speed_10MHz;\n\t\n\t//3.初始化GPIO\n\n\tGPIO_Init(GPIOA,  &amp;relay);\n\t\t\n\n}\n\n/*-------delay-------*/\n\n#include \"delay.h\"\n\n\n//us\n\nvoid delay_us(int delay_us)\n{    \n  volatile unsigned int num;\n  volatile unsigned int t;\n \n  \n  for (num = 0; num &lt; delay_us; num++)\n  {\n    t = 11;\n    while (t != 0)\n    {\n      t--;\n    }\n  }\n}\n\n//ms\nvoid delay_ms( int delay_ms)\n{    \n  volatile unsigned int num;\n  for (num = 0; num &lt; delay_ms; num++)\n  {\n    delay_us(1000);\n  }\n\n}</code></pre>\n<h3>三、外部中断配置</h3>\n<blockquote>\n<p><strong>1. 配置GPIO并使能时钟</strong></p>\n<p><strong>2. 把GPIO映射到对应的中断线</strong></p>\n<p><strong>3. 配置外部中断</strong></p>\n<p><strong>4. 配置NVIC组</strong></p>\n<p><strong>5. 配置NVIC中断控制器</strong></p>\n<p><strong>6. 配置中断服务函数</strong></p>\n</blockquote>\n<pre><code class=\"language-cpp\">#include \"exit.h\"\n#include \"shake.h\"\n\nvoid exit_Init()\n{\n\tEXTI_InitTypeDef exti;\n\tNVIC_InitTypeDef nvic;\n\t\n\t//1.配置GPIO\n\t\n\tshake_Init();\n\t\n\tRCC_APB2PeriphClockCmd( RCC_APB2Periph_AFIO,  ENABLE); //打开中断用到的时钟\n\tGPIO_EXTILineConfig( GPIO_PortSourceGPIOA, GPIO_PinSource4 ); //把GPIO映射到对应的中断线----&gt;在GPIO.H\n  NVIC_PriorityGroupConfig( NVIC_PriorityGroup_2); //配置NVIC优先级组---&gt;在misc.h\n\n\n\t\n\t//2.配置外部中断\n\t\n\texti.EXTI_Line      = EXTI_Line4;\n\texti.EXTI_Mode      = EXTI_Mode_Interrupt;\n\texti.EXTI_Trigger   = EXTI_Trigger_Falling;\n\texti.EXTI_LineCmd = ENABLE;   \n\t\n\t//3.初始化外部中断\n\t\n  EXTI_Init(&amp;exti);\n\n\t//4.配置NVIC中断控制器\n\t\n\tnvic.NVIC_IRQChannel     = EXTI4_IRQn; //中断源----&gt;在misc.c---&gt;stm32f10x.h           \n\tnvic.NVIC_IRQChannelPreemptionPriority  = 1;\n\tnvic.NVIC_IRQChannelSubPriority    = 1;\n\tnvic.NVIC_IRQChannelCmd  = ENABLE;\n\t\n\t//5.初始化NVIC\n\t\n  NVIC_Init(&amp;nvic);\n\n\t//6.配置中断服务函数  ----&gt; 在启动文件----用的那个中断源就用那个中断服务函数\n}</code></pre>\n<h3>四、串口配置 </h3>\n<blockquote>\n<p><strong>1. 配置GPIO并使能对应时钟</strong></p>\n<p><strong>2. 配置串口</strong></p>\n<p><strong>3. 配置串口中断</strong></p>\n<p><strong>4. 配置NVIC中断控制器</strong></p>\n<p><strong>5. 配置中断服务函数</strong></p>\n</blockquote>\n<pre><code class=\"language-cpp\">#include \"uart.h\"\n#include \"stdio.h\"\n\ntypedef struct __FILE FILE;\n\nvoid uart_Init()\n{\n\tGPIO_InitTypeDef txrx;\n\tUSART_InitTypeDef uart;\n\tNVIC_InitTypeDef nvic;\n\n\t\n\t//1.GPIO配置并使能时钟\n\n\tRCC_APB2PeriphClockCmd( RCC_APB2Periph_GPIOA,  ENABLE); \n\tRCC_APB2PeriphClockCmd( RCC_APB2Periph_USART1,  ENABLE); \n\tNVIC_PriorityGroupConfig( NVIC_PriorityGroup_2); //配置NVIC优先级组---&gt;在misc.h\n\n\t\n\ttxrx.GPIO_Mode = GPIO_Mode_AF_PP; //复用推挽输出，因为txrx是复用端口\n\ttxrx.GPIO_Pin  = GPIO_Pin_9;\n\ttxrx.GPIO_Speed = GPIO_Speed_50MHz;\n\t\n\tGPIO_Init(GPIOA,  &amp;txrx); //初始化TX\n\n\ttxrx.GPIO_Mode = GPIO_Mode_IN_FLOATING; //因为是接受，所以输入用浮空\n\ttxrx.GPIO_Pin  = GPIO_Pin_10;\n\t//txrx.GPIO_Speed = GPIO_Speed_50MHz; //要不要都一样，因为速度是输出才用\n\t\n\tGPIO_Init(GPIOA,  &amp;txrx); //初始化RX\n\n\t\n\t//2.配置串口\n\t\n\tuart.USART_BaudRate = 9600;\n\tuart.USART_WordLength  = USART_WordLength_8b;\n\tuart.USART_StopBits = USART_StopBits_1;\n\tuart.USART_Parity = USART_Parity_No;\n\tuart.USART_HardwareFlowControl = USART_HardwareFlowControl_None;\n\tuart.USART_Mode = USART_Mode_Rx|USART_Mode_Tx;\n  \n\t USART_Cmd(USART1,ENABLE  ); //使能串口\n\n\t//3.初始化串口\n\t\n\t USART_Init(USART1, &amp;uart);\n\n\t//4.设置串口中断类型\n\n\t USART_ITConfig(USART1, USART_IT_RXNE ,  ENABLE); //接收中断\n\n\n\t//5.配置NVIC\n\t\n\tnvic.NVIC_IRQChannel     = USART1_IRQn; //中断源----&gt;在misc.c---&gt;stm32f10x.h           \n\tnvic.NVIC_IRQChannelPreemptionPriority  = 1;\n\tnvic.NVIC_IRQChannelSubPriority    = 1;\n\tnvic.NVIC_IRQChannelCmd  = ENABLE;\n\t\t\n     NVIC_Init(&amp;nvic);\n\t\t\n\t\n}\n\n\nvoid sendBits(USART_TypeDef* USARTx, uint16_t Data) //发送一个字符\n{\n\t\n\t\t USART_SendData( USARTx,  Data);\n\t\t while( USART_GetFlagStatus(USART1, USART_FLAG_TXE )!= SET); \n\t\n}\n\nvoid sendStr(USART_TypeDef* USARTx, char *Data) //发送一个字符串\n{\n\twhile(*Data != '\\0')\n\t{\n\t\tsendBits(USARTx,*Data);\n\t\tData++;\n\t\t\n\t}\n}\n\t\n\nint fputc(int ch , FILE * p) //printf重定向----&lt;把打印到显示屏的数据,改成打印到串口&gt;\n{\n\t\tUSART_SendData( USART1,  ch);\n\t\t while( USART_GetFlagStatus(USART1, USART_FLAG_TXE )!= SET);\t\t\n\t\n\t\n\treturn ch;\n\t\n}\n\t\nvoid USART1_IRQHandler() //6.中断服务函数\n{\n\tchar buf;\n\t\n\tif( ( USART_GetITStatus(USART1,  USART_IT_RXNE)) == SET) //等于SET就说明已经产生一个中断标志位\n\t{\n\t\tbuf =  USART_ReceiveData( USART1);\n\n\tif(buf == 'o')\n\t{\n\t\tsendStr(USART1, \"ok\");\n\t\tprintf(\"666\"); //---&lt;因为printf本身就可以携带字符串，所以执行fputc,是一位一位给SendData发送的&gt;\n\t\t\n\t\t//while( USART_GetFlagStatus(USART1, USART_FLAG_TXE )!= SET); //USART_FLAG_TXE是发送完成标志，== 0，说明发送完成\n\t}\n\n\t}\n\t\n\t USART_ClearFlag( USART1,USART_FLAG_TXE  );//清除中断标志\n}</code></pre>\n<p><strong>printf重定义 </strong></p>\n<blockquote>\n<p><strong>就是把fputc这个函数原本打印到显示器的数据，给它改到串口</strong></p>\n</blockquote>\n<h3>五、定时器</h3>\n<blockquote>\n<p><strong>1. 定时器配置并使能时钟</strong></p>\n<p><strong>2. 配置定时器中断 （T=（重装值）*（预分频系数）/72Mhz）</strong></p>\n<p><strong>3. 配置NVIC中断控制器</strong></p>\n<p><strong>4. 编写中断服务函数</strong></p>\n</blockquote>\n<p><strong>时钟树 </strong></p>\n<p style=\"text-align:center;\"><strong><img alt=\"ba0af313096f4bb683caddc001ece9e9.png\" src=\"image\\ba0af313096f4bb683caddc001ece9e9.png\"/></strong></p>\n<pre><code class=\"language-cpp\">#include \"time.h\"\n#include \"uart.h\"\n\nvoid time_Init()\n{\n\t\n\tTIM_TimeBaseInitTypeDef time;\n\tNVIC_InitTypeDef nvic;\n  RCC_APB1PeriphClockCmd( RCC_APB1Periph_TIM2,ENABLE  );\n  NVIC_PriorityGroupConfig( NVIC_PriorityGroup_2);\n\n\t \n\t//1.定时器配置\n\t\t\n\ttime.TIM_Prescaler  = 7200-1; //预分频系数\n\ttime.TIM_Period     = 10000-1; //自动重装\n\ttime.TIM_ClockDivision = TIM_CKD_DIV1;//时钟分频，设置定时器时钟CK_INT频率与数字滤波采样\n\ttime.TIM_CounterMode = TIM_CounterMode_Up; //向上计数\n\t\n\t//2.定时器初始化并使能\n\t\n  TIM_TimeBaseInit( TIM2, &amp;time);\n\tTIM_Cmd(TIM2,  ENABLE);\n\t\n\t//3.配置定时器中断\n\t\n\t TIM_ITConfig( TIM2,  TIM_IT_Update,  ENABLE);\n\n\n\t//4.配置NVIC中断控制器\n\t\n\tnvic.NVIC_IRQChannel     = TIM2_IRQn; //中断源----&gt;在misc.c---&gt;stm32f10x.h           \n\tnvic.NVIC_IRQChannelPreemptionPriority  = 1;\n\tnvic.NVIC_IRQChannelSubPriority    = 1;\n\tnvic.NVIC_IRQChannelCmd  = ENABLE;\n\t\n  NVIC_Init(&amp;nvic);\n\t\n\t\n}\n\n\t//5.中断服务函数\n\nvoid TIM2_IRQHandler()\n{\n\t \n\t\n\tif(TIM_GetITStatus( TIM2, TIM_IT_Update ) == SET)\n\t {\n\t\t \n\t\t  TIM_ClearITPendingBit( TIM2, TIM_IT_Update );//清除定时器中断标志位\n\t\t\n\t\t\t\n\t\t\t\t\tUSART_SendData( USART1,  'a');\n\t\t\t\t\twhile( USART_GetFlagStatus(USART1, USART_FLAG_TXE )!= SET);\n\t\t\t\n\t }\n\t \n\n\n}</code></pre>\n<h3><strong>systick定时器</strong></h3>\n<blockquote>\n<p><strong>1. 配置时钟源（可以72mhz/9mhz）</strong></p>\n<p><strong>2. 配置重装值 </strong></p>\n<p><strong>3. 向下递减到0触发中断退出定时器</strong></p>\n<p><strong>4. 关闭定时器</strong></p>\n</blockquote>\n<pre><code class=\"language-cpp\">#include \"systick.h\"\n\nvoid Delay_ms(int ms) //最大24位\n{\n\tint i;\n\tSysTick_Config(72000);\n\t\n\tfor(i = 0; i &lt; ms;i++ )\n\t{\n\t\twhile(!(SysTick-&gt;CTRL)&amp; 1&lt;&lt;16 );\n\t\t\n\t}\n\t\n\t\tSysTick-&gt;CTRL &amp;=~SysTick_CTRL_ENABLE_Msk;\n\t\n}\n\nvoid Delay_us(int us) //最大24位\n{\n\tint i;\n\tSysTick_Config(72);//重装定时器值,t = 重装值*(1/72mhz),反过来讲7200就是，72000*(1/72MHz)=1/1000=1(ms)\n\t \n\tfor(i = 0; i &lt; us;i++ )\n\t{\n\t\twhile(!(SysTick-&gt;CTRL)&amp; 1&lt;&lt;16 );//如果数到了0，则该为为1\n\t\t\n\t}\n\t\n\t\tSysTick-&gt;CTRL &amp;=~SysTick_CTRL_ENABLE_Msk; //关闭计数器 置0\n\t\n}</code></pre>\n<h3>PWM模式</h3>\n<blockquote>\n<p><strong>1 .使能时钟和使能AFIO时钟（因为需要引脚复用）</strong></p>\n<p><strong>2. 调用函数进行引脚映射</strong></p>\n<p><strong>3. GPIO配置 （这里我们用的定时器3通道2）</strong></p>\n<p><strong>4. 定时器配置</strong></p>\n<p><strong>5. pwm配置</strong></p>\n<p><strong>6. pwm初始化，并使能pwm和使能rcc</strong></p>\n</blockquote>\n<p style=\"text-align:center;\"> <img alt=\"d421918434584778abe9530e3a1a30c8.jpeg\" src=\"image\\d421918434584778abe9530e3a1a30c8.jpeg\"/></p>\n<p style=\"text-align:center;\"> <img alt=\"ea1f60ffa25e4b018097b81c6b7d540e.png\" src=\"image\\ea1f60ffa25e4b018097b81c6b7d540e.png\"/></p>\n<pre><code class=\"language-cpp\">#include \"pwm.h\"\n\nvoid pwm_Init()\n{\n\tGPIO_InitTypeDef dj;\n\tTIM_TimeBaseInitTypeDef time;\n\tTIM_OCInitTypeDef pwm;\n\n\t\n\tRCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,  ENABLE); //用于映射到这个引脚，打开这个引脚的时钟\n  RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,  ENABLE); //引脚复用，必须打开这个时钟\n\tRCC_APB1PeriphClockCmd( RCC_APB1Periph_TIM3,ENABLE  ); //使能定时器3的时钟\n\t\n  GPIO_PinRemapConfig(GPIO_PartialRemap_TIM3 , ENABLE ); //指定管脚映射\n\n\t//1.GPIO配置\n\t\n\tdj.GPIO_Mode = GPIO_Mode_AF_PP;\n\tdj.GPIO_Pin  = GPIO_Pin_5;        //*****用的定时器3通道2******\n\tdj.GPIO_Speed = GPIO_Speed_50MHz;\n\t\n\tGPIO_Init( GPIOB, &amp;dj);\n\t\n\t//2.定时器配置\n\t\n\ttime.TIM_Prescaler  = 7200-1; //自动重装\n\ttime.TIM_Period     = 200-1; //预分频系数\n\ttime.TIM_ClockDivision = TIM_CKD_DIV1;//时钟分频，设置定时器时钟CK_INT频率与数字滤波采样\n\ttime.TIM_CounterMode = TIM_CounterMode_Up; //向上计数\n\n  TIM_TimeBaseInit( TIM3, &amp;time);\n\t\n\t//3.PWM配置\n\t\n\tpwm.TIM_OCMode = TIM_OCMode_PWM1;  //选择pwm1模式，如果定时器向上计数，一旦cnt&lt;crr时，通道为有效电平，定时器向下则无效电平，pwm2则相反\n\tpwm.TIM_OutputState = TIM_OutputState_Enable; //使能比较输出，就是打开把输出的电平给到重映射的引脚上\n\tpwm.TIM_OCPolarity = TIM_OCPolarity_Low; //选择有效电平为低电平\n\t\n\t//4.pwm初始化并使能ccr并使能定时器3\n\t\n\t TIM_OC2Init( TIM3, &amp;pwm );\n\t TIM_OC2PreloadConfig(TIM3,TIM_OCPreload_Enable);\n\t TIM_Cmd(TIM3,  ENABLE);\n\n\t \n\t\n}\n\n</code></pre>\n<pre><code class=\"language-cpp\">#include \"stm32f10x.h\"\n#include \"delay.h\"\n#include \"pwm.h\"\n\nint main()\n{\n\n\t pwm_Init();\n\t\t\n\t TIM_SetCompare2(TIM3,  195); //设置比较值\n\t\n\t\twhile(1)\n\t\t{\n\t\t\t delay_ms(1000);\n\t\t\t TIM_SetCompare2(TIM3,  175); //设置比较值,180°\n\t\t\t delay_ms(1000);\n\t\t\t TIM_SetCompare2(TIM3,  195); //设置比较值，0°\n\t\t\t \t\t\t \n\n\n\t\t\n\t\t\n\t\t} \n\n}</code></pre>\n<h3>DMA(直接寄存器访问)</h3>\n<blockquote>\n<p><strong>DMA传输将数据从一个地址空间复制到另一个地址空间，提供在外设和存储器之间或者存储器和存储器之间的高速数据传输</strong></p>\n</blockquote>\n<p>我们知道CPU有转移数据、计算、控制程序转移等很多功能，<strong>系统运作的核心就是CPU</strong>，那我们可不可以减轻消耗cpu的资源呢？</p>\n<p>有，我们可以直接让内存-&gt;外设、外设-&gt;内存，内存-&gt;内存，因为有dma，它不需要经过cpu,可以直接访问flash或SRAM。</p>\n<p style=\"text-align:center;\"><img alt=\"f4cc9457be094549b6c7a5aad28cd230.png\" src=\"image\\f4cc9457be094549b6c7a5aad28cd230.png\"/> <img alt=\"83a953cdf89243449c33be1468715717.png\" src=\"image\\83a953cdf89243449c33be1468715717.png\"/></p>\n<p><img alt=\"40753888afd14a4d80dc7b63aa5563b4.png\" src=\"image\\40753888afd14a4d80dc7b63aa5563b4.png\"/></p>\n<blockquote>\n<p><strong>1. 配置DMA</strong></p>\n<p><strong>2. 初始化/使能DMA</strong></p>\n<p><strong>3. 使能串口DMA（这里用的内存-&gt;串口）</strong></p>\n<p><strong>4. 获取DMA标志位、判断是否发送完成</strong></p>\n</blockquote>\n<pre><code class=\"language-cpp\">/*\n\t\n\t\t内存-&gt;外设\n\n*/\n\n#include \"dma.h\"\n\nvoid dma_Init(DMA_Channel_TypeDef* DMAy_Channelx,u32 *paddr,u32 *maddr,u16 size)\n{\n\t\tDMA_InitTypeDef dma;\n\t\tRCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1,  ENABLE);\n\t\t\n\t\t//1.配置dma\n\t\t\n\t\tdma.DMA_PeripheralBaseAddr = (u32)paddr; //外设地址,是u32位，所以要强转\n\t\tdma.DMA_MemoryBaseAddr = (u32)maddr; //内存地址，是u32位\n\t\tdma.DMA_DIR = DMA_DIR_PeripheralDST; //传输方向，我们选择从内存到外设\n\t\tdma.DMA_BufferSize = size; //设置一次传输的大小,最大传输65536\n\t    dma.DMA_PeripheralInc = DMA_PeripheralInc_Disable; //设置传输数据外设地址是否递增\n\t\tdma.DMA_MemoryInc = DMA_MemoryInc_Enable; //设置传输数据内存地址是否递增\n\t\tdma.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte; //设置外设的数据长度为多少字节传输\n\t\tdma.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte; //设置内存的数据长度为多少地址传输 \n\t\tdma.DMA_Mode = DMA_Mode_Normal; //设置模式，是循环发送，还是只发送一次\n\t\tdma.DMA_Priority = DMA_Priority_High; //设置dma的通道优先级，一共有低、中、高、很高4个优先级\n\t\tdma.DMA_M2M = DMA_M2M_Disable; //这是设置内存到内存的使能\n\t\n\t\t//2.初始化dma\n\t\n\t\t DMA_Init(DMAy_Channelx , &amp;dma); //用参数传递通道，提高使用性\n\n}\n\n\nvoid dma_Enable(DMA_Channel_TypeDef* DMAy_Channelx,uint16_t size)\n{\n\t DMA_Cmd(DMAy_Channelx,  DISABLE); //先失能\n\t DMA_SetCurrDataCounter( DMAy_Channelx,  size); //设置数据传输量\n\t DMA_Cmd(DMAy_Channelx,  ENABLE);  //使能\n\n}\n</code></pre>\n<pre><code class=\"language-cpp\">#include \"stm32f10x.h\"\n#include \"delay.h\"\n#include \"dma.h\"\n#include \"uart.h\"\n\n#define SIZE 2000\n\nu8 maddr[SIZE]; //定义maddr\n\nvoid maddr_Init(u8 * p)\n{\n\tint i = 0;\n\tfor(i = 0; i &lt; SIZE;++i)\n\t{\n\t\t*p = '5';\n\t\t p++;\n\t}\n}\n\nint main()\n{\n\t uart_Init();\n\t dma_Init( DMA1_Channel4,(u32 *)&amp;USART1-&gt;DR, (u32 *)maddr, SIZE); //初始化dma---USART1-&gt;DR---(串口的数据寄存器，也就是这里的外设地址)\n\t\t\n\t maddr_Init(maddr); //给内存地址写值\n\t USART_DMACmd( USART1,  USART_DMAReq_Tx,  ENABLE); //使能外设，并配置成发送\n\t dma_Enable(DMA1_Channel4, SIZE); //使能dma1通道\n\t\n\twhile(1)\n\t{\n\t\t\t if(DMA_GetFlagStatus( DMA1_FLAG_TC4) == SET) //判断是否发送完成\n\t\t\t {\n\t\t\t\t  DMA_ClearFlag( DMA1_FLAG_TC4); //发送完成清除标志\n\t\t\t\t \n\t\t\t\t\tbreak; //打破while，只执行一次\n\n\t\t\t }\n\n\t}\n\t\t\n\n}</code></pre>\n<p></p>\n<p></p>\n</div>\n</div>"}