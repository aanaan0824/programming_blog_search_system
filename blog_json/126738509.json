{"blogid": "126738509", "writerAge": "码龄2年", "writerBlogNum": "50", "writerCollect": "10", "writerComment": "15", "writerFan": "89", "writerGrade": "3级", "writerIntegral": "578", "writerName": "Qinꦿ.๓", "writerProfileAdress": "writer_image\\profile_126738509.jpg", "writerRankTotal": "33010", "writerRankWeekly": "6713", "writerThumb": "40", "writerVisitNum": "4741", "blog_read_count": "18", "blog_time": "于 2022-09-07 09:51:12 发布", "blog_title": "SpringBoot整合MyBatis和Redis", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h1><strong>Spring框架配置方式</strong></h1>\n<p><span style=\"color:#fe2c24;\"><strong>XML配置方</strong></span></p>\n<p>优点：便于阅读、与业务代码解耦</p>\n<p>缺点：解析XML影响性能、开发工作量大，编译器不可校验配置正确性</p>\n<p><span style=\"color:#fe2c24;\"><strong>注解配置方式</strong></span></p>\n<p>优点：开发便捷、编译期可校验配置正确性</p>\n<p>缺点：注解与代码绑定，配置分散，不利于统一处理</p>\n<p><span style=\"color:#fe2c24;\"><strong>Java配置方式</strong></span></p>\n<p>优点：编译期可校验配置正确性、配置简单，方便维护和管理、可以使用IDE的代码提示功能</p>\n<p>缺点：不利于新人学习和理解框架的原理</p>\n<h1><strong>实现Java配置方式</strong></h1>\n<p>实现Java配置的方式，主要通过两个注解：@Configuration和@Bean</p>\n<p><span style=\"color:#fe2c24;\"><strong>@Configuration</strong></span></p>\n<p>标注于类上，表示该类为配置类，具有与Spring IoC配置文件相同的功能</p>\n<p><span style=\"color:#fe2c24;\"><strong>@Bean</strong></span></p>\n<p>标注于配置类的方法上，用于向该配置类注入一个Bean组件</p>\n<p>方法返回值为组件的对象类型</p>\n<p><span style=\"color:#fe2c24;\"><strong>演示案例</strong></span></p>\n<pre><code class=\"hljs\">实体类\n\npublic class Dog {\n\n    private String name;//宠物狗狗的姓名\n\n    private int age;//宠物狗狗的年龄\n\n    //此处省略getter and setter 方法\n\n}\n\npublic class User {\n\n    private String userName;\n\n    private Dog dog;\n\n    //此处省略getter and setter 和 toString方法\n\n}\n\n\n配置类\n\n/**\n\n * @Configuration 指明当前类是一个配置类，就是来代替之前的Spring配置文件\n\n * 在配置文件中用&lt;bean id=\"\" class=\"\"&gt;&lt;/bean&gt;标签添加组件\n\n */\n\n@Configuration\n\npublic class JavaConfig {\n\n    //将方法的返回值添加到容器中；容器中这个组件默认的id就是方法名\n\n    //@Bean\n\n    //@Bean注解提供了name属性，通过name属性可以指定Bean组件的id值\n\n    @Bean(name = \"user13\")\n\n    public User user12(){\n\n        User user=new User();\n\n        user.setUserName(\"小明\");\n\n        Dog dog=new Dog();\n\n        dog.setName(\"欢欢\");\n\n        dog.setAge(5);\n\n        user.setDog(dog);\n\n        return user;\n    }\n}\n\n\n\n\n\n测试类\n\n@RunWith(SpringRunner.class)\n\n@SpringBootTest\n\nclass Ch041javapeizhiApplicationTests {\n\n    @Test\n    void contextLoads() {\n\n        /*java配置的方式生成的Spring容器。测试时，首先通过AnnotationConfigApplicationContext\n\n        获取SpringIoc容器的上下文信息。再在上下文信息中获取对应的Bean组件*/        \n\n        ApplicationContext act=new AnnotationConfigApplicationContext(JavaConfig.class);\n\n        User user=(User)act.getBean(\"user13\");\n\n        System.out.println(user.toString());\n\n    }\n\n    @Resource\n\n    private User user;\n\n    @Test\n\n    void contextLoads2() {\n\n        System.out.println(user.toString());\n\n    }\n\n}\n</code></pre>\n<p><span style=\"color:#fe2c24;\"><strong>Java配置方式扩展</strong></span></p>\n<p><strong>Bean组件的作用域：@Scope注解可以标注在方法上与@Bean注解搭配使用</strong></p>\n<p>@Scope(\"singleton\") ：默认，单例模式，容器只创建一次实例</p>\n<p>@Scope(\"prototype\") ：每次获取时创建新的实例</p>\n<p><strong>initMethod属性</strong></p>\n<p>作用：被标注的方法将于容器启动前执行</p>\n<p>使用方法：@Bean(initMethod=\"Bean中的初始化方法名\")</p>\n<p><strong>destroyMethod属性</strong></p>\n<p>作用：被标注的方法将于容器销毁前执行</p>\n<p>使用方法：@Bean(destroyMethod=\"Bean中的销毁方法名\")</p>\n<h1><strong>SpringBoot整合MyBatis</strong></h1>\n<p>SpringBoot整合MyBatis的方式有两种，根据引入依赖的名称：分为<strong>mybatis-spring的方式</strong> 和 <strong>mybatis-spring-boot-starter的方式</strong>。</p>\n<p><span style=\"color:#fe2c24;\"><strong>方式1：mybatis-spring方式</strong></span></p>\n<p><span style=\"color:#4d4d4d;\">创建SpringBoot项目，搭建项目结构如图：</span></p>\n<p style=\"text-align:center;\"><span style=\"color:#4d4d4d;\"><img alt=\"\" src=\"image\\dba35d8691254527b5236d476b3d4bc5.png\"/></span></p>\n<pre><code class=\"hljs\">\n实体类----------------------------------------\n\npublic class User {\n\n    private Integer id;\n\n    private String userName;\n\n    private String userPassword;\n\n    //此处省略getter and setter\n\n}\n\n\n\n\nmapper类----------------------------------------\n\npublic interface UserMapper {\n\n    //根据id查询对应的用户信息\n\n    User getUserById(Long id);\n\n}\n\n\n\nmapper映射文件----------------------------------------\n\n&lt;mapper namespace=\"com.msds.mapper.UserMapper\"&gt;\n\n    &lt;!--根据id查询对应的用户信息--&gt;\n\n    &lt;select id=\"getUserById\" resultType=\"user\" parameterType=\"long\"&gt;\n\n        select * from `smbms_user`\n\n        &lt;where&gt;\n\n            id=#{id}\n        &lt;/where&gt;\n\n    &lt;/select&gt;\n\n&lt;/mapper&gt;\n\nservice接口----------------------------------------\n\npublic interface UserService {\n\n    //根据id查询对应的用户信息\n\n    User getUserById(Long id);\n\n}\n\nservice接口实现类---------------------------------------- \n\nimport javax.annotation.Resource;\n\n@Service\n\npublic class UserServiceImpl implements UserService{\n\n    @Resource\n\n    private UserMapper userMapper;\n\n    //根据id查询对应的用户信息\n\n    @Override\n\n    public User getUserById(Long id) {\n\n        return userMapper.getUserById(id);\n\n    }\n\n}\n\n\n</code></pre>\n<p> <strong><span style=\"color:#4d4d4d;\">步骤1：引入依赖：</span>MyBatis包、MyBatis-Spring整合包</strong></p>\n<pre><code class=\"hljs\">  &lt;!--Spring整合MyBatis包--&gt;\n\n        &lt;dependency&gt;\n\n            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;\n\n            &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;\n\n            &lt;version&gt;2.0.3&lt;/version&gt;\n\n        &lt;/dependency&gt;\n\n        &lt;!--MyBatis包--&gt;\n\n        &lt;dependency&gt;\n\n            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;\n\n            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;\n\n            &lt;version&gt;3.5.1&lt;/version&gt;\n\n        &lt;/dependency&gt;\n\n        &lt;!--整合mybatis后需要进行数据持久化操作，因此还须引入与数据库操作相关的依赖--&gt;\n\n        &lt;dependency&gt;\n\n            &lt;groupId&gt;mysql&lt;/groupId&gt;\n\n            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\n            &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;\n\n        &lt;/dependency&gt;\n</code></pre>\n<p> <span style=\"color:#4d4d4d;\"><strong>步骤2：编写配置信息：</strong></span><strong>配置数据源DataSource、配置SqlSessionFactoryBean、配置MapperScannerConfigurer</strong></p>\n<p>2.1配置数据源(这里在application.yml文件中配置的)</p>\n<pre><code class=\"hljs\">\napplication.yml文件\n\n#配置数据源DataSource\n\nspring:\n\n  datasource:\n\n    driver-class-name: com.mysql.cj.jdbc.Driver\n\n    url: jdbc:mysql://localhost:3306/smbms?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC&amp;zeroDateTimeBehavior=convertToNull\n\n    username: root\n\n    password: 123456\n</code></pre>\n<p> <span style=\"color:#4d4d4d;\">2.2配置SqlSessionFactoryBean</span></p>\n<p><span style=\"color:#4d4d4d;\">新建工具类DataSourceUtil.java，类中添加如下代码</span></p>\n<pre><code class=\"hljs\">\nimport org.apache.ibatis.session.SqlSessionFactory;\n\nimport org.mybatis.spring.SqlSessionFactoryBean;\n\nimport org.springframework.beans.factory.annotation.Autowired;\n\nimport org.springframework.context.annotation.Bean;\n\nimport org.springframework.context.annotation.Configuration;\n\nimport javax.sql.DataSource;\n\n\n@Configuration\n\npublic class DataSourceUtil {\n\n    @Autowired\n\n    private DataSource dataSource;\n\n    @Bean\n\n    public SqlSessionFactory sqlSessionFactoryBean(){\n\n        SqlSessionFactoryBean sqlSessionFactoryBean=new SqlSessionFactoryBean();\n\n        try {\n\n            sqlSessionFactoryBean.setDataSource(dataSource);\n\n            sqlSessionFactoryBean.setTypeAliasesPackage(\"com.msds.bean\");\n\n            return sqlSessionFactoryBean.getObject();\n\n        } catch (Exception e) {\n\n            e.printStackTrace();\n\n            throw new RuntimeException();\n\n        }\n\n    }\n\n}\n\n\n</code></pre>\n<p> <span style=\"color:#4d4d4d;\">2.3配置MapperScannerConfigurer</span></p>\n<p><span style=\"color:#4d4d4d;\">创建工具类MyBatisConf .java，类中添加如下代码</span></p>\n<pre><code class=\"hljs\">\nimport org.mybatis.spring.mapper.MapperScannerConfigurer;\n\nimport org.springframework.context.annotation.Bean;\n\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\n\npublic class MyBatisConf {\n\n    @Bean\n    public MapperScannerConfigurer mapperScannerConfigurer(){\n\n        //定义扫描器实例\n\n        MapperScannerConfigurer msc=new MapperScannerConfigurer();\n\n        //通过SqlSessionFactoryBean生产SqlSessionFactory实例\n\n        //小括号中的信息来源于DataSourceUtil类中的获取SqlSessionFactory方法的名字\n\n        msc.setSqlSessionFactoryBeanName(\"sqlSessionFactoryBean\");\n\n        //定义扫描的包\n\n        msc.setBasePackage(\"com.msds.mapper\");\n\n        return msc;\n\n    }\n\n}\n\n\n</code></pre>\n<p> <span style=\"color:#4d4d4d;\">完成了上述配置代码之后，就完成了与MyBatis的整合工作。在业务实现类中注入Mapper组件，并在UserController类中编写getUserById()方法，接受前台页面的请求，实现通过用户的id查询用户信息。UserController代码如下</span></p>\n<pre><code class=\"hljs\">\nimport com.msds.bean.User;\n\nimport com.msds.service.UserService;\n\nimport org.springframework.web.bind.annotation.RequestMapping;\n\nimport org.springframework.web.bind.annotation.RequestMethod;\n\nimport org.springframework.web.bind.annotation.RequestParam;\n\nimport org.springframework.web.bind.annotation.RestController;\n\nimport javax.annotation.Resource;\n\n//@RestController 此注解是一个组合注解，是Controller和@ResponseBody的组合\n\n@RestController\n\npublic class UserController {\n\n    @Resource\n\n    private UserService userService;\n\n    @RequestMapping(value = \"/getUserById\",method = RequestMethod.GET)\n\n    public String getUserById(@RequestParam String id){\n\n        User user=userService.getUserById(Long.parseLong(id));\n\n        String name=user.getUserName();\n\n        return name;\n\n    }\n\n}\n\n\n</code></pre>\n<p><span style=\"color:#fe2c24;\"><strong>方式2：mybatis-spring-boot-starter方式</strong></span></p>\n<p><strong>步骤1：引入依赖</strong></p>\n<pre><code class=\"hljs\">     &lt;!--引入与MyBatis相关的依赖--&gt;\n\n        &lt;!--由于spring-boot-parent没有指定mybatis-spring-boot-starter的版本号 所以在引入时 需要手动指定版本号 --&gt;\n\n        &lt;dependency&gt;\n\n            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;\n\n            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;\n\n            &lt;version&gt;2.0.1&lt;/version&gt;\n\n        &lt;/dependency&gt;\n\n        &lt;!--引入与MySQL数据库相关的依赖--&gt;\n\n        &lt;dependency&gt;\n\n            &lt;groupId&gt;mysql&lt;/groupId&gt;\n\n            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n\n        &lt;/dependency&gt;\n</code></pre>\n<p><strong>步骤2：编写配置文件</strong></p>\n<p>使用mybatis-spring-boot-starter的方式整合时，SpringBoot已经通过自动配置，生成了系统所需要的MapperScannerConfigurer组件，并给此组件注入了DataSource，开发人员需要在application.yml文件中配置数据源，指定mapper映射文件和接口的位置、MyBatis配置文件的位置和需要起别名的实体所在包的位置。具体配置如下：</p>\n<pre><code class=\"hljs\">#配置数据源DataSource\n\nspring:\n\n  datasource:\n\n    driver-class-name: com.mysql.cj.jdbc.Driver\n\n    url: jdbc:mysql://localhost:3306/smbms?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC&amp;zeroDateTimeBehavior=convertToNull\n\n    username: root\n\n    password: 123456\n\nmybatis:\n\n  #指定Mapper映射文件位置\n\n  #mapper-locations: classpath:com/msds/mapper/UserMapper.xml\n\n  mapper-locations: classpath:com/msds/mapper/*.xml\n\n  #指定需起别名的实体包位置\n\n  type-aliases-package: com.msds.bean\n</code></pre>\n<p> <strong>步骤3：步骤2的配置中缺少了指定Mapper接口位置的配置，MyBatis中提供了两个注解，用于指定Mapper接口的位置</strong></p>\n<p><strong><span style=\"color:#ffd900;\">@Mapper</span>：</strong>标注在Mapper接口上</p>\n<p><span style=\"color:#ffd900;\"><strong>@MapperScan(\"Mapper接口所在的包名\"</strong></span><strong><span style=\"color:#ffd900;\">)</span>：</strong>标注到启动类上，或者某个配置类上（即被@Configuration标注的类）</p>\n<p>使用以上两个注解中的任何一个都可指定Mapper的接口位置代码测试</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\c8bcd99380f74cf58ed6db6be5abd7a5.png\"/></p>\n<h1><strong>数据源和事务</strong></h1>\n<p><span style=\"color:#fe2c24;\"><strong>演示案例：配置DBCP2连接池</strong></span></p>\n<p><strong>步骤1：添加依赖</strong></p>\n<pre><code class=\"hljs\">     &lt;!--引入与MyBatis相关的依赖--&gt;\n\n        &lt;!--由于spring-boot-parent没有指定mybatis-spring-boot-starter的版本号 所以在引入时 需要手动指定版本号 --&gt;\n\n        &lt;dependency&gt;\n\n            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;\n\n            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;\n\n            &lt;version&gt;2.0.1&lt;/version&gt;\n\n        &lt;/dependency&gt;\n\n        &lt;!--引入Mysql相关依赖--&gt;\n\n        &lt;dependency&gt;\n\n            &lt;groupId&gt;mysql&lt;/groupId&gt;\n\n            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n\n        &lt;/dependency&gt;\n\n        &lt;!--DBCP2数据源连接池依赖\n\n            spring-boot-starter-parent指定了commons-dbcp2的版本号，所以不需要手动指定版本号；\n\n            若指定了版本号，则按所指定的版本号为准\n\n        --&gt;\n\n        &lt;dependency&gt;\n\n            &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;\n\n            &lt;artifactId&gt;commons-dbcp2&lt;/artifactId&gt;\n\n        &lt;/dependency&gt;\n</code></pre>\n<p> <strong>步骤2：在application.yml中配置DBCP2数据源连接池</strong></p>\n<pre><code class=\"hljs\">#配置数据源DataSource\nspring:\n\n  datasource:\n\n    driver-class-name: com.mysql.cj.jdbc.Driver\n\n    url: jdbc:mysql://localhost:3306/smbms?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC&amp;zeroDateTimeBehavior=convertToNull\n\n    username: root\n\n    password: 123456\n\n    #数据源的类型。使用DBCP2配置连接池，需指定数据源类型，否则Spring Boot仍会使用内置的数据源\n\n    type: org.apache.commons.dbcp2.BasicDataSource\n\n    dbcp2:\n\n      #最大空闲数\n\n      max-idle: 10\n\n      #最大连接数\n\n      max-total: 50\n\nmybatis:\n\n  #指定Mapper映射文件位置\n\n  #mapper-locations: classpath:com/msds/mapper/UserMapper.xml\n\n  mapper-locations: classpath:com/msds/mapper/*.xml\n\n  #指定需起别名的实体包位置\n\n  type-aliases-package: com.msds.bean\n</code></pre>\n<p> <strong>步骤3：启动类上要添加注解</strong></p>\n<p><strong><span style=\"color:#ffd900;\"><strong>@MapperScan(</strong><strong>\"Mapper接口所在的包名\"</strong><strong>)</strong></span></strong></p>\n<p><strong>步骤4：测试——编写DataSourceShow类，如下：</strong></p>\n<pre><code class=\"hljs\">import org.springframework.beans.BeansException;\n\nimport org.springframework.context.ApplicationContext;\n\nimport org.springframework.context.ApplicationContextAware;\n\nimport org.springframework.stereotype.Component;\n\nimport javax.sql.DataSource;\n\n//项目在启动时就可加载 重写的setApplicationContext()方法\n\n@Component\n\npublic class DataSourceShow implements ApplicationContextAware {\n\n    ApplicationContext ac=null;\n\n    @Override\n\n    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n\n        this.ac=applicationContext;\n\n        DataSource dataSource=applicationContext.getBean(DataSource.class);\n\n        System.out.println(\"+++++++++++++++++++++++++++++++++++++++\");\n\n        System.out.println(dataSource.getClass().getName());\n\n    }\n\n}\n</code></pre>\n<p><span style=\"color:#fe2c24;\"><strong>事务控制</strong></span></p>\n<p>SpringBoot项目中可以使用注解管理事务——<strong>@Transactional</strong></p>\n<p>添加到类上，作用于当前类的所有方法</p>\n<p>添加到方法上，作用于当前方法</p>\n<p>在实际的开发中可能配置多数据源，针对不同的数据源，SpringBoot生成的事务管理器也不同。此时可以通过@Transactional的Value属性指定使用的事务管理器</p>\n<p>@Transactional(Value=\"事务管理器的名称\")</p>\n<p><strong>扩展知识</strong></p>\n<p>设置事务传播特性</p>\n<p>@Transactional(isolation=Isolation.PROPAGATION_REQUIRED)</p>\n<p>默认：REQUIRED</p>\n<p>设置事务隔离级别</p>\n<p>@Transactional(propagation=Propagation.ISOLATION_DEFAULT)</p>\n<p>默认：使用数据库的隔离级别</p>\n<h1><span style=\"color:#fe2c24;\">Spring-Boot整合Redis</span></h1>\n<p>windows下安装Redis/菜鸟教程：<a href=\"http://www.runoob.com/redis/redis-install.html\" title=\"Redis 安装 | 菜鸟教程\">Redis 安装 | 菜鸟教程</a>  </p>\n<p><strong>步骤1：引入依赖</strong></p>\n<pre><code class=\"hljs\">    &lt;!--引入redis依赖--&gt;\n\n        &lt;dependency&gt;\n\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\n            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;\n\n        &lt;/dependency&gt;\n</code></pre>\n<p> <strong>步骤2：配置Redis连接</strong></p>\n<p>由于SpringBoot整合Redis之后内部已经集成了与Redis相关的自动配置，所以，开发人员只需在application.yml文件中配置与Redis服务端的连接，需要配置的内容如下：</p>\n<pre><code class=\"hljs\">spring:\n\n  redis:\n\n    host: Redis服务的IP  本机的话写127.0.0.1或localhost就可以了\n\n    port: Redis服务端口，通常为 6379\n\n    password: 连接Redis服务的密码  无密码就啥都不写\n\n    database: 0   \"0\"表示0号库\n</code></pre>\n<p> <strong>步骤3：创建RedisTemplate的Bean组件</strong></p>\n<p>RedisTemplate是SpringBoot提供的一个模板类，它提供了很多快速使用Redis的API，而不需要自己来维护连接、事务。</p>\n<p>具体实现方法是创建一个配置类来管理RedisTemplate的Bean组件，具体代码实现如下：</p>\n<pre><code class=\"hljs\">\nimport org.springframework.context.annotation.Bean;\n\nimport org.springframework.context.annotation.Configuration;\n\nimport org.springframework.data.redis.connection.RedisConnectionFactory;\n\nimport org.springframework.data.redis.core.RedisTemplate;\n\n@Configuration\n\npublic class RedisConfig {\n\n    //参数RedisConnectionFactory为Spring Boot自动注入\n\n    @Bean\n\n    public RedisTemplate&lt;String,Object&gt; redisTemplate(RedisConnectionFactory factory){\n\n        RedisTemplate&lt;String,Object&gt; rt=new RedisTemplate&lt;String,Object&gt;();\n\n        rt.setConnectionFactory(factory);\n\n        return rt;\n\n    }\n\n}\n\n\n</code></pre>\n<p> <strong>步骤4：创建工具类调用<strong>RedisTemplate操作Redis服务端，进行数据的存取。代码如下</strong></strong></p>\n<pre><code class=\"hljs\">\nimport org.springframework.data.redis.core.RedisTemplate;\n\nimport org.springframework.data.redis.core.ValueOperations;\n\nimport org.springframework.stereotype.Component;\n\nimport javax.annotation.Resource;\n\n@Component\n\npublic class RedisUtil {\n\n    @Resource\n\n    private RedisTemplate&lt;String,Object&gt; redisTemplate;\n    /**\n\n     * 往redis中缓存数据\n\n     * @param key\n\n     * @param object\n\n     * @return\n\n     */\n\n    public boolean set(String key,Object object){\n\n        ValueOperations&lt;String,Object&gt; vo=redisTemplate.opsForValue();\n\n        vo.set(key,object);\n\n        return true;\n\n    }\n\n    /**\n\n     * 根据key从redis服务器中获取value值\n\n     * @param key\n\n     * @return\n\n     */\n\n    public Object get(String key){\n\n        ValueOperations&lt;String,Object&gt; vo=redisTemplate.opsForValue();\n\n        return vo.get(key);\n\n    }\n\n}\n</code></pre>\n<p> <strong>步骤5：测试</strong></p>\n<p>首先需要在项目启动时为Redis初始化一些数据。SpringBoot提供了一个名为CommandLineRunner的接口。实现了此接口的类，重写CommandLineRunner接口的run()方法，run()方法中的代码即可在项目启动时运行。</p>\n<p>这里通过创建CommandLineRunner的子类来完成Redis数据的初始化工作，代码如下：</p>\n<pre><code class=\"hljs\">\nimport org.springframework.boot.CommandLineRunner;\n\nimport org.springframework.stereotype.Component;\n\nimport javax.annotation.Resource;\n\n@Component\n\npublic class MyRunner implements CommandLineRunner {\n\n    @Resource\n\n    private RedisUtil redisUtil;\n\n    @Override\n\n    public void run(String... args) throws Exception {\n\n        System.out.println(\"项目启动了。。。\");\n\n        redisUtil.set(\"key02\",\"spring-redis\");\n\n        System.out.println(\"获取redis中的值：\"+redisUtil.get(\"key02\"));\n\n    }\n\n}\n</code></pre>\n<p>我们现在使用springBoot默认提供的redis服务，但是按上面的步骤操作完以后。</p>\n<p>发现存在的问题：序列化，我们set到redis服务器中的key和value是这样的</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\adb2fea294f4435c94a4391781bdb631.png\"/></p>\n<p>解决这个问题就需要将key和value序列化，如果是xml配置的</p>\n<p>我们直接注入官方给定的keySerializer,valueSerializer,hashKeySerializer即可：</p>\n<pre><code class=\"hljs\">  &lt;bean id=\"redisTemplate\" class=\"org.springframework.data.redis.core.RedisTemplate\"&gt;\n\n        &lt;property name=\"keySerializer\" ref=\"stringRedisSerializer\"/&gt;\n        &lt;property name=\"valueSerializer\" ref=\"stringRedisSerializer\"/&gt;\n\n    &lt;/bean&gt;\n</code></pre>\n<p> 那么使用注解的话我们需要自己在自己编写的配置中将key、value进行转换</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\f471308de1a34fe8931a003672b7f4b3.png\"/></p>\n<pre><code class=\"hljs\">\nimport org.springframework.context.annotation.Bean;\n\nimport org.springframework.context.annotation.Configuration;\n\nimport org.springframework.data.redis.connection.RedisConnectionFactory;\n\nimport org.springframework.data.redis.core.RedisTemplate;\n\nimport org.springframework.data.redis.serializer.StringRedisSerializer;\n\n@Configuration\n\npublic class RedisConfig {\n\n    //参数RedisConnectionFactory为Spring Boot自动注入\n\n    @Bean\n\n    public RedisTemplate&lt;String,Object&gt; redisTemplate(RedisConnectionFactory factory){\n\n        RedisTemplate&lt;String,Object&gt; rt=new RedisTemplate&lt;String,Object&gt;();\n\n        rt.setConnectionFactory(factory);\n\n        //默认存储的是二进制  以下是转成String的\n\n        rt.setKeySerializer(new StringRedisSerializer());\n\n        rt.setValueSerializer(new StringRedisSerializer());\n\n        return rt;\n\n    }\n\n}\n</code></pre>\n<p style=\"text-align:center;\"> <img alt=\"\" src=\"image\\f5af70f57dc64c549d7f6ebb050bf633.png\"/></p>\n<p> </p>\n<p> </p>\n<p></p>\n</div>\n</div>"}