{"blogid": "126663745", "writerAge": "码龄6年", "writerBlogNum": "772", "writerCollect": "3194", "writerComment": "104", "writerFan": "1008", "writerGrade": "7级", "writerIntegral": "15014", "writerName": "wespten", "writerProfileAdress": "writer_image\\profile_126663745.jpg", "writerRankTotal": "734", "writerRankWeekly": "503", "writerThumb": "662", "writerVisitNum": "1139023", "blog_read_count": "262", "blog_time": "于 2022-09-02 15:34:17 发布", "blog_title": "Redis实现消息队列", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h2>一、消息队列</h2>\n<h3>1、什<strong>么是消息队列</strong></h3>\n<p>     消息队列（Message Queue）是一种应用间的通信方式，消息发送后可以立即返回，由消息系统来确保消息的可靠传递。消息发布者只管把消息发布到 MQ 中而不用管谁来取，消息使用者只管从 MQ 中取消息而不管是谁发布的。这样发布者和使用者都不用知道对方的存在。</p>\n<p>     这个其实跟设计模式中的观察者模式有点像，参考文章<a href=\"https://www.cnblogs.com/hld123/p/12980402.html\" title=\"《设计模式-观察者模式(observer)》\">《设计模式-观察者模式(observer)》</a>。被观察者可以称之为事件对象，有新的事件发布,会被观察者监听到。</p>\n<h3>2、消息队列的特点</h3>\n<p>1）三个角色：生产者、消费者、消息处理中心</p>\n<p>     把数据放到消息队列的叫做生产者</p>\n<p>     从消息队列里边取数据的叫做消费者</p>\n<p>     消息处理中心指的就是消息队列</p>\n<p>2）异步处理模式</p>\n<p>     生产者将消息发送到一条虚拟的通道（消息队列）上，而无须等待响应。消费者则订阅或是监听该通道，取出消息。两者互不干扰，甚至都不需要同时在线，也就是我们说的松耦合。</p>\n<p>3）可靠性</p>\n<p>     消息要可以保证不丢失、至少被消费一次、有时可能还需要顺序性的保证</p>\n<h3>3、为什么要使用消息队列</h3>\n<p>消息队列是分布式系统中重要的组件，使用消息队列主要是为了通过异步处理提高系统性能和流量削峰、降低系统耦合性。</p>\n<p>比如订单系统，与其关联的可能就有商品系统、库存系统、收件地址系统，用户系统、短信（邮件/微信）通知系统，日志记录系统等等。如果用户下单后，要把这些业务以同步的方式执行，那么调用链可能会很长，不利于高并发的处理。就需要把短信通知、日志记录这种与订单系统关联并不是那么紧密，实时性要求那么高的业务，放到消息队列中去异步实现。</p>\n<p>当然，还需要注意的是，比如商品秒杀，用户下单后，虽然某些业务可以通过投入消息队列，立即返回。仍需考虑实际情况，不能直接告诉用户秒杀成功，还需要消费者处理完消息后，通过异步回调通知服务器，判断处理成功后再通知用户，避免带来不必要的纠纷。</p>\n<h2>二、<strong>Redis实现消息队列方式</strong></h2>\n<p>Redis的设计是用来做缓存的，它是一个内存数据库，不过因为其某些特性适合用来充当队列(Redis的List数据结构比较适合做MQ)，所以也多被用于做简单的mq。它有几个阻塞式的API可以使用，正是这些阻塞式的API让他有做消息队列的能力。</p>\n<p>Redis实现消息队列有三种方式：List、发布订阅（pub/sub）、Stream。</p>\n<h3>1、<strong>生产消费模式 - List实现消息队列（PUSH/POP）</strong></h3>\n<p>生产消费模式会让一个或多个客户端监听消息队列，一旦消息到达，消费者马上消费，谁先抢到算谁的。如果队列中没有消息，消费者会继续监听。</p>\n<p><img alt=\"\" height=\"184\" src=\"image\\e6d4be25f03644e2989882d143b9cdb5.png\" width=\"543\"/></p>\n<p>Redis 的List（列表）是简单的字符串列表，按照插入顺序排序。可以在头部left和尾部right添加新的元素。List提供了push和pop命令，遵循着先入先出FIFO的原则。</p>\n<p><strong>1）LPUSH + RPOP或者 RPUSH+LPOP</strong></p>\n<p>LPUSH在头部（List的左边）添加一个新的元素并返回List长度，充当消息队列中的生产者。RPOP在尾部（List的右边）删除一个元素并返回该元素的值，充当消息队列中的消费者。</p>\n<p>基于List类型的插入删除元素操作实现，就是一个典型的先进先出队列的解决方案。</p>\n<p>优点：</p>\n<p>1）List类型是基于链表实现，插入删除元素时间复杂度仅为常量级，有先进先出（FIFO）的特点来保证数据的顺序</p>\n<p>2）Redis支持消息持久化，在服务端数据是安全的</p>\n<p>缺点：</p>\n<p>1）点对点的模式- Point-to-Point(P2P)</p>\n<p>因为 Redis 单线程的特点，所以在消费数据时，一条消息只能被一个消费者接收，消费者完全靠手速来获取，不支持分组消费，是一种比较简陋的消息队列。</p>\n<p>2）性能风险点</p>\n<p>第一点：消费者如果想要及时的处理数据，就要在程序中写个类似 while(true) 这样的逻辑，不停地去调用 RPOP 或 LPOP 命令，查看列表中是否有待处理的消息。这就会给消费者程序带来些不必要的性能损失。</p>\n<pre><code class=\"hljs\">while(true){\n   $result = $redis-&gt;lpop(\"queue\");\n   if($result){\n     $data = json_decode($result, true);\n   }\n }</code></pre>\n<p>第二点：如果队列空了，消费者会陷入pop死循环，即使没有数据也不会停止。空轮询不但消耗消费者的CPU资源还会增加Redis的访问压力，影响Redis的性能。</p>\n<p>3）没有数据权重的概念，只能先进先出</p>\n<p>4）客户端数据不安全</p>\n<p>消费确认机制（ACK）实现麻烦加之不能重复消费，一旦消费，数据就会删除，这意味着该元素只存在于客户端的上下文中，导致客户端数据是不安全的，当客户端宕机、网络断开会出现数据丢失，也不能实现广播模式。</p>\n<p><strong>2）LPUSH/BRPOP</strong></p>\n<p>此方案是在方案一上针对队列没有元素时造成服务器资源浪费进行的优化方案，使用了BRPOP做消费者，BRPOP是阻塞的。消费者可以设置数据不存在时的阻塞时间，来减少不必要的轮询。</p>\n<p>关于brpop/blpop有几点需要说明：</p>\n<p>BRPOP LIST1 LIST2 .. LISTN TIMEOUT</p>\n<p>第一点：使用brpop和blpop实现阻塞读取</p>\n<p>由于需要一直调用rpop/lpop才可以实现不停的监听且消费消息，为解决这个问题，Redis提供了阻塞命令brpop/blpop。使用brpop会阻塞队列，而且每次只会弹出一个消息，如果没有消息则会阻塞。</p>\n<p>第二点：减小Redis的压力</p>\n<p>生产者从列表左侧lpush加入消息到队列，消费者使用brpop命令从列表右侧弹出消息并设置超时(阻塞)时间，如果列表中没有消息则一直阻塞直到超时。当超时时间设置为0时刻,则无限等待，一直阻塞直到弹出消息。这样做的目的在于减小Redis的压力。</p>\n<p>第三点：注意异常的处理</p>\n<p>对于Redis来说提供了blpop/brpop阻塞读，阻塞读在队列没有数据时会立即进入休眠状态，一旦数据到来则立即被唤醒，消息的延迟几乎为零。需要注意的是如果线程一直阻塞在那里，连接就会被服务器主动断开来减少资源占用，这时blpop/brpop会抛出异常，所以编写消费端时需要注意异常的处理。</p>\n<p><strong>3）LPUSH+LRANGE+RPOP</strong></p>\n<p>此方案是在方案一上针对客户端数据安全进行的优化方案，使用LRANGE首先对队列元素只做读取不做消费，在客户端消费完成后，再使用RPOP对服务端进行消费。</p>\n<p>由于LRANGE不是阻塞的就又回到了方案二解决的资源浪费问题上了，无法减少不必要的轮询。</p>\n<p>还存在重复执行的问题，由于先读再消费，在消费者宕机重启后会再次读到没有确认消费的但是已经在消费者处理过的元素，就有了重复消费的风险。真的是绕啊。</p>\n<p><strong>4）LPUSH+BRPOPLPUSH+LREM</strong></p>\n<p>该方案也是对客户端数据安全进行的优化方案，是一种安全的队列，虽然也会存在重复消费的风险，但是元素队列的操作都是在服务端进行的，问题发生的概率会大大降低。</p>\n<p>说明：使用 RPOPLPUSH 获取消息时，RPOPLPUSH 会把消息返给客户端，同时把该消息放入一个备份消息列表，并且这个过程是原子的，可以保证消息的安全，当客户端成功的处理了消息后，就可以把此消息从备份列表中移除了。</p>\n<p>这个方案当然也不是完美的，还是存在客户端宕机的情况，正在处理中的队列存在长期不消费的消息怎么办？</p>\n<p>可以再添加一台客户端来监控长期不消费的消息，重新将消息打回待消费的队列，这个可以使用循环队列的模式来实现。</p>\n<p><strong>总结：</strong></p>\n<p>1）Redis中实现生产者和消费者模型，可使用LPUSH和RPOP来实现该功能。不过当列表为空时消费者就需要轮询来获取消息，这样会增加Redis的访问压力和消费者的CPU时间，另外很多访问也是无用的。为此Redis提供了阻塞式访问BRPOP和BLPOP命令。同时Redis会为所有阻塞的消费者以先后顺序排序。</p>\n<p>2）使用Redis的列表来实现一个任务队列，开启两个程序，一个作为生产者使用LPUSH写队列，一个作为消费者使用RPOP读队列。由于消费者并不知道什么时候会有消息过来，所以消费者需要一直循环读取数据。使用BRPOP改进后，消费者不会一直循环读取，而是一直阻塞直到等待超时或者有消息过来时才读取。</p>\n<h3>2、<strong>发布订阅模式（PUB/SUB）- 消息多播</strong></h3>\n<p>Redis 通过 PUBLISH 、 SUBSCRIBE 、PSUBSCRIBE 等命令实现了订阅与发布模式， 这个功能提供两种信息机制， 分别是订阅/发布到频道和订阅/发布到模式。</p>\n<p>发布订阅模式是一个或多个客户端订阅消息频道，只要发布者发布消息，所有订阅者都能收到消息，订阅者都是平等的。</p>\n<p>此模式中生产者producer和消费者consumer之间的关系是一对多的，也就是一条消息会被多个消费者所消费，当只有一个消费者时可视为一对一的消息队列。</p>\n<p>订阅：</p>\n<p><img alt=\"\" height=\"231\" src=\"image\\715774ba7f134e7ea7fdc7a46c50beda.png\" width=\"400\"/></p>\n<p> 发布：</p>\n<p><img alt=\"\" height=\"338\" src=\"image\\99add951852045dbb622c8fb489bb794.png\" width=\"402\"/> </p>\n<p><strong>1） 订阅/发布到频道</strong></p>\n<p><img alt=\"\" height=\"226\" src=\"image\\6088ff1891fb43eb86c77ff0acf7a833.png\" width=\"806\"/></p>\n<p><strong>2）订阅/发布到模式</strong></p>\n<p>可以理解为是一个类似正则匹配的 Key，只是个可以匹配给定模式的频道。这样就不需要显式地去订阅多个名称了，可以通过模式订阅这种方式，一次性关注多个频道。</p>\n<p><img alt=\"\" height=\"204\" src=\"image\\c73284f36a87446ea1a8bd99b749211e.png\" width=\"708\"/></p>\n<p>我们可以看到订阅的客户端每次可以收到一个 3 个参数的消息，分别为：消息的种类、始发频道的名称、实际的消息。 </p>\n<p><img alt=\"\" height=\"152\" src=\"image\\c0dec004cba646d196659efaa039b64c.png\" width=\"412\"/></p>\n<pre><code class=\"hljs\">127.0.0.1:6379&gt; psubscribe news.*\nReading messages... (press Ctrl-C to quit)\n1) \"psubscribe\"    # 返回值的类型：显示订阅成功\n2) \"news.*\"        # 订阅的模式\n3) (integer) 1     # 目前已订阅的模式的数量\n1) \"pmessage\"      # 返回值的类型：信息\n2) \"news.*\"        # 信息匹配的模式\n3) \"news.55\"       # 信息本身的目标频道\n4) \"php\"           # 信息的内容</code></pre>\n<p>发布订阅 (pub/sub) 的缺点：<strong> </strong>消息无法持久化，如果出现网络断开、Redis 宕机等，消息就会被丢弃。而且也没有 Ack 机制来保证数据的可靠性，假设一个消费者都没有，那消息就直接被丢弃了。 </p>\n<h3>3、<strong>Stream</strong></h3>\n<p>Redis 5.0 版本新增了一个更强大的数据结构—Stream。</p>\n<p>1） 它提供了消息的持久化和主备复制功能，可以让任何客户端访问任何时刻的数据，并且能记住每一个客户端的访问位置，还能保证消息不丢失。</p>\n<p>2） 它就像是个仅追加内容的消息链表，把所有加入的消息都串起来，每个消息都有一个唯一的 ID 和对应的内容。而且消息是持久化的。</p>\n<p>XADD key ID field value [field value ...]  - 添加消息到末尾</p>\n<p>XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] id [id ...]</p>\n<p><strong>1）独立消费</strong></p>\n<p><img alt=\"\" height=\"422\" src=\"image\\890fceb2a1404dcea272b34cbdec5b57.png\" width=\"504\"/></p>\n<p><strong>$</strong> 这个特殊的 ID 意思是 XREAD 应该使用流 mystream 已经存储的最大 ID 作为最后一个 ID。以便我们仅接收从我们开始监听时间以后的新消息。</p>\n<p><strong>2）分组消费</strong></p>\n<p>xread 虽然可以扇形分发到 N 个客户端，然而，在某些问题中，我们想要做的不是向许多客户端提供相同的消息流，而是从同一流向许多客户端提供不同的消息子集。比如下图这样，三个消费者按轮训的方式去消费一个Stream。</p>\n<p><img alt=\"\" height=\"391\" src=\"image\\d748e9204b704020aeb07cdcda7b9e64.png\" width=\"481\"/></p>\n<p><strong>1. Redis Stream 借鉴了很多 Kafka 的设计</strong></p>\n<p>Consumer Group：有了消费组的概念，每个消费组状态独立，互不影响，一个消费组可以有多个消费者</p>\n<p>last_delivered_id ：每个消费组会有个游标 last_delivered_id 在数组之上往前移动，表示当前消费组已经消费到哪条消息了</p>\n<p>pending_ids ：消费者的状态变量，作用是维护消费者的未确认的 id。pending_ids 记录了当前已经被客户端读取的消息，但是还没有 ack。如果客户端没有 ack，这个变量里面的消息 ID 会越来越多，一旦某个消息被 ack，它就开始减少。这个 pending_ids 变量在 Redis 官方被称之为 PEL，也就是 Pending Entries List，这是一个很核心的数据结构，它用来确保客户端至少消费了消息一次，而不会在网络传输的中途丢失了没处理。</p>\n<p><strong>2. 分区</strong></p>\n<p>Stream 不像 Kafka 那样有分区的概念，如果想实现类似分区的功能，就要在客户端使用一定的策略将消息写到不同的 Stream。</p>\n<p>xgroup create：创建消费者组</p>\n<p>xgreadgroup：读取消费组中的消息</p>\n<p>xack：ack 掉指定消息</p>\n<p><img alt=\"\" height=\"225\" src=\"image\\9dac5a403f324d648ae5c38287a41532.png\" width=\"786\"/></p>\n<p><strong>3）按消费组消费</strong></p>\n<p><strong>1. 创建消费组</strong></p>\n<pre><code class=\"hljs\">XGROUP [CREATE key groupname id-or-$] [SETID key groupname id-or-$] [DESTROY key groupname] [DELCONSUMER key groupname consumername]</code></pre>\n<p>说明：</p>\n<pre><code class=\"hljs\">key ：队列名称，如果不存在就创建\ngroupname ：组名。\n$ ： 表示从尾部开始消费，只接受新消息，当前 Stream 消息会全部忽略。</code></pre>\n<p><strong>2. 读取消费组中的消息</strong></p>\n<pre><code class=\"hljs\">XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] ID [ID ...]</code></pre>\n<p>例如：</p>\n<pre><code class=\"hljs\">XREADGROUP GROUP consumer-group-name consumer-name COUNT 1 STREAMS mystream &gt;</code></pre>\n<p>总结：</p>\n<p>1）Redis作为消息队列使用，redis支持的数据结构是可以支撑这类业务，主要是利用了list这种数据结构的特性。</p>\n<p>2）Redis的列表相当于编程语言里面的 LinkedList，是一个双向的列表结构，这意味着列表新增和删除元素是非常快的，时间复杂度为O(1)，但是查找一个元素的时候需要遍历列表，时间复杂度为O(n)。由于列表的元素操作和消息队列操作类似，所以redis可以适用于消息队列的场景，当然，在适用于的栈的场景下也可以胜任。</p>\n<p>3）需要提醒一下，生产环境中如果对消息的可靠性有十分高的要求（比如订单支付的消费消息），请使用专业的消息队列（例如：rmq，amq等），对消息的丢失有一定容忍度的程序完全可以使用redis，例如我们的日志收集程序。</p>\n<h2>三、Redis实现优先级消息队列</h2>\n<p>如果要实现任务队列，只需要让生产者将任务使用LPUSH命令加入到某个键中，另一边让消费者不断使用RPOP命令从该键中取出任务即可。</p>\n<p>首先我们先进行简单测试，分别打开两个redis-cli实例</p>\n<p>在第一个窗口中输入：</p>\n<pre><code class=\"hljs\">127.0.0.1:6379&gt; LPUSH queue:0 yayun\n(integer) 1\n127.0.0.1:6379&gt; </code></pre>\n<p>第二个窗口输入：</p>\n<pre><code class=\"hljs\">127.0.0.1:6379&gt; RPOP queue:0\n\"yayun\"\n127.0.0.1:6379&gt; LLEN queue:0\n(integer) 0\n127.0.0.1:6379&gt; </code></pre>\n<p>可以看见马上就取出值了，再次查询的时候发现已经没有记录了，说明已经消费掉了。简单明了的生产者，消费者。</p>\n<p>如果我们程序中使用RPOP命令，将导致队列中即使没有任务时，也会每秒都会调用RPOP命令，如果可以实现一旦有新任务加入就通知消费者，也就是我们的程序，那么将是最给力的，Redis都已经替我们想好了，我们可以使用BRPOP命令操作，BRPOP命令和RPOP命令相似，唯一的区别是当列表中没有元素时BRPOP命令会一直阻塞住连接，直到有新的任务加入。我们再次进行简单测试。</p>\n<p>BRPOP命令接收两个参数，第一个是键名，第二个是超时时间，单位是秒。当超过了此时间没有获得性元素的话返回nil。如果设置为0，表示不限制等待时间，即如果没有新元素加入列表就会永远阻塞下去。</p>\n<p>第一个窗口中输入（没有任务一直阻塞）：</p>\n<pre><code class=\"hljs\">127.0.0.1:6379&gt; BRPOP queue:0 0</code></pre>\n<p>第二个窗口中输入：</p>\n<pre><code class=\"hljs\">127.0.0.1:6379&gt; LPUSH queue:0 yayun\n(integer) 1\n127.0.0.1:6379&gt; </code></pre>\n<p>当我们加入任务时，发现第一个窗口的输入如下：</p>\n<pre><code class=\"hljs\">127.0.0.1:6379&gt; BRPOP queue:0 0\n1) \"queue:0\"\n2) \"yayun\"\n(66.19s)\n127.0.0.1:6379&gt; </code></pre>\n<p>可以发现当加入任务时马上消费掉了，元素已经被取走。</p>\n<p>下面说说如何实现优先级消息队列，最后结合python来一段简单代码演示一下。BRPOP命令可以同时接收多个键，起完整的命令格式为BRPOP key [ key ... ] timeout，例如BRPOP queue:0 queue:1 0。意思是同时检测多个键，如果所有键都没有元素则一直阻塞，如果其中有一个键有元素会从该键中弹出元素。如果多个键都有元素则按照从左到右的顺序取第一个键中的一个元素。下面进行简单的测试。打开两个实例：</p>\n<p>第一个窗口中：</p>\n<pre><code class=\"hljs\">127.0.0.1:6379&gt; LPUSH queue:0 yayun\n(integer) 1\n127.0.0.1:6379&gt; LPUSH queue:1 dengyayun\n(integer) 1\n127.0.0.1:6379&gt; </code></pre>\n<p>第二个窗口中：</p>\n<pre><code class=\"hljs\">127.0.0.1:6379&gt; LPUSH queue:0 yayun\n(integer) 1\n127.0.0.1:6379&gt; BRPOP queue:0 queue:1 0\n1) \"queue:0\"\n2) \"yayun\"\n127.0.0.1:6379&gt; BRPOP queue:0 queue:1 0\n1) \"queue:1\"\n2) \"dengyayun\"\n127.0.0.1:6379&gt; </code></pre>\n<p>从上面我们可以发现queue:0任务先执行了。好了，说了这么多了相信大家都测试体会到了，下面来一段简单的python脚本进行测试。python操作redis需要安装模块。</p>\n<p>从<a href=\"https://codeload.github.com/andymccurdy/redis-py/zip/master\" title=\"https://github.com/andymccurdy/redis-py\">https://github.com/andymccurdy/redis-py</a>下载redis-py-master.zip安装，解压后进入到目录执行python setup.py install即可安装完成。</p>\n<p>关于相关操作说明这里说的非常清楚<a href=\"https://pypi.python.org/pypi/redis/\" title=\"redis · PyPI\">redis · PyPI</a>以及解压后目录里的README.rst文件，可以进行阅读。</p>\n<p>生产着脚本如下：</p>\n<pre><code class=\"hljs\">#!/usr/bin/python\n\nimport redis\n\ndef producers():\n    for i in xrange(1000000):\n        str='low_task_queue %d' % i\n        pool = redis.ConnectionPool(host='localhost', port=6379, db=0)\n        r = redis.Redis(connection_pool=pool)\n        r.lpush('low_task_queue',str)\n\nif __name__ == \"__main__\":\n    producers()</code></pre>\n<p>消费者脚本如下：</p>\n<pre><code class=\"hljs\">#!/usr/bin/python\n\nimport redis, time\n\ndef handle(task):\n    print task\n    time.sleep(1)\n\ndef consumer():\n    pool = redis.ConnectionPool(host='localhost', port=6379, db=0)\n    r = redis.Redis(connection_pool=pool)\n    while 1:\n        result = r.brpop(['high_task_queue', 'low_task_queue'], 0)\n        handle(result[1])\n\nif __name__ == \"__main__\":\n    consumer()</code></pre>\n<p>打开2个窗口，分别执行两个脚本，然后打开第3个窗口手动添加元素，模拟优先级队列。</p>\n<p>可以看见在处理队列了，我这里停顿了1秒才处理，是为了观看效果。</p>\n<pre><code class=\"hljs\">[root@mysql-server-03 ~]# python consumer.py \nlow_task_queue 0\nlow_task_queue 1\nlow_task_queue 2\nlow_task_queue 3\nlow_task_queue 4\nlow_task_queue 5\nlow_task_queue 6\nlow_task_queue 7\nlow_task_queue 8\nlow_task_queue 9\nlow_task_queue 10\nlow_task_queue 11\nlow_task_queue 12\nlow_task_queue 13\nlow_task_queue 14</code></pre>\n<p>打开窗口手动插入元素：</p>\n<pre><code class=\"hljs\">127.0.0.1:6379&gt; LPUSH high_task_queue 'high_task_queue 9999999'\n(integer) 1\n127.0.0.1:6379&gt; </code></pre>\n<p>可以看见优先级队列已经处理：</p>\n<pre><code class=\"hljs\">low_task_queue 213\nlow_task_queue 214\nlow_task_queue 215\nlow_task_queue 216\nlow_task_queue 217\nlow_task_queue 218\nlow_task_queue 219\nlow_task_queue 220\nlow_task_queue 221\nlow_task_queue 222\nlow_task_queue 223\nlow_task_queue 224\nhigh_task_queue 9999999\nlow_task_queue 225\nlow_task_queue 226\nlow_task_queue 227\nlow_task_queue 228</code></pre>\n</div>\n</div>"}