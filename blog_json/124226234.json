{"blogid": "124226234", "writerAge": "码龄8年", "writerBlogNum": "4", "writerCollect": "17", "writerComment": "2", "writerFan": "2", "writerGrade": "1级", "writerIntegral": "55", "writerName": "herees", "writerProfileAdress": "writer_image\\profile_124226234.jpg", "writerRankTotal": "133344", "writerRankWeekly": "110554", "writerThumb": "2", "writerVisitNum": "7911", "blog_read_count": "6138", "blog_time": "于 2022-04-17 11:22:32 发布", "blog_title": "C# 使用MQTTnet实现MQTT通信", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p>   MQTT是机器对机器(M2M)/物联网(IoT)连接协议。它被设计为一个极其轻量级的发布/订阅消息传输协议。对于需要较小代码占用空间和/或网络带宽非常宝贵的远程连接非常有用，是专为受限设备和低带宽、高延迟或不可靠的网络而设计。这些原则也使该协议成为新兴的“机器到机器”(M2M)或物联网(IoT)世界的连接设备，以及带宽和电池功率非常高的移动应用的理想选择。例如，它已被用于通过卫星链路与代理通信的传感器、与医疗服务提供者的拨号连接，以及一系列家庭自动化和小型设备场景。它也是移动应用的理想选择，因为它体积小，功耗低，数据包最小，并且可以有效地将信息分配给一个或多个接收器</p>\n<h2><a id=\"_2\"></a>特点</h2>\n<ul><li>开放消息协议，简单易实现</li><li>发布订阅模式，一对多消息发布</li><li>基于TCP/IP网络连接,提供有序，无损，双向连接。</li><li>1字节固定报头，2字节心跳报文，最小化传输开销和协议交换，有效减少网络流量。</li><li>消息QoS支持，可靠传输保证</li></ul>\n<h2><a id=\"_8\"></a>应用</h2>\n<p>MQTT协议广泛应用于物联网、移动互联网、智能硬件、车联网、电力能源等领域。</p>\n<ul><li>物联网M2M通信，物联网大数据采集</li><li>Android消息推送，WEB消息推送</li><li>移动即时消息，例如Facebook Messenger</li><li>智能硬件、智能家具、智能电器</li><li>车联网通信，电动车站桩采集</li><li>智慧城市、远程医疗、远程教育</li><li>电力、石油与能源等行业市场</li></ul>\n<h2><a id=\"C_17\"></a>C#程序实现</h2>\n<h3><a id=\"MQTnet_18\"></a>MQTnet库</h3>\n<p>MQTTnet 是一个用于基于 MQTT 的通信的高性能 .NET 库。它提供 MQTT 客户机和 MQTT 服务器（代理），并支持版本 5 之前的 MQTT 协议。</p>\n<h3><a id=\"_20\"></a>常规</h3>\n<ul><li>异步支持</li><li>客户端和服务器（但不是 UWP 服务器）的 TLS 支持</li><li>可扩展的通信通道（例如内存中、TCP、TCP+TLS、WS）</li><li>轻量级（只有MQTT的低级实现，没有开销）</li><li>性能优化（每秒处理约 150，000 条消息）*</li><li>跨所有受支持的 MQTT 协议版本的统一 API</li><li>访问内部跟踪消息</li><li>单元测试（约 636 次测试）</li><li>无外部依赖关系<br/> 在本地机器（英特尔 i7 8700K）上测试，MQTTnet 客户端和服务器使用 TCP 通道在同一进程中运行。用于验证的应用程序是此存储库的一部分，并存储在/Tests/MQTTnet.TestApp.NetCore中。</li></ul>\n<h3><a id=\"_32\"></a>客户</h3>\n<ul><li>支持通过 TCP （+TLS） 或 WS （WebSocket） 进行通信</li><li>包含内核低级别MqttClient，具有低级别功能</li><li>还包括 ManagedMqttClient，它会自动维护连接和订阅。此外，应用程序消息会自动排队并重新安排为更高的 QoS 级别。</li><li>Rx 支持（通过另一个项目）</li><li>与 Microsoft Azure IoT Hub 兼容</li></ul>\n<h3><a id=\"_38\"></a>服务器（代理）</h3>\n<ul><li>可用连接的客户端列表</li><li>支持同时使用不同协议版本的连接客户端</li><li>能够发布自己的消息（无需环回客户端）</li><li>能够接收每条消息（无需环回客户端）</li><li>可扩展的客户端凭据验证</li><li>支持保留的消息，包括通过接口方法持久保存（需要自己的实现）</li><li>支持 WebSockets（通过 ASP.NET Core 2.0，单独的 nuget）</li><li>可以添加自定义消息拦截器，允许转换或扩展每个收到的应用程序消息</li><li>验证订阅并拒绝订阅某些主题，具体取决于请求客户端</li><li>同时连接具有不同协议版本的客户端。</li></ul>\n<h3><a id=\"_49\"></a>支持的框架</h3>\n<table><thead><tr><th>框架</th><th>版本</th></tr></thead><tbody><tr><td>.NET</td><td>5.0+</td></tr><tr><td>.NET Framework</td><td>4.5.2+</td></tr><tr><td>.NET 标准</td><td>1.3+</td></tr><tr><td>.NET Core</td><td>1.1+</td></tr><tr><td>.NET Core App</td><td>1.1+</td></tr><tr><td>单</td><td>5.2+</td></tr><tr><td>断续器</td><td>10.0.10240+</td></tr><tr><td>Xamarin.Android</td><td>7.5+</td></tr><tr><td>Xamarin.iOS</td><td>10.14+</td></tr><tr><td>Blazor WebAssembly</td><td>3.2.0+</td></tr></tbody></table>\n<h3><a id=\"_62\"></a>服务端代码实现</h3>\n<pre><code class=\"prism language-c#\"> public static async void MqttServer()\n        {\n            var optionBuilder = new MqttServerOptionsBuilder()\n                .WithDefaultEndpointBoundIPAddress(IPAddress.Parse(\"192.168.0.2\"))\n                .WithDefaultEndpointPort(1883)\n                .WithConnectionBacklog(1000)\n                .WithConnectionValidator(c =&gt;\n                {\n                    if (c.ClientId.Length &lt; 10)\n                    {\n                        c.ReasonCode = MqttConnectReasonCode.ClientIdentifierNotValid;\n                        return;\n                    }\n\n                    if (c.Username != \"admin\") //用户名\n                    {\n                        c.ReasonCode = MqttConnectReasonCode.BadUserNameOrPassword;\n                        return;\n                    }\n\n                    if (c.Password != \"public\") //密码\n                    {\n\n                        c.ReasonCode = MqttConnectReasonCode.BadUserNameOrPassword;\n                        return;\n                    }\n\n                    Console.WriteLine($\"{c.ClientId}连接成功！\");\n                    c.ReasonCode = MqttConnectReasonCode.Success;\n                }).Build();\n            _mqttServer = new MqttFactory().CreateMqttServer();\n\n            //客户端接入\n            _mqttServer.UseClientConnectedHandler(ClientConnected);\n\n            //客户端断开\n            _mqttServer.UseClientDisconnectedHandler(ClientDisconnected);\n\n            //主题消息\n            _mqttServer.UseApplicationMessageReceivedHandler(ApplicationMessageReceived);\n\n            //主题订阅需要实现IMqttServerClientSubscribedTopicHandler\n            _mqttServer.ClientSubscribedTopicHandler =new ClientSubscribedTopic();\n\n            //启动监听需要实现IMqttServerStartedHandler\n            _mqttServer.StartedHandler = new ServerStarteOrStopped();\n            //停止监听 IMqttServerStoppedHandler\n            _mqttServer.StoppedHandler = new ServerStarteOrStopped();\n            //服务启动\n            await _mqttServer.StartAsync(optionBuilder);\n        }\n</code></pre>\n<h3><a id=\"_116\"></a>客户端代码实现</h3>\n<pre><code class=\"prism language-c#\">public static async  void Client()\n        {\n            var options = new MqttClientOptions();\n\n            options.ClientId = Guid.NewGuid().ToString().Replace(\"-\", \"\").ToUpper();\n\n            //设置服务器地址与端口\n            options.ChannelOptions = new MqttClientTcpOptions()\n            {\n\n                Server = \"192.168.0.2\",\n                Port = 1883\n            };\n            //设置账号与密码\n            options.Credentials = new MqttClientCredentials()\n            {\n                Username = \"admin\",\n                Password = Encoding.Default.GetBytes(\"public\")\n            };\n            options.CleanSession = true;\n\n            //保持期\n            options.KeepAlivePeriod = TimeSpan.FromSeconds(100.5);\n\n            //构建客户端对象\n            _mqttClient = new MqttFactory().CreateMqttClient() as MqttClient;\n\n            try\n            {\n                //绑定消息接收方法\n                _mqttClient.UseApplicationMessageReceivedHandler(ApplicationMessageReceivedHandler);\n\n                //绑定连接成功状态接收方法\n                _mqttClient.UseConnectedHandler(ConnectedHandler);\n\n                //绑定连接断开状态接收方法\n                _mqttClient.UseDisconnectedHandler(DisconnectedHandler);\n\n                //启动连接\n                await _mqttClient.ConnectAsync(options);\n\n                //订阅消息\n                await _mqttClient.SubscribeAsync(\n                    new MqttTopicFilter[] { //订阅消息集合\n                        new MqttTopicFilter() //订阅消息对象\n                        { \n                            Topic = \"123\",  //订阅消息主题\n                            QualityOfServiceLevel = MqttQualityOfServiceLevel.AtLeastOnce  //消息类型\n                        }\n                    });\n            }\n            catch\n            {\n                Console.WriteLine($\"连接失败\");\n            }\n        }\n</code></pre>\n<p>Demo下载地址：<a href=\"https://download.csdn.net/download/herees/85160530\">https://download.csdn.net/download/herees/85160530</a></p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}