{"blogid": "126325856", "writerAge": "码龄2年", "writerBlogNum": "57", "writerCollect": "1162", "writerComment": "2161", "writerFan": "3567", "writerGrade": "6级", "writerIntegral": "8380", "writerName": "哎呀是小张啊", "writerProfileAdress": "writer_image\\profile_126325856.jpg", "writerRankTotal": "1745", "writerRankWeekly": "177", "writerThumb": "2507", "writerVisitNum": "89518", "blog_read_count": "697", "blog_time": "于 2022-08-16 00:00:00 发布", "blog_title": "【JavaEE初阶】多线程 _ 基础篇 _ 线程安全问题（下篇）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>☕导航小助手☕</strong></p>\n<p id=\"%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2-toc\" style=\"margin-left:0px;\"><strong>    🍚</strong><a href=\"#%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2\">写在前面</a></p>\n<p id=\"%E4%B8%80%E3%80%81%E5%86%85%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7-toc\" style=\"margin-left:0px;\"><strong>         🧇</strong><a href=\"#%E4%B8%80%E3%80%81%E5%86%85%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7\">一、内存可见性</a></p>\n<p id=\"%E4%BA%8C%E3%80%81%E5%86%85%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%20%E2%80%94%E2%80%94%20volatile%E5%85%B3%E9%94%AE%E5%AD%97-toc\" style=\"margin-left:0px;\"><strong>         🧀</strong><a href=\"#%E4%BA%8C%E3%80%81%E5%86%85%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%20%E2%80%94%E2%80%94%20volatile%E5%85%B3%E9%94%AE%E5%AD%97\">二、内存可见性的解决办法 —— volatile关键字</a></p>\n<p id=\"%E4%B8%89%E3%80%81wait%20%E5%92%8C%20notify%20%E5%85%B3%E9%94%AE%E5%AD%97-toc\" style=\"margin-left:0px;\"><strong>         🍔</strong><a href=\"#%E4%B8%89%E3%80%81wait%20%E5%92%8C%20notify%20%E5%85%B3%E9%94%AE%E5%AD%97\">三、wait 和 notify 关键字</a></p>\n<p id=\"3.1%20wait()%20%E6%96%B9%E6%B3%95-toc\" style=\"margin-left:0px;\"><strong>                   🥩🥩</strong><a href=\"#3.1%20wait%28%29%20%E6%96%B9%E6%B3%95\">3.1 wait() 方法</a></p>\n<p id=\"3.2%20notify()%20%E6%96%B9%E6%B3%95-toc\" style=\"margin-left:0px;\"><strong>                   🦪🦪</strong><a href=\"#3.2%20notify%28%29%20%E6%96%B9%E6%B3%95\">3.2 notify() 方法</a></p>\n<p id=\"3.3%20notifyAll()%20%E6%96%B9%E6%B3%95-toc\" style=\"margin-left:0px;\"><strong>                   🍣🍣</strong><a href=\"#3.3%20notifyAll%28%29%20%E6%96%B9%E6%B3%95\">3.3 notifyAll() 方法</a></p>\n<p id=\"3.4%20wait%20%E5%92%8C%20sleep%20%E7%9A%84%E5%AF%B9%E6%AF%94-toc\" style=\"margin-left:0px;\"><strong>                   🍤🍤</strong><a href=\"#3.4%20wait%20%E5%92%8C%20sleep%20%E7%9A%84%E5%AF%B9%E6%AF%94\">3.4 wait 和 sleep 的对比</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h1 id=\"%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2\">写在前面</h1>\n<p>在上一篇博客中，已经介绍了 线程安全问题的部分内容，我们知道了 线程安全问题 是什么，也知道了线程安全问题出现的五种原因（当然，这五种原因 只是一些典型的情况，并不能说明 线程不安全只是这五种情况造成的），并且还知道 怎样去解决 由于不是原子的操作 而引发的线程安全问题（加锁 是解决 线程的某些修改操作 不是原子性的办法）~</p>\n<p>那么，接下来将介绍剩下的内容 ......</p>\n<p><img alt=\"\" height=\"58\" src=\"image\\0ad794973ab445439eefdbb54815cf15.png\" width=\"1146\"/> </p>\n<p></p>\n<h1 id=\"%E4%B8%80%E3%80%81%E5%86%85%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7\">一、内存可见性</h1>\n<p>现在，就来介绍一下 怎样解决 由于内存可见性而引发的 线程安全问题~</p>\n<p>内存可见性 所存在的场景 是：一个线程读、一个线程写的场景~</p>\n<pre><code>package thread;\n\nimport java.util.Scanner;\n\npublic class Demo16 {\n    //写一个 内部类，此时这个内部类 就处在 Demo16 的内部，就可以解决 前面已经写过 Counter 的问题\n    static class Counter {\n        public int flg = 0;\n    }\n\n    public static void main(String[] args) {\n        Counter counter = new Counter();\n        \n        Thread t1 = new Thread(() -&gt; {\n            while (counter.flg == 0) {\n                //执行循环，但是此处循环 啥都不做\n            }\n            System.out.println(\"t1循环结束\");\n        });\n        t1.start();\n        \n        Thread t2 = new Thread(() -&gt; {\n            //让用户输入一个数字，赋值给 flg\n            Scanner scanner = new Scanner(System.in);\n            System.out.println(\"请输入一个整数：\");\n            counter.flg = scanner.nextInt();\n        });\n        t2.start();\n    }\n}</code></pre>\n<blockquote>\n<p>预期效果：</p>\n<p>t2线程 输入一个非零的整数后，此时 t1线程 循环结束，随之进程结束~</p>\n</blockquote>\n<blockquote>\n<p>运行结果： </p>\n<p><img alt=\"\" height=\"378\" src=\"image\\bc30f44a151841e19cc761884b5a1e85.png\" width=\"851\"/></p>\n</blockquote>\n<p><strong>这，就是内存可见性的问题~</strong></p>\n<hr/>\n<blockquote>\n<p>分析：</p>\n<p>t1线程 的工作：</p>\n<ol><li>load 读取内存的数据到 CPU 的寄存器</li><li>test 检测 CPU寄存器的值是否和预期的一样</li></ol>\n<p>同时，反复进行，频繁进行~</p>\n<p>由于 读内存比读 CPU寄存器 慢上几千倍、上万倍，意味着 t1线程 的主要操作就在 load上，但是 每一次读取到的值又没有啥变化，于是 直接进行了优化，就相当于 只从内存中只读取一次数据，后续就直接从寄存器里面 进行反复 test 就好了~</p>\n<p>编译器看到这个线程（t1线程）对变量 flg 也没有做修改，于是就进行了优化操作~</p>\n<p>但是，这里出现了一个特殊情况，有其他的线程（t2线程）对这个变量做出了修改~</p>\n<p>但是，t1线程 仍然是 采用之前的数据来读寄存器，此时 读到的数据和内存的数据是不一致的，这种情况就叫做 <strong>内存可见性问题</strong>（即 内存改了，但是线程没有看见；或者说，没有及时读取到内存中的最新数据）~</p>\n</blockquote>\n<p><img alt=\"\" height=\"58\" src=\"image\\0ad794973ab445439eefdbb54815cf15.png\" width=\"1146\"/></p>\n<p> </p>\n<h1 id=\"%E4%BA%8C%E3%80%81%E5%86%85%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%20%E2%80%94%E2%80%94%20volatile%E5%85%B3%E9%94%AE%E5%AD%97\">二、内存可见性的解决办法 —— volatile关键字</h1>\n<p>由于 编译器优化，是属于编译器自带的功能，正常来说，程序员并不好干预~</p>\n<p>但是 因为上述的场景，编译器知道自己可能会出现误判，因此就给程序猿提供了一个 干预优化的途径 —— <span style=\"color:#be191c;\"><strong><span style=\"background-color:#fbd4d0;\">volatile</span></strong></span>关键字~</p>\n<p>这个关键字是写到要修改的变量上，要保证哪个变量的内存可见性 就往哪个变量里面加~</p>\n<p><img alt=\"\" height=\"172\" src=\"image\\aa91def11b0e4fb39a1d42ad8456c527.png\" width=\"996\"/></p>\n<p><img alt=\"\" height=\"190\" src=\"image\\6af3a4cbc466437c86fe2081fa7697ec.png\" width=\"1039\"/></p>\n<blockquote>\n<p>注意 volatile 可以修饰变量的位置，也是在 public 左右~ </p>\n</blockquote>\n<p>此时，运行结果：</p>\n<p><img alt=\"\" height=\"301\" src=\"image\\2dc13493ca3f4b8bb8749661950afdb9.png\" width=\"762\"/></p>\n<blockquote>\n<p><strong><span style=\"background-color:#fbd4d0;\"><span style=\"color:#be191c;\">volatile</span></span><span style=\"color:#be191c;\"> </span></strong>操作 相当于是 显示得禁止了编译器进行上述优化，相当于是给这个对应的变量加上了 \"内存屏障\"（特殊的二进制指令），JVM 再读取这个变量的时候，因为内存屏障的存在，就知道每次都要重新读取这个变量的内容，而不是草率的进行优化了~</p>\n<p>虽然频繁的读取内存，使得速度变慢了，但是数据却是算的对了~</p>\n</blockquote>\n<hr/>\n<p>当然，编译器的优化，是根据代码的实际情况来运行的，在一开始的代码中，由于 循环体是空，所以循环的转速极快，导致了 读内存的操作非常频繁，所以就出发了优化~</p>\n<p>但是，如果在<strong>循环体中加上 sleep</strong>，让循环转速一下子就慢了，读取内存的操作 就不是特别频繁了，就不会被触发优化了~</p>\n<pre><code>package thread;\n\nimport java.util.Scanner;\n\npublic class Demo16 {\n    //写一个 内部类，此时这个内部类 就处在 Demo16 的内部，就可以解决 前面已经写过 Counter 的问题\n    static class Counter {\n        public int flg = 0;\n    }\n\n    public static void main(String[] args) {\n        Counter counter = new Counter();\n\n        Thread t1 = new Thread(() -&gt; {\n            while (counter.flg == 0) {\n                //执行循环，此处加上 sleep 操作\n                try {\n                    Thread.sleep(100);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            System.out.println(\"t1循环结束\");\n        });\n        t1.start();\n\n        Thread t2 = new Thread(() -&gt; {\n            //让用户输入一个数字，赋值给 flg\n            Scanner scanner = new Scanner(System.in);\n            System.out.println(\"请输入一个整数:\");\n            counter.flg = scanner.nextInt();\n        });\n        t2.start();\n    }\n}</code></pre>\n<p>运行结果：</p>\n<p><img alt=\"\" height=\"372\" src=\"image\\0e6163c6b8fe46778ed0678775e806fd.png\" width=\"790\"/></p>\n<p>所以说，编译器到底什么时候会优化，仍然是一个 \"玄学\"问题，它内部有一个完整的优化体系，但是也不关咱们啥事~</p>\n<p>由于咱们也不好确定 什么时候优化，什么时候不优化，所以还得要在必要的时候加上 volatile~</p>\n<hr/>\n<p><strong>注意：</strong></p>\n<ol><li>volatile关键字 保证的是 内存可见性 的问题，它不保证原子性的问题~</li><li>volatile 解决的是 一个线程读、一个线程写 的问题~</li><li>当然，volatile 也可以解决指令重排序的问题~</li><li>synchronized 保证的是 原子性的问题，解决的是 两个线程写 的问题~</li></ol>\n<p><img alt=\"\" height=\"58\" src=\"image\\0ad794973ab445439eefdbb54815cf15.png\" width=\"1146\"/></p>\n<p></p>\n<h1 id=\"%E4%B8%89%E3%80%81wait%20%E5%92%8C%20notify%20%E5%85%B3%E9%94%AE%E5%AD%97\">三、wait 和 notify 关键字</h1>\n<p>前面已经介绍到，线程它是随机调度的，这个随机性很讨厌，我们希望可以控制线程的执行顺序~</p>\n<p>我们可以用 join关键字 来控制 线程结束 的顺序了~</p>\n<p>但是，我们仍希望 让两个线程按照既定的顺序配合执行~</p>\n<p>wait 和 notify 关键字就可以做到这个效果，相比于 jion，它们可以更好的控制线程之间的执行顺序~</p>\n<hr/>\n<p>wait 叫做 \"等待\"，调用 wait 的线程，就会进入线程阻塞等待的状态（即 Waiting状态）~</p>\n<p>notify 叫做 \"通知 / 唤醒\"，调用 notify 的线程，就可以把<span style=\"color:#956fe7;\"><strong>对应的 wait 线程</strong></span>给唤醒（即 从阻塞状态恢复回就绪状态）~</p>\n<blockquote>\n<p>wait 和 notify 都是 Object 的成员方法（随便哪个对象都可以调用）~</p>\n<p>比如说：</p>\n<p>如果有 o1.wait();</p>\n<p>那么 o1.notify()就可以唤醒调用 o1.wait() 的线程，而 o2.notify() 是不能够唤醒调用 o1.wait() 的线程的~ </p>\n</blockquote>\n<hr/>\n<p></p>\n<h1 id=\"3.1%20wait()%20%E6%96%B9%E6%B3%95\">3.1 wait() 方法</h1>\n<p>wait() 内部的执行过程：</p>\n<ol><li>释放锁</li><li>等待通知</li><li>当通知到达后，就会被唤醒，并且尝试重新获取锁</li></ol>\n<blockquote>\n<p>wait() 一上来就要释放锁，这就说明 在调用 wait 之前，就需要先拿到锁；</p>\n<p>换句话说，wait 必须要放到 synchronized 中使用，并且 synchronized 加锁的对象 和 调用 wait 方法的对象 是同一个对象~</p>\n<p></p>\n</blockquote>\n<p><img alt=\"\" height=\"1034\" src=\"image\\0533cec7974a44dea7193e8833a29bb1.png\" width=\"1200\"/></p>\n<p><img alt=\"\" height=\"1034\" src=\"image\\344db657dee740e79435c5f92483e380.png\" width=\"1200\"/></p>\n<p>此时，使用 <span style=\"color:#be191c;\"><strong><span style=\"background-color:#fbd4d0;\">object.wait()</span></strong></span> 之后就会一直等待下去，但是程序肯定不会这么一直等待下去了，所以这个时候就需要一个唤醒的方法 —— <span style=\"color:#be191c;\"><strong><span style=\"background-color:#fbd4d0;\">notify()</span></strong></span> ~</p>\n<p><img alt=\"\" height=\"58\" src=\"image\\0ad794973ab445439eefdbb54815cf15.png\" width=\"1146\"/></p>\n<p></p>\n<h1 id=\"3.2%20notify()%20%E6%96%B9%E6%B3%95\">3.2 notify() 方法</h1>\n<p>notify() 内部执行的过程：进行通知~ </p>\n<pre><code>package thread;\n\nimport java.util.Scanner;\n\n//创建两个线程，一个线程调用 wait，一个线程调用 notify\npublic class Demo18 {\n    //这个对象用来作为锁对象\n    public static Object locker = new Object();\n\n    public static void main(String[] args) {\n        Thread waitTask = new Thread(() -&gt; {\n            synchronized (locker) {\n                System.out.println(\"wait 开始\");\n                try {\n                    locker.wait();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(\"wait 结束\");\n            }\n        });\n        waitTask.start();\n\n        //创建一个用来 通知/唤醒 的线程\n        Thread notifyTask = new Thread(() -&gt; {\n            //让用户来控制，用户输入内容后，再执行通知~\n            Scanner scanner = new Scanner(System.in);\n            System.out.println(\"输入任意内容，开始通知：\");\n            //next 会阻塞，直到用户真正输入内容以后\n            scanner.next();\n\n            synchronized (locker) {\n                System.out.println(\"notify 开始\");\n                locker.notify();\n                System.out.println(\"notify 结束\");\n            }\n        });\n        notifyTask.start();\n    }\n}\n\n\n</code></pre>\n<p>运行结果：</p>\n<p><img alt=\"\" height=\"391\" src=\"image\\e32eed9edb0a403ba29e551975a0e077.png\" width=\"742\"/></p>\n<hr/>\n<p>当然，wait 和 notify 机制，还能够有效避免 \"线程饿死\"~</p>\n<blockquote>\n<p>线程饿死：有些情况下，调度器可能分配的不均匀，导致 有些线程反复占用 CPU，有些线程始终捞不着 CPU...... </p>\n</blockquote>\n<p>线程 在拿到锁之后，判定当下的任务是否可以进行~</p>\n<p>如果 可以进行，那么就干活；如果不可以进行，那么就 wait~</p>\n<p>等到合适的时候（条件满足的时候）就再继续执行（notify） / 再继续参与竞争锁~ </p>\n<hr/>\n<p>注意：</p>\n<ol><li>notify 在调用的时候，会尝试唤醒进行通知，如果当前对象没有在其他线程里 wait，则不会有副作用~</li><li>如果 wait 是一个对象，notify 是另一个对象，则没啥用，无法被唤醒~</li></ol>\n<p><img alt=\"\" height=\"58\" src=\"image\\0ad794973ab445439eefdbb54815cf15.png\" width=\"1146\"/></p>\n<p></p>\n<h1 id=\"3.3%20notifyAll()%20%E6%96%B9%E6%B3%95\">3.3 notifyAll() 方法</h1>\n<p>当然，在 Java 中，还有一个唤醒线程的方法 —— notifyAll() 方法~</p>\n<p>当有多个线程等待的时候，notify 是从若干个线程里面随机挑选一个唤醒，是一次唤醒一个；而 notifyAll 则是直接唤醒所有线程，再有这些线程去竞争锁~</p>\n<blockquote>\n<p><strong>举个例子理解 notify 和 notifyAll 的区别：</strong></p>\n<p>notify 只是唤醒等待队列中的一个线程，其他的线程还是 需要乖乖的等着，如：</p>\n<p><img alt=\"\" height=\"329\" src=\"image\\10bf5d5827e443b2824b8f7a0f3d205b.png\" width=\"948\"/>而 notifyAll 则是一下子将这些线程全部唤醒，这些进程则需要重新竞争锁，如：</p>\n<p><img alt=\"\" height=\"452\" src=\"image\\de630ffa24744d119fce0767fb822300.png\" width=\"897\"/></p>\n</blockquote>\n<p>由于 最终的结果 notifyAll 还是只能进去一个线程，并且 其他的线程还可能出现 \"线程饿死\" 的情况，所以说 一般的还是 notifyAll 用的比较少~</p>\n<p><img alt=\"\" height=\"58\" src=\"image\\0ad794973ab445439eefdbb54815cf15.png\" width=\"1146\"/></p>\n<p></p>\n<h1 id=\"3.4%20wait%20%E5%92%8C%20sleep%20%E7%9A%84%E5%AF%B9%E6%AF%94\">3.4 wait 和 sleep 的对比</h1>\n<p>都会让线程进入阻塞~</p>\n<p>阻塞的原因和目的不同，进入的状态也不同，被唤醒的条件也不同~</p>\n<p>wait 是用来控制线程之间的执行先后顺序，而 sleep 在实际开发中实际很少会用到（等待的时间太固定了，如果有突发情况 想提前唤醒并不是那么容易）~</p>\n<p>wait 进入的是 <span style=\"color:#be191c;\"><strong><span style=\"background-color:#fbd4d0;\">Waiting</span></strong></span> 状态，sleep 进入的是 <span style=\"color:#be191c;\"><strong><span style=\"background-color:#fbd4d0;\">Time Waiting</span></strong></span> 状态<span style=\"color:#0d0016;\">~</span></p>\n<p><span style=\"color:#0d0016;\">wait 是主动被唤醒，而 sleep 是时间到了就会自动被唤醒~</span></p>\n<p><span style=\"color:#0d0016;\">wait 其实是涵盖了 sleep 的功能，即可以死等，也可以等待最大时间，所以一般在实际开发中用的多的是 sleep~</span></p>\n<p><img alt=\"\" height=\"58\" src=\"image\\0ad794973ab445439eefdbb54815cf15.png\" width=\"1146\"/></p>\n<p>关于线程安全问题的博客就暂时介绍到这里了~</p>\n<p>如果感觉这一篇博客对你有帮助的话，可以一键三连走一波，非常非常感谢啦 ~</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\be564e7d0ecd4bfc87a52c7ccef655b1.png\"/>​​​​​​​</p>\n<p> </p>\n</div>\n</div>"}