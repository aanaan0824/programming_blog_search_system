{"blogid": "125633381", "writerAge": "码龄2年", "writerBlogNum": "25", "writerCollect": "1669", "writerComment": "913", "writerFan": "9223", "writerGrade": "5级", "writerIntegral": "2785", "writerName": "石原里美的微笑", "writerProfileAdress": "writer_image\\profile_125633381.jpg", "writerRankTotal": "7270", "writerRankWeekly": "781", "writerThumb": "1063", "writerVisitNum": "94638", "blog_read_count": "21207", "blog_time": "已于 2022-07-15 09:25:03 修改", "blog_title": "Java中的IO流如何理解——精简", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E5%BC%95%E8%A8%80-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%BC%95%E8%A8%80\">引言</a></p>\n<p id=\"%E7%BC%93%E5%86%B2%E6%B5%81%C2%A0-toc\" style=\"margin-left:0px;\"><a href=\"#%E7%BC%93%E5%86%B2%E6%B5%81%C2%A0\">缓冲流 </a></p>\n<p id=\"%E5%AD%97%E8%8A%82%E7%BC%93%E5%86%B2%E6%B5%81%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%AD%97%E8%8A%82%E7%BC%93%E5%86%B2%E6%B5%81%C2%A0\">字节缓冲流 </a></p>\n<p id=\"%E5%AD%97%E7%AC%A6%E7%BC%93%E5%86%B2%E6%B5%81%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%AD%97%E7%AC%A6%E7%BC%93%E5%86%B2%E6%B5%81%C2%A0\">字符缓冲流 </a></p>\n<p id=\"%E8%BD%AC%E6%8D%A2%E6%B5%81%C2%A0-toc\" style=\"margin-left:0px;\"><a href=\"#%E8%BD%AC%E6%8D%A2%E6%B5%81%C2%A0\">转换流 </a></p>\n<p id=\"%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E8%BD%AC%E6%8D%A2%E6%B5%81%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E8%BD%AC%E6%8D%A2%E6%B5%81%C2%A0\">字符输入转换流 </a></p>\n<p id=\"%E5%AD%97%E7%AC%A6%E8%BE%93%E5%87%BA%E8%BD%AC%E6%8D%A2%E6%B5%81%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%AD%97%E7%AC%A6%E8%BE%93%E5%87%BA%E8%BD%AC%E6%8D%A2%E6%B5%81%C2%A0\">字符输出转换流 </a></p>\n<p id=\"%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%C2%A0-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%C2%A0\">序列化和反序列化 </a></p>\n<p id=\"%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96%C2%A0\">对象序列化 </a></p>\n<p id=\"%E5%AF%B9%E8%B1%A1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%AF%B9%E8%B1%A1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%C2%A0\">对象反序列化 </a></p>\n<p id=\"%E6%89%93%E5%8D%B0%E6%B5%81%C2%A0-toc\" style=\"margin-left:0px;\"><a href=\"#%E6%89%93%E5%8D%B0%E6%B5%81%C2%A0\">打印流 </a></p>\n<p id=\"Properties-toc\" style=\"margin-left:0px;\"><a href=\"#Properties\">Properties</a></p>\n<p id=\"-toc\" style=\"margin-left:0px;\"></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<p></p>\n<h1 id=\"%E5%BC%95%E8%A8%80\">引言</h1>\n<blockquote>\n<p>通过前面的简单学习，我们已经能够大致了解了关于文件的操作，但是能够明显感受到在执行其他的操作的时候，还是会有一些不方便的地方存在，因此今天我们会学习另外四个IO流来帮助我们对文件进行操作，这四个流分别是<span style=\"background-color:#a2e043;\">缓冲流</span>、<span style=\"background-color:#38d8f0;\">转换流</span>、<span style=\"background-color:#ed7976;\">序列化</span>、<span style=\"background-color:#faa572;\">打印流</span>。好了，废话不多说，我直接开始今天的学习吧！</p>\n<p><img alt=\"\" height=\"505\" src=\"image\\ac783d25d5af4cb8bea1ed7bd3f7ed53.png\" width=\"672\"/></p>\n<p></p>\n</blockquote>\n<h1 id=\"%E7%BC%93%E5%86%B2%E6%B5%81%C2%A0\">缓冲流 </h1>\n<blockquote>\n<ul><li>缓冲流也称为高效流、或者高级流。之前学习的字节流也可以称为原始流。</li><li>作用：缓冲流自带缓冲区，可以提高原始字节流、字符流读取数据的性能。</li><li><span style=\"color:#fe2c24;\">形象举例</span>：倘若我们将对文件的输入和输出操作想象为运输水的过程的话，在最初的时候，水（数据）是直接对接水管进行运输，而缓冲流的不同之处在于水不需要对接水管，仅需要和水管前的水缸进行对接，这么做可以提高了运输的效率。</li><li>缓冲流分为两种，一种是字节缓冲流，另一种则是字符缓冲流。分别是<span style=\"background-color:#a2e043;\">BufferedInputStream（字节缓冲输入流）</span>、<span style=\"background-color:#38d8f0;\">BufferedOuputStream（字节缓冲输出流）</span>、<span style=\"background-color:#ed7976;\">BufferedReader（字符缓冲输入流）</span>、<span style=\"background-color:#faa572;\">BufferedWriter（字符缓冲输出流）。</span> </li></ul>\n</blockquote>\n<h2 id=\"%E5%AD%97%E8%8A%82%E7%BC%93%E5%86%B2%E6%B5%81%C2%A0\">字节缓冲流 </h2>\n<blockquote>\n<ul><li><span style=\"background-color:#ff9900;\">字节缓冲输入流</span>：BufferedInputStream，提高字节输入流读取数据的性能，读写功能上并无变化</li><li><span style=\"background-color:#ed7976;\">字节缓冲输出流</span>：BufferedOutputStream， 提高字节输出流读取数据的性能，读写功能上并无变化</li></ul>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px;\"><tbody><tr><td>构造器</td><td>说明</td></tr><tr><td> <p>public BufferedInputStream（InputStream is）</p> </td><td>可以把低级的字节输入流包装成一个高级的字节缓冲输入流管道，从而提高字节输入流读数据的性能</td></tr><tr><td>public BufferedOutputStream（OutputStream os）</td><td>可以把低级的字节输出流包装成一个高级的字节缓冲输出流管道，从而提高写数据的性能</td></tr></tbody></table>\n<pre><code class=\"language-java\">InputStream is = new FileInputStream(\"File//data.txt\");\nInputStream bis = new BufferedInputStream(is);\nOutputStream os = new FileOutputStream(\"File//data01.txt\");\nOutputStream bos = new BufferedOutputStream(os);\nint len;\nbyte []buffer = new byte[1024];\nwhile ((len = bis.read(buffer))!=-1){\nbos.write(buffer,0,len);\nbos.flush();</code></pre>\n<p>通过字节缓冲流实现将一个文件中的内容复制在另一个文件之中。</p>\n<p class=\"img-center\"><img alt=\"\" height=\"221\" src=\"https://img-blog.csdnimg.cn/6ed2202372604b19956d96ebf7e68d88.gif\" width=\"273\"/></p>\n<p></p>\n</blockquote>\n<h2 id=\"%E5%AD%97%E7%AC%A6%E7%BC%93%E5%86%B2%E6%B5%81%C2%A0\">字符缓冲流 </h2>\n<blockquote>\n<p><span style=\"background-color:#a2e043;\">字符缓冲输入流</span>：BufferedReader，提高字符输入流读取数据的性能，除此之外多了按照行读取数据的功能</p>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px;\"><tbody><tr><td>构造器</td><td>说明</td></tr><tr><td>public BufferedReader（Reader r）</td><td>可以把低级的字符输入流包装成一个高级的缓冲字符输入流管道，从而提高字符输入流读数据的性能</td></tr><tr><td>方法</td><td>说明</td></tr><tr><td>public String readLine（）</td><td>读取一行数据返回，如果读取没有完毕，无行可读取返回null</td></tr></tbody></table>\n<pre><code class=\"language-java\">        Reader r = new FileReader(\"File//data.txt\");\n        BufferedReader br = new BufferedReader(r);//由于是子类独有的功能，所有不能使用多态创建\n        String s;\n        byte []buffer = new byte[1024];\n        while ((s = br.readLine())!=null){\n            System.out.println(s);\n        }\n//正常情况下会将文件中的数据依次输出；\n        Reader r = new FileReader(\"File//data.txt\");\n        BufferedReader br = new BufferedReader(r);\n        br.readLine();\n        br.readLine();\n//若文件中的数据不足两行：\n//kdirvingJamesJame\n//null</code></pre>\n<p></p>\n</blockquote>\n<blockquote>\n<p><span style=\"background-color:#38d8f0;\">字符缓冲输出流</span>：BufferedWriter，提高字符输出流写取数据的性能，除此之外多了换行功能 </p>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px;\"><tbody><tr><td>构造器</td><td>说明</td></tr><tr><td>public BufferedWriter（Writer w）</td><td>可以把低级的字符输出流包装成一个高级的缓冲字符输出流管道，从而提高字符输出流写数据的性能</td></tr><tr><td>方法</td><td>说明</td></tr><tr><td>public void newLine（）</td><td>执行操作</td></tr></tbody></table>\n<pre><code class=\"language-java\">        Writer w = new FileWriter(\"File//data.txt\",true);\n        BufferedWriter bw = new BufferedWriter(w);//由于是子类独有的功能，所有不能使用多态创建\n        bw.write(\"石原里美\");\n        bw.newLine();\n        bw.write(\"工藤静香\");\n        bw.newLine();\n        bw.flush();</code></pre>\n<p>需要留意的地方是，在写文件的时候如果想要对文件进行追加操作，需要对Writer的对象设置true，而不是BufferedWriter的对象。</p>\n<p></p>\n</blockquote>\n<h1 id=\"%E8%BD%AC%E6%8D%A2%E6%B5%81%C2%A0\">转换流 </h1>\n<blockquote>\n<p>在学习转换流之前，我们应该要了解的是如果代码编码和文件编码如果不一致。使用字符流直接读取会造成乱码，因此我们需要代码编码和文件编码一致，才能保证不会乱码，而转换流的出现就是为了能够避免这种事情的发生的。 </p>\n<p class=\"img-center\"><img alt=\"\" height=\"210\" src=\"https://img-blog.csdnimg.cn/9b11a23466e144fdb6001d05a6492d71.gif\" width=\"259\"/></p>\n<p></p>\n</blockquote>\n<h2 id=\"%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E8%BD%AC%E6%8D%A2%E6%B5%81%C2%A0\">字符输入转换流 </h2>\n<blockquote>\n<p>首先是对于乱码的问题提供一个简单的思路：</p>\n<p>1、使用字符输入转换流；</p>\n<p>2、可以提取文件（不同的编码）的原始字节流，原始字节不会存在问题；</p>\n<p>3、将字节流以指定编码转换成字符输入流，这样字符输入流中的字符就不会乱码了。</p>\n<p>字符输入转换流：InputStreamReader，可以把原始字节流按照指定编码转换成字符输入流</p>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px;\"><tbody><tr><td>构造器</td><td>说明</td></tr><tr><td>public InputStreamReader（InputStream is）</td><td>可以把原始的字节流按照代码默认编码转换成字符输入流。几乎不用</td></tr><tr><td>public InputStreamReader（InputStream is，String charset）</td><td>可以把原始的字节流按照指定指定编码转换成字符输入流，这样字符流中的字符就不乱码了</td></tr></tbody></table>\n<p></p>\n<pre><code class=\"language-java\">        InputStream is = new FileInputStream(\"File//data.txt\");\n        InputStreamReader isr = new InputStreamReader(is);\n        InputStreamReader isr = new InputStreamReader(is,\"GBK\");</code></pre>\n<p>在以上代码中，已知将data.txt文件的编码格式设置为GBK，而代码编码是utf-8，所以需要通过转换流将编码变为一致。而一种构造器默认utf-8，显然是不行的，第二种则是可以指定编码，将原始的字节输入流转换为字符输入流，并以GBK的形似进行读取。</p>\n</blockquote>\n<h2 id=\"%E5%AD%97%E7%AC%A6%E8%BE%93%E5%87%BA%E8%BD%AC%E6%8D%A2%E6%B5%81%C2%A0\">字符输出转换流 </h2>\n<blockquote>\n<p>字符输出转换流：OutputStreamWriter，可以把字节输出流按照指定编码转换成字符输出流</p>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px;\"><tbody><tr><td>构造器</td><td>说明</td></tr><tr><td>public OutputStreamWriter（OutputStream os）</td><td>可以把原始的字节输出流按照代码默认编码转换成字符输出流，几乎不用</td></tr><tr><td>public OutputStreamWriter（OutputStream os，String charset）</td><td>可以把原始的字节输出流按照指定的编码转换成字符输出流</td></tr></tbody></table>\n<p>首先我们应该知道字符输出转换流是为了应对哪些现实中的事情：假如你的客户智能编码为GBK的文件，那么你给他传过去一个utf-8的文件的话，文件是会乱码的，那么这个时候就需要我们传过去一个编码为GBK的文件。</p>\n<pre><code class=\"language-java\">        OutputStream os = new FileOutputStream(\"File//data.txt\");\n        Writer osw = new OutputStreamWriter(os);\n        Writer osw = new OutputStreamWriter(os,\"GBK\");</code></pre>\n<p>在以上代码中，第一种是默认utf-8的，所以是几乎不用的，而第二种则是可以指定客户需要的编码文件格式。</p>\n<p class=\"img-center\"><img alt=\"\" height=\"172\" src=\"https://img-blog.csdnimg.cn/1bcdf77aee114db7b2c4a88acb166bc1.gif\" width=\"224\"/></p>\n<p></p>\n</blockquote>\n<h1 id=\"%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%C2%A0\">序列化和反序列化 </h1>\n<h2 id=\"%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96%C2%A0\">对象序列化 </h2>\n<blockquote>\n<ul><li><span style=\"background-color:#a2e043;\">对象字节输出流</span>，ObjectOutputStream</li><li>作用：以内存为基准，把内存中的对象存储到磁盘文件中去，称为对象序列化</li></ul>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px;\"><tbody><tr><td>构造器</td><td>说明</td></tr><tr><td>public ObjectOutputStream（OutputStream os）</td><td>把低级字节输出流包装成高级的对象字节输出流</td></tr></tbody></table>\n<p> 首先是简单的创建了一个学生类Student，需要注意的是Java规定对象序列化的时候，类需要实现<span style=\"background-color:#38d8f0;\">Serializable接口</span>。</p>\n<pre><code class=\"language-java\">public class Student implements Serializable {\n    private String name;\n    private int age;\n    private String number;\n    private String classroom;\n}</code></pre>\n<p>接下来则是实现对象的序列化的操作：</p>\n<pre><code class=\"language-java\">        Student s = new Student(\"石原里美\",18,\"001\",\"智能一班\");\n        OutputStream os = new FileOutputStream(\"File//data.txt\");\n        ObjectOutputStream oos = new ObjectOutputStream(os);\n        oos.writeObject(s);\n        oos.close();</code></pre>\n<p>另外如果不希望对象中的某个数据不参与序列化，则可以通过<span style=\"background-color:#faa572;\">transient</span>对其进行修饰，如“private transient String name”，执行该操作之后，对其进行反序列化的时候该数据会显示null。</p>\n</blockquote>\n<h2 id=\"%E5%AF%B9%E8%B1%A1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%C2%A0\">对象反序列化 </h2>\n<blockquote>\n<ul><li>对象字节输入流，ObjectInputStream</li><li>作用：以内存为基准，把存储到磁盘文件中去的对象数据恢复成内存中的对象，称为对象反序列化</li></ul>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px;\"><tbody><tr><td>构造器</td><td>说明</td></tr><tr><td>public ObjectInputStream（InputStream is）</td><td>把低级字节输入流包装成高级的对象字节输入流</td></tr></tbody></table>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px;\"><tbody><tr><td>方法名称</td><td>说明</td></tr><tr><td>public Object readObject（）</td><td>把存储到磁盘文件中去的对象数据恢复成内存中的对象返回</td></tr></tbody></table>\n<pre><code class=\"language-java\">        InputStream is = new FileInputStream(\"File//data.txt\");\n        ObjectInputStream ois = new ObjectInputStream(is);\n        Object s = ois.readObject();\n        System.out.println(s);\n//输出结果：\n//Student{name='石原里美', age=18, number='001', classroom='智能一班'}</code></pre>\n<p>另外还有一个知识点，在定义类的时候，可以定义一个版本序列号，而在反序列号的时候，其序列号必须一致才可以正常的读取，如“private static final long serialVersionUID = 1;”</p>\n<p>若在第一次序列化之后，将类中的版本序列号更改，在没有作第二次重新序列化之前，反序列化会出现报错的情况。</p>\n<p class=\"img-center\"><img alt=\"\" height=\"212\" src=\"https://img-blog.csdnimg.cn/6064c6363dd849d9904e85be6b167bdb.gif\" width=\"212\"/></p>\n<p></p>\n</blockquote>\n<h1 id=\"%E6%89%93%E5%8D%B0%E6%B5%81%C2%A0\">打印流 </h1>\n<blockquote>\n<ul><li>作用：打印流可以实现方便、高效的打印数据到文件中去。一般指PrintStream，WriteStream两个类</li><li>可以实现打印什么数据就是什么数据，例如打印整数97，写出去就是97，打印boolean的true，写出去就是true</li></ul>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px;\"><tbody><tr><td>构造器</td><td>说明</td></tr><tr><td>public PrintStream（OutputStream os）</td><td>打印流直接通向字节输出流管道</td></tr><tr><td>public PrintStream（File f）</td><td>打印流直接通向文件对象</td></tr><tr><td>public PrintStream（String filepath）</td><td>打印流直接通向文件路径</td></tr></tbody></table>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px;\"><tbody><tr><td>方法名称</td><td>说明</td></tr><tr><td>public void print（Xxx xx）</td><td>打印任意类型的数据出去</td></tr></tbody></table>\n<p></p>\n<pre><code class=\"language-java\">//三种构造器的使用\nPrintStream ps = new PrintStream(\"File//data01.txt\");\nPrintStream ps1 = new PrintStream(new File(\"File//data.txt\"));\nPrintStream ps2 = new PrintStream(new FileOutputStream(new          File(\"File//data.txt\")));\nps.print(11);\nps.print(\"凯里·欧文\");</code></pre>\n<p></p>\n<p>PrintStream和WriterStream的<span style=\"color:#fe2c24;\">区别</span>：</p>\n<ul><li>打印数据功能上是一模一样，都是使用方便，性能高效</li><li>PrintStream继承字节输出流OutputStream，支持写字节数据的方法</li><li>PrintWriter继承字符输出流Writer，支持写字符出去</li></ul>\n</blockquote>\n<h1 id=\"Properties\">Properties</h1>\n<blockquote>\n<ul><li>作用：Properties代表的是一个属性文件可以把自己对象中的键值对信息存入到一个属性文件中去</li><li>属性文件：后缀是.properties结尾的文件，里面的内容都是key=value，后续做系统配置信息的</li></ul>\n<p></p>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px;\"><tbody><tr><td>构造器</td><td>说明</td></tr><tr><td>void load （InputStream is）</td><td>从输入字节流读取属性列表（键值对）</td></tr><tr><td>void load （Reader r）</td><td>从输入字符流读取属性列表（键值对）</td></tr><tr><td>void store （OutputStream os，String comments）</td><td>将此属性列表（键值对）写入此Properties中，以适合于使用load（InputStream）方法的格式输出字节流</td></tr><tr><td>void store（Writer w，String comments）</td><td>将此属性列表（键值对）写入此Properties中，以适合于使用load（reader）方法的格式输出字符流</td></tr><tr><td>public Object setProperty（String key，String value）</td><td>保存键值对（put）</td></tr><tr><td>public String getProperty（String key）</td><td>使用此属性列表中指定的键搜索属性值（get）</td></tr><tr><td>public Set&lt;String&gt; stringPropertyNames（）</td><td>所有键的名称的集合（keySet（））</td></tr></tbody></table>\n<pre><code class=\"language-java\">        Properties properties = new Properties();\n        properties.setProperty(\"石原里美\",\"18\");\n        properties.setProperty(\"工藤静香\",\"19\");\n        properties.setProperty(\"朱茵\",\"20\");\n        System.out.println(properties);\n        //第一个参数是文件存储路径，第二个是对文件的注释\n        properties.store(new FileWriter(\"File//Baby.properties\"),\"这些都是绝世美女，不接受反驳哈哈哈\");</code></pre>\n<p><img alt=\"\" height=\"184\" src=\"image\\c963f6835f434e978277f8b07a5d0278.png\" width=\"1157\"/></p>\n<p></p>\n<pre><code class=\"language-java\">        Properties properties = new Properties();\n        properties.load(new FileReader(\"File//Baby.properties\"));\n        System.out.println(properties);\n//输出结果：\n//{\"石原里美\"=18,\"工藤静香\"=19,\"朱茵\"=20}\n</code></pre>\n<p></p>\n</blockquote>\n<p style=\"text-align:center;\"><s><span style=\"background-color:#a2e043;\">创作不易，给个三连吧</span></s></p>\n<p></p>\n<p class=\"img-center\"><img alt=\"\" height=\"306\" src=\"https://img-blog.csdnimg.cn/aaae983712c340cba1d9444d91e4ae5c.gif\" width=\"306\"/></p>\n<p></p>\n<p></p>\n<p></p>\n<h1></h1>\n</div>\n</div>"}