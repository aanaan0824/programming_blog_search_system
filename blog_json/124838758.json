{"blogid": "124838758", "writerAge": "码龄6年", "writerBlogNum": "15", "writerCollect": "150", "writerComment": "6", "writerFan": "93", "writerGrade": "2级", "writerIntegral": "240", "writerName": "彭_江南", "writerProfileAdress": "writer_image\\profile_124838758.jpg", "writerRankTotal": "73578", "writerRankWeekly": "359601", "writerThumb": "17", "writerVisitNum": "38577", "blog_read_count": "11082", "blog_time": "已于 2022-05-19 14:47:51 修改", "blog_title": "python编程考试题目大全", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p>1.题目名称：批阅奏章<br/> 某朝皇帝有大臣n名（1&lt;=n&lt;=1000），分别编号大臣1~n。某日皇帝身体抱恙，奏章堆积如山无法及时一一批阅，便命身旁內侍帮他把奏章按指定顺序排序后再阅。于是皇帝亲自挑选了几个值得信赖的重臣并排好序，要求把他们的奏章按排好的顺序放到前面，其他的按照编号升序排列即可。现在要求你写一个程序来帮皇上解决这个问题，即已知奏章总数和顺序、钦点重臣的排列顺序，求得皇帝查阅奏章的顺序。<br/> 输入描述：<br/> 第一行输入两个整数p（1&lt;=p&lt;=5000）和q，其中p表示堆积奏章的总数、q表示皇帝钦点重臣数<br/> 第二行输入p个数，表示所有按呈递顺序递上来的奏章来自于哪个大臣（大臣编号）<br/> 第三行输入q个数，表示皇帝钦点并排好序的重臣编号<br/> 输出描述：<br/> 输出奏章按指定顺序排好序后，皇帝按大臣编号批阅的顺序<br/> 输入样例：<br/> 5 3<br/> 5 4 3 2 1<br/> 3 5 4<br/> 输出样例：<br/> 3 5 4 1 2<br/> 答案：</p>\n<pre><code>line1 = list(map(int,input('ddd').split()))\np = line1[0]\nq = line1[1]\narticle_author = list(map(int,input('ddd').split()))\npersons = list(map(int,input('ddd').split()))\nresult =[]\narticle_author.sort()\nfor p1 in persons:\n    for a1 in range(0,len(article_author)):\n        if article_author[a1] == p1:\n            result.append(p1)\n            article_author[a1] = 0\nfor a1 in article_author:\n    if a1!=0:\n        result.append(a1)\nprint_text = list(map(str,result))\nprint(\" \".join(print_text))\n</code></pre>\n<p>2.题目名称：报价<br/> 时间限制：1000ms内存限制：256M<br/> 题目描述<br/> 给定某股票每日的报价和一个目标值，请在所有报价中找出和为目标值的那两天的报价，并打印出对应的报价。<br/> 假设每种输入只会对应一个答案，且每日的报价不会重复。<br/> 你需要按报价从小到大的顺序打印答案。</p>\n<p>输入描述：<br/> 输入：第一行是某股票每日的报价，这些报价是正整数且用空格相隔，例如：17 20 33<br/> 第二行是目标值，例如：37<br/> 输出描述：<br/> 输出：对应的报价，报价之间用空格相隔，例如：17 20<br/> 示例<br/> 示例1<br/> 输入<br/> 17 20 33<br/> 37<br/> 复制<br/> 输出<br/> 17 20<br/> 复制<br/> 答案：</p>\n<pre><code>list1=list(map(int,input().split()))\ngoal=int(input())\nlist1.sort()\nfor i in list1:\n    if (goal-i) in list1:\n        print(str(i)+\" \"+str(goal-i))\n        break\n</code></pre>\n<p>3.题目名称：水仙花数<br/> 时间限制：1000ms内存限制：256M<br/> 题目描述<br/> 如果一个 3 位数等于其各位数字的立方和，则称这个数为水仙花数。<br/> 例如：153 = 1^3 + 5^3 + 3^3，因此 153 就是一个水仙花数<br/> 输入描述：<br/> 输入一个整数a与一个整数b, 用空格分隔<br/> 输出描述：<br/> 输出a到b区间内的水仙花数<br/> 示例<br/> 示例1<br/> 输入<br/> 100 170<br/> 复制<br/> 输出<br/> 153<br/> 复制<br/> 答案：</p>\n<pre><code>a,b = map(int,input().split())\nfor n in range(a,b+1):\n    x = int(str(n)[0])\n    y = int(str(n)[1])\n    z = int(str(n)[2])\n    if n == x**3 + y**3 + z**3:\n        print(n)\n</code></pre>\n<p>4.题目名称：字符串查找和比较(pass)<br/> 时间限制：1000ms内存限制：256M<br/> 题目描述<br/> 写函数实现如下功能，给定字符串A和B,输出A和B中的最长公共子串。比如A=“aocdfe” B=“pmcdfa” 则输出\"cdf\"。<br/> 输入描述：<br/> 输入待处理的两个字符串 str1，str2<br/> 输出描述：<br/> 找出两个字符串最长的公共子串<br/> 示例 示例1<br/> 输入<br/> aocdfe<br/> pmcdfa<br/> 输出<br/> Cdf<br/> 答案：</p>\n<pre><code>A = str(input(\"\"))\nB = str(input(\"\"))\nif len(A)&gt;len(B):\n    A,B = B,A\nout_put=[]\nfor i in range(len(A),0,-1):\n    for j in range(0,len(A)-i+1):\n        if A[j:j+i] in B:\n            print(A[j:j+i])\n            out_put.append(A[j:j+i])\n    if out_put:\n        break\n</code></pre>\n<p>5.题目名称：尼姆博弈<br/> 时间限制：1000ms内存限制：256M<br/> 题目描述<br/> 你和你的朋友，两个人一起玩 Nim 游戏：<br/> 桌子上有一堆石头。<br/> 你们轮流进行自己的回合，你作为先手。<br/> 每一回合，轮到的人拿掉 1 - 3 块石头。<br/> 拿掉最后一块石头的人就是获胜者。<br/> 假设你们每一步都是最优解。请编写一个函数，来判断你是否可以在给定石头数量为 n 的情况下赢得游戏。如果可以赢，返回 true；否则，返回 false 。<br/> 输入描述：<br/> 整数n<br/> 输出描述：<br/> true或false<br/> 示例<br/> 示例1<br/> 输入<br/> 4<br/> 复制<br/> 输出<br/> False<br/> 答案：</p>\n<pre><code>num = int(input())\nif num % 4 == 0:\n    print(\"false\")\nelse:\n    print(\"true\")\n\n</code></pre>\n<p>6.题目名称：罗马数字转整数(pass)<br/> 时间限制：1000ms内存限制：256M<br/> 题目描述<br/> 罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p>\n<p>例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。<br/> 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>\n<p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br/> X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br/> C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br/> 给定一个罗马数字，将其转换成整数。<br/> 输入描述：<br/> 罗马数字<br/> 输出描述：<br/> 转换后的整数<br/> 示例<br/> 示例1<br/> 输入 III<br/> 输出 3<br/> 答案：</p>\n<pre><code>src = input()\nn_value = {\"Z\":0,\"I\":1,\"V\":5,\"X\":10,\"L\":50,\"C\":100,\"D\":500,\"M\":1000}\npre_value = {\"I\":\"Z\",\"V\":\"I\",\"X\":\"I\",\"L\":\"X\",\"C\":\"X\",\"D\":\"C\",\"M\":\"C\"}\nresult = 0\nlast_char = \"\"\nfor _c in src:\n    result+= n_value[_c]\n    if last_char == pre_value[_c]:\n        result-= n_value[last_char] * 2\n    last_char = _c\nprint(result)\n\n</code></pre>\n<p>7.题目名称：员工排序<br/> 时间限制：1000ms内存限制：256M<br/> 题目描述<br/> 某公司要针对员工情况统一调薪，现有一个员工列表，包含姓名、职级、工作年限、工资信息。现要求将该列表按以下规则重新排序：</p>\n<p>1、职级高的排在前面</p>\n<p>2、若职级相同，按工资少的排前面</p>\n<p>3、若工资相同，工作年限长的排前面</p>\n<p>输入描述：<br/> 第一行输入一个整数n，表示员工列表中员工的人数</p>\n<p>接下来的n行，分别输入员工的姓名、职级、工作年限和工资信息，各项信息用空格分隔</p>\n<p>输出描述：<br/> 输出按要求重新排列的员工列表，每名员工信息（姓名、职级、工作年限和工资）占一行</p>\n<p>示例<br/> 示例1<br/> 输入<br/> 6<br/> 张三 3 3 3000<br/> 李四 3 4 3000<br/> 王五 3 3 4000<br/> 赵六 4 3 3000<br/> 陆奇 4 4 4000<br/> 闫八 4 4 3980.99<br/> 复制<br/> 输出<br/> 赵六 4 3 3000.00<br/> 闫八 4 4 3980.99<br/> 陆奇 4 4 4000.00<br/> 李四 3 4 3000.00<br/> 张三 3 3 3000.00<br/> 王五 3 3 4000.00<br/> 答案：</p>\n<pre><code>num = int(input())\nemployees = []\nfor _i in range(0,num):\n    employees.append(input().split())\nsrc_data = list(map(lambda x:[x[0],int(x[1]),int(x[2]),float(x[3])],employees))\nsrc_data.sort(key=lambda x: -1000000000000*x[1] + 10000*x[3] - x[2])\nfor _i in src_data:\n    print(\"%s %d %d %0.2f\" % (_i[0],_i[1],_i[2],_i[3]))\n</code></pre>\n<p>8.题目名称：汉诺塔<br/> 时间限制：1000ms内存限制：256M<br/> 题目描述<br/> 有三个立柱A、B、C。A柱上穿有大小不等的圆盘N个，较大的圆盘在下，较小的圆盘在上。要求把A柱上的圆盘全部移到C柱上，保持大盘在下、小盘在上的规律（可借助B柱）。每次移动只能把一个柱子最上面的圆盘移到另一个柱子的最上面。请输出移动过程。</p>\n<p>输入描述：<br/> 输入一个整数n</p>\n<p>输出描述：<br/> 输出移动过程</p>\n<p>示例<br/> 示例1<br/> 输入<br/> 3<br/> 复制<br/> 输出<br/> a-&gt;c<br/> a-&gt;b<br/> c-&gt;b<br/> a-&gt;c<br/> b-&gt;a<br/> b-&gt;c<br/> a-&gt;c<br/> 复制</p>\n<pre><code>def han_nuo(n,src,tmp,dest):\n    if n &lt;= 0:\n        return\n    if n == 1:\n        print(src + \"-&gt;\" + dest)\n        return\n    han_nuo(n-1,src,dest,tmp)\n    print(src + \"-&gt;\" + dest)\n    han_nuo(n-1,tmp,src,dest)\n    \nnum = int(input())\nhan_nuo(num,\"a\",\"b\",\"c\")\n</code></pre>\n<p>9.题目名称：交换数值<br/> 时间限制：1000ms内存限制：256M<br/> 题目描述<br/> 将整数a、b的值进行交换，并且不使用任何中间变量。<br/> 输入描述：<br/> 输入待处理的两个整数 a 和b<br/> 输出描述：<br/> a 和b 的值交换<br/> 示例<br/> 示例1<br/> 输入<br/> a=100<br/> b=200<br/> 复制<br/> 输出<br/> a=200<br/> b=100<br/> 复制<br/> 答案</p>\n<pre><code>a = int(input().split('=')[1])\nb = int(input().split('=')[1])\na,b = b,a\nprint(\"a=%d\"%a)\nprint(\"b=%d\"%b)\n</code></pre>\n<p>10.题目名称：进程排序(pass)<br/> 某系统中有n个进程，每个进程都有自己唯一的进程id（PID），同时每个进程最多还有一个父进程，父进程id为（PPID），和一个或多个子进程。<br/> 若某进程没有父进程，则PPID为0。 当某一进程被终止时，其子进程也将被终止。<br/> 现给出进程id列表和起对应的父进程id列表，当要终止某一进程时，计算最终会终止哪些进程，并将要终止的PID按升序排列。<br/> 输入描述：<br/> 第一行输入两个整数n和k，n表示当前系统中运行的进程数；k表示要终止进程的PID<br/> 第二行输入n个正整数，表示进程列表，每个整数表示进程的PID<br/> 第三行输入n个正整数，表示进程列表中的进程对应的父进程PPID列表。<br/> 输出描述：<br/> 输出当进程k终止时，所有会被终止的进程PID，并按PID升序排列，每个PID用空格分隔。<br/> 输入样例：<br/> 4 5<br/> 1 3 10 5<br/> 3 0 5 3<br/> 输出样例：5 10<br/> 答案：</p>\n<pre><code>import copy\nn,k=map(int,input().split(' '))\npids=list(map(int,input().split(' ')))\nppids=list(map(int,input().split(' ')))\nt=[k]\nA=[k]\nwhile len(set(t)&amp;set(ppids))&gt;0:\n    zk=[]\n    for x in t:\n        for i in range(len(ppids)):\n            if ppids[i]==x:\n                zk.append(pids[i])\n                A.append(pids[i])\n    t=copy.deepcopy(zk)\nA.sort()\nli=[str(x) for x in A]\nprint(' '.join(li))\n\n</code></pre>\n<p>11.题目名称：丑数<br/> 时间限制：1000ms内存限制：256M<br/> 题目描述<br/> 给你一个整数 n ，请你判断 n 是否为 丑数 。如果是，返回 true ；否则，返回 false 。<br/> 丑数 就是只包含质因数 2、3 和/或 5 的正整数。(1通常被视为丑数)<br/> 输入描述：<br/> 整数n<br/> 输出描述：true或false<br/> 示例 示例1<br/> 输入6<br/> 输出true<br/> 答案：</p>\n<pre><code>m=int(input())\ndef cnum(n):\n    while True:\n        if n &lt;= 0:\n            return False\n        elif n==1 or n==2 or n==3 or n==5:\n            return True\n        elif n % 2 ==0:\n            n = n/2\n        elif n % 3 ==0:\n            n = n/3\n        elif n % 5 ==0:\n            n = n/5\n        else:\n            return False\nf=cnum(m)\nif f == True:\n    print(\"true\")\nelse:\n    print(\"false\")\n\n</code></pre>\n<p>12、 克拉兹猜想：任取一正整数，如果是偶数，将其除以2。如果是奇数，将其乘以3再加1，然后重复这个过程，最后结果都会陷入4 2 1 的循环。<br/> 比如序列：13, 40, 20, 10, 5, 16, 8, 4, 2, 1, 4, 2, 1<br/> 请通过编程实现，当4,2,1重复第二次的时候，结束循环。请输出以下3个序列：<br/> [13, 40, 20, 10, 5, 16, 8, 4, 2, 1, 4, 2, 1]<br/> [31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1, 4, 2, 1]<br/> [101, 304, 152, 76, 38, 19, 58, 29, 88, 44, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1, 4, 2, 1]</p>\n<pre><code>def collatz(number):\n    res=number%2\n    if res==0:\n        return number//2\n    else:\n        return number*3+1\n\nnum=13\nin_list=[13,31,101]\nfor  num in in_list:\n    jg_list = [num]\n    while True:\n        num=collatz(num)\n        jg_list.append(num)\n        if jg_list.count(1)==2:\n            break\n    print(jg_list)\n----------------------------------------------------------\n</code></pre>\n<p>如果输入的数 是 1 2 就不适用上面的程序 必须改用下面</p>\n<pre><code>num= int(input())\narr = input()\n\nin_list = [int(n) for n in arr.split()]\ndef collatz(number):\n    res=number%2\n    if res==0:\n        return number//2\n    else:\n        return number*3+1\n\nfor  num in in_list:\n    jg_list = [num]\n    while True:\n        num=collatz(num)\n        jg_list.append(num)\n        if jg_list[-6:]==[4,2,1,4,2,1]:\n            break\n    print(jg_list)\n</code></pre>\n<p>13、给定一组数，按照数组中出现的次数依次从大到小排序，出现次数一样的按照数组中的先后顺序输出<br/> 比如：<br/> 输入：1 1 1 1 3 3 3 4 5 2 6 6 6 6 6<br/> 输出：6 6 6 6 6 1 1 1 1 3 3 3 4 5 2¶</p>\n<pre><code>n=map(int,input().split())\nn=list(n)\n\njg_list=[]\nfor index,value in enumerate(n):\n    j=n.count(value)\n    jg=[value,index,j]\n    jg_list.append(jg)\n\njg_list.sort(key=lambda x:x[1])\njg_list.sort(key=lambda x:x[2],reverse=True)\n\n\nfor x in jg_list:\n    print(x[0],'',end='')\n</code></pre>\n<p>14、完数：一个数如果恰好等于它的因子之和，这个数就称为\"完数\"。例如6=1＋2＋3。编程找出10000以内的所有完数。</p>\n<pre><code>jg=[]\nfor i in range(1,10000):\n    sum1 = 0\n    for j in range(1,int(i/2)+1):\n        if i/j==int(i/j):\n            sum1+=j\n    if sum1==i:\n        jg.append(i)\nprint(jg)\n</code></pre>\n<p>15、利用条件运算符的嵌套来完成此题：学习成绩&gt;=90分的同学用A表示，60-89分之间的用B表示，60分以下的用C表示</p>\n<pre><code>def main():\n    s = int(input('请输入成绩:'))\n    if s&gt;=90:\n        grade = 'A'\n    elif s&gt;=60:\n        grade = 'B'\n    else:\n        grade = 'C'\n    print(grade)\nmain()\n</code></pre>\n<p>16、递归案例 求斐波那契列数列1，1，2，3，5，8，13 的第30位</p>\n<pre><code>def f(n):\n      return 1 if n==1 or n==2 else f(n-1)+f(n-2)\n\nn=int(input())\n\nls=[]\nfor i in range(1,n+1):\n    if i==1 or i==2:\n       ls.append(1)\n    else:\n       ls.append(ls[i-2]+ls[i-3])\n       \nprint(ls)\n</code></pre>\n<h2><a id=\"N_533\"></a>求整数N的阶乘</h2>\n<pre><code>n=int(input())\ndef f(n):\n    if n==1:\n        return(n)\n    else:\n        return(n*f(n-1))\n        \nprint(f(1),f(2),f(3),f(4),f(5),f(6))\n        \nprint(f(n))\n</code></pre>\n<p>#求整数N的阶乘</p>\n<pre><code>def f(n):\n    if n==1:\n        return(n)\n    else:\n        return(n*f(n-1))\n        \nn=int(input())\nls=[]\nfor i in range(1,n+1):\n     if i==1:\n         ls.append(1)\n     else:\n         ls.append(f(i))\nprint(ls)   \n     \nprint(f(1),f(2),f(3),f(4),f(5),f(6))\n        \nprint(f(n))\n</code></pre>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}