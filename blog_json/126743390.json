{"blogid": "126743390", "writerAge": "码龄2年", "writerBlogNum": "523", "writerCollect": "664", "writerComment": "30", "writerFan": "12330", "writerGrade": "6级", "writerIntegral": "5648", "writerName": "无薪法师", "writerProfileAdress": "writer_image\\profile_126743390.jpg", "writerRankTotal": "2934", "writerRankWeekly": "586", "writerThumb": "80", "writerVisitNum": "257684", "blog_read_count": "12", "blog_time": "于 2022-09-07 12:52:40 发布", "blog_title": "JVM 程序计数器", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<blockquote>\n<p>程序计数器是一块较小的内存空间，它的作用可以看作是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。- - 摘自《深入理解Java虚拟机》</p>\n</blockquote>\n<p><strong>特 点</strong></p>\n<ol><li> <p>如果线程正在执行的是Java 方法，则这个计数器记录的是正在执行的虚拟机字节码指令地址</p> </li><li> <p>如果正在执行的是Native 方法，则这个技术器值为空（Undefined）</p> </li><li> <p>此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域</p> </li></ol>\n<p><strong>一、程序计数器会随着线程的启动而创建，先来直观的看下计数器中会存哪些内容</strong></p>\n<p>有代码如下</p>\n<pre><code>package com.xnccs.cn.share;\n\npublic class ShareCal {\n\n    public int calc(){\n        int a = 100;\n        int b = 200;\n        int c = 300;\n        return ( a + b ) * c;\n    }\n}\n</code></pre>\n<p>这是一段非常简单的计算代码，我们先编译成Class 文件再使用 javap 反汇编工具看下class 文件中数据格式，如下图</p>\n<p><img alt=\"这里写图片描述\" src=\"https://img-blog.csdn.net/20180102165306848?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVhZl8wMzAz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\"/></p>\n<p>图中使用红框框起来的就是字节码指令的<strong>偏移地址</strong>，偏移地址对应的<strong>bipush</strong> 等等是jvm 中的操作指令,这是入栈指令。这里不作详细分析，有机会再分享。 当执行到方法**calc()**时在当前的线程中会创建相应的程序计数器，在计数器中为存放执行地址 （红框中的）0 2 3…等等</p>\n<p><img alt=\"这里写图片描述\" src=\"https://img-blog.csdn.net/20180102170104381?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVhZl8wMzAz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\"/></p>\n<p>这也说明在我们程序运行过程中计数器中改变的只是值，而不会随着程序的运行需要更大的空间，也就不会发生溢出情况。–<strong>特点3</strong></p>\n<p><strong>二、举例理解程序计数器</strong></p>\n<p>说线程恢复等基础功能都需要依赖这个程序计数器来完成，首先我们得知道：</p>\n<ul><li>线程是CPU 最小的调度单元</li><li>Java 虚拟机的多线程是通过切换线程并分配处理器执行时间的方式来实现的，在任何一个确定的时间，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令</li></ul>\n<p>如有如下图过程，当A 线程先向处理器发出指令，但当执行到中途一半时，B线程过来执行，且优先级高，此时处理器将A 挂起，B 执行，当B 执行结束需要唤醒A 同时得知道A 的执行位置，就可以查看线程A 中的计数器指令</p>\n<p><img alt=\"这里写图片描述\" src=\"https://img-blog.csdn.net/20180102172208721?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVhZl8wMzAz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\"/></p>\n<p><strong>三、为什么执行的是native 方法时，为undefined</strong></p>\n<p>由上我们知道计数器记录的字节码指令地址，但是native 本地（如：System.currentTimeMillis()/ public static native long currentTimeMillis();）方法是大多是通过C实现并未编译成需要执行的字节码指令所以在计数器中当然是空（undefined）.</p>\n<p><strong>问： 那native 方法的多线程是如何实现的呢？</strong></p>\n<p><strong>答：</strong> native 方法是通过调用系统指令来实现的，那系统是如何实现多线程的则 native 就是如何实现的</p>\n<p>摘博客一段话：</p>\n<p>Java线程总是需要以某种形式映射到OS线程上。映射模型可以是1:1（原生线程模型）、n:1（绿色线程 / 用户态线程模型）、m:n（混合模型）。以HotSpot VM的实现为例，它目前在大多数平台上都使用1:1模型，也就是每个Java线程都直接映射到一个OS线程上执行。此时，native方法就由原生平台直接执行，并不需要理会抽象的JVM层面上的“pc寄存器”概念——原生的CPU上真正的PC寄存器是怎样就是怎样。就像一个用C或C++写的多线程程序，它在线程切换的时候是怎样的，Java的native方法也就是怎样的。</p>\n<p>作者：RednaxelaFX<br/> 链接：<a href=\"https://www.zhihu.com/question/40598119/answer/87381512\">https://www.zhihu.com/question/40598119/answer/87381512</a></p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}