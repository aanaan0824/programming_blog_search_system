{"blogid": "123867636", "writerAge": "码龄14年", "writerBlogNum": "2", "writerCollect": "1", "writerComment": "0", "writerFan": "1", "writerGrade": "1级", "writerIntegral": "20", "writerName": "noworrycd", "writerProfileAdress": "writer_image\\profile_123867636.jpg", "writerRankTotal": "217236", "writerRankWeekly": "437068", "writerThumb": "0", "writerVisitNum": "1450", "blog_read_count": "910", "blog_time": "于 2022-04-22 11:58:14 发布", "blog_title": "c# richtextbox更新大量数据不卡死的办法", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<blockquote>\n<p>提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档</p>\n</blockquote>\n<p></p>\n<div class=\"toc\">\n<h3>文章目录</h3>\n<ul><li><a href=\"#_7\">前言</a></li><li><a href=\"#richtextbox_11\">一、richtextbox更新方法</a></li><li><a href=\"#_17\">二、使用步骤</a></li><li><a href=\"#_95\">总结</a></li></ul>\n</div>\n<p></p>\n<hr/>\n<h1><a id=\"_7\"></a>前言</h1>\n<p>c# 的richtextbox对读入几十万行大数据或者频繁更新经常卡死界面几分钟。<br/> 终于找到一个通过子线程更新的方法， 实际测试对于40万行可以在10秒内完成更新， 并且运行中界面不卡死可以操作。</p>\n<h1><a id=\"richtextbox_11\"></a>一、richtextbox更新方法</h1>\n<p>richtextbox更新有两种更新方法：richtextbox.appendtext() 和 richtextbox.text = richtextbox.text + str。<br/> 在子线程中可使用 richtextbox.text = richtextbox.text + str。</p>\n<p>为了提高效率， 使用了StringBuilder sb进行缓冲， 每maxDisplayline行更新一次richtextbox， 并根据行数增加动态调整了maxDisplayline的大小。</p>\n<h1><a id=\"_17\"></a>二、使用步骤</h1>\n<p>代码如下（核心代码）：</p>\n<pre><code>        maxDisplayline = 1 * 1000; // 1000行\n       StringBuilder sb = new StringBuilder();\n        Stopwatch swGlobal = new Stopwatch();\n        string[] sblineslist = in_str.Split(new char[] { '\\n' }); // instr 为输入字符串，可以是文件读入的\n        // static readonly object lockSb = new object();\n\n        richTextBoxDisplay.Focus();\n        sb.Clear();\n        Thread.Sleep(1);\n\n        \n        swGlobal.Reset(); swGlobal.Start();\n\n        Thread t = new Thread((ThreadStart)delegate\n          {\n              try\n              {\n                  for (int i = 0; i &lt; sblineslist.Length; i++)\n                  {\n                      if (stopSign)\n                      {\n                          return;\n                      }\n\n\t\t\t\t\t// lock(lockSb)\n                      sb.Append(sblineslist[i] + \"\\n\");\n\n                      if (i &gt; 0 &amp;&amp; i % maxDisplayline == 0)\n                      {\n                          this.Invoke((EventHandler)delegate { labelStatus.Text = \"状态: \" + count + \"/\" + manualSyncFilesFullname.Count + \" \" + runsecond + \"s -&gt; \" + (i + 1) \n                              + \" Act/Rest: \" + swGlobal.ElapsedMilliseconds/1000 + \"/\" + (int)(1.0 * swGlobal.ElapsedMilliseconds * (sblineslist.Length - (i+1)) /(i+1) /1000) + \"s\";\n                              labelStatus.Update(); });\n\n                          if (sb.Length &gt; 0)\n                          {\n          \t\t\t\t\t\t// lock(lockSb)\n                              this.richTextBoxDisplay.Text = this.richTextBoxDisplay.Text + sb.ToString();\n                              sb.Clear();\n                          }\n\n                          maxDisplayline = maxDisplayline * ((int)Math.Sqrt(i/ maxDisplayline));\n                      }\n                  }\n\n                  if (sb.Length &gt; 0)\n                  {\n   \t\t\t\t\t\t// lock(lockSb)\n                      this.richTextBoxDisplay.Text = this.richTextBoxDisplay.Text + sb.ToString();\n                      sb.Clear();\n                  }\n                  this.Invoke((EventHandler)delegate { labelStatus.Text = \"状态: \" + count + \"/\" + manualSyncFilesFullname.Count + \" \" + runsecond + \"s -&gt; \" + sblineslist.Length.ToString()\n                      +\" Act: \" + swGlobal.ElapsedMilliseconds / 1000 + \"s\";\n                      labelStatus.Update(); });\n              }\n              catch (Exception ex)\n              {\n                  try\n                  {\n                      stopSign = true;\n                      this.Invoke((EventHandler)delegate { labelStatus.Text = \"异常错误: \" + ex.Message; labelStatus.Update(); });\n                  }\n                  catch { }\n              }\n        });\n\n        t.IsBackground = true;\n        t.Start();\n        Thread.Sleep(33);\n\n        while (!stopSign &amp;&amp; t != null &amp;&amp; t.IsAlive)\n        {\n            Application.DoEvents();\n            Thread.Sleep(3);\n        }\n</code></pre>\n<h1><a id=\"_95\"></a>总结</h1>\n<p>richtextbox.text 支持在子线程中直接操作和访问。<br/> 如果需要多线程并发交互更新，需要在操作sb的时候加锁。</p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}