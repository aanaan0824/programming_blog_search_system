{"blogid": "126591449", "writerAge": "码龄5年", "writerBlogNum": "266", "writerCollect": "2741", "writerComment": "120", "writerFan": "16737", "writerGrade": "6级", "writerIntegral": "5343", "writerName": "Mr.codeee", "writerProfileAdress": "writer_image\\profile_126591449.jpg", "writerRankTotal": "2900", "writerRankWeekly": "840", "writerThumb": "465", "writerVisitNum": "390992", "blog_read_count": "428", "blog_time": "已于 2022-08-30 20:28:08 修改", "blog_title": "DLL注入——使用远程线程", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h3>1.简介</h3>\n<p>从根本上来说，DLL注入技术要求目标进程中的一个线程调用LoadLibrary来载入我们想要的DLL。由于我们不能轻易地控制别人进程中的线程，因此这种方法要求我们在目标进程中创建一个新的线程，Windows提供了创建远程线程的函数。</p>\n<pre><code class=\"language-cpp\">HANDLE CreateRemoteThread(\n  [in]  HANDLE                 hProcess,\n  [in]  LPSECURITY_ATTRIBUTES  lpThreadAttributes,\n  [in]  SIZE_T                 dwStackSize,\n  [in]  LPTHREAD_START_ROUTINE lpStartAddress,\n  [in]  LPVOID                 lpParameter,\n  [in]  DWORD                  dwCreationFlags,\n  [out] LPDWORD                lpThreadId\n);</code></pre>\n<ul><li>hProcess：用于创建线程的进程的句柄。</li><li>lpThreadAttributes：指向SECURITY_ATTRIBUTES结构的指针，该结构确定返回的句柄是否可以被子进程继承。</li><li>dwStackSize：堆栈的初始大小，以字节为单位。如果此参数为零，则新线程使用默认大小。</li><li>lpStartAddress：指向线程要执行的应用程序定义函数的指针。</li><li>lpParameter：指向要传递给线程的变量的指针。</li><li>dwCreationFlags：控制线程创建的标志。</li><li>lpThreadId：指向接收线程标识符的变量的指针。如果该参数为NULL，则不返回线程标识符。</li></ul>\n<h3>2.步骤</h3>\n<ul><li>用VirtualAllocEx函数在远程进程的地址空间中分配一块内存。</li><li>用WriteProcessMemory函数把DLL的路径名复制到第一步分配的内存中。</li><li>用GetProcAddress函数来得到LoadLibraryW或LoadLibraryA函数的实际地址（在Kernel32.dll中）</li><li>用CreateRemoteThread函数在远程进程中创建一个线程，让新线程调用正确的LoadLibrary函数并在参数中传入第一步分配的内存地址。这时，DLL已经被注入到远程进程的地址空间中，DLL的DllMain函数会收到DLL_PROCESS_ATTACH通知并且执行我们想要执行的代码。</li><li>VirtualFreeEx来释放第1步分配的内存。</li><li>用GetProcAddress函数来得到FreeLibrary函数的实际地址（在Kernel32.dll中）</li><li>用CreateRemoteThread函数在远程进程中创建一个线程，让新线程调用FreeLibrary函数并在参数中传入远程DLL的HMODULE。</li></ul>\n<p><strong>步骤1、2、3原理简介：</strong></p>\n<p>字符串“D://remoteDll.dll”，位于调用进程的空间地址中，我们把这个地址传给新创建的远程线程，远程线程再把它传给LoadLibrary，当LoadLibrary去访问这个内存地址的时候，DLL的路径字符串并不在那里，远程进程的线程就很可能引发访问违规。为了解决这个问题，我们需要把DLL的字符串存放到远程进程的地址空间中去，所以会使用VirtualAllocEx和WriteProcessMemory方法。</p>\n<h3>3.示例</h3>\n<p><strong>3.1先做一个动态库remoteDll.dll</strong></p>\n<p>此库的功能是，一旦被注入到进程的地址空间中，就报告该进程正在使用的所有DLL，并将打印信息写入到本地文件D://out.txt中。</p>\n<pre><code class=\"language-cpp\">const char* filepath = \"D://out.txt\";\n\nBOOL APIENTRY DllMain( HMODULE hModule,\n                       DWORD  ul_reason_for_call,\n                       LPVOID lpReserved\n                     )\n{\n    switch (ul_reason_for_call)\n    {\n    case DLL_PROCESS_ATTACH:\n    {\n        FILE* fp = freopen(filepath, \"w\", stdout);\n        \n        PBYTE pb = NULL;\n        MEMORY_BASIC_INFORMATION mbi;\n        while (VirtualQuery(pb, &amp;mbi, sizeof(mbi)) == sizeof(mbi))\n        {\n            int nlen;\n            char szModName[MAX_PATH];\n            if (mbi.State == MEM_FREE)\n                mbi.AllocationBase = mbi.BaseAddress;\n            if ((mbi.AllocationBase == hModule) || (mbi.AllocationBase != mbi.BaseAddress) || (mbi.AllocationBase == NULL))\n                nlen = 0;\n            else\n            {\n                nlen = GetModuleFileNameA((HINSTANCE)mbi.AllocationBase, szModName, _countof(szModName));\n            }\n            if (nlen &gt; 0)\n            {\n                char szBuf[MAX_PATH] = { 0 };\n                wsprintfA(szBuf, \"\\n%p-%s\", mbi.AllocationBase, szModName);\n                printf(\"%s\\n\", szBuf);\n            }\n\n            pb += mbi.RegionSize;\n        } \n\n        fclose(fp);\n    }\n    break;\n    case DLL_THREAD_ATTACH:\n    case DLL_THREAD_DETACH:\n    case DLL_PROCESS_DETACH:\n        break;\n    }\n    return TRUE;\n}\n</code></pre>\n<p><strong>3.2写一个测试程序</strong></p>\n<p>新建一个带界面的程序</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\7c5d362c4708451e8691197f16fc348c.png\"/></p>\n<p>改了一下窗口界面，这里加了一个菜单项注入。</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\02944399373b4e1d8d5b1bceba56119c.png\"/></p>\n<p>点击注入出现弹窗，如下图所示。</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\9cba69a0a97f4294a735a2f7d80345e3.png\"/></p>\n<p>输入进程ID，点击确定即可，下面是注入的回调函数。</p>\n<pre><code class=\"language-cpp\">// “注入”框的消息处理程序。\nINT_PTR CALLBACK Inject(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)\n{\n    UNREFERENCED_PARAMETER(lParam);\n    switch (message)\n    {\n    case WM_INITDIALOG:\n    {\n        return (INT_PTR)TRUE;\n    }\n    case WM_COMMAND:\n        if (LOWORD(wParam) == IDOK)\n        {\n            //获取ID值\n            DWORD processID = GetDlgItemInt(hDlg, IDC_EDIT1, NULL, FALSE);\n            if (processID == 0)\n            {\n                processID = GetCurrentProcessId();\n            }\n\n            if (InjectLib(processID, TEXT(\"D://remoteDll.dll\")))\n            {\n                printf(\"inject ok\");\n                EjectLib(processID, TEXT(\"D://remoteDll.dll\"));\n            }\n            else\n            {\n                printf(\"inject failed\");\n            }\n\n            EndDialog(hDlg, LOWORD(wParam));\n            return (INT_PTR)TRUE;\n        }\n        else if (LOWORD(wParam) == IDCANCEL)\n        {\n            EndDialog(hDlg, LOWORD(wParam));\n            return (INT_PTR)TRUE;\n        }\n        break;\n    }\n    return (INT_PTR)FALSE;\n}</code></pre>\n<p>InjectLib函数如下：</p>\n<pre><code class=\"language-cpp\">BOOL WINAPI InjectLib(DWORD processID, PCWSTR pszLibFile)\n{\n    BOOL bOk = FALSE;\n    HANDLE hProcess = NULL, hThread = NULL;\n    PWSTR pszLibFileRemote = NULL;\n\n    __try\n    {\n        hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_CREATE_THREAD |\n            PROCESS_VM_OPERATION | PROCESS_VM_WRITE, FALSE, processID);\n\n        if (hProcess == NULL)\n            __leave;\n\n        int cch = 1 + lstrlenW(pszLibFile);\n        int cb = cch * sizeof(wchar_t);\n\n        pszLibFileRemote = (PWSTR)VirtualAllocEx(hProcess, NULL, cb, MEM_COMMIT, PAGE_READWRITE);\n        if (pszLibFileRemote == NULL)\n            __leave;\n\n        if (!WriteProcessMemory(hProcess, pszLibFileRemote, (PVOID)pszLibFile, cb, NULL))\n            __leave;\n\n        FARPROC pfnThreadRtn = GetProcAddress(GetModuleHandle(TEXT(\"Kernel32\")), \"LoadLibraryW\");\n        if (pfnThreadRtn == NULL)\n            __leave;\n\n        hThread = CreateRemoteThread(hProcess, NULL, 0, (PTHREAD_START_ROUTINE)pfnThreadRtn, pszLibFileRemote, 0, NULL);\n        if (hThread == NULL)\n            __leave;\n\n        WaitForSingleObject(hThread, INFINITE);\n\n        bOk = TRUE;\n    }\n    __finally\n    {\n        if (pszLibFileRemote != NULL)\n            VirtualFreeEx(hProcess, pszLibFileRemote, 0, MEM_RELEASE);\n\n        if (hThread != NULL)\n            CloseHandle(hThread);\n\n        if (hProcess != NULL)\n            CloseHandle(hProcess);\n    }\n\n    return bOk;\n}</code></pre>\n<p>EjectLib函数如下：</p>\n<pre><code class=\"language-cpp\">BOOL WINAPI EjectLib(DWORD processID, PCWSTR pszLibFile)\n{\n    BOOL bOk = FALSE;\n    HANDLE hthSnapshot = NULL;\n    HANDLE hProcess = NULL, hThread = NULL;\n    PWSTR pszLibFileRemote = NULL;\n\n    __try\n    {\n        //获取指定进程的快照，以及这些进程使用的堆、模块和线程。\n        hthSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, processID);\n        if (hthSnapshot == INVALID_HANDLE_VALUE)\n            __leave;\n\n        MODULEENTRY32W me = { sizeof(me) };\n        BOOL bFound = FALSE;\n        BOOL bMoreMods = Module32FirstW(hthSnapshot, &amp;me);  //检索与进程关联的第一个模块的信息。\n        for (; bMoreMods; bMoreMods = Module32NextW(hthSnapshot, &amp;me)) //检索与进程或线程关联的下一个模块的信息\n        {\n            bFound = (_wcsicmp(me.szModule, pszLibFile) == 0) || (_wcsicmp(me.szExePath, pszLibFile));\n            if (bFound)\n                break;\n        }\n\n        if (!bFound)\n            __leave;\n\n        hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_CREATE_THREAD |\n            PROCESS_VM_OPERATION, FALSE, processID);\n\n        if (hProcess == NULL)\n            __leave;\n\n        FARPROC pfnThreadRtn = GetProcAddress(GetModuleHandle(TEXT(\"Kernel32\")), \"FreeLibrary\");\n        if (pfnThreadRtn == NULL)\n            __leave;\n\n        //me.modBaseAddr 在所属进程的上下文中模块的基地址。\n        hThread = CreateRemoteThread(hProcess, NULL, 0, (PTHREAD_START_ROUTINE)pfnThreadRtn, me.modBaseAddr, 0, NULL);\n        if (hThread == NULL)\n            __leave;\n\n        WaitForSingleObject(hThread, INFINITE);\n\n        bOk = TRUE;\n    }\n    __finally\n    {\n        if (hthSnapshot != NULL)\n            CloseHandle(hthSnapshot);\n\n        if (hThread != NULL)\n            CloseHandle(hThread);\n\n        if (hProcess != NULL)\n            CloseHandle(hProcess);\n    }\n\n    return bOk;\n}</code></pre>\n<p><strong>3.3执行程序</strong></p>\n<p>打开一个记事本程序，找到PID，如下图所示，PID = 20752。</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\eae720c49ea744a5a89028549712a949.png\"/></p>\n<p></p>\n<p>运行3.2中的程序，输入这个PID，点击确定注入成功。</p>\n<p><strong>3.4运行结果</strong></p>\n<p>注入之后，在本地文件out.txt中，可以看见正在该记事本程序正在使用的DLL。</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\9938cfc932644fa9b1ac16f69ff5b2d1.png\"/></p>\n<p></p>\n</div>\n</div>"}