{"blogid": "126559861", "writerAge": "码龄6年", "writerBlogNum": "419", "writerCollect": "6914", "writerComment": "3070", "writerFan": "22142", "writerGrade": "8级", "writerIntegral": "27836", "writerName": "小码农叔叔", "writerProfileAdress": "writer_image\\profile_126559861.jpg", "writerRankTotal": "233", "writerRankWeekly": "60", "writerThumb": "2485", "writerVisitNum": "6586527", "blog_read_count": "4231", "blog_time": "已于 2022-08-28 10:40:58 修改", "blog_title": "springboot 整合谷歌 gRPC", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h1>前言</h1>\n<p>在前两篇，详细了解了谷歌gRPC的使用，以及gRPC实际使用中的几种通信模式，本篇通过实际案例了解下 gRPC与springboot的整合过程；</p>\n<p></p>\n<h1>整合过程</h1>\n<p></p>\n<p>案例为了模拟真实的场景，仍然分为Server端，和Client端，这个和前两篇保持一致，分为2个工程模块，服务端发布服务，客户端调服务，整体步骤和之前差不多；</p>\n<p></p>\n<p><img alt=\"\" height=\"85\" src=\"image\\94e5a516fe5c45318629170590f4bf19.png\" width=\"374\"/></p>\n<p></p>\n<p></p>\n<h2>一、服务端：grpc-server</h2>\n<h3></h3>\n<h3>1、导入maven相关依赖</h3>\n<p></p>\n<pre><code class=\"language-java\"> &lt;repositories&gt;\n        &lt;repository&gt;\n            &lt;id&gt;alimaven&lt;/id&gt;\n            &lt;name&gt;aliyun maven&lt;/name&gt;\n            &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;\n        &lt;/repository&gt;\n    &lt;/repositories&gt;\n\n    &lt;pluginRepositories&gt;\n        &lt;pluginRepository&gt;\n            &lt;id&gt;alimaven&lt;/id&gt;\n            &lt;name&gt;aliyun maven&lt;/name&gt;\n            &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;\n        &lt;/pluginRepository&gt;\n    &lt;/pluginRepositories&gt;\n\n    &lt;dependencies&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;net.devh&lt;/groupId&gt;\n            &lt;artifactId&gt;grpc-server-spring-boot-starter&lt;/artifactId&gt;\n            &lt;version&gt;2.13.0.RELEASE&lt;/version&gt;\n        &lt;/dependency&gt;\n\n    &lt;/dependencies&gt;\n\n    &lt;build&gt;\n        &lt;extensions&gt;\n            &lt;extension&gt;\n                &lt;groupId&gt;kr.motd.maven&lt;/groupId&gt;\n                &lt;artifactId&gt;os-maven-plugin&lt;/artifactId&gt;\n                &lt;version&gt;1.6.0&lt;/version&gt;\n            &lt;/extension&gt;\n        &lt;/extensions&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n                &lt;executions&gt;\n                    &lt;execution&gt;\n                        &lt;goals&gt;\n                            &lt;goal&gt;repackage&lt;/goal&gt;\n                        &lt;/goals&gt;\n                    &lt;/execution&gt;\n                &lt;/executions&gt;\n            &lt;/plugin&gt;\n\n            &lt;!--跳过test测试--&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n                &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;\n                &lt;configuration&gt;\n                    &lt;skip&gt;true&lt;/skip&gt;\n                &lt;/configuration&gt;\n            &lt;/plugin&gt;\n\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.xolstice.maven.plugins&lt;/groupId&gt;\n                &lt;artifactId&gt;protobuf-maven-plugin&lt;/artifactId&gt;\n                &lt;version&gt;0.6.1&lt;/version&gt;\n                &lt;configuration&gt;\n                    &lt;protocArtifact&gt;com.google.protobuf:protoc:3.5.1:exe:${os.detected.classifier}&lt;/protocArtifact&gt;\n                    &lt;pluginId&gt;grpc-java&lt;/pluginId&gt;\n                    &lt;pluginArtifact&gt;io.grpc:protoc-gen-grpc-java:1.11.0:exe:${os.detected.classifier}&lt;/pluginArtifact&gt;\n                    &lt;!--默认值--&gt;\n                    &lt;protoSourceRoot&gt;${project.basedir}/src/main/proto&lt;/protoSourceRoot&gt;\n                    &lt;!--默认值--&gt;\n                    &lt;!--&lt;outputDirectory&gt;${project.build.directory}/generated-sources/protobuf/java&lt;/outputDirectory&gt;--&gt;\n                    &lt;outputDirectory&gt;${project.basedir}/src/main/java&lt;/outputDirectory&gt;\n                    &lt;!--设置是否在生成java文件之前清空outputDirectory的文件，默认值为true，设置为false时也会覆盖同名文件--&gt;\n                    &lt;clearOutputDirectory&gt;false&lt;/clearOutputDirectory&gt;\n                &lt;/configuration&gt;\n                &lt;executions&gt;\n                    &lt;execution&gt;\n                        &lt;!--在执行mvn compile的时候会执行以下操作--&gt;\n                        &lt;phase&gt;compile&lt;/phase&gt;\n                        &lt;goals&gt;\n                            &lt;!--生成OuterClass类--&gt;\n                            &lt;goal&gt;compile&lt;/goal&gt;\n                            &lt;!--生成Grpc类--&gt;\n                            &lt;goal&gt;compile-custom&lt;/goal&gt;\n                        &lt;/goals&gt;\n                    &lt;/execution&gt;\n                &lt;/executions&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;</code></pre>\n<p></p>\n<h3>2、创建proto目录并定义proto服务文件 </h3>\n<p></p>\n<p>通过前两篇的学习，相信大家对这个服务文件的定义应该非常熟悉了，服务端提供一个 hello的服务接口，入参和出参均为字符串；</p>\n<pre><code class=\"language-bash\">\nsyntax = \"proto3\";\n\noption java_multiple_files = false;\n\noption java_package = \"com.congge.news.proto\";\n\noption java_outer_classname = \"NewsProto\";\n\npackage news;\n\nservice NewsService {\n    rpc hello(StringRequest) returns (StringResponse){}\n}\n\nmessage StringRequest{\n    string name = 1;\n}\n\nmessage StringResponse{\n    string result = 1;\n}\n\n</code></pre>\n<p></p>\n<h3>3、编译并生成服务端相关的服务目录和类文件</h3>\n<p></p>\n<p>依次点击下面两个按钮，生成服务相关的文件</p>\n<p></p>\n<p><img alt=\"\" height=\"475\" src=\"image\\fe7fe755a5c542e287fec76b9fc22ca0.png\" width=\"469\"/></p>\n<p></p>\n<p><img alt=\"\" height=\"129\" src=\"image\\c4ffa32d344149f0af181e8e3cee2884.png\" width=\"384\"/></p>\n<p></p>\n<h3>4、重写服务接口的方法</h3>\n<p></p>\n<p>在该方法中，就是具体编写服务接口方法实现的逻辑，实际开发中，就是实际要关注业务逻辑的位置；</p>\n<pre><code class=\"language-java\">import com.congge.news.proto.NewsProto;\nimport com.congge.news.proto.NewsServiceGrpc;\nimport io.grpc.stub.StreamObserver;\nimport net.devh.boot.grpc.server.service.GrpcService;\n\n@GrpcService\npublic class NewsService extends NewsServiceGrpc.NewsServiceImplBase {\n\n    @Override\n    public void hello(NewsProto.StringRequest request, StreamObserver&lt;NewsProto.StringResponse&gt; responseObserver) {\n        String name = request.getName();\n        NewsProto.StringResponse response = NewsProto.StringResponse.newBuilder().setResult(\"hello :\" + name).build();\n        responseObserver.onNext(response);\n        responseObserver.onCompleted();\n    }\n}</code></pre>\n<p></p>\n<h3>5、配置文件</h3>\n<p></p>\n<pre><code class=\"language-java\">spring:\n  application:\n    name: rpc-server\n\ngrpc:\n  server:\n    port: 9988\n\nserver:\n  port: 8088</code></pre>\n<p></p>\n<h3>6、提供一个启动类并启动服务</h3>\n<p>通过启动日志可以发现，服务端自身的web端口以及grpc服务监听的端口都已经生效；</p>\n<p><img alt=\"\" height=\"569\" src=\"image\\72cb23909c944d9db387eea6f9275436.png\" width=\"1200\"/></p>\n<p></p>\n<p>到这里，服务端的整合过程就基本完成了，接下来看客户端的整合步骤吧；</p>\n<p></p>\n<h2>二、服务端：grpc-client</h2>\n<p></p>\n<h3>1、导入依赖</h3>\n<p>同上</p>\n<p></p>\n<h3>2、创建proto目录并定义proto服务文件 </h3>\n<p>同上</p>\n<p></p>\n<h3>3、编译并生成服务端相关的服务目录和类文件</h3>\n<p>同上</p>\n<p></p>\n<h3>4、配置文件</h3>\n<p></p>\n<pre><code class=\"language-java\">spring:\n  application:\n    name: rpc-client\n\ngrpc:\n  client:\n    grpc-server:\n      address: 'static://127.0.0.1:9988'\n      negotiationType: plaintext\n\nserver:\n  port: 8087</code></pre>\n<p></p>\n<h3>5、提供一个web接口</h3>\n<p></p>\n<p>为了模拟外部的接口调用，这里提供一个用于测试的web接口，在接口中远程调用服务端的服务接口；</p>\n<p></p>\n<pre><code class=\"language-java\">@RestController\npublic class NewsController {\n\n    @GrpcClient(\"grpc-server\")\n    private NewsServiceGrpc.NewsServiceBlockingStub newsServiceBlockingStub;\n\n    @GetMapping(\"/hello\")\n    public String hello(String name) {\n        NewsProto.StringResponse response = newsServiceBlockingStub.hello(NewsProto.StringRequest.newBuilder().setName(name).build());\n        return response.getResult();\n    }\n\n}</code></pre>\n<p></p>\n<h3>6、提供一个启动类并启动服务</h3>\n<p></p>\n<p><img alt=\"\" height=\"466\" src=\"image\\5d8c107fb635495e805cbfa62ea29d4c.png\" width=\"1200\"/></p>\n<p></p>\n<p>浏览器调用下上面的客户端提供的接口进行测试，效果如下：</p>\n<p></p>\n<p><img alt=\"\" height=\"158\" src=\"image\\f760e5e54a124e56bb074a749457f495.png\" width=\"643\"/></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n</div>\n</div>"}