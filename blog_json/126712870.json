{"blogid": "126712870", "writerAge": "码龄15年", "writerBlogNum": "330", "writerCollect": "11548", "writerComment": "7657", "writerFan": "27726", "writerGrade": "8级", "writerIntegral": "34587", "writerName": "dvlinker", "writerProfileAdress": "writer_image\\profile_126712870.jpg", "writerRankTotal": "145", "writerRankWeekly": "5", "writerThumb": "9964", "writerVisitNum": "4624561", "blog_read_count": "1731", "blog_time": "于 2022-09-05 20:57:47 发布", "blog_title": "C/C++编程新手容易犯的10种编程错误", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"1%E3%80%81%E6%9C%89%E4%BA%9B%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8D%E7%94%A8%E5%86%99%E5%9C%A8cpp%E4%B8%AD-toc\" style=\"margin-left:40px;\"><a href=\"#1%E3%80%81%E6%9C%89%E4%BA%9B%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8D%E7%94%A8%E5%86%99%E5%9C%A8cpp%E4%B8%AD\">1、有些关键字不用写在cpp中</a></p>\n<p id=\"2%E3%80%81%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC%E5%86%99%E5%88%B0%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E4%B8%AD%E4%BA%86-toc\" style=\"margin-left:40px;\"><a href=\"#2%E3%80%81%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC%E5%86%99%E5%88%B0%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E4%B8%AD%E4%BA%86\">2、函数参数的默认值写到函数实现中了</a></p>\n<p id=\"3%E3%80%81%E5%9C%A8%E7%BC%96%E5%86%99%E7%B1%BB%E6%97%B6%EF%BC%8C%E5%9C%A8%E7%B1%BB%E7%9A%84%E7%BB%93%E5%B0%BE%E5%A4%84%E5%BF%98%E8%AE%B0%E6%B7%BB%E5%8A%A0%22%3B%22%E5%88%86%E5%8F%B7%E4%BA%86-toc\" style=\"margin-left:40px;\"><a href=\"#3%E3%80%81%E5%9C%A8%E7%BC%96%E5%86%99%E7%B1%BB%E6%97%B6%EF%BC%8C%E5%9C%A8%E7%B1%BB%E7%9A%84%E7%BB%93%E5%B0%BE%E5%A4%84%E5%BF%98%E8%AE%B0%E6%B7%BB%E5%8A%A0%22%3B%22%E5%88%86%E5%8F%B7%E4%BA%86\">3、在编写类时，在类的结尾处忘记添加\";\"分号了</a></p>\n<p id=\"4%E3%80%81%E5%8F%AA%E6%B7%BB%E5%8A%A0%E4%BA%86%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%EF%BC%8C%E6%B2%A1%E6%9C%89%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0-toc\" style=\"margin-left:40px;\"><a href=\"#4%E3%80%81%E5%8F%AA%E6%B7%BB%E5%8A%A0%E4%BA%86%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%EF%BC%8C%E6%B2%A1%E6%9C%89%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0\">4、只添加了函数声明，没有函数实现</a></p>\n<p id=\"5%E3%80%81cpp%E6%96%87%E4%BB%B6%E5%BF%98%E8%AE%B0%E6%B7%BB%E5%8A%A0%E5%88%B0%E5%B7%A5%E7%A8%8B%E4%B8%AD%EF%BC%8C%E5%AF%BC%E8%87%B4%E6%B2%A1%E6%9C%89%E7%94%9F%E6%88%90%E4%BE%9B%E9%93%BE%E6%8E%A5%E4%BD%BF%E7%94%A8%E7%9A%84obj%E6%96%87%E4%BB%B6-toc\" style=\"margin-left:40px;\"><a href=\"#5%E3%80%81cpp%E6%96%87%E4%BB%B6%E5%BF%98%E8%AE%B0%E6%B7%BB%E5%8A%A0%E5%88%B0%E5%B7%A5%E7%A8%8B%E4%B8%AD%EF%BC%8C%E5%AF%BC%E8%87%B4%E6%B2%A1%E6%9C%89%E7%94%9F%E6%88%90%E4%BE%9B%E9%93%BE%E6%8E%A5%E4%BD%BF%E7%94%A8%E7%9A%84obj%E6%96%87%E4%BB%B6\">5、cpp文件忘记添加到工程中，导致没有生成供链接使用的obj文件</a></p>\n<p id=\"6%E3%80%81%E5%87%BD%E6%95%B0%E4%B8%AD%E8%BF%94%E5%9B%9E%E4%BA%86%E4%B8%80%E4%B8%AA%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%9C%B0%E5%9D%80%E6%88%96%E8%80%85%E5%BC%95%E7%94%A8-toc\" style=\"margin-left:40px;\"><a href=\"#6%E3%80%81%E5%87%BD%E6%95%B0%E4%B8%AD%E8%BF%94%E5%9B%9E%E4%BA%86%E4%B8%80%E4%B8%AA%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%9C%B0%E5%9D%80%E6%88%96%E8%80%85%E5%BC%95%E7%94%A8\">6、函数中返回了一个局部变量的地址或者引用</a></p>\n<p id=\"7%E3%80%81%E5%BF%98%E8%AE%B0%E5%B0%86%E7%88%B6%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%A3%B0%E6%98%8Evirtual%E5%87%BD%E6%95%B0%EF%BC%8C%E5%AF%BC%E8%87%B4%E5%A4%9A%E6%80%81%E6%B2%A1%E6%9C%89%E7%94%9F%E6%95%88-toc\" style=\"margin-left:40px;\"><a href=\"#7%E3%80%81%E5%BF%98%E8%AE%B0%E5%B0%86%E7%88%B6%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%A3%B0%E6%98%8Evirtual%E5%87%BD%E6%95%B0%EF%BC%8C%E5%AF%BC%E8%87%B4%E5%A4%9A%E6%80%81%E6%B2%A1%E6%9C%89%E7%94%9F%E6%95%88\">7、忘记将父类中的接口声明virtual函数，导致多态没有生效</a></p>\n<p id=\"8%E3%80%81%E8%AF%A5%E4%BD%BF%E7%94%A8%E5%8F%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%9C%B0%E6%96%B9%EF%BC%8C%E5%8D%B4%E4%BD%BF%E7%94%A8%E4%BA%86%E5%8D%95%E6%8C%87%E9%92%88-toc\" style=\"margin-left:40px;\"><a href=\"#8%E3%80%81%E8%AF%A5%E4%BD%BF%E7%94%A8%E5%8F%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%9C%B0%E6%96%B9%EF%BC%8C%E5%8D%B4%E4%BD%BF%E7%94%A8%E4%BA%86%E5%8D%95%E6%8C%87%E9%92%88\">8、该使用双指针的地方，却使用了单指针</a></p>\n<p id=\"9%E3%80%81%E5%8F%91%E5%B8%83exe%E7%A8%8B%E5%BA%8F%E6%97%B6%EF%BC%8C%E5%BF%98%E8%AE%B0%E5%B0%86exe%E4%BE%9D%E8%B5%96%E7%9A%84C%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BA%93%E6%88%96MFC%E5%BA%93%E5%B8%A6%E4%B8%8A%E4%BA%86-toc\" style=\"margin-left:40px;\"><a href=\"#9%E3%80%81%E5%8F%91%E5%B8%83exe%E7%A8%8B%E5%BA%8F%E6%97%B6%EF%BC%8C%E5%BF%98%E8%AE%B0%E5%B0%86exe%E4%BE%9D%E8%B5%96%E7%9A%84C%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BA%93%E6%88%96MFC%E5%BA%93%E5%B8%A6%E4%B8%8A%E4%BA%86\">9、发布exe程序时，忘记将exe依赖的C运行时库或MFC库带上了</a></p>\n<p id=\"10%E3%80%81%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8%E6%B7%B1%E6%8B%B7%E8%B4%9D%EF%BC%8C%E5%8D%B4%E7%94%A8%E4%BA%86%E6%B5%85%E6%8B%B7%E8%B4%9D-toc\" style=\"margin-left:40px;\"><a href=\"#10%E3%80%81%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8%E6%B7%B1%E6%8B%B7%E8%B4%9D%EF%BC%8C%E5%8D%B4%E7%94%A8%E4%BA%86%E6%B5%85%E6%8B%B7%E8%B4%9D\">10、应该使用深拷贝，却用了浅拷贝</a></p>\n<hr id=\"hr-toc\"/>\n<p>       IT公司每年都会有一定的人员流动，相应地也会招一些应届生补充进来，指导应届生已经成为老员工的必修课了。平日里我们会经常帮新人看代码中的问题，在此过程中发现了C/C++新手容易犯的一些编程错误，在此简单的总结一下，给新人们一个参考。 </p>\n<p class=\"img-center\"><img alt=\"\" height=\"275\" src=\"image\\448af3e329f04a049d278b838481e6ea.png\" width=\"541\"/></p>\n<h2 id=\"1%E3%80%81%E6%9C%89%E4%BA%9B%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8D%E7%94%A8%E5%86%99%E5%9C%A8cpp%E4%B8%AD\">1、有些关键字不用写在cpp中</h2>\n<p>       对于C++类，一些关键字只要写在.h中就好，cpp中就不用再加上了，比如virtual、static等关键字，如果再cpp中多写，编译器会报错。比如如下的虚接口与静态成员变量的定义，只要在头文件中声明就可以了。</p>\n<pre><code class=\"language-cpp\">class shape\n{\n    virtual Draw();\n    //...\n    static int nLevel;\n}</code></pre>\n<h2 id=\"2%E3%80%81%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC%E5%86%99%E5%88%B0%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E4%B8%AD%E4%BA%86\">2、函数参数的默认值写到函数实现中了</h2>\n<p>        带有参数默认值的函数，默认值是加在函数声明处的，函数实现处的参数是不需要带上的。为了方便查看代码，在函数实现处的参数中，将默认值注释起来。</p>\n<p>       正确的做法是，头文件中有默认值：</p>\n<pre><code class=\"language-cpp\">BOOL CreateConf( const CString&amp; strConfName, const BOOL bAudio = FALSE );</code></pre>\n<p>      在函数实现处的参数中不用添加默认值：</p>\n<pre><code class=\"language-cpp\">BOOL CreateConf( const CString&amp; strConfName, const BOOL bAudio/* = FALSE*/ );\n{\n    // ......\n}</code></pre>\n<h2 id=\"3%E3%80%81%E5%9C%A8%E7%BC%96%E5%86%99%E7%B1%BB%E6%97%B6%EF%BC%8C%E5%9C%A8%E7%B1%BB%E7%9A%84%E7%BB%93%E5%B0%BE%E5%A4%84%E5%BF%98%E8%AE%B0%E6%B7%BB%E5%8A%A0%22%3B%22%E5%88%86%E5%8F%B7%E4%BA%86\">3、在编写类时，在类的结尾处忘记添加\";\"分号了</h2>\n<p>        在类的结尾处忘记添加分号，编译会报错。新人们有可能找了半天，也没找出引起编译错误的原因。其实很简单，在类的结尾处忘记添加分号了。</p>\n<pre><code class=\"language-cpp\">class Shape\n{\n    // ...\n};</code></pre>\n<h2 id=\"4%E3%80%81%E5%8F%AA%E6%B7%BB%E5%8A%A0%E4%BA%86%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%EF%BC%8C%E6%B2%A1%E6%9C%89%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0\">4、只添加了函数声明，没有函数实现</h2>\n<p>       在添加类的函数时，只在类的头文件中添加了函数声明，但在cpp中却没有添加函数的实现。如果其他地方调用到该函数，在编译链接的时候会报 unresolved external symbol错误。因为没有实现，所有没有供链接使用的obj文件。</p>\n<blockquote>\n<p>在头文件添加的函数声明，在编译时会用到声明；在cpp文件添加的函数实现，会编译成函数符号，在链接的时候会用到。</p>\n</blockquote>\n<h2 id=\"5%E3%80%81cpp%E6%96%87%E4%BB%B6%E5%BF%98%E8%AE%B0%E6%B7%BB%E5%8A%A0%E5%88%B0%E5%B7%A5%E7%A8%8B%E4%B8%AD%EF%BC%8C%E5%AF%BC%E8%87%B4%E6%B2%A1%E6%9C%89%E7%94%9F%E6%88%90%E4%BE%9B%E9%93%BE%E6%8E%A5%E4%BD%BF%E7%94%A8%E7%9A%84obj%E6%96%87%E4%BB%B6\">5、cpp文件忘记添加到工程中，导致没有生成供链接使用的obj文件</h2>\n<p>       在添加C++类时，我们一般会添加一个.h头文件和一个对应的.cpp源文件。如果忘记把.cpp文件添加到工程中了，即没有参与编译，没有生成供链接使用的obj文件。如果有代码调用到该C++类的接口，则在编译链接的时候会报 unresolved external symbol错误，即链接不到该C++类对应的接口。这个问题也经常会遇到。</p>\n<h2 id=\"6%E3%80%81%E5%87%BD%E6%95%B0%E4%B8%AD%E8%BF%94%E5%9B%9E%E4%BA%86%E4%B8%80%E4%B8%AA%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%9C%B0%E5%9D%80%E6%88%96%E8%80%85%E5%BC%95%E7%94%A8\">6、函数中返回了一个局部变量的地址或者引用</h2>\n<p>       <span style=\"color:#1a439c;\"><strong>在函数中返回了一个局部变量的地址或者引用，而这个局部变量在函数结束时其生命周期就结束了</strong></span>，内存就被释放了。当外部访问到传出的地址或引用时，就访问了已经释放的内存，就会触发内存访问违例的异常，因为该变量的内存已经释放了。比如如下的错误代码：</p>\n<pre><code class=\"language-cpp\">char* GetResult()\n{\n    char chResult[100] = { 0 };\n \n    // ......\n \n    return chResult;\n}</code></pre>\n<p>这是编程新手容易犯的错误，主要是对变量的声明周期理解的不到位导致的。 </p>\n<h2 id=\"7%E3%80%81%E5%BF%98%E8%AE%B0%E5%B0%86%E7%88%B6%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%A3%B0%E6%98%8Evirtual%E5%87%BD%E6%95%B0%EF%BC%8C%E5%AF%BC%E8%87%B4%E5%A4%9A%E6%80%81%E6%B2%A1%E6%9C%89%E7%94%9F%E6%95%88\">7、忘记将父类中的接口声明virtual函数，导致多态没有生效</h2>\n<p>       代码中本来要借助于C++多态的虚函数调用机制，最终要调用子类实现的接口，结果忘记在父类中将对应的接口声明为virtual，导致形成多态的机制，没有调用到子类实现的函数。</p>\n<p>       <span style=\"color:#1a439c;\"><strong> 一定要记住，要实现多态下的函数调用，父类的相关接口必须声明为virtual。</strong></span></p>\n<pre><code class=\"language-cpp\">class Shape()\n{\n    // ...\n \n    virtual void Draw();\n \n    // ...\n} </code></pre>\n<p>多态是C++中核心概念之一，代码到处都有多态的身影，一定要吃透多态的概念，理解虚函数调用是如何实现的。关于C++多态中虚函数的调用，可以参见文章：</p>\n<p><a class=\"link-info has-card\" href=\"https://blog.csdn.net/chenlycly/article/details/121046234\" title=\"几秒读懂C++虚函数调用的汇编代码实现\"><span class=\"link-card-box\"><span class=\"link-title\">几秒读懂C++虚函数调用的汇编代码实现</span><span class=\"link-link\"><img alt=\"icon-default.png?t=M7J4\" class=\"link-link-icon\" src=\"image\\icon-default.png\"/>https://blog.csdn.net/chenlycly/article/details/121046234</span></span></a></p>\n<h2 id=\"8%E3%80%81%E8%AF%A5%E4%BD%BF%E7%94%A8%E5%8F%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%9C%B0%E6%96%B9%EF%BC%8C%E5%8D%B4%E4%BD%BF%E7%94%A8%E4%BA%86%E5%8D%95%E6%8C%87%E9%92%88\">8、该使用双指针的地方，却使用了单指针</h2>\n<p>       有时，我们需要调用一个接口去获取某些数据，<span style=\"color:#1a439c;\"><strong>接口中将数据拷贝到传入的参数对应的内存中，此时设计参数时会传入指针或引用。</strong></span></p>\n<p><span style=\"color:#1a439c;\"><strong>       </strong></span>比如，我们在调用GetData之前定义了结构体指针p，并new出了对应的结构体对象内存，应该在定义GetData接口时应该使用双指针（指针的指针）的，结果错写成了单指针。有问题的代码如下：</p>\n<pre><code class=\"language-cpp\">struct CodecInfo     // 编码信息\n{\n    int nFrameRate；\n \n    // ...\n}；\n \n \nCodecInfo* pInfo = new CodecInfo;\n// 出问题的点\nGetAudioCodecPtr()-&gt;GetCodecInfo(pInfo);   // 调用AudioCodec::GetCodecInfo获取编码信息\n \n \nAudioCodec::GetCodecInfo( CodecInfo* pInfo)  // 此处的参数不应该使用单指针\n{\n    memcpy(pInfo, m_codecInfo, sizeof(CodecInfo));\n}</code></pre>\n<p>       上图中的AudioCodec::GetCodecInfo接口的参数不应该为单指针，应该用双指针，修改后的代码应该如下：</p>\n<pre><code class=\"language-cpp\">AudioCodec::GetCodecInfo( CodecInfo** pInfo)  // 此处的参数类型使用双指针\n{\n    memcpy(*pInfo, m_codecInfo, sizeof(CodecInfo));\n}\n\n</code></pre>\n<h2 id=\"9%E3%80%81%E5%8F%91%E5%B8%83exe%E7%A8%8B%E5%BA%8F%E6%97%B6%EF%BC%8C%E5%BF%98%E8%AE%B0%E5%B0%86exe%E4%BE%9D%E8%B5%96%E7%9A%84C%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BA%93%E6%88%96MFC%E5%BA%93%E5%B8%A6%E4%B8%8A%E4%BA%86\">9、发布exe程序时，忘记将exe依赖的C运行时库或MFC库带上了</h2>\n<p>       比如新人用VS-MFC库编写一个测试用的工具软件，结果在发布release版本程序时，没有将程序依赖的C运行时库带上，导致该工具软件在某些电脑中启动报错，提示找不到C运行时库：</p>\n<p class=\"img-center\"><img alt=\"\" height=\"168\" src=\"image\\af516d9b354648249080919c8dd627b6.png\" width=\"522\"/></p>\n<p>因为程序中依赖了动态版本的运行时库和MFC库，在发布程序时要将这些库带上。有些系统中没有这些库，程序启动时就会报找不到库，就会启动失败。没有经验的新手很容易犯这样的错误。</p>\n<h2 id=\"10%E3%80%81%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8%E6%B7%B1%E6%8B%B7%E8%B4%9D%EF%BC%8C%E5%8D%B4%E7%94%A8%E4%BA%86%E6%B5%85%E6%8B%B7%E8%B4%9D\">10、应该使用深拷贝，却用了浅拷贝</h2>\n<p>       本来应该要进行深拷贝的，却使用了浅拷贝（直接赋值），<span style=\"color:#1a439c;\"><strong>导致另个不同生命周期的C++对象指向了同一块内存，一个对象将内存释放后，另一个对象再用到这块内存，就造成了内存访问违例，产生异常。</strong></span></p>\n<p>       有个很经典的C++笔试题，让我们实现String类的相关函数，其主要目的就是用来考察对深拷贝与浅拷贝的理解的。题目中给出String类的声明：</p>\n<pre><code class=\"language-cpp\">class String{\npublic:\n    String();\n    String(const String &amp; str);\n    String(const char* str);\n    String&amp; operator=(String str);\n    char* c_str() const;\n    ~String();\n    int size() const;\nprivate:\n    char* data;\n};</code></pre>\n<p>让写出上述几个函数的内部实现。这些函数的实现代码如下：</p>\n<pre><code class=\"language-cpp\">// 1、普通构造函数  \nString::String(const char *str)\n{\n    if (str == NULL)\n    {\n        m_data = new char[1];// 得分点：对空字符串自动申请存放结束标志'\\0'的，加分点：对m_data加NULL判断  \n        *m_data = '\\0';\n    }\n    else\n    {\n        int length = strlen(str);\n        m_data = new char[length + 1];// 若能加 NULL 判断则更好\n        strcpy(m_data, str);\n    }\n}\n \n \n// 2、String的析构函数  \nString::~String(void)\n{\n    delete[] m_data; // 或delete m_data;  \n}\n \n \n// 3、拷贝构造函数  \nString::String(const String &amp;other)// 得分点：输入参数为const型  \n{         \n    int length = strlen(other.m_data);\n    m_data = new char[length + 1];// 若能加 NULL 判断则更好  \n    strcpy(m_data, other.m_data);\n}\n \n \n// 4、赋值函数  \nString &amp; String::operator = (const String &amp;other) // 得分点：输入参数为const型  \n{\n    if (this == &amp;other)//得分点：检查自赋值  \n        return *this; \n    if (m_data)\n        delete[] m_data;//得分点：释放原有的内存资源  \n    int length = strlen(other.m_data);\n    m_data = new char[length + 1];//加分点：对m_data加NULL判断  \n    strcpy(m_data, other.m_data);\n    return *this;//得分点：返回本对象的引用    \n}</code></pre>\n</div>\n</div>"}