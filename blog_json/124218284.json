{"blogid": "124218284", "writerAge": "码龄6年", "writerBlogNum": "621", "writerCollect": "16507", "writerComment": "862", "writerFan": "86643", "writerGrade": "8级", "writerIntegral": "42772", "writerName": "bitcarmanlee", "writerProfileAdress": "writer_image\\profile_124218284.jpg", "writerRankTotal": "99", "writerRankWeekly": "380", "writerThumb": "5381", "writerVisitNum": "8397247", "blog_read_count": "2314", "blog_time": "于 2022-04-16 19:08:28 发布", "blog_title": "c++三种实例化对象方式", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-tomorrow-night\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h2><a id=\"1_0\"></a>1.隐式创建</h2>\n<p>首先我们定义一个测试类</p>\n<pre><code>class Person {\n    private:\n      int age;\n      string name;\n    public:\n        Person() {\n            cout&lt;&lt;\"this is construct~\";\n        }\n        Person(int age, string name) {\n            this-&gt;age = age;\n            this-&gt;name = name;\n            cout&lt;&lt;\"name is: \"&lt;&lt;name&lt;&lt;\", age is: \"&lt;&lt;age&lt;&lt;endl;\n        }\n};\n</code></pre>\n<p>然后我们在main方法中隐式创建Person对象</p>\n<pre><code>Person p1;\ncout&lt;&lt;endl;\nPerson p2(18, \"lili\");\ncout&lt;&lt;endl;\n</code></pre>\n<h2><a id=\"2_29\"></a>2.显示创建</h2>\n<p>当然，我们也可以像其他编程语言一样，显示创建一个对象</p>\n<pre><code>Person p3 = Person();\ncout&lt;&lt;endl;\nPerson p4 = Person(16, \"xx\");\ncout&lt;&lt;endl;\n</code></pre>\n<p>这种方式，与上面的第一种方式原理基本一直。</p>\n<h2><a id=\"3new_40\"></a>3.用new创建</h2>\n<p>当然我们还可以用new关键字来创建对象</p>\n<pre><code>Person *p5 = new Person();\ncout&lt;&lt;endl;\nPerson *p6 = new Person(14, \"yy\");\n</code></pre>\n<p>注意new出来的对象，都需要用指针接收。</p>\n<h2><a id=\"4_51\"></a>4.上述三种方式的区别</h2>\n<p>上面三种方式可以认为是两种方式，因为第一种方式与第二种方式基本相同。那么具体区别在哪里？</p>\n<p>1.new出来的对象必须要用指针接收，并且需要显式delete销毁对象释放内存。</p>\n<p>2.内存位置不同。<br/> 对于隐式声明</p>\n<pre><code>Person p1;\n</code></pre>\n<p>p1对象位于栈空间。</p>\n<pre><code>Person *p5 = new Person();\n</code></pre>\n<p>p5对象位于堆空间。</p>\n<p>3.内存分配时间不同<br/> 使用隐式创建对象的时候，创建支出就已经分配了内存。而使用new的方式，如果对象没有初始化，此时没有分配内存空间，也无法delete。</p>\n<pre><code>Person *p = NULL;\ndelete p;\n</code></pre>\n<p>上述语句如果执行，会有各种意想不到的情况发生。</p>\n<p>4.隐式声明的对象是局部变量，出了函数就没有了。而new出来的指针对象可以在方法之间传递，且该指针对象所指向的堆中的对象实例仍然存在。</p>\n<p>5.频繁调用场合并不适合new，就像new申请和释放内存一样。</p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}