{"blogid": "124308972", "writerAge": "码龄1年", "writerBlogNum": "21", "writerCollect": "49", "writerComment": "2", "writerFan": "14", "writerGrade": "2级", "writerIntegral": "256", "writerName": "凸头拯救地球", "writerProfileAdress": "writer_image\\profile_124308972.jpg", "writerRankTotal": "56281", "writerRankWeekly": "16806", "writerThumb": "44", "writerVisitNum": "11365", "blog_read_count": "3197", "blog_time": "已于 2022-04-21 23:32:43 修改", "blog_title": "python装饰器这一篇就够了", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h2>前言</h2>\n<ol><li> <h3>什么是装饰器</h3> </li><li> <h3>实现原理</h3> </li><li> <h3>实现效果</h3> </li><li> <h3>适用场景</h3> </li></ol>\n<h3>装饰器：</h3>\n<ol><li> <h3>装饰器的写法</h3> </li><li> <h3>装饰器的拓展 </h3> </li><li> <h3>装饰器的模板</h3> </li></ol>\n<hr/>\n<p></p>\n<ul><li> <h3>什么是装饰器呢？ </h3> </li></ul>\n<p>就是在特定条件下为某些函数再不改动函数体的时候为函数新添加一些功能，这就是装饰器</p>\n<ul><li> <h3> 实现原理：</h3> </li></ul>\n<p>基于@语法和函数闭包，将原函数封装在闭包中，然后将函数赋值为一个新的函数（内置函数），执行函数时再在内层函数中执行闭包中的原函数</p>\n<ul><li> <h3>实现效果：</h3> </li></ul>\n<p>可以在你改变函数内部代码和调用的前提下，实现在函数执行和执行拓展功能</p>\n<ul><li> <h3>适用场景： </h3> </li></ul>\n<p>多个函数系统统一在执行前后定义一些功能</p>\n<h3>关于前言我们了解这么多就够了，然后小编带着大家推导出装饰器</h3>\n<hr/>\n<h2>装饰器：</h2>\n<ul><li> <h3>装饰器的写法：</h3> </li></ul>\n<p>这里我们有一个需求，我们定义了5个函数，想在5个函数执行前和执行后都打印一句话：装饰器的学习。首先我们来写于一下没有装饰器的写法，话不多说直接上代码：</p>\n<pre><code class=\"language-python\">def a():\n    pass\n\n\ndef b():\n    pass\n\n\ndef c():\n    pass\n\n\ndef d():\n    pass\n\n\ndef e():\n    pass</code></pre>\n<p> 先定义5个函数，再加上我们要打印的话：</p>\n<pre><code class=\"language-python\">def a():\n    print(\"装饰器的学习\")\n    print(\"装饰器的学习\")\n\n\ndef b():\n    print(\"装饰器的学习\")\n    print(\"装饰器的学习\")\n\n\ndef c():\n    print(\"装饰器的学习\")\n    print(\"装饰器的学习\")\n\n\ndef d():\n    print(\"装饰器的学习\")\n    print(\"装饰器的学习\")\n\n\ndef e():\n    print(\"装饰器的学习\")\n    pass\n    print(\"装饰器的学习\")\n\n\na()\nb()\nc()\nd()\ne()</code></pre>\n<p>运行一下：</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\8f7a5997dc5347f9859af52aa744a018.png\"/></p>\n<p> 发现运行成功，但我们想如果我要修改打印的话就要都修改一次，特别麻烦，而且，这是5个函数如果是500个，我们还要一个一个的去加吗？这就有我们的装饰器了，首先我用装饰器修改下，再给大家解释。</p>\n<pre><code class=\"language-python\">def outer(origin):\n    def inner():\n        print(\"装饰器的学习\")\n        res = origin()\n        print(\"装饰器的学习\")\n        return res\n\n    return inner\n\n\n@outer\ndef a():\n    pass\n\n\n@outer\ndef b():\n    pass\n\n\n@outer\ndef c():\n    pass\n\n\n@outer\ndef d():\n    pass\n\n\n@outer\ndef e():\n    pass\n\n\na()\nb()\nc()\nd()\ne()\n</code></pre>\n<p>运行一下：</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\32928c1fecdd442db0b0723afef595bc.png\"/></p>\n<p>发现这样我们也成功了，接下来小编来个大家解释</p>\n<ul><li>首先： </li></ul>\n<p>我们要明白@的作用，那我们的函数a来举例子@的作用就是帮我们执行一次a=outer(a)，首先python将把我们的a变成参数传给outer函数，运行后再赋值给a，这就是@的作用。</p>\n<ul><li>其次给大家解释一下自定的outer函数 </li></ul>\n<p>我自己称这个函数为@下函数的补丁函数，也就是装饰器函数还是拿a函数举例子，首先a函数变成参数传给了我们的outer函数，outer里又嵌套了一个inner函数 ，然后将函数a赋值给res，然后用return语句返回出结果，外层函数返回inner函数，也就是将inner函数运行一次，这就是工作流程。</p>\n<ul><li>最后分别在各函数前加上装饰，最后运行出结果</li><li style=\"text-align:center;\"><img alt=\"\" src=\"image\\a0497cf3505f40fca47e8c43147a8ed3.png\"/></li></ul>\n<p> 这就是装饰器的写法。</p>\n<ul><li>装饰器的参数</li></ul>\n<p>这时我遇到一个问题如果函数内有参数而且每个函数的参数数量不同，我们应该怎末办，先看下面代码</p>\n<pre><code class=\"language-python\">def outer(origin):\n    def inner():\n        print(\"装饰器的学习\")\n        res = origin()\n        print(\"装饰器的学习\")\n        return res\n\n    return inner\n\n\n@outer\ndef a(g, e):\n    pass\n\n\n@outer\ndef b(w):\n    pass\n\n\n@outer\ndef c(u, y, t):\n    pass\n\n\n@outer\ndef d(c):\n    pass\n\n\n@outer\ndef e():\n    pass\n\n\na()\nb()\nc()\nd()\ne()</code></pre>\n<p> 这时我们运行一下</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\c85696bf61fd40ba938a32bd5b55115f.png\"/></p>\n<p> 发现报错，是因为我们的装饰器内没有这两个参数，那可以在装饰器内设置两个参数，但问题是，有的函数内有3个参数，而有的函数内没有参数，那我们应该怎么办？</p>\n<p>针对这个问题我们可以给装饰器设置动态参数，先看代码：</p>\n<pre><code class=\"language-python\">def outer(origin):\n    def inner(*args, **kwargs):\n        print(\"装饰器的学习\")\n        res = origin(*args, **kwargs)\n        print(\"装饰器的学习\")\n        return res\n\n    return inner\n\n\n@outer\ndef a(a1):\n    print(\"我是一函数\")\n\n\n@outer\ndef b(a1, a2):\n    print(\"我是二函数\")\n\n\n@outer\ndef c(a5, a6, a7):\n    print(\"我是三函数\")\n\n\na(1)\nb(2, 3)\nc(4, 5, 6)</code></pre>\n<p>因为函数太多了，小编有点麻烦就剪了几个函数，但道理是相同的，这时我们再运行一下</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\11ebe2769bf94fad8b78759635bd8ce8.png\"/></p>\n<p> 这样我们就成功了，以上就是装饰器的写法，接下来给大家拓展一下</p>\n<hr/>\n<ul><li> <h3>装饰器的拓展：（functools模块）</h3> </li></ul>\n<p>首先给大家引入一下这时教给大家几个魔法方法</p>\n<table align=\"left\" border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px;\"><tbody><tr><td style=\"width:127px;\">.__name__</td><td style=\"width:371px;\">获取函数名字</td></tr><tr><td style=\"width:127px;\">.__doc__</td><td style=\"width:371px;\">获取函数内的注释</td></tr></tbody></table>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p>接下来我们实战一下</p>\n<pre><code class=\"language-python\">def outer(origin):\n    def inner(*args, **kwargs):\n        # 我是一个装饰器函数\n        print(\"装饰器的学习\")\n        res = origin(*args, **kwargs)\n        print(\"装饰器的学习\")\n        return res\n\n    return inner\n\n\n@outer\ndef c(a5, a6, a7):\n    # 我是个函数\n    print(\"我是三函数\")\n\n\nc(4, 5, 6)\nprint(c.__name__)\nprint(c.__doc__)</code></pre>\n<p>运行一下：</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\60220d0c6aa548ef86bea66dbf683d71.png\"/></p>\n<p>这时我们发现我要的是c函数，但给我反馈的是inner函数，这是为什么呢？</p>\n<p>这就是工作原理，直接就把c函数装饰成了inner函数，那以后再工作中一定会要自己函数的名字，而不要我装饰后的函数，这样就可以让我们的函数装饰的更像，其实在以后中，都想装饰的更像，那我们应该怎末办？</p>\n<p>这时就需要我们的第三方模块functools，直接上代码</p>\n<pre><code class=\"language-python\">import functools\n\n\ndef outer(origin):\n    @functools.wraps(origin)\n    def inner(*args, **kwargs):\n        # 我是一个装饰器函数\n        print(\"装饰器的学习\")\n        res = origin(*args, **kwargs)\n        print(\"装饰器的学习\")\n        return res\n\n    return inner\n\n\n@outer\ndef c(a5, a6, a7):\n    # 我是个函数\n    print(\"我是三函数\")\n\n\nc(4, 5, 6)\nprint(c.__name__)\nprint(c.__doc__)</code></pre>\n<p> 这时再运行一下</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\b8452ad0f9ac4b3f9f796e38a95cf952.png\"/></p>\n<p>这时我们发现，我们伪装成功了，这样就会让我们的装饰更像。</p>\n<hr/>\n<ul><li> <h3>装饰器模板：</h3> </li></ul>\n<p></p>\n<p>接下来送给大家装饰器的模板，以后需要随时ctrl+c和ctrl+v</p>\n<pre><code class=\"language-python\">import functools\n\n\ndef outer(origin):\n    @functools.wraps(origin)\n    def inner(*args, **kwargs):\n        # 这里书写需要装饰的功能\n        res = origin(*args, **kwargs)\n        return res\n\n    return inner</code></pre>\n<p>记得要在需要装饰的函数前要写上@outer哦</p>\n<h3>总结：</h3>\n<p>综上，就是关于装饰器的所有知识点，希望大家能学到，最后希望大家多提宝贵意见，我们下期见。</p>\n<p></p>\n</div>\n</div>"}