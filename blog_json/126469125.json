{"blogid": "126469125", "writerAge": "码龄5年", "writerBlogNum": "286", "writerCollect": "1763", "writerComment": "92", "writerFan": "612", "writerGrade": "5级", "writerIntegral": "3723", "writerName": "这个名字先用着", "writerProfileAdress": "writer_image\\profile_126469125.jpg", "writerRankTotal": "5410", "writerRankWeekly": "6321", "writerThumb": "334", "writerVisitNum": "205016", "blog_read_count": "6368", "blog_time": "已于 2022-08-23 17:15:51 修改", "blog_title": "微信登录的接口", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p></p>\n<div class=\"toc\">\n<h3>目录</h3>\n<ul><li><a href=\"#_2\"></a></li><li><ul><li><a href=\"#_3\"></a></li><li><ul><li><a href=\"#_4\"></a></li></ul>\n</li><li><a href=\"#_10\">第一步：生成微信扫描二维码(网页内嵌的二维码)接口</a></li><li><a href=\"#__98\">第二步：处理微信回调 ，获取扫描人信息</a></li></ul>\n</li></ul>\n</div>\n<p></p>\n<h1><a id=\"_2\"></a></h1>\n<h2><a id=\"_3\"></a></h2>\n<h3><a id=\"_4\"></a></h3>\n<p>微信开放平台：</p>\n<p>https://developers.weixin.qq.com/doc/oplatform/Mobile_App/WeChat_Login/Development_Guide.html</p>\n<h2><a id=\"_10\"></a>第一步：生成微信扫描二维码(网页内嵌的二维码)接口</h2>\n<p>提供了第二种获取 code 的方式，支持网站将微信登录二维码内嵌到自己页面中，用户使用微信扫码授权后通过 JS 将code返回给网站。 JS微信登录主要用途：网站希望用户在网站内就能完成登录，无需跳转到微信域下登录后再返回，提升微信登录的流畅性与成功率。 网站内嵌二维码微信登录 JS 实现办法：</p>\n<p>步骤1：在页面中先引入如下 JS 文件（支持https）：</p>\n<blockquote>\n<p>http://res.wx.qq.com/connect/zh_CN/htmledition/js/wxLogin.js</p>\n</blockquote>\n<p>步骤2：在需要使用微信登录的地方实例以下 JS 对象：</p>\n<pre><code>var obj = new WxLogin({\n self_redirect:true,\n id:\"login_container\", \n appid: \"\", \n scope: \"\", \n redirect_uri: \"\",\n  state: \"\",\n style: \"\",\n href: \"\"\n });\n</code></pre>\n<p>参数说明<br/> <img alt=\"在这里插入图片描述\" src=\"image\\f2fe743fbcfb45cbab59daea3689a0a7.png\"/><br/> 我们需要写必须的那几个参数；</p>\n<p><strong>生成微信扫描二维码(网页内嵌的二维码)接口.此几口返回的数据是：生成二维码需要的参数</strong></p>\n<p>注意：接口的后台需要准备这几个参数：</p>\n<blockquote>\n<p>appid ： 应用唯一标识，在微信开放平台提交应用审核通过后获得<br/> scope ：应用授权作用域，拥有多个作用域用逗号（,）分隔，网页应用目前仅填写snsapi_login即可<br/> redirect_uri ： <strong>重定向地址，需要进行UrlEncode</strong><br/> state : 用于保持请求和回调的状态，授权请求后原样带回给第三方。该参数可用于防止 csrf 攻击（跨站请求伪造攻击），建议第三方带上该参数，可设置为简单的随机数加 session 进行校验</p>\n</blockquote>\n<p>1.需要在显示二维码的页面 引入前端api接口：</p>\n<blockquote>\n<p>import weixinApi from ‘@/api/weixin’</p>\n</blockquote>\n<p>2.然后在 mounted() 方法中添加以下方法</p>\n<pre><code>  mounted() {\n //初始化微信js\n    const script = document.createElement('script')\n    script.type = 'text/javascript'\n    script.src = 'https://res.wx.qq.com/connect/zh_CN/htmledition/js/wxLogin.js'\n    document.body.appendChild(script)\n   },\n</code></pre>\n<p>3、实例化微信JS对象<br/> 添加微信登录方法,<strong>即点击微信登录按钮，触发展示微信二维码的方法：</strong></p>\n<pre><code>weixinLogin() {\n  this.dialogAtrr.showLoginType = 'weixin'\n\n  weixinApi.getLoginParam().then(response =&gt; {\n    var obj = new WxLogin({\n      self_redirect:true,\n      id: 'weixinLogin', // 需要显示的容器id\n      appid: response.data.appid, // 公众号appid wx*******\n      scope: response.data.scope, // 网页默认即可\n      redirect_uri: response.data.redirectUri, // 授权成功后回调的url\n      state: response.data.state, // 可设置为简单的随机数加session用来校验\n      style: 'black', // 提供\"black\"、\"white\"可选。二维码的样式\n      href: '' // 外部css文件url，需要https\n    })\n  })\n},\n</code></pre>\n<p>然后记得网关设置：</p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\d3ddf2608d2440a9ba2303cecf61dc12.png\"/></p>\n<p>测试二维码展示：</p>\n<h2><a id=\"__98\"></a>第二步：处理微信回调 ，获取扫描人信息</h2>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\048e49197427499faea938cae16f6e0d.png\"/></p>\n<p>手机点击确认后的：</p>\n<p>请求网址: http://localhost:8160/api/ucenter/wx/callback?code=0815s6ll2O8vK94DBoll2u3htf45s6lP&amp;state=1661166686989</p>\n<p>请求网址: http://localhost:8160/api/ucenter/wx/callback?code=091927ll2UTvK94eW6nl2segEs3927lr&amp;state=1661167265572</p>\n<p>简单说，OAuth 就是一种授权机制。数据的所有者告诉系统，同意授权第三方应用进入系统，获取这些数据。系统从而产生一个短期的进入令牌（token），用来代替密码，供第三方应用使用。</p>\n<p>四、令牌与密码<br/> 令牌（token）与密码（password）的作用是一样的，都可以进入系统，但是有三点差异。</p>\n<p>（1）令牌是短期的，到期会自动失效，用户自己无法修改。密码一般长期有效，用户不修改，就不会发生变化。</p>\n<p>（2）令牌可以被数据所有者撤销，会立即失效。以上例而言，屋主可以随时取消快递员的令牌。密码一般不允许被他人撤销。</p>\n<p>（3）令牌有权限范围（scope），比如只能进小区的二号门。对于网络服务来说，只读令牌就比读写令牌更安全。密码一般是完整权限。</p>\n<p>上面这些设计，保证了令牌既可以让第三方应用获得权限，同时又随时可控，不会危及系统安全。这就是 OAuth 2.0 的优点。</p>\n<p>注意，只要知道了令牌，就能进入系统。系统一般不会再次确认身份，所以令牌必须保密，泄漏令牌与泄漏密码的后果是一样的。 这也是为什么令牌的有效期，一般都设置得很短的原因。</p>\n<hr/>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\ee72728bdb7e4954a1b0fdb83ffe2557.png\"/></p>\n<ol><li>客户应用请求授权服务器获取Access Token</li><li>授权服务器咨询用户意见</li><li>用户同意授权</li><li>授权服务器颁发Access Token 给 客户应用</li></ol>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\3935f16ae6fd4e1db90445e5d1a13ada.png\"/></p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\4078a2d888984ec190f0ceb2e7381b53.png\"/></p>\n<p>创建工具类：httpclint:</p>\n<p>在server_user模块：<br/> <img alt=\"在这里插入图片描述\" src=\"image\\f76005faa33542ccaa9929dcce41bbc8.png\"/></p>\n<p>在common-util中引入httpclient依赖：</p>\n<pre><code>&lt;!--httpclient--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;\n            &lt;artifactId&gt;httpclient&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\2c49386aab5643b3a8eb179a8c53c352.png\"/></p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\b701a6dd56184401aa12920b65366be2.png\"/></p>\n<p>第二步：通过 code 获取access_token</p>\n<p>通过 code 获取access_token</p>\n<pre><code>https://api.weixin.qq.com/sns/oauth2/\naccess_token?appid=APPID\n&amp;secret=SECRET&amp;\ncode=CODE&amp;\ngrant_type=authorization_code\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\bd307854c45b4d0c8acda442c6114c1f.png\"/></p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\9962e808327342f3bd67628c2a6d46ce.png\"/></p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\093141b97c9a4c7c83568aaf6d06203c.png\"/></p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\c4a4826786c24e0a9a5aa7484dda92d7.png\"/></p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\da20ef7a59574c6aa2dddaa141c95324.png\"/></p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\63896b4826204a798f08a58a89c1a5dd.png\"/></p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\fbf9148263a44fed85294576e878c27e.png\"/></p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\9f056907dba64a0a8c105960a3791598.png\"/></p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\f0d1b034834d48ffbee3c104efce6d16.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"image\\30a67eb994a54c8998b060c4e8a19f65.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"image\\938fee4a0a2e41aea32d661bfe4a2ef2.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"image\\c455ffbfa96041ee8ab7defd10458dcb.png\"/></p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\f122fc9651ec4f8a9d91238603d0422c.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"image\\613c24770d87480bbf3afee5f3b6be40.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"image\\91e526cce4a04812951c1ec096ac09c9.png\"/></p>\n<p>说明：我们根据返回openid判断是否需要绑定手机号码，如果需要绑定，那么我们要根据openid用户用户信息，然后更新上手机号码</p>\n<p>前端：</p>\n<p>3.4 回调返回页面<br/> 操作：yygh-site<br/> 说明：我们只期望返回一个空页面，然后跟登录层通信就可以了，其实就是一个过渡页面，所以我们要给这个过渡页面定义一个空模板</p>\n<p>3.4.2回调返回页面<br/> 根据返回路径/weixin/cakkback，我们创建组件/weixin/cakkback.vue</p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\3ec5fcca69db4deebe3d4dd50fae1a5c.png\"/></p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\27776888bf7b4b0a9645ec3d1cc3148b.png\"/></p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\31f4cc7bbaef4a94a8151a977ce06542.png\"/></p>\n<p>说明：在页面我们就能够接收到返回来的参数</p>\n<p>3.4.3 父组件定义回调方法<br/> 在myheader.vue添加方法</p>\n<p>mounted() 中增加方法：</p>\n<pre><code> // 微信登录回调处理\n   let self = this;\n   window[\"loginCallback\"] = (name,token, openid) =&gt; {\n     self.loginCallback(name, token, openid);\n   }\n</code></pre>\n<p>然后methods中增加方法：</p>\n<pre><code>loginCallback(name, token, openid) {\n      // 打开手机登录层，绑定手机号，改逻辑与手机登录一致\n      if(openid != '') {\n        this.userInfo.openid = openid\n        this.showLogin()\n      } else {\n        this.setCookies(name, token)\n      }\n    },\n</code></pre>\n<p>3.5 服务器绑定手机号码<br/> 页面绑定手机号码会把openid传递过来，我们根据openid找到用户信息，然后绑定手机号码<br/> 修改UserInfoServiceImpl类登录方法</p>\n<pre><code> //绑定手机号码\n        UserInfo userInfo = null;\n        if(!StringUtils.isEmpty(loginVo.getOpenid())) {\n            userInfo = this.selectWxInfoOpenId(loginVo.getOpenid());\n            if(null != userInfo) {\n                userInfo.setPhone(loginVo.getPhone());\n                this.updateById(userInfo);\n            } else {\n                throw new YyghException(ResultCodeEnum.DATA_ERROR);\n            }\n        }\n\n        if(userInfo == null){\n            //判断是否第一次登录，根据手机号查询数据库，如果不存在相同的手机号就是第一次登录\n            QueryWrapper&lt;UserInfo&gt; wrapper = new QueryWrapper&lt;&gt;();\n            wrapper.eq(\"phone\",phone);\n             userInfo = baseMapper.selectOne(wrapper);\n            if(null==userInfo ){//第一次使用这个手机号登录\n                //添加信息到数据库\n                userInfo = new UserInfo();\n                userInfo.setName(\"\");\n                userInfo.setPhone(phone);\n                userInfo.setStatus(1);//设置可用\n                //this.save(userInfo);//保存到数据库\n                baseMapper.insert(userInfo);\n            }\n        }\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\b0ce43f092784ba88cbb698188abae31.png\"/></p>\n<pre><code>package com.fan.yygh.user.controller;\n\nimport com.alibaba.fastjson.JSONObject;\nimport com.fan.yygh.common.exception.YyghException;\nimport com.fan.yygh.common.result.Result;\nimport com.fan.yygh.common.result.ResultCodeEnum;\nimport com.fan.yygh.helper.JwtHelper;\nimport com.fan.yygh.model.user.UserInfo;\nimport com.fan.yygh.user.service.UserInfoService;\nimport com.fan.yygh.user.utils.ConstantPropertiesUtil;\nimport com.fan.yygh.user.utils.HttpClientUtils;\nimport io.swagger.annotations.Api;\nimport io.swagger.annotations.ApiOperation;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.util.StringUtils;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\nimport javax.annotation.Resource;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URLEncoder;\nimport java.util.HashMap;\nimport java.util.Map;\n//微信操作的接口\n@Api(\"微信\")\n@Controller\n@RequestMapping(\"/api/ucenter/wx\")\npublic class WeixinApiController {\n    @Resource\n    private UserInfoService userInfoService;\n\n    /**\n     * 获取微信登录参数\n     * 1.生成微信扫描二维码\n     * 返回生成二维码需要的参数\n     */\n    @GetMapping(\"getLoginParam\")\n    @ResponseBody\n    public Result genQrConnect() throws UnsupportedEncodingException {\n        String redirect_uri = URLEncoder.encode(\n                ConstantPropertiesUtil.WX_OPEN_REDIRECT_URL, \"UTF-8\");\n        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();\n\n        map.put(\"appid\", ConstantPropertiesUtil.WX_OPEN_APP_ID);\n        map.put(\"redirect_uri\", redirect_uri);\n        map.put(\"scope\", \"snsapi_login\");\n        map.put(\"state\", System.currentTimeMillis()+\"\");//System.currentTimeMillis()+\"\"\n        return Result.ok(map);\n    }\n    //微信扫描后回调的方法\n    @GetMapping(\"callback\")\n    public String callback(String code,String state){\n        //第一步，获取 临时授权临时票据code\n        System.out.println(\"code:\"+code);\n        //第二步：拿着code和微信appid和秘钥appscrect(三个参数换一个参数),--》请求微信固定地址--》换取access_token\n        StringBuffer baseAccessTokenUrl = new StringBuffer()\n                .append(\"https://api.weixin.qq.com/sns/oauth2/access_token\")\n                .append(\"?appid=%s\")\n                .append(\"&amp;secret=%s\")\n                .append(\"&amp;code=%s\")\n                .append(\"&amp;grant_type=authorization_code\");\n        //baseAccessTokenUrl的参数填充\n        String accessTokenUrl = String.format(baseAccessTokenUrl.toString(),\n                ConstantPropertiesUtil.WX_OPEN_APP_ID, //参数一appid\n                ConstantPropertiesUtil.WX_OPEN_APP_SECRET, //参数二appscrec\n                code); //参数三code\n\n        //使用httpclient请求这个地址\n        String accessTokenInfo  = null;\n        try {\n            //使用三个参数换取token,accessTokenInfo包含token令牌信息\n            accessTokenInfo = HttpClientUtils.get(accessTokenUrl);//accessTokenUrl包含三个参数\n            /*令牌accessTokenInfo:\n            {\"access_token\":\"60_jEgLorfJRsMwTfuDdzUN_7mApa4D7c\",\n            \"expires_in\":7200,\n            \"refresh_token\":\"60_LPZ7M5sigEJ_wB09HKCeMETuYwLBjg\",\n            \"openid\":\"o3_SC5yAwrC4BO587_u3_llgcHZU\",\n            \"scope\":\"snsapi_login\",\n            \"unionid\":\"oWgGz1KqBehsbtgjrIjCR8-5hxkU\"}*/\n            System.out.println(\"使用code换取的access_token结果accessTokenInfo:\"+accessTokenInfo);\n            /*=============================以下是对换取的token做处理=======================================*/\n            //从返回字符串拿到两个值openid  和 access_token\n            JSONObject jsonObject = JSONObject.parseObject(accessTokenInfo);\n            String access_token = jsonObject.getString(\"access_token\");\n            String openid = jsonObject.getString(\"openid\");\n            //判断数据库是否存在微信的扫描人信息，根据openid判断\n            UserInfo userInfo = userInfoService.selectWxInfoOpenId(openid);\n            if(userInfo == null){ //数据库不存在微信信息\n                //第三步：拿着openid 和access_token 请求微信地址，得到扫码人 信息\n                //根据access_token获取微信用户的基本信息\n                //先根据openid进行数据库查询\n                // UserInfo userInfo = userInfoService.getByOpenid(openId);\n                // 如果没有查到用户信息,那么调用微信个人信息获取的接口\n                // if(null == userInfo){\n                //如果查询到个人信息，那么直接进行登录\n                //使用access_token换取受保护的资源：微信的个人信息\n                //换取token的地址：   https://api.weixin.qq.com/sns/oauth2/access_token\n                //换取user信息的地址：https://api.weixin.qq.com/sns/userinfo\n                String baseUserInfoUrl = \"https://api.weixin.qq.com/sns/userinfo\" +\n                        \"?access_token=%s\" +\n                        \"&amp;openid=%s\";\n                String userInfoUrl = String.format(baseUserInfoUrl, access_token, openid);\n\n                String resultInfo = HttpClientUtils.get(userInfoUrl);\n                //得到扫码 用户信息resultInfo，是一个json字符串\n                /*扫码人信息resultInfo:\n                {\"openid\":\"o3_SC5yAwrC4BO587_u3_llgcHZUxxx\",\n                \"nickname\":\"xxx\",\"sex\":0,\"language\":\"\",\"city\":\"\",\"province\":\"\",\"country\":\"\",\n                \"headimgurl\":\"https:\\23\\/132\",\n                \"privilege\":[],\n                \"unionid\":\"oWgGz1KqBehsbtgjrIjCR8-5hxkU\"}*/\n                //================第四步：利用access_token 和openid  换取 扫码人信息=============\n                System.out.println(\"扫码人信息resultInfo:\"+resultInfo);\n                //解析用户信息，将string转成json对象\n                JSONObject resultUserInfoJson = JSONObject.parseObject(resultInfo);\n                String nickname = resultUserInfoJson.getString(\"nickname\");//得到用户昵称\n                String headimgurl = resultUserInfoJson.getString(\"headimgurl\");//得到用户头像\n                //获取扫码人信息 并添加到数据库\n                userInfo = new UserInfo();\n                userInfo.setName(nickname);\n                userInfo.setOpenid(openid);\n                userInfo.setStatus(1);\n                //保存到数据库\n                userInfoService.save(userInfo);\n            }\n\n            //返回name和token令牌字符串\n            HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();\n            String name = userInfo.getName();\n            if(StringUtils.isEmpty(name)){\n                name = userInfo.getNickName();\n            }\n            if(StringUtils.isEmpty(name)){\n                name = userInfo.getPhone();\n            }\n            map.put(\"name\",name);//将名字放入map\n            //要求每个微信用户要绑定手机号，判断userInfo是否有手机号，\n            // 如果手机号为空，返回openid\n            //如果手机号不为空，返回openid值是空字符串\n            //前端判断：如果openid不为空，绑定手机号，如果openid为空，不需要绑定手机号\n            if(StringUtils.isEmpty(userInfo.getPhone())){\n                map.put(\"openid\", userInfo.getOpenid());\n            }else{\n                map.put(\"openid\",\"\");\n            }\n            //产生token令牌字符串\n            String token = JwtHelper.createToken(userInfo.getId(), name);\n            map.put(\"token\",token);//将令牌token放入map\n\n            //登录成功后的页面跳转\n            return \"redirect:\"+ ConstantPropertiesUtil.YYGH_BASE_URL + \"/weixin/callback?token=\"+\n                    map.get(\"token\")+\"&amp;openid=\"+\n                    map.get(\"openid\")+\"&amp;name=\"+URLEncoder.encode(map.get(\"name\"),\"utf-8\");\n\n        } catch (Exception e) {\n            throw new YyghException(ResultCodeEnum.FETCH_ACCESSTOKEN_FAILD);\n            //return null;\n        }\n\n    }\n\n    /*============我的微信二维码生成的方法====================*/\n    /*方法返回生成展示二维码的各种前端页面参数*/\n    @ApiOperation(\"我的微信二维码生成的方法\")\n    @GetMapping(\"createWeixinImage\")\n    @ResponseBody  //此注解返回json\n    public Result   createWeixinImage() throws UnsupportedEncodingException {\n        //微信官方规定：redirect_uri\t\t重定向地址，需要进行UrlEncode\n        String redirect_uri = URLEncoder.encode(\n                ConstantPropertiesUtil.WX_OPEN_REDIRECT_URL,\n                \"UTF-8\");\n        HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();\n        //从官网给的参数中获取appid，appid在配置文件中的\n        map.put(\"appid\",ConstantPropertiesUtil.WX_OPEN_APP_ID);\n        //scope:应用授权作用域，拥有多个作用域用逗号（,）分隔，网页应用目前仅填写snsapi_login即可\n        map.put(\"scope\",\"snsapi_login\");\n        map.put(\"redirect_uri\",redirect_uri);\n        /*用于保持请求和回调的状态，授权请求后原样带回给第三方。\n        该参数可用于防止 csrf 攻击（跨站请求伪造攻击），\n        建议第三方带上该参数，可设置为简单的随机数加 session 进行校验*/\n        map.put(\"state\",System.currentTimeMillis()+\"\");\n        return Result.ok(map);\n    }\n\n}\n\n</code></pre>\n<pre><code>package com.fan.yygh.user.service.impl;\n\nimport com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;\nimport com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;\nimport com.fan.yygh.common.exception.YyghException;\nimport com.fan.yygh.common.result.ResultCodeEnum;\nimport com.fan.yygh.helper.JwtHelper;\nimport com.fan.yygh.model.user.UserInfo;\nimport com.fan.yygh.user.mapper.UserInfoMapper;\nimport com.fan.yygh.user.service.UserInfoService;\nimport com.fan.yygh.vo.user.LoginVo;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.stereotype.Service;\nimport org.springframework.util.StringUtils;\n\nimport javax.annotation.Resource;\nimport java.util.HashMap;\nimport java.util.Map;\n\n@Service //先继承《M是mapper,T是实体类》后实现\npublic class UserInfoImpl extends ServiceImpl&lt;UserInfoMapper, UserInfo&gt;\n        implements UserInfoService {\n    @Resource\n    private UserInfoMapper userInfoMapper;\n    @Resource\n    private RedisTemplate&lt;String,String&gt; redisTemplate;\n\n\n    //判断数据库是否存在微信的扫描人信息，根据openid判断\n    @Override\n    public UserInfo selectWxInfoOpenId(String openid) {\n        QueryWrapper&lt;UserInfo&gt; wrapper = new QueryWrapper&lt;&gt;();\n        wrapper.eq(\"openid\",openid);\n        UserInfo userInfo = baseMapper.selectOne(wrapper);\n        return userInfo;\n    }\n\n    //用户手机号登录接口\n    @Override\n    public Map&lt;String, Object&gt; loginUser(LoginVo loginVo) {\n        //从vo中获取参数\n        String phone = loginVo.getPhone();\n        String code = loginVo.getCode();\n        //参数校验\n        if(StringUtils.isEmpty(phone) || StringUtils.isEmpty(code)){\n            throw new YyghException(ResultCodeEnum.PARAM_ERROR);//ResultCodeEnum枚举类\n        }\n        //TODO 校验校验验证码\n        //校验校验验证码\n        String mobleCode = redisTemplate.opsForValue().get(phone);\n        if(!code.equals(mobleCode)) {\n            throw new YyghException(ResultCodeEnum.CODE_ERROR);\n        }\n\n\n        //绑定手机号码\n        UserInfo userInfo = null;\n        if(!StringUtils.isEmpty(loginVo.getOpenid())) {\n            userInfo = this.selectWxInfoOpenId(loginVo.getOpenid());\n            if(null != userInfo) {\n                userInfo.setPhone(loginVo.getPhone());\n                this.updateById(userInfo);\n            } else {\n                throw new YyghException(ResultCodeEnum.DATA_ERROR);\n            }\n        }\n\n        if(userInfo == null){\n            //判断是否第一次登录，根据手机号查询数据库，如果不存在相同的手机号就是第一次登录\n            QueryWrapper&lt;UserInfo&gt; wrapper = new QueryWrapper&lt;&gt;();\n            wrapper.eq(\"phone\",phone);\n             userInfo = baseMapper.selectOne(wrapper);\n            if(null==userInfo ){//第一次使用这个手机号登录\n                //添加信息到数据库\n                userInfo = new UserInfo();\n                userInfo.setName(\"\");\n                userInfo.setPhone(phone);\n                userInfo.setStatus(1);//设置可用\n                //this.save(userInfo);//保存到数据库\n                baseMapper.insert(userInfo);\n            }\n        }\n\n        //校验是否被禁用\n        if(userInfo.getStatus() == 0) {\n            throw new YyghException(ResultCodeEnum.LOGIN_DISABLED_ERROR);\n        }\n\n        //返回给页面的map信息\n        HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();\n        String name = userInfo.getName();\n        if (StringUtils.isEmpty(name)) {//如果名字为空\n            name = userInfo.getNickName();//用昵称代替名字\n        }\n        if(StringUtils.isEmpty(name)){\n            name = userInfo.getPhone();//如果名字为空，用手机号代替名字\n        }\n        map.put(\"name\",name);//返回name和token\n        //利用工具生成token\n        String token = JwtHelper.createToken(userInfo.getId(), name);\n        map.put(\"token\",token);//token  被写错了\n        return map;  //记得返回map\n    }\n}\n\n</code></pre>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}