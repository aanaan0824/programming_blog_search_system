{"blogid": "123888590", "writerAge": "码龄169天", "writerBlogNum": "27", "writerCollect": "442", "writerComment": "20", "writerFan": "86", "writerGrade": "2级", "writerIntegral": "383", "writerName": "星悦糖", "writerProfileAdress": "writer_image\\profile_123888590.jpg", "writerRankTotal": "41964", "writerRankWeekly": "277996", "writerThumb": "93", "writerVisitNum": "79872", "blog_read_count": "65245", "blog_time": "已于 2022-05-06 15:37:29 修改", "blog_title": "SpringBoot框架", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong> </p>\n<p id=\"1.1%20%E7%AE%80%E4%BB%8B-toc\" style=\"margin-left:40px;\"><a href=\"#1.1%20%E7%AE%80%E4%BB%8B\">1.1 简介</a></p>\n<p id=\"1.2%20%E7%89%B9%E6%80%A7-toc\" style=\"margin-left:40px;\"><a href=\"#1.2%20%E7%89%B9%E6%80%A7\">1.2 特性</a></p>\n<p id=\"1.3%20%E5%9B%9B%E5%A4%A7%E6%A0%B8%E5%BF%83-toc\" style=\"margin-left:40px;\"><a href=\"#1.3%20%E5%9B%9B%E5%A4%A7%E6%A0%B8%E5%BF%83\">1.3 四大核心</a></p>\n<p id=\"2%20springboot%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B-toc\" style=\"margin-left:0px;\"><a href=\"#2%20springboot%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B\">2 springboot入门案例</a></p>\n<p id=\"2.1%20SpringBoot%20%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E6%AD%A5%E9%AA%A4-toc\" style=\"margin-left:40px;\"><a href=\"#2.1%20SpringBoot%20%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E6%AD%A5%E9%AA%A4\">2.1 SpringBoot 项目开发步骤</a></p>\n<p id=\"%C2%A02.2%C2%A0%C2%A0%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%20Spring%20MVC%20%E7%9A%84%20Spring%20BootController%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A02.2%C2%A0%C2%A0%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%20Spring%20MVC%20%E7%9A%84%20Spring%20BootController%C2%A0\"> 2.2  创建一个 Spring MVC 的 Spring BootController </a></p>\n<p id=\"2.3%C2%A0%20%E5%88%86%E6%9E%90-toc\" style=\"margin-left:40px;\"><a href=\"#2.3%C2%A0%20%E5%88%86%E6%9E%90\">2.3  分析</a></p>\n<p id=\"2.4%20%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F-toc\" style=\"margin-left:40px;\"><a href=\"#2.4%20%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F\">2.4 核心配置文件格式</a></p>\n<p id=\"2.5%C2%A0%C2%A0Spring%20Boot%20%E5%89%8D%E7%AB%AF%E4%BD%BF%E7%94%A8%20JSP-toc\" style=\"margin-left:40px;\"><a href=\"#2.5%C2%A0%C2%A0Spring%20Boot%20%E5%89%8D%E7%AB%AF%E4%BD%BF%E7%94%A8%20JSP\">2.5  Spring Boot 前端使用 JSP</a></p>\n<p id=\"3%20SpringBoot%E6%A1%86%E6%9E%B6Web%E5%BC%80%E5%8F%91-toc\" style=\"margin-left:0px;\"><a href=\"#3%20SpringBoot%E6%A1%86%E6%9E%B6Web%E5%BC%80%E5%8F%91\">3 SpringBoot框架Web开发</a></p>\n<p id=\"%C2%A03.1%C2%A0%C2%A0Spring%20Boot%20%E9%9B%86%E6%88%90%20MyBatis%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A03.1%C2%A0%C2%A0Spring%20Boot%20%E9%9B%86%E6%88%90%20MyBatis%C2%A0\"> 3.1  Spring Boot 集成 MyBatis </a></p>\n<p id=\"%C2%A03.2%C2%A0DAO%20%E7%9A%84%E5%85%B6%E5%AE%83%E5%BC%80%E5%8F%91%E6%96%B9%E5%BC%8F-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A03.2%C2%A0DAO%20%E7%9A%84%E5%85%B6%E5%AE%83%E5%BC%80%E5%8F%91%E6%96%B9%E5%BC%8F\"> 3.2 DAO 的其它开发方式</a></p>\n<p id=\"%C2%A03.3%C2%A0Spring%20Boot%20%E4%BA%8B%E5%8A%A1%E6%94%AF%E6%8C%81-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A03.3%C2%A0Spring%20Boot%20%E4%BA%8B%E5%8A%A1%E6%94%AF%E6%8C%81\"> 3.3 Spring Boot 事务支持</a></p>\n<p id=\"3.4%C2%A0%C2%A0Spring%20Boot%20%E4%B8%8B%E7%9A%84%20Spring%20MVC%EF%BC%88%E6%B3%A8%E8%A7%A3%EF%BC%89-toc\" style=\"margin-left:40px;\"><a href=\"#3.4%C2%A0%C2%A0Spring%20Boot%20%E4%B8%8B%E7%9A%84%20Spring%20MVC%EF%BC%88%E6%B3%A8%E8%A7%A3%EF%BC%89\">3.4  Spring Boot 下的 Spring MVC（注解）</a></p>\n<p id=\"%C2%A03.5%20SpringBoot%E5%AE%9E%E7%8E%B0RESTFUL-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A03.5%20SpringBoot%E5%AE%9E%E7%8E%B0RESTFUL\"> 3.5 SpringBoot实现RESTFUL</a></p>\n<p id=\"3.6%C2%A0%C2%A0Spring%20Boot%20%E9%9B%86%E6%88%90%20Redis%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#3.6%C2%A0%C2%A0Spring%20Boot%20%E9%9B%86%E6%88%90%20Redis%C2%A0\">3.6  Spring Boot 集成 Redis </a></p>\n<p></p>\n<h2 id=\"1.1%20%E7%AE%80%E4%BB%8B\">1.1 简介</h2>\n<p>springboot是spring家族中的一个全新框架，用来简化spring程序的创建和开发过程。在以往我们通过SpringMVC+Spring+Mybatis框架进行开发的时候，我们需要配置web.xml，spring配置，mybatis配置，然后整合在一起，而springboot抛弃了繁琐的xml配置过程，采用大量默认的配置来简化我们的spring开发过程。</p>\n<p>SpringBoot化繁为简，使开发变得更加的简单迅速。</p>\n<h2 id=\"1.2%20%E7%89%B9%E6%80%A7\">1.2 特性</h2>\n<ul><li>能够快速创建基于spring的程序</li><li>能够直接使用Java main方法启动内嵌的Tomcat服务器运行springboot程序，不需要部署war包</li><li>提供约定的starter POM来简化Maven配置，让Maven的配置变得简单</li><li>自动化配置，根据项目的Maven依赖配置，springboot自动配置spring、springmvc等</li><li>提供了程序的健康检查功能</li><li>基本可以完全不使用xml配合文件，采用注解配置</li></ul>\n<h2 id=\"1.3%20%E5%9B%9B%E5%A4%A7%E6%A0%B8%E5%BF%83\">1.3 四大核心</h2>\n<p>      <span style=\"color:#fe2c24;\"><strong>  自动配置、起步依赖、Actuator、命令行界面</strong></span></p>\n<h1 id=\"2%20springboot%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B\">2 springboot入门案例</h1>\n<h2 id=\"2.1%20SpringBoot%20%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E6%AD%A5%E9%AA%A4\">2.1 SpringBoot 项目开发步骤</h2>\n<p>        （1）创建一个 Module，选择类型为Spring Initializr 快速构建</p>\n<p><img alt=\"\" height=\"254\" src=\"image\\771faad6db884518a9d544d12fba62ef.png\" width=\"811\"/></p>\n<p>        （2）设置 GAV 坐标及 pom 配置信息 </p>\n<p> <img alt=\"\" height=\"446\" src=\"image\\89bc00f4a5454ce1942e7a4287d24917.png\" width=\"805\"/></p>\n<p>        （3）选择 Spring Boot 版本及依赖 </p>\n<p><img alt=\"\" height=\"268\" src=\"image\\472ec93782624524808d74a0753fdf32.png\" width=\"824\"/></p>\n<p>        （4）设置模块名称、Content Root 路径及模块文件的目录，然后点击finish即可</p>\n<p><img alt=\"\" height=\"152\" src=\"image\\2f48a19f46774194be60fb2720539d50.png\" width=\"826\"/></p>\n<p>        （5）项目结构如下：</p>\n<p><img alt=\"\" height=\"731\" src=\"image\\d3fe7e617cc94138836a0edcb0896de2.png\" width=\"733\"/></p>\n<p>        <strong>static</strong>：存放静态资源。如图片、CSS、JavaScript 等 <br/>         <strong>templates</strong>：存放 Web 页面的模板文件 <br/>        <strong> application.properties/application.yml</strong> 用于存放程序的各种依赖模块的配置信息，比如 服务端口，数据库连接配置等<br/>       <strong>  .gitignore</strong>：使用版本控制工具 git 的时候，设置一些忽略提交的内容 <br/>         <strong>Application.java</strong>：SpringBoot 程序执行的入口，执行该程序中的 main 方法，启动当前SpringBoot项目。</p>\n<p>        （6）对pom.xml文件进行解释</p>\n<pre><code class=\"language-XML\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; \n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" \nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \n xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 \nhttp://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; \n &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; \n &lt;!--继承 SpringBoot 框架的一个父项目，所有自己开发的 Spring Boot 都必须的继承--&gt; \n &lt;parent&gt; \n     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; \n     &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; \n     &lt;version&gt;2.2.1.RELEASE&lt;/version&gt; \n     &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; \n &lt;/parent&gt; \n \n &lt;!--当前项目的 GAV 坐标--&gt; \n &lt;groupId&gt;com.bjpowernode.springboot&lt;/groupId&gt; \n &lt;artifactId&gt;002-springboot-springmvc&lt;/artifactId&gt; \n &lt;version&gt;1.0.0&lt;/version&gt; \n \n &lt;!--maven 项目名称，可以删除--&gt; \n &lt;name&gt;002-springboot-springmvc&lt;/name&gt; \n &lt;!--maven 项目描述，可以删除--&gt; \n &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; \n \n &lt;!--maven 属性配置，可以在其它地方通过${}方式进行引用--&gt; \n &lt;properties&gt; \n     &lt;java.version&gt;1.8&lt;/java.version&gt; \n &lt;/properties&gt; \n \n \n &lt;dependencies&gt; \n &lt;!--SpringBoot 框架 web 项目起步依赖，通过该依赖自动关联其它依赖，不需要我们一个一个去添加\n--&gt; \n     &lt;dependency&gt; \n         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; \n         &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; \n     &lt;/dependency&gt; \n \n &lt;!--SpringBoot 框架的测试起步依赖，例如：junit 测试，如果不需要的话可以删除--&gt; \n     &lt;dependency&gt; \n         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; \n         &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; \n         &lt;scope&gt;test&lt;/scope&gt; \n         &lt;exclusions&gt; \n             &lt;exclusion&gt; \n                 &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; \n                 &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; \n             &lt;/exclusion&gt; \n         &lt;/exclusions&gt; \n     &lt;/dependency&gt; \n &lt;/dependencies&gt; \n \n &lt;build&gt; \n     &lt;plugins&gt; \n         &lt;!--SpringBoot提供的打包编译等插件--&gt; \n         &lt;plugin&gt; \n             &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; \n             &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; \n         &lt;/plugin&gt; \n     &lt;/plugins&gt; \n &lt;/build&gt; \n&lt;/project&gt; </code></pre>\n<h2 id=\"%C2%A02.2%C2%A0%C2%A0%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%20Spring%20MVC%20%E7%9A%84%20Spring%20BootController%C2%A0\"> 2.2  创建一个 Spring MVC 的 Spring BootController </h2>\n<p>      （1）创建SpringBootController 类</p>\n<p>     <span style=\"color:#fe2c24;\"><strong>   注意：新创建的类一定要位于 Application 同级目录或者下级目录，否则 SpringBoot 加<br/> 载不到。 </strong></span></p>\n<pre><code class=\"language-java\">package com.bjpowernode.springboot.web; \n \nimport org.springframework.stereotype.Controller; \nimport org.springframework.web.bind.annotation.RequestMapping; \nimport org.springframework.web.bind.annotation.ResponseBody; \n \n@Controller \npublic class SpringBootController { \n \n @RequestMapping(value = \"/springBoot/say\") \n public @ResponseBody String say() { \n     return \"Hello,springBoot!\"; \n } \n} </code></pre>\n<p>        （2）启动Application类中的main方法</p>\n<p>        通过在控制台的输出，可以看到启动 SpringBoot 框架，会启动一个内嵌的 tomcat，端<br/> 口号为 8080，上下文根为空 。</p>\n<p><img alt=\"\" height=\"40\" src=\"image\\10afb86889a848e3a0675575ebc888b3.png\" width=\"821\"/></p>\n<p>         （3）在浏览器中输入 http://localhost:8080/springBoot/say进行访问 </p>\n<p><img alt=\"\" height=\"152\" src=\"image\\b992376046c84363bb9a789c34b11ec2.png\" width=\"482\"/></p>\n<h2 id=\"2.3%C2%A0%20%E5%88%86%E6%9E%90\">2.3  分析</h2>\n<p><br/>         （1）spring-boot-starter-parent 是一个 Springboot 的父级依赖，开发 SpringBoot 程序都需<br/> 要继承该父级项目，它用来提供相关的 Maven 默认依赖，使用它之后，常用的 jar<br/> 包依赖可以省去 version 配置 <br/>         （2）Spring Boot 提供了一些默认的jar 包的依赖，可查看该父级依赖的 pom 文件 <br/>         （3）如果不想使用某个默认的依赖版本，可以通过 pom.xml 文件的属性配置覆盖各个<br/> 依赖项，比如覆盖 Spring 版本： </p>\n<pre><code class=\"language-XML\"> &lt;properties&gt; \n     &lt;spring-framework.version&gt;5.0.0.RELEASE&lt;/ spring-framework.version &gt; \n &lt;/properties&gt; </code></pre>\n<p>        （4）<span style=\"color:#fe2c24;\"><strong> @SpringBootApplication</strong></span> 注解是 Spring Boot 项目的核心注解，主要作用是<span style=\"color:#fe2c24;\"><strong>开启<br/> Spring 自动配置</strong></span>，如果在 Application 类上去掉该注解，那么不会启动 SpringBoot程序 <br/>         （5）main 方法是一个标准的 Java 程序的 main 方法，是boot项目启动运行的入口<br/>         （6）<span style=\"color:#fe2c24;\"><strong>@Controller 及 @ResponseBody </strong></span>依然是我们之前的 Spring MVC，因为 Spring Boot<br/> 的里面依然是使用我们的 Spring MVC + Spring + MyBatis 等框架 </p>\n<h2 id=\"2.4%20%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F\">2.4 核心配置文件格式</h2>\n<p>        （1）.properties 文件（默认采用该文件） </p>\n<p>通过修改 application.properties 配置文件，修改默认 tomcat 端口号及项目上下文件根：</p>\n<pre><code class=\"language-java\">#设置内嵌 Tomcat 端口号 \nserver.port=9090 \n \n#配置项目上下文根 \nserver.servlet.context-path=/003-springboot-port-context-path \n</code></pre>\n<p> 页面显示结果：</p>\n<p><img alt=\"\" height=\"148\" src=\"image\\2ca1e43358954bc79abfccbb61232b9a.png\" width=\"761\"/></p>\n<p>        （2） .yml 文件 ：</p>\n<p>        项目名称：004-springboot-yml</p>\n<p>        yml 是一种 yaml 格式的配置文件，主要采用一定的空格、换行等格式排版进行配置。它能够直观的被计算机识别数据序列化格式，容易被人类阅读，yaml 类似于 xml，但是语法比 xml 简洁很多，值与前面的冒号配置项必须要有一个空格， yml 后缀也可以使用 yaml 后缀 。</p>\n<p><img alt=\"\" height=\"231\" src=\"image\\306bf50884304c03a4d7d4cc429d3506.png\" width=\"618\"/></p>\n<p>       <span style=\"color:#fe2c24;\"><strong> 注意：当两种格式配置文件同时存在时，使用的是.properties 配置文件。</strong></span></p>\n<p>        （3）多环境配置（<span style=\"color:#fe2c24;\"><strong>.properties方式</strong></span>）</p>\n<p>        在实际开发的过程中，我们的项目会经历很多的阶段（开发-&gt;测试-&gt;上线），每个阶段<br/> 的配置也会不同，例如：端口、上下文根、数据库等，那么这个时候<span style=\"color:#38d8f0;\"><strong>为了方便在不同的环境<br/> 之间切换，SpringBoot 提供了多环境配置</strong></span>，具体步骤如下 ：</p>\n<p>        项目名称：005-springboot-multi-environment </p>\n<p>为每个环境创建一个配置文件，命名必须为<span style=\"color:#fe2c24;\"> application-环境标识.properties|yml</span></p>\n<p><img alt=\"\" height=\"252\" src=\"image\\9e9ac1a19eb94be99a96a7f8eb22b93d.png\" width=\"707\"/></p>\n<p><span style=\"color:#be191c;\"><strong> application-dev.properties </strong></span></p>\n<pre><code class=\"language-XML\">#开发环境\n\n#设置内嵌 Tomcat 默认端口号 \nserver.port=8080 \n \n#设置项目的上下文根 \nserver.servlet.context-path=/005-springboot-multi-environment-dev \n</code></pre>\n<p><strong><span style=\"color:#be191c;\">application-product.properties</span></strong></p>\n<pre><code>#生产环境 \n \n#配置内嵌 Tomcat 默认端口号 \nserver.port=80 \n \n#配置项目上下文根 \nserver.servlet.context-path=/005-springboot-multi-environment-product \n</code></pre>\n<p><span style=\"color:#be191c;\"><strong>application-test.properties</strong></span></p>\n<pre><code class=\"language-TypeScript\">#测试环境 \n \n#配置内嵌 Tomcat 端口号 \nserver.port=8081 \n \n#配置项目的上下文根 \nserver.servlet.context-path=/005-springboot-multi-environment-test \n</code></pre>\n<p> <span style=\"color:#fe2c24;\"><strong>在总配置文件 application.properties 进行环境的激活</strong></span></p>\n<pre><code>#SpringBoot 的总配置文件 \n \n#激活开发环境 \n#spring.profiles.active=dev \n \n#激活测试环境 \n#spring.profiles.active=test \n \n#激活生产环境 \nspring.profiles.active=product \n</code></pre>\n<p>        （4）多环境配置（<span style=\"color:#fe2c24;\"><strong>.yml方式</strong></span>）</p>\n<p><span style=\"color:#be191c;\"><strong> application-dev.yml</strong></span></p>\n<pre><code class=\"language-XML\">#设置开发环境配置 \n \nserver: \n port: 8080 #设置 Tomcat 内嵌端口号 \n servlet: \n  context-path: /dev #设置上下文根 </code></pre>\n<p><strong><span style=\"color:#be191c;\">application-product.yml</span></strong></p>\n<pre><code>#设置生产环境配置 \n \nserver: \n port: 80 \n servlet: \n  context-path: /product \n</code></pre>\n<p><span style=\"color:#be191c;\"><strong>application-test.yml</strong></span></p>\n<pre><code class=\"language-TypeScript\">#设置测试环境配置 \n \nserver: \n port: 9090 \n servlet: \n  context-path: /test</code></pre>\n<p> <span style=\"color:#fe2c24;\"><strong>在总配置文件 application.yml进行环境的激活</strong></span></p>\n<pre><code>#springboot 总配置文件 \n \n#激活开发环境 \n#spring: \n# profiles: \n#  active: dev \n \n \n#激活测试环境 \n#spring: \n# profiles: \n#  active: test \n \n#激活生产环境 \nspring: \n profiles: \n  active: product \n</code></pre>\n<p>        （5）Spring Boot 自定义配置</p>\n<p>        在 SpringBoot 的核心配置文件中，除了使用内置的配置项之外，我们还可以在自定义配<br/> 置，然后采用如下注解去读取配置的属性值：</p>\n<p>        <span style=\"color:#38d8f0;\"><strong>（A）@Value注解 用于逐个读取application.properties中的配置</strong></span></p>\n<p><strong>        案例演示：</strong></p>\n<p><strong>       （1） </strong>在核心配置文件 applicatin.properties 中，添加两个自定义配置项 school.name 和<br/> website。<span style=\"color:#a2e043;\">在 IDEA 中可以看到这两个属性不能被 SpringBoot 识别，背景是桔色的 ：</span></p>\n<p><span style=\"color:#38d8f0;\"><strong>.properties方式</strong></span></p>\n<p><img alt=\"\" height=\"318\" src=\"image\\c097e3bd22844c9490a63b12023a6f74.png\" width=\"800\"/></p>\n<p><span style=\"color:#38d8f0;\"><strong> .yml方式</strong></span></p>\n<pre><code>#设置端口号及上下文根 \nserver: \n port: 9090 \n servlet: \n  context-path: / \n \nschool: \n name: ssm \nwebsit: http://www.baidu.com </code></pre>\n<p>        （2）在 SpringBootController 中定义属性，并使用@Value 注解或者自定义配置值，并对其方法进行测试</p>\n<pre><code class=\"language-java\">@Controller \npublic class SpringBootController { \n \n @Value(\"${school.name}\") \n private String schoolName; \n \n @Value(\"${websit}\") \n private String websit; \n \n @RequestMapping(value = \"/springBoot/config\") \n public @ResponseBody String say() { \n return schoolName + \"------\" + websit; \n } \n} </code></pre>\n<p>        （3）重新运行 Application，在浏览器中进行测试 </p>\n<p><img alt=\"\" height=\"182\" src=\"image\\243d2c6c76e4443787ed1675bcb304c8.png\" width=\"793\"/></p>\n<p>         <span style=\"color:#38d8f0;\"><strong>（B）@ConfigurationProperties</strong></span></p>\n<p>      <strong>  作用：</strong><span style=\"color:#fe2c24;\">将整个文件映射成一个对象，用于自定义配置项比较多的情况 。</span></p>\n<p>        <strong>案例演示：</strong></p>\n<p><strong>        （1）</strong>在 com.abc.springboot.config 包下创建 ConfigInfo 类，并为该类加上 Component 和<br/> ConfigurationProperties 注解，并在 ConfigurationProperties 注解中添加属性 prefix，可以区分同名配置 。</p>\n<pre><code class=\"language-java\">@Data\n@Component \n@ConfigurationProperties(prefix = \"school\") \npublic class ConfigInfo { \n \n private String name; \n \n private String websit; \n} </code></pre>\n<p><span style=\"color:#be191c;\"><strong>        （2）application.properties 配置文件</strong></span></p>\n<pre><code class=\"language-XML\">#设置内嵌 Tomcat 端口号 \nserver.port=9090 \n \n#设置上下文根 \nserver.servlet.context-path=/config \n \nschool.name=ssm \nschool.websit=http://www.baidu.com \n</code></pre>\n<p>        （3）在 SpringBootController 中注入 ConfigInfo 配置类 </p>\n<pre><code class=\"language-java\">@Autowired \nprivate ConfigInfo configInfo; \n</code></pre>\n<p>        （4）修改 SpringBootController 类中的测试方法</p>\n<pre><code class=\"language-java\">@RequestMapping(value = \"/springBoot/config\") \npublic @ResponseBody String say() { \n return configInfo.getName() + \"=======\" + configInfo.getWebsit(); \n} </code></pre>\n<p>        （5）重新运行 Application，在浏览器中进行测试 <br/><img alt=\"\" height=\"164\" src=\"image\\aa2268c283ee4b979df668f157f55f09.png\" width=\"780\"/></p>\n<p>         <strong><span style=\"color:#38d8f0;\">（C）警告解决</span></strong></p>\n<p>        在 ConfigInfo 类中使用了 ConfigurationProperties 注解后，IDEA 会出现一个警告，不影响程序的执行。</p>\n<p>        点击 open documentnation 跳转到网页，在网页中提示需要加一个依赖，我们将这<br/> 个依赖拷贝，粘贴到 pom.xml 文件中 即可。</p>\n<pre><code class=\"language-XML\">&lt;!--解决使用@ConfigurationProperties 注解出现警告问题--&gt; \n&lt;dependency&gt; \n  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; \n  &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; \n  &lt;optional&gt;true&lt;/optional&gt; \n&lt;/dependency&gt; </code></pre>\n<p>        <span style=\"color:#38d8f0;\"><strong>（D）中文乱码</strong></span></p>\n<p>    如果在 SpringBoot 核心配置文件中有中文信息，会出现乱码： </p>\n<ul><li>一般在配置文件中，不建议出现中文（注释除外） </li><li>如果出现中文，可以先转化为 ASCII 码 </li></ul>\n<p><img alt=\"\" height=\"92\" src=\"image\\eada3b74a3984d4db7a6f691f24ddb71.png\" width=\"670\"/></p>\n<h2 id=\"2.5%C2%A0%C2%A0Spring%20Boot%20%E5%89%8D%E7%AB%AF%E4%BD%BF%E7%94%A8%20JSP\">2.5  Spring Boot 前端使用 JSP</h2>\n<p>         （1）在 pom.xml 文件中配置以下依赖项</p>\n<pre><code class=\"language-XML\">&lt;!--引入 Spring Boot 内嵌的 Tomcat 对 JSP 的解析包，不加解析不了 jsp 页面--&gt; \n&lt;!--如果只是使用 JSP 页面，可以只添加该依赖--&gt; \n&lt;dependency&gt; \n &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; \n &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt; \n&lt;/dependency&gt; \n \n&lt;!--如果要使用 servlet 必须添加该以下两个依赖--&gt; \n&lt;!-- servlet 依赖的 jar 包--&gt; \n&lt;dependency&gt; \n &lt;groupId&gt;javax.servlet&lt;/groupId&gt; \n &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; \n&lt;/dependency&gt; \n&lt;dependency&gt; \n &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; \n &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt; \n &lt;version&gt;2.3.1&lt;/version&gt; \n&lt;/dependency&gt; \n \n&lt;!--如果使用 JSTL 必须添加该依赖--&gt; \n&lt;!--jstl 标签依赖的 jar 包 start--&gt; \n&lt;dependency&gt; \n &lt;groupId&gt;javax.servlet&lt;/groupId&gt; \n &lt;artifactId&gt;jstl&lt;/artifactId&gt; \n&lt;/dependency&gt; </code></pre>\n<p>        （2）在 pom.xml 的 build 标签中要配置以下信息 <br/>         <span style=\"color:#956fe7;\">SpringBoot 要求 jsp 文件必须编译到指定的 META-INF/resources 目录下才能访问，否则<br/> 访问不到</span>。其实官方已经更建议使用模板技术。</p>\n<pre><code class=\"language-XML\">&lt;!-- \n SpringBoot 要求 jsp 文件必须编译到指定的 META-INF/resources 目录下才能访问，否则访问\n不到。 \n 其它官方已经建议使用模版技术\n--&gt; \n&lt;resources&gt; \n &lt;resource&gt; \n     &lt;!--源文件位置--&gt; \n     &lt;directory&gt;src/main/webapp&lt;/directory&gt; \n     &lt;!--指定编译到 META-INF/resources，该目录不能随便写--&gt; \n     &lt;targetPath&gt;META-INF/resources&lt;/targetPath&gt; \n     &lt;!--指定要把哪些文件编译进去，**表示 webapp 目录及子目录，*.*表示所有文件--&gt; \n     &lt;includes&gt; \n         &lt;include&gt;**/*.*&lt;/include&gt; \n     &lt;/includes&gt; \n &lt;/resource&gt; \n&lt;/resources&gt; </code></pre>\n<p>        （3）在 application.properties 文件配置 Spring MVC 的视图展示为jsp，这里相当于 Spring MVC 的配置。</p>\n<pre><code>#SpringBoot 核心配置文件 \n#指定内嵌 Tomcat 端口号 \nserver.port=8090 \n \n#配置 SpringMVC 视图解析器 \n#其中：/ 表示目录为 src/main/webapp \nspring.mvc.view.prefix=/ \nspring.mvc.view.suffix=.jsp \n</code></pre>\n<p>        （4）在 com.abc.springboot.controller 包下创建 JspController 类</p>\n<pre><code class=\"language-java\">@Controller \npublic class SpringBootController { \n \n @RequestMapping(value = \"/springBoot/jsp\") \n public String jsp(Model model) { \n \n     model.addAttribute(\"data\",\"SpringBoot 前端使用 JSP 页面！\"); \n \n return \"index\"; \n } \n} \n</code></pre>\n<p>        （5）在 src/main 下创建一个 webapp 目录，然后在该目录下新建index.jsp 页面 </p>\n<p>        注意： 如果在webapp目录下右键，没有创建jsp的选项，可以在Project Structure中指定webapp为 Web Resource Directory 。</p>\n<p><img alt=\"\" height=\"553\" src=\"image\\7291326034b64bbc99ea471b78f1911f.png\" width=\"1200\"/></p>\n<p>         （6）在 index.jsp 中获取 Controller 传递过来的数据 </p>\n<p><img alt=\"\" height=\"283\" src=\"image\\86bcbb724d5b46e295eb590d5de5c6c2.png\" width=\"883\"/></p>\n<p>         （7）重新运行 Application，通过浏览器访问测试 </p>\n<p><img alt=\"\" height=\"140\" src=\"image\\204e21ce0a5846f5a43a19ea4bb9cd71.png\" width=\"530\"/></p>\n<h1 id=\"3%20SpringBoot%E6%A1%86%E6%9E%B6Web%E5%BC%80%E5%8F%91\">3 SpringBoot框架Web开发</h1>\n<p>通过实际代码案例进行梳理：</p>\n<h2 id=\"%C2%A03.1%C2%A0%C2%A0Spring%20Boot%20%E9%9B%86%E6%88%90%20MyBatis%C2%A0\"> 3.1  Spring Boot 集成 MyBatis </h2>\n<p>通过 SpringBoot +MyBatis 实现对数据库学生表的查询操作的实现步骤：</p>\n<p>（1）创建新的数据库springboot并向表中插入数据</p>\n<p>（2）创建一个新的 SpringBoot 的 Module </p>\n<p>        创建项目的过程省略</p>\n<p>（3）在 pom.xml 中添加相关 jar 依赖 </p>\n<pre><code class=\"language-XML\">&lt;!--MyBatis 整合 SpringBoot 的起步依赖--&gt; \n&lt;dependency&gt; \n &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; \n &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; \n &lt;version&gt;2.0.0&lt;/version&gt; \n&lt;/dependency&gt; \n\n&lt;!--MySQL 的驱动依赖--&gt; \n&lt;dependency&gt; \n &lt;groupId&gt;mysql&lt;/groupId&gt; \n &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; \n&lt;/dependency&gt; </code></pre>\n<p>（4）在 Springboot 的核心配置文件 application.properties 中配置数据源 </p>\n<pre><code class=\"language-XML\">#配置内嵌 Tomcat 端口号 \nserver.port=9090 \n \n#配置项目上下文根 \nserver.servlet.context-path=/010-springboot-web-mybatis \n \n#配置数据库的连接信息 \n#注意这里的驱动类有变化 \nspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver \nspring.datasource.url=jdbc:mysql://localhost:3306/springboot?useUnicode=true&amp;characterEncoding=UTF-8&amp;useJDBCCompliantTimezoneShift=true&amp;useLegacyDatetimeCode=false&amp;serverTimezone=GMT%2B8 \n \nspring.datasource.username=root \nspring.datasource.password=root\n</code></pre>\n<p>（5）开发代码（代码生成器）</p>\n<p>使用 Mybatis 反向工程生成接口、映射文件以及实体 bean，具体步骤参见附录 1</p>\n<p>         （A）在 web 包下创建 StudentController 并编写代码</p>\n<pre><code class=\"language-java\">@Controller \npublic class StudentController { \n \n @Autowired \n private StudentService studentService; \n \n @RequestMapping(value = \"/springBoot/student\") \n public @ResponseBody Object student() { \n \n Student student = studentService.queryStudentById(1); \n \n return student; \n } \n} \n</code></pre>\n<p>        （B）在 service 包下创建 service 接口并编写代码 </p>\n<pre><code class=\"language-java\">public interface StudentService { \n \n /** \n * 根据学生标识获取学生详情 \n * @param id \n * @return \n */ \n Student queryStudentById(Integer id); \n}</code></pre>\n<p>        （C）在 service.impl 包下创建 service 接口并编写代码</p>\n<pre><code class=\"language-java\">@Service \npublic class StudentServiceImpl implements StudentService { \n \n\n @Autowired \n private StudentMapper studentMapper; \n \n @Override \n public Student queryStudentById(Integer id) { \n return studentMapper.selectByPrimaryKey(id); \n } \n} </code></pre>\n<p>        （D）如果在 web 中导入 service 存在报错，可以尝试进行如下配置解决 <br/><img alt=\"\" height=\"685\" src=\"image\\b675d84a06aa439ca8edcc7f78c2c6f1.png\" width=\"972\"/></p>\n<p>        （E） 在 Mybatis 反向工程生成的 StudentMapper 接口上加一个 Mapper 注解 <br/><span style=\"color:#fe2c24;\"><strong>@Mapper 作用：mybatis 自动扫描数据持久层的映射文件及 DAO 接口的关系</strong></span></p>\n<pre><code class=\"language-java\">@Mapper \npublic interface StudentMapper { \n}</code></pre>\n<p>        （F）默认情况下，Mybatis 的 xml 映射文件不会编译到 target 的 class 目录下，所<br/> 以我们需要在 pom.xml 文件中配置 resource 。</p>\n<pre><code class=\"language-XML\">&lt;resources&gt; \n &lt;resource&gt; \n &lt;directory&gt;src/main/java&lt;/directory&gt; \n &lt;includes&gt; \n     &lt;include&gt;**/*.xml&lt;/include&gt; \n &lt;/includes&gt; \n &lt;/resource&gt; \n&lt;/resources&gt;</code></pre>\n<p>        （G）启动 Application 应用，浏览器访问测试运行</p>\n<p><img alt=\"\" height=\"169\" src=\"image\\30bd2f7c242644bcb0d12c2363b317f1.png\" width=\"700\"/></p>\n<h2 id=\"%C2%A03.2%C2%A0DAO%20%E7%9A%84%E5%85%B6%E5%AE%83%E5%BC%80%E5%8F%91%E6%96%B9%E5%BC%8F\"> 3.2 DAO 的其它开发方式</h2>\n<p><span style=\"color:#fe2c24;\"><strong>方式一：</strong></span></p>\n<p>（A）注释掉 StudentMapper 接口上的@Mapper 注解 </p>\n<p><img alt=\"\" height=\"59\" src=\"image\\25b2b2b1dbac4e51ae18c76da261d2bc.png\" width=\"327\"/></p>\n<p>（B）在运行的主类上添加注解包扫描MapperScan(\"com.abc.springboot.mapper\") </p>\n<pre><code class=\"language-java\">@SpringBootApplication \n@MapperScan(\"com.abc.springboot.mapper\") \npublic class Application { \n</code></pre>\n<p>或</p>\n<pre><code class=\"language-java\">@SpringBootApplication \n//Mybatis 提供的注解：扫描数据持久层的 mapper 映谢配置文件,DAO 接口上就不用加@Mapper \n//basePackages 通常指定到数据持久层包即可 \n@MapperScan(basePackages = \"com.abc.springboot.mapper\") \npublic class Application { </code></pre>\n<p><span style=\"color:#fe2c24;\"><strong>方式二：</strong></span></p>\n<p>        因为 SpringBoot 不能自动编译接口映射的 xml 文件，还需要手动在 pom 文件中指定，<br/> 所以有的公司直接将映射文件直接放到 resources 目录下 ，在 resources 目录下新建目录 mapper 存放映射文件，将 StudentMapper.xml 文件移到resources/mapper 目录下：</p>\n<p><img alt=\"\" height=\"542\" src=\"image\\89627dcd24ec46e7b9fb3bdaec3527e0.png\" width=\"547\"/></p>\n<p>        在 <span style=\"color:#fe2c24;\"><strong>application.properties 配置文件中指定映射文件的位置</strong></span>，这个配置<span style=\"color:#fe2c24;\">只有接口和映<br/> 射文件不在同一个包的情况下，才需要指定：</span></p>\n<pre><code class=\"language-XML\"># 指定 Mybatis 映射文件的路径 \nmybatis.mapper-locations=classpath:mapper/*.xml \n</code></pre>\n<h2 id=\"%C2%A03.3%C2%A0Spring%20Boot%20%E4%BA%8B%E5%8A%A1%E6%94%AF%E6%8C%81\"> 3.3 Spring Boot 事务支持</h2>\n<p>springboot事务底层依然采用的是 Spring 本身提供的事务管理。</p>\n<ul><li>在入口类中使用注解@EnableTransactionManagement开启事务支持</li><li>在访问数据库的service方法上添加注解@Transactional即可</li></ul>\n<p>       在上述案例的基础上，通过 SpringBoot +MyBatis 实现对数据库学生表的更新操作，在 service 层的方法中构建异常，查看事务是否生效：</p>\n<p>        （1）在 StudentController 中添加更新学生的方法</p>\n<pre><code class=\"language-java\">@RequestMapping(value = \"/springboot/modify\") \npublic @ResponseBody Object modifyStudent() { \n \n int count = 0; \n try { \n Student student = new Student(); \n student.setId(1); \n student.setName(\"Jack\"); \n student.setAge(33); \n count = studentService.modifyStudentById(student); \n } catch (Exception e) { \n e.printStackTrace(); \n return \"fail\"; \n } \n \n return count; \n} </code></pre>\n<p>        （2）在 StudentService 接口中添加更新学生方法</p>\n<pre><code class=\"language-java\">int modifyStudentById(Student student); \n</code></pre>\n<p>        （3）在 StudentServiceImpl 接口实现类中对更新学生方法进行实现，并构建一个异常，同时在该方法上加@Transactional 注解。</p>\n<pre><code class=\"language-java\">@Override \n@Transactional //添加此注解说明该方法添加的事务管理 \npublic int update(Student student) { \n \n int updateCount = studentMapper.updateByPrimaryKeySelective(student); \n \n System.out.println(\"更新结果：\" + updateCount); \n \n //在此构造一个除数为 0 的异常，测试事务是否起作用 \n int a = 10/0; \n \n return updateCount; \n} \n</code></pre>\n<p>        （4）在Application类上加@EnableTransactionManagement开启事务支持。</p>\n<p><span style=\"color:#fe2c24;\"><strong>@EnableTransactionManagement 可选，但是业务方法上必须添加@Transactional 事务才生效</strong></span></p>\n<pre><code class=\"language-java\">@SpringBootApplication \n@MapperScan(basePackages = \"com.abc.springboot.mapper\") \n@EnableTransactionManagement //开启事务支持(可选项，但@Transactional 必须添加) \npublic class Application { \n</code></pre>\n<h2 id=\"3.4%C2%A0%C2%A0Spring%20Boot%20%E4%B8%8B%E7%9A%84%20Spring%20MVC%EF%BC%88%E6%B3%A8%E8%A7%A3%EF%BC%89\">3.4  Spring Boot 下的 Spring MVC（注解）</h2>\n<p>springboot下的springMVC主要有以下注解：</p>\n<p>        （1）@Controller：Spring MVC 的注解，处理 http 请求</p>\n<p>        （2）@RestController ：@Controller 与@ResponseBody 的组合注解 </p>\n<p>        如果一个 Controller 类添加了@RestController，那么该 Controller 类下的所有方法都相当<br/> 于添加了<span style=\"color:#fe2c24;\">@ResponseBody 注解 </span>，<span style=\"color:#a2e043;\"><strong>用于返回字符串或json数据。</strong></span></p>\n<p><strong><span style=\"color:#38d8f0;\">创建 MyRestController 类，演示@RestController 替代@Controller + @ResponseBody</span></strong></p>\n<pre><code class=\"language-java\">@RestController \npublic class MyRestController { \n @Autowired \n private StudentService studentService; \n \n @RequestMapping(\"/boot/stu\") \n public Object stu(){ \n return studentService.getStudentById(1); \n } \n} </code></pre>\n<p>        （3）@RequestMapping：支持 Get 请求，也支持 Post 请求 。<br/>         （4）@GetMapping ：只支持 Get 请求，主要用于查询操作。</p>\n<p>        （5）@PostMapping：只支持Post请求，主要用于新增数据。</p>\n<p>        （6）@PutMapping：只支持put请求，主要用于修改数据</p>\n<p>        （7）@DeleteMapping：只支持delete请求，通常用与删除数据</p>\n<p>        <span style=\"color:#4da8ee;\"><strong>（8）综合案例：</strong></span></p>\n<p><span style=\"color:#4da8ee;\"><strong>（A）创建一个 MVCController，里面使用上面介绍的各种注解接收不同的请求 </strong></span></p>\n<pre><code class=\"language-java\">//RestController 注解相当于加了给方法加了@ResponseBody 注解，所以是不能跳转页面的，只能返回字符串或者 json 数据 \n@RestController \npublic class MVCController { \n \n @GetMapping(value = \"/query\") \n public String get() { \n return \"@GetMapping 注解,通常查询时使用\"; \n } \n \n \n @PostMapping(value = \"/add\") \n public String add() { \n return \"@PostMapping 注解，通常新增时使用\"; \n } \n \n @PutMapping(value = \"/modify\") \n public String modify() { \n return \"@PutMapping 注解，通常更新数据时使用\"; \n } \n \n @DeleteMapping(value = \"/remove\") \n public String remove() { \n return \"@DeleteMapping 注解，通常删除数据时使用\"; \n } \n} </code></pre>\n<p><span style=\"color:#38d8f0;\"><strong>（B）启动应用，在浏览器中输入不同的请求进行测试</strong></span></p>\n<p><img alt=\"\" height=\"153\" src=\"image\\c17629d610a04d279fce84f85ca91fc7.png\" width=\"521\"/></p>\n<p> <span style=\"color:#38d8f0;\"><strong>（C）结合POSTMan工具测试其他请求类型</strong></span></p>\n<p><img alt=\"\" height=\"512\" src=\"image\\c827a712bd1348c693517a3bc2b70ba3.png\" width=\"861\"/></p>\n<h2 id=\"%C2%A03.5%20SpringBoot%E5%AE%9E%E7%8E%B0RESTFUL\"> 3.5 SpringBoot实现RESTFUL</h2>\n<p>        <strong>（1）简介</strong></p>\n<p>        它是一种互联网软件设计的风格，它只是提出了一组客户端和服务器交互时的架构理念和设计原则，基于这种理念和原则设计的接口可以更简洁，更有层次。</p>\n<blockquote>\n<p>比如我们要访问一个 http 接口：http://localhost:8080/boot/order?id=1021&amp;status=1 <br/> 采用 RESTFul 风格则 http 地址为：http://localhost:8080/boot/order/1021/1 </p>\n</blockquote>\n<p>        <strong>（2）开发RESTFUL</strong>，主要用到以下注解：</p>\n<ul><li><span style=\"color:#fe2c24;\"><strong>@PathVariable ：获取 url 中的数据，<strong>该注</strong>解是实现 RESTFul 最主要的一个注解</strong></span></li><li><span style=\"color:#fe2c24;\"><strong> </strong></span><span style=\"color:#0d0016;\">@PostMapping ：接收和处理post方式的请求</span></li><li><span style=\"color:#0d0016;\">@DeleteMapping：接收delete方式的请求，可以用GetMapping代替</span></li><li><span style=\"color:#0d0016;\">@PutMapping ：接收put方式的请求，可以用 PostMapping 代替 </span></li><li><span style=\"color:#0d0016;\">@GetMapping ：接收get方式请求</span><br/><br/> （3）案例：使用 RESTful 风格模拟实现对学生的增删改查操作</li></ul>\n<p>该项目集成了 MyBatis、spring、SpringMVC，通过模拟实现对学生的增删改查操作</p>\n<p><span style=\"color:#be191c;\"><strong>pom.xml文件</strong></span></p>\n<pre><code class=\"language-XML\">&lt;dependencies&gt; \n &lt;!--SpringBoot 框架 web 项目起步依赖--&gt; \n &lt;dependency&gt; \n     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; \n     &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; \n &lt;/dependency&gt; \n \n &lt;!--MyBatis 集成 SpringBoot 框架起步依赖--&gt; \n &lt;dependency&gt; \n     &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; \n     &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; \n     &lt;version&gt;2.0.1&lt;/version&gt; \n &lt;/dependency&gt; \n &lt;!--MySQL 驱动--&gt; \n &lt;dependency&gt; \n     &lt;groupId&gt;mysql&lt;/groupId&gt; \n     &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; \n &lt;/dependency&gt; \n&lt;/dependencies&gt; \n \n&lt;build&gt; \n &lt;!--指定配置资源的位置--&gt; \n &lt;resources&gt; \n     &lt;resource&gt; \n         &lt;directory&gt;src/main/java&lt;/directory&gt; \n         &lt;includes&gt; \n             &lt;include&gt;**/*.xml&lt;/include&gt; \n         &lt;/includes&gt; \n     &lt;/resource&gt; \n &lt;/resources&gt; \n \n &lt;plugins&gt; \n     &lt;!--mybatis 代码自动生成插件--&gt; \n     &lt;plugin&gt; \n         &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; \n         &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; \n         &lt;version&gt;1.3.6&lt;/version&gt; \n         &lt;configuration&gt; \n             &lt;!--配置文件的位置--&gt; \n             &lt;configurationFile&gt;GeneratorMapper.xml&lt;/configurationFile&gt; \n             &lt;verbose&gt;true&lt;/verbose&gt; \n             &lt;overwrite&gt;true&lt;/overwrite&gt; \n         &lt;/configuration&gt; \n     &lt;/plugin&gt; \n \n     &lt;plugin&gt; \n         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; \n         &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; \n     &lt;/plugin&gt; \n &lt;/plugins&gt; \n&lt;/build&gt; </code></pre>\n<p><span style=\"color:#be191c;\"><strong>application. properties核心配置文件</strong></span></p>\n<pre><code class=\"language-XML\">#配置内嵌 Tomcat 端口号 \nserver.port=8090 \n \n#配置项目上下文根 \nserver.servlet.context-path=/\n \n#配置数据库的连接信息 \n#注意这里的驱动类有变化 \nspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver \nspring.datasource.url=jdbc:mysql://localhost:3306/springboot?useUnicode=true&amp;characterEncoding=UTF-8&amp;useJDBCCompliantTimezoneShift=true&amp;useLegacyDatetimeCode=false&amp;serverTimezone=GMT%2B8 \n \nspring.datasource.username=root \nspring.datasource.password=root\n</code></pre>\n<p><span style=\"color:#be191c;\"><strong>通过逆向工程生成 DAO</strong></span></p>\n<p><img alt=\"\" height=\"106\" src=\"image\\e6d2f2b5670e4004a3f77af65dc71600.png\" width=\"205\"/></p>\n<p><span style=\"color:#be191c;\"><strong>创建 RESTfulController</strong></span></p>\n<pre><code class=\"language-java\">@RestController \npublic class RESTfulController { \n \n /** \n * 添加学生 \n * 请求地址：\nhttp://localhost:9090/014-springboot-restful/springBoot/student/wangpeng/23 \n * 请求方式：POST \n * @param name \n * @param age \n * @return \n */ \n @PostMapping(value = \"/springBoot/student/{name}/{age}\") \n public Object addStudent(@PathVariable(\"name\") String name, @PathVariable(\"age\") Integer age) { \n \n Map&lt;String,Object&gt; retMap = new HashMap&lt;String, Object&gt;(); \n retMap.put(\"name\",name); \n retMap.put(\"age\",age); \n \n \n return retMap; \n } \n \n /** \n * 删除学生 \n * 请求地址：\nhttp://localhost:9090/014-springboot-restful/springBoot/student/1 \n * 请求方式：Delete \n * @param id \n * @return \n */ \n @DeleteMapping(value = \"/springBoot/student/{id}\") \n public Object removeStudent(@PathVariable(\"id\") Integer id) { \n \n return \"删除的学生 id 为：\" + id; \n } \n \n /** \n * 修改学生信息 \n * 请求地址：\nhttp://localhost:9090/014-springboot-restful/springBoot/student/2 \n * 请求方式：Put \n * @param id \n * @return \n */ \n @PutMapping(value = \"/springBoot/student/{id}\") \n public Object modifyStudent(@PathVariable(\"id\") Integer id) { \n \n return \"修改学生的 id 为\" + id; \n } \n \n @GetMapping(value = \"/springBoot/student/{id}\") \n public Object queryStudent(@PathVariable(\"id\") Integer id) { \n \n return \"查询学生的 id 为\" + id; \n } \n} \n</code></pre>\n<p><span style=\"color:#be191c;\"><strong>使用 Postman 模拟发送请求，进行测试 ：</strong></span><br/><img alt=\"\" height=\"402\" src=\"image\\13048b1f36d946389b7310825893eb75.png\" width=\"728\"/></p>\n<p> <img alt=\"\" height=\"388\" src=\"image\\aff527fa91d1447aa9889c19483a966f.png\" width=\"785\"/></p>\n<p> <img alt=\"\" height=\"391\" src=\"image\\e6f529bd716c485e81242ca9b74e1625.png\" width=\"787\"/></p>\n<p> <img alt=\"\" height=\"375\" src=\"image\\e87dcaf4d5124660ad18a9070457aa4b.png\" width=\"614\"/></p>\n<p>         （4）请求冲突的问题</p>\n<p><span style=\"color:#a2e043;\"><strong>           解决方案：&lt;1&gt;修改路径     &lt;2&gt;修改请求方式</strong></span></p>\n<p>创建 RESTfulController 类，结合 Postman 进行测试说明 ：</p>\n<pre><code class=\"language-java\">@RestController \npublic class RESTfulController { \n \n /** \n * id:订单标识 \n * status：订单状态 \n * 请求路径：\nhttp://localhost:9090/015-springboot-restful-url-conflict/springBoot/orde\nr/1/1001 \n * @param id \n * @param status \n * @return \n */ \n @GetMapping(value = \"/springBoot/order/{id}/{status}\") \n public Object queryOrder(@PathVariable(\"id\") Integer id, @PathVariable(\"status\") Integer status) { \n \n Map&lt;String,Object&gt; map = new HashMap&lt;String,Object&gt;(); \n \n map.put(\"id\",id); \n map.put(\"status\",status); \n \n return map; \n } \n \n /** \n * id:订单标识 \n * status：订单状态 \n * 请求路径：\nhttp://localhost:9090/015-springboot-restful-url-conflict/springBoot/1/or\nder/1001 \n * @param id \n * @param status \n \n * @return \n */ \n @GetMapping(value = \"/springBoot/{id}/order/{status}\") \n public Object queryOrder1(@PathVariable(\"id\") Integer id, @PathVariable(\"status\") Integer status) { \n Map&lt;String,Object&gt; map = new HashMap&lt;String,Object&gt;(); \n \n map.put(\"id\",id); \n map.put(\"status\",status); \n \n return map; \n } \n \n /** \n * id:订单标识 \n * status：订单状态 \n * 请求路径：\nhttp://localhost:9090/015-springboot-restful-url-conflict/springBoot/1001\n/order/1 \n * @param id \n * @param status \n * @return \n */ \n @GetMapping(value = \"/springBoot/{status}/order/{id}\") \n public Object queryOrder2(@PathVariable(\"id\") Integer id, \n @PathVariable(\"status\") Integer status) { \n Map&lt;String,Object&gt; map = new HashMap&lt;String,Object&gt;(); \n \n map.put(\"id\",id); \n map.put(\"status\",status); \n \n return map; \n } \n \n /** \n * id:订单标识 \n * status：订单状态 \n * 请求路径：\nhttp://localhost:9090/015-springboot-restful-url-conflict/springBoot/1001\n/order/1 \n * @param id \n * @param status \n * @return \n */ \n \n\n @PostMapping(value = \"/springBoot/{status}/order/{id}\") \n public Object queryOrder3(@PathVariable(\"id\") Integer id,  @PathVariable(\"status\") Integer status) { \n Map&lt;String,Object&gt; map = new HashMap&lt;String,Object&gt;(); \n \n map.put(\"id\",id); \n map.put(\"status\",status); \n \n return map; \n } \n \n \n \n \n /** \n * query1 和 query2 两个请求路径会发生请求路径冲突问题 \n * query3 与 query1 和 query2 发生请求冲突 \n * 注意：虽然两个路径写法改变了，但是由于传递的两个参数都是 int 值，所以不知道该交给\n哪个请求进行处理 \n * 就会出现匹配模糊不清的异常，所以要想解决冲突，有两种方式： \n * 1.修改请求路径 \n * 2.修改请求方式 \n */ \n} \n</code></pre>\n<p>        （5）RESTful 原则</p>\n<ul><li>增 post 请求、删 delete 请求、改 put 请求、查 get 请求 </li><li><span style=\"color:#4da8ee;\"><strong>请求路径不要出现动词：</strong></span></li></ul>\n<p>        <img alt=\"\" height=\"150\" src=\"image\\e683c802905848afaf3d35709fe68e54.png\" width=\"437\"/></p>\n<ul><li> <strong>分页、排序等操作，不需要使用斜杠传参数</strong></li></ul>\n<p>        <img alt=\"\" height=\"131\" src=\"image\\705f107f530f48f5a623d7cbe7df79bb.png\" width=\"532\"/></p>\n<h2 id=\"3.6%C2%A0%C2%A0Spring%20Boot%20%E9%9B%86%E6%88%90%20Redis%C2%A0\">3.6  Spring Boot 集成 Redis </h2>\n<p>        完善根据学生 id 查询学生的功能：<span style=\"color:#956fe7;\"><strong>先从 redis 缓存中查找，如果找不到，再从数据库中<br/> 查找，然后放到 redis 缓存中。</strong></span></p>\n<p><span style=\"color:#faa572;\"><strong>具体实现步骤：</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>（A）首先通过 MyBatis 逆向工程生成实体 bean 和数据持久层 ：</strong></span></p>\n<p><img alt=\"\" height=\"149\" src=\"image\\792c56fe1ea543f79cd13d55c6f19c6e.png\" width=\"273\"/></p>\n<p><strong>（B）在 pom.xml 文件中添加 redis 依赖</strong></p>\n<pre><code class=\"language-XML\">&lt;!-- 加载 spring boot redis 包 --&gt; \n&lt;dependency&gt; \n &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; \n &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; \n&lt;/dependency&gt; \n</code></pre>\n<p> <strong>（C）Spring Boot 核心配置文件application.properties 如下：</strong></p>\n<pre><code class=\"language-java\">#配置内嵌 Tomcat 端口号 \nserver.port=9090 \n \n#配置项目上下文根 \nserver.servlet.context-path=/016-springboot-redis \n \n#配置连接 MySQL 数据库信息 \nspring.datasource.url=jdbc:mysql://127.0.0.1:3306/springboot？useUnicode=true&amp;characterEncoding=UTF8&amp;useJDBCCompliantTimezoneShift=true&amp;useLegacyDa\ntetimeCode=false&amp;serverTimezone=GMT%2B8 \nspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver \nspring.datasource.username=root \nspring.datasource.password=root\n \n#配置 redis 连接信息 \nspring.redis.host=127.0.0.1 \nspring.redis.port=6379 \n#spring.redis.password=root\n</code></pre>\n<p><strong>（D）启动redis服务</strong><img alt=\"\" height=\"314\" src=\"image\\9ea8fd34be9142eaad966f4f955c1e74.png\" width=\"1087\"/></p>\n<p> <strong>（E）RedisController类</strong></p>\n<pre><code class=\"language-java\">@RestController \npublic class RedisController { \n \n @Autowired \n private StudentService studentService; \n \n /** \n * 请求地址：\nhttp://localhost:9090/016-springboot-redis//springboot/allStudentCount \n * @param request \n * @return \n */ \n @GetMapping(value = \"/springboot/allStudentCount\") \n public Object allStudentCount(HttpServletRequest request) { \n \n Long allStudentCount = studentService.queryAllStudentCount(); \n \n return \"学生总人数：\" + allStudentCount; \n } \n} </code></pre>\n<p><strong>（F）StudentService 接口</strong></p>\n<pre><code class=\"language-java\">public interface StudentService { \n \n /** \n * 获取学生总人数 \n * @return \n */ \n Long queryAllStudentCount(); \n} </code></pre>\n<p><strong>（G）在 StudentServiceImpl 中注入 RedisTemplate，并编写根据 id获取学生的方法</strong></p>\n<p>        配置了上面的步骤，Spring Boot 将自动配置 RedisTemplate，在需要操作 redis 的类中注入 redisTemplate 即可。 <br/><span style=\"color:#fe2c24;\">        注意：Spring Boot 帮我们注入 RedisTemplate 类，泛型里面只能写 &lt;String, String&gt;、&lt;Object, Object&gt;或者什么都不写。</span></p>\n<pre><code class=\"language-java\">@Service \npublic class StudentServiceImpl implements StudentService { \n \n @Autowired \n private StudentMapper studentMapper; \n \n @Autowired \n private RedisTemplate&lt;Object,Object&gt; redisTemplate; \n \n @Override \n public Long queryAllStudentCount() { \n \n //设置 redisTemplate 对象 key 的序列化方式 \n redisTemplate.setKeySerializer(new StringRedisSerializer()); \n \n //从 redis 缓存中获取总人数 \n Long allStudentCount = (Long) redisTemplate.opsForValue().get(\"allStudentCount\"); \n //判断是否为空 \n if ( allStudentCount==null) { \n //去数据库查询，并存放到 redis 缓存中 \n \n allStudentCount = studentMapper.selectAllStudentCount(); \n \nredisTemplate.opsForValue().set(\"allStudentCount\",allStudentCount,15,TimeUnit.SECONDS); \n } \n return allStudentCount; \n } \n} \n</code></pre>\n<p><strong>（H）StudentMapper 接口</strong></p>\n<pre><code class=\"language-java\">@Mapper\npublic interface StudentMapper {\n /** \n * 获取学生总人数 \n * @return \n */ \n Long selectAllStudentCount(); \n}\n</code></pre>\n<p><strong>（I）StudentMapper 映射文件 </strong></p>\n<pre><code class=\"language-XML\">&lt;!--获取学生总人数--&gt; \n&lt;select id=\"selectAllStudentCount\" resultType=\"java.lang.Long\"&gt; \n select count(*) from  t_student \n&lt;/select&gt; \n</code></pre>\n<p><strong>（J）启动类 Application</strong></p>\n<p>在 SpringBoot 启动类上<span style=\"color:#956fe7;\"><strong>添加扫描数据持久层的注解并指定扫描包：</strong></span></p>\n<pre><code class=\"language-java\">@SpringBootApplication \n@MapperScan(basePackages = \"com.abc.springboot.mapper\")//扫描数据持久层 \npublic class Application { \n \n public static void main(String[] args) { \n SpringApplication.run(Application.class, args); \n } \n \n} </code></pre>\n<p><strong>（K）让 Student 类实现序列化接口（可选）</strong></p>\n<p><span style=\"color:#fe2c24;\"><strong>在类名上 Alt + 回车</strong></span>，如果没有提示生成序列化 id，那么需要做如下的配置 ：</p>\n<p><img alt=\"\" height=\"685\" src=\"image\\a9490888ebd7475aaa2285713baf1c6f.png\" width=\"972\"/></p>\n<p><img alt=\"\" height=\"92\" src=\"image\\d7cd122b4b6c4439beaa6567ae4f8e06.png\" width=\"720\"/></p>\n<p> <strong>（L）启动 SpringBoot 应用，访问测试</strong></p>\n<p><img alt=\"\" height=\"137\" src=\"image\\cff408f99e10411083e50822b368c495.png\" width=\"582\"/></p>\n<p></p>\n</div>\n</div>"}