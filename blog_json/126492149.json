{"blogid": "126492149", "writerAge": "码龄1年", "writerBlogNum": "32", "writerCollect": "295", "writerComment": "904", "writerFan": "458", "writerGrade": "5级", "writerIntegral": "1852", "writerName": "南猿北者", "writerProfileAdress": "writer_image\\profile_126492149.jpg", "writerRankTotal": "10642", "writerRankWeekly": "475", "writerThumb": "639", "writerVisitNum": "11516", "blog_read_count": "341", "blog_time": "于 2022-08-24 16:38:21 发布", "blog_title": "C++核心编程（二）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atelier-sulphurpool-light\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p></p>\n<div class=\"toc\">\n<h3>文章目录</h3>\n<ul><li><a href=\"#_5\">前言</a></li><li><a href=\"#__10\">一、 成员属性私有化</a></li><li><a href=\"#_58\">二、对象的初始化和清理</a></li><li><ul><li><a href=\"#1_62\">1、构造函数</a></li><li><a href=\"#2_70\">2、析构函数</a></li><li><a href=\"#3_126\">3、构造函数的分类</a></li><li><a href=\"#4_132\">4、构造函数的调用</a></li><li><ul><li><a href=\"#_171\">括号法</a></li><li><a href=\"#_181\">显示法</a></li><li><a href=\"#_195\">隐式转换法</a></li></ul>\n</li><li><a href=\"#5_201\">5、拷贝构造函数的调用时机</a></li><li><a href=\"#6_226\">6、构造函数调用规则</a></li><li><a href=\"#7_252\">7、深拷贝与浅拷贝</a></li></ul>\n</li><li><a href=\"#__335\">三、 初始化列表</a></li><li><a href=\"#_341\">静态成员</a></li><li><ul><li><a href=\"#_357\">静态成员变量</a></li><li><a href=\"#_371\">静态成员函数</a></li></ul>\n</li><li><a href=\"#__384\">四、 成员变量和成员函数分开存储</a></li><li><a href=\"#this_394\">五、this指针</a></li><li><a href=\"#__431\">六、 空指针访问成员函数</a></li><li><a href=\"#const_452\">七、const修饰成员函数</a></li></ul>\n</div>\n<p></p>\n<hr/>\n<h1><a id=\"_5\"></a>前言</h1>\n<p>记录C++核心编程（二）</p>\n<h1><a id=\"__10\"></a>一、 成员属性私有化</h1>\n<p>通过上一篇的总结我们可以知道，class的默认属性是私有属性；<br/> 为什么默认属性是私有的？<br/> 我们知道，假设一个对象是公有的话，那么是不是任何人都能访问并且修改它，是不是就会存在一些潜在的危险，为了避免这些危险，我们通常将一个对象的成员属性设置为私有，设置为私有有什么好处呢？<br/> <strong>1、可以控制成员属性的写和读的权限；<br/> 2、可以在写入数据时，对写入的数据进行检查和筛选，保证数据的有限性；</strong><br/> 我们用一个具体的实例来说话：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Person</span>\n<span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">private</span><span class=\"token operator\">:</span>\n\t<span class=\"token keyword\">int</span> m_Age<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n\t<span class=\"token keyword\">void</span> <span class=\"token function\">setM_Age</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> age<span class=\"token punctuation\">)</span><span class=\"token comment\">//通过成员函数来设置私有属性的值（控制写）</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\tm_Age <span class=\"token operator\">=</span> age<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token keyword\">int</span> <span class=\"token function\">getM_Age</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token comment\">//同理，通过成员函数来设置私有属性的值（控制读）</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\t<span class=\"token keyword\">return</span> m_Age<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">test1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\tPerson p1<span class=\"token punctuation\">;</span>\n\tp1<span class=\"token punctuation\">.</span><span class=\"token function\">setM_Age</span><span class=\"token punctuation\">(</span><span class=\"token number\">18</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> age <span class=\"token operator\">=</span> p1<span class=\"token punctuation\">.</span><span class=\"token function\">getM_Age</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\tcout <span class=\"token operator\">&lt;&lt;</span> age <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token function\">test1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\7095938531e84167aba0ff72701fa390.png\"/><br/> 我们可以发现我们无法直接修改私有属性的值；<br/> 我们也无法直接读取私有属性的值；<br/> 应为该成员属性被设置为私有了，我们根本访都访问不到它，何谈读和写，计算你找到了它，人家不给你“开门”，你啥也做不了！！！<br/> 但是我们的成员函数是公共的，我们可以通过它的成员函数，来间接对其进行修改和读取：<br/> <img alt=\"在这里插入图片描述\" src=\"image\\8024d553b3844baab289378fbc9c66af.png\"/><br/> ，如果我们设置成公有的话，那岂不是什么人都能入侵我们的房子，并且还能对我们的房子做一些未知的操作，这不就增加了我们房子的危险性；但是我们将防止设置为私有属性，也就相当于，只留了一条路来进入这个房子，不准你走其它道路，，当然你从我这那东西，也得通过“正规途径”，你看这样是不是方便管理和控制了；<strong>因此我们在创建一个类的时候，通常将成员属性设置为私有，并且提供一些公共的接口去管理这些私有属性；</strong><br/> 从上面的代码我们可以看到，一个人的年龄不可能超过150岁，也不可能为负数吧，于是我们可以在写数据的时候，对年龄这个属性进行一些限制，比如：<br/> <img alt=\"在这里插入图片描述\" src=\"image\\454da93aff37414c929abcb99beb334d.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"image\\ffe46f53cea445dda70a843abb76c31d.png\"/><br/> 这也体现了设置私有属性的第二个好处；</p>\n<h1><a id=\"_58\"></a>二、对象的初始化和清理</h1>\n<p>在日常生活中，我们买到了新手机，是不是发现都是我们手机的语言都是简体中文（在大陆买），在国外买的话，手机语言是不是又是其它语言了，这是不是就是对一个手机的初始化呢？当然在我们对于不用的手机，我们通常会拿去卖掉，或者直接砸掉，但是我们在做这些之前是不是应该格式化一下手机，清除一下手机的数据，以此来保护我们的隐私；<br/> 对于一个对象来说也是这样的，<strong>我们在创建对象的时候，编译器就会自动掉一个叫做构造函数的东西，帮我们完成对一个对象的初始化，同理在对象销毁的时候，也会自动掉一个叫做析构函数的东西将我们对象里面东西给清除掉；</strong><br/> <strong>对象的初始化和清理工作是编译器强制我们做的，如果我们不给一个类提供构造函数和析构函数的话，编译器会为我们提供，但是编译器所提供的函数都是无函数体的（也就是空实现，函数体里面啥也没有），因此我们在设计一个类的时候，同时需要考虑构造函数和析构函数的设计；</strong></p>\n<h2><a id=\"1_62\"></a>1、构造函数</h2>\n<pre><code>语法：类名+（）\n1、没有返回值，也不用写void；\n2、函数名和类名一样；\n3、构造函数可以发生重载技术\n4、程序在调用对象时会自动调用构造函数（也就是我们创建对象的时候），无需自动调用，而且只会调用一次，（但是我们可以指定调用的构造函数的类型）；\n</code></pre>\n<h2><a id=\"2_70\"></a>2、析构函数</h2>\n<pre><code>语法：~类名+（）\n1、没有返回值，也不写void；\n2、函数名和类名一样，但是要在函数名前面叫一个~；\n3、析构函数不能有参数，因此不能发生重载技术；\n4、程序在对象销毁前会自动调用析构函数，无需手动调用，而且只会调用一次；\n</code></pre>\n<p>接下来我们来具体看看语法的实现：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Person</span>\n<span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">private</span><span class=\"token operator\">:</span>\n\tstring m_name<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> m_age<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n\t<span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\tcout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"构造函数的调用\"</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token operator\">~</span><span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\tcout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"析构函数的调用\"</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">test2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\tPerson p1<span class=\"token punctuation\">;</span><span class=\"token comment\">//我们没有调用构造和析构函数</span>\n\n\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token comment\">//test1();</span>\n\t<span class=\"token function\">test2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">system</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"pause\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\884b153127a44ef28428606164bb9a12.png\"/></p>\n<p>我们可以发现编译器确实是自动调用了构造和析构函数；在创建p1的时候，编译器自动掉了构造函数，在离开test2时对象销毁，析构函数被自动调用；<br/> 同时如果我们没有设计构造函数和析构函数的话，编译器提供的构造和析构函数，就像我写的函数那样，只不过编译器提供的没有cout输出语句；<br/> 我们再来看看，在main函数里面创建给对象是不是这样呢？<br/> <img alt=\"在这里插入图片描述\" src=\"image\\2ec7b2713d8146caaf8994a47754c04a.png\"/><br/> 我们可以发现，在main函数中似乎只调用了构造函数，析构好像没有被调用，这是为什么？难道是对象并没有被销毁？<br/> 的确如此，我们代码在执行到system的时候就停了下来，也就是说我们这时候并没有离开main函数，自然对象也就没有被销毁，自然析构函数也就无法被调用：<br/> 他不是提醒我们按任意键继续吗？按呗，按了就能结束main函数，也就能销毁对象了：<br/> <img alt=\"在这里插入图片描述\" src=\"image\\091d95922c7b48a9bb369e0a375b4027.png\"/><br/> 还有一种办法就是，我们自己手动调用析构函数，让其提前清理：<br/> <img alt=\"在这里插入图片描述\" src=\"image\\8916af8a5ea84e20b272a4e1316db118.png\"/><br/> （为了方便演示稍微改了下Person的权限）但是我们无法手动调用构造函数，因为在创建对象的时候，编译器已经自动调用了，不需要我们去手动调用；当然我们也只能提前销毁对象里面的数据，并不能干扰对象的生命周期，在最后对象销毁的时候，编译器还是会自动调用析构函数来清理对象里面的数据：<br/> <img alt=\"在这里插入图片描述\" src=\"image\\2daae0aff5a64bc5b18e28da7c79118a.png\"/><br/> 同时我们需要注意下，就是我们设计的构造函数和析构函数一定要让编译器访问的到，不要设置为私有或者保护属性,不然编译器会报错！！！</p>\n<h2><a id=\"3_126\"></a>3、构造函数的分类</h2>\n<p>由于析构函数不能发生重载技术，自然其类型也就只有哪一个，但是构造函数就有多个类型：具体可以按两方面来细分：</p>\n<pre><code>1、按参数分：有参构造和无参构造,同时无参构造也被称为默认构造，编译器给我们提供的构造函数也就是无参构造；\n2、按类型分：普通构造构造函数和拷贝构造函数；\n</code></pre>\n<h2><a id=\"4_132\"></a>4、构造函数的调用</h2>\n<p>既然构造函数有这麽多种类，那么调用它的方式也是有三种：<br/> 测试代码：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Person</span>\n<span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n\tstring m_name<span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\tcout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"无参构造函数调用\"</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token function\">Person</span><span class=\"token punctuation\">(</span>string name<span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\tm_name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n\t\tcout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"有参构造函数调用\"</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> Person<span class=\"token operator\">&amp;</span>p<span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\tm_name <span class=\"token operator\">=</span> p<span class=\"token punctuation\">.</span>m_name<span class=\"token punctuation\">;</span>\n\t\tcout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"拷贝构造函数调用\"</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token operator\">~</span><span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\tcout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"析构函数调用\"</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">test3</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\tPerson p1<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token function\">test3</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>解析一下拷贝函数的参数：const修饰主要是为了防止被拷贝的对象的数据被无意修改，加引用主要是为了节省空间，不然函数的形参会产生一共与之一模一样，大小一样的形参对象，有点浪费空间，故我们选择了引用；</p>\n<h3><a id=\"_171\"></a>括号法</h3>\n<p>括号法是怎么个用法呢？<br/> <img alt=\"在这里插入图片描述\" src=\"image\\95fe0309a3234cb89630eada92bc88af.png\"/><br/> 当然看到这里，或许我们会疑惑如果是无参调用的话，既然无参嘛，那我们也用括号法，只是括号里面不写参数嘛 既将p1改写成：<br/> Person p1();可不可以呢？<br/> 我们来运行看看：<br/> <img alt=\"在这里插入图片描述\" src=\"image\\b2ffbe44a29f4e429442b8873df78017.png\"/><br/> 我们可以编译器发出了警告：为什么？<br/> <strong>主要是编译器：会把Person p1();解释为一个函数声明，该函数声明为 函数名为p1,形参没有，返回值为Person类型；而不会将其解释为括号法调用的无参构造，</strong><br/> 前面刚开始我们不是说过，程序在调用对象时会自动调用构造函数（也就是我们创建对象的时候），无需自动调用，而且只会调用一次，（但是我们可以指定调用的构造函数的类型）这里括号法里面的括号，就好似再让我们选择调用那种类型的构造函数！！！</p>\n<h3><a id=\"_181\"></a>显示法</h3>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\39225d32de0a48ea894fb132ed98708e.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"image\\38fc64d2cadc4f7eb3456f3009d333c9.png\"/></p>\n<p>显示法的本质：在等号的右边是一个匿名对象，该对象没有名字，只有空间，如果是我们只看右边的话，是不是就是一个括号法的调用；现在我们再把等号左边加进来看看，是不是等号左边就相当于再为这个匿名结构体取名字，让这个匿名结构体完成有名的转换！！！但是如果对于一个匿名结构体来说没有没有给它取名字，而直接让其调用构造函数的话（相当于我们只有p2的右边部分的话，在这条语句执行完过后，该匿名对象就会被销毁）：<br/> <img alt=\"在这里插入图片描述\" src=\"image\\3b4614fe7e76469c8e95e8d2d05c810c.png\"/><br/> <strong>我们可以发现输出语句是在调用析构函数之后才输出的，而调用析构函数的时候代表者对象的销毁，这说明在cout之前，该匿名对象就被销毁了；</strong><br/> 这点需要我们注意;<br/> 还有一点我们需要注意：<br/> <strong>不要使用匿名构造函数，初始化匿名对象：</strong><br/> <img alt=\"在这里插入图片描述\" src=\"image\\87b27c4d71a94fca94a9c110f0fc4e56.png\"/></p>\n<p>一运行起来我们发现，发生了错误，原因是重定义；主要是因为在编译器看来：<br/> Person （p2）与Person p2毫无差异，完全等价，相当于我们再一次定义了p2，所以会发生报错！！！</p>\n<h3><a id=\"_195\"></a>隐式转换法</h3>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\a6de428ef1f14c7b9d4deb22c7f57ff0.png\"/></p>\n<p>隐式转换法的本质是显示法：<br/> <img alt=\"在这里插入图片描述\" src=\"image\\3c3a9fc840b040c29bc010fe0e5a4736.png\"/></p>\n<h2><a id=\"5_201\"></a>5、拷贝构造函数的调用时机</h2>\n<p>1、一个相同类型的对象且已经赋值，作为右值赋给同类型的对象；<br/> <img alt=\"在这里插入图片描述\" src=\"image\\169b11ec54a145c78ebc38305a25f760.png\"/><br/> 2、对象作为函数形参；<br/> <img alt=\"在这里插入图片描述\" src=\"image\\19f0192e23a34758b5bb54d0326083d9.png\"/><br/> 形参作为实参的临时拷贝自然也是将实参的所有数据一起拷贝过来，自然调用拷贝构造函数；<br/> 3、对象作为函数返回值；<br/> <img alt=\"在这里插入图片描述\" src=\"image\\56d9c2f8bb994a45a9e3fd2dd070d857.png\"/><br/> 我们可以发现，在函数返回时调用了拷贝构造函数，我们能理解有参构造函数的调用，但是为什么会调用拷贝构造函数？<br/> 主要是因为：我们return的并不是p1也不可能是p1！！我i们返回的是p1里面的数据，编译器呢，在return创建了一个相同类型的对象，也就是匿名对象，编译器将p1里面的数据全部拷贝到这个匿名对象里面去，自然也就会调用拷贝构造函数，我们return的时候也是return的这个匿名对象；<br/> <strong>注意事项：</strong><br/> <strong>关于返回的匿名对的去留：</strong><br/> 1、如果返回值作为同类型对象的右初始值，那么这个匿名结构体变为有名；<br/> 就像这样：<br/> <img alt=\"在这里插入图片描述\" src=\"image\\6d0a21c1d1864a42b3296761c0c6a9db.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"image\\9daaa4e9ad374431bfae00a05ba8bd07.png\"/></p>\n<p>该匿名结构体在函数调用完毕过后，不会被析构掉，转而变为名字叫做p2的有名对象；<br/> 2、如果返回值作为同类型对象的右值，不是初值，则该匿名对象会将其里面数据拷贝进该同类型对象过后，随着该语句执行完，然后被析构掉：<br/> <img alt=\"在这里插入图片描述\" src=\"image\\e7d3f539fd334372a546b9992ef1c8d0.png\"/><br/> 3、单纯的只调用函数，该匿名结构体在该语句执行完过后，立马被销毁；<br/> <img alt=\"在这里插入图片描述\" src=\"image\\6f7e435272d245dba74d73d1fa909f44.png\"/></p>\n<h2><a id=\"6_226\"></a>6、构造函数调用规则</h2>\n<p>对于构造函数和析构函数来说，我们是必须调用的，如果没有设计，编译器会自动给我们提供，但却是空实现；<br/> 对于构造函数来说编译器一般会给我我们提供2种构造函数：<br/> 如果我们设计的类里面压根就没有设计构造和析构函数，<strong>一般情况下，编译器会自动给我们提供：无参构造函数、拷贝构造函数、析构函数；</strong><br/> 但是：<br/> 1、如果我们只提供了无参构造函数，编译器依旧会提供拷贝构造函数和析构函数；<br/> 2、如果我们只提供了有参构造函数，编译器不会提供无参构造函数，但会提供拷贝构造函数和析构函数<br/> 3、如果我们只提供了拷贝构造函数，那么编译器不会提供无参构造函数，只会提供析构函数；<br/> 我们依次来对3种情况进行测试：<br/> 情况一：<br/> <img alt=\"在这里插入图片描述\" src=\"image\\bc07ea9765024dbe87eca810e65b138b.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"image\\65a716392ddd43f4ae57e2255c7df1d8.png\"/></p>\n<p>我们可以发现程序很轻松就跑过去：我们在没有设计拷贝构造函数的情况下，p2也得却成功拷贝了p1里面的数据<br/> 情形二：<br/> <img alt=\"在这里插入图片描述\" src=\"image\\62cc0c734dbe461c8effe8393090c21c.png\"/></p>\n<p>我们可以很明显的发现我们的p1发生了错误，没有默认构造函数！！！<br/> 我们注释掉这代码，我们来看看拷贝构造函数：<br/> <img alt=\"在这里插入图片描述\" src=\"image\\f2ebdcd7c3c24289b951154f0877b142.png\"/><br/> 我们可以发现实际符合预期；<br/> 情形3：<br/> <img alt=\"在这里插入图片描述\" src=\"image\\345401792d3a4d80bae8baa1fe04d6f7.png\"/><br/> 我们可以发现实际是符合预期的；</p>\n<h2><a id=\"7_252\"></a>7、深拷贝与浅拷贝</h2>\n<p>这个主要发生在拷贝构造函数里面：<br/> 什么是浅拷贝。就是简单的拷贝：<br/> <img alt=\"在这里插入图片描述\" src=\"image\\4efe34ef515b46ccbb733ed0c581e2df.png\"/><br/> 举个例子：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Person</span>\n<span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">private</span><span class=\"token operator\">:</span>\n\t<span class=\"token keyword\">int</span><span class=\"token operator\">*</span> Age<span class=\"token punctuation\">;</span><span class=\"token comment\">//利用堆区开辟空间</span>\n\tstring m_name<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n\t<span class=\"token keyword\">void</span> <span class=\"token function\">setDate</span><span class=\"token punctuation\">(</span>string name<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> age<span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\tm_name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n\t\tAge <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span>age<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token keyword\">int</span> <span class=\"token function\">getAge</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\t<span class=\"token keyword\">return</span> <span class=\"token operator\">*</span>Age<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\tstring <span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\t<span class=\"token keyword\">return</span> m_name<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>现在我们什么构造和析构函数都没设计，我们用编译器提供的；<br/> <img alt=\"在这里插入图片描述\" src=\"image\\4b4fffba8d964a3ca9d29bae0bc6157a.png\"/></p>\n<p>我们可以发现结果非常完美，的却如此，但是有一个小瑕疵，就是我们向堆区申请了空间，我们似乎忘记释放了，这可是个不好的习惯，我们改在何时释放？是不是对象销毁的时候释放最合适；<br/> 那么我们可以在析构函数里面设计释放的这个操作：<br/> <img alt=\"在这里插入图片描述\" src=\"image\\b9b2f45ff8104e3db92b2e6a68c06c16.png\"/><br/> 我们接下来再来运行看看：<br/> <img alt=\"在这里插入图片描述\" src=\"image\\16b5f317e4f84e79b19fca9d1c2c4f89.png\"/><br/> 我们发现程序崩了，为什么？？？？<br/> 主要是因为浅拷贝存在的问题：我们前面说了，浅拷贝就是单纯的数据的拷贝，画图理解就是：<br/> <img alt=\"在这里插入图片描述\" src=\"image\\b2194b2d5f224b6b8b9f83b78363af7c.png\"/><br/> 我们在对象销毁的的时候，按照栈区先进后出的原则，我们先对p2对象进行析构，那么我们是不是在这时候就会把我们从堆上开辟的空间给释放了，这不编译器不会报错；第二次我们再来对p1析构，同理我们p1里面的Age也存的是所开辟的空间的地址，但是我们之前在p2里面已经对这块空空间释放过了，我们现在又会对该空间进行释放，这不就造成，对同一块空间，进行多次释放吗？编译器自然会崩；<br/> 那么我们应该如何解决该问题？<br/> 这时候，这样编译器提供给我们拷贝函数的拷贝方式似乎不合理，我们需要重新设计一下拷贝方式，我们应该在堆区上重新开辟一块空间，我们可以这样设计：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Person</span>\n<span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">private</span><span class=\"token operator\">:</span>\n\t<span class=\"token keyword\">int</span><span class=\"token operator\">*</span> Age<span class=\"token punctuation\">;</span><span class=\"token comment\">//利用堆区开辟空间</span>\n\tstring m_name<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n\t<span class=\"token keyword\">void</span> <span class=\"token function\">setDate</span><span class=\"token punctuation\">(</span>string name<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> age<span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\tm_name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n\t\tAge <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span>age<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token keyword\">int</span> <span class=\"token function\">getAge</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\t<span class=\"token keyword\">return</span> <span class=\"token operator\">*</span>Age<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\tstring <span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\t<span class=\"token keyword\">return</span> m_name<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> Person<span class=\"token operator\">&amp;</span> p<span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\tm_name <span class=\"token operator\">=</span> p<span class=\"token punctuation\">.</span>m_name<span class=\"token punctuation\">;</span>\n\t\tAge <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>p<span class=\"token punctuation\">.</span>Age<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token operator\">~</span><span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\t<span class=\"token keyword\">delete</span>  Age<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>我们再来运行一遍代码：<br/> <img alt=\"在这里插入图片描述\" src=\"image\\e8794120e5eb4ffa8f3e2bf925ccf4d0.png\"/><br/> 程序很愉快运行起来，没有刚才的报错；</p>\n<h1><a id=\"__335\"></a>三、 初始化列表</h1>\n<p>主要分为两种初始化方式：<br/> 1、传统方式：<br/> <img alt=\"在这里插入图片描述\" src=\"image\\e66102992ce14df9b75c90dc0e49f08c.png\"/><br/> 2、初始化列表：<br/> <img alt=\"在这里插入图片描述\" src=\"image\\0d80c68001a1452786872471ef7df3ce.png\"/></p>\n<h1><a id=\"_341\"></a>静态成员</h1>\n<p>静态成员就是在成员变量和成员函数前加上关键字static,称为静态成员静态成员分为:</p>\n<p>●静态成员变量</p>\n<p>。所有对象共享同一份数据</p>\n<p>。在编译阶段分配内存</p>\n<p>。类内声明，类外初始化</p>\n<p>●静态成员函数</p>\n<p>。所有对象共享同一个函数</p>\n<p>。静态成员函数只能访问静态成员变量</p>\n<h2><a id=\"_357\"></a>静态成员变量</h2>\n<p>静态成员变量不属于任何一个具体的对象，但是所有对象都能对其进行修改和访问，在内存中只存在一份；<br/> <img alt=\"在这里插入图片描述\" src=\"image\\05c962e7bcc84df2a127f281b11e6335.png\"/><br/> 我们可以发现，我们无法正常编译，编译器告诉我们不认识？？在访问静态变量前我们需要对其进行类外声明；<br/> 比如：int Person::c=0;告诉编译器我们Person作用域下的静态变量，初始化为0；<br/> 像这样设计过后我们就能正常访问了：</p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\3c42e81bafad49eabbc9e254f37cba51.png\"/><br/> 当然对于静态成员变量也是有访问权限的，如果你将其设计为私有权限，我们计算声明了也是访问不到的：<br/> <img alt=\"在这里插入图片描述\" src=\"image\\0e0f1f02b0a448ff85fb2ea5d4a19919.png\"/></p>\n<p>对于公共权限的静态成员变量我们有两种访问方式，上述是一种；<br/> 还有一种就是：通过类名进行访问：<br/> <img alt=\"在这里插入图片描述\" src=\"image\\3b7c3700f83c4506b521605b6e57470e.png\"/></p>\n<h2><a id=\"_371\"></a>静态成员函数</h2>\n<p>和静态成员变量一样：不属于任何一个具体对象，所有对象共享一份；<br/> 与静态成员变量不一样，静态成员函数不需要声明，但是访问方式是一样的<br/> 1、通过对象访问：<br/> <img alt=\"在这里插入图片描述\" src=\"image\\1ecd3fe1c2484c10bc518f5323d1f090.png\"/></p>\n<p>2、通过类名进行访问：<br/> <img alt=\"在这里插入图片描述\" src=\"image\\25a9c8f82884409389c7ff7dc7538f5f.png\"/><br/> 注意事项：<br/> 1、静态成员函数，只能访问静态成员变量，不能访问非静态成员变量；应为我们静态成员变量在只有一份，我们可以很轻松的读取和写入，但是对于非静态成员变量，内存中，不同的对象，各有各的，静态成员函数，无法辨别所对应的成员变量是那个对象的，自然也就无法精确修改（主要是因为静态成员函数里面没有this指针），往大了说静态成员函数只能访问静态成员变量，其它非静态成员访问不到；但是非静态成员函数能访问静态成员，应为非静态成员函数里面有this指针<br/> <img alt=\"在这里插入图片描述\" src=\"image\\c0cd3c9e0a5145c886570d8175e7e172.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"image\\144b72281ce64f7ea1b9f6bb3e70afdf.png\"/></p>\n<h1><a id=\"__384\"></a>四、 成员变量和成员函数分开存储</h1>\n<p>我们先来计算一下，空类都大小：<br/> <img alt=\"在这里插入图片描述\" src=\"image\\0f669577a57e47258f5878615d7e796b.png\"/><br/> 我们可以发现结果是1，为什么？<br/> 主要是因为，编译器为了区分不同的对象，特意划分的一块区域；比如：<br/> Person p1;和Person p2;是两个不同的对象，他们不可能使用同一块空间把，我们于是就给1块空间，意思意思，加以区分这是两个对象，不是一个；这一个字节，只起占位作用；<br/> <img alt=\"在这里插入图片描述\" src=\"image\\47bf99c3b67745f2a9b5b85aa12080d6.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"image\\5f71047996a745b7919cc4b49096c3c0.png\"/><br/> 不管我有多少个静态成员变量，我sizeof’算的都是非静态成员变量，算的是所有对象都有的；</p>\n<h1><a id=\"this_394\"></a>五、this指针</h1>\n<p>每一个非静态成员函数只会诞生一份函数实例， 也就是说多个同类型的对象会共用一块代码那么问题是:这-块代码是如何区分那个对象调用自己的呢?</p>\n<p>C+ +通过提供特殊的对象指针, this指针,解决上述问题。this指针指向被调用的成员函数所属的对象</p>\n<p>this指针是隐含每一个非静态成员函数内的一种指针</p>\n<p>this指针不需要定义，直接使用即可，同时this指针不能被修改（指针不能变）；<br/> <strong>this指针本质是：Person*const this；</strong></p>\n<p><strong>this指针的用途:</strong></p>\n<p>●当形参和成员变量同名时，可用this指针来区分</p>\n<p>●在类的非静态成员函数中返回对象本身，可使用return *this<br/> 用途1：<br/> <img alt=\"在这里插入图片描述\" src=\"image\\78895671858c4561bb525a6c005507ef.png\"/><br/> 我们可以发现并没有赋值成功，主要是编译器将对象的a、b也判断成了形参的a、b，自然也就无法成功初始化；<br/> 如何解决？<br/> this不是指向调用该函数的对象的指针吗，我们利用this指针来访问对象的成员变量就行了：<br/> <img alt=\"在这里插入图片描述\" src=\"image\\9cff69da29224545a4a3e9e1f63ea60c.png\"/><br/> 用途2：<br/> 如果我们设计一个函数让a自增10：<br/> <img alt=\"在这里插入图片描述\" src=\"image\\d972e018d7e34f3a8766d237f0b5d323.png\"/><br/> 如果我们还想加10，我们就在调一次<br/> 多次加10，就多次调用；<br/> 除了图中所写的我们还可以将fun1的返回值写成引用的形式：<br/> <img alt=\"在这里插入图片描述\" src=\"image\\011edb98a4874e59a315ae17bed6c1b0.png\"/><br/> 形成链式访问；<br/> 那我们可不可以将返回值设计成Person类型？<br/> <img alt=\"在这里插入图片描述\" src=\"image\\a0662c8bc00d4831b50aa98b1d5c73ad.png\"/><br/> 显然不行，为什么？<br/> 我们前面说了对象最为返回值，函数返回的不是同一个对象，我们的链式访问都不是对同一个对象的成员函数进行访问，怎么肯自加呢？（翻看前面拷贝构造函数调用时机）<br/> 我们还可以设计成指针：<br/> <img alt=\"在这里插入图片描述\" src=\"image\\2a38741219d74270aed4d8a7cb6a8938.png\"/><br/> 当然this指针在静态成员函数中是没有的，这也是静态成员函数不能访问非静态成员变量的原因；</p>\n<h1><a id=\"__431\"></a>六、 空指针访问成员函数</h1>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\cc21a80e1cd64b7fa2dd2c750cb089fe.png\"/><br/> 我们可以发现fun2很轻松访问到了；<br/> 再来看看fun1：<br/> <img alt=\"在这里插入图片描述\" src=\"image\\c592b82b62144611ba110e40f29fe17e.png\"/></p>\n<p>我们发现代码崩了；<br/> 为什么：<br/> 主要是因为：<br/> 在编译器看来：<br/> p-&gt;fun2()<br/> 等价于：fun2();<br/> p-&gt;fun1()<br/> 等价于:fun1();<br/> a+=10等价于this-&gt;a+=10;<br/> this=NULL;<br/> 我们对空指针进行了解引用；坑=肯定不行；<br/> 同理：Person A；<br/> A.fun2();//在编译器看来就等价于fun2（）；<br/> A.fun1();//在编译器看来就等价于fun1（）；</p>\n<h1><a id=\"const_452\"></a>七、const修饰成员函数</h1>\n<p><strong>常函数:</strong></p>\n<p>●成员函数后加const后我们称为这个函数为常函数</p>\n<p>●常函数内不可以修改成员属性</p>\n<p>●成员属性声明时加关键字mutable后，在常函数中依然可以修改</p>\n<p><strong>常对象:</strong></p>\n<p>●声明对象前加const称该对象为常对象<br/> ●常对象只能调用常函数<br/> 情况1：<br/> <img alt=\"在这里插入图片描述\" src=\"image\\a64c7f4095c74d6ea071409d63bdfc46.png\"/><br/> 我们可以发现，在加了const修饰过后，我们无法该表对象里面的成员变量；<br/> 但是对于一些特殊的变量我们可以加mutable来取消const的影响：<br/> <img alt=\"在这里插入图片描述\" src=\"image\\2f347477a6bd40f2bce4c71c567ae819.png\"/><br/> 情形2：<br/> 被const修饰的对象，只能调用同样被const修饰的成员函数（常函数）为什么？<br/> const作用就是不让我们修改对象内部的数据，当然会限制任何方式来修改，包括通过成员函数，没有用const修饰过的函数，存在可以修改const修饰对象的嫌疑，而加了const修饰的成员函数不会，应为成员函数加const，保证了成员变量不会通过成员函数来修改：<br/> <img alt=\"在这里插入图片描述\" src=\"image\\14c94b5c363240e0a406b4b6c7616194.png\"/></p>\n<p>本质上const不是修饰成员函数的，而是修饰this指针的<br/> 既保证不能通过指针解引用的方式去改变：Person <strong>const</strong> * const this； （是前一个const）<br/> 这也是为什么const修饰的对象只能访问常函数；</p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}