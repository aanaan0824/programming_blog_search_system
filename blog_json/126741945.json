{"blogid": "126741945", "writerAge": "码龄1年", "writerBlogNum": "374", "writerCollect": "209", "writerComment": "11", "writerFan": "8394", "writerGrade": "5级", "writerIntegral": "3906", "writerName": "m0_67391907", "writerProfileAdress": "writer_image\\profile_126741945.jpg", "writerRankTotal": "5051", "writerRankWeekly": "936", "writerThumb": "32", "writerVisitNum": "158343", "blog_read_count": "15", "blog_time": "于 2022-09-07 11:20:12 发布", "blog_title": "java面试题：java中的单例设计模式及两种实现方法的代码举例", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p>java面试时经常会问到关于单例设计模式，因为它能考察的知识点较多且在开发中经常用到。</p>\n<p>那我就来说一说我对于单例设计模式的一些浅见。</p>\n<p>首先，在Java中，什么是单例呢？</p>\n<p>就是保证类在内存中只有一个对象。</p>\n<p>那么问题来了，如何才能保证类在内存中只有一个对象呢？</p>\n<p>A：把构造方法私有化；</p>\n<p>B：在成员变量中自己new一个类实例，并用private将其私有化且用static将其静态修饰；</p>\n<p>C：对外提供一个静态方法返回这个对象。</p>\n<p>依据以上的思路，就可以写出如下的代码：</p>\n<pre><code>public class Student{\n    private Student(){}\n    private static Student s=new Student();\n    public static Student getStudent(){\n        return s;\n    }\n}\n</code></pre>\n<p>以上的实现方法在业内称为”饿汉式”，可以这样理解：这个单例对象随着类的加载就被创建出来了，就像饿狼扑食一样，这里的”狼”就是单例对象，而“食”就是类加载。</p>\n<p>还有另一种实现方法称为“懒汉式”。先看代码实现：</p>\n<pre><code>public class Student{\n    private Student(){}\n    private static Student s=null;\n    public static Student getStudent()\n    {\n        if(s==null)\n        {\n            s=new Student();\n        }\n        return s;\n    }\n}\n</code></pre>\n<p>从代码中可以看出：这个单例对象是随着调用类的静态方法才被被创建的，并不是随着类的加载而被创建，所以它要滞后于类加载，故称为“懒汉式”。</p>\n<p>但以上代码会出现线程安全问题。</p>\n<p>那就让我来分析一下为什么会出现线程安全问题</p>\n<p>判断是否会出现线程安全问题必须满足一下三个条件，缺一不可：</p>\n<p>A：是否为多线程环境；</p>\n<p>B：是否有共享数据；</p>\n<p>C：是否有多条语句操作共享数据</p>\n<p>那我就按这三个条件分析以上代码：</p>\n<p>A是有可能的</p>\n<p>B共享数据就是 Student对象</p>\n<p>C</p>\n<p>if(t==null){<!-- --><br/> t=new Student();<br/> }</p>\n<p>这里有两条语句在操作共享数据</p>\n<p>那么问题又来了，如何解决线程安全问题呢？</p>\n<p>加锁</p>\n<p>而加锁又有两种实现方法：1.同步代码块；2.同步方法</p>\n<p>显然对以上代码而言，同步方法是个简洁明了的。所以修改后的代码如下：</p>\n<pre><code>public class Student{\n    private Student(){}\n    private static Student s=null;\n    public static synchronized Student getStudent(){\n        if(s==null)\n        {\n            s=new Student();\n        }\n        return s;\n    }\n]\n</code></pre>\n<p>那么，这两种单例实现代码的应用场景是什么呢？</p>\n<p>答案：开发一般用“饿汉式”，因为它不会出现问题且代码简单，面试时用“懒汉式”，因为它不仅考察了单例模式实现，还考察了线程安全。</p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}