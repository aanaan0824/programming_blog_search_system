{"blogid": "125101696", "writerAge": "码龄10年", "writerBlogNum": "51", "writerCollect": "360", "writerComment": "72", "writerFan": "127", "writerGrade": "5级", "writerIntegral": "2600", "writerName": "魔术师Dix", "writerProfileAdress": "writer_image\\profile_125101696.jpg", "writerRankTotal": "7596", "writerRankWeekly": "60150", "writerThumb": "115", "writerVisitNum": "209852", "blog_read_count": "1245", "blog_time": "已于 2022-06-02 16:33:30 修改", "blog_title": "【Unity】六边形地图格子基础", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>        这里的六边形地图，指SLG游戏中的大世界地图，用六边形的网格进行平铺。例如文明，以及部分SLG手游。</p>\n<p>        这里介绍六边形地图格子的基本概念，以及具体数学实现代码。</p>\n<p></p>\n<h1>1、基本概念</h1>\n<p>        这里强制规定，所有的格子都是<strong>尖头朝上</strong>（Z轴正向）。</p>\n<p>        地图的起点在左下角（保证一个轴的值为正）。</p>\n<p></p>\n<h2>1.1、 格子坐标</h2>\n<p>        六边形的坐标，在逻辑计算中采用立体坐标，<strong>坐标的三个值之和为0 （X+Y+Z =0 ）</strong>。坐标定义可以设置为 XYZ，也可以设置为 QRS ，如下图所示：</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\1446943ff70c4cb0b91928cf09a4af70.png\"/></p>\n<p></p>\n<p>        坐标的三个值分别代表六边形的三个朝向的偏移值。</p>\n<p>        之所以使用立体坐标，因为其对称性好，而且简便公式是最多的。其缺点是在视图上不够直观，不能直观地反应出平面位置。所以，在针对玩家进行显示时，建议不要直接使用立体坐标，而是转换成平面坐标（XY）。</p>\n<p></p>\n<h2>1.2、 格子尺寸</h2>\n<p>        关于格子有以下几个基本概念：</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\f0a27d13cb3645368875cdb2084bf614.png\"/></p>\n<p></p>\n<p><strong>        内径</strong>：中心到边的距离（OB）；</p>\n<p><strong>        外径</strong>：中心到角的距离（OA）；</p>\n<p>        显然，这里边长就等于外径 （AC = OA）。</p>\n<p>        经过简单的三角函数计算，内径和外径的比例如下：</p>\n<pre><code class=\"language-cs\">        /// &lt;summary&gt;\n        /// 内径/外径  3^0.5 / 4 \n        /// &lt;/summary&gt;\n        public const float InnerToOutter = 0.8660254037844386f;\n\n        /// &lt;summary&gt;\n        /// 外径/内径  4 / 3^0.5 \n        /// &lt;/summary&gt;\n        public const float OutterToInner = 1.154700538379252f;</code></pre>\n<p>        <span style=\"color:#a2e043;\"><em>建议保证内径为整数，这样在做寻路计算时，走的格子距离就是整数。</em></span></p>\n<p></p>\n<h2>1.3、 格子方向</h2>\n<p>        对于六边形格子，<strong>是只能通过边跨越到另一个格子</strong>，且尖头朝上。因此方向就是：正左、正右、左上、右上、左下、右下六个方向。在坐标中的转换如下：   </p>\n<pre><code class=\"language-cs\">        public static readonly int3[] HexDirOffset = new int3[]\n            {\n                new int3(0,0,0),//原点\n                new int3(1,-1,0),//正右\n                new int3(0,-1,1),//右上\n                new int3(-1,0,1),//左上\n                new int3(-1,1,0),//正左\n                new int3(0,1,-1),//左下\n                new int3(1,0,-1),//右下\n            };</code></pre>\n<p>     </p>\n<h1>2、 格子平铺</h1>\n<p>        六边形的格子平铺也是尽量铺成矩形，这样方便设计地图。但这样的平铺，在计算边界时就要注意在X轴上要加上垂直偏移。        </p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\daf7cc9a855340bcb5fe35012e850a79.png\"/></p>\n<p>        如上图所示，在平铺，左下为【0,0,0】的情况下，在X轴上会出现负数，但是Z轴确定是正数，Y轴是负数。</p>\n<p>        提供给玩家显示的时候，改为平面坐标（XY），转换方式下文会提到。</p>\n<p>        结果如下图所示：</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\7dc9ec1ddbac455f96a18e8a787b04a4.png\"/></p>\n<p>         平铺坐标的显示范围就能和配置的范围相同了，如上图水平、垂直都是10*10。但是视图坐标只用来显示用，逻辑计算还是用立体坐标计算。</p>\n<p></p>\n<h1>3、 坐标转换</h1>\n<h2>3.1、 六边形坐标转换为Unity坐标</h2>\n<h2></h2>\n<p>        ColumnLength ： 列间距（内径的2倍）；</p>\n<p>        HexTileInnerRadius ： 内径 ；</p>\n<p>        RowLength ： 行间距(外径的1.5f倍) ；</p>\n<pre><code class=\"language-cs\">        /// &lt;summary&gt;\n        /// 把六边形坐标转换成Unity坐标\n        /// (Y 轴为0）；\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"hexCoordinate\"&gt;六边形地块&lt;/param&gt;\n        /// &lt;returns&gt;Unity世界坐标，六边形的中心点&lt;/returns&gt;\n        public static float3 HexCoordineToUnityPos_V3(this HexGrid hexCoordinate)\n        {\n            float x = (hexCoordinate.x * ColumnLength) + (hexCoordinate.z * HexTileInnerRadius);\n            float z = hexCoordinate.z * RowLength;\n            return new float3(x, 0, z);\n        }</code></pre>\n<p></p>\n<h2>3.2、 Unity坐标转换为六边形坐标</h2>\n<p>        使用三角函数进行计算：</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\ccc975e97a3747ad99a415a9c7eecdcb.png\"/></p>\n<p>         代码如下：</p>\n<p>        HexTileOuterRadius ： 外径</p>\n<pre><code class=\"language-cs\">        /// &lt;summary&gt;\n        /// 将世界坐标（UnityPos) 转换到目标 HexGrid 下标\n        /// （这个方法不是很精确）\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"unityX\"&gt;世界坐标&lt;/param&gt;\n        /// &lt;param name=\"unityZ\"&gt;世界坐标&lt;/param&gt;\n        /// &lt;returns&gt;所属的 HexTile 坐标&lt;/returns&gt;\n        public static HexGrid UnityPosToHexGrid(float unityX, float unityZ)\n        {\n            float q = (Sqrt_3 / 3.0f * unityX) - (1.0f / 3.0f * unityZ);\n            float r = 2.0f / 3.0f * unityZ;\n\n            return new HexGrid(HexRound(q / HexTileOuterRadius, r / HexTileOuterRadius));\n        }\n                \n        /// &lt;summary&gt;\n        /// 坐标规整；\n        /// &lt;/summary&gt;\n        private static Vector2Int HexRound(float q, float r)\n        {\n            float s = -q - r;\n            int rq = Mathf.RoundToInt(q);\n            int rr = Mathf.RoundToInt(r);\n            int rs = Mathf.RoundToInt(s);\n            float q_diff = Mathf.Abs(rq - q);\n            float r_diff = Mathf.Abs(rr - r);\n            float s_diff = Mathf.Abs(rs - s);\n            if (q_diff &gt; r_diff &amp;&amp; q_diff &gt; s_diff)\n                rq = -rr - rs;\n            else if (r_diff &gt; s_diff)\n                rr = -rq - rs;\n            return new Vector2Int(rq, rr);\n        }</code></pre>\n<p>        关于坐标规整：</p>\n<p>        因为在计算时，通过三角函数会有小数的问题，将其四舍五入成整数，不总是能得到最近的格子坐标，且保证三个数之和为0 。</p>\n<p>        因此需要对坐标进行规整计算。</p>\n<p></p>\n<h2>3.3、 立体坐标和视图坐标的转换</h2>\n<p>        因为存在多种视图坐标和立体坐标的表示方法，因此坐标转换一定是要配套使用。</p>\n<p>        但，一般在一个游戏中，会限定同一种表示方法。因此可以直接用如下代码进行计算。</p>\n<h3>3.3.1、 立体坐标转换为视图坐标</h3>\n<p>        x轴减去y轴的值，并出2即可：</p>\n<pre><code class=\"language-cs\">        /// &lt;summary&gt;\n        /// 转换成视图坐标\n        /// &lt;/summary&gt;\n        public static Vector2Int ToViewCoordiante(this Vector3Int logicCoordiante)\n        {\n            int x = (logicCoordiante.x - logicCoordiante.y) / 2;\n            int y = logicCoordiante.z;\n            return new Vector2Int(x, y);\n        }</code></pre>\n<h3>3.3.2、 视图坐标转换为立体坐标</h3>\n<pre><code class=\"language-cs\">        /// &lt;summary&gt;\n        /// 转换成立体坐标\n        /// &lt;/summary&gt;\n        public static HexGrid ToCubeCoordiante(this Vector2Int viewGrid)\n        {\n            int z = viewGrid.y;\n            int x = viewGrid.x - viewGrid.y / 2;\n            return new HexGrid(x, z);\n        }</code></pre>\n<p></p>\n<p></p>\n</div>\n</div>"}