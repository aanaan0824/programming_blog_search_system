{"blogid": "123167485", "writerAge": "码龄2年", "writerBlogNum": "33", "writerCollect": "259", "writerComment": "64", "writerFan": "2385", "writerGrade": "3级", "writerIntegral": "478", "writerName": "北村南", "writerProfileAdress": "writer_image\\profile_123167485.jpg", "writerRankTotal": "31148", "writerRankWeekly": "2982", "writerThumb": "72", "writerVisitNum": "48087", "blog_read_count": "4092", "blog_time": "已于 2022-07-12 15:17:20 修改", "blog_title": "【Unity触控】实现缩放和360度观察模型、单击、双击、滑动", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h2> 话不多说，先看实现效果！</h2>\n<p class=\"img-center\"><img alt=\"\" height=\"559\" src=\"https://img-blog.csdnimg.cn/8512eab0563a4ae7b52f06dbc28881d0.gif\" width=\"251\"/></p>\n<p>想要更牛X一点可以和<a class=\"link-info\" href=\"https://beicunnan.blog.csdn.net/article/details/124208270?spm=1001.2014.3001.5502\" title=\"AR增强现实技术\">AR增强现实技术</a>相结合，如下效果 </p>\n<p class=\"img-center\"><img alt=\"\" height=\"288\" src=\"https://img-blog.csdnimg.cn/1f8474a3702348a39fcfd47f7305fa90.gif\" width=\"640\"/></p>\n<p>若想实现以上的AR增强现实效果可参考以下文章</p>\n<p><a href=\"https://beicunnan.blog.csdn.net/article/details/124208270?spm=1001.2014.3001.5502\" title=\"(2条消息) EasyAR实战项目图像识别与模型交互（全网首发，保姆级教程）_北村南的博客-CSDN博客_easyar\">(2条消息) EasyAR实战项目图像识别与模型交互（全网首发，保姆级教程）_北村南的博客-CSDN博客_easyar</a></p>\n<h2></h2>\n<h2>工具 </h2>\n<p>我们主要使用Unity官方提供的Touch接口，里面已经包含了大量的触屏操作，完全满足我们的一般业务需求，该接口中主要方法如下</p>\n<p><strong>Touch</strong>接口</p>\n<table><tbody><tr><td><a href=\"https://docs.unity.cn/cn/2020.3/ScriptReference/Touch-altitudeAngle.html\" title=\"altitudeAngle\">altitudeAngle</a></td><td>0 弧度值指示触笔平行于表面，pi/2 指示垂直。</td></tr><tr><td><a href=\"https://docs.unity.cn/cn/2020.3/ScriptReference/Touch-azimuthAngle.html\" title=\"azimuthAngle\">azimuthAngle</a></td><td>0 弧度值指示触笔指向沿着设备 X 轴方向。</td></tr><tr><td><a href=\"https://docs.unity.cn/cn/2020.3/ScriptReference/Touch-deltaPosition.html\" title=\"deltaPosition\">deltaPosition</a></td><td>自上次像素坐标更改以来的位置增量。</td></tr><tr><td><a href=\"https://docs.unity.cn/cn/2020.3/ScriptReference/Touch-deltaTime.html\" title=\"deltaTime\">deltaTime</a></td><td>自记录的 Touch 值上次更改以来经过的时间。</td></tr><tr><td><a href=\"https://docs.unity.cn/cn/2020.3/ScriptReference/Touch-fingerId.html\" title=\"fingerId\">fingerId</a></td><td>触摸的唯一索引。</td></tr><tr><td><a href=\"https://docs.unity.cn/cn/2020.3/ScriptReference/Touch-maximumPossiblePressure.html\" title=\"maximumPossiblePressure\">maximumPossiblePressure</a></td><td>平台的最大可能压力值。如果 Input.touchPressureSupported 返回 false，此属性的值将始终为 1.0f。</td></tr><tr><td><a href=\"https://docs.unity.cn/cn/2020.3/ScriptReference/Touch-phase.html\" title=\"phase\">phase</a></td><td>描述触摸阶段。</td></tr><tr><td><a href=\"https://docs.unity.cn/cn/2020.3/ScriptReference/Touch-position.html\" title=\"position\">position</a></td><td>触摸在屏幕空间中的位置（像素坐标）。</td></tr><tr><td><a href=\"https://docs.unity.cn/cn/2020.3/ScriptReference/Touch-pressure.html\" title=\"pressure\">pressure</a></td><td>当前应用于触摸的压力大小。1.0f 被视为平均触摸压力。如果 Input.touchPressureSupported 返回 false，此属性的值将始终为 1.0f。</td></tr><tr><td><a href=\"https://docs.unity.cn/cn/2020.3/ScriptReference/Touch-radius.html\" title=\"radius\">radius</a></td><td>触摸半径的估计值。加上 radiusVariance 可获得最大触摸大小，减去它可获得最小触摸大小。</td></tr><tr><td><a href=\"https://docs.unity.cn/cn/2020.3/ScriptReference/Touch-radiusVariance.html\" title=\"radiusVariance\">radiusVariance</a></td><td>此值确定触摸半径的精度。半径加上此值可获得最大触摸大小，减去它可获得最小触摸大小。</td></tr><tr><td><a href=\"https://docs.unity.cn/cn/2020.3/ScriptReference/Touch-rawPosition.html\" title=\"rawPosition\">rawPosition</a></td><td>触摸触点在屏幕空间中的第一个位置（像素坐标）。</td></tr><tr><td><a href=\"https://docs.unity.cn/cn/2020.3/ScriptReference/Touch-tapCount.html\" title=\"tapCount\">tapCount</a></td><td>点击次数。</td></tr><tr><td><a href=\"https://docs.unity.cn/cn/2020.3/ScriptReference/Touch-type.html\" title=\"type\">type</a></td><td>用于指示触摸是 Direct、Indirect（或远程）还是 Stylus 类型的值。</td></tr></tbody></table>\n<p><strong>TouchPhase </strong></p>\n<p>该变量是一个枚举类型，其中包含可能的手指触摸状态。这些状态表示手指在最近的帧更新时可以采取的操作。因为设备在整个“生命周期”中对触摸进行跟踪，所以触摸的开始和结束以及之间的移动可以在发生触摸的帧上报告。</p>\n<table><tbody><tr><td><a href=\"https://docs.unity3d.com/cn/2020.3/ScriptReference/TouchPhase.Began.html\" title=\"Began\">Began</a></td><td>手指触摸了屏幕。</td></tr><tr><td><a href=\"https://docs.unity3d.com/cn/2020.3/ScriptReference/TouchPhase.Moved.html\" title=\"Moved\">Moved</a></td><td>手指在屏幕上进行了移动。</td></tr><tr><td><a href=\"https://docs.unity3d.com/cn/2020.3/ScriptReference/TouchPhase.Stationary.html\" title=\"Stationary\">Stationary</a></td><td>手指正在触摸屏幕但尚未移动。</td></tr><tr><td><a href=\"https://docs.unity3d.com/cn/2020.3/ScriptReference/TouchPhase.Ended.html\" title=\"Ended\">Ended</a></td><td>从屏幕上抬起了手指。这是最后一个触摸阶段。</td></tr><tr><td><a href=\"https://docs.unity3d.com/cn/2020.3/ScriptReference/TouchPhase.Canceled.html\" title=\"Canceled\">Canceled</a></td><td>系统取消了对触摸的跟踪。</td></tr></tbody></table>\n<p><strong>详细解释见官方文档</strong></p>\n<p><a href=\"https://docs.unity.cn/cn/2020.3/ScriptReference/Touch.html\" title=\"UnityEngine.Touch - Unity 脚本 API\">UnityEngine.Touch - Unity 脚本 API</a></p>\n<p></p>\n<h2>脚本代码</h2>\n<p>编写脚本，随后将脚本放置于模型上即可</p>\n<p>脚本一：放缩+360度旋转模型</p>\n<pre><code class=\"language-cs\">using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class suofang : MonoBehaviour\n{\n    private Touch oldTouch1;  //上次触摸点1(手指1)\n    private Touch oldTouch2;  //上次触摸点2(手指2)\n    void Update()\n    {\n        //没有触摸，就是触摸点为0\n        if (Input.touchCount &lt;= 0)\n        {\n            return;\n        }\n        //单点触摸， 水平上下旋转\n        if ( Input.touchCount ==1)\n        {\n            Touch touch = Input.GetTouch(0);\n            Vector2 deltaPos = touch.deltaPosition;\n            transform.Rotate(Vector3.down * deltaPos.x, Space.World);//绕Y轴进行旋转\n            transform.Rotate(Vector3.right * deltaPos.y, Space.World);//绕X轴进行旋转，下面我们还可以写绕Z轴进行旋转\n        }\n        //多点触摸, 放大缩小\n        Touch newTouch1 = Input.GetTouch(0);\n        Touch newTouch2 = Input.GetTouch(1);\n        //第2点刚开始接触屏幕, 只记录，不做处理\n        if (newTouch2.phase == TouchPhase.Began)\n        {\n            oldTouch2 = newTouch2;\n            oldTouch1 = newTouch1;\n            return;\n        }\n        //计算老的两点距离和新的两点间距离，变大要放大模型，变小要缩放模型\n        float oldDistance = Vector2.Distance(oldTouch1.position, oldTouch2.position);\n        float newDistance = Vector2.Distance(newTouch1.position, newTouch2.position);\n        //两个距离之差，为正表示放大手势， 为负表示缩小手势\n        float offset = newDistance - oldDistance;\n        //放大因子， 一个像素按 0.01倍来算(100可调整)\n        float scaleFactor = offset / 75f;\n        Vector3 localScale = transform.localScale;\n        Vector3 scale = new Vector3(localScale.x + scaleFactor,\n                                    localScale.y + scaleFactor,\n                                    localScale.z + scaleFactor);\n        //在什么情况下进行缩放\n        if (scale.x &gt;= 0.5f &amp;&amp; scale.y &lt;= 2f)\n        {\n            transform.localScale = scale;\n        }\n        //记住最新的触摸点，下次使用\n        oldTouch1 = newTouch1;\n        oldTouch2 = newTouch2;\n    }\n}\n</code></pre>\n<p>脚本二：单击、双击、滑动页面</p>\n<pre><code class=\"language-cs\">using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.UI;\n\npublic class chuping : MonoBehaviour\n{\n    public Text LeftRightTips;          //左右划屏\n    public Text UpDownTips;             //上下划屏\n    public Text DoubleClickTips;        //双击\n\n\n    private Vector2 DeltaArea;       //二维向量，滑屏区域\n\n    private bool BoolSecondClick;           //是否为第二次点击\n    private float FloFirstTime=0f;          //第一次点击时间\n    private float FloSecondTime=0f;         //第二次点击时间\n\n    // Use this for initialization\n    void Start () {\n        //初始化，测试数值\n        DeltaArea = Vector2.zero;\n\t}\n\t\n\t// Update is called once per frame\n\tvoid Update () {\n        /* 手指离开屏幕 */\n        //Input.touchCount是静态整形变量，当一只手指接触到屏幕时返回1，二只手指返回2，以此类推。\n        if (Input.touchCount == 1 &amp;&amp; (Input.GetTouch(0).phase == TouchPhase.Ended))\n        {    \n            DeltaArea = Vector2.zero;\n            //DoubleClickTips.text = \"\";          //如果手指离开屏幕，双击效果消失\n        }\n\n        /* 识别手指滑屏 */\n        if (Input.touchCount == 1 &amp;&amp; (Input.GetTouch(0).phase == TouchPhase.Moved))\n        {\n            DeltaArea.x += Input.GetTouch(0).deltaPosition.x;           //不断获取手指触屏时x,y轴的变化量并赋值给滑屏区域\n            DeltaArea.y += Input.GetTouch(0).deltaPosition.y;\n            if (DeltaArea.x &gt; 150)\n            {\n                LeftRightTips.text = \"右滑屏\";\n            }else if(DeltaArea.x &lt; -150)\n            {\n                LeftRightTips.text = \"左滑屏\";\n            }\n\n            if (DeltaArea.y &gt; 150)\n            {\n                UpDownTips.text = \"上滑屏\";\n\n            }else if (DeltaArea.y &lt;- 150)\n            {\n                UpDownTips.text = \"下滑屏\";\n            }\n        }\n        \n\n        /* 手指双击识别*/\n        if (Input.touchCount == 1 &amp;&amp; (Input.GetTouch(0).phase == TouchPhase.Began))\n        {\n            FloSecondTime = Time.time;\n            if (FloSecondTime - FloFirstTime &gt; 0.02F &amp;&amp; FloSecondTime - FloFirstTime &lt; 0.3F)            \n            {//当第二次点击与第一次点击的时间间隔在0.02秒至0.3秒之间时\n                DoubleClickTips.text = \"双击了屏幕！\";\n            }\n            else\n            {\n                DoubleClickTips.text = \"单击了屏幕！\";\n            }\n            FloFirstTime = Time.time;       //记录时间\n                                                                                                                                                                                                                                                                                                                                      \n        }\n\n    }\n\n}\n</code></pre>\n</div>\n</div>"}