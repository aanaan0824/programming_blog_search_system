{"blogid": "124637269", "writerAge": "码龄4年", "writerBlogNum": "49", "writerCollect": "615", "writerComment": "610", "writerFan": "1296", "writerGrade": "5级", "writerIntegral": "2739", "writerName": "子韵如初", "writerProfileAdress": "writer_image\\profile_124637269.jpg", "writerRankTotal": "23136", "writerRankWeekly": "28110", "writerThumb": "863", "writerVisitNum": "1058670", "blog_read_count": "789", "blog_time": "已于 2022-05-19 16:49:15 修改", "blog_title": "【附源码+Pybind + Cython Python性能提升方案】该拿什么拯救你，Slow Python", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p><br/><strong>目录</strong></p>\n<p id=\"Cython%E4%BB%8B%E7%BB%8D-toc\" style=\"margin-left:0px;\"><a href=\"#Cython%E4%BB%8B%E7%BB%8D\">Cython介绍</a></p>\n<p id=\"%E6%80%A7%E8%83%BD%E6%AF%94%E5%AF%B9-toc\" style=\"margin-left:0px;\"><a href=\"#%E6%80%A7%E8%83%BD%E6%AF%94%E5%AF%B9\">性能比对</a></p>\n<p id=\"%E7%BA%AFC%2B%2B-toc\" style=\"margin-left:40px;\"><a href=\"#%E7%BA%AFC%2B%2B\">纯C++</a></p>\n<p id=\"Pybind11-toc\" style=\"margin-left:40px;\"><a href=\"#Pybind11\">Pybind11</a></p>\n<p id=\"Python-toc\" style=\"margin-left:40px;\"><a href=\"#Python\">Python</a></p>\n<p id=\"Cython-toc\" style=\"margin-left:40px;\"><a href=\"#Cython\">Cython</a></p>\n<p id=\"%E6%80%BB%E7%BB%93-toc\" style=\"margin-left:0px;\"><a href=\"#%E6%80%BB%E7%BB%93\">总结</a></p>\n<p id=\"%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6\">循环机制</a></p>\n<p id=\"%E7%AE%97%E6%95%B0%E6%93%8D%E4%BD%9C-toc\" style=\"margin-left:40px;\"><a href=\"#%E7%AE%97%E6%95%B0%E6%93%8D%E4%BD%9C\">算数操作</a></p>\n<p id=\"%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D\">内存分配</a></p>\n<p id=\"%E6%9B%B4%E5%A4%9A%E6%83%85%E5%86%B5-toc\" style=\"margin-left:40px;\"><a href=\"#%E6%9B%B4%E5%A4%9A%E6%83%85%E5%86%B5\">更多情况</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<p></p>\n<p>在做深度学习部署以及加速过程中，性能计算是非常重要的，这也是Python的一大痛点，本文主要介绍各种Python加速的方法并且也抛砖引玉，阐述了Why python so slow。整体测试代码目录如下</p>\n<p><img alt=\"\" height=\"323\" src=\"image\\7d010e1c0c224ad19ae172abd9caaf39.png\" width=\"370\"/></p>\n<h1 id=\"Cython%E4%BB%8B%E7%BB%8D\">Cython介绍</h1>\n<p>简单来说Cython适合以下场景</p>\n<p style=\"margin-left:auto;text-align:left;\"><span style=\"color:#333333;\"><span style=\"background-color:#ffffff;\">1. 因为某些需求导致不得不编写一些多重嵌套的循环，而这些循环如果用 C 语言来实现会快几百倍，但是不熟悉 C 或者不知道 Python 如何与 C 进行交互</span></span></p>\n<p style=\"margin-left:auto;text-align:left;\"><span style=\"color:#333333;\"><span style=\"background-color:#ffffff;\">2. 项目组规定只能使用 Python 语言，解释器只能 CPython</span></span></p>\n<p style=\"margin-left:auto;text-align:left;\"><span style=\"color:#333333;\"><span style=\"background-color:#ffffff;\">3. Python 是一门动态语言，但希望至少在数字计算方面，能够加入可选的静态类型，这样可以极大的加速运算效果。因为单纯的数字相加不太需要所谓的动态性，尤其是当你的程序中出现了大量的计算逻辑时</span></span></p>\n<p style=\"margin-left:auto;text-align:left;\"><span style=\"color:#333333;\"><span style=\"background-color:#ffffff;\">4. 对于一些计算密集型的部分，写出一些超越 Numpy、Scipy、Pandas 的算法</span></span></p>\n<p style=\"margin-left:auto;text-align:left;\"><span style=\"color:#333333;\"><span style=\"background-color:#ffffff;\">5. 项目中有一些已经用 C、C++ 实现的库，需要直接在 Python 内部更好地调用它们，并且不使用 ctypes、cffi 等模块</span></span></p>\n<p style=\"margin-left:auto;text-align:left;\"><span style=\"color:#333333;\"><span style=\"background-color:#ffffff;\">6. 可以将 Python 代码中性能关键的部分使用 C 进行重写，来达到提升性能的效果。但是这需要对 Python 解释器有很深的了解，熟悉底层的 Python/C API，而这是一件非常痛苦的事情。</span></span></p>\n<p style=\"margin-left:auto;text-align:left;\">Cython将 Python 语言丰富的表达能力、动态机制和 C 语言的高性能汇聚在了一起，并且代码写起来仍然像写 Python 一样。</p>\n<p></p>\n<h1 id=\"%E6%80%A7%E8%83%BD%E6%AF%94%E5%AF%B9\">性能比对</h1>\n<h2 id=\"%E7%BA%AFC%2B%2B\">纯C++</h2>\n<pre><code class=\"language-cpp\">#include &lt;time.h&gt;\n\n#include &lt;iostream&gt;\n// g++ cfib.cpp -Ofast -o cfib &amp;&amp; ./cfib\ndouble cppfib(int n) {\n  int i;\n  double a = 0.0, b = 1.0, tmp;\n  for (i = 0; i &lt; n; ++i) {\n    tmp = a;\n    a = a + b;\n    b = tmp;\n  }\n  return a;\n}\nint main() {\n  clock_t st, ed;\n  st = clock();\n  double r = cppfib(10000000);\n  ed = clock();\n  std::cout &lt;&lt; (double)(ed - st) / CLOCKS_PER_SEC &lt;&lt; std::endl;\n  std::cout &lt;&lt; r &lt;&lt; std::endl;\n  return 1;\n}</code></pre>\n<p>编译</p>\n<pre><code>g++ cfib.cpp -o cfib &amp;&amp; ./cfib</code></pre>\n<p><strong>22.23ms</strong></p>\n<p>编译打开-Ofast优化参数</p>\n<pre><code>g++ cfib.cpp -Ofast -o cfib &amp;&amp; ./cfib</code></pre>\n<p><strong>15.217ms</strong></p>\n<p></p>\n<h2 id=\"Pybind11\">Pybind11</h2>\n<pre><code class=\"language-cpp\">#include &lt;pybind11/pybind11.h&gt;\n// c++ -shared -rdynamic -fPIC -undefined  -fvisibility=hidden -std=c++14\n// $(python3 -m pybind11 --includes)  pybindfib.cpp -o pybindfib$(python3-config\n// --extension-suffix)\nnamespace py = pybind11;\ndouble cppfib(int n) {\n  int i;\n  double a = 0.0, b = 1.0, tmp;\n  for (i = 0; i &lt; n; ++i) {\n    tmp = a;\n    a = a + b;\n    b = tmp;\n  }\n  return a;\n}\nPYBIND11_MODULE(pybindfib, m) { m.def(\"cppfib\", &amp;cppfib); }</code></pre>\n<p>编译，因为没有太多的循环体，打开-O编译运行加速效果不大</p>\n<pre><code class=\"language-bash\">c++ -shared -rdynamic -fPIC -undefined  -fvisibility=hidden -std=c++14</code></pre>\n<p>运行结果以及使用Ipython，Jupyter中的%time方法，非常实用</p>\n<p><img alt=\"\" height=\"222\" src=\"image\\f33f3e12888240d582779204ad004420.png\" width=\"499\"/></p>\n<h2 id=\"Python\">Python</h2>\n<p><img alt=\"\" height=\"294\" src=\"image\\40d2c107c0f24fe48dde031cc46a4471.png\" width=\"464\"/></p>\n<p></p>\n<h2 id=\"Cython\">Cython</h2>\n<p>no_setup_cython.pyx</p>\n<pre><code class=\"language-cpp\">def fib(int n):\n    cdef int i\n    cdef double a = 0.0, b = 1.0\n    for i in range(n):\n        a, b = a + b, a\n    return a</code></pre>\n<pre><code class=\"language-cpp\">cdef extern from \"cfib.h\":\n    double cfib(int n)</code></pre>\n<p>如上面代码可以看到<span style=\"background-color:#ffffff;\">和<span style=\"color:#333333;\">纯 Python 的斐波那契相比，Cython<strong>已经规定好了变量 i、a、b 的类型</strong>。因为 Python 中所有的变量都是一个 PyObject *，在底层中就是 C 的一个指针。PyObject（C 的一个结构体）内部有两个成员，分别是 <strong>ob_refcnt：保存对象的引用计数、ob_type *：保存对象类型的指针</strong>。不管是整型、字符串、元组、字典，所有指向它们的变量都是一个 PyObject*，当进行操作的时候，首先要通过 </span><code>-&gt; ob_type</code><span style=\"color:#333333;\"> 来获取对应的类型的指针，再进行转化。</span></span></p>\n<p style=\"margin-left:auto;text-align:left;\"><span style=\"background-color:#ffffff;\"><span style=\"color:#333333;\">这也是Python中经典的<strong>万物皆对象，都是分配在堆上的，且由于是动态语言</strong>因此</span></span><span style=\"color:#333333;\"><span style=\"background-color:#ffffff;\">Python 解释器每一次相加都要进行检测，判断到底是什么类型并进行转化，然后执行加法的时候，再去找内部的 __add__ 方法，将两个对象相加，创建一个新的对象，执行结束后再将这个新对象的指针转成 PyObject *，然后返回。并且 Python 中的对象都是在堆上分配空间，<strong>再加上 a 和 b 不可变，所以每一次循环都会创建新的对象，并将之前的对象给回收掉。想想都很费时。</strong></span></span></p>\n<p style=\"margin-left:auto;text-align:left;\"><span style=\"color:#333333;\"><span style=\"background-color:#ffffff;\">setup.py</span></span></p>\n<pre><code class=\"language-python\">from setuptools import setup\nfrom Cython.Build import cythonize\n\nsetup(\n    ext_modules = cythonize(\"cythonfib.pyx\")\n)\n# python setup.py build_ext --inplace</code></pre>\n<p>可以通过python setup.py build_ext --inplace 生成pyd二进制文件，也可以直接使用pyximport</p>\n<p><img alt=\"\" height=\"240\" src=\"image\\ca2bf23533c04dc199a84099a3db6371.png\" width=\"492\"/></p>\n<h1 id=\"%E6%80%BB%E7%BB%93\">总结</h1>\n<p></p>\n<p><img alt=\"\" height=\"512\" src=\"image\\856f0d93f5b44d5bbb229063a3ec3566.png\" width=\"932\"/></p>\n<p style=\"margin-left:auto;text-align:left;\"><span style=\"color:#000000;\"><span style=\"background-color:#ffffff;\">通过循环体耗时我们看到，Python 的 for 循环真的是非常之慢了，主要有以下几方面原因</span></span></p>\n<h2 id=\"%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6\" style=\"margin-left:auto;text-align:left;\"><span style=\"color:#0d0016;\"><span style=\"background-color:#ffffff;\">循环机制</span></span></h2>\n<p style=\"margin-left:auto;text-align:left;\"><span style=\"color:#000000;\"><span style=\"background-color:#ffffff;\">Python 在遍历一个可迭代对象的时候，会先调用这个可迭代对象内部的__iter__ 方法返回其对应的迭代器，然后再不断地调用这个迭代器的 __next__ 方法，将值一个一个的迭代出来，直到迭代器抛出 StopIteration 异常，for循环捕捉，终止循环。<strong>而迭代器是有状态的，Python 解释器需要时刻记录迭代器的迭代状态</strong></span></span></p>\n<h2 id=\"%E7%AE%97%E6%95%B0%E6%93%8D%E4%BD%9C\" style=\"margin-left:auto;text-align:left;\"><span style=\"color:#0d0016;\"><span style=\"background-color:#ffffff;\">算数操作</span></span></h2>\n<p style=\"margin-left:auto;text-align:left;\"><span style=\"color:#000000;\"><span style=\"background-color:#ffffff;\">Python 由于其动态特性，使得其无法做任何基于类型的优化。比如：循环体中的 a + b，这个 a、b 指向的可以是整数、浮点数、字符串、元组、列表，甚至是我们实现了魔法方法 __add__ 的类的实例对象。尽管人为是知道是浮点数，但是 Python 不会做这种假设，<strong>所以每一次执行 a + b 的时候，都会检测其类型到底是什么。</strong>然后判断内部是否有 __add__ 方法，以及两者能不能相加，然后条件满足的话再调用对应的 __add__ 方法，将 a 和 b 作为参数，将 a 和 b 指向的对象进行相加。计算出结果之后，再返回其指针转成 PyObject * 返回</span></span></p>\n<p style=\"margin-left:auto;text-align:left;\"><span style=\"color:#000000;\"><span style=\"background-color:#ffffff;\">而对于 C 和 Cython 来说，<strong>在创建变量的时候就实现规定了类型。就是这个类型，不是其它的，因此编译之后的 a + b 只是一条简单的机器指令</strong></span></span></p>\n<p style=\"margin-left:auto;text-align:left;\"></p>\n<h2 id=\"%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D\" style=\"margin-left:auto;text-align:left;\"><span style=\"color:#0d0016;\"><span style=\"background-color:#ffffff;\">内存<strong>分配</strong></span></span></h2>\n<p style=\"margin-left:auto;text-align:left;\"><span style=\"color:#000000;\"><span style=\"background-color:#ffffff;\">Python 中的对象是分配在堆上面的，因为 Python 中的<strong>对象本质上就是 C 中的 malloc 函数为结构体在堆区申请的一块内存。在堆区进行内存的分配和释放是需要付出很大的代价</strong>的，而栈则要小很多，并且它是由操作系统维护的，会自动回收，效率极高。尽管 Python 引入了内存池机制使得其在一定程度上避免了和操作系统的频繁交互，并且还引入了小整数对象池以及针对字符串的intern机制。但事实上，当涉及到对象（任意对象、包括标量）的创建和销毁时，都会增加动态分配内存、以及 Python 内存子系统的开销。而 float 对象又是不可变的，因此每循环一次都会创建和销毁一次，所以效率依旧是不高的</span></span></p>\n<p style=\"margin-left:auto;text-align:left;\"><span style=\"color:#000000;\"><span style=\"background-color:#ffffff;\">而 Cython 分配的变量，a 和 b，它们就不是指针了（ Python 中的变量本质上都是一个指针），而是<strong>分配在栈上的双精度浮点数。而栈上分配的效率远远高于堆</strong>，因此非常适合 for 循环，所以效率要比 Python 高很多</span></span></p>\n<h2 id=\"%E6%9B%B4%E5%A4%9A%E6%83%85%E5%86%B5\" style=\"margin-left:auto;text-align:left;\"><span style=\"color:#000000;\"><span style=\"background-color:#ffffff;\">更多情况</span></span></h2>\n<p style=\"margin-left:auto;text-align:left;\"><span style=\"color:#000000;\"><span style=\"background-color:#ffffff;\">上面分析中只是在代码中添加了几个 cdef 就能获得如此大的性能改进。但是，并非所有的 Python 代码在使用 Cython 时，都能获得巨大的性能改进。因为斐波那契数列的数据是绑定在 CPU 上的，运行时都花费在处理 CPU 寄存器的一些变量上，而不需要进行数据的移动</span></span></p>\n<p style=\"margin-left:auto;text-align:left;\"><span style=\"color:#000000;\"><span style=\"background-color:#ffffff;\">如果此函数是内存密集（例如，给两个大数组添加元素）、I/O 密集（例如，从磁盘读取大文件）或网络密集（例如，从 FTP 服务器下载文件），<strong>则 Python，C，Cython 之间的差异可能会显著减少（对于存储密集操作）或完全消失（对于 I/O 密集或网络密集操作）</strong></span></span></p>\n<p style=\"margin-left:auto;text-align:left;\"><span style=\"color:#0d0016;\"><span style=\"background-color:#ffffff;\">且Python 的整数不受长度的限制，但是 C 中 int 和 long 是受到限制的，因此不能正确地表示无限精度的整数。</span></span></p>\n<p></p>\n<p>编译Cython warning，这是因为定义了一个“cdef”函数。“cdef”函数是 C函数，它们在 Python 模块级别不可见，因此就会出现定义了但是没被使用的情况。如果需要定义<strong>Python 可调用函数，可以使用def或者cpdef</strong>。</p>\n<pre><code>_temp/test.c:1047:18: warning: ‘__pyx_f_4test_gen’ defined but not used [-Wunused-function]\n static PyObject *__pyx_f_4test_gen(int __pyx_v_x) {\nt3.c:556:12: warning: ‘__pyx_f_2t3_fun’ defined but not used [-Wunused-function]\n static int __pyx_f_2t3_fun(char *__pyx_v_s) {<!-- --></code></pre>\n<p></p>\n</div>\n</div>"}