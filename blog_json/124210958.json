{"blogid": "124210958", "writerAge": "码龄1年", "writerBlogNum": "11", "writerCollect": "53", "writerComment": "8", "writerFan": "4", "writerGrade": "2级", "writerIntegral": "146", "writerName": "Anastasia..", "writerProfileAdress": "writer_image\\profile_124210958.jpg", "writerRankTotal": "126213", "writerRankWeekly": "726837", "writerThumb": "16", "writerVisitNum": "14941", "blog_read_count": "4410", "blog_time": "于 2022-04-16 11:59:23 发布", "blog_title": "宏任务和微任务", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h1 id=\"%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95\"><a id=\"_0\"></a></h1>\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E4%B8%80%E3%80%81%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%80%E3%80%81%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1\">一、宏任务和微任务</a></p>\n<p id=\"%E5%85%88%E5%81%9A%E9%A2%98%EF%BC%9A-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%85%88%E5%81%9A%E9%A2%98%EF%BC%9A\">先做题：</a></p>\n<p id=\"%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%8C%85%E6%8B%AC%EF%BC%9A-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%8C%85%E6%8B%AC%EF%BC%9A\">宏任务：</a></p>\n<p id=\"%E5%BE%AE%E4%BB%BB%E5%8A%A1%EF%BC%9A-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%BE%AE%E4%BB%BB%E5%8A%A1%EF%BC%9A\">微任务：</a></p>\n<p id=\"%E5%BC%82%E6%AD%A5%E5%92%8C%E5%90%8C%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB%3A-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%BC%82%E6%AD%A5%E5%92%8C%E5%90%8C%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB%3A\">异步和同步的区别:</a></p>\n<p id=\"%E5%89%8D%E7%AB%AF%E4%BD%BF%E7%94%A8%E5%BC%82%E6%AD%A5%E7%9A%84%E5%9C%BA%E6%99%AF%EF%BC%9A-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%89%8D%E7%AB%AF%E4%BD%BF%E7%94%A8%E5%BC%82%E6%AD%A5%E7%9A%84%E5%9C%BA%E6%99%AF%EF%BC%9A\">前端使用异步的场景：</a></p>\n<p id=\"%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%EF%BC%9A-toc\" style=\"margin-left:80px;\"><a href=\"#%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%EF%BC%9A\">定时任务：</a></p>\n<p id=\"%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%EF%BC%9A-toc\" style=\"margin-left:80px;\"><a href=\"#%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%EF%BC%9A\">网络请求：</a></p>\n<p id=\"%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E5%92%8Cevent%20loop%EF%BC%88%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%EF%BC%89-toc\" style=\"margin-left:80px;\"><a href=\"#%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E5%92%8Cevent%20loop%EF%BC%88%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%EF%BC%89\">任务队列和event loop（事件循环）</a></p>\n<p id=\"%E8%80%83%E5%AF%9F%E7%9A%84%E6%98%AF%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E5%92%8C%E5%9B%9E%E8%B0%83%E9%98%9F%E5%88%97%E3%80%82%E6%B3%A8%E6%84%8F%E4%BB%A5%E4%B8%8B%E5%87%A0%E7%82%B9%EF%BC%9A-toc\" style=\"margin-left:40px;\"><a href=\"#%E8%80%83%E5%AF%9F%E7%9A%84%E6%98%AF%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E5%92%8C%E5%9B%9E%E8%B0%83%E9%98%9F%E5%88%97%E3%80%82%E6%B3%A8%E6%84%8F%E4%BB%A5%E4%B8%8B%E5%87%A0%E7%82%B9%EF%BC%9A\">考察的是事件循环和回调队列。注意以下几点：</a></p>\n<p id=\"%E8%A7%A3%E6%9E%90%EF%BC%9A-toc\" style=\"margin-left:80px;\"><a href=\"#%E8%A7%A3%E6%9E%90%EF%BC%9A\">解析：</a></p>\n<hr id=\"hr-toc\"/>\n<p>        JavaScript 语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。</p>\n<p>        为了协调事件、用户交互、脚本、UI 渲染和网络处理等行为，防止主线程的不阻塞，Event Loop 的方案应用而生。Event Loop 包含两类：一类是基于 Browsing Context，一种是基于 Worker。</p>\n<p>        二者的运行是独立的，也就是说，每一个 JavaScript 运行的\"线程环境\"都有一个独立的 Event Loop，每一个 Web Worker 也有一个独立的 Event Loop。</p>\n<h1 id=\"%E4%B8%80%E3%80%81%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1\"><a id=\"pandas_22\"></a>一、宏任务和微任务</h1>\n<h2 id=\"%E5%85%88%E5%81%9A%E9%A2%98%EF%BC%9A\"><strong>先做题：</strong></h2>\n<pre><code class=\"language-javascript\">setTimeout(function(){\n\t\t\tconsole.log('setTimeout') \n\t\t},0) \t\t\n\t\t//同步\n\t\tconsole.log('script start')\t\n\t\tasync function async1(){\n\t\t\t//同步\n\t\t\tconsole.log('async1 start');\n\t\t\tawait async2()\n\t\t\t//异步\n\t\t\tconsole.log('async1 end')\n\t\t}\t\n\t\tasync function async2(){\n\t\t\t//同步\n\t\t\tconsole.log('async2 end')\n\t\t}\t\n\t\t//微任务\n\t\tnew Promise(function(resolve){\n\t\t\t//同步\n\t\t\tconsole.log('promise')\n\t\t\tfor (var i = 0; i &lt;10000; i++) {\n\t\t\t\tif (i === 10) {\n\t\t\t\t\tconsole.log(\"3\")\n\t\t\t\t}\n\t\t\t\ti == 9999 &amp;&amp; resolve('4')\n\t\t\t}\n\t\t\tresolve();\n\t\t}).then(function(val){\n\t\t\tconsole.log(val)\n\t\t\t//异步\n\t\t\tconsole.log('promise1')\n\t\t}).then(function(res){\n\t\t\tconsole.log(res)\n\t\t\tconsole.log('promise2')\n\t\t})\t\n\t\t//微任务\n\t\tasync1(); \t\n\t\t//同步\n\t\tconsole.log('script end')</code></pre>\n<h2 id=\"%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%8C%85%E6%8B%AC%EF%BC%9A\">宏任务：</h2>\n<p>        setTimeout setInterval Ajax DOM事件  script(整体代码)   I/OUI交互事件   postMessageMessage  Channel setImmediate(Node.js 环境)</p>\n<h2 id=\"%E5%BE%AE%E4%BB%BB%E5%8A%A1%EF%BC%9A\">微任务：</h2>\n<p>        Promise async/await  Object.observe MutationObserver    process.nextTick(Node.js 环境)</p>\n<p><strong>微任务比宏任务的执行时间要早</strong></p>\n<p>        异步和单线程</p>\n<p>        异步和单线程是相辅相成的，js是一门单线程脚本语言，所以需要异步来辅助</p>\n<h2 id=\"%E5%BC%82%E6%AD%A5%E5%92%8C%E5%90%8C%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB%3A\">异步和同步的区别:</h2>\n<p>        异步不会阻塞程序的执行，</p>\n<p>        同步会阻塞程序的执行，</p>\n<h2 id=\"%E5%89%8D%E7%AB%AF%E4%BD%BF%E7%94%A8%E5%BC%82%E6%AD%A5%E7%9A%84%E5%9C%BA%E6%99%AF%EF%BC%9A\">前端使用异步的场景：</h2>\n<h3 id=\"%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%EF%BC%9A\">定时任务：</h3>\n<p>        setTimeout，setInverval</p>\n<h3 id=\"%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%EF%BC%9A\">网络请求：</h3>\n<p>        ajax请求，动态&lt;img&gt;加载</p>\n<p>        事件绑定</p>\n<h3 id=\"%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E5%92%8Cevent%20loop%EF%BC%88%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%EF%BC%89\">任务队列和event loop（事件循环）</h3>\n<p>        1）所有的同步任务都在主线程上执行，行成一个执行栈。</p>\n<p>        2）除了主线程之外，还存在一个任务列队，只要异步任务有了运行结果，就在任务列队中植入一个时间标记。</p>\n<p>        3）主线程完成所有任务(执行栈清空），就会读取任务列队，先执行微任务队列在执行宏任务队列。</p>\n<p>        4）重复上面三步。</p>\n<p>        只要主线程空了，就会读取任务列队，这就是js的运行机制，也被称为 event loop（事件循环）。</p>\n<h2 id=\"%E8%80%83%E5%AF%9F%E7%9A%84%E6%98%AF%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E5%92%8C%E5%9B%9E%E8%B0%83%E9%98%9F%E5%88%97%E3%80%82%E6%B3%A8%E6%84%8F%E4%BB%A5%E4%B8%8B%E5%87%A0%E7%82%B9%EF%BC%9A\">考察的是事件循环和回调队列。注意以下几点：</h2>\n<p>        Promise 优先于 setTimeout 宏任务，所以 setTimeout 回调会最后执行</p>\n<p>        Promise 一旦被定义就会立即执行</p>\n<p>        Promise 的 resolve 和 reject  是异步执行的回调。所以 resolve() 会被放到回调队列中，在主函数执行完和 setTimeout 之前调用</p>\n<p>        await 执行完后，会让出线程。async 标记的函数会返回一个 Promise 对象</p>\n<h3 id=\"%E8%A7%A3%E6%9E%90%EF%BC%9A\"><strong>解析：</strong></h3>\n<p>        首先，事件循环从宏任务（macrostack）队列开始，这个时候，宏任务队列中，只有一个 script (整体代码)任务。从宏任务队列中取出一个任务来执行。</p>\n<p>        首先执行 console.log('script start')，输出 ‘script start'</p>\n<p>        遇到 setTimeout 把 console.log('setTimeout') 放到 macrotask 队列中</p>\n<p>        执行 aync1() 输出 ‘async1 start' 和 'async2' ,把 console.log('async1 end') 放到 micro 队列中</p>\n<p>        执行到 promise ，输出 'promise1' ，把 console.log('promise2') 放到  micro 队列中</p>\n<p>        执行 console.log('script end')，输出 ‘script end'</p>\n<p>        macrotask 执行完成会执行 microtask ，把 microtask quene 里面的 microtask 全部拿出来一次性执行完，所以会输出 'async1 end' 和 ‘promise2'</p>\n<p>        开始新一轮的事件循环，去除执行一个 macrotask 执行，所以会输出 ‘setTimeout'</p>\n<p></p>\n<h1><a id=\"_55\"></a></h1>\n</div>\n</div>"}