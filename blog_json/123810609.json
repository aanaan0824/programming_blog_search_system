{"blogid": "123810609", "writerAge": "码龄17年", "writerBlogNum": "15", "writerCollect": "20", "writerComment": "2", "writerFan": "1", "writerGrade": "2级", "writerIntegral": "161", "writerName": "D365 代码家", "writerProfileAdress": "writer_image\\profile_123810609.jpg", "writerRankTotal": "100635", "writerRankWeekly": "203131", "writerThumb": "3", "writerVisitNum": "20347", "blog_read_count": "2090", "blog_time": "已于 2022-03-29 05:09:35 修改", "blog_title": "使用.net6.0创建asp.net core webapi项目", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p>1，NET6.0和NET5.0创建的asp.net core webapi项目的区别：<br/> NET5.0创建的webapi项目有一个Startup.cs文件。在NET6.0下面没有了。<br/> 说明微软在这块又做了优化。精减了启用文件。<img alt=\"在这里插入图片描述\" src=\"image\\5e2df82252454389bda6b6a746404d46.png\"/><br/> 2，项目默认生产一个天气预报控制器WeatherForecastController。<br/> 3，感觉微软命名不是很规范，或者说，有些内容微软自己也没有规划清楚。我这里明明是建立的asp.net core webapi 项目，而不是asp.net core MVC 项目，但是使用到的名称空间却是带mvc的（using crosoft.AspNetCore.Mvc;）。<br/> <img alt=\"在这里插入图片描述\" src=\"image\\8ff4b2ab1a1c4ede8dd63a06f3aca61a.png\"/><br/> 4，asp.net core webapi 控制器的类继承的是 ControllerBase， 跟MVC下面的控制器集成的父类是不一样的。<br/> 5，启动项目，运行如下，站点默认路径为：https://localhost:7182/swagger/index.html 这里是swagger首页。 这里需要强调的是asp.net core webapi 5.0和 6.0都是自带swagger功能的，以前在.net framework时代 swagger是要在项目下单独安装组件和配置后，才具有的一个功能。<br/> <img alt=\"在这里插入图片描述\" src=\"image\\9b12a9261e164ccb8ade8d409899d249.png\"/><br/> 6，添加一个自己的控制器。<br/> 代码如下：<br/> using Microsoft.AspNetCore.Mvc;<br/> namespace D365WebApi6._0.Controllers<br/> {<!-- --></p>\n<pre><code>[Route(\"api/[controller]/[action]\")]\n[ApiController]\npublic class MyTestController : ControllerBase\n{\n    [HttpGet]\n    public string GetSomething(string id)\n    {\n        return \"xxx\";\n    }\n}\n</code></pre>\n<p>}</p>\n<p>我这里的api请求地址路由是这么设置的，在控制器类，前面加一个如下的标签 [Route(“api/[controller]/[action]”)] ，其中“api”是随意取名的，[controller]这里会匹配控制器的名称，主要是匹配控制器类的名称。控制器类名取名为：MyTestController，那么这里匹配到的[controller] 等于MyTest。<br/> [action]则匹配的是方法名称，在这里匹配到[action]等于GetSomething。<br/> 那么，这里控制器路由标签匹配到的完整路径为：api/mytest/getSomething<br/> 控制器方法的访问路径为：https://localhost:7182/api/mytest/getSomething?id=100<br/> 这里的id为控制器方法的参数（这里写的是http get方法）。<br/> <img alt=\"在这里插入图片描述\" src=\"image\\2b43c4bca0ae4a17a552aaeda3f96f70.png\"/></p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\4e7bda7fe9f644bda99a5a4257d93d78.png\"/><br/> 控制器方法的访问路径为：https://localhost:7182/api/mytest/getSomething?id=100，这里的id为控制器方法的参数（这里写的是http get方法）。</p>\n<p>在浏览器中访问结果如下：<img alt=\"在这里插入图片描述\" src=\"image\\bfde61eeb9924e23a33c6e27ea12a0c6.png\"/><br/> 以上是非restful的方式访问，如果要用restful的方式访问怎么办呢？ 办法如下：<br/> 在控制器中，再添加2个http get 方法:<br/> <img alt=\"在这里插入图片描述\" src=\"image\\ecdcb6fb16fd415eaca8281e4afad440.png\"/><br/> 浏览器中访问截图如下：<br/> <img alt=\"在这里插入图片描述\" src=\"image\\88bce323204646dfb904154ca9b51e26.png\"/><br/> Swagger中的区别：<br/> <img alt=\"在这里插入图片描述\" src=\"image\\69f91afe1e63486abd5301a8a8d97bb0.png\"/></p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}