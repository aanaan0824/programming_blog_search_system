{"blogid": "126516909", "writerAge": "码龄2年", "writerBlogNum": "58", "writerCollect": "1403", "writerComment": "1849", "writerFan": "2917", "writerGrade": "6级", "writerIntegral": "4705", "writerName": "风铃听雨~", "writerProfileAdress": "writer_image\\profile_126516909.jpg", "writerRankTotal": "3568", "writerRankWeekly": "54", "writerThumb": "1637", "writerVisitNum": "137668", "blog_read_count": "887", "blog_time": "已于 2022-08-27 08:41:58 修改", "blog_title": "【直击面试】JVM这些面试题你都会了吗", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<blockquote>\n<ul><li>🧛‍♂️<strong>个人主页：</strong><a href=\"https://blog.csdn.net/muzi_longren?spm=1011.2415.3001.5343\">杯咖啡</a></li><li>💡进步是今天的活动，明天的保证！</li><li>✨目前正在学习：<a href=\"https://blog.csdn.net/muzi_longren/category_11902155.html?spm=1001.2014.3001.5482\">SSM框架</a>,<a href=\"https://blog.csdn.net/muzi_longren/category_11895216.html\">算法刷题</a></li><li>👉本文收录专栏 ： <a href=\"https://blog.csdn.net/muzi_longren/category_11981721.html?spm=1001.2014.3001.5482\">直击面试</a></li><li>🙌<strong>牛客网</strong>，刷算法过面试的神级网站，<strong>用牛客你也牛。</strong> 👉<a href=\"https://www.nowcoder.com/link/pc_csdncpt_flty_jzsf\">免费注册和我一起学习刷题</a>👈</li><li>🐳希望大家多多支持🥰一起进步呀！</li><li>😎The man who fears losing has already lost.<br/> 怕输的人已经输了。 - 《权力的游戏》</li></ul>\n</blockquote>\n<hr/>\n<blockquote>\n<p>查漏补缺JVM面试题<br/> 👀<code>小提示：有些干，谨慎食用！！！！</code></p>\n</blockquote>\n<h1><a id=\"1JVM_12\"></a>1.JVM运行时内存结构</h1>\n<h1><a id=\"2_13\"></a>2.对象和内存溢出</h1>\n<h1><a id=\"3GC_14\"></a>3.GC算法</h1>\n<hr/>\n<h1><a id=\"1JVM_16\"></a>1.JVM运行时内存结构</h1>\n<p>1.由如下图构成。Runtime Data Area有如下几个区，其中PC程序计数器、<br/> 虚拟机栈和本地方法栈是线程独享的，堆和方法区是线程共享的。Classload用来加载class文<br/> 件，执行引擎用来执行程序，本地方法接口调用本地方法库。<br/> <img alt=\"在这里插入图片描述\" src=\"image\\700db7409f774b2fa4b3e85e3fbf1a1f.png\"/></p>\n<p>2.java stack比较简单，每一个都是一个栈帧，每个栈帧由三部分构成。局部变量区、<br/> 操作数区和帧数据区。局部变量是一个以数组形式管理的内存区，一般第0位是指向<br/> 自己的this引用；其他的都是基本数据类型和reference类型和returnedAddress类型。<br/> 操作数区不是通过索引来访问，通过入栈出栈来访问，是临时数据的存储区域，比方<br/> 说数学计算。帧数据区是保存一些指向常量池的指针，需要常量数据时就通过这个指<br/> 针来访问常量池数据。<br/> <img alt=\"在这里插入图片描述\" src=\"image\\72dcd80ebef24146b34b600d1eb93eb4.png\"/></p>\n<p>3.共享内存区：分为permanent space、old space、From,survivor、To survivor和<br/> Eden。其中premanent包括runtime constant pool和已加载的类信息和方法信息。<br/> Old space(tenured generation)包含生命周期长的存活对象。From survivor和Eden<br/> 存放存活比较短的对像，To survivor是用来复制保存存活的对象。<br/> <img alt=\"在这里插入图片描述\" src=\"image\\586cdf935980469d9ad30e67e2a6484d.png\"/></p>\n<p>4.JVM参数设置。<br/> -Xmx:最大堆内存，如：-Xmx512m<br/> -Xms:初始时堆内存，如：-Xms256m<br/> -XX:MaxNewSize:最大年轻区内存<br/> X:NewSize:初始时年轻区内存.通常为mx的1/3或1/4。新生代=Eden+2<br/> 个Survivor空间。实际可用空间为=Eden+1个Survivor,即90%<br/> -XX:MaxPermSize:最大特久带内存<br/> -XX:PermSize:初始时特久带内存<br/> XX:+PrintGCDetails。打印GC信息<br/> -X:NewRatio新生代与老年代的比例，如-X:NewRatio=2,则新生代占整个堆<br/> 空间的1/3，老年代占2/3<br/> -XX:SurvivorRatio新生代中Eden与Survivor的比值。默认值为8。即Eden占新生<br/> 代空间的8/10，另外两个Survivor各占1/10<br/> 栈：<br/> ×SS:设置每个线程的堆栈大小.JDK1.5+每个线程堆栈大小为1M,般来说如果<br/> 栈不是很深的话，1M是绝对够用了的。Lst集合存储元素特点？</p>\n<h1><a id=\"2_53\"></a>2.对象和内存溢出</h1>\n<h2><a id=\"1_54\"></a>1.对象</h2>\n<blockquote>\n<p>A.创建。首先检查指令的参数能不能在常量区找到类的符号引用，并检查这个类<br/> 是否加载、解析和初始化过，如果没有就执行类的加载过程。其次是内存分配<br/> 类加载之后就知道要分配的内存大小，分配方法有两种，一种是指针碰撞，就<br/> 是一块内存是使用过的，一块是未使用的，用一个指针分割，新分配的内存指<br/> 针就向空闲的挪动，compact功能的虚拟机是用指针碰撞；另一种是空闲列表<br/> 就是一个列表记录空闲的内存块，不断更新列表，新分配的内存在列表中寻找<br/> 一个合适大小的内存块，sweep功能的虚拟机是使用空闲列表。第三，在分配<br/> 内存空间的时候，还要考虑并发性。有两个方法，一种是同步处理，如采用<br/> C八S和失败重试的方法：另外一种是把内存分配动作按照线程划分在不同的空<br/> 间之中，每个线程在堆中预先分配一小块内存，本地线程分配缓冲TLAB,那<br/> 个线程需要分配内存在那个TLAB上分配，只有TLAB用完了，才要同步锁定<br/> 重新分配。第四、对对象进行必要设置，比方说对象属于那个类，如何找到类<br/> 的元数据信息和对象hashcode以及对象GC分代年龄等。</p>\n</blockquote>\n<blockquote>\n<p>B·对象的内存布局。分为对象头、实例数据和对齐填充。对象头包括两部分，第<br/> 部分是存储对象自身信息，如hashcode,GC分代年龄，锁状态等；第二部<br/> 分是类型指针，对象指向它的类的元数据的指针，虚拟机通过这个指针确定这<br/> 是那个类的实例。</p>\n</blockquote>\n<blockquote>\n<p>C.对象访问定位。两种方式，一种是句柄访问，句柄池有访问对象实例数据的指<br/> 针和访问对象数据类型的指针。这个访问最大好处是reference是稳定的句柄<br/> 池地址，对象改变都是改变句柄池里面的指针，而reference本身不动。另外<br/> 一种就是直接指针，它有到对象类型数据的指针和实例数据。这个访问的好处<br/> 是速度更快，节省了一次指针定位的开销。</p>\n</blockquote>\n<h2><a id=\"2__OOM_80\"></a>2. 内存溢出 OOM。</h2>\n<blockquote>\n<p>A.准益出。堆存放的是对象实例，只要不断创建对象，并且保证GC Root到对象<br/> 有可大路径避免被垃圾回收清除掉对象，那么对象数量达到最大堆容量限制就<br/> 会OOM。用内存映象分析工具，Eclipse Memory Analyzer分析一下。</p>\n</blockquote>\n<blockquote>\n<p>B.虚拟机栈和本地方法栈益出。分为两种，一种是如果线程清求的栈深度大于虚<br/> 拟机所允许的最大深度，抛出StackOverFlowError异常；另一种是如果虚拟机<br/> 在扩展栈时无法申请到足够内存空间，抛出OutOfMemoryError异常。可以减<br/> 小最大堆和栈容量来获取更多的线程数量。</p>\n</blockquote>\n<blockquote>\n<p>C.方法区和常量池溢出。会有额外提示PermGen space。.</p>\n</blockquote>\n<blockquote>\n<p>D.本机直接内存益出。这个Heap Dump文件看不到内存占用，但是如果有直接<br/> 或简介使用了NO,那有可能就是本机直接内存溢出了。</p>\n</blockquote>\n<h1><a id=\"3_GC__94\"></a>3. GC 算法</h1>\n<h2><a id=\"1__95\"></a>1. 判断对象可以回收。</h2>\n<blockquote>\n<p>A.引用计数器方法。对象被引用就加一，失效的时候减一；为0时就可以释放。<br/> 缺点是，GC有环的时候不能释放。</p>\n</blockquote>\n<blockquote>\n<p>B.GC Root。以根对象为起点，然后根据关联关系向下搜索。如果根对象找不到<br/> 任何路径与之相连，就判断为对象可以被回收。GC Root的选取有四种：虚拟<br/> 机栈中引用对象，方法区中类的静态属性引用对象，方法区中常量引用对象和<br/> 本地方法栈中i引用对象。可达性分析算法标记了的对象，默认是第一次标<br/> 泊，如果这个对像没有实现finalize方法的话，就直接回收了；如果实现了<br/> finalize方法的话，就要把第一次标记的对象放到一个F-Queue队列里面，然<br/> 后虚拟机会启动一个Finalizer线程去执行，然后会进行第二次标记。第二次标<br/> 记的对象就直接回收。要想存活一次的话，就重写finalize方法，如果想复活<br/> 的话，就在finalize里，把自己关联到任何一个上就行，如，把自己赋值给某<br/> 个类变量或者对象的成员变量。</p>\n</blockquote>\n<blockquote>\n<p>C.强引用对象任何时候都不会被回收；软引用在内存够的时候不会被回收，在不<br/> 够时候会，SoftReference类；弱引用在虚拟机回收时直接回收，WeakReference。<br/> 虚引用不会构成任何对对象的影响，创建目的是为了对象被回收时系统得到一个通知<br/> 消息，PhantomReference。</p>\n</blockquote>\n<h2><a id=\"2__114\"></a>2. 垃圾回收算法。</h2>\n<blockquote>\n<p>A.标记-清除(mark-sweep)。缺点是内存碎片多。</p>\n</blockquote>\n<blockquote>\n<p>B.标记-复制(mark-copy)。将内存分为两块，一块内存保留对象的全部复制到另一<br/> 块空闲内存中。缺点是内存减半。所以分区来实现，eden,s0,s1,按一定比例，<br/> 默认8：1：1即可。这个就是Minor GC,一般情况下，对象在Eden上申请空间，<br/> 当发现没有足够空间，就发生Minor GC,会把Eden和From survivor里的保留的<br/> 对象复制到To survivor里面，然后清空Eden和From survivor内存，然后rom<br/> survivor和To survivor对换。如果To survivor空间不够，直接把From survivor<br/> 对象复制到old space,或者部分年龄足够了的对象也会直接复制到old space。<br/> From survivor把对像复制到Tenured区域时，如果设置了<br/> HandlePromotionFailure(允许担保失败)，如果允许就只进行Minor GC,如果不<br/> 允许就触发ulGC。</p>\n</blockquote>\n<blockquote>\n<p>C.标记整理(mark-compact)。整理时，先清除掉应该清除的对象，然后把存活的<br/> 对象压缩到堆的一端，按顺序排放。FuGC需要对整个堆进行回收。比方说<br/> Tenured满了，permanent满了人system.gc显示调用，会发生Full GC。<br/> Permanent要回收，一般回收的是常量池的常量和无用的类信息。类所有实例都回<br/> 收了，加载类的classloader已经被回收了和类的class对象没有被引用（没有通过<br/> 反射引用该类)这三条满足了才会回收类。</p>\n</blockquote>\n<hr/>\n<h1><a id=\"_136\"></a>小提示</h1>\n<blockquote>\n<p>今日内容有些干，请谨慎食用！！！！</p>\n</blockquote>\n<blockquote>\n<p><span class=\"katex--inline\"><span class=\"katex\"><span class=\"katex-mathml\">\n     \n      \n       \n        \n         \n          原创不易，还希望各位大佬支持一下\n         \n        \n       \n       \n        \\textcolor{blue}{原创不易，还希望各位大佬支持一下}\n       \n      \n     </span><span class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord cjk_fallback\" style=\"color: blue;\">原创不易，还希望各位大佬支持一下</span></span></span></span></span> <br/><br/> <span class=\"katex--inline\"><span class=\"katex\"><span class=\"katex-mathml\">\n     \n      \n       \n        \n         \n          点赞，你的认可是我创作的动力！\n         \n        \n       \n       \n        \\textcolor{green}{点赞，你的认可是我创作的动力！}\n       \n      \n     </span><span class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord cjk_fallback\" style=\"color: green;\">点赞，你的认可是我创作的动力！</span></span></span></span></span> <br/><br/> <span class=\"katex--inline\"><span class=\"katex\"><span class=\"katex-mathml\">\n     \n      \n       \n        \n         \n          收藏，你的青睐是我努力的方向！\n         \n        \n       \n       \n        \\textcolor{green}{收藏，你的青睐是我努力的方向！}\n       \n      \n     </span><span class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord cjk_fallback\" style=\"color: green;\">收藏，你的青睐是我努力的方向！</span></span></span></span></span> <br/><br/> <span class=\"katex--inline\"><span class=\"katex\"><span class=\"katex-mathml\">\n     \n      \n       \n        \n         \n          评论，你的意见是我进步的财富！\n         \n        \n       \n       \n        \\textcolor{green}{评论，你的意见是我进步的财富！}\n       \n      \n     </span><span class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord cjk_fallback\" style=\"color: green;\">评论，你的意见是我进步的财富！</span></span></span></span></span> <br/></p>\n</blockquote>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}