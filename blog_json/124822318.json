{"blogid": "124822318", "writerAge": "码龄2年", "writerBlogNum": "78", "writerCollect": "747", "writerComment": "958", "writerFan": "5985", "writerGrade": "5级", "writerIntegral": "3124", "writerName": "远走与梦游", "writerProfileAdress": "writer_image\\profile_124822318.jpg", "writerRankTotal": "8933", "writerRankWeekly": "1898", "writerThumb": "1055", "writerVisitNum": "105505", "blog_read_count": "2061", "blog_time": "已于 2022-05-21 19:09:57 修改", "blog_title": "理解vue-admin-template模板，连接后端改造登陆功能", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>首先修改统一请求路径为我们自己的登陆接口，在.env.development文件中</p>\n<pre><code># base api\nVUE_APP_BASE_API = 'http://localhost:8081/api/dsxs/company'</code></pre>\n<p>打开登陆页面，src/views/login/index.vue</p>\n<pre><code>&lt;template&gt;\n  &lt;div class=\"login-container\"&gt;\n    &lt;el-form ref=\"loginForm\" :model=\"loginForm\" :rules=\"loginRules\" class=\"login-form\" auto-complete=\"on\" label-position=\"left\"&gt;\n\n      &lt;div class=\"title-container\"&gt;\n        &lt;h3 class=\"title\"&gt;Login Form&lt;/h3&gt;\n      &lt;/div&gt;\n\n      &lt;el-form-item prop=\"username\"&gt;\n        &lt;span class=\"svg-container\"&gt;\n          &lt;svg-icon icon-class=\"user\" /&gt;\n        &lt;/span&gt;\n        &lt;el-input\n          ref=\"username\"\n          v-model=\"loginForm.username\"\n          placeholder=\"Username\"\n          name=\"username\"\n          type=\"text\"\n          tabindex=\"1\"\n          auto-complete=\"on\"\n        /&gt;\n      &lt;/el-form-item&gt;\n\n      &lt;el-form-item prop=\"password\"&gt;\n        &lt;span class=\"svg-container\"&gt;\n          &lt;svg-icon icon-class=\"password\" /&gt;\n        &lt;/span&gt;\n        &lt;el-input\n          :key=\"passwordType\"\n          ref=\"password\"\n          v-model=\"loginForm.password\"\n          :type=\"passwordType\"\n          placeholder=\"Password\"\n          name=\"password\"\n          tabindex=\"2\"\n          auto-complete=\"on\"\n          @keyup.enter.native=\"handleLogin\"\n        /&gt;\n        &lt;span class=\"show-pwd\" @click=\"showPwd\"&gt;\n          &lt;svg-icon :icon-class=\"passwordType === 'password' ? 'eye' : 'eye-open'\" /&gt;\n        &lt;/span&gt;\n      &lt;/el-form-item&gt;\n\n      &lt;el-button :loading=\"loading\" type=\"primary\" style=\"width:100%;margin-bottom:30px;\" @click.native.prevent=\"handleLogin\"&gt;Login&lt;/el-button&gt;\n\n      &lt;div class=\"tips\"&gt;\n        &lt;span style=\"margin-right:20px;\"&gt;username: admin&lt;/span&gt;\n        &lt;span&gt; password: any&lt;/span&gt;\n      &lt;/div&gt;\n\n    &lt;/el-form&gt;\n  &lt;/div&gt;\n&lt;/template&gt;</code></pre>\n<p>可以看到页面使用组件对loginForm进行名称和密码的绑定</p>\n<pre><code> data() {\n    const validateUsername = (rule, value, callback) =&gt; {\n      if (!validUsername(value)) {\n        callback(new Error('Please enter the correct user name'))\n      } else {\n        callback()\n      }\n    }\n    const validatePassword = (rule, value, callback) =&gt; {\n      if (value.length &lt; 6) {\n        callback(new Error('The password can not be less than 6 digits'))\n      } else {\n        callback()\n      }\n    }</code></pre>\n<p>这段代码则为对输入的内容进行验证</p>\n<p>看登陆的方法</p>\n<pre><code>   handleLogin() {\n      \n      this.$refs.loginForm.validate(valid =&gt; {\n        if (valid) {\n          this.loading = true\n          this.$store.dispatch('user/login', this.loginForm).then(() =&gt; {\n            this.$router.push({ path: this.redirect || '/' })\n            this.loading = false\n          }).catch(() =&gt; {\n            this.loading = false\n          })\n        } else {\n\n          return false\n        }\n      })\n    }</code></pre>\n<p>其中 this.$store.dispatch('user/login', this.loginForm)，不是请求后台user/login接口，而是转到modules下的user.js中的login方法，打开store/modules/user.js可以看到login方法。而login方法则是调用api/user.js中的login方法。</p>\n<p>此时修改store/modules/user.js接收后台传来的响应数据</p>\n<pre><code>const actions = {\n  // user login\n  login({ commit }, userInfo) {\n    const { username, password } = userInfo\n    return new Promise((resolve, reject) =&gt; {\n      login({ username: username.trim(), password: password }).then(response =&gt; {\n        console.log(response)\n        const { data } = response\n        commit('SET_TOKEN', response.data.token)\n        setToken(response.data.token)\n        resolve()\n      }).catch(error =&gt; {\n        reject(error)\n      })\n    })\n  },</code></pre>\n<p>同时在api/user.js中修改为我们后台的请求地址</p>\n<p></p>\n<pre><code>import request from '@/utils/request'\n\nexport function login(data) {\n  return request({\n    url: 'userlogin',\n    method: 'post',\n    data\n  })\n}\n\nexport function getInfo(token) {\n  return request({\n    url: 'userinfo',\n    method: 'get',\n    params: { token }\n  })\n}</code></pre>\n<p>此时可以发现模板采用的登陆方式是请求两次，第一次通过用户名密码请求后端，后端判断后，返回对应的token。然后在通过getInfo方法请求后端，获取用户真实信息。</p>\n<p>在编写后端之前还需要修改utils/request.js，因为默认状态码是20000为成功，而我们平时返回的是200</p>\n<pre><code>   // if the custom code is not 20000, it is judged as an error.\n    if (res.code !== 200) {\n      Message({\n        message: res.message || 'Error',\n        type: 'error',\n        duration: 5 * 1000\n      })</code></pre>\n<p>简单的编写后端代码，登陆方法根据账号密码查出用户信息，根据用户id与name生成token并返回，userinfo则是对token进行获取，在查出对应值进行返回。</p>\n<pre><code>@CrossOrigin\n@RestController\n@RequestMapping(\"/api/dsxs/company\")\npublic class CompanyuserController {\n    @Autowired\n    private CompanyuserService companyuserService;\n    //后台登陆\n    @PostMapping(\"userlogin\")\n    @ResponseBody\n    public R userlogin(@RequestBody UserVo userVo){\n        Companyuser companyuser = companyuserService.login(userVo);\n        String token = JwtHelper.createToken(companyuser.getId(), companyuser.getName());\n        return R.ok().data(\"token\",token);\n    }\n    //返回信息\n    @GetMapping(\"userinfo\")\n    public R userinfo( String token){\n        Integer userId = JwtHelper.getUserId(token);\n        System.out.println(\"====\");\n        Companyuser user = companyuserService.getById(userId);\n        HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();\n        map.put(\"name\",user.getName());\n        map.put(\"avatar\",user.getAvatar());\n        return R.ok().data(\"name\",user.getName()).data(\"avatar\",user.getAvatar());\n    }\n}</code></pre>\n<p>我这里使用@CrossOrigin注解解决的跨域问题。</p>\n<p></p>\n<p></p>\n<p></p>\n</div>\n</div>"}