{"blogid": "115211590", "writerAge": "码龄4年", "writerBlogNum": "42", "writerCollect": "133", "writerComment": "42", "writerFan": "9", "writerGrade": "3级", "writerIntegral": "708", "writerName": "遥乐", "writerProfileAdress": "writer_image\\profile_115211590.jpg", "writerRankTotal": "35351", "writerRankWeekly": "103548", "writerThumb": "69", "writerVisitNum": "59719", "blog_read_count": "5304", "blog_time": "于 2021-11-12 15:19:40 发布", "blog_title": "Unity学习：资源存储加载之——文件夹、路径格式及其方法等", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h2>1、Assets文件夹</h2>\n<h3>Assets文件夹是unity项目中放置游戏资源的主文件夹，根目录文件夹。</h3>\n<p><strong>（1）路径格式：assetsPath  = \"Assets/xx/xx.xxx\"；</strong></p>\n<p><strong>（2）编辑器下使用的加载方法：Resources.LoadAssetAtPath(assetsPath) ；</strong></p>\n<p>Asset文件夹下任意位置任意资源，打包后不存在Asset文件，<span style=\"color:#fe2c24;\">仅在编辑器环境下运行使用</span>。</p>\n<p>它可以加载Assets目录下的任意文件夹下的资源，必须是”Assets/xx/xx.xxx”这种路径，并且要带文件的后缀名。</p>\n<p><strong>（3）编辑器和打包后都可使用的加载方法：AssetDatabase.LoadAssetAtPath(filePath)；</strong></p>\n<p>AssetDatabase是一个API，它允许您访问您项目中的资源。它提供了查找资源、加载资源、创建资源、删除资源和修改资源的方法。</p>\n<p>它可以读取Assets目录下的任意文件夹下的资源，必须是”Assets/xx/xx.xxx” 这种路径，并且要带文件的后缀名。</p>\n<p>仅返回在 Project 视图中可见的资源对象。如果未找到资源，返回Null；</p>\n<pre><code class=\"language-cs\">public string filePath;//存档路径\n\nprivate void Awake()\n    {\n        filePath  = \"Assets/TempTestFile/XXX.mat\";\n    }\n\nprivate void testLoad()\n    {\n        //加载指定资源\n        Resources.LoadAssetAtPath(filePath);\n        AssetDatabase.loadasset(filePath);\n\n        //加载指定类型的资源\n        Material mat = AssetDatabase.LoadAssetAtPath(\"Assets/Materials\", typeof(Material)) as Material;\n        Material mat = AssetDatabase.LoadAssetAtPath&lt;Material&gt;(\"Assets/Materials/XXX.mat\");\n    }</code></pre>\n<h2>2、特殊文件夹：Resources文件夹：</h2>\n<h3><strong>Resources是用来存放资源的<span style=\"color:#f33b45;\">特殊文件夹</span>。编辑器环境下unity可以方便快速加载Resources文件夹里的资源。</strong></h3>\n<p>但在打包过程中，会将Assets目录及其所有子目录下的名字为Resources的文件夹合并，并加密压缩。所以打包后只能读取不能写入。</p>\n<p>并且在程序启动时会对Resources下的所有对象初始化，构建实例ID。这个过程耗时非线性增加，可能导致程序启动时间过长。</p>\n<p><strong>（1）路径格式：assetsPath  = \"XXX.png\";</strong></p>\n<p>XXX.png资源已经在Resources文件夹中了。</p>\n<p><strong>（2）加载方法：Resources.Load(assetsPath)；</strong></p>\n<p><span style=\"color:#fe2c24;\">编辑时和运行时都可以使用</span>，直接读取Resources文件夹下的指定资源，</p>\n<p>即以Resources文件夹为根目录开始的相对路径，且不包含资源的扩展名。</p>\n<pre><code class=\"language-cs\">public string assetsPath;//存档路径\n\nprivate void Awake()\n    {\n        assetsPath= \"XXX.png\";//资源文件直接放到Resources文件夹里\n    }\nprivate void Load()\n    {\n        //1、加载某个资源，文件不用加后缀，直接文件名称即可\n        Resources.Load(assetsPath);\n        Resources.Load(\"资源名\");\n\n        //2、加载指定文件夹下的所有资源\n        Resources.LoadAll(\"文件夹名\");//同步加载\n        Resources.LoadAllAsync(文件夹名);//异步加载\n\n        //3、加载指定类型的某个资源\n        Resources.Load&lt;GameObject&gt;(\"Prefabs/Cube\");\n        TextAsset itemText = Resources.Load&lt;TextAsset&gt;(\"Config/Item\");\n        string itemsJson = itemText.text;//获取文本文件里的内容\n        //注：txt/json等文本在Unity里面是TextAsset类型,这里加载放到Resources文件夹下Config文件夹里的命名为Item的Json文件\n        \n        \n       //4、卸载非GameObject类型的资源，将其他已加载资源及其克隆体卸载\n       Resources.UnloadAsset(obj);\n\n       //4、卸载所有没有用到的资源\n       Resources.UnloadUnusedAssets(); \n    }</code></pre>\n<h2>3、特殊文件夹：streamingAssets文件夹</h2>\n<p><strong>（1）说明：StreamingAssets流文件夹，一般是存放预存的信息、初始的AssetsBundle资源，<span style=\"color:#f33b45;\">不要去改动</span> ；</strong></p>\n<p>StreamingAssets文件夹目录下的所有资源都会打入发布包中，但资源都是不压缩的，所以它会比较大、占空间，且打包后运行时只能读不能写，</p>\n<p><strong>（2）加载方法：Application.streamingAssetsPath（path）;</strong></p>\n<p>不同平台下该文件的路径也不同，可以用Application.streamingAssetsPath加载，会根据当前的平台，自动加载正确的streamingAsset文件；</p>\n<pre><code class=\"language-cs\">public string filePath;//存档路径\n\nprivate void Awake()\n    {\n        filePath = Application.streamingAssets +\"/jsonDatas.json\";\n    }\n\n\n//直接加载资源\nprivate void TestLoad()\n    {\n        Application.streamingAssetsPath（filePath）;\n    }\n\n\n//数据流形式读取指定路径的文件数据\nprivate void LoadFile()\n    {\n        if (!File.Exists(FilePath))\n        {\n            Debug.Log(\"找不到存档文件\");\n        }\n        else\n        {\n            //根据文件路径创建数据流\n            StreamReader sr = new StreamReader(FilePath);\n            //读取Json数据\n            string ReadStr = sr.ReadToEnd();\n            //关闭数据流\n            sr.Close();\n            //将获取到的Json数据转为Datas类数据，这里使用LitJson库解析，也可使用其他Json库\n            Ddatas tempDatas= JsonMapper.ToObject&lt;Datas&gt;(ReadStr);\n            //把读取的数据赋值给目标数据\n            datas= tempDatas;\n\n            Debug.Log(\"本地存档读取赋值成功\");\n        }\n    }</code></pre>\n<h2>4、AssetBundle资源</h2>\n<p><strong>（1）磁盘上的实际文件，<span style=\"color:#f33b45;\">AssetBundle存档文件</span>，包含可在运行时由 Unity 加载的特定于平台的非代码资源。</strong></p>\n<p><strong>（2）AssetBundle”也可以指代通过代码进行交互以便从特定 AssetBundle 存档加载资源的实际 AssetBundle 对象。</strong></p>\n<h2>5、Application.dataPath路径：</h2>\n<p><strong>用于返回<span style=\"color:#f33b45;\">工程文件所在位置的数据文件夹</span>的路径</strong></p>\n<pre><code class=\"language-cs\">public string filePath;//存档路径\n\nprivate void Awake()\n    {\n        filePath = Application.dataPath + \"/StreamingFile/jsonDatas.txt\"；\n        filePath = Application.dataPath + \"/StreamingAssets/jsonDatas.json\";\n    }\n\n//数据流形式读取文件数据\nprivate void testLoad()\n    {\n        if (!File.Exists(FilePath)) Debug.Log(\"找不到存档文件\");\n        else\n        {\n            StreamReader sr = new StreamReader(FilePath);\n            string ReadStr = sr.ReadToEnd();\n            sr.Close();\n            Ddatas tempDatas= JsonMapper.ToObject&lt;Datas&gt;(ReadStr);\n            datas= tempDatas;\n        }\n    }</code></pre>\n<h2>6、Application.streamingAssetsPath路径：</h2>\n<p>用于返回<span style=\"color:#f33b45;\">流数据的缓存目录</span>，返回路径为相对路径，适合设置一些外部数据文件的路径。</p>\n<pre><code class=\"language-cs\">public string filePath;//存档路径\n\nprivate void Awake()\n    {\n        filePath = Application.streamingAssets +\"jsonDatas.txt\"；\n        filePath = Application.dataPath + \"/StreamingAssets/jsonDatas.json\";\n    }\nprivate void testLoad()\n    {\n        Application.streamingAssetsPath（filePath）;\n    }</code></pre>\n<h2>7、Application.persistenDataPath路径：</h2>\n<p><strong>用于返回一个持久化数据存储目录的路径，可以在此路径下<span style=\"color:#f33b45;\">存储一些持久化的数据文件</span>。</strong></p>\n<p>该值是目录路径；此目录中可以存储每次运行要保留的数据。在 iOS 和 Android 上发布时，persistentDataPath 指向设备上的公共目录。应用程序更新不会擦除此位置中的文件。用户仍然可以直接擦除这些文件。</p>\n<p>内容可读写，不过只能运行时才能写入或者读取</p>\n<p><span style=\"color:#f33b45;\">是一个外部存储路径，和项目安装位置无关的绝对路径，多是保存用户信息数据的位置，升级版本不会影响到这些数据；</span></p>\n<p><strong>考虑<span style=\"color:#f33b45;\">多平台</span>的话，尽量存到Application.persistenDataPath；</strong></p>\n<pre><code class=\"language-cs\">public string filePath;//存档路径\n\nprivate void Temp()\n    {\n        filePath = Application.persistentDataPath + \"/jsonDatas.json\";\n    }</code></pre>\n<h2>8、Application.temporaryCachePath路径：</h2>\n<p>用于返回一个<span style=\"color:#f33b45;\">临时数据的缓存目录</span>。</p>\n<p><span style=\"color:#f33b45;\">是用来放缓存和临时的，用户可以清理掉；</span></p>\n<pre><code class=\"language-cs\">public string filePath;//存档路径\n\nprivate void Temp()\n    {\n        filePath = Application.temporaryCachePath+ \"/jsonDatas.json\";\n    }</code></pre>\n<h2></h2>\n<p> 注：关于数据存储读取具体操作，可以参考我的其他文章笔记：<br/><a class=\"link-info\" href=\"https://blog.csdn.net/weixin_43908355/article/details/115181472\" title=\"Unity数据存储学习——创建、存储、读取Json文件\">Unity数据存储学习——创建、存储、读取Json文件</a></p>\n<p><a class=\"link-info\" href=\"https://blog.csdn.net/weixin_43908355/article/details/115176096\" title=\"Unity数据存储学习之——本地playerPref存储\">Unity数据存储学习之——本地playerPref存储</a></p>\n</div>\n</div>"}