{"blogid": "124174756", "writerAge": "码龄1年", "writerBlogNum": "10", "writerCollect": "14", "writerComment": "4", "writerFan": "11", "writerGrade": "2级", "writerIntegral": "156", "writerName": "小白舒_SC", "writerProfileAdress": "writer_image\\profile_124174756.jpg", "writerRankTotal": "112340", "writerRankWeekly": "360470", "writerThumb": "46", "writerVisitNum": "4032", "blog_read_count": "1558", "blog_time": "已于 2022-04-14 23:21:21 修改", "blog_title": "Qt多线程的两种创建方法以及快速停止线程方法", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h1 id=\"%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95\"><a id=\"_0\"></a>文章目录</h1>\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95-toc\" style=\"margin-left:0px;\"><a href=\"#%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95\">文章目录</a></p>\n<p id=\"%E5%89%8D%E8%A8%80-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%89%8D%E8%A8%80\">前言</a></p>\n<p id=\"%E4%B8%80%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%88%9B%E5%BB%BA%E6%96%B9%E6%B3%95-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%80%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%88%9B%E5%BB%BA%E6%96%B9%E6%B3%95\">一、多线程的两种创建方法</a></p>\n<p id=\"%E7%BB%A7%E6%89%BFQThread-toc\" style=\"margin-left:40px;\"><a href=\"#%E7%BB%A7%E6%89%BFQThread\">1.继承QThread</a></p>\n<p id=\"%C2%A0moveToThread%E6%96%B9%E6%B3%95-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A0moveToThread%E6%96%B9%E6%B3%95\">2.moveToThread方法</a></p>\n<p id=\"%E4%BA%8C%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BF%AB%E9%80%9F%E5%81%9C%E6%AD%A2-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BA%8C%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BF%AB%E9%80%9F%E5%81%9C%E6%AD%A2\">二、多线程快速停止</a></p>\n<p id=\"1.%E7%BA%BF%E7%A8%8B%E5%81%9C%E6%AD%A2%E4%BB%8B%E7%BB%8D-toc\" style=\"margin-left:40px;\"><a href=\"#1.%E7%BA%BF%E7%A8%8B%E5%81%9C%E6%AD%A2%E4%BB%8B%E7%BB%8D\">1.线程停止介绍</a></p>\n<p id=\"2.%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#2.%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%C2%A0\">2.具体实现 </a></p>\n<p id=\"%E6%80%BB%E7%BB%93-toc\" style=\"margin-left:0px;\"><a href=\"#%E6%80%BB%E7%BB%93\">总结</a></p>\n<hr/>\n<h1 id=\"%E5%89%8D%E8%A8%80\"><a id=\"_12\"></a>前言</h1>\n<p>介绍多线程的两种创建方法以及快速停止线程的方法</p>\n<h1 id=\"%E4%B8%80%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%88%9B%E5%BB%BA%E6%96%B9%E6%B3%95\"><a id=\"pandas_22\"></a>一、多线程的两种创建方法</h1>\n<h2 id=\"%E7%BB%A7%E6%89%BFQThread\">1.继承QThread</h2>\n<p>1.自定义一个类，继承于QThread。</p>\n<pre><code class=\"language-cpp\">class MyThread：public QThread{\npublic:\n     virtual void run() override;\t//虚函数  线程处理函数（和主线程不在同一个线程）\n    \nsignals:\n    void Finshed();\t//信号 线程执行完发送\n}\nvoid MyThread::run() {\n    // 实现  -- 复杂的处理过程\n    \n    emit Finished;\t// 发送线程\n};\n</code></pre>\n<p> 2.定义线程</p>\n<pre><code class=\"language-cpp\">MyThread mythread;\n//MyThread* mythread = new MyThread();</code></pre>\n<p> 3.开启线程</p>\n<pre><code class=\"language-cpp\">mythread.start();\n//mythread-&gt;start();</code></pre>\n<blockquote>\n<p> 通过执行mythread.start()或者mythread-&gt;start()启动run()函数，而不是直接调用run()函数。</p>\n</blockquote>\n<p>4.自定义线程结束槽函数</p>\n<blockquote>\n<p>run()函数结束前会发送 Finished信号，可以自定义槽函数打印线程结束；</p>\n</blockquote>\n<pre><code class=\"language-cpp\">public slots:\n\tvoid SlotFinished();\n——————————————————————\nvoid MyWidget::SlotFinished(){\n    // 线程结束后的操作\n    qDebug() &lt;&lt; \"子线程结束！\";\n}\n</code></pre>\n<p>5.绑定线程结束信号和线程结束槽</p>\n<pre><code class=\"language-cpp\">connect(&amp;mythread,&amp;MyThread::Finished,this,&amp;MyWidget::SlotFinished);\n//connect(mythread,&amp;MyThread::Finished,this,&amp;MyWidget::SlotFinished);\n</code></pre>\n<blockquote>\n<p>【提示】MyThread类可以自定义多种方法，在run()函数内执行。 </p>\n</blockquote>\n<pre><code class=\"language-cpp\">class MyThread：public QThread{\npublic:\n   virtual void run() override;\t//虚函数  线程处理函数（和主线程不在同一个线程）\n\n    void Func1();//方法1\n    void Func2();//方法2\nsignals:\n    void Finshed();\t//信号 线程执行完发送\n}\nvoid MyThread::run() {\n    // 实现  -- 复杂的处理过程\n    Func1();\n    Func2();\n\n    emit Finished;\t// 发送线程\n};\n</code></pre>\n<h2 id=\"%C2%A0moveToThread%E6%96%B9%E6%B3%95\">2.moveToThread方法</h2>\n<p> 1.自定义一个功能实现类。</p>\n<pre><code class=\"language-cpp\">#ifndef THREAD_H\n#define THREAD_H\n \n#include &lt;QObject&gt;\n \nclass MyThread :public QObject\n{\n    Q_OBJECT\npublic:\n    MyThread();\n    ~Mythread();\n\n    void Func1();\n    void Func2();\n};\n \n#endif // THREAD_H</code></pre>\n<p>2.mythread.cpp中去完善构造函数与功能函数的具体实现。 </p>\n<pre><code class=\"language-cpp\">#include \"mythread.h\"\n#include &lt;QDebug&gt;\nThread::Thread()\n{\n    \n}\n \nvoid MyThread::Func1()\n{\n    qDebug()&lt;&lt;\"方法1\";\n}\n\nvoid MyThread::Func2()\n{\n    qDebug()&lt;&lt;\"方法2\";\n}</code></pre>\n<p>3. 在你的窗口mywidget.h中添加各种头文件，创建两个信号，声明一个线程和刚刚创建的自定义功能实现类，添加两个按钮，声明两个响应按钮的槽函数。</p>\n<pre><code class=\"language-cpp\">#ifndef MYWIDGET_H\n#define MYWIDGET_H\n \n#include &lt;QWidget&gt;\n#include &lt;QThread&gt;\n#include &lt;QObject&gt;\n#include \"thread.h\"\n#include &lt;QtWidgets/QPushButton&gt;\n \nnamespace Ui {\nclass MyWidget ;\n}\n \nclass MyWidget : public QWidget\n{\n    Q_OBJECT\n \npublic:\n    MyWidget (QWidget *parent = 0);\n    ~MyWidget ();\n\npublic slots:\n    void SlotDoFunc1();\n    void SlotDoFunc2();\n\nsignals:\n    void RunFunc1(); // 信号\n    void RunFunc2(); \n \nprivate:\n    Ui::MyWidget *ui;\n    QThread *Thread;//qt的线程类\n    MyThread *Mythread;//自定义的功能实现类\n\n    QPushButton* Func1QPushButton;//执行方法1按钮\n    QPushButton* Func2QPushButton;//执行方法2按钮\n};\n \n#endif // MYWIDGET_H</code></pre>\n<p> 4.在mywidget.cpp中，先实例化Thread线程和Mythread，并且把Mythread这个类推向子线程，代码如下：</p>\n<pre><code class=\"language-cpp\">#include \"mywidget.h\"\n#include \"ui_mywidget.h\"\n \nMyWidget::MyWidget(QWidget *parent) :\n    QWidget(parent),\n    ui(new Ui::MyWidget)\n{\n    ui-&gt;setupUi(this);\n\n    Thread = new QThread;\n    Mythread = new MyThread;\n\n    connect(this,&amp;MyWidget::RunFunc1,Mythread ,&amp;Mythread::Func1);\n    connect(this,&amp;MyWidget::RunFunc2,Mythread ,&amp;Mythread::Func2);\n\n    Mythread-&gt;moveToThread(Thread);\n    connect(ui-&gt;Func1QPushButton, SIGNAL(clicked()), this, SLOT(SlotDoFunc1()));\n    connect(ui-&gt;Func2QPushButton, SIGNAL(clicked()), this, SLOT(SlotDoFunc2()));\n}\n\nvoid MyWidget::SlotDoFunc1()\n{\n    //线程开启之前需要等之前的线程结束\n\tif (Thread-&gt;isRunning())\n\t{\n\t\twait();\n\t}\n    emit RunFunc1();\n    Thread-&gt;start();\n}\n\nvoid MyWidget::SlotDoFunc2()\n{\n    //线程开启之前需要等之前的线程结束\n\tif (Thread-&gt;isRunning())\n\t{\n\t\twait();\n\t}\n    emit RunFunc2();\n    Thread-&gt;start();\n}\n \nMyWidget::~MyWidget()\n{\n    delete ui;\n}</code></pre>\n<h1 id=\"%E4%BA%8C%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BF%AB%E9%80%9F%E5%81%9C%E6%AD%A2\"><a id=\"_26\"></a>二、多线程快速停止</h1>\n<h2 id=\"1.%E7%BA%BF%E7%A8%8B%E5%81%9C%E6%AD%A2%E4%BB%8B%E7%BB%8D\"><a id=\"1_27\"></a>1.线程停止介绍</h2>\n<blockquote>\n<p>子线程停止标志是run()函数运行结束，quit()、stop()【terminate()没试过，但是不建议使用，会出现内存问题】等并不会立刻停止run()，只是告诉线程要停止，真正停止还是需要等run()函数执行完毕。想快速停止必须要自定义方法，给出停止标志。以第一种创建多线程方法为例，具体操作如下：</p>\n</blockquote>\n<h2 id=\"2.%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%C2%A0\">2.具体实现 </h2>\n<p> 1.在线程类中，声明一个bool值的停止标志，以及停止函数。</p>\n<pre><code class=\"language-cpp\">class MyThread：public QThread{\n    \n    Q_OBJECT\n\npublic:\n    MyThread();\n    ~MyThread();\n\npublic:\n     virtual void run() override;\t//虚函数  线程处理函数（和主线程不在同一个线程）\n\npublic:\n    void Stop();//停止函数\n\nsignals:\n    void Finshed();\t//信号 线程执行完发送\n}\n\nprivate:\n    bool m_bStop;//停止标志\n</code></pre>\n<p>2.在mythread.cpp的构造函数中初始化m_bStop为false，Stop方法中用来设置m_bStop的值。</p>\n<pre><code class=\"language-cpp\">MyThread::MyThread()\n: QThread()\n{\n    m_bStop = false;\n}</code></pre>\n<pre><code class=\"language-cpp\">void MyThread::Stop()\n{\n    m_bStop = true;\n}</code></pre>\n<p>3. 在run()函数的耗时的循环中加判断，退出循环。</p>\n<pre><code class=\"language-cpp\">void MyThread::run()\n{\n    //m_bStop = false;//如果线程未被delete且多次停止启用需要\n加这句保证循环开始时m_bStop始终为false,否则第二次开启将不会进入循环。\n    for（int i, i&lt; 10000, i++）\n    {\n        if(m_bStop)\n        {\n            return;\n        }\n        //复杂的计算\n    }\n    emit Finished;\t// 发送线程\n}\n</code></pre>\n<p>4.在需要停止线程的地方，调用线程类的Stop()方法即可。 </p>\n<pre><code class=\"language-cpp\">void MyWidget::Func()\n{\n    MyThread myThread;\n    myThread.Stop();\n   // MyThread* myThread = new MyThread();\n   // myThread-&gt;Stop();\n}</code></pre>\n<blockquote>\n<p>如果在run()函数中调用线程类本身自定义的方法，方法中有耗时的循环，可类推。代码如下： </p>\n</blockquote>\n<pre><code class=\"language-cpp\">class MyThread：public QThread{\npublic:\n   virtual void run() override;\t//虚函数  线程处理函数（和主线程不在同一个线程）\n\n    void Func();//线程类本身自定义方法\nsignals:\n    void Finshed();\t//信号 线程执行完发送\n}\n\nvoid MyThread::run() {\n\n    m_bStop = false;\n    Func();//实现线程类本身自定义方法\n    emit Finished;\t// 发送线程\n};\n\nvoid MyThread::Func() {\n\n    for（int i, i&lt; 10000, i++）\n    {\n        if(m_bStop)\n        {\n            return;\n        }\n        //复杂的计算\n    }\n};\n</code></pre>\n<h1 id=\"%E6%80%BB%E7%BB%93\"><a id=\"_55\"></a>总结</h1>\n<p>正在学习中，欢迎批评指正！</p>\n</div>\n</div>"}