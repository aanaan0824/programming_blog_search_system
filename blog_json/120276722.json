{"blogid": "120276722", "writerAge": "码龄1年", "writerBlogNum": "67", "writerCollect": "2132", "writerComment": "2068", "writerFan": "8564", "writerGrade": "6级", "writerIntegral": "5939", "writerName": "芒果再努力", "writerProfileAdress": "writer_image\\profile_120276722.jpg", "writerRankTotal": "2484", "writerRankWeekly": "1883", "writerThumb": "2422", "writerVisitNum": "79807", "blog_read_count": "4049", "blog_time": "于 2021-09-13 22:55:04 发布", "blog_title": "C语言-八道笔试题由浅入深玩转指针", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p><strong>前言：本文章将带你刷8道比较有意思的指针笔试题，笔者将由深入浅出解析这些题目！必要的题目，作者已经加上内存布局图！希望本文对你有所帮助！</strong></p>\n<hr/>\n<p> <strong>目录</strong></p>\n<p id=\"%E4%B8%80.%E7%AC%94%E8%AF%95%E9%A2%981%20-%E6%8C%87%E9%92%88%E4%B8%8E%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%85%B3%E7%B3%BB-%E5%80%BC-toc\" style=\"margin-left:80px;\"><a href=\"#%E4%B8%80.%E7%AC%94%E8%AF%95%E9%A2%981%20-%E6%8C%87%E9%92%88%E4%B8%8E%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%85%B3%E7%B3%BB-%E5%80%BC\" title=\"一.笔试题1 -指针与一维数组的关系-值\">一.笔试题1 -指针与一维数组的关系-值</a></p>\n<p id=\"%E4%BA%8C.%E7%AC%94%E8%AF%95%E9%A2%982-%E6%8C%87%E9%92%88%E4%B8%8E%E7%BB%93%E6%9E%84%E4%BD%93-toc\" style=\"margin-left:80px;\"><a href=\"#%E4%BA%8C.%E7%AC%94%E8%AF%95%E9%A2%982-%E6%8C%87%E9%92%88%E4%B8%8E%E7%BB%93%E6%9E%84%E4%BD%93\" title=\"二.笔试题2-指针与结构体\">二.笔试题2-指针与结构体</a></p>\n<p id=\"%E4%B8%89.%E7%AC%94%E8%AF%95%E9%A2%983-%E6%8C%87%E9%92%88%E4%B8%8E%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%85%B3%E7%B3%BB-%E5%9D%80-toc\" style=\"margin-left:80px;\"><a href=\"#%E4%B8%89.%E7%AC%94%E8%AF%95%E9%A2%983-%E6%8C%87%E9%92%88%E4%B8%8E%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%85%B3%E7%B3%BB-%E5%9D%80\" title=\"三.笔试题3-指针与一维数组的关系-址\">三.笔试题3-指针与一维数组的关系-址</a></p>\n<p id=\"%E5%9B%9B.%E7%AC%94%E8%AF%95%E9%A2%984-%E6%8C%87%E9%92%88%E4%B8%8E%E9%80%97%E5%8F%B7%E8%A1%A8%E8%BE%BE%E5%BC%8F-toc\" style=\"margin-left:80px;\"><a href=\"#%E5%9B%9B.%E7%AC%94%E8%AF%95%E9%A2%984-%E6%8C%87%E9%92%88%E4%B8%8E%E9%80%97%E5%8F%B7%E8%A1%A8%E8%BE%BE%E5%BC%8F\" title=\"四.笔试题4-指针与逗号表达式\">四.笔试题4-指针与逗号表达式</a></p>\n<p id=\"%E4%BA%94.%E7%AC%94%E8%AF%95%E9%A2%985-%E6%8C%87%E9%92%88%E4%B8%8E%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84-toc\" style=\"margin-left:80px;\"><a href=\"#%E4%BA%94.%E7%AC%94%E8%AF%95%E9%A2%985-%E6%8C%87%E9%92%88%E4%B8%8E%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84\" title=\"五.笔试题5-指针与二维数组\">五.笔试题5-指针与二维数组</a></p>\n<p id=\"%E5%85%AD.%E7%AC%94%E8%AF%95%E9%A2%986-%E6%8C%87%E9%92%88%E4%B8%8E%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84-toc\" style=\"margin-left:80px;\"><a href=\"#%E5%85%AD.%E7%AC%94%E8%AF%95%E9%A2%986-%E6%8C%87%E9%92%88%E4%B8%8E%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84\" title=\"六.笔试题6-指针与二维数组\">六.笔试题6-指针与二维数组</a></p>\n<p id=\"%E4%B8%83.%E7%AC%94%E8%AF%95%E9%A2%987-%E6%8C%87%E9%92%88%E4%B8%8E%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84-toc\" style=\"margin-left:80px;\"><a href=\"#%E4%B8%83.%E7%AC%94%E8%AF%95%E9%A2%987-%E6%8C%87%E9%92%88%E4%B8%8E%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84\" title=\"七.笔试题7-指针与字符指针数组\">七.笔试题7-指针与字符指针数组</a></p>\n<p id=\"%E5%85%AB.%E7%AC%94%E8%AF%95%E9%A2%989-%E6%8C%87%E9%92%88%E4%B8%8E%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84(%E9%9A%BE)-toc\" style=\"margin-left:80px;\"><a href=\"#%E5%85%AB.%E7%AC%94%E8%AF%95%E9%A2%989-%E6%8C%87%E9%92%88%E4%B8%8E%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%28%E9%9A%BE%29\" title=\"八.笔试题9-指针与字符指针数组(难)\">八.笔试题9-指针与字符指针数组(难)</a></p>\n<hr id=\"hr-toc\"/>\n<h3>一.笔试题1 -指针与一维数组的关系-值</h3>\n<pre><code>int main()\n{\n    int a[5] = { 1, 2, 3, 4, 5 };\n    int *ptr = (int *)(&amp;a + 1);\t//&amp;a：取出整个数组的地址，&amp;a+1：跳过一个数组\n    //&amp;a的类型为：数组指针  int(*)[5] \t\t\t所以要强转\n    \n    //a为数组名，首元素地址，即为1的地址，+1，跳过一个元素，即为2的地址\n    printf( \"%d,%d\", *(a + 1), *(ptr - 1));  // 2  5\n    return 0;\n}</code></pre>\n<hr/>\n<p>图解：<img alt=\"\" height=\"250\" src=\"image\\20210913220920908.png\" width=\"371\"/> </p>\n<hr/>\n<h2> 二.笔试题2-指针与结构体</h2>\n<pre><code>//这里告知结构体的大小是20个字节\nstruct Test\n{\n    int Num;\n    char *pcName;\n    short sDate;\n    char cha[2];\n    short sBa[4];\n}*p;\n//假设p 的值为0x100000。 如下表表达式的值分别为多少？\nint main()\n{\n    p = 0x00100000;\n    //0x1--&gt;对应的值就是1  相当于0x00000001\n    printf(\"%p\\n\", p + 0x1);//p为结构体指针，指向一个结构体，+1，跳过一个结构体，即跳过20个字节，\n    //   0x00100000+20 -&gt; 0x00100020 错误，  要将20转化为16进制再加，或者将16进制0x00100000转化为10进制之后加上20，然后再转化为16进制\n    // 20-&gt; 0X00000014 \n    //所以最终结果为：0x00100014\n    printf(\"%p\\n\", (unsigned long)p + 0x1);//将p转化为长整形，+1，即为整形+1，  例如：500+1= 501，\n    //所以结果为： 0x00100001\n    printf(\"%p\\n\", (unsigned int*)p + 0x1);\n    //将p强转为无符号整形，+1跳过一个整形-&gt;跳过4个字节\n    //所以结果为：0x00100004\n    return 0;\n}</code></pre>\n<p><strong>注意坑点：整数+1 -&gt;跳过一个字节  执行普通的加减运算</strong></p>\n<p><strong>       而整形指针+1 -&gt;跳过四个字节 </strong></p>\n<p><span style=\"color:#fe2c24;\"><strong>指针+1 的步长取决于指针指向的数据的类型</strong></span></p>\n<hr/>\n<h3>三.笔试题3-指针与一维数组的关系-址</h3>\n<pre><code>int main()\n{\n    int a[4] = { 1, 2, 3, 4 };\n    int *ptr1 = (int *)(&amp;a + 1);\n    int *ptr2 = (int *)((int)a + 1);\n    printf( \"%x,%x\", ptr1[-1], *ptr2);\t// 4 2000000\n    return 0;\n}</code></pre>\n<blockquote>\n<p>解析： </p>\n<p><strong>int *ptr1 = (int *)(&amp;a + 1)</strong>:  取出数组的地址+1，跳过一个数组，因为&amp;a的类型为数组指针：int(*)[4] 类型不匹配，所以强转为int类型</p>\n<p>prt1[-1]==&gt; *(ptr1+（-1)）==&gt;*(ptr1-1)</p>\n<p>-------------------------------------------------------------------------------------------------------</p>\n<p><strong>int *ptr2 = (int *)((int)a + 1)</strong></p>\n<p>此时的a代表的首元素地址，<span style=\"color:#be191c;\">地址值是一个常量，</span></p>\n<p><span style=\"color:#e6b223;\">整数+1：相当于跳过一个字节</span></p>\n<p>所以应该画出数组的整体字节布局，注意要考虑<strong><span style=\"color:#ff9900;\">小端存放</span>，<span style=\"color:#fe2c24;\">读取时倒着读取的问题</span></strong></p>\n<p><img alt=\"\" height=\"286\" src=\"image\\20210913221439852.png\" width=\"674\"/></p>\n<p><strong>ptr2是整形指针，解引用向后访问4个字节</strong></p>\n<p><strong>所以ptr2指向的是00 00 00 02这四个字节</strong></p>\n<p><strong>要倒着拿：所以打印结果为：02000000</strong></p>\n</blockquote>\n<p>图解：</p>\n<p><img alt=\"\" height=\"266\" src=\"image\\20210913221237918.png\" width=\"614\"/></p>\n<p>注意点：<strong>整形+1：加一个字节</strong>    如：500+1 = 501  </p>\n<p>           <strong>   整形指针+1：跳过(加)4个字节</strong></p>\n<hr/>\n<h2> 四.笔试题4-指针与逗号表达式 </h2>\n<pre><code>int main()\n{\n   int a[3][2] = { (0, 1), (2, 3), (4, 5) };\n   int *p;\n   p = a[0];\n   printf(\"%d \",p[0]);\t//1\n   return 0;\n}</code></pre>\n<p><strong>坑点：<span style=\"color:#fe2c24;\">逗号表达式-结果为最后一个表达式的结果</span></strong></p>\n<p>图解：<img alt=\"\" height=\"340\" src=\"image\\2021091322205932.png\" width=\"641\"/> </p>\n<p><strong>所以相当于只初始化了前三个元素，后面的元素未初始化，默认为0  </strong></p>\n<blockquote>\n<p>解析：</p>\n<p>a[0] : 二维数组第一行的数组名，在这里是首元素地址，即第一行第一个元素的地址</p>\n<p>p[0] ==&gt;*(p+0)==&gt;*p</p>\n<p>p是整形指针，解引用向后访问4个字节</p>\n</blockquote>\n<p><img alt=\"\" height=\"266\" src=\"image\\20210913222449401.png\" width=\"511\"/>  </p>\n<hr/>\n<h3>五.笔试题5-指针与二维数组</h3>\n<pre><code>int main()\n{\n    int a[5][5];\n    int(*p)[4];\n    p = a;\n    printf( \"%p,%d\\n\", &amp;p[4][2]-&amp;a[4][2], &amp;p[4][2]-&amp;a[4][2]);\n    return 0;\n}</code></pre>\n<p><strong>注意：p是数组指针，指向的数组有4个元素</strong></p>\n<p><span style=\"color:#fe2c24;\"><strong>指针-指针得到的是二者之间的元素个数</strong></span></p>\n<p><strong>p[4] = *(p+4)</strong></p>\n<p><strong>p[4][2] ==&gt; *(*(p+4)+2)</strong></p>\n<p>图解：</p>\n<p><img alt=\"\" height=\"342\" src=\"image\\20210913222622589.png\" width=\"682\"/></p>\n<p><strong>&amp;p[4][2]为小地址，&amp;a[4][2]为大地址，小地址减大地址，所以最后结果为-4</strong>  </p>\n<hr/>\n<blockquote>\n<p>-4：<br/> 原码：10000000 00000000 00000000 00000100<br/> 反码：11111111 11111111 11111111 11111011<br/> 补码：11111111 11111111 11111111 11111100</p>\n</blockquote>\n<p>使用%p方式打印：打印的是-4对应的补码 1111 1111 1111 1111 1111 1111 1111 1100 -&gt;结果为：FFFFFFFC</p>\n<p><span style=\"color:#fe2c24;\"><strong>整数在内存中以补码方式存储<em>，</em>打印地址和打印无符号整数一样，都是打印内存中补码</strong></span></p>\n<p>使用%d方式打印：打印二进制补码对应的原码，=&gt;  -4</p>\n<hr/>\n<p><span style=\"color:#fe2c24;\">注意</span>：<strong>a是二维数组，对应数组指针的类型为：int(*)[5]，指向的是有5个元素的一维数组</strong></p>\n<p><strong>而p是数组指针，指向的数组只有4个元素，所以会有警告</strong></p>\n<p>-&gt;可以写成 <strong>int(*p)[4] = (int(*)[4])a</strong> 消除警告</p>\n<hr/>\n<h3>六.笔试题6-指针与二维数组</h3>\n<pre><code>int main()\n{\n    int aa[2][5] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n    int *ptr1 = (int *)(&amp;aa + 1);\n    int *ptr2 = (int *)(*(aa + 1));\n    printf( \"%d,%d\", *(ptr1 - 1), *(ptr2 - 1));    // 5 10\n\treturn 0;\n}</code></pre>\n<blockquote>\n<p>解析：</p>\n<p><strong>&amp;aa：取出二维数组的地址 &amp;aa+1：跳过二维数组</strong></p>\n<p><strong>&amp;二维数组应该使用数组指针接收，现在保存到整形指针，所以要强转。</strong></p>\n<p><strong>aa:没有单独放在sizeof内部，没有&amp;数组名，所以代表的是二维数组首元素地址，即二维数组第一行的地址</strong></p>\n<p><strong>aa+1：跳过一行</strong></p>\n<p><strong>*(aa+1) : 相当于拿到了第二行的数组名 等价于 aa[1]</strong> </p>\n</blockquote>\n<p>图解：<img alt=\"\" height=\"300\" src=\"image\\20210913223015739.png\" width=\"538\"/> </p>\n<hr/>\n<h3>七.笔试题7-指针与字符指针数组</h3>\n<pre><code>#include &lt;stdio.h&gt;\nint main()\n{\n    char *a[] = {\"work\",\"at\",\"alibaba\"};\n    char**pa = a;\n    pa++;\n    printf(\"%s\\n\", *pa);\n\treturn 0;\n}</code></pre>\n<blockquote>\n<p>解析： </p>\n<p><strong>a是数组，元素类型为：char* ，存放的是指向字符串的首字符地址</strong></p>\n<p><strong>根据后面初始化的内容确定数组的大小</strong></p>\n<p><strong>char** pa = a ; 此处的a是首元素地址，char**类型</strong></p>\n<p><strong>--------</strong></p>\n<p><strong>char**pa ：一颗*说明pa是指针，另一颗*说明pa指向的类型是char*</strong></p>\n<p><strong>pa+1:跳过char*</strong></p>\n<p><strong>所以从字符a的地址向后打印，遇到\\0即停止打印</strong></p>\n<p><strong>打印结果为：at</strong></p>\n</blockquote>\n<hr/>\n<p>图解：</p>\n<p><img alt=\"\" height=\"417\" src=\"image\\20210913223532721.png\" width=\"1200\"/></p>\n<hr/>\n<h1><strong> 八.笔试题9-指针与字符指针数组(难)</strong></h1>\n<pre><code>int main()\n{\n    char *c[] = {\"ENTER\",\"NEW\",\"POINT\",\"FIRST\"};\n    char**cp[] = {c+3,c+2,c+1,c};\n    char***cpp = cp;\n    printf(\"%s\\n\", **++cpp);\n    printf(\"%s\\n\", *--*++cpp+3);\n    printf(\"%s\\n\", *cpp[-2]+3);\n    printf(\"%s\\n\", cpp[-1][-1]+1);\n    return 0;\n}</code></pre>\n<p>这道题比较难，所以我们分表达式解决！</p>\n<hr/>\n<p> 最最最初的内存布局：</p>\n<p><img alt=\"\" height=\"459\" src=\"image\\20210913223638246.png\" width=\"1200\"/></p>\n<hr/>\n<blockquote>\n<p>解析：**++cpp</p>\n<p><strong>前置++，cpp先自增，</strong></p>\n<p><img alt=\"\" height=\"682\" src=\"image\\20210913223712717.png\" width=\"1008\"/></p>\n<hr/>\n<p>此时cpp</p>\n<p>（存放了）指向存放c+2地址的空间（地址）</p>\n<p>*cpp-&gt;得到c+2的地址</p>\n<p>**cpp得到c+2中存放的内容-&gt;首字符P的地址</p>\n<hr/>\n<p>所以从首字符P开始向后打印，打印结果为：POINT</p>\n</blockquote>\n<hr/>\n<blockquote>\n<p> 解析：*--*++cpp+3</p>\n<p>注意：<span style=\"color:#fe2c24;\"><strong>上面的表达式，cpp发生自增，指向的已经是存放c+2地址的空间</strong> </span></p>\n<p>++cpp ：前置++，cpp发生自增原来是指向存放c+2地址的空间，变为指向存放c+1地址的空间</p>\n<p><img alt=\"\" height=\"702\" src=\"image\\20210913223827553.png\" width=\"1117\"/></p>\n<hr/>\n<p>*++cpp：<strong>拿到存放c+1地址的空间</strong>，里面存放的是c+1的地址</p>\n<p>--*++cpp；前置--，相当于自减解引用cpp之后的内容，即自减c+1的地址，（地址值是常量）。即把原来空间存放的是c+1的地址变成了存放的是c的地址，即<strong>现在拿到的是存放c地址的空间</strong></p>\n<hr/>\n<p><img alt=\"\" height=\"410\" src=\"image\\20210913223855716.png\" width=\"1200\"/></p>\n<p>*--*++cpp ： 得到c空间中存放的内容（首字符E的地址）</p>\n<p>*--*++cpp+3 ：从首字符E的地址向后+3 ，即为E的地址</p>\n<hr/>\n<p>从E的地址向后打印-&gt;打印结果为ER</p>\n</blockquote>\n<hr/>\n<blockquote>\n<p>解析：*cpp[-2]+3</p>\n<p><img alt=\"\" height=\"400\" src=\"image\\20210913223921393.png\" width=\"1200\"/></p>\n<hr/>\n<p>cpp[-2] ==&gt;*(cpp+(-2) )==&gt; *(cpp-2)</p>\n<p>*cpp[-2]+3 ==&gt; **(cpp-2) )+3</p>\n<p>cpp-2:从指向存放c地址空间又变为了指向存放c+3地址的空间</p>\n<p><img alt=\"\" height=\"480\" src=\"image\\20210913223945363.png\" width=\"1198\"/></p>\n<p>*(cpp-2):得到cpp现在指向的内容，即c+3的地址</p>\n<p>**(cpp-2)：得到c+3空间的内容（首字符F的地址）</p>\n<p>**(cpp-2)+3 :从首字符F的地址向后+3，即为S的地址</p>\n<hr/>\n<p>从S的地址向后打印，打印结果为：ST</p>\n</blockquote>\n<hr/>\n<blockquote>\n<p>解析：cpp[-1][-1]+1</p>\n<p>cpp[-1] ==&gt;*(cpp-1)</p>\n<p>cpp[-1][-1] ==&gt; *(*(cpp-1)-1)</p>\n<p>cpp[-1][-1] +1 ==&gt; *(*(cpp-1)-1) +1</p>\n<p><span style=\"color:#fe2c24;\"> <strong>注意：此时的cpp指向为第二条表达式之后的状态，上面的第三条表达式并没有改变cpp（即cpp没有自增自减以及被赋值）</strong>，<strong>也没有改变其指向内容</strong>，<strong>所以第四条表达式的初始状态为计算第二条表达式之后的内存布局</strong> </span></p>\n<p><img alt=\"\" height=\"546\" src=\"image\\20210913224046864.png\" width=\"1195\"/></p>\n<p> cpp-1：变为指向存放c+2地址的空间</p>\n<p><img alt=\"\" height=\"457\" src=\"image\\20210913224057840.png\" width=\"1200\"/></p>\n<p>*(cpp-1):<strong>得到c+2的地址</strong></p>\n<p>*(cpp-1)-1 ：c+2的地址值（常量）自减，变成了c+1的地址，<strong>即得到了c+1的地址</strong></p>\n<p><img alt=\"\" height=\"399\" src=\"image\\20210913224117751.png\" width=\"1200\"/></p>\n<p>*(*(cpp-1)-1): 得到c+1的内容（首字符N的地址）</p>\n<p>*(*(cpp-1)-1)+1:得到首字符N向后+1跳过一个字符，即为字符E的地址</p>\n<hr/>\n<p>从字符E向后打印，打印结果为EW</p>\n</blockquote>\n<hr/>\n<p><strong>总结： </strong></p>\n<p><strong>能坚持看完，你已经比别人优秀很多了！也感谢你看到最后，如果笔者哪里写错了的话，欢迎大佬们评论区指正！<span style=\"color:#fe2c24;\">如果此文对你有帮助的话，欢迎留个关注，留个赞再走呀！</span></strong></p>\n</div>\n</div>"}