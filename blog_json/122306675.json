{"blogid": "122306675", "writerAge": "码龄1年", "writerBlogNum": "144", "writerCollect": "609", "writerComment": "35", "writerFan": "804", "writerGrade": "5级", "writerIntegral": "2383", "writerName": "IT孔乙己", "writerProfileAdress": "writer_image\\profile_122306675.jpg", "writerRankTotal": "68236", "writerRankWeekly": "162821", "writerThumb": "121", "writerVisitNum": "182330", "blog_read_count": "3800", "blog_time": "于 2022-01-04 16:54:12 发布", "blog_title": "厌倦了C++，CS&ML博士用Rust重写Python扩展，还总结了9条规则", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>选自medium.com</p>\n<p><strong>作者：</strong> <strong>Carl M. Kadie</strong></p>\n<p><strong>机器之心编译</strong></p>\n<p><strong>编辑：杜伟、陈萍</strong></p>\n<p>效果好不好，试一试就知道了。</p>\n<p>Python 是数据科学家最流行的编程语言之一，其内部集成了高质量分析库，包括 NumPy、SciPy、自然语言工具包等，这些库中的许多都是用 C 和 C++ 实现的。</p>\n<p>然而，C 和 C++ 兼容性差，且本身不提供线程安全。有研究者开始转向 Rust，重写 C++ 扩展。</p>\n<p><strong>拥有 CS 与机器学习博士学位的 Carl M. Kadie </strong>，通过更新 Python 中生物信息学软件包 Bed-Reader，为研究者带来了在 Rust 中编写 Python 扩展的九个规则。以下是原博客的主要内容。</p>\n<p>一年前，我厌倦了我们软件包 Bed-Reader 的 C++ 扩展，我用 Rust 重写了它，令人高兴的是，得到的新扩展和 C/C++ 一样快，但具有更好的兼容性和安全性。一路走来，我学会了这九条规则，可以帮助你创建更好的扩展代码，这 <strong>九条规则</strong> 包括：</p>\n<p>1. 创建一个包含 Rust 和 Python 项目的单独存储库</p>\n<p>2. 使用 maturin &amp; PyO3 在 Rust 中创建 Python-callable translator 函数</p>\n<p>3. 让 Rust translator 函数调用 nice Rust 函数</p>\n<p>4. 在 Python 中预分配内存</p>\n<p>5. 将 nice Rust 错误处理翻译 nice Python 错误处理</p>\n<p>6. 多线程与 Rayon 和 ndarray::parallel，返回任何错误</p>\n<p>7. 允许用户控制并行线程数</p>\n<p>8. 将 nice 动态类型 Python 函数翻译成 nice Rust 泛型函数</p>\n<p>9. 创建 Rust 和 Python 测试</p>\n<p>其中， 文中提到的 nice 这个词是指使用最佳实践和原生类型创建 。换句话说：在代码顶部，编写 nice Python 代码；在中间，用 Rust 编写 translator 代码；在底部，编写 nice Rust 代码。结构如下图所示：</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\73620356e677cad6349d241e5e9b4663.png\"/></p>\n<p>上述策略看似显而易见，但遵循它可能会很棘手。本文提供了有关如何遵循每条规则的实用建议和示例。</p>\n<p>我在 Bed-Reader 进行了实验， <strong>Bed-Reader 是一个 Python 包</strong> ，用于读取和写入 PLINK Bed Files，这是一种在生物信息学中用于存储 DNA 数据的二进制格式。Bed 格式的文件可以达到 TB。Bed-Reader 让用户可以快速、随机地访问数据的子集。它在用户选择的 int8、float32 或 float64 中返回一个 NumPy 数组。</p>\n<p>我希望 Bed-Reader 扩展代码具有以下特点：</p>\n<ul><li> <p>比 Python 快；</p> </li><li> <p>兼容 NumPy；</p> </li><li> <p>可以进行数据并行多线程处理；</p> </li><li> <p>与执行数据并行多线程的所有其他包兼容；</p> </li><li> <p>安全。</p> </li></ul>\n<p>我们最初的 C++ 扩展兼具速度快、与 NumPy 兼容，以及使用 OpenMP 进行数据并行多线程等特点。遗憾的是，OpenMP 运行时库 (Runtime library)，存在 Python 包兼容版本问题。</p>\n<p>Rust 提供了 C++ 扩展带来的优势。除此之外，Rust 通过提供没有运行时库的数据并行多线程解决了运行时兼容性问题。此外，Rust 编译器还能保证线程安全。</p>\n<p>在 Rust 中创建 Python 扩展需要许多设计决策。根据我使用 Bed-Reader 的经验，以下是我的使用规则。 </p>\n<p>规则 1：创建一个包含 Rust 和 Python 项目的单独存储库</p>\n<p>下表显示了如何布局文件：</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\d1a031ce7776e00ec530ec753d72a2fa.png\"/></p>\n<p>使用 Rust 常用的‘cargo new’命令创建 Cargo.toml 和 src/lib.rs 文件。Python 没有 setup.py 文件。相反，Cargo.toml 包含 PyPi 包信息，例如包的名称、版本号、 README 文件的位置等。要在没有 setup.py 的情况下工作，pyproject.toml 必须包含：</p>\n<pre><code>[build-system]</code>\n<code>requires = [\"maturin==0.12.5\"]</code>\n<code>build-backend = \"maturin\"</code>\n</pre>\n<p>一般来说，Python 设置在 pyproject.toml 中（如果不是，则在 pytest.ini 等文件中）。Python 代码位于子文件夹 bed_reader 中。</p>\n<p>最后，我们使用 GitHub 操作来构建、测试和准备部署。该脚本位于 .github/workflows/ci.yml 中。</p>\n<p>规则 2：使用 maturin &amp; PyO3 <strong>在 Rust 中</strong></p>\n<p>创建 Python-callable translator 函数</p>\n<p>Maturin 是一个 PyPi 包，可通过 PyO3 构建和发布 Python 扩展。PyO3 是一个 Rust crate，用于在 Rust 中编写 Python 扩展。</p>\n<p>在 Cargo.toml 中，包含这些 Rust 依赖项：</p>\n<pre><code>[dependencies]</code>\n<code>thiserror = \"1.0.30\"</code>\n<code>ndarray-npy = { version = \"0.8.1\", default-features = false }</code>\n<code>rayon = \"1.5.1\"</code>\n<code>numpy = \"0.15.0\"</code>\n<code>ndarray = { version = \"0.15.4\", features = [\"approx\", \"rayon\"] }</code>\n<code>pyo3 = { version = \"0.15.1\", features = [\"extension-module\"] }</code>\n<code>[dev-dependencies]</code>\n<code>temp_testdir = \"0.2.3\"</code>\n</pre>\n<p>在 src/lib.rs 底部，包含这两行：</p>\n<pre><code>mod python_module;</code>\n<code>mod tests;</code>\n</pre>\n<p>规则 3：Rust translator 函数</p>\n<p>调用 nice Rust 函数</p>\n<p>在 src/lib.rs 定义了 nice  Rust 函数，这些函数将完成包的核心工作。 它们能够输入和输出标准 Rust 类型并尝试遵循 Rust 最佳实践。例如，对于 Bed-Reader 包， read_no_alloc 是一个 nice Rust 函数，用于从 PLINK Bed 文件读取和返回值。</p>\n<p>然而，Python 不能直接调用这些函数。因此，在文件 src/python_module.rs 中定义 Python 可以调用的 Rust translator 函数，下面为 translator 函数示例：</p>\n<pre><code>#[pyfn(m)]</code>\n<code>#[pyo3(name = \"read_f64\")]</code>\n<code>fn read_f64_py(</code>\n<code>    _py: Python&lt;'_&gt;,</code>\n<code>    filename: &amp;str,</code>\n<code>    iid_count: usize,</code>\n<code>    sid_count: usize,</code>\n<code>    count_a1: bool,</code>\n<code>    iid_index: &amp;PyArray1&lt;usize&gt;,</code>\n<code>    sid_index: &amp;PyArray1&lt;usize&gt;,</code>\n<code>    val: &amp;PyArray2&lt;f64&gt;,</code>\n<code>    num_threads: usize,</code>\n<code>) -&gt; Result&lt;(), PyErr&gt; {<!-- --></code>\n<code>    let iid_index = iid_index.readonly();</code>\n<code>    let sid_index = sid_index.readonly();</code>\n<code>    let mut val = unsafe { val.as_array_mut() };</code>\n<code>    let ii = &amp;iid_index.as_slice()?;</code>\n<code>    let si = &amp;sid_index.as_slice()?;</code>\n<code>    create_pool(num_threads)?.install(|| {<!-- --></code>\n<code>        read_no_alloc(</code>\n<code>            filename,</code>\n<code>            iid_count,</code>\n<code>            sid_count,</code>\n<code>            count_a1,</code>\n<code>            ii,</code>\n<code>            si,</code>\n<code>            f64::NAN,</code>\n<code>            &amp;mut val,</code>\n<code>       )</code>\n<code>    })?;</code>\n<code>   Ok(())</code>\n<code>}</code>\n</pre>\n<p>该函数将文件名、一些与文件大小相关的整数以及两个一维 NumPy 数组作为输入，这些数组指示要读取数据的哪个子集。该函数从文件中读取值并填充 val，这是一个预先分配的二维 NumPy 数组。</p>\n<p>注意</p>\n<p>将 Python NumPy 1-D 数组转换为 Rust slices，通过：</p>\n<pre><code>let iid_index = iid_index.readonly();</code>\n<code>let ii = &amp;iid_index.as_slice()?;</code>\n</pre>\n<p>将 Python NumPy 2d 数组转换为 2-D Rust ndarray 对象，通过：</p>\n<pre>let mut val = unsafe { val.as_array_mut() };</pre>\n<p>调用 read_no_alloc，这是 src/lib.rs 中一个 nice Rust 函数，它将完成核心工作。</p>\n<p>规则 4：在 Python 中预分配内存</p>\n<p>在 Python 中为结果预分配内存简化了 Rust 代码。在 Python 端，在 bed_reader/_open_bed.py 中，我们可以导入 Rust translator 函数：</p>\n<pre>from .bed_reader import [...] read_f64 [...]</pre>\n<p>然后定义一个 nice Python 函数来分配内存、调用 Rust translator 函数并返回结果。</p>\n<pre><code>def read([...]):</code>\n<code>    [...]</code>\n<code>    val = np.zeros((len(iid_index), len(sid_index)), order=order, dtype=dtype)</code>\n<code>    [...]</code>\n<code>    reader = read_f64</code>\n<code>    [...]</code>\n<code>    reader(</code>\n<code>        str(self.filepath),</code>\n<code>        iid_count=self.iid_count,</code>\n<code>        sid_count=self.sid_count,</code>\n<code>        count_a1=self.count_A1,</code>\n<code>        iid_index=iid_index,</code>\n<code>        sid_index=sid_index,</code>\n<code>        val=val,</code>\n<code>        num_threads=num_threads,</code>\n<code>    )</code>\n<code>    [...]</code>\n<code>    return val</code>\n</pre>\n<p>规则 5：将 nice Rust 错误处理翻译 nice Python 错误处理</p>\n<p>为了了解如何处理错误，让我们在 read_no_alloc（ src/lib.rs 中 nice Rust 函数）中跟踪两个可能的错误。</p>\n<p>示例错误 1：来自标准函数的错误。如果 Rust 的标准 File::open 函数找不到文件或无法打开文件， 在这种情况下，如下一行中的? 将导致函数返回一些 std::io::Error 值。 </p>\n<pre>let mut buf_reader = BufReader::new(File::open(filename)?);</pre>\n<p>为了定义一个可返回这些值的函数，我们可以给函数一个返回类型 Result&lt;(), BedErrorPlus&gt;。我们定义 BedErrorPlus 时要包含所有 std::io::Error，如下所示：</p>\n<pre><code>use thiserror::Error;</code>\n<code>...</code>\n<code>/// BedErrorPlus enumerates all possible errors</code>\n<code>/// returned by this library.</code>\n<code>/// Based on https://nick.groenen.me/posts/rust-error-handling/#the-library-error-type</code>\n<code>#[derive(Error, Debug)]</code>\n<code>pub enum BedErrorPlus {<!-- --></code>\n<code>    #[error(transparent)]</code>\n<code>    IOError(#[from] std::io::Error),</code>\n<code>    #[error(transparent)]</code>\n<code>    BedError(#[from] BedError),</code>\n<code>    #[error(transparent)]</code>\n<code>    ThreadPoolError(#[from] ThreadPoolBuildError),</code>\n<code>}</code>\n</pre>\n<p>这是 nice Rust 错误处理，但 Python 不理解它。因此，在 src/python_module.rs 中，我们要进行翻译。首先， <strong>定义 translator 函数 read_f64_py 来返回 PyErr</strong> ；其次，实现了一个从 BedErrorPlus 到 PyErr 的转换器。转换器使用正确的错误消息创建正确的 Python 错误类（IOError、ValueError 或 IndexError）。如下所示：</p>\n<pre><code>impl std::convert::From&lt;BedErrorPlus&gt; for PyErr {<!-- --></code>\n<code>   fn from(err: BedErrorPlus) -&gt; PyErr {<!-- --></code>\n<code>        match err {<!-- --></code>\n<code>            BedErrorPlus::IOError(_) =&gt; PyIOError::new_err(err.to_string()),</code>\n<code>            BedErrorPlus::ThreadPoolError(_) =&gt; PyValueError::new_err(err.to_string()),</code>\n<code>            BedErrorPlus::BedError(BedError::IidIndexTooBig(_))</code>\n<code>            | BedErrorPlus::BedError(BedError::SidIndexTooBig(_))</code>\n<code>            | BedErrorPlus::BedError(BedError::IndexMismatch(_, _, _, _))</code>\n<code>            | BedErrorPlus::BedError(BedError::IndexesTooBigForFiles(_, _))</code>\n<code>            | BedErrorPlus::BedError(BedError::SubsetMismatch(_, _, _, _)) =&gt; {<!-- --></code>\n<code>                PyIndexError::new_err(err.to_string())</code>\n<code>            }</code>\n<code>            _ =&gt; PyValueError::new_err(err.to_string()),</code>\n<code>        }</code>\n<code>    }</code>\n<code>}</code>\n</pre>\n<p>示例错误 2：特定于函数的错误。如果 nice 函数 read_no_alloc 可以打开文件，但随后意识到文件格式错误怎么办？它应该引发一个自定义错误，如下所示：</p>\n<pre><code>if (BED_FILE_MAGIC1 != bytes_vector[0]) || (BED_FILE_MAGIC2 != bytes_vector[1]) {<!-- --></code>\n<code>    return Err(BedError::IllFormed(filename.to_string()).into());</code>\n<code>}</code>\n</pre>\n<p>BedError::IllFormed 类型的自定义错误在 src/lib.rs 中定义：</p>\n<pre><code>use thiserror::Error;</code>\n<code>[...]</code>\n<code>// https://docs.rs/thiserror/1.0.23/thiserror/</code>\n<code>#[derive(Error, Debug, Clone)]</code>\n<code>pub enum BedError {<!-- --></code>\n<code>   #[error(\"Ill-formed BED file. BED file header is incorrect or length is wrong.'{0}'\")]</code>\n<code>   IllFormed(String),</code>\n<code>[...]</code>\n<code>}</code>\n</pre>\n<p>其余的错误处理与示例错误 1 中的相同。</p>\n<p>最后，对于 Rust 和 Python，标准错误和自定义错误的结果都属于带有信息性错误消息的特定错误类型。</p>\n<p>规则 6：多线程与 Rayon 和 ndarray::parallel，返回任何错误</p>\n<p>Rust Rayon crate 提供了简单且轻量级的数据并行多线程。ndarray::parallel 模块将 Rayon 应用于数组。通常的模式是跨一个或多个 2D 数组的列（或行）并行化。面对的一个挑战是从并行线程返回任何错误消息。我将重点介绍两种通过错误处理并行化数组操作的方法。以下两个示例都出现在 Bed-Reader 的 src/lib.rs 文件中。</p>\n<p>方法 1：par_bridge().try_for_each</p>\n<p>Rayon 的 par_bridge 将顺序迭代器变成了并行迭代器。如果遇到错误，使用 try_for_each 方法可以尽快停止所有处理。</p>\n<p>这个例子中，我们遍历了压缩（zip）在一起的两个 things：</p>\n<ul><li> <p>DNA 位置的二进制数据；</p> </li><li> <p>输出数组的列。</p> </li></ul>\n<p>然后，按顺序读取二进制数据，但并行处理每一列的数据。我们停止了任何错误。</p>\n<pre><code>[... not shown, read bytes for DNA location's data ...]</code>\n<code>// Zip in the column of the output array</code>\n<code>.zip(out_val.axis_iter_mut(nd::Axis(1)))</code>\n<code>// In parallel, decompress the iid info and put it in its column</code>\n<code>.par_bridge() // This seems faster that parallel zip</code>\n<code>.try_for_each(|(bytes_vector_result, mut col)| {<!-- --></code>\n<code>    match bytes_vector_result {<!-- --></code>\n<code>        Err(e) =&gt; Err(e),</code>\n<code>        Ok(bytes_vector) =&gt; {<!-- --></code>\n<code>           for out_iid_i in 0..out_iid_count {<!-- --></code>\n<code>              let in_iid_i = iid_index[out_iid_i];</code>\n<code>              let i_div_4 = in_iid_i / 4;</code>\n<code>              let i_mod_4 = in_iid_i % 4;</code>\n<code>              let genotype_byte: u8 = (bytes_vector[i_div_4] &gt;&gt; (i_mod_4 * 2)) &amp; 0x03;</code>\n<code>              col[out_iid_i] = from_two_bits_to_value[genotype_byte as usize];</code>\n<code>            }</code>\n<code>            Ok(())</code>\n<code>         }</code>\n<code>      }</code>\n<code>})?;</code>\n</pre>\n<p>方法 2：par_azip!</p>\n<p>ndarray 包的 par_azip！宏允许并行地通过一个或多个压缩在一起的数组或数组片段。在我看来，这非常具有可读性。但是，它不直接支持错误处理。因此，我们可以通过将任何错误保存到结果列表来添加错误处理。</p>\n<p>下面是一个效用函数的例子。完整的效用函数从三个计数和总和（count and sum）数组计算统计量（均值和方差），并且并行工作。如果在数据中发现错误，则将该错误记录在结果列表中。在完成所有处理之后，检查结果列表是否有错误。</p>\n<pre><code>[...]</code>\n<code>let mut result_list: Vec&lt;Result&lt;(), BedError&gt;&gt; = vec![Ok(()); sid_count];</code>\n<code>nd::par_azip!((mut stats_row in stats.axis_iter_mut(nd::Axis(0)),</code>\n<code>     &amp;n_observed in &amp;n_observed_array,</code>\n<code>     &amp;sum_s in &amp;sum_s_array,</code>\n<code>     &amp;sum2_s in &amp;sum2_s_array,</code>\n<code>     result_ptr in &amp;mut result_list)</code>\n<code>{<!-- --></code>\n<code>  [...some code not shown...]</code>\n<code>});</code>\n<code>// Check the result list for errors</code>\n<code>result_list.par_iter().try_for_each(|x| (*x).clone())?;</code>\n<code>[...]</code>\n</pre>\n<p>Rayon 和 ndarray::parallel 提供了许多其他不错的数据并行处理方法。</p>\n<p>规则 7：允许用户控制并行线程数</p>\n<p>为了更好地使用用户的其他代码，用户必须能够控制每个函数可以使用的并行线程数。</p>\n<p>在下面这个 nice Python read 函数中，用户可以得到一个可选的 num_threadsargument。如果用户没有设置它，Python 会通过这个函数设置它：</p>\n<pre><code>def get_num_threads(num_threads=None):</code>\n<code>    if num_threads is not None:</code>\n<code>        return num_threads</code>\n<code>    if \"PST_NUM_THREADS\" in os.environ:</code>\n<code>        return int(os.environ[\"PST_NUM_THREADS\"])</code>\n<code>    if \"NUM_THREADS\" in os.environ:</code>\n<code>        return int(os.environ[\"NUM_THREADS\"])</code>\n<code>    if \"MKL_NUM_THREADS\" in os.environ:</code>\n<code>        return int(os.environ[\"MKL_NUM_THREADS\"])</code>\n<code>    return multiprocessing.cpu_count()</code>\n</pre>\n<p>接着在 Rust 端，我们可以定义 create_pool。这个辅助函数从 num_threads 构造一个 Rayon ThreadPool 对象。</p>\n<pre><code>pub fn create_pool(num_threads: usize) -&gt; Result&lt;rayon::ThreadPool, BedErrorPlus&gt; {<!-- --></code>\n<code>   match rayon::ThreadPoolBuilder::new()</code>\n<code>      .num_threads(num_threads)</code>\n<code>      .build()</code>\n<code>   {<!-- --></code>\n<code>      Err(e) =&gt; Err(e.into()),</code>\n<code>      Ok(pool) =&gt; Ok(pool),</code>\n<code>   }</code>\n<code>}</code>\n</pre>\n<p>最后，在 Rust translator 函数 read_f64_py 中，我们从 create_pool(num_threads)?.install(...) 内部调用 read_no_alloc（很好的 Rust 函数）。这将所有 Rayon 函数限制为我们设置的 num_threads。</p>\n<pre><code>[...]</code>\n<code>    create_pool(num_threads)?.install(|| {<!-- --></code>\n<code>        read_no_alloc(</code>\n<code>            filename,</code>\n<code>            [...]</code>\n<code>        )</code>\n<code>     })?;</code>\n<code>[...]</code>\n</pre>\n<p>规则 8：将 nice 动态类型 Python 函数翻译成 nice Rust 泛型函数</p>\n<p>nice Python read 函数的用户可以指定返回的 NumPy 数组的 dtype（int8、float32 或 float64）。从这个选择中，该函数查找适当的 Rust translator 函数（read_i8(_py)、read_f32(_py) 或 read_f64(_py)），然后调用该函数。</p>\n<pre><code>def read(</code>\n<code>    [...]</code>\n<code>    dtype: Optional[Union[type, str]] = \"float32\",</code>\n<code>    [...]</code>\n<code>    )</code>\n<code>    [...]</code>\n<code>    if dtype == np.int8:</code>\n<code>        reader = read_i8</code>\n<code>    elif dtype == np.float64:</code>\n<code>        reader = read_f64</code>\n<code>    elif dtype == np.float32:</code>\n<code>        reader = read_f32</code>\n<code>    else:</code>\n<code>        raise ValueError(</code>\n<code>          f\"dtype'{val.dtype}'not known, only\"</code>\n<code>          + \"'int8', 'float32', and 'float64' are allowed.\"</code>\n<code>        )</code>\n<code>     reader(</code>\n<code>       str(self.filepath),</code>\n<code>       [...]</code>\n<code>     )</code>\n</pre>\n<p>三个 Rust translator 函数调用相同的 Rust 函数，即在 src/lib.rs 中定义的 read_no_alloc。以下是 translator 函数 read_64 (又称 read_64_py) 的相关部分：</p>\n<pre><code>#[pyfn(m)]</code>\n<code>#[pyo3(name = \"read_f64\")]</code>\n<code>fn read_f64_py(</code>\n<code>    [...]</code>\n<code>    val: &amp;PyArray2&lt;f64&gt;,</code>\n<code>    num_threads: usize,</code>\n<code> ) -&gt; Result&lt;(), PyErr&gt; {<!-- --></code>\n<code>    [...]</code>\n<code>    let mut val = unsafe { val.as_array_mut() };</code>\n<code>    [...]</code>\n<code>    read_no_alloc(</code>\n<code>        [...]</code>\n<code>        f64::NAN,</code>\n<code>        &amp;mut val,</code>\n<code>     )</code>\n<code>     [...]</code>\n<code>}</code>\n</pre>\n<p>我们在 src/lib.rs 中定义了 niceread_no_alloc 函数。也就是说，该函数适用于具有正确特征的任何类型的 TOut 。其代码的相关部分如下所示：</p>\n<pre><code>fn read_no_alloc&lt;TOut: Copy + Default + From&lt;i8&gt; + Debug + Sync + Send&gt;(</code>\n<code>    filename: &amp;str,</code>\n<code>    [...]</code>\n<code>    missing_value: TOut,</code>\n<code>    val: &amp;mut nd::ArrayViewMut2&lt;'_, TOut&gt;,</code>\n<code>) -&gt; Result&lt;(), BedErrorPlus&gt; {<!-- --></code>\n<code>[...]</code>\n<code>}</code>\n</pre>\n<p>在 nice Python、translator Rust 和 nice Rust 中组织代码，可以让我们为 Python 用户提供动态类型的代码，同时仍能用 Rust 编写出漂亮的通用代码。</p>\n<p>规则 9：创建 Rust 和 Python 测试</p>\n<p>你可能只想编写会调用 Rust 的 Python 测试。但是，你还应该编写 Rust 测试。添加 Rust 测试使你可以交互地运行测试和交互地调试。Rust 测试还为你以后得到 Rust 版本的包提供了途径。在示例项目中，两组测试都从  bed_reader/tests/data 读取测试文件。</p>\n<p>在可行的情况下，我还建议编写函数的纯 Python 版本，然后就可以使用这些慢速 Python 函数来测试快速 Rust 函数的结果。</p>\n<p>最后，关于 CI 脚本，例如 bed-reader/ci.yml，应该同时运行 Rust 和 Python 测试。</p>\n<p><em>原文链接：https://towardsdatascience.com/nine-rules-for-writing-python-extensions-in-rust-d35ea3a4ec29</em></p>\n</div>\n</div>"}