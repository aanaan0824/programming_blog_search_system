{"blogid": "124072787", "writerAge": "码龄2年", "writerBlogNum": "13", "writerCollect": "23", "writerComment": "0", "writerFan": "5", "writerGrade": "2级", "writerIntegral": "142", "writerName": "买Lemon也用劵", "writerProfileAdress": "writer_image\\profile_124072787.jpg", "writerRankTotal": "85876", "writerRankWeekly": "976863", "writerThumb": "10", "writerVisitNum": "29598", "blog_read_count": "8303", "blog_time": "已于 2022-05-21 20:19:43 修改", "blog_title": "浅谈SQL注入的四种防御方法", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-light\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p>最近了解到安全公司的面试中都问到了很多关于SQL注入的一些原理和注入类型的问题，甚至是SQL注入的防御方法。SQL注入真的算是web漏洞中的元老了，著名且危害性极大。下面这里就简单的分享一下我总结的四种SQL注入防御手段，加深理解，方便下次遇到这种问题时可以直接拿来使用。(主要是怕面试中脑壳打铁，这种情况太常见了)</p>\n<p>SQL注入占我们渗透学习中极大地一部分，拥有这很重要的地位。随着防御手段的不段深入，市面上存在SQL注入的网站的确少之又少了，但不能说是没有。在我看来，<strong>学习SQL注入的目的并不只是学习针对这种方法，而是一类方法，包括他的思想，思路和奇淫技巧，简单点说就是举一反三</strong>。<strong>学到现在发现好像越向后面学其他漏洞，方法思路都大体一致，比如字符串拼接，构造闭合语句，函数替代等等。</strong></p>\n<p>好了，说了这么多，现在我们步入正题吧！</p>\n<p>我们简单理解<strong>SQL注入就是在人为可以构造参数的地方加入一些非法敏感语句，绕过后端的处理，并带入到数据库中执行，然后返回敏感数据的过程。</strong></p>\n<ol><li> <p><strong>限制数据类型</strong></p> <p>在传入参数的地方限制参数的类型，比如<strong>整型 Integer</strong>，随后加入函数判断，如<strong>is_numeric($_GET[‘id’])</strong> 只有当get到的id为<strong>数字或者数字字符时才能执行下一步</strong>，限制了字字符自然就限制了注入，毕竟构造参数怎么可能不传入字符。但这种方法存在一定的限制，只能在特定的页面才能使用，一般大部分都是要求我们传入的字符串，但可以很大程度限制整型注入的情况。(针对此函数也是有一定绕过手段，比如转为十六进制)</p> </li><li> <p><strong>正则表达式匹配传入参数</strong></p> <p>相信对于正则表达式大家都不陌生了，几乎在过滤比较严格的地方都有正则表达式。(后面我也会写一篇关于使用正则表达式的文章，包括基础的使用和绕过)。这里简单解读一下这段正则表达式：</p> <pre><code class=\"prism language-php\"><span class=\"token variable\">$id</span><span class=\"token operator\">=</span><span class=\"token variable\">$_POST</span><span class=\"token punctuation\">[</span><span class=\"token string single-quoted-string\">'id'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">preg_match</span><span class=\"token punctuation\">(</span><span class=\"token string single-quoted-string\">'/and|select|insert|insert|update|[A-Za-z]|/d+:/i'</span><span class=\"token punctuation\">,</span> <span class=\"token variable\">$id</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span> \n        <span class=\"token keyword\">die</span><span class=\"token punctuation\">(</span><span class=\"token string single-quoted-string\">'stop hacking!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token keyword\">echo</span> <span class=\"token string single-quoted-string\">'good'</span><span class=\"token punctuation\">;</span> \n    <span class=\"token punctuation\">}</span>\n</code></pre> <pre><code class=\"prism language-typescript\"><span class=\"token function\">preg_match</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> 函数匹配传入的id值，\n<span class=\"token operator\">/</span> 作为正则的起始标识符\n<span class=\"token operator\">|</span> 代表或\n<span class=\"token punctuation\">[</span><span class=\"token constant\">A</span><span class=\"token operator\">-</span>Za<span class=\"token operator\">-</span>z<span class=\"token punctuation\">]</span> 表示匹配参数中是否存在大小写的<span class=\"token number\">26</span>个字符\n<span class=\"token operator\">/</span>d 匹配是否存在数字\n<span class=\"token operator\">+</span>匹配一次或多次\n<span class=\"token operator\">/</span>i 不区分大小写\n</code></pre> <p>像下面这句：<br/> ?id=1’ union select 1,2# 因为匹配到union select，输出 stop hacking!<br/> 正则表达式也具有一定危险性，在SQL注入绕过waf中谈到过，<strong>正则表达式匹配非常消耗性能</strong>，因此攻击时可以构造大量的正常语句‘骗’过服务器，当后台对数据的处理达到最大限制时就会放弃匹配后面我们构造的非法语句，从而略过这个数据包。</p> </li><li> <p><strong>函数过滤转义</strong></p> <p>在php中最基本的就是自带的<strong>magic_quotes_gpc</strong>函数，用于处理 ’ \" 符号加上/ 防止转义, 比如：</p> <pre><code class=\"prism language-php\"> <span class=\"token operator\">?</span>id<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token string single-quoted-string\">' and 1=1#  ===&gt; ?id=1/'</span> <span class=\"token keyword\">and</span> <span class=\"token number\">1</span><span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token comment\">#</span>\n</code></pre> <p>另外还有<strong>addslashes</strong>(),也具有相同的效果。</p> <p>像前面提到的**preg_match()**函数结合正则表达式或者黑名单也具有预防效果。</p> <p>小tips：<strong>默认情况下，PHP 指令 magic_quotes_gpc 为 on，对所有的 GET、POST 和 COOKIE 数据自动运行 addslashes()。不要对已经被 magic_quotes_gpc 转义过的字符串使用 addslashes()，因为这样会导致双层转义。遇到这种情况时可以使用函数 get_magic_quotes_gpc() 进行检测。</strong></p>\n<ul><li><strong>mysql_escape_string($string)</strong>：用反斜杠转义字符串中的特殊字符，用于mysql_query()查询。</li><li><strong>mysql_real_escape_string()</strong> 函数转义 SQL 语句中使用的字符串中的特殊字符。<br/> 转义的符号包括 \\x00 \\n \\r \\ ’ \" \\x1a</li></ul> </li><li> <p><strong>预编译语句</strong></p> <p>预编译语句对现在的程序员来说基本都会去设计使用的方法，保障数据库的安全。一般来说，防御<strong>SQL注入的最佳方式就是使用预编译语句，绑定变量</strong>。</p> <pre><code class=\"prism language-php\"><span class=\"token keyword type-declaration\">String</span> query<span class=\"token operator\">=</span><span class=\"token string double-quoted-string\">\"select password from users where username='?' \"</span><span class=\"token punctuation\">;</span>\n</code></pre> <p>下面讲一下什么叫预编译：<strong>使用预编译相当于是将数据于代码分离的方式，把传入的参数绑定为一个变量，用？表示，攻击者无法改变SQL的结构</strong>，在这个例子中，即使攻击者插入类似 admin’ or 1=1# 的字符串，如果不做处理直接带入查询，那么query则变成了</p> <pre><code class=\"prism language-php\">query<span class=\"token operator\">=</span><span class=\"token string double-quoted-string\">\"select password from users where username='admin' or 1=1 \"</span><span class=\"token punctuation\">;</span>\n</code></pre> <p>闭合了后面的引号，从而执行了恶意代码。而<strong>预编译则是将传入的 admin’ or 1=1# 当做纯字符串的形式作为username执行，避免了上面说到的SQL语句中的拼接闭合查询语句等过程，可以理解为字符串与sql语句的关系区分开，username此时作为字符串不会被当做之前的SQL语句被带入数据库执行，避免了类似sql语句拼接、闭合等非法操作。就相当于拿着这个字符串去数据库中找有没有这个东西一样。并且使用预编译的SQL语句，SQL语句的语义不会发生改变。</strong></p> <p>下面给个php绑定变量的事例：</p> <pre><code class=\"prism language-php\"><span class=\"token variable\">$query</span><span class=\"token operator\">=</span><span class=\"token string double-quoted-string\">\"INSERT INTO myCity (Name,CountryCode,District) VALUES (?,?,?)\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token variable\">$stmt</span><span class=\"token operator\">=</span><span class=\"token variable\">$mysqli</span><span class=\"token operator\">-&gt;</span><span class=\"token function\">prepare</span><span class=\"token punctuation\">(</span><span class=\"token variable\">$query</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token variable\">$stmt</span><span class=\"token operator\">-&gt;</span><span class=\"token function\">bind_param</span><span class=\"token punctuation\">(</span><span class=\"token string double-quoted-string\">\"sss\"</span><span class=\"token punctuation\">,</span><span class=\"token variable\">$val1</span><span class=\"token punctuation\">,</span><span class=\"token variable\">$val2</span><span class=\"token punctuation\">,</span><span class=\"token variable\">$val3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token variable\">$val1</span><span class=\"token operator\">=</span><span class=\"token string double-quoted-string\">\"Stuttgart\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token variable\">$val2</span><span class=\"token operator\">=</span><span class=\"token string double-quoted-string\">\"DEU\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token variable\">$val3</span><span class=\"token operator\">=</span><span class=\"token string double-quoted-string\">\"Baden\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//execute the statement</span>\n<span class=\"token variable\">$stmt</span><span class=\"token operator\">-&gt;</span><span class=\"token function\">execute</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre> <p>以上谈到的四种方法都是一些基本方法，具体怎么实现防御还要看怎么去设计。<strong>说到预编译语句是最佳方式，并不是说只是使用这一种方法就能够防止SQL注入，而实际上预编译也存在注入绕过的问题，并且也不是所有的地方都能够使用预编译语句。最佳的方式应该是多种方法结合，使用预编译的同时还要加上其他函数过滤，正则匹配等，更多的还有根据实际情况自定义函数确保安全。</strong></p> </li></ol>\n<p>最近在看《白帽子将web安全》这本书，这篇文章很多都是用的里面的知识。书里讲的很好很详细，有深度也有广度。在学习中也有很多疑惑的地方，初入网络安全，希望可以和大家多多交流彼此经验。同时也欢迎各个大佬指正！</p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}