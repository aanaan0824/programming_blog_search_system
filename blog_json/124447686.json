{"blogid": "124447686", "writerAge": "码龄5年", "writerBlogNum": "10", "writerCollect": "9", "writerComment": "0", "writerFan": "0", "writerGrade": "2级", "writerIntegral": "106", "writerName": "LoveLittleMango", "writerProfileAdress": "writer_image\\profile_124447686.jpg", "writerRankTotal": "137454", "writerRankWeekly": "998729", "writerThumb": "2", "writerVisitNum": "5346", "blog_read_count": "2243", "blog_time": "于 2022-04-27 17:18:05 发布", "blog_title": "std::mutex和std::lock_guard", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p style=\"margin-left:.0001pt;text-align:justify;\">std::mutex是互斥锁，它是一种可锁定的对象，它被设计用来在关键代码段需要<span style=\"background-color:#ffff00;\">独占访问</span>时发出信号，防止具有相同保护的其他<span style=\"background-color:#ffff00;\">线程并发执行</span>并<span style=\"background-color:#ffff00;\">访问相同的内存位置</span>。互斥对象提供独占性，不支持递归性(也就是说，一个线程不应该锁定它已经拥有的互斥对象，否则会导致死锁)。  </p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"> 构造函数：仅支持默认构造函数，不支持拷贝和移动构造函数。完成构造后，处于unlock状态。<span style=\"background-color:#f7f8fa;\"><span style=\"color:#4a90e2;\">互斥锁的构造本身不是原子的</span></span><span style=\"background-color:#f7f8fa;\"><span style=\"color:#4a90e2;\">:</span></span><span style=\"background-color:#f7f8fa;\"><span style=\"color:#4a90e2;\">在构造时访问对象可能会引发数据竞争。</span></span>  </p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">lock()：调用线程锁住互斥对象，必要时阻塞，<span style=\"background-color:#f7f8fa;\"><span style=\"color:#4a90e2;\">互斥对象被作为原子操作访问</span></span><span style=\"background-color:#f7f8fa;\"><span style=\"color:#4a90e2;\">/</span></span><span style=\"background-color:#f7f8fa;\"><span style=\"color:#4a90e2;\">修改</span></span><span style=\"background-color:#f7f8fa;\"><span style=\"color:#4a90e2;\">(</span></span><span style=\"background-color:#f7f8fa;\"><span style=\"color:#4a90e2;\">不会导致数据竞争</span></span><span style=\"background-color:#f7f8fa;\"><span style=\"color:#4a90e2;\">)</span></span><span style=\"background-color:#f7f8fa;\"><span style=\"color:#4a90e2;\">。</span></span>  :</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">如果互斥锁当前没有被任何线程锁住，调用线程将锁住它(从这一点开始，直到unlock()被调用，线程拥有互斥锁)。  </p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">如果互斥锁当前被另一个线程锁定，调用线程的执行将被阻塞，直到另一个线程执行unlock()(其他非锁定线程继续执行)。  </p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">如果互斥对象当前被调用此函数的同一线程锁定，则会产生死锁(行为未定义)。</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">互斥锁上的所有锁定和解锁操作都遵循一个总的顺序，在同一对象上的锁定操作和之前的解锁操作之间，所有可见的效果都是同步的。  </p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">trylock(): 如果没有锁定，则锁定互斥对象，功能和lock()类似，只是在trylock()失败时会返回false，同时调用线程不会被阻塞。</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">如果没有std::mutext mtx的锁定保护，那么*和$的输出不能保证是一次性全输出，大概率会出现交叉现象。</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;thread&gt;\n#include &lt;mutex&gt;\n\nstd::mutex mtx;\n\nvoid print_block(int n, char c){\n\tmtx.lock();\n    for(int i=0; i&lt;n; ++i){\n        std::cout &lt;&lt; c;\n    }\n    std::cout &lt;&lt;'\\n';\n\tmtx.unlock();\n}\n\nint main(){\n    std::thread th1(print_block, 500,'*');\n\tstd::thread th2(print_block, 500,'$');\n\t\n\tth1.join();\n\tth2.join();\n\treturn 0;\n}</code></pre>\n<p>std::lock_guard是锁保护器，它通过保持互斥对象始终处于锁定状态来管理互斥对象。在构造时，互斥对象被调用线程锁定，而在销毁时，互斥对象被解锁。 它是最简单的锁，特别适用于具有自动持续时间(duration)的对象，该对象持续到上下文结束。 通过这种方式，它保证在<span style=\"color:#fe2c24;\">抛出异常时</span>正确地解锁互斥对象。注意，lock_guard对象不以任何方式管理互斥对象的生存期:互斥对象的生存期至少要延长到锁它的lock_guard被销毁。</p>\n<p>下面的代码段如果用mtx.lock()替换std::lock_guard&lt;std::mutex&gt; lck(mtx);的话，会在抛出异常后因为不能执行unlock()操作而死锁。</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;thread&gt;\n#include &lt;mutex&gt;\n#include &lt;stdexcept&gt;\n\n\nstd::mutex mtx;\n\nvoid print_even(int x){\n\tstd::lock_guard&lt;std::mutex&gt; lck(mtx);\n\tif(x%2==0){\n\t\tstd::cout &lt;&lt; x &lt;&lt; \" is even\\n\";\n\t}else{\n\t\tthrow (std::logic_error(\"not even\"));\n\t}\n}\n\nvoid print_thread_id(int id) {\n\ttry{\n\t\t\tprint_even(id);\n\t}\n\tcatch (std::logic_error&amp;) {\n\t\tstd::cout &lt;&lt; \"[exception caught]\\n\";\n\t}\n}\n\nint main(){\n    std::thread threads[10];\n\t\n\tfor(int i=0; i&lt;10; ++i)\n\t\tthreads[i] = std::thread(print_thread_id, i+1);\n\t\n\tfor(auto&amp; th : threads) th.join();\n\treturn 0;\n}</code></pre>\n<p>参考</p>\n<p><a class=\"has-card\" href=\"https://www.cplusplus.com/reference/mutex/lock_guard/\" title=\"lock_guard - C++ Reference\"><span class=\"link-card-box\"><span class=\"link-title\">lock_guard - C++ Reference</span><span class=\"link-link\"><img alt=\"\" class=\"link-link-icon\" src=\"https://www.cplusplus.com/favicon.ico\"/>https://www.cplusplus.com/reference/mutex/lock_guard/</span></span></a><a class=\"has-card\" href=\"https://www.cplusplus.com/reference/mutex/mutex/\" title=\"mutex - C++ Reference\"><span class=\"link-card-box\"><span class=\"link-title\">mutex - C++ Reference</span><span class=\"link-link\"><img alt=\"\" class=\"link-link-icon\" src=\"https://www.cplusplus.com/favicon.ico\"/>https://www.cplusplus.com/reference/mutex/mutex/</span></span></a></p>\n</div>\n</div>"}