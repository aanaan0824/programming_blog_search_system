{"blogid": "125549934", "writerAge": "码龄17年", "writerBlogNum": "40", "writerCollect": "29", "writerComment": "12", "writerFan": "24", "writerGrade": "3级", "writerIntegral": "448", "writerName": "萤火架构", "writerProfileAdress": "writer_image\\profile_125549934.jpg", "writerRankTotal": "43203", "writerRankWeekly": "89522", "writerThumb": "7", "writerVisitNum": "21010", "blog_read_count": "1077", "blog_time": "于 2022-06-30 23:04:31 发布", "blog_title": "C#生成putty格式的ppk文件（支持passphrase）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h2 id=\"背景\">背景</h2>\n<p>2022国家级护网行动即将开启，根据阿里云给出的安全建议，需要将登陆Linux的方式改为密钥对方式。我这里使用的远程工具是自己开发的，能够同时管理Windows和Linux，但是以前不支持密钥对的登陆方式，所以需要改造一下。</p>\n<p><strong>护网行动是什么？</strong>护网行动从2016年开始，是一场由公安部组织的网络安全攻防演练，目的是针对全国范围的真实网络目标为对象的实战攻防活动，旨在发现、暴露和解决安全问题，检验我国各大企事业单位、部属机关的网络安全防护水平和应急处置能力。护网行动每年举办一次，为期2-3周。</p>\n<p><strong>我使用的远程工具 RDManager：</strong><a href=\"https://blog.bossma.cn/tools/new-version-of-rdmanager-replace-poderosa-with-putty/\" title=\"https://blog.bossma.cn/tools/new-version-of-rdmanager-replace-poderosa-with-putty/\">https://blog.bossma.cn/tools/new-version-of-rdmanager-replace-poderosa-with-putty/</a>，这个工具访问Linux使用了putty，putty的密钥对登陆方式使用的是自有格式的ppk文件，但是阿里云上下载的是pem格式的密钥文件，所以需要将pem格式转换为ppk格式。</p>\n<h2 id=\"思路\">思路</h2>\n<p>putty本身提供了一个工具，可以将其他格式的密钥文件转换为自有的ppk文件，这个工具的名字是puttygen。在linux上可以通过命令进行转换，在Windows上则必须使用GUI工具手动操作，这多有不便。我期望的是能通过编程的方式进行这个转换，这样只需要在RDManger中上传pem文件，就可以自动转换为putty的ppk格式的文件，不需要再去使用puttygen。</p>\n<p>首先查了下有没有现成的轮子，经过多次寻找，在Github上找到了一个项目：pem2ppk (<a href=\"https://github.com/akira345/pem2ppk\" title=\"https://github.com/akira345/pem2ppk\">https://github.com/akira345/pem2ppk</a>)，这个项目看名字就知道很贴合我的需求，它的主要功能就是读取pem文件，然后输出为ppk文件。我最终的解决方案主体也是从此而来。不过这个程序有两个问题：</p>\n<ul><li>1、不是所有的pem文件都能转换成功，网上也是有人说成功了，有人说不行。</li><li>2、不支持对密钥进行加密，别人拿走了这个ppk文件就可以直接使用。puttygen是有这个功能的。</li></ul>\n<p>除此之外，很难再找到比较贴合需求的资料了。怎么办？其实这个Github项目的很大一部分代码来源于另一篇文章：<a href=\"https://antonymale.co.uk/generating-putty-key-files.html\" title=\"https://antonymale.co.uk/generating-putty-key-files.html\">https://antonymale.co.uk/generating-putty-key-files.html</a>，作者提到可以去看putty的源码。</p>\n<p>受此启发，我也可以去看putty的源码，然后将相关处理翻译为C#的实现，这样应该是可以解决问题的。</p>\n<h2 id=\"实现\">实现</h2>\n<p>putty的源码官网上就可以下载到，不过我看的是一个几年前的版本：<a href=\"https://github.com/KasperDeng/putty\" title=\"https://github.com/KasperDeng/putty\">https://github.com/KasperDeng/putty</a>，这个版本和新版本的主要逻辑都是一样的，搞懂C语言的若干函数和数据类型就很容易理解，而且旧版本更原始，没有那么多的抽象，反而更容易理解。</p>\n<h3 id=\"输出ppk内容不正确的问题\">输出ppk内容不正确的问题</h3>\n<p>这个问题主要是由于填充(padding)使用不当造成的，pem2ppk项目在输出密钥的各个属性时都使用了前置填充，而putty并不是固定的都加了填充。</p>\n<p>看putty的代码实现：<a href=\"https://github.com/KasperDeng/putty/blob/037a4ccb6e731fafc4cc77c0d16f80552fd69dce/putty-src/sshrsa.c#L654\" title=\"https://github.com/KasperDeng/putty/blob/037a4ccb6e731fafc4cc77c0d16f80552fd69dce/putty-src/sshrsa.c#L654\">https://github.com/KasperDeng/putty/blob/037a4ccb6e731fafc4cc77c0d16f80552fd69dce/putty-src/sshrsa.c#L654</a></p>\n<pre><code>    dlen = (bignum_bitcount(rsa-&gt;private_exponent) + 8) / 8;\n    plen = (bignum_bitcount(rsa-&gt;p) + 8) / 8;\n    qlen = (bignum_bitcount(rsa-&gt;q) + 8) / 8;\n    ulen = (bignum_bitcount(rsa-&gt;iqmp) + 8) / 8;\n    bloblen = 16 + dlen + plen + qlen + ulen;</code></pre>\n<p>这段代码是计算密钥的各个属性的值的字节数，然后用于初始化一个大的字节数组，将这些数据写进去。bignum_bitcount是计算值的比特位数，除以8就是得到字节数，为什么还要加8呢？这是因为C语言中除法的结果是向下取整的，比如数学计算结果是1.5，那么C语言中得到的就是1，为了不让任何一个比特丢失，所以这里加了一个8，预留好充足的空间。</p>\n<p>再来看pem2ppk中的实现：<a href=\"https://github.com/akira345/pem2ppk/blob/d2baee08064953280984607d1e4ae1183127e5ad/PEM2PPK/PuttyKeyFileGenerator.cs#L24\" title=\"pem2ppk/PuttyKeyFileGenerator.cs at d2baee08064953280984607d1e4ae1183127e5ad · akira345/pem2ppk · GitHub\">pem2ppk/PuttyKeyFileGenerator.cs at d2baee08064953280984607d1e4ae1183127e5ad · akira345/pem2ppk · GitHub</a></p>\n<pre><code>private const int prefixSize = 4;\nprivate const int paddedPrefixSize = prefixSize + 1;\nbyte[] publicBuffer = new byte[3 + keyType.Length + paddedPrefixSize + keyParameters.Exponent.Length +\n                                           paddedPrefixSize + keyParameters.Modulus.Length + 1];</code></pre>\n<p>这里keyParameters.Exponent和keyParameters.Modulus是公钥的两个属性，可以看到前边加了一个固定的长度paddedPrefixSize，这个paddedPrefixSize=prefixSize + 1，这里边的1就对应putty中的+8逻辑。</p>\n<p>不过固定+1是有问题的，可以想一下C#和C语言在处理这些属性值时的差别。</p>\n<p>在putty中如果数据比特数不能被8整除，那么+8之后再整除就可以得到正确的字节数，否则就会少1个字节；如果数据能被8整除，那么+8就会多1个空的字节，这个多的字节就是padding了。所以能被8整除的时候才会有这个padding。</p>\n<p>在C#中开始处理的时候就已经都是字节了，所以C#中不需要处理位数不能被8整除的问题，但是需要在能被8整除的时候增加一个空字节，C#中如何判断数据的位数能被8整除呢？可以认为数据首byte的最高位是1的时候，比特数就能被8整数，此时最小二进制数是10000000，比它小的数就可以被舍弃掉至少1位。10000000也就是128，因此凡是大于等于这个数的都是能被8整数的，也就是需要padding的。</p>\n<p>所以可以这样判断是否需要增加padding：<a href=\"https://gist.github.com/bosima/ee6630d30b533c7d7b2743a849e9b9d0#file-puttykeyfilegenerator-cs-L190\" title=\"https://gist.github.com/bosima/ee6630d30b533c7d7b2743a849e9b9d0#file-puttykeyfilegenerator-cs-L190\">https://gist.github.com/bosima/ee6630d30b533c7d7b2743a849e9b9d0#file-puttykeyfilegenerator-cs-L190</a></p>\n<pre><code>\tprivate static bool CheckIsNeddPadding(byte[] bytes)\n\t{\n\t\treturn bytes[0] &gt;= 128;\n\t}\n\n\tprivate static int GetPrefixSize(byte[] bytes)\n\t{\n\t\treturn CheckIsNeddPadding(bytes) ? paddedPrefixSize : prefixSize;\n\t}</code></pre>\n<h3 id=\"实现ppk加密\">实现ppk加密</h3>\n<p>pem2ppk项目中没有对key进行加密的实现，网上也没有找到C#的源代码可以实现这个功能。但是这个功能很关键，在RDManager中所有的密码都是加密处理的，这样服务器账号落盘的时候安全性才能有比较好的保障，但是阿里云导出的pem是没有加密的，虽然puttygen也可以给pem加密，但是还不是不能将加密以编程的方式集成到RDManager中。</p>\n<p>解决这个问题的方式还是搬运putty的实现方式，将C语言的实现转换为C#的实现。其中有两个关键的处理：一是要在计算Private-MAC的值时给私钥增加padding，二是使用AES256进行加密处理。至于putty为什么要这样处理，我没有研究，只是照搬过来。</p>\n<p>主要看下AES256加密的处理，有些参数很关键：</p>\n<pre><code>byte[] passKey = new byte[40];\n...\nbyte[] iv = new byte[16];\nbyte[] aesKey = new byte[32];\nBuffer.BlockCopy(passKey, 0, aesKey, 0, 32);\nusing (RijndaelManaged rijalg = new RijndaelManaged())\n{\n\trijalg.BlockSize = 128;\n\trijalg.KeySize = 256;\n\trijalg.Padding = PaddingMode.None;\n\trijalg.Mode = CipherMode.CBC;\n\trijalg.Key = aesKey;\n\trijalg.IV = iv;\n\n\tICryptoTransform encryptor = rijalg.CreateEncryptor(rijalg.Key, rijalg.IV);\n\treturn encryptor.TransformFinalBlock(bytes, 0, bytes.Length);\n}</code></pre>\n<ul><li>iv是长度为16的字节数组，里边都是默认值0。</li><li>aeskey是一个长度为32的字节数组，不过计算的时候准备的是长度为40的字节数组，需要截一下。</li><li>Padding需要设置为PaddingMode.None，默认的不是这个。</li></ul>\n<p>其它就没什么好说的了。来一张RDManger的使用界面：</p>\n<div class=\"img-center\">\n<img alt=\"\" src=\"image\\180fc155c6ad6d6aac6a1f95e18e4cf5.png\"/>\n</div>\n<hr/>\n<p>以上就是本文的主要内容了。</p>\n<p>完整代码在Github，欢迎访问：<a href=\"https://gist.github.com/bosima/ee6630d30b533c7d7b2743a849e9b9d0\" title=\"https://gist.github.com/bosima/ee6630d30b533c7d7b2743a849e9b9d0\">https://gist.github.com/bosima/ee6630d30b533c7d7b2743a849e9b9d0</a></p>\n<p> </p>\n</div>\n</div>"}