{"blogid": "123335283", "writerAge": "码龄3年", "writerBlogNum": "9", "writerCollect": "75", "writerComment": "0", "writerFan": "16", "writerGrade": "1级", "writerIntegral": "79", "writerName": "KingGue", "writerProfileAdress": "writer_image\\profile_123335283.jpg", "writerRankTotal": "146501", "writerRankWeekly": "222818", "writerThumb": "8", "writerVisitNum": "8887", "blog_read_count": "2416", "blog_time": "已于 2022-03-09 21:57:00 修改", "blog_title": "ACM模式下输入输出总结（Java）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h1><strong>1、使用 java.util.Scanner包</strong></h1>\n<ol><li> <h3><code>nextInt()</code>：直至读取到空格或回车之后结束本次的int值；</h3> </li><li> <h3><code>next()</code>：直至读取到空格或回车之后结束本次的String值，不可读取回车；</h3> </li><li> <h3><code>nextLine()</code>：直至读取到换行符（回车）之后结束本次读取的String，可读取回车（空值）</h3> </li></ol>\n<h2>1.1 读取连续整数（两个整数a和b）</h2>\n<pre><code class=\"language-java\">import java.util.Scanner;\npublic class Main{\n    public static void main(String[] args) {\n        Scanner in=new Scanner(System.in);\n        while(in.hasNext()){\n            int a=in.nextInt();\n            int b=in.nextInt();\n            System.out.println(a+b);\n        }\n    }\n}\n</code></pre>\n<p><img alt=\"\" height=\"205\" src=\"image\\4000f79bcd07488aa9efa82ea0257732.png\" width=\"562\"/></p>\n<h2>1.2  读取有限整数</h2>\n<pre><code class=\"language-java\">import java.util.Scanner;\npublic class Main{\n    public static void main(String[] args){\n        Scanner in=new Scanner(System.in);\n        int n=in.nextInt();\n        while(n--&gt;0){\n            int a=in.nextInt();\n            int b=in.nextInt();\n            System.out.println(a+b);\n        }\n    }\n}\n</code></pre>\n<p><img alt=\"\" height=\"218\" src=\"image\\cef12311255d4b6ab348b8080574c423.png\" width=\"804\"/></p>\n<h2>1.3  每行读取空格隔开的整数</h2>\n<pre><code class=\"language-java\">import java.util.Scanner;\nimport java.lang.String;\nimport java.lang.Integer;\npublic class Main{\n    public static void main(String[] args){\n        Scanner in=new Scanner(System.in);\n        while(in.hasNext()){\n            String[] temp=in.nextLine().split(\" \");\n            int sum=0;\n            for(String s:temp)\n                sum+=Integer.valueOf(s);\n            System.out.println(sum);\n        }\n    }\n}\n</code></pre>\n<p><img alt=\"\" height=\"207\" src=\"image\\f6998cc1684f4074aec287b8552ed0a0.png\" width=\"609\"/></p>\n<p></p>\n<h1><strong> 2 使用 <code>BufferedReader</code>和<code>InputStreamReader</code></strong></h1>\n<h2>2.1 整体函数框架</h2>\n<pre><code class=\"language-java\">import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n \npublic class Main {\n    public static void main(String[] args) throws IOException{\n    \t......\n    }\n}</code></pre>\n<h2>2.2.1 输入为一个字符串时</h2>\n<blockquote>\n<p>abcd</p>\n</blockquote>\n<pre><code class=\"language-java\">        // 创建一个BufferedReader对象\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // 读取字符串\n        String line = br.readLine();\n \n        // 测试输入是否正确\n        System.out.println(line);</code></pre>\n<p><img alt=\"\" height=\"172\" src=\"image\\35f6ac53fdab498f863304b02bee3561.png\" width=\"624\"/>  </p>\n<h2>2.2.2 输入为多个数字</h2>\n<blockquote>\n<p>1 2</p>\n</blockquote>\n<pre><code class=\"language-java\">        // 创建一个BufferedReader对象\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // 读取第一行数据\n        String line = br.readLine();\n        // 将字符串根据空格进行分隔\n        String[] strings = line.trim().split(\" \");\n        // 分别将其中的每个数值读出\n        int n = Integer.parseInt(strings[0]);\n        int v = Integer.parseInt(strings[1]);\n \n        // 测试输入是否正确\n        System.out.println(\"n: \" + n + \"\\tv: \" + v);</code></pre>\n<p><img alt=\"\" height=\"220\" src=\"image\\70149f195ae343c8835edc06f330e4f9.png\" width=\"588\"/></p>\n<h2>2.2.3 输入中有一个数组，且有数组的长度</h2>\n<blockquote>\n<p>7<br/> 1 2 3 4 5 6 7</p>\n</blockquote>\n<pre><code class=\"language-java\">        // 创建一个BufferedReader对象\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // 读取第一行数据\n        String line = br.readLine();\n        // 将字符串根据空格进行分隔\n        String[] strings = line.trim().split(\" \");\n        // 分别将其中的每个数值读出\n        int n = Integer.parseInt(strings[0]);\n        int v = Integer.parseInt(strings[1]);\n        // 读取第二行数据\n        line = br.readLine();\n        strings = line.trim().split(\" \");\n        // 创建一个int型的数组用来储存第二行的多个数字\n        int[] nums = new int[n];\n        for (int i = 0; i &lt; n; i ++) {\n            nums[i] = Integer.parseInt(strings[i]);\n        }\n \n        // 测试输入是否正确\n        for (int num: nums) {\n            System.out.print(num + \" \");\n        }</code></pre>\n<p><img alt=\"\" height=\"194\" src=\"image\\91746b7690b24016a308d5631ffd66ce.png\" width=\"575\"/></p>\n<h1>3 各类输入输出构造（题目示例）</h1>\n<h2>3.1 <strong>多行输入（分隔符为空格）</strong></h2>\n<p>题目描述：</p>\n<ul><li>小v今年有n门课，每门都有考试，为了拿到奖学金，小v必须让自己的平均成绩至少为avg。</li><li>每门课由<strong>平时成绩</strong>和<strong>考试成绩</strong>组成，满分为 r。</li><li>在他知道每门课的平时成绩为ai ,若想让这门课的考试成绩多拿一分的话，小v要花bi 的时间复习，不复习的话当然就是0分。</li><li>同时我们显然可以发现复习得再多也不会拿到超过满分的分数。为了拿到奖学金，小v至少要花多少时间复习。<br/>  </li></ul>\n<p>输入描述：</p>\n<ul><li>第一行三个整数 n , r , avg (n大于等于1小于等于1e5，r 大于等于1小于等于1e9,avg大于等于1小于等于1e6)，接下来n行，每行两个整数 ai 和 bi，均小于等于1e6大于等于1</li></ul>\n<p>输入</p>\n<ul><li>5 10 9</li><li>0 5</li><li>9 1</li><li>8 1</li><li>0 1</li><li>9 100</li></ul>\n<pre><code class=\"language-java\">import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        //Scanner类默认的分隔符就是空格\n        Scanner sc=new Scanner(System.in);\n        while(sc.hasNext()){\n            int n=sc.nextInt();\n            int full=sc.nextInt();\n            int avg=sc.nextInt();\n            int[][] nums=new int[n][2];\n            for(int i=0;i&lt;n;i++){\n                nums[i][0]=sc.nextInt();\n                nums[i][1]=sc.nextInt();\n            }\n            //假定不会出现拿不到奖学金的情况\n            if (n==1){\n                System.out.println((avg-nums[0][0])*nums[0][1]);\n                continue;\n            }\n            Arrays.sort(nums, (o1, o2) -&gt; o1[1] - o2[1]); //按复习代价从小到大排序\n            long sum=0;\n            for(int[] a:nums) {\n                sum+=a[0];\n            }\n            long limit=avg*n;\n            int index=0;\n            long time=0;\n            while(sum&lt;limit){\n                int tmp=full-nums[index][0];\n                if(tmp+sum&lt;=limit){                   //如果一门课程复习到满分，小于限制，\n                    time+=tmp*nums[index][1];\n                    sum+=tmp;\n                    index++;\n                }\n                else{                                //如果一门课程复习到满分，大于限制，\n                    time+=(limit-sum)*nums[index][1];\n                    sum=limit;\n                }\n            }\n            // 输出描述:\n            // 一行输出答案。\n            // 输出\n            // 43\n            System.out.println(time);\n        }\n    }\n}</code></pre>\n<h2>3.2 <strong>数组输入（分隔符为空格）</strong></h2>\n<p>题目描述：</p>\n<ul><li> <pre>一条长l的笔直的街道上有n个路灯，若这条街的起点为0，终点为l，第i个路灯坐标为 ai，每盏灯可以覆盖到的最远距离为d，为了照明需求，所有灯的灯光必须覆盖整条街，但是为了省电，要使这个d最小，请找到这个最小的 d。\n</pre> </li><li> <pre>输入描述:每组数据第一行两个整数n和l（n大于0小于等于1000，l小于等于1000000000大于0）。\n第二行有n个整数(均大于等于0小于等于l)，为每盏灯的坐标，多个路灯可以在同一点。\n输入:\n7 15\n15 5 3 7 9 14 0</pre> </li></ul>\n<pre><code class=\"language-java\">import java.util.Arrays;\nimport java.util.Scanner;\npublic class Main {\n    public static void main(String[] args){\n        Scanner sc=new Scanner(System.in);\n        while(sc.hasNext()){\n            int n=sc.nextInt();\n            long l=sc.nextLong();\n            long[] nums=new long[n];\n            for(int i=0;i&lt;n;i++){\n                nums[i]=sc.nextLong();\n            }\n            Arrays.sort(nums);   //升序排序\n            long gap=nums[1]-nums[0];\n            for(int i=1;i&lt;n;i++){\n                gap=Math.max(gap,nums[i]-nums[i-1]);\n            }\n            //下标最小和最大位置的路灯需要单独判断\n            //如下标为3是最小，那么0-3这一段必须被覆盖到，所以最小下标必须单独判断\n            gap=Math.max(gap,nums[0]*2);\n            gap=Math.max(gap,(l-nums[n-1])*2);\n            // 输出描述:\n            // 输出答案，保留两位小数。\n            // 输出\n            // 2.50\n            System.out.println(String.format(\"%.2f\",gap/2.0));\n        }\n    }\n}\n</code></pre>\n<h2>3.3 <strong>输入为一个链表</strong></h2>\n<p>反转链表题目描述：</p>\n<ul><li> <pre>对于一个链表 L: L0→L1→…→Ln-1→Ln ,  将其翻转成 L0→Ln→L1→Ln-1→L2→Ln-2→…</pre> </li></ul>\n<p>输入描述：</p>\n<ul><li>输入是一串数字，用逗号分隔（1,2,3,4,5），请将其转换成单链表格式之后，再进行操作。</li></ul>\n<pre><code class=\"language-java\">import java.util.Scanner;\nimport java.util.Stack;\npublic class Main {\n    static class LinkNode {\n        int val;\n        LinkNode next;\n        public LinkNode(int val){\n            this.val = val;\n        }\n    }\n    public static void main(String[] args){\n        Scanner scanner = new Scanner(System.in);\n        //以字符串形式作为输入\n        String str = scanner.next().toString();\n        //通过分隔符将其转为字符串数组\n        String[] arr  = str.split(\",\");\n        //初始化一个整数数组\n        int[] ints = new int[arr.length];\n        //给整数数组赋值\n        for(int j = 0; j&lt;ints.length;j++) {\n            ints[j] = Integer.parseInt(arr[j]);\n        }\n        Stack&lt;LinkNode&gt; stack = new Stack&lt;&gt;();\n        LinkNode head = new LinkNode(0);\n        LinkNode p = head;\n        //链表初始化并放入stack中\n        for(int i = 0; i &lt; ints.length; i++){\n            p.next = new LinkNode(ints[i]);\n            p = p.next;\n            stack.add(p);\n        }\n        head = head.next;\n        //开始链表转换\n        p = head;\n        LinkNode q = stack.peek();\n        while ((!p.equals(q)) &amp;&amp; (!p.next.equals(q))) {\n            q = stack.pop();\n            q.next = p.next;\n            p.next = q;\n            p = p.next.next;\n            q = stack.peek();\n        }\n        q.next = null;\n        //输出\n        //1,5,2,4,3\n        //打印\n        while (head != null) {\n            if(head.next == null){\n                System.out.print(head.val);\n            }else{\n                System.out.print(head.val + \",\");\n            }\n            head = head.next;\n        }\n    }\n}</code></pre>\n<h2>3.4 输入是一棵树<strong>（主要是构建树的过程）</strong></h2>\n<ul><li> <pre>题目描述\n给定一个二叉树，判断其是否是一个有效的二叉搜索树。\n假设一个二叉搜索树具有如下特征：\n节点的左子树只包含小于当前节点的数。\n节点的右子树只包含大于当前节点的数。\n所有左子树和右子树自身必须也是二叉搜索树。\n例如：\n输入：\n    5\n   / \\\n  1   3\n     / \\\n    4   6\n输出: false</pre> </li><li> <pre>输入描述:\n第一行两个数 n，root，分别表示二叉树有n个节点，第root个节点是二叉树的根，接下来共n行，第i行三个数val_i,left_i,right_i，分别表示第i个节点的值val是val_i,左儿子left是第left_i个节点，右儿子right是第right_i个节点。节点0表示空。1&lt;=n&lt;=100000,保证是合法的二叉树。\n输入\n5 1\n5 2 3\n1 0 0\n3 4 5\n4 0 0\n6 0 0</pre> </li></ul>\n<pre><code class=\"language-java\">import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Stack;\n//构造树需要的结点类\nclass TreeNode {\n    TreeNode left, right;\n    int val;\n\n    public TreeNode(int val) {\n        this.val = val;\n    }\n}\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        String[] s = reader.readLine().split(\" \");\n        int n = Integer.parseInt(s[0]);\n        int root = Integer.parseInt(s[1]);\n        TreeNode[] tree = new TreeNode[n + 1];\n        int[][] leaf = new int[n + 1][2];\n        for (int i = 1; i &lt;= n; i++) {\n            String[] ss = reader.readLine().split(\" \");\n            int val_i = Integer.parseInt(ss[0]);\n            int left_i = Integer.parseInt(ss[1]);\n            int right_i = Integer.parseInt(ss[2]);\n            TreeNode node = new TreeNode(val_i);\n            leaf[i][0] = left_i;\n            leaf[i][1] = right_i;\n            tree[i] = node;\n        }\n        for (int i = 1; i &lt;= n; i++) {\n            int left = leaf[i][0];\n            if (left != 0) {\n                tree[i].left = tree[left];\n            } else {\n                tree[i].left = null;\n            }\n            int right = leaf[i][1];\n            if (right != 0) {\n                tree[i].right = tree[right];\n            } else {\n                tree[i].right = null;\n            }\n        }\n        TreeNode head = tree[root];\n        boolean flag = isBinarySearchTree(head);\n        System.out.println(flag);\n    }\n    private static boolean isBinarySearchTree(TreeNode node) {\n        if(node == null){\n            return true;\n        }\n        int pre = Integer.MIN_VALUE;\n        Stack&lt;TreeNode&gt; s = new Stack&lt;&gt;();\n\n        while(!s.isEmpty() || node != null){\n            while(node != null){\n                s.push(node);\n                node = node.left;\n            }\n            node = s.pop();\n            if(node == null){\n                break;\n            }\n            if(pre &gt; node.val){\n                return false;\n            }\n            pre = node.val;\n            node = node.right;\n        }\n        return true;\n    }\n}\n</code></pre>\n</div>\n</div>"}