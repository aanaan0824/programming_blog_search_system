{"blogid": "124101531", "writerAge": "码龄9年", "writerBlogNum": "268", "writerCollect": "1617", "writerComment": "474", "writerFan": "16410", "writerGrade": "7级", "writerIntegral": "11283", "writerName": "特立独行的猫a", "writerProfileAdress": "writer_image\\profile_124101531.jpg", "writerRankTotal": "1092", "writerRankWeekly": "573", "writerThumb": "630", "writerVisitNum": "989114", "blog_read_count": "4760", "blog_time": "已于 2022-04-11 19:23:17 修改", "blog_title": "gtest单元测试框架介绍及简单使用", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h3>Gtest介绍</h3>\n<p>Gtest是Google的一个开源框架，它主要用于写单元测试，检查真自己的程序是否符合预期行为。可在多个平台上使用（包括Linux, Mac OS X, Windows, Cygwin和Symbian）。它提供了丰富的断言、致命和非致命失败判断，能进行值参数化测试、类型参数化测试、“死亡测试”。</p>\n<h3>下载安装</h3>\n<p>相关地址：</p>\n<p><a href=\"http://googletest.googlecode.com/files/gtest-1.3.0.zip\" title=\"http://googletest.googlecode.com/files/gtest-1.3.0.zip\">http://googletest.googlecode.com/files/gtest-1.3.0.zip</a></p>\n<p><a href=\"https://github.com/google/googletest\" title=\"GitHub - google/googletest: GoogleTest - Google Testing and Mocking Framework\">GitHub - google/googletest: GoogleTest - Google Testing and Mocking Framework</a></p>\n<p>windows下推荐使用vcpkg工具下载安装，安装很简便。</p>\n<p>默认下载安装的是32位的，若需要64位的则指定.\\vcpkg.exe install gtest:x64-windows</p>\n<pre><code class=\"language-bash\">.\\vcpkg.exe install gtest</code></pre>\n<h3>相关特性</h3>\n<p><strong>一 .断言</strong><br/> 一般的要测试一个方法（函数）是否是正常执行的，可以提供一些输入数据。在调用这个方法（函数）后得到输出数据，然后检查输出的数据是否与我们期望的结果是一致的。若一致则说明这个方法的逻辑是正确的，否则就有问题。  </p>\n<p>在对输出结果进行检查（check）时，Gtest为我提供了一系列的断言（assertion）来进行代码测试，这些宏有点类似于函数调用。当断言失败时Gtest将会打印出assertion时的源文件和出错行的位置以及附加的失败信息。这些输出的附加信息用户可以直接通过“&lt;&lt;”在这些断言宏后面。</p>\n<p>Gtest中，断言的宏可以理解为分为两类，一类是ASSERT系列，一类是EXPECT系列。</p>\n<p>ASSERT_系列的断言（Fatal assertion）：</p>\n<p>当检查点失败时，退出当前函数（注意：并非退出当前案例）。</p>\n<p>EXPECT_系列的断言(Nonfatal assertion)：</p>\n<p>当检查点失败时，继续执行下一个检查点（每一个断言表示一个测试点）。</p>\n<p>通常情况应该首选使用EXPECT_，因为ASSERT_*在报告完错误后不会进行清理工作，有可能导致内存泄露问题。</p>\n<p>断言中提供以下几种检查方法:</p>\n<p>布尔类型检查</p>\n<p><img alt=\"\" height=\"125\" src=\"image\\62ab0db5f0ff4fb9a9d6150a638c6f88.png\" width=\"960\"/> 二值检查</p>\n<p><img alt=\"\" height=\"300\" src=\"image\\09f53d64def044e28b886b08ae833718.png\" width=\"958\"/>字符串检查</p>\n<p><img alt=\"\" height=\"358\" src=\"image\\10d8df8abd304b4c8ad9b31372509a5d.png\" width=\"965\"/>异常检查</p>\n<p><img alt=\"\" height=\"197\" src=\"image\\c72fc9dc528a4459ac487845bd981477.png\" width=\"952\"/></p>\n<p>浮点检查</p>\n<p><img alt=\"\" height=\"126\" src=\"image\\d5bf89a729ee4d679a005b2060045e4f.png\" width=\"958\"/></p>\n<p>相近值检查</p>\n<p><img alt=\"\" height=\"105\" src=\"image\\9b583738a96d4d8d9d52e506a21b71f4.png\" width=\"961\"/></p>\n<p><strong>二 .宏测试</strong></p>\n<p><strong>TEST宏</strong></p>\n<p>TEST宏的第一个参数是test_suite_name（测试套件名），第二个参数是test_name（测试特例名）。</p>\n<p>测试套件（Test Case）是为某个特殊目标而编制的一组测试输入、执行条件以及预期结果，以便测试某个程序路径或核实是否满足某个特定需求。</p>\n<p>测试特例是测试套件下的一个（组）测试。</p>\n<p>对于测试套件名和测试特例名，不能有下划线（_）。因为GTest源码中需要使用下划线把它们连接成一个独立的类名。不能有相同的“测试套件名和特例名”的组合——否则类名重合。</p>\n<p>测试套件名和测试特例名的分开，使得我们编写的测试代码有着更加清晰的结构。</p>\n<p><strong>TEST_F宏</strong></p>\n<p>使用TEST_F前需要创建一个固件类，继承esting::Test类。</p>\n<p>在类内部使用public或者protected描述其成员，为了保证实际执行的测试子类可以使用其成员变量。在构造函数或者继承于::testing::Test类中的SetUp方法中可以实现我们需要构造的数据。在析构函数或者继承于::testing::Test类中的TearDown方法中可以实现一些资源释放的代码。</p>\n<p>第一个参数为测试套件名（必须与创建的固件类名一致），第二个为测试名，可任意取。</p>\n<p>TEST_F宏和TEST宏的实现接近，只是TEST_F宏的封装更加开放一些，对TEST宏的功能多了一些扩展。</p>\n<p>TEST_F与TEST的区别，TEST_F提供了一个初始化函数（SetUp）和一个清理函数(TearDown)。在TEST_F中使用的变量可以在初始化函数SetUp中初始化，在TearDown中销毁。所有的TEST_F是互相独立的，都是在初始化以后的状态开始运行。一个TEST_F不会影响另一个TEST_F所使用的数据，多个测试场景需要相同数据配置的情况用 TEST_F。</p>\n<p><strong>TEST_P宏</strong></p>\n<p>在设计测试案例时，经常需要考虑给被测函数传入不同的值的情况。我们之前的做法通常是写一个通用方法然后编写在测试案例调用它。即使使用了通用方法，这样的工作也是有很多重复性的。</p>\n<p>用TEST这个宏，需要编写如下的测试案例，每输入一个值就需要写一个测试点，这还只是在一个测试中，如果把每个测试点单独创建一个测试，工作量就更大。使用TEST_P这个宏，对输入进行参数化，就简单很多。</p>\n<h3><strong>预处理事件机制</strong></h3>\n<p>gtest 提供了多种预处理事件机制，方便我们在测试之前或之后做一些操作。</p>\n<p>1. 全局的，所有测试执行前后。</p>\n<p>2. TestSuite级别的，在某测试套件中第一个测试前，最后一个测试执行后。</p>\n<p>3. TestCase级别的，每个测试前后。</p>\n<p><strong>1.全局事件</strong></p>\n<p>要实现全局事件，必须写一个类继承testing::Environment类，实现里面的SetUp和TearDown方法。</p>\n<p>1. SetUp()方法在所有案例执行前执行。</p>\n<p>2. TearDown()方法在所有案例执行后执行。</p>\n<p>还需要在main函数中通过调用testing::AddGlobalTestEnvironment这个函数将事件挂进来，也就是说，我们可以写很多个这样的类，然后将他们的事件都挂上去，AddGlobalTestEnvironment这个函数要放在RUN_ALL_TEST之前。 </p>\n<p><img alt=\"\" src=\"image\\20210804172322327.png\"/></p>\n<p><strong>2.TestSuites事件</strong></p>\n<p>需要写一个类，继承testing::Test，然后实现两个<strong><strong>静态</strong></strong>方法</p>\n<p>1. SetUpTestCase() 方法在第一个TestCase之前执行。</p>\n<p>2. TearDownTestCase() 方法在最后一个TestCase之后执行。</p>\n<p><strong>3.TestCase事件</strong><br/> TestCase事件是挂在每个案例执行前后的，实现方式和Test'Suites的几乎一样，不过需要实现的是SetUp方法和TearDown方法：</p>\n<p>1. SetUp()方法在每个TestCase之前执行。</p>\n<p>2. TearDown()方法在每个TestCase之后执行。<br/><strong>测试用例入口</strong></p>\n<pre><code class=\"language-cpp\">int main(int argc,char *argv[])\n{\n    testing::InitGoogleTest(&amp;argc,argv);\n    return RUN_ALL_TESTS();\n}</code></pre>\n<h3>cmake工程中使用</h3>\n<pre><code class=\"language-bash\">find_package(GTest CONFIG REQUIRED)\ntarget_link_libraries(${PROJECT_NAME} PRIVATE GTest::gtest GTest::gtest_main GTest::gmock GTest::gmock_main)</code></pre>\n<p>附个简单的cmake工程模板：</p>\n<pre><code class=\"language-bash\">cmake_minimum_required(VERSION 3.12)\n\nproject(mygtest VERSION 0.0.1)\n\nset(CMAKE_CXX_STANDARD 11)\n\n####################  QT dependencies ####################\n#set(CMAKE_CXX_STANDARD 11)\n#set(CMAKE_AUTOMOC ON)\n#set(CMAKE_AUTORCC ON)\n#set(CMAKE_AUTOUIC ON)\n\n#set(QT_VERSION 5)\n#set(REQUIRED_LIBS Core)\n#set(REQUIRED_LIBS_QUALIFIED Qt5::Core)\n\n####################  set output directory ####################\nset(BUILD_DIR ${CMAKE_CURRENT_SOURCE_DIR}/build)\nset(LIB_DIR ${BUILD_DIR}/Release)\nset(LIB_FIX)\nif (CMAKE_BUILD_TYPE MATCHES \"Debug\")\n    set(LIB_DIR ${BUILD_DIR}/Debug)\n    set(LIB_FIX _d)\nendif ()\n\nget_filename_component(ABSOLUTE_PATH ${LIB_DIR} ABSOLUTE)\nset(LIB_DIR ${ABSOLUTE_PATH})\n\nset(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${LIB_DIR}/lib)\nset(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${LIB_DIR}/lib)\nset(CMAKE_PDB_OUTPUT_DIRECTORY ${LIB_DIR}/lib)\nset(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${LIB_DIR}/lib)\n\nset(LIB_DIR_FIX ${LIB_DIR}/bin)\noption(USE_VS_BUILD \"use visual studio build.\" OFF)\nif (USE_VS_BUILD)\n    set(LIB_DIR_FIX ${LIB_DIR}/bin/Debug)\nendif ()\n\n####################  set include path ####################\nset(SRC_PATH\n        ${CMAKE_CURRENT_SOURCE_DIR}/\n        )\n\ninclude_directories(\n        ${SRC_PATH}\n        ${BUILD_DIR}/../include\n)\n\nadd_definitions(\n        \n)\n\n####################  scan source files ####################\nforeach (path ${SRC_PATH})\n    aux_source_directory(${path} SRC_FILES)\nendforeach ()\n\n\n####################  version config ####################\n#configure_file(${BUILD_DIR}/../include/version.h.in ${CMAKE_CURRENT_BINARY_DIR}/plugin_version.h)\n#include_directories(${CMAKE_CURRENT_BINARY_DIR})\n\n#if (MSVC)\n#    set(MY_VERSIONINFO_RC \"${CMAKE_CURRENT_BINARY_DIR}/VersionInfo.rc\")\n#    configure_file(\"${CMAKE_CURRENT_SOURCE_DIR}/resource.rc.in\"\n#            \"${MY_VERSIONINFO_RC}\")\n#endif ()\n\n#add_library(${PROJECT_NAME} SHARED ${SRC_FILES} ${MY_VERSIONINFO_RC})\nadd_executable(${PROJECT_NAME} ${SRC_FILES})\n####################  set target properties ####################\nset_target_properties(${PROJECT_NAME} PROPERTIES DEBUG_POSTFIX _d)\n\n####################  set target dependencies ####################\nfind_package(GTest CONFIG REQUIRED)\n#find_package(Qt${QT_VERSION} COMPONENTS ${REQUIRED_LIBS} REQUIRED)\n\nset(THIRD_LIBS\n        #${REQUIRED_LIBS_QUALIFIED}\n        #${LOGGING_LIB}\n        )\ntarget_link_libraries(${PROJECT_NAME} PRIVATE ${THIRD_LIBS})\ntarget_link_libraries(${PROJECT_NAME} PRIVATE GTest::gtest GTest::gtest_main GTest::gmock GTest::gmock_main)</code></pre>\n<p>在clion的项目中还需要配置：</p>\n<pre><code class=\"language-bash\">-DCMAKE_PREFIX_PATH=D:\\Qt5.12.11\\Qt5.12.11\\5.12.11\\msvc2015_64\\lib\\cmake -DCMAKE_TOOLCHAIN_FILE=F:\\vcpkg\\scripts\\buildsystems\\vcpkg.cmake -Wno-dev</code></pre>\n<p>若使用命令行下尝试，则推荐使用powershell脚本，附个示例：</p>\n<pre><code class=\"language-bash\">$VcpkgPath = \"F:/vcpkg/scripts/buildsystems/vcpkg.cmake\"\n#if (($result = Read-Host \"Enter the full path of vcpkg.cmake[default: F:/vcpkg/scripts/buildsystems/vcpkg.cmake]\") -eq '') {} else {$VcpkgPath=$result}\nWrite-Host \"`n VcpkgPath: $VcpkgPath\" -ForegroundColor Yellow\n\nPush-Location 'C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\Common7\\Tools'    \ncmd /c \"vsvars32.bat&amp;set\" |\nForEach-Object {\n  if ($_ -match \"=\") {\n    $v = $_.split(\"=\"); set-item -force -path \"ENV:\\$($v[0])\"  -value \"$($v[1])\"\n  }\n}\nPop-Location\nwrite-host \"`nVisual Studio 2015 Command Prompt variables set.\" -ForegroundColor Yellow\n\nWrite-Host \"`n build for this module project.\" -ForegroundColor Green\ncmake . -B build -DCMAKE_BUILD_TYPE=RelWithDebInfo -DCMAKE_TOOLCHAIN_FILE=\"$VcpkgPath\" -Wno-dev -G \"NMake Makefiles\" \nSet-Location build\nnmake \n#nmake install\nSet-Location ..</code></pre>\n<h3>简单示例</h3>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\nusing namespace std; \n#include&lt;gtest/gtest.h&gt;\n\nclass MyClass{\npublic:\n    int add(int a,int b){\n        return a+b;\n    }\n    int del(int a,int b){\n        return a-b;\n    }\n\n};\n//class MyClassTest: public testing::Test{}\nclass MyClassTest: public testing::TestWithParam&lt;int&gt;{\npublic:\n    static void SetUpTestCase()\n    {\n        cout&lt;&lt;\"SetUpTestCase\"&lt;&lt;endl;\n    }\n    static void TearDownTestCase()\n    {\n        cout&lt;&lt;\"TearDownTestCase\"&lt;&lt;endl;\n    }\n    virtual void SetUp()   //TEST跑之前会执行SetUp\n    {\n        cout&lt;&lt;\"SetUp\"&lt;&lt;endl;\n    }\n    virtual void TearDown() //TEST跑完之后会执行TearDown\n    {\n        cout&lt;&lt;\"TearDown\"&lt;&lt;endl;\n    }\n    MyClass myClass;\n\n};\n\nINSTANTIATE_TEST_SUITE_P(PARAM,MyClassTest,testing::Values(3,5,7,9));\n\nint Abs(int x)\n{\n     return x &gt; 0 ? x : -x;\n}\n\nTEST(IsAbsTest,MyTest)\n{\n    ASSERT_TRUE(Abs(1) == 1) &lt;&lt; \"Abs(1)=1\";  //ASSERT_TRUE期待结果是true,operator&lt;&lt;输出一些自定义的信息\n    ASSERT_TRUE(Abs(-1) == 1) &lt;&lt; \"Abs(-1)=1\";\n    ASSERT_FALSE(Abs(-2) == -2);  //期待结果是false\n    ASSERT_EQ(Abs(1),Abs(-1));\n    ASSERT_NE(Abs(-1),0);\n    ASSERT_LT(Abs(-1),2);\n    ASSERT_GT(Abs(-1),0);\n    ASSERT_LE(Abs(-1),2);\n    ASSERT_GE(Abs(-1),0);\n}\n\n//此时使用的是TEST_P宏\nTEST_P(MyClassTest,AddTest)\n{\n    auto out= myClass.add(1,2);\n    //ASSERT_NE(out,3);\n    int n = GetParam();\n    ASSERT_EQ(out,3);\n    ASSERT_EQ(out,n);\n}\n//此时使用的是TEST_F宏\nTEST_F(MyClassTest,Add)\n{\n    auto out= myClass.add(1,2);\n    ASSERT_EQ(out,3);\n}\nTEST_F(MyClassTest,del)\n{\n    ASSERT_EQ(myClass.del(4,3),1);\n}\n\nint main(int argc,char *argv[])\n{\n    testing::InitGoogleTest(&amp;argc,argv);\n    return RUN_ALL_TESTS();\n}</code></pre>\n<p>运行结果：</p>\n<p><img alt=\"\" height=\"589\" src=\"image\\5d657b89514348c7bf5d57bdda443df1.png\" width=\"1057\"/></p>\n<h3>引用</h3>\n<p><a href=\"https://zhuanlan.zhihu.com/p/369466622\" title=\"手把手教你使用gtest写单元测试（1/2） - 知乎\">手把手教你使用gtest写单元测试（1/2） - 知乎</a></p>\n<p><a href=\"https://blog.csdn.net/qq_36631379/article/details/119387921\" title=\"GTest 总结_HUSTER593的博客-CSDN博客_gtest\">GTest 总结_HUSTER593的博客-CSDN博客_gtest</a></p>\n<p><a href=\"https://blog.csdn.net/linhai1028/article/details/81675724\" title=\"gtest的介绍和使用_linhai1028的博客-CSDN博客_gtest\">gtest的介绍和使用_linhai1028的博客-CSDN博客_gtest</a></p>\n<p><a href=\"https://www.cnblogs.com/coderzh/archive/2009/04/08/1431297.html\" title=\"玩转Google开源C++单元测试框架Google Test系列(gtest)之四 - 参数化 - CoderZh - 博客园\">玩转Google开源C++单元测试框架Google Test系列(gtest)之四 - 参数化 - CoderZh - 博客园</a></p>\n<p><a href=\"https://www.csdn.net/tags/NtjaAg2sNTM4MjMtYmxvZwO0O0OO0O0O.html\" title=\"https://www.csdn.net/tags/NtjaAg2sNTM4MjMtYmxvZwO0O0OO0O0O.html\">https://www.csdn.net/tags/NtjaAg2sNTM4MjMtYmxvZwO0O0OO0O0O.html</a></p>\n<p><a href=\"https://www.cnblogs.com/jycboy/p/gtest_catalog.html\" title=\"Google C++单元测试框架GoogleTest(总) - 超超boy - 博客园\">Google C++单元测试框架GoogleTest(总) - 超超boy - 博客园</a></p>\n<p><a href=\"https://www.cnblogs.com/coderzh/archive/2010/01/09/beautiful-testcase.html\" title=\"编写优美的GTest测试案例 - CoderZh - 博客园\">编写优美的GTest测试案例 - CoderZh - 博客园</a></p>\n</div>\n</div>"}