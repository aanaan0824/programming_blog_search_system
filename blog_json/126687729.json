{"blogid": "126687729", "writerAge": "码龄2年", "writerBlogNum": "218", "writerCollect": "3982", "writerComment": "240", "writerFan": "5017", "writerGrade": "5级", "writerIntegral": "3926", "writerName": "IT_Holmes", "writerProfileAdress": "writer_image\\profile_126687729.jpg", "writerRankTotal": "3958", "writerRankWeekly": "5613", "writerThumb": "673", "writerVisitNum": "250332", "blog_read_count": "52", "blog_time": "于 2022-09-06 12:48:48 发布", "blog_title": "Docker 学习笔记总结(三)", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-tomorrow-night\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p></p>\n<div class=\"toc\">\n<h3>文章目录</h3>\n<ul><li><a href=\"#1_docker__redis_2\">1. docker 搭建 三主三从的redis集群</a></li><li><a href=\"#2__redis__redis_65\">2. redis集群 之 主从容错切换迁移(基于redis集群)</a></li><li><a href=\"#3_redis__redis_79\">3. redis集群 之 主从扩容(基于redis集群)</a></li><li><a href=\"#4_redis__redis_120\">4. redis集群 之 主从缩容(基于redis集群)</a></li><li><a href=\"#5_DockerFile__150\">5. DockerFile 介绍</a></li><li><a href=\"#6_DockerFile__163\">6. DockerFile 构建过程解析</a></li><li><a href=\"#7_DockerFile__176\">7. DockerFile 保留字简介</a></li><li><a href=\"#8_DockerFile__266\">8. DockerFile 保留字案例演示</a></li><li><a href=\"#9__322\">9. 虚悬镜像</a></li><li><a href=\"#10_Docker__349\">10. Docker 微服务实战</a></li></ul>\n</div>\n<p></p>\n<h1><a id=\"1_docker__redis_2\"></a>1. docker 搭建 三主三从的redis集群</h1>\n<hr/>\n<p><strong>架构图：</strong><br/> <img alt=\"在这里插入图片描述\" src=\"image\\7797861fbf7242ecbca48f75782a954e.png\"/></p>\n<hr/>\n<p><strong>第一步：启动6台redis节点：</strong></p>\n<pre><code class=\"prism language-shell\"><span class=\"token function\">docker</span> run -d --name redis-node-1 --net <span class=\"token function\">host</span> --privileged<span class=\"token operator\">=</span>true <span class=\"token punctuation\">\\</span>\n-v /data/redis/share/redis-node-1:/data redis:6.0.8 <span class=\"token punctuation\">\\</span>\n--cluster-enabled <span class=\"token function\">yes</span> --appendonly <span class=\"token function\">yes</span> --port <span class=\"token number\">6381</span>\n\n<span class=\"token function\">docker</span> run -d --name redis-node-2 --net <span class=\"token function\">host</span> --privileged<span class=\"token operator\">=</span>true <span class=\"token punctuation\">\\</span>\n-v /data/redis/share/redis-node-2:/data redis:6.0.8 <span class=\"token punctuation\">\\</span>\n--cluster-enabled <span class=\"token function\">yes</span> --appendonly <span class=\"token function\">yes</span> --port <span class=\"token number\">6382</span>\n\n<span class=\"token punctuation\">..</span>.\n\n<span class=\"token comment\"># 开上6台redis节点。</span>\n</code></pre>\n<p><strong>参数命令解释：</strong><br/> <img alt=\"在这里插入图片描述\" src=\"image\\960f7b5601f340ca873e6a2934e1c6bd.png\"/></p>\n<p><strong>启动后的容器：</strong><br/> <img alt=\"在这里插入图片描述\" src=\"image\\8071e013354b44908c7adbb6bf97aed8.png\"/></p>\n<p><strong>第二步：进入其中一个节点，构建主从关系。</strong></p>\n<pre><code class=\"prism language-shell\"><span class=\"token comment\"># 进入redis节点</span>\n<span class=\"token function\">docker</span> <span class=\"token builtin class-name\">exec</span> -it redis-node-1 /bin/bash\n<span class=\"token comment\"># 构建主从关系</span>\nredis-cli --cluster create <span class=\"token number\">127.0</span>.0.1:6381 <span class=\"token number\">127.0</span>.0.1:6382 <span class=\"token number\">127.0</span>.0.1:6383 <span class=\"token number\">127.0</span>.0.1:6384 <span class=\"token number\">127.0</span>.0.1:6385 <span class=\"token number\">127.0</span>.0.1:6386 --cluster-replicas <span class=\"token number\">1</span>\n</code></pre>\n<p><strong><code>--cluster-replicas 1 表示为每个master创建一个salve节点，就是1:1的主从比例。</code></strong></p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\a9ecf00d23b848cebb1b50abc161224c.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"image\\f42bd32d221d46e3b6c44458f8523707.png\"/></p>\n<p><strong>第三步：进入某个节点查看redis集群状态。</strong></p>\n<ul><li><strong>cluster info命令：打印集群的信息.</strong></li><li><strong>cluster nodes命令：查看集群节点。</strong><br/> <img alt=\"在这里插入图片描述\" src=\"image\\f6ebd7d41e7640eb9b5869d92a4a60b5.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"image\\2cc349f76d614e84bc967871525054e3.png\"/><br/> <code>到了这，一个3主3从的redis集群就算搭建成功！</code></li></ul>\n<p><strong>注意错误：</strong></p>\n<ul><li><strong>因为是集群了，所以不能用单机版命令进入redis客户端，要添加-c的参数以集群模式启动。</strong><br/> <img alt=\"在这里插入图片描述\" src=\"image\\74f1f53283f046378c76a0828d340829.png\"/></li><li><strong>添加-c后，在数据读写时就会有读写路由切换的一个效果。</strong><br/> <img alt=\"在这里插入图片描述\" src=\"image\\8838c24e1acb4fca9cf513f47aa51acf.png\"/><br/> <code>其实就是通过哈希槽分区算法，算出要插入的槽位，进而切换到槽位所在的节点而已。</code></li></ul>\n<p><strong>第四步：redis-cli --cluster check 127.0.0.1:6381<br/> 命令查看集群信息。</strong></p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\39459fb1606f44cda8dbb6c7e1ce68d7.png\"/></p>\n<h1><a id=\"2__redis__redis_65\"></a>2. redis集群 之 主从容错切换迁移(基于redis集群)</h1>\n<hr/>\n<p><strong>容错就是如果redis某个节点宕机了的情况。</strong></p>\n<p><strong>主节点宕机，对应的从节点通过心跳检测，检测不到就会上位。</strong><br/> <img alt=\"在这里插入图片描述\" src=\"image\\f75a10f6a0ad468ba461575debc557a5.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"image\\deffc54224f743f2a43e1247e0c83faa.png\"/></p>\n<p><strong>当宕机的节点恢复，就会变成对应的从机。</strong></p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\697adf343a36462e83239100b765f728.png\"/></p>\n<h1><a id=\"3_redis__redis_79\"></a>3. redis集群 之 主从扩容(基于redis集群)</h1>\n<hr/>\n<p><strong>扩容就是添加节点的情况。</strong></p>\n<p><strong>第一步：新建6387，6388两个redis节点。</strong><br/> <img alt=\"在这里插入图片描述\" src=\"image\\5d7f9ec2dede4acbbc0e182077403ca2.png\"/></p>\n<p><strong>第二步：将新增的6387节点作为master节点加入集群。</strong></p>\n<pre><code class=\"prism language-shell\">redis-cli --cluster add-node 自己实际IP地址:6387 自己实际IP地址:6381\n<span class=\"token comment\"># 6387就是将要作为master新增节点。</span>\n<span class=\"token comment\"># 6381就是原来集群节点里面的领路人，相当于找到组织加入集群。</span>\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\efa0a0c28a0a40fbae2b652f2ddd0298.png\"/><br/> <strong>第三步：虽然节点已经加入了集群，但没有槽位的。所以要重新分派槽号。</strong></p>\n<pre><code class=\"prism language-shell\">redis-cli --cluster reshard IP地址:端口号\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\dfc59b9020c84c2bbb70c9c5eff76e84.png\"/><br/> <strong>执行reshard命令后，要填写一些配置：</strong><br/> <img alt=\"在这里插入图片描述\" src=\"image\\c8d2ccae418a47ee94f46173586198d6.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"image\\9355df2e0c194fc2b40aeda46803200f.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"image\\64a6fa5e44714fe48b4550da7acbf3df.png\"/></p>\n<p><strong>第四步：槽号分派是从前面几个节点分出了一些槽号给新节点。</strong><br/> <img alt=\"在这里插入图片描述\" src=\"image\\b7b8cea501e44fe0aa16a9858dbca0e2.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"image\\20b70ff3456a43618fd7b37501e76853.png\"/></p>\n<p><strong>第五步：为主节点6387分配从节点6388。</strong></p>\n<pre><code class=\"prism language-shell\"><span class=\"token comment\"># 从节点绑定</span>\nredis-cli --cluster add-node 从节点IP:从节点端口 主节点IP:主节点端口 --cluster-slave --cluster-master-id 主节点ID\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\e0d0a56a7d8e47f3a0ee70a34d4f256a.png\"/></p>\n<p><strong>这样就将3主3从扩展到了4主4从的效果。</strong></p>\n<h1><a id=\"4_redis__redis_120\"></a>4. redis集群 之 主从缩容(基于redis集群)</h1>\n<hr/>\n<p><strong>第一步：先删除主节点对应的从节点。</strong></p>\n<pre><code class=\"prism language-shell\"><span class=\"token comment\"># 删除从节点</span>\nredis-cli --cluster del-node ip:从机端口 从机6388节点ID\n<span class=\"token comment\"># 检查从节点是否被删除</span>\nredis-cli --cluster check <span class=\"token number\">127.0</span>.0.1:6382  \n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\622983c287834390837153def14495cc.png\"/></p>\n<p><strong>第二步：将主节点redis的槽号清空，重新分配。本例将清出来的槽号都给了6381节点。</strong></p>\n<pre><code class=\"prism language-shell\"><span class=\"token comment\"># 分配槽号给6381节点</span>\nredis-cli --cluster reshard <span class=\"token number\">127.0</span>.0.1:6381\n</code></pre>\n<p><strong>分配流程如下：</strong><br/> <img alt=\"在这里插入图片描述\" src=\"image\\d20cdc78d640440183bb217fe6db89a1.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"image\\96d88843accb40a6971cf74a627befda.png\"/></p>\n<p><strong>第三步：将主节点6387删除。</strong></p>\n<pre><code class=\"prism language-shell\">redis-cli --cluster del-node ip:从机端口 <span class=\"token number\">6387</span>节点ID\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\1ee8bc2f274f4ce8b6237b5732218b84.png\"/></p>\n<h1><a id=\"5_DockerFile__150\"></a>5. DockerFile 介绍</h1>\n<hr/>\n<p><strong>DockerFile是用来构建Docker镜像的文本文件，是由一条条构建镜像所需的指令和参数构成的脚本。</strong></p>\n<p><strong>之前用过docker commit 命令来将容器保存成镜像，从而达到一个加强版的镜像。而Dockerfile要比这种方式还要简单。</strong></p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\2fb3e22d3c4047a5ab2d5b3c10f09488.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"image\\dc3bf66d927648219b12217a9e46a9a5.png\"/></p>\n<p><strong>Dockerfile文档官方地址：<a href=\"https://docs.docker.com/engine/reference/builder/\">https://docs.docker.com/engine/reference/builder/</a></strong></p>\n<h1><a id=\"6_DockerFile__163\"></a>6. DockerFile 构建过程解析</h1>\n<hr/>\n<p><strong>DockerFile内容基础知识：</strong></p>\n<ul><li><strong>每条保留字指令都必须为大写字母且后面要跟随至少一个参数。</strong></li><li><strong>指令按照从上到下，顺序执行。</strong></li><li><strong>#表示注释。</strong></li><li><strong>每条指令都会创建一个新的镜像层并对镜像进行提交。</strong></li></ul>\n<p><strong>Docker执行DockerFile的大致流程：</strong><br/> <img alt=\"在这里插入图片描述\" src=\"image\\d8ca8027270b498088a1c12c0d5c01fa.png\"/><br/> <code>DockerFile就类似配置文件一样。</code></p>\n<h1><a id=\"7_DockerFile__176\"></a>7. DockerFile 保留字简介</h1>\n<hr/>\n<p><strong>可以参考tomcat8的dockerfile：<a href=\"https://github.com/docker-library/tomcat\">https://github.com/docker-library/tomcat</a></strong></p>\n<hr/>\n<p><strong>from保留字：</strong></p>\n<ul><li><strong>就是基于来自哪个镜像的。</strong><br/> <img alt=\"在这里插入图片描述\" src=\"image\\360bf2a7231046239b2afd5f8858d344.png\"/></li></ul>\n<hr/>\n<p><strong>maintainer保留字：</strong><br/> <img alt=\"在这里插入图片描述\" src=\"image\\662f8bbb0555459389465a3da842ceeb.png\"/></p>\n<hr/>\n<p><strong>run保留字：</strong></p>\n<ul><li><strong>两种格式：shell格式和exec格式。</strong></li><li><strong>run是在docker build时运行。</strong><br/> <img alt=\"在这里插入图片描述\" src=\"image\\b9b7ce20bc014a2da4712eb9bf8fee75.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"image\\da3214fdc1d840feba57f2af3a24451a.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"image\\cc34a21b90264ab99357f4b71bb2701d.png\"/></li></ul>\n<hr/>\n<p><strong>expose保留字：</strong><br/> <img alt=\"在这里插入图片描述\" src=\"image\\b80ac068c34e4e23b029b54c8bf093cf.png\"/></p>\n<hr/>\n<p><strong>workdir保留字：</strong><br/> <img alt=\"在这里插入图片描述\" src=\"image\\e9335ab40b9348ab980a2925d0b4971c.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"image\\e92f014e4a0c4b439bf7244be16cfd60.png\"/></p>\n<hr/>\n<p><strong>user保留字：</strong><br/> <img alt=\"在这里插入图片描述\" src=\"image\\1477d41b260e4fd69e92d006bb1845c8.png\"/></p>\n<hr/>\n<p><strong>env保留字：</strong><br/> <img alt=\"在这里插入图片描述\" src=\"image\\dc741d23f6c74e519cc9326cbef7755b.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"image\\3bd449532ec8465380836ca91511534e.png\"/></p>\n<hr/>\n<p><strong>volume保留字：</strong><br/> <img alt=\"在这里插入图片描述\" src=\"image\\6f7c3430c4aa40beb893ecf824554207.png\"/></p>\n<hr/>\n<p><strong>add保留字：</strong><br/> <img alt=\"在这里插入图片描述\" src=\"image\\401155d60f3f46e78af901974063de46.png\"/><br/> <code>add和copy保留字功能差不多，只不过add要更强大一点，会自动处理URL和解压压缩包。</code></p>\n<hr/>\n<p><strong>copy保留字：</strong><br/> <img alt=\"在这里插入图片描述\" src=\"image\\59d1b7d36e924c778df55be7558fc6da.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"image\\4c9f1b6ea62e4fc19ba5e95e422a7b89.png\"/></p>\n<hr/>\n<p><strong>cmd保留字：</strong><br/> <img alt=\"在这里插入图片描述\" src=\"image\\a588b38123b443a08dc9f622d16e3c7a.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"image\\6426a758e776430f9d147ac74d7b581d.png\"/></p>\n<p><strong>注意事项：Dockerfile中可以有多个CMD命令，但只有最后一个生效，CMD会被docker run之后的参数替换掉。</strong><br/> <img alt=\"在这里插入图片描述\" src=\"image\\652f8c13646c45269b055439d0d25442.png\"/></p>\n<p><strong>cmd与run的区别：</strong><br/> <img alt=\"在这里插入图片描述\" src=\"image\\d65efe6af0a5493189c2ba1ccc5a509a.png\"/></p>\n<hr/>\n<p><strong>entrypoint保留字：</strong></p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\c4b2f4b3ed8348e39fbd28a1c1ae7ddf.png\"/><br/> <strong>查看图片中的案例：</strong><br/> <img alt=\"在这里插入图片描述\" src=\"image\\f78dfa35b4b54f6aa9830056f6d7c961.png\"/></p>\n<hr/>\n<p><strong>保留字总结：</strong><br/> <img alt=\"在这里插入图片描述\" src=\"image\\ce4dd7bd147249759028bea57031eb12.png\"/></p>\n<h1><a id=\"8_DockerFile__266\"></a>8. DockerFile 保留字案例演示</h1>\n<hr/>\n<p>场景需求：</p>\n<ul><li>centos镜像具备vim + ifconfig + jdk8。</li></ul>\n<p>jdk8下载地址：<a href=\"https://mirrors.yangxingzhen.com/jdk/\">https://mirrors.yangxingzhen.com/jdk/</a></p>\n<p><strong>因为，安装一个jdk8环境。因此，下载要给jdk8压缩包，通过ADD保留字解压，通过ENV配置环境变量。</strong></p>\n<hr/>\n<p><strong>第一步：编写Dockerfile文件，注意开头的一定是大写的D。</strong></p>\n<p><strong>Dockerfile文件编写：</strong></p>\n<pre><code class=\"prism language-shell\">FROM centos\nMAINTAINER zzyy<span class=\"token operator\">&lt;</span>zzyybs@126.com<span class=\"token operator\">&gt;</span>\n\nENV MYPATH /usr/local\nWORKDIR <span class=\"token variable\">$MYPATH</span>\n\n<span class=\"token comment\">#安装vim编辑器</span>\nRUN yum -y <span class=\"token function\">install</span> <span class=\"token function\">vim</span>\n<span class=\"token comment\">#安装ifconfig命令查看网络IP</span>\nRUN yum -y <span class=\"token function\">install</span> net-tools\n<span class=\"token comment\">#安装java8及lib库</span>\nRUN yum -y <span class=\"token function\">install</span> glibc.i686\nRUN <span class=\"token function\">mkdir</span> /usr/local/java\n<span class=\"token comment\">#ADD 是相对路径jar,把jdk-8u171-linux-x64.tar.gz添加到容器中,安装包必须要和Dockerfile文件在同一位置</span>\nADD jdk-8u171-linux-x64.tar.gz /usr/local/java/\n<span class=\"token comment\">#配置java环境变量</span>\nENV JAVA_HOME /usr/local/java/jdk1.8.0_171\nENV JRE_HOME <span class=\"token variable\">$JAVA_HOME</span>/jre\nENV CLASSPATH <span class=\"token variable\">$JAVA_HOME</span>/lib/dt.jar:<span class=\"token variable\">$JAVA_HOME</span>/lib/tools.jar:<span class=\"token variable\">$JRE_HOME</span>/lib:<span class=\"token variable\">$CLASSPATH</span>\nENV <span class=\"token environment constant\">PATH</span> <span class=\"token variable\">$JAVA_HOME</span>/bin:<span class=\"token environment constant\">$PATH</span>\n\nEXPOSE <span class=\"token number\">80</span>\n\nCMD <span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$MYPATH</span>\n</code></pre>\n<p><strong>第二步：通过Dockerfile构建新镜像。</strong></p>\n<ul><li><strong>格式：docker build -t 新镜像名字:TAG . 别忘记后面还有个点。</strong></li></ul>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\c71d5d90f0f84b17b19f7ae837633965.png\"/></p>\n<p>构建的时候存在以下问题为解决！！！<img alt=\"在这里插入图片描述\" src=\"image\\135cf49d8ea442e58347bcf8eed333b5.png\"/></p>\n<p><strong>第三步：运行新镜像的容器。</strong></p>\n<ul><li><strong>格式：docker run -it 新景象名字:TAG</strong></li></ul>\n<h1><a id=\"9__322\"></a>9. 虚悬镜像</h1>\n<hr/>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\f4c389bdf4284108825892b61f10b322.png\"/></p>\n<p><strong>通过Dockerfile写一个虚悬镜像。</strong></p>\n<p><strong>第一步：vim Dockerfile 。</strong></p>\n<pre><code class=\"prism language-shell\">from ubuntu\nCMD <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'action is success'</span>\n</code></pre>\n<p><strong>第二步：docker build . 别忘记后面的点。</strong><br/> <img alt=\"在这里插入图片描述\" src=\"image\\c0f29c06529746d890f89a97613790f5.png\"/><br/> <strong>这样虚悬镜像就创建成功了。</strong><br/> <img alt=\"在这里插入图片描述\" src=\"image\\df50fb3e21924c9bba2efd67ef5e16d2.png\"/><br/> <strong>对于虚悬镜像一定要删除！</strong></p>\n<p><strong>第三步：通过docker image ls -f dangling=true命令可以查看当前镜像的所有虚悬镜像。</strong><br/> <img alt=\"在这里插入图片描述\" src=\"image\\016afff29c0448b99956cdb4dc27a5d9.png\"/></p>\n<p><strong>第四步：使用docker image prune命令来删除虚悬镜像。</strong><br/> <img alt=\"在这里插入图片描述\" src=\"image\\03490f962b844bdabe074211039e9690.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"image\\8226f4376b0f40249f89b5f082b44733.png\"/></p>\n<h1><a id=\"10_Docker__349\"></a>10. Docker 微服务实战</h1>\n<hr/>\n<p><strong>目的：将一个微服务部署到docker容器上。</strong></p>\n<p><strong>第一步：搭建一个springboot微服务项目。上传到linux服务器上面。</strong></p>\n<p><strong>第二步：编写Dockerfile文件。</strong></p>\n<pre><code class=\"prism language-shell\"><span class=\"token comment\"># 基础镜像使用java</span>\nFROM java:8\n<span class=\"token comment\"># 作者</span>\nMAINTAINER itholmes\n\n<span class=\"token comment\"># VOLUME 指定临时文件目录为/tmp，在主机/var/lib/docker目录下创建了一个临时文件并链接到容器的/tmp</span>\nVOLUME /tmp\n<span class=\"token comment\"># 将jar包添加到容器中并更名为zzyy_docker.jar</span>\nADD SSMProject-1.0-SNAPSHOT.jar itholmes_docker.jar\n<span class=\"token comment\"># 运行jar包</span>\nRUN <span class=\"token function\">bash</span> -c <span class=\"token string\">'touch /itholmes_docker.jar'</span>\nENTRYPOINT <span class=\"token punctuation\">[</span><span class=\"token string\">\"java\"</span>,<span class=\"token string\">\"-jar\"</span>,<span class=\"token string\">\"/itholmes_docker.jar\"</span><span class=\"token punctuation\">]</span>\n<span class=\"token comment\">#暴露6001端口作为微服务</span>\nEXPOSE <span class=\"token number\">6001</span>\n</code></pre>\n<p><strong>第三步：执行构建命令：docker build -t itholmes_docker:1.6 . (不要忘记后面的点)</strong><br/> <img alt=\"在这里插入图片描述\" src=\"image\\2ac91d2ebda14d02ab0c35612e4c7e14.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"image\\da53bd333c4d4555abeeba9e4b197eae.png\"/></p>\n<p><strong>第四步：运行刚刚创建好的容器镜像，docker run -d -p 6001:6001 镜像ID。</strong></p>\n<ul><li><strong>测试端口可以使用curl命令 来进行访问。</strong><br/> <img alt=\"在这里插入图片描述\" src=\"image\\0bd60ab1669148a0a1a26a90d3853595.png\"/></li></ul>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}