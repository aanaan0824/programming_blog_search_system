{"blogid": "125869840", "writerAge": "码龄1年", "writerBlogNum": "77", "writerCollect": "684", "writerComment": "1104", "writerFan": "919", "writerGrade": "5级", "writerIntegral": "3683", "writerName": "NO.-LL", "writerProfileAdress": "writer_image\\profile_125869840.jpg", "writerRankTotal": "5192", "writerRankWeekly": "191", "writerThumb": "1241", "writerVisitNum": "44488", "blog_read_count": "657", "blog_time": "已于 2022-08-16 22:51:26 修改", "blog_title": "进阶C++__STL__容器vector使用方法【简单易懂】", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"></p>\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"-toc\" style=\"margin-left:0px;\"></p>\n<p id=\"vector%E5%AE%B9%E5%99%A8-toc\" style=\"margin-left:0px;\"><a href=\"#vector%E5%AE%B9%E5%99%A8\">vector容器</a></p>\n<p id=\"vector%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:40px;\"><a href=\"#vector%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\">vector构造函数</a></p>\n<p id=\"vector%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C-toc\" style=\"margin-left:40px;\"><a href=\"#vector%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C\">vector赋值操作</a></p>\n<p id=\"vector%E5%AE%B9%E9%87%8F%E5%92%8C%E5%A4%A7%E5%B0%8F-toc\" style=\"margin-left:40px;\"><a href=\"#vector%E5%AE%B9%E9%87%8F%E5%92%8C%E5%A4%A7%E5%B0%8F\">vector容量和大小</a></p>\n<p id=\"vector%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4-toc\" style=\"margin-left:40px;\"><a href=\"#vector%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4\">vector插入和删除</a></p>\n<p id=\"vector%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96-toc\" style=\"margin-left:40px;\"><a href=\"#vector%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96\">vector数据存取</a></p>\n<p id=\"vector%E4%BA%92%E6%8D%A2%E5%AE%B9%E5%99%A8-toc\" style=\"margin-left:40px;\"><a href=\"#vector%E4%BA%92%E6%8D%A2%E5%AE%B9%E5%99%A8\">vector互换容器</a></p>\n<p id=\"vector%E9%A2%84%E7%95%99%E7%A9%BA%E9%97%B4-toc\" style=\"margin-left:40px;\"><a href=\"#vector%E9%A2%84%E7%95%99%E7%A9%BA%E9%97%B4\">vector预留空间</a></p>\n<p id=\"%C2%A0reserve%EF%BC%88%EF%BC%89%E7%9A%84%E5%AE%9E%E7%8E%B0-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A0reserve%EF%BC%88%EF%BC%89%E7%9A%84%E5%AE%9E%E7%8E%B0\"> reserve（）的实现</a></p>\n<p></p>\n<p id=\"vector%E7%9A%84%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-toc\" style=\"margin-left:0px;\"><a href=\"#vector%E7%9A%84%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0\">vector的增删查改的模拟实现</a></p>\n<p></p>\n<p id=\"%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE%E7%BB%83%E4%B9%A0%C2%A0-toc\" style=\"margin-left:0px;\"><a href=\"#%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE%E7%BB%83%E4%B9%A0%C2%A0\">经典题目练习 </a></p>\n<p id=\"1.%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92OJ-toc\" style=\"margin-left:40px;\"><a href=\"#1.%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92OJ\">1.杨辉三角OJ</a></p>\n<p id=\"2.%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9%20OJ-toc\" style=\"margin-left:40px;\"><a href=\"#2.%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9%20OJ\">2.删除排序数组中的重复项 OJ</a></p>\n<p id=\"3.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#3.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97%C2%A0\">3. 数组中出现次数超过一半的数字 </a></p>\n<p id=\"4.%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97-toc\" style=\"margin-left:40px;\"><a href=\"#4.%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97\">4.只出现一次的数字</a></p>\n<p id=\"5.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88-toc\" style=\"margin-left:40px;\"><a href=\"#5.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88\">5.电话号码字母组合</a></p>\n<p id=\"6.%C2%A0%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C%20%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#6.%C2%A0%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C%20%C2%A0\">6. 连续子数组的最大和  </a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h1 id=\"vector%E5%AE%B9%E5%99%A8\">vector容器</h1>\n<p></p>\n<h2 id=\"vector%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\">vector构造函数</h2>\n<blockquote>\n<ul><li><code>vector&lt;T&gt; v;</code> //采用模板实现类实现，默认构造函数</li><li><code>vector(v.begin(), v.end());</code> //将v[begin(), end())区间中的元素拷贝给本身。</li><li><code>vector(n, elem);</code> //构造函数将n个elem拷贝给本身。</li><li><code>vector(const vector &amp;vec);</code> //拷贝构造函数。</li></ul>\n</blockquote>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;string&gt; \nusing namespace std;\n\n#include &lt;vector&gt;\n\nvoid printVector(vector&lt;int&gt;&amp; v) {\n\n\tfor (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) {\n\t\tcout &lt;&lt; *it &lt;&lt; \" \";\n\t}\n\tcout &lt;&lt; endl;\n}\n\nvoid test01()\n{\n\tvector&lt;int&gt; v1; //无参构造 默认构造 \n\tfor (int i = 0; i &lt; 10; i++)\n\t{\n\t\tv1.push_back(i);\n\t}\n\tprintVector(v1);\n\t//通过区间方式构造 \n\tvector&lt;int&gt; v2(v1.begin(), v1.end());\n\tprintVector(v2);\n\t// n个元素e方式构造 \n\tvector&lt;int&gt; v3(10, 0);\n\tprintVector(v3);\n\t//拷贝构造 \n\tvector&lt;int&gt; v4(v3);\n\tprintVector(v4);\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n</code></pre>\n<blockquote>\n<p>输出：</p>\n<p>0 1 2 3 4 5 6 7 8 9<br/> 0 1 2 3 4 5 6 7 8 9<br/> 0 0 0 0 0 0 0 0 0 0<br/> 0 0 0 0 0 0 0 0 0 0</p>\n</blockquote>\n<p></p>\n<p></p>\n<p></p>\n<h2 id=\"vector%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C\">vector赋值操作</h2>\n<blockquote>\n<ul><li> <p><code>vector&amp; operator=(const vector &amp;vec);</code>//重载等号操作符</p> </li><li> <p><code>assign(beg, end);</code> //将[beg, end)区间中的数据拷贝赋值给本身。</p> </li><li> <p><code>assign(n, elem);</code> //将n个elem拷贝赋值给本身。</p> </li></ul>\n</blockquote>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;string&gt; \nusing namespace std;\n#include &lt;vector&gt;\n\nvoid printVector(vector&lt;int&gt;&amp; v) {\n\n\tfor (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) {\n\t\tcout &lt;&lt; *it &lt;&lt; \" \";\n\t}\n\tcout &lt;&lt; endl;\n}\n\n//赋值操作\nvoid test01()\n{\n\tvector&lt;int&gt; v1; //无参构造\n\tfor (int i = 0; i &lt; 10; i++)\n\t{\n\t\tv1.push_back(i);\n\t}\n\tprintVector(v1);\n\n\tvector&lt;int&gt;v2;\n\tv2 = v1;\n\tprintVector(v2);\n\n\tvector&lt;int&gt;v3;\n\tv3.assign(v1.begin(), v1.end());\n\tprintVector(v3);\n\n\tvector&lt;int&gt;v4;\n\tv4.assign(10, 100);\n\tprintVector(v4);\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n\n\n</code></pre>\n<blockquote>\n<p>输出：</p>\n<p>0 1 2 3 4 5 6 7 8 9<br/> 0 1 2 3 4 5 6 7 8 9<br/> 0 1 2 3 4 5 6 7 8 9<br/> 100 100 100 100 100 100 100 100 100 100</p>\n</blockquote>\n<p></p>\n<h2 id=\"vector%E5%AE%B9%E9%87%8F%E5%92%8C%E5%A4%A7%E5%B0%8F\">vector容量和大小</h2>\n<blockquote>\n<ul><li> <p><code>empty();</code> //判断容器是否为空</p> </li><li> <p><code>capacity();</code> //容器的容量</p> </li><li> <p><code>size();</code> //返回容器中元素的个数</p> </li><li> <p><code>resize(int num);</code> //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。</p> <p>​ //如果容器变短，则末尾超出容器长度的元素被删除。</p> </li><li> <p><code>resize(int num, elem);</code> //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。</p> <p>​ //如果容器变短，则末尾超出容器长度的元素被删除</p> </li></ul>\n</blockquote>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;string&gt; \nusing namespace std;\n#include &lt;vector&gt;\n\nvoid printVector(vector&lt;int&gt;&amp; v) {\n\n\tfor (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) {\n\t\tcout &lt;&lt; *it &lt;&lt; \" \";\n\t}\n\tcout &lt;&lt; endl;\n}\n\nvoid test01()\n{\n\tvector&lt;int&gt; v1;\n\tfor (int i = 0; i &lt; 10; i++)\n\t{\n\t\tv1.push_back(i);\n\t}\n\tprintVector(v1);\n\tif (v1.empty())\n\t{\n\t\tcout &lt;&lt; \"v1为空\" &lt;&lt; endl;\n\t}\n\telse\n\t{\n\t\tcout &lt;&lt; \"v1不为空\" &lt;&lt; endl;\n\t\tcout &lt;&lt; \"v1的容量 = \" &lt;&lt; v1.capacity() &lt;&lt; endl;\n\t\tcout &lt;&lt; \"v1的大小 = \" &lt;&lt; v1.size() &lt;&lt; endl;\n\t}\n\n\t//resize 重新指定大小 ，若指定的更大，默认用0填充新位置，可以利用重载版本替换默认填充\n\tv1.resize(15,10);\n\tprintVector(v1);\n\n\t//resize 重新指定大小 ，若指定的更小，超出部分元素被删除\n\tv1.resize(5);\n\tprintVector(v1);\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n\n\n\n</code></pre>\n<p><img alt=\"\" height=\"235\" src=\"image\\c2dce1b1d6444be78b717b8732b2ee85.png\" width=\"468\"/></p>\n<p></p>\n<p></p>\n<p></p>\n<h2 id=\"vector%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4\">vector插入和删除</h2>\n<blockquote>\n<ul><li><code>push_back(ele);</code> //尾部插入元素ele</li><li><code>pop_back();</code> //删除最后一个元素</li><li><code>insert(const_iterator pos, ele);</code> //迭代器指向位置pos插入元素ele</li><li><code>insert(const_iterator pos, int count,ele);</code>//迭代器指向位置pos插入count个元素ele</li><li><code>erase(const_iterator pos);</code> //删除迭代器指向的元素</li><li><code>erase(const_iterator start, const_iterator end);</code>//删除迭代器从start到end之间的元素</li><li><code>clear();</code> //删除容器中所有元素</li></ul>\n</blockquote>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;string&gt; \nusing namespace std;\n\n#include &lt;vector&gt;\n\nvoid printVector(vector&lt;int&gt;&amp; v) {\n\n\tfor (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) {\n\t\tcout &lt;&lt; *it &lt;&lt; \" \";\n\t}\n\tcout &lt;&lt; endl;\n}\n\n//插入和删除\nvoid test01()\n{\n\tvector&lt;int&gt; v1;\n\t//尾插\n\tv1.push_back(10);\n\tv1.push_back(20);\n\tv1.push_back(30);\n\tv1.push_back(40);\n\tv1.push_back(50);\n\tprintVector(v1);\n\t//尾删\n\tv1.pop_back();\n\tprintVector(v1);\n\t//插入\n\tv1.insert(v1.begin(), 100);\n\tprintVector(v1);\n\n\tv1.insert(v1.begin(), 2, 1000);\n\tprintVector(v1);\n\n\t//删除\n\tv1.erase(v1.begin());\n\tprintVector(v1);\n\n\t//清空\n\tv1.erase(v1.begin(), v1.end());\n\tv1.clear();\n\tprintVector(v1);\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n\n\n</code></pre>\n<blockquote>\n<p>输出：</p>\n<p>10 20 30 40 50<br/> 10 20 30 40<br/> 100 10 20 30 40<br/> 1000 1000 100 10 20 30 40<br/> 1000 100 10 20 30 40</p>\n</blockquote>\n<p></p>\n<p></p>\n<h2 id=\"vector%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96\">vector数据存取</h2>\n<blockquote>\n<ul><li><code>at(int idx);</code> //返回索引idx所指的数据</li><li><code>operator[];</code> //返回索引idx所指的数据</li><li><code>front();</code> //返回容器中第一个数据元素</li><li><code>back();</code> //返回容器中最后一个数据元素</li></ul>\n</blockquote>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;string&gt; \nusing namespace std;\n#include &lt;vector&gt;\n\nvoid test01()\n{\n\tvector&lt;int&gt;v1;\n\tfor (int i = 0; i &lt; 10; i++)\n\t{\n\t\tv1.push_back(i);\n\t}\n\n\tfor (int i = 0; i &lt; v1.size(); i++)\n\t{\n\t\tcout &lt;&lt; v1[i] &lt;&lt; \" \";\n\t}\n\tcout &lt;&lt; endl;\n\n\tfor (int i = 0; i &lt; v1.size(); i++)\n\t{\n\t\tcout &lt;&lt; v1.at(i) &lt;&lt; \" \";\n\t}\n\tcout &lt;&lt; endl;\n\n\tcout &lt;&lt; \"v1的第一个元素为： \" &lt;&lt; v1.front() &lt;&lt; endl;\n\tcout &lt;&lt; \"v1的最后一个元素为： \" &lt;&lt; v1.back() &lt;&lt; endl;\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n\n</code></pre>\n<blockquote>\n<p>输出：</p>\n<p>0 1 2 3 4 5 6 7 8 9<br/> 0 1 2 3 4 5 6 7 8 9<br/> v1的第一个元素为： 0<br/> v1的最后一个元素为： 9</p>\n</blockquote>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<h2 id=\"vector%E4%BA%92%E6%8D%A2%E5%AE%B9%E5%99%A8\">vector互换容器</h2>\n<blockquote>\n<ul><li><code>swap(vec);</code> // 将vec与本身的元素互换</li></ul>\n</blockquote>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;string&gt; \nusing namespace std;\n#include &lt;vector&gt;\n\nvoid printVector(vector&lt;int&gt;&amp; v) {\n\n\tfor (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) {\n\t\tcout &lt;&lt; *it &lt;&lt; \" \";\n\t}\n\tcout &lt;&lt; endl;\n}\n\nvoid test01()\n{\n\tvector&lt;int&gt;v1;\n\tfor (int i = 0; i &lt; 10; i++)\n\t{\n\t\tv1.push_back(i);\n\t}\n\tprintVector(v1);\n\n\tvector&lt;int&gt;v2;\n\tfor (int i = 10; i &gt; 0; i--)\n\t{\n\t\tv2.push_back(i);\n\t}\n\tprintVector(v2);\n\n\t//互换容器\n\tcout &lt;&lt; \"互换后\" &lt;&lt; endl;\n\tv1.swap(v2);\n\tprintVector(v1);\n\tprintVector(v2);\n}\n\nvoid test02()\n{\n\tvector&lt;int&gt; v;\n\tfor (int i = 0; i &lt; 100000; i++) {\n\t\tv.push_back(i);\n\t}\n\n\tcout &lt;&lt; \"v的容量为：\" &lt;&lt; v.capacity() &lt;&lt; endl;\n\tcout &lt;&lt; \"v的大小为：\" &lt;&lt; v.size() &lt;&lt; endl;\n\n\tv.resize(3);\n\n\tcout &lt;&lt; \"v的容量为：\" &lt;&lt; v.capacity() &lt;&lt; endl;\n\tcout &lt;&lt; \"v的大小为：\" &lt;&lt; v.size() &lt;&lt; endl;\n\n\t//收缩内存\n\tvector&lt;int&gt;(v).swap(v); //匿名对象\n\n\tcout &lt;&lt; \"v的容量为：\" &lt;&lt; v.capacity() &lt;&lt; endl;\n\tcout &lt;&lt; \"v的大小为：\" &lt;&lt; v.size() &lt;&lt; endl;\n}\n\nint main() {\n\n\ttest01();\n\n\ttest02();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n\n\n</code></pre>\n<blockquote>\n<p>输出：</p>\n<p>0 1 2 3 4 5 6 7 8 9<br/> 10 9 8 7 6 5 4 3 2 1<br/> 互换后<br/> 10 9 8 7 6 5 4 3 2 1<br/> 0 1 2 3 4 5 6 7 8 9<br/> v的容量为：131072<br/> v的大小为：100000<br/> v的容量为：131072<br/> v的大小为：3<br/> v的容量为：3<br/> v的大小为：3</p>\n</blockquote>\n<p>总结：swap可以使两个容器互换，可以达到实用的<strong>收缩内存</strong>效果</p>\n<p></p>\n<p></p>\n<h2 id=\"vector%E9%A2%84%E7%95%99%E7%A9%BA%E9%97%B4\">vector预留空间</h2>\n<blockquote>\n<p><code>reserve(int len);</code>//容器预留len个元素长度，预留位置不初始化，元素不可访问。</p>\n</blockquote>\n<p>vector开辟空间原理：</p>\n<p>当空间不够时，会重新开辟一块更大的空间，将原来空间内容拷贝到这个更大的空间，并指向这块空间；<img alt=\"\" height=\"472\" src=\"image\\ad12a0b12e0547febf47e1742b98899e.png\" width=\"882\"/></p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;string&gt; \nusing namespace std;\n#include &lt;vector&gt;\n\nvoid test01()\n{\n\tvector&lt;int&gt; v;\n\n\t//预留空间\n\t//v.reserve(100000);\n\n\tint num = 0;\n\tint* p = NULL;\n\tfor (int i = 0; i &lt; 100000; i++) {\n\t\tv.push_back(i);\n\t\tif (p != &amp;v[0]) {\n\t\t\tp = &amp;v[0];\n\t\t\tnum++;\n\t\t}\n\t}\n\n\tcout &lt;&lt; \"num:\" &lt;&lt; num &lt;&lt; endl;\n}\n\nint main() {\n\n\ttest01();\n    \n\tsystem(\"pause\");\n\n\treturn 0;\n}\n\n\n</code></pre>\n<blockquote>\n<p>输出：（不同编译器结果不同）</p>\n<p> num:18</p>\n</blockquote>\n<p>利用开辟空间原理判断指向的地址是否改变，我们发现vector存100000个元素时要改变18次，即重新开辟并拷贝18次；这样非常耗费时间；</p>\n<p>当我们使用reserve直接预留100000空间时，则只需要一次，非常节约时间</p>\n<h3 id=\"%C2%A0reserve%EF%BC%88%EF%BC%89%E7%9A%84%E5%AE%9E%E7%8E%B0\"> reserve（）的实现</h3>\n<pre><code class=\"language-cpp\">/* reserve */\nvoid reserve(size_t new_capacity) {\n\tif (new_capacity &gt; capacity()) {  \t\t\t// 检查是否真的需要扩容\n\t\tif (_finish == _eos) {\n\t\t\tsize_t sz = size();   // 提前把size算好\n \n\t\t\tT* tmp = new T[new_capacity];\n\t\t\tif (_start) {\n\t\t\t\t// memcpy(tmp, _start, sizeof(T) * size());   有问题！\n \n\t\t\t\t\t//自己把原空间的数据拷贝到新空间\n\t\t\t\tfor (size_t i = 0; i &lt; sz; i++) { \n\t\t\t\t\t// 如果T是int，一个一个拷贝没问题\n\t\t\t\t\t// 如果T是string等自定义问题，一个一个拷贝调用的是T的深拷贝，也不会出问题。\n\t\t\t\t\ttmp[i] = _start[i];  \n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\tdelete[] _start;                          // 并释放原有的旧空间\n\t\t\t}\n \n\t\t\t_start = tmp;                    // 指向新空间\n\t\t\t_finish = tmp + sz;\t\t\t     // 现场算size() 会有问题，因为start已经被更新成tmp了\n\t\t\t_eos = _start + new_capacity;\n\t\t}\n\t}\n}</code></pre>\n<p></p>\n<p></p>\n<p></p>\n<h1>vector迭代器失效问题</h1>\n<h3>1、缺位删除</h3>\n<p>下面这个代码输出的是？</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main(void)\n\n{\n\n\tvector&lt;int&gt;array;\n\n\tarray.push_back(100);\n\n\tarray.push_back(300);\n\n\tarray.push_back(300);\n\n\tarray.push_back(300);\n\n\tarray.push_back(300);\n\n\tarray.push_back(500);\n\n\tvector&lt;int&gt;::iterator itor;\n\n\tfor (itor = array.begin(); itor != array.end(); itor++)\n\n\t{\n\n\t\tif (*itor == 300)\n\n\t\t{\n\n\t\t\titor = array.erase(itor);\n\n\t\t}\n\n\t}\n\n\tfor (itor = array.begin(); itor != array.end(); itor++)\n\n\t{\n\n\t\tcout &lt;&lt; *itor &lt;&lt; \" \";\n\n\t}\n\n\treturn 0;\n\n}</code></pre>\n<blockquote>\n<p> 100 500 ？？错误！！</p>\n<p></p>\n<p> for(itor=array.begin();itor!=array.end();itor++)</p>\n<p>{<!-- --></p>\n<p>        if(* itor==300) //向量的数据为300时进行删除</p>\n<p>        {<!-- --></p>\n<p>                //删除之后迭代器进行返回赋值，不会导致迭代器失效，删除当前数据，</p>\n<p>                //后面的数据相当于会向前移动,此时itor还是指向下一个300数据，</p>\n<p>                //但是由于循环回去，for循环末尾itor++会让迭代器指向下一个</p>\n<p>                //数据，因此会错失一次300的比较判断</p>\n<p>                itor=array.erase(itor);</p>\n<p>        }</p>\n<p>}</p>\n<p>所以答案为: 100 300 300 500 </p>\n</blockquote>\n<p></p>\n<h3>2、删除导致迭代器失效</h3>\n<p>结果是？</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main()\n\n{\n\n\tint ar[] = { 1,2,3,4,0,5,6,7,8,9 };\n\n\tint n = sizeof(ar) / sizeof(int);\n\n\tvector&lt;int&gt; v(ar, ar + n);\n\n\tvector&lt;int&gt;::iterator it = v.begin();\n\n\twhile (it != v.end())\n\n\t{\n\n\t\tif (*it != 0)\n\n\t\t\tcout &lt;&lt; *it;\n\n\t\telse\n\t\t{\n\t\t\tv.erase(it);\n\t\t\t*it=5;\n\t\t}\n\t\tit++;\n\t}\n\n\treturn 0;\n\n}\n\n</code></pre>\n<blockquote>\n<p>A.程序运行崩溃</p>\n<p>B.1 2 3 4 5 0 6 7 8 9</p>\n<p>C.1 2 3 4 5 6 7 8 9</p>\n<p>D.1 2 3 4 6 7 8 9</p>\n<hr/>\n<p>分析:当迭代器的值为0时，此时会进行删除，删除后如果迭代器不重新赋值，会导致原来的迭代器失效，此时针对一个已经失效的迭代器在进行++,会导致程序崩溃</p>\n<p>故答案为A</p>\n</blockquote>\n<hr/>\n<p></p>\n<h1 id=\"vector%E7%9A%84%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0\">vector的增删查改的模拟实现</h1>\n<p>函数接口：</p>\n<pre><code class=\"language-cpp\">namespace bit\n\n{\n\n  template&lt;class T&gt;\n\n  class vector\n\n  {\n\n  public:\n\n    // Vector的迭代器是一个原生指针\n\n    typedef T* iterator；\n\n    typedef const T* const_iterator；\n\n    iterator begin()；\n\n    iterator end()；\n\n    const_iterator cbegin()；\n\n    const_iterator cend() const；\n\n\n\n    // construct and destroy\n\n    vector()；\n\n    vector(int n, const T&amp; value = T())；\n\n    template&lt;class InputIterator&gt;\n\n    vector(InputIterator first, InputIterator last)；\n\n    vector(const vector&lt;T&gt;&amp; v)；\n\n    vector&lt;T&gt;&amp; operator= (vector&lt;T&gt; v)；\n\n    ~vector()；\n\n    // capacity\n\n    size_t size() const ；\n\n    size_t capacity() const；\n\n    void reserve(size_t n)；\n\n    void resize(size_t n, const T&amp; value = T())；\n\n\n\n    ///access///\n\n    T&amp; operator[](size_t pos)；\n\n    const T&amp; operator[](size_t pos)const；\n\n\n\n    ///modify/\n\n    void push_back(const T&amp; x)；\n\n    void pop_back()；\n\n    void swap(vector&lt;T&gt;&amp; v)；\n\n    iterator insert(iterator pos, const T&amp; x)；\n\n    iterator erase(Iterator pos)；\n\n  private:\n\n    iterator _start; // 指向数据块的开始\n\n    iterator _finish; // 指向有效数据的尾\n\n    iterator _endOfStorage; // 指向存储容量的尾\n\n  };\n\n}</code></pre>\n<p> 模拟实现</p>\n<pre><code class=\"language-cpp\">namespace bit\n{\n  template&lt;class T&gt;\n  class vector\n  {\n  public:\n    // Vector的迭代器是一个原生指针\n\n    typedef T* iterator；\n\n    typedef const T* const_iterator；\n\n    iterator begin()\n    {\n      return _start;\n    }\n    iterator end()\n    {\n      return _finish;\n    }\n    const_iterator cbegin()const\n    {\n      return _start;\n    }\n    const_iterator cend() const\n    {\n      return _finish;\n    }\n\n\n    // construct and destroy\n    vector(): _start(nullptr), _finish(nullptr), _endOfStorage(nullptr)\n    {}\n    vector(int n, const T&amp; value = T())\n      : _start(nullptr), _finish(nullptr),_endOfStorage(nullptr)\n    {\n      reserve(n);\n      while (n--)\n      {\n        push_back(value);\n      }\n    }\n\n    template&lt;class InputIterator&gt;\n\n    vector(InputIterator first, InputIterator last)\n    {\n      reserve(last - first);\n      while (first != last)\n      {\n        push_back(*first);\n        ++first;\n      }\n    }\n\n    vector(const vector&lt;T&gt;&amp; v)\n      : _start(nullptr), _finish(nullptr), _endOfStorage(nullptr)\n    {\n      reserve(v.capacity());\n      iterator it = begin();\n      const_iterator vit = v.cbegin();\n      while (vit != v.cend())\n      {\n       *it++ = *vit++;\n      }\n      _finish = _start + v.size();\n      _endOfStorage = _start + v.capacity();\n    }\n\n    vector&lt;T&gt;&amp; operator= (vector&lt;T&gt; v)\n    {\n      swap(v);\n      return *this;\n    }\n\n    ~vector()\n    {\n      delete[] _start;\n      _start = _finish = _endOfStorage = nullptr;\n    }\n\n\n    // capacity\n    size_t size() const \n    {\n      return _finish - _start;\n    }\n\n    size_t capacity() const\n    {\n      return _endOfStorage - _start;\n    }\n\n    void reserve(size_t n)\n    {\n\n      if (n &gt; capacity())\n      {\n        size_t oldSize = size();\n        T* tmp = new T[n];\n        if (_start)\n        {\n          for (size_t i = 0; i &lt; oldSize; ++i)\n          tmp[i] = _start[i];\n        }\n        _start = tmp;\n        _finish = _start + size;\n        _endOfStorage = _start + n;\n      }\n\n    }\n\n    void resize(size_t n, const T&amp; value = T())\n    {\n      // 1.如果n小于当前的size，则数据个数缩小到n\n      if (n &lt;= size())\n      {\n        _finish = _start + n;\n        return;\n      }\n\n      // 2.空间不够则增容\n      if (n &gt; capacity())\n       reserve(n);\n\n      // 3.将size扩大到n\n      iterator it = _finish;\n      iterator _finish = _start + n;\n      while (it != _finish)\n      {\n        *it = value;\n        ++it;\n      }\n    }\n\n    ///access///\n\n    T&amp; operator[](size_t pos)\n    {\n      return _start[pos];\n    }\n\n    const T&amp; operator[](size_t pos)const\n    {\n      return _start[pos];\n    }\n\n\n    ///modify/\n\n    void push_back(const T&amp; x)\n    {\n      insert(end(), x);\n    }\n\n    void pop_back()\n    {\n      erase(--end());\n    }\n\n    void swap(vector&lt;T&gt;&amp; v)\n    {\n      swap(_start, v._start);\n      swap(_finish, v._finish);\n      swap(_endOfStorage, v._endOfStorage);\n    }\n\n    iterator insert(iterator pos, const T&amp; x)\n    {\n      assert(pos &lt;= _finish);\n\n      // 空间不够先进行增容\n      if (_finish == _endOfStorage)\n      {\n        size_t size = size();\n        size_t newCapacity = (0 == capacity())? 1 : capacity() * 2;\n        reserve(newCapacity);\n\n        // 如果发生了增容，需要重置pos\n        pos = _start + size;\n      }\n\n      iterator end = _finish - 1;\n      while (end &gt;= pos)\n      {\n        *(end + 1) = *end;\n        --end;\n      }\n      *pos = x;\n      ++_finish;\n      return pos;\n    }\n\n\n    // 返回删除数据的下一个数据\n\n// 方便解决:一边遍历一边删除的迭代器失效问题\n\n    iterator erase(Iterator pos)\n    {\n      // 挪动数据进行删除\n      iterator begin = pos + 1;\n      while (begin != _finish) \n      {\n        *(begin - 1) = *begin;\n        ++begin;\n      }\n      --_finish;\n      return pos;\n    }\n  private:\n    iterator _start; // 指向数据块的开始\n    iterator _finish; // 指向有效数据的尾\n    iterator _endOfStorage; // 指向存储容量的尾\n\n  };\n\n}</code></pre>\n<p></p>\n<h1 id=\"%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE%E7%BB%83%E4%B9%A0%C2%A0\">经典题目练习 </h1>\n<h2 id=\"1.%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92OJ\">1.<span style=\"color:#4183c4;\">杨辉三角</span><span style=\"color:#4183c4;\">OJ</span></h2>\n<p><img alt=\"\" height=\"981\" src=\"image\\c898850bfa7c4107b15919a168363581.png\" width=\"839\"/></p>\n<blockquote>\n<p>模拟；练一练二维vector </p>\n</blockquote>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; generate(int numRows) {\n        vector&lt;vector&lt;int&gt;&gt; vv;\n        vv.resize(numRows);\n        for(size_t i=1;i&lt;=numRows;i++)\n        {\n            vv[i-1].resize(i,0);\n\n            vv[i-1][0]=1;\n            vv[i-1][i-1]=1;\n        }\n\n        for(int i=0;i&lt;vv.size();i++)\n        {\n            for(int j=0;j&lt;vv[i].size();j++){\n                if(vv[i][j]==0)\n                {\n                    vv[i][j]=vv[i-1][j]+vv[i-1][j-1];\n                }\n            }\n        }\n        return vv;\n    }\n};</code></pre>\n<p></p>\n<p></p>\n<h2 id=\"2.%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9%20OJ\"><span style=\"color:#4183c4;\">2.删除排序数组中的重复项</span><span style=\"color:#4183c4;\"> OJ </span></h2>\n<p><img alt=\"\" height=\"733\" src=\"image\\d3a528bf477a462482789a580558108d.png\" width=\"840\"/></p>\n<blockquote>\n<p> 快慢指针：</p>\n<p>所谓快：不加条件判断的数组下标累计<br/> 所谓慢：加上条件判断的数组下标累计</p>\n</blockquote>\n<div>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int removeDuplicates(vector&lt;int&gt;&amp; nums) {\n        int n=nums.size();\n        if(n==0){\n            return 0;\n        }\n        int fast=1,slow=1;\n        while(fast&lt;n)\n        {\n            if(nums[fast]!=nums[fast-1]){\n                nums[slow]=nums[fast];\n                slow++;\n            }\n            fast++;\n        }\n        return slow;\n    }\n};</code></pre>\n<p></p>\n</div>\n<div></div>\n<h2 id=\"3.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97%C2%A0\"><span style=\"color:#777777;\">3. </span><span style=\"color:#4183c4;\">数组中出现次数超过一半的数字</span><span style=\"color:#4183c4;\"> </span></h2>\n<p><img alt=\"\" height=\"903\" src=\"image\\cd5c5f7052984799a327b5e228507aec.png\" width=\"1088\"/></p>\n<blockquote>\n<p><strong>最优解：<span style=\"color:#fe2c24;\">候选法</span> </strong></p>\n<p>思想就是：如果两个数不相等，就消去这两个数，最坏情况下，每次消去一个众数和一个非众数，那么如果存在众数，最后留下的数肯定是众数（因为超过数组一半）。</p>\n<ol><li>假设cond为候选人，cnt为票数（要找到票最多的当选）；</li><li>如果cnt为0，说明没有候选人或者该候选人票不够选不了；</li><li>否则，如果cnt &gt; 0, 表示有候选人，如果当前数=cond，则++cnt，否则--cnt</li></ol>\n</blockquote>\n<div>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers) {\n        int cond = 0;\n        int cnt = 0;\n        for (int i=0; i&lt;numbers.size(); ++i) \n        {\n            if (cnt == 0) \n            {\n                cond = numbers[i];\n                ++cnt;\n            }\n            else\n            {\n                if (cond == numbers[i]) ++cnt;\n                else --cnt;\n            }\n        }\n        return cond;\n    }\n};</code></pre>\n<p></p>\n<p></p>\n</div>\n<h2 id=\"4.%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97\"><a href=\"https://leetcode.cn/problems/single-number/\" title=\"4.只出现一次的数字\">4.只出现一次的数字</a></h2>\n<p><img alt=\"\" height=\"480\" src=\"image\\3a918d89287548739e6e825560adf380.png\" width=\"1047\"/></p>\n<blockquote>\n<p>不需要额外空间的方法，就往位运算上想</p>\n<ol><li> <p>交换律：a ^ b ^ c &lt;=&gt; a ^ c ^ b</p> </li><li> <p>任何数于0异或为任何数 0 ^ n =&gt; n</p> </li><li> <p>相同的数异或为0: n ^ n =&gt; 0</p> </li></ol>\n</blockquote>\n<div>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int singleNumber(vector&lt;int&gt;&amp; nums) {\n        int ret=0;\n        for(auto e:nums)\n            ret^=e;\n        return ret;\n    }\n};</code></pre>\n<p></p>\n</div>\n<h2 id=\"5.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88\"><span style=\"color:#777777;\">5.</span><span style=\"color:#4183c4;\">电话号码字母组合</span></h2>\n<p><img alt=\"\" height=\"878\" src=\"image\\8556e549f286474a8a9149b1eced3402.png\" width=\"883\"/></p>\n<p><img alt=\"\" height=\"417\" src=\"image\\9f914ece2ee742f09346a390419665c6.png\" width=\"703\"/></p>\n<blockquote>\n<p> 思路：</p>\n<p>由题意知就是把字母一一组合；</p>\n<ol><li>首先使用哈希表存储每个数字对应的所有可能的字母，然后进行回溯操作</li><li>假设输入“234”，进入递归，首先获得str第一个字符‘2’然后转成数字，取数字映射的字符串</li><li>开始遍历字符“abc”，刚取到‘a’时再进入递归取第二个字符‘3’，取数字映射的字符串“def”后开始遍历，以此类推我们的combineStr为“adg”</li><li>取到“adg”时就到顶了，利用di==digits.size()判断，将取到的组合数保存到retV并开始回溯；</li><li>由auto ch : str 我们会遍历“ghi”，按照上述同理方法得到“adh”,“adi”，然后回溯到第二次取‘e’，同理得“aeg”，“aeh”，“aei”</li><li>最终取到3*3*3种排列</li></ol>\n<p>回溯算法用于寻找所有的可行解，如果发现一个解不可行，则会舍弃不可行的解。在这道题中，由于每个数字对应的每个字母都可能进入字母组合，因此不存在不可行的解，直接穷举所有的解即可。</p>\n</blockquote>\n<pre><code class=\"language-cpp\">class Solution {\n    string nums[10]={\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\npublic:\n    void Combine(string digits,int di,string combineStr,vector&lt;string&gt;&amp; retV)\n    {\n        if(di==digits.size())\n        {\n            retV.push_back(combineStr);\n            return;\n        }\n        int num=digits[di]-'0';\n        string str=nums[num];\n\n        for(auto ch:str)\n        {\n            Combine(digits,di+1,combineStr+ch,retV);\n        }\n    }\n    vector&lt;string&gt; letterCombinations(string digits) {\n        vector&lt;string&gt; retV;\n        if(digits.empty())\n            return retV;\n        int i=0;\n        string str;\n        Combine(digits,i,str,retV);\n        return retV;\n    }\n};</code></pre>\n<p>顺手打败全国的人~~ </p>\n<p><img alt=\"\" height=\"434\" src=\"image\\5da1f0e6304e4a25a0f57493a983b17d.png\" width=\"1200\"/></p>\n<p></p>\n<p></p>\n<div></div>\n<h2 id=\"6.%C2%A0%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C%20%C2%A0\"><span style=\"color:#777777;\">6. </span><span style=\"color:#4183c4;\">连续子数组的最大和</span><span style=\"color:#4183c4;\"> </span> </h2>\n<div></div>\n<div>\n<p><img alt=\"\" height=\"767\" src=\"image\\b6597488ad694597a650c675175f63e2.png\" width=\"1200\"/></p>\n</div>\n<blockquote>\n 经典动态规划 \n <ul><li>step 1：可以用dp数组表示以下标 i 为终点的最大连续子数组和。</li><li>step 2：遍历数组，每次遇到一个新的数组元素，连续的子数组要么加上变得更大，要么这个元素本身就更大，要么会更小，更小我们就舍弃，因此状态转移为dp[i]=max(dp[i−1]+array[i],array[i])                                                                                  </li><li>step 3：因为连续数组可能会断掉，每一段只能得到该段最大值，因此我们需要维护一个最大值。</li></ul>\n</blockquote>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int FindGreatestSumOfSubArray(vector&lt;int&gt; array) {\n        vector&lt;int&gt; dp(array.size(),0);\n        dp[0]=array[0];\n        int maxv=dp[0];\n        for(int i=1;i&lt;array.size();i++)\n        {\n            dp[i]=max(dp[i-1]+array[i],array[i]);\n            maxv=max(maxv,dp[i]);\n        }\n        return maxv;\n    }\n};</code></pre>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n</div>\n</div>"}