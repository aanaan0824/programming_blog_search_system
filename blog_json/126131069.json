{"blogid": "126131069", "writerAge": "码龄15年", "writerBlogNum": "452", "writerCollect": "5628", "writerComment": "2679", "writerFan": "24805", "writerGrade": "7级", "writerIntegral": "16476", "writerName": "Hann Yang", "writerProfileAdress": "writer_image\\profile_126131069.jpg", "writerRankTotal": "550", "writerRankWeekly": "199", "writerThumb": "5948", "writerVisitNum": "643890", "blog_read_count": "1439", "blog_time": "已于 2022-08-05 21:46:41 修改", "blog_title": "Python 生命游戏（tkinter版）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h1>生命游戏(Game of Life)</h1>\n<p>由剑桥大学约翰·何顿·康威设计的计算机程序。美国趣味数学大师马丁·加德纳(Martin Gardner，1914-2010）通过《科学美国人》杂志，将康威的生命游戏介绍给学术界之外的广大渎者，一时吸引了各行各业一大批人的兴趣，这时细胞自动机课题才吸引了科学家的注意。</p>\n<h2>游戏概述</h2>\n<p>用一个二维表格表示“生存空间”，空间的每个方格中都可放置一个生命细胞，每个生命细胞只有两种状态：“生”或“死”。用绿色方格表示该细胞为“生”，空格(白色)表示该细胞为“死”。或者说方格网中绿色部分表示某个时候某种“生命”的分布图。生命游戏想要模拟的是：随着时间的流逝，这个分布图将如何一代一代地变化。死亡太沉重，我想称它为“湮灭”状态。</p>\n<h2>生存定律</h2>\n<p>生存空间的每个方格都存在一个细胞，它的周边紧邻的8个方格上的称为邻居细胞。<br/> (1)当前细胞为湮灭状态时，当周围有３个存活细胞时，则迭代后该细胞变成存活状态(模拟繁殖)。<br/> (2)当前细胞为存活状态时，当周围的邻居细胞少于２个存活时，该细胞变成湮灭状态(数量稀少)。<br/> (3)当前细胞为存活状态时，当周围有３个以上的存活细胞时，该细胞变成湮灭状态(数量过多)。<br/> (4)当前细胞为存活状态时，当周围有２个或３个存活细胞时，该细胞保持原样。</p>\n<p>简单来说，活细胞Cell看作是‘1’，死Cell看作‘0’，8个邻居的累加和Sum决定了下一轮的状态：</p>\n<p>“繁殖”：<strong>死</strong>Cell=0，若Sum=3，则Cell=1。<br/> “稀少”：<strong>活</strong>Cell=1，若Sum&lt;2，则Cell=0。<br/> “过多”：<strong>活</strong>Cell=1，若Sum&gt;3，则Cell=0。<br/> “正常”：<strong>活</strong>Cell=1，若Sum=2或3，则Cell=1。</p>\n<p>生存空间中生命的繁殖和湮灭，如下图所示：</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/ea76cf45cbe740409e754e3292587b10.gif\"/></p>\n<h2>图形结构</h2>\n<p>在游戏进行中，杂乱无序的细胞会逐渐演化出各种精致、有形的图形结构；这些结构往往有很好的对称性，而且每一代都在变化形状。一些形状一经锁定就不会逐代变化。有时，一些已经成形的结构会因为一些无序细胞的“入侵”而被破坏。但是形状和秩序经常能从杂乱中产生出来。</p>\n<p><strong>通常会有以下四种状态：</strong></p>\n<p><strong>不动点（fixed points）</strong>：变化终结于恒定图像<br/><strong>交替态（alternation）</strong>：图像出现周期性变化<br/><strong>随机态（randomness）</strong>：图像变化近乎随机<br/><strong>复杂态（complexity）</strong>：图像存在某种复杂规律</p>\n<p>常见的不动结构：</p>\n<p><img alt=\"\" height=\"114\" src=\"image\\aefc5e1438e3427dbc0a6f618db2973a.png\" width=\"610\"/></p>\n<p>周期变化的结构：</p>\n<p style=\"text-align:center;\"><img alt=\"\" class=\"left\" src=\"https://img-blog.csdnimg.cn/f0c49f1081a740bca2af30a8c3c388bd.gif\"/></p>\n<p>逐步趋向湮灭的结构：</p>\n<p style=\"text-align:center;\"><img alt=\"\" class=\"left\" src=\"https://img-blog.csdnimg.cn/407a6dfa7b04459eb3204dc0e56f9fc8.gif\"/></p>\n<hr/>\n<p>由一根10个连续细胞演化出来的周期结构：</p>\n<p><img alt=\"\" src=\"https://img-blog.csdnimg.cn/6fa427412c8b49dbb6357bcdfa72c06a.gif\"/></p>\n<hr/>\n<p>动态变化后全部湮灭的结构：</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/e14012459496405ab79d9a6ac0afdddd.gif\"/></p>\n<hr/>\n<p><strong>移动的飞船</strong>：周期变化且逐渐向右平移</p>\n<p>飞船到了边界变成向对角线移动的“<strong>滑翔者</strong>”，滑翔者到了边界成为不动的<strong>方块</strong>。</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/284444bf1e424aada07300930840588b.gif\"/></p>\n<p>更多有趣的图形结构有待发现，用代码来辅助这项工作还是比较方便的.....</p>\n<hr/>\n<h2>代码实现</h2>\n<p>用tkinter库实现了软件界面，画布、按钮、标签等控件都是配角，全是为表现生命繁殖演化的核心代码类方法 Lifes.reproduce() 作帮手的，源代码<strong>lifegame.pyw</strong>如下：</p>\n<pre><code class=\"language-python\">from tkinter import messagebox as msgbox\nimport tkinter as tk\nimport webbrowser\nimport random\n\nclass Lifes:\n    def __init__(self, rows=36, cols=36):\n        self.row = rows+2\n        self.col = cols+2\n        self.items = [[0]*self.col for _ in range(self.row)]\n        self.histroy = []\n        self.histroySize = 30\n        self.running = False\n        self.runningSpeed = 100\n        \n    def rndinit(self, rate=0.1):\n        self.histroy = []\n        for i in range(self.row):\n            for j in range(self.col):\n                rnd = random.random()\n                if rnd &gt; 1-rate:\n                    self.items[i][j]=1\n\n    def reproduce(self):\n        new = [[0]*self.col for _ in range(self.row)]\n        self.add_histroy()\n        if len(self.histroy) &gt; self.histroySize:\n            self.histroy.pop(0)\n        for i in range(self.row):\n            for j in range(self.col):\n                if i*j==0 or i==self.row-1 or j==self.col-1:\n                    new[i][j]=0\n                else:\n                    lifes=0\n                    for m in range(i-1,i+2):\n                        for n in range(j-1,j+2):\n                            if m==i and n==j:\n                                continue\n                            lifes += self.items[m][n]\n                    if self.items[i][j]:\n                        if lifes==2 or lifes==3:\n                            new[i][j]=1\n                        else:\n                            new[i][j]=0\n                    else:\n                        if lifes==3:\n                            new[i][j]=1\n        for idx,narray in enumerate(new):\n            self.items[idx] = narray\n\n    def is_stable(self):\n        if len(self.histroy)&lt;self.histroySize:\n            return False\n        arr = []\n        for i in self.histroy:\n            if i not in arr:\n                arr.append(i)\n        if len(arr)&lt;10:\n            return True\n\n    def add_histroy(self, Items=None):\n        arr = []\n        if Items==None:\n            Items=self.items[:]\n        for item in Items:\n            b = 0\n            for i,n in enumerate(item[::-1]):\n                b += n*2**i\n            arr.append(b)\n        self.histroy.append(arr)\n\n\ndef drawCanvas():\n    global tv,rect\n    tv = tk.Canvas(win, width=win.winfo_width(), height=win.winfo_height())\n    tv.pack(side = \"top\")\n    for i in range(36):\n        coord = 40, 40, 760, i*20 + 40\n        tv.create_rectangle(coord)\n        coord = 40, 40, i*20 + 40, 760\n        tv.create_rectangle(coord)\n    coord = 38, 38, 760, 760\n    tv.create_rectangle(coord,width=2)\n    coord = 39, 39, 760, 760\n    tv.create_rectangle(coord,width=2)\n    coord = 38, 38, 762, 762\n    tv.create_rectangle(coord,width=2)\n    R,XY = 8,[50+i*20 for i in range(36)]\n    rect = [[0]*36 for _ in range(36)]\n    for i,x in enumerate(XY):\n        for j,y in enumerate(XY):\n            rect[i][j] = tv.create_rectangle(x-R,y-R,x+R,y+R,tags=('imgButton1'))\n            tv.itemconfig(rect[i][j],fill='lightgray',outline='lightgray')\n    tv.tag_bind('imgButton1','&lt;Button-1&gt;',on_Click)\n\ndef drawLifes():\n    R,XY = 8,[50+i*20 for i in range(36)]\n    if Life.running:\n        for i,x in enumerate(XY):\n            for j,y in enumerate(XY):\n                if Life.items[i+1][j+1]:\n                    tv.itemconfig(rect[i][j],fill='green',outline='green')\n                else:\n                    tv.itemconfig(rect[i][j],fill='lightgray',outline='lightgray')\n        tv.update()\n        Life.reproduce()\n        if Life.is_stable():\n            Life.running = False\n            if sum(sum(Life.items,[])):\n                msgbox.showinfo('Message','生命繁殖与湮灭进入稳定状态！！！')\n            else:\n                msgbox.showinfo('Message','生命全部湮灭，进入死亡状态！！！')\n    win.after(Life.runningSpeed, drawLifes)\n\ndef StartLife():\n    if sum(sum(Life.items,[])):\n        Life.histroy = []\n        Life.running = True\n    else:\n        msgbox.showinfo('Message','请点击小方块填入生命细胞，或者使用随机功能！')\n\ndef BreakLife():\n    Life.running = not Life.running\n    if Life.running:\n        Life.histroy.clear()\n        Life.add_histroy()\n\ndef RandomLife():\n    Life.rndinit()\n    Life.running = True\n\ndef ClearLife():\n    Life.running = False\n    Life.histroy = []\n    Life.items = [[0]*38 for _ in range(38)]\n    for x in range(36):\n        for y in range(36):\n            tv.itemconfig(rect[x][y],fill='lightgray',outline='lightgray')\n\ndef btnCommand(i):\n    if   i==0: return StartLife\n    elif i==1: return BreakLife\n    elif i==2: return RandomLife\n    elif i==3: return ClearLife\n\ndef on_Enter(event):\n    tCanvas.itemconfig(tVisit, fill='magenta')\n\ndef on_Leave(event):\n    tCanvas.itemconfig(tVisit, fill='blue')\n\ndef on_Release(event):\n    url = 'https://blog.csdn.net/boysoft2002?type=blog'\n    webbrowser.open(url, new=0, autoraise=True)\n\ndef on_Click(event):\n    x,y = (event.x-40)//20,(event.y-40)//20\n    if not Life.running:\n        if Life.items[x+1][y+1]:\n            tv.itemconfig(rect[x][y],fill='lightgray',outline='lightgray')\n        else:\n            tv.itemconfig(rect[x][y],fill='red',outline='red')\n        Life.items[x+1][y+1] = not Life.items[x+1][y+1]\n\ndef on_Close():\n    if msgbox.askokcancel(\"Quit\",\"Do you want to quit?\"):\n        Life.running = False\n        print(Copyright())\n        win.destroy()\n\ndef Introduce():\n    txt = '''【生命游戏】\\n\\n生存定律：\n    (1)当前细胞为湮灭状态时，当周围有３个存活细胞时，则迭代后该细胞变成存活状态(模拟繁殖)。\n    (2)当前细胞为存活状态时，当周围的邻居细胞少于２个存活时，该细胞变成湮灭状态(数量稀少)。\n    (3)当前细胞为存活状态时，当周围有３个以上的存活细胞时，该细胞变成湮灭状态(数量过多)。\n    (4)当前细胞为存活状态时，当周围有２个或３个存活细胞时，该细胞保持原样。'''\n    return txt\n\ndef Copyright():\n    return 'Lifes Game Ver1.0\\nWritten by HannYang, 2022/08/01.'\n\nif __name__ == '__main__':\n\n    win = tk.Tk()\n    X,Y = win.maxsize()\n    W,H = 1024,800\n    winPos = f'{W}x{H}+{(X-W)//2}+{(Y-H)//2}'\n    win.geometry(winPos)\n    win.resizable(False, False)\n    win.title('生命游戏 Ver1.0')\n    win.update()\n    drawCanvas()\n    Life = Lifes()\n    drawLifes()\n\n    tLabel = tk.Label(win, width=30, height=20, background='lightgray')\n    tLabel.place(x=780, y=38)\n    tLabel.config(text='\\n\\n\\n'.join((Introduce(),Copyright())))\n    tLabel.config(justify=tk.LEFT,anchor=\"nw\",borderwidth=10,wraplength=210)\n\n    tButton = [None]*4\n    bX,bY,dY = 835, 458, 50\n    txt = ['开始','暂停','随机','清空']\n    for i in range(4):\n        tButton[i] = tk.Button(win, text=txt[i], command=btnCommand(i))\n        tButton[i].place(x=bX, y=bY+dY*i, width=120, height=40)     \n\n    tCanvas = tk.Canvas(win, width=200, height=45)\n    tCanvas.place(x=800,y=716)\n    tVisit = tCanvas.create_text((88, 22), text=u\"点此访问Hann's CSDN主页!\")\n    tCanvas.itemconfig(tVisit, fill='blue', tags=('btnText'))\n    tCanvas.tag_bind('btnText','&lt;Enter&gt;',on_Enter)\n    tCanvas.tag_bind('btnText','&lt;Leave&gt;',on_Leave)\n    tCanvas.tag_bind('btnText','&lt;ButtonRelease-1&gt;',on_Release)\n    win.protocol(\"WM_DELETE_WINDOW\", on_Close)\n    win.mainloop()\n</code></pre>\n<h3>编译命令</h3>\n<blockquote>\n<p><strong>D:\\&gt; pyinstaller -F lifegame.pyw --noconsole</strong></p>\n</blockquote>\n<h2>运行界面</h2>\n<p><img alt=\"\" height=\"838\" src=\"image\\aa8b27152b7e454eaf3a2a6110878b06.png\" width=\"1040\"/></p>\n<h3>使用简介</h3>\n<p>在生存空间里点击方格种植细胞（甚至可以画出你要表达的图形），然后点击开始；点下暂停键，则可以任意编辑生命图形，再点开始继续运行；点随机键则由软件随机生成细胞位置；清空键可以在任何时候清空生存空间，进入暂停编辑状态。 </p>\n<h3>后续改进</h3>\n<p>Lifes类预留了histroy属性，后续可以增加回退功能；代码缺点是生存空间的行列被我写死了，以后版本中可以改进成任意定义行列数；另一个缺点是对稳定状态的判断比较简单，之后可以增加计算变化周期的功能。</p>\n<p>优点就是可以任意编辑你的图形，最后以一张自己的网名画的图作收尾：</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/410bc801568c40c8bf6337326f5f6755.gif\"/></p>\n<hr/>\n<p>前部分介绍性文字来源于百度百科等网络资源 </p>\n</div>\n</div>"}