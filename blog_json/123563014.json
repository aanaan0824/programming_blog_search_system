{"blogid": "123563014", "writerAge": "None", "writerBlogNum": "66", "writerCollect": "130", "writerComment": "108", "writerFan": "259", "writerGrade": "5级", "writerIntegral": "1632", "writerName": "元素跃迁", "writerProfileAdress": "writer_image\\profile_123563014.jpg", "writerRankTotal": "61362", "writerRankWeekly": "17648", "writerThumb": "76", "writerVisitNum": "94560", "blog_read_count": "5189", "blog_time": "已于 2022-03-18 00:39:47 修改", "blog_title": "B1：Unity制作Moba类游戏——Socket帧同步", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h1><img alt=\"\" height=\"390\" src=\"image\\abfcacdb3e8744c3b32b0fcfb9060afa.png\" width=\"709\"/></h1>\n<p> </p>\n<p></p>\n<p></p>\n<p><img alt=\"\" height=\"400\" src=\"image\\2b3a6e4ef4814588a001ac551d689e42.png\" width=\"338\"/><img alt=\"\" height=\"211\" src=\"image\\be7285fb1fd846b291aec4436b432cf3.png\" width=\"336\"/></p>\n<p></p>\n<h3> 刚上大学就喜欢玩，英雄联盟陪伴了我整个大学生涯，承载了满满的回忆，现在老娘要亲手做一个！！【文末有福利哦~】</h3>\n<p><img alt=\"\" height=\"464\" src=\"image\\ccfb67d80330416f9d431fea7f4aa2a2.png\" width=\"311\"/></p>\n<p>相信做开发的小伙伴们都有一个“游戏梦”，就是亲手制作出自己热爱的游戏，然后和小伙伴们在线玩耍~~~ 很多小伙伴觉得自己开发游戏很难，需要大量的时间、精力、资源等投入。</p>\n<p>Emmmmmm  ~   ~  其实并不是啦~  ~ 开发一款自己喜欢的游戏其实是非常简单轻松的事情，只要把……模型、动画、地形、渲染、算法、脚本、网络、光影、Editor、内存管理、多线程、bilabilabila…（此处省略500个知识点）都掌握好，就可以很轻松的做出一款游戏啦，是不是很简单啊~（手动狗头）</p>\n<p class=\"img-center\"><img alt=\"\" height=\"370\" src=\"image\\9f5477208de7a8e1d27a0882b8afc33c.png\" width=\"333\"/></p>\n<h1>第一章：Socket制作帧同步网络框架</h1>\n<p>相信小伙伴们都知道Moba类属于强联网游戏，需要使用帧同步网络技术以实时同步传输对局中所有玩家的操作指令，做到无差错、无重复、并按顺序接收等，这里讲解一下游戏实现帧同步的原理：</p>\n<p><span style=\"color:#ff9900;\"><strong>某个客户端在当前时间点当前帧发送数据给服务器==&gt;服务器接收后记录并统一发送操作命令给所有客户端==&gt;所有客户端接收后对比时间帧执行命令==&gt;客户端对比当前时间帧之间的差值做补间动画==&gt;客户端继续发送数据……</strong></span></p>\n<p><span style=\"color:#4da8ee;\"><strong>了解了原理后开发起来就简单多啦，这里直接上一段简单的案例代码。</strong></span></p>\n<p><strong>Unity 版本：2020.3.3</strong></p>\n<p><strong>第一步：开启服务器，等待客户端连接</strong></p>\n<pre><code>\n    void Main()\n    {\n        //定义socket\n        //获取本地ip地址\n        //string ip = ClientController.GetLocalIpAddress(\"InterNetwork\");\n        //端口号\n\n        serverSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);\n        IPEndPoint ipendPoint = new IPEndPoint(IPAddress.Parse(ip), port);\n        Debug.Log(\"ip地址:\" + ip);\n        Debug.Log(\"开始绑定端口号:\" + port);\n        //将ip地址和端口号绑定\n        serverSocket.Bind(ipendPoint);\n        Debug.Log(\"绑定端口号成功，开启服务器....\");\n        //开启服务器\n        serverSocket.Listen(100);\n        Debug.Log(\"启动服成功!\");\n        while (true)\n        {\n            Debug.Log(\"等待链接.....\");\n            Socket clinetSocket = serverSocket.Accept();\n            ClientController controller = new ClientController(clinetSocket);\n            //添加到列表中\n            clientControllerList.Add(controller);\n            Debug.Log(\"当前有\" + clientControllerList.Count + \"个用户\");\n            Debug.Log(\"有一个用户链接....\");\n        }\n    }\n\n</code></pre>\n<p><strong>第二步：客户端连接服务器，发送登录请求。</strong></p>\n<pre><code>\n    /// &lt;summary&gt;\n    /// 开始链接服务器\n    /// &lt;/summary&gt;\n    /// &lt;param name=\"ip\"&gt;&lt;/param&gt;\n    /// &lt;param name=\"port\"&gt;&lt;/param&gt;\n    public void ConnectToServer(string ip,int port)\n    {\n        //创建socket对象\n        clientSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);\n\n        IPEndPoint ipendPoint = new IPEndPoint(IPAddress.Parse(ip), port);\n        Debug.Log(\"开始链接服务器！！！\");\n        //请求链接\n        clientSocket.BeginConnect(ipendPoint, ConnectCallback, \"\");\n\n    }\n\n    /// &lt;summary&gt;\n    /// 链接的回调\n    /// &lt;/summary&gt;\n    /// &lt;param name=\"ar\"&gt;&lt;/param&gt;\n    public void ConnectCallback(IAsyncResult ar)\n    {\n        try\n        {\n            clientSocket.EndConnect(ar);\n        }\n        catch(Exception e)\n        {\n            Debug.Log(e.ToString());\n        }\n        //判断到底链接成功了还是没有\n        if(clientSocket.Connected == true)\n        {\n            //调用链接成功的回调\n            onConnectSuccess();\n            //开启接收消息\n            ReceiveMessageFromServer();\n        }\n        else\n        {\n            //链接失败\n            onConnectExcept();\n        }\n    }\n\n\n\n private void Update()\n    {\n      \n            //监控控制当前玩家的英雄移动\n            if (Input.GetMouseButtonDown(0))\n            {\n                \n                    Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);\n                    RaycastHit hit;\n                    if (Physics.Raycast(ray, out hit, 1000.0f, LayerMask.GetMask(\"Terrain\")))\n                    {\n                        TCPData_Move tCPData_Move = new TCPData_Move();\n                        tCPData_Move.position = hit.point;\n                        ChatUIController.Single.SendMoveData(tCPData_Move);\n                    }\n\n            }\n    }\n\n  </code></pre>\n<h3>第三步：服务器接收消息后，做统一分发给所有客户端：</h3>\n<pre><code>  void ReceiveFromClient()\n    {\n        while (true)\n        {\n            byte[] buffer = new byte[4096];\n            int lenght = clientSocket.Receive(buffer, 0, buffer.Length, SocketFlags.None);\n            string json = System.Text.Encoding.UTF8.GetString(buffer, 0, lenght);\n            json.TrimEnd();\n                MessageData data = LitJson.JsonMapper.ToObject&lt;MessageData&gt;(json);\n                switch (data.msgType)\n                {\n                    case MessageType.Login://如果是登陆消息\n                        playerSocketData = JsonUtility.FromJson&lt;PlayerSocketData&gt;(data.playerSocketData);\n                        //需要告诉所有客户端，***加入了房间\n                        MessageData chatData = new MessageData();\n                        chatData.msgType = MessageType.Login;\n                        chatData.playerSocketData = JsonUtility.ToJson(playerSocketData);\n                        chatData.msg = JsonUtility.ToJson(playerList);\n                        SendMessageDataToAllClient(chatData);\n                     \n                        break;\n                    case MessageType.Chat://如果是聊天消息\n                                          //转发聊天信息\n                        MessageData chatMessageData = new MessageData();\n                        chatMessageData.msgType = MessageType.Chat;\n                        chatMessageData.playerSocketData= JsonUtility.ToJson(playerSocketData);\n                        chatMessageData.msg = data.msg;\n                        SendMessageDataToAllClient(chatMessageData);\n\n                        break;\n                    case MessageType.Exit://客户端请求退出\n                        //告诉所有的其他用户，**退出了房间\n                        MessageData logOutChatData = new MessageData();\n                        logOutChatData.msgType = MessageType.Exit;\n                        logOutChatData.playerSocketData = JsonUtility.ToJson(playerSocketData);\n                        logOutChatData.msg = nickName + \" 断开了连接\";\n                        SendMessageDataToAllClient(logOutChatData);\n                       \n                        break;\n                    case MessageType.Move://同步玩家移动\n                        MessageData MoveMessageData = new MessageData();\n                        MoveMessageData.msgType = MessageType.Move;\n                        MoveMessageData.playerSocketData = JsonUtility.ToJson(playerSocketData); \n                        MoveMessageData.msg = data.msg;\n                        SendMessageDataToAllClient(MoveMessageData);\n                        break;\n                }\n        }\n    }</code></pre>\n<h3>第四步：所有客户端接收消息（先判断数据类型，然后执行对应命令方法）</h3>\n<pre><code>/// &lt;summary&gt;\n    /// 读取数据并调用控制\n    /// &lt;/summary&gt;\n    private void ReceiveSocketData()\n    {\n        if (isStart == true)\n        {\n            while (socketDatas_Receive.Count &gt; 0)\n            {\n\n                MessageData messageData = socketDatas_Receive.Dequeue();\n                switch (messageData.msgType)\n                {\n                    case MessageType.Chat:\n                        EventManager.playerControl_C.Action_Talk(messageData);\n                        break;\n                    case MessageType.Login:\n                        EventManager.playerControl_C.AddPlayer(messageData);\n                        break;\n                    case MessageType.Exit:\n                         EventManager.playerControl_C.RemovePlayer(messageData);\n                        break;\n                    case MessageType.Close:\n                        EventManager.playerControl_C.CloseServer();\n                        break;\n                    case MessageType.Move:\n                        EventManager.playerControl_C.Action_Move(messageData);\n                        break;\n                    case MessageType.Other:\n                        break;\n                    default:\n                        break;\n                }\n            }\n        }\n    }</code></pre>\n<h3>第五步：执行命令，并做补间动画。</h3>\n<pre><code>  /// &lt;summary&gt;\n    /// 执行移动\n    /// &lt;/summary&gt;\n    /// &lt;param name=\"move_SocketData\"&gt;&lt;/param&gt;\n    public void ActionMove(TCPData_Move tCPData_Move)\n    {\n        Target = tCPData_Move.position;\n        isMove = true;\n       //寻路\n        moveForward(this.gameObject.transform, Target);\n       //转向\n        turnForward(this.gameObject.transform, Target);\n        animation.Play(\"run\");\n    }\n\n\n    void moveForward(Transform obj, Vector3 target)\n    {\n        obj.transform.position = Vector3.Lerp(obj.transform.position, target, Time.deltaTime);\n    }\n\n    /// &lt;summary&gt;\n    /// 直接用transform.LookAt(targetPos);当目标点和远点不在一个高度时，会使物体发生倾斜来看想目标点\n    /// 该方法使物体朝向指向的方向，同时保持物体不倾斜，只绕y轴旋转一定角度\n    /// &lt;/summary&gt;\n    /// &lt;param name=\"origin\"&gt;&lt;/param&gt;\n    /// &lt;param name=\"target\"&gt;&lt;/param&gt;\n    void turnForward(Transform origin, Vector3 target)\n    {\n        //将原坐标和目的坐标映射到XOZ平面，从而过滤掉y轴方向的旋转的影响\n        Vector3 t1 = new Vector3(origin.position.x, 0, origin.position.z);\n        Vector3 t2 = new Vector3(target.x, 0, target.z);\n\n        Vector3 forward_dir = t2 - t1;\n        Quaternion rotate = Quaternion.FromToRotation(origin.forward, forward_dir);\n        float angle = rotate.eulerAngles.y;\n        //实现旋转\n        //origin.rotation *= rotate;\n        //实现平滑旋转\n        origin.rotation = Quaternion.Lerp(origin.rotation, origin.rotation * rotate, Time.deltaTime * 100);\n    }</code></pre>\n<h3>局域网内，让一台电脑为服务器，多个网段开启客户端，即可实现多人同步在线帧同步传输数据啦（移动端和PC端互通），附上效果：</h3>\n<p></p>\n<h3><img alt=\"\" height=\"360\" src=\"https://img-blog.csdnimg.cn/9f80959d0bbb441180d07e9812456013.gif\" width=\"640\"/></h3>\n<h3>欢迎小伙伴们关注+关注哈~</h3>\n<h3>【文末福利】</h3>\n<p><img alt=\"\" height=\"727\" src=\"image\\b9590bf7218f418d8422705f4d110e17.png\" width=\"576\"/></p>\n<p><img alt=\"\" height=\"569\" src=\"image\\15ef2cfa07b3431f8cabd8e3580168ba.png\" width=\"640\"/></p>\n<p></p>\n<p></p>\n</div>\n</div>"}