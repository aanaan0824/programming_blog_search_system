{"blogid": "126179712", "writerAge": "码龄178天", "writerBlogNum": "53", "writerCollect": "1445", "writerComment": "2140", "writerFan": "4840", "writerGrade": "6级", "writerIntegral": "5572", "writerName": "月亮嚼成星~", "writerProfileAdress": "writer_image\\profile_126179712.jpg", "writerRankTotal": "3060", "writerRankWeekly": "94", "writerThumb": "1912", "writerVisitNum": "34284", "blog_read_count": "371", "blog_time": "已于 2022-08-23 20:40:04 修改", "blog_title": "【Java SE】面向对象三大特性之继承", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p><img alt=\"ced485cbb11e458d81a746890b32cf3f.gif\" src=\"https://img-blog.csdnimg.cn/ced485cbb11e458d81a746890b32cf3f.gif\"/>  </p>\n<blockquote>\n<p>作者：月亮嚼成星~</p>\n<p>博客主页：<a href=\"https://blog.csdn.net/m0_67995737?type=blog\" title=\"月亮嚼成星~的博客主页\">月亮嚼成星~的博客主页</a></p>\n<p>专栏：<a href=\"https://blog.csdn.net/m0_67995737/category_11933537.html\" title=\"Java SE基础\">Java SE基础</a></p>\n<p><span style=\"color:#ff9900;\">工欲善其事必先利其器，给大家介绍一款超牛的斩获大厂offer利器——牛客网</span></p>\n<p><a class=\"link-info\" href=\"https://www.nowcoder.com/link/pc_csdncpt_ylcxx_c\" title=\"点击免费注册和我一起刷题吧\">点击免费注册和我一起刷题吧</a>​​​​​​​</p>\n</blockquote>\n<p><img alt=\"\" src=\"image\\1b119009e58540a8839229bf3523e631.png\"/></p>\n<p><span style=\"color:#956fe7;\">面向对象思想中提出了继承的概念，专门用来进行共性抽取，实现代码复用。</span></p>\n<h1><strong>🐳</strong>何为继承？</h1>\n<blockquote>\n<p><span style=\"color:#fe2c24;\">继承(inheritance)机制：是面向对象程序设计使代码可以复用的最重要的手段，它允许程序员在保持原有类特 性的基础上进行扩展，增加新功能，这样产生新的类，称派生类。继承呈现了面向对象程序设计的层次结构， 体现了由简单到复杂的认知过程。继承主要解决的问题是：共性的抽取，实现代码复用。</span></p>\n</blockquote>\n<p>例如：狗和猫都是动物，那么我们就可以将共性的内容进行抽取，然后采用继承的思想来达到共用。</p>\n<p>狗：</p>\n<pre><code class=\"language-java\">\npublic class Dog {\n    String name;\n    int age;\n    float weight;\n\n    public void eat() {\n        System.out.println(name + \"正在吃饭\");\n    }\n\n    public void sleep() {\n        System.out.println(name + \"正在睡觉\");\n    }\n\n    void Bark() {\n        System.out.println(name + \"汪汪汪~~~\");\n    }\n}</code></pre>\n<p>猫： </p>\n<pre><code class=\"language-java\">\npublic class Cat{\n    String name;\n    int age;\n    float weight;\n    public void eat(){\n        System.out.println(name + \"正在吃饭\");\n    }\n    public void sleep()\n    {\n        System.out.println(name + \"正在睡觉\");\n    }\n    void mew(){\n        System.out.println(name + \"喵喵喵~~~\");\n    }\n}</code></pre>\n<p>在猫和狗中含有相同的字段和行为，同时也可能含有不同的字段和行为，所以我们可以将相同的部分提取出来，然后让猫和狗来继承相同的部分：</p>\n<p><img alt=\"\" height=\"697\" src=\"image\\38c58687bcf443d390e81018e03b70c1.png\" width=\"1200\"/></p>\n<p>那能否将这些共性抽取呢？面向对象思想中提出了继承的概念，专门用来进行共性抽取，实现代码复用。</p>\n<p><span style=\"color:#fe2c24;\">在Java中如果要表示类之间的继承关系，需要借助extends关键字</span>，具体如下：</p>\n<pre><code class=\"language-java\">//Cat.java\npublic class Cat extends Animal{\n\n    void mew(){\n        System.out.println(name + \"喵喵喵~~~\");\n    }\n}\n//Dog.java\npublic class Dog extends Animal{\n\n    void Bark() {\n        System.out.println(name + \"汪汪汪~~~\");\n    }\n}\n//Animal.java\npublic class Animal {\n    String name;\n    int age;\n    float weight;\n    public void eat(){\n        System.out.println(name + \"正在吃饭\");\n    }\n    public void sleep()\n    {\n        System.out.println(name + \"正在睡觉\");\n    }\n}\n//Test.java\npublic class Test {\n    public static void main(String[] args) {\n        Dog dog=new Dog();\n        Cat cat=new Cat();\n        cat.name=\"mimi\";\n        dog.name=\"wangcai\";\n        cat.eat();\n        dog.eat();\n        dog.Bark();\n    }\n}\n</code></pre>\n<p><img alt=\"\" height=\"659\" src=\"image\\6aa3777c097f488a8accb57a81894b24.png\" width=\"1080\"/></p>\n<p> 猫和狗的name和eat都是从Animal类中继承下来的。</p>\n<p><img alt=\"\" height=\"745\" src=\"image\\2b9908b470394388910e39c7551dffeb.png\" width=\"1200\"/></p>\n<p><span style=\"color:#fe2c24;\">注意：<br/> 1. 子类会将父类中的成员变量或者成员方法继承到子类中了<br/> 2. 子类继承父类之后，必须要新添加自己特有的成员，体现出与基类的不同，否则就没有必要继承了。</span></p>\n<h1><strong>🐳</strong>如何从子类中访问父类成员呢？</h1>\n<h2><strong>🐳</strong>1. 子类和父类不存在同名成员变量：</h2>\n<pre><code class=\"language-java\">//Car.java\npublic class Car {\n    int a;\n    int b;\n    String name;\n\n    public void music(){\n        System.out.println(name+\"正在播放音乐\");\n    }\n}\n//BMW.java\npublic class BMW extends Car{\n    int c;\n    public void method(){\n        a=10;// 访问从父类中继承下来的a\n        b=20;// 访问从父类中继承下来的b\n        name=\"aodi\";// 访问从父类中继承下来的name\n        c=30;// 访问自己的c\n    }\n}\n</code></pre>\n<h2><strong>🐳</strong>2. 子类和父类成员变量同名：</h2>\n<p>成员变量访问遵循就近原则，自己有优先自己的，如果没有则向父类中找。</p>\n<pre><code class=\"language-java\">//Car.java\npublic class Car {\n    int a;\n    int b;\n    String name;\n\n    public void music(){\n        System.out.println(name+\"正在播放音乐\");\n    }\n}\n//BMW.java\npublic class BMW extends Car{\n    int b;\n    int c;\n    public void method(){\n        a=10;// 访问从父类中继承下来的a\n        b=20;// 访问自己的b\n        name=\"aodi\";// 访问从父类中继承下来的name\n        c=30;// 访问自己的c\n    }\n}\n</code></pre>\n<p><span style=\"color:#fe2c24;\">注意：在子类方法中 或者 通过子类对象访问成员时：<br/> 如果访问的成员变量子类中有，优先访问自己的成员变量。<br/> 如果访问的成员变量子类中无，则访问父类继承下来的，如果父类也没有定义，则编译报错。<br/> 如果访问的成员变量与父类中成员变量同名，则优先访问自己的</span></p>\n<h2><strong>🐳</strong>子类中访问父类的成员方法：</h2>\n<pre><code class=\"language-java\">//Car.java\npublic class Car {\n    int a;\n    int b;\n    String name;\n\n    public void music(){\n        System.out.println(name+\"正在播放音乐\");\n    }\n}\n//BMW.java\npublic class BMW extends Car{\n    int b;\n    int c;\n    public void A(){\n        System.out.println(\"子类的A行为\");\n    }\n    public void method(){\n        a=10;// 访问从父类中继承下来的a\n        b=20;// 访问自己的b\n        name=\"aodi\";// 访问从父类中继承下来的name\n        c=30;// 访问自己的c\n        A();//子类的A成员方法\n        music();//父类的music方法\n    }\n\n}\n</code></pre>\n<p><span style=\"color:#fe2c24;\">总结：成员方法没有同名时，在子类方法中或者通过子类对象访问方法时，则优先访问自己的，自己没有时再到父类中找，如果父类中也没有则报错。</span></p>\n<h2><strong>🐳</strong> 成员方法名字相同：</h2>\n<pre><code class=\"language-java\">//Car.java\n\npublic class Car {\n    int a;\n    int b;\n    String name;\n\n    public void A(){\n        System.out.println(\"父类的A行为\");\n    }\n    public void B(){\n        System.out.println(\"父类的B行为\");\n    }\n\n    public void getB(){\n        System.out.println(b);\n    }\n    public void music(){\n        System.out.println(name+\"正在播放音乐\");\n    }\n}\n\n\n\n\n//BMW.java\npublic class BMW extends Car{\n    int b;\n    int c;\n    public void A(){\n        System.out.println(\"子类的A行为\");\n    }\n    public void B(){\n        System.out.println(\"子类的B行为\");\n    }\n    public void getB(int a,int b){\n        this.a=a;\n        this.b=b;\n    }\n    public void method(){\n        a=10;// 访问从父类中继承下来的a\n        b=20;// 访问自己的b\n        name=\"aodi\";// 访问从父类中继承下来的name\n        c=30;// 访问自己的c\n        A();//子类的A成员方法\n        music();//父类的music方法\n        B();//访问的子类的B方法\n        getB();//访问父类的getB方法\n    }\n\n}</code></pre>\n<p><span style=\"color:#fe2c24;\">总结：通过子类对象访问父类与子类中不同名方法时，优先在子类中找，找到则访问，否则在父类中找，找到则访问，否则编译报错。<br/> 通过派生类对象访问父类与子类同名方法时，如果父类和子类同名方法的参数列表不同(重载)，根据调用方法适传递的参数选择合适的方法访问，如果没有则报错。</span></p>\n<h1><strong>🐳</strong> super关键字：</h1>\n<p>如果子类中存在与父类中相同的成员时，那如何在子类中访问父类相同名称的成员呢？直接访问是无法做到的，Java提供了super关键字，该关键字主要作用：在子类方法中访问父类的成员。</p>\n<pre><code class=\"language-java\">//Car.java\n\npublic class Car {\n    int a;\n    int b;\n    String name;\n\n    public void A(){\n        System.out.println(\"父类的A行为\");\n    }\n    public void B(){\n        System.out.println(\"父类的B行为\");\n    }\n\n    public void getB(){\n        System.out.println(b);\n    }\n    public void music(){\n        System.out.println(name+\"正在播放音乐\");\n    }\n}\n\n\n\n\n//BMW.java\npublic class BMW extends Car{\n    int b;\n    int c;\n    public void A(){\n        System.out.println(\"子类的A行为\");\n    }\n    public void B(){\n        System.out.println(\"子类的B行为\");\n    }\n    public void getB(int a,int b){\n        this.a=a;\n        this.b=b;\n    }\n    public void method(){\n        a=10;// 访问从父类中继承下来的a\n        b=20;// 访问自己的b\n        super.b=50;//访问从父类中继承下来的b\n        name=\"aodi\";// 访问从父类中继承下来的name\n        c=30;// 访问自己的c\n        A();//子类的A成员方法\n        music();//父类的music方法\n        B();//访问的子类的B方法\n        super.B();//访问父类的B方法\n        getB();//访问父类的getB方法\n    }\n\n}</code></pre>\n<p>在子类方法中，如果想要明确访问父类中成员时，借助super关键字即可<br/><span style=\"color:#fe2c24;\">注意事项：<br/> 1. super和this一样只能在非静态方法中使用<br/> 2. super可以在在子类方法中，访问父类的成员变量和方法。</span></p>\n<h1><strong>🐳</strong> 子类构造方法：</h1>\n<p>子类对象构造时，需要先调用基类构造方法，然后执行子类的构造方法。</p>\n<pre><code class=\"language-java\">//Car.java\npublic class Car {\n    int a;\n    int b;\n    String name;\n\n    public Car(){\n        System.out.println(\"基类构造方法\");\n    }\n\n}\n\n//BMW.java\npublic class BMW extends Car{\n    int b;\n    int c;\n    public BMW(){\n        System.out.println(\"子类构造方法\");\n    }\n\n\n}\n\n//Test.java\npublic class Test {\n    public static void main(String[] args) {\n     BMW bmw=new BMW();\n    }\n}</code></pre>\n<p><img alt=\"\" height=\"320\" src=\"image\\956c02456c684eaca54f72eba981b38f.png\" width=\"720\"/><br/> 子类对象中成员是有两部分组成的，基类继承下来的以及子类新增加的部分 。父子肯定是先有父再有子，所以在构造子类对象时候 ，先要调用基类的构造方法，将从基类继承下来的成员构造完整，然后再调用子类自己的构造方法，将子类自己新增加的成员初始化完整。</p>\n<p><span style=\"color:#fe2c24;\">注意：</span></p>\n<p><span style=\"color:#fe2c24;\">1. 若父类显式定义无参或者默认的构造方法，在子类构造方法第一行默认有隐含的super()调用，即调用基类构造方法<br/> 2. 如果父类构造方法是带有参数的，此时需要用户为子类显式定义构造方法，并在子类构造方法中选择合适的父类构造方法调用，否则编译失败。<br/> 3. 在子类构造方法中，super(...)调用父类构造时，必须是子类构造函数中第一条语句。<br/> 4. super(...)只能在子类构造方法中出现一次，并且不能和this同时出现</span></p>\n<h1><strong>🐳</strong>super和this的区别：<br/><img alt=\"\" height=\"677\" src=\"image\\5a4c1d8b5e8c4b3e8e3ce4d2ff1d3d2c.png\" width=\"1200\"/></h1>\n<h1><strong>🐳</strong> 代码块在继承关系中的执行顺序：</h1>\n<pre><code class=\"language-java\">//Car.java\npublic class Car {\n    int a;\n    int b;\n    String name;\n    {\n        System.out.println(\"父类实例代码块执行\");\n    }\n\n    static {\n        System.out.println(\"父类静态代码块执行\");\n    }\n    public Car(){\n        System.out.println(\"基类构造方法执行\");\n    }\n\n}\n//BMW.java\npublic class BMW extends Car{\n    int b;\n    int c;\n    String name;\n    {\n        System.out.println(\"子类实例代码块执行\");\n    }\n\n    static {\n        System.out.println(\"子类静态代码块执行\");\n    }\n    public BMW(){\n        System.out.println(\"子类构造方法\");\n    }\n\n\n}\n//Test.java\npublic class Test {\n    public static void main(String[] args) {\n     BMW bmw=new BMW();\n    }\n}</code></pre>\n<p><img alt=\"\" height=\"714\" src=\"image\\12b0d6cd18a046e18d1a41c39c98035b.png\" width=\"1200\"/><br/>  <img alt=\"\" height=\"338\" src=\"image\\4019817234d34d24a959e2d83d90a902.png\" width=\"831\"/></p>\n<p> 当我们第二次实例化对象的时候，我们可以清楚的看到：</p>\n<pre><code class=\"language-java\">public class Test {\n    public static void main(String[] args) {\n     BMW bmw=new BMW();\n     System.out.println(\"第二次实例化子类对象：\");\n     System.out.println(\"==================================\");\n     BMW bmw1=new BMW();\n    }\n}</code></pre>\n<p><img alt=\"\" height=\"455\" src=\"image\\2bef999e936f4a9d9e7c90ba3af0a09a.png\" width=\"839\"/></p>\n<blockquote>\n<p><span style=\"color:#fe2c24;\"> 通过分析执行结果，得出以下结论：<br/> 1、父类静态代码块优先于子类静态代码块执行，且是最早执行<br/> 2、父类实例代码块和父类构造方法紧接着执行<br/> 3、子类的实例代码块和子类构造方法紧接着再执行<br/> 4、第二次实例化子类对象时，父类和子类的静态代码块都将不会再执行</span></p>\n</blockquote>\n<h1><strong>🐳</strong>protected 关键字</h1>\n<p>在封装的那一篇开头介绍了访问控制修饰符：<a class=\"link-info\" href=\"https://blog.csdn.net/m0_67995737/article/details/126167008?spm=1001.2014.3001.5501\" title=\"【Java SE】面向对象三大特性之封装\">【Java SE】面向对象三大特性之封装</a></p>\n<p>感兴趣的可以再去了解一下。</p>\n<p><img alt=\"\" src=\"image\\78c698cb5fdc49f3ae28524efb085f3b.png\"/></p>\n<p>这边建立了2个不同的包：</p>\n<p>其中一个是同一个包中的2个类，另一个类在另一个包中：</p>\n<p><img alt=\"\" height=\"174\" src=\"image\\0d3cfe1654e54a8ba7321268ccfde2f5.png\" width=\"472\"/></p>\n<p>首先在同一个包中：</p>\n<pre><code class=\"language-java\">package TestDemo;\n//A.java\npublic class A {\n    public int a;\n    private int b;\n    protected int c;\n    int d;\n}\n//B.java\npackage TestDemo;\n\npublic class B extends A{\n\npublic void method(){\n\n    super.a=20;\n    super.b=100;\n    super.c=30;\n    super.d=40;\n\n\n}\n\n}\n</code></pre>\n<p> <img alt=\"\" height=\"188\" src=\"image\\8fdfc88c736e4627a886ff37f7a90f68.png\" width=\"642\"/></p>\n<p> 虽然不能访问，但是也继承了父类的b成员变量。</p>\n<p>现在是两个包中的：</p>\n<pre><code class=\"language-java\">package TestDemo;\n//A.java\n\npublic class A {\n    public int a;\n    private int b;\n    protected int c;\n    int d;\n}\n//C.java\npackage TestDemo1;\n\nimport TestDemo.A;\n\npublic class C extends A {\n    public void method(){\n\n        super.a=20;\n        super.b=100; //编译报错，父类中private成员在不同包子类中不可见\n        super.c=30;// 父类中protected修饰的成员在不同包子类中可以直接访问\n        super.d=40;// 父类中默认访问权限修饰的成员在不同包子类中不能直接访问\n\n    }\n}\n</code></pre>\n<p><img alt=\"\" height=\"199\" src=\"image\\f24ca02cdc1b4614a4cf67bd7e9f66f1.png\" width=\"696\"/><br/><span style=\"color:#fe2c24;\">注意：我们在使用的时候应该尽可能的使用 比较严格的访问权限. 例如如果一个方法能用 private, 就尽量不要用 public.</span></p>\n<h1><strong>🐳</strong>继承方式</h1>\n<p><span style=\"color:#956fe7;\"> 继承方式有单继承，多层继承和不同类继承同一个类。</span></p>\n<p>一般我们不希望出现超过三层的继承关系. 如果继承层次太多, 就需要考虑对代码进行重构了.<br/> 如果想从语法上进行限制继承, 就可以使用 final 关键字 </p>\n<h1><strong>🐳</strong>final 关键字</h1>\n<p>final关键可以用来修饰变量、成员方法以及类<br/> 1. 修饰变量或字段，表示常量(即不能修改)<br/><img alt=\"\" height=\"113\" src=\"image\\a872769793774b209d484e07b2b939f1.png\" width=\"444\"/><br/> 2. 修饰类：表示此类不能被继承<br/><img alt=\"\" height=\"505\" src=\"image\\7097122e9acf46a8bab375bbee77b4f9.png\" width=\"1200\"/><br/> 3. 修饰方法：表示该方法不能被重写</p>\n<h1><strong>🐳</strong>重写</h1>\n<p>当子类对象调用重写的方法时，调用的是子类的方法，而不是父类中被重写的方法。</p>\n<p>要想调用父类中被重写的方法，则必须使用关键字 super。</p>\n<pre><code class=\"language-java\">public class Animals {\n    public void call(){\n        System.out.println(\"动物叫...\");\n    }\n}\n\n\npublic class Cat extends Animals{\n    @Override\n    public void call() {\n        System.out.println(\"喵喵喵...\");\n    }\n}\n\n\npublic class Dog extends Animals{\n    @Override\n    public void call() {\n        super.call();\n    }\n \n    public static void main(String[] args) {\n        Animals dog = new Dog();\n        dog.call();//动物叫...\n        Animals cat = new Cat();\n        cat.call();//喵喵喵...\n    }\n}\n</code></pre>\n<h1><strong>🐳</strong>继承与组合</h1>\n<p><span style=\"color:#956fe7;\">继承表示对象之间是is-a的关系，比如：狗是动物，猫是动物<br/> 组合表示对象之间是has-a的关系，比如：汽车有发动机，轮胎等等组成</span></p>\n<pre><code class=\"language-java\">class D{\n\n}\nclass E{\n\n}\n//F由D，E构成（组合）\nclass F{\n    private D d; // 可以复用D的属性和方法\n    private E e; // 可以复用E的属性和方法\n   \n}</code></pre>\n<p><span style=\"color:#fe2c24;\">组合和继承都可以实现代码复用，应该使用继承还是组合，需要根据应用场景来选择，一般建议：能用组合尽量用组合。</span></p>\n</div>\n</div>"}