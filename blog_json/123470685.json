{"blogid": "123470685", "writerAge": "码龄3年", "writerBlogNum": "13", "writerCollect": "162", "writerComment": "17", "writerFan": "1874", "writerGrade": "2级", "writerIntegral": "204", "writerName": "soar3033", "writerProfileAdress": "writer_image\\profile_123470685.jpg", "writerRankTotal": "53895", "writerRankWeekly": "3807", "writerThumb": "23", "writerVisitNum": "25112", "blog_read_count": "6084", "blog_time": "已于 2022-04-28 11:31:26 修改", "blog_title": "通过C#和Arduino实现软件示波器", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-light\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p></p>\n<div class=\"toc\">\n<h3>文章目录</h3>\n<ul><li><a href=\"#_4\">前言</a></li><li><a href=\"#_13\">一、作者对示波器的部分理解</a></li><li><a href=\"#_20\">二、软件示波器</a></li><li><a href=\"#_31\">三、软件示波器的实现</a></li><li><ul><li><a href=\"#_32\">采集部分</a></li><li><ul><li><a href=\"#_37\">第一种方式</a></li><li><a href=\"#_43\">第二种方式</a></li><li><a href=\"#_49\">本次的选择</a></li><li><a href=\"#Arduino_53\">Arduino对模拟量的读取和传输</a></li></ul>\n</li><li><a href=\"#PC_72\">PC端程序</a></li><li><ul><li><a href=\"#_74\">界面设计</a></li><li><a href=\"#_80\">串口读取</a></li><li><a href=\"#_127\">数据处理和绘图</a></li></ul>\n</li><li><a href=\"#_168\">最终的效果</a></li><li><a href=\"#_174\">源码</a></li></ul>\n</li></ul>\n</div>\n<p></p>\n<hr/>\n<h1><a id=\"_4\"></a>前言</h1>\n<p>  对于电子爱好者来说，示波器是一件不可或缺的神器。有了示波器的帮助，我们可以根据信号的实际变化来判断我们的电路或单片机程序的正确性。在有错误发生时，通过示波器我们也可以更容易的分析问题的产生点。</p>\n<p>  但我们有没有想过，示波器本身就是一个电子电路，它的结构如何，又是如何工作的？作为一个电子电路的爱好者，我们是否可以搭建一个属于自己的示波器呢？下面作者就来通过Arduino作为信号采集电路来实现一个软件示波器。</p>\n<hr/>\n<h1><a id=\"_13\"></a>一、作者对示波器的部分理解</h1>\n<p>  示波器，顾名思义是一个将信号的波形进行显示的仪器设备。最基本的示波器实际上只需要两个部分——1信号采集、2图像输出。我们直接对信号进行采集，然后将原始信号在屏幕上进行输出这本身已经是一个示波器了。</p>\n<p>  但是如此简陋的示波器存在着巨大的问题：一方面，原始信号如果幅值很大或者很小，那么就会出现信号在屏幕上无法正常显示的问题——比如幅度很小的信号在屏幕上也许只是一条笔直的直线；另一方面，如果单纯的将各种信号进行连续的采集并展现在屏幕上，那么对于变化速度极高的信号我们肉眼很可能观看不到任何稳定的信号，只会觉得屏幕上的信号在不断的闪烁。<br/>   要解决上面说到的两个问题，我们就需要对原始示波器的功能进行扩展。一方面，为了解决信号幅值的问题我们应当引入<strong>幅值调节</strong>；另一方面，为了解决高频率信号的显示问题我们应当引入<strong>触发功能</strong>。</p>\n<h1><a id=\"_20\"></a>二、软件示波器</h1>\n<p>  我们在市场上购买的示波器一般是硬件示波器，它从硬件上包含了一台示波器应该具备的完整功能——信号的采集、处理、显示。</p>\n<p>  硬件示波器有着完整的硬件结构，使得其成本相对较高。对于我们自己制作示波器而言，为了节约成本，可以选择软示波器——即采用硬件对信号进行采集，而对信号的处理和显示通过软件功能在电脑上进行实现。</p>\n<p>  软件示波器，正如前文所提可以分为两个大的部分——一部分是基于电子电路的信号采集部分；另一部分是基于软件的信号处理和显示功能。</p>\n<p>  而如果对整个流程进行描述，则是电子电路对原始信号进行采集（ADC），之后通过通信将采集到的数据发送给计算机里运行的软件。软件在接收到原始信号的数值后，对其幅值进行处理，并根据我们设定的触发方式将信号图形显示到图像区域，如下图。<br/> <img alt=\"在这里插入图片描述\" src=\"image\\99af3ba6fa5e4b948dc1369a595660e2.png\"/></p>\n<h1><a id=\"_31\"></a>三、软件示波器的实现</h1>\n<h2><a id=\"_32\"></a>采集部分</h2>\n<p>  信号采集电路使用STM32F103C8T6最小系统作为基础硬件，通过它所自带的ADC功能来完成信号的采集。采集之后，则通过串口通信将采集到的原始信号传输给我们的软示波器软件。</p>\n<p>  当然，也可以通过其它的电路及开发方式以相同的思路来实现这些功能。（如果你需要将手中的STM32F103C8T6配置为Arduino的开发方式，可以参照这篇文章<a href=\"https://zhuanlan.zhihu.com/p/62246356\">STM32duino——依托Arduino框架玩转STM32（一）： 开发环境的配置</a>）</p>\n<h3><a id=\"_37\"></a>第一种方式</h3>\n<p>  在采集和传输方式上，我们有两种选择：一种是，我们可以选择让Arduino每次采集一个ADC的值，然后通过串口传输，传输完成后再进行下一次的采集。采用这种方式，在编程上是极为简单的，但是在串口传输后再进行下一次的采集将导致采样的频率降低，使得我们无法采集到一些变化较快的信号。</p>\n<p>  例如下图中，上半部分黑色实线是我们的原始信号，细点画线是采集发生的时刻；下半部分的点为对应的采集值。我们可以很容易的发现，对于变化频率较低的信号我们的采样基本可以正确的描述其原始状态，但是对于原始图形中出现的尖峰毛刺我们可能会不能正确的对其捕捉。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\aa7693eaf6b143278941bb20b41197e8.png\"/></p>\n<h3><a id=\"_43\"></a>第二种方式</h3>\n<p>  另一种方式则是：连续的进行ADC采集，将采集到的数据存储于单片机的存储区，在存储区域满后进行连续的串口发送。采用这种方式的优点是提高了信号采集时的采集频率，可以将更高频率的信号变化采集出来。</p>\n<p>  但这种方式也存在自己的缺点，就是采集是间歇性的，即连续的采集——连续的发送——连续的采集（如果采用STM32原生的DMA传输方式可以最大程度减小这种采集的不连续，但这不在我们此次的讨论范围之内）。第二种方式的采集效果可以参照下图，我们很容易的发现高频的毛刺信号可以被采集到了，但是由于传输阶段的存在，采集变得不再连续。<br/> <img alt=\"在这里插入图片描述\" src=\"image\\89d417bd3bbb4a7b8874e298d3fcbbb3.png\"/></p>\n<h3><a id=\"_49\"></a>本次的选择</h3>\n<p>  咱本次的软示波器制作中，我们先采用第一种方式进行。<strong>但如果使用STM32的原生开发模式，更推荐使用DMA的方式来实现第二种采集方式，并将信号触发的功能也在单片机端实现，以实现示波器最佳的性能！！！</strong></p>\n<h3><a id=\"Arduino_53\"></a>Arduino对模拟量的读取和传输</h3>\n<p>  Arduino中的代码相当简单。我们先声明一个int变量an用于存储每次模拟量读取的值，然后再setup中声明PA0引脚的工作模式为INPUT(输入模式，含数字量读取和模拟量读取)，之后开启串口，并选择9600这个中规中矩的波特率。实际上波特率越高对于模拟示波器来说性能越好，当然也会带来一些问题。在此我们先选择9600这个中规中矩的波特率。</p>\n<pre><code class=\"prism language-c\"><span class=\"token keyword\">int</span> an<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">setup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n  <span class=\"token function\">pinMode</span><span class=\"token punctuation\">(</span>PA0<span class=\"token punctuation\">,</span>INPUT<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  Serial<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token number\">9600</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">loop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n  an<span class=\"token operator\">=</span><span class=\"token function\">analogRead</span><span class=\"token punctuation\">(</span>PA0<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  Serial<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>an<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>  之后，在Arduino程序的Loop中，我们依次进行模拟量的读取，串口的模拟量值传输，以及1ms的延时。就此，Arduino端的配置就完成了，当你把程序下载到电路板中后，打开Arduino的串口监视器你会看到一系列变化的数字——即PA0脚的模拟量电压（对于STM32F103来说3.3V对应4095），就像下图。<br/> <img alt=\"在这里插入图片描述\" src=\"image\\ecf844a7f8994667b1138584bedcda85.png\"/></p>\n<h2><a id=\"PC_72\"></a>PC端程序</h2>\n<p>  在完成了Arduino的配置并能够正常的发送读取的模拟量之后，我们便可以开始PC端程序的设计了。PC端程序从功能上来说主要有三个部分，分别是：1串口读取、2数据处理和触发判断、3绘图。在有了这三部分的功能后，程序即可接收到电路板发出的模拟量数值，然后经过处理最终显示在屏幕上。</p>\n<h3><a id=\"_74\"></a>界面设计</h3>\n<p>  针对我们所需要的功能，界面上设计了串口的操作区域——包含串口的选择以及连接、断开操作。设计了触发和扫描方式操作区域，通过这个区域我们可以选择单次扫描（扫描一页图像后停止，在实际的示波器上我们通常用这个功能抓取要分析的信号流）、连续扫描，并设置扫描的触发方式和触发阈值。还加入了一个pictureBox用于显示扫描到的图像结果。</p>\n<p>最终的界面设计如下：<br/> <img alt=\"在这里插入图片描述\" src=\"image\\e8a9f24135ee44568c274d733c266acf.png\"/></p>\n<h3><a id=\"_80\"></a>串口读取</h3>\n<p>  在串口读取部分，我们除了对串口的波特率、较验方式、数据位和停止位进行设置外，最重要的就是绑定串口的接收事件<strong>sp.DataReceived += getValue</strong>。如此一来，每当电脑的串口接收到电路板发来的模拟量数据，便会触发<strong>getValue</strong>来进行处理。<strong>getValue</strong>会读取一行串口数据，然后将数据从字符串转换为int形式，并通过<strong>changeValue1</strong>来传递到主程序的value中（因为getValue被触发时是在单独的线程中活动的，对于跨线程的内容更改必须通过委托的形式）。</p>\n<p>。</p>\n<pre><code class=\"prism language-c\">                sp<span class=\"token punctuation\">.</span>PortName <span class=\"token operator\">=</span> comboBox1<span class=\"token punctuation\">.</span>Text<span class=\"token punctuation\">;</span><span class=\"token comment\">//设置端口</span>\n                sp<span class=\"token punctuation\">.</span>BaudRate <span class=\"token operator\">=</span> <span class=\"token number\">9600</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//设置波特率</span>\n                sp<span class=\"token punctuation\">.</span>Parity <span class=\"token operator\">=</span> Parity<span class=\"token punctuation\">.</span>None<span class=\"token punctuation\">;</span><span class=\"token comment\">//设置校验</span>\n                sp<span class=\"token punctuation\">.</span>DataBits <span class=\"token operator\">=</span> <span class=\"token number\">8</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//设置数据位</span>\n                sp<span class=\"token punctuation\">.</span>StopBits <span class=\"token operator\">=</span> StopBits<span class=\"token punctuation\">.</span>One<span class=\"token punctuation\">;</span><span class=\"token comment\">//设置停止位</span>\n                sp<span class=\"token punctuation\">.</span>DataReceived <span class=\"token operator\">+=</span> getValue<span class=\"token punctuation\">;</span><span class=\"token comment\">//绑定接收事件处理</span>\n                sp<span class=\"token punctuation\">.</span><span class=\"token function\">Open</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//打开串口</span>\n</code></pre>\n<pre><code class=\"prism language-c\">        private <span class=\"token keyword\">void</span> <span class=\"token function\">getValue</span><span class=\"token punctuation\">(</span>object obj<span class=\"token punctuation\">,</span> SerialDataReceivedEventArgs e<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{<!-- --></span>\n            string tmp<span class=\"token operator\">=</span>sp<span class=\"token punctuation\">.</span><span class=\"token function\">ReadLine</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            try\n            <span class=\"token punctuation\">{<!-- --></span>\n                <span class=\"token keyword\">int</span> tmp2 <span class=\"token operator\">=</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">.</span><span class=\"token function\">Parse</span><span class=\"token punctuation\">(</span>tmp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token function\">changeValue1</span><span class=\"token punctuation\">(</span>tmp2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token function\">catch</span> <span class=\"token punctuation\">(</span>Exception<span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">{<!-- --></span>\n\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n</code></pre>\n<pre><code class=\"prism language-c\">        private <span class=\"token keyword\">void</span> <span class=\"token function\">changeValue1</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> v<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{<!-- --></span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>InvokeRequired<span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">{<!-- --></span>\n                D1 d <span class=\"token operator\">=</span> new <span class=\"token function\">D1</span><span class=\"token punctuation\">(</span>changeValue1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                this<span class=\"token punctuation\">.</span><span class=\"token function\">Invoke</span><span class=\"token punctuation\">(</span>d<span class=\"token punctuation\">,</span> v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">else</span>\n            <span class=\"token punctuation\">{<!-- --></span>\n                value <span class=\"token operator\">=</span> v<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n</code></pre>\n<h3><a id=\"_127\"></a>数据处理和绘图</h3>\n<p>  当扫描开始进行后，我们会开启一个单独的扫描线程，由改线程来进行数据的处理和绘图，以防止主界面的阻塞。</p>\n<pre><code class=\"prism language-c\">\t\tth1 <span class=\"token operator\">=</span> new <span class=\"token function\">Thread</span><span class=\"token punctuation\">(</span>new <span class=\"token function\">ThreadStart</span><span class=\"token punctuation\">(</span>scan<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//否则进行连续扫描</span>\n\t\tth1<span class=\"token punctuation\">.</span><span class=\"token function\">Start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>  扫描线程通过Sleep的方式控制两次采集的间隔，以此来达到水平缩放的目的。需要注意的是，实际的示波器的采集间隔是通过单片机定时器中断实现的。在我们的虚拟示波器中，这个功能实际上很不好用——因为我们的最高扫描速度本来就不快，已经没有缩放的必要了。这里依然做出此功能是为了让大家理解实际示波器的工作方式。</p>\n<p>  由于在C#的pictureBox中，图像的Y坐标越大图像反而越低，所以我们采用<strong>600-value<em>v_mul</em>600/4096</strong>这种方式来对图像进行垂直方向的颠倒。其中，600是我们的pictureBox的高度。</p>\n<p>  之后我们通过Graphics对象来将读取到的所有点以直线的方式连续的画到画布（Bitmap）上，并通过<strong>changePic</strong>将pictureBox的图像内容变为我们的画布，由此完成图像的输出。</p>\n<pre><code class=\"prism language-c\">            <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>true<span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">{<!-- --></span>\n                Thread<span class=\"token punctuation\">.</span><span class=\"token function\">Sleep</span><span class=\"token punctuation\">(</span>h_mul<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//通过延时来实现水平坐标的缩放功能，当h_mul越大，两次取点的间隔越大，实现了图像水平的缩小。在硬件示波器上，也是这样的原理，只是通过时钟中断来控制扫描取点的间隔</span>\n                values_tmp<span class=\"token punctuation\">[</span>count<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">600</span><span class=\"token operator\">-</span>value<span class=\"token operator\">*</span>v_mul<span class=\"token operator\">*</span><span class=\"token number\">600</span><span class=\"token operator\">/</span><span class=\"token number\">4096</span><span class=\"token punctuation\">;</span>\n                count<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n                count2<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>count <span class=\"token operator\">==</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">{<!-- --></span>\n                    count <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>count2<span class=\"token operator\">&gt;</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">{<!-- --></span>\n                    count2 <span class=\"token operator\">=</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n                bmp_tmp <span class=\"token operator\">=</span> new <span class=\"token function\">Bitmap</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">,</span> <span class=\"token number\">600</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//创建新的画布</span>\n                g <span class=\"token operator\">=</span> Graphics<span class=\"token punctuation\">.</span><span class=\"token function\">FromImage</span><span class=\"token punctuation\">(</span>bmp_tmp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//创建绘画对象</span>\n                <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> count2<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token comment\">//进行绘画</span>\n                <span class=\"token punctuation\">{<!-- --></span>\n                    g<span class=\"token punctuation\">.</span><span class=\"token function\">DrawLine</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">,</span> new <span class=\"token function\">Point</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> values_tmp<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> new <span class=\"token function\">Point</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span> values_tmp<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//将每个采集点进行直线绘画</span>\n                <span class=\"token punctuation\">}</span>\n                <span class=\"token function\">changePic</span><span class=\"token punctuation\">(</span>bmp_tmp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//更新显示的图像</span>\n\n            <span class=\"token punctuation\">}</span>\n</code></pre>\n<h2><a id=\"_168\"></a>最终的效果</h2>\n<p>  打开程序，对串口进行连接，并开启扫描，便可以对PA0端口的电压进行采集并对波形绘图了。<br/> <img alt=\"在这里插入图片描述\" src=\"image\\5beb2fe914234e07928c7e7927cf0f59.png\"/></p>\n<h2><a id=\"_174\"></a>源码</h2>\n<p><a href=\"https://download.csdn.net/download/soar3033/85006935\">虚拟示波器的C#程序源码</a></p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}