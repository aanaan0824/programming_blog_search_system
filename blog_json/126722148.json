{"blogid": "126722148", "writerAge": "码龄4年", "writerBlogNum": "363", "writerCollect": "369", "writerComment": "273", "writerFan": "740", "writerGrade": "6级", "writerIntegral": "7131", "writerName": "码海兴辰", "writerProfileAdress": "writer_image\\profile_126722148.jpg", "writerRankTotal": "2388", "writerRankWeekly": "481", "writerThumb": "417", "writerVisitNum": "390902", "blog_read_count": "183", "blog_time": "于 2022-09-06 11:57:45 发布", "blog_title": "MQ学习之史上最全RabbitMQ（强烈建议收藏）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p style=\"margin-left:.0001pt;text-align:justify;\"><strong><strong>一：RabbitMQ</strong></strong></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">在RabbitMQ的<a href=\"https://rabbitmq.com/getstarted.html\" title=\"官方网站\">官方网站</a>中，可以找到文档和资料。</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><strong><strong>1.安装RabbitMQ</strong></strong></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">参考RabbitMQ部署指南.md</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><strong><strong>2.MQ的基本结构</strong></strong></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><img alt=\"\" height=\"226\" src=\"image\\54e0ab5480cf4cd3a6848dc1d16ecf41.png\" width=\"554\"/></p>\n<p> </p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">RabbitMQ中的一些角色：</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">·publisher：生产者</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">·consumer：消费者</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">·exchange个：交换机，负责消息路由</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">·queue：队列，存储消息</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">·virtualHost：虚拟主机，隔离不同租户的exchange、queue、消息的隔离</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><strong><strong>3.RabbitMQ消息模型</strong></strong></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">RabbitMQ官方提供了5个不同的Demo示例，对应了不同的消息模型：</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><img alt=\"\" height=\"258\" src=\"image\\674f49f0c8f6406eb51a00bc9f91644b.png\" width=\"521\"/></p>\n<p> </p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><strong><strong>4.入门案例</strong></strong></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">简单队列模式的模型图：</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><img alt=\"\" height=\"78\" src=\"image\\f4aaf6731f064d4bba4aee6ca398eeff.png\" width=\"554\"/></p>\n<p> </p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">官方的HelloWorld是基于最基础的消息队列模型来实现的，只包括三个角色：</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">·publisher：消息发布者，将消息发送到队列queue</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">·queue：消息队列，负责接受并缓存消息</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">·consumer：订阅队列，处理队列中的消息</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><strong><strong>5.publisher实现</strong></strong></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">思路：</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">·建立连接</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">·创建Channel</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">·声明队列</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">·发送消息</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">·关闭连接和channel</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><img alt=\"\" height=\"515\" src=\"image\\e139304f726b40c78555886d4be41c08.png\" width=\"554\"/></p>\n<p> </p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><strong><strong>6.consumer实现</strong></strong></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">代码思路：</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">·建立连接</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">·创建Channel</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">·声明队列</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">·订阅消息</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><img alt=\"\" height=\"582\" src=\"image\\af75d97f5abb496695f1da40d53806cf.png\" width=\"554\"/></p>\n<p> </p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><strong><strong>7.基本消息队列的消息发送流程：</strong></strong></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">·建立connection</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">·创建channel</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">·利用channel声明队列</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">·利用channel向队列发送消息</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><strong><strong>8.基本消息队列的消息接收流程：</strong></strong></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">·建立connection</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">·创建channel</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">·利用channel声明队列</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">·定义consumer的消费行为handleDelivery()</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">·利用channel将消费者与队列绑定</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><strong><strong>9.SpringAMQP</strong></strong></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">SpringAMQP是基于RabbitMQ封装的一套模板，并且还利用SpringBoot对其实现了自动装配，使用起来非常方便。</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">SpringAmqp的官方地址：<a href=\"https://spring.io/projects/spring-amqp\" title=\"Spring AMQP\">Spring AMQP</a></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><img alt=\"\" height=\"382\" src=\"image\\a2bb602426794d92be454623e89fa12a.png\" width=\"321\"/></p>\n<p> </p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">SpringAMQP提供了三个功能：</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">·自动声明队列、交换机及其绑定关系</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">·基于注解的监听器模式，异步接收消息</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">·封装了RabbitTemplate工具，用于发送消息</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><strong><strong>10.Basic Queue 简单队列模型</strong></strong></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">1.引入依赖</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><img alt=\"\" height=\"88\" src=\"image\\ef5385bff0c5450a8729d9c6ef357234.png\" width=\"554\"/></p>\n<p> </p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><strong><strong>2.</strong></strong><strong><strong>消息发送</strong></strong></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">首先配置MQ地址，在publisher服务的application.yml中添加配置：</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><img alt=\"\" height=\"172\" src=\"image\\81008a00722b4d7c98ea284d1fcda847.png\" width=\"403\"/></p>\n<p> </p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">然后在publisher服务中编写测试类SpringAmqpTest，并利用RabbitTemplate实现消息发送：</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><img alt=\"\" height=\"265\" src=\"image\\9e65673de2604f3fb97f9775b6336233.png\" width=\"374\"/></p>\n<p> </p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><strong><strong>3.消息接收</strong></strong></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">首先配置MQ地址，在consumer服务的application.yml中添加配置：</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><img alt=\"\" height=\"170\" src=\"image\\285ed9be01e84a8296618953c63e6ecd.png\" width=\"380\"/></p>\n<p> </p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">然后在consumer服务中新建一个类 ，代码如下：</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><img alt=\"\" height=\"144\" src=\"image\\8004fff61de040f7852bcf55df9d5e42.png\" width=\"554\"/></p>\n<p> <img alt=\"\" height=\"144\" src=\"image\\db0a4f2d8f134002b5ec2b5221f5d32c.png\" width=\"554\"/></p>\n<p> </p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><strong><strong>11.WorkQueue</strong></strong></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">Work queues，也被称为（Task queues），任务模型。简单来说就是<strong><strong>让多个消费者绑定到一个队列，共同消费队列中的消息</strong></strong>。</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><img alt=\"\" height=\"170\" src=\"image\\858800c3a6494021a75031db253299cc.png\" width=\"453\"/></p>\n<p> </p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">此时就可以使用work 模型，多个消费者共同处理消息处理，速度就能大大提高了。</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><strong><strong>消息发送</strong></strong></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">这次我们循环发送，模拟大量消息堆积现象。</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">在publisher服务中的SpringAmqpTest类中添加一个测试方法：</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><img alt=\"\" height=\"322\" src=\"image\\c2e11ce73e764c949f0f5d27889c594a.png\" width=\"490\"/></p>\n<p> </p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><strong><strong>消息</strong></strong><strong><strong>接收</strong></strong></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">模拟多个消费者绑定同一个队列，需要在consumer服务的SpringRabbitListener中添加2个新的方法：</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><img alt=\"\" height=\"184\" src=\"image\\8ab92f75d4b445b6a9563b1c6fe6de64.png\" width=\"554\"/></p>\n<p> </p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">注意到这个消费者进行了sleep，模拟任务耗时。</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><strong><strong>测试结果</strong></strong></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">启动ConsumerApplication后，在执行publisher服务中刚刚编写的发送测试方法testWorkQueue。</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">可以看到消费者1很快完成了自己的25条消息。消费者2却在缓慢的处理自己的25条消息。也就是说消息是平均分配给每个消费者，并没有考虑到消费者的处理能力。这样显然是有问题的。</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><strong><strong>能者多劳</strong></strong></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">在spring中有一个简单的配置，可以解决这个问题。修改consumer服务的application.yml文件，添加配置：</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><img alt=\"\" height=\"114\" src=\"image\\0fec865098744259b9fcf0444e1c532f.png\" width=\"554\"/></p>\n<p> </p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><strong><strong>总结：</strong></strong></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">Work模型的使用：</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">·多个消费者绑定到一个队列，同一条消息只会被一个消费者处理</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">·通过设置prefetch来控制消费者预取的消息数量</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><strong><strong>12.发布/订阅</strong></strong></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">发布订阅的模型如图：</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><img alt=\"\" height=\"159\" src=\"image\\2f4941c811b04310af6f979906e06430.png\" width=\"488\"/></p>\n<p> </p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">可以看到，在订阅模型中，多了一个exchange角色，而且过程略有变化：</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">·Publisher：生产者，也就是要发送消息的程序，但是不再发送到队列中，而是发给X（交换机）</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">·Exchange：交换机，图中的X。一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。Exchange有以下3种类型：</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><strong><strong>Fanout：</strong></strong>广播，将消息交给所有绑定到交换机的队列</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><strong><strong>Direct：</strong></strong>定向，把消息交给符合指定routing key 的队列</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><strong><strong>Topic：</strong></strong>通配符，把消息交给符合routing pattern（路由模式） 的队列</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">·Consumer：消费者，与以前一样，订阅队列，没有变化</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">·Queue：消息队列也与以前一样，接收消息、缓存消息。</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><strong><span style=\"color:#ff0000;\"><strong>Exchange（交换机）只负责转发消息，不具备存储消息的能力</strong></span></strong>，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><strong><strong>Fanout</strong></strong></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">Fanout，英文翻译是扇出，在MQ中叫广播更合适。</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><img alt=\"\" height=\"155\" src=\"image\\2e19d24e576240269b3393aaef0afc65.png\" width=\"579\"/></p>\n<p> </p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">在广播模式下，消息发送流程是这样的：</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">1） 可以有多个队列</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">2） 每个队列都要绑定到Exchange（交换机）</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">3） 生产者发送的消息，只能发送到交换机，交换机来决定要发给哪个队列，生产者无法决定</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">4） 交换机把消息发送给绑定过的所有队列</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">5） 订阅队列的消费者都能拿到消息</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><strong><strong>声明队列和交换机</strong></strong></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">Spring提供了一个接口Exchange，来表示所有不同类型的交换机：</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><img alt=\"\" height=\"185\" src=\"image\\a10cd4d4d9234e2bbacfb4cac78d2957.png\" width=\"554\"/></p>\n<p> </p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">在consumer中创建一个类，声明队列和交换机：</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><img alt=\"\" height=\"471\" src=\"image\\7208e95408b3443db664bd653fb0d9e9.png\" width=\"554\"/></p>\n<p> </p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><strong><strong>消息发送</strong></strong></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><img alt=\"\" height=\"187\" src=\"image\\7e1f7c24b08b40a3b9228f6820560a6a.png\" width=\"544\"/></p>\n<p> </p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><strong><strong>消息接收</strong></strong></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">在consumer服务的SpringRabbitListener中添加两个方法，作为消费者：</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><img alt=\"\" height=\"198\" src=\"image\\3b6b688ac7a14750b117ef48c8cdc42c.png\" width=\"554\"/></p>\n<p> </p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><strong><strong>13.Direct</strong></strong></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">在Fanout模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange。</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><img alt=\"\" height=\"176\" src=\"image\\e1c02a5973b34e5f9cd5cbb2ef9d4beb.png\" width=\"554\"/></p>\n<p> </p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">在Direct模型下：</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">·队列与交换机的绑定，不能是任意绑定了，而是要指定一个RoutingKey（路由key）</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">·消息的发送方在 向 Exchange发送消息时，也必须指定消息的 RoutingKey。</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">·Exchange不再把消息交给每一个绑定的队列，而是根据消息的Routing Key进行判断，只有队列的Routingkey与消息的 Routing key完全一致，才会接收到消息</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><strong><strong>基于注解声明队列和交换机</strong></strong></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">基于@Bean的方式声明队列和交换机比较麻烦，Spring还提供了基于注解方式来声明。</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">在consumer的SpringRabbitListener中添加两个消费者，同时基于注解来声明队列和交换机：</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><img alt=\"\" height=\"310\" src=\"image\\0286c26365994838966adfe07695723b.png\" width=\"554\"/></p>\n<p> </p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><strong><strong>@Exchange(type = ExchangeTypes.DIRECT)：指定交换机的类型</strong></strong></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><strong><strong>消息发送</strong></strong></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">在publisher服务的SpringAmqpTest类中添加测试方法：</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"></p>\n<p style=\"margin-left:.0001pt;text-align:justify;\"><img alt=\"\" height=\"180\" src=\"image\\15b9cf34c74e41eda79904f7ea8b40ba.png\" width=\"554\"/></p>\n<p> </p>\n</div>\n</div>"}