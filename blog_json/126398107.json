{"blogid": "126398107", "writerAge": "码龄1年", "writerBlogNum": "49", "writerCollect": "253", "writerComment": "470", "writerFan": "1273", "writerGrade": "4级", "writerIntegral": "1530", "writerName": "beyond.myself", "writerProfileAdress": "writer_image\\profile_126398107.jpg", "writerRankTotal": "12428", "writerRankWeekly": "1574", "writerThumb": "562", "writerVisitNum": "27872", "blog_read_count": "762", "blog_time": "已于 2022-09-05 16:50:08 修改", "blog_title": "C++：map和set", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E4%B8%80.set%E4%BB%8B%E7%BB%8D-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%80.set%E4%BB%8B%E7%BB%8D\">一.set介绍</a></p>\n<p id=\"1.set%E4%BB%8B%E7%BB%8D-toc\" style=\"margin-left:40px;\"><a href=\"#1.set%E4%BB%8B%E7%BB%8D\">1.set介绍</a></p>\n<p id=\"2.insert%20%E4%BD%BF%E7%94%A8-toc\" style=\"margin-left:40px;\"><a href=\"#2.insert%20%E4%BD%BF%E7%94%A8\">2.insert 使用</a></p>\n<p id=\"%C2%A0set%E4%B8%AD%E7%9A%84%E6%99%AE%E9%80%9A%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%B0%B1%E6%98%AF%E7%94%A8%E7%9A%84const%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%81%EF%BC%81-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A0set%E4%B8%AD%E7%9A%84%E6%99%AE%E9%80%9A%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%B0%B1%E6%98%AF%E7%94%A8%E7%9A%84const%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%81%EF%BC%81\"> set中的普通迭代器就是用的const迭代器！！</a></p>\n<p id=\"3.find-toc\" style=\"margin-left:40px;\"><a href=\"#3.find\">3.find</a></p>\n<p id=\"set%3A%3Afind%E5%92%8Cstd%3A%3Afind%E5%AF%B9%E6%AF%94-toc\" style=\"margin-left:80px;\"><a href=\"#set%3A%3Afind%E5%92%8Cstd%3A%3Afind%E5%AF%B9%E6%AF%94\">set::find和std::find对比</a></p>\n<p id=\"4.erase-toc\" style=\"margin-left:40px;\"><a href=\"#4.erase\">4.erase</a></p>\n<p id=\"5.swap%20%E6%A0%B9%E8%8A%82%E7%82%B9%E4%BA%A4%E6%8D%A2-toc\" style=\"margin-left:40px;\"><a href=\"#5.swap%20%E6%A0%B9%E8%8A%82%E7%82%B9%E4%BA%A4%E6%8D%A2\">5.swap 根节点交换</a></p>\n<p id=\"6.count%20%E6%AF%94find%E6%96%B9%E4%BE%BF-toc\" style=\"margin-left:40px;\"><a href=\"#6.count%20%E6%AF%94find%E6%96%B9%E4%BE%BF\">6.count 比find方便</a></p>\n<p id=\"7.lower_bound%EF%BC%9A%E8%BF%94%E5%9B%9E%3E%3D%20val%E5%BE%97%E4%BD%8D%E7%BD%AE%E8%BF%AD%E4%BB%A3%E5%99%A8-toc\" style=\"margin-left:40px;\"><a href=\"#7.lower_bound%EF%BC%9A%E8%BF%94%E5%9B%9E%3E%3D%20val%E5%BE%97%E4%BD%8D%E7%BD%AE%E8%BF%AD%E4%BB%A3%E5%99%A8\">7.lower_bound：返回&gt;= val得位置迭代器</a></p>\n<p id=\"%EF%BC%881%EF%BC%89lower_bound-toc\" style=\"margin-left:80px;\"><a href=\"#%EF%BC%881%EF%BC%89lower_bound\">（1）lower_bound</a></p>\n<p id=\"%E7%94%A8%E9%80%94%EF%BC%9A%E4%B8%BE%E4%BE%8B%EF%BC%9A%E8%A6%81%E6%B1%82%E5%88%A0%E9%99%A4%3E%3Dx%E7%9A%84%E6%89%80%E6%9C%89%E5%80%BC%EF%BC%9A-toc\" style=\"margin-left:80px;\"><a href=\"#%E7%94%A8%E9%80%94%EF%BC%9A%E4%B8%BE%E4%BE%8B%EF%BC%9A%E8%A6%81%E6%B1%82%E5%88%A0%E9%99%A4%3E%3Dx%E7%9A%84%E6%89%80%E6%9C%89%E5%80%BC%EF%BC%9A\">用途：举例：要求删除&gt;=x的所有值：</a></p>\n<p id=\"%EF%BC%882%EF%BC%89upper_bound%C2%A0%E8%BF%94%E5%9B%9E%3Ex%E4%BD%8D%E7%BD%AE%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8-toc\" style=\"margin-left:80px;\"><a href=\"#%EF%BC%882%EF%BC%89upper_bound%C2%A0%E8%BF%94%E5%9B%9E%3Ex%E4%BD%8D%E7%BD%AE%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8\">（2）upper_bound 返回&gt;x位置的迭代器</a></p>\n<p id=\"8.%20std%3A%3Amultiset%20%E8%B7%9Fset%E6%8E%A5%E5%8F%A3%E4%B8%80%E6%A0%B7%EF%BC%8C%E5%8F%AA%E6%98%AF%E5%85%81%E8%AE%B8%E5%86%97%E4%BD%99%EF%BC%8C%E4%B8%8D%E5%8E%BB%E9%87%8D-toc\" style=\"margin-left:40px;\"><a href=\"#8.%20std%3A%3Amultiset%20%E8%B7%9Fset%E6%8E%A5%E5%8F%A3%E4%B8%80%E6%A0%B7%EF%BC%8C%E5%8F%AA%E6%98%AF%E5%85%81%E8%AE%B8%E5%86%97%E4%BD%99%EF%BC%8C%E4%B8%8D%E5%8E%BB%E9%87%8D\">8. std::multiset 跟set接口一样，只是允许冗余，不去重</a></p>\n<p id=\"9.set%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE-toc\" style=\"margin-left:40px;\"><a href=\"#9.set%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE\">9.set相关题目</a></p>\n<p id=\"%E4%BA%8C.map%E7%94%A8%E6%B3%95%E4%BB%8B%E7%BB%8D-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BA%8C.map%E7%94%A8%E6%B3%95%E4%BB%8B%E7%BB%8D\">二.map用法介绍</a></p>\n<p id=\"%E5%87%A0%E4%B8%AAmap%E5%92%8Cset%E7%9A%84%E5%86%B7%E7%9F%A5%E8%AF%86%EF%BC%9A-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%87%A0%E4%B8%AAmap%E5%92%8Cset%E7%9A%84%E5%86%B7%E7%9F%A5%E8%AF%86%EF%BC%9A\">几个map和set的冷知识：</a></p>\n<p id=\"map%EF%BC%9A-toc\" style=\"margin-left:40px;\"><a href=\"#map%EF%BC%9A\">map：</a></p>\n<p id=\"%E2%91%A0map%E6%98%AFC%2B%2B98%E4%B8%AD%E5%B7%B2%E5%AD%98%E5%9C%A8%E7%9A%84%EF%BC%8Cunordered_map%E6%98%AFC%2B%2B11%E4%B8%AD%E6%89%8D%E6%9C%89%E7%9A%84-toc\" style=\"margin-left:80px;\"><a href=\"#%E2%91%A0map%E6%98%AFC%2B%2B98%E4%B8%AD%E5%B7%B2%E5%AD%98%E5%9C%A8%E7%9A%84%EF%BC%8Cunordered_map%E6%98%AFC%2B%2B11%E4%B8%AD%E6%89%8D%E6%9C%89%E7%9A%84\">①map是C++98中已存在的，unordered_map是C++11中才有的</a></p>\n<p id=\"%E2%91%A1map%E4%B8%AD%E9%83%BD%E9%87%8D%E8%BD%BD%E4%BA%86%5B%5D%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%8Cmultimap%E4%B8%AD%E6%B2%A1%E6%9C%89%E9%87%8D%E8%BD%BD%5B%5D%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%8Cset%E4%B9%9F%E6%B2%A1%E6%9C%89%E9%87%8D%E8%BD%BD%5B%5D%E3%80%82-toc\" style=\"margin-left:80px;\"><a href=\"#%E2%91%A1map%E4%B8%AD%E9%83%BD%E9%87%8D%E8%BD%BD%E4%BA%86%5B%5D%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%8Cmultimap%E4%B8%AD%E6%B2%A1%E6%9C%89%E9%87%8D%E8%BD%BD%5B%5D%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%8Cset%E4%B9%9F%E6%B2%A1%E6%9C%89%E9%87%8D%E8%BD%BD%5B%5D%E3%80%82\">②map中都重载了[]运算符，multimap中没有重载[]运算符，set也没有重载[]。</a></p>\n<p id=\"%E2%91%A2map%E4%B8%ADkey%E4%B8%8D%E8%83%BD%E4%BF%AE%E6%94%B9%EF%BC%8C%E5%9B%A0%E4%B8%BA%E5%A6%82%E6%9E%9C%E4%BF%AE%E6%94%B9%E4%BA%86%E5%B0%B1%E4%B8%8D%E8%83%BD%E4%BF%9D%E8%AF%81%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%9C%89%E5%BA%8F%E7%89%B9%E6%80%A7%E4%BA%86-toc\" style=\"margin-left:80px;\"><a href=\"#%E2%91%A2map%E4%B8%ADkey%E4%B8%8D%E8%83%BD%E4%BF%AE%E6%94%B9%EF%BC%8C%E5%9B%A0%E4%B8%BA%E5%A6%82%E6%9E%9C%E4%BF%AE%E6%94%B9%E4%BA%86%E5%B0%B1%E4%B8%8D%E8%83%BD%E4%BF%9D%E8%AF%81%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%9C%89%E5%BA%8F%E7%89%B9%E6%80%A7%E4%BA%86\">③map中key不能修改，因为如果修改了就不能保证红黑树的有序特性了</a></p>\n<p id=\"set%EF%BC%9A-toc\" style=\"margin-left:40px;\"><a href=\"#set%EF%BC%9A\">set：</a></p>\n<p id=\"%E2%91%A0set%E4%B8%AD%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%AD%98%E5%82%A8%E9%94%AE%E5%80%BC%E5%AF%B9%EF%BC%8C%E5%AE%9E%E4%BE%8B%E5%8C%96set%E6%97%B6%EF%BC%8C%E5%B0%86set%E4%B8%AD%E5%85%83%E7%B4%A0%E7%B1%BB%E5%9E%8B%E8%AE%BE%E7%BD%AE%E4%B8%BApair%E5%8D%B3%E5%8F%AF-toc\" style=\"margin-left:80px;\"><a href=\"#%E2%91%A0set%E4%B8%AD%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%AD%98%E5%82%A8%E9%94%AE%E5%80%BC%E5%AF%B9%EF%BC%8C%E5%AE%9E%E4%BE%8B%E5%8C%96set%E6%97%B6%EF%BC%8C%E5%B0%86set%E4%B8%AD%E5%85%83%E7%B4%A0%E7%B1%BB%E5%9E%8B%E8%AE%BE%E7%BD%AE%E4%B8%BApair%E5%8D%B3%E5%8F%AF\">①set中也可以存储键值对，实例化set时，将set中元素类型设置为pair即可</a></p>\n<p id=\"%E2%91%A1set%E9%BB%98%E8%AE%A4%E6%98%AF%E5%8D%87%E5%BA%8F%EF%BC%8C%E4%BD%86%E6%98%AF%E5%85%B6%E5%86%85%E9%83%A8%E9%BB%98%E8%AE%A4%E4%B8%8D%E6%98%AF%E6%8C%89%E7%85%A7%E5%A4%A7%E4%BA%8E%E6%AF%94%E8%BE%83%EF%BC%8C%E8%80%8C%E6%98%AF%E6%8C%89%E7%85%A7%20less%E5%B0%8F%E4%BA%8E%E6%AF%94%E8%BE%83-toc\" style=\"margin-left:80px;\"><a href=\"#%E2%91%A1set%E9%BB%98%E8%AE%A4%E6%98%AF%E5%8D%87%E5%BA%8F%EF%BC%8C%E4%BD%86%E6%98%AF%E5%85%B6%E5%86%85%E9%83%A8%E9%BB%98%E8%AE%A4%E4%B8%8D%E6%98%AF%E6%8C%89%E7%85%A7%E5%A4%A7%E4%BA%8E%E6%AF%94%E8%BE%83%EF%BC%8C%E8%80%8C%E6%98%AF%E6%8C%89%E7%85%A7%20less%E5%B0%8F%E4%BA%8E%E6%AF%94%E8%BE%83\">②set默认是升序，但是其内部默认不是按照大于比较，而是按照 less小于比较</a></p>\n<p id=\"%E2%91%A2map%E5%92%8Cset%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E9%83%BD%E6%98%AFO(log_2N)-toc\" style=\"margin-left:80px;\"><a href=\"#%E2%91%A2map%E5%92%8Cset%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E9%83%BD%E6%98%AFO%28log_2N%29\">③map和set查询的时间复杂度都是O(log_2N)</a></p>\n<p id=\"%E2%91%A3map%E5%92%8Cset%E5%BA%95%E5%B1%82%E9%83%BD%E6%98%AF%E4%BD%BF%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91%E5%AE%9E%E7%8E%B0%E7%9A%84-toc\" style=\"margin-left:80px;\"><a href=\"#%E2%91%A3map%E5%92%8Cset%E5%BA%95%E5%B1%82%E9%83%BD%E6%98%AF%E4%BD%BF%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91%E5%AE%9E%E7%8E%B0%E7%9A%84\">④map和set底层都是使用红黑树实现的</a></p>\n<p id=\"1.pair%E5%92%8Cmake_pair-toc\" style=\"margin-left:40px;\"><a href=\"#1.pair%E5%92%8Cmake_pair\">1.pair和make_pair</a></p>\n<p id=\"%EF%BC%881%EF%BC%89pair%E9%94%AE%E5%80%BC%E5%AF%B9%20%E7%9A%84%E4%BB%8B%E7%BB%8D-toc\" style=\"margin-left:80px;\"><a href=\"#%EF%BC%881%EF%BC%89pair%E9%94%AE%E5%80%BC%E5%AF%B9%20%E7%9A%84%E4%BB%8B%E7%BB%8D\">（1）pair键值对 的介绍</a></p>\n<p id=\"%EF%BC%882%EF%BC%89make_pair%20%E4%BB%8B%E7%BB%8D-toc\" style=\"margin-left:80px;\"><a href=\"#%EF%BC%882%EF%BC%89make_pair%20%E4%BB%8B%E7%BB%8D\">（2）make_pair 介绍</a></p>\n<p id=\"2.map%E7%9A%84%E9%81%8D%E5%8E%86-toc\" style=\"margin-left:40px;\"><a href=\"#2.map%E7%9A%84%E9%81%8D%E5%8E%86\">2.map的遍历</a></p>\n<p id=\"%EF%BC%881%EF%BC%89%E8%8B%B1%E6%B1%89%E5%AD%97%E5%85%B8%E7%9A%84%E9%81%8D%E5%8E%86-toc\" style=\"margin-left:80px;\"><a href=\"#%EF%BC%881%EF%BC%89%E8%8B%B1%E6%B1%89%E5%AD%97%E5%85%B8%E7%9A%84%E9%81%8D%E5%8E%86\">（1）英汉字典的遍历</a></p>\n<p id=\"%EF%BC%882%EF%BC%89%E8%AE%B0%E5%BD%95%E6%B0%B4%E6%9E%9C%E6%AC%A1%E6%95%B0-toc\" style=\"margin-left:80px;\"><a href=\"#%EF%BC%882%EF%BC%89%E8%AE%B0%E5%BD%95%E6%B0%B4%E6%9E%9C%E6%AC%A1%E6%95%B0\">（2）记录水果次数</a></p>\n<p id=\"3.insert%E5%86%99%E6%B3%95%E6%8F%90%E9%AB%98%20%E8%AE%B0%E5%BD%95%E6%B0%B4%E6%9E%9C%E6%AC%A1%E6%95%B0%20%E7%9A%84%E6%95%88%E7%8E%87%EF%BC%88%E4%B8%8D%E8%BF%99%E4%B9%88%E5%86%99%EF%BC%8C%E5%8F%AA%E6%98%AF%E4%B8%BA%5B%5D%E5%81%9A%E9%93%BA%E5%9E%AB%EF%BC%89-toc\" style=\"margin-left:40px;\"><a href=\"#3.insert%E5%86%99%E6%B3%95%E6%8F%90%E9%AB%98%20%E8%AE%B0%E5%BD%95%E6%B0%B4%E6%9E%9C%E6%AC%A1%E6%95%B0%20%E7%9A%84%E6%95%88%E7%8E%87%EF%BC%88%E4%B8%8D%E8%BF%99%E4%B9%88%E5%86%99%EF%BC%8C%E5%8F%AA%E6%98%AF%E4%B8%BA%5B%5D%E5%81%9A%E9%93%BA%E5%9E%AB%EF%BC%89\">3.insert写法提高 记录水果次数 的效率（不这么写，只是为[]做铺垫）</a></p>\n<p id=\"4.operator%5B%5D%20%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#4.operator%5B%5D%20%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%C2%A0\">4.operator[] 运算符重载 </a></p>\n<p id=\"%EF%BC%881%EF%BC%89%20%E6%8F%90%E9%AB%98%20%E8%AE%B0%E5%BD%95%E6%B0%B4%E6%9E%9C%E6%AC%A1%E6%95%B0%20%E7%9A%84%E6%95%88%E7%8E%87%E7%9A%84%E7%9C%9F%E6%AD%A3%E5%86%99%E6%B3%95%EF%BC%9A-toc\" style=\"margin-left:80px;\"><a href=\"#%EF%BC%881%EF%BC%89%20%E6%8F%90%E9%AB%98%20%E8%AE%B0%E5%BD%95%E6%B0%B4%E6%9E%9C%E6%AC%A1%E6%95%B0%20%E7%9A%84%E6%95%88%E7%8E%87%E7%9A%84%E7%9C%9F%E6%AD%A3%E5%86%99%E6%B3%95%EF%BC%9A\">（1） 提高 记录水果次数 的效率的真正写法：</a></p>\n<p id=\"%EF%BC%882%EF%BC%89%20%E5%AD%97%E5%85%B8%E4%B8%AD%E5%88%A9%E7%94%A8%5B%5D%E6%8F%92%E5%85%A5%E6%88%96%E4%BF%AE%E6%94%B9%20%E7%A4%BA%E4%BE%8B-toc\" style=\"margin-left:80px;\"><a href=\"#%EF%BC%882%EF%BC%89%20%E5%AD%97%E5%85%B8%E4%B8%AD%E5%88%A9%E7%94%A8%5B%5D%E6%8F%92%E5%85%A5%E6%88%96%E4%BF%AE%E6%94%B9%20%E7%A4%BA%E4%BE%8B\">（2） 字典中利用[]插入或修改 示例</a></p>\n<p id=\"5.multimap%20%E5%85%81%E8%AE%B8%E9%94%AE%E5%80%BC%E5%86%97%E4%BD%99-toc\" style=\"margin-left:40px;\"><a href=\"#5.multimap%20%E5%85%81%E8%AE%B8%E9%94%AE%E5%80%BC%E5%86%97%E4%BD%99\">5.multimap 允许键值冗余</a></p>\n<p id=\"%E4%B8%89.%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%89.%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE\">三.相关题目</a></p>\n<p id=\"%E3%80%82692.%20%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%8D%95%E8%AF%8D-toc\" style=\"margin-left:40px;\"><a href=\"#%E3%80%82692.%20%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%8D%95%E8%AF%8D\">1.692. 前K个高频单词</a></p>\n<p id=\"%EF%BC%881%EF%BC%89%E5%81%9A%E6%B3%95%E4%B8%80%EF%BC%9Astable_sort%E7%A8%B3%E5%AE%9A%E6%8E%92%E5%BA%8F-toc\" style=\"margin-left:80px;\"><a href=\"#%EF%BC%881%EF%BC%89%E5%81%9A%E6%B3%95%E4%B8%80%EF%BC%9Astable_sort%E7%A8%B3%E5%AE%9A%E6%8E%92%E5%BA%8F\">（1）做法一：stable_sort稳定排序</a></p>\n<p id=\"%EF%BC%882%EF%BC%89%E5%81%9A%E6%B3%95%E4%BA%8C%EF%BC%9Astable_sort%E7%A8%B3%E5%AE%9A%E6%8E%92%E5%BA%8F%202-toc\" style=\"margin-left:80px;\"><a href=\"#%EF%BC%882%EF%BC%89%E5%81%9A%E6%B3%95%E4%BA%8C%EF%BC%9Astable_sort%E7%A8%B3%E5%AE%9A%E6%8E%92%E5%BA%8F%202\">（2）做法二：stable_sort稳定排序 2</a></p>\n<p id=\"%EF%BC%883%EF%BC%89%E5%81%9A%E6%B3%95%E4%B8%89%EF%BC%9Asort%20%E9%9D%9E%E7%A8%B3%E5%AE%9A%E6%8E%92%E5%BA%8F%EF%BC%8C%E5%8F%AF%E4%BB%A5%E6%8E%A7%E5%88%B6%E6%AF%94%E8%BE%83%E6%96%B9%E6%B3%95%E4%BD%BF%E5%85%B6%E7%A8%B3%E5%AE%9A-toc\" style=\"margin-left:80px;\"><a href=\"#%EF%BC%883%EF%BC%89%E5%81%9A%E6%B3%95%E4%B8%89%EF%BC%9Asort%20%E9%9D%9E%E7%A8%B3%E5%AE%9A%E6%8E%92%E5%BA%8F%EF%BC%8C%E5%8F%AF%E4%BB%A5%E6%8E%A7%E5%88%B6%E6%AF%94%E8%BE%83%E6%96%B9%E6%B3%95%E4%BD%BF%E5%85%B6%E7%A8%B3%E5%AE%9A\">（3）做法三：sort 非稳定排序，可以控制比较方法使其稳定</a></p>\n<p id=\"%C2%A0%EF%BC%884%EF%BC%89%E5%81%9A%E6%B3%95%E5%9B%9B%EF%BC%9A%E5%88%A9%E7%94%A8map%E8%87%AA%E8%BA%AB%E6%8C%89%E7%85%A7first%E6%8E%92%E5%BA%8F-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A0%EF%BC%884%EF%BC%89%E5%81%9A%E6%B3%95%E5%9B%9B%EF%BC%9A%E5%88%A9%E7%94%A8map%E8%87%AA%E8%BA%AB%E6%8C%89%E7%85%A7first%E6%8E%92%E5%BA%8F\"> （4）做法四：利用map自身按照first排序</a></p>\n<p id=\"%E5%9B%9B.%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%9B%9B.%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0\">四.模拟实现</a></p>\n<p id=\"Map.h-toc\" style=\"margin-left:40px;\"><a href=\"#Map.h\">Map.h</a></p>\n<p id=\"Set.h-toc\" style=\"margin-left:40px;\"><a href=\"#Set.h\">Set.h</a></p>\n<p id=\"RBTree.h-toc\" style=\"margin-left:40px;\"><a href=\"#RBTree.h\">RBTree.h</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h1 id=\"%E4%B8%80.set%E4%BB%8B%E7%BB%8D\">一.set介绍</h1>\n<h2 id=\"1.set%E4%BB%8B%E7%BB%8D\">1.set介绍</h2>\n<p>set 是一个K模型的搜索二叉树 #include&lt;set&gt;</p>\n<p><img alt=\"\" height=\"167\" src=\"image\\963f23125271409a8788b856ec66df4a.png\" width=\"869\"/></p>\n<p></p>\n<h2 id=\"2.insert%20%E4%BD%BF%E7%94%A8\">2.insert 使用</h2>\n<p><img alt=\"\" height=\"243\" src=\"image\\c099f111cad1435182374e757a4c543a.png\" width=\"1023\"/></p>\n<p>(1)和(2)相当于一样，在pos位置插入也会自动排序</p>\n<p> insert ：排序 + 去重 </p>\n<pre><code class=\"language-cpp\">void test_set1()\n{\n\tset&lt;int&gt; s;\n\ts.insert(4);\n\ts.insert(5);\n\ts.insert(2);\n\ts.insert(1);\n\ts.insert(1);\n\ts.insert(3);\n\ts.insert(2);\n\ts.insert(1);\n\n\n\t// 排序 + 去重 \n\tset&lt;int&gt;::iterator it = s.begin();\n\twhile (it != s.end())\n\t{\n\t\t//*it = 10;    迭代器不支持修改\n\t\tcout &lt;&lt; *it &lt;&lt; \" \";\n\t\t++it;\n\t}\n\tcout &lt;&lt; endl;\n\n    for (auto e : s)\n\t{\n\t\tcout &lt;&lt; e &lt;&lt; \" \";\n\t}\n\tcout &lt;&lt; endl;\n}\n</code></pre>\n<p><img alt=\"\" height=\"132\" src=\"image\\1ad9bb72836147a195e92661a955c171.png\" width=\"216\"/></p>\n<h3 id=\"%C2%A0set%E4%B8%AD%E7%9A%84%E6%99%AE%E9%80%9A%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%B0%B1%E6%98%AF%E7%94%A8%E7%9A%84const%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%81%EF%BC%81\"> set中的普通迭代器就是用的const迭代器！！</h3>\n<p><img alt=\"\" height=\"77\" src=\"image\\fbd4ed41d9af4275baadb25d2707d127.png\" width=\"758\"/><br/>  </p>\n<h2 id=\"3.find\">3.find</h2>\n<p><img alt=\"\" height=\"128\" src=\"image\\b1db6e5ebbc84fd0aa95b5c4832ad4db.png\" width=\"374\"/></p>\n<p>能找到就返回元素的迭代器，找不到就返回end</p>\n<h3 id=\"set%3A%3Afind%E5%92%8Cstd%3A%3Afind%E5%AF%B9%E6%AF%94\">set::find和std::find对比</h3>\n<p>set::find 搜索二叉树特性查找，时间复杂度是O(logN)</p>\n<p>全局的find 是暴力查找，时间复杂度是O(N)</p>\n<p>所以set::find效率更高</p>\n<pre><code class=\"language-cpp\">void test_set2()\n{\n\tset&lt;int&gt; s;\n\ts.insert(4);\n\ts.insert(5);\n\ts.insert(2);\n\ts.insert(1);\n\ts.insert(1);\n\ts.insert(3);\n\ts.insert(2);\n\ts.insert(1);\n\n\tset&lt;int&gt;::iterator pos = s.find(20);  // O(logN)\n\tif (pos != s.end())\n\t{\n\t\tcout &lt;&lt; \"set.find找到了\" &lt;&lt; endl;\n\t}\n\n\tpos = find(s.begin(), s.end(), 2); // O(N)\n\tif (pos != s.end())\n\t{\n\t\tcout &lt;&lt; \"find找到了\" &lt;&lt; endl;\n\t}\n}</code></pre>\n<p></p>\n<h2 id=\"4.erase\">4.erase</h2>\n<p>size_type就是size_t，也就是unsigned int</p>\n<p><img alt=\"\" height=\"198\" src=\"image\\831aff9fd81a43d7a8e0f77526594664.png\" width=\"559\"/></p>\n<p>(1) void erase (iterator position); 必须加检查if (pos != s.end()) s.erase(pos); 因为有pos时，正常运行，如果没有pos，就会报错。例如：s.erase(pos);</p>\n<p>(2)size_ type erase (const value_ type&amp; val) ; 则可以随便删，无论有没有都不报错 例如：s.erase(3)</p>\n<p>(3)void erase (iterator first，iterator last) 删的是[ first， last），即不包含 last</p>\n<pre><code class=\"language-cpp\">void test_set3()\n{\n\tset&lt;int&gt; s;\n\ts.insert(4);\n\ts.insert(5);\n\ts.insert(2);\n\ts.insert(1);\n\ts.insert(1);\n\ts.insert(3);\n\ts.insert(2);\n\ts.insert(1);\n\n\tcout &lt;&lt; s.erase(3) &lt;&lt; endl;    //有就返回1\n\tcout &lt;&lt; s.erase(30) &lt;&lt; endl;   //没有就返回0\n\n\tfor (auto e : s)\n\t{\n\t\tcout &lt;&lt; e &lt;&lt; \" \";\n\t}\n\tcout &lt;&lt; endl;\n\n\tset&lt;int&gt;::iterator pos = s.find(3);\n\tif (pos != s.end())\n\t\ts.erase(pos);\n\n\tfor (auto e : s)\n\t{\n\t\tcout &lt;&lt; e &lt;&lt; \" \";\n\t}\n\tcout &lt;&lt; endl;\n</code></pre>\n<p><img alt=\"\" height=\"176\" src=\"image\\ce9e04367fba4f2294166222125859a2.png\" width=\"223\"/></p>\n<h2 id=\"5.swap%20%E6%A0%B9%E8%8A%82%E7%82%B9%E4%BA%A4%E6%8D%A2\">5.swap 根节点交换</h2>\n<p><img alt=\"\" height=\"113\" src=\"image\\aad802b5b25e4d4fb7c571f560aa8d58.png\" width=\"329\"/></p>\n<h2 id=\"6.count%20%E6%AF%94find%E6%96%B9%E4%BE%BF\">6.count 比find方便</h2>\n<p><img alt=\"\" height=\"118\" src=\"image\\1bf4cdd980e24c5789395d562080c89f.png\" width=\"555\"/></p>\n<pre><code class=\"language-cpp\">\n\tif (s.count(5))\n\t{\n\t\tcout &lt;&lt; \"5在\" &lt;&lt; endl;\n\t}\n\n\tif (s.find(5) != s.end())\n\t{\n\t\tcout &lt;&lt; \"5在\" &lt;&lt; endl;\n\t}</code></pre>\n<p>打印：</p>\n<p>5在</p>\n<p>5在</p>\n<p><img alt=\"\" height=\"207\" src=\"image\\a80ee86d3d3242c79ab69d1089c8abf6.png\" width=\"384\"/></p>\n<p></p>\n<h2 id=\"7.lower_bound%EF%BC%9A%E8%BF%94%E5%9B%9E%3E%3D%20val%E5%BE%97%E4%BD%8D%E7%BD%AE%E8%BF%AD%E4%BB%A3%E5%99%A8\">7.lower_bound：返回&gt;= val得位置迭代器</h2>\n<h3 id=\"%EF%BC%881%EF%BC%89lower_bound\">（1）lower_bound</h3>\n<p>返回&gt;= val得位置迭代器 3返回3位置 6 返回7位置</p>\n<p><img alt=\"\" height=\"139\" src=\"image\\99644c01ffb34395a974e414fe467cb0.png\" width=\"497\"/></p>\n<pre><code class=\"language-cpp\">返回&gt;= val的位置迭代器 3返回3位置 6 返回7位置\n    set&lt;int&gt; s;\n\ts.insert(4);\n\ts.insert(5);\n\ts.insert(1);\n\ts.insert(3);\n\ts.insert(2);\n\ts.insert(7);\n\ts.insert(9);\n    set&lt;int&gt;::iterator lowIt = s.lower_bound(3); 存在\n\tlowIt = s.lower_bound(6); 不存在</code></pre>\n<h3 id=\"%E7%94%A8%E9%80%94%EF%BC%9A%E4%B8%BE%E4%BE%8B%EF%BC%9A%E8%A6%81%E6%B1%82%E5%88%A0%E9%99%A4%3E%3Dx%E7%9A%84%E6%89%80%E6%9C%89%E5%80%BC%EF%BC%9A\">用途：举例：要求删除&gt;=x的所有值：</h3>\n<pre><code class=\"language-cpp\">void test_set4()\n{\n\tset&lt;int&gt; s;\n\ts.insert(4);\n\ts.insert(5);\n\ts.insert(1);\n\ts.insert(3);\n\ts.insert(2);\n\ts.insert(7);\n\ts.insert(9);\n    for (auto e : s)\n\t{\n\t\tcout &lt;&lt; e &lt;&lt; \" \";\n\t}\n\tcout &lt;&lt; endl;\n\n\t// 要求删除&gt;=x的所有值\n\tint x;\n\tcin &gt;&gt; x;\n\tset&lt;int&gt;::iterator lowIt = s.lower_bound(x);\n\ts.erase(lowIt, s.end());\n\n\tfor (auto e : s)\n\t{\n\t\tcout &lt;&lt; e &lt;&lt; \" \";\n\t}\n\tcout &lt;&lt; endl;\n}</code></pre>\n<p><img alt=\"\" height=\"127\" src=\"image\\7e1a52fbd322404eafa549d978e96926.png\" width=\"491\"/></p>\n<h3 id=\"%EF%BC%882%EF%BC%89upper_bound%C2%A0%E8%BF%94%E5%9B%9E%3Ex%E4%BD%8D%E7%BD%AE%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8\">（2）upper_bound 返回&gt;x位置的迭代器</h3>\n<p>返回&gt;x位置的迭代器，s.upper_bound(5) 存在5，不存在6，则返回7；s.upper_bound(6) 不存在6，返回7；</p>\n<pre><code class=\"language-cpp\">    set&lt;int&gt; s;\n\ts.insert(4);\n\ts.insert(5);\n\ts.insert(1);\n\ts.insert(3);\n\ts.insert(2);\n\ts.insert(7);\n\ts.insert(9);\n\n\t返回&gt;x位置的迭代器  -》 都是返回 7位置的迭代器\n\tset&lt;int&gt;::iterator upIt = s.upper_bound(5);  // 存在\n\tupIt = s.upper_bound(6); // 不存在</code></pre>\n<p>用途：例如 删除x &lt;=  &lt;= y的区间 删除 [x,y]</p>\n<pre><code class=\"language-cpp\">void test_set4()\n{\n\tset&lt;int&gt; s;\n\ts.insert(4);\n\ts.insert(5);\n\ts.insert(1);\n\ts.insert(3);\n\ts.insert(2);\n\ts.insert(7);\n\ts.insert(8);\n\n\t// 返回&gt;= val得位置迭代器  3返回3位置  6 返回7位置\n\t/*set&lt;int&gt;::iterator lowIt = s.lower_bound(3); 存在\n\tlowIt = s.lower_bound(6); 不存在*/\n\tfor (auto e : s)\n\t{\n\t\tcout &lt;&lt; e &lt;&lt; \" \";\n\t}\n\tcout &lt;&lt; endl;\n\n\t// 删除x &lt;=  &lt;= y的区间 删除 [x,y]\n\tint x, y;\n\tcin &gt;&gt; x &gt;&gt; y;\n\tauto leftIt = s.lower_bound(x);  // [\n\tauto rightIt = s.upper_bound(y); // )\n\ts.erase(leftIt, rightIt);\n\tfor (auto e : s)\n\t{\n\t\tcout &lt;&lt; e &lt;&lt; \" \";\n\t}\n\tcout &lt;&lt; endl;\n}</code></pre>\n<p><img alt=\"\" height=\"135\" src=\"image\\eb18ae79b2944faab61903887dc753e8.png\" width=\"538\"/></p>\n<h2 id=\"8.%20std%3A%3Amultiset%20%E8%B7%9Fset%E6%8E%A5%E5%8F%A3%E4%B8%80%E6%A0%B7%EF%BC%8C%E5%8F%AA%E6%98%AF%E5%85%81%E8%AE%B8%E5%86%97%E4%BD%99%EF%BC%8C%E4%B8%8D%E5%8E%BB%E9%87%8D\">8. std::multiset 跟set接口一样，只是允许冗余，不去重</h2>\n<p><img alt=\"\" height=\"172\" src=\"image\\e6f9bee586ee497ab32cf2dd70d20be3.png\" width=\"932\"/></p>\n<p>插入重复的数时set会去重，multiset不去重，允许冗余</p>\n<p>不同：</p>\n<p>multiset 的count和erase 返回查找或删除个数</p>\n<p>find(x) 多个x的话，find返回中序第一个x</p>\n<pre><code class=\"language-cpp\">void test_set6()\n{\n\tmultiset&lt;int&gt; s;\n\ts.insert(4);\n\ts.insert(5);\n\ts.insert(2);\n\ts.insert(1);\n\ts.insert(1);\n\ts.insert(3);\n\ts.insert(2);\n\ts.insert(1);\n\ts.insert(3);\n\ts.insert(3);\n\ts.insert(3);\n\ts.insert(3);\n\n\t// 排序 \n\tset&lt;int&gt;::iterator it = s.begin();    //迭代器打印\n\twhile (it != s.end())\n\t{\n\t\t//*it = 10;\n\t\tcout &lt;&lt; *it &lt;&lt; \" \";\n\t\t++it;\n\t}\n\tcout &lt;&lt; endl;\n\n\tfor (auto e : s)        //范围for打印\n\t{\n\t\tcout &lt;&lt; e &lt;&lt; \" \";\n\t}\n\tcout &lt;&lt; endl;\n\n\tcout &lt;&lt; s.count(1) &lt;&lt; endl;    //测试count，打印3，因为1有3个\n\tcout &lt;&lt; s.erase(1) &lt;&lt; endl;    //测试erase，打印3，因为1有3个\n\tfor (auto e : s)    \n\t{\n\t\tcout &lt;&lt; e &lt;&lt; \" \";\n\t}\n\tcout &lt;&lt; endl;\n                           \n\tauto pos = s.find(3);         // 多个x的话，find返回中序第一个x\n\twhile (pos != s.end())        //从中序第一个3开始打印完整个\n\t{\n\t\tcout &lt;&lt; *pos &lt;&lt; \" \";\n\t\t++pos;\n\t}\n\tcout &lt;&lt; endl;\n}</code></pre>\n<p><img alt=\"\" height=\"218\" src=\"image\\0775c8b05eb74cd39333dabcc4fd6884.png\" width=\"346\"/></p>\n<p> <img alt=\"\" height=\"177\" src=\"image\\a5075a636e4d4596baf10831512be586.png\" width=\"262\"/></p>\n<h2 id=\"9.set%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE\">9.set相关题目</h2>\n<p><a href=\"https://leetcode.cn/problems/intersection-of-two-arrays/\" title=\"349. 两个数组的交集\">349. 两个数组的交集</a></p>\n<p><img alt=\"\" height=\"471\" src=\"image\\5a5b961832c14e2f83ff6d1d485c996f.png\" width=\"553\"/></p>\n<p>方法一：把nums1和nums2分别放进s1和s2中进行去重，再利用范围for把s2中的每个元素在s1中进行查找，如果找到就放进v中。时间复杂度是：O(n*logn) n个节点，每个节点找logn高度次</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {\n        //去重\n        set&lt;int&gt; s1;\n        for(auto e:nums1)\n        {\n            s1.insert(e);\n        }\n        //去重\n        set&lt;int&gt; s2;\n        for(auto e:nums2)\n        {\n            s2.insert(e);\n        }\n        vector&lt;int&gt; v;\n        for(auto e:s2)\n        {\n            if(s1.count(e))\n            {\n                v.push_back(e);\n            }\n        }\n        return v;\n    }\n};</code></pre>\n<p>方法二：</p>\n<p><img alt=\"\" height=\"357\" src=\"image\\64cd95b7ac054f3a8b5d0fdb66403182.png\" width=\"467\"/></p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {\n        set&lt;int&gt; s1;\n        for(auto e:nums1)\n        {\n            s1.insert(e);\n        }\n\n        set&lt;int&gt; s2;\n        for(auto e:nums2)\n        {\n            s2.insert(e);\n        }\n        vector&lt;int&gt; v;\n        set&lt;int&gt;::iterator it1=s1.begin();\n        set&lt;int&gt;::iterator it2=s2.begin();\n        while(it1!=s1.end() &amp;&amp; it2!=s2.end())\n        {\n            if(*it1&gt;*it2)    //相比较，值小的++\n            {\n                ++it2;\n            }\n            else if(*it1&lt;*it2)    //相比较，值小的++\n            {\n                ++it1;\n            }\n            else                //相比较，值相等就放进v中，同时++\n            {\n                v.push_back(*it1);\n                ++it1;\n                ++it2;\n            }\n        }\n        return v;\n    }\n};</code></pre>\n<p></p>\n<h1 id=\"%E4%BA%8C.map%E7%94%A8%E6%B3%95%E4%BB%8B%E7%BB%8D\">二.map用法介绍</h1>\n<p>map是KV模型的搜索二叉树，<u>insert和[]用法是重点，其他用法参考set</u>        #include&lt;map&gt;</p>\n<p><img alt=\"\" height=\"215\" src=\"image\\e5d2c81392e24734a41a483da8fb048d.png\" width=\"925\"/></p>\n<h2 id=\"%E5%87%A0%E4%B8%AAmap%E5%92%8Cset%E7%9A%84%E5%86%B7%E7%9F%A5%E8%AF%86%EF%BC%9A\">几个map和set的冷知识：</h2>\n<h2 id=\"map%EF%BC%9A\">map：</h2>\n<h3 id=\"%E2%91%A0map%E6%98%AFC%2B%2B98%E4%B8%AD%E5%B7%B2%E5%AD%98%E5%9C%A8%E7%9A%84%EF%BC%8Cunordered_map%E6%98%AFC%2B%2B11%E4%B8%AD%E6%89%8D%E6%9C%89%E7%9A%84\">①map是C++98中已存在的，unordered_map是C++11中才有的</h3>\n<h3 id=\"%E2%91%A1map%E4%B8%AD%E9%83%BD%E9%87%8D%E8%BD%BD%E4%BA%86%5B%5D%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%8Cmultimap%E4%B8%AD%E6%B2%A1%E6%9C%89%E9%87%8D%E8%BD%BD%5B%5D%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%8Cset%E4%B9%9F%E6%B2%A1%E6%9C%89%E9%87%8D%E8%BD%BD%5B%5D%E3%80%82\">②map中都重载了[]运算符，multimap中没有重载[]运算符，<span style=\"color:#fe2c24;\">set</span>也没有重载[]。</h3>\n<p>原因：map中key是唯一的，每个key都有与之对应的value，经常需要通过key获取value，因此 map为了形象简单 就重载了[]运算符, multimap中key是可以重复的，如果重载了[]运算符，给定 一个key时，就没有办法返回     value了，因此，multimap中没有重载[]运算符</p>\n<h3 id=\"%E2%91%A2map%E4%B8%ADkey%E4%B8%8D%E8%83%BD%E4%BF%AE%E6%94%B9%EF%BC%8C%E5%9B%A0%E4%B8%BA%E5%A6%82%E6%9E%9C%E4%BF%AE%E6%94%B9%E4%BA%86%E5%B0%B1%E4%B8%8D%E8%83%BD%E4%BF%9D%E8%AF%81%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%9C%89%E5%BA%8F%E7%89%B9%E6%80%A7%E4%BA%86\">③map中key不能修改，因为如果修改了就不能保证红黑树的有序特性了</h3>\n<h2 id=\"set%EF%BC%9A\">set：</h2>\n<h3 id=\"%E2%91%A0set%E4%B8%AD%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%AD%98%E5%82%A8%E9%94%AE%E5%80%BC%E5%AF%B9%EF%BC%8C%E5%AE%9E%E4%BE%8B%E5%8C%96set%E6%97%B6%EF%BC%8C%E5%B0%86set%E4%B8%AD%E5%85%83%E7%B4%A0%E7%B1%BB%E5%9E%8B%E8%AE%BE%E7%BD%AE%E4%B8%BApair%E5%8D%B3%E5%8F%AF\">①set中也可以存储键值对，实例化set时，将set中元素类型设置为pair即可</h3>\n<h3 id=\"%E2%91%A1set%E9%BB%98%E8%AE%A4%E6%98%AF%E5%8D%87%E5%BA%8F%EF%BC%8C%E4%BD%86%E6%98%AF%E5%85%B6%E5%86%85%E9%83%A8%E9%BB%98%E8%AE%A4%E4%B8%8D%E6%98%AF%E6%8C%89%E7%85%A7%E5%A4%A7%E4%BA%8E%E6%AF%94%E8%BE%83%EF%BC%8C%E8%80%8C%E6%98%AF%E6%8C%89%E7%85%A7%20less%E5%B0%8F%E4%BA%8E%E6%AF%94%E8%BE%83\">②set默认是升序，但是其内部默认不是按照大于比较，而是按照 less<strong>小于比较</strong></h3>\n<p>less是把小的放左边，所以是升序；greater是把大的放左边，所以是降序</p>\n<p><img alt=\"\" height=\"149\" src=\"image\\7a2dff96f5b44c478b3147497d5c8210.png\" width=\"237\"/></p>\n<p></p>\n<h3 id=\"%E2%91%A2map%E5%92%8Cset%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E9%83%BD%E6%98%AFO(log_2N)\">③<span style=\"color:#4da8ee;\">map</span>和set查询的时间复杂度都是O(log_2N)</h3>\n<p>解释：map和set的底层结构都是红黑树，而红黑树是近似的平衡二叉搜索树，故查询时间 复杂度为O(log_2N)</p>\n<h3 id=\"%E2%91%A3map%E5%92%8Cset%E5%BA%95%E5%B1%82%E9%83%BD%E6%98%AF%E4%BD%BF%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91%E5%AE%9E%E7%8E%B0%E7%9A%84\">④<span style=\"color:#4da8ee;\">map</span>和set底层都是使用红黑树实现的</h3>\n<p></p>\n<h2 id=\"1.pair%E5%92%8Cmake_pair\">1.pair和make_pair</h2>\n<h3 id=\"%EF%BC%881%EF%BC%89pair%E9%94%AE%E5%80%BC%E5%AF%B9%20%E7%9A%84%E4%BB%8B%E7%BB%8D\">（1）pair<span style=\"color:#333333;\"><strong>键值对 的</strong></span>介绍</h3>\n<div>\n<span style=\"color:#494949;\"><strong>用来表示具有一一对应关系的一种结构，该结构中一般只包含两个成员变量key和value，key代 </strong></span>\n</div>\n<div>\n<span style=\"color:#494949;\"><strong>表键值，value表示与key对应的信息</strong>。比如：现在要建立一个英汉互译的字典，那该字典中必然 </span>\n</div>\n<div>\n<span style=\"color:#494949;\">有英文单词与其对应的中文含义，而且，英文单词与其中文含义是一一对应的关系，即通过该应 </span>\n</div>\n<div>\n<span style=\"color:#494949;\">该单词，在词典中就可以找到与其对应的中文含义。 </span>\n</div>\n<div></div>\n<p>pair 打包了KV模型的key和val两个类型的值，c++不支持返回两个值，也就不知道返回key和val哪一个了，所以干脆打包key和val，返回一个pair结构</p>\n<p>（value_type 是 <a href=\"https://legacy.cplusplus.com/pair\" title=\"pair\">pair</a>&lt;const key_type,mapped_type&gt;）</p>\n<p>pair中的first就相当于KV模型中的key，second相当于KV模型中的val</p>\n<p><img alt=\"\" height=\"376\" src=\"image\\82ccf741dc6d4f83bd108de346b92347.png\" width=\"509\"/></p>\n<h3 id=\"%EF%BC%882%EF%BC%89make_pair%20%E4%BB%8B%E7%BB%8D\">（2）make_pair 介绍</h3>\n<p>make_pair 相当于返回了一个pair的匿名对象</p>\n<p><img alt=\"\" height=\"178\" src=\"image\\1cc10c1d4bfa491f8d15bc1da49c2f28.png\" width=\"781\"/></p>\n<h2 id=\"2.map%E7%9A%84%E9%81%8D%E5%8E%86\">2.map的遍历</h2>\n<h3 id=\"%EF%BC%881%EF%BC%89%E8%8B%B1%E6%B1%89%E5%AD%97%E5%85%B8%E7%9A%84%E9%81%8D%E5%8E%86\">（1）英汉字典的遍历</h3>\n<p>几种插入英汉字典的方式：匿名对象插入，普通对象插入，make_pair插入</p>\n<pre><code class=\"language-cpp\">void test_map1()\n{\n\tmap&lt;string, string&gt; dict;\n\n\t// pair构造函数\n\tdict.insert(pair&lt;string, string&gt;(\"sort\", \"排序\")); //匿名对象插入更便捷\n\tpair&lt;string, string&gt; kv(\"insert\", \"插入\");    //普通对象插入\n\tdict.insert(kv);\n\n\t// make_pair\n\tauto ret1 = dict.insert(make_pair(\"left\", \"左边\"));  //make_pair插入\n\tauto ret2 = dict.insert(make_pair(\"left\", \"剩余\"));\n\t// 遍历\n//map&lt;string, string&gt;::iterator it = dict.begin();\n\tauto it = dict.begin();\n\twhile (it != dict.end())\n\t{\n\t\t//cout &lt;&lt; *it &lt;&lt; \" \"; // it-&gt;operator*()\n\t\t//cout &lt;&lt; (*it).first &lt;&lt; \":\" &lt;&lt; (*it).second &lt;&lt; endl;\n\t\tcout &lt;&lt; it-&gt;first &lt;&lt; \":\" &lt;&lt; it-&gt;second &lt;&lt; endl;\n\t\t++it;\n\t}\n\tcout &lt;&lt; endl;\n\n\tfor (const auto&amp; kv : dict)\n\t{\n\t\tcout &lt;&lt; kv.first &lt;&lt; \":\" &lt;&lt; kv.second &lt;&lt; endl;\n\t}\n}\n\nint main()\n{\n\ttest_map1();\n\treturn 0;\n}</code></pre>\n<p><img alt=\"\" height=\"167\" src=\"image\\1de873cf2de9447194f53bb22dd5aced.png\" width=\"150\"/></p>\n<h3 id=\"%EF%BC%882%EF%BC%89%E8%AE%B0%E5%BD%95%E6%B0%B4%E6%9E%9C%E6%AC%A1%E6%95%B0\">（2）记录水果次数</h3>\n<pre><code class=\"language-cpp\">void test_map2()\n{\n\tstring arr[] = { \"苹果\", \"西瓜\", \"苹果\", \"西瓜\", \"苹果\", \"苹果\", \"西瓜\", \"苹果\", \"香蕉\", \"苹果\", \"香蕉\" };\n\tmap&lt;string, int&gt; countMap;\n\tfor (auto&amp; str : arr)\n\t{\n\t\tmap&lt;string, int&gt;::iterator it = countMap.find(str);\t\n\t\tif (it != countMap.end())\t//如果countMap中有，就计数加1\n\t\t{\n\t\t\tit-&gt;second++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcountMap.insert(make_pair(str, 1));\t//没有就插入水果\n\t\t}\n\t}\n\tfor (auto&amp; str : arr)\n\t{\n\t\tcountMap[str]++;\n\t}\n\tfor (const auto&amp; kv : countMap)\n\t{\n\t\tcout &lt;&lt; kv.first &lt;&lt; \":\" &lt;&lt; kv.second &lt;&lt; endl;\n\t}\n}</code></pre>\n<p><img alt=\"\" height=\"105\" src=\"image\\549e1e44158d4954a7d3e611e6d4db1e.png\" width=\"118\"/></p>\n<h2 id=\"3.insert%E5%86%99%E6%B3%95%E6%8F%90%E9%AB%98%20%E8%AE%B0%E5%BD%95%E6%B0%B4%E6%9E%9C%E6%AC%A1%E6%95%B0%20%E7%9A%84%E6%95%88%E7%8E%87%EF%BC%88%E4%B8%8D%E8%BF%99%E4%B9%88%E5%86%99%EF%BC%8C%E5%8F%AA%E6%98%AF%E4%B8%BA%5B%5D%E5%81%9A%E9%93%BA%E5%9E%AB%EF%BC%89\">3.insert写法提高 记录水果次数 的效率（不这么写，只是为[]做铺垫）</h2>\n<p>map的insert默认是按照pair中的first进行排序的</p>\n<p><img alt=\"\" height=\"263\" src=\"image\\341b0f1e461047b29ca21bdd89f5d534.png\" width=\"1023\"/></p>\n<p> <img alt=\"\" height=\"527\" src=\"image\\0ecf9b3ea5614f8a9eafe5c2c5916749.png\" width=\"1200\"/></p>\n<p></p>\n<pre><code class=\"language-cpp\">    string arr[] = { \"苹果\", \"西瓜\", \"苹果\", \"西瓜\", \"苹果\", \"苹果\", \"西瓜\", \"苹果\", \"香蕉\", \"苹果\", \"香蕉\" };\n\tmap&lt;string, int&gt; countMap;\n\tfor (auto&amp; str : arr)\n\t{\npair&lt;map&lt;string, int&gt;::iterator, bool&gt; ret = countMap.insert(make_pair(str, 1));\n\t\t//或者 auto ret = countMap.insert(make_pair(str, 1));\n\t\tif (ret.second == false)\n\t\t{\n\t\t\tret.first-&gt;second++;\n\t\t}\n\t}\n\tfor (const auto&amp; kv : countMap)\n\t{\n\t\tcout &lt;&lt; kv.first &lt;&lt; \":\" &lt;&lt; kv.second &lt;&lt; endl;\n\t}</code></pre>\n<p><img alt=\"\" height=\"106\" src=\"image\\b218021f8863476da91580c7a03fbf66.png\" width=\"98\"/></p>\n<p>解释：</p>\n<p>pair&lt;map&lt;string, int&gt;::iterator, bool&gt;  ret = countMap.insert(make_pair(str, 1)) 插入节点，若插入成功，ret.first这个iterator 存的是新插入节点的迭代器，ret.second 存的是true；若插入失败，ret.first这个iterator 存的是已有的相同节点的迭代器，ret.second 存的是false；插入失败就再记录个数++就行，ret.first-&gt;second++; 用于访问记录水果个数，ret.first 是节点迭代器，ret.first-&gt;second++; 节点中的second用于记录对应水果的个数<img alt=\"\" height=\"390\" src=\"image\\53e109d5a08e4c6db30a181b8f188f65.png\" width=\"1200\"/></p>\n<h2 id=\"4.operator%5B%5D%20%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%C2%A0\">4.operator[] 运算符重载 </h2>\n<p><img alt=\"\" height=\"137\" src=\"image\\27b7ba53859946b48eb56759f8be179f.png\" width=\"384\"/></p>\n<h3 id=\"%EF%BC%881%EF%BC%89%20%E6%8F%90%E9%AB%98%20%E8%AE%B0%E5%BD%95%E6%B0%B4%E6%9E%9C%E6%AC%A1%E6%95%B0%20%E7%9A%84%E6%95%88%E7%8E%87%E7%9A%84%E7%9C%9F%E6%AD%A3%E5%86%99%E6%B3%95%EF%BC%9A\">（1） 提高 记录水果次数 的效率的真正写法：</h3>\n<pre><code class=\"language-cpp\">void test_map2()\n{\n\tstring arr[] = { \"苹果\", \"西瓜\", \"苹果\", \"西瓜\", \"苹果\", \"苹果\", \"西瓜\", \"苹果\", \"香蕉\", \"苹果\", \"香蕉\" };\n\tmap&lt;string, int&gt; countMap;\n\tfor (auto&amp; str : arr)\n\t{\n\t\tcountMap[str]++;\n\t}\n\n\tfor (const auto&amp; kv : countMap)\n\t{\n\t\tcout &lt;&lt; kv.first &lt;&lt; \":\" &lt;&lt; kv.second &lt;&lt; endl;\n\t}\n}</code></pre>\n<p> <img alt=\"\" height=\"96\" src=\"image\\d6f677691c8d485d8c3b610f6dbab4d6.png\" width=\"92\"/></p>\n<p> 解释：</p>\n<p><img alt=\"\" height=\"1016\" src=\"image\\d4aeb88da0394a828bf18fdb973b64f5.png\" width=\"1098\"/></p>\n<p> countMap[str]++; 中 countMap[str] 返回的是新插入节点中的 次数second 。</p>\n<p>如果插入的str不在 对象countMap中，countMap[str]++; 就是<strong>插入</strong>这个节点，迭代器就是新节点的迭代器，看原码可知 int类型的次数second用的是缺省值（对应原码中的mapped_typed()，是缺省值 ），所以开始second就是0，++后就是1。作用就是插入并修改val (val意思就是second)。</p>\n<p>如果插入的str在 对象countMap中，countMap[str]++; 就是查找到这个节点，迭代器就是已有节点的迭代器，int类型的次数second在第一次已经是1了，++后就是2。作用就是插入并修改val (val意思就是second，用于计水果次数)。</p>\n<h3 id=\"%EF%BC%882%EF%BC%89%20%E5%AD%97%E5%85%B8%E4%B8%AD%E5%88%A9%E7%94%A8%5B%5D%E6%8F%92%E5%85%A5%E6%88%96%E4%BF%AE%E6%94%B9%20%E7%A4%BA%E4%BE%8B\">（2） 字典中利用[]插入或修改 示例</h3>\n<pre><code class=\"language-cpp\">void test_map1()\n{\n\tmap&lt;string, string&gt; dict;\n\n\t// pair构造函数\n\tdict.insert(pair&lt;string, string&gt;(\"sort\", \"排序\"));\n\tpair&lt;string, string&gt; kv(\"insert\", \"插入\");\n\tdict.insert(kv);\n\n\t// make_pair\n\tauto ret1 = dict.insert(make_pair(\"left\", \"左边\"));\n\tauto ret2 = dict.insert(make_pair(\"left\", \"剩余\"));\n\n\tdict[\"operator\"] = \"重载\"; // 插入+修改\n\tdict[\"left\"] = \"左边、剩余\"; // 修改\n\tdict[\"erase\"];  // 插入\n\tcout &lt;&lt; dict[\"left\"] &lt;&lt; endl; // 查找\n}</code></pre>\n<p><img alt=\"\" height=\"424\" src=\"image\\313200bc6b944a36b4c618b999004ccf.png\" width=\"1200\"/></p>\n<p></p>\n<h2 id=\"5.multimap%20%E5%85%81%E8%AE%B8%E9%94%AE%E5%80%BC%E5%86%97%E4%BD%99\">5.multimap 允许键值冗余</h2>\n<p><img alt=\"\" height=\"191\" src=\"image\\7dba8f8bed0742d48b3003e0139dbef7.png\" width=\"986\"/></p>\n<p></p>\n<p><img alt=\"\" height=\"574\" src=\"image\\fcdd8b45857c448da676d08a66e12240.png\" width=\"1200\"/></p>\n<p>相比map，multimap使用函数接口最大的区别是什么?<br/> 答：不支持operator[] 。</p>\n<p><img alt=\"\" height=\"119\" src=\"image\\de18cc9a57de45cbbfa9cab41650f34e.png\" width=\"645\"/></p>\n<p></p>\n<h1 id=\"%E4%B8%89.%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE\">三.相关题目</h1>\n<h2 id=\"%E3%80%82692.%20%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%8D%95%E8%AF%8D\">1.<a href=\"https://leetcode.cn/problems/top-k-frequent-words/\" title=\"692. 前K个高频单词\">692. 前K个高频单词</a></h2>\n<p><img alt=\"\" height=\"754\" src=\"image\\0ed8d001ef2b4c19b815e88dabf4a26d.png\" width=\"580\"/></p>\n<h3 id=\"%EF%BC%881%EF%BC%89%E5%81%9A%E6%B3%95%E4%B8%80%EF%BC%9Astable_sort%E7%A8%B3%E5%AE%9A%E6%8E%92%E5%BA%8F\">（1）做法一：stable_sort稳定排序</h3>\n<p>把map中的pair放到v中再用stable_sort稳定排序，再把各个pair对应的first放到vv中，再输出vv</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    typedef map&lt;string,int&gt;::iterator CountIter;\n    struct less\n    {\n        bool operator()(const pair&lt;string,int&gt;&amp; x,const pair&lt;string,int&gt;&amp; y)\n        {\n            return x.second&gt;y.second;\n        }\n    };\n\n    vector&lt;string&gt; topKFrequent(vector&lt;string&gt;&amp; words, int k) {\n        map&lt;string,int&gt; countMap;\n        for(auto&amp; str:words)\n        {\n           countMap[str]++;\n        }\n\n        vector&lt;pair&lt;string,int&gt;&gt; v;\n        CountIter it=countMap.begin();\n        while(it!=countMap.end())\n        {\n            //cout&lt;&lt;it-&gt;first&lt;&lt;\" \"&lt;&lt;it-&gt;second&lt;&lt;endl;\n            v.push_back(*it);\n            ++it;\n        }\n\n        stable_sort(v.begin(),v.end(),less());  //stable_sort稳定排序\n        vector&lt;string&gt; vv;\n        for(int i=0;i&lt;k;i++)\n        {\n            vv.push_back(v[i].first);\n        }\n        for(auto e:v)\n        {\n            cout&lt;&lt;e.first&lt;&lt;\" \"&lt;&lt;e.second&lt;&lt;endl;\n        }\n        return vv;\n    }\n};</code></pre>\n<h3 id=\"%EF%BC%882%EF%BC%89%E5%81%9A%E6%B3%95%E4%BA%8C%EF%BC%9Astable_sort%E7%A8%B3%E5%AE%9A%E6%8E%92%E5%BA%8F%202\">（2）做法二：stable_sort稳定排序 2</h3>\n<p>与做法一不同的是：pair很大，为了减少拷贝，我们可以选择不拷贝pair而是拷贝迭代器，把map中的迭代器放到v中，比较方法中通过迭代器找到second，再用stable_sort稳定排序这些迭代器，再把各个迭代器对应的first放到vv中，再输出vv</p>\n<p>自己敲的：</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    typedef map&lt;string,int&gt;::iterator CountIter;\n    struct less //降序\n    {\n        bool operator()(const CountIter&amp; x,const CountIter&amp; y)\n        {\n            return x-&gt;second &gt; y-&gt;second;\n        }\n    };\n    \n    vector&lt;string&gt; topKFrequent(vector&lt;string&gt;&amp; words, int k) {\n        map&lt;string,int&gt; countMap;\n        for(auto&amp; str:words)\n        {\n           countMap[str]++;\n        }\n\n        vector&lt;CountIter&gt; v;\n        CountIter it=countMap.begin();\n        while(it!=countMap.end())\n        {\n            //cout&lt;&lt;it-&gt;first&lt;&lt;\" \"&lt;&lt;it-&gt;second&lt;&lt;endl;\n            v.push_back(it);\n            ++it;\n        }\n\n        stable_sort(v.begin(),v.end(),less());  //stable_sort稳定排序\n        for(auto e:v)\n        {\n            cout&lt;&lt;e-&gt;first&lt;&lt;\" \"&lt;&lt;e-&gt;second&lt;&lt;endl;\n        }\n        vector&lt;string&gt; vv;\n        for(int i=0;i&lt;k;i++)\n        {\n            vv.push_back(v[i]-&gt;first);\n        }\n        \n        return vv;\n    }\n};</code></pre>\n<h3 id=\"%EF%BC%883%EF%BC%89%E5%81%9A%E6%B3%95%E4%B8%89%EF%BC%9Asort%20%E9%9D%9E%E7%A8%B3%E5%AE%9A%E6%8E%92%E5%BA%8F%EF%BC%8C%E5%8F%AF%E4%BB%A5%E6%8E%A7%E5%88%B6%E6%AF%94%E8%BE%83%E6%96%B9%E6%B3%95%E4%BD%BF%E5%85%B6%E7%A8%B3%E5%AE%9A\">（3）做法三：sort 非稳定排序，可以控制比较方法使其稳定</h3>\n<p>相比较上面的方法，把stable_sort换成sort后，只需要控制比较方法即可使其稳定：因为map中默认是按照分first小的在前排序的，sort 时我们设计的比较方法是按second排序的，但是当second相等时，sort有可能打乱之前map中按 first 排的先后顺序，这样就是不稳定。我们只需要比较方法中让second相等时的情况再按first小的在前排好就可以达到稳定的目的。（相等时会多比一下first，会影响一点效率）</p>\n<p>自己敲的：</p>\n<p><img alt=\"\" height=\"1200\" src=\"image\\3794f3061e624772a33ad0d555468108.png\" width=\"799\"/></p>\n<h3 id=\"%C2%A0%EF%BC%884%EF%BC%89%E5%81%9A%E6%B3%95%E5%9B%9B%EF%BC%9A%E5%88%A9%E7%94%A8map%E8%87%AA%E8%BA%AB%E6%8C%89%E7%85%A7first%E6%8E%92%E5%BA%8F\"> （4）做法四：利用map自身按照first排序</h3>\n<p>map的insert默认是按照pair中的first进行排序的，因此我们可以创建一个sortMap，int对应first，string对应second，然后一个一个从kv中插入进sortMap（kv中的first和second颠倒一下插入进去），因为map默认去掉重复的first，这样会导致把次数重复的元素去掉（因为次数放在了first位置），因此要用允许重复的multimap，插入顺序map默认是less降序，因为是top-k问题，我们要把map中插入顺序改成升序插入greater&lt;int&gt;。</p>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    vector&lt;string&gt; topKFrequent(vector&lt;string&gt;&amp; words, int k) {\n        map&lt;string,int&gt; countMap;\n        for(auto&amp; str:words)\n        {\n           countMap[str]++;\n        }\n        //排序\n        multimap&lt;int,string,greater&lt;int&gt;&gt; sortMap;\n        for(auto&amp; kv:countMap)\n        {\n            sortMap.insert(make_pair(kv.second,kv.first));\n        }\n        // auto it=sortMap.begin();  \n        // while(it!=sortMap.end())\n        // {\n        //     cout&lt;&lt;it-&gt;first&lt;&lt;\" \"&lt;&lt;it-&gt;second&lt;&lt;endl;\n        //     ++it;\n        // }\n        vector&lt;string&gt; vv;\n        auto it=sortMap.begin();\n        for(int i=0;i&lt;k;i++)\n        {\n            vv.push_back(it-&gt;second);\n            ++it;\n        }\n        \n        return vv;\n    }\n};</code></pre>\n<p></p>\n<p>官方写法：</p>\n<p><img alt=\"\" height=\"1200\" src=\"image\\580322e78f3b4d0f90b550a5039c50af.png\" width=\"879\"/></p>\n<p></p>\n<h1 id=\"%E5%9B%9B.%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0\">四.模拟实现</h1>\n<p>重点：</p>\n<p>struct SetKeyOfT 仿函数，用于在RBTree.h找到map/set中所要比较的值，用于控制RBTree.h中pair类型的比较方法，因为库中的pair类型 先比first再比second 的比较方法不是我们想要的</p>\n<h2 id=\"Map.h\">Map.h</h2>\n<pre><code class=\"language-cpp\">#pragma once\n#include \"RBTree.h\"\n\nnamespace bit\n{\n\ttemplate&lt;class K, class V&gt;\n\tclass map\n\t{\n\t\tstruct MapKeyOfT\n\t\t{\n\t\t\tconst K&amp; operator()(const pair&lt;K, V&gt;&amp; kv)\n\t\t\t{\n\t\t\t\treturn kv.first;\n\t\t\t}\n\t\t};\n\tpublic:\n\t\ttypedef typename RBTree&lt;K, pair&lt;K, V&gt;, MapKeyOfT&gt;::iterator iterator;\n\t\ttypedef typename RBTree&lt;K, pair&lt;K, V&gt;, MapKeyOfT&gt;::const_iterator const_iterator;\n\n\t\titerator begin()\n\t\t{\n\t\t\treturn _t.Begin();\n\t\t}\n\n\t\titerator end()\n\t\t{\n\t\t\treturn _t.End();\n\t\t}\n\n\t\tpair&lt;iterator, bool&gt; insert(const pair&lt;K, V&gt;&amp; kv)\n\t\t{\n\t\t\treturn _t.Insert(kv);\n\t\t}\n\n\t\titerator find(const K&amp; key)\n\t\t{\n\t\t\treturn _t.Find(key);\n\t\t}\n\n\t\tV&amp; operator[](const K&amp; key)\n\t\t{\n\t\t\tpair&lt;iterator, bool&gt; ret = insert(make_pair(key, V()));\n\t\t\treturn ret.first-&gt;second;\n\t\t}\n\n\tprivate:\n\t\tRBTree&lt;K, pair&lt;K, V&gt;, MapKeyOfT&gt; _t;\n\t};\n\n\tvoid test_map1()\n\t{\n\t\tmap&lt;string, int&gt; m;\n\t\tm.insert(make_pair(\"111\", 1));\n\t\tm.insert(make_pair(\"555\", 5));\n\t\tm.insert(make_pair(\"333\", 3));\n\t\tm.insert(make_pair(\"222\", 2));\n\n\t\tmap&lt;string, int&gt;::iterator it = m.begin();\n\t\twhile (it != m.end())\n\t\t{\n\t\t\tcout &lt;&lt; it-&gt;first &lt;&lt; \":\" &lt;&lt; it-&gt;second &lt;&lt; endl;\n\t\t\t++it;\n\t\t}\n\t\tcout &lt;&lt; endl;\n\n\t\tfor (auto&amp; kv : m)\n\t\t{\n\t\t\tcout &lt;&lt; kv.first &lt;&lt; \":\" &lt;&lt; kv.second &lt;&lt; endl;\n\t\t}\n\t\tcout &lt;&lt; endl;\n\t}\n\n\tvoid test_map2()\n\t{\n\t\tstring arr[] = { \"ƻ\", \"\", \"ƻ\", \"\", \"ƻ\", \"ƻ\", \"\", \"ƻ\", \"㽶\", \"ƻ\", \"㽶\" };\n\n\t\tmap&lt;string, int&gt; countMap;\n\t\tfor (auto&amp; str : arr)\n\t\t{\n\t\t\tcountMap[str]++;\n\t\t}\n\n\t\tfor (const auto&amp; kv : countMap)\n\t\t{\n\t\t\tcout &lt;&lt; kv.first &lt;&lt; \":\" &lt;&lt; kv.second &lt;&lt; endl;\n\t\t}\n\t}\n\n\tvoid test_map3()\n\t{\n\t\tmap&lt;string, string&gt; dict;\n\t\tdict[\"insert\"];\n\t\tdict[\"insert\"] = \"\";\n\t\tdict[\"left\"] = \"\";\n\n\t}\n}</code></pre>\n<h2 id=\"Set.h\">Set.h</h2>\n<p></p>\n<pre><code class=\"language-cpp\">#pragma once\n\n#include \"RBTree.h\"\n\nnamespace bit\n{\n\ttemplate&lt;class K&gt;\n\tclass set\n\t{\n\t\tstruct SetKeyOfT\n\t\t{\n\t\t\tconst K&amp; operator()(const K&amp; key)\n\t\t\t{\n\t\t\t\treturn key;\n\t\t\t}\n\t\t};\n\tpublic:\n\t\ttypedef typename RBTree&lt;K, K, SetKeyOfT&gt;::const_iterator iterator;\n\t\ttypedef typename RBTree&lt;K, K, SetKeyOfT&gt;::const_iterator const_iterator;\n\n\t\titerator begin() const    //set内容不想被修改(key值不修改)，则给this设置const，\n\t\t{                          //调用时会调用带const的Begin()\n\t\t\treturn _t.Begin();\n\t\t}\n\n\t\titerator end() const\n\t\t{\n\t\t\treturn _t.End();\n\t\t}\n\n\t\tpair&lt;iterator, bool&gt; insert(const K&amp; key)\n\t\t{\n\t\t\t//pair&lt;typename RBTree&lt;K, K, SetKeyOfT&gt;::iterator, bool&gt; ret = _t.Insert(key);\n\t\t\tauto ret = _t.Insert(key);\n\t\t\treturn pair&lt;iterator, bool&gt;(iterator(ret.first._node), ret.second);\n\t\t}\n\n\t\titerator find(const K&amp; key)\n\t\t{\n\t\t\treturn _t.Find(key);\n\t\t}\n\tprivate:\n\t\tRBTree&lt;K, K, SetKeyOfT&gt; _t;\n\t};\n\n\tvoid test_set1()\n\t{\n\t\tset&lt;int&gt; s;\n\t\ts.insert(8);\n\t\ts.insert(6);\n\t\ts.insert(11);\n\t\ts.insert(5);\n\t\ts.insert(6);\n\t\ts.insert(7);\n\t\ts.insert(10);\n\t\ts.insert(13);\n\t\ts.insert(12);\n\t\ts.insert(15);\n\n\t\tset&lt;int&gt;::iterator it = s.begin();\n\t\twhile (it != s.end())\n\t\t{\n\t\t\tcout &lt;&lt; *it &lt;&lt; \" \";\n\t\t\t++it;\n\t\t}\n\t\tcout &lt;&lt; endl;\n\n\t\tfor (auto e : s)\n\t\t{\n\t\t\tcout &lt;&lt; e &lt;&lt; \" \";\n\t\t}\n\t\tcout &lt;&lt; endl;\n\t}\n}</code></pre>\n<h2 id=\"RBTree.h\">RBTree.h</h2>\n<pre><code class=\"language-cpp\">pragma once\n\nenum Colour\n{\n\tRED,\n\tBLACK,\n};\n\ntemplate&lt;class T&gt;\nstruct RBTreeNode\n{\n\tRBTreeNode&lt;T&gt;* _left;\n\tRBTreeNode&lt;T&gt;* _right;\n\tRBTreeNode&lt;T&gt;* _parent;\n\tT _data; // 数据\n\n\tColour _col;\n\n\tRBTreeNode(const T&amp; data)\n\t\t:_data(data)\n\t\t, _left(nullptr)\n\t\t, _right(nullptr)\n\t\t, _parent(nullptr)\n\t\t, _col(RED)\n\t{}\n};\n\ntemplate&lt;class T, class Ref, class Ptr&gt;\nstruct __RBTreeIterator\n{\n\ttypedef RBTreeNode&lt;T&gt; Node;\n\ttypedef __RBTreeIterator&lt;T, Ref, Ptr&gt; Self;\n\tNode* _node;\n\n\t__RBTreeIterator(Node* node)\n\t\t:_node(node)\n\t{}\n\n\tRef operator*()\n\t{\n\t\treturn _node-&gt;_data;\n\t}\n\n\tPtr operator-&gt;()\n\t{\n\t\treturn &amp;_node-&gt;_data;\n\t}\n\t// 休息17:00\n\tSelf&amp; operator++()\n\t{\n\t\tif (_node-&gt;_right == nullptr)\n\t\t{\n\t\t\t// 找祖先里面，孩子是父亲左的那个\n\t\t\tNode* cur = _node;\n\t\t\tNode* parent = cur-&gt;_parent;\n\t\t\twhile (parent &amp;&amp; parent-&gt;_right == cur)\n\t\t\t{\n\t\t\t\tcur = cur-&gt;_parent;\n\t\t\t\tparent = parent-&gt;_parent;\n\t\t\t}\n\n\t\t\t_node = parent;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// 右子树的最左节点\n\t\t\tNode* subLeft = _node-&gt;_right;\n\t\t\twhile (subLeft-&gt;_left)\n\t\t\t{\n\t\t\t\tsubLeft = subLeft-&gt;_left;\n\t\t\t}\n\n\t\t\t_node = subLeft;\n\t\t}\n\t\t\n\t\treturn *this;\n\t}\n\n\tSelf operator++(int)\n\t{\n\t\tSelf tmp(*this);\n\t\t\n\t\t++(*this);\n\n\t\treturn tmp;\n\t}\n\n\tSelf&amp; operator--()\n\t{\n\t\tif (_node-&gt;_left == nullptr)\n\t\t{\n\t\t\t// 找祖先里面，孩子是父亲\n\t\t\tNode* cur = _node;\n\t\t\tNode* parent = cur-&gt;_parent;\n\t\t\twhile (parent &amp;&amp; cur == parent-&gt;_left)\n\t\t\t{\n\t\t\t\tcur = cur-&gt;_parent;\n\t\t\t\tparent = parent-&gt;_parent;\n\t\t\t}\n\n\t\t\t_node = parent;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// 左子树的最右节点\n\t\t\tNode* subRight = _node-&gt;_left;\n\t\t\twhile (subRight-&gt;_right)\n\t\t\t{\n\t\t\t\tsubRight = subRight-&gt;_right;\n\t\t\t}\n\n\t\t\t_node = subRight;\n\t\t}\n\n\t\treturn *this;\n\t}\n\n\tSelf operator--(int)\n\t{\n\t\tSelf tmp(*this);\n\n\t\t--(*this);\n\n\t\treturn tmp;\n\t}\n\n\tbool operator!=(const Self&amp; s) const\n\t{\n\t\treturn _node != s._node;\n\t}\n\n\tbool operator==(const Self&amp; s) const\n\t{\n\t\treturn _node == s-&gt;_node;\n\t}\n};\n\n// T决定红黑树存什么数据\n// set  RBTree&lt;K, K&gt;\n// map  RBTree&lt;K, pair&lt;K, V&gt;&gt;\n// KeyOfT -&gt; 支持取出T对象中key的仿函数\ntemplate&lt;class K, class T, class KeyOfT&gt;\nclass RBTree\n{\n\ttypedef RBTreeNode&lt;T&gt; Node;\npublic:\n\ttypedef __RBTreeIterator&lt;T, T&amp;, T*&gt; iterator;\n\ttypedef __RBTreeIterator&lt;T, const T&amp;, const T*&gt; const_iterator;\n\n\t// 构造 拷贝构造 赋值 和析构 跟搜索树实现方式是一样的\n\n\titerator Begin()\n\t{\n\t\tNode* subLeft = _root;\n\t\twhile (subLeft &amp;&amp; subLeft-&gt;_left)\n\t\t{\n\t\t\tsubLeft = subLeft-&gt;_left;\n\t\t}\n\n\t\treturn iterator(subLeft);\n\t}\n\n\titerator End()\n\t{\n\t\treturn iterator(nullptr);\n\t}\n\n\tconst_iterator Begin() const\n\t{\n\t\tNode* subLeft = _root;\n\t\twhile (subLeft &amp;&amp; subLeft-&gt;_left)\n\t\t{\n\t\t\tsubLeft = subLeft-&gt;_left;\n\t\t}\n\n\t\treturn const_iterator(subLeft);\n\t}\n\n\tconst_iterator End() const\n\t{\n\t\treturn const_iterator(nullptr);\n\t}\n\n\tpair&lt;iterator, bool&gt; Insert(const T&amp; data)\n\t{\n\t\t// 1、搜索树的规则插入\n\t\t// 2、看是否违反平衡规则，如果违反就需要处理：旋转\n\t\tif (_root == nullptr)\n\t\t{\n\t\t\t_root = new Node(data);\n\t\t\t_root-&gt;_col = BLACK;\n\t\t\treturn make_pair(iterator(_root), true);\n\t\t}\n\n\t\tKeyOfT kot;\n\n\t\tNode* parent = nullptr;\n\t\tNode* cur = _root;\n\t\twhile (cur)\n\t\t{\n\t\t\tif (kot(cur-&gt;_data) &lt; kot(data))\n\t\t\t{\n\t\t\t\tparent = cur;\n\t\t\t\tcur = cur-&gt;_right;\n\t\t\t}\n\t\t\telse if (kot(cur-&gt;_data) &gt; kot(data))\n\t\t\t{\n\t\t\t\tparent = cur;\n\t\t\t\tcur = cur-&gt;_left;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn make_pair(iterator(cur), true);\n\t\t\t}\n\t\t}\n\n\t\tcur = new Node(data);\n\t\tNode* newnode = cur;\n\t\tcur-&gt;_col = RED;  \n\t\tif (kot(parent-&gt;_data) &lt; kot(data))\n\t\t{\n\t\t\tparent-&gt;_right = cur;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tparent-&gt;_left = cur;\n\t\t}\n\n\t\tcur-&gt;_parent = parent;\n\n\t\t// 存在连续红色节点\n\t\twhile (parent &amp;&amp; parent-&gt;_col == RED)\n\t\t{\n\t\t\tNode* grandfater = parent-&gt;_parent;\n\t\t\tassert(grandfater);\n\n\t\t\tif (grandfater-&gt;_left == parent)\n\t\t\t{\n\t\t\t\tNode* uncle = grandfater-&gt;_right;\n\t\t\t\t// 情况一：\n\t\t\t\tif (uncle &amp;&amp; uncle-&gt;_col == RED) // 叔叔存在且为红\n\t\t\t\t{\n\t\t\t\t\t// 变色\n\t\t\t\t\tparent-&gt;_col = uncle-&gt;_col = BLACK;\n\t\t\t\t\tgrandfater-&gt;_col = RED;\n\n\t\t\t\t\t// 继续往上处理\n\t\t\t\t\tcur = grandfater;\n\t\t\t\t\tparent = cur-&gt;_parent;\n\t\t\t\t}\n\t\t\t\telse // 叔叔不存在 或者 叔叔存在且为黑\n\t\t\t\t{\n\t\t\t\t\tif (cur == parent-&gt;_left) // 单旋\n\t\t\t\t\t{\n\t\t\t\t\t\t//     g\n\t\t\t\t\t\t//   p\n\t\t\t\t\t\t// c\n\t\t\t\t\t\tRotateR(grandfater);\n\t\t\t\t\t\tparent-&gt;_col = BLACK;\n\t\t\t\t\t\tgrandfater-&gt;_col = RED;\n\t\t\t\t\t}\n\t\t\t\t\telse // 双旋\n\t\t\t\t\t{\n\t\t\t\t\t\t//     g\n\t\t\t\t\t\t//   p\n\t\t\t\t\t\t//     c \n\t\t\t\t\t\tRotateL(parent);\n\t\t\t\t\t\tRotateR(grandfater);\n\t\t\t\t\t\tcur-&gt;_col = BLACK;\n\t\t\t\t\t\tgrandfater-&gt;_col = RED;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse //(grandfater-&gt;_right == parent)\n\t\t\t{\n\t\t\t\tNode* uncle = grandfater-&gt;_left;\n\t\t\t\t// 情况一：\n\t\t\t\tif (uncle &amp;&amp; uncle-&gt;_col == RED)\n\t\t\t\t{\n\t\t\t\t\t// 变色\n\t\t\t\t\tparent-&gt;_col = uncle-&gt;_col = BLACK;\n\t\t\t\t\tgrandfater-&gt;_col = RED;\n\n\t\t\t\t\t// 继续往上处理\n\t\t\t\t\tcur = grandfater;\n\t\t\t\t\tparent = cur-&gt;_parent;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (cur == parent-&gt;_right)\n\t\t\t\t\t{\n\t\t\t\t\t\t// g\n\t\t\t\t\t\t//   p\n\t\t\t\t\t\t//     c \n\t\t\t\t\t\tRotateL(grandfater);\n\t\t\t\t\t\tparent-&gt;_col = BLACK;\n\t\t\t\t\t\tgrandfater-&gt;_col = RED;\n\t\t\t\t\t}\n\t\t\t\t\telse // 双旋\n\t\t\t\t\t{\n\t\t\t\t\t\t// g\n\t\t\t\t\t\t//   p\n\t\t\t\t\t\t// c\n\t\t\t\t\t\tRotateR(parent);\n\t\t\t\t\t\tRotateL(grandfater);\n\t\t\t\t\t\tcur-&gt;_col = BLACK;\n\t\t\t\t\t\tgrandfater-&gt;_col = RED;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t_root-&gt;_col = BLACK;\n\n\t\treturn make_pair(iterator(newnode), true);\n\t}\n\n\tvoid RotateL(Node* parent)\n\t{\n\t\tNode* subR = parent-&gt;_right;\n\t\tNode* subRL = subR-&gt;_left;\n\n\t\tparent-&gt;_right = subRL;\n\t\tif (subRL)\n\t\t\tsubRL-&gt;_parent = parent;\n\n\t\tNode* ppNode = parent-&gt;_parent;\n\n\t\tsubR-&gt;_left = parent;\n\t\tparent-&gt;_parent = subR;\n\n\t\tif (parent == _root)\n\t\t{\n\t\t\t_root = subR;\n\t\t\t_root-&gt;_parent = nullptr;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (parent == ppNode-&gt;_left)\n\t\t\t{\n\t\t\t\tppNode-&gt;_left = subR;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tppNode-&gt;_right = subR;\n\t\t\t}\n\n\t\t\tsubR-&gt;_parent = ppNode;\n\t\t}\n\t}\n\n\tvoid RotateR(Node* parent)\n\t{\n\t\tNode* subL = parent-&gt;_left;\n\t\tNode* subLR = subL-&gt;_right;\n\n\t\tparent-&gt;_left = subLR;\n\t\tif (subLR)\n\t\t\tsubLR-&gt;_parent = parent;\n\n\t\tNode* ppNode = parent-&gt;_parent;\n\n\t\tsubL-&gt;_right = parent;\n\t\tparent-&gt;_parent = subL;\n\n\t\tif (parent == _root)\n\t\t{\n\t\t\t_root = subL;\n\t\t\t_root-&gt;_parent = nullptr;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (ppNode-&gt;_left == parent)\n\t\t\t{\n\t\t\t\tppNode-&gt;_left = subL;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tppNode-&gt;_right = subL;\n\t\t\t}\n\t\t\tsubL-&gt;_parent = ppNode;\n\t\t}\n\t}\n\n\titerator Find(const K&amp; key)\n\t{\n\t\tNode* cur = _root;\n\t\tKeyOfT kot;\n\t\twhile (cur)\n\t\t{\n\t\t\tif (kot(cur-&gt;_data) &lt; key)\n\t\t\t{\n\t\t\t\tcur = cur-&gt;_right;\n\t\t\t}\n\t\t\telse if (kot(cur-&gt;_data) &gt; key)\n\t\t\t{\n\t\t\t\tcur = cur-&gt;_left;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn iterator(cur);\n\t\t\t}\n\t\t}\n\n\t\treturn End();\n\t}\n\nprivate:\n\tNode* _root = nullptr;\n};</code></pre>\n<p></p>\n</div>\n</div>"}