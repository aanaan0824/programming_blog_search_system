{"blogid": "125333327", "writerAge": "码龄12年", "writerBlogNum": "4", "writerCollect": "3", "writerComment": "0", "writerFan": "0", "writerGrade": "1级", "writerIntegral": "65", "writerName": "南城码爷", "writerProfileAdress": "writer_image\\profile_125333327.jpg", "writerRankTotal": "139769", "writerRankWeekly": "354919", "writerThumb": "1", "writerVisitNum": "2375", "blog_read_count": "1027", "blog_time": "已于 2022-06-24 11:11:23 修改", "blog_title": "eigen 中的matrix", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"Storage%20orders-toc\" style=\"margin-left:40px;\"><a href=\"#Storage%20orders\">Storage orders</a></p>\n<p id=\"title3-toc\" style=\"margin-left:0px;\"><a href=\"#title3\">        </a> <a href=\"#title3\">Constructors</a></p>\n<p id=\"%E5%9B%BA%E5%AE%9A%E5%B0%BA%E5%AF%B8%E5%92%8C%E5%8A%A8%E6%80%81%E5%B0%BA%E5%AF%B8-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%9B%BA%E5%AE%9A%E5%B0%BA%E5%AF%B8%E5%92%8C%E5%8A%A8%E6%80%81%E5%B0%BA%E5%AF%B8\">固定尺寸和动态尺寸</a></p>\n<p id=\"%E5%9D%97%E6%93%8D%E4%BD%9C-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%9D%97%E6%93%8D%E4%BD%9C\">块操作</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h2 id=\"Storage%20orders\">Storage orders</h2>\n<p>eigen矩阵存储顺序两种，column-major 和 row-major，默认列排列</p>\n<p><img alt=\"A = \\begin{bmatrix} 8 &amp; 2 &amp; 2 &amp; 9 \\\\ 9 &amp; 1 &amp; 4 &amp; 4 \\\\ 3 &amp; 5 &amp; 4 &amp; 5 \\end{bmatrix}.\" class=\"mathcode\" src=\"https://latex.codecogs.com/gif.latex?A%20%3D%20%5Cbegin%7Bbmatrix%7D%208%20%26%202%20%26%202%20%26%209%20%5C%5C%209%20%26%201%20%26%204%20%26%204%20%5C%5C%203%20%26%205%20%26%204%20%26%205%20%5Cend%7Bbmatrix%7D.\"/></p>\n<p><strong>example：</strong></p>\n<pre><code>Matrix&lt;int, 3, 4, ColMajor&gt; Acolmajor;\nAcolmajor &lt;&lt; 8, 2, 2, 9,\n             9, 1, 4, 4,\n             3, 5, 4, 5;\ncout &lt;&lt; \"The matrix A:\" &lt;&lt; endl;\ncout &lt;&lt; Acolmajor &lt;&lt; endl &lt;&lt; endl; \n \ncout &lt;&lt; \"In memory (column-major):\" &lt;&lt; endl;\nfor (int i = 0; i &lt; Acolmajor.size(); i++)\n  cout &lt;&lt; *(Acolmajor.data() + i) &lt;&lt; \"  \";\ncout &lt;&lt; endl &lt;&lt; endl;\n \nMatrix&lt;int, 3, 4, RowMajor&gt; Arowmajor = Acolmajor;\ncout &lt;&lt; \"In memory (row-major):\" &lt;&lt; endl;\nfor (int i = 0; i &lt; Arowmajor.size(); i++)\n  cout &lt;&lt; *(Arowmajor.data() + i) &lt;&lt; \"  \";\ncout &lt;&lt; endl;</code></pre>\n<p><strong> Output:</strong></p>\n<pre><code>The matrix A:\n8 2 2 9\n9 1 4 4\n3 5 4 5\n\nIn memory (column-major):\n8  9  3  2  1  5  2  4  4  9  4  5  \n\nIn memory (row-major):\n8  2  2  9  9  1  4  4  3  5  4  5 </code></pre>\n<h1 id=\"title3\">Constructors</h1>\n<p>默认构造函数不执行任何动态内存分配，</p>\n<pre><code>Matrix3f a;\nMatrixXf b;</code></pre>\n<p>a是一个3x3矩阵，未初始化的数组float[9]。</p>\n<p>b是动态大小矩阵，大小为0x0。</p>\n<p>支持c++11，可以按如下初始化任意大小的矩阵，</p>\n<pre><code>Vector2i a(1, 2);                      // A column vector containing the elements {1, 2}\nMatrix&lt;int, 5, 1&gt; b {1, 2, 3, 4, 5};   // A row-vector containing the elements {1, 2, 3, 4, 5}\nMatrix&lt;int, 1, 5&gt; c = {1, 2, 3, 4, 5}; // A column vector containing the elements {1, 2, 3, 4, 5}\n</code></pre>\n<p>也可以逗号初始化<em>comma-initializer</em> syntax</p>\n<pre><code>Matrix3f m;\nm &lt;&lt; 1, 2, 3,\n     4, 5, 6,\n     7, 8, 9;</code></pre>\n<h2 id=\"%E5%9B%BA%E5%AE%9A%E5%B0%BA%E5%AF%B8%E5%92%8C%E5%8A%A8%E6%80%81%E5%B0%BA%E5%AF%B8\">固定尺寸和动态尺寸</h2>\n<p>什么时候应该使用固定尺寸（例如<code>Matrix4f</code>），什么时候应该使用动态尺寸（例如<code>MatrixXf</code>）？简单的答案是：尽可能对非常小的尺寸使用固定尺寸，并在较大尺寸或必须使用的地方使用动态尺寸。对于小尺寸，尤其是小于（大约）16 的尺寸，使用固定尺寸对性能非常有利，因为它允许<a class=\"el\" href=\"http://eigen.tuxfamily.org/dox/namespaceEigen.html\" title=\"Eigen\">Eigen</a>避免动态内存分配和展开循环。在内部，固定大小的<a class=\"el\" href=\"http://eigen.tuxfamily.org/dox/namespaceEigen.html\" title=\"Eigen\">Eigen</a>矩阵只是一个普通数组，即</p>\n<pre><code>Matrix4f mymatrix; \n//really amounts to just doing\nfloat mymatrix[16];</code></pre>\n<p>所以这真的有零运行成本。相比之下，动态大小矩阵的数组总是在堆heap上分配，所以这样做</p>\n<pre><code>MatrixXf mymatrix(rows,columns);\n//amounts to doing\nfloat *mymatrix = new float[rows*columns];</code></pre>\n<p>除此之外，该<code>MatrixXf</code>对象将其行数和列数存储为成员变量。</p>\n<p>当然，使用固定大小的限制是只有在编译时知道大小时才有可能。此外，对于足够大的尺寸，例如大于（大约）32 的尺寸，使用固定尺寸的性能优势变得可以忽略不计。更糟糕的是，尝试在函数内使用固定大小创建一个非常大的矩阵可能会导致堆栈溢出stack overflow，因为<a class=\"el\" href=\"http://eigen.tuxfamily.org/dox/namespaceEigen.html\" title=\"Eigen\">Eigen</a>会尝试将数组自动分配为局部变量，而这通常在堆栈上完成。最后，根据情况，当使用动态大小时， <a class=\"el\" href=\"http://eigen.tuxfamily.org/dox/namespaceEigen.html\" title=\"Eigen\">Eigen</a>也可以更积极地尝试向量化（使用 SIMD 指令），请参阅<a class=\"el\" href=\"http://eigen.tuxfamily.org/dox/TopicVectorization.html\" title=\"Vectorization\">Vectorization</a>。</p>\n<h2 id=\"%E5%9D%97%E6%93%8D%E4%BD%9C\">块操作</h2>\n<p>块是矩阵或数组的矩形部分。块表达式既可以用作右值，也可以用作左值。与通常的特征表达式一样，只要让编译器进行优化。</p>\n<p>两种表示形式：</p>\n<p> </p>\n<p><img alt=\"\" height=\"117\" src=\"image\\2435b20d50034df9a362bdcce5130c1a.png\" width=\"635\"/></p>\n<p><strong> Example:</strong></p>\n<pre><code>#include &lt;Eigen/Dense&gt;\n#include &lt;iostream&gt;\n \nint main()\n{\n  Eigen::Array22f m;\n  m &lt;&lt; 1,2,\n       3,4;\n  Eigen::Array44f a = Eigen::Array44f::Constant(0.6);\n  std::cout &lt;&lt; \"Here is the array a:\\n\" &lt;&lt; a &lt;&lt; \"\\n\\n\";\n  a.block&lt;2,2&gt;(1,1) = m;\n  std::cout &lt;&lt; \"Here is now a with m copied into its central 2x2 block:\\n\" &lt;&lt; a &lt;&lt; \"\\n\\n\";\n  a.block(0,0,2,3) = a.block(2,1,2,3);\n  std::cout &lt;&lt; \"Here is now a with bottom-right 2x3 block copied into top-left 2x3 block:\\n\" &lt;&lt; a &lt;&lt; \"\\n\\n\";\n}</code></pre>\n<p><strong>Output: </strong></p>\n<pre><code>Here is the array a:\n0.6 0.6 0.6 0.6\n0.6 0.6 0.6 0.6\n0.6 0.6 0.6 0.6\n0.6 0.6 0.6 0.6\n\nHere is now a with m copied into its central 2x2 block:\n0.6 0.6 0.6 0.6\n0.6   1   2 0.6\n0.6   3   4 0.6\n0.6 0.6 0.6 0.6\n\nHere is now a with bottom-right 2x3 block copied into top-left 2x3 block:\n  3   4 0.6 0.6\n0.6 0.6 0.6 0.6\n0.6   3   4 0.6\n0.6 0.6 0.6 0.6\n</code></pre>\n<p></p>\n</div>\n</div>"}