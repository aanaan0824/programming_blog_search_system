{"blogid": "125016506", "writerAge": "码龄1年", "writerBlogNum": "80", "writerCollect": "107", "writerComment": "19", "writerFan": "581", "writerGrade": "4级", "writerIntegral": "851", "writerName": "Promising_mi", "writerProfileAdress": "writer_image\\profile_125016506.jpg", "writerRankTotal": "20788", "writerRankWeekly": "2994", "writerThumb": "35", "writerVisitNum": "15514", "blog_read_count": "1430", "blog_time": "已于 2022-05-28 13:32:35 修改", "blog_title": "对简单字符串的排序整理（简单的2种方法）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h1>一、用sort对字符串排序</h1>\n<h3>1.sort可以对string排序</h3>\n<p>我在做题的时候发现我用sort对string排序的语句判错。</p>\n<p>我最开始写的代码是</p>\n<pre><code class=\"language-cpp\">    string s;\n    cin&gt;&gt;s;\n    int len=s.length();\n    sort(s,s+len);</code></pre>\n<p>我的天，我现在看见我这么写，<s>我真想给自己一下子</s>。现在因为返乡隔离什么的大脑都已经混乱了，我想我真是封的疯了。</p>\n<p>在我查找相关的资料之后，终于大彻大悟，醍醐灌顶。正确代码如下：</p>\n<pre><code>    string s;\n    cin&gt;&gt;s;\n    sort(s.begin(),s.end());</code></pre>\n<p>看见正确的之后突然想起来string是一个类啊，和vector，queue什么的都有库函数啊，而且巨好用啊。这样事情就明了了，直接用这个方法对string排序就好了。</p>\n<p></p>\n<h3>2.sort可以对字符数组排序</h3>\n<pre><code class=\"language-cpp\">int main(){\n    char ch[1001];\n    cin&gt;&gt;ch;\n    int len=strlen(ch);\n    sort(ch,ch+len);\n    cout&lt;&lt;ch;\n    return 0;\n}</code></pre>\n<p></p>\n<p>用cin直接按首地址输入字符串，不能读入空格和回车</p>\n<p>输入一串字符之后再按回车就直接输出了，应该根本没机会在cin中按回车 。（如果此话有错误，欢迎家银们批评指正）</p>\n<p><img alt=\"\" height=\"492\" src=\"image\\43b9073be64b4deaa526b31100abcaa9.png\" width=\"1200\"/></p>\n<p></p>\n<p>如果这样输入字符串</p>\n<p>这样应该是没有超过100个字符都给算到里面了，如果输入没有超过100个字符，结束输入用ctrl+z结束。</p>\n<p><img alt=\"\" height=\"554\" src=\"image\\84f7a5df7c614e269b45ed3b837ca64b.png\" width=\"1200\"/></p>\n<p></p>\n<p></p>\n<p> 如果输入超过100个字符，即使在输入的过程中超过了100，但还是可以输入，最后按回车就结束输入了，字符数组里面只取100个字符。</p>\n<p><img alt=\"\" height=\"893\" src=\"image\\c7ced55aaedf4bf2a61c7a88d5823cfe.png\" width=\"1200\"/></p>\n<p></p>\n<h1>二、类似冒泡排序的方法</h1>\n<p>这个方法具体有没有名字我不知道，但我刚学的时候总是用这个方法，其实还挺好用。</p>\n<p>但是时间复杂度高，为O（n2）。</p>\n<p><img alt=\"\" height=\"680\" src=\"image\\467105571fc343838682499bbd8ad067.png\" width=\"1200\"/></p>\n<p></p>\n<pre><code class=\"language-cpp\">int main(){\n    char ch[1001];\n    cin&gt;&gt;ch;\n    int len=strlen(ch);\n    for(int i=0;i&lt;len-1;++i){\n        for(int j=i+1;j&lt;len;++j)\n            if(ch[j]&lt;ch[i])\n                swap(ch[i],ch[j]);\n    }\n    cout&lt;&lt;ch;\n    return 0;\n}</code></pre>\n<p>i 从 0 循环到 len-1，j 从 i+1 到最后。</p>\n<p>如果在  s[i]  后面有比  s[j]  小的，就把小的放在前面，每一次移动都确定了前面的1个元素的位置，最后就排好序了。属于稳定排序。</p>\n</div>\n</div>"}