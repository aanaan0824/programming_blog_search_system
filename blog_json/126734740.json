{"blogid": "126734740", "writerAge": "码龄1年", "writerBlogNum": "135", "writerCollect": "145", "writerComment": "201", "writerFan": "1325", "writerGrade": "5级", "writerIntegral": "1924", "writerName": "从未止步..", "writerProfileAdress": "writer_image\\profile_126734740.jpg", "writerRankTotal": "10359", "writerRankWeekly": "945", "writerThumb": "315", "writerVisitNum": "25082", "blog_read_count": "16", "blog_time": "已于 2022-09-07 18:38:05 修改", "blog_title": "栈在递归中的应用", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-light\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h2><a id=\"_0\"></a>函数调用的特点：</h2>\n<p>函数调用的过程：<br/> <img alt=\"在这里插入图片描述\" src=\"image\\fce4479b8a5e4fed9ad32bad3f0a549a.png\"/>那么该过程其实和元素进栈是相类似的：</p>\n<p>如下图所示：</p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\213b0464d62d4e66bedf8be0c11f4fc7.png\"/>函数调用时，需要用一个栈存储：</p>\n<p>1：调用返回地址</p>\n<p>2：实参</p>\n<p>3：局部变量</p>\n<p>当所有可调用的函数都被调用完之后，下面执行未执行完成的语句：<br/> <img alt=\"在这里插入图片描述\" src=\"image\\24f09c3b6b3443b3bdb5fe87e738e63c.png\"/>此时的函数调用栈，相当于进行出栈的操作：</p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\547bd33f20c2432b83a7bf2c0fcb69db.png\"/>接着将func1所占用的内存进行释放。</p>\n<p><strong>最后被调用的函数最先被调用的函数最先被执行结束（LIFO）</strong></p>\n<p>适合用“递归”算法解决：可以把原始问题转换成属性相同，但规模较小的问题。<br/> 举例：<br/> <img alt=\"在这里插入图片描述\" src=\"image\\30beeb0c39124c068738215249a4c75b.png\"/>我们将问题规模从n转换到了比n更小的n-1.</p>\n<p>但如何设计一个递归算法并不是这里要探讨的主要问题，这里，我们重点学习栈在递归中的应用。</p>\n<p>递归调用时，函数调用栈可称为“递归工作栈”</p>\n<h2><a id=\"n_31\"></a>递归算法实现n的阶乘：</h2>\n<p><strong>每进入一层递归，就将递归调用所需信息压入栈顶</strong></p>\n<p>如下图所示：<br/> <img alt=\"在这里插入图片描述\" src=\"image\\181af637a81a44ce8747525ff377dd96.png\"/><strong>每退出一层递归，就从栈顶弹出相应的信息</strong></p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\56941bc2edb24a7d881ddfa27260c372.png\"/>下面也是如此调用返回，直到第一层。</p>\n<p>这种算法虽然可以一定程度上减小问题规模，但是，<strong>当太多层递归可能会导致栈溢出</strong>，设想，上述实例，假如传入的参数为10000，按摩相当于该栈需要压入10000层，但我们的内存资源是有限的，这样一来会增加空间复杂度。</p>\n<h2><a id=\"_42\"></a>递归算法实现斐波那契数列：</h2>\n<p><strong>每进入一层递归，就将递归调用所需信息压入栈顶</strong></p>\n<p>如下图所示：<br/> <img alt=\"在这里插入图片描述\" src=\"image\\05b5821c62f240ad8a163cde6028f081.png\"/><br/> <strong>每退出一层递归，就从栈顶弹出相应的信息</strong></p>\n<p>如下图所示：</p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\70ab7671c8f144faae371abebf682f7c.png\"/><br/> 通过上图的递归调用过程，我们不难发现，其实有很多项都是重复计算的，例如：Fib(1)/FIb(2),因此，<strong>递归的调用可能包含重复计算，这也是它的缺点。</strong></p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}