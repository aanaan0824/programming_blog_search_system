{"blogid": "125719373", "writerAge": "码龄1年", "writerBlogNum": "43", "writerCollect": "1846", "writerComment": "2943", "writerFan": "2178", "writerGrade": "6级", "writerIntegral": "6934", "writerName": "敲代码の流川枫", "writerProfileAdress": "writer_image\\profile_125719373.jpg", "writerRankTotal": "2211", "writerRankWeekly": "65", "writerThumb": "2428", "writerVisitNum": "29468", "blog_read_count": "997", "blog_time": "已于 2022-07-19 11:23:56 修改", "blog_title": "C语言进阶——字符函数和字符串函数", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p></p>\n<p class=\"img-center\"><img alt=\"ced485cbb11e458d81a746890b32cf3f.gif\" src=\"https://img-blog.csdnimg.cn/ced485cbb11e458d81a746890b32cf3f.gif\"/></p>\n<blockquote>\n<p>作者：<span style=\"color:#faa572;\"><strong>敲代码の流川枫</strong></span></p>\n<p>博客主页：<a href=\"https://blog.csdn.net/chenchenchencl?spm=1011.2421.3001.5343\" title=\"流川枫的博客\">流川枫的博客</a></p>\n<p>专栏：<a href=\"https://blog.csdn.net/chenchenchencl/category_11903109.html\" title=\"C语言从入门到进阶\">C语言从入门到进阶</a></p>\n<p>语录：<span style=\"color:#faa572;\"><strong>Stay hungry stay foolish</strong></span></p>\n<p><span style=\"color:#faa572;\"><strong>工欲善其事必先利其器，给大家介绍一款超牛的斩获大厂offer利器——牛客网</strong></span></p>\n<p><strong><span style=\"color:#faa572;\"><a href=\"https://www.nowcoder.com/link/pc_csdncpt_qdmdlcf_c\" title=\"点击免费注册和我一起刷题吧\">点击免费注册和我一起刷题吧</a></span></strong></p>\n</blockquote>\n<blockquote>\n<p><strong>重点介绍处理字符和字符串的库函数的使用和注意事项</strong></p>\n</blockquote>\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"1.%E6%B1%82%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A6-toc\" style=\"margin-left:0px;\"><a href=\"#1.%E6%B1%82%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A6\">1.求字符串长度</a></p>\n<p id=\"strlen-toc\" style=\"margin-left:40px;\"><a href=\"#strlen\">1.1 strlen</a></p>\n<p id=\"1.2%20strlen%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-toc\" style=\"margin-left:40px;\"><a href=\"#1.2%20strlen%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0\">1.2 strlen的模拟实现</a></p>\n<p id=\"2.%E9%95%BF%E5%BA%A6%E4%B8%8D%E5%8F%97%E9%99%90%E5%88%B6%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:0px;\"><a href=\"#2.%E9%95%BF%E5%BA%A6%E4%B8%8D%E5%8F%97%E9%99%90%E5%88%B6%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0\">2.长度不受限制的字符串函数</a></p>\n<p id=\"2.1strcp-toc\" style=\"margin-left:40px;\"><a href=\"#2.1strcp\">2.1 strcpy</a></p>\n<p id=\"2.2%C2%A0strcpy%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-toc\" style=\"margin-left:40px;\"><a href=\"#2.2%C2%A0strcpy%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0\">2.2 strcpy的模拟实现</a></p>\n<p id=\"2.2strcat-toc\" style=\"margin-left:40px;\"><a href=\"#2.2strcat\">2.3 strcat</a></p>\n<p id=\"2.4%C2%A0strcat%20%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-toc\" style=\"margin-left:40px;\"><a href=\"#2.4%C2%A0strcat%20%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0\">2.4 strcat 的模拟实现</a></p>\n<p id=\"2.3strcmp-toc\" style=\"margin-left:40px;\"><a href=\"#2.3strcmp\">2.5 strcmp</a></p>\n<p id=\"2.6%20strcmp%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-toc\" style=\"margin-left:40px;\"><a href=\"#2.6%20strcmp%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0\">2.6 strcmp的模拟实现</a></p>\n<p id=\"3.%E9%95%BF%E5%BA%A6%E5%8F%97%E9%99%90%E5%88%B6%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D-toc\" style=\"margin-left:0px;\"><a href=\"#3.%E9%95%BF%E5%BA%A6%E5%8F%97%E9%99%90%E5%88%B6%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D\">3.长度受限制的字符串函数</a></p>\n<p id=\"3.1strncpy-toc\" style=\"margin-left:40px;\"><a href=\"#3.1strncpy\">3.1 strncpy</a></p>\n<p id=\"3.2%20strncpy%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-toc\" style=\"margin-left:40px;\"><a href=\"#3.2%20strncpy%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0\">3.2 strncpy的模拟实现</a></p>\n<p id=\"3.2strncat-toc\" style=\"margin-left:40px;\"><a href=\"#3.2strncat\">3.3 strncat</a></p>\n<p id=\"3.4%20strncat%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-toc\" style=\"margin-left:40px;\"><a href=\"#3.4%20strncat%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0\">3.4 strncat的模拟实现</a></p>\n<p id=\"3.3strncmp-toc\" style=\"margin-left:40px;\"><a href=\"#3.3strncmp\">3.5 strncmp</a></p>\n<p id=\"4.%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE-toc\" style=\"margin-left:0px;\"><a href=\"#4.%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE\">4.字符串查找</a></p>\n<p id=\"4.1strstr-toc\" style=\"margin-left:40px;\"><a href=\"#4.1strstr\">4.1 strstr</a></p>\n<p id=\"4.2%20strstr%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-toc\" style=\"margin-left:40px;\"><a href=\"#4.2%20strstr%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0\">4.2 strstr的模拟实现</a></p>\n<p id=\"4.3%C2%A0strtok-toc\" style=\"margin-left:40px;\"><a href=\"#4.3%C2%A0strtok\">4.3 strtok</a></p>\n<p id=\"5.%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%E6%8A%A5%E5%91%8A-toc\" style=\"margin-left:0px;\"><a href=\"#5.%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%E6%8A%A5%E5%91%8A\">5.错误信息报告</a></p>\n<p id=\"strerror-toc\" style=\"margin-left:40px;\"><a href=\"#strerror\">5.1strerror</a></p>\n<p id=\"6.%E5%AD%97%E7%AC%A6%E6%93%8D%E4%BD%9C%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:0px;\"><a href=\"#6.%E5%AD%97%E7%AC%A6%E6%93%8D%E4%BD%9C%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0\">6.内存操作函数</a></p>\n<p id=\"6.1memcpy-toc\" style=\"margin-left:40px;\"><a href=\"#6.1memcpy\">6.1 memcpy</a></p>\n<p id=\"6.2memmove-toc\" style=\"margin-left:40px;\"><a href=\"#6.2memmove\">6.2 memcpy的模拟实现</a></p>\n<p id=\"6.3%C2%A0memmove-toc\" style=\"margin-left:40px;\"><a href=\"#6.3%C2%A0memmove\">6.3 memmove</a></p>\n<p id=\"6.4%20memmove%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-toc\" style=\"margin-left:40px;\"><a href=\"#6.4%20memmove%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0\">6.4 memmove的模拟实现</a></p>\n<p id=\"6.3memset-toc\" style=\"margin-left:40px;\"><a href=\"#6.3memset\">6.5 memset</a></p>\n<p id=\"6.4memcmp-toc\" style=\"margin-left:40px;\"><a href=\"#6.4memcmp\">6.6 memcmp</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h1 id=\"1.%E6%B1%82%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A6\">1.求字符串长度</h1>\n<h2 id=\"strlen\">1.1 strlen</h2>\n<div>\n<pre><code>size_t strlen ( const char * str );</code></pre>\n</div>\n<blockquote>\n<p><strong><span style=\"background-color:#f3f3f4;\">函数功能：strlen函数返回的是在字符串中'\\0'前面出现的字符个数（不包含'\\0')</span></strong></p>\n<p><img alt=\"\" height=\"257\" src=\"image\\dbfb5af0ef794796ab5a7b963b8fa2b6.png\" width=\"954\"/></p>\n</blockquote>\n<p><strong> 注意事项：</strong></p>\n<blockquote>\n<p><strong>参数指向的字符串必须要以'\\0'结束，</strong>如果不以‘\\0’结束，会一直向后读取字符，直到出现零终止符为止，因此会返回随机值， 编译器也会提示需要给字符串添加零终止符</p>\n<div>\n<pre><code>#define _CRT_SECURE_NO_WARNINGS\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\nint main()\n{\n\tchar arr1[] = { 'b','i','t' };\n\tint len = strlen(arr1);\n\tprintf(\"%d\\n\", len);\n\treturn 0;\n}</code></pre>\n</div>\n<p></p>\n<div>\n<p><img alt=\"\" height=\"80\" src=\"image\\e7a070ce1ce14035a031d1869b72aee9.png\" width=\"541\"/>​</p>\n</div>\n<div>\n<p><img alt=\"\" height=\"59\" src=\"image\\a60b1ad6f6934b6abaece17733981916.png\" width=\"530\"/>​</p>\n</div>\n</blockquote>\n<blockquote>\n<p><strong>注意函数的返回值为<span style=\"background-color:#38d8f0;\">size_t</span>，是无符号整型</strong></p>\n<p><img alt=\"\" height=\"115\" src=\"image\\4e2f8793a44a480392608fedf5828025.png\" width=\"976\"/></p>\n<p></p>\n<div>\n<pre><code>#define _CRT_SECURE_NO_WARNINGS\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\nint main()\n{\n\tif (strlen(\"abc\") - strlen(\"abcdef\") &gt; 0)\n\t\tprintf(\"&gt;\");\n\tif (strlen(\"abc\") - strlen(\"abcdef\") &lt; 0)\n\t\tprintf(\"&lt;\");\n\tif (strlen(\"abc\") - strlen(\"abcdef\") == 0)\n\t\tprintf(\"==\");\n\treturn 0;\n}</code></pre>\n</div>\n<div>\n<p><img alt=\"\" height=\"63\" src=\"image\\dcf55b09abd44282b6da5132e0578997.png\" width=\"445\"/>​</p>\n</div>\n<p>这段代码不仔细分析会认为输出的是”&lt;“,结果是”&gt;“,因为<strong><span style=\"background-color:#f3f3f4;\">size_t返回的是无符号整型，-3的补码被当成无符号整型来处理的时候返回的是非常大的正数，</span></strong>因此会是”&gt;“ ，要注意strlen的返回值是无符号整型,可以这样直接比较strlen(\"abc\") &gt; strlen(\"abcdef\")，也可以将strlen函数返回值强制类型转换为有符号整型</p>\n</blockquote>\n<h2 id=\"1.2%20strlen%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0\">1.2 strlen的模拟实现</h2>\n<blockquote>\n<div>\n<pre><code>#define _CRT_SECURE_NO_WARNINGS\n#include&lt;stdio.h&gt;\n#include&lt;assert.h&gt;\n//创建计数器方式\nsize_t my_strlen(const char* str)\n{\n\tsize_t count = 0;\n\tassert(str);\n\twhile (*str !='\\0')\n\t{\n\t\tcount++;\n\t\tstr++;\n\t}\n\treturn count;\n}\nint main()\n{\n\tchar arr[] = \"abcdef\";\n\tsize_t n = my_strlen(arr);\n\tprintf(\"%u\\n\", n);\n\treturn 0;\n}</code></pre>\n</div>\n<div>\n<p><img alt=\"\" height=\"71\" src=\"image\\7b23c725f1a44860ac880c0f6d2655de.png\" width=\"552\"/>​</p>\n</div>\n<p>还有两种模拟实现方式：</p>\n<div>\n<pre><code>//指针-指针的方式\nint my_strlen(char*s)\n{\n\tchar*p=s;\n\twhile(*p!='\\0')\n\t\tp++;\n\treturn p -s;\n}\n//不能创建临时变量计数器\nint my_strlen(const char*str)\n{ \n\tif(*str=='\\0')\n\t\treturn 0;\n\telse return 1+my_strlen(str+1);\n}</code></pre>\n</div>\n</blockquote>\n<h1 id=\"2.%E9%95%BF%E5%BA%A6%E4%B8%8D%E5%8F%97%E9%99%90%E5%88%B6%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0\">2.长度不受限制的字符串函数</h1>\n<h2 id=\"2.1strcp\">2.1 strcpy</h2>\n<div>\n<pre><code>char* strcpy(char* destination, const char*source );</code></pre>\n</div>\n<blockquote>\n<p class=\"img-center\"><img alt=\"\" height=\"450\" src=\"image\\703ae25faf144542b31d55d7b38737ab.png\" width=\"954\"/></p>\n</blockquote>\n<blockquote>\n<p> 注意事项：</p>\n<p><strong>源字符串必须以'\\0'结束</strong></p>\n<p><strong>会将源字符串中的'\\0'拷贝到目标空间</strong></p>\n<p><strong>目标空间必须足够大，以确保能存放源字符串</strong></p>\n<p><strong>目标空间必须可变</strong></p>\n</blockquote>\n<h2 id=\"2.2%C2%A0strcpy%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0\">2.2 strcpy的模拟实现</h2>\n<blockquote>\n<div>\n<pre><code>#define _CRT_SECURE_NO_WARNINGS\n#include&lt;stdio.h&gt;\n#include&lt;assert.h&gt;\n\nchar* my_strcpy(char* str1,const char* str2)\n{\n\tassert(str1);\n\tassert(str2);\n\tchar*ret = str1;\n\twhile (*str1++ = *str2++)\n\t{\n\t\t;\n\t}\n\treturn ret;\n}\nint main()\n{\n\tchar arr1[] = \"abcdef\";\n\tchar arr2[20] = { 0 };\n\tmy_strcpy(arr2, arr1);\n\tprintf(\"%s\\n\",arr2);\n\treturn 0;\n\n}</code></pre>\n</div>\n<div>\n<p class=\"img-center\"><img alt=\"\" height=\"76\" src=\"image\\c1c7a8a943594fafb7bfb5505db9dfea.png\" width=\"413\"/></p>\n<p>​</p>\n</div>\n<p><span style=\"background-color:#38d8f0;\"> char*ret = str1;</span>在函数结束要返回str1的地址时，str1已经改变，因此要在<strong>未改变之前创建ret保存它的初始地址用于返回</strong></p>\n</blockquote>\n<h2 id=\"2.2strcat\">2.3 strcat</h2>\n<div>\n<pre><code>char* strcat ( char* destination, const char* source );</code></pre>\n</div>\n<div>\n<blockquote>\n<p><img alt=\"\" height=\"477\" src=\"image\\bc85ebb1c4f9464aa695abf54a0152aa.png\" width=\"958\"/>​</p>\n</blockquote>\n</div>\n<blockquote>\n<p> <strong>注意事项：</strong></p>\n<p><strong>目标空间必须可修改，能够将数据追加上去</strong></p>\n<p><strong>源字符串必须以'\\0'结束，否则无法追加数据</strong></p>\n<p><strong>目标空间必须有足够的大,能容纳下源字符串的内容，否则编译器会提示警告，也可以成功追加上去字符串，但是会覆盖掉原有地址的数据，是非常危险的行为</strong></p>\n</blockquote>\n<blockquote>\n<p>功能：</p>\n<div>\n<pre><code>#define _CRT_SECURE_NO_WARNINGS\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\nint main()\n{\n\tchar arr1[20] = \"hello\";\n\tchar arr2[] = \"world\";\n\tstrcat(arr1, arr2);\n\tprintf(\"%s\\n\", arr1);\n\treturn 0;\n}</code></pre>\n</div>\n<div>\n<p class=\"img-center\"><img alt=\"\" height=\"76\" src=\"image\\a3b2e1538d5b4147af1aaaa2b4affd11.png\" width=\"536\"/></p>\n<p>​</p>\n</div>\n<p></p>\n</blockquote>\n<blockquote>\n<h2 id=\"2.4%C2%A0strcat%20%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0\">2.4 strcat 的模拟实现</h2>\n<div>\n<pre><code>#define _CRT_SECURE_NO_WARNINGS\n#include&lt;stdio.h&gt;\n#include&lt;assert.h&gt;\nchar* my_strcat(char* dest, const char* src)\n{\n\tchar* ret = dest;\n\tassert(dest &amp;&amp; src);\n\twhile(*dest != '\\0')\n\t{\n\t\tdest++;\n\t}\n\twhile (*dest++ = *src++)\n\t{\n\t\t;\n\t}\n\treturn ret;\n}\nint main()\n{\n\tchar arr1[20] = \"hollo\";\n\tmy_strcat(arr1, \"world\");\n\tprintf(\"%s\\n\", arr1);\n\treturn 0;\n}</code></pre>\n</div>\n<p>该函数要避免自己给自己追加数据，因为开始追加时，第一个字符会将零终止符覆盖掉，当全部字符都追加完之后，没有零终止符了，出现死循环</p>\n</blockquote>\n<h2 id=\"2.3strcmp\">2.5 strcmp</h2>\n<p></p>\n<div>\n<pre><code>int strcmp ( const char* str1, const char* str2 );</code></pre>\n</div>\n<blockquote>\n<p><strong>功能：</strong></p>\n<div id=\"I_description\" style=\"margin-left:0;\">\n<strong><span style=\"color:#000000;\"><span style=\"background-color:#ffffff;\">比较两个字符串</span></span></strong>\n</div>\n<p><strong>将 C 字符串 <em>str1</em> 与 C 字符串 <em>str2 进行比较</em><br/> 此函数开始比较每个字符串的第一个字符。如果它们彼此相等，则继续比较下一对，直到字符不同或达到终止空字符<br/> 此函数执行字符的二进制比较</strong></p>\n</blockquote>\n<div>\n<blockquote>\n<p class=\"img-center\"><img alt=\"\" height=\"333\" src=\"image\\f1a46e4510cf4c628a4faed9a3dcd854.png\" width=\"438\"/></p>\n<p>​</p>\n</blockquote>\n</div>\n<h2 id=\"2.6%20strcmp%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0\">2.6 strcmp的模拟实现</h2>\n<blockquote>\n<div>\n<pre><code>#define _CRT_SECURE_NO_WARNINGS\n#include&lt;stdio.h&gt;\nint my_strcmp(const char* str1, const char* str2)\n{\n\twhile (*str1 == *str2)\n\t{\n\t\tif (*str1 == '\\0')\n\t\t\treturn 0;\n\t\tstr1++;\n\t\tstr2++;\n\t}\n\treturn  (*str1 - *str2);\n}\nint main()\n{\n\tchar arr1[] = \"abc\";\n\tchar arr2[] = \"abc\";\n\tint ret = my_strcmp(arr1, arr2);\n\tif (ret == 0)\n\t\tprintf(\"==\\n\");\n\tif (ret &gt; 0)\n\t\tprintf(\"&gt;\\n\");\n\tif (ret &lt; 0)\n\t\tprintf(\"&lt;\\n\");\n\treturn 0;\n}</code></pre>\n</div>\n<div>\n<p><img alt=\"\" height=\"77\" src=\"image\\37d9dec7e74545e2be4c405f56831958.png\" width=\"519\"/>​</p>\n</div>\n<p><span style=\"background-color:#38d8f0;\"> my_strcmp </span>函数的思路是，让两个字符串从第一对开始比较，如果相等则都自增实现下一对的比较，如果比较到最后，第一个字符串结束，即出现零终止符，那么返回0，两字符串相等；如果在出现零终止符之前有一对不相等，那么返回两字符串相减的值，可以比较出大小</p>\n</blockquote>\n<h1 id=\"3.%E9%95%BF%E5%BA%A6%E5%8F%97%E9%99%90%E5%88%B6%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D\">3.长度受限制的字符串函数介绍</h1>\n<h2 id=\"3.1strncpy\">3.1 strncpy</h2>\n<div>\n<pre><code>char * strncpy ( char * destination, const char * source, size_t num )</code></pre>\n</div>\n<blockquote>\n<p><strong>功能：</strong></p>\n<p><strong>拷贝num个字符从源字符串到目标空间</strong></p>\n</blockquote>\n<blockquote>\n<p><span style=\"background-color:#38d8f0;\">如果源字符串的长度小于num，则拷贝完源字符串之后，在目标的后边追加0，直到num个</span></p>\n<div>\n<pre><code>#define _CRT_SECURE_NO_WARNINGS\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\nint main()\n{\n\tchar arr1[10] = \"abcde\";\n\tchar arr2[] = \"fghi\";\n\tstrncpy(arr1, arr2, 7);\n\tprintf(\"%s\\n\", arr1);\n\treturn 0;\n}</code></pre>\n</div>\n<div>\n<p><img alt=\"\" height=\"77\" src=\"image\\362c684bc4a54d8a8c7776d322b79bcc.png\" width=\"395\"/>​</p>\n</div>\n</blockquote>\n<h2 id=\"3.2%20strncpy%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0\">3.2 strncpy的模拟实现</h2>\n<div>\n<pre><code>char * __cdecl strncpy (\n        char * dest,\n        const char * source,\n        size_t count\n        )\n{\n        char *start = dest;\n\n        while (count &amp;&amp; (*dest++ = *source++) != '\\0')    /* copy string */\n                count--;\n\n        if (count)                              /* pad out with zeroes */\n                while (--count)\n                        *dest++ = '\\0';\n\n        return(start);\n}\n</code></pre>\n</div>\n<h2 id=\"3.2strncat\">3.3 strncat</h2>\n<div>\n<pre><code>char * strncat ( char * destination, const char * source, size_t num );</code></pre>\n</div>\n<blockquote>\n<p><strong>功能：<br/> 将源的第一个字符追加到目标，以及终止空字符<br/> 如果源中字符串的长度小于num,则仅重复终止空字符之前的内容</strong></p>\n<div>\n<pre><code>#define _CRT_SECURE_NO_WARNINGS\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\nint main()\n{\n\tchar arr1[10] = \"abcde\";\n\tchar arr2[] = \"fghi\";\n\tstrncat(arr1, arr2, 3);\n\tprintf(\"%s\\n\", arr1);\n\treturn 0;\n}</code></pre>\n</div>\n<div>\n<p><img alt=\"\" height=\"77\" src=\"image\\247987aacf0b4b8e8d806a8868a1fdca.png\" width=\"529\"/>​</p>\n</div>\n<p>该函数追加完要求的字符后会自动追加一个零终止符保证追加完后的数据仍然是一个字符串 </p>\n</blockquote>\n<h2 id=\"3.4%20strncat%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0\">3.4 strncat的模拟实现</h2>\n<div>\n<blockquote>\n<pre><code>char * __cdecl strncat (\n        char * front,\n        const char * back,\n        size_t count\n        )\n{\n        char *start = front;\n\n        while (*front++)\n                ;\n        front--;\n\n        while (count--)\n                if ((*front++ = *back++) == 0)\n                        return(start);\n\n        *front = '\\0';\n        return(start);\n}\n</code></pre>\n</blockquote>\n</div>\n<h2 id=\"3.3strncmp\">3.5 strncmp</h2>\n<div>\n<pre><code>int strncmp ( const char * str1, const char * str2, size_t num );\n</code></pre>\n</div>\n<blockquote>\n<p style=\"margin-left:0;text-align:left;\"><strong><span style=\"background-color:#ffffff;\"><span style=\"color:#000000;\">功能：比较两个字符串的字符</span></span></strong></p>\n<p style=\"margin-left:0;text-align:left;\">将 C 字符串 str1 的数目与 C 字符串 str2 的数目进行比较<br/> 此函数开始比较每个字符串的第一个字符。如果它们彼此相等，则继续比较下一对，直到字符不同，直到达到终止空字符，或者直到两个字符串中的数字字符匹配，以先发生者为准</p>\n</blockquote>\n<div>\n<blockquote>\n<p><img alt=\"\" height=\"400\" src=\"image\\062a63d175794c11bf32e425dc14ff2f.png\" width=\"429\"/>​</p>\n<p></p>\n</blockquote>\n</div>\n<blockquote>\n<div>\n<pre><code>#define _CRT_SECURE_NO_WARNINGS\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\nint main()\n{\n\tchar arr1[] = \"abcde\";\n\tchar arr2[] = \"fghi\";\n\tint ret = strncmp(arr1, arr2, 3);\n\tprintf(\"%d\\n\", ret);\n\treturn 0;\n}</code></pre>\n</div>\n<div>\n<p><img alt=\"\" height=\"74\" src=\"image\\4d592bf81aa84690aac38cf119413487.png\" width=\"453\"/>​</p>\n</div>\n</blockquote>\n<h1 id=\"4.%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE\">4.字符串查找</h1>\n<h2 id=\"4.1strstr\">4.1 strstr</h2>\n<div>\n<pre><code>char* strstr ( const char* str1, const char* str2);</code></pre>\n</div>\n<blockquote>\n<p><strong>功能：</strong></p>\n<p><strong>查找子串的字符串函数</strong>，<strong><span style=\"background-color:#ffffff;\"><span style=\"color:#000000;\">返回指向 str1 中第一次出现的 str2 的指针，如果 str2 不是 str1 的一部分，则返回空指针</span></span></strong></p>\n<div>\n<p><img alt=\"\" height=\"363\" src=\"image\\0e074d26fa5444b99b01156b8d69ce53.png\" width=\"725\"/>​</p>\n</div>\n</blockquote>\n<blockquote>\n<div>\n<pre><code>#define _CRT_SECURE_NO_WARNINGS\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\nint main()\n{\n\tchar arr1[] = \"chencli\";\n\tchar arr2[] = \"enc\";\n\tchar* ret = strstr(arr1, arr2, 3);\n\tif (ret == NULL)\n\t\tprintf(\"字串不存在\");\n\telse\n\tprintf(\"找到字串为：%s\\n\", ret);\n\treturn 0;\n}</code></pre>\n</div>\n<div>\n<p><img alt=\"\" height=\"80\" src=\"image\\540db64cec03403bb9f1072bf3abfcdb.png\" width=\"433\"/>​</p>\n</div>\n<p></p>\n</blockquote>\n<h2 id=\"4.2%20strstr%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0\">4.2 strstr的模拟实现<br/>  </h2>\n<blockquote>\n<p>找字串有两种情况，如下图：</p>\n<div>\n<p><img alt=\"\" height=\"415\" src=\"image\\9eaa50f64cc642d2b9bc7a622040ba19.png\" width=\"584\"/>​</p>\n</div>\n<p> <strong>情况2中，bbc和bc需要多次匹配</strong></p>\n<p><strong>第一次比较：s1!=s2，p++，指向b,s1被赋值指向b，s2被复制为str2</strong></p>\n<p><strong>第二次比较：s1==s2相等，s1++,s2++</strong></p>\n<p><strong>第三次比较：s1!=s2，跳出while循环，p++,指向第二个b，s1被赋值指向第二个b；s2被赋值为str2</strong></p>\n<p><strong>第四次比较：s1==s2，s1++,s2++</strong></p>\n<p><strong>第五次比较：s1==s2，返回p，查找子串完成</strong></p>\n<div>\n<pre><code>#define _CRT_SECURE_NO_WARNINGS\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\nchar* my_strstr(const char* str1, const char* str2)\n{\n\tassert(str1 &amp;&amp; str2);\n\tconst char* s1 = str1;\n\tconst char* s2 = str2;\n\tconst char* p = str1;\n\n\twhile (*p)\n\t{\n\t\ts1 = p;\n\t\ts2 = str2;\n\t\twhile (*s1 != '\\0' &amp;&amp; *s2 != '\\0' &amp;&amp; *s1 == *s2)\n\t\t{\n\t\t\ts1++;\n\t\t\ts2++;\n\t\t}\n\t\tif (*s2 == '\\0')\n\t\t\treturn p;\n\t\tp++;\n\t}\n\treturn NULL;\n\n}</code></pre>\n</div>\n</blockquote>\n<h2 id=\"4.3%C2%A0strtok\">4.3 strtok</h2>\n<div>\n<pre><code>char* strtok ( char* str, const char* sep );</code></pre>\n</div>\n<blockquote>\n<p style=\"margin-left:0;text-align:justify;\"><span style=\"background-color:#38d8f0;\">sep参数是个字符串，定义了用作分隔符的字符集合</span></p>\n<p style=\"margin-left:0;text-align:justify;\">第一个参数指定一个字符串，它包含了0个或者多个由sep字符串中一个或者多个分隔符分割的标记</p>\n<p style=\"margin-left:0;text-align:justify;\">strtok函数找到str中的下一个标记，并将其用\\0结尾，返回一个指向这个标记的指针（注：strtok函数会改变被操作的字符串，所以在使用strtok函数<span style=\"background-color:#38d8f0;\">切分的字符串一般都是临时拷贝的内容并且可修改</span>）</p>\n<p style=\"margin-left:0;text-align:justify;\">strtok函数的<span style=\"background-color:#38d8f0;\">第一个参数不为NULL</span>，函数将找到str中第一个标记，strtok函数将保存它在字符串中的位置</p>\n<p style=\"margin-left:0;text-align:justify;\">strtok函数的<span style=\"background-color:#38d8f0;\">第一个参数为NULL</span>，函数将在同一个字符串中被保存的位置开始，查找下一个标记</p>\n<p style=\"margin-left:0;text-align:justify;\"><span style=\"background-color:#38d8f0;\">如果字符串中不存在更多的标记，则返回NULL指针</span></p>\n</blockquote>\n<blockquote>\n<div>\n<pre><code>#define _CRT_SECURE_NO_WARNINGS\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\nint main()\n{\n\tconst char* sep = \"@.\";\n\tchar email[] = \"1234567@qq.com\";\n\tchar cp[30] = { 0 };\n\t\n\n    strcpy(cp, email);//strtok函数找到str中的下一个标记，并将其用\\0结尾，返回一个指向这个标记的指针\n\t//（注：strtok函数会改变被操作的字符串，所以在使用strtok函数切分的字符串一般都是临时拷贝的内容并且可修改。）\n\t\n\n    char* ret = strtok(cp, sep);//strtok函数的第一个参数不为NULL，函数将找到str中第一个标记，strtok函数将保存它在字符串中的位置\n\tprintf(\"%s\\n\", ret);\n\t\n\n    ret = strtok(NULL, sep);//strtok函数的第一个参数为NULL，函数将在同一个字符串中被保存的位置开始，查找下一个标记\n\tprintf(\"%s\\n\", ret);\n\n\n\tret = strtok(NULL, sep);\n\tprintf(\"%s\\n\", ret);//如果字符串中不存在更多的标记，则返回NULL指针\n\n\treturn 0;\n}</code></pre>\n</div>\n<div>\n<p><img alt=\"\" height=\"115\" src=\"image\\ff9a9341c3b040299c85b9f494a88fcd.png\" width=\"546\"/>​</p>\n</div>\n</blockquote>\n<h1 id=\"5.%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%E6%8A%A5%E5%91%8A\">5.错误信息报告</h1>\n<h2 id=\"strerror\">5.1strerror</h2>\n<div>\n<pre><code>char* strerror ( int errnum );</code></pre>\n</div>\n<blockquote>\n<p>功能：</p>\n<p>返回错误码，所对应的错误信息</p>\n<p>C语言的库函数执行失败的时候都会设置错误码</p>\n<div>\n<pre><code>#define _CRT_SECURE_NO_WARNINGS\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\nint main()\n{\n\tprintf(\"%s\\n\", strerror(0));\n\tprintf(\"%s\\n\", strerror(1));\n\tprintf(\"%s\\n\", strerror(2));\n\tprintf(\"%s\\n\", strerror(3));\n\tprintf(\"%s\\n\", strerror(4));\n\n\treturn 0;\n}</code></pre>\n</div>\n<div>\n<p><img alt=\"\" height=\"152\" src=\"image\\78db325a3b604e0e973cebbec6eb1f96.png\" width=\"511\"/>​</p>\n</div>\n</blockquote>\n<blockquote>\n<div>\n<pre><code>#define _CRT_SECURE_NO_WARNINGS\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\nint main()\n{\n\t\n\tFILE* pf = fopen(\"test.text\", \"r\");\n\tif (pf == NULL)\n\t{\n\t\tprintf(\"%s\\n\", strerror(errno));\n\t\treturn 1;\n\t}\n\telse\n\t{\n\t\t//\n\t}\n\treturn 0;\n}</code></pre>\n</div>\n<div>\n<p><img alt=\"\" height=\"71\" src=\"image\\bb226a5bac854e29b0222914398b9f42.png\" width=\"482\"/>​</p>\n</div>\n<p></p>\n<p><strong>errno是c语言设置的一个全局的错误码存放的变量</strong></p>\n<p><strong>当没有test.txt被读时，errno就会更新</strong></p>\n</blockquote>\n<h1 id=\"6.%E5%AD%97%E7%AC%A6%E6%93%8D%E4%BD%9C%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0\">6.内存操作函数</h1>\n<h2 id=\"6.1memcpy\">6.1 memcpy</h2>\n<div>\n<pre><code>void* memcpy ( void* destination, const void* source, size_t num );</code></pre>\n</div>\n<blockquote>\n<p><strong>功能：</strong></p>\n<div style=\"margin-left:0;\">\n<p style=\"margin-left:0;text-align:left;\"><strong><span style=\"background-color:#ffffff;\"><span style=\"color:#000000;\">复制内存块</span></span></strong></p>\n<p><strong>将 num 字节值从源指向的位置直接复制到目标指向的内存块<br/> 源指针和目标指针所指向的对象的基础类型与此函数无关</strong></p>\n<p><strong>结果是数据的二进制副本<br/> 该函数不检查源中是否有任何终止空字符 - 它<span style=\"background-color:#38d8f0;\">始终精确地复制数字字节</span></strong></p>\n</div>\n<p><strong>注意事项：</strong></p>\n<p><strong>函数memcpy从source的位置开始向后复制num个字节的数据到destination的内存位置</strong></p>\n<p><strong>这个函数在<span style=\"background-color:#38d8f0;\">遇到'\\0'的时候并不会停下来</span></strong></p>\n<p><strong>如果source和destination有任何的重叠，复制的结果都是未定义的，为避免溢出，目标参数和源参数所指向的数组的大小应至少为 num 个字节，<span style=\"background-color:#38d8f0;\">并且不应重叠（对于重叠的内存块，<a href=\"https://cplusplus.com/memmove\" title=\"memmove\">memmove</a> 是一种更安全的方法）</span></strong></p>\n</blockquote>\n<h2 id=\"6.2memmove\">6.2 memcpy的模拟实现</h2>\n<blockquote>\n<div>\n<pre><code>#define _CRT_SECURE_NO_WARNINGS\n#include&lt;stdio.h&gt;\n#include&lt;assert.h&gt;\n\nvoid* my_memcpy(void* dest,const void* src, size_t num)\n{\n\tassert(dest &amp;&amp; src);\n\tvoid* ret = dest;\n\n\twhile (num--)\n\t{\n\t\t*(char*)dest = *(char*)src;\n\t\tdest = (char*)dest + 1;\n\t\tsrc = (char*)src + 1;\n\t}\n\treturn ret;\n}\nint main()\n{\n\tchar arr1[100] = \"abcdef\";\n\tchar arr2[100] = { 0 };\n\tmy_memcpy(arr2, arr1,5);\n\tprintf(\"%s\\n\", arr2);\n\treturn 0;\n}</code></pre>\n</div>\n<div>\n<p><img alt=\"\" height=\"81\" src=\"image\\e091e181750244d1aee454b6a23168b9.png\" width=\"505\"/>​</p>\n</div>\n<p> 函数参数的类型是void*型的，因此可以复制不同元素类型的数组</p>\n<p><span style=\"background-color:#38d8f0;\">该函数不能用于内存空间上有重叠的数据</span></p>\n</blockquote>\n<h2 id=\"6.3%C2%A0memmove\">6.3 memmove</h2>\n<div>\n<pre><code>void* memmove ( void* destination, const void* source, size_t num );</code></pre>\n</div>\n<blockquote>\n<p><strong>功能：</strong></p>\n<p><strong>和memcpy的差别就是memmove函数处理的<span style=\"background-color:#38d8f0;\">源内存块和目标内存块是可以重叠的</span></strong></p>\n<p><strong>如果源空间和目标空间出现重叠，就得使用memmove函数处理</strong></p>\n</blockquote>\n<h2 id=\"6.4%20memmove%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0\">6.4 memmove的模拟实现</h2>\n<blockquote>\n<p><strong>当需要处理的数据空间上有重叠时，往往有时候需要从前往后拷贝，有时候从后往前拷贝</strong></p>\n<p><strong>分析如图：</strong></p>\n<p><strong>dest&lt;src和dest&gt;src</strong></p>\n<p><img alt=\"\" height=\"413\" src=\"image\\9a02e5b171994fcab23da0816888b7a3.png\" width=\"715\"/>​</p>\n<div>\n<pre><code>void* my_memmove(void* dest, const void* src, size_t num)\n{\n\tassert(dest &amp;&amp; src);\n\tvoid* ret = dest;\n\tif (dest &lt; src)\n\t{\n\t\t//前向后拷贝\n\t\twhile(num--)\n\t\t{\n\t\t\t*(char*)dest = *(char*)src;\n\t\t\tdest = (char*)dest + 1;\n\t\t\tsrc = (char*)src + 1;\n\t\t}\n\t}\n\telse\n\t{\n\t\t//后向前拷贝\n\t\twhile(num--)\n\t\t{\n\t\t\t*((char*)dest + num) = *((char*)src + num);\n\t\t}\n\t}\n}</code></pre>\n</div>\n</blockquote>\n<h2 id=\"6.3memset\">6.5 memset</h2>\n<blockquote>\n<p><strong>功能：</strong></p>\n<div style=\"margin-left:0;\">\n<strong><span style=\"color:#000000;\"><span style=\"background-color:#ffffff;\">填充内存块</span></span></strong>\n</div>\n<p><strong>将 <em>ptr</em> 所指向的内存<em>块的前一</em>个字节数设置为指定<em>值</em>（解释为无符号字符）</strong></p>\n<p><img alt=\"\" height=\"310\" src=\"image\\7091bca12deb49f9ae4e9560169e9814.png\" width=\"695\"/>​</p>\n<p></p>\n<div>\n<pre><code>#define _CRT_SECURE_NO_WARNINGS\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\nint main()\n{\n\tchar arr[] = \"hello world\";\n\tmemset(arr + 6, 'x', 3);\n\tprintf(\"%s\\n\", arr);\n\treturn 0;\n}</code></pre>\n</div>\n<div>\n<p><img alt=\"\" height=\"74\" src=\"image\\5054396d556f4a5bbf151296832dc25f.png\" width=\"400\"/>​</p>\n</div>\n</blockquote>\n<h2 id=\"6.4memcmp\">6.6 memcmp</h2>\n<blockquote>\n<p style=\"margin-left:0;text-align:left;\"><strong><span style=\"background-color:#ffffff;\"><span style=\"color:#000000;\">功能：</span></span></strong></p>\n<p style=\"margin-left:0;text-align:left;\"><strong><span style=\"background-color:#ffffff;\"><span style=\"color:#000000;\">比较两个内存块</span></span></strong></p>\n<p style=\"margin-left:0;text-align:justify;\"><strong>将 ptr1 所指向的内存块的前 num 个字节与 ptr2 指向的第一个字节数进行比较，如果它们都匹配，则返回零，或者如果不匹配，则返回与零不同的值，表示哪个值更大<br/><span style=\"background-color:#38d8f0;\">请注意，与 <a href=\"https://cplusplus.com/strcmp\" title=\"strcmp\">strcmp</a> 不同，该函数在找到空字符后不会停止比较</span></strong></p>\n<div>\n<p><img alt=\"\" height=\"386\" src=\"image\\da9a0c3da5ba43ac992b3afea94d1949.png\" width=\"750\"/>​</p>\n</div>\n</blockquote>\n<blockquote>\n<p><strong><span style=\"background-color:#f3f3f4;\">该组内存操作函数和字符串操作函数不同在于字符串操作函数只能作用于字符串，该内存操作函数可以作用于任意类型的数据</span></strong></p>\n</blockquote>\n<p></p>\n<p></p>\n<p></p>\n</div>\n</div>"}