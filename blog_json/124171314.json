{"blogid": "124171314", "writerAge": "码龄3年", "writerBlogNum": "13", "writerCollect": "13", "writerComment": "7", "writerFan": "2", "writerGrade": "2级", "writerIntegral": "144", "writerName": "东方萝卜", "writerProfileAdress": "writer_image\\profile_124171314.jpg", "writerRankTotal": "88325", "writerRankWeekly": "557514", "writerThumb": "9", "writerVisitNum": "7404", "blog_read_count": "3935", "blog_time": "已于 2022-07-22 17:46:31 修改", "blog_title": "js几种继承", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<blockquote>\n<p>提示：主要是原型链继承、构造函数继承、原型链加构造函数继承、寄生组合式继承</p>\n</blockquote>\n<hr/>\n<p></p>\n<h1><a id=\"pandas_16\"></a>一、原型链继承</h1>\n<p>子类想要继承父类的属性和方法，可以将其原型对象指向父类的实例，根据原型链就可以使用到父类的方法和属性</p>\n<pre><code class=\"language-javascript\">    // 父类\n    function Parent() {\n      this.name = ['父类']\n      this.introduce = function () {\n        console.log(\"my name is\" + this.name)\n      }\n    }\n    // 子类\n    function Child() {\n      this.childname = ['子类']\n    }\n\n    // 核心代码：\n    Child.prototype = new Parent()\n    var child1 = new Child()\n    console.log(child1)</code></pre>\n<h1>  输出的结果：</h1>\n<h1>                <img alt=\"\" height=\"158\" src=\"image\\3a8c908ae8e44b5aa2f0738a98d6f3ad.png\" width=\"398\"/></h1>\n<p></p>\n<p> child已经继承了父类的方法，但是缺点就是多个子类实例对父类引用类型的操作会被纂改，无法保持子类实例的个性。如：</p>\n<pre><code class=\"language-javascript\">    var child1 = new Child()\n    child1.name[0] = 'child1唱歌'\n    var child2 = new Child()\n    child2.name[0] = 'child2跳舞'\n    console.log(child1.name);\n    console.log(child2.name);</code></pre>\n<p>输出结果：</p>\n<p>         <img alt=\"\" height=\"81\" src=\"image\\4667c332b1304d18a6ed06c8b7228950.png\" width=\"201\"/></p>\n<p> child1和child2继承的父类的name属性是一个数组，对其操作时更改会互相影响。</p>\n<hr/>\n<h1>二、构造函数继承</h1>\n<p>在子类的构造函数中，执行父类的构造函数，并且为其绑定子类的this</p>\n<pre><code class=\"language-javascript\">    // 父类\n    function Parent() {\n      this.name = ['父类']\n      this.introduce = function () {\n        console.log(\"父类上的introduce方法\")\n      }\n    }\n    Parent.prototype.sayhi = function () {\n      console.log('父类原型上的sayhi方法');\n    }\n    // 子类\n    function Child() {\n      this.childname = ['子类']\n      Parent.call(this)\n    }\n\n    var child1 = new Child()\n    child1.introduce()\n    child1.sayhi()</code></pre>\n<p>上述代码的结果是：</p>\n<p>         <img alt=\"\" height=\"98\" src=\"image\\73348b60794646d8befd7d4eab8774b5.png\" width=\"595\"/></p>\n<p> 构造函数继承可以继承到父类上的属性和方法，但是继承不到父类原型上的属性和方法</p>\n<hr/>\n<h1></h1>\n<h1>三、原型链加构造函数继承</h1>\n<pre><code class=\"language-javascript\">    // 父类\n    function Parent() {\n      this.name = ['父类']\n      this.introduce = function () {\n        console.log(\"父类上的introduce方法\")\n      }\n    }\n    Parent.prototype.sayhi = function () {\n      console.log('父类原型上的sayhi方法');\n    }\n    // 子类\n    function Child() {\n      this.childname = ['子类']\n      Parent.call(this) // 第二次调用Parent\n    }\n\n    Child.prototype = new Parent() // 第一次调用Parent\n\n    var child1 = new Child()\n    console.log(child1);</code></pre>\n<p>输出结果：</p>\n<p>         <img alt=\"\" height=\"273\" src=\"image\\dd5938e0c9e546ad82bb67c46ab2f536.png\" width=\"730\"/></p>\n<p> 第一次调用Parent(),在Child.prototype写入了父类的name和introduce属性和方法，第二次再调用Parent（）， 给实例child1又写入了name和introduce属性和方法。实例child1上的name和introduce屏蔽了原型对象Parent.prototype的两个同名属性，所以组合模式的缺点就在使用子类创建实例对象的时候，其原型中会存在两份相同的属性和方法.</p>\n<hr/>\n<h1> 四、原型式继承</h1>\n<p>利用一个空对象作为中介、将某个对象直接赋值给空对象构造函数的原型，其实就是使用Object.create()</p>\n<pre><code class=\"language-javascript\">    var Parent = {\n      name: ['父类属性'],\n      sayhi: function () {\n        console.log(this.name);\n      }\n    }\n\n    var child1 = Object.create(Parent)\n    var child2 = Object.create(Parent)\n    child1.name[0] = 'child1属性'\n    child2.name[0] = 'child2属性'\n    console.log(child1);</code></pre>\n<p><img alt=\"\" height=\"143\" src=\"image\\d8e223e372764b2eb2d396131960fa93.png\" width=\"387\"/></p>\n<p></p>\n<p>缺点：跟原型链继承一样，多个子类实例的引用类型属性指向相同，可能会纂改。 </p>\n<hr/>\n<h1>五、寄生组合式继承</h1>\n<pre><code class=\"language-javascript\">     // 父类\n    function Parent() {\n      this.name = ['父类']\n      this.introduce = function () {\n        console.log(\"父类上的introduce方法\")\n      }\n    }\n    Parent.prototype.sayhi = function () {\n      console.log('父类原型上的sayhi方法');\n    }\n    // 子类\n    function Child() {\n      this.childname = ['子类']\n      Parent.call(this) // 核心代码\n    }\n    Child.prototype = Object.create(Parent.prototype) // 核心代码\n\n    const child1 = new Child()\n    const child2 = new Child()\n    child1.name[0] = 'child1'\n    child2.name[0] = 'child2'\n    console.log(child1);\n    console.log(child1.name);\n    console.log(child2.name);</code></pre>\n<p><img alt=\"\" height=\"308\" src=\"image\\b26fd1023b964b05b52cc6b374c222fc.png\" width=\"727\"/></p>\n<p> 完美解决原型链加构造函数继承的缺点</p>\n<p>mark一下，明天接着写</p>\n</div>\n</div>"}