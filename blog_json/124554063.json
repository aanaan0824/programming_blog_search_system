{"blogid": "124554063", "writerAge": "None", "writerBlogNum": "48", "writerCollect": "1430", "writerComment": "418", "writerFan": "246", "writerGrade": "5级", "writerIntegral": "3834", "writerName": "用户体验官大龙", "writerProfileAdress": "writer_image\\profile_124554063.jpg", "writerRankTotal": "8431", "writerRankWeekly": "42169", "writerThumb": "475", "writerVisitNum": "573926", "blog_read_count": "3973", "blog_time": "已于 2022-07-07 11:46:39 修改", "blog_title": "Vue3.2单文件组件setup的语法糖总结", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E5%89%8D%E8%A8%80-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%89%8D%E8%A8%80\">前言</a></p>\n<p id=\"setup%E8%AF%AD%E6%B3%95%E7%B3%96-toc\" style=\"margin-left:0px;\"><a href=\"#setup%E8%AF%AD%E6%B3%95%E7%B3%96\">setup语法糖</a></p>\n<p id=\"%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95\">一、基本用法</a></p>\n<p id=\"%E5%8F%98%E9%87%8F%E5%92%8C%E6%96%B9%E6%B3%95%E4%B8%8D%E9%9C%80%E8%A6%81return-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%8F%98%E9%87%8F%E5%92%8C%E6%96%B9%E6%B3%95%E4%B8%8D%E9%9C%80%E8%A6%81return\">二、data和methods</a></p>\n<p id=\"%E4%B8%89%E3%80%81%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7computed-toc\" style=\"margin-left:40px;\"><a href=\"#%E4%B8%89%E3%80%81%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7computed\">三、计算属性computed</a></p>\n<p id=\"%E5%9B%9B%E3%80%81%E7%9B%91%E5%90%AC%E5%99%A8watch%E3%80%81watchEffect-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%9B%9B%E3%80%81%E7%9B%91%E5%90%AC%E5%99%A8watch%E3%80%81watchEffect\">四、监听器watch、watchEffect</a></p>\n<p id=\"%E4%BA%94%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4directive-toc\" style=\"margin-left:40px;\"><a href=\"#%E4%BA%94%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4directive\">五、自定义指令directive</a></p>\n<p id=\"import%E5%AF%BC%E5%85%A5%E7%9A%84%E5%86%85%E5%AE%B9%E5%8F%AF%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8-toc\" style=\"margin-left:40px;\"><a href=\"#import%E5%AF%BC%E5%85%A5%E7%9A%84%E5%86%85%E5%AE%B9%E5%8F%AF%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8\">六、import导入的内容可直接使用</a></p>\n<p id=\"%E5%A3%B0%E6%98%8Eprops%E5%92%8Cemits%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%A3%B0%E6%98%8Eprops%E5%92%8Cemits%C2%A0\">七、声明props和emits </a></p>\n<p id=\"%E7%88%B6%E7%BB%84%E4%BB%B6%E8%8E%B7%E5%8F%96%E5%AD%90%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B0%E6%8D%AE-toc\" style=\"margin-left:40px;\"><a href=\"#%E7%88%B6%E7%BB%84%E4%BB%B6%E8%8E%B7%E5%8F%96%E5%AD%90%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B0%E6%8D%AE\">八、父组件获取子组件的数据</a></p>\n<p id=\"%C2%A0provide%E5%92%8Cinject%E4%BC%A0%E5%80%BC-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A0provide%E5%92%8Cinject%E4%BC%A0%E5%80%BC\"> 九、provide和inject传值</a></p>\n<p id=\"%E5%8D%81%E3%80%81%E8%B7%AF%E7%94%B1useRoute%E5%92%8CuseRouter-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%8D%81%E3%80%81%E8%B7%AF%E7%94%B1useRoute%E5%92%8CuseRouter\">十、路由useRoute和useRouter</a></p>\n<p id=\"使用自定义指令-toc\" style=\"margin-left:40px;\"><a href=\"#%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4\">十一、对await异步的支持</a></p>\n<p id=\"%E5%8D%81%E4%BA%8C%E3%80%81nextTick-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%8D%81%E4%BA%8C%E3%80%81nextTick\">十二、nextTick</a></p>\n<p id=\"%E5%8D%81%E4%B8%89%E3%80%81%E5%85%A8%E5%B1%80%E5%B1%9E%E6%80%A7globalProperties-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%8D%81%E4%B8%89%E3%80%81%E5%85%A8%E5%B1%80%E5%B1%9E%E6%80%A7globalProperties\">十三、全局属性globalProperties</a></p>\n<p id=\"%E5%8D%81%E5%9B%9B%E3%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%8D%81%E5%9B%9B%E3%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F\">十四、生命周期</a></p>\n<p id=\"%E5%8D%81%E4%BA%94%E3%80%81%E4%B8%8E%E6%99%AE%E9%80%9A%E7%9A%84script%E6%A0%87%E7%AD%BE%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%8D%81%E4%BA%94%E3%80%81%E4%B8%8E%E6%99%AE%E9%80%9A%E7%9A%84script%E6%A0%87%E7%AD%BE%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8\">十五、与普通的script标签一起使用</a></p>\n<p id=\"%E5%8D%81%E5%85%AD%E3%80%81v-memo%E6%96%B0%E6%8C%87%E4%BB%A4-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%8D%81%E5%85%AD%E3%80%81v-memo%E6%96%B0%E6%8C%87%E4%BB%A4\">十六、v-memo新指令</a></p>\n<p id=\"style%E6%96%B0%E7%89%B9%E6%80%A7-toc\" style=\"margin-left:0px;\"><a href=\"#style%E6%96%B0%E7%89%B9%E6%80%A7\">style新特性</a></p>\n<p id=\"%E5%B1%80%E9%83%A8%E6%A0%B7%E5%BC%8F-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%B1%80%E9%83%A8%E6%A0%B7%E5%BC%8F\">一、局部样式</a></p>\n<p id=\"%E6%B7%B1%E5%BA%A6%E9%80%89%E6%8B%A9%E5%99%A8-toc\" style=\"margin-left:40px;\"><a href=\"#%E6%B7%B1%E5%BA%A6%E9%80%89%E6%8B%A9%E5%99%A8\">二、深度选择器</a></p>\n<p id=\"插槽选择器-toc\" style=\"margin-left:40px;\"><a href=\"#%E6%8F%92%E6%A7%BD%E9%80%89%E6%8B%A9%E5%99%A8\">三、插槽选择器</a></p>\n<p id=\"全局选择器-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%85%A8%E5%B1%80%E9%80%89%E6%8B%A9%E5%99%A8\">四、全局选择器</a></p>\n<p id=\"混合使用局部与全局样式-toc\" style=\"margin-left:40px;\"><a href=\"#%E6%B7%B7%E5%90%88%E4%BD%BF%E7%94%A8%E5%B1%80%E9%83%A8%E4%B8%8E%E5%85%A8%E5%B1%80%E6%A0%B7%E5%BC%8F\">五、混合使用局部与全局样式</a></p>\n<p id=\"%E6%94%AF%E6%8C%81CSS%C2%A0Modules-toc\" style=\"margin-left:40px;\"><a href=\"#%E6%94%AF%E6%8C%81CSS%C2%A0Modules\">六、支持CSS Modules</a></p>\n<p id=\"%E4%B8%8Esetup%E4%B8%80%E5%90%8C%E4%BD%BF%E7%94%A8-toc\" style=\"margin-left:40px;\"><a href=\"#%E4%B8%8Esetup%E4%B8%80%E5%90%8C%E4%BD%BF%E7%94%A8\">七、与setup一同使用</a></p>\n<p id=\"状态驱动的动态-css-toc\" style=\"margin-left:40px;\"><a href=\"#%E7%8A%B6%E6%80%81%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%8A%A8%E6%80%81-css\">八、动态 CSS</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h1>前言</h1>\n<p>        <span style=\"color:#fe2c24;\">满满的干货，建议收藏慢慢看，可以当作Vue3.0的学习资料。</span></p>\n<p>        在vue2.0时期，组件里定义的各类变量、方法、计算属性等是分别存放到data、methods、computed...选项里，这样编写的代码不便于后期的查阅（查找一个业务逻辑需要在各个选项来回切换）。setup函数的推出就是为了解决这个问题，让新手开发者更容易上手...</p>\n<h1 id=\"setup%E8%AF%AD%E6%B3%95%E7%B3%96\">setup语法糖</h1>\n<p>        setup是Vue3.0后推出的语法糖，并且在Vue3.2版本进行了大更新，像写普通JS一样写vue组件，对于开发者更加友好了；按需引入computed、watch、directive等选项，一个业务逻辑可以集中编写在一起，让代码更加简洁便于浏览。</p>\n<h2 id=\"%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95\">一、基本用法</h2>\n<p>只需在&lt;script&gt;里添加一个setup属性，编译时会把&lt;script setup&gt;&lt;/script&gt;里的代码编译成一个setup函数</p>\n<pre><code>&lt;script setup&gt;\nconsole.log('hello script setup')\n&lt;/script&gt;</code></pre>\n<p>普通的&lt;script&gt;只会在组件被首次引入的时候执行一次，<span style=\"color:#fe2c24;\">&lt;script setup&gt;里的代码会在每次组件实例被创建的时候执行</span><strong>。</strong></p>\n<h2 id=\"%E5%8F%98%E9%87%8F%E5%92%8C%E6%96%B9%E6%B3%95%E4%B8%8D%E9%9C%80%E8%A6%81return\">二、data和methods</h2>\n<p>&lt;script setup&gt;里声明的变量和函数，不需要return暴露出去，就可以直接在template使用</p>\n<pre><code>&lt;script setup&gt;\nimport { ref, reactive } from 'vue'    \n// 普通变量\nconst msg = 'Hello!'\n\n// 响应式变量\nlet num = ref(1111)         // ref声明基本类型变量\nconst obj = reactive({        // reactive声明对象类型变量，如Object、Array、Date...\n    key: 'this is a object'\n})\n\n// 函数\nfunction log() {\n    console.log(msg)          // Hello\n    console.log(num.value)    // 1111（可根据input输入值而改变）\n    console.log(obj.key)      // this is a object\n}\n&lt;/script&gt;\n\n&lt;template&gt;\n    &lt;h1&gt;{<!-- -->{ msg }}&lt;/h1&gt;\n    &lt;p&gt;{<!-- -->{obj.key}}&lt;/p&gt;\n    &lt;input v-model=\"num\" type=\"text\" /&gt;\n    &lt;button @click=\"log\"&gt;打印日志&lt;/button&gt;\n&lt;/template&gt;</code></pre>\n<h2 id=\"%E4%B8%89%E3%80%81%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7computed\">三、计算属性computed</h2>\n<pre><code>&lt;script setup&gt;\nimport { ref, computed } from 'vue'\n\nlet count = ref(0)\nconst countPlus = computed(()=&gt;{\n    return count.value+1\n})\n&lt;/script&gt;\n\n&lt;template&gt;\n    &lt;h1&gt;计数：{<!-- -->{ countPlus }}&lt;/h1&gt;\n&lt;/template&gt;</code></pre>\n<h2 id=\"%E5%9B%9B%E3%80%81%E7%9B%91%E5%90%AC%E5%99%A8watch%E3%80%81watchEffect\">四、监听器watch、watchEffect</h2>\n<p>1、watch监听器除了使用方式有区别之外，其他的与vue2.0没啥变化</p>\n<pre><code>&lt;script setup&gt;\nimport { ref, reactive, watch } from 'vue'\n\n// 监听ref\nlet count = ref(0)\nwatch(count, (newVal, oldVal)=&gt; {\n    console.log('修改后', newVal)\n    console.log('修改前', oldVal)\n})\n\n// 监听reactive属性\nconst obj = reactive({\n    count: 0\n})\nwatch(\n    ()=&gt; obj.count,     // 一个函数，返回监听属性\n    (newVal, oldVal)=&gt; {\n        console.log('修改后', newVal)\n        console.log('修改前', oldVal)\n    },\n    {\n        immediate: true,     // 立即执行，默认为false\n        deep: true     // 深度监听，默认为false\n    }\n)\n\nconst onChange = function(){\n    count.value++\n    obj.count++\n}\n&lt;/script&gt;\n\n&lt;template&gt;\n    &lt;button @click=\"onChange\"&gt;改变count&lt;/button&gt;\n&lt;/template&gt;</code></pre>\n<p>2、watchEffect</p>\n<p>watchEffect是Vue3.0新增的一个监听属性的方法，它与watch的区别在于watchEffect不需要指定监听对象，回调函数里可直接获取到修改后的属性的值</p>\n<pre><code>&lt;script setup&gt;\nimport { ref, reactive, watchEffect } from 'vue'\n\nlet count = ref(0)\nconst obj = reactive({\n    count: 0\n})\nsetTimeout(()=&gt;{\n    count.value++\n    obj.count++\n}, 1000)\n\nwatchEffect(()=&gt; {\n    console.log('修改后的count', count.value)\n    console.log('修改前的obj', obj.value)\n})\n&lt;/script&gt;</code></pre>\n<h2 id=\"%E4%BA%94%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4directive\">五、自定义指令directive</h2>\n<p>以 <code>vNameOfDirective</code> 的形式来命名本地自定义指令，可以直接在模板中使用</p>\n<pre><code>&lt;script setup&gt;\n// 导入指令可重命名\n// import { myDirective as vMyDirective } from './MyDirective.js'\n\n// 自定义指令\nconst vMyDirective = {\n  beforeMount: (el) =&gt; {\n    // 在元素上做些操作\n  }\n}\n&lt;/script&gt;\n&lt;template&gt;\n  &lt;h1 v-my-directive&gt;This is a Heading&lt;/h1&gt;\n&lt;/template&gt;</code></pre>\n<h2 id=\"import%E5%AF%BC%E5%85%A5%E7%9A%84%E5%86%85%E5%AE%B9%E5%8F%AF%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8\">六、import导入的内容可直接使用</h2>\n<p> 1、导入的模块内容，不需要通过 <code>methods</code> 来暴露它</p>\n<pre><code>// utils.js \nexport const onShow = function(name) {\n    return 'my name is ' + name\n}</code></pre>\n<pre><code>// Show.vue\n&lt;script setup&gt;\n    import { onShow } from './utils.js'\n&lt;/script&gt;\n&lt;template&gt;\n    &lt;div&gt;{<!-- -->{ onShow('jack') }}&lt;/div&gt;\n&lt;/template&gt;</code></pre>\n<p> 2、<span style=\"color:#fe2c24;\"><strong>导入外部组件，不需要通过components注册使用</strong></span></p>\n<pre><code>// Child.vue\n&lt;template&gt;\n    &lt;div&gt;I am a child&lt;/div&gt;\n&lt;/template&gt;</code></pre>\n<pre><code>// Parent.vue\n&lt;script setup&gt;\n    import Child from './Child.vue'\n&lt;/script&gt;\n&lt;template&gt;\n    &lt;child&gt;&lt;/child&gt;\n&lt;/template&gt;</code></pre>\n<h2 id=\"%E5%A3%B0%E6%98%8Eprops%E5%92%8Cemits%C2%A0\">七、声明props和emits </h2>\n<p>在 <code>&lt;script setup&gt;</code> 中必须使用 <code>defineProps</code> 和 <code>defineEmits</code> API 来声明 <code>props</code> 和 <code>emits</code> ，它们具备完整的类型推断并且在 <code>&lt;script setup&gt;</code> 中是直接可用的</p>\n<pre><code>// Child.vue\n&lt;script setup&gt;\n\n// 声明props\nconst props = defineProps({\n    info: {\n        type: String,\n        default: ''\n    }\n})\n\n// 声明emits\nconst $emit = defineEmits(['change'])\n\nconst onChange = function() {\n    $emit('change', 'child返回值')\n}\n&lt;/script&gt;\n\n&lt;template&gt;\n    &lt;h1&gt;信息：{<!-- -->{ info }}&lt;/h1&gt;\n    &lt;button @click=\"onChange\"&gt;点击我&lt;/button&gt;\n&lt;/template&gt;</code></pre>\n<pre><code>// Parent.vue\n&lt;script setup&gt;\nimport { ref } from 'vue'\nimport Child from './Child.vue'\n\nconst msg = ref('hello setup !')    // 响应式变量\n\nconst onAction = function(event) {\n    console.log(event)    // child返回值\n}\n&lt;/script&gt;\n\n&lt;template&gt;\n    &lt;child :info=\"msg\" @change=\"onAction\"&gt;&lt;/child&gt;\n&lt;/template&gt;</code></pre>\n<p>如果使用了 Typescript，<a href=\"https://v3.cn.vuejs.org/api/sfc-script-setup.html#%E4%BB%85%E9%99%90-typescript-%E7%9A%84%E5%8A%9F%E8%83%BD\" title=\"使用纯类型声明来声明 prop 和 emits\">使用纯类型声明来声明 prop 和 emits</a> 也是可以的。</p>\n<h2 id=\"%E7%88%B6%E7%BB%84%E4%BB%B6%E8%8E%B7%E5%8F%96%E5%AD%90%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B0%E6%8D%AE\">八、父组件获取子组件的数据</h2>\n<p>父组件要想通过ref获取子组件的变量或函数，子组件须使用<span style=\"color:#fe2c24;\"><strong>defineExpose</strong></span>暴露出去</p>\n<pre><code>// Child.vue\n&lt;script setup&gt;\nimport { ref, defineExpose } from 'vue'\n\nconst info = ref('I am child')\nconst onChange = function() {\n    console.log('Function of child')\n}\n\n// 暴露属性\ndefineExpose({\n    info,\n    onChange\n})\n&lt;/script&gt;\n\n&lt;template&gt;\n    &lt;h1&gt;信息：{<!-- -->{ info }}&lt;/h1&gt;\n    &lt;button @click=\"onChange\"&gt;点击我&lt;/button&gt;\n&lt;/template&gt;</code></pre>\n<pre><code>// Parent.vue\n&lt;script setup&gt;\nimport { ref } from 'vue'\nimport Child from './Child.vue'\n\nconst childRef = ref()\nconst onAction = function() {\n    console.log(childRef.value.info)    // I am child\n    console.log(childRef.value.onChange())    // Function of child\n}\n&lt;/script&gt;\n\n&lt;template&gt;\n    &lt;child ref=\"childRef\"&gt;&lt;/child&gt;\n    &lt;button @click=\"onAction\"&gt;获取子值&lt;/button&gt;\n&lt;/template&gt;</code></pre>\n<h2 id=\"%C2%A0provide%E5%92%8Cinject%E4%BC%A0%E5%80%BC\"> 九、provide和inject传值</h2>\n<p>无论组件层次结构有多深，父组件都可以通过<span style=\"color:#fe2c24;\"><strong><code>provide</code></strong></span> 选项来其所有子组件提供数据，子组件通过<span style=\"color:#fe2c24;\"><strong>inject</strong></span>接收数据</p>\n<pre><code>// Parent.vue\n&lt;script setup&gt;\nimport { ref, provide } from 'vue'\nimport Child from './Child.vue'\n\nconst msg = ref('Hello, my son')\nconst onShow = function() {\n    console.log('I am your parent')\n}\n\nprovide('myProvide', {\n    msg,\n    onShow\n})\n&lt;/script&gt;\n\n&lt;template&gt;\n    &lt;child&gt;&lt;/child&gt;\n&lt;/template&gt;</code></pre>\n<pre><code>// Child.vue\n&lt;script setup&gt;\nimport { inject } from 'vue'\n\nconst provideState = inject('myProvide')    // 接收参数\n\nconst getData = function() {\n    console.log(provideState.msg)    // Hello, my son\n    console.log(provideState.onShow())    // I am your parent\n}\n&lt;/script&gt;\n\n&lt;template&gt;\n    &lt;button @click=\"getData\"&gt;获取父值&lt;/button&gt;\n&lt;/template&gt;</code></pre>\n<h2 id=\"%E5%8D%81%E3%80%81%E8%B7%AF%E7%94%B1useRoute%E5%92%8CuseRouter\">十、路由useRoute和useRouter</h2>\n<pre><code>&lt;script setup&gt;\nimport { useRoute, useRouter } from 'vue-router'\n\nconst $route = useRoute()\nconst $router = userRouter()\n\n// 路由信息\nconsole.log($route.query)\n\n// 路由跳转\n$router.push('/login')\n&lt;/script&gt;</code></pre>\n<h2 id=\"使用自定义指令\">十一、对await异步的支持</h2>\n<p><code>&lt;script setup&gt;</code> 中可以使用顶层 <code>await</code>。结果代码会被编译成 <code>async setup()</code></p>\n<pre><code>&lt;script setup&gt;\n    const post = await fetch(`/api/post/1`).then(r =&gt; r.json())\n&lt;/script&gt;</code></pre>\n<h2 id=\"%E5%8D%81%E4%BA%8C%E3%80%81nextTick\">十二、nextTick</h2>\n<pre><code>// 方式一\n&lt;script setup&gt;\nimport { nextTick } from 'vue'\n\nnextTick(()=&gt;{\n    console.log('Dom已更新！')\n})\n&lt;/script&gt;</code></pre>\n<pre><code>// 方式二\n&lt;script setup&gt;\nimport { nextTick } from 'vue'\n\nawait nextTick()    // nextTick是一个异步函数，返回一个Promise实例\n// console.log('Dom已更新！')\n&lt;/script&gt;</code></pre>\n<h2 id=\"%E5%8D%81%E4%B8%89%E3%80%81%E5%85%A8%E5%B1%80%E5%B1%9E%E6%80%A7globalProperties\">十三、全局属性globalProperties</h2>\n<pre><code>// main.js里定义\nimport { createApp } from 'vue'\nimport App from './App.vue'\nconst app = createApp(App)\n\n// 定义一个全局属性$global \napp.config.globalProperties.$global = 'This is a global property.' \n\napp.mount('#app')</code></pre>\n<pre><code>// 组件内使用\n&lt;script setup&gt;\nimport { getCurrentInstance } from 'vue'\n\n// 获取vue实例\nconst { proxy } = getCurrentInstance()\n// 输出\nconsole.log(proxy.$global)    // This is a global property.\n&lt;/script&gt;</code></pre>\n<h2 id=\"%E5%8D%81%E5%9B%9B%E3%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F\">十四、生命周期</h2>\n<p>setup()里访问组件的生命周期需要在生命周期钩子前加上“on”，并且没有beforeCreate和created生命周期钩子</p>\n<blockquote>\n<p>因为 <code>setup</code> 是围绕 <code>beforeCreate</code> 和 <code>created</code> 生命周期钩子运行的，所以不需要显式地定义它们。换句话说，在这些钩子中编写的任何代码都应该直接在 <code>setup</code> 函数中编写。</p>\n</blockquote>\n<p><img alt=\"\" height=\"726\" src=\"image\\d7064ce777c948e5b1d105db5387753e.png\" width=\"470\"/></p>\n<pre><code>// 使用方式\n&lt;script setup&gt;\nimport { onMounted } from 'vue'\n\nonMounted(()=&gt; {\n    console.log('onMounted')\n})\n&lt;/script&gt;</code></pre>\n<h2 id=\"%E5%8D%81%E4%BA%94%E3%80%81%E4%B8%8E%E6%99%AE%E9%80%9A%E7%9A%84script%E6%A0%87%E7%AD%BE%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8\">十五、与普通的script标签一起使用</h2>\n<p><code>&lt;script setup&gt;</code> 可以和普通的 <code>&lt;script&gt;</code> 一起使用。普通的 <code>&lt;script&gt;</code> 在有这些需要的情况下或许会被使用到：</p>\n<ul><li>无法在 <code>&lt;script setup&gt;</code> 声明的选项，例如 <code>inheritAttrs</code> 或通过插件启用的自定义的选项；</li><li>声明命名导出，<code>&lt;script setup&gt;</code>定义的组件默认以组件文件的名称作为组件名；</li><li>运行副作用或者创建只需要执行一次的对象。</li></ul>\n<pre><code>&lt;script&gt;\n// 普通 &lt;script&gt;, 在模块范围下执行(只执行一次)\nrunSideEffectOnce()\n\n// 声明额外的选项\nexport default {\n  name: 'ComponentName',    // 组件重命名\n  inheritAttrs: false,\n  customOptions: {}\n}\n&lt;/script&gt;\n\n&lt;script setup&gt;\n// 在 setup() 作用域中执行 (对每个实例皆如此)\n&lt;/script&gt;</code></pre>\n<h2 id=\"%E5%8D%81%E5%85%AD%E3%80%81v-memo%E6%96%B0%E6%8C%87%E4%BB%A4\">十六、v-memo新指令</h2>\n<p>该指令与v-once类似，v-once是只渲染一次之后的更新不再渲染，而v-memo是根据条件来渲染。该指令接收一个固定长度的数组作为依赖值进行记忆比对，如果数组中的每个值都和上次渲染的时候相同，则该元素（含子元素）不刷新。</p>\n<p>1、应用于普通元素或组件；</p>\n<pre><code>&lt;template&gt;\n&lt;-- 普通元素 --&gt;\n&lt;div v-memo=\"[valueA, valueB]\"&gt;\n  ... \n&lt;/div&gt;\n\n&lt;-- 组件 --&gt;\n&lt;component v-memo=\"[valueA, valueB]\"&gt;&lt;/component&gt;\n&lt;/template&gt;\n\n&lt;script setup&gt;\nimport component from \"../compoents/component.vue\"\n&lt;/script&gt;</code></pre>\n<p>当组件重新渲染的时候，如果 <code>valueA</code> 与 <code>valueB</code> 都维持不变，那么对这个 <code>&lt;div&gt;</code> 以及它的所有子节点的更新都将被跳过。</p>\n<p>2、<strong>结合<code>v-for</code>使用</strong></p>\n<p><code>v-memo</code> 仅供性能敏感场景的针对性优化，会用到的场景应该很少。渲染 <code>v-for</code> 长列表 (长度大于 1000) 可能是它最有用的场景：</p>\n<pre><code>&lt;template&gt;\n&lt;div v-for=\"item in list\" :key=\"item.id\" v-memo=\"[item.id === selected]\"&gt;\n  &lt;p&gt;ID: {<!-- -->{ item.id }} - selected: {<!-- -->{ item.id === selected }}&lt;/p&gt;\n  &lt;p&gt;...more child nodes&lt;/p&gt;\n&lt;/div&gt;\n&lt;/template&gt;</code></pre>\n<p>当selected发生变化时，只有item.id===selected的该项重新渲染，其余不刷新。</p>\n<h1 id=\"style%E6%96%B0%E7%89%B9%E6%80%A7\">style新特性</h1>\n<p>Vue3.2版本对单文件组件的style样式进行了很多升级，如局部样式、css变量以及样式暴露给模板使用等。</p>\n<h2 id=\"%E5%B1%80%E9%83%A8%E6%A0%B7%E5%BC%8F\">一、局部样式</h2>\n<p>当 <code>&lt;style&gt;</code> 标签带有 <code>scoped</code> attribute 的时候，它的 CSS 只会应用到当前组件的元素上：</p>\n<pre><code>&lt;template&gt;\n  &lt;div class=\"example\"&gt;hi&lt;/div&gt;\n&lt;/template&gt;\n\n&lt;style scoped&gt;\n.example {\n  color: red;\n}\n&lt;/style&gt;</code></pre>\n<h2 id=\"%E6%B7%B1%E5%BA%A6%E9%80%89%E6%8B%A9%E5%99%A8\">二、深度选择器</h2>\n<p>处于 <code>scoped</code> 样式中的选择器如果想要做更“深度”的选择，也即：影响到子组件，可以使用 <code>:deep()</code> 这个伪类：</p>\n<pre><code>&lt;style scoped&gt;\n.a :deep(.b) {\n  /* ... */\n}\n&lt;/style&gt;</code></pre>\n<blockquote>\n<p>通过 <code>v-html</code> 创建的 DOM 内容不会被作用域样式影响，但你仍然可以使用深度选择器来设置其样式。</p>\n</blockquote>\n<h2 id=\"插槽选择器\">三、插槽选择器</h2>\n<p>默认情况下，作用域样式不会影响到 <code>&lt;slot/&gt;</code> 渲染出来的内容，因为它们被认为是父组件所持有并传递进来的。使用 <code>:slotted</code> 伪类以确切地将插槽内容作为选择器的目标：</p>\n<pre><code>&lt;style scoped&gt;\n:slotted(div) {\n  color: red;\n}\n&lt;/style&gt;</code></pre>\n<h2 id=\"全局选择器\">四、全局选择器</h2>\n<p>如果想让其中一个样式规则应用到全局，比起另外创建一个 <code>&lt;style&gt;</code>，可以使用 <code>:global</code> 伪类来实现：</p>\n<pre><code>&lt;style scoped&gt;\n:global(.red) {\n  color: red;\n}\n&lt;/style&gt;</code></pre>\n<h2 id=\"混合使用局部与全局样式\">五、混合使用局部与全局样式</h2>\n<p>你也可以在同一个组件中同时包含作用域样式和非作用域样式：</p>\n<pre><code>&lt;style&gt;\n/* global styles */\n&lt;/style&gt;\n\n&lt;style scoped&gt;\n/* local styles */\n&lt;/style&gt;</code></pre>\n<h2 id=\"%E6%94%AF%E6%8C%81CSS%C2%A0Modules\">六、支持CSS Modules</h2>\n<p><code>&lt;style module&gt;</code> 标签会被编译为 <a href=\"https://github.com/css-modules/css-modules\" title=\"CSS Modules\">CSS Modules</a> 并且将生成的 CSS 类键暴露给组件：</p>\n<p>1、 默认以<code>$style</code> 对象暴露给组件；</p>\n<pre><code>&lt;template&gt;\n  &lt;p :class=\"$style.red\"&gt;\n    This should be red\n  &lt;/p&gt;\n&lt;/template&gt;\n\n&lt;style module&gt;\n.red {\n  color: red;\n}\n&lt;/style&gt;</code></pre>\n<p>2、可以自定义注入module名称</p>\n<pre><code>&lt;template&gt;\n  &lt;p :class=\"classes.red\"&gt;red&lt;/p&gt;\n&lt;/template&gt;\n\n&lt;style module=\"classes\"&gt;\n.red {\n  color: red;\n}\n&lt;/style&gt;</code></pre>\n<h2 id=\"%E4%B8%8Esetup%E4%B8%80%E5%90%8C%E4%BD%BF%E7%94%A8\">七、与setup一同使用</h2>\n<p>注入的类可以通过 <a href=\"https://v3.cn.vuejs.org/api/global-api.html#usecssmodule\" title=\"useCssModule\">useCssModule</a> API 在 <code>setup()</code> 和 <code>&lt;script setup&gt;</code> 中使用：</p>\n<pre><code>&lt;script setup&gt;\nimport { useCssModule } from 'vue'\n\n// 默认, 返回 &lt;style module&gt; 中的类\nconst defaultStyle = useCssModule()\n\n// 命名, 返回 &lt;style module=\"classes\"&gt; 中的类\nconst classesStyle = useCssModule('classes')\n&lt;/script&gt;</code></pre>\n<h2 id=\"状态驱动的动态-css\">八、动态 CSS</h2>\n<p>单文件组件的 <code>&lt;style&gt;</code> 标签可以通过 <code>v-bind</code> 这一 CSS 函数将 CSS 的值关联到动态的组件状态上：</p>\n<pre><code>&lt;script setup&gt;\nconst theme = {\n  color: 'red'\n}\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;p&gt;hello&lt;/p&gt;\n&lt;/template&gt;\n\n&lt;style scoped&gt;\np {\n  color: v-bind('theme.color');\n}\n&lt;/style&gt;</code></pre>\n<p>（完） </p>\n<p>参考文献：</p>\n<p><a href=\"https://v3.cn.vuejs.org/api/sfc-spec.html\" title=\"SFC 语法规范 | Vue.js\">SFC 语法规范 | Vue.js</a></p>\n<p><a class=\"link-info\" href=\"https://juejin.cn/post/7006108454028836895#heading-43\" title=\"Vue3.2 setup语法糖、Composition API、状态库Pinia归纳总监\">Vue3.2 setup语法糖、Composition API、状态库Pinia归纳总监</a></p>\n</div>\n</div>"}