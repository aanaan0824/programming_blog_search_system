{"blogid": "123647344", "writerAge": "码龄2年", "writerBlogNum": "48", "writerCollect": "2512", "writerComment": "4018", "writerFan": "8742", "writerGrade": "6级", "writerIntegral": "7335", "writerName": "小杰312", "writerProfileAdress": "writer_image\\profile_123647344.jpg", "writerRankTotal": "3536", "writerRankWeekly": "8086", "writerThumb": "2664", "writerVisitNum": "112388", "blog_read_count": "1809", "blog_time": "已于 2022-04-25 17:06:04 修改", "blog_title": "STL设计之链表设计,分块分组件分析,迭代器设计思路", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E5%89%8D%E8%A8%80.-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%89%8D%E8%A8%80.\">前言.</a></p>\n<p id=\"%E4%B8%80.%20%E6%80%9D%E8%80%83%E5%85%B3%E4%BA%8Elist%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%80.%20%E6%80%9D%E8%80%83%E5%85%B3%E4%BA%8Elist%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1\">一. 思考关于list的迭代器的设计</a></p>\n<p id=\"%E4%BA%8C.%20%E9%87%8D%E8%A6%81%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%E5%88%86%E6%9E%90%E7%90%86%E8%A7%A3%2C%E6%9C%89%E4%BA%86%E8%BF%99%E4%BA%9B%E5%85%88%E5%86%99%E5%87%BA%E6%9D%A5%E7%9C%8B%E7%9C%8B%E6%95%88%E6%9E%9C-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BA%8C.%20%E9%87%8D%E8%A6%81%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%E5%88%86%E6%9E%90%E7%90%86%E8%A7%A3%2C%E6%9C%89%E4%BA%86%E8%BF%99%E4%BA%9B%E5%85%88%E5%86%99%E5%87%BA%E6%9D%A5%E7%9C%8B%E7%9C%8B%E6%95%88%E6%9E%9C\">二. 重要函数原型分析理解,有了这些先写出来看看效果</a></p>\n<p id=\"%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A1%86%E6%9E%B6%E5%BF%85%E5%A4%87%E5%87%BD%E6%95%B0%E5%88%A8%E6%9E%90-toc\" style=\"margin-left:80px;\"><a href=\"#%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A1%86%E6%9E%B6%E5%BF%85%E5%A4%87%E5%87%BD%E6%95%B0%E5%88%A8%E6%9E%90\">迭代器框架必备函数刨析</a></p>\n<p id=\"List%E6%A1%86%E6%9E%B6%E5%BF%85%E5%A4%87%E5%87%BD%E6%95%B0%E5%88%A8%E6%9E%90-toc\" style=\"margin-left:80px;\"><a href=\"#List%E6%A1%86%E6%9E%B6%E5%BF%85%E5%A4%87%E5%87%BD%E6%95%B0%E5%88%A8%E6%9E%90\">List框架必备函数刨析</a></p>\n<p id=\"%E4%B8%89.%20%E6%90%AD%E5%87%BA%E5%A4%A7%E4%BD%93%E6%A1%86%E6%9E%B6-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%89.%20%E6%90%AD%E5%87%BA%E5%A4%A7%E4%BD%93%E6%A1%86%E6%9E%B6\">三. 搭出大体框架</a></p>\n<p id=\"%E5%9B%9B.%20%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E5%88%86%E5%9D%97%E5%88%86%E6%9E%90%20(%E5%92%8Cvector%E5%B7%AE%E4%B8%8D%E5%A4%A7%E5%A4%9A)-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%9B%9B.%20%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E5%88%86%E5%9D%97%E5%88%86%E6%9E%90%20%28%E5%92%8Cvector%E5%B7%AE%E4%B8%8D%E5%A4%A7%E5%A4%9A%29\">四. 函数细节分块分析 (和vector差不大多)</a></p>\n<p id=\"%E5%8C%BA%E9%97%B4%E8%8C%83%E5%9B%B4range%E6%9E%84%E9%80%A0-toc\" style=\"margin-left:80px;\"><a href=\"#%E5%8C%BA%E9%97%B4%E8%8C%83%E5%9B%B4range%E6%9E%84%E9%80%A0\">区间范围range构造</a></p>\n<p id=\"swap%3A%20%E9%9D%9E%E5%B8%B8%E7%BA%AF%E7%B2%B9%E7%AE%80%E5%8D%95%E7%9A%84%E6%8D%A2%2C%20%E5%B0%86%E4%BD%A0%E7%9A%84%E6%88%90%E5%91%98%E6%8D%A2%E7%BB%99%E6%88%91%2C%20%E6%88%91%E5%B0%B1%E6%88%90%E4%BA%86%E4%BD%A0%EF%BC%8C%E4%BD%A0%E5%B0%B1%E6%88%90%E4%B8%BA%E4%BA%86%E6%88%91-toc\" style=\"margin-left:80px;\"><a href=\"#swap%3A%20%E9%9D%9E%E5%B8%B8%E7%BA%AF%E7%B2%B9%E7%AE%80%E5%8D%95%E7%9A%84%E6%8D%A2%2C%20%E5%B0%86%E4%BD%A0%E7%9A%84%E6%88%90%E5%91%98%E6%8D%A2%E7%BB%99%E6%88%91%2C%20%E6%88%91%E5%B0%B1%E6%88%90%E4%BA%86%E4%BD%A0%EF%BC%8C%E4%BD%A0%E5%B0%B1%E6%88%90%E4%B8%BA%E4%BA%86%E6%88%91\">swap: 非常纯粹简单的换, 将你的成员换给我, 我就成了你，你就成为了我</a></p>\n<p id=\"%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%C2%A0%20%C2%A0%20(%E5%9B%A0%E4%B8%BA%E6%9C%89%E4%BA%86swap%2C%20%E6%88%91%E8%87%AA%E8%BA%AB%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%BAnullptr%20%E9%81%BF%E5%85%8D%E9%87%8E%E6%8C%87%E9%92%88%2C%20%E7%84%B6%E5%90%8E%E5%B0%86%E5%A4%8D%E7%94%A8range%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E6%9E%84%E9%80%A0%E5%87%BA%E6%9D%A5%E7%9A%84tmp%E5%AF%B9%E8%B1%A1%E6%8D%A2%E6%9D%A5%E6%9E%84%E9%80%A0%E8%87%AA%E8%BA%AB)-toc\" style=\"margin-left:80px;\"><a href=\"#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%C2%A0%20%C2%A0%20%28%E5%9B%A0%E4%B8%BA%E6%9C%89%E4%BA%86swap%2C%20%E6%88%91%E8%87%AA%E8%BA%AB%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%BAnullptr%20%E9%81%BF%E5%85%8D%E9%87%8E%E6%8C%87%E9%92%88%2C%20%E7%84%B6%E5%90%8E%E5%B0%86%E5%A4%8D%E7%94%A8range%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E6%9E%84%E9%80%A0%E5%87%BA%E6%9D%A5%E7%9A%84tmp%E5%AF%B9%E8%B1%A1%E6%8D%A2%E6%9D%A5%E6%9E%84%E9%80%A0%E8%87%AA%E8%BA%AB%29\">拷贝构造    (因为有了swap, 我自身初始化为nullptr 避免野指针, 然后将复用range构造代码构造出来的tmp对象换来构造自身)</a></p>\n<p id=\"%E8%B5%8B%E5%80%BC%E9%87%8D%E8%BD%BD-toc\" style=\"margin-left:80px;\"><a href=\"#%E8%B5%8B%E5%80%BC%E9%87%8D%E8%BD%BD\">赋值重载</a></p>\n<p id=\"%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0(%E6%8A%A2%E5%A4%BA%E5%B0%86%E4%BA%A1%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A0%86%E5%8C%BA%E8%B5%84%E6%BA%90%E8%BF%9B%E8%A1%8C%E6%9E%84%E9%80%A0)-toc\" style=\"margin-left:80px;\"><a href=\"#%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%28%E6%8A%A2%E5%A4%BA%E5%B0%86%E4%BA%A1%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A0%86%E5%8C%BA%E8%B5%84%E6%BA%90%E8%BF%9B%E8%A1%8C%E6%9E%84%E9%80%A0%29\">移动构造(抢夺将亡对象的堆区资源进行构造)</a></p>\n<p id=\"%E5%86%99%E5%AE%8Cinsert()%20%2B%20erase()%E6%8E%A5%E5%8F%A3%EF%BC%8C%E7%9B%B8%E5%BD%93%E4%BA%8E%E6%98%AF%E5%86%99%E5%A5%BD%E4%BA%86%E5%85%AD%E4%B8%AA%E6%8E%A5%E5%8F%A3-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%86%99%E5%AE%8Cinsert%28%29%20%2B%20erase%28%29%E6%8E%A5%E5%8F%A3%EF%BC%8C%E7%9B%B8%E5%BD%93%E4%BA%8E%E6%98%AF%E5%86%99%E5%A5%BD%E4%BA%86%E5%85%AD%E4%B8%AA%E6%8E%A5%E5%8F%A3\">写完insert() + erase()接口，相当于是写好了六个接口</a></p>\n<p id=\"insert()-toc\" style=\"margin-left:80px;\"><a href=\"#insert%28%29\">insert()</a></p>\n<p id=\"push_back()%C2%A0%20%E5%A4%8D%E7%94%A8insert%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:80px;\"><a href=\"#push_back%28%29%C2%A0%20%E5%A4%8D%E7%94%A8insert%E5%87%BD%E6%95%B0\">push_back()  复用insert函数</a></p>\n<p id=\"push_front()%C2%A0%20%E5%A4%8D%E7%94%A8insert%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:80px;\"><a href=\"#push_front%28%29%C2%A0%20%E5%A4%8D%E7%94%A8insert%E5%87%BD%E6%95%B0\">push_front()  复用insert函数</a></p>\n<p id=\"erase()%3B-toc\" style=\"margin-left:80px;\"><a href=\"#erase%28%29%3B\">erase();</a></p>\n<p id=\"pop_back()-toc\" style=\"margin-left:80px;\"><a href=\"#pop_back%28%29\">pop_back() 复用erase</a></p>\n<p id=\"pop_front()-toc\" style=\"margin-left:80px;\"><a href=\"#pop_front%28%29\">pop_front() 复用erase</a></p>\n<p id=\"%E4%BA%94.%20%E6%80%BB%E4%BD%93%E4%BB%A3%E7%A0%81%20%2B%20%E6%B5%8B%E8%AF%95-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BA%94.%20%E6%80%BB%E4%BD%93%E4%BB%A3%E7%A0%81%20%2B%20%E6%B5%8B%E8%AF%95\">五. 总体代码 + 测试</a></p>\n<p id=\"%E5%85%AD.%20%E6%80%BB%E7%BB%93-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%85%AD.%20%E6%80%BB%E7%BB%93\">六. 总结</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h1 id=\"%E5%89%8D%E8%A8%80.\">前言.</h1>\n<blockquote>\n<ul><li><strong>欢迎大家来到小杰的手写STL章节，小杰会长期根据自己所学和浅显理解，尽力以比较简单口语的方式带着大家分析STL中各种重要容器的函数接口迭代器等等组件的设计，希望大家可以支持小杰，万分感谢.  </strong></li><li><strong>如下附上精彩前文连接</strong></li></ul>\n</blockquote>\n<p><a class=\"has-card\" href=\"https://blog.csdn.net/weixin_53695360/article/details/123248476?spm=1001.2014.3001.5501\" title=\"分块刨析从函数原型到分块实现C++STL(vector)_小杰312的博客-CSDN博客\"><span class=\"link-card-box\"><span class=\"link-title\">分块刨析从函数原型到分块实现C++STL(vector)_小杰312的博客-CSDN博客</span><span class=\"link-desc\">分块刨析从函数原型到分块实现C++STL(vector)</span><span class=\"link-link\"><img alt=\"\" class=\"link-link-icon\" src=\"https://g.csdnimg.cn/static/logo/favicon32.ico\"/>https://blog.csdn.net/weixin_53695360/article/details/123248476?spm=1001.2014.3001.5501</span></span></a></p>\n<h1 id=\"%E4%B8%80.%20%E6%80%9D%E8%80%83%E5%85%B3%E4%BA%8Elist%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1\">一. 思考关于list的迭代器的设计</h1>\n<blockquote>\n<ul><li><strong>首先关于list的迭代器设计上面，不再像vector那般的简单了，因为 List 不是连续的存储空间在存储着元素，元素的访问也就没有办法像 vector中原生指针那样直接的进行 ++ 操作去访问后序元素，  <span style=\"color:#fe2c24;\">但是迭代器就是可以支持做 ++  -- * 操作的一个这样一个类, 我们需要可以通过 ++  迭代器的操作  遍历访问整个容器中的元素</span></strong></li><li><strong><span style=\"color:#0d0016;\">正因上述的需求，我们的  List 中的节点  LIstNode* pnode  便是需要专门为其设计一个迭代器类进行管理的，使得 </span> pnode 可以通过  ++  的操作去访问下一个的元素,  -- 操作可以去访问上一个元素</strong></li><li><strong>所以大体上的思路出来了，一个struct iterator迭代器类封装管理一个ListNode* 的指针，功能就是一个智能指针类，管理一个ListNode* 指针,  对齐进行各种运算符重载：使得我们的ListNode* 指针可以通过 ++  -- 操作实现容器的遍历</strong></li><li><strong>结点类</strong></li></ul>\n<p><img alt=\"\" height=\"423\" src=\"image\\908784a126b74db396603e3b3853ea99.png\" width=\"539\"/></p>\n<ul><li> <strong>迭代器类:   此处粘贴出来的仅仅只是迭代器的重要组件，理清楚思路，其他的迭代器的运算符重载函数的书写还是蛮easy的</strong></li></ul>\n<p><img alt=\"\" height=\"234\" src=\"image\\66dc1c615b19496bb646620caf4f310d.png\" width=\"977\"/></p>\n<ul><li><strong> 首先：我们将迭代器设置成了三个模板参数，分别是T  Ref   Ptr, 这样做有什么必要吗？   答案肯定是肯定的，  STL源码中不可能无端设计出来三个模板参数呀</strong></li><li><strong>因为后序需要使用到ListIterator&lt;T, Ref, Ptr&gt; 还有 ListNode&lt;T&gt; 但是这样带着模板写有点略显麻烦了，所以起得别名, self别名 代表迭代器本体类型</strong></li></ul>\n<p><img alt=\"\" height=\"375\" src=\"image\\cd8540d2c87a41e3b050ae68d58d9577.png\" width=\"1059\"/></p>\n<ul><li><strong> 上述问题的解决其实就是在此处了， 核心关键就是两种迭代器的产生, 一种是const_iterator  另外一个是  iterator ，  一旦我们将其设置成三个模板参数，我们传入const 的时候他会按照模板的模子自动帮我们生成一份const类，我们就不再需要重新单独的为const 再专门设计出来一个类了, 没有必要做这个手工花销，有模板不必再自己新手写一个const 迭代器管理类了</strong></li></ul>\n</blockquote>\n<h1 id=\"%E4%BA%8C.%20%E9%87%8D%E8%A6%81%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%E5%88%86%E6%9E%90%E7%90%86%E8%A7%A3%2C%E6%9C%89%E4%BA%86%E8%BF%99%E4%BA%9B%E5%85%88%E5%86%99%E5%87%BA%E6%9D%A5%E7%9C%8B%E7%9C%8B%E6%95%88%E6%9E%9C\">二. 重要函数原型分析理解,有了这些先写出来看看效果</h1>\n<blockquote>\n<h3 id=\"%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A1%86%E6%9E%B6%E5%BF%85%E5%A4%87%E5%87%BD%E6%95%B0%E5%88%A8%E6%9E%90\">迭代器框架必备函数刨析</h3>\n<p><img alt=\"\" height=\"558\" src=\"image\\d0da99b274414739b74ec1ad03987f82.png\" width=\"889\"/></p>\n<ul><li><strong>operator * 重载就是取出其中的数据</strong></li><li><strong>opeartor-&gt; 重载就是取出数据的地址</strong></li><li><strong>!= 和 == 大家都懂, 判断是否是一个迭代器</strong></li></ul>\n<p><img alt=\"\" height=\"640\" src=\"image\\e64febfa056c4a55b85643f8627544fc.png\" width=\"913\"/></p>\n<ul><li><strong> ++  -- 操作迭代器必备的操作， 代表着前进和后退一个结点</strong></li></ul>\n<h3 id=\"List%E6%A1%86%E6%9E%B6%E5%BF%85%E5%A4%87%E5%87%BD%E6%95%B0%E5%88%A8%E6%9E%90\">List框架必备函数刨析</h3>\n<p><img alt=\"\" height=\"519\" src=\"image\\ababa7cefb9f4120a38a07baabda8fcf.png\" width=\"899\"/></p>\n<ul><li><strong>写默认构造很简单，一个没有数据的虚拟结点充当表头, 前后指针指向表头自身.</strong></li></ul>\n<p><img alt=\"\" height=\"674\" src=\"image\\c35591e9d198486ba073d29acf13e63a.png\" width=\"1200\"/></p>\n<ul><li><strong>尾部插入一个结点, 三个过程</strong></li></ul>\n<ol><li><strong>拿到尾部结点指针 pTail, 创建出新的newnode结点</strong></li><li><strong>pTail和newnode 相连接, newnode 成为新的tail</strong></li><li><strong>要构成循环，newnode 尾部结点需要和 head 相互连接</strong></li></ol>\n<p><img alt=\"\" height=\"578\" src=\"image\\8e025eb2a8e2427a8163b1257b317ef3.png\" width=\"1131\"/></p>\n<ul><li> <strong>上述简简单单的写一下for_each   使用迭代器作为模板参数，不为别的，只为了让大家感受一下为啥迭代器   <span style=\"color:#fe2c24;\">就能做各种容器和算法之间的粘合剂，没有迭代器就无法支持容器的遍历</span><span style=\"color:#0d0016;\">。。。             </span></strong></li><li><span style=\"color:#0d0016;\"><strong>因为没有迭代器管理对象指针，智能指针类，让其支持  ++  --  * 操作来泛型的遍历整个容器，且将容器中的元素进行算法func处理，   </strong></span><strong><span style=\"color:#fe2c24;\">  (STL的哪些所有的遍历算法都没法实现了，都瘫痪了)</span></strong></li></ul>\n</blockquote>\n<h1 id=\"%E4%B8%89.%20%E6%90%AD%E5%87%BA%E5%A4%A7%E4%BD%93%E6%A1%86%E6%9E%B6\">三. 搭出大体框架</h1>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;list&gt;\n#include &lt;assert.h&gt;\nusing namespace std;\n\nnamespace tyj {\n\t//链表节点的设计, 双向循环链表\n\ttemplate&lt;class T&gt;\n\tstruct ListNode {\n\t\tListNode(const T&amp; _val = T())\n\t\t\t: pre(nullptr)\n\t\t\t, next(nullptr)\n\t\t\t, val(_val) {\n\t\t}\n\t\tListNode&lt;T&gt;* pre;\n\t\tListNode&lt;T&gt;* next;\n\t\tT val;\n\t};\n\n\t//分析一下三个模板??? 为啥要三个，其实这个是STL源码里面这样设计的\n\ttemplate&lt;class T, class Ref, class Ptr&gt;\n\tstruct ListIterator {\n\t\ttypedef ListNode&lt;T&gt; Node;\n\t\ttypedef ListIterator&lt;T, Ref, Ptr &gt; self;\n\t\tNode* pnode;\t//Iterator管理的指针\n\n\t\tListIterator(Node* _pnode = nullptr)\n\t\t\t: pnode(_pnode) { \n\t\t}\n\t\tRef operator*() {\n\t\t\treturn pnode-&gt;val;\t//*重载访问val\n\t\t}\n\n\t\tPtr operator-&gt;() {\t\t//支持-&gt;访问\n\t\t\treturn &amp;pnode-&gt;val;\n\t\t}\n\n\t\tbool operator!=(const self&amp; obj) const {\n\t\t\treturn pnode != obj.pnode;\n\t\t}\n\t\tbool operator==(const self&amp; obj) const {\n\t\t\treturn pnode == obj.pnode;\n\t\t}\n\n\t\tself&amp; operator++() {\t//前置++ -- 操作返回本体\n\t\t\tpnode = pnode-&gt;next;\n\t\t\treturn *this;\n\t\t}\n\t\tself operator++(int) {\n\t\t\tself before(*this);\t//返回的是之前的\n\t\t\tpnode = pnode-&gt;next;\n\t\t\treturn before;\n\t\t}\n\n\n\t\tself&amp; operator--() {\n\t\t\tpnode = pnode-&gt;pre;\n\t\t\treturn *this;\n\t\t}\n\n\t\tself operator--(int) {\n\t\t\tself before(*this);\n\t\t\tpnode = pnode-&gt;pre;\n\t\t\treturn before;\n\t\t}\n\n\t};\n\n\ttemplate&lt;class T&gt;\n\tclass List {\n\t\ttypedef ListNode&lt;T&gt; Node;//\n\tpublic:\n\t\ttypedef ListIterator&lt;T, T&amp;, T*&gt; iterator;\n\t\ttypedef ListIterator&lt;T, const T&amp;, const T*&gt; const_iterator;\n\t\t//此处体现出来了  Ref  Ptr模板化的好处了\t\n\t\tList() : head(new Node) {\n\t\t\thead-&gt;pre = head-&gt;next = head;//双向链表的最初状态\n\t\t}\n\n\t\titerator begin() {//第一个结点\n\t\t\treturn iterator(head-&gt;next);\n\t\t}\n\n\t\tconst_iterator begin() const {\n\t\t\treturn const_iterator(head-&gt;next);\n\t\t}\n\n\t\titerator end() {\n\t\t\treturn iterator(head);//返回虚拟头部结点\n\t\t}\n\n\t\tconst_iterator end() const {\n\t\t\treturn const_iterator(head);//虚拟头部结点\n\t\t}\n\n\t\tvoid push_back(const T&amp; val) {\n\t\t\tNode* pTail = head-&gt;pre;\n\t\t\tNode* newnode = new Node(val);\n\t\t\t//连接到尾部\n\t\t\tpTail-&gt;next = newnode;\n\t\t\tnewnode-&gt;pre = pTail;\n\t\t\t//成环连接到head上\n\t\t\tnewnode-&gt;next = head;\n\t\t\thead-&gt;pre = newnode;\n\t\t}\n\n\tprivate:\n\t\tNode* head;//头部指针指向头部结点\n\n\t};\n\n\ttemplate&lt;class InputIterator, class Function&gt;\n\tvoid for_each(InputIterator first, InputIterator last, Function f) {\n\t\twhile (first != last) {\n\t\t\tf(*first++);\n\t\t}\n\t}\n\ttemplate&lt;class T&gt;\n\tstruct Print {\n\t\tvoid operator()(const T&amp; val) const {\n\t\t\tcout &lt;&lt; val &lt;&lt; \" \";\n\t\t}\n\t};\n}\n\ntemplate&lt;class T&gt;\nvoid PrintList(tyj::List&lt;T&gt;&amp; lt) {\n\ttyj::for_each(lt.begin(), lt.end(), tyj::Print&lt;T&gt;());\n    cout &lt;&lt; endl;\n}\n\nint main() {\n\n\ttyj::List&lt;int&gt; lt;\n\tfor (int i = 0; i &lt; 5; ++i) {\n\t\tlt.push_back(i);\n\t}\n\tPrintList(lt);\n\n\treturn 0;\n}\n</code></pre>\n<h1 id=\"%E5%9B%9B.%20%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E5%88%86%E5%9D%97%E5%88%86%E6%9E%90%20(%E5%92%8Cvector%E5%B7%AE%E4%B8%8D%E5%A4%A7%E5%A4%9A)\">四. 函数细节分块分析 (和vector差不大多)</h1>\n<blockquote>\n<ul><li> <h3 id=\"%E5%8C%BA%E9%97%B4%E8%8C%83%E5%9B%B4range%E6%9E%84%E9%80%A0\"><strong>区间范围range构造</strong></h3> </li></ul>\n<p><img alt=\"\" height=\"437\" src=\"image\\af98c24759e447cdaa6033f51ccec8df.png\" width=\"743\"/></p>\n<ul><li> <strong>vector  和 list 都是这种方式实现的, 遍历传入区间，然后调用push_back 复用代码实现传入，一种常用的套路方式.</strong></li><li><strong>swap为复用代码做准备</strong></li></ul>\n<pre><code>void swap(List&amp; lt) {\n\t::swap(head, lt.head);\n}</code></pre>\n<ul><li> <h3 id=\"swap%3A%20%E9%9D%9E%E5%B8%B8%E7%BA%AF%E7%B2%B9%E7%AE%80%E5%8D%95%E7%9A%84%E6%8D%A2%2C%20%E5%B0%86%E4%BD%A0%E7%9A%84%E6%88%90%E5%91%98%E6%8D%A2%E7%BB%99%E6%88%91%2C%20%E6%88%91%E5%B0%B1%E6%88%90%E4%BA%86%E4%BD%A0%EF%BC%8C%E4%BD%A0%E5%B0%B1%E6%88%90%E4%B8%BA%E4%BA%86%E6%88%91\">swap: 非常纯粹简单的换, 将你的成员换给我, 我就成了你，你就成为了我</h3> </li><li> <h3 id=\"%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%C2%A0%20%C2%A0%20(%E5%9B%A0%E4%B8%BA%E6%9C%89%E4%BA%86swap%2C%20%E6%88%91%E8%87%AA%E8%BA%AB%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%BAnullptr%20%E9%81%BF%E5%85%8D%E9%87%8E%E6%8C%87%E9%92%88%2C%20%E7%84%B6%E5%90%8E%E5%B0%86%E5%A4%8D%E7%94%A8range%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E6%9E%84%E9%80%A0%E5%87%BA%E6%9D%A5%E7%9A%84tmp%E5%AF%B9%E8%B1%A1%E6%8D%A2%E6%9D%A5%E6%9E%84%E9%80%A0%E8%87%AA%E8%BA%AB)\">拷贝构造    (因为有了swap, 我自身初始化为nullptr 避免野指针, 然后将复用range构造代码构造出来的tmp对象换来构造自身)</h3> </li></ul>\n<pre><code>List(const List&amp; lt) \n\t: head(nullptr) {\n\tList tmp(lt.begin(), lt.end());\n\tswap(tmp);\t//换, 复用范围构造\n}</code></pre>\n<ul><li> <h3 id=\"%E8%B5%8B%E5%80%BC%E9%87%8D%E8%BD%BD\">赋值重载</h3> </li></ul>\n<pre><code>//直接复用拷贝构造出来的lt\nList&amp; operator=(List lt) {\n\thead = nullptr;\n\tswap(lt);\n\treturn *this;\n}</code></pre>\n<ul><li><strong>纯纯的复用拷贝构造出来的lt对象，你反正是临时对象，出来作用域就要析构，我直接换掉你底层的堆区资源构造this，复用拷贝构造  (<span style=\"color:#fe2c24;\">本质还是复用range构造</span>) </strong></li><li> <h3 id=\"%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0(%E6%8A%A2%E5%A4%BA%E5%B0%86%E4%BA%A1%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A0%86%E5%8C%BA%E8%B5%84%E6%BA%90%E8%BF%9B%E8%A1%8C%E6%9E%84%E9%80%A0)\">移动构造(抢夺将亡对象的堆区资源进行构造)</h3> </li></ul>\n<pre><code>List(List&amp;&amp; lt) {\n    head = nullptr;\n\tswap(lt);\n}</code></pre>\n<ul><li><strong><span style=\"color:#fe2c24;\">移动构造，直接换，其他啥都不干，为啥它可以这样，拷贝构造都需要复用range范围构造构造构造出来一个tmp才能换,  但是移动构造是直接换,    </span></strong></li><li><strong><span style=\"color:#0d0016;\">核心原因：移动构造传入的参数是一个右值，啥叫作右值，将死对象，临时对象，既然参数本来就是将亡对象，我直接就可使用它的底层堆区资源来构造自身</span></strong></li></ul>\n<p></p>\n<ul><li> <h2 id=\"%E5%86%99%E5%AE%8Cinsert()%20%2B%20erase()%E6%8E%A5%E5%8F%A3%EF%BC%8C%E7%9B%B8%E5%BD%93%E4%BA%8E%E6%98%AF%E5%86%99%E5%A5%BD%E4%BA%86%E5%85%AD%E4%B8%AA%E6%8E%A5%E5%8F%A3\"><span style=\"color:#0d0016;\">写完insert() + erase()接口，相当于是写好了六个接口</span></h2> </li><li> <h3 id=\"insert()\">insert()</h3> </li></ul>\n<p><img alt=\"\" height=\"605\" src=\"image\\23f2107a92054535adf20183c9eaaace.png\" width=\"1046\"/></p>\n<ul><li><strong>insert(pos, val);  在pos迭代器位置的前面插入一个值为val的结点newnode</strong></li><li> <h3 id=\"push_back()%C2%A0%20%E5%A4%8D%E7%94%A8insert%E5%87%BD%E6%95%B0\">push_back()  复用insert函数</h3> </li></ul>\n<pre><code>void push_back(const T&amp; val) {\n\tinsert(end(), val);\n    //在end()前插入一个newnode结点\n}</code></pre>\n<ul><li> <h3 id=\"push_front()%C2%A0%20%E5%A4%8D%E7%94%A8insert%E5%87%BD%E6%95%B0\">push_front()  复用insert函数</h3> </li></ul>\n<pre><code>void push_front(const T&amp; val) {\n\tinsert(begin(), val);\n    //在begin前插入一个newnode结点    \n}</code></pre>\n<ul><li> <h3 id=\"erase()%3B\">erase();</h3> </li></ul>\n<p><img alt=\"\" height=\"552\" src=\"image\\5675e11f31534b728bac38b6af91b09f.png\" width=\"942\"/></p>\n<p><strong>erase(pos)总结就是三句话:</strong></p>\n<ol><li><strong>拿取pos前pre后next结点</strong></li><li><strong>delete pos</strong></li><li><strong>pre 和 next结点相连 </strong></li></ol>\n<ul><li> <h3 id=\"pop_back()\"><strong>pop_back() 复用erase</strong></h3> </li></ul>\n<pre><code>void pop_back() {\n\terase(--end());\n    //删除end()前一个迭代器\n    //end() == head \n    //--end() == head-&gt;pre == pTail\n}</code></pre>\n<ul><li> <h3 id=\"pop_front()\">pop_front() 复用erase</h3> </li></ul>\n<pre><code>void pop_front() {\n\terase(begin());\n    //begin() head-&gt;next;\n    //head-&gt;next == firstnode\n    //head是一个空头结点, firstnode才是真实的第一个元素\n}</code></pre>\n</blockquote>\n<h1 id=\"%E4%BA%94.%20%E6%80%BB%E4%BD%93%E4%BB%A3%E7%A0%81%20%2B%20%E6%B5%8B%E8%AF%95\">五. 总体代码 + 测试</h1>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;list&gt;\n#include &lt;algorithm&gt;\n#include &lt;assert.h&gt;\nusing namespace std;\n\nnamespace tyj {\n\t//链表节点的设计, 双向循环链表\n\ttemplate&lt;class T&gt;\n\tstruct ListNode {\n\t\tListNode(const T&amp; _val = T())\n\t\t\t: pre(nullptr)\n\t\t\t, next(nullptr)\n\t\t\t, val(_val) {\n\t\t}\n\t\tListNode&lt;T&gt;* pre;\n\t\tListNode&lt;T&gt;* next;\n\t\tT val;\n\t};\n\n\t//分析一下三个模板??? 为啥要三个，其实这个是STL源码里面这样设计的\n\ttemplate&lt;class T, class Ref, class Ptr&gt;\n\tstruct ListIterator {\n\t\ttypedef ListNode&lt;T&gt; Node;\n\t\ttypedef ListIterator&lt;T, Ref, Ptr &gt; self;\n\t\tNode* pnode;\t//Iterator管理的指针\n\n\t\tListIterator(Node* _pnode = nullptr)\n\t\t\t: pnode(_pnode) { \n\t\t}\n\t\tRef operator*() {\n\t\t\treturn pnode-&gt;val;\t//*重载访问val\n\t\t}\n\n\t\tPtr operator-&gt;() {\t\t//支持-&gt;访问\n\t\t\treturn &amp;pnode-&gt;val;\n\t\t}\n\n\t\tbool operator!=(const self&amp; obj) const {\n\t\t\treturn pnode != obj.pnode;\n\t\t}\n\t\tbool operator==(const self&amp; obj) const {\n\t\t\treturn pnode == obj.pnode;\n\t\t}\n\n\t\tself&amp; operator++() {\t//前置++ -- 操作返回本体\n\t\t\tpnode = pnode-&gt;next;\n\t\t\treturn *this;\n\t\t}\n\t\tself operator++(int) {\n\t\t\tself before(*this);\t//返回的是之前的\n\t\t\tpnode = pnode-&gt;next;\n\t\t\treturn before;\n\t\t}\n\n\n\t\tself&amp; operator--() {\n\t\t\tpnode = pnode-&gt;pre;\n\t\t\treturn *this;\n\t\t}\n\n\t\tself operator--(int) {\n\t\t\tself before(*this);\n\t\t\tpnode = pnode-&gt;pre;\n\t\t\treturn before;\n\t\t}\n\n\t};\n\n\ttemplate&lt;class T&gt;\n\tclass List {\n\t\ttypedef ListNode&lt;T&gt; Node;\n\tpublic:\n\t\ttypedef ListIterator&lt;T, T&amp;, T*&gt; iterator;\n\t\ttypedef ListIterator&lt;T, const T&amp;, const T*&gt; const_iterator;\n\t\t//此处体现出来了  Ref  Ptr模板化的好处了\t\n\t\tList() : head(new Node) {\n\t\t\thead-&gt;pre = head-&gt;next = head;//双向链表的最初状态\n\t\t}\n\n\t\ttemplate&lt;class InputIterator&gt;\n\t\tList(InputIterator first, InputIterator last)\n\t\t\t: head(new Node) {\n\t\t\thead-&gt;pre = head-&gt;next = head;\n\t\t\twhile (first != last) {\n\t\t\t\tpush_back(*first++);\n\t\t\t}\n\t\t}\n\n\t\tvoid swap(List&amp; lt) {\n\t\t\t::swap(head, lt.head);\n\t\t}\n\n\t\tList(const List&amp; lt)\n\t\t\t: head(nullptr) {\n\t\t\tList tmp(lt.begin(), lt.end());\n\t\t\tswap(tmp);\t//换, 复用范围构造\n\t\t}\n\n\t\t//直接复用拷贝构造出来的lt\n\t\tList&amp; operator=(List lt) {\n\t\t\thead = nullptr;\n\t\t\tswap(lt);\n\t\t\treturn *this;\n\t\t}\n\n\t\tList(List&amp;&amp; lt) {\n\t\t\tswap(lt);\n\t\t}\n\n\t\titerator begin() {//第一个结点\n\t\t\treturn iterator(head-&gt;next);\n\t\t}\n\n\t\tconst_iterator begin() const {\n\t\t\treturn const_iterator(head-&gt;next);\n\t\t}\n\n\t\titerator end() {\n\t\t\treturn iterator(head);//返回虚拟头部结点\n\t\t}\n\n\t\tconst_iterator end() const {\n\t\t\treturn const_iterator(head);//虚拟头部结点\n\t\t}\n\n\t\t//在pos位置插入一个val \n\t\tvoid insert(iterator pos, const T&amp; val) {\n\t\t\tassert(pos.pnode);//先断言结点位置存在, 不存在就无法插入\n\t\t\tNode* cur = pos.pnode;//先拿取到结点指针\n\t\t\tNode* pre = cur-&gt;pre;\n\t\t\tNode* newnode = new Node(val);//创建新的结点\n\n\t\t\tpre-&gt;next = newnode;\n\t\t\tnewnode-&gt;pre = pre;\n\t\t\t//新的结点连接pre\n\t\t\tnewnode-&gt;next = cur;\n\t\t\tcur-&gt;pre = newnode;\n\t\t\t//新的结点连接cur\n\t\t}\n\n\t\tvoid push_back(const T&amp; val) {\n\t\t\t//Node* pTail = head-&gt;pre;\n\t\t\t//Node* newnode = new Node(val);\n\t\t\t连接到尾部\n\t\t\t//pTail-&gt;next = newnode;\n\t\t\t//newnode-&gt;pre = pTail;\n\t\t\t成环连接到head上\n\t\t\t//newnode-&gt;next = head;\n\t\t\t//head-&gt;pre = newnode;\n\t\t\tinsert(end(), val);\n\t\t}\n\t\t \n\t\tvoid push_front(const T&amp; val) {\n\t\t\tinsert(begin(), val);\n\t\t}\n\n\n\t\tvoid pop_front() {\n\t\t\terase(begin());\n\t\t}\n\n\t\tvoid pop_back() {\n\t\t\terase(--end());\n\t\t}\n\n\t\t//删除pos迭代器位置元素返回下一个元素\n\t\titerator erase(iterator pos) {\n\t\t\tassert(pos.pnode);//存在才可以做删除操作\n\t\t\tassert(pos != end());\n\t\t\t//拿取到前面一个结点和后一个结点\n\t\t\tNode* pre = pos.pnode-&gt;pre;\n\t\t\tNode* next = pos.pnode-&gt;next;\n\n\t\t\t//删除现在iterator\n\t\t\tdelete pos.pnode;\n\n\t\t\tpre-&gt;next = next;\n\t\t\tnext-&gt;pre = pre;\n\t\t\treturn iterator(next);\n\t\t}\n\t\tvoid clear() {\n\t\t\tNode* p = head-&gt;next, *q;\n\t\t\twhile (p != head) {\n\t\t\t\tq = p-&gt;next;\n\t\t\t\tdelete p;\n\t\t\t\tp = q;\n\t\t\t}\n\t\t\tdelete head;\n\t\t}\n\n\t\tsize_t size() {\n\t\t\tsize_t ans = 0;\n\t\t\tNode* p = head-&gt;next;\n\t\t\twhile (p != head) {\n\t\t\t\tans += 1;\n\t\t\t\tp = p-&gt;next;\n\t\t\t}\n\t\t\treturn ans;\n\t\t}\n\n\t\t~List() {\n\t\t\tif (head != nullptr)\n\t\t\t\tclear();\n\t\t\thead = nullptr;\n\t\t}\n\tprivate:\n\t\tNode* head;//头部指针指向头部结点\n\t};\n\n\ttemplate&lt;class InputIterator, class Function&gt;\n\tvoid for_each(InputIterator first, InputIterator last, Function f) {\n\t\twhile (first != last) {\n\t\t\tf(*first++);\n\t\t}\n\t}\n\ttemplate&lt;class T&gt;\n\tstruct Print {\n\t\tvoid operator()(const T&amp; val) const {\n\t\t\tcout &lt;&lt; val &lt;&lt; \" \";\n\t\t}\n\t};\n}\n\ntemplate&lt;class T&gt;\nvoid PrintList(tyj::List&lt;T&gt;&amp; lt) {\n\ttyj::for_each(lt.begin(), lt.end(), tyj::Print&lt;T&gt;());\n\tcout &lt;&lt; endl;\n}\n\n\n// 测试List的构造\nvoid TestList1()\n{\n\ttyj::List&lt;int&gt; l1;\n\tint array[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 };\n\ttyj::List&lt;int&gt; l3(array, array + sizeof(array) / sizeof(array[0]));\n\tPrintList(l3);\n\ttyj::List&lt;int&gt; l4(l3);\n\tPrintList(l4);\n\tl1 = l4;\n\tPrintList(l1);\n}\n\nvoid TestList2()\n{\n\t// 测试PushBack与PopBack\n\ttyj::List&lt;int&gt; l;\n\tl.push_back(1);\n\tl.push_back(2);\n\tl.push_back(3);\n\tPrintList(l);\n\tl.pop_back();\n\tl.pop_back();\n\tPrintList(l);\n\tl.pop_back();\n\tcout &lt;&lt; l.size() &lt;&lt; endl;\n\t// 测试PushFront与PopFront\n\tl.push_front(1);\n\tl.push_front(2);\n\tl.push_front(3);\n\tPrintList(l);\n\tl.pop_front();\n\tl.pop_front();\n\tPrintList(l);\n\tl.pop_front();\n\tcout &lt;&lt; l.size() &lt;&lt; endl;\n}\n\nvoid TestList3()\n{\n\tint array[] = { 1, 2, 3, 4, 5 };\n\ttyj::List&lt;int&gt; l(array, array + sizeof(array) / sizeof(array[0]));\n\tauto pos = l.begin();\n\tl.insert(l.begin(), 0);\n\tPrintList(l);\n\n\t++pos;\n\tl.insert(pos, 2);\n\tPrintList(l);\n\tl.erase(l.begin());\n\tl.erase(pos);\n\tPrintList(l);\n\t// pos指向的节点已经被删除，pos迭代器失效\n\tcout &lt;&lt; *pos &lt;&lt; endl;\n\tauto it = l.begin();\n\twhile (it != l.end())\n\t{\n\t\tit = l.erase(it);\n\t}\n\tcout &lt;&lt; l.size() &lt;&lt; endl;\n}\n\nint main() {\n\n\t//tyj::List&lt;int&gt; lt;\n\t//for (int i = 0; i &lt; 5; ++i) {\n\t//\tlt.push_back(i);\n\t//}\n\n\t//PrintList(lt);\n\t//int arr[5] = { 1, 2, 3, 4, 5 };\n\t//tyj::List&lt;int&gt; lt2(arr, arr + 5);\n\n\t//PrintList(lt2);\n\t/*TestList1();*/\n\n\t/*TestList2();*/\n\n\tTestList3();\n\treturn 0;\n}</code></pre>\n<h1 id=\"%E5%85%AD.%20%E6%80%BB%E7%BB%93\">六. 总结</h1>\n<blockquote>\n<ul><li><strong>就list对比vector而言, list更能够体现出来迭代器的设计重要性</strong></li><li><strong>本质来说STL的list底层就是一个双向循环的链表(数据结构)而已,  其中最最有价值的部分是  iterator的设计上面.   iterator是如何粘合  容器 + 算法的，这一点特别的重要</strong></li><li><strong>首先我们写链表需要先封装出来一个ListNode结构体:    </strong></li><li><strong>我们需要管理ListNode* 的指针于是我们需要设计出ListIterator类来支持各种指针的运算符重载，来支持特定的容器遍历方式，粘合算法</strong></li><li><strong> <span style=\"color:#fe2c24;\">写STL 或者写一些小东西的经验之谈</span></strong></li><li><span style=\"color:#0d0016;\"><strong>首先看是否存在一定的框架，或者官方文档，如果存在，将其总体框架分成组件，将重要组件分别设计实现，针对重要的接口进行文档阅读，分析实现.</strong></span></li><li><span style=\"color:#0d0016;\"><strong>写出框架简单测试，框架没有问题之后我们可以看见小小的效果，喜悦心理，然后再慢慢的一点一点的啃食重点接口。。写完接口要及时测试</strong></span></li><li><span style=\"color:#0d0016;\"><strong>最终，对于整体代码进行各种特别情景下的测试。。。 </strong></span><strong><span style=\"color:#fe2c24;\">找debug</span></strong></li></ul>\n<p><span style=\"color:#fe2c24;\"><strong>感谢你阅读完了小杰的本篇文章，小杰后序还会根据自身掌握水平持续推出一些STL的设计书写思路，如果您觉着小杰写的还不错，劳烦关注支持一下，非常感谢，最后还是祝福大家都学习的学业专业有成，工作的都升职加薪</strong></span></p>\n</blockquote>\n</div>\n</div>"}