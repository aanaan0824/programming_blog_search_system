{"blogid": "122028929", "writerAge": "码龄15年", "writerBlogNum": "613", "writerCollect": "728", "writerComment": "275", "writerFan": "3270", "writerGrade": "8级", "writerIntegral": "29092", "writerName": "孙飞 Sunface", "writerProfileAdress": "writer_image\\profile_122028929.jpg", "writerRankTotal": "93833", "writerRankWeekly": "10657", "writerThumb": "845", "writerVisitNum": "2511166", "blog_read_count": "799", "blog_time": "于 2021-12-19 20:02:36 发布", "blog_title": "Rust学习教程31 -返回值Result和?", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-tomorrow-night\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<blockquote>\n<p>本文节选自<a href=\"https://github.com/sunface/rust-course\">&lt;&lt;Rust语言圣经&gt;&gt;</a>一书<br/> 欢迎大家加入Rust编程学院，一起学习交流:<br/> QQ群：1009730433</p>\n</blockquote>\n<h1><a id=\"Result_4\"></a>可恢复的错误Result</h1>\n<p>还记得上一节中，提到的关于文件读取的思考题吧？当时我们解决了读取中如果遇到不可恢复错误该怎么处理，现在来看看，读取过程中，正常返回和遇到可以恢复的错误时该如何处理。</p>\n<p>假设，我们有一台消息服务器，每个用户都通过websocket连接到该服务器来接收和发送消息，该过程就涉及到socket文件的读写，那么此时，如果一个用户的读写发生了错误，显然不能直接panic，否则服务器会直接崩溃，所有用户都会断开连接，因此我们需要一种更温和的错误处理方式: <code>Result&lt;T,E&gt;</code>.</p>\n<p>之前章节有提到过，<code>Result&lt;T,E&gt;</code>是一个枚举类型，定义如下：</p>\n<pre><code class=\"prism language-rust\"><span class=\"token keyword\">enum</span> <span class=\"token type-definition class-name\">Result</span><span class=\"token operator\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">E</span><span class=\"token operator\">&gt;</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token class-name\">Ok</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token class-name\">Err</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>泛型参数<code>T</code>代表成功时存入的正确值，存放方式是<code>Ok(T)</code>，<code>E</code>代表错误是存入的错误值，存放方式是<code>Err(E)</code>，枯燥的讲解永远不及代码生动准确，因此先来看下打开文件的例子：</p>\n<pre><code class=\"prism language-rust\"><span class=\"token keyword\">use</span> <span class=\"token namespace\">std<span class=\"token punctuation\">::</span>fs<span class=\"token punctuation\">::</span></span><span class=\"token class-name\">File</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">let</span> f <span class=\"token operator\">=</span> <span class=\"token class-name\">File</span><span class=\"token punctuation\">::</span><span class=\"token function\">open</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello.txt\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>以上<code>File::open</code>返回一个<code>Result</code>类型, 那么问题来了：</p>\n<blockquote>\n<h4><a id=\"_26\"></a>如何获知变量类型或者函数的返回类型</h4>\n<p>有几种常用的方式:</p>\n<ul><li>第一种是查询标准库或者三方库文档，搜索<code>File</code>，然后找到它的<code>open</code>方法，但是此处更推荐第二种方法:</li><li>在<a href=\"../../first-try/editor.md\">Rust IDE</a>章节，我们推荐了<code>VSCode</code> IED和<code>rust-analyze</code>插件，如果你成功安装的话，那么就可以在<code>VScode</code>中很方便的通过代码跳转的方式查看代码，同时<code>rust-analyze</code>插件还会对代码中的类型进行标注，非常方便好用！</li><li>你还可以尝试故意标记一个错误的类型，然后让编译器告诉你:</li></ul>\n</blockquote>\n<pre><code class=\"prism language-rust\"><span class=\"token keyword\">let</span> f<span class=\"token punctuation\">:</span> <span class=\"token keyword\">u32</span> <span class=\"token operator\">=</span> <span class=\"token class-name\">File</span><span class=\"token punctuation\">::</span><span class=\"token function\">open</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello.txt\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>错误提示如下：</p>\n<pre><code class=\"prism language-console\">error[E0308]: mismatched types\n --&gt; src/main.rs:4:18\n  |\n4 |     let f: u32 = File::open(\"hello.txt\");\n  |                  ^^^^^^^^^^^^^^^^^^^^^^^ expected u32, found enum\n`std::result::Result`\n  |\n  = note: expected type `u32`\n             found type `std::result::Result&lt;std::fs::File, std::io::Error&gt;`\n</code></pre>\n<p>上面代码，故意将<code>f</code>类型标记成整形，编译器立刻不乐意了，你是在忽悠我吗？打开文件操作返回一个整形？来，大哥来告诉你返回什么：<code>std::result::Result&lt;std::fs::File, std::io::Error&gt;</code>,我的天呐，怎么这么长的类型！</p>\n<p>别慌，其实很简单，首先<code>Result</code>本身是定义在<code>std::result</code>中的，但是因为<code>Result</code>很常用，就被包含在了<a href=\"../../appendix/prelude.md\"><code>prelude</code></a>中(将常用的东东提前引入到当前作用域内），因此无需手动引入<code>std::result::Result</code>，那么返回类型可以简化为<code>Result&lt;std::fs::File,std::io::Error&gt;</code>，你看看是不是很像标准的<code>Result&lt;T,E&gt;</code>枚举定义？只不过<code>T</code>被替换成了具体的类型<code>std::fs::File</code>，是一个文件句柄类型，<code>E</code>被替换成<code>std::io::Error</code>，是一个IO错误类型.</p>\n<p>这个返回值类型说明<code>File::open</code>调用如果成功则返回一个可以进行读写的文件句柄，如果失败，则返回一个IO错误: 文件不存在或者没有访问文件的权限等。总之<code>File::open</code>需要一个方式告知调用者是成功还是失败，并同时返回具体的文件句柄(成功)或错误信息(失败), 万幸的是,这些信息<code>Result</code>枚举可以提供:</p>\n<pre><code class=\"prism language-rust\"><span class=\"token keyword\">use</span> <span class=\"token namespace\">std<span class=\"token punctuation\">::</span>fs<span class=\"token punctuation\">::</span></span><span class=\"token class-name\">File</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">let</span> f <span class=\"token operator\">=</span> <span class=\"token class-name\">File</span><span class=\"token punctuation\">::</span><span class=\"token function\">open</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello.txt\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">let</span> f <span class=\"token operator\">=</span> <span class=\"token keyword\">match</span> f <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token class-name\">Ok</span><span class=\"token punctuation\">(</span>file<span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> file<span class=\"token punctuation\">,</span>\n        <span class=\"token class-name\">Err</span><span class=\"token punctuation\">(</span>error<span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{<!-- --></span>\n            <span class=\"token macro property\">panic!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Problem opening the file: {:?}\"</span><span class=\"token punctuation\">,</span> error<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>代码很清晰，对打开文件后的<code>Result&lt;T,E&gt;</code>类型进行匹配取值，如果是成功，则将<code>Ok(file)</code>中存放的的文件句柄<code>file</code>赋值给<code>f</code>，如果失败，则将<code>Err(error)</code>中存放的错误信息<code>error</code>使用<code>panic</code>抛出来，进而结束程序，这非常符合上文提到过的<code>panic</code>使用场景。</p>\n<p>好吧，也没有那么合理:)</p>\n<h2><a id=\"_73\"></a>对返回的错误进行处理</h2>\n<p>直接<code>panic</code>还是过于粗暴，因为实际上IO的错误有很多种，我们需要对部分错误进行特殊处理，而不是所有错误都直接崩溃:</p>\n<pre><code class=\"prism language-rust\"><span class=\"token keyword\">use</span> <span class=\"token namespace\">std<span class=\"token punctuation\">::</span>fs<span class=\"token punctuation\">::</span></span><span class=\"token class-name\">File</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">use</span> <span class=\"token namespace\">std<span class=\"token punctuation\">::</span>io<span class=\"token punctuation\">::</span></span><span class=\"token class-name\">ErrorKind</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">let</span> f <span class=\"token operator\">=</span> <span class=\"token class-name\">File</span><span class=\"token punctuation\">::</span><span class=\"token function\">open</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello.txt\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">let</span> f <span class=\"token operator\">=</span> <span class=\"token keyword\">match</span> f <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token class-name\">Ok</span><span class=\"token punctuation\">(</span>file<span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> file<span class=\"token punctuation\">,</span>\n        <span class=\"token class-name\">Err</span><span class=\"token punctuation\">(</span>error<span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token keyword\">match</span> error<span class=\"token punctuation\">.</span><span class=\"token function\">kind</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n            <span class=\"token class-name\">ErrorKind</span><span class=\"token punctuation\">::</span><span class=\"token class-name\">NotFound</span> <span class=\"token operator\">=&gt;</span> <span class=\"token keyword\">match</span> <span class=\"token class-name\">File</span><span class=\"token punctuation\">::</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello.txt\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n                <span class=\"token class-name\">Ok</span><span class=\"token punctuation\">(</span>fc<span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> fc<span class=\"token punctuation\">,</span>\n                <span class=\"token class-name\">Err</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token macro property\">panic!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Problem creating the file: {:?}\"</span><span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n            other_error <span class=\"token operator\">=&gt;</span> <span class=\"token macro property\">panic!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Problem opening the file: {:?}\"</span><span class=\"token punctuation\">,</span> other_error<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>上面代码在匹配出<code>error</code>后，又对<code>error</code>进行了详细的匹配解析，最终结果：</p>\n<ul><li>如果是文件不存在错误<code>ErrorKind::NotFound</code>，就创建文件，这里创建文件<code>File::create</code>也是返回<code>Result</code>，因此继续用<code>match</code>对其进行处理:创建成功，将新的文件句柄赋值给<code>f</code>，如果失败，则<code>panic</code></li><li>剩下的错误，一律<code>panic</code></li></ul>\n<p>虽然很清晰，但是代码还是有些啰嗦，我们会在<a href=\"../../errors/simplify.md\">简化错误处理</a>一章重点讲述如何写出更优雅的错误.</p>\n<h2><a id=\"panic_unwrapexpect_101\"></a>失败就panic: unwrap和expect</h2>\n<p>上一节中，已经看到过这两兄弟的简单介绍，这里再来回顾下。</p>\n<p>在不需要处理错误的场景，例如写原型、示例时，我们不想使用<code>match</code>去匹配<code>Result&lt;T,E&gt;</code>以获取其中的<code>T</code>值，因为<code>match</code>的穷尽匹配特性，你总要去处理下<code>Err</code>分支。那么有没有办法简化这个过程？有，答案就是<code>unwrap</code>和<code>expect</code>。</p>\n<p>它们的作用就是，如果返回成功，就将<code>Ok(T)</code>中的值取出来，如果失败，就直接<code>panic</code>，真的勇士决不多BB，直接崩溃.</p>\n<pre><code class=\"prism language-rust\"><span class=\"token keyword\">use</span> <span class=\"token namespace\">std<span class=\"token punctuation\">::</span>fs<span class=\"token punctuation\">::</span></span><span class=\"token class-name\">File</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">let</span> f <span class=\"token operator\">=</span> <span class=\"token class-name\">File</span><span class=\"token punctuation\">::</span><span class=\"token function\">open</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello.txt\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">unwrap</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>如果调用这段代码时不存在 <em>hello.txt</em> 文件，那么<code>unwrap</code>就将直接<code>panic</code>：</p>\n<pre><code class=\"prism language-console\">thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Os { code: 2, kind: NotFound, message: \"No such file or directory\" }', src/main.rs:4:37\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n</code></pre>\n<p><code>expect</code>跟<code>unwrap</code>很像，只不过它允许指定<code>panic!</code>时的报错信息:</p>\n<pre><code class=\"prism language-rust\"><span class=\"token keyword\">use</span> <span class=\"token namespace\">std<span class=\"token punctuation\">::</span>fs<span class=\"token punctuation\">::</span></span><span class=\"token class-name\">File</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">let</span> f <span class=\"token operator\">=</span> <span class=\"token class-name\">File</span><span class=\"token punctuation\">::</span><span class=\"token function\">open</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello.txt\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">expect</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Failed to open hello.txt\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>报错如下</p>\n<pre><code class=\"prism language-console\">thread 'main' panicked at 'Failed to open hello.txt: Os { code: 2, kind: NotFound, message: \"No such file or directory\" }', src/main.rs:4:37\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n</code></pre>\n<p>可以看出，<code>expect</code>相比<code>unwrap</code>能提供更精确的错误信息，在有些场景也会更加实用。</p>\n<h2><a id=\"_140\"></a>传播错误</h2>\n<p>咱们的程序几乎不太可能只有<code>A-&gt;B</code>形式的函数调用，一个设计良好的程序，一个功能涉及十来层的函数调用都有可能。而错误处理也往往不是哪里调用出错，就在哪里处理，实际应用中，大概率会把错误层层上传然后交给调用链的上游函数进行处理，由此，错误传播将极为常见.</p>\n<p>例如以下函数从文件中读取用户名，然后将结果进行返回：</p>\n<pre><code class=\"prism language-rust\"><span class=\"token keyword\">use</span> <span class=\"token namespace\">std<span class=\"token punctuation\">::</span>fs<span class=\"token punctuation\">::</span></span><span class=\"token class-name\">File</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">use</span> <span class=\"token namespace\">std<span class=\"token punctuation\">::</span>io<span class=\"token punctuation\">::</span></span><span class=\"token punctuation\">{<!-- --></span><span class=\"token keyword\">self</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Read</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">read_username_from_file</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-&gt;</span> <span class=\"token class-name\">Result</span><span class=\"token operator\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span> <span class=\"token namespace\">io<span class=\"token punctuation\">::</span></span><span class=\"token class-name\">Error</span><span class=\"token operator\">&gt;</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token comment\">// 打开文件，f是`Result&lt;文件句柄,io::Error&gt;`</span>\n    <span class=\"token keyword\">let</span> f <span class=\"token operator\">=</span> <span class=\"token class-name\">File</span><span class=\"token punctuation\">::</span><span class=\"token function\">open</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello.txt\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">let</span> <span class=\"token keyword\">mut</span> f <span class=\"token operator\">=</span> <span class=\"token keyword\">match</span> f <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token comment\">// 打开文件成功，将file句柄赋值给f</span>\n        <span class=\"token class-name\">Ok</span><span class=\"token punctuation\">(</span>file<span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> file<span class=\"token punctuation\">,</span>\n        <span class=\"token comment\">// 打开文件失败，将错误返回(向上传播)</span>\n        <span class=\"token class-name\">Err</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token keyword\">return</span> <span class=\"token class-name\">Err</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 创建动态字符串s</span>\n    <span class=\"token keyword\">let</span> <span class=\"token keyword\">mut</span> s <span class=\"token operator\">=</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">::</span><span class=\"token function\">new</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 从f文件句柄读取数据并写入s中</span>\n    <span class=\"token keyword\">match</span> f<span class=\"token punctuation\">.</span><span class=\"token function\">read_to_string</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span><span class=\"token keyword\">mut</span> s<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token comment\">// 读取成功，返回Ok封装的字符串</span>\n        <span class=\"token class-name\">Ok</span><span class=\"token punctuation\">(</span>_<span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token class-name\">Ok</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n        <span class=\"token comment\">// 将错误向上传播</span>\n        <span class=\"token class-name\">Err</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token class-name\">Err</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>有几点值得注意：</p>\n<ul><li>该函数返回一个<code>Result&lt;String, io::Error&gt;</code>类型，当读取用户名成功时，返回<code>Ok(String)</code>，失败时，返回<code>Err(io:Error)</code></li><li><code>File::open</code>和<code>f.read_to_string</code>返回的<code>Result&lt;T,E&gt;</code>中的<code>E</code>就是<code>io::Error</code></li></ul>\n<p>由此可见，该函数将<code>io::Error</code>的错误往上进行传播, 该函数的调用者最终会对<code>Result&lt;String,io::Error&gt;</code>进行再处理，至于怎么处理就是调用者的事，如果是错误，它可以选择继续向上传播错误，也可以直接<code>panic</code>，亦或将具体的错误原因包装后写入socket中呈现给终端用户。</p>\n<p>但是上面的代码也有自己的问题，那就是太长了(优秀的程序员身上的优点极多，其中最大的优点就是<em>懒</em>)，我自认为也有那么一点点优秀，因此见不到这么啰嗦的代码，下面咱们来讲讲如何简化它。</p>\n<h3><a id=\"__178\"></a>传播界的大明星: ?</h3>\n<p>大明星出场，必需得有排面，来看看<code>?</code>的排面:</p>\n<pre><code class=\"prism language-rust\"><span class=\"token keyword\">use</span> <span class=\"token namespace\">std<span class=\"token punctuation\">::</span>fs<span class=\"token punctuation\">::</span></span><span class=\"token class-name\">File</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">use</span> <span class=\"token namespace\">std<span class=\"token punctuation\">::</span></span>io<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">use</span> <span class=\"token namespace\">std<span class=\"token punctuation\">::</span>io<span class=\"token punctuation\">::</span></span><span class=\"token class-name\">Read</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">read_username_from_file</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-&gt;</span> <span class=\"token class-name\">Result</span><span class=\"token operator\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span> <span class=\"token namespace\">io<span class=\"token punctuation\">::</span></span><span class=\"token class-name\">Error</span><span class=\"token operator\">&gt;</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">let</span> <span class=\"token keyword\">mut</span> f <span class=\"token operator\">=</span> <span class=\"token class-name\">File</span><span class=\"token punctuation\">::</span><span class=\"token function\">open</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello.txt\"</span><span class=\"token punctuation\">)</span><span class=\"token operator\">?</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> <span class=\"token keyword\">mut</span> s <span class=\"token operator\">=</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">::</span><span class=\"token function\">new</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    f<span class=\"token punctuation\">.</span><span class=\"token function\">read_to_string</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span><span class=\"token keyword\">mut</span> s<span class=\"token punctuation\">)</span><span class=\"token operator\">?</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">Ok</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>看到没，这就是排面，相比前面的<code>match</code>处理错误的函数，代码直接减少了一半不止，但是，一山更比一山难，看不懂啊！</p>\n<p>其实<code>?</code>就是一个宏，它的作用跟上面的<code>match</code>几乎一模一样:</p>\n<pre><code class=\"prism language-rust\"><span class=\"token keyword\">let</span> <span class=\"token keyword\">mut</span> f <span class=\"token operator\">=</span> <span class=\"token keyword\">match</span> f <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token comment\">// 打开文件成功，将file句柄赋值给f</span>\n    <span class=\"token class-name\">Ok</span><span class=\"token punctuation\">(</span>file<span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> file<span class=\"token punctuation\">,</span>\n    <span class=\"token comment\">// 打开文件失败，将错误返回(向上传播)</span>\n    <span class=\"token class-name\">Err</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token keyword\">return</span> <span class=\"token class-name\">Err</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>如果结果是<code>Ok(T)</code>，则把<code>T</code>赋值给<code>f</code>，如果结果是<code>Err(E)</code>，则返回该错误，所以<code>?</code>特别适合用来传播错误。</p>\n<p>虽然<code>?</code>和<code>match</code>功能一致，但是事实上<code>?</code>会更胜一筹。何解？</p>\n<p>想象一下，一个设计良好的系统中，肯定有自定义的错误特征，错误之间很可能会存在上下级关系，例如标准库中的<code>std::io::Error</code>和<code>std::error::Error</code>，前者是io相关的错误结构体，后者是一个最最通用的标准错误特征，同时前者实现了后者，因此<code>std::io::Error</code>可以转换为<code>std:error::Error</code>。</p>\n<p>明白了以上的错误转换，<code>?</code>的更胜一筹就很好理解了，它可以自动进行类型提升:</p>\n<pre><code class=\"prism language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">open_file</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-&gt;</span> <span class=\"token class-name\">Result</span><span class=\"token operator\">&lt;</span><span class=\"token class-name\">File</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Box</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">dyn</span> <span class=\"token namespace\">std<span class=\"token punctuation\">::</span>error<span class=\"token punctuation\">::</span></span><span class=\"token class-name\">Error</span><span class=\"token operator\">&gt;&gt;</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">let</span> <span class=\"token keyword\">mut</span> f <span class=\"token operator\">=</span> <span class=\"token class-name\">File</span><span class=\"token punctuation\">::</span><span class=\"token function\">open</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello.txt\"</span><span class=\"token punctuation\">)</span><span class=\"token operator\">?</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">Ok</span><span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>上面代码中<code>File::open</code>报错时返回的错误是<code>std::io::Error</code>类型，但是<code>open_file</code>函数返回的错误类型是<code>std::error::Error</code>的特征对象，可以看到一个错误类型通过<code>?</code>返回后，变成了另一个错误类型，这就是<code>?</code>的神奇之处。</p>\n<p>根本原因是在于标准库中定义的<code>From</code>特征，该特征有一个方法<code>from</code>，该方法用于把一个类型转成另外一个类型，<code>?</code>可以自动调用该方法，然后进行隐式类型转换。因此只要函数返回的错误<code>ReturnError</code>实现了<code>From&lt;OtherError&gt;</code>特征，那么<code>?</code>就会自动把<code>OtherError</code>转换为<code>ReturnError</code>。</p>\n<p>这种转换非常好用，意味着你可以用一个大而全的<code>ReturnError</code>来覆盖所有错误类型，只需要为各种子错误类型实现这种转换即可。</p>\n<p>强中自有强中手，一码更比一码短:</p>\n<pre><code class=\"prism language-rust\"><span class=\"token keyword\">use</span> <span class=\"token namespace\">std<span class=\"token punctuation\">::</span>fs<span class=\"token punctuation\">::</span></span><span class=\"token class-name\">File</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">use</span> <span class=\"token namespace\">std<span class=\"token punctuation\">::</span></span>io<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">use</span> <span class=\"token namespace\">std<span class=\"token punctuation\">::</span>io<span class=\"token punctuation\">::</span></span><span class=\"token class-name\">Read</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">read_username_from_file</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-&gt;</span> <span class=\"token class-name\">Result</span><span class=\"token operator\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span> <span class=\"token namespace\">io<span class=\"token punctuation\">::</span></span><span class=\"token class-name\">Error</span><span class=\"token operator\">&gt;</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">let</span> <span class=\"token keyword\">mut</span> s <span class=\"token operator\">=</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">::</span><span class=\"token function\">new</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token class-name\">File</span><span class=\"token punctuation\">::</span><span class=\"token function\">open</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello.txt\"</span><span class=\"token punctuation\">)</span><span class=\"token operator\">?</span><span class=\"token punctuation\">.</span><span class=\"token function\">read_to_string</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span><span class=\"token keyword\">mut</span> s<span class=\"token punctuation\">)</span><span class=\"token operator\">?</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token class-name\">Ok</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>瞧见没？ <code>?</code>还能实现链式调用，<code>File::open</code>遇到错误就返回，没有错误就将<code>Ok</code>中的值取出来用于下一个方法调用，简直太精妙了，从Go语言过来的我，内心狂喜(其实学Rust的苦和痛我才不会告诉你们)。</p>\n<p>不仅有更强，还要有最强，我不信还有人比我更短((不要误解)：</p>\n<pre><code class=\"prism language-rust\"><span class=\"token keyword\">use</span> <span class=\"token namespace\">std<span class=\"token punctuation\">::</span></span>fs<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">use</span> <span class=\"token namespace\">std<span class=\"token punctuation\">::</span></span>io<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">read_username_from_file</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-&gt;</span> <span class=\"token class-name\">Result</span><span class=\"token operator\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span> <span class=\"token namespace\">io<span class=\"token punctuation\">::</span></span><span class=\"token class-name\">Error</span><span class=\"token operator\">&gt;</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token comment\">// read_to_string是定义在std::io中的方法，因此需要在上面进行引用</span>\n    <span class=\"token namespace\">fs<span class=\"token punctuation\">::</span></span><span class=\"token function\">read_to_string</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello.txt\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>从文件读取数据到字符串中，是比较常见的操作，因此Rust标准库为我们提供了<code>fs::read_to_string</code>函数，该函数内部会打开一个文件、创建<code>String</code>、读取文件内容最后写入字符串并返回，因为该函数无法帮助我们学习该章的内容，因此放在最后来讲，其实只是我想震你们一下:)</p>\n<h4><a id=\"Option_252\"></a>?用于Option的返回</h4>\n<p><code>?</code>不仅仅可以用于<code>Result</code>的传播，还能用于<code>Option</code>的传播，再来回忆下<code>Option</code>的定义：</p>\n<pre><code class=\"prism language-rust\"><span class=\"token keyword\">pub</span> <span class=\"token keyword\">enum</span> <span class=\"token type-definition class-name\">Option</span><span class=\"token operator\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token operator\">&gt;</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token class-name\">Some</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token class-name\">None</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p><code>Result</code>通过<code>?</code>返回错误，那么<code>Option</code>就通过<code>?</code>返回<code>None</code>：</p>\n<pre><code class=\"prism language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">first</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span><span class=\"token punctuation\">[</span><span class=\"token keyword\">i32</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-&gt;</span> <span class=\"token class-name\">Option</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">&amp;</span><span class=\"token keyword\">i32</span><span class=\"token operator\">&gt;</span> <span class=\"token punctuation\">{<!-- --></span>\n   <span class=\"token keyword\">let</span> v <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token operator\">?</span><span class=\"token punctuation\">;</span>\n   <span class=\"token class-name\">Some</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>上面的函数中，<code>arr.get</code>返回一个<code>Option&lt;&amp;i32&gt;</code>类型，因为<code>?</code>的使用，如果<code>get</code>的结果是<code>None</code>，则直接返回<code>None</code>，如果是<code>Some(&amp;i32)</code>，则把里面的值赋给<code>v</code>。</p>\n<p>其实这个函数有些画蛇添足，我们完全可以写出更简单的版本：</p>\n<pre><code class=\"prism language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">first</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span><span class=\"token punctuation\">[</span><span class=\"token keyword\">i32</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-&gt;</span> <span class=\"token class-name\">Option</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">&amp;</span><span class=\"token keyword\">i32</span><span class=\"token operator\">&gt;</span> <span class=\"token punctuation\">{<!-- --></span>\n   arr<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>有一句话怎么说？没有需求，制造需求也要上。。。大家别跟我学习，这是软件开发大忌. 只能用代码洗洗眼了：</p>\n<pre><code class=\"prism language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">last_char_of_first_line</span><span class=\"token punctuation\">(</span>text<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span><span class=\"token keyword\">str</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-&gt;</span> <span class=\"token class-name\">Option</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">char</span><span class=\"token operator\">&gt;</span> <span class=\"token punctuation\">{<!-- --></span>\n    text<span class=\"token punctuation\">.</span><span class=\"token function\">lines</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">?</span><span class=\"token punctuation\">.</span><span class=\"token function\">chars</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">last</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>上面代码展示了在链式调用中使用<code>?</code>提前返回<code>None</code>的用法,<code>.next</code>方法返回的是<code>Option</code>类型：如果返回<code>Some(&amp;str)</code>，那么继续调用<code>chars</code>方法,如果返回<code>None</code>，则直接从整个函数中返回<code>None</code>，不再继续进行链式调用.</p>\n<h4><a id=\"_284\"></a>新手用?常会犯的错误</h4>\n<p>初学者在用<code>?</code>时，老是会犯错，例如写出这样的代码:</p>\n<pre><code class=\"prism language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">first</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span><span class=\"token punctuation\">[</span><span class=\"token keyword\">i32</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-&gt;</span> <span class=\"token class-name\">Option</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">&amp;</span><span class=\"token keyword\">i32</span><span class=\"token operator\">&gt;</span> <span class=\"token punctuation\">{<!-- --></span>\n   arr<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token operator\">?</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>这段代码无法通过编译，切记：<code>?</code>操作符需要一个变量来承载正确的值，只有错误值能直接返回，正确的值不行。因此<code>?</code>只能用于以下形式：</p>\n<ul><li><code>let v = xxx()?;</code></li><li><code>xxx()?.yyy()?;</code></li></ul>\n<h4><a id=\"main_295\"></a>带返回值的main函数</h4>\n<p>因为刚才讲的<code>?</code>使用限制，这段代码你很容易看出它无法编译：</p>\n<pre><code class=\"prism language-rust\"><span class=\"token keyword\">use</span> <span class=\"token namespace\">std<span class=\"token punctuation\">::</span>fs<span class=\"token punctuation\">::</span></span><span class=\"token class-name\">File</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">let</span> f <span class=\"token operator\">=</span> <span class=\"token class-name\">File</span><span class=\"token punctuation\">::</span><span class=\"token function\">open</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello.txt\"</span><span class=\"token punctuation\">)</span><span class=\"token operator\">?</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>因为<code>?</code>要求<code>Result&lt;T,E&gt;</code>形式的返回值，而<code>main</code>函数的返回是<code>()</code>，因此无法满足，那是不是就无解了呢？</p>\n<p>实际上Rust还支持另外一种形式的<code>main</code>函数：</p>\n<pre><code class=\"prism language-rust\"><span class=\"token keyword\">use</span> <span class=\"token namespace\">std<span class=\"token punctuation\">::</span>error<span class=\"token punctuation\">::</span></span><span class=\"token class-name\">Error</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">use</span> <span class=\"token namespace\">std<span class=\"token punctuation\">::</span>fs<span class=\"token punctuation\">::</span></span><span class=\"token class-name\">File</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-&gt;</span> <span class=\"token class-name\">Result</span><span class=\"token operator\">&lt;</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Box</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">dyn</span> <span class=\"token class-name\">Error</span><span class=\"token operator\">&gt;&gt;</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">let</span> f <span class=\"token operator\">=</span> <span class=\"token class-name\">File</span><span class=\"token punctuation\">::</span><span class=\"token function\">open</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello.txt\"</span><span class=\"token punctuation\">)</span><span class=\"token operator\">?</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token class-name\">Ok</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>这样就能使用<code>?</code>提前返回了，同时我们又一次看到了<code>Box&lt;dyn Error&gt;</code>特征对象，因为<code>std::error:Error</code>是Rust中抽象层次最高的错误，其它标准库中的错误都实现了该特征，因此我们可以用该特征对象代表一切错误，就算<code>main</code>函数中调用任何标准库函数发生错误，都可以通过<code>Box&lt;dyn Error&gt;</code>这个特征对象进行返回.</p>\n<p>至于<code>main</code>函数可以有多种返回值，那是因为实现了[std::process::Termination]特征,目前为止该特征还没进入稳定版Rust中，也许未来你可以为自己的类型实现该特征！</p>\n<p>至此，Rust的基础内容学习已经全部完成，下面我们将学习Rust的高级进阶内容，正式开启你的高手之路。</p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}