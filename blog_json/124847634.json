{"blogid": "124847634", "writerAge": "码龄6年", "writerBlogNum": "621", "writerCollect": "16511", "writerComment": "862", "writerFan": "86715", "writerGrade": "8级", "writerIntegral": "42777", "writerName": "bitcarmanlee", "writerProfileAdress": "writer_image\\profile_124847634.jpg", "writerRankTotal": "99", "writerRankWeekly": "380", "writerThumb": "5382", "writerVisitNum": "8397951", "blog_read_count": "10617", "blog_time": "已于 2022-05-18 22:01:05 修改", "blog_title": "c++智能指针详解", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-tomorrow-night\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h2><a id=\"1_0\"></a>1.什么是智能指针</h2>\n<p>从比较简单的层面来看，智能指针是RAII(Resource Acquisition Is Initialization，资源获取即初始化)机制对普通指针进行的一层封装。这样使得智能指针的行为动作像一个指针，本质上却是一个对象，这样可以方便管理一个对象的生命周期。</p>\n<p>在c++中，智能指针一共定义了4种：<br/> auto_ptr、unique_ptr、shared_ptr 和 weak_ptr。其中，auto_ptr 在 C++11已被摒弃，在C++17中已经移除不可用。</p>\n<h2><a id=\"2_6\"></a>2.原始指针的问题</h2>\n<p>原始指针的问题大家都懂，就是如果忘记删除，或者删除的情况没有考虑清楚，容易造成悬挂指针(dangling pointer)或者说野指针(wild pointer)。</p>\n<p>我们看个简单的例子</p>\n<pre><code class=\"prism language-cpp\">objtype <span class=\"token operator\">*</span>p <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token function\">objtype</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\np <span class=\"token operator\">-&gt;</span> <span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">delete</span> p<span class=\"token punctuation\">;</span>\n</code></pre>\n<p>上面的代码结构是我们经常看到的。里面的问题主要有以下两点：<br/> 1.代码的最后，忘记执行delete p的操作。<br/> 2.第一点其实还好，比较容易发现也比较容易解决。比较麻烦的是，如果func()中有异常，delete p语句执行不到，这就很难办。有的同学说可以在func中进行删除操作，理论上是可以这么做，实际操作起来，会非常麻烦也非常复杂。</p>\n<p>此时，智能指针就可以方便我们控制指针对象的生命周期。在智能指针中，一个对象什么情况下被析构或被删除，是由指针本身决定的，并不需要用户进行手动管理，是不是瞬间觉得幸福感提升了一大截，有点幸福来得太突然的意思，终于不用我自己手动删除指针了。</p>\n<h2><a id=\"3unique_ptr_23\"></a>3.unique_ptr</h2>\n<p>unique_ptr是独享被管理对象指针所有权(owership)的智能指针。unique_ptr对象封装一个原始指针，并负责其生命周期。当该对象被销毁时，会在其析构函数中删除关联的原始指针。</p>\n<p>创建unique_ptr:</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream&gt;</span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;string&gt;</span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;memory&gt;</span></span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">f1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    unique_ptr<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">&gt;</span> <span class=\"token function\">p</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    cout<span class=\"token operator\">&lt;&lt;</span><span class=\"token operator\">*</span>p<span class=\"token operator\">&lt;&lt;</span>endl<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n</code></pre>\n<p>上面的代码就创建了一个unique_ptr。需要注意的是，unique_ptr没有复制构造函数，不支持普通的拷贝和赋值操作。因为unique_ptr独享被管理对象指针所有权，当p2, p3失去p的所有权时会释放对应资源，此时会执行两次delete p的操作。</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">void</span> <span class=\"token function\">f1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    unique_ptr<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">&gt;</span> <span class=\"token function\">p</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    cout<span class=\"token operator\">&lt;&lt;</span><span class=\"token operator\">*</span>p<span class=\"token operator\">&lt;&lt;</span>endl<span class=\"token punctuation\">;</span>\n    unique_ptr<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">&gt;</span> <span class=\"token function\">p2</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    unique_ptr<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">&gt;</span> p3 <span class=\"token operator\">=</span> p<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>对于p2,p3对应的行，IDE会提示报错</p>\n<pre><code class=\"prism language-cpp\">无法引用 函数 <span class=\"token string\">\"std::__1::unique_ptr&lt;_Tp, _Dp&gt;::unique_ptr(const std::__1::unique_ptr&lt;int, std::__1::default_delete&lt;int&gt;&gt; &amp;) [其中 _Tp=int, _Dp=std::__1::default_delete&lt;int&gt;]\"</span> <span class=\"token punctuation\">(</span>已隐式声明<span class=\"token punctuation\">)</span> <span class=\"token operator\">--</span> 它是已删除的函数\n</code></pre>\n<p>unique_ptr虽然不支持普通的拷贝和赋值操作，但却可以将所有权进行转移，使用std::move方法即可。</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">void</span> <span class=\"token function\">f1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    unique_ptr<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">&gt;</span> <span class=\"token function\">p</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    unique_ptr<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">&gt;</span> p2 <span class=\"token operator\">=</span> std<span class=\"token double-colon punctuation\">::</span><span class=\"token function\">move</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//error，此时p指针为空: cout&lt;&lt;*p&lt;&lt;endl; </span>\n    cout<span class=\"token operator\">&lt;&lt;</span><span class=\"token operator\">*</span>p2<span class=\"token operator\">&lt;&lt;</span>endl<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>unique最常见的使用场景，就是替代原始指针，为动态申请的资源提供异常安全保证。</p>\n<pre><code class=\"prism language-cpp\">objtype <span class=\"token operator\">*</span>p <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token function\">objtype</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\np <span class=\"token operator\">-&gt;</span> <span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">delete</span> p\n</code></pre>\n<p>前面我们分析了这部分代码的问题，如果我们修改一下</p>\n<pre><code class=\"prism language-cpp\">unique_ptr<span class=\"token operator\">&lt;</span>objtype<span class=\"token operator\">&gt;</span> <span class=\"token function\">p</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token function\">objtype</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\np <span class=\"token operator\">-&gt;</span> <span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">delete</span> p\n</code></pre>\n<p>此时我们只要unique_ptr创建成功，unique_ptr对应的析构函数都能保证被调用，从而保证申请的动态资源能被释放掉。</p>\n<h2><a id=\"4shared_ptr_83\"></a>4.shared_ptr</h2>\n<p>我们提到的智能指针，很大程度上就是指的shared_ptr，shared_ptr也在实际应用中广泛使用。它的原理是使用引用计数实现对同一块内存的多个引用。在最后一个引用被释放时，指向的内存才释放，这也是和 unique_ptr 最大的区别。当对象的所有权需要共享(share)时，share_ptr可以进行赋值拷贝。<br/> shared_ptr使用引用计数，每一个shared_ptr的拷贝都指向相同的内存。每使用他一次，内部的引用计数加1，每析构一次，内部的引用计数减1，减为0时，删除所指向的堆内存。</p>\n<pre><code>std::shared_ptr&lt;int&gt; p4 = new int(1)\n</code></pre>\n<p>上面这种写法是错误的，因为右边得到的是一个原始指针，前面我们讲过shared_ptr本质是一个对象，将一个指针赋值给一个对象是不行的。</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">void</span> <span class=\"token function\">f2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    shared_ptr<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">&gt;</span> p <span class=\"token operator\">=</span> <span class=\"token generic-function\"><span class=\"token function\">make_shared</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">&gt;</span></span></span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    shared_ptr<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">&gt;</span> <span class=\"token function\">p2</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    shared_ptr<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">&gt;</span> p3 <span class=\"token operator\">=</span> p<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>以上写法都是可以的</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">void</span> <span class=\"token function\">f2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    shared_ptr<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">&gt;</span> p <span class=\"token operator\">=</span> <span class=\"token generic-function\"><span class=\"token function\">make_shared</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">&gt;</span></span></span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>p2 <span class=\"token operator\">=</span> p<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    cout<span class=\"token operator\">&lt;&lt;</span><span class=\"token operator\">*</span>p2<span class=\"token operator\">&lt;&lt;</span>endl<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>上面的写法，可以获取shared_ptr的原始指针。</p>\n<h2><a id=\"5shared_ptr_112\"></a>5.shared_ptr使用需要注意的点</h2>\n<h3><a id=\"51_shared_ptr_113\"></a>5.1 不能将一个原始指针初始化多个shared_ptr</h3>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">void</span> <span class=\"token function\">f2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>p0 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    shared_ptr<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">&gt;</span> <span class=\"token function\">p1</span><span class=\"token punctuation\">(</span>p0<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    shared_ptr<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">&gt;</span> <span class=\"token function\">p2</span><span class=\"token punctuation\">(</span>p0<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    cout<span class=\"token operator\">&lt;&lt;</span><span class=\"token operator\">*</span>p1<span class=\"token operator\">&lt;&lt;</span>endl<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>上面代码就会报错。原因也很简单，因为p1,p2都要进行析构删除，这样会造成原始指针p0被删除两次，自然要报错。</p>\n<h3><a id=\"52_126\"></a>5.2.循环引用问题</h3>\n<p>shared_ptr最大的坑就是循环引用。引用网络上的一个例子：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">struct</span> <span class=\"token class-name\">Father</span>\n<span class=\"token punctuation\">{<!-- --></span>\n    shared_ptr<span class=\"token operator\">&lt;</span>Son<span class=\"token operator\">&gt;</span> son_<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">Son</span>\n<span class=\"token punctuation\">{<!-- --></span>\n    shared_ptr<span class=\"token operator\">&lt;</span>Father<span class=\"token operator\">&gt;</span> father_<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">auto</span> father <span class=\"token operator\">=</span> <span class=\"token generic-function\"><span class=\"token function\">make_shared</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>Father<span class=\"token operator\">&gt;</span></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">auto</span> son <span class=\"token operator\">=</span> <span class=\"token generic-function\"><span class=\"token function\">make_shared</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>Son<span class=\"token operator\">&gt;</span></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    father<span class=\"token operator\">-&gt;</span>son_ <span class=\"token operator\">=</span> son<span class=\"token punctuation\">;</span>\n    son<span class=\"token operator\">-&gt;</span>father_ <span class=\"token operator\">=</span> father<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n</code></pre>\n<p>该部分代码会有内存泄漏问题。原因是<br/> 1.main 函数退出之前，Father 和 Son 对象的引用计数都是 2。<br/> 2.son 指针销毁，这时 Son 对象的引用计数是 1。<br/> 3.father 指针销毁，这时 Father 对象的引用计数是 1。<br/> 4.由于 Father 对象和 Son 对象的引用计数都是 1，这两个对象都不会被销毁，从而发生内存泄露。</p>\n<p>为避免循环引用导致的内存泄露，就需要使用 weak_ptr。weak_ptr 并不拥有其指向的对象，也就是说，让 weak_ptr 指向 shared_ptr 所指向对象，对象的引用计数并不会增加。<br/> 使用 weak_ptr 就能解决前面提到的循环引用的问题，方法很简单，只要让 Son 或者 Father 包含的 shared_ptr 改成 weak_ptr 就可以了。</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">struct</span> <span class=\"token class-name\">Father</span>\n<span class=\"token punctuation\">{<!-- --></span>\n    shared_ptr<span class=\"token operator\">&lt;</span>Son<span class=\"token operator\">&gt;</span> son_<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">Son</span>\n<span class=\"token punctuation\">{<!-- --></span>\n    weak_ptr<span class=\"token operator\">&lt;</span>Father<span class=\"token operator\">&gt;</span> father_<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">auto</span> father <span class=\"token operator\">=</span> <span class=\"token generic-function\"><span class=\"token function\">make_shared</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>Father<span class=\"token operator\">&gt;</span></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">auto</span> son <span class=\"token operator\">=</span> <span class=\"token generic-function\"><span class=\"token function\">make_shared</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>Son<span class=\"token operator\">&gt;</span></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    father<span class=\"token operator\">-&gt;</span>son_ <span class=\"token operator\">=</span> son<span class=\"token punctuation\">;</span>\n    son<span class=\"token operator\">-&gt;</span>father_ <span class=\"token operator\">=</span> father<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>1.main 函数退出前，Son 对象的引用计数是 2，而 Father 的引用计数是 1。<br/> 2.son 指针销毁，Son 对象的引用计数变成 1。<br/> 3.father 指针销毁，Father 对象的引用计数变成 0，导致 Father 对象析构，Father 对象的析构会导致它包含的 son_ 指针被销毁，这时 Son 对象的引用计数变成 0，所以 Son 对象也会被析构。</p>\n<h2><a id=\"6_188\"></a>6.智能指针小结</h2>\n<p>我们该如何选择智能指针：</p>\n<p>如果程序要使用多个指向同一个对象的指针，应选择 shared_ptr。这样的情况包括<br/> 1.有一个指针数组，并使用一些辅助指针来标示特定的元素，如最大的元素和最小的元素；<br/> 2.两个对象包含都指向第三个对象的指针；<br/> 3.STL 容器包含指针。很多 STL 算法都支持复制和赋值操作，这些操作可用于 shared_ptr，但不能用于 unique_ptr（编译器发出 warning）和 auto_ptr（行为不确定）。如果你的编译器没有提供 shared_ptr，可使用 Boost 库提供的 shared_ptr。</p>\n<p>如果程序不需要多个指向同一个对象的指针，则可使用 unique_ptr。如果函数使用 new 分配内存，并返还指向该内存的指针，将其返回类型声明为 unique_ptr 是不错的选择。这样，所有权转让给接受返回值的 unique_ptr，而该智能指针将负责调用 delete。</p>\n<h2><a id=\"_198\"></a>参考文献</h2>\n<p>https://zhuanlan.zhihu.com/p/461837602</p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}