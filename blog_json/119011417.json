{"blogid": "119011417", "writerAge": "码龄4年", "writerBlogNum": "120", "writerCollect": "3713", "writerComment": "156", "writerFan": "5008", "writerGrade": "5级", "writerIntegral": "3594", "writerName": "Code0cean", "writerProfileAdress": "writer_image\\profile_119011417.jpg", "writerRankTotal": "4414", "writerRankWeekly": "1308", "writerThumb": "798", "writerVisitNum": "333502", "blog_read_count": "248", "blog_time": "于 2022-09-04 23:43:33 发布", "blog_title": "MySQL锁机制详解-表锁与行锁", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-light\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p></p>\n<div class=\"toc\">\n<h3>文章目录</h3>\n<ul><li><ul><li><a href=\"#1__1\">1. 数据库锁理论</a></li><li><a href=\"#2__8\">2. 锁的分类</a></li><li><ul><li><a href=\"#21__9\">2.1 按数据操作的类型分类</a></li><li><a href=\"#22__16\">2.2 按数据操作的颗粒度分类</a></li></ul>\n</li><li><a href=\"#3__29\">3. 表锁的应用</a></li><li><ul><li><a href=\"#31__32\">3.1 表锁相关命令</a></li><li><a href=\"#32__66\">3.2 给表加表共享读锁</a></li><li><a href=\"#33__94\">3.3 给表加表独占写锁</a></li><li><a href=\"#34__99\">3.4 意向共享锁和意向排他锁</a></li><li><a href=\"#35__120\">3.5 并发插入</a></li><li><a href=\"#36_MyISAM_143\">3.6 MyISAM锁调度机制</a></li><li><a href=\"#37__149\">3.7 总结</a></li></ul>\n</li><li><a href=\"#4__156\">4. 行锁的应用</a></li><li><ul><li><a href=\"#41__157\">4.1 基本介绍</a></li><li><a href=\"#42__196\">4.2 行锁的使用</a></li><li><a href=\"#43__249\">4.3 行锁的算法</a></li><li><ul><li><a href=\"#431_Record_Lock_255\">4.3.1 Record Lock</a></li><li><a href=\"#432_Gap_Lock_264\">4.3.2 Gap Lock</a></li><li><a href=\"#433_Nextkey_Lock_279\">4.3.3 Next-key Lock</a></li></ul>\n</li><li><a href=\"#44__297\">4.4 分析行锁的争夺情况</a></li><li><a href=\"#45__314\">4.5 死锁和避免死锁</a></li><li><a href=\"#46__324\">4.6 总结</a></li></ul>\n</li><li><a href=\"#5__338\">5. 页锁</a></li><li><a href=\"#6__342\">6. 隔离级别与锁的关系</a></li><li><a href=\"#7__352\">7. 数据库的乐观锁和悲观锁</a></li><li><a href=\"#8__367\">8. 总结</a></li></ul>\n</li></ul>\n</div>\n<p></p>\n<h2><a id=\"1__1\"></a>1. 数据库锁理论</h2>\n<p>锁是计算机协调多个进程或线程并发访问某一资源的机制。</p>\n<p>在数据库中，除传统的计算机资源，如CPU、RAM、I/O等的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题。此外，锁冲突也是影响数据库并发访问性能的一个重要因素。</p>\n<p>我们到淘宝上买一件商品，商品只有一件库存，这个时候如果还有另一个人买，那么如何解决是你买还是别人买到的问题呢？这里就涉及到了事务，我们先从库存表取出物品数量，然后插入订单，付款后插入付款表信息，然后更新商品数量。在这个过程中，使用锁可以对有限的资源进行保护，解决隔离和并发的问题。</p>\n<h2><a id=\"2__8\"></a>2. 锁的分类</h2>\n<h3><a id=\"21__9\"></a>2.1 按数据操作的类型分类</h3>\n<p>锁的分类，按数据操作的类型划分，分为读锁和写锁：</p>\n<ul><li> <p>读锁（共享锁，Share Lock）：针对同一份数据，多个读操作可以同时进行而不会互相影响。若事务T对数据对象A加上读锁，则<mark>事务T只能读A；其他事务只能再对A加读锁，而不能加写锁</mark>，直到事务T释放A上的读锁。这就保证了其他事务可以读A，但在事务T释放A上的读锁之前不能对A做任何修改。</p> </li><li> <p>写锁（排它锁，Exclusive Lock）：写锁只可以加一个，当前写操作没有完成前，它会阻断其他写锁和读锁。若事务T对数据对象A加上写锁，则只允许事务T<mark>读取和修改</mark>A，<mark>其它任何事务都不能再对A加任何类型的锁，直到T释放A上的锁</mark>。它防止任何其它事务获取资源上的锁，直到在事务的末尾将资源上的原始锁释放为止。在更新操作(<code>INSERT、UPDATE 或 DELETE</code>)过程中始终应用排它锁。</p> </li></ul>\n<h3><a id=\"22__16\"></a>2.2 按数据操作的颗粒度分类</h3>\n<p>在关系型数据库中，按数据操作的颗粒度划分，分为表锁，行锁和页锁。表锁，行锁和页锁的对比如下：</p>\n<ul><li><strong>表锁</strong>：MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MyISAM与InnoDB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。</li></ul>\n<p>特点：表锁开销小，加锁快，无死锁，锁定粒度大，发生锁冲突的概率最高，并发最低</p>\n<ul><li><strong>行锁</strong>：MySQL中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁和排他锁。InnoDB存储引擎默认采用行锁。InnoDB与MyISAM的最大不同有两点：一是支持事务（TRANSACTION）;二是采用了行级锁</li></ul>\n<p>特点：行锁开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</p>\n<ul><li><strong>页锁</strong>：页锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。</li></ul>\n<p>特点：开销和加锁时间界于表锁和行锁之间：会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</p>\n<h2><a id=\"3__29\"></a>3. 表锁的应用</h2>\n<p>表锁对当前操作的整张表加锁，实现简单 ，<mark>资源消耗也比较少，加锁快，不会出现死锁 。触发锁冲突的概率最高，并发度最低，MyISAM和 InnoDB引擎都支持表级锁</mark>。在 MyISAM 存储引擎中，会自动为 <code>select</code>语句加上共享锁，为 <code>update/delete/insert</code> 操作加上排他锁。</p>\n<h3><a id=\"31__32\"></a>3.1 表锁相关命令</h3>\n<p><strong>（1）手动添加表锁</strong></p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">lock</span> <span class=\"token keyword\">table</span> 表名字 <span class=\"token keyword\">read</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">write</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>表名字<span class=\"token number\">2</span> <span class=\"token keyword\">read</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">write</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<p><strong>（2）查看表上加过的锁的命令</strong></p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">show</span> <span class=\"token keyword\">open</span> <span class=\"token keyword\">tables</span>\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\22017d4f0ba9442b9319cca761c75845.png\"/></p>\n<p><strong>（3）释放表锁的命令</strong></p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">unlock</span> <span class=\"token keyword\">tables</span>\n</code></pre>\n<p><strong>（4）分析表锁定的命令</strong></p>\n<pre><code class=\"prism language-sql\"> <span class=\"token keyword\">show</span> <span class=\"token keyword\">status</span>  <span class=\"token operator\">like</span> <span class=\"token string\">'table%'</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\be68eb99829e4687ba6b7606caea054f.png\"/><br/> 我们可以通过检查<code>table_locks_waited</code>和<code>table_locks_immediate</code>状态变量来分析系统的表锁定情况。两个变量的说明如下：</p>\n<ul><li><code>table_locks_waited</code>：表示不能立即获取锁，需要等待锁的次数</li><li><code>table_locks_immediate</code>：可以立即获取锁的次数</li></ul>\n<p>如果<code>table_locks_waited</code>的值比较高，则说明存在着较严重的表级锁争用情况。这时，需要我们对应用做进一步的检查，来确定问题所在。</p>\n<h3><a id=\"32__66\"></a>3.2 给表加表共享读锁</h3>\n<p>表共享读锁，加了共享读锁的表，不会阻塞其他 session 的读请求，但是会阻塞其他 session 的写请求。</p>\n<p>创建数据的SQL：</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">create</span> <span class=\"token keyword\">table</span> mylock <span class=\"token punctuation\">(</span>\nid <span class=\"token keyword\">int</span> <span class=\"token operator\">not</span> <span class=\"token boolean\">null</span> <span class=\"token keyword\">primary</span> <span class=\"token keyword\">key</span> <span class=\"token keyword\">auto_increment</span><span class=\"token punctuation\">,</span>\nname <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">default</span> <span class=\"token string\">''</span>\n<span class=\"token punctuation\">)</span> <span class=\"token keyword\">engine</span> myisam<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">insert</span> <span class=\"token keyword\">into</span> mylock<span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span> <span class=\"token keyword\">values</span><span class=\"token punctuation\">(</span><span class=\"token string\">'a'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">insert</span> <span class=\"token keyword\">into</span> mylock<span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span> <span class=\"token keyword\">values</span><span class=\"token punctuation\">(</span><span class=\"token string\">'b'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">insert</span> <span class=\"token keyword\">into</span> mylock<span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span> <span class=\"token keyword\">values</span><span class=\"token punctuation\">(</span><span class=\"token string\">'c'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">insert</span> <span class=\"token keyword\">into</span> mylock<span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span> <span class=\"token keyword\">values</span><span class=\"token punctuation\">(</span><span class=\"token string\">'d'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">insert</span> <span class=\"token keyword\">into</span> mylock<span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span> <span class=\"token keyword\">values</span><span class=\"token punctuation\">(</span><span class=\"token string\">'e'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">### 3.1 读锁</span>\n</code></pre>\n<p>以给mylock表加read锁(读阻塞写例子)<br/> <img alt=\"在这里插入图片描述\" src=\"image\\2ede1da657224202ad8a80be635d9302.png\"/></p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\1d1b6c0dc780461a86bd4c847b4745ad.png\"/><br/> 总结：</p>\n<p>加了共享读锁的表，不会阻塞其他 session 的读（select）请求，但是会阻塞当前session和其他 session 的写（insert、update、delete）请求。</p>\n<h3><a id=\"33__94\"></a>3.3 给表加表独占写锁</h3>\n<p>独占写锁就是大家锁所熟知的排他锁，它会阻塞其他进程对同一表的读写操作，只有当当前的排他锁释放后，才会执行其他进程的读写操作。<br/> <img alt=\"在这里插入图片描述\" src=\"image\\b5cc6a8371f745349a83fbd1f3306691.png\"/><br/> 加了写锁后，当前会话不能对其他表进行读写操作，而其他会话可以对其他表进行读写操作。<br/> <img alt=\"在这里插入图片描述\" src=\"image\\11933f19a506420fab754a744884a1aa.png\"/></p>\n<h3><a id=\"34__99\"></a>3.4 意向共享锁和意向排他锁</h3>\n<p>当一个事务需要给自己需要的某个资源加锁的时候，如果遇到一个共享锁正锁定着自己需要的资源的时候，自己可以再加一个共享锁，不过不能加排他锁。但是，如果遇到自己需要锁定的资源已经被一个排他锁占有之后，则只能等待该锁定释放资源之后自己才能获取锁定资源并添加自己的锁定。</p>\n<p><strong>InnoDB支持多粒度锁，允许行锁和表锁共存</strong>。<strong>意向锁是表级锁</strong>，意向锁的作用是指示事务稍后需要对表中的一行使用哪种类型的锁(共享锁或排他锁)。就是当一个事务在需要获取资源锁定的时候，如果遇到自己需要的资源已经被排他锁占用的时候，该事务可以需要锁定行的表上面添加一个合适的意向锁。如果自己需要一个共享锁，那么就在表上面添加一个意向共享锁。而如果自己需要的是某行（或者某些行）上面添加一个排他锁的话，则先在表上面添加一个意向排他锁。<strong>意向共享锁可以同时并存多个，但是意向排他锁同时只能有一个存在。</strong></p>\n<p>InnoDB存储引擎的两个表级锁：</p>\n<ul><li> <p>意向共享锁（IS）： 表示事务准备给数据行记入共享锁，事务在一个数据行加共享锁前必须先取得该表的IS锁。</p> </li><li> <p>意向排他锁（IX）： 表示事务准备给数据行加入排他锁，事务在一个数据行加排他锁前必须先取得该表的IX锁。</p> </li></ul>\n<p>注意：</p>\n<ul><li>这里的意向锁是表级锁，<mark>表示的是一种意向，仅仅表示事务正在读或写某一行记录，在真正加行锁时才会判断是否冲突。意向锁是InnoDB自动加的，不需要用户干预。</mark></li><li>IX，IS是表级锁，不会和行级的X，S锁发生冲突，只会和表级的X，S发生冲突。</li></ul>\n<p>InnoDB的锁机制兼容情况如下图所示：<br/> <img alt=\"在这里插入图片描述\" src=\"image\\71fd35271dc7403d8f40073d2271b6fd.png\"/></p>\n<p>当一个事务请求的锁模式与当前的锁兼容，InnoDB就将请求的锁授予该事务；反之如果请求不兼容，则该事物就等待锁释放。</p>\n<h3><a id=\"35__120\"></a>3.5 并发插入</h3>\n<p>为减少读写锁之间的争抢，MyISAM存储引擎支持并发插入。我们可以使用local关键字实现一个表加了读锁，其他session对该表的写操作依然可以执行。但是只有当当前持有读锁的session释放读锁后，其他session的写操作结果才可见。语法如下：</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">lock</span> <span class=\"token keyword\">table</span> 表名 <span class=\"token keyword\">read</span> <span class=\"token keyword\">local</span>\n</code></pre>\n<p>这样在当前表被加读锁的时候，可以让其他session往表里添加记录，但需要配合<code>concurrent_insert</code>全局变量使用。MySQL的 <code>concurrent_insert</code>参数用枚举值及含义如下：</p>\n<ul><li><strong>NEVER</strong>：加读锁后，不允许其他session并发写入</li><li><strong>AUTO</strong>：加读锁后，在表里<strong>没有空洞(就是没有删除过行)的条件</strong>下，允许其他session并发写入</li><li><strong>ALWAYS</strong>：加读锁后，允许其他session并发写入，即使是有空洞的表</li></ul>\n<p>查看当前数据库的设置：</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">show</span> <span class=\"token keyword\">global</span> variables <span class=\"token operator\">like</span> <span class=\"token string\">'%concurrent_insert%'</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\0e0e05adaf0b4a6ead43ecdd80c14877.png\"/></p>\n<p>改变数据库设置：</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">set</span> <span class=\"token keyword\">global</span> concurrent_insert <span class=\"token operator\">=</span> ALWAYS<span class=\"token punctuation\">;</span>\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\4f6642390dc343779fba8c200943dd62.png\"/></p>\n<h3><a id=\"36_MyISAM_143\"></a>3.6 MyISAM锁调度机制</h3>\n<p>对于仅使用表级锁的存储引擎(如 MyISAM 、MEMORY 和 MERGE)，写进程的优先级高于读进程，尽管读进程在队列的头部，写进程也会插队。通过设置系统变量 low-priority-updates=1，所有的 <code>INSERT、UPDATE、DELETE和 LOCK TABLE WRITE</code> 语句都将等待，直到受影响的表上没有挂起的 <code>SELECT</code> 或 <code>LOCK TABLE</code> 读操作。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\203907b9c0194a8280940f933fa658c0.png\"/></p>\n<h3><a id=\"37__149\"></a>3.7 总结</h3>\n<ul><li>共享读锁之间是兼容的，但共享读锁与独占写锁之间，以及独占写锁之间是互斥的，也就是说读和写是串行的。</li><li>在一定条件下，MyISAM允许查询和插入并发执行，我们可以利用这一点来解决应用中对同一表查询和插入的锁争用问题。</li><li>MyISAM默认的锁调度机制是写优先，这并不一定适合所有应用，用户可以通过设置<code>LOW_PRIORITY_UPDATES</code>参数，或在<code>INSERT、UPDATE、DELETE</code>语句中指定<code>LOW_PRIORITY</code>选项来调节读写锁的争用。</li><li>由于表锁的锁定粒度大，读写之间又是串行的，因此，如果更新操作较多，MyISAM表可能会出现严重的锁等待，可以考虑采用InnoDB存储引擎来减少锁冲突。</li></ul>\n<h2><a id=\"4__156\"></a>4. 行锁的应用</h2>\n<h3><a id=\"41__157\"></a>4.1 基本介绍</h3>\n<p>InnoDB存储引擎默认采用行锁，<mark>行级锁锁定粒度最小，发生锁冲突的概率最低，并发度也最高。但是行锁开销大，加锁慢，会出现死锁</mark>。 InnoDB是<mark>基于索引来完成行锁</mark>，例如:</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> tab_with_index <span class=\"token keyword\">where</span> id <span class=\"token operator\">=</span> <span class=\"token number\">1</span> <span class=\"token keyword\">for</span> <span class=\"token keyword\">update</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p><code>for update</code> 可以根据条件来完成行锁锁定，并且 ID 是有索引键的列，<mark>如果 ID不是索引键那么InnoDB将完成表锁。</mark></p>\n<p>InnoDB与MyISAM的最大不同有两点：<mark>1.支持事务 2.采用行级锁</mark>。</p>\n<blockquote>\n<p>MySQL事务是由一组SQL语句组成的逻辑处理单元，事务具有以下4个属性，通常简称为事务的ACID特性。</p>\n<ol><li>原⼦性（Atomicity）： 事务是最⼩的执⾏单位，不允许分割。事务的原⼦性确保动作要么全部完成，要么完全不起作⽤；</li><li>⼀致性（Consistency）： 执⾏事务前后，数据都必须保持一致状态，多个事务对同⼀个数据读取的结果是相同的；</li><li>隔离性（Isolation）： 数据库系统提供一定的隔离机制，并发访问数据库时，⼀个⽤户的事务不被其他事务所⼲扰，各并发事务之间数据库是独⽴的；</li><li>持久性（Durability）： ⼀个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发⽣故障也不应该对其有任何影响。</li></ol>\n</blockquote>\n<p>在典型的应⽤程序中，多个事务并发运⾏，经常会操作相同的数据来完成各⾃的任务（多个⽤户<br/> 对同⼀数据进⾏操作）。并发虽然是必须的，但可能会导致以下的问题。</p>\n<blockquote>\n<ol><li>脏读（Dirty read）: 当⼀个事务正在访问数据并且对数据进⾏了修改，⽽这种修改还没有提交到数据库中，这时另外⼀个事务也访问了这个数据，然后使⽤了这个数据。因为这个数据是还没有提交的数据，那么另外⼀个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</li><li>丢失修改（Lost to modify）: 指在⼀个事务读取⼀个数据时，另外⼀个事务也访问了该数据，那么在第⼀个事务中修改了这个数据后，第⼆个事务也修改了这个数据。这样第⼀个事务内的修改结果就被丢失，因此称为丢失修改。<br/> 例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。</li><li>不可重复读（Unrepeatableread）: 指在⼀个事务内多次读同⼀数据。在这个事务还没有结 束时，另⼀个事务也访问该数据。那么，在第⼀个事务中的两次读数据之间，由于第⼆个事务的修改导致第⼀个事务两次读取的数据可能不太⼀样。这就发⽣了在⼀个事务内两次读到的数据是不⼀样的情况，因此称为不可重复读。</li><li>幻读（Phantom read）: 幻读与不可重复读类似。它发⽣在⼀个事务（T1）读取了⼏⾏数据，接着另⼀个并发事务（T2）插⼊了⼀些数据时。在随后的查询中，第⼀个事务（T1）就会发现多了⼀些原本不存在的记录，就好像发⽣了幻觉⼀样，所以称为幻读。</li></ol>\n<p>不可重复读和幻读区别： 不可重复读的重点是修改⽐如多次读取⼀条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除，⽐如多次读取⼀条记录发现记录增多或减少了。</p>\n</blockquote>\n<p>MySQL的事务隔离级别有四种：</p>\n<blockquote>\n<ul><li>READ-UNCOMMITTED(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更， 可能会导致脏读、幻读或不可重复读。</li><li>READ-COMMITTED(读取已提交)： 允许读取并发事务已经提交的数据，可以阻⽌脏读，但 是幻读或不可重复读仍有可能发⽣。</li><li>REPEATABLE-READ(可重复读)： 对同⼀字段的多次读取结果都是⼀致的，除⾮数据是被 本身事务⾃⼰所修改，可以阻⽌脏读和不可重复读，但幻读仍有可能发⽣。</li><li>SERIALIZABLE(可串⾏化)： 最⾼的隔离级别，完全服从ACID的隔离级别。所有的事务依 次逐个执⾏，这样事务之间就完全不可能产⽣⼲扰，也就是说，该级别可以防⽌脏读、不可 重复读以及幻读。</li></ul>\n</blockquote>\n<p>MySQL InnoDB 存储引擎的<mark>默认⽀持的隔离级别是 REPEATABLE-READ（可重复读）</mark>。</p>\n<h3><a id=\"42__196\"></a>4.2 行锁的使用</h3>\n<p>建表SQL：</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> test_innodb_lock <span class=\"token punctuation\">(</span>\na <span class=\"token keyword\">INT</span><span class=\"token punctuation\">(</span><span class=\"token number\">11</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\nb <span class=\"token keyword\">VARCHAR</span><span class=\"token punctuation\">(</span><span class=\"token number\">16</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span><span class=\"token keyword\">ENGINE</span><span class=\"token operator\">=</span><span class=\"token keyword\">INNODB</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">insert</span> <span class=\"token keyword\">into</span> test_innodb_lock <span class=\"token keyword\">values</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token string\">'b2'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">insert</span> <span class=\"token keyword\">into</span> test_innodb_lock <span class=\"token keyword\">values</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token string\">'2000'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">insert</span> <span class=\"token keyword\">into</span> test_innodb_lock <span class=\"token keyword\">values</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token string\">'3000'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">insert</span> <span class=\"token keyword\">into</span> test_innodb_lock <span class=\"token keyword\">values</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token string\">'4000'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">insert</span> <span class=\"token keyword\">into</span> test_innodb_lock <span class=\"token keyword\">values</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span><span class=\"token string\">'5000'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">insert</span> <span class=\"token keyword\">into</span> test_innodb_lock <span class=\"token keyword\">values</span><span class=\"token punctuation\">(</span><span class=\"token number\">6</span><span class=\"token punctuation\">,</span><span class=\"token string\">'6000'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">insert</span> <span class=\"token keyword\">into</span> test_innodb_lock <span class=\"token keyword\">values</span><span class=\"token punctuation\">(</span><span class=\"token number\">7</span><span class=\"token punctuation\">,</span><span class=\"token string\">'7000'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">create</span> <span class=\"token keyword\">index</span> idx_a <span class=\"token keyword\">on</span> test_innodb_lock<span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">create</span> <span class=\"token keyword\">index</span> idx_b <span class=\"token keyword\">on</span> test_innodb_lock<span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>普通的 select 语句是不会对记录加锁的，如果要在查询时对记录加行锁，可以使用下面这两个方式：</p>\n<pre><code class=\"prism language-sql\"><span class=\"token comment\">#对读取的记录加共享锁</span>\n<span class=\"token keyword\">select</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token keyword\">from</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token keyword\">where</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token keyword\">lock</span> <span class=\"token operator\">in</span> <span class=\"token keyword\">share</span> <span class=\"token keyword\">mode</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">#对读取的记录加独占锁</span>\n<span class=\"token keyword\">select</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token keyword\">from</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token keyword\">where</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token keyword\">for</span> <span class=\"token keyword\">update</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>上面这两条语句必须在一个事务中，因为当事务提交了，锁就会被释放，所以在使用这两条语句的时候，要加上 begin、start transaction 或者取消自动提交。<br/> 取消自动提交命令：</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">set</span> autocommit <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>行锁演示：<br/> 通过for update 给某一行上行锁<br/> <img alt=\"在这里插入图片描述\" src=\"image\\24c723e757d045d0afd8f33d3d2a2f2e.png\"/></p>\n<p>两个会话更新同一行，2号会话会阻塞。<br/> <img alt=\"在这里插入图片描述\" src=\"image\\91b38b4c20404876be5c3cec36d4082f.png\"/></p>\n<p>两个会话更新不同的行，1号会话更新a=1,而2号会话更新其他行可以正常更新不会阻塞。<br/> <img alt=\"在这里插入图片描述\" src=\"image\\9b3d1fd937724a2ca080df4f177a0a13.png\"/><br/> 注意：<mark>索引未生效或查询条件没有建立索引，会导致行锁变表锁，如varchar 不用 ’ ’ 导致系统自动转换类型，使得索引失效。</mark></p>\n<p>在索引失效的情况下，行锁变成了使用表锁，会话2 的更新操作阻塞，直至会话1释放持有的表锁。<br/> <img alt=\"在这里插入图片描述\" src=\"image\\294c47d943c34f93b2f42e21055029cc.png\"/><br/> 索引未失效的情况，使用行锁，不会导致会话2 的更新操作阻塞<br/> <img alt=\"在这里插入图片描述\" src=\"image\\cc6c2e9c3f854a26a5dc5ef80e022343.png\"/></p>\n<h3><a id=\"43__249\"></a>4.3 行锁的算法</h3>\n<p>InnoDB存储引擎行锁的算法有三种：</p>\n<ul><li><strong>Record Lock</strong>: 对索引项加锁，锁定符合条件的行。其他事务不能修改和删除加锁项；</li><li><strong>Gap Lock:</strong> 对索引项之间的“间隙”加锁，锁定记录的范围（对第一条记录前的间隙或最后一条将记录后的间隙加锁），不包含索引项本身。其他事务不能在锁范围内插入数据，这样就防止了别的事务新增幻影行。</li><li><strong>Next-key Lock</strong>： 锁定索引项本身和索引范围。即<strong>Record Lock</strong>和<strong>Gap Lock</strong>的结合。可解决幻读问题。</li></ul>\n<h4><a id=\"431_Record_Lock_255\"></a>4.3.1 Record Lock</h4>\n<p>Innodb对于行的查询使用<strong>Next-key Lock</strong>，<strong>Next-key Lock</strong>为了解决Phantom Problem幻读问题。</p>\n<p>当查询的索引含有唯一属性时，将<strong>Next-key Lock降级为Record Lock</strong>。如下SQL：</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">SELECT</span> id <span class=\"token keyword\">FROM</span> <span class=\"token keyword\">user</span> <span class=\"token keyword\">WHERE</span> id <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>当id列为唯一索引列，对id=1的索引记录进行加锁，此时使用的是Record Lock。</p>\n<h4><a id=\"432_Gap_Lock_264\"></a>4.3.2 Gap Lock</h4>\n<p>Gap Lock间隙锁是在索引记录之间的间隙上的锁，或者是在第一个索引记录之前或最后一个索引记录之后的间隙上的锁。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\ef8c0715af3b48e4b261676ee897921d.png\"/><br/> 可以看到不能在test_innnodb_lock表上的a列插入值2，因为a列当前范围(1,5)的间隙被加上了间隙锁。</p>\n<p>当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，<mark>InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP）”。InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁）。</mark></p>\n<p>间隙锁有一个比较致命的弱点，就是当锁定一个范围键值之后，即使某些不存在的键值也会被锁定，而造成在锁定的时候无法插入锁定键值范围内的任何数据。在某些场景下这可能会对性能造成很大的危害。</p>\n<p>Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生。<br/> 有两种方式显式关闭Gap Lock间隙锁：（除了外键约束和唯一性检查外，其余情况仅使用record lock）</p>\n<ul><li>将事务隔离级别设置为<strong>READ-COMMITTED</strong>(读取已提交)</li><li>将参数<code>innodb_locks_unsafe_for_binlog</code>设置为1</li></ul>\n<h4><a id=\"433_Nextkey_Lock_279\"></a>4.3.3 Next-key Lock</h4>\n<p>Next-key Lock 锁定索引项本身和索引范围，即Record Lock和Gap Lock的结合，可解决幻读问题。</p>\n<p>例子：当事务 T1 对 r行 加 共享 或 排他锁时，同时会对 r行 前的间隙加 间隙锁，此时，另一个事务 T2 无法在 r行 之前插入新的索引记录。<br/> 假设一个索引包含值10、11、13和20。该索引可能的 Next-Key Locks覆盖以下区间：</p>\n<blockquote>\n<p>(-∞, 10]<br/> (10, 11]<br/> (11, 13]<br/> (13, 20]<br/> (20, +∞)<br/> 对于最后一个间隔，Next-Key Locks 锁定了索引中最大值之上的间隙和“正无穷”伪记录，该伪记录的值高于索引中任何实际值。其并不是一个真正的索引记录，因此，实际上，这个 Next-Key Locks 只锁定最大索引值后面的间隙。</p>\n</blockquote>\n<p>默认情况下，InnoDB操作在 <strong>可重复读(REPEATABLE READ)</strong> 事务隔离级别。在这种情况下，InnoDB使用Next-Key Locks进行搜索和索引扫描，这样可以防止幻读。</p>\n<blockquote>\n<p>关于行锁的更多学习： <a href=\"https://mp.weixin.qq.com/s/1LGJjbx_n_cvZndjM3R8mQ\">https://mp.weixin.qq.com/s/1LGJjbx_n_cvZndjM3R8mQ</a></p>\n</blockquote>\n<h3><a id=\"44__297\"></a>4.4 分析行锁的争夺情况</h3>\n<p>通过检查InnoDB_row_lock状态变量来分析系统上的行锁的争夺情况，命令如下:</p>\n<pre><code class=\"prism language-sql\"> <span class=\"token keyword\">show</span> <span class=\"token keyword\">status</span> <span class=\"token operator\">like</span> <span class=\"token string\">'innodb_row_lock%'</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\79f1f46be12745499b92dce857f32512.png\"/><br/> 各个状态量的说明如下：</p>\n<ul><li><code>innodb_row_lock_current_waits</code>:当前正在等待锁定的数量；</li><li><code>innodb_row_lock_time</code>:从系统启动到现在锁定总时间长度（等待总时长）</li><li><code>innodb_row_lock_time_avg</code>:每次等待所花平均时间（等待平均时长）</li><li><code>innodb_row_lock_time_max</code>:从系统启动到现在等待最长的一次所花事件</li><li><code>innodb_row_lock_waits</code>：系统启动后到现在总共等待的次数（等待总次数）</li></ul>\n<p>当等待次数很高，而且每次等待时长也不小的时候，我们就需要分析系统中为什么会有如此多的等待，然后根据分析结果着手指定优化计划。</p>\n<h3><a id=\"45__314\"></a>4.5 死锁和避免死锁</h3>\n<p>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。</p>\n<p><mark>InnoDB的行级锁是基于索引实现的，如果查询语句没有命中任何索引，那么InnoDB会使用表级锁</mark>.。此外，InnoDB的行级锁是针对索引加的锁，不针对数据记录，因此即使访问不同行的记录，如果使用了相同的索引键仍然会出现锁冲突。</p>\n<p>此外，<mark>不同于MyISAM总是一次性获得所需的全部锁，InnoDB的锁是逐步获得的，当两个事务都需要获得对方持有的锁，导致双方都在等待，这就产生了死锁</mark>。 发生死锁后，InnoDB一般都可以检测到，并使一个事务释放锁回退，另一个则可以获取锁完成事务，我们可以采取以上方式避免死锁：</p>\n<ul><li><strong>通过表级锁来减少死锁产生的概率</strong>。对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率</li><li><strong>多个程序尽量约定以相同的顺序访问表</strong>。如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁的产生概率。</li><li><strong>同一个事务尽可能做到一次锁定所需要的所有资源</strong>，这样可以减少死锁产生概率</li></ul>\n<h3><a id=\"46__324\"></a>4.6 总结</h3>\n<p>InnoDB存储引擎由于实现了行级锁定，虽然在锁定机制的实现方面所带来的性能损耗可能比表级锁定会更高一些，但是在整体并发处理能力方面要远远优于MyISAM的表级锁定的。当系统并发量较高的时候，InnoDB的整体性能和MyISAM相比就会有比较明显的优势了。</p>\n<p>但是，InodbDB的行级锁同样也有其脆弱的一面，当我们使用不当的时候，可能会让InnoDB的整体性能表现不仅不能比MyISAM高，甚至可能会更差。</p>\n<p>使用InnoDB存储引擎的优化建议：</p>\n<ol><li>尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁</li><li>合理设计索引，尽量缩小锁的范围</li><li>尽可能较少检索条件，避免间隙锁</li><li>尽量控制事务大小，减少锁定资源量和时间长度</li><li>尽可能低级别事务隔离</li></ol>\n<h2><a id=\"5__338\"></a>5. 页锁</h2>\n<p>页锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。页级进行了折衷，一次锁定相邻的一组记录。BDB存储引擎支持页级锁。开销和加锁时间界于表锁和行锁之间，会出现死锁。锁定粒度界于表锁和行锁之间，并发度一般。</p>\n<h2><a id=\"6__342\"></a>6. 隔离级别与锁的关系</h2>\n<p>在<strong>读取未提交Read Uncommitted</strong>级别下，读取数据不需要加共享锁，这样就不会跟被修改的数据上的排他锁冲突</p>\n<p>在<strong>读取已提交Read Committed</strong>级别下，读操作需要加共享锁，但是在语句执行完以后释放共享锁。</p>\n<p>在<strong>可重复读Repeatable Read</strong>级别下，读操作需要加共享锁，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁。</p>\n<p><strong>可串行化SERIALIZABLE</strong>是限制性最强的隔离级别，因为该级别锁定整个范围的键，并一直持有锁，直到事务完成。</p>\n<h2><a id=\"7__352\"></a>7. 数据库的乐观锁和悲观锁</h2>\n<p>数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。</p>\n<ul><li>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。</li></ul>\n<p>悲观锁的实现方式：使用数据库中的锁机制</p>\n<ul><li>乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过Version的方式来进行锁定。</li></ul>\n<p>乐观锁的实现方式：一般会使用版本号机制或CAS算法实现。</p>\n<p>关于两种锁的使用场景，从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。</p>\n<p>但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行Retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。</p>\n<h2><a id=\"8__367\"></a>8. 总结</h2>\n<p>MyISAM和InnoDB存储引擎使用的锁：</p>\n<ul><li>MyISAM采用表级锁(table-level locking)。</li><li>InnoDB支持行级锁(row-level locking)和表级锁,默认为行级锁</li></ul>\n<p>表级锁和行级锁，和页锁的对比：</p>\n<ul><li>表级锁： Mysql中锁定<strong>粒度最大</strong>的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和 InnoDB引擎都支持表级锁。</li></ul>\n<p>特点：开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。</p>\n<ul><li>行级锁： Mysql中锁定 <strong>粒度最小</strong> 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。</li></ul>\n<p>特点：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</p>\n<ul><li>页级锁： BDB存储引擎支持页级锁。MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。页级进行了折衷，一次锁定相邻的一组记录。</li></ul>\n<p>特点：开销和加锁时间界于表锁和行锁之间，会出现死锁。锁定粒度界于表锁和行锁之间，并发度一般。</p>\n<p>从上述特点可见，很难笼统地说哪种锁更好，只能就具体应用的特点来说哪种锁更合适！仅从锁的角度来说：表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用。</p>\n<blockquote>\n<p>参考：<br/> 1.<a href=\"https://blog.csdn.net/qq_34337272/article/details/80611486\">https://blog.csdn.net/qq_34337272/article/details/80611486</a><br/> 2.<a href=\"https://mp.weixin.qq.com/s/rFBFwzsDvoqptTubAqyuFQ\">https://mp.weixin.qq.com/s/rFBFwzsDvoqptTubAqyuFQ</a><br/> 3.<a href=\"https://zhuanlan.zhihu.com/p/123962424\">https://zhuanlan.zhihu.com/p/123962424</a></p>\n</blockquote>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}