{"blogid": "124078060", "writerAge": "码龄2年", "writerBlogNum": "1", "writerCollect": "101", "writerComment": "5", "writerFan": "26", "writerGrade": "1级", "writerIntegral": "31", "writerName": "菜猿进阶ing", "writerProfileAdress": "writer_image\\profile_124078060.jpg", "writerRankTotal": "193558", "writerRankWeekly": "486677", "writerThumb": "16", "writerVisitNum": "5676", "blog_read_count": "5669", "blog_time": "已于 2022-04-25 16:11:40 修改", "blog_title": "王道C语言督学营oj练习（全部更新完成）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E5%88%9D%E7%BA%A7%E9%98%B6%E6%AE%B5-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%88%9D%E7%BA%A7%E9%98%B6%E6%AE%B5\">初级阶段</a></p>\n<p id=\"week1-day1%E4%BD%9C%E4%B8%9A-toc\" style=\"margin-left:80px;\"><a href=\"#week1-day1%E4%BD%9C%E4%B8%9A\">week1-day1作业</a></p>\n<p id=\"week1-day2%E4%BD%9C%E4%B8%9A-toc\" style=\"margin-left:80px;\"><a href=\"#week1-day2%E4%BD%9C%E4%B8%9A\">week1-day2作业</a></p>\n<p id=\"week1-day3%E4%BD%9C%E4%B8%9A-toc\" style=\"margin-left:80px;\"><a href=\"#week1-day3%E4%BD%9C%E4%B8%9A\">week1-day3作业</a></p>\n<p id=\"week2-day4%E4%BD%9C%E4%B8%9A1-toc\" style=\"margin-left:80px;\"><a href=\"#week2-day4%E4%BD%9C%E4%B8%9A1\">week2-day4作业1</a></p>\n<p id=\"week2-day5%E4%BD%9C%E4%B8%9A-toc\" style=\"margin-left:80px;\"><a href=\"#week2-day5%E4%BD%9C%E4%B8%9A\">week2-day5作业</a></p>\n<p id=\"week2-day6%E4%BD%9C%E4%B8%9A-toc\" style=\"margin-left:80px;\"><a href=\"#week2-day6%E4%BD%9C%E4%B8%9A\">week2-day6作业</a></p>\n<p id=\"%C2%A0week3-day7%E4%BD%9C%E4%B8%9A1-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A0week3-day7%E4%BD%9C%E4%B8%9A1\"> week3-day7作业1</a></p>\n<p id=\"week3-day7%E4%BD%9C%E4%B8%9A2-toc\" style=\"margin-left:80px;\"><a href=\"#week3-day7%E4%BD%9C%E4%B8%9A2\">week3-day7作业2</a></p>\n<p id=\"week3-day8%E4%BD%9C%E4%B8%9A-toc\" style=\"margin-left:80px;\"><a href=\"#week3-day8%E4%BD%9C%E4%B8%9A\">week3-day8作业</a></p>\n<p id=\"week3-day9%E4%BD%9C%E4%B8%9A-toc\" style=\"margin-left:80px;\"><a href=\"#week3-day9%E4%BD%9C%E4%B8%9A\">week3-day9作业</a></p>\n<p id=\"week4-day10%E4%BD%9C%E4%B8%9A-toc\" style=\"margin-left:80px;\"><a href=\"#week4-day10%E4%BD%9C%E4%B8%9A\">week4-day10作业</a></p>\n<p id=\"week4-day11%E4%BD%9C%E4%B8%9A-toc\" style=\"margin-left:80px;\"><a href=\"#week4-day11%E4%BD%9C%E4%B8%9A\">week4-day11作业</a></p>\n<p id=\"%C2%A0week4-day12%E4%BD%9C%E4%B8%9A-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A0week4-day12%E4%BD%9C%E4%B8%9A\"> week4-day12作业</a></p>\n<p id=\"%E4%B8%AD%E7%BA%A7%E9%98%B6%E6%AE%B5-toc\" style=\"margin-left:40px;\"><a href=\"#%E4%B8%AD%E7%BA%A7%E9%98%B6%E6%AE%B5\">中级阶段</a></p>\n<p id=\"%E4%B8%AD%E7%BA%A7-day1-toc\" style=\"margin-left:80px;\"><a href=\"#%E4%B8%AD%E7%BA%A7-day1\">中级-day1</a></p>\n<p id=\"%C2%A0%E4%B8%AD%E7%BA%A7-day2%E4%BD%9C%E4%B8%9A-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A0%E4%B8%AD%E7%BA%A7-day2%E4%BD%9C%E4%B8%9A\"> 中级-day2作业</a></p>\n<p id=\"%E4%B8%AD%E7%BA%A7day3%E4%BD%9C%E4%B8%9A-toc\" style=\"margin-left:80px;\"><a href=\"#%E4%B8%AD%E7%BA%A7day3%E4%BD%9C%E4%B8%9A\">中级day3作业</a></p>\n<p id=\"%E4%B8%AD%E7%BA%A7-day4%E4%BD%9C%E4%B8%9A-toc\" style=\"margin-left:80px;\"><a href=\"#%E4%B8%AD%E7%BA%A7-day4%E4%BD%9C%E4%B8%9A\">中级-day4作业</a></p>\n<p id=\"%C2%A0%E4%B8%AD%E7%BA%A7-day5%E4%BD%9C%E4%B8%9A%E2%80%8B-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A0%E4%B8%AD%E7%BA%A7-day5%E4%BD%9C%E4%B8%9A%E2%80%8B\"> 中级-day5作业​</a></p>\n<p id=\"%E4%B8%AD%E7%BA%A7-day6%E4%BD%9C%E4%B8%9A-toc\" style=\"margin-left:80px;\"><a href=\"#%E4%B8%AD%E7%BA%A7-day6%E4%BD%9C%E4%B8%9A\">中级-day6作业</a></p>\n<p id=\"%E4%B8%AD%E7%BA%A7-day7%E4%BD%9C%E4%B8%9A-toc\" style=\"margin-left:80px;\"><a href=\"#%E4%B8%AD%E7%BA%A7-day7%E4%BD%9C%E4%B8%9A\">中级-day7作业</a></p>\n<p id=\"%E4%B8%AD%E7%BA%A7-day8%E4%BD%9C%E4%B8%9A-toc\" style=\"margin-left:80px;\"><a href=\"#%E4%B8%AD%E7%BA%A7-day8%E4%BD%9C%E4%B8%9A\">中级-day8作业</a></p>\n<p id=\"%E4%B8%AD%E7%BA%A7-day9%E4%BD%9C%E4%B8%9A-toc\" style=\"margin-left:80px;\"><a href=\"#%E4%B8%AD%E7%BA%A7-day9%E4%BD%9C%E4%B8%9A\">中级-day9作业</a></p>\n<p id=\"%E4%B8%AD%E7%BA%A7-day10%E4%BD%9C%E4%B8%9A-toc\" style=\"margin-left:80px;\"><a href=\"#%E4%B8%AD%E7%BA%A7-day10%E4%BD%9C%E4%B8%9A\">中级-day10作业</a></p>\n<p id=\"%E4%B8%AD%E7%BA%A7day11-%E4%BD%9C%E4%B8%9A-toc\" style=\"margin-left:80px;\"><a href=\"#%E4%B8%AD%E7%BA%A7day11-%E4%BD%9C%E4%B8%9A\">中级day11-作业</a></p>\n<p id=\"%E4%B8%AD%E7%BA%A7day12-%E4%BD%9C%E4%B8%9A-toc\" style=\"margin-left:80px;\"><a href=\"#%E4%B8%AD%E7%BA%A7day12-%E4%BD%9C%E4%B8%9A\">中级day12-作业</a></p>\n<p id=\"%E9%AB%98%E7%BA%A7%E9%98%B6%E6%AE%B5-toc\" style=\"margin-left:0px;\"><a href=\"#%E9%AB%98%E7%BA%A7%E9%98%B6%E6%AE%B5\">高级阶段</a></p>\n<p id=\"%E9%AB%98%E7%BA%A7day1-%E4%BD%9C%E4%B8%9A-toc\" style=\"margin-left:80px;\"><a href=\"#%E9%AB%98%E7%BA%A7day1-%E4%BD%9C%E4%B8%9A\">高级day1-作业</a></p>\n<p id=\"%E9%AB%98%E7%BA%A7day2-%E4%BD%9C%E4%B8%9A-toc\" style=\"margin-left:80px;\"><a href=\"#%E9%AB%98%E7%BA%A7day2-%E4%BD%9C%E4%B8%9A\">高级day2-作业</a></p>\n<p style=\"margin-left:80px;\"><a href=\"#%E9%AB%98%E7%BA%A7day2-%E4%BD%9C%E4%B8%9A\">高级day3-作业</a></p>\n<p style=\"margin-left:80px;\"><a href=\"#%E9%AB%98%E7%BA%A7day2-%E4%BD%9C%E4%B8%9A\">高级day4-作业</a></p>\n<p style=\"margin-left:80px;\"><a href=\"#%E9%AB%98%E7%BA%A7day2-%E4%BD%9C%E4%B8%9A\">高级day5-作业</a></p>\n<p style=\"margin-left:80px;\"><a href=\"#%E9%AB%98%E7%BA%A7day2-%E4%BD%9C%E4%B8%9A\">高级day6-作业</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<p></p>\n<h1 id=\"%E5%88%9D%E7%BA%A7%E9%98%B6%E6%AE%B5\">初级阶段</h1>\n<h3 id=\"week1-day1%E4%BD%9C%E4%B8%9A\">week1-day1作业</h3>\n<p><img alt=\"\" height=\"622\" src=\"image\\d11abacdba6f4ea1bcf4ce1204c63b92.png\" width=\"1200\"/></p>\n<pre><code class=\"language-cpp\">#include &lt;stdio.h&gt;\n\nint main()\n{\n    printf(\"hello wangdao\\n\");\n    \n    return 0;\n}\n</code></pre>\n<h3 id=\"week1-day2%E4%BD%9C%E4%B8%9A\">week1-day2作业</h3>\n<p><img alt=\"\" height=\"546\" src=\"image\\4343e8eb913f4edd9efac089f777d5eb.png\" width=\"1200\"/></p>\n<pre><code class=\"language-cpp\">#define _CRT_SECURE_NO_WARNINGS //解决scanf编译报错问题(考试不需要写)\n#include&lt;stdio.h&gt;\n\nint main()\n{\n    int a,b;\n    scanf(\"%d%d\", &amp;a,&amp;b);//一定要在变量前加取地址符&amp;\n    printf(\"%d\\n\", a+b);\n}</code></pre>\n<p></p>\n<h3 id=\"week1-day3%E4%BD%9C%E4%B8%9A\">week1-day3作业</h3>\n<p><img alt=\"\" height=\"550\" src=\"image\\04f11e9f74964d7589d30baa73a03c47.png\" width=\"1200\"/></p>\n<pre><code class=\"language-cpp\">#define _CRT_SECURE_NO_WARNINGS\n#include&lt;stdio.h&gt;\nint main()\n{\n    int a;\n    scanf(\"%d\", &amp;a);\n    if (65 &lt; a &lt; 122)\n        printf(\"%c\", a);\n    return 0;\n} </code></pre>\n<p></p>\n<h3 id=\"week2-day4%E4%BD%9C%E4%B8%9A1\">week2-day4作业1</h3>\n<p><img alt=\"\" height=\"694\" src=\"image\\c20e6ba7b30f4df19bef3b56af7c38ae.png\" width=\"1200\"/></p>\n<pre><code class=\"language-cpp\">#define _CRT_SECURE_NO_WARNINGS\n#include&lt;stdio.h&gt;\nint main()\n{\n    int year;\n    scanf(\"%d\", &amp;year);\n    if (year % 400 == 0 || year % 4 == 0 &amp;&amp; year % 100 != 0)//能被4整除但不能被100整除或者能被400整除\n    {\n        printf(\"yes\\n\");\n\n    }\n    else {\n        printf(\"no\\n\");\n    }\n\n}</code></pre>\n<p></p>\n<h3 id=\"week2-day5%E4%BD%9C%E4%B8%9A\">week2-day5作业</h3>\n<p><img alt=\"\" height=\"578\" src=\"image\\0b44788c22d84ac0ad0c2f66c6e89ebc.png\" width=\"1200\"/></p>\n<pre><code class=\"language-cpp\">#define _CRT_SECURE_NO_WARNINGS\n#include&lt;stdio.h&gt;\n//一个scanf读多种类型的数据\n//混合输入时每次在%c之前需要加入一个空格\nint main()\n{\n    int i;\n    char j;\n    float k;\n    scanf(\"%d %c%f\", &amp;i, &amp;j, &amp;k);\n    //printf(\"%.2f\",(float)i+(float)j+k);\n    printf(\"%0.2f\\n\", i + j + k);\n    return 0;\n}</code></pre>\n<p></p>\n<h3 id=\"week2-day6%E4%BD%9C%E4%B8%9A\">week2-day6作业</h3>\n<p><img alt=\"\" height=\"729\" src=\"image\\92a90c37cd0d489587e20e763e6d8e37.png\" width=\"1200\"/></p>\n<pre><code class=\"language-cpp\"> #define _CRT_SECURE_NO_WARNINGS\n#include&lt;stdio.h&gt;\n//把最初输入的整型数a，反过来后，再存到另外一个整形数b，判断a和b是否相等，如果相等就输出yes，不等就输出no\nint main() \n{\n    int a,b,c,tmp;\n    while (scanf(\"%d\", &amp;a) != EOF)\n    {\n        b = 0;\n        c = a;\n        while (a)\n        {\n            tmp = a % 10;\n            b = b * 10 + tmp;\n            a = a / 10;\n        }\n        if (c == b)\n        {\n            printf(\"yes\\n\");\n        }\n        else\n        {\n            printf(\"no\\n\");\n        }\n    }\n    return 0;\n}</code></pre>\n<p></p>\n<h3 id=\"%C2%A0week3-day7%E4%BD%9C%E4%B8%9A1\"> week3-day7作业1</h3>\n<p><img alt=\"\" height=\"734\" src=\"image\\d1f9f1462b874141a36762d55504cf03.png\" width=\"1200\"/></p>\n<pre><code class=\"language-cpp\">//while循环\n\n #define _CRT_SECURE_NO_WARNINGS\n#include&lt;stdio.h&gt;\nint main()\n{\n    int n;\n    int i = 1;\n    int total = 1;//存储最终的和\n    scanf(\"%d\", &amp;n);\n    while (i &lt;= n)//while后面不能加分号，否则会进入死循环\n    {\n        total = total * i;\n        i++;\n    }\n    printf(\"%d\\n\", total);\n}\n\n //for循环\n\n#define _CRT_SECURE_NO_WARNINGS\n#include&lt;stdio.h&gt;\nint main()\n{\n    int n;\n    int i, total;\n    scanf(\"%d\", &amp;n);//读取输入\n    //for语句中只能有两个分号\n    for (i = 1, total = 1; i &lt;= n; i++)\n    {\n        total = total * i;\n    }\n    printf(\"%d\\n\", total);\n}</code></pre>\n<h3 id=\"week3-day7%E4%BD%9C%E4%B8%9A2\">week3-day7作业2</h3>\n<p><img alt=\"\" height=\"612\" src=\"image\\484151fef82444b88f31e4e9323fec27.png\" width=\"915\"/></p>\n<pre><code class=\"language-cpp\">#include&lt;stdio.h&gt;\nint main() \n{\n    int i, j, k, m, sum = 0;\n    for (i = 1; i &lt;= 40; i++)\n    {\n        for (j = 1; j &lt;= 40; j++)\n        {\n            for (k = 1; k &lt;= 40; k++)\n            {\n                for (m = 1; m &lt;= 40; m++)\n                {\n                    if (i + j + k + m == 40 &amp;&amp; 10 * i + 5 * j + k + m * 2 == 100)\n                    {\n                        sum++;\n                    }\n                }\n            }\n        }\n    }\n    printf(\"%d\", sum);\n    return 0;\n    \n} </code></pre>\n<h3 id=\"week3-day8%E4%BD%9C%E4%B8%9A\">week3-day8作业</h3>\n<p><img alt=\"\" height=\"1089\" src=\"image\\a8fe00bb20684607ba0f22da196d7b54.png\" width=\"1200\"/></p>\n<pre><code class=\"language-cpp\"> #define _CRT_SECURE_NO_WARNINGS\n#include&lt;stdio.h&gt;\nint main()\n{\n    int a[100], n, k = 0;\n    scanf(\"%d\", &amp;n);//接下来要输入多少个元素\n    for (int i = 0; i &lt; n; i++)\n    {\n        scanf(\"%d\", &amp;a[i]);//如何往数组里元素读取数据\n        if (a[i] == 2)\n        {\n            k++;\n        }\n    }\n    printf(\"%d\\n\",k);\n}</code></pre>\n<h3 id=\"week3-day9%E4%BD%9C%E4%B8%9A\">week3-day9作业</h3>\n<p><img alt=\"\" height=\"1200\" src=\"image\\90d910517c494f41b729cd290874d653.png\" width=\"1200\"/></p>\n<pre><code class=\"language-cpp\"> #define _CRT_SECURE_NO_WARNINGS\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\nint main()\n{\n    char a[20];\n    char b[20];\n    int len;\n    gets(a);\n    len = strlen(a);//读取数组a的长度\n    for (int i = 0; i &lt; len; i++)\n    {\n        b[i] = a[len - i - 1];//将a数组的下标存的数据赋值给逆转后b数组的下标\n    }\n    b[len] = '\\0';//在b数组中，数据结束后添加结束符\n    if (strcmp(a, b) &gt; 0)//判断原字符串是否大于逆转后的字符串\n    {\n        printf(\"1\");\n    }\n    else if (strcmp(a, b) &lt; 0)\n    {\n        printf(\"-1\");\n    }\n    else\n    {\n        printf(\"0\");\n    }\n}</code></pre>\n<h3 id=\"week4-day10%E4%BD%9C%E4%B8%9A\">week4-day10作业</h3>\n<p><img alt=\"\" height=\"701\" src=\"image\\7587ddb308074dce9a6945512d0e0cbf.png\" width=\"1200\"/></p>\n<pre><code class=\"language-cpp\">#define _CRT_SECURE_NO_WARNINGS\n#include&lt;stdio.h&gt;\n\nvoid change(int *j)//j称为形参，j=&amp;i\n{\n    *j = *j/2;//指针的间接访问\n}\n\nint main()\n{\n    int i;//i是局部变量\n    scanf(\"%d\",&amp;i);\n    change(&amp;i);//函数调用时，把&amp;i称为实参\n    printf(\"%d\\n\", i);\n    return 0;\n}</code></pre>\n<h3 id=\"week4-day11%E4%BD%9C%E4%B8%9A\">week4-day11作业</h3>\n<p><img alt=\"\" height=\"1072\" src=\"image\\206ec9c685bf4a51a71768043ec84f8b.png\" width=\"1200\"/></p>\n<p></p>\n<pre><code class=\"language-cpp\">#define _CRT_SECURE_NO_WARNINGS\n#include&lt;stdio.h&gt;\n//malloc可以帮我们实现动态数组\nint main()\n{\n    int i;//申请多大的空间\n    scanf(\"%d\", &amp;i);\n    char* p;\n    p = malloc(i);//malloc申请空间的单位是字节\n    char c;\n    scanf(\"%c\", &amp;c);//为了去除缓冲区里边的\\n\n    gets(p);//如果不通过上面的scanf去消除\\n，gets不会卡住\n    puts(p);\n    return 0;\n}</code></pre>\n<h3 id=\"%C2%A0week4-day12%E4%BD%9C%E4%B8%9A\"> week4-day12作业</h3>\n<p><img alt=\"\" height=\"1007\" src=\"image\\ffab7ad5732c4729927ccae356357eb2.png\" width=\"1200\"/></p>\n<pre><code class=\"language-cpp\">#define _CRT_SECURE_NO_WARNINGS\n#include&lt;stdio.h&gt; \n\nint step(int n)\n{\n    if (1 == n || 2 == n)//递归的结束条件\n    {\n        return n;\n    }\n    return step(n - 1) + step(n - 2);//递归公式\n}\n\nint main()\n{\n    int n;//存储台阶\n    scanf(\"%d\", &amp;n);\n    printf(\"%d\\n\", step(n));\n    return 0;\n}</code></pre>\n<h2 id=\"%E4%B8%AD%E7%BA%A7%E9%98%B6%E6%AE%B5\">中级阶段</h2>\n<h3 id=\"%E4%B8%AD%E7%BA%A7-day1\">中级-day1</h3>\n<p><img alt=\"\" height=\"566\" src=\"image\\20ecf95a81a74c9089e1ef523f6d50a4.png\" width=\"1200\"/></p>\n<pre><code class=\"language-cpp\">#define _CRT_SECURE_NO_WARNINGS\n#include&lt;stdio.h&gt;\n\n//结构体指针\nstruct student\n{\n    int num;\n    char name[20];\n    char sex;\n};//结构体类型声明，注意最后一定要加分号\nint main()\n{\n    struct student sarr[1];\n    int i=0;\n        scanf(\"%d%s %c\", &amp;sarr[i].num, sarr[i].name, &amp;sarr[i].sex);\n        printf(\"%d %s %c\\n\", sarr[i].num, sarr[i].name, sarr[i].sex);\n    \n    return 0;\n}</code></pre>\n<h3 id=\"%C2%A0%E4%B8%AD%E7%BA%A7-day2%E4%BD%9C%E4%B8%9A\"> 中级-day2作业</h3>\n<p><img alt=\"\" height=\"718\" src=\"image\\cff8c7a1400a47e3924040f46bf722a5.png\" width=\"1200\"/></p>\n<pre><code class=\"language-cpp\">#define _CRT_SECURE_NO_WARNINGS\n#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\nvoid modify_pointer(char*&amp;p) {\n    p = (char*)malloc(100);\n    fgets(p, 100, stdin);//如果使用fgets传入的是一个指针变量，中间参数是指针指向的空间大小\n\n}\nint main() {\n    char* p;\n    modify_pointer(p);\n    puts(p);\n    return 0;\n}</code></pre>\n<h3 id=\"%E4%B8%AD%E7%BA%A7day3%E4%BD%9C%E4%B8%9A\">中级day3作业</h3>\n<p> <img alt=\"\" height=\"1158\" src=\"image\\cf48f9e00f6249588270755f4db34f2f.png\" width=\"1200\"/></p>\n<pre><code class=\"language-cpp\">#define _CRT_SECURE_NO_WARNINGS\n#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\n\n#define MaxSize 50\ntypedef int ElemType;//顺序表中元素的类型\n//静态分配\ntypedef struct {\n    ElemType data[MaxSize];//定义的数组，用来存元素\n    int length;//当前顺序表中有多少个元素\n}SqList;\n\n//i代表插入的位置，从1开始，e要插入的元素\nbool ListInsert(SqList&amp; L, int i, ElemType e)\n{\n    if (i&lt;1 || i&gt;L.length + 1)//判断要插入的位置是否合法\n        return false;\n    if (L.length &gt;= MaxSize)//超出了空间,元素存储满了，不能再存了\n        return false;\n    for (int j = L.length; j &gt;= i; j--)//移动顺序表中的元素\n        L.data[j] = L.data[j - 1];\n    L.data[i - 1] = e;//数组下标从零开始，插入第一个位置，访问的下标为零\n    L.length++;\n    return true;//插入成功，返回true\n}\n//删除使用元素e的引用的目的是拿出对应的值\nbool ListDelete(SqList&amp; L, int i, ElemType&amp; e)\n{\n    if (i&lt;1 || i&gt;L.length)//如果删除的位置是不合法\n        return false;\n    if (L.length == 0)//顺序表中没有元素，无需删除\n    {\n        return false;\n    }\n    e = L.data[i - 1];//获取顺序表中对应的元素，赋值给e\n    for (int j = i; j &lt; L.length; j++)//从i的位置依次把元素往前覆盖\n        L.data[j - 1] = L.data[j];\n    L.length--;\n    return true;//删除一个元素，顺序表长度减1\n}\n//打印顺序表元素\nvoid PrintList(SqList&amp; L)\n{\n    for (int i = 0; i &lt; L.length; i++)\n    {\n        printf(\"%3d\", L.data[i]);//要求所有元素打印到一排\n    }\n    printf(\"\\n\");\n}\n//要不要加引用，就是看是不是在子函数中去改变主函数中对应的变量，要改就要加\nint main()\n{\n    \n    SqList L;//顺序表的名称\n    bool ret;//查看返回值，布尔型是true，或者false\n    ElemType del;//用来存要删除的元素\n    //首先手动在顺序表中赋值\n    L.data[0] = 1;\n    L.data[1] = 2;\n    L.data[2] = 3;\n    L.length = 3;//总计三个元素\n    int i;\n    scanf(\"%d\\n\", &amp;i);\n    ret = ListInsert(L, 2, i);//往第二个位置插入6这个元素\n    if (ret)\n    {\n        PrintList(L);//打印成功后的顺序表\n    }\n    else {\n        printf(\"插入失败\\n\");\n    }\n    int k;\n    scanf(\"%d\\n\", &amp;k);\n    ret = ListDelete(L,k,del);//删除第一个位置的元素，把元素输出\n    if (ret)\n    {\n        PrintList(L);\n    }\n    else {\n        printf(\"false\\n\");\n    }\n    return 0;\n}</code></pre>\n<h3 id=\"%E4%B8%AD%E7%BA%A7-day4%E4%BD%9C%E4%B8%9A\">中级-day4作业</h3>\n<p><img alt=\"\" height=\"1200\" src=\"image\\190286c3421349abb382b63fab0c85ad.png\" width=\"1200\"/></p>\n<pre><code class=\"language-cpp\">#define _CRT_SECURE_NO_WARNINGS\n#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\ntypedef int ElemType;\ntypedef struct LNode {\n    ElemType data;\n    struct LNode* next;//指向下一个节点\n}LNode,*LinkList;\n//头插法新建链表\nLinkList CreatList1(LinkList&amp; L)//list_head_insert\n{\n    LNode* s; int x;\n    L = (LinkList)malloc(sizeof(LNode));//带头结点的链表\n    L-&gt;next = NULL;//L-&gt;data里边没放东西\n    scanf(\"%d\", &amp;x);//从标准输入读取数据\n    //3 4 5 6 9999\n    while (x != 9999) {\n        s = (LNode*)malloc(sizeof(LNode));//申请一个新空间给s，强制类型转换\n        s-&gt;data = x;//把读取到的值，给新空间中的data成员\n        s-&gt;next = L-&gt;next;//让新结点的next指针指向链表的第一个元素（第一个放我们数据的元素）\n        L-&gt;next = s;//让s作为第一的元素\n        scanf(\"%d\", &amp;x);//读取标准输入\n    }\n    return L;\n}\n//尾插法新建链表\nLinkList CreatList2(LinkList &amp;L)//list_tail_insert\n{\n    int x;\n    L = (LinkList)malloc(sizeof(LNode));//带头结点的链表\n    LNode* s, * r = L;//LinkList s,r=L;也可以，r代表链表表尾结点，指向链表尾部\n    //3 4 5 6 9999\n    scanf(\"%d\\n\", &amp;x);\n    while (x!=9999)\n    {\n        s = (LNode*)malloc(sizeof(LNode));\n        s-&gt;data = x;\n        r-&gt;next = s;//让尾部节点指向新节点\n        r = s;//r指向新的表尾结点\n        scanf(\"%d\\n\", &amp;x);\n    }\n    r-&gt;next = NULL;//尾结点的next指针赋值为null\n    return L;\n    \n}\n//打印链表中每个结点的值\nvoid PrintList(LinkList L)\n{\n    L = L-&gt;next;\n    while (L != NULL)//NULL是为了代表一张空的藏宝图\n    {\n        printf(\"%3d\", L-&gt;data);//打印当前节点数据\n        L = L-&gt;next;//指向下一个节点\n        if (L != NULL)\n        {\n            printf(\" \");\n        }\n    }\n    printf(\"\\n\");\n}\nint main()\n{\n    LinkList L;\n    LinkList search;\n    CreatList1(L);//输入数据可以为3 4 5 6 7 9999，头插法新建链表\n    PrintList(L);//链表打印\n    CreatList2(L);//输入数据可以为3 4 5 6 7 9999，尾插法新建链表\n    PrintList(L);\n    return 0;\n} </code></pre>\n<h3 id=\"%C2%A0%E4%B8%AD%E7%BA%A7-day5%E4%BD%9C%E4%B8%9A%E2%80%8B\"> 中级-day5作业<img alt=\"\" height=\"1200\" src=\"image\\d583fc9dfe824b0ea1b458772ed0dd19.png\" width=\"1200\"/></h3>\n<pre><code class=\"language-cpp\">#define _CRT_SECURE_NO_WARNINGS\n#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\ntypedef int ElemType;\ntypedef struct LNode {\n    ElemType data;\n    struct LNode* next;//指向下一个节点\n}LNode,*LinkList;\n//尾插法建立链表\nLinkList CreatList(LinkList&amp; L)//list_tail_insert\n{\n    int x;\n    L = (LinkList)malloc(sizeof(LNode));//带头结点的链表\n    LNode* s, * r = L;//LinkList s,r=L;也可以，r代表链表表尾结点，指向链表尾部\n    //3 4 5 6 7 9999\n    scanf(\"%d\", &amp;x);\n    while (x != 9999) {\n        s = (LNode*)malloc(sizeof(LNode));\n        s-&gt;data = x;\n        r-&gt;next = s;//让尾部节点指向新节点\n        r = s;//r指向新的尾部节点\n        scanf(\"%d\", &amp;x);\n    }\n    r-&gt;next = NULL;\n    return L;\n}\n//按序号查找结点值\nLNode* GetElem(LinkList L, int i)\n{\n    int j = 1;\n    LNode* p = L-&gt;next;\n    if (i == 0)\n        return L;\n    if (i &lt; 1)\n        return NULL;\n    while (p&amp;&amp;j&lt;i)\n    {\n        p = p-&gt;next;\n        j++;\n    }\n    return p;\n}\n//新结点插入第i个位置\nbool LinstFrontInsert(LinkList L, int i, ElemType e)\n{\n    LinkList p = GetElem(L, i - 1);\n    if (NULL == p)\n    {\n        return false;\n    }\n    LinkList s = (LNode*)malloc(sizeof(LNode));//为新插入的节点申请空间\n    s-&gt;data = e;\n    s-&gt;next = p-&gt;next;\n    p-&gt;next = s;\n    return true;\n}\n//删除第i个节点\nbool ListDelete(LinkList L, int i)\n{\n    LinkList p = GetElem(L, i - 1);\n    if (NULL == p)\n    {\n        return false;\n    }\n    LinkList q;\n    q = p-&gt;next;\n    p-&gt;next = q-&gt;next;//断链\n    free(q);//释放对应节点的空间\n    return true;\n}\n//打印链表中每个节点的位置\nvoid PrintList(LinkList L)\n{\n    L = L-&gt;next;\n    while (L!=NULL)\n    {\n        printf(\"%3d\", L-&gt;data);\n        L = L-&gt;next;//指向下一个节点\n    }\n    printf(\"\\n\");\n}\n\n\nint main()\n{\n    LinkList L;\n    LinkList search;\n    CreatList(L);\n    //PrintList(L);\n    search = GetElem(L, 2);//查找第二个位置的元素的值\n    if (search != NULL)\n    {\n        printf(\"%d\\n\", search-&gt;data);\n\n    }\n    LinstFrontInsert(L, 2, 99);//新结点插入第i个位置\n    PrintList(L);\n    ListDelete(L, 4);//删除第4个节点\n    PrintList(L);\n}</code></pre>\n<h3 id=\"%E4%B8%AD%E7%BA%A7-day6%E4%BD%9C%E4%B8%9A\">中级-day6作业</h3>\n<p><img alt=\"\" height=\"1060\" src=\"image\\e2045b3d20b64612acface9d925e2c90.png\" width=\"1200\"/></p>\n<pre><code class=\"language-cpp\">#define _CRT_SECURE_NO_WARNINGS\n#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\n#define MaxSize 50\ntypedef int ElemType;\ntypedef struct {\n    ElemType data[MaxSize];//数组\n    int top;\n}SqStack;\n//栈初始化\nvoid InitStack(SqStack&amp; S)\n{\n    S.top = -1;//代表栈为空\n}\n\n//入栈\nbool Push(SqStack&amp; S, ElemType x)\n{\n    if (S.top == MaxSize - 1)//数组的大小不能改变，避免访问越界\n    {\n        return false;\n    }\n    S.data[++S.top] = x;\n    return true;\n}\n//出栈\nbool Pop(SqStack&amp; S, ElemType&amp; x)\n{\n    if (-1 == S.top)\n        return false;\n    x = S.data[S.top--];\n    printf(\" %d\", x);\n    return true;\n}\n//队列\ntypedef struct {\n    ElemType data[5];//数组，存放MaxSize-1个元素\n    int front, rear;//队列头，队列尾\n}SqQueue;\n//队列初始化\nvoid InitQueue(SqQueue&amp; Q)//初始化队列\n{\n    Q.rear = Q.front = 0;\n}\n//入队\nbool EnQueue(SqQueue&amp; Q, ElemType x)\n{\n    if ((Q.rear + 1) % MaxSize == Q.front)//判断是否队满\n        return false;\n    Q.data[Q.rear] = x;//3 4 5 6 7\n    Q.rear = (Q.rear + 1) % MaxSize;\n    return true;\n}\n//出队\nbool DeQueue(SqQueue&amp; Q, ElemType&amp; x)\n{\n    if (Q.rear == Q.front)\n        return false;\n    x = Q.data[Q.front];//先进先出\n    Q.front = (Q.front + 1) % MaxSize;\n    printf(\" %d\", x);\n    return true;\n}\nint main()\n{\n    SqStack S;//后进先出LIFO\n    ElemType m;//用来存放拿出的元素\n    InitStack(S);//初始化\n    ElemType a, b, c;\n    scanf(\"%d %d %d\\n\", &amp;a, &amp;b, &amp;c);\n    Push(S, a);\n    Push(S, b);\n    Push(S, c);\n    SqQueue Q;\n    ElemType element;//存储出队元素\n    InitQueue(Q);//初始化队列\n    //入队\n    int n = 1;\n    int n1;\n    while (n &lt; 5)\n    {\n        scanf(\"%d\", &amp;n1);\n        EnQueue(Q, n1);\n        n = n + 1;\n    }\n    Pop(S, m);\n    Pop(S, m);\n    Pop(S, m);\n    printf(\"\\n\");\n    if (n &gt; 4)printf(\"false\\n\");\n    for(int i=1;i&lt;n;i++)\n    {\n        DeQueue(Q, element);\n    }\n    return 0;\n\n}</code></pre>\n<h3 id=\"%E4%B8%AD%E7%BA%A7-day7%E4%BD%9C%E4%B8%9A\">中级-day7作业</h3>\n<p><img alt=\"\" height=\"569\" src=\"image\\49d548af355e4124b496cef46872b506.png\" width=\"1200\"/></p>\n<p></p>\n<pre><code class=\"language-cpp\">#define _CRT_SECURE_NO_WARNINGS\n#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\ntypedef int ElemType;\ntypedef char BiElemType;\ntypedef struct BiTNode {\n    BiElemType c;//C就是书籍上的data\n    struct BiTNode* lchild;\n    struct BiTNode* rchild;\n}BiTNode, * BiTree;\n\n\ntypedef struct tag {\n    BiTree p;\n    struct tag* pnext;\n}tag_t, * ptag_t;\n//队列的相关数据结构\ntypedef struct LinkNode {\n    ElemType data;\n    struct LinkNode* next;\n}LinkNode;\ntypedef struct {\n    LinkNode* front, * rear;\n}LinkQueue;\nvoid InitQueue(LinkQueue&amp; Q);\nbool IsEmpty(LinkQueue Q);\nvoid EnQueue(LinkQueue&amp; Q, ElemType x);\nbool DeQueue(LinkQueue&amp; Q, ElemType&amp; x);\n\n\n//带头结点的队列\nvoid InitQueue(LinkQueue&amp; Q)\n{\n    Q.front = Q.rear = (LinkNode*)malloc(sizeof(LinkNode));\n    Q.front-&gt;next = NULL;\n}\n\nbool IsEmpty(LinkQueue Q)\n{\n    if (Q.front == Q.rear)\n        return true;\n    else\n        return false;\n}\n\nvoid EnQueue(LinkQueue&amp; Q, ElemType x)\n{\n    LinkNode* s = (LinkNode*)malloc(sizeof(LinkNode));\n    s-&gt;data = x; s-&gt;next = NULL;\n    Q.rear-&gt;next = s;\n    Q.rear = s;\n}\n\nbool DeQueue(LinkQueue&amp; Q, ElemType&amp; x)\n{\n    if (Q.front == Q.rear) return false;\n    LinkNode* p = Q.front-&gt;next;//头结点什么都没存，所以头结点的下一个节点才有数据\n    x = p-&gt;data;\n    Q.front-&gt;next = p-&gt;next;\n    if (Q.rear == p)\n        Q.rear = Q.front;\n    free(p);\n    return true;\n}\n\n\n//前序遍历\nvoid preOrder(BiTree p)\n{\n    if (p != NULL)\n    {\n        putchar(p-&gt;c);//等价于visit函数\n        preOrder(p-&gt;lchild);\n        preOrder(p-&gt;rchild);\n    }\n}\n\nint main()\n{\n    BiTree pnew;\n    int i, j, pos;\n    char c;\n    BiTree tree = NULL;//树根\n    ptag_t phead = NULL, ptail = NULL, listpnew = NULL, pcur = NULL;//phead是队列头，ptail是队列尾\n    while (scanf(\"%c\", &amp;c) != EOF)\n    {\n        if (c == '\\n')\n        {\n            break;\n        }\n        pnew = (BiTree)calloc(1, sizeof(BiTNode));//calloc申请空间并对空间进行初始化，赋值为0\n        pnew-&gt;c = c;//数据放进去\n        listpnew = (ptag_t)calloc(1, sizeof(tag_t));//给队列结点申请空间\n        listpnew-&gt;p = pnew;\n        if (NULL == tree)\n        {\n            tree = pnew;//树的根\n            phead = listpnew;//队列头\n            ptail = listpnew;//队列尾\n            pcur = listpnew;\n            continue;\n        }\n        else\n        {\n            ptail-&gt;pnext = listpnew;//新节点放入链表，通过尾插法\n            ptail = listpnew;//ptail指向队列尾部\n        }//pcur始终指向要插入的位置\n        if (NULL == pcur-&gt;p-&gt;lchild)//如何把新节点放入树\n        {\n            pcur-&gt;p-&gt;lchild = pnew;//把新节点放到要插入结点的左边\n        }\n        else if (NULL == pcur-&gt;p-&gt;rchild)\n        {\n            pcur-&gt;p-&gt;rchild = pnew;//把新节点放到要插入结点的右边\n            pcur = pcur-&gt;pnext;//左右都放了结点后，pcur指向队列的下一个\n        }\n\n    }\n    preOrder(tree);\n}</code></pre>\n<h3 id=\"%E4%B8%AD%E7%BA%A7-day8%E4%BD%9C%E4%B8%9A\">中级-day8作业</h3>\n<p><img alt=\"\" height=\"634\" src=\"image\\0767a46b29074e928e9938316b54f298.png\" width=\"1200\"/></p>\n<pre><code class=\"language-cpp\">#define _CRT_SECURE_NO_WARNINGS\n#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\ntypedef char BiElemType;\ntypedef struct BiTNode {\n    BiElemType c;//c就是书籍上的data\n    struct BiTNode* lchild;\n    struct BiTNode* rchild;\n}BiTNode, * BiTree;\n\ntypedef struct tag {\n    BiTree p;//树的某一个结点的地址值\n    struct tag* pnext;\n}tag_t, * ptag_t;\n#define MaxSize 50\ntypedef BiTree ElemType;\n//队列的相关数据结构\ntypedef struct LinkNode {\n    ElemType data;\n    struct LinkNode* next;\n}LinkNode;\ntypedef struct {\n    LinkNode* front, * rear;\n}LinkQueue;\nvoid InitQueue(LinkQueue&amp; Q);\nbool IsEmpty(LinkQueue Q);\nvoid EnQueue(LinkQueue&amp; Q, ElemType x);\nbool DeQueue(LinkQueue&amp; Q, ElemType&amp; x);\n//带头结点的队列\nvoid InitQueue(LinkQueue&amp; Q)\n{\n    Q.front = Q.rear = (LinkNode*)malloc(sizeof(LinkNode));\n    Q.front-&gt;next = NULL;\n}\n\nbool IsEmpty(LinkQueue Q)\n{\n    if (Q.front == Q.rear)\n        return true;\n    else\n        return false;\n}\n\nvoid EnQueue(LinkQueue&amp; Q, ElemType x)\n{\n    LinkNode* s = (LinkNode*)malloc(sizeof(LinkNode));\n    s-&gt;data = x; s-&gt;next = NULL;\n    Q.rear-&gt;next = s;\n    Q.rear = s;\n}\n\nbool DeQueue(LinkQueue&amp; Q, ElemType&amp; x)\n{\n    if (Q.front == Q.rear) return false;\n    LinkNode* p = Q.front-&gt;next;//头结点什么都没存，所以头结点的下一个节点才有数据\n    x = p-&gt;data;\n    Q.front-&gt;next = p-&gt;next;\n    if (Q.rear == p)\n        Q.rear = Q.front;\n    free(p);\n    return true;\n}\n\n//中序遍历  hdibjeafcg\nvoid InOrder(BiTree p)\n{\n    if (p != NULL)\n    {\n        InOrder(p-&gt;lchild);\n        putchar(p-&gt;c);\n        InOrder(p-&gt;rchild);\n    }\n}\n//hidjebfgca  后序遍历\nvoid PostOrder(BiTree p)\n{\n    if (p != NULL)\n    {\n        PostOrder(p-&gt;lchild);\n        PostOrder(p-&gt;rchild);\n        putchar(p-&gt;c);\n    }\n}\n\n//层次遍历,层序遍历，广度优先遍历\nvoid LevelOrder(BiTree T)\n{\n    LinkQueue Q;//辅助队列\n    InitQueue(Q);//初始化队列\n    BiTree p;\n    EnQueue(Q, T);//树根入队\n    while (!IsEmpty(Q))\n    {\n        DeQueue(Q, p);//出队当前结点并打印\n        putchar(p-&gt;c);\n        if (p-&gt;lchild != NULL) //入队左孩子\n            EnQueue(Q, p-&gt;lchild);\n        if (p-&gt;rchild != NULL)  //入队右孩子\n            EnQueue(Q, p-&gt;rchild);\n    }\n}\nint main()\n{\n    BiTree pnew;\n    int i, j, pos;\n    char c;\n    BiTree tree = NULL;//树根\n    ptag_t phead = NULL, ptail = NULL, listpnew = NULL, pcur = NULL;//phead就是队列头，ptail就是队列尾\n    //abcdefghij\n    while (scanf(\"%c\", &amp;c) != EOF)\n    {\n        if (c == '\\n')\n        {\n            break;\n        }\n        pnew = (BiTree)calloc(1, sizeof(BiTNode));//calloc申请空间并对空间进行初始化，赋值为0\n        pnew-&gt;c = c;//数据放进去\n        listpnew = (ptag_t)calloc(1, sizeof(tag_t));//给队列结点申请空间\n        listpnew-&gt;p = pnew;\n        if (NULL == tree)\n        {\n            tree = pnew;//树的根\n            phead = listpnew;//队列头\n            ptail = listpnew;//队列尾\n            pcur = listpnew;\n            continue;\n        }\n        else {\n            ptail-&gt;pnext = listpnew;//新结点放入链表，通过尾插法\n            ptail = listpnew;//ptail指向队列尾部\n        }//pcur始终指向要插入的结点的位置\n        if (NULL == pcur-&gt;p-&gt;lchild)//如何把新结点放入树\n        {\n            pcur-&gt;p-&gt;lchild = pnew;//把新结点放到要插入结点的左边\n        }\n        else if (NULL == pcur-&gt;p-&gt;rchild)\n        {\n            pcur-&gt;p-&gt;rchild = pnew;//把新结点放到要插入结点的右边\n            pcur = pcur-&gt;pnext;//左右都放了结点后，pcur指向队列的下一个\n        }\n    }\n    InOrder(tree);\n    printf(\"\\n\");\n    PostOrder(tree);\n    printf(\"\\n\");\n    LevelOrder(tree);\n    printf(\"\\n\");\n}</code></pre>\n<h3 id=\"%E4%B8%AD%E7%BA%A7-day9%E4%BD%9C%E4%B8%9A\">中级-day9作业</h3>\n<p><img alt=\"\" height=\"673\" src=\"image\\e5ef6673a72d4d63820266e2c45f4cfc.png\" width=\"1200\"/></p>\n<p></p>\n<pre><code class=\"language-cpp\">#define _CRT_SECURE_NO_WARNINGS\n#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\ntypedef int KeyType;\ntypedef struct BSTNode {\n    KeyType key;\n    struct BSTNode* lchild, * rchild;\n}BSTNode, * BiTree;\n//54 20 66 40 28 79 58\nint BST_Insert(BiTree&amp; T, KeyType k)\n{\n    if (NULL == T)\n    {\n        //为新节点申请空间\n        T = (BiTree)malloc(sizeof(BSTNode));\n        T-&gt;key = k;\n        T-&gt;lchild = T-&gt;rchild = NULL;\n        return 1;//代表插入成功\n    }\n    else if (k == T-&gt;key)\n        return 0;//发现相同元素，就不插入\n    else if (k &lt; T-&gt;key)\n        return BST_Insert(T-&gt;lchild, k);\n    else\n        return BST_Insert(T-&gt;rchild, k);\n}\n\n//创建二叉排序树\nvoid Create_BST(BiTree&amp; T, KeyType str[], int n)\n{\n    T = NULL;\n    int i = 0;\n    while (i &lt; n)\n    {\n        BST_Insert(T, str[i]);\n        i++;\n    }\n}\n//中序遍历\nvoid InOrder(BiTree T, KeyType str[], int&amp; pos)\n{\n    if (T != NULL)\n    {\n        InOrder(T-&gt;lchild, str, pos);\n        printf(\"%3d\", T-&gt;key);\n        str[pos++] = T-&gt;key;//输出的同时存入数组\n        InOrder(T-&gt;rchild, str, pos);\n    }\n}\ntypedef int ElemType;\ntypedef struct {\n    ElemType* elem;//整形指针\n    int TableLen;\n}SSTable;\nint Binary_Search(SSTable L, ElemType key)\n{\n    int low = 0, high = L.TableLen - 1, mid;\n    while (low &lt;= high)\n    {\n        mid = (low + high) / 2;\n        if (L.elem[mid] == key)\n            return mid;\n        else if (L.elem[mid] &gt; key)\n            high = mid - 1;\n        else\n            low = mid + 1;\n    }\n    return -1;\n}\nint main()\n{\n    BiTree T = NULL;\n    BiTree parent;//存储父亲节点的地址值\n    BiTree search;\n    KeyType str[10];//将要进入二叉排序树的元素值\n    int i;\n    for (i = 0; i &lt; 10; i++)\n    {\n        scanf(\"%d\", &amp;str[i]);\n    }\n    Create_BST(T, str, 10);\n    int pos = 0;\n    InOrder(T, str, pos);//中序遍历把有序数组的结果存到str数组中\n    printf(\"\\n\");\n    SSTable L;\n    L.elem = str;\n    L.TableLen = 10;\n    pos = Binary_Search(L, 21);\n    printf(\"%d\\n\", pos);\n    return 0;\n\n}</code></pre>\n<h3 id=\"%E4%B8%AD%E7%BA%A7-day10%E4%BD%9C%E4%B8%9A\">中级-day10作业</h3>\n<p><img alt=\"\" height=\"627\" src=\"image\\cabcee19de2847c4a34638e0d300764d.png\" width=\"1200\"/></p>\n<p></p>\n<pre><code class=\"language-cpp\">#define _CRT_SECURE_NO_WARNINGS\n#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\n\nint main()\n{\n    char j;\n    scanf(\"%c\",&amp;j);\n    int i;\n    int arr[9] = { 0,1,1,2,2,3,1,1,2 };\n    for (i = 0; i &lt; 9; i++)\n    {\n        printf(\"%2d\", arr[i]);\n    }\n    return 0;\n}</code></pre>\n<h3 id=\"%E4%B8%AD%E7%BA%A7day11-%E4%BD%9C%E4%B8%9A\">中级day11-作业</h3>\n<p><img alt=\"\" height=\"781\" src=\"image\\1ccf5c12503e43d9a5b57b132594618e.png\" width=\"1200\"/></p>\n<pre><code class=\"language-cpp\">#define _CRT_SECURE_NO_WARNINGS\n#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\n#include &lt;time.h&gt;\n#include&lt;string.h&gt;\n\ntypedef int ElemType;\ntypedef struct {\n    ElemType* elem;//存储元素的起始地址\n    int TableLen;\n}SSTable;\nvoid ST_Init(SSTable&amp; ST, ElemType A[],int len)\n{\n    ST.TableLen = len;\n    ST.elem = (ElemType*)malloc(sizeof(ElemType) * ST.TableLen);\n    int i;\n    for (i = 0; i &lt; ST.TableLen; i++)\n    {\n        ST.elem[i] = A[i];\n    }\n\n}\nvoid ST_print(SSTable ST)\n{\n    for (int i = 0; i &lt; ST.TableLen; i++)\n    {\n        printf(\"%3d\", ST.elem[i]);\n    }\n    printf(\"\\n\");\n}\nvoid swap(ElemType&amp; a, ElemType&amp; b)\n{\n    ElemType tmp;\n    tmp = a;\n    a = b;\n    b = tmp;\n}\nvoid BubbleSort1(ElemType A[], int n)\n{\n    int i, j, flag;\n    for (i = 0; i &lt; n - 1; i++)//i是控制有多少个有序了\n    {\n        flag = 0;\n        for (j = n - 1; j &gt; i; j--)//内层控制比较，交换\n        {\n            if (A[j - 1] &gt; A[j])\n            {\n                swap(A[j - 1], A[j]);\n                flag = 1;\n            }\n        }\n    }\n}\nint Partition(int* arr, int left, int right)\n{\n    int k, i;\n    for (k = i = left; i &lt; right; i++)\n    {\n        if (arr[i] &lt; arr[right])\n        {\n            swap(arr[i], arr[k]);\n            k++;\n        }\n    }\n    swap(arr[k], arr[right]);\n    return k;\n}\n\n\n//递归实现\nvoid QuickSort(ElemType A[], int low, int high)\n{\n    if (low &lt; high)\n    {\n        int pivotpos = Partition(A, low, high);//分割点左边的元素都比分割点要小，右边的比分割点大\n        QuickSort(A, low, pivotpos - 1);\n        QuickSort(A, pivotpos + 1, high);\n    }\n}\nvoid InsertSort(ElemType A[], int n)\n{\n    int i, j;\n    for (i = 2; i &lt; n; i++)\n    {\n        if (A[i] &lt; A[i - 1])\n        {\n            A[0] = A[i];//放到暂存位置，A[0]既是暂存，也是哨兵\n            for (j = i - 1; A[0] &lt; A[j]; --j)//移动元素，内层循环控制有序序列中的每一个元素和要插入的元素比较\n                A[j + 1] = A[j];\n            A[j + 1] = A[0];//把暂存元素插入到对应位置\n        }\n    }\n}\nint main()\n{\n    SSTable ST;\n    ElemType A[10];\n    int i;\n    for (i = 0; i &lt; 10; i++)\n    {\n        scanf(\"%d\", &amp;A[i]);\n    }\n    ST_Init(ST,A, 10);//初始化\n    BubbleSort1(ST.elem, 10);//冒泡排序\n    ST_print(ST);\n    QuickSort(ST.elem, 0, 9);//快速排序\n    ST_print(ST);\n    InsertSort(ST.elem, 10);//插入排序\n    ST_print(ST);\n}\n\n </code></pre>\n<h3 id=\"%E4%B8%AD%E7%BA%A7day12-%E4%BD%9C%E4%B8%9A\">中级day12-作业</h3>\n<p><img alt=\"\" height=\"685\" src=\"image\\8f92104e87484273b525427e7a9c1034.png\" width=\"1200\"/></p>\n<pre><code class=\"language-cpp\">#define _CRT_SECURE_NO_WARNINGS\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;time.h&gt;\n#include &lt;string.h&gt;\ntypedef int ElemType;\ntypedef struct {\n\tElemType* elem;\n\tint TableLen;\n}SSTable;\n\nvoid ST_Init(SSTable&amp; ST, ElemType A[], int len)\n{\n\tST.TableLen = len;\n\tST.elem = (ElemType*)malloc(sizeof(ElemType) * ST.TableLen);\n\tint i;\n\tfor (i = 0; i &lt; ST.TableLen; i++)\n\t{\n\t\tST.elem[i] = A[i];\n\t}\n\n}\nvoid ST_print(SSTable ST)\n{\n\tfor (int i = 0; i &lt; ST.TableLen; i++)\n\t{\n\t\tprintf(\"%3d\", ST.elem[i]);\n\t}\n\tprintf(\"\\n\");\n}\nvoid swap(ElemType&amp; a, ElemType&amp; b)\n{\n\tElemType tmp;\n\ttmp = a;\n\ta = b;\n\tb = tmp;\n}\nvoid SelectSort(ElemType A[], int n)\n{\n\tint i, j, min;//min记录最小的元素的下标\n\tfor (i = 0; i &lt; n - 1; i++)//最多可以为8\n\t{\n\t\tmin = i;\n\t\tfor (j = i + 1; j &lt; n; j++)//j最多可以为9\n\t\t{\n\t\t\tif (A[j] &lt; A[min])\n\t\t\t\tmin = j;\n\t\t}\n\t\tif (min != i)\n\t\t{\n\t\t\tswap(A[i], A[min]);\n\t\t}\n\t}\n}\n//调整子树\nvoid AdjustDown1(ElemType A[], int k, int len)\n{\n\tint dad = k;\n\tint son = 2 * dad + 1;\n\twhile (son &lt;= len)\n\t{\n\t\tif (son + 1 &lt;= len &amp;&amp; A[son] &lt; A[son + 1])//看下有没有右孩子，比较左右孩子选大的\n\t\t{\n\t\t\tson++;\n\t\t}\n\t\tif (A[son] &gt; A[dad])//比较孩子和父亲\n\t\t{\n\t\t\tswap(A[son], A[dad]);\n\t\t\tdad = son;\n\t\t\tson = 2 * dad + 1;\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid HeapSort1(ElemType A[], int len)\n{\n\tint i;\n\tfor (i = len / 2; i &gt;= 0; i--)\n\t{\n\t\tAdjustDown1(A, i, len);\n\t}\n\tswap(A[0], A[len]);//交换顶部和数组最后一个元素\n\tfor (i = len - 1; i &gt; 0; i--)\n\t{\n\t\tAdjustDown1(A, 0, i);//剩下元素调整为大根堆\n\t\tswap(A[0], A[i]);\n\t}\n}\n//选择排序与堆排序\nint main()\n{\n\tSSTable ST;\n\tElemType A[10]; \n\tint i;\n\tfor (i = 0; i &lt; 10; i++)\n\t{\n\t\tscanf(\"%d\", &amp;A[i]);\n\t}\n\tST_Init(ST,A, 10);//初始化\n\tmemcpy(ST.elem, A, sizeof(A));\n\tSelectSort(ST.elem,10);\n\tST_print(ST);\n\tHeapSort1(ST.elem, 9);//零号元素不参与排序\n\tST_print(ST);\n\treturn 0;\n}</code></pre>\n<h1 id=\"%E9%AB%98%E7%BA%A7%E9%98%B6%E6%AE%B5\">高级阶段</h1>\n<h3 id=\"%E9%AB%98%E7%BA%A7day1-%E4%BD%9C%E4%B8%9A\">高级day1-作业</h3>\n<p><img alt=\"\" height=\"540\" src=\"image\\c571f31c1c724fcf949c161c005e2183.png\" width=\"1200\"/></p>\n<p></p>\n<pre><code class=\"language-cpp\">#define _CRT_SECURE_NO_WARNINGS\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#define N 10\ntypedef int ElemType;\nvoid Merge(ElemType A[], int low, int mid, int high)\n{\n\tElemType B[N];//为了降低操作次数\n\tint i, j, k;\n\tfor (k = low; k &lt;= high; k++)//复制元素到B中\n\t\tB[k] = A[k];\n\tfor (i = low, j = mid + 1, k = i; i &lt;= mid &amp;&amp; j &lt;= high; k++)//合并两个有序数组\n\t{\n\t\tif (B[i] &lt;= B[j])\n\t\t\tA[k] = B[i++];\n\t\telse\n\t\t\tA[k] = B[j++];\n\t}\n\twhile (i &lt;= mid)//如果有剩余元素，接着放入即可\n\t\tA[k++] = B[i++];\n\twhile (j &lt;= high)\n\t\tA[k++] = B[j++];\n}\nvoid MergeSort(ElemType A[], int low, int high)//递归分割\n{\n\tif (low &lt; high)\n\t{\n\t\tint mid = (low + high) / 2;\n\t\tMergeSort(A, low, mid);\n\t\tMergeSort(A, mid + 1, high);\n\t\tMerge(A, low, mid, high);\n\t}\n}\nvoid print(int* a)\n{\n\tfor (int i = 0; i &lt; N; i++)\n\t{\n\t\tprintf(\"%3d\", a[i]);\n\t}\n\tprintf(\"\\n\");\n}\n// 归并排序\nint main()\n{\n\tint A[10];\n\tint i;\n\tfor (i = 0; i &lt; 10; i++)\n\t{\n\t\tscanf(\"%d\", &amp;A[i]);\n\t}\n\tMergeSort(A, 0, 9);\n\tprint(A);\n\treturn 0;\n}\n</code></pre>\n<h3 id=\"%E9%AB%98%E7%BA%A7day2-%E4%BD%9C%E4%B8%9A\">高级day2-作业</h3>\n<p><img alt=\"\" height=\"1200\" src=\"image\\40e7b2eed10f4fd9891524216f0d57ce.png\" width=\"1200\"/></p>\n<p></p>\n<pre><code class=\"language-cpp\">#define _CRT_SECURE_NO_WARNINGS\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;malloc.h&gt;\n#include &lt;string.h&gt;\n\n#define MAX 100\n#define isLetter(a)  ((((a)&gt;='a')&amp;&amp;((a)&lt;='z')) || (((a)&gt;='A')&amp;&amp;((a)&lt;='Z')))\n#define LENGTH(a)  (sizeof(a)/sizeof(a[0]))\n\n// 邻接表中表对应的链表的顶点\ntypedef struct _ENode\n{\n    int ivex;                   // 该边所指向的顶点的位置,是数组的下标\n    struct _ENode* next_edge;   // 指向下一条弧的指针\n}ENode, * PENode;\n\n// 邻接表中表的顶点\ntypedef struct _VNode\n{\n    char data;              // 顶点信息\n    ENode* first_edge;      // 指向第一条依附该顶点的弧\n}VNode;\n\n// 邻接表\ntypedef struct _LGraph\n{\n    int vexnum;             // 图的顶点的数目\n    int edgnum;             // 图的边的数目\n    VNode vexs[MAX];\n}LGraph;\n\n/*\n * 返回ch在matrix矩阵中的位置\n */\nstatic int get_position(LGraph g, char ch)\n{\n    int i;\n    for (i = 0; i &lt; g.vexnum; i++)//去顶点结构体数组中遍历每个顶点\n        if (g.vexs[i].data == ch)\n            return i;//返回的是对应顶点的下标\n    return -1;\n}\n/*\n * 读取一个输入字符\n */\n static char read_char()\n {\n     char ch;\n \n     do {\n         ch = getchar();\n     } while (!isLetter(ch));\n \n     return ch;\n }\n\n/*\n * 将node链接到list的末尾\n */\nstatic void link_last(ENode* list, ENode* node)\n{\n    ENode* p = list;\n\n    while (p-&gt;next_edge)\n        p = p-&gt;next_edge;\n    p-&gt;next_edge = node;\n}\n\n\n/*\n * 深度优先搜索遍历图的递归实现\n */\nstatic void DFS(LGraph G, int i, int* visited)\n{\n    ENode* node;\n\n    visited[i] = 1;//要访问当前结点了，所以打印\n    printf(\" %c\", G.vexs[i].data);\n    node = G.vexs[i].first_edge;//拿当前顶点的后面一个顶点\n    while (node != NULL)\n    {\n        if (!visited[node-&gt;ivex])//只要对应顶点没有访问过，深入到下一个顶点访问\n            DFS(G, node-&gt;ivex, visited);\n        node = node-&gt;next_edge;//某个顶点的下一条边，例如B结点的下一条边\n    }\n}\n\n/*\n * 深度优先搜索遍历图\n */\nvoid DFSTraverse(LGraph G)\n{\n    int i;\n    int visited[MAX];       // 顶点访问标记\n\n    // 初始化所有顶点都没有被访问\n    for (i = 0; i &lt; G.vexnum; i++)\n        visited[i] = 0;\n    //从A开始深度优先遍历\n    for (i = 0; i &lt; G.vexnum; i++)\n    {\n        if (!visited[i])\n            DFS(G, i, visited);\n    }\n    printf(\"\\n\");\n}\n\n/*\n * 广度优先搜索（类似于树的层次遍历）\n */\nvoid BFS(LGraph G)\n{\n    int head = 0;\n    int rear = 0;\n    int queue[MAX];     // 辅组队列\n    int visited[MAX];   // 顶点访问标记\n    int i, j, k;\n    ENode* node;\n\n    //每个顶点未被访问\n    for (i = 0; i &lt; G.vexnum; i++)\n        visited[i] = 0;\n    //从零号顶点开始遍历\n    for (i = 0; i &lt; G.vexnum; i++)//对每个连同分量均调用一次BFS\n    {\n        if (!visited[i])//如果没访问过，就打印，同时入队,最初是A\n        {\n            visited[i] = 1;//标记已经访问过\n            printf(\" %c\", G.vexs[i].data);\n            queue[rear++] = i;  // 入队列\n        }\n        while (head != rear) //第一个进来的是A，遍历A的每一条边\n        {\n            j = queue[head++];  // 出队列\n            node = G.vexs[j].first_edge;\n            while (node != NULL)\n            {\n                k = node-&gt;ivex;\n                if (!visited[k])\n                {\n                    visited[k] = 1;\n                    printf(\" %c\", G.vexs[k].data);\n                    queue[rear++] = k;//类似于树的层次遍历，遍历到的同时入队\n                }\n                node = node-&gt;next_edge;\n            }\n        }\n    }\n    printf(\"\\n\");\n}\n\n\n/*\n * 创建邻接表对应的图(有向图)\n */\nLGraph* create_example_lgraph_directed()\n{\n    char c1, c2;\n    char vexs[] = { 'A', 'B', 'C', 'D', 'E', 'F', 'G' };\n    char edges[][2] = {\n        {'A', 'B'},\n        {'B', 'C'},\n        {'B', 'E'},\n        {'B', 'F'},\n        {'C', 'E'},\n        {'D', 'C'},\n        {'E', 'B'},\n        {'E', 'D'},\n        {'F', 'G'} };\n    int vlen = LENGTH(vexs);\n    int elen = LENGTH(edges);\n    int i, p1, p2;\n    ENode* node1;\n    LGraph* pG;\n    if ((pG = (LGraph*)malloc(sizeof(LGraph))) == NULL)\n        return NULL;\n    memset(pG, 0, sizeof(LGraph));\n\n    // 初始化\"顶点数\"和\"边数\"\n    pG-&gt;vexnum = vlen;\n    pG-&gt;edgnum = elen;\n    // 初始化\"邻接表\"的顶点\n    for (i = 0; i &lt; pG-&gt;vexnum; i++)\n    {\n        pG-&gt;vexs[i].data = vexs[i];\n        pG-&gt;vexs[i].first_edge = NULL;\n    }\n\n    // 初始化\"邻接表\"的边\n    for (i = 0; i &lt; pG-&gt;edgnum; i++)\n    {\n        // 读取边的起始顶点和结束顶点\n        c1 = edges[i][0];\n        c2 = edges[i][1];\n\n        p1 = get_position(*pG, c1);\n        p2 = get_position(*pG, c2);\n        // 初始化node1\n        node1 = (ENode*)calloc(1, sizeof(ENode));\n        node1-&gt;ivex = p2;\n        // 将node1链接到\"p1所在链表的末尾\"\n        if (pG-&gt;vexs[p1].first_edge == NULL)\n            pG-&gt;vexs[p1].first_edge = node1;\n        else\n            link_last(pG-&gt;vexs[p1].first_edge, node1);\n    }\n      \n    return pG;\n}\nint main()\n{\n    LGraph* pG;\n    pG = create_example_lgraph_directed();\n    DFSTraverse(*pG);//深度优先遍历\n    BFS(*pG);//广度优先遍历\n    return 0;\n}</code></pre>\n<h3>高级day3-作业</h3>\n<p><img alt=\"\" height=\"638\" src=\"image\\ac167bc757e94bec8591e5a587081553.png\" width=\"1200\"/></p>\n<p> </p>\n<pre><code class=\"language-cpp\">#include&lt;stdio.h&gt;\n\n\nint main()\n{\n\tprintf(\"%3d%3d\\n\", 0, 13);\n\treturn 0;\n}</code></pre>\n<h3>高级day4-作业</h3>\n<p><img alt=\"\" height=\"603\" src=\"image\\1a92753c5949482c858c4b6a16f0fb82.png\" width=\"1200\"/></p>\n<pre><code class=\"language-cpp\">#define _CRT_SECURE_NO_WARNINGS\n#include&lt;stdio.h&gt;\nint main()\n{\n\tint i;\n\tscanf(\"%d\", &amp;i);\n\tprintf(\"%2d\\n\", i &lt;&lt; 1);\n\tprintf(\"%2d\\n\", i &gt;&gt; 1);\n\t\treturn 0;\n}</code></pre>\n<h3> 高级day5-作业</h3>\n<p><img alt=\"\" height=\"530\" src=\"image\\dabfc4943f964b2d9d12619f30806ee7.png\" width=\"1200\"/></p>\n<pre><code class=\"language-cpp\">#define _CRT_SECURE_NO_WARNINGS\n#include&lt;stdio.h&gt;\nint main()\n{\n\tint i;\n\tint arr[5];\n\tfor (i = 0; i &lt; 5; i++)\n\t{\n\t\tscanf(\"%d\", arr + i);\n\n\t}\n\tint result=0;\n\tfor (i = 0; i &lt; 5; i++)\n\t{\n\t\tresult ^= arr[i];\n\t}\n\tprintf(\"%d\\n\", result);\n\t\treturn 0;\n}\n</code></pre>\n<h3> 高级day6-作业</h3>\n<p><img alt=\"\" height=\"677\" src=\"image\\30899c54c7334acca1bdd1deb62bb5b0.png\" width=\"1200\"/></p>\n<pre><code class=\"language-cpp\">#include&lt;stdio.h&gt;\n\nint main()\n{\n\tprintf(\"mov\\npush\\npop\\n\");\n\treturn 0;\n}</code></pre>\n<p> </p>\n</div>\n</div>"}