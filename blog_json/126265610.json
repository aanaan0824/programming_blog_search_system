{"blogid": "126265610", "writerAge": "码龄3年", "writerBlogNum": "28", "writerCollect": "223", "writerComment": "365", "writerFan": "416", "writerGrade": "5级", "writerIntegral": "1691", "writerName": "繁华的梦境", "writerProfileAdress": "writer_image\\profile_126265610.jpg", "writerRankTotal": "13895", "writerRankWeekly": "7804", "writerThumb": "480", "writerVisitNum": "33469", "blog_read_count": "207", "blog_time": "于 2022-08-10 14:30:50 发布", "blog_title": "C++动态内存管理", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-light\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p></p>\n<div class=\"toc\">\n<h3>目录</h3>\n<ul><li><a href=\"#CC_1\">C/C++动态内存管理</a></li><li><a href=\"#newdelete_8\">new和delete</a></li><li><a href=\"#operator_newoperator_delete_66\">operator new和operator delete</a></li><li><a href=\"#placementnew_99\">placement-new</a></li><li><a href=\"#_115\">内存泄露</a></li></ul>\n</div>\n<p></p>\n<h1><a id=\"CC_1\"></a>C/C++动态内存管理</h1>\n<p>讲解之前先看一下C/C++中程序内存区域划分<br/> <img alt=\"在这里插入图片描述\" src=\"image\\c2349ebdd36a48ada06d7ccaaae8d1c2.png\"/></p>\n<blockquote>\n<p>需要注意：<br/> 1.const变量不是定义在常量区的，c语言中const全局变量存储在只读数据段，编译期最初将其保存在符号表中，第一次使用时为其分配内存，在程序结束时释放。而const局部变量（局部变量就是在函数中定义的一个const变量，）存储在栈中，代码块结束时释放。<br/> 2.一般情况下，在栈区开辟空间，先开辟的空间地址较高，在堆区开辟空间，先开辟的空间一般地址较低，但是不一定，在堆区开辟空间，后开辟的空间的地址不一定比先开辟的空间地址高，因为如果前面开辟的某一块空间可能被释放了，然后后面申请一块空间可能会申请之前被释放掉的空间</p>\n</blockquote>\n<h1><a id=\"newdelete_8\"></a>new和delete</h1>\n<p>C语言我们可以通过malloc和free申请和释放一块空间，但有些地方就无能为力而且使用起来比较麻烦，因此C++又提出了自己的内存管理方式：通过new和delete操作符进行动态内存管理，看下用法：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token comment\">// 动态申请一个int类型的空间</span>\n\t<span class=\"token keyword\">int</span><span class=\"token operator\">*</span> date1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token comment\">// 动态申请一个int类型的空间并初始化为10</span>\n\t<span class=\"token keyword\">int</span><span class=\"token operator\">*</span> date2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token comment\">// 动态申请3个int类型的空间</span>\n\t<span class=\"token keyword\">int</span><span class=\"token operator\">*</span> date3 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">delete</span> date1<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">delete</span> date2<span class=\"token punctuation\">;</span>\n\t<span class=\"token comment\">//如果是单个数据不用加[]，如果释放多个数据需要在delete后跟一个[]</span>\n\t<span class=\"token keyword\">delete</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> date3<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p><strong>new/delete和malloc/free针对内置类型没有差别，只是用法不一样</strong><br/> 看一下针对自定义类型</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Date</span>\n<span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n\t<span class=\"token function\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t\t<span class=\"token operator\">:</span> <span class=\"token function\">_year</span><span class=\"token punctuation\">(</span><span class=\"token number\">2022</span><span class=\"token punctuation\">)</span>\n\t\t<span class=\"token punctuation\">,</span> <span class=\"token function\">_month</span><span class=\"token punctuation\">(</span><span class=\"token number\">8</span><span class=\"token punctuation\">)</span>\n\t\t<span class=\"token punctuation\">,</span> <span class=\"token function\">_day</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span><span class=\"token punctuation\">}</span>\n\t<span class=\"token operator\">~</span><span class=\"token function\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\tcout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"~Date:\"</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token keyword\">this</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">private</span><span class=\"token operator\">:</span>\n\t<span class=\"token keyword\">int</span> _year<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> _month<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> _day<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\n\tDate<span class=\"token operator\">*</span> p1 <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>Date<span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>Date<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">free</span> <span class=\"token punctuation\">(</span>p1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\n\tDate<span class=\"token operator\">*</span> p2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> Date<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">delete</span> p2<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\e23e0fd1f5374fd49619f3ac081f5a24.png\"/><br/> 可以看到new和delete都开辟了一块空间，new还调用了构造函数。<br/> <img alt=\"在这里插入图片描述\" src=\"image\\cefacf5d651f47b1aa459ea92e008e4a.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"image\\81427c0d6c454db49410a93b1959258b.png\"/><br/> free和delete都释放了空间，delete还调用了析构函数<br/> <strong>总结：<br/> 1.C++中如果是申请内置类型对象或者数组，malloc和free没有区别<br/> 2.如果是自定义类型，区别很大，new和delete是开空间+调用构造函数初始化，析构函数清理（在空间上执行析构函数，完成对象中资源的清理工作）+释放空间（释放对象的空间），malloc和free仅仅是开空间+释放空间<br/> 3.建议在C++中，无论是内置类型还是自定义类型的申请释放，尽量使用new和delete</strong></p>\n<h1><a id=\"operator_newoperator_delete_66\"></a>operator new和operator delete</h1>\n<blockquote>\n<p>new和delete是用户进行动态内存申请和释放的操作符，operator new 和operator delete是系统提供的全局函数，new在底层调用operator new全局函数来申请空间，delete在底层通过operator delete全局函数来释放空间</p>\n</blockquote>\n<p>operator new 实际也是通过malloc来申请空间，如果malloc申请空间<br/> 成功就直接返回，否则执行用户提供的空间不足应对措施，如果用户提供该措施就继续申请，否则就抛异常。operator delete 最终是通过free来释放空间的</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">int</span><span class=\"token operator\">*</span> p1 <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token keyword\">operator</span> <span class=\"token keyword\">new</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token operator\">*</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">operator</span> <span class=\"token keyword\">delete</span><span class=\"token punctuation\">(</span>p1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n等价于\n<span class=\"token keyword\">int</span><span class=\"token operator\">*</span> p1 <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token operator\">*</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">free</span><span class=\"token punctuation\">(</span>p1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\b7b05f36853047d69cf7d6edd4dd4b82.png\"/><br/> <strong>总结：<br/> 内置类型：</strong><br/> 如果申请的是内置类型的空间，new和malloc，delete和free基本类似，不同的地方是：new/delete申请和释放的是单个元素的空间，new[]和delete[]申请的是连续空间，而且new在申请空间失败时会抛异常，malloc会返回NULL。<br/> <strong>自定义类型：</strong><br/> new的原理<br/> 1.调用operator new函数申请空间<br/> 2.在申请的空间上执行构造函数，完成对象的构造<br/> delete的原理<br/> 3.在空间上执行析构函数，完成对象中资源的清理工作<br/> 4.调用operator delete函数释放对象的空间<br/> 5.malloc/free和new/delete的区别</p>\n<blockquote>\n<p>malloc/free和new/delete的区别<br/> 1.malloc和free是函数，new和delete是操作符<br/> 2. malloc申请的空间不会初始化，new可以初始化<br/> 3.malloc申请空间时，需要手动计算空间大小并传递，new只需在其后跟上空间的类型即可<br/> 4.malloc的返回值为void*,在使用时必须强转，new不需要，因为new后跟的是空间的类型<br/> 5.malloc申请空间失败时，返回的是NULL，因此使用时必须判空，new不需要，但是new需要捕获异常<br/> 6.申请自定义类型对象时，malloc/free只会开辟空间，不会调用构造函数与析构函数，而new在申请空间后会调用构造函数完成对象的初始化，delete在释放空间前会调用析构函数完成空间中资源的清理</p>\n</blockquote>\n<h1><a id=\"placementnew_99\"></a>placement-new</h1>\n<blockquote>\n<p>placement-new也就是定位new表达式，是在已分配的原始内存空间中调用构造函数初始化一个对象。定位new表达式在实际中一般是配合内存池使用。因为内存池分配出的内存没有初始化，所以如果是自定义类型的对象，需要使用new的定义表达式进行显示调构造函数进行初始化。<br/> <strong>使用格式：</strong><br/> new (place_address) type或者new (place_address) type(initializer-list)<br/> place_address必须是一个指针，initializer-list是类型的初始化列表</p>\n</blockquote>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\tDate<span class=\"token operator\">*</span> d1 <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>Date<span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>Date<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">new</span><span class=\"token punctuation\">(</span>d1<span class=\"token punctuation\">)</span> Date<span class=\"token punctuation\">;</span>\n\t<span class=\"token comment\">//如果Date类的构造函数有参数时，需要传参，new(d1) Date(4)</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>Date* d1 = (Date*)malloc(sizeof(Date))和new(d1) Date这两句等价于Date* d1 = new Date;<br/> 析构函数也可以显示调用：p-&gt;~A()，operator delete(p )等价于 delete p</p>\n<h1><a id=\"_115\"></a>内存泄露</h1>\n<blockquote>\n<p>内存泄漏指因为疏忽或错误造成程序未能释放已经不再使用的内存的情况。内存泄漏并不是指内存在物理上的消失，而是应用程序分配某段内存后，因为设计错误，失去了对该段内存的控制，因而造成了内存的浪费</p>\n</blockquote>\n<p><strong>内存泄漏的危害：</strong><br/> 长期运行的程序出现内存泄漏，影响很大，如操作系统、后台服务等等，出现内存泄漏会导致响应越来越慢，最终卡死</p>\n<blockquote>\n<p>C/C++程序中一般我们关心两种方面的内存泄漏：<br/> <strong>堆内存泄露</strong> 堆内存指的是程序执行中依据须要分配通过malloc /calloc / realloc / new等从堆中分配的一块内存，用完后必须通过调用相应的 free或者delete删掉。假设程序的设计错误导致这部分内存没有被释放，那么以后这部分空间将无法再被使用，就会产生堆内存泄露。<br/> <strong>系统资源泄漏</strong> 指程序使用系统分配的资源，比如方套接字、文件描述符、管道等没有使用对应的函数释放掉，导致系统资源的浪费，严重可导致系统效能减少，系统执行不稳定。</p>\n<blockquote>\n<p>如何避免内存泄漏<br/> 1.工程前期良好的设计规范，养成良好的编码规范，申请的内存空间记着匹配的去释放。ps：这个理想状态。但是如果碰上异常时，就算注意释放了，还是可能会出问题。需要下一条智能指针来管理才有保证。<br/> 2.采用RAII思想或者智能指针来管理资源。<br/> 3.有些公司内部规范使用内部实现的私有内存管理库。这套库自带内存泄漏检测的功能选项。<br/> 4.出问题了使用内存泄漏工具检测。ps：不过很多工具都不够靠谱，或者收费昂贵。内存泄漏非常常见，解决方案分为两种：1、事前预防型。如智能指针等。2、事后查错型。如泄漏检测工具</p>\n</blockquote>\n</blockquote>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}