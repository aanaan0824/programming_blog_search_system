{"blogid": "122727045", "writerAge": "码龄3年", "writerBlogNum": "99", "writerCollect": "417", "writerComment": "27", "writerFan": "2515", "writerGrade": "4级", "writerIntegral": "1109", "writerName": "Licht小粉", "writerProfileAdress": "writer_image\\profile_122727045.jpg", "writerRankTotal": "15881", "writerRankWeekly": "2819", "writerThumb": "98", "writerVisitNum": "138933", "blog_read_count": "2853", "blog_time": "已于 2022-07-06 17:10:47 修改", "blog_title": "QT之connect的第五个参数(信号与槽的使用)（qt对象树）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%80%20%E3%80%81QT%20connect%20%E7%AC%AC5%E4%B8%AA%E5%8F%82%E6%95%B0%E4%B8%80%E8%88%AC%E4%B8%8D%E5%A1%AB%EF%BC%8C%E4%B8%BA%E9%BB%98%E8%AE%A4%E5%80%BC%E3%80%82\">一 、QT connect 第5个参数一般不填，为默认值。</a></p>\n<p id=\"%E4%BA%8C%E3%80%81%E4%BF%A1%E5%8F%B7-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BA%8C%E3%80%81%E4%BF%A1%E5%8F%B7\">二、信号</a></p>\n<p id=\"%E4%B8%89%E3%80%81connect%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%89%E3%80%81connect%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B\">三、connect函数原型</a></p>\n<p id=\"%E5%9B%9B%E3%80%81%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD%E7%9A%84%E5%A4%9A%E7%A7%8D%E7%94%A8%E6%B3%95-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%9B%9B%E3%80%81%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD%E7%9A%84%E5%A4%9A%E7%A7%8D%E7%94%A8%E6%B3%95\">四、信号与槽的多种用法</a></p>\n<p id=\"%E4%BA%94%E3%80%81%E6%A7%BD%E7%9A%84%E5%B1%9E%E6%80%A7-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BA%94%E3%80%81%E6%A7%BD%E7%9A%84%E5%B1%9E%E6%80%A7\">五、槽的属性</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h1 id=\"%E4%B8%80%20%E3%80%81QT%20connect%20%E7%AC%AC5%E4%B8%AA%E5%8F%82%E6%95%B0%E4%B8%80%E8%88%AC%E4%B8%8D%E5%A1%AB%EF%BC%8C%E4%B8%BA%E9%BB%98%E8%AE%A4%E5%80%BC%E3%80%82\"><strong>一 、QT connect 第5个参数一般不填，为默认值。</strong></h1>\n<p>1、<strong>Qt::AutoConnection</strong>： 默认值，使用这个值则连接类型会在信号发送时决定。如果<strong>接收者和发送者在同一个线程</strong>，则自动使用<strong>Qt::DirectConnection</strong>类型。如果接收者和发送者<strong>不在一个线程</strong>，则自动使用<strong>Qt::QueuedConnection</strong>类型。</p>\n<p>  2、<strong>Qt::DirectConnection</strong>：<strong>槽函数会在信号发送的时候直接被调用</strong>，槽函数和信号发送者在同一线程。效果看上去就像是直接在信号发送位置调用了槽函数，效果上看起来像函数调用，同步执行。<br/><strong>emit语句后面的代码将在与信号关联的所有槽函数<span style=\"color:#be191c;\">执行完毕</span>后才被执行。</strong></p>\n<p><strong>无论槽函数所属对象在哪个线程，槽函数都在<span style=\"color:#be191c;\">发射信号的线程</span>内执行。</strong></p>\n<p>  3、<strong>Qt::QueuedConnection</strong>：<strong>信号发出后</strong>，信号会暂时被放到一个<strong><span style=\"color:#4da8ee;\">消息队列</span></strong>中，需<strong>等到接收对象所属线程的事件循环取得控制权时才取得该信号</strong>，然后执行和信号关联的槽函数，这种方式<strong>既可以在同一线程内传递消息也可以跨线程操作。</strong></p>\n<p><strong>emit语句后的代码将在发出信号后<span style=\"color:#be191c;\">立即被执行</span>，<span style=\"color:#be191c;\">无需等待</span>槽函数执行完毕</strong></p>\n<p><strong>槽函数在<span style=\"color:#be191c;\">接收者所依附线程</span>执行。</strong></p>\n<p>4、<strong>Qt::BlockingQueuedConnection</strong>：<strong>槽函数的调用时机与Qt::QueuedConnection一致</strong>，不过发送完信号后发送者所在线程会<strong>阻塞</strong>，<strong>直到槽函数运行完</strong>。而且接收者和发送者<strong>绝对不能在一个线程，否则程序会死锁</strong>。在<strong>多线程间需要同步</strong>的场合可能需要这个。</p>\n<p>  5、<strong>Qt::UniqueConnection</strong>：这个flag可以通过按位或（|）与以上四个结合在一起使用。当这个flag设置时，当某个信号和槽已经连接时，再进行重复的连接就会失败。也就是为了<strong>避免重复连接。</strong></p>\n<p><strong>一般qt connect的第五个参数会在多线程中运用到,需要注意的是:</strong></p>\n<p><strong>QThread是用来管理线程的，QThread对象所依附的线程和所管理的线程并不是同一个概念。</strong>QThread<strong>所依附的线程</strong>，就是<strong>创建</strong>QThread<strong>对象的线程</strong>;QThread 所<strong>管理的线程</strong>，就是<strong>run启动的线程，也就是新建线程</strong>。</p>\n<p><strong>例如:QThread对象依附在主线程中，QThread对象的slot函数会在主线程中执行，而不是次线程。除非QThread对象依附到次线程中(通过movetoThread)。</strong></p>\n<p><strong>或许你可能会感兴趣:</strong></p>\n<p><strong><a class=\"link-info\" href=\"https://blog.csdn.net/ligare/article/details/122704799?spm=1001.2014.3001.5501\" title=\"QT 多线程 之MoveToThread使用详解\">QT 多线程 之MoveToThread使用详解</a></strong></p>\n<p><a class=\"link-info\" href=\"https://blog.csdn.net/ligare/article/details/122730222?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164672895416780255213783%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=164672895416780255213783&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-6-122730222.nonecase&amp;utm_term=connect&amp;spm=1018.2226.3001.4450\" title=\"QT发送结构体信号\">QT发送结构体信号</a></p>\n<p></p>\n<h1 id=\"%E4%BA%8C%E3%80%81%E4%BF%A1%E5%8F%B7\"><strong>二、信号</strong></h1>\n<p><strong>声明</strong>信号使用<strong>signals</strong>关键字,<strong>发送</strong>信号使用<strong>emit</strong>关键字。</p>\n<p><strong>注意点:</strong></p>\n<p>1.所有的信号声明都是<strong>公有的</strong>，所以Qt规定不能在signals前面加public,private, protected。</p>\n<p>2.所有的信号都没有返回值，所以<strong>返回值都用void</strong>。</p>\n<p>3.所有的<strong>信号都不需要定义</strong>。</p>\n<p>4.<strong>必须直接或间接继承自QOBject类，并且开头私有声明包含Q_OBJECT</strong>。</p>\n<p>5.在<strong>同一个线程</strong>中，当一个信号被emit发出时，会立即执行其槽函数，<strong>等槽函数执行完毕后，才会执行emit后面的代码</strong>，如果<strong>一个信号链接了多个槽</strong>，那么会等所有的槽函数执行完毕后才执行后面的代码，槽函数的执行顺序是按照它们链接时的顺序执行的。<strong>不同线程中（即跨线程时），槽函数的执行顺序是随机的。</strong></p>\n<p>6.在链接信号和槽时，可以设置链接方式为：在发出信号后，不需要等待槽函数执行完，而是直接执行后面的代码，是通过connect的第5个参数。</p>\n<p>7.<strong>信号与槽机制要求信号和槽的<span style=\"color:#be191c;\">参数一致</span></strong>，所谓一致，是<strong>参数类型一致</strong>。如果不一致，允许的情况是，<strong>信号的参数可以比槽函数的参数多</strong>，即便如此，槽函数存在的那些参数的顺序也必须和信号的前面几个一致起来。这是因为，你可以在槽函数中选择忽略信号传来的数据（也就是槽函数的参数比信号的少），但是不能说信号根本没有这个数据，你就要在槽函数中使用（就是槽函数的参数比信号的多，这是不允许的）。</p>\n<h1 id=\"%E4%B8%89%E3%80%81connect%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B\"><br/><strong>三、connect函数原型</strong></h1>\n<p>a.如：connect(pushButton, SIGNAL(clicked()), dialog, SLOT(close()));Qt4和Qt5都可以使用这种连接方式。</p>\n<pre><code>    static QMetaObject::Connection connect(\n    const QObject *sender,    //信号发送对象指针\n    const char *signal,       //信号函数字符串，使用SIGNAL()\n    const QObject *receiver,  //槽函数对象指针\n    const char *member,       //槽函数字符串，使用SLOT()\n    Qt::ConnectionType = Qt::AutoConnection);</code></pre>\n<p>b.如：connect(pushButton, &amp;QPushButton::clicked, dialog, &amp;QDialog::close);这是Qt5新增的连接方式，这使得在编译期间就可以进行拼写检查，参数检查，类型检查，并且支持相容参数的兼容性转换。</p>\n<pre><code>    static QMetaObject::Connection connect(\n    const QObject *sender,      //信号发送对象指针\n    const QMetaMethod &amp;signal,  //信号函数地址\n    const QObject *receiver,    //槽函数对象指针\n    const QMetaMethod &amp;method,  //槽函数地址\n    Qt::ConnectionType type = Qt::AutoConnection);</code></pre>\n<p><strong><span style=\"color:#be191c;\">注：qt5之后，这种新型的写法，支持所有的函数类型，无需定义slot关键字也可以。</span></strong></p>\n<p></p>\n<h1 id=\"%E5%9B%9B%E3%80%81%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD%E7%9A%84%E5%A4%9A%E7%A7%8D%E7%94%A8%E6%B3%95\"><strong>四、信号与槽的多种用法</strong></h1>\n<p>1、一个信号可以和多个槽相连;</p>\n<p>2、多个信号可以连接到一个槽;</p>\n<p>3、一个信号可以连接到另外的一个信号;</p>\n<p>4、槽可以被取消链接.</p>\n<p><strong>其写法和connect一样，只需要将connect换成disconnect即可。</strong></p>\n<p></p>\n<h1 id=\"%E4%BA%94%E3%80%81%E6%A7%BD%E7%9A%84%E5%B1%9E%E6%80%A7\"><strong>五、</strong><strong>槽的属性</strong></h1>\n<p><strong>public slots</strong>：在这个区内声明的槽意味着<strong>所有对象都可将信号</strong>和之<strong>相连接</strong>。这对于组件编程非常有用，你能创建彼此互不了解的对象，将他们的信号和槽进行连接以便信息能够正确的传递。 <br/><strong>protected slots</strong>：在这个区内声明的槽意味着<strong>当前类及其子类</strong>能将信号和之相连接。<br/><strong>private slots</strong>：在这个区内声明的槽意味着只有<strong>类自己</strong>能将信号和之相连接。</p>\n<p><strong>注:信号和槽不能携带模板类参数.</strong><br/><strong>补充:</strong></p>\n<p>Qt提供了一种机制，能够自动、有效的组织和管理<strong>继承自QObject的Qt对象</strong>，这种机制就是<span style=\"color:#be191c;\"><strong>对象树.</strong></span></p>\n<p><strong>优点:</strong>能够帮助程序员缓解<strong>内存泄露</strong>的问题,提高编程效率，同时也保证了系统的稳健性.</p>\n<p><strong>举例</strong>:当应用程序创建了一个具有父窗口部件的对象时，该对象将被加入父窗口部件的孩子列表。当应用程序销毁父窗口部件时，其下的孩子列表中的对象将被一一删除.<strong>这就是为什么我们创建出一个对象时,都最好在初始化的时候加上this指针.</strong>new了一个父窗口后，只要delete父窗口后，那它的子窗口都会被自动释放，<strong>释放顺序（即析构顺序）与这些子对象的构造顺序相反.</strong></p>\n<p></p>\n<p><img alt=\"\" height=\"616\" src=\"image\\282d87ca7103492ea6dbdb3144805b35.png\" width=\"1163\"/></p>\n<p></p>\n</div>\n</div>"}