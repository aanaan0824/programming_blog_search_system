{"blogid": "121780133", "writerAge": "码龄15年", "writerBlogNum": "613", "writerCollect": "728", "writerComment": "275", "writerFan": "3270", "writerGrade": "8级", "writerIntegral": "29092", "writerName": "孙飞 Sunface", "writerProfileAdress": "writer_image\\profile_121780133.jpg", "writerRankTotal": "93833", "writerRankWeekly": "10657", "writerThumb": "845", "writerVisitNum": "2511167", "blog_read_count": "1162", "blog_time": "于 2021-12-07 22:15:02 发布", "blog_title": "Rust学习教程12 - String字符串与切片", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-tomorrow-night\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<blockquote>\n<p>本文节选自<a href=\"https://github.com/sunface/rust-course\">&lt;&lt;Rust语言圣经&gt;&gt;</a>一书<br/> 欢迎大家加入Rust编程学院，一起学习交流:<br/> QQ群：1009730433</p>\n</blockquote>\n<h1><a id=\"_5\"></a>字符串</h1>\n<p>在其他语言，字符串往往是送分题，因为实在是太简单了，例如<code>\"hello, world\"</code>就是字符串章节的几乎全部内容了，对吧？如果你带着这样的想法来学Rust，<br/> 我保证，绝对会栽跟头，<strong>因此这一章大家一定要重视，仔细阅读，这里有很多其它Rust书籍中没有的内容</strong>。</p>\n<p>首先来看段很简单的代码：</p>\n<pre><code class=\"prism language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n  <span class=\"token keyword\">let</span> my_name <span class=\"token operator\">=</span> <span class=\"token string\">\"Pascal\"</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">greet</span><span class=\"token punctuation\">(</span>my_name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">greet</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">:</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n  <span class=\"token macro property\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello, {}!\"</span><span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p><code>greet</code>函数接受一个字符串类型的<code>name</code>参数，然后打印到终端控制台中，非常好理解，你们猜猜，这段代码能否通过编译？</p>\n<pre><code class=\"prism language-conole\">error[E0308]: mismatched types\n --&gt; src/main.rs:3:11\n  |\n3 |     greet(my_name);\n  |           ^^^^^^^\n  |           |\n  |           expected struct `std::string::String`, found `&amp;str`\n  |           help: try using a conversion method: `my_name.to_string()`\n\nerror: aborting due to previous error\n</code></pre>\n<p>Bingo，果然报错了，编译器提示<code>greet</code>函数需要一个<code>String</code>类型的字符串，却传入了一个<code>&amp;str</code>类型的字符串，相信读者心中现在一定有几头草泥马呼啸而过，怎么字符串也能整出这么多花活？</p>\n<p>在讲解字符串之前，先来看看什么是切片?</p>\n<h2><a id=\"slice_41\"></a>切片(slice)</h2>\n<p>切片并不是Rust独有的概念，在Go语言中就非常流行，它允许你引用集合中一段连续的元素序列，而不是引用整个集合。</p>\n<p>对于字符串而言，切片就是对<code>String</code>类型中某一部分的引用，它看起来像这样：</p>\n<pre><code class=\"prism language-rust\"><span class=\"token keyword\">let</span> s <span class=\"token operator\">=</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello world\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> hello <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>s<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">..</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> world <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>s<span class=\"token punctuation\">[</span><span class=\"token number\">6</span><span class=\"token punctuation\">..</span><span class=\"token number\">11</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p><code>hello</code>没有引用整个<code>String s</code>，而是引用了<code>s</code>的一部分内容，通过<code>[0..5]</code>的方式来指定。</p>\n<p>这就是创建切片的语法，使用方括号包括的一个序列: <strong>[开始索引…终止索引]</strong>，其中开始索引是切片中第一个元素的索引位置，而终止索引是最后一个元素后面的索引位置，也就是这是一个<code>右半开区间</code>。在内部，切片数据结构会保存开始的位置和切片的长度，其中长度是通过<code>终止索引</code> - <code>开始索引</code>的方式计算得来的。</p>\n<p>对于<code>let world = &amp;s[6..11];</code>来说，<code>world</code>是一个切片，该切片的指针指向<code>s</code>的第7个字节(索引从0开始,6是第7个字节)，且该切片的长度是<code>5</code>个字节。</p>\n<img alt=\"\" class=\"center\" src=\"/img/string-01.svg\"/>\n<p><span class=\"caption\">图：String切片引用了另一个<code>String</code>的一部分</span></p>\n<p>在使用Rust的<code>..</code>区间(range)语法时，如果你想从索引0开始，可以使用如下的方式，这两个是等效的：</p>\n<pre><code class=\"prism language-rust\"><span class=\"token keyword\">let</span> s <span class=\"token operator\">=</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> slice <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>s<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">..</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> slice <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>s<span class=\"token punctuation\">[</span><span class=\"token punctuation\">..</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>同样的，如果你的切片想要包含<code>String</code>的最后一个字节，则可以这样使用:</p>\n<pre><code class=\"prism language-rust\"><span class=\"token keyword\">let</span> s <span class=\"token operator\">=</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> len <span class=\"token operator\">=</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">len</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> slice <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>s<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">..</span>len<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> slice <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>s<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>你也可以截取完整的<code>String</code>切片：</p>\n<pre><code class=\"prism language-rust\"><span class=\"token keyword\">let</span> s <span class=\"token operator\">=</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> len <span class=\"token operator\">=</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">len</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> slice <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>s<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">..</span>len<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> slice <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>s<span class=\"token punctuation\">[</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<blockquote>\n<p>在对字符串使用切片语法时需要格外小心，切片的索引必须落在字符之间的边界位置，也就是UTF8字符的边界，例如中文在UT8中占用三个字节,下面的代码就会崩溃:</p>\n<pre><code class=\"prism language-rust\"> <span class=\"token keyword\">let</span> s <span class=\"token operator\">=</span> <span class=\"token string\">\"中国人\"</span><span class=\"token punctuation\">;</span>\n <span class=\"token keyword\">let</span> a <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>s<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">..</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n <span class=\"token macro property\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"{}\"</span><span class=\"token punctuation\">,</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>因为我们只取<code>s</code>字符串的前两个字节，但是一个中文占用三个字节，因此没有落在边界处，也就是连<code>中</code>字都取不完整，此时程序会直接崩溃退出，如果改成<code>&amp;a[0..3]</code>，则可以正常通过编译.<br/> 因此，当你需要对字符串做切片索引操作时，需要格外小心这一点, 关于该如何操作utf8字符串，参见<a href=\"#%E6%93%8D%E4%BD%9CUTF8%E5%AD%97%E7%AC%A6%E4%B8%B2\">这里</a></p>\n</blockquote>\n<p>字符串切片的类型标示是<code>&amp;str</code>，因此我们可以这样申明一个函数，输入<code>String</code>类型，返回它的切片: <code>fn first_word(s: &amp;String) -&gt; &amp;str</code>.</p>\n<p>有了切片就可以写出这样的安全代码：</p>\n<pre><code class=\"prism language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">let</span> <span class=\"token keyword\">mut</span> s <span class=\"token operator\">=</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello world\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">let</span> word <span class=\"token operator\">=</span> <span class=\"token function\">first_word</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    s<span class=\"token punctuation\">.</span><span class=\"token function\">clear</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// error!</span>\n\n    <span class=\"token macro property\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"the first word is: {}\"</span><span class=\"token punctuation\">,</span> word<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>编译器报错如下：</p>\n<pre><code class=\"prism language-console\">error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable\n  --&gt; src/main.rs:18:5\n   |\n16 |     let word = first_word(&amp;s);\n   |                           -- immutable borrow occurs here\n17 | \n18 |     s.clear(); // error!\n   |     ^^^^^^^^^ mutable borrow occurs here\n19 | \n20 |     println!(\"the first word is: {}\", word);\n   |                                       ---- immutable borrow later used here\n</code></pre>\n<p>回忆一下借用的规则：当我们已经有了可变借用时，就无法再拥有不可变的借用。因为<code>clear</code>需要清空改变<code>String</code>，因此它需要一个可变借用，而之后的<code>println!</code>又使用了不可变借用，因此编译无法通过。</p>\n<p>从上述代码可以看出，Rust不仅让我们的<code>api</code>更加容易使用，而且也在编译器就位我们消除了大量错误！</p>\n<h4><a id=\"_133\"></a>其它切片</h4>\n<p>因为切片是对集合的部分引用，因此不仅仅字符串有切片，其它集合类型也有，例如数组:</p>\n<pre><code class=\"prism language-rust\"><span class=\"token keyword\">let</span> a <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> slice <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">..</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token macro property\">assert_eq!</span><span class=\"token punctuation\">(</span>slice<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span><span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>该数组切片的类型是<code>&amp;[i32]</code>，数组切片和字符串切片的工作方式是一样的，例如持有一个引用指向原始数组的某个元素和长度。对于集合类型，我们在<a href=\"../advance/collection.md\">这一章</a>中有详细的介绍。</p>\n<h2><a id=\"_145\"></a>字符串字面量是切片</h2>\n<p>之前提到过字符串字面量,但是没有提到它的类型：</p>\n<pre><code class=\"prism language-rust\"><span class=\"token keyword\">let</span> s <span class=\"token operator\">=</span> <span class=\"token string\">\"Hello, world!\"</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>实际上，<code>s</code>的类型时<code>&amp;str</code>，因此你也可以这样声明：</p>\n<pre><code class=\"prism language-rust\"><span class=\"token keyword\">let</span> s<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span><span class=\"token keyword\">str</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"Hello, world!\"</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>该切片指向了程序可执行文件中的某个点，这也是为什么字符串字面量是不可变的，因为<code>&amp;str</code>时一个不可变引用。</p>\n<p>了解完切片，可以进入本节的正题了。</p>\n<h2><a id=\"_160\"></a>什么是字符串?</h2>\n<p>顾名思义，字符串是由字符组成的连续集合，但是在上一节中我们提到过，<strong>Rust中的字符是Unicode类型，因此每个字符占据4个字节内存空间，但是在字符串中不一样，字符串是UTF8编码，也就是字符所占的字节数是变长的(1-4)</strong>，这样有助于大幅降低字符串所占用的内存空间.</p>\n<p>Rust在语言级别，只有一种字符串类型：<code>str</code>，它通常是以引用类型出现<code>&amp;str</code>，也就是上文提到的字符串切片。虽然语言级别只有上述的<code>str</code>类型，但是在标准库里，还有多种不同用途的字符串类型，其中使用最广的即是<code>String</code>类型。</p>\n<p><code>str</code>类型是硬编码进可执行文件，也无法被修改，但是<code>String</code>则是一个可增长、可改变且具有所有权的UTF8编码字符串，<strong>当Rust用户提到字符串时，往往指的就是<code>String</code>类型和<code>&amp;str</code>字符串切片类型，这两个类型都是UTF8编码</strong>.</p>\n<p>除了<code>String</code>类型的字符串，Rust的标准库还提供了其他类型的字符串，例如<code>OsString</code>,<code>OsStr</code>,<code>CsString</code>和<code>CsStr</code>等，注意到这些名字都以<code>String</code>或者<code>Str</code>结尾了吗？它们分别对应的是具有所有权和被借用的变量。</p>\n<h4><a id=\"_170\"></a>操作字符串</h4>\n<p>由于String是可变字符串，因此我们可以对它进行创建、增删操作，下面的代码汇总了相关的操作方式：</p>\n<pre><code class=\"prism language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token comment\">// 创建一个空String</span>\n    <span class=\"token keyword\">let</span> <span class=\"token keyword\">mut</span> s <span class=\"token operator\">=</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">::</span><span class=\"token function\">new</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 将&amp;str类型的\"hello,world\"添加到中</span>\n    s<span class=\"token punctuation\">.</span><span class=\"token function\">push_str</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello,world\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 将字符'!'推入s中</span>\n    s<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token char string\">'!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 最后s的内容是\"hello,world!\"</span>\n    <span class=\"token macro property\">assert_eq!</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">,</span><span class=\"token string\">\"hello,world!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 从现有的&amp;str切片创建String类型</span>\n    <span class=\"token keyword\">let</span> <span class=\"token keyword\">mut</span> s <span class=\"token operator\">=</span> <span class=\"token string\">\"hello,world\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">to_string</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 将字符'!'推入s中</span>\n    s<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token char string\">'!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 最后s的内容是\"hello,world!\"</span>\n    <span class=\"token macro property\">assert_eq!</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">,</span><span class=\"token string\">\"hello,world!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 从现有的&amp;str切片创建String类型</span>\n    <span class=\"token comment\">// String与&amp;str都是UTF8编码，因此支持中文</span>\n    <span class=\"token keyword\">let</span> <span class=\"token keyword\">mut</span> s <span class=\"token operator\">=</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"你好,世界\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 将字符'!'推入s中</span>\n    s<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token char string\">'!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 最后s的内容是\"hello,world!\"</span>\n    <span class=\"token macro property\">assert_eq!</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">,</span><span class=\"token string\">\"你好,世界!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">let</span> s1 <span class=\"token operator\">=</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello,\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> s2 <span class=\"token operator\">=</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"world!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 在下句中，s1的所有权被转移走了，因此后面不能再使用s1</span>\n    <span class=\"token keyword\">let</span> s3 <span class=\"token operator\">=</span> s1 <span class=\"token operator\">+</span> <span class=\"token operator\">&amp;</span>s2<span class=\"token punctuation\">;</span> <span class=\"token comment\">// note s1 has been moved here and can no longer be used</span>\n    <span class=\"token macro property\">assert_eq!</span><span class=\"token punctuation\">(</span>s3<span class=\"token punctuation\">,</span><span class=\"token string\">\"hello,world!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 下面的语句如果去掉注释，就会报错</span>\n    <span class=\"token comment\">// println!(\"{}\",s1);</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>在上面代码中，有一处需要解释的地方，就是使用<code>+</code>来对字符串进行相加操作， 这里之所以使用<code>s1 + &amp;s2</code>的形式，是因为<code>+</code>使用了<code>add</code>方法，该方法的定义类似:</p>\n<pre><code class=\"prism language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">,</span> s<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span><span class=\"token keyword\">str</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-&gt;</span> <span class=\"token class-name\">String</span> <span class=\"token punctuation\">{<!-- --></span>\n</code></pre>\n<p>因为该方法涉及到更复杂的特征功能，因此我们这里简单说明下，<code>self</code>是<code>String</code>类型的字符串<code>s1</code>,该函数说明，只能将&amp;str类型的字符串切片添加到String类型的<code>s1</code>上，然后返回一个新的<code>String</code>类型，所以<code>let s3 = s1 + &amp;s2;</code>就很好解释了，将<code>String</code>类型的<code>s1</code>与<code>&amp;str</code>类型的<code>s2</code>进行相加，最终得到<code>String</code>类型的s3.</p>\n<p>由此可推，以下代码也是合法的：</p>\n<pre><code class=\"prism language-rust\">  <span class=\"token keyword\">let</span> s1 <span class=\"token operator\">=</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"tic\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">let</span> s2 <span class=\"token operator\">=</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"tac\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">let</span> s3 <span class=\"token operator\">=</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"toe\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// String = String + &amp;str + &amp;str + &amp;str + &amp;str</span>\n  <span class=\"token keyword\">let</span> s <span class=\"token operator\">=</span> s1 <span class=\"token operator\">+</span> <span class=\"token string\">\"-\"</span> <span class=\"token operator\">+</span> <span class=\"token operator\">&amp;</span>s2 <span class=\"token operator\">+</span> <span class=\"token string\">\"-\"</span> <span class=\"token operator\">+</span> <span class=\"token operator\">&amp;</span>s3<span class=\"token punctuation\">;</span>\n</code></pre>\n<p><code>String</code> + <code>&amp;str</code>返回一个<code>String</code>，然后再继续跟一个<code>&amp;str</code>进行<code>+</code>操作，返回一个<code>String</code>类型，不断循环，最终生成一个<code>s</code>，也是<code>String</code>类型。</p>\n<p>在上面代码中，我们做了一个有些难以理解的<code>&amp;String</code>操作，下面来展开讲讲。</p>\n<h2><a id=\"Stringstr_230\"></a>String与&amp;str的转换</h2>\n<p>在之前的代码中，已经见到好几种从<code>&amp;str</code>类型生成<code>String</code>类型的操作：</p>\n<ul><li><code>String::from(\"hello,world\")</code></li><li><code>\"hello,world\".to_string()</code></li></ul>\n<p>那么如何将<code>String</code>类型转为<code>&amp;str</code>类型呢？答案很简单，取引用即可：</p>\n<pre><code class=\"prism language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">let</span> s <span class=\"token operator\">=</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello,world!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">say_hello</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">say_hello</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>s<span class=\"token punctuation\">[</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">say_hello</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">.</span><span class=\"token function\">as_str</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">say_hello</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span><span class=\"token keyword\">str</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token macro property\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"{}\"</span><span class=\"token punctuation\">,</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>实际上这种灵活用法是因为<code>deref</code>强制转换，具体我们会在<a href=\"../traits/deref.md\">Deref特征</a>进行详细讲解。</p>\n<h2><a id=\"_252\"></a>字符串索引</h2>\n<p>在其它语言中，使用索引的方式访问字符串的某个字符或者子串是很正常的行为，但是在Rust中就会报错:</p>\n<pre><code class=\"prism language-rust\"><span class=\"token keyword\">let</span> s1 <span class=\"token operator\">=</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> h <span class=\"token operator\">=</span> s1<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>该代码会产生如下错误：</p>\n<pre><code class=\"prism language-console\">3 |     let h = s1[0];\n  |             ^^^^^ `String` cannot be indexed by `{integer}`\n  |\n  = help: the trait `Index&lt;{integer}&gt;` is not implemented for `String`\n</code></pre>\n<h4><a id=\"_268\"></a>深入字符串内部</h4>\n<p>字符串的底层的数据存储格式实际上是[u8]，一个字节数组。对于<code>let hello = String::from(\"Hola\");</code>这行代码来说，<code>hello</code>的长度是<code>4</code>个字节，因为<code>\"hola\"</code>中的每个字母在UTF8编码中仅占用1个字节，但是对于下面的代码呢?</p>\n<pre><code class=\"prism language-rust\"><span class=\"token keyword\">let</span> hello <span class=\"token operator\">=</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"中国人\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>如果问你该字符串多长，你可能会说<code>3</code>，但是实际上是<code>9</code>个字节的长度，因为每个汉字在UTF8中的长度是<code>3</code>个字节，因此这种情况下对<code>hello</code>进行索引<br/> 访问<code>&amp;hello[0]</code>没有任何意义，因为你取不到<code>中</code>这个字符，而是取到了这个字符三个字节中的第一个字节，这是一个非常奇怪而且难以理解的返回值。</p>\n<h4><a id=\"_276\"></a>字符串的不同表现形式</h4>\n<p>现在看一下用梵文写的字符串<code>“नमस्ते”</code>, 它底层的字节数组如下形式：</p>\n<pre><code class=\"prism language-rust\"><span class=\"token punctuation\">[</span><span class=\"token number\">224</span><span class=\"token punctuation\">,</span> <span class=\"token number\">164</span><span class=\"token punctuation\">,</span> <span class=\"token number\">168</span><span class=\"token punctuation\">,</span> <span class=\"token number\">224</span><span class=\"token punctuation\">,</span> <span class=\"token number\">164</span><span class=\"token punctuation\">,</span> <span class=\"token number\">174</span><span class=\"token punctuation\">,</span> <span class=\"token number\">224</span><span class=\"token punctuation\">,</span> <span class=\"token number\">164</span><span class=\"token punctuation\">,</span> <span class=\"token number\">184</span><span class=\"token punctuation\">,</span> <span class=\"token number\">224</span><span class=\"token punctuation\">,</span> <span class=\"token number\">165</span><span class=\"token punctuation\">,</span> <span class=\"token number\">141</span><span class=\"token punctuation\">,</span> <span class=\"token number\">224</span><span class=\"token punctuation\">,</span> <span class=\"token number\">164</span><span class=\"token punctuation\">,</span> <span class=\"token number\">164</span><span class=\"token punctuation\">,</span>\n<span class=\"token number\">224</span><span class=\"token punctuation\">,</span> <span class=\"token number\">165</span><span class=\"token punctuation\">,</span> <span class=\"token number\">135</span><span class=\"token punctuation\">]</span>\n</code></pre>\n<p>长度是18个字节，这也是计算机最终存储该字符串的形式。如果从字符的形式去看，则是：</p>\n<pre><code class=\"prism language-rust\"><span class=\"token punctuation\">[</span><span class=\"token char string\">'न'</span><span class=\"token punctuation\">,</span> <span class=\"token char string\">'म'</span><span class=\"token punctuation\">,</span> <span class=\"token char string\">'स'</span><span class=\"token punctuation\">,</span> <span class=\"token char string\">'्'</span><span class=\"token punctuation\">,</span> <span class=\"token char string\">'त'</span><span class=\"token punctuation\">,</span> <span class=\"token char string\">'े'</span><span class=\"token punctuation\">]</span>\n</code></pre>\n<p>但是这种形势下，第四和六两个字母根本就不存在，没有任何意义，接着再从字母串的形式去看：</p>\n<pre><code class=\"prism language-rust\"><span class=\"token punctuation\">[</span><span class=\"token string\">\"न\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"म\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"स्\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"ते\"</span><span class=\"token punctuation\">]</span>\n</code></pre>\n<p>所以，可以看出来Rust提供了不同的字符串展现方式，这样程序可以挑选自己想要的方式去使用，而无需去管字符串从人类语言角度看长什么样。</p>\n<p>还有一个原因导致了Rust不允许去索引字符：因为索引操作，我们总是期望它的性能表现是O(1)，然后对于<code>String</code>类型来说，无法保证这一点，因为Rust可能需要从0开始去遍历字符串来定位合法的字符。</p>\n<h2><a id=\"_295\"></a>字符串切片</h2>\n<p>前文提到过，字符串切片是非常危险的操作，因为切片的索引是通过字节来进行，但是字符串是UTF8编码，因此你无法保证索引的字节刚好落在字符的边界上，例如：</p>\n<pre><code class=\"prism language-rust\"><span class=\"token keyword\">let</span> hello <span class=\"token operator\">=</span> <span class=\"token string\">\"中国人\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> s <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>hello<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">..</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>运行上面的程序，会直接造成崩溃：</p>\n<pre><code class=\"prism language-console\">thread 'main' panicked at 'byte index 2 is not a char boundary; it is inside '中' (bytes 0..3) of `中国人`', src/main.rs:4:14\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n</code></pre>\n<p>这里提示的很清楚，我们索引的字节落在了<code>中</code>字符的内部，这种返回没有任何意义。</p>\n<p>因此在通过索引区间来访问字符串时，需要格外的小心，一不注意，就会导致你程序的崩溃！</p>\n<h2><a id=\"UTF8_311\"></a>操作UTF8字符串</h2>\n<p>前文提到了几中使用UTF8字符串的方式，下面来一一说明。</p>\n<h4><a id=\"_314\"></a>字符</h4>\n<p>如果你想要以Unicode字符的方式遍历字符串，最好的办法是使用<code>chars</code>方法，例如：</p>\n<pre><code class=\"prism language-rust\"><span class=\"token keyword\">for</span> c <span class=\"token keyword\">in</span> <span class=\"token string\">\"中国人\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">chars</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token macro property\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"{}\"</span><span class=\"token punctuation\">,</span> c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>输出如下</p>\n<pre><code class=\"prism language-console\">中\n国\n人\n</code></pre>\n<h4><a id=\"_328\"></a>字节</h4>\n<p>这种方式是返回字符串的底层字节数组表现形式：</p>\n<pre><code class=\"prism language-rust\"><span class=\"token keyword\">for</span> b <span class=\"token keyword\">in</span> <span class=\"token string\">\"中国人\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">bytes</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token macro property\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"{}\"</span><span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>输出如下：</p>\n<pre><code class=\"prism language-console\">228\n184\n173\n229\n155\n189\n228\n186\n186\n</code></pre>\n<h4><a id=\"_348\"></a>获取子串</h4>\n<p>想要准确的从UTF8字符串中获取子串是较为复杂的事情，例如想要从<code>holla中国人नमस्ते</code>这种变长的字符串中取出某一个子串，使用标准库你是做不到的，<br/> 你需要在<code>crates.io</code>上搜索<code>utf8</code>来寻找想要的功能。</p>\n<p>可以考虑尝试下这个库:<a href=\"https://crates.io/crates/utf8_slice\">utf8 slice</a>.</p>\n<h2><a id=\"String_354\"></a>String底层剖析</h2>\n<p>@todo</p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}