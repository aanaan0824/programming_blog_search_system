{"blogid": "125611657", "writerAge": "码龄1年", "writerBlogNum": "91", "writerCollect": "6689", "writerComment": "12531", "writerFan": "13041", "writerGrade": "7级", "writerIntegral": "19588", "writerName": "微凉秋意", "writerProfileAdress": "writer_image\\profile_125611657.jpg", "writerRankTotal": "415", "writerRankWeekly": "1", "writerThumb": "7495", "writerVisitNum": "121668", "blog_read_count": "943", "blog_time": "已于 2022-07-08 14:41:03 修改", "blog_title": "＜C++＞初识STL —— 标准模板库", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>✨<strong>引言</strong></p>\n<blockquote>\n<p>        前面的函数模板和类模板都是为了<span style=\"color:#38d8f0;\"><strong>STL</strong></span>的理解做准备的，因此终于迎来了C++提高编程的重点：STL。快来跟博主一起了解标准模板库的基本知识和使用吧！</p>\n<p style=\"text-align:center;\">✨✨订阅专栏学习不迷路哦~✨✨</p>\n</blockquote>\n<p id=\"main-toc\">✨<strong>目录</strong></p>\n<p id=\"STL%E7%9A%84%E5%87%BA%E7%8E%B0%E8%83%8C%E6%99%AF-toc\" style=\"margin-left:0px;\"><a href=\"#STL%E7%9A%84%E5%87%BA%E7%8E%B0%E8%83%8C%E6%99%AF\">STL的出现背景</a></p>\n<p id=\"STL%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-toc\" style=\"margin-left:0px;\"><a href=\"#STL%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\">STL基本概念</a></p>\n<p id=\"STL%E5%85%AD%E5%A4%A7%E7%BB%84%E4%BB%B6-toc\" style=\"margin-left:0px;\"><a href=\"#STL%E5%85%AD%E5%A4%A7%E7%BB%84%E4%BB%B6\">STL六大组件</a></p>\n<p id=\"%E5%88%9D%E8%AF%86%E5%AE%B9%E5%99%A8%E7%AE%97%E6%B3%95%E8%BF%AD%E4%BB%A3%E5%99%A8-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%88%9D%E8%AF%86%E5%AE%B9%E5%99%A8%E7%AE%97%E6%B3%95%E8%BF%AD%E4%BB%A3%E5%99%A8\">初识容器算法迭代器</a></p>\n<p id=\"vector%E5%AE%B9%E5%99%A8%E7%9A%84%E5%88%9D%E6%AC%A1%E4%BD%BF%E7%94%A8-toc\" style=\"margin-left:0px;\"><a href=\"#vector%E5%AE%B9%E5%99%A8%E7%9A%84%E5%88%9D%E6%AC%A1%E4%BD%BF%E7%94%A8\">vector容器的初次使用</a></p>\n<p id=\"%E5%AD%98%E6%94%BE%E5%86%85%E7%BD%AE%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%AD%98%E6%94%BE%E5%86%85%E7%BD%AE%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\">存放内置数据类型</a></p>\n<p id=\"%E5%AD%98%E6%94%BE%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%AD%98%E6%94%BE%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\">存放自定义数据类型</a></p>\n<p id=\"vector%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B5%8C%E5%A5%97%E4%BD%BF%E7%94%A8-toc\" style=\"margin-left:40px;\"><a href=\"#vector%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B5%8C%E5%A5%97%E4%BD%BF%E7%94%A8\">vector容器的嵌套使用</a></p>\n<p id=\"%C2%A0%E8%BF%90%E8%A1%8C%E6%95%88%E6%9E%9C-toc\" style=\"margin-left:0px;\"><a href=\"#%C2%A0%E8%BF%90%E8%A1%8C%E6%95%88%E6%9E%9C\"> 运行效果</a></p>\n<p id=\"%F0%9F%8E%89%E6%80%BB%E7%BB%93%C2%A0-toc\" style=\"margin-left:0px;\"><a href=\"#%F0%9F%8E%89%E6%80%BB%E7%BB%93%C2%A0\">✨总结 </a></p>\n<hr/>\n<h1 id=\"STL%E7%9A%84%E5%87%BA%E7%8E%B0%E8%83%8C%E6%99%AF\">STL的出现背景</h1>\n<blockquote>\n<ul><li>长久以来，软件届就一直希望建立一种可<span style=\"color:#38d8f0;\"><strong>重复利用</strong></span>的东西</li><li>C++的面向对象和泛型编程思想，目的就是<span style=\"color:#38d8f0;\"><strong>复用性</strong></span>的提升</li><li>数据结构和算法没能有一套标准，导致被迫从事大量重复工作</li><li>为了建立数据结构和算法的一套标准，那么STL就诞生了</li></ul>\n</blockquote>\n<h1 id=\"STL%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\">STL基本概念</h1>\n<blockquote>\n<ul><li>STL全称：标准模板库(Standard Template Library)</li><li>STL从广义上分为:<span style=\"color:#38d8f0;\"><strong>容器</strong></span>(container)<span style=\"color:#38d8f0;\"><strong>算法</strong></span>(algorithm)<span style=\"color:#38d8f0;\"><strong>迭代器</strong></span>(iterator)</li><li>容器和算法之间通过迭代器进行无缝连接</li><li>STL几乎所有的代码都采用了模板类或者模板函数</li></ul>\n</blockquote>\n<h1 id=\"STL%E5%85%AD%E5%A4%A7%E7%BB%84%E4%BB%B6\">STL六大组件</h1>\n<blockquote>\n<ul><li> <p>STL六大组件分别是：容器、算法、迭代器、仿函数、适配器、空间配置器。</p> </li><li> <p>容器:各种数据结构，如vector、list、deque、set、map等，用来存放数据。</p> </li><li> <p>算法:常用的各种算法，如sort、find、copy、for_each等</p> </li><li> <p>迭代器:扮演了容器与算法之间的粘合剂，迭代器的使用非常类似于指针，初学阶段我们可以先理解迭代器为指针。</p> </li><li> <p>仿函数:行为类似函数，可作为算法的某种策略</p> </li><li> <p>适配器:一种用来修饰容器或者仿函数或迭代器结构的东西。</p> </li><li> <p>空间配置器:负责空间的配置与管理。</p> </li></ul>\n</blockquote>\n<h1 id=\"%E5%88%9D%E8%AF%86%E5%AE%B9%E5%99%A8%E7%AE%97%E6%B3%95%E8%BF%AD%E4%BB%A3%E5%99%A8\">初识容器算法迭代器</h1>\n<p><strong>迭代器种类：</strong></p>\n<p><img alt=\"\" src=\"image\\657bbfecef1c43c6bcf93eacbc8eea01.png\"/></p>\n<p>        <strong> 常用的迭代器种类为双向迭代器，和随机访问迭代器。</strong></p>\n<blockquote>\n<p>了解STL容器、算法、迭代器概念之后，我们利用代码感受STL的魅力</p>\n<p>STL中最常用的容器为vector，可以理解为数组，下面我们将学习如何向这个容器中插入数据、并遍历这个容器。</p>\n</blockquote>\n<h1 id=\"vector%E5%AE%B9%E5%99%A8%E7%9A%84%E5%88%9D%E6%AC%A1%E4%BD%BF%E7%94%A8\">vector容器的初次使用</h1>\n<blockquote>\n<p>容器：    vector</p>\n<p>算法：    for_each</p>\n<p>迭代器：vector::iterator</p>\n</blockquote>\n<h2 id=\"%E5%AD%98%E6%94%BE%E5%86%85%E7%BD%AE%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\">存放内置数据类型</h2>\n<pre><code class=\"language-cpp\">void printInfo(int val) {\n\tcout &lt;&lt; val&lt;&lt;\" \";\n}\n//内置数据类型存放测试\nvoid test02()\n{\n\tvector&lt;int&gt; ve;\n\tve.push_back(1);\n\tve.push_back(0);\n\tve.push_back(0);\n\tve.push_back(8);\n\tve.push_back(6);\n\tcout &lt;&lt; \"此时容器大小为：\" &lt;&lt; ve.size() &lt;&lt; endl;\n\tcout &lt;&lt; \"容器数据情况：\" &lt;&lt; endl;\n\t//通过迭代器来访问容器中的数据 3种方法\n\t//1、while循环遍历\n\t//vector&lt;int&gt;::iterator itBegin = ve.begin();//起始迭代器，指向容器中第一个元素\n\t//vector&lt;int&gt;::iterator itEnd = ve.end();//结束迭代器，指向容器中最后一个元素的下一个位置\n\t/*while (itBegin != itEnd)\n\t{\n\t\tcout &lt;&lt; *itBegin &lt;&lt;\" \";\n\t\titBegin++;\n\t}*/\n\t//2、for循环遍历\n\t/*for (vector&lt;int&gt;::iterator it = ve.begin(); it != ve.end(); it++)\n\t{\n\t\tcout &lt;&lt; *it &lt;&lt; \" \";\n\t}*/\n\t//3、for_each遍历\n\tfor_each(ve.begin(),ve.end(),printInfo);\n\tcout &lt;&lt; endl;\n}</code></pre>\n<blockquote>\n<p>首先创建整型的vector容器 <strong><span style=\"color:#38d8f0;\">ve</span></strong>，将1、0、0、8、6依次尾插入ve容器内，然后利用迭代器来访问容器中的数据，分为<span style=\"color:#38d8f0;\"><strong>while、for、for_each</strong></span>三种循环方法：</p>\n<p>1、while循环</p>\n<p>        创建两个指针<span style=\"color:#38d8f0;\"><strong>itBegin、itEnd</strong></span>分别指向ve容器的第一个位置和最后一个元素的下一个位置，利用while循环，当递增的itBegin不等于itEnd时，输出<span style=\"color:#38d8f0;\"><strong>解引用</strong></span>的itBegin，就可以得到该位置对应的数据，递增的语句是<span style=\"color:#38d8f0;\"><strong>itBegin++</strong></span>。</p>\n<p>2、for循环</p>\n<p>        创建一个指针即可，也是让指针从begin递增，在不等于end时依次解引用输出数据。这个方法比较方法，我个人推荐使用</p>\n<p>3、for_each循环</p>\n<p>        使用for_each循环需要先引入头文件#include<span style=\"color:#38d8f0;\"><strong>&lt;algorithm&gt;</strong></span>，这个头文件包含了算法里的方法。<span style=\"color:#38d8f0;\"><strong>参数列表</strong></span>分别是：起始位置，终止位置，打印函数。所以我定义了一个<strong><span style=\"color:#38d8f0;\">printInfo</span></strong>函数来不换行打印数据。</p>\n</blockquote>\n<h2 id=\"%E5%AD%98%E6%94%BE%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\">存放自定义数据类型</h2>\n<pre><code class=\"language-cpp\">//Person类展示\nclass Person\n{\npublic:\n\tstring name;\n\tint height;\n\tPerson(string name, int height) {\n\t\tthis-&gt;name = name;\n\t\tthis-&gt;height = height;\n\t}\n};\n//自定义类型数据存放测试\nvoid test01()\n{\n\tPerson p1(\"子鼠\",120);\n\tPerson p2(\"丑牛\",150);\n\tPerson p3(\"寅虎\",140);\n\tvector&lt;Person&gt; v;\n\tv.push_back(p1);\n\tv.push_back(p2);\n\tv.push_back(p3);\n\tfor (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++)\n\t{\n\t\tcout &lt;&lt; \"姓名：\" &lt;&lt; it-&gt;name &lt;&lt; \" 身高：\" &lt;&lt; it-&gt;height &lt;&lt; endl;\n\t}\n}</code></pre>\n<blockquote>\n<p>        vector通过参数列表里的数据类型来决定容器内存放的数据类型，这里参数列表指定时Person类，那么就可以将创建的对象p1、p2、p3存入容器内，再利用for循环打印数据。和上面不同的是，打印姓名身高用的是<span style=\"color:#38d8f0;\"><strong>-&gt;</strong></span>操作符，这是因为it相当于一个<span style=\"color:#38d8f0;\"><strong>指针</strong></span>，所以可以直接通过指针调用对象的属性，当然也可以这样写：<span style=\"color:#38d8f0;\"><strong>(*t).name</strong></span>，先解引用再调用的方式也可以。</p>\n</blockquote>\n<h2 id=\"vector%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B5%8C%E5%A5%97%E4%BD%BF%E7%94%A8\">vector容器的嵌套使用</h2>\n<p>        <strong>容器相当于一个数组，那么数组嵌套数组不就是二维数组吗，我们来测试一下。</strong></p>\n<pre><code class=\"language-cpp\">//打印嵌套容器的数据\nvoid printVector(vector&lt;vector&lt;int&gt;&gt;V)\n{\n\tcout &lt;&lt; \"打印嵌套容器数据：\" &lt;&lt; endl;\n\tfor (vector&lt;vector&lt;int&gt;&gt;::iterator T = V.begin(); T != V.end(); T++)\n\t{\n\t\tfor (vector&lt;int&gt;::iterator t = (*T).begin(); t != (*T).end(); t++)\n\t\t{\n\t\t\tcout &lt;&lt; *t &lt;&lt; \" \";\n\t\t}\n\t\tcout &lt;&lt; endl;\n\t}\n}\n//容器嵌套使用,二维数组\nvoid test03()\n{\n\tvector&lt;vector&lt;int&gt;&gt; V;\n\tvector&lt;int&gt;v1;\n\tvector&lt;int&gt;v2;\n\tvector&lt;int&gt;v3;\n\tvector&lt;int&gt;v4;\n\tvector&lt;int&gt;v5;\n\tfor (int i = 1; i &lt; 5; i++)\n\t{\n\t\tv1.push_back(i);\n\t\tv2.push_back(i+1);\n\t\tv3.push_back(i+2);\n\t\tv4.push_back(i+3);\n\t\tv5.push_back(i+4);\n\t}\n\tV.push_back(v1);\n\tV.push_back(v2);\n\tV.push_back(v3);\n\tV.push_back(v4);\n\tV.push_back(v5);\n\tprintVector(V);\n}</code></pre>\n<blockquote>\n<p>        创建的这个<span style=\"color:#38d8f0;\"><strong>V</strong></span>容器，他的参数列表是<span style=\"color:#38d8f0;\"><strong>vector&lt;int&gt;</strong></span>，那就说明该容器存入的是存入整型数据的容器，说白了就是二维整型数组。然后先创建小容器并进行赋值，再将小容器尾插入大容器内，调用自定义的printVector函数来打印数据。</p>\n<p>        二维数组都是两层for循环打印，类似的对于嵌套容器来说也一样。  第一层for循环决定着循环的次数，第二层for循环的<span style=\"color:#38d8f0;\"><strong>(*T)</strong></span>用到了二级指针，也就是说大容器T指针解引用之后还是一个小容器的指针，根据<span style=\"color:#38d8f0;\"><strong>T++</strong></span>这行代码来更新指向也就能改变小指针的容器，从而输出嵌套容器内的所有数据。</p>\n</blockquote>\n<h1 id=\"%C2%A0%E8%BF%90%E8%A1%8C%E6%95%88%E6%9E%9C\"> 运行效果</h1>\n<p><img alt=\"\" height=\"426\" src=\"image\\b540098c4fb947d482223fb747bad959.png\" width=\"640\"/></p>\n<h1 id=\"%F0%9F%8E%89%E6%80%BB%E7%BB%93%C2%A0\"><strong>✨</strong>总结 </h1>\n<p>        <strong>那么到这里初识STL就结束了，跟着这篇博客学习可以了解STL的基本概念，以及STL六大组件中容器、算法、迭代器的关系。后面的内容也会持续更新的，希望朋友们多多支持，你们的鼓励是我创作的不竭动力！</strong></p>\n</div>\n</div>"}