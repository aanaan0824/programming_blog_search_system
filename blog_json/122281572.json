{"blogid": "122281572", "writerAge": "码龄1年", "writerBlogNum": "10", "writerCollect": "164", "writerComment": "210", "writerFan": "1008", "writerGrade": "3级", "writerIntegral": "715", "writerName": "K.t.P.T.", "writerProfileAdress": "writer_image\\profile_122281572.jpg", "writerRankTotal": "67925", "writerRankWeekly": "286686", "writerThumb": "252", "writerVisitNum": "22972", "blog_read_count": "1620", "blog_time": "于 2022-01-03 01:46:37 发布", "blog_title": "【STL】vector容器如何使用？", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p></p>\n<div class=\"toc\">\n<h3>文章目录</h3>\n<ul><li><a href=\"#font_size5font_1\"><font size=\"5\">前言</font></a></li><li><ul><li><a href=\"#vector_4\">vector的理解</a></li><li><a href=\"#vector_21\">vector的成员类型</a></li><li><a href=\"#vector_27\">vector的创建</a></li><li><a href=\"#vector_47\">vector的迭代器</a></li><li><a href=\"#vector_54\">vector的容量</a></li><li><a href=\"#vector_81\">vector元素访问</a></li><li><a href=\"#vector_95\">vector的元素修改</a></li></ul>\n</li></ul>\n</div>\n<p></p>\n<h1><a id=\"font_size5font_1\"></a><font size=\"5\">前言</font></h1>\n<blockquote>\n<p>上篇博客简述了string类，实际上就是一个用来装字符的容器，后面我会整理其他的容器，首先这篇我介绍的是向量类std::vector，在使用之前需要引入向量库vector。</p>\n</blockquote>\n<h2><a id=\"vector_4\"></a>vector的理解</h2>\n<p>vector可以看做一个可以按照需要自动增长和缩短的动态数组<br/> <strong>内部机理</strong><br/> 实际上，vector内部就是用数组存储地址的，我们知道数组是需要在创建的时候指定大小，但是std::vector不需要，这里有一个概念，我们把内部数组能够存放元素的最大数量称为容器容量(capacity)，实际元素数量(size)超过容量时，就需要继续申请扩充容量，然而数组无法在末尾直接增加内存的，所以我们需要申请一块更大的连续内存，并把旧内存的数据复制到新内存里面，这个复制操作的时间复杂度很明显就是O(n),随后旧内存被释放。<br/> <strong>值得注意的是</strong><br/> 扩容时一般会申请适量多的内存<br/> 利：以一定内存来换取大幅度提高插入元素时的速度<br/> 原因：<br/> 当容量大于元素数量时：<br/> 插入1个新元素的时间复杂度为O( 1 ),<br/> 插入n个新元素的时间复杂度为O（n）。<br/> 当容量小于元素数量时：<br/> 插入1个新元素的时间复杂度为O( n ),<br/> 插入n个新元素的时间复杂度为O（n*n）。<br/> <strong>但是还有一种容器既不会浪费内存也可以快速插入就是list</strong></p>\n<h2><a id=\"vector_21\"></a>vector的成员类型</h2>\n<p>由于vector是一个后来人们编写的类，所以具体的内部代码主要由写库的人决定(如扩充容量的多少)，不过C++是有标准的（为了达到每个人写的代码可以进行交流），只要按照标准写代码库，这些新声明与定义的类型都可以找到底层类型，例如size_type的底层代码通常是size_t（C++标准中的无符号的整数类型）。<br/> <img alt=\"在这里插入图片描述\" src=\"image\\fba35edd66524da68582931ae1d74a02.png\"/><br/> 在使用上，完整的vector类型： std:vecter&lt;存放的元素的类型&gt;<br/> 在使用上，完整的成员类型:std:vecter&lt;存放的元素的类型&gt;：上面的成员类型</p>\n<h2><a id=\"vector_27\"></a>vector的创建</h2>\n<p>1.vector&lt;数据类型&gt; v;//&lt;&gt;尖括号是用来指定容器存放的元素的数据类型，也就是说容器只能存放一种数据类型<br/> 例：<code>vector&lt;int&gt;v；</code></p>\n<p>2.vectorc数据类型&gt; v(size_type count);//<br/> 例：<code>vector&lt;int&gt; v(50);</code></p>\n<p>3.vector&lt;数据类型&gt; v(size_type count，数据的类型value);<br/> 例：<code>vector&lt;int&gt; v(10，1);</code><br/> 4.vector&lt;数据类型&gt;v(任意类型的输入迭代器 first，任意类型的输入送代器 last)<br/> 例：<code>string str=“woaini”;</code><br/> .<code>vector&lt;char&gt;v(str.begin()，str.end();</code></p>\n<p><strong>创建时间复杂度</strong></p>\n<ol><li>O(1)</li><li>O(n)（与 count 成线性）</li><li>O(n)（与 count 成线性）</li><li>4.O(n)（与 first 到 last 的距离成线性）</li></ol>\n<h2><a id=\"vector_47\"></a>vector的迭代器</h2>\n<p>时间复杂度:O(1)<br/> 1 <code>vector&lt;int&gt;::iterator it=v.begin();</code><br/> 2. <code>vector&lt;int&gt;::const_iterator const it =v.begin();</code><br/> 3. <code>vector&lt;int&gt;::reverse_iterator rbegin();</code><br/> 4. <code>vector&lt;int&gt;::const_reverse_iterator const rbegin();</code></p>\n<h2><a id=\"vector_54\"></a>vector的容量</h2>\n<p>1 <code>bool flag=v.empty();</code>// 判断容器是否为空O(1)<br/> 2.<code>size_type size=size() ;</code> //返回容器中的元素数量O(1),内部实现`</p>\n<pre><code class=\"prism language-clike\">std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span><span class=\"token function\">distance</span><span class=\"token punctuation\">(</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token comment\">//了解更多推荐看候捷的《STL源码剖析》</span>\n</code></pre>\n<p>3.<code>size_type capacity=capacity() ;</code> 获取容器的容量O(1),扩充多少不确定。<br/> 4.<code>void reserve(size_type n);</code> 预留容量(与容器的size()成线性)</p>\n<pre><code class=\"prism language-clike\"> vector<span class=\"token operator\">&lt;</span>int<span class=\"token operator\">&gt;</span> v<span class=\"token punctuation\">;</span>\n v<span class=\"token punctuation\">.</span><span class=\"token function\">reserve</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n v<span class=\"token punctuation\">.</span><span class=\"token function\">phsh_back</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//直接插入而不需要扩容</span>\n</code></pre>\n<p>**如果 n&lt;=capacity()，则函数没有操作;<br/> 如果 n&gt;capacity()，则容器重新分配内存,来扩充容量。<br/> 注意：<br/> 重新分配内存后，由于内存地址已经发生了改变，这就导致了之前保存下来的这个容器的所有迭代器全部都会失效，不能再使用，如果需要使用迭代器的话，就必须重新通过成员函数begin()和end()获取。<br/> <strong>时间复杂度</strong><br/> 1-3.O(1);<br/> 4.与容器的size()成线性</p>\n<h2><a id=\"vector_81\"></a>vector元素访问</h2>\n<p>时间复杂度都是O(1)<br/> 1.中括号[]//获取相应位置的引用<br/> 例：<code>v[3]=222;</code><br/> 2.reference at(size_type pos);//同上，但是会判断是否越界<br/> 例：<code>v.at(3)=666;</code><br/> 3.reference front(); 获取容器第1个元素的引用<br/> 例：<code>cout&lt;&lt;v.front()&lt;&lt;endl;</code><br/> 4.reference back(); 获取容器最后1个元素的引用<br/> 例：<code>cout&lt;&lt;v.back()&lt;&lt;endl;</code><br/> 5.int* data(); 获取容器底层数组的首地址<br/> 例：<code>int*p=data();</code><br/> 合法范围：[data(),data()+size()]</p>\n<h2><a id=\"vector_95\"></a>vector的元素修改</h2>\n<p>void push_back(const value_type &amp; value);<br/> 例：<code>v.push_back(222);</code><br/> <strong>时间复杂度</strong>：虽然有可能出现时间复杂度O()的扩容操作，但是由于时间均摊给每一步，时间复杂度还是O(1)<br/> void pop_back();<br/> 例：<code>v.pop_back();</code><br/> <strong>注意</strong>：<br/> 1.first和last不能是对象自身的迭代器，否则是未定义行为<br/> 2. 如果新的 size()大于旧的 capacity()，则该容器对象所有迭代器和引用都会失效,在插入新元素后，由于原来插入位置的元素及其后面的元素移位，导致原来插入位置及其后面的迭代器和引用全部失效。<br/> iterator insert(iterator pos. const value_type &amp; value);//在pos前一位插入value<br/> void insert(iterator pos. size_type count, const value_type &amp; value);//在pos前插入count个value<br/> void insert(iterator pos.任意类型的输入送代器first任意类型的输入迭代器 last);//插入指定迭代器first到last之间的元素<br/> iterator erase(iterator pos);<br/> 例：</p>\n<pre><code class=\"prism language-clike\">string str <span class=\"token operator\">=</span><span class=\"token string\">\"happynewyear\"</span>\nvector<span class=\"token operator\">&lt;</span>char<span class=\"token operator\">&gt;</span> <span class=\"token function\">v</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>str<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nv<span class=\"token punctuation\">.</span><span class=\"token function\">erase</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>iterator erase(iterator first, iterator last);</p>\n<pre><code class=\"prism language-clike\">v<span class=\"token punctuation\">.</span><span class=\"token function\">erase</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span>v<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//删除2，3, 4</span>\n</code></pre>\n<p>void clear();//清空容器，容器容量不变；<br/> 例<code>v.clear();</code><br/> void resize(size_type count);//定义容量<br/> 例：<code>v.size(5)；</code><br/> void resize(size_type count, const value_type &amp; value);//定义容量<br/> 例：<code>resize(5,666)；</code><br/> 如果当前大小大于count，则减少到count个元素如果当前大小小于count<br/> 则：<br/> 1 后附额外的默认插入的元素<br/> 2. 后附额外的 value 的副本时间复杂度O(n)，与元素的数量成线性<br/> <img alt=\"在这里插入图片描述\" src=\"image\\ad57411e3b714e62b64439d02c534a39.png\"/><br/> <font color=\"#dd0000\"> ◆◆◆◆◆◆◆◆◆◆◆◆◆◆感谢您对这篇文章的阅读，感恩一见三连哦~♡◆◆◆◆◆◆◆◆◆◆◆◆◆◆</font><br/></p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}