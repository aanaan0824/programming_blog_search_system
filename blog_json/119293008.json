{"blogid": "119293008", "writerAge": "码龄2年", "writerBlogNum": "9", "writerCollect": "70", "writerComment": "7", "writerFan": "5", "writerGrade": "2级", "writerIntegral": "125", "writerName": "田pangp", "writerProfileAdress": "writer_image\\profile_119293008.jpg", "writerRankTotal": "190373", "writerRankWeekly": "963558", "writerThumb": "24", "writerVisitNum": "9974", "blog_read_count": "4643", "blog_time": "于 2021-08-01 10:37:29 发布", "blog_title": "Qt QGraphicsView拖拽（移动）、缩放", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>谦虚的话就不说了，我也是小白，仅供参考（还是说了）</p>\n<p>先讲原理，只有明白原理之后才能开始做事。</p>\n<p>首先需要明白，view在整个视图框架中的角色是用于显示scene的，所以决定了如何展示scene，包括scale()函数，用于放大缩小所展示的scene；centerOn()函数，决定scene的中心在何方。所有的操作，都不会直接改变scene，改变的只是如何展现scene。</p>\n<p>view就像窗户，我们可以透过窗户看到窗外的景色。scene就像窗外的景色，需要窗户作为媒介才能够让我们看到，只不过这里的景色（scene）不一定会比窗户（view）大。并且，在窗户如何显示窗外的景色，也可以通过函数设置，比如我家窗户是个哈哈镜，那就可以放大缩小甚至扭曲景色。item就像是景色当中的花鸟鱼虫。如果懂PhotoShop的话，view就像是图层上的蒙版，scene就像是蒙版下的图像。</p>\n<h1>一、缩放</h1>\n<p>先来说缩放，因为缩放最为简单。</p>\n<p>主要使用到scale()函数。该函数用于缩放场景，但是并不是改变了scene的大小尺寸，仅仅是改变了显示比例。</p>\n<pre><code>void QGraphicsView::scale(qreal sx, qreal sy)</code></pre>\n<p>我们需要两个参数，sx,sy，指的是沿x,y缩放的比例，而不是大小。举个栗子：</p>\n<pre><code class=\"language-cpp\">void MyView::wheelEvent(QWheelEvent *event)\n{\n    int wheelValue = event-&gt;angleDelta().y();\n    double ratio = (double)wheelValue / (double)1200 + 1;\n    scale(ratio, ratio);\n}</code></pre>\n<p>MyView继承了QGraphicsView，并重写wheelEvent。每次滚动滚轮，都将放大原来的1.1倍，或是缩小原来的0.9倍。</p>\n<h1>二、移动</h1>\n<p>主要使用到centerOn()函数，用于定义view的中心位置应该展示哪里的scene，这句话有点绕，不急，听我娓娓道来。各种mapTo函数，用于坐标变换，这个看文档解释的很清楚了。<em>P.S. 虽然此处使用这个函数虽然能够达到我想要的效果，原理也讲得通，但是总感觉很奇怪，请大佬评论告诉我我做得对吗。</em></p>\n<p><strong>先讲坐标</strong></p>\n<p><img alt=\"\" height=\"1080\" src=\"image\\20210801091125864.jpg\" width=\"1200\"/></p>\n<p> view和scene的原点都位于左上角，对就是这样，你知道这些就够了。</p>\n<p><strong>再讲特点</strong></p>\n<p><span style=\"background-color:#ffd900;\">这才是重点</span>。在Qt的视图框架中，如果在scene中直接添加一个item，scene的大小就是这个item的boundingRect尺寸，也就是item的最大边界矩形。如果这个item是小于view的，那么这个item会显示在view的中心，就像这样。<span style=\"color:#0d0016;\"><span style=\"background-color:#fbd4d0;\">如果scene的尺寸是小于view的，也就是说view可以完全包含scene，那么是不能够通过centerOn来移动scene。只有当scene大于view，以至于view不能完全展示scene时，才可以通过centerOn移动。</span>这里特别注意，我就是这里踩了坑。</span></p>\n<p><img alt=\"\" height=\"1080\" src=\"image\\20210801092427334.jpg\" width=\"1200\"/></p>\n<p><span style=\"background-color:#f9eda6;\">（此段为可选择阅读段）</span>此时，如果事件传播正常，且item设置了QGraphicsItem::ItemIsMovable（可以在item的setFlag函数中设置），这个item可以直接移动，scene会自动变化大小以适应item。如果将item向scene的左上角移动，scene的原点依旧还是左上角，以view的视角来看，是scene右下角不变，向左上角延伸。如果将已经移动的item再移动回来，scene的大小也不会变化，换言之，scene只可能被item撑得更大，不能自动变小。</p>\n<pre><code>void QGraphicsView::centerOn(const QPointF &amp;pos)</code></pre>\n<p>cneterOn函数接受一个point参数，用于定义view的中心位置，应该展示scene坐标的什么位置。</p>\n<p><img alt=\"\" height=\"1080\" src=\"image\\20210801100325363.jpg\" width=\"1200\"/></p>\n<p> 注意，这个移动是有极限的，如果scene尺寸本身就大于view，那么不会将scene移出view的范围，换言之，如论如何移动，scene一定会完全包围view。</p>\n<p>那么我们思路就十分清晰了。如果我们想移动一个距离，假设移动的距离为offsetPoint，获取一个当前view视图中中心点在scene的坐标，currentScenePoint = mapToScene(MyView.width() / 2, MyView.height() / 2)，那么计算出新的点并传入centerOn函数，centerOn( - (currentScenePoint -  offsetPoint))；</p>\n<p>下面是示例，这个示例中展示了当鼠标点击空白区域时，通过拖拽移动scene。</p>\n<pre><code class=\"language-cpp\">void FunctionView::mousePressEvent(QMouseEvent *event)\n{\n    QGraphicsView::mousePressEvent(event);\n    if(this-&gt;scene() == nullptr)\n    {\n        qDebug() &lt;&lt; \"The scene is null\";\n        return;\n    }\n    // 记录鼠标按下时的中心点坐标\n    centerAnchor = mapToScene(event-&gt;pos()) - event-&gt;pos() + QPointF(width() / 2, height() / 2);\n    // 记录当前鼠标在view中的位置，用来在mouseMove事件中计算偏移\n    // 此处不将view坐标转换成scene坐标的原因是优化性能，在move的过程中会产生抖动\n    posAnchor = event-&gt;pos();\n    isMousePressed = true;\n}\n\nvoid FunctionView::mouseMoveEvent(QMouseEvent *event)\n{\n    QGraphicsView::mouseMoveEvent(event);\n    QPointF offsetPos = event-&gt;pos() - posAnchor;\n    if(isMousePressed){\n        setTransformationAnchor(QGraphicsView::AnchorUnderMouse);\n        centerOn(centerAnchor - offsetPos);\n    }\n}\n\nvoid FunctionView::mouseReleaseEvent(QMouseEvent *event)\n{\n    QGraphicsView::mouseReleaseEvent(event);\n    isMousePressed = false;\n}</code></pre>\n<p>Tips:视图框架事件的传递顺序是view-&gt;scene-&gt;item，如果需要将事件继续向后传递，使用event-&gt;ignore()是没用的，猜测因为view看做是一个控件，scene和item都是控件内的组件，ignore只能处理控件到控件的事件，但是控件内的事件无能为力。这里可以使用QGraphicsView::mousexxxEvent(event)这样的函数，将event事件再次传入视图。上面的例子也是用到了这样的方法。</p>\n</div>\n</div>"}