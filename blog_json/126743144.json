{"blogid": "126743144", "writerAge": "码龄24天", "writerBlogNum": "53", "writerCollect": "0", "writerComment": "0", "writerFan": "19", "writerGrade": "3级", "writerIntegral": "530", "writerName": "web13017819078", "writerProfileAdress": "writer_image\\profile_126743144.jpg", "writerRankTotal": "39521", "writerRankWeekly": "12819", "writerThumb": "0", "writerVisitNum": "1696", "blog_read_count": "11", "blog_time": "于 2022-09-07 12:24:19 发布", "blog_title": "JVM - 双亲委派", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h2><a id=\"_JVM___2\"></a># <code>JVM</code> - 双亲委派</h2>\n<blockquote>\n<p><code>JDK</code>版本：<code>1.8</code></p>\n</blockquote>\n<h3><a id=\"_1_7\"></a># 1、双亲委派机制</h3>\n<p><code>Java</code>虚拟机对于<code>class</code>文件采用的加载策略是按需加载。也就是当需要使用该类时才会将该类的<code>.class</code>文件加载到内存中生成<code>Class</code>对象。并且加载某个类的<code>.class</code>文件时，<code>Java</code>虚拟机采用的是<strong>双亲委派</strong>模式，即将加载<code>.class</code>文件的的请求优先交由父类进行加载处理，如果父类能够进行正常加载则将其加载到内存中，如果不能加载则再由自己进行加载。这是一种任务委派模式。</p>\n<hr/>\n<h3><a id=\"_2_13\"></a># 2、双亲委派机制的工作原理</h3>\n<ul><li>如果一个类加载器收到了类加载的请求，它并不会自己先去加载，而是将这个请求委托给父类的加载器去执行。</li><li>如果父类加载器还在其父类加载器，则进一步向上委托，依次进行递归，请求最总将到达顶层的引导类加载器。</li><li>如果父类加载器可以完成类加载任务，就成功返回，如果父类加载器无法完成类加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</li></ul>\n<p><img alt=\"双亲委派流程\" src=\"image\\4a6afe61a200488aa28e3ab0db1c70af.png\"/></p>\n<p>比如在加载<code>jdbc.jar</code>用于实现数据库连接的时候。因为<code>jdbc.jar</code>是基于<code>Java</code>中<code>rt.jar</code>中的<code>SPI</code>接口进行实现的，所以在加载的时候，由于<code>SPI</code>接口会调用实现类中的方法，所以这里<code>jbdc.jar</code>中的方法会被加载到内存中，此时就会进行双亲委派进行类加载。最终从<code>Bootstrap ClassLoader</code>类加载器中加载<code>SPI</code>核心类，然后加载<code>SPI</code>接口的实现类，此时<code>Bootstrap ClassLoader</code>会进行反向委派，通过线程上下文类加载器进行<code>jdbc.jar</code>的加载。</p>\n<p><img alt=\"双清委派例子\" src=\"image\\926d8987e33949699cee50a9b7203cf2.png\"/></p>\n<p>这样做的优势：</p>\n<ul><li>避免类的重复加载。</li><li>保护程序安全，防止核心类库<code>API</code>被恶意篡改。</li></ul>\n<h3><a id=\"_3_30\"></a># 3、沙箱安全机制</h3>\n<p>自定义类<code>java.lang.String</code>：</p>\n<pre><code>package java.lang;\n\npublic class String{\n    \n    public static void main(String[] args){\n    \tSystem.out.println(\"自定义的 java.lang.String 类\")    \n    }\n    \n}\n</code></pre>\n<p>启动程序</p>\n<p>在加载自定义<code>String</code>类的时候，会使用双清委派机制，优先交由<code>Bootstrap Class Loader</code>进行类的加载，此时引导类加载器会优先加载<code>JDK</code>自带的<code>.class</code>文件，其中包含<code>rt.jar</code>中的<code>java.lang.String.class</code>文件，此时<code>String</code>类已经交由<code>Bootstrap Class Loader</code>加载到内存中，而自定义的<code>String</code>类则是会使用<code>Application Class Loader</code>进行类加载，此时内存中已经存在<code>java.lang.String</code>类，所以再使用应用类加载器进行类加载的时候就会报<code>java.lang.SecurityException:Prohibited package name: java.lang</code>异常。这样就可以保证<code>Java</code>核心类库的绝对安全。</p>\n<hr/>\n<h3><a id=\"_4Class_51\"></a># 4、如果判断两个<code>Class</code>对象是否相同</h3>\n<p>在<code>JVM</code>中表示两个<code>Class</code>对象是否为同一个类存在两个必要条件：</p>\n<ul><li>类的完全限定名必须一致(完全限定名：包名+类名)。</li><li>加载这个类的<code>ClassLoader</code>（指<code>ClassLoader</code>实例对象）必须相同。</li></ul>\n<p>换句话说，在<code>JVM</code>中，即使这两个类对象（<code>Class</code>对象）来源同一个<code>Class</code>文件，被同一个虚拟机所加载，但只要加载它们的<code>ClassLoader</code>实例对象不同，那么这两个类对象也是不相等的。</p>\n<h3><a id=\"_5_60\"></a># 5、对类加载器的引用</h3>\n<p><code>JVM</code>必须知道一个类是由启动加载器加载的还是由用户类加载器加载的。如果一个类是由用户类加载器加载的，那么<code>JVM</code>会将这个<strong>类加载器的一个引用作为类型信息的一部分保存在方法区中</strong>。当解析一个类到另一个类型的引用的时候，<code>JVM</code>需要保证这两个类型的类加载器是相同的。</p>\n<h3><a id=\"_6_64\"></a># 6、类的主动使用和被动使用</h3>\n<p><code>Java</code>程序对类的使用方式分为：主动使用和被动使用。</p>\n<p>主动使用分为七种情况：</p>\n<ul><li>创建类的实例。</li><li>访问某个类或者接口的静态变量，或者对该静态变量的赋值。</li><li>调用类的静态方法。</li><li>反射(比如：<code>Class.forName(\"com.kapcb.ccc.Kpacb\")</code>)。</li><li>初始化一个类的子类。</li><li><code>Java</code>虚拟机启动时被表明为启动类的类。</li><li><code>JDK7</code>开始提供的动态语言支持 \n  <ul><li><code>java.lang.invoke.MethodHandle</code>实例的解析结果，<code>REF_getStatic</code>、<code>REF_putStatic</code>、<code>REF_invokeStatic</code>句柄对应的类没有初始化，则初始化 。</li></ul> </li></ul>\n<p>除了以上七种情况，其他使用<code>Java</code>类的方式都被看作是<strong>对类的被动使用</strong>，<strong>都不会导致类的初始化</strong>。</p>\n<p><a href=\"https://github.com/kapbc/Java-Kapcb\">GitHub源码地址</a>：<code>https://github.com/kapbc/Java-Kapcb/tree/master/src/main/java/com/kapcb/ccc/jvm</code></p>\n<blockquote>\n<p>备注：此文为笔者学习<code>JVM</code>的笔记，鉴于本人技术有限，文中难免出现一些错误，感谢大家批评指正。</p>\n</blockquote>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}