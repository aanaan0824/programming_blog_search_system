{"blogid": "125263266", "writerAge": "码龄1年", "writerBlogNum": "9", "writerCollect": "17", "writerComment": "2", "writerFan": "55", "writerGrade": "2级", "writerIntegral": "107", "writerName": "搓手取火", "writerProfileAdress": "writer_image\\profile_125263266.jpg", "writerRankTotal": "108130", "writerRankWeekly": "693806", "writerThumb": "4", "writerVisitNum": "9105", "blog_read_count": "6681", "blog_time": "于 2022-06-13 16:49:58 发布", "blog_title": "AOP是什么？如何使用AOP？", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<ol><li style=\"text-align:justify;\"><strong><em><u><span style=\"color:#FF0000;\">AOP</span></u></em></strong><strong><em><u><span style=\"color:#FF0000;\">基本概念是什么？</span></u></em></strong></li></ol>\n<ol><li style=\"text-align:justify;\"><strong><span style=\"color:#000000;\">什么是AOP？</span></strong></li></ol>\n<p style=\"margin-left:0;text-align:justify;\"><strong><span style=\"color:#000000;\">AOP</span></strong><strong><span style=\"color:#000000;\">就是面向切面编程，或者叫面向方面编程，或者开玩笑的说叫面向方便面编程</span></strong></p>\n<p style=\"margin-left:0;text-align:justify;\"><strong><span style=\"color:#000000;\">在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期间动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</span></strong></p>\n<p style=\"margin-left:0;text-align:justify;\"><strong><u><span style=\"color:#FF0000;\">用我的话讲，比如一个方法，他只能计算加法，而不能计算乘法，但是又不想改源码！这时候可以在外面创建一个类，在这个类中通过AOP的技术给这个方法进行添加功能的操作，这就是AOP。</span></u></strong></p>\n<ol><li style=\"text-align:justify;\"><strong><span style=\"color:#000000;\">AOP</span></strong><strong><span style=\"color:#000000;\">的作用（特点）是什么？</span></strong></li></ol>\n<p style=\"margin-left:0;text-align:justify;\"><strong><span style=\"color:#000000;\">AOP</span></strong><strong><span style=\"color:#000000;\">代表的是一个横向的关 系，将“对象”比作一个空心的圆柱体，其中封装的是对象的属性和行为；则面向方面编程的方法，就是将这个圆柱体以切面形式剖开，选择性的提供业务逻辑。而 剖开的切面，也就是所谓的“方面”了。然后它又以巧夺天功的妙手将这些剖开的切面复原，不留痕迹，但完成了效果。</span></strong></p>\n<p style=\"margin-left:0;text-align:justify;\"><strong><span style=\"color:#000000;\">实现AOP的技术，主要分为两大类：一是采用动态代理技术，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行；二是采用静态织入的方式，引入特定的语法创建“方面”，从而使得编译器可以在编译期间织入有关“方面”的代码。</span></strong></p>\n<ol><li style=\"text-align:justify;\"><strong><span style=\"color:#000000;\">AOP</span></strong><strong><span style=\"color:#000000;\">的底层原理是什么？</span></strong></li></ol>\n<p style=\"margin-left:0;text-align:justify;\"><strong><span style=\"color:#000000;\">AOP</span></strong><strong><span style=\"color:#000000;\">底层使用了动态代理</span></strong></p>\n<p style=\"margin-left:0;text-align:justify;\"><strong><span style=\"color:#000000;\">有两种情况</span></strong></p>\n<p style=\"margin-left:0;text-align:justify;\"><strong><span style=\"color:#000000;\">（1、）有接口的情况：                                              </span></strong></p>\n<p style=\"margin-left:0;text-align:justify;\"><strong><span style=\"color:#000000;\">使用了JDK的动态代理</span></strong></p>\n<p style=\"margin-left:0;text-align:justify;\"><img alt=\"\" height=\"1195\" src=\"image\\6218b6ef64d44b61b75b48168860c014.png\" width=\"861\"/></p>\n<p style=\"margin-left:0;text-align:justify;\"><strong><span style=\"color:#000000;\">这里有个错误啊，代理类不用继承接口，不用不用继承，懒得改了，写几个字把。</span></strong></p>\n<p style=\"margin-left:0;text-align:justify;\"><strong><span style=\"color:#000000;\">（2、）没有接口的情况：</span></strong></p>\n<p style=\"margin-left:0;text-align:justify;\"><strong><span style=\"color:#000000;\">使用了CGLTB动态代理</span></strong></p>\n<p style=\"margin-left:0;text-align:justify;\"><img alt=\"\" height=\"895\" src=\"image\\29fce808a7634716a604565ad8c49bae.png\" width=\"779\"/></p>\n<ol><li style=\"text-align:justify;\"><strong><span style=\"color:#FF0000;\">AOP</span></strong><strong><span style=\"color:#FF0000;\">动态代理的实现！</span></strong></li></ol>\n<ol><li style=\"text-align:justify;\"><strong><span style=\"color:#FF0000;\">为什么要用动态代理？ </span></strong></li></ol>\n<p style=\"margin-left:0;text-align:justify;\"><strong><span style=\"color:#000000;\">在不改变原来的代码上进行 修改代码，有点层次感</span></strong></p>\n<ol><li style=\"text-align:justify;\"><strong><span style=\"color:#FF0000;\">如何使用动态代理？</span></strong></li></ol>\n<p style=\"margin-left:0;text-align:justify;\"><strong><span style=\"color:#000000;\">（这里是有接口的情况下）</span></strong></p>\n<p style=\"margin-left:0;text-align:justify;\"><strong><span style=\"color:#000000;\">使用JDK的动态代理，使用Proxy类里面的方法创建代理对象</span></strong></p>\n<ol><li style=\"text-align:justify;\"><strong> </strong><strong><span style=\"color:#FF0000;\">每个方法方法参数的作用？</span></strong></li></ol>\n<p style=\"margin-left:0;text-align:justify;\"><strong><span style=\"color:#000000;\">调用newProxyInstance(1:ClassLoder,2:类&lt;？&gt;[] interfances,3:InvocationHand)</span></strong></p>\n<p style=\"margin-left:0;text-align:justify;\"><strong><span style=\"color:#000000;\">1:</span></strong><strong><span style=\"color:#000000;\">类的加载器</span></strong></p>\n<p style=\"margin-left:0;text-align:justify;\"><strong><span style=\"color:#000000;\">2</span></strong><strong><span style=\"color:#000000;\">：增强方法所在类，，这个类实现的接口，支持多个接口，所以已数组的形式展出</span></strong></p>\n<p style=\"margin-left:0;text-align:justify;\"><strong><span style=\"color:#000000;\">3</span></strong><strong><span style=\"color:#000000;\">：实现这个接口InvocationHand，创建代理的对象，写增强的方法。</span></strong></p>\n<ol><li style=\"text-align:justify;\"><strong><span style=\"color:#FF0000;\">每个方法的作用？</span></strong></li></ol>\n<p style=\"margin-left:0;text-align:justify;\"><span style=\"color:#000000;\">Proxy.newProxyInstance</span><span style=\"color:#000000;\">：将方法调用到处理程序，具有指定的代理类，调用处理程序的代理实例，该代理类，由指定的类加载器定义</span></p>\n<p style=\"margin-left:0;text-align:justify;\"><span style=\"color:#000000;\">并实现指定的接口</span></p>\n<p style=\"margin-left:0;text-align:justify;\"><span style=\"color:#000000;\">method.invoke</span><span style=\"color:#000000;\">：调用method类代表的方法，其中obj是对象名，args是传入method方法的参数</span></p>\n<ol><li style=\"text-align:justify;\"><strong><span style=\"color:#FF0000;\">步骤</span></strong></li></ol>\n<p style=\"margin-left:0;text-align:justify;\"><strong><em><u><span style=\"color:#000000;\">这里已继承接口的栗子举例</span></u></em></strong></p>\n<p style=\"margin-left:0;text-align:justify;\"><img alt=\"\" height=\"503\" src=\"image\\e6bd0b89781a4e1297cad15ef8b8d536.png\" width=\"1200\"/></p>\n<p style=\"margin-left:0;text-align:justify;\"><strong><span style=\"color:#000000;\">这里先创建一个接口</span></strong></p>\n<p style=\"margin-left:0;text-align:justify;\"><img alt=\"\" height=\"318\" src=\"image\\a5159363e1c4481998b2dcbf50db2c86.png\" width=\"1047\"/><strong>  </strong></p>\n<p style=\"margin-left:0;text-align:justify;\"><strong><span style=\"color:#000000;\">然后创建一个类继承这个接口</span></strong></p>\n<p style=\"margin-left:0;text-align:justify;\"><strong><span style=\"color:#000000;\">接下来所有的话都在这张图中：</span></strong></p>\n<p style=\"margin-left:0;text-align:justify;\"><img alt=\"\" height=\"1200\" src=\"image\\5283fd130945476ca57684d837e7dcfd.png\" width=\"1200\"/></p>\n<p style=\"margin-left:0;text-align:justify;\"><strong>                     </strong><strong><span style=\"color:#000000;\">结果就是：</span></strong></p>\n<p style=\"margin-left:0;text-align:justify;\"><img alt=\"\" height=\"393\" src=\"image\\ec97a0b864c142508dd8c9d220c7aaca.png\" width=\"1200\"/></p>\n<p style=\"margin-left:0;text-align:justify;\"><strong>                               </strong><strong><span style=\"color:#000000;\">以上就是AOP的基础操作。</span></strong></p>\n<ol><li style=\"text-align:justify;\"><strong><span style=\"color:#000000;\">AOP</span></strong><strong><span style=\"color:#000000;\">的基础操作术语有哪些？</span></strong></li></ol>\n<ol><li style=\"text-align:justify;\"><strong><span style=\"color:#000000;\">连接点：</span></strong></li></ol>\n<p style=\"margin-left:0;text-align:justify;\"><strong><span style=\"color:#000000;\">连接点是在应用执行过程中能够插入切面（Aspect）的一个点。这些点可以是调用方法时、甚至修改一个字段时</span></strong><strong><span style=\"color:#000000;\">。</span></strong></p>\n<p style=\"margin-left:0;text-align:justify;\"><strong><span style=\"color:#FF0000;\">就是可以被增强的方法，就称为连接点</span></strong></p>\n<ol><li style=\"text-align:justify;\"><strong><span style=\"color:#000000;\">切入点：</span></strong></li></ol>\n<p style=\"margin-left:0;text-align:justify;\"><strong><span style=\"color:#000000;\">实际被增强的方法，就是切入点，比如说有俩方法，一个方法被增强了一个没被增强，则被增强的方法叫做切入点，没被增强的方法就不能叫做切入点</span></strong></p>\n<p style=\"margin-left:0;text-align:justify;\"><strong><span style=\"color:#000000;\">切入点表达式:</span></strong></p>\n<p style=\"margin-left:0;text-align:justify;\"><strong><span style=\"color:#000000;\">execution (public * com.ljb.service.impl..*.*(..))</span></strong></p>\n<p style=\"margin-left:0;text-align:justify;\"><strong><span style=\"color:#000000;\">execution</span></strong><strong><span style=\"color:#000000;\">（权限修饰符，返回值类型，类全路径，方法名称，参数列表）</span></strong></p>\n<p style=\"margin-left:0;text-align:justify;\"><strong><span style=\"color:#000000;\">1.execution</span></strong><strong><span style=\"color:#000000;\">：指示符，execution是最常用的指示符，用于匹配方法执行的连接点。</span></strong></p>\n<p style=\"margin-left:0;text-align:justify;\"><strong><span style=\"color:#000000;\">2.public</span></strong><strong><span style=\"color:#000000;\">：访问修饰符，该参数可选。</span></strong></p>\n<p style=\"margin-left:0;text-align:justify;\"><strong><span style=\"color:#000000;\">3.</span></strong><strong><span style=\"color:#000000;\">第一个*号：返回值类型，*号表示所有的类型，即通配符。</span></strong></p>\n<p style=\"margin-left:0;text-align:justify;\"><strong><span style=\"color:#000000;\">4.</span></strong><strong><span style=\"color:#000000;\">包名：需要拦截的包名，后面的两个点表示当前包和当前包的所有子包，即例子中的com. ljb.service.impl包和该包的子孙包下所有类。</span></strong></p>\n<p style=\"margin-left:0;text-align:justify;\"><strong><span style=\"color:#000000;\">5.</span></strong><strong><span style=\"color:#000000;\">第二个*号：类名，*号表示所有的类。</span></strong></p>\n<p style=\"margin-left:0;text-align:justify;\"><strong><span style=\"color:#000000;\">*(..):</span></strong><strong><span style=\"color:#000000;\">方法名，*号表示所有方法，括号里面表示方法的参数，两个点表示任何参数，可有可无。</span></strong></p>\n<ol><li style=\"text-align:justify;\"><strong><span style=\"color:#000000;\">通知（增强）</span></strong></li></ol>\n<p style=\"margin-left:0;text-align:justify;\"><strong><span style=\"color:#000000;\">真正被增强的逻辑部分称为通知（增强）</span></strong></p>\n<p style=\"margin-left:0;text-align:justify;\"><strong><span style=\"color:#000000;\">通知有五种类型：</span></strong></p>\n<p style=\"margin-left:0;text-align:justify;\"><strong><span style=\"color:#000000;\">1</span></strong><strong><span style=\"color:#000000;\">、前通知：方法执行之前，method：增强执行的方法</span></strong></p>\n<p style=\"margin-left:0;text-align:justify;\"><strong><span style=\"color:#000000;\">2</span></strong><strong><span style=\"color:#000000;\">、后通知：方法执行之后，又称最终通知，无论如何都执行</span></strong></p>\n<p style=\"margin-left:0;text-align:justify;\"><strong><span style=\"color:#000000;\">3</span></strong><strong><span style=\"color:#000000;\">、返回后通知：成功返回后，有异常时不执行</span></strong></p>\n<p style=\"margin-left:0;text-align:justify;\"><strong><span style=\"color:#000000;\">4</span></strong><strong><span style=\"color:#000000;\">、异常通知：发生异常后，只有异常抛出时才执行，不能try…catch异常</span></strong></p>\n<p style=\"margin-left:0;text-align:justify;\"><strong><span style=\"color:#000000;\">5</span></strong><strong><span style=\"color:#000000;\">、环绕通知：在方法的执行前后进行一些增强，在方法的执行前后进行一些增强 =前通知+返回后通知</span></strong></p>\n<ol><li style=\"text-align:justify;\"><strong><span style=\"color:#000000;\">切面</span></strong></li></ol>\n<p style=\"margin-left:0;text-align:justify;\"><strong><span style=\"color:#000000;\">切面是一个动作，也叫一个过程：</span></strong></p>\n<p style=\"margin-left:0;text-align:justify;\"><strong><span style=\"color:#000000;\">把通知应当用到切入点的过程</span></strong></p>\n<ol><li style=\"text-align:justify;\"><strong><span style=\"color:#000000;\">AOP</span></strong><strong><span style=\"color:#000000;\">操作的准备工作有哪些？</span></strong></li></ol>\n<p style=\"margin-left:0;text-align:justify;\"><strong><span style=\"color:#000000;\">1</span></strong><strong><span style=\"color:#000000;\">、一般基于AspectJ实现AOP操作，他不是Spring组成部分，是独立AOP框架，一般把AspectJ和Spring框架一起使用，进行AOP的操作。</span></strong></p>\n<p style=\"margin-left:0;text-align:justify;\"><strong><span style=\"color:#000000;\">这有两种方式</span></strong></p>\n<ol><li style=\"text-align:justify;\"><strong><span style=\"color:#000000;\">注解方式</span></strong></li><li style=\"text-align:justify;\"><strong><span style=\"color:#000000;\">Xml</span></strong><strong><span style=\"color:#000000;\">方式</span></strong></li></ol>\n<p style=\"margin-left:0;text-align:justify;\"><strong><span style=\"color:#000000;\">这里我就不写xml的方式了</span></strong></p>\n<p style=\"margin-left:0;text-align:justify;\"><strong><span style=\"color:#000000;\">！引入依赖</span></strong></p>\n<p style=\"margin-left:0;text-align:justify;\"><strong><span style=\"color:#000000;\">链接：https://pan.baidu.com/s/14Ige68Y8xxhoe1DDgMKRnQ </span></strong></p>\n<p style=\"margin-left:0;text-align:justify;\"><strong><span style=\"color:#000000;\">提取码：1111</span></strong></p>\n<p style=\"margin-left:0;text-align:justify;\"><strong><span style=\"color:#000000;\">推荐全部导入。</span></strong></p>\n<p style=\"margin-left:0;text-align:justify;\"></p>\n<p style=\"margin-left:0;text-align:justify;\"><strong><span style=\"color:#000000;\">先创建一个类</span></strong></p>\n<p style=\"margin-left:0;text-align:justify;\"><img alt=\"\" height=\"521\" src=\"image\\1fe55bdc6849473d806ca86b20b0f6c2.png\" width=\"1078\"/></p>\n<p style=\"margin-left:0;text-align:justify;\"><strong>               </strong><strong><span style=\"color:#000000;\">然后写配置文件：这其中需要引入context与aop这两个名称空间，不会引入名称空间的小伙伴要去学咯。</span></strong></p>\n<p style=\"margin-left:0;text-align:justify;\"><img alt=\"\" height=\"726\" src=\"image\\dd0e795e0fbc4de5a5a18bbbd66191d2.png\" width=\"1200\"/></p>\n<p style=\"margin-left:0;text-align:justify;\"></p>\n<p style=\"margin-left:0;text-align:justify;\"><strong><span style=\"color:#000000;\">然后再创建一个类对原有的类进行增加功能：这里的在前面都讲过了，那个权限修饰符可以省略不写，写了也不出错</span></strong></p>\n<p style=\"margin-left:0;text-align:justify;\"><img alt=\"\" height=\"601\" src=\"image\\fe76c4f44ae2447fb99344948d382cca.png\" width=\"1200\"/></p>\n<p style=\"margin-left:0;text-align:justify;\"><strong><span style=\"color:#000000;\">最后进行测试：</span></strong></p>\n<p style=\"margin-left:0;text-align:justify;\"><img alt=\"\" height=\"1200\" src=\"image\\ed93aa3ae84b4fdcbef8ac53baa8ec80.png\" width=\"1200\"/></p>\n<p style=\"margin-left:0;text-align:justify;\"><strong><span style=\"color:#000000;\">运行结果正常，证明咱们没错。</span></strong></p>\n</div>\n</div>"}