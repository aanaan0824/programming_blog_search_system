{"blogid": "122028955", "writerAge": "码龄15年", "writerBlogNum": "613", "writerCollect": "728", "writerComment": "275", "writerFan": "3270", "writerGrade": "8级", "writerIntegral": "29092", "writerName": "孙飞 Sunface", "writerProfileAdress": "writer_image\\profile_122028955.jpg", "writerRankTotal": "93833", "writerRankWeekly": "10657", "writerThumb": "845", "writerVisitNum": "2511165", "blog_read_count": "1008", "blog_time": "于 2021-12-19 20:03:37 发布", "blog_title": "Rust学习教程32 - 动态数组Vec", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-tomorrow-night\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<blockquote>\n<p>本文节选自<a href=\"https://github.com/sunface/rust-course\">&lt;&lt;Rust语言圣经&gt;&gt;</a>一书<br/> 欢迎大家加入Rust编程学院，一起学习交流:<br/> QQ群：1009730433</p>\n</blockquote>\n<h1><a id=\"Vector_4\"></a>动态数组Vector</h1>\n<p>动态数组类型用<code>Vec&lt;T&gt;</code>表示，事实上，在之前的章节，它的身影多次出现，我们一直没有细讲，只是简单的把它当作数组处理。</p>\n<p>动态数组允许你存储多个值，这些值在内存中一个紧挨着另一个排列，因此访问其中某个元素的成本非常低。动态数组只能存储相同类型的元素，如果你想存储不同类型的元素，可以使用之前讲过的枚举类型或者特征对象.</p>\n<p>总之，当我们想拥有一个列表，里面都是相同类型的数据时，动态数组将会非常有用。</p>\n<h2><a id=\"_12\"></a>创建动态数组</h2>\n<p>在Rust中，有多种方式可以创建动态数组。</p>\n<h4><a id=\"Vecnew_15\"></a>Vec::new</h4>\n<p>使用<code>Vec::new</code>创建动态数组是最rusty的方式，它调用了<code>Vec</code>中的<code>new</code>关联函数：</p>\n<pre><code class=\"prism language-rust\"><span class=\"token keyword\">let</span> v<span class=\"token punctuation\">:</span> <span class=\"token class-name\">Vec</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">i32</span><span class=\"token operator\">&gt;</span> <span class=\"token operator\">=</span> <span class=\"token class-name\">Vec</span><span class=\"token punctuation\">::</span><span class=\"token function\">new</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>这里, <code>v</code>被显式地声明了类型<code>Vec&lt;i32&gt;</code>，这是因为Rust编译器无法从<code>Vec::new()</code>中得到任何关于类型的暗示信息，因此也无法推导出<code>v</code>的具体类型，但是当你向里面增加一个元素后，一切又不同了：</p>\n<pre><code class=\"prism language-rust\"><span class=\"token keyword\">let</span> <span class=\"token keyword\">mut</span> v <span class=\"token operator\">=</span> <span class=\"token class-name\">Vec</span><span class=\"token punctuation\">::</span><span class=\"token function\">new</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nv<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>此时，<code>v</code>就无需手动声明类型，因为编译器通过<code>v.push(1)</code>，推测出<code>v</code>中的元素类型是<code>i32</code>，因此推导出<code>v</code>的类型是<code>Vec&lt;id3&gt;</code>.</p>\n<h4><a id=\"vec_29\"></a>vec![]</h4>\n<p>还可以使用宏<code>vec!</code>来创建数组，与<code>Vec::new</code>有所不同，前者能在创建同时给予初始化值：</p>\n<pre><code class=\"prism language-rust\"><span class=\"token keyword\">let</span> v <span class=\"token operator\">=</span> <span class=\"token macro property\">vec!</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>同样，此处的<code>v</code>也无需标注类型，编译器只需检查它内部的元素即可自动推导出<code>v</code>的类型是<code>Vec&lt;i32&gt;</code>(Rust中，整数默认类型是i32，在<a href=\"../base-type/numbers.md#%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B\">数值类型</a>中有详细介绍)。</p>\n<h2><a id=\"Vector_37\"></a>更新Vector</h2>\n<p>向数组尾部添加元素，可以使用<code>push</code>方法:</p>\n<pre><code class=\"prism language-rust\"><span class=\"token keyword\">let</span> <span class=\"token keyword\">mut</span> v <span class=\"token operator\">=</span> <span class=\"token class-name\">Vec</span><span class=\"token punctuation\">::</span><span class=\"token function\">new</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nv<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>与其它类型一样，必须将<code>v</code>声明为<code>mut</code>后，才能进行修改,.</p>\n<h2><a id=\"Vector_47\"></a>Vector与其元素共存亡</h2>\n<p>跟结构体一样，<code>Vector</code>类型在超出作用域范围后，会被自动删除:</p>\n<pre><code class=\"prism language-rust\"><span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">let</span> v <span class=\"token operator\">=</span> <span class=\"token macro property\">vec!</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span> <span class=\"token comment\">// &lt;- v超出作用域并在此处被删除</span>\n</code></pre>\n<p>当<code>Vector</code>被删除后，它内部存储的所有内容也会随之被删除。目前来看，这种解决方案简单直白，但是当<code>vector</code>中的元素被引用后，事情可能会没那么简单。</p>\n<h2><a id=\"Vector_59\"></a>从Vector中读取元素</h2>\n<p>读取指定位置的元素有两种方式可选: 通过下标索引访问或者使用<code>get</code>方法:</p>\n<pre><code class=\"prism language-rust\"><span class=\"token keyword\">let</span> v <span class=\"token operator\">=</span> <span class=\"token macro property\">vec!</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> third<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span><span class=\"token keyword\">i32</span> <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>v<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token macro property\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"第三个元素是 {}\"</span><span class=\"token punctuation\">,</span> third<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">match</span> v<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token class-name\">Some</span><span class=\"token punctuation\">(</span>third<span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span> <span class=\"token macro property\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"第三个元素是 {}\"</span><span class=\"token punctuation\">,</span> third<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token class-name\">None</span> <span class=\"token operator\">=&gt;</span> <span class=\"token macro property\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"去你的第三个元素，根本没有！\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>和其它语言一样，集合类型的索引下标都是从<code>0</code>开始，<code>&amp;v[2]</code>表示借用<code>v</code>中的第三个元素，最终会获得该元素的引用。而<code>v.get(2)</code>也是访问第三个元素，但是有所不同的是，它返回了<code>Option&lt;&amp;T&gt;</code>，因此还需要额外的<code>match</code>来匹配解构出具体的值。</p>\n<h4><a id=\"get_75\"></a>下标索引与<code>.get</code>的区别</h4>\n<p>这两种方式都能成功的读取到指定的数组元素，既然如此为什么会存在两种方法？何况<code>.get</code>还会增加使用复杂度，让我们通过示例说明：</p>\n<pre><code class=\"prism language-rust\"><span class=\"token keyword\">let</span> v <span class=\"token operator\">=</span> <span class=\"token macro property\">vec!</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> does_not_exist <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>v<span class=\"token punctuation\">[</span><span class=\"token number\">100</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> does_not_exist <span class=\"token operator\">=</span> v<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>运行以上代码，<code>&amp;v[100]</code>的访问方式会导致程序无情报错退出，因为发生了数组越界访问。 但是<code>v.get</code>就不会，它在内部做了处理，有值的时候返回<code>Some(T)</code>，无值的时候返回<code>None</code>，因此<code>v.get</code>的使用方式非常安全。</p>\n<p>既然如此，为何不统一使用<code>v.get</code>的形式？因为实在是有些啰嗦，Rust语言的设计者和使用者在审美这方面还是相当统一的：简洁即正义，何况性能上也会有轻微的损耗。</p>\n<p>既然有两个选择，肯定就有如何选择的问题，答案很简单，当你确保索引不会越界的时候，就用索引访问，否则用<code>.get</code>。例如，访问第几个数组元素并不取决于我们，而是取决于用户的输入时，用<code>.get</code>会非常适合，天知道那些可爱的用户会输入一个什么样的数字进来！</p>\n<h5><a id=\"_90\"></a>同时借用多个数组元素</h5>\n<p>既然涉及到借用数组元素，那么很可能会遇到同时借用多个数组元素的情况，还记得在<a href=\"../ownership/borrowing.md#%E5%80%9F%E7%94%A8%E8%A7%84%E5%88%99%E6%80%BB%E7%BB%93\">所有权和借用</a>章节咱们讲过的借用规则嘛？如果记得，就来看看下面的代码：）</p>\n<pre><code class=\"prism language-rust\"><span class=\"token keyword\">let</span> <span class=\"token keyword\">mut</span> v <span class=\"token operator\">=</span> <span class=\"token macro property\">vec!</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> first <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>v<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\nv<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token number\">6</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token macro property\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"The first element is: {}\"</span><span class=\"token punctuation\">,</span> first<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>先不运行，来推断下结果，首先<code>first = &amp;v[0]</code>进行了不可变借用，<code>v.push</code>进行了可变借用，如果<code>first</code>在<code>v.push</code>之后不再使用，那么该段代码可以成功编译(原因见<a href=\"../ownership/borrowing.md#%E5%8F%AF%E5%8F%98%E5%BC%95%E7%94%A8%E4%B8%8E%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%BC%95%E7%94%A8%E4%B8%8D%E8%83%BD%E5%90%8C%E6%97%B6%E5%AD%98%E5%9C%A8\">引用的作用域</a>).</p>\n<p>可是上面的代码中，<code>first</code>这个不可变借用在可变借用<code>v.push</code>后被使用了，那么妥妥的，编译器就会报错：</p>\n<pre><code class=\"prism language-console\">$ cargo run\nCompiling collections v0.1.0 (file:///projects/collections)\nerror[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable 无法对v进行可变借用，因此之前已经进行了不可变借用\n--&gt; src/main.rs:6:5\n|\n4 |     let first = &amp;v[0];\n|                  - immutable borrow occurs here // 不可变借用发生在此处\n5 | \n6 |     v.push(6);\n|     ^^^^^^^^^ mutable borrow occurs here // 可变借用发生在此处\n7 | \n8 |     println!(\"The first element is: {}\", first);\n|                                          ----- immutable borrow later used here // 不可变借用在这里被使用\n\nFor more information about this error, try `rustc --explain E0502`.\nerror: could not compile `collections` due to previous error\n</code></pre>\n<p>其实，按理来说，这两个引用不应该互相影响的：一个是查询元素，一个是在数组尾部插入元素，完全不相干的操作，为何编译器要这么严格呢？</p>\n<p>原因在于：数组的大小是可变的，当老数组的大小不够用时，Rust会重新分配一块更大的内存空间，然后把老数组拷贝过来。这种情况下，之前的引用显然会指向一块无效的内存，这非常rusty - 对用户进行严格的教育。</p>\n<p>其实想想，<strong>在长大之后，我们感激人生路上遇到过的严师益友，正是因为他们，我们才在正确的道路上不断前行，虽然在那个时候，并不能理解他们</strong>，而Rust就如那个良师益友，它不断的在纠正我们不好的编程习惯，直到某一天，你发现自己能写出一次性通过的漂亮代码时，就能明白它的良苦用心。</p>\n<blockquote>\n<p>若读者想要更深入的了解<code>Vec&lt;T&gt;</code>，可以看看[Rustonomicon]，其中从零手撸一个动态数组，非常适合深入学习</p>\n</blockquote>\n<h2><a id=\"Vector_132\"></a>迭代遍历Vector中的元素</h2>\n<p>如果想要依次访问数组中的元素，可以使用迭代的方式去遍历数组，这种方式比用下标的方式去遍历数组更安全也更高效(每次下标访问都会触发数组边界检查):</p>\n<pre><code class=\"prism language-rust\"><span class=\"token keyword\">let</span> v <span class=\"token operator\">=</span> <span class=\"token macro property\">vec!</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token operator\">&amp;</span>v <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token macro property\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"{}\"</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>也可以在迭代过程中，修改<code>Vector</code>中的元素：</p>\n<pre><code class=\"prism language-rust\"><span class=\"token keyword\">let</span> <span class=\"token keyword\">mut</span> v <span class=\"token operator\">=</span> <span class=\"token macro property\">vec!</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token operator\">&amp;</span><span class=\"token keyword\">mut</span> v <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token operator\">*</span>i <span class=\"token operator\">+=</span> <span class=\"token number\">10</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h2><a id=\"_150\"></a>存储不同类型的元素</h2>\n<p>在本节开头，有讲到数组的元素必需类型相同，但是也提到了解决方案: 那就是通过使用枚举类型和特征对象来实现不同类型元素的存储。先来看看通过枚举如何实现：</p>\n<pre><code class=\"prism language-rust\"><span class=\"token attribute attr-name\">#[derive(Debug)]</span>\n<span class=\"token keyword\">enum</span> <span class=\"token type-definition class-name\">IpAddr</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token constant\">V4</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token constant\">V6</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">let</span> v <span class=\"token operator\">=</span> <span class=\"token macro property\">vec!</span><span class=\"token punctuation\">[</span>\n        <span class=\"token class-name\">IpAddr</span><span class=\"token punctuation\">::</span><span class=\"token constant\">V4</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"127.0.0.1\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">to_string</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n        <span class=\"token class-name\">IpAddr</span><span class=\"token punctuation\">::</span><span class=\"token constant\">V6</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"::1\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">to_string</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span> ip <span class=\"token keyword\">in</span> v <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token function\">show_addr</span><span class=\"token punctuation\">(</span>ip<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">show_addr</span><span class=\"token punctuation\">(</span>ip<span class=\"token punctuation\">:</span> <span class=\"token class-name\">IpAddr</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token macro property\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"{:?}\"</span><span class=\"token punctuation\">,</span>ip<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>数组<code>v</code>中存储了两种不同的<code>ip</code>地址，但是这两种都属于<code>IpAddr</code>枚举类型的成员，因此可以存储在数组中。</p>\n<p>再来看看特征对象的实现：</p>\n<pre><code class=\"prism language-rust\"><span class=\"token keyword\">trait</span> <span class=\"token class-name\">IpAddr</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">display</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">struct</span> <span class=\"token type-definition class-name\">V4</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">impl</span> <span class=\"token class-name\">IpAddr</span> <span class=\"token keyword\">for</span> <span class=\"token constant\">V4</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">display</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token macro property\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"ipv4: {:?}\"</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">struct</span> <span class=\"token type-definition class-name\">V6</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">impl</span> <span class=\"token class-name\">IpAddr</span> <span class=\"token keyword\">for</span> <span class=\"token constant\">V6</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">display</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token macro property\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"ipv6: {:?}\"</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">let</span> v<span class=\"token punctuation\">:</span> <span class=\"token class-name\">Vec</span><span class=\"token operator\">&lt;</span><span class=\"token class-name\">Box</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">dyn</span> <span class=\"token class-name\">IpAddr</span><span class=\"token operator\">&gt;&gt;</span> <span class=\"token operator\">=</span> <span class=\"token macro property\">vec!</span><span class=\"token punctuation\">[</span>\n        <span class=\"token class-name\">Box</span><span class=\"token punctuation\">::</span><span class=\"token function\">new</span><span class=\"token punctuation\">(</span><span class=\"token constant\">V4</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"127.0.0.1\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">to_string</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n        <span class=\"token class-name\">Box</span><span class=\"token punctuation\">::</span><span class=\"token function\">new</span><span class=\"token punctuation\">(</span><span class=\"token constant\">V6</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"127.0.0.1\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">to_string</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span> ip <span class=\"token keyword\">in</span> v <span class=\"token punctuation\">{<!-- --></span>\n        ip<span class=\"token punctuation\">.</span><span class=\"token function\">display</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>比枚举实现要稍微复杂一些，我们为<code>V4</code>和<code>V6</code>都实现了特征<code>IpAddr</code>，然后将它俩的实例用<code>Box::new</code>包裹后，存在了数组<code>v</code>中，需要注意的是，这里必需手动的指定类型：<code>Vec&lt;Box&lt;dyn IpAddr&gt;&gt;</code>，表示数组<code>v</code>存储的是特征<code>IpAddr</code>的对象，这样就实现了在数组中存储不同的类型.</p>\n<p>在实际使用场景中，特征对象数组要比枚举数组常见很多，主要原因在于<a href=\"../trait/trait-object.md\">特征对象非常灵活</a>，而编译器对枚举的限制较多，且无法动态增加类型。</p>\n<p>最后，如果你想要了解<code>Vector</code>更多的用法，请参见本书的标准库解析章节：<a href=\"../../std/vector.md\"><code>Vector</code>常用方法</a></p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}