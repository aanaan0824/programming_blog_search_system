{"blogid": "125531427", "writerAge": "码龄2年", "writerBlogNum": "91", "writerCollect": "437", "writerComment": "194", "writerFan": "643", "writerGrade": "4级", "writerIntegral": "1457", "writerName": "梦梦~~", "writerProfileAdress": "writer_image\\profile_125531427.jpg", "writerRankTotal": "22027", "writerRankWeekly": "18922", "writerThumb": "209", "writerVisitNum": "107418", "blog_read_count": "16960", "blog_time": "于 2022-06-30 00:19:36 发布", "blog_title": "MySQL优化：从十几秒优化到三百毫秒", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-tomorrow-night\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p><font size=\"4\">        今天这篇文章还是记录问题的解决过程的。昨天测试测试代码的时候，发现一个功能需要大概十几秒的时间才能执行完。我就去看自己的代码逻辑，完整看了代码之后，凭感觉导致时间长的原因有两部分：一个是mysql的书写问题，另一个可能是循环查询数据库的问题。代码梦梦就不上传了，可能会涉及到公司的隐私问题</font></p>\n<p><font size=\"4\">        下面是粘出来的sql部分，可以看到这个sql都7秒多了，第二张图片是使用explain执行器之后的结果，可以看到五张表只有两张表走了索引，其他的表没有走索引，可以看到type这一列的级别也是ALL。</font><br/> <font size=\"4\">        结果值从好到坏依次是：system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL。一般来说，得保证查询至少达到range级别，最好能达到ref，否则就可能会出现性能问题。所以这个sql要优化了。</font><br/> <img alt=\"在这里插入图片描述\" src=\"image\\997c0d4170dd471a9a993e61fc78830e.png\"/></p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\e656681cadb944b3bc6dc85304b74140.png\"/></p>\n<p><font size=\"4\">        优化方式：</font><br/> <font size=\"4\">        1，先结合type+key这两列来优化，也就是通过增加索引来优化。一般我会给在where 和order by 子句中用到字段添加索引。所以我就在 d 表上添加了四个索引（deviceId、name、del_flag、project_id），c 表给prdfession也添加了索引。</font></p>\n<p><font size=\"4\">        2，之后再根据Extra这一列进行优化，可以看到上图这两列出现了“Using temporary”、“Using filesort”这两种情况。</font><br/> <font size=\"4\">        “Using temporary”：指的是sql中如果order by或者group by中的字段都来自于其它表而非连接顺序中的第一个表，就会创建一个临时表了。解决方案：可以尝试创建联合索引试试。</font><br/> <font size=\"4\">        “Using filesort”：指的是order by 查询的字段数据量超出了mysql的默认值，导致了order by中的字段不走索引，使用了文件查询，也是导致性能瓶颈的原因。解决方案：可以尝试把排序功能放到代码中实现，sql中不做排序。</font><br/> <font size=\"4\">        当创建了普通索引、联合索引（project_id + name）之后，再看一下sql的执行速度。</font><br/> <img alt=\"在这里插入图片描述\" src=\"image\\049783fefc2a4271ade5ec474fa2998d.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"image\\839c2120e69e4732ba4ef8685b7d015c.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"image\\6657d433ceab4943aa51145ec94ca52a.png\"/></p>\n<p><font size=\"4\">        可以看到执行速度立马就提了上去，explain命令执行的时候，也会发现type一列全达到了ref级别，extra一列去没有了“Using temporary”、“Using filesort”这两个影响性能的标志。</font><br/> <font size=\"4\">        现在sql的优化就完成了，如果速度还慢的话，就考虑优化代码逻辑的部分辽。</font></p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}