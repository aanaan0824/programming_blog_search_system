{"blogid": "126654108", "writerAge": "码龄5年", "writerBlogNum": "240", "writerCollect": "4607", "writerComment": "475", "writerFan": "22095", "writerGrade": "6级", "writerIntegral": "7310", "writerName": "小锋学长生活大爆炸", "writerProfileAdress": "writer_image\\profile_126654108.jpg", "writerRankTotal": "1761", "writerRankWeekly": "466", "writerThumb": "788", "writerVisitNum": "664539", "blog_read_count": "665", "blog_time": "已于 2022-09-02 01:27:47 修改", "blog_title": "万字长文保姆级教你制作自己的多功能QQ机器人", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<blockquote>\n 转载请注明出处：小锋学长生活大爆炸(\n <a href=\"https://xfxuezhang.blog.csdn.net/\" title=\"https://xfxuezhang.blog.csdn.net/\">https://xfxuezhang.blog.csdn.net/</a>)\n</blockquote>\n<blockquote>\n<span style=\"color:#fe2c24;\"><strong>由于CSDN编辑器问题，存在很多图片缺失，强烈建议访问原文：</strong></span>\n<a href=\"http://xfxuezhang.cn/index.php/archives/418/\" title=\"万字长文保姆级教你制作自己的多功能QQ机器人 - 小锋学长生活大爆炸\">万字长文保姆级教你制作自己的多功能QQ机器人 - 小锋学长生活大爆炸</a>\n</blockquote>\n<p><a name=\"sZLfq\"></a></p>\n<p><a name=\"ci_title0\"></a>​​​​​​</p>\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E5%89%8D%E8%A8%80-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%89%8D%E8%A8%80\">前言</a></p>\n<p id=\"%E5%8A%9F%E8%83%BD%E6%B8%85%E5%8D%95-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%8A%9F%E8%83%BD%E6%B8%85%E5%8D%95\">功能清单</a></p>\n<p id=\"%E5%85%8D%E8%B4%B9%E9%A2%86%E5%8F%96%E8%BD%BB%E9%87%8F%E5%BA%94%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%85%8D%E8%B4%B9%E9%A2%86%E5%8F%96%E8%BD%BB%E9%87%8F%E5%BA%94%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8\">免费领取轻量应用服务器</a></p>\n<p id=\"SSH%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8-toc\" style=\"margin-left:0px;\"><a href=\"#SSH%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8\">SSH连接服务器</a></p>\n<p id=\"%E5%B8%B8%E8%A7%81Ubuntu%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E4%B8%8E%E9%97%AE%E9%A2%98%E4%BF%AE%E5%A4%8D-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%B8%B8%E8%A7%81Ubuntu%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E4%B8%8E%E9%97%AE%E9%A2%98%E4%BF%AE%E5%A4%8D\">常见Ubuntu软件安装与问题修复</a></p>\n<p id=\"%E6%90%AD%E5%BB%BAmirai%E7%8E%AF%E5%A2%83-toc\" style=\"margin-left:0px;\"><a href=\"#%E6%90%AD%E5%BB%BAmirai%E7%8E%AF%E5%A2%83\">搭建mirai环境</a></p>\n<p id=\"Python%E6%8E%A7%E5%88%B6mirai%E7%AF%87-toc\" style=\"margin-left:0px;\"><a href=\"#Python%E6%8E%A7%E5%88%B6mirai%E7%AF%87\">Python控制mirai篇</a></p>\n<p id=\"debug%E8%BE%93%E5%87%BA%E5%B0%81%E8%A3%85-toc\" style=\"margin-left:40px;\"><a href=\"#debug%E8%BE%93%E5%87%BA%E5%B0%81%E8%A3%85\">debug输出封装</a></p>\n<p id=\"%E4%BA%A4%E4%BA%92%E6%8E%88%E6%9D%83-toc\" style=\"margin-left:40px;\"><a href=\"#%E4%BA%A4%E4%BA%92%E6%8E%88%E6%9D%83\">交互授权</a></p>\n<p id=\"%E7%BB%91%E5%AE%9Abot-toc\" style=\"margin-left:40px;\"><a href=\"#%E7%BB%91%E5%AE%9Abot\">绑定bot</a></p>\n<p id=\"%E9%87%8A%E6%94%BEbot-toc\" style=\"margin-left:40px;\"><a href=\"#%E9%87%8A%E6%94%BEbot\">释放bot</a></p>\n<p id=\"%E6%9C%AA%E8%AF%BB%E6%B6%88%E6%81%AF%E7%9A%84%E6%95%B0%E9%87%8F-toc\" style=\"margin-left:40px;\"><a href=\"#%E6%9C%AA%E8%AF%BB%E6%B6%88%E6%81%AF%E7%9A%84%E6%95%B0%E9%87%8F\">未读消息的数量</a></p>\n<p id=\"%E8%8E%B7%E5%8F%96%E6%9C%80%E6%96%B0%E7%9A%84%E6%B6%88%E6%81%AF-toc\" style=\"margin-left:40px;\"><a href=\"#%E8%8E%B7%E5%8F%96%E6%9C%80%E6%96%B0%E7%9A%84%E6%B6%88%E6%81%AF\">获取最新的消息</a></p>\n<p id=\"%E8%A7%A3%E6%9E%90%E6%B6%88%E6%81%AF%E5%86%85%E5%AE%B9-toc\" style=\"margin-left:40px;\"><a href=\"#%E8%A7%A3%E6%9E%90%E6%B6%88%E6%81%AF%E5%86%85%E5%AE%B9\">解析消息内容</a></p>\n<p id=\"%E5%90%91%E5%A5%BD%E5%8F%8B%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%90%91%E5%A5%BD%E5%8F%8B%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF\">向好友发送消息</a></p>\n<p id=\"%E5%90%91%E7%BE%A4%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%90%91%E7%BE%A4%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF\">向群发送消息</a></p>\n<p id=\"%E5%90%91%E7%BE%A4%E5%8F%91%E9%80%81%E5%AF%8C%E6%96%87%E6%9C%AC%E6%B6%88%E6%81%AF-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%90%91%E7%BE%A4%E5%8F%91%E9%80%81%E5%AF%8C%E6%96%87%E6%9C%AC%E6%B6%88%E6%81%AF\">向群发送富文本消息</a></p>\n<p id=\"Q%E7%BE%A4%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91-toc\" style=\"margin-left:0px;\"><a href=\"#Q%E7%BE%A4%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91\">Q群消息转发</a></p>\n<p id=\"%E7%B1%BB%E4%BC%BCQMsg%E9%85%B1%E7%9A%84%E6%B6%88%E6%81%AF%E9%80%9A%E7%9F%A5-toc\" style=\"margin-left:0px;\"><a href=\"#%E7%B1%BB%E4%BC%BCQMsg%E9%85%B1%E7%9A%84%E6%B6%88%E6%81%AF%E9%80%9A%E7%9F%A5\">类似QMsg酱的消息通知</a></p>\n<p id=\"%E5%A4%9A%E5%8A%9F%E8%83%BD%E5%88%87%E6%8D%A2%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%AE%BE%E8%AE%A1-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%A4%9A%E5%8A%9F%E8%83%BD%E5%88%87%E6%8D%A2%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%AE%BE%E8%AE%A1\">多功能切换的实现设计</a></p>\n<p id=\"%E7%BF%BB%E8%AF%91%E6%9F%A5%E8%AF%A2-toc\" style=\"margin-left:0px;\"><a href=\"#%E7%BF%BB%E8%AF%91%E6%9F%A5%E8%AF%A2\">翻译查询</a></p>\n<p id=\"%E9%A2%86%E5%8F%96%E8%85%BE%E8%AE%AF%E5%85%8D%E8%B4%B9%E7%BF%BB%E8%AF%91API-toc\" style=\"margin-left:40px;\"><a href=\"#%E9%A2%86%E5%8F%96%E8%85%BE%E8%AE%AF%E5%85%8D%E8%B4%B9%E7%BF%BB%E8%AF%91API\">领取腾讯免费翻译API</a></p>\n<p id=\"%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%8E%A5%E5%85%A5%E7%BF%BB%E8%AF%91%E5%8A%9F%E8%83%BD-toc\" style=\"margin-left:40px;\"><a href=\"#%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%8E%A5%E5%85%A5%E7%BF%BB%E8%AF%91%E5%8A%9F%E8%83%BD\">机器人接入翻译功能</a></p>\n<p id=\"%E5%AE%9E%E6%97%B6%E5%A4%A9%E6%B0%94-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%AE%9E%E6%97%B6%E5%A4%A9%E6%B0%94\">实时天气</a></p>\n<p id=\"%E9%A2%86%E5%8F%96%E5%85%8D%E8%B4%B9%E7%9A%84%E5%92%8C%E9%A3%8E%E5%A4%A9%E6%B0%94API-toc\" style=\"margin-left:40px;\"><a href=\"#%E9%A2%86%E5%8F%96%E5%85%8D%E8%B4%B9%E7%9A%84%E5%92%8C%E9%A3%8E%E5%A4%A9%E6%B0%94API\">领取免费的和风天气API</a></p>\n<p id=\"%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%8E%A5%E5%85%A5%E5%A4%A9%E6%B0%94%E5%8A%9F%E8%83%BD-toc\" style=\"margin-left:40px;\"><a href=\"#%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%8E%A5%E5%85%A5%E5%A4%A9%E6%B0%94%E5%8A%9F%E8%83%BD\">机器人接入天气功能</a></p>\n<p id=\"%E5%AE%9E%E6%97%B6%E7%83%AD%E6%90%9C-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%AE%9E%E6%97%B6%E7%83%AD%E6%90%9C\">实时热搜</a></p>\n<p id=\"%E9%A2%86%E5%8F%96%E5%85%8D%E8%B4%B9%E7%9A%84%E5%A4%A9%E8%A1%8C%E7%83%AD%E6%90%9CAPI-toc\" style=\"margin-left:40px;\"><a href=\"#%E9%A2%86%E5%8F%96%E5%85%8D%E8%B4%B9%E7%9A%84%E5%A4%A9%E8%A1%8C%E7%83%AD%E6%90%9CAPI\">领取免费的天行热搜API</a></p>\n<p id=\"%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%8E%A5%E5%85%A5%E7%83%AD%E6%90%9C%E5%8A%9F%E8%83%BD-toc\" style=\"margin-left:40px;\"><a href=\"#%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%8E%A5%E5%85%A5%E7%83%AD%E6%90%9C%E5%8A%9F%E8%83%BD\">机器人接入热搜功能</a></p>\n<p id=\"%E7%85%A7%E7%89%87%E4%B8%8A%E4%BC%A0-toc\" style=\"margin-left:0px;\"><a href=\"#%E7%85%A7%E7%89%87%E4%B8%8A%E4%BC%A0\">照片上传</a></p>\n<p id=\"%E9%A2%86%E5%8F%96%E8%85%BE%E8%AE%AF%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8COS-toc\" style=\"margin-left:40px;\"><a href=\"#%E9%A2%86%E5%8F%96%E8%85%BE%E8%AE%AF%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8COS\">领取腾讯对象存储COS</a></p>\n<p id=\"%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%8E%A5%E5%85%A5%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%8A%9F%E8%83%BD-toc\" style=\"margin-left:40px;\"><a href=\"#%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%8E%A5%E5%85%A5%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%8A%9F%E8%83%BD\">机器人接入图片上传功能</a></p>\n<p id=\"%E8%87%AA%E8%A1%8C%E6%B7%BB%E5%8A%A0%E5%B0%8F%E5%8A%9F%E8%83%BD%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93-toc\" style=\"margin-left:0px;\"><a href=\"#%E8%87%AA%E8%A1%8C%E6%B7%BB%E5%8A%A0%E5%B0%8F%E5%8A%9F%E8%83%BD%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93\">自行添加小功能函数总结</a></p>\n<p id=\"%E6%8E%A7%E5%88%B6%E6%A0%91%E8%8E%93%E6%B4%BE%E8%88%B5%E6%9C%BA%E4%B8%8E%E5%B1%8F%E6%98%BE-toc\" style=\"margin-left:0px;\"><a href=\"#%E6%8E%A7%E5%88%B6%E6%A0%91%E8%8E%93%E6%B4%BE%E8%88%B5%E6%9C%BA%E4%B8%8E%E5%B1%8F%E6%98%BE\">控制树莓派舵机与屏显</a></p>\n<p id=\"%E8%85%BE%E8%AE%AF%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BAMQTT%E7%8E%AF%E5%A2%83-toc\" style=\"margin-left:40px;\"><a href=\"#%E8%85%BE%E8%AE%AF%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BAMQTT%E7%8E%AF%E5%A2%83\">腾讯云服务器搭建MQTT环境</a></p>\n<p id=\"%E5%BE%85%E5%AE%9E%E7%8E%B0%E5%8A%9F%E8%83%BD-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%BE%85%E5%AE%9E%E7%8E%B0%E5%8A%9F%E8%83%BD\">待实现功能</a></p>\n<p id=\"%E6%8E%A5%E5%85%A5%E6%8E%A7%E5%88%B6ESP32(%E5%AE%9E%E7%8E%B0%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85%E6%8E%A7%E5%88%B6)-toc\" style=\"margin-left:40px;\"><a href=\"#%E6%8E%A5%E5%85%A5%E6%8E%A7%E5%88%B6ESP32%28%E5%AE%9E%E7%8E%B0%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85%E6%8E%A7%E5%88%B6%29\">接入控制ESP32(实现智能家居控制)</a></p>\n<p id=\"%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%E6%95%B4%E7%90%86-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%E6%95%B4%E7%90%86\">完整代码整理</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<p></p>\n<h1 id=\"%E5%89%8D%E8%A8%80\">前言</h1>\n<p>QQ、微信是我们平常使用最多的通讯工具，网上也有很多通过软件去控制QQ/微信的开源工具，通过这些工具，我们可以实现许多有意思的效果，而不仅仅局限于消息聊天。<br/> 自从微信网页版被官方禁用后，微信的软件工具几乎已经失效了，现有的一些是通过hook微信本身来实现，这种很容易被官方检测并封号。另一些是通过注册企业号来控制，但不直观且功能受限。<br/> 这里我们借助相对更开放的QQ来制作我们的机器人，对比几款工具后，最终选择了<strong>mirai</strong>。<br/><br/><br/><a name=\"Kuddq\"></a></p>\n<p><a name=\"ci_title1\"></a></p>\n<h1 id=\"%E5%8A%9F%E8%83%BD%E6%B8%85%E5%8D%95\">功能清单</h1>\n<p>网上现有开源的机器人大多只是实现了类似“自动推送天气、接入图灵机器人自动聊天”等等，大多属于自娱自乐，没有发挥最大用途。<br/> 因此，我们的QQ机器人(暂且取名为<strong>“小锋仔”</strong>)是根据日常所需而制，包含常用功能且设计得易于扩展。<br/><strong>目前包含的功能有：</strong></p>\n<ul><li>类似QMsg酱的消息通知</li><li>QQ群消息转发</li><li>翻译查询</li><li>照片上传</li><li>实况天气</li><li>实时热搜</li><li>控制树莓派舵机</li><li>控制树莓派屏显</li><li>... ...</li></ul>\n<p><strong>将来可能包含的功能有：</strong></p>\n<ul><li>接入控制ESP32(实现智能家居控制)</li></ul>\n<p>接下来详细介绍如何自己搭建一个这样的QQ机器人。<strong>篇幅较长</strong>且<strong>保姆级详细</strong>，建议收藏后慢慢看。<br/><a name=\"LoHxV\"></a></p>\n<p><a name=\"ci_title2\"></a></p>\n<h1 id=\"%E5%85%8D%E8%B4%B9%E9%A2%86%E5%8F%96%E8%BD%BB%E9%87%8F%E5%BA%94%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8\">免费领取轻量应用服务器</h1>\n<blockquote>\n 首先为了能运行mirai，且随时随地能连接，我们需要有一个\n <strong>具备公网IP的服务器</strong>。这里使用腾讯云的\n <strong>免费服务器</strong>。\n <br/> 如果你已有服务器了，可以跳过本节，当然也可以看一看下面介绍的性价比超高的服务器。\n</blockquote>\n<p>对比<strong>云服务器 CVM</strong>，<strong>轻量应用服务器 </strong>更聚焦于中小企业、开发者、云计算入门者、学生等用户群体。详细的对比可以看：<a href=\"https://cloud.tencent.com/document/product/1207/49819\" title=\"轻量应用服务器 与云服务器 CVM 对比-产品简介-文档中心-腾讯云\">轻量应用服务器 与云服务器 CVM 对比-产品简介-文档中心-腾讯云</a>。<br/> 因此，对于个人学习与使用而言，轻量服务器<strong>更便宜、更实用</strong>，且<strong>性能不输</strong>。如果是想要进阶的童靴，可以上手CVM、ECS服务器。<br/> 对于还不想买的童靴，可以<strong>免费领取</strong>腾讯云提供的<strong>1个月服务器试用套餐</strong>。直接上领取步骤：</p>\n<ol><li>进入官网：<a href=\"https://curl.qcloud.com/HfOuxzXC\" title=\"云产品免费试用\">云产品免费试用</a>；</li><li>下滑到中间位置，有个“<strong>云产品体验</strong>”专区。可以看到有很多产品可以试用，大家感兴趣的话可以依次尝试下，这里我们主要试用“<strong>轻量应用服务器</strong>”：</li></ol>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\c158ec9f2b8724eb4961a2a82b274699.png\"/></p>\n<ol><li>进入配置页面，这里我们选择<strong>Ubuntu</strong>系统(注意别选错哦)。</li></ol>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\3972172c72debc2653cfff8b562627f7.png\"/></p>\n<p><br/><br/> 然后需要扫码进行人脸认证<br/><br/> 完成支付即可，金额0元，也即白送。<br/><br/><strong>注：</strong>试用时间使用完之后，也可以继续续费。对比<strong>其他几家</strong>的云服务提供商如华为云、百度云、阿里云，服务器的价格都较贵，即使是<strong>1核1G2M的学生价服务器</strong>，也要近<strong>99元/年</strong>。但<strong>腾讯云的2核2G4M轻量应用服务器只需65元/年</strong>，确实是很诱人了。进入<a href=\"https://curl.qcloud.com/6s8YCjob\" title=\"轻量应用服务器专场\">轻量应用服务器专场</a>可以选择不同的配置。当然，对于<strong>学生用户</strong>，也可以直接在<a href=\"https://curl.qcloud.com/h42F6h0e\" title=\"云+校园特惠套餐\">云+校园特惠套餐</a>选择。</p>\n<ol><li>完成购买后，需要进入控制台，设置SSH登录密码</li></ol>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\5799c6980130f97b91533fe999bef94f.png\"/></p>\n<p><br/>  </p>\n<ol><li>记住“<strong>公网IP、用户名(ubuntu)、密码</strong>”这三项，后面要用到。</li><li>更多云产品可看：<a href=\"https://curl.qcloud.com/fnG9lyjo\" title=\"云产品特惠专区\">云产品特惠专区</a>。</li><li>由于后面需要用到端口，因此这里我们提前开放2个端口：8888和9966</li></ol>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\7d64eaf4a1df362abf9f84c1209d1f79.png\"/></p>\n<p><br/><br/> 这里腾讯云可能有个<strong>小特点</strong>。如果发现在控制台防火墙放行后，还是无法访问。需要再在服务器里放行一下端口。这里先写着，大家可以在后面一节中连接上了服务器，再回过来这里输入指令。</p>\n<pre><code>sudo apt install firewalld -y\nsudo firewall-cmd --list-all\nsudo firewall-cmd --permanent --zone=public --add-port=8888/tcp &amp;&amp; sudo firewall-cmd --reload\nsudo firewall-cmd --permanent --zone=public --add-port=9966/tcp &amp;&amp; sudo firewall-cmd --reload\nsudo systemctl start firewalld.service</code></pre>\n<p><a name=\"zPy6u\"></a></p>\n<p><a name=\"ci_title3\"></a></p>\n<h1 id=\"SSH%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8\">SSH连接服务器</h1>\n<p>服务器初始化完成后，就可以通过<strong>SSH</strong>去连接了。这里我们可以直接使用<strong>powershell</strong>来连接，其他SSH软件我强推<strong>mobaxterm</strong>！！安装包也已经准备好了：<a href=\"http://xfxuezhang.cn/web/share/QQBot/MobaXterm.exe\" title=\"MobaXterm.exe\">MobaXterm.exe</a></p>\n<ol><li>搜索打开powershell：</li></ol>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\ae2b1fcded85723ddd86a2843a3c6ef0.png\"/></p>\n<ol><li>输入以下命令连接SSH：</li></ol>\n<pre><code>ssh 用户名@&lt;公网ip&gt;</code></pre>\n<ol><li>或者使用MobaXterm软件：</li></ol>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\83e7176e0eac66694fa3d9ca3d9238a5.png\"/></p>\n<ol><li>先更新一下软件库：</li></ol>\n<pre><code>sudo apt upgrade -y\nsudo apt autoremove -y</code></pre>\n<ol><li>一般不建议使用管理员账户，因此我们要自己新建一个账户：</li></ol>\n<pre><code>sudo adduser sxf</code></pre>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\621539bba91450b26103df56043f676e.png\"/></p>\n<p><br/> 然后将账户加入sudoers组：</p>\n<pre><code>sudo apt install vim\nsudo vim /etc/sudoers</code></pre>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\c706bfe3ac97415fb1c197002dfe2779.png\"/></p>\n<p><br/> 然后退出软件，重新用新建的账号登录即可。<br/> 至此，服务器环境就搭建完成了。</p>\n<p><a name=\"Mr2DD\"></a></p>\n<p><a name=\"ci_title4\"></a></p>\n<h1 id=\"%E5%B8%B8%E8%A7%81Ubuntu%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E4%B8%8E%E9%97%AE%E9%A2%98%E4%BF%AE%E5%A4%8D\">常见Ubuntu软件安装与问题修复</h1>\n<p>这篇博客里记录了很多我在使用过程中，常用软件的安装，非常详细且经过亲测，时不时也会更新内容，大家可以收藏以备下次使用。<br/><a href=\"https://blog.csdn.net/sxf1061700625/article/details/121265658\" title=\"Ubuntu20.04 + VirtualBox相关_小锋学长生活大爆炸的博客-CSDN博客\">Ubuntu20.04 + VirtualBox相关_小锋学长生活大爆炸的博客-CSDN博客</a></p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\60853193451c0e3d93e493dd87efe233.png\"/></p>\n<p><br/><a name=\"uoxBD\"></a></p>\n<p><a name=\"ci_title5\"></a></p>\n<h1 id=\"%E6%90%AD%E5%BB%BAmirai%E7%8E%AF%E5%A2%83\">搭建mirai环境</h1>\n<p>接下来就要在服务器上搭建QQ机器人(mirai)基础环境。搭建完成后，我们就可以远程跟机器人进行交互。<br/> 官方mirai的github仓库：<a href=\"https://github.com/mamoe/mirai\" title=\"GitHub - mamoe/mirai: 高效率 QQ 机器人支持库\">GitHub - mamoe/mirai: 高效率 QQ 机器人支持库</a><br/> 由于github是国外的，而官方已经不再支持<a href=\"https://gitee.com/shiver/mirai\" title=\"gitee\">gitee</a>的维护，因此如果大家无法访问上面的连接，可以用我帮大家下载下来的安装包：<br/> 其他的一些文档：<a href=\"https://docs.mirai.mamoe.net/\" title=\"Mirai | mirai\">Mirai | mirai</a><br/> 官方论坛：<a href=\"https://mirai.mamoe.net/\" title=\"主页 | MiraiForum\">主页 | MiraiForum</a><br/><strong>下面开始正式安装：</strong></p>\n<ol><li>先SSH连接上服务器，建议不要用root用户登录。</li><li>下载安装包mcl-installer-a02f711-linux-amd64：</li></ol>\n<pre><code>mkdir qqbot\ncd qqbot\nwget http://xfxuezhang.cn/web/share/QQBot/mcl-installer-a02f711-linux-amd64\nsudo chmod +x mcl-installer-a02f711-linux-amd64</code></pre>\n<p>此时需要输入密码(在上面选购并装完服务器后会显示，当时要求记下的)。</p>\n<pre><code>./mcl-installer-a02f711-linux-amd64</code></pre>\n<p>此时进入安装流程，弹出的几个选项都<strong>直接回车</strong>选默认即可。</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\6c630a89a9b4a44be66b2829cfc24e27.png\"/></p>\n<ol><li>安装完成后，还需要安装mirai-api-http。在当前页面下，继续输入：</li></ol>\n<pre><code>./mcl --update-package net.mamoe:mirai-api-http --channel stable-v2 --type plugin</code></pre>\n<ol><li>编辑_config/net.mamoe.mirai-api-http/setting.yml_配置文件 (没有则自行创建)</li></ol>\n<pre><code>## 配置文件中的值，全为默认值\n\n## 启用的 adapter, 内置有 http, ws, reverse-ws, webhook\nadapters:\n  - http\n  - ws\n\n## 是否开启认证流程, 若为 true 则建立连接时需要验证 verifyKey\n## 建议公网连接时开启\nenableVerify: true\nverifyKey: 1234567890\n\n## 开启一些调式信息\ndebug: false\n\n## 是否开启单 session 模式, 若为 true，则自动创建 session 绑定 console 中登录的 bot\n## 开启后，接口中任何 sessionKey 不需要传递参数\n## 若 console 中有多个 bot 登录，则行为未定义\n## 确保 console 中只有一个 bot 登陆时启用\nsingleMode: false\n\n## 历史消息的缓存大小\n## 同时，也是 http adapter 的消息队列容量\ncacheSize: 4096\n\n## adapter 的单独配置，键名与 adapters 项配置相同\nadapterSettings:\n  ## 详情看 http adapter 使用说明 配置\n  http:\n    # 0.0.0.0是允许远程访问，localhost只能同机器访问\n    host: 0.0.0.0\n    port: 8888\n    cors: [\"*\"]\n    unreadQueueMaxSize: 100\n  \n  ## 详情看 websocket adapter 使用说明 配置\n  ws:\n    host: localhost\n    port: 8080\n    reservedSyncId: -1</code></pre>\n<ol><li>启动mirai即可：</li></ol>\n<pre><code>./mcl</code></pre>\n<p>首次启动会自动下载jar包。等待启动完成后，输入\"<strong>?</strong>\"，可以查看所有支持的mcl命令。</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\95224e6a482755b42d35541eb73761fe.png\"/></p>\n<ol><li>使用以下命令即可登录QQ号：</li></ol>\n<pre><code>/login  [password] </code></pre>\n<p>如果想要启动mcl后自动登录QQ号，可以用：</p>\n<pre><code>/autoLogin add   </code></pre>\n<p>也可以设置不同的设备登录。</p>\n<pre><code>/autoLogin setConfig  protocol ANDROID_PAD</code></pre>\n<p>它对应的配置文件其实就在：<strong>config/Console/AutoLogin.yml</strong></p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\a2e385fa692545c74521c111a38b8411.png\"/></p>\n<ol><li> <p>现在QQ风控很严了，第一次登录很有可能遇到“需要滑动验证码”的。建议申请<strong>小号</strong>使用，以免发生不测。并且首次使用时在QQ“<strong>账号安全设置</strong>”中关闭“<strong>安全登录检查</strong>”、“<strong>陌生设备登录保护</strong>”。如果遇到验证码，可以尝试：</p>\n<ol><li>将Captcha link通过另一个QQ，发给待登录的mirai-QQ，手机登录mirai-QQ并点击链接，手动完成滑块验证，然后回到mobaxterm输入回车；</li></ol></li></ol>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\a6687a85d83d8209c8d0ca81ae977eaf.png\"/></p>\n<ol><li>如果不行，就参考这个链接的方法：<a href=\"https://github.com/project-mirai/mirai-login-solver-selenium\" title=\"GitHub - project-mirai/mirai-login-solver-selenium: SliderCaptcha solver\">GitHub - project-mirai/mirai-login-solver-selenium: SliderCaptcha solver</a>；</li><li>还不行，再参考这个链接的方法：<a href=\"https://docs.mirai.mamoe.net/mirai-login-solver-selenium/\" title=\"mirai-login-solver-selenium | mirai\">mirai-login-solver-selenium | mirai</a>；</li><li>还有一个小技巧可以尝试。在手机端先通过手机号登录QQ，如果没问题，再通过手机号在mirai上登录。手机建议先登录上mirai-QQ，有时可能会弹窗提示“是否允许陌生设备登录”等等，要手动点确认的。</li><li>另外，<strong>最新申请的QQ号</strong>，一般可以成功登录mirai。</li><li>如果以上都不行，目前的<strong>终极方案</strong>是使用<strong>miraiAndroid</strong>：<a href=\"https://github.com/mzdluo123/MiraiAndroid\" title=\"MiraiAndroid\">MiraiAndroid</a>：</li></ol>\n<ul><li>在手机上的MiraiAndroid登录QQ后导出device.json</li><li>将cache目录下的3个文件account.secrets、servers.json、session.bin也复制出来</li></ul>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\49328769fcb8068fb9fc8b14789199d0.png\"/></p>\n<ul><li>接下来点击左上角, 再点击“<strong>工具</strong>”。选择你机器人的账号, 选择 <strong>导出 DEVICE.JSON</strong> 将其导出。</li></ul>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\bad2f326a163e07543617d89c5ff2067.png\"/></p>\n<ul><li>再次回到服务器端，进入 “<strong>bots/&lt;你的QQ号&gt;</strong>” 下面, 将导出的 <strong>device.json</strong> 复制放入。对应的cache文件夹也复制放入。</li></ul>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\7211d2ad1723f1ed80a5a55ceec859d8.png\"/></p>\n<ul><li>再次执行 <strong>./mcl </strong>启动 mirai-console 看看效果。</li></ul>\n<ul><li>若仍有问题，欢迎加入<strong>文末Q群</strong>交流。</li></ul>\n<ol><li>至此，mcl就已经能正常接收QQ消息了。而我们的实现代码对mcl的控制，就是通过<strong>mirai-api-http</strong>插件来实现的。根据上面第4步配置的_setting.yml_文件，再参考<a href=\"https://docs.mirai.mamoe.net/mirai-api-http/api/API.html\" title=\"官方API文档\">官方API文档</a>和<a href=\"https://github.com/project-mirai/mirai-api-http/blob/master/docs/adapter/HttpAdapter.md#%E8%AE%A4%E8%AF%81%E4%B8%8E%E4%BC%9A%E8%AF%9D\" title=\"HttpAdapter文档\">HttpAdapter文档</a>，即可实现互联互通。(讲起来比较麻烦，no bibi，后面直接show me the code)。</li></ol>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\9fa9c193a6e44f0eadee54d333c9ff76.png\"/></p>\n<p><a name=\"Qxjel\"></a></p>\n<p><a name=\"ci_title6\"></a></p>\n<h1 id=\"Python%E6%8E%A7%E5%88%B6mirai%E7%AF%87\">Python控制mirai篇</h1>\n<p>当服务器成功运行了mirai后，我们就可以在本地进行Python脚本的编写了。由于最新的mirai-api-http变更过接口规范，因此网上某些一两年前的代码已经失效了。本教程对应的mirai-api-http使用的是最新的2.x版本。<br/> 接下来的操作，<strong>都默认已经完成“启动mcl并login了QQ号”</strong>。<br/> 在上面setting.yml中，有两个配置项值得注意，他是我们脚本可以控制的密钥：</p>\n<pre><code>verifyKey: 1234567890\nhttp: port: 8888</code></pre>\n<p><a name=\"s6u8X\"></a></p>\n<p><a name=\"ci_title7\"></a></p>\n<h2 id=\"debug%E8%BE%93%E5%87%BA%E5%B0%81%E8%A3%85\">debug输出封装</h2>\n<p>简单封装下。直接用print也是可以的。</p>\n<pre><code>class Logger:\n    def __init__(self, level='debug'):\n        self.level = level\n\n    def DebugLog(self, *args):\n        if self.level == 'debug':\n            print(*args)\n\n    def TraceLog(self, *args):\n        if self.level == 'trace':\n            print(*args)\n\n    def setDebugLevel(self, level):\n        self.level = level.lower()</code></pre>\n<p><a name=\"JECIJ\"></a></p>\n<p><a name=\"ci_title8\"></a></p>\n<h2 id=\"%E4%BA%A4%E4%BA%92%E6%8E%88%E6%9D%83\">交互授权</h2>\n<p>在交互前，脚本需要先向mirai获取一个verifyKey，之后在每个请求时候，都需要带上这个key，也叫session。其中，参数auth_key对应了上面setting.yml里的verifyKey。</p>\n<pre><code>auth_key = '1234567890'\n\ndef verifySession(self, auth_key):\n    \"\"\"每个Session只能绑定一个Bot，但一个Bot可有多个Session。\n        session Key在未进行校验的情况下，一定时间后将会被自动释放\"\"\"\n    data = {\"verifyKey\": auth_key}\n    url = self.addr+'verify'\n    res = requests.post(url, data=json.dumps(data)).json()\n    logger.DebugLog(res)\n    if res['code'] == 0:\n        return res['session']\n    return None</code></pre>\n<p><a name=\"bdqEn\"></a></p>\n<p><a name=\"ci_title9\"></a></p>\n<h2 id=\"%E7%BB%91%E5%AE%9Abot\">绑定bot</h2>\n<p>使用此方法校验并激活你的Session，同时将Session与一个<strong>已登录</strong>的Bot绑定。</p>\n<pre><code>qq = '121215'             # mirai登录的那个QQ\nsession = 'grge8484'     # 上面verifySession函数的返回值\n\ndef bindSession(self, session, qq):\n    \"\"\"校验并激活Session，同时将Session与一个已登录的Bot绑定\"\"\"\n    data = {\"sessionKey\": session, \"qq\": qq}\n    url = self.addr + 'bind'\n    res = requests.post(url, data=json.dumps(data)).json()\n    logger.DebugLog(res)\n    if res['code'] == 0:\n        self.session = session\n        return True\n    return False</code></pre>\n<p><a name=\"KXtmJ\"></a></p>\n<p><a name=\"ci_title10\"></a></p>\n<h2 id=\"%E9%87%8A%E6%94%BEbot\">释放bot</h2>\n<p>使用此方式释放session及其相关资源（Bot不会被释放）</p>\n<pre><code>def releaseSession(self, session, qq):\n    \"\"\"不使用的Session应当被释放，长时间（30分钟）未使用的Session将自动释放，\n        否则Session持续保存Bot收到的消息，将会导致内存泄露(开启websocket后将不会自动释放)\"\"\"\n    data = {\"sessionKey\": session, \"qq\": qq}\n    url = self.addr + 'release'\n    res = requests.post(url, data=json.dumps(data)).json()\n    logger.DebugLog(res)\n    if res['code'] == 0:\n        return True\n    return False</code></pre>\n<p><a name=\"mWc3I\"></a></p>\n<p><a name=\"ci_title11\"></a></p>\n<h2 id=\"%E6%9C%AA%E8%AF%BB%E6%B6%88%E6%81%AF%E7%9A%84%E6%95%B0%E9%87%8F\">未读消息的数量</h2>\n<p>获取当前有多少条未读消息。</p>\n<pre><code>def getMessageCount(self, session):\n    url = self.addr + 'countMessage?sessionKey='+session\n    res = requests.get(url).json()\n    if res['code'] == 0:\n        return res['data']\n    return 0</code></pre>\n<p><a name=\"pdGHm\"></a></p>\n<p><a name=\"ci_title12\"></a></p>\n<h2 id=\"%E8%8E%B7%E5%8F%96%E6%9C%80%E6%96%B0%E7%9A%84%E6%B6%88%E6%81%AF\">获取最新的消息</h2>\n<p>获取消息后会从队列中移除。</p>\n<pre><code>def fetchLatestMessage(self, session):\n    url = self.addr + 'fetchLatestMessage?count=10&amp;sessionKey='+session\n    res = requests.get(url).json()\n    if res['code'] == 0:\n        return res['data']\n    return None</code></pre>\n<p><a name=\"CarET\"></a></p>\n<p><a name=\"ci_title13\"></a></p>\n<h2 id=\"%E8%A7%A3%E6%9E%90%E6%B6%88%E6%81%AF%E5%86%85%E5%AE%B9\">解析消息内容</h2>\n<p>简单实现了部分消息类型的解析，会有消息丢失，请根据使用需求自行调整。</p>\n<pre><code>data = 'xxx'  # 可以是上面getMsgFromGroup函数的返回值\n\ndef parseGroupMsg(self, data):\n    res = []\n    if data is None:\n        return res\n    for item in data:\n        if item['type'] == 'GroupMessage':\n            type = item['messageChain'][-1]['type']\n            if type == 'Image':\n                text = item['messageChain'][-1]['url']\n            elif type == 'Plain':\n                text = item['messageChain'][-1]['text']\n            elif type == 'Face':\n                text = item['messageChain'][-1]['faceId']\n            else:\n                logger.TraceLog(\"&gt;&gt; 当前消息类型暂不支持转发：=&gt; \"+type)\n                continue\n                name = item['sender']['memberName']\n                group_id = str(item['sender']['group']['id'])\n                group_name = item['sender']['group']['name']\n                res.append({'text': text, 'type': type, 'name': name, 'groupId': group_id, 'groupName': group_name})\n                return res</code></pre>\n<p><a name=\"fOsXd\"></a></p>\n<p><a name=\"ci_title14\"></a></p>\n<h2 id=\"%E5%90%91%E5%A5%BD%E5%8F%8B%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF\">向好友发送消息</h2>\n<p>向指定好友发送消息。</p>\n<pre><code>def sendFriendMessage(self, session, qq, msg):\n    msg_list = msg.split(r'\\n')\n    msg_chain = [{ \"type\": \"Plain\", \"text\": m+'\\n' } for m in msg_list]\n\n    data = {\n        \"sessionKey\": session,\n        \"target\": qq,\n        \"messageChain\": msg_chain\n    }\n    url = self.addr + 'sendFriendMessage'\n    try:\n        res = requests.post(url, data=json.dumps(data)).json()\n        except:\n            logger.DebugLog(\"&gt;&gt; 发送失败\")\n            return 0\n        if res['code'] == 0:\n            return res['messageId']\n        return 0</code></pre>\n<p><a name=\"ZZOsN\"></a></p>\n<p><a name=\"ci_title15\"></a></p>\n<h2 id=\"%E5%90%91%E7%BE%A4%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF\">向群发送消息</h2>\n<p>也只是简单实现。</p>\n<pre><code>def sendMsgToGroup(self, session, group, msg):\n    text = msg['text']\n    type = msg['type']\n    name = msg['name']\n    group_id = msg['groupId']\n    group_name = msg['groupName']\n    content1 = \"【消息中转助手】\\n用户：{}\\n群号：{}\\n群名：{}\\n消息：\\n{}\".format(\n        name, group_id, group_name, text)\n    content2 = \"【消息中转助手】\\n用户：{}\\n群号：{}\\n群名：{}\\n消息：\\n\".format(\n        name, group_id, group_name)\n    logger.DebugLog(\"&gt;&gt; 消息类型：\" + type)\n    if type == 'Plain':\n        message = [{\"type\": type, \"text\": content1}]\n    elif type == 'Image':\n        message = [\n            {\"type\": 'Plain', \"text\": content2},\n            {\"type\": type, \"url\": text}]\n    elif type == 'Face':\n        message = [{\"type\": 'Plain', \"text\": content2},\n                   {\"type\": type, \"faceId\": text}]\n    else:\n        logger.TraceLog(\"&gt;&gt; 当前消息类型暂不支持转发：=&gt; \"+type)\n        return 0\n    data = {\n        \"sessionKey\": session,\n        \"group\": group,\n        \"messageChain\": message\n    }\n    logger.DebugLog(\"&gt;&gt; 消息内容：\" + str(data))\n    url = self.addr + 'sendGroupMessage'\n    try:\n        res = requests.post(url, data=json.dumps(data)).json()\n        except:\n            logger.DebugLog(\"&gt;&gt; 转发失败\")\n            return 0\n        logger.DebugLog(\"&gt;&gt; 请求返回：\" + str(res))\n        if res['code'] == 0:\n            return res['messageId']\n        return 0</code></pre>\n<p><a name=\"ChQ9f\"></a></p>\n<p><a name=\"ci_title16\"></a></p>\n<h2 id=\"%E5%90%91%E7%BE%A4%E5%8F%91%E9%80%81%E5%AF%8C%E6%96%87%E6%9C%AC%E6%B6%88%E6%81%AF\">向群发送富文本消息</h2>\n<p>跟上面的差不多，消息类型变了一下，从而支持类似HTML形式的消息发送。</p>\n<pre><code>def sendPlainTextToGroup(self, session, group, msg):\n    msg_list = msg.split(r'\\n')\n    msg_chain = [{ \"type\": \"Plain\", \"text\": m+'\\n' } for m in msg_list]\n    data = {\n        \"sessionKey\": session,\n        \"group\": group,\n        \"messageChain\": msg_chain\n    }\n    url = self.addr + 'sendGroupMessage'\n    try:\n        res = requests.post(url, data=json.dumps(data)).json()\n        except:\n            logger.DebugLog(\"&gt;&gt; 转发失败\")\n            return 0\n        logger.DebugLog(\"&gt;&gt; 请求返回：\" + str(res))\n        if res['code'] == 0:\n            return res['messageId']\n        return 0</code></pre>\n<p>以上就是几个简单、常用的函数。基于这些函数，就已经可以实现蛮多有趣的功能了。<br/><a name=\"BAVcl\"></a></p>\n<p><a name=\"ci_title17\"></a></p>\n<h1 id=\"Q%E7%BE%A4%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91\">Q群消息转发</h1>\n<p>这部分可以直接参考之前的博客：<a href=\"https://blog.csdn.net/sxf1061700625/article/details/122793393?\" title=\"Q群消息转发例程\">Q群消息转发例程</a>。其实也就是把上面的函数整合一下，放一个完整版：</p>\n<pre><code>import requests\nfrom time import sleep\n\nclass Logger:\n    def __init__(self, level='debug'):\n        self.level = level\n\n    def DebugLog(self, *args):\n        if self.level == 'debug':\n            print(*args)\n\n    def TraceLog(self, *args):\n        if self.level == 'trace':\n            print(*args)\n\n    def setDebugLevel(self, level):\n        self.level = level.lower()\n\nlogger = Logger()\nclass QQBot:\n    def __init__(self):\n        self.addr = 'http://43.143.12.250:8888/'\n        self.session = None\n\n    def verifySession(self, auth_key):\n        \"\"\"每个Session只能绑定一个Bot，但一个Bot可有多个Session。\n        session Key在未进行校验的情况下，一定时间后将会被自动释放\"\"\"\n        data = {\"verifyKey\": auth_key}\n        url = self.addr+'verify'\n        res = requests.post(url, data=json.dumps(data)).json()\n        logger.DebugLog(res)\n        if res['code'] == 0:\n            return res['session']\n        return None\n\n    def bindSession(self, session, qq):\n        \"\"\"校验并激活Session，同时将Session与一个已登录的Bot绑定\"\"\"\n        data = {\"sessionKey\": session, \"qq\": qq}\n        url = self.addr + 'bind'\n        res = requests.post(url, data=json.dumps(data)).json()\n        logger.DebugLog(res)\n        if res['code'] == 0:\n            self.session = session\n            return True\n        return False\n\n    def releaseSession(self, session, qq):\n        \"\"\"不使用的Session应当被释放，长时间（30分钟）未使用的Session将自动释放，\n        否则Session持续保存Bot收到的消息，将会导致内存泄露(开启websocket后将不会自动释放)\"\"\"\n        data = {\"sessionKey\": session, \"qq\": qq}\n        url = self.addr + 'release'\n        res = requests.post(url, data=json.dumps(data)).json()\n        logger.DebugLog(res)\n        if res['code'] == 0:\n            return True\n        return False\n\n    def fetchLatestMessage(self, session):\n        url = self.addr + 'fetchLatestMessage?count=10&amp;sessionKey='+session\n        res = requests.get(url).json()\n        if res['code'] == 0:\n            return res['data']\n        return None\n\n    def parseGroupMsg(self, data):\n        res = []\n        if data is None:\n            return res\n        for item in data:\n            if item['type'] == 'GroupMessage':\n                type = item['messageChain'][-1]['type']\n                if type == 'Image':\n                    text = item['messageChain'][-1]['url']\n                elif type == 'Plain':\n                    text = item['messageChain'][-1]['text']\n                elif type == 'Face':\n                    text = item['messageChain'][-1]['faceId']\n                else:\n                    logger.TraceLog(\"&gt;&gt; 当前消息类型暂不支持转发：=&gt; \"+type)\n                    continue\n                name = item['sender']['memberName']\n                group_id = str(item['sender']['group']['id'])\n                group_name = item['sender']['group']['name']\n                res.append({'text': text, 'type': type, 'name': name, 'groupId': group_id, 'groupName': group_name})\n        return res\n\n    def getMessageCount(self, session):\n        url = self.addr + 'countMessage?sessionKey='+session\n        res = requests.get(url).json()\n        if res['code'] == 0:\n            return res['data']\n        return 0\n\n    def sendPlainTextToGroup(self, session, group, msg):\n        msg_list = msg.split(r'\\n')\n        msg_chain = [{ \"type\": \"Plain\", \"text\": m+'\\n' } for m in msg_list]\n        data = {\n          \"sessionKey\": session,\n          \"group\": group,\n          \"messageChain\": msg_chain\n        }\n        url = self.addr + 'sendGroupMessage'\n        try:\n            res = requests.post(url, data=json.dumps(data)).json()\n        except:\n            logger.DebugLog(\"&gt;&gt; 转发失败\")\n            return 0\n        logger.DebugLog(\"&gt;&gt; 请求返回：\" + str(res))\n        if res['code'] == 0:\n            return res['messageId']\n        return 0\n\n    def sendMsgToGroup(self, session, group, msg):\n        text = msg['text']\n        type = msg['type']\n        name = msg['name']\n        group_id = msg['groupId']\n        group_name = msg['groupName']\n        content1 = \"【消息中转助手】\\n用户：{}\\n群号：{}\\n群名：{}\\n消息：\\n{}\".format(\n            name, group_id, group_name, text)\n        content2 = \"【消息中转助手】\\n用户：{}\\n群号：{}\\n群名：{}\\n消息：\\n\".format(\n            name, group_id, group_name)\n        logger.DebugLog(\"&gt;&gt; 消息类型：\" + type)\n        if type == 'Plain':\n            message = [{\"type\": type, \"text\": content1}]\n        elif type == 'Image':\n            message = [\n                {\"type\": 'Plain', \"text\": content2},\n                {\"type\": type, \"url\": text}]\n        elif type == 'Face':\n            message = [{\"type\": 'Plain', \"text\": content2},\n                       {\"type\": type, \"faceId\": text}]\n        else:\n            logger.TraceLog(\"&gt;&gt; 当前消息类型暂不支持转发：=&gt; \"+type)\n            return 0\n        data = {\n                \"sessionKey\": session,\n                \"group\": group,\n                \"messageChain\": message\n                }\n        logger.DebugLog(\"&gt;&gt; 消息内容：\" + str(data))\n        url = self.addr + 'sendGroupMessage'\n        try:\n            res = requests.post(url, data=json.dumps(data)).json()\n        except:\n            logger.DebugLog(\"&gt;&gt; 转发失败\")\n            return 0\n        logger.DebugLog(\"&gt;&gt; 请求返回：\" + str(res))\n        if res['code'] == 0:\n            return res['messageId']\n        return 0\n\n    def sendMsgToAllGroups(self, session, receive_groups, send_groups, msg_data):\n        # 对每条消息进行检查\n        for msg in msg_data:\n            group_id = msg['groupId']\n            # 接收的消息群正确（目前只支持 消息类型）\n            if group_id in receive_groups:\n                # 依次将消息转发到目标群\n                for g in send_groups:\n                    logger.DebugLog(\"&gt;&gt; 当前群：\"+g)\n                    if g == group_id:\n                        logger.DebugLog(\"&gt;&gt; 跳过此群\")\n                        continue\n                    res = self.sendMsgToGroup(session, g, msg)\n                    if res != 0:\n                        logger.TraceLog(\"&gt;&gt; 转发成功！{}\".format(g))\n\n    def sendFriendMessage(self, session, qq, msg):\n        msg_list = msg.split(r'\\n')\n        msg_chain = [{ \"type\": \"Plain\", \"text\": m+'\\n' } for m in msg_list]\n\n        data = {\n          \"sessionKey\": session,\n          \"target\": qq,\n          \"messageChain\": msg_chain\n        }\n        url = self.addr + 'sendFriendMessage'\n        try:\n            res = requests.post(url, data=json.dumps(data)).json()\n        except:\n            logger.DebugLog(\"&gt;&gt; 发送失败\")\n            return 0\n        if res['code'] == 0:\n            return res['messageId']\n        return 0\n\ndef qqTransfer():\n    with open('conf.json', 'r+', encoding=\"utf-8\") as f:\n        content = f.read()\n    conf = json.loads(content)\n\n    auth_key = conf['auth_key']\n    bind_qq = conf['bind_qq']\n    sleep_time = conf['sleep_time']\n    debug_level = conf['debug_level']\n\n    receive_groups = conf['receive_groups']\n    send_groups = conf['send_groups']\n\n    logger.setDebugLevel(debug_level)\n\n    session = bot.verifySession(auth_key)\n    logger.DebugLog(\"&gt;&gt; session: \"+session)\n    bot.bindSession(session, bind_qq)\n    while True:\n        cnt = bot.getMessageCount(session)\n        if cnt:\n            logger.DebugLog('&gt;&gt; 有消息了 =&gt; {}'.format(cnt))\n            logger.DebugLog('获取消息内容')\n            data = bot.fetchLatestMessage(session)\n            if len(data) == 0:\n                logger.DebugLog('消息为空')\n                continue\n            logger.DebugLog(data)\n            logger.DebugLog('解析消息内容')\n            data = bot.parseGroupMsg(data)\n            logger.DebugLog(data)\n            logger.DebugLog('转发消息内容')\n            bot.sendMsgToAllGroups(session, receive_groups, send_groups, data)\n        # else:\n        #     logger.DebugLog('空闲')\n        sleep(sleep_time)\n    bot.releaseSession(session, bind_qq)</code></pre>\n<p>其中，conf.json内容为：</p>\n<pre><code>{\n  \"auth_key\": \"1234567890\",\n  \"bind_qq\":  \"123456\",                                                     # mirai登录的QQ (复制时记得删我)\n  \"sleep_time\": 1,\n  \"receive_groups\": [\"913182235\", \"977307922\"],  # 要接受消息的群 (复制时记得删我)\n  \"send_groups\": [\"913182235\", \"977307922\"],         # 要发送消息的群 (复制时记得删我)\n  \"debug_level\": \"debug\"\n}\n</code></pre>\n<p>下面，我们就先从类似QMsg酱的消息通知开始。</p>\n<p><a name=\"saACt\"></a></p>\n<p><a name=\"ci_title18\"></a></p>\n<h1 id=\"%E7%B1%BB%E4%BC%BCQMsg%E9%85%B1%E7%9A%84%E6%B6%88%E6%81%AF%E9%80%9A%E7%9F%A5\">类似QMsg酱的消息通知</h1>\n<p><strong>设计目标</strong>：通过调用指定的URL，小锋仔机器人就会给指定的好友发送指定的消息。<br/> 关于QMsg酱的使用教程可以看：<a href=\"https://blog.csdn.net/sxf1061700625/article/details/107099612?\" title=\"免费的QQ微信消息推送机器人\">免费的QQ微信消息推送机器人</a><br/> 前面我们特地开放了9966端口，因此可以使用<strong>Flask</strong>来监听这个端口。<br/> 本着越简单越好的原则，我们把“<strong>发给好友还是群</strong>”、“<strong>目标好友或群的号</strong>”、“<strong>发送的内容</strong>”三部分都拼接到URL上，因此有：</p>\n<pre><code>http://43.143.12.250:9966/QQ/send/friend?target=123&amp;msg=hello\nhttp://43.143.12.250:9966/QQ/send/group?target=123&amp;msg=hello</code></pre>\n<p>因此，代码可以写成：</p>\n<pre><code>from flask import Flask, request\n\napp = Flask(__name__)\n\n@app.route('/QQ/send/friend', methods=['GET'])\ndef qqListenMsgToFriend():\n    # 类似于Qmsg的功能\n    # flask做得接收HTTP请求转为QQ消息\n    qq = request.args.get('target', None)\n    msg = request.args.get('msg', None)\n    bot.sendFriendMessage(bot.session, qq, msg)\n    return 'Hello World! Friend!'\n\n@app.route('/QQ/send/group', methods=['GET'])\ndef qqListenMsgToGroup():\n    # 类似于Qmsg的功能\n    # flask做得接收HTTP请求转为QQ消息\n    qq = request.args.get('target', None)\n    msg = request.args.get('msg', None)\n    bot.sendPlainTextToGroup(bot.session, qq, msg)\n    return 'Hello World! Group!'\n\nif __name__ == '__main__':\n    app.run(port='9966', host='0.0.0.0')</code></pre>\n<p>由于Flask和小锋仔QQBot都要阻塞运行，因此稍微变动一下，让小锋仔以子线程的形式运行即可。</p>\n<pre><code>if __name__ == '__main__':\n    t = threading.Thread(target=qqTransfer)\n    t.setDaemon(True)\n    t.start()\n\n    app.run(port='9966', host='0.0.0.0')</code></pre>\n<p>测试一下：</p>\n<pre><code>http://localhost:9966/QQ/send/friend?target=1061700625&amp;msg=hello</code></pre>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\ce68e4b2e9e6ecf6397c33f593ad81b3.png\"/></p>\n<p><br/> 如果我们把这个脚本放到服务器上去运行，那么链接就变成了：</p>\n<pre><code>http://43.143.12.250:9966/QQ/send/friend?target=1061700625&amp;msg=hello</code></pre>\n<p>当然，能发消息的前提是“<strong>先加好友</strong>”或“<strong>加群</strong>”啦。</p>\n<p><a name=\"aHCI6\"></a></p>\n<p><a name=\"ci_title19\"></a></p>\n<h1 id=\"%E5%A4%9A%E5%8A%9F%E8%83%BD%E5%88%87%E6%8D%A2%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%AE%BE%E8%AE%A1\">多功能切换的实现设计</h1>\n<p>上面我们进行了简单地尝鲜。<br/> 1、从这部分开始，我们涉及的功能比较杂，为了能更好的区分功能，需要设计一个简单的交互协议。</p>\n<ul><li>我们发送的内容可以分为：<strong>功能选择</strong> 与 <strong>消息详情</strong>；</li><li>为了区分他俩，可以在选择功能时添加<strong>指定前缀</strong>，如“CMD+翻译”；</li><li>小锋仔接收到后，进入翻译模式准备；</li><li>发送指令详情时，就不加前缀。而小锋仔则将收到的消息进行翻译，再把结果返回。</li></ul>\n<p>根据以上内容，小锋仔需要记录的状态信息至少有：</p>\n<pre><code>class StatusStore:\n    def __init__(self, from_qq:int=None, is_cmd:bool=False, func_name:str=None, need_second:bool=False, msg:str=None) -&gt; None:\n        self.from_qq = from_qq          # 发送者的QQ号\n        self.is_cmd = is_cmd            # 是否是指令(选择功能)\n        self.func_name = func_name      # 选择的功能的名称\n        self.need_second = need_second  # 是否需要经过两步：先发cmd指令，再发详细内容\n        self.msg = msg                  # 本次发送的消息内容\n    \n    def detail(self):\n        return self.__dict__</code></pre>\n<p>2、并且我们设置，只有从指定QQ发过来消息，才能响应。因此在接收到消息时，需要判断对方的信息。对于好友类型的消息，mirai返回格式如<a href=\"https://github.com/project-mirai/mirai-api-http/blob/master/docs/api/MessageType.md\" title=\"消息类型说明\">消息类型说明</a>：</p>\n<pre><code>{\n  \"type\": \"FriendMessage\",\n  \"sender\": {\n    \"id\": 123,\n    \"nickname\": \"\",\n    \"remark\": \"\"\n  },\n  \"messageChain\": [] // 数组，内容为下文消息类型\n}</code></pre>\n<p>因此，我们可以从\"type\"和 \"sender:id\"入手判断。<br/> 3、我们暂时考虑只有一个主QQ能发送指令的情况。<br/> 4、定义一个类来专门管理不同功能的函数，例如：</p>\n<pre><code>class MultiFunction:\n    \"\"\"多功能函数集合\"\"\"\n    def __init__(self) -&gt; None:\n        pass\n\n    @staticmethod\n    def translate(original:str, convert:str='zh2en') -&gt; str:\n        return '假装是翻译结果' \n    \n    @staticmethod\n    def uploadImage(image_path:str) -&gt; str:\n        return '假装是上传结果' \n\n    @staticmethod\n    def weather(city:str) -&gt; str:\n        return '假装是天气结果' \n    \n    @staticmethod\n    def hotNews(status_store:StatusStore) -&gt; str:\n        return '假装是热搜结果' \n\n\n# 多功能函数的映射\n# function: 功能对应函数名\n# need_second: 是否需要经过两步：先发cmd指令，再发详细内容\n# desc: 需要经过两步时，第一次返回的提示语\nfunction_map = {\n    '翻译': {'function': MultiFunction.translate, 'need_second': True, 'desc': '请输入您要翻译的内容~'}, \n    '天气': {'function': MultiFunction.weather, 'need_second': True, 'desc': '请问是哪座城市的天气呢？'}, \n    '热搜': {'function': MultiFunction.hotNews, 'need_second': False}\n}\n\ndef choiceFunction(store_obj:StatusStore):\n    res = ''\n    if function_map.get(store_obj.func_name):\n        res = function_map.get(store_obj.func_name)['function'](store_obj.msg)\n    return res </code></pre>\n<p>5、大致实现流程的想法是：</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\825f7e1da1b215893cf1903425c7df70.jpeg\"/></p>\n<p><br/> 对应代码实现：</p>\n<pre><code>def analyzeFriendMsg(self, data):\n    if data is None or data['type'] != 'FriendMessage':\n        return None, None, None\n    sender_id = data['sender']['id']\n    msg_type = data['messageChain'][-1]['type']\n    if msg_type == 'Plain':\n        msg_text = data['messageChain'][-1]['text']\n    elif msg_type == 'Image':\n        msg_text = data['messageChain'][-1]['url']\n    else:\n        msg_text = ''\n        return sender_id, msg_type, msg_text</code></pre>\n<p>最终的框架就是：</p>\n<pre><code>def xiaofengzai():\n    auth_key = '1234567890'     # settings.yml中的verifyKey\n    bind_qq = '3126229950'      # mirai登录的QQ\n    target_qq = '1061700625'    # 我们自己用的主QQ\n    target_qq = int(target_qq)  # 接收到的消息里，QQ是int类型的\n    sleep_time = 1              # 轮询间隔\n    status_store = {}\n\n    session = bot.verifySession(auth_key)\n    logger.DebugLog(\"&gt;&gt; session: \"+session)\n    bot.bindSession(session, bind_qq)\n    while True:\n        cnt = bot.getMessageCount(session)\n        if not cnt:\n            sleep(sleep_time)\n            continue\n        logger.DebugLog('&gt;&gt; 有消息了 =&gt; {}'.format(cnt))\n        logger.DebugLog('获取消息内容')\n        data = bot.fetchLatestMessage(session)\n        if len(data) == 0:\n            logger.DebugLog('消息为空')\n            sleep(sleep_time)\n            continue\n        logger.DebugLog(data)\n        logger.DebugLog('解析消息内容')\n\n        sender_id, msg_type, msg_text = bot.analyzeFriendMsg(data[0])\n        if not sender_id or sender_id != target_qq:\n            sleep(sleep_time)\n            continue\n\n        if msg_text.strip().lower().startswith('cmd'):\n            _, func_name = msg_text.strip().split('\\n')[0].split()\n            func_name = func_name.strip()\n            store_obj = StatusStore(from_qq=sender_id, is_cmd=True, func_name=func_name)\n            # 不需要发两次，直接调用函数返回结果即可\n            func_info = function_map.get(func_name)\n            if not func_info:\n                res = '指令[{}]暂不支持'.format(func_name)\n            elif func_info.get('need_second'):\n                res = '收到你的指令：{}\\n{}'.format(func_name, func_info.get('desc') or '已进入对应状态, 请继续发送详细内容')\n                # 添加或更新记录\n                status_store[sender_id] = store_obj\n            else:\n                res = '请求结果为：\\n' + str(choiceFunction(store_obj))\n                status_store.pop(sender_id, '')\n        else:\n            res = '请先发送指令哦...'\n            store_obj = status_store.get(sender_id)\n            if store_obj and store_obj.is_cmd:\n                store_obj.msg = msg_text\n                res = '请求结果为：\\n' + str(choiceFunction(store_obj))\n                status_store.pop(sender_id, '')\n        \n        bot.sendFriendMessage(session, qq=sender_id, msg=res)</code></pre>\n<p>看一下效果：</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\97186acee39ce74500db1c84548c185e.png\"/></p>\n<p><br/> 至此，骨架有了，接下来开始填充功能了。</p>\n<p><a name=\"PjnRQ\"></a></p>\n<p><a name=\"ci_title20\"></a></p>\n<h1 id=\"%E7%BF%BB%E8%AF%91%E6%9F%A5%E8%AF%A2\">翻译查询</h1>\n<p>根据上面的骨架可知，我们只需要实现<strong>MultiFunction类下的translate函数</strong>即可。如果想快速测试函数效果，可以使用以下代码，而不用先启动mirai：</p>\n<pre><code>res = choiceFunction(StatusStore(func_name='翻译', msg='你好'))\nprint(res)</code></pre>\n<p><a name=\"al111\"></a></p>\n<p><a name=\"ci_title21\"></a></p>\n<h2 id=\"%E9%A2%86%E5%8F%96%E8%85%BE%E8%AE%AF%E5%85%8D%E8%B4%B9%E7%BF%BB%E8%AF%91API\">领取腾讯免费翻译API</h2>\n<p>要做翻译，最方便的就是调用API了(没错，调包侠!)。<br/> 这里使用腾讯的翻译API，可以免费领取：<a href=\"https://curl.qcloud.com/HfOuxzXC\" title=\"领取腾讯翻译API\">领取腾讯翻译API</a>。点进链接后，往下拖到“<strong>云产品体验</strong>”专区，选择“<strong>人工智能</strong>”，下面有“<strong>机器翻译</strong>”。他的调用量是<strong>每月更新</strong>，非常的良心了。</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\59078a910f5f7bee1828aa2543c79a2f.png\"/></p>\n<p><br/> 点击“<strong>立即体验</strong>”，进入控制台界面，虽然上面显示的是“开通付费版”，但不用担心，他是有免费额度的，更何况你账户里又没充余额，哈哈哈。<br/><br/> 支持很多类型的翻译，这次我们先选<strong>文本翻译</strong>，<a href=\"https://cloud.tencent.com/document/product/551/15619\" title=\"机器翻译 文本翻译-API 文档-文档中心-腾讯云\">机器翻译 文本翻译-API 文档-文档中心-腾讯云</a>：<br/><br/> 我们用SDK的方式，免去了自己封装复杂的加密步骤：</p>\n<pre><code>pip install --upgrade tencentcloud-sdk-python</code></pre>\n<p>然后去获取密钥<a href=\"https://console.cloud.tencent.com/cam/capi\" title=\"API密钥管理\">API密钥管理</a>，记下<strong>APPID、SecretId、SecretKey</strong>：</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\0ce331e8b0dd438c956ccc8625fc8a16.png\"/></p>\n<p><br/><a name=\"gBEy7\"></a></p>\n<p><a name=\"ci_title22\"></a></p>\n<h2 id=\"%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%8E%A5%E5%85%A5%E7%BF%BB%E8%AF%91%E5%8A%9F%E8%83%BD\">机器人接入翻译功能</h2>\n<p>小锋仔bot结合翻译功能，直接上代码：</p>\n<pre><code>import json\nfrom tencentcloud.common import credential\nfrom tencentcloud.common.profile.client_profile import ClientProfile\nfrom tencentcloud.common.profile.http_profile import HttpProfile\nfrom tencentcloud.common.exception.tencent_cloud_sdk_exception import TencentCloudSDKException\nfrom tencentcloud.tmt.v20180321 import tmt_client, models\n\ndef translate(original:str, convert:str='en'):\n    secretId = 'xxx'  # 从API控制台获取\n    secretKey = 'xxx' # 从API控制台获取\n    AppId = 12123     # 从API控制台获取\n    try:\n        cred = credential.Credential(secretId, secretKey)\n        client = tmt_client.TmtClient(cred, \"ap-guangzhou\")\n        req = models.TextTranslateRequest()\n        params = {\n            \"SourceText\": original,\n            \"Source\": \"auto\",\n            \"Target\": convert,\n            \"ProjectId\": AppId\n        }\n        req.from_json_string(json.dumps(params))\n        resp = client.TextTranslate(req)\n        # print(resp.to_json_string())\n        return resp.TargetText\n    except TencentCloudSDKException as err:\n        print(err)\n        return ''</code></pre>\n<p>使用测试效果：</p>\n<pre><code>print(choiceFunction(StatusStore(func_name='翻译', msg='你好')))\n\n# 输出：\n{\"TargetText\": \"Hello\", \"Source\": \"zh\", \"Target\": \"en\", \"RequestId\": \"a1b17f47-751e-44cd-89a5-6a22e9f2c444\"}\nHello</code></pre>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\5b5dfed3c1c865fb457096d6bf8c122d.png\"/></p>\n<p><br/><a name=\"eoHrj\"></a></p>\n<p><a name=\"ci_title23\"></a></p>\n<h1 id=\"%E5%AE%9E%E6%97%B6%E5%A4%A9%E6%B0%94\">实时天气</h1>\n<p><a name=\"qFY33\"></a></p>\n<p><a name=\"ci_title24\"></a></p>\n<h2 id=\"%E9%A2%86%E5%8F%96%E5%85%8D%E8%B4%B9%E7%9A%84%E5%92%8C%E9%A3%8E%E5%A4%A9%E6%B0%94API\">领取免费的和风天气API</h2>\n<p>天气部分，我们是用免费的和风天气API：<a href=\"https://dev.qweather.com/docs/api/weather/weather-now/\" title=\"实时天气 - API\">实时天气 - API</a>。<br/> 首先也要进行登录并获取KEY，这个步骤官网讲的很详细，图文并茂的，这边就不多写了，大家可以跳转过去（注意我们选的是<strong>Web API</strong>）：<a href=\"https://dev.qweather.com/docs/resource/get-key/\" title=\"创建应用和KEY - RESOURCE\">创建应用和KEY - RESOURCE</a>。<br/><a name=\"lulNg\"></a></p>\n<p><a name=\"ci_title25\"></a></p>\n<h2 id=\"%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%8E%A5%E5%85%A5%E5%A4%A9%E6%B0%94%E5%8A%9F%E8%83%BD\">机器人接入天气功能</h2>\n<p>同样的，直接上代码：</p>\n<pre><code>def weather(city:str) -&gt; str:\n    url_api_weather = 'https://devapi.qweather.com/v7/weather/now?'\n    url_api_geo = 'https://geoapi.qweather.com/v2/city/lookup?'\n    weather_key = 'xxxxx'  # 和风天气控制台的key\n\n    # 实况天气\n    def getCityId(city_kw):\n        url_v2 = url_api_geo + 'location=' + city_kw + '&amp;key=' + weather_key\n        city = requests.get(url_v2).json()['location'][0]\n        return city['id']\n\n    city_name = '广州'\n    city_id = getCityId(city_name)\n    url = url_api_weather + 'location=' + city_id + '&amp;key=' + weather_key\n    res = requests.get(url).json()\n    text = \"&lt;天气信息获取失败&gt;\"\n    if res['code'] == '200' or res['code'] == 200:\n        text = '实时天气:\\n 亲爱的 小主, 您所在的地区为 {},\\n 现在的天气是 {},\\n 气温 {}°, 湿度 {}%,\\n 体感气温为 {}°,\\n 风向 {}, 风速 {}km/h'.format(\n            city_name, res['now']['text'], res['now']['temp'], res['now']['humidity'], res['now']['feelsLike'], res['now']['windDir'], res['now']['windSpeed']) \n    return text </code></pre>\n<p>测试效果：</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\3533aec59b95db13050912879a3e5c7b.png\"/></p>\n<p><br/><a name=\"Esngb\"></a></p>\n<p><a name=\"ci_title26\"></a></p>\n<h1 id=\"%E5%AE%9E%E6%97%B6%E7%83%AD%E6%90%9C\">实时热搜</h1>\n<p><a name=\"U6kSi\"></a></p>\n<p><a name=\"ci_title27\"></a></p>\n<h2 id=\"%E9%A2%86%E5%8F%96%E5%85%8D%E8%B4%B9%E7%9A%84%E5%A4%A9%E8%A1%8C%E7%83%AD%E6%90%9CAPI\">领取免费的天行热搜API</h2>\n<p>这部分用的是天行数据，免费会员每天赠送<strong>100次</strong>调用额度：<a href=\"https://www.tianapi.com/apiview/99\" title=\"今日头条新闻API接口 - 天行数据TianAPI\">今日头条新闻API接口 - 天行数据TianAPI</a>。先注册账号，然后点击“申请接口”即可。</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\4eb60234053140c22fcd299a6fa56abd.png\"/></p>\n<p><br/> 注意，首次注册需要在控制台完成“<strong>实名认证</strong>”和“<strong>邮箱验证</strong>”（马上通过，不需要等待审核）。<br/><br/> 对于密钥Key，是在“<strong>控制台-数据管理-我的密钥KEY</strong>”中。<br/><br/><a name=\"bNfdZ\"></a></p>\n<p><a name=\"ci_title28\"></a></p>\n<h2 id=\"%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%8E%A5%E5%85%A5%E7%83%AD%E6%90%9C%E5%8A%9F%E8%83%BD\">机器人接入热搜功能</h2>\n<p>同样的，直接上代码：</p>\n<pre><code>def hotNews(status_store:StatusStore) -&gt; str:\n    tianxing_key = 'e05966abe0b054686c9f6b7d60e59a8d'\n    def common(data):\n        url = data + '?key={}'.format(tianxing_key)\n        res = requests.get(url).json()\n        return res['newslist']\n    res = common('http://api.tianapi.com/topnews/index')\n    tops = []\n    index = 1\n    for item in res:\n        tops.append(str(index) + '. ' + item['title'])\n        index += 1\n        return '\\n'.join(tops[0:10])</code></pre>\n<p>测试效果：</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\8b74cbb3bea82fe39fa36422d6ceb484.png\"/></p>\n<p><br/><a name=\"bDpRK\"></a></p>\n<p><a name=\"ci_title29\"></a></p>\n<h1 id=\"%E7%85%A7%E7%89%87%E4%B8%8A%E4%BC%A0\">照片上传</h1>\n<p>有时候我们想保存一些照片，但又不想放手机里，那我们可以做个“<strong>通过把照片发给小锋仔机器人，让小锋仔再上传到服务器或者COS上</strong>”的功能。<br/><a name=\"gqHdd\"></a></p>\n<p><a name=\"ci_title30\"></a></p>\n<h2 id=\"%E9%A2%86%E5%8F%96%E8%85%BE%E8%AE%AF%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8COS\">领取腾讯对象存储COS</h2>\n<p>还是这个链接：<a href=\"https://curl.qcloud.com/HfOuxzXC\" title=\"云产品体验 - 腾讯云\">云产品体验 - 腾讯云</a>，在“<strong>云产品体验-基础-对象存储COS</strong>”下面。对象存储不止可以用来存文件，这里我们只用来存图片。</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\899492e5b1ce1d26cd7f10248f5280d4.png\"/></p>\n<ol><li>领取完成后，进入控制台，创建存储桶：</li></ol>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\2c359299b24b649825fd953ead350ea4.png\"/></p>\n<ol><li>配置存储桶信息，访问权限设置为“<strong>公有读私有写</strong>”，这样别人就能看到了，便于分享图片：</li></ol>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\e070593f20a50584bc05e44923852583.png\"/></p>\n<p><br/>  </p>\n<ol><li>创建完成后，就可以通过Python APi去控制上传了。不过需要先安装下SDK：</li></ol>\n<pre><code>pip install -U cos-python-sdk-v5</code></pre>\n<ol><li>上传图片部分，我们现在随便拿一张图测试：</li></ol>\n<pre><code>from qcloud_cos import CosConfig\nfrom qcloud_cos import CosS3Client\nimport os\n\ndef uploadImage(image_path:str) -&gt; str:\n    bucket_id = 'image-1253093297'  # 存储桶的名称\n    secret_id = 'xxx'\n    secret_key = 'xxx'\n    region = 'ap-guangzhou'  # 存储桶的地区\n    token = None              \n    scheme = 'https'          \n    config = CosConfig(Region=region, SecretId=secret_id, SecretKey=secret_key, Token=token, Scheme=scheme)\n    client = CosS3Client(config)\n    # 本地文件形式上传\n    # response = client.upload_file(\n    #     Bucket=bucket_id,\n    #     LocalFilePath=image_path,\n    #     Key=image_path.split(os.sep)[-1],\n    #     PartSize=1,\n    #     MAXThread=10,\n    #     EnableMD5=False\n    # )\n\n    # 网络文件形式上传\n    file_keyname = image_path.split('/')[-2] + '.jpg'\n    stream = requests.get(image_path)\n    response = client.put_object(\n        Bucket=bucket_id,\n        Body=stream,\n        Key=file_keyname\n    )\n    print(response['ETag'])\n    img_url = 'https://{}.cos.{}.myqcloud.com/{}'.format(bucket_id, region, file_keyname)\n    return '上传成功, ETag: {}\\nURL: {}'.format(response['ETag'], img_url)</code></pre>\n<ol><li>上传完成后，在控制台就可以看到了。</li></ol>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\a3712d1ed5c9a1c124d5da629aee2a33.png\"/></p>\n<ol><li>更多cos操作可看官方文档：<a href=\"https://cloud.tencent.com/document/product/436/12269\" title=\"对象存储 快速入门-SDK 文档-文档中心-腾讯云\">对象存储 快速入门-SDK 文档-文档中心-腾讯云</a><br/><a name=\"lhA7g\"></a></li></ol>\n<p><a name=\"ci_title31\"></a></p>\n<h2 id=\"%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%8E%A5%E5%85%A5%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%8A%9F%E8%83%BD\">机器人接入图片上传功能</h2>\n<p>通过mirai文档可知，图片消息格式为：</p>\n<pre><code>[{'type': 'FriendMessage', 'messageChain': [{'type': 'Source', 'id': 55312, 'time': 1662048857}, {'type': 'Image', 'imageId': '{DCAD8B29-D606-B354-117D-F39479C14FE3}.jpg', 'url': 'http://c2cpicdw.qpic.cn/offpic_new/1061700625//1061700625-141936558-DCAD8B29D606B354117DF39479C14FE3/0?term=2', 'path': None, 'base64': None}], 'sender': {'id': 1061700625, 'nickname': '热心市民', 'remark': '热心市民'}}]</code></pre>\n<p>因此只需要拿到里面的URL就行，而我们的analyzeFriendMsg函数就已经提取了URl了，因此<strong>啥都不用多改</strong>！！（结构好，就是方便呀~）<br/> 直接测试：</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\3d5d507cc44ec0c1f58df6e7f6356af5.png\"/></p>\n<p><a name=\"VCL24\"></a></p>\n<p><a name=\"ci_title32\"></a></p>\n<h1 id=\"%E8%87%AA%E8%A1%8C%E6%B7%BB%E5%8A%A0%E5%B0%8F%E5%8A%9F%E8%83%BD%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93\">自行添加小功能函数总结</h1>\n<p>通过上面几个小功能，不难发现我们的程序在功能上很方便扩展，总结一下，<strong>就2步</strong>：</p>\n<ol><li>在<strong>MultiFunction</strong>类中添加功能函数的实现，入参尽量为<strong>字符串型</strong>，返回也为<strong>字符串型</strong>；</li><li>在<strong>function_map</strong>中添加函数信息；</li></ol>\n<p>下面提供几个好玩的接口，给大家留个作业，自己集成到机器人中去：</p>\n<pre><code># 疫情信息\ndef getYiQing():\n    url = 'https://c.m.163.com/ug/api/wuhan/app/data/list-total?t={}'.format(329091037164)\n    headers = {\n        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) '\n                      'Chrome/96.0.4664.110 Safari/537.36 '\n    }\n    res = requests.get(url, headers=headers).json()\n    total = res['data']['chinaTotal']['total']\n    today = res['data']['chinaTotal']['today']\n    a = 99\n    symbol_today = '＋' if today['confirm'] &gt;= 0 else ''\n    symbol_total = '＋' if today['storeConfirm'] &gt;= 0 else ''\n    symbol_input = '＋' if today['input'] &gt;= 0 else ''\n    confirmTotal = '累计确诊：{}，较昨日：{}{}'.format(total['confirm'], symbol_today, today['confirm'])\n    confirmToday = '现有确诊：{}，较昨日：{}{}'.format(total['confirm'] - total['dead'] - total['heal'], symbol_total, today['storeConfirm'])\n    inputs = '境外输入：{}，较昨日：{}{}'.format(total['input'], symbol_input, today['input'])\n    return inputs + '\\n' + confirmToday + '\\n' + confirmTotal\n\n# 历史上的今天\ndef getHistoryToday():\n    url = 'https://api.oick.cn/lishi/api.php'\n    res = requests.get(url).json()\n    historyToday = []\n    for item in res['result']:\n        historyToday.append(item['date'] + ', ' + item['title'])\n    return '\\n'.join(random.choices(historyToday, k=3))\n\n# 一言\ndef dailysentence():\n    url = 'https://res.abeim.cn/api-text_yiyan'\n    res = requests.get(url).json()\n    return res['content']\n\n# 天行api\ndef common(data):\n    tianxing_key = ''  # 天行key\n    url = data + '?key={}'.format(tianxing_key)\n    res = requests.get(url).json()\n    return res['newslist']\n\n# 天行api - 小窍门\ndef dailyTips():\n    res = common('http://api.tianapi.com/qiaomen/index')\n    tipsArray = res[0]\n    return tipsArray['content']\n\n# 天行api - 健康小知识\ndef healthTips():\n    res = common('http://api.tianapi.com/healthtip/index')\n    tipsArray = res[0]\n    return tipsArray['content']</code></pre>\n<p>如果以后功能越来越多，我们很容易记不住关键词是啥，因此，稍稍变动一下，让我们可以知道功能清单。在<strong>xiaofengzai</strong>函数这个位置添加一段代码：</p>\n<pre><code>if msg_text.strip() == '功能清单':\n    res = '目前支持的关键词有：\\n' + '\\n'.join(function_map.keys())</code></pre>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\b47cf5136fbaa3bc29a9a3563099a208.png\"/></p>\n<p><br/><br/><a name=\"kK75q\"></a></p>\n<p><a name=\"ci_title33\"></a></p>\n<h1 id=\"%E6%8E%A7%E5%88%B6%E6%A0%91%E8%8E%93%E6%B4%BE%E8%88%B5%E6%9C%BA%E4%B8%8E%E5%B1%8F%E6%98%BE\">控制树莓派舵机与屏显</h1>\n<p>这部分摘自我前面的博客：</p>\n<ul><li><a href=\"https://blog.csdn.net/sxf1061700625/article/details/112060685\" title=\"4步实现树莓派人脸识别、拍照与推送、舵机旋转\">4步实现树莓派人脸识别、拍照与推送、舵机旋转</a></li><li><a href=\"https://blog.csdn.net/sxf1061700625/article/details/117880520\" title=\"QQ控制树莓派(舵机+摄像头+...)\">QQ控制树莓派(舵机+摄像头+...)</a></li><li><a href=\"https://blog.csdn.net/sxf1061700625/article/details/120567880\" title=\"树莓派4B驱动1.8寸ST7735S TFT屏幕\">树莓派4B驱动1.8寸ST7735S TFT屏幕</a></li></ul>\n<p>与树莓派的主要交互，这里主要有两种方式：</p>\n<ul><li><strong>树莓派上也运行mirai</strong>。通过设置不同的protocol，是可以实现同时在线的。</li><li><strong>通过MQTT通信</strong>。这个比较好用，是个物联网协议，广泛适用于IoT场景，推荐。</li></ul>\n<p>我的另一个大型项目“<a href=\"https://blog.csdn.net/sxf1061700625/article/details/124138633\" title=\"基于树莓派的智能魔镜\">基于树莓派的智能魔镜</a>”，它里面树莓派与手机的通信，就是通过MQTT实现的。很贴心的，B站还有配套的视频教程，欢迎来踩，哈哈哈~<a href=\"https://space.bilibili.com/37064895?\" title=\"小锋学长生活大爆炸的个人空间\">小锋学长生活大爆炸的个人空间</a>。</p>\n<hr/>\n<p><a name=\"VDCyD\"></a></p>\n<p><a name=\"ci_title34\"></a></p>\n<h2 id=\"%E8%85%BE%E8%AE%AF%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BAMQTT%E7%8E%AF%E5%A2%83\">腾讯云服务器搭建MQTT环境</h2>\n<p>树莓派由于不在身边，因此这部分暂时先略过，大家可以通过上面几篇博客自学一下，他们也都是使用到了mirai的。这里讲一下MQTT的安装，也可以参考<a href=\"https://blog.csdn.net/sxf1061700625/article/details/121265658#%E5%AE%89%E8%A3%85Mosquitto%20MQTT\" title=\"安装EMQX MQTT\">安装EMQX MQTT</a>。</p>\n<ol><li>SSH进入我们的服务器后，输入指令：</li></ol>\n<pre><code>sudo apt-add-repository ppa:mosquitto-dev/mosquitto-ppa\nsudo apt-get update\nsudo apt-get install mosquitto\nsudo apt-get install mosquitto-clients\nsudo apt clean</code></pre>\n<ol><li>然后去腾讯云控制台开放下<strong>1883</strong>端口。</li><li>再在防火墙软件上也放行下1883端口</li></ol>\n<pre><code>sudo firewall-cmd --permanent --zone=public --add-port=1883/tcp &amp;&amp; sudo firewall-cmd --reload\nsudo systemctl start firewalld.service</code></pre>\n<ol><li>通过Python调用MQTT的示例可以参考：<a href=\"https://blog.csdn.net/sxf1061700625/article/details/97920856\" title=\"Python MQTT\">Python MQTT</a>。</li><li>想了解学习MQTT概念的可以参考：<a href=\"https://blog.csdn.net/sxf1061700625/article/details/88574414\" title=\"MQTT V3.1协议规范\">MQTT V3.1协议规范</a>。</li><li> <p>更多MQTT使用示例可以参考：</p>\n<ol><li><a href=\"https://blog.csdn.net/sxf1061700625/article/details/109697345\" title=\"Ubuntu18和Raspbian搭建LAMP环境+部署图片上传网页+安装Mosquitto\">Ubuntu18和Raspbian搭建LAMP环境+部署图片上传网页+安装Mosquitto</a></li><li><a href=\"https://blog.csdn.net/sxf1061700625/article/details/104321104\" title=\"纯JavaScript实现的MQTT智能门锁\">纯JavaScript实现的MQTT智能门锁</a></li><li><a href=\"https://blog.csdn.net/sxf1061700625/article/details/113097111?\" title=\"Qt搭建MQTT环境\">Qt搭建MQTT环境</a></li></ol></li></ol>\n<p><a name=\"t3MMQ\"></a></p>\n<p><a name=\"ci_title35\"></a></p>\n<h1 id=\"%E5%BE%85%E5%AE%9E%E7%8E%B0%E5%8A%9F%E8%83%BD\">待实现功能</h1>\n<p><a name=\"vR5ib\"></a></p>\n<p><a name=\"ci_title36\"></a></p>\n<h2 id=\"%E6%8E%A5%E5%85%A5%E6%8E%A7%E5%88%B6ESP32(%E5%AE%9E%E7%8E%B0%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85%E6%8E%A7%E5%88%B6)\">接入控制ESP32(实现智能家居控制)</h2>\n<p>ESP32是一块可以链接WIFI的嵌入式开发板，支持MQTT协议。这样一来，只要通过跟我们的机器人互相订阅Topic，在通过设计一套通信协议，就可以实现远程交互了。进一步地，给ESP32接入外设，就可以很容易的实现一个智能家居，而我们则可以通过QQ机器人来实现对智能家居的控制。</p>\n<p><a name=\"qor6q\"></a></p>\n<p><a name=\"ci_title37\"></a></p>\n<h1 id=\"%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%E6%95%B4%E7%90%86\">完整代码整理</h1>\n<p>为了方便，我们把所有需要修改的变量，都统一提取到了最前面。大家在复制过程中，<strong>务必记得都填上自己的</strong>！！<br/> ![Q073C@O[}BS4ON(A]H$C_YX.png](<a href=\"https://cdn.nlark.com/yuque/0/2022/png/21876370/1662051010396-4111cadd-c0f7-444e-88bf-f5ab77abd9c1.png#clientId=u1cf12aa3-c8f3-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=547&amp;id=u1448e26e&amp;margin=%5Bobject%20Object%5D&amp;name=Q073C%40O%5B%7DBS4ON%28A%5DH%24C_YX.png&amp;originHeight=903&amp;originWidth=1013&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=46750&amp;status=done&amp;style=none&amp;taskId=ud48045de-328e-4049-870b-8561bc1feb4&amp;title=&amp;width=614\" title=\"https://cdn.nlark.com/yuque/0/2022/png/21876370/1662051010396-4111cadd-c0f7-444e-88bf-f5ab77abd9c1.png#clientId=u1cf12aa3-c8f3-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=547&amp;id=u1448e26e&amp;margin=%5Bobject%20Object%5D&amp;name=Q073C%40O%5B%7DBS4ON%28A%5DH%24C_YX.png&amp;originHeight=903&amp;originWidth=1013&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=46750&amp;status=done&amp;style=none&amp;taskId=ud48045de-328e-4049-870b-8561bc1feb4&amp;title=&amp;width=614\">https://cdn.nlark.com/yuque/0/2022/png/21876370/1662051010396-4111cadd-c0f7-444e-88bf-f5ab77abd9c1.png#clientId=u1cf12aa3-c8f3-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=547&amp;id=u1448e26e&amp;margin=%5Bobject%20Object%5D&amp;name=Q073C%40O%5B%7DBS4ON%28A%5DH%24C_YX.png&amp;originHeight=903&amp;originWidth=1013&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=46750&amp;status=done&amp;style=none&amp;taskId=ud48045de-328e-4049-870b-8561bc1feb4&amp;title=&amp;width=614</a>)<br/> 最后，贴上完整代码。由于水平有限，写的可能不是很好。也欢迎大家DIY魔改成自己的。如果有问题，欢迎加入<strong>文末Q群</strong>一起交流~~~</p>\n<pre><code>import json\nimport os\n\nimport requests\nfrom flask import Flask, request\nfrom time import sleep\nimport threading\nimport json\nfrom tencentcloud.common import credential\nfrom tencentcloud.common.profile.client_profile import ClientProfile\nfrom tencentcloud.common.profile.http_profile import HttpProfile\nfrom tencentcloud.common.exception.tencent_cloud_sdk_exception import TencentCloudSDKException\nfrom tencentcloud.tmt.v20180321 import tmt_client, models\nimport requests\nfrom qcloud_cos import CosConfig\nfrom qcloud_cos import CosS3Client\n\n\n# ---------------------------- 变量定义区 ---------------------------- #\n# 自己运行mirai的服务器IP和mirai-api-http的监听端口\nmirai_server_url = 'http://43.143.12.250:8888/'\n# settings.yml中的verifyKey\nauth_key = '1234567890'     \n# mirai登录的QQ\nbind_qq = 'xxx'      \n# 我们自己用的主QQ。接收到的消息里，QQ是int类型的\ntarget_qq = 123123\n\n# 腾讯COS存储桶的名称\ntencent_cos_bucket_id = 'xxx'  \n# 腾讯COS存储桶的地区\ntencent_cos_region = 'ap-guangzhou'  \n# 腾讯控制台的SecretId\ntencent_secret_id = 'xxx'\n# 腾讯控制台的SecretKey\ntencent_secret_key = 'xxx'\n# 腾讯机器翻译的appid\ntencent_translate_AppId = xxx\n# 和风天气API的key\nweather_key = 'xxx'\n# 天行API的key\ntianxing_key = 'xxx'\n# ------------------------------------------------------------------ #\n\n\nclass Logger:\n    def __init__(self, level='debug'):\n        self.level = level\n\n    def DebugLog(self, *args):\n        if self.level == 'debug':\n            print(*args)\n\n    def TraceLog(self, *args):\n        if self.level == 'trace':\n            print(*args)\n\n    def setDebugLevel(self, level):\n        self.level = level.lower()\n\n\nclass QQBot:\n    def __init__(self):\n        self.addr = mirai_server_url\n        self.session = None\n\n    def verifySession(self, auth_key):\n        \"\"\"每个Session只能绑定一个Bot，但一个Bot可有多个Session。\n        session Key在未进行校验的情况下，一定时间后将会被自动释放\"\"\"\n        data = {\"verifyKey\": auth_key}\n        url = self.addr+'verify'\n        res = requests.post(url, data=json.dumps(data)).json()\n        logger.DebugLog(res)\n        if res['code'] == 0:\n            return res['session']\n        return None\n\n    def bindSession(self, session, qq):\n        \"\"\"校验并激活Session，同时将Session与一个已登录的Bot绑定\"\"\"\n        data = {\"sessionKey\": session, \"qq\": qq}\n        url = self.addr + 'bind'\n        res = requests.post(url, data=json.dumps(data)).json()\n        logger.DebugLog(res)\n        if res['code'] == 0:\n            self.session = session\n            return True\n        return False\n\n    def releaseSession(self, session, qq):\n        \"\"\"不使用的Session应当被释放，长时间（30分钟）未使用的Session将自动释放，\n        否则Session持续保存Bot收到的消息，将会导致内存泄露(开启websocket后将不会自动释放)\"\"\"\n        data = {\"sessionKey\": session, \"qq\": qq}\n        url = self.addr + 'release'\n        res = requests.post(url, data=json.dumps(data)).json()\n        logger.DebugLog(res)\n        if res['code'] == 0:\n            return True\n        return False\n\n    def fetchLatestMessage(self, session):\n        url = self.addr + 'fetchLatestMessage?count=10&amp;sessionKey='+session\n        res = requests.get(url).json()\n        if res['code'] == 0:\n            return res['data']\n        return None\n\n\n    def parseGroupMsg(self, data):\n        res = []\n        if data is None:\n            return res\n        for item in data:\n            if item['type'] == 'GroupMessage':\n                type = item['messageChain'][-1]['type']\n                if type == 'Image':\n                    text = item['messageChain'][-1]['url']\n                elif type == 'Plain':\n                    text = item['messageChain'][-1]['text']\n                elif type == 'Face':\n                    text = item['messageChain'][-1]['faceId']\n                else:\n                    logger.TraceLog(\"&gt;&gt; 当前消息类型暂不支持转发：=&gt; \"+type)\n                    continue\n                name = item['sender']['memberName']\n                group_id = str(item['sender']['group']['id'])\n                group_name = item['sender']['group']['name']\n                res.append({'text': text, 'type': type, 'name': name, 'groupId': group_id, 'groupName': group_name})\n        return res\n\n    def getMessageCount(self, session):\n        url = self.addr + 'countMessage?sessionKey='+session\n        res = requests.get(url).json()\n        if res['code'] == 0:\n            return res['data']\n        return 0\n\n    def peekMessage(self, session):\n        url = self.addr + 'peekMessage?sessionKey='+session\n        res = requests.get(url).json()\n        if res['code'] == 0:\n            return res['data']\n        return 0\n\n    def sendPlainTextToGroup(self, session, group, msg):\n        msg_list = msg.split(r'\\n')\n        msg_chain = [{ \"type\": \"Plain\", \"text\": m+'\\n' } for m in msg_list]\n        data = {\n          \"sessionKey\": session,\n          \"group\": group,\n          \"messageChain\": msg_chain\n        }\n        url = self.addr + 'sendGroupMessage'\n        try:\n            res = requests.post(url, data=json.dumps(data)).json()\n        except:\n            logger.DebugLog(\"&gt;&gt; 转发失败\")\n            return 0\n        logger.DebugLog(\"&gt;&gt; 请求返回：\" + str(res))\n        if res['code'] == 0:\n            return res['messageId']\n        return 0\n\n    def sendMsgToGroup(self, session, group, msg):\n        text = msg['text']\n        type = msg['type']\n        name = msg['name']\n        group_id = msg['groupId']\n        group_name = msg['groupName']\n        content1 = \"【消息中转助手】\\n用户：{}\\n群号：{}\\n群名：{}\\n消息：\\n{}\".format(\n            name, group_id, group_name, text)\n        content2 = \"【消息中转助手】\\n用户：{}\\n群号：{}\\n群名：{}\\n消息：\\n\".format(\n            name, group_id, group_name)\n        logger.DebugLog(\"&gt;&gt; 消息类型：\" + type)\n        if type == 'Plain':\n            message = [{\"type\": type, \"text\": content1}]\n        elif type == 'Image':\n            message = [\n                {\"type\": 'Plain', \"text\": content2},\n                {\"type\": type, \"url\": text}]\n        elif type == 'Face':\n            message = [{\"type\": 'Plain', \"text\": content2},\n                       {\"type\": type, \"faceId\": text}]\n        else:\n            logger.TraceLog(\"&gt;&gt; 当前消息类型暂不支持转发：=&gt; \"+type)\n            return 0\n        data = {\n                \"sessionKey\": session,\n                \"group\": group,\n                \"messageChain\": message\n                }\n        logger.DebugLog(\"&gt;&gt; 消息内容：\" + str(data))\n        url = self.addr + 'sendGroupMessage'\n        try:\n            res = requests.post(url, data=json.dumps(data)).json()\n        except:\n            logger.DebugLog(\"&gt;&gt; 转发失败\")\n            return 0\n        logger.DebugLog(\"&gt;&gt; 请求返回：\" + str(res))\n        if res['code'] == 0:\n            return res['messageId']\n        return 0\n\n    def sendMsgToAllGroups(self, session, receive_groups, send_groups, msg_data):\n        # 对每条消息进行检查\n        for msg in msg_data:\n            group_id = msg['groupId']\n            # 接收的消息群正确（目前只支持 消息类型）\n            if group_id in receive_groups:\n                # 依次将消息转发到目标群\n                for g in send_groups:\n                    logger.DebugLog(\"&gt;&gt; 当前群：\"+g)\n                    if g == group_id:\n                        logger.DebugLog(\"&gt;&gt; 跳过此群\")\n                        continue\n                    res = self.sendMsgToGroup(session, g, msg)\n                    if res != 0:\n                        logger.TraceLog(\"&gt;&gt; 转发成功！{}\".format(g))\n\n    def sendFriendMessage(self, session, qq, msg):\n        msg_list = msg.split(r'\\n')\n        msg_chain = [{ \"type\": \"Plain\", \"text\": m+'\\n' } for m in msg_list]\n\n        data = {\n          \"sessionKey\": session,\n          \"target\": qq,\n          \"messageChain\": msg_chain\n        }\n        url = self.addr + 'sendFriendMessage'\n        try:\n            res = requests.post(url, data=json.dumps(data)).json()\n        except:\n            logger.DebugLog(\"&gt;&gt; 发送失败\")\n            return 0\n        if res['code'] == 0:\n            return res['messageId']\n        return 0\n\n\n    def analyzeFriendMsg(self, data):\n        if data is None or data['type'] != 'FriendMessage':\n            return None, None, None\n        sender_id = data['sender']['id']\n        msg_type = data['messageChain'][-1]['type']\n        if msg_type == 'Plain':\n            msg_text = data['messageChain'][-1]['text']\n        elif msg_type == 'Image':\n            msg_text = data['messageChain'][-1]['url']\n        else:\n            msg_text = ''\n        return sender_id, msg_type, msg_text\n\n\n\n\nlogger = Logger()\nbot = QQBot()\napp = Flask(__name__)\n\ndef qqTransfer():\n    with open('conf.json', 'r+', encoding=\"utf-8\") as f:\n        content = f.read()\n    conf = json.loads(content)\n\n    auth_key = conf['auth_key']\n    bind_qq = conf['bind_qq']\n    sleep_time = conf['sleep_time']\n    debug_level = conf['debug_level']\n\n    receive_groups = conf['receive_groups']\n    send_groups = conf['send_groups']\n\n    logger.setDebugLevel(debug_level)\n\n    session = bot.verifySession(auth_key)\n    logger.DebugLog(\"&gt;&gt; session: \"+session)\n    bot.bindSession(session, bind_qq)\n    while True:\n        cnt = bot.getMessageCount(session)\n        if cnt:\n            logger.DebugLog('&gt;&gt; 有消息了 =&gt; {}'.format(cnt))\n            logger.DebugLog('获取消息内容')\n            data = bot.fetchLatestMessage(session)\n            if len(data) == 0:\n                logger.DebugLog('消息为空')\n                continue\n            logger.DebugLog(data)\n            logger.DebugLog('解析消息内容')\n            data = bot.parseGroupMsg(data)\n            logger.DebugLog(data)\n            logger.DebugLog('转发消息内容')\n            bot.sendMsgToAllGroups(session, receive_groups, send_groups, data)\n        # else:\n        #     logger.DebugLog('空闲')\n        sleep(sleep_time)\n    bot.releaseSession(session, bind_qq)\n\n\n\n\n\nclass StatusStore:\n    def __init__(self, from_qq:int=None, is_cmd:bool=False, func_name:str=None, need_second:bool=False, msg:str=None) -&gt; None:\n        self.from_qq = from_qq          # 发送者的QQ号\n        self.is_cmd = is_cmd            # 是否是指令(选择功能)\n        self.func_name = func_name      # 选择的功能的名称\n        self.need_second = need_second  # 是否需要经过两步：先发cmd指令，再发详细内容\n        self.msg = msg                  # 本次发送的消息内容\n    \n    def detail(self):\n        return self.__dict__\n\nclass MultiFunction:\n    \"\"\"多功能函数集合\"\"\"\n    def __init__(self) -&gt; None:\n        pass\n\n    @staticmethod\n    def translate(original:str, convert:str='en'):\n        try:\n            cred = credential.Credential(tencent_secret_id, tencent_secret_key)\n            client = tmt_client.TmtClient(cred, \"ap-guangzhou\")\n            req = models.TextTranslateRequest()\n            params = {\n                \"SourceText\": original,\n                \"Source\": \"auto\",\n                \"Target\": convert,\n                \"ProjectId\": tencent_translate_AppId\n            }\n            req.from_json_string(json.dumps(params))\n            resp = client.TextTranslate(req)\n            # print(resp.to_json_string())\n            return resp.TargetText\n        except TencentCloudSDKException as err:\n            print(err)\n        return ''\n    \n    @staticmethod\n    def uploadImage(image_path:str) -&gt; str:\n        token = None              \n        scheme = 'https'          \n        config = CosConfig(Region=tencent_cos_region, SecretId=tencent_secret_id, SecretKey=tencent_secret_key, Token=token, Scheme=scheme)\n        client = CosS3Client(config)\n        # 本地文件形式上传\n        # response = client.upload_file(\n        #     Bucket=bucket_id,\n        #     LocalFilePath=image_path,\n        #     Key=image_path.split(os.sep)[-1],\n        #     PartSize=1,\n        #     MAXThread=10,\n        #     EnableMD5=False\n        # )\n\n        # 网络文件形式上传\n        file_keyname = image_path.split('/')[-2] + '.jpg'\n        stream = requests.get(image_path)\n        response = client.put_object(\n            Bucket=tencent_cos_bucket_id,\n            Body=stream,\n            Key=file_keyname\n        )\n        print(response['ETag'])\n        img_url = 'https://{}.cos.{}.myqcloud.com/{}'.format(tencent_cos_bucket_id, tencent_cos_region, file_keyname)\n        return '上传成功, ETag: {}\\nURL: {}'.format(response['ETag'], img_url)\n\n    @staticmethod\n    def weather(city_name:str='广州') -&gt; str:\n        url_api_weather = 'https://devapi.qweather.com/v7/weather/now?'\n        url_api_geo = 'https://geoapi.qweather.com/v2/city/lookup?'\n        \n        # 实况天气\n        def getCityId(city_kw):\n            url_v2 = url_api_geo + 'location=' + city_kw + '&amp;key=' + weather_key\n            city = requests.get(url_v2).json()['location'][0]\n            return city['id']\n\n        city_id = getCityId(city_name)\n        url = url_api_weather + 'location=' + city_id + '&amp;key=' + weather_key\n        res = requests.get(url).json()\n        text = \"&lt;天气信息获取失败&gt;\"\n        print(res)\n        if res['code'] == '200' or res['code'] == 200:\n            text = '实时天气:\\n 亲爱的 小主, 您所在的地区为 {},\\n 现在的天气是 {},\\n 气温 {}°, 湿度 {}%,\\n 体感气温为 {}°,\\n 风向 {}, 风速 {}km/h'.format(\n                city_name, res['now']['text'], res['now']['temp'], res['now']['humidity'], res['now']['feelsLike'], res['now']['windDir'], res['now']['windSpeed']) \n        return text \n    \n    @staticmethod\n    def hotNews(status_store:StatusStore) -&gt; str:\n        def common(data):\n            url = data + '?key={}'.format(tianxing_key)\n            res = requests.get(url).json()\n            return res['newslist']\n        res = common('http://api.tianapi.com/topnews/index')\n        tops = []\n        index = 1\n        for item in res:\n            tops.append(str(index) + '. ' + item['title'])\n            index += 1\n        return '\\n'.join(tops[0:10])\n\n\n\n\n\n\n# 多功能函数的映射\n# function: 功能对应函数名\n# need_second: 是否需要经过两步：先发cmd指令，再发详细内容\n# desc: 需要经过两步时，第一次返回的提示语\nfunction_map = {\n    '翻译': {'function': MultiFunction.translate, 'need_second': True, 'desc': '请输入您要翻译的内容~'}, \n    '天气': {'function': MultiFunction.weather, 'need_second': True, 'desc': '请问是哪座城市的天气呢？'}, \n    '热搜': {'function': MultiFunction.hotNews, 'need_second': False},\n    '上传图片': {'function': MultiFunction.uploadImage, 'need_second': True, 'desc': '请发送图片过来吧~'},\n}\ndef choiceFunction(store_obj:StatusStore):\n    res = ''\n    if function_map.get(store_obj.func_name):\n        res = function_map.get(store_obj.func_name)['function'](store_obj.msg)\n    return res \n\n\n\n\n\n\ndef xiaofengzai():\n    sleep_time = 1              # 轮询间隔\n    status_store = {}\n\n    session = bot.verifySession(auth_key)\n    logger.DebugLog(\"&gt;&gt; session: \"+session)\n    bot.bindSession(session, bind_qq)\n    while True:\n        cnt = bot.getMessageCount(session)\n        if not cnt:\n            sleep(sleep_time)\n            continue\n        logger.DebugLog('&gt;&gt; 有消息了 =&gt; {}'.format(cnt))\n        logger.DebugLog('获取消息内容')\n        data = bot.fetchLatestMessage(session)\n        if len(data) == 0:\n            logger.DebugLog('消息为空')\n            sleep(sleep_time)\n            continue\n        logger.DebugLog(data)\n        logger.DebugLog('解析消息内容')\n\n        sender_id, msg_type, msg_text = bot.analyzeFriendMsg(data[0])\n        if not sender_id or sender_id != target_qq:\n            sleep(sleep_time)\n            continue\n\n        if msg_text.strip() == '功能清单':\n            res = '目前支持的关键词有：\\n' + '\\n'.join(function_map.keys())\n        elif msg_text.strip().lower().startswith('cmd'):\n            _, func_name = msg_text.strip().split('\\n')[0].split()\n            func_name = func_name.strip()\n            store_obj = StatusStore(from_qq=sender_id, is_cmd=True, func_name=func_name)\n            # 不需要发两次，直接调用函数返回结果即可\n            func_info = function_map.get(func_name)\n            if not func_info:\n                res = '指令[{}]暂不支持'.format(func_name)\n            elif func_info.get('need_second'):\n                res = '收到你的指令：{}\\n{}'.format(func_name, func_info.get('desc') or '已进入对应状态, 请继续发送详细内容')\n                # 添加或更新记录\n                status_store[sender_id] = store_obj\n            else:\n                res = '请求结果为：\\n' + str(choiceFunction(store_obj))\n                status_store.pop(sender_id, '')\n        else:\n            res = '请先发送指令哦...'\n            store_obj = status_store.get(sender_id)\n            if store_obj and store_obj.is_cmd:\n                store_obj.msg = msg_text\n                res = '请求结果为：\\n' + str(choiceFunction(store_obj))\n                status_store.pop(sender_id, '')\n        \n        bot.sendFriendMessage(session, qq=sender_id, msg=res)\n\n        \n\n\n@app.route('/QQ/send', methods=['GET'])\ndef qqListenMsg():\n    # 类似于Qmsg的功能\n    # flask做得接收HTTP请求转为QQ消息\n    qq = request.args.get('target', None)\n    msg = request.args.get('msg', None)\n    bot.sendFriendMessage(bot.session, qq, msg)\n    return 'Hello World!'\n\n@app.route('/QQ/send/friend', methods=['GET'])\ndef qqListenMsgToFriend():\n    # 类似于Qmsg的功能\n    # flask做得接收HTTP请求转为QQ消息\n    qq = request.args.get('target', None)\n    msg = request.args.get('msg', None)\n    bot.sendFriendMessage(bot.session, qq, msg)\n    return 'Hello World! Friend!'\n\n@app.route('/QQ/send/group', methods=['GET'])\ndef qqListenMsgToGroup():\n    # 类似于Qmsg的功能\n    # flask做得接收HTTP请求转为QQ消息\n    qq = request.args.get('target', None)\n    msg = request.args.get('msg', None)\n    bot.sendPlainTextToGroup(bot.session, qq, msg)\n    return 'Hello World! Group!'\n\n\nif __name__ == '__main__':\n    t = threading.Thread(target=xiaofengzai)\n    t.setDaemon(True)\n    t.start()\n\n    # t = threading.Thread(target=qqTransfer)\n    # t.setDaemon(True)\n    # t.start()\n\n    app.run(port='9966', host='0.0.0.0')</code></pre>\n<p></p>\n</div>\n</div>"}