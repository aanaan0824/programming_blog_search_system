{"blogid": "124978166", "writerAge": "码龄4年", "writerBlogNum": "567", "writerCollect": "2687", "writerComment": "216", "writerFan": "4965", "writerGrade": "7级", "writerIntegral": "14344", "writerName": "努 力 小 子", "writerProfileAdress": "writer_image\\profile_124978166.jpg", "writerRankTotal": "792", "writerRankWeekly": "3834", "writerThumb": "1112", "writerVisitNum": "1278442", "blog_read_count": "4828", "blog_time": "已于 2022-05-27 09:00:56 修改", "blog_title": "Redis消息队列——Redis Stream", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-tomorrow-night-eighties\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p></p>\n<div class=\"toc\">\n<h3>文章目录</h3>\n<ul><li><a href=\"#_1\">消息队列</a></li><li><a href=\"#Redis__pubsub__18\">为什么不使用Redis 发布订阅 (pub/sub) 来实现消息队列</a></li><li><a href=\"#Stream_26\">Stream</a></li><li><ul><li><a href=\"#_35\">消息队列相关命令：</a></li><li><a href=\"#_45\">消费者组相关命令：</a></li></ul>\n</li><li><a href=\"#Stream_60\">Stream最简单的生产、消费模型</a></li><li><a href=\"#Stream__65\">Stream 优点/改进</a></li><li><ul><li><a href=\"#Stream__67\">Stream 支持「阻塞式」拉取消息</a></li><li><a href=\"#___73\">支持发布 / 订阅模式</a></li><li><ul><li><a href=\"#XADD_key_ID_field_value_field_value__78\">XADD key ID field value [field value ...]</a></li></ul>\n</li><li><a href=\"#Stream__136\">Stream 能保证消息不丢失，重新消费</a></li><li><a href=\"#Stream__RDB__AOF__147\">Stream 数据会写入到 RDB 和 AOF 做持久化</a></li><li><a href=\"#Stream_150\">消息堆积时，Stream的处理</a></li></ul>\n</li><li><a href=\"#_169\">专业的消息队列</a></li></ul>\n</div>\n<p></p>\n<h1><a id=\"_1\"></a>消息队列</h1>\n<p>“消息队列”是在消息的传输过程中保存消息的容器。“消息”是在两台计算机间传送的数据单位。消息队列管理器在将消息从它的源中继到它的目标时充当中间人。队列的主要目的是提供路由并保证消息的传递；如果发送消息时接收者不可用，消息队列会保留消息，直到可以成功地传递它。<br/> 当我们在使用一个消息队列时，希望它的功能如下：</p>\n<pre><code class=\"prism language-sql\">支持阻塞等待拉取消息\n支持发布 <span class=\"token operator\">/</span> 订阅模式\n消费失败，可重新消费，消息不丢失\n实例宕机，消息不丢失，数据可持久化\n消息可堆积\n</code></pre>\n<p>消息队列(Message Queue)是一种应用间的通信方式，消息发送后可以立即返回，有消息系统来确保信息的可靠专递，消息生产者只管把消息发布到MQ中而不管谁来取，消息消费者只管从MQ中取消息而不管谁发布的，这样发布者和使用者都不用知道对方的存在。</p>\n<p>首先，我们可以知道，消息队列是一种异步的工作机制，比如说日志收集系统，为了避免数据在传输过程中丢失，还有订单系统，下单后，会生成对应的单据，库存的扣减，消费信息的发送，一个下单，产生这么多的消息，都是通过一个操作的触发，然后将其他的消息放入消息队列中，依次产生。再就是很多网站的，秒杀活动之类的，前多少名用户会便宜，都是通过消息队列来实现的。</p>\n<p>这些例子，都是通过消息队列，来实现，业务的解耦，最终数据的一致性，广播，错峰流控等等，从而完成业务的逻辑。</p>\n<h1><a id=\"Redis__pubsub__18\"></a>为什么不使用Redis 发布订阅 (pub/sub) 来实现消息队列</h1>\n<p>Redis Stream 主要用于消息队列（MQ，Message Queue），Redis 本身是有一个 Redis 发布订阅 (pub/sub) 来实现消息队列的功能，支持发布 / 订阅，支持多组生产者、消费者处理消息。但是存在很多问题：<br/> 1.消费者下线，数据会丢失。<br/> 2.不支持数据持久化，Redis 宕机，数据也会丢失，Pub/Sub 没有基于任何数据类型实现，不会写入到 RDB 和 AOF 中，当 Redis 宕机重启，Pub/Sub 的数据也会全部丢失。<br/> 3.消息堆积，缓冲区溢出，消费者会被强制踢下线，数据也会丢失。缓冲区的默认配置：client-output-buffer-limit pubsub 32mb 8mb 60。它的参数含义如下：<br/> 32mb：缓冲区一旦超过 32MB，Redis 直接强制把消费者踢下线。<br/> 8mb + 60：缓冲区超过 8MB，并且持续 60 秒，Redis 也会把消费者踢下线。</p>\n<h1><a id=\"Stream_26\"></a>Stream</h1>\n<p>Redis Stream 提供了消息的持久化和主备复制功能，可以让任何客户端访问任何时刻的数据，并且能记住每一个客户端的访问位置，还能保证消息不丢失。</p>\n<p>Redis Stream 有一个消息链表，将所有加入的消息都串起来，每个消息都有一个唯一的 ID 和对应的内容。每个 Stream 都有唯一的名称，它就是 Redis 的 key，在我们首次使用 xadd 指令追加消息时自动创建。<br/> <img alt=\"在这里插入图片描述\" src=\"image\\0fe1905138df45ebbc0168cdef5e0056.png\"/><br/> Consumer Group ：消费组，使用 XGROUP CREATE 命令创建，一个消费组有多个消费者(Consumer)。<br/> last_delivered_id ：游标，每个消费组会有个游标 last_delivered_id，任意一个消费者读取了消息都会使游标 last_delivered_id 往前移动。<br/> pending_ids ：消费者(Consumer)的状态变量，作用是维护消费者的未确认的 id。 pending_ids 记录了当前已经被客户端读取的消息，但是还没有 ack (Acknowledge character：确认字符）。</p>\n<h2><a id=\"_35\"></a>消息队列相关命令：</h2>\n<p>XADD - 添加消息到末尾<br/> XTRIM - 对流进行修剪，限制长度<br/> XDEL - 删除消息<br/> XLEN - 获取流包含的元素数量，即消息长度<br/> XRANGE - 获取消息列表，会自动过滤已经删除的消息<br/> XREVRANGE - 反向获取消息列表，ID 从大到小<br/> XREAD - 以阻塞或非阻塞方式获取消息列表</p>\n<h2><a id=\"_45\"></a>消费者组相关命令：</h2>\n<p>XGROUP CREATE - 创建消费者组<br/> XREADGROUP GROUP - 读取消费者组中的消息<br/> XACK - 将消息标记为\"已处理\"<br/> XGROUP SETID - 为消费者组设置新的最后递送消息ID<br/> XGROUP DELCONSUMER - 删除消费者<br/> XGROUP DESTROY - 删除消费者组<br/> XPENDING - 显示待处理消息的相关信息<br/> XCLAIM - 转移消息的归属权<br/> XINFO - 查看流和消费者组的相关信息；<br/> XINFO GROUPS - 打印消费者组的信息；<br/> XINFO STREAM - 打印流信息</p>\n<h1><a id=\"Stream_60\"></a>Stream最简单的生产、消费模型</h1>\n<p>XADD：发布消息<br/> XREAD：读取消息<br/> <img alt=\"在这里插入图片描述\" src=\"image\\9c6e4f9aa2df4e0ca336221dc9828c07.png\"/></p>\n<h1><a id=\"Stream__65\"></a>Stream 优点/改进</h1>\n<h2><a id=\"Stream__67\"></a>Stream 支持「阻塞式」拉取消息</h2>\n<p>读取消息时，只需要增加 BLOCK 参数即可支持「阻塞式」拉取消息。<br/> // BLOCK 0 表示阻塞等待，不设置超时时间<br/> 127.0.0.1:6379&gt; XREAD COUNT 5 BLOCK 0 STREAMS queue 1618469127777-0<br/> 这时，消费者就会阻塞等待，直到生产者发布新的消息才会返回。</p>\n<h2><a id=\"___73\"></a>支持发布 / 订阅模式</h2>\n<p>XADD 向队列添加消息，如果指定的队列不存在，则创建一个队列<br/> XGROUP：创建消费者组<br/> XREADGROUP：在指定消费组下，开启消费者拉取消息<br/> 首先，生产者依旧发布 2 条消息：</p>\n<h3><a id=\"XADD_key_ID_field_value_field_value__78\"></a>XADD key ID field value [field value …]</h3>\n<p>向队列添加消息，如果指定的队列不存在，则创建一个队列<br/> key ：队列名称，如果不存在就创建<br/> ID ：消息 id，我们使用 * 表示由 redis 生成，可以自定义，但是要自己保证递增性，*表示让 Redis 自动生成唯一的消息 ID。<br/> field value ： 记录。<br/> 比如：<code>XADD mystream * field1 value1 field2 value2 field3 value3</code></p>\n<pre><code class=\"prism language-sql\"><span class=\"token number\">127.0</span><span class=\"token number\">.0</span><span class=\"token number\">.1</span>:<span class=\"token number\">6379</span><span class=\"token operator\">&gt;</span> XADD queue <span class=\"token operator\">*</span> name a \n<span class=\"token string\">\"1618470740565-0\"</span>\n<span class=\"token number\">127.0</span><span class=\"token number\">.0</span><span class=\"token number\">.1</span>:<span class=\"token number\">6379</span><span class=\"token operator\">&gt;</span> XADD queue <span class=\"token operator\">*</span> name b \n<span class=\"token string\">\"1618470743793-0\"</span>\n</code></pre>\n<p>发布后要开启 2 组消费者处理同一批数据，就需要创建 2 个消费者组：<br/> // 创建消费者组1，0-0表示从头拉取消息</p>\n<pre><code class=\"prism language-sql\"><span class=\"token number\">127.0</span><span class=\"token number\">.0</span><span class=\"token number\">.1</span>:<span class=\"token number\">6379</span><span class=\"token operator\">&gt;</span> XGROUP <span class=\"token keyword\">CREATE</span> queue group1 <span class=\"token number\">0</span><span class=\"token operator\">-</span><span class=\"token number\">0</span>\n</code></pre>\n<p>// 创建消费者组2，0-0表示从头拉取消息</p>\n<pre><code class=\"prism language-sql\"><span class=\"token number\">127.0</span><span class=\"token number\">.0</span><span class=\"token number\">.1</span>:<span class=\"token number\">6379</span><span class=\"token operator\">&gt;</span> XGROUP <span class=\"token keyword\">CREATE</span> queue group2 <span class=\"token number\">0</span><span class=\"token operator\">-</span><span class=\"token number\">0</span>\n</code></pre>\n<p>消费者组创建好之后，我们可以给每个「消费者组」下面挂一个「消费者」，让它们分别处理同一批数据。<br/> XREADGROUP GROUP 读取消费组中的消息。<br/> 第一个消费组开始消费：<br/> // group1的consumer开始消费，&gt;表示拉取最新数据</p>\n<pre><code class=\"prism language-sql\"><span class=\"token number\">127.0</span><span class=\"token number\">.0</span><span class=\"token number\">.1</span>:<span class=\"token number\">6379</span><span class=\"token operator\">&gt;</span> XREADGROUP <span class=\"token keyword\">GROUP</span> group1 consumer COUNT <span class=\"token number\">5</span> STREAMS queue \n\n<span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"queue\"</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"1618470740565-0\"</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"name\"</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"a\"</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"1618470743793-0\"</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"name\"</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"b\"</span>\n</code></pre>\n<p>同样地，第二个消费组开始消费：</p>\n<p>// group2的consumer开始消费，&gt;表示拉取最新数据</p>\n<pre><code class=\"prism language-sql\"><span class=\"token number\">127.0</span><span class=\"token number\">.0</span><span class=\"token number\">.1</span>:<span class=\"token number\">6379</span><span class=\"token operator\">&gt;</span> XREADGROUP <span class=\"token keyword\">GROUP</span> group2 consumer COUNT <span class=\"token number\">5</span> STREAMS queue\n\n<span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"queue\"</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"1618470740565-0\"</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"name\"</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"a\"</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"1618470743793-0\"</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"name\"</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"b\"</span>\n</code></pre>\n<p>我们可以看到，这 2 组消费者，都可以获取同一批数据进行处理了。<br/> <img alt=\"在这里插入图片描述\" src=\"image\\4b3b0f8bdc32438da621431366c68701.png\"/><br/> //消费者重新上线，0-0表示重新拉取未ACK的消息</p>\n<pre><code class=\"prism language-sql\"><span class=\"token number\">127.0</span><span class=\"token number\">.0</span><span class=\"token number\">.1</span>:<span class=\"token number\">6379</span><span class=\"token operator\">&gt;</span> XREADGROUP <span class=\"token keyword\">GROUP</span> group1 consumer1 COUNT <span class=\"token number\">5</span> STREAMS queue <span class=\"token number\">0</span><span class=\"token operator\">-</span><span class=\"token number\">0</span>\n<span class=\"token comment\">// 之前没消费成功的数据，依旧可以重新消费</span>\n<span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"queue\"</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"1618472043089-0\"</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"name\"</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"a\"</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"1618472045158-0\"</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"name\"</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"b\"</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span> \n</code></pre>\n<h2><a id=\"Stream__136\"></a>Stream 能保证消息不丢失，重新消费</h2>\n<p>当一组消费者处理完消息后，需要执行 XACK 命令告知 Redis，这时 Redis 就会把这条消息标记为「处理完成」。<br/> // group1下的 1618472043089-0 消息已处理完成</p>\n<pre><code class=\"prism language-sql\"><span class=\"token number\">127.0</span><span class=\"token number\">.0</span><span class=\"token number\">.1</span>:<span class=\"token number\">6379</span><span class=\"token operator\">&gt;</span> XACK queue group1 \n<span class=\"token number\">1618472043089</span><span class=\"token operator\">-</span><span class=\"token number\">0</span>\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\8c6ded5f367a429c8455d8b1a9b3d94a.png\"/><br/> 消费者异常宕机，肯定不会发送 XACK，那么 Redis 就会依旧保留这条消息。<br/> 待这组消费者重新上线后，Redis 就会把之前没有处理成功的数据，重新发给这个消费者。这样一来，即使消费者异常，也不会丢失数据了。</p>\n<h2><a id=\"Stream__RDB__AOF__147\"></a>Stream 数据会写入到 RDB 和 AOF 做持久化</h2>\n<p>Stream 是新增加的数据类型，它与其它数据类型一样，每个写操作，也都会写入到 RDB 和 AOF 中。<br/> 我们只需要配置好持久化策略，这样的话，就算 Redis 宕机重启，Stream 中的数据也可以从 RDB 或 AOF 中恢复回来。</p>\n<h2><a id=\"Stream_150\"></a>消息堆积时，Stream的处理</h2>\n<p>当消息队列发生消息堆积时，一般只有 2 个解决方案：<br/> 生产者限流：避免消费者处理不及时，导致持续积压<br/> 丢弃消息：中间件丢弃旧消息，只保留固定长度的新消息<br/> 而 Redis 在实现 Stream 时，采用了第 2 个方案。</p>\n<p>在发布消息时，你可以指定队列的最大长度，防止队列积压导致内存爆炸。</p>\n<pre><code class=\"prism language-sql\"><span class=\"token comment\">// 队列长度最大10000</span>\n<span class=\"token number\">127.0</span><span class=\"token number\">.0</span><span class=\"token number\">.1</span>:<span class=\"token number\">6379</span><span class=\"token operator\">&gt;</span> XADD queue MAXLEN <span class=\"token number\">10000</span> <span class=\"token operator\">*</span> name a\n<span class=\"token string\">\"1618473015018-0\"</span>\n</code></pre>\n<p>当队列长度超过上限后，旧消息会被删除，只保留固定长度的新消息。<br/> 这么来看，Stream 在消息积压时，如果指定了最大长度，还是有可能丢失消息的。</p>\n<h1><a id=\"_169\"></a>专业的消息队列</h1>\n<p>1.消息不丢<br/> 2.消息可堆积</p>\n<p>使用一个消息队列，其实就分为三大块：生产者、队列中间件、消费者。<br/> <img alt=\"在这里插入图片描述\" src=\"image\\3c3f094d727845e385ee542241227efe.png\"/><br/> 消息是否会发生丢失，其重点也就在于以下 3 个环节：<br/> <strong>生产者会不会丢消息？<br/> 消费者会不会丢消息？<br/> 队列中间件会不会丢消息？</strong></p>\n<p><strong>当生产者在发布消息时，可能发生以下异常情况：</strong><br/> <strong>消息没发出去</strong>：网络故障或其它问题导致发布失败，中间件直接返回失败。消息根本没发出去，那么重新发一次就好了。<br/> <strong>不确定是否发布成功</strong>：网络问题导致发布超时，可能数据已发送成功，但读取响应结果超时了。为了避免消息丢失，只能继续重试，直到发布成功为止。生产者一般会设定一个最大重试次数，超过上限依旧失败，需要记录日志报警处理。<br/> <strong>在使用消息队列时，要保证消息不丢，宁可重发，也不能丢弃。</strong></p>\n<p>无论是 Redis 还是专业的队列中间件，生产者都是可以保证消息不丢的。因为大不了重发。</p>\n<p><strong>消费者会不会丢消息？</strong><br/> 消费者拿到消息后，还没处理完成，就异常宕机了，那消费者还能否重新消费失败的消息？<br/> 消费者在处理完消息后，必须「告知」队列中间件，队列中间件才会把标记已处理，否则仍旧把这些数据发给消费者。<br/> 这种方案需要消费者和中间件互相配合，才能保证消费者这一侧的消息不丢。<br/> 无论是 Redis 的 Stream，还是专业的队列中间件，例如 RabbitMQ、Kafka，其实都是这么做的。</p>\n<p><strong>队列中间件会不会丢消息？</strong><br/> Redis 在以下 2 个场景下，都会导致数据丢失：<br/> AOF 持久化配置为每秒写盘，但这个<strong>写盘过程是异步的</strong>，<strong>Redis 宕机时会存在数据丢失的可能</strong><br/> <strong>主从复制也是异步的</strong>，<strong>主从切换时，也存在丢失数据的可能（从库还未同步完成主库发来的数据，就被提成主库）</strong><br/> 基于以上原因我们可以看到，<strong>Redis 本身的无法保证严格的数据完整性。</strong></p>\n<p>像 RabbitMQ 或 Kafka 这类专业的队列中间件，在使用时，一般是部署一个集群，生产者在发布消息时，队列中间件通常会写「多个节点」，以此保证消息的完整性。这样一来，即便其中一个节点挂了，也能保证集群的数据不丢失。</p>\n<p>因为 Redis 的数据都存储在内存中，这就意味着一旦发生消息积压，则会导致 Redis 的内存持续增长，如果超过机器内存上限，依旧可能被强行删除。但 Kafka、RabbitMQ 这类消息队列就不一样了，它们的数据都会存储在磁盘上，磁盘的成本要比内存小得多，当消息积压时，无非就是多占用一些磁盘空间，相比于内存，在面对积压时也会更加轻松。</p>\n<p><strong>Redis 相比于 Kafka、RabbitMQ，部署和运维更加轻量。如果你的业务场景足够简单，对于数据丢失不敏感，而且消息积压概率比较小的情况下，把 Redis 当作队列是完全可以的。<br/> 如果你的业务场景对于数据丢失非常敏感，而且写入量非常大，消息积压时会占用很多的机器资源，那么我建议你使用专业的消息队列中间件。</strong></p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}