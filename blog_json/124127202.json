{"blogid": "124127202", "writerAge": "码龄1年", "writerBlogNum": "27", "writerCollect": "164", "writerComment": "80", "writerFan": "1676", "writerGrade": "3级", "writerIntegral": "438", "writerName": "我要取个特别特别特别特别特别特别长的名字", "writerProfileAdress": "writer_image\\profile_124127202.jpg", "writerRankTotal": "32480", "writerRankWeekly": "6083", "writerThumb": "107", "writerVisitNum": "32603", "blog_read_count": "4074", "blog_time": "已于 2022-04-22 07:07:18 修改", "blog_title": "c++STL库最详细介绍(保姆级教学)", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p><strong>目录</strong></p>\n<p style=\"margin-left:0px;\"><a href=\"#%E5%85%A5%E5%9D%91rc%E8%BD%A6%E7%9A%84%E6%88%91%E5%8F%88%E6%9D%A5%E5%86%99%E6%96%87%E5%95%A6%E3%83%BE%28%E2%89%A7%E2%96%BD%E2%89%A6*%29o\">入坑rc车的我又来写文啦ヾ(≧▽≦*)o</a></p>\n<p style=\"margin-left:0px;\"><a href=\"#%E9%A6%96%E5%85%88%EF%BC%8C%E5%92%B1%E4%BB%AC%E6%90%9E%E6%B8%85%E6%A5%9ASTL%E5%BA%93%E6%98%AF%E5%95%A5%E4%B8%9C%E8%A5%BF%EF%BC%88%E5%A4%A7%E4%BD%AC%E5%BE%80%E4%B8%8B%E7%9C%8B%EF%BC%89\">首先，咱们搞清楚STL库是啥东西</a></p>\n<p style=\"margin-left:0px;\"><a href=\"#One.%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%28Sort%29%3A\">One.快速排序(Sort):</a></p>\n<p style=\"margin-left:40px;\"><a href=\"#Sort%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%3A\">1.Sort的基本用法:</a></p>\n<p style=\"margin-left:40px;\"><a href=\"#Sort%E8%BF%9B%E9%98%B6%E7%94%A8%E6%B3%95%EF%BC%88CMP%EF%BC%89%EF%BC%9A\">2.Sort进阶用法（CMP）：</a></p>\n<p style=\"margin-left:40px;\"><a href=\"#3.Sort%E5%AF%B9%E7%BB%93%E6%9E%84%E4%BD%93%28%E6%88%96%E8%80%85%E7%B1%BB%29%E7%9A%84%E6%8E%92%E5%BA%8F%EF%BC%9A\">3.Sort对结构体(或者类)的排序：</a></p>\n<p style=\"margin-left:0px;\"><a href=\"#Two.Map\">Two.Map</a></p>\n<p style=\"margin-left:40px;\"><a href=\"#Map%E7%AE%80%E4%BB%8B%3A\">Map简介:</a></p>\n<p style=\"margin-left:80px;\"><a href=\"#%E5%AE%9A%E4%B9%89%EF%BC%9A\">定义：</a></p>\n<p style=\"margin-left:80px;\"><a href=\"#%E4%B8%BE%E4%B8%AA%E6%A0%97%E5%AD%90%3A\">举个栗子:</a></p>\n<p style=\"margin-left:0px;\"><a href=\"#%E5%88%B7%E9%A2%98%E6%97%B6%E9%97%B4!\">刷题时间!</a></p>\n<p style=\"margin-left:40px;\"><a href=\"#%C2%A0%E7%A6%BB%E6%95%A3%E5%8C%96%E5%9F%BA%E7%A1%80%3A\"> 题目：离散化基础</a></p>\n<p style=\"margin-left:80px;\"><a href=\"#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F\">输入格式</a></p>\n<p style=\"margin-left:80px;\"><a href=\"#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F\">输出格式</a></p>\n<p style=\"margin-left:80px;\"><a href=\"#%E8%BE%93%E5%85%A5%2F%E8%BE%93%E5%87%BA%E4%BE%8B%E5%AD%901\">输入/输出例子1</a></p>\n<p style=\"margin-left:40px;\"><a href=\"#%E9%A2%98%E8%A7%A3%3A\">题解:</a></p>\n<p style=\"margin-left:0px;\"><a href=\"#Three.stack%28%E6%A0%88%29\">Three.stack(栈)</a></p>\n<p style=\"margin-left:40px;\"><a href=\"#%E6%A0%88%E7%9A%84%E4%BB%8B%E7%BB%8D%EF%BC%9A\">栈的介绍：</a></p>\n<p style=\"margin-left:40px;\"><a href=\"#%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%9A\">栈的定义：</a></p>\n<p style=\"margin-left:40px;\"><a href=\"#%E6%A0%88%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%EF%BC%9A\">栈的成员函数：</a></p>\n<p style=\"margin-left:0px;\"><a href=\"#Four.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE\">Four.二分查找</a></p>\n<p style=\"margin-left:40px;\"><a href=\"#%E7%BE%8E%E5%A6%99%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%9A\">美妙的函数：</a></p>\n<p style=\"margin-left:80px;\"><a href=\"#1.lower_bound%E5%87%BD%E6%95%B0\">1.lower_bound函数</a></p>\n<p style=\"margin-left:80px;\"><a href=\"#2.upper_bound%E5%87%BD%E6%95%B0\">2.upper_bound函数</a></p>\n<p style=\"margin-left:80px;\"><a href=\"#3.binary_search%EF%BC%9A%E6%9F%A5%E6%89%BE%E6%95%B0%E7%BB%84%E5%86%85%E6%9F%90%E4%B8%AA%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6%E5%87%BA%E7%8E%B0%E3%80%82\">3.binary_search：查找数组内某个元素是否出现。</a></p>\n<p style=\"margin-left:0px;\"><a href=\"#%E5%86%8D%E6%9D%A5%E4%B8%80%E9%A2%98%EF%BC%81\">再来一题！</a></p>\n<p style=\"margin-left:0px;\"><a href=\"#%E2%80%8B%C2%A0\">​ </a></p>\n<p style=\"margin-left:40px;\"><a href=\"#%E9%A2%98%E7%9B%AE%EF%BC%9A%E6%95%B0%E7%BB%84%E7%BA%BF%E6%AE%B5%E5%92%8CM\">题目：数组线段和M</a></p>\n<p style=\"margin-left:80px;\"><a href=\"#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F\">输入格式</a></p>\n<p style=\"margin-left:80px;\"><a href=\"#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F\">输出格式</a></p>\n<p style=\"margin-left:80px;\"><a href=\"#%E8%BE%93%E5%85%A5%2F%E8%BE%93%E5%87%BA%E4%BE%8B%E5%AD%901\">输入/输出例子1</a></p>\n<p style=\"margin-left:40px;\"><a href=\"#%E9%A2%98%E8%A7%A3%EF%BC%9A\">题解：</a></p>\n<p style=\"margin-left:0px;\"><a href=\"#Six.list%28%E9%93%BE%E8%A1%A8%29\">Six.list(链表)</a></p>\n<p style=\"margin-left:40px;\"><a href=\"#%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0%EF%BC%9A\">常用操作函数：</a></p>\n<p style=\"margin-left:40px;\"><a href=\"#list%E7%9A%84%E5%AE%9A%E4%B9%89\">list的定义</a></p>\n<p style=\"margin-left:0px;\"><a href=\"#%E3%83%BD%28%EF%BF%A3%CF%89%EF%BF%A3%28%EF%BF%A3%CF%89%EF%BF%A3%E3%80%83%29%E3%82%9D%E4%BB%8A%E5%A4%A9%E5%B0%B1%E5%88%B0%E8%BF%99%EF%BC%8C%E5%A4%A7%E5%AE%B6%E5%86%8D%E8%A7%81%EF%BC%81%E3%80%82\">ヽ(￣ω￣(￣ω￣〃)ゝ今天就到这，大家再见！。</a></p>\n<hr/>\n<p> </p>\n<p> </p>\n<p> </p>\n<h1>入坑rc车的我又来写文啦ヾ(≧▽≦*)o</h1>\n<blockquote>\n<p>要“深入探讨”的可以加我qq28562939</p>\n<p>想必经常搞C++的人大概都听说过STL库吧(正好最近在研究)，其中最知名我就是我们的——sort快速排序了！</p>\n<p>不了解的兄弟也没关系，</p>\n<p>我们继续往下看。</p>\n<p style=\"text-align:center;\"><img alt=\"971a71db51780b6ae7e37c02d9491cba.png\" src=\"image\\971a71db51780b6ae7e37c02d9491cba.png\"/></p>\n<p> 难度逐次递增。</p>\n</blockquote>\n<p> </p>\n<h1>首先，咱们搞清楚STL库是啥东西</h1>\n<blockquote>\n<p>STL,学名Standard Template Library，一般我们称他为标准模板库，是一系列软件的统称。</p>\n<p>从根本上说，STL是一些“容器”的集合，这些“容器”有list,vector,set,map一大堆，STL也是算</p>\n<p>法和其他一些组件的集合。比如说&lt;algorithm&gt;中sort函数、&lt;string&gt;中string类都</p>\n<p>是STL的内容。</p>\n</blockquote>\n<p>STL库还有很多内容，比如：向量（vector）、栈（stack）、队列（queue）、优先队列</p>\n<p>（priority_queue）、链表（list）、集合（set）、映射（map）等容器；min、max、swap</p>\n<p>、sort、lower_bound、upper_bound 等算法，有的甚至都没人知道。ㄟ( ▔, ▔ )ㄏ</p>\n<hr/>\n<h1>One.快速排序(Sort):</h1>\n<p>众所周知，c++有各种正常排序和奇葩的排序，比如说冒泡排序，时间复杂度为N(O^2)，就很离谱</p>\n<p>是不是，随便排一个100000的元素的数组就超时。</p>\n<p style=\"text-align:center;\"><img alt=\"39fde83e8ab951081df3bfad24aca8bd.png\" src=\"image\\39fde83e8ab951081df3bfad24aca8bd.png\"/></p>\n<p> </p>\n<p>所以，咱们以后不用冒泡，用sort快排（弃暗投明）,时间复杂度为N*LogN，对一百万个数排序也不会超过1秒。</p>\n<h2>1.Sort的基本用法:</h2>\n<p>sort是STL自带的系统函数，它的格式是：</p>\n<p>void sort(要排序元素的起始地址，要排序元素的结束地址，比较函数)；</p>\n<p>这里可以省略比较函数，他是默认从小到大排序的（升序排序）</p>\n<pre><code class=\"language-cpp\">#include&lt;algorithm&gt;\n#include&lt;iostream&gt;\nusing namespace std;\nint main()\n{\n\tint a[]={3,5,2,6,9,3,5};\n\tsort(a,a+7);//7是数组的元素个数，这里a为数组的开头，a+7就等于排序到数组的第七个元素\n\tfor(int i=0;i&lt;6;i++)\n\t\tcout&lt;&lt;a[i]&lt;&lt;\" \";\n}\n</code></pre>\n<p>输出:</p>\n<pre><code class=\"language-cpp\">2 3 3 5 5 6</code></pre>\n<h2>2.Sort进阶用法（CMP）：</h2>\n<p>void sort(要排序元素的起始地址，要排序元素的结束地址，比较函数)；,没错又是他，这里我们发</p>\n<p>现还有个比较函数没说，这个比较函数的作用就是可以自定义排序方式，比如降序排序。</p>\n<p>定义：bool cmp(int x,int y).....，如果返回True那么x就排在y前面。</p>\n<pre><code class=\"language-cpp\">#include&lt;algorithm&gt;\n#include&lt;iostream&gt;\nusing namespace std;\nbool cmp(int x,int y)\n{\n\tif(x&gt;y)return true;//降序\n\treturn false;\n}\nint main()\n{\n\tint a[]={3,5,2,6,9,3,5};\n\tsort(a,a+7,cmp);//7是数组的元素个数\n\tfor(int i=0;i&lt;6;i++)\n\t\tcout&lt;&lt;a[i]&lt;&lt;\" \";\n}\n</code></pre>\n<p>输出：</p>\n<pre><code>9 6 5 5 3 3</code></pre>\n<h2>3.Sort对结构体(或者类)的排序：</h2>\n<p>同学们进行干饭比赛，参赛队员分别为“法外狂徒张三”，“干饭者老八”以及王五同学，谁吃的更多谁就排在更前面，如果吃的一样多那么谁吃的老八汉堡多谁就排在更前面：</p>\n<pre><code class=\"language-cpp\">#include&lt;algorithm&gt;\n#include&lt;iostream&gt;\nusing namespace std;\nstruct ganfan\n{\n\tstring name;\n\tint zongshu;\n\tint hanbao;\n};\nbool cmp(ganfan x,ganfan y)\n{\n\tif(x.zongshu&gt;y.zongshu)return true;\n\telse if(x.hanbao&gt;y.hanbao&amp;&amp;x.zongshu==y.zongshu)//如果一样多那么比谁吃的汉堡多\n\treturn false;\n}\nint main()\n{\n\tganfan a[3];\n\ta[0].name=\"zhangsan\";a[0].zongshu=200;a[0].hanbao=6;\n\ta[1].name=\"laoba\";a[1].zongshu=170;a[1].hanbao=13;\n\ta[2].name=\"wangwu\";a[2].zongshu=170;a[2].hanbao=10;\n\tsort(a,a+3,cmp);\n\tfor(int i=0;i&lt;3;i++)\n\t\tcout&lt;&lt;a[i].name&lt;&lt;\" \";\n}\n</code></pre>\n<p>输出：</p>\n<pre><code>wangwu laoba zhangsan</code></pre>\n<p>我们可以看到，张三的干饭总数是最多的，所以排在最前面，老八和王五的干饭总数一样多，但是老八吃的汉堡更多些，所以老八排在王五前面。</p>\n<h1>Two.Map</h1>\n<h2>Map简介:</h2>\n<p>map是STL的一个关联容器，它提供一对一的<a href=\"https://so.csdn.net/so/search?q=hash&amp;spm=1001.2101.3001.7020\" title=\"hash\">hash</a>。</p>\n<ul><li>第一个可以称为关键字(key)，每个关键字只能在map中出现一次；</li><li>第二个可能称为该关键字的值(value)；</li></ul>\n<h3>定义：</h3>\n<pre><code class=\"language-cpp\">map&lt;类型,类型&gt; m;</code></pre>\n<h3>举个栗子:</h3>\n<p>记录每个人的名字的对应的爱好,张三喜欢吃汉堡：</p>\n<pre><code class=\"language-cpp\">#include&lt;map&gt;\n#include&lt;iostream&gt;\nusing namespace std;\nint main()\n{\n\tmap&lt;string,string&gt; m;\n\tm[\"张三\"]=\"吃汉堡\";\n\tcout&lt;&lt;\"张三: \"&lt;&lt;m[\"张三\"]; \n}\n</code></pre>\n<p> 输出：</p>\n<pre><code>张三: 吃汉堡</code></pre>\n<p> </p>\n<h1>刷题时间!</h1>\n<p style=\"text-align:center;\"><img alt=\"df2b8fc98dbf62e1e2f5863a43a8ecfc.png\" src=\"image\\df2b8fc98dbf62e1e2f5863a43a8ecfc.png\"/></p>\n<h2> 题目：离散化基础</h2>\n<p>在使用离散化方法编程时，通常要知道每个数排序后的编号(rank值)，相同的数对应同一个编号。</p>\n<h3>输入格式</h3>\n<p> </p>\n<p>第1行：一个整数N。 1&lt;=N&lt;=100000。<br/> 第2行：有N个整数，每个数都是int范围的。注意：可能有相同整数。</p>\n<p> </p>\n<h3>输出格式</h3>\n<p> </p>\n<p>依次输出每个数的排名。</p>\n<p> </p>\n<h3>输入/输出例子1</h3>\n<p>输入：</p>\n<p>5<br/> 8 2 6 9 2</p>\n<p>输出：</p>\n<p>3 1 2 4 1</p>\n<h2>题解:</h2>\n<p>这题用Sort和Map就可以很容易解决:</p>\n<pre><code class=\"language-cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nint N,a[100001],b[100001];\nmap&lt;int,int&gt; m;\nint main(){\n    \n    cin&gt;&gt;N;\n    for(int i=0;i&lt;N;i++)\n    {\n        cin&gt;&gt;a[i];\n        b[i]=a[i];\n    }\n    sort(b,b+N);//将数组排序\n    int c=1;//排名\n    m[b[0]]=1;//因为数组经过排序，所以第1个元素肯定是第一\n    for(int i=1;i&lt;N;i++)\n    {\n        if(b[i]!=b[i-1])//判断是否不与前一个数相等\n        {\n            c++;\n            m[b[i]]=c;\n        }\n    }\n    for(int i=0;i&lt;N;i++)\n        if(m[a[i]]!=0)\n            cout&lt;&lt;m[a[i]]&lt;&lt;\" \";//按照原来的下标输出\n    \n    return 0;\n}</code></pre>\n<h1>Three.stack(栈)</h1>\n<p>头文件:</p>\n<pre><code class=\"language-cpp\">#include&lt;stack&gt;</code></pre>\n<p>stack好像还有个翻译叫“咸鱼”...嘿嘿。</p>\n<h2>栈的介绍：</h2>\n<blockquote>\n<p>栈就像一个盒子，可以放入或去除元素，但是个人类都知道，<strong>要把盒子底下的东西取出来，就必须先取出他上面的东西。</strong></p>\n</blockquote>\n<p>假如我们把1、2、3、4、5按顺序分别<strong>入栈</strong>：</p>\n<p style=\"text-align:center;\"><img alt=\"04c131ebc812f96f01151e3a54b8f13c.png\" src=\"image\\04c131ebc812f96f01151e3a54b8f13c.png\"/></p>\n<p>                                                                                                                         ——博主美丽的手绘 </p>\n<h2>栈的定义：</h2>\n<pre><code class=\"language-cpp\">stack&lt;类型(可以不写)&gt; st;\n或者stack st;</code></pre>\n<p>很easy是不？</p>\n<h2>栈的成员函数：</h2>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:329px;\"><tbody><tr><td>.empty()</td><td style=\"width:129px;\">判断栈是否为空，空则返回true</td></tr><tr><td>.pop()</td><td style=\"width:129px;\">移除栈顶元素</td></tr><tr><td>.push(啥啥啥)</td><td style=\"width:129px;\">在栈顶增加元素</td></tr><tr><td>.size()</td><td style=\"width:129px;\">返回栈中元素数目</td></tr><tr><td>.top()</td><td style=\"width:129px;\">返回栈顶元素</td></tr></tbody></table>\n<p>.empty()  判断栈是否为空。</p>\n<pre><code class=\"language-cpp\">stack st;\nif(st.empty())//如果是空那么执行下面代码\n    ......</code></pre>\n<p> .push(啥啥啥),在栈顶增加元素。</p>\n<p>.top()，返回栈顶元素，记住是返回，要单独输出。</p>\n<pre><code class=\"language-cpp\">#include&lt;stack&gt;\n#include&lt;iostream&gt;\nusing namespace std;\nstack&lt;int&gt; st;\nint main(){\n    \n    st.push(5418);\n    cout&lt;&lt;st.top();//输出栈顶元素\n    return 0;\n}</code></pre>\n<p>输出5418。 </p>\n<p>                                                    </p>\n<hr/>\n<p>.size(), 返回栈中元素数目。</p>\n<pre><code class=\"language-cpp\">#include&lt;stack&gt;\n#include&lt;iostream&gt;\nusing namespace std;\nstack&lt;int&gt; st;\nint main(){\n    \n    st.push(5418);\n    cout&lt;&lt;st.size();\n    \n    return 0;\n}</code></pre>\n<p>输出1 </p>\n<hr/>\n<p>.pop()，移除栈顶元素：</p>\n<pre><code class=\"language-cpp\">#include&lt;stack&gt;\n#include&lt;iostream&gt;\nusing namespace std;\nstack&lt;int&gt; st;\nint main(){\n    \n    st.push(1452);\n    st.push(5418);\n    st.pop();\n    cout&lt;&lt;st.top();\n    \n    return 0;\n}</code></pre>\n<p> 输出1452。</p>\n<p> </p>\n<p>简单不？</p>\n<hr/>\n<h1>Four.二分查找</h1>\n<p>头文件：</p>\n<pre><code class=\"language-cpp\">#include &lt;algorithm&gt;</code></pre>\n<h2>美妙的函数：</h2>\n<h3>1.lower_bound函数</h3>\n<blockquote>\n<p>对于有序容器，有序容器，有序容器（重要的事情说三遍）快速二分查找出第一个大于等于</p>\n<p>指定数的位置（下标），如果没有找到，返回最后一个数据后面的位置。</p>\n</blockquote>\n<p>  对于数组，通常的格式为：</p>\n<p>查找的数组下标 = lower_bound(数组要查找的开始位置，数组要查找的结束位置后面，要找的数) – 数组开始位置(一般写数组名);</p>\n<p>比如：</p>\n<pre><code class=\"language-cpp\">#include&lt;algorithm&gt;\n#include&lt;iostream&gt;\n\nusing namespace std;\n\nint main() {\n\n    int a[5] = { 1,2,3,3,8 };\n\n    //从 a 数组中找到第一个不小于   3 的元素\n\n    int   index = lower_bound(a, a + 5, 3)-a;//查找的数组下标 = lower_bound(数组要查找的开始位置，数组要查找的结束位置后面，要找的数) – 数组开始位置;\n\n    if   (index==5 ) cout &lt;&lt; \" not found! \";//index=5，也就是数组末尾的位置。\n    else  cout &lt;&lt; index;\n\n    return   0;\n\n}</code></pre>\n<p> 输出2。</p>\n<h3>2.upper_bound函数</h3>\n<blockquote>\n<p>有一个类似lower_bound的函数upper_bound, 快速二分查找出第一个大于指定数的位置（下</p>\n<p>标），如果没有找到，返回最后一个数据后面的位置。</p>\n</blockquote>\n<p>举个栗子，啊......快没栗子了。(っ °Д °;)っ</p>\n<pre><code class=\"language-cpp\">#include&lt;algorithm&gt;\n#include&lt;iostream&gt;\n\nusing namespace std;\n\nint main() {\n\n    int a[5] = { 1,2,3,3,8 };\n    //从 a 数组中找到第一个大于 3 的元素\n\n    int   index = upper_bound(a, a + 5, 3)-a;\n\n    if   (index==5 ) cout &lt;&lt; \" not found! \";\n    else cout &lt;&lt; index;\n\n    return   0;\n\n}</code></pre>\n<p> 输出4.</p>\n<h3>3.binary_search：查找数组内某个元素是否出现。</h3>\n<blockquote>\n<p>void binary_search(数组首地址，结束地址，要查找的数)</p>\n<p>返回值为bool类型，找到了返回true。</p>\n</blockquote>\n<p> </p>\n<p> </p>\n<h1>再来一题！</h1>\n<h1 style=\"text-align:center;\"><img alt=\"41392fe6aaffa9f5bc56fbe02133c7d1.png\" src=\"image\\41392fe6aaffa9f5bc56fbe02133c7d1.png\"/> </h1>\n<h2>题目：数组线段和M</h2>\n<h3>输入格式</h3>\n<p> </p>\n<p>  第一行2个正整数N和M，N范围[1，1000000],M范围[1，10^9]。</p>\n<p>  第二行是N个正整数，每个数范围[1，1000]。</p>\n<p> </p>\n<p> </p>\n<h3>输出格式</h3>\n<p> </p>\n<p>  一个整数。</p>\n<p> </p>\n<h3>输入/输出例子1</h3>\n<p>输入：</p>\n<p>10 20</p>\n<p>1 7 10 10 7 10 6 4 6 6</p>\n<p> </p>\n<p>输出：</p>\n<p>2</p>\n<h2>题解：</h2>\n<p>这题我是用<a class=\"link-info\" href=\"https://blog.csdn.net/qq_52109814/article/details/119038243?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=C++%20%E5%89%8D%E7%BC%80%E5%92%8C&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-119038243.142%5Ev7%5Epc_search_result_control_group,157%5Ev4%5Econtrol&amp;spm=1018.2226.3001.4187\" title=\"前缀和\">前缀和</a>的方法解的，因为数据较多，这样快一点,还能变成有序数列。</p>\n<p>代码稍稍有点难，大家看着办吧：</p>\n<pre><code class=\"language-cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nint N,M;\nint a[1000001];\nint main(){\n    \n    cin&gt;&gt;N&gt;&gt;M;\n    cin&gt;&gt;a[0];\n    for(int i=1;i&lt;N;i++)\n    {\n        cin&gt;&gt;a[i];\n        a[i]+=a[i-1];//求前缀和数组\n    }\n    int ans=0;\n    int mubiao=M;//目标\n    for(;int index = lower_bound(a, a + N, mubiao)-a;)\n    {\n        if(index==N)//找不到了说明没有了\n        {\n            break;\n        }\n        if(a[index]==M)\n        {\n            mubiao=a[index]+1;\n        }\n        else{\n            int fl=a[index]-M;\n            int ind=lower_bound(a, a + N, fl)-a;\n            if(a[ind]==fl)\n                ans++;\n            mubiao=a[index]+1;//目标加一，防止重复查找\n        }\n    }\n    cout&lt;&lt;ans;\n    \n    return 0;\n}</code></pre>\n<p>思路是找一个比M大的数，如果能找到，那么求出这个数和M的差，再找这个差，如果能找到，那根据前缀和的定义这一串的和就等于M，然后把目标+1，防止重复查找。</p>\n<h1>Six.list(链表)</h1>\n<h2>常用操作函数：</h2>\n<p>List.assign() 给list赋值 </p>\n<p><br/> List.back() 返回最后一个元素 </p>\n<p><br/> List.begin() 返回指向第一个元素的迭代器 </p>\n<p><br/> List.clear() 删除所有元素 </p>\n<p><br/> List.empty() 如果list是空的则返回true </p>\n<p><br/> List.end() 返回末尾的迭代器 </p>\n<p><br/> List.erase() 删除一个元素 </p>\n<p><br/> List.front() 返回第一个元素 </p>\n<p><br/> List.get_allocator() 返回list的配置器 </p>\n<p><br/> List.insert() 插入一个元素到list中 </p>\n<p><br/> List.max_size() 返回list能容纳的最大元素数量 </p>\n<p><br/> List.merge() 合并两个list </p>\n<p><br/> List.pop_back() 删除最后一个元素 </p>\n<p><br/> List.pop_front() 删除第一个元素 </p>\n<p><br/> List.push_back() 在list的末尾添加一个元素 </p>\n<p><br/> List.push_front() 在list的头部添加一个元素 </p>\n<p><br/> List.rbegin() 返回指向第一个元素的逆向迭代器 </p>\n<p><br/> List.remove() 从list删除元素 </p>\n<p><br/> List.remove_if() 按指定条件删除元素 </p>\n<p><br/> List.rend() 指向list末尾的逆向迭代器 </p>\n<p><br/> List.resize() 改变list的大小 </p>\n<p><br/> List.reverse() 把list的元素倒转 </p>\n<p><br/> List.size() 返回list中的元素个数 </p>\n<p><br/> List.sort() 给list排序 </p>\n<p><br/> List.splice() 合并两个list </p>\n<p><br/> List.swap() 交换两个list的内容</p>\n<p><br/> List.unique() 删除list中相邻重复的元素</p>\n<hr/>\n<h2>list的定义</h2>\n<pre><code class=\"language-cpp\">list&lt;int&gt; lst1;          //创建一个空list\n\nlist&lt;int&gt; lst2(10);       //创建一个含有10个元素的list\n\nlist&lt;int&gt; lst3(3,2);  //创建含有3个元素2的list\n\nlist&lt;int&gt; lst4(lst2);    //使用lst2初始化lst4\n\nlist&lt;int&gt; lst5(lst2.begin(),lst2.end());  //同lst4</code></pre>\n<p>部分内容与栈那篇差不多，我们不讲。</p>\n<p> </p>\n<h1>ヽ(￣ω￣(￣ω￣〃)ゝ今天就到这，大家再见！。</h1>\n<p> </p>\n<p> </p>\n<p> </p>\n<p> </p>\n<p> </p>\n</div>\n</div>"}