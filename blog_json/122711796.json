{"blogid": "122711796", "writerAge": "码龄13年", "writerBlogNum": "78", "writerCollect": "254", "writerComment": "7", "writerFan": "96", "writerGrade": "4级", "writerIntegral": "1280", "writerName": "草原悠悠兔", "writerProfileAdress": "writer_image\\profile_122711796.jpg", "writerRankTotal": "120376", "writerRankWeekly": "59291", "writerThumb": "40", "writerVisitNum": "90556", "blog_read_count": "1660", "blog_time": "已于 2022-01-27 11:19:19 修改", "blog_title": "C#多线程处理List集合数据", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>List集合是非<a href=\"https://so.csdn.net/so/search?q=%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8&amp;spm=1001.2101.3001.7020\" title=\"线程安全\">线程安全</a>的，所以我们采用并行编程时会发生错误。如下图所示</p>\n<pre><code class=\"language-cs\"> Parallel.For(0, 1000, (i) =&gt;\n      {\n        Product product = new Product();\n        product.Name = \"name\" + i;\n        product.Category = \"Category\" + i;\n        product.SellPrice = i;\n        _Products.Add(product);\n      });</code></pre>\n<p>代码中开启并发操作向集合中添加1000条数据，在没有保障线程安全和串行化的运行下，实际得到的数据不到1000条。为此我们需要采用Lock关键字，来确保每次只有一个线程来访问 ，可以得到1000条数据。</p>\n<pre><code>private static object o = new object();\nParallel.For(0, 1000, (i) =&gt;\n      {\n        Product product = new Product();\n        product.Name = \"name\" + i;\n        product.Category = \"Category\" + i;\n        product.SellPrice = i;\n        lock (o)\n        {\n          _Products.Add(product);\n        }\n      });</code></pre>\n<p>但是锁的引入，带来了一定的开销和性能的损耗，并降低了程序的扩展性，在并发编程中显然不适用。为此，在.NET Framework 4中提供了System.Collections.Concurrent新的命名空间可以访问用于解决线程安全问题，它们能够解决潜在的死锁问题和竞争条件问题，因此在很多复杂的情形下它们能够使得并行代码更容易编写，这些集合尽 可能减少需要使用锁的次数，从而使得在大部分情形下能够优化为最佳性能，不会产生不必要的同步开销。</p>\n<p>线程安全并不是没有代价的，比起System.Collenctions和System.Collenctions.Generic命名空间中的 列表、集合和数组来说，并发集合会有更大的开销。因此，应该只在需要从多个任务中并发访问集合的时候才使用并发几个，在串行代码中使用并发集合是没有意义 的，因为它们会增加无谓的开销。</p>\n<p>通过这个命名空间能访问以下为并发做好了准备的集合。</p>\n<p><strong>1.BlockingCollection</strong> 与经典的阻塞队列数据结构类似，能够适用于多个任务添加和删除数据，提供阻塞和限界能力。</p>\n<p><strong>2.ConcurrentBag</strong> 提供对象的线程安全的无序集合</p>\n<p><strong>3.ConcurrentDictionary </strong> 提供可有多个线程同时访问的键值对的线程安全集合</p>\n<p><strong>4.ConcurrentQueue  </strong> 提供线程安全的先进先出集合</p>\n<p><strong>5.ConcurrentStack  </strong> 提供线程安全的后进先出集合</p>\n<p>这些集合通过使用比较并交换和内存屏障等技术，避免使用典型的互斥重量级的锁，从而保证线程安全和性能。</p>\n<pre><code>      _ConcurrenProducts = new ConcurrentQueue&lt;Product&gt;();\n      /*创建任务 tk1  tk1 执行 数据集合添加操作*/\n      Task tk1 = Task.Factory.StartNew(() =&gt;\n      {\n        AddConcurrenProducts();\n      });\n    Task.WaitAll(tk1);</code></pre>\n<pre><code class=\"language-cs\">/*执行集合数据添加操作*/\n    static void AddConcurrenProducts()\n    {\n      Parallel.For(0, 30000, (i) =&gt;\n      {\n        Product product = new Product();\n        product.Name = \"name\" + i;\n        product.Category = \"Category\" + i;\n        product.SellPrice = i;\n        _ConcurrenProducts.Enqueue(product);\n      });\n\n    }\n</code></pre>\n<p>在处理的List集合数据时，可将其放到<code>ConcurrentQueue</code>中，然后开启多个线程去处理数据，处理完成后，再到队列中获取下一个待处理数据。</p>\n<pre><code>/// &lt;summary&gt;\n/// 多线程处理数据（无返回值）\n/// &lt;/summary&gt;\n/// &lt;typeparam name=\"T\"&gt;数据类型&lt;/typeparam&gt;\n/// &lt;param name=\"list\"&gt;待处理数据&lt;/param&gt;\n/// &lt;param name=\"action\"&gt;数据处理方法（有参数无返回值）&lt;/param&gt;\n/// &lt;param name=\"count\"&gt;处理线程数量&lt;/param&gt;\n/// &lt;param name=\"waitFlag\"&gt;是否等待执行结束&lt;/param&gt;\nstatic void RunTask&lt;T&gt;(List&lt;T&gt; list, Action&lt;T&gt; action, int threadCount = 5, bool waitFlag = true)\n{\n  ConcurrentQueue&lt;T&gt; queue = new ConcurrentQueue&lt;T&gt;(list);\n  Task[] tasks = new Task[threadCount];\n  for (int i = 0; i &lt; threadCount; i++)\n  {\n     tasks[i] = Task.Factory.StartNew(() =&gt;\n     {\n       while (queue.TryDequeue(out T t))\n       {\n         action(t);\n       }\n     });\n  }\n  if (waitFlag)\n  {\n    Task.WaitAll(tasks);\n  }\n}\n\n/// &lt;summary&gt;\n/// 多线程处理数据（返回处理后列表）\n/// &lt;/summary&gt;\n/// &lt;typeparam name=\"T\"&gt;数据类型&lt;/typeparam&gt;\n/// &lt;param name=\"list\"&gt;待处理数据&lt;/param&gt;\n/// &lt;param name=\"func\"&gt;数据处理方法（有参数有返回值）&lt;/param&gt;\n/// &lt;param name=\"threadCount\"&gt;处理线程数量&lt;/param&gt;\n/// &lt;returns&gt;数据处理后结果&lt;/returns&gt;\nstatic List&lt;T&gt; RunTask&lt;T&gt;(List&lt;T&gt; list, Func&lt;T, T&gt; func, int threadCount = 5)\n{\n  var result = new List&lt;T&gt;();\n  ConcurrentQueue&lt;T&gt; queue = new ConcurrentQueue&lt;T&gt;(list);\n  Task&lt;List&lt;T&gt;&gt;[] tasks = new Task&lt;List&lt;T&gt;&gt;[threadCount];\n  for (int i = 0; i &lt; threadCount; i++)\n  {\n    tasks[i] = Task.Factory.StartNew&lt;List&lt;T&gt;&gt;(() =&gt;\n    {\n      var rList = new List&lt;T&gt;();\n      while (queue.TryDequeue(out T t))\n      {\n        rList.Add(func(t));\n      }\n      return rList;\n    });\n  }\n  Task.WaitAll(tasks);\n  for (int i = 0; i &lt; threadCount; i++)\n  {\n    result.AddRange(tasks[i].Result);\n  }\n  return result;\n}</code></pre>\n<p></p>\n</div>\n</div>"}