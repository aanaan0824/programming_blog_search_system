{"blogid": "122262815", "writerAge": "码龄14年", "writerBlogNum": "31", "writerCollect": "82", "writerComment": "26", "writerFan": "2370", "writerGrade": "2级", "writerIntegral": "363", "writerName": "冀石程序猿", "writerProfileAdress": "writer_image\\profile_122262815.jpg", "writerRankTotal": "63951", "writerRankWeekly": "4587", "writerThumb": "47", "writerVisitNum": "38096", "blog_read_count": "1491", "blog_time": "于 2021-12-31 22:57:50 发布", "blog_title": "C# 串口SerialPort控件", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>串口对于工控领域应用较为广泛，串口通讯类型主要分为RS-232，RS-485。</p>\n<p>RS-232 也称标准串口，最常用的一种串行通讯接口。目前常用为9芯D型插座（DB9），在两台电脑之间通讯需要用到D行头的端子（2、3、5），分别为读、写、信号地。在两台电脑通讯时需要对信号端子2和3进行对调，一端的写“端子3”对应另一端的读“端子2”，信号地端子直连即可，接线图如下。</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\405857a4b1b267930bd04c270361e1e4.png\"/></p>\n<p></p>\n<p>目前，大部分的笔记本已经不在配置RS-232物理串口，如何在计算机进行串口程序调试，就需要用到vspd虚拟串口软件，用这个软件可以在电脑上虚拟出来串口，虚拟出的可以1对1进行绑定。</p>\n<p><img alt=\"\" height=\"405\" src=\"image\\6b00b0c0d42d4022ba7b1b6d9997e56e.png\" width=\"620\"/></p>\n<p>此软件可以添加、删除、重置端口，上图已经增加了3对串口，COM1~COM2，COM3~COM4，COM5~COM6，可以相互通讯，这样就能在笔记本上进行串口程序的调试，工具<a href=\"https://download.csdn.net/download/evint888/72609188\" title=\"VSPD6.9.zip-网络设备文档类资源-CSDN下载\">VSPD6.9.zip-网络设备文档类资源-CSDN下载</a>。</p>\n<p>下面进行C# SerialPort介绍</p>\n<p><img alt=\"\" height=\"400\" src=\"image\\b7df9385fd1f4d778e8b854cdf08c8fd.png\" width=\"433\"/></p>\n<p>1、BaudRate：波特率，两个串口之间通讯，需要两端的波特率设置一致，否则，数据接收会出现乱码，如果波特率不同，串口也能接收到数据，知识分析内容不一致；波特率越高，传输距离就越短，当波特率为115200时，保证数据完整，需要线长小于10m，如果线距过大会造成误码的情况，传输效率会降低。</p>\n<p>2、PortName：串口名称，在windows计算机下，串口的命名都是以COM开头，串口1则为COM1，以此类推，串口10即为COM10，由于C#加Mono，可使C#程序运行在Linux主机上，SerialPort控件时支持跨平台的，但是在linux下，串口命名/dev/ttyS0,即填写对应名称在PortName上即可，此属性string类型。</p>\n<p>3、IsOpen：是否打开，通过此属性进行串口打开的判断。</p>\n<p>4、BytesToRead：串口读缓冲中的字节数，通过此属性判断是否有数据。</p>\n<p>5、Close()方法：用来关闭串口，当程序退出时，需要对串口进行关闭。</p>\n<p>6、Open()方法：用来打开串口，当串口打开时，即可进行数据发送和接收。</p>\n<p>7、Write()方法：用来写串口数据，传输数据使用byte[]数组和长度。</p>\n<p>8、Read()方法：用BytesToRead的长度从读缓冲区中读取数据到byte[]数组中，当执行Read()方法后，缓冲区数据同时清空。</p>\n<p>下面对SerialPort控件进行封装，对发送数据增加头、尾、校验，防止传输过程中数据丢失，代码见下图。</p>\n<pre><code class=\"language-cs\">    public class SerialPortClass\n    {\n        /// &lt;summary&gt;\n        /// 串口组件\n        /// &lt;/summary&gt;\n        private SerialPort serialPort = new SerialPort();\n        /// &lt;summary&gt;\n        /// 是否启动线程\n        /// &lt;/summary&gt;\n        private bool IsStart = false;\n        /// &lt;summary&gt;\n        /// 数据列表\n        /// &lt;/summary&gt;\n        public List&lt;byte&gt; DataList = new List&lt;byte&gt;();\n        /// &lt;summary&gt;\n        /// 缓冲区列表\n        /// &lt;/summary&gt;\n        private List&lt;byte&gt; buffer = new List&lt;byte&gt;();\n        /// &lt;summary&gt;\n        /// 串口名称\n        /// &lt;/summary&gt;\n        public string PortName = \"COM1\";\n        /// &lt;summary&gt;\n        /// 初始化\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"_portname\"&gt;&lt;/param&gt;\n        public SerialPortClass()\n        {\n            try\n            {\n                ReadParam();\n                serialPort.Close();\n                serialPort.PortName = PortName;\n                serialPort.BaudRate = 9600;\n            }\n            catch (Exception ex)\n            {\n                LogHelper.Debug(ex);\n            }\n        }\n\n        public void ReadParam()\n        {\n            try\n            {\n                PortName = ConfigurationManager.AppSettings[\"PortName\"];\n            }\n            catch (Exception ex)\n            {\n                LogHelper.Debug(ex);\n            }\n\n        }\n        /// &lt;summary&gt;\n        /// 打开串口\n        /// &lt;/summary&gt;\n        /// &lt;returns&gt;&lt;/returns&gt;\n        public bool OpenCom()\n        {\n            bool Ret = false;\n            try\n            {\n                CloseCom();\n                if (!serialPort.IsOpen)\n                {\n                    serialPort.Open();\n                    DataList.Clear();\n                    Ret = true;\n                }\n            }\n            catch (Exception ex)\n            {\n                LogHelper.Debug(ex);\n            }\n            return Ret;\n        }\n        /// &lt;summary&gt;\n        /// 关闭串口\n        /// &lt;/summary&gt;\n        public void CloseCom()\n        {\n            try\n            {\n                serialPort.Close();\n            }\n            catch (Exception ex)\n            {\n                LogHelper.Debug(ex);\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// 启动任务\n        /// &lt;/summary&gt;\n        public void StartTask()\n        {\n            try\n            {\n                IsStart = true;\n                Thread task = new Thread(new ThreadStart(Run));\n                task.IsBackground = true;\n                task.Start();\n            }\n            catch (Exception ex)\n            {\n                LogHelper.Debug(ex);\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// 停止任务\n        /// &lt;/summary&gt;\n        public void StopTask()\n        {\n            try\n            {\n                IsStart = false;\n            }\n            catch (Exception ex)\n            {\n                LogHelper.Debug(ex);\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// 读取数据\n        /// &lt;/summary&gt;\n        private void Run()\n        {\n            while (true)\n            {\n                if (!IsStart) break;\n                try\n                {\n                    if (serialPort.IsOpen)\n                    {\n                        int count = serialPort.BytesToRead;\n                        if (count &gt; 0)\n                        {\n                            byte[] buf = new byte[count];\n                            serialPort.Read(buf, 0, count);\n                            buffer.AddRange(buf);\n                            while (buffer.Count &gt;= 2)\n                            {\n                                if (buffer[0] == 0x02) //帧头\n                                {\n                                    int len = buffer[1]; //长度\n                                    if (buffer.Count &lt; len + 4)     //完整数据为帧长+4   头1 长度1 命令 校验1 尾1\n                                    {                               //                   02    01   A     X  03\n                                        break;\n                                    }\n                                    byte sum = 0;\n                                    for (int i = 1; i &lt; len + 2; i++) //校验\n                                    {\n                                        sum += buffer[i];\n                                    }\n                                    if (buffer[len + 3] == 0x03 &amp;&amp; buffer[len + 2] == sum)\n                                    {\n                                        if (DataList.IndexOf(buffer[len + 1]) &lt; 0)\n                                            DataList.Add(buffer[len + 1]);\n                                    }\n                                    buffer.RemoveRange(0, len + 4);\n                                }\n                                else\n                                {\n                                    buffer.RemoveAt(0);\n                                }\n                            }\n                        }\n                    }\n                }\n                catch (Exception ex)\n                {\n                    LogHelper.Debug(ex);\n                }\n                Thread.Sleep(10);\n            }\n        }\n\n        public void SendBuff(byte _order)\n        {\n            try\n            {\n                if (serialPort.IsOpen)\n                {\n                    byte[] buff = new byte[5];\n                    buff[0] = 0x02;\n                    buff[1] = 0x01;\n                    buff[2] = _order;\n                    byte sum = buff[1];\n                    sum += buff[2];\n                    buff[3] = sum;\n                    buff[4] = 0x03;\n                    serialPort.Write(buff, 0, buff.Length);\n                }\n            }\n            catch (Exception ex)\n            {\n                LogHelper.Debug(ex);\n            }\n        }\n   }</code></pre>\n<p></p>\n<p></p>\n</div>\n</div>"}