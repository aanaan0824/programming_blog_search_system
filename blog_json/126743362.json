{"blogid": "126743362", "writerAge": "码龄24天", "writerBlogNum": "50", "writerCollect": "0", "writerComment": "1", "writerFan": "16", "writerGrade": "3级", "writerIntegral": "510", "writerName": "web17508858916", "writerProfileAdress": "writer_image\\profile_126743362.jpg", "writerRankTotal": "40691", "writerRankWeekly": "11999", "writerThumb": "0", "writerVisitNum": "1755", "blog_read_count": "11", "blog_time": "于 2022-09-07 12:50:09 发布", "blog_title": "JVM 方法内联", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p><strong>1. 函数的调用过程。</strong></p>\n<p>调用某个函数实际上将程序执行顺序转移到该函数所存放在内存中某个地址，将函数的程序内容执行完后，再返回到转去执行该函数前的地方。<br/> 这种转移操作要求在转去前要保护现场并记忆执行的地址，转回后先要恢复现场，并按原来保存地址继续执行。也就是通常说的<strong>压栈</strong>和<strong>出栈</strong>。<br/> 因此，函数调用要有一定的时间和空间方面的开销。那么对于那些函数体代码不是很大，又频繁调用的函数来说，这个时间和空间的消耗会很大。</p>\n<p><strong>2. 内联函数</strong><br/> 那怎么解决这个性能消耗问题呢，这个时候需要引入内联函数了。<strong>内联函数就是在程序编译时，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体来直接进行替换</strong>。显然，这样就不会产生转去转回的问题，但是由于在编译时将函数体中的代码被替代到程序中，因此会增加目标程序代码量，进而增加空间开销，而在时间代销上不象函数调用时那么大，可见它是以目标代码的增加为代价来换取时间的节省。</p>\n<pre><code>写C代码时，我们都学到将一些简短的逻辑定义在宏里。这样做的好处是，在编译器编译的时候会将用到该宏的地方直接用宏的代码替换。这样就不再需要象调用方法那样的压栈、出栈，传参了。性能上提升了。内联函数的处理方式与宏类似，但与宏又有所不同，内联函数拥有函数的本身特性（类型、作用域等等）。在C++里有个内联函数，使用inline关键字修饰。另外，写在Class定义内的函数也会被编译器视为内联函数。 \n</code></pre>\n<p><strong>3. JVM内联函数</strong></p>\n<p>C++是否为内联函数由自己决定，Java由编译器决定。Java不支持直接声明为内联函数的，如果想让他内联，你只能够向编译器提出请求: 关键字final修饰 用来指明那个函数是希望被JVM内联的，例：</p>\n<pre><code>public final void doSomething() {  \n        // to do something  \n}  \n</code></pre>\n<p>总的来说，一般的函数都不会被当做内联函数，只有声明了final后，编译器才会考虑是不是要把你的函数变成内联函数。</p>\n<p>JVM内建有许多运行时优化。<strong>首先短方法更利于JVM推断</strong>。流程更明显，作用域更短，副作用也更明显。<strong>如果是长方法JVM可能直接就跪了</strong>。第二个原因则更重要：方法内联<br/> <strong>如果JVM监测到一些小方法被频繁的执行，它会把方法的调用替换成方法体本身</strong>。比如说下面这个：</p>\n<pre><code>private int add4(int x1, int x2, int x3, int x4) {  \n        return add2(x1, x2) + add2(x3, x4);  \n    }  \n\n    private int add2(int x1, int x2) {  \n        return x1 + x2;  \n    }  \n</code></pre>\n<p>运行一段时间后JVM会把add2方法去掉，并把你的代码翻译成：</p>\n<pre><code>private int add4(int x1, int x2, int x3, int x4) {  \n        return x1 + x2 + x3 + x4;  \n    }\n</code></pre>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}