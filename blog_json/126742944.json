{"blogid": "126742944", "writerAge": "码龄5年", "writerBlogNum": "58", "writerCollect": "10", "writerComment": "1", "writerFan": "3", "writerGrade": "3级", "writerIntegral": "574", "writerName": "悠玄烛远", "writerProfileAdress": "writer_image\\profile_126742944.jpg", "writerRankTotal": "33301", "writerRankWeekly": "11561", "writerThumb": "6", "writerVisitNum": "14933", "blog_read_count": "12", "blog_time": "已于 2022-09-07 12:38:18 修改", "blog_title": "【编程规范】 后端API接口设计编写与文档编写参考", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-tomorrow-night\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p></p>\n<div class=\"toc\">\n<h3>文章目录</h3>\n<ul><li><ul><li><a href=\"#0__5\">0 统一规范</a></li><li><ul><li><a href=\"#01__7\">0.1 理清业务流程</a></li><li><a href=\"#02__11\">0.2 定义前后端开发的接口规范</a></li><li><a href=\"#03__23\">0.3 定义接口文档</a></li></ul>\n</li><li><a href=\"#1__43\">1 后端接口编写</a></li><li><ul><li><a href=\"#10__47\">1.0 后端接口介绍</a></li><li><ul><li><a href=\"#101__49\">1.0.1 接口交互</a></li><li><a href=\"#102__57\">1.0.2 返回格式</a></li><li><a href=\"#103_CODE_67\">1.0.3 CODE状态码</a></li><li><a href=\"#104_MessageMsg_91\">1.0.4 Message（Msg）</a></li><li><a href=\"#105_DATA_95\">1.0.5 DATA</a></li></ul>\n</li><li><a href=\"#11__99\">1.1 数据校验与异常处理</a></li><li><ul><li><a href=\"#111__101\">1.1.1 参数校验设计</a></li><li><a href=\"#112__153\">1.1.2 全局异常处理</a></li><li><a href=\"#113__181\">1.1.3 自定义异常</a></li></ul>\n</li><li><a href=\"#12__218\">1.2 数据统一响应</a></li><li><ul><li><a href=\"#121__224\">1.2.1 自定义统一响应体</a></li><li><a href=\"#122__305\">1.2.2 响应码枚举</a></li><li><a href=\"#123__368\">1.2.3 全局处理响应数据</a></li></ul>\n</li><li><a href=\"#13__409\">1.3 其他返回数据</a></li></ul>\n</li><li><a href=\"#2__434\">2 接口设计参考</a></li><li><ul><li><a href=\"#21__436\">2.1 接口设计原则</a></li><li><ul><li><a href=\"#211__442\">2.1.1 数据有效性校验</a></li><li><a href=\"#212__452\">2.1.2 幂等设计</a></li><li><a href=\"#213__474\">2.1.3 数据加密</a></li><li><a href=\"#214__478\">2.1.4 时间戳机制</a></li></ul>\n</li><li><a href=\"#22__483\">2.2 设计规范</a></li><li><ul><li><a href=\"#221_URL_514\">2.2.1 URL设计</a></li><li><a href=\"#222__542\">2.2.2 返回值设计</a></li><li><a href=\"#223_RESTful_API_579\">2.2.3 非RESTful API需求</a></li><li><a href=\"#224__591\">2.2.4 字段命名规范</a></li></ul>\n</li></ul>\n</li><li><a href=\"#3__597\">3 文档编写</a></li><li><ul><li><a href=\"#31__603\">3.1 简单版本</a></li><li><ul><li><a href=\"#311__613\">3.1.1 目录格式</a></li><li><a href=\"#312__623\">3.1.2 案例模板</a></li><li><ul><li><a href=\"#_627\">接口说明</a></li><li><a href=\"#_651\">请求示例</a></li><li><a href=\"#_671\">请求参数说明</a></li><li><a href=\"#_681\">响应示例</a></li><li><a href=\"#_705\">响应参数说明</a></li></ul>\n</li></ul>\n</li><li><a href=\"#32__714\">3.2 复杂版本</a></li><li><ul><li><a href=\"#321__718\">3.2.1 目录格式</a></li><li><a href=\"#322__774\">3.2.2 案例模板</a></li><li><ul><li><a href=\"#_776\">封面</a></li><li><a href=\"#_790\">文档信息</a></li><li><a href=\"#_808\">版本历史</a></li><li><a href=\"#_818\">目录</a></li><li><a href=\"#_825\">文档具体内容部分</a></li><li><ul><li><a href=\"#_833\">编写目的</a></li><li><a href=\"#_837\">对接准备事项</a></li><li><a href=\"#___845\">使用协议 + 规范</a></li><li><a href=\"#_849\">报文规范</a></li><li><a href=\"#_863\">加解密规范</a></li><li><a href=\"#_891\">业务接口</a></li></ul>\n</li><li><a href=\"#_906\">附录</a></li></ul>\n</li></ul>\n</li></ul>\n</li><li><a href=\"#_910\">参考文档</a></li></ul>\n</li></ul>\n</div>\n<br/> 在一个新型的web应用中，由于中台只负责数据的输送，不涉及具体业务，所以就需要搭建一个业务服务来组装业务数据，把 浏览器/客户端 和中台连接起来。业务服务将组装完的数据以统一的数据格式返回给客户端，这里就需要对业务服务后台接口进行统一设计。下面就来具体介绍一下如何设计和编写后端接口。\n<p></p>\n<h2><a id=\"0__5\"></a>0 统一规范</h2>\n<h3><a id=\"01__7\"></a>0.1 理清业务流程</h3>\n<p>通过需求文档，描述清楚业务流程，定义好相关的设计规范。根据项目大小划分好前台和后台的功能需求，通过需求来得到对应的模块。</p>\n<h3><a id=\"02__11\"></a>0.2 定义前后端开发的接口规范</h3>\n<p>一般前后端分离项目会拥有不同的数据格式，例如 json、url等。 这里要通过文档的形式同前后端一起确定好数据阐述的格式。</p>\n<p>接口地址：不包含接口BASE地址。</p>\n<p>请求方式: get、post、put、delete等。</p>\n<p>请求参数：数据格式（默认json）、数据类型、是否必填、中文描述。</p>\n<p>响应参数：类型、中文描述。</p>\n<h3><a id=\"03__23\"></a>0.3 定义接口文档</h3>\n<p>这里的接口文档一般就是对应后台的实体，即RequestVo（调用后台接口访问的实体）和给往前端的ResponseVo（前台调用接口时前往的实体）。一般来说ResponseVo都会在后台做一个统一的处理为ResultVo。</p>\n<p>对于ResultVo的规范需要在上一节中定义好，例如：错误码Code，错误描述msg，请求的url，以及实体泛型T。</p>\n<p>需要注意的是，这里定义的接口文档实在彻底了解号数据流、业务流的基础之上完成的。</p>\n<p>尽量采用自动化接口文档，可以做到在线测试，同步更新。 文档中应包含：接口BASE地址、接口版本、接口模块分类等。</p>\n<p>有了这个接口文档之后（实质上就是定义实体的过程和对应的json），前后端的开发基本根据这个文档去开发。在实际的项目业务中，接口文档会产生版本的迭代，这个时候我们会需要将它放到<strong>版本管理器</strong>中，不论你用的是git亦或者是svn。</p>\n<p>注：除了以上描述的，我们的项目中还有redis，mongoDB，elasticsearch等。这些都是在非常了解业务的状况和系统架构下去设计的。后台运用这些工具去完成接口功能的实现以及系统功能和性能的实现。</p>\n<h2><a id=\"1__43\"></a>1 后端接口编写</h2>\n<p>主要是对RESTful接口设计做一个介绍。</p>\n<h3><a id=\"10__47\"></a>1.0 后端接口介绍</h3>\n<h4><a id=\"101__49\"></a>1.0.1 接口交互</h4>\n<p>前端和后端进行交互，前端按照约定请求URL路径，并传入相关参数，后端服务器接收<br/> 请求，进行业务处理，返回数据给前端。</p>\n<p>针对URL路径的restful风格，以及传入参数的公共请求头的要求（如：app_version,api_version,device等)，这里就不介绍了,小伙伴们可以自行去了解，也比较简单。</p>\n<h4><a id=\"102__57\"></a>1.0.2 返回格式</h4>\n<p>在 0.2小节 中我们提到了会把ResponseVo 处理为一个统一的ResultVo。</p>\n<p>这个ResultVo大致由4个部分组成，分别 是接口请求地址（url）、接口请求方式（get/post）、请求数据（request）、响应数据（response）。</p>\n<p>在前端的眼中，拿到的数据就会长这样，也就是我们所理解的返回格式。</p>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-iPfV1rRu-1662523338889)(C:\\Users\\Hasee\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220906214352990.png)]</p>\n<h4><a id=\"103_CODE_67\"></a>1.0.3 CODE状态码</h4>\n<p>一般来说没有明确的规范要求，具体是看开发时需要什么就添加什么。</p>\n<p>例如，我们要提示前端用户权限不足，那么我们返回的状态码就可以定义为 <strong>403</strong> ；如果我们要告诉前端的数据参数异常，我们就可以把返回的状态码定义成 <strong>102</strong> 。具体的状态码细节可以参考http请求返回的状态码。</p>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-V9VfIYYH-1662523338892)(C:\\Users\\Hasee\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220906215237691.png)]</p>\n<table><thead><tr><th>分类</th><th>区间</th><th>分类描述</th></tr></thead><tbody><tr><td>1**</td><td>100~199</td><td>信息，服务器收到请求，需要请求者继续执行操作</td></tr><tr><td>2**</td><td>200~299</td><td>成功，操作被成功接收并处理</td></tr><tr><td>3**</td><td>300~399</td><td>重定向，需要进一步的操作以完成请求</td></tr><tr><td>4**</td><td>400~499</td><td>客户端错误，请求包含语法错误或无法完成请求</td></tr><tr><td>5**</td><td>500~599</td><td>服务器错误，服务器在处理请求的过程中发生了错误</td></tr></tbody></table>\n<p>具体可以参考这篇文章：<a href=\"https://www.php.cn/faq/453229.html\">HTTP状态码有哪些分类？</a></p>\n<p>同样我们可以这么设计：</p>\n<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-AMuiZ7de-1662523338893)(C:\\Users\\Hasee\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220906215907754.png)]</p>\n<p>这样设计的好处是可以把错误类型归类到某个区间内，如果区间不够，可以设计成4位数。 这样前端开发人员在得到返回值后，根据状态码就可以知道，大概什么错误，再根据msg相关的信息描述，可以快速定位。</p>\n<h4><a id=\"104_MessageMsg_91\"></a>1.0.4 Message（Msg）</h4>\n<p>这个字段相对理解比较简单，就是发生错误时，如何友好的进行提示。一般的设计是和code状态码一起设计。</p>\n<h4><a id=\"105_DATA_95\"></a>1.0.5 DATA</h4>\n<p>返回数据体，json格式，根据不同的业务又不同的json体。一般来说返回给前端时会结合msg、code一起返回。</p>\n<h3><a id=\"11__99\"></a>1.1 数据校验与异常处理</h3>\n<h4><a id=\"111__101\"></a>1.1.1 参数校验设计</h4>\n<p>我们先来看一段数据校验的代码：</p>\n<pre><code class=\"prism language-java\"><span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">addUser</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">User</span> user<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n     <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">.</span><span class=\"token function\">getId</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">||</span> user<span class=\"token punctuation\">.</span><span class=\"token function\">getAccount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">||</span> user<span class=\"token punctuation\">.</span><span class=\"token function\">getPassword</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span> <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n         <span class=\"token keyword\">return</span> <span class=\"token string\">\"对象或者对象字段不能为空\"</span><span class=\"token punctuation\">;</span>\n     <span class=\"token punctuation\">}</span>\n     <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">StringUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">.</span><span class=\"token function\">getAccount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> <span class=\"token class-name\">StringUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">.</span><span class=\"token function\">getPassword</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n         <span class=\"token keyword\">return</span> <span class=\"token string\">\"不能输入空字符串\"</span><span class=\"token punctuation\">;</span>\n     <span class=\"token punctuation\">}</span>\n     <span class=\"token comment\">// 参数校验完毕后这里就写上业务逻辑</span>\n     <span class=\"token keyword\">return</span> <span class=\"token string\">\"success\"</span><span class=\"token punctuation\">;</span>\n <span class=\"token punctuation\">}</span>\n</code></pre>\n<p>是不是感觉比较熟悉，在最开始不熟悉开发的时候，都会这么写过。虽然我们阅读这段代码对参数的校验是没有问题的，而且排版也还看得过去。但是每个接口都这么写显然会看的比较繁琐。而且还没到业务处理，参数校验的代码就这么多了，显然会让人头大。</p>\n<p>在我们引入的依赖 spring-boot-starter-web 中包含了 <strong>Validator</strong> ，它可以非常方便的定制校验规则，并自动完成校验。只需要在需要校验的字段加上对应的注解即可，message后面填校验失败后的信息。</p>\n<pre><code class=\"prism language-java\"><span class=\"token annotation punctuation\">@NotNull</span><span class=\"token punctuation\">(</span>message <span class=\"token operator\">=</span> <span class=\"token string\">\"xxx\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token annotation punctuation\">@Size</span><span class=\"token punctuation\">(</span>min<span class=\"token operator\">=</span><span class=\"token operator\">*</span><span class=\"token punctuation\">,</span> max<span class=\"token operator\">=</span><span class=\"token operator\">*</span><span class=\"token punctuation\">,</span> message <span class=\"token operator\">=</span> <span class=\"token string\">\"xxx\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">//下面这个注解适用于邮箱验证</span>\n<span class=\"token annotation punctuation\">@Email</span><span class=\"token punctuation\">(</span>message<span class=\"token operator\">=</span><span class=\"token string\">\"xxx\"</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<p>校验规则和错误提示信息配置完毕后，接下来只需要在接口中需要校验的参数上加上@Valid 注解，并添加BindResult参数即可方便完成验证。</p>\n<p>BindResult作用：如果有参数校验失败，会将错误信息封装成对象组装在BindingResult里</p>\n<p>当然，每个接口中都添加BindResult显然会比较繁琐，我们完全可以把BindResult去掉</p>\n<p>例如：</p>\n<pre><code class=\"prism language-Java\">@RestController\npublic class UserController {\n    @Autowired\n    private UserService userService;\n\t@RequestMapping(\"user\")\n    public String addUser(@RequestBody @Valid User user,) {\n        return userService.addUser(user);\n    }\n}\n</code></pre>\n<h4><a id=\"112__153\"></a>1.1.2 全局异常处理</h4>\n<p>如果我们接口向上一节那么写，就会发现这样就把所有的问题都响应到前端了，解决这个问题的办法就是使用全局异常处理。</p>\n<p>由于参数校验会自动引发异常，我们就不用再去手动捕捉异常进行处理，这个时候我们就可以用spring boot全局异常处理。</p>\n<p>首先，我们需要新建一个<strong>ExceptionControllerAdvice类</strong>，在这个类上加上**@ControllerAdvice或@RestControllerAdvice注解**，这个类就配置成全局处理类了。（这个根据你的Controller层用的是@Controller还是@RestController来决定）</p>\n<p>然后在类中新建方法，在方法上加上**@ExceptionHandler注解**并指定你想处理的异常类型，接着在方法内编写对该异常的操作逻辑，就完成了对该异常的全局处理。</p>\n<p>例如：</p>\n<pre><code class=\"prism language-java\"><span class=\"token annotation punctuation\">@RestControllerAdvice</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ExceptionControllerAdvice</span> <span class=\"token punctuation\">{<!-- --></span>\n\n    <span class=\"token annotation punctuation\">@ExceptionHandler</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">MethodArgumentNotValidException</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token class-name\">MethodArgumentNotValidExceptionHandler</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">MethodArgumentNotValidException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token comment\">// 从异常对象中拿到ObjectError对象</span>\n        <span class=\"token class-name\">ObjectError</span> objectError <span class=\"token operator\">=</span> e<span class=\"token punctuation\">.</span><span class=\"token function\">getBindingResult</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getAllErrors</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// 然后提取错误提示信息进行返回</span>\n        <span class=\"token keyword\">return</span> objectError<span class=\"token punctuation\">.</span><span class=\"token function\">getDefaultMessage</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4><a id=\"113__181\"></a>1.1.3 自定义异常</h4>\n<p>我们在 1.0.1小节 中了解了返回格式的写法，我们自定义异常也可以参考这一小节来编写。</p>\n<pre><code class=\"prism language-Java\">@Getter //只要getter方法，无需setter\npublic class APIException extends RuntimeException {\n    private int code;\n    private String msg;\n\n    public APIException() {\n        this(1001, \"接口错误\");\n    }\n    public APIException(String msg) {\n        this(1001, msg);\n    }\n    public APIException(int code, String msg) {\n        super(msg);\n        this.code = code;\n        this.msg = msg;\n    }\n}\n\n</code></pre>\n<p>当然，我们也需要在全局异常类中添加上我们对自定义异常的处理。</p>\n<pre><code class=\"prism language-java\"><span class=\"token annotation punctuation\">@ExceptionHandler</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">APIException</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token class-name\">APIExceptionHandler</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">APIException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">return</span> e<span class=\"token punctuation\">.</span><span class=\"token function\">getMsg</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n</code></pre>\n<p>这样就对异常的处理就比较规范了，当然还可以添加对Exception的处理，这样无论发生什么异常我们都能屏蔽掉然后响应数据给前端，不过建议最后项目上线时这样做，能够屏蔽掉错误信息暴露给前端，在开发中为了方便调试还是不要这样做。</p>\n<h3><a id=\"12__218\"></a>1.2 数据统一响应</h3>\n<p>在上一大节中，我们对全局异常处理和自定义异常已经处理完毕，但是当我们抛出自定义异常的时候，全局异常处理只响应了异常中的错误信息msg给前端，并没有将错误代码code返回。这里就要说到数据统一响应了。</p>\n<p>我们尽管对参数校验方式和异常处理方式做好了规范，但是对响应数据没有做好规范。</p>\n<h4><a id=\"121__224\"></a>1.2.1 自定义统一响应体</h4>\n<p>统一数据响应第一步肯定要做的就是我们自己自定义一个响应体类，无论后台是运行正常还是发生异常，响应给前端的数据格式是不变的。</p>\n<p>可以参考我们自定义异常类，也来一个响应信息代码code和响应信息说明msg。</p>\n<pre><code class=\"prism language-java\"><span class=\"token annotation punctuation\">@JsonInclude</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">JsonInclude<span class=\"token punctuation\">.</span>Include</span><span class=\"token punctuation\">.</span>NON_NULL<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ResultVo</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">&gt;</span></span> <span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token comment\">/**\n\t * 状态码\n\t */</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">Integer</span> code<span class=\"token punctuation\">;</span>\n\t<span class=\"token comment\">/**\n\t * 提示信息，如果有错误时，前端可以获取该字段进行提示\n\t */</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> msg<span class=\"token punctuation\">;</span>\n\t<span class=\"token comment\">/**\n\t * 查询到的结果数据，\n\t */</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">T</span> data<span class=\"token punctuation\">;</span>\n    \n\t<span class=\"token keyword\">public</span> <span class=\"token class-name\">ResponseResult</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Integer</span> code<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> msg<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n\t\t<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>code <span class=\"token operator\">=</span> code<span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>msg <span class=\"token operator\">=</span>msg<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> \n\t<span class=\"token keyword\">public</span> <span class=\"token class-name\">ResponseResult</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Integer</span> code<span class=\"token punctuation\">,</span> <span class=\"token class-name\">T</span> data<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n\t\t<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>code <span class=\"token operator\">=</span> code<span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>data <span class=\"token operator\">=</span> data<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">Integer</span> <span class=\"token function\">getCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n\t\t<span class=\"token keyword\">return</span> code<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\t<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setCode</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Integer</span> code<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n\t\t<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>code <span class=\"token operator\">=</span> code<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\t<span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">getMsg</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n\t\t<span class=\"token keyword\">return</span> msg<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n\t<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setMsg</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> msg<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n\t\t<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>msg <span class=\"token operator\">=</span>msg<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\t<span class=\"token keyword\">public</span> <span class=\"token class-name\">T</span> <span class=\"token function\">getData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n\t\t<span class=\"token keyword\">return</span> data<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\t<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setData</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">T</span> data<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n\t\t<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>data <span class=\"token operator\">=</span> data<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\t<span class=\"token keyword\">public</span> <span class=\"token class-name\">ResultVo</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Integer</span> code<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> msg<span class=\"token punctuation\">,</span> <span class=\"token class-name\">T</span> data<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n\t\t<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>code <span class=\"token operator\">=</span> code<span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>msg <span class=\"token operator\">=</span>msg<span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>data <span class=\"token operator\">=</span> data<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>然后我们修改全局异常处理的返回值：</p>\n<pre><code class=\"prism language-java\"><span class=\"token annotation punctuation\">@ExceptionHandler</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">APIException</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token class-name\">ResultVO</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">&gt;</span></span> <span class=\"token class-name\">APIExceptionHandler</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">APIException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token comment\">// 注意哦，这里返回类型是自定义响应体</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ResultVO</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">&gt;</span></span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span><span class=\"token function\">getCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"响应失败\"</span><span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">.</span><span class=\"token function\">getMsg</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token annotation punctuation\">@ExceptionHandler</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">MethodArgumentNotValidException</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token class-name\">ResultVO</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">&gt;</span></span> <span class=\"token class-name\">MethodArgumentNotValidExceptionHandler</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">MethodArgumentNotValidException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token class-name\">ObjectError</span> objectError <span class=\"token operator\">=</span> e<span class=\"token punctuation\">.</span><span class=\"token function\">getBindingResult</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getAllErrors</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 注意哦，这里返回类型是自定义响应体</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ResultVO</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">&gt;</span></span><span class=\"token punctuation\">(</span><span class=\"token number\">1001</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"参数校验失败\"</span><span class=\"token punctuation\">,</span> objectError<span class=\"token punctuation\">.</span><span class=\"token function\">getDefaultMessage</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n</code></pre>\n<p>通过上面的操作，我们将状态码和响应说明还有错误提示数据都返给了前端，并且是所有异常都会返回相同的格式。</p>\n<p>这样无论是正确响应还是发生异常，响应数据的格式都是统一的。</p>\n<p>数据格式规范好了，不过响应码code和响应信息msg还没有规范。所以，必须要将响应码和响应信息给规范起来。</p>\n<h4><a id=\"122__305\"></a>1.2.2 响应码枚举</h4>\n<p>要规范响应体中的响应码和响应信息我们使用枚举是最好的。Java中自带了枚举类型，我们可以依据枚举类型创建一个响应码枚举类。</p>\n<pre><code class=\"prism language-Java\">@Getter\npublic enum ResultCode {\n\n    private int code;\n    private String msg;\n\n    ResultCode(int code, String msg) {\n        this.code = code;\n        this.msg = msg;\n    }\n    //这里的状态码依据项目实际情况自行定义，不必照搬\n    SUCCESS(1000, \"操作成功\"),\n\n    FAILED(1001, \"响应失败\"),\n\n    VALIDATE_FAILED(1002, \"参数校验失败\"),\n\n    ERROR(5000, \"未知错误\");\n\n}\n\n</code></pre>\n<p>我们还要把状态码和信息就会一一对应，这样比较好维护。</p>\n<p>这里要修改响应体的构造方法，让其只准接受响应码枚举来设置响应码和响应信息。</p>\n<pre><code class=\"prism language-java\"><span class=\"token keyword\">public</span> <span class=\"token class-name\">ResultVO</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">T</span> data<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token comment\">//这里的SUCCESS依据自己定义的ResultCode来替换</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ResultCode</span><span class=\"token punctuation\">.</span>SUCCESS<span class=\"token punctuation\">,</span> data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token class-name\">ResultVO</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ResultCode</span> resultCode<span class=\"token punctuation\">,</span> <span class=\"token class-name\">T</span> data<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>code <span class=\"token operator\">=</span> resultCode<span class=\"token punctuation\">.</span><span class=\"token function\">getCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>msg <span class=\"token operator\">=</span> resultCode<span class=\"token punctuation\">.</span><span class=\"token function\">getMsg</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>data <span class=\"token operator\">=</span> data<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n</code></pre>\n<p>同时我们还应当对全局异常处理的响应码设置方式进行修改：</p>\n<pre><code class=\"prism language-Java\">@ExceptionHandler(APIException.class)\npublic ResultVO&lt;String&gt; APIExceptionHandler(APIException e) {\n    // 注意哦，这里传递的响应码枚举\n    return new ResultVO&lt;&gt;(ResultCode.FAILED, e.getMsg());\n}\n\n@ExceptionHandler(MethodArgumentNotValidException.class)\npublic ResultVO&lt;String&gt; MethodArgumentNotValidExceptionHandler(MethodArgumentNotValidException e) {\n    ObjectError objectError = e.getBindingResult().getAllErrors().get(0);\n    // 注意哦，这里传递的响应码枚举\n    return new ResultVO&lt;&gt;(ResultCode.VALIDATE_FAILED, objectError.getDefaultMessage());\n}\n</code></pre>\n<h4><a id=\"123__368\"></a>1.2.3 全局处理响应数据</h4>\n<p>既然我们对响应数据做了处理，也对异常做了统一返回响应体，我们可以用一个全局处理来把省略掉用响应体包装接口返回数据。</p>\n<p>我们同样是像全局异常处理一样，定义一个全局处理类 <strong>ResponseControllerAdvice</strong> 继承 <strong>ResponseBodyAdvice</strong> 接口并重写其中的方法。</p>\n<pre><code class=\"prism language-java\"><span class=\"token comment\">// 注意，这里要加上需要扫描的包，即项目的controller包</span>\n<span class=\"token annotation punctuation\">@RestControllerAdvice</span><span class=\"token punctuation\">(</span>basePackages <span class=\"token operator\">=</span> <span class=\"token punctuation\">{<!-- --></span><span class=\"token string\">\"xxx\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> \n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ResponseControllerAdvice</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">ResponseBodyAdvice</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Object</span><span class=\"token punctuation\">&gt;</span></span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">supports</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">MethodParameter</span> returnType<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Class</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">HttpMessageConverter</span><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">&gt;</span><span class=\"token punctuation\">&gt;</span></span> aClass<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token comment\">// 如果接口返回的类型本身就是ResultVO那就没有必要进行额外的操作，返回false</span>\n        <span class=\"token keyword\">return</span> <span class=\"token operator\">!</span>returnType<span class=\"token punctuation\">.</span><span class=\"token function\">getGenericParameterType</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ResultVO</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">Object</span> <span class=\"token function\">beforeBodyWrite</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> data<span class=\"token punctuation\">,</span> <span class=\"token class-name\">MethodParameter</span> returnType<span class=\"token punctuation\">,</span> <span class=\"token class-name\">MediaType</span> mediaType<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Class</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">HttpMessageConverter</span><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">&gt;</span><span class=\"token punctuation\">&gt;</span></span> aClass<span class=\"token punctuation\">,</span> <span class=\"token class-name\">ServerHttpRequest</span> request<span class=\"token punctuation\">,</span> <span class=\"token class-name\">ServerHttpResponse</span> response<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token comment\">// String类型不能直接包装，所以要进行些特别的处理</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>returnType<span class=\"token punctuation\">.</span><span class=\"token function\">getGenericParameterType</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n            <span class=\"token class-name\">ObjectMapper</span> objectMapper <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ObjectMapper</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{<!-- --></span>\n                <span class=\"token comment\">// 将数据包装在ResultVO里后，再转换为json字符串响应给前端</span>\n                <span class=\"token keyword\">return</span> objectMapper<span class=\"token punctuation\">.</span><span class=\"token function\">writeValueAsString</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">ResultVO</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">&gt;</span></span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">JsonProcessingException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n                <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">APIException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"返回String类型错误\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token comment\">// 将原本的数据包装在ResultVO里</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ResultVO</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">&gt;</span></span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n</code></pre>\n<p>重写的这两个方法是用来在controller将数据进行返回前进行增强操作，supports方法要<strong>返回为true才会执行beforeBodyWrite方法</strong>，所以如果有些情况不需要进行增强操作可以在supports方法里进行判断。</p>\n<p>对返回数据进行真正的操作还是<strong>在beforeBodyWrite方法</strong>中，我们可以直接在该方法里包装数据，这样就不需要每个接口都进行数据包装了，省去了很多麻烦。</p>\n<p>这样尽管我们没有在接口中包装数据，但返回给前端的依然是经过包装后的数据。</p>\n<h3><a id=\"13__409\"></a>1.3 其他返回数据</h3>\n<p>在上一节中，我们得到了一个统一响应体ResultVo，里面具有code、msg、data。</p>\n<p>如果返回给前端的数据，要求给出分页信息，那么ResponsePages类中，还需要有Page类，其中至少包括当前页数，每页显示条数和总条数信息。分页使用github的pagehelper工具类来完成。</p>\n<pre><code class=\"prism language-json\">http返回对象示例：\n<span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token literal-property property\">code</span><span class=\"token operator\">:</span> code<span class=\"token punctuation\">,</span>\n    <span class=\"token literal-property property\">msg</span><span class=\"token operator\">:</span> msg<span class=\"token punctuation\">,</span>\n    <span class=\"token literal-property property\">pageInfo</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{<!-- --></span>         <span class=\"token comment\">// 分页信息</span>\n        <span class=\"token literal-property property\">curPage</span><span class=\"token operator\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>\n        <span class=\"token literal-property property\">pageLimit</span><span class=\"token operator\">:</span> <span class=\"token number\">10</span><span class=\"token punctuation\">,</span>\n        <span class=\"token literal-property property\">page</span><span class=\"token operator\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>\n        <span class=\"token literal-property property\">total</span><span class=\"token operator\">:</span> <span class=\"token number\">10</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token literal-property property\">data</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{<!-- --></span>data<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>很多时候我们往往需要多种返回数据，例如添加返回分页信息，我们可以灵活的根据业务需求修改ResultVo，但是切记不要在项目进行到中段时再反复修改，一定要在项目开始时就确立，这就是接口开发文档存在的意义。</p>\n<h2><a id=\"2__434\"></a>2 接口设计参考</h2>\n<h3><a id=\"21__436\"></a>2.1 接口设计原则</h3>\n<p>参考面向对象原则，接口设计也有六大原则，分别是单一职责原则、里氏替换原则、依赖倒置原则、接口隔离原则、迪米特法则、开闭原则。</p>\n<p>接下来介绍一些其他的设计原则。</p>\n<h4><a id=\"211__442\"></a>2.1.1 数据有效性校验</h4>\n<p>常规性校验：包括必填字段，长度检测。格式校验等。</p>\n<p>鉴权校验：当前请求必须符合权限等。</p>\n<p>业务校验：根据实际业务而定，比如订单金额不能小于0等等。</p>\n<p>作用：在接口层做用户鉴权校验和参数校验，比如做ID基础校验，id&lt;0 直接拦截这样就很有效的能够解决恶意请求从而导致缓存击穿的问题。这里有一个小细节，就是我们开发的时候要保持一个不信任的心，就是不要相信任何的调用方，比如你提供了一个API接口出去，有几个参数。我觉得作为被调用方，任何可能的参数都应该被考虑到去做校验。因为你不相信任何调用你的人，你不知道她会传什么参数给你。举个简单的例子，如果你的接口是分页查询的，若是你没有对分页参数的大小做限制，调用的人万一一口气查询十万条数据，一次请求就会要好几秒。多几个并发不就挂掉了。</p>\n<h4><a id=\"212__452\"></a>2.1.2 幂等设计</h4>\n<p>幂等的概念： 多次调用对系统的产生的影响是一样的，即对资源的作用是一样的，但是返回值允许不同。</p>\n<p>HTTP的幂等性：</p>\n<p>（1）GET : 只是获取资源，对资源本身并没有副作用。天然的幂等性。</p>\n<p>（2）HEAD: 本质上和GET一样，获取请求头的信息，主要是探活的作用，具有幂等性。</p>\n<p>（3）OPTIONS: 获取当前URL所支持的方法，因此也是具有幂等性的。</p>\n<p>（4）DELETE: 用于资源的删除，具有副作用，但是他应满足幂等性，如根据ID删除某一个资源。调用方法可以调用N次而不用担心出错。</p>\n<p>（5）PUT: 用于资源更新，有副作用，但是他应该满足幂等性，如根据ID更新数据，调用多次和N次的作用是相同的。</p>\n<p>（6）POST: 用于资源添加，多次提交可能产生副作用，比如订单的提交等等。</p>\n<p><strong>如何实现幂等（后端的方法）：</strong></p>\n<p>解决方法为：使用Token。前端向服务端请求一个唯一Token，然后再将Token随表单一起提交。后端拿到请求的时候需要先将请求的Token去除去做校验，只有当Token存在的时候才会获取表单数据进行DB的操作；若是Token压根就不存在就说明已经有了其他线程的请求已经在处理了这个数据，所以这次请求是多余的。</p>\n<h4><a id=\"213__474\"></a>2.1.3 数据加密</h4>\n<p>数据在传输的过程中我们知道资源数据都是直接爆露出口来的，用抓包工具就可以很轻松的修改。所以一般我们会对传输的数据进行加密。常规的做法是对敏感数据（比如用户的身份证号等）做MD5加密。现在主流的做法是使用HTTPS协议，再HTTP和TCP之间添加一层数据安全层（SSL层），这一层负责数据的加密和解密。</p>\n<h4><a id=\"214__478\"></a>2.1.4 时间戳机制</h4>\n<p>尽管数据经过了加密处理，但还是会有人一直进行恶意请求，这个时候的简单做法就是添加时间戳机制，在每次的请求中加入当前时间，服务端对每次请求中的时间（解密之后）与当前系统的时间作对比，看是否在一个固定的时间范围内，比如5s。恶意伪造的数据在没有弄清楚这个混淆时间戳的字段之前，是没办法频繁的更改数据中心的时间的，超过10s就可以当做非法请求了。</p>\n<h3><a id=\"22__483\"></a>2.2 设计规范</h3>\n<p>首先我们要知道，所有的设计考量都应当基于 <strong>减少重复工作，增加可读性可维护性</strong> 出发的。</p>\n<p>由于是在设计API接口，我们就应该符合API的一般模式：</p>\n<pre><code>ResultType ApiName(ParamType )\n\n1. 接口参数，即形参。可以是 string，int，以及其他任意可以称之为参数的东西\n2. 接口返回值。可以是 string，int，以及其他任意可以称之为返回值的东西\n3. 接口名（签名)\n</code></pre>\n<p>那么在RESTful中我们要对应上这个模式：</p>\n<pre><code>HttpResponse URL(HttpRequest)\n\n1. HttpRequest：包括请求头，URL参数，请求body参数\n2. HttpResponse: 包括响应头，响应的body\n</code></pre>\n<p>我们可以总结出一个大概的标准：</p>\n<pre><code>1.接口命名必须要做到清晰。\n2.接口数量，越少越好。\n3.有明确的输入输出总是有返回值，告诉调用端，我到底做了什么，做得怎么样，即：反馈。\n</code></pre>\n<h4><a id=\"221_URL_514\"></a>2.2.1 URL设计</h4>\n<p>应该尽量将API部署在专用域名之下： https://api.example.com</p>\n<p>①具有统一的前缀或者将其版本化。</p>\n<p>版本号分为整型和浮点型 。整型是大功能版本，如v1、v2。浮点型是补充功能版本， 如v1.1、v2.1。</p>\n<pre><code>https://api.example.com/v{n}\n/SERVICE_NAME/v1/users\n或者\n/APP_NAME/v2/users\n</code></pre>\n<p>②url应该尽可能的短小，同一份资源可以由不同的路径。</p>\n<p>③接口的数量越少越好，能合并的接口就尽量合并。</p>\n<pre><code>获取用户列表信息：GET /users\n获取单个用户信息：GET /users/{id}\n\n坦白说，获取一个与获取一批，似乎并没有什么语义上的差别，\n但是后端的同学就不一样了，他可能需要写两个 View Class。\n所以只保留批量的接口，查询一个时，用 URL 参数传递就行了。\n</code></pre>\n<h4><a id=\"222__542\"></a>2.2.2 返回值设计</h4>\n<p>参考 1.2 小节</p>\n<pre><code>Response Headers\n可以做少量文章，如自定义一个Header\n\nStatus Code\n按照基本规范来，该404的404，该200的200\n\nResponse body\n基本都是围绕这个做文章\n</code></pre>\n<pre><code>{\n    是否成功\n    boolean \"is_success\":\n    错误码是多少\n    number|null \"err_code\":\n    错误信息\n    string|null \"err_msg\": \n    错误详情（可选）\n    string|null \"err_detail\":\n    出错的时哪个服务\n    string|null \"provider\": \n    \n    正常返回时的数据\n    \"response_data\": {\n\n    }\n}\n</code></pre>\n<h4><a id=\"223_RESTful_API_579\"></a>2.2.3 非RESTful API需求</h4>\n<p>实际业务开展过程中，可能会出现各种的api不是简单的restful 规范能实现的。需要有一些api突破restful规范原则。特别是移动互联网的api设计，更需要有一些特定的api来优化数据请求的交互。</p>\n<pre><code>删除单个or批量删除： DELETE  /v1/product      body参数{ids：[]}\n\n页面级API:把当前页面中需要用到的所有数据通过一个接口一次性返回全部数据\n</code></pre>\n<h4><a id=\"224__591\"></a>2.2.4 字段命名规范</h4>\n<p>实际上没有很明确的规范，但是尽量跟随数据库的风格，即：下划线风格。 这样，在 序列化整个 Model 时，也许会很方便。参考阿里巴巴开发手册。</p>\n<h2><a id=\"3__597\"></a>3 文档编写</h2>\n<p>在项目开发中，web项目的前后端分离开发，APP开发，需要由前后端工程师共同定义接口，编写接口文档，之后大家都根据这个接口文档进行开发，到项目结束前都要一直维护。</p>\n<p>接口文档在项目开发过程中，使前后端工程师有一个统一的文件进行沟通交流开发；项目维护中或者项目人员更迭，方便后期人员查看、维护。</p>\n<h3><a id=\"31__603\"></a>3.1 简单版本</h3>\n<p>简单的核心就是<strong>怎么简单怎么来，怎么省时间怎么来</strong>。</p>\n<p>如果不知道怎么写，就<strong>把案例写的越详细越好</strong>。</p>\n<p>开发时间是非常宝贵的，而接口对接通常都是一些工期紧张的情况下去快速编写，而且面对一些碎片化的时间工作者，一份简单直观的文档可能更受欢迎。</p>\n<p>另外，接口文档最终形式最好是pdf。</p>\n<h4><a id=\"311__613\"></a>3.1.1 目录格式</h4>\n<pre><code>• 接口说明\n• 请求示例\n• 请求参数说明\n• 响应示例\n• 响应参数说明\n</code></pre>\n<h4><a id=\"312__623\"></a>3.1.2 案例模板</h4>\n<h5><a id=\"_627\"></a>接口说明</h5>\n<p>接口功能：</p>\n<blockquote>\n<p>本接口用于获取用户的token信息。</p>\n</blockquote>\n<p>接口请求地址：</p>\n<pre><code>https: xxx/xxx/xxxx\n复制代码\n</code></pre>\n<p><strong>请求头 :</strong></p>\n<table><thead><tr><th>请求头</th><th>请求内容</th><th>说明</th></tr></thead><tbody><tr><td>Authorization</td><td>Basic secretKey</td><td>访问token</td></tr><tr><td>Content-Type</td><td>application/json</td><td>请求方式</td></tr></tbody></table>\n<p><strong>请求方式：POST</strong></p>\n<p><strong>参数类型：JSON</strong></p>\n<h5><a id=\"_651\"></a>请求示例</h5>\n<p>绝大多数为json，自定义格式</p>\n<pre><code class=\"prism language-json\"><span class=\"token punctuation\">[</span>\n    <span class=\"token punctuation\">{<!-- --></span><span class=\"token string-property property\">\"id\"</span><span class=\"token operator\">:</span><span class=\"token string\">\"20201219\"</span><span class=\"token punctuation\">,</span>\n     <span class=\"token string-property property\">\"name\"</span><span class=\"token operator\">:</span><span class=\"token string\">\"21.59\"</span>，\n     <span class=\"token string-property property\">\"age\"</span><span class=\"token operator\">:</span><span class=\"token string\">\"ftp_1002\"</span>\n     <span class=\"token operator\">...</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">{<!-- --></span><span class=\"token string-property property\">\"id\"</span><span class=\"token operator\">:</span><span class=\"token string\">\"20201219\"</span><span class=\"token punctuation\">,</span>\n     <span class=\"token string-property property\">\"name\"</span><span class=\"token operator\">:</span><span class=\"token string\">\"21.59\"</span>，\n     <span class=\"token string-property property\">\"age\"</span><span class=\"token operator\">:</span><span class=\"token string\">\"ftp_1002\"</span>\n     <span class=\"token operator\">...</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">]</span>\n复制代码\n</code></pre>\n<h5><a id=\"_671\"></a>请求参数说明</h5>\n<table><thead><tr><th>字段名</th><th>字段说明</th><th>字段类型</th><th>是否必填</th></tr></thead><tbody><tr><td>字段1</td><td>说明字段1的作用</td><td>varchar(50)</td><td>是</td></tr><tr><td>字段2</td><td>说明字段2的作用</td><td>int</td><td>是</td></tr><tr><td>字段3</td><td>说明字段3的作用</td><td>decimal</td><td>是</td></tr></tbody></table>\n<h5><a id=\"_681\"></a>响应示例</h5>\n<p>成功响应编码：</p>\n<pre><code class=\"prism language-json\"><span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token string\">\"code: \"</span><span class=\"token number\">200</span>\"<span class=\"token punctuation\">,</span>\n    <span class=\"token string-property property\">\"message\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"请求成功\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string-property property\">\"data\"</span><span class=\"token operator\">:</span> 返回数据，格式自定\n<span class=\"token punctuation\">}</span>\n复制代码\n</code></pre>\n<p>失败响应编码：</p>\n<pre><code class=\"prism language-json\"><span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token string\">\"code: \"</span><span class=\"token number\">200</span>\"<span class=\"token punctuation\">,</span>\n    <span class=\"token string-property property\">\"message\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"请求成功\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string-property property\">\"data\"</span><span class=\"token operator\">:</span> 返回数据，格式自定\n<span class=\"token punctuation\">}</span>\n复制代码\n</code></pre>\n<h5><a id=\"_705\"></a>响应参数说明</h5>\n<table><thead><tr><th><strong>接口返回码</strong></th><th><strong>接口返回描述</strong></th></tr></thead><tbody><tr><td>200</td><td>成功</td></tr><tr><td>400</td><td>请求参数异常</td></tr><tr><td>401</td><td>授权失败</td></tr><tr><td>500</td><td>系统异常</td></tr></tbody></table>\n<h3><a id=\"32__714\"></a>3.2 复杂版本</h3>\n<p>由于不同的公司有不同的文档格式要求，此处只列举一个仅供参考的案例。</p>\n<h4><a id=\"321__718\"></a>3.2.1 目录格式</h4>\n<pre><code>+ 封面\n  + 接口文档名称\n  + 接口版本号\n  + 版权说明\n+ 文档信息\n  + 标题 | 创建时间 | 打印时间 | 文件名 | 存放目录 | 所有者 | 作用\n  + 小题：版权声明\n+ 版本历史（重点1）\n  + \\| 版本号 \\| 日期 \\| 修改者 \\| 描述 \\|\n  + \\| v1.0.0  \\| xxx \\| xxx \\| xxx |\n+ 目录\n  + 结构清晰\n  + 有条理\n  + 能快速定位需要的信息（后文会介绍）\n+ 文档具体内容部分\n  + 编写目的\n  + 对接准备事项\n    + 测试联调\n    + 上线\n  + 使用协议 + 规范\n  + 报文规范\n    + 请求报文规范\n    + 响应报文规范\n  + 接口描述\n    + 报文规范\n      + 请求报文\n      + 响应报文\n      + 公共报文头\n      + 接口码说明\n      + 业务接口\n      + 查询接口\n    + 加解密规范\n      + 原则\n      + 令牌信息\n      + 加密规范\n      + 解密规范\n  + 业务接口\n    + 具体接口1：\n      + 说明\n      + 规范码（查表）\n      + 使用方式\n      + 请求字段\n      + 响应字段\n      + 案例\n    + 具体接口2....\n    ........\n  + 附录\n    + 参考资料1\n    + 参考资料2\n  + 其他.....\n复制代码\n</code></pre>\n<h4><a id=\"322__774\"></a>3.2.2 案例模板</h4>\n<h5><a id=\"_776\"></a>封面</h5>\n<p>封面还是比较重要的，毕竟是打开文档的第一眼内容，下面用阿里的文档作为参考，可以看到封面一般是如下内容：</p>\n<pre><code>公司名称\n\n文档名称\n\n版本号\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\76619419c53f4312814e01091ecd2e15.png\"/></p>\n<h5><a id=\"_790\"></a>文档信息</h5>\n<p>文档信息主要记录这份文件的产生日期以及具体的创建打印日期等。</p>\n<table><thead><tr><th>文档名</th><th>内容</th></tr></thead><tbody><tr><td>标题</td><td>xxx文档</td></tr><tr><td>创建日期</td><td>20xx-xx-xx</td></tr><tr><td>打印日期</td><td>20xx-xx-xx</td></tr><tr><td>文件名</td><td>文档的全名</td></tr><tr><td>存放目录</td><td>文件位置</td></tr><tr><td>所有者</td><td>某某公司</td></tr><tr><td>作者</td><td>xxx</td></tr></tbody></table>\n<blockquote>\n<p>版权声明：（现在这个时代版权是极其重要的）</p>\n<p>xxxx所有，不得三方借阅、出让、出版</p>\n</blockquote>\n<h5><a id=\"_808\"></a>版本历史</h5>\n<p>版本历史是很重要的，每次改动都需要有详细的记录，这样才能保证文档的干净和有效，同时可以方便<strong>review</strong>的时候，对于文档的修订者进行文档审查。</p>\n<table><thead><tr><th>版本号</th><th>日期</th><th>概述</th><th>修订者</th></tr></thead><tbody><tr><td>1.0.0</td><td>20xx-xx-xx</td><td>创建</td><td>xxx</td></tr><tr><td>1.0.1</td><td>20xx-xx-xx</td><td>修改文档第一小节内容</td><td>xxx</td></tr><tr><td>1.0.2</td><td>20xx-xx-xx</td><td>修订文档第四小节的错误描述，更新文档说明</td><td>xxx</td></tr></tbody></table>\n<h5><a id=\"_818\"></a>目录</h5>\n<p>好的文档一定有好的目录，只要按照一定的规范和格式写出来的文档，一般看上去都是十分舒服的。还是用阿里的开发手册做参考</p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\e67c358db61e408cbe43a964ca3b9ef2.png\"/></p>\n<h5><a id=\"_825\"></a>文档具体内容部分</h5>\n<p>这一部分发挥的自由空间就比较大了，不同的业务不同的公司不同的需求不同的人都能写出万千种格式的文档，所以这里也是给一个样例做参考使用。是否有实用价值因人而异。</p>\n<blockquote>\n<p>为了不让整个目录树太长，这里没有做标题说明=-=</p>\n</blockquote>\n<h6><a id=\"_833\"></a>编写目的</h6>\n<p>需要解决什么问题，为什么要这份文档，这份文档有什么参考价值？</p>\n<h6><a id=\"_837\"></a>对接准备事项</h6>\n<p>接口方可以提供什么内容，接口方需要对接方的那些内容，以及提供的其他信息，比如需要对接方提供 <strong>系统应用id</strong>，<strong>系统唯一标识</strong>。向对接方提供密钥等等</p>\n<p>​ 1. <strong>测试联调</strong>：分配测试的密钥，测试环境的账户和密码以及其他信息</p>\n<p>​ 2. <strong>上线</strong>：上线之后需要做什么事情，如：替换生产url，替换生产环境账户密码，替换密钥为生产密钥等等</p>\n<h6><a id=\"___845\"></a>使用协议 + 规范</h6>\n<p>可以是本次对接使用的算法，通信协议，可以是术语说明或者和业务相关的其他说明，以及对接的要求都可以，发挥空间很大，自由设计。</p>\n<h6><a id=\"_849\"></a>报文规范</h6>\n<p>报文规范是接口对接的核心部分，因为对接大部分的时间基本都是花在接口参数调试和请求调试等。所以报文规范算是非常重要的内容。具体内容可以参考简单版本的接口描述，也可以使用目录格式进行对应的描述</p>\n<pre><code>+ 请求报文：主要为请求的Body,以及请求的header内容，一般都是Json的格式，并且要求UTF8编码\n  + 响应报文：返回的格式和内容，也是需要协商的部分\n  + 公共报文头：一般需要重复使用的参数可以作为公共报文头，但是不是所有的公共报文头都是必选，存在可选的参数\n  + 接口码说明：描述接口的注意事项，以及那些字段参数需要重点关注，主要为提示信息\n  + 业务接口：一般表示业务的返回结果，比如统一2000作为报文的成功响应码，其他所有码都是存在对应的接口码表进行设计。\n  + 查询接口：如何才算是表示查询成功，比如一个还钱的接口当中可能是受理中，拒绝或者处理完成，等查询接口的信息描述\n复制代码\n</code></pre>\n<h6><a id=\"_863\"></a>加解密规范</h6>\n<p>也是比较重要的部分，也是比较花时间的地方，需要大量调试来打通接口的地方，存在以下的几个要点。</p>\n<pre><code>原则：接口存在一些简单的原则，比如`非对称加密`，`数字签名`，`时间戳判断有效性`，具体按照接口的原则自由设置\n\n令牌信息：描述令牌是如何生成的，是比较重要的部分，一般由对接双方沟通完成，最好多以案例和代码辅助解释\n\n加密规范：描述接口数据的加密过程，比较重要的内容信息，最好多以案例和代码辅助解释\n\n解密规范：就是解释接口要如何解密，比如需要拿到服务端给过来的配对公钥才能解密，再比如使用签名+参数进行对照加密验证签名是否正确等。\n</code></pre>\n<p><strong>加解密规范参考：</strong></p>\n<p>一般的加密方式，一般情况下做到下面这种形式基本可以屏蔽大部分的攻击：</p>\n<pre><code>1. 按照map的key进行字典排序，同时加入`timetamp`值校验核对时间\n2. 把参数按照一些特殊形式拼接为`key=value&amp;key=value`的形式，末尾带入时间戳或者其他的一些信息，比如应用Id等核实身份的内容\n3. 把这一串按照**AES加密**，然后按照**BASE64编码**，生成一个编码串\n4. 把BASE64编码进行**MD5加密**，加密完成之后，得到固定长度的MD5字符串\n5. 按照md5串+上面的string在进行一次md5加密，生成签名，那么这个签名基本上就唯一的\n</code></pre>\n<h6><a id=\"_891\"></a>业务接口</h6>\n<p>这里基本可以<strong>照抄简单接口模板</strong>，因为接口描述每个人的描述不同，下面给出一些基本上涉及的点，另外，到了这一步就尽量用案例辅助，因为案例可以帮助接口阅读者更快速的上手和理解，注意这一部分的内容：<strong>实用性大于理论性</strong>。</p>\n<p>具体接口：</p>\n<pre><code>1. 说明\n2. 规范码（查表）\n3. 使用方式\n4. 请求字段\n5. 响应字段\n6. 案例\n</code></pre>\n<h5><a id=\"_906\"></a>附录</h5>\n<p>可能这部分和说明书一样基本没人看，所以不做过多的解释，附录不必写的很详细的，这里可以随意施展。</p>\n<h2><a id=\"_910\"></a>参考文档</h2>\n<p>1.<a href=\"https://blog.csdn.net/zxd1435513775/article/details/109008081\">CSDN_如何设计和编写标准的后端接口</a><br/> 2.<a href=\"https://my.oschina.net/qqlet/blog/1922038\">开源博客_API 接口规范</a><br/> 3.<a href=\"https://blog.csdn.net/IT_LanTian/article/details/122223723\">CSDN_什么是接口文档，如何写接口，有什么规范？</a></p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}