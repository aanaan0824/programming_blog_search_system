{"blogid": "126171737", "writerAge": "码龄1年", "writerBlogNum": "642", "writerCollect": "582", "writerComment": "77", "writerFan": "1725", "writerGrade": "6级", "writerIntegral": "7525", "writerName": "Java技术那些事儿", "writerProfileAdress": "writer_image\\profile_126171737.jpg", "writerRankTotal": "2136", "writerRankWeekly": "1531", "writerThumb": "144", "writerVisitNum": "143191", "blog_read_count": "3125", "blog_time": "于 2022-08-05 09:59:19 发布", "blog_title": "MyBatis是什么？使用它作为持久层框架有什么优点？", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p class=\"img-center\"><img alt=\"\" src=\"image\\99604cc8867cc5fce26838d69cbd45e1.png\"/></p>\n<hr/>\n<h1>一、前言</h1>\n<p>在阅读本篇文章之前，我先提问一下：</p>\n<ul><li>mybatis映射文件、核心配置文件、properties配置文件、日志文件到底在这个框架中各自的功能是什么？它们在文件夹中的位置该如何设定？</li><li>resultMap、resultType有什么不同？什么时候要使用它们？</li><li>遇到像模糊查询时，我们该如何正确操作？</li><li> <h1>{} 、${} 之间的区别是什么？各自使用的情景是什么？</h1> </li><li>mybatis缓存是什么？</li><li>分步查询会不会？</li><li>...</li></ul>\n<p>废话不多说，满满的干货，赶快来看看吧~</p>\n<h1>二、基本介绍</h1>\n<p>一句话总结一下，MyBatis是一个基于Java的持久层框架，是一个半自动的ORM框架。那么可爱的它具有哪些很好的特性呢？</p>\n<ul><li>支持定制化 SQL、存储过程以及高级映射</li><li>避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集的操作</li><li>可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO(实体类)映射成数据库中的记录</li></ul>\n<p>那么它有哪些优点呢？</p>\n<ul><li>轻量级，性能出色</li><li>SQL 和 Java 编码分开，功能边界清晰。Java代码专注业务、SQL语句专注数据</li></ul>\n<p>好了，了解这些就差不多了，接下来进入Mybatis的知识世界！</p>\n<h1>三、搭建开发环境</h1>\n<p>首先要做的就是引入依赖，具体的<code>pom.xml</code>如下：</p>\n<pre><code>  &lt;packaging&gt;jar&lt;/packaging&gt;\n    &lt;dependencies&gt; &lt;!-- Mybatis核心 --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;\n            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;\n            &lt;version&gt;3.5.7&lt;/version&gt;\n        &lt;/dependency&gt; &lt;!-- junit测试 --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;junit&lt;/groupId&gt;\n            &lt;artifactId&gt;junit&lt;/artifactId&gt;\n            &lt;version&gt;4.12&lt;/version&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n        &lt;/dependency&gt; &lt;!-- MySQL驱动 --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;mysql&lt;/groupId&gt;\n            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n            &lt;version&gt;8.0.28&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\n            &lt;artifactId&gt;lombok&lt;/artifactId&gt;\n            &lt;version&gt;1.18.10&lt;/version&gt;\n        &lt;/dependency&gt;&lt;!-- log4j日志 --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;log4j&lt;/groupId&gt;\n            &lt;artifactId&gt;log4j&lt;/artifactId&gt;\n            &lt;version&gt;1.2.17&lt;/version&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n\n</code></pre>\n<p>这里需要注意的就是MySQL的驱动依赖了，我直接跟着视频走，使用的是版本5.7，结果可想而知，报错了，呜呜呜~</p>\n<p>接着就是创建实体类、mapper接口、核心配置文件、映射文件，我给大家依次演示一下如何使用：</p>\n<p>实体类：与数据库字段相关联，这个数据库在我的石墨文档第一个位置，大家可以自己运行一下SQL代码试一试</p>\n<pre><code>@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class User {\n    private Integer id;\n    private String username;\n    private String password;\n    private Integer age;\n    private String sex;\n    private String email;\n}\n\n</code></pre>\n<p>mapper接口：可以从官方文档中找案例复制下来——<a href=\"https://link.juejin.cn/?target=https%3A%2F%2Fmybatis.org%2Fmybatis-3%2Fgetting-started.html\" title=\"Mybatis官方文档\">Mybatis官方文档</a></p>\n<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;\n&lt;!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;\n&lt;mapper namespace=\"com.cabbage.mappers.UserMapper\"&gt;\n&lt;/mapper&gt;\n\n</code></pre>\n<p>核心配置文件：跟mapper接口一样，也可以从官方中复制下来</p>\n<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;\n&lt;!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;\n&lt;configuration&gt;\n    &lt;properties resource=\"jdbc.properties\"/&gt;\n    &lt;typeAliases&gt;\n        &lt;package name=\"com.cabbage.pojo\"/&gt;\n    &lt;/typeAliases&gt;\n    &lt;environments default=\"development\"&gt;\n        &lt;environment id=\"development\"&gt;\n            &lt;transactionManager type=\"JDBC\"/&gt;\n            &lt;dataSource type=\"POOLED\"&gt;\n                &lt;property name=\"driver\" value=\"${jdbc.driver}\"/&gt;\n                &lt;property name=\"url\" value=\"${jdbc.url}\"/&gt;\n                &lt;property name=\"username\" value=\"${jdbc.username}\"/&gt;\n                &lt;property name=\"password\" value=\"${jdbc.password}\"/&gt;\n            &lt;/dataSource&gt;\n        &lt;/environment&gt;\n    &lt;/environments&gt;\n    &lt;mappers&gt;\n        &lt;!--&lt;mapper resource=\"mappers/UserMapper.xml\"/&gt;--&gt;\n        &lt;package name=\"com.cabbage.mappers\"/&gt;\n    &lt;/mappers&gt;\n&lt;/configuration&gt;\n\n</code></pre>\n<p>最后再来一个日记文件记录信息以及jdbc.properties配置文件</p>\n<p>日志文件：可以当做是一种模板</p>\n<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE log4j:configuration SYSTEM \"log4j.dtd\"&gt;\n&lt;log4j:configuration xmlns:log4j=\"http://jakarta.apache.org/log4j/\"&gt;\n    &lt;appender name=\"STDOUT\" class=\"org.apache.log4j.ConsoleAppender\"&gt;\n        &lt;param name=\"Encoding\" value=\"UTF-8\"/&gt;\n        &lt;layout class=\"org.apache.log4j.PatternLayout\"&gt;\n            &lt;param name=\"ConversionPattern\" value=\"%-5p %d{MM-dd HH:mm:ss,SSS} %m (%F:%L) \\n\"/&gt;\n        &lt;/layout&gt;\n    &lt;/appender&gt;\n    &lt;logger name=\"java.sql\"&gt;\n        &lt;level value=\"debug\"/&gt;\n    &lt;/logger&gt;\n    &lt;logger name=\"org.apache.ibatis\"&gt;\n        &lt;level value=\"info\"/&gt;\n    &lt;/logger&gt;\n    &lt;root&gt;\n        &lt;level value=\"debug\"/&gt;\n        &lt;appender-ref ref=\"STDOUT\"/&gt;\n    &lt;/root&gt;\n&lt;/log4j:configuration&gt;\n\n</code></pre>\n<p><code>jdbc.properties</code>配置文件：配置数据库的连接信息——用户名、密码等等</p>\n<pre><code>jdbc.driver=com.mysql.cj.jdbc.Driver\njdbc.url=jdbc:mysql://localhost:3306/mybatis\njdbc.username=\njdbc.password=\n\n</code></pre>\n<p></p>\n<p></p>\n<p>说了这么多配置文件，大家估计都懵了，这些文件各自放在什么目录下呢？大家可以参考一下我的位置</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\0648829e0ec8393b4b3a48078f89c229.png\"/></p>\n<blockquote>\n<p>好了，各位小伙伴们，基本的环境搭建已经完成了，熟悉mybatis的小伙伴们看到这些文件中的属性，也知道各自是什么功能；不知道的小伙伴也不要着急，从案例中慢慢就会解密他们的各自功能以及使用方法。</p>\n</blockquote>\n<h1>四、核心配置文件</h1>\n<p>让我们回过头来看看刚才搭建的核心配置文件，如何使用？</p>\n<ul><li>1、<code>&lt;properties/&gt;</code> <p class=\"img-center\"><img alt=\"\" src=\"image\\7c25074ce5babbf205e0108692147045.png\"/></p> </li></ul>\n<ul><li>2、<code>&lt;typeAliases&gt;&lt;/typeAliases&gt;</code> <p class=\"img-center\"><img alt=\"\" src=\"image\\552c1280145a32b773c4cd1e518fc555.png\"/></p> </li></ul>\n<ul><li> <p>3、<code>&lt;mappers&gt;&lt;/mappers&gt;</code></p> <p class=\"img-center\"><img alt=\"\" src=\"image\\e590fa9243e9fd4ec2510a9e21bfa655.png\"/></p> <p></p> <p>需要特别注意的是：在<code>resources</code>文件夹下建包时，格式应该是下图的样式</p> <p class=\"img-center\"><img alt=\"\" src=\"image\\223101eb773ead6091d9b7db6ceeabcb.png\"/></p> <p></p> </li></ul>\n<h1>五、mapper映射文件</h1>\n<p>先看一下映射文件的命名规则：</p>\n<ul><li>表所对应的实体类的<code>类名+Mapper.xml</code></li></ul>\n<blockquote>\n<p>例如：表t_user，映射的实体类为User，所对应的映射文件为UserMapper.xml 因此一个映射文件对应一个实体类，对应一张表的操作</p>\n</blockquote>\n<ul><li>MyBatis映射文件用于编写SQL，访问以及操作表中的数据</li><li>MyBatis映射文件存放的位置是<code>src/main/resources/mappers目录</code>下</li></ul>\n<p>此外，MyBatis中可以面向接口操作数据，要保证两个一致：</p>\n<ul><li>mapper接口的全类名和映射文件的命名空间<code>（namespace）</code>保持一致</li><li>mapper接口中方法的方法名和映射文件中编写SQL的标签的id属性保持一致</li></ul>\n<p>写一个代码演示一下：查询表中id=3的user</p>\n<pre><code>    &lt;!--User selectById();--&gt;\n    &lt;select id=\"selectById\" resultType=\"User\"&gt;\n        SELECT * FROM t_user WHERE id = 3\n    &lt;/select&gt;\n\n</code></pre>\n<pre><code>public interface UserMapper {\n    User selectById();\n}\n\n</code></pre>\n<p></p>\n<p></p>\n<p>运行结果完全正确：</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\6a8714ace59b3b0a905b1599cef76378.png\"/></p>\n<p>需要注意的是：</p>\n<ul><li>查询的标签select必须设置属性<code>resultType</code>或<code>resultMap</code>，用于设置实体类和数据库表的映射</li><li>resultType：自动映射，用于属性名和表中字段名一致的情况</li><li>resultMap：自定义映射，用于一对多或多对一或字段名和属性名不一致的情况，这个后面就会讲到</li><li>当查询的数据为多条时，不能使用实体类作为返回值，只能使用集合，否则会抛出异常<code>TooManyResultsException；</code>但是若查询的数据只有一条，可以使用实体类或集合作为返回值</li></ul>\n<h1>六、参数值的两种方式（重点）</h1>\n<ul><li> <p>MyBatis获取参数值的两种方式：<code>${}和#{}</code></p> </li><li> <p>${}的本质就是<code>字符串拼接</code>，#{}的本质就是<code>占位符赋值</code></p> </li><li> <p>${}使用字符串拼接的方式拼接sql，若为字符串类型或日期类型的字段进行赋值时，需要手动加单引号；但是#{}使用占位符赋值的方式拼接sql，此时为字符串类型或日期类型的字段进行赋值时，可以自动添加单引号</p> </li></ul>\n<p>在学习中，原本把参数值分为五种情况，最后介绍了注解<code>@Param</code>的使用，最后就把这五种情况归纳为两种情况，那就来介绍这两种情况吧！</p>\n<ul><li>1、实体类类型参数</li><li>2、使用@Param标识参数，使用该注解时，以@Param注解的值为键，以参数为值，或者以param1、param2为键，以参数为值</li></ul>\n<blockquote>\n<p>下面找一些具有代表性的代码，方便以后的回忆，小伙伴们也可以看看这些代码是否还知道是什么意思呀，测试代码就不写了</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\03ca843aafea84c0e66034fa318248de.png\"/></p>\n</blockquote>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\bd98699f947e22dea0fc273afea48b2d.png\"/></p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\2d2b2e68a68115e6d23d75d9d988a510.png\"/></p>\n<h1>七、select的重点介绍</h1>\n<pre><code>    查询单个数据，这个很简单了\n    &lt;!--Integer getCount();--&gt;\n    &lt;select id=\"getCount\" resultType=\"integer\"&gt;\n        select count(*) from t_user\n    &lt;/select&gt;\n\n    查询一条数据为map集合，会把查询到的一个对象封装在map中\n    &lt;!--Map&lt;String,Object&gt; getUserByIdToMap(@Param(\"id\") Integer id);--&gt;\n    &lt;select id=\"getUserByIdToMap\" resultType=\"map\"&gt;\n        select * from t_user where id = #{id}\n    &lt;/select&gt;\n\n    查询所有数据放入到map集合中\n//方式一：    List&lt;Map&lt;String,Object&gt;&gt; getAllUsersToMap();\n    @MapKey(\"id\")，&lt;!--把id当做map的键，查询的对象作为值返回过来--&gt;\n    Map&lt;String, Object&gt; getAllUsersToMap();\n\n</code></pre>\n<p>对<code>查询所有数据放入到map集合中</code>这种方式，进行代码测试一下：</p>\n<pre><code>    @Test\n    public void test4() throws IOException {\n        SqlSession sqlSession = GetSqlSession.getSqlSession();\n        UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n//        List&lt;Map&lt;String, Object&gt;&gt; mapList = mapper.getAllUsersToMap();\n        Map&lt;String, Object&gt; map = mapper.getAllUsersToMap();\n//        System.out.println(mapList);\n        System.out.println(map);\n    }\n\n</code></pre>\n<p></p>\n<p></p>\n<p>看一下查询的部分结果：</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\7e5d21e8660353cf34efc82fc95da109.png\"/></p>\n<h1>八、特殊SQL的查询</h1>\n<ul><li>1、<code>模糊查询</code></li></ul>\n<pre><code>    &lt;!--List&lt;User&gt; getUserByLike(@Param(\"username\") String username);--&gt;\n    &lt;select id=\"getUserByLike\" resultType=\"User\"&gt;\n        select * from t_user where username like \"%\"#{username}\"%\"\n    &lt;/select&gt;\n\n</code></pre>\n<ul><li>2、<code>批量删除</code></li></ul>\n<pre><code>    &lt;!--Integer deleteMore(@Param(\"ids\") String ids);--&gt;\n    &lt;delete id=\"deleteMore\"&gt;\n        delete from t_user where id in (${ids})\n    &lt;/delete&gt;\n</code></pre>\n<p><strong>代码演示一下：</strong></p>\n<pre><code>    @Test\n    public void test2() throws IOException {\n        SqlSession sqlSession = GetSqlSession.getSqlSession();\n        SQLMapper mapper = sqlSession.getMapper(SQLMapper.class);\n        Integer result = mapper.deleteMore(\"7,8,9\");\n        System.out.println(result);\n    }\n复制代码\n</code></pre>\n<p>运行结果： [图片上传失败...(image-4c6888-1659663334477)]</p>\n<ul><li>3、<code>动态设置表名</code></li></ul>\n<pre><code>    &lt;!--List&lt;User&gt; getAllUserByTableName(@Param(\"tableName\") String tableName);--&gt;\n    &lt;select id=\"getAllUserByTableName\" resultType=\"User\"&gt;\n        select * from ${tableName}\n    &lt;/select&gt;\n\n</code></pre>\n<ul><li>4、<code>添加功能获取自增的主键</code></li></ul>\n<pre><code>    &lt;!--int insertUser(User user);\n    useGeneratedKeys：设置使用自增的主键 \n    keyProperty：因为增删改有统一的返回值是受影响的行数，\n    因此只能将获取的自增的主键放在传输的参数user对象的某个属性中\n--&gt;\n    &lt;insert id=\"insertUser\" useGeneratedKeys=\"true\" keyProperty=\"id\"&gt;\n        insert into t_user values (null,#{username},#{password},#{age},#{sex},#{email})\n    &lt;/insert&gt;\n    &lt;!--这句话是什么意思呢？也就是说加入一个user对象的同时\n    ，把该对象的自增键的值赋给id，通过调用getter方法拿到id值--&gt;\n\n</code></pre>\n<p><strong>代码演示一下：</strong></p>\n<pre><code>    @Test\n    public void test4() throws IOException {\n        SqlSession sqlSession = GetSqlSession.getSqlSession();\n        SQLMapper mapper = sqlSession.getMapper(SQLMapper.class);\n        User user = new User(null, \"cabbage8\"\n                , \"123454\", 23, \"男\"\n                , \"cabbage8@qq.com\");\n        int result = mapper.insertUser(user);\n        System.out.println(result);\n        System.out.println(user.getId());\n    }\n\n</code></pre>\n<p><strong>运行结果：</strong></p>\n<p class=\"img-center\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/img_convert/0b8e2eaa11e3756ab58d3051599e5336.webp?x-oss-process=image/format,png\"/></p>\n<p></p>\n<h1>九、自定义resultMap</h1>\n<ul><li>1、<code>resultMap处理字段和属性的映射关系</code>，若字段名和实体类中的属性名不一致，则可以通过resultMap设置自定义映射</li></ul>\n<pre><code>    &lt;resultMap id=\"mapEmp\" type=\"Emp\"&gt;\n        &lt;id property=\"eid\" column=\"eid\"/&gt;\n        &lt;result property=\"empName\" column=\"emp_name\"/&gt;\n    &lt;/resultMap&gt;\n    &lt;!--List&lt;Emp&gt; getAllEmp();--&gt;\n    &lt;select id=\"getAllEmp\" resultMap=\"mapEmp\"&gt;\n        select eid,emp_name,age,sex,email,did from t_emp\n--或者select eid,emp_name empName,age,sex,email,did from t_emp\n    &lt;/select&gt;\n\n</code></pre>\n<blockquote>\n<p><code>resultMap：设置自定义映射属性：</code></p>\n<ul><li>id：表示自定义映射的唯一标识</li><li>type：查询的数据要映射的实体类的类型子标签：</li><li>id：设置主键的映射关系</li></ul>\n<p><code>result：设置普通字段的映射关系</code></p>\n<ul><li>property：设置映射关系中实体类中的属性名</li><li>column：设置映射关系中表中的字段名</li></ul>\n</blockquote>\n<p>当然，若字段名和实体类中的属性名不一致，但是字段名符合数据库的规则（使用<em>），实体类中的属性名符合Java的规则（使用驼峰）时，<code>可以在MyBatis的核心配置文件中设置一个全局配置信息mapUnderscoreToCamelCase，</code>在查询表中数据时，自动将</em>类型的字段名转换为驼峰 例如：字段名user_name，设置了<code>mapUnderscoreToCamelCase</code>，此时字段名就会转换为userName</p>\n<ul><li>2、<code>多对一映射处理</code>，这是重点！</li></ul>\n<p>我们需要修改一下核心配置文件的内容，添加一些配置（这些配置在官方文档中都有介绍）：</p>\n<pre><code>    &lt;settings&gt;\n        &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/&gt;\n        &lt;!--开启延迟加载--&gt;\n        &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt;\n    &lt;/settings&gt;\n\n</code></pre>\n<p>三种方式的介绍：</p>\n<pre><code>    &lt;!--Emp getEmpAndDept(@Param(\"eid\") Integer eid);--&gt;\n    &lt;!--方式一：级联属性赋值--&gt;\n    &lt;resultMap id=\"getEmpAndDeptMap1\" type=\"Emp\"&gt;\n        &lt;id property=\"eid\" column=\"eid\"/&gt;\n        &lt;result property=\"empName\" column=\"emp_name\"/&gt;\n        &lt;result property=\"dept.did\" column=\"did\"/&gt;\n        &lt;result property=\"dept.deptName\" column=\"dept_name\"/&gt;\n    &lt;/resultMap&gt;\n    &lt;!--方式二：association解决映射关系--&gt;\n    &lt;resultMap id=\"getEmpAndDeptMap2\" type=\"Emp\"&gt;\n        &lt;id property=\"eid\" column=\"eid\"/&gt;\n        &lt;result property=\"empName\" column=\"emp_name\"/&gt;\n        &lt;association property=\"dept\" javaType=\"Dept\"&gt;\n            &lt;result property=\"did\" column=\"did\"/&gt;\n            &lt;result property=\"deptName\" column=\"dept_name\"/&gt;\n        &lt;/association&gt;\n    &lt;/resultMap&gt;\n    &lt;!--方式三：分步查询--&gt;\n    &lt;!--\n    select:设置分步查询的SQL的唯一标识（namespace.方法名）\n    column：设置分步的查询条件\n    fetchType:当开启了全局的延迟加载之后，可通过此属性手动控制延迟加载的效果\n    eager，立即加载；lazy，懒加载\n    --&gt;\n    &lt;resultMap id=\"getEmpAndDeptByStepMap\" type=\"Emp\"&gt;\n        &lt;id property=\"eid\" column=\"eid\"/&gt;\n        &lt;result property=\"empName\" column=\"emp_name\"/&gt;\n        &lt;association property=\"dept\"\n                     select=\"com.cabbage.mappers.DeptMapper.getEmpAndDeptByStepTwo\"\n                     column=\"did\"\n                     fetchType=\"eager\"&gt;\n        &lt;/association&gt;\n    &lt;/resultMap&gt;\n    &lt;!--Emp getEmpAndDeptByStepOne(@Param(\"eid\") Integer eid);--&gt;\n    &lt;select id=\"getEmpAndDeptByStepOne\" resultMap=\"getEmpAndDeptByStepMap\"&gt;\n        select * from t_emp where eid = #{eid}\n    &lt;/select&gt;\n\n</code></pre>\n<p>方式三中<code>DeptMapper.xml</code>对应的分步查询的第二步：</p>\n<pre><code>    &lt;!--Dept getEmpAndDeptByStepTwo(@Param(\"did\") Integer did);--&gt;\n    &lt;select id=\"getEmpAndDeptByStepTwo\" resultType=\"Dept\"&gt;\n        select * from t_dept where did = #{did}\n    &lt;/select&gt;\n\n</code></pre>\n<blockquote>\n<p>老师说，方式三在实际开发中使用的最多，方式三是一种懒加载，那咱们就测试一下方式三：</p>\n</blockquote>\n<pre><code>    @Test\n    public void test3() throws IOException {\n        SqlSession sqlSession = SqlSessionUtil.getSqlSession();\n        EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);\n        Emp emp = mapper.getEmpAndDeptByStepOne(1);\n        System.out.println(emp.getEmpName());\n        System.out.println(\"----------------\");\n        System.out.println(emp.getDept());\n    }\n\n</code></pre>\n<p><strong>运行结果：</strong></p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\ed679de42c3db14ce28b53c77e4b9cba.png\"/></p>\n<p></p>\n<p><strong>我们把eager改成lazy后的运行结果：</strong></p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\562eaf24215fb1d687a662c921835168.png\"/></p>\n<p></p>\n<ul><li>3、<code>一对多映射处理</code>，这是重点！</li></ul>\n<pre><code>    &lt;!--方式一：\n    collection：处理一对多的映射关系\n    ofType：表示该属性所对应的集合中存储数据的类型\n    --&gt;\n    &lt;resultMap id=\"getDeptAndEmpMap\" type=\"Dept\"&gt;\n        &lt;result property=\"did\" column=\"did\"&gt;&lt;/result&gt;\n        &lt;result property=\"deptName\" column=\"dept_name\"&gt;&lt;/result&gt;\n        &lt;collection property=\"emps\" ofType=\"Emp\"&gt;\n            &lt;result property=\"eid\" column=\"eid\"&gt;&lt;/result&gt;\n            &lt;result property=\"empName\" column=\"emp_name\"&gt;&lt;/result&gt;\n            &lt;result property=\"age\" column=\"age\"&gt;&lt;/result&gt;\n            &lt;result property=\"email\" column=\"email\"&gt;&lt;/result&gt;\n            &lt;result property=\"sex\" column=\"sex\"&gt;&lt;/result&gt;\n            &lt;result property=\"did\" column=\"did\"&gt;&lt;/result&gt;\n        &lt;/collection&gt;\n    &lt;/resultMap&gt;\n    &lt;!--Dept getDeptAndEmp(@Param(\"did\") Integer did);--&gt;\n    &lt;select id=\"getDeptAndEmp\" resultMap=\"getDeptAndEmpMap\"&gt;\n        select * from t_dept t1 left join t_emp t2 on t1.did = t2.did where t1.did = #{did}\n    &lt;/select&gt;\n\n    &lt;!--方式二--&gt;\n    &lt;resultMap id=\"getDeptAndEmpOneMap\" type=\"Dept\"&gt;\n        &lt;id property=\"did\" column=\"did\"&gt;&lt;/id&gt;\n        &lt;result property=\"deptName\" column=\"dept_name\"&gt;&lt;/result&gt;\n        &lt;collection property=\"emps\"\n                    select=\"com.cabbage.mappers.EmpMapper.getDeptAndEmpByStepTwo\"\n                    column=\"did\"&gt;\n        &lt;/collection&gt;\n    &lt;/resultMap&gt;\n    &lt;!-- Dept getDeptAndEmpOne(@Param(\"did\") Integer did);--&gt;\n    &lt;select id=\"getDeptAndEmpOne\" resultMap=\"getDeptAndEmpOneMap\"&gt;\n        select * from t_dept where did = #{did}\n    &lt;/select&gt;\n\n</code></pre>\n<p>方式二中<code>EmpMapper.xml</code>对应的分步查询的第二步：</p>\n<pre><code>    &lt;!--List&lt;Emp&gt; getDeptAndEmpByStepTwo(@Param(\"eid\") Integer eid);--&gt;\n    &lt;select id=\"getDeptAndEmpByStepTwo\" resultType=\"Emp\"&gt;\n        select * from t_emp where did= #{eid}\n    &lt;/select&gt;\n\n</code></pre>\n<p>写个测试代码：</p>\n<pre><code>    @Test\n    public void test4() throws IOException {\n        SqlSession sqlSession = SqlSessionUtil.getSqlSession();\n        DeptMapper mapper = sqlSession.getMapper(DeptMapper.class);\n        Dept dept = mapper.getDeptAndEmpOne(1);\n        System.out.println(dept);\n    }\n\n</code></pre>\n<h1>十、动态SQL</h1>\n<blockquote>\n<p>Mybatis框架的动态SQL技术是一种根据特定条件动态拼装SQL语句的功能，它存在的意义是为了解决拼接SQL语句字符串时的痛点问题。接下来就为大家逐一介绍他们的使用代码</p>\n</blockquote>\n<ul><li>1、<code>if的使用</code>：if标签可通过test属性的表达式进行判断，若表达式的结果为true，则标签中的内容会执行；反之标签中的内容不会执行</li></ul>\n<pre><code>    &lt;!--List&lt;User&gt; getUserByCondition(User user);--&gt;\n    &lt;select id=\"getUserByCondition\" resultType=\"User\"&gt;\n        select * from t_user where 1=1\n        &lt;if test=\"username !=null and username != ''\"&gt;\n            and username = #{username}\n        &lt;/if&gt;\n        &lt;if test=\"password != null and password != ''\"&gt;\n            and password = #{password}\n        &lt;/if&gt;\n    &lt;/select&gt;\\\n</code></pre>\n<blockquote>\n<p>这个语句是什么意思呢？其实就是我们传入一个实体对象，对象的username、password属性不为空或者不为null，就查询。对应的SQL语句是：select * from t_user where 1=1 and username = ? and password = ?</p>\n</blockquote>\n<ul><li>2、<code>where的使用</code></li></ul>\n<pre><code>&lt;!--List&lt;User&gt; getUserByWhere(User user);--&gt;\n    &lt;select id=\"getUserByWhere\" resultType=\"User\"&gt;\n        select * from t_user\n        &lt;where&gt;\n            &lt;if test=\"username != null and username != ''\"&gt;\n                and username = #{username}\n            &lt;/if&gt;\n            &lt;if test=\"password != null and password != ''\"&gt;\n                and password = #{password}\n            &lt;/if&gt;\n        &lt;/where&gt;\n    &lt;/select&gt;\n\\\n</code></pre>\n<blockquote>\n<p>where和if一般结合使用： 1、若where标签中的if条件都不满足，则where标签没有任何功能，即不会添加where关键字 2、若where标签中的if条件满足，则where标签会自动添加where关键字，并将条件最前方多余的 and去掉 3、注意：where标签不能去掉条件最后多余的and</p>\n</blockquote>\n<ul><li>3、<code>trim的使用</code></li></ul>\n<pre><code>&lt;!--List&lt;User&gt; getUserByTrim(User user);--&gt;\n    &lt;select id=\"getUserByTrim\" resultType=\"User\"&gt;\n        select * from t_user\n        &lt;trim prefix=\"where\" suffixOverrides=\"and\"&gt;\n            &lt;if test=\"username != null and username != ''\"&gt;\n                username = #{username} and\n            &lt;/if&gt;\n            &lt;if test=\"password != null and password != ''\"&gt;\n                password = #{password} and\n            &lt;/if&gt;\n        &lt;/trim&gt;\n    &lt;/select&gt;\n\\\\\\\n</code></pre>\n<blockquote>\n<p>trim用于去掉或添加标签中的内容，常用属性： 1、prefix：在trim标签中的内容的前面添加某些内容 2、prefixOverrides：在trim标签中的内容的前面去掉某些内容 3、suffix：在trim标签中的内容的后面添加某些内容 4、suffixOverrides：在trim标签中的内容的后面去掉某些内容</p>\n</blockquote>\n<ul><li>4、<code>choose、when、otherwise的使用</code>，相当于if...else if..else，满足一个if条件就不会执行下一个条件了</li></ul>\n<pre><code>    &lt;!--List&lt;User&gt; getUserByIfElse(User user);--&gt;\n    &lt;select id=\"getUserByIfElse\" resultType=\"User\"&gt;\n        select * from t_user\n        &lt;where&gt;\n            &lt;choose&gt;\n                &lt;when test=\"username != null and username != ''\"&gt;\n                    username = #{username}\n                &lt;/when&gt;\n                &lt;when test=\"password != null and password != ''\"&gt;\n                    password = #{password}\n                &lt;/when&gt;\n                &lt;otherwise&gt;\n                    id = 3\n                &lt;/otherwise&gt;\n            &lt;/choose&gt;\n        &lt;/where&gt;\n    &lt;/select&gt;\n</code></pre>\n<ul><li>5、<code>foreach的使用</code></li></ul>\n<pre><code>&lt;!--int insertByForeach(@Param(\"users\") List&lt;User&gt; list);--&gt;\n    &lt;insert id=\"insertByForeach\"&gt;\n        insert into t_user values\n        &lt;foreach collection=\"users\" item=\"item\" separator=\",\"&gt;\n            (null,#{item.username},#{item.password},#{item.age},#{item.sex},#{item.email})\n        &lt;/foreach&gt;\n    &lt;/insert&gt;\n&lt;!--对应的SQL语句就是：insert into t_user values (null,?,?,?,?,?) , (null,?,?,?,?,?)--&gt;\n\n    &lt;!--int deleteByForeach(@Param(\"id\") int[] id);--&gt;\n    &lt;delete id=\"deleteByForeach\"&gt;\n        delete from t_user where id in\n        &lt;foreach collection=\"id\" open=\"(\" close=\")\" separator=\",\" item=\"item\"&gt;\n            #{item}\n        &lt;/foreach&gt;\n    &lt;/delete&gt;\n&lt;!--对应的SQL语句是：delete from t_user where id in ( ? , ? )--&gt;\n\n</code></pre>\n<blockquote>\n<p>一起来看看其中的属性： 1、collection：设置要循环的数组或集合 2、item：表示集合或数组中的每一个数据 3、separator：设置循环体之间的分隔符 4、open：设置foreach标签中的内容的开始符 5、close：设置foreach标签中的内容的结束符</p>\n</blockquote>\n<ul><li>6、<code>SQL片段的使用</code>，可以记录一段公共sql片段，在使用的地方通过include标签进行引入</li></ul>\n<pre><code>    &lt;sql id=\"selectAll\"&gt;\n        id,username,password,age,sex,email\n    &lt;/sql&gt;\n&lt;!--比如我们把select * 这个查询字段可以改为表中所有的字段到sql片段中，\n最后再把 *去掉，引入sql片段就可以了--&gt;\n\n    select &lt;include refid=\"selectAll\"&gt;&lt;/include&gt; from t_user\n\n</code></pre>\n<h1>十一、MyBatis的缓存</h1>\n<blockquote>\n<p>对于这一部分的讲解，我不打算举例代码，因为相信学过mybatis的小伙伴们，看看对缓存的文字介绍，就可以回想起缓存所具有的特点，那么咱们就先从一级缓存开始吧！</p>\n</blockquote>\n<p>一级缓存是SqlSession级别的，通过同一个SqlSession查询的数据会被缓存，下次查询相同的数据，就会从缓存中直接获取，不会从数据库重新访问。把握两点：一是同一个sqlsession，二是查询相同的数据。缓存影响着我们的查询速度，但不影响我的查询数据！</p>\n<p>使一级缓存失效的四种情况：</p>\n<ul><li>不同的SqlSession对应不同的一级缓存</li><li>同一个SqlSession但是查询条件不同</li><li>同一个SqlSession两次查询期间执行了任何一次增删改操作(注意一下)</li><li>同一个SqlSession查询期间手动清空了缓存(<code>sqlSession.clearCache();</code>)</li></ul>\n<p>还是演示一下手动清空缓存的情况吧：</p>\n<pre><code>    @Test\n    public void test1() throws IOException {\n        InputStream inputStream = Resources.getResourceAsStream(\"mybatis-config.xml\");\n        SqlSessionFactoryBuilder factoryBuilder = new SqlSessionFactoryBuilder();\n        SqlSessionFactory factory = factoryBuilder.build(inputStream);\n        SqlSession sqlSession = factory.openSession(true);\n        UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n        UserMapper mapper1 = sqlSession.getMapper(UserMapper.class);\n        User user = mapper.selectById(1);\n        sqlSession.clearCache();\n        User user1 = mapper1.selectById(1);\n        System.out.println(user);\n        System.out.println(user1);\n    }\n\n</code></pre>\n<p><strong>运行结果：</strong></p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\9ce40e89428ed888c9f8b423acb95ebf.png\"/></p>\n<p></p>\n<p>二级缓存是SqlSessionFactory级别，通过同一个SqlSessionFactory创建的SqlSession查询的结果会被缓存；此后若再次执行相同的查询语句，结果就会从缓存中获取</p>\n<p>二级缓存开启的条件：</p>\n<ul><li>在核心配置文件中，设置全局配置属性cacheEnabled=\"true\"，默认为true，不需要设置</li><li>在映射文件中设置标签<code>&lt;cache /&gt;</code></li><li>二级缓存必须在SqlSession关闭或提交之后有效(不要忘记了哦)</li><li>查询的数据所转换的实体类类型必须实现序列化的接口(<code>implements Serializable</code>)</li></ul>\n<p>使二级缓存失效的情况：</p>\n<ul><li>两次查询之间执行了任意的增删改，会使一级和二级缓存同时失效</li></ul>\n<p><strong>演示一下二级缓存：</strong></p>\n<pre><code> @Test\n    public void test2() throws IOException {\n        InputStream inputStream = Resources.getResourceAsStream(\"mybatis-config.xml\");\n        SqlSessionFactoryBuilder factoryBuilder = new SqlSessionFactoryBuilder();\n        SqlSessionFactory factory = factoryBuilder.build(inputStream);\n        SqlSession sqlSession = factory.openSession(true);\n        UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n        User user1 = mapper.selectById(1);\n        System.out.println(user1);\n        sqlSession.close();//关闭一个后，放入了二级缓存中\n        SqlSession sqlSession1 = factory.openSession(true);\n        UserMapper mapper1 = sqlSession1.getMapper(UserMapper.class);\n        User user = mapper1.selectById(1);\n        System.out.println(user);\n        sqlSession1.close();\n    }\n\n</code></pre>\n<p></p>\n<p></p>\n<p>运行结果：</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\dc2f08f46c3ae7fad9998eff44e05168.png\"/></p>\n<blockquote>\n<p>二级缓存的相关配置，这一部分老师没有细讲，摘录下来，了解一下。在mapper配置文件中添加的cache标签可以设置一些属性：</p>\n</blockquote>\n<ul><li><code>eviction属性：缓存回收策略</code> LRU（Least Recently Used） – 最近最少使用的：移除最长时间不被使用的对象。 FIFO（First in First out） – 先进先出：按对象进入缓存的顺序来移除它们。 SOFT – 软引用：移除基于垃圾回收器状态和软引用规则的对象。 WEAK – 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。 默认的是 LRU。</li><li><code>flushInterval属性</code>：刷新间隔，单位毫秒，默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句时刷新</li><li><code>size属性</code>：引用数目，正整数代表缓存最多可以存储多少个对象，太大容易导致内存溢出</li><li><code>readOnly属性</code>：只读，true/false true：只读缓存；会给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。这提供了很重要的性能优势。 false：读写缓存；会返回缓存对象的拷贝（通过序列化）。这会慢一些，但是安全，因此默认是false。</li></ul>\n<p>最后来讲一讲MyBatis缓存查询的顺序：</p>\n<ul><li>先查询二级缓存，因为二级缓存中可能会有其他程序已经查出来的数据，可以拿来直接使用。</li><li>如果二级缓存没有命中，再查询一级缓存</li><li>如果一级缓存也没有命中，则查询数据库<code>SqlSession</code>关闭之后，一级缓存中的数据会写入二级缓存</li></ul>\n<h1>十二、创建逆向工程</h1>\n<p>什么是逆向工程呢？就是先创建数据库表，由框架负责根据数据库表，反向生成如下资源：</p>\n<ul><li>Java实体类、mapper接口、mapper映射文件</li></ul>\n<p>那么就开始根据步骤创建逆向工程吧！</p>\n<p>首先需要添加依赖和插件，这里有些依赖使用已经在前面使用过了，大家可以注意一下哦</p>\n<pre><code>&lt;!-- 依赖MyBatis核心包 --&gt;\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;\n            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;\n            &lt;version&gt;3.5.7&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\n            &lt;artifactId&gt;lombok&lt;/artifactId&gt;\n            &lt;version&gt;1.18.10&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;!-- MySQL驱动 --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;mysql&lt;/groupId&gt;\n            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n            &lt;version&gt;8.0.28&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;!-- junit测试 --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;junit&lt;/groupId&gt;\n            &lt;artifactId&gt;junit&lt;/artifactId&gt;\n            &lt;version&gt;4.12&lt;/version&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;log4j&lt;/groupId&gt;\n            &lt;artifactId&gt;log4j&lt;/artifactId&gt;\n            &lt;version&gt;1.2.17&lt;/version&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt; &lt;!-- 控制Maven在构建过程中相关配置 --&gt;\n    &lt;build&gt; &lt;!-- 构建过程中用到的插件 --&gt;\n        &lt;plugins&gt; &lt;!-- 具体插件，逆向工程的操作是以构建过程中插件形式出现的 --&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;\n                &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;\n                &lt;version&gt;1.3.0&lt;/version&gt; &lt;!-- 插件的依赖 --&gt;\n                &lt;dependencies&gt; &lt;!-- 逆向工程的核心依赖 --&gt;\n                    &lt;dependency&gt;\n                        &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;\n                        &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt;\n                        &lt;version&gt;1.3.2&lt;/version&gt;\n                    &lt;/dependency&gt; &lt;!-- 数据库连接池 --&gt;\n                    &lt;dependency&gt;\n                        &lt;groupId&gt;com.mchange&lt;/groupId&gt;\n                        &lt;artifactId&gt;c3p0&lt;/artifactId&gt;\n                        &lt;version&gt;0.9.2&lt;/version&gt;\n                    &lt;/dependency&gt;\n                    &lt;!-- MySQL驱动 --&gt;\n                    &lt;dependency&gt;\n                        &lt;groupId&gt;mysql&lt;/groupId&gt;\n                        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n                        &lt;version&gt;8.0.28&lt;/version&gt;\n                    &lt;/dependency&gt;\n                &lt;/dependencies&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;\n\n</code></pre>\n<p>接着创建MyBatis的核心配置文件以及逆向工程的配置文件，第一个配置文件已经讲过了，来看看逆向工程配置文件如何创建(使用时，发现实体类属性值补全，后来完善了一下视频中的笔记，加了一个配置)：</p>\n<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!DOCTYPE generatorConfiguration\n        PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\"&gt;\n&lt;generatorConfiguration&gt;\n    &lt;!-- targetRuntime: 执行生成的逆向工程的版本 MyBatis3Simple:\n    生成基本的CRUD（清新简洁版）\n    MyBatis3: 生成带条件的CRUD（奢华尊享版） --&gt;\n    &lt;context id=\"DB2Tables\" targetRuntime=\"MyBatis3\"&gt;\n        &lt;!-- 数据库的连接信息 --&gt;\n        &lt;jdbcConnection driverClass=\"com.mysql.cj.jdbc.Driver\" connectionURL=\"jdbc:mysql://localhost:3306/mybatis\"\n                        userId=\"root\" password=\"\"&gt;\n                        &lt;!-- 解决table schema中有多个重名的表生成表结构不一致问题 --&gt;\n            &lt;property name=\"nullCatalogMeansCurrent\" value=\"true\"/&gt;\n            &lt;/jdbcConnection&gt;\n        &lt;!-- javaBean的生成策略--&gt;\n        &lt;javaModelGenerator targetPackage=\"com.cabbage.pojo\" targetProject=\".\\src\\main\\java\"&gt;\n            &lt;property name=\"enableSubPackages\" value=\"true\"/&gt;\n            &lt;property name=\"trimStrings\" value=\"true\"/&gt;\n        &lt;/javaModelGenerator&gt;\n        &lt;!-- SQL映射文件的生成策略 --&gt;\n        &lt;sqlMapGenerator targetPackage=\"com.cabbage.mappers\" targetProject=\".\\src\\main\\resources\"&gt;\n            &lt;property name=\"enableSubPackages\" value=\"true\"/&gt;\n        &lt;/sqlMapGenerator&gt;\n        &lt;!-- Mapper接口的生成策略 --&gt;\n        &lt;javaClientGenerator type=\"XMLMAPPER\" targetPackage=\"com.cabbage.mappers\"\n                             targetProject=\".\\src\\main\\java\"&gt;\n            &lt;property name=\"enableSubPackages\" value=\"true\"/&gt;\n        &lt;/javaClientGenerator&gt;\n        &lt;!-- 逆向分析的表 --&gt; &lt;!-- tableName设置为*号，可以对应所有表，此时不写domainObjectName --&gt;\n        &lt;!-- domainObjectName属性指定生成出来的实体类的类名 --&gt;\n        &lt;table tableName=\"t_user\" domainObjectName=\"User\"/&gt;\n    &lt;/context&gt;\n&lt;/generatorConfiguration&gt;\n\n</code></pre>\n<p>需要注意的是：逆向工程配置文件的数据库相关的信息还是需要自己修改配置的</p>\n<p></p>\n<p></p>\n<p>最后执行插件，如图所示：</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\3387701688784086ee72fcdc468ca819.png\"/></p>\n<p></p>\n<p></p>\n<p>使用逆向工程生成的目录给大家看一下，可以看出跟我们自己手动创建的一模一样，是不是很简便呢？</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\d0ac790bcca01a6fd254feec3ec2ea7d.png\"/></p>\n<blockquote>\n<p>好了，本文对MyBatis的知识总结就到这里了，在复习的过程中，对使用逆向工程后的方法没有具体举例介绍，因为方法实在是太多了；还有一个知识点就是分页插件的使用也没有在本文中介绍，原因也是提供的方法很多，不方便介绍，自己认为最好的办法就是找一个小项目，在实际开发中慢慢熟练使用这些框架给的方法！</p>\n</blockquote>\n</div>\n</div>"}