{"blogid": "125021831", "writerAge": "码龄1年", "writerBlogNum": "12", "writerCollect": "76", "writerComment": "4", "writerFan": "7", "writerGrade": "2级", "writerIntegral": "152", "writerName": "烟雨任平生@", "writerProfileAdress": "writer_image\\profile_125021831.jpg", "writerRankTotal": "96383", "writerRankWeekly": "494042", "writerThumb": "28", "writerVisitNum": "16551", "blog_read_count": "14702", "blog_time": "于 2022-05-28 19:16:26 发布", "blog_title": "python的多线程", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h1><a id=\"python_0\"></a>python多线程</h1>\n<h2><a id=\"_2\"></a>一、线程的概念</h2>\n<p>线程是CPU分配资源的基本单位。当一程序开始运行，这个程序就变成了一个进程，而一个进程相当于一个或者多个线程。当没有多线程编程时，一个进程相当于一个主线程；当有多线程编程时，一个进程包含多个线程（含主线程）。使用线程可以实现程序大的开发。</p>\n<p>多个线程可以在同一个程序中运行，并且每一个线程完成不同的任务。</p>\n<p>多线程实现后台服务程序可以同时处理多个任务，并不发生阻塞现象。</p>\n<p>多线程的程序设计的特点就是能够提高程序执行效率和处理速度。python程序可以同时并行运行多个相对独立的线程。</p>\n<h2><a id=\"_16\"></a>二、创建多线程</h2>\n<p>python支持两种创建多线程的方式：</p>\n<p>~通过 threading.Thread () 创建。</p>\n<p>~通过继承 threading.Thread 类的继承。</p>\n<h3><a id=\"1_threadingThread___24\"></a>1.通过 threading.Thread () 创建</h3>\n<p>语法形式：</p>\n<pre><code>thread.Thread(group=Nore,targt=None,args=(),kwargs={},*,daemon=None)\n</code></pre>\n<p>参数解释：</p>\n<p>~group：必须为None，于ThreadGroup类相关，一般不使用。</p>\n<p>~target：线程调用的对象，就是目标函数。</p>\n<p>~name：为线程起这个名字。默认是Tread-x，x是序号，由1开始，第一个创建的线程名字就是Tread-1。</p>\n<p>~args：为目标函数传递关键字参数，字典。</p>\n<p>~daemon：用来设置线程是否随主线程退出而退出。</p>\n<p>示例：</p>\n<pre><code>import threading\ndef test (x,y):\n for i in range(x,y):\n   print(i)\nthread1 = threading.Thread(name='t1',target= test,args=(1,10))\nthread2 = threading.Thread(name='t2',target= test,args=(11,20))\nthread1.start()   #启动线程1\nthread2.start()   #启动线程2\n</code></pre>\n<p>输出：</p>\n<pre><code>1\n2\n3\n4\n5\n6\n7\n8\n9\n11\n12\n13\n14\n15\n16\n17\n18\n19\n</code></pre>\n<p>解释：两个程序会并发运行，所以结果不一定每次都是顺序的1~10，这是根据CPU给两个线程风马分配的时间片段来决定。可以看到每次结果都不同。</p>\n<h3><a id=\"2__threadingThread__84\"></a>2.通过继承 threading.Thread 类的继承</h3>\n<p>threading.Thread是一个类，可以继承它。</p>\n<p>示例：</p>\n<pre><code>import threading\nclass mythread(threading.Thread):\n  def run(self):\n    for i in range(1,10):\n      print(i)\nthread1 = mythread();\nthread2 = mythread();\nthread1.start()\nthread2.start()\n</code></pre>\n<p>输出：</p>\n<pre><code>1\n2\n3\n4\n5\n6\n7\n8\n9\n1\n2\n3\n4\n5\n6\n7\n8\n9\n</code></pre>\n<p>解释：自定义一个类继承threading.Thread,然后重写父类的run方法，线程启动时（执行start（））会自动执行该方法。</p>\n<h2><a id=\"_129\"></a>三、主线程</h2>\n<p>在python中，主线程是第一个启动的线程。</p>\n<p>~父线程:如果启动线程A中启动了一个线程B，A就是B的父线程。</p>\n<p>~子线程：B就是A的子线程。</p>\n<p>创建线程时有一个damon属性，用它来判断主线程。当daemon设置False时，线程不会随主线程退出而退出，主线程会一直等着子线程执行完;。当daemon设置True时，线程会随主线程退出而退出，主线程结束其他的子线程会强制退出。</p>\n<p>使用daemon注意：</p>\n<p>~daemon属性必须在start( )之前设置，否则会引发RuntimeError异常</p>\n<p>~每个线程都由daemon属性，可以显示设置也可以不设置，不设置则取默认值None</p>\n<p>~如果子子线程不设置daemon属性，就取当前线程的daemon来设置它。子子线程继承子线程的daemon值，作用和设置None一样。</p>\n<p>~从主线程创建的所有线程不设置daemon属性，则默认都是daemon=False。</p>\n<p>示例：</p>\n<pre><code>import time\nimport threading\ndef test():\n time.sleep(10)\n for i in range(10):\n  print(i)\nthread1 = threading.Thread(target=test,daemon=False)\nthread1.start()\nprint('主线程完成了')\n</code></pre>\n<p>输出：</p>\n<pre><code>主线程完成了\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n</code></pre>\n<p>解释：当主线程运行完毕输出完之后，等待一下后输出0~9。如果将daemon=False该为daemon=True，则不会运行for i in range(10)语句。</p>\n<h2><a id=\"_183\"></a>四、阻塞线程</h2>\n<p>一个线程中调用另一个线程的join方法，调用者被阻塞，直到调用线程被终止。</p>\n<p>语法形式：</p>\n<pre><code>join(timeout-=None)\n</code></pre>\n<p>timeout 参数指定调用者等待多久，没有设置时，就一直等待被调用线程结束被调用线程结束。其中，一个线程可以被join多次调用。</p>\n<p>示例：</p>\n<pre><code>import time\nimport threading\ndef test():\n time.sleep(5)\n for i in range(10):\n  print(i)\nthread1=threading.Thread(target=test)\nthread1.start()\nthread1.join()\nprint('主线程完成了')\n</code></pre>\n<p>输出：</p>\n<pre><code>0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n主线程完成了\n</code></pre>\n<p>解释：在thread1.start()后加thread1.join()添加join方法，输出时，主线程就会等待输出完0~9后再执行自己的print输出。</p>\n<h2><a id=\"_228\"></a>五、判断线程是否活动的</h2>\n<p>~run（）：用以表示线程活动的方法</p>\n<p>~start（）：启动线程</p>\n<p>~join（）：等待至线程终止</p>\n<p>~isAlive（）：返回线程是否活动的</p>\n<p>~getName（）：返回线程名称</p>\n<p>~setName() : 设置线程名称</p>\n<p>示例：</p>\n<pre><code>from threading import Thread, Event\nimport time\ndef countdown(n, started_evt):\n    print('正在运行')\n    started_evt.set()\n    while n &gt; 0:\n        print('时间', n)\n        n -= 1\n        time.sleep(2)\nstarted_evt = Event()\nprint('开始倒计时')\nt = Thread(target=countdown, args=(10, started_evt))\nt.start()\nstarted_evt.wait()\nprint('倒计时运行')\n</code></pre>\n<p>输出：</p>\n<pre><code>开始倒计时\n正在运行\n时间 10\n倒计时运行\n时间 9\n时间 8\n时间 7\n时间 6\n时间 5\n时间 4\n时间 3\n时间 2\n时间 1\n</code></pre>\n<p>Alive，顾名思义，它表示线程当前是否为可用状态，如果线程已经启动，并且当前没有任何异常的话，则返回true，否则为false</p>\n<p>Thread.isAlive() ：顾名思义，是表示当前线程时候为可用状态，即是否已经在启动，并且在运行的状态；</p>\n<h2><a id=\"_284\"></a>六、线程同步</h2>\n<h3><a id=\"1_286\"></a>1.同步概念</h3>\n<p>异步模式的情况下，同时有一个线程在修改共享数据，另一个线程在读取共享数据，当修改的共享数据的线程没有处理完毕，读取数据的线程肯定会得到错误的结果。如果采用多线程的同步控制机制，当处理共享数据的线程完成处理数据之后，读取线程就读取数据。</p>\n<p>python的锁就解决这一问题，锁住线程，只允许一个线程操作，其他线程排队等待，待当前线程操作完毕后，再按顺序一个一个来运行。</p>\n<h3><a id=\"2_python_292\"></a>2. python的锁</h3>\n<p>python的threading模块提供了RLock锁解决方法。在某一时间只能让一个线程操作的语句放到RLock的acquire方法和release方法之间，即acquire相当于给RLack上锁，而release相当于解锁。</p>\n<p>示例：</p>\n<pre><code>import threading\nclass mythread(threading.Thread):\n def run(self):\n  global x                   #声明一个全局变量\n  lock.acquire()             #上锁\n  x +=10\n  print('%s:%d'%(self.name,x))\n  lock.release()             #解锁\nx = 0                        #设置全局变量初始值\nlock = threading.RLock()     #创建可重入锁\nlist1 = []                   \nfor i in range(5):   \n list1.append(mythread())    #创建五个线程，放到同一列表中\nfor i in list1:\n i.start()                   #开启列表线程\n</code></pre>\n<p>输出：</p>\n<pre><code>Thread-1:10\nThread-2:20\nThread-3:30\nThread-4:40\nThread-5:50\n</code></pre>\n<p>解释：</p>\n<h3><a id=\"3_python_328\"></a>3. python中的条件锁</h3>\n<p>条件锁常用的方法：</p>\n<p>~acquire([timeout]):调用关联锁的方法</p>\n<p>~release()：解锁</p>\n<p>~wait():使线程进入 Condition 的等待池等待通知并释放解锁。使用前线程必须已获得锁定，否则将抛出异常。</p>\n<p>~notify():从等待池挑选一个线程并通知，收到通知的线程将自动调用 acquire() 尝试获得，其他线程仍然在等待池中等待通知，直到该线程收到通知 调用该方法，否则将会抛出异常。</p>\n<p>~notify ALL():跟notify() 一样，但这个方法对应的是所有的线程。</p>\n<p>示例：</p>\n<p>题目：有几个生产车间生产，几个消费者购买，当生产达到一定数量时，停止生产。</p>\n<pre><code>import threading\nimport time\ncondtion = threading.Condition()\nsheep = ['1件产品','1件产品','1件产品','1件产品','1件产品']\nclass Producer(threading.Thread):\n    def __init__(self, name):\n        super().__init__(name=name)\n        pass\n    def run(self):\n        global condtion, sheep\n        while True:\n            time.sleep(0.1)\n            condtion.acquire()\n            if len(sheep) &lt; 10:\n                print(self.name + \"生产了1件产品\")\n                sheep.append('1件产品')\n                condtion.notifyAll()\n                pass\n            else:\n                print(\"仓库满了，停止生产!\")\n                condtion.wait()\n                pass\n            condtion.release()\n        pass\n    pass\nclass Customer(threading.Thread):\n    def __init__(self, name):\n        super().__init__(name=name)\n        pass\n    def run(self):\n        global condtion, sheep\n        while True:\n            time.sleep(0.1)\n            condtion.acquire()\n            if len(sheep) &gt; 0:\n                meat = sheep.pop()\n                print(self.name + \"购买了\" + meat + \"还剩多少\" + str(len(sheep)) + \"件\")\n                condtion.notifyAll()\n                pass\n            else:\n                print(\"买光了，等待\")\n                condtion.wait()\n                pass\n            condtion.release()\n        pass\n    pass\nif __name__ == \"__main__\":\n    p1 = Producer(\"1号生产车间\")\n    p2 = Producer(\"2号生产车间\")\n    p3 = Producer(\"3号生产车间\")\n    p4 = Producer(\"4号生产车间\")\n    p5 = Producer(\"5号生产车间\")\n    p6 = Producer(\"6号生产车间\")\n    p1.start()\n    p2.start()\n    p4.start()\n    p5.start()\n    p6.start()\n    c1 = Customer('小王')\n    c2 = Customer('小李')\n    c3 = Customer('小贾')\n    c4 = Customer('小沈')\n    c5 = Customer('小刘')\n    c1.start()\n    c2.start()\n    c3.start()\n    c4.start()\n    c5.start()\n</code></pre>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}