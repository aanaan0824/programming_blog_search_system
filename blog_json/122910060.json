{"blogid": "122910060", "writerAge": "码龄10年", "writerBlogNum": "66", "writerCollect": "96", "writerComment": "9", "writerFan": "20", "writerGrade": "4级", "writerIntegral": "1479", "writerName": "hsy12342611", "writerProfileAdress": "writer_image\\profile_122910060.jpg", "writerRankTotal": "97640", "writerRankWeekly": "66008", "writerThumb": "13", "writerVisitNum": "92588", "blog_read_count": "3225", "blog_time": "已于 2022-02-13 16:57:15 修改", "blog_title": "C++与QML交互总结", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>一直对于QT的理解和使用都停留在主窗口程序和控制台程序，虽然QT的新东西QML听过也接触过，但是基本上没梳理过调用流程。趁着旧项目要使用QML技术，现在就将C++和QML交互进行总结。</p>\n<p>在C++和QML中均可以定义信号和槽，并且均可以完成信号和槽的绑定</p>\n<h1>一. QML中使用C++业务类</h1>\n<p>基本流程如下：</p>\n<p>1.将C++注册进入QML引擎，C++类型在qml中当成一个子组件使用</p>\n<p>2.在qml中完成信号与槽的绑定</p>\n<p>测试代码：</p>\n<p>1.QML定义</p>\n<p>main.qml</p>\n<pre><code class=\"language-javascript\">import QtQuick 2.7\nimport QtQuick.Window 2.2\n\nimport WorkClass 1.0\n\nWindow {\n    id: root\n    visible: true\n    width: 640\n    height: 480\n    title: qsTr(\"Hello World\")\n\n    signal qmlSignal1\n    signal qmlSignal2(string strValue, int iValue)\n\n    MainForm {\n        anchors.fill: parent\n        mouseArea.onClicked: {\n            Qt.quit();\n        }\n    }\n\n    MouseArea{\n        anchors.fill: parent\n        acceptedButtons: Qt.LeftButton | Qt.RightButton\n        onClicked: {\n            if(mouse.button === Qt.LeftButton){\n                console.log(' Qt.LeftButton')\n                bussiness.strValue = \"HelloCpp\"\n                bussiness.intValue = 2022\n                bussiness.sendSignal()\n            }else{\n                console.log(' Qt.RightButton')\n                root.qmlSignal1()\n                root.qmlSignal2('hesy', 2000)\n            }\n        }\n    }\n\n    CBusiness{\n        id: bussiness\n        property int addpro: 0\n\n        onIntValueChanged: {\n            console.log('qml onIntValueChanged', \"begin change addpro \", addpro)\n            addpro++\n            console.log('qml onIntValueChanged', addpro)\n        }\n\n        onAddproChanged: {\n            console.log('qml onAddFun', addpro)\n        }\n    }\n\n    Component.onCompleted: {\n        bussiness.onSignal1.connect(function(){console.log('no name qml function')})\n        bussiness.onSignal2.connect(qmlProcess1)\n        root.qmlSignal1.connect(bussiness.slot1)\n        root.qmlSignal2.connect(bussiness.slot2)\n        console.log('Component.onCompleted')\n    }\n\n    function qmlProcess1(str, value){\n        console.log('qmlProcess1', str, value)\n    }\n}\n</code></pre>\n<p>2.C++业务类定义和实现</p>\n<p>cbusiness.h</p>\n<pre><code class=\"language-cpp\">#ifndef CBUSINESS_H\n#define CBUSINESS_H\n\n#include &lt;QObject&gt;\n\nclass CBusiness : public QObject\n{\n    Q_OBJECT\n    Q_PROPERTY(QString strValue READ getStrValue WRITE setStrValue NOTIFY strValueChanged)\n    Q_PROPERTY(int intValue READ getIntValue WRITE setIntValue NOTIFY intValueChanged)\n\npublic:\n    explicit CBusiness(QObject *parent = 0);\n    Q_INVOKABLE void sendSignal();\n\n    void setStrValue(QString strValue);\n    QString getStrValue() const;\n    void setIntValue(int intValue);\n    int getIntValue() const;\n\nsignals:\n    void signal1();\n    void signal2(QString strValue, int intValue);\n    void strValueChanged(QString strValue);\n    void intValueChanged(int intValue);\n\npublic slots:\n    void slot1();\n    void slot2(QString strValue, int intValue);\n\nprivate:\n    //类的属性\n    QString m_strValue;\n    int m_intValue;\n};\n\n#endif // CBUSINESS_H\n</code></pre>\n<p>cbusiness.cpp</p>\n<pre><code class=\"language-cpp\">#include \"cbusiness.h\"\n#include &lt;QDebug&gt;\n\nCBusiness::CBusiness(QObject *parent) : QObject(parent), m_strValue(\"\"), m_intValue(0)\n{\n}\n\n\nvoid CBusiness::sendSignal()\n{\n    qDebug() &lt;&lt; \"CBusiness::\" &lt;&lt; __FUNCTION__;\n    emit signal1();\n    emit signal2(m_strValue, m_intValue);\n}\n\nvoid CBusiness::setStrValue(QString strValue)\n{\n    qDebug() &lt;&lt; \"CBusiness::\" &lt;&lt; __FUNCTION__ &lt;&lt; strValue;\n    m_strValue = strValue;\n    emit strValueChanged(strValue);\n    qDebug()&lt;&lt; \"CBusiness::\" &lt;&lt; \"emit strValueChanged\" &lt;&lt; endl;\n}\n\nQString CBusiness::getStrValue() const\n{\n    qDebug() &lt;&lt; \"CBusiness::\" &lt;&lt; __FUNCTION__;\n    return m_strValue;\n}\n\nvoid CBusiness::setIntValue(int intValue)\n{\n    qDebug() &lt;&lt; \"CBusiness::\" &lt;&lt; __FUNCTION__;\n    m_intValue = intValue;\n    emit intValueChanged(intValue);\n    qDebug()&lt;&lt; \"CBusiness::\" &lt;&lt; \"emit intValueChanged\";\n}\n\n\nint CBusiness::getIntValue() const\n{\n    qDebug() &lt;&lt; \"CBusiness::\" &lt;&lt; __FUNCTION__;\n    return m_intValue;\n}\n\nvoid CBusiness::slot1()\n{\n    qDebug() &lt;&lt; \"CBusiness::\" &lt;&lt; __FUNCTION__;\n}\n\nvoid CBusiness::slot2(QString strValue, int intValue)\n{\n    qDebug() &lt;&lt; \"CBusiness::\" &lt;&lt; __FUNCTION__;\n    qDebug() &lt;&lt; \"CBusiness:: \" &lt;&lt; strValue &lt;&lt; \"  \" &lt;&lt; intValue;\n}\n</code></pre>\n<p>3.主调函数</p>\n<p>main.cpp</p>\n<pre><code class=\"language-cpp\">#include &lt;QGuiApplication&gt;\n#include &lt;QQmlApplicationEngine&gt;\n\n#include \"cbusiness.h\"\n\nint main(int argc, char *argv[])\n{\n    QGuiApplication app(argc, argv);\n\n    //qmlRegisterType注册C++类型至QML\n    //arg1:import时模块名\n    //arg2:主版本号\n    //arg3:次版本号\n    //arg4:QML类型名\n    qmlRegisterType&lt;CBusiness&gt;(\"WorkClass\", 1, 0, \"CBusiness\");\n\n    QQmlApplicationEngine engine;\n    engine.load(QUrl(QStringLiteral(\"qrc:/main.qml\")));\n    if (engine.rootObjects().isEmpty())\n        return -1;\n\n    return app.exec();\n}\n</code></pre>\n<p>4.测试结果</p>\n<p>鼠标左键点击：</p>\n<p><img alt=\"\" height=\"396\" src=\"image\\80ed9feb7919444d8229a475485ca525.png\" width=\"1092\"/></p>\n<p> 说明：</p>\n<p>信号和槽的绑定在qml中完成，鼠标左键按下，首先打印：qml: Qt.LeftButton</p>\n<p>bussiness.strValue = \"HelloCpp\" 触发 CBusiness::setStrValue（</p>\n<p>因为如下：</p>\n<pre>Q_PROPERTY(QString strValue READ getStrValue WRITE setStrValue NOTIFY strValueChanged)</pre>\n<p>此处= \"HelloCpp\" 其实是调用的setStrValue</p>\n<p>）调用</p>\n<p>bussiness.intValue = 2022触发CBusiness::setIntValue（</p>\n<pre>因为如下：\nQ_PROPERTY(int intValue READ getIntValue WRITE setIntValue NOTIFY intValueChanged)</pre>\n<p>此处= 2022其实是调用的setIntValue</p>\n<p>）调用， 然后调用emit strValueChanged(strValue);，触发qml中 onIntValueChanged调用，接着addpro++触发onAddproChanged调用</p>\n<p>最后调用CBusiness::sendSignal()，触发emit signal1(); emit signal2(m_strValue, m_intValue);信号，调用qml的槽 </p>\n<pre>function(){console.log('no name qml function')</pre>\n<p>和</p>\n<pre>function qmlProcess1(str, value)\n</pre>\n<p>鼠标右键点击：</p>\n<p><img alt=\"\" height=\"144\" src=\"image\\5b19b450d27b4f4cbf6f2c315db25c0b.png\" width=\"840\"/></p>\n<p> 说明：</p>\n<p>鼠标右键，通过qml信号调用到c++的槽函数，并且还传递参数给c++</p>\n<h1>二.C++使用QML</h1>\n<p>基本流程如下：</p>\n<p>1.在C++中获得qml对象指针</p>\n<p>2.在C++中完成信号和槽的绑定</p>\n<p>测试代码：</p>\n<p>1.QML定义</p>\n<p>main.qml</p>\n<pre><code class=\"language-javascript\">import QtQuick 2.7\nimport QtQuick.Window 2.2\n\nItem {\n    id: root\n    visible: true\n    width: 640\n    height: 480\n    //title: qsTr(\"Hello World\")\n\n    property string msg: \"I am QML Item\"\n    signal callCpp(string arg1, string arg2)\n\n    MainForm {\n        anchors.fill: parent\n        mouseArea.onClicked: {\n            Qt.quit();\n        }\n    }\n\n    Rectangle {\n        anchors.fill: parent\n        color: \"blue\"\n        objectName: \"rect\"\n    }\n\n    MouseArea {\n        anchors.fill: parent\n        onClicked: {\n            console.log(\"onClicked, callCpp\")\n            root.callCpp(root.msg, \"notify cpp\")\n        }\n    }\n\n    onHeightChanged: {\n        console.log(\"onHeightChanged execute\")\n    }\n    onWidthChanged: {\n        console.log(\"onWidthChanged execute\")\n    }\n\n\n    //QML中的方法可以被cpp调用，也可以作为槽函数\n    function qmlFun(val_arg) {\n        console.log(\"qmlFun execute\", val_arg, \"return qmlFun_return_result\")\n        return \"qmlFun_return_result\"\n    }\n    //注意槽函数参数为var类型\n    function invokeFromCpp(arg1, arg2) {\n        console.log(\"invokeFromCpp execute \", arg1, arg2)\n    }\n}\n</code></pre>\n<p>2.C++业务类定义和实现</p>\n<p>cbusiness.h</p>\n<pre><code class=\"language-cpp\">#ifndef CBUSINESS_H\n#define CBUSINESS_H\n\n#include &lt;QObject&gt;\n\nclass CBusiness : public QObject\n{\n    Q_OBJECT\npublic:\n    explicit CBusiness(QObject *parent = 0);\n\nsignals:\n    void callQml(const QVariant &amp;arg1,const QVariant &amp;arg2);\n\npublic slots:\n    void invokeFromQml(const QString &amp;arg1,const QString &amp;arg2);\n};\n\n#endif // CBUSINESS_H\n</code></pre>\n<p>cbusiness.cpp</p>\n<pre><code class=\"language-cpp\">#include \"cbusiness.h\"\n\n#include &lt;QDebug&gt;\n\nCBusiness::CBusiness(QObject *parent) : QObject(parent)\n{\n\n}\n\nvoid CBusiness::invokeFromQml(const QString &amp;arg1,const QString &amp;arg2)\n{\n    qDebug() &lt;&lt; \"CBusiness::\" &lt;&lt; __FUNCTION__ &lt;&lt; arg1 &lt;&lt; arg2;\n    qDebug() &lt;&lt; \"CBusiness::\" &lt;&lt; __FUNCTION__ &lt;&lt; \" emit callQml\";\n    emit callQml(\"I am cpp\", \"notify qml\");\n}\n</code></pre>\n<p>3.主调函数</p>\n<p>main.cpp</p>\n<pre><code class=\"language-cpp\">#include &lt;QGuiApplication&gt;\n#include &lt;QQmlApplicationEngine&gt;\n#include &lt;QQmlProperty&gt;\n#include &lt;QQuickView&gt;\n#include &lt;QQuickItem&gt;\n#include &lt;QMetaObject&gt;\n#include &lt;QDebug&gt;\n\n#include \"cbusiness.h\"\n\nint main(int argc, char *argv[])\n{\n    QCoreApplication::setAttribute(Qt::AA_EnableHighDpiScaling);\n\n    QGuiApplication app(argc, argv);\n\n    /*\n    可以用QQmlComponent\\QQuickView\\QQuickWidget的C++代码加载QML文档\n    当使用QQuickView时，qml的根不能是Window\n    */\n    QQuickView view(QUrl(\"qrc:/main.qml\"));\n    view.show();\n\n    // 获取到qml根对象的指针\n    QObject *qmlObj = view.rootObject();\n\n\n        /*\n        修改qml属性值的方法\n        QObject::setProperty()  QQmlProperty  QMetaProperty::write()\n        */\n\n    // 通过QObject设置属性值\n    qDebug() &lt;&lt; \"cpp: \" &lt;&lt; \"set qml property height\";\n    QQmlProperty(qmlObj, \"height\").write(500);  //qmlObj-&gt;setProperty(\"height\",500);\n    // 通过QObject获取属性值\n    qDebug() &lt;&lt; \"cpp: \" &lt;&lt; \"get qml property height\" &lt;&lt; qmlObj-&gt;property(\"height\").toDouble();\n    // C++访问qml的其它属性\n    qDebug() &lt;&lt; \"cpp: \" &lt;&lt; \"get qml property msg\" &lt;&lt; qmlObj-&gt;property(\"msg\").toString();\n\n\n    // 获取QQuickItem\n    QQuickItem *item = qobject_cast&lt;QQuickItem*&gt;(qmlObj);\n    // 通过QQuickItem设置属性值\n    qDebug() &lt;&lt; \"cpp: \" &lt;&lt; \"set qml property width\";\n    item-&gt;setWidth(300);\n    // 通过QQuickItem获取属性值\n    qDebug() &lt;&lt; \"cpp: \" &lt;&lt; \"get qml property width\" &lt;&lt; item-&gt;width();\n\n\n    // 通过object name访问加载的QML对象\n    // QObject::findChildren()可用于查找具有匹配object name属性的子项\n    QObject *qmlRect = qmlObj-&gt;findChild&lt;QObject*&gt;(\"rect\");\n    if(qmlRect)\n    {\n        qDebug() &lt;&lt; \"cpp: \" &lt;&lt; \"get rect color\" &lt;&lt; qmlRect-&gt;property(\"color\");\n    }\n\n\n    // C++调用QML方法\n    QVariant valReturn;\n    QVariant valArg = \"I am cpp\";\n    //Q_RETURN_ARG()和Q_Arg()参数必须制定为QVariant类型\n    QMetaObject::invokeMethod(qmlObj, \"qmlFun\",\n                              Q_RETURN_ARG(QVariant,valReturn),\n                              Q_ARG(QVariant,valArg));\n    qDebug() &lt;&lt; \"cpp: \" &lt;&lt; \"QMetaObject::invokeMethod result\" &lt;&lt; valReturn.toString(); //qml函数中返回“ok”\n\n\n    CBusiness cppObj;\n    // cpp和qml信号与槽关联\n    // qml信号绑订cpp的槽，用QString类型\n    QObject::connect(qmlObj, SIGNAL(callCpp(QString, QString)), &amp;cppObj, SLOT(invokeFromQml(QString, QString)));\n\n    //关联cpp信号与qml槽\n    // cpp的信号绑定qml槽，用QVariant类型\n    QObject::connect(&amp;cppObj, SIGNAL(callQml(QVariant, QVariant)), qmlObj, SLOT(invokeFromCpp(QVariant, QVariant)));\n\n    return app.exec();\n}\n</code></pre>\n<p>4.测试结果</p>\n<p><img alt=\"\" height=\"300\" src=\"image\\09adda0802224044b7e6fb6e476886f3.png\" width=\"1198\"/></p>\n<p>信号和槽的绑定在c++代码中完成，在c++中可以修改qml的属性，获取qml的属性，调用qml的方法，传递和获取参数均可以</p>\n<p> 鼠标点击</p>\n<p><img alt=\"\" height=\"162\" src=\"image\\2779f9cd19674dcd915dcaa23d50eb92.png\" width=\"934\"/></p>\n<p> 鼠标点击后，通过qml的信号callCpp调用c++的槽函数invokeFromQml，然后再通过c++的信号函数callQml调用qml的槽函数invokeFromCpp</p>\n<h1>三.QVariant中方法canConvert和convert使用总结</h1>\n<p>1.canConvert只是报告QVariant进行两个类型之间转换的能力，例如QString和Int类型之间的转换，关注类型<br/> 2.convert判断的是QVariant进行两个类型的数据之间转换的能力，例如“123”和123之间的转换，关注数据</p>\n<p>举例：</p>\n<pre><code class=\"language-cpp\">QString str1 = \"Qt5.7.0\";\nQVariant var1 = str1;\n\nqDebug() &lt;&lt; var1.canConvert(QVariant::Int); // true\nqDebug() &lt;&lt; var1.convert(QVariant::Int); // false\nqDebug() &lt;&lt; var1.toString(); // \"0\"\n\nvar1 = str1;\nqDebug() &lt;&lt; var1.convert(QVariant::String); // true\nqDebug() &lt;&lt; var1.toString(); // \"Qt5.7.0\"\n\nQString str2 = \"789\";\nQVariant var2 = str2;\n\nqDebug() &lt;&lt; var2.canConvert(QVariant::Int); // true\nqDebug() &lt;&lt; var2.convert(QVariant::Int); // true\nqDebug() &lt;&lt; var2.toString(); // \"789\"</code></pre>\n<p></p>\n</div>\n</div>"}