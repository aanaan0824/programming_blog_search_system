{"blogid": "122508749", "writerAge": "码龄11年", "writerBlogNum": "57", "writerCollect": "62", "writerComment": "5", "writerFan": "9", "writerGrade": "4级", "writerIntegral": "882", "writerName": "z974656361", "writerProfileAdress": "writer_image\\profile_122508749.jpg", "writerRankTotal": "29015", "writerRankWeekly": "67103", "writerThumb": "18", "writerVisitNum": "45173", "blog_read_count": "688", "blog_time": "于 2022-01-15 17:22:24 发布", "blog_title": "RUST——互斥锁的使用", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>互斥锁是Rust语言中所提供的，基于共享内存的方式来实现线程之间通信的机制。</p>\n<h2>Mutex的简单使用</h2>\n<p>Mutex是rust标准库中提供的互斥锁的实现。使用的示例代码如下所示：</p>\n<pre><code class=\"language-rust\">use std::sync::Mutex;\n\nfn main() {\n    let m = Mutex::new(5);\n\n    {\n        let mut num = m.lock().unwrap();\n        *num = 6;\n    }\n\n    println!(\"m = {:?}\", m);\n}</code></pre>\n<p>共享变量是存储于Mutex对象的内部的，如果要访问共享的数据，需要先获取锁，然后才能访问内部的数据。</p>\n<h2>Mutex在多线程之间的共享</h2>\n<p>下面我们尝试在多个线程之间共享Mutex对象，以实现对数据的共享。示例代码如下：</p>\n<pre><code class=\"language-rust\">use std::sync::Mutex;\nuse std::thread;\n\nfn main() {\n    let counter = Mutex::new(0);\n    let mut handles = vec![];\n\n    for _ in 0..10 {\n        let handle = thread::spawn(move || {\n            let mut num = counter.lock().unwrap();\n\n            *num += 1;\n        });\n        handles.push(handle);\n    }\n\n    for handle in handles {\n        handle.join().unwrap();\n    }\n\n    println!(\"Result: {}\", *counter.lock().unwrap());\n}</code></pre>\n<p>如果我们编译上述代码，会得到如下的结果：</p>\n<pre><code class=\"language-bash\">   Compiling playground v0.0.1 (/playground)\nerror[E0382]: use of moved value: `counter`\n  --&gt; src/main.rs:9:36\n   |\n5  |     let counter = Mutex::new(0);\n   |         ------- move occurs because `counter` has type `Mutex&lt;i32&gt;`, which does not implement the `Copy` trait\n...\n9  |         let handle = thread::spawn(move || {\n   |                                    ^^^^^^^ value moved into closure here, in previous iteration of loop\n10 |             let mut num = counter.lock().unwrap();\n   |                           ------- use occurs due to use in closure\n\nFor more information about this error, try `rustc --explain E0382`.\nerror: could not compile `playground` due to previous error</code></pre>\n<p>显然，在创建线程的时候，使用move语义，Mutex对象的所有权发生了转移，因而无法实现在多个线程之间共享Mutex的对象。如果想要实现Mutex对象在多个线程之间共享，必须使用具有多所有权的对象，我们很自然的就想到了rust中基于引用计数实现的智能指针Rc。</p>\n<h2>基于Rc实现Mutex在多线程之间的共享</h2>\n<p>基于Rc的机制实现Mutex在多线程之间的共享的示例代码如下：</p>\n<pre><code class=\"language-rust\">use std::rc::Rc;\nuse std::sync::Mutex;\nuse std::thread;\n\nfn main() {\n    let counter = Rc::new(Mutex::new(0));\n    let mut handles = vec![];\n\n    for _ in 0..10 {\n        let counter = Rc::clone(&amp;counter);\n        let handle = thread::spawn(move || {\n            let mut num = counter.lock().unwrap();\n\n            *num += 1;\n        });\n        handles.push(handle);\n    }\n\n    for handle in handles {\n        handle.join().unwrap();\n    }\n\n    println!(\"Result: {}\", *counter.lock().unwrap());\n}</code></pre>\n<p>如果我们编译上述代码，会得到如下的编译结果：</p>\n<pre><code class=\"language-bash\">   Compiling playground v0.0.1 (/playground)\nerror[E0277]: `Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely\n   --&gt; src/main.rs:11:22\n    |\n11  |           let handle = thread::spawn(move || {\n    |  ______________________^^^^^^^^^^^^^_-\n    | |                      |\n    | |                      `Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely\n12  | |             let mut num = counter.lock().unwrap();\n13  | |\n14  | |             *num += 1;\n15  | |         });\n    | |_________- within this `[closure@src/main.rs:11:36: 15:10]`\n    |\n    = help: within `[closure@src/main.rs:11:36: 15:10]`, the trait `Send` is not implemented for `Rc&lt;Mutex&lt;i32&gt;&gt;`\n    = note: required because it appears within the type `[closure@src/main.rs:11:36: 15:10]`\nnote: required by a bound in `spawn`\n\nFor more information about this error, try `rustc --explain E0277`.\nerror: could not compile `playground` due to previous error</code></pre>\n<p>从上述结果中，我们可以看到，Rc的实现的引用计数，并不是线程安全的，无法在多线程之间传递。很自然地，我们可以使用rust中的线程安全的引用计数实现机制Arc，A代表的是Atomic，是原子性的操作，因而可以保证线程的安全。</p>\n<h2>基于Arc实现Mutex在多线程之间的共享</h2>\n<p>基于Arc实现的引用计数，来实现在Mutex在多线程之间的共享的示例代码如下：</p>\n<pre><code class=\"language-rust\">use std::sync::{Arc, Mutex};\nuse std::thread;\n\nfn main() {\n    let counter = Arc::new(Mutex::new(0));\n    let mut handles = vec![];\n\n    for _ in 0..10 {\n        let counter = Arc::clone(&amp;counter);\n        let handle = thread::spawn(move || {\n            let mut num = counter.lock().unwrap();\n\n            *num += 1;\n        });\n        handles.push(handle);\n    }\n\n    for handle in handles {\n        handle.join().unwrap();\n    }\n\n    println!(\"Result: {}\", *counter.lock().unwrap());\n}</code></pre>\n<p>运行上述代码，结果如下：</p>\n<pre><code class=\"language-rust\">Result: 10</code></pre>\n<p></p>\n</div>\n</div>"}