{"blogid": "123340046", "writerAge": "码龄2年", "writerBlogNum": "100", "writerCollect": "98", "writerComment": "8", "writerFan": "21", "writerGrade": "4级", "writerIntegral": "1012", "writerName": "缘笙箫196", "writerProfileAdress": "writer_image\\profile_123340046.jpg", "writerRankTotal": "37180", "writerRankWeekly": "285188", "writerThumb": "14", "writerVisitNum": "58912", "blog_read_count": "4722", "blog_time": "已于 2022-03-09 11:24:16 修改", "blog_title": "Unity——射线检测", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p><strong>1.new Raw（cube0.transform，Vector3.forward）</strong></p>\n<p>射线，第一个参数：射线的起始点；第二参数：射线的方向</p>\n<pre><code class=\"language-cs\"> myray = new Ray(this.gameObject.transform.position, Vector3.forward);</code></pre>\n<p><strong>2.Physics.Raycast（myray）</strong></p>\n<p>物理射线检测，返回值是bool类型，根据返回值只能确定当前射线有没有碰撞到其他碰撞体</p>\n<p></p>\n<p><strong>RaycastHit hitInfo</strong></p>\n<p><strong>Physics.Raycast(myray,out hitInfo)</strong></p>\n<p>返回值只能返回是否碰撞到其他碰撞体；但是out出来一个hitInfo值是我们需要的射线碰撞到的信息</p>\n<pre><code class=\"language-cs\"> RaycastHit hit;\n        if(Physics.Raycast(myray,out hit))\n        {\n            Debug.Log(\"transfirm:\" + hit.transform + \n            \",name:\" + hit.transform.name + \n            \",point:\" + hit.point + \",nor:\" + hit.normal);\n        }</code></pre>\n<p><img alt=\"\" height=\"61\" src=\"image\\bf524746c4884fa39278d7bd4240167a.png\" width=\"1093\"/></p>\n<p> <img alt=\"\" height=\"194\" src=\"image\\396c8ac9b20242b2be91deac0fbeee70.png\" width=\"497\"/></p>\n<p> <strong>当我们的射线碰撞到一个游戏物体的碰撞体后，返回一个hit值这个对象包含的信息</strong></p>\n<p><strong>collider:</strong>碰撞到的游戏物体的碰撞体</p>\n<p><strong>distance:</strong>碰撞体到射线起始点的距离</p>\n<p><strong>normal:</strong>碰撞点所在的平面的法向量</p>\n<p><strong>point:</strong>实际碰撞到的点的世界坐标位置</p>\n<p><strong>rigidbody:</strong>碰撞到的游戏物体的刚体</p>\n<p><strong>transform:</strong>碰撞到的游戏物体的Transform组件</p>\n<blockquote>\n<p>Physics.Raycast(myray,out hit,100,</p>\n<p><strong>(1&lt;&lt;LayerMask.NameToLayer(\"UI\"))+(1&lt;&lt;LayerMask.NameToLayer(\"cube\"))</strong>)</p>\n</blockquote>\n<p>Int类型的参数是1左移对应层数所得来的，这样的操作可以一次检测到多个层的游戏物体</p>\n<p></p>\n<p><strong>3.Camera.main.ScreenPointToRay(Input.mousePosition);</strong></p>\n<p><strong>        </strong>将鼠标触摸在屏幕上的点转换为射线</p>\n<p></p>\n<p><strong>实现射击的效果</strong></p>\n<pre><code class=\"language-cs\"> //定义一个射线\n    Ray myray;\n    //炮弹\n    public GameObject bullet;\n    //射线的返回值\n    RaycastHit hitInfo;\n    //弹痕\n    public GameObject quade;\n\n    void Update()\n    {\n        //运用这个api可以将输入的鼠标坐标转换为射线\n        myray = Camera.main.ScreenPointToRay(Input.mousePosition);\n        \n        if (Input.GetMouseButtonDown(0))\n        {\n\n            if(Physics.Raycast(myray,out hitInfo, 1000))\n            {\n                //从摄像头到碰撞物体的距离\n                Vector3 dir = hitInfo.point - transform.position;\n                //生成子弹\n                GameObject go =GameObject.Instantiate(bullet);\n                //初始化子弹\n                go.transform.position = transform.position;\n                //给子弹初速度\n                go.GetComponent&lt;Rigidbody&gt;().velocity = dir.normalized * 20;\n                //生成弹痕\n                GameObject shader = GameObject.Instantiate(quade);\n                //弹痕生成的位置\n                shader.transform.position = hitInfo.point + Vector3.forward;\n                //弹痕的朝向\n                shader.transform.rotation = Quaternion.LookRotation(-hitInfo.normal);\n            }\n            else\n            {\n                Vector3 v2 = Camera.main.ScreenToWorldPoint(Input.mousePosition+new Vector3(0,0,100));\n\n                GameObject go = GameObject.Instantiate(bullet);\n                go.transform.position = transform.position;\n                go.GetComponent&lt;Rigidbody&gt;().velocity = v2.normalized * 20;\n            }\n        }\n    }</code></pre>\n<p></p>\n<p><strong>4.RaycastAll</strong></p>\n<p><strong>一条射线碰撞到多个碰撞体</strong></p>\n<pre><code class=\"language-cs\">private Ray myray;\n    private RaycastHit[] rayInfo;\n\n    // Update is called once per frame\n    void Update()\n    {\n        myray = new Ray(this.transform.position, -Vector3.left);\n        Debug.DrawRay(this.transform.position, -Vector3.left,Color.red,10000);\n        rayInfo = Physics.RaycastAll(myray, 100, (1 &lt;&lt; LayerMask.NameToLayer(\"cube\")));\n        //这个RaycastHit[]能够接收所有碰撞到的物体信息，如果没有碰撞到返回的长度就是0\n        for (int i = 0; i &lt; rayInfo.Length; i++)\n        {\n            Debug.Log(rayInfo[i].transform.name);\n        }\n    }</code></pre>\n<p></p>\n</div>\n</div>"}