{"blogid": "124090314", "writerAge": "码龄7年", "writerBlogNum": "47", "writerCollect": "174", "writerComment": "24", "writerFan": "183", "writerGrade": "3级", "writerIntegral": "581", "writerName": "44w0", "writerProfileAdress": "writer_image\\profile_124090314.jpg", "writerRankTotal": "28306", "writerRankWeekly": "363379", "writerThumb": "87", "writerVisitNum": "43979", "blog_read_count": "7219", "blog_time": "于 2022-04-11 08:12:21 发布", "blog_title": "js判断数据类型（全）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h2><a id=\"js_0\"></a>js基本数据类型</h2>\n<ol><li>基本数据类型：<br/> String、Number、Boolean、Undefined未定义、null空、symbol表示独一无二的值（es6引入的新的原始数据基本类型）。<br/> Number：返回的特殊值NaN，表示不是数值，用于表示本来要返回的数值的操作失败了。<br/> String：字符串是不可变的，一旦创建，值就不能变了。做的字符串操作是先对原字符串进行销毁再创建的。<br/> null：null值表示一个空对象指针，typeof null 结果是object。<br/> symbol（符号）：是原始值，且实例是唯一、不可变的。用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险。</li><li>引用类型：<br/> 对象Object、数组Array、函数function<br/> 函数存在三种常见的表达方式：<br/> 1.函数声明 function sum(a,b){return a+b;}<br/> 2.函数表达式 let sum = function(a,b){return a+b};<br/> 3.箭头函数 let sum = (a,b)=&gt;{return a+b;}</li></ol>\n<h2><a id=\"_14\"></a>查看数据类型</h2>\n<ol><li> <p>typeof<br/> typeof对于一些类型的处理只返回了处于其原型链最顶端的object类型。<br/> 引用类型除了function返回function类型之外，其他都返回object。<br/> ○ NaN的数据类型是number<br/> ○ 数组(Array)和日期Date的数据类型是object<br/> ○ 不能检测出null，检测null的数据类型是object</p> </li><li> <p>toString<br/> toString是Object的原型方法，调用该方法，返回当前对象的[[class]]。对于Object对象，直接调用toString()就可以返回，对于其他类型需要通过call()/apply()来调用才能返回正确的类型信息。<br/> 使用：<br/> Object.prototype.toString.call(‘’ '); //[[Object String]]</p> </li><li> <p>constructor<br/> 无法判断null和undefined<br/> 原型prototype的一个属性，函数被定义的时候，js引擎会为函数添加原型prototype，并且这个prototype种constructor属性指向函数应用。<br/> 使用：<br/> [].constructor ==Array //true<br/> new Date().constructor == Date //true</p> </li><li> <p>instanceof<br/> 用来判断A是否为B的实例，A instanceof B，如果A是B的实例，返回true否则返回false。instanceof检测的是原型。<br/> <img alt=\"在这里插入图片描述\" src=\"image\\f1f28a03440549b1a86bd538f3843a74.png\"/></p> <p>可以看出[] 的原型指向Array.prototype，间接指向Object.prototype，因此 [] instanceof Array 返回true，[] instanceof Object 也返回true。</p> <p>instanceof只能判断两个对象之间是否属于实例关系，不能判断一个对象属于哪种类型。</p> </li><li> <p>typeof与instanceof的区别<br/> 1.typeof返回字符串，也就是返回一个变量基本类型，instanceof返回布尔值<br/> 2.instanceof相对来说，更适合判断：一个对象是否是一个构造函数的实例 。对于类型的判断存在不确定性：例如一个数组，它的_proto_原型执行Array.prototype，间接指向Object.prototype，因此 [] instanceof Array 返回true，[] instanceof Object 也返回true。<br/> 3.typeof存在弊端，无法检测null类型和除了function以外的引用类型。</p> </li><li> <p>怎样判断是否是数组</p>\n<ol><li>Array.isArray(arr)== true;</li><li>arr.constructor()=== Array ;</li><li>Object.prototype.toString.call(arr) === “[object Array]”</li></ol> </li></ol>\n<p>7.什么不直接Object.prototype.toString().call(arr)，为什么要放在call()中</p>\n<ol><li> <p>两个toString根本不是同个方法，object本身是一个构造函数，任意一个函数自身的toString方法都是继承自function构造函数。而Object原型下面的构造函数是返回对象内部的class值。</p> </li><li> <p>虽然Array也继承自Object，但js在Array.prototype上重写了toString，而我们通过toString.call(arr)实际上是通过原型链调用了。</p> </li></ol>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}