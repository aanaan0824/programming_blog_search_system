{"blogid": "126743419", "writerAge": "None", "writerBlogNum": "4650", "writerCollect": "12088", "writerComment": "1192", "writerFan": "12083", "writerGrade": "9级", "writerIntegral": "84819", "writerName": "阿里云云栖号", "writerProfileAdress": "writer_image\\profile_126743419.jpg", "writerRankTotal": "26", "writerRankWeekly": "1746", "writerThumb": "3179", "writerVisitNum": "6015125", "blog_read_count": "16", "blog_time": "于 2022-09-07 12:55:44 发布", "blog_title": "从0到1使用 Webpack5 + React + TS 构建标准化应用", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p class=\"img-center\"><img alt=\"\" src=\"image\\2bca92f4622c849272324b2272a5c39f.jpeg\"/></p>\n<h3>前言</h3>\n<p>本篇文章主要讲解如何从一个空目录开始，建立起一个基于webpack + react + typescript的标准化前端应用。</p>\n<ul><li>技术栈: webpack5 + React18 + TS</li><li>工程化: eslint + prettier + husky + git hooks</li><li>支持图片、less、sass、fonts、数据资源(JSON、csv、tsv等)、Antd按需加载以及主题</li><li>支持热更新、资源压缩、代码分离（动态导入、懒加载等）、缓存、devServer</li></ul>\n<h3>背景</h3>\n<p>在项目开发中，我们可以使用create-react-app或者飞冰等脚手架工具，那么，为什么我们要自己来搭建一个标准化项目？</p>\n<h3>原因</h3>\n<ul><li>当我们使用优秀的脚手架工具开发项目时，当然会提升很多便利，他们的功能更全面、性能更强大，但是在这些值得学习的榜样面前，我们需要从零开始，动手去实现每一个细节和功能，看的再多都不如自己动手实现一个demo更有效果。并且动手实践也可以帮助我们理解项目打包和编译的原理，进而提升自己的技术熟练度，扩展我们的知识面。Webpack 实现工程化方方面面的功能，自然不是 all in one code实现的。从 Webpack 的设计理念和实现原理中，我们能接触到工程化方面的知识：架构扩展、插件化、缓存机制。学习Webpack也代表着学习前端的发展趋势：例如在webpack的竟对Vite上，我们可以学到bundleless的理念，跳过了传统的打包这个概念，并且其他先进理念都是我们需要去学习的地方。</li><li>开发中，我们发现使用def、aone等生成一个成熟的前端项目模版，不难会发现，项目中的babel、weback、prettier、loader等配置文件缺失，而且难以修改现成的脚手架配置，可扩展能力较弱。导致在性能优化方面能做的工作有限，使得开发受到限制。</li></ul>\n<h3>项目结构</h3>\n<h3>目录</h3>\n<pre><code>├── dist                                // 默认的 build 输出目录\n├── .husky                              // pre-commit hook\n├── webpack.config.js                   // 全局配置文件及webpack配置文件\n├── test                                // 测试目录\n└── src                                 // 源码目录\n    ├── assets                          // 公共的文件（如image、css、font等）\n    ├── components                      // 项目组件\n    ├── constants                       // 常量/接口地址等\n    ├── routes                          // 路由\n    ├── utils                           // 工具库\n    ├── pages                           // 页面模块\n        ├── Home                        // Home模块，建议组件统一大写开头\n        ├── ...\n    ├── App.tsx                         // react顶层文件\n    ├── typing                          // ts类型文件\n├── .editorconfig                       // IDE格式规范\n├── .eslintignore                       // eslint忽略\n├── .eslintrc                           // eslint配置文件\n├── .gitignore                          // git忽略\n├── .prettierrc                         // prettierc配置文件\n├── .babelrc                         // babel配置文件\n├── LICENSE.md                          // LICENSE\n├── package.json                        // package\n├── README.md                           // README\n├── tsconfig.json                       // typescript配置文件</code></pre>\n<h3>依赖</h3>\n<pre><code>\"dependencies\": {\n    \"antd\": \"^4.22.4\", // 懂得都懂\n    \"react\": \"^18.2.0\", // 懂得都懂\n    \"react-dom\": \"^18.2.0\" // 懂得都懂\n  },\n  \"devDependencies\": {\n    // babel全家桶\n    \"@babel/core\": \"^7.18.10\",\n    \"@babel/plugin-proposal-class-properties\": \"^7.18.6\", // React class支持\n    \"@babel/plugin-transform-runtime\": \"^7.18.10\", // 抽离提取 Babel的注入代码，防止重复加载，减小体积\n    \"@babel/preset-env\": \"^7.18.10\", // 提供的预设，允许我们使用最新的JavaScript\n    \"@babel/preset-react\": \"^7.18.6\", // react支持\n      \n    // ts类型检查\n    \"@types/node\": \"^18.6.4\",\n    \"@types/react\": \"^18.0.15\",\n    \"@types/react-dom\": \"^18.0.6\",\n    // @types 开头的是对应包的 TypeScript 类型声明\n    \"@typescript-eslint/eslint-plugin\": \"^5.33.0\",\n    \"@typescript-eslint/parser\": \"^5.33.0\",\n      \n    // webpack loader：解析对应文件\n    \"csv-loader\": \"^3.0.5\",\n    \"sass-loader\": \"^13.0.2\",\n    \"xml-loader\": \"^1.2.1\",\n    \"ts-loader\": \"^9.3.1\",\n    \"less-loader\": \"^11.0.0\",\n      \n    // eslint全家桶\n    \"eslint\": \"^8.21.0\",\n    \"eslint-config-ali\": \"^14.0.1\", // ali前端规约\n    \"eslint-config-prettier\": \"^8.5.0\", // 关闭所有不必要或可能与[Prettier]冲突的规则\n    \"eslint-import-resolver-typescript\": \"^3.4.0\", // 添加 ts 语法支持  eslint-plugin-import\n    \"eslint-plugin-import\": \"^2.26.0\", // ES6+  import/export 语法支持\n    \"eslint-plugin-prettier\": \"^4.2.1\", // prettier语法支持\n    \"eslint-plugin-react\": \"^7.30.1\", // react语法支持\n    \"eslint-plugin-react-hooks\": \"^4.6.0\", // hooks语法支持\n    \"eslint-webpack-plugin\": \"^3.2.0\", \n    \n    // webpack plugin\n    \"fork-ts-checker-webpack-plugin\": \"^7.2.13\", // 避免webpack中检测ts类型\n    \"html-webpack-plugin\": \"^5.5.0\", // 简化HTML文件的创建 ，配合webpack包含hash的bundle使用\n    \"mini-css-extract-plugin\": \"^2.6.1\", // css拆分\n    \"optimize-css-assets-webpack-plugin\": \"^6.0.1\", // css压缩\n    \"terser-webpack-plugin\": \"^5.3.3\", // 使用 terser 压缩 js （terser 是一个管理和压缩 ES6+ 的工具）\n    \"webpack-bundle-analyzer\": \"^4.5.0\", // webpack打包体积可视化分析\n    \"webpack-cli\": \"^4.10.0\", // 提供脚手架命令\n    \"webpack\": \"^5.74.0\", // webpack引擎\n    \"webpack-dev-server\": \"^4.9.3\", // 开发环境的live server\n     \n    // 工具\n    \"husky\": \"^8.0.1\", // 自动配置 Git hooks 钩子\n    \"less\": \"^4.1.3\", // css类型\n    \"sass\": \"^1.54.3\", // css类型\n    \"typescript\": \"^4.7.4\", // ts\n    \"lint-staged\": \"^13.0.3\", // 对暂存的git文件运行linter\n    \n    // prettier 格式化\n    \"prettier\": \"^2.7.1\",\n    \"pretty-quick\": \"^3.1.3\", // 在更改的文件上运行 prettier\n  }</code></pre>\n<h3>实现过程</h3>\n<h3>项目初始化</h3>\n<p>首先从一个空目录开始，对项目初始化：</p>\n<pre><code>mkdir demo\ncd demo\ngit init\nnpm init</code></pre>\n<h3>React和Babel引入</h3>\n<p>对于一个React项目，我们首先要安装React，写一个Hello World！</p>\n<p>安装我们主要的项目依赖：</p>\n<pre><code>tnpm i -S react react-dom</code></pre>\n<p>由于我们的浏览器不支持最新的ECMAScript语法，所以我们需要Babel来转义为ES5或者ES6。</p>\n<p>安装我们的Babel来提高兼容性:</p>\n<pre><code>tnpm i -D @babel/core babel-preset-env babel-preset-react @babel/plugin-proposal-class-properties</code></pre>\n<ul><li>@babel/core: babel转码的核心引擎</li><li>babel-preset-env: 添加对ES5、ES6的支持</li><li>babel-preset-react: 添加对JSX的支持</li><li>@babel/plugin-proposal-class-properties: 对React中class的支持</li></ul>\n<h3>Webpack引入</h3>\n<pre><code>tnpm i -D webpack webpack-cli webpack-dev-server html-webpack-plugin</code></pre>\n<ul><li>webpack: weback插件的核心依赖</li><li>webpack-cli: 为插件提供命令行工具</li><li>webpack-dev-server: 帮助启动live server</li><li>html-webpack-plugin: 帮助创建HTML模版</li></ul>\n<h3>Babel配置</h3>\n<p>.babelrc中添加基本配置:</p>\n<pre><code>{\n  \"presets\": [\"@babel/react\", \"@babel/env\"],\n  \"plugins\": [\"@babel/plugin-proposal-class-properties\"]\n}</code></pre>\n<h3>Babel Plugin</h3>\n<p>Babel是代码转换器，借助Babel，我们可以使用最流行的js写法，而plugin就是实现Babel功能的核心。</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\0bf2907408b1e9df752dfcbd95b2b634.png\"/></p>\n<p>这里的配置是为了支持react中class的写法。</p>\n<h3>Babel Preset</h3>\n<p>Babel的Plugin一般拆成尽可能小的粒度，开发者可以按需引进，例如ES6到ES5的功能，官方提供了20+插件，这样可以提高性能和扩展性，但是很多时候逐个引入就很让人头大，而Babel Preset就是为此而生，可以视为Presets是相关Plugins的集合。</p>\n<ul><li>@babel/react: 支持了React所有的转码需求</li><li>@babel/env: 不夸张滴讲，仅需要它自己内部的配置项，就可以完成现代JS工程几乎所有的转码需求</li></ul>\n<h3>Webpack基本配置</h3>\n<p>新建一个webpack.config.js文件。</p>\n<pre><code>//webpack.config.js\nconst path = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\nmodule.exports = {\n   entry: './src/index.js',\n   output: {\n      path: path.join(__dirname, '/dist'),\n      filename: 'bundle.js'\n   },\n   devServer: {\n      port: 8080\n   },\n   module: {\n      rules: [\n         {\n            test: /\\.jsx?$/,\n            exclude: /node_modules/,\n            loader: 'babel-loader',\n         },\n         {\n            test: /\\.css$/,\n            use: [ 'style-loader', 'css-loader' ]\n        }\n      ]\n   },\n   plugins:[\n       new HtmlWebpackPlugin({\n            template: path.join(__dirname,'/src/index.html')\n       }) \n   ]\n}</code></pre>\n<ul><li>entry: 入口，开始打包的起点</li><li>output: 打包文件的地址</li><li>devServer: live server配置</li><li>test: 使用loader的文件类型</li><li>loader: 将要使用的loader</li></ul>\n<h3>Package.json基本配置</h3>\n<pre><code>\"start\": \"webpack serve --mode development --open --hot\",\n\"build\": \"webpack --mode production\"</code></pre>\n<ul><li>mode: process.env.NODE_ENV --&gt; development, 为modules和chunks启用有意义的名称</li><li>open: 告诉server在服务启动后打开默认浏览器</li><li>hot: 开启热更新</li></ul>\n<h3>写一个React Demo</h3>\n<p>目前的项目结构如下图所示：</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\5190ec5c13a6e7a13e90b3cffd188be8.jpeg\"/></p>\n<p>js和html文件如下图所示：</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\5e59abab0f3c254a513327dbcb2fa2bb.png\"/></p>\n<p>最后，只要start一下，项目就会启动在8080端口。</p>\n<h3>TypeScript配置</h3>\n<pre><code>tnpm install -D typescript ts-loader @types/node @types/react @types/react-dom</code></pre>\n<ul><li>typescript: TypeScript的主要引擎</li><li>ts-loader: 转义.ts --&gt; .js 并打包</li><li>@types/node @types/react @types/react-dom: 对node、react、react dom类型的定义</li></ul>\n<p>同时在根目录加入tsconfig.json来对ts编译进行配置：</p>\n<pre><code>//_tsconfig.json_\n\n{\n  \"compilerOptions\": {\n    \"outDir\": \"./dist/\",\n    \"noImplicitAny\": true,\n    \"module\": \"es6\",\n    \"target\": \"es5\",\n    \"jsx\": \"react\",\n    \"allowJs\": true,\n    \"allowSyntheticDefaultImports\": true,\n    \"moduleResolution\": \"Node\"\n  }\n}</code></pre>\n<p>最后在webpack中添加对ts的支持。</p>\n<h3>添加ts-loader：</h3>\n<pre><code>//_webpack.config.js_\n...\n{\n  test: /\\.tsx?$/,\n  exclude: /node_modules/,\n  loader: 'ts-loader'\n}\n...</code></pre>\n<h3>设置resolve属性，来指定文件如何被解析：</h3>\n<pre><code>//_webpack.config.js_\n...\nresolve: \n{\n   extensions: [ '.tsx', '.ts', '.js' ],\n}\n...</code></pre>\n<h3>rename入口：</h3>\n<pre><code>//_webpack.config.js_\n...\nentry: \"./src/index.tsx\",\n...</code></pre>\n<p>最后启动一下server来看一下ts配置是否正确。</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\4d2d7c7812132249561c4381f72cd021.jpeg\"/></p>\n<p>上述我们的配置其实相当于执行了一次：</p>\n<pre><code>npx create-react-app my-app --template typescript</code></pre>\n<p>在这种流程下很是麻烦，将 *.ts 提供给 TypeScript，然后将运行的结果提供给 Babel，而且还要借助很多loader。</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\7b7e69193ed5bc7d6b19c6142cee028f.png\"/></p>\n<p>那么我们能不能简化一下这样的流程，因为Babel7中提供的babel-loader就可以完美进行编译ts，答案是可以的，这种方式直接简化了过程。</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\50ac4d2370443a17731bdccf0ac17439.png\"/></p>\n<pre><code>module: {\n    rules: [\n      {\n        test: /\\.tsx?$/,\n        exclude: /node_modules/,\n        loader: ['babel-loader']\n      }\n    ]\n  },</code></pre>\n<p>并且在.babelrc中也只多了一行@babel/preset-typescript，这种配置更简单，而且打包速度更快一点，逻辑更加清晰。</p>\n<p>那么为什么还要在项目中使用ts-loader呢？</p>\n<ul><li>ts-loader 在内部是调用了 TypeScript 的官方编译器 -- tsc。所以，ts-loader 和 tsc 是共享 tsconfig.json，所以会提供完整的报错信息，ts-loader也与 vscode 提供的语法校验表现一致</li><li>而@babel/preset-typescript有的时候会无法提供完整的报错信息和类型提示</li></ul>\n<h3>管理资源</h3>\n<p>webpack 只能理解 JavaScript 和 JSON 文件，这是 webpack 开箱可用的自带能力。loader 让 webpack 能够去处理其他类型的文件，并将它们转换为有效的模块中。</p>\n<p>loader中，test属性可以识别出哪些文件会被转换；use属性可以定义出转换时，应该是用哪个loader。</p>\n<h3>CSS、Less、Sass</h3>\n<p>安装loader：</p>\n<pre><code>tnpm i -D less less-loader style-loader css-loader sass sass-loader</code></pre>\n<p>webpack配置：</p>\n<pre><code>//_webpack.config.js_\n...\nrules: [\n      {\n        test: /\\.jsx?$/,\n        exclude: /node_modules/,\n        loader: 'babel-loader',\n      },\n      {\n        test: /\\.css$/,\n        use: ['style-loader', 'css-loader'],\n      },\n      {\n        test: /\\.tsx?$/,\n        exclude: /node_modules/,\n        loader: 'ts-loader',\n      },\n      {\n        test: /\\.(less|css)$/,\n        exclude: /\\.module\\.less$/,\n        use: [\n          {\n            loader: 'css-loader',\n            options: {\n              importLoaders: 2,\n              sourceMap: !!DEV,\n            },\n          },\n          {\n            loader: 'less-loader',\n            options: {\n              sourceMap: !!DEV,\n            },\n          },\n        ],\n      },\n      {\n        test: /\\.(sass|scss)$/,\n        use: [\n          {\n            loader: 'css-loader',\n            options: {\n              importLoaders: 2,\n              sourceMap: !!DEV,\n            },\n          },\n          {\n            loader: 'sass-loader',\n            options: {\n              sourceMap: !!DEV,\n            },\n          },\n        ],\n      },\n ...</code></pre>\n<h3>图片、JSON资源</h3>\n<p>对于图片和字体，我们可以使用内置的Assets Modules来轻松地把这些内容加到我们的系统中，对于类型，我们可以选择：</p>\n<ul><li>asset/resource 发送一个单独的文件并导出 URL。</li><li>asset/inline 导出一个资源的 data URI。</li><li>asset/source 导出资源的源代码。</li><li>asset 在导出一个 data URI 和发送一个单独的文件之间自动选择。</li></ul>\n<pre><code>//_webpack.config.js_\n...\nmodule: {\n  rules: [{\n    test: /\\.png/,\n    type: 'asset/resource'\n  }]\n},\n...</code></pre>\n<p>对于其他类型资源，我们需要安装csv-loader、xml-loader等：</p>\n<pre><code>//_webpack.config.js_\n...\n{\n  test: /\\.(csv|tsv)$/i,\n  use: ['csv-loader'],\n},\n{\n  test: /\\.xml$/i,\n  use: ['xml-loader'],\n},\n...</code></pre>\n<h3>搭建开发环境</h3>\n<p>目前，我们的应用已经可以正常运行tsx文件，并且在本地进行调试和开发，那么我们来看看如何设置一个开发环境，来使开发变得更加轻松。</p>\n<pre><code>//_webpack.config.js_\n...\nconst { DEV, DEBUG } = process.env;\nprocess.env.BABEL_ENV = DEV ? 'development' : 'production';\nprocess.env.NODE_ENV = DEV ? 'development' : 'production';\n...\nmode: DEV ? 'development' : 'production',\ndevtool: DEV &amp;&amp; 'source-map',\n...</code></pre>\n<p>我们可以从process.env中获取环境变量来区分开发环境和生产环境。</p>\n<p>当webpack在本地打包代码时，我们可以使用inline-source-map，可以将编译后的代码映射回原始源代码，这样在报错的时候，错误就会被定为到确切的文件和行数。当然，在生产环境中，为了保护隐私，最好把这个设置动态关掉。<br/> 在开发环境中，webpack-dev-server会为你提供一个基本的web server，并且具有实时重新加载功能。</p>\n<h3>完善打包配置与缓存</h3>\n<p>我们希望每次打包都把上次的打包文件删除，可以使用CleanWebpackPlugin：</p>\n<pre><code>//_webpack.config.js_\n...\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin');\n\nmodule.exports = {\n  plugins: [\n    new CleanWebpackPlugin(),\n  ]\n}\n...</code></pre>\n<p>并且，在我们生产环境，我们希望改动后的新版本可以丢弃缓存，并且没有改动的版本可以保留缓存；但是在开发环境，我们不希望有缓存，而是每次都是拿到最新的资源。所以，需要对webpack config做一次拆分：分成</p>\n<ul><li>webpack.prod.js 生产环境打包配置</li><li>webpack.dev.js 开发环境打包配置</li></ul>\n<p>里面的区别主要在于打包后的文件名称、sourceMap等。</p>\n<h3>生产环境</h3>\n<p>contenthash：只有模块的内容改变，才会改变hash值：</p>\n<pre><code>output: {\n    filename: 'js/[name].[contenthash:8].js', // contenthash：只有模块的内容改变，才会改变hash值\n },</code></pre>\n<h3>开发环境</h3>\n<pre><code>output: {\n  filename: 'js/[name].[hash:8].js',\n}</code></pre>\n<h3>性能优化</h3>\n<h3>打包分析工具</h3>\n<p>可以使用webpack-bundle-analyzer来分析我们打包资源的大小：</p>\n<pre><code>const { BundleAnalyzerPlugin } = require('webpack-bundle-analyzer');\nplugins: [\n  DEBUG &amp;&amp; new BundleAnalyzerPlugin(),\n]</code></pre>\n<p>同时设置package.json的启动项</p>\n<h3>资源压缩</h3>\n<p>OptimizeCSSAssetsPlugin主要用来优化css文件的输出，包括摈弃重复的样式定义、砍掉样式规则中多余的参数、移除不需要的浏览器前缀等。</p>\n<p>TerserPlugin主要用来优化js体积，包括重命名变量，甚至是删除整个的访问不到的代码块。</p>\n<pre><code>//_webpack.config.js_\n...\nconst OptimizeCSSAssetsPlugin = require('optimize-css-assets-webpack-plugin');\nconst TerserPlugin = require('terser-webpack-plugin');\n...\noptimization: {\n  minimizer: [\n    new TerserPlugin({\n      parallel: false,\n      terserOptions: {\n        output: {\n          comments: false,\n        },\n      },\n    }),\n    new OptimizeCSSAssetsPlugin({}),\n  ],\n    minimize: !DEV,\n      splitChunks: {\n        minSize: 500000,\n          cacheGroups: {\n            vendors: false,\n          },\n      },\n},\n...</code></pre>\n<h3>代码分离</h3>\n<p>资源分离</p>\n<p>1)多入口</p>\n<p>webpack内置的特性能够把代码分离到不同的bundle 中，然后可以按需加载或并行加载这些文件。代码分离可以用于获取更小的bundle，以及控制资源加载优先级，如果使用合理，会极大影响加载时间。</p>\n<pre><code>//_webpack.config.js_\n...\nentry: {\n  index: './src/index.js',\n  another: './src/another-module.js',\n},\noutput: {\n  filename: '[name].bundle.js'\n...</code></pre>\n<p>2)Tree Shaking</p>\n<p>Webpack5在生产环境已经集成了Tree Shaking功能，不用的代码会被shaking掉：</p>\n<pre><code>// _webpack.config.js_\nmodule.exports = {\n  // ...\n  mode: 'production',\n};</code></pre>\n<p>但是在开发环境中需要手动配置(Not Recommend)：</p>\n<pre><code>// _webpack.config.js_\nmodule.exports = {\n  // ...\n  mode: 'development',\n  optimization: {\n    usedExports: true,\n  }\n};</code></pre>\n<p>处于好奇，webpack是如何完美的避开没有使用的代码的呢？</p>\n<p>很简单：就是 Webpack 没看到你使用的代码。Webpack 跟踪整个应用程序的import/export 语句，因此，如果它看到导入的东西最终没有被使用，它会认为那是未引用代码(或叫做“死代码”—— dead-code )，并会对其进行 tree-shaking 。死代码并不总是那么明确的。下面是一些例子：</p>\n<pre><code>// _test.js_\n// 这会被看作“活”代码，不会做 tree-shaking\nimport { add } from './math'\nconsole.log(add(5, 6))\n// 导入但没有赋值给 JavaScript 对象，也没有在代码里用到\n// 这会被当做“死”代码，会被 tree-shaking\nimport { add, minus } from './math'\nconsole.log('hello webpack')\n// 导入整个库，但是没有赋值给 JavaScript 对象，也没有在代码里用到\n// 非常奇怪，这竟然被当做“活”代码，因为 Webpack 对库的导入和本地代码导入的处理方式不同。\nimport { add, minus } from './math' // 死的\nimport 'lodash' // 活的\nconsole.log('hello webpack')\n所以对于这种三方库我们可以使用下面的Shimming方法。</code></pre>\n<p>注意 Webpack 不能百分百安全地进行 tree-shaking。有些模块导入，只要被引入，就会对应用程序产生重要影响。一个很好的例子就是全局样式表，或者设置全局配置的JavaScript 文件。Webpack 认为这样的文件有“副作用”。具有副作用的文件不应该做 tree-shaking，因为这将破坏整个应用。比较好的告诉Webpack你的代码有副作用的方法就是在package.json里面设置sideEffects。</p>\n<pre><code>{\n  \"name\": \"your-project\",\n  \"sideEffects\": [\"./src/some-side-effectful-file.js\", \"*.css\"]\n}</code></pre>\n<p>3)Shimming预置依赖</p>\n<p>对于上面的lodash库无法被shaking，我们可以使用细粒度shimming预置的方法来优化，首先引入ProvidePlugin插件，把应用程序中的模块依赖，改为一个全局变量依赖，让我们先移除 lodash 的 import语句，改为通过插件提供它，并且提取出join方法来全局使用它：</p>\n<pre><code>// _src/index.tsx\nconsole.log(join(['hello', 'webpack'], ' '))\n// _webpack.config.js_\nplugins: [\n  new webpack.ProvidePlugin({\n    //_: 'lodash'\n    // 如果没注释的话，需要这样引用console.log(_.join(['hello', 'webpack'], ' '))\n    join: ['lodash', 'join'],\n  })\n]</code></pre>\n<p>细粒度Shimming</p>\n<p>一些遗留的模块依赖的this指向的window对象，我们可以使用import-loaders，它对依赖 window 对象下的全局变量（比如 $ 或 this ）的第三方模块非常有用。</p>\n<p>CommonJS 上下文中，这将会变成一个问题，也就是说此时的 this指向的是 module.exports。在这种情况下，你可以通过使用 imports-loader覆盖 this 指向：</p>\n<pre><code>// _webpack.config.js_\nmodule: {\n  rules: [\n    {\n      test: require.resolve('./src/index.js'),\n      use: 'imports-loader?wrapper=window',\n    },\n  ]\n},</code></pre>\n<p>4)公共部分提取</p>\n<p>防止重复可以使用splitChunk，提取出代码中的公共部分：</p>\n<pre><code>//_webpack.config.js_\n...\nminimize: !DEV,\n  splitChunks: {\n    minSize: 500000,\n      cacheGroups: {\n        vendors: false,\n      },\n  },\n...</code></pre>\n<ul><li>minSize：形成一个新代码块最小的体积</li><li>cacheGroups：这里开始设置缓存的 chunks</li></ul>\n<p>5)按需分离</p>\n<p>在React项目中，代码按需分离可以使用如下方法，webpack 把 import() 作为一个分离点(split-point)，并把引入的模块作为一个单独的 chunk。import() 将模块名字作为参数并返回一个 Promoise 对象，即 import(name) -&gt; Promise。</p>\n<pre><code>//_index.tsx_\n...\nconst WdAndDxEntry = lazy(() =&gt; import(/* webpackChunkName: \"wd-and-dx\" */ '../../old-code/component/wd-and-dx/entry'));\nconst WdAndDxFallback = () =&gt; ()\nconst SSRCompatibleSuspense = (props: Parameters&lt; typeof Suspense&gt;['0']) =&gt; {\n  const isMounted = useMounted();\n  \n  if (isMounted) {\n    return &lt; Suspense {...props} /&gt;;\n  }\n  return &lt; &gt;{props.fallback}&lt; /&gt;;\n} \n...\nreturn (\n  &lt; SSRCompatibleSuspense fallback={&lt; WdAndDxFallback /&gt;}&gt;\n    &lt; WdAndDxEntry\n      className=\"\"\n      data={data}\n      style={<!-- -->{\n        height: 150,\n      }}\n      /&gt;\n  &lt; /SSRCompatibleSuspense&gt;\n);</code></pre>\n<p>6)分离三方库</p>\n<p>配置 dependOn option 选项，这样可以在多个 chunk 之间共享模块：</p>\n<pre><code>//_webpack.config.js_\n...\nmodule.exports = {\n  entry: {\n    index: {\n      import: './src/index.js',\n      dependOn: 'shared',\n  },\n  another: {\n    import: './src/another-module.js',\n    dependOn: 'shared',\n  },\n  shared: 'lodash',\n  }\n}\n...</code></pre>\n<p>CSS分离</p>\n<p>该插件MiniCssExtractPlugin将CSS提取到单独的文件中。它为每个包含CSS的JS文件创建一个CSS文件。</p>\n<pre><code>//_webpack.config.js_\n...\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin');\n...\n{\n  test: /\\.(sass|scss)$/,\n  use: [\n    {\n      loader: MiniCssExtractPlugin.loader,\n    },\n    {\n      loader: 'css-loader',\n      options: {\n        importLoaders: 2,\n        sourceMap: !!DEV,\n      },\n    },\n    {\n      loader: 'sass-loader',\n      options: {\n        sourceMap: !!DEV,\n      },\n    },\n  ],\n},\n...\nDEBUG &amp;&amp; new BundleAnalyzerPlugin(),\n  new MiniCssExtractPlugin({\n  filename: '[name].css',\n  chunkFilename: '[name].css',\n}),\n...</code></pre>\n<h3>提高构建速度</h3>\n<p>当项目体积增大时，编译时间也随之增加。其中时间大头就是ts的类型检测耗时。ts-loader 提供了一个 transpileOnly 选项，它默认为 false，我们可以把它设置为 true，这样项目编译时就不会进行类型检查，也不会输出声明文件。</p>\n<pre><code>//_webpack.config.js_\n...\nmodule: {\n  rules: [\n    {\n      test: /\\.tsx?$/,\n      use: [\n        {\n          loader: 'ts-loader',\n          options: {\n            transpileOnly: true\n          }\n        }\n      ]\n    }\n  ]\n}\n...</code></pre>\n<p>可以看一下开关这个选项后的前后对比：</p>\n<p>开启检查前</p>\n<pre><code>$ webpack --mode=production --config ./build/webpack.config.js\nHash: 36308e3786425ccd2e9d\nVersion: webpack 4.41.0\nTime: 2482ms\nBuilt at: 12/20/2019 4:52:43 PM\n     Asset       Size  Chunks             Chunk Names\n    app.js  932 bytes       0  [emitted]  main\nindex.html  338 bytes          [emitted]\nEntrypoint main = app.js\n[0] ./src/index.ts 14 bytes {0} [built]\nChild html-webpack-plugin for \"index.html\":\n     1 asset\n    Entrypoint undefined = index.html\n    [0] ./node_modules/html-webpack-plugin/lib/loader.js!./index.html 489 bytes {0} [built]\n    [2] (webpack)/buildin/global.js 472 bytes {0} [built]\n    [3] (webpack)/buildin/module.js 497 bytes {0} [built]\n        + 1 hidden module\n✨  Done in 4.88s.</code></pre>\n<p>关闭检查后</p>\n<pre><code>$ webpack --mode=production --config ./build/webpack.config.js\nHash: e5a133a9510259e1f027\nVersion: webpack 4.41.0\nTime: 726ms\nBuilt at: 12/20/2019 4:54:20 PM\nAsset       Size  Chunks             Chunk Names\napp.js  932 bytes       0  [emitted]  main\nindex.html  338 bytes          [emitted]\nEntrypoint main = app.js\n[0] ./src/index.ts 14 bytes {0} [built]\nChild html-webpack-plugin for \"index.html\":\n1 asset\nEntrypoint undefined = index.html\n[0] ./node_modules/html-webpack-plugin/lib/loader.js!./index.html 489 bytes {0} [built]\n[2] (webpack)/buildin/global.js 472 bytes {0} [built]\n[3] (webpack)/buildin/module.js 497 bytes {0} [built]\n+ 1 hidden module\n✨  Done in 2.40s.</code></pre>\n<p>From 4.88s --&gt; 2.4s，但是缺少了类型检查。</p>\n<p>这里官方推荐了一个解决方案，使用fork-ts-checker-webpack-plugin，它在一个单独的进程上运行类型检查器，此插件使用 TypeScript 而不是 webpack 的模块解析，有了 TypeScript 的模块解析，我们不必等待webpack 编译。可以极大加快编译速度。</p>\n<pre><code>//_webpack.config.js_\n...\nmodule: {\n    rules: [\n      {\n        test: /\\.tsx?$/,\n        use: [\n          {\n            loader: 'ts-loader',\n            options: {\n              transpileOnly: true\n            }\n          }\n        ]\n      }\n    ]\n  },\n  plugins: [\n    new ForkTsCheckerWebpackPlugin()\n  ]\n...</code></pre>\n<h3>用editorconfig统一编辑器规范</h3>\n<p>在根目录新建.editorconfig即可，注意不要与已有的lint规则冲突：</p>\n<pre><code>// __.editorconfig__\n# http://editorconfig.org\nroot = true\n\n[*]\n indent_style = space\n indent_size = 2\n end_of_line = lf\n charset = utf-8\n trim_trailing_whitespace = true\n insert_final_newline = true\n \n [*.md]\ntrim_trailing_whitespace = false\n\n[makefile]\nindent_style = tab\nindent_size = 4</code></pre>\n<h3>Antd配置</h3>\n<p>babel中配置按需加载：</p>\n<pre><code>{\n  \"presets\": [\"@babel/react\", \"@babel/env\"],\n  \"plugins\": [\n    \"@babel/plugin-proposal-class-properties\",\n    [\n      \"import\",\n      {\n        \"libraryName\": \"antd\",\n        \"libraryDirectory\": \"es\",\n        \"style\": true // or 'css'\n      },\n      \"antd\"\n    ]\n  ]\n}</code></pre>\n<p>webpack中定制主题：</p>\n<pre><code>module: {\n    rules: [\n      // 处理 .css\n      {\n        test: /\\.css$/,\n        use: ['style-loader', 'css-loader'],\n      },\n      // 处理 .less\n      {\n        test: /\\.less$/,\n        use: [\n          'style-loader',\n          'css-loader',\n          // less-loader\n          {\n            loader: 'less-loader',\n            options: {\n              lessOptions: {\n                // 替换antd的变量，去掉 @ 符号即可\n                // https://ant.design/docs/react/customize-theme-cn\n                modifyVars: {\n                  'primary-color': '#1DA57A',\n                },\n                javascriptEnabled: true, // 支持js\n              },\n            },\n          },\n        ],\n      },\n    ]\n  }</code></pre>\n<p>注意样式必须加载 less 格式，一个常见的问题就是引入了多份样式，less 的样式被 css 的样式覆盖了。</p>\n<h3>ESlint配置</h3>\n<p>ESlint主要功能包含代码格式和代码质量的校验，并且可以配置pre-commit来规范代码的提交。</p>\n<pre><code>tnpm install -D eslint eslint-webpack-plugin @typescript-eslint/parser @typescript-eslint/eslint-plugin eslint-plugin-react</code></pre>\n<ul><li>eslint: eslint主要引擎</li><li>eslint-webpack-plugin: webpack loader</li><li>@typescript-eslint/parser: 帮助ESlint lint ts代码</li><li>@typescript-eslint/eslint-plugin: 包含TS扩展规则的插件</li><li>eslint-plugin-react: 包含React扩展规则的插件</li></ul>\n<p>ESlint配置文件</p>\n<pre><code>// _eslintrc_\nmodule.exports =  {\n  parser:  '@typescript-eslint/parser',  // ESlint Parser\n  extends:  [\n    'plugin:react/recommended',  // 从@eslint-plugin-react中选择推荐的规则\n    'plugin:@typescript-eslint/recommended',  // 从@typescript-eslint/eslint-plugin选择推荐的规则\n  ],\n  parserOptions:  {\n    ecmaVersion:  2018,  // 帮助转化最先进的ECMAScript功能\n    sourceType:  'module',  // 允许imports的用法\n    ecmaFeatures:  {\n      jsx:  true,  // JSX兼容\n    },\n  },\n  rules:  {\n  },\n  settings:  {\n    react:  {\n      version:  'detect',  // 告诉eslint-plugin-react自动检测最新版本的react\n    },\n  },\n};</code></pre>\n<h3>Prettier配置</h3>\n<p>虽然 ESLint 也可以校验代码格式，但 Prettier 更擅长，所以项目中一般会搭配一起使用。为了避免二者的冲突，一般的解决思路是禁掉 ESLint 中与 Prettier 冲突的规则，然后使用 Prettier 做格式化， ESLint 做代码校验。</p>\n<p>prettier配置文件</p>\n<pre><code>{\n  \"arrowParens\": \"avoid\",\n  \"bracketSpacing\": true,\n  \"embeddedLanguageFormatting\": \"auto\",\n  \"htmlWhitespaceSensitivity\": \"css\",\n  \"insertPragma\": false,\n  \"jsxBracketSameLine\": true,\n  \"jsxSingleQuote\": false,\n  \"printWidth\": 100,\n  \"proseWrap\": \"preserve\",\n  \"quoteProps\": \"as-needed\",\n  \"requirePragma\": false,\n  \"semi\": true,\n  \"singleQuote\": true,\n  \"tabWidth\": 2,\n  \"trailingComma\": \"es5\",\n  \"useTabs\": true,\n  \"vueIndentScriptAndStyle\": false\n}</code></pre>\n<h3>代码提交规范</h3>\n<p>prettier 只是保证了在通过编辑器（vs code）进行格式化代码的时候，格式化成需要的格式（当然可以通过配置 onSave 在代码保存时自动格式化），但是无法保证所有人都会主动进行。<br/> 因此进行自动格式化显得非常重要，而自动格式化的是时机选择 pre-commit 最恰当，通过 git hook ，能够在 commit 之前格式化好代码（如果已经 commit，会将暂存转为提交，生成提交记录，需要回滚才会撤销）。</p>\n<pre><code>tnpm i -D pretty-quick prettier husky</code></pre>\n<ul><li>pretty-quick: 配合git-hooks进行代码检测，并且fix</li><li>husky: 可以通过配置的方式来使用git-hooks，避免手动修改</li></ul>\n<p>package.json设置</p>\n<pre><code>\"pretty\": \"./node_modules/.bin/pretty-quick --staged\"\n...\n\"husky\": {\n    \"hooks\": {\n      \"pre-commit\": \"tnpm run pretty\"\n    }\n  },</code></pre>\n<h3>Webpack完整配置</h3>\n<p>最后贴一下完整的配置，因为Aone发布自动更新版本号，所以不用拆分config文件来根据环境设置缓存，并且配置已经尽可能简化，拆分反而会增加维护成本。</p>\n<pre><code>//_webpack.config.js_\n//webpack.config.js\nconst path = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin');\nconst OptimizeCSSAssetsPlugin = require('optimize-css-assets-webpack-plugin');\nconst TerserPlugin = require('terser-webpack-plugin');\nconst ForkTsCheckerWebpackPlugin = require('fork-ts-checker-webpack-plugin');\nconst { BundleAnalyzerPlugin } = require('webpack-bundle-analyzer');\nconst ESLintPlugin = require('eslint-webpack-plugin');\n\nconst { DEV, DEBUG } = process.env;\n\nprocess.env.BABEL_ENV = DEV ? 'development' : 'production';\nprocess.env.NODE_ENV = DEV ? 'development' : 'production';\n\nmodule.exports = {\n  entry: './src/index.tsx',\n  output: {\n    path: path.join(__dirname, '/dist'),\n    filename: 'bundle.js',\n    clean: true,\n  },\n  devServer: {\n    port: 8080,\n  },\n  mode: DEV ? 'development' : 'production',\n  devtool: DEV &amp;&amp; 'source-map',\n  module: {\n    rules: [\n      {\n        test: /\\.jsx?$/,\n        exclude: /node_modules/,\n        loader: 'babel-loader',\n      },\n      {\n        test: /\\.tsx?$/,\n        exclude: /node_modules/,\n        loader: 'ts-loader',\n      },\n      {\n        test: /\\.css$/,\n        use: ['style-loader', 'css-loader'],\n      },\n      // 处理 .less\n      {\n        test: /\\.less$/,\n        use: [\n          'style-loader',\n          'css-loader',\n          // less-loader\n          {\n            loader: 'less-loader',\n            options: {\n              lessOptions: {\n                // 替换antd的变量，去掉 @ 符号即可\n                // https://ant.design/docs/react/customize-theme-cn\n                modifyVars: {\n                  'primary-color': '#1DA57A',\n                  'border-color-base': '#d9d9d9', // 边框色\n                  'text-color': '#d9d9d9'\n                },\n                javascriptEnabled: true, // 支持js\n              },\n            },\n          },\n        ],\n      },\n      {\n        test: /\\.(sass|scss)$/,\n        use: [\n          {\n            loader: MiniCssExtractPlugin.loader,\n          },\n          {\n            loader: 'css-loader',\n            options: {\n              importLoaders: 2,\n              sourceMap: !!DEV,\n            },\n          },\n          {\n            loader: 'sass-loader',\n            options: {\n              sourceMap: !!DEV,\n            },\n          },\n        ],\n      },\n      {\n        test: /\\.png/,\n        type: 'asset/resource',\n      },\n      {\n        test: /\\.(woff|woff2|eot|ttf|otf)$/i,\n        type: 'asset/resource',\n      },\n      {\n        test: /\\.(csv|tsv)$/i,\n        use: ['csv-loader'],\n      },\n      {\n        test: /\\.xml$/i,\n        use: ['xml-loader'],\n      },\n    ],\n  },\n  optimization: {\n    minimizer: [\n      new TerserPlugin({\n        parallel: false,\n        terserOptions: {\n          output: {\n            comments: false,\n          },\n        },\n      }),\n      new OptimizeCSSAssetsPlugin({}),\n    ],\n    minimize: !DEV,\n    splitChunks: {\n      minSize: 500000,\n      cacheGroups: {\n        vendors: false,\n      },\n    },\n  },\n  resolve: {\n    modules: ['node_modules'],\n    extensions: ['.json', '.js', '.jsx', '.ts', '.tsx', '.less', 'scss'],\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: path.join(__dirname, '/src/index.html'),\n      filename: 'app.html',\n      inject: 'body',\n    }),\n    DEBUG &amp;&amp; new BundleAnalyzerPlugin(),\n    new MiniCssExtractPlugin({\n      filename: '[name].css',\n      chunkFilename: '[name].css',\n    }),\n    new ESLintPlugin(),\n    new ForkTsCheckerWebpackPlugin(),\n  ].filter(Boolean),\n};</code></pre>\n<h3>总结</h3>\n<p>这篇文章主要记录了开发过程中从项目初始化开始，再到一个标准化前端项目的搭建路程。涉及相关代码规范、开发环境搭建、生产环境优化等，旨在打造出一个可快速使用的现代Webpack5.x+React18.x+Typescript+Antd4.x模板，以供在以后的实际业务场景需求中零成本使用。</p>\n<p><strong>推荐阅读</strong></p>\n<p><a href=\"https://link.zhihu.com/?target=https%3A//developer.aliyun.com/article/%25E9%2593%25BE%25E6%258E%25A5%25E5%259C%25B0%25E5%259D%2580https%253A//mp.weixin.qq.com/s%3F__biz%3DMzIzOTU0NTQ0MA%3D%3D%26mid%3D2247509237%26idx%3D1%26sn%3D4d99a5bb722edaa5fd09494268830ea2%26chksm%3De92a99fade5d10ec1e5abefe5b645ea7c9ab4b0706a05a48ed3e04767b3131dd8439983dc915%26scene%3D21%23wechat_redirect\" title=\"1.研发效能的思考总结\">1.研发效能的思考总结</a></p>\n<p><a href=\"https://link.zhihu.com/?target=https%3A//developer.aliyun.com/article/%25E9%2593%25BE%25E6%258E%25A5%25E5%259C%25B0%25E5%259D%2580https%253A//mp.weixin.qq.com/s%3F__biz%3DMzIzOTU0NTQ0MA%3D%3D%26mid%3D2247508588%26idx%3D1%26sn%3D1d011102aeaa8f496a1bab329b8bf0ce%26chksm%3De92a9f63de5d1675ccaa257304b5b395c25ccffd4ccaf50c2c93aeadce5bdef272fb436be4cd%26scene%3D21%23wechat_redirect\" title=\"2.关于技术能力的思考和总结\">2.关于技术能力的思考和总结</a></p>\n<p><a href=\"https://link.zhihu.com/?target=https%3A//developer.aliyun.com/article/%25E9%2593%25BE%25E6%258E%25A5%25E5%259C%25B0%25E5%259D%2580https%253A//mp.weixin.qq.com/s%3F__biz%3DMzIzOTU0NTQ0MA%3D%3D%26mid%3D2247509546%26idx%3D1%26sn%3D39acfc274b6e5c81d994f47bfd409f7e%26chksm%3De92a9b25de5d1233fa86fd9d175ae8e6eb136023bedc3e5b6b35a1b9a41e9821bbffaefbc90e%26scene%3D21%23wechat_redirect\" title=\"3. 如何结构化和清晰地进行表达\">3. 如何结构化和清晰地进行表达</a></p>\n<p>作者 | 刘皇逊(恪语)</p>\n<p><strong><a href=\"https://link.zhihu.com/?target=https%3A//click.aliyun.com/m/1000357087/\" title=\"原文链接\">原文链接</a></strong></p>\n<p><strong>本文为阿里云原创内容，未经允许不得转载</strong></p>\n</div>\n</div>"}