{"blogid": "126620645", "writerAge": "码龄1年", "writerBlogNum": "62", "writerCollect": "62", "writerComment": "10", "writerFan": "12", "writerGrade": "3级", "writerIntegral": "695", "writerName": "哈哈ha~", "writerProfileAdress": "writer_image\\profile_126620645.jpg", "writerRankTotal": "26290", "writerRankWeekly": "7659", "writerThumb": "62", "writerVisitNum": "7921", "blog_read_count": "506", "blog_time": "于 2022-08-31 19:09:22 发布", "blog_title": "vue——响应式数据、双向数据绑定、filter过滤器、面试题", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h1>一、响应式数据（面试题）</h1>\n<h3>1.响应式数据：</h3>\n<blockquote>\n<ul><li>内存中的数据改变 页面UI随之动态刷新 这种数据就是响应式数据。</li><li>只能由代码改变UI或者只能由UI改变代码。</li></ul>\n</blockquote>\n<h3>2.响应式数据的设计原理：</h3>\n<blockquote>\n<p> <strong>vue2.0：</strong></p>\n<ul><li>采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各属性setter，getter。在数据变动时发布消息给订阅者，触发相应监听回调。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty 将它们转为 getter/setter。</li><li>用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。视图中的变化会通过 watcher 更新 vm 中的数据 而非 data 中的数据。若 data 中某属性多次发生变化，watcher 仅会进入更新队列一次。</li></ul>\n<p>  <strong>vue3.0：</strong></p>\n<ul><li>使用es6 proxy 代理了data对象</li></ul>\n</blockquote>\n<p>    <strong>自实现响应式数据绑定：</strong></p>\n<pre><code class=\"language-html\">  &lt;div id=\"myvue\"&gt;\n        &lt;h1 id=\"title\"&gt;&lt;/h1&gt;\n        &lt;p id=\"msg\"&gt;&lt;/p&gt;\n    &lt;/div&gt;\n    &lt;script&gt;\n        function myVue(option) {\n            let _myvm = {}\n            //劫持\n            let arr = Object.keys(option.data)\n            for (let i = 0; i &lt; arr.length; i++) {\n                // _myvm[arr[i]]=option.data[arr[i]] \n                Object.defineProperty(_myvm, arr[i], {\n                    set(val) {\n                        //劫持\n                        option.data[arr[i]] = val\n                        //响应-刷新页面\n                        //渲染\n                        let title = document.querySelector(option.el + \" #title\")\n                        let msg = document.querySelector(option.el + \" #msg\")\n                        title.innerHTML = _myvm['title']\n                        msg.innerHTML = _myvm['msg']\n                    },\n                    get() {\n                        return option.data[arr[i]]\n                    }\n                })\n                _myvm[arr[i]] = option.data[arr[i]]\n            }\n            return _myvm\n        }\n        var myvm = new myVue({\n            el: \"#myvue\",\n            data: {\n                title: \"mytitle\",\n                msg: \"mymsg\"\n            }\n        })\n    &lt;/script&gt;</code></pre>\n<p><strong> 结果显示：</strong></p>\n<p><img alt=\"\" height=\"241\" src=\"image\\5fb7444604cf4e78842793966c3ab1bd.png\" width=\"344\"/><img alt=\"\" height=\"348\" src=\"image\\d50c466e2e9f42528a18b3d25edd0308.png\" width=\"337\"/></p>\n<h1>二、数据绑定（面试题）</h1>\n<h3>1.双向数据绑定</h3>\n<p><strong>v-model:</strong></p>\n<p><strong>对 input 使用 v-model，实际上是指定其 :value 和 @input</strong></p>\n<blockquote>\n<ul><li>代码改变UI,UI也能改变代码</li><li>第一向：(响应式数据)数据容器中的数据改变，页面也随之动态刷新(DOM操作改变页面)  </li><li> 第二向：用户操作DOM改变了页面 数据容器中的数据的值也随之改变</li></ul>\n</blockquote>\n<pre><code class=\"language-html\"> &lt;div id=\"eg1\"&gt;\n        &lt;button @click=\"change\"&gt;改变&lt;/button&gt;\n        &lt;button @click=\"look\"&gt;查看&lt;/button&gt;\n     &lt;p&gt; {<!-- -->{msg}}&lt;/p&gt; \n        &lt;!-- &lt;input type=\"text\" :value=\"msg\" @input=\"myinput\"&gt; --&gt;\n        &lt;input type=\"text\" v-model=\"msg\"&gt;\n\n    &lt;/div&gt;\n    &lt;script&gt;\n        new Vue({\n            el: \"#eg1\",\n            data: {\n                msg: \"haha\"\n            },\n            methods: {\n                myinput() {\n                    this.msg = e.target.value\n                },\n                change() {\n                    this.msg = \"hh\"\n                },\n                look() {\n                    console.log(this.msg)\n                }\n            },\n        })\n    &lt;/script&gt;</code></pre>\n<p><strong>结果显示：</strong></p>\n<p><img alt=\"\" height=\"180\" src=\"image\\d6f5d965c7b7486c94d16ad8f7b8dd7f.png\" width=\"333\"/><img alt=\"\" height=\"130\" src=\"image\\d9173ddce3a54f0b8138a00fbe9a5c63.png\" width=\"339\"/></p>\n<p> <img alt=\"\" height=\"586\" src=\"image\\d4e00f6e17884c3493081178cf86ca12.png\" width=\"792\"/></p>\n<h1> 三、v-for循环渲染中key的意义（面试题） </h1>\n<p><strong>使用场景：</strong></p>\n<blockquote>\n<p>data中for循环的容器数据个数发生变化时,会跟for中的vm节点个数作比较 如果数据多了,会在vm节点后面增加对应数量的节点,并不会重新创建所有节点,然后vm去更新对应的DOM 然后就去刷新数据到界面: 按照for的数据容器中的数据顺序来渲染如果用户以前操作过旧节点,那么新数据顺序可能会出现跟旧节点顺序不匹配的效果(旧节点跟旧数据没有对应起来)</p>\n</blockquote>\n<p><strong>解决方案:</strong>  </p>\n<blockquote>\n<p><strong><span style=\"color:#0d0016;\">for循环时把数据跟创建的节点利用给元素绑定唯一key值</span></strong><br/> 因为vue在刷新页面组件时,会把旧节点跟新vm节点做比较,如果要增加节点,并不会删除旧节点,而是复用 这样会导致节点跟数据没有绑定关系而重新渲染,用key可以将数据与节点绑定起来</p>\n</blockquote>\n<blockquote>\n<p><span style=\"color:#fe2c24;\">注：</span>key值不能用数组的下标index 因为数组改变 下标也会改变   </p>\n</blockquote>\n<p><strong>意义：</strong></p>\n<blockquote>\n<ol><li>让数据跟真实的dom一一关联 使之不发生渲染混乱的情况</li><li>提高绘制渲染效率  高效更新虚拟DOM</li></ol>\n</blockquote>\n<h1>四、filter过滤器</h1>\n<ul><li> filter主要用于数据展示之前的处理</li><li>只能用在v-bind或者插值表达式中</li><li>可以调用多个函数 也可以传递多个参数</li></ul>\n<pre><code class=\"language-html\"> &lt;div id=\"eg1\"&gt;\n        &lt;p&gt;{<!-- -->{timeformat(birth)}}--调methods方法，在this上&lt;/p&gt;\n        &lt;p&gt;{<!-- -->{birth|tool|tool2}}--调filter过滤器:( 参数|函数)，不在this上&lt;/p&gt;\n        &lt;p&gt;{<!-- -->{birth|tool3(100,200)}}--多种传参&lt;/p&gt;\n    &lt;/div&gt;\n    &lt;script&gt;\n        new Vue({\n            el: \"#eg1\",\n            data: {\n                birth: \"2001-05-08\",\n            },\n            //在this上\n            methods: {\n                timeformat(str) {\n                    let age = new Date().getFullYear() - new Date(str).getFullYear()\n                    return age + \"岁\"\n                },\n            },\n            //不在this上\n            filters: {\n                tool(str) {\n                    let age = new Date().getFullYear() - new Date(str).getFullYear()\n                    return age + \"岁\"\n                },\n                tool2(str) {\n                    if(parseInt(str)&gt;18)\n                    return \"已经成年了\"\n                },\n                tool3(arg1,arg2,arg3) {\n                  console.log(arg1,arg2,arg3)\n                  return arg1\n                }\n            }\n        })\n    &lt;/script&gt;</code></pre>\n<p><strong>结果显示：</strong></p>\n<p><img alt=\"\" height=\"186\" src=\"image\\394ee9c9dfae4511b652ea069262a83b.png\" width=\"675\"/></p>\n<p></p>\n</div>\n</div>"}