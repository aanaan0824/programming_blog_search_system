{"blogid": "125332012", "writerAge": "码龄10年", "writerBlogNum": "69", "writerCollect": "477", "writerComment": "838", "writerFan": "713", "writerGrade": "5级", "writerIntegral": "2582", "writerName": "玲娜贝儿~", "writerProfileAdress": "writer_image\\profile_125332012.jpg", "writerRankTotal": "7672", "writerRankWeekly": "348", "writerThumb": "595", "writerVisitNum": "46409", "blog_read_count": "1385", "blog_time": "已于 2022-06-22 22:38:19 修改", "blog_title": "【C++】-- STL容器适配器之priority_queue", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFpriority_queue-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFpriority_queue\">一、什么是priority_queue</a></p>\n<p id=\"%E4%BA%8C%E3%80%81priority_queue%E7%9A%84%E4%BD%BF%E7%94%A8-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BA%8C%E3%80%81priority_queue%E7%9A%84%E4%BD%BF%E7%94%A8\">二、priority_queue的使用</a></p>\n<p id=\"1.priority_queue%E7%9A%84%E6%9E%84%E9%80%A0-toc\" style=\"margin-left:40px;\"><a href=\"#1.priority_queue%E7%9A%84%E6%9E%84%E9%80%A0\">1.priority_queue的构造</a></p>\n<p id=\"2.push(%20)-toc\" style=\"margin-left:40px;\"><a href=\"#2.push%28%20%29\">2.push( )</a></p>\n<p id=\"%C2%A03.pop(%20)-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A03.pop%28%20%29\">3.pop( )</a></p>\n<p id=\"%C2%A04.size(%20)-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A04.size%28%20%29\">4.size( )</a></p>\n<p id=\"5.empty(%20)%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#5.empty%28%20%29%C2%A0\">5.empty( ) </a></p>\n<p id=\"%C2%A0%E4%B8%89%E3%80%81priority_queue%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-toc\" style=\"margin-left:0px;\"><a href=\"#%C2%A0%E4%B8%89%E3%80%81priority_queue%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0\"> 三、priority_queue模拟实现</a></p>\n<p id=\"1.%E4%BB%BF%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:40px;\"><a href=\"#1.%E4%BB%BF%E5%87%BD%E6%95%B0\">1.仿函数</a></p>\n<p id=\"%EF%BC%881%EF%BC%89%E6%A6%82%E5%BF%B5%C2%A0-toc\" style=\"margin-left:80px;\"><a href=\"#%EF%BC%881%EF%BC%89%E6%A6%82%E5%BF%B5%C2%A0\">（1）概念 </a></p>\n<p id=\"%EF%BC%882%EF%BC%89%E4%BC%98%E7%82%B9-toc\" style=\"margin-left:80px;\"><a href=\"#%EF%BC%882%EF%BC%89%E4%BC%98%E7%82%B9\">（2）优点</a></p>\n<p id=\"%EF%BC%883%EF%BC%89%E7%BC%BA%E7%82%B9-toc\" style=\"margin-left:80px;\"><a href=\"#%EF%BC%883%EF%BC%89%E7%BC%BA%E7%82%B9\">（3）缺点</a></p>\n<p id=\"%EF%BC%884%EF%BC%89%E5%AE%9E%E7%8E%B0-toc\" style=\"margin-left:80px;\"><a href=\"#%EF%BC%884%EF%BC%89%E5%AE%9E%E7%8E%B0\">（4）实现</a></p>\n<p id=\"2.%E5%A0%86%E7%9A%84%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4-toc\" style=\"margin-left:40px;\"><a href=\"#2.%E5%A0%86%E7%9A%84%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4\">2.堆的插入删除</a></p>\n<p id=\"3.%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-toc\" style=\"margin-left:40px;\"><a href=\"#3.%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0\">3.代码实现</a></p>\n<p id=\"%C2%A0%EF%BC%881%EF%BC%89%E4%BB%BF%E5%87%BD%E6%95%B0%3C-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A0%EF%BC%881%EF%BC%89%E4%BB%BF%E5%87%BD%E6%95%B0%3C\"> （1）仿函数&lt;</a></p>\n<p id=\"%EF%BC%882%EF%BC%89%E4%BB%BF%E5%87%BD%E6%95%B0%3E-toc\" style=\"margin-left:80px;\"><a href=\"#%EF%BC%882%EF%BC%89%E4%BB%BF%E5%87%BD%E6%95%B0%3E\">（2）仿函数&gt;</a></p>\n<p id=\"%EF%BC%883%EF%BC%89push()-toc\" style=\"margin-left:80px;\"><a href=\"#%EF%BC%883%EF%BC%89push%28%29\">（3）push()</a></p>\n<p id=\"%EF%BC%884%EF%BC%89pop()-toc\" style=\"margin-left:80px;\"><a href=\"#%EF%BC%884%EF%BC%89pop%28%29\">（4）pop()</a></p>\n<p id=\"%EF%BC%885%EF%BC%89top()-toc\" style=\"margin-left:80px;\"><a href=\"#%EF%BC%885%EF%BC%89top%28%29\">（5）top()</a></p>\n<p id=\"%EF%BC%886%EF%BC%89size()-toc\" style=\"margin-left:80px;\"><a href=\"#%EF%BC%886%EF%BC%89size%28%29\">（6）size()</a></p>\n<p id=\"%EF%BC%887%EF%BC%89empty()-toc\" style=\"margin-left:80px;\"><a href=\"#%EF%BC%887%EF%BC%89empty%28%29\">（7）empty()</a></p>\n<p id=\"4.%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%E6%AE%B5-toc\" style=\"margin-left:40px;\"><a href=\"#4.%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%E6%AE%B5\">4.完整代码段</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<p></p>\n<h1 id=\"%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFpriority_queue\"><span style=\"color:#956fe7;\">一、什么是priority_queue</span></h1>\n<p>（1）priority_queue即优先级队列，是一种容器适配器，最大元素放在第一个。</p>\n<p>（2）底层用堆实现，默认是大堆，因为默认大的优先级高，可随时插入元素，可快速查找最大元素，即优先级队列中第一个元素。</p>\n<p>（3）优先级队列元素从特定容器的“尾部”弹出，其称为优先队列的顶部。</p>\n<p>（4）底层容器可以是任何标准容器类模板，也可以是其他特定设计的容器类。容器应该可以通过随机访问迭代器访问，并支持以下操作：<br/>         empty( )：检测容器是否为空<br/>         size( )：返回容器中有效元素个数<br/>         front( )：返回容器中第一个元素的引用<br/>         push_back( )：在容器尾部插入元素<br/>         pop_back( )：删除容器尾部元素</p>\n<p>（5）标准容器类vector和deque满足这些需求。默认情况下，如果没有为特定的priority_queue类实例化指定容器类，则使用vector，堆的物理结构是数组，所以优先级队列也是一个vector。</p>\n<p>（6） 需要支持随机访问迭代器，以便始终在内部保持堆结构。容器适配器通过在需要时自动调用算法函数make_heap、push_heap和pop_heap来自动完成此操作。</p>\n<h1 id=\"%E4%BA%8C%E3%80%81priority_queue%E7%9A%84%E4%BD%BF%E7%94%A8\"><span style=\"color:#956fe7;\">二、priority_queue的使用</span></h1>\n<p>优先级队列默认使用vector作为其底层存储数据的容器，在vector上又使用了堆算法将vector中元素构造成堆的结构，因此priority_queue就是堆，所有需要用到堆的位置，都可以考虑使用priority_queue。</p>\n<h2 id=\"1.priority_queue%E7%9A%84%E6%9E%84%E9%80%A0\"><span style=\"color:#956fe7;\">1.priority_queue的构造</span></h2>\n<p>priority_queue有两种构造方式：</p>\n<p>（1）构造一个空的优先级队列</p>\n<pre><code class=\"language-cpp\">explicit priority_queue (const Compare&amp; comp = Compare(),\n                         const Container&amp; ctnr = Container());//构造一个控的优先级队列</code></pre>\n<p>构造一个空的优先级队列pq1： </p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;queue&gt;//队列\n#include&lt;vector&gt;//数组\n#include&lt;functional&gt;//比较符号，less 或 greater\n\nusing namespace std;\n\nint main()\n{\n\tpriority_queue&lt;int&gt; pq1;//构造一个空的优先级队列\n    \n    pq1.push(3);//向优先级队列中插入元素\n\tpq1.push(1);\n\tpq1.push(6);\n\tpq1.push(12);\n\tpq1.push(7);\n\n    while (!pq1.empty())\n\t{\n\t\tcout &lt;&lt; pq1.top() &lt;&lt; endl;\n\t\tpq1.pop();\n\t}\n}</code></pre>\n<p><img alt=\"\" height=\"380\" src=\"image\\7d145cfc42334500b66673029d46cadc.png\" width=\"1200\"/></p>\n<p>（2）用迭代器区间构造一个优先级队列</p>\n<pre><code class=\"language-cpp\">template &lt;class InputIterator&gt;\n         priority_queue (InputIterator first, InputIterator last,\n                         const Compare&amp; comp = Compare(),\n                         const Container&amp; ctnr = Container());//用first和last之间的元素构造优先级队列</code></pre>\n<p>使用数组的迭代器区间构造一个优先级队列：</p>\n<pre><code class=\"language-cpp\">    vector&lt;int&gt; v;\n\tv.push_back(1);\n\tv.push_back(2);\n\tv.push_back(3);\n\tv.push_back(4);\n\n\tpriority_queue&lt;int&gt; pq2(v.begin(), v.end()) ;//用v的迭代器区间构造pq2</code></pre>\n<p>以上都构造的是大堆，如何构造一个小堆呢？</p>\n<p>可以使用如下模板构造：T是元素类型，Container 指定容器，Compare是元素比较方式，大于还是小于，默认为大于less，即大堆，如果想改成小堆，就用greater。</p>\n<pre><code class=\"language-cpp\">template &lt;class T, class Container = vector&lt;T&gt;,\n  class Compare = less&lt;typename Container::value_type&gt; &gt; class priority_queue;</code></pre>\n<p> value_type被typedef为T，编译器编译的时候是没有vecto的，因为vector没有被实例化，所以编译器编译的时候不知道Container是vector，不知道value_type类型。</p>\n<p>构造一个小堆： </p>\n<pre><code class=\"language-cpp\">    priority_queue&lt;int,vector&lt;int&gt;,greater&lt;vector&lt;int&gt;::value_type&gt;&gt; pq4;\n\tpq4.push(20);\n\tpq4.push(2);\n\tpq4.push(8);\n\tpq4.push(5);\n\n\twhile (!pq4.empty())\n\t{\n\t\tcout &lt;&lt; pq4.top() &lt;&lt; endl;\n\t\tpq4.pop();\n\t}</code></pre>\n<p><img alt=\"\" height=\"352\" src=\"image\\407d7252dcef407a811bfc30730a5e07.png\" width=\"1200\"/>  </p>\n<h2 id=\"2.push(%20)\"><span style=\"color:#956fe7;\">2.push( )</span></h2>\n<p>向优先级队列中插入元素 </p>\n<pre><code class=\"language-cpp\">void push (const value_type&amp; val);//向优先级队列中插入元素</code></pre>\n<p> 向pq3中插入元素：</p>\n<pre><code class=\"language-cpp\">    priority_queue&lt;int&gt; pq3;\n\tpq3.push(6);//向优先级队列中插入元素\n\tpq3.push(3);\n\tpq3.push(9);\n\tpq3.push(8);</code></pre>\n<h2 id=\"%C2%A03.pop(%20)\"><span style=\"color:#956fe7;\">3.pop( )</span></h2>\n<p>删除优先级队列第一个元素 </p>\n<pre><code class=\"language-cpp\">void pop();//删除优先级队列第一个元素</code></pre>\n<p> 删除pq3的第一个元素：</p>\n<pre><code class=\"language-cpp\">    pq3.pop();//删除优先级队列第一个元素</code></pre>\n<h2 id=\"%C2%A04.size(%20)\"><span style=\"color:#956fe7;\">4.size( )</span></h2>\n<p> 返回优先级队列的元素个数</p>\n<pre><code class=\"language-cpp\">size_type size() const;//返回优先级队列的元素个数</code></pre>\n<p> 返回pq3的元素个数</p>\n<pre><code class=\"language-cpp\">    cout &lt;&lt; pq3.size() &lt;&lt; endl;//返回pq3的元素个数</code></pre>\n<p><img alt=\"\" height=\"250\" src=\"image\\38dee69c169b4105b2bbcc786b412c10.png\" width=\"1200\"/></p>\n<h2 id=\"5.empty(%20)%C2%A0\"><span style=\"color:#956fe7;\">5.empty( ) </span></h2>\n<p>判断优先级队列是否为空</p>\n<pre><code class=\"language-cpp\">bool empty() const;//判断优先级队列是否为空</code></pre>\n<p> 判断pq3是否为空</p>\n<pre><code class=\"language-cpp\">    cout &lt;&lt; pq3.empty() &lt;&lt; endl;</code></pre>\n<p><img alt=\"\" height=\"254\" src=\"image\\95a0174c734945daa4e0a6de6fcba3ba.png\" width=\"1200\"/></p>\n<h1 id=\"%C2%A0%E4%B8%89%E3%80%81priority_queue%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0\"> <span style=\"color:#956fe7;\">三、priority_queue模拟实现</span></h1>\n<p>priority_queue底层用堆实现，priority_queue的模拟实现只需要对堆进行封装即可。</p>\n<h2 id=\"1.%E4%BB%BF%E5%87%BD%E6%95%B0\"><span style=\"color:#956fe7;\">1.仿函数</span></h2>\n<p>priority_queue默认是大堆，那么该如何实现小堆呢？需要先了解仿函数。</p>\n<h3 id=\"%EF%BC%881%EF%BC%89%E6%A6%82%E5%BF%B5%C2%A0\"><span style=\"color:#956fe7;\">（1）概念 </span></h3>\n<p>仿函数让一个类的使用看上去像个函数。仿函数是在类中实现了一个<a href=\"https://baike.baidu.com/item/operator/2387244\" title=\"operator\">operator</a>operator<a href=\"https://baike.baidu.com/item/operator/2387244\" title=\"operator\">operator</a>()，是一个类的对象，这个类就有了类似函数的行为，所以这个类就是一个仿函数类，目的是为了让函数拥有类的性质。</p>\n<p>这个类的对象即仿函数，可以当作一般函数去用，只不过仿函数的功能是在一个类中的运算符operator()中实现的，使用的时候把函数作为参进行传递即可。</p>\n<h3 id=\"%EF%BC%882%EF%BC%89%E4%BC%98%E7%82%B9\"><span style=\"color:#956fe7;\">（2）优点</span></h3>\n<p> ① 仿函数比函数指针的执行速度快，函数指针通过地址调用，而仿函数是对运算符operator进行自定义来提高调用的效率。<br/>  ② 仿函数比一般函数灵活，可以同时拥有两个不同的状态实体，一般函数不具备此种功能。<br/>  ③ 仿函数可以作为模板参数使用，因为每个仿函数都拥有自己的类型。</p>\n<h3 id=\"%EF%BC%883%EF%BC%89%E7%BC%BA%E7%82%B9\"><span style=\"color:#956fe7;\">（3）缺点</span></h3>\n<p> ① 需要单独实现一个类。<br/>  ② 定义形式比较复杂。</p>\n<h3 id=\"%EF%BC%884%EF%BC%89%E5%AE%9E%E7%8E%B0\"><span style=\"color:#956fe7;\">（4）实现</span></h3>\n<p> 先看如下函数isLess，它实现了&lt;的比较</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n\nbool isLess(int l, int r)\n{\n\treturn l &lt; r;\n}\n\nint main()\n{\n\tcout &lt;&lt; isLess(1, 3) &lt;&lt; endl;\n}</code></pre>\n<p>如果在一个类里，实现同样功能，Less这个类就变成了仿函数类，它的对象就是一个仿函数</p>\n<pre><code class=\"language-cpp\">struct less\n{\n\tbool operator()(int l, int r)\n\t{\n\t\treturn l &lt; r;\n\t}\n};</code></pre>\n<p> 这个类还可以再完善一下，使用类模板来支持不同类型的数据使用&lt;比较大小</p>\n<pre><code class=\"language-cpp\">template &lt;class T&gt;\nstruct less\n{\n\tbool operator()(const T&amp; l, const T&amp; r)\n\t{\n\t\treturn l &lt; r;//&lt;的比较\n\t}\n};</code></pre>\n<p>同样，&gt;的仿函数类也可以实现了：</p>\n<pre><code class=\"language-cpp\">template &lt;class T&gt;\nstruct greater\n{\n\tbool operator()(const T&amp; l, const T&amp; r)\n\t{\n\t\treturn l &gt; r;//&gt;的比较\n\t}\n};</code></pre>\n<p>如何使用仿函数呢？</p>\n<pre><code class=\"language-cpp\">int main()\n{\n\tless&lt;int&gt; lessInt;//定义一个仿函数类对象，参数类型指定为int\n\tstd::cout &lt;&lt; lessInt(1, 3) &lt;&lt; std::endl;//对仿函数的调用等价于std::cout &lt;&lt; lessInt.operator()(1, 3) &lt;&lt; std::endl;\n}</code></pre>\n<p>priority_queue模板中的less替换成greater就可以实现&gt;的比较了：</p>\n<pre><code class=\"language-cpp\">template &lt;class T, class Container = vector&lt;T&gt;,\n  class Compare = greater&lt;typename Container::value_type&gt; &gt; class priority_queue;</code></pre>\n<p></p>\n<h2 id=\"2.%E5%A0%86%E7%9A%84%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4\"><span style=\"color:#956fe7;\">2.堆的插入删除</span></h2>\n<p>要对priority_queue插入删除，就是在堆上插入删除，堆在物理上是数组，在逻辑上是一颗完全二叉树。根据<a href=\"https://blog.csdn.net/gx714433461/article/details/122889673?spm=1001.2014.3001.5501\" title=\"【数据结构】堆-C语言版\">【数据结构】堆-C语言版</a>一文回忆一下堆的插入删除相关知识</p>\n<p>（1）堆的插入（先插入，再向上调整）</p>\n<p><img alt=\"\" height=\"957\" src=\"image\\b19f8dc87699490eae8bbd370965b433.png\" width=\"1200\"/></p>\n<p></p>\n<p> （2）堆的删除（先交换，然后删除，再向下调整）</p>\n<p><img alt=\"\" height=\"1097\" src=\"image\\c64b1a7543d443af8166dce7ca9cf7e9.png\" width=\"1200\"/></p>\n<h2 id=\"3.%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0\"><span style=\"color:#956fe7;\">3.代码实现</span></h2>\n<p>priority_queue类默认的Container是vector，是自定义类型。因此priority_queue的构造函数、拷贝构造函数、赋值运算符重载函数、析构函数都不用写，会调vector的默认构造函数、拷贝构造函数、赋值运算符重载函数、析构函数。只需要实现7个函数：仿函数&lt;、仿函数&gt;、push、pop、top、size、empty。</p>\n<h3 id=\"%C2%A0%EF%BC%881%EF%BC%89%E4%BB%BF%E5%87%BD%E6%95%B0%3C\"><span style=\"color:#956fe7;\"> （1）仿函数&lt;</span></h3>\n<pre><code class=\"language-cpp\">template&lt;class T&gt;\nstruct less\n{\n\tbool operator()(const T&amp; l, const T&amp; r)\n\t{\n\t\treturn l &lt; r;\n\t}\n};</code></pre>\n<h3 id=\"%EF%BC%882%EF%BC%89%E4%BB%BF%E5%87%BD%E6%95%B0%3E\"><span style=\"color:#956fe7;\">（2）仿函数&gt;</span></h3>\n<pre><code class=\"language-cpp\">\ttemplate&lt;class T&gt;\n\tstruct greater\n\t{\n\t\tbool operator()(const T&amp; l, const T&amp; r)\n\t\t{\n\t\t\treturn l &gt; r;\n\t\t}\n\t};</code></pre>\n<h3 id=\"%EF%BC%883%EF%BC%89push()\"><span style=\"color:#956fe7;\">（3）push()</span></h3>\n<pre><code class=\"language-cpp\">\ttemplate&lt;class T, class Container = vector&lt;T&gt;,class Compare = delia::less&lt;T&gt;&gt;//指定Compare方式是less，按&lt;比较\n\tclass priority_queue\n\t{\n\tpublic:\t\t\n\t\t//向上调整算法\n\t\tvoid AdjustUp(size_t child)\n\t\t{\n\t\t\tCompare com;//定义仿函数类对象\n\n\t\t\tsize_t parent = (child - 1) / 2;//找父亲的位置\n\t\t\twhile (child &gt; 0)\n\t\t\t{\n\t\t\t\t//if (_con[parent] &lt; _con[child])//父亲比孩子小，孩子就要往上提\n\t\t\t\tif (com(_con[parent] , _con[child]))//使用仿函数比较\n\t\t\t\t{\n\t\t\t\t\tswap(_con[parent], _con[child]);//交换父亲和孩子\n\t\t\t\t\tchild = parent;//父亲变孩子\n\t\t\t\t\tparent = (child - 1) / 2;//重新计算新孩子的父亲位置\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t//父亲&gt;=孩子就不用动\n\t\t\t\t\tbreak;\n\t\t\t\t}\t\n\t\t\t}\n\t\t}\n\n\t\t//插入\n\t\tvoid push(const T&amp; x)\n\t\t{\n\t\t\t_con.push_back(x);//尾插到堆\n\t\t\tAdjustUp(_con.size() - 1);//向上调整\n\t\t}\n    \n    private:\n\t\tContainer _con;\n\t};</code></pre>\n<h3 id=\"%EF%BC%884%EF%BC%89pop()\"><span style=\"color:#956fe7;\">（4）pop()</span></h3>\n<pre><code class=\"language-cpp\">\t\t//向下调整算法\n\t\tvoid AdjustDown(size_t parent)\n\t\t{\n\t\t\tCompare com;//定义仿函数类对象\n\n\t\t\tsize_t child = 2 * parent + 1;//找孩子位置\n\t\t\twhile (child &lt; _con.size())\n\t\t\t{\n\t\t\t\t//找大孩子\n\t\t\t\tif (child + 1 &lt; _con.size() &amp;&amp; _con[child+1] &gt; _con[child])\n\t\t\t\t{\n\t\t\t\t\tchild++;\n\t\t\t\t}\n\n\t\t\t\t//if(_con[parent] &lt; _con[child])父亲比孩子小，父亲就要往下挪\n\t\t\t\tif (com(_con[parent], _con[child]))//使用仿函数比较\n\t\t\t\t{\n\t\t\t\t\tswap(_con[parent], _con[child]);//交换父亲和孩子\n\t\t\t\t\tparent = child;//孩子变父亲\n\t\t\t\t\tchild = parent * 2 + 1;//重新计算孩子的位置\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n        //删除\n\t\tvoid pop()\n\t\t{\n\t\t\tswap(_con[0], _con[_con.size() - 1]);//交换堆顶元素和堆尾元素\n\t\t\t_con.pop_back();//删除堆顶元素\t\t\t\n\t\t\tAdjustDown(0);//向下调整算法\n\t\t}</code></pre>\n<h3 id=\"%EF%BC%885%EF%BC%89top()\"><span style=\"color:#956fe7;\">（5）top()</span></h3>\n<pre><code class=\"language-cpp\">\t\t//返回priority_queue第一个元素，即堆顶元素\n\t\tT top()\n\t\t{\n\t\t\treturn _con[0];\n\t\t}</code></pre>\n<h3 id=\"%EF%BC%886%EF%BC%89size()\"><span style=\"color:#956fe7;\">（6）size()</span></h3>\n<pre><code class=\"language-cpp\">\t\t//求priority_queue队列中元素个数\n\t\tsize_t size()\n\t\t{\n\t\t\treturn _con.size();\n\t\t}</code></pre>\n<h3 id=\"%EF%BC%887%EF%BC%89empty()\"><span style=\"color:#956fe7;\">（7）empty()</span></h3>\n<pre><code class=\"language-cpp\">\t\t//判断priority_queue是否为空\n\t\tbool empty()\n\t\t{\n\t\t\treturn _con.empty();\n\t\t}</code></pre>\n<p></p>\n<h2 id=\"4.%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%E6%AE%B5\"><span style=\"color:#956fe7;\">4.完整代码段</span><br/>  </h2>\n<p>018-priority_queue.h</p>\n<pre><code class=\"language-cpp\">#pragma once\n#include&lt;vector&gt;\nusing namespace std;\n\nnamespace delia\n{\n\ttemplate&lt;class T&gt;\n\tstruct less\n\t{\n\t\tbool operator()(const T&amp; l, const T&amp; r)\n\t\t{\n\t\t\treturn l &lt; r;\n\t\t}\n\t};\n\n\ttemplate&lt;class T&gt;\n\tstruct greater\n\t{\n\t\tbool operator()(const T&amp; l, const T&amp; r)\n\t\t{\n\t\t\treturn l &gt; r;\n\t\t}\n\t};\n\n\ttemplate&lt;class T, class Container = vector&lt;T&gt;,class Compare = std::less&lt;T&gt;&gt;\n\tclass priority_queue\n\t{\n\tpublic:\n\t\t//Container默认是vector，自定义类型\n\t\t//构造函数、拷贝构造函数、赋值运算符重载函数、析构函数都不用写，会调用vector的构造函数和析构函数等\n\t\t\n\t\t\n\n\t\t//向上调整算法\n\t\tvoid AdjustUp(size_t child)\n\t\t{\n\t\t\tCompare com;//定义仿函数类对象\n\n\t\t\tsize_t parent = (child - 1) / 2;//找父亲的位置\n\t\t\twhile (child &gt; 0)\n\t\t\t{\n\t\t\t\t//if (_con[parent] &lt; _con[child])//父亲比孩子小，孩子就要往上提\n\t\t\t\tif (com(_con[parent] , _con[child]))//使用仿函数比较\n\t\t\t\t{\n\t\t\t\t\tswap(_con[parent], _con[child]);//交换父亲和孩子\n\t\t\t\t\tchild = parent;//父亲变孩子\n\t\t\t\t\tparent = (child - 1) / 2;//重新计算新孩子的父亲位置\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t//父亲&gt;=孩子就不用动\n\t\t\t\t\tbreak;\n\t\t\t\t}\t\n\t\t\t}\n\t\t}\n\n\t\t//插入\n\t\tvoid push(const T&amp; x)\n\t\t{\n\t\t\t_con.push_back(x);//尾插到堆\n\t\t\tAdjustUp(_con.size() - 1);//向上调整\n\t\t}\n\n\t\t//向下调整算法\n\t\tvoid AdjustDown(size_t parent)\n\t\t{\n\t\t\tCompare com;//定义仿函数类对象\n\n\t\t\tsize_t child = 2 * parent + 1;//找孩子位置\n\t\t\twhile (child &lt; _con.size())\n\t\t\t{\n\t\t\t\t//找大孩子\n\t\t\t\tif (child + 1 &lt; _con.size() &amp;&amp; _con[child+1] &gt; _con[child])\n\t\t\t\t{\n\t\t\t\t\tchild++;\n\t\t\t\t}\n\n\t\t\t\t//if(_con[parent] &lt; _con[child])父亲比孩子小，父亲就要往下挪\n\t\t\t\tif (com(_con[parent], _con[child]))//使用仿函数比较\n\t\t\t\t{\n\t\t\t\t\tswap(_con[parent], _con[child]);//交换父亲和孩子\n\t\t\t\t\tparent = child;//孩子变父亲\n\t\t\t\t\tchild = parent * 2 + 1;//重新计算孩子的位置\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//删除\n\t\tvoid pop()\n\t\t{\n\t\t\tswap(_con[0], _con[_con.size() - 1]);//交换堆顶元素和堆尾元素\n\t\t\t_con.pop_back();//删除堆顶元素\t\t\t\n\t\t\tAdjustDown(0);//向下调整算法\n\t\t}\n\n\t\t//返回priority_queue第一个元素，即堆顶元素\n\t\tT top()\n\t\t{\n\t\t\treturn _con[0];\n\t\t}\n\n\t\t//求priority_queue队列中元素个数\n\t\tsize_t size()\n\t\t{\n\t\t\treturn _con.size();\n\t\t}\n\n\t\t//判断priority_queue是否为空\n\t\tbool empty()\n\t\t{\n\t\t\treturn _con.empty();\n\t\t}\n\n\tprivate:\n\t\tContainer _con;\n\t};\n\n}</code></pre>\n<p>018-test.cpp</p>\n<pre><code class=\"language-cpp\">#include \"018-priority_queue.h\"\n#include&lt;iostream&gt;\n\nvoid test_priority_queue()\n{\n\tdelia::priority_queue&lt;int&gt; pq;\n\tpq.push(9);\n\tpq.push(26);\n\tpq.push(31);\n\tpq.push(3);\n\tpq.push(11);\n\tpq.push(1);\n\tpq.push(5);\n\tpq.push(39);\n\tpq.push(23);\n\tpq.push(18);\n\n\tstd::cout &lt;&lt; \"priority_queue:\" &lt;&lt; std::endl;\n\twhile (!pq.empty())\n\t{\n\t\tstd::cout &lt;&lt; pq.top() &lt;&lt; std::endl;\n\t\tpq.pop();\n\t}\n\tstd::cout &lt;&lt; std::endl;\n}\n\nvoid test_priority_queue_push()\n{\n\tdelia::priority_queue&lt;int&gt; pq;\n\tpq.push(9);\n\tpq.push(26);\n\tpq.push(31);\n\tpq.push(3);\n\tpq.push(11);\n\tpq.push(1);\n\tpq.push(5);\n\tpq.push(39);\n\tpq.push(23);\n\tpq.push(18);\n\n\tpq.push(83);\n\n\tstd::cout &lt;&lt; \"push:\" &lt;&lt; std::endl;\n\twhile (!pq.empty())\n\t{\n\t\tstd::cout &lt;&lt; pq.top() &lt;&lt; std::endl;\n\t\tpq.pop();\n\t}\n\tstd::cout &lt;&lt; std::endl;\n}\n\nvoid test_priority_queue_pop()\n{\n\tdelia::priority_queue&lt;int&gt; pq;\n\tpq.push(9);\n\tpq.push(26);\n\tpq.push(31);\n\tpq.push(3);\n\tpq.push(11);\n\tpq.push(1);\n\tpq.push(5);\n\tpq.push(39);\n\tpq.push(23);\n\tpq.push(18);\n\n\tstd::cout &lt;&lt; \"pop:\" &lt;&lt; std::endl;\n\tpq.pop();\n\twhile (!pq.empty())\n\t{\n\t\tstd::cout &lt;&lt; pq.top() &lt;&lt; std::endl;\n\t\tpq.pop();\n\t}\n\tstd::cout &lt;&lt; std::endl;\n}\n\nvoid test_priority_queue_top()\n{\n\tdelia::priority_queue&lt;int&gt; pq;\n\tpq.push(9);\n\tpq.push(26);\n\tpq.push(31);\n\tpq.push(3);\n\tpq.push(11);\n\tpq.push(1);\n\tpq.push(5);\n\tpq.push(39);\n\tpq.push(23);\n\tpq.push(18);\n\n\tstd::cout &lt;&lt; \"top:\" &lt;&lt; std::endl;\n\tstd::cout &lt;&lt; pq.top() &lt;&lt; std::endl;\n\tstd::cout &lt;&lt; std::endl;\n}\n\nvoid test_priority_queue_size()\n{\n\tdelia::priority_queue&lt;int&gt; pq;\n\tpq.push(9);\n\tpq.push(26);\n\tpq.push(31);\n\tpq.push(3);\n\tpq.push(11);\n\tpq.push(1);\n\tpq.push(5);\n\tpq.push(39);\n\tpq.push(23);\n\tpq.push(18);\n\n\tstd::cout &lt;&lt; \"size:\" &lt;&lt; std::endl;\n\tstd::cout &lt;&lt; pq.size() &lt;&lt; std::endl;\n\tstd::cout &lt;&lt; std::endl;\n}\n\nvoid test_priority_queue_empty()\n{\n\tdelia::priority_queue&lt;int&gt; pq;\n\tpq.push(9);\n\tpq.push(26);\n\tpq.push(31);\n\tpq.push(3);\n\tpq.push(11);\n\tpq.push(1);\n\tpq.push(5);\n\tpq.push(39);\n\tpq.push(23);\n\tpq.push(18);\n\n\tstd::cout &lt;&lt; \"empty:\" &lt;&lt; std::endl;\n\tstd::cout &lt;&lt; pq.empty() &lt;&lt; std::endl;\n\tstd::cout &lt;&lt; std::endl;\n}\n\nint main()\n{\n\ttest_priority_queue();\n\ttest_priority_queue_push();\n\ttest_priority_queue_pop();\n\ttest_priority_queue_top();\n\ttest_priority_queue_size();\n\ttest_priority_queue_empty();\n\n\treturn 0;\n\n}</code></pre>\n<p>运行结果如下 </p>\n<p><img alt=\"\" height=\"373\" src=\"image\\f2aaa188aed541aeb89138c596f7d3de.png\" width=\"231\"/></p>\n<p><img alt=\"\" height=\"271\" src=\"image\\81c7520372f248bf84306a22969470d7.png\" width=\"224\"/></p>\n<p></p>\n</div>\n</div>"}