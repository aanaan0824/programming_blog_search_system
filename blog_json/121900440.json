{"blogid": "121900440", "writerAge": "码龄4年", "writerBlogNum": "52", "writerCollect": "325", "writerComment": "70", "writerFan": "171", "writerGrade": "5级", "writerIntegral": "2077", "writerName": "Magicdata大数据", "writerProfileAdress": "writer_image\\profile_121900440.jpg", "writerRankTotal": "32343", "writerRankWeekly": "213603", "writerThumb": "72", "writerVisitNum": "236074", "blog_read_count": "2544", "blog_time": "于 2021-12-13 11:02:09 发布", "blog_title": "C# 关于浏览器——WebBrowser篇", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>最近要写一个浏览器包裹一个网站，试了各种浏览器插件，记录一下。</p>\n<p>第一个就是微软的WebBrowser，这个很容易，直接拖过来，然后写一下注册表调用IE11的内核显示，这个代码是抄的：</p>\n<pre><code>/// &lt;summary&gt;\n        /// 修改注册表信息来兼容当前程序\n        ///\n        /// &lt;/summary&gt;  \n        static void SetWebBrowserFeatures(int ieVersion)\n        {\n            // don't change the registry if running in-proc inside Visual Studio  \n            if (LicenseManager.UsageMode != LicenseUsageMode.Runtime)\n                return;\n\n            //获取程序及名称  \n            var appName = System.IO.Path.GetFileName(System.Diagnostics.Process.GetCurrentProcess().MainModule.FileName);            \n\n            //得到浏览器的模式的值  \n            UInt32 ieMode = GeoEmulationModee(ieVersion);\n\n            var featureControlRegKey = @\"HKEY_CURRENT_USER\\Software\\Microsoft\\Internet Explorer\\Main\\FeatureControl\\\";\n\n            //设置浏览器对应用程序（appName）以什么模式（ieMode）运行\n            Registry.SetValue(featureControlRegKey + \"FEATURE_BROWSER_EMULATION\",\n                appName, ieMode, RegistryValueKind.DWord);\n\n            //为完整的Internet Explorer浏览器启用“打开”的功能         \n            Registry.SetValue(featureControlRegKey + \"FEATURE_ENABLE_CLIPCHILDREN_OPTIMIZATION\",\n                appName, 1, RegistryValueKind.DWord);\n\n\n            Registry.SetValue(featureControlRegKey + \"FEATURE_AJAX_CONNECTIONEVENTS\",\n                appName, 1, RegistryValueKind.DWord);\n\n\n            Registry.SetValue(featureControlRegKey + \"FEATURE_GPU_RENDERING\",\n                appName, 1, RegistryValueKind.DWord);\n\n\n            Registry.SetValue(featureControlRegKey + \"FEATURE_WEBOC_DOCUMENT_ZOOM\",\n                appName, 1, RegistryValueKind.DWord);\n\n\n            Registry.SetValue(featureControlRegKey + \"FEATURE_NINPUT_LEGACYMODE\",\n                appName, 0, RegistryValueKind.DWord);\n        }\n\n        /// &lt;summary&gt;  \n        /// 获取浏览器的版本  \n        /// &lt;/summary&gt;  \n        /// &lt;returns&gt;&lt;/returns&gt;  \n        static int GetBrowserVersion()\n        {\n            int browserVersion = 0;\n            using (var ieKey = Registry.LocalMachine.OpenSubKey(@\"SOFTWARE\\Microsoft\\Internet Explorer\",\n                RegistryKeyPermissionCheck.ReadSubTree,\n                System.Security.AccessControl.RegistryRights.QueryValues))\n            {\n                var version = ieKey.GetValue(\"svcVersion\");\n                if (null == version)\n                {\n                    version = ieKey.GetValue(\"Version\");\n                    if (null == version)\n                        throw new ApplicationException(\"Microsoft Internet Explorer is required!\");\n                }\n                int.TryParse(version.ToString().Split('.')[0], out browserVersion);\n            }\n\n            //如果小于7  \n            if (browserVersion &lt; 7)\n            {\n                throw new ApplicationException(\"不支持的浏览器版本!\");\n            }\n            return browserVersion;\n        }\n\n        /// &lt;summary&gt;  \n        /// 通过版本得到浏览器模式的值\n        /// &lt;/summary&gt;  \n        /// &lt;param name=\"browserVersion\"&gt;&lt;/param&gt;  \n        /// &lt;returns&gt;&lt;/returns&gt;  \n        static UInt32 GeoEmulationModee(int browserVersion)\n        {\n            UInt32 mode = 11000; // Internet Explorer 11. Webpages containing standards-based !DOCTYPE directives are displayed in IE11 Standards mode.   \n            switch (browserVersion)\n            {\n                case 7:\n                    mode = 7000; // Webpages containing standards-based !DOCTYPE directives are displayed in IE7 Standards mode.   \n                    break;\n                case 8:\n                    mode = 8000; // Webpages containing standards-based !DOCTYPE directives are displayed in IE8 mode.   \n                    break;\n                case 9:\n                    mode = 9000; // Internet Explorer 9. Webpages containing standards-based !DOCTYPE directives are displayed in IE9 mode.                      \n                    break;\n                case 10:\n                    mode = 10000; // Internet Explorer 10.  \n                    break;\n                case 11:\n                    mode = 11000; // Internet Explorer 11  \n                    break;\n            }\n            return mode;\n        }</code></pre>\n<p>然后在Form的Load里面写：</p>\n<p>SetWebBrowserFeatures(11);//内核为11</p>\n<p>就OK了，然后就是处理新窗口的问题了，这个有两种情况，一个是网页内容的新窗口，主要是target的处理，添加事件处理函数：</p>\n<pre><code>/防止在新窗口打开链接\n        private void browser_NewWindow(object sender, CancelEventArgs e)\n        {\n            e.Cancel = true;\n        }\n\n        //替换掉网页中链接的新窗口属性\n        private void browser_DocumentCompleted(object sender, WebBrowserDocumentCompletedEventArgs e)\n        {\n            //this.Text = this.browser.Document.Title;\n            foreach (HtmlElement links in this.browser.Document.Links)\n            {\n                links.SetAttribute(\"target\", \"_self\");\n            }\n\n            foreach (HtmlElement form in this.browser.Document.Forms)\n            {\n                form.SetAttribute(\"target\", \"_self\");\n            }\n        }</code></pre>\n<p>还有一种是js的window.open，这个这样处理：在Form_Load里面写</p>\n<pre><code> string jsHtml= \"window.open=function(url, title, prop){window.external.jumpUrl(url);}\";\nmshtml.IHTMLDocument2 doc = browser.Document.DomDocument as mshtml.IHTMLDocument2;\n                mshtml.IHTMLWindow2 win = doc.parentWindow as mshtml.IHTMLWindow2;\n                win.execScript(jsHtml, \"javascript\");\n</code></pre>\n<p>需要引用Microsoft.mshtml，其中jumpUrl是程序自身的一个函数，处理传递过来的 Url，通常是直接load一下：</p>\n<pre><code>public void jumpUrl(string url)\n        {            \n            browser.Navigate(url);\n        }</code></pre>\n<p>要从js里面调用函数，需要引用：</p>\n<p>using System.Runtime.InteropServices;</p>\n<p>然后在类前面写：</p>\n<p>[System.Runtime.InteropServices.ComVisible(true)]<br/>     public partial class mainForm : Form<br/>     {<!-- --></p>\n<p>.......</p>\n<p>然后就是各种加载导航操作什么的，这个没什么好说的。</p>\n<p>一些坑：</p>\n<p>1、这个对js的支持非常弱，尤其是用了jquery的操作，不确定性太多；</p>\n<p>2、虽然用了IE内核，但并不是全部支持IE的功能，感觉也就是60~70的样子；</p>\n<p>3、对客户机的环境依赖太多，需要装IE的高版本，FrameWorks、VS支持什么的。</p>\n<p>总之，不推荐包装复杂的站点，否则就是噩梦。</p>\n</div>\n</div>"}