{"blogid": "125357661", "writerAge": "码龄14年", "writerBlogNum": "133", "writerCollect": "104", "writerComment": "67", "writerFan": "121", "writerGrade": "5级", "writerIntegral": "2580", "writerName": "jason成都", "writerProfileAdress": "writer_image\\profile_125357661.jpg", "writerRankTotal": "17666", "writerRankWeekly": "46526", "writerThumb": "38", "writerVisitNum": "142148", "blog_read_count": "1456", "blog_time": "于 2022-06-19 15:57:00 发布", "blog_title": "c++的json库", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>现在c++的库其实实现都差不多，因为没有c++没有反射功能，所以只能按照键值对方式组合和解析。每个库原理差不多，主要是接口的实现。</p>\n<p>目前有很多库了，只介绍4个。</p>\n<p>json11,rapidjson,jsoncpp,nlohmann</p>\n<p>大家自己查阅官方文档吧，总体都是类似map这样的。</p>\n<p>用jsoncpp举例，主要就是value类型</p>\n<pre><code class=\"language-cpp\">int ParseJsonFromString()\n{\n    const char* str = \"{\\\"uploadid\\\": \\\"UP000000\\\",\\\"code\\\": 100,\\\"msg\\\": \\\"\\\",\\\"files\\\": \\\"\\\"}\";\n    Json::Reader reader;\n    Json::Value root;\n    if (reader.parse(str, root))  // reader将Json字符串解析到root，root将包含Json里所有子元素   \n    {\n        std::string upload_id = root[\"uploadid\"].asString();  // 访问节点，upload_id = \"UP000000\"   \n        int code = root[\"code\"].asInt();    // 访问节点，code = 100   \n    }\n    return 0;\n}</code></pre>\n<p>很多库的使用都是这样的。</p>\n<p>nlohmann库需要实现解析过程。</p>\n<p>以下是json字符串解析：</p>\n<pre><code class=\"language-cpp\">int  ParseJson()\n{\n    // create object from string literal\n    json j = \"{ \\\"happy\\\": true, \\\"pi\\\": 3.141 }\"_json;\n    // or even nicer with a raw string literal\n    auto j2 = R\"(\n  {\n    \"happy\": true,\n    \"pi\": 3.141\n  }\n)\"_json;\n\n    std::string s = j.dump();\n    return 0;\n}\n</code></pre>\n<p>如果需要将json字符串与结构体转换</p>\n<pre><code class=\"language-cpp\">struct MyContainer {\n    std::string name;\n    std::string address;\n    int age;\n    list&lt;string&gt; lst;\n    double score;\n\n};\n</code></pre>\n<pre><code class=\"language-cpp\">//1.重载转换函数\nvoid to_json(nlohmann::json&amp; j, const MyContainer&amp; p) {\n    j = json{ {\"name\", p.name}, {\"address\", p.address}, {\"score\", p.score},{\"age\",p.age},{\"lst\",p.lst} };\n}\n\nvoid from_json(const nlohmann::json&amp; j, MyContainer&amp; p) {\n    j.at(\"name\").get_to(p.name);\n    j.at(\"address\").get_to(p.address);\n    j.at(\"score\").get_to(p.score);\n    j.at(\"age\").get_to(p.age);\n    j.at(\"lst\").get_to(p.lst);\n}</code></pre>\n<p>需要在同名称空间实现上面的方法，c++没有反射，需要自己实现映射关系。以上接口方法就是需要结构体与json类型建立映射关系。</p>\n<pre><code class=\"language-cpp\">int defParseJson()\n{\n    MyContainer c;\n    c.age = 3;\n    c.name = \"jnoy\";\n    c.score = 6;\n    c.lst.push_back(\"aa\");\n    c.lst.push_back(\"cc\");\n\n    json j = c;//将结构体转换成json对象\n    std::string str= j.dump();//转换字符串\n    std::cout &lt;&lt; str &lt;&lt; std::endl;\n\n    //必须在同名称空间，实现to_json，from_json\n   auto p= j.get&lt;MyContainer&gt;();//转换结构体\n   // json k = c;\n    return 0;\n}</code></pre>\n<p>准备好以后的序列化和反序列化。</p>\n</div>\n</div>"}