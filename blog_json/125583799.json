{"blogid": "125583799", "writerAge": "码龄1年", "writerBlogNum": "24", "writerCollect": "20", "writerComment": "25", "writerFan": "293", "writerGrade": "2级", "writerIntegral": "330", "writerName": "猫的幻想曲", "writerProfileAdress": "writer_image\\profile_125583799.jpg", "writerRankTotal": "45019", "writerRankWeekly": "9761", "writerThumb": "76", "writerVisitNum": "8639", "blog_read_count": "3633", "blog_time": "于 2022-07-03 13:51:30 发布", "blog_title": "微信支付及支付回调", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h1>1.微信支付</h1>\n<p>通过微信平台为商家提供代收款服务</p>\n<h2>1.1微信支付的业务--商户注册微信支付业务：</h2>\n<p><img alt=\"\" height=\"48\" src=\"image\\10cb648ddcbe4fd28d597bdaa11901eb.png\" width=\"649\"/></p>\n<p> <img alt=\"\" height=\"514\" src=\"image\\2f44008aea2d48d9ab84113196e78994.png\" width=\"915\"/></p>\n<p> <img alt=\"\" height=\"185\" src=\"image\\4d591ccac1ef46e995e5d4e0920fb73f.png\" width=\"450\"/></p>\n<h2> 1.2申请支付订单--商户向支付平台申请支付链接</h2>\n<p>支付订单，并不是用户提交的商品订单，而是商品向微信支付平台申请的支付链接</p>\n<h3>1.2.1导入微信支付的依赖</h3>\n<p>wxpay的maven依赖：</p>\n<pre><code class=\"language-java\">&lt;dependency&gt;\n    &lt;groupId&gt;com.github.wxpay&lt;/groupId&gt;\n    &lt;artifactId&gt;wxpay-sdk&lt;/artifactId&gt;\n    &lt;version&gt;0.0.3&lt;/version&gt;\n&lt;/dependency&gt;</code></pre>\n<h3>1.2.2创建微信支付配置类，配置商品信息</h3>\n<p>创建一类，实现WXPayConfig接口</p>\n<p>重写三分方法，分别设置商品AppID\\商户ID\\商户密钥</p>\n<pre><code class=\"language-java\">package com.qfedu.config;\n\nimport com.github.wxpay.sdk.WXPayConfig;\n\nimport java.io.InputStream;\n\n/**\n * @Description:\n * @Author : Jerry\n * @create : 2022-07-02 18:16\n */\npublic class MyPayConfig implements WXPayConfig {\n    @Override\n    public String getAppID() {\n        return \"wx632c8f211f8122c6\";\n    }\n\n    @Override\n    public String getMchID() {\n        return \"1497984412\";\n    }\n\n    @Override\n    public String getKey() {\n        return \"sbNCm1JnevqI36LrEaxFwcaT0hkGxFnc\";\n    }\n\n    @Override\n    public InputStream getCertStream() {\n        return null;\n    }\n\n    @Override\n    public int getHttpConnectTimeoutMs() {\n        return 0;\n    }\n\n    @Override\n    public int getHttpReadTimeoutMs() {\n        return 0;\n    }\n}\n</code></pre>\n<p><img alt=\"\" height=\"668\" src=\"image\\6300f18519ef4035bb2e24634fe79441.png\" width=\"1200\"/></p>\n<h3> 1.2.3设置订单的参数</h3>\n<pre><code class=\"language-java\">//设置当前订单信息\nHashMap&lt;String,String&gt; data = new HashMap&lt;&gt;();\ndata.put(\"fee_type\",\"CNY\");         //支付币种\ndata.put(\"total_fee\",\"0.1\");        //支付总金额\ndata.put(\"body\",\"咪咪虾条\");        // 商品描述\n//使用当前用户订单的编号作为当前支付交易的交易号\ndata.put(\"out_trade_no\", orderId);\ndata.put(\"trade_type\",\"NATIVE\");    //交易类型\ndata.put(\"notify_url\",\"/pay/success\");          //设置支付完成时的回调方法接口\n</code></pre>\n<p>修改OrderService的实现类：</p>\n<pre><code class=\"language-java\">package com.qfedu.fmmall.service.impl;\n\nimport com.qfedu.fmmall.dao.OrderItemMapper;\nimport com.qfedu.fmmall.dao.OrdersMapper;\nimport com.qfedu.fmmall.dao.ProductSkuMapper;\nimport com.qfedu.fmmall.dao.ShoppingCartMapper;\nimport com.qfedu.fmmall.entity.OrderItem;\nimport com.qfedu.fmmall.entity.Orders;\nimport com.qfedu.fmmall.entity.ProductSku;\nimport com.qfedu.fmmall.entity.ShoppingCartVO;\nimport com.qfedu.fmmall.service.OrderService;\nimport com.qfedu.fmmall.vo.R;\nimport com.qfedu.fmmall.vo.ResStatus;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\nimport java.math.BigDecimal;\nimport java.util.*;\n\n/**\n * @Description:\n * @Author : Jerry\n * @create : 2022-07-01 17:46\n */\n@Service\npublic class OrderServiceImpl implements OrderService {\n\n    @Autowired\n    private ShoppingCartMapper shoppingCartMapper;\n    @Autowired\n    private OrdersMapper ordersMapper;\n    @Autowired\n    private OrderItemMapper orderItemMapper;\n    @Autowired\n    private ProductSkuMapper productSkuMapper;\n\n    /**\n     * 保存订单业务\n     * @param cids 在购物车列表页面选择得购物车记录的ID\n     * @param order\n     * @return\n     */\n    @Transactional\n    public Map&lt;String,String&gt; addOrder(String cids, Orders order)  {\n\n        Map&lt;String,String&gt; map = new HashMap&lt;&gt;();\n\n        //1.校验库存:根据cids查询当前订单中关联的购物车记录详情（包括库存）\n        String[] arr = cids.split(\",\");\n        List&lt;Integer&gt; cidList = new ArrayList&lt;&gt;();\n        for (int i = 0; i&lt;arr.length; i++){\n            cidList.add(Integer.parseInt(arr[i]));\n        }\n        List&lt;ShoppingCartVO&gt; list = shoppingCartMapper.selectShopCartByCids(cidList);\n\n        boolean f = true;\n        String untitled = \"\";\n        for (ShoppingCartVO sc: list){\n            if(Integer.parseInt(sc.getCartNum())&gt;sc.getSkuStock()){\n                f = false;\n            }\n            //获取所有商品名称，以,分割拼接称字符串\n            untitled = untitled+sc.getProductName()+\",\";\n\n        }\n        if(f){\n            //2. 保存订单\n            //收货人信息：姓名，电话，地址,商品总价格,支付方式,订单创建时间\n            //订单初始状态（待支付 1）\n            order.setUntitled(untitled);\n            order.setCreateTime(new Date());\n            order.setStatus(\"1\");\n            //生成订单编号\n            String orderId = UUID.randomUUID().toString().replace(\"-\", \" \");\n            order.setOrderId(orderId);\n            ordersMapper.insert(order);\n\n            //3.生成商品快照\n            for(ShoppingCartVO sc:list){\n                int cnum = Integer.parseInt(sc.getCartNum());\n                String itemId = System.currentTimeMillis()+\"\"+(new Random().nextInt(89999)+10000);//增大容错率\n                OrderItem orderItem = new OrderItem(itemId, orderId, sc.getProductId(), sc.getProductName(), sc.getProductImg(), sc.getSkuId(), sc.getSkuName(), new BigDecimal(sc.getSellPrice())\n                        , cnum, new BigDecimal(sc.getSellPrice()*cnum), new Date(), new Date(), 0);\n                orderItemMapper.insert(orderItem);\n            }\n\n            //4.扣减库存：根据套餐id修改套餐库存量\n            for (ShoppingCartVO sc: list){\n                String skuId = sc.getSkuId();\n                int newStock = sc.getSkuStock() - Integer.parseInt(sc.getCartNum());\n\n                //updateByExampleSelective只添加修改的，其他的不变\n                ProductSku productSku = new ProductSku();\n                productSku.setSkuId(skuId);\n                productSku.setStock(newStock);\n                productSkuMapper.updateByPrimaryKeySelective(productSku);\n            }\n\n            //5.删除购物车：当购物车中得记录购买成功之后，购物车中对应做删除操作\n            for(int cid:cidList){\n                shoppingCartMapper.deleteByPrimaryKey(cid);\n            }\n\n            map.put(\"orderId\",orderId);\n            map.put(\"productNames\",untitled);\n            return map;\n        }else {\n            //表示库存不足\n            return null;\n        }\n\n    }\n}\n</code></pre>\n<p>OrderController：（微信支付实现）</p>\n<pre><code class=\"language-java\">package com.qfedu.controller;\n\nimport com.github.wxpay.sdk.WXPay;\nimport com.qfedu.config.MyPayConfig;\nimport com.qfedu.fmmall.entity.Orders;\nimport com.qfedu.fmmall.service.OrderService;\nimport com.qfedu.fmmall.vo.R;\nimport com.qfedu.fmmall.vo.ResStatus;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.*;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * @Description:\n * @Author : Jerry\n * @create : 2022-07-01 19:40\n */\n@RestController\n@CrossOrigin\n@RequestMapping(\"/order\")\npublic class OrderController {\n\n    @Autowired\n    private OrderService orderService;\n\n    @PostMapping(\"/add\")\n    public R add(String cids, @RequestBody Orders order){\n        R r = null;\n        try {\n            Map&lt;String, String&gt; orderInfo = orderService.addOrder(cids, order);\n            String orderId = orderInfo.get(\"orderId\");\n\n            if(orderId!=null){\n\n                //设置当前订单信息\n                HashMap&lt;String,String&gt; data = new HashMap&lt;&gt;();\n                data.put(\"fee_type\",\"CNY\");         //支付币种\n                data.put(\"total_fee\",order.getActualAmount()*100+\"\");        //支付总金额\n                data.put(\"body\",orderInfo.get(\"productNames\"));             // 商品描述\n                //使用当前用户订单的编号作为当前支付交易的交易号\n                data.put(\"out_trade_no\", orderId);\n                data.put(\"trade_type\",\"NATIVE\");    //交易类型\n                data.put(\"notify_url\",\"/pay/success\");          //设置支付完成时的回调方法接口\n\n                //发送请求，获取响应\n                //微信支付：申请支付连接\n                WXPay wxPay = new WXPay(new MyPayConfig());\n                Map&lt;String, String&gt; resp = wxPay.unifiedOrder(data);\n                orderInfo.put(\"payUrl\",resp.get(\"code_url\"));\n                //orderInfo中包含了：订单编号，购买的商品名称，支付链接\n                r = new R(ResStatus.OK,\"提交订单成功！！！\",orderInfo);\n            }else {\n                r = new R(ResStatus.NO,\"提交订单失败！！！\",null);\n            }\n        } catch (Exception e) {\n            r = new R(ResStatus.NO,\"提交订单失败！！！\",null);\n        }\n        return r;\n    }\n\n}\n</code></pre>\n<h1>2.支付回调</h1>\n<p>支付回调：当用户支付成功之后，支付平台会向我们指定的服务器接口发送请求传递订单支付状态数据</p>\n<h2>2.1 创建一个控制器定义回调接口</h2>\n<pre><code class=\"language-java\">package com.qfedu.controller;\n\nimport com.github.wxpay.sdk.WXPayUtil;\nimport com.qfedu.fmmall.service.OrderService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.PostMapping;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport javax.servlet.ServletInputStream;\nimport javax.servlet.http.HttpServletRequest;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * @Description: 回调接口:当用户支付成功之后，微信支付平台就会请求这个接口，将支付状态的数据传递过来\n * @Author : Jerry\n * @create : 2022-07-02 18:44\n */\n@RestController\n@RequestMapping(\"/pay\")\npublic class PayController {\n\n    @Autowired\n    private OrderService orderService;\n\n    /**\n     * 1.接收微信支付平台传递的数据（使用request的输入流接收）\n     */\n    @PostMapping(\"/callback\")\n    public String success(HttpServletRequest request) throws Exception {\n        ServletInputStream is = request.getInputStream();\n        byte[] bs = new byte[1024];\n        int len = -1;\n        StringBuilder builder = new StringBuilder();\n        while ((len = is.read(bs)) != -1){\n            builder.append(new String(bs,0,len));\n        }\n        String s = builder.toString();\n        //使用帮助类将xml接口的字符串转换成map\n        Map&lt;String,String&gt; map = WXPayUtil.xmlToMap(s);\n\n        if(map!=null &amp;&amp; \"success\".equalsIgnoreCase(map.get(\"result_code\"))){\n            //支付成功\n            //2.修改订单状态为“待发货/已支付”\n            String orderId = map.get(\"out_trade_no\");\n            int i = orderService.updateOrderStatus(orderId, \"2\");\n            System.out.println(\"--orderId:\"+orderId);\n            //3.响应微信支付平台\n            if(i&gt;0){\n                HashMap&lt;String,String&gt; resp = new HashMap&lt;&gt;();\n                resp.put(\"return_code\",\"success\");\n                resp.put(\"return_msg\",\"OK\");\n                resp.put(\"appid\",map.get(\"appid\"));\n                resp.put(\"result_code\",\"success\");\n                return WXPayUtil.mapToXml(resp);\n            }\n        }\n        //支付失败\n        return null;\n    }\n\n}\n</code></pre>\n<h2>2.2 设置回调URL</h2>\n<p>在订单接口中申请支付链接的时候将回调接口的路径设置给微信支付平台</p>\n<p><img alt=\"\" height=\"779\" src=\"image\\b9c045b7d4a443bfba755cef56c69949.png\" width=\"1200\"/></p>\n<p> <img alt=\"\" height=\"116\" src=\"image\\ca246e402cfd4aa4ac678b8f09a2f753.png\" width=\"1014\"/></p>\n<h2> 2.3 Ngrok实现内网穿透</h2>\n<p>网站：ngrok.cc</p>\n<p>注册账号，申请隧道id</p>\n<p>开通隧道：</p>\n<p><img alt=\"\" height=\"753\" src=\"image\\383572a83b404f31ada98facea405bd5.png\" width=\"1189\"/></p>\n<p> <img alt=\"\" height=\"701\" src=\"image\\1d3736e14245465a9dd46553171b4d34.png\" width=\"1200\"/></p>\n<p> 获取隧道id：</p>\n<p><img alt=\"\" height=\"311\" src=\"image\\fe683cf4ab8049319f8656d357eba3de.png\" width=\"1200\"/></p>\n<p> 下载客户端</p>\n<h2>2.4 前端通过轮询访问获取订单支付状态</h2>\n<h3>流程图：</h3>\n<p><img alt=\"\" height=\"188\" src=\"image\\2ba13026c40845a19634db2621b278ce.png\" width=\"980\"/></p>\n<p> </p>\n<h3>接口实现：</h3>\n<p>service接口：</p>\n<pre><code class=\"language-java\">package com.qfedu.fmmall.service;\n\nimport com.qfedu.fmmall.entity.Orders;\nimport com.qfedu.fmmall.vo.R;\n\nimport java.util.Map;\n\n/**\n * @Description: 订单接口\n * @Author : Jerry\n * @create : 2022-07-01 17:45\n */\npublic interface OrderService {\n\n    public Map&lt;String,String&gt; addOrder(String cids, Orders order);\n\n    public int updateOrderStatus(String orderId,String status);\n\n    public R getOrderById(String orderId);\n\n}\n</code></pre>\n<p>service实现类：</p>\n<pre><code class=\"language-java\">@Override\npublic R getOrderById(String orderId) {\n    Orders orders = ordersMapper.selectByPrimaryKey(orderId);\n    return new R(ResStatus.OK,\"success\",orders.getStatus());\n}</code></pre>\n<p>controller：</p>\n<pre><code class=\"language-java\">@GetMapping(\"/status/{oid}\")\npublic R getOrderStatus(@PathVariable(\"oid\") String orderId,\n                        @RequestHeader(\"token\")String token){\n    R r = orderService.getOrderById(orderId);\n    return r;\n}</code></pre>\n<h2>2.5 webSocket消息推送：</h2>\n<h3>实现流程： </h3>\n<p><img alt=\"\" height=\"541\" src=\"image\\d5db13490e1044b5b62695a458c7a774.png\" width=\"939\"/></p>\n<h3> 2.5.1 创建webSocket服务器</h3>\n<p>添加依赖：</p>\n<pre><code class=\"language-java\">&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt;\n&lt;/dependency&gt;</code></pre>\n<p>添加websocket服务节点配置：（Java配置方式）</p>\n<pre><code class=\"language-java\">@Configuration\npublic class WebSocketConfig {\n\n    @Bean\n    public ServerEndpointExporter getServerEndpointExporter(){\n        return new ServerEndpointExporter();\n    }\n\n}</code></pre>\n<p>创建websocket服务器：</p>\n<pre><code class=\"language-java\">package com.qfedu.websocket;\n\nimport org.springframework.stereotype.Component;\nimport org.springframework.web.bind.annotation.PostMapping;\n\nimport javax.websocket.OnClose;\nimport javax.websocket.OnOpen;\nimport javax.websocket.Session;\nimport javax.websocket.server.PathParam;\nimport javax.websocket.server.ServerEndpoint;\nimport java.io.IOException;\nimport java.util.concurrent.ConcurrentHashMap;\n\n/**\n * @Description:\n * @Author : Jerry\n * @create : 2022-07-03 13:06\n */\n@Component\n@ServerEndpoint(\"/webSocket/{oid}\")\npublic class WebSocketServer {\n\n    private static ConcurrentHashMap&lt;String,Session&gt; sessionMap = new ConcurrentHashMap&lt;&gt;();\n\n    /**\n     * 前端发送请求建立websocket连接，就会执行  @OnOpen 方法\n     */\n    @OnOpen\n    public void open(@PathParam(\"oid\") String orderId, Session session){\n        System.out.println(\"---------建立连接:\"+orderId);\n        sessionMap.put(orderId,session);\n    }\n\n    /**\n     * 前端关闭页面或者主动关闭webSocket连接，都会执行close\n     */\n    @OnClose\n    public void close(@PathParam(\"oid\") String orderId){\n        sessionMap.remove(orderId);\n    }\n\n    public static void sendMsg(String orderId,String msg){\n        try {\n            Session session = sessionMap.get(orderId);\n            session.getBasicRemote().sendText(msg);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n}\n</code></pre>\n<p>修改回调接口：</p>\n<p><img alt=\"\" height=\"624\" src=\"image\\db515be4597c4f308483c83a5d8ef78a.png\" width=\"1074\"/></p>\n<p> </p>\n</div>\n</div>"}