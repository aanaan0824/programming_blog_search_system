{"blogid": "124897294", "writerAge": "码龄1年", "writerBlogNum": "103", "writerCollect": "5465", "writerComment": "4193", "writerFan": "7301", "writerGrade": "7级", "writerIntegral": "13153", "writerName": "三分苦", "writerProfileAdress": "writer_image\\profile_124897294.jpg", "writerRankTotal": "783", "writerRankWeekly": "296", "writerThumb": "4502", "writerVisitNum": "115916", "blog_read_count": "1312", "blog_time": "已于 2022-06-29 17:41:35 修改", "blog_title": "【 C++ 】日期计算器", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E4%B8%80%E3%80%81%E5%89%8D%E8%A8%80-toc\" style=\"margin-left:80px;\"><a href=\"#%E4%B8%80%E3%80%81%E5%89%8D%E8%A8%80\">一、前言</a></p>\n<p id=\"%E4%BA%8C%E3%80%81%E6%97%A5%E6%9C%9F%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0-toc\" style=\"margin-left:80px;\"><a href=\"#%E4%BA%8C%E3%80%81%E6%97%A5%E6%9C%9F%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0\">二、日期类的实现</a></p>\n<p id=\"%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E6%A3%80%E6%9F%A5%E6%97%A5%E6%9C%9F%E7%9A%84%E5%90%88%E6%B3%95%E6%80%A7-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E6%A3%80%E6%9F%A5%E6%97%A5%E6%9C%9F%E7%9A%84%E5%90%88%E6%B3%95%E6%80%A7\">        检查日期的合法性</a></p>\n<p id=\"%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%3C%C2%A0%C2%A0%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%3C%C2%A0%C2%A0%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD\">         &lt;  运算符重载</a></p>\n<p id=\"%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%3D%3D%20%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%3D%3D%20%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD\">        == 运算符重载</a></p>\n<p id=\"%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%3C%3D%20%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%3C%3D%20%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD\">        &lt;= 运算符重载</a></p>\n<p id=\"%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%3E%C2%A0%C2%A0%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%3E%C2%A0%C2%A0%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD\">         &gt;  运算符重载</a></p>\n<p id=\"%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%3E%3D%20%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%3E%3D%20%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD\">        &gt;= 运算符重载</a></p>\n<p id=\"%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0!%3D%20%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0!%3D%20%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD\">         != 运算符重载</a></p>\n<p id=\"%E6%94%B9%E8%BF%9B%E5%92%8C%E4%BC%98%E5%8C%96-toc\" style=\"margin-left:80px;\"><a href=\"#%E6%94%B9%E8%BF%9B%E5%92%8C%E4%BC%98%E5%8C%96\">        </a><a href=\"#%E6%94%B9%E8%BF%9B%E5%92%8C%E4%BC%98%E5%8C%96\">改进和优化</a></p>\n<p id=\"%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E6%97%A5%E6%9C%9F%20%2B%20%E5%A4%A9%E6%95%B0-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E6%97%A5%E6%9C%9F%20%2B%20%E5%A4%A9%E6%95%B0\">        日期 + 天数</a></p>\n<p id=\"%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E6%97%A5%E6%9C%9F%20%2B%3D%20%E5%A4%A9%E6%95%B0-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E6%97%A5%E6%9C%9F%20%2B%3D%20%E5%A4%A9%E6%95%B0\">        日期 += 天数</a></p>\n<p id=\"%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E6%97%A5%E6%9C%9F%20-%3D%20%E5%A4%A9%E6%95%B0-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E6%97%A5%E6%9C%9F%20-%3D%20%E5%A4%A9%E6%95%B0\">        日期 -= 天数</a></p>\n<p id=\"%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E6%97%A5%E6%9C%9F%20-%20%E5%A4%A9%E6%95%B0-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E6%97%A5%E6%9C%9F%20-%20%E5%A4%A9%E6%95%B0\">        日期 - 天数</a></p>\n<p id=\"%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E5%89%8D%E7%BD%AE%20%2B%2B-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E5%89%8D%E7%BD%AE%20%2B%2B\">        前置 ++</a></p>\n<p id=\"%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E5%90%8E%E7%BD%AE%20%2B%2B-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E5%90%8E%E7%BD%AE%20%2B%2B\">        后置 ++</a></p>\n<p id=\"%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E5%89%8D%E7%BD%AE%20---toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E5%89%8D%E7%BD%AE%20--\">        前置 --</a></p>\n<p id=\"%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E5%90%8E%E7%BD%AE%20---toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E5%90%8E%E7%BD%AE%20--\">        后置 --</a></p>\n<p id=\"%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E6%97%A5%E6%9C%9F%20-%20%E6%97%A5%E6%9C%9F-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E6%97%A5%E6%9C%9F%20-%20%E6%97%A5%E6%9C%9F\">        日期 - 日期</a></p>\n<p id=\"%E4%B8%89%E3%80%81%E6%80%BB%E7%BB%93-toc\" style=\"margin-left:80px;\"><a href=\"#%E4%B8%89%E3%80%81%E6%80%BB%E7%BB%93\">三、总结</a></p>\n<hr/>\n<h3>一、前言</h3>\n<blockquote>\n<p>在我们的日常生活中，我们可能需要计算几天后的日期，或计算日期差等，现如今计算日期的方式有很多，简单粗暴的直接查看日历，快捷点的直接使用<span style=\"color:#956fe7;\">日期计算器</span>来求得，先给一个网络上的日期计算器截图：</p>\n<p><img alt=\"\" height=\"444\" src=\"image\\5bb8c58572444b73bf58bb6ab3f99917.png\" width=\"911\"/></p>\n<p>现在，就让我们用代码来实现其工作原理吧。 </p>\n<ul><li><span style=\"background-color:#fefcd8;\">注意：</span>本篇日期类<span style=\"color:#956fe7;\"><strong>.h</strong></span>文件放声明，<span style=\"color:#956fe7;\"><strong>.cpp</strong></span>文件放定义</li></ul>\n</blockquote>\n<h3 id=\"%E4%BA%8C%E3%80%81%E6%97%A5%E6%9C%9F%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0\">二、日期类的实现</h3>\n<h3 id=\"%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E6%A3%80%E6%9F%A5%E6%97%A5%E6%9C%9F%E7%9A%84%E5%90%88%E6%B3%95%E6%80%A7\">检查日期的合法性</h3>\n<blockquote>\n<p>实现日期类首先就得检查日期的合法性，这其中就包括大小月，闰年的2月有29天，一年只有12个月等等细节都要考虑到。</p>\n<pre><code class=\"language-cpp\">class Date\n{\npublic:\n    bool isLeapYear(int year) //判断是否为闰年\n    {\n    \t//四年一闰百年不闰或四百年一闰\n    \treturn (year % 4 == 0 &amp;&amp; year % 100 != 0) || (year % 400 == 0);\n    }\n\tint GetMonthDay(int year, int month)\n\t{\n        //加上static防止函数频繁调用开辟几十个字节大小的数组，最好加上\n\t\tstatic int monthDayArray[13] = { 0,31,28,31,30,31,30,31,31,30,31,30,31 };\n\t\tif (month == 2 &amp;&amp; isLeapYear(year))\n\t\t\treturn 29; //闰月29天\n\t\telse\n\t\t\treturn monthDayArray[month];\n\t}\n\tDate(int year = 1, int month = 1, int day = 1)\n\t{\n\t\tif (year &gt;= 1 &amp;&amp; month &lt;= 12 &amp;&amp; month &gt;= 1 &amp;&amp; day &lt;= GetMonthDay(year, month))\n\t\t{\n            //确保日期合法\n\t\t\t_year = year;\n\t\t\t_month = month;\n\t\t\t_day = day;\n\t\t}\n\t}\nprivate:\n\tint _year;\n\tint _month;\n\tint _day;\n};\n</code></pre>\n</blockquote>\n<h3 id=\"%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%3C%C2%A0%C2%A0%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD\">&lt;  运算符重载</h3>\n<blockquote>\n<ul><li><span style=\"background-color:#fbd4d0;\">思路：</span></li></ul>\n<p>&lt; 运算符重载在我上一篇博文已经详细讲解过，主要是先把大于的情况全部统计出来，就比如我要比较实例化对象d1是否小于实例化对象d2，只需考虑如下三种满足的情况：</p>\n<ul><li>d1的年小于d2的年</li><li>d1与d2年相等，d1的月小于d2的月</li><li>d1与d2年相等月相等，d1的天小于d2的天</li></ul>\n<p>这三种全是小于的情况，返回true，其余返回false</p>\n<ul><li><span style=\"background-color:#edf6e8;\">代码如下：</span></li></ul>\n<pre><code class=\"language-cpp\">// &lt;运算符重载\nbool Date::operator&lt;(const Date&amp; d) const //类外访问成员函数需要设定类域\n{\n\tif (_year &lt; d._year ||\n\t\t_year == d._year &amp;&amp; _month &lt; d._month ||\n\t\t_year == d._year &amp;&amp; _month == d._month &amp;&amp; _day &lt; d._day)\n\t\treturn true;\n\telse\n\t\treturn false;\n}</code></pre>\n</blockquote>\n<h3 id=\"%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%3D%3D%20%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD\">== 运算符重载</h3>\n<blockquote>\n<ul><li><span style=\"background-color:#fbd4d0;\"> 思路：</span></li></ul>\n<p>== 运算符重载其实非常简单，只需要判断d1和d2的年、月、天是否对应相等即可：</p>\n<ul><li><span style=\"background-color:#edf6e8;\">代码如下：</span></li></ul>\n<pre><code class=\"language-cpp\">// ==运算符重载\nbool Date::operator==(const Date&amp; d) const\n{\n\treturn _year == d._year &amp;&amp;\n\t\t_month == d._month &amp;&amp;\n\t\t_day == d._day;\n}</code></pre>\n</blockquote>\n<h3 id=\"%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%3C%3D%20%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD\">&lt;= 运算符重载</h3>\n<blockquote>\n<ul><li><span style=\"background-color:#fbd4d0;\">思路： --  </span><strong><span style=\"background-color:#fbd4d0;\">复用</span></strong></li></ul>\n<p>&lt;= 的运算符重载，这里要仔细想一想 &lt;= 成立的条件是啥。不就是<span style=\"color:#956fe7;\"> 要么 &lt; 要么 =</span> 吗？我们只需要<span style=\"color:#fe2c24;\"><strong>复用</strong></span>先前写的<span style=\"color:#956fe7;\"> &lt; 运算符重载</span>和 <span style=\"color:#956fe7;\">&lt;=运算符重载</span>，无需自己费老大劲推导其内部原理。</p>\n<ul><li><span style=\"background-color:#edf6e8;\">代码如下：</span></li></ul>\n<pre><code class=\"language-cpp\">// &lt;=运算符重载\nbool Date::operator&lt;=(const Date&amp; d) const\n{\n\treturn *this &lt; d || *this == d;\n}</code></pre>\n</blockquote>\n<h3 id=\"%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%3E%C2%A0%C2%A0%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD\">&gt;  运算符重载</h3>\n<blockquote>\n<ul><li><span style=\"background-color:#fbd4d0;\">思路： --  </span><strong><span style=\"background-color:#fbd4d0;\">复用</span></strong></li></ul>\n<p>&gt; 的反义就是 &lt;=，所以我们只需要<span style=\"color:#fe2c24;\"><strong>复用</strong> </span><span style=\"color:#956fe7;\">&lt;= 运算符重载</span>，再<span style=\"color:#fe2c24;\">对其取反</span>即可解决此问题。</p>\n<ul><li><span style=\"background-color:#edf6e8;\">代码如下：</span></li></ul>\n<pre><code class=\"language-cpp\">// &gt;运算符重载\nbool Date::operator&gt;(const Date&amp; d) const\n{\n\treturn !(*this &lt;= d);\n}</code></pre>\n</blockquote>\n<h3 id=\"%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%3E%3D%20%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD\">&gt;= 运算符重载</h3>\n<blockquote>\n<ul><li><span style=\"background-color:#fbd4d0;\">思路： --  </span><strong><span style=\"background-color:#fbd4d0;\">复用</span></strong></li></ul>\n<p>&gt;= 的反义就是 &lt;，所以我们只需要<span style=\"color:#fe2c24;\"><strong>复用</strong></span> <span style=\"color:#956fe7;\">&lt; 运算符重载</span>，再<span style=\"color:#fe2c24;\">对其取反</span>即可。</p>\n<ul><li><span style=\"background-color:#edf6e8;\">代码如下：</span></li></ul>\n<pre><code class=\"language-cpp\">// &gt;=运算符重载\nbool Date::operator&gt;=(const Date&amp; d) const\n{\n\treturn !(*this &lt; d);\n}</code></pre>\n</blockquote>\n<h3 id=\"%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0!%3D%20%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD\">!= 运算符重载</h3>\n<blockquote>\n<ul><li><span style=\"background-color:#fbd4d0;\">思路： --  <strong>复用</strong></span></li></ul>\n<p>有了前面的基础，写个 != 也很简单，<span style=\"color:#956fe7;\">对 == 取反</span>即可</p>\n<ul><li><span style=\"background-color:#edf6e8;\">代码如下：</span></li></ul>\n<pre><code class=\"language-cpp\">//!=运算符重载\nbool Date::operator!=(const Date&amp; d) const\n{\n\treturn !(*this == d);\n}</code></pre>\n</blockquote>\n<h3 id=\"%E6%94%B9%E8%BF%9B%E5%92%8C%E4%BC%98%E5%8C%96\">改进和优化</h3>\n<blockquote>\n<p>上述我们写的运算符重载都是建立在声明定义分离的，这里我们可以对其进行优化，如下：</p>\n<p>先前我们学过内联，可以帮助我们对于短小函数减少函数调用而引发的效率损失问题，因此我们可以把上述几个运算符重载函数放成内联，此外，有一种简单粗暴的方法：<span style=\"color:#fe2c24;\">直接在类里定义，因为类里的函数默认内联</span>，还省的我们自己写inline，而且我们也不用在类外加上类域了，当然，有些长的函数还是声明和定义分离比较好。</p>\n<ul><li><span style=\"background-color:#fbd4d0;\">Date.h 文件：</span></li></ul>\n<pre><code class=\"language-cpp\">#pragma once\n#include&lt;iostream&gt;\n#include&lt;assert.h&gt;\nusing std::cout;\nusing std::cin;\nusing std::endl;\nclass Date\n{\npublic:\n\tbool isLeapYear(int year)\n\t{\n\t\t//四年一润百年不润或四百年一润\n\t\treturn (year % 4 == 0 &amp;&amp; year % 100 != 0) || (year % 400 == 0);\n\t}\n\t//获取某月天数\n\tint GetMonthDay(int year, int month);\n\t//构造函数\n\tDate(int year = 1, int month = 1, int day = 1);\n\t//打印\n\tvoid Print() const\n\t{\n\t\tcout &lt;&lt; _year &lt;&lt; \"-\" &lt;&lt; _month &lt;&lt; \"-\" &lt;&lt; _day &lt;&lt; endl;\n\t}\n\t// &lt;运算符重载\n\tbool operator&lt;(const Date&amp; d) const;\n\t// ==运算符重载\n\tbool operator==(const Date&amp; d) const;\n\t// &lt;=运算符重载\n\tbool operator&lt;=(const Date&amp; d) const\n\t{\n\t\treturn *this &lt; d || *this == d;\n\t}\n\t// &gt;运算符重载\n\tbool operator&gt;(const Date&amp; d) const\n\t{\n\t\treturn !(*this &lt;= d);\n\t\t//return (d &lt; *this);\n\t}\n\t// &gt;=运算符重载\n\tbool operator&gt;=(const Date&amp; d) const\n\t{\n\t\treturn !(*this &lt; d);\n\t}\n\t// !=运算符重载\n\tbool operator!=(const Date&amp; d) const\n\t{\n\t\treturn !(*this == d);\n\t}\nprivate:\n\tint _year;\n\tint _month;\n\tint _day;\n};</code></pre>\n<ul><li><span style=\"background-color:#fbd4d0;\">Date.cpp 文件：</span></li></ul>\n<pre><code class=\"language-cpp\">#include\"Date.h\"\n//获取某月天数\nint Date::GetMonthDay(int year, int month)\n{\n\tassert(year &gt;= 0 &amp;&amp; month &gt; 0 &amp;&amp; month &lt; 13);\n\tstatic int monthDayArray[13] = { 0,31,28,31,30,31,30,31,31,30,31,30,31 };\n\tif (month == 2 &amp;&amp; isLeapYear(year))\n\t\treturn 29;\n\telse\n\t\treturn monthDayArray[month];\n}\n//构造函数\nDate::Date(int year, int month, int day)\n{\n\tif (year &gt;= 1 &amp;&amp; month &lt;= 12 &amp;&amp; month &gt;= 1 &amp;&amp; day &lt;= GetMonthDay(year, month))\n\t{\n\t\t_year = year;\n\t\t_month = month;\n\t\t_day = day;\n\t}\n\telse\n\t\tcout &lt;&lt; \"日期非法\" &lt;&lt; endl;\n}\n// &lt;运算符重载\nbool Date::operator&lt;(const Date&amp; d) const //类外访问成员函数需要设定类域\n{\n\tif (_year &lt; d._year ||\n\t\t_year == d._year &amp;&amp; _month &lt; d._month ||\n\t\t_year == d._year &amp;&amp; _month == d._month &amp;&amp; _day &lt; d._day)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n// ==运算符重载\nbool Date::operator==(const Date&amp; d) const\n{\n\treturn _year == d._year &amp;&amp;\n\t\t_month == d._month &amp;&amp;\n\t\t_day == d._day;\n}</code></pre>\n</blockquote>\n<h3 id=\"%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E6%97%A5%E6%9C%9F%20%2B%20%E5%A4%A9%E6%95%B0\">日期 + 天数</h3>\n<blockquote>\n<ul><li><span style=\"background-color:#fbd4d0;\">思路：</span></li></ul>\n<p>对于日期 + 天数，我们得到的还是一个日期。特别需要注意进位的问题（<span style=\"color:#956fe7;\">天满了往月进，月满了往年进</span>），主要考虑如下几个特殊点：</p>\n<ul><li>加过的天数超过该月的最大天数，需要进位</li><li>当月进位到13时，年进位+1，月置为1</li></ul>\n<p><img alt=\"\" height=\"419\" src=\"image\\cb8eeb08fe7b4bf2b86850ce943c2a12.png\" width=\"906\"/></p>\n<ul><li><span style=\"background-color:#fbd4d0;\">法一：</span></li></ul>\n<pre><code class=\"language-cpp\">Date Date::operator+(int day) const\n{\n\tDate ret(*this); //拷贝构造，拿d1去初始化ret\n\tret._day += day;\n\twhile (ret._day &gt; GetMonthDay(ret._year, ret._month))\n\t{\n\t\tret._day -= GetMonthDay(ret._year, ret._month);\n\t\tret._month++;\n\t\tif (ret._month == 13)\n\t\t{\n\t\t\tret._year++;\n\t\t\tret._month = 1;\n\t\t}\n\t}\n\treturn ret;\n}</code></pre>\n<p>出了作用域，对象ret不在，它是一个局部对象，我们这里不能用引用，用了的话，返回的就是ret的别名，但是ret又已经销毁了，访问野指针了，<span style=\"color:#956fe7;\">所以出了作用域，如果对象不在了，就不能用引用返回，要用传值返回</span></p>\n<ul><li><span style=\"background-color:#fbd4d0;\">法二：<strong>复用日期+=天数</strong></span></li></ul>\n<p>此法是建立在日期+=天数的基础上完成的，这里各位可以先看下文日期+=天数，然后我们进行复用：</p>\n<pre><code class=\"language-cpp\">Date Date::operator+(int day) const\n{\n\t//法二：复用日期 += 天数\n\tDate ret(*this);\n\tret += day;\n\treturn ret;\n}</code></pre>\n<ul><li><span style=\"background-color:#edf6e8;\">法一和法二熟优？</span></li></ul>\n<p>答案：<span style=\"color:#956fe7;\">法二</span>更好，也就是用+去复用+=，具体原因在下文会解释。</p>\n</blockquote>\n<h3 id=\"%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E6%97%A5%E6%9C%9F%20%2B%3D%20%E5%A4%A9%E6%95%B0\">日期 += 天数</h3>\n<blockquote>\n<p>这里实现 += 其实有两种方案</p>\n<ul><li><span style=\"background-color:#fbd4d0;\">法一：</span></li></ul>\n<p>前面我实现的日期+天数，仔细观察我的代码，函数的第一行，我就调用了一个拷贝构造：</p>\n<pre><code class=\"language-cpp\">Date ret(*this); //拷贝构造，拿d1去初始化ret</code></pre>\n<p>这里调用拷贝构造，是为了不在*this本身上做变动，只在ret上进行操作，其理由是日期+天数得到的是另一个日期，而不用拷贝构造直接在*this上做改动只会导致原有的日期也变化，而这个变化正是我日期 += 天数的需求</p>\n<p></p>\n<p>仔细想想：+=天数就是在原有的日期上再加一定的天数，直接对*this做手脚即可，因此只需对日期+天数的代码进行小改动即可：</p>\n<pre><code class=\"language-cpp\">Date&amp; Date::operator+=(int day) //传引用返回\n{\n\t//如果day小于0，要单独处理\n\tif (day &lt; 0)\n\t{\n\t\treturn *this -= -day;\n\t}\n\t_day += day;\n\twhile (_day &gt; GetMonthDay(_year, _month))\n\t{\n\t\t_day -= GetMonthDay(_year, _month);\n\t\t_month++;\n\t\tif (_month == 13)\n\t\t{\n\t\t\t_year++;\n\t\t\t_month = 1;\n\t\t}\n\t}\n\treturn *this;\n}</code></pre>\n<p>注意这里是传引用返回，原因就在于我返回的*this是全局的，出了作用域还在</p>\n<ul><li><span style=\"background-color:#fbd4d0;\">法二：<strong>复用日期 +天数</strong></span></li></ul>\n<pre><code class=\"language-cpp\">Date&amp; Date::operator+=(int day)\n{\n\t//法二：复用\n\t* this = *this + day; //让d1+过天数后再返回给自己从而实现+=\n\treturn *this;\n}</code></pre>\n<ul><li><span style=\"background-color:#edf6e8;\">法一和法二熟优？</span></li></ul>\n<p>答案：<span style=\"color:#956fe7;\">法一</span>。其实讨论这个问题就是在讨论用+去复用+=号还是用+=复用+号，答案是用+去复用+=好，因为+有两次拷贝，而+=没有拷贝，所以实现+=，并且用+去复用+=效率更高</p>\n</blockquote>\n<h3 id=\"%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E6%97%A5%E6%9C%9F%20-%3D%20%E5%A4%A9%E6%95%B0\">日期 -= 天数</h3>\n<blockquote>\n<ul><li><span style=\"background-color:#fbd4d0;\">思路：</span></li></ul>\n<p>日期-=天数得到的还是一个日期，且是在原日期的基础上做改动。合法的日期减去天数后的day只要&gt;0就没问题，若小于0就要借位了。要注意当减去的天数&lt;0时单独讨论。具体步骤如下：</p>\n<ol><li>当减的天数为负数，则为+=，直接调用</li><li>若减后的day&lt;0，月-1</li><li>若月 = 0，则年-1，月置为12</li></ol>\n<ul><li><span style=\"background-color:#edf6e8;\">代码如下：</span></li></ul>\n<pre><code class=\"language-cpp\">//日期 -=天数  d1-=100\nDate&amp; Date::operator-=(int day)\n{\n\t//如果减去的天数是负数，要单独处理，直接调用+=运算符重载\n\tif (day &lt; 0)\n\t{\n\t\treturn *this += -day;\n\t}\n\t_day -= day;\n\twhile (_day &lt;= 0)\n\t{\n\t\t--_month;\n\t\tif (_month == 0)\n\t\t{\n\t\t\t_month = 12;\n\t\t\t--_year;\n\t\t}\n\t\t_day += GetMonthDay(_year, _month);\n\t}\n\treturn *this;\n}\n</code></pre>\n</blockquote>\n<h3 id=\"%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E6%97%A5%E6%9C%9F%20-%20%E5%A4%A9%E6%95%B0\">日期 - 天数</h3>\n<blockquote>\n<p>有了先前日期+和+=的基础，这里实现日期 - 天数直接复用日期 -= 天数即可：</p>\n<pre><code class=\"language-cpp\">//日期 - 天数\nDate Date::operator-(int day) const\n{\n\tDate ret(*this);\n\tret -= day;\n\treturn ret;\n}</code></pre>\n</blockquote>\n<h3 id=\"%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E5%89%8D%E7%BD%AE%20%2B%2B\">前置 ++</h3>\n<blockquote>\n<ul><li><span style=\"background-color:#fbd4d0;\">思路：</span></li></ul>\n<p>C++里有前置++和后置++，这就导致一个巨大的问题，该如何区分它们，具体实现过程不难（<span style=\"color:#956fe7;\">直接复用+=即可</span>），难的是如何区分前置和后置。因此C++规定，<span style=\"color:#fe2c24;\">无参的为前置，有参的为后置</span>。</p>\n<ul><li><span style=\"background-color:#edf6e8;\">代码如下：</span></li></ul>\n<pre><code class=\"language-cpp\">//前置++\nDate&amp; Date::operator++() //无参的为前置\n{\n\t*this += 1; //直接复用+=\n\treturn *this;\n}</code></pre>\n</blockquote>\n<h3 id=\"%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E5%90%8E%E7%BD%AE%20%2B%2B\">后置 ++</h3>\n<blockquote>\n<ul><li><span style=\"background-color:#fbd4d0;\">思路：</span></li></ul>\n<p>有参的即为后置，后置++拿到的返回值应该是自己本身未加过的，因此要<span style=\"color:#956fe7;\">先把自己保存起来，再++*this，随后返回自己。</span></p>\n<ul><li><span style=\"background-color:#edf6e8;\">代码如下：</span></li></ul>\n<pre><code class=\"language-cpp\">//后置++\nDate Date::operator++(int i) //有参数的为后置\n{\n\tDate tmp(*this);\n\t*this += 1; //复用+=\n\treturn tmp;\n}</code></pre>\n</blockquote>\n<h3 id=\"%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E5%89%8D%E7%BD%AE%20--\">前置 --</h3>\n<blockquote>\n<ul><li><span style=\"background-color:#fbd4d0;\">思路：</span></li></ul>\n<p>前置--和前置++没啥区别，只不过内部复用的是-=</p>\n<ul><li><span style=\"background-color:#edf6e8;\">代码如下：</span></li></ul>\n<pre><code class=\"language-cpp\">//前置--\nDate&amp; Date::operator--() //无参的为前置\n{\n\t*this -= 1; //直接复用-=\n\treturn *this;\n}\n</code></pre>\n</blockquote>\n<h3 id=\"%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E5%90%8E%E7%BD%AE%20--\">后置 --</h3>\n<blockquote>\n<ul><li><span style=\"background-color:#fbd4d0;\">思路：</span></li></ul>\n<p>后置--和后置++类似，只不过内部复用的是-=，不再赘述</p>\n<ul><li><span style=\"background-color:#edf6e8;\">代码如下：</span></li></ul>\n<pre><code class=\"language-cpp\">//后置--\nDate Date::operator--(int i) //有参数的为后置\n{\n\tDate tmp(*this);\n\t*this -= 1;\n\treturn tmp;\n}</code></pre>\n</blockquote>\n<h3 id=\"%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E6%97%A5%E6%9C%9F%20-%20%E6%97%A5%E6%9C%9F\">日期 - 日期</h3>\n<blockquote>\n<ul><li><span style=\"background-color:#fbd4d0;\">思路：</span></li></ul>\n<p>日期 - 日期得到的是天数，首先我们得判断两个日期的大小，用min和max代替小的和大的，随后，算出min和max之间的差距，若min!=max，则min就++，随即定义变量n也自增++，最后返回n（注意符号）</p>\n<ul><li><span style=\"background-color:#edf6e8;\">代码如下：</span></li></ul>\n<pre><code class=\"language-cpp\">//日期 - 日期\nint Date::operator-(const Date&amp; d) const\n{\n\tint flag = 1; //方便后续计算正负\n\tDate max = *this;\n\tDate min = d;\n\tif (*this &lt; d)\n\t{\n\t\tmin = *this;\n\t\tmax = d;\n\t\tflag = -1; //计算正负\n\t} //确保max是大的，min是小的\n\tint n = 0;\n\twhile (min != max)\n\t{\n\t\tmin++;\n\t\tn++;\n\t}//算出min和max之间绝对值差距\n\treturn n * flag; //如果d1大，结果为正，d2大结果为负\n}</code></pre>\n</blockquote>\n<h3 id=\"%E4%B8%89%E3%80%81%E6%80%BB%E7%BB%93\">三、总结</h3>\n<blockquote>\n<p>本篇日期类把先前学到的<span style=\"color:#956fe7;\">引用，传值/传引用返回、拷贝构造、复用</span>等等知识点柔和到了一起，非常值得大家操手练习练习，创作不易，还望三连。</p>\n<ul><li>日期类的源码链接：<a class=\"link-info\" href=\"https://gitee.com/bit-zy/class104/tree/master/Date/Date\" title=\"gitee链接：日期计算器完善版\">gitee链接：日期计算器完善版</a></li></ul>\n</blockquote>\n</div>\n</div>"}