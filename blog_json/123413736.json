{"blogid": "123413736", "writerAge": "码龄4年", "writerBlogNum": "75", "writerCollect": "557", "writerComment": "148", "writerFan": "90", "writerGrade": "4级", "writerIntegral": "1006", "writerName": "被代码折磨的狗子", "writerProfileAdress": "writer_image\\profile_123413736.jpg", "writerRankTotal": "18658", "writerRankWeekly": "25953", "writerThumb": "145", "writerVisitNum": "134048", "blog_read_count": "8730", "blog_time": "已于 2022-03-12 22:57:45 修改", "blog_title": "Unity之UnityWebRequest和使用", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h1>一、前言</h1>\n<p>1. UnityWebRequest</p>\n<blockquote>\n<p> 官方描述：</p>\n<p>UnityWebRequest 提供了一个模块化系统，用于构成 HTTP 请求和处理 HTTP 响应。UnityWebRequest 系统的主要目标是让 Unity 游戏与 Web 浏览器后端进行交互。该系统还支持高需求功能，例如分块 HTTP 请求、流式 POST/PUT 操作以及对 HTTP 标头和动词的完全控制。</p>\n<p>从官方描述来看，对于UnityWebRequest类的升级更大程度代表了Unity对于Webgl网页浏览器支持的优化。</p>\n</blockquote>\n<p>2.WWW类</p>\n<blockquote>\n<p>其实5.4版本的时候就出了新的API UnityWebRequest用于替代WWW，有些较大的文件下载需要断点续传的功能（即下载了一部分突然中断下载后，再次下载直接从上次下载的地方继续下载，而不是重新下载）就需要使用HttpWebRequest或UnityWebRequest，在2017版本中WWW是还没有被弃用的，2018版本我没有试过，2019是已经被弃用的，使用的时候可以看到这个类被画上了绿色波浪。</p>\n</blockquote>\n<p>这里大体的描述一下，后面还可能会持续深入解剖。下面讲述一下这个类的一些常用接口和使用</p>\n<h1>二、常用方法Get、Post、Put和Head</h1>\n<p><strong>UnityWebRequest</strong></p>\n<blockquote>\n<p>架构：</p>\n<p>UnityWebRequest 生态系统将 HTTP 事务分解为三个不同的操作：</p>\n<ul><li>向服务器提供数据</li><li>从服务器接收数据</li><li>HTTP 流量控制（例如，重定向和错误处理）</li></ul>\n<p>UnityWebRequest由三个元素组成：<br/> 1 UpLoadHandler处理数据将数据上传到服务器的对象；<br/> 2 DownLoadHandler从服务器下载数据的对象；<br/> 3 UnityWebRequest负责与HTTP通信并管理上面两个对象。还处理 HTTP 流量控制。此对象是定义自定义标头和 URL 的位置，也是存储错误和重定向信息的位置。</p>\n</blockquote>\n<p>更多描述请看官网手册：<a class=\"link-info\" href=\"https://docs.unity.cn/cn/2019.4/Manual/UnityWebRequest.html\" title=\"https://docs.unity.cn/cn/2019.4/Manual/UnityWebRequest.html\">https://docs.unity.cn/cn/2019.4/Manual/UnityWebRequest.html</a> </p>\n<p><strong> （1）常用方法：</strong></p>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px;\"><tbody><tr><td><strong>方法</strong></td><td><strong>作用</strong></td></tr><tr><td>SendWebRequest()</td><td>开始与远程服务器通信。在调用此方法之后，有必要的话UnityWebRequest将执行DNS解析，将HTTP请求发送到目标URL的远程服务器并处理服务器的响应。</td></tr><tr><td>Get(url)</td><td>创建一个HTTP为传入URL的UnityWebRequest对象</td></tr><tr><td>Post（url)</td><td>向Web服务器发送表单信息</td></tr><tr><td>Put(url)</td><td>将数据上传到Web服务器</td></tr><tr><td>Abort()</td><td>直接结束联网</td></tr><tr><td>Head()</td><td>创建一个为传输HTTP头请求的UnityWebRequest对象</td></tr><tr><td>GetResponseHeader()</td><td>返回一个字典，内容为在最新的HTTP响应中收到的所有响应头</td></tr></tbody></table>\n<p><strong>（2）构造函数</strong></p>\n<pre><code class=\"language-cs\">public UnityWebRequest（）; \npublic UnityWebRequest（Uri uri）;\npublic UnityWebRequest（Uri uri，string method）;\npublic UnityWebRequest（Uri uri，string method,Networking.DownloadHandler downloadHandler， \n\t\t\t\t\t\tNetworking.UploadHandler uploadHandler）;\n</code></pre>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px;\"><tbody><tr><td><strong>参数</strong></td><td><strong>含义</strong></td></tr><tr><td>URL</td><td>url网址信息或本地文件路径信息</td></tr><tr><td>method</td><td>相当于方法名，只有<code>GET, POST, PUT, HEAD</code>四种，默认为<code>GET</code>，一旦调用<code>SendWebRequest()</code>，就无法更改</td></tr><tr><td>downloadHandler</td><td>下载数据的委托方法</td></tr><tr><td>uploadHandler</td><td>上传数据的委托方法</td></tr></tbody></table>\n<p>下面介绍一下一些经常用的接口。介绍之前先简单聊聊GET、POST和PUT这三种方式的区别</p>\n<blockquote>\n<p>1.Get：一般用于向服务器获取信息，举例：后台服务器有一个接口http://127.0.0.1/Get/?studentName=张三，这个接口负责返回学生名字为张三的数据，我们在提交get的时候，服务器会接收studentName下的值，通过这个值来进行逻辑处理，使用Get我们要访问得值是暴露在浏览器中的，如果是用户名密码这样的重要信息被暴露后果将不堪设想，所以像网页中搜索栏需要条件来获取信息的功能，就可以使用Get的方法来实现。</p>\n<p>2.Post：这种方式就是为了解决Get访问时信息暴露的危险，使用Post访问时表单中的内容不会暴露，安全性更高，一般用于网页用户登录等重要信息上</p>\n<p>3.Put：这种方式用于将数据发送到远程的服务器。比如文件上传。</p>\n</blockquote>\n<h3>1.Get方法</h3>\n<p>(1) 使用静态类创建UnityWebRequest获取Txt文本信息</p>\n<pre><code class=\"language-cs\">using System.Collections;\nusing System.Collections.Generic;\nusing System.IO;\nusing UnityEngine.UI;\nusing UnityEngine;\nusing UnityEngine.EventSystems;\nusing UnityEngine.Networking;\nusing System;\n\npublic class AAA : MonoBehaviour\n{\n    void Start()\n    {\n        StartCoroutine(\"GetDataB\", \"Test.txt\");\n    }\n\n    #region 创建persistentDataPath文件夹\n    IEnumerator GetDataB(string fileName)\n    {\n        //1.url地址\n        string fromPath = Application.streamingAssetsPath + \"/\" + fileName;\n        //2.创建一个UnityWebRequest类 method属性为Get\n        UnityWebRequest request = UnityWebRequest.Get(fromPath);\n        //3.等待响应时间，超过5秒结束\n        request.timeout = 5;\n        //4.发送请求信息\n        yield return request.SendWebRequest(); \n\n        //5.判断是否下载完成\n        if (request.isDone)\n        {\n            //6.判断是否下载错误\n            if (request.isHttpError || request.isNetworkError)\n                Debug.Log(request.error);\n            else\n                Debug.Log(request.downloadHandler.text);\n        }\n    }\n\n    #endregion\n}\n</code></pre>\n<p>(2) 使用构造来创建</p>\n<blockquote>\n<p><span style=\"color:#fe2c24;\">注意：这里为什么要用两种方式呢？因为静态类创建(</span><span style=\"color:#4da8ee;\">UnityWebRequest.Get</span><span style=\"color:#fe2c24;\">)的Request是自带DownloadHandler和UploadHandler的，而构造创建(</span><span style=\"color:#4da8ee;\">new UnityWebRequest</span><span style=\"color:#fe2c24;\"> )是没有的，需要自己手动创建赋值，注意不要踩坑哦！！</span></p>\n</blockquote>\n<pre><code class=\"language-cs\">using System.Collections;\nusing System.Collections.Generic;\nusing System.IO;\nusing UnityEngine.UI;\nusing UnityEngine;\nusing UnityEngine.EventSystems;\nusing UnityEngine.Networking;\nusing System;\n\npublic class AAA : MonoBehaviour\n{\n    void Start()\n    {\n        StartCoroutine(\"GetDataB\", \"Test.txt\");\n    }\n\n    #region 创建persistentDataPath文件夹\n    IEnumerator GetDataB(string fileName)\n    {\n\n        string fromPath = Application.streamingAssetsPath + \"/\" + fileName;\n        Uri uri = new Uri(fromPath);\n        //UnityWebRequest request = UnityWebRequest.Get(fromPath);\n        UnityWebRequest request =new UnityWebRequest(uri); //使用构造\n        request.timeout = 5;//等待响应时间，超过5秒结束\n\n        /*使用构造没有DownloadHandler和UploadHandler，所以要创建赋值，这里只用到了下载，所以可以不用创建UploadHandler\n         * 下面罗列了三种不同类型的DownloadHandler\n         1.DownloadHandlerBuffer 读取文件存储\n         2.DownloadHandlerTexture 读取图片\n         3.DownloadHandlerFile 下载文件到本地\n         */\n        DownloadHandlerBuffer Download = new DownloadHandlerBuffer();\n        request.downloadHandler = Download;\n\n        yield return request.SendWebRequest();\n\n        if (request.isDone)\n        {\n            if (request.isHttpError || request.isNetworkError)\n                Debug.Log(request.error);\n            else \n                Debug.Log(request.downloadHandler.text);\n        }\n        \n    }\n\n    #endregion\n\n}\n</code></pre>\n<h3> 2.Post方法</h3>\n<blockquote>\n<p>Post方法将一个表上传到远程的服务器，一般来说我们登陆某个网站的时候会用到这个方法，我们的账号密码会以一个表单的形式传过去。</p>\n</blockquote>\n<pre><code class=\"language-cs\">using System.Collections;\nusing UnityEngine;\nusing UnityEngine.Networking;\n\n/// &lt;summary&gt;\n/// 网络请求测试\n/// &lt;/summary&gt;\npublic class ChinarWebRequest : MonoBehaviour\n{\n    void Start()\n    {\n        StartCoroutine(Post());\n    }\n    /// &lt;summary&gt;\n    /// 开启一个协程，发送请求\n    /// &lt;/summary&gt;\n    /// &lt;returns&gt;&lt;/returns&gt;\n    IEnumerator Post()\n    {\n        WWWForm form = new WWWForm();\n        //键值对\n        form.AddField(\"key\",  \"value\");\n        form.AddField(\"name\", \"Chinar\");\n        //请求链接，并将form对象发送到远程服务器\n        UnityWebRequest webRequest = UnityWebRequest.Post(\"http://www.baidu.com\", form);\n\n        yield return webRequest.SendWebRequest();\n        if (webRequest.isHttpError || webRequest.isNetworkError)\n        {\n            Debug.Log(webRequest.error);\n        }\n        else\n        {\n            Debug.Log(\"发送成功\"); \n        }\n    }\n}\n</code></pre>\n<h3>3.Put方法</h3>\n<blockquote>\n<p>Put方法将数据发送到远程的服务器。例如：文件上传</p>\n</blockquote>\n<pre><code class=\"language-cs\">using System.Collections;\nusing UnityEngine;\nusing UnityEngine.Networking;\n\n/// &lt;summary&gt;\n/// 网络请求测试\n/// &lt;/summary&gt;\npublic class ChinarWebRequest : MonoBehaviour\n{\n    void Start()\n    {\n        StartCoroutine(Upload());\n    }\n    \n    /// &lt;summary&gt;\n    /// 开启协程\n    /// &lt;/summary&gt;\n    /// &lt;returns&gt;&lt;/returns&gt;\n    IEnumerator Upload()\n    {\n        byte[] myData = System.Text.Encoding.UTF8.GetBytes(\"Chinar的测试数据\");\n        using (UnityWebRequest uwr = UnityWebRequest.Put(\"http://www.baidu.com\", myData))\n        {\n            yield return uwr.SendWebRequest();\n\n            if (uwr.isNetworkError || uwr.isHttpError)\n            {\n                Debug.Log(uwr.error);\n            }\n            else\n            {\n                Debug.Log(\"上传成功!\");\n            }\n        }\n    }\n}\n</code></pre>\n<h3>4.Abort方法</h3>\n<blockquote>\n<p>Abort方法会尽快结束联网，可以随时调用此方法。<br/> 如果 UnityWebRequest尚未完成，那么 UnityWebRequest将尽快停止上传或下载数据。</p>\n<p><span style=\"color:#fe2c24;\">中止的 UnityWebRequests被认为遇到了系统错误</span>。isNetworkError或isHttpError属性将返回true，error属性将为“User Aborted”。</p>\n</blockquote>\n<h3>5.Head方法 </h3>\n<blockquote>\n<p>Head方法与Get方法用法一致，都是传入一个URL。</p>\n<p>关于head这个方法解释推荐文章：<a class=\"link-info\" href=\"https://www.jianshu.com/p/49ebc4a78474\" title=\"https://www.jianshu.com/p/49ebc4a78474\">https://www.jianshu.com/p/49ebc4a78474</a></p>\n</blockquote>\n<p><img alt=\"\" height=\"331\" src=\"image\\bde39bb3924a4e80afcd47ec509212ad.png\" width=\"859\"/></p>\n<p>根据这个文章特点的截图 我简单聊聊Head作用 :</p>\n<p> 1.第一条就是只请求资源头部，网页的body主体是不显示的。大家可以先用get请求一个www.baidu.com查看</p>\n<p><img alt=\"\" height=\"737\" src=\"image\\71ef2ce228914a9e9e7694f499d9117b.png\" width=\"1200\"/></p>\n<p>接下来我们使用Head来请求</p>\n<p><img alt=\"\" height=\"540\" src=\"image\\b4f6d15e484145bfbcd01409c4d4b6e8.png\" width=\"1200\"/> 2.检查超链接有效性，当链接出现问题时会返回一个错误码，上方链接文章有对应错误码的中文描述。使用get、post也可以测试有效性，但是这些方式访问成功会返回body主体，所以使用head访问可以节省网络资源</p>\n<p>3.网页是否被修改，举个例子，我们将一个静态网页使用MD5加密后存入数据库，在head中加入这个html被加密后的数据进行数据库访问判断，如果这个静态网页被修改访问就会出现问题。不过这是很久之前的版本用的方法，现在基本使用的时token进行验证</p>\n<p>4.第四点就是头包含的这些信息了，例如我们需要获取安全验证信息来进心判断操作，如果使用GET、PUST等方式访问，就会连带body主体一起获取，大大浪费资源。</p>\n<p>下面是UnityWebRequest.Head的请求方式：一般与下面的GetResponseHeader方法配合使用获取文件大小的，后面断电续传中会有用到。</p>\n<pre><code class=\"language-cs\">    /// &lt;summary&gt;\n    /// 开启一个协程，发送请求\n    /// &lt;/summary&gt;\n    /// &lt;returns&gt;&lt;/returns&gt;\n    IEnumerator SendRequest()\n    {\n        UnityWebRequest uwr = UnityWebRequest.Head(\"www.baidu.com\");       //创建UnityWebRequest对象\n        yield return uwr.SendWebRequest();                                 //等待返回请求的信息\n        if (uwr.isHttpError || uwr.isNetworkError)                         //如果请求失败，或是 网络错误\n        {\n            Debug.Log(uwr.error); //打印错误原因\n        }\n        else //请求成功\n        {\n            Debug.Log(\"Head:请求成功\");\n        }\n    }</code></pre>\n<h3>6.GetResponseHeader方法</h3>\n<p>GetResponseHeader方法可以用来获取请求文件的长度 传入参数 <font face=\"monospace\">\"</font>Content-Length<font face=\"monospace\">\"</font>字符串，表示获取文件内容长度。</p>\n<pre><code class=\"language-cs\"> IEnumerator SendRequest()\n    {\n        UnityWebRequest uwr = UnityWebRequest.Head(\"www.baidu.com\"); //创建UnityWebRequest对象\n        yield return uwr.SendWebRequest();                                 //等待返回请求的信息\n        if (uwr.isHttpError || uwr.isNetworkError)                         //如果其 请求失败，或是 网络错误\n        {\n            Debug.Log(uwr.error); //打印错误原因\n        }\n        else //请求成功\n        {\n            long totalLength = long.Parse(uwr.GetResponseHeader(\"Content-Length\")); //首先拿到文件的全部长度\n            Debug.Log($\"totalLength:{totalLength}\" );//打印文件长度\n        }\n    }</code></pre>\n<h1>三、常用属性</h1>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:600px;\"><tbody><tr><td><strong>属性</strong></td><td><strong>类型</strong></td><td><strong>含义</strong></td></tr><tr><td>timeout</td><td>int</td><td>等待时间(秒)超过此数值是 <code>UnityWebReqest</code>的尝试连接将终止</td></tr><tr><td>isHttpError</td><td>bool</td><td><code>HTTP</code>响应出现出现错误</td></tr><tr><td>isNetworkError</td><td>bool</td><td>系统出现错误</td></tr><tr><td>error</td><td>string</td><td>描述 <code>UnityWebRequest</code>对象在处理<code>HTTP</code>请求或响应时遇到的任何系统错误</td></tr><tr><td>downloadProgress</td><td>float</td><td>表示从服务器下载数据的进度</td></tr><tr><td>uploadProgress</td><td>float</td><td>表示从服务器上传数据的进度</td></tr><tr><td>isDone</td><td>bool</td><td>是否完成与远程服务器的通信</td></tr><tr><td>SendWebRequest</td><td>UnityWebRequestAsyncOperation</td><td>发送信息访问</td></tr></tbody></table>\n<h1>四、案例 </h1>\n<h3>一、断点续传</h3>\n<blockquote>\n<p>记录已经下载到的本地文件大小，向资源服务器发送请求时，通过请求头实现拿到剩下需要下载的内容，然后接着下载<br/> 确保对同一个资源文件的下载操作，就不存在资源会下载错误的情况，如果你在断点续传的阶段发现资源服务器上的资源已经更新，那就得删除之前下载的文件然后重新下载。</p>\n</blockquote>\n<pre><code class=\"language-cs\">using System;\nusing System.Collections;\nusing System.IO;\nusing UnityEngine;\nusing UnityEngine.Networking;\nusing UnityEngine.UI;\n\npublic class ChinarBreakpointRenewal : MonoBehaviour\n{\n    private bool _isStop;           //是否暂停\n\n    public Slider ProgressBar;      //进度条\n    public Text SliderValue;        //滑动条值\n    public Button startBtn;        //开始按钮\n    public Button pauseBtn;        //暂停按钮\n    string Url = \"https://downsc.chinaz.net/Files/DownLoad/sound1/201808/10447.wav\";\n\n    /// &lt;summary&gt;\n    /// 初始化UI界面及给按钮绑定方法\n    /// &lt;/summary&gt;\n    void Start()\n    {\n        //初始化进度条和文本框\n        ProgressBar.value = 0;\n        SliderValue.text = \"0.0%\";\n\n        //开始、暂停按钮事件监听\n        startBtn.onClick.AddListener(OnClickStartDownload);\n        pauseBtn.onClick.AddListener(OnClickStop);\n    }\n\n\n    //开始下载按钮监听事件\n    public void OnClickStartDownload()\n    {\n        //开启协程 *注意真机上要用Application.persistentDataPath路径*\n        StartCoroutine(DownloadFile(Url, Application.streamingAssetsPath + \"/MP4/test.mp4\", CallBack));\n    }\n\n\n    /// &lt;summary&gt;\n    /// 协程：下载文件\n    /// &lt;/summary&gt;\n    /// &lt;param name=\"url\"&gt;请求的Web地址&lt;/param&gt;\n    /// &lt;param name=\"filePath\"&gt;文件保存路径&lt;/param&gt;\n    /// &lt;param name=\"callBack\"&gt;下载完成的回调函数&lt;/param&gt;\n    /// &lt;returns&gt;&lt;/returns&gt;\n    IEnumerator DownloadFile(string url, string filePath, Action callBack)\n    {\n        UnityWebRequest huwr = UnityWebRequest.Head(url); //使用Head方法可以获取到文件的全部长度\n        yield return huwr.SendWebRequest();//发送信息请求\n        //判断请求或系统是否出错\n        if (huwr.isNetworkError || huwr.isHttpError) \n        {\n            Debug.Log(huwr.error); //出现错误 输出错误信息\n        }\n        else\n        {\n            long totalLength = long.Parse(huwr.GetResponseHeader(\"Content-Length\")); //首先拿到文件的全部长度\n            string dirPath = Path.GetDirectoryName(filePath);//获取文件的上一级目录\n            if (!Directory.Exists(dirPath)) //判断路径是否存在\n            {\n                Directory.CreateDirectory(dirPath);//不存在创建\n            }\n\n            /*作用：创建一个文件流，指定路径为filePath,模式为打开或创建，访问为写入\n             * 使用using(){}方法原因： 当同一个cs引用了不同的命名空间，但这些命名控件都包括了一个相同名字的类型的时候,可以使用using关键字来创建别名，这样会使代码更简洁。注意：并不是说两个名字重复，给其中一个用了别名，另外一个就不需要用别名了，如果两个都要使用，则两个都需要用using来定义别名的\n             * using(类){} 括号中的类必须是继承了IDisposable接口才能使用否则报错\n             * 这里没有出现不同命名空间出现相同名字的类属性可以不用using(){}\n             */\n            using (FileStream fs = new FileStream(filePath, FileMode.OpenOrCreate, FileAccess.Write))\n            {\n                long nowFileLength = fs.Length; //当前文件长度,断点前已经下载的文件长度。\n                Debug.Log(fs.Length);\n                //判断当前文件是否小于要下载文件的长度，即文件是否下载完成\n                if (nowFileLength &lt; totalLength)\n                {\n                    Debug.Log(\"还没下载完成\");\n\n                    /*使用Seek方法 可以随机读写文件\n                     * Seek()  ----------有两个参数 第一参数规定文件指针以字节为单位移动的距离。第二个参数规定开始计算的位置\n                     * 第二个参数SeekOrigin 有三个值：Begin  Current   End\n                     * fs.Seek(8,SeekOrigin.Begin);表示 将文件指针从开头位置移动到文件的第8个字节\n                     * fs.Seek(8,SeekOrigin.Current);表示 将文件指针从当前位置移动到文件的第8个字节\n                     * fs.Seek(8,SeekOrigin.End);表示 将文件指针从最后位置移动到文件的第8个字节\n                     */\n                    fs.Seek(nowFileLength, SeekOrigin.Begin);  //从开头位置，移动到当前已下载的子节位置\n\n                    UnityWebRequest uwr = UnityWebRequest.Get(url); //创建UnityWebRequest对象，将Url传入\n                    uwr.SetRequestHeader(\"Range\", \"bytes=\" + nowFileLength + \"-\" + totalLength);//修改请求头从n-m之间\n                    uwr.SendWebRequest();                      //开始请求\n                    if (uwr.isNetworkError || uwr.isHttpError) //如果出错\n                    {\n                        Debug.Log(uwr.error); //输出 错误信息\n                    }\n                    else\n                    {\n                        long index = 0;     //从该索引处继续下载\n                        while (nowFileLength &lt; totalLength) //只要下载没有完成，一直执行此循环\n                        {\n                            if (_isStop) break;//如果停止跳出循环\n                            yield return null;\n                            byte[] data = uwr.downloadHandler.data;\n                            if (data != null)\n                            {\n                                long length = data.Length - index;\n                                fs.Write(data, (int)index, (int)length); //写入文件\n                                index += length;\n                                nowFileLength += length;\n                                ProgressBar.value = (float)nowFileLength / totalLength;\n                                SliderValue.text = Math.Floor((float)nowFileLength / totalLength * 100) + \"%\";\n                                if (nowFileLength &gt;= totalLength) //如果下载完成了\n                                {\n                                    ProgressBar.value = 1; //改变Slider的值\n                                    SliderValue.text = 100 + \"%\";\n                                    /*这句话的作用是：如果callBack方法不为空则执行Invoke\n                                     * 注意：\n                                     * 1.这里的Invoke可不是Unity的Invoke延迟调用的用法，参考文章：https://blog.csdn.net/liujiejieliu1234/article/details/45312141 从文章中我们可以看到，C#中的Invoke是为了防止winform中子主线程刚开始创建对象时，子线程与主线程并发修改主线程尚未创建的对象属性。\n                                     * 因为unity这里只有主线程没有用到子线程可以直接写callBack();\n                                     */\n                                    callBack?.Invoke();\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /// &lt;summary&gt;\n    /// 下载完成后的回调函数\n    /// &lt;/summary&gt;\n    void CallBack()\n    {\n        Debug.Log(\"下载完成\");\n    }\n\n    /// &lt;summary&gt;\n    /// 暂停下载\n    /// &lt;/summary&gt;\n    public void OnClickStop()\n    {\n        if (_isStop)\n        {\n            pauseBtn.GetComponentInChildren&lt;Text&gt;().text = \"暂停下载\";\n            Debug.Log(\"继续下载\");\n            _isStop = !_isStop;\n            OnClickStartDownload();\n        }\n        else\n        {\n            pauseBtn.GetComponentInChildren&lt;Text&gt;().text = \"继续下载\";\n            Debug.Log(\"暂停下载\");\n            _isStop = !_isStop;\n        }\n    }\n}\n</code></pre>\n<p>如果以上有什么不对，或者可以优化的地方欢迎大家指正，感谢。</p>\n</div>\n</div>"}