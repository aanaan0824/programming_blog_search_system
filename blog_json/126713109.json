{"blogid": "126713109", "writerAge": "码龄6年", "writerBlogNum": "167", "writerCollect": "157", "writerComment": "19", "writerFan": "49", "writerGrade": "5级", "writerIntegral": "2071", "writerName": "小甄笔记", "writerProfileAdress": "writer_image\\profile_126713109.jpg", "writerRankTotal": "10210", "writerRankWeekly": "16609", "writerThumb": "33", "writerVisitNum": "134668", "blog_read_count": "79", "blog_time": "于 2022-09-05 21:40:42 发布", "blog_title": "自定义注解使用", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h2>注解介绍</h2>\n<p>它提供了一种安全的类似注释的机制，用来将任何的信息或<a href=\"https://so.csdn.net/so/search?q=%E5%85%83%E6%95%B0%E6%8D%AE&amp;spm=1001.2101.3001.7020\" title=\"元数据\">元数据</a>（metadata）与程序元素（类、方法、成员变量等）进行关联。为程序的元素（类、方法、成员变量）加上更直观、更明了的说明，这些说明信息是与程序的业务逻辑无关，并且供指定的工具或框架使用。Annontation像一种修饰符一样，应用于包、类型、构造方法、方法、成员变量、参数及本地变量的声明语句中</p>\n<p>注解本质是一个继承了Annotation 的特殊接口，其具体实现类是Java 运行时生成的动态代理类。而我们通过反射获取注解时，返回的是Java 运行时生成的动态代理对象$Proxy1。通过代理对象调用自定义注解（接口）的方法，会最终调用AnnotationInvocationHandler 的invoke 方法 </p>\n<h2>元注解</h2>\n<p>所有元注解定义在java.lang.annotation包下面，其中Annotation是注解的基本接口，<strong>所有的注解都继承这个接口</strong></p>\n<p><img alt=\"\" height=\"306\" src=\"image\\2e1cff8854334b6c8ba6650aa6335667.png\" width=\"369\"/></p>\n<p> java.lang.annotation 提供了四种元注解，专门注解其他的注解（在自定义注解的时候，需要使用到元注解）</p>\n<p><strong>1、@Documented</strong>：指定被标注的注解会包含在javadoc中</p>\n<p><strong>2、@Retention</strong>： 指定注解的生命周期（源码、class文件、运行时），其参考值见类的定义：java.lang.annotation.RetentionPolicy</p>\n<blockquote>\n<p>RetentionPolicy<strong>.SOURCE</strong> : 在编译阶段丢弃。这些注解在编译结束之后就不再有任何意义，所以它们不会写入字节码。@Override, @SuppressWarnings都属于这类注解。<br/> RetentionPolicy<strong>.CLASS</strong> : 在类加载的时候丢弃。在字节码文件的处理中有用。注解默认使用这种方式。<br/> RetentionPolicy<strong>.RUNTIME</strong> : 始终不会丢弃，运行期也保留该注解，因此可以使用反射机制读取该注解的信息。<strong>我们自定义的注解通常使用这种方式</strong>。 </p>\n</blockquote>\n<p><strong>3、@Target</strong>：指定注解使用的目标范围（类、方法、字段等），其参考值见类的定义：java.lang.annotation.ElementTyp</p>\n<blockquote>\n<p>ElementType.<strong>CONSTRUCTOR ：</strong>用于描述构造器。</p>\n<p>ElementType.<strong>FIELD ：</strong>成员变量、对象、属性（包括enum实例）。<br/> ElementType.<strong>LOCAL_VARIABLE</strong>: 用于描述局部变量。<br/> ElementType.<strong>METHOD ：</strong> 用于描述方法。<br/> ElementType.<strong>PACKAGE ：</strong>用于描述包。<br/> ElementType.<strong>PARAMETER </strong>：用于描述参数。<br/> ElementType.<strong>ANNOTATION_TYPE</strong>：用于描述参数<br/> ElementType.<strong>TYPE ：</strong>用于描述类、接口(包括注解类型) 或enum声明。</p>\n</blockquote>\n<p><strong> 4、@Inherited</strong>：指定子类可以继承父类的注解，只能是类上的注解，方法和字段的注解不能继承。即如果父类上的注解是@Inherited修饰的就能被子类继承</p>\n<h2><strong>注解处理器类库</strong> </h2>\n<p>AnnotatedElement 接口是所有程序元素（Class、Method和Constructor）的父接口，所以程序通过反射获取了某个类的AnnotatedElement对象之后，程序就可以调用该对象的如下方法来访问Annotation信息：</p>\n<p>　　<strong>方法1：</strong>&lt;T extends Annotation&gt;  T  <strong>getAnnotation</strong>(Class&lt;T&gt; annotationClass): 返回改程序元素上存在的、指定类型的注解，如果该类型注解不存在，则返回null。<br/> 　　<strong>方法2：</strong>Annotation[]  <strong>getAnnotations()</strong>:返回该程序元素上存在的所有注解。<br/> 　　<strong>方法3：</strong>boolean  <strong>isAnnotationPresent</strong>(Class&lt;?extends Annotation&gt; annotationClass):判断该程序元素上是否包含指定类型的注解，存在则返回true，否则返回false.<br/> 　　<strong>方法4：</strong>Annotation[]  <strong>getDeclaredAnnotations(</strong>Class&lt;T&gt; annotationClass<strong>)</strong>：返回直接存在于此元素上的所有注释。与此接口中的其他方法不同，该方法将忽略继承的注释。（如果没有注释直接存在于此元素上，则返回长度为零的一个数组。）该方法的调用者可以随意修改返回的数组；这不会对其他调用者返回的数组产生任何影响</p>\n<p>代码案例：</p>\n<pre><code class=\"language-java\">public &lt;T extends Serializable&gt; List&lt;LogSystem&gt; generateLog(T target) {\n\tClass&lt;? extends Serializable&gt; clz = target.getClass();\n\tField[] fields = clz.getDeclaredFields();\n\tMethod[] methods = clz.getMethods();\n\tSystemLogging clzAnnotation = null;\n\t// 类上是否有标注了@systemlogging注解\n\tif(clz.isAnnotationPresent(SystemLogging.class)){\n\t}\n\tfor (Method method : methods) {\n\t\t// 方法上是否标注了@systemlogging注解\n\t\tif(method.isAnnotationPresent(SystemLogging.class)){\n\t\t}\n\t}\n\tfor(Field field : fields){\n\t\t// 属性上是否有标注了@systemlogging注解\n\t\tif(field.isAnnotationPresent(SystemLogging.class)){\n\t\t}\n        // 获取属性上指定注解的内容，不存在返回null\n        SystemLogging systemLogging = field.getAnnotation(SystemLogging.class);\n\t}\n}</code></pre>\n<h2>自定义注解</h2>\n<ul><li>Annotation 类型定义为<strong>@interface</strong>, 所有的Annotation 会自动继承java.lang.Annotation这一接口,并且不能再去继承别的类或是接口。</li><li>  参数成员只能用public 或默认(default) 这两个访问权修饰。<strong>语法：类型  属性名()  [default 默认值];      default表示默认值 ，也可以不编写默认值的.</strong></li><li>  参数成员只能用基本类型byte、short、char、int、long、float、double、boolean八种基本数据类型和String、Enum、Class、annotations等数据类型，以及这一些类型的数组.</li><li>  要获取类方法和字段的注解信息，必须通过Java的反射技术来获取 Annotation 对象，因为你除此之外没有别的获取注解对象的方法。</li><li>  注解也可以没有定义成员,，不过这样注解就没啥用了</li></ul>\n<p>代码案例</p>\n<pre><code class=\"language-java\">@Target({ElementType.FIELD, ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface SystemLogging {\n    String[] keys() default {};\n\n    String value() default \"\";\n\n    String secondValue() default \"\";\n\n    String keyName() default \"字段\";\n\n    Class&lt;? extends KeyEnums&gt;[] keyEnum() default {};\n\n    boolean deleted() default false;\n}</code></pre>\n<p>springboot中的自定义注解类</p>\n<p><img alt=\"\" height=\"365\" src=\"image\\b9b78c8c3a594f78a325826464d51dff.png\" width=\"999\"/></p>\n<p>springboot扩展注解：<a href=\"https://blog.csdn.net/pengjunlee/article/details/79700127?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control\" title=\"SpringBoot重点详解--@Conditional注解_pengjunlee的博客-CSDN博客\">SpringBoot重点详解--@Conditional注解_pengjunlee的博客-CSDN博客</a></p>\n<p></p>\n<p></p>\n</div>\n</div>"}