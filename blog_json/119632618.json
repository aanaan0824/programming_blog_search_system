{"blogid": "119632618", "writerAge": "码龄6年", "writerBlogNum": "227", "writerCollect": "6419", "writerComment": "199", "writerFan": "2765", "writerGrade": "6级", "writerIntegral": "8272", "writerName": "herryone123", "writerProfileAdress": "writer_image\\profile_119632618.jpg", "writerRankTotal": "1592", "writerRankWeekly": "6190", "writerThumb": "1169", "writerVisitNum": "987845", "blog_read_count": "7252", "blog_time": "已于 2022-08-30 20:27:35 修改", "blog_title": "C++创建型模式-工厂模式", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h1>一、简单工厂模式</h1>\n<h2>1.1 简单工厂模式</h2>\n<p>简单工厂模式（Simple Factory Pattern）专门定义<strong>一个类来负责创建其他类的实例，被创建的实例通常具有共同的父类。</strong></p>\n<p>简单工厂模式，是一种实例化对象的方式，只要输入需要实例化对象的名字，就可以通过工厂对象的相应工厂函数来制造你需要的对象。</p>\n<h2>1.2 简单工厂模式的角色</h2>\n<p>（1）Factory工厂角色（工厂类）：</p>\n<p>工厂角色即工厂类，是简单工厂模式的核心，负责创建所有实例的内部逻辑，工厂类可以被外界直接调用，创建所需要的产品对象。</p>\n<p>（2）Product（抽象产品角色）：</p>\n<p>抽象产品角色是简单工厂模式所创建的所有对象的父类，负责描述所有实例所共有的公告接口。所创建的具体产品对象都是其子类对象。</p>\n<p>（3）ConcreteProduct（具体产品角色）：</p>\n<p>具体产品角色是简单工厂模式的创建目标。每个具体产品角色都继承了抽象产品角色，需要实现定义在抽象产品中的方法。</p>\n<p></p>\n<p>ProductA、ProductB和ProductC继承自Product虚拟类，Show方法是不同产品的自描述；Factory依赖于ProductA、ProductB和ProductC，Factory根据不同的条件创建不同的Product对象</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\20210816083201361.png\"/></p>\n<p> 依赖关系：箭头指向被依赖的一方</p>\n<p>继承关系：</p>\n<h2> 1.3 简单工厂模式的应用</h2>\n<p>在程序中，需要创建的对象很多，导致对象的new操作多且杂时，需要使用简单工厂模式；<br/> 由于对象的创建过程是我们不需要去关心的，而我们注重的是对象的实际操作，所以，我们需要分离对象的创建和操作两部分，如此，方便后期的程序扩展和维护。</p>\n<h2>1.4 简单工厂模式的优缺点</h2>\n<p>优点：</p>\n<p>本着高内聚低耦合的原则，将系统的逻辑部分和功能分开。</p>\n<p>缺点：</p>\n<ul><li>简单工厂模式会增加系统类的个数，在一定程度上增加了系统的复杂度和理解难度；</li><li>系统扩展难，一旦增加新产品，就需要修改工厂逻辑，不利于系统的扩展与维护；简单工厂模式中所有<strong>产品的创建都是由同一个工厂创建，工厂类职责较重，业务逻辑较为复杂，具体产品与工厂类之间耦合度高，严重影响了系统的灵活性和扩展性</strong>。</li></ul>\n<h2>1.5 简单工厂模式实现</h2>\n<p>某电视机厂为各个品牌代工生产电视机，可以使用简单工厂的模式来实现。</p>\n<p><img alt=\"\" height=\"391\" src=\"image\\211e07ace21747aa8a1583b313f1ec62.png\" width=\"758\"/></p>\n<p></p>\n<p></p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n  \ntypedef enum ProductTypeTag\n{\n  Hair,\n  Hisense,\n}PRODUCTTYPE;\n  \n//抽象产品类 TV(电视机类)\nclass TV\n{\npublic:\n  virtual void Show() = 0;\n  virtual ~TV(){};//声明析构函数为虚函数，防止内存泄漏\n};\n //具体产品类 HairTV(海尔电视类)\nclass HairTV : public TV\n{\npublic:\n  void Show()\n  {\n    cout&lt;&lt;\"I'm HairTV \"&lt;&lt;endl;\n  }\n};\n //具体产品类 HisenseTV(海信电视类)  \nclass  HisenseTV : public TV\n{\npublic:\n  void Show()\n  {\n    cout&lt;&lt;\"I'm HisenseTV\"&lt;&lt;endl;\n  }\n};\n  \n\n// 工厂类 TVFactory(电视机工厂类)\nclass TVFactory\n{\npublic:\n  TV* CreateTV(PRODUCTTYPE type)\n  {\n    switch (type)\n    {\n    case Hair:\n      return new HairTV();\n  \n    case Hisense:\n      return new HisenseTV();\n    default:\n      return NULL;\n    }\n  }\n};\n  \nint main(int argc, char *argv[])\n{\n    // 创建工厂类对象\n    TVFactory* myTVFactory = new  TVFactory();\n    TV* hairTV = myTVFactory-&gt;CreateTV(Hair);\n    if (hairTV != NULL)\n        hairTV-&gt;Show();\n\n    TV* hisenseTV = myTVFactory-&gt;CreateTV(Hisense);\n    if (hisenseTV != NULL)\n        hisenseTV-&gt;Show();\n\n    delete  myTVFactory;\n    myTVFactory = NULL;\n\n    delete hairTV;\n    hairTV = NULL;\n\n    delete hisenseTV;\n    hisenseTV = NULL;  \n  \n    return 0;\n}</code></pre>\n<p>调试结果：</p>\n<p><img alt=\"\" height=\"84\" src=\"image\\1a63dd8ef8ae46caaa96f1046bc5900d.png\" width=\"208\"/></p>\n<p></p>\n<p>TVFactory 是工厂类，它是整个系统的核心，提供了静态工厂方法CreateTV（），该方法中包含一个字符串类型的参数，在内部业务逻辑中根据参数值得不同实例化不同的具体产品类，返回相依的对象。<span style=\"color:#fe2c24;\">简单工厂模式的缺点是 如增加 生成TCL电视时，需要修改工厂类TVFactory</span>。 </p>\n<p>小结：</p>\n<p>在程序中，需要创建的对象很多，导致对象的new操作多且杂时，需要使用简单工厂模式。</p>\n<h1>二、工厂方法模式</h1>\n<h2>2.1 工厂方法简介</h2>\n<p>简单工厂模式中<strong>最大的缺点是当有新产品要加入系统时，必须要修改工厂类，加入必要的处理逻辑，违背了“开闭原则”</strong>。</p>\n<p>工厂方法模式定义：在工厂模式中，<span style=\"color:#4da8ee;\">工厂父类负责定义创建产品对象的公告接口，而工厂子类负责生成具体的产品对象</span>。<strong>目的是将产品的实例化操作延迟到工厂子类中完成</strong>，通过工厂子类来确定究竟应该实例化哪一个具体产品类。</p>\n<h2>2.2 模式结构</h2>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\20210817084741848.png\"/></p>\n<p> （1）Product （抽象产品）</p>\n<p>抽象产品是定义产品的接口，是工厂方法模式所创建对象的超类型，也是产品对象的共同父类或接口。</p>\n<p>（2）ConcreteProduct（具体产品）</p>\n<p>具体产品实现了抽象产品的接口，某种类型的具体产品由专门的具体工厂创建。</p>\n<p>（3）Factory(抽象工厂)</p>\n<p>（4）ConcreteFactory（具体工厂）</p>\n<p>具体工厂是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可由客户调用，返回一个具体产品类的实例。</p>\n<p></p>\n<h2>2.3 应用    </h2>\n<p>工厂方法模式的意义是定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类当中。核心工厂类不再负责产品的创建，这样核心类成为一个抽象工厂角色，仅负责具体工厂子类必须实现的接口，这样进一步抽象化的好处是使得工厂方法模式可以<span style=\"color:#4da8ee;\">使系统在不修改具体工厂角色的情况下引进新的产品</span>。</p>\n<p>1.在设计的初期，就考虑到产品在后期会进行扩展的情况下，可以使用工厂方法模式；</p>\n<p>2.产品结构较复杂的情况下，可以使用工厂方法模式；</p>\n<p>                                                                                                                                                        </p>\n<h2>2.4 优缺点</h2>\n<p>优点：系统的扩展性好，符合“开闭原则”  。系统加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品即可。</p>\n<p>缺点：在添加新产品时，需要编写新的具体产品类，而且要提供与之对应的具体工厂类，系统中类的个数将成对增加，一定程度上增加了系统的复杂度。</p>\n<h2>2.5 举例</h2>\n<p>简单工厂模式，通过一个电视机代工厂来生产电视机，当需要增加新的品牌的电视机时不得不修该工厂类中的工厂方法，违反了“开闭原则”。</p>\n<p>工厂方法模式，将原有的工厂进行分割，<span style=\"color:#4da8ee;\">为每种品牌的电视机提供一个子工厂，海尔工厂专门负责生产海尔电视机，海信工厂专门负责生产海信电视机，若增加TCL电视，只需要增加一个新的TCL工厂。</span></p>\n<p><img alt=\"\" height=\"317\" src=\"image\\aeaea1cff5dd47b5aaaf4d970b925aa1.png\" width=\"1200\"/></p>\n<p></p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\nusing namespace std;\n /*抽象产品类 TV(电视机类)*/ \nclass TV\n{\npublic:\n  virtual void Show() = 0;\n virtual ~TV();//声明析构函数为虚函数，防止内存泄漏\n};\n /*具体产品类 HairTV(海尔电视机类)*/ \nclass HairTV : public TV\n{\npublic:\n  void Show()\n  {\n    cout&lt;&lt; \"I'm HairTV\"&lt;&lt;endl;\n  }\n};\n/*具体产品类 HisenseTV(海信电视机类)*/\nclass HisenseTV : public TV\n{\npublic:\n  void Show()\n  {\n    cout&lt;&lt; \"I'm HisenseTV\"&lt;&lt;endl;\n  }\n};\n/*工厂类(电视机工厂类)*/  \nclass TVFactory\n{\npublic:\n  virtual TV *CreateTV() = 0;\n   virtual ~TVFactory(){};//析构函数声明为虚函数，防止内存泄漏\n};\n /*具体工厂类 HairTVFactory(海尔电视机工厂类)*/ \nclass HairTVFactory : public TVFactory\n{\npublic:\n  TV *CreateTV()\n  {\n    return new HairTV ();\n  }\n};\n /*具体工厂类 HisenseTV(海信电视机工厂类)*/ \nclass HisenseTVFactory : public TVFactory\n{\npublic:\n  TV *CreateTV()\n  {\n    return new HisenseTV ();\n  }\n};\n  \nint main(int argc , char *argv [])\n{\n  TVFactory *hairTVFactory = new HairTVFactory();\n  TV *hairTV = hairTVFactory-&gt;CreateTV();\n  hairTV-&gt;Show();\n  \n  TVFactory *hisenseTVFactory = new HisenseTVFactory();\n  TV *hisenseTV = hisenseTVFactory-&gt;CreateTV();\n  hisenseTV-&gt;Show();\n  \n  if (hairTVFactory!= NULL)\n  {\n    delete hairTVFactory;\n    hairTVFactory = NULL;\n  }\n  \n  if (hairTV != NULL)\n  {\n    delete hairTV;\n    hairTV = NULL;\n  }\n  \n  if (hisenseTVFactory != NULL)\n  {\n    delete hisenseTVFactory;\n    hisenseTVFactory = NULL;\n  }\n  \n  if (hisenseTV != NULL)\n  {\n    delete hisenseTV;\n    hisenseTV = NULL;\n  }\n  return 0;\n}\n\n</code></pre>\n<p>运行结果：</p>\n<p><img alt=\"\" height=\"92\" src=\"image\\4e924000558c46c2996437c0f7be001c.png\" width=\"193\"/></p>\n<p></p>\n<h2>三、抽象工厂模式</h2>\n<h2>3.1 抽象工厂模式</h2>\n<p>抽象工厂模式是工厂方法模式的泛化版，工厂模式是一种特殊的抽象工厂模式，<span style=\"color:#fe2c24;\">在工厂模式中，每个具体工厂只能生产一种具体的产品</span>，如海尔电视机厂只生产海尔电视机，而抽象工厂方法模式中，一个具体的工厂可以生产多个具体产品。</p>\n<h2>3.2 模式角色</h2>\n<p>产品等级结构与产品族：</p>\n<p>产品等级结构：</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\20210819084940528.png\"/></p>\n<p> （1）AbstractFactory（抽象工厂）</p>\n<p>抽象工厂用于声明生成抽象产品的方法，<span style=\"color:#38d8f0;\">在一个抽象工厂中可以定义一组方法，每一个方法对应一个产品等级结构。</span></p>\n<p>（2）ConcreteFactory  （具体工厂）</p>\n<p>具体工厂实现了抽象工厂声明的抽象产品的方法，生成一组具体产品</p>\n<p>（3）AbstractProduct （抽象产品）</p>\n<p>抽象产品为每种产品声明接口，在抽象产品中定义了产品的抽象业务方法。</p>\n<p>（4）ConcreteProdunct （具体产品）</p>\n<p>具体产品定义具体工厂生产的具体产品对象，实现抽象产品接口中定义的业务方法。</p>\n<p></p>\n<h2> 3.3 应用</h2>\n<p>当需要创建的对象是一系列相互关联或相互依赖的产品族时，便可以使用抽象工厂模式。说的更明白一点，就是一个继承体系中，如果存在着多个等级结构（即存在着多个抽象类），并且分属各个等级结构中的实现类之间存在着一定的关联或者约束，就可以使用抽象工厂模式。假如各个等级结构中的实现类之间不存在关联或约束，则使用多个独立的工厂来对产品进行创建，则更合适一点。</p>\n<ol><li>适合于产品之间相互关联、相互依赖且相互约束的地方</li><li>需要动态切换产品族的地方</li></ol>\n<h2>3.4 优缺点</h2>\n<p><strong>优点：</strong></p>\n<ol><li>抽象工厂模式将产品族的依赖与约束关系放到抽象工厂中，便于管理。</li><li>职责解耦，用户不需要关心一堆自己不关心的细节，由抽象工厂来负责组件的创建</li><li>切换产品族容易，只需要增加一个具体工厂实现，客户端选择另一个套餐就可以了</li></ol>\n<p><strong>缺点：</strong></p>\n<ol><li>抽象工厂模式类增加的速度很快，有一个产品族就需要增加一个具体工厂实现，比较繁琐</li><li>产品族难以扩展产品。当产品族中增加一个产品时，抽象工厂接口中需要增加一个函数，对应的所有具体工厂实现都需要修改，修改放大严重。</li><li>抽象工厂并未完全屏蔽创建细节，给出的都是组件。对于这种情况可以结合工厂模式或简单工厂模式一起使用。</li></ol>\n<h2>3.5 举例</h2>\n<p>如一个电器工厂可以生产多种类型的电器，如海尔工厂可以生产海尔电视机、海尔空调等，TCL工厂可以生产TCL电视、TCL空调等。<span style=\"color:#ff9900;\">相同品牌的电器构成一个产品族，而相同类型的电器构成了一个产品等级结构。</span></p>\n<p><img alt=\"\" height=\"706\" src=\"image\\d178bce2957d4ee997e117a091ab185b.png\" width=\"1200\"/></p>\n<p></p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\nusing namespace std;\n  \n// 抽象产品类类 Television(电视机类)\nclass Television\n{\npublic:\n    virtual void Show() = 0;\n    virtual ~Television(){};//析构函数声明为虚函数，防止内存泄漏\n};\n\n//具体产品类 HaierTelevision（海尔电视机类）\nclass HaierTelevision : public Television\n{\npublic:\n    void Show()\n    {\n        cout &lt;&lt; \"I'm HaierTelevision\" &lt;&lt; endl;\n    }\n};\n//具体产品类 TCLTelevision（TCL电视机类）\nclass TCLTelevision : public Television\n{\npublic:\n    void Show()\n    {\n        cout &lt;&lt; \"I'm TCLTelevision\" &lt;&lt; endl;\n    }\n};\n\n// 抽象产品类  AirCondition（空调类）\nclass AirCondition\n{\npublic:\n    virtual void Show() = 0;\n    virtual ~AirCondition(){};//析构函数声明为虚函数，防止内存泄漏\n};\n//具体产品类 HairAirCondition(海尔空调类)\nclass HairAirCondition : public AirCondition\n{\npublic:\n    void Show()\n    {\n        cout &lt;&lt; \"I'm HairAirCondition\" &lt;&lt; endl;\n    }\n};\n//具体产品类 TCLAirCondition(TCL空调类)\nclass TCLAirCondition : public AirCondition\n{\npublic:\n    void Show()\n    {\n        cout &lt;&lt; \"I'm TCLAirCondition\" &lt;&lt; endl;\n    }\n};\n\n// 抽象工厂类 EFactory(电器工厂类)\nclass EFactory\n{\npublic:\n    virtual Television* CreateTelevision() = 0;\n    virtual AirCondition* CreateAirCondition() = 0;\n     virtual ~EFactory(){};//析构函数声明为虚函数，防止内存泄漏\n};\n//具体工厂类 HairFactory(海尔工厂类)\nclass HairFactory : public EFactory\n{\npublic:\n    Television* CreateTelevision()\n    {\n        return new HaierTelevision();\n    }\n\n    AirCondition* CreateAirCondition()\n    {\n        return new HairAirCondition();\n    }\n};\n//具体工厂类 TCLFactory(TCL工厂类) \nclass TCLFactory : public EFactory\n{\npublic:\n    Television* CreateTelevision()\n    {\n        return new TCLTelevision();\n    }\n\n    AirCondition* CreateAirCondition()\n    {\n        return new TCLAirCondition();\n    }\n};\n  \nint main(int argc, char *argv[])\n{\n  EFactory *hairFactory = new HairFactory ();/*实例化工厂抽象类*/\n  Television *haierTelevision =hairFactory-&gt;CreateTelevision();/*实例化产品抽象类*/\n  AirCondition *haierAirCondition = hairFactory-&gt;CreateAirCondition();\n  \n  haierTelevision-&gt;Show();\n  haierAirCondition-&gt;Show();\n  \n  EFactory *tCLFactory = new TCLFactory ();\n  Television *tCLTelevision = tCLFactory-&gt;CreateTelevision();\n  AirCondition *tCLAirCondition = tCLFactory-&gt;CreateAirCondition();\n  \n  tCLTelevision-&gt;Show();\n  tCLAirCondition-&gt;Show();\n  \n  if (hairFactory != NULL)\n  {\n    delete hairFactory;\n    hairFactory = NULL;\n  }\n  \n  if (haierTelevision != NULL)\n  {\n    delete haierTelevision;\n    haierTelevision= NULL;\n  }\n  \n  if (tCLAirCondition != NULL)\n  {\n    delete tCLAirCondition;\n    tCLAirCondition = NULL;\n  }\n  \n  if (tCLFactory != NULL)\n  {\n    delete tCLFactory;\n    tCLFactory= NULL;\n  }\n  \n  if (tCLTelevision != NULL)\n  {\n    delete tCLTelevision;\n    tCLTelevision = NULL;\n  }\n  \n  if (tCLAirCondition != NULL)\n  {\n    delete tCLAirCondition;\n    tCLAirCondition = NULL;\n  }\n}</code></pre>\n<p>运行结果：</p>\n<p><img alt=\"\" height=\"120\" src=\"image\\5a652c1f3a9d425e8bcf300772e3d987.png\" width=\"277\"/></p>\n<p></p>\n<h1>四、总结</h1>\n<ol><li>大家应该已经发现了，其实抽象工厂模式如果只有一个组件的话，其实是退化到了工厂方法模式，也就是没有了产品族的概念，只剩一个产品了，因此简单工厂，工厂方法，抽象工厂这三者之间是有内在联系的，区别只是产品的复杂度。</li><li>抽象工厂的本质是选择产品族，因此大家可以根据这个特征来识别是否可以应用抽象工厂。</li></ol>\n<p>简单工厂：唯一工厂类，一个产品抽象类，工厂类的创建方法依据入参判断并创建具体产品对象。<br/> 工厂方法：多个工厂类，一个产品抽象类，利用多态创建不同的产品对象，避免了大量的if-else判断。<br/> 抽象工厂：多个工厂类，多个产品抽象类，产品子类分组，同一个工厂实现类创建同组中的不同产品，减少了工厂子类的数量。<br/>  </p>\n<p> </p>\n<p></p>\n<p></p>\n<p>参考文献：</p>\n<p>【1】<a href=\"https://www.cnblogs.com/huiz/p/8232783.html\" id=\"cb_post_title_url\" title=\"工厂模式（C++实现）\">工厂模式（C++实现）</a>：<a href=\"https://www.cnblogs.com/huiz/p/8232783.html\" title=\"工厂模式（C++实现） - 1点er执着 - 博客园\">工厂模式（C++实现） - 1点er执着 - 博客园</a></p>\n<p>【2】设计模式之简单工厂，工厂方法模式（c++）：<a href=\"https://blog.csdn.net/u012219045/article/details/60467306\" title=\"设计模式之简单工厂，工厂方法模式（c++）_u012219045的专栏-CSDN博客_c++ 工厂方法模式\">设计模式之简单工厂，工厂方法模式（c++）_u012219045的专栏-CSDN博客_c++ 工厂方法模式</a></p>\n<p>【3】<a href=\"https://www.cnblogs.com/jostree/p/4251756.html\" title=\"C++实现设计模式之 — 简单工厂模式\">C++实现设计模式之 — 简单工厂模式</a>：<a href=\"https://www.cnblogs.com/jostree/p/4251756.html\" title=\"C++实现设计模式之 — 简单工厂模式 - jostree - 博客园\">C++实现设计模式之 — 简单工厂模式 - jostree - 博客园</a></p>\n<p>【4】 C++设计模式之简单工厂模式实例：<a href=\"https://www.jb51.net/article/55858.htm\" title=\"https://www.jb51.net/article/55858.htm\">https://www.jb51.net/article/55858.htm</a></p>\n<p>【5】C++设计模式之工厂方法模式：<a href=\"https://www.jb51.net/article/55860.htm\" title=\"https://www.jb51.net/article/55860.htm\">https://www.jb51.net/article/55860.htm</a></p>\n<p>【6】C++设计模式之抽象工厂模式：<a href=\"https://www.jb51.net/article/55861.htm\" title=\"https://www.jb51.net/article/55861.htm\">https://www.jb51.net/article/55861.htm</a></p>\n<p>【7】抽象工厂模式和工厂模式的区别: <a href=\"https://www.zhihu.com/question/20367734\" title=\"抽象工厂模式和工厂模式的区别？ - 知乎\">抽象工厂模式和工厂模式的区别？ - 知乎</a></p>\n<p>【8】抽象工厂模式应用场景(24种设计模式优缺点)：<a href=\"https://www.haitaoseo.com/960718.html\" title=\"https://www.haitaoseo.com/960718.html\">https://www.haitaoseo.com/960718.html</a></p>\n</div>\n</div>"}