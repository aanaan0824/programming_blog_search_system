{"blogid": "125246751", "writerAge": "码龄3年", "writerBlogNum": "75", "writerCollect": "63", "writerComment": "4", "writerFan": "29", "writerGrade": "3级", "writerIntegral": "765", "writerName": "·~简单就好", "writerProfileAdress": "writer_image\\profile_125246751.jpg", "writerRankTotal": "24809", "writerRankWeekly": "8885", "writerThumb": "11", "writerVisitNum": "26739", "blog_read_count": "4354", "blog_time": "已于 2022-06-12 16:37:00 修改", "blog_title": "mysql事务（详解）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h1><a id=\"Mysql_0\"></a>Mysql事务</h1>\n<h2><a id=\"_2\"></a><strong>一、事务存在的意义</strong></h2>\n<h3><a id=\"1_4\"></a>1、事务定义</h3>\n<ul><li>事务：事务是一个最小的不可在分的工作单元；通常一个事务对应一个完整的业务(例如银行账户转账业务，该业务是一个最小的工作单元)</li><li>一个完整的业务需要批量的DML(insert、update、delete)语句共同联合完成。</li><li>事务只和DML语句有关，或者说DML语句才有事务。这个和业务逻辑有关，业务逻辑不同，DML语句的个数不同。</li></ul>\n<h3><a id=\"2_10\"></a><strong>2.事务是什么？</strong></h3>\n<p>多个操作同时进行,那么同时成功，那么同时失败。这就是事务。</p>\n<p><strong>事务有四个特性：一致性、持久性、原子性、隔离性</strong></p>\n<p><strong>比如有一个订单业务</strong></p>\n<p>1.订单表当中添加一条记录 2.商品数量数据更新(减少) 3…</p>\n<p>当多个任务同时进行操作的时候，这些任务只能同时成功，或者同时失败。</p>\n<p><strong>3.Mybatis关于事务的管理</strong></p>\n<p>MyBatis框架中的事务默认是手动提交的，也就是每次编写程序都需要调用commit()方法提交事务</p>\n<pre><code class=\"prism language-java\"><span class=\"token operator\">&lt;</span>transactionManager type<span class=\"token operator\">=</span><span class=\"token string\">\"JDBC\"</span><span class=\"token operator\">&gt;</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>transactionManager<span class=\"token operator\">&gt;</span>  <span class=\"token operator\">==</span><span class=\"token operator\">==</span>》程序员自己控制处理的提交和回滚\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\829265f2a539496d972ec093323453f1.png\"/></p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\c28bd966c929424296f6823f1ef3dbd2.png\"/></p>\n<h2><a id=\"_36\"></a>二、事务的四大性质</h2>\n<ol><li> <p>原子性：事务是一个不可分割的工作单位，要么同时成功，要么同时失败。例：当两个人发起转账业务时，如果A转账发起，而B因为一些原因不能成功接受，事务最终将不会提交，则A和B的请求最终不会成功。</p> </li><li> <p>持久性：一旦事务提交，他对数据库的改变就是永久的。<strong>注</strong>：只要提交了事务，将会对数据库的数据进行永久性刷新。</p> </li><li> <p>隔离性：多个事务之间相互隔离的，互不干扰</p> </li><li> <p>一致性：事务执行接收之后，数据库完整性不被破坏</p> <p>注意：只有当前三条性质都满足了，才能保证事务的一致性</p> </li></ol>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\2f0798cbce574f478c9f03ac813fff55.png\"/></p>\n<p><strong>刷脏</strong>：Mysql为了保证存储效率，于是每次将要读写的文件是先存储在缓存池中，对于数据的操作是在缓存池中，而mysql将会定期的刷新到磁盘中。</p>\n<p><strong>1、如何保证原子性：</strong></p>\n<p>​ 首先：对于A和B两操作要操作成功就一定需要更改到表的信息，如果如图所示A语句操作成功，而B语句操作时出现断电等其他情况终止了操作，所以此时两个事务没有操作成功，在没有提交事务之前，mysql会先记录跟新前的数据到undo log日志里面，当最终的因为操作不成功而发生事务回滚时，会从undo log日志里面先前存好的数据，重新对数据库的数据进行数据的回退。</p>\n<p>​ <strong>undo log日志</strong>：（撤销回退的日志）主要存储数据库更新之前的数据，用于作备份</p>\n<p><strong>2、如何保证事务的持久性：</strong></p>\n<p>通过重做日志：<strong>redo log日志</strong>，对于用户将对发生了修改而为提交的数据存入了redo log日志中，当此时发生断电等其他异常时，可以根据redo log日志重新对数据做一个提交，做一个恢复。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\e9263317bc3a4554b839a4efefbcf60d.png\"/></p>\n<p>3、隔离性：</p>\n<h3><a id=\"1_69\"></a>1事务的并发问题：</h3>\n<h4><a id=\"1_71\"></a>1、脏读（读未提交）</h4>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\0e5ac64c906c4d13b6dbdecda01b5910.png\"/></p>\n<p>(1)、脏读：事务A读取到了事务已经修改但未提交的数据，这种数据就叫脏数据，是不正确的</p>\n<h4><a id=\"2_78\"></a>2、读已提交：（不可重复读）</h4>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\2b755a18343a4122a434c5d955804492.png\"/></p>\n<p>不可重复读：对于事务A多次读取同一个数据时，由于其他是事务也在访问这个数据，进行修改且提交，对于事务A，读取同一个数据时，有可能导致数据不一致，叫不可重复读</p>\n<h4><a id=\"3_85\"></a>3、可重复读：（幻读）</h4>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\86be832bbeb348ea8b736e6331ec58c0.png\"/></p>\n<p>幻读：原因：因为mysql数据库读取数据时，是将数据放入缓存中，当事务B对数据库进行操作：例如删除所有数据且提交时，事务A同样能访问到数据，这就产生了幻读。<br/> 问题：解决了可重复读，但是会产生一种问题，错误的读取数据，对于其他事务添加的数据也将访问不到</p>\n<h4><a id=\"4_93\"></a>4、串行化</h4>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\03fed1e189d940fb912068ca894f4f6e.png\"/></p>\n<p><strong>串行化</strong>：事务A和事务B同时访问时，在事务A修改了数据，而没有提交数据时，此时事务B想增加或修改数据时，只能等待事务A的提交，事务B才能够执行。</p>\n<p>**问题：**用户的体验十分的差，因为每次访问时都要等待其他事务的提交才能操作</p>\n<p>伴随着对应的解决方案：</p>\n<h3><a id=\"2_103\"></a>2事务的隔离等级：</h3>\n<p><strong>隔离性的隔离级别</strong></p>\n<ol><li>读未提交 read uncommitted</li><li>读已提交 read committed</li><li>可重复读 repeatable read</li><li>串行化 serializable</li></ol>\n<p>（1）、读未提交：事物A和事物B，事物A未提交的数据，事物B可以读取到。 这种隔离级别最低，这种级别一般是在理论上存在，数据库隔离级别一般都高于该级别。 <strong>三种并发问题都没解决。</strong></p>\n<pre><code class=\"prism language-mysql\">set global transaction isolation level read uncommitted;\n#查看当前隔离级别\nselect @@global.tx_isolation,@@tx_isolation;\n</code></pre>\n<p>（2）、读已提交：事务A只能读取到事务B提交的数据，这种级别可以避免“脏数据” ，这种隔离级别会导致“不可重复读取” ，<strong>Oracle默认隔离级别</strong></p>\n<pre><code class=\"prism language-mysql\">set global transaction isolation level read committed;\n查看当前隔离级别\nselect @@global.tx_isolation,@@tx_isolation;\n</code></pre>\n<p>（3）、可重复读：- 事务A和事务B，事务A提交之后的数据，事务B读取不到 - 事务B是可重复读取数据 - 这种隔离级别高于读已提交 - 换句话说，对方提交之后的数据，我还是读取不到 - 这种隔离级别可以避免“不可重复读取”，达到可重复读取 - 比如1点和2点读到数据是同一个 - MySQL默认级别 - 虽然可以达到可重复读取，但是会导致“幻像读”</p>\n<pre><code class=\"prism language-mysql\">set global transaction isolation level repeatable read;\n查看当前隔离级别\nselect @@global.tx_isolation,@@tx_isolation;\n</code></pre>\n<p>(4)、串行化：事务A和事务B，事务A在操作数据库时，事务B只能排队等待 这种隔离级别很少使用，吞吐量太低，用户体验差 这种级别可以避免“幻像读”，每一次读取的都是数据库中真实存在数据，事务A与事务B串行， 而不并发</p>\n<pre><code class=\"prism language-mysql\">set global transaction isolation level serializable;\n\n查看当前隔离级别\nselect @@global.tx_isolation,@@tx_isolation;\n</code></pre>\n<h3><a id=\"3_147\"></a>3隔离级别的一致性的关系：</h3>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\fe8bf94eb677468da203a783d44ade6a.png\"/></p>\n<h2><a id=\"_154\"></a>三、事务的相关技术代码</h2>\n<ul><li>开启事务：START TRANSACTION</li><li>事务的提交：COMMIT<br/> ages/image-20220605111202527.png\" alt=“image-20220605111202527” style=“zoom:80%;” /&gt;</li></ul>\n<h2><a id=\"_162\"></a>三、事务的相关技术代码</h2>\n<ul><li>开启事务：START TRANSACTION</li><li>事务的提交：COMMIT</li><li>事务的回滚：ROLLBACK (一旦事务提交失败，我们需要将数据回滚到之前的状态，需要用到rollback语句)</li></ul>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}