{"blogid": "119180778", "writerAge": "码龄1年", "writerBlogNum": "126", "writerCollect": "631", "writerComment": "74", "writerFan": "976", "writerGrade": "5级", "writerIntegral": "2198", "writerName": "黑马星云", "writerProfileAdress": "writer_image\\profile_119180778.jpg", "writerRankTotal": "1895141", "writerRankWeekly": "18972", "writerThumb": "253", "writerVisitNum": "147525", "blog_read_count": "13679", "blog_time": "于 2021-07-28 15:11:59 发布", "blog_title": "map 详解（C++）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p></p>\n<p>现实中的数据很多是关联的，例如书本名称和价格，每条数据都含有两部分：</p>\n<pre><code>信息学竞赛一本通 ：¥80\n高等数学 ：¥27.5\n生物信息分析 ：¥35.5</code></pre>\n<p>我们可以使用map存储这类一对一的数据：</p>\n<p>第一个可以称为关键字(key)，每个关键字只能在map中出现一次；<br/> 第二个可能称为该关键字的值(value)；</p>\n<p>另外需要注意的是，使用 map 容器存储的各个键-值对，<strong>键的值既不能重复也不能被修改</strong>。换句话说，map 容器中存储的各个键值对不仅键的值独一无二，键的类型也会用 const 修饰，这意味着只要键值对被存储到 map 容器中，其键的值将不能再做任何修改。</p>\n<p></p>\n<h2><strong>1.头文件</strong></h2>\n<pre><code>#include &lt;map&gt;\nusing namespace std;</code></pre>\n<p></p>\n<h2><strong>2.初始化</strong></h2>\n<pre><code>std::map&lt;std::string, int&gt;myMap;\nstd::map&lt;std::string, int&gt;myMap{ {\"C语言教程\",10},{\"STL教程\",20} };//myMap 容器在初始状态下，就包含有 2 个键值对。</code></pre>\n<p>再次强调，map 容器中存储的键值对，其本质都是 pair 类模板创建的 pair 对象。因此，下面程序也可以创建出一模一样的 myMap 容器：</p>\n<pre><code>std::map&lt;std::string, int&gt;myMap{std::make_pair(\"C语言教程\",10),std::make_pair(\"STL教程\",20)};</code></pre>\n<p></p>\n<h2><strong>3.插入元素</strong></h2>\n<p><a href=\"http://c.biancheng.net/cplus/\">C++</a> <a href=\"http://c.biancheng.net/stl/\">STL</a> map 类模板中对<code>[ ]</code>运算符进行了重载，即根据使用场景的不同，借助<code>[ ]</code>运算符可以实现不同的操作。举个例子</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;map&gt;  //map\n#include &lt;string&gt; //string\nusing namespace std;\nint main()\n{\n    std::map&lt;string, string&gt; mymap{ {\"STL教程\",\"http://c.biancheng.net/java/\"} };\n    //获取已存储键值对中，指定键对应的值\n    cout &lt;&lt; mymap[\"STL教程\"] &lt;&lt; endl;\n\n    //向 map 容器添加新键值对\n    mymap[\"Python教程\"] = \"http://c.biancheng.net/python/\";\n\n    //修改 map 容器已存储键值对中，指定键对应的值\n    mymap[\"STL教程\"] = \"http://c.biancheng.net/stl/\";\n\n    for (auto iter = mymap.begin(); iter != mymap.end(); ++iter) {\n        cout &lt;&lt; iter-&gt;first &lt;&lt; \" \" &lt;&lt; iter-&gt;second &lt;&lt; endl;\n    }\n   \n    return 0;\n}</code></pre>\n<p>程序执行结果为：</p>\n<pre><code>http://c.biancheng.net/java/\nPython教程 http://c.biancheng.net/python/\nSTL教程 http://c.biancheng.net/stl/</code></pre>\n<p>可以看到，当操作对象为 map 容器中已存储的键值对时，则借助 [ ] 运算符，既可以获取指定键对应的值，还能对指定键对应的值进行修改；反之，若 map 容器内部没有存储以 [ ] 运算符内指定数据为键的键值对，则使用 [ ] 运算符会向当前 map 容器中添加一个新的键值对。</p>\n<p></p>\n<h2><strong>4.获取元素</strong></h2>\n<p>map 类模板中对<code>[ ]</code>运算符进行了重载，这意味着，类似于借助数组下标可以直接访问数组中元素，通过指定的键，我们可以轻松获取 map 容器中该键对应的值。</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;map&gt;      // map\n#include &lt;string&gt;   // string\nusing namespace std;\n\nint main() {\n    //创建并初始化 map 容器\n    std::map&lt;std::string, std::string&gt;myMap{ {\"STL教程\",\"http://c.biancheng.net/stl/\"},\n                                             {\"C语言教程\",\"http://c.biancheng.net/c/\"},\n                                             {\"Java教程\",\"http://c.biancheng.net/java/\"} };\n    string cValue = myMap[\"C语言教程\"];\n    cout &lt;&lt; cValue &lt;&lt; endl;\n    return 0;\n}</code></pre>\n<p>程序执行结果为：</p>\n<pre><code>http://c.biancheng.net/c/</code></pre>\n<p><strong>注意</strong>，只有当 map 容器中确实存有包含该指定键的键值对，借助重载的 [ ] 运算符才能成功获取该键对应的值；反之，若当前 map 容器中没有包含该指定键的键值对，则此时使用 [ ] 运算符将不再是访问容器中的元素，而变成了向该 map 容器中增添一个键值对。其中，该键值对的键用 [ ] 运算符中指定的键，其对应的值取决于 map 容器规定键值对中值的数据类型，如果是基本数据类型，则值为 0；如果是 string 类型，其值为 \"\"，即空字符串（即使用该类型的默认值作为键值对的值）。</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;map&gt;      // map\n#include &lt;string&gt;   // string\nusing namespace std;\n\nint main() {\n    //创建空 map 容器\n    std::map&lt;std::string, int&gt;myMap;\n    int cValue = myMap[\"C语言教程\"];\n    for (auto i = myMap.begin(); i != myMap.end(); ++i) {\n        cout &lt;&lt; i-&gt;first &lt;&lt; \" \"&lt;&lt; i-&gt;second &lt;&lt; endl;\n    }\n    return 0;\n}</code></pre>\n<p>程序执行结果为：</p>\n<pre><code>C语言教程 0</code></pre>\n<p></p>\n<h2><strong>5.迭代元素</strong></h2>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;map&gt;      // pair\n#include &lt;string&gt;       // string\nusing namespace std;\n\nint main() {\n    //创建并初始化 map 容器\n    map&lt;string, string&gt;myMap{ {\"STL教程\",\"http://c.biancheng.net/stl/\"},{\"C语言教程\",\"http://c.biancheng.net/c/\"} };\n\n    //调用 begin()/end() 组合，遍历 map 容器\n    for (map&lt;string, string&gt;::iterator iter = myMap.begin(); iter != myMap.end(); ++iter) {\n        cout &lt;&lt; iter-&gt;first &lt;&lt; \" \" &lt;&lt; iter-&gt;second &lt;&lt; endl;\n    }\n    return 0;\n}</code></pre>\n<p>程序执行结果为：</p>\n<pre><code>C语言教程 http://c.biancheng.net/c/\nSTL教程 http://c.biancheng.net/stl/</code></pre>\n<p></p>\n<h2><strong>6.删除元素</strong></h2>\n<pre><code>删除键为bfff指向的元素\n \ncmap.erase(\"bfff\");\n \n \n删除迭代器 key所指向的元素\nmap&lt;string,int&gt;::iterator key = cmap.find(\"mykey\");\nif(key!=cmap.end())\n{\n    cmap.erase(key);\n}\n \n删除所有元素\ncmap.erase(cmap.begin(),cmap.end());</code></pre>\n<p></p>\n<p></p>\n</div>\n</div>"}