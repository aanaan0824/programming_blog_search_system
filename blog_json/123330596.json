{"blogid": "123330596", "writerAge": "码龄2年", "writerBlogNum": "170", "writerCollect": "626", "writerComment": "16", "writerFan": "370", "writerGrade": "5级", "writerIntegral": "2314", "writerName": "普通网友", "writerProfileAdress": "writer_image\\profile_123330596.jpg", "writerRankTotal": "暂无排名", "writerRankWeekly": "暂无排名", "writerThumb": "132", "writerVisitNum": "213344", "blog_read_count": "7422", "blog_time": "于 2022-03-07 15:00:37 发布", "blog_title": "Java程序员学习Rust编程", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>如果您是 Java 开发人员，您会发现 Rust 相对容易掌握，这要归功于这两种语言的相似性。</p>\n<p><a href=\"https://insights.stackoverflow.com/survey/2021%3Ca%20href='/query/searchAction.shtml?query=technology%27%3E%3Cb%3Etechnology%3C/b%3E%3C/a%3E-most-loved-dreaded-and-wanted\" title=\"根据Stack Overflow\">根据Stack Overflow</a> 的调查，Rust 已经在语言流行度或最常用语言的阶梯上攀升，但最引人注目的是，Rust 不断成为“最受喜爱的语言” 。这证明了使用 Rust 的丰富经验。</p>\n<p>Rust 语法</p>\n<p>像 Java 一样，Rust 也是编译好的。它被编译为 <a href=\"https://en.wikipedia.org/wiki/LLVM\" title=\"LLVM\">LLVM</a> 规范，在精神上类似于 <a href=\"https://www.infoworld.com/article/3272244/what-is-the-jvm-introducing-the-java-virtual-machine.html\" title=\"JVM\">JVM</a> ，允许输出到各种目标平台。</p>\n<p>和 Java 一样，Rust 起源于 C 血统。它在块中使用花括号，在行终止时使用分号，这与 Java 完全相同。例如，您可以 <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=bb44492b090fb713e3d0cccf700246dc\" title=\"在这里\">在这里</a> 看到一个简单的程序，如：</p>\n<pre>fn main () {     println !( &lt;font&gt;\"Hello, InfoWorld!\"&lt;/font&gt;&lt;font&gt; ); } \n&lt;/font&gt;</pre>\n<p>请注意，有一个main()函数，类似于 Java 中的main函数入口点。</p>\n<p><strong>Rust中的函数</strong></p>\n<p>函数在Rust中是独立的，它们可以在任何地方声明，包括嵌套在其他函数中。</p>\n<p>这与Java不同，在Java中，函数总是被声明为对象的方法（除了lambdas的情况）。</p>\n<p>换句话说，在Java中，所有东西都是一个对象。在Rust中则不然。</p>\n<pre>fn main() {\n    println!(&lt;font&gt;\"Hello, world!\"&lt;/font&gt;&lt;font&gt;);\n\n    fn function2(){\n        println!(&lt;/font&gt;&lt;font&gt;\"Hello InfoWorld\"&lt;/font&gt;&lt;font&gt;);\n    }\n    function2();\n\n    function3();\n}\n\nfn function3() {\n    println!(&lt;/font&gt;&lt;font&gt;\"Hello again.\"&lt;/font&gt;&lt;font&gt;);\n}\n&lt;/font&gt;</pre>\n<p><strong>隐式返回值</strong></p>\n<p>与Java不同，Rust允许你在函数的结尾跳过返回return关键字。函数中的最后一条语句将自动被评估为返回值。</p>\n<p>这样做时，你可以省略最后语句中的分号。</p>\n<p><strong>lambdas代码</strong></p>\n<p>和Java一样，Rust支持功能式编码的lambdas。语法是不同的，但如果你熟悉Java流API，就不难理解。</p>\n<p>项目显示了使用map()函数使一组字符串大写的情况。正如你所看到的，这与Java很相似。</p>\n<pre>&lt;font&gt;&lt;i&gt;// Rust&lt;/i&gt;&lt;/font&gt;&lt;font&gt;\nfn main() {\n    let animals = [&lt;/font&gt;&lt;font&gt;\"dog\"&lt;/font&gt;&lt;font&gt;, &lt;/font&gt;&lt;font&gt;\"badger\"&lt;/font&gt;&lt;font&gt;, &lt;/font&gt;&lt;font&gt;\"quokka\"&lt;/font&gt;&lt;font&gt;];\n\n    let result = animals.iter().map(|value| value.to_uppercase());\n\n    &lt;b&gt;for&lt;/b&gt; animal in result {\n        println!(&lt;/font&gt;&lt;font&gt;\"Uppercased: {}\"&lt;/font&gt;&lt;font&gt;, animal);\n    }\n}\n&lt;/font&gt;</pre>\n<p>map()函数需要一个两部分的参数：</p>\n<ol><li>第一部分是管道字符里面的一个变量，|value|，它将定义作为每个项目的句柄的变量。</li><li>第二部分是要执行的操作。在本例中，我们对数组的每个元素调用to_uppercase()。</li></ol>\n<p>注意，像Java一样，Rust的lambdas是捕获周围块的状态的闭包。</p>\n<p>换句话说，它们可以访问它们所执行的变量上下文。</p>\n<p><strong>对象是Rust中的struct</strong></p>\n<p>下面代码介绍了struct关键字。struct是结构的简称，它允许你定义一个数据容器，就像Java中类的状态部分。</p>\n<pre>struct Animal {\n  name: String\n}\nfn main() {\n  let dog = Animal{\n    name: String::from(&lt;font&gt;\"Shiba\"&lt;/font&gt;&lt;font&gt;)\n  };\n  println!(&lt;/font&gt;&lt;font&gt;\"{}\"&lt;/font&gt;&lt;font&gt;, dog.name);\n}\n&lt;/font&gt;</pre>\n<p>你在struct的大括号内定义结构的成员。这些变量类似于公共成员。</p>\n<p>请注意，在你声明dog变量的那一行，没有必要调用new关键字。</p>\n<p>Rust可以从上下文中推断出，但是一个新的引用变量名是有必要的。</p>\n<p>接下来，注意到变量名在创建时被设置为一个带值的字符串。这是通过调用内置的String.from方法，使用双冒号引用操作符完成的。</p>\n<p>最后，注意到就像Java一样，Rust使用点运算符来访问dog实例的名字字段：dog.name。</p>\n<p><strong>方法</strong></p>\n<p>您可以向struct添加函数，这些函数的行为方式与Java中的方法基本相同。</p>\n<p>例如，为了给上述代码中所示的Animal struct添加一个speak()方法，你可以使用impl关键字。</p>\n<pre>impl Animal {\n  fn speak(&amp;self) {\n      println!(&lt;font&gt;\"{}\"&lt;/font&gt;&lt;font&gt;, self.name);\n  }\n}\n&lt;/font&gt;</pre>\n<p>Impl意味着实现接口或父类。</p>\n<p>上述代码我们正在实现Animal struct：我们定义了一个方法speak，它需要一个参数。</p>\n<p>这个参数是特殊的&amp;self指针（Rust中的&amp;意味着参数是一个引用指针）。</p>\n<p>这个特殊指针的语义与Java中的this关键字非常相似。它指的是当前活动的对象实例。</p>\n<p>调用dog.speak()将输出当前实例化对象的名称。</p>\n<p>在这个例子中输出结果是 \"Shiba\"。</p>\n<p><strong>Rust中的可变性</strong></p>\n<p>如果你有Java背景，那么Rust的一个比较奇怪的地方就是变量的默认不可变性。</p>\n<p>简而言之，当你在Rust中声明一个变量时，它默认是不可变的，试图改变它将导致一个错误。</p>\n<p>要使一个变量可变，必须添加mut关键字，但mut一次只能由一个引用添加。</p>\n<p>记住，Rust高度关注保持代码的线程安全。这也避免了在Java中看到的并发修改错误。</p>\n<p>下面代码显示了如何使dog对象变异，然后给它分配一个新的名字。</p>\n<pre>let mut dog = Animal{\n  name: String::from(&lt;font&gt;\"Shiba\"&lt;/font&gt;&lt;font&gt;)\n};\ndog.name = String::from(&lt;/font&gt;&lt;font&gt;\"Suki\"&lt;/font&gt;&lt;font&gt;);\nprintln!(&lt;/font&gt;&lt;font&gt;\"{}\"&lt;/font&gt;&lt;font&gt;, dog.name);\n&lt;/font&gt;</pre>\n<p><strong>Rust中的类型推理</strong></p>\n<p>在Rust中，你并不总是需要告诉编译器你正在声明什么类型的变量。</p>\n<p>对于来自Java的开发者来说，这似乎很奇怪，因为在Java中没有推断变量类型的工具。</p>\n<p>例如，下面代码编译器正确地将类型推断为整数。</p>\n<pre>let number1 = 10;\nlet number2 = 10;\nprintln!(&lt;font&gt;\"{}\"&lt;/font&gt;&lt;font&gt;, number1 * number2);\n&lt;/font&gt;</pre>\n<p><strong>阴影Shadowing和变量名</strong></p>\n<p>另一个可能会让Java开发者感到惊讶的Rust特性是所谓的变量阴影shadowing。</p>\n<p>从本质上讲，你可以在一个变量上面创建一个同名的可变变量“罩子”，而不是把它声明为可变的。</p>\n<p>这是一种一次性的可变性，为相同的变量名称创建一个新的空间。</p>\n<p>一般来说，重复使用同一变量名的能力与Java不同。</p>\n<p>下面显示了一个变量阴影的简单例子。</p>\n<pre>fn main() {\n    let x = 5;\n    let x = x + 1;\n    println!(&lt;font&gt;\"The value of x is: {}\"&lt;/font&gt;&lt;font&gt;, x); &lt;/font&gt;&lt;font&gt;&lt;i&gt;// outputs 6&lt;/i&gt;&lt;/font&gt;&lt;font&gt;\n}\n&lt;/font&gt;</pre>\n<p><strong>Rust中的元组类型</strong></p>\n<p>Rust支持元组类型，它是一种复合变量，在Java中没有真正的类似物。</p>\n<p>下面代码向你展示了一个元组的实例。</p>\n<pre>fn main() {\n    let myTuple = (&lt;font&gt;\"Sum\"&lt;/font&gt;&lt;font&gt;, 10, 5);\n    let (x, y) = myTuple ;\n    println!(&lt;/font&gt;&lt;font&gt;\"The {} is: {}\"&lt;/font&gt;&lt;font&gt;, x, y + z);\n}\n&lt;/font&gt;</pre>\n<p>在这里你可以看到myTuple变量是用括号声明的，包含三个值、一个字符串和两个整数。这就是一个元组。</p>\n<p>你可以将元组 \"去结构化（解构或析构） \"为元组变量，就像在上面代码中看到的那样，let关键字被用来用元组中的值填充每个变量x、y和z。</p>\n<p>你也可以通过索引访问元组成员。例如，tup.0引用元组的第一个字段（字符串 \"Sum\"）。</p>\n<p><strong>Rust中的traits和泛型</strong></p>\n<p>在Rust中，有一个traits的概念，它类似于Java中的“接口interface”。它们定义了一个类型与其他类型共享的属性。</p>\n<p>换句话说，traits抽象了不同类型的共同功能。</p>\n<p>Rust中的泛型与Java中的泛型类似，使用类似的角括号语法，根据类型的共享属性，以一般的方式处理类型。</p>\n<pre>pub trait Summary {\n    fn summarize(&amp;self) -&gt; String;\n}\npub struct NewsArticle {\n    pub headline: String,\n    pub location: String,\n    pub author: String,\n    pub content: String,\n}\n\nimpl Summary &lt;b&gt;for&lt;/b&gt; NewsArticle {\n    fn summarize(&amp;self) -&gt; String {\n        format!(&lt;font&gt;\"{}, by {} ({})\"&lt;/font&gt;&lt;font&gt;, self.headline, self.author, self.location)\n    }\n}\n\npub struct Tweet {\n    pub username: String,\n    pub content: String,\n    pub reply: bool,\n    pub retweet: bool,\n}\n\nimpl Summary &lt;b&gt;for&lt;/b&gt; Tweet {\n    fn summarize(&amp;self) -&gt; String {\n        format!(&lt;/font&gt;&lt;font&gt;\"{}: {}\"&lt;/font&gt;&lt;font&gt;, self.username, self.content)\n    }\n}\n\nfn main() {\n    let tweet = Tweet {\n        username: String::from(&lt;/font&gt;&lt;font&gt;\"dog_post\"&lt;/font&gt;&lt;font&gt;),\n        content: String::from(&lt;/font&gt;&lt;font&gt;\"A Shih Tzu is smaller than a Lurcher\"&lt;/font&gt;&lt;font&gt;,\n        ),\n        reply: false,\n        retweet: false,\n    };\n\n    println!(&lt;/font&gt;&lt;font&gt;\"1 new tweet: {}\"&lt;/font&gt;&lt;font&gt;, tweet.summarize());\n}\n&lt;/font&gt;</pre>\n<p>在这里，trait关键字被用来定义一个Summary属性，然后用impl关键字为每个struct对象类型(NewsArticle和Tweet)实现这个属性。</p>\n<p>所以这与Java中的接口非常相似，只是在Java中，接口定义了整个类的表面，而不是零散地定义方法。</p>\n</div>\n</div>"}