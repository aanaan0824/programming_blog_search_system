{"blogid": "126546806", "writerAge": "码龄1年", "writerBlogNum": "65", "writerCollect": "4796", "writerComment": "7278", "writerFan": "9974", "writerGrade": "7级", "writerIntegral": "13210", "writerName": "陈橘又青", "writerProfileAdress": "writer_image\\profile_126546806.jpg", "writerRankTotal": "833", "writerRankWeekly": "6", "writerThumb": "4998", "writerVisitNum": "364597", "blog_read_count": "487", "blog_time": "于 2022-08-26 17:05:17 发布", "blog_title": "【刷题记录16】Java工程师丨美团面试真题（1）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<blockquote>\n<p><strong>题目地址：</strong></p>\n<blockquote>\n<p><strong> 传送门</strong>： <a href=\"https://www.nowcoder.com/link/pc_csdncpt_qing_java\" title=\"牛客网 - 找工作神器|笔试题库|面试经验|实习招聘内推，求职就业一站解决_牛客网\">牛客网 - 找工作神器|笔试题库|面试经验|实习招聘内推，求职就业一站解决_牛客网</a></p>\n</blockquote>\n<hr/>\n</blockquote>\n<p><strong>Java面试练习题刷题记录</strong></p>\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E4%B8%80%E3%80%81%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%80%E3%80%81%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC\">一、最大差值</a></p>\n<p id=\"%E4%BA%8C%E3%80%81%E6%A3%8B%E5%AD%90%E7%BF%BB%E8%BD%AC-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BA%8C%E3%80%81%E6%A3%8B%E5%AD%90%E7%BF%BB%E8%BD%AC\">二、棋子翻转</a></p>\n<p id=\"%C2%A0%E4%B8%89%E3%80%81%E6%8B%9C%E8%AE%BF-toc\" style=\"margin-left:0px;\"><a href=\"#%C2%A0%E4%B8%89%E3%80%81%E6%8B%9C%E8%AE%BF\"> 三、拜访</a></p>\n<p id=\"%E5%9B%9B%E3%80%81%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%86%85%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%9B%9B%E3%80%81%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%86%85%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2\">四、直方图内最大矩形</a></p>\n<p id=\"%E4%BA%94%E3%80%81%E6%80%BB%E7%BB%93-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BA%94%E3%80%81%E6%80%BB%E7%BB%93\">五、总结</a></p>\n<hr/>\n<h1 id=\"%E4%B8%80%E3%80%81%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC\">一、最大差值</h1>\n<h2 id=\"%E6%8F%8F%E8%BF%B0\">描述</h2>\n<p>有一个长为 n 的数组 A ，求满足 0 ≤ a ≤ b &lt; n 的 A[b] - A[a] 的最大值。</p>\n<p>给定数组 A 及它的大小 n ，请返回最大差值。</p>\n<p>数据范围： 2&lt;n≤2∗105 2 &lt; n \\le 2*10^5\\ 2&lt;n≤2∗105  ，数组中的值满足 0≤∣val∣≤5∗108 0 \\le |val| \\le 5*10^8 \\ 0≤∣val∣≤5∗108 </p>\n<blockquote>\n<h2 id=\"%E7%A4%BA%E4%BE%8B1\">示例1</h2>\n<p>输入：</p>\n<pre>[5,1],2</pre>\n<p>返回值：</p>\n<pre>0\n</pre>\n<h2 id=\"%E7%A4%BA%E4%BE%8B2\">示例2</h2>\n<p>输入：</p>\n<pre>[5,6],2</pre>\n<p>返回值：</p>\n<pre>1\n</pre>\n</blockquote>\n<p>题解：</p>\n<pre><code class=\"language-java\">import java.util.*;\n\n\npublic class Solution {\n    /**\n     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可\n     *\n     * \n     * @param A int整型一维数组 \n     * @param n int整型 \n     * @return int整型\n     */\n    public int getDis (int[] A, int n) {\n        // write code here\n        \n        int res = 0;\n        int min = Integer.MAX_VALUE;\n        for (int i = 0; i &lt; n; i++) {\n            min = Math.min(min, A[i]);\n            res = Math.max(res, A[i] - min);\n        }\n        return res;\n    }\n}\n</code></pre>\n<hr/>\n<h1 id=\"%E4%BA%8C%E3%80%81%E6%A3%8B%E5%AD%90%E7%BF%BB%E8%BD%AC\"><strong>二、棋子翻转</strong></h1>\n<h2>描述</h2>\n<p>在 4x4 的棋盘上摆满了黑白棋子，黑白两色棋子的位置和数目随机，其中0代表白色，1代表黑色；左上角坐标为 (1,1) ，右下角坐标为 (4,4) 。</p>\n<p>现在依次有一些翻转操作，要对以给定翻转坐标(x,y)（也即第x行第y列）为中心的上下左右四个棋子的颜色进行翻转。</p>\n<p>给定两个数组 A 和 f ，分别代表 初始棋盘 和 哪些要进行翻转的位置(x,y) ，请返回经过所有翻转操作后的棋盘。</p>\n<p></p>\n<p>例如输入[[0,0,1,1],[1,0,1,0],[0,1,1,0],[0,0,1,0]],[[2,2],[3,3],[4,4]]时，初始键盘如下图所示：</p>\n<p><img alt=\"\" height=\"320\" src=\"image\\e323b5a588dd469c884bac25dd5fe7aa.png\" width=\"327\"/></p>\n<p> </p>\n<p>对应的输出为[[0,1,1,1],[0,0,1,0],[0,1,1,0],[0,0,1,0]]，如下图所示：<br/><img alt=\"\" height=\"317\" src=\"image\\2091f96fad7d4a289c6f5ded687ed93e.png\" width=\"312\"/></p>\n<h2>示例1</h2>\n<blockquote>\n<p>输入：</p>\n<pre>[[0,0,1,1],[1,0,1,0],[0,1,1,0],[0,0,1,0]],[[2,2],[3,3],[4,4]]</pre>\n<p>返回值：</p>\n<pre>[[0,1,1,1],[0,0,1,0],[0,1,1,0],[0,0,1,0]]\n</pre>\n</blockquote>\n<p>题解：</p>\n<pre><code class=\"language-java\">import java.util.*;\n\n\npublic class Solution {\n    /**\n     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可\n     *\n     * \n     * @param A int整型二维数组 \n     * @param f int整型二维数组 \n     * @return int整型二维数组\n     */\n    public int[][] flipChess (int[][] A, int[][] f) {\n        // write code here\n        int m = A.length;\n        int n = A[0].length;\n        for(int i = 0; i &lt; f.length; i++) {\n            int x = f[i][0] - 1, y = f[i][1] - 1;\n            if(x &gt; 0) A[x - 1][y] = 1 - A[x - 1][y];\n            if(y &gt; 0) A[x][y - 1] = 1 - A[x][y - 1];\n            if(x + 1 &lt; m) A[x + 1][y] = 1 - A[x + 1][y];\n            if(y + 1 &lt; n) A[x][y + 1] = 1 - A[x][y + 1];\n        }\n        return A;\n    }\n}\n</code></pre>\n<hr/>\n<h1 id=\"%C2%A0%E4%B8%89%E3%80%81%E6%8B%9C%E8%AE%BF\"> 三、拜访</h1>\n<h2>描述</h2>\n<p>现在有一个城市销售经理，需要从公司出发，去拜访市内的某位商家，已知他的位置以及商家的位置，但是由于城市道路交通的原因，他每次移动只能在左右中选择一个方向 或 在上下中选择一个方向，现在问他有多少种最短方案到达商家地址。</p>\n<p>给定一个地图 CityMap 及它的 行长度 n 和 列长度 m ，其中1代表经理位置， 2 代表商家位置， -1 代表不能经过的地区， 0 代表可以经过的地区，请返回方案数，保证一定存在合法路径。保证矩阵的长宽都小于等于 10。</p>\n<p>注意：需保证所有方案的距离都是最短的方案</p>\n<p>数据范围：2≤n,m≤102 \\leq n,m \\leq 102≤n,m≤10</p>\n<p>例如当输入为[[2,0,0,0],[0,-1,-1,0],[0,-1,1,0],[0,0,0,0]],4,4时，对应的4行4列CityMap如下图所示：</p>\n<p><img alt=\"\" height=\"480\" src=\"image\\b813066991594b5d823c4b2e05afc912.png\" width=\"477\"/></p>\n<p>经理的位置在(2,2)，商家的位置在(0,0)，经分析，经理到达商家地址的最短方案有两种，分别为：</p>\n<p>(2,2)-&gt;(2,3)-&gt;(1,3)-&gt;(0,3)-&gt;(0,2)-&gt;(0,1)-&gt;(0,0)</p>\n<p>和</p>\n<p>(2,2)-&gt;(3,2)-&gt;(3,1)-&gt;(3,0)-&gt;(2,0)-&gt;(1,0)-&gt;(0,0)，所以对应的返回值为2</p>\n<h2>示例1</h2>\n<blockquote>\n<p>输入：</p>\n<pre>[[0,1,0],[2,0,0]],2,3</pre>\n<p>返回值：</p>\n<pre>2\n</pre>\n</blockquote>\n<p>题解：</p>\n<pre><code class=\"language-java\">import java.util.*;\n\n\npublic class Solution {\n    /**\n     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可\n     *\n     * \n     * @param CityMap int整型二维数组 \n     * @param n int整型 \n     * @param m int整型 \n     * @return int整型\n     */\n    int[][] directions = new int[][]{<!-- -->{1,0}, {-1, 0}, {0,1}, {0, -1}};\n    public int countPath (int[][] CityMap, int n, int m) {\n        // write code here\n        int ans = 0;\n        Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;();\n        int[][] dist = new int[n][m];\n        int[][] dp = new int[n][m];\n        boolean[][] visited = new boolean[n][m];\n        for(int i=0; i&lt;n; i++){\n            for(int j=0; j&lt;m; j++){\n                if(CityMap[i][j]==1){ //确认出发点\n                    queue.offer(new int[]{i,j});\n                    dist[i][j] = 1;  //出发点距离为1\n                    dp[i][j] = 1;  //出发点的最短路径数为1\n                }\n            }\n        }\n        while(!queue.isEmpty()){\n            int[] p = queue.poll();\n            int x = p[0], y = p[1];\n            if(CityMap[x][y]==2){\n                return dp[x][y];\n            }\n            CityMap[x][y] = -1;\n            for(int[] direction : directions){\n                int newx = x + direction[0];\n                int newy = y + direction[1];\n                if(newx&gt;=n || newx&lt;0 || newy&lt;0 || newy&gt;=m || CityMap[newx][newy]==-1){  //判断不可达\n                    continue;\n                }\n                if(dist[newx][newy]==0 || dist[newx][newy]==dist[x][y]+1){  //dist[newx][newy]为0或当前访问点加1，则说明可以通过当前访问点到达目标点，且为最短路径\n                    dp[newx][newy] += dp[x][y];  \n                    dist[newx][newy] = dist[x][y] + 1;\n                }\n                \n                if(!visited[newx][newy]){  //通过visited数组防止重复加入访问队列\n                    queue.offer(new int[]{newx, newy});\n                    visited[newx][newy] = true;\n                }\n            }\n        }\n        return -1;\n    }\n}\n</code></pre>\n<hr/>\n<h1 id=\"%E5%9B%9B%E3%80%81%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%86%85%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2\">四、直方图内最大矩形</h1>\n<h2>描述</h2>\n<p>给定一个数组heights，长度为n，height[i]是在第i点的高度，那么height[i]表示的直方图，能够形成的最大矩形是多少?</p>\n<p>1.每个直方图宽度都为1</p>\n<p>2.直方图都是相邻的</p>\n<p>3.如果不能形成矩形，返回0即可</p>\n<p>4.保证返回的结果不会超过231-1</p>\n<p>数据范围:</p>\n<p>0&lt;=heights[i]&lt;=1040 &lt;= heights[i] &lt;= 10^40&lt;=heights[i]&lt;=104</p>\n<p>0&lt;=heights.length&lt;=1050 &lt;= heights.length &lt;=10^50&lt;=heights.length&lt;=105</p>\n<p>如输入[3,4,7,8,1,2]，那么如下:</p>\n<p><img alt=\"\" height=\"504\" src=\"image\\90acf955f28049b1ab8864641d1dd5fa.png\" width=\"837\"/></p>\n<h2>示例1</h2>\n<blockquote>\n<p>输入：</p>\n<pre>[3,4,7,8,1,2]</pre>\n<p>返回值：</p>\n<pre>14\n</pre>\n</blockquote>\n<h2>示例2</h2>\n<blockquote>\n<p>输入：</p>\n<pre>[1,7,3,2,4,5,8,2,7]</pre>\n<p>返回值：</p>\n<pre>16\n</pre>\n</blockquote>\n<p> 题解：</p>\n<pre><code class=\"language-java\">import java.util.*;\n\npublic class Solution {\n    /**\n     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可\n     *\n     * \n     * @param heights int整型一维数组 \n     * @return int整型\n     */\n    public int largestRectangleArea (int[] heights) {\n        //总宽度\n        int n=heights.length;\n        //新建单调栈\n        ArrayDeque&lt;Integer&gt; stack=new ArrayDeque&lt;&gt;();\n        \n        int res=0;\n        for(int i=0;i&lt;n;i++){\n            //只要栈顶元素比当前大，则可以统计以栈顶元素为高的最大面积\n            while(!stack.isEmpty()&amp;&amp;heights[stack.peek()]&gt;heights[i]){\n                //由于单调栈内元素是单调不递减的，L到i-1之间的高度一定大于等于curHeight\n                int curHeight=heights[stack.pop()];\n                //如果栈中元素为空，说明0到i-1之间的高度均大于等于curHeight\n                int L=stack.isEmpty()?0:stack.peek()+1;\n                res=Math.max(res,(i-L)*curHeight);\n            }\n            stack.push(i);\n        }\n        \n        //如果遍历完之后，单调栈还不为空，则继续统计可能的最大面积\n        while(!stack.isEmpty()){\n            int curHeight=heights[stack.pop()];\n            int L=stack.isEmpty()?0:stack.peek()+1;\n            res=Math.max(res,(n-L)*curHeight);\n        }\n        \n        return res;\n    }\n}\n</code></pre>\n<hr/>\n<h1 id=\"%E4%BA%94%E3%80%81%E6%80%BB%E7%BB%93\">五、总结</h1>\n<p><strong>我几乎每天都会在<strong><a href=\"https://www.nowcoder.com/link/pc_csdncpt_qing_java\" title=\"【牛客网】\">【牛客网】</a></strong></strong><strong>刷题训练来使自己对各种算法随时保持一个清晰的状态。要知道<u>眼过千遍不如手过一遍</u></strong><strong>，想成为一名合格的开发工程师，更要逼迫自己养成动手的好习惯。</strong></p>\n<p><strong>相较于其他平台，<strong><a href=\"https://www.nowcoder.com/link/pc_csdncpt_qing_java\" title=\"牛客\">牛客</a></strong> 的题目更面向工作，不光有“面试必刷101道”，还有海量大厂真题，内容全程免费，非常的友好。</strong> </p>\n<p><img alt=\"\" height=\"428\" src=\"image\\2fd2e12585a144bab58b23b1cb7ee5e5.png\" width=\"560\"/></p>\n<p></p>\n<blockquote>\n<p>牛客网还支持<strong>ACM模式</strong>，没有练习过的一定要提前适应！像某团、某为，都要求自己处理输入输出，如果不提前练习会很吃亏的！</p>\n<p>牛客的题解更新迭代也很快，讨论区也有技巧的分享，能帮你把所有盲点扫清楚，整体来说还是非常推荐去练习的~</p>\n<p><strong>传送门</strong>： <a href=\"https://www.nowcoder.com/link/pc_csdncpt_qing_java\" title=\"牛客网 - 找工作神器|笔试题库|面试经验|实习招聘内推，求职就业一站解决_牛客网\">牛客网 - 找工作神器|笔试题库|面试经验|实习招聘内推，求职就业一站解决_牛客网</a></p>\n</blockquote>\n<hr/>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\5f8beec27f064327b7e12d0ce82d2595.png\"/> </p>\n<p> </p>\n</div>\n</div>"}