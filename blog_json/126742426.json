{"blogid": "126742426", "writerAge": "码龄1年", "writerBlogNum": "374", "writerCollect": "242", "writerComment": "21", "writerFan": "10327", "writerGrade": "5级", "writerIntegral": "3935", "writerName": "m0_67402125", "writerProfileAdress": "writer_image\\profile_126742426.jpg", "writerRankTotal": "5111", "writerRankWeekly": "842", "writerThumb": "52", "writerVisitNum": "153928", "blog_read_count": "14", "blog_time": "于 2022-09-07 11:36:56 发布", "blog_title": "JDK1.8 JVM内存模型", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h2><a id=\"JDK18_JVM_2\"></a>一、JDK1.8 JVM内存模型概览</h2>\n<p><img alt=\"JVM内存模型\" src=\"https://img-blog.csdn.net/20180225003503739?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYnJ1Y2UxMjg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\"/></p>\n<p>这里介绍的是JDK1.8 JVM内存模型。1.8同1.7比，最大的差别就是：<strong>元数据区取代了永久代</strong>。元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：<strong>元数据空间并不在虚拟机中，而是使用本地内存</strong>。</p>\n<h2><a id=\"_9\"></a>二、各区域介绍</h2>\n<h3><a id=\"1__12\"></a>1. 程序计数器</h3>\n<p>每个线程一块，指向当前线程正在执行的字节码代码的行号。如果当前线程执行的是native方法，则其值为null。</p>\n<h3><a id=\"2_Java_16\"></a>2. Java虚拟机栈</h3>\n<p><img alt=\"stack\" src=\"https://img-blog.csdn.net/20180226235717764?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYnJ1Y2UxMjg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\"/><br/> 线程私有，生命周期与线程同进同退。每个Java方法在被调用的时候都会创建一个栈帧，并入栈。一旦完成调用，则出栈。所有的的栈帧都出栈后，线程也就完成了使命。</p>\n<h3><a id=\"3__21\"></a>3. 本地方法栈</h3>\n<p>功能与Java虚拟机栈十分相同。区别在于，本地方法栈为虚拟机使用到的native方法服务。不多说。</p>\n<h3><a id=\"4__25\"></a>4. 堆</h3>\n<p><img alt=\"heap\" src=\"https://img-blog.csdn.net/20180224000420159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYnJ1Y2UxMjg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\"/><br/> 堆是JVM内存占用最大，管理最复杂的一个区域。其唯一的用途就是存放对象实例：所有的对象实例及数组都在对上进行分配。1.8后，字符串常量池从永久代中剥离出来，存放在队中。堆有自己进一步的内存分块划分，具体划分请参见上图。</p>\n<h3><a id=\"5__30\"></a>5. 元数据区</h3>\n<p>元数据区取代了1.7版本及以前的永久代。元数据区和永久代本质上都是方法区的实现。方法区存放虚拟机加载的类信息，静态变量，常量等数据。<br/> 元数据区OOM测试：</p>\n<p>a. jvm参数配置</p>\n<pre><code>-XX:MetaspaceSize=8m -XX:MaxMetaspaceSize=50m\n</code></pre>\n<ul><li>1</li></ul>\n<p>b. 测试代码</p>\n<pre><code>public class MetaSpaceOomMock {\n\n    public static void main(String[] args) {\n        ClassLoadingMXBean loadingBean = ManagementFactory.getClassLoadingMXBean();\n        while (true) {\n            Enhancer enhancer = new Enhancer();\n            enhancer.setSuperclass(MetaSpaceOomMock.class);\n            enhancer.setCallbackTypes(new Class[]{Dispatcher.class, MethodInterceptor.class});\n            enhancer.setCallbackFilter(new CallbackFilter() {\n                @Override\n                public int accept(Method method) {\n                    return 1;\n                }\n\n                @Override\n                public boolean equals(Object obj) {\n                    return super.equals(obj);\n                }\n            });\n\n            Class clazz = enhancer.createClass();\n            System.out.println(clazz.getName());\n            //显示数量信息（共加载过的类型数目，当前还有效的类型数目，已经被卸载的类型数目）\n            System.out.println(\"total: \" + loadingBean.getTotalLoadedClassCount());\n            System.out.println(\"active: \" + loadingBean.getLoadedClassCount());\n            System.out.println(\"unloaded: \" + loadingBean.getUnloadedClassCount());\n        }\n    }\n}\n</code></pre>\n<p><code>c. 运行输出：</code></p>\n<pre><code>jvm.MetaSpaceOomMock$$EnhancerByCGLIB$$567f7ec0\ntotal: 6265\nactive: 6265\nunloaded: 0\njvm.MetaSpaceOomMock$$EnhancerByCGLIB$$3501581b\ntotal: 6266\nactive: 6266\nunloaded: 0\nException in thread \"main\" net.sf.cglib.core.CodeGenerationException: java.lang.reflect.InvocationTargetException--&gt;null\n    at net.sf.cglib.core.AbstractClassGenerator.generate(AbstractClassGenerator.java:345)\n    at net.sf.cglib.proxy.Enhancer.generate(Enhancer.java:492)\n    at net.sf.cglib.core.AbstractClassGenerator$ClassLoaderData$3.apply(AbstractClassGenerator.java:93)\n    at net.sf.cglib.core.AbstractClassGenerator$ClassLoaderData$3.apply(AbstractClassGenerator.java:91)\n    at net.sf.cglib.core.internal.LoadingCache$2.call(LoadingCache.java:54)\n    at java.util.concurrent.FutureTask.run(FutureTask.java:266)\n    at net.sf.cglib.core.internal.LoadingCache.createEntry(LoadingCache.java:61)\n    at net.sf.cglib.core.internal.LoadingCache.get(LoadingCache.java:34)\n    at net.sf.cglib.core.AbstractClassGenerator$ClassLoaderData.get(AbstractClassGenerator.java:116)\n    at net.sf.cglib.core.AbstractClassGenerator.create(AbstractClassGenerator.java:291)\n    at net.sf.cglib.proxy.Enhancer.createHelper(Enhancer.java:480)\n    at net.sf.cglib.proxy.Enhancer.createClass(Enhancer.java:337)\n    at jvm.MetaSpaceOomMock.main(MetaSpaceOomMock.java:38)\nCaused by: java.lang.reflect.InvocationTargetException\n    at sun.reflect.GeneratedMethodAccessor1.invoke(Unknown Source)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:498)\n    at net.sf.cglib.core.ReflectUtils.defineClass(ReflectUtils.java:413)\n    at net.sf.cglib.core.AbstractClassGenerator.generate(AbstractClassGenerator.java:336)\n    ... 12 more\nCaused by: java.lang.OutOfMemoryError: Metaspace\n    at java.lang.ClassLoader.defineClass1(Native Method)\n    at java.lang.ClassLoader.defineClass(ClassLoader.java:763)\n    ... 17 more\n</code></pre>\n<p>如果是1.7的jdk，那么报OOM的将是PermGen区域。</p>\n<h3><a id=\"6__112\"></a>6. 直接内存</h3>\n<p>jdk1.4引入了NIO，它可以使用Native函数库直接分配堆外内存。</p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}