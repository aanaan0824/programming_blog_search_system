{"blogid": "124570115", "writerAge": "码龄1年", "writerBlogNum": "91", "writerCollect": "6689", "writerComment": "12532", "writerFan": "13044", "writerGrade": "7级", "writerIntegral": "19588", "writerName": "微凉秋意", "writerProfileAdress": "writer_image\\profile_124570115.jpg", "writerRankTotal": "415", "writerRankWeekly": "1", "writerThumb": "7495", "writerVisitNum": "121716", "blog_read_count": "1392", "blog_time": "已于 2022-06-12 08:47:22 修改", "blog_title": "算法设计与分析基础之分治法，详解二分查找、合并以及快速排序", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p style=\"text-align:center;\"><img alt=\"\" class=\"left\" src=\"https://img-blog.csdnimg.cn/50422e39407547ec999af330d381414b.gif\"/></p>\n<p>任何一个可以用计算机求解的问题所需的计算时间都与其规模有关：问题的规模越小，越容易直接求解。 要想直接解决一个规模较大的问题，有时是很困难的。那么，为了更好地解决这些规模较大的问题，分治法应运而生了。 在计算机科学中，分治法是一种很重要的算法。它采取各个击破的技巧来解决一个规模较大的问题，该技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)等。话不多说，直接上案例。</p>\n<hr/>\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE\">二分查找</a></p>\n<p id=\"%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0-toc\" style=\"margin-left:40px;\"><a href=\"#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0\">问题描述</a></p>\n<p id=\"%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-toc\" style=\"margin-left:40px;\"><a href=\"#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3\">算法思想</a></p>\n<p id=\"%E6%9E%84%E9%80%A0%E5%AE%9E%E4%BE%8B-toc\" style=\"margin-left:40px;\"><a href=\"#%E6%9E%84%E9%80%A0%E5%AE%9E%E4%BE%8B\">构造实例</a></p>\n<p id=\"%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95\">实现方法</a></p>\n<p id=\"1%E3%80%81%E4%B8%A4%E7%A7%8D%E9%9D%9E%E9%80%92%E5%BD%92-toc\" style=\"margin-left:80px;\"><a href=\"#1%E3%80%81%E4%B8%A4%E7%A7%8D%E9%9D%9E%E9%80%92%E5%BD%92\">1、两种非递归</a></p>\n<p id=\"2%E3%80%81%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95-toc\" style=\"margin-left:80px;\"><a href=\"#2%E3%80%81%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95\">2、递归算法</a></p>\n<p id=\"%C2%A0%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A0%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6\">时间复杂度</a></p>\n<p id=\"%E4%BA%8C%E3%80%81-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BA%8C%E3%80%81\">二、合并排序</a></p>\n<p id=\"%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-toc\" style=\"margin-left:40px;\"><a href=\"#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3\">算法思想</a></p>\n<p id=\"%E5%90%88%E5%B9%B6%E6%96%B9%E6%B3%95-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%90%88%E5%B9%B6%E6%96%B9%E6%B3%95\">合并方法</a></p>\n<p id=\"%C2%A0%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A0%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0\">算法描述</a></p>\n<p id=\"%E9%9D%9E%E9%80%92%E5%BD%92%E5%BD%A2%E5%BC%8F-toc\" style=\"margin-left:80px;\"><a href=\"#%E9%9D%9E%E9%80%92%E5%BD%92%E5%BD%A2%E5%BC%8F\">非递归形式</a></p>\n<p id=\"%C2%A0%E9%80%92%E5%BD%92%E5%BD%A2%E5%BC%8F-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A0%E9%80%92%E5%BD%92%E5%BD%A2%E5%BC%8F\">递归形式</a></p>\n<p id=\"%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-toc\" style=\"margin-left:40px;\"><a href=\"#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6\">时间复杂度</a></p>\n<p id=\"%E4%B8%89%E3%80%81-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%89%E3%80%81\">三、快速排序</a></p>\n<p id=\"%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-toc\" style=\"margin-left:40px;\"><a href=\"#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3\">算法思想</a></p>\n<p id=\"%E5%BF%AB%E6%8E%92%E5%88%86%E6%B2%BB%E4%BD%93%E7%8E%B0-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%BF%AB%E6%8E%92%E5%88%86%E6%B2%BB%E4%BD%93%E7%8E%B0\">快排分治体现</a></p>\n<p id=\"%C2%A0%E5%88%92%E5%88%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%9E%84%E9%80%A0%E5%AE%9E%E4%BE%8B-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A0%E5%88%92%E5%88%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%9E%84%E9%80%A0%E5%AE%9E%E4%BE%8B\">划分方法的构造实例</a></p>\n<p id=\"%E5%9B%BE%E7%A4%BA%E5%8A%A9%E7%90%86%E8%A7%A3-toc\" style=\"margin-left:80px;\"><a href=\"#%E5%9B%BE%E7%A4%BA%E5%8A%A9%E7%90%86%E8%A7%A3\">图示助理解</a></p>\n<p id=\"%C2%A0%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A0%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0\">具体代码实现</a></p>\n<p id=\"%C2%A0%E8%BF%90%E8%A1%8C%E6%95%88%E6%9E%9C-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A0%E8%BF%90%E8%A1%8C%E6%95%88%E6%9E%9C\">运行效果</a></p>\n<p id=\"%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-toc\" style=\"margin-left:40px;\"><a href=\"#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6\">时间复杂度</a></p>\n<p id=\"%C2%A0%E7%BB%93%E8%AF%AD-toc\" style=\"margin-left:0px;\"><a href=\"#%C2%A0%E7%BB%93%E8%AF%AD\"> 结语</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h1 id=\"%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE\">二分查找</h1>\n<h2 id=\"%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0\">问题描述</h2>\n<p>二分查找又称为折半查找，它要求待查找的数据元素必须是按关键字大小有序排列的。给定已排好序的n个元素s1,…,sn，现要在这n个元素中找出一特定元素x。 首先较容易想到使用顺序查找方法，逐个比较s1,…,sn，直至找出元素x或搜索遍整个序列后确定x不在其中。显然，该方法没有很好地利用n个元素已排好序这个条件。因此，在最坏情况下，顺序查找方法需要O(n)次比较。</p>\n<h2 id=\"%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3\">算法思想</h2>\n<p>假定元素序列已经由小到大排好序，将有序序列分成规模大致相等的两部分，然后取中间元素与特定查找元素x进行比较，如果x等于中间元素，则算法终止；如果x小于中间元素，则在序列的左半部继续查找，即在序列的左半部重复分解和治理操作；否则，在序列的右半部继续查找，即在序列的右半部重复分解和治理操作。可见，二分查找算法重复利用了元素间的次序关系。</p>\n<h2 id=\"%E6%9E%84%E9%80%A0%E5%AE%9E%E4%BE%8B\">构造实例</h2>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\fc2656fe83ca43569ec48a58f8cd1b93.png\"/></p>\n<p>创建数组并随机赋值，定义low为数组左边界high为数组右边界（数组长度-1）middle为数组长度的一半。middle=(low+high)/2，即指示中间元素；我们需要通过代码来每次折半查找我们需要的元素值。</p>\n<h2 id=\"%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95\">实现方法</h2>\n<h3 id=\"1%E3%80%81%E4%B8%A4%E7%A7%8D%E9%9D%9E%E9%80%92%E5%BD%92\">1、两种非递归</h3>\n<p>twoFind1()</p>\n<pre><code class=\"language-cpp\">int twoFind1(int A[], int len, int K)\n{\n\tint low = 0, high = len - 1,middle;\n\tif (low &gt; high) return -2;\n\twhile (low &lt;= high)//包含等于的情况\n\t{\n\t\tmiddle = (low + high) / 2;\n\t\tif (K == A[middle]) return middle;\n\t\telse if (K &gt; A[middle]) low = middle + 1;\n\t\telse high = middle - 1;\n\t}\n\treturn -1;\n}</code></pre>\n<p>twoFind2()</p>\n<pre><code class=\"language-cpp\">int twoFind2(int A[], int len, int K)\n{\n\tint low = 0, high = len - 1,middle;\n\tif (low &gt; high) return -2;\n\twhile (low &lt; high)//不含等于的情况，并在最后做判断\n\t{\n\t\tmiddle = (low + high) / 2;\n\t\tif (K == A[middle]) return middle;\n\t\telse if (K &gt; A[middle]) low = middle + 1;\n\t\telse high = middle - 1;\n\t}\n\tif (low == high &amp;&amp; A[low] == K) return low;\n\treturn -1;\n}</code></pre>\n<h3 id=\"2%E3%80%81%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95\">2、递归算法</h3>\n<pre><code class=\"language-cpp\">//递归二分查找算法\nint twoFind3(int A[], int k, int low, int high)\n{\n\tint middle;\n\tif (low &gt; high) return -1;//递归结束条件\n\tmiddle = (low + high) / 2;\n\tif (low==high &amp;&amp; A[middle] == k) return middle;\n\tif (low &lt; high) {\n\t\tif (A[middle] &lt; k)      return  twoFind3(A, k, middle + 1, high);\n\t\telse  if(A[middle]==k)  return middle;\n\t\telse                    return  twoFind3(A, k, 0, middle - 1);\n\t}\n\treturn -1;\n}</code></pre>\n<h2 id=\"%C2%A0%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6\"> 时间复杂度</h2>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\a4629be5c0714a1da5ff4ad60b1742cd.png\"/></p>\n<p></p>\n<h1 id=\"%E4%BA%8C%E3%80%81\">二、合并排序</h1>\n<h2>算法思想</h2>\n<blockquote>\n<p>合并排序是采用分治策略实现对n个元素进行排序的算法，是分治法的一个典型应用和完美体现。它是一种平衡、简单的二分分治策略，其计算过程分为三大步： （1）分解：将待排序元素分成大小大致相同的两个子序列。 （2）求解子问题：用合并排序法分别对两个子序列递归地进行排序。 （3）合并：将排好序的有序子序列进行合并，得到符合要求的有序序列。</p>\n</blockquote>\n<h2 id=\"%E5%90%88%E5%B9%B6%E6%96%B9%E6%B3%95\">合并方法</h2>\n<blockquote>\n<p>设置三个工作指针i，j，k。其中，i和j指示两个待排序序列中当前需比较的元素，k指向辅助数组B中待放置元素的位置。比较A[i]和A[j]的大小关系，如果A[i]小于等于A[j]，则B[k]=A[i]，同时将指针i和k分别推进一步；反之，B[k]=A[j]，同时将指针j和k分别推进一步。如此反复，直到其中一个序列为空。最后，将非空序列中的剩余元素按原次序全部放到辅助数组B的尾部。 </p>\n</blockquote>\n<h2 id=\"%C2%A0%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0\"> 算法描述</h2>\n<h3 id=\"%E9%9D%9E%E9%80%92%E5%BD%92%E5%BD%A2%E5%BC%8F\">非递归形式</h3>\n<pre><code class=\"language-cpp\">void Merge(int A[]，int low，int middle，int high)\n{\nint i,j,k; \nint *B=new int[high-low+1];\ni=low; j=middle+1; k=low;\n  while(i&lt;=middle&amp;&amp;j&lt;=high)  //两个子序列非空\n if(A[i]&lt;=A[j])  B[k++]=A[i++];\n     else  B[k++]=A[j++];\n while (i&lt;=middle) B[k++]=A[i++];\n while (j&lt;=high) B[k++]=A[j++];\n  for(i=low;i&lt;=high;i++) A[i++]=B[i++];\n}</code></pre>\n<h3 id=\"%C2%A0%E9%80%92%E5%BD%92%E5%BD%A2%E5%BC%8F\"> 递归形式</h3>\n<pre><code class=\"language-cpp\">void MergeSort (int A[]，int low，int high)\n{    \n  int middle;\n  if (low&lt;high) \n     {\n        middle=(low+high)/2;   //取中点\n        MergeSort(A,low,middle); \n        MergeSort(A,middle+1,high); \n        Merge(A,low,middle,high); //合并\n     }\n}</code></pre>\n<h2 id=\"%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6\">时间复杂度</h2>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\7b33e49e2c2040be970177e70694efab.png\"/></p>\n<blockquote>\n<p> 求得T(n)=nT(1)+nlogn=n+nlogn，即合并排序算法的时间复杂性为O(nlogn)</p>\n</blockquote>\n<h1 id=\"%E4%B8%89%E3%80%81\">三、快速排序</h1>\n<h2>算法思想</h2>\n<blockquote>\n<p>通过一趟扫描将待排序的元素分割成独立的三个序列：第一个序列中所有元素均不大于基准元素、第二个序列是基准元素、第三个序列中所有元素均不小于基准元素。由于第二个序列已经处于正确位置，因此需要再按此方法对第一个序列和第三个序列分别进行排序，整个排序过程可以递归进行，最终可使整个序列变成有序序列。</p>\n</blockquote>\n<h2 id=\"%E5%BF%AB%E6%8E%92%E5%88%86%E6%B2%BB%E4%BD%93%E7%8E%B0\">快排分治体现</h2>\n<blockquote>\n<p>1、分解  </p>\n<p>在A[low:high]中选定一个元素作为基准元素(P)，以此基准元素为标准将待排序序列划分为两个子序列并使序列A[low:P-1]中所有元素的值均小于等于A[P]，序列A[P+1:high]中所有元素的值均大于等于A[P]。</p>\n<p>2、求解子问题 对子序列A[low:P-1]和A[P+1:high],分别通过递归调用快速排序算法来进行排序。</p>\n<p>3、合并 就地排序。</p>\n</blockquote>\n<p>  对于基准元素P可以采取以下五种方法：</p>\n<blockquote>\n<p>（a）取第一个元素。 （b）取最后一个元素。 （c）取位于中间位置的元素。 （d）“三者取中的规则”。 （e）取位于low和high之间的随机数，用A[P]作为基准元素。即采用随机函数产生一个位于low和high之间的随机数P(low≤P≤high)，用A[P]作为基准，这相当于强迫R[low:high]中的元素是随机分布的。 </p>\n</blockquote>\n<h2 id=\"%C2%A0%E5%88%92%E5%88%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%9E%84%E9%80%A0%E5%AE%9E%E4%BE%8B\"> 划分方法的构造实例</h2>\n<h3 id=\"%E5%9B%BE%E7%A4%BA%E5%8A%A9%E7%90%86%E8%A7%A3\">图示助理解</h3>\n<p>以第一个元素作为基准元素</p>\n<blockquote>\n<p class=\"img-center\"><img alt=\"\" height=\"328\" src=\"image\\e5dc1dbb05c54146a0e51d7626105f6e.png\" width=\"441\"/></p>\n<p class=\"img-center\"><img alt=\"\" height=\"334\" src=\"image\\00c7eefc6df24b62bd0c75c936ba1396.png\" width=\"450\"/></p>\n</blockquote>\n<h3 id=\"%C2%A0%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0\"> 具体代码实现</h3>\n<p>tips：完整代码，可复制后直接使用</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\nusing namespace std;\n//交换函数swap\nvoid swap1(int&amp; a, int&amp; b)\n{\n\tint temp = a; a = b; b = temp;\n}\n//做一个把数组分两半的函数\nint sortSecond(int A[], int low, int high)\n{\n\tint P = A[high];//基数选择右边界\n\twhile (low &lt; high)\n\t{\n\t\twhile (low &lt; high &amp;&amp; A[low] &lt;= P)\n\t\t\tlow++;//左边部分小的跳过\n\t\tif (low &lt; high){\n\t\t\tswap1(A[low], A[high--]);//大的扔到后面并使右边界减一\n\t\t}\n\t\twhile (low&lt;high &amp;&amp; A[high]&gt;=P)\n\t\t\thigh--;//右边大的跳过\n\t\tif (low &lt; high) {\n\t\t\tswap1(A[low++], A[high]);//小的扔到前面并使左边界加一\n\t\t}\n\t}\n\treturn low;//此时low=high\n}\nvoid fastSort(int A[], int low, int high)\n{\n\tif (low &gt; high) return;//递归结束条件 low&gt;high\n\tint v = sortSecond(A, low, high);\n\tfastSort(A, low,  v - 1);//对左区间递归排序\n\tfastSort(A, v + 1, high);//对右区间递归排序\n}\nint main()\n{\n\tint A[9] = {4,3,1,2,4,9,5,8,6};\n\tint len = sizeof(A) / sizeof(A[0]);\n\tcout &lt;&lt; \"排序前数组为：\\t\" &lt;&lt; endl;\n\tfor (int i = 0; i &lt; len; i++)\n\t{\n\t\tcout &lt;&lt; A[i] &lt;&lt; \" \";\n\t}\n\tcout &lt;&lt; endl;\n\tfastSort(A, 0, len-1);//时间复杂度 平均情况O(nlogn)，最坏情况O(n^2)\n\tcout &lt;&lt; \"快速排序后数组为：\\t\" &lt;&lt; endl;\n\tfor (int i = 0; i &lt; len; i++)\n\t{\n\t\tcout &lt;&lt; A[i] &lt;&lt; \" \";\n\t}\n}</code></pre>\n<p>我选择的是以最右边的元素作为基准元素，所以先和基准元素左边的值作比较，如果A[low]&lt;=P，进行low++操作，反之交换数据并让让右边界减一，这是因为右半部分是和P作比较，所以没必要把判断过的数据重复判断，直到low!&lt;high，返回low的值，而且不难想到此时low=high。</p>\n<h3 id=\"%C2%A0%E8%BF%90%E8%A1%8C%E6%95%88%E6%9E%9C\"> 运行效果</h3>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\9147abd899304490a175c228aebaa3f0.png\"/></p>\n<h2>时间复杂度</h2>\n<p> <img alt=\"\" height=\"431\" src=\"image\\62e64140b2a344d096dec8f58b582094.png\" width=\"494\"/></p>\n<h1 id=\"%C2%A0%E7%BB%93%E8%AF%AD\"> 结语</h1>\n<p>有趣的分治法到这里就结束了，分治法是一种很重要的算法。它采取各个击破的技巧来解决一个规模较大的问题，该技巧是很多高效算法的基础，所以希望这篇博客可以被大家收藏，如果有错误或者不规范的地方一定评论出来，我每天都会管理我的博客内容，你的点赞关注评论是我前进的最大动力，加油！！！</p>\n<p></p>\n</div>\n</div>"}