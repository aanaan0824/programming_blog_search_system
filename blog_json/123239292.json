{"blogid": "123239292", "writerAge": "码龄1年", "writerBlogNum": "99", "writerCollect": "144", "writerComment": "13", "writerFan": "155", "writerGrade": "4级", "writerIntegral": "1300", "writerName": "Curz酥", "writerProfileAdress": "writer_image\\profile_123239292.jpg", "writerRankTotal": "15797", "writerRankWeekly": "5879", "writerThumb": "163", "writerVisitNum": "44189", "blog_read_count": "3749", "blog_time": "于 2022-03-02 21:35:05 发布", "blog_title": "C++ map的常用用法（超详细）(*^ｰ^)人(^ｰ^*)", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>C++中的map翻译为<strong>映射，<s>不是地图！！！</s> </strong>也是常用的STL容器。它在算法竞赛中应用十分广泛，因为<strong>map可以将任何基本类型（包括STL容器）映射到任何基本类型（包括STL容器）</strong>，十分灵活。因此我们很有必要来熟练map的常用用法。</p>\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"1%E3%80%81map%E7%9A%84%E5%AE%9A%E4%B9%89-toc\" style=\"margin-left:0px;\"><a href=\"#1%E3%80%81map%E7%9A%84%E5%AE%9A%E4%B9%89\">1、map的定义</a></p>\n<p id=\"2%E3%80%81map%E5%AE%B9%E5%99%A8%E5%86%85%E5%85%83%E7%B4%A0%E7%9A%84%E8%AE%BF%E9%97%AE-toc\" style=\"margin-left:0px;\"><a href=\"#2%E3%80%81map%E5%AE%B9%E5%99%A8%E5%86%85%E5%85%83%E7%B4%A0%E7%9A%84%E8%AE%BF%E9%97%AE\">2、map容器内元素的访问</a></p>\n<p id=\"3%E3%80%81map%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%AE%9E%E4%BE%8B%E8%A7%A3%E6%9E%90%EF%BC%9A-toc\" style=\"margin-left:0px;\"><a href=\"#3%E3%80%81map%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%AE%9E%E4%BE%8B%E8%A7%A3%E6%9E%90%EF%BC%9A\">3、map常用函数实例解析：</a></p>\n<p id=\"1%E3%80%81find()%EF%BC%9A-toc\" style=\"margin-left:80px;\"><a href=\"#1%E3%80%81find%28%29%EF%BC%9A\">1、find()：</a></p>\n<p id=\"2%E3%80%81erase()%3A-toc\" style=\"margin-left:80px;\"><a href=\"#2%E3%80%81erase%28%29%3A\">2、erase():</a></p>\n<p id=\"3%E3%80%81size()%EF%BC%9A-toc\" style=\"margin-left:80px;\"><a href=\"#3%E3%80%81size%28%29%EF%BC%9A\">3、size()：</a></p>\n<p id=\"4%E3%80%81clear()%3A-toc\" style=\"margin-left:80px;\"><a href=\"#4%E3%80%81clear%28%29%3A\">4、clear():</a></p>\n<p id=\"4%E3%80%81%E6%8B%93%E5%B1%95-toc\" style=\"margin-left:0px;\"><a href=\"#4%E3%80%81%E6%8B%93%E5%B1%95\">4、拓展</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h1 id=\"1%E3%80%81map%E7%9A%84%E5%AE%9A%E4%B9%89\">1、map的定义</h1>\n<p>单独定义一个map:</p>\n<pre><code class=\"language-cpp\">map&lt;typename1, typename2&gt; mp;</code></pre>\n<p></p>\n<p>其中，typename1是<strong><span style=\"color:#511b78;\">键</span></strong>的类型，typename2是<strong><span style=\"color:#511b78;\">值</span></strong>的类型。</p>\n<p>注：如果是字符串到整型的映射，<strong>必须使用<span style=\"color:#1c7331;\">string</span>而不能用char数组！</strong></p>\n<pre><code class=\"language-cpp\">map&lt;string, int&gt; mp;</code></pre>\n<p>这是因为char数组作为<strong>数组</strong>，是不能被作为键值的。所以如果想用字符串做映射，必须用<strong><span style=\"color:#1c7331;\">string</span></strong>。</p>\n<p>再举个<s>栗子</s>例子：map的键和值也可以是<span style=\"color:#1a439c;\"><strong>STL容器</strong></span>，例如以下代码将一个<strong><span style=\"color:#1a439c;\">set</span></strong>容器映射到一个字符串：</p>\n<pre><code class=\"language-cpp\">map&lt;set&lt;int&gt;, string&gt; mp;</code></pre>\n<p></p>\n<h1 id=\"2%E3%80%81map%E5%AE%B9%E5%99%A8%E5%86%85%E5%85%83%E7%B4%A0%E7%9A%84%E8%AE%BF%E9%97%AE\">2、map容器内元素的访问</h1>\n<p>一般有两种访问方式：通过<span style=\"color:#1a439c;\"><strong>下标</strong></span>访问或通过<strong><span style=\"color:#1a439c;\">迭代器</span></strong>访问：</p>\n<p>1、通过下标访问：</p>\n<p>和普通数组一样，例如一个定义为<span style=\"color:#511b78;\"><strong><span style=\"background-color:#efedf6;\">map&lt;char, int&gt; mp</span></strong></span>的<strong>map</strong>来说，可以直接使用<span style=\"color:#511b78;\"><strong><span style=\"background-color:#efedf6;\">mp['c']</span></strong></span>的方式来访问它对应的<strong>int</strong>整数。可以直接使用<strong><span style=\"color:#511b78;\"><span style=\"background-color:#efedf6;\">mp['c'] = 20</span></span></strong>这样的方式来赋值：</p>\n<pre><code class=\"language-cpp\">map&lt;char, int&gt; mp; \nmp['c'] = 20;\ncout &lt;&lt; mp['c'];\t//答案输出20</code></pre>\n<p>但是要注意的是，<strong>map</strong>中的<strong><span style=\"color:#511b78;\">键是唯一的</span></strong>，例如以下代码：</p>\n<pre><code class=\"language-cpp\">map&lt;char, int&gt; mp; \nmp['c'] = 20;\nmp['c'] = 30;\t//30覆盖了20 \nmp['c'] = 666; \t//666覆盖了30 \ncout &lt;&lt; mp['c'];\t//答案输出666 </code></pre>\n<p></p>\n<p>2、通过迭代器访问：</p>\n<p><span style=\"color:#1a439c;\"><strong>map迭代器</strong></span>的定义和其他<strong>STL</strong>容器迭代器定义的方式相同：</p>\n<pre><code class=\"language-cpp\">map&lt;typename1, typename2&gt;::iterator it;</code></pre>\n<p>这样就得到了迭代器 <span style=\"color:#ad720d;\"><strong>it </strong></span>。</p>\n<p>map可以使用<strong>it-&gt;first</strong>来访问<span style=\"color:#511b78;\">键</span>，<strong>it-&gt;second</strong>来访问<span style=\"color:#511b78;\">值</span>：</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;map&gt;\nusing namespace std;\nint main(){\n\tmap&lt;char, int&gt; mp; \n\tmp['a'] = 222;\n\tmp['b'] = 333;\t\n\tmp['c'] = 444;\n\tfor(map&lt;char, int&gt;::iterator it = mp.begin(); it != mp.end(); it++){\n\t\tcout &lt;&lt; it-&gt;first;\t \n\t\tcout &lt;&lt; \" \"; \n\t\tcout &lt;&lt; it-&gt;second;\n\t\tcout &lt;&lt; endl;\n\t} \t\n\treturn 0;\n}</code></pre>\n<p>代码输出结果：</p>\n<pre><code class=\"language-cpp\">a 222\nb 333\nc 444</code></pre>\n<p>还有一点要补充，就是<strong>map</strong>会以<span style=\"color:#511b78;\"><strong><span style=\"background-color:#efedf6;\">键</span></strong></span><strong><span style=\"background-color:#efedf6;\">从小到大的顺序自动排序</span></strong>，如：</p>\n<pre><code class=\"language-cpp\">mp['c'] = 222;\nmp['a'] = 333;\t\nmp['b'] = 444;</code></pre>\n<p>顺序输出结果是（即按<strong>a &lt; b &lt; c</strong>的顺序从小到大排序）：</p>\n<pre><code class=\"language-cpp\">a 333\nb 444\nc 222</code></pre>\n<p>上述现象是因为，map内部是由<strong><span style=\"color:#fe2c24;\">红</span>黑<span style=\"color:#1c7331;\">树</span></strong>实现的（<strong>set</strong>也是），在建立映射的过程中，会自动实现从小到大排序功能。</p>\n<p></p>\n<h1 id=\"3%E3%80%81map%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%AE%9E%E4%BE%8B%E8%A7%A3%E6%9E%90%EF%BC%9A\">3、map常用函数实例解析：</h1>\n<h3 id=\"1%E3%80%81find()%EF%BC%9A\">1、find()：</h3>\n<p><strong>find(key)</strong>返回键为<strong>key</strong>映射的迭代器，时间复杂度为O(logN)，N为map中映射的个数：</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;map&gt;\nusing namespace std;\nint main(){\n\tmap&lt;char, int&gt; mp; \n\tmp['a'] = 222;\n\tmp['b'] = 333;\t\n\tmp['c'] = 444;\n\tmap&lt;char, int&gt;::iterator it = mp.find('b');\n\tcout &lt;&lt; it-&gt;first &lt;&lt; \" \" &lt;&lt; it-&gt;second;\n\treturn 0;\n}</code></pre>\n<p>输出结果：</p>\n<pre><code class=\"language-cs\">b 333</code></pre>\n<p></p>\n<h3 id=\"2%E3%80%81erase()%3A\">2、erase():</h3>\n<p><strong>erase()</strong>有两种用法：1、<strong>删除单个元素</strong>。2、<strong>删除一个区间内所有的元素</strong>。</p>\n<p><strong>① 删除单个元素：</strong></p>\n<p><strong><span style=\"background-color:#d4e9d5;\">mp.erase(it)</span></strong>，<strong>it</strong>为需要删除的元素的<strong>迭代器</strong>。时间复杂度为O(1)：</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;map&gt;\nusing namespace std;\nint main(){\n\tmap&lt;char, int&gt; mp; \n\tmp['a'] = 222;\n\tmp['b'] = 333;\t\n\tmp['c'] = 444;\n\tmap&lt;char, int&gt;::iterator it = mp.find('b');\n\tmp.erase(it);\n\tfor(map&lt;char, int&gt;::iterator it = mp.begin(); it != mp.end(); it++){\n\t\tcout &lt;&lt; it-&gt;first &lt;&lt; \" \" &lt;&lt; it-&gt;second &lt;&lt; endl;\n\t}\n\treturn 0;\n}</code></pre>\n<p>输出结果：</p>\n<pre><code class=\"language-javascript\">a 222\nc 444</code></pre>\n<p></p>\n<p><strong><span style=\"background-color:#d4e9d5;\">mp.erase(key)</span></strong>，<strong>key</strong>为要删除的映射的键。时间复杂度O(logN)，N为map内元素的个数：</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;map&gt;\nusing namespace std;\nint main(){\n\tmap&lt;char, int&gt; mp; \n\tmp['a'] = 222;\n\tmp['b'] = 333;\t\n\tmp['c'] = 444;\n\t//map&lt;char, int&gt;::iterator it = mp.find('b');\n\t//mp.erase(it);\n\tmp.erase('b');\n\tfor(map&lt;char, int&gt;::iterator it = mp.begin(); it != mp.end(); it++){\n\t\tcout &lt;&lt; it-&gt;first &lt;&lt; \" \" &lt;&lt; it-&gt;second &lt;&lt; endl;\n\t}\n\treturn 0;\n}</code></pre>\n<p>输出结果：</p>\n<pre><code class=\"language-vbscript\">a 222\nc 444</code></pre>\n<p></p>\n<p><strong>② 删除一个区间内所有的元素：</strong></p>\n<p><strong><span style=\"background-color:#d4e9d5;\">mp.erase(first, last)</span></strong>，其中，<strong>first</strong>为需要删除的区间的<strong>起始迭代器</strong>，<strong>last</strong>为需要删除的区间末尾迭代器的<span style=\"color:#1a439c;\"><strong>下一个</strong></span>地址，<strong>即为删除左闭右开的区间[first, last)</strong>。时间复杂度为O(last - first)：</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;map&gt;\nusing namespace std;\nint main(){\n\tmap&lt;char, int&gt; mp; \n\tmp['a'] = 222;\n\tmp['b'] = 333;\t\n\tmp['c'] = 444;\n\tmap&lt;char, int&gt;::iterator it = mp.find('b');\n\tmp.erase(it, mp.end()); //删除it之后的所有映射，即b 333和 c 444 \n\t//mp.erase(it);\n\t//mp.erase('b');\n\tfor(map&lt;char, int&gt;::iterator it = mp.begin(); it != mp.end(); it++){\n\t\tcout &lt;&lt; it-&gt;first &lt;&lt; \" \" &lt;&lt; it-&gt;second &lt;&lt; endl;\n\t}\n\treturn 0;\n}</code></pre>\n<p>输出结果：</p>\n<pre><code class=\"language-Swift\">a 222</code></pre>\n<p></p>\n<h3 id=\"3%E3%80%81size()%EF%BC%9A\">3、size()：</h3>\n<p><strong><span style=\"background-color:#d4e9d5;\">size()</span></strong>用来获得map中映射的<strong>对数</strong>，复杂度为O(1)。</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;map&gt;\nusing namespace std;\nint main(){\n\tmap&lt;char, int&gt; mp; \n\tmp['a'] = 222;\n\tmp['b'] = 333;\t\n\tmp['c'] = 444;\n\tcout &lt;&lt; mp.size(); \n\treturn 0;\n}</code></pre>\n<p>输出结果：</p>\n<pre><code class=\"language-Delphi\">3</code></pre>\n<p></p>\n<h3 id=\"4%E3%80%81clear()%3A\">4、clear():</h3>\n<p><strong><span style=\"background-color:#d4e9d5;\">clear()</span></strong>用来清空<strong>map</strong>中的所有元素，复杂度为O(N)，N为map中元素个数：</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n#include&lt;map&gt;\nusing namespace std;\nint main(){\n\tmap&lt;char, int&gt; mp; \n\tmp['a'] = 222;\n\tmp['b'] = 333;\t\n\tmp['c'] = 444;\n\tmp.clear();\t//清空map\n\tcout &lt;&lt; mp.size(); \n\treturn 0;\n}</code></pre>\n<p>输出结果：</p>\n<pre><code class=\"language-Lua\">0</code></pre>\n<p></p>\n<h1 id=\"4%E3%80%81%E6%8B%93%E5%B1%95\">4、拓展</h1>\n<p>        <strong>map</strong>的键和值是<strong>唯一</strong>的，如果需要<strong>一个键对应多个值</strong>，就只能用<span style=\"color:#1c7331;\"><strong>multimap</strong></span>。另外，C++11标准新增了<span style=\"color:#1c7892;\"><strong>unordered_map</strong></span>，以<strong>散列</strong>代替<strong>map</strong>内部的红黑树实现，使其可以用来处理只映射而不按<strong>key</strong>排序的需求，速度比<strong>map</strong>要<strong>快得多</strong>。</p>\n<p></p>\n<div id=\"gtx-trans\">\n<div class=\"gtx-trans-icon\"></div>\n</div>\n</div>\n</div>"}