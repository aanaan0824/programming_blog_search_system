{"blogid": "124875846", "writerAge": "码龄4年", "writerBlogNum": "155", "writerCollect": "2435", "writerComment": "2543", "writerFan": "2420", "writerGrade": "6级", "writerIntegral": "5831", "writerName": "Mindtechnist", "writerProfileAdress": "writer_image\\profile_124875846.jpg", "writerRankTotal": "2818", "writerRankWeekly": "414", "writerThumb": "1693", "writerVisitNum": "113891", "blog_read_count": "654", "blog_time": "已于 2022-06-01 15:01:27 修改", "blog_title": "【STL终极奥义❀解耦合思想的实现❀】函数对象、谓词与函数适配器——从for_each、transform、count_if、sort算法源码的角度分析", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<blockquote>\n<h1 id=\"%E5%89%8D%E8%A8%80\" style=\"text-align:center;\">🎈🎈🎈🎈🎈🎈🎈前言🎈🎈🎈🎈🎈🎈🎈</h1>\n<p>📣STL算法为我们提供了一些统一的算法模型，在这些算法模型中，只提供了一个统一的壳子，具体实现什么样的功能由我们通过函数对象或回调函数来实现。这是一种非常重要的思想，统一性思想，而统一的实现就是解耦合，如果不理解这个思想，那么学习STL就像背英语单词，将变得毫无意义。下面将通过for_each、transform、count_if、sort四个算法实例来一步步深入理解这种思想。 </p>\n</blockquote>\n<hr/>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\86d2792174a5431d97f04553c150d779.jpeg\"/>  </p>\n<p id=\"main-toc\">🎮<strong>文章目录</strong>🎮</p>\n<p id=\"%E4%B8%80%E3%80%81%E5%87%86%E5%A4%87%E7%9F%A5%E8%AF%86-toc\" style=\"margin-left:0px;\">🥇<a href=\"#%E4%B8%80%E3%80%81%E5%87%86%E5%A4%87%E7%9F%A5%E8%AF%86\">一、概念解析</a></p>\n<p id=\"%E4%BA%8C%E3%80%81%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4-toc\" style=\"margin-left:0px;\">🥇<a href=\"#%E4%BA%8C%E3%80%81%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4\">二、从源码到实战</a></p>\n<p id=\"1.%E5%BC%95%E5%85%A5%E5%BA%93-toc\" style=\"margin-left:40px;\">🥈<a href=\"#1.%E5%BC%95%E5%85%A5%E5%BA%93\">1. for_each算法与一元函数对象</a></p>\n<p id=\"1.1%20%E6%90%AD%E5%BB%BA%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6-toc\" style=\"margin-left:80px;\">🥉<a href=\"#1.1%20%E6%90%AD%E5%BB%BA%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6\">1.1 搭建测试框架</a></p>\n<p id=\"1.2%20for_each%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-toc\" style=\"margin-left:80px;\">🥉<a href=\"#1.2%20for_each%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90\">1.2 for_each源码分析</a></p>\n<p id=\"1.3%20%E6%A0%B9%E6%8D%AEfor_each%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1-toc\" style=\"margin-left:80px;\">🥉<a href=\"#1.3%20%E6%A0%B9%E6%8D%AEfor_each%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1\">1.3 根据for_each源码实现一元函数对象</a></p>\n<p id=\"2.%20count_if%E7%AE%97%E6%B3%95%E4%B8%8E%E4%B8%80%E5%85%83%E8%B0%93%E8%AF%8D-toc\" style=\"margin-left:40px;\">🥈<a href=\"#2.%20count_if%E7%AE%97%E6%B3%95%E4%B8%8E%E4%B8%80%E5%85%83%E8%B0%93%E8%AF%8D\">2. count_if算法与一元谓词</a></p>\n<p id=\"2.1%20count_if%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-toc\" style=\"margin-left:80px;\">🥉<a href=\"#2.1%20count_if%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90\">2.1 count_if源码分析</a></p>\n<p id=\"2.2%20%E6%A0%B9%E6%8D%AEcount_if%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0%E4%B8%80%E5%85%83%E8%B0%93%E8%AF%8D-toc\" style=\"margin-left:80px;\">🥉<a href=\"#2.2%20%E6%A0%B9%E6%8D%AEcount_if%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0%E4%B8%80%E5%85%83%E8%B0%93%E8%AF%8D\">2.2 根据count_if源码实现一元谓词</a></p>\n<p id=\"3.%C2%A0transform%E7%AE%97%E6%B3%95%E4%B8%8E%E4%BA%8C%E5%85%83%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1-toc\" style=\"margin-left:40px;\">🥈<a href=\"#3.%C2%A0transform%E7%AE%97%E6%B3%95%E4%B8%8E%E4%BA%8C%E5%85%83%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1\">3. transform算法与二元函数对象</a></p>\n<p id=\"3.1%20transform%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-toc\" style=\"margin-left:80px;\">🥉<a href=\"#3.1%20transform%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90\">3.1 transform源码分析</a></p>\n<p id=\"3.2%20%E6%A0%B9%E6%8D%AEtransform%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1-toc\" style=\"margin-left:80px;\">🥉<a href=\"#3.2%20%E6%A0%B9%E6%8D%AEtransform%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1\">3.2 根据transform源码实现函数对象</a></p>\n<p id=\"4.%20sort%E7%AE%97%E6%B3%95%E4%B8%8E%E4%BA%8C%E5%85%83%E8%B0%93%E8%AF%8D-toc\" style=\"margin-left:40px;\">🥈<a href=\"#4.%20sort%E7%AE%97%E6%B3%95%E4%B8%8E%E4%BA%8C%E5%85%83%E8%B0%93%E8%AF%8D\">4. sort算法与二元谓词</a></p>\n<p id=\"4.1%20sort%E7%AE%97%E6%B3%95%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-toc\" style=\"margin-left:80px;\">🥉<a href=\"#4.1%20sort%E7%AE%97%E6%B3%95%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90\">4.1 sort算法源码分析</a></p>\n<p id=\"4.2%20%E6%A0%B9%E6%8D%AEsort%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%85%83%E8%B0%93%E8%AF%8D-toc\" style=\"margin-left:80px;\">🥉<a href=\"#4.2%20%E6%A0%B9%E6%8D%AEsort%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%85%83%E8%B0%93%E8%AF%8D\">4.2 根据sort源码实现二元谓词</a></p>\n<p id=\"5.%20%E5%87%BD%E6%95%B0%E9%80%82%E9%85%8D%E5%99%A8-toc\" style=\"margin-left:40px;\">🥈<a href=\"#5.%20%E5%87%BD%E6%95%B0%E9%80%82%E9%85%8D%E5%99%A8\">5. 函数适配器</a></p>\n<p id=\"%E4%B8%89%E3%80%81%E6%80%BB%E7%BB%93%EF%BC%9ASTL%E6%8F%90%E4%BE%9B%E7%9A%84%E7%BB%9F%E4%B8%80%E6%80%A7%E6%80%9D%E8%80%83-toc\" style=\"margin-left:0px;\">🥇<a href=\"#%E4%B8%89%E3%80%81%E6%80%BB%E7%BB%93%EF%BC%9ASTL%E6%8F%90%E4%BE%9B%E7%9A%84%E7%BB%9F%E4%B8%80%E6%80%A7%E6%80%9D%E8%80%83\">三、STL提供的统一性思考</a></p>\n<p style=\"margin-left:0px;\"><img alt=\"\" src=\"image\\768f5a916f5a480da5b3dc4a317323e3.jpeg\"/></p>\n<hr/>\n<p></p>\n<h1 id=\"%E4%B8%80%E3%80%81%E5%87%86%E5%A4%87%E7%9F%A5%E8%AF%86\"><strong>一、概念解析</strong></h1>\n<ul><li><strong>算法：</strong>STL提供的算法主要包含两大类，一类是不改变所操作容器内容的算法比如计数、搜索、比较等算法；另一类是修改所操作容器内容的算法，比如排序、删除等等。使用STL算法需要包含头文件&lt;algorithm&gt;。</li><li><strong>函数对象：</strong>函数对象是指重载了函数调用操作符()的类，其功能类似于回调函数，函数对象一般用于STL算法中来自定义回调行为。 \n  <ul><li>一元函数对象：重载的operator()函数只有一个参数；</li><li>二元函数对象：重载的operator()函数有两个参数；</li></ul></li><li><strong>谓词：</strong>谓词可以是仿函数（函数对象），也可以是回调函数，它的返回值是bool类型，作为一个判断式。 \n  <ul><li>一元谓词，只有一个参数的谓词；</li><li>二元谓词：含有两个参数的谓词；</li></ul></li><li><strong>函数适配器 ：</strong>有时候算法中的函数对象只接收一元函数对象，但是我们想要实现的功能需要二元函数对象完成，这时我们就可以通过绑定器把一个二元函数对象和一个参数绑定在一起，适配成一元函数对象。使用函数适配器需要包含头文件&lt;functional&gt;。</li><li><strong>预定义函数对象：</strong>STL标准模板库已经提前预定义好的函数对象，比如greater、less等，使用预定义函数对象需要包含头文件&lt;functional&gt;。</li></ul>\n<h1 id=\"%E4%BA%8C%E3%80%81%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4\"><a id=\"_19\"></a>二、从源码到实战</h1>\n<h2 id=\"1.%E5%BC%95%E5%85%A5%E5%BA%93\"><a id=\"1_20\"></a>1. for_each算法与一元函数对象</h2>\n<p>本节目标是使用for_each算法实现遍历容器</p>\n<h3 id=\"1.1%20%E6%90%AD%E5%BB%BA%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6\">1.1 搭建测试框架</h3>\n<p>搭建一个测试框架</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\nusing namespace std;\n\n#include &lt;vector&gt;\n#include &lt;string&gt;\n#include &lt;algorithm&gt; //使用算法\n#include &lt;functional&gt; //使用预定义函数对象和适配器\n\nint main()\n{\n\tvector&lt;string&gt; v1;\n\tv1.push_back(\"hello\");\n\tv1.push_back(\"C++\");\n\tv1.push_back(\"STL\");\n\tv1.push_back(\"!\");\n\tv1.push_back(\"!\");\n\tv1.push_back(\"!\");\n\n    /*在此添加测试代码*/\n\n\tsystem(\"pause\");\n\treturn 0;\n}</code></pre>\n<h3 id=\"1.2%20for_each%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90\">1.2 for_each源码分析</h3>\n<p>首先转到for_each算法源码</p>\n<pre><code class=\"language-cpp\">_Fn for_each(_InIt _First, _InIt _Last, _Fn _Func) { // perform function for each element [_First, _Last)\n\t\t_Adl_verify_range(_First, _Last);\n\t\tauto _UFirst = _Get_unwrapped(_First);\n\t\tconst auto _ULast = _Get_unwrapped(_Last);\n\t\tfor (; _UFirst != _ULast; ++_UFirst) {\n\t\t\t_Func(*_UFirst); //通过源码可知，for_each 的函数对象是一元函数对象\n\t\t}\n\n\t\treturn _Func;\n\t}</code></pre>\n<p>根据源码分析可知，for_each算法接收一个一元函数对象，并返回该对象，它会把传入的容器中的元素一个个的放入回调函数_Func作为函数参数。由此可见，for_each只是提供了一个壳子，这个壳子的功能是把一个容器的所有元素（起始和结束都有我们通过迭代器传入）依次作为参数传给函数对象_Func，而具体对这些元素做什么操作，由我们自己通过回调函数_Func实现。这就是算法统一性和解耦合思想的体现。</p>\n<h3 id=\"1.3%20%E6%A0%B9%E6%8D%AEfor_each%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1\">1.3 根据for_each源码实现一元函数对象</h3>\n<p>根据源码可以分析出回调函数的接口，一个参数，无返回值（或未用到返回值）。</p>\n<pre><code class=\"language-cpp\">//一元函数对象\ntemplate&lt;typename _MyType&gt;\nclass _FroEachClass\n{\npublic:\n\tvoid operator()(_MyType&amp; t)\n\t{\n\t\tcout &lt;&lt; t &lt;&lt; \" \";\n\t\tm_count++;\n\t}\npublic:\n\t_FroEachClass()\n\t{\n\t\tthis-&gt;m_count = 0;\n\t}\npublic:\n\tint get_count()\n\t{\n\t\treturn this-&gt;m_count;\n\t}\nprivate:\n\tint m_count;\n};\n\ntemplate&lt;typename _MyType&gt;\nvoid _FroEachFunc(_MyType&amp; t)\n{\n\tcout &lt;&lt; t &lt;&lt; \" \";\n}</code></pre>\n<p>回调函数和函数对象（类）的区别已经在另一篇文章中分析过了，函数对象可以有自己的属性和方法，因为类的封装特性，可以把属性方法一并传入作为函数参数，详情可见</p>\n<p><a href=\"https://blog.csdn.net/qq_43471489/article/details/123633464?spm=1001.2014.3001.5501\" title=\"【STL算法】for_each源码刨析及函数对象本质刨析https://blog.csdn.net/qq_43471489/article/details/123633464?spm=1001.2014.3001.5501\">【STL算法】for_each源码刨析及函数对象本质刨析https://blog.csdn.net/qq_43471489/article/details/123633464?spm=1001.2014.3001.5501</a>我们在主函数添加如下测试代码</p>\n<div>\n<pre><code class=\"language-cpp\">_FroEachClass&lt;string&gt; for_each_obj;\nfor_each_obj = for_each(v1.begin(), v1.end(), for_each_obj);\ncout &lt;&lt; \"\\nvector size: \" &lt;&lt; for_each_obj.get_count() &lt;&lt; endl;\nfor_each(v1.begin(), v1.end(), _FroEachFunc&lt;string&gt;);\ncout &lt;&lt; endl;</code></pre>\n</div>\n<p>编译运行</p>\n<div>\n<p><img alt=\"\" height=\"97\" src=\"image\\48af966acba74228852338c0741359b5.png\" width=\"267\"/>​</p>\n</div>\n<p> 可以看到，使用函数对象和回调函数都能实现遍历容器，使用函数对象可以通过私有属性记录容器中元素个数。</p>\n<h2 id=\"2.%20count_if%E7%AE%97%E6%B3%95%E4%B8%8E%E4%B8%80%E5%85%83%E8%B0%93%E8%AF%8D\">2. count_if算法与一元谓词</h2>\n<p>本节目标是使用count_if算法计算某个元素的个数</p>\n<h3 id=\"2.1%20count_if%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90\">2.1 count_if源码分析</h3>\n<p>通过VS转到源码功能</p>\n<div>\n<pre><code class=\"language-cpp\">template &lt;class _InIt, class _Pr&gt;\n_NODISCARD _Iter_diff_t&lt;_InIt&gt; count_if(_InIt _First, _InIt _Last, _Pr _Pred) { // count elements satisfying _Pred\n\t_Adl_verify_range(_First, _Last);\n\tauto _UFirst = _Get_unwrapped(_First);\n\tconst auto _ULast = _Get_unwrapped(_Last);\n\t_Iter_diff_t&lt;_InIt&gt; _Count = 0;\n\tfor (; _UFirst != _ULast; ++_UFirst) {\n\t\tif (_Pred(*_UFirst)) { //由此可见_Pred返回的应该是一个bool\n\t\t\t++_Count;\n\t\t}\n\t}\n\n\treturn _Count;\n}</code></pre>\n</div>\n<p>通过源码分析可知，count_if算法提供了这样一个壳子，他会把我们传入的容器迭代器范围内的元素依次传递给函数对象_Pred，并且函数对象_Pred返回一个bool类型，由此可知count_if的参数是一个一元谓词</p>\n<div>\n<pre><code class=\"language-cpp\">if (_Pred(*_UFirst)) { //由此可见_Pred返回的应该是一个bool</code></pre>\n</div>\n<p>如果这个返回结果为真，即传递给函数对象_Pred的参数（容器元素）符合条件，就进行一次计数。最终count_if返回这个计数值。</p>\n<h3 id=\"2.2%20%E6%A0%B9%E6%8D%AEcount_if%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0%E4%B8%80%E5%85%83%E8%B0%93%E8%AF%8D\">2.2 根据count_if源码实现一元谓词</h3>\n<p>根据上一小节分析可知，我们要写的谓词接口形式为bool类型返回值，一个参数，代码如下：</p>\n<div>\n<pre><code class=\"language-cpp\">template&lt;typename _MyType&gt;\nclass _CountOfClass\n{\npublic:\n\tbool operator()(_MyType&amp; t)\n\t{\n\t\treturn (t == this-&gt;m_data);\n\t}\npublic:\n\t_CountOfClass(_MyType&amp; t)\n\t{\n\t\tthis-&gt;m_data = t;\n\t}\nprivate:\n\t_MyType m_data;\n};\n\ntemplate&lt;typename _MyType&gt;\nbool _CountOfFunc(_MyType&amp; t1)\n{\n\tstring s = \"!\";\n\treturn (t1 == s);\n}</code></pre>\n</div>\n<p>然后再主函数继续添加如下测试代码，我们使用count_if计算容器中“!”出现的次数</p>\n<div>\n<pre><code class=\"language-cpp\">string s(\"!\");\nint count = count_if(v1.begin(), v1.end(), _CountOfClass&lt;string&gt;(s));\ncout &lt;&lt; \"count : \" &lt;&lt; count &lt;&lt; endl;\ncount = count_if(v1.begin(), v1.end(), _CountOfFunc&lt;string&gt;); //使用回调函数也可以编译通过\ncout &lt;&lt; \"count : \" &lt;&lt; count &lt;&lt; endl;</code></pre>\n</div>\n<p>编译运行</p>\n<div>\n<p><img alt=\"\" height=\"137\" src=\"image\\a2a4ba808b8a4eab859a773176f39103.png\" width=\"291\"/>​</p>\n</div>\n<p> 通过运行结果看到，容器中总共3个叹号。</p>\n<h2 id=\"3.%C2%A0transform%E7%AE%97%E6%B3%95%E4%B8%8E%E4%BA%8C%E5%85%83%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1\">3. transform算法与二元函数对象</h2>\n<p>本节目标，使用transform算法实现把两个容器内容相加放入第三个容器。</p>\n<h3 id=\"3.1%20transform%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90\">3.1 transform源码分析</h3>\n<p>使用VS查看源码</p>\n<div>\n<pre><code class=\"language-cpp\">template &lt;class _InIt1, class _InIt2, class _OutIt, class _Fn&gt;\n_OutIt transform(const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, _OutIt _Dest, _Fn _Func) {\n\t\t// transform [_First1, _Last1) and [_First2, ...) with _Func\n\t_Adl_verify_range(_First1, _Last1);\n\tauto _UFirst1 = _Get_unwrapped(_First1);\n\tconst auto _ULast1 = _Get_unwrapped(_Last1);\n\tconst auto _Count = _Idl_distance&lt;_InIt1&gt;(_UFirst1, _ULast1);\n\tauto _UFirst2 = _Get_unwrapped_n(_First2, _Count);\n\tauto _UDest = _Get_unwrapped_n(_Dest, _Count);\n\tfor (; _UFirst1 != _ULast1; ++_UFirst1, (void) ++_UFirst2, ++_UDest) {\n\t\t*_UDest = _Func(*_UFirst1, *_UFirst2); //把两个参数_UFirst1和_UFirst2的元素传入_Func返回结果放入_UDest\n\t}\n\n\t_Seek_wrapped(_Dest, _UDest);\n\treturn _Dest;\n}</code></pre>\n</div>\n<p>这只是transform算法的一个重载模型之一，首先传入参数是两个容器的输入迭代器_First1、_Last1、_First2，其中第一个容器给出了起始和结束位置的迭代器，用来限定操作的容器范围，输出迭代器_Dest。通过这条语句可以看到</p>\n<div>\n<pre><code class=\"language-cpp\">*_UDest = _Func(*_UFirst1, *_UFirst2); //把两个参数_UFirst1和_UFirst2的元素传入_Func返回结果放入_UDest</code></pre>\n</div>\n<p>transform算法把两个输入迭代器指示的容器元素传入回调函数_Func作为参数，并返回一个元素装入到输出迭代器_Dest所指示的容器位置中。由此分析可知，transform算法提供了这样一个模型，把两个容器中的元素进行操作，操作结果存放到第三个容器中，所以_Func的返回值应该是和容器类型同类型的一个元素，操作的元素个数由第一个容器的迭代器指定，最终transform返回第三个容器的迭代器位置。transform需要的是一个二元函数对象。</p>\n<h3 id=\"3.2%20%E6%A0%B9%E6%8D%AEtransform%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1\">3.2 根据transform源码实现函数对象</h3>\n<p>根据源码分析，回调函数接口应为二元函数对象，函数返回值为一个元素，代码如下：</p>\n<div>\n<pre><code class=\"language-cpp\">template&lt;typename _MyType&gt;\nclass _TransformClass\n{\npublic:\n\t_MyType operator()(_MyType&amp; t1, _MyType&amp; t2)\n\t{\n\t\treturn (t1 + t2);\n\t}\n};\n\ntemplate&lt;typename _MyType&gt;\n_MyType _TransformFunc(_MyType&amp; t1, _MyType&amp; t2)\n{\n\treturn (t1 + t2);\n}</code></pre>\n</div>\n<p>继续在主函数添加测试代码如下：</p>\n<div>\n<pre><code class=\"language-cpp\">vector&lt;string&gt; v3(for_each_obj.get_count() + 1);\nv3[6] = \"end\";\ntransform(v1.begin(), v1.end(), v1.begin(), v3.begin(), _TransformClass&lt;string&gt;());\nfor_each(v3.begin(), v3.end(), _FroEachClass&lt;string&gt;());\ncout &lt;&lt; endl;\nvector&lt;string&gt;::iterator it = transform(v1.begin(), v1.end(), v1.begin(), v3.begin(), _TransformFunc&lt;string&gt;);\nfor_each(v3.begin(), v3.end(), _FroEachClass&lt;string&gt;());\ncout &lt;&lt; endl;\ncout &lt;&lt; *it &lt;&lt; endl; //transform 返回的是: v1 + v2 最后一个元素相加后，后面的那个位置的迭代器</code></pre>\n</div>\n<p>编译运行</p>\n<div>\n<p><img alt=\"\" height=\"199\" src=\"image\\9247b3e5a2544fa7bfb165b403260ebe.png\" width=\"441\"/>​</p>\n</div>\n<p> 通过输出结果看到，已经实现了把容器1和2相加存入第三个容器的功能。我们在源码分析中说到，transform返回容器3的输出迭代器，那么返回的迭代器位置究竟在哪呢，我们在程序进行了测试，也就是这几句程序</p>\n<div>\n<pre><code class=\"language-cpp\">vector&lt;string&gt;::iterator it = transform(v1.begin(), v1.end(), v1.begin(), v3.begin(), _TransformFunc&lt;string&gt;);\nfor_each(v3.begin(), v3.end(), _FroEachClass&lt;string&gt;());\ncout &lt;&lt; endl;\ncout &lt;&lt; *it &lt;&lt; endl; //transform 返回的是: v1 + v2 最后一个元素相加后，后面的那个位置的迭代器</code></pre>\n</div>\n<p>通过对返回的迭代器指向的内容打印可以得出结论，transform算法返回的是v1.end()减去v1.begin()后面的一个位置，加入容器v1有6个元素，那么transform返回的应该是v3的第7个位置，具体可见程序中的说明。</p>\n<h2 id=\"4.%20sort%E7%AE%97%E6%B3%95%E4%B8%8E%E4%BA%8C%E5%85%83%E8%B0%93%E8%AF%8D\">4. sort算法与二元谓词</h2>\n<p>本节目标是通过sort算法实现排序功能。</p>\n<h3 id=\"4.1%20sort%E7%AE%97%E6%B3%95%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90\">4.1 sort算法源码分析</h3>\n<p>源码如下：</p>\n<div>\n<pre><code class=\"language-cpp\">template &lt;class _RanIt, class _Pr&gt;\nvoid sort(const _RanIt _First, const _RanIt _Last, _Pr _Pred) { // order [_First, _Last), using _Pred\n\t_Adl_verify_range(_First, _Last);\n\tconst auto _UFirst = _Get_unwrapped(_First);\n\tconst auto _ULast = _Get_unwrapped(_Last);\n\t_Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred));\n}</code></pre>\n</div>\n<div>\n<pre><code class=\"language-cpp\">template &lt;class _RanIt, class _Pr&gt;\nvoid _Sort_unchecked(_RanIt _First, _RanIt _Last, _Iter_diff_t&lt;_RanIt&gt; _Ideal, _Pr _Pred) {\n    // order [_First, _Last), using _Pred\n    _Iter_diff_t&lt;_RanIt&gt; _Count;\n    while (_ISORT_MAX &lt; (_Count = _Last - _First) &amp;&amp; 0 &lt; _Ideal) { // divide and conquer by quicksort\n        auto _Mid = _Partition_by_median_guess_unchecked(_First, _Last, _Pred);\n        // TRANSITION, VSO#433486\n        _Ideal = (_Ideal &gt;&gt; 1) + (_Ideal &gt;&gt; 2); // allow 1.5 log2(N) divisions\n\n        if (_Mid.first - _First &lt; _Last - _Mid.second) { // loop on second half\n            _Sort_unchecked(_First, _Mid.first, _Ideal, _Pred);\n            _First = _Mid.second;\n        } else { // loop on first half\n            _Sort_unchecked(_Mid.second, _Last, _Ideal, _Pred);\n            _Last = _Mid.first;\n        }\n    }\n\n    if (_ISORT_MAX &lt; _Count) { // heap sort if too many divisions\n        _Make_heap_unchecked(_First, _Last, _Pred);\n        _Sort_heap_unchecked(_First, _Last, _Pred);\n    } else if (2 &lt;= _Count) {\n        _Insertion_sort_unchecked(_First, _Last, _Pred); // small\n    }\n}</code></pre>\n</div>\n<p>首先分析源码，sort算法实现的是排序功能，我们可以按自己的排序规则进行排序，比如对一个people类按照成员变量年龄进行排序，一个成绩管理系统，按照成绩排序等，另外STL还提供了预定义函数对象供我们使用，比如less、greater等。sort算法接收的是一个二元谓词。</p>\n<h3 id=\"4.2%20%E6%A0%B9%E6%8D%AEsort%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%85%83%E8%B0%93%E8%AF%8D\">4.2 根据sort源码实现二元谓词</h3>\n<p>我们实现从大到小排序，代码如下：</p>\n<div>\n<pre><code class=\"language-cpp\">//二元谓词\ntemplate&lt;typename _MyType&gt;\nclass _SortClass\n{\npublic:\n\tbool operator()(_MyType&amp; t1, _MyType&amp; t2)\n\t{\n\t\treturn (t1 &gt; t2);\n\t}\n};\n\ntemplate&lt;typename _MyType&gt;\nbool _SortFunc(_MyType&amp; t1, _MyType&amp; t2)\n{\n\treturn (t1 &gt; t2);\n}</code></pre>\n</div>\n<p>在主函数添加如下测试代码：</p>\n<div>\n<pre><code class=\"language-cpp\">v4.push_back(1);\nsort(v4.begin(), v4.end(), _SortClass&lt;int&gt;());\nfor_each(v4.begin(), v4.end(), _FroEachClass&lt;int&gt;());\ncout &lt;&lt; endl;\nsort(v4.begin(), v4.end(), _SortFunc&lt;int&gt;);\nfor_each(v4.begin(), v4.end(), _FroEachClass&lt;int&gt;());\ncout &lt;&lt; endl;</code></pre>\n</div>\n<p>编译运行</p>\n<div>\n<p><img alt=\"\" height=\"231\" src=\"image\\5570a3633d3d48659bf2be57b6732a4e.png\" width=\"412\"/>​</p>\n</div>\n<p> 我们还可以使用预定义函数对象实现从大到小排序</p>\n<div>\n<pre><code class=\"language-cpp\">sort(v4.begin(), v4.end(), greater&lt;int&gt;()); //使用预定义函数对象\nfor_each(v4.begin(), v4.end(), _FroEachClass&lt;int&gt;());\ncout &lt;&lt; endl;</code></pre>\n</div>\n<div>\n<p><img alt=\"\" height=\"252\" src=\"image\\d5b32b9bdffa498b9e86cddd21775efe.png\" width=\"461\"/>​</p>\n</div>\n<p> 通过自定义的谓词，我们可以实现自己的数据类型的排序，这就是sort算法为我们提供的统一个排序模型。</p>\n<h2 id=\"5.%20%E5%87%BD%E6%95%B0%E9%80%82%E9%85%8D%E5%99%A8\">5. 函数适配器</h2>\n<p>有时候算法中的函数对象只接收一元函数对象，但是我们想要实现的功能需要二元函数对象完成，这时我们就可以通过绑定器把一个二元函数对象和一个参数绑定在一起，适配成一元函数对象。比如，我们要用count_if实现计算int型容器中大于5的元素的个数，我们可以借用预定义函数对象greater，但是greater是一个二元谓词，我们在第二节分析过count_if源码，count_if接收的是一个一元函数对象，这时我们就可以使用绑定器bind2nd把元素5绑定到greater的第二个参数位置，把他适配为一元函数对象。</p>\n<p>在主函数添加如下测试代码：</p>\n<div>\n<pre><code class=\"language-cpp\">int n = 5;\nint num = count_if(v4.begin(), v4.end(), bind2nd(greater&lt;int&gt;(), n));\n//count_if 接收一元函数对象或一元谓词，我们借用二元谓词greater实现计算大于5的元素个数\n//这时可以使用绑定器 bind2nd 把预定义函数对象greater和一个参数n适配为一元谓词\ncout &lt;&lt; \"greater \" &lt;&lt; n &lt;&lt; \" : \" &lt;&lt; num &lt;&lt; endl;</code></pre>\n</div>\n<p>编译运行</p>\n<div>\n<p><img alt=\"\" height=\"249\" src=\"image\\4c29bf49156a4099b292979934030182.png\" width=\"482\"/>​</p>\n</div>\n<p> 大于5的个数为5，结果正确。</p>\n<p>通过这个例子我们可以再一次体会到STL算法为我们提供的统一性，我们使用count_if算法完成了两个自己的算法，一个是计算容器中某元素的个数，一个是计算容器中大于某元素的个数。只要是我们的回到调函数功能和参数模型能匹配算法提供的模型，就可以套用该算法，这就是统一性。</p>\n<h1 id=\"%E4%B8%89%E3%80%81%E6%80%BB%E7%BB%93%EF%BC%9ASTL%E6%8F%90%E4%BE%9B%E7%9A%84%E7%BB%9F%E4%B8%80%E6%80%A7%E6%80%9D%E8%80%83\">三、STL提供的统一性思考</h1>\n<p>算法的统一性延伸至STL的统一性思考</p>\n<div>\n<pre><code class=\"language-cpp\">_OutIt transform(const _InIt _First, const _InIt _Last, _OutIt _Dest, _Fn _Func)\n_OutIt transform(const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, _OutIt _Dest, _Fn _Func)\n    //_First1 : 容器1的输入迭代器begin()   _Last1 : 容器1的输入迭代器end()\n    //_First2 : 容器2的输入迭代器begin()\n    //_Dest : 输出迭代器\n    //_Func : 函数对象/回调函数\n//算法的核心思想：\n    //transform提供了一个统一的操作，把容器1和容器2的元素当作输入，把操作结果放到容器3中\n    //容器中的元素遍历由迭代器提供\n    //容器1和容器2之间的操作由函数对象提供\n    //通过算法实现了数据类型和具体算法的分离\n    //transform只提供一个把容器1和容器2的元素运算后放入容器3这个统一模型，这个算法是通用的\n    //而具体的算法，是加减乘除还是其他运算由函数对象来提供（由我们自己编写）\n    //输入输出的数据类型由容器来决定，容器和算法之间通过迭代器连接\n    \n    //容器实现了数据类型和容器本身的分离，比如我们通过vector可以放入int\\string\\class等\n    //容器提供了统一的一个模型，里面的元素只是元素本身，不用管是什么类型，他就是一个元素\n    \n    //迭代器提供了遍历容器的统一方法，不管什么容器vector\\deque\\queue\\set\\map，也不管\n    //容器中装的什么元素int\\string\\class，都可以使用迭代器进行遍历，迭代器总是指向容器中的一个元素\n    //迭代器这种统一的遍历方法为算法的统一性提供了基础\n    \n    //算法提供了算法本身的统一性，算法本身提供一个模型，具体操作由函数对象\\回调函数提供\n    //回调函数实现了任务实现与任务调用的分离\n    //容器和算法之间由迭代器提连接的桥梁</code></pre>\n</div>\n<hr/>\n<p style=\"text-align:center;\"> <img alt=\"\" src=\"https://img-blog.csdnimg.cn/462efc7ff35d428086e72dd681159d8d.gif\"/></p>\n<hr/>\n<p><strong>🧧附：完整代码🧧</strong></p>\n<div>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\nusing namespace std;\n\n#include &lt;vector&gt;\n#include &lt;string&gt;\n#include &lt;algorithm&gt; //使用算法\n#include &lt;functional&gt; //使用预定义函数对象和适配器\n\n//一元函数对象\ntemplate&lt;typename _MyType&gt;\nclass _FroEachClass\n{\npublic:\n\tvoid operator()(_MyType&amp; t)\n\t{\n\t\tcout &lt;&lt; t &lt;&lt; \" \";\n\t\tm_count++;\n\t}\npublic:\n\t_FroEachClass()\n\t{\n\t\tthis-&gt;m_count = 0;\n\t}\npublic:\n\tint get_count()\n\t{\n\t\treturn this-&gt;m_count;\n\t}\nprivate:\n\tint m_count;\n};\n\ntemplate&lt;typename _MyType&gt;\nvoid _FroEachFunc(_MyType&amp; t)\n{\n\tcout &lt;&lt; t &lt;&lt; \" \";\n}\n\n//一元谓词\ntemplate&lt;typename _MyType&gt;\nclass _CountOfClass\n{\npublic:\n\tbool operator()(_MyType&amp; t)\n\t{\n\t\treturn (t == this-&gt;m_data);\n\t}\npublic:\n\t_CountOfClass(_MyType&amp; t)\n\t{\n\t\tthis-&gt;m_data = t;\n\t}\nprivate:\n\t_MyType m_data;\n};\n\ntemplate&lt;typename _MyType&gt;\nbool _CountOfFunc(_MyType&amp; t1)\n{\n\tstring s = \"!\";\n\treturn (t1 == s);\n}\n\n//二元函数对象\ntemplate&lt;typename _MyType&gt;\nclass _TransformClass\n{\npublic:\n\t_MyType operator()(_MyType&amp; t1, _MyType&amp; t2)\n\t{\n\t\treturn (t1 + t2);\n\t}\n};\n\ntemplate&lt;typename _MyType&gt;\n_MyType _TransformFunc(_MyType&amp; t1, _MyType&amp; t2)\n{\n\treturn (t1 + t2);\n}\n\n//二元谓词\ntemplate&lt;typename _MyType&gt;\nclass _SortClass\n{\npublic:\n\tbool operator()(_MyType&amp; t1, _MyType&amp; t2)\n\t{\n\t\treturn (t1 &gt; t2);\n\t}\n};\n\ntemplate&lt;typename _MyType&gt;\nbool _SortFunc(_MyType&amp; t1, _MyType&amp; t2)\n{\n\treturn (t1 &gt; t2);\n}\n\nint main()\n{\n\tvector&lt;string&gt; v1;\n\tv1.push_back(\"hello\");\n\tv1.push_back(\"C++\");\n\tv1.push_back(\"STL\");\n\tv1.push_back(\"!\");\n\tv1.push_back(\"!\");\n\tv1.push_back(\"!\");\n\n\t/*\n\t_Fn for_each(_InIt _First, _InIt _Last, _Fn _Func) { // perform function for each element [_First, _Last)\n\t\t_Adl_verify_range(_First, _Last);\n\t\tauto _UFirst = _Get_unwrapped(_First);\n\t\tconst auto _ULast = _Get_unwrapped(_Last);\n\t\tfor (; _UFirst != _ULast; ++_UFirst) {\n\t\t\t_Func(*_UFirst); //通过源码可知，for_each 的函数对象是一元函数对象\n\t\t}\n\n\t\treturn _Func;\n\t}\n\t*/\n\t//通过 for_each 算法实现遍历容器  --- 使用一元函数对象\n\t_FroEachClass&lt;string&gt; for_each_obj;\n\tfor_each_obj = for_each(v1.begin(), v1.end(), for_each_obj);\n\tcout &lt;&lt; \"\\nvector size: \" &lt;&lt; for_each_obj.get_count() &lt;&lt; endl;\n\tfor_each(v1.begin(), v1.end(), _FroEachFunc&lt;string&gt;);\n\tcout &lt;&lt; endl;\n\t\n\t/*\n\ttemplate &lt;class _InIt, class _Pr&gt;\n\t_NODISCARD _Iter_diff_t&lt;_InIt&gt; count_if(_InIt _First, _InIt _Last, _Pr _Pred) { // count elements satisfying _Pred\n\t\t_Adl_verify_range(_First, _Last);\n\t\tauto _UFirst = _Get_unwrapped(_First);\n\t\tconst auto _ULast = _Get_unwrapped(_Last);\n\t\t_Iter_diff_t&lt;_InIt&gt; _Count = 0;\n\t\tfor (; _UFirst != _ULast; ++_UFirst) {\n\t\t\tif (_Pred(*_UFirst)) { //由此可见_Pred返回的应该是一个bool\n\t\t\t\t++_Count;\n\t\t\t}\n\t\t}\n\n\t\treturn _Count;\n\t}\n\t*/\n\t//用count_if计算 某个元素的个数  ---  使用一元谓词\n\tstring s(\"!\");\n\tint count = count_if(v1.begin(), v1.end(), _CountOfClass&lt;string&gt;(s));\n\tcout &lt;&lt; \"count : \" &lt;&lt; count &lt;&lt; endl;\n\tcount = count_if(v1.begin(), v1.end(), _CountOfFunc&lt;string&gt;); //使用回调函数也可以编译通过\n\tcout &lt;&lt; \"count : \" &lt;&lt; count &lt;&lt; endl;\n\n\t/*\n\ttemplate &lt;class _InIt1, class _InIt2, class _OutIt, class _Fn&gt;\n\t_OutIt transform(const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, _OutIt _Dest, _Fn _Func) {\n\t\t// transform [_First1, _Last1) and [_First2, ...) with _Func\n\t\t_Adl_verify_range(_First1, _Last1);\n\t\tauto _UFirst1 = _Get_unwrapped(_First1);\n\t\tconst auto _ULast1 = _Get_unwrapped(_Last1);\n\t\tconst auto _Count = _Idl_distance&lt;_InIt1&gt;(_UFirst1, _ULast1);\n\t\tauto _UFirst2 = _Get_unwrapped_n(_First2, _Count);\n\t\tauto _UDest = _Get_unwrapped_n(_Dest, _Count);\n\t\tfor (; _UFirst1 != _ULast1; ++_UFirst1, (void) ++_UFirst2, ++_UDest) {\n\t\t\t*_UDest = _Func(*_UFirst1, *_UFirst2); //把两个参数_UFirst1和_UFirst2的元素传入_Func返回结果放入_UDest\n\t\t}\n\n\t\t_Seek_wrapped(_Dest, _UDest);\n\t\treturn _Dest;\n\t}\n\t*/\n\t//用transform把两个容器内容相加放入第三个容器  ---  使用二元函数对象\n\tvector&lt;string&gt; v3(for_each_obj.get_count() + 1);\n\tv3[6] = \"end\";\n\ttransform(v1.begin(), v1.end(), v1.begin(), v3.begin(), _TransformClass&lt;string&gt;());\n\tfor_each(v3.begin(), v3.end(), _FroEachClass&lt;string&gt;());\n\tcout &lt;&lt; endl;\n\tvector&lt;string&gt;::iterator it = transform(v1.begin(), v1.end(), v1.begin(), v3.begin(), _TransformFunc&lt;string&gt;);\n\tfor_each(v3.begin(), v3.end(), _FroEachClass&lt;string&gt;());\n\tcout &lt;&lt; endl;\n\tcout &lt;&lt; *it &lt;&lt; endl; //transform 返回的是: v1 + v2 最后一个元素相加后，后面的那个位置的迭代器\n\n\t/*\n\ttemplate &lt;class _RanIt, class _Pr&gt;\n\tvoid sort(const _RanIt _First, const _RanIt _Last, _Pr _Pred) { // order [_First, _Last), using _Pred\n\t\t_Adl_verify_range(_First, _Last);\n\t\tconst auto _UFirst = _Get_unwrapped(_First);\n\t\tconst auto _ULast = _Get_unwrapped(_Last);\n\t\t_Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred));\n\t}\n\t*/\n\t//用sort算法实现排序，使用二元谓词\n\tvector&lt;int&gt; v4;\n\tfor (int i = 0; i &lt; 10; i++)\n\t{\n\t\t//v4.push_back(rand());\n\t\tv4.push_back(i + 1);\n\t}\n\tv4.push_back(1);\n\tsort(v4.begin(), v4.end(), _SortClass&lt;int&gt;());\n\tfor_each(v4.begin(), v4.end(), _FroEachClass&lt;int&gt;());\n\tcout &lt;&lt; endl;\n\tsort(v4.begin(), v4.end(), _SortFunc&lt;int&gt;);\n\tfor_each(v4.begin(), v4.end(), _FroEachClass&lt;int&gt;());\n\tcout &lt;&lt; endl;\n\tsort(v4.begin(), v4.end(), greater&lt;int&gt;()); //使用预定义函数对象\n\tfor_each(v4.begin(), v4.end(), _FroEachClass&lt;int&gt;());\n\tcout &lt;&lt; endl;\n\n\t//使用 count_if 计算大于5的元素的个数\n\tint n = 5;\n\tint num = count_if(v4.begin(), v4.end(), bind2nd(greater&lt;int&gt;(), n));\n\t//count_if 接收一元函数对象或一元谓词，我们借用二元谓词greater实现计算大于5的元素个数\n\t//这时可以使用绑定器 bind2nd 把预定义函数对象greater和一个参数n适配为一元谓词\n\tcout &lt;&lt; \"greater \" &lt;&lt; n &lt;&lt; \" : \" &lt;&lt; num &lt;&lt; endl;\n\t\n\tsystem(\"pause\");\n\treturn 0;\n}</code></pre>\n</div>\n<hr/>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/dc54c1e3737a478eaeb78dfd2d1820f9.gif\"/></p>\n</div>\n</div>"}