{"blogid": "126677362", "writerAge": "码龄2年", "writerBlogNum": "93", "writerCollect": "5047", "writerComment": "5468", "writerFan": "4918", "writerGrade": "7级", "writerIntegral": "13556", "writerName": "一名不会打字的程序员", "writerProfileAdress": "writer_image\\profile_126677362.jpg", "writerRankTotal": "786", "writerRankWeekly": "73", "writerThumb": "5267", "writerVisitNum": "79367", "blog_read_count": "90", "blog_time": "于 2022-09-06 10:15:00 发布", "blog_title": "【C++难点收录】“C++难?，你真的理解了这些吗？”《常见面试题》【二】", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-github-gist\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p></p>\n<div class=\"toc\">\n<h3>文章目录</h3>\n<ul><li><ul><li><ul><li><a href=\"#_1\">虚继承</a></li><li><a href=\"#_21\">虚函数</a></li><li><a href=\"#_35\">重写（覆盖）</a></li><li><a href=\"#_69\">隐藏</a></li></ul>\n</li></ul>\n</li><li><a href=\"#_101\">多态</a></li><li><ul><li><a href=\"#_107\">纯虚函数</a></li><li><a href=\"#_124\">虚函数表</a></li></ul>\n</li><li><a href=\"#set_140\">set</a></li><li><a href=\"#map_142\">map</a></li><li><a href=\"#_209\">面试题</a></li></ul>\n</div>\n<p></p>\n<h3><a id=\"_1\"></a>虚继承</h3>\n<p>概念：解决菱形继承的数据冗余和二义性</p>\n<p>原理：将虚基类对现象放到公共位置（vs是放到整个对象尾部），虚基表中存偏移量，来计算虚基类的位置；</p>\n<p>没加virtual之前</p>\n<p><img alt=\"动画18\" src=\"https://img-blog.csdnimg.cn/img_convert/5e9c5d5a6c6a69961dc16c866bfbb837.gif\"/></p>\n<p>加了virtual只后的内存情况</p>\n<p><img alt=\"动画17\" src=\"https://img-blog.csdnimg.cn/img_convert/b32b9442c744273b8f52552de542ba06.gif\"/></p>\n<p><img alt=\"image-20220830080912152\" src=\"image\\cc9176fd20abbcb279a6572b8e3256bd.png\"/></p>\n<p>虚继承中，将A通常叫做虚基类</p>\n<p><img alt=\"image-20220830081837765\" src=\"image\\af238f28582149dc7056bf9f61b8b87c.png\"/></p>\n<h3><a id=\"_21\"></a>虚函数</h3>\n<p>概念：虚函数重写是多态条件之一</p>\n<p>多态原理：虚函数地址放到对象的虚表（虚函数表）中，多态指向谁调用本质是运行到对象虚表找到要调用的虚函数</p>\n<p>析构函数可以是虚函数吗？什么场景下析构函数是虚函数？</p>\n<blockquote>\n<p>答：可以，并且最好把基类的析构函数定义成虚函数</p>\n</blockquote>\n<p><img alt=\"image-20220830075712354\" src=\"image\\18090d0f5f1a410ceb0814b3ae554584.png\"/></p>\n<p><strong>总结：虚函数虚基类两个地方都用到virtual关键字，它们之间没有一点关联，不要联系到一起。</strong></p>\n<h3><a id=\"_35\"></a>重写（覆盖）</h3>\n<p>满足重写，必须接口一致，并且是虚函数继承，重写虚函数的继承是一种<strong>接口继承</strong>，什么是接口继承呢？</p>\n<p>以下程序输出结果是（） ：</p>\n<pre><code class=\"prism language-c++\">class A\n{\npublic:\n\tvirtual void func(int val = 1){ std::cout&lt;&lt;\"A-&gt;\"&lt;&lt; val &lt;&lt;std::endl;}\n\tvirtual void test()//void test(A*this)\n    { \n        func();//this-&gt;func()\n                       \n    }\n};\nclass B : public A\n{\npublic:\n\tvoid func(int val=0){ std::cout&lt;&lt;\"B-&gt;\"&lt;&lt; val &lt;&lt;std::endl; }\n};\nint main(int argc ,char* argv[])\n{\n    B*p = new B;\n    p-&gt;test();//p-&gt;test(p)\n    return 0;\n}\n</code></pre>\n<blockquote>\n<p>输出：B-&gt;1；重写，只会重写函数的实现，不对(int val=0)中的val=0干扰，可以是<code>void func(int a)</code>或<code>void fun(int)</code>都会构成重写，所以val的值还是对象A的val</p>\n</blockquote>\n<p>总结：子类的缺省参数不起作用，重写虚函数是一种接口继承，也就可以理解成函数、返回值、参数（包括缺省参数）都是父类继承下来，所以这里用的 父类的缺省参数</p>\n<h3><a id=\"_69\"></a>隐藏</h3>\n<p>（ 1）如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无 virtual<br/> 关键字，基类的函数将被隐藏（注意别与重载混淆）。<br/> （ 2）如果派生类的函数与基类的函数同名， 并且参数也相同， 但是基类函数没有 virtual<br/> 关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）。<br/> 示例程序中：</p>\n<pre><code class=\"prism language-c++\">#include &lt;iostream.h&gt;\nclass Base\n{\npublic:\nvirtual void f(float x){ cout &lt;&lt; \"Base::f(float) \" &lt;&lt; x &lt;&lt; endl; }\n\t\tvoid g(float x){ cout &lt;&lt; \"Base::g(float) \" &lt;&lt; x &lt;&lt; endl; }\n\t\tvoid h(float x){ cout &lt;&lt; \"Base::h(float) \" &lt;&lt; x &lt;&lt; endl; }\n};\nclass Derived : public Base\n{\npublic:\nvirtual void f(float x){ cout &lt;&lt; \"Derived::f(float) \" &lt;&lt; x &lt;&lt; endl; }\n\t\tvoid g(int x){ cout &lt;&lt; \"Derived::g(int) \" &lt;&lt; x &lt;&lt; endl; }\n\t\tvoid h(float x){ cout &lt;&lt; \"Derived::h(float) \" &lt;&lt; x &lt;&lt; endl; }\n};\n</code></pre>\n<p>（ 1）函数 Derived::f(float)覆盖了 Base::f(float)。<br/> （ 2）函数 Derived::g(int)隐藏了 Base::g(float)，而不是重载。<br/> （ 3）函数 Derived::h(float)隐藏了 Base::h(float)，而不是覆盖。</p>\n<h1><a id=\"_101\"></a>多态</h1>\n<p>1、虚函数的重写 2、父类的指针或引用调用才符合多态条件</p>\n<p>多态是在<strong>运行时</strong>到指向对象的虚表中查找要调用的虚函数的地址来进行调用，如果没加*或&amp;，就会在编译时直接确认类型调用函数的地址</p>\n<h2><a id=\"_107\"></a>纯虚函数</h2>\n<pre><code class=\"prism language-c++\">//virtual void fun(){}//虚函数\n\tvirtual void fun() = 0;//纯虚函数\n</code></pre>\n<p>包含纯虚函数的类叫抽象类，抽象类不能实例化出对象</p>\n<p><img alt=\"image-20220829200400785\" src=\"image\\95ca00307475ca5ff808e378438ec4d8.png\"/></p>\n<p>纯虚函数的作用：</p>\n<p>1、强制子类去完成重写：父类的纯虚函数<code>virtual void fun() = 0;</code>子类重写：<code>virtual void func(){}</code></p>\n<p>2、表示抽象的类型，抽象就是在现实中没有对应的实体的。</p>\n<h2><a id=\"_124\"></a>虚函数表</h2>\n<p><img alt=\"image-20220829173844321\" src=\"image\\7d89729a3219127204e3f34effbfa376.png\"/></p>\n<p>在32位平台下，没有加virtual大小为1，加了之后就会变4，这是因为加了虚函数关键字，底层会有个vftptr（vitual function table pointer）<strong>虚函数表指针</strong>；</p>\n<p><strong>1、虚函数存在哪？</strong></p>\n<blockquote>\n<p>答：代码段</p>\n</blockquote>\n<p><strong>2、虚函数表（虚表）存在哪？</strong></p>\n<blockquote>\n<p>代码段（常量区）</p>\n</blockquote>\n<p><img alt=\"image-20220829203205038\" src=\"image\\f0484697309a9d2381054aff2d23a699.png\"/></p>\n<h1><a id=\"set_140\"></a>set</h1>\n<h1><a id=\"map_142\"></a>map</h1>\n<p>下面两种方式等同</p>\n<pre><code class=\"prism language-c++\">//mp.insert(pair&lt;int, int&gt;(6, 6));\n\tmp.insert(make_pair(5, 5));\n</code></pre>\n<p>日常大家喜欢用make_pair因为它不用声明模板参数，自动推</p>\n<p><img alt=\"image-20220831193822769\" src=\"image\\90391c3d5091a60c24b6fcd9dec4c182.png\"/></p>\n<pre><code class=\"prism language-c++\">#include&lt;iostream&gt;\nusing namespace std;\n#include&lt;set&gt;\n#include&lt;map&gt;\n\nint main()\n{\n\tmap&lt;int, int&gt;mp;\n\tmp.insert(pair&lt;int,int&gt;(1, 1));\n\tmp.insert(pair&lt;int, int&gt;(3, 3));\n\tmp.insert(pair&lt;int, int&gt;(6, 6));\n\tmp.insert(make_pair(5, 5));\n\tauto lt = mp.begin();\n\twhile (lt != mp.end())\n\t{\n\t\tcout &lt;&lt; lt-&gt;first &lt;&lt; \":\" &lt;&lt; lt-&gt;second &lt;&lt; endl;\n\t\t//cout &lt;&lt; (*lt).first &lt;&lt; \":\" &lt;&lt; (*lt).second &lt;&lt; endl;\n\t\tlt++;\n\t}\n\tcout &lt;&lt; endl;\n\n\treturn 0;\n}\n</code></pre>\n<p><img alt=\"image-20220831194236883\" src=\"image\\31ee4df479095ea3dfb3e48fff5b85ef.png\"/></p>\n<p>总结：</p>\n<blockquote>\n<p>map</p>\n<p>1、增 insert+operator[]</p>\n<p>2、删 erase</p>\n<p>3、查 find+（不建议operator[]）</p>\n<p>4、改 operator[]</p>\n<p>5、遍历 iterator+范围for -》遍历出来的数据是按k排序的，应为底层是搜索数，走的是</p>\n<p>要注意的是map中存的是pair&lt;k,v&gt;键值对</p>\n</blockquote>\n<h1><a id=\"_209\"></a>面试题</h1>\n<p>C++的缺陷有哪些？</p>\n<p>多继承就是一个问题-》菱形继承-？虚继承-》底层结构的对象模型非常复杂，且有一定效率损失</p>\n<p>什么是菱形继承？菱形继承问题是什么？-》代码冗余，会有二义性-》如何解决？-》虚继承-》解决原理是什么？</p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}