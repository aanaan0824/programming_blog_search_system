{"blogid": "126228963", "writerAge": "码龄1年", "writerBlogNum": "103", "writerCollect": "4573", "writerComment": "4379", "writerFan": "6331", "writerGrade": "7级", "writerIntegral": "13374", "writerName": "@每天都要敲代码", "writerProfileAdress": "writer_image\\profile_126228963.jpg", "writerRankTotal": "799", "writerRankWeekly": "90", "writerThumb": "4854", "writerVisitNum": "80932", "blog_read_count": "232", "blog_time": "于 2022-08-25 20:22:36 发布", "blog_title": "深入理解多线程（第三篇）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<blockquote>\n<p>✅作者简介：大家好我是@每天都要敲代码，一位材料转码农的选手，希望一起努力，一起进步！<br/> 📃个人主页：<a href=\"https://blog.csdn.net/m0_61933976?spm=1010.2135.3001.5421\" title=\"@每天都要敲代码的个人主页\">@每天都要敲代码的个人主页</a></p>\n<p>🔥系列专栏：<a href=\"https://blog.csdn.net/m0_61933976/category_11820121.html?spm=1001.2014.3001.5482\" title=\"JavaSE从入门到精通\">JavaSE从入门到精通</a><br/> 💬推荐一款模拟面试、刷题神器，从基础到大厂面试题👉<a href=\"https://www.nowcoder.com/link/pc_csdncpt_mtdyqdm_c\" title=\"点击跳转刷题网站进行注册学习\">点击跳转刷题网站进行注册学习</a></p>\n</blockquote>\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E7%BA%BF%E7%A8%8B%E5%86%85%E5%AE%B9%E8%A1%A5%E5%85%85-toc\" style=\"margin-left:0px;\"><a href=\"#%E7%BA%BF%E7%A8%8B%E5%86%85%E5%AE%B9%E8%A1%A5%E5%85%85\">线程内容补充</a></p>\n<p id=\"1.%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B-toc\" style=\"margin-left:40px;\"><a href=\"#1.%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B\">1. 守护线程</a></p>\n<p id=\"2%E3%80%81%E5%AE%9A%E6%97%B6%E5%99%A8-toc\" style=\"margin-left:40px;\"><a href=\"#2%E3%80%81%E5%AE%9A%E6%97%B6%E5%99%A8\">2. 定时器</a></p>\n<p id=\"3%E3%80%81%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%AC%AC%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F-toc\" style=\"margin-left:40px;\"><a href=\"#3%E3%80%81%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%AC%AC%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F\">3. 实现线程的第三种方式：实现Callable接口</a></p>\n<p id=\"4%E3%80%81wait%E5%92%8Cnotify-toc\" style=\"margin-left:40px;\"><a href=\"#4%E3%80%81wait%E5%92%8Cnotify\">4. wait和notify(生产者和消费者模式)</a></p>\n<p id=\"%E7%BB%93%E6%9D%9F%E8%AF%AD-toc\" style=\"margin-left:0px;\"><a href=\"#%E7%BB%93%E6%9D%9F%E8%AF%AD\">结束语</a></p>\n<hr id=\"hr-toc\"/>\n<h1><strong>线程内容补充</strong></h1>\n<blockquote>\n<p>1、守护线程<br/> 2、定时器<br/> 3、实现线程的第三种方式：FutureTask方式，实现Callable接口。（JDK8新特性）<br/> 4、关于Object类中的wait和notify方法。（生产者和消费者模式）</p>\n</blockquote>\n<h2 id=\"1.%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B\">1. 守护线程</h2>\n<blockquote>\n<p>（1）java语言中线程分为两大类：<br/>            <strong> 一类是：用户线程</strong><br/>             <strong>一类是：守护线程（后台线程）</strong>，其中具有代表性的就是<span style=\"color:#fe2c24;\">垃圾回收线程(守护线程)</span></p>\n<p>（2）守护线程的特点：<br/>             一般守护线程是一个死循环，所有的用户线程只要结束，守护线程自动结束。   <br/>            注意：<span style=\"color:#fe2c24;\">主线程main方法是一个用户线程</span>。</p>\n<p>（3）守护线程用在什么地方呢？<br/>            例如：每天00:00的时候系统数据自动备份。这个需要使用到定时器，并且我们可以将定时器设置为守护线程。 一直在那里看着，每到00:00的时候就备份一次。所有的用户线程<br/> 如果结束了，守护线程自动退出，没有必要进行数据备份了。</p>\n</blockquote>\n<p><strong>模拟守护线程</strong></p>\n<blockquote>\n<p>主线程用户线程结束；守护线程也会自动终止，即使死循环也不行！</p>\n<p>例如：下面主线程main运行完，备份数据的线程也会自动终止</p>\n</blockquote>\n<pre><code class=\"language-java\">package com.bjpowernode.java.thread;\n// 守护线程\npublic class ThreadTest014 {\n    public static void main(String[] args) {\n        Thread t = new BackThread();\n        t.setName(\"备份数据的线程\");\n\n        // 启动线程之前，将线程设置为守护线程\n        t.setDaemon(true);\n\n        t.start();\n\n        // 主线程是用户线程\n        for (int i = 0; i &lt;10 ; i++) {\n            System.out.println(Thread.currentThread().getName()+\"---&gt;\"+i);\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n\n    }\n}\n\nclass BackThread extends Thread{\n\n    public void run() {\n        int i = 0;\n        // 即使是死循环，但由于该线程是守护者，当用户线程结束，守护线程自动终止。\n        while(true){\n            System.out.println(Thread.currentThread().getName()+\"---&gt;\"+ (++i));\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}</code></pre>\n<h3></h3>\n<h2 id=\"2%E3%80%81%E5%AE%9A%E6%97%B6%E5%99%A8\">2. 定时器</h2>\n<blockquote>\n<p>（1）定时器的作用： 间隔特定的时间，执行特定的程序。</p>\n<p>        例如：每周要进行银行账户的总账操作。</p>\n<p>                   每天要进行数据的备份操作。</p>\n<p>（2）在实际的开发中，每隔多久执行一段特定的程序，这种需求是很常见的，那么在java中其实可以采用多种方式实现：                <br/>         1）可以使用sleep方法，睡眠，设置睡眠时间，每到这个时间点醒来，执行任务。这种方式是最原始的定时器。</p>\n<p>        2）在<strong>java的类库中</strong>已经写好了一个<strong><span style=\"color:#fe2c24;\">定时器：java.util.Timer</span></strong>，可以直接拿来用。不过，这种方式在目前的开发中也很少用，因为现在有很多高级框架都是支持定时任务的。</p>\n<p>        3）在实际的开发中，目前使用较多的是Spring框架中提供的SpringTask框架，这个框架只要进行简单的配置，就可以完成定时器的任务。</p>\n<p>（3）<strong>继承TimerTask类，创建Timer对象，调用schedule方法</strong></p>\n<p>      <span style=\"color:#fe2c24;\">  timer.schedule(定时任务，第一次执行时间，间隔多久执行一次);</span></p>\n</blockquote>\n<pre><code class=\"language-java\">package com.bjpowernode.java.thread;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.Timer;\nimport java.util.TimerTask;\n\n// 使用定时器指定定时对象\npublic class ThreadTest15 {\n    public static void main(String[] args) throws Exception {\n        // 创建定时器对象\n        Timer timer = new Timer();\n        // Timer timer = new Timer(true); // 守护进程的方式\n\n        // 指定定时任务\n        // timer.schedule(定时任务，第一次执行时间，间隔多久执行一次);\n\n        // 获取第一次执行时间\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyy-MM-dd HH:mm:ss\");\n        Date firstTime = sdf.parse(\"2022-7-31 22:19:00\");\n\n        timer.schedule(new logTimerTask(),firstTime,10*1000); // 间隔10秒执行一次\n        \n    }\n\n}\n\n// 定时任务类，继承TimerTask\n// 假设这是一个记录日志的定时任务\nclass logTimerTask extends TimerTask{ // TimerTask是一个抽象类\n    public void run() {\n        // 编写执行的定时任务\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyy-MM-dd HH:mm:ss\");\n        String strTime = sdf.format(new Date());\n        System.out.println(strTime+\"：完成了一次数据备份\");\n    }\n}</code></pre>\n<h3></h3>\n<h2 id=\"3%E3%80%81%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%AC%AC%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F\">3. 实现线程的第三种方式：实现Callable接口</h2>\n<blockquote>\n<p id=\"1.%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9A%E7%9B%B4%E6%8E%A5%E7%BB%A7%E6%89%BFThread%EF%BC%8C%E9%87%8D%E5%86%99run%E6%96%B9%E6%B3%95-toc\">（1）<strong>实现线程的第三种方式：</strong><span style=\"color:#fe2c24;\">实现Callable接口</span><br/>      <strong>优点：</strong><span style=\"color:#fe2c24;\">可以获取到线程的执行结果。</span><br/>      <strong>缺点：</strong><span style=\"color:#fe2c24;\">效率比较低，在获取t线程执行结果的时候，当前线程受阻塞，效率较低。</span></p>\n<p>（2）实现线程的第三种方式：实现Callable接口。（JDK8新特性）<br/>         这种方式实现的线程<span style=\"color:#fe2c24;\">可以获取线程的返回值；</span>之前讲解的那两种方式是无法获取线程返回值的，因为run方法返回void。</p>\n<p>        思考：系统委派一个线程去执行一个任务，该线程执行完任务之后，可能会有一个执行结果，我们怎么能拿到这个执行结果呢？使用第三种方式：实现Callable接口</p>\n<p>（3）这种方式执行效率较低，在获取返回值时有可能造成当前线程阻塞！</p>\n</blockquote>\n<pre><code class=\"language-java\">import java.util.concurrent.Callable;\nimport java.util.concurrent.FutureTask;\n\n// 实现线程的第三种方式，实现callable接口\npublic class ThreadTest08 {\n    public static void main(String[] args) throws Exception{\n        //第一步：创建一个“未来任务类”\n        // 参数既可以传Runnable(没有返回值),也可以传Callable(有返回值)\n        FutureTask task = new FutureTask(new MyCallable()); // Callable接口实现类对象\n\n        // 创建线程对象\n        Thread t = new Thread(task);\n        // 启动线程\n        t.start();\n\n        // main方法是在主线程中，在主线程中，怎么获取t线程的返回值\n        // get()方法的执行会导致“当前线程阻塞”，要等拿到call()方法return的结果\n        Object obj = task.get();\n        System.out.println(\"线程执行结果：\"+obj);\n\n        // main方法这里的程序要想执行必须等待get()方法的结束\n        // 而get()方法可能需要很久。因为get()方法是为了拿另一个线程的执行结果\n        // 另一个线程执行是需要时间的。\n        System.out.println(\"Hello World\");\n\n    }\n}\n\n\nclass MyCallable implements Callable{\n    // 重写call()方法，ctrl+O；\n    // call()方法就相当于run()方法，只不过run()方法有返回值\n    public Object call() throws Exception {\n        System.out.println(\"call method begin\");\n        Thread.sleep(1000*10);\n        System.out.println(\"call method end\");\n        int a = 10;\n        int b = 20;\n        return a+b; //自动装箱（返回的是Object类型，300结果会变成Integer）\n    }\n}\n\n/*执行结果：\n call method begin\n call method end\n 线程执行结果：30\n Hello World\n*/\n\n</code></pre>\n<p><strong>采用匿名内部类的方式 </strong></p>\n<pre><code class=\"language-java\">package com.bjpowernode.java.thread;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.FutureTask; \n// 采用匿名内部类的方式\npublic class ThreadTest16 {\n    public static void main(String[] args) throws Exception, InterruptedException {\n        // 匿名内部类的方式\n        FutureTask task = new FutureTask(new Callable() {\n            public Object call() throws Exception {   \n                System.out.println(\"call method begin\");\n                Thread.sleep(1000 * 10);\n                System.out.println(\"call method end!\");\n                int a = 100;\n                int b = 200;\n                return a + b; //自动装箱(300结果变成Integer)\n            }\n        });\n\n        // 创建线程对象\n        Thread t = new Thread(task);\n        // 启动线程\n        t.start();\n        Object obj = task.get();\n        System.out.println(obj);\n\n        System.out.println(\"Hello World!\");\n\n\n    }\n}\n</code></pre>\n<h3></h3>\n<h2 id=\"4%E3%80%81wait%E5%92%8Cnotify\">4. wait和notify(<strong>生产者和消费者模式</strong>)</h2>\n<blockquote>\n<p>（1）关于Object类中的wait和notify方法（生产者和消费者模式）</p>\n<p>T线程在o对象上活动，T线程是当前线程对象；当调用o.wait()方法后，当前线程进入等待状态。o.notify()方法的调用可以让正在o对象上等待的线程唤醒。例如：我走在大街上（对象o），有人要打我(线程T)；我说“等会别打脸“（相当于调用了o.wait()）；“继续吧”（相当于调用了o.notify()）</p>\n<p>（2）<span style=\"color:#0d0016;\">wait和notify方法不是线程对象的方法，是java中任何一个java对象都有的方法，因为这两个方式是Object类中自带的</span>。wait方法和notify方法不是通过线程对象调用！</p>\n<p>（3）wait()方法作用      </p>\n<pre><code class=\"language-java\">Object o = new Object();\no.wait();</code></pre>\n<p>表示：让正在o对象上活动的线程进入等待状态，无期限等待，直到被唤醒为止。o.wait();方法的调用，会让“当前线程（正在o对象上活动的线程）”进入等待状态。</p>\n<p>（4）notify()方法作用        </p>\n<pre><code class=\"language-java\">Object o = new Object();\no.notify();</code></pre>\n<p> 表示：唤醒正在o对象上等待的线程。还有一个notifyAll()方法：这个方法是唤醒o对象上处于等待的所有线程。</p>\n</blockquote>\n<p><strong>生产者和消费者模式</strong></p>\n<blockquote>\n<p>生产者和消费者模式是为了专门解决某个特定需求的；</p>\n<p>一个线程负责生产，一个线程负责消费；最终要达到生产和消费平衡 </p>\n</blockquote>\n<p><img alt=\"\" height=\"712\" src=\"image\\c813dc65c74b428cbdc063dc00fb94b0.png\" width=\"1200\"/></p>\n<blockquote>\n<p>（1）使用wait方法和notify方法实现“生产者和消费者模式”<br/> （2）什么是“生产者和消费者模式”？<br/>      生产线程负责生产，消费线程负责消费。<br/>      生产线程和消费线程要达到均衡。<br/>      这是一种特殊的业务需求，在这种特殊的情况下需要使用wait方法和notify方法。<br/> （3）<span style=\"color:#fe2c24;\"><strong>wait和notify方法不是线程对象的方法，是普通java对象都有的方法</strong></span><br/> （4）wait方法和notify方法建立在线程同步的基础之上；因为多线程要同时操作一个仓库。有线程安全问题。<br/> （5）wait方法作用：o.wait()让正在o对象上活动的线程t进入等待状态，并且释放掉t线程之前占有的o对象的锁。<br/> （6）notify方法作用：o.notify()让正在o对象上等待的线程唤醒，只是通知，不会释放o对象上之前占有的锁。<br/> （7）模拟这样一个需求：<br/>     1）仓库我们采用List集合<br/>     2）List集合中假设只能存储1个元素<br/>     3）1个元素就表示仓库满了<br/>     4）如果List集合中元素个数是0，就表示仓库空了<br/>     5）保证List集合中永远都是最多存储1个元素</p>\n<p>    6）必须做到这种效果：生产1个消费1个</p>\n</blockquote>\n<pre><code class=\"language-java\">package com.bjpowernode.java.thread;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class ThreadTest17 {\n    public static void main(String[] args) {\n        // 创建1个仓库对象，共享的\n        List list = new ArrayList();\n        // 创建2个线程对象\n        Thread t1 = new Thread(new Producer(list));\n        Thread t2 = new Thread(new Consumer(list));\n\n        t1.setName(\"生产者线程\");\n        t2.setName(\"消费者线程\");\n\n        t1.start();\n        t2.start();\n\n    }\n\n}\n\n// 生产线程\nclass Producer implements Runnable{\n    // 仓库\n    private List list;\n    // 通过构造方法传过来\n    public Producer(List list) {\n        this.list = list;\n    }\n\n    public void run() {\n        // 一直生产（使用死循环）\n         while(true){\n             // 给仓库对象List加锁\n             synchronized (list){\n                 if(list.size()&gt;0){ // 大于0,说明仓库中已经有一个元素了\n                     try {\n                         // 当前线程进入等待状态，并且释放Producer之前占有的List集合的锁\n                         list.wait();\n                     } catch (InterruptedException e) {\n                         e.printStackTrace();\n                     }\n                 }\n\n                 // 如果仓库空，生产\n                 Object obj = new Object();\n                 list.add(obj);\n                 System.out.println(Thread.currentThread().getName()+\"---&gt;\"+obj);\n\n                 // 唤醒消费者进行消费\n                 list.notify();\n             }\n         }\n    }\n}\n\n// 消费线程\nclass Consumer implements Runnable{\n    // 仓库\n    private List list;\n    // 通过构造方法传过来\n    public Consumer(List list) {\n        this.list = list;\n    }\n\n    public void run() {\n        // 一直消费\n        while(true){\n            synchronized (list){\n                if(list.size() == 0){\n                    try {\n                        // 仓库已经空了\n                        // 消费者线程等待，释放掉List集合的锁\n                        list.wait();\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n\n                // 说明仓库中有数据，消费者进行消费\n                Object obj = list.remove(0);\n                System.out.println(Thread.currentThread().getName()+\"---&gt;\"+obj);\n\n                // 唤醒生产者生产\n                list.notify();\n            }\n        }\n    }\n}</code></pre>\n<h1 id=\"%E7%BB%93%E6%9D%9F%E8%AF%AD\">结束语</h1>\n<blockquote>\n<p>今天的分享就到这里啦！快快通过下方链接注册加入刷题大军吧！各种大厂面试真题在等你哦！<br/> 💬刷题神器，从基础到大厂面试题👉<a href=\"https://www.nowcoder.com/link/pc_csdncpt_mtdyqdm_c\" title=\"点击跳转刷题网站进行注册学习\">点击跳转刷题网站进行注册学习</a></p>\n</blockquote>\n<p><img alt=\"\" height=\"511\" src=\"image\\184068dc41e94efbb14e555f972eaa17.png\" width=\"1200\"/></p>\n<p> </p>\n</div>\n</div>"}