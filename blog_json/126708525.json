{"blogid": "126708525", "writerAge": "码龄1年", "writerBlogNum": "28", "writerCollect": "230", "writerComment": "479", "writerFan": "415", "writerGrade": "5级", "writerIntegral": "1736", "writerName": "风＆646", "writerProfileAdress": "writer_image\\profile_126708525.jpg", "writerRankTotal": "12520", "writerRankWeekly": "5535", "writerThumb": "527", "writerVisitNum": "20234", "blog_read_count": "20", "blog_time": "于 2022-09-07 10:58:02 发布", "blog_title": "vector常用接口使用【c++】", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p></p>\n<div class=\"toc\">\n<h3>文章目录：</h3>\n<ul><li><a href=\"#vector_1\">🔭vector简介</a></li><li><a href=\"#vector_9\">🔭vector构造函数</a></li><li><a href=\"#vector_26\">🔭vector空间增长问题</a></li><li><ul><li><a href=\"#reserve_resize_27\">👾reserve 、resize</a></li><li><a href=\"#size_empty_37\">👾size 、empty</a></li><li><a href=\"#capacity_39\">👾capacity</a></li></ul>\n</li><li><a href=\"#vector_70\">🔭vector中迭代器使用</a></li><li><a href=\"#vector_92\">🔭vector的增删查改</a></li><li><ul><li><a href=\"#push_back_pop_back_93\">👾push_back 、pop_back</a></li><li><a href=\"#operator_112\">👾operator[]</a></li><li><a href=\"#insert__erase_find_136\">👾insert 、erase 、find</a></li></ul>\n</li><li><a href=\"#vector_163\">🔭vector的迭代器失效问题</a></li><li><ul><li><a href=\"#_291\">👾迭代器失效场景总结</a></li></ul>\n</li></ul>\n</div>\n<p></p>\n<h1><a id=\"vector_1\"></a>🔭vector简介</h1>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\2ac2164bdd0d428e8822fda7252bc54e.png\"/></p>\n<ol><li>vector是表示大小可变数组的序列容器。</li><li>vector采用连续的存储空间来存储元素。可用下标的方式对vector中元素进行访问，非常高效。</li><li>vector会分配一些额外的空间存储数据，以适应可能的增长，即存储空间比实际需要的存储空间大。不同的编译器的库采用了不同的方式权衡空间的使用和分配方式。</li><li>与其它动态序列容器相比，vector在访问元素的时候更加高效，在末尾插入和删除元素相对高效。而在任意位置插入和删除相较而言效率低下，不建议经常使用。</li></ol>\n<h1><a id=\"vector_9\"></a>🔭vector构造函数</h1>\n<table><thead><tr><th>(<a href=\"https://cplusplus.com/reference/vector/vector/vector/\">constructor</a>)构造函数</th><th>说明</th></tr></thead><tbody><tr><td>vector()</td><td>无参数构造</td></tr><tr><td>vector(size_type n,const value_type&amp; val = value_type())</td><td>用n个val来构造vector</td></tr><tr><td>vector(const vector&amp; x)</td><td>拷贝构造</td></tr><tr><td>vector(Inputlterator first,InputIterator last)</td><td>迭代器区间来构造初始化</td></tr></tbody></table>\n<pre><code>int main()\n{\n\tvector&lt;int&gt; v1;                         //无参构造\n\tvector&lt;int&gt; v2(5, 7);                   //用5个7构造v2\n\tvector&lt;int&gt; v3(v2.begin(), v2.end());   //指定v2的区间构造v3\n\tvector&lt;int&gt; v4(v3);                     //用v3拷贝构造v4\n\treturn 0;\n}\n</code></pre>\n<h1><a id=\"vector_26\"></a>🔭vector空间增长问题</h1>\n<h2><a id=\"reserve_resize_27\"></a>👾reserve 、resize</h2>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\f246b89bc4c7427b8e687682d057f45b.png\"/></p>\n<ul><li><strong><font color=\"blue\">reserve只负责开辟空间，若知道需要多少空间，reserve可以减缓vector频繁增容的代价。<font color=\"blue\"></font></font></strong></li><li><strong><font color=\"blue\">resize开空间的同时对其进行初始化，影响size的大小。</font></strong></li></ul>\n<p>resize的使用情况：<br/> <img alt=\"在这里插入图片描述\" src=\"image\\d6b0f089991d4bd18373391b228da2a8.png\"/><br/> reserve使用情况:<br/> <img alt=\"在这里插入图片描述\" src=\"image\\c13ae5642dc048a19e4d1794697bf6ba.png\"/></p>\n<h2><a id=\"size_empty_37\"></a>👾size 、empty</h2>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\cf946d61ce4d478babb68a5853823ed8.png\"/></p>\n<h2><a id=\"capacity_39\"></a>👾capacity</h2>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\39a2a36987df4842a7a1d27556594a64.png\"/></p>\n<p><strong>测试capacity的增容机制：</strong></p>\n<pre><code>void test_capacity()\n{\n\tsize_t size;\n\tvector&lt;int&gt; foo;\n\tsize = foo.capacity();\n\tcout &lt;&lt; \"making v grow；\" &lt;&lt; endl;\n\tfor (int i = 0;i &lt; 100;++i)\n\t{\n\t\tfoo.push_back(i);\n\t\tif (size != foo.capacity())\n\t\t{\n\t\t\tsize = foo.capacity();\n\t\t\tcout &lt;&lt; \"capacity changed: \" &lt;&lt; size &lt;&lt; endl;\n\t\t}\n\t}\n}\nint main()\n{\n\ttest_capacity();\n\treturn 0;\n}\n</code></pre>\n<p>vs2022下和Linux下的运行结果对比：<br/> <img alt=\"在这里插入图片描述\" src=\"image\\8698e66430c44c529ea945b12e3bd3f4.png\"/><br/> <strong>总结</strong>：<strong>上述探索capacity的增容机制的代码在vs和g++下运行发现，vs下capacity是按照1.5倍增长，g++下是按照2倍增长</strong>。单次增容次数越多，增容次数就少，效率更高同时可能空间浪费更严重。单次增容空间少，会导致频繁增容，从而效率低下。若提前知道vector中要存储多少数据，可以提前用reserve将空间开好。</p>\n<h1><a id=\"vector_70\"></a>🔭vector中迭代器使用</h1>\n<table><thead><tr><th>iterator</th><th>接口说明</th></tr></thead><tbody><tr><td>begin+end</td><td>begin()获取第一个数据的位置，end()获取最后一个数据的下一个位置</td></tr><tr><td>rbegin+rend</td><td>rbegin()获取最后一个数据的位置，rend()获取第一个数据的前一个位置</td></tr></tbody></table>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\936aac29cc7d45eea18c3941192c42b4.png\"/></p>\n<pre><code>template &lt;class T&gt;\nvoid PrintVector(const vector&lt;T&gt;&amp; v)\n{\n\tclass std::vector&lt;T&gt;::const_iterator it = v.begin();\n\twhile (it != v.end())\n\t{\n\t\t*it += 1;\n\t\tcout &lt;&lt; *it &lt;&lt; \" \";\n\t\t++it;\n\t}\n\tcout &lt;&lt; endl;\n}\n</code></pre>\n<h1><a id=\"vector_92\"></a>🔭vector的增删查改</h1>\n<h2><a id=\"push_back_pop_back_93\"></a>👾push_back 、pop_back</h2>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\08b3d2be88d84d62806596f53837cfa3.png\"/></p>\n<pre><code>int main()\n{\n\tvector&lt;string&gt; v1;\n\tstring s(\"hello\");\n\tv1.push_back(s);\n\n\tvector&lt;int&gt; v2;\n\tfor (int i = 0;i &lt; 10;++i)\n\t{\n\t\tv2.push_back(i);\n\t}\n\tv2.pop_back();\n\treturn 0;\n}\n</code></pre>\n<h2><a id=\"operator_112\"></a>👾operator[]</h2>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\ed4e3f9230884631b4a934877ae668e5.png\"/></p>\n<p>🔎<strong>operator[]在vector中的使用场景：</strong></p>\n<pre><code>// operator[]+index和c++中vector的for+auto的遍历\nint main()\n{\n\tvector&lt;int&gt; v{ 1,2,3,4,5,6,7 };\n\n\t// 通过[]更改下标为2位置的数据并访问\n\tv[2] = 33;\n\tcout &lt;&lt; v[2] &lt;&lt; endl;\n\n\t// 使用for+[]方式遍历vector\n\tfor (size_t i = 0;i &lt; v.size();++i)\n\t{\n\t\tcout &lt;&lt; v[i] &lt;&lt; \" \";\n\t}\n\tcout &lt;&lt; endl;\n\n\treturn 0;\n}\n</code></pre>\n<h2><a id=\"insert__erase_find_136\"></a>👾insert 、erase 、find</h2>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\ed9a1ceee65b41259724978ede4895d5.png\"/><br/> 🔎<strong>vector中insert和erase的用法：</strong></p>\n<pre><code>//任意位置插入:insert 和 erase,以及查找find\nint main()\n{\n\t// 使用列表方式初始化，c++11的新语法\n\tvector&lt;int&gt; v{ 1,2,3,4,5,6,7 };\n\t\n\t//insert：在指定位置插入值为val的元素，在1之前插入0，若找不到1，则不插入\n\t//使用find查找1的位置\n\tvector&lt;int&gt;::iterator pos = find(v.begin(), v.end(),1);\n\tif (pos != v.end())\n\t{\n\t\t//在pos位置之前插入0\n\t\tv.insert(pos, 0);\n\t}\n\n\t//erase:删除指定位置数据，删除4\n\tpos = find(v.begin(), v.end(), 4);\n\t//删除pos位置数据\n\tv.erase(pos);\n\n\treturn 0;\n}\n</code></pre>\n<h1><a id=\"vector_163\"></a>🔭vector的迭代器失效问题</h1>\n<blockquote>\n<p><strong>迭代器</strong>的作用是让算法能够不用关心底层的数据结构，迭代器其底层就是指针或对指针进行了封装。因此迭代器失效实际就是底层对指针所指向的空间被销毁了，使用一块已经被释放的空间。若继续使用已失效的迭代器，程序可能会崩溃。</p>\n</blockquote>\n<p>💻<strong>可能会导致vector迭代器失效的几种可能：</strong><br/> <font color=\"red\">1、<strong>引起其底层空间改变的操作，都可能使vector的迭代器失效</strong>，如：reserve、resize、insert、push_back等操作。</font></p>\n<pre><code>int main()\n{\n\tvector&lt;int&gt; v{ 1,2,3,4,5,6,7,8,9 };\n\tauto it = v.begin();\n\n\t//插入元素期间，可能会引起扩容，从而导致空间被释放\n\tv.insert(v.begin(), 0);\n\tv.push_back(9);\n\n\t//给vector重新赋值，可能会引起底层容量的改变\n\tv.assign(100, 10);\n\n    while(it!=v.end())\n    {\n         cout&lt;&lt;*it&lt;&lt;\" \";\n         ++it; \n    }\n\treturn 0;\n}\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\b363b594a8454b979d917bb803c62087.png\"/><br/> 🪐迭代器失效原因：以上操作，都有可能导致vector扩容，vector底层旧空间被释放，再次访问it时，it还使用原来的空间，对it进行访问时，访问的是一块已经释放的空间，而导致程序运行时奔溃。<br/> 对于以上问题，我们需要让it指向新的空间并访问，对it进行重新赋值。</p>\n<p><font color=\"red\">2、<strong>指定位置元素的删除导致迭代器失效</strong></font><br/> <img alt=\"在这里插入图片描述\" src=\"image\\f85e3abe938147669e2230b22ae32867.png\"/></p>\n<p>❓接下来我们来看一个问题，删除所有vector中所有的偶数，怎么设计代码是正确的？</p>\n<p>首先我们来看一个错误的示例：❌</p>\n<pre><code>int main()\n{\n\tvector&lt;int&gt; v{ 1,2,3,4,5,6 };\n\tauto it = v.begin();\n\twhile (it != v.end())\n\t{\n\t\tif (*it % 2 == 0)\n\t\t\tv.erase(it);\n\t\t++it;\n\t}\n\treturn 0;\n}\n</code></pre>\n<p>代码的运行测试及分析：<br/> <img alt=\"在这里插入图片描述\" src=\"image\\e64e72717ab646ba9a1acc5672a63125.png\"/><br/> 改进之后的代码，解决迭代器失效问题：✔️</p>\n<pre><code>int main()\n{\n\tvector&lt;int&gt; v{ 1,2,3,4,5,6,7 };\n\tauto it = v.begin();\n\twhile (it != v.end())\n\t{\n\t\tif (*it % 2 == 0)\n\t\t{\n\t\t\t//erase(it) 之后，it失效，不能++，erase会返回删除位置it的下一个位置\n\t\t\tit = v.erase(it);\n\t\t}\n\t\telse\n\t\t\t++it;\n\t}\n\tfor (auto e : v)\n\t\tcout &lt;&lt; e &lt;&lt; \" \";\n\treturn 0;\n}\n</code></pre>\n<p>运行测试及分析:<br/> <img alt=\"在这里插入图片描述\" src=\"image\\f4511d9f136349a2821f3efd4e89c6c7.png\"/><br/> <font color=\"red\">3、<strong>Linux下，g++编译器对迭代器的失效检测并没有vs下严格，处理方式相较没有那么极端</strong></font></p>\n<pre><code>//扩容之后，迭代器已经失效了，程序虽可以运行，但是运行结果并不对\nint main()\n{\n\tvector&lt;int&gt; v{ 1,2,3,4,5 };\n\tfor (size_t i = 0;i &lt; v.size();++i)\n\t\tcout &lt;&lt; v[i] &lt;&lt; \" \";\n\tcout &lt;&lt; endl;\n\n\tauto it = v.begin();\n\tcout &lt;&lt; \"扩容前vector容量：\" &lt;&lt; v.capacity() &lt;&lt; endl;\n\t//扩大vector容器空间，使迭代器失效\n\tv.reserve(100);\n\tcout &lt;&lt; \"扩容后vector容量：\" &lt;&lt; v.capacity() &lt;&lt; endl;\n\n\t//经过上述的reserve之后，it迭代器失效了，在vs下程序直接崩溃，在Linux下则不会（可能运行成功，但结果不对）\n\twhile (it != v.end())\n\t{\n\t\tcout &lt;&lt; *it &lt;&lt; \" \";\n\t\t++it;\n\t}\n\tcout &lt;&lt; endl;\n\n\treturn 0;\n}\n</code></pre>\n<p>代码在vs2022下运行结果：<br/> <img alt=\"在这里插入图片描述\" src=\"image\\4fbde00b65e646b2a39ccc65d3b01053.png\"/><br/> 看看此代码在Linux下运行的结果：</p>\n<pre><code>int main()\n{\n\tvector&lt;int&gt; v{ 1,2,3,4,5};         //这一组数据程序可以运行起来\n\t//vector&lt;int&gt; v{1,2,3,4,5,6};      //这一组数据程序运行可能会崩溃\n\tauto it = v.begin();\n\twhile (it != v.end())\n\t{\n\t\tif (*it % 2 == 0)\n\t\t\tv.erase(it);\n\t\t++it;\n\t}\n\treturn 0;\n}\n</code></pre>\n<p>📖erase删除任意位置数据后，Linux下迭代器没有失效，因为空间没变，后面的元素往前移，it的位置依然有效，但若erase删除的是最后一个元素，删除后it越界，++it导致程序崩溃。<strong>erase的失效都是意义变了或者不在有效访问数据范围内。</strong></p>\n<p>📄总结一下：对于insert和erase造成的迭代器失效问题，Linux g++ 平台检测相对没有那么严格，基本依靠操作系统自身对野指针的越界检查机制，Windows下vs系列的检查更为严格，使用了强制检查的机制，即使是迭代器没有越界，仅仅是意义变了也可以检查出来。</p>\n<h2><a id=\"_291\"></a>👾迭代器失效场景总结</h2>\n<p>vector迭代器失效有两种情况：<br/> 1、插入元素、扩容导致空间改变，导致野指针式迭代器失效。<br/> 2、迭代器指向的空间位置意义变了。程序运行结果错误或导致崩溃。</p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}