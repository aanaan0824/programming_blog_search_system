{"blogid": "123826962", "writerAge": "码龄1年", "writerBlogNum": "63", "writerCollect": "1774", "writerComment": "406", "writerFan": "2776", "writerGrade": "4级", "writerIntegral": "1565", "writerName": "YR_T", "writerProfileAdress": "writer_image\\profile_123826962.jpg", "writerRankTotal": "10886", "writerRankWeekly": "2227", "writerThumb": "523", "writerVisitNum": "142315", "blog_read_count": "2644", "blog_time": "已于 2022-03-30 10:22:40 修改", "blog_title": "c++桶排序(刚学也能看懂)", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p><strong>目录</strong></p>\n<p style=\"margin-left:0px;\"> </p>\n<p style=\"margin-left:0px;\"><a href=\"#%E5%93%88%E5%96%BD%F0%9F%98%86\">哈喽😆</a></p>\n<p style=\"margin-left:0px;\"><a href=\"#%E7%A9%BF%E6%A2%AD%E9%97%A8\">穿梭门</a></p>\n<p style=\"margin-left:0px;\"><a href=\"#%E6%95%88%E6%9E%9C%F0%9F%A7%90\">效果🧐</a></p>\n<p style=\"margin-left:0px;\"><a href=\"#%E6%A1%B6%E6%8E%92%E5%BA%8F%E6%98%AF%E4%BB%80%E4%B9%88%F0%9F%92%A1\">桶排序是什么💡</a></p>\n<p style=\"margin-left:0px;\"><a href=\"#%F0%9F%A4%94%E5%86%8D%E7%AE%80%E5%8D%95%E7%82%B9%E8%AF%B4\">🤔再简单点说</a></p>\n<p style=\"margin-left:0px;\"><a href=\"#%F0%9F%91%80%E5%86%8D%E5%86%8D%E7%AE%80%E5%8D%95%E7%82%B9%E8%AF%B4\">👀再再简单点说</a></p>\n<p style=\"margin-left:0px;\"><a href=\"#%E6%80%9D%E8%B7%AF\">思路</a></p>\n<p style=\"margin-left:0px;\"><a href=\"#%E7%A1%AE%E5%AE%9A%E2%80%9C%E5%88%86%E6%A1%B6%E2%80%9D%E4%B8%AA%E6%95%B0%F0%9F%94%8D\">确定“分桶”个数🔍</a></p>\n<p style=\"margin-left:0px;\"><a href=\"#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%F0%9F%98%90\">复杂度分析😐</a></p>\n<p style=\"margin-left:0px;\"><a href=\"#c%2B%2B%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0\">c++代码实现</a></p>\n<p style=\"margin-left:0px;\"><a href=\"#python%E7%89%88%E4%BB%A3%E7%A0%81%28%E5%98%BF%E5%98%BF%EF%BC%8C%E6%B2%A1%E6%83%B3%E5%88%B0%E5%90%A7%29\">python版代码(嘿嘿，没想到吧)</a></p>\n<p style=\"margin-left:0px;\"><a href=\"#%E6%9C%80%E5%90%8E\">最后</a></p>\n<hr/>\n<p> </p>\n<h1>哈喽😆</h1>\n<p>这次来发一下桶排序，它的时间复杂度低，代码也不难</p>\n<h1>穿梭门</h1>\n<p><a href=\"https://blog.csdn.net/m0_64036070/article/details/123804075?utm_source=app&amp;app_version=5.3.0\" title=\"二分算法\">二分算法</a></p>\n<p><a href=\"https://blog.csdn.net/m0_64036070/article/details/123770678?utm_source=app&amp;app_version=5.3.0\" title=\"堆排序\">堆排序</a></p>\n<h1>效果🧐</h1>\n<p style=\"text-align:center;\"><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETkBZUl9U,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\c18ee5d2e3d643e8b1a2c4703de5444c.png\"/></p>\n<p>就是排序</p>\n<p>所以说，还是比较简单滴 </p>\n<p style=\"text-align:center;\"><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETkBZUl9U,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\45c01775f2954648a65378d9ee1ddce7.png\"/></p>\n<h1>桶排序是什么💡</h1>\n<blockquote>\n<p>桶排序是计数排序的升级版，也是分治算法。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：<strong>假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。简言之，将值为i的元素放入i号桶，最后依次把桶里的元素倒出来。</strong><br/> 怎么样，是不是很“简单”？                  </p>\n</blockquote>\n<p>还有这张一看就头疼的图</p>\n<p style=\"text-align:center;\"><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETkBZUl9U,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\791166833ec54015845660c445e020c1.png\"/></p>\n<p> </p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETkBZUl9U,size_15,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\734a8e7d1fa0465aa07d5e7242b0bc1c.png\"/>                       </p>\n<p> 🤔🤔🤔🤔🤔🤔🤔🤔🤔🤔🤔🤔🤔🤔🤔🤔🤔🤔🤔</p>\n<h1>🤔再简单点说</h1>\n<p>桶排序的基本思想是假设数据在[min,max]之间均匀分布，其中min、max分别指数据中的最小值和最大值。那么将区间[min,max]等分成n份，这n个区间便称为n个桶。将数据加入对应的桶中，然后每个桶内单独排序。由于桶之间有大小关系，因此可以从大到小(或从小到大)将桶中元素放入到数组中。</p>\n<h1>👀再再简单点说</h1>\n<p>简单说，你有一个数组1 , 3 , 7 , 77 ，100 ，234</p>\n<p>比如，</p>\n<p>你把一位数、两位数和三位数分到3个桶里，</p>\n<p>各自排完序再合到一起</p>\n<p>排序前：1 , 3 , 7 , 77 ，100 ，234</p>\n<p>一位数：1、7、3</p>\n<p>两位数：77</p>\n<p>三位数：100、234</p>\n<p>排序后：</p>\n<p>一位数：1、3、7</p>\n<p>两位数：77</p>\n<p>三位数：100、234</p>\n<p>合起来：1、3、7、77、100、234 </p>\n<h1>思路</h1>\n<p><strong>1.</strong><em>设置一个定量的数组当作空桶子。</em><br/><strong>2</strong>.<em>寻访序列，并且把项目一个一个放到对应的桶子去。</em><br/><strong>3.</strong><em>对每个非空的桶子进行排序。</em><br/><strong>4.</strong><em>从不是空的桶子里把项目再放回原来的序列中。</em></p>\n<h1>确定“分桶”个数🔍<br/>  </h1>\n<p>假如要对数组arr={ 2,0,1,6,8,10,5,99,87,333,2,0,1 }排序，假设需要桶的个数为bucketNum=std::ceil(size/3)，向上取整，反之桶个数不够映射时越界。</p>\n<h1>复杂度分析😐</h1>\n<p><br/> 桶排序实际上只需要遍历一遍所有的待排序元素，然后依次放入指定的位置，如果加上输出排序的时间，那么需要遍历所有的桶，时间复杂度为O(n+m)，其中n为待排序元素的个数，m为桶的个数，这时相当快的排序算法，但是，对于空间的小号来说太大了。当n越大，空间浪费就越大，所以，如果数据跨度过大，桶排序并不适用跨度范围大的排序。</p>\n<h1>c++代码实现</h1>\n<p>直接放代码，如果你报错了，就把前面的万能头文件改了</p>\n<p>c++版(devc++无报错无警告)</p>\n<pre><code class=\"language-cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n// 打印数组\nvoid print_array(int *arr, int n) {\n    if(n==0){\n        printf(\"ERROR: Array length is ZERO\\n\");\n        return;\n    }\n    printf(\"%d\", arr[0]);\n    for (int i=1; i&lt;n; i++) \n        printf(\" %d\", arr[i]);\n    printf(\"\\n\");\n}\n\n\nint* sort_array(int *arr, int n) {\n    int i;\n\tint maxValue = arr[0];\n\tfor (i = 1; i &lt; n; i++) \n\t\tif (arr[i] &gt; maxValue)  // 输入数据的最大值\n\t\t\tmaxValue = arr[i]; \n\t\n\t// 设置10个桶，依次0，1，，，9\n\tconst int bucketCnt = 10;\n\tvector&lt;int&gt; buckets[bucketCnt];\n\t// 桶的大小bucketSize根据数组最大值确定：比如最大值99， 桶大小10\n\t// 最大值999，桶大小100\n\t// 根据最高位数字映射到相应的桶，映射函数为 arr[i]/bucketSize\n\tint bucketSize = 1;\n\twhile (maxValue) {\t\t//求最大尺寸 \n\t\tmaxValue /= 10;\n\t\tbucketSize *= 10;\n\t}\n\tbucketSize /= 10;\t\t//桶的个数 \n\t// 入桶\n\tfor (int i=0; i&lt;n; i++) {\n\t\tint idx = arr[i]/bucketSize;\t\t\t//放入对应的桶 \n\t\tbuckets[idx].push_back(arr[i]);\n\t\t// 对该桶使用插入排序(因为数据过少，插入排序即可)，维持该桶的有序性\n\t\tfor (int j=int(buckets[idx].size())-1; j&gt;0; j--) {\n\t\t\tif (buckets[idx][j]&lt;buckets[idx][j-1]) {\n\t\t\t\tswap(buckets[idx][j], buckets[idx][j-1]);\n\t\t\t}\n\t\t}\n\t}\n\t// 顺序访问桶，得到有序数组\n\tfor (int i=0, k=0; i&lt;bucketCnt; i++) {\n\t\tfor (int j=0; j&lt;int(buckets[i].size()); j++) {\n\t\t\tarr[k++] = buckets[i][j];\n\t\t}\n\t}\n\treturn arr;\n}\n\n\n\nint main() {\n    int n;\n    scanf(\"%d\", &amp;n);\n    \n    int *arr;\n    arr = (int*)malloc(sizeof(int)*n);\n    \n    for (int i=0; i&lt;n; i++) scanf(\"%d\", &amp;arr[i]);\n    \n    arr = sort_array(arr, n);\n    \n    print_array(arr, n);\n    \n    system(\"pause\"); \n    return 0;\n}\n</code></pre>\n<h1>python版代码(嘿嘿，没想到吧)</h1>\n<pre><code class=\"language-python\">def bucketSort(nums):\n    # 选择一个最大的数\n    max_num = max(nums)\n    # 创建一个元素全是0的列表, 当做桶\n    bucket = [0]*(max_num+1)\n    # 把所有元素放入桶中, 即把对应元素个数加一\n    for i in nums:\n        bucket[i] += 1\n \n    # 存储排序好的元素\n    sort_nums = []\n    # 取出桶中的元素\n    for j in range(len(bucket)):\n        if bucket[j] != 0:\n            for y in range(bucket[j]):\n                sort_nums.append(j)\n \n    return sort_nums\n \nnums = [5,6,3,2,1,65,2,0,8,0]\nprint bucketSort(nums)\n \n\"\"\"\n[0, 0, 1, 2, 2, 3, 5, 6, 8, 65]\n\"\"\"</code></pre>\n<h1>最后</h1>\n<p>今天想给大家推荐一本书</p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETkBZUl9U,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\b40e74529fe744c2949daaf0646b0dbf.png\"/></p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAWVJfVA==,size_15,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\896a242d5dcb41e4ac662ad2f6a9c738.png\"/></p>\n<p> </p>\n<p> 互粉必回！   白白👋</p>\n<p> </p>\n<p> </p>\n<p> </p>\n<p> </p>\n<p> </p>\n<p> </p>\n<p> </p>\n<p> </p>\n<p> </p>\n<p> </p>\n<p> </p>\n<p> </p>\n<p> </p>\n<p> </p>\n<p> </p>\n<p> </p>\n<p> </p>\n<p> </p>\n<p> </p>\n<p> </p>\n<p> </p>\n<p> </p>\n<p> </p>\n</div>\n</div>"}