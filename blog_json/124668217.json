{"blogid": "124668217", "writerAge": "码龄4年", "writerBlogNum": "20", "writerCollect": "64", "writerComment": "11", "writerFan": "10", "writerGrade": "2级", "writerIntegral": "269", "writerName": "竹北1998", "writerProfileAdress": "writer_image\\profile_124668217.jpg", "writerRankTotal": "80423", "writerRankWeekly": "138458", "writerThumb": "41", "writerVisitNum": "16443", "blog_read_count": "12016", "blog_time": "于 2022-05-09 16:31:11 发布", "blog_title": "Java代码实现—冒泡排序", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"1%E3%80%81%E5%89%8D%E8%A8%80-toc\" style=\"margin-left:0px;\"><a href=\"#1%E3%80%81%E5%89%8D%E8%A8%80\">1、前言</a></p>\n<p id=\"2%E3%80%81%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F-toc\" style=\"margin-left:0px;\"><a href=\"#2%E3%80%81%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F\">2、冒泡排序</a></p>\n<p id=\"2.1%20%E7%AE%97%E6%B3%95%E6%80%9D%E8%B7%AF-toc\" style=\"margin-left:40px;\"><a href=\"#2.1%20%E7%AE%97%E6%B3%95%E6%80%9D%E8%B7%AF\">2.1 算法思路</a></p>\n<p id=\"2.2%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B%EF%BC%9A-toc\" style=\"margin-left:40px;\"><a href=\"#2.2%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B%EF%BC%9A\">2.2 代码实现过程：</a></p>\n<p id=\"3%E3%80%81%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96-toc\" style=\"margin-left:0px;\"><a href=\"#3%E3%80%81%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96\">3、代码优化</a></p>\n<p id=\"3.1%C2%A0%E8%B6%9F%E6%95%B0%E4%BC%98%E5%8C%96-toc\" style=\"margin-left:40px;\"><a href=\"#3.1%C2%A0%E8%B6%9F%E6%95%B0%E4%BC%98%E5%8C%96\">3.1 趟数优化</a></p>\n<p id=\"3.2%20%E5%BE%AA%E7%8E%AF%E6%AC%A1%E6%95%B0%E4%BC%98%E5%8C%96-toc\" style=\"margin-left:40px;\"><a href=\"#3.2%20%E5%BE%AA%E7%8E%AF%E6%AC%A1%E6%95%B0%E4%BC%98%E5%8C%96\">3.2 循环次数优化</a></p>\n<p id=\"3.3%20%E6%8E%92%E5%BA%8F%E5%AE%8C%E6%88%90%E4%BC%98%E5%8C%96-toc\" style=\"margin-left:40px;\"><a href=\"#3.3%20%E6%8E%92%E5%BA%8F%E5%AE%8C%E6%88%90%E4%BC%98%E5%8C%96\">3.3 排序完成优化</a></p>\n<p id=\"4%E3%80%81%E7%BB%93%E8%AF%AD-toc\" style=\"margin-left:0px;\"><a href=\"#4%E3%80%81%E7%BB%93%E8%AF%AD\">4、结语</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h1 id=\"1%E3%80%81%E5%89%8D%E8%A8%80\">1、前言</h1>\n<p>我们书接上回，接着数组中的遗留问题来讲解这节的冒泡排序，干货满满，里面还涉及到代码的优化，希望大家有所收获</p>\n<h1 id=\"2%E3%80%81%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F\">2、冒泡排序</h1>\n<ul><li>冒泡排序思想：给定一个数组，让数组升序 (降序) 排序。</li></ul>\n<h2 id=\"2.1%20%E7%AE%97%E6%B3%95%E6%80%9D%E8%B7%AF\">2.1 算法思路</h2>\n<ul><li>假设排升序：</li></ul>\n<ol><li>将数组中相邻元素从前往后依次进行比较，<strong>如果前一个元素比后一个元素大，则交换</strong>，一趟下来后最大元素就在数组的末尾。</li><li>依次从上上述过程，直到数组中所有的元素都排列好。</li><li>依据这个思想，我们很容易写出如下代码：</li></ol>\n<pre><code class=\"language-java\">\n    public static void main7(String[] args) {\n        int[] array = {10,5,3,7,6};\n        myBubblesort(array);\n        System.out.println(Arrays.toString(array));\n    }\n    public static void myBubblesort(int[] array){\n        for (int i = 0; i &lt; array.length; i++) {\n            for (int j = 0; j &lt; array.length-1; j++) {\n                if(array[j] &gt; array[j+1]){\n                    int tmp = 0;\n                    tmp = array[j];\n                    array[j] = array[j+1];\n                    array[j+1] = tmp;\n                }\n            }\n        }\n    }\n\n</code></pre>\n<h2 id=\"2.2%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B%EF%BC%9A\">2.2 代码实现过程：</h2>\n<ul><li> 上述代码在我们思路清晰的情况下很容易写出，但是代码是如何实现的呢？</li><li>在这里我们主要关注两个点：<strong><span style=\"color:#fe2c24;\">趟数i和每次循环的次数j</span></strong>。</li></ul>\n<hr/>\n<ul><li>第1趟：i = 0时</li></ul>\n<p><span style=\"color:#0d0016;\">        当j = 0时，此时array[0] = 10; array[1] = 5；10 &gt; 5，<strong>所以执行array[j] = array[j+1]的交换代码（这里交换代码简写，下同）</strong>，数组变为：{5,10,3,7,6};</span></p>\n<p><span style=\"color:#0d0016;\">        当j = 1时，此时array[1] = 10; array[2] = 3；10 &gt; 3，所以执行array[j] = array[j+1]的交换代码，数组变为{5,3,10,7,6}; </span></p>\n<p><span style=\"color:#0d0016;\">        当j = 2时，此时array[2] = 10; array[3] = 7；10&gt;7，所以执行array[j] = array[j+1]的交换代码，数组变为{5,3,7,10,6}； </span></p>\n<p><span style=\"color:#0d0016;\">        当j = 3时，此时array[3] = 10; array[4] = 6；10&gt;6，所以执行array[j] = array[j+1]的交换代码，数组变为{5,3,7,6,10}；</span></p>\n<p></p>\n<p>      <span style=\"color:#0d0016;\">  至此第1趟的内部循环结束，</span><span style=\"color:#fe2c24;\">我们将10这个数字排列到数组的末尾</span><span style=\"color:#0d0016;\">，此时j循环了4次，<strong>j = 3时停止</strong>。 </span></p>\n<p><span style=\"color:#0d0016;\">        我们发现，数组中一共有5个元素，j循环了4次，那么第一个循环条件就是<strong>j &lt;array.length - 1</strong>；如果不-1的话，j = 4的时候，<strong>那么array[j+1]就会越界</strong>，因为数组的下标就到4。 所以array.length - 1，<strong>是否就有一个条件呢？</strong>，答案是否定的（</span><span style=\"color:#fe2c24;\">可以做代码优化</span><span style=\"color:#0d0016;\">），我们继续向下执行第2趟。</span></p>\n<p class=\"img-center\"><img alt=\"\" height=\"300\" src=\"image\\6d6569a85fc448a1bc192465fbc37d4f.png\" width=\"428\"/></p>\n<ul><li> 第2趟：i = 1时</li></ul>\n<p>        当j = 0时，此时数组是上一趟结束的数组{5,3,7,6,10}，此时array[0] = 5; array[1] = 3；5 &gt; 3，所以执行array[j] = array[j+1]的交换代码，数组变为：{3,5,7,6,10};</p>\n<p>        当j = 1时，此时array[1] = 5; array[2] = 7；5 &lt; 7，所以不执行array[j] = array[j+1]的交换代码，数组还是{3,5,7,6,10};</p>\n<p>        当j = 2时，此时array[2] = 7; array[3] = 6；7 &gt; 6，所以执行array[j] = array[j+1]的交换代码，数组变为{3,5,6,7,10};</p>\n<p>        至此第2趟代码就执行完交换了，因为当j = 3的时候，我们比较的是7和10的大小，在第一趟的时候，<strong>我们就已经操作完10到数组的末尾了，所以没必要再比较一次</strong>。</p>\n<p>         在第2趟中我们将7操作到倒数第二位的指定位置，我们发现内部循环j执行了3次，<span style=\"color:#fe2c24;\">到j = 2时候停止</span>。 其实到第2趟的时候我们已经排序完成了，<strong>但是代码不知道这个事情（这点记下来，可以做代码优化）</strong>，我们接着执行第3趟</p>\n<p class=\"img-center\"><img alt=\"\" height=\"292\" src=\"image\\b592d02fe6c1484f8ddd858457b97367.png\" width=\"456\"/></p>\n<ul><li> 第3趟：i = 2时</li></ul>\n<p><span style=\"color:#0d0016;\">        当j = 0时，此时数组是上一趟结束的数组{3,5,6,7,10}，此时array[0] = 3; array[1] = 5；3 &lt; 5，所以不执行array[j] = array[j+1]的交换代码，数组还是{3,5,6,7,10}。</span></p>\n<p><span style=\"color:#0d0016;\">         当j = 1时，此时array[1] = 5; array[2] = 6；5 &lt; 6，所以不执行array[j] = array[j+1]的交换代码，数组还是{3,5,6,7,10}。</span></p>\n<p><span style=\"color:#0d0016;\">         至此第3趟的内部循环就结束了，因为如果再往下执行，就要操作7了，<strong>但是7我们在第2趟的时候已经操作过了。</strong></span></p>\n<p><span style=\"color:#0d0016;\">         在第3趟的内部循环中，<strong>是操作了6在倒数第3位的位置</strong>，我们发现内部循环j执行了2次，</span><span style=\"color:#fe2c24;\">到j = 1时候停止</span><span style=\"color:#0d0016;\">。 数据早就排序好了，但是代码不知道，所以继续第4趟。</span></p>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"212\" src=\"image\\425f9743b53a42f8b0521214ffc1a153.png\" width=\"454\"/></p>\n<ul><li>第4趟，i = 3时</li></ul>\n<p>        当j = 0时，此时数组是上一趟结束的数组{3,5,6,7,10}，此时array[0] = 3; array[1] = 5；3 &lt; 5，所以不执行array[j] = array[j+1]的交换代码，数组还是{3,5,6,7,10}。</p>\n<p>        至此第4趟结束了，因为我们要<strong>操作的是5这个数字，和3比较完之后，就已经在原来正确的位置了，所以循环结束</strong>。</p>\n<p>        在第4趟的内部循环中，是操作了<strong>5在倒数第4位的位置</strong>，我们发现内部循环j执行了1次，到<span style=\"color:#fe2c24;\">j = 0</span>时候停止。</p>\n<p>       <span style=\"color:#fe2c24;\">  注意</span>：我们要不要执行第5趟呢，这个问题放在代码优化中讲解。</p>\n<p class=\"img-center\"><img alt=\"\" height=\"238\" src=\"image\\4a2bb8c5e9254db0890e2f4e78d619e8.png\" width=\"212\"/></p>\n<h1 id=\"3%E3%80%81%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96\">3、代码优化</h1>\n<h2 id=\"3.1%C2%A0%E8%B6%9F%E6%95%B0%E4%BC%98%E5%8C%96\">3.1 趟数优化</h2>\n<ul><li>书接上一节，当我们执行完第四趟的时候，现在只有3一个数字，没有必要再执行一趟，因为其他的数字如果排序完成之后，3自动排序好了，所<span style=\"color:#fe2c24;\">以趟数可以优化为：i &lt; array.length - 1趟，也就是最后1趟没有必要执行</span>，代码优化如下：</li></ul>\n<pre><code class=\"language-java\">\n    public static void main7(String[] args) {\n        int[] array = {10,5,3,7,6};\n        myBubblesort(array);\n        System.out.println(Arrays.toString(array));\n    }\n    public static void myBubblesort(int[] array){\n        for (int i = 0; i &lt; array.length-1; i++) {\n            for (int j = 0; j &lt; array.length-1; j++) {\n                if(array[j] &gt; array[j+1]){\n                    int tmp = 0;\n                    tmp = array[j];\n                    array[j] = array[j+1];\n                    array[j+1] = tmp;\n                }\n            }\n        }\n    }</code></pre>\n<h2 id=\"3.2%20%E5%BE%AA%E7%8E%AF%E6%AC%A1%E6%95%B0%E4%BC%98%E5%8C%96\">3.2 循环次数优化</h2>\n<ul><li>我们发现，第1趟时候，j = 3结束循环；第2趟的时候，j = 2的时候结束循环；第3趟的时候，j = 1结束循环；第4趟的时候，j = 0结束循环。 <span style=\"color:#fe2c24;\">所以内部循环j可以优化成j &lt; array.length- 1 - i；循环次数减少，代码的运行效率就提高了</span>。代码优化如下：</li></ul>\n<pre><code class=\"language-java\">\n    public static void main7(String[] args) {\n        int[] array = {10,5,3,7,6};\n        myBubblesort(array);\n        System.out.println(Arrays.toString(array));\n    }\n    public static void myBubblesort(int[] array){\n        for (int i = 0; i &lt; array.length-1; i++) {\n            for (int j = 0; j &lt; array.length-i-1; j++) {\n                if(array[j] &gt; array[j+1]){\n                    int tmp = 0;\n                    tmp = array[j];\n                    array[j] = array[j+1];\n                    array[j+1] = tmp;\n                }\n            }\n        }\n    }</code></pre>\n<h2 id=\"3.3%20%E6%8E%92%E5%BA%8F%E5%AE%8C%E6%88%90%E4%BC%98%E5%8C%96\">3.3 排序完成优化</h2>\n<ul><li>在上述代码中，我们<strong>肉眼可见的第2趟的时候就已经排序完成</strong>，<span style=\"color:#fe2c24;\">但是代码并不知道排序完成</span>，还是会继续执行，那么我们有没有办法让代码知道什么时候已经排序完成呢？</li><li>我们设置一个<span style=\"color:#fe2c24;\">标志位flg = false</span>；如果<span style=\"color:#fe2c24;\">执行交换代码，就把flg = true</span>；如果没有交换代码，就证明排序已经完成。 我们在每一趟，执行或不执行交换代码的后面判断这个标志位，<strong>如果flg = true，证明本趟交换了数据，那就执行下一趟；如果flg = false；证明没有执行交换代码，那么本趟就已经排序完成了，就return结束函数即可</strong>。 代码优化如下：</li></ul>\n<pre><code class=\"language-java\">   public static void main7(String[] args) {\n        int[] array = 10,5,3,7,6};\n        myBubblesort(array);\n        System.out.println(Arrays.toString(array));\n    }\n    public static void myBubblesort(int[] array){\n        for (int i = 0; i &lt; array.length-1; i++) {\n            boolean flg = false;\n            for (int j = 0; j &lt; array.length-1-i; j++) {\n                if(array[j] &gt; array[j+1]){\n                    int tmp = 0;\n                    tmp = array[j];\n                    array[j] = array[j+1];\n                    array[j+1] = tmp;\n                    flg = true;\n                }\n            }\n            if(flg == false){\n                return;\n            }\n        }\n    }\n</code></pre>\n<ul><li><span style=\"color:#fe2c24;\">注意</span>：flg标志位要放在趟数循环内部，因为每次循环都要把flg = false；<strong>否则如果放在循环外部，只要执行过一次交换，flg就为true了</strong>，那么就检测不到这趟是否完成了排序。 </li></ul>\n<h1 id=\"4%E3%80%81%E7%BB%93%E8%AF%AD\">4、结语</h1>\n<ul><li>其实，冒泡排序我们本身是不难实现的，但是你能否做到三次代码优化呢？相信看完这次blog你也可以实现。</li><li>接下来，博主会更新<strong>类与对象</strong>的相关内容，期待大家的持续关注！</li></ul>\n<p></p>\n</div>\n</div>"}