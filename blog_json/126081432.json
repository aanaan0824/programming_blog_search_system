{"blogid": "126081432", "writerAge": "码龄3年", "writerBlogNum": "434", "writerCollect": "1829", "writerComment": "138", "writerFan": "5819", "writerGrade": "6级", "writerIntegral": "5829", "writerName": "nuist__NJUPT", "writerProfileAdress": "writer_image\\profile_126081432.jpg", "writerRankTotal": "2574", "writerRankWeekly": "1181", "writerThumb": "287", "writerVisitNum": "308042", "blog_read_count": "272", "blog_time": "于 2022-09-04 18:53:17 发布", "blog_title": "备战数学建模37-遗传算法GA(攻坚战1)", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E4%B8%80%E3%80%81%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%9A%84%E6%A6%82%E5%BF%B5-toc\" style=\"margin-left:40px;\"><a href=\"#%E4%B8%80%E3%80%81%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%9A%84%E6%A6%82%E5%BF%B5\">一、遗传算法的概念</a></p>\n<p id=\"1.1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-toc\" style=\"margin-left:80px;\"><a href=\"#1.1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\">1.1、基本概念</a></p>\n<p id=\"%C2%A01.2%E3%80%81%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%87%E7%A8%8B-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A01.2%E3%80%81%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%87%E7%A8%8B\"> 1.2、遗传算法的基本过程</a></p>\n<p id=\"%C2%A01.3%E3%80%81%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%9A%84%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A01.3%E3%80%81%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%9A%84%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4\"> 1.3、遗传算法的具体步骤</a></p>\n<p id=\"%E4%BA%8C%E3%80%81%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%BB%8F%E5%85%B8%E6%A1%88%E4%BE%8B-toc\" style=\"margin-left:40px;\"><a href=\"#%E4%BA%8C%E3%80%81%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%BB%8F%E5%85%B8%E6%A1%88%E4%BE%8B\">二、遗传算法经典案例</a></p>\n<p id=\"2.1%E3%80%81%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E6%B1%82%E8%A7%A3%E5%87%BD%E6%95%B0%E6%9E%81%E5%A4%A7%E5%80%BC%E9%97%AE%E9%A2%982.4-toc\" style=\"margin-left:80px;\"><a href=\"#2.1%E3%80%81%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E6%B1%82%E8%A7%A3%E5%87%BD%E6%95%B0%E6%9E%81%E5%A4%A7%E5%80%BC%E9%97%AE%E9%A2%982.4\">2.1、遗传算法求解函数极大值问题</a></p>\n<p id=\"2.2%E3%80%81%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E6%B1%82%E8%A7%A3%E5%87%BD%E6%95%B0%E6%9E%81%E5%B0%8F%E5%80%BC%E9%97%AE%E9%A2%98-toc\" style=\"margin-left:80px;\"><a href=\"#2.2%E3%80%81%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E6%B1%82%E8%A7%A3%E5%87%BD%E6%95%B0%E6%9E%81%E5%B0%8F%E5%80%BC%E9%97%AE%E9%A2%98\">2.2、遗传算法求解函数极小值问题</a></p>\n<p id=\"2.3%E3%80%81%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E6%B1%82%E8%A7%A3%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98(TSP)-toc\" style=\"margin-left:80px;\"><a href=\"#2.3%E3%80%81%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E6%B1%82%E8%A7%A3%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98%28TSP%29\">2.3、遗传算法求解旅行商问题(TSP)</a></p>\n<p id=\"2.4%E3%80%81%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E6%B1%82%E8%A7%A3%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98-toc\" style=\"margin-left:80px;\"><a href=\"#2.4%E3%80%81%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E6%B1%82%E8%A7%A3%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98\">2.4、遗传算法求解背包问题</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h2 id=\"%E4%B8%80%E3%80%81%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%9A%84%E6%A6%82%E5%BF%B5\">一、遗传算法的概念</h2>\n<h3 id=\"1.1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\">1.1、基本概念</h3>\n<p>遗传算法(Genetic Algorithm,GA):模仿生物的遗传进化原理，通过选择、交叉、变异等操作，使得种群个体的适应性不断提高，物竞天择，适者生存。智能算法，全局搜索寻优。</p>\n<p>遗传算法的特点如下：</p>\n<p><img alt=\"\" height=\"511\" src=\"image\\57cf9264e50341aab7abcdf3775d7e2b.png\" width=\"936\"/></p>\n<p> 遗传算法的应用领域比较广泛，具体涉及的应用领域如下：</p>\n<p><img alt=\"\" height=\"558\" src=\"image\\f3f5018417ca457a9ba1f4771673f49b.png\" width=\"892\"/></p>\n<p>我们看三个概念，即个体，种群，适应度。初始解组成的是个体，多个个体组成的称为种群，适应度是指衡量个体适应高低的，适应度函数一般就是指的目标函数。</p>\n<p><img alt=\"\" height=\"403\" src=\"image\\17de264dd133488dad1b0c2e3df78ce1.png\" width=\"948\"/></p>\n<p><img alt=\"\" height=\"296\" src=\"image\\e29289f2ec484a11868da05fdf667a37.png\" width=\"921\"/></p>\n<p> 下面看一下编码和解码的概念，本文中的编码和解码如下，编码是指将原来的个体改变成能进行选择，交叉，和变异等操作的染色体的过程。而解码就是将染色体转换成为原始的个体，即最优解。编码是遗传算法解决问题的先决条件和关键步骤，常用的编码方式有：二进制编码，浮点数编码等。<span style=\"color:#fe2c24;\">一般来说，二进制编码比浮点型编码的搜索能力更强，浮点型编码在种群多样性的操作更具多样性。</span></p>\n<p><img alt=\"\" height=\"341\" src=\"image\\e7ddfa70d0cb43e0b19b99f86cbeed72.png\" width=\"962\"/></p>\n<p>下面看一下遗传操作的选择，交叉与变异。选择操作就是选择好的进行遗传，交叉就是随机配对，变异就是改变基因到其对应的基因。</p>\n<p><img alt=\"\" height=\"500\" src=\"image\\bec997ef355f4377a28e689adb01696e.png\" width=\"949\"/></p>\n<h3 id=\"%C2%A01.2%E3%80%81%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%87%E7%A8%8B\"> 1.2、遗传算法的基本过程</h3>\n<p>遗传算法的基本过程如下：主要包括：收集问题参数并编码成染色体，初始化种族群体，通过选择交叉，变异等遗传操作更新群体，并计算群体的适应度，直到达到迭代次数或者适应度值不发生改变，则终止循环，并对染色体进行解码，即可得到问题的最优解。</p>\n<p><img alt=\"\" height=\"550\" src=\"image\\df6188cf9c8f4acabd7184a56f1cfc2b.png\" width=\"944\"/></p>\n<p>下面看一下遗传算法的具体步骤：</p>\n<p>首先，我们需要确定决策变量和约束条件，这个通常根据题意获得。然后建立模型，需要确定目标函数，然后需要找出个体，并对个体进行编码，编码是非常重要的，常用的编码方式是二进制编码。</p>\n<p><img alt=\"\" height=\"798\" src=\"image\\b3fd1c59731841498c778849881f1f3e.png\" width=\"1200\"/></p>\n<p>标准的遗传算法基本是采用二进制编码，就是将个体(决策变量)用二进制串连在一起，构成染色体。编码完成，最后留下满足适应度函数的染色体后，还需要进行解码成个体，所以需要确定解码方法。其实就是还原成原来的决策变量。</p>\n<p><img alt=\"\" height=\"782\" src=\"image\\6314c08e5e3e4afcbadc4d2dc3b4a044.png\" width=\"1200\"/></p>\n<p>然后，我们需要确定个体适应度的量化方法，即确定适应度函数，通过适应度函数去求解最优的决策变量，一般比较常用的就是直接将目标函数作为适应度函数，当然也有其它方法去确定适应度函数。</p>\n<p><img alt=\"\" height=\"732\" src=\"image\\598e2a898d9c4b00b766eb27935f0ede.png\" width=\"1200\"/></p>\n<p> <img alt=\"\" height=\"766\" src=\"image\\651eac57fe314430ab8a075a1e36861f.png\" width=\"1200\"/></p>\n<p> </p>\n<p>有了适应度函数后，我们就可以确定选择，交叉和变异的方式，个体选择常用的方法是按比例适应度分配，个体的适应度在总适应度的比例越大，即被选取的概率越大，遗产因子就会在种群中逐渐扩大。</p>\n<p><img alt=\"\" height=\"745\" src=\"image\\186a2c843ac9487aa32a236b9e34aa31.png\" width=\"1200\"/></p>\n<p>计算出每个个体的选择概率后，我们就使用轮盘赌法进行选择，其实就是概率越大，轮盘所占比例越大，被选中的可能越大。</p>\n<p><img alt=\"\" height=\"770\" src=\"image\\ba6c1e4f69ad41d2ab08a5473aa1e8bb.png\" width=\"1200\"/>遗传的相关操作除了选择之外，还有交叉和变异，我们下面看一下交叉操作，交叉其实就是序列的交换，交叉率不宜过大，也不宜过小，一般取0.4-0.9。</p>\n<p><img alt=\"\" height=\"858\" src=\"image\\f2b0ae2de4194450b89912c1960cd604.png\" width=\"1200\"/> </p>\n<p> 下面看一下变异操作，对于二进制编码的变异，就是将1变成0，或者将0变成1，也应该选取合适的变异率，变异率过大和过小都不好。</p>\n<p><img alt=\"\" height=\"869\" src=\"image\\d6d0c2425302485eba9a51a1f7a7c593.png\" width=\"1200\"/></p>\n<p> </p>\n<p><img alt=\"\" height=\"832\" src=\"image\\17778401ae38442ebc7f895ca24966d9.png\" width=\"1200\"/></p>\n<h3 id=\"%C2%A01.3%E3%80%81%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%9A%84%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4\"> 1.3、遗传算法的具体步骤</h3>\n<p> 遗传算法的具体步骤如下：首先对个体编码成染色体，初始化群体并计算解码后的适应值，然后进行遗传操作形成下一代群体， 判断是否满足要求，不满足则继续迭代，直到满足要求或者达到迭代次数。</p>\n<p><img alt=\"\" height=\"597\" src=\"image\\316ab1165dbe43f889f4026f0d6f5395.png\" width=\"1200\"/></p>\n<h2 id=\"%E4%BA%8C%E3%80%81%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%BB%8F%E5%85%B8%E6%A1%88%E4%BE%8B\">二、遗传算法经典案例</h2>\n<h3 id=\"2.1%E3%80%81%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E6%B1%82%E8%A7%A3%E5%87%BD%E6%95%B0%E6%9E%81%E5%A4%A7%E5%80%BC%E9%97%AE%E9%A2%982.4\">2.1、遗传算法求解函数极大值问题</h3>\n<p><img alt=\"\" height=\"289\" src=\"image\\716214f81c26453a9e898cd313e99301.png\" width=\"1200\"/></p>\n<p> 用标准遗传算法求函数<strong>f(x)=x+10sin(5x)+7cos(4x) </strong>的最大值，其中 x 的取值范围为[0,10]。这是一个有多个局部极值的函数。</p>\n<p>下面是使用遗传算法求解该函数模型最大值的具体步骤：</p>\n<p>（1）初始化种群数目为 NP=50，染色体的编码方式选择二级制编码，二进制编码长度为 L=20，遗传算法的最大进化迭代数为 G=100，交叉概率 取Pc=0.8，变异概率取Pm=0.1。</p>\n<p>（2）产生初始种群，将二进制编码转换成十进制，计算个体适应度值，并进行归一化；采用基于轮盘赌的选择操作、基于概率的交叉和变异操作，产生新的种群，并把历代的最优个体保留在新种群中，进行下一步遗传操作。</p>\n<p>（3）判断是否满足终止条件：若满足，则结束搜索过程，输出优化值；若不满足，则继续进行迭代优化。</p>\n<p>优化结束后，其适应度进化曲线如下图所示，最优个体 x= 7.8569，函数 f(x)的最大值为 24.8554。这个值不是固定的，每次执行都会有些许波动。</p>\n<p>遗传算法的具体流程图如下：</p>\n<p><img alt=\"\" height=\"992\" src=\"image\\872cd6ea809d4cce9836df1faeeba417.png\" width=\"1098\"/></p>\n<p> 完整的matlab代码如下，注释很全：</p>\n<pre><code class=\"hljs\">%遗传算法求函数极值\nclear \nclc\nNP = 50; %种群数量\nL = 20; %二进制位串长度\nPc = 0.8; %交叉率\nPm = 0.1; %变异率\nG = 100; %最大遗传迭代次数\nXs = 10; %个体最小值\nXx = 0; %个体最大值\nf = randi([0,1],NP,L); %随机获得初始种群\n%遗传算法\nfor k = 1:G\n    for i = 1:NP\n        U = f(i,:); %遍历每个种群\n        m = 0;\n        for j = 1:L %遍历种群的每个二进制位\n            m = U(j)*2^(j-1)+m ; %将二进制转换成十进制\n        end\n        x(i) = Xx+m*(Xs-Xx)/(2^L-1); %对染色体进行解码得到个体\n        Fit(i) = func1(x(i)); %通过目标函数计算个体的适应度\n    end\n    maxFit = max(Fit); %适应度最大值\n    minFit = min(Fit); %适应度最小值\n    rr = find(Fit==maxFit); %找到适应度最大值的的位置\n    fBest = f(rr(1,1),:); %最适应的种群\n    xBest = x(rr(1,1)); %最适应的染色体，即个体\n    Fit = (Fit-minFit)/(maxFit-minFit); %归一化适应度值\n    \n    %基于轮盘赌法的选择操作\n    sum_Fit = sum(Fit) ; %对适应度进行求和\n    fitvalue = Fit./sum_Fit; %求每个适应度被选中的概率\n    fitvalue = cumsum(fitvalue) ; %得到累加后的概率\n    ms = sort(rand(NP,1)) ; %随机生成概率值，并由小到大排序\n    fiti = 1;\n    newi = 1;\n    while newi &lt;= NP\n        if ms(newi) &lt; fitvalue(fiti) %如果随机生成的概率值小于被选中的概率\n            nf(newi,:) = f(fiti,:); %找到选择出来的染色体\n            newi = newi+1;\n        else %不满足条件，继寻找合适的染色体\n            fiti = fiti+1;\n        end\n    end\n    %交叉操作，就是二进制对应0和1的互换\n    for i = 1:2:NP  %遍历种群\n        p = rand ; %随机产生的一个概率\n        if p &gt; Pc %要保证随机产生的概率大于交叉率\n            q = rand(1,L);\n            for j = 1:L\n                if q(j)==1 %只要随机产生的位置等于1，就进行交叉\n                    %将被选择的二级制进行交换，即交叉\n                    temp = nf(i+1,j);\n                    nf(i+1,j) = nf(i,j);\n                    nf(i,j) = temp;\n                end\n            end\n        end\n    end\n    %变异操作，就是二进制取反操作\n    i = 1;\n    while i &lt;= round(NP*Pm)\n        h = randi([1,NP],1,1); %随机选取一个需要变异的染色体\n        for j = 1:round(L*Pm)\n            g = randi([1,L],1,1); %随机选取需要变异的基因数\n            nf(h,g) =~ nf(h,g); %取反变异\n        end\n        i = i+1;\n    end\n    f = nf; %更新种群\n    f(1,:) = fBest; %保留最优个体在新种群中\n    trace(k) = maxFit; %保存最优的适应度\nend\ndisp('最优个体如下：') ;\ndisp(xBest) ;\ndisp('函数最大值：') ;\ndisp(func1(xBest)) ;\nfigure\nplot(trace)\nxlabel('迭代次数')\nylabel('目标函数值')\ntitle('适应度进化曲线')</code></pre>\n<p>适应度函数即目标函数如下：</p>\n<pre><code class=\"hljs\">function result = func1(x)\nfit = x+10*sin(5*x)+7*cos(4*x);\nresult = fit;\nend\n</code></pre>\n<p>迭代过程的适应度进行如下，最终的值在24.85左右，即函数的最值为24.85左右。<br/><img alt=\"\" height=\"995\" src=\"image\\dd656fe59fe14d42aedd843775f370a2.png\" width=\"1124\"/></p>\n<h3 id=\"2.2%E3%80%81%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E6%B1%82%E8%A7%A3%E5%87%BD%E6%95%B0%E6%9E%81%E5%B0%8F%E5%80%BC%E9%97%AE%E9%A2%98\">2.2、遗传算法求解函数极小值问题</h3>\n<p><img alt=\"\" height=\"95\" src=\"image\\242350160b0546bdba350293be3a50da.png\" width=\"1200\"/></p>\n<p>（1）初始化种群数目为 NP=100，染色体的编码方式选择二级制编码，二进制编码长度为 L=10，遗传算法的最大进化迭代数为 G=1000，交叉概率 取Pc=0.8，变异概率取Pm=0.1。</p>\n<p>（2）产生初始种群，将二进制编码转换成十进制，计算个体适应度值；采用基于轮盘赌的选择操作、基于概率的交叉和变异操作，产生新的种群，并把历代的最优个体保留在新种群中，进行下一步遗传操作。</p>\n<p>（3）判断是否满足终止条件：若满足，则结束搜索过程，输出优化值；若不满足，则继续进行迭代优化。</p>\n<pre><code class=\"hljs\">%遗传算法求函数极值\nclear \nclc\nNP = 100; %种群数量\nL = 10; %二进制位串长度\nPc = 0.8; %交叉率\nPm = 0.1; %变异率\nG = 1000; %最大遗传迭代次数\nXs = 20; %个体上限\nXx = -20; %个体下线\nf = randi([0,1],NP,L); %随机获得初始种群\n%遗传算法\nfor k = 1:G\n    for i = 1:NP\n        U = f(i,:); %遍历每个种群\n        m = 0;\n        for j = 1:L %遍历种群的每个二进制位\n            m = U(j)*2^(j-1)+m ; %将二进制转换成十进制\n        end\n        x(i) = Xx+m*(Xs-Xx)/(2^L-1); %对染色体进行解码得到个体\n        Fit(i) = -func2(x(i)); %通过目标函数计算个体的适应度\n    end\n    maxFit = max(Fit); %适应度最大值\n    %minFit = min(Fit); %适应度最小值\n    rr = find(Fit==maxFit); %找到适应度最小值的的位置\n    fBest = f(rr(1,1),:); %最适应的种群\n    xBest = x(rr(1,1)); %最适应的染色体，即个体\n   % Fit = (Fit-minFit)/(maxFit-minFit); %归一化适应度值\n    \n    %基于轮盘赌法的选择操作\n    sum_Fit = sum(Fit) ; %对适应度进行求和\n    fitvalue = Fit./sum_Fit; %求每个适应度被选中的概率\n    fitvalue = cumsum(fitvalue);  %得到累加后的概率\n    ms = sort(rand(NP,1)) ; %随机生成概率值，并由小到大排序\n    fiti = 1;\n    newi = 1;\n    while newi &lt;= NP\n        if ms(newi) &lt; fitvalue(fiti) %如果随机生成的概率值小于被选中的概率\n            nf(newi,:) = f(fiti,:); %找到选择出来的染色体\n            newi = newi+1;\n        else %不满足条件，继寻找合适的染色体\n            fiti = fiti+1;\n        end\n    end\n    %交叉操作，就是二进制对应0和1的互换\n    for i = 1:2:NP  %遍历种群\n        p = rand ; %随机产生的一个概率\n        if p &gt; Pc %要保证随机产生的概率大于交叉率\n            q = rand(1,L);\n            for j = 1:L\n                if q(j)==1 %只要随机产生的位置等于1，就进行交叉\n                    %将被选择的二级制进行交换，即交叉\n                    temp = nf(i+1,j);\n                    nf(i+1,j) = nf(i,j);\n                    nf(i,j) = temp;\n                end\n            end\n        end\n    end\n    %变异操作，就是二进制取反操作\n    i = 1;\n    while i &lt;= round(NP*Pm)\n        h = randi([1,NP],1,1); %随机选取一个需要变异的染色体\n        for j = 1:round(L*Pm)\n            g = randi([1,L],1,1); %随机选取需要变异的基因数\n            nf(h,g) =~ nf(h,g); %取反变异\n        end\n        i = i+1;\n    end\n    f = nf; %更新种群\n    f(1,:) = fBest; %保留最优个体在新种群中\n    trace(k) = -maxFit; %保存最大的适应度\nend\ndisp('最优个体如下：') ;\ndisp(xBest) ;\ndisp('函数最小值：') ;\ndisp(func2(xBest)) ;\nfigure\nplot(trace)\nxlabel('迭代次数')\nylabel('目标函数值')\ntitle('适应度进化曲线')</code></pre>\n<p>适应度函数如下：</p>\n<pre><code class=\"hljs\">function result=func2(x)\nsumm=sum(x.^2);\nresult=summ;\nend\n</code></pre>\n<p>运行结果如下：</p>\n<p><img alt=\"\" height=\"256\" src=\"image\\549cbd51060d47618e80d33b65ccdbc9.png\" width=\"942\"/></p>\n<p> <img alt=\"\" height=\"995\" src=\"image\\abb9e068ea7b4728b98f32b4b4bc5a61.png\" width=\"1124\"/></p>\n<h3 id=\"2.3%E3%80%81%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E6%B1%82%E8%A7%A3%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98(TSP)\">2.3、遗传算法求解旅行商问题(TSP)</h3>\n<p>[旅行商问题]（TSP）。<strong>假设有一个旅行商人要拜访全国31个省会城市，他需要选择所要走的路径，路径的限制是每个城市只能拜访一次，而且最后要回到原来出发的城市。对路径选择的要求是：所选路径的路程为所有路径之中的最小值。</strong>全国31个省会城市的坐标为［1304 2312；3639 1315；4177 2244；37121399；3488 1535；3326 1556；3238 1229；4196 1004；4312 790；4386 570；3007 1970；2562 1756；2788 1491；2381 1676；1332695；3715 1678；3918 2179；4061 2370；3780 2212；3676 2578；4029 2838；4263 2931；3429 1908；3507 2367；3394 2643；34393201；2935 3240；3140 3550；2545 2357；2778 2826；2370 2975］。</p>\n<p>（1）初始化种群数目为NP=200,最大遗传迭代数目为G=1000，染色体基因个数为N=31，即城市数目。</p>\n<p>（2）产生初始种群，计算个体适应度值，即路径长度；采用基于概率的方式选择进行操作的个体；对选中的成对个体，随机交叉所选中的成对城市坐标，以确保交叉后路径每个城市只到访一次；对选中的单个个体，随机交换其一对城市坐标作为变异操作，产生新的种群，进行下一次遗传操作。</p>\n<p>（3）判断是否满足终止条件：若满足，则结束搜索过程，输出优化值；若不满足，则继续进行迭代优化。</p>\n<p>Matlab代码如下：</p>\n<pre><code class=\"hljs\">%遗传算法解决TSP问题\nclear \nclose all; \nclc;   \nC=[1304 2312;3639 1315;4177 2244;3712 1399;3488 1535;3326 1556;...\n    3238 1229;4196 1044;4312  790;4386  570;3007 1970;2562 1756;...\n    2788 1491;2381 1676;1332  695;3715 1678;3918 2179;4061 2370;...\n    3780 2212;3676 2578;4029 2838;4263 2931;3429 1908;3507 2376;...\n    3394 2643;3439 3201;2935 3240;3140 3550;2545 2357;2778 2826;...\n    2370 2975];%省会城市坐标\nN=size(C,1);%C的行数,即城市数目\nD=zeros(N);%N*N的零矩阵，初始化任意两个城市距离间隔矩阵\n%求任意两个城市距离间隔矩阵\nfor i=1:N\n    for j=1:N\n        D(i,j)=((C(i,1)-C(j,1))^2+(C(i,2)-C(j,2))^2)^0.5;\n    end\nend\nNP=200;%种群数目\nG=1000;%最大遗传迭代数\nf=zeros(NP,N);%NP*N的零矩阵，用于存储种群\nF=[];%种群更新中间存储\nfor i=1:NP\n    f(i,:)=randperm(N);%1~N之间的随机数，随机生成初始种群\nend\nR=f(1,:);%用于存储最优种群\nlen=zeros(NP,1);%用于存储路径长度\nfitness=zeros(NP,1);%用于存储归一化适应值\ngen=0;\n%遗传算法循环，小于最大遗传迭代次数，则继续更新下一代\nwhile gen&lt;G\n    %计算路径长度\n    for i=1:NP\n        len(i,1)=D(f(i,N),f(i,1));\n        for j=1:(N-1)\n            len(i,1)=len(i,1)+D(f(i,j),f(i,j+1));\n        end\n    end\n    maxlen=max(len);%最长路径\n    minlen=min(len);%最短路径\n    %更新最短路径\n    rr=find(len==minlen);\n    R=f(rr(1,1),:);\n    %计算归一化适应值\n    for i=1:length(len)\n        fitness(i,1)=(1-((len(i,1)-minlen)/(maxlen-minlen+0.001)));\n    end\n    %选择操作\n    nn=0;\n    for i=1:NP\n        if fitness(i,1)&gt;=rand\n            nn=nn+1;\n            F(nn,:)=f(i,:);\n        end\n    end\n    [aa,bb]=size(F);\n    while aa&lt;NP\n        nnper=randperm(nn);\n        A=F(nnper(1),:);\n        B=F(nnper(2),:);\n        %交叉操作\n        W=ceil(N/10);%交叉点个数\n        p=unidrnd(N-W+1);%随机选择交叉范围，从p到p+W\n        for i=1:W\n            x=find(A==B(p+i-1));\n            y=find(B==A(p+i-1));\n            temp=A(p+i-1);\n            A(p+i-1)=B(p+i-1); \n            B(p+i-1)=temp;\n            temp=A(x); \n            A(x)=B(y); \n            B(y)=temp;\n        end\n        %变异操作\n        p1=floor(1+N*rand());\n        p2=floor(1+N*rand());\n        while p1==p2\n            p1=floor(1+N*rand());\n            p2=floor(1+N*rand());\n        end\n        tmp=A(p1); \n        A(p1)=A(p2); \n        A(p2)=tmp;\n        tmp=B(p1); \n        B(p1)=B(p2); \n        B(p2)=tmp;\n        F=[F;A;B];\n        [aa,bb]=size(F);\n    end\n    if aa&gt;NP\n        F=F(1:NP,:);%保持种群规模为n\n    end\n    f=F;%更新种群\n    f(1,:)=R;%保留每代最优个体\n    clear F;\n    gen=gen+1 ;\n    Rlength(gen)=minlen;\nend\nfigure\nfor i=1:N-1\n    plot([C(R(i),1),C(R(i+1),1)],[C(R(i),2),C(R(i+1),2)],'bo-');\n    hold on;\nend\ntitle(['优化最短距离:',num2str(minlen)]);\nfigure\nplot(Rlength)\nxlabel('迭代次数')\nylabel('目标函数值')\ntitle('适应度进化曲线')</code></pre>\n<p>运行结果如下：</p>\n<p><img alt=\"\" height=\"995\" src=\"image\\05934762da9a491d8706e5d5c952884d.png\" width=\"1124\"/></p>\n<p> <img alt=\"\" height=\"995\" src=\"image\\866e5a3731344868a62d8a1a17a1ac8a.png\" width=\"1124\"/></p>\n<p> </p>\n<h3 id=\"2.4%E3%80%81%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E6%B1%82%E8%A7%A3%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98\">2.4、遗传算法求解背包问题</h3>\n<p>[0-1背包问题]。有N件物品和一个容量为V的背包。第i件物品的体积是c(i)，价值是w(i)。求解将哪些物品放入背包<strong>可使物品的体积总和不超过背包的容量，且价值总和最大</strong>。假设物品数量为10，背包的容量为300。每件物品的体积为［95，75，23，73，50，22，6，57，89，98］，价值为［89，59，19，43，100，72，44，16，7，64］。</p>\n<p>（1）初始化种群数目为Np =50，染色体基因维数为L=10，最大进化代数为G=100。</p>\n<p>（2）产生二进制初始种群，其中1表示选择该物品，0表示不选择该物品。取适应度值为选择物品的价值总和，计算个体适应度值，当物品体积总和大于背包容量时，对适应度值进行惩罚计算。</p>\n<p>（3）对适应度进行归一化，采用基于轮盘赌的选择操作、基于概率的交叉和变异操作，产生新的种群，并把历代的最优个体保留在新种群中，进行下一步遗传操作。</p>\n<p>（4）判断是否满足终止条件：若满足，则结束搜索过程，输出优化值；若不满足，则继续进行迭代优化。<br/>  </p>\n<p>matlab代码如下：</p>\n<pre><code class=\"hljs\">%遗传算法解决0-1背包问题\nclear  \nclose all;\nclc; \nNP = 50;%种群规模\nL = 10;%物品件数\nPc = 0.8;%交叉率\nPm = 0.05;%变异率\nG = 100;%最大遗传代数\nV = 300;%背包容量\nC = [95,75,23,73,50,22,6,57,89,98]; %物品体积\nW = [89,59,19,43,100,72,44,16,7,64];%物品价值\nafa = 2; %惩罚函数系数\nf = randi([0,1],NP,L);%随机获得初始种群\nmaxFit = 0 ;\n%遗传算法循环部分\nfor k = 1:G\n    %适应度计算,即计算总价值\n    for i = 1:NP\n         Fit(i) = func4(f(i,:),C,W,V,afa);\n    end\n    maxFit = max(Fit);%最大价值\n    minFit = min(Fit);%最小价值\n    rr = find(Fit==maxFit);\n    fBest = f(rr(1,1),:);%历代最优个体\n    Fit = (Fit - minFit)/(maxFit - minFit);%归一化适应度值\n    %基于轮盘赌的选择\n    sum_Fit = sum(Fit); %求适应度和\n    fitvalue = Fit./sum_Fit;%求被选中的概率\n    fitvalue = cumsum(fitvalue);%累加\n    ms = sort(rand(NP,1)); %随机生成的概率，并按照由小到大排序\n    fiti = 1;\n    newi = 1;\n    while newi &lt;= NP\n        if (ms(newi)) &lt; fitvalue(fiti) %被选中的概率大于随机生成的\n            nf(newi,:) = f(fiti,:); %选择复制\n            newi = newi + 1;\n        else\n            fiti = fiti + 1;\n        end\n    end\n    %基于概率的交叉操作\n    for i = 1:2:NP\n        p = rand;\n        if p &gt; Pc\n            q = randi([0,1],1,L);          \n            for j = 1:L\n                if q(j)==1;\n                    temp = nf(i + 1,j);\n                    nf(i + 1,j) = nf(i,j);\n                    nf(i,j) = temp;\n                end\n            end\n        end\n    end\n    %基于概率的变异操作\n    for m = 1:NP\n        for n = 1:L\n            r = rand(1,1);\n            if r &lt; Pm\n                nf(m,n) = ~nf(m,n);\n            end\n        end\n    end\n    f = nf;\n    f(1,:) = fBest; %保留最优个体在新种群中\n    trace(k) = maxFit; %历代最优适应度\nend\ndisp('最优个体如下：') ;\ndisp(fBest) ;\ndisp('最大价值如下：') ;\ndisp(maxFit) ;\nfigure\nplot(trace)\nxlabel('迭代次数')\nylabel('目标函数值')\ntitle('适应度进化曲线')</code></pre>\n<p>适应度函数的代码如下：</p>\n<pre><code class=\"hljs\">%适应度函数，求物品价值总和\nfunction result = func4(f,C,W,V,afa)\nfit = sum(f.*W); %物品价值总和\nTotalSize = sum(f.*C); %物品总体积\nif TotalSize &lt;= V %物品总体积小于背包容量\n    fit = fit;\nelse %物品总体积大于背包容量\n    fit = fit - afa * (TotalSize - V);\nend\nresult = fit;\nend</code></pre>\n<p>运行结果如下：其实10个物品，1表示选择该物品，0表示不选择该物品，最后的最大总价值为388</p>\n<p><img alt=\"\" height=\"237\" src=\"image\\c433c6c30e7c41ab98d496ce5dbc0d02.png\" width=\"980\"/></p>\n<p> </p>\n<p><img alt=\"\" height=\"995\" src=\"image\\7a7725fbbf67422dbb43f8a22863d5b7.png\" width=\"1124\"/></p>\n</div>\n</div>"}