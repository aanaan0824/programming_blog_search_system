{"blogid": "126308911", "writerAge": "码龄1年", "writerBlogNum": "11", "writerCollect": "23", "writerComment": "36", "writerFan": "308", "writerGrade": "2级", "writerIntegral": "312", "writerName": "假正经的小柴", "writerProfileAdress": "writer_image\\profile_126308911.jpg", "writerRankTotal": "45325", "writerRankWeekly": "913", "writerThumb": "168", "writerVisitNum": "1768", "blog_read_count": "390", "blog_time": "于 2022-08-12 21:29:53 发布", "blog_title": "c++面向对象的好朋友：友元---可分享私有成员", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>      我们知道c++的一个类中，可以自行访问成员变量和成员函数，此时不论什么访问权限，也都是可以访问的。</p>\n<p>      那对外呢？</p>\n<p>      对外界类，我们可以看一下下面这张表关于类与类之间访问权限进行的总结</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\c48679f9d7fd438dbe3f6fd28a1d6c8c.jpeg\"/></p>\n<p>（<strong>派生类是c++继承有关的知识点，外界函数对类内访问与表中“外部的类”访问权限情况是一致的。</strong>）</p>\n<p>举个例子：</p>\n<p><img alt=\"\" height=\"679\" src=\"image\\06493804b1e64795bf124ccf50322395.png\" width=\"639\"/></p>\n<p style=\"text-align:center;\"> <img alt=\"\" src=\"image\\e383ad9e561844179c918739ff1b615e.png\"/></p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\9d5b64ec212e434a966fc1c71354a79a.png\"/> </p>\n<p>      我们可以看见编译后有俩条明显的错误，说m_width与m_length是私有的.这里说明这外部函数是不能直接性的访问类内的私有成员的。 </p>\n<p>      <strong>表中我们也可以明显的看出外部是无法访问类中的私有成员的，那怎样使得外部可以访问到类中私有成员呢？</strong>------<span style=\"color:#ff9900;\"><strong>友元就可以达到这个目的，它可以让一个函数或者一个类访问另一个类中的私有成员。友元的关键字为 friend 。</strong></span></p>\n<p><strong>      友元有三种实现：</strong></p>\n<ul><li><strong>全局函数做友元</strong></li><li><strong>类做友元</strong></li><li><strong>成员函数做友元</strong></li></ul>\n<p>(个人巧记：<span style=\"color:#9c8ec1;\">根据友元的关键字是friend，中文翻译是朋友的意思，我们可以理解为朋友之间的分享，从而促使函数或者另一个类可以访问自己</span>）</p>\n<p style=\"text-align:center;\">      <strong>1.全局函数做友元</strong></p>\n<p>       在上面例子中，我要想让全局函数useShape(Shape&amp; shape)可以访问到Shape类内成员而不会报错怎么做呢？<span style=\"color:#ff9900;\"><strong>我们可以把这个全局函数当成这个类的好朋友，在这个类的开头声明一下----friend void useShape(Shape&amp; shape);成为好朋友之后呢，就可以访问类中的私有成员了。</strong></span><span style=\"color:#fe2c24;\">此处声明就和全局函数声明差不多，前面多加了个friend而已。</span></p>\n<p>       下面可以看一下完整的代码:</p>\n<pre><code class=\"language-cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\n//创建一个图形类. \nclass Shape{\n\t//useShape全局函数是 Shape 好朋友，可以访问 Shape 中的私有成员. \n\tfriend void useShape(Shape&amp; shape);\npublic:\n\tShape(int width,int length){\n\t\tthis-&gt;m_length = length;\n\t\tthis-&gt;m_width = width;\n\t}\n\t~Shape(){}\n\tvoid printArear(){\n\t\tcout&lt;&lt;m_width*m_length&lt;&lt;endl;\n\t}\nprivate:\n\tint m_width;\n\tint m_length;\n};\n\n//全局函数 \nvoid useShape(Shape&amp; shape){\n\tcout&lt;&lt;\"Shape m_length is \"&lt;&lt;shape.m_length&lt;&lt;endl;\n\tcout&lt;&lt;\"Shape m_width is \"&lt;&lt;shape.m_width&lt;&lt;endl;\n\tcout&lt;&lt;\"Shape arear is \";\n\tshape.printArear();\n}\n\nint main(){\n\tShape shape(4,5);\n\tuseShape(shape);\n\treturn 0;\n}\n</code></pre>\n<p style=\"text-align:center;\"><strong>2.类做友元</strong></p>\n<p>       <strong>类做友元和全局函数做友元操作其实差距不大，声明也是在类最上头声明就好，告诉自己这个类是自己的朋友，形式：friend class+类名;这样就可以访问私有成员了.</strong></p>\n<p>      直接看完整代码直观点:</p>\n<pre><code class=\"language-cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\n//创建一个图形类. \nclass Shape{\n\t//ShapeGay类是 Shape 好朋友，可以访问 Shape 中的私有成员. \n\tfriend class ShapeGay;\npublic:\n\tShape(){\n\tm_length = 5;\n\tm_width = 4;\n\t}\n\tShape(int width,int length){\n\t\tthis-&gt;m_length = length;\n\t\tthis-&gt;m_width = width;\n\t}\n\t~Shape(){}\n\tvoid printArear(){\n\t\tcout&lt;&lt;m_width*m_length&lt;&lt;endl;\n\t}\nprivate:\n\tint m_width;\n\tint m_length;\n};\n\nclass ShapeGay{\npublic:\n\tshapeGay(){\n\t}\n\t~ShapeGay(){\n\t}\n\tvoid visitShape(){\n\tcout&lt;&lt;\"Shape m_length is \"&lt;&lt;shape.m_length&lt;&lt;endl;\n\tcout&lt;&lt;\"Shape m_width is \"&lt;&lt;shape.m_width&lt;&lt;endl;\n\tcout&lt;&lt;\"Shape arear is \";\n\tshape.printArear();\n\t}\nprivate:\n\tShape shape;\n};\n\nint main(){\n\tShapeGay gg;\n\tgg.visitShape();\n\treturn 0;\n}\n</code></pre>\n<p style=\"text-align:center;\"><strong>3.成员函数做友元</strong></p>\n<p>      <strong><span style=\"color:#ff9900;\">成员函数做友元我们可以在类内定义该成员函数，然后在类外实现这个函数(类外实现成员函数的格式：数据类型 类名::函数名())，记得进行注释，从而与其他函数进行区分，便于查看。这里需要把这个类的成员函数放类外实现，放在类内实现会报错。</span>养成写在类外也是一个好的习惯，可以更好地维护代码。</strong></p>\n<p>      具体实现看代码：</p>\n<pre><code class=\"language-cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nclass Shape;//提前声明类，以免在其他类内使用报错 \n\nclass ShapeGay{\nprivate:\n\tShape* shape;\npublic:\n\tShapeGay();\n\t~ShapeGay();\n\tvoid visitShape(); //是Shape类的朋友,可以访问Shape类内的私有成员. \n};\n\n//创建一个图形类. \nclass Shape{\n\t//ShapeGay类中visitShape()函数是 Shape 好朋友，可以访问 Shape 中的私有成员. \n\tfriend void ShapeGay::visitShape();\npublic:\n\tShape(){\n\tm_length = 5;\n\tm_width = 4;\n\t}\n\tShape(int width,int length){\n\t\tthis-&gt;m_length = length;\n\t\tthis-&gt;m_width = width;\n\t}\n\t~Shape(){}\n\tvoid printArear(){\n\t\tcout&lt;&lt;m_width*m_length&lt;&lt;endl;\n\t}\nprivate:\n\tint m_width;\n\tint m_length;\n};\n\nShapeGay::ShapeGay(){\n\tshape = new Shape;\n}\n\nShapeGay::~ShapeGay(){\n\tdelete shape;\n}\n\nvoid ShapeGay::visitShape(){\n\tcout&lt;&lt;\"Shape m_length is \"&lt;&lt;shape-&gt;m_length&lt;&lt;endl;\n\tcout&lt;&lt;\"Shape m_width is \"&lt;&lt;shape-&gt;m_width&lt;&lt;endl;\n\tcout&lt;&lt;\"Shape arear is \";\n\tshape-&gt;printArear();\n}\n\nint main(){\n\tShapeGay gg;\n\tgg.visitShape();\n\treturn 0;\n}\n</code></pre>\n<p style=\"text-align:center;\">（心里话对好朋友说啊）<img alt=\"\" src=\"https://img-blog.csdnimg.cn/68e45c71e1d64d33ad874c960f4606fa.gif\"/></p>\n<p> </p>\n</div>\n</div>"}