{"blogid": "123501908", "writerAge": "码龄1年", "writerBlogNum": "32", "writerCollect": "2903", "writerComment": "3788", "writerFan": "7896", "writerGrade": "6级", "writerIntegral": "6770", "writerName": "程序猿教你打篮球", "writerProfileAdress": "writer_image\\profile_123501908.jpg", "writerRankTotal": "2069", "writerRankWeekly": "104", "writerThumb": "2593", "writerVisitNum": "246283", "blog_read_count": "9430", "blog_time": "已于 2022-07-13 20:41:19 修改", "blog_title": "你还不懂栈和队列的实现吗？（图解剖析）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<div style=\"text-align:center;\">\n<div class=\"img-center\">\n<figure class=\"image\">\n<img alt=\"\" height=\"89\" src=\"image\\9443238a713141018a304158238c54ee.png\" width=\"96\"/>\n<figcaption>\n    篮球哥温馨提示：编程的同时不要忘记锻炼哦！\n   </figcaption>\n</figure>\n</div>\n</div>\n<h1 style=\"text-align:center;\"><strong>吃得了符号的亏，上得了大小写的当，你方可成为大牛！😎</strong></h1>\n<p style=\"text-align:center;\"><strong>为系统而生，为框架而死，为Debug奋斗一辈子！🦍</strong></p>\n<hr/>\n<p>可算是把链表给结束了，很多小伙伴已经迫不及待想看到栈和队列了，那么它来了！相信有了顺序表和链表的基础，栈和队列对于你们来讲也是轻轻松松，那我就废话不多说，直接进入今天的重点：</p>\n<blockquote>\n<p><span style=\"color:#4da8ee;\"><strong>⚽ 1、栈的介绍</strong></span></p>\n<p><span style=\"color:#4da8ee;\"><strong>🥎 2、栈的常用接口实现</strong></span></p>\n<p><span style=\"color:#4da8ee;\"><strong>🏐 3、队列的介绍</strong></span></p>\n<p><span style=\"color:#4da8ee;\"><strong>🏀 4、队列的常用接口实现</strong></span></p>\n</blockquote>\n<hr/>\n<h3><strong><span style=\"color:#ad720d;\">⚽  1、栈的介绍：</span></strong></h3>\n<blockquote>\n<p><span style=\"color:#fe2c24;\"><strong>栈：</strong></span>一种特殊的线性表，其只允许在固定的一端进行插入和删除元素操作。<span style=\"color:#0d0016;\"><strong>进行数据插入和删除操作的一端称为栈顶，另一端称为栈底。</strong></span>栈中的数据元素遵守后进先出LIFO（Last In First Out）的原则。</p>\n<p><strong><span style=\"color:#fe2c24;\">压栈：</span></strong>栈的插入操作叫做进栈/压栈/入栈，<span style=\"color:#0d0016;\"><strong>入数据在栈顶。</strong></span></p>\n<p><strong><span style=\"color:#fe2c24;\">出栈：</span></strong>栈的删除操作叫做出栈。<span style=\"color:#0d0016;\"><strong>出数据也在栈顶。</strong></span></p>\n</blockquote>\n<p><img alt=\"\" src=\"image\\7024be5db90b4103961e229066314cbb.png\"/></p>\n<p><strong>栈的实现一般可以使用数组或者链表实现，相对而言数组的结构实现更优一些。因为数组在尾上 插入数据的代价比较小。</strong></p>\n<p><strong><span style=\"color:#fe2c24;\">本次我们是用动态数组来实现栈！静态栈在实际中一般不实用！</span></strong></p>\n<h3><span style=\"color:#ad720d;\"><strong>🥎 2、栈的常用接口实现</strong> </span></h3>\n<blockquote>\n<p><strong> 🎸 首先是我们动态栈的结构：</strong></p>\n</blockquote>\n<p> 有了顺序表和链表的基础我就直接上代码了！</p>\n<pre><code class=\"language-cpp\">typedef int STDataType;\n\ntypedef struct Stack\n{\n\tSTDataType* a;\n\tint top;\n\tint capacity;\n}ST;</code></pre>\n<blockquote>\n<p><strong>🎻 栈的初始化：</strong></p>\n</blockquote>\n<p><img alt=\"\" src=\"image\\1ac1854e78594081b732c5906c2c0532.png\"/></p>\n<blockquote>\n<p><strong> ⛳ 入栈操作：</strong></p>\n</blockquote>\n<p style=\"text-align:center;\"> <img alt=\"\" src=\"image\\9d9a7d7f14174355bc1ef0567251a2e6.png\"/></p>\n<blockquote>\n<p><strong> 🎋 出栈操作：</strong></p>\n</blockquote>\n<p><strong>出栈就很简单了，我们直接使top--就可以了，因为我们插入数据是先在top位置插入，然后再top++，这样我们下次插入数据就会覆盖pos位置的数据！<span style=\"color:#fe2c24;\">注意：当栈没有初始化，没有数据的情况下不能进行出栈操作！</span></strong></p>\n<pre><code class=\"language-cpp\">void StackPop(ST* ps)\n{\n\tassert(ps);\n\tassert(ps-&gt;top &gt; 0);\n\tps-&gt;top--;\n}</code></pre>\n<blockquote>\n<p><strong> 🎁 取栈顶元素操作：</strong></p>\n</blockquote>\n<p><strong> 我们知道top是栈顶元素的后一个，所以我们直接取top-1下标位置的数据就可以！</strong></p>\n<pre><code class=\"language-cpp\">STDataType StackTop(ST* ps)\n{\n\tassert(ps);\n\tassert(ps-&gt;top &gt; 0);\n\treturn ps-&gt;a[ps-&gt;top - 1];\n}</code></pre>\n<blockquote>\n<p><strong>🎨  求栈的节点个数：</strong></p>\n</blockquote>\n<pre><code class=\"language-cpp\">int StackSize(ST* ps)\n{\n\tassert(ps);\n\treturn ps-&gt;top;\n}</code></pre>\n<blockquote>\n<p><strong>🎠 判断栈是否为空：</strong></p>\n</blockquote>\n<p> 我们使用返回值为bool型的函数，bool类型只会返回true或false见下代码：</p>\n<pre><code class=\"language-cpp\">bool StackEmpty(ST* ps)\n{\n\tassert(ps);\n\treturn ps-&gt;top == 0;\n}</code></pre>\n<blockquote>\n<p><strong> 🎍 销毁栈操作：</strong></p>\n</blockquote>\n<p><strong> 记得养成释放动态内存的习惯哦！</strong></p>\n<pre><code class=\"language-cpp\">void StackDestroy(ST* ps)\n{\n\tassert(ps);\n\tfree(ps-&gt;a);\n\tps-&gt;a = NULL;\n\tps-&gt;top = ps-&gt;capacity = 0;\n}</code></pre>\n<p><strong> 栈相对来说还是比较简单了，栈的基本接口就到这里了，下面我们来实现队列的基本接口操作！</strong></p>\n<hr/>\n<h3><span style=\"color:#ad720d;\"> <strong>🏐 3、队列的介绍</strong></span></h3>\n<blockquote>\n<p><span style=\"color:#fe2c24;\"><strong>队列：</strong></span>只允许在一端进行插入数据操作，在另一端进行删除数据操作的特殊线性表，队列具有<strong><span style=\"color:#0d0016;\">先进先出</span></strong>FIFO(First In First Out) 入队列：进行插入操作的一端称为<span style=\"color:#0d0016;\"><strong>队尾</strong></span>出队列，进行删除操作的一 端称为<span style=\"color:#0d0016;\"><strong>队头</strong></span>！</p>\n<p><span style=\"color:#fe2c24;\"><strong>队列也可以数组和链表的结构实现，使用链表的结构实现更优一些，因为如果使用数组的结构， 出队列在数组头上出数据，效率会比较低。</strong></span></p>\n</blockquote>\n<p style=\"text-align:center;\"> <img alt=\"\" src=\"image\\4e3e4ef0d44f46fe91ee814e12f2520f.png\"/></p>\n<h3><span style=\"color:#ad720d;\"><strong>🏀 4、队列的常用接口实现</strong> </span></h3>\n<blockquote>\n<p><strong>🧦 队列的结构： </strong></p>\n</blockquote>\n<p> 结构搭建这里我们就不多说了，直接走代码！</p>\n<pre><code class=\"language-cpp\">typedef int QDataType;\n\ntypedef struct QueueNode\n{\n\tstruct QueueNode* next;\n\tQDataType data;\n}QNode;\n\ntypedef struct Queue\n{\n\tQNode* head;\n\tQNode* tail;\n}Queue;</code></pre>\n<blockquote>\n<p><strong>🥽 队列的初始化：</strong></p>\n</blockquote>\n<p><strong>这里我们只需要初始化队头指针和队尾指针就可以了！ </strong></p>\n<pre><code class=\"language-cpp\">void QueueInit(Queue* pq)\n{\n\tassert(pq);\n\tpq-&gt;head = pq-&gt;tail = NULL;\n}</code></pre>\n<blockquote>\n<p><strong>🎭 队尾入节点：</strong></p>\n</blockquote>\n<p> <img alt=\"\" src=\"image\\a9019d49b11b479ba380cb2285fe1a77.png\"/></p>\n<blockquote>\n<p><strong> 👔 队头出节点：</strong></p>\n</blockquote>\n<p style=\"text-align:center;\"> <img alt=\"\" src=\"image\\f0cf296fecc5496a82155b701ecf57ac.png\"/></p>\n<blockquote>\n<p><strong>👗  取队头节点数据：</strong></p>\n</blockquote>\n<pre><code class=\"language-cpp\">QDataType QueueFront(Queue* pq)\n{\n\tassert(pq);\n\tassert(pq-&gt;head);\n\t\n\treturn pq-&gt;head-&gt;data;\n}</code></pre>\n<blockquote>\n<p><strong>👜 取队尾节点数据：</strong></p>\n</blockquote>\n<pre><code class=\"language-cpp\">QDataType QueueBack(Queue* pq)\n{\n\tassert(pq);\n\tassert(pq-&gt;head);\n\n\treturn pq-&gt;tail-&gt;data;\n}</code></pre>\n<blockquote>\n<p><strong>🧨  求队列节点个数：</strong></p>\n</blockquote>\n<pre><code class=\"language-cpp\">int QueueSize(Queue* pq)\n{\t\n\tint size = 0;\n\tQNode* cur = pq-&gt;head;\n\tassert(pq);\n\twhile (cur)\n\t{\n\t\t++size;\n\t\tcur = cur-&gt;next;\n\t}\n\treturn size;\n}</code></pre>\n<blockquote>\n<p><strong>🎆 判断队列是否为空：</strong></p>\n</blockquote>\n<p><strong>跟上面栈一样使用bool型类型</strong></p>\n<pre><code class=\"language-cpp\">bool QueueEmpty(Queue* pq)\n{\n\tassert(pq);\n\treturn pq-&gt;head == NULL;\n}</code></pre>\n<blockquote>\n<p><strong>🎇 销毁队列操作：</strong></p>\n</blockquote>\n<pre><code class=\"language-cpp\">void QueueDestory(Queue* pq)\n{\n\tassert(pq);\n\tQNode* cur = pq-&gt;head;\n\twhile (cur)\n\t{\n\t\tQNode* next = cur-&gt;next;\n\t\tfree(cur);\n\t\tcur = next;\n\t}\n\tpq-&gt;head = pq-&gt;tail = NULL;\n}</code></pre>\n<p><strong>其实栈和队列这一章算简单的，如果有前面顺序表和链表的基础，这个就是轻轻松松的事，所以我只在重点的地方画了图解，没画图解的地方相信小伙伴们也是看得懂的</strong>！</p>\n<hr/>\n<p style=\"text-align:center;\">最后又到了爱打篮球的程序员的鸡汤时刻：<strong>含泪播种的人一定能含笑收获！加油，祝你我！</strong></p>\n<p style=\"text-align:center;\"> <img alt=\"\" height=\"115\" src=\"image\\919c643034054d399bf4cb76b05e3903.png\" width=\"132\"/></p>\n<p style=\"text-align:center;\">下期预告：二叉树</p>\n</div>\n</div>"}