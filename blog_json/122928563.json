{"blogid": "122928563", "writerAge": "码龄11年", "writerBlogNum": "30", "writerCollect": "144", "writerComment": "10", "writerFan": "79", "writerGrade": "2级", "writerIntegral": "313", "writerName": "云无极", "writerProfileAdress": "writer_image\\profile_122928563.jpg", "writerRankTotal": "104976", "writerRankWeekly": "82669", "writerThumb": "11", "writerVisitNum": "60016", "blog_read_count": "1642", "blog_time": "已于 2022-02-15 11:39:49 修改", "blog_title": "C#中委托、事件和回调的用法说明", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>参考链接：</p>\n<p><a href=\"http://www.tracefact.net/tech/009.html\" title=\"C#中的委托和事件 - Part.1 - 技术 - 张子阳的博客\">C#中的委托和事件 - Part.1 - 技术 - 张子阳的博客</a></p>\n<p><a href=\"https://www.cnblogs.com/yinqixin/p/5056307.html\" title=\"分分钟用上C#中的委托和事件 - 雾中人 - 博客园\">分分钟用上C#中的委托和事件 - 雾中人 - 博客园</a><br/><a href=\"https://blog.csdn.net/sajiazaici/article/details/78702144\" title=\"C#回调函数的简单讲解与应用例子（最简单讲解，大神绕道）_sajiazaici的博客-CSDN博客_c# 回调函数\">C#回调函数的简单讲解与应用例子（最简单讲解，大神绕道）_sajiazaici的博客-CSDN博客_c# 回调函数</a></p>\n<p><strong>委托是一个类，它定义了方法的类型，使得可以将方法当作另一个方法的参数来进行传递，这种将方法动态地赋给参数的做法，可以避免在程序中大量使用If-Else(Switch)语句，同时使得程序具有更好的可扩展性。</strong></p>\n<p><strong>事件是对委托的封装。如果不进行封装，让委托暴露给调用者，调用者就可以把委托变量重新引用到新的委托对象，也就删除了当前要调用的方法列表；</strong></p>\n<p>定义一个事件有两步，首先定义一个委托，它包括了这件事的“协议”和委托方法（由谁去做）；其次，用event关键字和相关委托声明这个事件。事件像是一个接口，封装了委托所定的“协议”。由于委托已经定义了协议，剩下的就是按这个协议去办事，至于怎么做它并不关心。调用者无法访问委托对象。</p>\n<p><strong>回调函数就是把一个方法的传给另外一个方法去执行。</strong>回调函数只是一个功能片段，由用户按照回调函数的调用约定来实现的一个函数。可以把任意一个符合这个委托的方法传递进去，意思就是说这部分代码是可变的。而设计上有一个抽离出可变部分代码的原则，这种用法无疑可以用到那种场合了。从上可知，事件和回调都是对委托的一种用法。事件是把委托封装起来，而回调函数则是由委托绑定不同的函数来实现不同的功能。</p>\n<hr/>\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E5%A7%94%E6%89%98%E7%9A%84%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%A7%94%E6%89%98%E7%9A%84%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B\">委托的使用案例</a></p>\n<p id=\"%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B-toc\" style=\"margin-left:40px;\"><a href=\"#%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B\">事件的使用案例</a></p>\n<p id=\"%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%A1%88%E4%BE%8B-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%A1%88%E4%BE%8B\">带参数的事件案例</a></p>\n<p id=\"%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B\">回调函数的使用案例</a></p>\n<hr id=\"hr-toc\"/>\n<h2 id=\"%E5%A7%94%E6%89%98%E7%9A%84%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B\">委托的使用案例</h2>\n<p>定义委托和方法</p>\n<pre><code>        //委托定义(要与方法中参数一致)\n        public delegate int DelegateTest(int n1, int n2);\n\n        class Math\n        {\n            //方法定义(委托要执行的方法，本案例把方案写到class类中)\n            public int Multiply(int n1, int n2)\n            {\n                return n1 * n2;\n            }\n\n            public int AddTest(int n1, int n2)\n            {\n                return n1 + n2;\n            }\n        }</code></pre>\n<p>委托的使用</p>\n<pre><code>        private void button1_Click(object sender, EventArgs e)\n        {\n            Math objMath = new Math();\n\n            //创建委托对象\n            DelegateTest delegateDemo1;\n\n            //将方法与委托对象关联起来 （委托：将方法当作另一个方法的参数来进行传递）\n            //delegateDemo1 = new CallDelegate(objMath.Multiply);\n            delegateDemo1 = objMath.Multiply; //与上面方法相同\n            //delegateDemo1 += objMath.AddTest;  //给委托对象再绑定一个方法，若该条代码执行，显示结果为17\n\n            //将委托实例化\n            int result = delegateDemo1(5, 12);\n            richTextBox1.AppendText(result.ToString() + \"\\r\");\n\n            //****委托的另外一写法，通过Action或Func，如果有返回值用Func，否则用Action *****//\n            //Func&lt;int, int, int&gt; func1 = new Func&lt;int, int, int&gt;(objMath.Multiply);\n            Func&lt;int, int, int&gt; func1 = objMath.Multiply;\n            richTextBox1.AppendText(func1.Invoke(6, 13) + \"\\r\");\n        }</code></pre>\n<p></p>\n<p>执行的结果</p>\n<p><img alt=\"\" height=\"319\" src=\"image\\0ea6e15104ca4efc81592f72f2563385.png\" width=\"492\"/></p>\n<p><strong>利用Action或Func简化代码</strong></p>\n<pre><code>        private void button4_Click(object sender, EventArgs e)\n        {\n            Math objMath = new Math();\n            //委托的另外一写法，通过Action或Func，如果有返回值用Func，否则用Action\n            //Func&lt;int, int, int&gt; func1 = new Func&lt;int, int, int&gt;(objMath.Multiply); //同下\n            Func&lt;int, int, int&gt; func1 = objMath.Multiply;\n            richTextBox1.AppendText(func1.Invoke(6, 13) + \"\\r\");\n        }</code></pre>\n<hr/>\n<h2 id=\"%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B\">事件的使用案例</h2>\n<pre><code>        class ClassA\n        {\n            public string ClassAinfo = \"A 默认!\";\n            public void DispInfo()\n            {\n                ClassAinfo = \"A 收到！\";\n            }\n        }\n\n        class ClassB\n        {\n            public string ClassAinfo = \"B 默认!\";\n            public void DispInfo()\n            {\n                ClassAinfo = \"B 收到！\";\n            }\n        }\n        class DelegatEventTest\n        {\n            //定义委托\n            public delegate void MyDelegateEventHandler();\n            //定义事件\n            public event MyDelegateEventHandler NotifyEveryOne;\n            //调用事件\n            public void Notify()\n            {\n                if (NotifyEveryOne != null)\n                {\n                    NotifyEveryOne();\n                }\n            }\n        }</code></pre>\n<p>事件的使用</p>\n<pre><code>        private void button3_Click(object sender, EventArgs e)\n        {\n            //创建classA和classB的对象\n            ClassA objA = new ClassA();\n            ClassB objB = new ClassB();\n            //创建委托的对象\n            DelegatEventTest event1 = new DelegatEventTest();\n\n            //订阅事件（类似于 方法与委托事件的关联）\n            event1.NotifyEveryOne += new DelegatEventTest.MyDelegateEventHandler(objA.DispInfo);\n            //event1.NotifyEveryOne += new DelegatEventTest.MyDelegateEventHandler(objB.DispInfo);\n\n            event1.Notify();\n\n            richTextBox1.AppendText(objA.ClassAinfo + \"\\r\");\n            richTextBox1.AppendText(objB.ClassAinfo + \"\\r\");\n        }</code></pre>\n<p><img alt=\"\" height=\"346\" src=\"image\\17e9c64b2b7f4270963e20b984f3a9e0.png\" width=\"533\"/></p>\n<hr/>\n<h2 id=\"%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%A1%88%E4%BE%8B\">带参数的事件案例</h2>\n<p>参考网上的案例，场景：首领boyK要搞一场鸿门宴，吩咐部下boyA和boyB各自带队埋伏在屏风两侧，约定以杯为令：若左手举杯，则boyA带队杀出；若右手举杯，则boyB带队杀出；若直接摔杯，则boyA和boyB同时杀出。boyA和boyB袭击的具体方法，首领boyK并不关心。</p>\n<p>boyK的定义</p>\n<pre><code>        public class BoyK\n        {\n            //定义委托\n            public delegate void RaiseEventHandler(string hand);\n            public delegate void FallEventHandler();\n\n            //定义事件\n            public event RaiseEventHandler RaiseEvent;\n            public event FallEventHandler FallEvent;\n\n            //调用事件（例：举手事件）\n            public void Raise(string hand)\n            {\n                if (RaiseEvent!=null)\n                {\n                    RaiseEvent(hand);\n                }\n            }\n            //调用事件（例：摔杯事件）\n            public void Fall()\n            {\n                if (FallEvent!=null)\n                {\n                    FallEvent();\n                }\n            }            \n        }</code></pre>\n<p>boyA的定义</p>\n<pre><code>        class BoyA\n        {\n            public string str = \"A待命\";\n            BoyK boyk;\n            public BoyA(BoyK k)\n            {\n                boyk = k;\n                k.RaiseEvent += new BoyK.RaiseEventHandler(k_RaiseEvent);   //订阅举杯事件\n                k.FallEvent += new BoyK.FallEventHandler(k_FallEvent);      //订阅摔杯事件\n            }\n            public void Attack()\n            {\n                str = \"A开始**\";\n            }\n\n            //boyK举杯的动作\n            void k_RaiseEvent(string hand)\n            {\n                if (hand.Equals(\"左\"))\n                {\n                    Attack();\n                }\n            }\n\n            void k_FallEvent()\n            {\n                Attack();\n            }         \n        }</code></pre>\n<p>boyB的定义</p>\n<pre><code>        class BoyB\n        {\n            public string str = \"B待命\";\n            BoyK boyk;\n            public BoyB(BoyK k)\n            {\n                boyk = k;\n                k.RaiseEvent += new BoyK.RaiseEventHandler(k_RaiseEvent);   //订阅举杯事件\n                k.FallEvent += new BoyK.FallEventHandler(k_FallEvent);      //订阅摔杯事件\n            }\n\n            public void Attack()\n            {\n                str = \"B开始**\";\n            }\n\n            void k_RaiseEvent(string hand)\n            {\n                if (hand.Equals(\"右\"))\n                {\n                    Attack();\n                }\n            }\n\n            void k_FallEvent()\n            {\n                Attack();\n            }\n        }</code></pre>\n<p>事件的使用</p>\n<pre><code>        private void button2_Click(object sender, EventArgs e)\n        {\n            BoyK boyK = new BoyK();\n            BoyA boyA = new BoyA(boyK);\n            BoyB boyB = new BoyB(boyK);\n\n            //boyK.Raise(\"左\");\n            boyK.Raise(\"右\");\n            //boyK.Fall();\n\n            richTextBox1.AppendText(boyA.str+\"\\r\");\n            richTextBox1.AppendText(boyB.str + \"\\r\");\n        }</code></pre>\n<p>运行效果</p>\n<p><img alt=\"\" height=\"397\" src=\"image\\fdb013a8bd1e4f39807c2dd35863f233.png\" width=\"612\"/></p>\n<hr/>\n<h2 id=\"%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B\">回调函数的使用案例</h2>\n<p>实际开发中，下面这个类会封装起来，只提供函数接口。相当于系统底层</p>\n<pre><code>        //实际开发中，下面这个类会封装起来，只提供函数接口。相当于系统底层\n        class CalculateClass\n        {\n            public delegate int SomeCalculateWay(int num1, int num2);\n            //将传入参数在系统底层进行某种处理，具体计算方法由开发者开发，函数仅提供执行计算方法后的返回值\n            //下面的代码中相当于调用了一个回调函数\n            public int Calculate(int num1, int num2, SomeCalculateWay call)\n            {\n                return call(num1, num2);\n            }\n        }</code></pre>\n<p>开发层处理，开发人员编写具体的计算方法</p>\n<pre><code>        //开发层处理，开发人员编写具体的计算方法\n        class FunctionClass\n        {\n            public int GetSum(int a, int b)\n            {\n                return a + b;\n            }\n\n            public int GetMulti(int a, int b)\n            {\n                return a * b;\n            }\n        }</code></pre>\n<p>用户层，执行输入等操作</p>\n<pre><code>        private void button4_Click(object sender, EventArgs e)\n        {\n            CalculateClass cc = new CalculateClass();\n            FunctionClass fc = new FunctionClass();\n\n            int result1 = cc.Calculate(2, 3, fc.GetSum);\n            int result2 = cc.Calculate(2, 3, fc.GetMulti);\n\n            richTextBox1.AppendText(result1 + \"\\r\");\n            richTextBox1.AppendText(result2 + \"\\r\");\n        }</code></pre>\n<p><img alt=\"\" height=\"350\" src=\"image\\5d5d023027d843288d962793860fbbd8.png\" width=\"540\"/></p>\n<p> 说明：上述代码中的FunctionClass中的GetSum()和GetMulti()两个函数称为回调函数。可以看到整个程序中并没有哪个地方通过类似GetSum(1,2)这种形式调用了该函数，只有将其当作另一个函数的参数来进行调用。如cc.PrintAndCalculate(2, 3, fc.GetSum)。</p>\n</div>\n</div>"}