{"blogid": "120695429", "writerAge": "码龄2年", "writerBlogNum": "107", "writerCollect": "230", "writerComment": "16", "writerFan": "177", "writerGrade": "4级", "writerIntegral": "1403", "writerName": "Snakin_ya", "writerProfileAdress": "writer_image\\profile_120695429.jpg", "writerRankTotal": "20854", "writerRankWeekly": "41457", "writerThumb": "306", "writerVisitNum": "131375", "blog_read_count": "8275", "blog_time": "于 2021-10-11 01:08:07 发布", "blog_title": "PHP伪协议详解", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h1><a id=\"PHP_0\"></a>PHP伪协议详解</h1>\n<p>php支持的伪协议</p>\n<pre><code class=\"prism language-php\"><span class=\"token number\">1</span> <span class=\"token argument-name\">file</span><span class=\"token punctuation\">:</span><span class=\"token comment\">// — 访问本地文件系统</span>\n<span class=\"token number\">2</span> <span class=\"token argument-name\">http</span><span class=\"token punctuation\">:</span><span class=\"token comment\">// — 访问 HTTP(s) 网址</span>\n<span class=\"token number\">3</span> <span class=\"token argument-name\">ftp</span><span class=\"token punctuation\">:</span><span class=\"token comment\">// — 访问 FTP(s) URLs</span>\n<span class=\"token number\">4</span> <span class=\"token argument-name\">php</span><span class=\"token punctuation\">:</span><span class=\"token comment\">// — 访问各个输入/输出流（I/O streams）</span>\n<span class=\"token number\">5</span> <span class=\"token argument-name\">zlib</span><span class=\"token punctuation\">:</span><span class=\"token comment\">// — 压缩流</span>\n<span class=\"token number\">6</span> <span class=\"token argument-name\">data</span><span class=\"token punctuation\">:</span><span class=\"token comment\">// — 数据（RFC 2397）</span>\n<span class=\"token number\">7</span> <span class=\"token argument-name\">glob</span><span class=\"token punctuation\">:</span><span class=\"token comment\">// — 查找匹配的文件路径模式</span>\n<span class=\"token number\">8</span> <span class=\"token argument-name\">phar</span><span class=\"token punctuation\">:</span><span class=\"token comment\">// — PHP 归档</span>\n<span class=\"token number\">9</span> <span class=\"token argument-name\">ssh2</span><span class=\"token punctuation\">:</span><span class=\"token comment\">// — Secure Shell 2</span>\n<span class=\"token number\">10</span> <span class=\"token argument-name\">rar</span><span class=\"token punctuation\">:</span><span class=\"token comment\">// — RAR</span>\n<span class=\"token number\">11</span> <span class=\"token argument-name\">ogg</span><span class=\"token punctuation\">:</span><span class=\"token comment\">// — 音频流</span>\n<span class=\"token number\">12</span> <span class=\"token argument-name\">expect</span><span class=\"token punctuation\">:</span><span class=\"token comment\">// — 处理交互式的流</span>\n</code></pre>\n<h2><a id=\"1_phpfilter_21\"></a>1 php://filter</h2>\n<p>php://filter 是一种元封装器， 设计用于数据流打开时的筛选过滤应用。 这对于一体式（all-in-one）的文件函数非常有用，类似 readfile()、 file() 和 file_get_contents()， 在数据流内容读取之前没有机会应用其他过滤器。</p>\n<p>简单通俗的说，这是一个中间件，在读入或写入数据的时候对数据进行处理后输出的一个过程。</p>\n<p><strong>php://filter</strong>可以获取指定文件源码。当它与包含函数结合时，php://filter流会被当作php文件执行。所以我们一般对其进行编码，让其不执行。从而导致 任意文件读取。</p>\n<p>协议参数</p>\n<table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td><code>resource=&lt;要过滤的数据流&gt;</code></td><td>这个参数是必须的。它指定了你要筛选过滤的数据流。</td></tr><tr><td><code>read=&lt;读链的筛选列表&gt;</code></td><td>该参数可选。可以设定一个或多个过滤器名称，以管道符（<code>|</code>）分隔。</td></tr><tr><td><code>write=&lt;写链的筛选列表&gt;</code></td><td>该参数可选。可以设定一个或多个过滤器名称，以管道符（<code>|</code>）分隔。</td></tr><tr><td><code>&lt;；两个链的筛选列表&gt;</code></td><td>任何没有以 <code>read=</code> 或 <code>write=</code> 作前缀 的筛选器列表会视情况应用于读或写链。</td></tr></tbody></table>\n<p>常用：</p>\n<pre><code class=\"prism language-php\"><span class=\"token argument-name\">php</span><span class=\"token punctuation\">:</span><span class=\"token comment\">//filter/read=convert.base64-encode/resource=index.php</span>\n<span class=\"token argument-name\">php</span><span class=\"token punctuation\">:</span><span class=\"token comment\">//filter/resource=index.php</span>\n</code></pre>\n<p>利用filter协议读文件±，将index.php通过base64编码后进行输出。这样做的好处就是如果不进行编码，文件包含后就不会有输出结果，而是当做php文件执行了，而通过编码后则可以读取文件源码。</p>\n<p>而使用的convert.base64-encode，就是一种过滤器。</p>\n<h3><a id=\"_49\"></a>过滤器</h3>\n<h4><a id=\"_51\"></a>字符串过滤器</h4>\n<p>该类通常以<code>string</code>开头，对每个字符都进行同样方式的处理。</p>\n<p><strong>string.rot13</strong></p>\n<p>一种字符处理方式，字符右移十三位。</p>\n<p><strong>string.toupper</strong></p>\n<p>将所有字符转换为大写。</p>\n<p><strong>string.tolower</strong></p>\n<p>将所有字符转换为小写。</p>\n<h4><a id=\"stringstrip_tags_67\"></a>string.strip_tags</h4>\n<p>这个过滤器就比较有意思，用来处理掉读入的所有标签，例如XML的等等。在绕过死亡exit大有用处。</p>\n<h4><a id=\"_71\"></a>转换过滤器</h4>\n<p>对数据流进行编码，通常用来读取文件源码。</p>\n<p><strong>convert.base64-encode &amp; convert.base64-decode</strong></p>\n<p>base64加密解密</p>\n<p><strong>convert.quoted-printable-encode &amp; convert.quoted-printable-decode</strong></p>\n<p>可以翻译为可打印字符引用编码，使用可以打印的ASCII编码的字符表示各种编码形式下的字符。</p>\n<h4><a id=\"_83\"></a>压缩过滤器</h4>\n<p>注意，这里的压缩过滤器指的并不是在数据流传入的时候对整个数据进行写入文件后压缩文件，也不代表可以压缩或者解压数据流。压缩过滤器<strong>不</strong>产生命令行工具如 <code>gzip</code>的头和尾信息。只是压缩和解压数据流中的有效载荷部分。</p>\n<p>用到的两个相关过滤器：<code>zlib.deflate</code>（压缩）和 <code>zlib.inflate</code>（解压）。zilb是比较主流的用法，至于<code>bzip2.compress</code>和 <code>bzip2.decompress</code>工作的方式与 zlib 过滤器大致相同。</p>\n<h4><a id=\"_89\"></a>加密过滤器</h4>\n<p><code>mcrypt.*</code>和 <code>mdecrypt.*</code>使用 libmcrypt 提供了对称的加密和解密。</p>\n<p>更多妙用：https://www.leavesongs.com/PENETRATION/php-filter-magic.html</p>\n<h3><a id=\"filterexit_95\"></a>利用filter伪协议绕过死亡exit</h3>\n<h4><a id=\"exit_97\"></a>什么是死亡exit</h4>\n<p>死亡exit指的是在进行写入PHP文件操作时，执行了以下函数：</p>\n<pre><code class=\"prism language-php\"><span class=\"token function\">file_put_contents</span><span class=\"token punctuation\">(</span><span class=\"token variable\">$content</span><span class=\"token punctuation\">,</span> <span class=\"token string single-quoted-string\">'&lt;?php exit();'</span> <span class=\"token operator\">.</span> <span class=\"token variable\">$content</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>亦或者</p>\n<pre><code class=\"prism language-php\"><span class=\"token function\">file_put_contents</span><span class=\"token punctuation\">(</span><span class=\"token variable\">$content</span><span class=\"token punctuation\">,</span> <span class=\"token string single-quoted-string\">'&lt;?php exit();?&gt;'</span> <span class=\"token operator\">.</span> <span class=\"token variable\">$content</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>这样，当你插入一句话木马时，文件的内容是这样子的：</p>\n<pre><code class=\"prism language-php\"><span class=\"token delimiter important\">&lt;?php</span> <span class=\"token keyword\">exit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token operator\">?</span><span class=\"token operator\">&gt;</span>\n\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span>php @<span class=\"token keyword\">eval</span><span class=\"token punctuation\">(</span><span class=\"token variable\">$_POST</span><span class=\"token punctuation\">[</span><span class=\"token string single-quoted-string\">'snakin'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token operator\">?</span><span class=\"token operator\">&gt;</span>\n</code></pre>\n<p>这样即使插入了一句话木马，在被使用的时候也无法被执行。这样的死亡exit通常存在于缓存、配置文件等等不允许用户直接访问的文件当中。</p>\n<h4><a id=\"base64decode_121\"></a>base64decode绕过</h4>\n<p>利用filter协议来绕过，看下这样的代码：</p>\n<pre><code class=\"prism language-php\"><span class=\"token delimiter important\">&lt;?php</span>\n\n<span class=\"token variable\">$content</span> <span class=\"token operator\">=</span> <span class=\"token string single-quoted-string\">'&lt;?php exit; ?&gt;'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token variable\">$content</span> <span class=\"token operator\">.=</span> <span class=\"token variable\">$_POST</span><span class=\"token punctuation\">[</span><span class=\"token string single-quoted-string\">'txt'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">file_put_contents</span><span class=\"token punctuation\">(</span><span class=\"token variable\">$_POST</span><span class=\"token punctuation\">[</span><span class=\"token string single-quoted-string\">'filename'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token variable\">$content</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>当用户通过POST方式提交一个数据时，会与死亡exit进行拼接，从而避免提交的数据被执行。</p>\n<p>然而这里可以利用php://filter的base64-decode方法，将<code>$content</code>解码，利用php base64_decode函数特性去除死亡exit。</p>\n<p>base64编码中只包含64个可打印字符，当PHP遇到不可解码的字符时，会选择性的跳过，这个时候base64就相当于以下的过程：</p>\n<pre><code class=\"prism language-php\"><span class=\"token delimiter important\">&lt;?php</span>\n\n<span class=\"token variable\">$_GET</span><span class=\"token punctuation\">[</span><span class=\"token string single-quoted-string\">'txt'</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">preg_replace</span><span class=\"token punctuation\">(</span><span class=\"token string single-quoted-string\">'|[^a-z0-9A-Z+/]|s'</span><span class=\"token punctuation\">,</span> <span class=\"token string single-quoted-string\">''</span><span class=\"token punctuation\">,</span> <span class=\"token variable\">$_GET</span><span class=\"token punctuation\">[</span><span class=\"token string single-quoted-string\">'txt'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">base64_decode</span><span class=\"token punctuation\">(</span><span class=\"token variable\">$_GET</span><span class=\"token punctuation\">[</span><span class=\"token string single-quoted-string\">'txt'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>所以，当<code>$content</code> 包含 <code>&lt;?php exit; ?&gt;</code>时，解码过程会先去除识别不了的字符，&lt; ; ? &gt;和空格等都将被去除，于是剩下的字符就只有<code>phpexit</code>以及我们传入的字符了。由于base64是4个byte一组，再添加一个字符例如添加字符’a’后，将’phpexita’当做两组base64进行解码，也就绕过这个死亡exit了。</p>\n<p>这个时候后面再加上编码后的一句话木马，就可以getshell了。</p>\n<h4><a id=\"strip_tags_153\"></a>strip_tags绕过</h4>\n<p>这个<code>&lt;?php exit; ?&gt;</code>实际上是一个XML标签，既然是XML标签，我们就可以利用strip_tags函数去除它，而php://filter刚好是支持这个方法的。</p>\n<p>但是我们要写入的一句话木马也是XML标签，在用到strip_tags时也会被去除。</p>\n<p>注意到在写入文件的时候，filter是支持多个过滤器的。可以先将webshell经过base64编码，strip_tags去除死亡exit之后，再通过base64-decode复原。</p>\n<pre><code class=\"prism language-php\"><span class=\"token argument-name\">php</span><span class=\"token punctuation\">:</span><span class=\"token comment\">//filter/string.strip_tags|convert.base64-decode/resource=shell.php</span>\n</code></pre>\n<p>更多绕过方法：<a href=\"https://xz.aliyun.com/t/8163#toc-2\">file_put_content和死亡·杂糅代码之缘</a></p>\n<h2><a id=\"2_data_167\"></a>2 data://</h2>\n<p>数据流封装器，以传递相应格式的数据。可以让用户来控制输入流，当它与包含函数结合时，用户输入的data://流会被当作php文件执行。</p>\n<p>示例用法：</p>\n<pre><code class=\"prism language-php\"><span class=\"token number\">1</span>、<span class=\"token argument-name\">data</span><span class=\"token punctuation\">:</span><span class=\"token comment\">//text/plain,</span>\n<span class=\"token argument-name\">http</span><span class=\"token punctuation\">:</span><span class=\"token comment\">//127.0.0.1/include.php?file=data://text/plain,&lt;?php%20phpinfo();?&gt;</span>\n \n<span class=\"token number\">2</span>、<span class=\"token argument-name\">data</span><span class=\"token punctuation\">:</span><span class=\"token comment\">//text/plain;base64,</span>\n<span class=\"token argument-name\">http</span><span class=\"token punctuation\">:</span><span class=\"token comment\">//127.0.0.1/include.php?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b</span>\n</code></pre>\n<h3><a id=\"_181\"></a>范例</h3>\n<p>Example #1 打印 data:// 的内容</p>\n<pre><code class=\"prism language-php\"><span class=\"token delimiter important\">&lt;?php</span>\n<span class=\"token comment\">// 打印 \"I love PHP\"</span>\n<span class=\"token keyword\">echo</span>  <span class=\"token function\">file_get_contents </span><span class=\"token punctuation\">(</span> <span class=\"token string single-quoted-string\">'data://text/plain;base64,SSBsb3ZlIFBIUAo='</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token operator\">?</span><span class=\"token operator\">&gt;</span>\n</code></pre>\n<p>Example #2 获取媒体类型</p>\n<pre><code class=\"prism language-php\"><span class=\"token delimiter important\">&lt;?php</span>\n<span class=\"token variable\">$fp</span>    <span class=\"token operator\">=</span>  <span class=\"token function\">fopen </span><span class=\"token punctuation\">(</span> <span class=\"token string single-quoted-string\">'data://text/plain;base64,'</span> <span class=\"token punctuation\">,</span>  <span class=\"token string single-quoted-string\">'r'</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token variable\">$meta</span>  <span class=\"token operator\">=</span>  <span class=\"token function\">stream_get_meta_data </span><span class=\"token punctuation\">(</span> <span class=\"token variable\">$fp</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 打印 \"text/plain\"</span>\n<span class=\"token keyword\">echo</span>  <span class=\"token variable\">$meta</span> <span class=\"token punctuation\">[</span> <span class=\"token string single-quoted-string\">'mediatype'</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token operator\">?</span><span class=\"token operator\">&gt;</span>\n</code></pre>\n<h2><a id=\"3_file_204\"></a>3 file://</h2>\n<p>用于访问本地文件系统，并且不受allow_url_fopen，allow_url_include影响<br/> file://协议主要用于访问文件(绝对路径、相对路径以及网络路径)<br/> 比如：http://www.xx.com?file=file:///etc/passsword</p>\n<h2><a id=\"4_php_210\"></a>4 php://</h2>\n<p>在allow_url_fopen，allow_url_include都关闭的情况下可以正常使用<br/> php://作用为访问输入输出流</p>\n<h2><a id=\"5_phpinput_215\"></a>5 php://input</h2>\n<p><strong>php://input</strong>可以访问请求的原始数据的只读流，将post请求的数据当作php代码执行。当传入的参数作为文件名打开时，可以将参数设为php://input,同时post想设置的文件内容，php执行时会将post内容当作文件内容。从而导致任意代码执行。</p>\n<p>例如：<br/> http://127.0.0.1/cmd.php?cmd=php://input<br/> POST数据：&lt;?php phpinfo()?&gt;<br/> 注意：<br/> 当enctype=\"multipart/form-data\"的时候 php://input` 是无效的</p>\n<p>遇到file_get_contents()要想到用php://input绕过。</p>\n<h2><a id=\"6__zip_227\"></a>6 zip://</h2>\n<p>zip:// 可以访问压缩包里面的文件。当它与包含函数结合时，zip://流会被当作php文件执行。从而实现任意代码执行。</p>\n<pre><code>zip://中只能传入绝对路径。\n要用#分隔压缩包和压缩包里的内容，并且#要用url编码%23（即下述POC中#要用%23替换）\n只需要是zip的压缩包即可，后缀名可以任意更改。\n相同的类型的还有zlib://和bzip2://\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\2019021218350876.png\"/></p>\n<p>参考链接：</p>\n<p><a href=\"https://www.freebuf.com/column/148886.html\">php伪协议实现命令执行的七种姿势</a></p>\n<p><a href=\"https://segmentfault.com/a/1190000018991087\">PHP伪协议总结</a></p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}