{"blogid": "123709215", "writerAge": "None", "writerBlogNum": "44", "writerCollect": "80", "writerComment": "6", "writerFan": "17", "writerGrade": "3级", "writerIntegral": "483", "writerName": "学到牛牛", "writerProfileAdress": "writer_image\\profile_123709215.jpg", "writerRankTotal": "62173", "writerRankWeekly": "24039", "writerThumb": "36", "writerVisitNum": "63797", "blog_read_count": "2516", "blog_time": "于 2022-03-24 14:15:32 发布", "blog_title": "归并排序（Merge Sort）图解，归并排序算法", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>归并排序是建立在归并操作上的一种有效、稳定的排序算法，该算法采用非常经典的分治法（分治法可以通俗的解释为:把一片领土分解，分解为若干块小部分，然后一块块地占领征服，被分解的可以是不同的政治派别或是其他什么，然后让他们彼此异化），归并排序的思路很简单，速度呢，也仅此于快速排序，接下来我们详细的看看归并排序的过程。<br/><strong>基本思路：</strong><br/> 第一步：将序列中待排序数字分为若干组，每个数字分为一组。<br/> 第二步：将若干组两两合并，保证合并的组都是有序的。<br/> 第三步：重复第二步的操作，直到剩下最后一组即为有序数列。<br/><strong>详细步骤：</strong><br/> 首先将数组中待排序数字分成若干组,每个数字为一组</p>\n<p><img alt=\"\" src=\"image\\20dd1228ca0240c0819d8b1857f03d7c.png\"/></p>\n<p>相邻的两组进行对比，并且两两合并，保证合并后都是有序的数列，i（数字8）&gt;  j（数字4）需要交换位置（最终呈现一个升序的数组），经过比较合并后两个数存入一个空的指针里</p>\n<p><img alt=\"\" src=\"image\\a688cf85cc144546941593828296e80d.png\"/></p>\n<p><img alt=\"\" src=\"image\\1e90dcb98fc5482f81b773b87eb08ac7.png\"/><br/> 其他组按照此方法依次合并，从8个组合并成4个组</p>\n<p><img alt=\"\" src=\"image\\3addc43237364b03b03eaecb40f1a34b.png\"/></p>\n<p> 继续相邻的两个组进行合并</p>\n<p><img alt=\"\" src=\"image\\7dc546deaee84244a177cf7118e63a09.png\"/></p>\n<p>  定义两个变量i,j分别代表P1里的第一个值（4）和P2里的第一个值（5），i和j进行比较，i &lt; j（4 &lt; 5）,将数字4移入p中，i向后移动一位</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\7d7132cb70094d5b937175a0fd880dfa.png\"/></p>\n<p> i和j进行比较，i &gt; j（8 &gt; 5 ）,将数字5移动到p中（4的后一位），j后移一位</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\d990071957824ae99536539be28bd7ef.png\"/></p>\n<p>i 和j继续进行比较，i &gt; j （8 &gt; 7）,将数字7移动到p中（5的后一位），p2中没有待排序的数字，所以比较结束，p1中剩下的数字移动到p中（7的后一位），合并结束。旁边两个序列按照同样的方式进行合并，最后得到两个有序序列，将这两个有序序列通过上面的方式继续进行合并</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\ecb1dc0cdbe74273828eeece2384c68a.png\"/></p>\n<p> i和j进行比较，i &gt; j（4 &gt; 1）,i不动，p2中的数字1移动到p中，j向后移动一位</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\4aa869919ebc421aa3bbddee3e1f5a9e.png\"/></p>\n<p> i继续和j比较，i &gt; j（4 &gt; 2）,数字2移动到p中（1的后一位），j向后移动一位</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\b49e1c1ec97c4a83b80629518a8bccb5.png\"/></p>\n<p>i继续和j比较，i &gt; j（4 &gt; 3）,数字3移动到p中（2的后一位），j向后移动一位</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\d9e9bfe33dea42d096e3cb79f01a548b.png\"/></p>\n<p> i继续和j比较，i &lt; j（4 &lt;6）,数字4移动到p中（3的后一位），i向后移动一位</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\ebc2e87f4c74479cb0207604a188bb22.png\"/></p>\n<p> i继续和j比较，i &lt; j（5 &lt; 6）,数字5移动到p中（4的后一位），i向后移动一位</p>\n<p><img alt=\"\" src=\"image\\f217c70e26874589ac4fa3387b34117f.png\"/><br/> i继续和j比较，i &gt; j（7 &gt;6）,数字6移动到p中（5的后一位），p2中已经没有待排序的数字，所以比较结束，p1中剩下的数字移动到p中（6的后面）</p>\n<p><img alt=\"\" src=\"image\\78a434e0aa464aa09cb7b21f3190bcb5.png\"/><br/> 最后得到一个有序的数列 ，归并排序结束源代码 如下：</p>\n<pre><code class=\"language-cpp\">#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nvoid G_qsort(int *a,int first,int mid,int last,int *temp)\n{\n    int n = mid,m = last;\n    int k = 0;\n    int i = first,j = mid+1;\n    while(i &lt;= n &amp;&amp; j &lt;= m)  // 两边同时进行\n    {\n        if(a[i] &lt;= a[j])  //  i和j进行比较\n        {\n            temp[k++] = a[i++];  // 如果i &lt;= j,则i的值移动到temp里面\n        }\n        else\n        {\n            temp[k++] = a[j++];   // 如果i &gt; j,则j的值移动到temp里面\n        }\n    }\n    while(i &lt;= n) // 学到牛牛 www.xuedaon.com\n    {\n        temp[k++] = a[i++];\n    }\n    while(j &lt;= m)\n    {\n        temp[k++] = a[j++];    \n    }\n    for(i = 0; i &lt; k; i++)\n    {\n        a[first+i] = temp[i];\n    }\n}\n\nvoid G_sort(int *a,int first,int last,int *temp)\n{\n    if(first &lt; last)  //  当同时到达一个数时结束判断\n    {\n        int mid = (first+last)/2;  // 找到中间值\n        G_sort(a,first,mid,temp);  //  递归函数左边\n        G_sort(a,mid+1,last,temp);   // 右边\n        G_qsort(a,first,mid,last,temp);  // 进行排序\n    }\n}\n\nint sort(int *a,int n)\n{\n    int *p = malloc(n);  // 分配内存大小\n    if(p == NULL) \n    {\n        return -1;\n    }\n    else\n    {\n        free(p);  \n        G_sort(a,0,n-1,p);  // 调用函数传参，0和n-1为第一个数和最后一个数下标\n        p = NULL;\n        return 1;\n    }\n    \n}\nint main()\n{\n    int a[8]={8,4,5,7,1,3,6,2};\n    int i;\n    sort(a,8); // 调用函数传参\n    for(i = 0; i &lt; 8; i++)\n    {\n        printf(\"%d\",a[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}</code></pre>\n</div>\n</div>"}