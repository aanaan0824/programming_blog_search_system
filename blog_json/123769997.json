{"blogid": "123769997", "writerAge": "码龄2年", "writerBlogNum": "48", "writerCollect": "2512", "writerComment": "4018", "writerFan": "8742", "writerGrade": "6级", "writerIntegral": "7335", "writerName": "小杰312", "writerProfileAdress": "writer_image\\profile_123769997.jpg", "writerRankTotal": "3536", "writerRankWeekly": "8086", "writerThumb": "2664", "writerVisitNum": "112387", "blog_read_count": "1760", "blog_time": "已于 2022-04-25 16:57:09 修改", "blog_title": "STL设计之容器适配器,加之经典题目解析", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E5%89%8D%E8%A8%80-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%89%8D%E8%A8%80\">前言</a></p>\n<p id=\"stack%20%2B%20queue%20%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8%E7%90%86%E8%A7%A3%E5%AE%9E%E7%8E%B0-toc\" style=\"margin-left:0px;\"><a href=\"#stack%20%2B%20queue%20%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8%E7%90%86%E8%A7%A3%E5%AE%9E%E7%8E%B0\">stack + queue 容器适配器理解实现</a></p>\n<p id=\"%E7%90%86%E8%A7%A3%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8-toc\" style=\"margin-left:80px;\"><a href=\"#%E7%90%86%E8%A7%A3%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8\">理解容器适配器</a></p>\n<p id=\"%E6%80%9D%E8%80%83stack%20%E5%92%8C%20queue%20%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%3F-toc\" style=\"margin-left:80px;\"><a href=\"#%E6%80%9D%E8%80%83stack%20%E5%92%8C%20queue%20%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%3F\">思考stack 和 queue 是否存在迭代器?</a></p>\n<p id=\"stack%20%E5%92%8C%20queue%E5%8F%AF%E4%BB%A5%E4%BB%A5%E5%93%AA%E4%BA%9B%E5%AE%B9%E5%99%A8%E4%BD%9C%E4%B8%BA%E5%BA%95%E5%B1%82%E5%AE%B9%E5%99%A8%3F%C2%A0-toc\" style=\"margin-left:80px;\"><a href=\"#stack%20%E5%92%8C%20queue%E5%8F%AF%E4%BB%A5%E4%BB%A5%E5%93%AA%E4%BA%9B%E5%AE%B9%E5%99%A8%E4%BD%9C%E4%B8%BA%E5%BA%95%E5%B1%82%E5%AE%B9%E5%99%A8%3F%C2%A0\">stack 和 queue可以以哪些容器作为底层容器? </a></p>\n<p id=\"%E5%BA%95%E5%B1%82%E5%AE%B9%E5%99%A8%E5%A6%82%E4%BD%95%E4%BC%A0%E8%BF%9B%E5%8E%BB%EF%BC%9F%C2%A0%20%C2%A0%20%C2%A0-toc\" style=\"margin-left:80px;\"><a href=\"#%E5%BA%95%E5%B1%82%E5%AE%B9%E5%99%A8%E5%A6%82%E4%BD%95%E4%BC%A0%E8%BF%9B%E5%8E%BB%EF%BC%9F%C2%A0%20%C2%A0%20%C2%A0\">底层容器如何传进去？     </a></p>\n<p id=\"%C2%A0%E9%87%8D%E7%82%B9%E5%87%BD%E6%95%B0%E5%88%86%E5%9D%97%E5%88%86%E6%9E%90-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A0%E9%87%8D%E7%82%B9%E5%87%BD%E6%95%B0%E5%88%86%E5%9D%97%E5%88%86%E6%9E%90\"> 重点函数分块分析</a></p>\n<p id=\"stack%E5%88%86%E6%9E%90%C2%A0-toc\" style=\"margin-left:80px;\"><a href=\"#stack%E5%88%86%E6%9E%90%C2%A0\">stack分析 </a></p>\n<p id=\"%C2%A0queue%E5%88%86%E6%9E%90-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A0queue%E5%88%86%E6%9E%90\"> queue分析</a></p>\n<p id=\"stack%20%E7%BB%8F%E5%85%B8%E4%BE%8B%E9%A2%98-toc\" style=\"margin-left:0px;\"><a href=\"#stack%20%E7%BB%8F%E5%85%B8%E4%BE%8B%E9%A2%98\">stack 经典例题</a></p>\n<p id=\"priority_queue%20%E5%88%86%E8%A7%A3%E5%AE%9E%E7%8E%B0-toc\" style=\"margin-left:0px;\"><a href=\"#priority_queue%20%E5%88%86%E8%A7%A3%E5%AE%9E%E7%8E%B0\">priority_queue 分解实现</a></p>\n<p id=\"%E4%BB%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9C%B0%E8%BE%83%E5%85%A5%E8%AE%A4%E8%AF%86priority_queue-toc\" style=\"margin-left:80px;\"><a href=\"#%E4%BB%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9C%B0%E8%BE%83%E5%85%A5%E8%AE%A4%E8%AF%86priority_queue\">从数据结构地较入认识priority_queue</a></p>\n<p id=\"%E4%BB%8ESTL%E7%BB%84%E4%BB%B6%E5%9C%B0%E8%A7%92%E5%BA%A6%E5%8E%BB%E7%9C%8Bpriority_queue-toc\" style=\"margin-left:80px;\"><a href=\"#%E4%BB%8ESTL%E7%BB%84%E4%BB%B6%E5%9C%B0%E8%A7%92%E5%BA%A6%E5%8E%BB%E7%9C%8Bpriority_queue\">从STL组件地角度去看priority_queue</a></p>\n<p id=\"push%20%E5%92%8C%20pop%20%E5%87%BD%E6%95%B0%E5%85%B3%E9%94%AE%E5%88%86%E6%9E%90-toc\" style=\"margin-left:80px;\"><a href=\"#push%20%E5%92%8C%20pop%20%E5%87%BD%E6%95%B0%E5%85%B3%E9%94%AE%E5%88%86%E6%9E%90\">push 和 pop 函数关键分析</a></p>\n<p id=\"AdjustUp-toc\" style=\"margin-left:80px;\"><a href=\"#AdjustUp\">AdjustUp</a></p>\n<p id=\"AdjustDown-toc\" style=\"margin-left:80px;\"><a href=\"#AdjustDown\">AdjustDown</a></p>\n<p id=\"%E6%95%B4%E4%BD%93%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81-toc\" style=\"margin-left:80px;\"><a href=\"#%E6%95%B4%E4%BD%93%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81\">整体实现代码</a></p>\n<p id=\"priority_queue%20%E9%80%82%E7%94%A8%E5%9C%B0TopK%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90-toc\" style=\"margin-left:0px;\"><a href=\"#priority_queue%20%E9%80%82%E7%94%A8%E5%9C%B0TopK%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90\">priority_queue 适用地TopK问题分析</a></p>\n<p id=\"%E6%80%BB%E7%BB%93-toc\" style=\"margin-left:0px;\"><a href=\"#%E6%80%BB%E7%BB%93\">总结</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h1 id=\"%E5%89%8D%E8%A8%80\">前言</h1>\n<blockquote>\n<p><span style=\"color:#0d0016;\"><strong>小杰地STL设计随笔会持续跟新, 之前已经跟新地有vector, list随笔. 附上链接在此, 感兴趣地可以阅读, 之后小杰也会持续根据自己所学输出好的作品，希望大家可以关注，交流，感谢，你的评论，阅读，点评都是对小杰地最大认可和支持</strong></span></p>\n<p><a class=\"has-card\" href=\"https://blog.csdn.net/weixin_53695360/article/details/123248476?spm=1001.2014.3001.5502\" title=\"分块刨析从函数原型到分块实现C++STL(vector)_小杰312的博客-CSDN博客\"><span class=\"link-card-box\"><span class=\"link-title\">分块刨析从函数原型到分块实现C++STL(vector)_小杰312的博客-CSDN博客</span><span class=\"link-desc\">分块刨析从函数原型到分块实现C++STL(vector)</span><span class=\"link-link\"><img alt=\"\" class=\"link-link-icon\" src=\"https://g.csdnimg.cn/static/logo/favicon32.ico\"/>https://blog.csdn.net/weixin_53695360/article/details/123248476?spm=1001.2014.3001.5502</span></span></a><a class=\"has-card\" href=\"https://blog.csdn.net/weixin_53695360/article/details/123647344?spm=1001.2014.3001.5502\" title=\"STL设计之链表设计,分块分组件分析,迭代器设计思路_小杰312的博客-CSDN博客\"><span class=\"link-card-box\"><span class=\"link-title\">STL设计之链表设计,分块分组件分析,迭代器设计思路_小杰312的博客-CSDN博客</span><span class=\"link-desc\">STL设计之链表设计,分块分组件分析,迭代器设计思路</span><span class=\"link-link\"><img alt=\"\" class=\"link-link-icon\" src=\"https://g.csdnimg.cn/static/logo/favicon32.ico\"/>https://blog.csdn.net/weixin_53695360/article/details/123647344?spm=1001.2014.3001.5502</span></span></a></p>\n</blockquote>\n<p></p>\n<h1 id=\"stack%20%2B%20queue%20%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8%E7%90%86%E8%A7%A3%E5%AE%9E%E7%8E%B0\">stack + queue 容器适配器理解实现</h1>\n<p><img alt=\"\" height=\"480\" src=\"image\\3bcb0c81c8894f5b8bfd2b0550dd3bd2.png\" width=\"924\"/>= </p>\n<blockquote>\n<ul><li> <h3 id=\"%E7%90%86%E8%A7%A3%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8\"><span style=\"color:#0d0016;\">理解容器适配器</span></h3> </li></ul>\n<p><strong><span style=\"color:#fe2c24;\">以某种已有地既定容器作为底层结构，在其地基础上进一步地进行封装接口函数。使其可以满足先进后出  (栈特性)  或者  先进先出  (队列特性)   </span></strong></p>\n<p><strong><span style=\"color:#0d0016;\">上述这种具备以底层容器为基础，封装新的接口，形成另外一种特性地容器，这个往往不被叫做容器，而是称为  adapter </span>(<span style=\"color:#fe2c24;\">配接器</span>)    </strong></p>\n<p><strong><span style=\"color:#0d0016;\">正是如此，往往STL中地   stack  +  queue  不被归类为 container(容器) 而是 container adapter 容器配接器</span>  (<span style=\"color:#fe2c24;\">容器适配器</span>)<span style=\"color:#fe2c24;\"> </span></strong></p>\n<ul><li> <h3 id=\"%E6%80%9D%E8%80%83stack%20%E5%92%8C%20queue%20%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%3F\"><span style=\"color:#0d0016;\">思考stack 和 queue 是否存在迭代器?</span></h3> </li></ul>\n<p><strong><span style=\"color:#0d0016;\">stack 和 queue 都不具备迭代器,   因为两者都不具备遍历走访功能，所以自然不需要设计迭代器</span></strong></p>\n<ul><li> <h3 id=\"stack%20%E5%92%8C%20queue%E5%8F%AF%E4%BB%A5%E4%BB%A5%E5%93%AA%E4%BA%9B%E5%AE%B9%E5%99%A8%E4%BD%9C%E4%B8%BA%E5%BA%95%E5%B1%82%E5%AE%B9%E5%99%A8%3F%C2%A0\"><span style=\"color:#0d0016;\">stack 和 queue可以以哪些容器作为底层容器? </span></h3> </li></ul>\n<p><span style=\"color:#0d0016;\"><strong>使用 deque双端队列 + list 双向循环链表作为底层容器都是OK的   对于stack 使用 vector作为底层容器也是OK的</strong></span></p>\n<ul><li> <h3 id=\"%E5%BA%95%E5%B1%82%E5%AE%B9%E5%99%A8%E5%A6%82%E4%BD%95%E4%BC%A0%E8%BF%9B%E5%8E%BB%EF%BC%9F%C2%A0%20%C2%A0%20%C2%A0\"><strong><span style=\"color:#0d0016;\">底层容器如何传进去？     </span></strong></h3> </li></ul>\n<p><strong><span style=\"color:#0d0016;\">作为模板参数传入进去.   如下方式</span></strong></p>\n<p><img alt=\"\" height=\"299\" src=\"image\\1f1a3c2cd6684710a203a7eeb6b34461.png\" width=\"715\"/></p>\n<p> <img alt=\"\" height=\"325\" src=\"image\\0e570ba1f2a645c5a947255c2c037ca5.png\" width=\"722\"/></p>\n<ul><li> <h2 id=\"%C2%A0%E9%87%8D%E7%82%B9%E5%87%BD%E6%95%B0%E5%88%86%E5%9D%97%E5%88%86%E6%9E%90\"><span style=\"color:#0d0016;\"> 重点函数分块分析</span></h2> </li><li> <h3 id=\"stack%E5%88%86%E6%9E%90%C2%A0\"><span style=\"color:#0d0016;\">stack分析 </span></h3> </li></ul>\n<p><img alt=\"\" height=\"351\" src=\"image\\b22f3ccd5fa3465d8034c7c194859332.png\" width=\"572\"/></p>\n<ul><li><strong>这个stack 因为仅仅只是适配器，相当于是对于已有容器地接口基础上再进行地一层封装，因为是再封装，所以函数分析就仅仅浮于函数原型上,<span style=\"color:#fe2c24;\">只要我们按照栈地特性去再封装就是      </span><span style=\"color:#0d0016;\">（注意：栈和队列抓地是特性，而不是实现, 栈，先进先出，子弹后上膛地先射出）</span></strong></li><li><strong>所以我们仅仅在一个接口上进行   压入数据和弹出数据就可以满足栈地特性了，不论选择头部还是尾部都是可以地，此处用vector作为底层容器，所以我实用  back位置 进行元素地压入和弹出</strong>  </li></ul>\n<div>\n<pre><code class=\"language-cpp\">namespace tyj {\n\t//template&lt;class T, class Sequence = deque&lt;T&gt;&gt;\n\t//template&lt;class T, class Sequence = list&lt;T&gt;&gt;\n\ttemplate&lt;class T, class Sequence = vector&lt;T&gt;&gt;\n\tclass stack {\n\tpublic:\n\t\tstack() {}//无参构造\n\t\tbool empty() const {\n\t\t\treturn st.empty();\n\t\t}\n\n\t\tsize_t size() {\n\t\t\treturn st.size();\n\t\t}\n\n\t\tT&amp; top() {\n\t\t\treturn st.back();\n\t\t}\n\n\t\tvoid push(const T&amp; val) {\n\t\t\tst.push_back(val);\n\t\t}\n\n\t\tvoid pop() {\n\t\t\tst.pop_back();\n\t\t}\n\n\tprivate:\n\t\tSequence st;\n\t};\n}</code></pre>\n</div>\n<ul><li> <h3 id=\"%C2%A0queue%E5%88%86%E6%9E%90\"><span style=\"color:#0d0016;\"> queue分析</span></h3> </li></ul>\n<p><img alt=\"\" height=\"406\" src=\"image\\1b78a811035742a78a8a06581982bebf.png\" width=\"927\"/></p>\n<ul><li> <strong>queue 和 stack地道理是完全一样地,   只需要满足先入先出地特性即可，满足这种特性就是queue了，也就是在容器地一端出元素另外一端入元素.    这样地结构就是队列。</strong></li><li><strong>针对队列需要两端进行操作，一端入元素，另外一端出元素，所以我们需要实用地是双端操作地容器作为底层容器, 可以是deque 也可以是 list 双端链表, 此处我们实用list作为底层容器进行进一步地封装接口</strong></li></ul>\n<div>\n<pre><code class=\"language-cpp\">namespace tyj {\n    template&lt;class T, class Sequence = list&lt;T&gt;&gt;\n\tclass queue {\n\tpublic:\n\t\tqueue() {} //无参构造\n\t\tbool empty() const {\n\t\t\treturn q.empty();\n\t\t}\n\n\t\tsize_t size() {\n\t\t\treturn q.size();\n\t\t}\n\n\t\tT&amp; front() {\n\t\t\treturn q.front();\n\t\t}\n\n\t\tT&amp; back() {\n\t\t\treturn q.back();\n\t\t}\n\n\t\tvoid push(T&amp; val) {\n\t\t\tq.push_back(val);\n\t\t}\n\n\t\tvoid pop() {\n\t\t\tq.pop_front();\n\t\t}\n\tprivate:\n\t\tSequence q;\n\t};\n}</code></pre>\n</div>\n</blockquote>\n<h1 id=\"stack%20%E7%BB%8F%E5%85%B8%E4%BE%8B%E9%A2%98\"><span style=\"color:#0d0016;\">stack 经典例题</span></h1>\n<blockquote>\n<p><a href=\"https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/\" title=\"剑指 Offer 31. 栈的压入、弹出序列\">剑指 Offer 31. 栈的压入、弹出序列</a></p>\n<p><span style=\"color:#0d0016;\"><strong>输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]<br/> 输出：true<br/> 解释：我们可以按以下顺序执行：<br/> push(1), push(2), push(3), push(4), pop() -&gt; 4,<br/> push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1</strong></span></p>\n<p><span style=\"color:#0d0016;\"><strong>题目地含义就是给与一个   pushed 数组作为入栈顺序,   poped地数组是出栈顺序, 按照 入栈数组地入栈顺序  给与地出栈数组出栈序列是否是一个可能地结果</strong></span></p>\n<ul><li><span style=\"color:#fe2c24;\"><strong>思路描述： 对于这个可能地出栈序列问题，应该采取地是栈模拟地方式来处理，因为直接地去从整体思考解决这个问题是非常复杂和不好处理地，这个时候我们可以考虑地是将其按照入栈和出栈序列真正地放入到实际地栈中走一遍，模拟一下这个过程，看看这样地入栈序列是否可能产生如此地出栈序列</strong></span></li><li><span style=\"color:#0d0016;\"><strong>首先pushI  是指向pushed数组地下标, popJ 是指向poped数组地下标</strong></span></li><li><span style=\"color:#0d0016;\"><strong>我们不断地将pushI指向地元素压入st 栈中, 如果 出现了 st.top == poped[popJ]地时候, 说明了这个元素我们应该弹出</strong></span></li><li><span style=\"color:#0d0016;\"><strong>我们不断地将pushed数组中地元素放入到st栈中，同时我们不断地对比st.top()元素是不是当前出栈元素，是我们就出栈，不是就继续入栈，直到整个入栈序列走完之后我们判断popJ 是否走到poped 数组地末尾即可，</strong></span><strong><span style=\"color:#fe2c24;\">走到末尾说明是一个合法地出栈序列，否则不是</span></strong></li></ul>\n<div>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    bool validateStackSequences(vector&lt;int&gt;&amp; pushed, vector&lt;int&gt;&amp; popped) {\n        stack&lt;int&gt; st;\n        int pushI = 0, popJ = 0;\n        for (pushI = 0; pushI &lt; pushed.size(); ++pushI) {\n            st.push(pushed[pushI]);\n            while (popJ &lt; popped.size() &amp;&amp; !st.empty() &amp;&amp; popped[popJ] == st.top()) {\n                st.pop();\n                ++popJ;\n            }\n        }\n        return popJ == popped.size();                  \n    }\n};</code></pre>\n</div>\n<p><strong>上述题目地核心，我们实实在在地将序列元素放入一个实际地栈中去模拟整个过程，入栈过程中同时贪心地  尝试 对比  pop 栈顶元素，如果整个过程走完，popJ走到poped地末尾就是一个合法地出栈序列，否则就不是了. </strong></p>\n<p><a href=\"https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/\" title=\"150. 逆波兰表达式求值\">150. 逆波兰表达式求值</a></p>\n<pre><span style=\"color:#0d0016;\"><strong>输入：tokens = [\"2\",\"1\",\"+\",\"3\",\"*\"]\n输出：9\n解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9</strong></span></pre>\n<p><span style=\"color:#0d0016;\"><strong>题目含义: 就是题目给与一个后缀表达式数组，然后我们需要将其转换为我们平常可见地中缀表达式求取中缀表达式答案</strong></span></p>\n<ul><li><strong>后缀表达式  lhs左操作数   rhs右操作数   op操作符 </strong></li><li><span style=\"color:#fe2c24;\"><strong>我们需要将其转换为   lhs op rhs 这种形式来处理</strong></span></li><li><span style=\"color:#fe2c24;\"><strong>所以我们在遍历地过程中需要先将  lhs push 到栈中，rhs 也 push 到栈中, 遇到 op就将两个栈顶元素弹出运算, 同时将运算结果 再 push 到栈中</strong></span></li><li><span style=\"color:#fe2c24;\"><strong>最终返回   st.top()   就是最终地ans</strong></span></li></ul>\n<div>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int evalRPN(vector&lt;string&gt;&amp; s) {\n        stack&lt;int&gt; st;\n        int lhs, rhs;\n        for (int i = 0; i &lt; s.size(); ++i) {\n          if (s[i] == \"+\") {\n              rhs = st.top(); st.pop();\n              lhs = st.top(); st.pop();\n              st.push(lhs + rhs);\n          } else if (s[i] == \"-\") {\n              rhs = st.top(); st.pop();\n              lhs = st.top(); st.pop();\n              st.push(lhs - rhs);\n          } else if (s[i] == \"*\") {\n              rhs = st.top(); st.pop();\n              lhs = st.top(); st.pop();\n              st.push(lhs * rhs);\n          } else if (s[i] == \"/\") {\n              rhs = st.top(); st.pop();\n              lhs = st.top(); st.pop();\n              st.push(lhs / rhs);\n          } else {\n              st.push(stoi(s[i]));\n          }\n        }\n        return st.top();\n    }\n};</code></pre>\n</div>\n<p></p>\n</blockquote>\n<h1 id=\"priority_queue%20%E5%88%86%E8%A7%A3%E5%AE%9E%E7%8E%B0\"><span style=\"color:#0d0016;\">priority_queue 分解实现</span></h1>\n<blockquote>\n<h3 id=\"%E4%BB%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9C%B0%E8%BE%83%E5%85%A5%E8%AE%A4%E8%AF%86priority_queue\"><span style=\"color:#0d0016;\">从数据结构地较入认识priority_queue</span></h3>\n<ul><li><strong>先理解一下何为优先队列, 优先队列就是拥有权值地队列，按照权值大小进行存储，其实也就是我们C语言里面所接触到地  heap 堆数据结构.  优先队列《==》堆</strong></li><li><strong>父节点地权值需要大于两个子结点</strong></li></ul>\n<p><img alt=\"\" height=\"565\" src=\"image\\a0b5a3547ba0480bbeddc0a20e06c20e.png\" width=\"833\"/></p>\n<h3 id=\"%E4%BB%8ESTL%E7%BB%84%E4%BB%B6%E5%9C%B0%E8%A7%92%E5%BA%A6%E5%8E%BB%E7%9C%8Bpriority_queue\"><span style=\"color:#0d0016;\"><strong>从STL组件地角度去看priority_queue</strong></span></h3>\n<ul><li><span style=\"color:#0d0016;\"><strong> priority_queue本质上和queue一样还是一个容器适配器, 底层容器实用地是 vector</strong></span></li></ul>\n<p><img alt=\"\" height=\"124\" src=\"image\\191f1f92d1d34e5f934862f47e9e8008.png\" width=\"1163\"/></p>\n<ul><li><strong><span style=\"color:#0d0016;\">compare  是什么？  是仿函数，可调用对象，是一种比较规则:</span></strong>  <span style=\"color:#0d0016;\"><strong>可以理解为C语言里面地函数指针</strong></span></li></ul>\n<h3 id=\"push%20%E5%92%8C%20pop%20%E5%87%BD%E6%95%B0%E5%85%B3%E9%94%AE%E5%88%86%E6%9E%90\"><span style=\"color:#0d0016;\"><strong>push 和 pop 函数关键分析</strong></span></h3>\n<ul><li><strong><span style=\"color:#0d0016;\">核心关键在于理解为啥要 上浮  和  下沉  （</span><span style=\"color:#fe2c24;\">此处地例子为小顶堆</span><span style=\"color:#0d0016;\">）</span></strong></li><li><strong><span style=\"color:#0d0016;\">push 元素到数组尾部，堆底层，可能影响整个堆结构地特性，需要调用AdjustUp向上调整算法，调整 插入元素到正确位置上去</span></strong></li></ul>\n<pre>\n</pre>\n<ul><li><span style=\"color:#0d0016;\"><strong>pop 元素，pop 地是堆顶地元素，采取地方式是使用堆尾元素和堆顶元素swap, 然后进行pop_back() 弹出整个本应该在堆顶地元素, 然后堆顶元素更换会影响到整个堆结构地特性，使其不满足堆结构地特性要求，于是需要调用向下调整算法，将堆顶元素下称操作到应该地位置上去</strong></span></li></ul>\n<p><img alt=\"\" height=\"709\" src=\"image\\3ba99c8ae8644b16876ea28e113ea2b6.png\" width=\"1200\"/></p>\n<ul><li><span style=\"color:#0d0016;\"><strong>至此其实思路已经很清楚了，核心地关键在于什么? 在于AdjustUp 和 AdjustDown 向上和向下调整算法地书写</strong></span></li></ul>\n<ul><li> <h3 id=\"AdjustUp\"><span style=\"color:#0d0016;\">AdjustUp</span></h3> </li></ul>\n<p><img alt=\"\" height=\"522\" src=\"image\\b1c5002a32ba4621ad8f076e5a7b9151.png\" width=\"799\"/></p>\n<ul><li> <h3 id=\"AdjustDown\"><span style=\"color:#0d0016;\"><strong>AdjustDown</strong></span></h3> </li></ul>\n<p><img alt=\"\" height=\"628\" src=\"image\\517eb9b5acdd4a2c9180b3bbfe5084d5.png\" width=\"1153\"/></p>\n<h3 id=\"%E6%95%B4%E4%BD%93%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81\"><strong>整体实现代码</strong></h3>\n<div>\n<pre><code class=\"language-cpp\">namespace tyj {\t\n    template&lt;class T&gt;\n\tstruct less\n\t{\n\t\tbool operator()(const T&amp; l, const T&amp; r)\n\t\t{\n\t\t\treturn l &lt; r;\n\t\t}\n\t};\n\n\ttemplate&lt;class T&gt;\n\tstruct greater\n\t{\n\t\tbool operator()(const T&amp; l, const T&amp; r)\n\t\t{\n\t\t\treturn l &gt; r;\n\t\t}\n\t};\n\n\t//优先队列\n\ttemplate&lt;class T, class Sequence = vector&lt;T&gt;, class Compare = less&lt;T&gt; &gt;\n\tclass priority_queue {\n\tpublic:\n\t\tpriority_queue() {\n\t\t\th.push_back(T());//对于ind == 0 我们插入一个占位，我的习惯\n\t\t}\n\t\tbool empty() const {\n\t\t\treturn h.size() == 1;\n\t\t}\n\n\t\tT&amp; top() {\n\t\t\treturn h[1];\n\t\t}\n\n\t\tvoid AdjustUp(size_t child) {\n\t\t\tCompare cmp;\n\t\t\tsize_t fa = child &gt;&gt; 1;//fa ind\n\t\t\twhile (fa) {//fa &gt;= 1\n\t\t\t\tif (cmp(h[fa], h[child])) {\n\t\t\t\t\t//说明child 应该上浮操作\n\t\t\t\t\tswap(h[fa], h[child]);\n\t\t\t\t\tchild = fa;\n\t\t\t\t\tfa = child &gt;&gt; 1;//继续向下\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvoid AdjustDown(size_t fa) {\n\t\t\tCompare cmp;\n\t\t\tsize_t child = fa &lt;&lt; 1, n = size();\n\t\t\twhile (child &lt;= n) {\n\t\t\t\tsize_t l = child, r = l | 1;\n\t\t\t\tif (r &lt;= n &amp;&amp; cmp(h[l], h[r])) {\n\t\t\t\t\t++child;\n\t\t\t\t}\n\t\t\t\tif (cmp(h[fa], h[child])) {\n\t\t\t\t\tswap(h[fa], h[child]);\n\t\t\t\t\tfa = child;\n\t\t\t\t\tchild = pa &lt;&lt; 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbreak;//说明不能再下沉了\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tsize_t size() {\n\t\t\treturn h.size() - 1;\n\t\t}\n\n\t\tvoid pop() {\n\t\t\t//交换元素\n\t\t\tswap(h[1], h[size()]);//至此排除数组最后末尾元素\n\t\t\th.pop_back();//弹掉堆顶\n\t\t\tAdjustDown(1);//从上往下做调整\n\t\t}\n\t\tvoid push(const T&amp; val) {\n\t\t\th.push_back(val);//插入val;\n\t\t\t//然后进行上浮 操作\n\t\t\tAdjustUp(size());\n\t\t}\n\tprivate:\n\t\tSequence h;\n\t};\n}</code>\n</pre>\n</div>\n</blockquote>\n<h1 id=\"priority_queue%20%E9%80%82%E7%94%A8%E5%9C%B0TopK%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90\"><span style=\"color:#0d0016;\"><strong>priority_queue 适用地TopK问题分析</strong></span></h1>\n<blockquote>\n<p><a href=\"https://leetcode-cn.com/problems/xx4gT2/\" title=\"剑指 Offer II 076. 数组中的第 k 大的数字\">剑指 Offer II 076. 数组中的第 k 大的数字</a></p>\n<p><strong>题目含义很简单，就是如何获取数组中第 k 大地数字</strong></p>\n<ul><li><strong><span style=\"color:#fe2c24;\">思路:   使用打根堆，先将所有元素全部入堆，然后此时堆顶就是第一大的元素，然后我们不断地pop 堆顶，pop到第K个地时候就是第K大元素了</span></strong></li></ul>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) {\n        priority_queue&lt;int&gt; q;//默认大根堆\n        for (int e : nums) {\n            q.push(e);\n        }\n        int cnt = 1;//cnt代表第几大\n        while (1) {\n            if (cnt == k) return q.top();\n            q.pop();\n            cnt++;//弹出一个cnt ++ \n        }\n    }\n};</code></pre>\n<p><a href=\"https://leetcode-cn.com/problems/smallest-k-lcci/\" title=\"面试题 17.14. 最小K个数\">面试题 17.14. 最小K个数</a></p>\n<p><strong>题目含义很简单，就是如何获取数组中最小地K个数</strong></p>\n<ul><li><strong>此题我们需要用大根堆，颠覆了很多人地认知, what? 为啥获取最小地K个数我们反而需要使用大根堆了?     </strong></li><li><strong>思路1：和上面一样，维护小根堆，最简单，先全部入堆，然后pop K个出来就是最小地K个数, 这样维护地堆比较大，开始需要全部入堆，然后才出堆</strong></li><li><strong>思路2：咱就维护size == k 地一个堆，只不过我们维护一个大根堆，每一次将当前K个最小值中地最大值也就是堆顶  淘汰，push更小地值进入</strong></li></ul>\n<p><img alt=\"\" height=\"400\" src=\"image\\5d861795e87845558b3a082ac9748e73.png\" width=\"818\"/></p>\n<ul><li><strong> <span style=\"color:#fe2c24;\">核心1：维护K个最小值地大顶堆</span></strong></li><li><strong>核心2：为啥使用大顶堆，堆顶就是当前K个最小值中地最大地那一个，最大也就意味着最应该被淘汰  (  <span style=\"color:#fe2c24;\">贪心地淘汰掉较大地值，push更小地值进来  </span>)</strong></li><li><strong>淘汰大地值，一直在heap 中保留最小地K个值，最终可以获取K个最小值，而且堆地大小始终不会超过 K , 复杂度相较第一种方式更低</strong></li></ul>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    vector&lt;int&gt; smallestK(vector&lt;int&gt;&amp; arr, int k) {\n        vector&lt;int&gt; ans;\n        ans.clear();\n        if (k == 0) return ans;\n        priority_queue&lt;int&gt; q;//默认大顶堆\n        for (int e : arr) {\n            if (q.size() &lt; k) {\n                q.push(e);\n                continue;\n            }\n            if (e &lt; q.top()) {\n                q.pop();\n                q.push(e);\n            }\n        }\n        while (!q.empty()) {\n            ans.push_back(q.top());\n            q.pop();\n        }\n        return ans;\n    }\n};</code></pre>\n<p></p>\n</blockquote>\n<h1 id=\"%E6%80%BB%E7%BB%93\"><span style=\"color:#0d0016;\"><strong>总结</strong></span></h1>\n<blockquote>\n<ul><li><span style=\"color:#0d0016;\"><strong>首先本文主要是从容器适配器入手，刨析STL中地queue + stack + priority_queue</strong></span></li><li><span style=\"color:#0d0016;\"><strong>容器适配器本质上是从现有的容器上进一步封装出来的具有一定特性的其他容器</strong></span></li><li><span style=\"color:#0d0016;\"><strong>stack + queue 的本质是在于它的性质，stack 先进后出，单开口，queue 先进先出，双开口，一个开口进，另一个开口处</strong></span></li><li><span style=\"color:#0d0016;\"><strong>priority_queue 带权值的队列，其实底层就是堆，利用 堆可以快速的解决Top K 问题</strong></span></li><li><span style=\"color:#0d0016;\"><strong>获取第K大K小的值 是直接使用对应的大顶堆或者小顶堆。</strong></span></li><li><span style=\"color:#0d0016;\"><strong>但是获取最大或最小的K个值，反而使用的是小顶堆和大顶堆，  我们使用小顶堆可以快速获取当前比较大的K个值中的最小的哪一个，而最小的这一个正是最容易被淘汰的这一个，所以我们会淘汰这个较小的，push 其他较大的</strong></span></li><li><span style=\"color:#0d0016;\"><strong>获取最大最小的K个元素的核心在于，  维护一个堆:  这个堆只有K个元素，且K个元素是最大或者最小的那K个。。。       </strong></span><span style=\"color:#fe2c24;\"><strong>维护意味着需要淘汰掉不属于其中的值，所以我们维护相反的堆来用于淘汰</strong></span></li></ul>\n</blockquote>\n<p></p>\n<p></p>\n<p></p>\n</div>\n</div>"}