{"blogid": "126355480", "writerAge": "码龄2年", "writerBlogNum": "3", "writerCollect": "54", "writerComment": "3", "writerFan": "64", "writerGrade": "1级", "writerIntegral": "54", "writerName": "Dakhin", "writerProfileAdress": "writer_image\\profile_126355480.jpg", "writerRankTotal": "117811", "writerRankWeekly": "6639", "writerThumb": "20", "writerVisitNum": "1644", "blog_read_count": "1261", "blog_time": "已于 2022-08-16 18:59:54 修改", "blog_title": "一文带你从C快速过渡到C++", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h1><a id=\"P0__0\"></a>P0 前言</h1>\n<p>很多同学都有这样的困扰，那就是已经学过C语言了，想学习C++，结果上网一搜发现，很多教程都是\"C++重零开始到入门\"之类的课，很多知识和C学习是重复，没必要浪费大量的时间重头开始学起。因此为了节约时间，有了以下笔记。本人仅仅是个小白，不是什么大神，只是愿意将自己的学习笔记分享出来而已，如有错漏，欢迎指正。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\7da8ba6d9ccd45a495e7adc9cb96885d.png\"/></p>\n<h1><a id=\"P1_C_7\"></a>P1 C标准库—注释—条件编译</h1>\n<p>C++中包含了C标准库的移植版本，C标准库的头文件xx.h基本上变成了cxx</p>\n<table><thead><tr><th>C库</th><th>C++库</th></tr></thead><tbody><tr><td>stdio.h</td><td>cstdio</td></tr><tr><td>math.h</td><td>cmath</td></tr><tr><td>string.h</td><td>cstring</td></tr><tr><td><strong>malloc.h</strong>(特别的)</td><td><strong>malloc.h</strong></td></tr></tbody></table>\n<hr/>\n<p>块注释：</p>\n<pre><code class=\"prism language-c++\">/*...*/\n</code></pre>\n<p>单行注释：</p>\n<pre><code class=\"prism language-c++\">//\n</code></pre>\n<p>条件编译</p>\n<pre><code>#if 0                  #if 1                          #ifdef XXX                    #ifndef XXX      \n\n...                    ...                             ....                          ...\n\n#endif                 #else                           #endif                        #else\n\n​                       ...                                                            ...\n\n\t\t\t\t\t   #endif                                       \t\t          #endif\n</code></pre>\n<hr/>\n<p>例子：</p>\n<pre><code class=\"prism language-c++\">#define _CRT_SECURE_NO_WARNINGS \n#include &lt;cstdio&gt; //标准输入输出函数 \n#include &lt;cmath&gt; \n#include &lt;cstring&gt; //字符串处理函数 \nint main() {\n\tprintf(\"hello\\n\");\n\tdouble x = 3.14;\n\tprintf(\"%lf %lf\\n\", sqrt(x), sin(x));\n\n\tchar s[10] = \"hello\";\n\tputs(s);\n\tchar s2[16];\n\tstrcpy(s2, \"world\");\n\tputs(s2);\n\tstrcat(s2, \"sdfsdf\");\n\tputs(s2);\n\tprintf(\"%d %d\\n\", strlen(s), strlen(s2));\n\treturn 0;\n}\n</code></pre>\n<p><img alt=\"image-20220808153504265\" src=\"image\\b9c94b4f669a88284abb58e383dc6b2a.png\"/></p>\n<hr/>\n<h1><a id=\"P2_C_84\"></a>P2 C++标准输入输出流—名字空间</h1>\n<ul><li>包含头文件#include </li><li>cout是一个标准输出流变量（对象），代表控制台窗口</li><li>&lt;&lt;是一个输出流运算符，o &lt;&lt; x : 表示数据x输出到o</li><li>cout是标准名字空间std的一个名字，必须加上名字空间限定std::cout \n  <ul><li>std::cout &lt;&lt; “Hello world” &lt;&lt; endl;</li><li>using std::cout;</li><li>using namespace std</li></ul> </li></ul>\n<pre><code class=\"prism language-c++\">#include &lt;iostream&gt; //C++标准输入输出流头文件\n\nusing namespace std;\n\nint main()\n{\n    cout &lt;&lt; \"hello world!\" &lt;&lt; endl;\n    cout &lt;&lt; \"https://a.hwdong.com\" &lt;&lt; endl;\n    cout &lt;&lt; 3 + 4 &lt;&lt; endl;\n\n\n    double radius;\n    cout &lt;&lt; \"Please enter r:\\n\";\n    std::cin &gt;&gt; radius; //标准输入流对象cin 输入运算符&gt;&gt;\n\n    cout &lt;&lt; 3.14 * radius * radius &lt;&lt; endl;\n\n    std::cout &lt;&lt; \" *\\n\";\n    std::cout &lt;&lt; \" * *\\n\";\n    std::cout &lt;&lt; \" * *\\n\";\n    return 0;\n}\n</code></pre>\n<p><img alt=\"image-20220809103518257\" src=\"image\\50c64fb050f66b644666c204b02eccc8.png\"/></p>\n<pre><code class=\"prism language-c++\">#include &lt;fstream&gt; \n#include &lt;iostream&gt; \n#include &lt;string&gt; \nusing namespace std;\n\nint main() {\n\tofstream oF(\"test.txt\");\n\toF &lt;&lt; 3.14 &lt;&lt; \" \" &lt;&lt; \"hello world\\n\";\n\toF.close();\n\tifstream iF(\"test.txt\");\n\tdouble d;\n\tstring str;\n\tiF &gt;&gt; d &gt;&gt; str;\n\tcout&lt;&lt;d &lt;&lt;\" \"&lt;&lt; str&lt;&lt;endl;\n\n\treturn 0;\n}\n</code></pre>\n<hr/>\n<h1><a id=\"P3__143\"></a>P3 引用变量、引用形参、默认形参</h1>\n<h2><a id=\"1_145\"></a>1.引用变量</h2>\n<ul><li> <p>引用变量是其他变量的别名。如同一个人的外号或小名, 共用同一块内存</p> </li><li> <p>定义引用变量时必须指明其引用的是哪个变量，且不能再指向其他变量</p> <pre><code class=\"prism language-c++\">int a = 3;\nint &amp;r = a;\n</code></pre> </li></ul>\n<h2><a id=\"2_156\"></a>2.引用形参</h2>\n<ul><li>C语言中函数的形参以”值传递“的方式，形参的改变不会改变实参 void Fuction(int x, int y)</li><li>C语言中必须以指针的形式才能使形参改变时也改变形参void Fuction(int *x, int *y)</li><li>C++中可以使用”引用形参“实现指针传参的功能，本质都是地址</li></ul>\n<img alt=\"image-20220809204507305\" src=\"image\\image-20220809204507305.png\"/>\n<pre><code class=\"prism language-c++\">#include &lt;iostream&gt; \nusing namespace std;\n\nvoid swap(int &amp;x, int &amp;y) //X就是a，y就是b，没有产生新的内存块\n{\n\tint t = x;\n\tx = y;\n\ty = t;\n}\n\nint main() \n{\n\tint a = 3, b = 4;\n\tcout &lt;&lt; a &lt;&lt; '\\t' &lt;&lt; b &lt;&lt; endl;\n\tswap(a, b);\n\tcout &lt;&lt; a &lt;&lt; '\\t' &lt;&lt; b &lt;&lt; endl;\n}\n</code></pre>\n<p><img alt=\"image-20220809205430867\" src=\"image\\58aa8901d667a97870918a3fa49dfcae.png\"/></p>\n<h2><a id=\"3_186\"></a>3.默认形参</h2>\n<ul><li> <p>函数的默认形参必须在非默认形参右边，即一律靠右</p> </li><li> <p>函数传参时，如果不赋值，按默认形参值执行</p> <pre><code class=\"prism language-c++\">void add(int x = 1, int y, int z = 3);   //错误\nvoid add(int y, int x = 1, int z = 3);   //正确\n</code></pre> <pre><code class=\"prism language-c++\">#include &lt;iostream&gt; \nusing namespace std;\n\nvoid print(char ch, int n = 1) {\n\tfor (int i = 0; i &lt; n; i++)\n\t\tcout &lt;&lt; ch;\n}\n\nint main() {\n\tprint('*'); cout &lt;&lt; endl; //默认n=1,可以不写\n\tprint('*',3); cout &lt;&lt; endl;\n\tprint('*',5); cout &lt;&lt; endl;\n}\n</code></pre> <p><img alt=\"image-20220809210354657\" src=\"image\\e46248618d5fdf1bb6f49dfcfcb8b37d.png\"/></p> </li></ul>\n<hr/>\n<h1><a id=\"P4__217\"></a>P4 函数重载⭐</h1>\n<ul><li> <p>C++允许同一作用域里有同名的函数，只要它们的形参列表不同。如：</p> <pre><code class=\"prism language-c++\">int add(int x, int y);\nint add(double x, double y);\ndouble add(float x, float y);\n</code></pre> </li><li> <p>函数名+形参列表 构成了函数的签名，与返回类型无关,不能以返回类型区分函数。</p> <pre><code class=\"prism language-c++\">#include &lt;iostream&gt;\n\nusing namespace std;\n\nint add(int x, int y)\n{\n    return x + y;\n}\n\ndouble add(double x, double y)\n{\n    return x + y;\n}\n\nint main()\n{\n    cout &lt;&lt; add(5, 3) &lt;&lt; endl;\n    cout &lt;&lt; add(5.3, 7.8) &lt;&lt; endl;\n    cout &lt;&lt; add((double) 5, 7.8) &lt;&lt; endl;\n}\n</code></pre> <p><img alt=\"image-20220809211443157\" src=\"image\\d55c21db2060993c0a21270ea54422a1.png\"/></p> </li></ul>\n<hr/>\n<h1><a id=\"P5__256\"></a>P5 函数模板</h1>\n<ul><li> <p>泛化算法：用template关键字增加一个模板头，将数据类型变成类型模板参数</p> </li><li> <p>函数模板不是函数，而是产生函数的模板，使用时，加上&lt;类型&gt;就会自动产生该类型的函数</p> </li><li> <p>模板参数可以自动推断类型，为避免歧义，建议使用时还是加上&lt;类型&gt;</p> <pre><code class=\"prism language-c++\">template&lt;typename T&gt; //每一个函数模板都需要加这个\nT add(T x, T y)\n{\n\treturn x + y;\n}\n</code></pre> <p>例子：</p> <pre><code class=\"prism language-c++\">#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nusing namespace std;\n\ntemplate&lt;typename T&gt;\nT add(T x, T y)\n{\n    return x + y;\n}\n\nint main()\n{\n    cout &lt;&lt; add(5, 3) &lt;&lt; endl; //自动推断类型\n    cout &lt;&lt; add&lt;double&gt;(5, 7.8) &lt;&lt; endl; //歧义性\n    cout &lt;&lt; add&lt;string&gt;(\"hello\", \" world\") &lt;&lt; endl;\n}\n</code></pre> <p><img alt=\"image-20220809214933906\" src=\"image\\46a86dbd26fec2e8a220484e04f2821c.png\"/></p> </li></ul>\n<hr/>\n<h1><a id=\"P6_stringvector_298\"></a>P6 用户定义类型（string、vector）</h1>\n<h2><a id=\"1string_300\"></a>1.string（字符串）</h2>\n<ul><li> <p>是一个用户定义类型，表示符串</p> <pre><code class=\"prism language-c++\">string s = \"hello\", s2 = \"world\"\n</code></pre> </li><li> <p>可以用成员访问运算符 ” . “访问string类的成员</p> <pre><code class=\"prism language-c++\">int a=s.size() //取大小\ns=s.substr(1,3) //取第1~3位的字符,返回字符串\nint a=s.find(\"orl\") //查找字符串，返回所在下标\ns.insert(3,\"ABCD\") //在下标3前插入字符串\ns.insert(3,4,'w') //在下标3前插入4个w\ns1.swap(s2) //交换s1,s2的内容\n\ns1.append(s2) //添加s2的内容到s1：s1=\"123\",s2=\"abc\",-&gt;s1=\"123abc\"\ns1.append(s2);  // s1 = \"123abc\"\ns1.append(s2, 1, 2);  // s1 = \"123bc\"\ns1.append(3, 'K');  // s1 = \"123KKK\"\ns1.append(\"ABCDE\", 2, 3);  // s1 = \"123CDE\"，添加 \"ABCDE\" 的子串(2, 3)\n\ns=s.replace(2,3,\"aa\") //用aa替换原来字符串的第2-3位，返回字符串\ns=to_string(a) //把数值类型转化为string\nint a=stoi(s1) //把string转化为数值类型int\nfloat a=stof(s1) //把string转化为数值类型flloat\n\ns1.assign(s2) //用s2给s1赋值\ns1.assign(s2,2,3) //用s2的第2~3位给s1赋值\ns1.assign(10,'c') //用10个c给s1赋值\n\n\n</code></pre> </li><li> <p>可以用运算符” + “、” [] “(下标运算符)，处理string</p> <pre><code class=\"prism language-c++\">s + s2 //拼接两个字符串\ns[0] = 'H' //访问s字符的第0个成员\n</code></pre> <p>例子：</p> <pre><code class=\"prism language-c++\">#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nusing namespace std;\n\nint main()\n{\n    string s = \"hello\", s2(\"world\");\n    //访问运算符.\n\n    cout &lt;&lt; s.size() &lt;&lt; endl;\n    string s3 = s.substr(1, 3);\n    cout &lt;&lt; s3 &lt;&lt; endl;\n\n    string s4 = s + \" \" + s2;\n    cout &lt;&lt; s4 &lt;&lt; endl; //\"hello world\"\n\n\n    s4[0] = 'H';\n    s4[6] = 'W';\n    cout &lt;&lt; s4 &lt;&lt; endl;\n\n    int pos = s4.find(\"orl\");\n    cout &lt;&lt; pos &lt;&lt; endl;\n    s4.insert(3, \"ABCD\");\n    cout &lt;&lt; s4 &lt;&lt; endl;\n\n    for (int i = 0; i &lt; s4.size(); i++)\n        cout &lt;&lt; s4[i] &lt;&lt; \"-\";\n    cout &lt;&lt; \"\\n\";\n\n    string s5 = \"1234.5\";\n    float a = stof(s5);\n    cout &lt;&lt; a &lt;&lt; endl;\n\n}\n</code></pre> <p><img alt=\"image-20220809224026835\" src=\"image\\451681ccff3dd2a916367419c18eee16.png\"/></p> </li></ul>\n<h2><a id=\"2vector_386\"></a>2.vector（动态数组）</h2>\n<p>在C语言中，定义了一个静态数组后，其大小就固定了，不能再改变。</p>\n<p>而在C++中，加入了vector的类，可以随时改变数组的大小。</p>\n<ul><li>向量，类似于数组，但可以动态增长。头文件</li><li>是一个类模板，实例化产生一个类，如vector产生一个int类型的vector类（向量）</li><li>同样可以通过vector类对象去访问其成员，如成员访问函数</li><li>同样可以用符号运算符进行一些运算</li></ul>\n<pre><code class=\"prism language-c++\">vector::push_back(x) //在容器最后一个位置插入元素x\nvector::pop_back() //删除最后一个元素\nvector::size() //返回元素个数\nvector::capacity() //返回空间大小\nvector::resize(n) //重新分配成员个数为n\nvector::reserve(n) //重新分配空间大小为n\nvector::clear() //清空容器内容，但空间没改变\nvector::begin() //返回初始地址\nvector::end() //返回结尾地址\n    \nvector::erase()//删除元素或⼀段序列\niterator erase(iterator position);\niterator erase(iterator first, iterator last);\n\nvector::insert()//插⼊新的元素\niterator insert(iterator position, const T &amp;x); //v.insert(v.begin()+1,3)在第1位前插入3\nvoid insert(iterator position, size_type n, const T &amp;x);\nvoid insert(iterator position, InputIterator first, InputIterator last);\n//第⼀个函数，在迭代器指定的位置前插⼊值为x的元素\n//第⼆个函数，在迭代器指定的位置前插⼊n个值为x的元素\n//第三个函数，在迭代器指定的位置前插⼊另外⼀个容器的⼀段序列迭代器first到last若插⼊新的元素后总得元素个数⼤于capacity，则重新分配空间\n</code></pre>\n<pre><code class=\"prism language-c++\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main()\n{\n    vector&lt;int&gt; v = {7, 5, 16, 8};\n    //push_back()，最后添加一个元素\n\n    v.push_back(25);\n    v.push_back(13);\n\n    //成员函数size()、下标运算符[]\n    for (int i = 0; i &lt; v.size(); i++)\n        cout &lt;&lt; v[i] &lt;&lt; '\\t';\n    cout &lt;&lt; '\\n';\n\n    v.insert(v.begin()+1, 9); //插入不能用下标\n    v.pop_back();\n\n    for (int i = 0; i &lt; v.size(); i++)\n        cout &lt;&lt; v[i] &lt;&lt; '\\t';\n    cout &lt;&lt; '\\n';\n\n    v.resize(2);\n\n    for (int i = 0; i &lt; v.size(); i++)\n        cout &lt;&lt; v[i] &lt;&lt; '\\t';\n    cout &lt;&lt; '\\n';\n}\n</code></pre>\n<p><img alt=\"image-20220810220019642\" src=\"image\\4e50441fbde7ce530be695debc22daf3.png\"/></p>\n<hr/>\n<h1><a id=\"P7__459\"></a>P7 指针和动态内存分配</h1>\n<h2><a id=\"1_461\"></a>1.指针</h2>\n<p>⭐约定：指针就是地址！变量的指针就是变量的地址。</p>\n<ul><li> <p>可以用取地址运算符&amp;获得一个变量的地址，如&amp;var</p> </li><li> <p>指针变量就是存储指针（地址）的变量，如Type *P; //P是存储 ”Type类型变量的地址“ 的变量</p> </li><li> <p>可以通过取内容运算符*得到一个指针变量指向的变量，如 *P就是P指向的那个变量</p> </li></ul>\n<pre><code class=\"prism language-c++\">/* 指针就是地址，变量的指针就是变量的地址。 指针变量就是存储指针（地址）的变量。 */\n\n#include &lt;iostream&gt; \nusing namespace std;\n\nint main() {\n\tint a=3;\n\tint *p = &amp;a;   //取地址运算符&amp;用于获得a的地址：&amp;a\n\tcout &lt;&lt; p &lt;&lt; '\\t' &lt;&lt; &amp;a &lt;&lt; endl;     //p就是a的地址\n  \n\t//取内容运算符*用于获得指针指向的变量(内存块)\n\tcout &lt;&lt; *p &lt;&lt; '\\t' &lt;&lt; a &lt;&lt; endl;     //*p就是a\n  \n\t*p = 5;                              //即a = 5;\n\tcout &lt;&lt; *p &lt;&lt; '\\t' &lt;&lt; a &lt;&lt; endl;\n \n\tint *q = p;             //q和p值相同，都是a的地址(指针)\n\tcout &lt;&lt; *p &lt;&lt; '\\t' &lt;&lt; *q &lt;&lt; '\\t' &lt;&lt; a &lt;&lt; endl;\n}\n</code></pre>\n<h2><a id=\"2new_495\"></a>2.动态内存分配（new）</h2>\n<ul><li>new 可以代替 molloc, 且会对对象进行初始化（在类中很有用）</li></ul>\n<p>​ int *p = new int; // p在函数的堆栈区，new在全局共享未使用堆存储区</p>\n<ul><li> <p>delete可以代替free</p> <p>delete p; //释放p指向的内存，p本身没有被删掉</p> <p>delete[] p; //释放数组p指向的内存</p> </li></ul>\n<pre><code class=\"prism language-c++\">/* malloc free realloc 动态内存分配：new用于申请内存块、delete用于释放内存块 T *p = new T; delete p; T *q = new T[5]; delete[] q; */\n// 堆存储区\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main()\n{\n    int *p = new int;\n    *p = 3;\n    cout &lt;&lt; p &lt;&lt; '\\t' &lt;&lt; *p &lt;&lt; endl;\n    delete p;   //内存泄漏，释放p指向内存\n\n    p = new int; //p又指向一个新的内存\n    *p = 5;\n    cout &lt;&lt; p &lt;&lt; '\\t' &lt;&lt; *p &lt;&lt; endl;\n    delete p;\n}\n</code></pre>\n<p><img alt=\"image-20220810223252462\" src=\"image\\f30a4e6f2842915f26d918af3f91da6d.png\"/></p>\n<hr/>\n<h1><a id=\"P8__531\"></a>P8 类和对象</h1>\n<h2><a id=\"1_533\"></a>1.面向对象编程</h2>\n<ul><li>传统的过程式编程：变量（对象）就是一些存储数据的内存块，而过程（函数）对这些数据进行处理。</li></ul>\n<img alt=\"image-20220811124633548\" src=\"image\\image-20220811124633548.png\"/>\n<p>问题：数据不安全、维护困难（一个数据错误，很多函数都可能调用）</p>\n<ul><li>面向对象编程：程序是由不同种类的许多对象相互协助完成的。对象之间通过发送/接收消息来协作完成各种任务。</li></ul>\n<img alt=\"image-20220811124915969\" src=\"image\\image-20220811124915969.png\"/>\n<img alt=\"image-20220811150942421\" src=\"image\\image-20220811150942421.png\"/>\n<h2><a id=\"2_549\"></a>2.对象特性：用户定义类型</h2>\n<ul><li> <p>程序员定义自己的“用户定义类型”，如类类型，来表示各种应用问题中的各种概念</p> </li><li> <p>C++标准库提供了很多实用的标准“用户定义类型”</p>\n<ol><li> <p>cout是一个ostream类的对象（变量），cin是一个istream的对象（变量）</p> </li><li> <p>string是一个表示字符串的类。向一个string对象发送一个size()消息，查询该对象包含的字符数目</p> <pre><code class=\"prism language-c++\">string str = \"Hello world\"; cout &lt;&lt; str.size();\n</code></pre> </li></ol> </li></ul>\n<h2><a id=\"3class_563\"></a>3.定义类(class)</h2>\n<ul><li> <p>用struct或class关键字定义一个类。定义的类就是一个数据类型。</p> <pre><code class=\"prism language-c++\">struct student\n{\n\tstring name;\n\tdouble score;\n}\n</code></pre> </li><li> <pre><code class=\"prism language-c++\">class student{\nprivate:\n\tstring name;\n\tdouble score;\npublic: //接口\n\tvoid print() {cout &lt;&lt; this-&gt;name &lt;&lt; \" \" &lt;&lt; this-&gt;score &lt;&lt; endl;}\n\tstring get_name() { return name; }\n\tdouble get_score() { return score; }\n\tvoid set_name(string n) { name = n; }\n\tvoid set_score(double s) { score = s; }\n};\n</code></pre> </li><li> <p>类类型的变量通常称为对象。如：student stu；（对象就是类的一个实例）</p> </li><li> <p>可以定义类类型的数组，存储一组类对象。如 student stus[3];</p> </li><li> <p>T是一个类类型，则T *就是T指针类型。 T *变量可以指向一个类对象。</p> <p>如 student *p = &amp;stu; (p是一个student *指针变量，可以存放一个student类型的地址)</p> <img alt=\"image-20220811154253900\" src=\"image\\image-20220811154253900.png\"/> </li></ul>\n<img alt=\"image-20220811154329818\" src=\"image\\image-20220811154329818.png\"/>\n<ul><li> <p>类体定义成员函数</p> <pre><code class=\"prism language-c++\">struct student{//体内\n\tstring name;\n\tdouble score;\n\tvoid print(){cout &lt;&lt; name &lt;&lt; \" \" &lt;&lt; score &lt;&lt; endl;}; //函数声明\n}\n</code></pre> <pre><code class=\"prism language-c++\">struct student{//体外\n\tstring name;\n\tdouble score;\n\tvoid print(); //函数声明\n}\nvoid student::print(){ //函数的实现\n\tcout &lt;&lt; name &lt;&lt; \" \" &lt;&lt; score &lt;&lt; endl;\n}\n</code></pre> <p>注意：C语言中struct不能定义函数成员，而C++中可以，不过为了区分建议用class，且class有封装特性，自行决定成员公开还是私有，struct默认所有成员公开！！！</p> </li></ul>\n<h2><a id=\"4_628\"></a>4.学生成绩分析</h2>\n<pre><code class=\"prism language-c++\">/* 输入一组学生成绩(姓名和分数)，输出：平均成绩、最高分和最低分。 当然，也要能输出所有学生信息 */\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct student\n{\n    string name;\n    double score;\n    void print();\n};\n\nvoid student::print()\n{\n    cout &lt;&lt; name &lt;&lt; \" \" &lt;&lt; score &lt;&lt; endl;\n}\n\nint main()\n{\n    /* student stu; stu.name = \"Li Ping\"; stu.score = 78.5; stu.print(); */\n    vector&lt;student&gt; students; //动态类数组\n\n    while (1)\n    {\n        student stu;\n        cout &lt;&lt; \"请输入姓名 分数:\\n\";\n        cin &gt;&gt; stu.name &gt;&gt; stu.score;\n        if (stu.score &lt; 0) break;\n        students.push_back(stu);\n    }\n    for (int i = 0; i &lt; students.size(); i++)\n        students[i].print();\n\n    double min = 100, max = 0, average = 0;\n    for (int i = 0; i &lt; students.size(); i++)\n    {\n        if (students[i].score &lt; min) min = students[i].score;\n        if (students[i].score &gt; max) max = students[i].score;\n        average += students[i].score;\n    }\n    average /= students.size();\n    cout &lt;&lt; \"平均分、最高分、最低分：\"\n         &lt;&lt; average &lt;&lt; \" \" &lt;&lt; max &lt;&lt; \" \" &lt;&lt; min &lt;&lt; endl;\n}\n\n</code></pre>\n<img alt=\"image-20220811160939076\" src=\"image\\image-20220811160939076.png\"/>\n<hr/>\n<hr/>\n<h1><a id=\"P9__687\"></a>P9 访问控制、基础函数⭐⭐</h1>\n<h2><a id=\"1this_689\"></a>1.this指针</h2>\n<pre><code class=\"prism language-c++\">struct student{//体内\n\tstring name;\n\tdouble score;\n\tvoid print(){cout &lt;&lt; name &lt;&lt; \" \" &lt;&lt; score &lt;&lt; endl;}; //函数声明\n}\n</code></pre>\n<p>在类里面定义的成员函数，实际上编译器会自动转化为外部函数，并带this指针</p>\n<pre><code class=\"prism language-c++\">struct student{\n\tstring name;\n\tdouble score;\n    //void print(){cout &lt;&lt; name &lt;&lt; \" \" &lt;&lt; score &lt;&lt; endl;}; //函数声明\n}\nvoid print(student *this){//函数声明\n\tcout &lt;&lt; this-&gt;name &lt;&lt; \" \" &lt;&lt; this-&gt;score &lt;&lt; endl;\n}; \nint main(){\n    student stu;\n    stu.name = \"LI\";\n    stu.score = 88;\n    stu.print(); // print(&amp;stu) 会转化为指针参数\n}\n</code></pre>\n<h2><a id=\"2_720\"></a>2.访问控制（封装）</h2>\n<p>private:私有的，只能通过类体内访问</p>\n<p>public:公开的，可以在类体外访问</p>\n<p>protected：受保护的，只能在类体内访问或在体外通过成员函数访问</p>\n<pre><code class=\"prism language-c++\">/* struct和class区别： struct里的成员默认是public(公开的) class里的成员默认是private(私有的) */\n#include &lt;iostream&gt; \n#include &lt;string&gt; \nusing namespace std;\n\nclass student{\npublic: //接口\n\tvoid print() {cout &lt;&lt; this-&gt;name &lt;&lt; \" \" &lt;&lt; this-&gt;score &lt;&lt; endl;}\n\tstring get_name() { return name; }\n\tdouble get_score() { return score; }\n\tvoid set_name(string n) { name = n; }\n\tvoid set_score(double s) { score = s; }\nprivate:\n\tstring name;\n\tdouble score;\nprotected：\n    string lover；\n};\n\nint main() {\n\tstudent stu;\n\tstu.set_name(\"Li Ping\");\n\tstu.set_score(78.5);\n\tstu.print();   // print(&amp;stu);\n\tcout &lt;&lt; stu.get_name() &lt;&lt; \" \" &lt;&lt; stu.get_score() &lt;&lt; endl;\n}\n</code></pre>\n<h2><a id=\"3_759\"></a>3.构造函数</h2>\n<ul><li> <p>C++在创建一个类对象的时候，会自动调用被称为“构造函数”的成员函数</p> </li><li> <p>如果没有定义构造函数，那么C++会自动生成一个构造函数：类名函数，且没有返回、没有形参，函数体里什么也不做</p> <pre><code class=\"prism language-c++\">class student\n{\n    string name;\n    double score;\npublic:\n    student(string n, double s)：name(n),score(s)//用列表初始化\n    { \n        cout &lt;&lt; \"构造函数\\n\";\n    }\n}\n\n/*等价于*/\n    \nclass student\n{\n    string name;\n    double score;\npublic:\n    student(string n, double s)：\n    { \n        name = n;\n        score = s;\n        cout &lt;&lt; \"构造函数\\n\";\n    }\n}\n</code></pre> </li></ul>\n<pre><code class=\"prism language-c++\">/* 构造函数： 函数名和类名相同且无返回类型的成员函数。 */\n#include &lt;iostream&gt;\n#include &lt;string&gt;\nusing namespace std;\n\nclass student\n{\n    string name;\n    double score;\npublic:\n    student(string n, double s)\n    { //不是默认构造函数，重载\n        name = n;\n        score = s;\n        cout &lt;&lt; \"构造函数\\n\";\n    }\n   \n    student()\n    {\n        cout &lt;&lt; \"构造函数\" &lt;&lt; endl;\n    }\n\n    void print()\n    {\n        cout &lt;&lt; this-&gt;name &lt;&lt; \" \" &lt;&lt; this-&gt;score &lt;&lt; endl;\n    }\n};\n\nint main()\n{\n    student stu(\"LiPing\", 80.5); //在创建一个类对象时会自动调用称为“构造函数”的成员函数\n    stu.print();\n    student students[3];\n}\n</code></pre>\n<p><img alt=\"image-20220812204708388\" src=\"image\\057a154f9ecb04992271cecb1bf0a68c.png\"/></p>\n<h2><a id=\"4_834\"></a>4.拷贝构造函数</h2>\n<ul><li> <p>当我们定义一个类的新对象等于一个旧对象时，系统默认调用的是硬拷贝构造函数，即两个对象共用一个内存。</p> <pre><code class=\"prism language-c++\">class String{\n\tchar *data;\n\tint n;\npublic:\n\tString(const String &amp;s){//系统默认硬拷贝构造函数\n\t\tdata = s.data;\n\t\tn = s.n;\n\t}\n    String(const char *s = 0) //重载构造函数\n    {\n        if (s == 0)\n        {\n            data = 0;\n            n = 0;\n            return;\n        }\n        const char *p = s;\n        while (*p) p++;\n        n = p - s;\n        data = new char[n + 1];\n        for (int i = 0; i &lt;= n; i++)\n            data[i] = s[i];\n    }\n}\n</code></pre> </li><li> <p>但实际上我们希望定义的新对象拥有一块单独的内存，因此，需要重构 拷贝构造函数</p> </li></ul>\n<pre><code class=\"prism language-c++\">class String{\n\tchar *data;\n\tint n;\npublic:\n\tString(const String &amp;s){//重载拷贝构造函数-&gt;软拷贝\n\t\tdata = new char[s.n+1]; //开辟新内存\n\t\tn = s.n;\n\t\tfor (int i = 0; i &lt;= n; i++)\n            data[i] = s.data[i];\n\t}\n    String(const char *s = 0) //重载构造函数\n    {\n    }\n}\n</code></pre>\n<p>例子：</p>\n<pre><code class=\"prism language-c++\">#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass String\n{\n    char *data; //C风格的字符串\n    int n;\n\npublic:\n    String(const String &amp;s)\n    {//重载拷贝构造函数\n        data = new char[s.n + 1]; //申请新的内存\n        n = s.n;\n        for (int i = 0; i &lt;= n; i++)\n            data[i] = s.data[i];\n    }\n\n    String(const char *s = 0)\n    {//重载构造函数\n        if (s == 0)\n        {\n            data = 0;\n            n = 0;\n            return;\n        }\n        const char *p = s;\n        while (*p) p++;\n        n = p - s;\n        data = new char[n + 1];\n        for (int i = 0; i &lt;= n; i++)\n            data[i] = s[i];\n    }\n\n    int size()\n    { return n; }\n\n    char operator[](int i) const //const对象专用的下标重载\n    {\n        if (i &lt; 0 || i &gt;= n) throw \"下标非法\";\n        return data[i];\n    }\n\n    char &amp;operator[](int i)\n    {\n        if (i &lt; 0 || i &gt;= n) throw \"下标非法\";\n        return data[i];\n    }\n\n    friend ostream &amp;operator&lt;&lt;(ostream &amp;o, String s);//这里也调用了拷贝构造函数\n};\n\nostream &amp;operator&lt;&lt;(ostream &amp;o, String s)\n{\n    for (int i = 0; i &lt; s.size(); i++)\n        cout &lt;&lt; s[i];\n    return o;\n}\n\nint main()\n{\n    String str, str2(\"hello world\");//注意str分配的内存是0，str不能直接使用\n    cout &lt;&lt; str2 &lt;&lt; endl;\n    str2[1] = 'E';\n    cout &lt;&lt; str2 &lt;&lt; endl;\n    String const str3 = str2; //重载了拷贝构造函数，str3是单独内存\n    str2[0] = 'H';\n    cout &lt;&lt; \"str2: \" &lt;&lt; str2 &lt;&lt; endl;\n    cout &lt;&lt; \"str3: \" &lt;&lt; str3 &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>\n<p><img alt=\"image-20220813232515381\" src=\"image\\6b3704eab044884e3e6486c9b6d0cd37.png\"/></p>\n<h2><a id=\"5_966\"></a>5.友元函数</h2>\n<p>外部函数想要调用类的成员时，可以在类中声明该函数为友元函数。</p>\n<pre><code class=\"prism language-c++\">/*友元函数，允许外部函数访问类内部成员*/\nclass  student\n{\n\tstring name;\n\tdouble score;\npublic:\n\tstudent(string n, double s)\n\t{\n\t\tname = n; score = s;\n\t}\n\tfriend ostream&amp; operator&lt;&lt;(ostream &amp;out, student s);//友元函数\n}\n\nostream &amp;operator&lt;&lt;(ostream &amp;out, student s)\n{\n     cout &lt;&lt; s.name &lt;&lt; \" \"&lt;&lt; s.score &lt;&lt; endl;\n     return o;\n}\n\n</code></pre>\n<h2><a id=\"6_994\"></a>6.析构函数</h2>\n<ul><li>很多时候构造函数内申请动态内存，如果不及时释放掉，可能会造成内存泄漏的灾难，因此要有析构函数释放不用的内存</li><li>析构函数由 ~类名 构成，没有形参列表，也没有返回，后定义的先释放（堆栈类型）。</li><li>析构函数一般要搭配拷贝构造函数使用，否则，系统默认拷贝会让两个对象共用一块内存，而析构函数会释放两次内存，造成错误</li></ul>\n<pre><code class=\"prism language-c++\">class String {\n\tchar *data; //C风格的字符串\n\tint n;\npublic:\n\t~String() { //重载析构函数\n\t\tcout &lt;&lt;n&lt;&lt; \" 析构函数!\\n\";\n\t\tif(data)\n\t\t\tdelete[] data;\n\t}\n\tString(const String &amp;s) { //重载拷贝构造函数\n\t\tcout &lt;&lt; \"拷贝构造函数!\\n\";\t\n\t\tdata = new char[s.n + 1];\t\t\n\t\tn = s.n;\t\t\n\t\tfor (int i = 0; i &lt; n; i++)\n\t\t\tdata[i] = s.data[i];\n\t\tdata[n] = '\\0';\n\t}\n\tString(const char *s=0) { //构造函数\n\t}\n</code></pre>\n<h2><a id=\"7const_1032\"></a>7.const常函数</h2>\n<ul><li> <p>基础，修饰变量</p> </li><li> <pre><code class=\"prism language-c++\">const int a=10;//a不可改\n\nconst int* a = &amp;b://整型不可修改，但指针指向可以修改，*a不可改，a可改\n\nint *const a = &amp;b；//整型可修改，指针不可修改，*a可改，a不可改\n \nconst int *const p//二者都不可以改\n    \nvoid fun(const int i){}//i不能被修改\n</code></pre> </li><li> <p>进阶，const在类函数中的作用</p> <p>1.const修饰的函数，不能修改类中的成员变量，这是const修饰函数的基本作用</p> <p>2.未重载时，非const对象和const对象都能调用这个函数</p> <p>3.重载时， const对象调用const修饰的重载函数；非const对象调用非const函数</p> <pre><code class=\"prism language-c++\">class A\n{\npublic:\n  void f(int i){......} //一个函数\n  void f(int i) const {......} //上一个函数的重载\n};\n</code></pre> <pre><code class=\"prism language-c++\">#include &lt;iostream&gt;\n#include &lt;string&gt;\nusing namespace std;\n\nclass Test\n{\npublic:\n    Test();\n    ~Test();\n    int num;\n    int fun(int b);\n    int fun(int b) const;\n    int gun(int b) const;\n};\n\nTest::Test()\n{\n    cout &lt;&lt; \"Test()\" &lt;&lt; endl;\n}\nTest::~Test()\n{\n}\n\nint Test::fun(int b)\n{\n    cout &lt;&lt; \" int fun(int b);\" &lt;&lt; endl;\n    num = 2;\n    return 0;\n}\n\nint Test::fun(int b) const\n{\n    cout &lt;&lt; \" int fun(int b) const;\" &lt;&lt; endl;\n    return 0;\n}\n\nint Test::gun(int b) const\n{\n    cout &lt;&lt; \" int gun(int b) const;\" &lt;&lt; endl;\n    return 0;\n}\n\nint main()\n{\n    Test test;\n    const Test testConst;\n\n    test.fun(3); //非const变量调用非const函数\n    testConst.fun(3); //const变量调用const函数\n    test.gun(3); //非const变量也可以调用const函数\n\n    return 0;\n}\n</code></pre> </li></ul>\n<hr/>\n<hr/>\n<h1><a id=\"P10__1129\"></a>P10 运算符重载⭐</h1>\n<p>operator</p>\n<h2><a id=\"1_1133\"></a>1.流运算符重载</h2>\n<ul><li> <p>结合P4 函数重载 学习</p> </li><li> <p>c++中允许对运算符进行重载，只要他们的形参列表不一样</p> </li></ul>\n<pre><code class=\"prism language-c++\">ostream&amp; operator &lt;&lt; (ostream &amp;out, student s)//重载输出流\n{\n    cout &lt;&lt; s.name &lt;&lt; \" \"&lt;&lt; s.score &lt;&lt; endl;\n\treturn out;//引用，返回自身&amp;,不加返回的是一个复制值\n}\n\nistream&amp; operator&gt;&gt;(istream &amp;in, student &amp;s) //重载输入流，注意是引用s\n{\n\tin &gt;&gt; s.name &gt;&gt; s.score;\n\treturn in;\n}\n</code></pre>\n<h2><a id=\"2_1153\"></a>2.下标运算符</h2>\n<ul><li>如果想在类中使用下标运算符，必须在成员里定义operator[]</li></ul>\n<pre><code class=\"prism language-c++\">class Point{\n\tdouble x, y;\npublic:\t\n\tdouble operator[](int i) const{ //const函数\n  \n\t\tif (i == 0) return x;\n\t\telse if (i == 1) return y;\n\t\telse throw \"下标非法!\"; //抛出异常\n\t}\n\tdouble&amp; operator[](int i) {\n\t\tif (i == 0) return x;\n\t\telse if (i == 1) return y;\n\t\telse throw \"下标非法!\"; //抛出异常  \n\t}\n    \n\tPoint(double x_,double y_) {\n\t\tx = x_; y = y_;\n\t}\n\n\t//友元函数\n\tfriend ostream &amp; operator&lt;&lt;(ostream &amp;o, Point p);\n\tfriend istream &amp; operator&gt;&gt;(istream &amp;i, Point &amp;p);\n};\n</code></pre>\n<h2><a id=\"3_1183\"></a>3.加法运算符</h2>\n<p>既可以定义在类体外，也可以定义在类体内，注意两种写法不同</p>\n<pre><code class=\"prism language-c++\">//类体内\nclass student{\npublic:\n\tPoint operator+(const Point q) {\n\t\treturn Point(this-&gt;x + q[0], this-&gt;y + q[1]);\n\t}\n}\n\n//类体外\nPoint operator+(const Point p,const Point q) { return Point(p[0] + q[0], p[1] + q[1]); \n</code></pre>\n<p>例子：</p>\n<pre><code class=\"prism language-c++\">#include &lt;iostream&gt; \n#include &lt;string&gt; \nusing namespace std;\n\nclass Point{\n\tdouble x, y;\npublic:\t\n\tdouble operator[](int i) const{ //const函数\n  \n\t\tif (i == 0) return x;\n\t\telse if (i == 1) return y;\n\t\telse throw \"下标非法!\"; //抛出异常\n\t}\n\tdouble&amp; operator[](int i) {\n\t\tif (i == 0) return x;\n\t\telse if (i == 1) return y;\n\t\telse throw \"下标非法!\"; //抛出异常\n    \n\t}\n    \n\tPoint(double x_,double y_) {\n\t\tx = x_; y = y_;\n\t}\n\tPoint operator+(const Point q) {\n\t\treturn Point(this-&gt;x+q[0],this-&gt;y + q[1]);\n\t}\n\n\t//友元函数\n\tfriend ostream &amp; operator&lt;&lt;(ostream &amp;o, Point p);\n\tfriend istream &amp; operator&gt;&gt;(istream &amp;i, Point &amp;p);\n};\n\nostream &amp; operator&lt;&lt;(ostream &amp;o, Point p) {\n\to &lt;&lt;p.x &lt;&lt; \" \" &lt;&lt; p.y&lt;&lt; endl;\n\treturn o;\n}\nistream &amp; operator&gt;&gt;(istream &amp;i, Point &amp;p) {\n\ti &gt;&gt; p.x &gt;&gt; p.y;\n\treturn i;\n}\n/* Point operator+(const Point p,const Point q) { return Point(p[0] + q[0], p[1] + q[1]); } */\n\nint main() {\n\tPoint p(3.5, 4.8),q(2.0,3.0);\t\n  \n// cin &gt;&gt; p;\n\tcout &lt;&lt; p;\n\tcout &lt;&lt; p[0] &lt;&lt; \"-\" &lt;&lt; p[1] &lt;&lt; endl; //p.operator[](0)\n  \n\tp[0] = 3.45; p[1] = 5.67;\n\tcout &lt;&lt; \"p: \"&lt;&lt;p&lt;&lt;\"q: \"&lt;&lt;q;\t\n\tPoint s = p + q; //p.operator+(q) vs operator+(p,q)\n\tcout &lt;&lt; s;\n}\n</code></pre>\n<p><img alt=\"image-20220812224256428\" src=\"image\\2fbf6e8e9ceed5ed8624f363bfdcfcc0.png\"/></p>\n<hr/>\n<hr/>\n<h1><a id=\"P11__1265\"></a>P11 类模板</h1>\n<ul><li> <p>类似于函数模板，类模板不是类，而是产生类的模板，可以让类代码复用</p> </li><li> <pre><code class=\"prism language-c++\">template&lt;typename T&gt; //创建类模板\nclass Vector {\n\tT *data;\n\tint capacity;\n\tint n;\npublic:\n\tVector(int cap=3) {\n\t\tdata = new T[cap];//开辟的是3倍类型空间\n\t\tif (data == 0) {\n\t\t\tcap = 0; n = 0;\n\t\t\treturn;\n\t\t}\n\t\tcapacity = cap;\n\t\tn = 0;\n\t}\n\tvoid push_back(T e) {\n\t\tif (n == capacity) {//空间已经满\n\t\t\tcout &lt;&lt; \"增加容量！\\n\";\n\t\t\tT *p = new T[2 * capacity];\n\t\t\tif (p) {\n\t\t\t\tfor (int i = 0; i &lt; n; i++)\n\t\t\t\t\tp[i] = data[i];\n\t\t\t\tdelete[] data;\n\t\t\t\tdata = p;\n\t\t\t\tcapacity = 2*capacity;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tdata[n] = e;\n\t\tn++;\n\t}\n\tT operator[](int i) const{\n\t\tif (i &lt; 0 || i &gt;= n) throw \"下标非法!\";\n\t\treturn data[i];\t\t\n\t}\t\n\tint size() {\n\t\treturn n;\n\t}\n};\n\nint main() {\t\n\tVector&lt;int&gt; v; //可以定义任意类型变量\n\tv.push_back(3);\n\tv.push_back(4);\n\tv.push_back(5);\n\tv.push_back(6);\n\tv.push_back(7);\n\tfor (int i = 0; i &lt; v.size(); i++)\n\t\tcout &lt;&lt; v[i] &lt;&lt; '\\t';\n\tcout &lt;&lt; endl;\n}\n\n</code></pre> </li><li> <p>也可以使用系统自带的vector生成模板</p> <pre><code class=\"prism language-c++\">#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nclass student\n{\n    string name;\n    float score;\npublic:\n    student(string n = \"no\", float s = 0)\n    {\n        name = n;\n        score = s;\n    }\n\n    friend ostream &amp;operator&lt;&lt;(ostream &amp;o, student s);\n};\n\nostream &amp;operator&lt;&lt;(ostream &amp;o, student s)\n{\n    cout &lt;&lt; s.name &lt;&lt; \",\" &lt;&lt; s.score &lt;&lt; endl;\n    return o;\n}\n\n\nint main()\n{\n    vector&lt;student&gt; v;//生成student类型的对象（向量形式、可自由生长）\n    v.push_back(student(\"li\", 60));\n    v.push_back(student(\"wang\", 70));\n    v.push_back(student(\"zhao\", 80));\n    v.push_back(student(\"cen\", 90));\n\n    for (int i = 0; i &lt; v.size(); i++)\n        cout &lt;&lt; v[i];\n    cout &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre> <p><img alt=\"image-20220814154941638\" src=\"image\\c59a7064382d312136cbb0769847ffa9.png\"/></p> </li></ul>\n<hr/>\n<hr/>\n<h1><a id=\"P12__1384\"></a>P12 类的继承</h1>\n<h2><a id=\"1C__1386\"></a>1.C++ 继承</h2>\n<p>面向对象程序设计中最重要的一个概念是继承。继承允许我们依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行效率的效果。</p>\n<p>当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。</p>\n<p>这个已有的类称为<strong>基类</strong>，新建的类称为<strong>派生类</strong>。</p>\n<p>继承代表了 <strong>is a</strong> 关系。例如，哺乳动物是动物，狗是哺乳动物，因此，狗是动物，等等。</p>\n<p><img alt=\"img\" src=\"image\\22800d9cb7e64bf85e8294e575e17ae7.png\"/></p>\n<p>当一个类派生自基类，该基类可以被继承为 <strong>public、protected</strong> 或 <strong>private</strong> 几种类型。继承类型是通过上面讲解的访问修饰符 access-specifier 来指定的。</p>\n<p>我们几乎不使用 <strong>protected</strong> 或 <strong>private</strong> 继承，通常使用 <strong>public</strong> 继承。当使用不同类型的继承时，遵循以下几个规则：</p>\n<ul><li> <p><strong>公有继承（public）：<strong>当一个类派生自</strong>公有</strong>基类时，基类的<strong>公有</strong>成员也是派生类的<strong>公有</strong>成员，基类的<strong>保护</strong>成员也是派生类的<strong>保护</strong>成员，基类的<strong>私有</strong>成员不能直接被派生类访问，但是可以通过调用基类的<strong>公有</strong>和<strong>保护</strong>成员来访问。</p> </li><li> <p><strong>保护继承（protected）：</strong> 当一个类派生自<strong>保护</strong>基类时，基类的<strong>公有</strong>和<strong>保护</strong>成员将成为派生类的<strong>保护</strong>成员。</p> </li><li> <p><strong>私有继承（private）：<strong>当一个类派生自</strong>私有</strong>基类时，基类的<strong>公有</strong>和<strong>保护</strong>成员将成为派生类的<strong>私有</strong>成员。</p>\n<table><thead><tr><th align=\"left\">访问</th><th align=\"left\">public</th><th align=\"left\">protected</th><th align=\"left\">private</th></tr></thead><tbody><tr><td align=\"left\">同一个类</td><td align=\"left\">yes</td><td align=\"left\">yes</td><td align=\"left\">yes</td></tr><tr><td align=\"left\">派生类</td><td align=\"left\">yes</td><td align=\"left\">yes</td><td align=\"left\">no</td></tr><tr><td align=\"left\">外部的类</td><td align=\"left\">yes</td><td align=\"left\">no</td><td align=\"left\">no</td></tr></tbody></table><p>一个派生类继承了所有的基类方法，但下列情况除外：</p>\n<ul><li>基类的构造函数、析构函数和拷贝构造函数。</li><li>基类的重载运算符。</li><li>基类的友元函数。</li><li></li></ul> </li></ul>\n<h2><a id=\"2_1423\"></a>2.单继承</h2>\n<pre><code class=\"prism language-c++\">class &lt;派生类名&gt;:&lt;继承方式1&gt;&lt;基类名1&gt;\n{\n\t&lt;派生类类体&gt;\n};\n</code></pre>\n<p>例子：</p>\n<pre><code class=\"prism language-c++\">#include &lt;iostream&gt;\n \nusing namespace std;\n \n// 基类\nclass Shape \n{\n   public:\n      void setWidth(int w)\n      {\n         width = w;\n      }\n      void setHeight(int h)\n      {\n         height = h;\n      }\n   protected:\n      int width;\n      int height;\n};\n \n// 派生类\nclass Rectangle: public Shape\n{\n   public:\n      int getArea()\n      { \n         return (width * height); \n      }\n};\n \nint main(void)\n{\n   Rectangle Rect;\n \n   Rect.setWidth(5);//通过成员函数访问受保护变量\n   Rect.setHeight(7);\n \n   // 输出对象的面积\n   cout &lt;&lt; \"Total area: \" &lt;&lt; Rect.getArea() &lt;&lt; endl;\n\n   return 0;\n}\n</code></pre>\n<p>结果：Total area: 35</p>\n<h2><a id=\"3_1484\"></a>3.多继承</h2>\n<p>多继承即一个子类可以有多个父类，它继承了多个父类的特性。</p>\n<p>C++ 类可以从多个类继承成员，语法如下：</p>\n<pre><code class=\"prism language-c++\">class &lt;派生类名&gt;:&lt;继承方式1&gt;&lt;基类名1&gt;,&lt;继承方式2&gt;&lt;基类名2&gt;,…\n{\n&lt;派生类类体&gt;\n};\n</code></pre>\n<p>其中，访问修饰符继承方式是 <strong>public、protected</strong> 或 <strong>private</strong> 其中的一个，用来修饰每个基类，各个基类之间用逗号分隔，如上所示。现在让我们一起看看下面的实例：</p>\n<pre><code class=\"prism language-c++\">#include &lt;iostream&gt;\n \nusing namespace std;\n \n// 基类 Shape\nclass Shape \n{\n   public:\n      void setWidth(int w)\n      {\n         width = w;\n      }\n      void setHeight(int h)\n      {\n         height = h;\n      }\n   protected:\n      int width;\n      int height;\n};\n \n// 基类 PaintCost\nclass PaintCost \n{\n   public:\n      int getCost(int area)\n      {\n         return area * 70;\n      }\n};\n \n// 派生类\nclass Rectangle: public Shape, public PaintCost\n{\n   public:\n      int getArea()\n      { \n         return (width * height); \n      }\n};\n \nint main(void)\n{\n   Rectangle Rect;\n   int area;\n \n   Rect.setWidth(5);\n   Rect.setHeight(7);\n \n   area = Rect.getArea();\n   \n   // 输出对象的面积\n   cout &lt;&lt; \"Total area: \" &lt;&lt; Rect.getArea() &lt;&lt; endl;\n \n   // 输出总花费\n   cout &lt;&lt; \"Total paint cost: $\" &lt;&lt; Rect.getCost(area) &lt;&lt; endl;\n \n   return 0;\n}\n</code></pre>\n<p>结果：</p>\n<pre><code class=\"prism language-c++\">Total area: 35\nTotal paint cost: $2450\n</code></pre>\n<hr/>\n<hr/>\n<h1><a id=\"P13__1576\"></a>P13 类的多态</h1>\n<ul><li>如果说，继承是子类使用父类的代码，那么多态就是父类使用子类的代码。</li></ul>\n<h2><a id=\"1_1580\"></a>1.虚函数</h2>\n<p><strong>虚函数</strong> 是在基类中使用关键字 <strong>virtual</strong> 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。</p>\n<p>我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为<strong>动态链接</strong>，或<strong>后期绑定</strong>。</p>\n<pre><code class=\"prism language-c++\">class Shape {\n   protected:\n      int width, height;\n   public:\n      Shape( int a=0, int b=0)\n      {\n         width = a;\n         height = b;\n      }\n      virtual int area()//虚函数\n      {\n         cout &lt;&lt; \"Parent class area :\" &lt;&lt;endl;\n         return 0;\n      }\n};\n</code></pre>\n<h2><a id=\"2_1606\"></a>2.纯虚函数</h2>\n<p>您可能想要在基类中定义虚函数，以便在派生类中重新定义该函数更好地适用于对象，但是您在基类中又不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数。</p>\n<p>我们可以把基类中的虚函数 area() 改写如下：</p>\n<pre><code class=\"prism language-c++\">class Shape {\n   protected:\n      int width, height;\n   public:\n      Shape( int a=0, int b=0)\n      {\n         width = a;\n         height = b;\n      }\n      // pure virtual function\n      virtual int area() = 0;\n};\n</code></pre>\n<p>= 0 告诉编译器，函数没有主体，上面的虚函数是<strong>纯虚函数</strong>。</p>\n<h2><a id=\"3_1629\"></a>3.多态</h2>\n<p><strong>多态</strong>按字面的意思就是多种形态。当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。</p>\n<p>C++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。</p>\n<p>例子：</p>\n<pre><code class=\"prism language-c++\">#include &lt;iostream&gt; \nusing namespace std;\n \nclass Shape {\n   protected://受保护的，继承的类，只有在成员函数中才能访问\n      int width, height;\n   public:\n      Shape( int a=0, int b=0)\n      {\n         width = a;\n         height = b;\n      }\n      virtual int area() //虚函数，父类指针访问链接之类的接口\n      {\n         cout &lt;&lt; \"Parent class area :\" &lt;&lt;endl;\n         return 0;\n      }\n};\nclass Rectangle: public Shape{//继承父类\n   public:\n      Rectangle( int a=0, int b=0):Shape(a, b) { }//使用父类的构造函数\n      int area () //重载父类成员函数，注意此时父类是虚函数，后面父类对象指针可调用该函数\n      { \n         cout &lt;&lt; \"Rectangle class area :\" &lt;&lt; width * height &lt;&lt; endl;\n         return (width * height); \n      }\n};\nclass Triangle: public Shape{\n   public:\n      Triangle( int a=0, int b=0):Shape(a, b) { }\n      int area ()\n      { \n         cout &lt;&lt; \"Triangle class area :\" &lt;&lt; width * height / 2 &lt;&lt; endl;\n         return (width * height / 2); \n      }\n};\n// 程序的主函数\nint main( )\n{\n   Shape *shape;\n   Rectangle rec(10,7);\n   Triangle  tri(10,5);\n \n   // 存储矩形的地址\n   shape = &amp;rec;\n   // 调用矩形的求面积函数 area\n   shape-&gt;area();\n \n   // 存储三角形的地址\n   shape = &amp;tri;\n   // 调用三角形的求面积函数 area\n   shape-&gt;area();\n   \n   return 0;\n}\n</code></pre>\n<p><img alt=\"image-20220815213132913\" src=\"image\\01454886146fbb262add6b2ecbbf48ff.png\"/></p>\n<h1><a id=\"_1697\"></a>后记</h1>\n<p>本文主要参考了：<br/> hw-dong老师的博客：https://hwdong.net/<br/> 菜鸟C++教程：https://m.runoob.com/cplusplus/<br/> cppreference: https://zh.cppreference.com/w/cpp</p>\n<p>谢谢，如果对你有帮助，记得点个赞噢</p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}