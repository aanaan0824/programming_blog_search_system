{"blogid": "123752140", "writerAge": "码龄5年", "writerBlogNum": "8", "writerCollect": "12", "writerComment": "3", "writerFan": "10", "writerGrade": "2级", "writerIntegral": "152", "writerName": "Raymond-Shen", "writerProfileAdress": "writer_image\\profile_123752140.jpg", "writerRankTotal": "88579", "writerRankWeekly": "243259", "writerThumb": "7", "writerVisitNum": "18837", "blog_read_count": "815", "blog_time": "已于 2022-07-26 22:50:54 修改", "blog_title": "Rust企业落地探索", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h2>前言</h2>\n<p>最近我在微博转发了亚马逊对Rust和Go语言的对比。<a class=\"link-info has-card\" href=\"https://weibo.com/2150275531/LlkxkvTrl\" title=\"亚马逊发文力捧 Rust ，Go 技术负责人：别“拉踩”我们\"><span class=\"link-card-box\"><span class=\"link-title\">亚马逊发文力捧 Rust ，Go 技术负责人：别“拉踩”我们</span><span class=\"link-link\"><img alt=\"\" class=\"link-link-icon\" src=\"image\\icon-default.png\"/>https://weibo.com/2150275531/LlkxkvTrl</span></span></a></p>\n<p>AWS的文章对Rust的推崇溢于言表。引起了业内的震动。再次把cloud native, green programming language 这些问题推到舆论风口。那我们就多关注一下Rust</p>\n<p>Rust学习并不是很容易。如果大家学习过C++的语言特性，并且深入了解C++的标准库<a class=\"link-info\" href=\"https://www.boost.org/doc/libs/1_63_0/libs/smart_ptr/smart_ptr.htm\" title=\"auto pointer\">auto pointer</a>和Boost扩展库里的<a class=\"link-info\" href=\"https://www.boost.org/doc/libs/1_63_0/libs/smart_ptr/smart_ptr.htm\" title=\"smart pointer\">smart pointer</a>的话，我觉得大家会比较容易了解Rust的强类型和内存安全的一些考虑。这部分大家可以比较学习，横向比较确实是一种提高自己的方法。</p>\n<p>但是真正用Rust做一些企业真实的应用。我觉得只是学习语言特性是不足够的。底层库或者程序框架的开发者对语言特性的要求比较高。而我们要跨越谈论语言特性，和其他语言之间做比较的时候。我们还是要通过语言的生态，企业开发的支持来做一些探索。这样，才能真正落地，应用到生产环境里。</p>\n<p>我们探索的脚步不能停止。我将对一些比较重要的问题展开讨论。</p>\n<h2>入门资料</h2>\n<p>在学习Rust的时候，我们再语言入门的时候一定有很多的资料。我可以推荐大家看一些基本的资料。</p>\n<p><a class=\"has-card\" href=\"https://blog.csdn.net/weixin_34174132/article/details/85975606?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164826295516780261980079%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=164826295516780261980079&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-85975606.142%5Ev5%5Epc_search_result_cache,143%5Ev6%5Econtrol&amp;utm_term=rust%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF&amp;spm=1018.2226.3001.4187\" title=\"Rust学习资源和路线_weixin_34174132的博客-CSDN博客\"><span class=\"link-card-box\"><span class=\"link-title\">Rust学习资源和路线_weixin_34174132的博客-CSDN博客</span><span class=\"link-desc\">Rust学习资源和路线来源 https://rust-lang-cn.org/article/23学习资源The Rust Programming Language堪称Rust的\"The Book\"，是目前最权威的Rust系统教程，入门必读。Rust by Example实例化的讲解方法，通过一个个可实际运行的例子去介绍Rust的特性和用法，有的时候，代码是最好的老师。Frequen...</span><span class=\"link-link\"><img alt=\"\" class=\"link-link-icon\" src=\"https://g.csdnimg.cn/static/logo/favicon32.ico\"/>https://blog.csdn.net/weixin_34174132/article/details/85975606?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164826295516780261980079%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=164826295516780261980079&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-85975606.142%5Ev5%5Epc_search_result_cache,143%5Ev6%5Econtrol&amp;utm_term=rust%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF&amp;spm=1018.2226.3001.4187</span></span></a></p>\n<p><a class=\"has-card\" href=\"https://blog.csdn.net/s_lisheng/article/details/105778760?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164826295516780261980079%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=164826295516780261980079&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-5-105778760.142%5Ev5%5Epc_search_result_cache,143%5Ev6%5Econtrol&amp;utm_term=rust%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF&amp;spm=1018.2226.3001.4187\" title=\"Rust学习资料汇总_chirpyli的博客-CSDN博客_rust学习\"><span class=\"link-card-box\"><span class=\"link-title\">Rust学习资料汇总_chirpyli的博客-CSDN博客_rust学习</span><span class=\"link-desc\">列举一些学习Rust的好资料，方便平常学习与查阅。大部分文档在官网Grow with Rust一节都有列出，另一部分是平常学习时涉及到的文档资料。The Rust Programming Language这本书当然是要第一本阅读的了，入门首选。Rust对单元测试的支持是非常友好的，可参考Writing Automated Tests这一章。Rust by Example通过代码示例...</span><span class=\"link-link\"><img alt=\"\" class=\"link-link-icon\" src=\"https://g.csdnimg.cn/static/logo/favicon32.ico\"/>https://blog.csdn.net/s_lisheng/article/details/105778760?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164826295516780261980079%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=164826295516780261980079&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-5-105778760.142%5Ev5%5Epc_search_result_cache,143%5Ev6%5Econtrol&amp;utm_term=rust%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF&amp;spm=1018.2226.3001.4187</span></span></a></p>\n<h2>多线程</h2>\n<p>在官方的教程文档中，我们可以看到multi-thread的用处和如何使用线程池。<a class=\"link-info\" href=\"https://doc.rust-lang.org/book/ch20-02-multithreaded.html\" title=\"官方文档示例\">官方文档示例</a>里给出了跟好的例子。</p>\n<p>当然如果我们需要一个有生产强度的并行库。我们可以使用Rayon, tokio_threadpool等等。</p>\n<h3><strong>Rayon</strong></h3>\n<p><a class=\"has-card\" href=\"https://github.com/rayon-rs/rayon\" title=\"GitHub - rayon-rs/rayon: Rayon: A data parallelism library for Rust\"><span class=\"link-card-box\"><span class=\"link-title\">GitHub - rayon-rs/rayon: Rayon: A data parallelism library for Rust</span><span class=\"link-desc\">Rayon: A data parallelism library for Rust. Contribute to rayon-rs/rayon development by creating an account on GitHub.</span><span class=\"link-link\"><img alt=\"\" class=\"link-link-icon\" src=\"image\\fluidicon.png\"/>https://github.com/rayon-rs/rayon</span></span></a></p>\n<h3>tokio_threadpool</h3>\n<p><a class=\"has-card\" href=\"https://github.com/gatoWololo/tokio-threadpool-0.1.18\" title=\"GitHub - gatoWololo/tokio-threadpool-0.1.18: Modified version of tokio-threadpool for Servo-rr-channel compatibility.\"><span class=\"link-card-box\"><span class=\"link-title\">GitHub - gatoWololo/tokio-threadpool-0.1.18: Modified version of tokio-threadpool for Servo-rr-channel compatibility.</span><span class=\"link-desc\">Modified version of tokio-threadpool for Servo-rr-channel compatibility. - GitHub - gatoWololo/tokio-threadpool-0.1.18: Modified version of tokio-threadpool for Servo-rr-channel compatibility.</span><span class=\"link-link\"><img alt=\"\" class=\"link-link-icon\" src=\"image\\fluidicon.png\"/>https://github.com/gatoWololo/tokio-threadpool-0.1.18</span></span></a></p>\n<h2>异步处理框架</h2>\n<p>Rust里最大名鼎鼎的一部框架就是 <a class=\"link-info\" href=\"https://github.com/tokio-rs/tokio\" title=\"Tokio\">Tokio</a>。这个框架是很多框架的基础。框架本身的文档还是非常的详尽。而且在Github项目代码目录，有非常详细的实例程序。我们可以在 <a class=\"link-info\" href=\"https://github.com/tokio-rs/tokio/tree/master/examples\" title=\"examples\">examples</a> 这个位置找到。我是非常推崇直接通过例子来学习框架。</p>\n<p>对于异步处理框架，我们还是需要仔细了解异步框架的原理。大家可以看一下 <a class=\"link-info\" href=\"https://tokio.rs/tokio/tutorial/async\" title=\"Async in Depth\">Async in Depth</a> 来更深入的了解Async的实现原理。这对异步系统的理解和调优相关的任务会有比较好的帮助。</p>\n<h3>Tonic</h3>\n<p>Tokio 本身提供了一个 gRPC 的实现 <a class=\"link-info\" href=\"https://github.com/hyperium/tonic\" title=\"Tonic\">Tonic</a>。用Tonic开发其实也是比较容易的。我认为gRPC本身的效率还是非常高的。</p>\n<p>我们可以参照这篇文章实现一个基本的三层应用后端。<a class=\"has-card\" href=\"https://dev.to/steadylearner/how-to-use-grpc-with-rust-tonic-and-postgres-database-with-examples-3dl7\" title=\"How to use gRPC with Rust Tonic and Postgres database with examples - DEV Community\"><span class=\"link-card-box\"><span class=\"link-title\">How to use gRPC with Rust Tonic and Postgres database with examples - DEV Community</span><span class=\"link-desc\">In this post, we will learn how to use Rust Tonic gRPC crate and implement CRUD with Postgresql... Tagged with rust, tonic, postgres, grpc.</span><span class=\"link-link\"><img alt=\"\" class=\"link-link-icon\" src=\"https://res.cloudinary.com/practicaldev/image/fetch/s--E8ak4Hr1--/c_limit,f_auto,fl_progressive,q_auto,w_32/https://dev-to.s3.us-east-2.amazonaws.com/favicon.ico\"/>https://dev.to/steadylearner/how-to-use-grpc-with-rust-tonic-and-postgres-database-with-examples-3dl7</span></span></a></p>\n<p>或者使用tonic + sqlx来实现数据库连接也可以。 </p>\n<p><a class=\"has-card\" href=\"https://github.com/rezmuh/todo-tonic-sqlx-refinery-barrel\" title=\"hhttps://github.com/rezmuh/todo-tonic-sqlx-refinery-barrelhttps://github.com/rezmuh/todo-tonic-sqlx-refinery-barrel\"><span class=\"link-card-box\"><span class=\"link-title\">hhttps://github.com/rezmuh/todo-tonic-sqlx-refinery-barrelhttps://github.com/rezmuh/todo-tonic-sqlx-refinery-barrel</span><span class=\"link-link\"><img alt=\"\" class=\"link-link-icon\" src=\"image\\icon-default.png\"/>https://github.com/rezmuh/todo-tonic-sqlx-refinery-barrel</span></span></a>当然Tonic本身的<a class=\"link-info\" href=\"https://github.com/hyperium/tonic/tree/master/examples\" title=\"examples\">examples</a>也可以给大家大的帮助。</p>\n<h3>Tracing</h3>\n<p><a class=\"link-info\" href=\"https://github.com/tokio-rs/tracing\" title=\"Tracing\">Tracing</a>提供了一个比较统一日志体系。他的重要性和java里的log4j一样。所以这也是基本的企业应用的基础件。日志的重要性大家都知道吧？</p>\n<h2>数据库访问</h2>\n<p>数据库的重要性肯定是不言而喻的。Rust的数据库支持有哪些呢？下面这个文章给了我们一个比较全面的介绍。</p>\n<p><a class=\"has-card\" href=\"https://blog.logrocket.com/11-database-drivers-and-orms-for-rust-that-are-ready-for-production/\" title=\"11 database drivers and ORMs for Rust that are ready for production - LogRocket Blog\"><span class=\"link-card-box\"><span class=\"link-title\">11 database drivers and ORMs for Rust that are ready for production - LogRocket Blog</span><span class=\"link-link\"><img alt=\"\" class=\"link-link-icon\" src=\"image\\cropped-cropped-favicon-196x196-32x32.png\"/>https://blog.logrocket.com/11-database-drivers-and-orms-for-rust-that-are-ready-for-production/</span></span></a></p>\n<h2></h2>\n<h3>Diesel</h3>\n<p><a class=\"has-card\" href=\"https://github.com/diesel-rs/diesel\" title=\"GitHub - diesel-rs/diesel: A safe, extensible ORM and Query Builder for Rust\"><span class=\"link-card-box\"><span class=\"link-title\">GitHub - diesel-rs/diesel: A safe, extensible ORM and Query Builder for Rust</span><span class=\"link-desc\">A safe, extensible ORM and Query Builder for Rust. Contribute to diesel-rs/diesel development by creating an account on GitHub.</span><span class=\"link-link\"><img alt=\"\" class=\"link-link-icon\" src=\"image\\fluidicon.png\"/>https://github.com/diesel-rs/diesel</span></span></a></p>\n<h3>SQLX</h3>\n<p>SQLX是本身是一个基于Tokio的异步框架。所以应该基本上可以其他的异步框架进行使用。</p>\n<p><a class=\"has-card\" href=\"https://github.com/launchbadge/sqlx\" title=\"GitHub - launchbadge/sqlx: 🧰 The Rust SQL Toolkit. An async, pure Rust SQL crate featuring compile-time checked queries without a DSL. Supports PostgreSQL, MySQL, SQLite, and MSSQL.\"><span class=\"link-card-box\"><span class=\"link-title\">GitHub - launchbadge/sqlx: 🧰 The Rust SQL Toolkit. An async, pure Rust SQL crate featuring compile-time checked queries without a DSL. Supports PostgreSQL, MySQL, SQLite, and MSSQL.</span><span class=\"link-desc\">🧰 The Rust SQL Toolkit. An async, pure Rust SQL crate featuring compile-time checked queries without a DSL. Supports PostgreSQL, MySQL, SQLite, and MSSQL. - GitHub - launchbadge/sqlx: 🧰 The Rust SQL Toolkit. An async, pure Rust SQL crate featuring compile-time checked queries without a DSL. Supports PostgreSQL, MySQL, SQLite, and MSSQL.</span><span class=\"link-link\"><img alt=\"\" class=\"link-link-icon\" src=\"image\\fluidicon.png\"/>https://github.com/launchbadge/sqlx</span></span></a></p>\n<p>SQLX的好处就是比较纯粹，我们还是需要写SQL来完成工作。但是所有的语法检查，sql准备都在编译期做好了。在执行的时候效率非常高。</p>\n<h3>RBatis</h3>\n<p><a class=\"has-card\" href=\"https://github.com/rbatis/rbatis/\" title=\"GitHub - rbatis/rbatis: Rust High Performance compile-time ORM(RBSON based)\"><span class=\"link-card-box\"><span class=\"link-title\">GitHub - rbatis/rbatis: Rust High Performance compile-time ORM(RBSON based)</span><span class=\"link-desc\">Rust High Performance compile-time ORM(RBSON based) - GitHub - rbatis/rbatis: Rust High Performance compile-time ORM(RBSON based)</span><span class=\"link-link\"><img alt=\"\" class=\"link-link-icon\" src=\"https://github.com/fluidicon.png\"/>https://github.com/rbatis/rbatis/</span></span></a>这个基本上就是一个MyBatis的 Rust版本。具体例子可以看官方的<a class=\"link-info\" href=\"https://github.com/rbatis/rbatis/blob/master/example\" title=\" examples\"> examples</a>。这样的话从 java 转型过来的程序员就非常适应这种数据库访问方式。</p>\n<p>比较有意思的是RBatis的底层就是使用了sqlx，所以相对来说给sqlx添加了一个ORM层。RBatis所有的sql语法检查准备也都是在编译期完成。保持性能方面的优势。</p>\n<p></p>\n<h2>微服务框架</h2>\n<p>现在大多数的后端应用还是在使用无状态的微服务框架，现在这些框架已经基本上比较成熟。所以在本人的gitee里面fork了并且维护了一个国外的实现。</p>\n<p><a class=\"has-card\" href=\"https://gitee.com/raymondshen/kanban\" title=\"kanban: 由于对spring框架和java技术栈约来约笨重。我们在承担不必要的成本。所以该项目开始讨论其他的方案。特别是针对Rest API实现的方案。\"><span class=\"link-card-box\"><span class=\"link-title\">kanban: 由于对spring框架和java技术栈约来约笨重。我们在承担不必要的成本。所以该项目开始讨论其他的方案。特别是针对Rest API实现的方案。</span><span class=\"link-link\"><img alt=\"\" class=\"link-link-icon\" src=\"https://assets.gitee.com/assets/favicon-9007bd527d8a7851c8330e783151df58.ico\"/>https://gitee.com/raymondshen/kanban</span></span></a></p>\n<p>这里面以快捷开发的看板应用为例，演示了如何使用不同的框架。和Rust有关的是如下两种。</p>\n<p>同步框架: Diesel + Rocket</p>\n<ul><li>Directory: <a href=\"https://gitee.com/raymondshen/kanban/blob/main/diesel-rocket\" title=\"diesel-rocket\">diesel-rocket</a></li><li>Nickname: DR</li><li>Connection pool: r2d2</li><li>SQL executor: Diesel</li><li>HTTP routing: Rocket</li><li>Compiled with: Rust v1.53 (Nightly)</li></ul>\n<p>异步框架: sqlx + actix-web</p>\n<ul><li>Directory: <a href=\"https://gitee.com/raymondshen/kanban/blob/main/sqlx-actix-web\" title=\"sqlx-actix-web\">sqlx-actix-web</a></li><li>Nickname: SA</li><li>Connection pool: sqlx</li><li>SQL executor: sqlx</li><li>HTTP Routing: actix-web</li><li>Compiled with: Rust v1.53 (Nightly)</li></ul>\n<p>当然我非常推荐大家仔细阅读一下原作者的说明。</p>\n<p><a class=\"has-card\" href=\"https://github.com/pretzelhammer/rust-blog/blob/master/posts/restful-api-in-sync-and-async-rust.md\" title=\"rust-blog/restful-api-in-sync-and-async-rust.md at master · pretzelhammer/rust-blog · GitHub\"><span class=\"link-card-box\"><span class=\"link-title\">rust-blog/restful-api-in-sync-and-async-rust.md at master · pretzelhammer/rust-blog · GitHub</span><span class=\"link-desc\">Educational blog posts for Rust beginners. Contribute to pretzelhammer/rust-blog development by creating an account on GitHub.</span><span class=\"link-link\"><img alt=\"\" class=\"link-link-icon\" src=\"https://github.com/fluidicon.png\"/>https://github.com/pretzelhammer/rust-blog/blob/master/posts/restful-api-in-sync-and-async-rust.md</span></span></a></p>\n<p>他深入的分析了这些框架之间的异同。得到了一个并不让人惊讶的结论，异步框架吞吐量占有而同步系统延迟占优。</p>\n<p>这里我在sqlx-actix-web的基础上添加了i18n的支持。如果您面临的是国际化的后端应用。不妨可以看一下。</p>\n<p>如果大家希望快速有生产力的话，我建议大家做出一定的选择，直接跳过复杂的Rust语言特性。直接使用框架写后端应用。这样学习的话会表有成果，也能鼓励人不断在实践中进步。这比一下子掉到语言特性的坑里要好多了。</p>\n<p>另一个比较全面的例子是在这里，而且这个例子对数据程序的架构给了一定的示范作用。非常值得学习。</p>\n<p><a class=\"has-card\" href=\"https://github.com/jamesjmeyer210/actix_sqlx_mysql_user_crud\" title=\"GitHub - jamesjmeyer210/actix_sqlx_mysql_user_crud: A user crud written in Rust, designed to connect to a MySQL database with full integration test coverage.\"><span class=\"link-card-box\"><span class=\"link-title\">GitHub - jamesjmeyer210/actix_sqlx_mysql_user_crud: A user crud written in Rust, designed to connect to a MySQL database with full integration test coverage.</span><span class=\"link-desc\">A user crud written in Rust, designed to connect to a MySQL database with full integration test coverage. - GitHub - jamesjmeyer210/actix_sqlx_mysql_user_crud: A user crud written in Rust, designed to connect to a MySQL database with full integration test coverage.</span><span class=\"link-link\"><img alt=\"\" class=\"link-link-icon\" src=\"https://github.com/fluidicon.png\"/>https://github.com/jamesjmeyer210/actix_sqlx_mysql_user_crud</span></span></a></p>\n<p>比较重要的一点，是这个例子对数据库链接进行了多线程的封装。这样避免了之前案例中的问题。请关注下面 AppState 的初始化方法。这里也用了 Arc::new 来创建数据库连接的引用计数。</p>\n<pre><code class=\"language-rust\">use actix_web::{web, App, HttpServer};\nuse sqlx_user_crud::config::Config;\nuse sqlx_user_crud::dao::Database;\nuse sqlx_user_crud::{controller, AppState};\nuse std::sync::{Arc, Mutex};\n\n#[actix_web::main]\nasync fn main() -&gt; std::io::Result&lt;()&gt; {\n    println!(\"=== SQLX User CRUD ===\");\n\n    // Read in the configuration file.\n    // In small projects this can be a local configuration, but in more sophisticated systems, it is\n    // best practice to keep the configuration file on a remote server where it can be retrieved\n    // with an http request.\n    let config_file: &amp;'static str = \"config.json\";\n    let config = Config::from_file(config_file);\n    println!(\"Using configuration file from {0}\", config_file);\n\n    // Connect to the database\n    let db_context = Database::new(&amp;config.get_database_url()).await;\n    println!(\"Connected to database: {0}\", config.get_database_url());\n\n    // Instantiate the app_state. This application state will be cloned for each Actix thread but\n    // the Arc of the DbContext will be reused in each Actix thread.\n    let app_state = web::Data::new(AppState {\n        connections: Mutex::new(0),\n        context: Arc::new(db_context),\n    });\n\n    // Start the web application.\n    // We'll need to transfer ownership of the AppState to the HttpServer via the `move`.\n    // Then we can instantiate our controllers.\n    let app = HttpServer::new(move || {\n        App::new()\n            .app_data(app_state.clone())\n            .configure(controller::init_index_controller)\n            .configure(controller::init_user_controller)\n            .configure(controller::init_group_controller)\n    })\n    .bind(config.get_app_url())?;\n    println!(\"Listening on: {0}\", config.get_app_url());\n\n    app.run().await\n}</code></pre>\n<p>如果大家感兴趣，也可以看一下这个例子里有关 Module, Dao, Controler 的分层考虑。会比较有启发。 在下面研发自动化的时候我们还会在 sql_reverse 这一节进行更详细的说明。</p>\n<h3>RBatis + Actix-web</h3>\n<p>rbatis和Actix-web配合的例子如下：</p>\n<pre><code class=\"language-rust\">#![allow(unused_must_use)]\n#[macro_use]\nextern crate rbatis;\n\nuse actix_web::{web, App, HttpResponse, HttpServer, Responder};\nuse std::sync::Arc;\n\nuse rbatis::crud::CRUD;\nuse rbatis::rbatis::Rbatis;\n\n#[crud_table]\n#[derive(Clone, Debug)]\npub struct BizActivity {\n    pub id: Option&lt;String&gt;,\n    pub name: Option&lt;String&gt;,\n    pub pc_link: Option&lt;String&gt;,\n    pub h5_link: Option&lt;String&gt;,\n    pub pc_banner_img: Option&lt;String&gt;,\n    pub h5_banner_img: Option&lt;String&gt;,\n    pub sort: Option&lt;String&gt;,\n    pub status: Option&lt;i32&gt;,\n    pub remark: Option&lt;String&gt;,\n    pub create_time: Option&lt;rbatis::DateTimeNative&gt;,\n    pub version: Option&lt;i32&gt;,\n    pub delete_flag: Option&lt;i32&gt;,\n}\n\nimpl Default for BizActivity {\n    fn default() -&gt; Self {\n        BizActivity {\n            id: None,\n            name: None,\n            pc_link: None,\n            h5_link: None,\n            pc_banner_img: None,\n            h5_banner_img: None,\n            sort: None,\n            status: None,\n            remark: None,\n            create_time: None,\n            version: None,\n            delete_flag: None,\n        }\n    }\n}\n\nasync fn index(rb: web::Data&lt;Arc&lt;Rbatis&gt;&gt;) -&gt; impl Responder {\n    let v = rb.fetch_list::&lt;BizActivity&gt;().await.unwrap_or_default();\n    HttpResponse::Ok()\n        .insert_header((\"Content-Type\", \"text/json;charset=UTF-8\"))\n        .json(v)\n}\n\n#[tokio::main]\nasync fn main() -&gt; std::io::Result&lt;()&gt; {\n    //log\n    fast_log::init(fast_log::config::Config::new().console());\n    //init rbatis . also you can use  pub static RB:Lazy&lt;Rbatis&gt; = Lazy::new(||Rbatis::new()); replace this\n    log::info!(\"linking database...\");\n    let rb = example::init_sqlite_path(\"\").await;\n    let rb = Arc::new(rb);\n    log::info!(\"linking database successful!\");\n\n    log::info!(\"start on http://127.0.0.1:8080\");\n    //router\n    HttpServer::new(move || {\n        App::new()\n            //add into actix-web data\n            .app_data(web::Data::new(rb.to_owned()))\n            .route(\"/\", web::get().to(index))\n    })\n    .bind((\"127.0.0.1\", 8080))?\n    .run()\n    .await\n}</code></pre>\n<p>这里BizActivity本身也可以通过sql_reverse 自动生成。请查看下面的相应章节。</p>\n<h2>Actor模式</h2>\n<p>Actor模式可以构建比较复杂的CQRS模式的应用。并且完成无锁机制的同步。最典型的框架是Erlang，Akka等虚拟机系统。在Rust语言上实现Actor模式，对我们来讲还是非常有意思的。</p>\n<p>我推荐大家深度关注<a class=\"link-info\" href=\"https://weibo.com/2150275531/LllntA6Cj\" title=\"Actix\">Actix</a>。早在2020年，Rust语言也涌现出很多不同的Actor模式的实现。但是尘归尘，土归土，现在还在积极维护的看起来只有Actix了。如果有其他的服务实现，我觉得大家也可以留言推荐给我。我对此的看法是Actor模式非常适合大型企业后端应用，特别是有状态的应用。而Actix现在也助推actix-web框架，主要还是考虑现在微服务框架入门比较容易。而大型企业应用后端还是JVM的天下。Actix-actor在一定程度上是单机系统，只是考remote特性手工组建集群相对还是对架构师要求太高。但是，这不影响我对Actor模式的热情。还是会介绍一下。</p>\n<h3>有效利用使用多核CPU</h3>\n<p>在 Arbix 的实现离，Arbiter是一个调度单元。为了能够演示多个Arbiter的使用，下面的代码段还是非常有用的。</p>\n<pre><code class=\"language-rust\">extern crate actix;\nuse actix::prelude::*;\n\nstruct Fibonacci(pub u32);\n\n\nstruct SomeActor;\n\nimpl Actor for SomeActor {\n    type Context = Context&lt;Self&gt;;\n}\n\nimpl Message for Fibonacci{\n    type Result = Result&lt;u64, ()&gt;;\n}\n\nimpl Handler&lt;Fibonacci&gt; for SomeActor {\n    type Result = Result&lt;u64, ()&gt;;\n\n    fn handle(&amp;mut self, msg: Fibonacci, context: &amp;mut Self::Context) -&gt; Self::Result {\n        println!(\"working on fib({})\", msg.0);\n    let mut sum=0;\n    if msg.0 == 0 {\n        Err(())\n    } else if msg.0 == 1 {\n        Ok(1)\n    } else {\n\n        for j in 1..1000000 {\n            let mut i = 0;\n            sum = 0;\n            let mut last = 0;\n            let mut curr = 1;\n            while i &lt; msg.0 - 1 {\n                sum = last + curr;\n                last = curr;\n                curr = sum;\n                i += 1;\n            }\n        }\n        Ok(sum)\n    }\n}\n}\n\nfn main() {\nlet sys = System::new();\n\nlet a1 = Arbiter::new();\nlet a2 = Arbiter::new();\nlet a3 = Arbiter::new();\n\nlet execution1 = async {\n    println!(\"exec 1 created\");\n    let sa = SomeActor {}.start();\n    for n in 2..80 {\n        sa.do_send(Fibonacci(n));\n    }\n};\n\nlet execution2 = async {\n    println!(\"exec 2 created\");\n    let sa = SomeActor {}.start();\n    for n in 2..80 {\n        sa.do_send(Fibonacci(n));\n    }\n};\n\nlet execution3 = async {\n    println!(\"exec 3 created\");\n    let sa = SomeActor {}.start();\n    for n in 2..80 {\n        sa.do_send(Fibonacci(n));\n    }\n};\n\n\na1.spawn(execution1);\na2.spawn(execution2);\na3.spawn(execution3);\n\nsys.run();\n}</code></pre>\n<h3>websocket-chat-server</h3>\n<p><a class=\"has-card\" href=\"https://github.com/actix/examples/tree/master/websockets/chat-broker\" title=\"examples/websockets/chat-broker at master · actix/examples · GitHub\"><span class=\"link-card-box\"><span class=\"link-title\">examples/websockets/chat-broker at master · actix/examples · GitHub</span><span class=\"link-desc\">Community showcase and examples of Actix ecosystem usage. - examples/websockets/chat-broker at master · actix/examples</span><span class=\"link-link\"><img alt=\"\" class=\"link-link-icon\" src=\"https://github.com/fluidicon.png\"/>https://github.com/actix/examples/tree/master/websockets/chat-broker</span></span></a>这个例子之所以重要，主要是他是Actix框架位数不多的接近实战的官方示例。而这个例子很好的演示了 WebSocket Session, Actor, Arbiter, SystemService, Supervied之间的配合。堪称难能可贵。这也体现了Artix框架设计的精妙。</p>\n<p>下面是我们节选一下main.rs里的代码。</p>\n<pre><code class=\"language-rust\">use actix_files::{Files, NamedFile};\nuse actix_web::{middleware::Logger, web, App, Error, HttpRequest, HttpServer, Responder};\nuse actix_web_actors::ws;\n\nmod message;\nmod server;\nmod session;\n\nuse session::WsChatSession;\n\nasync fn index() -&gt; impl Responder {\n    NamedFile::open_async(\"./static/index.html\").await.unwrap()\n}\n\nasync fn chat_ws(req: HttpRequest, stream: web::Payload) -&gt; Result&lt;impl Responder, Error&gt; {\n    ws::start(WsChatSession::default(), &amp;req, stream)\n}\n\n#[actix_web::main]\nasync fn main() -&gt; std::io::Result&lt;()&gt; {\n    env_logger::init_from_env(env_logger::Env::new().default_filter_or(\"info\"));\n\n    log::info!(\"starting HTTP server at http://localhost:8080\");\n\n    HttpServer::new(move || {\n        App::new()\n            .service(web::resource(\"/\").to(index))\n            .service(web::resource(\"/ws\").to(chat_ws))\n            .service(Files::new(\"/static\", \"./static\"))\n            .wrap(Logger::default())\n    })\n    .workers(2)\n    .bind((\"127.0.0.1\", 8080))?\n    .run()\n    .await\n}\n</code></pre>\n<p>大家可以注意代码中 workers(2) 这个调用。由于Session本身就是Actor，所以，多少个 worker 也就启动了多少个 Arbiter。</p>\n<p>通过lldb我们可以看到这两个Arbiter的存在。</p>\n<pre><code class=\"language-bash\">chat-broker % lldb ../../target/debug/server \n(lldb) target create \"../../target/debug/server\"\nCurrent executable set to '/Users/raymond/src/rust/examples/target/debug/server' (arm64).\n(lldb) run\nProcess 5532 launched: '/Users/raymond/src/rust/examples/target/debug/server' (arm64)\n[2022-03-27T06:36:51Z INFO  server] starting HTTP server at http://localhost:8080\n[2022-03-27T06:36:51Z INFO  actix_server::builder] Starting 2 workers\n[2022-03-27T06:36:51Z INFO  actix_server::server] Actix runtime found; starting in Actix runtime\nProcess 5532 stopped\n* thread #1, queue = 'com.apple.main-thread', stop reason = signal SIGSTOP\n    frame #0: 0x00000001af84ac40 libsystem_kernel.dylib`kevent + 8\nlibsystem_kernel.dylib`kevent:\n-&gt;  0x1af84ac40 &lt;+8&gt;:  b.lo   0x1af84ac60               ; &lt;+40&gt;\n    0x1af84ac44 &lt;+12&gt;: pacibsp \n    0x1af84ac48 &lt;+16&gt;: stp    x29, x30, [sp, #-0x10]!\n    0x1af84ac4c &lt;+20&gt;: mov    x29, sp\nTarget 0: (server) stopped.\n(lldb) thread list\nProcess 5532 stopped\n* thread #1: tid = 0xfd860a, 0x00000001af84ac40 libsystem_kernel.dylib`kevent + 8, queue = 'com.apple.main-thread', stop reason = signal SIGSTOP\n  thread #2: tid = 0xfd864f, 0x00000001af84ac40 libsystem_kernel.dylib`kevent + 8, name = 'actix-rt|system:0|arbiter:0'\n  thread #3: tid = 0xfd8650, 0x00000001af84ac40 libsystem_kernel.dylib`kevent + 8, name = 'actix-rt|system:0|arbiter:1'\n  thread #4: tid = 0xfd8651, 0x00000001af84ac40 libsystem_kernel.dylib`kevent + 8, name = 'actix-server acceptor'\n(lldb) </code></pre>\n<p>就此，我们看到了一些Actix的一些内部机制。但是最好的学习方法还是源代码。这里不再详述。</p>\n<p>使用websocket-chat-server,进行扩充，控制好线程模型，我们很容易得到一个效率还不错的行情分发系统。这以后我们会尝试，并且和go语言的实现进行对比。 </p>\n<h3>actix-web-prometheus</h3>\n<p><a class=\"has-card\" href=\"https://github.com/atomix-team/actix-web-prometheus\" title=\"GitHub - atomix-team/actix-web-prometheus: Prometheus middleware for actix web\"><span class=\"link-card-box\"><span class=\"link-title\">GitHub - atomix-team/actix-web-prometheus: Prometheus middleware for actix web</span><span class=\"link-desc\">Prometheus middleware for actix web. Contribute to atomix-team/actix-web-prometheus development by creating an account on GitHub.</span><span class=\"link-link\"><img alt=\"\" class=\"link-link-icon\" src=\"https://github.com/fluidicon.png\"/>https://github.com/atomix-team/actix-web-prometheus</span></span></a>这个项目是用了最为流行的 tikv/rust-prometheus进行了针对Actix的适配。很值得尝试。使用方法确实也不困难。本身项目代码也不多，有问题自己动手改吧。哈哈</p>\n<pre><code class=\"language-rust\">use std::collections::HashMap;\nuse actix_web::{web, App, HttpResponse, HttpServer};\nuse actix_web_prometheus::{PrometheusMetrics, PrometheusMetricsBuilder};\nfn health() -&gt; HttpResponse {\n    HttpResponse::Ok().finish()\n}\n#[actix_web::main]\nasync fn main() -&gt; std::io::Result&lt;()&gt; {\n    let mut labels = HashMap::new();\n    labels.insert(\"label1\".to_string(), \"value1\".to_string());\n    let prometheus = PrometheusMetricsBuilder::new(\"api\")\n        .endpoint(\"/metrics\")\n        .const_labels(labels)\n        .build()\n        .unwrap();\n        HttpServer::new(move || {\n            App::new()\n                .wrap(prometheus.clone())\n                .service(web::resource(\"/health\").to(health))\n        })\n        .bind(\"127.0.0.1:8080\")?\n        .run()\n        .await?;\n    Ok(())\n}</code></pre>\n<h2> 研发自动化</h2>\n<h3>sql_reverse</h3>\n<p>对于Sqlx,其实没有给出比较完善的ORM能力，所以我们使用sql_reverse来帮助我们。大家可以找到这个项目。他非常新。</p>\n<p><a class=\"has-card\" href=\"https://github.com/ptechen/sql_reverse\" title=\"GitHub - ptechen/sql_reverse\"><span class=\"link-card-box\"><span class=\"link-title\">GitHub - ptechen/sql_reverse</span><span class=\"link-link\"><img alt=\"\" class=\"link-link-icon\" src=\"image\\icon-default.png\"/>https://github.com/ptechen/sql_reverse</span></span></a>我们为sqlx的model代码生成写了专门的template:</p>\n<pre><code class=\"language-rust\">use serde::{Deserialize, Serialize};\nuse sqlx::mysql::MySqlRow;\nuse sqlx::{FromRow, Row};\n\n{% if table.comment -%}\n\t/// {<!-- -->{ table.comment }}\n{% endif -%}\n{% for index in table.index_key -%}\n    /// 索引：{<!-- -->{index}}\n{% endfor -%}\n\n\n#[derive(Serialize, Deserialize, PartialEq, Clone)]\npub struct {<!-- -->{ table.struct_name }} {\n{%- for v in table.fields %}\n\t{% if v.comment -%}\n\t    /// {<!-- -->{ v.comment }} {% if v.database_field_type %} field_type: {<!-- -->{ v.database_field_type }}{% endif %}{% if v.default %} default: {<!-- -->{ v.default }}{% endif %} {% if v.default == '' %} default: ''{% endif %}\n\t{% endif -%}\n\t{% if v.is_null == 1 -%}\n    \tpub {<!-- -->{ v.field_name }}: Option&lt;{<!-- -->{ v.field_type }}&gt;,\n    {%- else -%}\n        {% if v.field_type == 'NaiveDateTime' -%}\n            pub {<!-- -->{ v.field_name }}: Option&lt;{<!-- -->{ v.field_type }}&gt;,\n        {%- else -%}\n            pub {<!-- -->{ v.field_name }}: {<!-- -->{ v.field_type }},\n        {%- endif -%}\n    {%- endif -%}\n{%- endfor %}\n}\n\nimpl&lt;'c&gt; FromRow&lt;'c, MySqlRow&lt;'c&gt;&gt; for {<!-- -->{ table.struct_name }} {\n    fn from_row(row: &amp;MySqlRow) -&gt; Result&lt;Self, sqlx::Error&gt; {\n        Ok({<!-- -->{ table.struct_name }} {\n{%- for v in table.fields %}\n            {<!-- -->{ v.field_name }}: row.get( {<!-- -->{ loop.index0 }} ),\n{%- endfor %}        \n        })\n    }\n}\n</code></pre>\n<p>大家可以一试。</p>\n<h3>Tera</h3>\n<p>这是一个比较有效的模版引擎。可以帮助我们做代码生成。也是sql_reverse的后端引擎。</p>\n<p><a class=\"has-card\" href=\"https://github.com/Keats/tera\" title=\"GitHub - Keats/tera: A template engine for Rust based on Jinja2/Django\"><span class=\"link-card-box\"><span class=\"link-title\">GitHub - Keats/tera: A template engine for Rust based on Jinja2/Django</span><span class=\"link-desc\">A template engine for Rust based on Jinja2/Django. Contribute to Keats/tera development by creating an account on GitHub.</span><span class=\"link-link\"><img alt=\"\" class=\"link-link-icon\" src=\"https://github.com/fluidicon.png\"/>https://github.com/Keats/tera</span></span></a></p>\n<h2>audit</h2>\n<p>rust项目的代码安全审计可以通过 cargo audit 进行审计。这里是公开的rust库的安全建议列库。这个建议库还是得到了很好的维护。</p>\n<p><a class=\"has-card\" href=\"https://github.com/RustSec/advisory-db\" title=\"GitHub - rustsec/advisory-db: Security advisory database for Rust crates published through crates.io\"><span class=\"link-card-box\"><span class=\"link-title\">GitHub - rustsec/advisory-db: Security advisory database for Rust crates published through crates.io</span><span class=\"link-desc\">Security advisory database for Rust crates published through crates.io - GitHub - rustsec/advisory-db: Security advisory database for Rust crates published through crates.io</span><span class=\"link-link\"><img alt=\"\" class=\"link-link-icon\" src=\"https://github.com/fluidicon.png\"/>https://github.com/RustSec/advisory-db</span></span></a></p>\n<p>如何安装和使用 cargo audit，可以参考这个文档：</p>\n<p><a href=\"https://github.com/RustSec/rustsec/tree/main/cargo-audit\" title=\"rustsec/cargo-audit at main · rustsec/rustsec · GitHub\">rustsec/cargo-audit at main · rustsec/rustsec · GitHub</a></p>\n<p>下面是我们针对actix-net进行审计的结果。发现了一个已经不被维护的库。</p>\n<pre><code class=\"language-bash\">~/rust/actix-net\ncargo audit\n    Fetching advisory database from `https://github.com/RustSec/advisory-db.git`\n      Loaded 421 security advisories (from /Users/user1/.cargo/advisory-db)\n    Updating crates.io index\n    Scanning Cargo.lock for vulnerabilities (214 crate dependencies)\nCrate:     serde_cbor\nVersion:   0.11.2\nWarning:   unmaintained\nTitle:     serde_cbor is unmaintained\nDate:      2021-08-15\nID:        RUSTSEC-2021-0127\nURL:       https://rustsec.org/advisories/RUSTSEC-2021-0127\nDependency tree:\nserde_cbor 0.11.2\n└── criterion 0.3.5\n    └── actix-codec 0.5.1\n        ├── actix-tls 3.0.4\n        └── actix-server 2.1.1\n            └── actix-tls 3.0.4\n\nwarning: 1 allowed warning found</code></pre>\n<p></p>\n<h2>集群，Raft，Gossip和其他</h2>\n<p>选择使用Raft的同学，在很大程度上都会考虑性能要求比较高的关键应用。而关键应用除了对性能要求比较高以外，还会考虑稳定性。通过集群的配置提高可用性是一个非常关键的技术。所以，我们会对集群进行进一步的讨论探索。</p>\n<h3>Actix集群</h3>\n<p>这是一个实验项目，我们暂时还没有深入研究。但是如果真的能达到Akka集群的水平，我们还是非常期待的。为了这个理想，大家也去给人点个星星，鼓励一下呗。</p>\n<p><a class=\"has-card\" href=\"https://github.com/pengwin/actix-raft-cluster\" title=\"GitHub - pengwin/actix-raft-cluster\"><span class=\"link-card-box\"><span class=\"link-title\">GitHub - pengwin/actix-raft-cluster</span><span class=\"link-desc\">Contribute to pengwin/actix-raft-cluster development by creating an account on GitHub.</span><span class=\"link-link\"><img alt=\"\" class=\"link-link-icon\" src=\"https://github.com/fluidicon.png\"/>https://github.com/pengwin/actix-raft-cluster</span></span></a></p>\n<p>另外一个实验项目是 actix_telepathy。作者 <a class=\"link-info\" href=\"https://hpi.de/naumann/people/phillip-wenig.html\" title=\"Phillip Wenig\">Phillip Wenig</a> 是Hasso Plattner Institute的软件系统专业的博士生。有问题可以向他咨询。祝愿这个项目越来越好。这样我们就有基于Rust的Actor集群可用了。</p>\n<p><a class=\"has-card\" href=\"https://docs.rs/actix-telepathy/latest/actix_telepathy/\" title=\"actix_telepathy - Rust\"><span class=\"link-card-box\"><span class=\"link-title\">actix_telepathy - Rust</span><span class=\"link-desc\">Actix-Telepathy is an extension to Actix that enables remote messaging and clustering support.</span><span class=\"link-link\"><img alt=\"\" class=\"link-link-icon\" src=\"image\\favicon-16x16-20220703-1.64.0-nightly-495b21669.png\"/>https://docs.rs/actix-telepathy/latest/actix_telepathy/</span></span></a>这里有一个例子可以知道项目如何运作。 </p>\n<p><a href=\"https://github.com/wenig/telepathy-examples\" title=\"https://github.com/wenig/telepathy-examples\">https://github.com/wenig/telepathy-examples</a></p>\n<h3>Raft</h3>\n<p>这篇文章我们叙述了如何使用Raft来实现高可用的高性能撮合引擎。有兴趣的架构设计师，软件设计师同学我们可以一起探讨。原子多播是撮合引擎的正解，当前国际上比较有名的金融交易所都是延续这个设计方法。我们有幸通过开源项目低成本实现源自多播的撮合引擎，也说明开源项目的不断发展。</p>\n<p><a href=\"https://blog.csdn.net/weixin_41308834/article/details/124375789\" title=\"Raft in Rust (原子多播+撮合引擎）_Raymond-Shen的博客-CSDN博客\">Raft in Rust (原子多播+撮合引擎）_Raymond-Shen的博客-CSDN博客</a></p>\n<h2>参考资料：</h2>\n<p><a href=\"https://speakerdeck.com/lukemathwalker/writing-enterprise-software-a-rust-experiment\" title=\"https://speakerdeck.com/lukemathwalker/writing-enterprise-software-a-rust-experiment\">https://speakerdeck.com/lukemathwalker/writing-enterprise-software-a-rust-experiment</a></p>\n<p><a href=\"https://github.com/pretzelhammer/rust-blog/blob/master/posts/restful-api-in-sync-and-async-rust.md\" title=\"rust-blog/restful-api-in-sync-and-async-rust.md at master · pretzelhammer/rust-blog · GitHub\">rust-blog/restful-api-in-sync-and-async-rust.md at master · pretzelhammer/rust-blog · GitHub</a></p>\n</div>\n</div>"}