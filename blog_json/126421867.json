{"blogid": "126421867", "writerAge": "码龄1年", "writerBlogNum": "91", "writerCollect": "6699", "writerComment": "12541", "writerFan": "13071", "writerGrade": "7级", "writerIntegral": "19618", "writerName": "微凉秋意", "writerProfileAdress": "writer_image\\profile_126421867.jpg", "writerRankTotal": "415", "writerRankWeekly": "1", "writerThumb": "7505", "writerVisitNum": "122057", "blog_read_count": "1214", "blog_time": "于 2022-08-21 21:07:17 发布", "blog_title": "【Rust 指南】详解Rust所有权的语法机制 | 理解其独特的内存管理原理", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-github-gist\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\0445dea7ffb04854838e8841b0f6b812.png\"/><br/> </p>\n<div class=\"toc\">\n<h3>文章目录</h3>\n<ul><li><a href=\"#emspemsp_2\">  前言</a></li><li><a href=\"#_6\">一、主流语言的资源回收状况</a></li><li><a href=\"#Rust__11\">二、Rust 所有权</a></li><li><ul><li><a href=\"#1_12\">1、所有权概念的基础</a></li><li><a href=\"#2_20\">2、根据变量来理清内存分配</a></li><li><ul><li><a href=\"#21__21\">2.1. 变量范围与内存分配</a></li><li><a href=\"#22_42\">2.2、变量与数据交互的方式</a></li></ul>\n</li><li><a href=\"#3_76\">3、涉及函数的所有权机制</a></li><li><ul><li><a href=\"#31_77\">3.1、函数传参的所有权</a></li><li><a href=\"#32_110\">3.2、函数返回值的所有权机制</a></li></ul>\n</li><li><a href=\"#4_141\">4、引用与租借</a></li></ul>\n</li></ul>\n</div>\n<p></p>\n<h1><a id=\"emspemsp_2\"></a>  前言</h1>\n<p>  所有权对大多数开发者而言是一个新颖的概念，它是 Rust 语言为高效使用内存而设计的语法机制。所有权概念是为了让 Rust 在编译阶段更有效地分析内存资源的有用性以实现内存管理而诞生的概念。</p>\n<hr/>\n<h1><a id=\"_6\"></a>一、主流语言的资源回收状况</h1>\n<p><em>计算机程序必须在运行时管理它们所使用的内存资源</em></p>\n<ul><li>C/C++ 这样的语言主要通过手动方式管理内存，开发者需要手动的申请和释放内存资源。但为了提高开发效率，只要不影响程序功能的实现，许多开发者没有及时释放内存的习惯。所以手动管理内存的方式常常造成资源浪费。</li><li>Java 语言也有回收资源的机制——GC，但是这种方式常常会降低运行时效率，所以 JVM 会尽可能少的回收资源，这样也会使程序占用较大的内存资源。</li></ul>\n<h1><a id=\"Rust__11\"></a>二、Rust 所有权</h1>\n<h2><a id=\"1_12\"></a>1、所有权概念的基础</h2>\n<p><em>所有权有以下三条规则：</em></p>\n<ol><li>Rust 中的每个值都有一个变量，称为其所有者。</li><li>一次只能有一个所有者。</li><li>当所有者不在程序运行范围时，该值将被删除。</li></ol>\n<blockquote>\n<p>从C/C++的角度来讲就是，变量有其作用范围，而且一个变量名对应一个变量的值；超过变量作用范围，该值就失效了。</p>\n</blockquote>\n<h2><a id=\"2_20\"></a>2、根据变量来理清内存分配</h2>\n<h3><a id=\"21__21\"></a>2.1. 变量范围与内存分配</h3>\n<ol><li>变量范围</li></ol>\n<p>变量范围是变量的一个属性，其代表变量的可行域，默认从声明变量开始有效直到变量所在域结束。</p>\n<ol start=\"2\"><li>内存和分配</li></ol>\n<p>如果我们定义了一个变量并给它赋予一个值，则这个变量的值存在于内存中。这种情况很普遍，但如果我们需要储存的数据长度不确定（比如用户输入的一串字符串），我们就无法在定义时明确数据长度，也就无法在编译阶段令程序分配固定长度的内存空间供数据储存使用。（有人说分配尽可能大的空间可以解决问题，但这个方法很不文明）。这就需要提供一种在程序运行时程序自己申请使用内存的机制——<strong>堆</strong>。</p>\n<p>有分配就有释放，程序不能一直占用某个内存资源。因此决定资源是否浪费的关键因素就是资源有没有及时的释放。</p>\n<p><em>用 C++代码举例：</em></p>\n<pre><code class=\"prism language-cpp\">\t<span class=\"token keyword\">int</span> n <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\tcin <span class=\"token operator\">&gt;&gt;</span> n<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span><span class=\"token operator\">*</span> arr <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">delete</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>arr<span class=\"token punctuation\">;</span>\n</code></pre>\n<p>很显然，Rust 里没有<code>delete</code> 函数来释放arr的内存资源。而Rust 之所以没有明示释放的步骤是因为在变量范围结束的时候，Rust 编译器自动添加了调用释放资源函数的步骤。别小看这一个自动调用释放资源的机制，这种简单的机制可以有效地解决一个史上最令程序员头疼的编程问题。</p>\n<h3><a id=\"22_42\"></a>2.2、变量与数据交互的方式</h3>\n<p><em>变量与数据交互方式主要有移动（Move）和克隆（Clone）两种：</em></p>\n<ol><li>多个变量可以在 Rust 中以不同的方式与相同的数据交互——移动<br/> 例：<code>let x = 5; let y = x;</code>\n<ul><li>这个程序将值 5 绑定到变量 x，然后将 x 的值复制并赋值给变量 y。现在栈中将有两个值 5。此情况中的数据是\"基本数据\"类型的数据，不需要存储到堆中，仅在栈中的数据的\"移动\"方式是直接复制，这不会花费更长的时间或更多的存储空间。</li><li>基本数据类型： \n    <ul><li>所有整数类型，例如 i32 、 u32 、 i64 等。<br/> 布尔类型 bool，值为 true 或 false 。<br/> 所有浮点类型，f32 和 f64。<br/> 字符类型 char。<br/> 仅包含以上类型数据的元组（Tuples）</li></ul> </li></ul>\n<hr/>\n<ul><li>但如果发生交互的数据在堆中就是另外一种情况：<br/> <code>let s1 = String::from(\"hello\");</code><br/> <code>let s2 = s1;</code></li><li>第一步是产生一个 String 对象，值为 “hello”。其中 “hello” 可以认为是类似于长度不确定的数据，需要在堆中存储，而第二步s2指向堆内s1的地址，放在C/C++里来说，这时候访问s1和s2都能得到“Hello”这个结果，但是在Rust里不允许这样。</li><li>前面我们说过，当变量超出范围时，Rust 自动调用释放资源函数并清理该变量的堆内存。但是 s1 和 s2 都被释放的话堆区中的 “hello” 被释放两次，这是不被系统允许的，实际上，当s1赋值给s2时，s1已经是<strong>名存实亡</strong>的状态了(无法访问)。</li></ul> </li></ol>\n<hr/>\n<ol start=\"2\"><li>Rust会尽可能地降低程序的运行成本，所以默认情况下，长度较大的数据存放在堆中，且采用移动的方式进行数据交互。但如果需要将数据单纯的复制一份以供他用，可以使用数据的第二种交互方式——克隆。</li></ol>\n<p><em>实例：</em></p>\n<pre><code class=\"prism language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">let</span> s1 <span class=\"token operator\">=</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> s2 <span class=\"token operator\">=</span> s1<span class=\"token punctuation\">.</span><span class=\"token function\">clone</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token macro property\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"s1 = {}, s2 = {}\"</span><span class=\"token punctuation\">,</span> s1<span class=\"token punctuation\">,</span> s2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>这里是真的将堆中的 “hello” 复制了一份，所以 s1 和 s2 都分别绑定了一个值，释放的时候也会被当作两个资源。</p>\n<p>当然，克隆仅在需要复制的情况下使用，毕竟复制数据会花费更多的时间。</p>\n<hr/>\n<h2><a id=\"3_76\"></a>3、涉及函数的所有权机制</h2>\n<h3><a id=\"31_77\"></a>3.1、函数传参的所有权</h3>\n<p><em>我们直接用代码解释：</em></p>\n<pre><code class=\"prism language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">let</span> s <span class=\"token operator\">=</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// s 被声明有效</span>\n\n    <span class=\"token function\">takes_ownership</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// s 的值被当作参数传入函数</span>\n    <span class=\"token comment\">// 所以可以当作 s 已经被移动，从这里开始已经无效</span>\n\n    <span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// x 被声明有效</span>\n\n    <span class=\"token function\">makes_copy</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// x 的值被当作参数传入函数</span>\n    <span class=\"token comment\">// 但 x 是基本类型，依然有效</span>\n    <span class=\"token comment\">// 在这里依然可以使用 x 却不能使用 s</span>\n\n<span class=\"token punctuation\">}</span> <span class=\"token comment\">// 函数结束, x 无效, 然后是 s. 但 s 已被移动, 所以不用被释放</span>\n\n\n<span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">takes_ownership</span><span class=\"token punctuation\">(</span>some_string<span class=\"token punctuation\">:</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token comment\">// 一个 String 参数 some_string 传入，有效</span>\n    <span class=\"token macro property\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"{}\"</span><span class=\"token punctuation\">,</span> some_string<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token comment\">// 函数结束, 参数 some_string 在这里释放</span>\n\n<span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">makes_copy</span><span class=\"token punctuation\">(</span>some_integer<span class=\"token punctuation\">:</span> <span class=\"token keyword\">i32</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token comment\">// 一个 i32 参数 some_integer 传入，有效</span>\n    <span class=\"token macro property\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"{}\"</span><span class=\"token punctuation\">,</span> some_integer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token comment\">// 函数结束, 参数 some_integer 是基本类型, 无需释放</span>\n</code></pre>\n<h3><a id=\"32_110\"></a>3.2、函数返回值的所有权机制</h3>\n<p><em>上实例：</em></p>\n<pre><code class=\"prism language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">let</span> s1 <span class=\"token operator\">=</span> <span class=\"token function\">gives_ownership</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// gives_ownership 移动它的返回值到 s1</span>\n\n    <span class=\"token keyword\">let</span> s2 <span class=\"token operator\">=</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// s2 被声明有效</span>\n\n    <span class=\"token keyword\">let</span> s3 <span class=\"token operator\">=</span> <span class=\"token function\">takes_and_gives_back</span><span class=\"token punctuation\">(</span>s2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// s2 被当作参数移动, s3 获得返回值所有权</span>\n<span class=\"token punctuation\">}</span> <span class=\"token comment\">// s3 无效被释放, s2 被移动, s1 无效被释放.</span>\n\n<span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">gives_ownership</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-&gt;</span> <span class=\"token class-name\">String</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">let</span> some_string <span class=\"token operator\">=</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// some_string 被声明有效</span>\n\n    <span class=\"token keyword\">return</span> some_string<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// some_string 被当作返回值移动出函数</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">takes_and_gives_back</span><span class=\"token punctuation\">(</span>a_string<span class=\"token punctuation\">:</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-&gt;</span> <span class=\"token class-name\">String</span> <span class=\"token punctuation\">{<!-- --></span> \n    <span class=\"token comment\">// a_string 被声明有效</span>\n\n    a_string  <span class=\"token comment\">// a_string 被当作返回值移出函数</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<blockquote>\n<p>被当作函数返回值的变量所有权将会被移动出函数并<strong>返回到调用函数的地方</strong>，而不会直接被无效释放。</p>\n</blockquote>\n<h2><a id=\"4_141\"></a>4、引用与租借</h2>\n<p><em>Rust 语言也是支持引用的，这个知识点对于C++开发者来说可谓是非常熟悉，引用实质上是一种指针，具体来说是一个<strong>指针常量</strong>。</em></p>\n<p> 我们可以把引用理解为访问变量的间接方式：</p>\n<pre><code class=\"prism language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">let</span> s1 <span class=\"token operator\">=</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> s2 <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>s1<span class=\"token punctuation\">;</span>\n    <span class=\"token macro property\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"s1 is {}, s2 is {}\"</span><span class=\"token punctuation\">,</span> s1<span class=\"token punctuation\">,</span> s2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">//变量本身不会被认定无效，可以访问s1，因为\"引用\"并没有在栈中复制变量的值</span>\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\d69f5fc31ae64b5a9ba0dca6193a41bd.png\"/></p>\n<hr/>\n<p><em>在函数中，传入变量的引用只需加上<code>&amp;</code>即可：</em></p>\n<pre><code class=\"prism language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">let</span> s1 <span class=\"token operator\">=</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">let</span> len <span class=\"token operator\">=</span> <span class=\"token function\">calculate_length</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>s1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token macro property\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"The length of '{}' is {}.\"</span><span class=\"token punctuation\">,</span> s1<span class=\"token punctuation\">,</span> len<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">calculate_length</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-&gt;</span> <span class=\"token keyword\">usize</span> <span class=\"token punctuation\">{<!-- --></span>\n    s<span class=\"token punctuation\">.</span><span class=\"token function\">len</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n运行结果：<span class=\"token class-name\">The</span> length of <span class=\"token lifetime-annotation symbol\">'hello</span>' is <span class=\"token number\">5</span><span class=\"token punctuation\">.</span>\n</code></pre>\n<hr/>\n<p><strong>关于引用时所有权的问题：</strong></p>\n<ul><li>引用不会获得值的所有权。</li><li>引用只能租借（Borrow）值的所有权。</li><li>引用本身也是一个类型并具有一个值，这个值记录的是别的值所在的位置（地址），但引用不具有所指值的所有权。</li><li>一个引用必须租借拥有所有权的变量，如果被租借的变量所有权移交给其他变量，那么就需要重新对新变量租借。</li></ul>\n<p> 例如：</p>\n<pre><code class=\"prism language-rust\">    <span class=\"token keyword\">let</span> s1 <span class=\"token operator\">=</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> <span class=\"token keyword\">mut</span> s2 <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>s1<span class=\"token punctuation\">;</span> <span class=\"token comment\">//因为s2租借多次，所以需要加mut</span>\n    <span class=\"token keyword\">let</span> s3 <span class=\"token operator\">=</span> s1<span class=\"token punctuation\">;</span>\n    s2 <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>s3<span class=\"token punctuation\">;</span>  <span class=\"token comment\">//重新从 s3 租借所有权</span>\n</code></pre>\n<ul><li>如果尝试利用租借来的权利来修改数据会被阻止，如果想要修改就要加上<code>mut</code>关键字 \n  <ul><li>例如：<br/> <img alt=\"在这里插入图片描述\" src=\"image\\be14ef7c02a341589d8b644d6cc8830f.png\"/></li></ul> </li><li>可变引用与不可变引用相比除了权限不同以外，可变引用不允许多重引用，但不可变引用可以</li></ul>\n<p> 例如：</p>\n<pre><code class=\"prism language-rust\"><span class=\"token keyword\">let</span> <span class=\"token keyword\">mut</span> s <span class=\"token operator\">=</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> r1 <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span><span class=\"token keyword\">mut</span> s<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> r2 <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span><span class=\"token keyword\">mut</span> s<span class=\"token punctuation\">;</span>\n\n<span class=\"token macro property\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"{}, {}\"</span><span class=\"token punctuation\">,</span> r1<span class=\"token punctuation\">,</span> r2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<blockquote>\n<p>这段程序不正确，因为多重可变引用了 s。<br/> <strong>Rust 对可变引用的这种设计主要出于对并发状态下发生数据访问碰撞的考虑，在编译阶段就避免了这种事情的发生。<br/> 由于发生数据访问碰撞的必要条件之一是数据被至少一个使用者写且同时被至少一个其他使用者读或写，所以在一个值被可变引用时不允许再次被任何引用。</strong></p>\n</blockquote>\n<hr/>\n<p><strong>垂悬引用（Dangling References）</strong><br/> 在C/C++等有指针概念的语言里，会存在空指针和野指针的异常，其实这种异常指的是那种没有实际指向一个真正能访问的数据的指针。它们就像失去悬挂物体的绳子，所以叫\"<strong>垂悬引用</strong>\" 。</p>\n<p><em>下面是一个垂悬的典型案例：</em></p>\n<pre><code class=\"prism language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">let</span> reference_to_nothing <span class=\"token operator\">=</span> <span class=\"token function\">dangle</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">dangle</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-&gt;</span> <span class=\"token operator\">&amp;</span><span class=\"token class-name\">String</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">let</span> s <span class=\"token operator\">=</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token operator\">&amp;</span>s\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<blockquote>\n<p>主函数调用<code>dangle</code>函数，该函数定义了一个局部变量 <code>s</code> ，函数结束时返回的该变量的引用；但是该变量本身并没有当作返回值，而是超过作用域后被释放，那么此时的引用的指向已经无法确定是否存在，因此不允许存在。</p>\n</blockquote>\n<blockquote>\n<p>这个原理跟C++中不能返回局部变量的地址是同一个知识点。</p>\n</blockquote>\n<hr/>\n<p><strong>注：本篇博客讲的内存资源都是指堆所占用的内存空间</strong></p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}