{"blogid": "123665627", "writerAge": "码龄11年", "writerBlogNum": "49", "writerCollect": "353", "writerComment": "140", "writerFan": "694", "writerGrade": "3级", "writerIntegral": "719", "writerName": "自动驾驶Player", "writerProfileAdress": "writer_image\\profile_123665627.jpg", "writerRankTotal": "22268", "writerRankWeekly": "6066", "writerThumb": "107", "writerVisitNum": "66062", "blog_read_count": "5049", "blog_time": "已于 2022-06-02 16:09:06 修改", "blog_title": "Apollo Planning决策规划算法代码详细解析 (1)：Scenario选择", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p><strong>本文重点讲解Apollo代码中怎样配置Scenario以及选择当前Scenario，Scenario场景决策是Apollo规划算法的第一步，本文会对代码进行详细解析，也会梳理整个决策流程，码字不易，喜欢的朋友们麻烦点个关注与赞。</strong> </p>\n<p><img alt=\"\" height=\"951\" src=\"image\\6ad078c833374835a8d59dbfce2ca7d6.png\" width=\"1200\"/></p>\n<p><strong>Apollo Planning决策规划系列文章：</strong></p>\n<p><a class=\"link-info\" href=\"https://blog.csdn.net/nn243823163/article/details/123684863?spm=1001.2014.3001.5501\" title=\"Apollo Planning决策规划代码详细解析 (2)：Scenario执行\">Apollo Planning决策规划代码详细解析 (2)：Scenario执行</a></p>\n<p><a class=\"link-info\" href=\"https://blog.csdn.net/nn243823163/article/details/123690894?spm=1001.2014.3001.5502\" title=\"Apollo Planning决策规划代码详细解析 (3)：stage执行\">Apollo Planning决策规划代码详细解析 (3)：stage执行</a></p>\n<p><a class=\"link-info\" href=\"https://blog.csdn.net/nn243823163/article/details/123710179\" title=\"Apollo Planning决策规划代码详细解析 (4)：Stage逻辑详解\">Apollo Planning决策规划代码详细解析 (4)：Stage逻辑详解</a></p>\n<p><a class=\"link-info\" href=\"https://blog.csdn.net/nn243823163/article/details/123851180\" title=\"Apollo Planning决策规划代码详细解析 (5)：规划算法流程介绍\">Apollo Planning决策规划代码详细解析 (5)：规划算法流程介绍</a></p>\n<p><a class=\"link-info\" href=\"https://blog.csdn.net/nn243823163/article/details/123904902?spm=1001.2014.3001.5502\" title=\"Apollo Planning决策规划代码详细解析 (6): LaneChangeDecider\">Apollo Planning决策规划代码详细解析 (6): LaneChangeDecider</a></p>\n<p><a href=\"https://blog.csdn.net/nn243823163/article/details/123915071\" title=\"Apollo Planning决策规划代码详细解析 (7): PathReuseDecider\">Apollo Planning决策规划代码详细解析 (7): PathReuseDecider</a></p>\n<p><a href=\"https://blog.csdn.net/nn243823163/article/details/123918819\" title=\"Apollo Planning决策规划代码详细解析 (8): PathLaneBorrowDecide\">Apollo Planning决策规划代码详细解析 (8): PathLaneBorrowDecide</a></p>\n<p><a href=\"https://blog.csdn.net/nn243823163/article/details/123987313\" title=\"Apollo Planning决策规划代码详细解析 (9): PathBoundsDecider\">Apollo Planning决策规划代码详细解析 (9): PathBoundsDecider</a></p>\n<p><a href=\"https://blog.csdn.net/nn243823163/article/details/124185202\" title=\"Apollo Planning决策规划代码详细解析 (10)：PiecewiseJerkPathOptimizer\">Apollo Planning决策规划代码详细解析 (10)：PiecewiseJerkPathOptimizer</a></p>\n<p><a href=\"https://blog.csdn.net/nn243823163/article/details/124193985\" title=\"Apollo Planning决策规划代码详细解析 (11): PathAssessmentDecider\">Apollo Planning决策规划代码详细解析 (11): PathAssessmentDecider</a></p>\n<p><a href=\"https://blog.csdn.net/nn243823163/article/details/124423416\" title=\"Apollo Planning决策规划代码详细解析 (12): PathDecider\">Apollo Planning决策规划代码详细解析 (12): PathDecider</a></p>\n<p><a href=\"https://blog.csdn.net/nn243823163/article/details/124506678?spm=1001.2014.3001.5502\" title=\"Apollo Planning决策规划代码详细解析 (13): RuleBasedStopDecider\">Apollo Planning决策规划代码详细解析 (13): RuleBasedStopDecider</a></p>\n<p><a href=\"https://blog.csdn.net/nn243823163/article/details/124545583\" title=\"Apollo Planning决策规划算法代码详细解析 (14):SPEED_BOUNDS_PRIORI_DECIDER\">Apollo Planning决策规划算法代码详细解析 (14):SPEED_BOUNDS_PRIORI_DECIDER</a></p>\n<p><a href=\"https://blog.csdn.net/nn243823163/article/details/124619461?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22124619461%22%2C%22source%22%3A%22nn243823163%22%7D&amp;ctrtid=P4IFO\" title=\"Apollo Planning决策规划算法代码解析(15): 速度动态规划SPEED_HEURISTIC_OPTIMIZER 上\">Apollo Planning决策规划算法代码解析(15): 速度动态规划SPEED_HEURISTIC_OPTIMIZER 上</a></p>\n<p><a href=\"https://blog.csdn.net/nn243823163/article/details/124704179?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22124704179%22%2C%22source%22%3A%22nn243823163%22%7D&amp;ctrtid=4UVMP\" title=\"Apollo Planning决策规划算法代码解析 (16):SPEED_HEURISTIC_OPTIMIZER 速度动态规划中\">Apollo Planning决策规划算法代码解析 (16):SPEED_HEURISTIC_OPTIMIZER 速度动态规划中</a></p>\n<p><a href=\"https://blog.csdn.net/nn243823163/article/details/124772521?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22124772521%22%2C%22source%22%3A%22nn243823163%22%7D&amp;ctrtid=hfHXY\" title=\"Apollo Planning决策规划算法代码解析 (17):SPEED_HEURISTIC_OPTIMIZER 速度动态规划下\">Apollo Planning决策规划算法代码解析 (17):SPEED_HEURISTIC_OPTIMIZER 速度动态规划下</a></p>\n<p><strong>算法介绍文章： </strong></p>\n<p><a href=\"https://blog.csdn.net/nn243823163/article/details/124029553?spm=1001.2014.3001.5502\" title=\"Apollo决策规划算法Planning : Piecewise Jerk Path Optimizer的python实现\">Apollo决策规划算法Planning : Piecewise Jerk Path Optimizer的python实现</a></p>\n<p><strong>仿真技术介绍文章： </strong></p>\n<p><a href=\"https://blog.csdn.net/nn243823163/article/details/124402527?spm=1001.2014.3001.5502\" title=\"prescan联合simulink进行FCW的仿真_自动驾驶 Player的博客-CSDN博客\">prescan联合simulink进行FCW的仿真_自动驾驶 Player的博客-CSDN博客</a></p>\n<p><strong> 如果对apollo规划算法感兴趣，想学习完整的系列文章，可以订阅下面专栏：</strong><a class=\"has-card\" href=\"https://blog.csdn.net/nn243823163/category_11685852.html\" title=\"https://blog.csdn.net/nn243823163/category_11685852.html\"><span class=\"link-card-box\"><span class=\"link-title\">https://blog.csdn.net/nn243823163/category_11685852.html</span><span class=\"link-link\"><img alt=\"\" class=\"link-link-icon\" src=\"image\\icon-default.png\"/>https://blog.csdn.net/nn243823163/category_11685852.html</span></span></a></p>\n<p><strong>正文如下：</strong> </p>\n<p><strong>本文重点讲解Apollo代码中怎样配置Scenario以及选择当前Scenario，Scenario决策是Apollo规划算法的第一步，本文会对代码进行详细解析，也会梳理整个决策流程，码字不易，喜欢的朋友们麻烦点个关注与赞。</strong>  </p>\n<p><strong>在本文你将学到下面这些内容：</strong></p>\n<ol><li>规划器planer的种类；</li><li>规划器planer的主要函数及逻辑；</li><li>场景管理类ScenarioManager的运行机制；</li><li>场景注册方法；</li><li>场景决策流程，如何选择当前场景</li><li>详细的apollo决策规划代码分析</li></ol>\n<p></p>\n<p><strong>代码具体过程如下：</strong></p>\n<p>0、规划算法的入口</p>\n<p>（1）规划模块的<span style=\"color:#494949;\">入口函数是PlanningComponent的Proc。</span></p>\n<p><span style=\"color:#494949;\">（2）以规划模式OnLanePlanning，执行RunOnce。在RunOnce中<strong>先执行交通规则</strong>，再规划轨迹。规划轨迹的函数是Plan。</span></p>\n<p><span style=\"color:#494949;\">1、</span>Scenario的判断在Planer中进行，目前Apollo共有下面这些planer，其中最常用的就是EM规划器，即PublicRoadPlanner，本系列主要介绍PublicRoadPlanner这个Planer。</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\fe539cdfe59942c4bb60661e067ebe67.png\"/>​</p>\n<p>2、Apollo会根据配置调用PublicRoadPlanner这个planer，关于配置方法，之后会在另外一篇博文进行更新。PublicRoadPlanner主要有init()与plan()两个重要的函数，inti()是规划器的初始化，plan就是具体的规划过程。</p>\n<div>\n<pre><code class=\"language-cpp\">class PublicRoadPlanner : public PlannerWithReferenceLine {\n public:\n  /**\n   * @brief Constructor\n   */\n  PublicRoadPlanner() = delete;\n\n  explicit PublicRoadPlanner(\n      const std::shared_ptr&lt;DependencyInjector&gt;&amp; injector)\n      : PlannerWithReferenceLine(injector) {}\n\n  /**\n   * @brief Destructor\n   */\n  virtual ~PublicRoadPlanner() = default;\n\n  void Stop() override {}\n\n  std::string Name() override { return \"PUBLIC_ROAD\"; }\n\n  common::Status Init(const PlanningConfig&amp; config) override;\n\n  /**\n   * @brief Override function Plan in parent class Planner.\n   * @param planning_init_point The trajectory point where planning starts.\n   * @param frame Current planning frame.\n   * @return OK if planning succeeds; error otherwise.\n   */\n  common::Status Plan(const common::TrajectoryPoint&amp; planning_init_point,\n                      Frame* frame,\n                      ADCTrajectory* ptr_computed_trajectory) override;\n};</code></pre>\n</div>\n<p>3、scenario的选择在Plan() 函数的update阶段，主要用的是ScenarioManager类的updata函数。ScenarioManager并不属于某个特定的planer，这个类只针对于scenario，每个planer都可以调用它来管理场景。下面代码片段是PublicRoadPlanner的Plan()函数。</p>\n<div>\n<pre><code class=\"language-cpp\">Status PublicRoadPlanner::Plan(const TrajectoryPoint&amp; planning_start_point,\n                               Frame* frame,\n                               ADCTrajectory* ptr_computed_trajectory) {\n  // 决策当前应该执行哪个场景\n  scenario_manager_.Update(planning_start_point, *frame);\n  // 获取当前场景\n  scenario_ = scenario_manager_.mutable_scenario();\n  // 处理当前场景\n  auto result = scenario_-&gt;Process(planning_start_point, frame);\n  // 打印debug信息\n  if (FLAGS_enable_record_debug) {\n    auto scenario_debug = ptr_computed_trajectory-&gt;mutable_debug()\n                              -&gt;mutable_planning_data()\n                              -&gt;mutable_scenario();\n    scenario_debug-&gt;set_scenario_type(scenario_-&gt;scenario_type());\n    scenario_debug-&gt;set_stage_type(scenario_-&gt;GetStage());\n    scenario_debug-&gt;set_msg(scenario_-&gt;GetMsg());\n  }\n  // 场景处理成功\n  if (result == scenario::Scenario::STATUS_DONE) {\n    // only updates scenario manager when previous scenario's status is\n    // STATUS_DONE\n    scenario_manager_.Update(planning_start_point, *frame);\n  } \n  // 场景处理失败\n  else if (result == scenario::Scenario::STATUS_UNKNOWN) {\n    return Status(common::PLANNING_ERROR, \"scenario returned unknown\");\n  }\n  return Status::OK();\n}</code></pre>\n</div>\n<p>4、ScenarioManager会实例化一个全局的scenario_manager_对象来进行场景管理，在PublicRoadPlanner初始化时会调用配置文件里的参数来建立这个对象。</p>\n<div>\n<pre><code class=\"language-cpp\">Status PublicRoadPlanner::Init(const PlanningConfig&amp; config) {\n  config_ = config;\n  scenario_manager_.Init(config);\n  return Status::OK();\n}</code></pre>\n</div>\n<p>调用ScenarioManager类的init()函数，并且根据当前planer的配置来注册场景。</p>\n<div>\n<pre><code class=\"language-cpp\">bool ScenarioManager::Init(\n    const std::set&lt;ScenarioConfig::ScenarioType&gt;&amp; supported_scenarios) {\n  // 注册场景\n  RegisterScenarios();\n  default_scenario_type_ = ScenarioConfig::LANE_FOLLOW;\n  supported_scenarios_ = supported_scenarios;\n  // 创建场景，默认为lane_follow\n  current_scenario_ = CreateScenario(default_scenario_type_);\n  return true;\n}</code></pre>\n</div>\n<p>目前PublicRoadPlanner支持下面这些场景</p>\n<div>\n<pre><code>// 还是在\"/conf/planning_config.pb.txt\"中\nstandard_planning_config {\n  planner_type: PUBLIC_ROAD\n  planner_type: OPEN_SPACE\n  planner_public_road_config {\n     // 支持的场景\n     scenario_type: LANE_FOLLOW  // 车道线保持\n     scenario_type: SIDE_PASS    // 超车\n     scenario_type: STOP_SIGN_UNPROTECTED  // 停止\n     scenario_type: TRAFFIC_LIGHT_PROTECTED    // 红绿灯\n     scenario_type: TRAFFIC_LIGHT_UNPROTECTED_LEFT_TURN  // 红绿灯左转\n     scenario_type: TRAFFIC_LIGHT_UNPROTECTED_RIGHT_TURN // 红绿灯右转\n     scenario_type: VALET_PARKING  // 代客泊车\n  }</code></pre>\n</div>\n<p>5、ScenarioManager类的Update()函数，用来决策当前处在什么场景。如果进入了新的场景，会创建一个新的对象来进行之后的规划逻辑。</p>\n<div>\n<pre><code class=\"language-cpp\">void ScenarioManager::Update(const common::TrajectoryPoint&amp; ego_point,\n                             const Frame&amp; frame) {\n  ACHECK(!frame.reference_line_info().empty());\n\n  Observe(frame);\n\n  ScenarioDispatch(frame);\n}</code></pre>\n</div>\n<p>场景决策逻辑在ScenarioDispatch(frame)当中，会根据配置选择基于规则还是基于学习的决策方法。</p>\n<div>\n<pre><code class=\"language-cpp\">void ScenarioManager::ScenarioDispatch(const Frame&amp; frame) {\n  ACHECK(!frame.reference_line_info().empty());\n  ScenarioConfig::ScenarioType scenario_type;\n\n  int history_points_len = 0;\n  if (injector_-&gt;learning_based_data() &amp;&amp;\n      injector_-&gt;learning_based_data()-&gt;GetLatestLearningDataFrame()) {\n    history_points_len = injector_-&gt;learning_based_data()\n                                  -&gt;GetLatestLearningDataFrame()\n                                  -&gt;adc_trajectory_point_size();\n  }\n  if ((planning_config_.learning_mode() == PlanningConfig::E2E ||\n       planning_config_.learning_mode() == PlanningConfig::E2E_TEST) &amp;&amp;\n      history_points_len &gt;= FLAGS_min_past_history_points_len) {\n    scenario_type = ScenarioDispatchLearning();\n  } else {\n    scenario_type = ScenarioDispatchNonLearning(frame);\n  }\n\n  ADEBUG &lt;&lt; \"select scenario: \"\n         &lt;&lt; ScenarioConfig::ScenarioType_Name(scenario_type);\n\n  // update PlanningContext\n  UpdatePlanningContext(frame, scenario_type);\n\n  if (current_scenario_-&gt;scenario_type() != scenario_type) {\n    current_scenario_ = CreateScenario(scenario_type);\n  }\n}</code></pre>\n</div>\n<p>6、ScenarioDispatchNonLearning()函数默认从lanefollow场景开始判断，首先根据驾驶员的意图来安排场景，如果不是默认的lanefollow场景，直接输出当前场景；如果是lanefollow场景，会依次判断是否属于别的场景；即剩余场景之间的跳转必须经过lanefollow这个场景。</p>\n<div>\n<pre><code class=\"language-cpp\">ScenarioConfig::ScenarioType ScenarioManager::ScenarioDispatchNonLearning(\n    const Frame&amp; frame) {\n  \n  // default: LANE_FOLLOW\n  ScenarioConfig::ScenarioType scenario_type = default_scenario_type_;\n  \n  // Pad Msg scenario\n  scenario_type = SelectPadMsgScenario(frame);\n\n  const auto vehicle_state_provider = injector_-&gt;vehicle_state();\n  common::VehicleState vehicle_state = vehicle_state_provider-&gt;vehicle_state();\n  const common::PointENU&amp; target_point =\n  frame.local_view().routing-&gt;routing_request().dead_end_info().target_point();\n  const common::VehicleState&amp; car_position = frame.vehicle_state();\n  if (scenario_type == default_scenario_type_) {\n    // check current_scenario (not switchable)\n    switch (current_scenario_-&gt;scenario_type()) {\n      case ScenarioConfig::LANE_FOLLOW:\n      case ScenarioConfig::PULL_OVER:\n        break;\n      case ScenarioConfig::BARE_INTERSECTION_UNPROTECTED:\n      case ScenarioConfig::EMERGENCY_PULL_OVER:\n      case ScenarioConfig::PARK_AND_GO:\n      case ScenarioConfig::STOP_SIGN_PROTECTED:\n      case ScenarioConfig::STOP_SIGN_UNPROTECTED:\n      case ScenarioConfig::TRAFFIC_LIGHT_PROTECTED:\n      case ScenarioConfig::TRAFFIC_LIGHT_UNPROTECTED_LEFT_TURN:\n      case ScenarioConfig::TRAFFIC_LIGHT_UNPROTECTED_RIGHT_TURN:\n      case ScenarioConfig::VALET_PARKING:\n      case ScenarioConfig::DEADEND_TURNAROUND:\n        // transfer dead_end to lane follow, should enhance transfer logic\n        if (JudgeReachTargetPoint(car_position, target_point)) {\n          scenario_type = ScenarioConfig::LANE_FOLLOW;\n          reach_target_pose_ = true;\n        }\n      case ScenarioConfig::YIELD_SIGN:\n        // must continue until finish\n        if (current_scenario_-&gt;GetStatus() !=\n            Scenario::ScenarioStatus::STATUS_DONE) {\n          scenario_type = current_scenario_-&gt;scenario_type();\n        }\n        break;\n      default:\n        break;\n    }\n  }\n  \n  // ParkAndGo / starting scenario\n  if (scenario_type == default_scenario_type_) {\n    if (FLAGS_enable_scenario_park_and_go &amp;&amp; !reach_target_pose_) {\n      scenario_type = SelectParkAndGoScenario(frame);\n    }\n  }\n\n  \n  // intersection scenarios\n  if (scenario_type == default_scenario_type_) {\n    scenario_type = SelectInterceptionScenario(frame);\n  }\n\n  \n  // pull-over scenario\n  if (scenario_type == default_scenario_type_) {\n    if (FLAGS_enable_scenario_pull_over) {\n      scenario_type = SelectPullOverScenario(frame);\n    }\n  }\n\n  \n  // VALET_PARKING scenario\n  if (scenario_type == default_scenario_type_) {\n    scenario_type = SelectValetParkingScenario(frame);\n  }\n  \n  // dead end\n  if (scenario_type == default_scenario_type_) {\n    scenario_type = SelectDeadEndScenario(frame);\n  }\n  \n  return scenario_type;\n}</code></pre>\n</div>\n<p>7、在场景判断时，首先调用函数SelectPadMsgScenario()，根据驾驶员意图来安排场景.</p>\n<div>\n<pre><code class=\"language-cpp\">ScenarioConfig::ScenarioType ScenarioManager::SelectPadMsgScenario(\n    const Frame&amp; frame) {\n  const auto&amp; pad_msg_driving_action = frame.GetPadMsgDrivingAction();\n  switch (pad_msg_driving_action) {\n    case DrivingAction::PULL_OVER:\n      if (FLAGS_enable_scenario_emergency_pull_over) {\n        return ScenarioConfig::EMERGENCY_PULL_OVER;\n      }\n      break;\n    case DrivingAction::STOP:\n      if (FLAGS_enable_scenario_emergency_stop) {\n        return ScenarioConfig::EMERGENCY_STOP;\n      }\n      break;\n    case DrivingAction::RESUME_CRUISE:\n      if (current_scenario_-&gt;scenario_type() ==\n              ScenarioConfig::EMERGENCY_PULL_OVER ||\n          current_scenario_-&gt;scenario_type() ==\n              ScenarioConfig::EMERGENCY_STOP) {\n        return ScenarioConfig::PARK_AND_GO;\n      }\n      break;\n    default:\n      break;\n  }\n  return default_scenario_type_;\n}</code></pre>\n</div>\n<p>8、<a name=\"scenario_update\"><span style=\"color:#494949;\">可以看到，除了驾驶员行为相关的两个场景外，每次切换场景必须是从默认场景(LANE_FOLLOW)开始，即每次场景切换之后都会回到默认场景。</span></a></p>\n<p style=\"text-align:center;\"><span style=\"color:#494949;\"><img alt=\"\" src=\"image\\f168864548e14357890e24ca8d7b2a0d.png\"/>​</span></p>\n<p></p>\n<p>9、以上即为apollo场景决策逻辑。后续文章会讲场景选择之后，怎么进行下一步的规划算法。</p>\n</div>\n</div>"}