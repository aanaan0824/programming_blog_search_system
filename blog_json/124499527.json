{"blogid": "124499527", "writerAge": "码龄2年", "writerBlogNum": "12", "writerCollect": "41", "writerComment": "1", "writerFan": "1", "writerGrade": "2级", "writerIntegral": "164", "writerName": "Ouchdex", "writerProfileAdress": "writer_image\\profile_124499527.jpg", "writerRankTotal": "76694", "writerRankWeekly": "799151", "writerThumb": "12", "writerVisitNum": "4869", "blog_read_count": "1912", "blog_time": "已于 2022-06-10 18:23:53 修改", "blog_title": "Unity 专业破坏效果插件 RayFire for Unity 入门教程（附插件资源链接）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-tomorrow-night-eighties\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h1><a id=\"Unity__RayFire_for_Unity__0\"></a>Unity 专业破坏效果插件 RayFire for Unity 入门教程</h1>\n<p><img alt=\"RayFire\" src=\"image\\920580956e3f40fc93210c8b57ca8407.png\"/></p>\n<blockquote>\n<p><strong>RayFire</strong> 是一款可以在运行时对 3D 对象进行无限次拆除或切片的插件，还可在编辑模式下对其进行预粉碎。<br/> 此外，RayFire 还可对模拟对象和拆除的片段提供<strong>高级动态模拟控制功能</strong>，比如在需要时将其激活。借助<strong>风力和旋风力</strong>，它可以实现<strong>射击、爆炸和侵袭</strong>，记录编辑器中的模拟并在运行时播放。</p>\n</blockquote>\n<ul><li><a href=\"https://assetstore.unity.com/packages/tools/game-toolkits/rayfire-for-unity-148690\">Unity Assets Store - Rayfire for Unity</a></li><li><a href=\"https://www.youtube.com/playlist?list=PLcjScvftXufKA-dLmqvokYnU7zFfKYWk0\">YouTube 官方教程播放列表（英文字幕）</a></li><li><a href=\"https://www.bilibili.com/video/BV1P64y197KC\">Bilibili 教程搬运（无字幕）</a>，感谢站友<a href=\"https://space.bilibili.com/179025849\">战神无名</a></li><li><a href=\"http://rayfirestudios.com/category/online-help-unity/\">官方网站帮助页面</a></li><li><a href=\"https://forum.unity.com/threads/released-rayfire-for-unity-runtime-demolition-and-fragmentation-plugin.674593/\">Unity 论坛页面</a></li><li><a href=\"https://discord.gg/8G98JKj\">Discord channel</a></li><li><a href=\"https://pan.baidu.com/s/1KXVmc5vI4kCJ_yd5H0RWJQ?pwd=ouch\">RayFire for Unity 离线资源下载</a></li></ul>\n<p>RayFire 需要 Unity 2018.4.34 或更高版本，请先安装支持的 Unity 编辑器。</p>\n<p>RayFire For Unity 的优点：</p>\n<ul><li>功能强大</li><li>快速上手</li><li>持续更新</li><li>缓存优化</li><li>全套官方视频教程</li></ul>\n<p>RayFire For Unity 的缺点：</p>\n<ul><li>170 美元的正式授权费用</li><li>高级功能学习成本较大</li><li>复杂场景需要高性能硬件</li><li>文档不够友好</li></ul>\n<h2><a id=\"_30\"></a>引子</h2>\n<blockquote>\n<p>本教程预期阅读和操作时间：2 ~ 3 小时</p>\n</blockquote>\n<p>RayFire 最初是 3DSMAX 中的一款用于制作破坏特效的强大插件，通过自动生成碎片模型减轻了模型师们的负担。后来，RayFire 官方推出了 Unity 插件版本，该插件不仅保留了破碎模型制作的功能，还为游戏工程师们简化了建模方面的流程，更包含了一系列高级运行时效果系统。</p>\n<p>如果你希望发布一款拥有非常炫酷破坏场景的战争游戏，或者只是想制作一款破坏类的解压小游戏，又或是通过 Unity 来渲染一些特效视频，RayFire for Unity 就是一个值得考虑的解决方案。</p>\n<p>好吧，口说无凭，如果这些不能打动你的话，可以看看下面这些使用到 RayFire 的成功商业案例。首先是官方宣传片——客户们的成品展示：</p>\n<p><a href=\"https://www.bilibili.com/video/BV1cx411c7eN\">点击前往 Bilibili 观看</a><br/> <a href=\"https://www.youtube.com/watch?v=ekqsMCrXZsQ\">点击前往油管观看</a></p>\n<p><img alt=\"RayFire customer showreel\" src=\"https://img-blog.csdnimg.cn/158a2aa2b7cc4755ac54378e4df59060.gif#pic_center\"/></p>\n<p>再来一段官方教程中的演示：</p>\n<p><a href=\"https://www.bilibili.com/video/BV1P64y197KC?p=2\">点击前往 Bilibili 观看</a><br/> <a href=\"https://www.youtube.com/watch?v=UFDiUy59qDU&amp;list=PLcjScvftXufKA-dLmqvokYnU7zFfKYWk0&amp;index=1\">点击前往油管观看</a></p>\n<p>接下来，让我们通过一个简短的教程初步了解如何使用 RayFire for Unity 。此教程使用的 Unity Editor 版本为 2020.3.22 LTS，推荐使用 Jetbrains Rider 作为开发 IDE，或为 Visual Studio 安装 ReSharper 扩展，我们需要写非常少量的 C# 代码。</p>\n<p><img alt=\"开发工具\" src=\"image\\04f762f515a44695a8fc61b4b64d1e4c.png\"/><br/> 本次教程最后会完成下面的场景：</p>\n<p><img alt=\"大爆炸\" src=\"https://img-blog.csdnimg.cn/041dfccbc2454266a71312cf4676e78d.gif#pic_center\"/></p>\n<h2><a id=\"_60\"></a>导入资源</h2>\n<p>从以下途径下载教程项目：</p>\n<ul><li><a href=\"https://github.com/RavingRua/RayFire-Tutorial\">GitHub</a></li><li><a href=\"https://gitee.com/ouchdex/RayFire-Tutorial\">Gitee</a></li></ul>\n<p>在正式开始之前，我们需要先将 <a href=\"https://assetstore.unity.com/packages/tools/game-toolkits/rayfire-for-unity-148690\">RayFire for Unity</a> 导入场景。如果你比较懒想跳过这部分，也可以直接下载打包好的<a href=\"https://pan.baidu.com/s/1WW7ehqPcpp4UfDdQj5nB0g?pwd=ouch\">项目压缩包</a>（有点大）。打开 Unity 包管理器，在\"我的资源\"中找到并导入 RayFire，或将本地已经下载的<code>.unitypackage</code>文件导入：</p>\n<p><img alt=\"导入 RayFire\" src=\"image\\3c1815ae4af945eeaf16e654d73db23e.png\"/></p>\n<p>导入全部内容，并将项目根目录下的<code>Rayfire</code>文件夹移动到<code>Vendors</code>文件夹中：</p>\n<p><img alt=\"RayFire 内容\" src=\"image\\d4abe9e1caf94d38a9d28a5d62538579.png\"/></p>\n<p>然后重新导入所有资源，重启 Unity Editor：</p>\n<p><img alt=\"重新导入所有资源\" src=\"image\\a2bab50deeaa4d9ca8002f6ad808067a.png\"/><br/> 说明：</p>\n<ul><li><code>Info</code>：RayFire 的文档、许可证书和说明文件，如果需要在生产环境中使用，务必仔细阅读许可证书说明；</li><li><code>Plugins</code>：各个平台需要的运行时资源，RayFire for Unity 支持 Windows 、Mac OS X 、Linux 、Android 、iOS 以及 Web 平台，运行时计算功能暂时不支持 Web；</li><li><code>Scripts</code>：核心脚本文件；</li><li><code>Tutorial</code>：官方教程场景，如果需要将插件用于生产环境，强烈建议跟随官方教程视频全部练习一遍。</li></ul>\n<blockquote>\n<p><a href=\"https://pan.baidu.com/s/1KXVmc5vI4kCJ_yd5H0RWJQ?pwd=ouch\">RayFire for Unity 离线资源下载</a>，仅供学习交流！请支持原作者，前往 Unity Assets Store 购买最新版的在线版许可。</p>\n<p>据我国《计算机软件保护条例》第十七条规定：“为了学习和研究软件内含的设计思想和原理，通过安装、显示、传输或者存储软件等方式使用软件的，可以不经软件著作权人许可，不向其支付报酬。”</p>\n</blockquote>\n<h2><a id=\"__90\"></a>第一步 处理素材</h2>\n<p>在 3DSMAX 中，我们可以使用 RayFire 为物体自动生成破碎模型，然后打包成 FBX 格式为 Unity 使用。使用 RayFire for Unity 同样可以 Unity Editor 中生成我们需要的破碎素材。</p>\n<p>打开<code>/Scenes/01</code>场景，我们已经在场景中放置了一颗不起眼的手榴弹对象<code>RGD-5</code>，到目前为止它还没有任何危险性，模型也是“铁板一块”的：</p>\n<p><img alt=\"RGD-5\" src=\"image\\1d92607c1a37441a9a648f95302b72a4.png\"/><br/> 观察预制件<code>RGD-5</code>的层级，可以发现其由弹体、保险环、保险杆组成，我们需要对弹体进行切片以模拟效果。</p>\n<p><img alt=\"手榴弹的层级\" src=\"image\\5840be9963d84656beb4a01db8091de5.png\"/></p>\n<h3><a id=\"_100\"></a>添加组件</h3>\n<p>使用<code>RayFire Shatter</code>组件进行分离处理。选中对象<code>RGD-5</code>，打开检查器，选择添加组件，找到<code>RayFire-&gt;RayFire Shatter</code>，添加：</p>\n<p><img alt=\"RayFire Shatter\" src=\"image\\b4233d8c804f42d0b592981d8b9e8fad.png\"/></p>\n<p>现在看到的组件控制面板，可以发现有一组令人头大的配置参数，这些参数对应了每种碎片生成类型。由于只是入门教程，这里不会细讲所有类型和其参数，官方教程中很详细地讲解了这些类型和参数的配置。</p>\n<p><img alt=\"切片类型\" src=\"image\\bee931e4bab9439c9647eb9b18aad41f.png\"/></p>\n<h3><a id=\"_110\"></a>开始切片</h3>\n<p>点击<code>Fragment</code>按钮即可进行切片，注意<code>RayFire Shatter</code>只会对所在对象切片，而不会影响子组件。RayFire 会在切片对象所在的层级中新生成一个名为<code>RGD-5_roots</code>的新对象，这个对象下包含了所有的碎片：</p>\n<p><img alt=\"处理后结果\" src=\"image\\19cc78fb2d3f48359b391f2607cad185.png\"/></p>\n<p>回到<code>RGD-5</code>对象上，此时编辑器面板中的碎片并没有显示出来。可以看到，在切片之后组件控制面板中多出了一些控件，拉伸<code>Scale View</code>滑动条，RayFire 会关闭切片前对象的网格渲染，并对碎片对象进行缩放，我们可以看到切片后的效果：</p>\n<p><img alt=\"查看所有碎片\" src=\"image\\3ecd2a6b851046cdb5e30c1662925506.png\"/></p>\n<p>点击<code>Delete Last</code>可以删除上一次切片结果，即删除生成的碎片游戏对象。</p>\n<p>如果觉得切片后的模型内部颜色比较奇怪，可以在<code>Material</code>参数中设置切片内侧的材质：</p>\n<p><img alt=\"材质选项\" src=\"image\\737c871d0fbf46aeb9ffe2b4b0009b6b.png\"/></p>\n<p>对同一对象重复切片将产生同样的结果，要产生不同的结果，在<code>Advance</code>参数项中修改随机种子：</p>\n<p><img alt=\"种子\" src=\"image\\cb0998a747bc4b5f985d9a6096463b9d.png\"/></p>\n<h3><a id=\"_130\"></a>切片类型</h3>\n<p>下面是每种切片类型的简单预览，标题链接到对应的教程视频。每项切片参数都有英文悬浮注释，文档中的解释也不过如此（文档真的不太行，还是推荐看视频）。</p>\n<p><a href=\"https://www.youtube.com/watch?v=qJ6NVrB1SNk&amp;list=PLcjScvftXufKA-dLmqvokYnU7zFfKYWk0&amp;index=2\">Voronoi（泰森多边形）</a>：对于比较随意的切片可以使用此类型。参数<code>Amount</code>决定生成的碎片数量，<code>Center Bias</code>决定了模型中心碎片的大小：</p>\n<p><img alt=\"Voronoi\" src=\"image\\27e619355a114d9891c4ec432c9f6cf6.png\"/><br/> <img alt=\"预览\" src=\"image\\85df11518b29422a8e0224291da45287.png\"/></p>\n<p><a href=\"https://www.youtube.com/watch?v=GyqYus7mH78&amp;list=PLcjScvftXufKA-dLmqvokYnU7zFfKYWk0&amp;index=3\">Splinters（尖碎片）</a>：参数<code>Axis</code>可以指定切片方向：</p>\n<p><img alt=\"Splinters\" src=\"image\\efae777bc18d4683932af9c668fc91b9.png\"/><br/> <img alt=\"预览\" src=\"image\\22cd1d69cdfe43b8ac9f6a77eb7a3694.png\"/><br/> <a href=\"https://www.youtube.com/watch?v=GlZl93WvzHs&amp;list=PLcjScvftXufKA-dLmqvokYnU7zFfKYWk0&amp;index=4\">Slabs（石板）</a>：<br/> <img alt=\"预览\" src=\"image\\103ceef801384c26b90a934ed5801ca4.png\"/></p>\n<p><a href=\"https://www.youtube.com/watch?v=GlZl93WvzHs&amp;list=PLcjScvftXufKA-dLmqvokYnU7zFfKYWk0&amp;index=4\">Radial（放射状）</a>：<br/> <img alt=\"预览\" src=\"image\\a528bd8b9f754bcea31f8110c090be06.png\"/></p>\n<p><a href=\"https://www.youtube.com/watch?v=4TuIgnkczag&amp;list=PLcjScvftXufKA-dLmqvokYnU7zFfKYWk0&amp;index=6\">Custom（自定义）</a>：此类型的使用建议参考视频。</p>\n<p><a href=\"https://www.youtube.com/watch?v=QKkBr5l0p88&amp;list=PLcjScvftXufKA-dLmqvokYnU7zFfKYWk0&amp;index=8\">Tets（四面体）</a>：此模式在默认<code>Density</code>（密度）参数为 7 时会产生大量碎片，建议调低该参数。<br/> <img alt=\"预览\" src=\"image\\00ef45c221b742f0ab1fa8313d273b81.png\"/></p>\n<p><a href=\"https://www.youtube.com/watch?v=JUcQtUGCuRU&amp;list=PLcjScvftXufKA-dLmqvokYnU7zFfKYWk0&amp;index=7\">Slices（片）</a>：此类型的使用建议参考视频。</p>\n<p>Decompose（解体）：解体切片比较实用，可以很方便将整体模型分开，然后对分离的各部分再次切片，在对象只有单一网格时无效。</p>\n<p><img alt=\"解体前\" src=\"image\\2a3c54702ef6489f8a021a588bc2a640.png\"/><br/> <img alt=\"解体后\" src=\"image\\d33cec94213f4b48a902f6169505f229.png\"/></p>\n<h3><a id=\"_162\"></a>保存切片</h3>\n<p>为了能够重复使用我们的劳动成果，切片后的结果应该被保存为预制件，这样就不需要每次都为同样的物体制作切片了。RayFire for Unity 支持使用<code>RayFire Rigid</code>组件进行运行时的碎片生成，但是这么做会带来比较大的内存和运算开销，最好的做法是直接保存<code>RayFire Shatter</code>生成的静态资源。</p>\n<p>在 Unity 中，预制体在编辑器和游戏中实例化的过程涉及数据的反序列化。<code>RayFire Shatter</code>组件生成的碎片对象的顶点（即 Mesh 文件中的信息）被直接绑定在对象上，这些碎片的网格信息对应的信息可以在单个场景中存在，但并不会在游戏对象生成预制件时被序列化保存。如果直接将碎片序列化为预制件，下一次反序列化预制件时，顶点数据将全部丢失。</p>\n<p>因此，我们需要手动保存这些顶点数据。RayFire 的作者推荐两种保存数据的方法：导出为 FBX 文件或单独导出 Mesh 。</p>\n<h4><a id=\"_FBX_170\"></a>导出为 FBX</h4>\n<p>要<a href=\"https://www.youtube.com/watch?v=lKPi6mt6yRI&amp;list=PLcjScvftXufKA-dLmqvokYnU7zFfKYWk0&amp;index=10\">导出为 FBX 文件</a>，首先需要安装 Unity 官方提供的工具 FBX Exporter 。打开 Unity 包管理器，选择 Unity 注册表，找到 FBX Exporter 并安装导入：</p>\n<p><img alt=\"Unity 注册表中的包\" src=\"image\\0a2597a4a02848bca4c35e9cca4be595.png\"/></p>\n<p>右键<code>RayFire Shatter</code>生成的游戏对象，点击<code>Export To FBX</code>：</p>\n<p><img alt=\"导出为 FBX\" src=\"image\\a903de63582a4ea2a31dbc52c0e6f6db.png\"/></p>\n<p>如果没有特殊需求，直接导出：</p>\n<p><img alt=\"导出参数\" src=\"image\\62dedcebad934d779aba784d0f00c4a4.png\"/><br/> 可以看到碎片模型已经被成功导出：<br/> <img alt=\"导出后结果\" src=\"image\\315a2e078ec94767a257458312195019.png\"/><br/> FBX 方案的主要问题在于，导出后的碎片模型和原模型不能共享素材，这会导致占用过多的空间并产生信息冗余，因此一般会推荐使用第二种方案：单独导出 Mesh 。</p>\n<h4><a id=\"_Mesh_187\"></a>单独导出 Mesh</h4>\n<p>要<a href=\"https://www.youtube.com/watch?v=pQcN2FFfwy4&amp;list=PLcjScvftXufKA-dLmqvokYnU7zFfKYWk0&amp;index=11\">单独导出网格中的顶点信息</a>，选择原模型的<code>RayFire Shatter</code>组件，找到<code>Export to asset</code>一栏。我们可以为导出的 Mesh 文件确定后缀，默认情况下导出的 Mesh 文件名称为<code>对象名_frags</code>。为了方便管理素材，我们将已经切片的模型放置在<code>ShatteredObjects</code>文件夹中，预制件存放于<code>ShatteredObjects/Prefabs</code>，网格文件存放于<code>ShatteredObjects/Meshs</code>：</p>\n<p><img alt=\"导出为 Mesh\" src=\"image\\d82792c07e7d4438857f94140b51d737.png\"/><br/> RayFire 会自动地为对象链接资源，现在我们可以放心地将对象导出为预制件了，将层级面板中的<code>RGD-5_roots</code>拖放到资源面板中的<code>ShatteredObjects/Prefabs</code>文件夹中：</p>\n<p><img alt=\"导出结果\" src=\"image\\3a8a9d26df974b9781b0f68bc3f9c014.png\"/><br/> 预制件只产生额外的网格信息，而不会产生其他资源的副本。</p>\n<h3><a id=\"_197\"></a>保存预制件</h3>\n<p>由于之前处理的只是手榴弹的弹体，最后导出的碎片模型和作为子对象的保险杆以及保险环分离了。建立一个空对象，把弹体、引信和拉环装配在一起：<br/> <img alt=\"制作手榴弹预制件\" src=\"image\\ddede7e9902f43699baabb9236a163fe.png\"/><br/> 保险的位置微调比较麻烦，我们可以右键原对象的<code>Transform</code>组件直接复制位置：</p>\n<p><img alt=\"复制位置\" src=\"image\\8229e93a414e45cca5480b32e56704b4.png\"/><br/> 然后粘贴到新的手榴弹上：</p>\n<p><img alt=\"粘贴位置\" src=\"image\\268aed5ef7574807aa29a45ed68c0c10.png\"/><br/> 保存为预制件<code>ShatteredObjects/Prefabs/RGD-5-Shattered</code>：<br/> <img alt=\"保存结果\" src=\"image\\99445950fe3a4aa3b7834131daae09fa.png\"/></p>\n<h2><a id=\"__209\"></a>第二步 处理预制件</h2>\n<p>我们已经制作了带有碎片的手榴弹模型，但也仅仅是个模型，没有物理效果的手榴弹连砸死人都做不到。现在，为手榴弹预制件添加物理效果。RayFire 为我们提供集成了 Unity 原生<code>Rigid</code>刚体组件特性的<code>RayFire Rigid</code>组件，选中<code>RGD-5-Shattered</code>对象，为其添加该组件：</p>\n<p><img alt=\"RayFire Rigid\" src=\"image\\a7ed04c4ce864952afd9b4187eef4e96.png\"/><br/> <img alt=\"RayFire Rigid\" src=\"image\\9c1307a7327d4878811758a48afedb15.png\"/><br/> 又是一大堆令人头疼的参数，官方教程视频详细地讲解了各个部分，这里仅做一些简单的介绍。</p>\n<h3><a id=\"RayFire_Rigid_217\"></a>RayFire Rigid</h3>\n<p><code>RayFire Rigid</code>组件为对象添加物理效果，并控制破碎的生效。</p>\n<p>下面介绍一些常用的配置参数：</p>\n<ul><li> <p>Initialization：刚体初始化的方式，共有两种：</p>\n<ul><li>By Method：由 C# 脚本中的逻辑激活，在编辑器中也可使用组件控制面板上的按钮激活；</li><li>At Start：游戏对象实例化时就激活。</li></ul> <p><code>RayFire Rigid</code>的功能只有在初始化后才会生效，未激活前的对象在场景中不会有任何物理效果。</p> </li><li> <p>Simulation Type：对象物理模拟的方式，总共有五种，官方教程演示了各种效果：<a href=\"https://www.bilibili.com/video/BV1P64y197KC?p=15\">Bilibili</a>，<a href=\"https://www.youtube.com/watch?v=KZ8h9F45lkM&amp;list=PLcjScvftXufKA-dLmqvokYnU7zFfKYWk0&amp;index=14\">油管</a>。可以在 RayFire 的教程目录中找到介绍该属性的场景：</p>\n<ul><li>Dynamic：刚体组件一旦激活就响应所有物理效果，该方式有时会导致物体被意外激活和破碎；</li><li>Sleeping：刚体组件在受到物理外力后才被激活并产生物理效果；</li><li>Inactive：类似 Sleeping，但是碎片在受到物理外力后不会产生物理效果，而是会被推离初始位置，直到被一些条件激活，条件在<code>Activation</code>项中设置。适合一些建筑破坏场景中的“藕断丝连”效果；</li><li>Kinematic：对象不会被其他物体激活，也不会受到外力影响而移动，但是可以影响其他带物理效果的物体，直到被一些条件激活。适合当<code>Inactive</code>导致模型嵌套的对象发生鬼畜的情况。</li></ul> </li><li> <p>Object Type：对象类型将决定刚体组件如何生效，官方教程演示了各种效果：<a href=\"https://www.bilibili.com/video/BV1P64y197KC?p=16\">Bilibili</a>，<a href=\"https://www.youtube.com/watch?v=fbVG1Y0RoBY&amp;list=PLcjScvftXufKA-dLmqvokYnU7zFfKYWk0&amp;index=15\">油管</a>。有以下类型：</p>\n<ul><li>Mesh：当对象含有网格数据，并是要被破坏的物体时，选择该类型；</li><li>Mesh Root：当对象是一个包含一组需要被破坏的对象的父对象时，使用该类型，RayFire 会自动为所有子对象添加<code>RayFire Rigid</code>组件，如果是 Mesh，则要手动添加；</li><li>Nested Cluster：对象是一个包含一组需要被破坏的父对象，且被包含的对象同样有父子层级，构成多层树结构，需要按层级进行多次破坏时，选择该类型。RayFire 会在每层破坏后为所有子对象添加<code>RayFire Rigid</code>组件；</li><li>Connected Cluster：当对象是一个包含一组需要被破坏的对象的父对象，并且不存在多层级，但是需要按部位破坏时，使用该类型。Mesh Root 和 Nested Cluster 会在一次碰撞后整体破碎，但 Connected Cluster 只有撞击部位附近的碎片会脱离。</li></ul> </li><li> <p>Physic：决定对象的物理属性：</p>\n<ul><li>Material Type：可以设置为一组 RayFire 预设材质类型，这些材质中有一些默认是不会因外力而导致破坏的；</li><li>Material：指定 Unity 中的材质；</li></ul> </li><li> <p>Fading：决定对象在被破坏之后如何消失：</p>\n<ul><li>Initiate：哪些碎片会消失，<code>On Demolition</code>只有被破坏的部分会消失，<code>On Activation</code>所有部分都会消失；</li><li>Life： \n    <ul><li>Life Type：生存时长计算类型，<code>By Life Time</code>表示对象一旦破坏就开始计时，<code>By Simulation And Life Time</code>在对象不再与外界发生物理交互后消失；</li><li>Life Time：生存时长，超过该时长后对象消失；</li><li>Life Variation：生存时长的上下波动范围。</li></ul> </li><li>Fade： \n    <ul><li>Fade Type：对象如何消失，向下移动、缩小、失去物理交互能力等；</li><li>Fade Time：消失过程时长；</li><li>Size Filter：大小小于该值的对象才会消失。</li></ul> </li></ul> </li></ul>\n<h3><a id=\"RayFire_Man_258\"></a>RayFire Man</h3>\n<p><code>RayFire Man</code> Manager 组件用于设置一组全局参数，这些参数将影响到场景中的所有物体。我们可以创建一个空对象<code>RayFireMan</code>作为游戏逻辑控制机，然后将<code>RayFire Man</code>组件挂载到它上面：</p>\n<p><img alt=\"RayFire Man\" src=\"image\\740aaf85cf7a4d9196e9046f861ec4d1.png\"/><br/> 在<code>Material Presets</code>一栏中，可以看到一些材料预设。金属材料是无法被外力破坏的，但是可以被脚本破坏，我们可以利用这一点。</p>\n<p><img alt=\"Material Type\" src=\"image\\9a0496bc0da84cdabb1ab8c8c1758bcd.png\"/></p>\n<h3><a id=\"_267\"></a>为手榴弹设置参数</h3>\n<p>现在考虑手榴弹有哪些特征：</p>\n<ul><li>由一个空对象挂载三个子对象，其中弹体子对象又有一组弹片子对象；</li><li>手榴弹被人为引爆而不是自爆，也不会一摔就坏；</li><li>引爆时破碎。</li></ul>\n<p>根据这些特征，设置<code>RayFire Rigid</code>的参数：</p>\n<p><img alt=\"设置参数\" src=\"image\\49ba2628167b4ad3918778ddd7ddd319.png\"/></p>\n<ul><li>Initialization：手动激活手榴弹的物理效果，选择<code>By Method</code>。在实际游戏中，手榴弹在扔出去之前应该无视物理效应跟随玩家手臂移动，虽然在该教程中我们并不会这么做；</li><li>Simulation Type：手榴弹被激活后应该始终有物理效果，<code>Dynamic</code>；</li><li>Object Type：手榴弹要先松开并弹出保险，然后再爆炸，包含两层破坏效果，因此选择<code>Nested Cluster</code>；</li><li>Demolition Type：将此项设置为<code>Runtime</code>，对象才会破坏；</li><li>Material Type：<code>Light Metal</code>默认不能被外力破坏，也符合现实中手榴弹的材质。</li></ul>\n<p>由于我们将 Object Type 设置为了<code>Nested Cluster</code>，在运行前最好先进行初始化，点击<code>Setup Cluster</code>，出现连接状态即可。如果没有手动设置，对象在实例化时 RayFire 也会自动设置连接，但这会额外消耗一些运行时资源：</p>\n<p><img alt=\"初始化\" src=\"image\\da7967bfbc36453096f062c465cd4a8b.png\"/><br/> 注意：如果对象下的层级发生变化，需要重置 Cluster ，否则 RayFire 会给出警告。</p>\n<h3><a id=\"_289\"></a>测试一下</h3>\n<p>运行场景，可以看到手榴弹悬浮在空中，并没有被激活。点击<code>RayFire Rigid</code>面板中的<code>Initialize</code>按钮手动激活，可以看到手榴弹受重力影响掉落，但是在碰撞时没有被破坏；点击<code>Demolish</code>按钮，观看效果，可以发现保险装置脱出；找到<code>RGD-5_roots</code>对象，点击<code>Demolish</code>按钮，可以看到弹体破碎了：</p>\n<p><img alt=\"测试一下\" src=\"https://img-blog.csdnimg.cn/0c51ec951df24116b1f7f264e872bd03.gif#pic_center\"/></p>\n<h2><a id=\"__296\"></a>第三步 艺术就是爆炸</h2>\n<p>现在，我们的玩具离成为真正的手榴弹只差最后一步：添加真正的爆炸效果。RayFire 很贴心地准备了<code>RayFire Bomb</code>、<code>RayFire Sound</code>和<code>RayFire Dust</code>组件，只需一些简单的步骤，外加最少的脚本，就可以让手榴弹同时具备爆炸、烟尘、火光和声音效果。</p>\n<h3><a id=\"_300\"></a>添加烟尘</h3>\n<p>打开场景<code>03</code>，选中<code>RGD-5-Shattered</code>对象，找到并添加<code>RayFire Dust</code>组件：</p>\n<p><img alt=\"RayFire Dust\" src=\"image\\a46823ec7e5b4bd287dd9f1600eda423.png\"/><br/> <img alt=\"参数\" src=\"image\\cd337f5c47134f78ad89bedaf5b51ccf.png\"/><br/> <code>Emit Dust</code>项决定在什么时候产生烟尘效果，分别是在破坏时、激活时或受到外力影响时。在<code>Dust Materials</code>项中，可以指定多种烟尘材质，这里使用 RayFire 教程场景中的材质<code>dust_1_m</code>、<code>dust_2_m</code>和<code>dust_3_m</code>：</p>\n<p><img alt=\"设置粒子材质\" src=\"image\\c5d7276965654ce08b0c3dce1699c946.png\"/><br/> 现在把该组件删除，因为我们之后要引入一个带有更好效果的爆炸特效。在处理环境对象时会再次用到烟尘。</p>\n<h3><a id=\"_311\"></a>添加音效</h3>\n<p>选中<code>RGD-5_roots</code>对象，找到并添加<code>RayFire Sound</code>组件：</p>\n<p><img alt=\"RayFire Sound\" src=\"image\\085b8de7922842638f58a5c0ff39fce8.png\"/><br/> 可以看到在初始化时、激活时、破坏时均可添加音效。现在为手榴弹弹体添加一组爆炸音效，这些音效会随机播放，音效文件可以在<code>AudioClips</code>文件夹中找到：</p>\n<p><img alt=\"设置声音效果\" src=\"image\\c719c384e4b54502ba2048de2e08dab7.png\"/><br/> 然后为<code>RGD-5-Shattered</code>添加一组拉环音效：</p>\n<p><img alt=\"设置音效\" src=\"image\\4823e44bfb424f9eb17f4f807332da8c.png\"/></p>\n<h3><a id=\"_323\"></a>添加爆炸</h3>\n<p><code>RayFire Bomb</code>组件模拟爆炸产生的冲击波和冲击影响。在预制件编辑面板中为<code>RGD-5_roots</code>添加该组件：</p>\n<p><img alt=\"RayFire Bomb\" src=\"image\\c1844ddb510e4888a64d01b88f604a4b.png\"/></p>\n<p>可以在检查器控制面板中设置炸弹的参数，并添加音效。因为该组件只能添加一种音效，选择之前使用<code>RayFire Sound</code>组件为弹体在破坏时添加一组随机音效。</p>\n<p>为了在之后模拟爆炸冲击波损伤效果，将<code>Apply Damage</code>勾选，设置<code>Damage Value</code>为<code>100</code>：</p>\n<p><img alt=\"爆炸伤害\" src=\"image\\f813bd3dc9864fd1b9b88fcdcb05dc72.png\"/></p>\n<p>我们使用<a href=\"https://assetstore.unity.com/packages/vfx/particles/stylized-explosion-pack-1-79037\">Stylized Explosion Pack</a>中提供的内容为手榴弹添加爆炸效果。在<code>Prefabs/Explosion/</code>下有三个爆炸效果预制件，每个预制件都带有一个<code>DestroyMe</code>脚本，可以设置其播放后销毁时间：</p>\n<p><img alt=\"Destroy Me\" src=\"image\\637233417502487bbbb0d6473fa0e78b.png\"/></p>\n<p>手榴弹仅靠这些组件还无法正常运作。接下来，用一些“胶水”代码实现我们的爆炸效果。</p>\n<h3><a id=\"_341\"></a>设置脚本逻辑</h3>\n<p>手榴弹爆炸的过程包括几个步骤：</p>\n<ol><li>弹开保险；</li><li>引信点火；</li><li>爆炸。</li></ol>\n<p>对应的，我们需要两个类：</p>\n<ul><li><code>Grenade</code>类：负责弹开保险，并通知引信点火，相当于手榴弹对象；</li><li><code>Bomb</code>类：通用的炸药类，可以点火、设置引信长度、引爆自身。</li></ul>\n<p>现在创建两个脚本<code>Grenade</code>和<code>Bomb</code>，将它们分别挂载到<code>RGD-5-Shattered</code>对象和<code>RGD-5_roots</code>对象上，并指定需要的引用。</p>\n<p><code>Grenade</code>：</p>\n<pre><code class=\"prism language-cs\"><span class=\"token keyword\">using</span> <span class=\"token namespace\">UnityEngine</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> <span class=\"token namespace\">RayFire</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">namespace</span> <span class=\"token namespace\">Scripts</span>\n<span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Grenade</span> <span class=\"token punctuation\">:</span> <span class=\"token type-list\"><span class=\"token class-name\">MonoBehaviour</span></span>\n    <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token keyword\">public</span> <span class=\"token class-name\">RayfireRigid</span> grenade<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 手榴弹对象</span>\n        <span class=\"token keyword\">public</span> <span class=\"token class-name\">Bomb</span> bomb<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 炸弹脚本</span>\n        <span class=\"token keyword\">public</span> <span class=\"token class-name\"><span class=\"token keyword\">float</span></span> fuseTime<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 引信时间（秒）</span>\n\n        <span class=\"token comment\">// 按 G 松开保险</span>\n        <span class=\"token keyword\">private</span> <span class=\"token return-type class-name\"><span class=\"token keyword\">void</span></span> <span class=\"token function\">DebugIgnite</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{<!-- --></span>\n            <span class=\"token function\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"[Debug] Ignite a grenade!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token function\">Ignite</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token comment\">// 通知炸药点火</span>\n        <span class=\"token keyword\">private</span> <span class=\"token return-type class-name\"><span class=\"token keyword\">void</span></span> <span class=\"token function\">Ignite</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{<!-- --></span>\n            grenade<span class=\"token punctuation\">.</span><span class=\"token function\">Initialize</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            grenade<span class=\"token punctuation\">.</span><span class=\"token function\">Demolish</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            bomb<span class=\"token punctuation\">.</span><span class=\"token function\">Ignite</span><span class=\"token punctuation\">(</span>fuseTime<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">private</span> <span class=\"token return-type class-name\"><span class=\"token keyword\">void</span></span> <span class=\"token function\">Update</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{<!-- --></span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>Input<span class=\"token punctuation\">.</span><span class=\"token function\">GetKey</span><span class=\"token punctuation\">(</span>KeyCode<span class=\"token punctuation\">.</span>G<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token function\">DebugIgnite</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p><img alt=\"挂载脚本\" src=\"image\\9030081965224d359f7cedb36ec9b71d.png\"/></p>\n<p><code>Bomb</code>：</p>\n<pre><code class=\"prism language-cs\"><span class=\"token keyword\">using</span> <span class=\"token namespace\">System<span class=\"token punctuation\">.</span>Collections</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> <span class=\"token namespace\">RayFire</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> <span class=\"token namespace\">UnityEngine</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">namespace</span> <span class=\"token namespace\">Scripts</span>\n<span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Bomb</span> <span class=\"token punctuation\">:</span> <span class=\"token type-list\"><span class=\"token class-name\">MonoBehaviour</span></span>\n    <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token keyword\">public</span> <span class=\"token class-name\">GameObject</span> bombBody<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 弹体对象</span>\n        <span class=\"token keyword\">public</span> <span class=\"token class-name\">RayfireBomb</span> rayfireBomb<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 需要引爆的 RayfireBomb</span>\n        <span class=\"token keyword\">public</span> <span class=\"token class-name\">GameObject</span> explosion<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 爆炸效果对象</span>\n\n        <span class=\"token comment\">// 手榴弹点火</span>\n        <span class=\"token keyword\">public</span> <span class=\"token return-type class-name\"><span class=\"token keyword\">void</span></span> <span class=\"token function\">Ignite</span><span class=\"token punctuation\">(</span><span class=\"token class-name\"><span class=\"token keyword\">float</span></span> fuseTime<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{<!-- --></span>\n            <span class=\"token function\">StartCoroutine</span><span class=\"token punctuation\">(</span><span class=\"token function\">ExplodeCoroutine</span><span class=\"token punctuation\">(</span>fuseTime<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 引信点火</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">private</span> <span class=\"token return-type class-name\">IEnumerator</span> <span class=\"token function\">ExplodeCoroutine</span><span class=\"token punctuation\">(</span><span class=\"token class-name\"><span class=\"token keyword\">float</span></span> fuseTime<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{<!-- --></span>\n            <span class=\"token keyword\">yield</span> <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token constructor-invocation class-name\">WaitForSeconds</span><span class=\"token punctuation\">(</span>fuseTime<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 引信时间</span>\n            <span class=\"token function\">Explode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 爆炸</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">private</span> <span class=\"token return-type class-name\"><span class=\"token keyword\">void</span></span> <span class=\"token function\">Explode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{<!-- --></span>\n            bombBody<span class=\"token punctuation\">.</span><span class=\"token generic-method\"><span class=\"token function\">GetComponent</span><span class=\"token generic class-name\"><span class=\"token punctuation\">&lt;</span>RayfireRigid<span class=\"token punctuation\">&gt;</span></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">Demolish</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 弹体破碎</span>\n            rayfireBomb<span class=\"token punctuation\">.</span><span class=\"token function\">Explode</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 产生冲击波</span>\n\n            <span class=\"token class-name\"><span class=\"token keyword\">var</span></span> exp <span class=\"token operator\">=</span> <span class=\"token function\">Instantiate</span><span class=\"token punctuation\">(</span>explosion<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            exp<span class=\"token punctuation\">.</span>transform<span class=\"token punctuation\">.</span>position <span class=\"token operator\">=</span> transform<span class=\"token punctuation\">.</span>position<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 设置位置</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p><img alt=\"挂载脚本\" src=\"image\\0907da1d8dc64436a33c98a46f8b3237.png\"/></p>\n<h3><a id=\"RayFire__435\"></a>RayFire 脚本事件</h3>\n<p>RayFire 内部实现了一个事件系统，我们可以使用脚本为每个事件添加一组事件处理程序（钩子）。以爆炸和破坏事件为例，RayFire 提供两个类<code>RFDemolitionEvent</code>和<code>RFExplosionEvent</code>用于注册这些事件。这些事件可以用于实现游戏逻辑，并方便我们调试程序。</p>\n<p>要添加事件处理程序，在两个类的<code>GlobalEvent</code>事件上使用<code>+=</code>操作符注册委托（C# 的类型安全回调函数）。创建一个<code>EventManager</code>脚本和对象来管理场景中的事件：</p>\n<p><img alt=\"EventManager\" src=\"image\\288488657b0d4a609ca0ff5db9d89e4b.png\"/><br/> <img alt=\"EventManager\" src=\"image\\2fb3b93ca7a048a9953f3528f42871d4.png\"/></p>\n<pre><code class=\"prism language-cs\"><span class=\"token keyword\">using</span> <span class=\"token namespace\">UnityEngine</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">using</span> <span class=\"token namespace\">RayFire</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">namespace</span> <span class=\"token namespace\">Scripts</span>\n<span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">EventManager</span> <span class=\"token punctuation\">:</span> <span class=\"token type-list\"><span class=\"token class-name\">MonoBehaviour</span></span>\n    <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token comment\">// 注册事件</span>\n        <span class=\"token keyword\">private</span> <span class=\"token return-type class-name\"><span class=\"token keyword\">void</span></span> <span class=\"token function\">Awake</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{<!-- --></span>\n            <span class=\"token comment\">// Debug：当对象别破坏时通知</span>\n            RFDemolitionEvent<span class=\"token punctuation\">.</span>GlobalEvent <span class=\"token operator\">+=</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">RayfireRigid</span> rigid<span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span>\n                <span class=\"token function\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"[Debug] Game Object \"</span> <span class=\"token operator\">+</span> rigid<span class=\"token punctuation\">.</span>gameObject<span class=\"token punctuation\">.</span>name <span class=\"token operator\">+</span> <span class=\"token string\">\" is destroyed!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\">// Debug：当炸弹爆炸时通知</span>\n            RFExplosionEvent<span class=\"token punctuation\">.</span>GlobalEvent <span class=\"token operator\">+=</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">RayfireBomb</span> bomb<span class=\"token punctuation\">)</span> <span class=\"token operator\">=&gt;</span>\n                <span class=\"token function\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"[Debug] Game Object \"</span> <span class=\"token operator\">+</span> bomb<span class=\"token punctuation\">.</span>gameObject<span class=\"token punctuation\">.</span>name <span class=\"token operator\">+</span> <span class=\"token string\">\" is exploded!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>观看<a href=\"https://www.youtube.com/watch?v=lRlqcHGA1sI&amp;list=PLcjScvftXufKA-dLmqvokYnU7zFfKYWk0&amp;index=30\">官方教程</a>获取更详细的事件说明。</p>\n<h3><a id=\"_467\"></a>测试一下</h3>\n<p>运行场景，按下键盘<code>G</code>键，等待 3 秒，Boom!：</p>\n<p><img alt=\"测试一下\" src=\"https://img-blog.csdnimg.cn/4816e6137fa8406e86593fdcf18aff7a.gif#pic_center\"/></p>\n<p>现在，我们的小玩具真正成为了大杀器。多亏了 RayFire，需要的代码甚至都没有超过 100 行。</p>\n<h2><a id=\"__476\"></a>第四步 处理环境素材</h2>\n<p>只有一个迷你手榴弹爆炸的场景实在是太逊了，那些细小的弹体碎片都给崩的没影了，完全没有办法体现 RayFire 的强大。接下来，为场景中的环境对象制作碎片模型并应用，练习一下整个过程，然后炸掉我们的劳动成果。记得保存为预制件！别真的一下全炸没了。</p>\n<h3><a id=\"_480\"></a>导入设置</h3>\n<p>在使用 RayFire 制作切片前，我们需要将所有导入资源的访问限制设置为可读。找到<code>/Models/House/House.fbx</code>，在检查器中设置读写已启用：</p>\n<p><img alt=\"导入设置\" src=\"image\\f9465f94a9564d45ba7766cbffdb6d8b.png\"/></p>\n<p>模型来自免费的第三方资源<a href=\"https://assetstore.unity.com/packages/p/low-poly-ultimate-home-pack-164671\">Low Poly Ultimate Home Pack</a>，这个作者的游戏对象命名比较烂，可能是因为对象实在是太多了…… 场景<code>04</code>中原始素材中的对象已经被重新整理层级和排列，找到目标物体对象会更容易些。</p>\n<h3><a id=\"_488\"></a>处理路灯</h3>\n<p>进入场景<code>04</code>，找到<code>Environment</code>对象下的<code>Light_Poll</code>，完全解压缩预制件：</p>\n<p><img alt=\"解压预制件\" src=\"image\\7f1cd847132a482d8feb3bd278f5d1fa.png\"/></p>\n<p>选中<code>Cylinder003</code>，<code>Box1340</code>和<code>Box1341</code>，这是我们需要切片的对象。使用之前的知识处理它们（让碎片数量少一些，不然太吃性能）：</p>\n<p><img alt=\"处理对象\" src=\"image\\d30f8064ee1748a39f1ff242c7d96b81.png\"/></p>\n<p>导出 Mesh，保存到<code>ShatteredObjects/Mesh/LightPoll</code>中。删除原物体，保留新的碎片根对象，然后在为<code>Light_Poll</code>添加<code>RayFire Rigid</code>并设置参数。我们希望电线杆在受到外力损伤程度一定时先解体，部件在二次撞击后破碎：</p>\n<p><img alt=\"设置参数\" src=\"image\\1fe5613dc5014f8db01970c368fb6a89.png\"/></p>\n<p>注意激活伤害检测：</p>\n<p><img alt=\"激活伤害检测\" src=\"image\\3024d775a96e4286bd05440e210d8108.png\"/></p>\n<p>对于比较脆弱的物体，可以考虑将碰撞也纳入伤害计算范围：</p>\n<p><img alt=\"碰撞伤害\" src=\"image\\a73a2b25074e4a03bb7fbb3b56983225.png\"/></p>\n<p>将处理后的路灯保存为预制件，存放于<code>ShatteredObject/Prefabs</code>中。删除原场景中的路灯并用切片后的替换。</p>\n<h3><a id=\"_513\"></a>处理人行道</h3>\n<p>选中<code>Pavings</code>，完全解压预制件，然后按照你的喜好设置<code>Paving</code>和<code>Paving_Under_House</code>的切片参数并切片。要求的效果是受到爆炸冲击波影响的碎片部分脱离，选择合适的参数：</p>\n<p><img alt=\"设置参数\" src=\"image\\20a5035b1d934ed8b01334751d41a8d1.png\"/><br/> <img alt=\"设置参数\" src=\"image\\157a80545ce8492c944d9db39c0ed337.png\"/></p>\n<p>重复预制件制作步骤。由于一部分人行道的模型和其他对象模型重叠，激活后可能会发生比较鬼畜的情况。</p>\n<h3><a id=\"_522\"></a>处理树</h3>\n<p>选择<code>Tree</code>对象，解压预制件。可以看到该对象由一些小块模型组成，因此无需二次处理，我们只需要调整层级顺序如下，然后添加<code>RayFire Rigid</code>组件并设置参数即可：</p>\n<p><img alt=\"层级情况\" src=\"image\\1230e491f1074572a267fea4e8610782.png\"/><br/> <img alt=\"设置参数\" src=\"image\\f80b1c9c944e4c89a4afb1d8a1ca027c.png\"/><br/> 记得激活伤害检测。重复预制件制作步骤，并删除未处理的对象，使用处理后的对象代替。</p>\n<h3><a id=\"_530\"></a>处理篱笆</h3>\n<p>找到<code>Fence</code>对象，解压预制件，选择层级下的另一个<code>Fence</code>。可以看到该对象同样无需切片处理，为其添加<code>RayFire Rigid</code>组件并设置参数：</p>\n<p><img alt=\"设置参数\" src=\"image\\fd7e83171e5740438bdab35893d899ca.png\"/><br/> 然后保存为预制件。</p>\n<h3><a id=\"_537\"></a>处理灌木</h3>\n<p>找到<code>Plants</code>对象，解压预制件，该对象同样无需处理，添加<code>RayFire Rigid</code>组件并设置参数：</p>\n<p><img alt=\"设置参数\" src=\"image\\70238e5ef66c4ad2987cc4e2d0b5e7e4.png\"/></p>\n<p>然后保存为预制件。</p>\n<h3><a id=\"_545\"></a>处理房屋</h3>\n<p>找到<code>House</code>对象，解压预制件，选择<code>Body</code>房体、<code>Roof</code>阁楼以及<code>Window1</code>和<code>Window2</code>两块玻璃，对它们进行切片并保存 Mesh ：</p>\n<p><img alt=\"目标\" src=\"image\\1cb24cae41c0417aba7ccf1ef06a6c29.png\"/></p>\n<p>可以发现对<code>Window1</code>和<code>Window2</code>切片时出现异常，这是因为 RayFire For Unity 无法很好地处理一些薄片物体，建议把这些物体的切片任务交给 3DSMAX 中的 RayFire 插件。删除这两个对象，或者保留它们（破坏时会显得很奇怪）：</p>\n<p><img alt=\"切片失败\" src=\"image\\cb2a466251964105a29ab54f27c1df11.png\"/></p>\n<p>对于<code>Roof</code>和<code>Body</code>，建议产生较少碎片，或者干脆不处理，因为<code>House</code>对象上的子对象已经足够多了，能让你的显卡渲染不过来。如果还是要进行切片，可以设置<code>Center Bias</code>让更大的碎片集中于中心和底部以显得更真实：</p>\n<p><img alt=\"设置参数\" src=\"image\\e4ee1bea61704e84a912a99b93541c6d.png\"/></p>\n<p>保存 Mesh 到<code>ShatteredObjects/Mesh/House</code>，删除原对象，将碎片至于<code>House</code>层级下，然后设置<code>RayFire Rigid</code>：</p>\n<p><img alt=\"设置参数\" src=\"image\\c77235fa22f746a782e5c15f705efecc.png\"/><br/> 然后保存为预制件。</p>\n<h3><a id=\"_564\"></a>添加音效和粒子</h3>\n<p>为刚才处理的所有预制件添加<code>RayFire Sound</code>和<code>RayFire Dust</code>组件，并指定效果素材。你可以在<code>AudioClips</code>中找到一些用于建筑<code>effect_rock</code>和树木<code>effect_wood</code>的音效；烟尘粒子可以使用 RayFire 教程中的<code>dust_m</code>材质，更改一下颜色即可（我选择的是棕色）。</p>\n<p>现在我们已经处理完了所有环境对象，是时候来点大爆炸了。</p>\n<h2><a id=\"__570\"></a>第五步 炸翻天</h2>\n<p>之前的手榴弹太小了，我们需要把它放大！暂时禁用<code>EventManager</code>对象以关闭调试控制台输出，设置<code>RGD-5_roots</code>的<code>RayFire Bomb</code>的属性：</p>\n<p><img alt=\"设置参数\" src=\"image\\88a13d6738ae431a9d8f9a440c37c257.png\"/><br/> 设置手榴弹大小：</p>\n<p><img alt=\"设置大小\" src=\"image\\491f4c2f020942f183de26fdf3a04b89.png\"/></p>\n<p>设置大型爆炸的音效：</p>\n<p><img alt=\"设置音效\" src=\"image\\65de56891b5d4a24a2bbbbc668f5696b.png\"/></p>\n<p>最后加上慢动作脚本，新建一个<code>SlowMotion</code>空对象并挂载该脚本：</p>\n<pre><code class=\"prism language-cs\"><span class=\"token keyword\">using</span> <span class=\"token namespace\">UnityEngine</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">SlowMotion</span> <span class=\"token punctuation\">:</span> <span class=\"token type-list\"><span class=\"token class-name\">MonoBehaviour</span></span>\n<span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\"><span class=\"token keyword\">float</span></span> slowMotionScale <span class=\"token operator\">=</span> <span class=\"token number\">0.1f</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token return-type class-name\"><span class=\"token keyword\">void</span></span> <span class=\"token function\">Awake</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{<!-- --></span>\n        Time<span class=\"token punctuation\">.</span>timeScale <span class=\"token operator\">*=</span> slowMotionScale<span class=\"token punctuation\">;</span>\n        Time<span class=\"token punctuation\">.</span>fixedDeltaTime <span class=\"token operator\">*=</span> slowMotionScale<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>如果你不想等待太久的话，记得更改引信时间。</p>\n<p>运行场景，按下<code>G</code>，以一次华丽的大爆炸结束本次教程吧。</p>\n<p><img alt=\"大爆炸\" src=\"https://img-blog.csdnimg.cn/041dfccbc2454266a71312cf4676e78d.gif#pic_center\"/><br/> 如果你在哪步中出了问题而没法解决，可以<code>Finished</code>目录中找到已完成的<code>Demo</code>场景进行对照。需要注意的是，如果场景需要的运算量过大，可能导致 RayFire 出现不一致的行为。</p>\n<h2><a id=\"_606\"></a>接下来去哪</h2>\n<ul><li>休息时间：尝试一下这款使用了 RayFire 插件的小游戏 <a href=\"https://pan.baidu.com/s/1p7287eYOCGWFwfDeV0LSdw?pwd=ouch\">Forward Traffic Controller</a></li><li>熟悉插件：观看<a href=\"https://www.youtube.com/playlist?list=PLcjScvftXufKA-dLmqvokYnU7zFfKYWk0\">官方教程</a>，尝试 RayFire 提供的其他高级功能；</li><li>扩展学习：阅读<a href=\"https://pan.baidu.com/s/1v8pbCrxnVBSkqu8GoHh4pg?pwd=ouch\">《.NET CLR via C#》</a>，了解 C# 语言基础和其他高级原生功能，并对 C# 在 Windows 平台上的运行时 .NET Framework 和 CLI/CLR 公共语言基础架构有一个初步的理解；</li><li>扩展学习：阅读 Unity 官方文档，了解 <a href=\"https://docs.unity.cn/cn/2021.1/Manual/unity-architecture.html\">Unity 的整体架构</a>，以及其底层的跨平台 Mono Runtime 与 .NET Framework 的区别与统一，然后思考：Unity 构建时的两种脚本后端 IL2CPP 和 Mono 都做了什么，应该何时使用；</li><li>扩展学习：了解什么是 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/core/introduction\">.NET Core</a>，展望跨平台的 .NET 环境和 Unity 的未来；</li><li>扩展学习：了解<a href=\"https://www.raywenderlich.com/22599905-improving-game-visuals-with-unity-s-hdrp\">如何在 Unity 中使用 HDRP 高清渲染管线</a>，以配合 RayFire 制作更华丽的效果；</li><li>扩展学习：了解<a href=\"https://docs.unity.cn/cn/2021.1/Manual/XR.html\">如何在 Unity 中进行 XR 开发</a>，配合 HDRP 和 RayFire 制作身临其境的电影级游戏场景或工业仿真应用；</li><li>扩展学习：<a href=\"https://www.bilibili.com/video/BV1H5411n78j\">什么是技术美术 TA</a>；</li><li>……</li></ul>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}