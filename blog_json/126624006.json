{"blogid": "126624006", "writerAge": "码龄3年", "writerBlogNum": "89", "writerCollect": "862", "writerComment": "1118", "writerFan": "1393", "writerGrade": "5级", "writerIntegral": "4118", "writerName": "小呆鸟_coding", "writerProfileAdress": "writer_image\\profile_126624006.jpg", "writerRankTotal": "4488", "writerRankWeekly": "710", "writerThumb": "1206", "writerVisitNum": "19896", "blog_read_count": "217", "blog_time": "已于 2022-09-04 21:10:32 修改", "blog_title": "【11. 死锁和进程通信】", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-light\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\8a4312420c6141bb82aadedc5b3bbec3.jpeg\"/></p>\n<blockquote>\n<p>🎉作者简介:👓<span class=\"katex--inline\"><span class=\"katex\"><span class=\"katex-mathml\">\n     \n      \n       \n        \n         \n          博主在读机器人研究生，目前研一。对计算机后端感兴趣，喜欢\n         \n         \n          c\n         \n         \n          +\n         \n         \n          +\n         \n         \n          ,\n         \n         \n          g\n         \n         \n          o\n         \n         \n          ,\n         \n         \n          p\n         \n         \n          y\n         \n         \n          t\n         \n         \n          h\n         \n         \n          o\n         \n         \n          n\n         \n         \n          ,\n         \n         \n          目前熟悉\n         \n         \n          c\n         \n         \n          +\n         \n         \n          +\n         \n         \n          ，\n         \n         \n          g\n         \n         \n          o\n         \n         \n          语言，数据库，网络编程，了解分布式等相关内容\n         \n        \n       \n       \n        \\textcolor{orange}{博主在读机器人研究生，目前研一。对计算机后端感兴趣，喜欢c++,go,python,目前熟悉c++，go语言，数据库，网络编程，了解分布式等相关内容}\n       \n      \n     </span><span class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.7667em; vertical-align: -0.0833em;\"></span><span class=\"mord cjk_fallback\" style=\"color: orange;\">博主在读机器人研究生，目前研一。对计算机后端感兴趣，喜欢</span><span class=\"mord mathnormal\" style=\"color: orange;\">c</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\" style=\"color: orange;\">+</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.8889em; vertical-align: -0.1944em;\"></span><span class=\"mord\" style=\"color: orange;\">+</span><span class=\"mpunct\" style=\"color: orange;\">,</span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em; color: orange;\">g</span><span class=\"mord mathnormal\" style=\"color: orange;\">o</span><span class=\"mpunct\" style=\"color: orange;\">,</span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord mathnormal\" style=\"color: orange;\">p</span><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em; color: orange;\">y</span><span class=\"mord mathnormal\" style=\"color: orange;\">t</span><span class=\"mord mathnormal\" style=\"color: orange;\">h</span><span class=\"mord mathnormal\" style=\"color: orange;\">o</span><span class=\"mord mathnormal\" style=\"color: orange;\">n</span><span class=\"mpunct\" style=\"color: orange;\">,</span><span class=\"mspace\" style=\"margin-right: 0.1667em;\"></span><span class=\"mord cjk_fallback\" style=\"color: orange;\">目前熟悉</span><span class=\"mord mathnormal\" style=\"color: orange;\">c</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span><span class=\"mbin\" style=\"color: orange;\">+</span><span class=\"mspace\" style=\"margin-right: 0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height: 0.8778em; vertical-align: -0.1944em;\"></span><span class=\"mord\" style=\"color: orange;\">+</span><span class=\"mord cjk_fallback\" style=\"color: orange;\">，</span><span class=\"mord mathnormal\" style=\"margin-right: 0.0359em; color: orange;\">g</span><span class=\"mord mathnormal\" style=\"color: orange;\">o</span><span class=\"mord cjk_fallback\" style=\"color: orange;\">语言，数据库，网络编程，了解分布式等相关内容</span></span></span></span></span><br/> 📃<span class=\"katex--inline\"><span class=\"katex\"><span class=\"katex-mathml\">\n     \n      \n       \n        \n         \n          个人主页：\n         \n        \n       \n       \n        \\textcolor{gray}{个人主页：}\n       \n      \n     </span><span class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord cjk_fallback\" style=\"color: gray;\">个人主页：</span></span></span></span></span> <a href=\"https://blog.csdn.net/weixin_45043334?spm=1011.2266.3001.5343\">小呆鸟_coding</a><br/> 🔎<span class=\"katex--inline\"><span class=\"katex\"><span class=\"katex-mathml\">\n     \n      \n       \n        \n         \n          支持\n         \n         \n          :\n         \n        \n       \n       \n        \\textcolor{gray}{支持:}\n       \n      \n     </span><span class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord cjk_fallback\" style=\"color: gray;\">支持</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\" style=\"color: gray;\">:</span></span></span></span></span><span class=\"katex--inline\"><span class=\"katex\"><span class=\"katex-mathml\">\n     \n      \n       \n        \n         \n          如果觉得博主的文章还不错或者您用得到的话，可以免费的关注一下博主，如果三连收藏支持就更好啦\n         \n        \n       \n       \n        \\textcolor{green}{如果觉得博主的文章还不错或者您用得到的话，可以免费的关注一下博主，如果三连收藏支持就更好啦}\n       \n      \n     </span><span class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord cjk_fallback\" style=\"color: green;\">如果觉得博主的文章还不错或者您用得到的话，可以免费的关注一下博主，如果三连收藏支持就更好啦</span></span></span></span></span>👍<span class=\"katex--inline\"><span class=\"katex\"><span class=\"katex-mathml\">\n     \n      \n       \n        \n         \n          就是给予我最大的支持！\n         \n        \n       \n       \n        \\textcolor{green}{就是给予我最大的支持！}\n       \n      \n     </span><span class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6833em;\"></span><span class=\"mord cjk_fallback\" style=\"color: green;\">就是给予我最大的支持！</span></span></span></span></span>🎁<br/> 💛本文摘要💛</p>\n<table><tbody><tr><td bgcolor=\"Pink\">本专栏主要是讲解操作系统的相关知识 本文主要讲解 死锁和进程通信 </td></tr></tbody></table>\n<p></p>\n<div class=\"toc\">\n<h3>文章目录</h3>\n<ul><li><a href=\"#_26\">死锁</a></li><li><ul><li><a href=\"#0__27\">🐮0. 概述</a></li><li><a href=\"#1__37\">🐮1. 死锁问题</a></li><li><a href=\"#2__49\">🐮2. 死锁模型</a></li><li><a href=\"#3__92\">🐮3. 死锁的特征</a></li><li><a href=\"#4__100\">🐮4. 死锁的处理办法</a></li><li><ul><li><a href=\"#41__105\">🐫4.1 死锁预防（约束条件最强）</a></li><li><a href=\"#42__121\">🐫4.2 死锁避免</a></li><li><ul><li><a href=\"#431__140\">🐍4.3.1 银行家算法</a></li></ul>\n</li><li><a href=\"#43__159\">🐫4.3 死锁检测</a></li><li><a href=\"#44__193\">🐫4.4 死锁恢复</a></li><li><a href=\"#45__208\">🐫4.5 鸵鸟算法（这是解决死锁用的最多的一种）</a></li></ul>\n</li><li><a href=\"#5_IPC_211\">🐮5. 进程通信（IPC）</a></li><li><ul><li><a href=\"#50__212\">🐫5.0 概述</a></li><li><ul><li><a href=\"#501__242\">🐍5.0.1 直接通信</a></li><li><a href=\"#502__251\">🐍5.0.2 间接通信</a></li></ul>\n</li><li><a href=\"#51__281\">🐫5.1 信号</a></li><li><a href=\"#52__300\">🐫5.2 管道</a></li><li><a href=\"#53__313\">🐫5.3 消息队列</a></li><li><a href=\"#54__327\">🐫5.4 共享内存</a></li></ul>\n</li></ul>\n</li></ul>\n</div>\n<br/>\n<strong><code>清华操作系统系列文章：可面试可复习</code></strong>\n<br/>\n<a href=\"https://blog.csdn.net/weixin_45043334/article/details/126274844\">1. 操作系统—概述</a>\n<br/>\n<a href=\"https://blog.csdn.net/weixin_45043334/article/details/126293098\">2. 操作系统—中断、异常、系统调用</a>\n<br/>\n<a href=\"https://blog.csdn.net/weixin_45043334/article/details/126353734\">3. 操作系统—物理内存管理</a>\n<br/>\n<a href=\"https://blog.csdn.net/weixin_45043334/article/details/126360202\">4. 操作系统—非连续内存分配</a>\n<br/>\n<a href=\"https://blog.csdn.net/weixin_45043334/article/details/126378112\">5. 虚拟内存管理</a>\n<br/>\n<a href=\"https://blog.csdn.net/weixin_45043334/article/details/126398876\">6. 操作系统—虚拟内存管理技术页面置换算法</a>\n<br/>\n<a href=\"https://blog.csdn.net/weixin_45043334/article/details/126426025\">7. 进程管理</a>\n<br/>\n<a href=\"https://blog.csdn.net/weixin_45043334/article/details/126451433\">8. 调度算法</a>\n<br/>\n<a href=\"https://blog.csdn.net/weixin_45043334/article/details/126477243\">9. 同步与互斥</a>\n<br/>\n<a href=\"https://blog.csdn.net/weixin_45043334/article/details/126533681\">10. 信号量和管程</a>\n<br/>\n<a href=\"https://blog.csdn.net/weixin_45043334/article/details/126624006\">11. 死锁和进程通信</a>\n<br/>\n<a href=\"https://blog.csdn.net/weixin_45043334/article/details/126652312\">12. 文件系统管理</a>\n<p></p>\n</blockquote>\n<h1><a id=\"_26\"></a>死锁</h1>\n<h2><a id=\"0__27\"></a>🐮0. 概述</h2>\n<ul><li>死锁问题</li><li>系统模型</li><li>死锁特征</li><li>死锁处理方法 \n  <ul><li>死锁预防</li><li>死锁避免</li><li>死锁检测</li><li>死锁恢复</li></ul> </li></ul>\n<h2><a id=\"1__37\"></a>🐮1. 死锁问题</h2>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\b8c51682d3df4333a97821d0fed7cc07.png\"/></p>\n<ul><li><strong>一组阻塞的进程持有一种资源等待获取另一个进程所占有的一个资源</strong></li><li><strong>死锁的原因：</strong>\n<ul><li>多进程并发执行，每个进程都需要这个资源，而资源是共享的，所有的进程都可以抢着用。自己拥有资源还抢其他资源，导致谁也执行不了</li></ul> </li><li><strong>什么是死锁</strong>\n<ul><li>每个进程拥有自己的资源，但是它又要需要其他的资源，而其他的资源被另一个进程占有，而另一个进程又需要前一个进程的资源，导致谁都不释放自己的资源，又想获得其他进程的资源，就导致死锁</li></ul> </li><li><strong>示例:</strong>\n<ul><li>系统有2个磁带驱动器</li><li>P1和P2各有一个,都需要另外一个**</li></ul> </li></ul>\n<h2><a id=\"2__49\"></a>🐮2. 死锁模型</h2>\n<ul><li><strong>资源类型R1,R2,…,Rm(CPU, memory space, IO devices)</strong></li><li><strong>每个资源类型Ri有Wi个实例.</strong></li><li><strong>每个进程使用资源如下:</strong>\n<ul><li>require,get ← free resource</li><li>use,hold ← requested,used resource</li><li>release ← free resource</li></ul> </li></ul>\n<p><strong>可重复使用的资源（获取资源—&gt;使用资源—&gt;释放资源）</strong></p>\n<ul><li>在一个时间只能有一个进程使用且不能被删除</li><li>进程获得资源,后来释放由其他进程重用</li><li>处理器,IO通道,主和副存储器,设备和数据结构,如文件,数据库和信号量</li><li>如果每个进程拥有一个资源并请求其他资源,死锁可能发生</li></ul>\n<p><strong>使用资源</strong></p>\n<ul><li>创建和销毁</li><li>在IO缓存区的中断,信号,消息,信息</li><li>如果接收消息阻塞可能会发生死锁</li><li>可能少见的组合事件会引起死锁</li></ul>\n<p><strong>资源分配图</strong></p>\n<ul><li><code>P&lt;sub&gt;1&lt;/sub&gt; --&gt; R&lt;sub&gt;j&lt;/sub&gt;</code> 表示进程 i 正在使用资源 j</li><li><code>R&lt;sub&gt;j&lt;/sub&gt; --&gt; P&lt;sub&gt;i&lt;/sub&gt;</code> 表示资源 j 被进程 i 所使用<br/> <img alt=\"在这里插入图片描述\" src=\"image\\a14cae88da7f4b6f9e7669dbe46d001e.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"image\\36e75f8ba5934194bca4b07d860e0e00.png\"/><br/> <strong>资源分配例子（无死锁）</strong><br/> <img alt=\"在这里插入图片描述\" src=\"image\\4ab891a6f5904b3f8af40dc34ca1a749.png\"/></li></ul>\n<p><strong>资源分配例子（有死锁）</strong><br/> <img alt=\"在这里插入图片描述\" src=\"image\\bb55015429ed4680b1e55061e3382c09.png\"/><br/> <strong>有循环的资源分配图没有死锁</strong><br/> <img alt=\"在这里插入图片描述\" src=\"image\\faf927f176a0491fb9b2da99c8b8e2ef.png\"/></p>\n<p><strong>总结</strong></p>\n<ul><li><strong>如果图中不包含循环:</strong>\n<ul><li>没有死锁</li></ul> </li><li><strong>如果图中包含循环:</strong>\n<ul><li>如果每个资源类只有一个实例,那么死锁</li><li>如果每个资源类有几个实例,可能死锁</li></ul> </li></ul>\n<h2><a id=\"3__92\"></a>🐮3. 死锁的特征</h2>\n<p><code>死锁的4个必要条件（死锁出现一定会出现以下四个条件,但是出现以下四个条件不一定死锁）</code></p>\n<ul><li><code>互斥</code>: 在一个时间只能有一个进程使用资源</li><li><code>持有并等待</code>: 进程保持至少一个资源正在等待获取其他进程持有的额外资源</li><li><code>无抢占</code>: 一个资源只能被进程资源释放,进程已经完成了它的任务之后</li><li><code>循环等待</code>: 存在等待进程集合<code>{P0,P1,...,Pn}</code>,<code>P0</code>正在等待<code>P1</code>所占用的资源,<code>P1</code>正在等待<code>P2</code>占用的资源…<code>Pn-1</code>在等待<code>Pn</code>的资源,<code>Pn</code>正在等待<code>P0</code>所占用的资源</li></ul>\n<h2><a id=\"4__100\"></a>🐮4. 死锁的处理办法</h2>\n<p><strong>常见方法</strong></p>\n<ul><li>确保系统永远不会进入死锁状态</li><li>运行系统进入死锁状态,然后恢复.</li><li>忽略这个问题,假装系统中从来没有发生死锁,用于大多数操作系统,包括UNIX</li></ul>\n<h3><a id=\"41__105\"></a>🐫4.1 死锁预防（约束条件最强）</h3>\n<ul><li><code>就是让死锁不会出现(将死锁出现的某一个条件打破就不会出现死锁了，前面死锁的4个必要条件，有一个条件被打破就不会出现死锁)</code></li></ul>\n<p><strong>限制申请方式</strong></p>\n<ol><li> <p><code>互斥 - 共享资源不是必须的,必须占用非共享资源</code></p> </li><li> <p><code>占用并等待 - 必须保证当一个进程请求的资源,它不持有任何其他资源</code></p>\n<ul><li>需要进程请求并分配其所有资源,它开始执行之前或允许进程请求资源仅当进程没有资源（我要拿到全部资源而不是一部分资源，当资源不能满足是，我就放弃所有资源）</li><li>资源利用率低,可能发生饥饿</li></ul> </li><li> <p><code>无抢占 -(kill到当前执行的进程)</code></p>\n<ul><li>如果进程占有某些资源,并请求其他不能被立即分配的资源,则释放当前正占有的资源</li><li>被抢占资源添加到资源列表中</li><li>只有当它能够获得旧的资源以及它请求新的资源,进程可以得到执行</li></ul> </li></ol>\n<p>4 <code>循环等待 - 对所有资源类型进行排序(资源都递增或者资源都递减),并要求每个进程按照资源的顺序进行申请</code></p>\n<h3><a id=\"42__121\"></a>🐫4.2 死锁避免</h3>\n<p>需要系统具有一些额外的先验信息提供</p>\n<ul><li>最简单和最有效的模式是要求每个进程声明它可能需要的每个类型资源的<code>最大数目</code></li><li>资源的分配状态是通过限定<code>提供与分配</code>的资源数量,和进程的<code>最大需求</code></li><li>死锁避免算法<code>动态检查</code>的资源分配状态,以确保永远不会有一个环形等待状态</li><li>当一个进程请求可用资源,系统必须判断立即分配是否能使系统处于安全状态</li><li>系统处于安全状态指: 针对所有进程,存在安全序列</li><li><code>序列&lt;P1,P2,...,Pn&gt;是安全的</code>: 针对每个Pi,Pi要求的资源能够由当前可用的资源+所有的Pj持有的资源来满足,其中j&lt;i. \n  <ul><li>如果Pi资源的需求不是立即可用,那么Pi可以等到所有Pj完成</li><li>当Pi完成后,Pi+1可以得到所需要的资源,执行,返回所分配的资源,并终止.</li><li>用同样的方法,Pi+2,Pi+3和Pn能获得其所需的资源.<br/> <img alt=\"在这里插入图片描述\" src=\"image\\5131fa2936ea45f7ae31287f86e18f26.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"image\\2723200ddd18488f85ef5d154e5453f9.png\"/></li></ul> </li></ul>\n<p><strong>死锁预防与死锁避免区别</strong></p>\n<ul><li>死锁预防是设法至少破坏产生死锁的四个必要条件，严格的防止死锁的出现，而死锁避免则不是那么严格的限制产生死锁的必要条件，因为即使死锁的必要条件存在，也不一定发生死锁。死锁避免是在系统运行过程中注意避免死锁的最终法神</li></ul>\n<h4><a id=\"431__140\"></a>🐍4.3.1 银行家算法</h4>\n<ul><li>只要判断出是<code>unsafe</code>状态（<code>unsafe</code>不等于<code>deadlock</code>）,由于<code>deadlock</code>更复杂，开销更大，所以当判断出<code>unsafe</code>后就不能让进程获得资源<br/> <img alt=\"\" src=\"image\\2fc2c201d728470e8a3ed415b6043d7d.png\"/></li></ul>\n<p><strong>银行家算法数据结构</strong></p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\1f193a0dfffb4f0284b7aab347646886.png\"/></p>\n<p><strong>找到安全序列的步骤</strong></p>\n<ul><li>当所有的Finsh为True则找到了安全序列，只要按照这个序列执行就不会出现死锁，当有一个为False就是unsafe。不安全我们就不能把资源分配给发出请求的进程<br/> <img alt=\"在这里插入图片描述\" src=\"image\\530fe242c8854a21b2ba842452a2f6f4.png\"/><br/> <strong>银行家大体思路</strong><br/> <img alt=\"在这里插入图片描述\" src=\"image\\47b36dc768e14db1bbf798f9f34c04e3.png\"/><br/> <strong>例子</strong></li><li>在<code>Need</code>中找到一个进程<code>（P1,P2,P3,P4）</code>所需要资源的个数小于<code>Avaliable vector V（0,1，1）</code>这个值。</li><li><code>P2</code>满足条件，P2的<code>Finish</code>变成<code>True</code>,然后将<code>P2</code>的资源释放掉,返回到系统中<code>Avaliable</code>中去</li><li>此时<code>Avaliable中</code>变为6，2，3，继续找下去，直到找到安全序列。<br/> <img alt=\"在这里插入图片描述\" src=\"image\\4b0e97ae18784119967a50a54c9268b1.png\"/></li></ul>\n<h3><a id=\"43__159\"></a>🐫4.3 死锁检测</h3>\n<ul><li><code>死锁避免</code>是即使没有死锁，如果判断出来有可能不安全就不让程序继续执行</li><li>死锁检测条件相比避免和预防又宽松了(<code>允许系统进入死锁状态，当到达一定时候，系统会判断是否是死锁，就启动恢复机制，不是在每次发出请求的时候，而是系统运行中判断</code>)</li></ul>\n<p><strong>方法</strong><br/> <img alt=\"在这里插入图片描述\" src=\"image\\3a6ce6b7085a47ad9b4b751bddeba432.png\"/></p>\n<p><strong>数据结构</strong></p>\n<ul><li><code>Available</code>: 长度为M的向量表示每种类型可用资源的数量</li><li><code>Allocation</code>: 一个n * m矩阵定义了当前分配给各个进程每种类型资源的数量,如果Alocation[i, j] = k, 进程Pi拥有资源Rj的k个实例</li><li><code>Request</code>: 一个n * m矩阵表示各进程的当前请求.如果Request[i, j] = k,表示进程Pi请求k个资源Pj的实例</li></ul>\n<p><strong>死锁检测算法</strong></p>\n<ul><li>定期的执行该算法，检测是否有死锁</li></ul>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\945e5d403de44450adfc8e6c24d940be.png\"/></p>\n<p><strong>很少使用算法的原因</strong></p>\n<ul><li>操作系统中很少使用银行家算法。死锁检测算法的原因是开销比较大</li><li>对于银行家算法，需要知道每一个进程需要的最大资源个数，这个信息很难获得</li></ul>\n<p><strong>俩个例子</strong></p>\n<ul><li>死锁检测算法与银行家算法是很类似的<br/> <img alt=\"在这里插入图片描述\" src=\"image\\80aa61e8fd1549b3be8df5474ce4cde0.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"image\\5b2aeadd7cd14fb085ac44e6129e3d06.png\"/></li></ul>\n<p><strong>检测算法使用</strong></p>\n<ul><li><strong>何时,使用什么样的频率来检测依赖于:</strong>\n<ul><li>死锁多久可能会发生?</li><li>多少进程需要被回滚? one for each disjoint cycle</li></ul> </li><li><strong>如果检测算法多次被调用,有可能是资源图有多个循环,所以我们无法分辨出多个可能死锁进程中的哪些\"造成\"死锁### 4.5 死锁恢复（约束条件最弱）</strong></li></ul>\n<h3><a id=\"44__193\"></a>🐫4.4 死锁恢复</h3>\n<ul><li><strong>1. 终止所有的死锁进程</strong></li><li><strong>2. 在一个时间内终止一个进程直到死锁消除</strong></li><li><strong>终止进程的顺序应该是（具体应该终止哪 个进程）:</strong>\n<ul><li>进程的优先级</li><li>进程运行了多久以及需要多少时间才能完成</li><li>进程占用的资源</li><li>进程完成需要的资源</li><li>多少进程需要被终止</li><li>进程是交互还是批处理</li></ul> </li><li><strong>3. 选择一个受孩子 - 最小的成本</strong></li><li><strong>4. 回滚 - 返回到一些安全状态,重启进程到安全状态</strong></li><li><strong>5. 饥饿 - 同一进程可能一直被选作受害者,包括回滚的数量</strong></li></ul>\n<h3><a id=\"45__208\"></a>🐫4.5 鸵鸟算法（这是解决死锁用的最多的一种）</h3>\n<h2><a id=\"5_IPC_211\"></a>🐮5. 进程通信（IPC）</h2>\n<h3><a id=\"50__212\"></a>🐫5.0 概述</h3>\n<ul><li>概述 \n  <ul><li>通信模型</li><li>直接及间接通信</li><li>阻塞与非阻塞</li><li>通信链路缓冲</li></ul> </li><li><strong>信号（与信号量不一样）</strong></li><li><strong>管道</strong></li><li><strong>消息队列</strong></li><li><strong>共享内存</strong></li></ul>\n<p><strong>进程通信的原因</strong>：保证进程独立的同时，也需要进程之间的沟通</p>\n<ul><li><strong>进程通信的机制及同步</strong></li><li><strong>不使用共享变量的进程通信</strong></li><li><strong>IPC facility 提供2个操作:</strong>\n<ul><li>send(message) - 消息大小固定或者可变</li><li>receive(message)</li></ul> </li><li><strong>如果P和Q想通信,需要:</strong>\n<ul><li>在它们之间建立通信链路</li><li>通过send/recevie交换消息</li></ul> </li><li><strong>通信链路的实现</strong>\n<ul><li>物理(例如,共享内存,硬件总线)</li><li>逻辑(例如,逻辑属性)</li></ul> </li></ul>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\385c5d62096d490ea807b303370710ef.png\"/></p>\n<h4><a id=\"501__242\"></a>🐍5.0.1 直接通信</h4>\n<ul><li><strong>进程必须正确的命名对方:</strong>\n<ul><li>send(P, message) - 发送消息到进程P</li><li>receive(Q, message) - 从进程Q接收信息</li></ul> </li><li><strong>通信链路的属性</strong>\n<ul><li>自动建立链路</li><li>一条链路恰好对应一对通信进程</li><li>每对进程之间只有一个链路存在</li><li>链路可以是单向的,但通常是双向的</li></ul> </li></ul>\n<h4><a id=\"502__251\"></a>🐍5.0.2 间接通信</h4>\n<ul><li> <p><strong>定向从消息队列接收消息</strong></p>\n<ul><li>每个消息对垒都有一个唯一的ID</li><li>只有它们共享了一个消息队列,进程才能够通信</li></ul> </li><li> <p><strong>通信链路的属性</strong></p>\n<ul><li>只有进程共享一个共同的消息队列,才建立链路</li><li>链接可以与许多进程相关联</li><li>每对进程可以共享多个通信链路</li><li>链接可以是单向或者双向</li></ul> </li><li> <p><strong>操作</strong></p>\n<ul><li>创建一个新的消息队列</li><li>通过消息队列发送和接收消息</li><li>销毁消息队列</li></ul> </li><li> <p><strong>原语的定义如下:</strong></p>\n<ul><li>send(A, message)</li><li>receive(A, message)</li></ul> </li></ul>\n<hr/>\n<ul><li> <p><strong>消息传递可以是阻塞或非阻塞</strong></p>\n<ul><li>阻塞被认为是同步的</li><li>非阻塞被认为是异步的</li></ul> </li><li> <p><strong>通信链路缓冲</strong></p>\n<ul><li>将消息缓存起来，缓存的目的就是提高效率，来避免发送发和接收方的不匹配，可能发的很快，接收的很慢，将临时不能处理的数据放在缓存。</li></ul> </li><li> <p><strong>通信链路缓存大小:</strong></p>\n<ol><li>0容量 - 0 message : 发送方必须等待接收方</li><li>有限容量 - n messages的有限长度 : 发送方必须等待,如果队列满</li><li>无限容量 - 无限长度 : 发送方不需要等待</li></ol> </li></ul>\n<h3><a id=\"51__281\"></a>🐫5.1 信号</h3>\n<p><strong>硬件中断与软件中断</strong></p>\n<ul><li>硬件中断：由外设引起的，是指向量中断，即中断源的识别标志，可用来存放中断服务程序入口地址或跳转到中断服务程序入口地址</li><li>软件中断：执行中断指令引起的， 利用硬件中断的概念，用软件方法模拟，实现宏观上的异步执行效果。</li></ul>\n<hr/>\n<ul><li><strong>信号Signal</strong>\n<ul><li>软件中断通知事件处理</li><li>Examples: SIGFPE, SIGKILL, SIGUSRI, SIGSTOP, SIGCONT</li></ul> </li><li><strong>接收到信号时会发生什么?</strong>\n<ul><li><code>catch</code>: 指定信号处理函数被调用</li><li><code>ignore</code>: 依靠操作系统的默认操作(abort, memory dump, suspend or resume process)</li><li><code>mask:</code> 闭塞信号因此不会传送(可能是暂时的,当处理同样类型的信号)</li></ul> </li><li><strong>不足:</strong>\n<ul><li>不能传输要交换的任何数据</li></ul> </li></ul>\n<p><strong>信号实现</strong><br/> <img alt=\"在这里插入图片描述\" src=\"image\\8c77a9f1cc2f4261a6f428853ca7a26c.png\"/></p>\n<h3><a id=\"52__300\"></a>🐫5.2 管道</h3>\n<ul><li><strong>管道是数据交换的，与信号不一样</strong></li><li><strong>管道是有容量的</strong></li><li><strong>子进程从父进程继承文件描述符</strong>\n<ul><li>0 stdin, 1 stdout, 2 stderr</li></ul> </li><li><strong>进程不知道(或不关心)从键盘,文件,程序读取或写入到终端,文件,程序.</strong>\n<ul><li><code>例如: $ ls | more (两个进程, 管道是缓存,对于ls来说是stdout,对于more来说是stdin )</code></li></ul> </li></ul>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\acc340f27c4c4c3d855ab34cffc1ff56.png\"/><br/> <strong>shell:</strong></p>\n<ol><li>创建管道</li><li>为ls创建一个进程，设置stdout为管道写端</li><li>为more创建一个进程，设置为stdin为管道读端</li></ol>\n<h3><a id=\"53__313\"></a>🐫5.3 消息队列</h3>\n<p><strong>消息队列与管道区别</strong></p>\n<ul><li><code>管道是父进程为子进程建立好的通道（如果没有父子关系，管道就建立不起来，且管道的数据是一个字节流，没有结构化的表示）</code></li><li><code>消息队列通过多个不相关的进程通过消息队列来传递数据（不需要父子关系，而且是结构化传递）</code></li><li>与管道一样有buffersize限制<br/> <img alt=\"在这里插入图片描述\" src=\"image\\ed0408999ed940cda82ff2439cd49a97.png\"/></li></ul>\n<p><strong>消息队列按FIFO来管理消息</strong></p>\n<ul><li>message: 作为一个字节序列存储</li><li>message queues: 消息数组</li><li>FIFO &amp; FILO configuration</li></ul>\n<h3><a id=\"54__327\"></a>🐫5.4 共享内存</h3>\n<ul><li><code>消息队列与管道都是间接通信方式，而共享内存是直接通信方式（有一个特殊的空间是进程都可以访问到）</code></li><li><code>管道和消息队列通过系统调用完成通信（send，receive）,而共享内存是直接从共享内存读取数据，是最快的，在最开始需要创建一个共享的区域。没有多余的拷贝</code></li></ul>\n<hr/>\n<ul><li><strong>进程</strong>\n<ul><li>每个进程都有私有地址空间</li><li>在每个地址空间内,明确地设置了共享内存段</li></ul> </li><li><strong>优点</strong>\n<ul><li>快速,方便地共享数据</li></ul> </li><li><strong>不足</strong>\n<ul><li>必须同步数据访问</li></ul> </li></ul>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\11b9310a9e214e21ae254cf3c0706011.png\"/></p>\n<ul><li>将同一块物理内存映射到进程相同或者不同的地址空间中去，当访问不同进程的虚地址时，其实访问的是同一块内存（需要页表等机制支持）</li></ul>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}