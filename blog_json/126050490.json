{"blogid": "126050490", "writerAge": "码龄2年", "writerBlogNum": "50", "writerCollect": "80", "writerComment": "2", "writerFan": "10", "writerGrade": "3级", "writerIntegral": "554", "writerName": "小艾菜菜菜", "writerProfileAdress": "writer_image\\profile_126050490.jpg", "writerRankTotal": "35705", "writerRankWeekly": "85645", "writerThumb": "24", "writerVisitNum": "16920", "blog_read_count": "1300", "blog_time": "已于 2022-07-29 11:17:35 修改", "blog_title": "C++ 哈希表基本用法", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h1><a id=\"_0\"></a>哈希表</h1>\n<p><strong>哈希表是一种很常见的数据结构，我现在平时刷算法题一般使用C++刷（不要问我为什么，懂的都懂）。C++关于哈希表有很多数据结构，平时使用的比较多的有unordered_set 跟 unordered_map。其中unordered_map 存储的是键值对。<br/> 其实我们在某些情况下可以使用数组构建哈希表（具体是哪些情况的呢，自行搜索）。但是数组的大小是受限制的，而且如果元素很少却哈希值很大的话会造成内存空间的浪费（至于为什么会这样请自行搜索）。</strong></p>\n<h2><a id=\"_3\"></a>为什么要用哈希表</h2>\n<p>如果现在做哈希表的题目，是因为按专题刷的哈希表的题目，所以会直接用哈希表。但是遇到一道新的题目，没有标签，怎么想到使用哈希表呢？<br/> 咱们要清楚一点的就是，<strong>一般哈希表都是用来快速判断一个元素是否出现在集合里。</strong></p>\n<h3><a id=\"_6\"></a>遍历</h3>\n<blockquote>\n<p><strong>for (auto i = hash.begin(); i != hash.end(); i++)</strong></p>\n</blockquote>\n<p>如果是unordered_map，遍历的时候，可以访键值<code>i -&gt;first</code>或者是<code>i-&gt;second</code>;</p>\n<h3><a id=\"_12\"></a>查找</h3>\n<p>查找某个元素是否在哈希表中，可以使用<code>hash.find(x) != hash.end()</code>,或者<code>hash.count(x) &gt; 0</code><br/> <strong>注意：<code>hash.count(x) </code> 的数值只有 0 和 1。所以不能通过<code>hsxh.count(x)</code>来表示x在hash 中出现的次数。</strong></p>\n<h3><a id=\"_16\"></a>插入</h3>\n<p>在unordered_set 中插入元素，可以用<code>hash.insert(key)</code>。<br/> 在unordered_map中插入元素，可以使用<code>hash[key = value</code>。</p>\n<h3><a id=\"_20\"></a>删除</h3>\n<p>在unordered_set 跟unordered_map 中删除元素，都用<code>hash.erase(key)</code>。<br/> 注意，在unordered_map 中，即使<code>hash[key] == 0</code>，如果之前已经将key存入到hash中，然后通过<code>hash[key] -- </code>使得<code>hash[key] == 0</code>，hash 中还会存在key ，也就是说此时<code>hash.count(key) == 1</code>。<br/> 在个别场景下，可能需要一次性删除 unordered_map 容器中存储的所有键值对，可以使用clear()方法，其语法格式如下：</p>\n<blockquote>\n<p>void clear()<br/> {<!-- --><br/> hash.clear();<br/> }</p>\n</blockquote>\n<p><strong>我觉的刷题会这些基本的操作足够了，想深层次的了解哈希表的话自行查阅资料吧。</strong></p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}