{"blogid": "125316513", "writerAge": "码龄1年", "writerBlogNum": "40", "writerCollect": "40", "writerComment": "0", "writerFan": "3", "writerGrade": "3级", "writerIntegral": "414", "writerName": "Lzfnemo2009", "writerProfileAdress": "writer_image\\profile_125316513.jpg", "writerRankTotal": "40775", "writerRankWeekly": "324857", "writerThumb": "11", "writerVisitNum": "14637", "blog_read_count": "2328", "blog_time": "已于 2022-06-18 07:42:06 修改", "blog_title": "EasyExcel模板导出(行和列自动合并)", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"1.%E9%9C%80%E6%B1%82%E8%83%8C%E6%99%AF%3A-toc\" style=\"margin-left:0px;\"><a href=\"#1.%E9%9C%80%E6%B1%82%E8%83%8C%E6%99%AF%3A\">1.需求背景:</a></p>\n<p id=\"2.%E5%88%9D%E6%AD%A5%E5%AE%9E%E7%8E%B0%3A-toc\" style=\"margin-left:0px;\"><a href=\"#2.%E5%88%9D%E6%AD%A5%E5%AE%9E%E7%8E%B0%3A\">2.初步实现:</a></p>\n<p id=\"3.%E5%88%97%E5%90%88%E5%B9%B6-toc\" style=\"margin-left:0px;\"><a href=\"#3.%E5%88%97%E5%90%88%E5%B9%B6\">3.列合并</a></p>\n<p id=\"4.%E8%A1%8C%E5%90%88%E5%B9%B6-toc\" style=\"margin-left:0px;\"><a href=\"#4.%E8%A1%8C%E5%90%88%E5%B9%B6\">4.行合并</a></p>\n<p id=\"5.excel%E5%AD%97%E4%BD%93%E6%A0%B7%E5%BC%8F%E5%86%85%E5%AE%B9%E5%B1%85%E4%B8%AD-toc\" style=\"margin-left:0px;\"><a href=\"#5.excel%E5%AD%97%E4%BD%93%E6%A0%B7%E5%BC%8F%E5%86%85%E5%AE%B9%E5%B1%85%E4%B8%AD\">5.excel字体样式内容居中</a></p>\n<p id=\"6.%E5%B0%86%E4%B8%89%E4%B8%AA%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E5%90%8E%E6%B3%A8%E5%86%8C%E5%90%8E%E6%9C%80%E7%BB%88%E4%BB%A3%E7%A0%81%3A-toc\" style=\"margin-left:0px;\"><a href=\"#6.%E5%B0%86%E4%B8%89%E4%B8%AA%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E5%90%8E%E6%B3%A8%E5%86%8C%E5%90%8E%E6%9C%80%E7%BB%88%E4%BB%A3%E7%A0%81%3A\">6.将三个工具类初始化后注册后最终代码:</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h1 id=\"1.%E9%9C%80%E6%B1%82%E8%83%8C%E6%99%AF%3A\">1.需求背景:</h1>\n<p>①需要从第三方获取数据,第三方接口有两个参数,开始时间和结束时间</p>\n<p>②获取回来的数据并没有入库,所以不能通过数据库将数据归类统计,excel合并大概的流程是判断上一行或者左右相邻列是否相同,然后进行合并,所以不能是零散的数据且客户要求每一个自治区和每一个航站要统计总数(后续会出一个数据整合文章),咱们默认数据已经整理好了.效果如下:</p>\n<p><img alt=\"\" height=\"169\" src=\"image\\d9bf342233614227b93e5ebf8a9b9f9f.png\" width=\"728\"/></p>\n<p>③最终效果:</p>\n<p><img alt=\"\" height=\"546\" src=\"image\\66ab977de4c44236b9a126d87ab35677.png\" width=\"690\"/></p>\n<h1 id=\"2.%E5%88%9D%E6%AD%A5%E5%AE%9E%E7%8E%B0%3A\">2.初步实现:</h1>\n<p>①利用easyExcel模板填充,实现效果如下图</p>\n<p><img alt=\"\" height=\"413\" src=\"image\\e501f41c32d84b8b956328bced0c3504.png\" width=\"698\"/></p>\n<p>代码:</p>\n<pre><code class=\"language-java\">        //模板位置\n        InputStream template = new PathMatchingResourcePatternResolver()\n        .getResource(\"templates/飞机扑救火场统计表.xlsx\").getInputStream();\n\n        response.setContentType(\"application/octet-stream\");\n        response.setCharacterEncoding(\"utf-8\");\n        // 这里URLEncoder.encode可以防止中文乱码\n        response.setHeader(\"Content-Disposition\",\n                \"attachment;filename=\" + java.net.URLEncoder.encode(\"飞机扑救火场统计表.xlsx\", \"UTF-8\"));\n        //ExcelWriter该对象用于通过POI将值写入Excel\n        ExcelWriter excelWriter = EasyExcel.write(response.getOutputStream()).withTemplate(template).build();\n        //构建excel的sheet         \n        WriteSheet writeSheet = EasyExcel.writerSheet().build();\n        Map&lt;String, String&gt; fileData = new HashMap&lt;&gt;();\n        fileData.put(\"beginDate\", beginDate);\n        fileData.put(\"endDate\", endDate);\n        excelWriter.fill(list, writeSheet);\n        excelWriter.fill(fileData, writeSheet);\n        excelWriter.finish();</code></pre>\n<p>模板:</p>\n<p><img alt=\"\" height=\"173\" src=\"image\\895dbd05cde7415db87a6a014eca70a2.png\" width=\"714\"/></p>\n<h1 id=\"3.%E5%88%97%E5%90%88%E5%B9%B6\">3.列合并</h1>\n<p> 列合并工具类,合并代码在afterCellDispose这个方法中,不管是列合并还是行合并其实是重写这个方法,将你的合并逻辑写在里面就可以.</p>\n<pre><code class=\"language-java\">//列合并工具类\npublic class ExcelFillCellMergePrevColUtils implements CellWriteHandler {\n    private static final String KEY =\"%s-%s\";\n    //所有的合并信息都存在了这个map里面\n    Map&lt;String, Integer&gt; mergeInfo = new HashMap&lt;&gt;();\n\n    public ExcelFillCellMergePrevColUtils() {\n    }\n\n    @Override\n    public void beforeCellCreate(WriteSheetHolder writeSheetHolder, WriteTableHolder writeTableHolder, Row row, Head head, Integer integer, Integer integer1, Boolean aBoolean) {\n\n    }\n\n    @Override\n    public void afterCellCreate(WriteSheetHolder writeSheetHolder, WriteTableHolder writeTableHolder, Cell cell, Head head, Integer integer, Boolean aBoolean) {\n\n    }\n\n    @Override\n    public void afterCellDataConverted(WriteSheetHolder writeSheetHolder, WriteTableHolder writeTableHolder, CellData cellData, Cell cell, Head head, Integer integer, Boolean aBoolean) {\n\n    }\n\n    @Override\n    public void afterCellDispose(WriteSheetHolder writeSheetHolder, WriteTableHolder writeTableHolder, List&lt;CellData&gt; list, Cell cell, Head head, Integer integer, Boolean aBoolean) {\n        //当前行\n        int curRowIndex = cell.getRowIndex();\n        //当前列\n        int curColIndex = cell.getColumnIndex();\n        \n        Integer num = mergeInfo.get(String.format(KEY, curRowIndex, curColIndex));\n        if(null != num){\n            // 合并最后一行 ,列\n            mergeWithPrevCol(writeSheetHolder, cell, curRowIndex, curColIndex,num);\n        }\n    }\n    public void mergeWithPrevCol(WriteSheetHolder writeSheetHolder, Cell cell, int curRowIndex, int curColIndex, int num) {\n        Sheet sheet = writeSheetHolder.getSheet();\n        CellRangeAddress cellRangeAddress = new CellRangeAddress(curRowIndex, curRowIndex, curColIndex, curColIndex + num);\n        sheet.addMergedRegion(cellRangeAddress);\n    }\n    //num从第几列开始增加多少列,(6,2,7)代表的意思就是第6行的第2列至第2+7也就是9列开始合并\n    public void add (int curRowIndex,  int curColIndex , int num){\n        mergeInfo.put(String.format(KEY, curRowIndex, curColIndex),num);\n    }\n\n}</code></pre>\n<p></p>\n<p><img alt=\"\" height=\"405\" src=\"image\\4e887cbf24df4c1f959b564c0fc11ba5.png\" width=\"1200\"/></p>\n<p></p>\n<p><img alt=\"\" height=\"915\" src=\"image\\934a51525f114971813f35db36721105.png\" width=\"1200\"/></p>\n<p>可以参考下面的这个excel看一下,广西壮族自治区的航站合计是从第8行,第2列开始+2列的范围合并</p>\n<p>列合并效果图:<img alt=\"\" height=\"520\" src=\"image\\112aa1555aac49fe90afcff6487e7e02.png\" width=\"898\"/></p>\n<h1 id=\"4.%E8%A1%8C%E5%90%88%E5%B9%B6\">4.行合并</h1>\n<p>行合并工具类初级版本: </p>\n<p>报错位置：ExcelFillCellMergeStrategyUtils合并策略类的 mergeWithPrevRow()方法中</p>\n<p>这一行代码会报空指针异常 java.lang.NullPointerException</p>\n<pre><code class=\"language-java\">Row preRow = cell.getSheet().getRow(curRowIndex - 1);</code></pre>\n<p> <img alt=\"\" height=\"895\" src=\"image\\19763c5123f249a08eab6daa5ec4e879.png\" width=\"1179\"/></p>\n<p></p>\n<p>原因:</p>\n<p>debug发现，cell.getSheet() 行的下标第0到42的数据行，获取的是同一个 sheet 实例</p>\n<p>当下标为43时，执行cell.getSheet()获取到的 sheet 实例不一样</p>\n<p>而下标0到42的行数据被存储到 存储sheet中。如果上一行为空则去缓存中获取上一行,</p>\n<pre>writeSheetHolder.getCachedSheet()\n</pre>\n<pre><code class=\"language-java\">   Row preRow = cell.getSheet().getRow(curRowIndex - 1);\n        if (preRow == null) {\n            // 当获取不到上一行数据时，使用缓存sheet中数据\n            preRow = writeSheetHolder.getCachedSheet().getRow(curRowIndex - 1);\n        }\n        Cell preCell=preRow.getCell(curColIndex);</code></pre>\n<p>行合并工具类最终版:</p>\n<pre><code class=\"language-java\">public class ExcelFillCellMergeStrategyUtils implements CellWriteHandler {\n\n    /**\n     * 合并字段的下标\n     */\n    private int[] mergeColumnIndex;\n    /**\n     * 合并几行\n     */\n    private int mergeRowIndex;\n\n    public ExcelFillCellMergeStrategyUtils(int mergeRowIndex, int[] mergeColumnIndex) {\n        this.mergeRowIndex = mergeRowIndex;\n        this.mergeColumnIndex = mergeColumnIndex;\n    }\n\n    @Override\n    public void beforeCellCreate(WriteSheetHolder writeSheetHolder, WriteTableHolder writeTableHolder, Row row,\n                                 Head head, Integer integer, Integer integer1, Boolean aBoolean) {\n\n    }\n\n    @Override\n    public void afterCellCreate(WriteSheetHolder writeSheetHolder, WriteTableHolder writeTableHolder, Cell cell,\n                                Head head, Integer integer, Boolean aBoolean) {\n\n\n\n\n    }\n\n\n\n    @Override\n    public void afterCellDataConverted(WriteSheetHolder writeSheetHolder, WriteTableHolder writeTableHolder,\n                                       CellData cellData, Cell cell, Head head, Integer integer, Boolean aBoolean) {\n\n    }\n\n    @Override\n    public void afterCellDispose(WriteSheetHolder writeSheetHolder, WriteTableHolder writeTableHolder,\n                                 List&lt;CellData&gt; list, Cell cell, Head head, Integer integer, Boolean aBoolean) {\n\n        //当前行\n        int curRowIndex = cell.getRowIndex();\n        //当前列\n        int curColIndex = cell.getColumnIndex();\n\n        if (curRowIndex &gt; mergeRowIndex) {\n            for (int i = 0; i &lt; mergeColumnIndex.length; i++) {\n                if (curColIndex == mergeColumnIndex[i]) {\n                    mergeWithPrevRow(writeSheetHolder, cell, curRowIndex, curColIndex);\n                    break;\n                }\n            }\n        }\n\n    }\n\n    private void mergeWithPrevRow(WriteSheetHolder writeSheetHolder, Cell cell, int curRowIndex, int curColIndex) {\n        //获取当前行的当前列的数据和上一行的当前列列数据，通过上一行数据是否相同进行合并\n        Object curData = cell.getCellTypeEnum() == CellType.STRING ? cell.getStringCellValue() :\n                cell.getNumericCellValue();\n        Row preRow = cell.getSheet().getRow(curRowIndex - 1);\n        if (preRow == null) {\n            // 当获取不到上一行数据时，使用缓存sheet中数据\n            preRow = writeSheetHolder.getCachedSheet().getRow(curRowIndex - 1);\n        }\n        Cell preCell=preRow.getCell(curColIndex);\n            Object preData = preCell.getCellTypeEnum() == CellType.STRING ? preCell.getStringCellValue() :\n                    preCell.getNumericCellValue();\n            // 比较当前行的第一列的单元格与上一行是否相同，相同合并当前单元格与上一行\n            if (curData.equals(preData)) {\n                Sheet sheet = writeSheetHolder.getSheet();\n                List&lt;CellRangeAddress&gt; mergeRegions = sheet.getMergedRegions();\n                boolean isMerged = false;\n                for (int i = 0; i &lt; mergeRegions.size() &amp;&amp; !isMerged; i++) {\n                    CellRangeAddress cellRangeAddr = mergeRegions.get(i);\n                    // 若上一个单元格已经被合并，则先移出原有的合并单元，再重新添加合并单元\n                    if (cellRangeAddr.isInRange(curRowIndex - 1, curColIndex)) {\n                        sheet.removeMergedRegion(i);\n                        cellRangeAddr.setLastRow(curRowIndex);\n                        sheet.addMergedRegion(cellRangeAddr);\n                        isMerged = true;\n                    }\n                }\n                // 若上一个单元格未被合并，则新增合并单元\n                if (!isMerged) {\n                    CellRangeAddress cellRangeAddress = new CellRangeAddress(curRowIndex - 1, curRowIndex, curColIndex,\n                            curColIndex);\n                    sheet.addMergedRegion(cellRangeAddress);\n                }\n            }\n\n\n\n\n\n    }\n}</code></pre>\n<h1 id=\"5.excel%E5%AD%97%E4%BD%93%E6%A0%B7%E5%BC%8F%E5%86%85%E5%AE%B9%E5%B1%85%E4%B8%AD\">5.excel字体样式内容居中</h1>\n<p>样式工具类: </p>\n<pre><code class=\"language-java\">public class CellStyleStrategy extends AbstractCellStyleStrategy {\n\n    private WriteCellStyle headWriteCellStyle;\n    private List&lt;WriteCellStyle&gt; contentWriteCellStyleList;\n\n    private CellStyle headCellStyle;\n    private List&lt;CellStyle&gt; contentCellStyleList;\n\n    public CellStyleStrategy(WriteCellStyle headWriteCellStyle,\n                                       List&lt;WriteCellStyle&gt; contentWriteCellStyleList) {\n        this.headWriteCellStyle = headWriteCellStyle;\n        this.contentWriteCellStyleList = contentWriteCellStyleList;\n    }\n\n    public CellStyleStrategy(WriteCellStyle headWriteCellStyle, WriteCellStyle contentWriteCellStyle) {\n        this.headWriteCellStyle = headWriteCellStyle;\n        contentWriteCellStyleList = new ArrayList&lt;WriteCellStyle&gt;();\n        contentWriteCellStyleList.add(contentWriteCellStyle);\n    }\n\n    @Override\n    protected void initCellStyle(Workbook workbook) {\n        if (headWriteCellStyle != null) {\n            headCellStyle = StyleUtil.buildHeadCellStyle(workbook, headWriteCellStyle);\n        }\n        if (contentWriteCellStyleList != null &amp;&amp; !contentWriteCellStyleList.isEmpty()) {\n            contentCellStyleList = new ArrayList&lt;CellStyle&gt;();\n            for (WriteCellStyle writeCellStyle : contentWriteCellStyleList) {\n                contentCellStyleList.add(StyleUtil.buildContentCellStyle(workbook, writeCellStyle));\n            }\n        }\n    }\n\n    @Override\n    protected void setHeadCellStyle(Cell cell, Head head, Integer relativeRowIndex) {\n        if (headCellStyle == null) {\n            return;\n        }\n        cell.setCellStyle(headCellStyle);\n    }\n\n    @Override\n    protected void setContentCellStyle(Cell cell, Head head, Integer relativeRowIndex) {\n        if (contentCellStyleList == null || contentCellStyleList.isEmpty()) {\n            return;\n        }\n        cell.setCellStyle(contentCellStyleList.get(0));\n    }\n\n}</code></pre>\n<pre><code class=\"language-java\"> public CellStyleStrategy horizontalCellStyleStrategyBuilder() {\n        WriteCellStyle headWriteCellStyle = new WriteCellStyle();\n        //设置头字体\n        WriteFont headWriteFont = new WriteFont();\n        headWriteFont.setFontHeightInPoints((short) 13);\n        headWriteFont.setBold(true);\n        headWriteCellStyle.setWriteFont(headWriteFont);\n        //设置头居中\n        headWriteCellStyle.setHorizontalAlignment(HorizontalAlignment.CENTER);\n        //内容策略\n        WriteCellStyle contentWriteCellStyle = new WriteCellStyle();\n        //设置 水平居中\n        contentWriteCellStyle.setHorizontalAlignment(HorizontalAlignment.CENTER);\n        //垂直居中\n        contentWriteCellStyle.setVerticalAlignment(VerticalAlignment.CENTER);\n\n        return new CellStyleStrategy(headWriteCellStyle, contentWriteCellStyle);\n    }</code></pre>\n<h1 id=\"6.%E5%B0%86%E4%B8%89%E4%B8%AA%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E5%90%8E%E6%B3%A8%E5%86%8C%E5%90%8E%E6%9C%80%E7%BB%88%E4%BB%A3%E7%A0%81%3A\">6.将三个工具类初始化后注册后最终代码:</h1>\n<pre><code class=\"language-java\"> public void exportExcel(HttpServletResponse response, String beginDate, String endDate) throws IOException {\n\n        ExcelFillCellMergePrevColUtils excelFillCellMergePrevColUtils = new ExcelFillCellMergePrevColUtils();\n\n        String terminalTotal = \"航站合计\";\n        String provinceTotal = \"省区合计\";\n        Map&lt;String, ProvinceInfo&gt; map = handlePlaneDownFire(beginDate, endDate);\n        List&lt;PlaneDownFire&gt; list = new ArrayList&lt;&gt;();\n        map.forEach((k, v) -&gt; {\n            //添加航站合计\n            v.getTerminalInfos().forEach((k1, v1) -&gt; {\n                list.addAll(v1.getList());\n                int size = list.size();\n                excelFillCellMergePrevColUtils.add(size + 3, 2, 2);\n                CommissionInfo terminalCommissionInfoTotal = v1.getSum();\n                PlaneDownFire planeDownFire = CommissionInfoConvert.INSTANCE.commissionInfo2planeDownFire(terminalCommissionInfoTotal);\n                planeDownFire.setProvincialArea(v.getName())\n                        .setMachineNumber(String.valueOf(size))\n                        .setFlyingCommission(String.valueOf(size))\n                        .setTerminal(v1.getName())\n                        .setModel(terminalTotal);\n                list.add(planeDownFire);\n            });\n            int size = list.size();\n            excelFillCellMergePrevColUtils.add(size + 3, 1, 3);\n            //省区合计\n            CommissionInfo provinceCommissionInfoTotal = v.getSum();\n            PlaneDownFire planeDownFire = CommissionInfoConvert.INSTANCE.commissionInfo2planeDownFire(provinceCommissionInfoTotal);\n            planeDownFire.setProvincialArea(v.getName())\n                    .setTerminal(provinceTotal)\n                    .setModel(String.valueOf(size));\n            list.add(planeDownFire);\n\n        });\n\n\n        //设置第几列开始合并\n        int[] mergeColumnIndex = {0, 1, 2, 3};\n        //设置第几行开始合并\n        int mergeRowIndex = 3;\n\n        ExcelFillCellMergeStrategyUtils excelFillCellMergeStrategyUtils = new ExcelFillCellMergeStrategyUtils(mergeRowIndex, mergeColumnIndex);\n\n        InputStream template = new PathMatchingResourcePatternResolver().getResource(\"templates/飞机扑救火场统计表.xlsx\").getInputStream();\n\n\n            response.setContentType(\"application/octet-stream\");\n            response.setCharacterEncoding(\"utf-8\");\n            // 这里URLEncoder.encode可以防止中文乱码\n            response.setHeader(\"Content-Disposition\",\n                    \"attachment;filename=\" + java.net.URLEncoder.encode(\"飞机扑救火场统计表.xlsx\", \"UTF-8\"));\n            //ExcelWriter该对象用于通过POI将值写入Excel\n            ExcelWriter excelWriter = EasyExcel.write(response.getOutputStream()).withTemplate(template)\n                     //样式注册\n                    .registerWriteHandler(horizontalCellStyleStrategyBuilder())\n                     //行注册\n                    .registerWriteHandler(excelFillCellMergeStrategyUtils)\n                     //列注册\n                    .registerWriteHandler(excelFillCellMergePrevColUtils)\n                    .build();\n            //构建excel的sheet\n            WriteSheet writeSheet = EasyExcel.writerSheet().build();\n            Map&lt;String, String&gt; fileData = new HashMap&lt;&gt;();\n            fileData.put(\"beginDate\", beginDate);\n            fileData.put(\"endDate\", endDate);\n            excelWriter.fill(fileData, writeSheet);\n            excelWriter.fill(list, writeSheet);\n            excelWriter.finish();\n\n    }</code></pre>\n<p>总结:EasyExcel动态导出几乎能够满足大部分需求,说到底还是实现CellWriteHandler 类里面的</p>\n<pre>afterCellDispose方法,里面实现你想要的效果.</pre>\n</div>\n</div>"}