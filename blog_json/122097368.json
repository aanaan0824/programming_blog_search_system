{"blogid": "122097368", "writerAge": "码龄1年", "writerBlogNum": "24", "writerCollect": "140", "writerComment": "5", "writerFan": "21", "writerGrade": "2级", "writerIntegral": "319", "writerName": "NEU！", "writerProfileAdress": "writer_image\\profile_122097368.jpg", "writerRankTotal": "73568", "writerRankWeekly": "491984", "writerThumb": "67", "writerVisitNum": "28182", "blog_read_count": "7756", "blog_time": "于 2021-12-22 23:54:10 发布", "blog_title": "C++实现快速排序", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h2>概述：</h2>\n<blockquote>\n<p>快速排序是对冒泡排序的一种改进。基本思想是：通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>\n<p><span style=\"background-color:#cccccc;\">首先用数组的第一个数作为</span><strong><span style=\"background-color:#cccccc;\">枢轴</span></strong><span style=\"background-color:#cccccc;\">，然后将所有比它小的数都放到它的位置之前，所有比它大的数都放到它的位置之后，由此可以该“枢轴“记录最后所落的位置i作为分界线，将序列分割成两个子序列。这个过程称为一趟快速排序。</span></p>\n<p>一趟快速排序的算法是：</p>\n<ol><li> <p>​设置两个变量i、j，排序开始的时候：令i=0，j=length-1；</p> </li><li> <p>​以第一个数组元素作为枢轴，赋值给key，即key=array[0]；</p> </li><li> <p>​从j开始向前扫描，找到第一个小于key的值array[j]，将array[j]和array[i]的值交换；</p> </li><li> <p>​从i开始向后扫描，找到第一个大于key的值array[i]，将array[i]和array[j]的值交换；</p> </li><li> <p>重复第3、4步，直到i==j，将枢轴元素移到正确位置上，即将key赋值给array[i]。</p> </li></ol>\n<p>时间复杂度：通常，快速排序被认为是，在所有同数量级(O(nlogn))的排序方法中，其平均性能最好。但是，若初始记录序列按关键字有序或基本有序时，快速排序将蜕化为冒泡排序，其时间复杂度为O(n²)。</p>\n<p>最坏：<strong><span style=\"background-color:#ffd900;\">O(n²) </span></strong>       最好和平均：<strong><span style=\"background-color:#ffd900;\">O(nlogn)</span></strong></p>\n</blockquote>\n<h2>代码：</h2>\n<pre><code>//快速排序\n#include &lt;iostream&gt; \nusing namespace std;\nvoid QuickSort(int *array,int low,int high){\t//快排 \n\tif(low&gt;=high){\t//若待排序序列只有一个元素，返回空 \n\t\treturn ;\n\t}\n\tint i=low;\t//i作为指针从左向右扫描 \n\tint j=high;\t//j作为指针从右向左扫描\n\tint key=array[low];//第一个数作为基准数 \n\twhile(i&lt;j){\n\t\twhile(array[j]&gt;=key&amp;&amp;i&lt;j){\t//从右边找小于基准数的元素 （此处由于j值可能会变，所以仍需判断i是否小于j） \n\t\t\tj--;\t//找不到则j减一 \n\t\t}\n\t\tarray[i]=array[j];\t//找到则赋值 \n\t\twhile(array[i]&lt;=key&amp;&amp;i&lt;j){\t//从左边找大于基准数的元素 \n\t\t\ti++;\t//找不到则i加一 \n\t\t}\n\t\tarray[j]=array[i];\t//找到则赋值 \n\t}\n\tarray[i]=key;\t//当i和j相遇，将基准元素赋值到指针i处 \n\tQuickSort(array,low,i-1);\t//i左边的序列继续递归调用快排 \n\tQuickSort(array,i+1,high);\t//i右边的序列继续递归调用快排 \n}\nint main(){\n\tint array[]={49,38,65,97,76,13,27,49};\n\tint length=sizeof(array)/sizeof(*array);\n\tcout&lt;&lt;\"原始序列：\";\n\tfor(int i=0;i&lt;length;i++){\n\t\tcout&lt;&lt;array[i]&lt;&lt;\" \";\n\t}\n\tcout&lt;&lt;endl;\n\tQuickSort(array,0,length-1);\n\tcout&lt;&lt;\"快排序列：\";\n\tfor(int i=0;i&lt;length;i++){\n\t\tcout&lt;&lt;array[i]&lt;&lt;\" \";\n\t}\n\treturn 0;\n}</code></pre>\n<h3>运行示例：</h3>\n<p><img alt=\"\" height=\"166\" src=\"image\\3b297e4c792a47c89e1ab4380415d3bb.png\" width=\"563\"/></p>\n</div>\n</div>"}