{"blogid": "126501930", "writerAge": "码龄4年", "writerBlogNum": "22", "writerCollect": "780", "writerComment": "1351", "writerFan": "1208", "writerGrade": "5级", "writerIntegral": "2843", "writerName": "张小姐的猫", "writerProfileAdress": "writer_image\\profile_126501930.jpg", "writerRankTotal": "8174", "writerRankWeekly": "183", "writerThumb": "858", "writerVisitNum": "18379", "blog_read_count": "1180", "blog_time": "于 2022-09-07 08:15:00 发布", "blog_title": "【Linux】进程概念（万字详解）—— 冯诺依曼体系结构 | 操作系统 | 进程", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-light\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h1><a id=\"Linux__0\"></a>⚡欢迎来到Linux专栏 ~~进程概念</h1>\n<blockquote>\n<hr color=\"#000000\" size='1\"'/>\n<ul><li>(꒪ꇴ꒪(꒪ꇴ꒪ )🐣,我是<strong>Scort</strong>🎓</li><li>🌍博客主页：<a href=\"https://blog.csdn.net/qq_42996461?spm=1011.2124.3001.5343\">张小姐的猫~江湖背景</a>🌍</li><li>快上车🚘，握好方向盘跟我有一起打天下嘞！</li><li>送给自己的一句鸡汤🤔：</li><li><strong>🔥集中起来的意志可以击穿顽石🔥</strong></li><li>🙏作者水平很有限，如果发现错误，可在评论区指正，感谢🙏</li><li><strong>🎉🎉欢迎持续关注！🎉🎉</strong><br/> <img alt=\"在这里插入图片描述\" src=\"image\\7a6bf08226ce422faf30e729dfcb147f.png\"/></li></ul>\n</blockquote>\n<p><img alt=\"请添加图片描述\" src=\"https://img-blog.csdnimg.cn/38790f03625a42d0a9549834603690f5.gif\"/></p>\n<p></p>\n<div class=\"toc\">\n<h3>【Linux】进程概念 —— 冯诺依曼体系结构 | 操作系统 | 进程</h3>\n<ul><li><a href=\"#Linux__0\">⚡欢迎来到Linux专栏 ~~进程概念</a></li><li><a href=\"#_27\">一、冯洛伊曼体系结构</a></li><li><ul><li><a href=\"#_28\">🌌体系结构</a></li><li><a href=\"#_38\">🌌数据流向</a></li><li><a href=\"#_57\">🌌实例</a></li></ul>\n</li><li><a href=\"#_Operator_System_65\">二、操作系统 (Operator System)</a></li><li><ul><li><a href=\"#what_66\">🌈是什么what？</a></li><li><a href=\"#why_69\">🌈为什么why？</a></li><li><a href=\"#how_76\">🌈怎么样管理how？</a></li></ul>\n</li><li><a href=\"#_process_111\">三、进程 (process)</a></li><li><ul><li><a href=\"#_112\">🌊基本概念</a></li><li><a href=\"#PCB_124\">🌊描述进程-PCB</a></li><li><a href=\"#_176\">🌊组织进程</a></li></ul>\n</li><li><a href=\"#_183\">四、查看进程</a></li><li><a href=\"#_233\">五、通过系统调用获取进程标示符</a></li><li><a href=\"#fork_287\">六、通过系统调用创建进程-fork初识</a></li><li><ul><li><a href=\"#1fork_309\">1️⃣如何理解fork创建子进程</a></li><li><a href=\"#2fork_324\">2️⃣fork有两个返回值</a></li></ul>\n</li><li><a href=\"#_382\">七、进程状态</a></li><li><ul><li><a href=\"#_385\">💦进程状态</a></li><li><a href=\"#_518\">💦僵尸进程</a></li><li><a href=\"#_565\">💦孤儿进程</a></li></ul>\n</li><li><a href=\"#__575\">八. 进程优先级</a></li><li><ul><li><a href=\"#_583\">✨查看优先级</a></li><li><a href=\"#_603\">✨调整优先级</a></li></ul>\n</li><li><a href=\"#_636\">📢写在最后</a></li></ul>\n</div>\n<p></p>\n<p><img alt=\"请添加图片描述\" src=\"image\\ca9229e0d5da4167b77717c5e31c9433.png\"/></p>\n<h1><a id=\"_27\"></a>一、冯洛伊曼体系结构</h1>\n<h2><a id=\"_28\"></a>🌌体系结构</h2>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\036565e925bc4eb098608384d01e6246.png\"/><br/> 说明：</p>\n<ol><li>输入设备：键盘，摄像头，话筒，<strong>磁盘</strong>，网卡</li><li>输出设备：显示器、<strong>磁盘</strong>、网卡、显卡、音响</li><li>存储器：指的是<strong>内存</strong>！不是磁盘</li><li>中央处理器：其中<strong>运算器</strong>进行<strong>算术运算</strong>和<strong>逻辑运算</strong></li></ol>\n<h2><a id=\"_38\"></a>🌌数据流向</h2>\n<p>冯 • 诺依曼体系结构规定了硬件层面上的数据流向，所有的输入单元的数据必须<strong>先写到存储器中</strong> (这里只是针对数据，不包含信号(通过外设直接对 CPU 交互))，然后 <code>CPU</code> 通过某种方式<strong>访问存储器</strong>，将数据读取到 CPU 内部，运算器进行运算，控制器进行控制，然后将结果写回到内存，最后将结果传输到输出设备中。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\443c850749e446a582f9b9359c0cd57d.png\"/><br/> 由上图我们知道</p>\n<blockquote>\n<p>cpu &amp;&amp;寄存器 &gt; 内存 &gt; 磁盘/SSD &gt; 光盘 &gt; 磁带</p>\n</blockquote>\n<p>这里有一个不太严谨的运算速度的数据，CPU 是纳秒级别的；内存是微秒级别的；磁盘是毫秒级别的。当一个快的设备和一个慢的设备一起协同时，最终的运算效率肯定是以慢的设备为主，就如 “ <strong>木桶原理</strong> ”：也就是说一般 CPU 去计算时，它的<code>短板就在磁盘上</code>，所以整个计算机体系的效率就一定会被磁盘拖累，如果把软件数据放在内存里，cpu直接和内存交互，如此一来效率大大提升。</p>\n<p>所以本质上可以把<strong>内存看作 CPU 和所有外设之间的缓存</strong>，也可以理解成这是内存的价值。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\3aaf07e21685457da538990a82848477.png\"/></p>\n<p>🔥<strong>总结</strong>：<strong>CPU不直接和外设打交道</strong>，因为CPU很快，外设很慢。因此有<strong>存储器</strong>在二者间<strong>起缓冲作用</strong>。在数据层面，任何外设，基本优先对内存读写；CPU也是直接对<strong>内存</strong>读写，内存是体系结构的<strong>核心设备</strong>，<code>IO = input + output。</code></p>\n<h2><a id=\"_57\"></a>🌌实例</h2>\n<p>对冯诺依曼的理解，不能只停留在概念上，要深入到对软件数据流理解上，请解释，从你登录上qq开始和某位朋友聊天开始，数据的流动过程。从你打开窗口，开始给他发消息，到他的到消息之后的数据流动过程。如果是在qq上发送文件呢？</p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\f7983393bbd04b7da3fc4da7565ae93e.png\"/><br/> 同理文件也是这样子接收的</p>\n<h1><a id=\"_Operator_System_65\"></a>二、操作系统 (Operator System)</h1>\n<h2><a id=\"what_66\"></a>🌈是什么what？</h2>\n<p>操作系统，是一款专门针对<strong>软硬件进行管理</strong>的<strong>软件</strong>。</p>\n<h2><a id=\"why_69\"></a>🌈为什么why？</h2>\n<p>在整个计算机软硬件架构中，操作系统的定位是：一款纯正的“<strong>搞管理</strong>”的软件</p>\n<ul><li class=\"task-list-item\"><input class=\"task-list-item-checkbox\" disabled=\"disabled\" type=\"checkbox\"/> 对上：给用户提供稳定、高效、安全的运行环境 —— 目的</li><li class=\"task-list-item\"><input class=\"task-list-item-checkbox\" disabled=\"disabled\" type=\"checkbox\"/> 对下：管理好软硬件资源 —— 方式</li></ul>\n<h2><a id=\"how_76\"></a>🌈怎么样管理how？</h2>\n<p>🌊以学校中的<strong>管理</strong>类比，操作系统中——在学校里大概有这三种角色：</p>\n<ol><li>管理者和被管理者并<strong>不会直接打交道</strong>（就好像你在学校见过校长吗❓）<br/> 学生 (<code>被管理者</code>) —— 软硬件<br/> 辅导员 <code>(执行者</code>) —— 驱动<br/> 校长 (<code>管理者)</code> —— 操作系统</li><li>如何管理我们？<br/> 对我们做出各种<strong>决策</strong>，依据就是你的<strong>核心数据</strong></li><li>校长是如何做执行的？你的数据如何被校长拿到？<br/> 通过辅导员</li></ol>\n<p>🚩站在校长的角度———</p>\n<ul><li class=\"task-list-item\"><input class=\"task-list-item-checkbox\" disabled=\"disabled\" type=\"checkbox\"/> 用结构体来<strong>描述</strong>一个学生的数据</li><li class=\"task-list-item\"><input class=\"task-list-item-checkbox\" disabled=\"disabled\" type=\"checkbox\"/> 来用特定的数据结构来<strong>组织</strong>，于是对学生的管理工作，变成了对数据结构的增删查改———对多个学生进行管理！</li></ul>\n<p>⚡管理的理念—— <strong>先描述，再组织</strong></p>\n<ul><li class=\"task-list-item\"><input class=\"task-list-item-checkbox\" disabled=\"disabled\" type=\"checkbox\"/> <strong>先描述</strong>：被管理的对象</li><li class=\"task-list-item\"><input class=\"task-list-item-checkbox\" disabled=\"disabled\" type=\"checkbox\"/> <strong>再组织</strong>：将被管理的对象用特定的<strong>数据结构</strong>组织起来</li></ul>\n<p>🌏对应到操作系统——</p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\0db5f66d3ad846bcb606fd16ed98304f.png\"/><br/> ⚡系统调用和库函数概念 ❗</p>\n<ol><li>在开发角度，操作系统对外会表现为<code>一个整体</code>，它不相信任何用户，但是会<strong>暴露</strong>自己的<strong>部分接口</strong>，<strong>供上层开发者使用</strong>，这部分由操作系统提供的接口，叫做系统调用。</li><li>系统调用在使用上，功能比较基础，对用户的<code>要求相对也比较高</code>，所以，有心的开发者就对部分系统调用进行<code>适度封装</code>，从而形成库，有了库，就很有利于更上层用户或者开发者进行二次开发。</li></ol>\n<blockquote>\n<p>类似于银行取钱时，一般都会雇佣服务人员 (库)，王大爷不会取钱，就叫指导人员来指导 (调用库)。其实对于库函数的使用要么使用了 <strong>SystemCall</strong>，如 printf 函数；要么没使用 SystemCall，如 sqrt 函数。</p>\n</blockquote>\n<p>操作系统是怎么管理进行进程管理的呢？很简单，先把进程<strong>描述</strong>起来，再把进程<strong>组织</strong>起来！</p>\n<h1><a id=\"_process_111\"></a>三、进程 (process)</h1>\n<h2><a id=\"_112\"></a>🌊基本概念</h2>\n<ul><li>课本概念：程序的一个执行实例，正在执行的程序等</li><li>内核观点：担当分配系统资源（CPU时间，内存）的实体<br/> <img alt=\"在这里插入图片描述\" src=\"image\\c03009ce86874f638c1df2a229961464.png\"/></li></ul>\n<blockquote>\n<p>当我们启动一个软件的时候，本质上就是启动了一个进程<br/> 在linux中<strong>运行一条命令</strong>，<code>./xxx运行</code>的时候，其实就是在系统层面<strong>创建了一个进程</strong></p>\n</blockquote>\n<p>Linux是可以同时加载多个程序的，Linux是可能同时存在<strong>大量的进程</strong>在系统的OS、内存</p>\n<h2><a id=\"PCB_124\"></a>🌊描述进程-PCB</h2>\n<p>为什么要有PCB？因为我们要先<strong>描述</strong>进程，后<strong>管理</strong></p>\n<p>在任何进程形成的时候，操作系统要为进程创建<code>PCB</code>(<strong>process control block</strong>)，进程控制块 —— 就是<strong>描述</strong>进程的结构体</p>\n<p>我们知道：<strong>文件 = 内容 + 属性</strong><br/> 把mytest.exe加载到内存里，本质上<code>只是把内容加载到内存</code>里，可是我们要管理进程，这里就需要大量的<strong>PCB</strong>结构来<code>描述</code>这里的进程，其中PCB<code>包含了进程所有的属性</code>：（包括了代码在哪、数据在哪、谁启动、什么时间启动的）</p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\f16a776b4fbf42ce9804de4890b7b62c.png\"/></p>\n<p>对进程的管理，变成了对进程PCB结构体链表的增删查改❗<br/> <img alt=\"在这里插入图片描述\" src=\"image\\bb462597e9094e7581aae055079165f8.png\"/></p>\n<p>🔥🔥什么是进程？</p>\n<blockquote>\n<p><strong>进程</strong> = 对应的<code>代码和数据</code> <code>+</code> 进程对应的<code>PCB结构体</code></p>\n</blockquote>\n<pre><code class=\"prism language-c\"><span class=\"token keyword\">struct</span> <span class=\"token class-name\">PCB</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token comment\">//属性数据，进程全部的属性数据 </span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>Linux 操作系统下的 <strong>PCB</strong> 是 <code>task_struct</code>，相当于是媒婆和王婆之间的关系。它会被装载到 <strong>RAM</strong>(内存) 里并且包含着进程的信息。</p>\n<pre><code class=\"prism language-c\"><span class=\"token keyword\">struct</span> <span class=\"token class-name\">task_struct</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token comment\">//进程全部属性数据 </span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>🌌 <code>task_struct</code>中有什么属性字段？</p>\n<ol><li> <p>标示符: 描述本进程的<strong>唯一标示符</strong>，用来区别其他进程。</p> </li><li> <p>状态: 任务状态，退出代码，退出信号等。</p> </li><li> <p>优先级: 相对于其他进程的优先级。</p> </li><li> <p>程序计数器: 程序中即将被执行的<strong>下一条指令的地址</strong>。</p> </li><li> <p>内存指针: 包括<strong>程序代码</strong>和进程相关<strong>数据</strong>的指针，还有和其他进程共享的内存块的指针</p> </li><li> <p><strong>上下文数据</strong>: 进程执行时处理器的寄存器中的数据[休学例子，要加图CPU，寄存器]。</p> </li><li> <p>I／O状态信息: 包括显示的I/O请求,分配给<strong>进程的I／O设备</strong>和被进程使用的<strong>文件列表</strong>。</p> </li><li> <p>记账信息: 可能包括处理器时间总和，使用的时钟数总和，时间限制，记账号等。</p> </li><li> <p>其他信息</p> </li></ol>\n<h2><a id=\"_176\"></a>🌊组织进程</h2>\n<p>可以在内核源代码里找到它。所有运行在系统里的进程都以task_struct链表的形式存在内核里。</p>\n<h1><a id=\"_183\"></a>四、查看进程</h1>\n<p>我写了一段程序myproc.c就是隔1s打印，<code>./</code>运行，同时复制SSH渠道再打开一个窗口，便于监视进程。</p>\n<p>💦<strong>查看进程</strong></p>\n<pre><code class=\"prism language-c\">ps axj <span class=\"token operator\">|</span> grep <span class=\"token string\">\"myproc\"</span> \n</code></pre>\n<p>🌈<strong>关闭进程</strong> ——</p>\n<pre><code class=\"prism language-c\"><span class=\"token punctuation\">[</span>Ctrl <span class=\"token operator\">+</span> C<span class=\"token punctuation\">]</span>\nkill <span class=\"token operator\">-</span><span class=\"token number\">9</span> <span class=\"token punctuation\">[</span>pid<span class=\"token punctuation\">]</span> 向目标进程发送<span class=\"token number\">9</span>号信号 <span class=\"token operator\">--</span> 同时也证明pid能标识系统上的唯一进程\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\823ac4c0434340e78800719dbf3d28a7.png\"/></p>\n<p>其中下面的是grep进程，我们不用管</p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\644f61d31f6541fbabb8f0c9114def96.png\"/></p>\n<p>🌈以<strong>文件形式查看进程</strong> ——<code>/proc</code>是Linux系统下查看进程的目录</p>\n<pre><code class=\"prism language-c\">ls <span class=\"token operator\">/</span>proc\ntop  <span class=\"token comment\">//不常用 相当于任务管理器</span>\n</code></pre>\n<p>进程启动后，会在<code>/proc</code>下形成<strong>目录</strong>，以自身<code>PID</code>的编号作为目录文件名 ——</p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\8dfda1f295734753821759f4a4fea5fc.png\"/></p>\n<p>🌈查看<strong>该进程</strong>的属性数据</p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\b6a579a089e941d99454b873dea3eca0.png\"/></p>\n<blockquote>\n<p>每个进程都会有一个属性，来保存自己所在的工作路径</p>\n</blockquote>\n<p>在<code>ls / proc</code> 目录中，当我们停止掉某个进程，此进程目录就会消失所以proc目录是<strong>动态</strong>的</p>\n<h1><a id=\"_233\"></a>五、通过系统调用获取进程标示符</h1>\n<p>我们可以使用 <code>man 2 getpid/getppid</code> 命令来查看人生中第一个<strong>系统调用接口</strong>：</p>\n<p>💛 <strong>查看进程PID</strong></p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\86f07d0656d14c04828e635843fc4512.png\"/></p>\n<p>执行以下代码———</p>\n<pre><code class=\"prism language-c\"> <span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;stdio.h&gt;</span></span>\n <span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;unistd.h&gt;</span></span>\n   \n <span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n <span class=\"token punctuation\">{<!-- --></span>\n     <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n     <span class=\"token punctuation\">{<!-- --></span>\n       <span class=\"token class-name\">pid_t</span> id <span class=\"token operator\">=</span> <span class=\"token function\">getpid</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//获取的是自己进程的PID</span>\n      <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello world! pid: %d\\n\"</span><span class=\"token punctuation\">,</span>id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>                                               \n      <span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n     <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\63f9e75fd47e4787ae4c62491f9f1e28.png\"/></p>\n<p><strong>父进程</strong></p>\n<p>执行以下代码———</p>\n<pre><code class=\"prism language-c\"> <span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;stdio.h&gt;</span></span>\n <span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;unistd.h&gt;</span></span>\n  \n <span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{<!-- --></span>\n      <span class=\"token class-name\">pid_t</span> pid <span class=\"token operator\">=</span> <span class=\"token function\">getppid</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//父进程</span>\n      <span class=\"token class-name\">pid_t</span> id <span class=\"token operator\">=</span> <span class=\"token function\">getpid</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//获取的是自己进程的PID</span>\n      <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello world! pid: %d, ppid: %d\\n\"</span><span class=\"token punctuation\">,</span>id<span class=\"token punctuation\">,</span>pid<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>                                            \n      <span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n <span class=\"token punctuation\">}</span>\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\bf68cfb36e9040ef92a25431f6cd424e.png\"/><br/> 这里我们发现父进程居然是<code>bash</code>，我们回想一下shell外壳 ❗❗可以看看这篇博客🚩<a href=\"https://blog.csdn.net/qq_42996461/article/details/126260729?spm=1001.2014.3001.5501\">shell外壳详解🚩</a><br/> 我们可以假设，这里的<code>bash</code>是王婆，为了完成任务，但又不想砸了自己的招牌，所以招了个实习生（可以理解成<strong>子进程</strong>）</p>\n<blockquote>\n<p>我们在操作命令行的时候，<strong>父进程永远是bash外壳</strong>，其原理：<code>shell外壳通过创建子进程的方式</code>，以bash的子进程去执行</p>\n</blockquote>\n<p>每次我们登录成功的时候，系统就会指派一个<strong>王婆</strong>跟着你，当你输入命令行的时候，王婆会说她帮你创建子进程去执行。卖个关子🚩<strong>王婆bash的父进程是谁？？</strong></p>\n<h1><a id=\"fork_287\"></a>六、通过系统调用创建进程-fork初识</h1>\n<p>💛 创建<strong>子进程</strong></p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\854a18899ee345c090729fea3e46054f.png\"/></p>\n<pre><code class=\"prism language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;stdio.h&gt;</span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;unistd.h&gt;</span></span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n   <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"I am parent process!\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n   <span class=\"token function\">fork</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n   \n   <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"you can see me ?\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n   <span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n   <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n <span class=\"token punctuation\">}</span>\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\bd4b1ad44f124b65b945650ab4e96731.png\"/>调用了fork之后，我们发现打印了两次，其实就是又两个进程在实行来执行代码，💡下面我来深入探究</p>\n<h2><a id=\"1fork_309\"></a>1️⃣如何理解fork创建子进程</h2>\n<p>✨fork本质是<code>创建进程</code>，系统中多了一个进程，就多了一份<em>与进程相关的内核数据结构<strong>PCB</strong> + <strong>进程的代码和数据</strong></em> 。 我们fork只是创建了子进程，但是子进程对应的代码和数据呢？</p>\n<ol><li>默认情况下，子进程会<code>继承</code>父进程的代码和数据<br/> 💖<strong>代码</strong>：父子进程代码共享，但是父子进程<strong>对应的id值不同</strong>，所以会执行不同的代码<br/> 💖<strong>数据</strong>：默认情况下，数据也是“<strong>共享</strong>的”，不过修改时会发生<strong>写时拷贝</strong>来维护数据的<strong>独立性</strong>。</li><li>子进程内核的数据结构<code>task_struct</code>，也会以父进程的为模板初始化自身</li></ol>\n<p>注：if 和 else if 有没有可能是同时执行的呢？</p>\n<ul><li><strong>没有</strong>！因为id在父进程里面是子进程的<code>pid</code>，在子进程里面是0，所以一般else运行父进程</li></ul>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\80b4cb6664af472ea6acb7d580224d1b.png\"/></p>\n<h2><a id=\"2fork_324\"></a>2️⃣fork有两个返回值</h2>\n<ol><li> <p>如何理解一个函数有<strong>两个返回值</strong>？</p> <p>1️⃣因为在fork内部，return时<strong>子进程已被创建</strong>，甚至可以被调度了，父子进程各自会执行return语句。<br/> 2️⃣返回两次并不意味着会保存两次（买个关子后面讲👍）</p> </li><li> <p>我们创建的子进程和父进程是做相同的事情吗？岂不是没有意义<br/> 答：是通过<code>if-else分流</code>，让父子进程各自执行不同的代码段，而这就是通过<strong>fork的返回值</strong>来完成的。<br/> ⚡<strong>创建失败</strong>：<code>&lt;0</code><br/> ⚡<strong>创建成功</strong>：给父进程返回子进程的<code>PID</code>；给子进程返回<code>0</code>，表示成功创建</p> </li><li> <p>为什么给子进程返回0，给父进程返回子进程的pid？<br/> 💡首先我们知道：<strong>父进程：子进程 = 1:n</strong><br/> 💡第二：因为父进程可能会<strong>创建多个子进程</strong>，这为了保证父进程能拿到想拿到的子进程（你爸给你起名字），而子进程返回 0 的原因是父进程对于子进程是<strong>唯一的</strong>(好比你不可能给你爸起名字)<br/> <img alt=\"在这里插入图片描述\" src=\"image\\3102547f7de643c992d5541719ce7dee.png\"/></p> </li><li> <p>父子进程被创建出来，哪一个进程先运行呢？<br/> 答：不一定！！这个是由操作系统的<code>调度器决定</code>的</p> </li></ol>\n<p>⚡多进程代码，让父子执行不同的事情：<code>if else 分流</code></p>\n<pre><code class=\"prism language-c\"> <span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;stdio.h&gt;</span></span>\n <span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;unistd.h&gt;</span></span>\n <span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n <span class=\"token punctuation\">{<!-- --></span>\n     <span class=\"token class-name\">pid_t</span> id <span class=\"token operator\">=</span> <span class=\"token function\">fork</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n     <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>id <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n     <span class=\"token punctuation\">{<!-- --></span>\n       <span class=\"token function\">perror</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"fork\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n       <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n     <span class=\"token punctuation\">}</span>\n     <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>id <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>                                                                                                             \n     <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token comment\">//子进程</span>\n        <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{<!-- --></span>\n          <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"I am child, pid :%d, ppid: %d\\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token function\">getpid</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token function\">getppid</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n     <span class=\"token punctuation\">}</span>\n     <span class=\"token keyword\">else</span>\n     <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token comment\">//父进程</span>\n        <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{<!-- --></span>\n          <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"I am father, pid :%d, ppid: %d\\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token function\">getpid</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token function\">getppid</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> <span class=\"token number\">0</span>；\n  <span class=\"token punctuation\">}</span>\n</code></pre>\n<h1><a id=\"_382\"></a>七、进程状态</h1>\n<p>进程的状态信息也是在<code>task_struct</code>（PCB）中。进程状态的意义在于，方便OS快速判断进程，并完成特定的功能，比如调度。本质上是一种分类。</p>\n<h2><a id=\"_385\"></a>💦进程状态</h2>\n<p>下面的状态在kernel源代码里定义：</p>\n<pre><code class=\"prism language-c\"><span class=\"token comment\">/*\n* The task state array is a strange \"bitmap\" of\n* reasons to sleep. Thus \"running\" is zero, and\n* you can test for combinations of others with\n* simple bit tests.\n*/</span>\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">const</span> task_state_array<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token string\">\"R (running)\"</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">/* 0 */</span>\n<span class=\"token string\">\"S (sleeping)\"</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">/* 1 */</span>\n<span class=\"token string\">\"D (disk sleep)\"</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">/* 2 */</span>\n<span class=\"token string\">\"T (stopped)\"</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">/* 4 */</span>\n<span class=\"token string\">\"t (tracing stop)\"</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">/* 8 */</span>\n<span class=\"token string\">\"X (dead)\"</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">/* 16 */</span>\n<span class=\"token string\">\"Z (zombie)\"</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">/* 32 */</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>一个完整的进程状态的变迁如下图————<br/> <img alt=\"在这里插入图片描述\" src=\"image\\b8123d5dfedd48018404e352cd37892e.png\"/></p>\n<p>⭐️ <strong>R 运行状态</strong>（running）: 并不意味着进程一定在运行中❓ 进程可能<strong>在运行队列中等</strong>或者<strong>正在被执行</strong>，就叫做 运行态，随时可以被CPU调度</p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\af32a37f141f4fa7971207bf423d1887.png\"/></p>\n<p>⭐️ <strong>S 浅度睡眠状态</strong>(sleeping) ，也叫做可中断睡眠(interruptible sleep)</p>\n<ul><li><strong>等待非CPU资源就绪</strong>。这种休眠是可被换醒的，我们可以 <code>Ctrl + C</code> 退出循环，而此时的进程就没了，也就是说它虽然是一种休眠状态，但是它随时可以接收外部的信号，处理外部的请求。</li></ul>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\7b77c87c0f47479c90f45a880b939ca6.png\"/><img alt=\"在这里插入图片描述\" src=\"image\\c640f6814ced43838d2f968004b32130.png\"/></p>\n<ul><li> <p>⭐️ <strong>挂起</strong>状态（也属于S 状态）</p> <p>当<strong>内存不足</strong>的时候，OS提供适当的<code>置换</code><strong>进程的代码和数据</strong>到磁盘中，PCB不换（好比你学籍还在，人把你赶走了）进程的状态就叫做<strong>挂起</strong> <img alt=\"在这里插入图片描述\" src=\"image\\f5573c88748e4175a2798ebee17a3daf.png\"/><br/> 📌你现在正在<strong>等待某种资源</strong>的时候，正巧<strong>内存不足</strong>了，内存不够是你正在阻塞状态，所以把你的代码数据置换到磁盘里，所以叫做“<strong>挂起阻塞</strong>”</p> </li></ul>\n<p>⭐️ <strong>D 深度睡眠状态</strong>(Disk sleep)，也叫不可中断睡眠状态(uninterruptible sleep)<br/> 进程处于D状态，<strong>不可被杀掉</strong>，耶稣来了都没用，只能等这个进程自动醒来,<strong>kill -9</strong> 都杀不掉它，也得等它醒来 （关机除外，有可能关机都要被磁盘写入卡住，只能拔电源）<br/> <img alt=\"在这里插入图片描述\" src=\"image\\f425d3efbaa546178464698fb803a222.png\"/><br/> dd命令能够演示D状态进程（想知道的同学可以自行百度）</p>\n<p>⭐️ <strong>T暂停状态</strong>(stopped)<br/> 可以通过发送 SIGSTOP（<strong>kill -19</strong>） 信号给进程来停止（T）进程。这个被暂停的进程可以通过发送 SIGCONT 信号让进程继续运行。</p>\n<p>⭐️ <strong>X死亡状态</strong>(dead)<br/> <strong>随时准备被OS回收</strong>。此状态只是一个返回状态，无法在任务列表中看到这个状态。因为回收进程是<strong>一瞬间</strong>发生的事情，我们很难直接捕捉到。</p>\n<p>⭐️ <strong>Z僵尸状态</strong>(Zombie)<br/> 💦是什么：一个进程已经退出，但还不允许被OS释放，处于一个<strong>被检测</strong>的状态（好比出事了，警察要拉警戒线去调查原因），一般是<code>父进程</code>或者<code>OS</code>，想要得知该进程的结果，如何检测呢？这个我们后文再细说</p>\n<p>💦为什么？ 维持该状态是为了让父进程和OS来<code>回收</code>，从<strong>Z</strong>状态变成<strong>X</strong></p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\fd0340d5970146af98385d47c7378e76.png\"/></p>\n<blockquote>\n<p>演示R/S/T状态：同样的复制SSH渠道，监视</p>\n</blockquote>\n<ol><li><strong>运行状态 R</strong> ——— 死循环</li></ol>\n<pre><code class=\"prism language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;stdio.h&gt;</span>      </span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>      \n<span class=\"token punctuation\">{<!-- --></span>      \n  <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    \n  <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>    \n<span class=\"token punctuation\">}</span>  \n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\327f861d89ec418abfca3040106309b4.png\"/></p>\n<ol start=\"2\"><li><strong>睡眠状态S</strong> —— sleep</li></ol>\n<pre><code class=\"prism language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;stdio.h&gt;</span> </span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;unitsd.h&gt;</span>     </span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>      \n<span class=\"token punctuation\">{<!-- --></span>      \n  <span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">;</span> <span class=\"token comment\">//睡眠100秒</span>\n  <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>    \n<span class=\"token punctuation\">}</span>  \n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\948d84c7793c4b9593ab8dc192c4ab21.png\"/></p>\n<ol start=\"3\"><li><strong>暂停状态 T</strong><br/> 我们先看看<strong>kill指令</strong><br/> <img alt=\"在这里插入图片描述\" src=\"image\\bd495c3440d04bb7ba3ca8ac00135a85.png\"/><br/> 暂停进程——<br/> <img alt=\"在这里插入图片描述\" src=\"image\\4781f20c4ddb40eca580a7f13b1b4c68.png\"/>这时，发送信号恢复状态，会发现S后面没有+号，[ctrl + C] 也没法终止程序，这是因为你的暂停和继续让进程变成了后台运行。<br/> <img alt=\"在这里插入图片描述\" src=\"image\\f37edcfc66e94fe3bcb7718a73320343.png\"/><br/> 这时候直接</li></ol>\n<pre><code class=\"prism language-c\">kill <span class=\"token operator\">-</span><span class=\"token number\">9</span>  pid <span class=\"token comment\">//可直接删除</span>\n</code></pre>\n<p>⚡ 前台进程：<code>S+</code> 和后台进程：S 的区别 ——</p>\n<ul><li>前台进程：<code>./myproc</code>，输入指令无效bash的命令行解释器就停止工作了，可以被【Ctrl +C】终止</li><li>后台进程：<code>./myproc &amp;</code>，可以执行指令，【Ctrl +C】 不能终止进程，退出进程要用<strong>kill</strong></li></ul>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\8c1c1b6e605b41aab2cfef562ef79625.png\"/></p>\n<h2><a id=\"_518\"></a>💦僵尸进程</h2>\n<ul><li>子进程退出，父进程还在运行，但<strong>父进程没有读取</strong>子进程状态，子进程就进入Z状态</li><li>僵死进程会以终止状态保持在进程表中，并且会一直在等待父进程读取退出状态代码</li></ul>\n<p>监控命令行脚本（<strong>常用</strong>）：</p>\n<pre><code class=\"prism language-c\"><span class=\"token keyword\">while</span> <span class=\"token operator\">:</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">do</span> ps axj <span class=\"token operator\">|</span> head <span class=\"token operator\">-</span><span class=\"token number\">1</span> <span class=\"token operator\">&amp;&amp;</span> ps axj <span class=\"token operator\">|</span> grep myproc <span class=\"token operator\">|</span> grep <span class=\"token operator\">-</span>v grep<span class=\"token punctuation\">;</span> sleep <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> echo <span class=\"token string\">\"########################\"</span><span class=\"token punctuation\">;</span> done\n</code></pre>\n<p>下面这段代码：我把子进程杀掉，父进程也不回收，看看子进程变啥样❓</p>\n<pre><code class=\"prism language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;iostream&gt;</span>    </span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;unistd.h&gt;</span>    </span>\n    \nusing namespace std<span class=\"token punctuation\">;</span>    \n    \n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>    \n<span class=\"token punctuation\">{<!-- --></span>    \n  <span class=\"token class-name\">pid_t</span> id <span class=\"token operator\">=</span> <span class=\"token function\">fork</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    \n  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>id <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>    \n  <span class=\"token punctuation\">{<!-- --></span>    \n    <span class=\"token comment\">//child    </span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>true<span class=\"token punctuation\">)</span>    \n    <span class=\"token punctuation\">{<!-- --></span>    \n      cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"I am a child, running!\"</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>    \n      <span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    \n    <span class=\"token punctuation\">}</span>    \n  <span class=\"token punctuation\">}</span>    \n  <span class=\"token keyword\">else</span>    \n  <span class=\"token punctuation\">{<!-- --></span>    \n    <span class=\"token comment\">//parent    </span>\n    cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"father do nothing!\"</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>    \n    <span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">50</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>                                                     \n  <span class=\"token punctuation\">}</span>    \n  <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>    \n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>如果没有人<strong>检测和回收</strong>(由父进程来做)，该进程退出就进入<strong>Z状态</strong> ——</p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\0bba8f882e1a4591baf28bb82e75ed82.png\"/></p>\n<p>⚡僵尸进程的<strong>危害</strong>：进程的退出状态被一直维持，本身就需要数据维护，占用了内存空间，长时间的占用就会导致内存泄漏！！如何避免呢？我们后面讲</p>\n<h2><a id=\"_565\"></a>💦孤儿进程</h2>\n<ul><li class=\"task-list-item\"><input class=\"task-list-item-checkbox\" disabled=\"disabled\" type=\"checkbox\"/> 父进程如果提前退出，那么子进程后退出，进入Z之后，那该如何处理呢？</li><li class=\"task-list-item\"><input class=\"task-list-item-checkbox\" disabled=\"disabled\" type=\"checkbox\"/> 父进程先退出，子进程就称之为“孤儿进程”</li><li class=\"task-list-item\"><input class=\"task-list-item-checkbox\" disabled=\"disabled\" type=\"checkbox\"/> 孤儿进程被1号<strong>init进程（系统本身</strong>）<code>领养</code>，当然要有init进程回收喽<br/> <img alt=\"在这里插入图片描述\" src=\"image\\b55cde19017440fcbfe03e6e3cf5ea92.png\"/>此时进程变成了后台进程，【ctrl+c】停止不了，我们直接kill -9就好，乱了也没事</li></ul>\n<h1><a id=\"__575\"></a>八. 进程优先级</h1>\n<p>⚡<strong>什么是</strong>优先级？<br/> <code>cpu</code><strong>资源分配的先后顺序</strong>，就是指进程的优先权（priority）</p>\n<p>⚡<strong>为什么</strong>要有优先级？<br/> 因为<strong>CPU是有限</strong>的！进程太多，需要通过某种方式（优先级）竞争资源（）</p>\n<h2><a id=\"_583\"></a>✨查看优先级</h2>\n<pre><code class=\"prism language-c\">ps <span class=\"token operator\">-</span>l\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\b3fc4a9b5d3943a7b1f36b2c9950db09.png\"/><br/> 我们很容易注意到其中的几个重要信息，有下：</p>\n<ul><li><strong>PRI</strong> ：代表这个进程可被执行的<strong>优先级</strong>，其<code>值越小越早被执行</code></li><li><strong>NI</strong> ：代表这个进程的<code>nice值</code>，优先值的修正数据；调整进程优先级，在Linux下，就是调整进程nice值</li><li><strong>UID</strong> : 代表执行者的身份</li></ul>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\ae4092fd609441629402e2b538b342f0.png\"/></p>\n<p>注：</p>\n<ul><li>需要强调一点的是，进程的nice值不是进程的优先级，他们不是一个概念，但是进程<strong>nice值会影响到进程的优先级变化</strong>。</li><li><strong>nice值</strong>是进程优先级的修正<strong>修正数据</strong></li></ul>\n<h2><a id=\"_603\"></a>✨调整优先级</h2>\n<p>Linux具体<strong>优先级做法</strong></p>\n<ul><li class=\"task-list-item\"><input class=\"task-list-item-checkbox\" disabled=\"disabled\" type=\"checkbox\"/> <strong>优先级 = 老的优先级 + nice</strong></li></ul>\n<p>⚡调整优先级：用top命令更改已存在进程的nice值（频繁操作可能需要<code>sudo</code>）</p>\n<pre><code class=\"prism language-c\">top\n进入top后按<span class=\"token string\">\"r\"</span> → 输入进程PID → 输入nice值\n</code></pre>\n<p>我们发现<code>PRI</code>默认是80<br/> <img alt=\"在这里插入图片描述\" src=\"image\\722b093df0e249ca8424b2bd56f1a338.png\"/><br/> 修改nice后：<strong>老的优先级都是80</strong>，也就是每次设置优先值都是在<code>80上加减</code><br/> <img alt=\"在这里插入图片描述\" src=\"image\\6eb92bf33d274f31b83c39a84a3d558b.png\"/>nice其取值范围是<code>-20至19</code>，一共40个级别<br/> <img alt=\"在这里插入图片描述\" src=\"image\\3bc278c6b50a4363907bd068f6fa0926.png\"/></p>\n<blockquote>\n<p>为什么nice值处在一个相对较小的范围内呢？</p>\n</blockquote>\n<p>因为优先级再怎么设置，也只能是一种<strong>相对的</strong>优先级，不能出现绝对的优先级，否则会出现严重的<strong>进程饥饿</strong>的问题。</p>\n<p>其他概念：</p>\n<ul><li>竞争性: 系统进程数目众多，而CPU资源只有少量，甚至1个，所以进程之间是具有竞争属性的。为了高效完成任务，更合理竞争相关资源，便具有了优先级</li><li>独立性: 多进程运行，需要独享各种资源，多进程运行期间<strong>互不干扰</strong></li><li>并行: 多个进程在<strong>多个CPU</strong>下分别，<strong>同时进行运行</strong>，这称之为并行</li><li>并发: 多个进程在<strong>一个CPU</strong>下采用<strong>进程切换</strong>的方式，在一段时间之内，让<strong>多个进程</strong>都得以<strong>推进</strong>，称之为并发</li></ul>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\009ed593a205478c9543022291c390b8.png\"/></p>\n<h1><a id=\"_636\"></a>📢写在最后</h1>\n<ul><li>能看到这里的都是棒棒哒🙌！</li><li>想必权限也算是Linux中重要🔥的部分了，如果认真看完以上部分，肯定有所收获。</li><li>接下来我还会继续写关于📚《<code>环境变量</code>》等…</li><li>💯如有错误可以尽管指出💯</li><li>🥇想学吗？我教你啊🥇</li><li>🎉🎉觉得博主写的还不错的可以`一键三连撒🎉🎉<img alt=\"请添加图片描述\" src=\"image\\3b858cc29a65401fa46f94ef04fdc55f.jpeg\"/></li></ul>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}