{"blogid": "126714282", "writerAge": "码龄1年", "writerBlogNum": "54", "writerCollect": "84", "writerComment": "101", "writerFan": "796", "writerGrade": "4级", "writerIntegral": "940", "writerName": "如何写出最优雅的代码", "writerProfileAdress": "writer_image\\profile_126714282.jpg", "writerRankTotal": "21340", "writerRankWeekly": "7016", "writerThumb": "191", "writerVisitNum": "23977", "blog_read_count": "92", "blog_time": "已于 2022-09-06 09:10:45 修改", "blog_title": "【Java从入门到放弃01】：类变量、类方法（static在类中的用法）及main函数细节", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h2 id=\"%E5%89%8D%E8%A8%80\">前言</h2>\n<blockquote>\n<p>经过一个多月的学习，终于进入了学习Java的第二阶段😁，本篇博客主要介绍Java面向对象高级部分中<strong>类变量、类方法</strong>的使用，以及<strong>main函数语法</strong>剖析，主要设计<strong>static关键字</strong>在类中的使用。</p>\n<p>🎓作者：如何写出最优雅的代码<br/> 📑如有错误，敬请指正🌹🌹</p>\n<p>💬开发工具：IDEA<br/> ————————————————</p>\n<p>很有意思的一句话，<strong>一个数如果没有前面的1，后面跟再多的0也是没有意义，我们应该继续努力，把1的位置往前挪</strong>！😮😮</p>\n</blockquote>\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E5%89%8D%E8%A8%80-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%89%8D%E8%A8%80\">前言</a></p>\n<p id=\"%E7%B1%BB%E5%8F%98%E9%87%8F-toc\" style=\"margin-left:40px;\"><a href=\"#%E7%B1%BB%E5%8F%98%E9%87%8F\">类变量</a></p>\n<p id=\"%E7%B1%BB%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89-toc\" style=\"margin-left:80px;\"><a href=\"#%E7%B1%BB%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89\">类变量的定义</a></p>\n<p id=\"%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%8F%98%E9%87%8F-toc\" style=\"margin-left:80px;\"><a href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%8F%98%E9%87%8F\">什么是类变量</a></p>\n<p id=\"%E5%A6%82%E4%BD%95%E8%AE%BF%E9%97%AE%E7%B1%BB%E5%8F%98%E9%87%8F-toc\" style=\"margin-left:80px;\"><a href=\"#%E5%A6%82%E4%BD%95%E8%AE%BF%E9%97%AE%E7%B1%BB%E5%8F%98%E9%87%8F\">如何访问类变量</a></p>\n<p id=\"%E7%B1%BB%E5%8F%98%E9%87%8F%E7%9A%84%E7%BB%86%E8%8A%82%E6%80%BB%E7%BB%93-toc\" style=\"margin-left:80px;\"><a href=\"#%E7%B1%BB%E5%8F%98%E9%87%8F%E7%9A%84%E7%BB%86%E8%8A%82%E6%80%BB%E7%BB%93\">类变量的细节总结</a></p>\n<p id=\"%E7%B1%BB%E6%96%B9%E6%B3%95-toc\" style=\"margin-left:40px;\"><a href=\"#%E7%B1%BB%E6%96%B9%E6%B3%95\">类方法</a></p>\n<p id=\"%E7%B1%BB%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89-toc\" style=\"margin-left:80px;\"><a href=\"#%E7%B1%BB%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89\">类方法的定义</a></p>\n<p id=\"%E7%B1%BB%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8-toc\" style=\"margin-left:80px;\"><a href=\"#%E7%B1%BB%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8\">类方法的调用</a></p>\n<p id=\"%E5%B8%B8%E8%A7%81%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-toc\" style=\"margin-left:80px;\"><a href=\"#%E5%B8%B8%E8%A7%81%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\">常见使用场景</a></p>\n<p id=\"%E7%B1%BB%E6%96%B9%E6%B3%95%E7%9A%84%E7%BB%86%E8%8A%82%E6%80%BB%E7%BB%93-toc\" style=\"margin-left:80px;\"><a href=\"#%E7%B1%BB%E6%96%B9%E6%B3%95%E7%9A%84%E7%BB%86%E8%8A%82%E6%80%BB%E7%BB%93\">类方法的细节总结</a></p>\n<p id=\"main%E6%96%B9%E6%B3%95%E8%AF%AD%E6%B3%95-toc\" style=\"margin-left:40px;\"><a href=\"#main%E6%96%B9%E6%B3%95%E8%AF%AD%E6%B3%95\">main方法语法</a></p>\n<p id=\"%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3main%E6%96%B9%E6%B3%95-toc\" style=\"margin-left:80px;\"><a href=\"#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3main%E6%96%B9%E6%B3%95\">深入理解main方法</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h2 id=\"%E7%B1%BB%E5%8F%98%E9%87%8F\">类变量</h2>\n<h3 id=\"%E7%B1%BB%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89\">类变量的定义</h3>\n<pre><code class=\"language-java\">访问修饰符 static 数据类型 变量名;//推荐使用\nstatic 访问修饰符 数据类型 变量名;//也可以</code></pre>\n<p> 在定义时也可以赋予初始值！</p>\n<h3 id=\"%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%8F%98%E9%87%8F\">什么是类变量</h3>\n<p>用static关键字修饰的成员变量即类变量，也叫<strong>静态变量/静态属性，是该类的所有对象共享的变量</strong>，任何一个该类的对象去访问它时，取到的都是相同的值，同样任何一个该类的对象去修改它的值，修改的也是同一个变量。而<strong>static变量在类加载时就生成了</strong>，下面以ChildGame类来演示类变量的使用并分析类变量在内存中的布局：</p>\n<pre><code class=\"language-java\">package com.lww.study_static_;\n\npublic class ChildGame {\n\n    public static void main(String[] args) {\n\n        //定义一个变量count，统计有多少个小孩加入了游戏\n        //int count = 0;\n\n        //注释快捷键，多行注释（每行都要） ctrl + /\n        //注释快捷键，多行注释（首尾行） ctrl + shift + /\n\n        Child child1 = new Child(\"白骨精\");\n        child1.join();\n        //count++;\n        child1.count++;\n\n        Child child2 = new Child(\"狐狸精\");\n        child2.join();\n        //count++;\n        child2.count++;\n\n        Child child3 = new Child(\"老鼠精\");\n        child3.join();\n        //count++;\n        child3.count++;\n\n        //游戏结束\n        //System.out.println(\"共有\" + count + \"小孩加入了游戏\");\n        //类变量可以通过类名访问\n        System.out.println(\"共有\" + Child.count + \"小孩加入了游戏\");\n        //下面的代码输出结果相同\n        System.out.println(\"child1.count = \" + child1.count);\n        System.out.println(\"child2.count = \" + child2.count);\n        System.out.println(\"child3.count = \" + child3.count);\n    }\n}\n\nclass Child{\n    private String name;\n\n    //定义一个类变量 count，是一个static 静态变量\n    //该变量最大的特点就是会被Child类的所有的对象实例共享\n    public static int count = 0;\n\n    public Child(String name){\n        this.name = name;\n    }\n\n    public void join(){\n        System.out.println(name + \"加入了游戏..\");\n    }\n</code></pre>\n<p>经过上面的代码测试，我们发现同一个类定义的不同对象，所访问到的static修饰的成员变量均是同一个，下面给出它在内存中的布局：</p>\n<p><img alt=\"\" height=\"708\" src=\"image\\4b4ebd605e2540489df7389ac7183b10.png\" width=\"966\"/></p>\n<p>有些书上说static修饰的count变量是在方法区中的静态域，而这里提供的是存在于堆区上，这里不做过多分析，感兴趣的可以自己找找网上的文章。不管是哪一种布局，这里主要想说明的点是，<strong>类变量在类加载时就产生了，该类的每一个实例对象都使用的是同一个类变量！</strong></p>\n<h3 id=\"%E5%A6%82%E4%BD%95%E8%AE%BF%E9%97%AE%E7%B1%BB%E5%8F%98%E9%87%8F\">如何访问类变量</h3>\n<pre><code class=\"language-java\">类名.类变量名//推荐使用！\n对象名.类变量名</code></pre>\n<p>静态变量的访问修饰符的访问权限范围和普通成员变量是一样（遵循的访问规则一样）！</p>\n<h3 id=\"%E7%B1%BB%E5%8F%98%E9%87%8F%E7%9A%84%E7%BB%86%E8%8A%82%E6%80%BB%E7%BB%93\">类变量的细节总结</h3>\n<blockquote>\n<ol><li>什么时候需要使用类变量：当我们需要让某个类的所有对象都共享一个变量时，就可以考虑使用类变量（静态变量）</li><li>类变量与实例变量（普通属性）的区别：<strong>类变量是该类的所有对象共享的，而实例变量是每个对象独享的</strong></li><li><strong>加上static称为类变量或静态变量，否则称为实例变量/普通变量/非静态变量</strong></li><li>类变量可以通过 类名.类变量名 或者 对象名.类变量名 来访问，但Java设计者推荐我们使用 类名.类变量名 方式去访问。访问规则遵循修饰符的访问权限和范围</li><li><strong>实例变量不能通过 类名.普通成员变量名 访问</strong>，因为还未创建对象实例，内存中没有该普通成员变量</li><li><strong>类变量是在类加载时就初始化了，也就是说，即使没有创建对象，只要类加载了，就可以使用类变量了</strong>，这也就是为什么能够通过 类名.类变量名 方式去访问</li><li>类变量的生命周期是随类的加载开始，随着类的消亡而销毁</li></ol>\n</blockquote>\n<hr/>\n<h2 id=\"%E7%B1%BB%E6%96%B9%E6%B3%95\">类方法</h2>\n<h3 id=\"%E7%B1%BB%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89\">类方法的定义</h3>\n<p>类方法也称为静态方法，定义形式如下：</p>\n<pre><code class=\"language-java\">访问修饰符 static 数据返回类型 方法名() {……}//推荐使用\nstatic 访问修饰符 数据返回类型 方法名() {……}//也可</code></pre>\n<p>经过上面类变量的介绍，这里的类方法理解起来会相对容易。</p>\n<h3 id=\"%E7%B1%BB%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8\">类方法的调用</h3>\n<pre><code class=\"language-java\">类名.类方法名//推荐使用\n对象名.类方法名</code></pre>\n<p>调用/访问规则同样遵循访问修饰符的访问权限和范围！下面是一段测试代码，供学习和思考：</p>\n<pre><code class=\"language-java\">package com.lww.study_static_;\n\npublic class StaticMethodDetail {\n    public static void main(String[] args) {\n\n        D.hi();\n        //非静态方法，不能通过类名调用\n        //D.say();//error，需要先创建对象，再通过对象调用\n        new D().say();\n        new D().ok();\n    }\n}\n\nclass D {\n    private int n1 = 100;\n    private static  int n2 = 200;\n\n    public void say() {\n        //非静态方法\n\n    }\n\n    public static void hi() {\n        //静态方法\n        //类方法中不允许使用和对象有关的关键字，\n        // 比如this和super，普通方法（成员方法）可以调用\n        //System.out.println(this.n1);//error\n    }\n\n    //类方法（静态方法）中，只能访问静态变量 或者 静态方法\n    //即静态方法中只能访问静态成员\n    public static void hello() {\n        System.out.println(n2);\n        System.out.println(D.n2);\n        //System.out.println(this.n2);//error\n        hi();\n        //say();//error\n    }\n\n    //普通成员方法，既可以访问非静态成员，也可以访问静态成员\n    public void ok() {\n        //非静态成员\n        System.out.println(n1++);\n        System.out.println(this.n1);\n        say();\n        //静态成员\n        System.out.println(n2);\n        hello();\n    }\n}</code></pre>\n<h3 id=\"%E5%B8%B8%E8%A7%81%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\">常见使用场景</h3>\n<ol><li>当方法中不涉及到任何和对象相关的成员时，可以将方法设计成静态方法，提高开发效率，比如util中的Math类、Array类中的方法很多都是设计为静态方法，他们都是可以直接通过 类名.类方法名 调用，避免创建对象的消耗</li><li>在程序员实际开发过程中，往往会将一些通用的方法，设计成静态方法，这样我们不需要创建对象就可以使用了，比如打印一堆数组，冒泡排序，完成某个计算任务等</li></ol>\n<h3 id=\"%E7%B1%BB%E6%96%B9%E6%B3%95%E7%9A%84%E7%BB%86%E8%8A%82%E6%80%BB%E7%BB%93\">类方法的细节总结</h3>\n<blockquote>\n<ol><li>类方法和普通方法都是随着类的加载而加载，将结构信息存储在方法区</li><li><strong>类方法中无this的参数，普通方法中隐含着this的参数</strong></li><li>类方法可以通过类名调用，也可以通过对象名调用</li><li>普通方法和对象有关，需要通过对象名调用，不能通过类名调用</li><li><strong>类方法中不允许使用和对象有关的关键字，比如this和super</strong>。普通方法可以</li><li><strong>类方法（静态方法）中只能访问静态成员，即只能 静态变量 或者 静态方法</strong></li><li><strong>普通成员方法，既可以访问 非静态成员，也可以访问 静态成员</strong></li></ol>\n</blockquote>\n<hr/>\n<h2 id=\"main%E6%96%B9%E6%B3%95%E8%AF%AD%E6%B3%95\">main方法语法</h2>\n<h3 id=\"%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3main%E6%96%B9%E6%B3%95\">深入理解main方法</h3>\n<blockquote>\n<p>main方法的形式：</p>\n<pre><code class=\"language-java\">public static void main(String[] args) {……}</code></pre>\n<ol><li>main方法是由虚拟机调用的</li><li>Java虚拟机需要调用main()方法，所以该方法的访问权限必须是public</li><li>Java虚拟机在执行main()方法时不必创建对象，所以该方法必须是static修饰的</li><li>该方法接收String类型的数组参数，该数组中保存执行java命令时传递给所运行的类的参数</li><li>java 执行的程序 参数1 参数2 参数3……参数由args数组接收</li></ol>\n</blockquote>\n<p>main()方法属于静态方法，所以在main()方法中，可以直接调用main所在类的静态方法或者静态属性，但是不能访问该类中的非静态成员，必须创建该类的实例对象后，才可以通过对象去访问，下面是一段测试代码： </p>\n<pre><code class=\"language-java\">import sun.applet.Main;\n\npublic class Main01 {\n\n    //静态的变量/属性\n    private static String name = \"憨憨\";\n    //非静态的变量/属性\n    private int n1 = 10000;\n\n    //静态方法\n    public static void hi() {\n        System.out.println(\"Main01的 hi方法\");\n    }\n    //非静态方法\n    public void cry() {\n        System.out.println(\"Main01的 cry方法\");\n    }\n\n    public static void main(String[] args) {\n\n        //可以直接使用name，\n        //1. 静态方法main 可以访问本类的静态成员\n        System.out.println(\"name = \" + name);\n        hi();\n        //2. 静态方法main 不可以访问本类的非静态成员\n        //System.out.println(n1);//error\n        //cry();//error\n        //3. 静态方法main 要访问本类的非静态成员，必须要先创建对象，再调用即可\n        Main01 main01 = new Main01();\n        System.out.println(main01.n1);\n        main01.cry();\n    }\n\n}</code></pre>\n<p>关于args数组，这里也可以通过下面的操作进行演示，在IDEA中执行下面代码：</p>\n<pre><code class=\"language-java\">package com.lww.study_main_;\n\npublic class Main02 {\n    public static void main(String[] args) {\n        for (int i = 0; i &lt; args.length; i++) {\n            System.out.println(\"args[\" + i + \"] = \" + args[i]);\n        }\n    }\n}</code></pre>\n<p>我们会发现没有任何输出结果，那是因为我们还没有给执行过程传递参数，通过下面步骤设置执行该代码时要传递的参数</p>\n<p><img alt=\"\" height=\"1200\" src=\"image\\8e14d4c50aba430f981b2e0e453a0389.png\" width=\"1200\"/></p>\n<p>如果没有显示有Main02，可以先运行一遍再设置，点击进去后出现以下界面</p>\n<p><img alt=\"\" height=\"1023\" src=\"image\\0794b93e99404f339b89b9d492a40042.png\" width=\"1200\"/></p>\n<p>在Program arguments栏输入要传递的运行参数，比如我这里输入的是北京 上海 西安，最后Apply后OK退出该界面，重新运行代码，会发现输出以下结果</p>\n<p><img alt=\"\" height=\"1200\" src=\"image\\5d2cc0e11acd48b4afe9818e8e62c830.png\" width=\"1200\"/></p>\n<p>当然这部分内容了解一下即可，实际开发过程中不需要我们去传递参数，但为了应付面试，我们还是要了解一下有这么个内容即可！</p>\n<hr/>\n<p>本篇博客到这就结束了，下面推荐一些往期的高质量文章：</p>\n<p><a class=\"link-info\" href=\"https://blog.csdn.net/m0_62080641/article/details/126166276?spm=1001.2014.3001.5501\" title=\"【Java从入门到精通 08】：面向对象编程（进阶部分）\">【Java从入门到精通 08】：面向对象编程（进阶部分）</a></p>\n<p><a class=\"link-info\" href=\"https://blog.csdn.net/m0_62080641/article/details/126110400?spm=1001.2014.3001.5501\" title=\"【Java从入门到精通 07】：面向对象编程（基础部分）\">【Java从入门到精通 07】：面向对象编程（基础部分）</a></p>\n<p><a class=\"link-info\" href=\"https://blog.csdn.net/m0_62080641/article/details/125740648?spm=1001.2014.3001.5501\" title=\"Linux环境搭建（使用云服务器方式）\">Linux环境搭建（使用云服务器方式）</a></p>\n<p><a class=\"link-info\" href=\"https://blog.csdn.net/m0_62080641/article/details/121866193?spm=1001.2014.3001.5502\" title=\"【自我介绍】小白程序员的成神之路\">【自我介绍】小白程序员的成神之路</a></p>\n<blockquote>\n<p id=\"%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A\">学习记录：</p>\n<ul><li>📆本篇博客整理于2022.9.5~2022.9.6</li><li>🎓作者：<strong>如何写出最优雅的代码</strong></li><li>📑如有错误，敬请指正🌹🌹</li><li>🥂关注一波不迷路！如果觉得写的不错，看完了别忘了点赞和收藏啊，感谢支持😏😏</li></ul>\n</blockquote>\n</div>\n</div>"}