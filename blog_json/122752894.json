{"blogid": "122752894", "writerAge": "码龄2年", "writerBlogNum": "71", "writerCollect": "3182", "writerComment": "2278", "writerFan": "18797", "writerGrade": "6级", "writerIntegral": "7435", "writerName": "小码农UU", "writerProfileAdress": "writer_image\\profile_122752894.jpg", "writerRankTotal": "56126", "writerRankWeekly": "5659", "writerThumb": "3710", "writerVisitNum": "118176", "blog_read_count": "1380", "blog_time": "已于 2022-02-02 18:44:01 修改", "blog_title": "c++虫洞 STL string", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-light\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p><img alt=\"在这里插入图片描述\" src=\"https://img-blog.csdnimg.cn/b5c88a1b82974504858f886e1db760b6.gif#pic_center\"/></p>\n<p></p>\n<div class=\"toc\">\n<h3>文章目录</h3>\n<ul><li><a href=\"#font_color996633_STLfont_7\"><font color=\"#996633\">STL</font></a></li><li><ul><li><a href=\"#font_color9400D3_STLfont_9\"><font color=\"#9400D3\">什么是STL</font></a></li><li><a href=\"#font_color9400D3_STLfont_13\"><font color=\"#9400D3\">STL版本</font></a></li><li><ul><li><a href=\"#font_colorFF0033_font_15\"><font color=\"#FF0033\">原始版本</font></a></li><li><a href=\"#font_colorFF0033_P_J_font_19\"><font color=\"#FF0033\">P. J. 版本</font></a></li><li><a href=\"#font_colorFF0033_RWfont_23\"><font color=\"#FF0033\">RW版本</font></a></li><li><a href=\"#font_colorFF0033_SGIfont_27\"><font color=\"#FF0033\">SGI版本</font></a></li></ul>\n</li><li><a href=\"#font_color9400D3_STLfont_31\"><font color=\"#9400D3\">STL的六大组件</font></a></li><li><a href=\"#font_color9400D3_STLfont_35\"><font color=\"#9400D3\">如何学习STL</font></a></li><li><a href=\"#font_color9400D3_STLfont_49\"><font color=\"#9400D3\">STL的缺陷</font></a></li></ul>\n</li><li><a href=\"#font_color996633_stringfont_58\"><font color=\"#996633\">接下来我们要学的第一个容器就是string</font></a></li><li><ul><li><a href=\"#font_color9400D3_stringfont_60\"><font color=\"#9400D3\">为什么学习string类？</font></a></li><li><ul><li><a href=\"#font_colorFF0033_Cfont_62\"><font color=\"#FF0033\">C语言中的字符串</font></a></li></ul>\n</li><li><a href=\"#font_color9400D3_stringfont_66\"><font color=\"#9400D3\">标准库中的string类</font></a></li><li><ul><li><a href=\"#font_colorFF0033_stringfont_68\"><font color=\"#FF0033\">string类(了解)</font></a></li><li><a href=\"#font_colorFF0033_stringfont_87\"><font color=\"#FF0033\">string类的常用接口说明（注意下面我只讲解最常用的接口）</font></a></li><li><ul><li><a href=\"#font_color0000CC_1stringfont_89\"><font color=\"#0000CC\">1.string类对象的常见构造</font></a></li><li><a href=\"#font_color0000CC_2stringfont_135\"><font color=\"#0000CC\">2.string类对象的容量操作</font></a></li><li><a href=\"#font_color0000CC_3stringfont_230\"><font color=\"#0000CC\">3.string类对象的访问及遍历操作</font></a></li><li><a href=\"#font_color0000CC_4stringfont_287\"><font color=\"#0000CC\">4.string类对象的修改操作</font></a></li><li><a href=\"#font_color0000CC_5stringfont_428\"><font color=\"#0000CC\">5.string类非成员函数</font></a></li></ul>\n</li><li><a href=\"#font_colorFF0033_font_440\"><font color=\"#FF0033\">几题小菜</font></a></li><li><ul><li><a href=\"#font_color0000CC_httpsleetcodecncomproblemsfirstuniquecharacterinastringfont_442\"><font color=\"#0000CC\">[找字符串中第一个只出现一次的字符](https://leetcode-cn.com/problems/first-unique-character-in-a-string/)</font></a></li><li><ul><li><a href=\"#font_colorFF00FF_font_448\"><font color=\"#FF00FF\">下标+[]</font></a></li><li><a href=\"#font_colorFF00FF_font_475\"><font color=\"#FF00FF\">迭代器</font></a></li><li><a href=\"#font_colorFF00FF_forfont_503\"><font color=\"#FF00FF\">范围for</font></a></li></ul>\n</li><li><a href=\"#httpsleetcodecncomproblemsreverseonlyletters_529\">仅仅反转字母</a></li><li><a href=\"#font_color0000CC_httpswwwnowcodercompractice8c949ea5f36f422594b306a2300315datpId37tqId21224rp5ruactivityojqrutahuaweiquestionrankingfont_567\"><font color=\"#0000CC\">[**字符串最后一个单词的长度**](https://www.nowcoder.com/practice/8c949ea5f36f422594b306a2300315da?tpId=37&amp;&amp;tqId=21224&amp;rp=5&amp;ru=/activity/oj&amp;qru=/ta/huawei/question-ranking)</font></a></li><li><a href=\"#httpsleetcodecncomproblemsvalidpalindrome_599\">验证回文串</a></li><li><a href=\"#httpsleetcodecncomproblemsaddstrings_677\">字符串相加</a></li></ul>\n</li></ul>\n</li></ul>\n</li></ul>\n</div>\n<br/>\n<img alt=\"在这里插入图片描述\" src=\"https://img-blog.csdnimg.cn/b4f5602989e64831a6f44d397527fcaf.gif#pic_center\"/>\n<p></p>\n<h1><a id=\"font_color996633_STLfont_7\"></a><font color=\"#996633\">STL</font></h1>\n<h2><a id=\"font_color9400D3_STLfont_9\"></a><font color=\"#9400D3\">什么是STL</font></h2>\n<blockquote>\n<p>STL(standard template libaray-标准模板库)：<mark>是C++标准库的重要组成部分</mark>，不仅是一个可复用的组件库，而且<mark>是一个包罗数据结构与算法的软件框架</mark></p>\n</blockquote>\n<h2><a id=\"font_color9400D3_STLfont_13\"></a><font color=\"#9400D3\">STL版本</font></h2>\n<h3><a id=\"font_colorFF0033_font_15\"></a><font color=\"#FF0033\">原始版本</font></h3>\n<blockquote>\n<p>Alexander Stepanov、Meng Lee 在惠普实验室完成的原始版本，本着开源精神，他们声明允许任何人任意运用、拷贝、修改、传播、商业使用这些代码，无需付费。唯一的条件就是也需要向原始版本一样做开源使用。 HP 版本–所有STL实现版本的始祖</p>\n</blockquote>\n<h3><a id=\"font_colorFF0033_P_J_font_19\"></a><font color=\"#FF0033\">P. J. 版本</font></h3>\n<blockquote>\n<p>由P. J. Plauger开发，继承自HP版本，被Windows Visual C++采用，不能公开或修改，缺陷：可读性比较低，符号命名比较怪异</p>\n</blockquote>\n<h3><a id=\"font_colorFF0033_RWfont_23\"></a><font color=\"#FF0033\">RW版本</font></h3>\n<blockquote>\n<p>由Rouge Wage公司开发，继承自HP版本，被C+ + Builder 采用，不能公开或修改，可读性一般。</p>\n</blockquote>\n<h3><a id=\"font_colorFF0033_SGIfont_27\"></a><font color=\"#FF0033\">SGI版本</font></h3>\n<blockquote>\n<p>由Silicon Graphics Computer Systems，Inc公司开发，继承自HP版 本。被GCC(Linux)采用，可移植性好，可公开、修改甚至贩卖，从命名风格和编程 风格上看，阅读性非常高。<mark>我们后面学习STL要阅读部分源代码，主要参考的就是这个版本。</mark></p>\n</blockquote>\n<h2><a id=\"font_color9400D3_STLfont_31\"></a><font color=\"#9400D3\">STL的六大组件</font></h2>\n<blockquote>\n<p><img alt=\"image-20220127112155030\" src=\"image\\8e40b0e72f12e8b76ef2a1b3fd16c051.png\"/></p>\n</blockquote>\n<h2><a id=\"font_color9400D3_STLfont_35\"></a><font color=\"#9400D3\">如何学习STL</font></h2>\n<blockquote>\n<p><img alt=\"image-20220127112859314\" src=\"image\\008362516133a92a1b703b7713e6ba7d.png\"/></p>\n<p><strong>简单总结一下：</strong></p>\n<p><mark>学习STL的三个境界：</mark></p>\n<ol><li>能用，</li><li>明理，</li><li>能扩展 。</li></ol>\n<p><mark>进公司前要把前两层修炼熟悉,第三层是在公司中修炼的</mark></p>\n</blockquote>\n<h2><a id=\"font_color9400D3_STLfont_49\"></a><font color=\"#9400D3\">STL的缺陷</font></h2>\n<blockquote>\n<ol><li>STL库的更新太慢了。这个得严重吐槽，上一版靠谱是C++98，中间的C++03基本一些修订。C++11出<br/> 来已经相隔了13年，STL才进一步更新。</li><li>STL现在都没有支持线程安全。并发环境下需要我们自己加锁。且锁的粒度是比较大的。</li><li>STL极度的追求效率，导致内部比较复杂。比如类型萃取，迭代器萃取。</li><li>STL的使用会有代码膨胀的问题，比如使用vector/vector/vector这样会生成多份代码，当然这是模板语<br/> 法本身导致的。</li></ol>\n</blockquote>\n<h1><a id=\"font_color996633_stringfont_58\"></a><font color=\"#996633\">接下来我们要学的第一个容器就是string</font></h1>\n<h2><a id=\"font_color9400D3_stringfont_60\"></a><font color=\"#9400D3\">为什么学习string类？</font></h2>\n<h3><a id=\"font_colorFF0033_Cfont_62\"></a><font color=\"#FF0033\">C语言中的字符串</font></h3>\n<blockquote>\n<p>C语言中，字符串是以’\\0’结尾的一些字符的集合，为了操作方便，C标准库中提供了一些str系列的库函数，但是这些库函数与字符串是分离开的，不太符合OOP的思想，而且底层空间需要用户自己管理，稍不留神可能还会越界访问</p>\n</blockquote>\n<h2><a id=\"font_color9400D3_stringfont_66\"></a><font color=\"#9400D3\">标准库中的string类</font></h2>\n<h3><a id=\"font_colorFF0033_stringfont_68\"></a><font color=\"#FF0033\">string类(了解)</font></h3>\n<blockquote>\n<p><a href=\"http://www.cplusplus.com/reference/string/string/?kw=string\">string类的文档介绍</a></p>\n<ol><li>字符串是表示字符序列的类</li><li>标准的字符串类提供了对此类对象的支持，其接口类似于标准字符容器的接口，但添加了专门用于操作单字节字符字符串的设计特性。</li><li>string类是使用char(即作为它的字符类型，使用它的默认char_traits和分配器类型(关于模板的更多信息，请参阅basic_string)。</li><li>string类是basic_string模板类的一个实例，它使用char来实例化basic_string模板类，并用char_traits和allocator作为basic_string的默认参数(根于更多的模板信息请参考basic_string)。</li><li>注意，这个类独立于所使用的编码来处理字节:如果用来处理多字节或变长字符(如UTF-8)的序列，这个类的所有成员(如长度或大小)以及它的迭代器，将仍然按照字节(而不是实际编码的字符)来操作。</li></ol>\n<p><mark>总结：</mark></p>\n<ol><li>string是表示字符串的字符串类</li><li>该类的接口与常规容器的接口基本相同，再添加了一些专门用来操作string的常规操作。</li><li>string在底层实际是：basic_string模板类的别名，typedef basic_string&lt;char, char_traits, allocator&gt;string;</li><li>不能操作多字节或者变长字符的序列。</li></ol>\n<p><strong>在使用string类时，必须包含#include头文件以及using namespace std;</strong></p>\n</blockquote>\n<h3><a id=\"font_colorFF0033_stringfont_87\"></a><font color=\"#FF0033\">string类的常用接口说明（注意下面我只讲解最常用的接口）</font></h3>\n<h4><a id=\"font_color0000CC_1stringfont_89\"></a><font color=\"#0000CC\">1.string类对象的常见构造</font></h4>\n<blockquote>\n<table><thead><tr><th align=\"center\">(<a href=\"http://www.cplusplus.com/reference/string/string/string/\">constructor</a>)函数名称</th><th>功能说明</th></tr></thead><tbody><tr><td align=\"center\">string() （重点）</td><td>构造空的string类对象，即空字符串</td></tr><tr><td align=\"center\">string(const char* s) （重点）</td><td>用C-string来构造string类对象</td></tr><tr><td align=\"center\">string(size_t n, char c)</td><td>string类对象中包含n个字符c</td></tr><tr><td align=\"center\">string(const string&amp;s) （重点）</td><td>拷贝构造函数</td></tr></tbody></table>\n<p><img alt=\"image-20220128152201077\" src=\"image\\a19e568e5d03edf00490e074c8895ac2.png\"/></p>\n<p><mark>学STL，重点讲最常用30%左右的接口函数，其他很少用，如果有一天我们需要用，就去看文档</mark></p>\n<p><img alt=\"image-20220128160854899\" src=\"image\\3c96f528c7d64ccad81e0d57c514da1a.png\"/></p>\n<p><img alt=\"image-20220128161158196\" src=\"image\\20c31e2ac64211d8d4f1d99c5bc98304.png\"/></p>\n<pre><code class=\"prism language-c++\">int main()\n{\n\tstring s1;              //无参构造\n\tstring s2(\"Hello c++\"); //带参数构造\n\tstring s3 = \"Hello c++\";//编译器优化的直接构造\n\tstring s4(s2);          //拷贝构造\n\n\tstring s5(s4, 2, string::npos);    //部分构造\n\tstring s6(\"123456789\", 5);         //构造前n个字符\n\t//这个作用就是假如以后要写网络的代码，截取前几个字符会用到\n\tconst char* url = \"http://www.cplusplus.com/reference/string/string/string/\";\n\tstring s7(url, 5);\n\tstring s8(10, 'x');     //构造n个一样的字符\n\n\n\tcout &lt;&lt; s1 &lt;&lt; endl;\n\tcout &lt;&lt; s2 &lt;&lt; endl;\n\tcout &lt;&lt; s3 &lt;&lt; endl;\n\tcout &lt;&lt; s4 &lt;&lt; endl;\n\tcout &lt;&lt; s5 &lt;&lt; endl;\n\tcout &lt;&lt; s6 &lt;&lt; endl;\n\tcout &lt;&lt; s7 &lt;&lt; endl;\n\tcout &lt;&lt; s8 &lt;&lt; endl;\n\n\treturn 0;\n}\n</code></pre>\n</blockquote>\n<h4><a id=\"font_color0000CC_2stringfont_135\"></a><font color=\"#0000CC\">2.string类对象的容量操作</font></h4>\n<blockquote>\n<table><thead><tr><th>函数名称</th><th>功能说明</th></tr></thead><tbody><tr><td><a href=\"http://www.cplusplus.com/reference/string/string/size/\">size</a>（重点）</td><td>返回字符串有效字符长度</td></tr><tr><td><a href=\"http://www.cplusplus.com/reference/string/string/length/\">length</a></td><td>返回字符串有效字符长度</td></tr><tr><td><a href=\"http://www.cplusplus.com/reference/string/string/capacity/\">capacity</a></td><td>返回空间总大小</td></tr><tr><td><a href=\"http://www.cplusplus.com/reference/string/string/empty/\">empty</a> （重点）</td><td>检测字符串释放为空串，是返回true，否则返回false</td></tr><tr><td><a href=\"http://www.cplusplus.com/reference/string/string/clear/\">clear</a> （重点）</td><td>清空有效字符</td></tr><tr><td><a href=\"http://www.cplusplus.com/reference/string/string/reserve/\">reserve</a> （重点）</td><td>为字符串预留空间</td></tr><tr><td><a href=\"http://www.cplusplus.com/reference/string/string/resize/\">resize</a> （重点）</td><td>将有效字符的个数该成n个，多出的空间用字符c填充</td></tr></tbody></table>\n<p><mark>实际上length在string中就是数组长度，和size一样，那为什么要两个一样的呢，是因为历史上string出来的要比stl早，string在官网文档也没有归类到容器里面（但他就是容器），而是放在了头文件里面，size是普法，length是只用与string的</mark></p>\n<p><strong>注意：</strong></p>\n<ol><li>size()与length()方法底层实现原理完全相同，引入size()的原因是为了与其他容器的接口保持一致，一般情况下基本都是用size()。</li><li>clear()只是将string中有效字符清空，不改变底层空间大小。</li><li>resize(size_t n) 与 resize(size_t n, char c)都是将字符串中有效字符个数改变到n个，不同的是当字符个数增多时：resize(n)用0来填充多出的元素空间，resize(size_t n, char c)用字符c来填充多出的元素空间。注意：resize在改变元素个数时，如果是将元素个数增多，可能会改变底层容量的大小，如果是将元素个数减少，底层空间总大小不变。</li><li>reserve(size_t res_arg=0)：为string预留空间，不改变有效元素个数，当reserve的参数小于string的底层空间总大小时，reserver不会改变容量大小。</li></ol>\n<p><img alt=\"image-20220128164211665\" src=\"image\\af31ff8ad311997f27e516a7c621a240.png\"/></p>\n<p><mark>这里提一嘴 at 的作用和 [] 是一样的，可以认为是早期语法可能不太支持 [] 所以才有at这个接口代替，后面支持了，at就基本不用了，他们也不是完全一样，他们越界就不一样</mark></p>\n<p><img alt=\"image-20220128175822354\" src=\"image\\b3232030604a6c574e24326e98808c32.png\"/></p>\n<p><img alt=\"image-20220129123039488\" src=\"image\\31fb1804631f94dc6518e99202a4a137.png\"/></p>\n<p><mark>reserve给足空间就可以防止多次增容，那么resize可以吗</mark></p>\n<p><img alt=\"image-20220129153150305\" src=\"image\\82541a31fa4ae33e39ad39c3d3c0b7dc.png\"/></p>\n<p><mark>我们也可以看看相同的代码在不同平台跑出来的结果</mark></p>\n<p><img alt=\"image-20220129154447987\" src=\"image\\263ccc7f77c58ea506f2a7bdcaf14948.png\"/></p>\n<p><img alt=\"image-20220129163550632\" src=\"image\\280edb1d7b67a6a341ddd57cc09cf2cf.png\"/></p>\n<pre><code class=\"prism language-c++\">int main()\n{\n\tstring s1 = \"Hello world\";\n\tstring s2 =\"world\";\n\t//判断字符串是否为空\n\tcout &lt;&lt;\"s1.empty \"&lt;&lt; s1.empty() &lt;&lt; endl;\n\tcout &lt;&lt; \"s2.empty \" &lt;&lt; s2.empty() &lt;&lt; endl;\n\t//大小\n\tcout &lt;&lt; \"s1.size \" &lt;&lt; s1.size() &lt;&lt; endl;\n\tcout &lt;&lt; \"s2.size \" &lt;&lt; s2.size() &lt;&lt; endl;\n\t//容量\n\tcout &lt;&lt;\"s1.capacity \"&lt;&lt; s1.capacity() &lt;&lt; endl;\n\tcout &lt;&lt;\"s2.capacity \"&lt;&lt; s2.capacity() &lt;&lt; endl &lt;&lt; endl;\n\t//清掉所有的数据，就是size变成零,但是空间不释放\n\ts1.clear();\n\tcout &lt;&lt; \"s1.size \" &lt;&lt; s1.size() &lt;&lt; endl;\n\tcout &lt;&lt; \"s1.capacity \" &lt;&lt; s1.capacity() &lt;&lt; endl &lt;&lt; endl;\n\t//在对象中插入n个字符，默认字符是‘\\0’\n\t//想要放其他字符就\n\ts1.resize(15);\n\tstring s3 = s2;\n\ts2.resize(1,'x');\n\ts3.resize(16,'x');\n\tcout &lt;&lt;\"s2:    \"&lt;&lt; s2 &lt;&lt; endl;\n\tcout &lt;&lt;\"s3:    \"&lt;&lt; s3 &lt;&lt; endl;\n\tcout &lt;&lt; \"s1.size \" &lt;&lt; s1.size() &lt;&lt; endl;\n\tcout &lt;&lt; \"s2.size \" &lt;&lt; s2.size() &lt;&lt; endl;\n\tcout &lt;&lt; \"s1.capacity \" &lt;&lt; s1.capacity() &lt;&lt; endl;\n\tcout &lt;&lt; \"s2.capacity \" &lt;&lt; s2.capacity() &lt;&lt; endl &lt;&lt; endl;\n\t//请求一个容量的改变  \n\ts2.reserve(40);\n\tcout &lt;&lt; \"s2:    \" &lt;&lt; s2 &lt;&lt; endl;\n\tcout &lt;&lt; \"s2.size \" &lt;&lt; s2.size() &lt;&lt; endl;\n\tcout &lt;&lt; \"s2.capacity \" &lt;&lt; s2.capacity() &lt;&lt; endl &lt;&lt; endl;\n\tstring s4;\n\t直接给足空间防止多次增容\t\n\t//s4.reserve(127);\n\t//看看resize可不可以防止多次增容\n\ts4.resize(127);\n\tint old_capacity = s4.capacity();\n\tfor (char ch = 0; ch &lt; 127; ch++)\n\t{\n\t\ts4 += ch;\n\t\t//查看增容情况\n\t\tif (old_capacity != s4.capacity())\n\t\t{\n\t\t\tcout &lt;&lt; \"增容：\" &lt;&lt; old_capacity &lt;&lt;\"-&gt;\"&lt;&lt; s4.capacity()&lt;&lt; endl;\n\t\t}\n\t\told_capacity = s4.capacity();\n\t}\n\tcout &lt;&lt; s4 &lt;&lt; endl &lt;&lt; endl;\n\treturn 0;\n}\n</code></pre>\n</blockquote>\n<h4><a id=\"font_color0000CC_3stringfont_230\"></a><font color=\"#0000CC\">3.string类对象的访问及遍历操作</font></h4>\n<blockquote>\n<table><thead><tr><th>函数名称</th><th>功能说明</th></tr></thead><tbody><tr><td><a href=\"http://www.cplusplus.com/reference/string/string/operator%5B%5D/\">operator[]</a> （重点）</td><td>返回pos位置的字符，const string类对象调用</td></tr><tr><td><a href=\"http://www.cplusplus.com/reference/string/string/begin/\">begin</a>+ <a href=\"http://www.cplusplus.com/reference/string/string/end/\">end</a></td><td>begin获取一个字符的迭代器 + end获取最后一个字符下一个位置的迭代器</td></tr><tr><td><a href=\"http://www.cplusplus.com/reference/string/string/rbegin/\">rbegin</a> + <a href=\"http://www.cplusplus.com/reference/string/string/rend/\">rend</a></td><td>begin获取一个字符的迭代器 + end获取最后一个字符下一个位置的迭代器</td></tr><tr><td>范围for</td><td>C++11支持更简洁的范围for的新遍历方式</td></tr></tbody></table>\n<p><mark>迭代器</mark></p>\n<p><mark>迭代器意义：像string，vector支持[]遍历，但是list，map等等容器不支持[],我们就要用迭代器遍历，所以迭代器是一种统一的使用方式</mark></p>\n<p><img alt=\"image-20220128181708095\" src=\"image\\5efe13ccf392aad9e8257e980f6cd11d.png\"/></p>\n<pre><code class=\"prism language-c++\">int main()\n{\n\tstring s1 = \"Hello c++\";\n\t//迭代器\n\tstring::iterator it = s1.begin();//begin是返回开始位置的迭代器\n\twhile (it != s1.end())//end是返回结束位置的迭代器\n\t{\n\t\tstatic char tmp = 'a';\n\t\t*it++ = tmp++;\n\t}\n\tit = s1.begin();\n\twhile (it != s1.end())//end是返回结束位置的迭代器\n\t{\n\t\tcout &lt;&lt; *it &lt;&lt; \" \";\n\t\tit++;\t\t\n\t}\n\treturn 0;\n}\n</code></pre>\n<p><mark>反向迭代器</mark></p>\n<p><img alt=\"image-20220128185001736\" src=\"image\\5d9c23f60629b90194416b326ad7251c.png\"/></p>\n<pre><code class=\"prism language-c++\">int main()\n{\n\tstring s1 = \"Hello c++\";\n\t//反向迭代器\n\tstring::reverse_iterator rit = s1.rbegin();\n\twhile (rit != s1.rend())\n\t{\n\t\tcout &lt;&lt; *rit &lt;&lt; \" \";\n\t\trit++;\n\t}\n\treturn 0;\n}\n</code></pre>\n<p><img alt=\"image-20220128221641116\" src=\"image\\1bac88788db010a29819cb01b21046d9.png\"/></p>\n</blockquote>\n<h4><a id=\"font_color0000CC_4stringfont_287\"></a><font color=\"#0000CC\">4.string类对象的修改操作</font></h4>\n<blockquote>\n<table><thead><tr><th>函数名称</th><th>功能说明</th></tr></thead><tbody><tr><td><a href=\"http://www.cplusplus.com/reference/string/string/push_back/\">push_back</a></td><td>在字符串后尾插字符c</td></tr><tr><td><a href=\"http://www.cplusplus.com/reference/string/string/append/\">append</a></td><td>在字符串后追加一个字符串</td></tr><tr><td><a href=\"http://www.cplusplus.com/reference/string/string/operator+=/\">operator+=</a> (重点)</td><td>在字符串后追加字符串str</td></tr><tr><td><a href=\"http://www.cplusplus.com/reference/string/string/c_str/\">c_str</a>(重点)</td><td>返回C格式字符串</td></tr><tr><td><a href=\"http://www.cplusplus.com/reference/string/string/find/\">find</a> + <a href=\"http://www.cplusplus.com/reference/string/string/npos/\">npos</a>(重点)</td><td>从字符串pos位置开始往后找字符c，返回该字符在字符串中的位置</td></tr><tr><td><a href=\"http://www.cplusplus.com/reference/string/string/rfind/\">rfind</a></td><td>从字符串pos位置开始往前找字符c，返回该字符在字符串中的位置</td></tr><tr><td><a href=\"http://www.cplusplus.com/reference/string/string/substr/\">substr</a></td><td>在str中从pos位置开始，截取n个字符，然后将其返回</td></tr></tbody></table>\n<p><strong>注意：</strong></p>\n<ol><li>在string尾部追加字符时，s.push_back© / s.append(1, c) / s += 'c’三种的实现方式差不多，一般情况下string类的+=操作用的比较多，+=操作不仅可以连接单个字符，还可以连接字符串。</li><li>对string操作时，如果能够大概预估到放多少字符，可以先通过reserve把空间预留好。</li></ol>\n<p><img alt=\"image-20220129011010870\" src=\"image\\c8fbf49867267240d732bb68a59b8f14.png\"/></p>\n<pre><code class=\"prism language-c++\">int main()\n{\n\tstring s;\n\ts.push_back('h');\n\ts.push_back('e');\n\ts.push_back('l');\n\ts.push_back('l');\n\ts.push_back('o');\n\tcout &lt;&lt; s &lt;&lt; endl;\n\n\ts.append(\" world\");\n\tcout &lt;&lt; s &lt;&lt; endl;\n\tstring s2 = \"!!!!!!\";\n\ts.append(s2);\n\tcout &lt;&lt; s &lt;&lt; endl;\n\n\t//但是不巧的是实际中最喜欢用的是+=\n\tstring s3;\n\ts3 += 'X';\n\ts3 += \"你好\";\n\ts3 += s2;\n\tcout &lt;&lt; s3 &lt;&lt; endl;\n\t//尽量少用insert，因为底层实现是数组，头部或者中间需要挪动数据\n\ts3.insert(0, \"x\");\n\ts3.insert(0,\"hhhh\");\n\tcout &lt;&lt; s3 &lt;&lt; endl;\n\t//删除\n\tstring s4 = s3;\n\tstring s5 = s3;\n\tstring s6 = s3;\n\ts4.erase(3, 100);//从第三个开始删除\n\ts5.erase(3);//从第三个开始删除，一直删完\n\ts6.erase(); //直接删光\n\tcout &lt;&lt; s4 &lt;&lt; endl;\n\tcout &lt;&lt; s5 &lt;&lt; endl;\n\tcout &lt;&lt; s6 &lt;&lt; endl;\n\treturn 0;\n}\n</code></pre>\n<p><img alt=\"image-20220129185118237\" src=\"image\\901a05ea408b26c99fce7574ec51293a.png\"/></p>\n<pre><code class=\"prism language-c++\">int main()\n{\n\tstring s(\"Hello world\");\n\tcout &lt;&lt; s &lt;&lt; endl;        //这边调的是operator&lt;&lt;(cout,s);\n\tcout &lt;&lt; s.c_str() &lt;&lt; endl;//这边调用的是内置类型operator&lt;&lt;(cout,const char*);\n\n\ts.resize(20);\n\ts += \"!!!\";\n\tcout &lt;&lt; s &lt;&lt; endl;\n\tcout &lt;&lt; s.c_str() &lt;&lt; endl;\n\treturn 0;\n}\n</code></pre>\n<p><img alt=\"image-20220129202118400\" src=\"image\\26e50818df25e1184464ed791d285c17.png\"/></p>\n<pre><code class=\"prism language-c++\">int main()\n{\n\t//假设我们需要取文件名的后缀\n\tstring filename = \"text.txt.zip\";\n\tsize_t pos = filename.rfind('.');\n\tif (pos != string::npos)\n\t{\n\t\tstring suff(filename, pos);\n\t\tcout &lt;&lt; suff &lt;&lt; endl;\n\t}\n\treturn 0;\n}\n</code></pre>\n<p><img alt=\"image-20220130103936419\" src=\"image\\c34f5ee206de6c8a7d4119faf319d30a.png\"/></p>\n<pre><code class=\"prism language-c++\">//取域名\nstring GetDomain(const string&amp; url)\n{\n\tsize_t pos = url.find(\"://\");\n\tif (pos != string::npos)\n\t{\n\t\t//找到域名的最开始位置\n\t\tsize_t start = pos + 3;\n\t\t//从域名开始的位置向后面找 ’/‘ \n\t\tsize_t end = url.find('/', start);\n\t\tif (end != string::npos)\n\t\t{\n\t\t\treturn url.substr(start, end - start);\n\t\t}\n\t}\n\t//假如没有就返回一个匿名对象\n\treturn string();\n}\n//取协议\nstring GetProtocol(const string&amp; url)\n{\n\tsize_t pos = url.find(\"://\");\n\tif (pos != string::npos)\n\t{\n\t\treturn url.substr(0, pos);\n\t}\n\t//假如没有就返回一个匿名对象\n\treturn string();\n}\nint main()\n{\n\t//分别取出域名和协议名\n\tstring url1 = \"http://www.cplusplus.com/reference/string/string/find/\";\n\tstring url2 = \"https://juejin.cn/creator/home\";\n\tcout &lt;&lt; GetDomain(url1) &lt;&lt; endl;\n\tcout &lt;&lt; GetProtocol(url1) &lt;&lt; endl;\n\tcout &lt;&lt; GetDomain(url2) &lt;&lt; endl;\n\tcout &lt;&lt; GetProtocol(url2) &lt;&lt; endl;\n\treturn 0;\n}\n</code></pre>\n</blockquote>\n<h4><a id=\"font_color0000CC_5stringfont_428\"></a><font color=\"#0000CC\">5.string类非成员函数</font></h4>\n<blockquote>\n<table><thead><tr><th>函数</th><th>功能说明</th></tr></thead><tbody><tr><td><a href=\"http://www.cplusplus.com/reference/string/string/operator+/\">operator+</a></td><td>尽量少用，因为传值返回，导致深拷贝效率低</td></tr><tr><td><a href=\"http://www.cplusplus.com/reference/string/string/operator%3E%3E/\">operator&gt;&gt;</a> （重点）</td><td>输入运算符重载</td></tr><tr><td><a href=\"http://www.cplusplus.com/reference/string/string/operator%3C%3C/\">operator&lt;&lt;</a> （重点）</td><td>输出运算符重载</td></tr><tr><td><a href=\"http://www.cplusplus.com/reference/string/string/getline/\">getline</a> （重点）</td><td>获取一行字符串</td></tr><tr><td><a href=\"http://www.cplusplus.com/reference/string/string/operators/\">relational operators</a> （重点）</td><td>大小比较</td></tr></tbody></table>\n</blockquote>\n<h3><a id=\"font_colorFF0033_font_440\"></a><font color=\"#FF0033\">几题小菜</font></h3>\n<h4><a id=\"font_color0000CC_httpsleetcodecncomproblemsfirstuniquecharacterinastringfont_442\"></a><font color=\"#0000CC\"><a href=\"https://leetcode-cn.com/problems/first-unique-character-in-a-string/\">找字符串中第一个只出现一次的字符</a></font></h4>\n<blockquote>\n<p>用这题来练手3种遍历</p>\n</blockquote>\n<blockquote>\n<p><img alt=\"image-20220127165401047\" src=\"image\\5e79dae354b7dd5615eb42d09f55a67a.png\"/></p>\n<h5><a id=\"font_colorFF00FF_font_448\"></a><font color=\"#FF00FF\">下标+[]</font></h5>\n<p><img alt=\"image-20220127170528297\" src=\"image\\ffa59cf824d00096d783fd4133db9c91.png\"/></p>\n<pre><code class=\"prism language-c++\">class Solution {\npublic:\n int firstUniqChar(string s) {\n     //26个字母计数数组\n     int count[26] = {0};\n     int i= 0;\n     //遍历计数\n     for(i = 0;i&lt;s.size();i++)\n     {\n         count[s[i]-97]++;\n     }\n     //找第一个是1的\n     for(i = 0;i&lt;s.size();i++)\n     {\n         if(1 == count[s[i]-97])\n         return i;\n     }\n     return -1;\n }\n};\n</code></pre>\n<h5><a id=\"font_colorFF00FF_font_475\"></a><font color=\"#FF00FF\">迭代器</font></h5>\n<p><img alt=\"image-20220127185059304\" src=\"image\\0fb3939f634b401e28475aacbf7e90d7.png\"/></p>\n<pre><code class=\"prism language-c++\">class Solution {\npublic:\n int firstUniqChar(string s) {\n     //26个字母计数数组\n     int count[26] = {0};\n     //迭代器\n     string::iterator it = s.begin();\n     while(it != s.end())\n     {\n         count[*it-97]++;\n         it++;\n     }\n     //找第一个是1的\n     for(int i = 0;i&lt;s.size();i++)\n     {\n         if(1 == count[s[i]-97])\n         return i;\n     }\n     return -1;\n }\n};\n</code></pre>\n<h5><a id=\"font_colorFF00FF_forfont_503\"></a><font color=\"#FF00FF\">范围for</font></h5>\n<p><img alt=\"image-20220127190748999\" src=\"image\\cfa33cb402ed92b0f7d417148a5d4b1d.png\"/></p>\n<pre><code class=\"prism language-c++\">class Solution {\npublic:\n int firstUniqChar(string s) {\n     //26个字母计数数组\n     int count[26] = {0};\n     //范围for\n    for(auto&amp; e:s)\n    {\n         count[e-97]++;\n    }\n     //找第一个是1的\n     for(int i = 0;i&lt;s.size();i++)\n     {\n         if(1 == count[s[i]-97])\n         return i;\n     }\n     return -1;\n }\n};\n</code></pre>\n</blockquote>\n<h4><a id=\"httpsleetcodecncomproblemsreverseonlyletters_529\"></a><a href=\"https://leetcode-cn.com/problems/reverse-only-letters/\">仅仅反转字母</a></h4>\n<blockquote>\n<p><img alt=\"image-20220128105728308\" src=\"image\\5c8f115b3b52625f457f5874211a847c.png\"/></p>\n<p><img alt=\"image-20220128105637326\" src=\"image\\caff7e34483fb7ce2095bf6e1bce8631.png\"/></p>\n<pre><code class=\"prism language-c++\">class Solution {\npublic:\n    //判断是否是字母\n    bool isletter(const char ch)\n    {\n        if((ch &gt;= 'a' &amp;&amp; ch&lt;='z') ||(ch &gt;= 'A' &amp;&amp; ch &lt;='Z'))\n        return true;\n        return false;\n    }\n    string reverseOnlyLetters(string s) {\n        if(!s.size())\n         return s;\n       //头尾下标\n       int begin = 0,end = s.size()-1;\n       while(begin &lt; end)\n       {\n           while(begin &lt; end &amp;&amp; !isletter(s[begin]))\n                begin++;\n           while(begin &lt; end &amp;&amp; !isletter(s[end]))\n                end--;\n            swap(s[begin],s[end]);\n            begin++;\n            end--;\n       }\n       return s;   \n    }\n};\n</code></pre>\n</blockquote>\n<h4><a id=\"font_color0000CC_httpswwwnowcodercompractice8c949ea5f36f422594b306a2300315datpId37tqId21224rp5ruactivityojqrutahuaweiquestionrankingfont_567\"></a><font color=\"#0000CC\"><a href=\"https://www.nowcoder.com/practice/8c949ea5f36f422594b306a2300315da?tpId=37&amp;&amp;tqId=21224&amp;rp=5&amp;ru=/activity/oj&amp;qru=/ta/huawei/question-ranking\"><strong>字符串最后一个单词的长度</strong></a></font></h4>\n<blockquote>\n<p><img alt=\"image-20220127211552511\" src=\"image\\af1ea505a660fd0318287c3e29291bcd.png\"/></p>\n<p><img alt=\"image-20220130112625865\" src=\"image\\bd0086d63a86d5c39b8b0c1a43a53455.png\"/></p>\n<p><img alt=\"image-20220130113017517\" src=\"image\\06b41f5c631fc98fa44af5b179c0a611.png\"/></p>\n<pre><code class=\"prism language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n\n\nint main()\n{\n    string str;\n    getline(cin,str);\n    size_t pos = str.rfind(' ');\n    if(pos != string::npos)\n    {\n        cout&lt;&lt; str.size()-pos-1&lt;&lt;endl;\n    }\n    else\n    {\n        cout&lt;&lt; str.size()&lt;&lt;endl;\n    }\n    return 0;\n}\n</code></pre>\n</blockquote>\n<h4><a id=\"httpsleetcodecncomproblemsvalidpalindrome_599\"></a><a href=\"https://leetcode-cn.com/problems/valid-palindrome/\">验证回文串</a></h4>\n<blockquote>\n<p><img alt=\"image-20220127212716778\" src=\"image\\d984a6577c6e27c68c5491e65a8d412c.png\"/></p>\n<p><img alt=\"image-20220130130005327\" src=\"image\\59aa12fc48a51ddbdf1a7abaaf46a93b.png\"/></p>\n<pre><code class=\"prism language-C++\">class Solution {\npublic:\n    bool isPalindrome(string s) {\n        //创建两个空字符串\n        string str1,str2,str3;        \n        //反向迭代器\n        string::reverse_iterator rit = s.rbegin();\n        while(rit != s.rend())\n        {\n            if(*rit &gt;= 'A' &amp;&amp; *rit &lt;='Z')\n                str1 += *rit+32;\n            else if(*rit &gt;= 'a' &amp;&amp; *rit&lt;='z')\n                str1 += *rit;\n            else if(*rit &gt;= '0' &amp;&amp; *rit&lt;='9')\n                str1 += *rit;\n            rit++;\n        }\n        str2 = str1;\n        //再来一次反向迭代器\n        string::reverse_iterator rt = str2.rbegin();\n        while(rt != str2.rend())\n           str3 += *rt++;\n        if(str3 == str2)\n            return true;\n        else\n            return false;\n    }\n};\n</code></pre>\n<p><img alt=\"image-20220130132239335\" src=\"image\\a68b088304145ee8c3f43095842b3521.png\"/></p>\n<pre><code class=\"prism language-C++\">class Solution {\npublic:\n    //判断字母数字\n    bool islettername(const char&amp; ch){\n        if(ch &gt;= 'a' &amp;&amp; ch &lt;= 'z'\n        || (ch &gt;= '0' &amp;&amp; ch &lt;='9'))\n        return true;\n        return false;\n    }\n    bool isPalindrome(string s) {\n        //先把s里面大写全部改成小写的\n        for(auto&amp; e:s)\n        {\n            if(e&gt;='A' &amp;&amp; e&lt;='Z')\n            e+=32;\n        }\n        int begin = 0;\n        int end = s.size()-1;\n        while(begin &lt; end)\n        {\n            while(begin &lt; end &amp;&amp; !islettername(s[begin]))\n            begin++;\n            while(begin &lt; end &amp;&amp; !islettername(s[end]))\n            end--;\n            if(s[begin] == s[end])\n            {\n                 begin++; end--;\n            }\n            else\n            return false;\n        }\n        return true;\n    }\n};\n</code></pre>\n</blockquote>\n<h4><a id=\"httpsleetcodecncomproblemsaddstrings_677\"></a><a href=\"https://leetcode-cn.com/problems/add-strings/\">字符串相加</a></h4>\n<blockquote>\n<p><img alt=\"image-20220130133032959\" src=\"image\\305bb9459760725fcc729eba4a8bc987.png\"/></p>\n<p><img alt=\"image-20220130141528575\" src=\"image\\b3f5082d6a7190980cb4715872943ff0.png\"/></p>\n<pre><code class=\"prism language-c++\">class Solution {\npublic:\n    string addStrings(string num1, string num2) {\n        //两个下标\n        int end1 = num1.size()-1,end2 = num2.size()-1;\n        //计算后的对象\n        string ansStr;\n        //进位\n        int carry = 0;\n        while(end1&gt;=0 || end2&gt;=0)\n        {\n            int n1 = 0;\n            if(end1 &gt;= 0){\n                n1 = num1[end1] - '0';\n                end1--;\n            }\n            int n2 = 0;\n            if(end2 &gt;= 0){\n                n2 = num2[end2] - '0';\n                end2--;\n            }\n            //两个位置开始相加\n            int ret = n1+n2+carry;\n            if(ret &gt; 9){\n                ret -= 10;\n                carry = 1;\n            }\n            else\n                carry = 0;\n            //这是就准备插字符\n            ansStr.insert(0,1,ret+'0');\n        }\n        //插最后一个进位的\n        if(carry)\n        ansStr.insert(0,1,carry+'0');\n        return ansStr;\n    }\n};\n</code></pre>\n<p><mark>实际上我们可以看到提交时间看到我们时间复杂度不行，那是因为我们头插了insert了，字符串越长，挪动的就越恶心，也就效率越低，所以我就直接尾插，到最后再来个逆置reverse就行了，这时候就看我们选用的接口了，基本一题都有好几种解法</mark></p>\n<p><img alt=\"image-20220130143407011\" src=\"image\\27a4e91bdf352fb6a82bf408989606bc.png\"/></p>\n<pre><code class=\"prism language-c++\">class Solution {\npublic:\n    string addStrings(string num1, string num2) {\n        //两个下标\n        int end1 = num1.size()-1,end2 = num2.size()-1;\n        //计算后的对象\n        string ansStr;\n        //进位\n        int carry = 0;\n        while(end1&gt;=0 || end2&gt;=0)\n        {\n            int n1 = 0;\n            if(end1 &gt;= 0){\n                n1 = num1[end1] - '0';\n                end1--;\n            }\n            int n2 = 0;\n            if(end2 &gt;= 0){\n                n2 = num2[end2] - '0';\n                end2--;\n            }\n            //两个位置开始相加\n            int ret = n1+n2+carry;\n            if(ret &gt; 9){\n                ret -= 10;\n                carry = 1;\n            }\n            else\n                carry = 0;\n            //这是就准备插字符  我们这就直接尾插\n            ansStr += (ret +'0');\n        }\n        //插最后一个进位的\n        if(carry)\n        ansStr += (carry +'0');\n        //然后逆置就行\n        reverse(ansStr.begin(),ansStr.end());\n        return ansStr;\n    }\n};\n</code></pre>\n</blockquote>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}