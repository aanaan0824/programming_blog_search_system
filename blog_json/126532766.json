{"blogid": "126532766", "writerAge": "码龄3年", "writerBlogNum": "30", "writerCollect": "254", "writerComment": "259", "writerFan": "384", "writerGrade": "4级", "writerIntegral": "1289", "writerName": "一哑7", "writerProfileAdress": "writer_image\\profile_126532766.jpg", "writerRankTotal": "14717", "writerRankWeekly": "213", "writerThumb": "312", "writerVisitNum": "13142", "blog_read_count": "616", "blog_time": "已于 2022-08-30 16:05:22 修改", "blog_title": "Java多线程下——各类锁的详解", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p></p>\n<div class=\"toc\">\n<h3>这里写目录标题</h3>\n<ul><li><a href=\"#_1\">各类锁的详解</a></li><li><ul><li><a href=\"#_2\">常见的锁策略</a></li><li><ul><li><a href=\"#_vs__3\">乐观锁 vs 悲观锁</a></li><li><a href=\"#_22\">读写锁</a></li><li><a href=\"#_vs__36\">重量级锁 vs 轻量级锁</a></li><li><a href=\"#Spin_Lock_54\">自旋锁（Spin Lock）</a></li><li><a href=\"#_vs__63\">公平锁 vs 非公平锁</a></li><li><a href=\"#_vs__73\">可重入锁 vs 不可重入锁</a></li></ul>\n</li><li><a href=\"#CAS_80\">CAS</a></li><li><a href=\"#Synchronized__138\">Synchronized 原理</a></li><li><ul><li><a href=\"#_151\">偏向锁</a></li><li><a href=\"#_159\">锁消除</a></li><li><a href=\"#_172\">锁粗化</a></li></ul>\n</li><li><a href=\"#Callable__188\">Callable 接口</a></li><li><a href=\"#ReentrantLock_266\">ReentrantLock</a></li><li><a href=\"#_305\">线程池</a></li><li><ul><li><a href=\"#ExecutorService__Executors_307\">ExecutorService 和 Executors</a></li><li><a href=\"#ThreadPoolExecutor_341\">ThreadPoolExecutor</a></li><li><a href=\"#_380\">线程池的工作流程</a></li><li><a href=\"#_Semaphore_383\">信号量 Semaphore</a></li></ul>\n</li><li><a href=\"#_435\">多线程环境使用哈希表</a></li><li><ul><li><a href=\"#Hashtable_436\">Hashtable</a></li><li><a href=\"#ConcurrentHashMap_448\">ConcurrentHashMap</a></li></ul>\n</li><li><a href=\"#_466\">死锁</a></li><li><ul><li><a href=\"#_477\">如何避免死锁</a></li><li><a href=\"#_489\">破坏循环等待</a></li></ul>\n</li><li><a href=\"#_574\">相关问题</a></li><li><ul><li><a href=\"#Java_575\">Java多线程是如何实现数据共享的?</a></li><li><a href=\"#Java_581\">Java线程共有几种状态？状态之间怎么切换的？</a></li><li><a href=\"#ThreadRunnable_590\">Thread和Runnable的区别和联系?</a></li><li><a href=\"#start_595\">多次start一个线程会怎么样？</a></li><li><a href=\"#synchronized_598\">有synchronized两个方法，两个线程分别同时用这个方法，请问会发生什么？</a></li><li><a href=\"#_605\">进程和线程的区别？</a></li></ul>\n</li></ul>\n</li></ul>\n</div>\n<p></p>\n<h1><a id=\"_1\"></a>各类锁的详解</h1>\n<h2><a id=\"_2\"></a>常见的锁策略</h2>\n<h3><a id=\"_vs__3\"></a>乐观锁 vs 悲观锁</h3>\n<blockquote>\n<ul><li>悲观锁:<br/> 总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。</li></ul>\n<p>例： <code>同学 A 认为 \"老师是比较忙的, 我来问问题, 老师不一定有空解答\". 因此同学 A 会先给老师发消息: \"老师 你忙嘛? 我下午两点能来找你问个问题嘛?\" (相当于加锁操作) 得到肯定的答复之后, 才会真的来问问题. 如果得到了否定的答复, 那就等一段时间, 下次再来和老师确定时间. 这个是悲观锁.</code></p>\n<ul><li>乐观锁：<br/> 假设数据一般情况下不会产生并发冲突，所以在数据进行提交更新的时候，才会正式对数据是否产生并<br/> 发冲突进行检测，如果发现并发冲突了，则让返回用户错误的信息，让用户决定如何去做。</li></ul>\n<p>例：<code>同学 B 认为 \"老师是比较闲的, 我来问问题, 老师大概率是有空解答的\". 因此同学 B 直接就来找老师.(没加 锁, 直接访问资源) 如果老师确实比较闲, 那么直接问题就解决了. 如果老师这会确实很忙, 那么同学 B 也 不会打扰老师, 就下次再来(虽然没加锁, 但是能识别出数据访问冲突). 这个是乐观锁.</code></p>\n</blockquote>\n<p>还记得我们之前经常提到的Synchronized吗？<br/> <mark>Synchronized 初始使用乐观锁策略. 当发现锁竞争比较频繁的时候, 就会自动切换成悲观锁策略</mark></p>\n<hr/>\n<h3><a id=\"_22\"></a>读写锁</h3>\n<p><mark>首先说明一下我们熟知的Synchronized 不是读写锁.</mark><br/> Java 标准库提供ReentrantReadWriteLock 类, 实现了读写锁。</p>\n<blockquote>\n<p>ReentrantReadWriteLock.ReadLock 类表示一个读锁. 这个对象提供了 lock / unlock 方法进行加锁解锁。<br/> ReentrantReadWriteLock.WriteLock 类表示一个写锁. 这个对象也提供了 lock / unlock 方法进行加锁解锁。</p>\n</blockquote>\n<p>读加锁和读加锁之间, 不互斥；<br/> 写加锁和写加锁之间, 互斥；<br/> 读加锁和写加锁之间, 互斥；</p>\n<p><mark>只要是涉及到 “互斥”, 就会产生线程的挂起等待. 一旦线程挂起, 再次被唤醒就不知道隔了多久了，因此尽可能减少 “互斥” 的机会, 就是提高效率的重要途径.</mark><br/> <code>所以很明显了吧，读写锁更适合于 \"频繁读, 不频繁写\" 的场景中</code></p>\n<hr/>\n<h3><a id=\"_vs__36\"></a>重量级锁 vs 轻量级锁</h3>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\3da474e142c546888cd09539016d41b5.png\"/><br/> <code>synchronized 并不仅仅是对 mutex 进行封装, 在 synchronized 内部还做了很多其他的 工作</code></p>\n<p>嗯？不知道什么意思？那肯定不知道啊因为没说来着，下面我们来理解一下：</p>\n<blockquote>\n<p>重量级锁: 加锁机制重度依赖了 OS 提供了 mutex</p>\n<ul><li>大量的内核态用户态切换</li><li>很容易引发线程的调度<br/> <code>这两个操作, 成本比较高. 一旦涉及到用户态和内核态的切换, 就意味着 \"沧海桑田\".</code></li></ul>\n<p>轻量级锁: 加锁机制尽可能不使用 mutex, 而是尽量在用户态代码完成. 实在搞不定了, 再使用 mutex.</p>\n<ul><li>少量的内核态用户态切换.</li><li>不太容易引发线程调度.</li></ul>\n</blockquote>\n<p><mark>嗯。。。又来了我们熟悉的synchronized 开始是一个轻量级锁. 如果锁冲突比较严重, 就会变成重量级锁.</mark></p>\n<hr/>\n<h3><a id=\"Spin_Lock_54\"></a>自旋锁（Spin Lock）</h3>\n<p>首先我们提出问题为什么是自旋锁，干啥的？<br/> 解：按之前的方式，线程在抢锁失败后进入阻塞状态，放弃 CPU，需要过很久才能再次被调度.但实际上, 大部分情况下，虽然当前抢锁失败，但过不了很久，锁就会被释放。没必要就放弃 CPU. 这个时候就可以使用自旋锁来处理这样的问题.<br/> <code>如果获取锁失败, 立即再尝试获取锁, 无限循环, 直到获取到锁为止. 第一次获取锁失败, 第二次的尝试会在极短的时间内到来.一旦锁被其他线程释放, 就能第一时间获取到锁.</code></p>\n<blockquote>\n<p><code>自旋锁是一种典型的 轻量级锁 的实现方式.</code></p>\n<ul><li>优点: 没有放弃 CPU, 不涉及线程阻塞和调度, 一旦锁被释放, 就能第一时间获取到锁.</li><li>缺点: 如果锁被其他线程持有的时间比较久, 那么就会持续的消耗 CPU 资源. (而挂起等待的时候是不消耗 CPU 的)</li></ul>\n</blockquote>\n<hr/>\n<h3><a id=\"_vs__63\"></a>公平锁 vs 非公平锁</h3>\n<blockquote>\n<ul><li>公平锁: 遵守 “先来后到”. B 比 C 先来的. 当 A 释放锁的之后, B 就能先于 C 获取到锁.</li><li>非公平锁: 不遵守 “先来后到”. B 和 C 都有可能获取到锁.</li></ul>\n</blockquote>\n<p><code>操作系统内部的线程调度就可以视为是随机的. 如果不做任何额外的限制, 锁就是非公平锁. 如果要想实现公平锁, 就需要依赖额外的数据结构, 来记录线程们的先后顺序.</code></p>\n<p><mark>synchronized 是非公平锁.</mark></p>\n<hr/>\n<h3><a id=\"_vs__73\"></a>可重入锁 vs 不可重入锁</h3>\n<p>可重入锁的字面意思是“可以重新进入的锁”，即允许同一个线程多次获取同一把锁。比如一个递归函数里有加锁操作，递归过程中这个锁会阻塞自己吗？如果不会，那么这个锁就是可重入锁（因为这个原因可重入锁也叫做递归锁）。</p>\n<p><code>Java里只要以Reentrant开头命名的锁都是可重入锁，而且JDK提供的所有现成的Lock实现类，包括synchronized关键字锁都是可重入的。</code><br/> <mark>Linux 系统提供的 mutex 是不可重入锁.</mark></p>\n<hr/>\n<h2><a id=\"CAS_80\"></a>CAS</h2>\n<p><code>Compare and swap</code><br/> CAS 是直接读写内存的, 而不是操作寄存器.<br/> CAS 的读内存, 比较, 写内存操作是一条硬件指令, 是原子的.</p>\n<p>CAS 有哪些应用:</p>\n<blockquote>\n<ol><li>实现原子类<br/> 标准库中提供了 java.util.concurrent.atomic 包, 里面的类都是基于这种方式来实现<br/> 典型的就是 AtomicInteger 类其中的 getAndIncrement ()相当于 i++ 操作.</li></ol>\n</blockquote>\n<p><img alt=\"cas1\" src=\"image\\4b0cc71eafff45aebd59b072369809de.png\"/><br/> <img alt=\"cas2\" src=\"image\\cb7327d5b38d45739e07cf16c4e1a078.png\"/><br/> <img alt=\"cas3\" src=\"image\\0fbd0772bed640e6ade2d06372eff3b0.png\"/></p>\n<p><img alt=\"cas4\" src=\"image\\f0241dedb3604b28a54eb01992769a8f.png\"/></p>\n<p>通过形如上述代码就可以实现一个原子类. 不需要使用重量级锁, 就可以高效的完成多线程的自增操作.<br/> <code>本来 check and set 这样的操作在代码角度不是原子的. 但是在硬件层面上可以让一条指令完成这个操作, 也就变成原子的了.</code></p>\n<blockquote>\n<ol start=\"2\"><li>实现自旋锁<br/> 基于 CAS 实现更灵活的锁, 获取到更多的控制权</li></ol>\n</blockquote>\n<blockquote>\n<ol start=\"3\"><li>CAS 的 ABA 问题</li></ol>\n<ul><li>ABA问题描述：<br/> 假设存在两个线程 t1 和 t2. 有一个共享变量 num, 初始值为 A，接下来, 线程 t1 想使用 CAS 把 num 值改成 Z, 那么就需要先读取 num 的值, 记录到 oldNum 变量中.使用 CAS 判定当前 num 的值是否为 A, 如果为 A, 就修改成 Z.但是, 在 t1 执行这两个操作之间, t2 线程可能把 num 的值从 A 改成了 B, 又从 B 改成了 A。<br/> <code>线程 t1 的 CAS 是期望 num 不变就修改. 但是 num 的值已经被 t2 给改了. 只不过又改成 A 了. 这个时候 t1 究竟是否要更新 num 的值为 Z 呢?</code><br/> <img alt=\"在这里插入图片描述\" src=\"image\\e74a13e89b1d4181af5d7c2803635243.png\"/><br/> 就像娶个新婚媳妇，怎么判断她在你之前是否有过无数个老公？</li></ul>\n</blockquote>\n<p>嗯？你说无所谓？都可以不介意？但是计算机不一样哦，来看一个Bug:</p>\n<p>假设 滑稽老哥 有 100 存款. 滑稽想从 ATM 取 50 块钱. 取款机创建了两个线程 并发的来执行 -50操作:</p>\n<p>我们期望一个线程执行 -50 成功, 另一个线程 -50 失败.如果使用 CAS 的方式来完成这个扣款过程就可能出现问题.</p>\n<blockquote>\n<p>正常的过程:</p>\n<ol><li>存款 100. 线程1 获取到当前存款值为 100, 期望更新为 50; 线程2 获取到当前存款值为 100, 期<br/> 望更新为 50.</li><li>线程1 执行扣款成功, 存款被改成 50. 线程2 阻塞等待中.</li><li>轮到线程2 执行了, 发现当前存款为 50, 和之前读到的 100 不相同, 执行失败.</li></ol>\n<p>异常的过程:</p>\n<ol><li>存款 100. 线程1 获取到当前存款值为 100, 期望更新为 50; 线程2 获取到当前存款值为 100, 期望更新为 50.</li></ol>\n<ol start=\"2\"><li>线程1 执行扣款成功, 存款被改成 50. 线程2 阻塞等待中.</li><li>在线程2 执行之前, 滑稽的朋友正好给滑稽转账 50, 账户余额变成 100 !!</li><li>轮到线程2 执行了, 发现当前存款为 100, 和之前读到的 100 相同, 再次执行扣款操作</li></ol>\n</blockquote>\n<p>你可以不介意媳妇，嗯。。理解理解但是钱。。。你不介意？<br/> 所以着急问我解决方案是什么了吧：<br/> <code>其实我们之前提到过就是引入版本号</code><br/> CAS 操作在读取旧值的同时, 也要读取版本号.</p>\n<blockquote>\n<p>真正修改的时候:</p>\n<ol><li>如果当前版本号和读到的版本号相同, 则修改数据, 并把版本号 + 1.</li><li>如果当前版本号高于读到的版本号. 就操作失败(认为数据已经被修改过了</li></ol>\n</blockquote>\n<p><code>在 Java 标准库中提供了 AtomicStampedReference&lt;E&gt; 类. 这个类可以对某个类进行包装, 在内部就提供了上面描述的版本管理功能.</code></p>\n<hr/>\n<h2><a id=\"Synchronized__138\"></a>Synchronized 原理</h2>\n<p>截止目前，本文前段我们已经了解了各种锁策略，期间也多次提到Synchronized，所以我们可以知道其具备以下特性：</p>\n<ol><li>开始时是乐观锁, 如果锁冲突频繁, 就转换为悲观锁</li><li>开始是轻量级锁实现, 如果锁被持有的时间较长, 就转换成重量级锁.</li><li>实现轻量级锁的时候大概率用到的自旋锁策略</li><li>是一种不公平锁</li><li>是一种可重入锁</li><li>不是读写锁</li></ol>\n<p>JVM 将 synchronized 锁分为 无锁、偏向锁、轻量级锁、重量级锁 状态。会根据情况，进行依次升级</p>\n<p>没有听过偏向锁？</p>\n<h3><a id=\"_151\"></a>偏向锁</h3>\n<blockquote>\n<ol><li>偏向锁不是真的 “加锁”, 只是给对象头中做一个 “偏向锁的标记”, 记录这个锁属于哪个线程</li><li>如果后续没有其他线程来竞争该锁, 那么就不用进行其他同步操作了(避免了加锁解锁的开销)</li><li>如果后续有其他线程来竞争该锁(刚才已经在锁对象中记录了当前锁属于哪个线程了, 很容易识别当前申请锁的线程是不是之前记录的线程), 那就取消原来的偏向锁状态, 进入一般的轻量级锁状态</li></ol>\n</blockquote>\n<p>举个栗子理解偏向锁：<br/> 假设男主是一个锁, 女主是一个线程. 如果只有这一个线程来使用这个锁, 那么男主女主即使不领证结婚(避免了高成本操作), 也可以一直幸福的生活下去.但是,但是，但是，女配出现了, 也尝试竞争男主, 此时不管领证结婚这个操作成本多高, 女主也势必要把这个动作完成了, 让女配死心.</p>\n<h3><a id=\"_159\"></a>锁消除</h3>\n<p><code>编译器+JVM 判断锁是否可消除. 如果可以, 就直接消除</code><br/> 有些应用程序的代码中, 用到了 synchronized, 但其实没有在多线程环境下. (例如 StringBuffer)</p>\n<pre><code class=\"prism language-java\"><span class=\"token class-name\">StringBuffer</span> sb <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">StringBuffer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n sb<span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"a\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n sb<span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"b\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n sb<span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"c\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n sb<span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"d\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>此时每个 append 的调用都会涉及加锁和解锁. 但如果只是在单线程中执行这个代码, 那么这些加锁解锁操作是没有必要的, 白白浪费了一些资源开销.</p>\n<h3><a id=\"_172\"></a>锁粗化</h3>\n<p><code>一段逻辑中如果出现多次加锁解锁, 编译器 + JVM 会自动进行锁的粗化.</code><br/> <img alt=\"在这里插入图片描述\" src=\"image\\b630679089c942e29702a21a70838be6.png\"/></p>\n<p>实际开发过程中, 使用细粒度锁, 是期望释放锁的时候其他线程能使用锁,但是实际上可能并没有其他线程来抢占这个锁. 这种情况 JVM 就会自动把锁粗化, 避免频繁申请释放锁.<br/> 举个栗子：<br/> 1、打开铅笔盒 ； 2、拿出橡皮 ； 3、关闭铅笔盒。<br/> 4、打开铅笔盒 ；5、拿出尺子 ； 6、关闭铅笔盒。<br/> 7、打开铅笔盒 ；8、拿出橡皮 ； 9、关闭铅笔盒。<br/> 然鹅。。人类会这样吗？当然不会，我们会：<br/> 1、打开铅笔盒 ； 2、拿出橡皮 ； 3、拿出尺子；4、拿出铅笔；5、关闭铅笔盒。</p>\n<p><code>这就是Synchronized，不愧出自JVM对咱们Java程序猿够良心吧。。。</code></p>\n<hr/>\n<h2><a id=\"Callable__188\"></a>Callable 接口</h2>\n<p><code>Callable 是一个 interface . 相当于把线程封装了一个 \"返回值\". 方便程序猿借助多线程的方式计算结果.</code><br/> 我们举个栗子：<br/> <mark>创建线程计算 1 + 2 + 3 + … + 1000</mark></p>\n<blockquote>\n<p>不使用 Callable 版本：</p>\n</blockquote>\n<pre><code class=\"prism language-java\"><span class=\"token keyword\">package</span> <span class=\"token namespace\">demo2</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Test</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Result</span> <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> sum <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">public</span> <span class=\"token class-name\">Object</span> lock <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">InterruptedException</span> <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token class-name\">Result</span> result <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Result</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">Thread</span> t <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n            <span class=\"token annotation punctuation\">@Override</span>\n            <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n                <span class=\"token keyword\">int</span> sum <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n                    sum <span class=\"token operator\">+=</span> i<span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n\n                <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">.</span>lock<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n                    result<span class=\"token punctuation\">.</span>sum <span class=\"token operator\">=</span> sum<span class=\"token punctuation\">;</span>\n                    result<span class=\"token punctuation\">.</span>lock<span class=\"token punctuation\">.</span><span class=\"token function\">notify</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n        t<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">.</span>lock<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n            <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">.</span>sum <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n                result<span class=\"token punctuation\">.</span>lock<span class=\"token punctuation\">.</span><span class=\"token function\">wait</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">.</span>sum<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n</code></pre>\n<p>可以看到, 上述代码需要一个辅助类 Result, 还需要使用一系列的加锁和 wait notify 操作, 代码复杂, 容易出错;所以我们看看使用 Callable 后。</p>\n<blockquote>\n<p>使用 Callable 版本：</p>\n</blockquote>\n<pre><code class=\"prism language-java\"><span class=\"token keyword\">package</span> <span class=\"token namespace\">demo2</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">import</span> <span class=\"token namespace\">java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>concurrent<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">Callable</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token namespace\">java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>concurrent<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">ExecutionException</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token namespace\">java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>concurrent<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">FutureTask</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Test</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">ExecutionException</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">InterruptedException</span> <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token class-name\">Callable</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">&gt;</span></span> callable <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Callable</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">&gt;</span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n            <span class=\"token annotation punctuation\">@Override</span>\n            <span class=\"token keyword\">public</span> <span class=\"token class-name\">Integer</span> <span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">Exception</span> <span class=\"token punctuation\">{<!-- --></span>\n                <span class=\"token keyword\">int</span> sum <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n                    sum <span class=\"token operator\">+=</span> i<span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n                <span class=\"token keyword\">return</span> sum<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">FutureTask</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">&gt;</span></span> futureTask <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">FutureTask</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">&gt;</span></span><span class=\"token punctuation\">(</span>callable<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">Thread</span> t <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span>futureTask<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> t<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> result <span class=\"token operator\">=</span> futureTask<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    \n<span class=\"token punctuation\">}</span>\n\n</code></pre>\n<p>可以看到, 使用 Callable 和 FutureTask 之后, 代码简化了很多, 也不必手动写线程同步代码了.<br/> <code>Callable 和 Runnable 相对, 都是描述一个 \"任务\". Callable 描述的是带有返回值的任务, Runnable描述的是不带返回值的任务.</code><br/> 说明： Callable 通常需要搭配 FutureTask 来使用. FutureTask 用来保存 Callable 的返回结果. 因为<br/> Callable 往往是在另一个线程中执行的, 啥时候执行完并不确定.FutureTask 就可以负责这个等待结果出来的工作</p>\n<hr/>\n<h2><a id=\"ReentrantLock_266\"></a>ReentrantLock</h2>\n<p><code>JUC类下的可重入互斥锁. 和 synchronized 定位类似, 都是用来实现互斥效果, 保证线程安全</code></p>\n<blockquote>\n<p>ReentrantLock 的用法:</p>\n<ol><li>lock(): 加锁, 如果获取不到锁就死等.</li><li>trylock(超时时间): 加锁, 如果获取不到锁, 等待一定的时间之后就放弃加锁.</li><li>unlock(): 解锁</li></ol>\n</blockquote>\n<blockquote>\n<p>ReentrantLock 和 synchronized 的区别:</p>\n<ul><li>synchronized 是一个关键字, 是 JVM 内部实现的(大概率是基于 C++ 实现).</li><li>ReentrantLock 是标准库的一个类, 在 JVM 外实现的(基于 Java 实现).</li><li>synchronized 使用时不需要手动释放锁. ReentrantLock 使用时需要手动释放. 使用起来更灵活, 但是也容易遗漏 unlock.</li><li>synchronized 在申请锁失败时, 会死等. ReentrantLock 可以通过 trylock 的方式等待一段时间就放弃.</li><li>synchronized 是非公平锁, ReentrantLock 默认是非公平锁. 可以通过构造方法传入一个 true 开启公平锁模式.</li><li>更强大的唤醒机制. synchronized 是通过 Object 的 wait / notify 实现等待-唤醒. 每次唤醒的是一个随机等待的线程. ReentrantLock 搭配 Condition 类实现等待-唤醒, 可以更精确控制唤醒某个指定的线程.</li></ul>\n</blockquote>\n<blockquote>\n<p>如何选择使用哪个锁?</p>\n<ul><li>锁竞争不激烈的时候, 使用 synchronized, 效率更高, 自动释放更方便.</li><li>锁竞争激烈的时候, 使用 ReentrantLock, 搭配 trylock 更灵活控制加锁的行为, 而不是死等.</li><li>如果需要使用公平锁, 使用 ReentrantLock.</li></ul>\n</blockquote>\n<hr/>\n<pre><code>原子类内部用的是 CAS 实现，所以性能要比加锁实现 i++ 高很多。原子类有以下几个：\n</code></pre>\n<p>AtomicBoolean； AtomicInteger；AtomicIntegerArray；AtomicLong； AtomicReference； AtomicStampedReference<br/> 以 AtomicInteger 举例，常见方法有：</p>\n<pre><code class=\"prism language-java\"> \t<span class=\"token function\">addAndGet</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> delta<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//i +=delta;</span>\n\n    <span class=\"token function\">decrementAndGet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//--i;</span>\n\n    <span class=\"token function\">getAndDecrement</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//i--;</span>\n\n    <span class=\"token function\">incrementAndGet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//++i;</span>\n\n    <span class=\"token function\">getAndIncrement</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//i++;</span>\n</code></pre>\n<hr/>\n<h2><a id=\"_305\"></a>线程池</h2>\n<p>虽然创建销毁线程比创建销毁进程更轻量, 但是在频繁创建销毁线程的时候还是会比较低效所以线程池就是为了解决这个问题. 如果某个线程不再使用了, 并不是真正把线程释放, 而是放到一个 “池子” 中, 下次如果需要用到线程就直接从池子中取, 不必通过系统来创建了。</p>\n<h3><a id=\"ExecutorService__Executors_307\"></a>ExecutorService 和 Executors</h3>\n<blockquote>\n<p>ExecutorService 表示一个线程池实例.<br/> Executors 是一个工厂类, 能够创建出几种不同风格的线程池.<br/> ExecutorService 的 submit 方法能够向线程池中提交若干个任务.</p>\n</blockquote>\n<blockquote>\n<p><code>Executors 创建线程池的几种方式</code></p>\n<ul><li>newFixedThreadPool: 创建固定线程数的线程池</li><li>newCachedThreadPool: 创建线程数目动态增长的线程池.</li><li>newSingleThreadExecutor: 创建只包含单个线程的线程池.</li><li>newScheduledThreadPool: 设定 延迟时间后执行命令，或者定期执行命令. 是进阶版的 Timer.</li></ul>\n</blockquote>\n<p><code>Executors 本质上是 ThreadPoolExecutor 类的封装.</code></p>\n<p>举个栗子：</p>\n<pre><code class=\"prism language-java\"><span class=\"token keyword\">package</span> <span class=\"token namespace\">demo2</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">import</span> <span class=\"token namespace\">java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>concurrent<span class=\"token punctuation\">.</span></span><span class=\"token operator\">*</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Test</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token class-name\">ExecutorService</span> pool <span class=\"token operator\">=</span> <span class=\"token class-name\">Executors</span><span class=\"token punctuation\">.</span><span class=\"token function\">newFixedThreadPool</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        pool<span class=\"token punctuation\">.</span><span class=\"token function\">submit</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Runnable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n            <span class=\"token annotation punctuation\">@Override</span>\n            <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n                <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n</code></pre>\n<h3><a id=\"ThreadPoolExecutor_341\"></a>ThreadPoolExecutor</h3>\n<blockquote>\n<p><code>理解 ThreadPoolExecutor 构造方法的参数:</code><br/> 把创建一个线程池想象成开个公司. 每个员工相当于一个线程.</p>\n</blockquote>\n<blockquote>\n<ol><li>corePoolSize: 正式员工的数量. (正式员工, 一旦录用, 永不辞退)maximumPoolSize: 正式员工 + 临时工的数目. (临时工: 一段时间不干活, 就被辞退).</li><li>keepAliveTime: 临时工允许的空闲时间.</li><li>unit: keepaliveTime 的时间单位, 是秒, 分钟, 还是其他值.</li><li>workQueue: 传递任务的阻塞队列</li><li>threadFactory: 创建线程的工厂, 参与具体的创建线程工作.</li><li>RejectedExecutionHandler: 拒绝策略, 如果任务量超出公司的负荷了接下来怎么处理.</li></ol>\n<ul><li>AbortPolicy(): 超过负荷, 直接抛出异常.</li><li>CallerRunsPolicy(): 调用者负责处理</li><li>DiscardOldestPolicy(): 丢弃队列中最老的任务.</li><li>DiscardPolicy(): 丢弃新来的任务.</li></ul>\n</blockquote>\n<p>举个栗子：</p>\n<pre><code class=\"prism language-java\"><span class=\"token keyword\">package</span> <span class=\"token namespace\">demo2</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">import</span> <span class=\"token namespace\">java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>concurrent<span class=\"token punctuation\">.</span></span><span class=\"token operator\">*</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Test</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token class-name\">ExecutorService</span> pool <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ThreadPoolExecutor</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">TimeUnit</span><span class=\"token punctuation\">.</span>MILLISECONDS<span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SynchronousQueue</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Runnable</span><span class=\"token punctuation\">&gt;</span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Executors</span><span class=\"token punctuation\">.</span><span class=\"token function\">defaultThreadFactory</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ThreadPoolExecutor<span class=\"token punctuation\">.</span>AbortPolicy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n            pool<span class=\"token punctuation\">.</span><span class=\"token function\">submit</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Runnable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n                <span class=\"token annotation punctuation\">@Override</span>\n                <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n                    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n</code></pre>\n<h3><a id=\"_380\"></a>线程池的工作流程</h3>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\715473d1fbfe40e6b8ee06847c8127cc.png\"/></p>\n<h3><a id=\"_Semaphore_383\"></a>信号量 Semaphore</h3>\n<p><code>信号量, 用来表示 \"可用资源的个数\". 本质上就是一个计数器.</code><br/> 就象是停车场的展示牌: 当前有车位 100 个. 表示有 100 个可用资源.</p>\n<ol><li>当有车开进去的时候, 就相当于申请一个可用资源, 可用车位就 -1 (这个称为信号量的 P 操作)</li><li>当有车开出来的时候, 就相当于释放一个可用资源, 可用车位就 +1 (这个称为信号量的 V 操作)</li><li>如果计数器的值已经为 0 了, 还尝试申请资源, 就会阻塞等待, 直到有其他线程释放资源.</li></ol>\n<p><mark>Semaphore 的 PV 操作中的加减计数器操作都是原子的, 可以在多线程环境下直接使用.</mark></p>\n<p>举个栗子：</p>\n<ul><li>创建 Semaphore 示例, 初始化为 4, 表示有 4 个可用资源.</li><li>acquire 方法表示申请资源(P操作), release 方法表示释放资源(V操作)</li><li>创建 20 个线程, 每个线程都尝试申请资源, sleep 1秒之后, 释放资源. 观察程序的执行效果</li></ul>\n<pre><code class=\"prism language-java\"><span class=\"token keyword\">package</span> <span class=\"token namespace\">demo2</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">import</span> <span class=\"token namespace\">java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>concurrent<span class=\"token punctuation\">.</span></span><span class=\"token operator\">*</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Test</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token class-name\">Semaphore</span> semaphore <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Semaphore</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">Runnable</span> runnable <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Runnable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n            <span class=\"token annotation punctuation\">@Override</span>\n            <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n                <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{<!-- --></span>\n                    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"申请资源\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    semaphore<span class=\"token punctuation\">.</span><span class=\"token function\">acquire</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"我获取到资源了\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"我释放资源了\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    semaphore<span class=\"token punctuation\">.</span><span class=\"token function\">release</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n                    e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">20</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n            <span class=\"token class-name\">Thread</span> t <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span>runnable<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            t<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n</code></pre>\n<p><code>使用场景：</code></p>\n<blockquote>\n<p>使用信号量可以实现 “共享锁”, 比如某个资源允许 3 个线程同时使用, 那么就可以使用 P 操作作为加锁, V 操作作为解锁, 前三个线程的 P 操作都能顺利返回, 后续线程再进行 P 操作就会阻塞等待,直到前面的线程执行了 V 操作.</p>\n</blockquote>\n<hr/>\n<h2><a id=\"_435\"></a>多线程环境使用哈希表</h2>\n<h3><a id=\"Hashtable_436\"></a>Hashtable</h3>\n<p>只是简单的把关键方法加上了 synchronized 关键字<br/> <img alt=\"在这里插入图片描述\" src=\"image\\c541a6d196fd45e1b145f56e10962e22.png\"/></p>\n<blockquote>\n<ol><li>如果多线程访问同一个 Hashtable 就会直接造成锁冲突.</li><li>size 属性也是通过 synchronized 来控制同步, 也是比较慢的.</li><li>一旦触发扩容, 就由该线程完成整个扩容过程. 这个过程会涉及到大量的元素拷贝, 效率会非常低.</li></ol>\n</blockquote>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\75966358f9224254ace6b2ea687740e6.png\"/></p>\n<h3><a id=\"ConcurrentHashMap_448\"></a>ConcurrentHashMap</h3>\n<p><code>相比于 Hashtable 做出了一系列的改进和优化</code></p>\n<blockquote>\n<ol><li>读操作没有加锁(但是使用了 volatile 保证从内存读取结果), 只对写操作进行加锁. 加锁的方式仍然是是用 synchronized, 但是不是锁整个对象, 而是 “锁桶” (用每个链表的头结点作为锁对象), 大大降低了锁冲突的概率.</li><li>充分利用 CAS 特性. 比如 size 属性通过 CAS 来更新. 避免出现重量级锁的情况.</li><li>优化了扩容方式: 化整为零</li></ol>\n<ul><li>发现需要扩容的线程, 只需要创建一个新的数组, 同时只搬几个元素过去.</li><li>扩容期间, 新老数组同时存在.</li><li>后续每个来操作 ConcurrentHashMap 的线程, 都会参与搬家的过程. 每个操作负责搬运一小部分元素.</li><li>搬完最后一个元素再把老数组删掉.</li><li>这个期间, 插入只往新数组加.</li><li>这个期间, 查找需要同时查新数组和老数组</li></ul>\n</blockquote>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\d74706c8660e48dd852187601b91e95e.png\"/></p>\n<p><code>ConcurrentHashMap.每个哈希桶都有一把锁.只有两个线程访问的恰好是同一个哈希桶上的数据才出现锁冲突</code></p>\n<hr/>\n<h2><a id=\"_466\"></a>死锁</h2>\n<p>死锁是这样一种情形：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p>\n<ol><li>互斥：至少有一个资源必须处于非共享模式，即一次只有一个进程可使用。如果另一进程申请该资源，那么申请进程应等到该资源释放为止。</li><li>占有并等待：—个进程应占有至少一个资源，并等待另一个资源，而该资源为其他进程所占有。</li><li>非抢占：资源不能被抢占，即资源只能被进程在完成任务后自愿释放。</li><li>循环等待：有一组等待进程 {P0，P1，…，Pn}，P0 等待的资源为 P1 占有，P1 等待的资源为 P2 占有，……，Pn-1 等待的资源为 Pn 占有，Pn 等待的资源为 P0 占有。</li></ol>\n<p>举个栗子：</p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\7c1662cf0c9748078b800804830f9736.png\"/></p>\n<h3><a id=\"_477\"></a>如何避免死锁</h3>\n<p>复习一下：<br/> 死锁产生的四个必要条件：</p>\n<ol><li>互斥使用，即当资源被一个线程使用(占有)时，别的线程不能使用</li><li>不可抢占，资源请求者不能强制从资源占有者手中夺取资源，资源只能由资源占有者主动释放。</li><li>请求和保持，即当资源请求者在请求其他的资源的同时保持对原有资源的占有。</li><li>循环等待，即存在一个等待队列：P1占有P2的资源，P2占有P3的资源，P3占有P1的资源。这样就形成了一个等待环路。</li></ol>\n<p>当上述四个条件都成立的时候，便形成死锁。当然，死锁的情况下如果打破上述任何一个条件，便可让死锁消失。</p>\n<p><code>众所周知其中最容易破坏的就是 \"循环等待\".</code></p>\n<h3><a id=\"_489\"></a>破坏循环等待</h3>\n<p>最常用的一种死锁阻止技术就是锁排序. 假设有 N 个线程尝试获取 M 把锁, 就可以针对 M 把锁进行编号(1, 2, 3…M).<br/> N 个线程尝试获取锁的时候, 都按照固定的按编号由小到大顺序来获取锁. 这样就可以避免环路等待.</p>\n<blockquote>\n<p>可能环路等待示例：</p>\n</blockquote>\n<pre><code class=\"prism language-java\"><span class=\"token keyword\">package</span> <span class=\"token namespace\">demo2</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">import</span> <span class=\"token namespace\">java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">Hashtable</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token namespace\">java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>concurrent<span class=\"token punctuation\">.</span></span><span class=\"token operator\">*</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Test</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token class-name\">Object</span> lock1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">Object</span> lock2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">Thread</span> t1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n            <span class=\"token annotation punctuation\">@Override</span>\n            <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n                <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span>lock1<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n                    <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span>lock2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n                        <span class=\"token comment\">// do something...</span>\n                    <span class=\"token punctuation\">}</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n        t1<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">Thread</span> t2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n            <span class=\"token annotation punctuation\">@Override</span>\n            <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n                <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span>lock2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n                    <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span>lock1<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n                        <span class=\"token comment\">// do something...</span>\n                    <span class=\"token punctuation\">}</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n        t2<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n</code></pre>\n<blockquote>\n<p>不会产生环路等待的代码:(对比一下)<br/> <code>约定好先获取 lock1, 再获取 lock2 , 就不会环路等待.</code></p>\n</blockquote>\n<pre><code class=\"prism language-java\"><span class=\"token keyword\">package</span> <span class=\"token namespace\">demo2</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">import</span> <span class=\"token namespace\">java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">Hashtable</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token namespace\">java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>concurrent<span class=\"token punctuation\">.</span></span><span class=\"token operator\">*</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Test</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token class-name\">Object</span> lock1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">Object</span> lock2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">Thread</span> t1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n            <span class=\"token annotation punctuation\">@Override</span>\n            <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n                <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span>lock1<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n                    <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span>lock2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n                        <span class=\"token comment\">// do something...</span>\n                    <span class=\"token punctuation\">}</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n        t1<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">Thread</span> t2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n            <span class=\"token annotation punctuation\">@Override</span>\n            <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n                <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span>lock1<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n                    <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span>lock2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n                        <span class=\"token comment\">// do something...</span>\n                    <span class=\"token punctuation\">}</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n        t2<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n\n</code></pre>\n<h2><a id=\"_574\"></a>相关问题</h2>\n<h3><a id=\"Java_575\"></a>Java多线程是如何实现数据共享的?</h3>\n<p>JVM 把内存分成了这几个区域:<br/> 方法区, 堆区, 栈区, 程序计数器.<br/> 其中堆区这个内存区域是多个线程之间共享的.<br/> 只要把某个数据放到堆内存中, 就可以让多个线程都能访问到.</p>\n<h3><a id=\"Java_581\"></a>Java线程共有几种状态？状态之间怎么切换的？</h3>\n<ul><li>NEW: 安排了工作, 还未开始行动. 新创建的线程, 还没有调用 start 方法时处在这个状态.</li><li>RUNNABLE: 可工作的. 又可以分成正在工作中和即将开始工作. 调用 start 方法之后, 并正在CPU 上运行/在即将准备运行 的状态.</li><li>BLOCKED: 使用 synchronized 的时候, 如果锁被其他线程占用, 就会阻塞等待, 从而进入该状态.</li><li>WAITING: 调用 wait 方法会进入该状态.</li><li>TIMED_WAITING: 调用 sleep 方法或者 wait(超时时间) 会进入该状态.</li><li>TERMINATED: 工作完成了. 当线程 run 方法执行完毕后, 会处于这个状态.<br/> <img alt=\"在这里插入图片描述\" src=\"image\\703a47b96bde4126bd61ffad99265b9c.png\"/></li></ul>\n<h3><a id=\"ThreadRunnable_590\"></a>Thread和Runnable的区别和联系?</h3>\n<p>Thread 类描述了一个线程.<br/> Runnable 接口描述了一个任务.<br/> 在创建线程的时候需要指定线程完成的任务, 可以直接重写 Thread 的 run 方法, 也可以使用Runnable 来描述这个任务.</p>\n<h3><a id=\"start_595\"></a>多次start一个线程会怎么样？</h3>\n<p>第一次调用 start 可以成功调用.后续再调用 start 会抛出java.lang.IllegalThreadStateException 异常</p>\n<h3><a id=\"synchronized_598\"></a>有synchronized两个方法，两个线程分别同时用这个方法，请问会发生什么？</h3>\n<p>synchronized 加在非静态方法上, 相当于针对当前对象加锁.</p>\n<ul><li>如果这两个方法属于同一个实例:<br/> 线程1 能够获取到锁, 并执行方法. 线程2 会阻塞等待, 直到线程1 执行完毕, 释放锁, 线程2 获取到锁之后才能执行方法内容.</li><li>如果这两个方法属于不同实例:<br/> 两者能并发执行, 互不干扰.</li></ul>\n<h3><a id=\"_605\"></a>进程和线程的区别？</h3>\n<ul><li>进程是包含线程的. 每个进程至少有一个线程存在，即主线程。</li><li>进程和进程之间不共享内存空间. 同一个进程的线程之间共享同一个内存空间.</li><li>进程是系统分配资源的最小单位，线程是系统调度的最小单位。</li></ul>\n<p><code>最后奉上一张图：</code><br/> <img alt=\"在这里插入图片描述\" src=\"image\\0fcabb05fdd14fbba61e46c3dd230eb4.png\"/></p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}