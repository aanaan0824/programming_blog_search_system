{"blogid": "124963146", "writerAge": "码龄3年", "writerBlogNum": "1", "writerCollect": "5", "writerComment": "2", "writerFan": "1", "writerGrade": "1级", "writerIntegral": "16", "writerName": "依斜那歧", "writerProfileAdress": "writer_image\\profile_124963146.jpg", "writerRankTotal": "213801", "writerRankWeekly": "1260937", "writerThumb": "1", "writerVisitNum": "1076", "blog_read_count": "1076", "blog_time": "已于 2022-05-26 15:57:23 修改", "blog_title": "C# Winform 实现窗体无系统边框，但是具有系统边框的所有功能，同时保证控件不闪烁", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>本人新手，想写个上位机，窗口能够实现最小化，最大化，拖动，改变大小等常用功能，Winform窗体的FormBorderStyle设置成sizable即可实现，但是窗体有自带的边框，不好看且无法编辑，想去掉，网上查到几种方法，都尝试了，但是都有缺陷，不太满意，不过最终还是实现了。走了弯路，浪费了不少时间，在这分享一下，最后效果是没有冗余边框，菜单栏在顶部</p>\n<p><img alt=\"\" height=\"135\" src=\"image\\fb240f9a92c744e196da5a801a5e70bc.png\" width=\"1200\"/></p>\n<p></p>\n<p>网上查到有两个方法（方法一和方法二），都需要将FormBorderStyle设置成None，首先说一下窗体的最小化最大化关闭，以及移动，然后是太多嵌套表格后防止闪烁，最后是窗体缩放，可以按目录自取。</p>\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E7%AA%97%E4%BD%93%E6%9C%80%E5%A4%A7%E5%8C%96%E6%9C%80%E5%B0%8F%E5%8C%96%E5%92%8C%E5%85%B3%E9%97%AD-toc\" style=\"margin-left:0px;\"><a href=\"#%E7%AA%97%E4%BD%93%E6%9C%80%E5%A4%A7%E5%8C%96%E6%9C%80%E5%B0%8F%E5%8C%96%E5%92%8C%E5%85%B3%E9%97%AD\">窗体最大化最小化和关闭</a></p>\n<p id=\"%E7%AA%97%E4%BD%93%E7%A7%BB%E5%8A%A8-toc\" style=\"margin-left:0px;\"><a href=\"#%E7%AA%97%E4%BD%93%E7%A7%BB%E5%8A%A8\">窗体移动</a></p>\n<p id=\"%E6%96%B9%E6%B3%95%E4%B8%80-toc\" style=\"margin-left:0px;\"><a href=\"#%E6%96%B9%E6%B3%95%E4%B8%80\">解决闪烁问题</a></p>\n<p id=\"%E7%BC%A9%E6%94%BE-toc\" style=\"margin-left:0px;\"><a href=\"#%E7%BC%A9%E6%94%BE\">缩放</a></p>\n<p id=\"%E6%96%B9%E6%B3%95%E4%B8%80-toc\" style=\"margin-left:40px;\"><a href=\"#%E6%96%B9%E6%B3%95%E4%B8%80\">方法一</a></p>\n<p id=\"%C2%A0%E6%96%B9%E6%B3%95%E4%BA%8C-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A0%E6%96%B9%E6%B3%95%E4%BA%8C\"> 方法二</a></p>\n<p id=\"%E6%96%B9%E6%B3%95%E4%B8%89-toc\" style=\"margin-left:40px;\"><a href=\"#%E6%96%B9%E6%B3%95%E4%B8%89\">方法三</a></p>\n<p id=\"%C2%A0%E6%96%B9%E6%B3%95%E5%9B%9B-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A0%E6%96%B9%E6%B3%95%E5%9B%9B\"> 方法四</a></p>\n<p id=\"%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81\">完整代码</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<p></p>\n<h1 id=\"%E7%AA%97%E4%BD%93%E6%9C%80%E5%A4%A7%E5%8C%96%E6%9C%80%E5%B0%8F%E5%8C%96%E5%92%8C%E5%85%B3%E9%97%AD\">窗体最大化最小化和关闭</h1>\n<p>这个简单，直接放三个button，改背景图片，实现相应功能</p>\n<pre><code class=\"language-cs\">private void buttonClose_Click(object sender, EventArgs e)\n        {\n            this.Close();  //关闭窗口\n        }\n\nprivate void buttonMax_Click(object sender, EventArgs e)\n       {\n           if (this.WindowState == FormWindowState.Maximized)   //如果处于最大化，则还原\n           {\n               this.WindowState = FormWindowState.Normal;\n               Image backImage = Resources.最大化;\n               buttonMax.BackgroundImage = backImage;\n           }\n           else\n           {\n               this.WindowState = FormWindowState.Maximized;   //如果处于普通状态，则最大化\n               Image backImage = Resources.还原;\n               buttonMax.BackgroundImage = backImage;\n           }\n       }\n\nprivate void buttonMin_Click(object sender, EventArgs e)\n       {\n           this.WindowState = FormWindowState.Minimized;  //最小化\n       }\n\nprivate void Form1_SizeChanged(object sender, EventArgs e)\n       {\n           if (this.WindowState != FormWindowState.Maximized)\n               buttonMax.BackgroundImage = Resources.最大化;\n       }</code></pre>\n<p>最后的 Form1_SizeChanged的作用：当窗体最大化时，拖动窗体顶部窗体会变小，但是这种情况下最大化按钮的图标还是还原图标，所以写个方法刷新一下</p>\n<p>点击最大化按钮后会发现窗体变大后覆盖了整个屏幕，把任务栏都遮住了，解决这个问题的方法如下：</p>\n<pre><code class=\"language-cs\">//在窗体的Load事件中编写\nprivate void Form1_Load(object sender, EventArgs e)\n{\n     this.MaximizedBounds = Screen.PrimaryScreen.WorkingArea;\n}</code></pre>\n<p>图标可以到这里下载 ：<a class=\"has-card\" href=\"https://www.iconfont.cn/search/index?searchType=icon&amp;q=close&amp;page=1&amp;fills=&amp;tag=&amp;fromCollection=1\" title=\"iconfont-阿里巴巴矢量图标库\"><span class=\"link-card-box\"><span class=\"link-title\">iconfont-阿里巴巴矢量图标库</span><span class=\"link-link\"><img alt=\"\" class=\"link-link-icon\" src=\"image\\icon-default.png\"/>https://www.iconfont.cn/search/index?searchType=icon&amp;q=close&amp;page=1&amp;fills=&amp;tag=&amp;fromCollection=1</span></span></a></p>\n<h1 id=\"%E7%AA%97%E4%BD%93%E7%A7%BB%E5%8A%A8\">窗体移动</h1>\n<p> 我这里设置的是鼠标在菜单栏上按下时可以拖动，网上方法很多，下面这个是我认为最简单的</p>\n<pre><code class=\"language-cs\">//窗体移动\n[DllImport(\"user32.dll\")]\npublic static extern bool ReleaseCapture();\n\n[DllImport(\"user32.dll\")]\npublic static extern bool SendMessage(IntPtr hwnd, int wMsg, int wParam, int lParam);\n\nprivate void menuStrip1_MouseDown(object sender, MouseEventArgs e)\n     {\n         if (e.Clicks == 1)\n         {\n             //窗体移动\n             if (e.Button == MouseButtons.Left)\n             {\n                 ReleaseCapture(); //释放鼠标捕捉\n                 //发送左键点击的消息至该窗体(标题栏)\n                 SendMessage(this.Handle, 0xA1, 0x02, 0);\n             }\n         }\n     }</code></pre>\n<p>虽然不懂原理是啥，但是好用哈哈哈</p>\n<p>参考文章：<a class=\"has-card\" href=\"https://www.csdn.net/tags/MtTaAgzsNjk5ODYtYmxvZwO0O0OO0O0O.html\" title=\"winform自定义最大化 - CSDN\"><span class=\"link-card-box\"><span class=\"link-title\">winform自定义最大化 - CSDN</span><span class=\"link-link\"><img alt=\"\" class=\"link-link-icon\" src=\"image\\icon-default.png\"/>https://www.csdn.net/tags/MtTaAgzsNjk5ODYtYmxvZwO0O0OO0O0O.html</span></span></a></p>\n<h1 id=\"%E6%96%B9%E6%B3%95%E4%B8%80\">解决闪烁问题</h1>\n<p>为了让窗体在改变大小时各个部分能够更合理的自动分布，设计时用了很多表格，表格嵌套多了最大化最小化以及缩放窗体时就容易出现闪烁的情况，网上也有较多方法，下面这个是我试了之后有效果的</p>\n<p><img alt=\"\" height=\"180\" src=\"image\\1e6b5562b7ef4134bb7d2b34f15bc779.png\" width=\"184\"/></p>\n<p> 代码：</p>\n<pre><code class=\"language-cs\"> protected override CreateParams CreateParams   //防止改变窗口大小时控件闪烁\n        {\n            get\n            {\n                CreateParams cp = base.CreateParams;\n                cp.ExStyle |= 0x02000000; // Turn on WS_EX_COMPOSITED\n                return cp;\n            }\n        }</code></pre>\n<p>参考文章：<a class=\"has-card\" href=\"https://blog.csdn.net/qq_25465525/article/details/88739837?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-5-88739837-blog-117190950.pc_relevant_paycolumn_v3&amp;spm=1001.2101.3001.4242.4&amp;utm_relevant_index=8\" title=\"(1条消息) Winfrom窗体由于控件过多而闪烁的解决方法_路漫漫都是坑的博客-CSDN博客_winform 最大化 闪烁\"><span class=\"link-card-box\"><span class=\"link-title\">(1条消息) Winfrom窗体由于控件过多而闪烁的解决方法_路漫漫都是坑的博客-CSDN博客_winform 最大化 闪烁</span><span class=\"link-link\"><img alt=\"\" class=\"link-link-icon\" src=\"image\\icon-default.png\"/>https://blog.csdn.net/qq_25465525/article/details/88739837?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-5-88739837-blog-117190950.pc_relevant_paycolumn_v3&amp;spm=1001.2101.3001.4242.4&amp;utm_relevant_index=8</span></span></a></p>\n<p> 补充说明：</p>\n<p>FormBorderStyle设置成None，且添加了防闪烁代码后，最大化最小化窗口会显示不全，可以通过在Form1_SizeChanged方法中添加两个refersh()可以解决，但是视觉效果不好</p>\n<pre><code class=\"language-cs\">private void Form1_SizeChanged(object sender, EventArgs e)\n       {\n           if (this.WindowState != FormWindowState.Maximized)\n               buttonMax.BackgroundImage = Resources.最大化;\n           refresh();\n           refresh();\n       }</code></pre>\n<h1 id=\"%E7%BC%A9%E6%94%BE\">缩放</h1>\n<h2>方法一</h2>\n<p>自己编写程序，主要通过MouseDown，MouseUp，MouseMove三个方法和自定义ResizeWindow方法实现根据鼠标位置判断和实施对应的窗体缩放。</p>\n<pre><code class=\"language-cs\">        //窗体改变大小\n        private bool isMouseDown = false;  //表示鼠标当前是否处于按下状态，初始值为否 \n        MouseDirection direction = MouseDirection.None;  //表示拖动的方向，起始为None，表示不拖动\n        //private Point mPoint;  //鼠标坐标\n        private bool changeornot = false;  //是否是改变窗体大小，true为是，false为不是\n\n        //定义一个枚举，表示拖动方向，用于判断\n        public enum MouseDirection\n        {\n            HerizontalLeft,  //水平方向拖动，只改变窗体的宽度\n            HerizontalRight,\n            VerticalTop,  //垂直方向拖动，只改变窗体的高度 \n            VerticalBottom,\n            DecliningLefttop,  //倾斜方向，同时改变窗体的宽度和高度\n            DecliningLeftbottom,\n            DecliningRighttop,\n            DecliningRightbottom,\n            None  //不做标志，即不拖动窗体改变大小\n        }\n        //鼠标在窗体内按下时获取鼠标的位置，并设置按下状态为真\n        private void Form1_MouseDown(object sender, MouseEventArgs e)\n        {\n            //mPoint = new Point(e.X, e.Y);\n            isMouseDown = true;\n        }\n        // 鼠标弹起，不再改变窗体尺寸\n        private void Form1_MouseUp(object sender, MouseEventArgs e)\n        {\n            isMouseDown = false;\n            direction = MouseDirection.None;\n        }\n        //鼠标移动过程中，坐标时刻在改变，根据不同位置改变拖动方向、鼠标样式和changeornot的状态\n        private void Form1_MouseMove(object sender, MouseEventArgs e)\n        {\n            if (isMouseDown &amp;&amp; direction != MouseDirection.None) //满足条件则直接执行改变窗口大小的方法\n            {\n                ResizeWindow();\n                return;\n            }\n            //当鼠标移动时横坐标距离窗体左边缘5像素以内且纵坐标距离上边缘也在5像素以内时\n            if (e.Location.X &lt;= 5 &amp;&amp; e.Location.Y &lt;= 5)\n            {\n                this.Cursor = Cursors.SizeNWSE;   //光标变为右下倾斜的箭头形状\\\n                direction = MouseDirection.DecliningLefttop;\n                changeornot = true;\n            }\n            //左下\n            else if (e.Location.X &lt;= 5 &amp;&amp; e.Location.Y &gt;= this.Height - 5)\n            {\n                this.Cursor = Cursors.SizeNESW;   //光标变为右上倾斜的箭头形状/\n                direction = MouseDirection.DecliningLeftbottom;\n                changeornot = true;\n            }\n            //右上\n            else if (e.Location.X &gt;= this.Width - 5 &amp;&amp; e.Location.Y &lt;= 5)\n            {\n                this.Cursor = Cursors.SizeNESW;   //光标变为右上倾斜的箭头形状/\n                direction = MouseDirection.DecliningRighttop;\n                changeornot = true;\n            }\n            //右下\n            else if (e.Location.X &gt;= this.Width - 5 &amp;&amp; e.Location.Y &gt; this.Height - 5)\n            {\n                this.Cursor = Cursors.SizeNWSE;   //光标变为右下倾斜的箭头形状\\\n                direction = MouseDirection.DecliningRightbottom;\n                changeornot = true;\n            }\n            //左\n            else if (e.Location.X &lt;= 5)\n            {\n                this.Cursor = Cursors.SizeWE;  //将光标变为水平的箭头形状\n                direction = MouseDirection.HerizontalLeft;\n                changeornot = true;\n            }\n            //右\n            else if (e.Location.X &gt;= this.Width - 5)\n            {\n                this.Cursor = Cursors.SizeWE;  //将光标变为水平的箭头形状\n                direction = MouseDirection.HerizontalRight;\n                changeornot = true;\n            }\n            //上\n            else if (e.Location.Y &lt;= 1)\n            {\n                this.Cursor = Cursors.SizeNS;  //将光标变为竖直的箭头形状\n                direction = MouseDirection.VerticalTop;\n                changeornot = true;\n            }\n            //下\n            else if (e.Location.Y &gt;= this.Height - 5)\n            {\n                this.Cursor = Cursors.SizeNS;   //将光标变为竖直的箭头形状\n                direction = MouseDirection.VerticalBottom;\n                changeornot = true;\n            }\n            //否则，其他窗体区域，鼠标星座均为单向箭头（默认）\n            else\n            {\n                this.Cursor = Cursors.Arrow;\n                direction = MouseDirection.None;\n                changeornot = false;\n            }\n        }\n        private void ResizeWindow()\n        {\n            //MousePosition的参考点是屏幕的左上角，表示鼠标当前相对于屏幕左上角的坐标。\n            //this.left和this.top的参考点也是屏幕，属性MousePosition是程序的重点\n            if (direction == MouseDirection.DecliningLefttop)  //左上\n            {\n                this.Cursor = Cursors.SizeNWSE;    //光标为右下倾斜的箭头形状\\\n                this.Width = this.Right - MousePosition.X;   //改变窗体宽和高\n                this.Height = this.Bottom - MousePosition.Y;\n                this.Location = new Point(MousePosition.X, MousePosition.Y);  //改变窗体位置\n            }\n            else if (direction == MouseDirection.DecliningLeftbottom)  //左下\n            {\n                this.Cursor = Cursors.SizeNESW;\n                this.Location = new Point(MousePosition.X, this.Top);\n                this.Width = this.Right - MousePosition.X;\n                this.Height = MousePosition.Y - this.Top;\n            }\n            else if (direction == MouseDirection.DecliningRighttop)   //右上\n            {\n                this.Cursor = Cursors.SizeNESW;\n                this.Location = new Point(this.Left, MousePosition.Y);\n                this.Width = MousePosition.X - this.Left;\n                this.Height = this.Bottom - MousePosition.Y;\n            }\n            else if (direction == MouseDirection.DecliningRightbottom)  //右下\n            {\n                this.Cursor = Cursors.SizeNWSE;  //不改变窗体位置\n                this.Width = MousePosition.X - this.Left;\n                this.Height = MousePosition.Y - this.Top;\n            }\n            else if (direction == MouseDirection.HerizontalLeft)   //左\n            {\n                this.Cursor = Cursors.SizeWE;\n                this.Location = new Point(MousePosition.X, this.Top);\n                this.Width = this.Right - MousePosition.X;\n            }\n            else if (direction == MouseDirection.HerizontalRight)   //右\n            {\n                this.Cursor = Cursors.SizeWE;\n                this.Width = MousePosition.X - this.Left;\n            }\n            else if (direction == MouseDirection.VerticalTop)   //上\n            {\n                this.Cursor = Cursors.SizeNS;\n                this.Location = new Point(this.Left, MousePosition.Y);\n                this.Height = this.Bottom - MousePosition.Y;\n            }\n            else if (direction == MouseDirection.VerticalBottom)   //下\n            {\n                this.Cursor = Cursors.SizeNS;\n                this.Height = MousePosition.Y - this.Top;\n            }\n            //即使鼠标按下，但是不在窗口右和下边缘，那么也不能改变窗口大小\n            else\n            {\n                this.Cursor = Cursors.Arrow;\n            }\n        }</code></pre>\n<p> 实际效果是能缩放，但是闪烁卡顿严重</p>\n<p>参考文章：<a class=\"has-card\" href=\"https://blog.csdn.net/qq_37341685/article/details/122220117\" title=\"(1条消息) winform无边框在panel上拖动窗口位置，改变窗口大小_傲娇萌主的博客-CSDN博客_winform窗体可拖动变大小属性\"><span class=\"link-card-box\"><span class=\"link-title\">(1条消息) winform无边框在panel上拖动窗口位置，改变窗口大小_傲娇萌主的博客-CSDN博客_winform窗体可拖动变大小属性</span><span class=\"link-link\"><img alt=\"\" class=\"link-link-icon\" src=\"image\\icon-default.png\"/>https://blog.csdn.net/qq_37341685/article/details/122220117</span></span></a></p>\n<p><br/><a class=\"has-card\" href=\"https://zhuanlan.zhihu.com/p/505185678\" title=\"winform 设置无边框后的窗口大小调整 - 知乎 (zhihu.com)\"><span class=\"link-card-box\"><span class=\"link-title\">winform 设置无边框后的窗口大小调整 - 知乎 (zhihu.com)</span><span class=\"link-link\"><img alt=\"\" class=\"link-link-icon\" src=\"image\\icon-default.png\"/>https://zhuanlan.zhihu.com/p/505185678</span></span></a></p>\n<h2 id=\"%C2%A0%E6%96%B9%E6%B3%95%E4%BA%8C\"> 方法二</h2>\n<p>直接上代码</p>\n<pre><code class=\"language-cs\">//窗体缩放\n        const int Guying_HTLEFT = 10;\n        const int Guying_HTRIGHT = 11;\n        const int Guying_HTTOP = 12;\n        const int Guying_HTTOPLEFT = 13;\n        const int Guying_HTTOPRIGHT = 14;\n        const int Guying_HTBOTTOM = 15;\n        const int Guying_HTBOTTOMLEFT = 0x10;\n        const int Guying_HTBOTTOMRIGHT = 17;\n        protected override void WndProc(ref Message m)\n        {\n            switch (m.Msg)\n            {\n                case 0x0084:\n                    base.WndProc(ref m);\n                    Point vPoint = new Point((int)m.LParam &amp; 0xFFFF,\n                        (int)m.LParam &gt;&gt; 16 &amp; 0xFFFF);\n                    vPoint = PointToClient(vPoint);\n                    if (vPoint.X &lt;= 5)\n                        if (vPoint.Y &lt;= 5)\n                            m.Result = (IntPtr)Guying_HTTOPLEFT;\n                        else if (vPoint.Y &gt;= ClientSize.Height - 5)\n                            m.Result = (IntPtr)Guying_HTBOTTOMLEFT;\n                        else m.Result = (IntPtr)Guying_HTLEFT;\n                    else if (vPoint.X &gt;= ClientSize.Width - 5)\n                        if (vPoint.Y &lt;= 5)\n                            m.Result = (IntPtr)Guying_HTTOPRIGHT;\n                        else if (vPoint.Y &gt;= ClientSize.Height - 5)\n                            m.Result = (IntPtr)Guying_HTBOTTOMRIGHT;\n                        else m.Result = (IntPtr)Guying_HTRIGHT;\n                    else if (vPoint.Y &lt;= 2)\n                        m.Result = (IntPtr)Guying_HTTOP;\n                    else if (vPoint.Y &gt;= ClientSize.Height - 5)\n                        m.Result = (IntPtr)Guying_HTBOTTOM;\n                    break;\n                default:\n                    base.WndProc(ref m);\n                    break;\n            }\n        }</code></pre>\n<p>其方法与一类似，通过判断鼠标位置实施不同缩放，但是缩放的方法不是自己写的，这个方法缩放会流畅很多，和有边框的窗口差不多，但是因为FormBorderStyle设置成None，没有边框，缩放过程中部分控件又会轻微闪烁（有防闪烁代码的基础上）。一般使用边框附近5个像素，因为我的菜单栏距顶部只有两个像素，设置成5会失效，所以上方缩放我设置的2 （else if (vPoint.Y &lt;= 2)）</p>\n<p><a class=\"has-card\" href=\"https://www.cnblogs.com/landptf/p/5068523.html\" title=\"Winform自定义无边框窗体 - landptf - 博客园 (cnblogs.com)\"><span class=\"link-card-box\"><span class=\"link-title\">Winform自定义无边框窗体 - landptf - 博客园 (cnblogs.com)</span><span class=\"link-link\"><img alt=\"\" class=\"link-link-icon\" src=\"image\\icon-default.png\"/>https://www.cnblogs.com/landptf/p/5068523.html</span></span></a></p>\n<h2 id=\"%E6%96%B9%E6%B3%95%E4%B8%89\">方法三</h2>\n<p>设置FormBorderStyle设置成Sizable，但是窗口样式中controlbox设置成false，且Form1的Text设置为空，效果如下。这样能够拥有边框的缩放功能，没有一点卡顿和闪烁，但是顶端有一个白色窄边，其他三边没有，但是最大化窗口时其他三边会有缝隙，也就是说边框虽然不显示，但还是在。</p>\n<p><img alt=\"\" height=\"113\" src=\"image\\957a6b0a53064e3f8352053802ee0c25.png\" width=\"284\"/></p>\n<p> <img alt=\"\" height=\"128\" src=\"image\\2365f522c6b34343bab27a13e5804eb4.png\" width=\"1200\"/></p>\n<h2 id=\"%C2%A0%E6%96%B9%E6%B3%95%E5%9B%9B\"> 方法四</h2>\n<p>此方法可以说是完美解决问题，经过方法二和方法三的折腾，我发现可以将窗口的FormBorderStyle设置成FixedSingle（3D也行，看个人审美），然后controlbox设置成false，且Text设置为空，此时窗口拥有系统的边框，不占位置，能够使用系统自带窗体的功能（比如点击任务栏图标可以最小化和还原），且显示正常（最大化最小化不会有显示缺陷），但是窗口不能缩放，再将方法二的代码加上，就完美解决了</p>\n<p>适合新手使用</p>\n<h1 id=\"%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81\">完整代码（需要按照方法四设置窗体）</h1>\n<pre><code class=\"language-cs\">#region 窗体设置\n        private void buttonClose_Click(object sender, EventArgs e)\n        {\n            this.Close();  //关闭窗口\n        }\n\n        private void buttonMax_Click(object sender, EventArgs e)\n        {\n            if (this.WindowState == FormWindowState.Maximized)   //如果处于最大化，则还原\n            {\n                this.WindowState = FormWindowState.Normal;\n                Image backImage = Resources.最大化;\n                buttonMax.BackgroundImage = backImage;\n            }\n            else\n            {\n                this.WindowState = FormWindowState.Maximized;   //如果处于普通状态，则最大化\n                Image backImage = Resources.还原;\n                buttonMax.BackgroundImage = backImage;\n            }\n        }\n\n        private void buttonMin_Click(object sender, EventArgs e)\n        {\n            this.WindowState = FormWindowState.Minimized;  //最小化\n        }\n\n        private void Form1_SizeChanged(object sender, EventArgs e)\n        {\n            if (this.WindowState != FormWindowState.Maximized)\n                buttonMax.BackgroundImage = Resources.最大化;\n        }\n\n        protected override CreateParams CreateParams   //防止改变窗口大小时控件闪烁\n        {\n            get\n            {\n                CreateParams cp = base.CreateParams;\n                cp.ExStyle |= 0x02000000; // Turn on WS_EX_COMPOSITED\n                return cp;\n            }\n        }\n\n        //窗体移动\n        [DllImport(\"user32.dll\")]\n        public static extern bool ReleaseCapture();\n\n        [DllImport(\"user32.dll\")]\n        public static extern bool SendMessage(IntPtr hwnd, int wMsg, int wParam, int lParam);\n\n        private void menuStrip1_MouseDown(object sender, MouseEventArgs e)\n        {\n            if (e.Clicks == 1)\n            {\n                //窗体移动\n                if (e.Button == MouseButtons.Left)\n                {\n                    ReleaseCapture(); //释放鼠标捕捉\n                    //发送左键点击的消息至该窗体(标题栏)\n                    SendMessage(this.Handle, 0xA1, 0x02, 0);\n                }\n            }\n        }\n\n        //窗体缩放\n        const int Guying_HTLEFT = 10;\n        const int Guying_HTRIGHT = 11;\n        const int Guying_HTTOP = 12;\n        const int Guying_HTTOPLEFT = 13;\n        const int Guying_HTTOPRIGHT = 14;\n        const int Guying_HTBOTTOM = 15;\n        const int Guying_HTBOTTOMLEFT = 0x10;\n        const int Guying_HTBOTTOMRIGHT = 17;\n        protected override void WndProc(ref Message m)\n        {\n            switch (m.Msg)\n            {\n                case 0x0084:\n                    base.WndProc(ref m);\n                    Point vPoint = new Point((int)m.LParam &amp; 0xFFFF,\n                        (int)m.LParam &gt;&gt; 16 &amp; 0xFFFF);\n                    vPoint = PointToClient(vPoint);\n                    if (this.WindowState != FormWindowState.Normal)\n                        break;  //源代码在窗体最大化状态下，鼠标移到窗口边缘也会出现拖动标识，添加这句代码可以避免\n                    if (vPoint.X &lt;= 5)\n                        if (vPoint.Y &lt;= 5)\n                            m.Result = (IntPtr)Guying_HTTOPLEFT;\n                        else if (vPoint.Y &gt;= ClientSize.Height - 5)\n                            m.Result = (IntPtr)Guying_HTBOTTOMLEFT;\n                        else m.Result = (IntPtr)Guying_HTLEFT;\n                    else if (vPoint.X &gt;= ClientSize.Width - 5)\n                        if (vPoint.Y &lt;= 5)\n                            m.Result = (IntPtr)Guying_HTTOPRIGHT;\n                        else if (vPoint.Y &gt;= ClientSize.Height - 5)\n                            m.Result = (IntPtr)Guying_HTBOTTOMRIGHT;\n                        else m.Result = (IntPtr)Guying_HTRIGHT;\n                    else if (vPoint.Y &lt;= 2)\n                        m.Result = (IntPtr)Guying_HTTOP;\n                    else if (vPoint.Y &gt;= ClientSize.Height - 5)\n                        m.Result = (IntPtr)Guying_HTBOTTOM;\n                    break;\n                default:\n                    base.WndProc(ref m);\n                    break;\n            }\n        }\n        #endregion</code></pre>\n<p></p>\n</div>\n</div>"}