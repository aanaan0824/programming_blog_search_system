{"blogid": "126633078", "writerAge": "码龄5年", "writerBlogNum": "305", "writerCollect": "3844", "writerComment": "486", "writerFan": "1301", "writerGrade": "7级", "writerIntegral": "10262", "writerName": "龚建波", "writerProfileAdress": "writer_image\\profile_126633078.jpg", "writerRankTotal": "1344", "writerRankWeekly": "6748", "writerThumb": "858", "writerVisitNum": "796859", "blog_read_count": "175", "blog_time": "于 2022-08-31 22:43:38 发布", "blog_title": "《QDebug 2022年8月》", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h1>一、Qt Widgets 问题交流</h1>\n<h3>1.QWidget鼠标事件穿透</h3>\n<p>对于一些透明或者半透明的QWidget，可能需要点击其下方的按钮或其他组件，但是QWidget本身是会接收这些鼠标事件的，需要一些额外的处理。下面是百度到的一些方法：</p>\n<p>方式A.设置setAttribute(Qt::WA_TransparentForMouseEvents, true)，设置之后该QWidget对象树就不再处理鼠标事件。最大的缺点就是不仅该QWidget不响应鼠标事件，它上面的其他组件也没法响应鼠标事件了。</p>\n<p>方式B.setMask把底部要点击的地方抠出来，缺点是抠出来的地方就成了全透明，不适合半透明的需求：</p>\n<pre><code class=\"language-cpp\">    QRegion reg(ui-&gt;widget-&gt;rect());\n    //bottom为被widget挡住的按钮\n    auto btn_area=ui-&gt;btnBottom-&gt;geometry();\n    btn_area.moveTo(btn_area.topLeft()-ui-&gt;widget-&gt;geometry().topLeft());\n    reg-=QRegion(btn_area);\n    ui-&gt;widget-&gt;setMask(reg);</code></pre>\n<p>方法C. QWdidget鼠标事件处理先判断坐标点下方是否有其他组件，有则传递下去：</p>\n<pre><code class=\"language-cpp\">void mouseMoveEvent(QMouseEvent *event){\n    transMouseEvents(event);\n}\n\nvoid mousePressEvent(QMouseEvent *event){\n    transMouseEvents(event);\n}\n\nvoid mouseReleaseEvent(QMouseEvent *event){\n    transMouseEvents(event);\n}\n\nvoid mouseDoubleClickEvent(QMouseEvent *event){\n    transMouseEvents(event);\n}\n\nvoid transMouseEvents(QMouseEvent *event){\n    if (this-&gt;parentWidget()) {    \n        this-&gt;setAttribute(Qt::WA_TransparentForMouseEvents, true);\n        QPoint pt = this-&gt;mapTo(this-&gt;parentWidget(), event-&gt;pos());\n        QWidget *wid = this-&gt;parentWidget()-&gt;childAt(pt);\n        if (wid) {\n            pt = wid-&gt;mapFrom(this-&gt;parentWidget(), pt);\n            QMouseEvent *mEvent = new QMouseEvent(event-&gt;type(), pt, event-&gt;button(), event-&gt;buttons(), event-&gt;modifiers());\n            QApplication::postEvent(wid, mEvent);\n        }\n        this-&gt;setAttribute(Qt::WA_TransparentForMouseEvents, false);\n    }\n}</code></pre>\n<p>参考：<a href=\"https://zhuanlan.zhihu.com/p/96773017\" title=\"QT 鼠标穿透 - 知乎\">QT 鼠标穿透 - 知乎</a> </p>\n<h1>二、Qt Quick 问题交流</h1>\n<h3>1.打包命令问题</h3>\n<p>百度搜（QML打包），找到的结果一般都是这样的：</p>\n<pre><code class=\"language-cpp\">windeployqt 程序.exe --qmldir C:\\Qt\\Qt5.15.2\\5.15.2\\msvc2019_64\\qml\n</code></pre>\n<p>这些博文上，--qmldir的参数一般都是指向Qt安装目录，但是通过查看文档可知，qmldir应该指向项目源码的qml目录，以查找导入了哪些模块，qmlimport才是用来指向安装路径或者其他依赖模块路径的。</p>\n<p><img alt=\"\" height=\"70\" src=\"image\\1525c31e364246948b0eacf13f0f8cdb.png\" width=\"442\"/></p>\n<p>文档：<a href=\"https://doc.qt.io/qt-5/windows-deployment.html\" title=\"https://doc.qt.io/qt-5/windows-deployment.html\">https://doc.qt.io/qt-5/windows-deployment.html</a> </p>\n<h1>三、其他</h1>\n<h3>1.QAXObject在WPS环境下读取Excel的UsedRange.Value为空</h3>\n<p>一开始测试MS Office时如下的代码可以正常的读取到UsedRange的表格内容：</p>\n<pre><code class=\"language-cpp\">QAxObject *used_range = work_sheet-&gt;querySubObject(\"UsedRange\");\nauto range_data = used_range-&gt;property(\"Value\").toList();</code></pre>\n<p>但是在测试WPS时，读取到的值是空的，修改为dynamicCall后就能正常读取了：</p>\n<pre><code class=\"language-cpp\">QAxObject *used_range = work_sheet-&gt;querySubObject(\"UsedRange\");\nauto range_data = used_range-&gt;dynamicCall(\"Value()\").toList();</code></pre>\n<p>完整的测试代码如下：</p>\n<pre><code class=\"language-cpp\">void parseExcel()\n{\n    const QString filepath = QFileDialog::getOpenFileName(this);\n    if(filepath.isEmpty()){\n        qDebug()&lt;&lt;\"filepath is empty\";\n        return;\n    }\n\n    QSharedPointer&lt;QAxObject&gt; excel{new QAxObject};\n    //分别尝试WPS和MS Office的excel组件\n    if(!excel-&gt;setControl(\"KET.Application\" )){\n        qDebug() &lt;&lt; \"open wps excel failed\";\n        if(!excel-&gt;setControl(\"Excel.Application\")){\n            qDebug() &lt;&lt; \"open office excel failed\";\n            return;\n        }\n    }\n\n    qDebug()&lt;&lt;\"excel open\";\n    auto scope = qScopeGuard([=]{\n        qDebug()&lt;&lt;\"excel quit\";\n        //退出时关闭，不然excel进程没退出\n        excel-&gt;dynamicCall(\"Quit()\");\n    });\n    Q_UNUSED(scope)\n\n    excel-&gt;setProperty(\"Visible\", false);\n    excel-&gt;setProperty(\"EnableEvents\", false);\n    excel-&gt;setProperty(\"DisplayAlerts\", false);\n    QAxObject *work_books = excel-&gt;querySubObject(\"WorkBooks\");\n    if(!work_books){\n        qDebug()&lt;&lt;\"query WorkBooks error\";\n        return;\n    }\n    work_books-&gt;dynamicCall(\"Open(const QString&amp;)\", filepath);\n    QAxObject *active_book = excel-&gt;querySubObject(\"ActiveWorkBook\");\n    if(!active_book){\n        qDebug()&lt;&lt;\"query ActiveWorkBook error\";\n        return;\n    }else{\n        qDebug()&lt;&lt;\"book open\";\n        auto book_scope = qScopeGuard([=]{\n            qDebug()&lt;&lt;\"book close\";\n            //bool是否保存修改\n            active_book-&gt;dynamicCall(\"Close(Boolean)\", false);\n        });\n        Q_UNUSED(book_scope)\n\n        QAxObject *work_sheet = active_book-&gt;querySubObject(\"WorkSheets(int)\", 1);\n        if(!work_sheet){\n            qDebug()&lt;&lt;\"query WorkSheets error\";\n            return;\n        }\n        QAxObject *used_range = work_sheet-&gt;querySubObject(\"UsedRange\");\n        if(!used_range){\n            qDebug()&lt;&lt;\"query UsedRange error\";\n            return;\n        }\n        //全部读取，范围是上下左右最边上的数据所围城的矩形区域\n        auto range_data = used_range-&gt;dynamicCall(\"Value()\").toList();\n        qDebug()&lt;&lt;\"range data:\"&lt;&lt;range_data;\n    }\n}</code></pre>\n<p></p>\n</div>\n</div>"}