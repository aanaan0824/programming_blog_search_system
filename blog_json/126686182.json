{"blogid": "126686182", "writerAge": "码龄2年", "writerBlogNum": "92", "writerCollect": "209", "writerComment": "184", "writerFan": "530", "writerGrade": "4级", "writerIntegral": "1547", "writerName": "江南无故人", "writerProfileAdress": "writer_image\\profile_126686182.jpg", "writerRankTotal": "12953", "writerRankWeekly": "7228", "writerThumb": "269", "writerVisitNum": "55001", "blog_read_count": "92", "blog_time": "于 2022-09-05 10:10:01 发布", "blog_title": "Linux常用锁", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atelier-sulphurpool-light\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p></p>\n<div class=\"toc\">\n<h3>Linux常用锁</h3>\n<ul><li><a href=\"#_1\">互斥锁</a></li><li><a href=\"#_10\">读写锁</a></li><li><a href=\"#_23\">自旋锁</a></li></ul>\n</div>\n<p></p>\n<h1><a id=\"_1\"></a>互斥锁</h1>\n<p><a href=\"https://blog.csdn.net/sqjddb/article/details/124906644?csdn_share_tail=%7B%22type%22:%22blog%22,%22rType%22:%22article%22,%22rId%22:%22124906644%22,%22source%22:%22sqjddb%22%7D\">参考前文🔗</a></p>\n<p>递归锁：在同一个线程可以多次获取同一个锁，不会产生死锁；</p>\n<p>非递归锁：在同一个线程中，加锁后不可以再次获取该锁，如果获取可能产生死锁；</p>\n<p>Linux的互斥量pthread_mutex_t是非递归锁，但是可以在创建互斥量时设置PTHREAD_MUTEX_RECURSIVE属性，将pthread_mutex_t设置为递归锁。</p>\n<h1><a id=\"_10\"></a>读写锁</h1>\n<p>读写锁有三种状态：读模式下加锁、写模式下加锁、不加锁。写模式下的读写锁一次只有一个线程可以占有，读模式下的读写锁多个线程可以同时占有。<br/> 写加锁状态时，所有试图加锁的线程都会被阻塞。<br/> 读加锁状态时，所有试图在读模式下加锁的线程都可以得到访问权，但是希望在写模式下加锁的线程会被阻塞，直到所有读锁释放<br/> 为了避免写模式锁请求一直不能满足，大多数操作系统会阻塞随后的读模式加锁请求。</p>\n<p><em><strong>互斥锁和读写锁对比：</strong></em></p>\n<p>互斥锁只有锁住和不加锁的状态，而且一次只有一个线程可以加锁<br/> 读写锁和互斥锁有些类似，但是并行性更高，有三种状态如上。<br/> 读写锁适合的场景就是对临界资源读的次数远大于写的次数的情况。</p>\n<h1><a id=\"_23\"></a>自旋锁</h1>\n<p>自旋锁就是某个线程想要进入临界区时，如果临界区已经被加锁，那么自旋锁并不会阻塞线程，而是轮询检测自旋锁的状态，也就是自旋。本质上是为了减少线程阻塞挂起再唤醒产生的消耗。在自旋期间，CPU不能做其他事，所以自旋锁适合临界区的代码非常短的场景，开销会非常小。内核的一些数据结构中自旋锁被广泛的使用。</p>\n<p><em><strong>互斥锁和自旋锁对比：</strong></em><br/> 实际中很多互斥量的实现其实非常高效，比如有些互斥量在申请锁的时候会自旋一段时间，自旋时间超过某个阈值才会休眠。在之前使用自旋锁的地方使用这些高效的互斥量性能也不差。还有由于现代处理器的进步，上下文切换也越来越快。</p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}