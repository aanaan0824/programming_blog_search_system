{"blogid": "125850482", "writerAge": "码龄1年", "writerBlogNum": "103", "writerCollect": "4570", "writerComment": "4376", "writerFan": "6331", "writerGrade": "7级", "writerIntegral": "13366", "writerName": "@每天都要敲代码", "writerProfileAdress": "writer_image\\profile_125850482.jpg", "writerRankTotal": "799", "writerRankWeekly": "90", "writerThumb": "4851", "writerVisitNum": "80906", "blog_read_count": "690", "blog_time": "已于 2022-08-03 17:23:47 修改", "blog_title": "深入理解Java IO流（第一篇）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<blockquote>\n<p>✅作者简介：大家好我是@每天都要敲代码，一位材料转码农的选手，希望一起努力，一起进步！<br/> 📃个人主页：<a href=\"https://blog.csdn.net/m0_61933976?spm=1010.2135.3001.5421\" title=\"@每天都要敲代码的个人主页\">@每天都要敲代码的个人主页</a><br/> 💬推荐一款模拟面试、刷题神器，从基础到大厂面试题👉<a href=\"https://www.nowcoder.com/link/pc_csdncpt_mtdyqdm_c\" title=\"点击跳转刷题网站进行注册学习\">点击跳转刷题网站进行注册学习</a></p>\n</blockquote>\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%F0%9F%A5%85IO%E6%B5%81%E7%90%86%E8%AE%BA%E6%A6%82%E8%BF%B0-toc\" style=\"margin-left:0px;\"><a href=\"#%F0%9F%A5%85IO%E6%B5%81%E7%90%86%E8%AE%BA%E6%A6%82%E8%BF%B0\">🥅IO流理论概述</a></p>\n<p id=\"1.%E4%BB%80%E4%B9%88%E6%98%AFIO-toc\" style=\"margin-left:80px;\"><a href=\"#1.%E4%BB%80%E4%B9%88%E6%98%AFIO\">1.什么是IO</a></p>\n<p id=\"2.IO%E6%B5%81%E7%9A%84%E5%88%86%E7%B1%BB-toc\" style=\"margin-left:80px;\"><a href=\"#2.IO%E6%B5%81%E7%9A%84%E5%88%86%E7%B1%BB\">2.IO流的分类</a></p>\n<p id=\"3.%E6%B5%81%E7%9A%84%E5%9B%9B%E5%A4%A7%E5%AE%B6%E6%97%8F-toc\" style=\"margin-left:80px;\"><a href=\"#3.%E6%B5%81%E7%9A%84%E5%9B%9B%E5%A4%A7%E5%AE%B6%E6%97%8F\">3.流的四大家族</a></p>\n<p id=\"4.%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1%E7%9A%84%E5%8D%81%E5%85%AD%E4%B8%AA%E6%B5%81-toc\" style=\"margin-left:80px;\"><a href=\"#4.%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1%E7%9A%84%E5%8D%81%E5%85%AD%E4%B8%AA%E6%B5%81\">4.需要掌握的十六个流</a></p>\n<p id=\"%F0%9F%A5%85%E5%AD%97%E8%8A%82%E8%BE%93%E5%85%A5%E6%B5%81FileInputStream-toc\" style=\"margin-left:0px;\"><a href=\"#%F0%9F%A5%85%E5%AD%97%E8%8A%82%E8%BE%93%E5%85%A5%E6%B5%81FileInputStream\">🥅字节输入流FileInputStream</a></p>\n<p id=\"1.FileInputStream%E5%88%9D%E6%AD%A5%E7%90%86%E8%A7%A3-toc\" style=\"margin-left:80px;\"><a href=\"#1.FileInputStream%E5%88%9D%E6%AD%A5%E7%90%86%E8%A7%A3\">1.FileInputStream初步理解</a></p>\n<p id=\"2.FileInputStream%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-toc\" style=\"margin-left:80px;\"><a href=\"#2.FileInputStream%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95\">2.FileInputStream常用方法</a></p>\n<p id=\"%F0%9F%A5%85%E5%AD%97%E8%8A%82%E8%BE%93%E5%87%BA%E6%B5%81FileOutputStream-toc\" style=\"margin-left:0px;\"><a href=\"#%F0%9F%A5%85%E5%AD%97%E8%8A%82%E8%BE%93%E5%87%BA%E6%B5%81FileOutputStream\">🥅字节输出流FileOutputStream</a></p>\n<p id=\"%F0%9F%A5%85%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9D-toc\" style=\"margin-left:0px;\"><a href=\"#%F0%9F%A5%85%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9D\">🥅任意文件拷贝</a></p>\n<p id=\"%F0%9F%A5%85FileReader%20%26%26%20FileWriter%20%26%26%20%E6%99%AE%E9%80%9A%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9D-toc\" style=\"margin-left:0px;\"><a href=\"#%F0%9F%A5%85FileReader%20%26%26%20FileWriter%20%26%26%20%E6%99%AE%E9%80%9A%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9D\">🥅FileReader &amp;&amp; FileWriter &amp;&amp; 普通文件拷贝</a></p>\n<p id=\"1.%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E6%B5%81FileReader-toc\" style=\"margin-left:80px;\"><a href=\"#1.%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E6%B5%81FileReader\">1.字符输入流FileReader</a></p>\n<p id=\"2.%E5%AD%97%E7%AC%A6%E8%BE%93%E5%87%BA%E6%B5%81FileWriter-toc\" style=\"margin-left:80px;\"><a href=\"#2.%E5%AD%97%E7%AC%A6%E8%BE%93%E5%87%BA%E6%B5%81FileWriter\">2.字符输出流FileWriter</a></p>\n<p id=\"3.%E6%99%AE%E9%80%9A%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9D-toc\" style=\"margin-left:80px;\"><a href=\"#3.%E6%99%AE%E9%80%9A%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9D\">3.普通文件拷贝</a></p>\n<p id=\"%E7%BB%93%E6%9D%9F%E8%AF%AD-toc\" style=\"margin-left:0px;\"><a href=\"#%E7%BB%93%E6%9D%9F%E8%AF%AD\">结束语</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h1 id=\"%F0%9F%A5%85IO%E6%B5%81%E7%90%86%E8%AE%BA%E6%A6%82%E8%BF%B0\">🥅IO流理论概述</h1>\n<h3 id=\"1.%E4%BB%80%E4%B9%88%E6%98%AFIO\"><strong>1.什么是IO</strong></h3>\n<blockquote>\n<p>❤️什么是IO？IO有什么用？</p>\n<p>      ⭐️<strong>I代表Input</strong>，把<span style=\"color:#fe2c24;\">硬盘里的文件放到内存里</span>，就叫做输入(Input)，也就是<span style=\"color:#fe2c24;\">读</span></p>\n<p>      ⭐️<strong>O代表Output</strong>，把<span style=\"color:#fe2c24;\">内存里的文件放到硬盘里</span>，就叫做输出(Output)，也就是<span style=\"color:#fe2c24;\">写</span></p>\n<p>❤️通过IO流可以完成文件的读和写！并且<strong>读和写都是以内存为参照的！</strong></p>\n</blockquote>\n<p><img alt=\"\" height=\"476\" src=\"image\\f13a42fa9e5f4487a4a2a99364f68e84.png\" width=\"1200\"/></p>\n<h3></h3>\n<h3 id=\"2.IO%E6%B5%81%E7%9A%84%E5%88%86%E7%B1%BB\"><strong>2.IO流的分类</strong></h3>\n<blockquote>\n<p><strong>❤️IO流的分类？有多种分类方式：</strong><br/>     ⭐️第一种方式是<strong><span style=\"color:#fe2c24;\">按照流的方向</span></strong>进行分类（<strong>以内存作为参照物</strong>）：            <br/>     （1）<span style=\"color:#fe2c24;\">往内存中去，叫做输入(Input)。或者叫做读(Read)。</span><br/>     （2）<span style=\"color:#fe2c24;\">从内存中出来，叫做输出(Output)。或者叫做写(Write)。</span><br/>     ⭐️另一种方式是<strong><span style=\"color:#fe2c24;\">按照读取数据方式不同</span></strong>进行分类：<br/>     （1）有的流是<span style=\"color:#fe2c24;\">按照<strong>字节</strong>的方式读取数据</span>，一次读取1个字节byte，等同于一次读取8个二进制位。这种流是万能的，<strong>什么类型的文件都可以读取</strong>。包括：文本文件，图片，声音文件，视频文件等....<br/>      例：假设文件file1.txt，采用字节流的话是这样读的：<br/>              a中国bc张三fe<br/>              第一次读：一个字节，正好读到'a'<br/>              第二次读：一个字节，正好读到'中'字符的一半。<br/>              第三次读：一个字节，正好读到'中'字符的另外一半。<br/>    （2）有的流是<span style=\"color:#fe2c24;\">按照<strong>字符</strong>的方式读取数据</span>，一次读取一个字符，这种流是为了方便读取<br/>    普通文本文件而存在的，这种流不能读取：图片、声音、视频等文件。<strong>只能读取纯文本文件，连word文件都无法读取。</strong><br/>    例：假设文件file1.txt，采用字符流的话是这样读的：<br/>            a中国bc张三fe<br/>            第一次读：'a'字符（'a'字符在windows系统中占用1个字节。）<br/>            第二次读：'中'字符（'中'字符在windows系统中占用2个字节。）<br/>   ⭐️综上所述：流的分类<br/>         <span style=\"color:#fe2c24;\">（1）输入流、输出流<br/>         （2）字节流、字符流</span></p>\n</blockquote>\n<h3></h3>\n<h3 id=\"3.%E6%B5%81%E7%9A%84%E5%9B%9B%E5%A4%A7%E5%AE%B6%E6%97%8F\"><strong>3.流的四大家族</strong></h3>\n<blockquote>\n<p><strong>❤️</strong>Java中的IO流都已经写好了，我们最主要还是掌握，在java中已经提供了哪些流，每个流的特点是什么，每个流对象上的常用方法有哪些<br/>     ⭐️java中<strong>所有的流</strong>都是在：<span style=\"color:#fe2c24;\">java.io.*</span>;</p>\n<p>    ⭐️ java中主要还是研究：怎么new流对象？调用流对象的哪个方法是读？哪个方法是写？</p>\n<p><strong>❤️java IO流这块有四大家族</strong><strong>：</strong><br/>     ⭐️四大家族的四个首领：（<strong>都是抽象类</strong>(abstract class)）<br/>        <span style=\"color:#fe2c24;\"> java.io.InputStream</span>          ​​​​<span style=\"color:#0d0016;\">字节输入流（读）</span><br/>        <span style=\"color:#fe2c24;\"> java.io.OutputStream       </span><span style=\"color:#0d0016;\">字节输出流（写）</span></p>\n<p><span style=\"color:#fe2c24;\">        java.io.Reader </span>               ​​​​  <span style=\"color:#0d0016;\">字符输入流（读）</span><br/>        <span style=\"color:#fe2c24;\"> java.io.Writer </span>     <span style=\"color:#0d0016;\">              字符输出流（写）</span></p>\n<p>   ⭐️<strong>所有的<span style=\"color:#fe2c24;\">流</span>都实现了：</strong></p>\n<p>           （1）<strong><span style=\"color:#fe2c24;\">java.io.Closeable接口，都是可关闭的，都有close()方法</span></strong>。<br/>            （2） 流，毕竟是一个管道，这个是内存和硬盘之间的通道，用完之后一定要关闭，<br/>              不然会耗费(占用)很多资源。养成好习惯，用完流一定要关闭。</p>\n<p>   ⭐️<strong>所有的<span style=\"color:#fe2c24;\">输出流</span>都实现了：</strong><br/>            （1）<span style=\"color:#fe2c24;\"><strong> java.io.Flushable接口，都是可刷新的，都有flush()方法。</strong></span><br/>            （2）养成一个好习惯，输出流在最终输出之后，一定要记得flush()刷新一下，<br/>              这个刷新表示将通道/管道当中剩余未输出的数据强行输出完（清空管道），<br/>            （3）<strong>注意：</strong>  <strong>刷新的作用就是清空管道；</strong>如果没有flush()可能会导致丢失数据。<br/><strong>❤️</strong><strong>注意：<span style=\"color:#fe2c24;\">在java中只要“类名”以Stream结尾的都是字节流。以“Reader/Writer”结尾的都是字符流。</span></strong></p>\n</blockquote>\n<p></p>\n<h3 id=\"4.%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1%E7%9A%84%E5%8D%81%E5%85%AD%E4%B8%AA%E6%B5%81\"><strong>4.需要掌握的十六个流</strong></h3>\n<blockquote>\n<p><strong>❤️java.io包下需要掌握的流有16个：</strong></p>\n<p><strong> ⭐️文件专属：</strong><br/>       <span style=\"color:#fe2c24;\">  java.io.FileInputStream（掌握）<br/>         java.io.FileOutputStream（掌握）<br/>         java.io.FileReader<br/>         java.io.FileWriter</span></p>\n<p><strong> ⭐️转换流：（将字节流转换成字符流）</strong><br/>      <span style=\"color:#fe2c24;\">   java.io.InputStreamReader<br/>         java.io.OutputStreamWriter</span></p>\n<p><strong> ⭐️缓冲流专属：</strong><br/>      <span style=\"color:#fe2c24;\">   java.io.BufferedReader<br/>         java.io.BufferedWriter<br/>         java.io.BufferedInputStream<br/>         java.io.BufferedOutputStream</span></p>\n<p><strong> ⭐️数据流专属：</strong><br/>       <span style=\"color:#fe2c24;\">  java.io.DataInputStream<br/>         java.io.DataOutputStream</span></p>\n<p><strong> ⭐️标准输出流：</strong><br/>       <span style=\"color:#fe2c24;\">  java.io.PrintWriter<br/>         java.io.PrintStream（掌握）</span></p>\n<p><strong> ⭐️对象专属流：</strong><br/>       <span style=\"color:#fe2c24;\">  java.io.ObjectInputStream（掌握）<br/>         java.io.ObjectOutputStream（掌握）</span></p>\n</blockquote>\n<p></p>\n<h1 id=\"%F0%9F%A5%85%E5%AD%97%E8%8A%82%E8%BE%93%E5%85%A5%E6%B5%81FileInputStream\">🥅字节输入流FileInputStream</h1>\n<h3 id=\"1.FileInputStream%E5%88%9D%E6%AD%A5%E7%90%86%E8%A7%A3\"><strong>1.FileInputStream初步理解</strong></h3>\n<blockquote>\n<p style=\"margin-left:0;text-align:justify;\"><strong>⭐️java.io.FileInputStream:</strong><br/>     1、文件字节输入流，万能的，任何类型的文件都可以采用这个流来读。<br/>     2、字节的方式，完成输入的操作，完成读的操作（硬盘---&gt; 内存）</p>\n<p style=\"margin-left:0;text-align:justify;\">    3、调用read()方法进行读，返回的是int类型(字符对应的ASCII码）；没有元素的话，返回的是-1</p>\n</blockquote>\n<pre><code class=\"language-java\">package com.bjpowernode.java.io;\n\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\n\npublic class FileInputStreamTest01 {\n    public static void main(String[] args) {\n        // 创建文件字节输入流对象\n        // 文件路径：//C:\\Java学习\\temp.txt\n        //（里面存的是abc，IDEA会自动把\\编程\\\\，因为java中\\表示转义）\n        // FileInputStream这个方法会抛出异常，父类是Exception，属于编译时异常，需要处理\n        FileInputStream fis = null; //写到外面，主要是为了finally里面能够调用\n        try {  //C:/Java学习/temp.txt，路径写成这样也是可以的\n            fis = new FileInputStream(\"C:\\\\Java学习\\\\temp.txt\");\n            //1、读文件，从此输入流中读取一个字节\n            int readDate = fis.read();\n            System.out.println(readDate); //97\n\n            readDate = fis.read();\n            System.out.println(readDate); //98\n\n            readDate = fis.read();\n            System.out.println(readDate); //99\n\n            readDate = fis.read();\n            System.out.println(readDate); //-1；最终没数据了，就返回-1\n            \n            //2、循环读\n           while(true){\n               int readDate1 = fis.read();\n               if(readDate1 == -1){ // 没有数据返回的是-1\n                   break;\n               }\n               System.out.println(readDate1);\n           }\n\n            //3、优化while\n            int readDate1 = 0;\n            while((readDate1 = fis.read()) != -1){\n                System.out.println(readDate1);\n            }\n\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) { //read时候，补充的异常处理\n            e.printStackTrace();\n        } finally {\n            // 加上finally关键字，无论最终有没有异常，都需要关闭这个流\n            // 在finally语句块当中确保流一定关闭\n            if (fis != null) { //生成这个的快捷键ifn\n                // 关闭流的前提，流不是null；是空没必要关闭\n                try {\n                    fis.close(); //有异常，try...catch\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n</code></pre>\n<blockquote>\n<p><strong>⭐️</strong>分析上面这个程序的<strong>缺点</strong>：<br/> （1）一次读取一个字节byte，这样内存和硬盘交互太频繁，基本上时间/资源都耗费在交互上面了。所以能不能一次读取多个字节呢？答案是可以的。</p>\n<p>（2）<span style=\"color:#fe2c24;\"><strong>int read(byte[] b)</strong></span>；<strong> 一次最多读取 b.length 个字节</strong>。<br/>     减少硬盘和内存的交互，提高程序的执行效率；往byte[]数组当中读。</p>\n<p>（3）这里我们不在使用绝对路径，而是相对路径；那么IDEA默认的路径是什么呢？</p>\n<p style=\"margin-left:0;text-align:justify;\">       <strong> 工程Project的根就是IDEA的默认当前路径；</strong></p>\n</blockquote>\n<pre><code class=\"language-java\">package com.bjpowernode.java.io;\n\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\n\npublic class FileInputStreamTest02 {\n    public static void main(String[] args) {\n        FileInputStream fis = null;\n        try {\n            // 我们写成相对路径方式，在这里要先理解在IDEA默认的当前路径是哪里？\n            // 工程Project的根就是IDEA的默认当前路径；例如我的：C:\\Users\\86177\\IdeaProjects\\JavaSe1\n            //fis = new FileInputStream(\"tempfile.txt\"); //这是在工程下面的tempfile.txt\n            // 如果是day06模块下的src包下有一个tempfile.txt，怎么调用呢？\n            fis = new FileInputStream(\"day06/src/tempfile.txt\"); //存放的是abcdef\n\n            // 开始读，采用byte数组，一次读取多个字节。最多读取“数组.length”个字节。\n            byte[] bytes = new byte[4];  准备一个4个长度的byte数组，一次最多读取4个字节\n\n           /* 1、普通打印\n           int readCount = fis.read(bytes); // 返回的是当前的读取到的字节数量。（不是字节本身）\n            System.out.println(readCount); // 4;第一次读到了4个字节\n            //System.out.println(new String(bytes)); //abcd，将字符数组全部转换成字符串\n            // 实际上应该读到多少个，就转换多少个\n            System.out.println(new String(bytes,0,readCount)); // abcd\n\n            readCount = fis.read(bytes);\n            System.out.println(readCount); // 2;第二次只能读取到2个字节\n            //System.out.println(new String(bytes)); //efcd，将字符数组全部转换成字符串，这里就出了问题\n            System.out.println(new String(bytes,0,readCount)); //ef\n\n            readCount = fis.read(bytes);\n            System.out.println(readCount); //1个字节都没有读取到返回-1*/\n\n\n           //2、 写成循环\n            while(true){\n                int readCount = fis.read(bytes);\n                if(readCount == -1){\n                    break;\n                }\n                System.out.print(new String(bytes,0,readCount)); // abcdef\n            }\n\n            //3、 代码优化\n           int readCount = 0;\n            while((readCount = fis.read(bytes)) != -1){\n                // 将读取到的将字符数组全部转换成字符串\n                System.out.print(new String(bytes,0,readCount)); // abcdef\n            }\n\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally{\n            if (fis != null) {\n                try {\n                    fis.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n    }\n}\n</code></pre>\n<h3></h3>\n<h3 id=\"2.FileInputStream%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95\"><strong>2.FileInputStream常用方法</strong></h3>\n<blockquote>\n<p style=\"margin-left:0;text-align:justify;\"><strong>❤️FileInputStream类的其它常用方法：</strong></p>\n<p style=\"margin-left:0;text-align:justify;\">      ⭐<span style=\"color:#fe2c24;\">int available()</span>：<strong>返回流当中剩余的没有读到的字节数量</strong></p>\n<p style=\"margin-left:0;text-align:justify;\">      ⭐<span style=\"color:#fe2c24;\">long skip(long n)</span>：<strong>跳过几个字节不读</strong></p>\n</blockquote>\n<pre><code class=\"language-java\">package com.bjpowernode.java.io;\n\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\n\npublic class FileInputStreamTest03 {\n    public static void main(String[] args) {\n        FileInputStream fis = null;\n        try {\n            fis = new FileInputStream(\"tempfile.txt\"); // 存的abcdef\n            // 先读一个字节\n            int readByte = fis.read();\n            System.out.println(readByte); // 97\n            //1、available方法，还剩下多少字节\n            System.out.println(fis.available()); // 5，还剩下5个字节\n            // available方法有什么用？\n            // 我们知道当前有的字节数，就不用使用循环了，直接指定当前长度就行\n            // 这种方式不太适合太大的文件，因为byte[]数组不能太大。\n            byte[] bytes = new byte[fis.available()]; //不需要循环，直接读一次就行\n            int readCount = fis.read(bytes);\n            System.out.println(new String(bytes,0,readCount));\n\n            // 2、skip方法，跳过几个字节\n            fis = new FileInputStream(\"tempfile.txt\");\n            // 跳过3个字节\n            fis.skip(3);\n            System.out.println(fis.read()); //100（d）\n\n\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                fis.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n</code></pre>\n<p></p>\n<h1 id=\"%F0%9F%A5%85%E5%AD%97%E8%8A%82%E8%BE%93%E5%87%BA%E6%B5%81FileOutputStream\">🥅字节输出流FileOutputStream</h1>\n<blockquote>\n<p style=\"margin-left:0;text-align:justify;\">❤️文件字节输出流，从内存到硬盘，负责写；怎么写呢？</p>\n<p style=\"margin-left:0;text-align:justify;\"> ⭐如果当前文件不存在，会自动创建！</p>\n<p style=\"margin-left:0;text-align:justify;\"> ⭐如果当前文件已经存在，会把原来文件的内容进行清空覆盖！</p>\n<p style=\"margin-left:0;text-align:justify;\"> ⭐后面的<span style=\"color:#fe2c24;\"><strong>参数直接跟的是byte数组</strong></span>；</p>\n<p style=\"margin-left:0;text-align:justify;\"> ⭐如果是字符串，<strong>字符串转字节数组</strong>需要<span style=\"color:#fe2c24;\">用getBytes()方法</span>，把<strong>字符串转换成byte数组；</strong>而把byte数组转换成字符串用的是new String(byte数组)<strong>       </strong></p>\n</blockquote>\n<pre><code class=\"language-java\">package com.bjpowernode.java.io;\n\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\npublic class FileOutputStreamTest01 {\n    public static void main(String[] args) {\n        FileOutputStream fos = null;\n        try {\n            //1、 myfile文件如果不存在的时候会自动新建！\n            // 这种方式谨慎使用，会先将原文件清空，然后重新写入。\n            fos = new FileOutputStream(\"myfile\");\n\n            //2、以追加的方式在文件末尾写入。不会清空原文件内容。\n            fos = new FileOutputStream(\"myfile\",true);\n\n            //3、开始写，写到数组里\n            byte[] bytes = {97,98,99,100};\n            fos.write(bytes); // 写进去abcd\n\n            //4、将byte数组的一部分写出\n            fos.write(bytes,0,2); //写进去ab\n\n            //5、写一个字符串，然后把字符串转换成byte数组\n            String s = \"我是一个中国人！\";\n            //将一个字符串转换成byte数组\n            byte[] byts = s.getBytes();\n            fos.write(byts); //写进去“我是一个中国人！”\n\n            //6、写完之后一定要刷新\n            fos.flush();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (fos != null) {\n                try {\n                    fos.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n</code></pre>\n<p></p>\n<h1 id=\"%F0%9F%A5%85%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9D\">🥅任意文件拷贝</h1>\n<blockquote>\n<p>有了上面的输入流和输出流学习，我们是不是就可以尝试完成一个文件拷贝的功能，无非就是读、写的结合应用，下面我们先看一下原理图：</p>\n</blockquote>\n<p><img alt=\"\" height=\"707\" src=\"image\\eef9cd5c7a51451f8f7cec9c4a214cf8.png\" width=\"1200\"/></p>\n<blockquote>\n<p>⭐使用<strong>FileInputStream + FileOutputStream完成文件的拷贝</strong>。</p>\n<p>⭐拷贝的过程应该是<strong>一边读，一边写</strong>。</p>\n<p>⭐使用<strong>字节流拷贝文件</strong>的时候，文件类型随意，什么样的文件都能拷贝。</p>\n</blockquote>\n<pre><code class=\"language-java\">package com.bjpowernode.java.io;\n\n\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\npublic class CopyTest {\n    public static void main(String[] args) {\n        FileInputStream fis = null;\n        FileOutputStream fos = null;\n        try {\n            //1、 创建一个输入流对象\n            fis = new FileInputStream(\"C:\\\\Java学习\\\\javaSE学习\\\\2.JavaSE初学习笔记\\\\2.第一章：Java环境搭建\\\\HelloWorld.java\");\n            //2、 创建一个输出流对象\n            fos = new FileOutputStream(\"C:\\\\Java学习\\\\HelloWorld.java\");\n\n            //3、 最核心的部分：一边读，一边写\n            byte[] bytes = new byte[1024 * 1024]; // 1MB（一次最多拷贝1MB。）\n            int readCount = 0;\n            while((readCount = fis.read(bytes)) != -1) {\n                fos.write(bytes, 0, readCount);\n            }\n\n            //4、 刷新，输出流最后要刷新\n            fos.flush();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            // 分开try，不要一起try。\n            // 一起try的时候，其中一个出现异常，可能会影响到另一个流的关闭。\n            if (fos != null) {\n                try {\n                    fos.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (fis != null) {\n                try {\n                    fis.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n</code></pre>\n<h3></h3>\n<h1 id=\"%F0%9F%A5%85FileReader%20%26%26%20FileWriter%20%26%26%20%E6%99%AE%E9%80%9A%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9D\">🥅FileReader &amp;&amp; FileWriter &amp;&amp; <strong>普通</strong>文件拷贝</h1>\n<h3 id=\"1.%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E6%B5%81FileReader\"><strong>1.字符输入流FileReader</strong></h3>\n<blockquote>\n<p>（1）对于字符输入输出流FileReader 和 FileWriter的用法，与字节输入输出流<strong>FileInputStream </strong>和 <strong><span style=\"color:#fe2c24;\">FileOutputStream</span></strong>的用法很相似；后者我们已经学过<strong>使用byte数组</strong>，前者是<span style=\"color:#fe2c24;\"><strong>使用char数组</strong></span>！</p>\n<p style=\"margin-left:0;text-align:justify;\">（2）FileReader： 文件字符输入流，只能读取普通文本。 读取文本内容时，比较方便，快捷。</p>\n</blockquote>\n<pre><code class=\"language-java\">package com.bjpowernode.java.io;\n\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class FileReaderTest01 {\n    public static void main(String[] args) {\n        FileReader reader = null;\n        try {\n            // 创建文件字符输入流\n            reader  = new FileReader(\"C:\\\\Java学习\\\\javaSE学习\\\\2.JavaSE初学习笔记\\\\2.第一章：Java环境搭建\\\\HelloWorld.java\");\n            // 开始读\n            char[] chars = new char[4]; // 一次读取4个字符\n\n            // 第一种方法\n           int readCount = 0;\n            while((readCount = reader.read(chars)) != -1){\n                System.out.print(new String(chars,0,readCount));\n            }\n\n            // 补充\n            // reader.read(chars); // 往char数组中读\n            \n            // 按照字符的方式读取，一次读取一个字符\n            for(char c :chars){\n                System.out.println(c);\n            }\n\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (reader != null) {\n                try {\n                    reader.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n    }\n}\n</code></pre>\n<p></p>\n<h3 id=\"2.%E5%AD%97%E7%AC%A6%E8%BE%93%E5%87%BA%E6%B5%81FileWriter\"><strong>2.字符输出流FileWriter</strong></h3>\n<blockquote>\n<p>（1）FileWriter：文件字符输出流，写；只能输出普通文本！例如：图片、声音、视频、word文件等，都不可以！</p>\n<p>（2）后面的参数<span style=\"color:#fe2c24;\">直接跟的是char数组；也可以直接跟字符串</span>！</p>\n</blockquote>\n<pre><code class=\"language-java\">package com.bjpowernode.java.io;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class FileWriterTest01 {\n    public static void main(String[] args) {\n        FileWriter writer = null;\n        try {\n            //1、 创建文件字符输出流对象\n            writer = new FileWriter(\"file\",true); //file，没有会自动创建\n\n            //2、 开始写\n            char[] chars = {'我','是','中','国','人'};\n            // 写整个数组的内容\n            writer.write(chars);\n            // 也可以只写数组的一部分\n            writer.write(chars,0,2);\n            // 后面也可以直接跟字符串\n            writer.write(\"\\n\"); // 换行\n            writer.write(\"我很骄傲\");\n\n            //3、 刷新\n            writer.flush();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally{\n            if (writer != null) {\n                try {\n                    writer.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n</code></pre>\n<h3></h3>\n<h3 id=\"3.%E6%99%AE%E9%80%9A%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9D\"><strong>3.普通文件拷贝</strong></h3>\n<blockquote>\n<p>使用FileReader 和 FileWriter进行拷贝，只能拷贝“普通文本”文件（能用记事本编辑的）！</p>\n</blockquote>\n<pre><code class=\"language-java\">package com.bjpowernode.java.io;\n\nimport java.io.*;\n\npublic class CopyTest02 {\n    public static void main(String[] args) {\n        FileReader reader = null;\n        FileWriter writer = null;\n\n        {\n            try {\n                // 创建字符输入流\n                reader = new FileReader(\"file\");\n                // 创建字符输出流\n                writer = new FileWriter(\"myfile\");\n\n                // 边读边写\n                char[] chars = new char[1024*1024]; // 1MB\n                int readCount = 0;\n                while((readCount = reader.read(chars)) != -1){\n                    writer.write(chars,0,readCount);\n                }\n\n                // 刷新\n                writer.flush();\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }finally {\n                if (reader != null) {\n                    try {\n                        reader.close();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n                if(writer != null){\n                    try {\n                        writer.close();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }\n    }\n\n}\n</code></pre>\n<h1 id=\"%E7%BB%93%E6%9D%9F%E8%AF%AD\">结束语</h1>\n<blockquote>\n<p>今天的分享就到这里啦！快快通过下方链接注册加入刷题大军吧！各种大厂面试真题在等你哦！</p>\n<p> 💬刷题神器，从基础到大厂面试题👉<a href=\"https://www.nowcoder.com/link/pc_csdncpt_mtdyqdm_c\" title=\"点击跳转刷题网站\">点击跳转刷题网站</a></p>\n</blockquote>\n<p><img alt=\"\" height=\"511\" src=\"image\\184068dc41e94efbb14e555f972eaa17.png\" width=\"1200\"/></p>\n<p></p>\n</div>\n</div>"}