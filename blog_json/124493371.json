{"blogid": "124493371", "writerAge": "码龄1年", "writerBlogNum": "89", "writerCollect": "1106", "writerComment": "1780", "writerFan": "4058", "writerGrade": "5级", "writerIntegral": "4238", "writerName": "小白又菜", "writerProfileAdress": "writer_image\\profile_124493371.jpg", "writerRankTotal": "4022", "writerRankWeekly": "310", "writerThumb": "1868", "writerVisitNum": "66782", "blog_read_count": "1263", "blog_time": "于 2022-04-29 12:40:11 发布", "blog_title": "[C++] 深入理解C++函数重载底层原理 C++入门（2）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>本篇文章我们要深入理解函数重载。还不了解函数重载的小伙伴可以看看上篇文章末尾简单理解一下<a href=\"https://blog.csdn.net/qq_58325487/article/details/124425335?spm=1001.2014.3001.5501\" title=\"[C++] helloworld 解析 C++入门（一）\">[C++] helloworld 解析 C++入门（一）</a></p>\n<blockquote>\n<p>本篇主要解决的问题：</p>\n<p>1.C语言不支持重载，C++支持重载，为什么？</p>\n<p>2.C++如何支持重载？</p>\n</blockquote>\n<blockquote>\n<p></p>\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E9%97%AE%E9%A2%98%E7%9A%84%E5%BC%95%E5%85%A5-toc\"><a href=\"#%E9%97%AE%E9%A2%98%E7%9A%84%E5%BC%95%E5%85%A5\">问题的引入</a></p>\n<p id=\"1.%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%EF%BC%88C%2B%2B%EF%BC%89-toc\"><a href=\"#1.%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%EF%BC%88C%2B%2B%EF%BC%89\">1.函数重载（C++）</a></p>\n<p id=\"1.1%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B-toc\"><a href=\"#1.1%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B\">1.1编译链接过程</a></p>\n<p id=\"1.1.1%E9%A2%84%E5%A4%84%E7%90%86%C2%A0-toc\"><a href=\"#1.1.1%E9%A2%84%E5%A4%84%E7%90%86%C2%A0\">1.1.1预处理 </a></p>\n<p id=\"%C2%A01.1.2%E7%BC%96%E8%AF%91-toc\"><a href=\"#%C2%A01.1.2%E7%BC%96%E8%AF%91\">1.1.2编译</a></p>\n<p id=\"1.1.3%E6%B1%87%E7%BC%96-toc\"><a href=\"#1.1.3%E6%B1%87%E7%BC%96\">1.1.3汇编</a></p>\n<p id=\"1.1.4%E9%93%BE%E6%8E%A5-toc\"><a href=\"#1.1.4%E9%93%BE%E6%8E%A5\">1.1.4链接</a></p>\n<p id=\"2.C%E8%AF%AD%E8%A8%80%20%E5%AF%B9%E5%87%BD%E6%95%B0%E9%87%8D%E5%91%BD%E5%90%8D-toc\"><a href=\"#2.C%E8%AF%AD%E8%A8%80%20%E5%AF%B9%E5%87%BD%E6%95%B0%E9%87%8D%E5%91%BD%E5%90%8D\">2.C语言 对函数重命名</a></p>\n<p id=\"%E6%80%BB%E7%BB%93-toc\"><a href=\"#%E6%80%BB%E7%BB%93\">3.总结</a></p>\n<p></p>\n</blockquote>\n<h1 id=\"%E9%97%AE%E9%A2%98%E7%9A%84%E5%BC%95%E5%85%A5\">问题的引入</h1>\n<p>首先我们复习一下函数重载。函数重载就像是一词多义，一个函数名可以有多个意思。函数可以根据参数的不同选择进入不同参数的函数。</p>\n<p>那么,这种情况属于函数重载吗？</p>\n<pre><code>short Add(short left, short right)\n{\n}\nint Add(short left, short right)\n{\n}\n</code></pre>\n<blockquote>\n<p>答：这种是不构成函数重载的，这是因为函数重载跟返回值没有关系，在VS2019下编译器也会主动报错。</p>\n<p>那么今天我们就是来底层深挖，为什么和返回值没有关系，又为什么和参数的顺序，个数，类型有关系呢？ </p>\n</blockquote>\n<p><img alt=\"\" height=\"254\" src=\"image\\1b174ba8251f4511aa3faa05ea93c8b7.png\" width=\"464\"/></p>\n<h1 id=\"1.%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%EF%BC%88C%2B%2B%EF%BC%89\"><strong>1.函数重载（C++）</strong></h1>\n<p>在我们学习C语言的过程中我们知道编译链接的过程，为了更好的展示这个过程，我们使用Linux来看这段过程。</p>\n<h2 id=\"1.1%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B\">1.1编译链接过程</h2>\n<p>首先我们复习一下编译连接的过程：</p>\n<blockquote>\n<p>1、预处理 -- 头文件展开,宏替换,条件编译,去掉注释<br/>  f.i  test.i<br/> 2、编译 -- 检查语法,生成汇编代码<br/>  f.s  test.s<br/> 3、汇编 -- 把汇编代码转换成二进制的机器码<br/>  f.o  test.o<br/> 4、链接 -- 找调用函数的地址,链接对应上,合并到一起 合并符号表<br/>  a.out</p>\n</blockquote>\n<p> <img alt=\"\" height=\"442\" src=\"image\\4cc9edba77734f50bf451eab2b9e84e0.png\" width=\"660\"/></p>\n<p></p>\n<h3 id=\"1.1.1%E9%A2%84%E5%A4%84%E7%90%86%C2%A0\">1.1.1预处理 </h3>\n<p>在预处理的过程中,会进行头文件的展开,宏替换，条件编译，去掉注释等一些操作，这个过程非常的重要。在这里我们重点说说头文件展开。</p>\n<p>头文件展开：</p>\n<p>假设现在我们创建一个f.h的头文件，f.cpp的文件。</p>\n<p><img alt=\"\" height=\"286\" src=\"image\\84f81219fc13465fb331816bf8034708.png\" width=\"759\"/></p>\n<p><img alt=\"\" height=\"381\" src=\"image\\e1b0ea9f1487480f9bb65cfa615cb6f7.png\" width=\"724\"/></p>\n<p> 那么头文件的展开就是将f.cpp的头文件进行展开。如下图所示：</p>\n<p><img alt=\"\" height=\"431\" src=\"image\\423000fcd7714ae8b2adc073edb8da16.png\" width=\"770\"/></p>\n<p>此时的cpp文件为:</p>\n<p> <img alt=\"\" height=\"418\" src=\"image\\8f71687a625a49f88808baab52632b78.png\" width=\"514\"/></p>\n<p>经过预处理的过程，我们在编译的过程中我们就可以找到函数了。 </p>\n<h3 id=\"%C2%A01.1.2%E7%BC%96%E8%AF%91\">1.1.2编译</h3>\n<p>检查语法,生成汇编代码，汇编代码是一种指令级的语言,如果有语法错误,就会在这个阶段出现。</p>\n<p>我们在VS下看看什么是指令级的代码，这些指令级的代码是给CPU准备的,CPU是执行指令的。</p>\n<p>例如：我们看看最简单的helloworld的指令代码</p>\n<p><img alt=\"\" height=\"762\" src=\"image\\e80febf7a7df4b0d84bc026f2a531533.png\" width=\"979\"/></p>\n<h3 id=\"1.1.3%E6%B1%87%E7%BC%96\">1.1.3汇编</h3>\n<p>当语法没问题的时候，我们就来到了汇编，此时这个指令级代码CPU不认识，机器都只认识0和1。因此汇编的过程就是将汇编代码转换成二进制的机器码。</p>\n<h3 id=\"1.1.4%E9%93%BE%E6%8E%A5\">1.1.4链接</h3>\n<p>找调用函数的地址，链接对应上合并到一起，合并符号表。</p>\n<p>我们来理解一下这个过程：</p>\n<p>这预处理过程中头文件展开如下</p>\n<p><img alt=\"\" height=\"439\" src=\"image\\a962c235cf2948aa8ea6910707c99530.png\" width=\"1200\"/></p>\n<p>在编译的过程中还会生成一个符号表，主要记录函数定义和函数地址的映射，那符号表为什么要生成函数地址的映射呢。此时我们来看</p>\n<p><img alt=\"\" height=\"704\" src=\"image\\6438b0bc6e8243c59d9493139a887f77.png\" width=\"1073\"/></p>\n<p> 在main函数的指令中，有两句指令call，call后面所跟的就是函数的地址，函数的名字和函数的地址。然后我们来看一下这个过程，真正的函数地址就是第一句指令的地址。函数的名字也会有自己的命名规则。</p>\n<p><img alt=\"\" height=\"347\" src=\"image\\b155590d67ab4347860e519d969a007e.png\" width=\"511\"/></p>\n<p></p>\n<p><img alt=\"\" height=\"414\" src=\"image\\f3f4d587b78a4325853d69edc58087b0.png\" width=\"623\"/></p>\n<p> <img alt=\"\" height=\"394\" src=\"image\\54aadf0e1c994d0aa9bd78a9fd7aa0e3.png\" width=\"1180\"/></p>\n<p></p>\n<p>为了更好的看函数的命名规则，我们在linux下看看这个细节。当函数名相同，参数不同时，他们的函数名会有一套新的命名规则。在不同的话函数调用中，他们参数类型首字符带进命名规则中去了。</p>\n<blockquote>\n<p>新的函数名：_Z 函数名长度 函数名 类型首字母</p>\n</blockquote>\n<p>因此即使函数名相同，但参数的类型不同，顺序不同，个数不同都会产生不同新的函数名。</p>\n<p><img alt=\"\" height=\"652\" src=\"image\\92291e06304c4897b23ddd4ba9a92bf3.png\" width=\"1200\"/></p>\n<p>因此再调用的时候对应的名字是不相同的。因此所对应的地址也是不同的 </p>\n<p> <img alt=\"\" height=\"259\" src=\"image\\9d55e9b563b34f54b525940e8354679b.png\" width=\"416\"/><img alt=\"\" height=\"160\" src=\"image\\afbbe5385fe44f92b0d0fad9d5426a9f.png\" width=\"514\"/></p>\n<p>这也是为什么C++支持函数重载的原因。</p>\n<h1 id=\"2.C%E8%AF%AD%E8%A8%80%20%E5%AF%B9%E5%87%BD%E6%95%B0%E9%87%8D%E5%91%BD%E5%90%8D\">2.C语言中处理</h1>\n<p>那我们在C语言中再看看这个过程，他的新的函数名是怎么命名的，我们首先创建3个文件</p>\n<p><img alt=\"\" height=\"226\" src=\"image\\3336a3d5f1a8444f856879146f347778.png\" width=\"426\"/></p>\n<p><img alt=\"\" height=\"410\" src=\"image\\2ff5006a58354d30aa5964af3cc661f0.png\" width=\"483\"/></p>\n<p><img alt=\"\" height=\"236\" src=\"image\\c785234e8a384e34beaa9bee7884c19b.png\" width=\"391\"/></p>\n<blockquote>\n<p> 我们再在Linux下看看C语言是如何处理函数名的</p>\n</blockquote>\n<p><img alt=\"\" height=\"422\" src=\"image\\436fb6b97d8d4b968a0a97edb165eaac.png\" width=\"810\"/></p>\n<p><img alt=\"\" height=\"254\" src=\"image\\490fcdb0bca24177a3854f5926ae5995.png\" width=\"710\"/></p>\n<blockquote>\n<p>此时我们发现<strong>C语言对函数的命名只有函数名本身，和参数无关。</strong></p>\n</blockquote>\n<p>我们在Linux下看看报错信息：我们创建两个f函数，我们在Linux下用gcc编译看报错信息，我们发现这时就会报错说函数命名发生冲突。</p>\n<p><img alt=\"\" height=\"608\" src=\"image\\970c0bfbd134479b914131356bd86d20.png\" width=\"911\"/></p>\n<blockquote>\n<p><strong>因此我们知道C语言对函数的命名只有函数名本身，因此如果在C语言中，函数名相同时，就会报错，因此C语言是不支持函数重载的。</strong></p>\n</blockquote>\n<p></p>\n<h1 id=\"%E6%80%BB%E7%BB%93\">3.总结</h1>\n<p>1.C++支持函数重载是因为C++在符号表中存储的函数的定义和函数的地址。C++中对函数的命名规则有了新的变化：_Z 函数名长度 函数名 类型首字母 。</p>\n<p>因此参数的类型，个数，顺序不同就会不同的命名。名字不同地址不同。这也是为什么C++支持函数重载的原因。</p>\n<p>2.我们发现在新的命名规则中是不包括返回值类型的，因此返回值类型不同并不会对函数的命名产生影响，这也是返回值不构成函数重载的原因。</p>\n<pre><code>short Add(short left, short right)\n{\n}\nint Add(short left, short right)\n{\n}\n</code></pre>\n<p>3.C语言中在生成符号表中存储的只是原函数的名字，那么如果函数的名字相同时就会产生命名冲突。这就是为什么C语言不支持函数重载的原因。</p>\n<p></p>\n<p>（本篇完）</p>\n</div>\n</div>"}