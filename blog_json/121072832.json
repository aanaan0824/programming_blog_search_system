{"blogid": "121072832", "writerAge": "码龄13年", "writerBlogNum": "209", "writerCollect": "9866", "writerComment": "847", "writerFan": "4694", "writerGrade": "7级", "writerIntegral": "10508", "writerName": "路人甲Java", "writerProfileAdress": "writer_image\\profile_121072832.jpg", "writerRankTotal": "40359", "writerRankWeekly": "11233", "writerThumb": "1723", "writerVisitNum": "1536232", "blog_read_count": "16827", "blog_time": "于 2021-10-31 16:30:00 发布", "blog_title": "一文吃透接口调用神器RestTemplate", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<div id=\"js_content\">\n<p><strong>文末可以领取所有系列高清 pdf。</strong></p>\n<p>大家好，我是路人，这是 SpringMVC 系列第 21 篇。</p>\n<p>本文介绍 Spring web 中特别牛逼的一个类 RestTemplate。</p>\n<h2>目录</h2>\n<ul><li><p>1、RestTemplate 概述</p></li><li><p>2、案例代码</p>\n<ul><li><p>2.1、git 地址</p></li><li><p>2.2、关键代码位置</p></li><li><p>2.3、如何运行测试用例？</p></li></ul></li><li><p>3、发送 Get 请求</p>\n<ul><li><p>3.1、普通请求</p></li><li><p>3.2、url 中含有动态参数</p></li><li><p>3.3、接口返回值为泛型</p></li><li><p>3.4、下载小文件</p></li><li><p>3.5、下载大文件</p></li><li><p>3.6、传递头</p></li><li><p>3.7、综合案例：含头、url 动态参数</p></li></ul></li><li><p>4、POST 请求</p>\n<ul><li><p>4.1、post 请求常见的 3 种类型</p></li><li><p>4.2、普通表单请求</p></li><li><p>4.3、上传本地文件</p></li><li><p>4.4、通过流或字节数组的方式上传文件</p></li><li><p>4.5、复杂表单：多个普通元素+多文件上传</p></li><li><p>4.6、发送 json 格式数据：传递 java 对象</p></li><li><p>4.7、发送 json 格式数据：传递 java 对象，返回值为泛型</p></li><li><p>4.8、发送 json 字符串格式数据</p></li></ul></li><li><p>5、DELETE、PUT、OPTION 请求</p>\n<ul><li><p>5.1、DELETE 请求</p></li><li><p>5.2、PUT 请求</p></li><li><p>5.3、OPTIONS 请求</p></li></ul></li><li><p>6、集成 HttpClient</p></li><li><p>7、集成 okhttp</p></li><li><p>8、总结</p></li><li><p>9、SpringMVC 系列目录</p></li><li><p>10、更多好文章</p></li><li><p>11、【路人甲 Java】所有系列高清 PDF</p></li></ul>\n<h2>1、RestTemplate 概述</h2>\n<p>发送 http 请求，估计很多人用过 httpclient 和 okhttp，确实挺好用的，而 Spring web 中的 RestTemplate 和这俩的功能类似，也是用来发送 http 请求的，不过用法上面比前面的 2 位要容易很多。</p>\n<p>spring 框架提供的 RestTemplate 类可用于在应用中调用 rest 服务，它简化了与 http 服务的通信方式，统一了 RESTful 的标准，封装了 http 链接， 我们只需要传入 url 及返回值类型即可。相较于之前常用的 HttpClient，RestTemplate 是一种更优雅的调用 RESTful 服务的方式。</p>\n<p>在 Spring 应用程序中访问第三方 REST 服务与使用 Spring RestTemplate 类有关。RestTemplate 类的设计原则与许多其他 Spring 模板类(例如 JdbcTemplate、JmsTemplate)相同，为执行复杂任务提供了一种具有默认行为的简化方法。</p>\n<p>RestTemplate 默认依赖 JDK 提供 http 连接的能力（HttpURLConnection），如果有需要的话也可以通过 setRequestFactory 方法替换为例如 Apache HttpComponents、Netty 或 OkHttp 等其它 HTTP library。</p>\n<p>考虑到 RestTemplate 类是为调用 REST 服务而设计的，因此它的主要方法与 REST 的基础紧密相连就不足为奇了，后者是 HTTP 协议的方法:HEAD、GET、POST、PUT、DELETE 和 OPTIONS。例如，RestTemplate 类具有 headForHeaders()、getForObject()、postForObject()、put()和 delete()等方法。</p>\n<p>下面给大家上案例，案例是重点，通过案例，把我知道的用法都给盘出来。</p>\n<h2>2、案例代码</h2>\n<h3>2.1、git 地址</h3>\n<pre class=\"has\"><code class=\"language-go\">https://gitee.com/javacode2018/springmvc-series</code></pre>\n<p style=\"text-align:center;\"><img alt=\"10d8584b55c22fe2e509a0a93fc0126a.png\" src=\"image\\10d8584b55c22fe2e509a0a93fc0126a.png\"/></p>\n<h3>2.2、关键代码位置</h3>\n<p>文中的所有 controller 代码，在<code>RestTemplateTestController</code>类中。</p>\n<p>所有@Test 用例的代码，在<code>RestTemplateTest</code>。</p>\n<p style=\"text-align:center;\"><img alt=\"3c0bd3eaa63e802b41c52ec909fae3a5.png\" src=\"image\\3c0bd3eaa63e802b41c52ec909fae3a5.png\"/></p>\n<h3>2.3、如何运行测试用例？</h3>\n<ul><li><p>拉取项目</p></li><li><p>将 chat16-RestTemplate 模块发布到 tomcat9 中</p></li><li><p>运行 RestTemplateTest 中对应的用例即可</p></li></ul>\n<p>下面咱们来看 RestTemplate 常见的用法汇总。</p>\n<h2>3、发送 Get 请求</h2>\n<h3>3.1、普通请求</h3>\n<p>接口代码</p>\n<pre class=\"has\"><code class=\"language-go\">@GetMapping(\"/test/get\")\n@ResponseBody\npublic BookDto get() {\n    return new BookDto(1, \"SpringMVC系列\");\n}</code></pre>\n<p>使用 RestTemplate 调用上面这个接口，通常有 2 种写法，如下</p>\n<pre class=\"has\"><code class=\"language-go\">@Test\npublic void test1() {\n    RestTemplate restTemplate = new RestTemplate();\n    String url = \"http://localhost:8080/chat16/test/get\";\n    //getForObject方法，获取响应体，将其转换为第二个参数指定的类型\n    BookDto bookDto = restTemplate.getForObject(url, BookDto.class);\n    System.out.println(bookDto);\n}\n\n@Test\npublic void test2() {\n    RestTemplate restTemplate = new RestTemplate();\n    String url = \"http://localhost:8080/chat16/test/get\";\n    //getForEntity方法，返回值为ResponseEntity类型\n    // ResponseEntity中包含了响应结果中的所有信息，比如头、状态、body\n    ResponseEntity&lt;BookDto&gt; responseEntity = restTemplate.getForEntity(url, BookDto.class);\n    //状态码\n    System.out.println(responseEntity.getStatusCode());\n    //获取头\n    System.out.println(\"头：\" + responseEntity.getHeaders());\n    //获取body\n    BookDto bookDto = responseEntity.getBody();\n    System.out.println(bookDto);\n}</code></pre>\n<p>test1 输出</p>\n<pre class=\"has\"><code class=\"language-go\">BookDto{id=1, name='SpringMVC系列'}</code></pre>\n<p>test2 输出</p>\n<pre class=\"has\"><code class=\"language-go\">200 OK\n头：[Content-Type:\"application/json;charset=UTF-8\", Transfer-Encoding:\"chunked\", Date:\"Sat, 02 Oct 2021 07:05:15 GMT\", Keep-Alive:\"timeout=20\", Connection:\"keep-alive\"]\nBookDto{id=1, name='SpringMVC系列'}</code></pre>\n<h3>3.2、url 中含有动态参数</h3>\n<p>接口代码</p>\n<pre class=\"has\"><code class=\"language-go\">@GetMapping(\"/test/get/{id}/{name}\")\n@ResponseBody\npublic BookDto get(@PathVariable(\"id\") Integer id, @PathVariable(\"name\") String name) {\n    return new BookDto(id, name);\n}</code></pre>\n<p>使用 RestTemplate 调用上面这个接口，通常有 2 种写法，如下</p>\n<pre class=\"has\"><code class=\"language-go\">@Test\npublic void test3() {\n    RestTemplate restTemplate = new RestTemplate();\n    //url中有动态参数\n    String url = \"http://localhost:8080/chat16/test/get/{id}/{name}\";\n    Map&lt;String, String&gt; uriVariables = new HashMap&lt;&gt;();\n    uriVariables.put(\"id\", \"1\");\n    uriVariables.put(\"name\", \"SpringMVC系列\");\n    //使用getForObject或者getForEntity方法\n    BookDto bookDto = restTemplate.getForObject(url, BookDto.class, uriVariables);\n    System.out.println(bookDto);\n}\n\n@Test\npublic void test4() {\n    RestTemplate restTemplate = new RestTemplate();\n    //url中有动态参数\n    String url = \"http://localhost:8080/chat16/test/get/{id}/{name}\";\n    Map&lt;String, String&gt; uriVariables = new HashMap&lt;&gt;();\n    uriVariables.put(\"id\", \"1\");\n    uriVariables.put(\"name\", \"SpringMVC系列\");\n    //getForEntity方法\n    ResponseEntity&lt;BookDto&gt; responseEntity = restTemplate.getForEntity(url, BookDto.class, uriVariables);\n    BookDto bookDto = responseEntity.getBody();\n    System.out.println(bookDto);\n}</code></pre>\n<p>test3 输出</p>\n<pre class=\"has\"><code class=\"language-go\">BookDto{id=1, name='SpringMVC系列'}</code></pre>\n<p>test4 输出</p>\n<pre class=\"has\"><code class=\"language-go\">BookDto{id=1, name='SpringMVC系列'}</code></pre>\n<h3>3.3、接口返回值为泛型</h3>\n<p>接口代码</p>\n<pre class=\"has\"><code class=\"language-go\">@GetMapping(\"/test/getList\")\n@ResponseBody\npublic List&lt;BookDto&gt; getList() {\n    return Arrays.asList(\n            new BookDto(1, \"Spring高手系列\"),\n            new BookDto(2, \"SpringMVC系列\")\n    );\n}</code></pre>\n<p>当接口的返回值为泛型的时候，这种情况比较特殊，使用 RestTemplate 调用上面这个接口，代码如下，需要用到<code>restTemplate.exchange</code>的方法，这个方法中有个参数是<code>ParameterizedTypeReference</code>类型，通过这个参数类指定泛型类型</p>\n<pre class=\"has\"><code class=\"language-go\">@Test\npublic void test5() {\n    RestTemplate restTemplate = new RestTemplate();\n    //返回值为泛型\n    String url = \"http://localhost:8080/chat16/test/getList\";\n    //若返回结果是泛型类型的，需要使用到exchange方法，\n    //这个方法中有个参数是ParameterizedTypeReference类型，通过这个参数类指定泛型类型\n    ResponseEntity&lt;List&lt;BookDto&gt;&gt; responseEntity =\n            restTemplate.exchange(url,\n                    HttpMethod.GET,\n                    null,\n                    new ParameterizedTypeReference&lt;List&lt;BookDto&gt;&gt;() {\n                    });\n    List&lt;BookDto&gt; bookDtoList = responseEntity.getBody();\n    System.out.println(bookDtoList);\n}</code></pre>\n<p>输出</p>\n<pre class=\"has\"><code class=\"language-go\">[BookDto{id=1, name='Spring高手系列'}, BookDto{id=2, name='SpringMVC系列'}]</code></pre>\n<h3>3.4、下载小文件</h3>\n<p>接口代码如下，这个接口会下载服务器端的 1.txt 文件。</p>\n<pre class=\"has\"><code class=\"language-go\">/**\n * 下载文件\n *\n * @return\n */\n@GetMapping(\"/test/downFile\")\n@ResponseBody\npublic HttpEntity&lt;InputStreamResource&gt; downFile() {\n    //将文件流封装为InputStreamResource对象\n    InputStream inputStream = this.getClass().getResourceAsStream(\"/1.txt\");\n    InputStreamResource inputStreamResource = new InputStreamResource(inputStream);\n    //设置header\n    MultiValueMap&lt;String, String&gt; headers = new HttpHeaders();\n    headers.add(HttpHeaders.CONTENT_DISPOSITION, \"attachment;filename=1.txt\");\n    HttpEntity&lt;InputStreamResource&gt; httpEntity = new HttpEntity&lt;&gt;(inputStreamResource);\n    return httpEntity;\n}</code></pre>\n<p>使用 RestTemplate 调用这个接口，代码如下，目前这个文件的内容比较少，可以直接得到一个数组。</p>\n<pre class=\"has\"><code class=\"language-go\">@Test\npublic void test6() {\n    RestTemplate restTemplate = new RestTemplate();\n    String url = \"http://localhost:8080/chat16/test/downFile\";\n    //文件比较小的情况，直接返回字节数组\n    ResponseEntity&lt;byte[]&gt; responseEntity = restTemplate.getForEntity(url, byte[].class);\n    //获取文件的内容\n    byte[] body = responseEntity.getBody();\n    String content = new String(body);\n    System.out.println(content);\n}</code></pre>\n<p>注意：如果文件大的时候，这种方式就有问题了，会导致 oom，要用下面的方式了。</p>\n<h3>3.5、下载大文件</h3>\n<p>接口代码，继续使用上面下载 1.txt 的代码</p>\n<pre class=\"has\"><code class=\"language-go\">/**\n * 下载文件\n *\n * @return\n */\n@GetMapping(\"/test/downFile\")\n@ResponseBody\npublic HttpEntity&lt;InputStreamResource&gt; downFile() {\n    //将文件流封装为InputStreamResource对象\n    InputStream inputStream = this.getClass().getResourceAsStream(\"/1.txt\");\n    InputStreamResource inputStreamResource = new InputStreamResource(inputStream);\n    //设置header\n    MultiValueMap&lt;String, String&gt; headers = new HttpHeaders();\n    headers.add(HttpHeaders.CONTENT_DISPOSITION, \"attachment;filename=1.txt\");\n    HttpEntity&lt;InputStreamResource&gt; httpEntity = new HttpEntity&lt;&gt;(inputStreamResource);\n    return httpEntity;\n}</code></pre>\n<p>此时使用 RestTemplate 调用这个接口，代码如下</p>\n<blockquote>\n<p>文件比较大的时候，比如好几个 G，就不能返回字节数组了，会把内存撑爆，导致 OOM，需要使用 execute 方法了，这个方法中有个 ResponseExtractor 类型的参数，restTemplate 拿到结果之后，会回调{@link ResponseExtractor#extractData}这个方法，在这个方法中可以拿到响应流，然后进行处理，这个过程就是变读边处理，不会导致内存溢出</p>\n</blockquote>\n<pre class=\"has\"><code class=\"language-go\">@Test\npublic void test7() {\n    RestTemplate restTemplate = new RestTemplate();\n    String url = \"http://localhost:8080/chat16/test/downFile\";\n    /**\n     * 文件比较大的时候，比如好几个G，就不能返回字节数组了，会把内存撑爆，导致OOM\n     * 需要这么玩：\n     * 需要使用execute方法了，这个方法中有个ResponseExtractor类型的参数，\n     * restTemplate拿到结果之后，会回调{@link ResponseExtractor#extractData}这个方法，\n     * 在这个方法中可以拿到响应流，然后进行处理，这个过程就是变读边处理，不会导致内存溢出\n     */\n    String result = restTemplate.execute(url,\n            HttpMethod.GET,\n            null,\n            new ResponseExtractor&lt;String&gt;() {\n                @Override\n                public String extractData(ClientHttpResponse response) throws IOException {\n                    System.out.println(\"状态：\"+response.getStatusCode());\n                    System.out.println(\"头：\"+response.getHeaders());\n                    //获取响应体流\n                    InputStream body = response.getBody();\n                    //处理响应体流\n                    String content = IOUtils.toString(body, \"UTF-8\");\n                    return content;\n                }\n            }, new HashMap&lt;&gt;());\n\n    System.out.println(result);\n}</code></pre>\n<h3>3.6、传递头</h3>\n<p>接口代码</p>\n<pre class=\"has\"><code class=\"language-go\">@GetMapping(\"/test/header\")\n@ResponseBody\npublic Map&lt;String, List&lt;String&gt;&gt; header(HttpServletRequest request) {\n    Map&lt;String, List&lt;String&gt;&gt; header = new LinkedHashMap&lt;&gt;();\n    Enumeration&lt;String&gt; headerNames = request.getHeaderNames();\n    while (headerNames.hasMoreElements()) {\n        String name = headerNames.nextElement();\n        Enumeration&lt;String&gt; values = request.getHeaders(name);\n        List&lt;String&gt; list = new ArrayList&lt;&gt;();\n        while (values.hasMoreElements()) {\n            list.add(values.nextElement());\n        }\n        header.put(name, list);\n    }\n    return header;\n}</code></pre>\n<p>使用 RestTemplate 调用接口，请求头中传递数据，代码如下，注意代码<code>①和②</code>，这两处是关键，用到了<code>HttpHeaders</code>和<code>RequestEntity</code></p>\n<blockquote>\n<ul><li><p>请求头放在 HttpHeaders 对象中</p></li><li><p>RequestEntity：请求实体，请求的所有信息都可以放在 RequestEntity 中，比如 body 部分、头、请求方式、url 等信息</p></li></ul>\n</blockquote>\n<pre class=\"has\"><code class=\"language-go\">@Test\npublic void test8() {\n    RestTemplate restTemplate = new RestTemplate();\n    String url = \"http://localhost:8080/chat16/test/header\";\n    //①：请求头放在HttpHeaders对象中\n    MultiValueMap&lt;String, String&gt; headers = new HttpHeaders();\n    headers.add(\"header-1\", \"V1\");\n    headers.add(\"header-2\", \"Spring\");\n    headers.add(\"header-2\", \"SpringBoot\");\n    //②：RequestEntity：请求实体，请求的所有信息都可以放在RequestEntity中，比如body部分、头、请求方式、url等信息\n    RequestEntity requestEntity = new RequestEntity(\n            null, //body部分数据\n            headers, //头\n            HttpMethod.GET,//请求方法\n            URI.create(url) //地址\n    );\n    ResponseEntity&lt;Map&lt;String, List&lt;String&gt;&gt;&gt; responseEntity = restTemplate.exchange(requestEntity,\n            new ParameterizedTypeReference&lt;Map&lt;String, List&lt;String&gt;&gt;&gt;() {\n            });\n    Map&lt;String, List&lt;String&gt;&gt; result = responseEntity.getBody();\n    System.out.println(result);\n}</code></pre>\n<p>输出</p>\n<pre class=\"has\"><code class=\"language-go\">{accept=[application/json, application/*+json], header-1=[V1], header-2=[Spring, SpringBoot], user-agent=[Java/1.8.0_121], host=[localhost:8080], connection=[keep-alive]}</code></pre>\n<h3>3.7、综合案例：含头、url 动态参数</h3>\n<p>接口</p>\n<pre class=\"has\"><code class=\"language-go\">@GetMapping(\"/test/getAll/{path1}/{path2}\")\n@ResponseBody\npublic Map&lt;String, Object&gt; getAll(@PathVariable(\"path1\") String path1,\n                                  @PathVariable(\"path2\") String path2,\n                                  HttpServletRequest request) {\n    Map&lt;String, Object&gt; result = new LinkedHashMap&lt;&gt;();\n    result.put(\"path1\", path1);\n    result.put(\"path2\", path2);\n    //头\n    Map&lt;String, List&lt;String&gt;&gt; header = new LinkedHashMap&lt;&gt;();\n    Enumeration&lt;String&gt; headerNames = request.getHeaderNames();\n    while (headerNames.hasMoreElements()) {\n        String name = headerNames.nextElement();\n        Enumeration&lt;String&gt; values = request.getHeaders(name);\n        List&lt;String&gt; list = new ArrayList&lt;&gt;();\n        while (values.hasMoreElements()) {\n            list.add(values.nextElement());\n        }\n        header.put(name, list);\n    }\n    result.put(\"header\", header);\n    return result;\n}</code></pre>\n<p>如下，使用 RestTemplate 调用接口，GET 方式、传递 header、path 中动态参数。</p>\n<pre class=\"has\"><code class=\"language-go\">@Test\npublic void test9() {\n    RestTemplate restTemplate = new RestTemplate();\n    String url = \"http://localhost:8080/chat16/test/getAll/{path1}/{path2}\";\n    //①：请求头\n    MultiValueMap&lt;String, String&gt; headers = new HttpHeaders();\n    headers.add(\"header-1\", \"V1\");\n    headers.add(\"header-2\", \"Spring\");\n    headers.add(\"header-2\", \"SpringBoot\");\n    //②：url中的2个参数\n    Map&lt;String, String&gt; uriVariables = new HashMap&lt;&gt;();\n    uriVariables.put(\"path1\", \"v1\");\n    uriVariables.put(\"path2\", \"v2\");\n    //③：HttpEntity：HTTP实体，内部包含了请求头和请求体\n    HttpEntity requestEntity = new HttpEntity(\n        null,//body部分，get请求没有body，所以为null\n        headers //头\n    );\n    //④：使用exchange发送请求\n    ResponseEntity&lt;Map&lt;String, Object&gt;&gt; responseEntity = restTemplate.exchange(\n        url, //url\n        HttpMethod.GET, //请求方式\n        requestEntity, //请求实体（头、body）\n        new ParameterizedTypeReference&lt;Map&lt;String, Object&gt;&gt;() {\n        },//返回的结果类型\n        uriVariables //url中的占位符对应的值\n    );\n    Map&lt;String, Object&gt; result = responseEntity.getBody();\n    System.out.println(result);\n}</code></pre>\n<p>输出</p>\n<pre class=\"has\"><code class=\"language-go\">{path1=v1, path2=v2, header={accept=[application/json, application/*+json], header-1=[V1], header-2=[Spring, SpringBoot], user-agent=[Java/1.8.0_121], host=[localhost:8080], connection=[keep-alive]}}</code></pre>\n<h2>4、POST 请求</h2>\n<h3>4.1、post 请求常见的 3 种类型</h3>\n<p>http 请求头中的 Content-Type 用来指定请求的类型，常见的有 3 种</p>\n<table><thead><tr><th>Content-Type</th><th>说明</th></tr></thead><tbody><tr><td>application/x-www-form-urlencoded</td><td>页面中普通的 form 表单提交时就是这种类型，表单中的元素会按照名称和值拼接好，然后之间用&amp;连接，格式如：p1=v1&amp;p2=v2&amp;p3=v3<br/>然后通过 urlencoded 编码之后丢在 body 中发送</td></tr><tr><td>multipart/form-data</td><td>页面中表单上传文件的时候，用到的就是这种格式</td></tr><tr><td>application/json</td><td>将发送的数据转换为 json 格式，丢在 http 请求的 body 中发送，后端接口通常用@RequestBody 配合对象来接收。</td></tr></tbody></table>\n<p>下面看则种方式的案例。</p>\n<h3>4.2、普通表单请求</h3>\n<p>普通表单默认为 application/x-www-form-urlencoded 类型的请求。</p>\n<p>接口代码</p>\n<pre class=\"has\"><code class=\"language-go\">@PostMapping(\"/test/form1\")\n@ResponseBody\npublic BookDto form1(BookDto bookDto) {\n    return bookDto;\n}</code></pre>\n<p>使用 RestTemplate 调用接口</p>\n<pre class=\"has\"><code class=\"language-go\">@Test\npublic void test10() {\n    RestTemplate restTemplate = new RestTemplate();\n    String url = \"http://localhost:8080/chat16/test/form1\";\n    //①：表单信息，需要放在MultiValueMap中，MultiValueMap相当于Map&lt;String,List&lt;String&gt;&gt;\n    MultiValueMap&lt;String, String&gt; body = new LinkedMultiValueMap&lt;&gt;();\n    //调用add方法填充表单数据(表单名称:值)\n    body.add(\"id\",\"1\");\n    body.add(\"name\",\"SpringMVC系列\");\n    //②：发送请求(url,请求体，返回值需要转换的类型)\n    BookDto result = restTemplate.postForObject(url, body, BookDto.class);\n    System.out.println(result);\n}</code></pre>\n<p>如果想携带头信息，代码如下</p>\n<pre class=\"has\"><code class=\"language-go\">@Test\npublic void test11() {\n    RestTemplate restTemplate = new RestTemplate();\n    String url = \"http://localhost:8080/chat16/test/form1\";\n    //①：表单信息，需要放在MultiValueMap中，MultiValueMap相当于Map&lt;String,List&lt;String&gt;&gt;\n    MultiValueMap&lt;String, String&gt; body = new LinkedMultiValueMap&lt;&gt;();\n    //调用add方法放入表单元素(表单名称:值)\n    body.add(\"id\",\"1\");\n    body.add(\"name\",\"SpringMVC系列\");\n    //②：请求头\n    HttpHeaders headers = new HttpHeaders();\n    //调用set方法放入请求头\n    headers.set(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_FORM_URLENCODED_VALUE);\n    //③：请求实体：包含了请求体和请求头\n    HttpEntity&lt;MultiValueMap&lt;String, String&gt;&gt; httpEntity = new HttpEntity&lt;&gt;(body, headers);\n    //④：发送请求(url,请求实体，返回值需要转换的类型)\n    BookDto result = restTemplate.postForObject(url, httpEntity, BookDto.class);\n    System.out.println(result);\n}</code></pre>\n<h3>4.3、上传本地文件</h3>\n<p>上传文件 Content-Type 为 multipart/form-data 类型。</p>\n<p>接口如下，上传上传单个文件，返回值为一个 Map 类型，是泛型类型</p>\n<pre class=\"has\"><code class=\"language-go\">@PostMapping(value = \"/test/form2\")\n@ResponseBody\npublic Map&lt;String, String&gt; form2(@RequestParam(\"file1\") MultipartFile file1) {\n    Map&lt;String, String&gt; fileMetadata = new LinkedHashMap&lt;&gt;();\n    fileMetadata.put(\"文件名\", file1.getOriginalFilename());\n    fileMetadata.put(\"文件类型\", file1.getContentType());\n    fileMetadata.put(\"文件大小(byte)\", String.valueOf(file1.getSize()));\n    return fileMetadata;\n}</code></pre>\n<p>使用 RestTemplate 调用接口，主要下面代码<code>②</code>上传的文件需要包装为<code>org.springframework.core.io.Resource</code>，常用的有 3 中[FileSystemResource、InputStreamResource、ByteArrayResource]，这里案例中我们用到的是 FileSystemResource 来上传本地文件，另外 2 种（InputStreamResource、ByteArrayResource）用法就比较特殊了，见下个案例。</p>\n<pre class=\"has\"><code class=\"language-go\">@Test\npublic void test12() {\n    RestTemplate restTemplate = new RestTemplate();\n    String url = \"http://localhost:8080/chat16/test/form2\";\n    //①：表单信息，需要放在MultiValueMap中，MultiValueMap相当于Map&lt;String,List&lt;String&gt;&gt;\n    MultiValueMap&lt;String, Object&gt; body = new LinkedMultiValueMap&lt;&gt;();\n    //调用add方法放入表单元素(表单名称:值)\n    //②：文件对应的类型，需要是org.springframework.core.io.Resource类型的，常见的有[FileSystemResource、InputStreamResource、ByteArrayResource]\n    body.add(\"file1\", new FileSystemResource(\".\\\\src\\\\main\\\\java\\\\com\\\\javacode2018\\\\springmvc\\\\chat16\\\\dto\\\\UserDto.java\"));\n    //③：头\n    HttpHeaders headers = new HttpHeaders();\n    headers.add(\"header1\", \"v1\");\n    headers.add(\"header2\", \"v2\");\n    //④：请求实体\n    RequestEntity&lt;MultiValueMap&lt;String, Object&gt;&gt; requestEntity = new RequestEntity&lt;&gt;(body, headers, HttpMethod.POST, URI.create(url));\n    //⑤：发送请求(请求实体，返回值需要转换的类型)\n    ResponseEntity&lt;Map&lt;String, String&gt;&gt; responseEntity = restTemplate.exchange(\n        requestEntity,\n        new ParameterizedTypeReference&lt;Map&lt;String, String&gt;&gt;() {\n        });\n    Map&lt;String, String&gt; result = responseEntity.getBody();\n    System.out.println(result);\n}</code></pre>\n<h3>4.4、通过流或字节数组的方式上传文件</h3>\n<blockquote>\n<p>有时候，上传的文件是通过流的方式或者字节数组的方式，那么就需要用到 InputStreamResource、ByteArrayResource 这俩了。</p>\n<p>**注意：**使用这俩的时候，需要重写 2 个方法，否则会上传失败</p>\n<ul><li><p>getFilename：文件名称</p></li><li><p>contentLength：长度</p></li></ul>\n</blockquote>\n<pre class=\"has\"><code class=\"language-go\">@Test\npublic void test13() {\n    RestTemplate restTemplate = new RestTemplate();\n    String url = \"http://localhost:8080/chat16/test/form2\";\n    //①：表单信息，需要放在MultiValueMap中，MultiValueMap相当于Map&lt;String,List&lt;String&gt;&gt;\n    MultiValueMap&lt;String, Object&gt; body = new LinkedMultiValueMap&lt;&gt;();\n    /**\n     * ②：通过流的方式上传文件，流的方式需要用到InputStreamResource类，需要重写2个方法\n     * getFilename：文件名称\n     * contentLength：长度\n     */\n    InputStream inputStream = RestTemplateTest.class.getResourceAsStream(\"/1.txt\");\n    InputStreamResource inputStreamResource = new InputStreamResource(inputStream) {\n        @Override\n        public String getFilename() {\n            return \"1.txt\";\n        }\n\n        @Override\n        public long contentLength() throws IOException {\n            return inputStream.available();\n        }\n    };\n    body.add(\"file1\", inputStreamResource);\n    //③：头\n    HttpHeaders headers = new HttpHeaders();\n    headers.add(\"header1\", \"v1\");\n    headers.add(\"header2\", \"v2\");\n    //④：请求实体\n    RequestEntity&lt;MultiValueMap&lt;String, Object&gt;&gt; requestEntity = new RequestEntity&lt;&gt;(body, headers, HttpMethod.POST, URI.create(url));\n    //⑤：发送请求(请求实体，返回值需要转换的类型)\n    ResponseEntity&lt;Map&lt;String, String&gt;&gt; responseEntity = restTemplate.exchange(\n            requestEntity,\n            new ParameterizedTypeReference&lt;Map&lt;String, String&gt;&gt;() {\n            });\n    Map&lt;String, String&gt; result = responseEntity.getBody();\n    System.out.println(result);\n}</code></pre>\n<h3>4.5、复杂表单：多个普通元素+多文件上传</h3>\n<p>接口</p>\n<pre class=\"has\"><code class=\"language-go\">/**\n * 复杂的表单：包含了普通元素、多文件\n *\n * @param userDto\n * @return\n */\n@PostMapping(\"/test/form3\")\n@ResponseBody\npublic Map&lt;String, String&gt; form3(UserDto userDto) {\n    Map&lt;String, String&gt; result = new LinkedHashMap&lt;&gt;();\n    result.put(\"name\", userDto.getName());\n    result.put(\"headImg\", userDto.getHeadImg().getOriginalFilename());\n    result.put(\"idImgList\", Arrays.toString(userDto.getIdImgList().stream().\n                                            map(MultipartFile::getOriginalFilename).toArray()));\n    return result;\n}</code></pre>\n<p>UserDto：包含了多个元素（姓名、头像、多张证件照），这种可以模拟复杂的表单</p>\n<pre class=\"has\"><code class=\"language-go\">public class UserDto {\n    //姓名\n    private String name;\n    //头像\n    private MultipartFile headImg;\n    //多张证件照\n    private List&lt;MultipartFile&gt; idImgList;\n\n    //get set 省略了...\n}</code></pre>\n<p>用 RestTemplate 调用这个接口，代码如下</p>\n<pre class=\"has\"><code class=\"language-go\">@Test\npublic void test14() {\n    RestTemplate restTemplate = new RestTemplate();\n    String url = \"http://localhost:8080/chat16/test/form3\";\n    //①：表单信息，需要放在MultiValueMap中，MultiValueMap相当于Map&lt;String,List&lt;String&gt;&gt;\n    MultiValueMap&lt;String, Object&gt; body = new LinkedMultiValueMap&lt;&gt;();\n    body.add(\"name\", \"路人\");\n    body.add(\"headImg\", new FileSystemResource(\".\\\\src\\\\main\\\\resources\\\\1.jpg\"));\n    //来2张证件照，元素名称一样\n    body.add(\"idImgList\", new FileSystemResource(\".\\\\src\\\\main\\\\resources\\\\2.jpg\"));\n    body.add(\"idImgList\", new FileSystemResource(\".\\\\src\\\\main\\\\resources\\\\3.jpg\"));\n    //③：头\n    HttpHeaders headers = new HttpHeaders();\n    headers.add(\"header1\", \"v1\");\n    headers.add(\"header2\", \"v2\");\n    //④：请求实体\n    RequestEntity&lt;MultiValueMap&lt;String, Object&gt;&gt; requestEntity = new RequestEntity&lt;&gt;(body, headers, HttpMethod.POST, URI.create(url));\n    //⑤：发送请求(请求实体，返回值需要转换的类型)\n    ResponseEntity&lt;Map&lt;String, String&gt;&gt; responseEntity = restTemplate.exchange(\n            requestEntity,\n            new ParameterizedTypeReference&lt;Map&lt;String, String&gt;&gt;() {\n            });\n    Map&lt;String, String&gt; result = responseEntity.getBody();\n    System.out.println(result);\n}</code></pre>\n<p>输出</p>\n<pre class=\"has\"><code class=\"language-go\">{name=路人, headImg=1.jpg, idImgList=[2.jpg, 3.jpg]}</code></pre>\n<h3>4.6、发送 json 格式数据：传递 java 对象</h3>\n<p>接口</p>\n<pre class=\"has\"><code class=\"language-go\">/**\n * body中json格式的数据，返回值非泛型\n *\n * @param bookDto\n * @return\n */\n@PostMapping(\"/test/form4\")\n@ResponseBody\npublic BookDto form4(@RequestBody BookDto bookDto) {\n    return bookDto;\n}</code></pre>\n<p>RestTemplate 调用接口</p>\n<pre class=\"has\"><code class=\"language-go\">@Test\npublic void test15() {\n    RestTemplate restTemplate = new RestTemplate();\n    String url = \"http://localhost:8080/chat16/test/form4\";\n    BookDto body = new BookDto(1, \"SpringMVC系列\");\n    BookDto result = restTemplate.postForObject(url, body, BookDto.class);\n    System.out.println(result);\n}</code></pre>\n<p>输出</p>\n<pre class=\"has\"><code class=\"language-go\">BookDto{id=1, name='SpringMVC系列'}</code></pre>\n<h3>4.7、发送 json 格式数据：传递 java 对象，返回值为泛型</h3>\n<p>接口</p>\n<pre class=\"has\"><code class=\"language-go\">/**\n * body中json格式的数据，返回值为泛型\n *\n * @param bookDtoList\n * @return\n */\n@PostMapping(\"/test/form5\")\n@ResponseBody\npublic List&lt;BookDto&gt; form5(@RequestBody List&lt;BookDto&gt; bookDtoList) {\n    return bookDtoList;\n}</code></pre>\n<p>用 RestTemplate 调用这个接口，代码如下</p>\n<pre class=\"has\"><code class=\"language-go\">@Test\npublic void test16() {\n    RestTemplate restTemplate = new RestTemplate();\n    String url = \"http://localhost:8080/chat16/test/form5\";\n    //①：请求体，发送的时候会被转换为json格式数据\n    List&lt;BookDto&gt; body = Arrays.asList(\n            new BookDto(1, \"SpringMVC系列\"),\n            new BookDto(2, \"MySQL系列\"));\n    //②：头\n    HttpHeaders headers = new HttpHeaders();\n    headers.add(\"header1\", \"v1\");\n    headers.add(\"header2\", \"v2\");\n    //③：请求实体\n    RequestEntity requestEntity = new RequestEntity(body, headers, HttpMethod.POST, URI.create(url));\n    //④：发送请求(请求实体，返回值需要转换的类型)\n    ResponseEntity&lt;List&lt;BookDto&gt;&gt; responseEntity = restTemplate.exchange(\n            requestEntity,\n            new ParameterizedTypeReference&lt;List&lt;BookDto&gt;&gt;() {\n            });\n    //⑤：获取结果\n    List&lt;BookDto&gt; result = responseEntity.getBody();\n    System.out.println(result);\n}</code></pre>\n<p>输出</p>\n<pre class=\"has\"><code class=\"language-go\">[BookDto{id=1, name='SpringMVC系列'}, BookDto{id=2, name='MySQL系列'}]</code></pre>\n<h3>4.8、发送 json 字符串格式数据</h3>\n<p>上面 2 个 json 案例 body 都是 java 对象，RestTemplate 默认自动配上 Content-Type=application/json</p>\n<p>但是如果 body 的值是 json 格式字符串的时候，调用的时候需要在头中明确指定 Content-Type=application/json，写法如下：</p>\n<pre class=\"has\"><code class=\"language-go\">@Test\npublic void test17() {\n    RestTemplate restTemplate = new RestTemplate();\n    String url = \"http://localhost:8080/chat16/test/form5\";\n    //①：请求体为一个json格式的字符串\n    String body = \"[{\\\"id\\\":1,\\\"name\\\":\\\"SpringMVC系列\\\"},{\\\"id\\\":2,\\\"name\\\":\\\"MySQL系列\\\"}]\";\n    /**\n     * ②：若请求体为json字符串的时候，需要在头中设置Content-Type=application/json；\n     * 若body是普通的java类的时候，无需指定这个，RestTemplate默认自动配上Content-Type=application/json\n     */\n    HttpHeaders headers = new HttpHeaders();\n    headers.setContentType(MediaType.APPLICATION_JSON);\n    //③：请求实体（body，头、请求方式，uri）\n    RequestEntity requestEntity = new RequestEntity(body, headers, HttpMethod.POST, URI.create(url));\n    //④：发送请求(请求实体，返回值需要转换的类型)\n    ResponseEntity&lt;List&lt;BookDto&gt;&gt; responseEntity = restTemplate.exchange(\n            requestEntity,\n            new ParameterizedTypeReference&lt;List&lt;BookDto&gt;&gt;() {\n            });\n    //⑤：获取结果\n    List&lt;BookDto&gt; result = responseEntity.getBody();\n    System.out.println(result);\n}</code></pre>\n<p>输出</p>\n<pre class=\"has\"><code class=\"language-go\">[BookDto{id=1, name='SpringMVC系列'}, BookDto{id=2, name='MySQL系列'}]</code></pre>\n<h2>5、DELETE、PUT、OPTION 请求</h2>\n<h3>5.1、DELETE 请求</h3>\n<pre class=\"has\"><code class=\"language-go\">public void delete(String url, Object... uriVariables);\npublic void delete(String url, Map&lt;String, ?&gt; uriVariables);\npublic void delete(URI url);</code></pre>\n<h3>5.2、PUT 请求</h3>\n<p>PUT 请求和 POST 请求类似，将类型改为 PUT 就可以了。</p>\n<h3>5.3、OPTIONS 请求</h3>\n<blockquote>\n<p>OPTIONS 请求用来探测接口支持哪些 http 方法</p>\n</blockquote>\n<pre class=\"has\"><code class=\"language-go\">public Set&lt;HttpMethod&gt; optionsForAllow(String url, Object... uriVariables);\npublic Set&lt;HttpMethod&gt; optionsForAllow(String url, Map&lt;String, ?&gt; uriVariables);\npublic Set&lt;HttpMethod&gt; optionsForAllow(URI url);</code></pre>\n<h2>6、集成 HttpClient</h2>\n<blockquote>\n<p>RestTemplate 内部默认用的是 jdk 自带的 HttpURLConnection 发送请求的，性能上面并不是太突出。</p>\n<p>可以将其替换为 httpclient 或者 okhttp。</p>\n<p>先来看下如何替换为 HttpClient。</p>\n</blockquote>\n<p>引入 maven 配置</p>\n<pre class=\"has\"><code class=\"language-go\">&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;\n    &lt;artifactId&gt;httpclient&lt;/artifactId&gt;\n    &lt;version&gt;4.5.7&lt;/version&gt;\n&lt;/dependency&gt;</code></pre>\n<p>创建 RestTemplate 时指定 HttpClient 配置，代码如下</p>\n<pre class=\"has\"><code class=\"language-go\">public HttpClient httpClient() {\n    HttpClientBuilder httpClientBuilder = HttpClientBuilder.create();\n    try {\n        //设置信任ssl访问\n        SSLContext sslContext = new SSLContextBuilder().loadTrustMaterial(null, (arg0, arg1) -&gt; true).build();\n        httpClientBuilder.setSSLContext(sslContext);\n        HostnameVerifier hostnameVerifier = NoopHostnameVerifier.INSTANCE;\n        SSLConnectionSocketFactory sslConnectionSocketFactory = new SSLConnectionSocketFactory(sslContext, hostnameVerifier);\n        Registry&lt;ConnectionSocketFactory&gt; socketFactoryRegistry = RegistryBuilder.&lt;ConnectionSocketFactory&gt;create()\n                // 注册http和https请求\n                .register(\"http\", PlainConnectionSocketFactory.getSocketFactory())\n                .register(\"https\", sslConnectionSocketFactory).build();\n\n        //使用Httpclient连接池的方式配置(推荐)，同时支持netty，okHttp以及其他http框架\n        PoolingHttpClientConnectionManager poolingHttpClientConnectionManager = new PoolingHttpClientConnectionManager(socketFactoryRegistry);\n        // 最大连接数\n        poolingHttpClientConnectionManager.setMaxTotal(1000);\n        // 同路由并发数\n        poolingHttpClientConnectionManager.setDefaultMaxPerRoute(100);\n        //配置连接池\n        httpClientBuilder.setConnectionManager(poolingHttpClientConnectionManager);\n        // 重试次数\n        httpClientBuilder.setRetryHandler(new DefaultHttpRequestRetryHandler(0, true));\n        //设置默认请求头\n        List&lt;Header&gt; headers = new ArrayList&lt;&gt;();\n        httpClientBuilder.setDefaultHeaders(headers);\n        return httpClientBuilder.build();\n    } catch (Exception e) {\n        throw new RuntimeException(e);\n    }\n}\n\npublic ClientHttpRequestFactory clientHttpRequestFactory() {\n    HttpComponentsClientHttpRequestFactory clientHttpRequestFactory = new HttpComponentsClientHttpRequestFactory(httpClient());\n    // 连接超时(毫秒)，这里设置10秒\n    clientHttpRequestFactory.setConnectTimeout(10 * 1000);\n    // 数据读取超时时间(毫秒)，这里设置60秒\n    clientHttpRequestFactory.setReadTimeout(60 * 1000);\n    // 从连接池获取请求连接的超时时间(毫秒)，不宜过长，必须设置，比如连接不够用时，时间过长将是灾难性的\n    clientHttpRequestFactory.setConnectionRequestTimeout(10 * 1000);\n    return clientHttpRequestFactory;\n}\n\npublic RestTemplate restTemplate(){\n    //创建RestTemplate的时候，指定ClientHttpRequestFactory\n    return new RestTemplate(this.clientHttpRequestFactory());\n}\n\n@Test\npublic void test18() {\n    RestTemplate restTemplate = this.restTemplate();\n    String url = \"http://localhost:8080/chat16/test/get\";\n    //getForObject方法，获取响应体，将其转换为第二个参数指定的类型\n    BookDto bookDto = restTemplate.getForObject(url, BookDto.class);\n    System.out.println(bookDto);\n}</code></pre>\n<h2>7、集成 okhttp</h2>\n<p>引入 maven 配置</p>\n<pre class=\"has\"><code class=\"language-go\">&lt;dependency&gt;\n    &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt;\n    &lt;artifactId&gt;okhttp&lt;/artifactId&gt;\n    &lt;version&gt;4.3.1&lt;/version&gt;\n&lt;/dependency&gt;</code></pre>\n<p>创建 RestTemplate</p>\n<pre class=\"has\"><code class=\"language-go\">new RestTemplate(new OkHttp3ClientHttpRequestFactory());</code></pre>\n<h2>8、总结</h2>\n<p>RestTemplate 使用确实非常容易，建议大家去看一下 RestTemplate 的源码，debug 跟踪一下过程，这样用起来就非常顺手了。</p>\n<p>《<a href=\"https://blog.csdn.net/qq_43810938/article/details/118229084\">尚硅谷 Java 学科全套教程（总 207.77GB）</a></p>\n<h2>9、SpringMVC 系列目录</h2>\n<ol><li><p><a href=\"https://blog.csdn.net/likun557/article/details/120620328\">SpringMVC 系列第 1 篇：helloword</a></p></li><li><p><a href=\"https://blog.csdn.net/weixin_43281120/article/details/104579041\">SpringMVC 系列第 2 篇：@Controller、@RequestMapping</a></p></li><li><p><a href=\"https://blog.csdn.net/likun557/article/details/120072794\">SpringMVC 系列第 3 篇：异常高效的一款接口测试利器</a></p></li><li><p><a href=\"https://blog.csdn.net/likun557/article/details/120620328\">SpringMVC 系列第 4 篇：controller 常见的接收参数的方式</a></p></li><li><p><a href=\"https://blog.csdn.net/weixin_37794901/article/details/102589744\">SpringMVC 系列第 5 篇：@RequestBody 大解密，说点你不知道的</a></p></li><li><p><a href=\"https://blog.csdn.net/likun557/article/details/118865329\">SpringMVC 系列第 6 篇：上传文件的 4 种方式，你都会么？</a></p></li><li><p><a href=\"https://blog.csdn.net/weixin_33978044/article/details/92488405\">SpringMVC 系列第 7 篇：SpringMVC 返回视图常见的 5 种方式，你会几种？</a></p></li><li><p><a href=\"https://blog.csdn.net/likun557/article/details/120072794\">SpringMVC 系列第 8 篇：返回 json &amp; 通用返回值设计</a></p></li><li><p><a href=\"https://blog.csdn.net/qq598535550/article/details/51703190\">SpringMVC 系列第 9 篇：SpringMVC 返回 null 是什么意思？</a></p></li><li><p><a href=\"https://blog.csdn.net/likun557/article/details/119066603\">SpringMVC 系列第 10 篇：异步处理</a></p></li><li><p><a href=\"https://blog.csdn.net/likun557/article/details/119582956\">SpringMVC 系列第 11 篇：集成静态资源</a></p></li><li><p><a href=\"https://blog.csdn.net/linmengmeng_1314/article/details/82596081\">SpringMVC 系列第 12 篇：拦截器</a></p></li><li><p><a href=\"https://blog.csdn.net/qq_29445811/article/details/110292414\">SpringMVC 系列第 13 篇：统一异常处理</a></p></li><li><p><a href=\"https://blog.csdn.net/likun557/article/details/120620328\">SpringMVC 系列第 14 篇：实战篇：通用返回值 &amp; 异常处理设计</a></p></li><li><p><a href=\"https://blog.csdn.net/likun557/article/details/120620328\">SpringMVC 系列第 15 篇：全注解的方式  &amp;  原理解析</a></p></li><li><p><a href=\"https://blog.csdn.net/Heron22/article/details/109456726\">SpringMVC 系列第 16 篇：通过源码解析 SpringMVC 处理请求的流程</a></p></li><li><p><a href=\"https://blog.csdn.net/likun557/article/details/120620328\">SpringMVC 系列第 17 篇：源码解析 SpringMVC 容器的启动过程</a></p></li><li><p><a href=\"https://blog.csdn.net/likun557/article/details/120928750\">SpringMVC 系列第 18 篇：强大的 RequestBodyAdvice 解密</a></p></li><li><p><a href=\"https://blog.csdn.net/xiyang_1990/article/details/103093316\">SpringMVC 系列第 19 篇：强大的 ResponseBodyAdvice 解密</a></p></li><li><p><a href=\"https://blog.csdn.net/ITITII/article/details/80082227\">SpringMVC 系列第 20 篇：RestFull 详解</a></p></li></ol>\n<h2>10、更多好文章</h2>\n<ol><li><p><a href=\"https://blog.csdn.net/likun557/article/details/120620328\">Spring 高手系列（共 56 篇）</a></p></li><li><p><a href=\"https://blog.csdn.net/nihui123/article/details/89609060\">Java 高并发系列（共 34 篇）</a></p></li><li><p><a href=\"https://blog.csdn.net/p15097962069/article/details/113795231\">MySql 高手系列（共 27 篇）</a></p></li><li><p><a href=\"https://blog.csdn.net/likun557/article/details/103046559\">Maven 高手系列（共 10 篇）</a></p></li><li><p><a href=\"https://blog.csdn.net/cmm0401/article/details/106851242\">Mybatis 系列（共 12 篇）</a></p></li><li><p><a href=\"https://blog.csdn.net/good575654643/article/details/102680093\">聊聊 db 和缓存一致性常见的实现方式</a></p></li><li><p><a href=\"https://blog.csdn.net/qq_41973594/article/details/109684180\">接口幂等性这么重要，它是什么？怎么实现？</a></p></li><li><p><a href=\"https://blog.csdn.net/u014400934/article/details/105132279\">泛型，有点难度，会让很多人懵逼，那是因为你没有看这篇文章！</a></p></li></ol>\n<h2>11、【路人甲 Java】所有系列高清 PDF</h2>\n<p style=\"text-align:center;\"><strong>领取方式，扫码发送：yyds</strong></p>\n<p style=\"text-align:center;\"><img alt=\"84e19fb78bd1cedc2cba886ea5c699bc.png\" src=\"image\\84e19fb78bd1cedc2cba886ea5c699bc.png\"/></p>\n</div>\n</div>\n</div>"}