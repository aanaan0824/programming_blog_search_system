{"blogid": "126702732", "writerAge": "码龄6年", "writerBlogNum": "772", "writerCollect": "3194", "writerComment": "104", "writerFan": "1008", "writerGrade": "7级", "writerIntegral": "15014", "writerName": "wespten", "writerProfileAdress": "writer_image\\profile_126702732.jpg", "writerRankTotal": "734", "writerRankWeekly": "503", "writerThumb": "662", "writerVisitNum": "1139019", "blog_read_count": "372", "blog_time": "已于 2022-09-05 18:35:11 修改", "blog_title": "Shell脚本详解", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h2>一、Shell基础</h2>\n<h3>1、Shell 简介</h3>\n<p>Shell 是一个 C 语言编写的脚本语言，它是用户与 Linux 的桥梁，用户输入命令交给 Shell 处理，<br/> Shell 将相应的操作传递给内核（Kernel），内核把处理的结果输出给用户。</p>\n<p>下面是流程示意图：</p>\n<p><img alt=\"\" height=\"299\" src=\"image\\2b0b854472d34d33854d8a8677d37c2b.png\" width=\"461\"/></p>\n<p>Shell 既然是工作在 Linux 内核之上，那我们也有必要了解下 Linux 相关知识。</p>\n<p>Linux 是一套免费试用和自由传播的类 Unix 操作系统，是一个基于 POSIX 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。</p>\n<p>1983 年 9 月 27 日，Richard Stallman（理查德-马修-斯托曼）发起 GNU 计划，它的目标是创建一套完全自由的操作系统。为保证 GNU 软件可以自由的使用、复制、修改和发布，所有的 GNU 软件都有一份在禁止其他人添加任何限制的情况下授权所有权利给任何人的协议条款，GNU 通用公共许可证（GNU General Plubic License，GPL），说白了就是不能做商业用途。</p>\n<p>GNU 是\"GNU is Not Unix\"的递归缩写。UNIX 是一种广泛使用的商业操作系统的名称。</p>\n<p>1985 年，Richard Stallman 又创立了自由软件基金会（Free Software Foundation，FSF）来为<br/> GNU 计划提供技术、法律以及财政支持。</p>\n<p>1990 年，GNU 计划开发主要项目有 Emacs（文本编辑器）、GCC（GNU Compiler Collection，GNU 编译器集合）、Bash 等，GCC 是一套 GNU 开发的编程语言编译器。还有开发一些 UNIX 系统的程序库和工具。</p>\n<p>1991 年，Linuxs Torvalds（林纳斯- 托瓦兹）开发出了与 UNIX 兼容的 Linux 操作系统内核并在<br/> GPL 条款下发布。</p>\n<p>1992 年，Linux 与其他 GUN 软件结合，完全自由的 GUN/Linux 操作系统正式诞生，简称 Linux。</p>\n<p>1995 年 1 月，Bob Young 创办 ACC 公司，以 GNU/Linux 为核心，开发出了 RedHat Linux 商业版。</p>\n<p>Linux 基本思想有两点：第一，一切都是文件；第二，每个软件都有确定的用途。与 Unix 思想十分相近。 </p>\n<h3>2、Shell 基本分两大类</h3>\n<p>1）图形界面 Shell（GUI Shell）</p>\n<p>GUI 为 Unix 或者类 Unix 操作系统构造一个功能完善、操作简单以及界面友好的桌面环境。主流桌面环境有 KDE，Gnome 等。</p>\n<p>2）命令行界面 Shell（CLI Shell）</p>\n<p>CLI 是在用户提示符下键入可执行指令的界面，用户通过键盘输入指令，完成一系列操作。</p>\n<p>在 Linux 系统上主流的 CLI 实现是 Bash，是许多 Linux 发行版默认的 Shell。还有许多 Unix 上<br/> Shell，例如 tcsh、csh、ash、bsh、ksh 等。</p>\n<h3>3、第一个Shell脚本 </h3>\n<p>主要讲解在大多Linux发行版下默认Bash Shell。Linux系统是RedHat下的CentOS 操作系统，完全免费。与其商业版RHEL（Red Hat Enterprise Linux）出自同样的源代码，不同的是CentOS并不包含封闭源代码软件和售后支持。 </p>\n<p>用vi打开test.sh，编写： </p>\n<pre><code># vi test.sh\n#!/bin/bash\necho \"Hello world!\"</code></pre>\n<div>\n 第一行指定解释器，第二行打印 Hello world！ 写好后，开始执行，执行 Shell 脚本有三种方法： \n</div>\n<div>\n 方法 1：直接用 bash 解释器执行：\n</div>\n<div>\n<pre><code># bash test.sh\nHello world!</code></pre>\n<div>\n<span style=\"color:#000000;\">当前终端会新生成一个子 bash 去执行脚本。 </span>\n</div>\n<div>\n<span style=\"color:#000000;\">方法 2：添加可执行权限：</span>\n<pre><code># ll test.sh\n-rw-r--r--. 1 root root 32 Aug 18 01:07 test.sh\n# chmod +x test.sh\n# ./test.sh\n-bash: ./test.sh: Permission denied\n# chmod +x test.sh\n# ./test.sh # ./在当前目录\nHello world!</code></pre>\n<div>\n<span style=\"color:#000000;\">这种方式默认根据脚本第一行指定的解释器处理，如果没写以当前默认 Shell 解释器执行。 </span>\n</div>\n<div>\n<span style=\"color:#000000;\">方法 3：source 命令执行，以当前默认 Shell 解释器执行：</span>\n</div>\n<div></div>\n</div>\n</div>\n<pre><code># source test.sh\nHello world!</code></pre>\n<h3>4、<span style=\"color:#000000;\"><strong>Shell 变量 </strong></span></h3>\n<p><strong>1）<span style=\"color:#000000;\">系统变量</span></strong></p>\n<p><span style=\"color:#000000;\">在命令行提示符直接执行 env、set 查看系统或环境变量。env 显示用户环境变量，set 显示 Shell 预先定义好的变量以及用户变量。可以通过 export 导出成用户变量。 </span></p>\n<div>\n<span style=\"color:#000000;\">一些写 Shell 脚本时常用的系统变量：</span>\n</div>\n<div></div>\n<p><img alt=\"\" height=\"650\" src=\"image\\742afa483c754c6bbc29609dcbbe56f9.png\" width=\"882\"/></p>\n<p><strong>2）<span style=\"color:#000000;\">普通变量与临时环境变量 </span></strong></p>\n<div>\n<p><span style=\"color:#000000;\">普通变量定义：</span></p>\n<pre><code>VAR=value </code></pre>\n<p><span style=\"color:#000000;\">临时环境变量定义：</span></p>\n<pre><code>export VAR=value</code></pre>\n<p><span style=\"color:#000000;\">变量引用：</span></p>\n</div>\n<div>\n<pre><code>$VAR</code></pre>\n<p><span style=\"color:#000000;\">下面看下他们之间区别： </span></p>\n</div>\n<div>\n<span style=\"color:#000000;\">Shell 进程的环境变量作用域是 Shell 进程，当 export 导入到系统变量时，则作用域是 Shell 进程 </span>\n</div>\n<div>\n<span style=\"color:#000000;\">及其 Shell 子进程。</span>\n</div>\n<div></div>\n<div>\n<img alt=\"\" height=\"623\" src=\"image\\22ee9fcb4d9542929e2ded834b8154ec.png\" width=\"979\"/>\n</div>\n<p><img alt=\"\" height=\"59\" src=\"image\\a361f144e9fd41199da12f1cbe202072.png\" width=\"979\"/></p>\n<div>\n<p>ps axjf 输出的第一列是 PPID（父进程 ID），第二列是 PID（子进程 ID）。</p>\n<p>当 SSH 连接 Shell 时，当前终端 PPID（-bash）是 sshd 守护程序的 PID（root@pts/0），因此在<br/> 当 前终端下的所有进程的 PPID 都是-bash 的 PID，比如执行命令、运行脚本。 </p>\n<p>所以当在-bash 下设置的变量，只在-bash 进程下有效，而-bash 下的子进程 bash 是无效的，当<br/> export 后才有效。 </p>\n<p>进一步说明：再重新连接 SSH，去除上面定义的变量测试下：</p>\n</div>\n<div>\n<img alt=\"\" height=\"520\" src=\"image\\7fe744b71cf34243bf49c6a9a0fd421d.png\" width=\"989\"/>\n</div>\n<p></p>\n<p>所以在当前 shell 定义的变量一定要 export，否则在写脚本时，会引用不到。</p>\n<p>还需要注意的是退出终端后，所有用户定义的变量都会清除。 在/etc/profile 下定义的变量就是这个原理，后面会讲解 Linux 常用变量文件。 </p>\n<div>\n<strong>3）位置变量</strong>\n</div>\n<div></div>\n<p>位置变量指的是函数或脚本后跟的第 n 个参数。</p>\n<p>$1-$n，需要注意的是从第 10 个开始要用花括号调用，例如${10}。</p>\n<p>shift 可对位置变量控制，例如：</p>\n<pre><code>#!/bin/bash\necho \"1: $1\"\nshift\necho \"2: $2\"\nshift\necho \"3: $3\"\n# bash test.sh a b c\n1: a\n2: c\n3:</code></pre>\n<p>每执行一次 shift 命令，位置变量个数就会减一，而变量值则提前一位。shift n，可设置向前移动<br/> n 位。</p>\n<p><strong>4）特殊变量</strong></p>\n<p><img alt=\"\" height=\"300\" src=\"image\\0e9717839d304898bb207c325a5ce8fe.png\" width=\"547\"/></p>\n<p><strong>5） <span style=\"color:#000000;\">变量引用 </span></strong></p>\n<p><img alt=\"\" height=\"174\" src=\"image\\4f026d6805524d109ff839fe5cb07021.png\" width=\"395\"/></p>\n<p><strong>① <span style=\"color:#000000;\">自定义变量与引用</span></strong></p>\n<pre><code># VAR=123\n# echo $VAR\n123\n# VAR+=456\n# echo $VAR\n123456</code></pre>\n<p>Shell 中所有变量引用使用$符，后跟变量名。</p>\n<p>有时个别特殊字符会影响正常引用，那么需要使用${VAR}，例如：</p>\n<pre><code># VAR=123\n# echo $VAR\n123\n# echo $VAR_ # Shell 允许 VAR_为变量名，所以此引用认为这是一个有效的变量名，故此返回\n空# echo ${VAR}\n123</code></pre>\n<p>还有时候变量名与其他字符串紧碍着，也会误认为是整个变量：</p>\n<pre><code># echo $VAR456\n# echo ${VAR}456\n123456</code></pre>\n<p><strong>② <span style=\"color:#000000;\">将命令结果作为变量值 </span></strong></p>\n<pre><code># VAR=`echo 123`\n# echo $VAR\n123\n# VAR=$(echo 123)\n# echo $VAR\n123</code></pre>\n<div>\n<span style=\"color:#000000;\">这里的反撇号等效于$()，都是用于执行 Shell 命令。</span>\n</div>\n<div></div>\n<div>\n<h3>5、<strong>双引号和单引号</strong></h3>\n<div>\n<span style=\"color:#000000;\">在变量赋值时，如果值有空格，Shell 会把空格后面的字符串解释为命令： </span>\n</div>\n<div></div>\n</div>\n<pre><code># VAR=1 2 3 -bash: 2: command not found\n# VAR=\"1 2 3\"\n# echo $VAR\n1 2 3 # VAR='1 2 3'\n# echo $VAR\n1 2 3</code></pre>\n<div>\n<p><span style=\"color:#000000;\">看不出什么区别，再举个说明：</span></p>\n<pre><code># N=3\n# VAR=\"1 2 $N\"\n# echo $VAR\n1 2 3\n# VAR='1 2 $N'\n# echo $VAR\n1 2 $N</code></pre>\n<div>\n<span style=\"color:#000000;\">单引号是告诉 Shell 忽略特殊字符，而双引号则解释特殊符号原有的意义，比如$、！。 </span>\n</div>\n<div></div>\n</div>\n<div>\n<h3>6、<strong>注释</strong></h3>\n<div>\n<span style=\"color:#000000;\">Shell 注释也很简单，只要在每行前面加个#号，即表示 Shell 忽略解释。 </span>\n</div>\n<div></div>\n</div>\n<h2>二、Shell字符串处理</h2>\n<div>\n<span style=\"color:#000000;\">上面讲解了为什么用${}引用变量，${}还有一个重要的功能，就是文本处理，单行文本基本上 </span>\n</div>\n<div>\n<span style=\"color:#000000;\">可以满足你所有需求。</span>\n</div>\n<div></div>\n<h3>1、<span style=\"color:#000000;\"><strong>获取字符串长度</strong></span></h3>\n<div>\n<pre><code># VAR='hello world!'\n# echo $VAR\nhello world!\n# echo ${#VAR}\n12</code></pre>\n<h3>2、<span style=\"color:#000000;\"><strong>字符串切片 </strong></span></h3>\n<div>\n<p><span style=\"color:#000000;\">格式： </span></p>\n<pre><code>${parameter:offset}\n${parameter:offset:length}</code></pre>\n<p><span style=\"color:#000000;\">截取从 offset 个字符开始，向后 length 个字符。 </span></p>\n</div>\n</div>\n<div>\n<pre><code>截取 hello 字符串：\n# VAR='hello world!'\n# echo ${VAR:0:5}\nhello\n截取 wo 字符：\n# echo ${VAR:6:2}\nwo\n截取 world!字符串：\n# echo ${VAR:5}\nworld!\n截取最后一个字符：\n# echo ${VAR:(-1)}\n!\n截取最后二个字符：\n# echo ${VAR:(-2)}\nd!\n截取从倒数第 3 个字符后的 2 个字符：\n# echo ${VAR:(-3):2}\nld</code></pre>\n<h3>3、<span style=\"color:#000000;\"><strong>替换字符串 </strong></span></h3>\n<p><span style=\"color:#000000;\">格式：</span></p>\n<pre><code>${parameter/pattern/string}</code></pre>\n<pre><code># VAR='hello world world!'\n将第一个 world 字符串替换为 WORLD： # echo ${VAR/world/WORLD}\nhello WORLD world!\n将全部 world 字符串替换为 WORLD： # echo ${VAR//world/WORLD}\nhello WORLD WORLD!\n替换正则匹配为空： # VAR=123abc\n# echo ${VAR//[^0-9]/}\n123\n# echo ${VAR//[0-9]/}\nabc</code></pre>\n<div>\n<span style=\"color:#000000;\">patterm 前面开头一个正斜杠为只匹配第一个字符串，两个正斜杠为匹配所有字符。 </span>\n</div>\n</div>\n<div></div>\n<h3>4、<strong>字符串截取 </strong></h3>\n<div>\n<p>格式：</p>\n<pre><code>${parameter#word} # 删除匹配前缀\n${parameter##word} \n${parameter%word} # 删除匹配后缀\n${parameter%%word}</code></pre>\n<div>\n  说明：\n </div>\n<div></div>\n<div>\n<span style=\"color:#000000;\"># 去掉左边，最短匹配模式，##最长匹配模式。 </span>\n</div>\n<div></div>\n<div>\n<span style=\"color:#000000;\">% 去掉右边，最短匹配模式，%%最长匹配模式。 </span>\n</div>\n</div>\n<div>\n   \n <pre><code># URL=\"http://www.baidu.com/baike/user.html\"\n以//为分隔符截取右边字符串：\n# echo ${URL#*//}\nwww.baidu.com/baike/user.html\n以/为分隔符截取右边字符串：\n# echo ${URL##*/}\nuser.html\n以//为分隔符截取左边字符串：\n# echo ${URL%%//*}\nhttp:\n以/为分隔符截取左边字符串：\n# echo ${URL%/*}\nhttp://www.baidu.com/baike\n以.为分隔符截取左边：\n# echo ${URL%.*}\nhttp://www.baidu.com/baike/user\n以.为分隔符截取右边：\n# echo ${URL##*.}\nhtml</code></pre>\n<h3>5、<span style=\"color:#000000;\"><strong>变量状态赋值 </strong></span></h3>\n<div>\n<span style=\"color:#000000;\">${VAR:-string} 如果 VAR 变量为空则返回 string。</span>\n</div>\n<div></div>\n<div>\n<span style=\"color:#000000;\">${VAR:+string} 如果 VAR 变量不为空则返回 string。</span>\n</div>\n<div></div>\n<div>\n<span style=\"color:#000000;\">${VAR:=string} 如果 VAR 变量为空则重新赋值 VAR 变量值为 string。</span>\n</div>\n<div></div>\n<div>\n<span style=\"color:#000000;\">${VAR:?string} 如果 VAR 变量为空则将 string 输出到 stderr。</span>\n</div>\n<div></div>\n<pre><code>如果变量为空就返回 hello world!： # VAR=\n# echo ${VAR:-'hello world!'}\nhello world!\n如果变量不为空就返回 hello world!： # VAR=\"hello\"\n# echo ${VAR:+'hello world!'}\nhello world!\n如果变量为空就重新赋值：\n# VAR=\n# echo ${VAR:=hello}\nhello\n# echo $VAR\nhello\n如果变量为空就将信息输出 stderr： # VAR=\n# echo ${VAR:?value is null}\n-bash: VAR: value is null</code></pre>\n<div>\n  ${}主要用途大概就这么多了，另外还可以获取数组元素，在后面会讲到。 \n  <br/>  \n </div>\n<h3>6、<strong>字符串颜色</strong></h3>\n<div>\n<span style=\"color:#000000;\">再介绍下字符串输出颜色，有时候关键地方需要醒目，颜色是最好的方式：</span>\n</div>\n<div></div>\n<p><img alt=\"\" height=\"274\" src=\"image\\072e9c33bdc1420a8c72f8e96ec6328b.png\" width=\"986\"/></p>\n<p>格式：</p>\n</div>\n<div>\n<pre><code>\\033[1;31;40m # 1 是显示方式，可选。31 是字体颜色。40m 是字体背景颜色。\n\\033[0m # 恢复终端默认颜色，即取消颜色设置。</code></pre>\n<p>示例：</p>\n<pre><code>#!/bin/bash\n# 字体颜色\nfor i in {31..37}; do\necho -e \"\\033[$i;40mHello world!\\033[0m\"\ndone\n# 背景颜色\nfor i in {41..47}; do\necho -e \"\\033[47;${i}mHello world!\\033[0m\"\ndone\n# 显示方式\nfor i in {1..8}; do\necho -e \"\\033[$i;31;40mHello world!\\033[0m\"\ndone</code></pre>\n<p><img alt=\"\" height=\"419\" src=\"image\\6f6fe7c6b5fa4661ab292152a3064c98.png\" width=\"366\"/></p>\n</div>\n<h2>三、Shell表达式与运算符</h2>\n<h3>1、<span style=\"color:#000000;\"><strong>条件表达式 </strong></span></h3>\n<div>\n<img alt=\"\" height=\"171\" src=\"image\\71a3b605cbf04a0e98d33ff0305556ec.png\" width=\"591\"/>\n</div>\n<p> <img alt=\"\" height=\"67\" src=\"image\\f622d417162943cb85b891cdece3bde8.png\" width=\"596\"/></p>\n<h3>2、<span style=\"color:#000000;\"><strong>整数比较符 </strong></span></h3>\n<p><img alt=\"\" height=\"424\" src=\"image\\d1e174bfc4ca42d6b071b7c1676dc477.png\" width=\"913\"/></p>\n<h3>3、<span style=\"color:#000000;\"><strong>字符串比较符 </strong></span> </h3>\n<p><img alt=\"\" height=\"596\" src=\"image\\5e37d11c76044bfa979a1b14da3b5d13.png\" width=\"707\"/></p>\n<p><img alt=\"\" height=\"137\" src=\"image\\dbbecc0c33c547fb88aee9a63fd0790f.png\" width=\"980\"/></p>\n<p>需要注意的是，使用-z 或-n 判断字符串长度时，变量要加双引号。</p>\n<p>举例说明： </p>\n<pre><code># [ -z $a ] &amp;&amp; echo yes || echo no\nyes\n# [ -n $a ] &amp;&amp; echo yes || echo no\nyes\n# 加了双引号才能正常判断是否为空\n# [ -z \"$a\" ] &amp;&amp; echo yes || echo no\nyes\n# [ -n \"$a\" ] &amp;&amp; echo yes || echo no\nno\n# 使用了双中括号就不用了双引号\n# [[ -n $a ]] &amp;&amp; echo yes || echo no\nno\n# [[ -z $a ]] &amp;&amp; echo yes || echo no\nyes</code></pre>\n<h3>4、<span style=\"color:#000000;\"><strong>文件测试 </strong></span></h3>\n<p><img alt=\"\" height=\"545\" src=\"image\\325b17278a8645be8e93ce60aeb6bb3a.png\" width=\"988\"/></p>\n<h3>5、<span style=\"color:#000000;\"><strong>布尔运算符</strong></span> </h3>\n<p><img alt=\"\" height=\"198\" src=\"image\\ea8c6e4b54ce45a4be5c6778c6c4ff4a.png\" width=\"920\"/></p>\n<h3>6、<span style=\"color:#000000;\"><strong>逻辑判断符 </strong></span></h3>\n<p><img alt=\"\" height=\"384\" src=\"image\\12f668c8edc54549a41ae20fd6458b22.png\" width=\"931\"/></p>\n<h3>7、<span style=\"color:#000000;\"><strong>整数运算 </strong></span> </h3>\n<p><img alt=\"\" height=\"389\" src=\"image\\e0324a1bdcae4a1685bf98723112f14d.png\" width=\"461\"/></p>\n<p><img alt=\"\" height=\"201\" src=\"image\\9e1dab43b76440bfbfbc8cd1dcbf56f1.png\" width=\"462\"/></p>\n<p>上面两个都不支持浮点运算。</p>\n<p>$(())表达式还有一个用途，三目运算：</p>\n<pre><code># 如果条件为真返回 1，否则返回 0 # echo $((1&lt;0))\n0# echo $((1&gt;0))\n1\n指定输出数字：\n# echo $((1&gt;0?1:2))\n1# echo $((1&lt;0?1:2))\n2\n注意：返回值不支持字符串</code></pre>\n<h3>8、其他运算工具（let/expr/bc） </h3>\n<p>除了 Shell 本身的算数运算表达式，还有几个命令支持复杂的算数运算：</p>\n<p><img alt=\"\" height=\"574\" src=\"image\\5c2bdcd14181452397252190ac4d9e88.png\" width=\"1075\"/></p>\n<p><span style=\"color:#000000;\">由于 Shell 不支持浮点数比较，可以借助 bc 来完成需求：</span> </p>\n<pre><code># echo \"1.2 &lt; 2\" |bc\n1# echo \"1.2 &gt; 2\" |bc\n0# echo \"1.2 == 2.2\" |bc\n0# echo \"1.2 != 2.2\" |bc\n1\n看出规律了嘛？运算如果为真返回 1，否则返回 0，写一个例子：\n# [ $(echo \"2.2 &gt; 2\" |bc) -eq 1 ] &amp;&amp; echo yes || echo no\nyes\n# [ $(echo \"2.2 &lt; 2\" |bc) -eq 1 ] &amp;&amp; echo yes || echo no\nno</code></pre>\n<p>expr 还可以对字符串操作，获取字符串长度：</p>\n<pre><code># expr length \"string\"\n6\n截取字符串：\n# expr substr \"string\" 4 6\ning\n获取字符在字符串中出现的位置：\n# expr index \"string\" str\n1# expr index \"string\" i 4\n获取字符串开始字符出现的长度：\n# expr match \"string\" s.*\n6# expr match \"string\" str\n3</code></pre>\n<h3>9、Shell 括号用途总结 </h3>\n<p>看到这里，想一想里面所讲的小括号、中括号的用途，是不是有点懵逼了。那我们总结一下！</p>\n<p><img alt=\"\" height=\"690\" src=\"image\\fc58c09a6f3c41c6b8318a1ea16db1cb.png\" width=\"884\"/></p>\n<h2>四、Shell流程控制</h2>\n<p>流程控制是改变程序运行顺序的指令。</p>\n<h3>1、if 语句 </h3>\n<p>格式：</p>\n<pre><code>if list; then list; [ elif list; then list; ] ... [ else list; ] fi</code></pre>\n<p><strong>1）单分支</strong></p>\n<pre><code>if 条件表达式; then\n命令\nfi</code></pre>\n<div>\n<span style=\"color:#000000;\">示例： </span>\n</div>\n<div></div>\n<div>\n<pre><code>#!/bin/bash\nN=10\nif [ $N -gt 5 ]; then\necho yes\nfi\n# bash test.sh\nyes</code></pre>\n<p><strong>2）<span style=\"color:#000000;\">双分支</span></strong></p>\n</div>\n<div>\n<pre><code>if 条件表达式; then\n命令\nelse\n命令\nfi</code></pre>\n<div>\n<span style=\"color:#000000;\">示例 1：</span>\n<pre><code>#!/bin/bash\nN=10\nif [ $N -lt 5 ]; then\necho yes\nelse\necho no\nfi\n# bash test.sh\nno</code></pre>\n<div>\n<span style=\"color:#000000;\">示例 2：判断 crond 进程是否运行</span>\n</div>\n</div>\n<div></div>\n<div>\n<pre><code>#!/bin/bash\nNAME=crond\nNUM=$(ps -ef |grep $NAME |grep -vc grep)\nif [ $NUM -eq 1 ]; then\n echo \"$NAME running.\"\nelse\n echo \"$NAME is not running!\"\nfi</code></pre>\n<div>\n<span style=\"color:#000000;\">示例 3：检查主机是否存活 </span>\n</div>\n<div></div>\n<div>\n<pre><code>#!/bin/bash\nif ping -c 1 192.168.1.1 &gt;/dev/null; then\necho \"OK.\"\nelse\necho \"NO!\"\nfi</code></pre>\n<p>if 语句可以直接对命令状态进行判断，就省去了获取$?这一步！</p>\n<p><strong>3）多分支</strong></p>\n</div>\n</div>\n<div>\n<pre><code>if 条件表达式; then\n 命令\nelif 条件表达式; then\n命令\nelse\n命令\nfi</code></pre>\n<div>\n   当不确定条件符合哪一个时，就可以把已知条件判断写出来，做相应的处理。\n  </div>\n<div></div>\n<div>\n   示例 1： \n   <pre><code>#!/bin/bash\nN=$1\nif [ $N -eq 3 ]; then\n echo \"eq 3\"\nelif [ $N -eq 5 ]; then\n echo \"eq 5\"\nelif [ $N -eq 8 ]; then\n echo \"eq 8\"\nelse\n echo \"no\"\nfi</code></pre>\n<p>如果第一个条件符合就不再向下匹配。</p>\n<p>示例 2：根据 Linux 不同发行版使用不同的命令安装软件</p>\n</div>\n</div>\n</div>\n<div>\n<pre><code>#!/bin/bash\nif [ -e /etc/redhat-release ]; then\n yum install wget -y\nelif [ $(cat /etc/issue |cut -d' ' -f1) == \"Ubuntu\" ]; then\n apt-get install wget -y\nelse\n Operating system does not support.\n exit\nfi</code></pre>\n<h3>2、for 语句 </h3>\n<p>格式：</p>\n<pre><code>for name [ [ in [ word ... ] ] ; ] do list ; done</code></pre>\n<pre><code>for 变量名 in 取值列表; do\n命令\ndone</code></pre>\n<div>\n<p><span style=\"color:#000000;\">示例：</span></p>\n<pre><code>#!/bin/bash\nfor i in {1..3}; do\necho $i\ndone\n# bash test.sh\n1\n2\n3</code></pre>\n<p>for 的语法也可以这么写：</p>\n<pre><code>#!/bin/bash\nfor i in \"$@\"; { # $@是将位置参数作为单个来处理\necho $i\n}# bash test.sh 1 2 3 \n1\n2\n3</code></pre>\n<div>\n<span style=\"color:#000000;\">默认 for 循环的取值列表是以空白符分隔，也就是第一章讲系统变量里的$IFS：</span>\n</div>\n<div></div>\n</div>\n</div>\n<pre><code>#!/bin/bash\nfor i in 12 34; do\necho $i\ndone\n# bash test.sh\n12\n34</code></pre>\n<p>如果想指定分隔符，可以重新赋值$IFS 变量：</p>\n<div>\n<pre><code>#!/bin/bash\nOLD_IFS=$IFS\nIFS=\":\"\nfor i in $(head -1 /etc/passwd); do\n echo $i\ndone\nIFS=$OLD_IFS # 恢复默认值\n# bash test.sh \nroot\nx\n00\nroot\n/root\n/bin/bash</code></pre>\n<div>\n<span style=\"color:#000000;\">for 循环还有一种 C 语言风格的语法，常用于计数、打印数字序列： </span>\n</div>\n<div>\n<pre><code>for (( expr1 ; expr2 ; expr3 )) ; do list ; done</code></pre>\n<pre><code>#!/bin/bash\nfor ((i=1;i&lt;=5;i++)); do # 也可以 i--\necho $i\ndone</code></pre>\n<div>\n<span style=\"color:#000000;\">示例 1：检查多个主机是否存活</span>\n</div>\n<div></div>\n</div>\n</div>\n<pre><code>#!/bin/bash\nfor ip in 192.168.1.{1..254}; do\n if ping -c 1 $ip &gt;/dev/null; then\n echo \"$ip OK.\"\n else\n echo \"$ip NO!\"\n fi\ndone</code></pre>\n<div>\n<span style=\"color:#000000;\">示例 2：检查多个域名是否可以访问 </span>\n</div>\n<div></div>\n<div>\n<pre><code>#!/bin/bash\nURL=\"www.baidu.com www.sina.com www.jd.com\"\nfor url in $URL; do\n HTTP_CODE=$(curl -o /dev/null -s -w %{http_code} http://$url)\n if [ $HTTP_CODE -eq 200 -o $HTTP_CODE -eq 301 ]; then\n echo \"$url OK.\"\n else\n echo \"$url NO!\"\n fi\ndone</code></pre>\n<h3>3、<span style=\"color:#000000;\"><strong>while 语句 </strong></span></h3>\n<div>\n<p><span style=\"color:#000000;\">格式：</span></p>\n<pre><code>while list; do list; done</code></pre>\n<pre><code>while 条件表达式; do\n命令\ndone</code></pre>\n<div>\n<span style=\"color:#000000;\">示例 1：</span>\n</div>\n<div></div>\n<div>\n<pre><code>#!/bin/bash\nN=0\nwhile [ $N -lt 5 ]; do\nlet N++\necho $N\ndone\n# bash test.sh\n1\n2\n3\n4\n5</code></pre>\n<div>\n<span style=\"color:#000000;\">当条件表达式为 false 时，终止循环。 </span>\n</div>\n<div></div>\n<div>\n<span style=\"color:#000000;\">示例 2：条件表达式为 true，将会产生死循环。</span>\n</div>\n<div></div>\n</div>\n</div>\n<pre><code>#!/bin/bash\nwhile [ 1 -eq 1 ]; do\necho \"yes\"\ndone</code></pre>\n<p>也可以条件表达式直接用 true：</p>\n<pre><code>#!/bin/bash\nwhile true; do\necho \"yes\"\ndone</code></pre>\n<p>还可以条件表达式用冒号，冒号在 Shell 中的意思是不做任何操作。但状态是 0，因此为 true：</p>\n</div>\n<pre><code>#!/bin/bash\nwhile :; do\necho \"yes\"\ndone</code></pre>\n<div>\n<span style=\"color:#000000;\">示例 3：逐行处理文本 </span>\n</div>\n<div></div>\n<div>\n<span style=\"color:#000000;\">文本内容： </span>\n</div>\n<div></div>\n<pre><code># cat a.txt\na b c \n1 2 3 \nx y z</code></pre>\n<div>\n<span style=\"color:#000000;\">要想使用 while 循环逐行读取 a.txt 文件，有三种方式： </span>\n</div>\n<div></div>\n<div>\n<span style=\"color:#000000;\">方式 1：</span>\n<pre><code>#!/bin/bash\ncat ./a.txt | while read LINE; do\necho $LINE\ndone</code></pre>\n<div>\n<span style=\"color:#000000;\">方式 2：</span>\n</div>\n<div></div>\n<div>\n<pre><code>#!/bin/bash\nwhile read LINE; do\necho $LINE\ndone &lt; ./a.txt</code></pre>\n<div>\n<span style=\"color:#000000;\">方式 3：</span>\n</div>\n</div>\n<div></div>\n</div>\n<div>\n<pre><code>#!/bin/bash\nexec &lt; ./a.txt # 读取文件作为标准输出\nwhile read LINE; do\necho $LINE\ndone</code></pre>\n<div>\n<span style=\"color:#000000;\">与 while 关联的还有一个 until 语句，它与 while 不同之处在于，是当条件表达式为 false 时才循 </span>\n</div>\n<div>\n<span style=\"color:#000000;\">环，实际使用中比较少，这里不再讲解。</span>\n</div>\n<div></div>\n<div>\n<h3><strong><span style=\"color:#000000;\">4、</span>break 和 continue 语句</strong></h3>\n<p>break 是终止循环。</p>\n<div>\n<span style=\"color:#000000;\">continue 是跳出当前循环。 </span>\n</div>\n<div></div>\n<div>\n<span style=\"color:#000000;\">示例 1：在死循环中，满足条件终止循环</span>\n</div>\n<div></div>\n<div>\n<pre><code>#!/bin/bash\nN=0\nwhile true; do\nlet N++\nif [ $N -eq 5 ]; then\nbreak\nfi\necho $N\ndone\n# bash test.sh\n1\n2\n3\n4</code></pre>\n<div>\n<span style=\"color:#000000;\">里面用了 if 判断，并用了 break 语句，它是跳出循环。与其关联的还有一个 continue 语句，它是 </span>\n</div>\n<div>\n<span style=\"color:#000000;\">跳出本次循环。 </span>\n</div>\n<div></div>\n<div>\n<span style=\"color:#000000;\">示例 2：举例子说明 continue 用法</span>\n</div>\n</div>\n<div></div>\n<div>\n<pre><code>#!/bin/bash\nN=0\nwhile [ $N -lt 5 ]; do\nlet N++\nif [ $N -eq 3 ]; then\ncontinue\nfi\necho $N\ndone\n# bash test.sh\n1\n2\n4\n5</code></pre>\n<p>当变量 N 等于 3 时，continue 跳过了当前循环，没有执行下面的 echo。</p>\n<p>注意：continue 与 break 语句只能循环语句中使用。</p>\n</div>\n</div>\n</div>\n<h3>5、case 语句 </h3>\n<div>\n case 语句一般用于选择性来执行对应部分块命令。\n</div>\n<div>\n<p><br/> 格式：</p>\n<pre><code>case word in [ [(] pattern [ | pattern ] ... ) list ;; ] ... esac\n</code></pre>\n<pre><code>case 模式名 in\n模式 1)\n命令\n;;\n模式 2)\n命令\n;;\n*)\n不符合以上模式执行的命令\nesac</code></pre>\n<div>\n<span style=\"color:#000000;\">每个模式必须以右括号结束，命令结尾以双分号结束。 </span>\n</div>\n<div></div>\n<div>\n<span style=\"color:#000000;\">示例：根据位置参数匹配不同的模式</span>\n</div>\n</div>\n<div></div>\n<div>\n<pre><code>#!/bin/bash\ncase $1 in\nstart)\necho \"start.\"\n;;\nstop)\necho \"stop.\"\n;;\nrestart)\necho \"restart.\"\n;;\n*)\necho \"Usage: $0 {start|stop|restart}\"\nesac\n# bash test.sh\nUsage: test.sh {start|stop|restart}\n# bash test.sh start\nstart.\n# bash test.sh stop\nstop.\n# bash test.sh restart\nrestart.</code></pre>\n<div>\n<span style=\"color:#000000;\">上面例子是不是有点眼熟，在 Linux 下有一部分服务启动脚本都是这么写的。 </span>\n</div>\n<div></div>\n<div>\n<span style=\"color:#000000;\">模式也支持正则，匹配哪个模式就执行那个：</span>\n</div>\n<div></div>\n<div>\n<pre><code>#!/bin/bash\ncase $1 in\n [0-9])\n echo \"match number.\"\n ;;\n [a-z])\n echo \"match letter.\"\n ;;\n '-h'|'--help')\n echo \"help\"\n ;;\n *)\n echo \"Input error!\"\n exit\nesac\n# bash test.sh 1\nmatch number.\n# bash test.sh a\nmatch letter.\n# bash test.sh -h\nhelp\n# bash test.sh --help\nhelp</code></pre>\n<div>\n<span style=\"color:#000000;\">模式支持的正则有：*、、[ ]、[.-.]、|。后面有章节单独讲解 Shell 正则表达式。</span>\n</div>\n<div></div>\n<h3>6、select 语句 </h3>\n<div></div>\n<div>\n   select 是一个类似于 for 循环的语句。\n  </div>\n<div></div>\n<div>\n<p>格式：</p>\n<pre><code>select name [ in word ] ; do list ; done</code></pre>\n<div>\n<pre><code>select 变量 in 选项 1 选项 2; do\nbreak\ndone</code></pre>\n<div>\n<span style=\"color:#000000;\">示例：</span>\n<pre><code>#!/bin/bash\nselect mysql_version in 5.1 5.6; do\necho $mysql_version\ndone\n# bash test.sh\n1) 5.1\n2) 5.6\n#? 1\n5.1\n#? 2\n5.6</code></pre>\n<div>\n<span style=\"color:#000000;\">用户输入编号会直接赋值给变量 mysql_version。作为菜单用的话，循环第二次后就不再显示菜单 </span>\n</div>\n<div>\n<span style=\"color:#000000;\">了，并不能满足需求。 </span>\n</div>\n<div></div>\n<div>\n<span style=\"color:#000000;\">在外面加个死循环，每次执行一次 select 就 break 一次，这样就能每次显示菜单了：</span>\n</div>\n<div></div>\n</div>\n<div>\n<pre><code>#!/bin/bash\nwhile true; do\nselect mysql_version in 5.1 5.6; do\necho $mysql_version\nbreak\ndone\ndone\n# bash test.sh\n1) 5.1\n2) 5.6\n#? 1\n5.1\n1) 5.1\n2) 5.6\n#? 2\n5.6\n1) 5.1\n2) 5.6</code></pre>\n<div>\n<span style=\"color:#000000;\">如果再判断对用户输入的编号执行相应的命令，如果用 if 语句多分支的话要复杂许多，用 case 语 </span>\n</div>\n<div>\n<p><span style=\"color:#000000;\">句就简单多了。</span></p>\n<pre><code>#!/bin/bash\nPS3=\"Select a number: \"\nwhile true; do\nselect mysql_version in 5.1 5.6 quit; do\ncase $mysql_version in\n5.1)\necho \"mysql 5.1\"\nbreak\n;;\n5.6)\necho \"mysql 5.6\"\nbreak\n;;\nquit)\nexit\n;;\n*)\necho \"Input error, Please enter again!\"\nbreak\nesac\ndone\ndone\n# bash test.sh\n1) 5.1\n2) 5.6\n3) quit\nSelect a number: 1\nmysql 5.1\n1) 5.1\n2) 5.6\n3) quit\nSelect a number: 2\nmysql 5.6\n1) 5.1\n2) 5.6\n3) quit\nSelect a number: 3</code></pre>\n<div>\n<span style=\"color:#000000;\">如果不想用默认的提示符，可以通过重新赋值变量 PS3 来自定义。这下就比较完美了！</span>\n</div>\n</div>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div></div>\n<h2>五、Shell函数与数组</h2>\n<h3>1、<strong>函数 </strong></h3>\n<p>格式：</p>\n<pre><code>func() {\ncommand\n}</code></pre>\n<div>\n<span style=\"color:#000000;\">function 关键字可写，也可不写。 </span>\n</div>\n<div></div>\n<div>\n<span style=\"color:#000000;\">示例 1：</span>\n</div>\n<div></div>\n<pre><code>#!/bin/bash\nfunc() {\necho \"This is a function.\"\n}\nfunc\n# bash test.sh\nThis is a function.</code></pre>\n<p>Shell 函数很简单，函数名后跟双括号，再跟双大括号。通过函数名直接调用，不加小括号。</p>\n<p>示例 2：函数返回值</p>\n<pre><code>#!/bin/bash\nfunc() {\nVAR=$((1+1))\nreturn $VAR\necho \"This is a function.\"\n}\nfunc\necho $?\n# bash test.sh\n2</code></pre>\n<div>\n<span style=\"color:#000000;\">return 在函数中定义状态返回值，返回并终止函数，但返回的只能是 0-255 的数字，类似于 exit。 </span>\n</div>\n<div></div>\n<div>\n<span style=\"color:#000000;\">示例 3：函数传参</span>\n</div>\n<div></div>\n<pre><code>#!/bin/bash\nfunc() {\necho \"Hello $1\"\n}\nfunc world\n# bash test.sh\nHello world</code></pre>\n<p>通过 Shell 位置参数给函数传参。</p>\n<p>函数也支持递归调用，也就是自己调用自己。</p>\n<p>例如：</p>\n<pre><code>#!/bin/bash\ntest() {\necho $1\nsleep 1\ntest hello\n}\ntest</code></pre>\n<p>执行会一直在调用本身打印 hello，这就形成了闭环。</p>\n<p>像经典的 fork 炸弹就是函数递归调用：</p>\n<pre><code>:(){ :|:&amp; };: 或 .(){.|.&amp;};.</code></pre>\n<p>这样看起来不好理解，我们更改下格式：</p>\n<pre><code>:() {\n:|:&amp;\n};\n:</code></pre>\n<div>\n<span style=\"color:#000000;\">再易读一点： </span>\n</div>\n<div></div>\n<div>\n<pre><code>bomb() {\nbomb|bomb&amp;\n};\nbomb</code></pre>\n<p>分析下：</p>\n<p>:(){ } 定义一个函数，函数名是冒号。</p>\n<p>: 调用自身函数</p>\n<p>| 管道符</p>\n<p>: 再一次递归调用自身函数</p>\n<p>:|: 表示每次调用函数\":\"的时候就会生成两份拷贝。</p>\n<p>&amp; 放到后台</p>\n<p>; 分号是继续执行下一个命令，可以理解为换行。</p>\n<p>: 最后一个冒号是调用函数。</p>\n<p>因此不断生成新进程，直到系统资源崩溃。</p>\n<p>一般递归函数用的也少，了解下即可！</p>\n</div>\n<h3>2、<span style=\"color:#000000;\"><strong>数组 </strong></span></h3>\n<div>\n 数组是相同类型的元素按一定顺序排列的集合。\n</div>\n<div></div>\n<div>\n<p>格式：</p>\n<pre><code>array=(元素 1 元素 2 元素 3 ...)</code></pre>\n<p>用小括号初始化数组，元素之间用空格分隔。</p>\n</div>\n<div></div>\n<div>\n 定义方法 1：初始化数组\n</div>\n<div></div>\n<div>\n<pre><code>array=(a b c)</code></pre>\n</div>\n<div>\n<p>定义方法 2：新建数组并添加元素</p>\n<pre><code>array[下标]=元素</code></pre>\n<p>定义方法 3：将命令输出作为数组元素</p>\n<pre><code>array=($(command))</code></pre>\n<p>数组操作：</p>\n</div>\n<pre><code>获取所有元素： # echo ${array[*]} # *和@ 都是代表所有元素\na b c\n获取元素下标： # echo ${!a[@]}\n0 1 2\n获取数组长度： # echo ${#array[*]}\n3\n获取第一个元素： # echo ${array[0]}\na\n获取第二个元素： # echo ${array[1]}\nb\n获取第三个元素： # echo ${array[2]}\nc\n添加元素： # array[3]=d\n# echo ${array[*]}\na b c d\n添加多个元素： # array+=(e f g)\n# echo ${array[*]}\na b c d e f g\n删除第一个元素： # unset array[0] # 删除会保留元素下标\n# echo ${array[*]}\nb c d e f g\n删除数组： # unset array</code></pre>\n<div>\n<span style=\"color:#000000;\">数组下标从 0 开始。 </span>\n</div>\n<div></div>\n<div>\n<span style=\"color:#000000;\">示例 1：讲 seq 生成的数字序列循环放到数组里面</span>\n</div>\n<div></div>\n<pre><code>#!/bin/bash\nfor i in $(seq 1 10); do\narray[a]=$i\nlet a++\ndone\necho ${array[*]}\n# bash test.sh\n1 2 3 4 5 6 7 8 9 10</code></pre>\n<div>\n<span style=\"color:#000000;\">示例 2：遍历数组元素</span>\n</div>\n<div></div>\n<div>\n<p><span style=\"color:#000000;\">方法 1：</span></p>\n<pre><code>#!/bin/bash\nIP=(192.168.1.1 192.168.1.2 192.168.1.3)\nfor ((i=0;i&lt;${#IP[*]};i++)); do\necho ${IP[$i]}\ndone\n# bash test.sh\n192.168.1.1\n192.168.1.2\n192.168.1.3</code></pre>\n<p>方法 2：</p>\n</div>\n<div>\n<pre><code>#!/bin/bash\nIP=(192.168.1.1 192.168.1.2 192.168.1.3)\nfor IP in ${IP[*]}; do\necho $IP\ndone</code></pre>\n<h2>六、Shell正则表达式</h2>\n</div>\n<p>正则表达式在每种语言中都会有，功能就是匹配符合你预期要求的字符串。</p>\n<p>Shell 正则表达式分为两种：</p>\n<p>基础正则表达式：BRE（basic regular express）</p>\n<p>扩展正则表达式：ERE（extend regular express），扩展的表达式有+、?、|和()</p>\n<p>下面是一些常用的正则表达式符号，我们先拿 grep 工具举例说明。</p>\n<p><img alt=\"\" height=\"272\" src=\"image\\4cba145fc8ed43608d271f82f2688e3d.png\" width=\"870\"/></p>\n<p><img alt=\"\" height=\"763\" src=\"image\\d3e0b7d9226c41bfbf3f98094ccef526.png\" width=\"699\"/><img alt=\"\" height=\"281\" src=\"image\\71a4cbfb8f9942a6981b581002d1a386.png\" width=\"703\"/></p>\n<p><img alt=\"\" height=\"199\" src=\"image\\b7c9685f075a4e378c7d4094f5d5db9e.png\" width=\"702\"/></p>\n<p><img alt=\"\" height=\"577\" src=\"image\\eaa9b5f08a7f489c93a4041f7f69afc9.png\" width=\"689\"/></p>\n<p><span style=\"color:#000000;\">示例：</span> </p>\n<pre><code>echo -e \"1\\n12\\n123\\n1234a\" |grep '[[:digit:]]'</code></pre>\n<p> <span style=\"color:#000000;\">在 Shell 下使用这些正则表达式处理文本最多的命令有下面几个工具： </span></p>\n<p> <img alt=\"\" height=\"115\" src=\"image\\49029ca8744642108a6b40c49f3d5d9a.png\" width=\"663\"/></p>\n<p> <img alt=\"\" height=\"154\" src=\"image\\3197d0c78d254c909b692daefc29b16e.png\" width=\"662\"/></p>\n<p><img alt=\"\" height=\"262\" src=\"image\\1fdca644d17a4922a48a9fa351271187.png\" width=\"662\"/></p>\n<p><img alt=\"\" height=\"307\" src=\"image\\9460481925ab46e49416d1095188d996.png\" width=\"285\"/></p>\n<h2>七、Shell文本处理三剑客</h2>\n<h3>1、grep</h3>\n<p>过滤来自一个文件或标准输入匹配模式内容。</p>\n<p>除了 grep 外，还有 egrep、fgrep。egrep 是 grep 的扩展，相当于 grep -E。fgrep 相当于 grep - f，用的少。</p>\n<pre><code>Usage: grep [OPTION]... PATTERN [FILE]...</code></pre>\n<p><img alt=\"\" height=\"337\" src=\"image\\c78acb1c08144268b167d998295e4c8e.png\" width=\"693\"/></p>\n<p><img alt=\"\" height=\"544\" src=\"image\\fa8e489610d845eca21ef7c266c63de5.png\" width=\"705\"/></p>\n<p><img alt=\"\" height=\"97\" src=\"image\\5dadc73acf4f4f94a45fef6472e313f5.png\" width=\"515\"/></p>\n<p><img alt=\"\" height=\"133\" src=\"image\\21770b4b5a704814aa1e3c6d99779671.png\" width=\"511\"/></p>\n<p>示例：</p>\n<p>1）输出 b 文件中在 a 文件相同的行 </p>\n<pre><code># grep -f a b</code></pre>\n<div>\n<span style=\"color:#000000;\">2）输出 b 文件中在 a 文件不同的行 </span>\n</div>\n<div></div>\n<div>\n<pre><code># grep -v -f a b</code></pre>\n<div>\n<span style=\"color:#000000;\">3） 匹配多个模式</span>\n</div>\n</div>\n<div></div>\n<div>\n<pre><code># echo \"a bc de\" |xargs -n1 |grep -e 'a' -e 'bc'\na\nbc</code></pre>\n<div>\n<span style=\"color:#000000;\">4）去除空格 http.conf 文件空行或开头#号的行 </span>\n</div>\n</div>\n<div></div>\n<div>\n<pre><code># grep -E -v \"^$|^#\" /etc/httpd/conf/httpd.conf</code></pre>\n<div>\n<span style=\"color:#000000;\">5） 匹配开头不分大小写的单词</span>\n</div>\n</div>\n<div></div>\n<div>\n<pre><code># echo \"A a b c\" |xargs -n1 |grep -i a \n或\n# echo \"A a b c\" |xargs -n1 |grep '[Aa]'\nA\na</code></pre>\n<p>6）只显示匹配的字符串</p>\n<pre><code># echo \"this is a test\" |grep -o 'is'\nis\nis</code></pre>\n<p>7）输出匹配的前五个结果</p>\n</div>\n<div>\n<pre><code># seq 1 20 |grep -m 5 -E '[0-9]{2}'\n10\n11\n12\n13\n14</code></pre>\n<p>8）统计匹配多少行</p>\n<pre><code># seq 1 20 |grep -c -E '[0-9]{2}'\n11</code></pre>\n<div>\n<span style=\"color:#000000;\">9） 匹配 b 字符开头的行</span>\n</div>\n<div></div>\n<pre><code># echo \"a bc de\" |xargs -n1 |grep '^b'\nbc</code></pre>\n<div>\n<span style=\"color:#000000;\">10） 匹配 de 字符结尾的行并输出匹配的行 </span>\n</div>\n<div></div>\n</div>\n<div>\n<pre><code># echo \"a ab abc abcd abcde\" |xargs -n1 |grep -n 'de$'\n5:abcde</code></pre>\n<p>11） 递归搜索/etc 目录下包含 ip 的 conf 后缀文件</p>\n</div>\n<div>\n<pre><code># grep -r '192.167.1.1' /etc --include *.conf</code></pre>\n<p>12） 排除搜索 bak 后缀的文件</p>\n</div>\n<div>\n<pre><code># grep -r '192.167.1.1' /opt --exclude *.bak</code></pre>\n<p>13） 排除来自 file 中的文件</p>\n</div>\n<div>\n<pre><code># grep -r '192.167.1.1' /opt --exclude-from file</code></pre>\n<div>\n<span style=\"color:#000000;\">14） 匹配 41 或 42 的数字</span>\n</div>\n</div>\n<div></div>\n<div>\n<pre><code># seq 41 45 |grep -E '4[12]'\n41\n42</code></pre>\n<p>15） 匹配至少 2 个字符</p>\n</div>\n<div>\n<pre><code># seq 13 |grep -E '[0-9]{2}'\n10\n11\n12\n13</code></pre>\n<p>16） 匹配至少 2 个字符的单词，最多 3 个字符的单词</p>\n</div>\n<div>\n<pre><code># echo \"a ab abc abcd abcde\" |xargs -n1 |grep -E -w -o '[a-z]{2,3}'\nab\nabc</code></pre>\n<div>\n<span style=\"color:#000000;\">17） 匹配所有 IP</span>\n</div>\n</div>\n<div></div>\n<div>\n<pre><code># ifconfig |grep -E -o \"[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\"</code></pre>\n<p>18） 打印匹配结果及后 3 行</p>\n</div>\n<div>\n<pre><code># seq 1 10 |grep 5 -A 3 \n5\n6\n7\n8\n</code></pre>\n<p>19） 打印匹配结果及前 3 行</p>\n<pre><code># seq 1 10 |grep 5 -B 3 \n2\n3\n4\n5</code></pre>\n<p>20） 打印匹配结果及前后 3 行</p>\n<pre><code># seq 1 10 |grep 5 -C 3 \n2\n3\n4\n5\n6\n7\n8</code></pre>\n<p>21） 不显示输出</p>\n</div>\n<div>\n<pre><code>不显示错误输出：\n# grep 'a' abc\ngrep: abc: No such file or directory\n# grep -s 'a' abc\n# echo $?\n2\n不显示正常输出：\n# grep -q 'a' a.txt</code></pre>\n<div>\n<span style=\"color:#000000;\">grep 支持上一章的基础和扩展正则表达式字符。</span>\n</div>\n</div>\n<div></div>\n<div>\n<h3>2、sed</h3>\n<div>\n  流编辑器，过滤和替换文本。\n </div>\n<div></div>\n<div>\n  工作原理：sed 命令将当前处理的行读入模式空间进行处理，处理完把结果输出，并清空模式空\n  <br/> 间。然后再将下一行读入模式空间进行处理输出，以此类推，直到最后一行。还有一个空间叫保持空间，又称暂存空间，可以暂时存放一些处理的数据，但不能直接输出，只能放到模式空间输出。 \n </div>\n<div></div>\n<div>\n<p>这两个空间其实就是在内存中初始化的一个内存区域，存放正在处理的数据和临时存放的数据。</p>\n<pre><code>Usage:\nsed [OPTION]... {script-only-if-no-other-script} [input-file]...\nsed [选项] '地址 命令' file</code></pre>\n<p><img alt=\"\" height=\"228\" src=\"image\\421deddd155f4fbd81a8b51ad3c8b80a.png\" width=\"504\"/></p>\n<p><img alt=\"\" height=\"661\" src=\"image\\bd5b5692dc62444e9084b97cf2473cd1.png\" width=\"661\"/></p>\n<p><img alt=\"\" height=\"350\" src=\"image\\1312402b709846538665c870a7eb0327.png\" width=\"663\"/></p>\n<p><img alt=\"\" height=\"350\" src=\"image\\0c271525cb8e441ab2858f8b3d50d9ae.png\" width=\"666\"/></p>\n<p>借助以下文本内容作为示例讲解： </p>\n</div>\n</div>\n<div>\n<pre><code># tail /etc/services\nnimgtw 48003/udp # Nimbus Gateway\n3gpp-cbsp 48049/tcp # 3GPP Cell Broadcast Service Protocol\nisnetserv 48128/tcp # Image Systems Network Services\nisnetserv 48128/udp # Image Systems Network Services\nblp5 48129/tcp # Bloomberg locator\nblp5 48129/udp # Bloomberg locator\ncom-bardac-dw 48556/tcp # com-bardac-dw\ncom-bardac-dw 48556/udp # com-bardac-dw\niqobject 48619/tcp # iqobject\niqobject 48619/udp # iqobject</code></pre>\n<h3><strong>① 匹配打印（p） </strong></h3>\n<p>1）打印匹配 blp5 开头的行</p>\n<pre><code># tail /etc/services |sed -n '/^blp5/p'\nblp5 48129/tcp # Bloomberg locator\nblp5 48129/udp # Bloomberg locator</code></pre>\n<p>2）打印第一行</p>\n</div>\n<div>\n<pre><code># tail /etc/services |sed -n '1p'\nnimgtw 48003/udp # Nimbus Gateway</code></pre>\n<p>3）打印第一行至第三行</p>\n</div>\n<div>\n<pre><code># tail /etc/services |sed -n '1,3p'\nnimgtw 48003/udp # Nimbus Gateway\n3gpp-cbsp 48049/tcp # 3GPP Cell Broadcast Service Protocol\nisnetserv 48128/tcp # Image Systems Network Services</code></pre>\n<p>4）打印奇数行</p>\n</div>\n<div>\n<pre><code># seq 10 |sed -n '1~2p'\n1\n3\n5\n7\n9</code></pre>\n<p>5）打印匹配行及后一行</p>\n</div>\n<div>\n<pre><code># tail /etc/services |sed -n '/blp5/,+1p'\nblp5 48129/tcp # Bloomberg locator\nblp5 48129/udp # Bloomberg locator</code></pre>\n<p>6）打印最后一行</p>\n</div>\n<div>\n<pre><code># tail /etc/services |sed -n '$p'\niqobject 48619/udp # iqobject</code></pre>\n<p>7）不打印最后一行</p>\n</div>\n<div>\n<pre><code># tail /etc/services |sed -n '$!p'\n3gpp-cbsp 48049/tcp # 3GPP Cell Broadcast Service\nProtocol\nisnetserv 48128/tcp # Image Systems Network Services\nisnetserv 48128/udp # Image Systems Network Services\nblp5 48129/tcp # Bloomberg locator\nblp5 48129/udp # Bloomberg locator\ncom-bardac-dw 48556/tcp # com-bardac-dw\ncom-bardac-dw 48556/udp # com-bardac-dw\niqobject 48619/tcp # iqobject\niqobject 48619/udp # iqobject</code></pre>\n<p>感叹号也就是对后面的命令取反。</p>\n<p>8）匹配范围</p>\n</div>\n<div>\n<pre><code># tail /etc/services |sed -n '/^blp5/,/^com/p'\nblp5 48129/tcp # Bloomberg locator\nblp5 48129/udp # Bloomberg locator\ncom-bardac-dw 48556/tcp # com-bardac-dw</code></pre>\n<div>\n<span style=\"color:#000000;\">匹配开头行到最后一行： </span>\n</div>\n</div>\n<div></div>\n<div>\n<pre><code># tail /etc/services |sed -n '/blp5/,$p'\nblp5 48129/tcp # Bloomberg locator\nblp5 48129/udp # Bloomberg locator\ncom-bardac-dw 48556/tcp # com-bardac-dw\ncom-bardac-dw 48556/udp # com-bardac-dw\niqobject 48619/tcp # iqobject\niqobject 48619/udp # iqobject</code></pre>\n<p>以逗号分开两个样式选择某个范围。</p>\n<p>9）引用系统变量，用引号</p>\n</div>\n<div>\n<pre><code># a=1\n# tail /etc/services |sed -n ''$a',3p'\n或\n# tail /etc/services |sed -n \"$a,3p\"</code></pre>\n<p>sed 命令用单引号时，里面变量用单引号引起来，或者 sed 命令用双引号，因为双引号解释特殊符<br/> 号原有意义。</p>\n</div>\n<h3><strong>②  匹配删除（d） </strong></h3>\n<div>\n 删除与打印使用方法类似，简单举几个例子。\n</div>\n<div></div>\n<div>\n<pre><code># tail /etc/services |sed '/blp5/d'\nnimgtw 48003/udp # Nimbus Gateway\n3gpp-cbsp 48049/tcp # 3GPP Cell Broadcast Service\nisnetserv 48128/tcp # Image Systems Network Services\nisnetserv 48128/udp # Image Systems Network Services\ncom-bardac-dw 48556/tcp # com-bardac-dw\ncom-bardac-dw 48556/udp # com-bardac-dw\niqobject 48619/tcp # iqobject\niqobject 48619/udp # iqobject\n# tail /etc/services |sed '1d'\n3gpp-cbsp 48049/tcp # 3GPP Cell Broadcast Service\nProtocol\nisnetserv 48128/tcp # Image Systems Network Services\nisnetserv 48128/udp # Image Systems Network Services\nblp5 48129/tcp # Bloomberg locator\nblp5 48129/udp # Bloomberg locator\ncom-bardac-dw 48556/tcp # com-bardac-dw\ncom-bardac-dw 48556/udp # com-bardac-dw\niqobject 48619/tcp # iqobject\niqobject 48619/udp # iqobject\n# tail /etc/services |sed '1~2d'\n3gpp-cbsp 48049/tcp # 3GPP Cell Broadcast Service\nisnetserv 48128/udp # Image Systems Network Services\nblp5 48129/udp # Bloomberg locator\ncom-bardac-dw 48556/udp # com-bardac-dw\niqobject 48619/udp # iqobject\n# tail /etc/services |sed '1,3d'\nisnetserv 48128/udp # Image Systems Network Services\nblp5 48129/tcp # Bloomberg locator\nblp5 48129/udp # Bloomberg locator\ncom-bardac-dw 48556/tcp # com-bardac-dw\ncom-bardac-dw 48556/udp # com-bardac-dw\niqobject 48619/tcp # iqobject\niqobject 48619/udp # iqobject</code></pre>\n<p>去除空格 http.conf 文件空行或开头#号的行：</p>\n</div>\n<div>\n<pre><code># sed '/^#/d;/^$/d' /etc/httpd/conf/httpd.conf</code></pre>\n<div>\n<span style=\"color:#000000;\">打印是把匹配的打印出来，删除是把匹配的删除，删除只是不用-n 选项。 </span>\n</div>\n</div>\n<h3><strong>③  替换（s///） </strong></h3>\n<div>\n 1）替换 blp5 字符串为 test\n</div>\n<div></div>\n<div>\n<pre><code># tail /etc/services |sed 's/blp5/test/'\n3gpp-cbsp 48049/tcp # 3GPP Cell Broadcast Service\nisnetserv 48128/tcp # Image Systems Network Services\nisnetserv 48128/udp # Image Systems Network Services\ntest 48129/tcp # Bloomberg locator\ntest 48129/udp # Bloomberg locator\ncom-bardac-dw 48556/tcp # com-bardac-dw\ncom-bardac-dw 48556/udp # com-bardac-dw\niqobject 48619/tcp # iqobject\niqobject 48619/udp # iqobject\nmatahari 49000/tcp # Matahari Broker\n全局替换加 g： # tail /etc/services |sed 's/blp5/test/g'</code></pre>\n<div>\n<span style=\"color:#000000;\">2）替换开头是 blp5 的字符串并打印</span>\n</div>\n</div>\n<div></div>\n<div>\n<pre><code># tail /etc/services |sed -n 's/^blp5/test/p'\ntest 48129/tcp # Bloomberg locator\ntest 48129/udp # Bloomberg locator</code></pre>\n<div>\n<span style=\"color:#000000;\">3）使用&amp;命令引用匹配内容并替换</span>\n</div>\n</div>\n<div></div>\n<div>\n<pre><code># tail /etc/services |sed 's/48049/&amp;.0/'\n3gpp-cbsp 48049.0/tcp # 3GPP Cell Broadcast Service\nisnetserv 48128/tcp # Image Systems Network Services\nisnetserv 48128/udp # Image Systems Network Services\nblp5 48129/tcp # Bloomberg locator\nblp5 48129/udp # Bloomberg locator\ncom-bardac-dw 48556/tcp # com-bardac-dw\ncom-bardac-dw 48556/udp # com-bardac-dw\niqobject 48619/tcp # iqobject\niqobject 48619/udp # iqobject\nmatahari 49000/tcp # Matahari Broker</code></pre>\n<p>IP 加单引号：</p>\n</div>\n<div>\n<pre><code># echo '10.10.10.1 10.10.10.2 10.10.10.3' |sed -r 's/[^ ]+/\"&amp;\"/g'\n\"10.10.10.1\" \"10.10.10.2\" \"10.10.10.3\"</code></pre>\n<div>\n<span style=\"color:#000000;\">4）对 1-4 行的 blp5 进行替换</span>\n</div>\n</div>\n<div></div>\n<div>\n<pre><code># tail /etc/services | sed '1,4s/blp5/test/'\n3gpp-cbsp 48049/tcp # 3GPP Cell Broadcast Service\nisnetserv 48128/tcp # Image Systems Network Services\nisnetserv 48128/udp # Image Systems Network Services\ntest 48129/tcp # Bloomberg locator\nblp5 48129/udp # Bloomberg locator\ncom-bardac-dw 48556/tcp # com-bardac-dw\ncom-bardac-dw 48556/udp # com-bardac-dw\niqobject 48619/tcp # iqobject\niqobject 48619/udp # iqobject\nmatahari 49000/tcp # Matahari Broker</code></pre>\n<p>5）对匹配行进行替换</p>\n</div>\n<div>\n<pre><code># tail /etc/services | sed '/48129\\/tcp/s/blp5/test/'\n3gpp-cbsp 48049/tcp # 3GPP Cell Broadcast Service\nisnetserv 48128/tcp # Image Systems Network Services\nisnetserv 48128/udp # Image Systems Network Services\ntest 48129/tcp # Bloomberg locator\nblp5 48129/udp # Bloomberg locator\ncom-bardac-dw 48556/tcp # com-bardac-dw\ncom-bardac-dw 48556/udp # com-bardac-dw\niqobject 48619/tcp # iqobject\niqobject 48619/udp # iqobject\nmatahari 49000/tcp # Matahari Broker</code></pre>\n<div>\n<span style=\"color:#000000;\">6）二次匹配替换</span>\n</div>\n</div>\n<div></div>\n<div>\n<pre><code># tail /etc/services |sed 's/blp5/test/;s/3g/4g/'\n4gpp-cbsp 48049/tcp # 3GPP Cell Broadcast Service\nisnetserv 48128/tcp # Image Systems Network Services\nisnetserv 48128/udp # Image Systems Network Services\ntest 48129/tcp # Bloomberg locator\ntest 48129/udp # Bloomberg locator\ncom-bardac-dw 48556/tcp # com-bardac-dw\ncom-bardac-dw 48556/udp # com-bardac-dw\niqobject 48619/tcp # iqobject\niqobject 48619/udp # iqobject\nmatahari 49000/tcp # Matahari Broker</code></pre>\n<div>\n<span style=\"color:#000000;\">7）分组使用，在每个字符串后面添加 123</span>\n</div>\n</div>\n<div></div>\n<div>\n<pre><code># tail /etc/services |sed -r 's/(.*) (.*)(#.*)/\\1\\2test \\3/'\n3gpp-cbsp 48049/tcp test # 3GPP Cell Broadcast Service\nisnetserv 48128/tcp test # Image Systems Network Services\nisnetserv 48128/udp test # Image Systems Network Services\nblp5 48129/tcp test # Bloomberg locator\nblp5 48129/udp test # Bloomberg locator\ncom-bardac-dw 48556/tcp test # com-bardac-dw\ncom-bardac-dw 48556/udp test # com-bardac-dw\niqobject 48619/tcp test # iqobject\niqobject 48619/udp test # iqobject\nmatahari 49000/tcp test # Matahari Broker</code></pre>\n<p>第一列是第一个小括号匹配，第二列第二个小括号匹配，第三列一样。将不变的字符串匹配分组，<br/> 再通过\\数字按分组顺序反向引用。</p>\n<p>8）将协议与端口号位置调换</p>\n</div>\n<div>\n<pre><code># tail /etc/services |sed -r 's/(.*)(\\&lt;[0-9]+\\&gt;)\\/(tcp|udp)(.*)/\\1\\3\\/\\2\\4/'\n3gpp-cbsp tcp/48049 # 3GPP Cell Broadcast Service\nisnetserv tcp/48128 # Image Systems Network Services\nisnetserv udp/48128 # Image Systems Network Services\nblp5 tcp/48129 # Bloomberg locator\nblp5 udp/48129 # Bloomberg locator\ncom-bardac-dw tcp/48556 # com-bardac-dw\ncom-bardac-dw udp/48556 # com-bardac-dw\niqobject tcp/48619 # iqobject\niqobject udp/48619 # iqobject\nmatahari tcp/49000 # Matahari Broker</code></pre>\n<p>9）位置调换</p>\n<pre><code>替换 x 字符为大写： # echo \"abc cde xyz\" |sed -r 's/(.*)x/\\1X/'\nabc cde Xyz\n456 与 cde 调换： # echo \"abc:cde;123:456\" |sed -r 's/([^:]+)(;.*:)([^:]+$)/\\3\\2\\1/'\nabc:456;123:cde</code></pre>\n<p>10）注释匹配行后的多少行</p>\n<pre><code># seq 10 |sed '/5/,+3s/^/#/'\n1\n2\n3\n4\n#5\n#6\n#7\n#8\n9\n10</code></pre>\n<p>11）注释指定多行</p>\n<pre><code># seq 5 |sed -r 's/^3|^4/&amp;#/'\n1\n2\n3#\n4#\n5# seq 5 |sed -r '/^3|^4/s/^/#/'\n1\n2\n#3\n#4\n5# seq 5 |sed -r 's/^3|^4/#\\0/'\n1\n2\n#3\n#4\n5</code></pre>\n<p>12）去除开头和结尾空格或制表符</p>\n<pre><code># echo \" 1 2 3 \" |sed 's/^[ \\t]*//;s/[ \\t]*$//'\n1 2 3</code></pre>\n<h3><strong>④ <span style=\"color:#000000;\">多重编辑（</span><span style=\"color:#000000;\">-e） </span></strong></h3>\n<pre><code># tail /etc/services |sed -e '1,2d' -e 's/blp5/test/'\nisnetserv 48128/udp # Image Systems Network Services\ntest 48129/tcp # Bloomberg locator\ntest 48129/udp # Bloomberg locator\ncom-bardac-dw 48556/tcp # com-bardac-dw\ncom-bardac-dw 48556/udp # com-bardac-dw\niqobject 48619/tcp # iqobject\niqobject 48619/udp # iqobject\nmatahari 49000/tcp # Matahari Broker</code></pre>\n<p>也可以使用分号分隔：</p>\n<pre><code># tail /etc/services |sed '1,2d;s/blp5/test/'</code></pre>\n<h3><strong>⑤ <span style=\"color:#000000;\">添加新内容（</span><span style=\"color:#000000;\">a、i 和 c） </span></strong></h3>\n<div>\n<span style=\"color:#000000;\">1）在 blp5 上一行添加 test</span>\n</div>\n<div></div>\n<pre><code># tail /etc/services |sed '/blp5/i \\test'\n3gpp-cbsp 48049/tcp # 3GPP Cell Broadcast Service\nisnetserv 48128/tcp # Image Systems Network Services\nisnetserv 48128/udp # Image Systems Network Services\ntest\nblp5 48129/tcp # Bloomberg locator\ntest\nblp5 48129/udp # Bloomberg locator\ncom-bardac-dw 48556/tcp # com-bardac-dw\ncom-bardac-dw 48556/udp # com-bardac-dw\niqobject 48619/tcp # iqobject\niqobject 48619/udp # iqobject\nmatahari 49000/tcp # Matahari Broker</code></pre>\n<div>\n<span style=\"color:#000000;\">2）在 blp5 下一行添加 test </span>\n</div>\n</div>\n<div></div>\n<pre><code># tail /etc/services |sed '/blp5/a \\test'\n3gpp-cbsp 48049/tcp # 3GPP Cell Broadcast Service\nisnetserv 48128/tcp # Image Systems Network Services\nisnetserv 48128/udp # Image Systems Network Services\nblp5 48129/tcp # Bloomberg locator\ntest\nblp5 48129/udp # Bloomberg locator\ntest\ncom-bardac-dw 48556/tcp # com-bardac-dw\ncom-bardac-dw 48556/udp # com-bardac-dw\niqobject 48619/tcp # iqobject\niqobject 48619/udp # iqobject\nmatahari 49000/tcp # Matahari Broker</code></pre>\n<div>\n<span style=\"color:#000000;\">3）将 blp5 替换新行</span>\n</div>\n<div></div>\n<pre><code># tail /etc/services |sed '/blp5/c \\test'\n3gpp-cbsp 48049/tcp # 3GPP Cell Broadcast Service\nisnetserv 48128/tcp # Image Systems Network Services\nisnetserv 48128/udp # Image Systems Network Services\ntest\ntest\ncom-bardac-dw 48556/tcp # com-bardac-dw\ncom-bardac-dw 48556/udp # com-bardac-dw\niqobject 48619/tcp # iqobject\niqobject 48619/udp # iqobject\nmatahari 49000/tcp # Matahari Broker</code></pre>\n<p>4）在指定行下一行添加一行</p>\n<pre><code># tail /etc/services |sed '2a \\test'\n3gpp-cbsp 48049/tcp # 3GPP Cell Broadcast Service\nisnetserv 48128/tcp # Image Systems Network Services\ntest\nisnetserv 48128/udp # Image Systems Network Services\nblp5 48129/tcp # Bloomberg locator\nblp5 48129/udp # Bloomberg locator\ncom-bardac-dw 48556/tcp # com-bardac-dw\ncom-bardac-dw 48556/udp # com-bardac-dw\niqobject 48619/tcp # iqobject\niqobject 48619/udp # iqobject\nmatahari 49000/tcp # Matahari Broker</code></pre>\n<p>5）在指定行前面和后面添加一行</p>\n<pre><code># seq 5 |sed '3s/.*/txt\\n&amp;/'\n1\n2\ntxt\n3\n4\n5\n# seq 5 |sed '3s/.*/&amp;\\ntxt/'\n1\n2\n3\ntxt\n4\n5</code></pre>\n<h3><strong>⑥ 读取文件并追加到匹配行后（r）</strong></h3>\n<pre><code># cat a.txt\n123\n456\n# tail /etc/services |sed '/blp5/r a.txt'\n3gpp-cbsp 48049/tcp # 3GPP Cell Broadcast Service\nisnetserv 48128/tcp # Image Systems Network Services\nisnetserv 48128/udp # Image Systems Network Services\nblp5 48129/tcp # Bloomberg locator\n123\n456\nblp5 48129/udp # Bloomberg locator\n123\n456\ncom-bardac-dw 48556/tcp # com-bardac-dw\ncom-bardac-dw 48556/udp # com-bardac-dw\niqobject 48619/tcp # iqobject\niqobject 48619/udp # iqobject\nmatahari 49000/tcp # Matahari Broker</code></pre>\n<h3><strong>⑦ <span style=\"color:#000000;\">将匹配行写到文件（</span><span style=\"color:#000000;\">w） </span></strong></h3>\n<pre><code># tail /etc/services |sed '/blp5/w b.txt'\n3gpp-cbsp 48049/tcp # 3GPP Cell Broadcast Service\nisnetserv 48128/tcp # Image Systems Network Services\nisnetserv 48128/udp # Image Systems Network Services\nblp5 48129/tcp # Bloomberg locator\nblp5 48129/udp # Bloomberg locator\ncom-bardac-dw 48556/tcp # com-bardac-dw\ncom-bardac-dw 48556/udp # com-bardac-dw\niqobject 48619/tcp # iqobject\niqobject 48619/udp # iqobject\nmatahari 49000/tcp # Matahari Broker\n# cat b.txt\nblp5 48129/tcp # Bloomberg locator\nblp5 48129/udp # Bloomberg locator</code></pre>\n<h3><strong>⑧ <span style=\"color:#000000;\">读取下一行（</span><span style=\"color:#000000;\">n 和 N） </span></strong></h3>\n<div>\n<span style=\"color:#000000;\">n 读取下一行到模式空间。 </span>\n</div>\n<div></div>\n<div>\n<span style=\"color:#000000;\">N 追加下一行内容到模式空间，并以换行符\\n 分隔。 </span>\n</div>\n<div></div>\n<div>\n<span style=\"color:#000000;\">1）打印匹配的下一行</span>\n</div>\n<div></div>\n<pre><code># seq 5 |sed -n '/3/{n;p}'\n4</code></pre>\n<div>\n<span style=\"color:#000000;\">2）打印偶数 </span>\n</div>\n<div></div>\n<pre><code># seq 6 |sed -n 'n;p'\n2\n4\n6</code></pre>\n<p>sed 先读取第一行 1，执行 n 命令，获取下一行 2，此时模式空间是 2，执行 p 命令，打印模式空<br/> 间。 现在模式空间是 2，sed 再读取 3，执行 n 命令，获取下一行 4，此时模式空间为 4，执行 p 命令，以此类推。</p>\n<p>3）打印奇数</p>\n<pre><code># seq 6 |sed 'n;d'\n1\n3\n5</code></pre>\n<p>sed 先读取第一行 1，此时模式空间是 1，并打印模式空间 1，执行 n 命令，获取下一行 2，执行 d命令，删除模式空间的 2，sed 再读取 3，此时模式空间是 3，并打印模式空间，再执行 n 命令，获取下一行 4，执行 d 命令，删除模式空间的 3，以此类推。</p>\n<pre><code># seq 6 |sed -n 'p;n'\n1\n3\n5</code></pre>\n<div>\n<span style=\"color:#000000;\">4）每三行执行一次 p 命令</span>\n</div>\n<div></div>\n<div>\n<pre><code># seq 6 |sed 'n;n;p'\n1\n2\n3\n3\n4\n5\n6\n6</code></pre>\n<p>sed 先读取第一行 1，并打印模式空间 1，执行 n 命令，获取下一行 2，并打印模式空间 2，再执行 n命令，获取下一行 3，执行 p 命令，打印模式空间 3。sed 读取下一行 3，并打印模式空间 3,以此类推。</p>\n<p>5）每三行替换一次</p>\n<p>方法 1：</p>\n</div>\n<div>\n<pre><code># seq 6 |sed 'n;n;s/^/=/;s/$/=/'\n1\n2\n=3=\n4\n5\n=6=</code></pre>\n<p>我们只是把 p 命令改成了替换命令。</p>\n<p>方法 2：</p>\n<p>这次用到了地址匹配，来实现上面的效果：</p>\n</div>\n<div>\n<pre><code># seq 6 |sed '3~3{s/^/=/;s/$/=/}'\n1\n2\n=3=\n4\n5\n=6=</code></pre>\n<div>\n<span style=\"color:#000000;\">当执行多个 sed 命令时，有时相互会产生影响，我们可以用大括号{}把他们括起来。 </span>\n</div>\n<div></div>\n<div>\n<span style=\"color:#000000;\">6）再看下 N 命令的功能</span>\n</div>\n<div></div>\n</div>\n<pre><code># seq 6 |sed 'N;q'\n1\n2\n将两行合并一行：\n# seq 6 |sed 'N;s/\\n//'\n12\n34\n56</code></pre>\n<div>\n<span style=\"color:#000000;\">第一个命令：sed 读取第一行 1，N 命令读取下一行 2，并以\\n2 追加，此时模式空间是 1\\n2，再执 行 q 退出。 </span>\n</div>\n<div></div>\n<div>\n<span style=\"color:#000000;\">为了进一步说明 N 的功能，看第二个命令：执行 N 命令后，此时模式空间是 1\\n2，再执行把\\n 替换 为空，此时模式空间是 12，并打印。 </span>\n</div>\n<div></div>\n<pre><code># seq 5 |sed -n 'N;p'\n1\n2\n3\n4\n# seq 6 |sed -n 'N;p'\n1\n2\n3\n4\n5\n6</code></pre>\n<p>为什么第一个不打印 5 呢？</p>\n<p>因为 N 命令是读取下一行追加到 sed 读取的当前行，当 N 读取下一行没有内容时，则退出，也不会执行 p 命令打印当前行。</p>\n<p>当行数为偶数时，N 始终就能读到下一行，所以也会执行 p 命令。</p>\n<p>7）打印奇数行数时的最后一行</p>\n<pre><code># seq 5 |sed -n '$!N;p'\n1\n2\n3\n4\n5\n</code></pre>\n<div>\n<span style=\"color:#000000;\">加一个满足条件，当 sed 执行到最后一行时，用感叹号不去执行 N 命令，随后执行 p 命令。 </span>\n</div>\n<div></div>\n<h3><strong>⑨ <span style=\"color:#000000;\">打印和删除模式空间第一行（</span><span style=\"color:#000000;\">P 和 D） </span></strong></h3>\n<div></div>\n<div>\n<span style=\"color:#000000;\">P 打印模式空间的第一行。 </span>\n</div>\n<div></div>\n<div>\n<span style=\"color:#000000;\">D 删除模式空间的第一行。 </span>\n</div>\n<div></div>\n<div>\n<span style=\"color:#000000;\">1）打印奇数</span>\n</div>\n<div></div>\n<div>\n<pre><code># seq 6 |sed -n 'N;P'\n1\n3\n5</code></pre>\n<p>2）保留最后一行</p>\n</div>\n<pre><code># seq 6 |sed 'N;D'\n6</code></pre>\n<div>\n<span style=\"color:#000000;\">读取第一行 1，执行 N 命令读取下一行并追加到模式空间，此时模式空间是 1\\n2，执行 D 命令删除 模式空间第一行 1，剩余 2。 </span>\n</div>\n<div></div>\n<div>\n<span style=\"color:#000000;\">读取第二行，执行 N 命令，此时模式空间是 3\\n4，执行 D 命令删除模式空间第一行 3，剩余 4。 </span>\n</div>\n<div>\n<span style=\"color:#000000;\">以此类推，读取最后一行打印时，而 N 获取不到下一行则退出，不再执行 D，因此模式空间只剩余 6 就打印。 </span>\n</div>\n<h3><strong>⑩ 保持空间操作（h 与 H、g 与 G 和 x） </strong></h3>\n<div>\n h 复制模式空间内容到保持空间（覆盖）。\n</div>\n<div></div>\n<div>\n H 复制模式空间内容追加到保持空间。\n</div>\n<div></div>\n<div>\n g 复制保持空间内容到模式空间（覆盖）。\n</div>\n<div></div>\n<div>\n G 复制保持空间内容追加到模式空间。\n</div>\n<div></div>\n<div>\n x 模式空间与保持空间内容互换\n</div>\n<div></div>\n<div>\n 1）将匹配的内容覆盖到另一个匹配\n</div>\n<div></div>\n<pre><code># seq 6 |sed -e '/3/{h;d}' -e '/5/g'\n1\n2\n4\n3\n6</code></pre>\n<div>\n<span style=\"color:#000000;\">h 命令把匹配的 3 复制到保持空间，d 命令删除模式空间的 3。后面命令再对模式空间匹配 5，并用 g 命令把保持空间 3 覆盖模式空间 5。 </span>\n</div>\n<div></div>\n<div>\n<span style=\"color:#000000;\">2）将匹配的内容放到最后 </span>\n</div>\n<div></div>\n<pre><code># seq 6 |sed -e '/3/{h;d}' -e '$G'\n1\n2\n4\n5\n6\n3</code></pre>\n<p>3）交换模式空间和保持空间</p>\n<pre><code># seq 6 |sed -e '/3/{h;d}' -e '/5/x' -e '$G'\n1\n2\n4\n3\n6\n5</code></pre>\n<div>\n<span style=\"color:#000000;\">看后面命令，在模式空间匹配 5 并将保持空间的 3 与 5 交换，5 就变成了 3,。最后把保持空间的 5 </span>\n</div>\n<div>\n<span style=\"color:#000000;\">追加到模式空间的。 </span>\n</div>\n<div></div>\n<div>\n<span style=\"color:#000000;\">4）倒叙输出</span>\n</div>\n<div></div>\n<pre><code># seq 5 |sed '1!G;h;$!d'\n5\n4\n3\n2\n1</code></pre>\n<p>分析下：</p>\n<p>1!G 第一行不执行把保持空间内容追加到模式空间，因为现在保持空间还没有数据。</p>\n<p>h 将模式空间放到保持空间暂存。</p>\n<p>$!d 最后一行不执行删除模式空间的内容。</p>\n<p>读取第一行 1 时，跳过 G 命令，执行 h 命令将模式空间 1 复制到保持空间，执行 d 命令删除模式空间的 1。</p>\n<p>读取第二行 2 时，模式空间是 2，执行 G 命令，将保持空间 1 追加到模式空间，此时模式空间是<br/> 2\\n1，执行 h 命令将 2\\n1 覆盖到保持空间，d 删除模式空间。</p>\n<p>读取第三行 3 时，模式空间是 3，执行 G 命令，将保持空间 2\\n1 追加到模式空间，此时模式空间是3\\n2\\n1，执行 h 命令将模式空间内容复制到保持空间，d 删除模式空间。</p>\n<p>以此类推，读到第 5 行时，模式空间是 5，执行 G 命令，将保持空间的 4\\n3\\n2\\n1 追加模式空间，然后复制到模式空间，5\\n4\\n3\\n2\\n1，不执行 d，模式空间保留，输出。</p>\n<p>由此可见，每次读取的行先放到模式空间，再复制到保持空间，d 命令删除模式空间内容，防止输<br/> 出，再追加到模式空间，因为追加到模式空间，会追加到新读取的一行的后面，循环这样操作， 就把所有行一行行追加到新读取行的后面，就形成了倒叙。</p>\n<p>5）每行后面添加新空行</p>\n<pre><code># seq 10 |sed G \n1\n\n2\n\n3\n\n4\n\n5</code></pre>\n<p>6）打印匹配行的上一行内容</p>\n<pre><code># seq 5 |sed -n '/3/{x;p};h' \n2</code></pre>\n<p>读取第一行 1，没有匹配到 3，不执行{x;p}，执行 h 命令将模式空间内容 1 覆盖到保持空间。</p>\n<p>读取第二行 2，没有匹配到 3，不执行{x;p}，执行 h 命令将模式空间内容 2 覆盖到保持空间。</p>\n<p>读取第三行 3，匹配到 3，执行 x 命令把模式空间 3 与保持空间 2 交换，再执行 p 打印模式空间 2</p>\n<p>以此类推。</p>\n<p>7）打印匹配行到最后一行或下一行到最后一行</p>\n<pre><code># seq 5 |sed -n '/3/,$p'\n3\n4\n5\n# seq 5 |sed -n '/3/,${h;x;p}'\n3\n4\n5\n# seq 5 |sed -n '/3/{:a;N;$!ba;p}'\n3\n4\n5\n# seq 5 |sed -n '/3/{n;:a;N;$!ba;p}'\n4\n5</code></pre>\n<p>匹配到 3 时，n 读取下一行 4，此时模式空间是 4，执行 N 命令读取下一行并追加到模式空间，此时模式空间是 4\\n5，标签循环完成后打印模式空间 4\\n5。</p>\n<h3><strong>⑪ 标签（:、b 和 t） </strong></h3>\n<p>标签可以控制流，实现分支判断。</p>\n<p>: lable name 定义标签</p>\n<p>b lable 跳转到指定标签，如果没有标签则到脚本末尾</p>\n<p>t lable 跳转到指定标签，前提是 s///命令执行成功</p>\n<p>1）将换行符替换成逗号</p>\n<p>方法 1：</p>\n<pre><code># seq 6 |sed 'N;s/\\n/,/'\n1,2\n3,4\n5,6</code></pre>\n<p>这种方式并不能满足我们的需求，每次 sed 读取到模式空间再打印是新行，替换\\n 也只能对 N 命令追加后的 1\\n2 这样替换。</p>\n<p>这时就可以用到标签了：</p>\n<pre><code># seq 6 |sed ':a;N;s/\\n/,/;b a'\n1,2,3,4,5,6</code></pre>\n<p>看看这里的标签使用，:a 是定义的标签名，b a 是跳转到 a 位置。</p>\n<p>sed 读取第一行 1，N 命令读取下一行 2，此时模式空间是 1\\n2$，执行替换，此时模式空间是<br/> 1,2$，执行 b 命令再跳转到标签 a 位置继续执行 N 命令，读取下一行 3 追加到模式空间，此时模式空间是 1,2\\n3$，再替换，以此类推，不断追加替换，直到最后一行 N 读不到下一行内容退出。</p>\n<p>方法 2：</p>\n<pre><code># seq 6 |sed ':a;N;$!b a;s/\\n/,/g'\n1,2,3,4,5,6</code></pre>\n<div>\n<span style=\"color:#000000;\">先将每行读入到模式空间，最后再执行全局替换。$!是如果是最后一行，则不执行 b a 跳转，最后 </span>\n</div>\n<div>\n<span style=\"color:#000000;\">执行全局替换。</span>\n</div>\n<div></div>\n<pre><code># seq 6 |sed ':a;N;b a;s/\\n/,/g'\n1\n2\n3\n4\n5\n6</code></pre>\n<div>\n<span style=\"color:#000000;\">可以看到，不加$!是没有替换，因为循环到 N 命令没有读到行就退出了，后面的替换也就没执行。 </span>\n</div>\n<div></div>\n<div>\n<span style=\"color:#000000;\">2）每三个数字加个一个逗号 </span>\n</div>\n<div></div>\n<pre><code># echo \"123456789\" |sed -r 's/([0-9]+)([0-9]+{3})/\\1,\\2/'\n123456,789\n# echo \"123456789\" |sed -r ':a;s/([0-9]+)([0-9]+{3})/\\1,\\2/;t a'\n123,456,789\n# echo \"123456789\" |sed -r ':a;s/([0-9]+)([0-9]+{2})/\\1,\\2/;t a'\n1,23,45,67,89</code></pre>\n<p>执行第一次时，替换最后一个，跳转后，再对 123456 匹配替换，直到匹配替换不成功，不执行 t 命令。</p>\n<h3><strong>⑫ <span style=\"color:#000000;\">忽略大小写匹配（</span><span style=\"color:#000000;\">I） </span></strong></h3>\n<pre><code># echo -e \"a\\nA\\nb\\nc\" |sed 's/a/1/Ig'\n1\n1\nb\nc</code></pre>\n<h3><strong>⑬ <span style=\"color:#000000;\">获取总行数（</span><span style=\"color:#000000;\">#） </span></strong></h3>\n<pre><code># seq 10 |sed -n '$='</code></pre>\n<h3>3、awk </h3>\n<p>awk 是一个处理文本的编程语言工具，能用简短的程序处理标准输入或文件、数据排序、计算以及<br/> 生成报表等等。</p>\n<p>在 Linux 系统下默认 awk 是 gawk，它是 awk 的 GNU 版本。可以通过命令查看应用的版本：</p>\n<pre><code>ls -l /bin/awk</code></pre>\n<p>基本的命令语法：</p>\n<pre><code>awk option 'pattern {action}' file</code></pre>\n<p>其中 pattern 表示 AWK 在数据中查找的内容，而 action 是在找到匹配内容时所执行的一系列命令，花括号用于根据特定的模式对一系列指令进行分组。</p>\n<p>awk 处理的工作方式与数据库类似，支持对记录和字段处理，这也是 grep 和 sed 不能实现的。<br/> 在 awk 中，缺省的情况下将文本文件中的一行视为一个记录，逐行放到内存中处理，而将一行中的某一部分作为记录中的一个字段。用 1,2,3...数字的方式顺序的表示行（记录）中的不同字段。用$后跟数字，引用对应的字段，以逗号分隔，0 表示整个行。</p>\n<p><img alt=\"\" height=\"575\" src=\"image\\9a3aa0f1556c49d4a9d3f3cdda03a1f3.png\" width=\"1062\"/></p>\n<h3><strong>① 选项</strong></h3>\n<p><img alt=\"\" height=\"479\" src=\"image\\92de0525597f4fc7af8d507eda0fdcfb.png\" width=\"959\"/></p>\n<h3><strong>② 模式</strong></h3>\n<p><span style=\"color:#000000;\">常用模式有： </span></p>\n<p><img alt=\"\" height=\"509\" src=\"image\\7c0470b56331432cb0b060757ad8d716.png\" width=\"959\"/></p>\n<p>而动作呢，就是下面所讲的 print、流程控制、I/O 语句等。</p>\n<p>示例：</p>\n<p>1）从文件读取 awk 程序处理文件 </p>\n<pre><code># vi test.awk\n{print $2}\n# tail -n3 /etc/services |awk -f test.awk\n48049/tcp\n48128/tcp\n49000/tcp</code></pre>\n<div>\n<span style=\"color:#000000;\">2）指定分隔符，打印指定字段</span>\n</div>\n<div></div>\n<pre><code>打印第二字段，默认以空格分隔：\n# tail -n3 /etc/services |awk '{print $2}'\n48049/tcp\n48128/tcp\n48128/udp\n指定冒号为分隔符打印第一字段：\n# awk -F ':' '{print $1}' /etc/passwd\nroot\nbin\ndaemon\nadm\nlp\nsync\n......</code></pre>\n<p>还可以指定多个分隔符，作为同一个分隔符处理：</p>\n<pre><code># tail -n3 /etc/services |awk -F'[/#]' '{print $3}'\niqobject\niqobject\nMatahari Broker\n# tail -n3 /etc/services |awk -F'[/#]' '{print $1}'\niqobject 48619\niqobject 48619\nmatahari 49000\n# tail -n3 /etc/services |awk -F'[/#]' '{print $2}'\ntcp\nudp\ntcp\n# tail -n3 /etc/services |awk -F'[/#]' '{print $3}'\niqobject\niqobject\nMatahari Broker\n# tail -n3 /etc/services |awk -F'[ /]+' '{print $2}'\n48619\n48619\n49000</code></pre>\n<p>[]元字符的意思是符号其中任意一个字符，也就是说每遇到一个/或#时就分隔一个字段，当用多个<br/> 分隔符时，就能更方面处理字段了。</p>\n<p>3）变量赋值</p>\n<pre><code># awk -v a=123 'BEGIN{print a}'\n123\n系统变量作为 awk 变量的值：\n# a=123\n# awk -v a=$a 'BEGIN{print a}'\n123\n或使用单引号\n# awk 'BEGIN{print '$a'}'\n123</code></pre>\n<div>\n<span style=\"color:#000000;\">4）输出 awk 全局变量到文件 </span>\n</div>\n<div></div>\n<pre><code># seq 5 |awk --dump-variables '{print $0}'\n1\n2\n3\n4\n5\n# cat awkvars.out \nARGC: number (1)\nARGIND: number (0)\nARGV: array, 1 elements\nBINMODE: number (0)\nCONVFMT: string (\"%.6g\")\nERRNO: number (0)\nFIELDWIDTHS: string (\"\")\nFILENAME: string (\"-\")\nFNR: number (5)\nFS: string (\" \")\nIGNORECASE: number (0)\nLINT: number (0)\nNF: number (1)\nNR: number (5)\nOFMT: string (\"%.6g\")\nOFS: string (\" \")\nORS: string (\"\\n\")\nRLENGTH: number (0)\nRS: string (\"\\n\")\nRSTART: number (0)\nRT: string (\"\\n\")\nSUBSEP: string (\"\\034\")\nTEXTDOMAIN: string (\"messages\")</code></pre>\n<div>\n<span style=\"color:#000000;\">5）BEGIN 和 END </span>\n</div>\n<div></div>\n<div>\n<span style=\"color:#000000;\">BEGIN 模式是在处理文件之前执行该操作，常用于修改内置变量、变量赋值和打印输出的页眉或标题。 </span>\n</div>\n<div></div>\n<div>\n<span style=\"color:#000000;\">例如：打印页眉</span>\n</div>\n<pre><code># tail /etc/services |awk 'BEGIN{print \"Service\\t\\tPort\\t\\t\\tDescription\\n===\"}{print\n$0}'\nService Port Description\n===\n3gpp-cbsp 48049/tcp # 3GPP Cell Broadcast Service\nisnetserv 48128/tcp # Image Systems Network Services\nisnetserv 48128/udp # Image Systems Network Services\nblp5 48129/tcp # Bloomberg locator\nblp5 48129/udp # Bloomberg locator\ncom-bardac-dw 48556/tcp # com-bardac-dw\ncom-bardac-dw 48556/udp # com-bardac-dw\niqobject 48619/tcp # iqobject\niqobject 48619/udp # iqobject\nmatahari 49000/tcp # Matahari Broker</code></pre>\n<p>END 模式是在程序处理完才会执行。</p>\n<p>例如：打印页尾</p>\n<pre><code># tail /etc/services |awk '{print $0}END{print \"===\\nEND......\"}'\n3gpp-cbsp 48049/tcp # 3GPP Cell Broadcast Service\nisnetserv 48128/tcp # Image Systems Network Services\nisnetserv 48128/udp # Image Systems Network Services\nblp5 48129/tcp # Bloomberg locator\nblp5 48129/udp # Bloomberg locator\ncom-bardac-dw 48556/tcp # com-bardac-dw\ncom-bardac-dw 48556/udp # com-bardac-dw\niqobject 48619/tcp # iqobject\niqobject 48619/udp # iqobject\nmatahari 49000/tcp # Matahari Broker\n===\nEND......</code></pre>\n<p>6）格式化输出 awk 命令到文件</p>\n<pre><code># tail /etc/services |awk --profile 'BEGIN{print\n\"Service\\t\\tPort\\t\\t\\tDescription\\n===\"}{print $0}END{print \"===\\nEND......\"}'\nService Port Description\n===\nnimgtw 48003/udp # Nimbus Gateway\n3gpp-cbsp 48049/tcp # 3GPP Cell Broadcast Service Protocol\nisnetserv 48128/tcp # Image Systems Network Services\nisnetserv 48128/udp # Image Systems Network Services\nblp5 48129/tcp # Bloomberg locator\nblp5 48129/udp # Bloomberg locator\ncom-bardac-dw 48556/tcp # com-bardac-dw\ncom-bardac-dw 48556/udp # com-bardac-dw\niqobject 48619/tcp # iqobject\niqobject 48619/udp # iqobject\n===\nEND......\n# cat awkprof.out\n # gawk profile, created Sat Jan 7 19:45:22 2017\n # BEGIN block(s)\n BEGIN {\n print \"Service\\t\\tPort\\t\\t\\tDescription\\n===\"\n }\n # Rule(s)\n {\n print $0\n }\n # END block(s)\n END {\n print \"===\\nEND......\"\n }</code></pre>\n<div>\n<span style=\"color:#000000;\">7）/re/正则匹配 </span>\n</div>\n<div></div>\n<div>\n<pre><code>匹配包含 tcp 的行：\n# tail /etc/services |awk '/tcp/{print $0}'\n3gpp-cbsp 48049/tcp # 3GPP Cell Broadcast Service\nisnetserv 48128/tcp # Image Systems Network Services\nblp5 48129/tcp # Bloomberg locator\ncom-bardac-dw 48556/tcp # com-bardac-dw\niqobject 48619/tcp # iqobject\nmatahari 49000/tcp # Matahari Broker\n匹配开头是 blp5 的行：\n# tail /etc/services |awk '/^blp5/{print $0}'\nblp5 48129/tcp # Bloomberg locator\nblp5 48129/udp # Bloomberg locator\n匹配第一个字段是 8 个字符的行：\n# tail /etc/services |awk '/^[a-z0-9]{8} /{print $0}'\niqobject 48619/tcp # iqobject\niqobject 48619/udp # iqobject\nmatahari 49000/tcp # Matahari Broker\n如果没有匹配到，请查看你的 awk 版本（awk --version）是不是 3，因为 4 才支持{}</code></pre>\n<p>8）逻辑 and、or 和 not</p>\n</div>\n<div>\n<pre><code>匹配记录中包含 blp5 和 tcp 的行：\n# tail /etc/services |awk '/blp5/ &amp;&amp; /tcp/{print $0}'\nblp5 48129/tcp # Bloomberg locator\n匹配记录中包含 blp5 或 tcp 的行：\n# tail /etc/services |awk '/blp5/ || /tcp/{print $0}'\n3gpp-cbsp 48049/tcp # 3GPP Cell Broadcast Service\nisnetserv 48128/tcp # Image Systems Network Services\nblp5 48129/tcp # Bloomberg locator\nblp5 48129/udp # Bloomberg locator\ncom-bardac-dw 48556/tcp # com-bardac-dw\niqobject 48619/tcp # iqobject\nmatahari 49000/tcp # Matahari Broker\n不匹配开头是#和空行：\n# awk '! /^#/ &amp;&amp; ! /^$/{print $0}' /etc/httpd/conf/httpd.conf\n或\n# awk '! /^#|^$/' /etc/httpd/conf/httpd.conf\n或\n# awk '/^[^#]|\"^$\"/' /etc/httpd/conf/httpd.conf</code></pre>\n<p>9）匹配范围</p>\n</div>\n<div>\n<pre><code># tail /etc/services |awk '/^blp5/,/^com/'\nblp5 48129/tcp # Bloomberg locator\nblp5 48129/udp # Bloomberg locator\ncom-bardac-dw 48556/tcp # com-bardac-dw</code></pre>\n<div>\n<span style=\"color:#000000;\">对匹配范围后记录再次处理，例如匹配关键字下一行到最后一行： </span>\n</div>\n</div>\n<div></div>\n<pre><code># seq 5 |awk '/3/,/^$/{printf /3/?\"\":$0\"\\n\"}'\n4\n5\n另一种判断真假的方式实现： \n# seq 5 |awk '/3/{t=1;next}t'\n4\n5\n1 和 2 都不匹配 3，不执行后面{}，执行 t，t 变量还没赋值，为空，空在 awk 中就为假，就不打印\n当前行。匹配到 3，执行 t=1，next 跳出，不执行 t。4 也不匹配 3，执行 t，t 的值上次赋值的 1， 为真，打印当前行，以此类推。（非 0 的数字都为真，所以 t 可以写任意非 0 数字）\n如果想打印匹配行都最后一行，就可以这样了：\n# seq 5 |awk '/3/{t=1}t' \n3\n4\n5</code></pre>\n<h3>③ 内置变量</h3>\n<p><img alt=\"\" height=\"609\" src=\"image\\12c08022a8cc4de8b53146cd1b9e6804.png\" width=\"1020\"/></p>\n<p><img alt=\"\" height=\"387\" src=\"image\\d163822e8cbb4f588863f27c3a7cf8f5.png\" width=\"1017\"/></p>\n<p>示例：</p>\n<p>1）FS 和 OFS</p>\n<p>在程序开始前重新赋值 FS 变量，改变默认分隔符为冒号，与-F一样。 </p>\n<pre><code># awk 'BEGIN{FS=\":\"}{print $1,$2}' /etc/passwd |head -n5\nroot x\nbin x\ndaemon x\nadm x\nlp x\n也可以使用-v 来重新赋值这个变量：\n# awk -vFS=':' '{print $1,$2}' /etc/passwd |head -n5 # 中间逗号被换成了 OFS 的默\n认值\nroot x\nbin x\ndaemon x\nadm x\nlp x\n由于 OFS 默认以空格分隔，反向引用多个字段分隔的也是空格，如果想指定输出分隔符这样：\n# awk 'BEGIN{FS=\":\";OFS=\":\"}{print $1,$2}' /etc/passwd |head -n5\nroot:x\nbin:x\ndaemon:x\nadm:x\nlp:x\n也可以通过字符串拼接实现分隔：\n# awk 'BEGIN{FS=\":\"}{print $1\"#\"$2}' /etc/passwd |head -n5\nroot#x\nbin#x\ndaemon#x\nadm#x\nlp#x</code></pre>\n<p>2）RS 和 ORS</p>\n<p>RS 默认是\\n 分隔每行，如果想指定以某个字符作为分隔符来处理记录：</p>\n<pre><code># echo \"www.baidu.com/user/test.html\" |awk 'BEGIN{RS=\"/\"}{print $0}'\nwww.baidu.com\nuser\ntest.html\nRS 也支持正则，简单演示下：\n# seq -f \"str%02g\" 10 |sed 'n;n;a\\-----' |awk 'BEGIN{RS=\"-+\"}{print $1}'\nstr01\nstr04\nstr07\nstr10\n将输出的换行符替换为+号：\n# seq 10 |awk 'BEGIN{ORS=\"+\"}{print $0}'\n1+2+3+4+5+6+7+8+9+10+\n替换某个字符：\n# tail -n2 /etc/services |awk 'BEGIN{RS=\"/\";ORS=\"#\"}{print $0}'\niqobject 48619#udp # iqobject\nmatahari 49000#tcp # Matahari Broker</code></pre>\n<div>\n<span style=\"color:#000000;\">3）NF </span>\n</div>\n<div></div>\n<div>\n<span style=\"color:#000000;\">NF 是字段个数。 </span>\n</div>\n<div></div>\n<pre><code># echo \"a b c d e f\" |awk '{print NF}'\n6\n打印最后一个字段：\n# echo \"a b c d e f\" |awk '{print $NF}'\nf\n打印倒数第二个字段：\n# echo \"a b c d e f\" |awk '{print $(NF-1)}'\ne\n排除最后两个字段：\n# echo \"a b c d e f\" |awk '{$NF=\"\";$(NF-1)=\"\";print $0}'\na b c d\n排除第一个字段：\n# echo \"a b c d e f\" |awk '{$1=\"\";print $0}'\nb c d e f</code></pre>\n<p>4）NR 和 FNR</p>\n<p>NR 统计记录编号，每处理一行记录，编号就会+1，FNR 不同的是在统计第二个文件时会重新计数。</p>\n<pre><code>打印行数：\n# tail -n5 /etc/services |awk '{print NR,$0}'\n1 com-bardac-dw 48556/tcp # com-bardac-dw\n2 com-bardac-dw 48556/udp # com-bardac-dw\n3 iqobject 48619/tcp # iqobject\n4 iqobject 48619/udp # iqobject\n5 matahari 49000/tcp # Matahari Broker\n打印总行数：\n# tail -n5 /etc/services |awk 'END{print NR}'\n5\n打印第三行：\n# tail -n5 /etc/services |awk 'NR==3'\niqobject 48619/tcp # iqobject\n打印第三行第二个字段：\n# tail -n5 /etc/services |awk 'NR==3{print $2}'\n48619/tcp\n打印前三行：\n# tail -n5 /etc/services |awk 'NR&lt;=3{print NR,$0}'\n1 com-bardac-dw 48556/tcp # com-bardac-dw\n2 com-bardac-dw 48556/udp # com-bardac-dw\n3 iqobject 48619/tcp # iqobject</code></pre>\n<div>\n<span style=\"color:#000000;\">看下 NR 和 FNR 的区别： </span>\n</div>\n<div></div>\n<div>\n<pre><code># cat a \na\nb\nc\n# cat b \nc\nd\ne\n# awk '{print NR,FNR,$0}' a b \n1 1 a \n2 2 b \n3 3 c \n4 1 c \n5 2 d \n6 3 e</code></pre>\n<p>可以看出 NR 每处理一行就会+1，而 FNR 在处理第二个文件时，编号重新计数。同时也知道 awk 处理两个文件时，是合并到一起处理。</p>\n<pre><code># awk 'FNR==NR{print $0\"1\"}FNR!=NR{print $0\"2\"}' a b\na1\nb1\nc1\nc2\nd2\ne2</code></pre>\n<p>当 FNR==NR 时，说明在处理第一个文件内容，不等于时说明在处理第二个文件内容。<br/> 一般 FNR 在处理多个文件时会用到，下面会讲解。</p>\n<p>5）ARGC 和 ARGV</p>\n<p>ARGC 是命令行参数数量</p>\n<p>ARGV 是将命令行参数存到数组，元素由 ARGC 指定，数组下标从 0 开始</p>\n<pre><code># awk 'BEGIN{print ARGC}' 1 2 3 \n4\n# awk 'BEGIN{print ARGV[0]}'\nawk\n# awk 'BEGIN{print ARGV[1]}' 1 2 \n1\n# awk 'BEGIN{print ARGV[2]}' 1 2 \n2</code></pre>\n<p>6）ARGIND</p>\n<p>ARGIND 是当前正在处理的文件索引值，第一个文件是 1，第二个文件是 2，以此类推，从而可以通过这种方式判断正在处理哪个文件。</p>\n</div>\n<pre><code># awk '{print ARGIND,$0}' a b \n1 a\n1 b \n1 c \n2 c \n2 d \n2 e \n# awk 'ARGIND==1{print \"a-&gt;\"$0}ARGIND==2{print \"b-&gt;\"$0}' a b \na-&gt;a\na-&gt;b\na-&gt;c\nb-&gt;c\nb-&gt;d\nb-&gt;e</code></pre>\n<p>7）ENVIRON</p>\n<p>ENVIRON 调用系统变量。</p>\n<pre><code># awk 'BEGIN{print ENVIRON[\"HOME\"]}'\n/root\n如果是设置的环境变量，还需要用 export 导入到系统变量才可以调用：\n# awk 'BEGIN{print ENVIRON[\"a\"]}'\n# export a \n# awk 'BEGIN{print ENVIRON[\"a\"]}'\n123</code></pre>\n<p>8）FILENAME</p>\n<p>FILENAME 是当前处理文件的文件名。</p>\n<pre><code># awk 'FNR==NR{print FILENAME\"-&gt;\"$0}FNR!=NR{print FILENAME\"-&gt;\"$0}' a b a-&gt;a\na-&gt;b\na-&gt;c\nb-&gt;c\nb-&gt;d\nb-&gt;e\n</code></pre>\n<p>9）忽略大小写</p>\n<pre><code># echo \"A a b c\" |xargs -n1 |awk 'BEGIN{IGNORECASE=1}/a/'\nAa</code></pre>\n<div>\n<span style=\"color:#000000;\">等于 1 代表忽略大小写。</span>\n</div>\n<div></div>\n<h3><strong>④ 操作符</strong></h3>\n<p><img alt=\"\" height=\"799\" src=\"image\\058c76e9cc594bf6a0e13036980ff5a7.png\" width=\"828\"/></p>\n<p>须知： 在 awk 中，有 3 种情况表达式为假：数字是 0，空字符串和未定义的值。 </p>\n<p>数值运算，未定义变量初始值为 0。字符运算，未定义变量初始值为空。</p>\n<p>举例测试： </p>\n<pre><code># awk 'BEGIN{n=0;if(n)print \"true\";else print \"false\"}'\nfalse\n# awk 'BEGIN{s=\"\";if(s)print \"true\";else print \"false\"}'\nfalse\n# awk 'BEGIN{if(s)print \"true\";else print \"false\"}'\nfalse</code></pre>\n<p>示例：</p>\n<p>1）截取整数</p>\n<pre><code># echo \"123abc abc123 123abc123\" |xargs -n1 | awk '{print +$0}'\n123\n0\n123\n# echo \"123abc abc123 123abc123\" |xargs -n1 | awk '{print -$0}'\n-123\n0-123</code></pre>\n<p>2）感叹号</p>\n<pre><code>打印奇数行： # seq 6 |awk 'i=!i'\n1\n3\n5\n打印偶数行： # seq 6 |awk '!(i=!i)' \n2\n4\n6</code></pre>\n<p>读取第一行：i 是未定义变量，也就是 i=!0，!取反意思。感叹号右边是个布尔值，0 或空字符串为<br/> 假，非 0 或非空字符串为真，!0 就是真，因此 i=1，条件为真打印当前记录。</p>\n<p>没有 print 为什么会打印呢？因为模式后面没有动作，默认会打印整条记录。</p>\n<p>读取第二行：因为上次 i 的值由 0 变成了 1，此时就是 i=!1，条件为假不打印。</p>\n<p>读取第三行：上次条件又为假，i 恢复初始值 0，取反，继续打印。以此类推...</p>\n<p>可以看出，运算时并没有判断行内容，而是利用布尔值真假判断输出当前行。</p>\n<p>3）不匹配某行</p>\n<pre><code># tail /etc/services |awk '!/blp5/{print $0}'\n3gpp-cbsp 48049/tcp # 3GPP Cell Broadcast Service\nisnetserv 48128/tcp # Image Systems Network Services\nisnetserv 48128/udp # Image Systems Network Services\ncom-bardac-dw 48556/tcp # com-bardac-dw\ncom-bardac-dw 48556/udp # com-bardac-dw\niqobject 48619/tcp # iqobject\niqobject 48619/udp # iqobject\nmatahari 49000/tcp # Matahari Broker</code></pre>\n<p>4）乘法和除法</p>\n<pre><code># seq 5 |awk '{print $0*2}'\n2\n4\n6\n8\n10\n# seq 5 |awk '{print $0%2}'\n1\n0\n1\n0\n1\n打印偶数行： # seq 5 |awk '$0%2==0{print $0}'\n2\n4\n打印奇数行： # seq 5 |awk '$0%2!=0{print $0}'\n1\n3\n5</code></pre>\n<p>5）管道符使用</p>\n<pre><code># seq 5 |shuf |awk '{print $0|\"sort\"}'\n1\n2\n3\n4\n5</code></pre>\n<p>6）正则表达式匹配</p>\n<pre><code># seq 5 |awk '$0~3{print $0}'\n3\n# seq 5 |awk '$0!~3{print $0}'\n1\n2\n4\n5\n# seq 5 |awk '$0~/[34]/{print $0}'\n3\n4\n# seq 5 |awk '$0!~/[34]/{print $0}'\n1\n2\n5\n# seq 5 |awk '$0~/[^34]/{print $0}'\n1\n2\n5</code></pre>\n<p>7）判断数组成员</p>\n<pre><code># awk 'BEGIN{a[\"a\"]=123}END{if(\"a\" in a)print \"yes\"}' &lt;/dev/null\nyes</code></pre>\n<div>\n<span style=\"color:#000000;\">8）三目运算符</span>\n</div>\n<div></div>\n<pre><code># awk 'BEGIN{print 1==1?\"yes\":\"no\"}' # 三目运算作为一个表达式，里面不允许写 print\nyes\n# seq 3 |awk '{print $0==2?\"yes\":\"no\"}'\nno\nyes\nno\n替换换行符为逗号：\n# seq 5 |awk '{print n=(n?n\",\"$0:$0)}'\n1\n1,2\n1,2,3\n1,2,3,4\n1,2,3,4,5\n# seq 5 |awk '{n=(n?n\",\"$0:$0)}END{print n}'\n1,2,3,4,5\n说明：读取第一行时，n 没有变量，为假输出$0 也就是 1，并赋值变量 n，读取第二行时，n 是 1 为\n真，输出 1,2 以此类推，后面会一直为真。\n每三行后面添加新一行：\n# seq 10 |awk '{print NR%3?$0:$0 \"\\ntxt\"}'\n1\n2\n3\ntxt\n4\n5\n6\ntxt\n7\n8\n9\ntxt\n10\n在\n两行合并一行：\n# seq 6 |awk '{printf NR%2!=0?$0\" \":$0\" \\n\"}' \n1 2 \n3 4 \n5 6 \n# seq 6 |awk 'ORS=NR%2?\" \":\"\\n\"'\n1 2 \n3 4 \n5 6 \n# seq 6 |awk '{if(NR%2)ORS=\" \";else ORS=\"\\n\";print}'</code></pre>\n<p>9）变量赋值</p>\n<pre><code>字段求和：\n# seq 5 |awk '{sum+=1}END{print sum}'\n5\n# seq 5 |awk '{sum+=$0}END{print sum}'\n15</code></pre>\n<h3><strong>⑤ 流程控制 </strong></h3>\n<p>1）if 语句 </p>\n<p>格式：</p>\n<pre><code>if (condition) statement [ else statement ]</code></pre>\n<pre><code>单分支：\n# seq 5 |awk '{if($0==3)print $0}'\n3\n也支持正则匹配判断，一般在写复杂语句时使用： \n# echo \"123abc#456cde 789aaa#aaabbb \" |xargs -n1 |awk -F# '{if($2~/[0-9]/)print $2}' \n456cde\n# echo \"123abc#456cde 789aaa#aaabbb \" |xargs -n1 |awk -F# '{if($2!~/[0-9]/)print $2}'\naaabbb\n或\n# echo \"123abc#456cde 789aaa#aaabbb\" |xargs -n1 |awk -F# '$2!~/[0-9]/{print $2}' \naaabbb\n双分支：\n# seq 5 |awk '{if($0==3)print $0;else print \"no\"}'\nno\nno\n3\nno\nno\n多分支：\n# cat file\n1 2 3 \n4 5 6 \n7 8 9 \n# awk '{if($1==4){print \"1\"} else if($2==5){print \"2\"} else if($3==6){print \"3\"} else\n{print \"no\"}}' file\nno\n1\nno\n</code></pre>\n<p>2）while 语句 </p>\n<p>格式：</p>\n<pre><code>while (condition) statement</code></pre>\n<p>遍历打印所有字段：</p>\n<pre><code># awk '{i=1;while(i&lt;=NF){print $i;i++}}' file\n1\n2\n3\n4\n5\n6\n7\n8\n9</code></pre>\n<p>awk 是按行处理的，每次读取一行，并遍历打印每个字段。</p>\n<div>\n<p>3）for 语句 C 语言风格</p>\n<p>格式：</p>\n<pre><code>for (expr1; expr2; expr3) statement</code></pre>\n<pre><code>遍历打印所有字段：\n# cat file\n1 2 3 \n4 5 6 \n7 8 9 \n# awk '{for(i=1;i&lt;=NF;i++)print $i}' file\n1\n2\n3\n4\n5\n6\n7\n8\n9\n倒叙打印文本：\n# awk '{for(i=NF;i&gt;=1;i--)print $i}' file\n3\n2\n1\n6\n5\n4\n9\n8\n7\n都换行了，这并不是我们要的结果。怎么改进呢？\n# awk '{for(i=NF;i&gt;=1;i--){printf $i\" \"};print \"\"}' file # print 本身就会新打印一行\n3 2 1 \n6 5 4 \n9 8 7 \n或\n# awk '{for(i=NF;i&gt;=1;i--)if(i==1)printf $i\"\\n\";else printf $i\" \"}' file\n3 2 1 \n6 5 4 \n9 8 7\n在这种情况下，是不是就排除第一行和倒数第一行呢？我们正序打印看下\n排除第一行：\n# awk '{for(i=2;i&lt;=NF;i++){printf $i\" \"};print \"\"}' file\n2 3 \n5 6 \n8 9\n排除第二行：\n# awk '{for(i=1;i&lt;=NF-1;i++){printf $i\" \"};print \"\"}' file\n1 2 \n4 5\n7 8\nIP 加单引号：\n# echo '10.10.10.1 10.10.10.2 10.10.10.3' |awk '{for(i=1;i&lt;=NF;i++)printf\n\"\\047\"$i\"\\047\"}\n'10.10.10.1' '10.10.10.2' '10.10.10.3'\n\\047 是 ASCII 码，可以通过 showkey -a 命令查看。</code></pre>\n<p>4）for 语句遍历数组 </p>\n<p>格式：</p>\n<pre><code>for (var in array) statement</code></pre>\n<div>\n<pre><code># seq -f \"str%.g\" 5 |awk '{a[NR]=$0}END{for(v in a)print v,a[v]}'\n4 str4\n5 str5\n1 str1\n2 str2\n3 str3</code></pre>\n<p>5）break 和 continue 语句 </p>\n<p>break 跳过所有循环，continue 跳过当前循环。</p>\n</div>\n</div>\n<pre><code># awk 'BEGIN{for(i=1;i&lt;=5;i++){if(i==3){break};print i}}'\n1\n2\n# awk 'BEGIN{for(i=1;i&lt;=5;i++){if(i==3){continue};print i}}'\n1\n2\n4\n5</code></pre>\n<p>6）删除数组和元素 </p>\n<p>格式：</p>\n<pre><code>delete array[index] 删除数组元素\ndelete array 删除数组</code></pre>\n<pre><code># seq -f \"str%.g\" 5 |awk '{a[NR]=$0}END{delete a;for(v in a)print v,a[v]}'\n空的… \n# seq -f \"str%.g\" 5 |awk '{a[NR]=$0}END{delete a[3];for(v in a)print v,a[v]}'\n4 str4\n5 str5\n1 str1\n2 str2</code></pre>\n<p>7）exit 语句 </p>\n<p>格式：</p>\n<pre><code>exit [ expression ]</code></pre>\n<p>exit 退出程序，与 shell 的 exit 一样。[ expr ]是 0-255 之间的数字。</p>\n<pre><code># seq 5 |awk '{if($0~/3/)exit (123)}'\n# echo $?\n123</code></pre>\n<h3><strong>⑥ 数组</strong></h3>\n<p>数组：存储一系列相同类型的元素，键/值方式存储，通过下标（键）来访问值。</p>\n<p>awk 中数组称为关联数组，不仅可以使用数字作为下标，还可以使用字符串作为下标。</p>\n<p>数组元素的键和值存储在 awk 程序内部的一个表中，该表采用散列算法，因此数组元素是随机排<br/> 序。</p>\n<p>数组格式：</p>\n<pre><code>array[index]=value</code></pre>\n<p>1）自定义数组</p>\n<pre><code># awk 'BEGIN{a[0]=\"test\";print a[0]}'\ntest</code></pre>\n<p>2）通过 NR 设置记录下标，下标从 1 开始</p>\n<pre><code># tail -n3 /etc/passwd |awk -F: '{a[NR]=$1}END{print a[1]}'\nsystemd-network\n# tail -n3 /etc/passwd |awk -F: '{a[NR]=$1}END{print a[2]}'\nzabbix\n# tail -n3 /etc/passwd |awk -F: '{a[NR]=$1}END{print a[3]}'\nuser</code></pre>\n<div>\n<span style=\"color:#000000;\">3）通过 for 循环遍历数组</span>\n</div>\n<div></div>\n<pre><code># tail -n5 /etc/passwd |awk -F: '{a[NR]=$1}END{for(v in a)print a[v],v}'\nzabbix 4\nuser 5\nadmin 1\nsystemd-bus-proxy 2\nsystemd-network 3 \n# tail -n5 /etc/passwd |awk -F: '{a[NR]=$1}END{for(i=1;i&lt;=NR;i++)print a[i],i}'\nadmin 1\nsystemd-bus-proxy 2\nsystemd-network 3\nzabbix 4\nuser 5</code></pre>\n<p>上面打印的 i 是数组的下标。</p>\n<p>第一种 for 循环的结果是乱序的，刚说过，数组是无序存储。</p>\n<p>第二种 for 循环通过下标获取的情况是排序正常。</p>\n<p>所以当下标是数字序列时，还是用 for(expr1;expr2;expr3)循环表达式比较好，保持顺序不变。</p>\n<p>4）通过++方式作为下标</p>\n<pre><code># tail -n5 /etc/passwd |awk -F: '{a[x++]=$1}END{for(i=0;i&lt;=x-1;i++)print a[i],i}'\nadmin 0\nsystemd-bus-proxy 1\nsystemd-network 2\nzabbix 3\nuser 4</code></pre>\n<p>x 被 awk 初始化值是 0，没循环一次+1</p>\n<p>5）使用字段作为下标</p>\n<pre><code># tail -n5 /etc/passwd |awk -F: '{a[$1]=$7}END{for(v in a)print a[v],v}'\n/sbin/nologin admin\n/bin/bash user\n/sbin/nologin systemd-network\n/sbin/nologin systemd-bus-proxy\n/sbin/nologin zabbix</code></pre>\n<p>6）统计相同字段出现次数</p>\n<pre><code># tail /etc/services |awk '{a[$1]++}END{for(v in a)print a[v],v}'\n2 com-bardac-dw\n1 3gpp-cbsp\n2 iqobject\n1 matahari\n2 isnetserv\n2 blp5\n# tail /etc/services |awk '{a[$1]+=1}END{for(v in a)print a[v],v}'\n2 com-bardac-dw\n1 3gpp-cbsp\n2 iqobject\n1 matahari\n2 isnetserv\n2 blp5\n# tail /etc/services |awk '/blp5/{a[$1]++}END{for(v in a)print a[v],v}'\n2 blp5</code></pre>\n<p>第一个字段作为下标，值被++初始化是 0，每次遇到下标（第一个字段）一样时，对应的值就会被<br/> +1，因此实现了统计出现次数。</p>\n<p>想要实现去重的的话就简单了，只要打印下标即可。</p>\n<p>7）统计 TCP 连接状态</p>\n<pre><code># netstat -antp |awk '/^tcp/{a[$6]++}END{for(v in a)print a[v],v}'\n9 LISTEN\n6 ESTABLISHED\n6 TIME_WAIT</code></pre>\n<p>8）只打印出现次数大于等于 2 的</p>\n<pre><code># tail /etc/services |awk '{a[$1]++}END{for(v in a) if(a[v]&gt;=2){print a[v],v}}'\n2 com-bardac-dw\n2 iqobject\n2 isnetserv\n2 blp5</code></pre>\n<p>9）去重</p>\n<pre><code>只打印重复的行：\n# tail /etc/services |awk 'a[$1]++'\nisnetserv 48128/udp # Image Systems Network Services\nblp5 48129/udp # Bloomberg locator\ncom-bardac-dw 48556/udp # com-bardac-dw\niqobject 48619/udp # iqobject\n不打印重复的行：\n# tail /etc/services |awk '!a[$1]++'\n3gpp-cbsp 48049/tcp # 3GPP Cell Broadcast Service\nisnetserv 48128/tcp # Image Systems Network Services\nblp5 48129/tcp # Bloomberg locator\ncom-bardac-dw 48556/tcp # com-bardac-dw\niqobject 48619/tcp # iqobject\nmatahari 49000/tcp # Matahari Broker</code></pre>\n<p>先明白一个情况，当值是 0 是为假，非 0 整数为真，知道这点就不难理解了。</p>\n<p>只打印重复的行说明：当处理第一条记录时，执行了++，初始值是 0 为假，就不打印，如果再遇到相同的记录，值就会+1，不为 0，则打印。</p>\n<p>不打印重复的行说明：当处理第一条记录时，执行了++，初始值是 0 为假，感叹号取反为真，打<br/> 印，如果再遇到相同的记录，值就会+1，不为 0 为真，取反为假就不打印。</p>\n<pre><code># tail /etc/services |awk '{if(a[$1]++)print $1}'\nisnetserv\nblp5\ncom-bardac-dw\niqobject\n使用三目运算：\n# tail /etc/services |awk '{print a[$1]++?$1:\"no\"}'\nno\nno\nisnetserv\nno\nblp5\nno\ncom-bardac-dw\nno\niqobject\nno\n# tail /etc/services |awk '{if(!a[$1]++)print $1}'\n3gpp-cbsp\nisnetserv\nblp5\ncom-bardac-dw\niqobject\nmatahari</code></pre>\n<p>10）统计每个相同字段的某字段总数：</p>\n<pre><code># tail /etc/services |awk -F'[ /]+' '{a[$1]+=$2}END{for(v in a)print v, a[v]}'\ncom-bardac-dw 97112\n3gpp-cbsp 48049\niqobject 97238\nmatahari 49000\nisnetserv 96256\nblp5 96258</code></pre>\n<p>11）多维数组</p>\n<p>awk 的多维数组，实际上 awk 并不支持多维数组，而是逻辑上模拟二维数组的访问方式，比如<br/> a[a,b]=1，使用 SUBSEP（默认\\034）作为分隔下标字段，存储后是这样 a\\034b。</p>\n<p>示例：</p>\n<pre><code># awk 'BEGIN{a[\"x\",\"y\"]=123;for(v in a) print v,a[v]}'\nxy 123\n我们可以重新复制 SUBSEP 变量，改变下标默认分隔符：\n# awk 'BEGIN{SUBSEP=\":\";a[\"x\",\"y\"]=123;for(v in a) print v,a[v]}'\nx:y 123\n根据指定的字段统计出现次数：\n# cat file\nA 192.168.1.1 HTTP\nB 192.168.1.2 HTTP\nB 192.168.1.2 MYSQL\nC 192.168.1.1 MYSQL\nC 192.168.1.1 MQ\nD 192.168.1.4 NGINX\n# awk 'BEGIN{SUBSEP=\"-\"}{a[$1,$2]++}END{for(v in a)print a[v],v}' file\n1 D-192.168.1.4\n1 A-192.168.1.1\n2 C-192.168.1.1\n2 B-192.168.1.2</code></pre>\n<h3><strong>⑦ <span style=\"color:#000000;\">内置函数 </span></strong></h3>\n<p><img alt=\"\" height=\"594\" src=\"image\\7033a3a8690340f9817d7f9f80383ee3.png\" width=\"885\"/></p>\n<p><img alt=\"\" height=\"608\" src=\"image\\0f94076fd4d34b77b2c462049ce574cb.png\" width=\"882\"/></p>\n<p>示例：</p>\n<p>1）int()</p>\n<pre><code>截断为整数： # echo -e \"123abc\\nabc123\\n123abc123\" | awk '{print int($0)}'\n123\n0\n123\n# awk 'BEGIN{print int(10/3)}'\n3</code></pre>\n<p>2）sqrt()</p>\n<pre><code>获取 9 的平方根：\n# awk 'BEGIN{print sqrt(9)}'\n3</code></pre>\n<p>3）rand()和 srand()</p>\n<pre><code>rand()并不是每次运行就是一个随机数，会一直保持一个不变：\n# awk 'BEGIN{print rand()}'\n0.237788\n当执行 srand()函数后，rand()才会发生变化，所以一般在 awk 着两个函数结合生成随机数，但是\n也有很大几率生成一样：\n# awk 'BEGIN{srand();print rand()}'\n0.31687\n如果想生成 1-10 的随机数可以这样：\n# awk 'BEGIN{srand();print int(rand()*10)}'\n4</code></pre>\n<p>如果想更完美生成随机数，还得做相应的处理！</p>\n<p>4）asort()和 asorti()</p>\n<pre><code>排序数组： \n# seq -f \"str%.g\" 5 |awk '{a[x++]=$0}END{s=asort(a,b);for(i=1;i&lt;=s;i++)print\nb[i],i}'\nstr1 1\nstr2 2\nstr3 3\nstr4 4\nstr5 5 \n# seq -f \"str%.g\" 5 |awk '{a[x++]=$0}END{s=asorti(a,b);for(i=1;i&lt;=s;i++)print\nb[i],i}'\n0 1 \n1 2 \n2 3 \n3 4 \n4 5</code></pre>\n<p>asort 将 a 数组的值放到数组 b，a 下标丢弃，并将数组 b 的总行号赋值给 s，新数组 b 下标从 1 开始，然后遍历。</p>\n<p>5）sub()和 gsub()</p>\n<pre><code>替换正则匹配的字符串：\n# tail /etc/services |awk '/blp5/{sub(/tcp/,\"icmp\");print $0}'\nblp5 48129/icmp # Bloomberg locator\nblp5 48129/udp # Bloomberg locator\n# tail /etc/services |awk '/blp5/{gsub(/c/,\"9\");print $0}'\nblp5 48129/t9p # Bloomberg lo9ator\nblp5 48129/udp # Bloomberg lo9ator\n# echo \"1 2 2 3 4 5\" |awk 'gsub(2,7,$2){print $0}'\n1 7 2 3 4 5 \n# echo \"1 2 3 a b c\" |awk 'gsub(/[0-9]/, '0'){print $0}'\n0 0 0 a b c</code></pre>\n<p>在指定行前后加一行：</p>\n<pre><code># seq 5 | awk 'NR==2{sub('/.*/',\"txt\\n&amp;\")}{print}'\n1\ntxt\n2\n3\n4\n5\n# seq 5 | awk 'NR==2{sub('/.*/',\"&amp;\\ntxt\")}{print}'\n1\n2\ntxt\n3\n4\n5</code></pre>\n<p>6）index()</p>\n<pre><code>获取字段索引起始位置：\n# tail -n 5 /etc/services |awk '{print index($2,\"tcp\")}'\n7\n0\n7\n0\n7</code></pre>\n<p>7）length()</p>\n<pre><code>统计字段长度：\n# tail -n 5 /etc/services |awk '{print length($2)}'\n9\n9\n9\n9\n9\n统计数组的长度：\n# tail -n 5 /etc/services |awk '{a[$1]=$2}END{print length(a)}'\n3</code></pre>\n<p>8）match</p>\n<pre><code># echo \"123abc#456cde 789aaa#234bbb 999aaa#aaabbb\" |xargs -n1 |awk '{print \nmatch($0,234)}' \n0\n8\n0\n如果记录匹配字符串 234，则返回索引位置，否则返回 0。\n那么，我们只想打印包含这个字符串的记录就可以这样：\n# echo \"123abc#456cde 789aaa#234bbb 999aaa#aaabbb\" |xargs -n1 |awk \n'{if(match($0,234)!=0)print $0}' \n789aaa#234bbb</code></pre>\n<p>9）split()</p>\n<pre><code>切分记录为数组 a： # echo -e \"123#456#789\\nabc#cde#fgh\" |awk '{split($0,a);for(v in a)print a[v],v}'\n123#456#789 1\nabc#cde#fgh 1 \n以#号切分记录为数据 a： \n# echo -e \"123#456#789\\nabc#cde#fgh\" |awk '{split($0,a,\"#\");for(v in a)print a[v],v}'\n123 1\n456 2\n789 3\nabc 1\ncde 2\nfgh 3</code></pre>\n<p>10）substr()</p>\n<pre><code>截取字符串索引 4 到最后：\n# echo -e \"123#456#789\\nabc#cde#fgh\" |awk '{print\nsubstr($0,4)}'\n#456#789\n#cde#fgh\n截取字符串索引 4 到长度 5： \n# echo -e \"123#456#789\\nabc#cde#fgh\" |awk '{print substr($0,4,5)}'\n#456#\n#cde#</code></pre>\n<p>11）tolower()和 toupper()</p>\n<pre><code>转换小写：\n# echo -e \"123#456#789\\nABC#cde#fgh\" |awk '{print tolower($0)}'\n123#456#789\nabc#cde#fgh\n转换大写：\n# echo -e \"123#456#789\\nabc#cde#fgh\" |awk '{print toupper($0)}'\n123#456#789\nABC#CDE#FGH</code></pre>\n<p>12）时间处理</p>\n<pre><code>返回当前时间戳：\n# awk 'BEGIN{print systime()}'\n1483297766\n将时间戳转为日期和时间\n# echo \"1483297766\" |awk '{print strftime(\"%Y-%m-%d %H:%M:%S\",$0)}'\n2017-01-01 14:09:26</code></pre>\n<h3><strong>⑧ I/O 语句</strong></h3>\n<p><img alt=\"\" height=\"378\" src=\"image\\046af5df7a7540c7abb893efa52045a4.png\" width=\"825\"/></p>\n<p><img alt=\"\" height=\"218\" src=\"image\\3560ce354c4d493caf48faab066aa43d.png\" width=\"826\"/></p>\n<p>示例：</p>\n<p>1）getline </p>\n<pre><code>获取匹配的下一行：\n# seq 5 |awk '/3/{getline;print}'\n4\n# seq 5 |awk '/3/{print;getline;print}'\n3\n4\n在匹配的下一行加个星号：\n# seq 5 |awk '/3/{getline;sub(\".*\",\"&amp;*\");print}'\n4*\n# seq 5 |awk '/3/{print;getline;sub(\".*\",\"&amp;*\")}{print}'\n1\n2\n3\n4*\n5</code></pre>\n<p>2）getline var</p>\n<pre><code>把 a 文件的行追加到 b 文件的行尾： \n# cat a \na\nb\nc\n# cat b \n1 one\n2 two\n3 three\n# awk '{getline line&lt;\"a\";print $0,line}' b \n1 one a \n2 two b \n3 three c \n把 a 文件的行替换 b 文件的指定字段： \n# awk '{getline line&lt;\"a\";gsub($2,line,$2);print}' b \n1 a \n2 b \n3 c \n把 a 文件的行替换 b 文件的对应字段： \n# awk '{getline line&lt;\"a\";gsub(\"two\",line,$2);print}' b \n1 one\n2 b \n3 three</code></pre>\n<p>3）command | getline [var]</p>\n<pre><code>获取执行 shell 命令后结果的第一行：\n# awk 'BEGIN{\"seq 5\"|getline var;print var}'\n1\n循环输出执行 shell 命令后的结果：\n# awk 'BEGIN{while(\"seq 5\"|getline)print}'\n1\n2\n3\n4\n5</code></pre>\n<p>4）next</p>\n<pre><code>不打印匹配行：\n# seq 5 |awk '{if($0==3){next}else{print}}'\n1\n2\n4\n5\n删除指定行：\n# seq 5 |awk 'NR==1{next}{print $0}'\n2\n3\n4\n5\n如果前面动作成功，就遇到 next，后面的动作不再执行，跳过。\n或者： \n# seq 5 |awk 'NR!=1{print}'\n2\n3\n4\n5\n把第一行内容放到每行的前面： \n# cat a\nhello\n1 a \n2 b \n3 c \n# awk 'NR==1{s=$0;next}{print s,$0}' a \nhello 1 a\nhello 2 b\nhello 3 c \n# awk 'NR==1{s=$0}NF!=1{print s,$0}' a \nhello 1 a\nhello 2 b\nhello 3 c</code></pre>\n<p>5）system()</p>\n<pre><code>执行 shell 命令判断返回值：\n# awk 'BEGIN{if(system(\"grep root /etc/passwd &amp;&gt;/dev/null\")==0)print \"yes\";else print\n\"no\"}'\nyes</code></pre>\n<p>6）打印结果写到文件</p>\n<pre><code># tail -n5 /etc/services |awk '{print $2 &gt; \"a.txt\"}'\n# cat a.txt\n48049/tcp\n48128/tcp\n48128/udp\n48129/tcp\n48129/udp</code></pre>\n<p>7）管道连接 shell 命令</p>\n<pre><code>将结果通过 grep 命令过滤：\n# tail -n5 /etc/services |awk '{print $2|\"grep tcp\"}'\n48556/tcp\n48619/tcp\n49000/tcp</code></pre>\n<h3><strong>⑨  printf 语句 </strong></h3>\n<p>格式化输出，默认打印字符串不换行。</p>\n<p>格式：</p>\n<pre><code>printf [format] arguments</code></pre>\n<p><img alt=\"\" height=\"483\" src=\"image\\b044ae2994ed4f0b95f3bdde296a1343.png\" width=\"757\"/></p>\n<p><img alt=\"\" height=\"163\" src=\"image\\ab0c1df718a04242a295f31cb00ebf08.png\" width=\"750\"/></p>\n<p><span style=\"color:#000000;\">示例： </span></p>\n<pre><code>将换行符换成逗号： \n# seq 5 |awk '{if($0!=5)printf \"%s,\",$0;else print $0}'\n1,2,3,4,5\n小括号中的 5 是最后一个数字。\n输出一个字符：\n# awk 'BEGIN{printf \"%.1s\\n\",\"abc\"}'\na\n保留一个小数点：\n# awk 'BEGIN{printf \"%.2f\\n\",10/3}'\n3.33\n格式化输出：\n# awk 'BEGIN{printf \"user:%s\\tpass:%d\\n\",\"abc\",123}'\nuser:abc pass:123\n左对齐宽度 10： \n# awk 'BEGIN{printf \"%-10s %-10s %-10s\\n\",\"ID\",\"Name\",\"Passwd\"}'\nID Name Passwd\n右对齐宽度 10： \n# awk 'BEGIN{printf \"%10s %10s %10s\\n\",\"ID\",\"Name\",\"Passwd\"}'\nID Name Passwd\n打印表格： \n# vi test.awk\nBEGIN{\nprint \"+--------------------+--------------------+\";\nprintf \"|%-20s|%-20s|\\n\",\"Name\",\"Number\";\nprint \"+--------------------+--------------------+\";\n}\n# awk -f test.awk\n+--------------------+--------------------+\n|Name |Number | \n+--------------------+--------------------+\n格式化输出：\n# awk -F: 'BEGIN{printf \"UserName\\t\\tShell\\n-----------------------------\\n\"}{printf\n\"%-20s %-20s\\n\",$1,$7}END{print \"END...\\n\"}' /etc/passwd\n打印十六进制：\n# awk 'BEGIN{printf \"%x %X\",123,123}'\n7b 7B</code></pre>\n<h3><strong>⑩ 自定义函数 </strong></h3>\n<p>格式：</p>\n<pre><code>function name(parameter list) { statements }</code></pre>\n<p>示例：</p>\n<pre><code># awk 'function myfunc(a,b){return a+b}BEGIN{print myfunc(1,2)}'\n3</code></pre>\n<h3><strong>⑪ 需求案例 </strong></h3>\n<p>1）分析 Nginx 日志</p>\n<p>日志格式：</p>\n<pre><code>'$remote_addr - $remote_user [$time_local] \"$request\" $status $body_bytes_sent \"\n$http_referer\" \"$http_user_agent\" \"$http_x_forwarded_for\"'</code></pre>\n<pre><code>统计访问 IP 次数：\n# awk '{a[$1]++}END{for(v in a)print v,a[v]}' access.log\n统计访问访问大于 100 次的 IP： \n# awk '{a[$1]++}END{for(v in a){if(a[v]&gt;100)print v,a[v]}}' access.log\n统计访问 IP 次数并排序取前 10： \n# awk '{a[$1]++}END{for(v in a)print v,a[v] |\"sort -k2 -nr |head -10\"}' access.log\n统计时间段访问最多的 IP： \n# awk '$4&gt;=\"[02/Jan/2017:00:02:00\" &amp;&amp; $4&lt;=\"[02/Jan/2017:00:03:00\"{a[$1]++}END{for(v in\na)print v,a[v]}' access.log\n统计上一分钟访问量：\n# date=$(date -d '-1 minute' +%d/%d/%Y:%H:%M)\n# awk -vdate=$date '$4~date{c++}END{print c}' access.log\n统计访问最多的 10 个页面：\n# awk '{a[$7]++}END{for(v in a)print v,a[v] |\"sort -k1 -nr|head -\nn10\"}' access.log\n统计每个 URL 数量和返回内容总大小：\n# awk '{a[$7]++;size[$7]+=$10}END{for(v in a)print a[v],v,size[v]}' access.log\n统计每个 IP 访问状态码数量：\n# awk '{a[$1\" \"$9]++}END{for(v in a)print v,a[v]}' access.log\n统计访问 IP 是 404 状态次数：\n# awk '{if($9~/404/)a[$1\" \"$9]++}END{for(i in a)print v,a[v]}' access.log</code></pre>\n<p>2）两个文件对比</p>\n<p>找出 b 文件在 a 文件相同记录：</p>\n<pre><code># seq 1 5 &gt; a \n# seq 3 7 &gt; b\n方法 1： \n# awk 'FNR==NR{a[$0];next}{if($0 in a)print $0}' a b \n3\n4\n5\n# awk 'FNR==NR{a[$0];next}{if($0 in a)print FILENAME,$0}' a b \nb 3 \nb 4 \nb 5 \n# awk 'FNR==NR{a[$0]}NR&gt;FNR{if($0 in a)print $0}' a b \n3\n4\n5\n# awk 'FNR==NR{a[$0]=1;next}(a[$0]==1)' a b # a[$0]是通过 b 文件每行获取值，如果是 1\n说明有\n# awk 'FNR==NR{a[$0]=1;next}{if(a[$0]==1)print}' a b \n3\n4\n5\n方法 2： # awk 'FILENAME==\"a\"{a[$0]}FILENAME==\"b\"{if($0 in a)print $0}' a b \n3\n4\n5\n方法 3： # awk 'ARGIND==1{a[$0]=1}ARGIND==2 &amp;&amp; a[$0]==1' a b \n3\n4\n5</code></pre>\n<p>找出 b 文件在 a 文件不同记录：</p>\n<pre><code>方法 1： \n# awk 'FNR==NR{a[$0];next}!($0 in a)' a b \n6\n7\n# awk 'FNR==NR{a[$0]=1;next}(a[$0]!=1)' a b \n# awk 'FNR==NR{a[$0]=1;next}{if(a[$0]!=1)print}' a b \n6\n7\n方法 2： # awk 'FILENAME==\"a\"{a[$0]=1}FILENAME==\"b\" &amp;&amp; a[$0]!=1' a b\n方法 3： # awk 'ARGIND==1{a[$0]=1}ARGIND==2 &amp;&amp; a[$0]!=1' a b</code></pre>\n<p>3）合并两个文件</p>\n<p>将 a 文件合并到 b 文件：</p>\n<pre><code># cat a\nzhangsan 20\nlisi 23\nwangwu 29\n# cat b\nzhangsan man\nlisi woman\nwangwu man\n# awk 'FNR==NR{a[$1]=$0;next}{print a[$1],$2}' a b\nzhangsan 20 man\nlisi 23 woman\nwangwu 29 man\n# awk 'FNR==NR{a[$1]=$0}NR&gt;FNR{print a[$1],$2}' a b\nzhangsan 20 man\nlisi 23 woman\nwangwu 29 man</code></pre>\n<p>将 a 文件相同 IP 的服务名合并：</p>\n<pre><code># cat a\n192.168.1.1: httpd\n192.168.1.1: tomcat\n192.168.1.2: httpd\n192.168.1.2: postfix\n192.168.1.3: mysqld\n192.168.1.4: httpd\n# awk 'BEGIN{FS=\":\";OFS=\":\"}{a[$1]=a[$1] $2}END{for(v in a)print v,a[v]}' a\n192.168.1.4: httpd\n192.168.1.1: httpd tomcat\n192.168.1.2: httpd postfix\n192.168.1.3: mysqld</code></pre>\n<p>说明：数组 a 存储是$1=a[$1] $2，第一个 a[$1]是以第一个字段为下标，值是 a[$1] $2，也就是<br/> $1=a[$1] $2，值的 a[$1]是用第一个字段为下标获取对应的值，但第一次数组 a 还没有元素，那么<br/> a[$1]是空值，此时数组存储是 192.168.1.1=httpd，再遇到 192.168.1.1 时，a[$1]通过第一字段<br/> 下标获得上次数组的 httpd，把当前处理的行第二个字段放到上一次同下标的值后面，作为下标<br/> 192.168.1.1 的新值。此时数组存储是 192.168.1.1=httpd tomcat。每次遇到相同的下标（第一个<br/> 字段）就会获取上次这个下标对应的值与当前字段并作为此下标的新值。</p>\n<p>4）将第一列合并到一行</p>\n<pre><code># cat file\n1 2 3 \n4 5 6 \n7 8 9 \n# awk '{for(i=1;i&lt;=NF;i++)a[i]=a[i]$i\" \"}END{for(v in a)print a[v]}' file \n1 4 7 \n2 5 8 \n3 6 9</code></pre>\n<p>说明：</p>\n<p>for 循环是遍历每行的字段，NF 等于 3，循环 3 次。</p>\n<p>读取第一行时：</p>\n<p>第一个字段：a[1]=a[1]1\" \" 值 a[1]还未定义数组，下标也获取不到对应的值，所以为空，因此a[1]=1 。</p>\n<p>第二个字段：a[2]=a[2]2\" \" 值 a[2]数组 a 已经定义，但没有 2 这个下标，也获取不到对应的<br/> 值，为空，因此 a[2]=2 。</p>\n<p>第三个字段：a[3]=a[3]3\" \" 值 a[2]与上面一样，为空,a[3]=3 。</p>\n<p>读取第二行时：</p>\n<p>第一个字段：a[1]=a[1]4\" \" 值 a[2]获取数组 a 的 2 为下标对应的值，上面已经有这个下标了，<br/> 对应的值是 1，因此 a[1]=1 4</p>\n<p>第二个字段：a[2]=a[2]5\" \" 同上，a[2]=2 5</p>\n<p>第三个字段：a[3]=a[3]6\" \" 同上，a[2]=3 6</p>\n<p>读取第三行时处理方式同上，数组最后还是三个下标，分别是 1=1 4 7，2=2 5 8，3=3 6 9。最后<br/> for 循环输出所有下标值。</p>\n<p>5）字符串拆分，统计出现的次数</p>\n<p>字符串拆分：</p>\n<pre><code>方法 1： # echo \"hello world\" |awk -F '' '{print $1}'\nh\n# echo \"hello\" |awk -F '' '{for(i=1;i&lt;=NF;i++)print $i}'\nh\ne\nl\nl\no\n方法 2： \n# echo \"hello\" |awk '{split($0,a,\"''\");for(v in a)print a[v]}'\nl\no\nh\ne\nl</code></pre>\n<p>统计字符串中每个字母出现的次数：</p>\n<pre><code># echo \"a.b.c,c.d.e\" |awk -F '[.,]' '{for(i=1;i&lt;=NF;i++)a[$i]++}END{for(v in a)print\nv,a[v]}'\na 1 \nb 1 \nc 2 \nd 1 \ne 1</code></pre>\n<p>6）统计平均成绩</p>\n<pre><code># cat file\njob 80\ndave 84\ntom 75\ndave 73\njob 72\ntom 83\ndave 88\n# awk '{a[$1]+=$2;b[$1]++}END{for(i in a)print i,a[i]/b[i]}' file\njob 76\ndave 81.6667\ntom 79</code></pre>\n<p>7）费用统计</p>\n<pre><code># cat file\nzhangsan 8000 1\nzhangsan 5000 1\nlisi 1000 1\nlisi 2000 1\nwangwu 1500 1\nzhaoliu 6000 1\nzhaoliu 2000 1\nzhaoliu 3000 1 \n# awk '{name[$1]++;cost[$1]+=$2;number[$1]+=$3}END{for(v in name)print\nv,cost[v],number[v]}' file\nzhangsan 5000 1\nlisi 3000 2\nwangwu 1500 1\nzhaoliu 11000 3</code></pre>\n<div>\n<span style=\"color:#000000;\">8）获取数字字段最大值</span>\n</div>\n<div></div>\n<pre><code># cat file\na b 1 \nc d 2 \ne f 3 \ng h 3 \ni j 2\n获取第三字段最大值：\n# awk 'BEGIN{max=0}{if($3&gt;max)max=$3}END{print max}' file\n3\n打印第三字段最大行：\n# awk 'BEGIN{max=0}{a[$0]=$3;if($3&gt;max)max=$3}END{for(v in a)print v,a[v],max}' a \ng h 3 3 3 \ne f 3 3 3 \nc d 2 2 3 \na b 1 1 3 \ni j 2 2 3 \n# awk 'BEGIN{max=0}{a[$0]=$3;if($3&gt;max)max=$3}END{for(v in a)if(a[v]==max)print v}' a \ng h 3 \ne f 3</code></pre>\n<p>9）去除第一行和最后一行</p>\n<pre><code># seq 5 |awk 'NR&gt;2{print s}{s=$0}'\n2\n3\n4</code></pre>\n<p>读取第一行，NR=1，不执行 print s，s=1</p>\n<p>读取第二行，NR=2，不执行 print s，s=2 （大于为真）</p>\n<p>读取第三行，NR=3，执行 print s，此时 s 是上一次 p 赋值内容 2，s=3</p>\n<p>最后一行，执行 print s，打印倒数第二行，s=最后一行</p>\n<p>获取 Nginx 负载均衡配置端 IP 和端口：</p>\n<pre><code># cat nginx.conf\nupstream example-servers1 {\n server 127.0.0.1:80 weight=1 max_fails=2 fail_timeout=30s;\n}\nupstream example-servers2 {\n server 127.0.0.1:80 weight=1 max_fails=2 fail_timeout=30s;\n server 127.0.0.1:82 backup;\n}\n# awk '/example-servers1/,/}/{if(NR&gt;2){print s}{s=$2}}' nginx.conf \n127.0.0.1:80\n# awk '/example-servers1/,/}/{if(i&gt;1)print s;s=$2;i++}' nginx.conf \n# awk '/example-servers1/,/}/{if(i&gt;1){print s}{s=$2;i++}}' nginx.conf\n127.0.0.1:80</code></pre>\n<p>读取第一行，i 初始值为 0，0&gt;1 为假，不执行 print s，x=example-servers1，i=1</p>\n<p>读取第二行，i=1，1&gt;1 为假，不执行 print s，s=127.0.0.1:80,i=2</p>\n<p>读取第三行，i=2，2&gt;1 为真，执行 print s，此时 s 是上一次 s 赋值内容 127.0.0.1:80，i=3</p>\n<p>最后一行，执行 print s，打印倒数第二行，s=最后一行。</p>\n<p>这种方式与上面一样，只是用 i++作为计数器。</p>\n<p>10）知道上述方式，就可以实现这种需求了，打印匹配行的上一行</p>\n<pre><code># seq 5 |awk '/3/{print s}{s=$0}'\n2</code></pre>\n<p>详情，请参考：<a href=\"https://www.gnu.org/software/gawk/manual/gawk.html\" title=\"The GNU Awk User’s Guide\">The GNU Awk User’s Guide</a></p>\n<h2>八、Shell标准输入与输出重定向</h2>\n<p>文件描述符（fd）：文件描述符是一个非负整数，在打开现存文件或新建文件时，内核会返回一个<br/> 文件描述符，读写文件也需要使用文件描述符来访问文件。</p>\n<p>内核为每个进程维护该进程打开的文件记录表。文件描述符只适于 Unix、Linux 操作系统。</p>\n<h3>① 标准输入、输出和错误</h3>\n<p><img alt=\"\" height=\"224\" src=\"image\\4c6274bd46e048868ba0e07269a1de05.png\" width=\"731\"/></p>\n<h3>② 重定向符号 </h3>\n<p><img alt=\"\" height=\"117\" src=\"image\\ad014a80944942f88872a6f21fcb8224.png\" width=\"659\"/></p>\n<p><img alt=\"\" height=\"220\" src=\"image\\2fed99012f0e43d98f6d8ad988846cbd.png\" width=\"662\"/></p>\n<p>输入和输出可以被重定向符号解释到 shell。</p>\n<p>shell 命令是从左到右依次执行命令。</p>\n<p>下面 n 字母是文件描述符。 </p>\n<h3>③ <span style=\"color:#000000;\"><strong>重定向输出 </strong></span></h3>\n<div>\n<span style=\"color:#000000;\">1）覆盖输出 </span>\n</div>\n<div></div>\n<div>\n<p><span style=\"color:#000000;\">一般格式：</span></p>\n<pre><code>[n]&gt;word</code></pre>\n<p><span style=\"color:#000000;\">如果 n 没有指定，默认是 1 </span></p>\n</div>\n<div>\n<span style=\"color:#000000;\">示例： </span>\n</div>\n<div></div>\n<pre><code>打印结果写到文件：\n# echo \"test\" &gt; a.txt\n当没有安装 bc 计算器时，错误输出结果写到文件：\n# echo \"1 + 1\" |bc 2 &gt; error.log</code></pre>\n<p>2）追加重定向输出</p>\n<p>一般格式：</p>\n<pre><code>[n]&gt;&gt;word</code></pre>\n<p>如果 n 没有指定，默认是 1。</p>\n<p>示例：</p>\n<pre><code>打印结果追加到文件：\n# echo \"test\" &gt;&gt; a.txt\n当没有安装 bc 计算器时，错误输出结果追加文件：\n# echo \"1 + 1\" |bc 2 &gt; error.log</code></pre>\n<h3>④ 重定向输入 </h3>\n<p>一般格式：</p>\n<pre><code>[n]&lt;word</code></pre>\n<p>如果 n 没有指定，默认是 0</p>\n<p>示例：</p>\n<pre><code>a.txt 内容作为 grep 输入：\n# grep \"test\" --color &lt; a.txt</code></pre>\n<h3>⑤ <span style=\"color:#000000;\"><strong>重定向标准输出和标准错误 </strong></span></h3>\n<div>\n<span style=\"color:#000000;\">1）覆盖重定向标准输出和标准错误 </span>\n</div>\n<div></div>\n<div>\n<span style=\"color:#000000;\">&amp;&gt;word 和&gt;&amp;word 等价于 &gt;word 2&gt;&amp;1 </span>\n</div>\n<div></div>\n<div>\n<span style=\"color:#000000;\">&amp;将标准输出和标准输入绑定到一起，重定向 word 文件。 </span>\n</div>\n<div></div>\n<div>\n<span style=\"color:#000000;\">示例： </span>\n</div>\n<div></div>\n<pre><code>当不确定执行对错时都覆盖到文件：\n# echo \"1 + 1\" |bc &amp;&gt; error.log\n当不确定执行对错时都覆盖到文件：\n# echo \"1 + 1\" |bc &gt; error.log 2&gt;&amp;1</code></pre>\n<p>2）追加重定向标准输出和标准错误</p>\n<p>&amp;&gt;&gt;word 等价于&gt;&gt;word 2&gt;&amp;1</p>\n<p>示例：</p>\n<pre><code>当不确定执行对错时都追加文件：\n# echo \"1 + 1\" |bc &amp;&gt;&gt; error.log</code></pre>\n<div>\n<span style=\"color:#000000;\">将标准输出和标准输入追加重定向到 delimiter： </span>\n</div>\n<div></div>\n<pre><code>&lt;&lt; delimiter\nhere-document\ndelimiter</code></pre>\n<p>从当前 shell 读取输入源，直到遇到一行只包含 delimiter 终止，内容作为标准输入。</p>\n<p>将 eof 标准输入作为 cat 标准输出再写到 a.txt：</p>\n<pre><code># cat &lt;&lt; eof\n123\nabc\neof\n123\nabc\n# cat &gt; a.txt &lt;&lt; eof\n&gt; 123\n&gt; abc\n&gt; eof</code></pre>\n<h3>⑥ 重定向到空设备 </h3>\n<p>/dev/null 是一个空设备，向它写入的数组都会丢弃，但返回状态是成功的。与其对应的还有一个<br/> /dev/zero 设备，提供无限的 0 数据流。</p>\n<p>在写 Shell 脚本时我们经常会用到/dev/null 设备，将 stdout、stderr 输出给它，也就是我们不想<br/> 要这些输出的数据。</p>\n<p>通过重定向到/dev/null 忽略输出，比如我们没有安装 bc 计算器，正常会抛出没有发现命令：</p>\n<pre><code># echo \"1 + 1\" |bc &gt;/dev/null 2&gt;&amp;1</code></pre>\n<p>这就让标准和错误输出到了空设备。</p>\n<p>忽略标准输出：</p>\n<pre><code># echo \"test\" &gt;/dev/null</code></pre>\n<p>忽略错误输出：</p>\n<pre><code># echo \"1 + 1\" |bc 2&gt;/dev/null</code></pre>\n<h3>⑦ read 命令 </h3>\n<p>read 命令从标准输入读取，并把输入的内容复制给变量。</p>\n<p>命令格式：</p>\n<pre><code>read [-ers] [-a array] [-d delim] [-i text] [-n nchars] [-N nchars] [-p \nprompt] [-t timeout] [-u fd] [name ...]</code></pre>\n<p><img alt=\"\" height=\"530\" src=\"image\\070600727dde49a1bde1ec6d8df18c14.png\" width=\"877\"/></p>\n<p>示例： </p>\n<pre><code>获取用户输入保存到变量：\n# read -p \"Please input your name: \" VAR\nPlease input your name: lizhenliang\n# echo $VAR\nlizhenliang\n用户输入保存为数组：\n# read -p \"Please input your name: \" -a ARRAY\nPlease input your name: a b c # echo ${ARRAY[*]}\na b c\n遇到 e 字符返回：\n# read -d e VAR\n123\n456\ne# echo $VAR\n123 456\n从文件作为 read 标准输入：\n# cat a.txt\nadfasfd\n# read VAR &lt; a.txt\n# echo $VAR\nadfasfd\nwhile 循环读取每一行作为 read 的标准输入：\n# cat a.txt |while read LINE; do echo $LINE; done\n123\nabc\n分别变量赋值：\n# read a b c 1 2 3 # echo $a\n1\n# echo $b\n2\n# echo $c\n3# echo 1 2 3 | while read a b c;do echo \"$a $b $c\"; done\n1 2 3</code></pre>\n<h2>九、Shell信号发送与捕捉</h2>\n<h3>1、Linux 信号类型 </h3>\n<p>信号（Signal）：信号是在软件层次上对中断机制的一种模拟，通过给一个进程发送信号，执行相<br/> 应的处理函数。</p>\n<p>进程可以通过三种方式来响应一个信号：</p>\n<p>1）忽略信号，即对信号不做任何处理，其中有两个信号不能忽略：SIGKILL 及 SIGSTOP。</p>\n<p>2）捕捉信号。</p>\n<p>3）执行缺省操作，Linux 对每种信号都规定了默认操作。</p>\n<p>Linux 究竟采用上述三种方式的哪一个来响应信号呢？取决于传递给响应的 API 函数。</p>\n<p>Linux 支持的信号有：</p>\n<p><img alt=\"\" height=\"322\" src=\"image\\ee97fd1b8d8740d4a1e17378b7d57ddf.png\" width=\"877\"/></p>\n<p><img alt=\"\" height=\"691\" src=\"image\\40d28ecffdf24cac914b1ac624b506da.png\" width=\"883\"/></p>\n<p><img alt=\"\" height=\"609\" src=\"image\\f688759a9390468b98ecc759cc75a02b.png\" width=\"883\"/></p>\n<p><img alt=\"\" height=\"167\" src=\"image\\8f083b984cdc47a28c3492bb53cfb5c7.png\" width=\"883\"/></p>\n<p>CoreDump（核心转储）：当程序运行过程中异常退出时，内核把当前程序在内存状况存储在一个<br/> core 文件中，以便调试。执行命令 ulimit -c 如果是 0 则没有开启，也不会生成 core dump 文件，<br/> 可通过 ulimit -c unlimited 命令临时开启 core dump 功能，只对当前终端环境有效，如果想永久<br/> 生效，可修改/etc/security/limites.conf 文件，添加一行 \"* soft core unlimited\"<br/> 默认生成的 core 文件保存在可执行文件所在的目录下，文件名为 core。</p>\n<p>如果想修改 core 文件保存路径，可通过修改内核参数：echo \"/tmp/corefile-%e-%p-%t\" &gt; /proc/sys/kernel/core_pattern，则文件名格式为 core-命名名-pid-时间戳。</p>\n<p>Linux 支持两种信号：</p>\n<p>一种是标准信号，编号 1-31，称为非可靠信号（非实时），不支持队列，信号可能会丢失，比如发送多次相同的信号，进程只能收到一次，如果第一个信号没有处理完，第二个信号将会丢弃。<br/> 另一种是扩展信号，编号 32-64，称为可靠信号（实时），支持队列，发多少次进程就可以收到多<br/> 少次。</p>\n<p>信号类型比较多，我们只要了解下，记住几个常用信号就行了，红色标记的我觉得需要记下。<br/> 发送信号一般有两种情况：</p>\n<p>一种是内核检测到系统事件，比如键盘输入 CTRL+C 会发送 SIGINT 信号。另一种是通过系统调用 kill 命令来向一个进程发送信号。 </p>\n<h3>2、kill 命令 </h3>\n<p>kill 命令发送信号给进程。</p>\n<p>命令格式：</p>\n<pre><code>kill [-s sigspec | -n signum | -sigspec] pid | jobspec ... </code></pre>\n<pre><code>kill -l [sigspec]\n-s # 信号名称\n-n # 信号编号\n-l # 打印编号 1-31 信号名称</code></pre>\n<p>示例：</p>\n<pre><code>给一个进程发送终止信号：\nkill -s SIGTERM pid\n或\nkill -n 15 pid\n或\nkill -15 pid\n或\nkill -TREM pid</code></pre>\n<h3>3、trap 命令 </h3>\n<p>trap 命令定义 shell 脚本在运行时根据接收的信号做相应的处理。</p>\n<p>命令格式：</p>\n<pre><code>trap [-lp] [[arg] signal_spec ...]\n-l # 打印编号 1-64 编号信号名称\narg # 捕获信号后执行的命令或者函数\nsignal_spec # 信号名或编号</code></pre>\n<p>一般捕捉信号后，做以下几个动作：</p>\n<p>1）清除临时文件<br/> 2）忽略该信号<br/> 3）询问用户是否终止脚本执行</p>\n<p>示例 1：按 CTRL+C 不退出循环</p>\n<pre><code>#!/bin/bash\ntrap \"\" 2 # 不指定 arg 就不做任何操作，后面也可以写多个信号，以空格分隔\nfor i in {1..10}; do\necho $i\nsleep 1\ndone\n# bash a.sh\n1\n2\n3\n^C4\n56\n^C7\n8\n9\n10</code></pre>\n<div>\n<span style=\"color:#000000;\">示例 2：循环打印数字，按 CTRL+C 退出，并打印退出提示</span>\n</div>\n<pre><code>#!/bin/bash\ntrap \"echo 'exit...';exit\" 2\nfor i in {1..10}; do\necho $i\nsleep 1\ndone\n# bash test.sh\n1\n2\n3\n^Cexit...</code></pre>\n<p>示例 3：让用户选择是否终止循环</p>\n<pre><code>#!/bin/bash\ntrap \"func\" 2\nfunc() {\nread -p \"Terminate the process? (Y/N): \" input\nif [ $input == \"Y\" ]; then\nexit\nfi\n}\nfor i in {1..10}; do\necho $i\nsleep 1\ndone\n# bash a.sh\n1\n2\n3\n^CTerminate the process? (Y/N): Y \n# bash a.sh\n1\n2\n3\n^CTerminate the process? (Y/N): N \n4\n5\n6\n...</code></pre>\n<h2>十、Shell编程时常用的系统文件</h2>\n<h3>1、Linux 系统目录结构</h3>\n<p><img alt=\"\" height=\"536\" src=\"image\\cc5131f209fc4abf9462204fcb79ea49.png\" width=\"877\"/></p>\n<p><img alt=\"\" height=\"114\" src=\"image\\d1a58919fab84670aa6ed721dae0c022.png\" width=\"873\"/></p>\n<h3>2、环境变量文件 </h3>\n<p><strong>① 系统级 </strong></p>\n<p>系统级变量文件对所有用户生效。</p>\n<p>/etc/profile # 系统范围内的环境变量和启动文件。不建议把要做的事情写在这里面，最好创建<br/> 一个自定义的，放在/etc/profile.d 下。</p>\n<p>/etc/bashrc # 系统范围内的函数和别名。</p>\n<p><strong>② 用户级 </strong></p>\n<p>用户级变量文件对自己生效，都在自己家目录下：</p>\n<p>~/.bashrc # 用户指定别名和函数<br/> ~/.bash_logout # 用户退出执行<br/> ~/.bash_profile # 用户指定变量和启动程序<br/> ~/.bash_history # 用户执行命令历史文件</p>\n<p>开启启动脚本顺序：/etc/profile -&gt; /etc/profile.d/*.sh -&gt; ~/.bash_profile -&gt; ~/.bashrc -&gt; <br/> /etc/bashrc</p>\n<p>因此，我们可以把写的脚本放到以上文件里执行。</p>\n<h3>3、<span style=\"color:#000000;\"><strong>系统配置文件 </strong></span></h3>\n<p><img alt=\"\" height=\"643\" src=\"image\\e98174e1422d47e798cbc20434ebcdc3.png\" width=\"873\"/></p>\n<p><img alt=\"\" height=\"478\" src=\"image\\de8cdac936c54b9aa2a71f2e006e65e6.png\" width=\"871\"/></p>\n<p><span style=\"color:#000000;\">crontab 任务计划说明： </span> </p>\n<pre><code># Example of job definition:\n# .---------------- minute (0 - 59)\n# | .------------- hour (0 - 23)\n# | | .---------- day of month (1 - 31)\n# | | | .------- month (1 - 12) OR jan,feb,mar,apr ...\n# | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR\nsun,mon,tue,wed,thu,fri,sat\n# | | | | | # * * * * * user-name command to be executed</code></pre>\n<h3>4、<span style=\"color:#000000;\"><strong>/dev 目录 </strong></span></h3>\n<div>\n<span style=\"color:#000000;\">/dev 目录下存放的是一些设备文件。</span>\n</div>\n<p><img alt=\"\" height=\"268\" src=\"image\\4527c0bde05446398abf6de032a53a5d.png\" width=\"881\"/></p>\n<h3>5、<span style=\"color:#000000;\"><strong>/proc 目录 </strong></span></h3>\n<div>\n<span style=\"color:#000000;\">/proc 是一个虚拟目录，在 Linux 系统启动后生成的，数据存储在内存中，存放内核运行时的参数、 网络信息、进程状态等等。</span>\n</div>\n<div></div>\n<p>1）<span style=\"color:#000000;\">/proc </span></p>\n<p><img alt=\"\" height=\"742\" src=\"image\\5a9256c67aeb4b97b062bbe15cfb4a86.png\" width=\"880\"/></p>\n<p>2）/proc/net </p>\n<p>/proc/net 目录存放的是一些网络协议信息。</p>\n<p><img alt=\"\" height=\"376\" src=\"image\\29df8d12a8ad414980e27ea4f625f5a3.png\" width=\"882\"/></p>\n<p><img alt=\"\" height=\"61\" src=\"image\\562b12244d574f2c9eaa98fa65c130a7.png\" width=\"880\"/></p>\n<p>3）/proc/sys </p>\n<p>这个目录下的文件可被读写，存了大多数内核参数，可以修改改变内核行为。所以修改这些文件要特别小心，修改错误可能导致内核不稳定。</p>\n<p>有四个主要的目录：</p>\n<pre><code>fs # 文件系统各方面信息，包括配额、文件句柄、inode 和目录项。\nkernel # 内核行为的信息\nnet # 网络配置信息，包括以太网、ipx、ipv4 和 ipv6。\nvm # Linux 内核的虚拟内存子系统，通常称为交换空间。</code></pre>\n<p><img alt=\"\" height=\"739\" src=\"image\\2766d619d87d440da054e732e27301f0.png\" width=\"700\"/></p>\n<p><img alt=\"\" height=\"617\" src=\"image\\860c18dc7d2249df9c2d8e9c2cc003e2.png\" width=\"698\"/></p>\n<p><img alt=\"\" height=\"404\" src=\"image\\5b66f65aac31420aac9644d6b2421a45.png\" width=\"700\"/></p>\n<p><img alt=\"\" height=\"199\" src=\"image\\62d34a6d30534a5f84c49a247f374ed9.png\" width=\"700\"/></p>\n<p> 详情参考：<a href=\"https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/deployment_guide/s2-proc-dir-sys\" title=\"E.3.9. /proc/sys/ Red Hat Enterprise Linux 6 | Red Hat Customer Portal\">E.3.9. /proc/sys/ Red Hat Enterprise Linux 6 | Red Hat Customer Portal</a></p>\n<h2>十一、Shell常用命令与工具</h2>\n<p>本节学习一些在编写 Shell 时的常用命令或工具及使用技巧。有人说 Shell 脚本是命令堆积的一<br/> 个文件，按顺序去执行。还有人说想学好 Shell 脚本，要把 Linux 上各种常见的命令或工具掌握<br/> 了，这些说法都没错。由于 Shell 语言本身在语法结构上比较简单，是面向过程编程，想实现复杂<br/> 的功能有点强人所难！</p>\n<p>而且 Shell 本身又工作在 Linux 内核之上，在用户态调用 Linux 命令会很方面，所以大多数情况下我们都是依靠这些命令来完成脚本中的某些功能，比如文本处理、获取系统状态等等，然后通过 Shell 语法结构组织代码逻辑。不管是学 Linux 系统好还是写 Shell 脚本也好，有些命令都是必须要会的，以下是根据个人经验总结的一些常用的命令。</p>\n<p>怎么更好的学习命令呢？</p>\n<p>当然查看官方帮助文档了，可以通过 man cmd、cmd --help、help cmd、info cmd 等方式查看命令的使用。</p>\n<h3>1、ls </h3>\n<p>功能：列出目录内容。</p>\n<p>常用选项：</p>\n<pre><code>-a 显示所有文件，包括隐藏的\n-l 长格式列出信息\n-i 显示文件 inode 号 -t 按修改时间排序\n-r 按修改时间倒序排序\n-h 打印易读大小单位</code></pre>\n<p>示例：</p>\n<pre><code>按修改时间排序：\n# ls -t\n按修改时间倒序排序：\n# ls -rt\n长格式列出：\n# ls -lh\n查看文件 inode： \n# ls -i file</code></pre>\n<p>2、echo </p>\n<p>功能：打印一行</p>\n<p>常用选项：</p>\n<pre><code>-n 不加换行符\n-e 解释转义符</code></pre>\n<p>示例：</p>\n<p>解释换行符。</p>\n<pre><code># echo -e \"1\\n2\\n3\"\n1\n2\n3</code></pre>\n<p>3、printf </p>\n<p>功能：格式化打印数据。默认打印字符串不换行。</p>\n<p>格式：</p>\n<pre><code>printf format [arguments]</code></pre>\n<p><img alt=\"\" height=\"507\" src=\"image\\89551a366c4048808bfea44cc9d058d6.png\" width=\"639\"/></p>\n<p> 一些常用的空白符：</p>\n<pre><code>\\n 换行\n\\r 回车\n\\t 水平制表符</code></pre>\n<p>示例：</p>\n<pre><code>输出一个字符：\n# printf \"%.1s\" abc\na\n保留一个小数点：\n# printf \"%.1f\" 1.333\n1.3\n输出换行：\n# printf \"%.1f\\n\" 1.333\n1.3\n格式化输出：\n# printf \"user: %s\\tpass: %d\\n\" abc 123\nuser: abc pass: 1\n左对齐宽度 10： # printf \"%-10s %-10s %-10s\\n\" ID Name Number\nID Name Number\n右对齐宽度 10： # printf \"%10s %10s %10s\\n\" ID Name Number\nID Name Number\n每段对齐：\n# printf \"%10s\\n\" ID Name Number\nID\nName\nNumber\n# printf \"%-10s\\n\" ID Name Number\nID\nName\nNumber</code></pre>\n<h3>4、cat</h3>\n<p>功能：连接文件和标准输出打印。</p>\n<p>常用选项：</p>\n<pre><code>-b 显示非空行行号\n-n 显示所有行行号\n-T 显示 tab，用^I 表示\n-E 显示以$结尾</code></pre>\n<p>示例：</p>\n<pre><code>连接两个文件：\n# cat a b # cat &lt;&lt; EOF\n&gt; 123\n&gt; abc\n&gt; EOF\n123\nabc\n将 eof 标准输入作为 cat 标准输出再写到 a.txt： # cat &gt; a.txt &lt;&lt; eof\n&gt; 123\n&gt; abc\n&gt; eof</code></pre>\n<h3>5、<span style=\"color:#000000;\"><strong>tac </strong></span></h3>\n<div>\n<span style=\"color:#000000;\">功能：连接文件和倒序打印文件。</span>\n</div>\n<div></div>\n<div>\n<span style=\"color:#000000;\">示例： </span>\n</div>\n<div></div>\n<div>\n<span style=\"color:#000000;\">倒序打印每一行。</span>\n</div>\n<div></div>\n<pre><code># tac a.txt</code></pre>\n<h3>6、<span style=\"color:#000000;\"><strong>rev </strong></span></h3>\n<div>\n<span style=\"color:#000000;\">功能：反向打印每一行。</span>\n</div>\n<div></div>\n<div>\n<span style=\"color:#000000;\">示例： </span>\n</div>\n<div></div>\n<pre><code># echo \"123\" |rev\n321</code></pre>\n<h3>7、<span style=\"color:#000000;\"><strong>wc </strong></span></h3>\n<div>\n<span style=\"color:#000000;\">功能：统计文件行数、字节、字符数 。</span>\n</div>\n<div></div>\n<div>\n<span style=\"color:#000000;\">常用选项： </span>\n</div>\n<div></div>\n<div>\n<pre><code>-c 打印文件字节数，一个英文字母 1 字节，一个汉字占 2-4 字节（根据编码）\n-m 打印文件字符数，一个汉字占 2 个字符\n-l 打印多少行\n-L 打印最长行的长度，也可以统计字符串长度</code></pre>\n<p><span style=\"color:#000000;\">示例：</span></p>\n</div>\n<pre><code>统计文件多少行：\n# wc -l file\n统计字符串长度： \n# echo \"hello\" |wc -L \n5</code></pre>\n<h3>8、cp</h3>\n<p>功能：复制文件或目录。</p>\n<p>常用选项：</p>\n<pre><code>-a 归档\n-b 目标文件存在创建备份，备份文件是文件名跟~ -f 强制复制文件或目录\n-r 递归复制目录\n-p 保留原有文件或目录属性\n-i 覆盖文件之前先询问用户\n-u 当源文件比目的文件修改时间新时才复制\n-v 显示复制信息</code></pre>\n<p>示例：</p>\n<pre><code>复制目录：\n# cp -rf test /opt</code></pre>\n<h3>9、mkdir </h3>\n<p>功能：创建目录。</p>\n<p>常用选项：</p>\n<pre><code>-p 递归创建目录\n-v 显示创建过程</code></pre>\n<p>示例：</p>\n<pre><code>创建多级目录：\n# mkdir /opt/test/abc\n创建多个目录：\n# mkdir {install,tmp}\n创建连续目录：\n# mkdir {a..c}</code></pre>\n<h3>10、<span style=\"color:#000000;\"><strong>mv </strong></span></h3>\n<div>\n<span style=\"color:#000000;\">功能：移动文件或重命名。</span>\n</div>\n<div></div>\n<div>\n<span style=\"color:#000000;\">常用选项： </span>\n</div>\n<div>\n<pre><code>-b 目标文件存在创建备份，备份文件是\"文件名后跟~\"\n-u 当源文件比目的文件修改时间新时才移动\n-v 显示移动信息</code></pre>\n<p><span style=\"color:#000000;\">示例：</span></p>\n</div>\n<pre><code>移动文件：\n# mv a.txt /opt\n重命名文件：\n# mv a.txt b.txt</code></pre>\n<h3>11、rename</h3>\n<p>功能：重命名文件，支持通配符。</p>\n<p>示例：批量命名文件</p>\n<pre><code>将 foo1-foo9 替换为 foo01-foo09：\n# rename foo foo0 foo?\n将以.htm 后缀的文件替换为.html：\n# rename .htm .html *.htm</code></pre>\n<h3>12、dirname</h3>\n<p>功能：去除路径的最后一个名字。</p>\n<p>示例：</p>\n<pre><code># dirname /usr/bin/\n/usr\n# dirname dir1/str dir2/str\ndir1\ndir2\n# dirname stdio.h\n.</code></pre>\n<h3>13、basename </h3>\n<p>功能：打印路径的最后一个名字。</p>\n<p>常用选项：</p>\n<pre><code>-a 支持多个参数\n-s 删除后面的后缀</code></pre>\n<p>示例：</p>\n<pre><code># basename /usr/bin/sort\nsort\n# basename include/stdio.h .h\nstdio\n# basename -s .h include/stdio.h\nstdio\n# basename -a any/str1 any/str2\nstr1\nstr2</code></pre>\n<h3>14、du </h3>\n<p>功能：估算文件磁盘空间使用。</p>\n<p>常用选项：</p>\n<pre><code>-h 易读格式显示（K，M，G） -b 单位 bytes 显示\n-k 单位 KB 显示\n-m 单位 MB 显示\n-s 只显示总大小\n--max-depth=&lt;目录层数&gt;，超过层数的目录忽略\n--exclude=file 排除文件或目录\n--time 显示大小和创建时间</code></pre>\n<p>示例：</p>\n<pre><code>查看目录大小：\n# du -sh /opt\n排除目录某个文件：\n# du -sh --exclude=test /opt</code></pre>\n<h3>15、cut </h3>\n<p>功能：选取文件的每一行数据。</p>\n<p>常用选项：</p>\n<pre><code>-b 选中第几个字符\n-c 选中多少个字符\n-d 指定分隔符分字段，默认是空格\n-f 显示选中字段</code></pre>\n<p>示例：</p>\n<pre><code>打印 b 字符：\n# echo \"abc\" |cut -b \"2\"\nb\n截取 abc 字符：\n# echo \"abcdef\" |cut -c 1-3\nabc\n以冒号分隔，显示第二个字段：\n# echo \"a:b:c\" |cut -d: -f2\nb</code></pre>\n<h3>16、tr </h3>\n<p>功能：替换或删除字符。</p>\n<p>格式：</p>\n<pre><code>Usage: tr [OPTION]... SET1 [SET2]</code></pre>\n<p>常用选项：</p>\n<pre><code>-c 替换 SET1 没有 SET2 的字符\n-d 删除 SET1 中字符\n-s 压缩 SET1 中重复的字符\n-t 将 SET1 用 SET2 转换，默认</code></pre>\n<p>示例：</p>\n<pre><code>替换 SET1 没有 SET2 的字符：\n# echo \"aaabbbccc\" | tr -c c 1\n111111ccc\n去重字符：\n# echo \"aaacccddd\" | tr -s '[a-z]'\nacd\n删除字符：\n# echo \"aaabbbccc\" | tr -d bbb\naaaccc\n删除换行符：\n# echo -e \"a\\nb\\nc\" | tr -d '\\n'\nabc\n替换字符：\n# echo \"aaabbbccc\" | tr '[a-z]' '[A-Z]'\nAAABBBCCC</code></pre>\n<h3><strong>17、<span style=\"color:#000000;\">stat </span></strong></h3>\n<div>\n<span style=\"color:#000000;\">功能：显示文件或文件的系统状态。</span>\n</div>\n<div></div>\n<div>\n 常用选项：\n</div>\n<div></div>\n<div>\n<pre><code>-Z 显示 selinux 安全上下文\n-f 显示文件系统状态\n-c 指定格式输出内容\n-t 以简洁的形式打印</code></pre>\n<p><span style=\"color:#000000;\">示例：</span></p>\n</div>\n<pre><code>显示文件信息：\n# stat file\n只显示文件修改时间：\n# stat -c %y file</code></pre>\n<h3>18、seq </h3>\n<p>功能：打印序列化数字。</p>\n<p>常用选项：</p>\n<pre><code>-f 使用 printf 样式格式\n-s 指定换行符，默认是\\n -w 等宽，用 0 填充</code></pre>\n<p>示例：</p>\n<pre><code>数字序列：\n# seq 3 \n1\n2\n3\n带0的数字序列：\n# seq -w 03\n01\n02\n03\n范围数字序列：\n# seq 2 5 \n2\n3\n4\n5\n步长序列：\n# seq 1 2 5 # 2 是步长\n1\n3\n5\n以冒号分隔序列：\n# seq -s \"+\" 5\n1+2+3+4+5\n等宽并在数字前面加字符串：\n# seq -f \"str%02g\" 3 # %g 是默认数字位数，02 是数字不足 2 位时用 0 填充。\nstr01\nstr02\nstr03</code></pre>\n<h3>19、shuf </h3>\n<p>功能：生成随机序列。</p>\n<p>常用选项：</p>\n<pre><code>-i 输出数字范围\n-o 结果写入文件</code></pre>\n<p>示例：</p>\n<p>输出范围随机数。</p>\n<pre><code># seq 5 |shuf\n2\n1\n5\n4\n3\n# shuf -i 5-10\n8\n10\n7\n9\n6\n5</code></pre>\n<h3>20、sort</h3>\n<p>功能：排序文本，默认对整列有效。</p>\n<p>常用选项：</p>\n<pre><code>-f 忽略字母大小写\n-M 根据月份比较，比如 JAN、DEC\n-h 根据易读的单位大小比较，比如 2K、1G\n-g 按照常规数值排序\n-n 根据字符串数值比较\n-r 倒序排序\n-k 位置 1,位置 2 根据关键字排序，在从第位置 1 开始，位置 2 结束\n-t 指定分隔符\n-u 去重重复行\n-o 将结果写入文件</code></pre>\n<p>示例：</p>\n<pre><code>随机数字排序：\n# seq 5 |shuf |sort\n随机字母排序：\n# printf \"%c\\n\" {a..f} |shuf |sort\n倒序排序：\n# seq 5 |shuf |sort -r\n分隔后的字段排序：\n# cat /etc/passwd |sort -t : -k 3 -n\n去重重复行：\n# echo -e \"1\\n1\\n2\\n3\\n3\" |sort -u\n大小单位排序：\n# du -h |sort -k 1 -h -r\n分隔后第一个字段的第二个字符排序：\n# echo -e \"fa:1\\neb:2\\ncc:3\" |sort -t : -k 1.2\ntab 作为分隔符：\n# sort -t $\"\\t\"\nfile 文件内容：\nzhangsan 6 100\nlisi 8 80\nwangwu 7 90\nzhaoliu 9 70\n对 file 文件的第二列正序排序，再次基础再对第三列倒序排序（多列排序）： \n# sort -k 2,2 -n -k 3,3 -nr file\n# sort -k 2 -n -k 3 -nr file\nzhaoliu 9 70\nlisi 8 80\nwangwu 7 90\nzhangsan 6 100\n对两个文件同时排序：\n# sort file1 file2</code></pre>\n<h3>21、uniq </h3>\n<p>功能：去除重复行,只会统计相邻的。</p>\n<p>常用选项：</p>\n<pre><code>-c 打印出现的次数\n-d 只打印重复行\n-u 只打印不重复行\n-D 只打印重复行，并且把所有重复行打印出来\n-f N 比较时跳过前 N 列 -i 忽略大小写\n-s N 比较时跳过前 N 个字符\n-w N 对每行第 N 个字符以后内容不做比较</code></pre>\n<p>示例：</p>\n<pre><code>测试文本如下：\n# cat file\nabc\ncde\nxyz\ncde\nxyz\nabd\n去重复行：\n# sort file |uniq\nabc\nabd\ncde\nxyz\n打印每行重复次数：\n# sort file |uniq -c\n 1 abc\n 1 abd\n 2 cde\n 2 xyz\n打印不重复行：\n# sort file |uniq -u\nabc\nabd\n打印重复行：\n# sort file |uniq -d\ncde\nxyz\n打印重复行并统计出现次数：\n# sort file |uniq -d -c\n 2 cde\n 2 xyz\n根据前几个字符去重：\n# sort file |uniq -w 2\nabc\ncde\nxyz</code></pre>\n<h3>22、tee </h3>\n<p>功能：从标准输入读取写到标准输出和文件。</p>\n<p>常用选项：</p>\n<pre><code>-a 追加到文件</code></pre>\n<p>示例：</p>\n<pre><code>打印并追加到文件：\n# echo 123 |tee -a a.log</code></pre>\n<h3>23、join </h3>\n<p>功能：连接两个文件。</p>\n<p>常用选项：</p>\n<pre><code>-i 忽略大小写\n-o 按照指定文件栏位显示\n-t 使用字符作为输入和输出字段分隔符</code></pre>\n<p>示例：</p>\n<pre><code># cat file1\n1 a \n2 b \n3 c \n# cat file2\n1 x \n2 y \n3 z\n将两个文件相同字段合并一列： # join file1 file2\n1 a x \n2 b y \n3 c z\n打印 file1 第二列和 file2 第二列：\n# join -o 1.2 2.2 file1 file2\na x \nb y \nc z \n# join -t ':' -o 1.1 2.1 /etc/passwd /etc/shadow\nuser1:user1\n……</code></pre>\n<h3>24、paste </h3>\n<p>功能：合并文件。</p>\n<p>常用选项：</p>\n<pre><code>-d 指定分隔符，默认是 tab 键分隔\n-s 将文件内容平行合并，默认 tab 键分隔</code></pre>\n<p>示例：</p>\n<pre><code># seq 1 3 &gt; file1\n# seq 4 6 &gt; file2\n两个文件合并：\n# paste file1 file2\n1 4 \n2 5\n3 6\n两个文件合并，+号分隔：\n# paste -d \"+\" file1 file2\n1+4\n2+5\n3+6\n文件内容平行显示：\n# paste -s file1 file2 \n1 2 3 \n4 5 6</code></pre>\n<h3>25、head</h3>\n<div>\n<span style=\"color:#000000;\">功能：输出文件的前几行。</span>\n</div>\n<div>\n<span style=\"color:#000000;\">常用选项： </span>\n</div>\n<div>\n<pre><code>-c 打印前多少 K，M\n-n 打印前多少行</code></pre>\n<p><span style=\"color:#000000;\">示例： </span></p>\n</div>\n<pre><code>打印文件前 50 行：\n# head -n 50 file</code></pre>\n<h3>26、tail </h3>\n<p>功能：输出文件的后几行。</p>\n<p>常用选项：</p>\n<pre><code>-c 打印后多少 K，M -f 实时读文件，随着文件输出附加输出\n-n 输出最后几行\n--pid 与-f 一起使用，表示 pid 死掉后结束\n-s 与-f 一起使用，表示休眠多少秒输出</code></pre>\n<p>示例：</p>\n<pre><code>打印文件后 50 行：\n# tail -n 50 file\n实时输出新增行：\n# tail -f file</code></pre>\n<h3>27、find</h3>\n<p>功能：目录层次结构中搜索文件。</p>\n<p>格式：</p>\n<pre><code>find path -option actions</code></pre>\n<p>常用选项：</p>\n<pre><code>-name 文件名，支持(‘*’, ‘?’) -type 文件类型，d 目录，f 常规文件等\n-perm 符合权限的文件，比如 755\n-atime -/+n 在 n 天以内/过去 n 天被访问过\n-ctime -/+n 在 n 天以内/过去 n 天被修改过\n-amin -/+n 在 n 天以内/过去 n 分钟被访问过\n-cmin -/+n 在 n 天以内/过去 n 分钟被修改过\n-size -/+n 文件大小小于/大于，b、k、M、G -maxdepth levels 目录层次显示的最大深度\n-regex pattern 文件名匹配正则表达式模式\n-inum 通过 inode 编号查找文件\n动作：\n-detele 删除文件\n-exec command {} \\; 执行命令，花括号代表当前文件\n-ls 列出当前文件，ls -dils 格式\n-print 完整的文件名并添加一个回车换行符\n-print0 打印完整的文件名并不添加一个回车换行符\n-printf format 打印格式\n其他字符：\n！ 取反\n-or/-o 逻辑或 -and 逻辑和</code></pre>\n<p>示例：</p>\n<pre><code>查找文件名：\n# find / -name \"*http*\"\n查找文件名并且文件类型：\n# find /tmp -name core -type f -print\n查找文件名并且文件类型删除：\n# find /tmp -name core -type f -delete\n查找当前目录常规文件并查看文件类型：\n# find . -type f -exec file '{}' \\;\n查找文件权限是 664： # find . -perm 664\n查找大于 1024k 的文件：\n# find . -size -1024k\n查找 3 天内修改的文件：\n# find /bin -ctime -3\n查找 3 分钟前修改的文件：\n# find /bin -cmin +3\n排除多个类型的文件：\n# find . ! -name \"*.sql\" ! -name \"*.txt\"\n或条件查找多个类型的文件：\n# find . -name '*.sh' -o -name '*.bak'\n# find . -regex \".*\\.sh\\|.*\\.bak\"\n# find . -regex \".*\\.\\(sh\\|bak\\)\"\n并且条件查找文件：\n# find . -name \"*.sql\" -a -size +1024k\n只显示第一级目录：\n# find /etc -type d -maxdepth 1\n通过 inode 编号删除文件：\n# rm `find . -inum 671915`\n# find . -inum 8651577 -exec rm -i {} \\;</code></pre>\n<h3>28、xargs </h3>\n<p>功能：从标准输入执行命令。</p>\n<p>常用选项：</p>\n<pre><code>-a file 从指定文件读取数据作为标准输入\n-0 处理包含空格的文件名,print0\n-d delimiter 分隔符，默认是空格分隔显示\n-i 标准输入的结果以{}代替\n-I 标准输入的结果以指定的名字代替\n-t 显示执行命令\n-p 交互式提示是否执行命令\n-n 最大命令行参数\n--show-limits 查看系统命令行长度限制</code></pre>\n<p>示例：</p>\n<pre><code>删除/tmp 下名字是 core 的文件：\n# find /tmp -name core -type f -print | xargs /bin/rm -f # find /tmp -name core -type f -print0 | xargs -0 /bin/rm -f\n列转行（去除换行符 ）：\n# cut -d: -f1 &lt; /etc/passwd | sort | xargs echo\n行转列：\n# echo \"1 2 3 4 5\" |xargs -n1\n最长两列显示：\n# echo \"1 2 3 4 5\" |xargs -n2\n创建未来十天时间：\n# seq 1 10 |xargs -i date -d \"{} days \" +%Y-%m-%d\n复制多个目录：\n# echo dir1 dir2 |xargs -n1 cp a.txt\n清空所有日志：\n# find ./ -name \"*.log\" |xargs -i tee {} # echo \"\"&gt; {} 这样不行，&gt;把命令中断了\nrm 在删除大量的文件时，会提示参数过长，那么可以使用 xargs 删除：\n# ls |xargs rm –rf\n或分配删除 rm [a-n]* -rf # getconf ARG_MAX 获取系统最大参数限制</code></pre>\n<h3>29、nl </h3>\n<p>功能：打印文件行号。</p>\n<p>常用选项：</p>\n<pre><code>-b &lt;a|t&gt; 指定行号显示方式，a 表示所有行都打印行号，b 表示空行不显示行号，默认是 a -n &lt;ln|rn|rz&gt; 行号显示方法，ln 左对齐，rn 右对齐，rz 右边显示，左边空白用 0 填充。\n-w 行号栏位在左边占用的宽度</code></pre>\n<p>示例：</p>\n<pre><code>打印行号，空行不显示：\n# nl a.txt\n左对齐打印行号：\n# nl -n ln a.txt\n行号右移动五个空格：\n# nl -w 5 a.txt</code></pre>\n<h3>30、date </h3>\n<p>功能：打印或设置系统日期和时间。</p>\n<p>常用选项：</p>\n<pre><code>-d string 显示指定字符串所描述的时间，而非当前时间\n-f datefile 从日期文件中按行读入时间描述\n-I 输出 ISO 8601 格式的日期和时间\n-r 显示文件的最后修改时间\n-R 输出 RFC 2822 格式的日期和时间\n-s string 设置时间所描述的字符串\n-u 打印或设置 UTC 时间</code></pre>\n<p>控制输出格式：</p>\n<pre><code> %% 一个文字的 %\n %a 当前 locale 的星期名缩写(例如： 日，代表星期日)\n %A 当前 locale 的星期名全称 (如：星期日)\n %b 当前 locale 的月名缩写 (如：一，代表一月)\n %B 当前 locale 的月名全称 (如：一月)\n %c 当前 locale 的日期和时间 (如：2005 年 3 月 3 日 星期四 23:05:25)\n %C 世纪；比如 %Y，通常为省略当前年份的后两位数字(例如：20)\n %d 按月计的日期(例如：01)\n %D 按月计的日期；等于%m/%d/%y\n %e 按月计的日期，添加空格，等于%_d\n %F 完整日期格式，等价于 %Y-%m-%d\n %g ISO-8601 格式年份的最后两位 (参见%G)\n %G ISO-8601 格式年份 (参见%V)，一般只和 %V 结合使用\n %h 等于%b\n %H 小时(00-23)\n %I 小时(00-12)\n %j 按年计的日期(001-366)\n %k 时(0-23)\n %l 时(1-12)\n %m 月份(01-12)\n %M 分(00-59)\n %n 换行\n %N 纳秒(000000000-999999999)\n %p 当前 locale 下的\"上午\"或者\"下午\"，未知时输出为空\n %P 与%p 类似，但是输出小写字母\n %r 当前 locale 下的 12 小时时钟时间 (如：11:11:04 下午)\n %R 24 小时时间的时和分，等价于 %H:%M\n %s 自 UTC 时间 1970-01-01 00:00:00 以来所经过的秒数\n %S 秒(00-60)\n %t 输出制表符 Tab\n %T 时间，等于%H:%M:%S\n %u 星期，1 代表星期一\n %U 一年中的第几周，以周日为每星期第一天(00-53)\n %V ISO-8601 格式规范下的一年中第几周，以周一为每星期第一天(01-53)\n %w 一星期中的第几日(0-6)，0 代表周一\n %W 一年中的第几周，以周一为每星期第一天(00-53)\n %x 当前 locale 下的日期描述 (如：12/31/99)\n %X 当前 locale 下的时间描述 (如：23:13:48)\n %y 年份最后两位数位 (00-99)\n %Y 年份</code></pre>\n<p>示例：</p>\n<pre><code>设置系统日期和时间：\n# date -s \"2016-12-15 00:00:00\"\n查看当前系统时间戳：\n# date +%s\n查看当前系统时间：\n# date +'%F %T'\n把日期和时间转换成时间戳：\n# date -d \"2016-12-15 18:00:00\" +%s\n把时间戳转成时间：\n# date -d '@1481842800' '+%F %T'\n时间加减：\n显示前 30 秒：date -d '-30 second' +'%F %T'\n显示前一分钟：date -d '-1 minute' +'%F %T'\n显示前一个时间：date -d '-1 hour' +'%F %T' \n显示前一个天：date -d '-1 day' +'%F %T'\n显示上一周：date -d '-1 week' +'%F %T'\n显示上一个月日期：date -d '-1 month' +%F\n显示上一年日期：date -d '-1 year' +%F\n或\n显示前一天日期：date -d yesterday +%F\n显示后一天日期：date -d tomorrow +%F\n时间比较：\nNOW_DATE=$(date +%s)\nAGO_DATE=$(date -d \"2016-12-15 18:00:00\" +%s)\n[ $NOW_DATE -gt $AGO_DATE ] &amp;&amp; echo yes || echo no</code></pre>\n<h3>31、wget</h3>\n<p>功能：非交互式网络下载，类似于 HTTP 客户端。</p>\n<p>常用选项：</p>\n<pre><code>-b, --background 后台运行</code></pre>\n<p>日志记录和输入文件：</p>\n<pre><code>-o, --output-file=FILE 日志写到文件\n-a, --append-output=FILE 日志追加到文件\n-d, --debug 打印 debug 信息，会包含头信息\n-q, --quiet 退出，不输出\n-i, --input-file=FILE 从文件中读取 URL 下载 </code></pre>\n<p>下载选项：</p>\n<pre><code>-t, --tries=NUMBER 设置链接重试次数\n-O, --output-document=FILE 写入内容到文件\n-nc, --no-clobber 跳过下载现有的文件\n-c, --continue 断点续传\n--progress=TYPE 设置进度条（dot 和 bar） -S, --server-response 打印服务器响应头信息\n--spider 不下载任何内容\n-T, --timeout=SECONDS 设置相应超时时间（还有--dns-timeout、--connect-timeout 和\n--read-timeout） -w, --wait=SECONDS 两次重试间隔等待时间\n--bind-address=ADDRESS 设置绑定地址\n--limit-rate=RATE 限制下载速度\n--user=USER 设置 ftp 和 http 用户名\n--password=PASS 设置 ftp 和 http 密码</code></pre>\n<p>目录：</p>\n<pre><code>-P, --directory-prefix=PREFIX 保存文件目录</code></pre>\n<p>HTTP 选项：</p>\n<pre><code>--http-user=USER 设置 http 用户名\n--http-password=PASS 设置 http 密码\n--proxy-user=USER 设置代理用户名\n--proxy-password=PASS 设置代理密码\n--referer=URL 设置 Referer\n--save-headers 保存头到文件\n--default-page=NAME 改变默认页面名字，默认 index.html\n-U,--user-agent=AGENT 设置客户端信息\n--no-http-keep-alive 禁用 HTTP keep-alive（长连接）\n--load-cookies=FILE 从文件加载 cookies\n--save-cookies=FILE 保存 cookies 到文件\n--post-data=STRING 使用 POST 方法，发送数据</code></pre>\n<p>FTP 选项：</p>\n<pre><code>--ftp-user=USER 设置 ftp 用户名\n--ftp-password=PASS 设置 ftp 密码\n--no-passive-ftp 禁用被动传输模式</code></pre>\n<p>递归下载：</p>\n<pre><code>-r, --recursive 指定递归下载\n-l, --level=NUMBER 最大递归深度\n-A, --accept=LIST 逗号分隔下载的扩展列表\n-R, --reject=LIST 逗号分隔不被下载的扩展列表\n-D, --domains=LIST 逗号分隔被下载域的列表\n--exclude-domains=LIST 排除不被下载域的列表</code></pre>\n<p>示例：</p>\n<pre><code>下载单个文件到当前目录：\n# wget http://nginx.org/download/nginx-1.11.7.tar.gz\n放到后台下载：\n# wget -b http://nginx.org/download/nginx-1.11.7.tar.gz\n对于网络不稳定的用户使用-c 和--tries 参数，保证下载完成，并下载到指定目录：\n# wget -t 3 -c http://nginx.org/download/nginx-1.11.7.tar.gz -P down\n不下载任何内容，判断 URL 是否可以访问：\n# wget --spider http://nginx.org/download/nginx-1.11.7.tar.gz\n下载内容写到文件：\n# wget http://www.baidu.com/index.html -O index.html\n从文件中读取 URL 下载：\n# wget -i url.list\n下载 ftp 文件：\n# wget --ftp-user=admin --ftp-password=admin ftp://192.168.1.10/ISO/CentOS-6.5-i386-\nminimal.iso\n伪装客户端，指定 user-agent 和 referer 下载：\n# wget -U \"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko)\nChrome/44.0.2403.157 Safari/537.36\" --referer \"http://nginx.org/en/download.html\"\nhttp://nginx.org/download/nginx-1.11.7.tar.gz\n查看 HTTP 头信息：\n# wget -S http://nginx.org/download/nginx-1.11.7.tar.gz\n# wget --debug http://nginx.org/download/nginx-1.11.7.tar.gz</code></pre>\n<h3>32、curl </h3>\n<p>功能：发送数据到 URL，类似于 HTTP 客户端。</p>\n<p>常用选项：</p>\n<pre><code>-k, --insecure 允许 HTTPS 连接网站\n-C, --continue-at 断点续传\n-b, --cookie STRING/FILE 从文件中读取 cookie\n-c, --cookie-jar 把 cookie 保存到文件\n-d, --data 使用 POST 方式发送数据\n--data-urlencode POST 的数据 URL 编码\n-F, --form 指定 POST 数据的表单\n-D, --dump-header 保存头信息到文件\n--ftp-pasv 指定 FTP 连接模式 PASV/EPSV\n-P, --ftp-port 指定 FTP 端口\n-L, --location 遵循 URL 重定向，默认不处理\n-l, --list-only 指列出 FTP 目录名\n-H, --header 自定义头信息发送给服务器\n-I, --head 查看 HTTP 头信息\n-o, --output FILE 输出到文件\n-#, --progress-bar 显示 bar 进度条\n-x, --proxy [PROTOCOL://]HOST[:PORT] 使用代理\n-U, --proxy-user USER[:PASSWORD] 代理用户名和密码\n-e, --referer 指定引用地址 referer\n-O, --remote-name 使用远程服务器上名字写到本地\n--connect-timeout 连接超时时间，单位秒\n--retry NUM 连接重试次数\n--retry-delay 两次重试间隔等待时间\n-s, --silent 静默模式，不输出任何内容\n-Y, --speed-limit 限制下载速率\n-u, --user USER[:PASSWORD] 指定 http 和 ftp 用户名和密码\n-T, --upload-file 上传文件\n-A, --user-agent 指定客户端信息</code></pre>\n<p>示例：</p>\n<pre><code>下载页面：\n# curl -o badu.html http://www.baidu.com\n不输出下载信息：\n# curl -s -o baidu.html http://www.baidu.com\n伪装客户端，指定 user-agent 和 referer 下载：\n# curl -A \"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko)\nChrome/44.0.2403.157 Safari/537.36\" -e \"baike.baidu.com\" http://127.0.0.1\n模拟用户登录，并保存 cookies 到文件：\n# curl -c ./cookies.txt -F NAME=user -F PWD=123 http://www.example.com/login.html\n使用 cookie 访问：\n# curl -b cookies.txt http://www.baidu.com\n访问 HTTP 认证页面：\n# curl -u user:pass http://www.example.com\nFTP 上传文件：\n# curl -T filename ftp://user:pass@ip/a.txt\n# curl ftp://ip -u user:pass-T filename\nFTP 下载文件：\n# curl -O ftp://user:pass@ip/a.txt\n# curl ftp://ip/filename -u user:pass -o filename\nFTP 下载多个文件：\n# curl ftp://ip/img/[1,3,5].jpg\n查看 HTTP 头信息：\n# curl -I http://www.baidu.com</code></pre>\n<h3>32、scp</h3>\n<p>功能：基于 SSH 的安全远程服务器文件拷贝。</p>\n<p>常用选项：</p>\n<pre><code>-i 指定私钥文件\n-l 限制速率，单位 Kb/s，1024Kb=1Mb\n-P 指定远程主机 SSH 端口\n-p 保存修改时间、访问时间和权限\n-r 递归拷贝目录\n-o SSH 选项，有以下几个比较常用的：\nConnectionAttempts=NUM 连接失败后重试次数\nConnectTimeout=SEC 连接超时时间\nStrictHostKeyChecking=no 自动拉去主机 key 文件\nPasswordAuthentication=no 禁止密码认证</code></pre>\n<p>示例：</p>\n<pre><code>本地目录推送到远程主机：\n# scp -P 22 -r src_dir root@192.168.1.10:/dst_dir\n远程主机目录拉取到本地：\n# scp -P 22 -r root@192.168.1.10:dst_dir src_dir\n同步文件方式一样，不用加-r 参数</code></pre>\n<h3>34、rsync </h3>\n<p>功能：远程或本地文件同步工具。</p>\n<p>常用选项：</p>\n<pre><code>-v 显示复制信息\n-q 不输出错误信息\n-c 跳过基础效验，不判断修改时间和大小\n-a 归档模式，等效-rlptgoD，保留权限、属组等\n-r 递归目录\n-l 拷贝软连接\n-z 压缩传输数据\n-e 指定远程 shell，比如 ssh、rsh\n--progress 进度条，等同-P\n--bwlimit=KB/s 限制速率，0 为没有限制\n--delete 删除那些 DST 中 SRC 没有的文件\n--exclude=PATTERN 排除匹配的文件或目录\n--exclude-from=FILE 从文件中读取要排除的文件或目录\n--password-file=FILE 从文件读取远程主机密码\n--port=PORT 监听端口</code></pre>\n<p>示例：</p>\n<pre><code>本地复制目录：\n# rsync -avz abc /opt\n本地目录推送到远程主机：\n# rsync -avz SRC root@192.168.1.120:DST\n远程主机目录拉取到本地：\n# rsync -avz root@192.168.1.10:SRC DST\n保持远程主机目录与本地一样：\n# rsync -avz --delete SRC root@192.168.1.120:DST\n排除某个目录：\n# rsync -avz --exclude=no_dir SRC root@192.168.1.120:DST\n指定 SSH 端口：\n# rsync -avz /etc/hosts -e \"ssh -p22\" root@192.168.1.120:/opt</code></pre>\n<h3>35、nohup </h3>\n<p>功能：运行程序，忽略挂起信号。</p>\n<p>示例：</p>\n<pre><code>后台运行程序，终端关闭不影响：\n# nohup bash test.sh &amp;&gt;test.log &amp;</code></pre>\n<h3>36、iconv </h3>\n<p>功能：将文件内容字符集转成其他字符集。</p>\n<p>常用选项：</p>\n<pre><code>-l 列出所有已知的字符集\n-f 原始文本编码\n-t 输出编码\n-o 输出到文件\n-s 关闭警告</code></pre>\n<p>示例：</p>\n<pre><code>将文件内容转换 UTF8： \n# iconv -f gbk -t utf8 old.txt -o new.txt\n将 csv 文件转换 GBK： \n# iconv -f utf8 -t gbk old.txt -o new.txt\n解决邮件乱码：\n# echo $(echo \"content\" | iconv -f utf8 -t gbk) | mail -s \"$(echo \"title\" | iconv -f\nutf8 -t gbk)\" example@mail.com</code></pre>\n<h3>37、uname</h3>\n<p>功能：输出系统信息。</p>\n<p>常用选项：</p>\n<pre><code>-a 输出以下所有信息\n-s 输出内核名称\n-n 输出主机名\n-r 输出内核发行版\n-v 输出内核版本\n-m 输出主机的硬件架构名称\n-p 输出处理器类型或\"unknown\"\n-i 输出硬件平台或\"unknown\n-o 输出操作系统名称</code></pre>\n<p>示例：</p>\n<pre><code>输出所有系统信息：\n# uname -a\n输出主机名：\n# uname -a\n输出内核版本：\n# uname -r\n输出操作系统：\n# uname -o</code></pre>\n<h3>38、sshpass </h3>\n<p>功能：非交互 SSH 登录（需要安装）。</p>\n<p>常用选项：</p>\n<pre><code>-f 从文件中获取密码\n-d 用文件描述符数字获取密码\n-p 指定 SSH 密码\n-e 密码作为环境变量传递，变量名是 SSHPASS</code></pre>\n<p>示例：</p>\n<pre><code>免交互 SSH 登录：\n# sshpass -p 123456 ssh root@192.168.1.10\n免交互传输文件：\n# sshpass -p 123456 scp a.txt 192.168.1.10:/root\n密码传入系统变量：\n# SSHPASS=123456 rsync -avz /etc/hosts -e \"sshpass -e ssh\" root@192.168.1.221:/opt</code></pre>\n<h3>39、tar </h3>\n<p>功能：归档目录或文件。</p>\n<p>常用选项：</p>\n<pre><code>-c 创建新归档\n-d 比较归档和文件系统的差异\n-r 追加文件到归档\n-t 存档的内容列表\n-x 提取归档所有文件\n-C 改变解压目录\n-f 使用归档文件或设备归档\n-j bzip2 压缩\n-z gzip 压缩\n-v 输出处理过程</code></pre>\n<p>示例：</p>\n<pre><code>创建归档文件来自 foo 和 bar： \n# tar -cf archive.tar foo bar\n提取归档的所有文件：\n# tar -xf archive.tar\n列出所有归档文件内容：\n# tar -tvf archive.tar\n创建归档并 gzip 压缩：\n# tar -zcvf archive.tar.gz log\n提取归档文件并 gzip 解压：\n# tar -zxvf log.tar.gz\n创建归档并 bzip2 压缩：\n# tar -jcvf log.tar.bz log\n提取归档并解压到指定目录：\n# tar -zxvf log.tar.gz -C /opt</code></pre>\n<h3>40、logger </h3>\n<p>功能：系统日志的 shell 命令行接口。</p>\n<p>常用选项：</p>\n<pre><code>-i 每行记录进程 ID\n-f 指定输出日志到文件\n-p 设置记录的优先级\n-t 添加标签</code></pre>\n<p>示例：</p>\n<pre><code># logger -i -t \"my_test\" -p local3.notice \"test_info\"</code></pre>\n<h3>41、<span style=\"color:#000000;\"><strong>netstat </strong></span></h3>\n<div>\n<span style=\"color:#000000;\">功能：打印网络连接、路由表、接口统计信息、伪装连接和多播成员。</span>\n</div>\n<div></div>\n<div>\n<p><span style=\"color:#000000;\">常用选项： </span></p>\n<pre><code>-r 显示路由表\n-i 显示接口表\n-n 不解析名字\n-p 显示程序名 PID/Program\n-l 显示监听的 socket\n-a 显示所有 socket\n-o 显示计时器\n-Z 显示上下文\n-t 只显示 tcp 连接\n-u 只显示 udp 连接\n-s 显示每个协议统计信息</code></pre>\n<p><span style=\"color:#000000;\">示例：</span></p>\n</div>\n<pre><code>显示所有监听：\n# netstat -anltu\n显示所有 TCP 连接：\n# netstat -antp\n显示所有 UDP 连接：\n# netstat -anup\n显示路由表：\n# netstat -r</code></pre>\n<h3>42、ss </h3>\n<p>功能：比 netstat 更强大的 socket 查看工具。</p>\n<p>格式：</p>\n<pre><code>ss [options] [ FILTER ]</code></pre>\n<p>常用选项：</p>\n<pre><code>-n 不解析名字\n-a 显示所有 socket\n-l 显示所有监听的 socket\n-o 显示计时器\n-e 显示 socket 详细信息\n-m 显示 socket 内存使用\n-p 显示进程使用的 socket\n-i 显示内部 TCP 信息\n-s 显示 socket 使用汇总\n-4 只显示 IPV4 的 socket\n-0 显示包 socket\n-t 只显示 TCP socket\n-u 只显示 UDP socket\n-d 只显示 DCCP socket\n-w 只显示 RAW socket\n-x 只显示 Unix 域 socket\n-f FAMILY 只显示 socket 族类型（ unix, inet, inet6, link, netlink） -A 查询 socket {all|inet|tcp|udp|raw|unix|packet|netlink}[,QUERY]\n-D 将原始的 TCP socket 转储到文件\n-F 从文件中读取过滤信息\n过滤：\n-o state 显示 TCP 连接状态信息</code></pre>\n<p>示例：</p>\n<pre><code>显示所有 TCP 连接：\n# ss -t -a\n显示所有 UDP 连接：\n# ss -u –a\n显示 socket 使用汇总：\n# ss -s\n显示所有建立的连接：\n# ss -o state established\n显示所有的 TIME-WAIT 状态：\n# ss -o state TIME-WAIT\n搜索所有本地进程连接到 X Server： \n# ss -x src /tmp/.X11-unix/</code></pre>\n<h3>43、lsof </h3>\n<p>功能：列出打开的文件。</p>\n<p>常用选项：</p>\n<pre><code>-i [i] 监听的网络地址，如果没有指定，默认列出所有。\n[i]来自[46][protocol][@hostname|hostaddr][:service|port]\n-U 列出 Unix 域 socket 文件\n-p 指定 PID\n-u 指定用户名或 UID 所有打开的文件\n+D 递归搜索</code></pre>\n<p>示例：</p>\n<pre><code>列出所有打开的文件：\n# lsof\n查看哪个进程占用文件：\n# lsof /etc/passwd\n列出所有打开的监听地址和 unix 域 socket 文件：\n# lsof -i -U\n列出 80 端口监听的进程：\n# lsof -i:80\n列出端口 1-1024 之间的所有进程：\n# lsof -i:1-1024\n列出所有 TCP 网络连接：\n# lsof -i tcp\n列出所有 UDP 网络连接：\n# lsof -i udp\n根据文件描述符列出打开的文件：\n# lsof -d 1\n列出某个目录被打开的文件：\n# lsof +D /var/log\n列出进程 ID 打开的文件：\n# lsof -p 5373\n打开所有登录用户名 abc 或 user id 1234，或 PID 123 或 PID 456： \n# lsof -p 123,456 -u 123,abc\n列出 COMMAND 列中包含字符串 sshd： \n# lsof -c sshd</code></pre>\n<h3>44、ps </h3>\n<p>功能：报告当前进程的快照。</p>\n<p>常用选项：</p>\n<pre><code>-a 显示所有进程\n-u 选择有效的用户 ID 或名称\n-x 显示无控制终端的进程\n-e 显示所有进程\n-f 全格式\n-r 只显示运行的进程\n-T 这个终端的所有进程\n-p 指定进程 ID\n--sort 对某列排序\n-m 线程\n-L 格式化代码列表\n-o 用户自定义格式\nCODE NORMAL HEADER\n%C pcpu %CPU\n%G group GROUP\n%P ppid PPID\n%U user USER\n%a args COMMAND\n%c comm COMMAND\n%g rgroup RGROUP\n%n nice NI\n%p pid PID\n%r pgid PGID\n%t etime ELAPSED\n%u ruser RUSER\n%x time TIME\n%y tty TTY\n%z vsz VSZ</code></pre>\n<p>示例：</p>\n<pre><code>打印系统上所有进程标准语法：\n# ps -ef\n打印系统上所有进程 BSD 语法：\n# ps aux\n打印进程树：\n# ps axjf 或 ps -ejH\n查看进程启动的线程：\n# ps -Lfp PID\n查看当前用户的进程数：\n# ps uxm 或 ps -U root -u root u\n自定义格式显示并对 CPU 排序：\n# ps -eo user,pid,pcpu,pmem,nice,lstart,time,args --sort=-pcpu\n或 \nps -eo \"%U %p %C %n %x %a\"</code></pre>\n<pre><code>USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND\nUSER 进程所有者\nPID 进程 ID\n%CPU 占用 CPU 时间\n%MEM 物理内存\nVSZ 虚拟内存大小（kb）\nRSS 驻留集内存页数量（kb）\nTTY 终端\nSTAT 进程状态；R 运行，S 休眠，D 不可中断，T 停止，Z 僵尸，N 表示普通优先级更低的优先级\nSTART 进程启动时间\nTIME 使用 CPU 总时间\nCOMMAND 命令名称和参数</code></pre>\n<h3>45、top </h3>\n<p>功能：动态显示活动的进程和系统资源利用率。</p>\n<p>常用选项：</p>\n<pre><code>-d 信息刷新时间间隔\n-p 只监控指定的进程 PID\n-i 只显示正在使用 CPU 的进程\n-H 显示线程\n-u 只查看指定用户名的进程\n-b 将输出编排成易处理格式，适合输出到文件处理\n-n 指定最大循环刷新数</code></pre>\n<p>交互命令：</p>\n<pre><code>f 添加或删除显示的指标\nc 显示完整命令\nP 按 CPU 使用百分比排序\nM 按驻留内存大小排序\nT 按进程使用 CPU 时间排序\n1 显示每个 CPU 核心使用率\nk 终止一个进程</code></pre>\n<p>示例：</p>\n<pre><code>刷新一次并输出到文件：\n# top -b -n 1 &gt; top.log\n只显示指定进程的线程：\n# top -Hp 123</code></pre>\n<p><img alt=\"\" height=\"183\" src=\"image\\82bc64b5820942c188fa4e775ba1d2aa.png\" width=\"1109\"/></p>\n<p>第一行：当前系统时间，系统运行了多长时间（9 天 22 小时 16 分钟），CPU 负载：1 分钟、5 分钟、15 分钟。</p>\n<p>第二行：系统总共 178 个进程，3 个 CPU 正在处理，175 在休眠等待处理，0 个停止，0 个僵尸进程。</p>\n<p>第三行：us 用户空间使用 CPU 时间 0.3%，sy 内核空间使用 CPU 时间 0.3%，ni 系统调整进程优先级。使用 CPU 时间 0.0%，id 空闲 CPU 时间 99.3%，wa 等待 I/O 响应 CPU 时间 0.0%，hi 硬中断，si 软中断。</p>\n<p>第四行和第五行：物理内存与交换分区使用率。</p>\n<p>第六行：<br/> PID 进程 ID<br/> USER 进程所有者<br/> PR 进程优先级<br/> NI 负值表示高优先级，正值表示低优先级<br/> VIRT 进程启动后使用虚拟内存总量（KB），VIRT=SWAP+RES<br/> RES 实际物理内存使用大小（KB），RES=CODE+DATA<br/> SHR 共享内存大小（KB）,可能与其他进程共享的内存；计算进程使用物理内存大小：RES-SHR<br/> S 进程状态；R 运行，S 休眠，D 不可中断，T 停止，Z 僵尸<br/> %CPU 上次更新到现在的 CPU 时间占用百分比<br/> %MEM 使用物理内存百分比<br/> TIME+ 使用 CPU 总时间<br/> COMMAND 命令名称和参数 </p>\n<h3>46、free</h3>\n<p>功能：查看内存使用率。</p>\n<p>常用选项：</p>\n<pre><code>-b bytes 显示\n-k KB 显示\n-m M 显示\n-g G 显示\n-h 易读单位显示\n-s 每几秒重复打印\n-c 重复打印几次退出</code></pre>\n<p>示例：</p>\n<pre><code>查看物理内存：\n# free -m\n易读单位显示：\n# free -h</code></pre>\n<h3>47、df </h3>\n<p>功能：查看文件系统的磁盘空间使用情况。</p>\n<p>常用选项：</p>\n<pre><code>-a 包含虚拟文件系统\n-h 可易读单位显示\n-i 显示 inode 信息而非块使用量\n-k 1K 块的数量\n-t 只显示指定文件系统为指定类型的信息\n-T 显示文件系统类型</code></pre>\n<p>示例：</p>\n<pre><code>查看所有文件系统：\n# df -ah\n输出指定文件系统：\n# df -t xfs</code></pre>\n<h3>48、vmstat </h3>\n<p>功能：报告虚拟内存、swap、io、上下文和 CPU 统计信息。</p>\n<p>分析了这些文件：</p>\n<pre><code>/proc/meminfo\n/proc/stat\n/proc/*/stat</code></pre>\n<p>常用选项：</p>\n<pre><code>-a 打印活跃和不活跃的内存页\n-d 打印硬盘统计信息\n-D 打印硬盘表\n-p 打印硬盘分区统计信息\n-s 打印虚拟内存表\n-m 打印内存分配（slab）信息\n-t 添加时间戳到输出\n-S 显示单位，默认 k、KB、m、M，大写是*1024</code></pre>\n<p>示例：</p>\n<pre><code>每秒刷新一次，统计五次：\n# vmstat -t 1 5</code></pre>\n<p><img alt=\"\" height=\"89\" src=\"image\\70b40ff75c7b4fb29291d52ac6e5b12b.png\" width=\"1056\"/></p>\n<p>r：CPU 正在运行的进程数<br/> b：在等待 I/O 的进程数<br/> swpd：已经使用的交换内存（kb）<br/> free：空闲的物理内存（kb）<br/> buff：已经使用的缓冲区内存（kb）；一般对设备数据缓存，写入到磁盘的数据。<br/> cache：已经使用的缓冲区内存（kb）；一般对文件数据缓存，从磁盘读取的数据。<br/> si：从磁盘交换到内存的交换页数量（kb/s）<br/> so：从内存交换到磁盘的交换页数据（kb/s）<br/> bi：块设备接收的块数量（kb/s）<br/> bo：块设备发送的块数量（kb/s）<br/> in：每秒 CPU 中断次数<br/> cs：每秒 CPU 上下文切换次数<br/> us：用户进程使用 CPU 时间（%）<br/> sy：系统进程使用 CPU 时间（%）<br/> id：CPU 空闲时间（%）<br/> wa：等待 I/O 响应所消耗的 CPU 时间（%）<br/> st：从虚拟设备中获得的时间（%）</p>\n<h3>49、iostat </h3>\n<p>功能：报告 CPU 利用率和磁盘 I/O。</p>\n<p>用法:</p>\n<pre><code>iostat [ 选项 ] [ &lt;时间间隔&gt; [ &lt;次数&gt; ] ]</code></pre>\n<p>常用选项：</p>\n<pre><code>-c 显示 CPU 使用率\n-d 只显示磁盘使用率\n-k 单位 KB/s 代替 Block/s\n-m 单位 MB/s 代替 Block/s\n-N 显示所有映射设备名字\n-t 打印报告时间\n-x 显示扩展统计信息</code></pre>\n<p>示例：</p>\n<pre><code>显示 CPU 使用率：\n# iostat -c 1 3\n显示 I/O 磁盘统计信息：\n# iostat -d -x -k 1 3 # 间隔 1 秒，输出 3 次</code></pre>\n<h3>50、sar </h3>\n<p>功能：查看系统资源综合方面利用率。</p>\n<p>常用选项：</p>\n<pre><code>-u, CPU\n-r, memory\n-b, disk\n-n DEV, NIC traffic\n-q, systemload\n-b, TPS（Transaction Per Second，每秒事务处理量）\n-o, output to file</code></pre>\n<p>示例：</p>\n<pre><code># sar -u 2 3 #每两秒执行一次，采集三次\n# sar -u 2 3 -o cpu.out\n# sar -f cpu.out #读取文件</code></pre>\n<h3>51、<span style=\"color:#000000;\"><strong>dstat </strong></span></h3>\n<div>\n<span style=\"color:#000000;\">功能：查看系统资源综合方面利用率（需要安装） 。</span>\n</div>\n<div></div>\n<div>\n 常用选项：\n</div>\n<div></div>\n<div>\n<pre><code>-c cpu 统计\n-d 磁盘统计\n-m 内存统计\n-n 网络统计\n-s swap 统计\n-l 负载统计\n--tcp tcp 状态统计\n--udp udp 状态统计\n--socket socket 数量统计\n-t 输出时间\n--output 写入 csv 文件</code></pre>\n<p><span style=\"color:#000000;\">插件：</span></p>\n<pre><code>--list\n支持的插件\n--top-bio-adv\n详细显示 I/O 进程写入 block 量，包括 pid、r、w 和 cpu\n--top-io-adv\n进程写入磁盘总量\n--top-cpu\n占用 CPU 进程\n--top-cpu-adv\n查看最高 CPU 进程\n--top-mem\n内存进程</code></pre>\n<p><span style=\"color:#000000;\">示例：</span></p>\n<pre><code>查看 CPU 利用率： \n# dstat -c\n查看 TCP 连接状态：\n# dstat --tcp</code></pre>\n<h3>52、ip </h3>\n<p>功能：查看/操作路由表、设备、路由策略和隧道。</p>\n<p>格式：</p>\n<pre><code>ip [ OPTIONS ] OBJECT { COMMAND | help }</code></pre>\n<p>常用选项：</p>\n<pre><code>-b, -batch &lt;FILENAME&gt; 从文件或标准输入读取命令并调用他们，第一次失败将终止\n-force 批量模式有错误不终止，如果有错误则状态返回非 0 -s, -statistics 输出更多的统计信息\n-l, -loops &lt;COUNT&gt; 指定最大的循环数</code></pre>\n<p>操作对象（OBEJECT）：</p>\n<pre><code>address 网络设备地址\n12tp 以太网 IP 隧道\nlink 配置网络设备\nmaddress 多播地址\nmonitor 动态监控网络连接\nmroute 多播路由缓存条目\nmrule 角色在多播路由策略数据库\nneighbour 管理 ARP 或 NDISC 缓存条目\nnetns 管理网络命名空间\nntable 管理 neighbour 缓存操作\nroute 路由表\nrule 角色在路由策略数据库\ntpc_metrics/tcpmetrics 管理 TCP 指标\ntunnel IP 隧道\ntuntap 管理 TUN/TAP 设备\nxfrm 管理 IPSec 策略\n可通过 ip OBEJECT help 再查看对象的操作方法。</code></pre>\n<p>示例：</p>\n<pre><code>查看网络设备地址：\n# ip addr\n查看网卡统计信息：\n# ip -s link\n查看单个网卡统计信息：\n# ip -s link ls eth0\n查看 ARP 缓存表：\n# ip neighbour\n查看路由表：\n# ip route\n查看路由策略：\n# ip rule\n网卡设置/删除 IP： \n# ip addr add/del 192.168.1.201/24 dev eth0\n添加/删除默认路由：\n# ip route add default via 192.168.1.1 dev eth0\n# ip route del 192.168.1.0/24 via 192.168.1.1\n添加静态路由：\n# ip route add 172.17.2.0/24 via 192.168.2.1 dev eth0\n开启/关闭网卡：\n# ip link set dev eth0 up/down\n设置最大传输单元：\n# ip link set dev eth0 mtu 1500\n设置 MAC 地址：\n# ip link set dev eth0 address 00:0c:29:52:73:8e</code></pre>\n<h3>53、nc</h3>\n<p>功能：TCP 和 UDP 连接和监听。</p>\n<p>常用选项：</p>\n<pre><code>-i interval 指定间隔时间发送和接受行文本\n-l 监听模式，管理传入的连接\n-n 不解析域名\n-p 指定本地源端口\n-s 指定本地源 IP 地址\n-u 使用 udp 协议，默认是 tcp\n-v 执行过程输出\n-w timeout 连接超时时间\n-x proxy_address[:port] 请求连接主机使用代理地址和端口\n-z 指定扫描监听端口，不发送任何数据</code></pre>\n<p>示例：</p>\n</div>\n<pre><code>端口扫描：\n# nc -z 192.168.1.10 1-65535\nTCP 协议连接到目标端口：\n# nc -p 31337 -w 5 192.168.1.10 22\nUDP 协议连接到目的端口：\n# nc -u 192.168.1.10 53\n指定本地 IP 连接：\n# nc -s 192.168.1.9 192.168.1.10 22\n探测端口是否开启：\n# nc -z -w 2 192.168.1.10 22\n创建监听 Unix 域 Socket： \n# nc -lU /var/tmp/ncsocket\n通过 HTTP 代理连接主机：\n# nc -x10.2.3.4:8080 -Xconnect 10.0.0.10 22\n监听端口捕获输出到文件：\n# nc -l 1234 &gt; filename.out\n从文件读入到指定端口：\n# nc host.example.com 1234 &lt; filename.in\n收发信息：\n# nc -l 1234\n# nc 127.0.0.1 1234\n执行 memcahced 命令：printf \"stats\\n\" |nc 127.0.0.1 11211\n发送邮件：\n# nc [-C] localhost 25 &lt;&lt; EOF\nHELO host.example.com\nMAIL FROM: &lt;user@host.example.com&gt;\nRCPT TO: &lt;user2@host.example.com&gt;\nDATA\nBody of email.\n.\nQUIT\nEOF\n# echo -n \"GET / HTTP/1.0\\r\\n\\r\\n\" | nc host.example.com 80</code></pre>\n<h3>54、time </h3>\n<p>功能：执行脚本时间。</p>\n<p>示例：</p>\n<pre><code>查看执行 ls 所需的时间：\n# time ls</code></pre>\n<h3>55、<span style=\"color:#000000;\"><strong>eval </strong></span></h3>\n<div>\n<span style=\"color:#000000;\">功能：执行参数作为 shell 命令。</span>\n</div>\n<div>\n<span style=\"color:#000000;\">示例： </span>\n</div>\n<pre><code>for i in $@; do\n eval $i\ndone\necho ---\necho $a\necho $b\n# bash test.sh a=1 b=2\n---\n12</code></pre>\n<h3>56、ssh </h3>\n<p>功能：SSH 客户端。</p>\n<p>常用选项：</p>\n<pre><code>-p 指定远程主机端口\n-i 指定认证文件\n-L [bind_address:]port:host:hostport\n-R [bind_address:]port:host:hostport]\n-D [bind_address:]port\n-o SSH 选项，有以下几个比较常用的：\nConnectionAttempts=NUM 连接失败后重试次数\nConnectTimeout=SEC 连接超时时间\nStrictHostKeyChecking=no 自动拉去主机 key 文件\nPasswordAuthentication=no 禁止密码认证</code></pre>\n<p>示例：</p>\n<pre><code>登录到远程主机： \n# ssh user@192.168.1.120\n远程主机执行命令： \n# ssh user@192.168.1.120 'ifconfig'\n本地文件内容写到远程主机文件： \n# ssh user@192.168.1.120 'cat &gt;&gt; file' &lt; /etc/passwd</code></pre>\n<p>SSH 还提供了一个非常有用的功能，就是端口转发，能帮你解决一些无法建立的连接。</p>\n<p>1）本地端口转发</p>\n<p>应用场景 1：A 不能访问 C，B 能访问 A 和 C，实现通过 B 能让 A 访问 C，在主机 A 执行：</p>\n<pre><code># ssh -L 2222:主机 C:22 主机 B \n# ssh -L [绑定地址:]本地端口:主机 C:C 端口 主机 B </code></pre>\n<p>将 SSH 绑定本地端口 2222，本地 2222 端口数据转发主机 B，主机 B 的所有数据转发到主机 C 的 22 端口；这样一来，只要在主机 A ssh -p 2222 localhost，就等于连上了主机 C 的 22 端口。</p>\n<p>应用场景 2：一台 Squid 代理服务器，限制了本机可以清理缓存，但是我想从远程服务器清理<br/> 在远程服务器执行：</p>\n<pre><code># ssh -L 31280:localhost:3128 SquidHost</code></pre>\n<p>在远程服务器上执行清理命令到本机 31280 端口，31280 收到的数据加密转发到 SquidHost 的 SSH Server 上，SSH Client 解密收到的数据并转发到监听的 3128 端口上，最后将 Squid 返回的数据原路返回。</p>\n<p>2）远程端口转发</p>\n<p>应用场景 1：A 不能访问 C，B 能访问 A 和 C，但 A 不能访问 B，比如 A 在外网，B 在内网<br/> 在主机 B 执行：</p>\n<pre><code># ssh -R 2222:主机 C:22 主机 A</code></pre>\n<p>将 SSH 绑定本机 2222 端口，与主机 A 建立 SSH 通道，当主机 A 访问本地 2222 端口，就等于访问主机B 的 2222 端口，主机 B 的 2222 端口把数据转发到主机 C 的 22 端口。</p>\n<p>应用常见 2：公司有一台内网服务器，还有一台云主机不能 SSH 直接连接这台公司内网服务器，但内网服务器可以 SSH 连接云主机，在公司内网服务器执行：</p>\n<pre><code># ssh -R 2222:localhost:22 云主机</code></pre>\n<p>将云主机上的 2222 端口数据转发到内网服务器 SSH Client 上，SSH Client 解密收到的数据并转发到监听的 22 端口上，最后再将返回的数据原路返回。</p>\n<p>3）动态端口转发（不限定端口，全权代理）</p>\n<p>应用场景：翻墙访问国外网站</p>\n<p>如果是 MAC 系统直接在终端执行：</p>\n<pre><code>ssh -D 2222 国外云主机</code></pre>\n<p>如果是 Windows 系统可借助 putty 工具实现，在 putty 里面端口转发-&gt;本地端口转发属性里面添加<br/> 一个本地端口，并勾选 SOCKS4/5 动态转发，连接即可。</p>\n<p>将 SSH 绑定本机 8080 端口，SSH 就会创建一个 SOCKS 代理服务，直接在浏览器上设置代理本机127.0.0.1 的 8080 端口即可，当浏览器访问国外网站时，本地代理把请求转发到国外云主机的 SSH Server，SSH 解密并转发给指定的网站。</p>\n<p>注意：再 Linux 终端执行 ssh 绑定命令后，默认会进入一个新的 shell，只要这个 shell 不退出，此<br/> 端口转发就一直有效。如果要想放到后台执行就加-Nf 两个选项，-N 是不执行命令，-f 后台执行，<br/> 这样就转入后台运行，就可以在本地 shell 执行操作了，如果想关闭后台就 kill 这个进程。</p>\n<p>详情，请参考：<a href=\"https://developer.ibm.com/\" title=\"IBM Developer\">IBM Developer</a></p>\n<h3>57、iptables </h3>\n<p>常见几种类型防火墙？</p>\n<p>包过滤防火墙：包过滤是 IP 层实现，包过滤根据数据包的源 IP、目的 IP、协议类型<br/> （TCP/UDP/ICMP）、源端口、目的端口等包头信息及数据包传输方向灯信息来判断是否允许数据包通过。</p>\n<p>应用层防火墙：也称为应用层代理防火墙，基于应用层协议的信息流检测，可以拦截某应用程序的<br/> 所有封包，提取包内容进行分析。有效防止 SQL 注入或者 XSS（跨站脚本攻击）之类的恶意代码。</p>\n<p>状态检测防火墙：结合包过滤和应用层防火墙优点，基于连接状态检测机制，将属于同一连接的所<br/> 有包作为一个整体的数据流看待，构成连接状态表（通信信息，应用程序信息等），通过规则表与<br/> 状态表共同配合，对表中的各个连接状态判断。</p>\n<p>iptables 是 Linux 下的配置防火墙的工具，用于配置 Linux 内核集成的 IP 信息包过滤系统，使增<br/> 删改查信息包过滤表中的规则更加简单。</p>\n<p>iptables 分为四表五链，表是链的容器，链是规则的容器，规则指定动作。</p>\n<p>四表：</p>\n<p><img alt=\"\" height=\"72\" src=\"image\\c1504a87f11d432e950ad162866a444b.png\" width=\"1043\"/></p>\n<p><img alt=\"\" height=\"195\" src=\"image\\bba823cc2ea144d193a07620b6cb6236.png\" width=\"1041\"/></p>\n<p>五链：</p>\n<p><img alt=\"\" height=\"321\" src=\"image\\23ee1deb3f754c3198cc0f011a16da65.png\" width=\"1042\"/></p>\n<p>表中的链： </p>\n<p><img alt=\"\" height=\"323\" src=\"image\\ca67c2a9563c4a26a7b75d93eefa4517.png\" width=\"1043\"/></p>\n<p>命令格式：</p>\n<pre><code>iptables [-t table] 命令 [chain] 匹配条件 动作 </code></pre>\n<p><img alt=\"\" height=\"513\" src=\"image\\deae73c34da24637b325a5d398be2c06.png\" width=\"1043\"/></p>\n<p><img alt=\"\" height=\"77\" src=\"image\\b7184c0c16244ec6b1c54a3c44fdc171.png\" width=\"1045\"/></p>\n<p><img alt=\"\" height=\"449\" src=\"image\\1434d700633d4fbc8dfcb83609a0f4da.png\" width=\"1044\"/></p>\n<p><img alt=\"\" height=\"451\" src=\"image\\a02dfaa204ba4443aabe313a6dfe3bd7.png\" width=\"1054\"/></p>\n<p><img alt=\"\" height=\"383\" src=\"image\\d216bd9388ae49afb7faf98119838abf.png\" width=\"1053\"/></p>\n<p> 示例：常用的规则配置方法</p>\n<p></p>\n<pre><code>iptables -F # 清空表规则，默认 filter 表\niptables -t nat -F # 清空 nat 表\niptables -A INPUT -p tcp --dport 22 -j ACCEPT # 允许 TCP 的 22 端口访问\niptables -I INPUT -p udp --dport 53 -j ACCEPT # 允许 UDP 的 53 端口访问，插入在第一条\niptables -A INPUT -p tcp --dport 22:25 -j ACCEPT # 允许端口范围访问\niptables -D INPUT -p tcp --dport 22:25 -j ACCEPT # 删除这条规则\n# 允许多个 TCP 端口访问\niptables -A INPUT -p tcp -m multiport --dports 22,80,8080 -j ACCEPT\niptables -A INPUT -s 192.168.1.0/24 -j ACCEPT # 允许 192.168.1.0 段 IP 访问\niptables -A INPUT -s 192.168.1.10 -j DROP # 对 1.10 数据包丢弃\niptables -A INPUT -i eth0 -p icmp -j DROP # eth0 网卡 ICMP 数据包丢弃，也就是禁 ping\n# 允许来自 lo 接口，如果没有这条规则，将不能通过 127.0.0.1 访问本地服务\niptables -A INPUT -i lo -j ACCEPT\n# 限制并发连接数，超过 30 个拒绝\niptables -I INPUT -p tcp --syn --dport 80 -m connlimit --connlimit-above 30 -j\nREJECT\n# 限制每个 IP 每秒并发连接数最大 3 个\niptables -I INPUT -p tcp --syn -m limit --limit 1/s --limit-burst 3 -j\nACCEPT\niptables -A FORWARD -p tcp --syn -m limit --limit 1/s -j ACCEPT\n# iptables 服务器作为网关时，内网访问公网\niptables –t nat -A POSTROUTING -s [内网 IP 或网段] -j SNAT --to [公网 IP]\n# 访问 iptables 公网 IP 端口，转发到内网服务器端口\niptables –t nat -A PREROUTING -d [对外 IP] -p tcp --dport [对外端口] -j DNAT --to [内 网 IP:内网端口] # 本地 80 端口转发到本地 8080 端口\niptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-ports 8080\n# 允许已建立及该链接相关联的数据包通过\niptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT\n# ASDL 拨号上网\niptables -t nat -A POSTROUTING -s 192.168.1.0/24 -o pppo -j MASQUERADE\n# 设置 INPUT 链缺省操作丢弃所有数据包，只要不符合规则的数据包都丢弃。注意要在最后设置，\n以免把自己关在外面！\niptables -P INPUT DROP</code></pre>\n<h2>十二、Shell脚本编写实战</h2>\n<h3>注意事项： </h3>\n<p>1）开头加解释器：#!/bin/bash<br/> 2）语法缩进，使用四个空格；多加注释说明。<br/> 3）命名建议规则：变量名大写、局部变量小写，函数名小写，名字体现出实际作用。<br/> 4）默认变量是全局的，在函数中变量 local 指定为局部变量，避免污染其他作用域。<br/> 5）有两个命令能帮助我调试脚本：set -e 遇到执行非 0 时退出脚本，set -x 打印执行过程。<br/> 6）写脚本一定先测试再到生产上。</p>\n<h3>1、获取随机字符串或数字 </h3>\n<p>获取随机 8 位字符串：</p>\n<pre><code>方法 1：\n# echo $RANDOM |md5sum |cut -c 1-8\n471b94f2\n方法 2： # openssl rand -base64 4\nvg3BEg==\n方法 3： # cat /proc/sys/kernel/random/uuid |cut -c 1-8\ned9e032c</code></pre>\n<div>\n<span style=\"color:#000000;\">获取随机 8 位数字：</span>\n</div>\n<pre><code>方法 1： # echo $RANDOM |cksum |cut -c 1-8\n23648321\n方法 2： # openssl rand -base64 4 |cksum |cut -c 1-8\n38571131\n方法 3： # date +%N |cut -c 1-8\n69024815</code></pre>\n<div>\n<span style=\"color:#000000;\">cksum：打印 CRC 效验和统计字节。</span>\n</div>\n<div></div>\n<h3>2、定义一个颜色输出字符串函数</h3>\n<pre><code>方法 1：\nfunction echo_color() {\n if [ $1 == \"green\" ]; then\n echo -e \"\\033[32;40m$2\\033[0m\"\n elif [ $1 == \"red\" ]; then\n echo -e \"\\033[31;40m$2\\033[0m\"\n fi\n}\n方法 2：\nfunction echo_color() {\n case $1 in\n green)\n echo -e \"\\033[32;40m$2\\033[0m\"\n ;;\n red)\n echo -e \"\\033[31;40m$2\\033[0m\"\n ;;\n *)\n echo \"Example: echo_color red string\"\n esac\n}\n\n使用方法：echo_color green \"test\"</code></pre>\n<div>\n<span style=\"color:#000000;\">function 关键字定义一个函数，可加或不加。</span>\n</div>\n<div></div>\n<h3>3、<span style=\"color:#000000;\"><strong>批量创建用户 </strong></span></h3>\n<pre><code>#!/bin/bash\nDATE=$(date +%F_%T)\nUSER_FILE=user.txt\necho_color(){\nif [ $1 == \"green\" ]; then\necho -e \"\\033[32;40m$2\\033[0m\"\nelif [ $1 == \"red\" ]; then\necho -e \"\\033[31;40m$2\\033[0m\"\nfi\n}# 如果用户文件存在并且大小大于 0 就备份\nif [ -s $USER_FILE ]; then\nmv $USER_FILE ${USER_FILE}-${DATE}.bak\necho_color green \"$USER_FILE exist, rename ${USER_FILE}-${DATE}.bak\"\nfi\necho -e \"User\\tPassword\" &gt;&gt; $USER_FILE\necho \"----------------\" &gt;&gt; $USER_FILE\nfor USER in user{1..10}; do\nif ! id $USER &amp;&gt;/dev/null; then\nPASS=$(echo $RANDOM |md5sum |cut -c 1-8)\nuseradd $USER\necho $PASS |passwd --stdin $USER &amp;&gt;/dev/null\necho -e \"$USER\\t$PASS\" &gt;&gt; $USER_FILE\necho \"$USER User create successful.\"\nelse\necho_color red \"$USER User already exists!\"\nfi\ndone</code></pre>\n<h3>4、检查软件包是否安装</h3>\n<pre><code>#!/bin/bash\nif rpm -q sysstat &amp;&gt;/dev/null; then\necho \"sysstat is already installed.\"\nelse\necho \"sysstat is not installed!\"\nfi</code></pre>\n<h3>5、检查服务状态</h3>\n<pre><code>#!/bin/bash\nPORT_C=$(ss -anu |grep -c 123)\nPS_C=$(ps -ef |grep ntpd |grep -vc grep)\nif [ $PORT_C -eq 0 -o $PS_C -eq 0 ]; then\necho \"内容\" | mail -s \"主题\" dst@example.com\nfi</code></pre>\n<h3>6、检查主机存活状态 </h3>\n<p>方法 1：将错误 IP 放到数组里面判断是否 ping 失败三次。</p>\n<pre><code>#!/bin/bash \nIP_LIST=\"192.168.18.1 192.168.1.1 192.168.18.2\"\nfor IP in $IP_LIST; do\n NUM=1\n while [ $NUM -le 3 ]; do\n if ping -c 1 $IP &gt; /dev/null; then\n echo \"$IP Ping is successful.\"\n break\n else\n # echo \"$IP Ping is failure $NUM\"\n FAIL_COUNT[$NUM]=$IP\n let NUM++\n fi\n done\n if [ ${#FAIL_COUNT[*]} -eq 3 ];then\n echo \"${FAIL_COUNT[1]} Ping is failure!\"\n unset FAIL_COUNT[*]\n fi\ndone</code></pre>\n<p>方法 2：将错误次数放到 FAIL_COUNT 变量里面判断是否 ping 失败三次。</p>\n<pre><code>#!/bin/bash\nIP_LIST=\"192.168.18.1 192.168.1.1 192.168.18.2\"\nfor IP in $IP_LIST; do\nFAIL_COUNT=0\nfor ((i=1;i&lt;=3;i++)); do\nif ping -c 1 $IP &gt;/dev/null; then\necho \"$IP Ping is successful.\"\nbreak\nelse\n# echo \"$IP Ping is failure $i\"\nlet FAIL_COUNT++\nfi\ndone\nif [ $FAIL_COUNT -eq 3 ]; then\necho \"$IP Ping is failure!\"\nfi\ndone</code></pre>\n<p>方法 3：利用 for 循环将 ping 通就跳出循环继续，如果不跳出就会走到打印 ping 失败。</p>\n<pre><code>#!/bin/bash\nping_success_status() {\nif ping -c 1 $IP &gt;/dev/null; then\necho \"$IP Ping is successful.\"\ncontinue\nfi\n}\nIP_LIST=\"192.168.18.1 192.168.1.1 192.168.18.2\"\nfor IP in $IP_LIST; do\nping_success_status\nping_success_status\nping_success_status\necho \"$IP Ping is failure!\"\ndone</code></pre>\n<h3>7、 监控 CPU、内存和硬盘利用率</h3>\n<p>1）CPU</p>\n<p>借助 vmstat 工具来分析 CPU 统计信息。</p>\n<pre><code>#!/bin/bash\nDATE=$(date +%F\" \"%H:%M)\nIP=$(ifconfig eth0 |awk -F '[ :]+' '/inet addr/{print $4}') # 只支持 CentOS6\nMAIL=\"example@mail.com\"\nif ! which vmstat &amp;&gt;/dev/null; then\n echo \"vmstat command no found, Please install procps package.\"\n exit 1\nfi\nUS=$(vmstat |awk 'NR==3{print $13}')\nSY=$(vmstat |awk 'NR==3{print $14}')\nIDLE=$(vmstat |awk 'NR==3{print $15}')\nWAIT=$(vmstat |awk 'NR==3{print $16}')\nUSE=$(($US+$SY))\nif [ $USE -ge 50 ]; then\n echo \"\n Date: $DATE\n Host: $IP\n Problem: CPU utilization $USE\n \" | mail -s \"CPU Monitor\" $MAIL\nfi</code></pre>\n<div>\n<span style=\"color:#000000;\">2）内存</span>\n</div>\n<div></div>\n<pre><code>#!/bin/bash\nDATE=$(date +%F\" \"%H:%M)\nIP=$(ifconfig eth0 |awk -F '[ :]+' '/inet addr/{print $4}') \nMAIL=\"example@mail.com\"\nTOTAL=$(free -m |awk '/Mem/{print $2}')\nUSE=$(free -m |awk '/Mem/{print $3-$6-$7}')\nFREE=$(($TOTAL-$USE))\n# 内存小于 1G 发送报警邮件\nif [ $FREE -lt 1024 ]; then\n echo \"\n Date: $DATE\n Host: $IP\n Problem: Total=$TOTAL,Use=$USE,Free=$FREE\n \" | mail -s \"Memory Monitor\" $MAIL\nfi</code></pre>\n<p>3）硬盘</p>\n<pre><code>#!/bin/bash\nDATE=$(date +%F\" \"%H:%M)\nIP=$(ifconfig eth0 |awk -F '[ :]+' '/inet addr/{print $4}') \nMAIL=\"example@mail.com\"\nTOTAL=$(fdisk -l |awk -F'[: ]+' 'BEGIN{OFS=\"=\"}/^Disk \\/dev/{printf \"%s=%sG,\",$2,$3}')\nPART_USE=$(df -h |awk 'BEGIN{OFS=\"=\"}/^\\/dev/{print $1,int($5),$6}')\nfor i in $PART_USE; do\n PART=$(echo $i |cut -d\"=\" -f1)\n USE=$(echo $i |cut -d\"=\" -f2)\n MOUNT=$(echo $i |cut -d\"=\" -f3)\n if [ $USE -gt 80 ]; then\n echo \"\n Date: $DATE\n Host: $IP\n Total: $TOTAL\n Problem: $PART=$USE($MOUNT)\n \" | mail -s \"Disk Monitor\" $MAIL\n fi\ndone</code></pre>\n<h3>8、批量主机磁盘利用率监控 </h3>\n<p>前提监控端和被监控端 SSH 免交互登录或者密钥登录。</p>\n<p>写一个配置文件保存被监控主机 SSH 连接信息，文件内容格式：IP User Port</p>\n<pre><code>#!/bin/bash\nHOST_INFO=host.info\nfor IP in $(awk '/^[^#]/{print $1}' $HOST_INFO); do\n USER=$(awk -v ip=$IP 'ip==$1{print $2}' $HOST_INFO)\n PORT=$(awk -v ip=$IP 'ip==$1{print $3}' $HOST_INFO)\n TMP_FILE=/tmp/disk.tmp\n ssh -p $PORT $USER@$IP 'df -h' &gt; $TMP_FILE\n USE_RATE_LIST=$( awk 'BEGIN{OFS=\"=\"}/^\\/dev/{print $1,int($5)}' $TMP_FILE)\n for USE_RATE in $USE_RATE_LIST; do\n PART_NAME=${USE_RATE%=*}\n USE_RATE=${USE_RATE#*=}\n if [ $USE_RATE -ge 80 ]; then\n echo \"Warning: $PART_NAME Partition usage $USE_RATE%!\"\n fi\n done\ndone</code></pre>\n<h3>9、检查网站可用性</h3>\n<p>1）检查 URL 可用性</p>\n<pre><code>方法 1：\ncheck_url() {\n HTTP_CODE=$(curl -o /dev/null --connect-timeout 3 -s -w \"%{http_code}\" $1)\n if [ $HTTP_CODE -ne 200 ]; then\n echo \"Warning: $1 Access failure!\"\n fi\n}\n方法 2：\ncheck_url() {\nif ! wget -T 10 --tries=1 --spider $1 &gt;/dev/null 2&gt;&amp;1; then \n#-T 超时时间，--tries 尝试 1 次，--spider 爬虫模式\n echo \"Warning: $1 Access failure!\"\n fi\n}\n使用方法：check_url www.baidu.com</code></pre>\n<p>2）判断三次 URL 可用性</p>\n<p>思路与上面检查主机存活状态一样。</p>\n<pre><code>方法 1：利用循环技巧，如果成功就跳出当前循环，否则执行到最后一行\n#!/bin/bash \ncheck_url() {\n HTTP_CODE=$(curl -o /dev/null --connect-timeout 3 -s -w \"%{http_code}\" $1)\n if [ $HTTP_CODE -eq 200 ]; then\n continue\n fi\n}\nURL_LIST=\"www.baidu.com www.agasgf.com\"\nfor URL in $URL_LIST; do\n check_url $URL\n check_url $URL\n check_url $URL\n echo \"Warning: $URL Access failure!\"\ndone\n方法 2：错误次数保存到变量\n#!/bin/bash \nURL_LIST=\"www.baidu.com www.agasgf.com\"\nfor URL in $URL_LIST; do\n FAIL_COUNT=0\n for ((i=1;i&lt;=3;i++)); do\n HTTP_CODE=$(curl -o /dev/null --connect-timeout 3 -s -w \"%{http_code}\" $URL)\n if [ $HTTP_CODE -ne 200 ]; then\n let FAIL_COUNT++\n else\n break\n fi\n done\n if [ $FAIL_COUNT -eq 3 ]; then\n echo \"Warning: $URL Access failure!\"\n fi\ndone\n方法 3：错误次数保存到数组\n#!/bin/bash \nURL_LIST=\"www.baidu.com www.agasgf.com\"\nfor URL in $URL_LIST; do\n NUM=1\n while [ $NUM -le 3 ]; do\n HTTP_CODE=$(curl -o /dev/null --connect-timeout 3 -s -w \"%{http_code}\" $URL)\n if [ $HTTP_CODE -ne 200 ]; then\n FAIL_COUNT[$NUM]=$IP #创建数组，以$NUM 下标，$IP 元素\n let NUM++\n else\n break\n fi\n done\n if [ ${#FAIL_COUNT[*]} -eq 3 ]; then\n echo \"Warning: $URL Access failure!\"\n unset FAIL_COUNT[*] #清空数组\n fi\ndone</code></pre>\n<h3>10、检查 MySQL 主从同步状态</h3>\n<pre><code>#!/bin/bash \nUSER=bak\nPASSWD=123456\nIO_SQL_STATUS=$(mysql -u$USER -p$PASSWD -e 'show slave status\\G' |awk -F:\n'/Slave_.*_Running/{gsub(\": \",\":\");print $0}') #gsub 去除冒号后面的空格\nfor i in $IO_SQL_STATUS; do\nTHREAD_STATUS_NAME=${i%:*}\nTHREAD_STATUS=${i#*:}\nif [ \"$THREAD_STATUS\" != \"Yes\" ]; then\necho \"Error: MySQL Master-Slave $THREAD_STATUS_NAME status is\n$THREAD_STATUS!\"\nfi\ndone</code></pre>\n<h3>11、屏蔽网站访问频繁的 IP</h3>\n<p>1）屏蔽每分钟访问超过 200 的 IP</p>\n<pre><code>方法 1：以 Nginx 日志作为测试\nDATE=$(date +%d/%b/%Y:%H:%M)\nABNORMAL_IP=$(tail -n5000 access.log |grep $DATE |awk '{a[$1]++}END{for(i in\na)if(a[i]&gt;100)print i}')\n#先 tail 防止文件过大，读取慢，数字可调整每分钟最大的访问量。awk 不能直接过滤日志，因为\n包含特殊字符。\nfor IP in $ABNORMAL_IP; do\n if [ $(iptables -vnL |grep -c \"$IP\") -eq 0 ]; then\n iptables -I INPUT -s $IP -j DROP\n fi\ndone\n方法 2：通过建立连接数\nABNORMAL_IP=$(netstat -an |awk '$4~/:80$/ &amp;&amp; $6~/ESTABLISHED/{gsub(/:[0-\n9]+/,\"\",$5);{a[$5]++}}END{for(i in a)if(a[i]&gt;100)print i}')\n#gsub 是将第五列（客户端 IP）的冒号和端口去掉\nfor IP in $ABNORMAL_IP; do\n if [ $(iptables -vnL |grep -c \"$IP\") -eq 0 ]; then\n iptables -I INPUT -s $IP -j DROP\n fi\ndone</code></pre>\n<p>2）屏蔽每分钟 SSH 暴力破解超过 10 次的 IP</p>\n<pre><code>方法 1：通过 lastb 获取登录状态:\nDATE=$(date +\"%a %b %e %H:%M\") #星期月天时分 %e 单数字时显示 7，而%d 显示 07\nABNORMAL_IP=$(lastb |grep \"$DATE\" |awk '{a[$3]++}END{for(i in a)if(a[i]&gt;10)print i}')\nfor IP in $ABNORMAL_IP; do\n if [ $(iptables -vnL |grep -c \"$IP\") -eq 0 ]; then\n iptables -I INPUT -s $IP -j DROP\n fi\ndone\n方法 2：通过日志获取登录状态\nDATE=$(date +\"%b %d %H\")\nABNORMAL_IP=\"$(tail -n10000 /var/log/auth.log |grep \"$DATE\" |awk '/Failed/{a[$(NF-\n3)]++}END{for(i in a)if(a[i]&gt;5)print i}')\"\nfor IP in $ABNORMAL_IP; do\n if [ $(iptables -vnL |grep -c \"$IP\") -eq 0 ]; then\n iptables -A INPUT -s $IP -j DROP\n echo \"$(date +\"%F %T\") - iptables -A INPUT -s $IP -j DROP\" &gt;&gt;~/ssh-loginlimit.log\n fi\ndone</code></pre>\n<h3>12、判断输入是否为 IP</h3>\n<pre><code>方法 1:\nfunction check_ip(){\n IP=$1\n VALID_CHECK=$(echo $IP|awk -F. '$1&lt;=255&amp;&amp;$2&lt;=255&amp;&amp;$3&lt;=255&amp;&amp;$4&lt;=255{print \"yes\"}')\n if echo $IP|grep -E \"^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}$\"&gt;/dev/null;\nthen\n if [ $VALID_CHECK == \"yes\" ]; then\n echo \"$IP available.\"\n else\n echo \"$IP not available!\"\n fi\n else\n echo \"Format error!\"\n fi\n}\ncheck_ip 192.168.1.1\ncheck_ip 256.1.1.1\n方法 2：\nfunction check_ip(){\n IP=$1\n if [[ $IP =~ ^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}$ ]]; then\n FIELD1=$(echo $IP|cut -d. -f1)\n FIELD2=$(echo $IP|cut -d. -f2)\n FIELD3=$(echo $IP|cut -d. -f3)\n FIELD4=$(echo $IP|cut -d. -f4)\n if [ $FIELD1 -le 255 -a $FIELD2 -le 255 -a $FIELD3 -le 255 -a $FIELD4 -le\n255 ]; then\n echo \"$IP available.\"\n else\n echo \"$IP not available!\"\n fi\n else\n echo \"Format error!\"\n fi\n}\ncheck_ip 192.168.1.1\ncheck_ip 256.1.1.1\n增加版：加个死循环，如果 IP 可用就退出，不可用提示继续输入，并使用 awk 判断\nfunction check_ip(){\n local IP=$1\n VALID_CHECK=$(echo $IP|awk -F. '$1&lt;=255&amp;&amp;$2&lt;=255&amp;&amp;$3&lt;=255&amp;&amp;$4&lt;=255{print \"yes\"}')\n if echo $IP|grep -E \"^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}$\" &gt;/dev/null;\nthen\n if [ $VALID_CHECK == \"yes\" ]; then\n return 0\n else\n echo \"$IP not available!\"\n return 1\n fi\n else\n echo \"Format error! Please input again.\"\n return 1\n fi }\nwhile true; do\n read -p \"Please enter IP: \" IP\n check_ip $IP\n [ $? -eq 0 ] &amp;&amp; break || continue\ndone</code></pre>\n<h3>13、判断输入是否为数字</h3>\n<pre><code>方法 1：\nif [[ $1 =~ ^[0-9]+$ ]]; then\n echo \"Is Number.\"\nelse\n echo \"No Number.\"\nfi\n方法 2：\nif [ $1 -gt 0 ] 2&gt;/dev/null; then\n echo \"Is Number.\"\nelse\n echo \"No Number.\"\nfi\n方法 3：\necho $1 |awk '{print $0~/^[0-9]+$/?\"Is Number.\":\"No Number.\"}' #三目运算符</code></pre>\n<h3>14、找出包含关键字的文件</h3>\n<pre><code>DIR=$1\nKEY=$2\nfor FILE in $(find $DIR -type f); do\n if grep $KEY $FILE &amp;&gt;/dev/null; then\n echo \"--&gt; $FILE\"\n fi\ndone</code></pre>\n<h3>15、监控目录，将新创建的文件名追加到日志中 </h3>\n<p>需安装 inotify-tools 软件包。</p>\n<pre><code>#!/bin/bash\nMON_DIR=/opt\ninotifywait -mq --format %f -e create $MON_DIR |\\\nwhile read files; do\n echo $files &gt;&gt; test.log\ndone</code></pre>\n<h3>16、多个网卡选择</h3>\n<pre><code>function local_nic() {\nlocal NUM ARRAY_LENGTH\nNUM=0\nfor NIC_NAME in $(ls /sys/class/net|grep -vE \"lo|docker0\"); do\nNIC_IP=$(ifconfig $NIC_NAME |awk -F'[: ]+' '/inet addr/{print $4}')\nif [ -n \"$NIC_IP\" ]; then\nNIC_IP_ARRAY[$NUM]=\"$NIC_NAME:$NIC_IP\" #将网卡名和对应 IP 放到数\n组\nlet NUM++\nfi\ndone\nARRAY_LENGTH=${#NIC_IP_ARRAY[*]}\nif [ $ARRAY_LENGTH -eq 1 ]; then #如果数组里面只有一条记录说明就一个网卡\nNIC=${NIC_IP_ARRAY[0]%:*}\nreturn 0\nelif [ $ARRAY_LENGTH -eq 0 ]; then #如果没有记录说明没有网卡\necho \"No available network card!\"\nexit 1\nelse\n#如果有多条记录则提醒输入选择\nfor NIC in ${NIC_IP_ARRAY[*]}; do\necho $NIC\ndone\nwhile true; do\nread -p \"Please enter local use to network card name: \"\nINPUT_NIC_NAME\nCOUNT=0\nfor NIC in ${NIC_IP_ARRAY[*]}; do\nNIC_NAME=${NIC%:*}\nif [ $NIC_NAME == \"$INPUT_NIC_NAME\" ]; then\nNIC=${NIC_IP_ARRAY[$COUNT]%:*}\nreturn 0\nelse\nCOUNT+=1\nfi\ndone\necho \"Not match! Please input again.\"\ndone\nfi\n}\nlocal_nic</code></pre>\n<p>如果有只有一个网卡就不选择。</p>\n<h3>17、查看网卡实时流量</h3>\n<pre><code>#!/bin/bash\n# Description: Only CentOS6\ntraffic_unit_conv() {\n local traffic=$1\n if [ $traffic -gt 1024000 ]; then\n printf \"%.1f%s\" \"$(($traffic/1024/1024))\" \"MB/s\"\n elif [ $traffic -lt 1024000 ]; then\n printf \"%.1f%s\" \"$(($traffic/1024))\" \"KB/s\"\n fi\n}\nNIC=$1\necho -e \" In ------ Out\"\nwhile true; do\n OLD_IN=$(awk -F'[: ]+' '$0~\"'$NIC'\"{print $3}' /proc/net/dev)\n OLD_OUT=$(awk -F'[: ]+' '$0~\"'$NIC'\"{print $11}' /proc/net/dev)\n sleep 1\n NEW_IN=$(awk -F'[: ]+' '$0~\"'$NIC'\"{print $3}' /proc/net/dev)\n NEW_OUT=$(awk -F'[: ]+' '$0~\"'$NIC'\"{print $11}' /proc/net/dev)\n IN=$(($NEW_IN-$OLD_IN))\n OUT=$(($NEW_OUT-$OLD_OUT))\n echo \"$(traffic_unit_conv $IN) $(traffic_unit_conv $OUT)\"\n sleep 1\ndone\n# 也可以通过 ficonfig 命令获取收发流量\nwhile true; do\n OLD_IN=$(ifconfig $NIC |awk -F'[: ]+' '/bytes/{print $4}') \n OLD_OUT=$(ifconfig $NIC |awk -F'[: ]+' '/bytes/{print $9}')\n sleep 1\n NEW_IN=$(ifconfig $NIC |awk -F'[: ]+' '/bytes/{print $4}')\n NEW_OUT=$(ifconfig $NIC |awk -F'[: ]+' '/bytes/{print $9}')\n IN=$(($NEW_IN-$OLD_IN))\n OUT=$(($NEW_OUT-$OLD_OUT))\n echo \"$(traffic_unit_conv $IN) $(traffic_unit_conv $OUT)\"\n sleep 1\ndone</code></pre>\n<h3>18、MySQL 数据库备份</h3>\n<pre><code>#!/bin/bash\nDATE=$(date +%F_%H-%M-%S)\nHOST=192.168.1.120\nDB=test\nUSER=bak\nPASS=123456\nMAIL=\"zhangsan@example.com lisi@example.com\"\nBACKUP_DIR=/data/db_backup\nSQL_FILE=${DB}_full_$DATE.sql\nBAK_FILE=${DB}_full_$DATE.zip\ncd $BACKUP_DIR\nif mysqldump -h$HOST -u$USER -p$PASS --single-transaction --routines --triggers -B\n$DB &gt; $SQL_FILE; then\n zip $BAK_FILE $SQL_FILE &amp;&amp; rm -f $SQL_FILE\n if [ ! -s $BAK_FILE ]; then\n echo \"$DATE 内容\" | mail -s \"主题\" $MAIL\n fi\nelse\n echo \"$DATE 内容\" | mail -s \"主题\" $MAIL\nfi\nfind $BACKUP_DIR -name '*.zip' -ctime +14 -exec rm {} \\;</code></pre>\n<h3>19、Nginx 启动脚本</h3>\n<pre><code>#!/bin/bash\n# Description: Only support RedHat system\n. /etc/init.d/functions\nWORD_DIR=/data/project/nginx1.10\nDAEMON=$WORD_DIR/sbin/nginx\nCONF=$WORD_DIR/conf/nginx.conf\nNAME=nginx\nPID=$(awk -F'[; ]+' '/^[^#]/{if($0~/pid;/)print $2}' $CONF)\nif [ -z \"$PID\" ]; then\nPID=$WORD_DIR/logs/nginx.pid\nelse\nPID=$WORD_DIR/$PID\nfi\nstop() {\n$DAEMON -s stop\nsleep 1 [ ! -f $PID ] &amp;&amp; action \"* Stopping $NAME\" /bin/true || action \"* Stopping\n$NAME\" /bin/false\n}\nstart() {\n$DAEMON\nsleep 1 [ -f $PID ] &amp;&amp; action \"* Starting $NAME\" /bin/true || action \"* Starting $NAME\"\n/bin/false\n}\nreload() {\n$DAEMON -s reload\n}\ntest_config() {\n$DAEMON -t }\ncase \"$1\" in\nstart)\nif [ ! -f $PID ]; then\nstart\nelse\necho \"$NAME is running...\"\nexit 0\nfi\n;;\nstop)\nif [ -f $PID ]; then\nstop\nelse\necho \"$NAME not running!\"\nexit 0\nfi\n;;\nrestart)\nif [ ! -f $PID ]; then\necho \"$NAME not running!\"\nstart\nelse\nstop\nstart\nfi\n;;\nreload)\nreload\n;;\ntestconfig)\ntest_config\n;;\nstatus)\n[ -f $PID ] &amp;&amp; echo \"$NAME is running...\" || echo \"$NAME not running!\"\n;;\n*)\necho \"Usage: $0 {start|stop|restart|reload|testconfig|status}\"\nexit 3\n;;\nesac</code></pre>\n<h3>20、选择 SSH 连接主机 </h3>\n<p>写一个配置文件保存被监控主机 SSH 连接信息，文件内容格式：主机名 IP User Port。</p>\n<pre><code>#!/bin/bash\nPS3=\"Please input number: \"\nHOST_FILE=host\nwhile true; do\n select NAME in $(awk '{print $1}' $HOST_FILE) quit; do\n [ ${NAME:=empty} == \"quit\" ] &amp;&amp; exit 0\n IP=$(awk -v NAME=${NAME} '$1==NAME{print $2}' $HOST_FILE)\n USER=$(awk -v NAME=${NAME} '$1==NAME{print $3}' $HOST_FILE)\n PORT=$(awk -v NAME=${NAME} '$1==NAME{print $4}' $HOST_FILE)\n if [ $IP ]; then\n echo \"Name: $NAME, IP: $IP\"\n ssh -o StrictHostKeyChecking=no -p $PORT -i id_rsa $USER@$IP # 密钥登录\n break\n else\n echo \"Input error, Please enter again!\"\n break\n fi\n done\ndone</code></pre>\n<h3>21、FTP 下载文件</h3>\n<pre><code>#!/bin/bash\nif [ $# -ne 1 ]; then\necho \"Usage: $0 filename\"\nfi\ndir=$(dirname $1)\nfile=$(basename $1)\nftp -n -v &lt;&lt; EOF # -n 自动登录\nopen 192.168.1.10\nuser admin adminpass\nbinary # 设置 ftp 传输模式为二进制，避免 MD5 值不同或.tar.gz 压缩包格式错误\ncd $dir\nget \"$file\"\nEOF</code></pre>\n<h3>22、输入五个 100 数之内的字符，统计和、最小和最大</h3>\n<pre><code>COUNT=1\nSUM=0\nMIN=0\nMAX=100\nwhile [ $COUNT -le 5 ]; do\nread -p \"请输入 1-10 个整数：\" INT\nif [[ ! $INT =~ ^[0-9]+$ ]]; then\necho \"输入必须是整数！\"\nexit 1\nelif [[ $INT -gt 100 ]]; then\necho \"输入必须是 100 以内！\"\nexit 1\nfi\nSUM=$(($SUM+$INT))\n[ $MIN -lt $INT ] &amp;&amp; MIN=$INT\n[ $MAX -gt $INT ] &amp;&amp; MAX=$INT\nlet COUNT++\ndone\necho \"SUM: $SUM\"\necho \"MIN: $MIN\"\necho \"MAX: $MAX\"</code></pre>\n<h3>23、将结果分别赋值给变量</h3>\n<pre><code>方法 1：\nfor i in $(echo \"4 5 6\"); do\n eval a$i=$i\ndone\necho $a4 $a5 $a6\n方法 2：将位置参数 192.168.18.1{1,2}拆分为到每个变量\nnum=0\nfor i in $(eval echo $*);do #eval 将{1,2}分解为 1 2\n let num+=1\n eval node${num}=\"$i\"\ndone\necho $node1 $node2 $node3\n# bash a.sh 192.168.18.1{1,2}\n192.168.18.11 192.168.18.12\n方法 3：\narr=(4 5 6)\nINDEX1=$(echo ${arr[0]})\nINDEX2=$(echo ${arr[1]})\nINDEX3=$(echo ${arr[2]})</code></pre>\n<h3>24、批量修改文件名</h3>\n<pre><code># touch article_{1..3}.html\n# ls\narticle_1.html article_2.html article_3.html</code></pre>\n<p>现在想把 article 改为 bbs：</p>\n<pre><code>方法 1：\nfor file in $(ls *html); do\nmv $file bbs_${file#*_}\n# mv $file $(echo $file |sed -r 's/.*(_.*)/bbs\\1/')\n# mv $file $(echo $file |echo bbs_$(cut -d_ -f2)\ndone\n方法 2：\nfor file in $(find . -maxdepth 1 -name \"*html\"); do\nmv $file bbs_${file#*_}\ndone\n方法 3： # rename article bbs *.html</code></pre>\n<h3>25、统计当前目录中以.html 结尾的文件总大小</h3>\n<pre><code>方法 1： # find . -name \"*.html\" -maxdepth 1 -exec du -b {} \\; |awk '{sum+=$1}END{print sum}'\n方法 2：\nfor size in $(ls -l *.html |awk '{print $5}'); do\nsum=$(($sum+$size))\ndone\necho $sum\n递归统计：\n# find . -name \"*.html\" -exec du -k {} \\; |awk '{sum+=$1}END{print sum}'</code></pre>\n<h3>26、扫描主机端口状态</h3>\n<pre><code>#!/bin/bash\nHOST=$1\nPORT=\"22 25 80 8080\"\nfor PORT in $PORT; do\n if echo &amp;&gt;/dev/null &gt; /dev/tcp/$HOST/$PORT; then\n echo \"$PORT open\"\n else\n echo \"$PORT close\"\n fi\ndone</code></pre>\n<h3>27、Expect 实现 SSH 免交互执行命令 </h3>\n<p>需要先安装 expect 工具，expect 涉及用法说明：</p>\n<p><img alt=\"\" height=\"525\" src=\"image\\a2c589a1040240c9989c817820d41ae3.png\" width=\"903\"/></p>\n<p>方法 1：EOF 标准输出作为 expect 标准输入 </p>\n<pre><code>#!/bin/bash\nUSER=root\nPASS=123.com\nIP=192.168.1.120\nexpect &lt;&lt; EOF\nset timeout 30\nspawn ssh $USER@$IP \nexpect {\n \"(yes/no)\" {send \"yes\\r\"; exp_continue}\n \"password:\" {send \"$PASS\\r\"}\n}\nexpect \"$USER@*\" {send \"$1\\r\"}\nexpect \"$USER@*\" {send \"exit\\r\"}\nexpect eof \nEOF</code></pre>\n<p>方法 2：</p>\n<pre><code>#!/bin/bash\nUSER=root\nPASS=123.com\nIP=192.168.1.120\nexpect -c \"\n spawn ssh $USER@$IP\n expect {\n \\\"(yes/no)\\\" {send \\\"yes\\r\\\"; exp_continue}\n \\\"password:\\\" {send \\\"$PASS\\r\\\"; exp_continue}\n \\\"$USER@*\\\" {send \\\"df -h\\r exit\\r\\\"; exp_continue}\n }\"</code></pre>\n<p>方法 3：将 expect 脚本独立出来</p>\n<p>login.exp 登录文件：</p>\n<pre><code>#!/usr/bin/expect \nset ip [lindex $argv 0]\nset user [lindex $argv 1]\nset passwd [lindex $argv 2]\nset cmd [lindex $argv 3]\nif { $argc != 4 } {\nputs \"Usage: expect login.exp ip user passwd\"\nexit 1\n}\nset timeout 30\nspawn ssh $user@$ip\nexpect {\n \"(yes/no)\" {send \"yes\\r\"; exp_continue}\n \"password:\" {send \"$passwd\\r\"}\n}\nexpect \"$user@*\" {send \"$cmd\\r\"}\nexpect \"$user@*\" {send \"exit\\r\"}\nexpect eof</code></pre>\n<p>执行命令脚本：</p>\n<pre><code>#!/bin/bash\nHOST_INFO=user_info\nfor ip in $(awk '{print $1}' $HOST_INFO)\ndo\n user=$(awk -v I=\"$ip\" 'I==$1{print $2}' $HOST_INFO)\n pass=$(awk -v I=\"$ip\" 'I==$1{print $3}' $HOST_INFO)\n expect login.exp $ip $user $pass $1\ndone</code></pre>\n<p>SSH 连接信息文件：</p>\n<pre><code># cat user_info \n192.168.1.120 root 123456</code></pre>\n<h3>28、批量修改服务器用户密码 </h3>\n<p>旧密码 SSH 主机信息 old_info 文件：</p>\n<pre><code># ip user passwd port\n#--------------------------------------\n192.168.18.217 root 123456 22\n192.168.18.218 root 123456 22</code></pre>\n<p>修改密码脚本：</p>\n<pre><code>#!/bin/bash\nOLD_INFO=old_info\nNEW_INFO=new_info\nfor IP in $(awk '/^[^#]/{print $1}' $OLD_INFO); do\n USER=$(awk -v I=$IP 'I==$1{print $2}' $OLD_INFO)\n PASS=$(awk -v I=$IP 'I==$1{print $3}' $OLD_INFO)\n PORT=$(awk -v I=$IP 'I==$1{print $4}' $OLD_INFO)\n NEW_PASS=$(mkpasswd -l 8)\n echo \"$IP $USER $NEW_PASS $PORT\" &gt;&gt; $NEW_INFO\n expect -c \"\n spawn ssh -p$PORT $USER@$IP\n set timeout 2\n expect {\n \\\"(yes/no)\\\" {send \\\"yes\\r\\\";exp_continue}\n \\\"password:\\\" {send \\\"$PASS\\r\\\";exp_continue}\n \\\"$USER@*\\\" {send \\\"echo \\'$NEW_PASS\\' |passwd --stdin $USER\\r \nexit\\r\\\";exp_continue}\n }\"\ndone</code></pre>\n<div>\n<p><span style=\"color:#000000;\">生成新密码 new_info 文件：</span></p>\n<pre><code>192.168.18.217 root n8wX3mU% 22\n192.168.18.218 root c87;ZnnL 22</code></pre>\n<h3>29、打印乘法口诀</h3>\n</div>\n<pre><code>方法 1： # awk 'BEGIN{for(n=0;n++&lt;9;){for(i=0;i++&lt;n;)printf i\"x\"n\"=\"i*n\" \";print \"\"}}'\n方法 2：\nfor ((i=1;i&lt;=9;i++)); do\n for ((j=1;j&lt;=i;j++)); do\n result=$(($i*$j))\n echo -n \"$j*$i=$result \"\n done\n echo\ndone</code></pre>\n<p>30、getopts 工具完善脚本命令行参数 </p>\n<p>getopts 是一个解析脚本选项参数的工具。</p>\n<p>命令格式：</p>\n<pre><code>getopts optstring name [arg]</code></pre>\n<p>初次使用你要注意这几点：</p>\n<p>1）脚本位置参数会与 optstring 中的单个字母逐个匹配，如果匹配到就赋值给 name，否则赋值 name为问号；</p>\n<p>2）optstring 中单个字母是一个选项，如果字母后面加冒号，表示该选项后面带参数，参数值并会赋值给 OPTARG 变量；</p>\n<p>3）optstring 中第一个是冒号，表示屏蔽系统错误（test.sh: illegal option -- h）； 4）允许把选项放一起，例如-ab；</p>\n<p>下面写一个打印文件指定行的简单例子，用于引导你思路，扩展你的脚本选项功能：</p>\n<pre><code>#!/bin/bash\nwhile getopts :f:n: option; do\n case $option in\n f)\n FILE=$OPTARG\n[ ! -f $FILE ] &amp;&amp; echo \"$FILE File not exist!\" &amp;&amp; exit\n ;;\n n)\n sed -n \"${OPTARG}p\" $FILE\n ;;\n ?)\n echo \"Usage: $0 -f &lt;file_path&gt; -n &lt;line_number&gt;\"\n echo \"-f, --file specified file\"\n echo \"-n, --line-number print specified line\"\n exit 1\n ;;\n esac\ndone\n# bash test.sh -h\nUsage: test.sh -f &lt;file_path&gt; -n &lt;line_number&gt;\n-f, --file specified file\n-n, --line-number print specified line\n# bash test.sh -f /etc/passwd -n 1\nroot:x:0:0:root:/root:/bin/bash</code></pre>\n<div>\n<span style=\"color:#000000;\">思路扩展：限定脚本参数，将参数保存变量，下面调用变量继续操作。</span>\n</div>\n</div>\n</div>"}