{"blogid": "122287564", "writerAge": "码龄2年", "writerBlogNum": "5", "writerCollect": "29", "writerComment": "30", "writerFan": "16", "writerGrade": "1级", "writerIntegral": "84", "writerName": "一只凡", "writerProfileAdress": "writer_image\\profile_122287564.jpg", "writerRankTotal": "144113", "writerRankWeekly": "1005486", "writerThumb": "16", "writerVisitNum": "4210", "blog_read_count": "1507", "blog_time": "已于 2022-08-13 00:09:10 修改", "blog_title": "基于C++，引用Eigen库，于QT平台开发的一个边角网测量平差程序-XXXX课程设计", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<table align=\"center\" border=\"1\" cellspacing=\"0\"><tbody><tr><td rowspan=\"2\" style=\"border-color:#000000;vertical-align:top;width:99.25pt;\"> <p style=\"margin-left:0px;text-align:center;\"></p> </td><td style=\"border-color:#000000;vertical-align:top;width:262.25pt;\"> <p style=\"margin-left:0px;text-align:center;\"></p> </td></tr><tr><td style=\"vertical-align:top;width:262.25pt;\"> <p style=\"margin-left:0px;text-align:center;\"></p> </td></tr></tbody></table>\n<p style=\"margin-left:0px;text-align:center;\">数据结构与测绘软件开发</p>\n<p style=\"margin-left:0px;text-align:center;\">课程设计</p>\n<p style=\"margin-left:0px;text-align:center;\"></p>\n<p style=\"margin-left:0px;text-align:center;\">边角网测量平差程序设计</p>\n<table align=\"center\" cellspacing=\"0\"><tbody><tr><td style=\"vertical-align:bottom;width:78.35pt;\"> <p style=\"margin-left:0px;text-align:center;\">姓         名：</p> </td><td style=\"vertical-align:bottom;width:155.95pt;\"> <p style=\"margin-left:0px;text-align:center;\">FXXX</p> </td></tr><tr><td style=\"vertical-align:bottom;width:78.35pt;\"> <p style=\"margin-left:0px;text-align:center;\">班       级：</p> </td><td style=\"vertical-align:bottom;width:155.95pt;\"> <p style=\"margin-left:0px;text-align:center;\">测绘工程XXXX班</p> </td></tr><tr><td style=\"vertical-align:bottom;width:78.35pt;\"> <p style=\"margin-left:0px;text-align:center;\">学         号：</p> </td><td style=\"vertical-align:bottom;width:155.95pt;\"> <p style=\"margin-left:0px;text-align:center;\">XXXXXX</p> </td></tr><tr><td style=\"vertical-align:bottom;width:78.35pt;\"> <p style=\"margin-left:0px;text-align:center;\">指导老师：</p> </td><td style=\"vertical-align:bottom;width:155.95pt;\"> <p style=\"margin-left:0px;text-align:center;\">XXXX</p> </td></tr></tbody></table>\n<p style=\"margin-left:0px;text-align:center;\"><strong>XXXXXXXX)XXX</strong></p>\n<p style=\"margin-left:0px;text-align:center;\"><strong>2021年12月</strong></p>\n<p style=\"margin-left:0px;\">前言：主要分享了一个基于C++文本输入输出流读取边角网数据，进行测量平差的程序。限于本人水平有限，望读者恳请指正。</p>\n<p style=\"margin-left:0px;text-align:center;\"></p>\n<p style=\"margin-left:0px;text-align:center;\"></p>\n<p style=\"text-align:center;\"><strong>目录</strong></p>\n<p style=\"margin-left:0px;\"><a href=\"#%E4%B8%80%E3%80%81%E8%AF%BE%E8%AE%BE%E6%A6%82%E5%86%B5\">一、课设概况</a></p>\n<p style=\"margin-left:40px;\"><a href=\"#1.1%E8%AF%BE%E8%AE%BE%E7%9B%AE%E6%A0%87\">1.1课设目标</a></p>\n<p style=\"margin-left:40px;\"><a href=\"#1.2%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83\">1.2开发环境</a></p>\n<p style=\"margin-left:0px;\"><a href=\"#%E4%BA%8C%E3%80%81%E5%B9%B3%E5%B7%AE%E6%A8%A1%E5%9E%8B\">二、平差模型</a></p>\n<p style=\"margin-left:40px;\"><a href=\"#2.1%E8%AF%AF%E5%B7%AE%E6%96%B9%E7%A8%8B\">2.1误差方程</a></p>\n<p style=\"margin-left:40px;\"><a href=\"#2.2%E5%B9%B3%E5%B7%AE%E5%8E%9F%E7%90%86\">2.2平差原理</a></p>\n<p style=\"margin-left:40px;\"><a href=\"#2.3%E7%B2%BE%E5%BA%A6%E8%AF%84%E5%AE%9A\">2.3精度评定</a></p>\n<p style=\"margin-left:40px;\"><a href=\"#Mk=%C2%B1mxk2+myk2%E2%80%8B%20%C2%A0\">​​​​</a><a href=\"#2.4%E8%AF%AF%E5%B7%AE%E6%A4%AD%E5%9C%86%E5%8F%82%E6%95%B0%E8%AE%A1%E7%AE%97\">2.4误差椭圆参数计算</a></p>\n<p style=\"margin-left:0px;\"><a href=\"#%E4%B8%89%E3%80%81%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F\">三、数据文件格式</a></p>\n<p style=\"margin-left:0px;\"><a href=\"#%E5%9B%9B%E3%80%81%E7%B1%BB%E5%8F%8A%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1\">四、类及功能设计</a></p>\n<p style=\"margin-left:40px;\"><a href=\"#4.1%20%E8%AF%BB%E5%8F%96Data.txt%E6%95%B0%E6%8D%AE%E7%B1%BBInData\">4.1 读取Data.txt数据类InData</a></p>\n<p style=\"margin-left:40px;\"><a href=\"#4.2%E8%A7%92%E5%BA%A6%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2%E7%B1%BBAngleChange\">4.2角度格式转换类AngleChange</a></p>\n<p style=\"margin-left:40px;\"><a href=\"#4.3%E8%AE%A1%E7%AE%97%E6%9C%AA%E7%9F%A5%E7%82%B9%E8%BF%91%E4%BC%BC%E5%9D%90%E6%A0%87%E7%B1%BBX0Y0\">4.3计算未知点近似坐标类X0Y0</a></p>\n<p style=\"margin-left:40px;\"><a href=\"#4.4%E5%B9%B3%E5%B7%AE%E6%A8%A1%E5%9D%97%E7%B1%BBAjust\">4.4平差模块类Ajust</a></p>\n<p style=\"margin-left:40px;\"><a href=\"#4.5%E6%95%B0%E6%8D%AE%E8%BE%93%E5%87%BA%E8%87%B3PutData.txt%E7%B1%BBOutData\">4.5数据输出至PutData.txt类OutData</a></p>\n<p style=\"margin-left:0px;\"><a href=\"#%E4%BA%94%E3%80%81%E8%BF%90%E7%AE%97%E5%AE%9E%E4%BE%8B\">五、运算实例</a></p>\n<p style=\"margin-left:40px;\"><a href=\"#5.1%E4%BE%8B%E9%A2%98%E4%B8%80\">5.1例题一</a></p>\n<p style=\"margin-left:40px;\"><a href=\"#5.2%E4%BE%8B%E9%A2%98%E4%BA%8C\">5.2例题二</a></p>\n<p style=\"margin-left:40px;\"><a href=\"#5.3%E4%BE%8B%E9%A2%98%E4%B8%89\">5.3例题三</a></p>\n<p style=\"margin-left:0px;\"><a href=\"#%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93\">六、总结</a></p>\n<p style=\"margin-left:40px;\"><a href=\"#6.1%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97\">6.1开发日志</a></p>\n<p style=\"margin-left:40px;\"><a href=\"#6.2%E6%84%9F%E6%83%B3\">6.2感想</a></p>\n<p style=\"margin-left:0px;\"><a href=\"#%E4%B8%83%E3%80%81%E9%99%84%E5%BD%95%EF%BC%88%E6%BA%90%E4%BB%A3%E7%A0%81%EF%BC%89\">七、附录（源代码）</a></p>\n<p style=\"margin-left:40px;\"><a href=\"#7.1%E9%A1%B9%E7%9B%AE%E5%B7%A5%E7%A8%8B%E7%AE%A1%E7%90%86%E6%96%87%E4%BB%B6day1.pro\">7.1项目工程管理文件day1.pro</a></p>\n<p style=\"margin-left:40px;\"><a href=\"#7.2%E4%B8%BB%E5%87%BD%E6%95%B0%E5%85%A5%E5%8F%A3main.cpp\">7.2主函数入口main.cpp</a></p>\n<p style=\"margin-left:40px;\"><a href=\"#7.3%E7%B1%BB%E7%9A%84.h%E5%92%8C.cpp%E6%96%87%E4%BB%B6\">7.3类的.h和.cpp文件</a></p>\n<p style=\"margin-left:80px;\"><a href=\"#1.%E8%AF%BB%E5%8F%96Data.txt%E7%B1%BBInData\">1.读取Data.txt类InData</a></p>\n<p style=\"margin-left:80px;\"><a href=\"#2.%E8%A7%92%E5%BA%A6%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2%E7%B1%BBAngleChange\">2.角度格式转换类AngleChange</a></p>\n<p style=\"margin-left:80px;\"><a href=\"#3.%E8%AE%A1%E7%AE%97%E8%BF%91%E4%BC%BC%E5%9D%90%E6%A0%87%E7%B1%BBX0Y0\">3.计算近似坐标类X0Y0</a></p>\n<p style=\"margin-left:80px;\"><a href=\"#4.%E5%B9%B3%E5%B7%AE%E6%A8%A1%E5%9D%97%E7%B1%BBAjust\">4.平差模块类Ajust</a></p>\n<p style=\"margin-left:80px;\"><a href=\"#5.%E6%95%B0%E6%8D%AE%E8%BE%93%E5%87%BAPutData.txt%E7%B1%BBOutData\">5.数据输出PutData.txt类OutData</a></p>\n<hr/>\n<h1 style=\"margin-left:0px;\">一、课设概况</h1>\n<h2 style=\"margin-left:0;text-align:justify;\">1.1课设目标</h2>\n<p>课程设计的任务是进行边角网测量平差程序设计，旨在通过C++文件流数据读写的方式，并进行边角网平差计算，以实现数据的批量输入，经过程序化处理后输出的目标。</p>\n<h2 style=\"margin-left:0;text-align:justify;\">1.2开发环境</h2>\n<p style=\"margin-left:0;text-align:justify;\">本次课设中我的应用程序开发框架选择的是：开源版、Windows平台下的Qt5.9.0。</p>\n<p style=\"margin-left:0;text-align:justify;\">集成开发环境（IDE）则为Qt5.9.0相对应的Qt Creator4.3.0。开发中我选择创建简单的控制台应用程序。</p>\n<p style=\"margin-left:0;text-align:justify;\">除了开发环境的选择外，还引用了Eigen3.4.0。Eigen库是一个开源的C++模板库，在这次实习中主要是用来进行矩阵运算和数值分析。</p>\n<p style=\"margin-left:0;text-align:justify;\">Eigen目前最新的版本是3.4.0，除了C++标准库以外，不需要任何其他的依赖包。Eigen使用的CMake建立配置文件和单元测试，并自动安装。如果使用Eigen库，只需包特定模块的的头文件即可，简单了说它就是一个C++版本的matlab包。一般情况下，使用include&lt;Eigen/Dense&gt;即可。</p>\n<p style=\"margin-left:0;text-align:center;\">表1 Eigen库模块表</p>\n<table border=\"1\" cellspacing=\"0\"><tbody><tr><td style=\"border-color:#000000;width:77.75pt;\"> <p style=\"margin-left:0;text-align:center;\">Module</p> </td><td style=\"border-color:#000000;width:148.8pt;\"> <p style=\"margin-left:0;text-align:center;\">Header file</p> </td><td style=\"border-color:#000000;width:188.25pt;\"> <p style=\"margin-left:0;text-align:center;\">Contents</p> </td></tr><tr><td style=\"border-color:#000000;width:77.75pt;\"> <p style=\"margin-left:0;text-align:center;\">Core</p> </td><td style=\"width:148.8pt;\"> <p style=\"margin-left:0;text-align:center;\">#include&lt;Eigen/Core&gt;</p> </td><td style=\"width:188.25pt;\"> <p style=\"margin-left:0;text-align:center;\">Matrix和Array类，基础的线性代数运算和数组操作</p> </td></tr><tr><td style=\"border-color:#000000;width:77.75pt;\"> <p style=\"margin-left:0;text-align:center;\">Geometry</p> </td><td style=\"width:148.8pt;\"> <p style=\"margin-left:0;text-align:center;\">#include&lt;Eigen/Geometry&gt;</p> </td><td style=\"width:188.25pt;\"> <p style=\"margin-left:0;text-align:center;\">旋转、平移、缩放、2维和3维的各种变换</p> </td></tr><tr><td style=\"border-color:#000000;width:77.75pt;\"> <p style=\"margin-left:0;text-align:center;\">LU</p> </td><td style=\"width:148.8pt;\"> <p style=\"margin-left:0;text-align:center;\">#include&lt;Eigen/LU&gt;</p> </td><td style=\"width:188.25pt;\"> <p style=\"margin-left:0;text-align:center;\">求逆，行列式，LU分解</p> </td></tr><tr><td style=\"border-color:#000000;width:77.75pt;\"> <p style=\"margin-left:0;text-align:center;\">Cholesky</p> </td><td style=\"width:148.8pt;\"> <p style=\"margin-left:0;text-align:center;\">#include &lt;Eigen/Cholesky&gt;</p> </td><td style=\"width:188.25pt;\"> <p style=\"margin-left:0;text-align:center;\">LLT和LDLT Cholesky分解</p> </td></tr><tr><td style=\"border-color:#000000;width:77.75pt;\"> <p style=\"margin-left:0;text-align:center;\">Householder</p> </td><td style=\"width:148.8pt;\"> <p style=\"margin-left:0;text-align:center;\">#include&lt;Eigen/Householder&gt;</p> </td><td style=\"width:188.25pt;\"> <p style=\"margin-left:0;text-align:center;\">豪斯霍尔德变换，用于线性代数运算</p> </td></tr><tr><td style=\"border-color:#000000;width:77.75pt;\"> <p style=\"margin-left:0;text-align:center;\">SVD</p> </td><td style=\"width:148.8pt;\"> <p style=\"margin-left:0;text-align:center;\">#include&lt;Eigen/SVD&gt;</p> </td><td style=\"width:188.25pt;\"> <p style=\"margin-left:0;text-align:center;\">SVD分解</p> </td></tr><tr><td style=\"border-color:#000000;width:77.75pt;\"> <p style=\"margin-left:0;text-align:center;\">QR</p> </td><td style=\"width:148.8pt;\"> <p style=\"margin-left:0;text-align:center;\">#include&lt;Eigen/QR&gt;</p> </td><td style=\"width:188.25pt;\"> <p style=\"margin-left:0;text-align:center;\">QR分解</p> </td></tr><tr><td style=\"border-color:#000000;width:77.75pt;\"> <p style=\"margin-left:0;text-align:center;\">Eigenvalues</p> </td><td style=\"width:148.8pt;\"> <p style=\"margin-left:0;text-align:center;\">#include&lt;Eigen/Eigenvalues&gt;</p> </td><td style=\"width:188.25pt;\"> <p style=\"margin-left:0;text-align:center;\">特征值，特征向量分解</p> </td></tr><tr><td style=\"border-color:#000000;width:77.75pt;\"> <p style=\"margin-left:0;text-align:center;\">Sparse</p> </td><td style=\"width:148.8pt;\"> <p style=\"margin-left:0;text-align:center;\">#include&lt;Eigen/Sparse&gt;</p> </td><td style=\"width:188.25pt;\"> <p style=\"margin-left:0;text-align:center;\">稀疏矩阵的存储和一些基本的线性运算</p> </td></tr><tr><td style=\"border-color:#000000;width:77.75pt;\"> <p style=\"margin-left:0;text-align:center;\">稠密矩阵</p> </td><td style=\"width:148.8pt;\"> <p style=\"margin-left:0;text-align:center;\"><strong>#include&lt;Eigen/Dense&gt;</strong></p> </td><td style=\"width:188.25pt;\"> <p style=\"margin-left:0;text-align:center;\"><strong>Core/Geometry/LU/Cholesky/SVD/QR/Eigenvalues</strong><strong>模块</strong></p> </td></tr><tr><td style=\"border-color:#000000;width:77.75pt;\"> <p style=\"margin-left:0;text-align:center;\">矩阵</p> </td><td style=\"width:148.8pt;\"> <p style=\"margin-left:0;text-align:center;\">#include&lt;Eigen/Eigen&gt;</p> </td><td style=\"width:188.25pt;\"> <p style=\"margin-left:0;text-align:center;\">包括Dense和Sparse(整合库)</p> </td></tr></tbody></table>\n<p></p>\n<p>不同的IDE下，引用Eigen库方式不同，Qt Creator在项目工程文件中添加Eigen的路径，添加一行代码INCLUDEPATH += Eigen库的路径即可，如下图所示：</p>\n<p style=\"text-align:center;\"><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5Y-q5Yeh,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\0b8ed1227c094303819d25ae6c4ac9d7.png\"/></p>\n<p style=\"margin-left:0;text-align:center;\">图1 Qt环境下添加Eigen库</p>\n<p style=\"margin-left:0;text-align:justify;\">至于其他环境，如VS，VC++等，在此不再说明，面向百度即可，在整个开发过程中，我遇到很多不懂的方法，以及bug等等，也是通过查看书籍、面向“百度”、以及向的优秀同学们请教等最终完成了这次边角网数据平差的课设目标。</p>\n<h1 style=\"margin-left:0;text-align:justify;\">二、平差模型</h1>\n<p style=\"margin-left:0;text-align:justify;\">本程序采用间接平差模型。令未知点的坐标平差值为参数。</p>\n<p style=\"margin-left:0;text-align:justify;\">平差有两种方式，一种是条件平差，一种是间接平差。条件方程式较少，占用内存小，但条件方程与网形有关，很难编制通用的程序。间接平差一个观测值就是一个误差方程，占用内存相对较大，但易于编程解算，容易编制通用的程序。从程序编制和程序的通用性考虑，所以选择间接平差的方法。</p>\n<h2 style=\"margin-left:0;text-align:justify;\">2.1误差方程</h2>\n<p style=\"margin-left:0;text-align:justify;\">（1）边长误差方程：</p>\n<p style=\"margin-left:0;text-align:justify;\">设<em>Ski</em>为<em>k</em>号点至<em>i</em>号点的边长观测值，则有：</p>\n<p style=\"margin-left:0;text-align:justify;\"><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5Y-q5Yeh,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\ba50d8df9f0b43c0ae005377fd01d28e.png\"/></p>\n<p style=\"margin-left:0;text-align:justify;\">线性化：</p>\n<p style=\"margin-left:0;text-align:justify;\"><img alt=\"1dff776742ab4d8789f0e9fc5a39cf2b.png\" src=\"image\\1dff776742ab4d8789f0e9fc5a39cf2b.png\"/><img alt=\"e260ac61c4064377b6ec764d6cff4e58.png\" src=\"image\\e260ac61c4064377b6ec764d6cff4e58.png\"/><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5Y-q5Yeh,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\8d1dfc0559ff4f9c8ef00c466c480d1b.png\"/></p>\n<p style=\"margin-left:0;text-align:justify;\">（2）观测角度误差方程</p>\n<p style=\"margin-left:0;text-align:justify;\"><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5Y-q5Yeh,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\a2abeb6ba4674f1aa0c5463540bf92d5.png\"/></p>\n<h2 style=\"margin-left:0;text-align:justify;\">2.2平差原理</h2>\n<p style=\"margin-left:0;text-align:justify;\">（1）将每一个观测量的平差值分别表达成所选参数的函数：</p>\n<p style=\"margin-left:0;text-align:center;\"><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5Y-q5Yeh,size_16,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\a12c3b4492cf427ab2fd9e2640661b21.png\"/></p>\n<p style=\"margin-left:0;text-align:justify;\">（2）若函数非线性要将其线性化，列出误差方程</p>\n<p style=\"margin-left:0;text-align:center;\"><img alt=\"1f5a1bc50b70460fb472ba03e8a633c6.png\" src=\"image\\1f5a1bc50b70460fb472ba03e8a633c6.png\"/></p>\n<p style=\"margin-left:0;text-align:justify;\">（3）由误差方程系数<strong><em>B</em></strong>和自由项组成法方程：</p>\n<p style=\"margin-left:0;text-align:center;\"><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5Y-q5Yeh,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\9b67f28b0b5b4f7fa039c2954eb689d4.png\"/></p>\n<p></p>\n<h2 style=\"margin-left:0;text-align:justify;\">2.3精度评定</h2>\n<p style=\"margin-left:0;text-align:justify;\">（1）单位权中误差</p>\n<p style=\"margin-left:0;text-align:center;\"><img alt=\"16f69f267fe44bd3ad9a1cbb247b8300.png\" src=\"image\\16f69f267fe44bd3ad9a1cbb247b8300.png\"/></p>\n<p style=\"margin-left:0;text-align:justify;\">（2）坐标平差值的协因数阵：</p>\n<p style=\"margin-left:0;text-align:center;\"><strong>Q</strong><em>XX</em>=(<em>ATPA</em>)-1</p>\n<p style=\"margin-left:0;text-align:justify;\">（3）K点坐标平差值的中误差、点位中误差：</p>\n<p style=\"text-align:center;\"><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5Y-q5Yeh,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\ffc2897bffaf491b9b10958366d74302.png\"/></p>\n<p style=\"margin-left:0px;text-align:center;\"><img alt=\"2494d046f199481c98065ea63d42b956.png\" src=\"image\\2494d046f199481c98065ea63d42b956.png\"/>  </p>\n<h2 style=\"margin-left:0;text-align:justify;\">2.4误差椭圆参数计算</h2>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5Y-q5Yeh,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\8367330ecb474978b8d160360e678c2d.png\"/></p>\n<p style=\"margin-left:0;text-align:justify;\">计算出两个根后，直接带入公式计算E和F，再判断E和F谁是极大值，极小值：</p>\n<p style=\"margin-left:0;text-align:center;\"><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5Y-q5Yeh,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\6bd26be7dea94b52a1bc46c5cbef1d94.png\"/></p>\n<p style=\"margin-left:0;text-align:justify;\">选择φ方向位差公式，因为用它程序计算方便直观，别的方式需要进行其他的判断。</p>\n<h1 style=\"margin-left:0;text-align:justify;\">三、数据文件格式</h1>\n<p style=\"margin-left:0;text-align:justify;\">将起算数据、观测精度指标、观测值及相关数据存入Data.txt文本文档中，进行数据读取操作，因此将涉及设计他们之间的数据关系以及结构设计。以如下图2边角网为例，说明数据文件的格式。</p>\n<p style=\"margin-left:0;text-align:justify;\">已知点为A、B、C、D、E、F共6个，未知点编号7，8,9,10·······17，18共12个，观测了14条边长S1～S14，观测了16个转角β1～β16，测角精度10″，测边精度10mm+15ppm。</p>\n<p style=\"text-align:center;\"><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5Y-q5Yeh,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\4aa65dcaf62f45e3b8df264982d5004f.png\"/></p>\n<p style=\"text-align:center;\"> 图2 示例边角网</p>\n<p style=\"margin-left:0;text-align:justify;\"><strong>1.边角网概况信息</strong></p>\n<p style=\"margin-left:0;text-align:justify;\">此部分，说明边角网的整体控制信息，包含，已知点数目、未知点数目、边长观测数、角度观测数，在本例中，它们分别为6、12、14、16。</p>\n<p style=\"margin-left:0;text-align:justify;\">以及精度指标：角度观测精度（秒），光电测距边长精度Amm+Bppm*L的固定误差A，比例误差B。本例中，分别为10、10、15。</p>\n<p style=\"margin-left:0;text-align:justify;\">在Data.txt文档中的中文描述语要为一整句，即中间须有标点符号连接，不能有空格，否则数据读取时会出错，对于数据的数字之间则用一个空格隔开，如下图3所示：</p>\n<p style=\"text-align:center;\"><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5Y-q5Yeh,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\82551b55a51b496f9c91cb363402c527.png\"/></p>\n<p style=\"text-align:center;\"> 图3 边角网概况信息数据格式</p>\n<p style=\"margin-left:0;text-align:justify;\"><strong>2.已知点数据格式</strong></p>\n<p style=\"margin-left:0;text-align:justify;\">已知点的ID编号以及X坐标和Y坐标。ID编号必须为数字，且从1开始编号，不能为字母。在本程序中，设计了一个大小为 ：已知点数*3的矩阵（数组），第一列是点的ID编号、第二列是X坐标，第三列是Y坐标。因为统一放在同一个矩阵，所以ID编号必须为数字，当然也可以用类型不同的数组存放，字符型的或是其他类型，但是在我程序编写的过程中，我自认为那样变得更加繁琐冗杂了，另外为了从存放已知点信息的这个矩阵调用已知点数据更加方便，所以从1开始编号。</p>\n<p style=\"margin-left:0;text-align:left;\">本例中已知点为A、B、C、D、E、F分别令他们ID编号为1、2、3、4、5、6。一行输入已知点的ID编号以及X坐标和Y坐标，之间用空格隔开，如下图4所示：</p>\n<p style=\"margin-left:0;text-align:center;\"><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5Y-q5Yeh,size_19,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\52fb2dd160aa4026bfd7efbb545e3952.png\"/></p>\n<p style=\"margin-left:0;text-align:center;\">图4 已知点数据格式</p>\n<p style=\"margin-left:0;text-align:justify;\"><strong>3.未知点数据格式</strong></p>\n<p style=\"margin-left:0;text-align:justify;\">同已知点格式类似，但是只需要ID编号即可，未知点的ID编号和已知点连续，本例中，已知点有6个，那未知点的ID编号就从7开始。</p>\n<p style=\"margin-left:0;text-align:justify;\">本例中未知点,分别令他们ID编号为7～18，如下图5所示：</p>\n<p style=\"margin-left:0;text-align:center;\"><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5Y-q5Yeh,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\b0b164547042484291ed2e8c83e9cdb9.png\"/></p>\n<p style=\"margin-left:0;text-align:center;\">图5 未知点数据格式</p>\n<p style=\"margin-left:0px;\"><strong>4.边长观测数据格式</strong></p>\n<p style=\"margin-left:0;text-align:justify;\">边长数据格式设计为：边长观测数 * 4的矩阵，每一行数据存储边长的ID编号，从1开始；对应的边长，单位：米/m；起点、终点的ID编号，这里ID编号即是已知点或者未知点的对应编号ID。</p>\n<p style=\"margin-left:0;text-align:justify;\">本例中，观测14条边，数据格式如下图6所示：</p>\n<p style=\"margin-left:0px;text-align:center;\"><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5Y-q5Yeh,size_19,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\bd3a8ebfe62d4149b09a77c8a43f921b.png\"/></p>\n<p style=\"margin-left:0px;text-align:center;\">图6 边长观测数据格式</p>\n<p style=\"margin-left:0;text-align:justify;\"><strong>5.角度观测数据格式</strong></p>\n<p style=\"margin-left:0;text-align:justify;\">角度数据格式设计为：角度观测数 * 5的矩阵，每一行数据存储角度观测值的测站ID，后视照准ID_1，前视照准ID_2，夹角观测值，测站ID和前视照准ID_2对应的边的ID编号。</p>\n<p style=\"margin-left:0;text-align:justify;\">其中夹角按照顺时针记录，数字用“度.分秒”表示，如23.20205格式表示23度20分20.5秒。测站ID，后视照准ID_1，前视照准ID_2指的是当前对应的已知点或未知点的ID编号。测站ID和前视照准ID_2对应的边的ID编号，这里边的ID编号指的是测站为起点（终点），前视照准为终点（起点）的那条边的ID编号。</p>\n<p style=\"margin-left:0;text-align:justify;\">参考图2示例边角网，以本例中的夹角β3具体说明：</p>\n<p style=\"margin-left:0;text-align:justify;\">测站ID=8</p>\n<p style=\"margin-left:0;text-align:justify;\">后视照准ID_1=7</p>\n<p style=\"margin-left:0;text-align:justify;\">前视照准ID_2=9</p>\n<p style=\"margin-left:0;text-align:justify;\">角值=250.1811</p>\n<p style=\"margin-left:0;text-align:justify;\">测站ID和前视照准ID_2对应的边的ID编号=3。其起点（终点）为8，终点（起点）为9，对应的边是S3，在边长数据格式中该边的ID编号是3。若测站ID和前视照准ID_2对应的边是两个已知点之间，那对应边ID此时写为0即可。</p>\n<p style=\"margin-left:0;text-align:justify;\">另外，该数据编写时，尽量从一已知方向出发，编写完该方向的所有观测角数据，再换另外的方向，否则，数据不清晰虽然并不影响程序执行，但是影响可读性。</p>\n<p style=\"margin-left:0;text-align:justify;\">本例角度观测数据格式如下图7所示：</p>\n<p style=\"margin-left:0px;text-align:center;\"><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5Y-q5Yeh,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\7f50593811944309b2ae4b3700f209e0.png\"/></p>\n<p style=\"margin-left:0px;text-align:center;\">图7 角度观测数据格式</p>\n<p style=\"margin-left:0;text-align:justify;\">通过以上的数据结构设计，将所有数据存放到Data.txt，并将Data.txt存储在编译环境下的工程项目中，以方便C++文件流以相对路径打开文件读写，当然也可以不考虑Data.txt的文件位置，在文件读取时以绝对路径即可。</p>\n<p style=\"margin-left:0;text-align:justify;\">但我认为，相对路径的方式更好，绝对路径用户的电脑命名不同，可能导致数据读取出错，另外，文件、程序的路径尽量不要包含有中文，横杠等特殊字符，可能导致不同的电脑不能运行。不同的IDE存放相对路径目录不同，在此仅以Qt为例，在编译器构建生成的同级目录下。如下图8所示：</p>\n<p style=\"text-align:center;\"><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5Y-q5Yeh,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\36b1cb61cd9540929581e81ae8577c1e.png\"/></p>\n<p style=\"text-align:center;\"> 图8 Date.txt相对路径位置</p>\n<p style=\"margin-left:0;text-align:justify;\">本例的数据格式全貌如下图9所示：</p>\n<p style=\"text-align:center;\"><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5Y-q5Yeh,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\461eb4f54bd247d38aa1d11d6fdbc411.png\"/></p>\n<p style=\"text-align:center;\"> 图9 Date.txt数据</p>\n<h1 style=\"margin-left:0px;\">四、类及功能设计</h1>\n<p>本程序我设计了读取Data.txt文本文件的类InData、角度格式转换的类AngleChange、计算近似坐标的类X0Y0、平差模块的Ajust、将平差处理后的相关数据输出的类OutData。它们之间的关系如下所示：</p>\n<p style=\"text-align:center;\"><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5Y-q5Yeh,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\e766a7b2c1e34259a58bc7894bc76029.png\"/></p>\n<h2 style=\"margin-left:0;text-align:justify;\">4.1 读取Data.txt数据类InData</h2>\n<p style=\"margin-left:0;text-align:justify;\">类体定义在indta.h头文件，声明函数具体实现indata.cpp文件。源代码见附录。在此说明定义了什么变量，函数以及它们关系。</p>\n<p style=\"margin-left:0;text-align:justify;\"><strong>（1）indata.h</strong></p>\n<p style=\"margin-left:0;text-align:left;\">class InData//边角网数据读取类</p>\n<p style=\"margin-left:0;text-align:left;\">{<!-- --></p>\n<p style=\"margin-left:0;text-align:left;\">public://定义一些外部接口成员</p>\n<p style=\"margin-left:0;text-align:left;\">int knownpoint,unknownpoint,Num_Distance,Num_Angle;</p>\n<p style=\"margin-left:0;text-align:left;\">//已知点数，未知点数，边长观测数，角度观测数</p>\n<p style=\"margin-left:0;text-align:left;\">double Pre_Angle,Pre_Distance_A,Pre_Distance_B;</p>\n<p style=\"margin-left:0;text-align:left;\">//角度观测精度（秒），光电测距边长精度Amm+Bppm*L的固定误差A，比例误差B</p>\n<p style=\"margin-left:0;text-align:left;\">    Eigen::MatrixXd KnownPointXY;//定义矩阵存放已知点的信息</p>\n<p style=\"margin-left:0;text-align:left;\">    Eigen::MatrixXd UnKnownPointX0Y0;//定义矩阵存放未知点的信息</p>\n<p style=\"margin-left:0;text-align:left;\">    Eigen::MatrixXd Distance_Obs;//定义矩阵存放边长观测值的信息</p>\n<p style=\"margin-left:0;text-align:left;\">    Eigen::MatrixXd Angle_Obs;//定义矩阵存放角度观测值的信息</p>\n<p style=\"margin-left:0;text-align:left;\">public:</p>\n<p style=\"margin-left:0;text-align:left;\">    void DoInData();//从Data.txt读取信息，存储到InData类</p>\n<p style=\"margin-left:0;text-align:left;\">};</p>\n<p style=\"margin-left:0;text-align:justify;\"><strong>（2）indata.cpp</strong></p>\n<p style=\"margin-left:0;text-align:justify;\">在此处具体实现函数void DoInData()的功能，在mian函数时调用该函数，以实现数据读取。</p>\n<p style=\"margin-left:0;text-align:justify;\">定义文件流对象FileRead，用于读取项目下的Data.txt文件。</p>\n<p style=\"margin-left:0;text-align:left;\">ifstream FileRead;</p>\n<p style=\"margin-left:0;text-align:justify;\">    FileRead.open(\"Data.txt\",ios::in);//读取项目相对路径下的Data.txt文件</p>\n<p style=\"margin-left:0;text-align:justify;\">具体代码间附录。可以将读到的数据输出到控制台应用，即显示屏上，结果如下图10。并且可供检查Data.txt数据是否正确。</p>\n<p style=\"margin-left:0;text-align:center;\"><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5Y-q5Yeh,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\cace44b6b14e48878c98b994bfeaafef.png\"/><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5Y-q5Yeh,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\796639e65d8d40f6b3c27c2c620ef65e.png\"/>图10 读取Data数据存放到成员</p>\n<h2 style=\"margin-left:0px;\">4.2角度格式转换类AngleChange</h2>\n<p style=\"margin-left:0;text-align:justify;\">由于程序处理运算使用的三角函数等是弧度值，因此需要将Data.txt数据中的度.分秒转换为0～2π的弧度值。AngleChange需要使用InData中读取到的数据，因此InData类的成员属性定义为public，并且AngleChange类public继承了InData类。</p>\n<p style=\"margin-left:0;text-align:left;\">class AngleChange:public InData</p>\n<p style=\"margin-left:0;text-align:left;\">{<!-- --></p>\n<p style=\"margin-left:0;text-align:left;\">public:</p>\n<p style=\"margin-left:0;text-align:left;\">    Eigen::MatrixXd Angle_Rad;//定义存放角度转换为弧度后的矩阵</p>\n<p style=\"margin-left:0;text-align:justify;\">void DoAngleChange();//弧度转换</p>\n<p style=\"margin-left:0;text-align:justify;\">};具体代码见附录。</p>\n<h2 style=\"margin-left:0;text-align:justify;\">4.3计算未知点近似坐标类X0Y0</h2>\n<p style=\"margin-left:0;text-align:justify;\">利用读取到的数据计算近似坐标计算，并存储到新定义的矩阵AllPointX0Y0，存放已知点坐标和未知点计算出来后的近似坐标。同样，X0Y0类public继承了AngleChange类。类体如下：</p>\n<p style=\"margin-left:0;text-align:left;\">#include \"anglechange.h\"</p>\n<p style=\"margin-left:0;text-align:left;\">class X0Y0:public AngleChange</p>\n<p style=\"margin-left:0;text-align:left;\">{<!-- --></p>\n<p style=\"margin-left:0;text-align:left;\">public:</p>\n<p style=\"margin-left:0;text-align:left;\">//存放已知点坐标和未知点计算出来后的近似坐标</p>\n<p style=\"margin-left:0;text-align:left;\">Eigen::MatrixXd AllPointX0Y0;</p>\n<p style=\"margin-left:0;text-align:left;\">void DoX0Y0();//计算未知点近似坐标</p>\n<p style=\"margin-left:0;text-align:left;\">};</p>\n<p style=\"margin-left:0;text-align:justify;\">以下图11中未知点7计算近似坐标说明：</p>\n<p style=\"margin-left:0;text-align:center;\"><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5Y-q5Yeh,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\6ab5e7aa480b45efac4341b2338b5dcc.png\"/></p>\n<p style=\"margin-left:0;text-align:center;\">图11 未知点7计算示例图</p>\n<p style=\"margin-left:0;text-align:justify;\"><strong>（1）在角β1的观测数据中，即矩阵Angle_Obs中可知：</strong></p>\n<p style=\"margin-left:0;text-align:justify;\">测站ID=2，后视ID_1=1 ，前视ID_2=7 ，夹角值（弧度）=163.4504（2.857996043），边长ID=1</p>\n<p style=\"margin-left:0;text-align:justify;\"><strong>（2）判断前视ID_2是否为未知点ID。</strong></p>\n<p style=\"margin-left:0;text-align:left;\">//检索并判断当前的未知点的X坐标是否为0；</p>\n<p style=\"margin-left:0;text-align:left;\">if(AllPointX0Y0(i+knownpoint,1)!=0)</p>\n<p style=\"margin-left:0;text-align:left;\">        continue;</p>\n<p style=\"margin-left:0;text-align:left;\">//若不等于0，说明上一次检索已经计算过当前未知点X和Y坐标，就不再执行下面的语句</p>\n<p style=\"margin-left:0;text-align:left;\">int Station_ID=Angle_Rad(j,0);//测站ID</p>\n<p style=\"margin-left:0;text-align:left;\">int Station_ID1=Angle_Rad(j,1);//后照ID_1</p>\n<p style=\"margin-left:0;text-align:left;\">double Angle=Angle_Rad(j,3);//角度观测值（弧度）</p>\n<p style=\"margin-left:0;text-align:left;\">int Dis_ID=Angle_Rad(j,4);//测站ID和前照ID_2对应的边长编号ID</p>\n<p style=\"margin-left:0;text-align:left;\">if(Angle_Rad(j,2)==UnKnownPointX0Y0(i,0)&amp;&amp;Dis_ID!=0)//检索并判断矩阵Angle_Rad第3列数据，即前照ID_2是否等于当前要计算的未知点ID编号，且对应的边长编号ID不为0，若条件成立，通过矩阵Angle_Rad中该前照ID_2对应的测站ID，后照ID_1计算未知点近似X和Y坐标</p>\n<p style=\"margin-left:0;text-align:justify;\"><strong>（3）该示例，前视ID_2=7是未知点ID编号，就执行计算。</strong></p>\n<p style=\"margin-left:0;text-align:left;\">double X1,Y1,X2,Y2;</p>\n<p style=\"margin-left:0;text-align:left;\">X1=AllPointX0Y0(Station_ID1-1,1);//测站后照ID_1对应X坐标</p>\n<p style=\"margin-left:0;text-align:left;\">Y1=AllPointX0Y0(Station_ID1-1,2);//测站后照ID_1对应Y坐标</p>\n<p style=\"margin-left:0;text-align:left;\">X2=AllPointX0Y0(Station_ID-1,1);//测站ID对应X坐标</p>\n<p style=\"margin-left:0;text-align:left;\">Y2=AllPointX0Y0(Station_ID-1,2);//测站ID对应Y坐标</p>\n<p style=\"margin-left:0;text-align:left;\">double a0=atan2((Y2-Y1),(X2-X1));//计算上一条边方位角</p>\n<p style=\"margin-left:0;text-align:left;\">if(a0&lt;0)//使方位角全为0~2PI范围</p>\n<p style=\"margin-left:0;text-align:left;\">{<!-- --></p>\n<p style=\"margin-left:0;text-align:left;\">a0=a0+2*PI;}</p>\n<p style=\"margin-left:0;text-align:left;\">double a=a0+Angle-PI;//计算测站ID和前照ID_2对应的边的方位角</p>\n<p style=\"margin-left:0;text-align:left;\">double X0,Y0;//计算当前未知点的对应近似X0和Y0坐标</p>\n<p style=\"margin-left:0;text-align:left;\">X0=X2+Distance_Obs(Dis_ID-1,1)*cos(a);</p>\n<p style=\"margin-left:0;text-align:justify;\">Y0=Y2+Distance_Obs(Dis_ID-1,1)*sin(a);</p>\n<p style=\"margin-left:0;text-align:justify;\"><strong>（4）计算完未知点7坐标，更新矩阵AllPointX0Y0</strong></p>\n<p style=\"margin-left:0;text-align:justify;\">之后的未知点计算需要用到之前的未知点坐标，如接下来未知点8的近似坐标计算，就需要未知点7的近似坐标，所以将计算出来的近似坐标存放回矩阵AllPointX0Y0。只需要如下简单的两句语句即可：</p>\n<p style=\"margin-left:0;text-align:left;\">AllPointX0Y0(i+knownpoint,1)=X0;</p>\n<p style=\"margin-left:0;text-align:left;\">AllPointX0Y0(i+knownpoint,2)=Y0;</p>\n<p style=\"margin-left:0;text-align:justify;\">该示例计算成功后的结果如下图12：其中1～6是已知点数据。</p>\n<p style=\"text-align:center;\"><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5Y-q5Yeh,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\c8aff5676f714f9bbf4f2387363bf698.png\"/></p>\n<p style=\"text-align:center;\"> 图12 近似坐标计算成果</p>\n<h2 style=\"margin-left:0;text-align:justify;\">4.4平差模块类Ajust</h2>\n<p style=\"margin-left:0;text-align:justify;\">计算出未知点近似坐标后，就可以误差方程计算系数阵B，自由项等，平差模块类Ajust主要定义了平差所需的相关矩阵和变量，以及计算的函数，同样，需要用到之前类的数据，所以Ajust类public继承了X0Y0类。</p>\n<p style=\"margin-left:0;text-align:justify;\">类体如下：</p>\n<p style=\"margin-left:0;text-align:left;\">#include \"x0y0.h\"</p>\n<p style=\"margin-left:0;text-align:left;\">class Ajust:public X0Y0</p>\n<p style=\"margin-left:0;text-align:left;\">{public:</p>\n<p style=\"margin-left:0;text-align:left;\">    Eigen::MatrixXd V;//改正数矩阵</p>\n<p style=\"margin-left:0;text-align:left;\">    Eigen::MatrixXd B;//误差方程系数矩阵</p>\n<p style=\"margin-left:0;text-align:left;\">    Eigen::MatrixXd x;//待定参数矩阵</p>\n<p style=\"margin-left:0;text-align:left;\">    Eigen::MatrixXd l;//自由项矩阵</p>\n<p style=\"margin-left:0;text-align:left;\">    Eigen::MatrixXd P;//权矩阵</p>\n<p style=\"margin-left:0;text-align:left;\">    Eigen::MatrixXd Nbb;//法方程系数阵</p>\n<p style=\"margin-left:0;text-align:left;\">    double sigma0;//单位权中误差</p>\n<p style=\"margin-left:0;text-align:left;\">    Eigen::MatrixXd QXX;//平差参数X的协因数阵</p>\n<p style=\"margin-left:0;text-align:left;\">    Eigen::MatrixXd DXX;//平差参数X的协方差阵</p>\n<p style=\"margin-left:0;text-align:left;\">    Eigen::MatrixXd Fhi0_E;//极大值方向</p>\n<p style=\"margin-left:0;text-align:left;\">    Eigen::MatrixXd Fhi0_F;//极大值方向</p>\n<p style=\"margin-left:0;text-align:left;\">    Eigen::MatrixXd E;//误差椭圆极大值</p>\n<p style=\"margin-left:0;text-align:left;\">    Eigen::MatrixXd F;//误差椭圆极小值</p>\n<p style=\"margin-left:0;text-align:left;\">public:</p>\n<p style=\"margin-left:0;text-align:left;\">    void DoForBl();//计算误差方程系数阵B、自由项矩阵l</p>\n<p style=\"margin-left:0;text-align:left;\">    void DoForP();//计算权矩阵P</p>\n<p style=\"margin-left:0;text-align:left;\">    void DoForVx();//计算改正数矩阵V、待定参数矩阵x</p>\n<p style=\"margin-left:0;text-align:left;\">    void Accuracy_assess();//精度评定函数</p>\n<p style=\"margin-left:0;text-align:left;\">void Error_ellipse();//误差椭圆参数计算</p>\n<p style=\"margin-left:0;text-align:justify;\">};具体实现见附录源代码。</p>\n<h2 style=\"margin-left:0;text-align:justify;\">4.5数据输出至PutData.txt类OutData</h2>\n<p style=\"margin-left:0;text-align:justify;\">此类主要定义了函数void DoPutData()进行相关数据及其成果的输出，通过文件流输出至项目相对路径下的文本文档PutData.txt中，因为要使用到之前数据成果，所以OutData类public继承了Ajust类。类体如下</p>\n<pre style=\"margin-left:.0001pt;\">#include \"ajust.h\"</pre>\n<pre style=\"margin-left:.0001pt;\">class OutData:public Ajust</pre>\n<pre style=\"margin-left:.0001pt;\">{<!-- --></pre>\n<pre style=\"margin-left:.0001pt;\">public:</pre>\n<pre style=\"margin-left:.0001pt;\">    void DoPutData();//将数据输出至PutData.txt文本文档</pre>\n<pre style=\"margin-left:.0001pt;\">};具体实现见附录源代码。</pre>\n<h1 style=\"margin-left:0;text-align:justify;\">五、运算实例</h1>\n<p style=\"margin-left:0;text-align:justify;\">此部分选择《测量平差》-第二版-中国矿业大学出版社，教材中几个例题，按照本程序的思路，编写Data.txt文本文档，就程序运行进行实例展示。</p>\n<p style=\"margin-left:0;text-align:justify;\">例题一：课本103页，例【4-2】；</p>\n<p style=\"margin-left:0;text-align:justify;\">例题二：课本139页，例【5-3】；</p>\n<p style=\"margin-left:0;text-align:justify;\">例题三：课本245页，第四题。</p>\n<h2 style=\"margin-left:0;text-align:justify;\">5.1例题一</h2>\n<p style=\"margin-left:0;text-align:justify;\">（1）此题为，课本103页，例【4-2】，补充说明：</p>\n<p style=\"margin-left:0;text-align:justify;\">测边精度：0mm+15ppm;详情如下图13</p>\n<p style=\"margin-left:0;text-align:justify;\"><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5Y-q5Yeh,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\73c0106763db4faa978ecbb4c8372ba1.png\"/></p>\n<p style=\"margin-left:0px;text-align:center;\">图13 例【4-2】图</p>\n<p style=\"margin-left:0px;\">（2）编写Data.txt数据。</p>\n<p style=\"text-align:center;\"><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5Y-q5Yeh,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\f07507aa407b4d8488c87d99cee8a404.png\"/></p>\n<p style=\"margin-left:0px;text-align:center;\">图14 例【4-2】Data.txt数据</p>\n<p style=\"margin-left:0;text-align:justify;\">（3）将数据文档命名为“Data.txt”放置于平差程序项目路径下。然后开始运行。运行结果如下图15：</p>\n<p style=\"margin-left:0;text-align:center;\"><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5Y-q5Yeh,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\00021fb6669b4e1f9d80e41465300938.png\"/></p>\n<p style=\"text-align:center;\">图15 控制台运行窗口结果</p>\n<p style=\"margin-left:0;text-align:justify;\">（4）提示运行成功后，查看项目路径下PutData.txt文件，查看平差结果。本例题结果如下图16。</p>\n<p style=\"margin-left:0;text-align:center;\"><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5Y-q5Yeh,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\1b8e03f4d8304d078a2fa33c12b75afe.png\"/></p>\n<p style=\"margin-left:0;text-align:center;\">图16 例【4-2】平差数据PutData.txt</p>\n<p style=\"margin-left:0;text-align:justify;\">参考课本上结果，平差结果成果，且数据比对相同，正确。</p>\n<h2 style=\"margin-left:0;text-align:justify;\">5.2例题二</h2>\n<p style=\"margin-left:0;text-align:justify;\">（1）此题为，课本139页，例【5-3】。</p>\n<p style=\"margin-left:0;text-align:justify;\"><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5Y-q5Yeh,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\c205caae8afe4eefbe4fdbcebd434123.png\"/></p>\n<p style=\"margin-left:0;text-align:justify;\">网形详情如下图17：</p>\n<p style=\"margin-left:0;text-align:center;\"><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5Y-q5Yeh,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\077bf33a7e73451eb1cb6f513402b21c.png\"/></p>\n<p style=\"margin-left:0;text-align:center;\">图17 例题二网形图</p>\n<p style=\"margin-left:0;text-align:justify;\">（2）编写Data.txt数据</p>\n<p style=\"margin-left:0;text-align:center;\"><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5Y-q5Yeh,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\7382acb8249946f5935edc0876b7e044.png\"/></p>\n<p style=\"margin-left:0;text-align:center;\">图18 例题二Data.txt数据</p>\n<p style=\"margin-left:0;text-align:justify;\">（3）将数据文档命名为“Data.txt”放置于平差程序项目路径下。然后开始运行。运行结果如下图19：</p>\n<p style=\"text-align:center;\"><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5Y-q5Yeh,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\dabcea2fca3743e7ab38d180ce6382be.png\"/></p>\n<p style=\"margin-left:0;text-align:center;\">图19 运行结果</p>\n<p style=\"margin-left:0;text-align:justify;\">（4）提示运行成功后，查看项目路径下PutData.txt文件，查看平差结果。本例题二结果如下图20。</p>\n<p style=\"text-align:center;\"><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5Y-q5Yeh,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\b9411221374c473c8b3d98bc903aae42.png\"/></p>\n<p style=\"margin-left:0px;text-align:center;\">图20 例题二平差数据PutData.txt</p>\n<p style=\"margin-left:0;text-align:justify;\">参考课本上结果，平差结果成果，且数据比对相同，正确。</p>\n<h2 style=\"margin-left:0;text-align:justify;\">5.3例题三</h2>\n<p style=\"margin-left:0;text-align:justify;\">（1）此题为课本245页，第四题。</p>\n<p style=\"margin-left:0;text-align:justify;\"><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5Y-q5Yeh,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\be317d2ff3c64342ad65c93e4d03d4e0.png\"/></p>\n<p style=\"margin-left:0;text-align:center;\">图21 例题三网型</p>\n<p style=\"margin-left:0;text-align:justify;\">已知点为A、B、C、D、E、F共6个，未知点编号7，8,9,10·······17，18共12个，观测了14条边长S1～S14，观测了16个转角β1～β16，测角精度10″，测边精度1.0<em>*</em><img alt=\"23c5eb4bca5d4e83a4d5769445da5dc6.png\" src=\"image\\23c5eb4bca5d4e83a4d5769445da5dc6.png\"/> /mm。</p>\n<p style=\"margin-left:0;text-align:justify;\">可见，此题的测边精度指标不是光电测距仪精度指标Amm+Bppm形式;仅需要在程序中简单修改以下权矩阵P中的边长的权即可。</p>\n<p style=\"margin-left:0;text-align:justify;\">以下是测边精度指标为Amm+Bppm时的计算P矩阵代码：</p>\n<p style=\"margin-left:0;text-align:left;\">void Ajust::DoForP()//定权矩阵P</p>\n<p style=\"margin-left:0;text-align:left;\">{<!-- --></p>\n<p style=\"margin-left:0;text-align:left;\">    double P_distance;//观测边的权</p>\n<p style=\"margin-left:0;text-align:left;\">double P_angle;//观测角的权</p>\n<p style=\"margin-left:0;text-align:left;\">//设置权阵P大小并初始化为0</p>\n<p style=\"margin-left:0;text-align:left;\">    P.setZero(Num_Distance+Num_Angle,Num_Distance+Num_Angle);</p>\n<p style=\"margin-left:0;text-align:left;\">    for(int i=0;i&lt;Num_Distance;i++)</p>\n<p style=\"margin-left:0;text-align:left;\">{<!-- --></p>\n<p style=\"margin-left:0;text-align:left;\">//对应边中误差</p>\n<p style=\"margin-left:0;text-align:left;\">double delta=Pre_Distance_A+Pre_Distance_B*0.001*Distance_Obs(i,1);</p>\n<p style=\"margin-left:0;text-align:left;\">P_distance=pow(Pre_Angle,2)/pow(delta,2);</p>\n<p style=\"margin-left:0;text-align:left;\">P(i,i)=P_distance;</p>\n<p style=\"margin-left:0;text-align:left;\">    }</p>\n<p style=\"margin-left:0;text-align:left;\">    for(int j=0;j&lt;Num_Angle;j++)</p>\n<p style=\"margin-left:0;text-align:left;\">    {<!-- --></p>\n<p style=\"margin-left:0;text-align:left;\">P_angle=1;//取角度观测精度Pre_Angle为验前单位权中误差</p>\n<p style=\"margin-left:0;text-align:left;\">P(j+Num_Distance,j+Num_Distance)=P_angle;</p>\n<p style=\"margin-left:0;text-align:left;\">}</p>\n<p style=\"margin-left:0;text-align:left;\">}</p>\n<p style=\"margin-left:0;text-align:justify;\">测边精度 1.0<em>*</em><img alt=\"23c5eb4bca5d4e83a4d5769445da5dc6.png\" src=\"image\\23c5eb4bca5d4e83a4d5769445da5dc6.png\"/> /mm，只需要更改定权时对应边中误差的计算方法即可。</p>\n<p style=\"margin-left:0;text-align:justify;\">将原来计算语句：</p>\n<p style=\"margin-left:0;text-align:justify;\">double delta=Pre_Distance_A+Pre_Distance_B*0.001*Distance_Obs(i,1)；</p>\n<p style=\"margin-left:0;text-align:justify;\"><strong>改为新的计算语句：</strong></p>\n<p style=\"margin-left:0;text-align:justify;\">double delta=sqrt(Distance_Obs(i,1))；</p>\n<p style=\"margin-left:0;text-align:justify;\">当测边精度指标为 1.0<em>*</em><img alt=\"23c5eb4bca5d4e83a4d5769445da5dc6.png\" src=\"image\\23c5eb4bca5d4e83a4d5769445da5dc6.png\"/> /mm时，权矩阵P的计算代码更改后如下：</p>\n<p style=\"margin-left:0;text-align:left;\">void Ajust::DoForP()//定权矩阵P</p>\n<p style=\"margin-left:0;text-align:left;\">{<!-- --></p>\n<p style=\"margin-left:0;text-align:left;\">    double P_distance;//观测边的权</p>\n<p style=\"margin-left:0;text-align:left;\">double P_angle;//观测角的权</p>\n<p style=\"margin-left:0;text-align:left;\">//设置权阵P大小并初始化为0</p>\n<p style=\"margin-left:0;text-align:left;\">    P.setZero(Num_Distance+Num_Angle,Num_Distance+Num_Angle);</p>\n<p style=\"margin-left:0;text-align:left;\">    for(int i=0;i&lt;Num_Distance;i++)</p>\n<p style=\"margin-left:0;text-align:left;\">{<!-- --></p>\n<p style=\"margin-left:0;text-align:left;\">//对应边中误差</p>\n<p style=\"margin-left:0;text-align:left;\">double delta=sqrt（Distance_Obs(i,1)）;</p>\n<p style=\"margin-left:0;text-align:left;\">P_distance=pow(Pre_Angle,2)/pow(delta,2);</p>\n<p style=\"margin-left:0;text-align:left;\">P(i,i)=P_distance;</p>\n<p style=\"margin-left:0;text-align:left;\">    }</p>\n<p style=\"margin-left:0;text-align:left;\">    for(int j=0;j&lt;Num_Angle;j++)</p>\n<p style=\"margin-left:0;text-align:left;\">    {<!-- --></p>\n<p style=\"margin-left:0;text-align:left;\">P_angle=1;//取角度观测精度Pre_Angle为验前单位权中误差</p>\n<p style=\"margin-left:0;text-align:left;\">P(j+Num_Distance,j+Num_Distance)=P_angle;</p>\n<p style=\"margin-left:0;text-align:left;\">}</p>\n<p style=\"margin-left:0;text-align:left;\">}</p>\n<p style=\"margin-left:0;text-align:justify;\"></p>\n<p style=\"margin-left:0;text-align:justify;\">（2）编写Data.txt数据 </p>\n<p style=\"text-align:center;\"><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5Y-q5Yeh,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\5f175dee5f7b47e481e2269e1c5d39c6.png\"/></p>\n<p style=\"margin-left:0;text-align:center;\">图22 例题三Data.txt数据</p>\n<p style=\"margin-left:0;text-align:justify;\">（3）将数据文档命名为“Data.txt”放置于平差程序项目路径下。然后开始运行。运行结果如下图23：</p>\n<p style=\"margin-left:0;text-align:center;\"><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5Y-q5Yeh,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\d9f560749aab46bfab508da87b351e5c.png\"/></p>\n<p style=\"margin-left:0;text-align:center;\">图23 例题三运行结果</p>\n<p>（4）提示运行成功后，查看项目路径下PutData.txt文件，查看平差结果。本例题二结果如下图24。</p>\n<p style=\"text-align:center;\"><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5Y-q5Yeh,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\06df894b764e40b4b818957f5688dcf3.png\"/></p>\n<p style=\"text-align:center;\"><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5Y-q5Yeh,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\83806795d34349c882abab445ad57841.png\"/></p>\n<p style=\"text-align:center;\"><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5Y-q5Yeh,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\31a8827d97d24b078478e4bc4df4d3aa.png\"/></p>\n<p style=\"text-align:center;\">图24 例题三平差PutData.txt数据</p>\n<p></p>\n<h1 style=\"margin-left:0;text-align:justify;\">六、总结</h1>\n<h2 style=\"margin-left:0;text-align:justify;\">6.1开发日志</h2>\n<p style=\"margin-left:0;text-align:justify;\"></p>\n<h2 style=\"margin-left:0;text-align:justify;\">6.2感想</h2>\n<p style=\"margin-left:0;text-align:justify;\">理论出真理，实践长才干。虽然这次课设目标勉强算是完成了，但这并不是学习的止步。通过这次课设，重拾了编程，体会到了程序化应用的优势，之后也会继续更深入的学习。</p>\n<h1 style=\"margin-left:0px;text-align:justify;\">七、附录（源代码）</h1>\n<h2 style=\"margin-left:0;text-align:justify;\">7.1项目工程管理文件day1.pro</h2>\n<p style=\"margin-left:0;text-align:left;\">QT += core</p>\n<p style=\"margin-left:0;text-align:left;\">QT -= gui</p>\n<p style=\"margin-left:0;text-align:left;\">INCLUDEPATH +=F:Eigen3.4.0</p>\n<p style=\"margin-left:0;text-align:left;\">CONFIG += c++11</p>\n<p style=\"margin-left:0;text-align:left;\">TARGET = day1</p>\n<p style=\"margin-left:0;text-align:left;\">CONFIG += console</p>\n<p style=\"margin-left:0;text-align:left;\">CONFIG -= app_bundle</p>\n<p style=\"margin-left:0;text-align:left;\">TEMPLATE = app</p>\n<p style=\"margin-left:0;text-align:left;\">SOURCES += main.cpp</p>\n<p style=\"margin-left:0;text-align:left;\">    anglechange.cpp</p>\n<p style=\"margin-left:0;text-align:left;\">    x0y0.cpp</p>\n<p style=\"margin-left:0;text-align:left;\">    ajust.cpp</p>\n<p style=\"margin-left:0;text-align:left;\">    indata.cpp</p>\n<p style=\"margin-left:0;text-align:left;\">    outdata.cpp</p>\n<p style=\"margin-left:0;text-align:left;\"># The following define makes your compiler emit warnings if you use</p>\n<p style=\"margin-left:0;text-align:left;\"># any feature of Qt which as been marked deprecated (the exact warnings</p>\n<p style=\"margin-left:0;text-align:left;\"># depend on your compiler). Please consult the documentation of the</p>\n<p style=\"margin-left:0;text-align:left;\"># deprecated API in order to know how to port your code away from it.</p>\n<p style=\"margin-left:0;text-align:left;\">DEFINES += QT_DEPRECATED_WARNINGS</p>\n<p style=\"margin-left:0;text-align:left;\"># You can also make your code fail to compile if you use deprecated APIs.</p>\n<p style=\"margin-left:0;text-align:left;\"># In order to do so, uncomment the following line.</p>\n<p style=\"margin-left:0;text-align:left;\"># You can also select to disable deprecated APIs only up to a certain version of Qt.</p>\n<p style=\"margin-left:0;text-align:left;\">#DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0x060000    # disables all the APIs deprecated before Qt 6.0.0</p>\n<p style=\"margin-left:0;text-align:left;\">HEADERS +=</p>\n<p style=\"margin-left:0;text-align:left;\">    anglechange.h</p>\n<p style=\"margin-left:0;text-align:left;\">    x0y0.h</p>\n<p style=\"margin-left:0;text-align:left;\">    ajust.h</p>\n<p style=\"margin-left:0;text-align:left;\">    indata.h</p>\n<p style=\"margin-left:0;text-align:left;\">    outdata.h</p>\n<p style=\"margin-left:0;text-align:left;\">。具体代码及配置调试可留言交流。</p>\n<p></p>\n</div>\n</div>"}