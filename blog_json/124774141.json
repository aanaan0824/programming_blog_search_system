{"blogid": "124774141", "writerAge": "码龄1年", "writerBlogNum": "129", "writerCollect": "479", "writerComment": "49", "writerFan": "169", "writerGrade": "4级", "writerIntegral": "1526", "writerName": "sermonlizhi", "writerProfileAdress": "writer_image\\profile_124774141.jpg", "writerRankTotal": "29648", "writerRankWeekly": "38520", "writerThumb": "176", "writerVisitNum": "111678", "blog_read_count": "10129", "blog_time": "于 2022-05-14 21:16:34 发布", "blog_title": "JVM内存模型", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-light\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p>Java在诞生之初就提出了<code>\"Write once，Run Anywhere\"</code>的口号，而这些都得益于JVM(Java Vritual Machine)，可以提前在不同的运行环境(linux或windows等)上安装JDK之后，就可以让同一份代码在任何地方运行了。而这里的JDK(Java Development Kit)是Java语言、Java虚拟机和Java类库的统称。</p>\n<h2><a id=\"JDKJava_2\"></a>一、JDK体系结构与Java跨平台特性</h2>\n<h3><a id=\"11_JDK_4\"></a>1.1 JDK体系结构</h3>\n<p>JDK是一个非常庞大的体系，里面包含了JVM、Java SE API(核心类库)、常用工具(javac等)以及Java语言等等一系列内容，其具体的体系结构图如下所示：</p>\n<img src=\"image\\50511850f7494023ba28d0049bb87014.png\" width=\"80%;\"/>\n<h3><a id=\"12_Java_10\"></a>1.2 Java跨平台特性</h3>\n<p>Java的跨语言特性在文章开始已经提过了，通过在不同系统安装对应的JDK(主要是JVM)版本就可以实现，大概如下图所示：</p>\n<img src=\"image\\f3aad1053e78482cbd2989925fd10b07.png\" width=\"50%;\"/>\n<h2><a id=\"JVM_16\"></a>二、JVM整体结构与内存模型</h2>\n<h3><a id=\"21_JVM_18\"></a>2.1 JVM整体结构</h3>\n<p>JVM称为Java虚拟机，作为一个虚拟机它首要的功能就是对应用程序的线程等分配内存空间，而JVM还要负责加载类、解析执行编译后的字节码文件，所以整个JVM主要就包含了运行时数据区、类加载子系统和字节码执行引擎。</p>\n<p>大概的结构如下图所示：<br/> <img src=\"image\\3e608324602f4457b14f4adbeb07d15c.png\" width=\"50%;\"/><br/> 在Java虚拟机外部，还有一些本地方法接口，这些接口也是JVM经常需要调用。</p>\n<h3><a id=\"22__26\"></a>2.2 内存模型</h3>\n<p>Java虚拟机的运行时数据区显然是在内存中的，所以这一部分也成为JVM的内存模型，这里要与JMM(Java内存模型)区分开。</p>\n<p>内存模型主要包含五部分的内容：堆、栈、本地方法栈、方法区(元空间)、程序计数器。</p>\n<p><strong>堆</strong>：JVM管理的最大一块内存空间，它是所有线程所共享的一块区域。在虚拟机启动的时候创建，该区域的唯一目的就是为了存放对象实例，<strong>几乎</strong>所有通过<code>new</code>创建的实例对象都会被分配在该区域。</p>\n<p><strong>栈(虚拟机栈)</strong>：也可以称为虚拟机线程栈，它是JVM中每个线程所私有的一块空间，每个线程都会有这么一块空间。它的生命周期是与线程的生命周期是绑定的。虚拟机栈描述了Java中方法执行时的内存模型，即每个方法被执行的时候，线程都会在自己的线程栈中同步创建一个栈帧(Stack Frame)，用于存放局部变量表、操作数栈、动态连接和方法出口等信息，每个方法从调用到完成的过程，就对应着一个栈帧在线程栈中从入栈到出栈的过程。</p>\n<p><strong>本地方法栈</strong>：本地方法栈与虚拟机栈的作用是相似，不同的是虚拟机栈为JVM执行的Java方法服务，而本地方法栈为JVM调用的本地方法服务。HotSpot虚拟机直接把本地方法栈和虚拟机栈合二为一。</p>\n<p><strong>程序计数器</strong>：只需要占用一小块的内存空间，每个线程都会有自己独立的程序计数器，主要功能就是记录当前线程执行到哪一行指令了，可以看作是当前线程所执行的字节码行号指示器。</p>\n<p><strong>方法区(元空间)</strong>：在JDK 8之前，方法区也称之为永久代，这部分区域与堆一样，是所有线程所共享的，它主要用于存放被虚拟机加载的类型信息、常量、静态变量以及即时编译器编译后的代码缓存等数据。对于一个Class文件，除了版本、字段、方法、接口等描述信息外，还有常量池表，在上一篇文章<a href=\"https://blog.csdn.net/sermonlizhi/article/details/124765843?spm=1001.2014.3001.5501\">《JVM类加载机制》</a>中提到过，主要用于编译器生成的各种字面量和符号引用，而这部分内容在Class文件加载后是存放在方法区的运行时常量池中。这个运行时常量池自然还包括了字符串常量池，但需要注意的是，<strong>在JDK 7以后的版本中，字符串常量池和静态变量等被移至到了Java堆区，而到了JDK 8，抛弃了之前永久代的概念，通过在本地内存中实现了元空间(Meta-space)来代替永久代，并把JDK 7中永久代剩余内容(主要是类型信息)全部移至到了元空间</strong>。</p>\n<p>所以，方法区是使用直接内存来实现，这与堆是不一样的，也就是堆和方法区用的并不是同一块物理内存。</p>\n<p><strong>直接内存</strong>：直接内存并不是JVM运行时数据区的一部分，其分配不会受Java堆大小的限制。</p>\n<p>下面以一个列子来演示JVM内存模型的各个部分，创建一个测试类如下：</p>\n<pre><code class=\"prism language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Test</span> <span class=\"token punctuation\">{<!-- --></span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">compute</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> b <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> c <span class=\"token operator\">=</span> a <span class=\"token operator\">*</span> b <span class=\"token operator\">*</span> <span class=\"token number\">6</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> c<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token class-name\">Test</span> test <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Test</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> compute <span class=\"token operator\">=</span> test<span class=\"token punctuation\">.</span><span class=\"token function\">compute</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>compute<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>将Test类编译之后，然后在控制台通过<code>javap -c Test.class</code>命令输出Class文件对应的字节码指令，下面主要分析<code>compute()</code>方法的字节码指令，结合JVM的内存模型。</p>\n<pre><code class=\"prism language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">compute</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token class-name\">Code</span><span class=\"token operator\">:</span>\n        <span class=\"token number\">0</span><span class=\"token operator\">:</span> iconst_4\n        <span class=\"token number\">1</span><span class=\"token operator\">:</span> istore_1\n        <span class=\"token number\">2</span><span class=\"token operator\">:</span> iconst_5\n        <span class=\"token number\">3</span><span class=\"token operator\">:</span> istore_2\n        <span class=\"token number\">4</span><span class=\"token operator\">:</span> iload_1\n        <span class=\"token number\">5</span><span class=\"token operator\">:</span> iload_2\n        <span class=\"token number\">6</span><span class=\"token operator\">:</span> imul\n        <span class=\"token number\">7</span><span class=\"token operator\">:</span> bipush        <span class=\"token number\">6</span>\n        <span class=\"token number\">9</span><span class=\"token operator\">:</span> imul\n</code></pre>\n<p>下面是执行Test的main方法时，线程栈的模型，下面结合下面的模型和字节码指令来介绍运行时数据区的各个模块。<br/> <img alt=\"在这里插入图片描述\" src=\"image\\263dd3cd02bb497cb6b6dfc4055e3bd1.png\"/></p>\n<p>当执行Test类的main方法时，首先会将<code>Test.class</code>文件加载进JVM的方法区，主要有常量池和方法定义，而常量池中此时包含一个<code>compute()</code>的符号引用，而在执行main方法，当调用<code>compute()</code>方法时，会将<code>compute()</code>的符号引用变成该方法具体在方法区的内存地址(直接引用)，因为这个过程是在程序运行时发生的，所以称为<strong>动态链接</strong>。</p>\n<p>在执行<code>main()</code>和<code>compute()</code>方法时会分别在main线程栈中创建两个栈帧，因为<code>main()</code>先调用，所以其栈帧处于栈的底部。</p>\n<p>通过<code>compute()</code>内存地址找到该方法包含的字节码指令就可以执行<code>compute()</code>方法了。</p>\n<p>1、<code>iconst_4</code>表示将int类型数值4压入操作数栈中，此时<code>compute()</code>栈帧中的操作数栈中就只有一个数字4</p>\n<p>2、<code>istore_1</code>表示将操作数栈顶的int类型数值放入到局部变量表的第二个槽位中(出栈)，此时操作数栈就没有元素了。</p>\n<p>​ <strong>注：局部变量表中，是以槽位为基本单位来存储数值，第一个槽位的索引下标为0，且存放的局部变量为当this引用</strong></p>\n<p>3、<code>iconst_5</code>表示将int类型数值5压入操作数栈中</p>\n<p>4、<code>istore_2</code>表示将操作数栈顶的int类型数值放入到局部变量表的第三个槽位中</p>\n<p>5、<code>iload_1</code>表示将局部变量表的第二个槽位中int类型的数值放入到操作数栈的栈顶</p>\n<p>6、<code>iload_2</code>表示将局部变量表的第三个槽位中int类型的数值放入到操作数栈的栈顶</p>\n<p>7、<code>imul</code>表示将操作数栈的元素全部出栈交给CPU进行乘法运算，然后再将运算结果压入操作数栈的栈顶</p>\n<p>​ <strong>第七步完成后，此时操作数栈里面的数值只有一个20</strong></p>\n<p>8、<code>bipush 6</code>表示将单字节常量6放入到操作数栈的栈顶</p>\n<p>9、<code>imul</code>将操作数栈中的int类型的元素20和6出栈交给CPU进行乘法运算，然后将计算结果120压入操作数栈的栈顶</p>\n<p>10、<code>istore_3</code>表示将操作数栈顶的int类型数值放入到局部变量表的第四个槽位中</p>\n<p>11、<code>iload_3</code>表示将局部变量表的第四个槽位中int类型的数值放入到操作数栈的栈顶</p>\n<p>12、<code>ireturn</code>表示从当前方法返回int类型的数值，即操作数栈中的数值。</p>\n<p>至此<code>compute()</code>方法就执行完成了，执行完之后，需要知道将返回到哪里去继续执行，这就是方法出口的作用，它会记录方法执行完之后，跳转到哪里。</p>\n<p><strong>注：对于这些常用的字节码指令可以参考周志明的《深入理解Java虚拟机》</strong></p>\n<h2><a id=\"JVM_126\"></a>三、JVM内存参数</h2>\n<p>JVM内存模型中的这些区域，都是有大小限制的，当然也可以通过JVM提供的参数来设置这些区域所占内存的大小。</p>\n<img src=\"image\\d34b47fba7cb4a5ca73a9daff7345578.png\" width=\"50%;\"/>\n<p><strong>补充：在JVM堆中的实例对象，会按照它们的年龄或大小分为新生代或老年代，而新生代的内存空间又分为Eden区和Survivor区，如下图所示：</strong></p>\n<img src=\"image\\feb615ca6159412f80c100c6eca79fe6.png\" width=\"50%;\"/>\n<p>至于为什么要这样划分内存空间，会在下篇文章介绍JVM的垃圾收集机制时详细介绍。</p>\n<p>下面介绍这些常用参数的含义：</p>\n<p><strong>-Xss</strong>：表示每个线程栈的大小</p>\n<p><strong>-Xms</strong>：表示堆空间的初始可用大小，默认为物理内存的1/64</p>\n<p><strong>-Xmx</strong>：表示堆空间的最大可以大小，默认为物理内存的1/4(<strong>这个参数在应用程序中是一定要指定的</strong>)</p>\n<p><strong>-Xmn</strong>：表示新生代(年轻代)的大小</p>\n<p><strong>-XX:NewRatio</strong>：默认为2，表示新生代占年老代的1/2，占整个堆内存的1/3。</p>\n<p><strong>-XX:SurvivorRatio</strong>：默认为8，表示一个survivor区占用1/8的Eden内存，即1/10的新生代内存。</p>\n<p><strong>-XX:MaxMetaspaceSize</strong>： 设置元空间最大值， 默认是-<code>1</code>， 即不限制， 或者说只受限于本地内存大小。</p>\n<p><strong>-XX:MetaspaceSize</strong>： 指定元空间触发<code>Full Gc</code>的初始阈值(元空间无固定初始大小)， 以字节为单位，默认是21M左右，达到该值就会触发<code>full gc</code>进行类型卸载， 同时收集器会对该值进行调整： 如果释放了大量的空间， 就适当降低该值； 如果释放了很少的空间， 那么在不超过<code>-XX：MaxMetaspaceSize</code>（如果设置了的话） 的情况下， 适当提高该值。</p>\n<p>由于调整元空间的大小需要Full GC，这是非常昂贵的操作，如果应用在启动的时候发生大量Full GC，通常都是由于永久代或元空间发生了大小调整，基于这种情况，一般建议在JVM参数中<strong>将MetaspaceSize和MaxMetaspaceSize设置成一样的值</strong>，并设置得比初始值要大，对于8G物理内存的机器来说，一般推荐将这两个值都设置为256M。</p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}