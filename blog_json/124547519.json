{"blogid": "124547519", "writerAge": "码龄5年", "writerBlogNum": "5", "writerCollect": "116", "writerComment": "131", "writerFan": "186", "writerGrade": "2级", "writerIntegral": "375", "writerName": "一个不同的ID", "writerProfileAdress": "writer_image\\profile_124547519.jpg", "writerRankTotal": "76697", "writerRankWeekly": "960347", "writerThumb": "102", "writerVisitNum": "16616", "blog_read_count": "1370", "blog_time": "于 2022-05-03 07:00:00 发布", "blog_title": "C++ Opencv之3D透视变换", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h2 id=\"%E5%89%8D%E8%A8%80%3A\">前言:</h2>\n<p>各位小伙伴们是不是经常出现拍摄角度不佳,看着特别难受,想把图片中的某个物体翻转一下呢?</p>\n<p>本文就以下面这本书为例,只需要鼠标按照顺时针点击书的四个脚就可以完成变换:</p>\n<figure class=\"image\">\n<img alt=\"\" height=\"1200\" src=\"image\\2e11e72e359c441b85b9e9c56108bbf3.png\" width=\"1200\"/>\n<figcaption>\n  侧着看好难受哦,想看正面怎么办?\n </figcaption>\n</figure>\n<p>效果:</p>\n<figure class=\"image\">\n<img alt=\"\" height=\"1002\" src=\"image\\4a62c5d441a0404995eb52848b2e0899.png\" width=\"1200\"/>\n<figcaption>\n  舒服了!!!\n </figcaption>\n</figure>\n<p></p>\n<p><img alt=\"\" height=\"504\" src=\"image\\b4ec684ba4ac4a21a977461467681fd8.png\" width=\"535\"/></p>\n<p></p>\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E6%B5%81%E7%A8%8B%E8%AE%B2%E8%A7%A3%3A-toc\" style=\"margin-left:40px;\"><a href=\"#%E6%B5%81%E7%A8%8B%E8%AE%B2%E8%A7%A3%3A\">流程讲解:</a></p>\n<p id=\"1.%E5%85%88%E8%AF%BB%E5%8F%96%E4%B8%80%E4%B8%AA%E9%9C%80%E8%A6%813D%E9%80%8F%E8%A7%86%E5%8F%98%E6%8D%A2%E7%9A%84%E5%9B%BE%E7%89%87%2C%E5%B9%B6%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAMAT%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%9B%BE%E7%89%87%E5%8F%98%E9%87%8F%2C%E7%94%A8%E6%9D%A5%E8%A3%85%E5%A4%84%E7%90%86%E5%90%8E%E7%9A%84%E5%9B%BE%E7%89%87-toc\" style=\"margin-left:80px;\"><a href=\"#1.%E5%85%88%E8%AF%BB%E5%8F%96%E4%B8%80%E4%B8%AA%E9%9C%80%E8%A6%813D%E9%80%8F%E8%A7%86%E5%8F%98%E6%8D%A2%E7%9A%84%E5%9B%BE%E7%89%87%2C%E5%B9%B6%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAMAT%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%9B%BE%E7%89%87%E5%8F%98%E9%87%8F%2C%E7%94%A8%E6%9D%A5%E8%A3%85%E5%A4%84%E7%90%86%E5%90%8E%E7%9A%84%E5%9B%BE%E7%89%87\">1.先读取一个需要3D透视变换的图片,并创建一个MAT类型的图片变量,用来装处理后的图片</a></p>\n<p id=\"2.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%90%91%E9%87%8F%2C%E7%94%A8%E6%9D%A5%E5%AD%98%E6%94%BE%E9%BC%A0%E6%A0%87%E7%82%B9%E5%87%BB%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%9D%90%E6%A0%87%E7%82%B9%E5%9C%A8%E5%A4%84%E7%90%86%E5%90%8E%E7%9A%84%E5%9B%BE%E7%89%87%E5%8F%98%E9%87%8F%E4%B8%AD%E7%9A%84%E4%BD%8D%E7%BD%AE-toc\" style=\"margin-left:80px;\"><a href=\"#2.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%90%91%E9%87%8F%2C%E7%94%A8%E6%9D%A5%E5%AD%98%E6%94%BE%E9%BC%A0%E6%A0%87%E7%82%B9%E5%87%BB%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%9D%90%E6%A0%87%E7%82%B9%E5%9C%A8%E5%A4%84%E7%90%86%E5%90%8E%E7%9A%84%E5%9B%BE%E7%89%87%E5%8F%98%E9%87%8F%E4%B8%AD%E7%9A%84%E4%BD%8D%E7%BD%AE\">2.创建一个向量,用来存放鼠标点击的四个坐标点在处理后的图片变量中的位置</a></p>\n<p id=\"3.%E7%94%B1%E4%BA%8E%E6%B6%89%E5%8F%8A%E5%88%B0%E9%BC%A0%E6%A0%87%E5%B7%A6%E9%94%AE%E7%82%B9%E5%87%BB%2C%E9%9C%80%E8%A6%81%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%BB%93%E6%9E%84%E4%BD%93-toc\" style=\"margin-left:80px;\"><a href=\"#3.%E7%94%B1%E4%BA%8E%E6%B6%89%E5%8F%8A%E5%88%B0%E9%BC%A0%E6%A0%87%E5%B7%A6%E9%94%AE%E7%82%B9%E5%87%BB%2C%E9%9C%80%E8%A6%81%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%BB%93%E6%9E%84%E4%BD%93\">3.由于涉及到鼠标左键点击,需要创建一个结构体</a></p>\n<p id=\"4.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%88%9A%E6%89%8D%E5%AE%9A%E4%B9%89%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%8C%E5%B9%B6%E5%B0%86%E8%AF%BB%E5%8F%96%E5%88%B0%E7%9A%84%E5%8E%9F%E5%9B%BE%E7%89%87%E7%9A%84%E5%9B%BE%E7%89%87%E5%8F%98%E9%87%8F%E4%BF%9D%E5%AD%98%E7%BB%99%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%8C%E5%B9%B6%E8%B0%83%E7%94%A8%E9%BC%A0%E6%A0%87%E7%82%B9%E5%87%BB%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:80px;\"><a href=\"#4.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%88%9A%E6%89%8D%E5%AE%9A%E4%B9%89%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%8C%E5%B9%B6%E5%B0%86%E8%AF%BB%E5%8F%96%E5%88%B0%E7%9A%84%E5%8E%9F%E5%9B%BE%E7%89%87%E7%9A%84%E5%9B%BE%E7%89%87%E5%8F%98%E9%87%8F%E4%BF%9D%E5%AD%98%E7%BB%99%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%8C%E5%B9%B6%E8%B0%83%E7%94%A8%E9%BC%A0%E6%A0%87%E7%82%B9%E5%87%BB%E5%87%BD%E6%95%B0\">4.创建一个刚才定义的结构体，并将读取到的原图片的图片变量保存给结构体，并调用鼠标点击函数</a></p>\n<p id=\"5.%E6%8A%8A%E7%82%B9%E5%87%BB%E7%9A%84%E4%BD%8D%E7%BD%AE%E4%B8%A2%E7%BB%99%E8%AE%A1%E7%AE%97%E5%87%BD%E6%95%B0%EF%BC%8C%E8%AE%A9%E5%85%B6%E4%BD%BF%E7%94%A8RANSAC%E7%AE%97%E6%B3%95%EF%BC%8C%E5%BE%97%E5%87%BA%E8%AE%A1%E7%AE%97%E7%BB%93%E6%9E%9C-toc\" style=\"margin-left:80px;\"><a href=\"#5.%E6%8A%8A%E7%82%B9%E5%87%BB%E7%9A%84%E4%BD%8D%E7%BD%AE%E4%B8%A2%E7%BB%99%E8%AE%A1%E7%AE%97%E5%87%BD%E6%95%B0%EF%BC%8C%E8%AE%A9%E5%85%B6%E4%BD%BF%E7%94%A8RANSAC%E7%AE%97%E6%B3%95%EF%BC%8C%E5%BE%97%E5%87%BA%E8%AE%A1%E7%AE%97%E7%BB%93%E6%9E%9C\">5.把点击的位置丢给计算函数，让其使用RANSAC算法，得出计算结果</a></p>\n<p id=\"6.%E7%BB%93%E6%9E%9C%E8%BD%AC%E6%8D%A2%EF%BC%8C%E5%B9%B6%E5%B0%86%E7%BB%93%E6%9E%9C%E6%98%BE%E7%A4%BA-toc\" style=\"margin-left:80px;\"><a href=\"#6.%E7%BB%93%E6%9E%9C%E8%BD%AC%E6%8D%A2%EF%BC%8C%E5%B9%B6%E5%B0%86%E7%BB%93%E6%9E%9C%E6%98%BE%E7%A4%BA\">6.结果转换，并将结果显示</a></p>\n<p id=\"7.%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%EF%BC%9A-toc\" style=\"margin-left:80px;\"><a href=\"#7.%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%EF%BC%9A\">7.如何使用：</a></p>\n<p id=\"%E6%89%80%E6%9C%89%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%9A-toc\" style=\"margin-left:40px;\"><a href=\"#%E6%89%80%E6%9C%89%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%9A\">所有的代码：</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h2 id=\"%E6%B5%81%E7%A8%8B%E8%AE%B2%E8%A7%A3%3A\">流程讲解:</h2>\n<h3 id=\"1.%E5%85%88%E8%AF%BB%E5%8F%96%E4%B8%80%E4%B8%AA%E9%9C%80%E8%A6%813D%E9%80%8F%E8%A7%86%E5%8F%98%E6%8D%A2%E7%9A%84%E5%9B%BE%E7%89%87%2C%E5%B9%B6%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAMAT%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%9B%BE%E7%89%87%E5%8F%98%E9%87%8F%2C%E7%94%A8%E6%9D%A5%E8%A3%85%E5%A4%84%E7%90%86%E5%90%8E%E7%9A%84%E5%9B%BE%E7%89%87\">1.先读取一个需要3D透视变换的图片,并创建一个MAT类型的图片变量,用来装处理后的图片</h3>\n<pre><code class=\"language-cpp\">    Mat image=imread(\"D:/Qt_Opencv_Project/book1.png\");\n    Mat result=Mat::zeros(400,500,CV_8UC1);//400*500的大小,但是里面没有东西</code></pre>\n<h3 id=\"2.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%90%91%E9%87%8F%2C%E7%94%A8%E6%9D%A5%E5%AD%98%E6%94%BE%E9%BC%A0%E6%A0%87%E7%82%B9%E5%87%BB%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%9D%90%E6%A0%87%E7%82%B9%E5%9C%A8%E5%A4%84%E7%90%86%E5%90%8E%E7%9A%84%E5%9B%BE%E7%89%87%E5%8F%98%E9%87%8F%E4%B8%AD%E7%9A%84%E4%BD%8D%E7%BD%AE\">2.创建一个向量,用来存放鼠标点击的四个坐标点在处理后的图片变量中的位置</h3>\n<p>听着可能有点乱，但是没事，往下看就懂了，顺便show一下原图片，方便后续的鼠标操作</p>\n<pre><code class=\"language-cpp\">    vector &lt;Point2f&gt;obj;\n    obj.push_back(Point2f(0,0));\n    obj.push_back(Point2f(500,0));\n    obj.push_back(Point2f(500,400));\n    obj.push_back(Point2f(0,400));//转换后的坐标\n    imshow(\"image\",image);</code></pre>\n<h3 id=\"3.%E7%94%B1%E4%BA%8E%E6%B6%89%E5%8F%8A%E5%88%B0%E9%BC%A0%E6%A0%87%E5%B7%A6%E9%94%AE%E7%82%B9%E5%87%BB%2C%E9%9C%80%E8%A6%81%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%BB%93%E6%9E%84%E4%BD%93\">3.由于涉及到鼠标左键点击,需要创建一个结构体</h3>\n<p>结构体中需要有一个放原图片（方便点击产生的小点能直接显示在图片上，看起来比较直观）,另一个存放鼠标点击的坐标点</p>\n<pre><code class=\"language-cpp\">struct imagedata\n{\n    Mat img;\n    vector &lt;Point2f&gt; points;\n};</code></pre>\n<h3 id=\"4.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%88%9A%E6%89%8D%E5%AE%9A%E4%B9%89%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%8C%E5%B9%B6%E5%B0%86%E8%AF%BB%E5%8F%96%E5%88%B0%E7%9A%84%E5%8E%9F%E5%9B%BE%E7%89%87%E7%9A%84%E5%9B%BE%E7%89%87%E5%8F%98%E9%87%8F%E4%BF%9D%E5%AD%98%E7%BB%99%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%8C%E5%B9%B6%E8%B0%83%E7%94%A8%E9%BC%A0%E6%A0%87%E7%82%B9%E5%87%BB%E5%87%BD%E6%95%B0\">4.创建一个刚才定义的结构体，并将读取到的原图片的图片变量保存给结构体，并调用鼠标点击函数</h3>\n<p>注意这个鼠标处理函数的参数为：</p>\n<p><em>窗口名   鼠标处理的回调函数  处理结果产生数据保存给哪个变量</em></p>\n<pre><code class=\"language-cpp\">    struct imagedata data;\n    data.img=image;\n    setMouseCallback(\"image\",mouseHundle,&amp;data);//鼠标处理的回调函数\n    waitKey(0);//按任意键关闭当前显示的窗口,显示下一个窗口</code></pre>\n<p>调用的回调函数：</p>\n<p><em>第一个参数为鼠标点击的命令</em></p>\n<p><em>第二、三个参数为点击的坐标</em></p>\n<p><em>第四个参数为标记（保留，本次没有使用到）</em></p>\n<p><em>第五个参数为传入的数据，将处理好的图片信息保存到这里，根据上面的代码,我们所传入的是一个第三点中自己创建的结构体</em></p>\n<p>此回调函数的内容:</p>\n<p>判断点击的是否为鼠标左键,如果是,则在点击位置画一个小红点,如果已经保存的小红点数目小于4个则保存小红点（为什么是4个？因为本文以书本为例，以书本的四个角来确定一本书在图片中的位置）</p>\n<pre><code class=\"language-cpp\">void mouseHundle(int event,int x,int y,int flag,void *per)\n{\n    struct imagedata * d=(struct imagedata*)per;//强转一下方便后面操作\n    if(event==EVENT_LBUTTONDOWN)\n    {//确定按下的是鼠标左键\n        //用圆形标记一下鼠标按下左键标记的位置\n        circle(d-&gt;img,Point(x,y),3,Scalar(0,0,255),3,CV_AA);//在图上标记,圆心为点击的位置\n        imshow(\"image\",d-&gt;img);//原窗口上显示\n        if(d-&gt;points.size()&lt;4)\n        {\n            d-&gt;points.push_back(Point2f(x,y));//把点击的点存起来\n        }\n    }\n}</code></pre>\n<h3 id=\"5.%E6%8A%8A%E7%82%B9%E5%87%BB%E7%9A%84%E4%BD%8D%E7%BD%AE%E4%B8%A2%E7%BB%99%E8%AE%A1%E7%AE%97%E5%87%BD%E6%95%B0%EF%BC%8C%E8%AE%A9%E5%85%B6%E4%BD%BF%E7%94%A8RANSAC%E7%AE%97%E6%B3%95%EF%BC%8C%E5%BE%97%E5%87%BA%E8%AE%A1%E7%AE%97%E7%BB%93%E6%9E%9C\">5.把点击的位置丢给计算函数，让其使用RANSAC算法，得出计算结果</h3>\n<p>作用：将四个鼠标点击的坐标及其框的内容，转换成刚才第二点中保存的结果图片的坐标</p>\n<p>函数参数：  <em>四个鼠标点击的坐标  需要转换的四个坐标  RANSAC算法的宏定义</em></p>\n<p>返回值：图片变量（可以理解成保存刚才那张图片处理的格式，在下一点中可以将原图以这个规则转换成结果图）</p>\n<pre><code class=\"language-cpp\">    Mat res=findHomography(data.points,obj,CV_RANSAC);  //利用RANSAC算法计算出来一个小矩阵</code></pre>\n<h3 id=\"6.%E7%BB%93%E6%9E%9C%E8%BD%AC%E6%8D%A2%EF%BC%8C%E5%B9%B6%E5%B0%86%E7%BB%93%E6%9E%9C%E6%98%BE%E7%A4%BA\">6.结果转换，并将结果显示</h3>\n<p>将原图按照上一点中得到的计算结果，进行转换</p>\n<p>参数：  原图   装效果图的图片变量  图片计算结果  装效果图的图片变量的大小</p>\n<pre><code class=\"language-cpp\">    warpPerspective(image,result,res,result.size());  //结果转换\n    imshow(\"result\",result);\n    waitKey(0);</code></pre>\n<h3 id=\"7.%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%EF%BC%9A\">7.如何使用：</h3>\n<p>导入图片以后，按照顺时针点击你想要3D变换的目标（比如本例是那本书）的四个角，然后按下任意键（别是关机键。。）结果就会跳出来啦！</p>\n<p><img alt=\"\" height=\"1000\" src=\"https://img-blog.csdnimg.cn/b2f6c74954e74c5684b742e80ddee110.gif\" width=\"1200\"/></p>\n<p></p>\n<h2 id=\"%E6%89%80%E6%9C%89%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%9A\">所有的代码：</h2>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;opencv2/opencv.hpp&gt;\nusing namespace cv;\nusing namespace std;\n\nstruct imagedata\n{\n    Mat img;\n    vector &lt;Point2f&gt; points;\n};\n\nvoid mouseHundle(int event,int x,int y,int flag,void *per)\n{\n    struct imagedata * d=(struct imagedata*)per;\n    if(event==EVENT_LBUTTONDOWN)\n    {//确定按下的是鼠标左键\n        //用圆形标记一下鼠标按下左键标记的位置\n        circle(d-&gt;img,Point(x,y),3,Scalar(0,0,255),3,CV_AA);//在图上标记,圆心为点击的位置\n        imshow(\"image\",d-&gt;img);//原窗口上显示\n        if(d-&gt;points.size()&lt;4)\n        {\n            d-&gt;points.push_back(Point2f(x,y));//把点击的点存起来\n        }\n    }\n}\n\nvoid example_1()\n{\n    Mat image=imread(\"D:/Qt_Opencv_Project/book1.png\");\n    Mat result=Mat::zeros(400,500,CV_8UC1);//400*500的大小,但是里面没有东西\n    //存放四个转换以后的坐标\n    vector &lt;Point2f&gt;obj;\n    obj.push_back(Point2f(0,0));\n    obj.push_back(Point2f(500,0));\n    obj.push_back(Point2f(500,400));\n    obj.push_back(Point2f(0,400));//转换后的坐标\n    imshow(\"image\",image);\n    struct imagedata data;\n    data.img=image;\n    setMouseCallback(\"image\",mouseHundle,&amp;data);//鼠标处理的回调函数\n    waitKey(0);//按任意键关闭当前显示的窗口,显示下一个窗口\n    Mat res=findHomography(data.points,obj,CV_RANSAC);  //利用RANSAC算法计算出来一个小矩阵\n    warpPerspective(image,result,res,result.size());  //结果转换\n    imshow(\"result\",result);\n    waitKey(0);\n}\n\n\n\nint main(int argc, char *argv[])\n{\n    example_1();\n    return 0;\n}\n</code></pre>\n<h1>看完别忘三连哦！您的支持是对我最大的鼓励！</h1>\n<p>博主往期的其他实用文章：</p>\n<p><a class=\"has-card\" href=\"https://blog.csdn.net/baidu_38326512/article/details/124271434?spm=1001.2014.3001.5502\" title=\"C++使用opencv调用级联分类器来识别目标物体_一个不同的ID的博客-CSDN博客\"><span class=\"link-card-box\"><span class=\"link-title\">C++使用opencv调用级联分类器来识别目标物体_一个不同的ID的博客-CSDN博客</span><span class=\"link-desc\">前言：相较于帧差法捕捉目标物体识别，级联分类器识别目标物体更加具有针对性，使用前者只要是动的物体都会被捕捉识别到，画面里有一点风吹草动，都会被捕捉识别下来，如果我想识别具体的人或者物，都无法做到精准的目标识别，所以有了级联分类器识别（即模型识别），会按照训练好的级联分类器（模型）来进行目标识别流程讲解：1.创建一个级联分类器对象创建一个级联分类器对象，并读取已经已经训练好的模型 CascadeClassifier cascade;//级联分类器(模型) cascade</span><span class=\"link-link\"><img alt=\"\" class=\"link-link-icon\" src=\"https://g.csdnimg.cn/static/logo/favicon32.ico\"/>https://blog.csdn.net/baidu_38326512/article/details/124271434?spm=1001.2014.3001.5502</span></span></a><a class=\"has-card\" href=\"https://blog.csdn.net/baidu_38326512/article/details/124236389?spm=1001.2014.3001.5502\" title=\"C++调用opencv完成运动目标捕捉_一个不同的ID的博客-CSDN博客\"><span class=\"link-card-box\"><span class=\"link-title\">C++调用opencv完成运动目标捕捉_一个不同的ID的博客-CSDN博客</span><span class=\"link-desc\">一、原理说明：差帧识别原理：将这一帧的图像和上一帧的图像进行比对，产生变化的即为运动的目标像素块二、过程详解：1.将传入的两帧先进行灰度处理，转化将rgb类型图片转化为灰度图，可大大降低处理时间和资源消耗将转换后的图片转存至frontGray和afterGray cvtColor(frontFrame,frontGray,CV_BGR2GRAY); cvtColor(afterFrame,afterGray,CV_BGR2GRAY);2.将两帧图片进行...</span><span class=\"link-link\"><img alt=\"\" class=\"link-link-icon\" src=\"https://g.csdnimg.cn/static/logo/favicon32.ico\"/>https://blog.csdn.net/baidu_38326512/article/details/124236389?spm=1001.2014.3001.5502</span></span></a></p>\n<p></p>\n</div>\n</div>"}