{"blogid": "126673483", "writerAge": "码龄4年", "writerBlogNum": "14", "writerCollect": "296", "writerComment": "463", "writerFan": "624", "writerGrade": "4级", "writerIntegral": "1025", "writerName": "KinHKin", "writerProfileAdress": "writer_image\\profile_126673483.jpg", "writerRankTotal": "20236", "writerRankWeekly": "172", "writerThumb": "344", "writerVisitNum": "4291", "blog_read_count": "941", "blog_time": "已于 2022-09-04 09:30:44 修改", "blog_title": "猿创征文｜vue中使用Axios最佳实践", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<blockquote>\n<p>温馨提示：一文搞懂前端网络请求之axios，全文8千字，估计耗时10-12分钟</p>\n<p>博主主页：<a href=\"https://blog.csdn.net/weixin_42974827?spm=1010.2135.3001.5421\" title=\"KinHKin的博客_CSDN博客-vue,性能优化,类型转换领域博主\">KinHKin的博客_CSDN博客-vue,性能优化,类型转换领域博主</a></p>\n<p><strong>提示：</strong>完整代码我已经压缩放在个人主页的资源里，供大家免费下载💗</p>\n</blockquote>\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"1.%E5%89%8D%E8%A8%80-toc\" style=\"margin-left:0px;\"><a href=\"#1.%E5%89%8D%E8%A8%80\">1.前言</a></p>\n<p id=\"2.%E4%BD%BF%E7%94%A8-toc\" style=\"margin-left:0px;\"><a href=\"#2.%E4%BD%BF%E7%94%A8\">2.使用</a></p>\n<p id=\"2.1%E5%AE%89%E8%A3%85-toc\" style=\"margin-left:40px;\"><a href=\"#2.1%E5%AE%89%E8%A3%85\">2.1安装</a></p>\n<p id=\"2.2%E5%9F%BA%E6%9C%AC%E7%94%A8%E4%BE%8B-toc\" style=\"margin-left:40px;\"><a href=\"#2.2%E5%9F%BA%E6%9C%AC%E7%94%A8%E4%BE%8B\">2.2基本用例</a></p>\n<p id=\"2.2.1%20get%E8%AF%B7%E6%B1%82-toc\" style=\"margin-left:80px;\"><a href=\"#2.2.1%20get%E8%AF%B7%E6%B1%82\">2.2.1 get请求</a></p>\n<p id=\"2.2.2%C2%A0post%E8%AF%B7%E6%B1%82-toc\" style=\"margin-left:80px;\"><a href=\"#2.2.2%C2%A0post%E8%AF%B7%E6%B1%82\">2.2.2 post请求</a></p>\n<p id=\"3.%E9%85%8D%E7%BD%AE-toc\" style=\"margin-left:0px;\"><a href=\"#3.%E9%85%8D%E7%BD%AE\">3.配置</a></p>\n<p id=\"3.1%E8%AF%AD%E6%B3%95-toc\" style=\"margin-left:40px;\"><a href=\"#3.1%E8%AF%AD%E6%B3%95\">3.1语法</a></p>\n<p id=\"3.2%E5%88%AB%E5%90%8D%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#3.2%E5%88%AB%E5%90%8D%C2%A0\">3.2别名 </a></p>\n<p id=\"4.Axios%E5%AE%9E%E4%BE%8B-toc\" style=\"margin-left:0px;\"><a href=\"#4.Axios%E5%AE%9E%E4%BE%8B\">4.Axios实例</a></p>\n<p id=\"4.1%E8%AF%AD%E6%B3%95-toc\" style=\"margin-left:40px;\"><a href=\"#4.1%E8%AF%AD%E6%B3%95\">4.1语法</a></p>\n<p id=\"4.2%E8%AF%B7%E6%B1%82%E9%85%8D%E7%BD%AE-toc\" style=\"margin-left:40px;\"><a href=\"#4.2%E8%AF%B7%E6%B1%82%E9%85%8D%E7%BD%AE\">4.2请求配置</a></p>\n<p id=\"4.3%E5%93%8D%E5%BA%94%E7%9A%84%E9%85%8D%E7%BD%AE-toc\" style=\"margin-left:40px;\"><a href=\"#4.3%E5%93%8D%E5%BA%94%E7%9A%84%E9%85%8D%E7%BD%AE\">4.3响应的配置</a></p>\n<p id=\"pei-zhi-de-you-xian-ji-toc\" style=\"margin-left:80px;\"><a href=\"#pei-zhi-de-you-xian-ji\">配置的优先级</a></p>\n<p id=\"5.%E6%8B%A6%E6%88%AA%E5%99%A8-toc\" style=\"margin-left:0px;\"><a href=\"#5.%E6%8B%A6%E6%88%AA%E5%99%A8\">5.拦截器</a></p>\n<p id=\"6.%E9%94%99%E8%AF%AF%E6%8B%A6%E6%88%AA-toc\" style=\"margin-left:0px;\"><a href=\"#6.%E9%94%99%E8%AF%AF%E6%8B%A6%E6%88%AA\">6.错误拦截</a></p>\n<p id=\"%C2%A07%EF%BC%8C%E5%8F%96%E6%B6%88%E8%AF%B7%E6%B1%82-toc\" style=\"margin-left:0px;\"><a href=\"#%C2%A07%EF%BC%8C%E5%8F%96%E6%B6%88%E8%AF%B7%E6%B1%82\"> 7.取消请求</a></p>\n<p id=\"8.%E5%AE%8C%E6%95%B4%E5%B0%81%E8%A3%85%C2%A0-toc\" style=\"margin-left:0px;\"><a href=\"#8.%E5%AE%8C%E6%95%B4%E5%B0%81%E8%A3%85%C2%A0\">8.完整封装 </a></p>\n<p id=\"9.%E6%80%BB%E7%BB%93-toc\" style=\"margin-left:0px;\"><a href=\"#9.%E6%80%BB%E7%BB%93\">9.总结</a></p>\n<hr id=\"hr-toc\"/>\n<h1>1.前言</h1>\n<p>最近在写vue3的项目，需要重新搭建脚手架并且使用网络请求接口，对于js的网络请求接口的一般有几种常用的方式：</p>\n<ol><li>fetch</li><li>XMLHttpRequests</li><li>ajax （原生）</li><li>axios （开源）</li></ol>\n<p>Axios 是一个基于 promise 的网络请求库，可以用于浏览器和 node.js。Axios 使用简单,包尺寸小且提供了易于扩展的接口。在服务端它使用原生 node.js <code>http</code> 模块, 而在客户端 (浏览端) 则使用 XMLHttpRequests。</p>\n<blockquote>\n<p>简单示例：</p>\n<p>import axios from \"axios\";<br/> axios.get('/users')<br/> .then(res =&gt; {<!-- --><br/> console.log(res.data);<br/> });</p>\n</blockquote>\n<h1 id=\"2.%E4%BD%BF%E7%94%A8\">2.使用</h1>\n<h2 id=\"2.1%E5%AE%89%E8%A3%85\">2.1安装</h2>\n<pre><code>npm install axios</code></pre>\n<h2 id=\"2.2%E5%9F%BA%E6%9C%AC%E7%94%A8%E4%BE%8B\">2.2基本用例</h2>\n<blockquote>\n<p>在commonJs中使用axios时候：使用require()导入的时候获得ts的类型推断；使用以下方法：</p>\n<p><strong>const axios = require('axios').default; </strong></p>\n<p><strong>// axios.&lt;method&gt; 能够提供自动完成和参数类型推断功能</strong></p>\n</blockquote>\n<h3 id=\"2.2.1%20get%E8%AF%B7%E6%B1%82\">2.2.1 get请求</h3>\n<p>发送一个get请求</p>\n<pre><code>import axios from \"axios\"; \naxios\n    .get(\"/getData\")\n    .then((res) =&gt; {\n      console.log(res);\n      list.value = res.data.list;\n    })\n    .catch(function (error) {\n      // 处理错误情况\n      console.log(error);\n    })\n    .then(function () {\n      // 总是会执行\n    });</code></pre>\n<blockquote>\n<p>支持异步操作 async/await用法</p>\n</blockquote>\n<pre><code>const list = ref&lt;ListModel[]&gt;([]);\nasync function getUrl() {\n  const res = await axios.get(\"/getData\", {\n    params: {\n      id: 1, //需要携带参数\n    },\n  });\n  list.value = res.data.list;\n}\ngetUrl();</code></pre>\n<p></p>\n<h3 id=\"2.2.2%C2%A0post%E8%AF%B7%E6%B1%82\">2.2.2 post请求</h3>\n<p>发送一个post请求</p>\n<pre><code>function postUrl() {\n  axios\n    .post(\"/postData\", {\n      name: \"Fred\",\n      age: 18,\n    })\n    .then(function (response) {\n      console.log(response.data.message);\n    })\n    .catch(function (error) {\n      console.log(error);\n    });\n}\npostUrl();</code></pre>\n<p> 发起多个并发请求</p>\n<pre><code>// 发送多个并发请求\nfunction getUserInfo() {\n  return axios.get(\"/userInfo\");\n}\nfunction getToken() {\n  return axios.get(\"/getToken\");\n}\n//同步\nPromise.all([getUserInfo(), getToken()]).then((res) =&gt; {\n  console.log(res, \"res\");\n});\n//异步\nPromise.race([getUserInfo(), getToken()]).then((res) =&gt; {\n  console.log(res, \"res1111\");\n});</code></pre>\n<h1 id=\"3.%E9%85%8D%E7%BD%AE\">3.配置</h1>\n<h2 id=\"3.1%E8%AF%AD%E6%B3%95\">3.1语法</h2>\n<p>axios(config)</p>\n<blockquote>\n<p>// 发起一个post请求</p>\n<p>axios({ method: 'post', url: '/user/12345', data: { firstName: 'Fred', lastName: 'Flintstone' } });</p>\n</blockquote>\n<p>默认请求方式：</p>\n<p>// 发起一个 GET 请求 (默认请求方式) axios('/user/12345');</p>\n<h2 id=\"3.2%E5%88%AB%E5%90%8D%C2%A0\">3.2别名 </h2>\n<p>axios.request(config)</p>\n<h1 id=\"4.Axios%E5%AE%9E%E4%BE%8B\">4.Axios实例</h1>\n<h2 id=\"4.1%E8%AF%AD%E6%B3%95\">4.1语法</h2>\n<p>axios.create([config])</p>\n<pre><code>const instance = axios.create({\n  baseURL: 'https://some-domain.com/api/',\n  timeout: 1000,\n  headers: {'X-Custom-Header': 'foobar'}\n});</code></pre>\n<h2 id=\"4.2%E8%AF%B7%E6%B1%82%E9%85%8D%E7%BD%AE\">4.2请求配置</h2>\n<p>这些是创建请求时可以用的配置选项。只有 <code>url</code> 是必需的。如果没有指定 <code>method</code>，请求将默认使用 <code>GET</code> 方法。</p>\n<pre><code>{\n  // `url` 是用于请求的服务器 URL\n  url: '/user',\n\n  // `method` 是创建请求时使用的方法\n  method: 'get', // 默认值\n\n  // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。\n  // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL\n  baseURL: 'https://some-domain.com/api/',\n\n  // `transformRequest` 允许在向服务器发送前，修改请求数据\n  // 它只能用于 'PUT', 'POST' 和 'PATCH' 这几个请求方法\n  // 数组中最后一个函数必须返回一个字符串， 一个Buffer实例，ArrayBuffer，FormData，或 Stream\n  // 你可以修改请求头。\n  transformRequest: [function (data, headers) {\n    // 对发送的 data 进行任意转换处理\n\n    return data;\n  }],\n\n  // `transformResponse` 在传递给 then/catch 前，允许修改响应数据\n  transformResponse: [function (data) {\n    // 对接收的 data 进行任意转换处理\n\n    return data;\n  }],\n\n  // 自定义请求头\n  headers: {'X-Requested-With': 'XMLHttpRequest'},\n\n  // `params` 是与请求一起发送的 URL 参数\n  // 必须是一个简单对象或 URLSearchParams 对象\n  params: {\n    ID: 12345\n  },\n\n  // `data` 是作为请求体被发送的数据\n  // 仅适用 'PUT', 'POST', 'DELETE 和 'PATCH' 请求方法\n  // 在没有设置 `transformRequest` 时，则必须是以下类型之一:\n  // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams\n  // - 浏览器专属: FormData, File, Blob\n  // - Node 专属: Stream, Buffer\n  data: {\n    firstName: 'Fred'\n  },\n  \n  // `timeout` 指定请求超时的毫秒数。\n  // 如果请求时间超过 `timeout` 的值，则请求会被中断\n  timeout: 1000, // 默认值是 `0` (永不超时)\n\n  // `withCredentials` 表示跨域请求时是否需要使用凭证\n  withCredentials: false, // default\n\n\n  // `auth` HTTP Basic Auth\n  auth: {\n    username: 'janedoe',\n    password: 's00pers3cret'\n  },\n\n  // `responseType` 表示浏览器将要响应的数据类型\n  // 选项包括: 'arraybuffer', 'document', 'json', 'text', 'stream'\n  // 浏览器专属：'blob'\n  responseType: 'json', // 默认值\n\n  // `responseEncoding` 表示用于解码响应的编码 (Node.js 专属)\n  // 注意：忽略 `responseType` 的值为 'stream'，或者是客户端请求\n  // Note: Ignored for `responseType` of 'stream' or client-side requests\n  responseEncoding: 'utf8', // 默认值\n\n  // `xsrfCookieName` 是 xsrf token 的值，被用作 cookie 的名称\n  xsrfCookieName: 'XSRF-TOKEN', // 默认值\n\n  // `xsrfHeaderName` 是带有 xsrf token 值的http 请求头名称\n  xsrfHeaderName: 'X-XSRF-TOKEN', // 默认值\n\n  // `onUploadProgress` 允许为上传处理进度事件\n  // 浏览器专属\n  onUploadProgress: function (progressEvent) {\n    // 处理原生进度事件\n  },\n\n  // `onDownloadProgress` 允许为下载处理进度事件\n  // 浏览器专属\n  onDownloadProgress: function (progressEvent) {\n    // 处理原生进度事件\n  },\n\n  // `maxContentLength` 定义了node.js中允许的HTTP响应内容的最大字节数\n  maxContentLength: 2000,\n\n  // `maxBodyLength`（仅Node）定义允许的http请求内容的最大字节数\n  maxBodyLength: 2000,\n\n  // `validateStatus` 定义了对于给定的 HTTP状态码是 resolve 还是 reject promise。\n  // 如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，\n  // 则promise 将会 resolved，否则是 rejected。\n  validateStatus: function (status) {\n    return status &gt;= 200 &amp;&amp; status &lt; 300; // 默认值\n  },\n\n  // `maxRedirects` 定义了在node.js中要遵循的最大重定向数。\n  // 如果设置为0，则不会进行重定向\n  maxRedirects: 5, // 默认值\n\n  // `proxy` 定义了代理服务器的主机名，端口和协议。\n  // 您可以使用常规的`http_proxy` 和 `https_proxy` 环境变量。\n  // 使用 `false` 可以禁用代理功能，同时环境变量也会被忽略。\n  // `auth`表示应使用HTTP Basic auth连接到代理，并且提供凭据。\n  // 这将设置一个 `Proxy-Authorization` 请求头，它会覆盖 `headers` 中已存在的自定义 `Proxy-Authorization` 请求头。\n  // 如果代理服务器使用 HTTPS，则必须设置 protocol 为`https`\n  proxy: {\n    protocol: 'https',\n    host: '127.0.0.1',\n    port: 9000,\n    auth: {\n      username: 'mikeymike',\n      password: 'rapunz3l'\n    }\n  },\n\n  // see https://axios-http.com/zh/docs/cancellation\n  cancelToken: new CancelToken(function (cancel) {\n  }),\n\n}</code></pre>\n<h2 id=\"4.3%E5%93%8D%E5%BA%94%E7%9A%84%E9%85%8D%E7%BD%AE\">4.3响应的配置</h2>\n<p>一个请求的响应包含以下信息</p>\n<pre><code>{\n  // `data` 由服务器提供的响应\n  data: {},\n\n  // `status` 来自服务器响应的 HTTP 状态码\n  status: 200,\n\n  // `statusText` 来自服务器响应的 HTTP 状态信息\n  statusText: 'OK',\n\n  // `headers` 是服务器响应头\n  // 所有的 header 名称都是小写，而且可以使用方括号语法访问\n  // 例如: `response.headers['content-type']`\n  headers: {},\n\n  // `config` 是 `axios` 请求的配置信息\n  config: {},\n\n  // `request` 是生成此响应的请求\n  // 在node.js中它是最后一个ClientRequest实例 (in redirects)，\n  // 在浏览器中则是 XMLHttpRequest 实例\n  request: {}\n}</code></pre>\n<h3 id=\"pei-zhi-de-you-xian-ji\">配置的优先级</h3>\n<p>配置将会按优先级进行合并。它的顺序是：在<a href=\"https://github.com/axios/axios/blob/master/lib/defaults.js#L28\" title=\"lib/defaults.js\">lib/defaults.js</a>中找到的库默认值，然后是实例的 <code>defaults</code> 属性，最后是请求的 <code>config</code> 参数。后面的优先级要高于前面的。下面有一个例子。</p>\n<pre><code>// 使用库提供的默认配置创建实例\n// 此时超时配置的默认值是 `0`\nconst instance = axios.create();\n\n// 重写库的超时默认值\n// 现在，所有使用此实例的请求都将等待2.5秒，然后才会超时\ninstance.defaults.timeout = 2500;\n\n// 重写此请求的超时时间，因为该请求需要很长时间\ninstance.get('/longRequest', {\n  timeout: 5000\n});</code></pre>\n<h1 id=\"5.%E6%8B%A6%E6%88%AA%E5%99%A8\">5.拦截器</h1>\n<p>在请求或响应被 then 或 catch 处理前拦截它们。</p>\n<pre><code>// 生成实例\nconst instance = axios.create({\n  baseURL: \"/\",\n  timeout: 1000,\n  headers: { \"Content-Type\": \"multipart/form-data;charset=utf-8\" },\n});\n// 请求的拦截器\ninstance.interceptors.request.use(\n  function (config) {\n    // 在发送请求之前做些什么\n    console.log(config, \"config\");\n    return config;\n  },\n  function (error) {\n    // 对请求错误做些什么\n    return Promise.reject(error);\n  }\n);\n// 返回的拦截器\ninstance.interceptors.response.use(\n  function (res) {\n    // 2xx 范围内的状态码都会触发该函数。\n    // 对响应数据做点什么\n    console.log(res, \"res\");\n\n    return res;\n  },\n  function (error) {\n    // 超出 2xx 范围的状态码都会触发该函数。\n    // 对响应错误做点什么\n    return Promise.reject(error);\n  }\n);</code></pre>\n<h1 id=\"6.%E9%94%99%E8%AF%AF%E6%8B%A6%E6%88%AA\">6.错误拦截</h1>\n<pre><code>axios.get('/getData')\n  .catch(function (error) {\n    if (error.response) {\n      // 请求成功发出且服务器也响应了状态码，但状态代码超出了 2xx 的范围\n      console.log(error.response.data);\n      console.log(error.response.status);\n      console.log(error.response.headers);\n    } else if (error.request) {\n      // 请求已经成功发起，但没有收到响应\n      // `error.request` 在浏览器中是 XMLHttpRequest 的实例，\n      // 而在node.js中是 http.ClientRequest 的实例\n      console.log(error.request);\n    } else {\n      // 发送请求时出了点问题\n      console.log('Error', error.message);\n    }\n    console.log(error.config);\n  });\n</code></pre>\n<p>使用 <code>validateStatus</code> 配置选项，可以自定义抛出错误的 HTTP code。</p>\n<pre><code>axios.get('/getData', {\n  validateStatus: function (status) {\n    return status &lt; 500; // 处理状态码小于500的情况\n  }\n})\n</code></pre>\n<p>使用 <code>toJSON</code> 可以获取更多关于HTTP错误的信息。</p>\n<pre><code>axios.get('/getData')\n  .catch(function (error) {\n    console.log(error.toJSON());\n  });</code></pre>\n<h1 id=\"%C2%A07%EF%BC%8C%E5%8F%96%E6%B6%88%E8%AF%B7%E6%B1%82\"> 7.取消请求</h1>\n<p>从v0.22.0以后，CancelToken取消请求的方式被弃用，Axios 支持以 fetch API 方式—— <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/AbortController\" title=\"AbortController\">AbortController</a> 取消请求：</p>\n<pre><code>const controller = new AbortController();\n\naxios.get('/getData', {\n   signal: controller.signal\n}).then(function(response) {\n   //...\n});\n// 取消请求\ncontroller.abort()</code></pre>\n<h1 id=\"8.%E5%AE%8C%E6%95%B4%E5%B0%81%E8%A3%85%C2%A0\">8.完整封装 </h1>\n<ol><li>建立http.ts文件</li><li> 编写clas Http类</li></ol>\n<p>完整代码如下，亲自测试通过：<img alt=\"\" height=\"338\" src=\"image\\e3b9bfee5d45450abc7e1e29ac59cad3.png\" width=\"970\"/></p>\n<p>http.ts文件全部代码如下：</p>\n<pre><code>import type { AxiosInstance, AxiosRequestConfig } from \"axios\";\nimport axios from \"axios\";\n\nclass Http {\n  private readonly options: AxiosRequestConfig;\n  private axiosInstance: AxiosInstance;\n\n  // 构造函数 参数 options\n  constructor(params: AxiosRequestConfig) {\n    this.options = params;\n    this.axiosInstance = axios.create(params); // 生成实例\n    this.setupInterceptors();\n  }\n  private setupInterceptors() {\n    this.axiosInstance.defaults.baseURL = \"/\";\n    this.axiosInstance.defaults.headers.post[\"Content-Type\"] =\n      \"application/json\";\n    this.axiosInstance.interceptors.request.use(\n      (config) =&gt; {\n        if (!config.headers) {\n          config.headers = {};\n        }\n        // config.headers.Authorization = CSRF_TOKEN;\n        return config;\n      },\n      () =&gt; {\n        return Promise.reject({\n          code: 1,\n          message: \"请求错误，请联系管理员\",\n        });\n      }\n    );\n\n    this.axiosInstance.interceptors.response.use(\n      (response) =&gt; {\n        return Promise.resolve(response);\n      },\n      (error) =&gt; {\n        let message = \"\";\n        if (error.response) {\n          switch (error.response.status) {\n            case 2:\n              message = \"未登录，直接跳转到登录页面\";\n              break;\n            case 3:\n              message = \"TOKEN过期，拒绝访问，直接跳转到登录页面\";\n              break;\n            case 4:\n              message = \"请求路径错误\";\n              break;\n            case 5:\n              message = \"系统异常，请联系管理员\";\n              break;\n            default:\n              message = \"未知错误，请联系管理员\";\n              break;\n          }\n        } else {\n          if (error.code &amp;&amp; error.code == \"ECONNABORTED\") {\n            message = \"请求超时，请检查网是否正常\";\n          } else {\n            message = \"未知错误，请稍后再试\";\n          }\n        }\n        return Promise.reject({\n          code: -1,\n          message: message,\n        });\n      }\n    );\n  }\n  /**\n   * Http get\n   * @param url 请求路径\n   * @param config 配置信息\n   * @returns Promise\n   */\n  get(url: string, config?: any): Promise&lt;any&gt; {\n    return new Promise((resolve, reject) =&gt; {\n      this.axiosInstance\n        .get(url, config)\n        .then((response) =&gt; {\n          resolve(response.data);\n        })\n        .catch((error) =&gt; {\n          reject(error);\n        });\n    });\n  }\n  /**\n   * Http post\n   * @param url 请求路径\n   * @param data 请求数据\n   * @param config 配置\n   * @returns Promise\n   */\n  post(url: string, data?: any, config?: any): Promise&lt;any&gt; {\n    return new Promise((reslove, reject) =&gt; {\n      this.axiosInstance\n        .post(url, data, config)\n        .then((response) =&gt; {\n          reslove(response.data);\n        })\n        .catch((error) =&gt; {\n          reject(error);\n        });\n    });\n  }\n}\nconst http = new Http({\n  timeout: 1000 * 5,\n});\nexport default http;\n</code></pre>\n<h1 id=\"9.%E6%80%BB%E7%BB%93\">9.总结</h1>\n<p>个人经过vue3项目实践，配合mock数据，使用axios请求基本满足前端日常开发的请求方式，至于文件上传，下载请求，只需要修改请求类型符合前后端联调的功能就可以使用了，对于环境的配置，我们需要在base_url上面修改指定的域名环境，这种可以做成配置项，比如在process.env.NODE_ENV填写环境配置，接下来我将配合http的请求方式详细讲解网络请求的过程，谢谢大家的支持，码字不易，希望多多三连支持💗💗💗</p>\n</div>\n</div>"}