{"blogid": "123899141", "writerAge": "码龄2年", "writerBlogNum": "103", "writerCollect": "1608", "writerComment": "745", "writerFan": "4001", "writerGrade": "5级", "writerIntegral": "3856", "writerName": "努力学习的少年", "writerProfileAdress": "writer_image\\profile_123899141.jpg", "writerRankTotal": "4934", "writerRankWeekly": "5736", "writerThumb": "1573", "writerVisitNum": "139242", "blog_read_count": "15667", "blog_time": "已于 2022-04-03 20:31:14 修改", "blog_title": "【c++复习笔记】——智能指针详细解析(智能指针的使用,原理分析)", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<blockquote>\n<ul><li><strong>💂 个人主页:</strong><a href=\"https://blog.csdn.net/sjp11?spm=1000.2115.3001.5343\" title=\"努力学习的少年\">努力学习的少年</a></li><li><strong>🤟 版权:</strong> 本文由【努力学习的少年】原创、在CSDN首发、需要转载请联系博主</li><li>💬 如果文章对你有帮助、<strong>欢迎<span style=\"color:#4da8ee;\">关注</span>、<span style=\"color:#ff9900;\">点赞</span>、<span style=\"color:#be191c;\">收藏</span>(一键三连)和<span style=\"color:#1a439c;\">订阅专栏</span>哦</strong></li></ul>\n</blockquote>\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E4%B8%80.%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%80.%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\">一. 智能指针的基本概念</a></p>\n<p id=\"%E4%BA%8C.%C2%A0%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BA%8C.%C2%A0%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8\">二.  智能指针的定义和使用</a></p>\n<p id=\"%E4%B8%89.%20auto_ptr-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%89.%20auto_ptr\">三. auto_ptr</a></p>\n<p id=\"%E5%9B%9B.%20unique_ptr-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%9B%9B.%20unique_ptr\">四. unique_ptr</a></p>\n<p id=\"%E4%BA%94.%20share_ptr-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BA%94.%20share_ptr\">五. share_ptr</a></p>\n<p id=\"1.%20shared_ptr%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-toc\" style=\"margin-left:40px;\"><a href=\"#1.%20shared_ptr%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\">1. shared_ptr的基本概念</a></p>\n<p id=\"2.%20shared_ptr%E7%9A%84%E5%8E%9F%E7%90%86-toc\" style=\"margin-left:40px;\"><a href=\"#2.%20shared_ptr%E7%9A%84%E5%8E%9F%E7%90%86\">2. shared_ptr的原理</a></p>\n<p id=\"3.%20shared_ptrd%E7%9A%84%E5%AE%9E%E7%8E%B0-toc\" style=\"margin-left:40px;\"><a href=\"#3.%20shared_ptrd%E7%9A%84%E5%AE%9E%E7%8E%B0\">3. shared_ptrd的实现</a></p>\n<p id=\"4.%20shared_ptr%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8-toc\" style=\"margin-left:40px;\"><a href=\"#4.%20shared_ptr%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8\">4. shared_ptr的循环引用</a></p>\n<p id=\"5.%20%E5%AE%9A%E5%88%B6%E5%88%A0%E9%99%A4%E5%99%A8-toc\" style=\"margin-left:40px;\"><a href=\"#5.%20%E5%AE%9A%E5%88%B6%E5%88%A0%E9%99%A4%E5%99%A8\">5. 定制删除器</a></p>\n<p id=\"%E4%BB%BF%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%A0%E9%99%A4%E5%99%A8-toc\" style=\"margin-left:80px;\"></p>\n<hr id=\"hr-toc\"/>\n<h1 id=\"%E4%B8%80.%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\">一. 智能指针的基本概念</h1>\n<h2>1. RAll</h2>\n<blockquote>\n<p>RAII（Resource Acquisition Is Initialization）是一种利用<strong><span style=\"color:#956fe7;\">对象生命周期来控制程序资源</span></strong>（如内存、文件句柄、网络连接、互斥量等等）的简单技术。<br/> 在对象构造时获取资源，接着控制对资源的访问使之在对象的生命周期内始终保持有效，最后在对象析构的时候释放资源。借此，我们实际上把管理一份资源的责任托管给了一个对象。这种做法有两大好处：</p>\n<ul><li><span style=\"color:#1a439c;\"><strong>不需要显式地释放资源。 </strong></span></li><li><span style=\"color:#1a439c;\"><strong>采用这种方式，对象所需的资源在其生命期内始终保持有效</strong>。</span></li></ul>\n</blockquote>\n<h2>2.智能指针概念</h2>\n<blockquote>\n<p>    在c++中，动态内存的管理式通过一对运算符来完成的：new,<span style=\"color:#4da8ee;\"><strong>在动态内存中为对象分配空间并返回一个指向该对象的指针</strong></span>，我们可以选择对对象进行初始化；delete，接受一个动态对象的指针，销毁该对象，并释放与之关联的内存。动态内存的使用很容易出现问题，因为确保在正确的时间释放内存是极其困难的。有时使用完对象后，忘记释放内存，造成内存泄漏的问题。</p>\n</blockquote>\n<ul><li><span style=\"color:#0d0016;\">  所谓的</span><strong><span style=\"color:#4da8ee;\">智能指针本质就是一个类模板</span></strong><span style=\"color:#0d0016;\">，它可以创建任意的类型的指针对象，当智能指针对象使用完后</span><strong><span style=\"color:#4da8ee;\">，对象就会自动调用析构函数去释放该指针所指向的空间</span></strong><span style=\"color:#0d0016;\">。</span></li></ul>\n<p>下面是智能指针的基本框架，所有的智能指针类模板中都需要包含一个<strong><span style=\"color:#4da8ee;\">指针对象</span></strong>，<strong><span style=\"color:#956fe7;\">构造函数</span></strong>和<span style=\"color:#be191c;\"><strong>析构函数</strong></span>。</p>\n<p><img alt=\"\" height=\"467\" src=\"image\\54036527c1784a51b79ac0f733f2f5ff.png\" width=\"838\"/></p>\n<p></p>\n<h1 id=\"%E4%BA%8C.%C2%A0%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8\">二.  智能指针的定义和使用</h1>\n<ul><li><strong><span style=\"color:#4da8ee;\">智能指针的使用跟普通指针类似</span></strong>，可以使用运算符“ * \" 和 ” -&gt; \"去获得指向的对象，因此，我们就需要在类中重载\" * \" 和\" -&gt; \"函数。</li></ul>\n<p><img alt=\"\" height=\"646\" src=\"image\\216d0af11b314eb69f03e28b59b08e36.png\" width=\"936\"/></p>\n<p></p>\n<ul><li>当程序结束时，此时ptr1和ptr2指针被销毁时，对象<span style=\"color:#4da8ee;\"><strong>p</strong>tr1和ptr2会自动调用析构函数去释放所指向的资源</span>，这是智能指针特点。</li></ul>\n<p></p>\n<p><img alt=\"\" height=\"270\" src=\"image\\ceada8c2f0d34de9b371b4710cc3992e.png\" width=\"1200\"/></p>\n<ul><li> 由于我的类中没有定义拷贝构造函数和赋值重载函数，那么我们只能调用类中原生的拷贝构造函数和赋值重载函数。那么就会程序就会出现崩溃的问题，如下:</li></ul>\n<p><img alt=\"\" height=\"315\" src=\"image\\6df388fd6eea4886bd5babe43465dbfa.png\" width=\"1200\"/></p>\n<ul><li><span style=\"color:#4da8ee;\"><strong>ptr2和ptr1指向的同一块空间</strong></span>，当ptr2被销毁时，它会调用它的析构函数去delete该资源对象，当ptr1被销毁时,也会去调用它的析构函数去释放ptr1所指向的资源.所以，当程序结束时，ptr2被先被销毁，同时释放ptr2所指向的资源，然后ptr1被销毁，也去释放该资源对象，那么如下的资源对象同时被释放两次，所以程序就会被崩溃掉。(<span style=\"color:#4da8ee;\"><strong>资源对象被释放后，如果再去释放该资源，程序就会崩溃</strong></span>)</li></ul>\n<p><img alt=\"\" height=\"375\" src=\"image\\93bc9b96e2154c73878783f642d8c472.png\" width=\"1200\"/></p>\n<p> 综上所述，我们不能使用原生的拷贝构造函数和赋值重载函数，并且<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">定义的拷贝构造函数和赋值重载函数需要考虑只能释放一次资源对象</span></span>。</p>\n<h1 id=\"c%2B%2B%E5%BA%93%E4%B8%AD%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88\">c++库中的智能指针</h1>\n<h1 id=\"%E4%B8%89.%20auto_ptr\">三. auto_ptr</h1>\n<p>auto_ptr是c++98版本库中提供的智能指针，该指针解决上诉的问题采取的措施是<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">管理权转移的思想</span></span>，也就是<strong><span style=\"color:#4da8ee;\">原对象拷贝给新对象的时候，原对象就会被设置为nullptr</span></strong>，此时就只有新对象指向一块资源空间。</p>\n<p><img alt=\"\" height=\"162\" src=\"image\\0c54771d97954e11ae96939cbd3b01f1.png\" width=\"783\"/></p>\n<p></p>\n<p><img alt=\"\" height=\"618\" src=\"image\\8d200463b84447618008255e27e50cf4.png\" width=\"1085\"/></p>\n<p></p>\n<p></p>\n<p> 如果auto_ptr调用拷贝构造函数或者赋值重载函数后<strong><span style=\"color:#4da8ee;\">，如果再去使用原来的对象的话，那么整个程序就会崩溃掉（因为原来的对象被设置为nullptr)</span></strong>，这对程序是有很大的伤害的.所以很多公司会禁用auto_ptr智能指针。</p>\n<h3 id=\"auto_ptr%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E8%B5%8B%E5%80%BC%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0\">auto_ptr的拷贝构造函数和赋值重载函数的实现</h3>\n<p><img alt=\"\" height=\"366\" src=\"image\\ae12272e4c1a421db455e54cb4d73a79.png\" width=\"953\"/></p>\n<h1 id=\"%E5%9B%9B.%20unique_ptr\">四. unique_ptr</h1>\n<p>unique_ptr是c++11版本库中提供的智能指针,<span style=\"color:#4da8ee;\"><strong>它直接将拷贝构造函数和赋值重载函数给禁用掉</strong></span>，因此，不让其进行拷贝和赋值。</p>\n<p></p>\n<p><img alt=\"\" height=\"179\" src=\"image\\229a0cb3f6fa4f26848c4cb30985e56d.png\" width=\"1010\"/></p>\n<h3 id=\"unique_ptr%E7%9A%84%E6%8B%B7%E8%B4%9D%E5%87%BD%E6%95%B0%E5%92%8C%E8%B5%8B%E5%80%BC%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0\">unique_ptr的拷贝函数和赋值重载函数</h3>\n<p><img alt=\"\" height=\"231\" src=\"image\\2224ff1928094415acb3def19353b84b.png\" width=\"787\"/></p>\n<h1 id=\"%E4%BA%94.%20share_ptr\">五. share_ptr</h1>\n<h2 id=\"1.%20shared_ptr%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\">1. shared_ptr的基本概念</h2>\n<p>share_ptr是c++11版本库中的智能指针，<strong><span style=\"color:#4da8ee;\">shared_ptr允许多个智能指针可以指向同一块资源</span></strong>，并且能够保证共享的资源只会被释放一次，因此是程序不会崩溃掉。</p>\n<p><img alt=\"\" height=\"237\" src=\"image\\38c25fc24c524f0da2dc06fe67cd780f.png\" width=\"818\"/></p>\n<h2 id=\"2.%20shared_ptr%E7%9A%84%E5%8E%9F%E7%90%86\">2. shared_ptr的原理</h2>\n<p>shared_ptr采用的是<strong><span style=\"color:#4da8ee;\">引用计数原理</span></strong>来实现多个shared_ptr对象之间共享资源：</p>\n<ul><li>shared_ptr在内部会<span style=\"color:#4da8ee;\"><strong>维护着一份引用计数</strong></span>，用来记录该份资源被几个对象共享。</li><li>当一个<span style=\"color:#4da8ee;\"><strong>shared_ptr对象被销毁时</strong></span>（调用析构函数），<span style=\"color:#1a439c;\"><strong>析构函数内就会将该计数减1</strong></span>。</li><li>如果引用计数减为0后，则表示自己是最后一个使用该资源的shared_ptr对象，必须释放资源。</li><li>如果<strong><span style=\"color:#956fe7;\">引用计数不是0</span></strong>，就说明自己还有其他对象在使用，<strong><span style=\"color:#956fe7;\">则不能释放该资源</span></strong>，否则其他对象就成为野指针。</li></ul>\n<p>引用计数是用来记录资源对象中有多少个指针指向该资源对象。</p>\n<p> <img alt=\"\" height=\"819\" src=\"image\\2c703560f1f34679af075ca465f3c40c.png\" width=\"1087\"/></p>\n<p> 销毁过程：</p>\n<p><img alt=\"\" height=\"475\" src=\"image\\7ab9863d78204ba59b98dc65d38ed18d.png\" width=\"1200\"/></p>\n<p></p>\n<h2 id=\"3.%20shared_ptrd%E7%9A%84%E5%AE%9E%E7%8E%B0\">3. shared_ptrd的实现</h2>\n<p>赋值重载的三种情况:</p>\n<ul><li>ptr1=ptr1；智能指针自己给自己赋值，不做处理</li><li>ptr2=ptr1；如果ptr1和ptr2指向同一块空间，不做处理</li><li>ptr2=ptr1；如果ptr2和ptr1指向的空间不一样,处理过程如下:</li></ul>\n<p><img alt=\"\" height=\"1051\" src=\"image\\69db8b98ccbc4e5c86a5b8517346b2f3.png\" width=\"1200\"/></p>\n<ul><li> 因为<span style=\"color:#4da8ee;\"><strong>_ptrcount指向的对象是在堆上</strong></span>，因此所有的线程都能够访问到该资源，多线程在修改_ptrcount时，则会出现线程安全问题，因此需要在修改_prtcount时需要用锁来保证其数据的正确性。</li><li>“  * \"会返回ptr指向的对象，为什么不需要锁对其进行保护？因为ptr返回的对象有可能被读或者被写，这个不是指针内部所考虑的，而是由调用者进行考虑的。</li></ul>\n<p><img alt=\"\" height=\"1200\" src=\"image\\fbaaa45909254c87a61ebe925a822441.png\" width=\"1117\"/></p>\n<p></p>\n<h2 id=\"4.%20shared_ptr%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8\">4. shared_ptr的循环引用</h2>\n<p>shared_ptr固然好用，但是它也会有问题存在。假设我们要使用定义一个双向链表，如果我们想要让创建出来的链表的节点都定义成shared_ptr智能指针，那么也需要将节点内的_pre和_next都定义成shared_ptr的智能指针。如果定义成普通指针，那么就不能赋值给shared_ptr的智能指针。</p>\n<p><img alt=\"\" height=\"407\" src=\"image\\a6b1afdb4e88452aa798315ce4f04c6b.png\" width=\"959\"/></p>\n<p>当其中<span style=\"color:#4da8ee;\">两个节点互相引用的时候，就会出现循环引用的现象</span>。如下:</p>\n<p><img alt=\"\" height=\"353\" src=\"image\\9d323a5860ed4c47ab35591d5c42db3b.png\" width=\"984\"/></p>\n<ul><li><strong><span style=\"color:#4da8ee;\"> use_count（）</span></strong>: 返回智能指针对象的引用计数。</li></ul>\n<p><img alt=\"\" height=\"612\" src=\"image\\7244696797924901a0488872816943e8.png\" width=\"1079\"/></p>\n<ul><li>当创建出node1和node2智能指针对象时，引用计数都是1.</li><li><strong><span style=\"color:#4da8ee;\">当node1的next指向node2所指向的资源时，node2的引用计数就+1，变成2，node2的pre指向noede1所指向的资源时，node1的引用计数+1，变成2</span></strong>.</li><li>当这两个智能指针使用完后，调用析构函数，引用计数都-1，都变成1，由于引用计数不为0，<strong><span style=\"color:#4da8ee;\">所以node1和node2所指向的对象不会被释放</span></strong>。</li><li>当node1所指向的资源释放需要当node2中的_prev被销毁，就需要node2资源的释放，node2所指向的资源释放就需要当node1中的_next被销毁，就需要node1资源的释放。因此node1和node2都有对方的“把柄”，这两个就造成循环引用现象，最终这node1和node2资源就不会进行释放。</li></ul>\n<p><img alt=\"\" height=\"491\" src=\"image\\3a547298b106428e90457cbe23d7d4fc.png\" width=\"1200\"/></p>\n<p></p>\n<p>那么如何解决这个shared_ptr的循环引用呢？</p>\n<ul><li>c++库中存在<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">weak_ptr</span></span>类型的智能指针。<strong><span style=\"color:#956fe7;\">weak_ptr类的对象它可以指向shared_ptr，并且不会改变shared_ptr的引用计数</span></strong>。一旦最后一个shared_ptr被销毁时，对象就会被释放。</li></ul>\n<p><img alt=\"\" height=\"376\" src=\"image\\1267fcd6576c469aa4a47b577ca31756.png\" width=\"973\"/></p>\n<blockquote>\n<p><strong><span style=\"color:#4da8ee;\">weak_ptr对象指向shared_ptr对象时，不会增加shared_ptr中的引用计数</span></strong>，因此当node1销毁掉时，则node1指向的空间就会被销毁掉，node2类似，所以weak_ptr指针可以很好解决循环引用的问题。</p>\n</blockquote>\n<ul><li> 所以在定义双向链表或者在二叉树等有多个指针的时候,如果想要将该类型定义成智能指针，那么结构体内的指针需要定义成weak_ptr类型的指针，防止循环引用的出现。</li></ul>\n<h3 id=\"weak_ptr%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0\">weak_ptr简单实现</h3>\n<p><img alt=\"\" height=\"678\" src=\"image\\4bf2089932a043819e67e71a27c8ca46.png\" width=\"1041\"/></p>\n<h2 id=\"5.%20%E5%AE%9A%E5%88%B6%E5%88%A0%E9%99%A4%E5%99%A8\">5. 定制删除器</h2>\n<blockquote>\n<p>    当<span style=\"color:#4da8ee;\"><strong>我们释放一个指向数组的指针的时候</strong></span>，<span style=\"color:#4da8ee;\"><strong>delete[]后面的空方括号是必须存在</strong></span>（如下），它指示编译器此指针指向的是一个对象数组的第一个元素，如果我们在delete一个指向数组的指针中忽略了方括号，我们的程序可能在执行过程中在没有任何警告下行为异常。</p>\n</blockquote>\n<p><img alt=\"\" height=\"93\" src=\"image\\15e9f878e61945f4b5520b0a94119856.png\" width=\"966\"/></p>\n<p></p>\n<ul><li> 我们如果在动态内存中创建出一个数组，用一个shared_ptr对象去指向该数组，当shared_ptr使用完后，就会去调用析构函数，<span style=\"color:#4da8ee;\"><strong>由于shared_ptr默认的删除方式是 delete ptr,后面没有带方括号</strong></span>，那么程序就会崩掉</li></ul>\n<p><img alt=\"\" height=\"363\" src=\"image\\3a3e9d8db0c446dc90ff8856a01d2ebe.png\" width=\"1144\"/></p>\n<ul><li> 如果我们打开一个了文件，返回一个文件指针，让一个shared_ptr对象去指向该文件，那么在调用析构函数的时候就<span style=\"color:#b95514;\"><strong>不能采用delete方法，而是使用flose()函数去关闭该文件</strong></span>。</li></ul>\n<p>因此，shared_ptr 类中提供了一个构造函数可以自定义一个删除器去指定析构函数的删除方式。</p>\n<p><img alt=\"\" height=\"24\" src=\"image\\61938c49e1f147ed9451aa0cdf3a6d8b.png\" width=\"689\"/></p>\n<p> 这个自定义删除器可以是<span style=\"color:#4da8ee;\"><strong>函数指针</strong></span>，<span style=\"color:#a2e043;\"><strong>仿函数</strong></span>，<strong><span style=\"color:#956fe7;\">lamber</span><span style=\"color:#1c7892;\">,包装器</span></strong>。</p>\n<h3 id=\"%E4%BB%BF%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%A0%E9%99%A4%E5%99%A8\">仿函数的删除器</h3>\n<p>shared_ptr中的<span style=\"color:#4da8ee;\">析构函数会去调用DelArry仿函数去释放动态数组</span>。</p>\n<p><img alt=\"\" height=\"352\" src=\"image\\0413e1d3a54a4b50aca19d02f7fe366e.png\" width=\"1049\"/></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n</div>\n</div>"}