{"blogid": "124520388", "writerAge": "码龄7年", "writerBlogNum": "6", "writerCollect": "53", "writerComment": "14", "writerFan": "9", "writerGrade": "1级", "writerIntegral": "87", "writerName": "春啊春", "writerProfileAdress": "writer_image\\profile_124520388.jpg", "writerRankTotal": "132902", "writerRankWeekly": "1007231", "writerThumb": "16", "writerVisitNum": "10312", "blog_read_count": "1009", "blog_time": "已于 2022-04-30 23:33:54 修改", "blog_title": "vue使用腾讯云COS上传文件-很清楚的哈。", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>最近一个项目需要用到前端COS上传文件，网上找了很多教程都是不清不楚的，搞懂了写个文章记录。</p>\n<h1><strong><span style=\"color:#fe2c24;\">内容有点长，一点一点看</span></strong></h1>\n<p>VUE使用的是js的上传SDK，先给vue安装一下。</p>\n<pre><code class=\"language-javascript\">npm i cos-js-sdk-v5 --save</code></pre>\n<p><span style=\"color:#fe2c24;\"><strong>前端第一步的活儿干完了</strong></span>，然后就是后端，因为考虑安全问题，所以我使用了<span style=\"color:#fe2c24;\">临时密钥上传</span>。</p>\n<p>我的后端是Thinkphp6，所以采用了php的临时密钥生成的代码。</p>\n<ul><li>composer 安装临时生成密钥</li></ul>\n<pre><code>如果根目录有composer.json文件则将创建\"qcloud_sts/qcloud-sts-sdk\": \"3.0.*\"加入require里面\n否则创建composer.json的文件，内容如下：\n{\n    \"require\":{\n        \"qcloud_sts/qcloud-sts-sdk\": \"3.0.*\"\n    }\n}\n\n添加好了后命令提示符到后端根目录下执行  composer update</code></pre>\n<p> 安装好了后新建一个文件，或者控制器，弄好了，试一试访问有没有问题哈，没问题的话响应是这样的</p>\n<p><span style=\"color:#ff9900;\">{\"code\":10001,\"status\":\"success\",\"data\":{\"</span>expiredTime\":1651332681,\"expiration\":\"2022-04-30T15:31:21Z\",\"credentials\":{\"sessionToken\":\"xxxxxxxxxxxxxxxxxxx\",\"tmpSecretKey\":\"xxxxxxxxxxx=\"},\"requestId\":\"xxxxxxxxxx\",\"startTime\":xxxxxxx}}</p>\n<p></p>\n<p><span style=\"color:#ff9900;\">{\"code\":10001,\"status\":\"success\",\"data\":{<!-- --></span> 这一节是我自己加上去的</p>\n<p><span style=\"color:#fe2c24;\"><strong>下面是控制器的代码</strong></span></p>\n<pre><code class=\"language-php\">&lt;?php\n\ndeclare(strict_types=1);\n\nnamespace app\\controller;\n\nuse QCloud\\COSSTS\\Sts;\n\nclass Cos\n{\n    /**\n     * 获取临时密钥，计算签名\n     *\n     * @return \\think\\Response\n     */\n    public function index()\n    {\n        $sts = new Sts();\n        $config = array(\n            'url' =&gt; 'https://sts.tencentcloudapi.com/', // url和domain保持一致\n            'domain' =&gt; 'sts.tencentcloudapi.com', // 域名，非必须，默认为 sts.tencentcloudapi.com\n            'proxy' =&gt; '',\n            'secretId' =&gt; \"XXXXXXXXXXXXXXXXXX\", // 固定密钥,若为明文密钥，请直接以'xxx'形式填入，不要填写到getenv()函数中\n            'secretKey' =&gt; \"XXXXXXXXXXXXXXXXXX\", // 固定密钥,若为明文密钥，请直接以'xxx'形式填入，不要填写到getenv()函数中\n            'bucket' =&gt; \"储存桶名称\", // 换成你的 bucket\n            'region' =&gt; \"储存桶地区\", // 换成 bucket 所在园区\n            'durationSeconds' =&gt; 1800, // 密钥有效期\n            'allowPrefix' =&gt; '*', // 这里改成允许的路径前缀，可以根据自己网站的用户登录态判断允许上传的具体路径，例子： a.jpg 或者 a/* 或者 * (使用通配符*存在重大安全风险, 请谨慎评估使用)\n            // 密钥的权限列表。简单上传和分片需要以下的权限，其他权限列表请看 https://cloud.tencent.com/document/product/436/31923\n            'allowActions' =&gt; array(\n                // 简单上传\n                'name/cos:PutObject',\n                'name/cos:PostObject',\n                // 分片上传\n                'name/cos:InitiateMultipartUpload',\n                'name/cos:ListMultipartUploads',\n                'name/cos:ListParts',\n                'name/cos:UploadPart',\n                'name/cos:CompleteMultipartUpload'\n            )\n        );\n\n        // 获取临时密钥，计算签名\n        $tempKeys = $sts-&gt;getTempKeys($config);\n        return success($tempKeys);\n        //这个success()是我自己弄的个方法写在公共方法里的\n        //就像这样\n        //function success($data)\n        //{\n        //   return json(['code' =&gt; 10001, 'status' =&gt; 'success', 'data' =&gt; $data]);\n        //}\n    }\n}\n</code></pre>\n<p><strong><span style=\"color:#fe2c24;\">下一步流程</span></strong></p>\n<p>注意，我是使用的子账号，所以我有在腾讯云COS控制台配置权限，</p>\n<p><img alt=\"\" height=\"956\" src=\"image\\aeba86f1cc5d44acabc7849fd1a51389.png\" width=\"1200\"/></p>\n<p> 访问管理新建一个子用户，然后点击授权，搜索cos的，相关的权限都勾选上基本不会出问题。</p>\n<p>添加的时候应该会给你一个secretId和secretKey，记录下来，需要写入到上面的php控制器文件里的</p>\n<p>然后储存桶管理添加配置跨域规则跟防盗链哈 </p>\n<p><img alt=\"\" height=\"936\" src=\"image\\bf6350257b2e45b686d3bf638f95d0dc.png\" width=\"1200\"/></p>\n<p><img alt=\"\" height=\"399\" src=\"image\\e0953236c5f54db992a163a70dd42623.png\" width=\"1200\"/></p>\n<p><img alt=\"\" height=\"399\" src=\"image\\891751e96f0d4276abbaa9906641f34c.png\" width=\"1200\"/></p>\n<p> 储存桶管理里面配置子账户权限</p>\n<p><img alt=\"\" height=\"836\" src=\"image\\a0697b9bd1bc4754a1fbabed0b0f45ef.png\" width=\"1200\"/></p>\n<p> <span style=\"color:#fe2c24;\">存储桶访问权限</span>跟<span style=\"color:#fe2c24;\">Policy权限设置</span>这样设置就行了。</p>\n<p><a href=\"https://console.cloud.tencent.com/cos/diagnose\" title=\"自助诊断地址\">自助诊断地址</a> 记住这个地址，后面会用到。</p>\n<p>然后这个后端这一块儿配置完了。</p>\n<h1><span style=\"color:#ed7976;\">继续去配置前端的。</span></h1>\n<p>因为用了axios嘛，所以先给前端配置个API </p>\n<p>你们用的啥方法做http请求的就按自己的来哈，只要是个请求就行。</p>\n<p>这个是向后端请求临时密钥的接口，记得后端加个权限验证，登录了再给访问接口。</p>\n<p>cos.js文件，</p>\n<pre><code class=\"language-javascript\">import request from '@/utils/request'\n\nexport function getCos(params) {\n  return request({\n    url: '/Cos',\n    method: 'get',\n    params\n  })\n}\n</code></pre>\n<p>然后接口写好了就要访问嘛。</p>\n<p>新建一个js咯，这个里面引入了安装的sdk，跟上面的api，我这个文件放在路由的文件夹里面的，你看自个放哪儿都行</p>\n<pre><code class=\"language-javascript\">// 前端\n// cos.js\nimport COS from 'cos-js-sdk-v5';\nimport {\n  getCos\n} from '@/api/cos';\n// 初始化实例\nexport const cos = new COS({\n  // getAuthorization 必选参数\n  getAuthorization: function(options, callback) {\n    getCos().then(res =&gt; {\n      if (res.code == 10001) {\n        var credentials = res.data &amp;&amp; res.data.credentials;\n        if (!res || !credentials) return console.error('credentials invalid');\n        callback({\n          TmpSecretId: credentials.tmpSecretId,\n          TmpSecretKey: credentials.tmpSecretKey,\n          XCosSecurityToken: credentials.sessionToken,\n          // 建议返回服务器时间作为签名的开始时间，避免用户浏览器本地时间偏差过大导致签名错误\n          StartTime: res.data.startTime, // 时间戳，单位秒，如：1580000000\n          ExpiredTime: res.data.expiredTime, // 时间戳，单位秒，如：1580000900\n          // ScopeLimit: true, // 细粒度控制权限需要设为 true，会限制密钥只在相同请求时重复使用\n        });\n      }\n    })\n  }\n});\n</code></pre>\n<p><span style=\"color:#fe2c24;\">上面这个代码是我改过的，能用，然后再放一段官方的代码你们看需求用的这个还是官方这个。</span></p>\n<pre><code class=\"language-javascript\">var COS = require('cos-js-sdk-v5');\nvar cos = new COS({\n    // getAuthorization 必选参数\n    getAuthorization: function (options, callback) {\n        // 异步获取临时密钥\n        // 服务端 JS 和 PHP 例子：https://github.com/tencentyun/cos-js-sdk-v5/blob/master/server/\n        // 服务端其他语言参考 COS STS SDK ：https://github.com/tencentyun/qcloud-cos-sts-sdk\n        // STS 详细文档指引看：https://cloud.tencent.com/document/product/436/14048\n\n        var url = 'http://example.com/server/sts.php'; // url替换成您自己的后端服务\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', url, true);\n        xhr.onload = function (e) {\n            try {\n                var data = JSON.parse(e.target.responseText);\n                var credentials = data.credentials;\n            } catch (e) {\n            }\n            if (!data || !credentials) {\n              return console.error('credentials invalid:\\n' + JSON.stringify(data, null, 2))\n            };\n            callback({\n              TmpSecretId: credentials.tmpSecretId,\n              TmpSecretKey: credentials.tmpSecretKey,\n              SecurityToken: credentials.sessionToken,\n              // 建议返回服务器时间作为签名的开始时间，避免用户浏览器本地时间偏差过大导致签名错误\n              StartTime: data.startTime, // 时间戳，单位秒，如：1580000000\n              ExpiredTime: data.expiredTime, // 时间戳，单位秒，如：1580000000\n          });\n        };\n        xhr.send();\n    }\n});</code></pre>\n<p>，然后获取密钥的OK了，那肯定要发送了嘛，随便做一个点击事件写个方法测试下。</p>\n<pre><code class=\"language-javascript\">//先引入上面的文件哈\n  import {\n    cos\n  } from '@/router/cos'\n//然后写个方法里面这样的\ncos.putObject({\n   Bucket: 'edu-1255457652',\n     /* 必须 */\n    Region: 'ap-chengdu',\n     /* 存储桶所在地域，必须字段 */\n     Key: '1.jpg',\n     // 上传名称\n    body:'XXXX'\n    //文件上传对象或字符串\n   }, function(data) {\n            console.log(data);\n    });</code></pre>\n<p>我这里是成功的哈</p>\n<p><img alt=\"\" height=\"815\" src=\"image\\d4171ab0b06942b1b58cc8bc98b965a0.png\" width=\"1200\"/></p>\n<p> 既然能上传了，那就封装下。</p>\n<p>跟获取临时密钥的放一起不放一起都行</p>\n<pre><code class=\"language-javascript\">//引入COS获取密钥\nimport {\n  cos\n} from '@/router/cos'\n// 导出上传方法\nexport function uploadFile(file, keys) {\n  const key = 'Image/' + keys; // Key: 对象键（Object 的名称），对象在存储桶中的唯一标识\n  let res = Promise\n    .all([cos]) //获取临时密钥\n    .then((res) =&gt; {\n      return new Promise((resolve, reject) =&gt; {\n        cos.putObject({\n          Bucket: 'xxxxxxxxxx',\n          /* 后端返回的桶名称,我这里没有从后端返回 */\n          Region: 'xxxxxxxxxxx',\n          /* 桶的对应地区 */\n          Key: key,\n          /* 文件名，也是文件在桶里唯一的标识 */\n          StorageClass: 'STANDARD',\n          Body: file, // 上传文件对象\n          onProgress: function(progressData) {\n            // console.log(JSON.stringify(progressData));\n          }\n        }, function(err, data) { //回调函数\n          if (!err) {\n            //成功返回data对象\n            resolve(data);\n          } else {\n            //失败返回error信息\n            reject(err);\n          }\n        });\n      })\n    })\n  return res\n}\n</code></pre>\n<p>OK了，就这样，然后使用的话</p>\n<pre><code class=\"language-javascript\">  import {\n    uploadFile\n  } from '@/router/update'\n//引入是必须的\n\n//使用\nuploadFile('1.text，我是名称，也可以是md5加密名字加上.png/.jpg啥的','我是内容，也可以是视频，图片对象啥的，这个地方一般字符串或者对象形式').then(res=&gt;{\n            console.log(res);\n          })</code></pre>\n<p><span style=\"color:#fe2c24;\">到这儿就结束了，备忘一下。调试中出啥问题，都可以去自助诊断查询，实在不行提交工单，等待大佬技术支持。</span></p>\n</div>\n</div>"}