{"blogid": "123685978", "writerAge": "码龄2年", "writerBlogNum": "57", "writerCollect": "14702", "writerComment": "285", "writerFan": "4909", "writerGrade": "6级", "writerIntegral": "4525", "writerName": "程序媛张小妍", "writerProfileAdress": "writer_image\\profile_123685978.jpg", "writerRankTotal": "6222", "writerRankWeekly": "11919", "writerThumb": "2744", "writerVisitNum": "639857", "blog_read_count": "7606", "blog_time": "已于 2022-03-26 07:40:48 修改", "blog_title": "C++入门基础知识总结（2022整理）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h1 id=\"articleContentId\"><strong>一、C++入门基础知识之什么是C++?</strong></h1>\n<p>1982年，Bjarne Stroustrup博士在C语言的基础上引入并扩充了面向对象的概念，发明了一种新的程序语言。为了表达该语言与C语言的渊源关系，命名为C++。因此：C++是基于C语言而产生的，它既可以进行C语言的过程化程序设计，又可以进行以抽象数据类型为特点的基于对象的程序设计，还可以进行面向对象的程序设计。</p>\n<p><strong>C++入门基础知识PDF版、C++提高教程、C++电子书籍 获取 方式如下</strong></p>\n<p><strong>关注微信公众号：“ C和C加加 ” 回复关键字：“ C++ ”即可领取</strong></p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\782cd297caf6cc04c8f9ede97f5e448a.png\"/></p>\n<h1><strong>二、C++入门基础知识看看C++的历史版本</strong></h1>\n<ul><li> <p>C with classes 类及派生类、公有和私有成员、类的构造析构、友元、内联函数、赋值运算符重载等</p> </li><li> <p>C++1.0 添加虚函数概念，函数和运算符重载，引用、常量等</p> </li><li> <p>C++2.0 更加完善支持面向对象，新增保护成员、多重继承、对象的初始化、抽象类、静态成员以及const成员函数</p> </li><li> <p>C++3.0 进一步完善，引入模板，解决多重继承产生的二义性问题和相应构造和析构的处理</p> </li><li> <p>C++98 C++标准第一个版本，绝大多数编译器都支持，得到了国际标准化组织（ISO）和美国标准化协会认可，以模板方式重写C++标准库，引入了STL（标准模板库）</p> </li><li> <p>C++03 C++标准第二个版本，语言特性无大改变，主要∶修订错误、减少多异性</p> </li><li> <p>C++05 C++标准委员会发布了一份计数报告（Technical Report，TR1），正式更名C++0x，即∶计划在本世纪第一个10年的某个时间发布</p> </li><li> <p>C++11 增加了许多特性，使得C++更像一种新语言，比如∶正则表达式、基于范围for循环、auto关键字、新容器、列表初始化、标准线程库等</p> </li><li> <p>C++14 对C++11的扩展，主要是修复C++11中漏洞以及改进，比如∶泛型的lambda表达式，auto的返回值类型推导，二进制字面常量等</p> </li><li> <p>C++17 在C++11上做了一些小幅改进，增加了19个新特性，比如∶static_assert（）的文本信息可选，Fold表达式用于可变的模板，if和switch语句中的初始化器等</p> </li></ul>\n<h1><strong>三、C++入门基础知识关键字</strong></h1>\n<p>C++中总计有63个关键字：</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\fe535ded0184510264d4789c784b72f9.png\"/></p>\n<p><strong>其中画圈的是C语言的关键字。<code>这里要注意了：false和true并不是C语言的关键字。</code></strong></p>\n<h1><strong>四、C++入门基础之C++的命名空间</strong></h1>\n<p>在C/C++中，变量、函数和类都是大量存在的，这些变量、函数和类的名称都将作用于全局作用域中，可能会导致很多命名冲突。</p>\n<p>使用命名空间的目的就是对标识符和名称进行本地化，以避免命名冲突或名字污染，namespace关键字的出现就是针对这种问题的。</p>\n<p>定义命名空间，需要使用到namespace关键字，后面跟命名空间的名字，然后接一对{}即可，{}中即为命名</p>\n<p>空间的成员。</p>\n<p>注意：一个命名空间就定义了一个新的作用域，命名空间中的所有内容都局限于该命名空间中</p>\n<h2>1、命名空间的普通定义</h2>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\ae2270dbe2e81d44e25d2d94d20c24fd.png\"/></p>\n<h2>2、命名空间可以嵌套</h2>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\34b65ff2860c4212071b46d50700c82b.png\"/></p>\n<h2>3、同一个工程中允许存在多个相同名称的命名空间,编译器最后会合成同一个命名空间中。</h2>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\ddfee9309b458f600a312547d0d1033b.png\"/></p>\n<p>它会与上面的xjt命名空间合并</p>\n<h1>五、C++入门基础命名空间的使用</h1>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\09bb1102dd3afb92f04d14e2d899778e.png\"/></p>\n<p>很显然直接打印printf是不可能的，因为你这样调用的是printf的地址，所以会出现的这样的结果，正面的调用方法为以下三种。</p>\n<h2>1、加命名空间名称及作用域限定符</h2>\n<p>符号“::”在C++中叫做作用域限定符，我们通过“命名空间名称::命名空间成员”便可以访问到命名空间中相应的成员</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\2616413caa9f6f44f5c0155110c27614.png\"/></p>\n<h2>2、使用using namespace 命名空间名称引入</h2>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\8485be98342a5cb979b887f9a5d0162c.png\"/></p>\n<p>但是这种方式存在着一些弊端，如果我们在命名空间中定义了一个名字为printf的变量，那么之后再将namespace xjt这个命名空间引入的话，就会造成命名的污染了。</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\54de8116463745c7e30a3483b9ce9992.png\"/></p>\n<p>为了解决这个问题，出现了第三种引入方法。</p>\n<h2>3、使用using将命名空间中的成员引入</h2>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\a3631b75cd3235b5c897dee6a7912973.png\"/></p>\n<p>这种方法可以防止命名的污染，因为它只引入了一部分。</p>\n<h1><strong>六、C++入门基础知识的输入和输出</strong></h1>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\8cc98d3916803118663b51b461e5c038.png\"/></p>\n<p>在C语言中有标准输入输出函数scanf和printf，而在C++中有cin标准输入和cout标准输出。在C语言中使用scanf和printf函数，需要包含头文件stdio.h。在C++中使用cin和cout，需要包含头文件iostream以及std标准命名空间。</p>\n<p>C++的输入输出方式与C语言更加方便，因为C++的输入输出不需要控制格式，例如：整型为%d，字符型为%c。</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\d58924865966f27b473a0310227439f8.png\"/></p>\n<p>注意：endl，这其中的l不是阿拉伯数字1，而是26个英文字母的l，它的作用相当于换行。</p>\n<p>这里我们还要注意下cin的特点，他和C语言中的gets有些像，gets是遇到换行符停止，而cin是以遇到空格，tab或者换行符作为分隔符的，因此这儿输入hello world会被空格符分隔开来。</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\e2d006efd063adefd50fb66542ea54df.png\"/></p>\n<p>这儿我输入的是hello world，但因为输入时出现了空格，所以之后的内容并不会读入，因此arr中存的就是hello。</p>\n<h1><strong>七、C++入门基础知识-缺省参数</strong></h1>\n<p>缺省参数是声明或定义函数时为函数的参数指定一个默认值。在调用该函数时，如果没有指定实参则采用该<br/> 默认值，否则使用指定的实参。</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\36d3a428d73f82353cb1d6377b5c618a.png\"/></p>\n<p></p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\9f59d18de533258b9e3b9e646f8a4af9.png\"/></p>\n<h2><strong>1、全缺省</strong></h2>\n<p>全缺省参数，即函数的全部形参都设置为缺省参数。</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\7961e2e4db913711650429e8abea233d.png\"/></p>\n<h2><strong>2、半缺省参数</strong></h2>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\4aa6efe14dfaa401b88660eadb32801a.png\"/></p>\n<p>注意： </p>\n<ul><li> <p>半缺省参数必须从右往左依次给出，不能间隔着给。</p> </li></ul>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\4afd40a07d01b4fa800399d3f583f3e1.png\"/></p>\n<ul><li> <p>缺省参数不能在函数声明和定义中同时出现</p> </li></ul>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\5839f356c1c331fc0a7c0ed2386be99f.png\"/></p>\n<p>因为：如果声明与定义位置同时出现，恰巧两个位置提供的值不同，那编译器就无法确定到底该用那个缺省值。</p>\n<ul><li> <p>缺省值必须是常量或者全局变量。</p> </li></ul>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\18cecc2fadc753477c9a7dddf29ca15e.png\"/></p>\n<h1><strong>八、C++入门基础-C++函数重载</strong></h1>\n<h2>1、函数重载</h2>\n<p>函数重载是函数的一种特殊情况，C++允许在<strong>同一作用域</strong>中声明几个功能类似的<strong>同名</strong><strong>函</strong><strong>数</strong>，这些同名函数的<strong>形参列表(参数个数 或 类型 或 顺序)必须不同</strong>，常用来处理实现功能类似数据类型不同的问题</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\4df2e071ed29a7f2228c87a56a0ba9d3.png\"/></p>\n<p>注意：若仅仅只有返回值不同，其他都相同，则不构成函数重载。</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\ebd5a6afce4dd69c3611c7621b9c82e4.png\"/></p>\n<h2><strong>2、C++函数重载的原理</strong></h2>\n<p>为什么C++支援函数重载，而C语言不可以了？</p>\n<p>这里我们就要回顾一下以前的知识了，在运行到执行文件前，要经过：预编译，编译，汇编，链接这些阶段</p>\n<p>其实问题就出在编译完之后的汇编阶段，因为在这里C++和C语言有着些许的不同，下面我们来看看：</p>\n<p>采用C语言编译器编译之后</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\688df54b347bdb7238b85026584fe012.png\"/></p>\n<p>采用C++编译器编译之后</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\a901da76f32cd93c1ba298c0f4f0c0f1.png\"/></p>\n<p>总结：</p>\n<ul><li> <p>其实归根到底，还是因为C编译器和C++编译器对函数名的修饰不同。在gcc下的修饰规则是：【_Z+函数长度+函数名+类<br/> 型首字母】。</p> </li><li> <p>这其实也告诉我们为什么函数的返回类型不同，不会构成函数重载，因为修饰规则并不会受返回值的影响。</p> </li></ul>\n<h2>3、extern “C”</h2>\n<p>有时候在C++工程中可能需要将某些函数按照C的风格来编译，在函数前加extern “C”，意思是告诉编译器，</p>\n<p>将该函数按照C语言规则来编译。比如：tcmalloc是google用C++实现的一个项目，他提供tcmallc()和tcfree</p>\n<p>两个接口来使用，但如果是C项目就没办法使用，那么他就使用extern “C”来解决。</p>\n<h1>九、C++入门基础知识-引用</h1>\n<h2><strong>1、引用</strong></h2>\n<p>引用不是新定义一个变量，<strong>而是给已存在变量取了一个别名</strong>，编译器不会为引用变量开辟内存空间，它和它<br/> 引用的变量<strong>共用同一块内存空间</strong>。</p>\n<p>类型&amp; 引用变量名(对象名) = 引用实体；</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\0c532905f7e543dbb74b0b9dbab0e595.png\"/></p>\n<p></p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\a65758b158aa06d5b0a8a29cee124892.png\"/></p>\n<p>注意：引用类型必须和引用实体是同种类型的</p>\n<h2><strong>2、引用的特征</strong></h2>\n<ul><li> <p>引用在定义时必须初始化</p> </li></ul>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\51d53dd70115c0b6dc816e02f80040e0.png\"/></p>\n<p></p>\n<ul><li> <p>一个变量可以有多个引用</p> </li></ul>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\654c989dfa3691a680fe8700c4854a33.png\"/></p>\n<p></p>\n<ul><li> <p>引用一旦引用了一个实体，就不能再引用其他实体</p> </li></ul>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\7e390020d96ce6c04a6634adccb988c6.png\"/></p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\e83b0c68c02b0bc5b5d864f8a2ea82db.png\"/></p>\n<p>但实际的效果，确实将c的值赋值给b，又因为b是a的引用，所以a的值见解变成了20。</p>\n<h2><strong>3、常引用</strong></h2>\n<p>上面提到，引用类型必须和引用实体是同种类型的。但是仅仅是同种类型，还不能保证能够引用成功，这儿我们还要注意可否可以修改的问题。</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\e78ccb8d4be7a1fb7274b00d76485ba0.png\"/></p>\n<p>这里的a，b，d都是常量，常量是不可以被修改的，但是如果你用int&amp;ra等这样来引用a的话，那么引用的这个a是可以被修改的，因此会出问题。<br/> 下面我们来看这么一段代码：</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\449a5bb08b4d60af913bda1e3ff5382f.png\"/></p>\n<p>这个引用对吗？想要弄明白这个问题，首先要明白隐士类型提升的问题，在这里int到double存在隐士类型的提升，而在提升的过程中系统会创建一个常量区来存放a类型提升后的结果。因此到这儿，这段代码一看就是错了，因为你隐士类型提升时a是存放在常量区中的，常量区是不可以被修改的，而你用double&amp;ra去引用他，ra这个引用是可以被修改的。</p>\n<p>加个const就可以解决这个问题。</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\a5c6d2a51d10750ca72c49240d157b9d.png\"/></p>\n<p>注意：将不可修改的量用可读可写的量来引用是不可以的，但是反过来是可以的，将可读可写的量用只可读的量来引用是可以的。</p>\n<h2><strong>4、引用的使用场景</strong></h2>\n<ul><li> <p>引用做参数</p> <p>还记得C语言中的交换函数，学习C语言的时候经常用交换函数来说明传值和传址的区别。现在我们学习了引用，可以不用指针作为形参了。因为在这里a和b是传入实参的引用，我们将a和b的值交换，就相当于将传入的两个实参交换了。</p> </li></ul>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\f80980e429d23080c6b93ae8d1a486d5.png\"/></p>\n<ul><li> <p>引用做返回值</p> <p>当然引用也能做返回值，但是要特别注意，我们返回的数据不能是函数内部创建的普通局部变量，因为在函数内部定义的普通的局部变量会随着函数调用的结束而被销毁。我们返回的数据必须是被static修饰或者是动态开辟的或者是全局变量等不会随着函数调用的结束而被销毁的数据。</p> <p>不加static的后果</p> </li></ul>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\cef638a774610953895d8411b99c3ff9.png\"/></p>\n<p>你是不是疑惑为什么打印的不是2而是7了？</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\9721a0b10639fe219ea413b6597faff8.png\"/></p>\n<p>这就更奇怪了，为什么中间加了一句printf，就打印随机值了？<br/> 下面我们来看看分析：</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\883fdd3ed6a9ff07b80af1daf5c1f41e.png\"/></p>\n<p></p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\883fdd3ed6a9ff07b80af1daf5c1f41e.png\"/></p>\n<p><em><strong>为什么会出现随机值，因为你在函数里定义的变量是临时变量，出了函数函数是会销毁的，这时它就随机指向内存中的一块空间了</strong></em>。所以在引用做函数返回值时最好还是给在函数中定义的变量加上static。</p>\n<p>这时你觉得你真的懂这段代码了吗？</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\634167e5b4cfd4d6c972842e26b44a44.png\"/></p>\n<p></p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\8d39a955b6c00ae1392e6c10485363e8.png\"/></p>\n<p>可能你会好奇了？为什么这儿是3了？下面来看看分析</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\44dade541b062dede455c9491fc8c4c6.png\"/></p>\n<p>其实你换种写法，这儿的结果就会换成7，原因也很简单，正是上面图片中说的原因</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\90af064d4fa88a5c981c3f96043a1063.png\"/></p>\n<p>注意：如果函数返回时，出了函数作用域，返回对象还未还给系统，则可以使用引用返回；如果已经还给系统了，则必须使用传值返回。<br/> 这句话说的是下面这种例子：</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\cbbb7fa724b2e9d3233cd2c0947f79b8.png\"/></p>\n<p>大家是不是感觉这个传引用返回用起来很怪了，下面我们来分析一下它是如何返回的。</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\734ba4b12c4d22cedb6d48d20605b12d.png\"/></p>\n<p>总结：<br/><code>传值的过程中会产生一个拷贝，而传引用的过程中不会，其实在做函数参数时也具有这个特点。</code></p>\n<h2><strong>5、引用和指针的区别</strong></h2>\n<p>在语法概念上引用就是一个别名，没有独立空间，和其引用实体共用同一块空间。</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\b2bb1172eae45d8cffcc415b69ca01ab.png\"/></p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\c5f06ecbdf6efc5d2cf2455cafabd8d7.png\"/></p>\n<p>在底层实现上实际是有空间的，因为引用是按照指针方式来实现的。</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\eed1bc223b0bf6f356fc3a5fd1a00006.png\"/></p>\n<p>我们来看下引用和指针的汇编代码对比</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\bb18eff589f05678bb53bd349a3215c5.png\"/></p>\n<p>引用和指针的区别</p>\n<ul><li> <p>引用在定义时必须初始化，指针没有要求。</p> </li><li> <p>引用在初始化时引用一个实体后，就不能再引用其他实体，而指针可以在任何时候指向任何一个同类型实体。</p> </li><li> <p>没有NULL引用，但有NULL指针。</p> </li><li> <p>在sizeof中的含义不同：引用的结果为引用类型的大小，但指针始终是地址空间所占字节个数（32位平台下占4个字节）。</p> </li><li> <p>引用进行自增操作就相当于实体增加1，而指针进行自增操作是指针向后偏移一个类型的大小。</p> </li><li> <p>有多级指针，但是没有多级引用。</p> </li><li> <p>访问实体的方式不同，指针需要显示解引用，而引用是编译器自己处理。</p> </li><li> <p>引用比指针使用起来相对更安全。</p> </li></ul>\n<h1>十、C++入门基础知识-内联函数</h1>\n<h2>1、概念</h2>\n<p>以inline修饰的函数叫做内联函数，编译时C++编译器会在<strong>调用内联函数的地方展开</strong>，没有函数压栈的开销，<br/> 内联函数提升程序运行的效率。（看到在加粗部分时，小伙伴肯定会想，这和c语言中的宏是不是很像了？）</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\48ec10787638f33337a2b734dcc874cf.png\"/></p>\n<p>如果在上述函数前增加inline关键字将其改成内联函数，在编译期间编译器会用函数体替换函数的调用</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\4f1629ab40c2421aa83138ea68f9516d.png\"/></p>\n<h2>2、特性</h2>\n<ul><li> <p>inline是一种以空间换时间的做法，省去调用函数额开销。所以代码很长/递归的函数不适宜使用作为内联函数。</p> </li><li> <p>inline对于编译器而言只是一个建议，编译器会自动优化，如果定义为inline的函数体内代码比较长/递归等等，编译器优化时会忽略掉内联。</p> </li><li> <p>inline不建议声明和定义分离，分离会导致链接错误。因为inline被展开，就没有函数地址了，链接就会找不到</p> </li></ul>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\02c1bd1a60dc4984d94c491053dfa66b.png\"/></p>\n<p>c++有哪些技术可以代替宏</p>\n<ul><li> <p>常量定义 换用const</p> </li><li> <p>函数定义 换用内联函数</p> </li></ul>\n<h1><strong>十一、auto关键字(C++11)</strong></h1>\n<p>在早期的C/C++中auto的含义是：使用auto修饰的变量是具有自动存储器的局部变量，但遗憾的是一直没有人去使用它。</p>\n<p>在C++11中，标准委员会赋予了auto全新的含义：auto不再是一个存储类型指示符，而是作为一个新的类型指示符来指示编译器，auto声明的变量必须由编译器在编译时期推导而得。 可能光看这一句话，你不一定能懂，下面我们举几个例子。</p>\n<pre><code class=\"language-cpp\">#include&lt;iostream&gt;\n\nusing namespace std;\n\nint TestAuto()\n\n{\n\nreturn 10;\n\n}\n\nint main()\n\n{\n\nint a = 10;\n\nauto b = a;\n\nauto c = 'a';\n\nauto d = TestAuto();\n\n\n\ncout &lt;&lt; typeid(b).name() &lt;&lt; endl; //这个地方要学到后面类的时候才可以解释，这里打印出的是类型名\n\ncout &lt;&lt; typeid(c).name() &lt;&lt; endl;\n\ncout &lt;&lt; typeid(d).name() &lt;&lt; endl;\n\n\n\ncout &lt;&lt; a &lt;&lt; endl;\n\ncout &lt;&lt; b&lt;&lt; endl;\n\ncout &lt;&lt; c &lt;&lt; endl;\n\ncout &lt;&lt; d &lt;&lt; endl;\n\n\n\n//auto e; 无法通过编译，使用auto定义变量时必须对其进行初始化\n\nreturn 0;\n\n}</code></pre>\n<p></p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\18bc9ccac3ff54419f62ff403d92338b.png\"/></p>\n<p>注意：使用auto定义变量时必须对其进行初始化，在编译阶段编译器需要根据初始化表达式来推导auto的实际类型。因此auto并非是一种“类型”的声明，而是一个类型声明时的“占位符”，编译器在编译期会将auto替换为<br/> 变量实际的类型。</p>\n<h2><strong>1、auto的使用细则</strong></h2>\n<ul><li> <p>auto与指针和引用结合起来使用</p> </li></ul>\n<p>用auto声明指针类型时，用auto和auto*没有任何区别，但用auto声明引用类型时则必须加&amp;</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\0d7e931cc91828ae93ae83470eddd761.png\"/></p>\n<p></p>\n<p>注意：用auto声明引用时必须加&amp;，否则创建的只是与实体类型相同的普通变量，只不过将其换了个姓名而已。</p>\n<ul><li> <p>在同一行定义多个变量</p> </li></ul>\n<p>当在同一行声明多个变量时，这些变量必须是相同的类型，否则编译器将会报错，因为编译器实际只对<br/> 第一个类型进行推导，然后用推导出来的类型定义其他变量。</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\8f5317f4814c6e6f92eab4412ee90c5e.png\"/></p>\n<h2><strong>2、auto不能推导的场景</strong></h2>\n<ul><li> <p>auto做为函数的参数</p> </li></ul>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\8f8f070086ce2c1b4e5e747240cf635a.png\"/></p>\n<ul><li> <p>auto不能直接用来声明数组</p> </li></ul>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\f952f4a7877da681e7df94bf41fa9d21.png\"/></p>\n<p>为了避免与C++98中的auto发生混淆，C++11只保留了auto作为类型指示符的用法<br/> auto在实际中最常见的优势用法就是跟以后会讲到的C++11提供的新式for循环，还有lambda表达式等进行配合使用。</p>\n<h1><strong>十二、C++入门基础知识基于范围的for循环（C++11)</strong></h1>\n<h2>1、范围for的语法</h2>\n<p>在C++98中如果要遍历一个数组，可以按照以下方式进行：</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\2e605716868e683af7f2a2a5096bc351.png\"/></p>\n<p>对于一个有范围的集合而言，由程序员来说明循环的范围是多余的，有时候还会容易犯错误。因此C++11中</p>\n<p>引入了基于范围的for循环。for循环后的括号由冒号“ ：”分为两部分：第一部分是范围内用于迭代的变量，第二部分则表示被迭代的范围。</p>\n<p>注意不能写成auto，不然改变不了原数组</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\c87328df0abef2dcf8aff15c05642246.png\"/></p>\n<p>正确的写法</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\60fab5fbe601174b9abe043edcaf5890.png\"/></p>\n<p>注意：与普通循环类似，可用continue来结束本次循环，也可以用break来跳出整个循环。</p>\n<h2><strong>2、范围for的使用条件</strong></h2>\n<ul><li> <p>for循环迭代的范围必须是确定的</p> </li></ul>\n<blockquote>\n<p>对于数组而言，就是数组中第一个元素和最后一个元素的范围；对于类而言，应该提供begin和end的<br/> 方法，begin和end就是for循环迭代的范围。</p>\n</blockquote>\n<blockquote>\n<p>注意：以下代码就有问题，因为for的范围不确定</p>\n</blockquote>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\5af196f5d2c6d06b964d0211dd499f1d.png\"/></p>\n<ul><li> <p>迭代的对象要实现++和==的操作。</p> </li></ul>\n<blockquote>\n<p>关于迭代器这个问题，以后会讲，现在大家了解一下就可以了。</p>\n</blockquote>\n<h1>十三、C++入门基础-指针空值nullptr</h1>\n<h2>1、C++98中的指针空值</h2>\n<blockquote>\n<p>在良好的C/C++编程习惯中，在声明一个变量的同时最好给该变量一个合适的初始值，否则可能会出现不可预料的错误。比如未初始化的指针，如果一个指针没有合法的指向，我们基本都是按如下方式对其进行初始化：</p>\n</blockquote>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\368738a18a77dcac44255070147261c6.png\"/></p>\n<p>NULL其实是一个宏，在传统的C头文件(stddef.h)中可以看到如下代码：</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\16548de38c36959df732c6a8c0684932.png\"/></p>\n<p>可以看到，NULL可能被定义为字面常量0，或者被定义为无类型指针(void*)的常量。不论采取何种定义，在使用空值的指针时，都不可避免的会遇到一些麻烦，比如：</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\9822d4cf154cb73b43b7832a04eb9ad0.png\"/></p>\n<p>程序本意本意是想通过Fun(NULL)调用指针版本的Fun(int* p)函数，但是由于NULL被定义为0，Fun(NULL)最终调用的是Fun(int p)函数。</p>\n<p>注：在C++98中字面常量0，既可以是一个整型数字，也可以是无类型的指针(void*)常量，但编译器默认情况下将其看成是一个整型常量，如果要将其按照指针方式来使用，必须对其进行强制转换。</p>\n<h2><strong>2、C++11中的指针空值</strong></h2>\n<p>对于C++98中的问题，C++11引入了关键字nullptr。</p>\n<p>在使用nullptr表示指针空值时，不需要包含头文件，因为nullptr是C++11作为关键字引入的。</p>\n<p>在C++11中，sizeof(nullptr)与sizeof((void*)0)所占的字节数相同，大小都为4。</p>\n<h1><strong>最后</strong></h1>\n<h3><strong>C++入门基础知识PDF版、C++提高教程、C++电子书籍 获取 方式如下</strong></h3>\n<p>关注微信公众号：“ C和C加加 ” 回复关键字：“ C++ ”即可领取</p>\n</div>\n</div>"}