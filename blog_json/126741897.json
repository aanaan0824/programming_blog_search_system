{"blogid": "126741897", "writerAge": "码龄1年", "writerBlogNum": "62", "writerCollect": "22", "writerComment": "18", "writerFan": "285", "writerGrade": "3级", "writerIntegral": "731", "writerName": "Bonsoir777", "writerProfileAdress": "writer_image\\profile_126741897.jpg", "writerRankTotal": "26352", "writerRankWeekly": "2786", "writerThumb": "97", "writerVisitNum": "6456", "blog_read_count": "10", "blog_time": "于 2022-09-07 11:47:10 发布", "blog_title": "ES6——ES6语法之箭头函数、剩余参数", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h1><a id=\"_0\"></a></h1>\n<div>\n<h3>文章目录</h3>\n<ul><li><a href=\"#_12\"><span style=\"color:#6eaad7;\">前言</span></a></li><li><span style=\"color:#6eaad7;\">一</span><a href=\"#_26\"><span style=\"color:#6eaad7;\">、</span></a><span style=\"color:#6eaad7;\">箭头函数</span>\n<ul><li><span style=\"color:#6eaad7;\">1. 基础语法</span></li><li><a href=\"#2_41\"><span style=\"color:#6eaad7;\">2.</span></a><span style=\"color:#6eaad7;\"> 省略写法</span></li><li><span style=\"color:#6eaad7;\">3.  this 指向问题</span></li><li><span style=\"color:#6eaad7;\">3.1 普通函数中的this</span></li><li><span style=\"color:#6eaad7;\">3.2  对象方法里的this</span></li><li><span style=\"color:#6eaad7;\">3.3  构造函数对象的this</span></li><li><span style=\"color:#6eaad7;\">3.4 apply/call调用时的this</span></li><li><span style=\"color:#6eaad7;\">3.5 箭头函数中this</span></li></ul></li><li><a href=\"#_26\"><span style=\"color:#6eaad7;\">二、</span></a><span style=\"color:#6eaad7;\">剩余参数</span>\n<ul><li><span style=\"color:#6eaad7;\">1. 传不定参数</span></li><li><span style=\"color:#6eaad7;\">2.  剩余参数与解构使用</span></li></ul></li><li><a href=\"#_55\"><span style=\"color:#6eaad7;\">总结</span></a></li></ul>\n</div>\n<p></p>\n<hr/>\n<h1><a id=\"_12\"></a>前言</h1>\n<p>在前文我们介绍了ES6中的let，const……今天书接上回，继续说ES6中的相关知识点吧！</p>\n<hr/>\n<h1><a id=\"pandas_22\"></a>一、箭头函数</h1>\n<h2>1. 基础语法</h2>\n<blockquote>\n<p style=\"margin-left:0;text-align:justify;\"><strong>语法：</strong>() =&gt;{} // ():函数 =&gt;:必须的语法，指向代码块 {}:代码块</p>\n</blockquote>\n<blockquote>\n<p style=\"margin-left:0;text-align:justify;\"><strong>举例：</strong></p>\n<p style=\"margin-left:0;text-align:justify;\"><span style=\"color:#fe2c24;\">//原js写法</span></p>\n<p style=\"margin-left:0;text-align:justify;\">function myFun(k,v){     </p>\n<p style=\"margin-left:0;text-align:justify;\">      return k + v;</p>\n<p style=\"margin-left:0;text-align:justify;\">}</p>\n<p style=\"margin-left:0;text-align:justify;\"><span style=\"color:#fe2c24;\">//es6 写法</span></p>\n<p style=\"margin-left:0;text-align:justify;\">const myFun1 = (k,v) =&gt; {<!-- --></p>\n<p style=\"margin-left:0;text-align:justify;\">      return k+v;</p>\n<p style=\"margin-left:0;text-align:justify;\">}</p>\n</blockquote>\n<h2 style=\"margin-left:0px;text-align:justify;\">2. 省略写法</h2>\n<blockquote>\n<p style=\"margin-left:0;text-align:justify;\"><strong>如果形参或者代码块只有一句可以简写：</strong></p>\n<p style=\"margin-left:0;text-align:justify;\">例如：</p>\n<p style=\"margin-left:0;text-align:justify;\">Const myFun = (k) =&gt; {return k+1;} 简写：</p>\n<p style=\"margin-left:0;text-align:justify;\"></p>\n<p style=\"margin-left:0;text-align:justify;\">Const myFun = k =&gt;  k +1;</p>\n</blockquote>\n<h2><a id=\"_26\"></a><span style=\"color:#fe2c24;\">3. this 指向问题</span></h2>\n<h3>3.1  普通函数中的this</h3>\n<blockquote>\n<p style=\"margin-left:0;text-align:justify;\"><strong>案例解析——</strong></p>\n<p style=\"margin-left:0;text-align:justify;\">这是一个普通函数,globalTest()是全局性的方法，属于全局性调用，因此this就代表全局对象window。</p>\n</blockquote>\n<pre><code class=\"language-javascript\">var name = \"global this\";\nfunction globalTest() {\n\nconsole.log(this);//window\nconsole.log(this.name);//global this\nThis.name = “global this change”;\n\n}\nglobalTest(); \n</code></pre>\n<h3>3.2  <strong>对象方法里的this</strong></h3>\n<blockquote>\n<p><strong>案例解析——</strong></p>\n<p>如果函数作为对象的方法调用，this指向的是这个上级对象，即调用方法的对象。</p>\n</blockquote>\n<pre><code class=\"language-javascript\">const person = {\n\t\t\t   name:\"张三\",\n\t\t\t   age:18,\n\t\t\t   say:function(){\n\t\t\t\t  console.log(this.name);// 张三 这时候的this是person的对象\n\t\t\t   }\n }\nperson.say();\n</code></pre>\n<h3>3.3  <strong>构造函数对象的</strong><strong>this</strong></h3>\n<blockquote>\n<p><strong>案例解析——</strong></p>\n<p>构造函数中的this指向新创建的对象本身。</p>\n</blockquote>\n<pre><code class=\"language-javascript\">var name = \"golbal\";\n function person(name,age){\n\t\t\t   this.name = name,\n\t\t\t   this.age = age,\n\t\t\t   this.say = function (){\n\t\t\t\t   console.log(this.name,this.age);\n\t\t\t   }  \n }\nconst person1 = new person(\"张三\",18);\nconst person2 = new person(\"小帅\",19);\nperson1.say();\nperson2.say()\n</code></pre>\n<h3>3.4 <strong>apply/call</strong><strong>调用时的</strong><strong>this</strong></h3>\n<blockquote>\n<p style=\"margin-left:0;text-align:justify;\"><span style=\"color:#fe2c24;\"><strong>call(thisObj，Object) </strong>调用一个对象的一个方法，以另一个对象替换当前对象。</span></p>\n<p style=\"margin-left:0;text-align:justify;\"></p>\n<p style=\"margin-left:0;text-align:justify;\"><strong>说明：</strong>call 方法可以用来代替另一个对象调用一个方法。call 方法可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。如果没有提供 thisObj 参数，那么 Global 对象被用作 thisObj。</p>\n</blockquote>\n<pre><code class=\"language-javascript\">const person1 = {name:\"张三\",age:18};\nvar name = \"G_张三\",age = \"G_18\";\n\t\t\nfunction myfun1(){\n\t\tconsole.log(this.name,this.age);\n }\nmyfun1();//对象是Windows\nmyfun1.call(person1);//对象改变为person1\n\n</code></pre>\n<blockquote>\n<p style=\"margin-left:0;text-align:justify;\"><span style=\"color:#fe2c24;\"><strong>call  apply  两者的区别——</strong></span>myfun.call(person,18,29); myfun.apply(person,[18,29]);</p>\n</blockquote>\n<h3>3.5 <strong>箭头函数中</strong><strong>this</strong></h3>\n<blockquote>\n<p style=\"margin-left:0;text-align:justify;\">箭头函数不绑定this关键字，箭头函数中的this，指向的是函数定义位置的上下文this。</p>\n<p style=\"margin-left:0;text-align:justify;\">箭头函数中的this指向是它所定义（声明）的位置，可以简单理解成，<span style=\"color:#fe2c24;\"><strong>定义箭头函数中的作用域的this指向谁，它就指向谁。</strong></span></p>\n</blockquote>\n<pre><code class=\"language-javascript\">const obj = { name: '张三'} \n\t\t function fn () { \n\t\t\t console.log(this);//this 指向 是obj对象\n\t\t\t return () =&gt; { \n\t\t\t\t console.log(this);//this 指向 的是箭头函数定义的位置，那么这个箭头函数定义在fn里面，而这个fn指向是的obj对象，所以这个this也指向是obj对象\n\t\t\t } \n\t\t } \n\t\t\nconst resFn = fn.call(obj); //{ name: '张三'} \nresFn();//{ name: '张三'} \n</code></pre>\n<h1>二、剩余参数</h1>\n<blockquote>\n<p style=\"margin-left:0;text-align:justify;\"><span style=\"color:#fe2c24;\"><strong>剩余参数</strong></span>语法允许我们将一个不定数量的参数表示为一个数组，不定参数定义方式，这种方式很方便的去声明不知道参数情况下的一个函数。<code class=\"language-c\"> </code></p>\n</blockquote>\n<h2><a id=\"2_41\"></a>1. <strong>传不定参数</strong></h2>\n<pre><code class=\"language-javascript\">function myfun(k1,...k2){\n\t\t\tconsole.log(k1);//10\n\t\t\tconsole.log(k2);//(2) [20, 30]\n}\nmyfun(10,20,30);\n</code></pre>\n<h2>2.  <strong>剩余参数与解构使用</strong></h2>\n<p><strong>案例一：</strong></p>\n<pre><code class=\"language-javascript\">\nlet numarr = [1,2,3];\nlet [num1,...numx] = numarr;\nconsole.log(num1);//1\nconsole.log(numx);// [2,3]\n\n\n</code></pre>\n<p><strong>案例二：</strong></p>\n<pre><code class=\"language-javascript\">function connect({host,port,username,password}){\n\tconsole.log(host);\n}\n\t\nconnect({\n\thost:\"127.0.0.1\",\n\tport:\"3306\",\n\tusername:\"root\",\n\tpassword:\"root\"\n})\n</code></pre>\n<hr/>\n<h1><a id=\"_55\"></a>总结</h1>\n<p>就此停笔，最后，依旧诚挚祝福看到这篇小文的人有个好心情。</p>\n</div>\n</div>"}