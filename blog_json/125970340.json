{"blogid": "125970340", "writerAge": "码龄1年", "writerBlogNum": "103", "writerCollect": "4587", "writerComment": "4391", "writerFan": "6375", "writerGrade": "7级", "writerIntegral": "13410", "writerName": "@每天都要敲代码", "writerProfileAdress": "writer_image\\profile_125970340.jpg", "writerRankTotal": "799", "writerRankWeekly": "90", "writerThumb": "4869", "writerVisitNum": "81108", "blog_read_count": "711", "blog_time": "已于 2022-08-09 23:17:23 修改", "blog_title": "深入理解多线程（第一篇）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<blockquote>\n<p>✅作者简介：大家好我是@每天都要敲代码，一位材料转码农的选手，希望一起努力，一起进步！<br/> 📃个人主页：<a href=\"https://blog.csdn.net/m0_61933976?spm=1010.2135.3001.5421\" title=\"@每天都要敲代码的个人主页\">@每天都要敲代码的个人主页</a></p>\n<p>🔥系列专栏：<a class=\"link-info\" href=\"https://blog.csdn.net/m0_61933976/category_11820121.html?spm=1001.2014.3001.5482\" title=\"JavaSE从入门到精通\">JavaSE从入门到精通</a><br/> 💬推荐一款模拟面试、刷题神器，从基础到大厂面试题👉<a href=\"https://www.nowcoder.com/link/pc_csdncpt_mtdyqdm_c\" title=\"点击跳转刷题网站进行注册学习\">点击跳转刷题网站进行注册学习</a></p>\n</blockquote>\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%C2%A0%E4%B8%80%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A6%82%E8%BF%B0-toc\" style=\"margin-left:0px;\"><a href=\"#%C2%A0%E4%B8%80%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A6%82%E8%BF%B0\"> 一：进程与多线程概述</a></p>\n<p id=\"1.%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E7%9A%84%E7%90%86%E8%A7%A3%C2%A0-toc\" style=\"margin-left:80px;\"><a href=\"#1.%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E7%9A%84%E7%90%86%E8%A7%A3%C2%A0\">1.多线程并发的理解 </a></p>\n<p id=\"2.%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F%E5%AD%98%E5%9C%A8%E5%87%A0%E4%B8%AA%E7%BA%BF%E7%A8%8B-toc\" style=\"margin-left:80px;\"><a href=\"#2.%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F%E5%AD%98%E5%9C%A8%E5%87%A0%E4%B8%AA%E7%BA%BF%E7%A8%8B\">2.分析程序存在几个线程</a></p>\n<p id=\"%F0%9F%A5%85%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F-toc\" style=\"margin-left:0px;\"><a href=\"#%F0%9F%A5%85%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F\">二：实现线程的两种方式</a></p>\n<p id=\"1.%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9A%E7%9B%B4%E6%8E%A5%E7%BB%A7%E6%89%BFThread%EF%BC%8C%E9%87%8D%E5%86%99run%E6%96%B9%E6%B3%95-toc\" style=\"margin-left:80px;\"><a href=\"#1.%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9A%E7%9B%B4%E6%8E%A5%E7%BB%A7%E6%89%BFThread%EF%BC%8C%E9%87%8D%E5%86%99run%E6%96%B9%E6%B3%95\">1.第一种方式：直接继承Thread，重写run方法</a></p>\n<p id=\"2.%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9A%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3%EF%BC%8C%E9%87%8D%E5%86%99run%E6%96%B9%E6%B3%95-toc\" style=\"margin-left:80px;\"><a href=\"#2.%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9A%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3%EF%BC%8C%E9%87%8D%E5%86%99run%E6%96%B9%E6%B3%95\">2.第二种方式：实现Runnable接口，重写run方法</a></p>\n<p id=\"3.%E9%87%87%E7%94%A8%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E6%96%B9%E5%BC%8F-toc\" style=\"margin-left:80px;\"><a href=\"#3.%E9%87%87%E7%94%A8%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E6%96%B9%E5%BC%8F\">3.采用匿名内部类的方式</a></p>\n<p id=\"%F0%9F%A5%85%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-toc\" style=\"margin-left:0px;\"><a href=\"#%F0%9F%A5%85%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F\">三：线程生命周期</a></p>\n<p id=\"%E5%9B%9B%EF%BC%9A%E7%BA%BF%E7%A8%8B%E7%AE%80%E5%8D%95%E5%AE%9E%E6%93%8D-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%9B%9B%EF%BC%9A%E7%BA%BF%E7%A8%8B%E7%AE%80%E5%8D%95%E5%AE%9E%E6%93%8D\">四：线程简单实操</a></p>\n<p id=\"1.%E8%8E%B7%E5%8F%96%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8D%E5%AD%97%20%26%20%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B%E5%AF%B9%E8%B1%A1-toc\" style=\"margin-left:80px;\"><a href=\"#1.%E8%8E%B7%E5%8F%96%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8D%E5%AD%97%20%26%20%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B%E5%AF%B9%E8%B1%A1\">1.获取线程的名字 &amp; 获取当前线程对象</a></p>\n<p id=\"2.%E7%BA%BF%E7%A8%8B%E7%9A%84sleep%E6%96%B9%E6%B3%95-toc\" style=\"margin-left:80px;\"><a href=\"#2.%E7%BA%BF%E7%A8%8B%E7%9A%84sleep%E6%96%B9%E6%B3%95\">2.线程的sleep方法</a></p>\n<p id=\"3.%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%9D%A1%E7%9C%A0%C2%A0-toc\" style=\"margin-left:80px;\"><a href=\"#3.%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%9D%A1%E7%9C%A0%C2%A0\">3.终止线程的睡眠 </a></p>\n<p id=\"4.%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%89%A7%E8%A1%8C-toc\" style=\"margin-left:80px;\"><a href=\"#4.%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%89%A7%E8%A1%8C\">4.终止线程的执行</a></p>\n<p id=\"5.%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89-toc\" style=\"margin-left:80px;\"><a href=\"#5.%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89\">5.线程的调度（了解）</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h1 id=\"%C2%A0%E4%B8%80%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A6%82%E8%BF%B0\"> 一：<strong>进程与多线程概述</strong></h1>\n<blockquote>\n<p>❤️<strong>什么是进程？什么是线程？</strong><br/>       ⭐️<span style=\"color:#fe2c24;\">进程是一个应用程序</span>（1个进程是一个软件）<br/>       ⭐️<span style=\"color:#fe2c24;\">线程是一个进程中的执行场景/执行单元</span><br/>       ⭐️<span style=\"color:#fe2c24;\"><strong>一个进程可以启动多个线程</strong></span><br/> ❤️对于java程序来说，当在DOS命令窗口中输入： java HelloWorld 回车之后。<br/>       ⭐️首先会先启动JVM，而JVM就是一个进程。<br/>       ⭐️JVM再启动一个主线程调用main方法。<br/>       ⭐️同时再启动一个垃圾回收线程负责看护，回收垃圾。<br/>       ⭐️所以，最起码现在的java程序中至少有两个线程并发， 一个是垃圾回收线程，一个是执行main方法的主线程。<br/> ❤️<strong>进程和线程是什么关系？</strong></p>\n<p>      ⭐️我们来通过身边的示例来说明一下：</p>\n<p>           假如阿里巴巴是一个进程，那么</p>\n<p>            马云：阿里巴巴的一个线程<br/>             员工：阿里巴巴的一个线程 <br/>       ⭐️<span style=\"color:#fe2c24;\"><strong>进程可以看做是现实生活当中的公司；线程可以看做是公司当中的某个员工</strong></span></p>\n<p>❤️<strong>注意：</strong><br/>       ⭐️<span style=\"color:#fe2c24;\">进程A和进程B的<strong>内存独立不共享</strong></span>。（例如：阿里巴巴和京东资源不会共享的）<br/>           魔兽游戏是一个进程，酷狗音乐是一个进程；这两个进程是独立的，不共享资源。</p>\n<p>      ⭐️在java语言中：<span style=\"color:#fe2c24;\">线程A和线程B，<strong>堆内存</strong>和<strong>方法区，内存共享</strong>；</span>但是<span style=\"color:#fe2c24;\"><strong>栈内存独立</strong>，<strong>一个线程一个栈。</strong></span><br/><strong>❤️多线程并发：   </strong>         <br/>       ⭐️假设<span style=\"color:#fe2c24;\">启动10个线程</span>，<span style=\"color:#fe2c24;\">会有10个栈空间</span>，每个栈和每个栈之间，<span style=\"color:#fe2c24;\">互不干扰</span>，各自执行各自的，这就是多线程并发。    <br/>       ⭐️例如：火车站，可以看做是一个进程；火车站中的每一个售票窗口可以看做是一个线程。我在窗口A购票，朋友可以在窗口A购票，朋友不需要等我，我也不需要等朋友；所以多线程并发可以提高效率。</p>\n<p>      ⭐️<span style=\"color:#fe2c24;\">java中之所以有多线程机制，目的就是为了提高程序的处理效率</span></p>\n<p><strong>❤️</strong>思考题：<br/>       ⭐️使用了多线程机制之后，main方法结束，是不是有可能程序也不会结束？<br/>       <span style=\"color:#fe2c24;\">  main方法结束只是主线程结束了，主栈空了，其它的栈(线程)可能还在压栈弹栈</span>。</p>\n<p>       ⭐️我们通过画图理解一下：</p>\n<p><img alt=\"\" height=\"699\" src=\"image\\352b027c69924a79bb53389279dfbfc6.png\" width=\"1200\"/></p>\n</blockquote>\n<h3 id=\"1.%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E7%9A%84%E7%90%86%E8%A7%A3%C2%A0\"><strong>1.多线程并发的理解 </strong></h3>\n<blockquote>\n<p>❤️<strong>分析一个问题：对于单核的CPU来说，真的可以做到真正的多线程并发吗？</strong></p>\n<p>    ⭐对于多核的CPU电脑来说，真正的多线程并发是没问题的；<br/>         4核CPU表示同一个时间点上，可以真正的有4个进程并发执行。</p>\n<p>    ⭐什么是<strong>真正的多线程并发</strong>？<br/>             t1线程执行t1的，t2线程执行t2的；t1不会影响t2，t2也不会影响t1。这叫做真正的多线程并发。</p>\n<p>    ⭐<span style=\"color:#fe2c24;\">单核的CPU表示只有一个大脑：</span><br/>        单核的CPU不能够做到真正的多线程并发，但是可以做到给人一种“多线程并发”的感觉！对于单核的CPU来说，在某一个时间点上实际上只能处理一件事情，但是由于CPU的处理速度极快，多个线程之间频繁切换执行，给人来的感觉是：多个事情同时在做！<br/>        例如：线程A：播放音乐，线程B：运行魔兽游戏；线程A和线程B频繁切换执行，人类会感觉音乐一直在播放，游戏一直在运行，给我们的感觉是同时并发的。<br/>        再例如：以前的电影院采用胶卷播放电影，一个胶卷一个胶卷播放速度达到一定程度之后，人类的眼睛产生了错觉，感觉是动画的。这说明人类的反应速度很慢，就像一根钢针扎到手上，到最终感觉到疼，这个过程是需要“很长的”时间的，在这个期间计算机可以进行亿万次的循环。所以计算机的执行速度很快。</p>\n</blockquote>\n<h3 id=\"2.%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F%E5%AD%98%E5%9C%A8%E5%87%A0%E4%B8%AA%E7%BA%BF%E7%A8%8B\"><strong>2.分析程序存在几个线程</strong></h3>\n<pre><code class=\"language-java\">package com.bjpowernode.java.thread;\n\n/*分析以下程序，有几个线程，除垃圾回收线程之外。有几个线程？\n        1个线程（因为程序只有1个栈）*/\npublic class ThreadTest01 {\n    public static void main(String[] args) {\n        System.out.println(\"main begin\");\n        m1();\n        System.out.println(\"main over\");\n    }\n\n    private static void m1() {\n        System.out.println(\"m1 begin\");\n        m2();\n        System.out.println(\"m1 over\");\n    }\n\n    private static void m2() {\n        System.out.println(\"m2 begin\");\n        m3();\n        System.out.println(\"m2 over\");\n    }\n\n    private static void m3() {\n        System.out.println(\"m3 execute!\");\n    }\n}\n</code></pre>\n<blockquote>\n<p>只有一个主线程（主栈），没有启动分支栈（分支线程）；所以只有一个线程！</p>\n<p><img alt=\"\" height=\"263\" src=\"image\\ee629ba695a648efa6bd6d568a284141.png\" width=\"980\"/></p>\n</blockquote>\n<p></p>\n<h1 id=\"%F0%9F%A5%85%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F\"><strong>二：</strong>实现线程的两种方式</h1>\n<blockquote>\n<p>java支持多线程机制！并且java已经将多线程实现了，我们只需要继承就行了！</p>\n</blockquote>\n<h3 id=\"1.%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9A%E7%9B%B4%E6%8E%A5%E7%BB%A7%E6%89%BFThread%EF%BC%8C%E9%87%8D%E5%86%99run%E6%96%B9%E6%B3%95\"><strong>1.第一种方式：直接继承Thread，重写run方法</strong></h3>\n<blockquote>\n<p>⭐实现线程的<strong>第一种方式：</strong></p>\n<p>    <span style=\"color:#fe2c24;\">编写一个类，直接<strong>继承</strong>java.lang.<strong>Thread</strong>，<strong>重写run()方法</strong></span></p>\n<p>    怎么<strong>创建线程对象</strong>？ new就行了，例如： <span style=\"color:#fe2c24;\">MyThread t = new MyThread()</span>。<br/>     怎么<strong>启动线程</strong>呢？ <span style=\"color:#fe2c24;\">调用线程对象的start()方法</span>。<br/>     start()方法的作用是：启动一个分支线程，在JVM中开辟一个新的栈空间，这段代码任务完成之后，瞬间就结束了。调用start方法的这段代码的任务只是为了开启一个新的栈空间，只要新的栈空间开出来，start()方法就结束了；线程就启动成功了。启动成功的线程会自动调用run方法，并且run方法在分支栈的栈底部（压栈）。 <strong>run方法在分支栈的栈底部，main方法在主栈的栈底部；run和main是平级的。</strong></p>\n<p>⭐注意：<br/>     亘古不变的道理：方法体当中的代码永远都是自上而下的顺序依次逐行执行的。</p>\n<p>⭐如果调用的是t.run，下面分支线程的i执行完，才会执行主线程的i；如果调用的是t.start()主线程和分支线程是一块执行的</p>\n<p>⭐我们通过内存图来了解一下：</p>\n<p><strong><span style=\"color:#fe2c24;\">调用run：</span></strong></p>\n<p><img alt=\"\" height=\"671\" src=\"image\\d841ae1bec3141b986b6fd75e56098f4.png\" width=\"1184\"/></p>\n<p><strong><span style=\"color:#fe2c24;\">调用start:</span></strong></p>\n<p><img alt=\"\" height=\"664\" src=\"image\\557d554bbd574a9f910bc720919b7f5c.png\" width=\"1200\"/></p>\n</blockquote>\n<pre><code class=\"language-java\">package com.bjpowernode.java.thread;\n\npublic class ThreadTest02 {\n    public static void main(String[] args) {\n        // 这里是main方法，这里的代码属于主线程，在主栈中运行。\n        // 新建一个分支线程对象\n        MyThread t = new MyThread();\n        // 启动线程，调用start()方法\n        t.start(); // 瞬间就结束了\n\n        //t.run(); // 不会启动线程，不会分配新的分支栈。（这种方式就是单线程。）\n\n        // 这里的代码还是运行在主线程中。\n        for(int i = 0; i &lt; 1000; i++){\n            System.out.println(\"主线程---&gt;\" + i);\n        }\n    }\n}\n\nclass MyThread extends Thread {\n    // 重写run方法\n    public void run() {\n        // 编写程序，这段程序运行在分支线程中（分支栈）。\n        for(int i = 0; i &lt; 1000; i++){\n            System.out.println(\"分支线程---&gt;\" + i);\n        }\n    }\n}\n</code></pre>\n<h3 id=\"2.%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9A%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3%EF%BC%8C%E9%87%8D%E5%86%99run%E6%96%B9%E6%B3%95\"><strong>2.第二种方式：实现Runnable接口，重写run方法</strong></h3>\n<blockquote>\n<p>第二种方式实现接口比较常用，因为一个类实现了接口，它还可以去继承其它的类，更灵活，面向接口编程；如果是第一种直接就继承了Thread类，类只能单继承，就不能在继承其它类了，比较局限！</p>\n</blockquote>\n<pre><code class=\"language-java\">package com.bjpowernode.java.thread;\n\npublic class ThreadTest03 {\n    public static void main(String[] args) {\n        // 创建一个可运行的对象\n        MyRunnable r = new MyRunnable();\n        // 将可执行的对象封装成一个线程对象\n        Thread t = new Thread(r);\n        \n        // Thread t = new Thread(new MyRunnable());// 合并代码\n\n        // 启动线程\n        t.start();\n\n        for(int i = 0; i &lt; 1000; i++){\n            System.out.println(\"主线程---&gt;\" + i);\n        }\n    }\n}\n\nclass MyRunnable implements Runnable{\n    public void run() {\n        for(int i = 0; i &lt; 1000; i++){\n            System.out.println(\"分支线程---&gt;\" + i);\n        }\n    }\n}</code></pre>\n<p></p>\n<h3 id=\"3.%E9%87%87%E7%94%A8%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E6%96%B9%E5%BC%8F\"><strong>3.采用匿名内部类的方式</strong></h3>\n<blockquote>\n<p>牵扯到接口，我们也可以不需要在通过实现接口的方式，也可以直接通过匿名内部类的方式去调用！</p>\n</blockquote>\n<pre><code class=\"language-java\">package com.bjpowernode.java.thread;\n\npublic class ThreadTest04 {\n    public static void main(String[] args) {\n        // 创建线程对象，采用匿名内部类方式\n        Thread t = new Thread(new Runnable() {\n            public void run() {\n                for (int i = 0; i &lt; 100; i++) {\n                    System.out.println(\"分支线程---》\"+i);\n                }\n            }\n        });\n\n        // 启动线程\n        t.start();\n\n        for (int i = 0; i &lt; 100; i++) {\n            System.out.println(\"主线程---》\"+i);\n        }\n    }\n}\n</code></pre>\n<h3></h3>\n<h1 id=\"%F0%9F%A5%85%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F\">三：线程生命周期</h1>\n<blockquote>\n<p>线程的生命周期总共有5个状态：<span style=\"color:#fe2c24;\">新建状态、就绪状态、运行状态、阻塞状态、死亡状态</span></p>\n</blockquote>\n<p><img alt=\"\" height=\"443\" src=\"image\\63db9f43a14a4853a1bd2fd565a60d76.png\" width=\"1113\"/></p>\n<p></p>\n<h1 id=\"%E5%9B%9B%EF%BC%9A%E7%BA%BF%E7%A8%8B%E7%AE%80%E5%8D%95%E5%AE%9E%E6%93%8D\">四：线程简单实操</h1>\n<h3 id=\"1.%E8%8E%B7%E5%8F%96%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8D%E5%AD%97%20%26%20%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B%E5%AF%B9%E8%B1%A1\"><strong>1.获取线程的名字 &amp; 获取当前线程对象</strong></h3>\n<blockquote>\n<p>1、怎么<strong>获取当前线程对象</strong></p>\n<pre><code class=\"language-java\">   static Thread currentThread() // 是一个静态方法\n   Thread th = Thread.currentThread(); // 返回值th就是当前线程。</code></pre>\n<p>2、<strong>获取线程对象的名字</strong></p>\n<pre><code class=\"language-java\">String name = 线程对象.getName();</code></pre>\n<p>3、<strong>修改线程对象的名字</strong></p>\n<pre><code class=\"language-java\">线程对象.setName(\"线程名字\");</code></pre>\n<p>4、当线程没有设置名字的时候，默认的名字规律<br/>     Thread-0<br/>     Thread-1<br/>     .....</p>\n</blockquote>\n<pre><code class=\"language-java\">package com.bjpowernode.java.thread;\n\npublic class ThreadTest05 {\n\n    public void doSome(){\n        //如果当前类不是线程类，super和this就不行了\n        //this.getName();\n        //super.getName();\n        // 但是这样可以\n        String name = Thread.currentThread().getName();\n        System.out.println(\"-------&gt;\" + name); // main，在main方法里创建的对象\n    }\n\n    public static void main(String[] args) {\n\n        ThreadTest05 threadTest05 = new ThreadTest05();\n        threadTest05.doSome();\n\n        // 获取当前线程对象\n        // currentThread就是当前线程对象\n        // 这个代码出现在main方法当中，所以当前线程就是主线程。\n        Thread th = Thread.currentThread();\n        System.out.println(th.getName()); // main\n\n        // 创建线程对象\n        MyThread2 t = new MyThread2();\n        // 设置线程的名字\n        t.setName(\"zl-gh\");\n        // 获取线程的名字\n        System.out.println(t.getName()); // zl-gh\n\n        // 如果不设置线程的名字默认是Thread-0 1 2 ......\n        MyThread2 t2 = new MyThread2();\n        System.out.println(t2.getName()); // Thread-1\n\n        t2.start();\n        // 启动线程\n        t.start();\n    }\n}\nclass MyThread2 extends Thread{\n    public void run() {\n        for (int i = 0; i &lt; 100; i++) {\n            // currentThread就是当前线程对象。当前线程是谁呢？\n            // 那个线程调用start()方法，线程执行run方法，那么这个当前线程就是那个\n            Thread th = Thread.currentThread();\n            System.out.println(th.getName()+\"---&gt;\"+i);\n\n            // 在这里，super和this也是可以的（当前类是线程类）\n            System.out.println(this.getName()+\"---&gt;\"+i);\n            System.out.println(super.getName()+\"---&gt;\"+i);\n        }\n    }\n}</code></pre>\n<h3 id=\"2.%E7%BA%BF%E7%A8%8B%E7%9A%84sleep%E6%96%B9%E6%B3%95\"><strong>2.线程的sleep方法</strong></h3>\n<blockquote>\n<p><strong>static void sleep(long millis)</strong><br/> 1、静态方法：Thread.sleep(1000);<br/> 2、参数是毫秒，需要进行异常处理！<br/> 3、作用：让当前线程进入休眠，进入“阻塞状态”，放弃占有CPU时间片，让给其它线程使用<br/> 4、Thread.sleep()方法，可以做到这种效果：<br/>         间隔特定的时间，去执行一段特定的代码，每隔多久执行一次。</p>\n</blockquote>\n<pre><code class=\"language-java\">package com.bjpowernode.java.thread;\n\npublic class ThreadTest06 {\n    public static void main(String[] args) {\n\n        // 使用案例1：\n        try {\n            // 休眠5秒\n            Thread.sleep(5000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        // 5秒过后才会打印Hello World\n        System.out.println(\"Hello World\");\n\n        // 使用案例2：\n        for (int i = 0; i &lt; 10; i++) {\n            System.out.println(Thread.currentThread().getName()+\"---&gt;\"+i);\n            try {\n                // 让当前线程休眠1秒；没隔1秒打印1个数字\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n</code></pre>\n<blockquote>\n<p>关于Thread.sleep()方法的一个面试题：</p>\n</blockquote>\n<pre><code class=\"language-java\">package com.bjpowernode.java.thread;\n\npublic class ThreadTest07 {\n    public static void main(String[] args) {\n        // 创建线程对象\n        Thread t = new MyThread3(); // 多态\n        // 设置线程名字\n        t.setName(\"zl-gh\");\n        // 启动线程\n        t.start();\n\n        // 调用sleep方法\n        try {\n            // 这段代码不会让线程zl-gh进入休眠状态，和对象没关系\n            // t.sleep在执行的时候还是会转换成：Thread.sleep(1000 * 5);\n            // 这行代码的作用是：让当前线程进入休眠，也就是说main线程进入休眠。\n            // 这样代码出现在main方法中，main线程睡眠。\n            t.sleep(1000*5);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        // 5秒之后这里才会执行。\n        System.out.println(\"Hello World\");\n\n    }\n}\n\nclass MyThread3 extends Thread{\n    public void run() {\n        for (int i = 0; i &lt; 10000; i++) {\n            System.out.println(Thread.currentThread().getName()+\"---&gt;\"+i);\n        }\n    }\n}</code></pre>\n<h3 id=\"3.%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%9D%A1%E7%9C%A0%C2%A0\">3.终止线程的睡眠 </h3>\n<blockquote>\n<p>注意：这个<strong>不是终断线程的执行，是终止线程的睡眠（唤醒线程）</strong>。</p>\n<p>调用<span style=\"color:#fe2c24;\">t.interrupt()</span>这种终断睡眠的方式依靠了java的异常处理机制，来终断线程的睡眠</p>\n</blockquote>\n<pre><code class=\"language-java\">package com.bjpowernode.java.thread;\n/*\nsleep睡眠太久了，如果希望半道上醒来，你应该怎么办？也就是说怎么叫醒一个正在睡眠的线程？？\n */\npublic class ThreadTest08 {\n    public static void main(String[] args) {\n        // 创建线程对象\n        Thread t = new Thread(new MyRunnable1());\n        // 设置线程名字\n        t.setName(\"zl-gh\");\n        // 启动线程\n        t.start();\n\n        // 希望5秒后，zl-gh线程醒来\n        try {\n            t.sleep(1000*5);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        // 终断t线程的睡眠\n        // 这种终断睡眠的方式依靠了java的异常处理机制\n        // 这里终断，下面catch会打印异常信息\n        t.interrupt();\n    }\n}\n\nclass MyRunnable1 implements Runnable{\n    // 重点：run()当中的异常不能throws，只能try catch\n    // 因为run()方法在父类中没有抛出任何异常，子类不能比父类抛出更多的异常。\n    public void run() {\n        System.out.println(Thread.currentThread().getName()+\"---&gt;begin\");\n\n        try {\n            Thread.sleep(1000*60*60*24*365); // 睡眠1年\n        } catch (InterruptedException e) {\n            //e.printStackTrace(); // 异常信息的打印\n        }\n\n        // 一年之后才会执行这段代码\n        System.out.println(Thread.currentThread().getName()+\"---&gt;end\");\n\n\n\n        // 调用doOther()\n     /*   try {\n            doOther(); // 在这里只能try\n        } catch (Exception e) {\n            e.printStackTrace();\n        }*/\n    }\n\n    // 其它方法可以throws\n    /*public void doOther() throws Exception{\n\n    }*/\n}\n\n</code></pre>\n<h3></h3>\n<h3 id=\"4.%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%89%A7%E8%A1%8C\"><strong>4.终止线程的执行</strong></h3>\n<p><strong>强行终止线程的执行</strong></p>\n<blockquote>\n<p>在java中怎么强行终止一个线程的执行；利用<span style=\"color:#fe2c24;\">t.stop()方法</span><br/> 这种方式存在很大的缺点：容易丢失数据。因为这种方式是直接将线程杀死了，线程没有保存的数据将会丢失。不建议使用。</p>\n</blockquote>\n<pre><code class=\"language-java\">package com.bjpowernode.java.thread;\n\npublic class ThreadTest09 {\n    public static void main(String[] args) {\n        // 创建线程对象\n        Thread t = new Thread(new MyRunnable3());\n        // 设置线程名字\n        t.setName(\"zl-gh\");\n        // 启动线程\n        t.start();\n\n        // 5秒之后强行终止zl-gh线程\n        try {\n            Thread.sleep(5*1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        // 5秒之后强行终止zl-gh线程\n        t.stop(); // 已过时（不建议使用）\n    }\n}\n\nclass MyRunnable3 implements Runnable{\n    public void run() {\n        for (int i = 0; i &lt; 10; i++) {\n            System.out.println(Thread.currentThread().getName()+\"---&gt;\"+i);\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}</code></pre>\n<p><strong>合理终止线程的执行（重点）</strong></p>\n<pre><code class=\"language-java\">package com.bjpowernode.java.thread;\n\npublic class ThreadTest10 {\n    public static void main(String[] args) {\n        // 创建线程对象\n        MyRunnable4 m = new MyRunnable4();\n        Thread t = new Thread(m);\n        // 设置线程名字\n        t.setName(\"zl-gh\");\n        // 启动线程\n        t.start();\n\n        // 5秒之后终止zl-gh线程\n        try {\n            Thread.sleep(5*1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        // 终止zl-gh线程\n        m.run = false;\n    }\n}\n\nclass MyRunnable4 implements Runnable{\n\n    // 打一个布尔标记\n    boolean run = true;\n\n    public void run() { // 是true才会执行线程\n        for (int i = 0; i &lt; 10; i++) {\n            if(run){\n                System.out.println(Thread.currentThread().getName()+\"---&gt;\"+i);\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }else{\n                // false就return结束了，在这里可以进行保存数据的操作\n               \n                return;\n            }\n\n        }\n    }\n}</code></pre>\n<h3></h3>\n<h3 id=\"5.%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89\"><strong>5.线程的调度（了解）</strong></h3>\n<blockquote>\n<p>1、常见的<strong>线程调度模型</strong>有哪些？</p>\n<p>（1）<span style=\"color:#fe2c24;\"><strong>抢占式调度模型：</strong></span>哪个线程的优先级比较高，抢到的CPU时间片的概率就高一些/多一些；<span style=\"color:#fe2c24;\">java采用的就是抢占式调度模型</span>。</p>\n<p>（2）<span style=\"color:#fe2c24;\"><strong>均分式调度模型：</strong></span>平均分配CPU时间片。每个线程占有的CPU时间片时间长度一样；平均分配，一切平等。有一些编程语言，线程调度模型采用的是这种方式。<br/> 2、java中提供了<strong>哪些方法是和线程调度有关系</strong>的呢？</p>\n<p>（1）实例方法：<br/>           <span style=\"color:#fe2c24;\">void setPriority(int newPriority)</span> <strong>设置线程的优先级</strong><br/>           <span style=\"color:#fe2c24;\">int getPriority()</span><strong> 获取线程优先级</strong><br/>           <strong>最低优先级1、默认优先级是5、最高优先级10</strong><br/>           优先级比较高的获取CPU时间片可能会多一些。（但也不完全是，大概率是多的） <br/> （2）静态方法：<br/>           <span style=\"color:#fe2c24;\">static void yield()</span>  <strong>让位方法</strong><br/>           暂停当前正在执行的线程对象，并执行其他线程<br/>           <span style=\"color:#fe2c24;\">yield()方法不是阻塞方法；让当前线程让位，让给其它线程使用</span>。<br/>           yield()方法的执行会让当前线程从“运行状态”回到“就绪状态”。<br/>           注意：在回到就绪之后，有可能还会再次抢到。<br/> （3）实例方法：<br/>           <span style=\"color:#fe2c24;\">void join()</span>  <strong>合并线程</strong><br/>           例：<strong><span style=\"color:#fe2c24;\">t.join()</span></strong>; <strong><span style=\"color:#fe2c24;\">当前线程进入阻塞</span>，<span style=\"color:#fe2c24;\">t线程执行</span>，直到t线程结束。当前线程才可以继续</strong></p>\n</blockquote>\n<p><strong>5.1 线程优先级</strong></p>\n<blockquote>\n<p>优先级较高的，只是抢到的CPU时间片相对多一些。<br/> 大概率方向更偏向于优先级比较高的。</p>\n</blockquote>\n<pre><code class=\"language-java\">package com.bjpowernode.java.thread;\n\npublic class ThreadTest11 {\n    public static void main(String[] args) {\n        System.out.println(\"最高优先级\"+Thread.MAX_PRIORITY); // 10\n        System.out.println(\"最低优先级\"+Thread.MIN_PRIORITY); // 1\n        System.out.println(\"最高优先级\"+Thread.NORM_PRIORITY);// 5\n\n        // 获取当前线程对象，获取当前线程的优先级\n        Thread currentThread = Thread.currentThread();\n        System.out.println(currentThread.getName()+\n        \"线程的优先级是\"+currentThread.getPriority()); // main线程的优先级是5\n\n        // 设置主线程的优先级为1\n        Thread.currentThread().setPriority(1);\n\n        // 调用下面的线程\n        Thread t = new Thread(new MyRunnable5());\n        t.setPriority(10); // t线程优先级设置为10\n        t.setName(\"zl-gh\");\n        t.start();\n\n        // 主线程的for循环\n        for (int i = 0; i &lt; 1000; i++) {\n            System.out.println(Thread.currentThread().getName()+\"---&gt;\"+i);\n        }\n    }\n\n}\n\nclass MyRunnable5 implements Runnable{\n    public void run() {\n        // 获取线程默认的优先级\n        // System.out.println(Thread.currentThread().getName()+\"线程的优先级\"+Thread.currentThread().getPriority()); // zl-gh线程的优先级5\n\n        // t线程的for循环；优先级较高，抢夺的CPU时间片也多，先执行结束\n        for (int i = 0; i &lt; 1000; i++) {\n            System.out.println(Thread.currentThread().getName()+\"---&gt;\"+i);\n        }\n    }\n}</code></pre>\n<p><strong>5.2 线程让位</strong></p>\n<blockquote>\n<p><strong>让位：</strong><span style=\"color:#fe2c24;\">当前线程暂停，回到就绪状态，让给其它线程</span>。<br/><strong>静态方法：</strong><span style=\"color:#fe2c24;\">Thread.yield();</span></p>\n</blockquote>\n<pre><code class=\"language-java\">package com.bjpowernode.java.thread;\n\npublic class ThreadTest12 {\n    public static void main(String[] args) {\n        // 创建线程对象\n        Thread t = new Thread(new MyRunnable6());\n        // 修改线程名字\n        t.setName(\"zl-gh\");\n        // 启动线程\n        t.start();\n\n        for (int i = 1; i &lt;= 10000; i++) {\n            System.out.println(Thread.currentThread().getName()+\"---&gt;\"+i);\n        }\n    }\n\n}\n\nclass MyRunnable6 implements Runnable{\n    public void run() {\n        for (int i = 1; i &lt;= 10000; i++) {\n            // 每100个让位一次\n            if(i%100 == 0){\n                Thread.yield();// 当前线程暂停一下，让给主线程。\n            }\n            System.out.println(Thread.currentThread().getName()+\"---&gt;\"+i);\n        }\n\n    }\n}</code></pre>\n<p><strong>5.3 线程合并</strong></p>\n<blockquote>\n<p><strong>实例方法：void join()  合并线程</strong></p>\n</blockquote>\n<pre><code class=\"language-java\">package com.bjpowernode.java.thread;\n\npublic class ThreadTest13 {\n    public static void main(String[] args) {\n        System.out.println(\"main begin\");\n        // 创建线程对象\n        Thread t = new Thread(new MyRunnable7());\n        // 修改线程的名字\n        t.setName(\"zl-gh\");\n        // 启动线程\n        t.start();\n\n        // 合并线程\n        try {\n            // t合并到当前线程中，当前线程受阻塞，t线程执行直到结束。\n            t.join();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        System.out.println(\"main over\"); // 最后执行\n    }\n}\n\nclass MyRunnable7 implements Runnable{\n    public void run() {\n        for (int i = 0; i &lt; 10000; i++) {\n            System.out.println(Thread.currentThread().getName()+\"---&gt;\"+i);\n        }\n    }\n}</code></pre>\n<p></p>\n<h1 id=\"%E7%BB%93%E6%9D%9F%E8%AF%AD\">结束语</h1>\n<blockquote>\n<p>今天的分享就到这里啦！快快通过下方链接注册加入刷题大军吧！各种大厂面试真题在等你哦！<br/> 💬刷题神器，从基础到大厂面试题👉<a href=\"https://www.nowcoder.com/link/pc_csdncpt_mtdyqdm_c\" title=\"点击跳转刷题网站进行注册学习\">点击跳转刷题网站进行注册学习</a></p>\n</blockquote>\n<p><img alt=\"\" height=\"511\" src=\"image\\184068dc41e94efbb14e555f972eaa17.png\" width=\"1200\"/></p>\n</div>\n</div>"}