{"blogid": "126430490", "writerAge": "码龄1年", "writerBlogNum": "43", "writerCollect": "1846", "writerComment": "2943", "writerFan": "2176", "writerGrade": "6级", "writerIntegral": "6934", "writerName": "敲代码の流川枫", "writerProfileAdress": "writer_image\\profile_126430490.jpg", "writerRankTotal": "2211", "writerRankWeekly": "65", "writerThumb": "2428", "writerVisitNum": "29459", "blog_read_count": "555", "blog_time": "已于 2022-08-19 21:24:47 修改", "blog_title": "JavaSE——异常处理机制", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p><img alt=\"ced485cbb11e458d81a746890b32cf3f.gif\" src=\"https://img-blog.csdnimg.cn/ced485cbb11e458d81a746890b32cf3f.gif\"/></p>\n<blockquote>\n<p>作者：<span style=\"color:#faa572;\">敲代码の流川枫</span></p>\n<p>博客主页：<a href=\"https://blog.csdn.net/chenchenchencl?spm=1011.2421.3001.5343\" title=\"流川枫的博客\">流川枫的博客</a></p>\n<p>专栏：<a href=\"https://blog.csdn.net/chenchenchencl/category_11932758.html\" title=\"和我一起学java\">和我一起学java</a></p>\n<p>语录：<span style=\"color:#faa572;\">Stay hungry stay foolish</span></p>\n<p><span style=\"color:#faa572;\">工欲善其事必先利其器，给大家介绍一款超牛的斩获大厂offer利器——牛客网</span></p>\n<p><a href=\"https://www.nowcoder.com/link/pc_csdncpt_qdmdlcf_c\" title=\"点击免费注册和我一起刷题吧\">点击免费注册和我一起刷题吧</a>   </p>\n</blockquote>\n<p class=\"img-center\"><img alt=\"\" height=\"252\" src=\"image\\39e536ea914043979d27fe28f31001b7.png\" width=\"592\"/></p>\n<p id=\"main-toc\"><strong>文章目录</strong></p>\n<p id=\"%E2%80%8B1.%20%E5%BC%82%E5%B8%B8%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-toc\" style=\"margin-left:0px;\"><a href=\"#%E2%80%8B1.%20%E5%BC%82%E5%B8%B8%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84\">​1. 异常的概念与体系结构</a></p>\n<p id=\"1.1%C2%A0%E5%BC%82%E5%B8%B8%E7%9A%84%E6%A6%82%E5%BF%B5-toc\" style=\"margin-left:40px;\"><a href=\"#1.1%C2%A0%E5%BC%82%E5%B8%B8%E7%9A%84%E6%A6%82%E5%BF%B5\">1.1 异常的概念</a></p>\n<p id=\"1.%20%E7%AE%97%E6%9C%AF%E5%BC%82%E5%B8%B8-toc\" style=\"margin-left:80px;\"><a href=\"#1.%20%E7%AE%97%E6%9C%AF%E5%BC%82%E5%B8%B8\">1. 算术异常</a></p>\n<p id=\"%C2%A02.%20%E6%95%B0%E7%BB%84%E8%B6%8A%E7%95%8C%E5%BC%82%E5%B8%B8-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A02.%20%E6%95%B0%E7%BB%84%E8%B6%8A%E7%95%8C%E5%BC%82%E5%B8%B8\">2. 数组越界异常</a></p>\n<p id=\"3.%20%E7%A9%BA%E6%8C%87%E9%92%88%E5%BC%82%E5%B8%B8-toc\" style=\"margin-left:80px;\"><a href=\"#3.%20%E7%A9%BA%E6%8C%87%E9%92%88%E5%BC%82%E5%B8%B8\">3. 空指针异常</a></p>\n<p id=\"4.%20%E8%BE%93%E5%85%A5%E4%B8%8D%E5%8C%B9%E9%85%8D%E5%BC%82%E5%B8%B8-toc\" style=\"margin-left:80px;\"><a href=\"#4.%20%E8%BE%93%E5%85%A5%E4%B8%8D%E5%8C%B9%E9%85%8D%E5%BC%82%E5%B8%B8\">4. 输入不匹配异常</a></p>\n<p id=\"%C2%A01.2%20%E5%BC%82%E5%B8%B8%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A01.2%20%E5%BC%82%E5%B8%B8%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84\"> 1.2 异常的体系结构</a></p>\n<p id=\"%C2%A01.3%20%E5%BC%82%E5%B8%B8%E7%9A%84%E5%88%86%E7%B1%BB-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A01.3%20%E5%BC%82%E5%B8%B8%E7%9A%84%E5%88%86%E7%B1%BB\"> 1.3 异常的分类</a></p>\n<p id=\"1.%20%E7%BC%96%E8%AF%91%E6%97%B6%E5%BC%82%E5%B8%B8-toc\" style=\"margin-left:80px;\"><a href=\"#1.%20%E7%BC%96%E8%AF%91%E6%97%B6%E5%BC%82%E5%B8%B8\">1. 编译时异常</a></p>\n<p id=\"2.%20%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8-toc\" style=\"margin-left:80px;\"><a href=\"#2.%20%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8\">2. 运行时异常</a></p>\n<p id=\"2.%20%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86-toc\" style=\"margin-left:0px;\"><a href=\"#2.%20%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86\">2. 异常的处理</a></p>\n<p id=\"2.1%E3%80%81%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8throw-toc\" style=\"margin-left:40px;\"><a href=\"#2.1%E3%80%81%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8throw\">2.1 抛出异常throw</a></p>\n<p id=\"2.2%20%E5%BC%82%E5%B8%B8%E7%9A%84%E6%8D%95%E8%8E%B7(throws%20%E4%BB%A5%E5%8F%8Atry-catch)-toc\" style=\"margin-left:40px;\"><a href=\"#2.2%20%E5%BC%82%E5%B8%B8%E7%9A%84%E6%8D%95%E8%8E%B7%28throws%20%E4%BB%A5%E5%8F%8Atry-catch%29\">2.2 异常的捕获(throws 以及try-catch)</a></p>\n<p id=\"%E5%BC%82%E5%B8%B8%E5%A3%B0%E6%98%8Ethrows-toc\" style=\"margin-left:80px;\"><a href=\"#%E5%BC%82%E5%B8%B8%E5%A3%B0%E6%98%8Ethrows\">异常声明throws</a></p>\n<p id=\"try-catch%E6%8D%95%E8%8E%B7%E5%B9%B6%E5%A4%84%E7%90%86-toc\" style=\"margin-left:80px;\"><a href=\"#try-catch%E6%8D%95%E8%8E%B7%E5%B9%B6%E5%A4%84%E7%90%86\">try-catch捕获并处理</a></p>\n<p id=\"finally-toc\" style=\"margin-left:80px;\"><a href=\"#finally\">finally</a></p>\n<p id=\"3.%20%E6%80%BB%E7%BB%93-toc\" style=\"margin-left:0px;\"><a href=\"#3.%20%E6%80%BB%E7%BB%93\">3. 总结</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h1 id=\"%E2%80%8B1.%20%E5%BC%82%E5%B8%B8%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84\">​1. 异常的概念与体系结构</h1>\n<h2 id=\"1.1%C2%A0%E5%BC%82%E5%B8%B8%E7%9A%84%E6%A6%82%E5%BF%B5\">1.1 异常的概念</h2>\n<p>什么是异常呢？</p>\n<p>在java中，将程序执行过程中发生的不正常行为称为异常</p>\n<p>java中不同类型的异常，都有与其对应的类来进行描述</p>\n<p>接下来看看有哪些常见的异常：</p>\n<h3 id=\"1.%20%E7%AE%97%E6%9C%AF%E5%BC%82%E5%B8%B8\">1. 算术异常</h3>\n<pre><code>public class Test {\n    public static void main(String[] args) {\n        System.out.println(10/0);\n    }\n}</code></pre>\n<p><img alt=\"\" height=\"285\" src=\"image\\577c6a6dc6e146a2802efc12b615e5c4.png\" width=\"1200\"/></p>\n<h3 id=\"%C2%A02.%20%E6%95%B0%E7%BB%84%E8%B6%8A%E7%95%8C%E5%BC%82%E5%B8%B8\">2. 数组越界异常</h3>\n<pre><code>public class Test {\n    public static void main(String[] args) {\n        int[] arr = {0,1,2,3};\n        System.out.println(arr[100]);\n    }\n}\n</code></pre>\n<p><img alt=\"\" height=\"274\" src=\"image\\fb7aba4f9b8641d3a2755b3800a4b331.png\" width=\"1200\"/></p>\n<h3 id=\"3.%20%E7%A9%BA%E6%8C%87%E9%92%88%E5%BC%82%E5%B8%B8\">3. 空指针异常</h3>\n<pre><code>public class Test {\n    public static void main(String[] args) {\n        int[] arr = null;\n        System.out.println(arr.length);\n    }\n}</code></pre>\n<p><img alt=\"\" height=\"267\" src=\"image\\80251d8f22284afb9194f9780b5aab26.png\" width=\"1200\"/></p>\n<h3 id=\"4.%20%E8%BE%93%E5%85%A5%E4%B8%8D%E5%8C%B9%E9%85%8D%E5%BC%82%E5%B8%B8\">4. 输入不匹配异常</h3>\n<pre><code>import java.util.Scanner;\n\npublic class Test {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        System.out.println(n);\n    }\n}</code></pre>\n<p><img alt=\"\" height=\"433\" src=\"image\\9d571213edf949b1874c8827a313130c.png\" width=\"1200\"/></p>\n<h2 id=\"%C2%A01.2%20%E5%BC%82%E5%B8%B8%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84\"> 1.2 异常的体系结构</h2>\n<blockquote>\n<p>Throwable：是异常体系的顶层类，其派生出两个重要的子类, Error和Exception</p>\n<p>Error：指的是Java虚拟机无法解决的严重问题，比如：JVM的内部错误、资源耗尽等，典型代表：StackOverflowError和OutOfMemoryError</p>\n<p>Exception：异常产生后程序员可以通过代码进行处理，使程序继续执行.我们平时所说的异常就是Exception</p>\n</blockquote>\n<p><img alt=\"\" height=\"535\" src=\"image\\ff99edd2a5354cd48b21c2ba75230af5.png\" width=\"787\"/></p>\n<h2 id=\"%C2%A01.3%20%E5%BC%82%E5%B8%B8%E7%9A%84%E5%88%86%E7%B1%BB\"> 1.3 异常的分类</h2>\n<h3 id=\"1.%20%E7%BC%96%E8%AF%91%E6%97%B6%E5%BC%82%E5%B8%B8\">1. 编译时异常</h3>\n<p>在程序编译期间发生的异常，称为编译时异常，也称为受检查异常(Checked Exception)</p>\n<p>程序想要编译，必须处理异常后才能继续编译</p>\n<pre><code>class Person{\n    private String name;\n    private String gender;\n    int age;\n\n        //想要让该类支持深拷贝，覆写Object类的clone方法即可\n    public Person clone(){\n        return (Person)super.clone();\n    }\n}</code></pre>\n<p><img alt=\"\" height=\"226\" src=\"image\\a8ab70c72d0c4abc91257ddd6f2e10c7.png\" width=\"813\"/></p>\n<h3 id=\"2.%20%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8\">2. 运行时异常</h3>\n<blockquote>\n<p>在程序执行期间发生的异常，称为运行时异常，也称为非受检查异常(Unchecked Exception)</p>\n<p>运行时指的是程序已经编译通过得到class 文件了, 再由 JVM 执行过程中出现的错误</p>\n<p>RunTimeException以及其子类对应的异常，都称为运行时异常。比如：NullPointerException、ArrayIndexOutOfBoundsException、ArithmeticException</p>\n</blockquote>\n<h1 id=\"2.%20%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86\">2. 异常的处理</h1>\n<p>异常处理主要的5个关键字：<strong>throw、try、catch、final、throws</strong></p>\n<p><img alt=\"\" height=\"331\" src=\"image\\27a9013653904386b1f3c7558eea72d7.png\" width=\"801\"/></p>\n<p></p>\n<h2 id=\"2.1%E3%80%81%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8throw\"><strong>2.1 抛出异常throw</strong></h2>\n<p>在Java中，可以借助throw关键字，抛出一个指定的异常对象，将错误信息告知给调用者。具体语法如下</p>\n<pre><code>throw new XXXException(\"异常产生的原因\");</code></pre>\n<p>接下来我们写一个抛出异常的代码</p>\n<pre><code>public class Test {\n    public static void main(String[] args) {\n        int[] arr = null;\n        test(arr);\n\n    }\n    public static void test (int[] arrays){\n        if(arrays == null){\n            throw new NullPointerException(\"传递的数组为null\");\n        }\n    }\n\n}\n\n</code></pre>\n<p><img alt=\"\" height=\"271\" src=\"image\\36929c758a9c452caf44f6faf9c9fc19.png\" width=\"1200\"/></p>\n<blockquote>\n<p>注意事项:</p>\n<p>1. throw必须写在方法体内部</p>\n<p>2. 抛出的对象必须是Exception 或者 Exception 的子类对象</p>\n<p>3. 如果抛出的是 RunTimeException 或者 RunTimeException 的子类，则可以不用处理，直接交给JVM来处理</p>\n<p>4. 如果抛出的是编译时异常，用户必须处理，否则无法通过编译</p>\n<p>5. 异常一旦抛出，其后的代码就不会执行</p>\n</blockquote>\n<h2 id=\"2.2%20%E5%BC%82%E5%B8%B8%E7%9A%84%E6%8D%95%E8%8E%B7(throws%20%E4%BB%A5%E5%8F%8Atry-catch)\">2.2 异常的捕获(throws 以及try-catch)</h2>\n<p>异常的捕获，也就是异常的具体处理方式，主要有两种：异常声明throws 以及 try-catch捕获处理</p>\n<h3 id=\"%E5%BC%82%E5%B8%B8%E5%A3%B0%E6%98%8Ethrows\">异常声明throws</h3>\n<blockquote>\n<p>当前方法不处理异常，提醒方法的调用者处理异常</p>\n<p>即当方法中抛出编译时异常，用户不想处理该异常，此时就可以借助throws将异常抛给方法的调用者来处理</p>\n</blockquote>\n<pre><code>语法格式：\n修饰符 返回值 类型 方法名(参数列表) throws 异常类型1，异常类型2...{\n        //...\n}</code></pre>\n<blockquote>\n<p>注意事项</p>\n<p>1. throws必须跟在方法的参数列表之后</p>\n<p>2. 声明的异常必须是 Exception 或者 Exception 的子类</p>\n<p>3. 方法内部如果抛出了多个异常，throws之后必须跟多个异常类型，之间用逗号隔开，如果抛出多个异常类型具有父子关系，直接声明父类即可</p>\n<p>4. 调用声明抛出异常的方法时，调用者必须对该异常进行处理，或者  继续使用throws抛出 </p>\n</blockquote>\n<p><img alt=\"\" height=\"278\" src=\"image\\1b013ccc7f38497d9ca7678cb8e20365.png\" width=\"895\"/></p>\n<pre><code>public class Test {\n    public static void main(String[] args) throws Exception {\n        int[] arr = null;\n        test(arr);\n\n    }\n\n    public static void test(int[] arrays) throws Exception{\n        if(arrays == null){\n            throw new NullPointerException();\n        }\n    }\n\n}</code></pre>\n<h3 id=\"%E2%80%8B%E7%BC%96%E8%BE%91\"><img alt=\"\" height=\"280\" src=\"image\\f1626aef33bb48c8b9f2ef63c6c6ddd4.png\" width=\"1200\"/></h3>\n<blockquote>\n<p><strong> 当test只声明了异常却没有处理，会向上寻找调用者即main函数，它也没有处理，则JVM处理异常</strong></p>\n</blockquote>\n<h3 id=\"try-catch%E6%8D%95%E8%8E%B7%E5%B9%B6%E5%A4%84%E7%90%86\">try-catch捕获并处理</h3>\n<blockquote>\n<p>throws对异常并没有真正处理，而是将异常报告给抛出异常方法的调用者，由调用者处理。如果真正要对异常进行处理，就需要try-catch</p>\n</blockquote>\n<p>语法格式：</p>\n<pre><code> try {\n            //将可能出现异常的代码放在这里\n            //可能会抛出异常，也可能不会\n}catch(要捕获的异常类型 e){\n\n            //如果try中的代码抛出异常了，此处catch捕获时异常类型与try中抛出的异常类型一致时，或者是try中抛出异常的基类时，就会被捕获到\n            //对异常就可以正常处理，处理完成后，跳出try-catch结构，继续执行后序代码\n}</code></pre>\n<p>注意事项:</p>\n<p>1. try块内抛出异常位置之后的代码将不会被执行</p>\n<pre><code>public class Test {\n    public static void main(String[] args) throws Exception {\n\n        try {\n            int[] arr = null;\n            System.out.println(arr[3]);\n            System.out.println(\"hello world\");\n        } catch (NullPointerException e) {\n            e.printStackTrace();\n        }\n    }\n}</code></pre>\n<p>没有输出hello world </p>\n<p><img alt=\"\" height=\"229\" src=\"image\\2b773117a03f422bb35724faeff8c6a7.png\" width=\"971\"/></p>\n<p>2. 如果抛出异常类型与catch时异常类型不匹配，即异常不会被成功捕获，也就不会被处理，继续往外抛，直到JVM收到后中断程序----异常是按照类型来捕获的</p>\n<p>抛出异常类型与catch时异常类型不匹配：</p>\n<pre><code>public class Test {\n    public static void main(String[] args) throws Exception {\n\n        try {\n            int[] arr = null;\n            System.out.println(arr[3]);\n            System.out.println(\"hello world\");\n        } catch (ArithmeticException e) {\n            e.printStackTrace();\n        }\n    }\n}</code></pre>\n<p><img alt=\"\" height=\"235\" src=\"image\\fec5bde5b6104b448f110d31f515d7b8.png\" width=\"1119\"/></p>\n<p>3. try中可能会抛出多个不同的异常对象，则必须用多个catch来捕获----即多种异常，多次捕获</p>\n<pre><code>public class Test {\n    public static void main(String[] args) throws Exception {\n\n        try {\n            int[] arr = null;\n            System.out.println(arr[3]);\n            System.out.println(\"hello world\");\n        } catch (ArithmeticException e) {\n            e.printStackTrace();\n        } catch (NullPointerException e){\n            e.printStackTrace();\n        } catch (ArrayIndexOutOfBoundsException e){\n            e.printStackTrace();\n        }\n    }\n}</code></pre>\n<p>多个异常的处理方式是完全相同, 也可以写成这样：</p>\n<pre><code>public class Test {\n    public static void main(String[] args) throws Exception {\n\n        try {\n            int[] arr = null;\n            System.out.println(arr[3]);\n            System.out.println(\"hello world\");\n        } catch (ArithmeticException | NullPointerException |ArrayIndexOutOfBoundsException e) {\n            e.printStackTrace();\n        } \n    }\n}</code></pre>\n<p><strong>异常之间具有父子关系，一定是子类异常在前catch，父类异常在后catch，否则语法错误</strong></p>\n<pre><code> public static void main(String[] args) throws Exception {\n\n        try {\n            int[] arr = null;\n            System.out.println(arr[3]);\n            System.out.println(\"hello world\");\n        } catch (ArithmeticException | NullPointerException |ArrayIndexOutOfBoundsException e) {\n            e.printStackTrace();\n        } catch (Exception e){\n            e.printStackTrace();\n        }\n    }</code></pre>\n<p>Exception可以捕获到所有异常</p>\n<h3 id=\"finally\">finally</h3>\n<p>有些特定的代码，不论程序是否发生异常，都需要执行；在程序正常或者异常退出时，必须要对资源进进行回收；异常还可能会引发程序的跳转，可能导致有些语句执行不到，就需要用到finally这个关键字了</p>\n<p>语法格式</p>\n<pre><code>try {\n          //...\n          \n}catch(要捕获的异常类型 e){\n\n            //...\n}finally{\n\n        //此处的语句无论是否发生异常，都会被执行到\n        //如果没有抛出异常，或者异常被捕获处理了，这里的代码也会执行\n}</code></pre>\n<pre><code>public static void main(String[] args) throws Exception {\n\n        try {\n            int[] arr = null;\n            System.out.println(arr[3]);\n        } catch (ArithmeticException | NullPointerException |ArrayIndexOutOfBoundsException e) {\n            e.printStackTrace();\n        } finally {\n            System.out.println(\"hello world\");\n        }\n    }</code></pre>\n<p><img alt=\"\" height=\"270\" src=\"image\\fbcb014c0a7e4c3384bd73e3471a2416.png\" width=\"1079\"/></p>\n<blockquote>\n<p> <strong>finally 执行的时机是在方法返回之前(try 或者 catch 中如果有 return 会在这个 return 之前执行 finally). 但是如果finally 中也存在 return 语句, 那么就会执行 finally 中的 return, 从而不会执行到 try 中原有的 return</strong></p>\n</blockquote>\n<h1 id=\"3.%20%E6%80%BB%E7%BB%93\"><strong>3. 总结</strong></h1>\n<p>        一个程序先执行 try 中的代码，如果 try 中的代码出现异常， 就会结束 try 中的代码， 看和 catch 中的异常类型是否匹配。如果找到匹配的异常类型，就会执行 catch 中的代码。如果没有找到匹配的异常类型，就会将异常向上传递到上层调用者。无论是否找到匹配的异常类型，finally 中的代码都会被执行到(在该方法结束之前执行)。如果上层调用者也没有处理异常， 就继续向上传递直到 main 方法也没有合适的代码处理异常， 就会交给 JVM 来进行处理，此时程序就会异常终止。</p>\n<p></p>\n<blockquote>\n<p><span style=\"color:#faa572;\">“ 本期的分享就到这里了， 记得给博主一个三连哈，你的支持是我创作的最大动力！</span></p>\n</blockquote>\n<p><img alt=\"ced485cbb11e458d81a746890b32cf3f.gif\" src=\"https://img-blog.csdnimg.cn/ced485cbb11e458d81a746890b32cf3f.gif\"/></p>\n</div>\n</div>"}