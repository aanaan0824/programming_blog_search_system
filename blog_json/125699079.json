{"blogid": "125699079", "writerAge": "码龄4年", "writerBlogNum": "131", "writerCollect": "3568", "writerComment": "3457", "writerFan": "5525", "writerGrade": "7级", "writerIntegral": "15159", "writerName": "TimeFriends", "writerProfileAdress": "writer_image\\profile_125699079.jpg", "writerRankTotal": "717", "writerRankWeekly": "87", "writerThumb": "4187", "writerVisitNum": "234342", "blog_read_count": "791", "blog_time": "于 2022-07-14 11:34:17 发布", "blog_title": "JVM内存模型", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-light\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p></p>\n<div class=\"toc\">\n<h3>文章目录</h3>\n<ul><li><a href=\"#_7\">全球概览</a></li><li><a href=\"#_34\">基于堆栈的架构</a></li><li><a href=\"#_53\">字节码</a></li><li><a href=\"#_211\">运行时数据区</a></li><li><ul><li><a href=\"#_223\">堆</a></li><li><a href=\"#_240\">方法区</a></li><li><a href=\"#_256\">运行时常量池</a></li><li><a href=\"#pc__267\">pc 寄存器（每个线程）</a></li><li><a href=\"#Java__275\">Java 虚拟机堆栈（每线程）</a></li><li><ul><li><a href=\"#_279\">框架</a></li><li><a href=\"#_289\">堆</a></li></ul>\n</li><li><a href=\"#_325\">本机方法堆栈（每线程）</a></li><li><a href=\"#_337\">本机方法堆栈（每线程）</a></li></ul>\n</li></ul>\n</div>\n<br/> JAVA 的主旨是其著名的 WOTA：“一次编写，随处运行”。为了应用它，Sun Microsystems 创建了 Java 虚拟机，这是对编译后的 Java 代码进行解释的底层操作系统的抽象。JVM是 JRE（Java 运行时环境）的核心组件，它是为运行 Java 代码而创建的，但现在被其他语言（Scala、Groovy、JRuby、Closure …）使用。\n<p></p>\n<p>在本文中，我将重点关注JVM 规范中描述的**运行时数据区。**这些区域旨在存储程序或 JVM 本身使用的数据。我将首先介绍 JVM 的概述，然后介绍字节码是什么，最后介绍不同的数据区域。</p>\n<p>内容[显示]</p>\n<h1><a id=\"_7\"></a>全球概览</h1>\n<p>JVM 是底层操作系统的抽象。它确保无论 JVM 在什么硬件或操作系统上运行，相同的代码都将以相同的行为运行。例如：</p>\n<ul><li>无论 JVM 是在 16 位/32 位/64 位操作系统上运行，原始类型 int 的大小始终是从 -2^31 到 2^31-1 的 32 位有符号整数。</li><li>无论底层操作系统/硬件是大端还是小端，每个 JVM 都以大端顺序（高字节在前）存储和使用内存中的数据。</li></ul>\n<p>注意：有时，JVM 实现的行为与另一个不同，但通常是相同的。</p>\n<p><a href=\"http://coding-geek.com/wp-content/uploads/2015/04/jvm_overview.jpg\"><img alt=\"JVM功能概述\" src=\"image\\c5775cc5069188c44d467b39b7dc0a9d.jpeg\"/></a></p>\n<p>此图给出了 JVM 的概述：</p>\n<ul><li>JVM<strong>解释</strong>通过编译类的源代码<strong>产生</strong>的字节码。尽管 JVM 一词代表“Java 虚拟机”，但它可以运行其他语言，如 scala 或 groovy，只要它们可以编译成 java 字节码。</li><li>为了避免磁盘 I/O，字节码由运行时数据区域之一中的**类加载器加载到 JVM。**这段代码一直保留在内存中，直到 JVM 停止或类加载器（加载它的）被销毁。</li><li>加载的代码然后由<strong>执行引擎****解释</strong>和执行。</li><li>执行引擎需要存储数据，例如指向正在执行的代码行的指针。它还需要存储在开发人员代码中处理的数据。</li><li>执行引擎还负责处理底层操作系统。</li></ul>\n<p>注意：如果经常使用，许多 JVM 实现的执行引擎会将字节码编译为本机代码，而不是总是解释字节码。它被称为即时 ( <strong>JIT</strong> ) 编译，大大加快了 JVM。编译后的代码临时保存在通常称为 <strong>代码缓存</strong>的区域中。由于该区域不在 JVM 规范中，因此我不会在本文的其余部分讨论它。</p>\n<h1><a id=\"_34\"></a>基于堆栈的架构</h1>\n<p>JVM 使用基于堆栈的体系结构。虽然它对开发人员来说是不可见的，但它对生成的字节码和 JVM 架构有巨大的影响，这就是为什么我将简要解释这个概念的原因。</p>\n<p>JVM 通过执行 Java 字节码中描述的基本操作来执行开发人员的代码（我们将在下一章中看到）。操作数是指令对其进行操作的值。根据 JVM 规范，这些操作要求参数通过称为<strong>操作数堆栈</strong>的堆栈传递。</p>\n<p><a href=\"http://coding-geek.com/wp-content/uploads/2015/04/state_of_java_operand_stack.jpg\"><img alt=\"iadd 操作期间 java 操作数堆栈的状态示例\" src=\"image\\466d48a593c4a17708ba9067e73c0e23.jpeg\"/></a></p>\n<p>例如，让我们以 2 个整数的基本加法为例。此操作称为<strong>iadd</strong> <strong>（<strong>用于</strong>整数</strong>加法）。如果想在字节码中添加 3 和 4：</p>\n<ul><li>他首先将 3 和 4 压入操作数堆栈。</li><li>然后调用 iadd 指令。</li><li>iadd 将从操作数堆栈中弹出最后两个值。</li><li>int 结果 (3 + 4) 被压入操作数堆栈以供其他操作使用。</li></ul>\n<p>这种运行方式称为基于堆栈的架构。还有其他处理基本操作的方法，例如基于寄存器的体系结构将操作数存储在小寄存器中而不是堆栈中。桌面/服务器 (x86) 处理器和以前的 android 虚拟机 Dalvik 使用这种基于寄存器的架构。</p>\n<h1><a id=\"_53\"></a>字节码</h1>\n<p>由于 JVM 解释字节码，因此在深入之前了解它是有用的。</p>\n<p>java字节码是将java源代码转化为一组基本操作。每个操作由一个字节组成，表示要执行的指令（称为<strong>操作码</strong>或<strong>操作码</strong>），以及用于传递参数的零个或多个字节（但大多数操作使用操作数堆栈来传递参数）。在 256 个可能的 1 字节长的 [操作码](从值 0x00 到 0xFF 十六进制)中，有 204 个当前在 java8 规范中使用。</p>\n<p>这是不同类别的字节码操作的列表。对于每个类别，我添加了一个小描述和操作码的十六进制范围：</p>\n<ul><li>常量：用于将值从常量池（我们稍后会看到）或从已知值推送到操作数堆栈中。从值 0x00 到 0x14</li><li>Loads：用于将局部变量中的值加载到操作数堆栈中。从值 0x15 到 0x35</li><li>Stores：用于从操作数堆栈存储到局部变量中。从值 0x36 到 0x56</li><li>Stack：用于处理操作数堆栈。从值 0x57 到 0x5f</li><li>Math：用于对操作数堆栈中的值进行基本数学运算。从值 0x60 到 0x84</li><li>转换：用于从一种类型转换为另一种类型。从值 0x85 到 0x93</li><li>比较：用于两个值之间的基本比较。从值 0x94 到 0xa6</li><li>控制：基本操作，如 goto、return ……允许更高级的操作，如循环或返回值的函数。从值 0xa7 到 0xb1</li><li>引用：用于分配对象或数组，获取或检查对象、方法或静态方法的引用。也用于调用（静态）方法。从值 0xb2 到 0xc3</li><li>Extended：之后添加的其他类别的操作。从值 0xc4 到 0xc9</li><li>保留：供每个 Java 虚拟机实现内部使用。3 个值：0xca、0xfe 和 0xff。</li></ul>\n<p>这204个操作很简单，例如：</p>\n<ul><li>操作数<strong>ifeq</strong> (0x99 ) 检查 2 个值是否相等</li><li>操作数<strong>iadd</strong> (0x60) 添加 2 个值</li><li>操作数<strong>i2l</strong> (0x85) 将整数转换为长整数</li><li>操作数<strong>arraylength</strong> (0xbe) 给出了数组的大小</li><li>操作数<strong>pop</strong> (0x57) 从操作数堆栈中弹出第一个值</li></ul>\n<p>要创建字节码需要一个编译器，JDK 中包含的标准 java 编译器是<strong>javac</strong>。</p>\n<p>我们来看一个简单的加法：</p>\n<pre><code>public class Test {\n  public static void main(String[] args) {\n    int a =1;\n    int b = 15;\n    int result = add(a,b);\n  }\n\n  public static int add(int a, int b){\n    int result = a + b;\n    return result;\n  }\n}\n</code></pre>\n<p>“javac Test.java”命令在Test.class 中生成一个字节码。由于 java 字节码是二进制代码，因此人类不可读。Oracle 在其 JDK 中提供了一个工具 <strong>javap</strong>，该工具将二进制字节码转换为来自 JVM 规范的人类可读的标记操作代码集。</p>\n<p>命令“javap -verbose Test.class”给出以下结果：</p>\n<pre><code>Classfile /C:/TMP/Test.class\n  Last modified 1 avr. 2015; size 367 bytes\n  MD5 checksum adb9ff75f12fc6ce1cdde22a9c4c7426\n  Compiled from \"Test.java\"\npublic class com.codinggeek.jvm.Test\n  SourceFile: \"Test.java\"\n  minor version: 0\n  major version: 51\n  flags: ACC_PUBLIC, ACC_SUPER\nConstant pool:\n   #1 = Methodref          #4.#15         //  java/lang/Object.\"&lt;init&gt;\":()V\n   #2 = Methodref          #3.#16         //  com/codinggeek/jvm/Test.add:(II)I\n   #3 = Class              #17            //  com/codinggeek/jvm/Test\n   #4 = Class              #18            //  java/lang/Object\n   #5 = Utf8               &lt;init&gt;\n   #6 = Utf8               ()V\n   #7 = Utf8               Code\n   #8 = Utf8               LineNumberTable\n   #9 = Utf8               main\n  #10 = Utf8               ([Ljava/lang/String;)V\n  #11 = Utf8               add\n  #12 = Utf8               (II)I\n  #13 = Utf8               SourceFile\n  #14 = Utf8               Test.java\n  #15 = NameAndType        #5:#6          //  \"&lt;init&gt;\":()V\n  #16 = NameAndType        #11:#12        //  add:(II)I\n  #17 = Utf8               com/codinggeek/jvm/Test\n  #18 = Utf8               java/lang/Object\n{\n  public com.codinggeek.jvm.Test();\n    flags: ACC_PUBLIC\n    Code:\n      stack=1, locals=1, args_size=1\n         0: aload_0\n         1: invokespecial #1                  // Method java/lang/Object.\"&lt;init&gt;\":()V\n         4: return\n      LineNumberTable:\n        line 3: 0\n\n  public static void main(java.lang.String[]);\n    flags: ACC_PUBLIC, ACC_STATIC\n    Code:\n      stack=2, locals=4, args_size=1\n         0: iconst_1\n         1: istore_1\n         2: bipush        15\n         4: istore_2\n         5: iload_1\n         6: iload_2\n         7: invokestatic  #2                  // Method add:(II)I\n        10: istore_3\n        11: return\n      LineNumberTable:\n        line 6: 0\n        line 7: 2\n        line 8: 5\n        line 9: 11\n\n  public static int add(int, int);\n    flags: ACC_PUBLIC, ACC_STATIC\n    Code:\n      stack=2, locals=3, args_size=2\n         0: iload_0\n         1: iload_1\n         2: iadd\n         3: istore_2\n         4: iload_2\n         5: ireturn\n      LineNumberTable:\n        line 12: 0\n        line 13: 4\n}\n</code></pre>\n<p>可读的 .class 表明字节码包含的不仅仅是 java 源代码的简单转录。它包含：</p>\n<ul><li>类的常量池的描述。常量池是 JVM 的数据区域之一，它存储有关类的元数据，例如方法的名称、它们的参数……当类在 JVM 中加载时，这部分会进入常量池。</li><li>LineNumberTable 或 LocalVariableTable 等信息，用于指定函数的位置（以字节为单位）及其在字节码中的变量。</li><li>开发人员 java 代码的字节码转录（加上隐藏的构造函数）。</li><li>处理操作数堆栈的特定操作以及更广泛的传递和获取参数的方式。</li></ul>\n<p>仅供参考，这是对存储在 .class 文件中的信息的简要描述：</p>\n<pre><code>ClassFile {\n  u4 magic;\n  u2 minor_version;\n  u2 major_version;\n  u2 constant_pool_count;\n  cp_info constant_pool[constant_pool_count-1];\n  u2 access_flags;\n  u2 this_class;\n  u2 super_class;\n  u2 interfaces_count;\n  u2 interfaces[interfaces_count];\n  u2 fields_count;\n  field_info fields[fields_count];\n  u2 methods_count;\n  method_info methods[methods_count];\n  u2 attributes_count;\n  attribute_info attributes[attributes_count];\n}\n</code></pre>\n<h1><a id=\"_211\"></a>运行时数据区</h1>\n<p>运行时数据区域是设计用于存储数据的内存区域。这些数据由开发人员的程序或 JVM 用于其内部工作。</p>\n<p><a href=\"http://coding-geek.com/wp-content/uploads/2015/04/jvm_memory_overview.jpg\"><img alt=\"JVM 的不同运行时内存数据区概览\" src=\"image\\34ee7b4743479419ac22feffe452b880.jpeg\"/></a></p>\n<p>此图显示了 JVM 中不同运行时数据区域的概览。有些区域是独一无二的，其他区域是每个线程的。</p>\n<h2><a id=\"_223\"></a>堆</h2>\n<p>堆是所有 Java 虚拟机线程之间共享的内存区域。它是在虚拟机启动时创建的。所有类<strong>实例</strong>和<strong>数组</strong>都在堆中<strong>分配（使用****new</strong>运算符）。</p>\n<pre><code> MyClass myVariable = new MyClass();\n MyClass[] myArrayClass = new MyClass[1024];\n</code></pre>\n<p>该区域必须由<strong>垃圾收集器</strong> 管理，以在不再使用时删除开发人员分配的实例。清理内存的策略取决于 JVM 的实现（例如，Oracle Hotspot 提供了多种算法）。</p>\n<p>堆可以动态扩展或收缩，并且可以具有固定的最小和最大大小。例如，在 Oracle Hotspot 中，用户可以通过以下方式使用 Xms 和 Xmx 参数指定堆的最小大小“java -Xms=512m -Xmx=1024m …”</p>\n<p>注意：堆不能超过最大大小。如果超过此限制，JVM 将抛出<strong>OutOfMemoryError。</strong></p>\n<h2><a id=\"_240\"></a>方法区</h2>\n<p>方法区是所有 Java 虚拟机线程之间共享的内存。它是在虚拟机启动时创建的，并由<strong>类加载器</strong>从字节码加载。只要加载它们的类加载器还活着，方法区中的数据就会保留在内存中。</p>\n<p>方法区存储：</p>\n<ul><li>类信息（字段/方法的数量、超类名称、接口名称、版本……）</li><li>方法和构造函数的字节码。</li><li>每个加载的类都有一个运行时常量池。</li></ul>\n<p>规范不强制在堆中实现方法区。例如，在 JAVA7 之前，Oracle <strong>HotSpot</strong>使用名为 PermGen 的区域来存储方法区域。这个<strong>PermGen</strong>与 Java 堆（以及像堆一样由 JVM 管理的内存）是连续的，并且被限制为 64Mo 的默认空间（由参数 -XX:MaxPermSize 修改）。从 Java 8 开始，HotSpot 现在将方法区存储在称为<strong>Metaspace</strong>的独立本机内存空间中，最大可用空间是可用的系统总内存。</p>\n<p>注意：方法区域不能超过最大大小。如果超过此限制，JVM 将抛出<strong>OutOfMemoryError。</strong></p>\n<h2><a id=\"_256\"></a>运行时常量池</h2>\n<p>该池是方法区的子部分。由于它是元数据的重要组成部分，Oracle 规范将运行时常量池与方法区分开描述。每个加载的类/接口都会增加这个常量池。这个池就像传统编程语言的符号表。换句话说，当一个类、方法或字段被引用时，JVM 通过运行时常量池在内存中搜索实际地址。它还包含常量值，如字符串文字或常量原语。</p>\n<pre><code>String myString1 = “This is a string litteral”;\nstatic final int MY_CONSTANT=2;\n</code></pre>\n<h2><a id=\"pc__267\"></a>pc 寄存器（每个线程）</h2>\n<p>每个线程都有自己的 pc（程序计数器）寄存器，与线程同时创建。在任何时候，每个 Java 虚拟机线程都在执行单个方法的代码，即该线程的<strong>当前方法</strong>。pc 寄存器包含当前正在执行的 Java 虚拟机指令（在方法区域中）的地址。</p>\n<p>注意：如果线程当前正在执行的方法是native，则Java虚拟机的pc寄存器的值是未定义的。Java虚拟机的pc寄存器足够宽，可以保存特定平台上的returnAddress或native指针。</p>\n<h2><a id=\"Java__275\"></a>Java 虚拟机堆栈（每线程）</h2>\n<p>堆栈区域存储多个帧，因此在讨论堆栈之前，我将介绍这些帧。</p>\n<h3><a id=\"_279\"></a>框架</h3>\n<p>帧是一种数据结构，其中包含表示<strong>当前方法</strong>（被调用的方法）中线程状态的多个数据：</p>\n<ul><li> <p><strong>操作数堆栈</strong>：我已经在关于基于堆栈的体系结构的章节中介绍了操作数堆栈。字节码指令使用此堆栈来处理参数。该堆栈还用于在（java）方法调用中传递参数，并在调用方法的堆栈顶部获取被调用方法的结果。</p> </li><li> <p><strong>局部变量数组</strong>：该数组包含当前方法范围内的所有局部变量。该数组可以保存原始类型、引用或 returnAddress 的值。这个数组的大小是在编译时计算的。Java虚拟机在方法调用时使用局部变量来传递参数，被调用方法的数组是从调用方法的操作数栈中创建的。</p> </li><li> <p><strong>运行时常量池引用</strong>：引用当前正在执行的<strong>方法的****当前类</strong>的常量池。JVM 使用它来将符号方法/变量引用（例如：myInstance.method()）转换为实际内存引用。</p> </li></ul>\n<h3><a id=\"_289\"></a>堆</h3>\n<p>每个 Java 虚拟机线程都有一个私有的<em>Java 虚拟机堆栈</em>，与线程同时创建。Java 虚拟机堆栈存储帧。每次调用方法时都会创建一个新框架并将其放入堆栈中。框架在其方法调用完成时被销毁，无论该完成是正常的还是突然的（它会引发未捕获的异常）。</p>\n<p>只有一帧，即执行方法的帧，在给定线程的任何点都处于活动状态。该帧称为<strong>当前帧</strong>，其方法称为<strong>当前方法</strong>。定义当前方法的类是<strong>当前类</strong>。对局部变量和操作数堆栈的操作通常参考当前帧。</p>\n<p>让我们看下面的例子，它是一个简单的加法</p>\n<pre><code>public int add(int a, int b){\n  return a + b;\n}\n\npublic void functionA(){\n// some code without function call\n  int result = add(2,3); //call to function B\n// some code without function call\n}\n</code></pre>\n<p>以下是运行 functionA() 时它在 JVM 中的工作方式：</p>\n<p><a href=\"http://coding-geek.com/wp-content/uploads/2015/04/state_of_jvm_method_stack.jpg\"><img alt=\"在内部调用之后和之前的 jvm 方法堆栈的状态示例\" src=\"image\\96264c7f1a6f069cb73542a03500eab5.jpeg\"/></a></p>\n<p>在 functionA() 中，Frame A 是堆栈帧的顶部，并且是当前帧。在对 add() 的内部调用开始时，将一个新帧（Frame B）放入堆栈中。帧 B 成为当前帧。帧 B 的局部变量数组通过弹出帧 A 的操作数堆栈来填充。当 add() 完成时，帧 B 被销毁并且帧 A 再次成为当前帧。add() 的结果被放入 Frame A 的操作数堆栈，以便 functionA() 可以通过弹出其操作数堆栈来使用它。</p>\n<p>注意：此堆栈的功能使其可动态扩展和收缩。堆栈不能超过最大大小，这限制了递归调用的数量。如果超过此限制，JVM 会抛出 <strong>StackOverflowError</strong>。</p>\n<p>对于 Oracle HotSpot，您可以使用参数 -Xss 指定此限制。</p>\n<h2><a id=\"_325\"></a>本机方法堆栈（每线程）</h2>\n<p>这是用 Java 以外的语言编写并通过 JNI（Java 本地接口）调用的本地代码的堆栈。由于它是“本机”堆栈，因此该堆栈的行为完全取决于底层操作系统。</p>\n<p>来填充。当 add() 完成时，帧 B 被销毁并且帧 A 再次成为当前帧。add() 的结果被放入 Frame A 的操作数堆栈，以便 functionA() 可以通过弹出其操作数堆栈来使用它。</p>\n<p>注意：此堆栈的功能使其可动态扩展和收缩。堆栈不能超过最大大小，这限制了递归调用的数量。如果超过此限制，JVM 会抛出 <strong>StackOverflowError</strong>。</p>\n<p>对于 Oracle HotSpot，您可以使用参数 -Xss 指定此限制。</p>\n<h2><a id=\"_337\"></a>本机方法堆栈（每线程）</h2>\n<p>这是用 Java 以外的语言编写并通过 JNI（Java 本地接口）调用的本地代码的堆栈。由于它是“本机”堆栈，因此该堆栈的行为完全取决于底层操作系统。</p>\n<p><strong>关于JVM内存模型，你学废了么？</strong></p>\n<hr/>\n<p>真诚地邀请您加入我们的大家庭.<br/> 在这里不仅有技术知识分享,还有博主们之间的互帮互助<br/> <strong>不定期发红包,每月更有抽奖环节,游戏机和实体书相赠(包邮)</strong><br/> 让我们抱团取暖,抱团内卷.打造美好C站.期待您的加入.<br/> 备注 : CSDN-xxxxxx (xxxxxx代表你csdn的昵称)</p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}