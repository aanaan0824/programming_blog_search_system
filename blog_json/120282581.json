{"blogid": "120282581", "writerAge": "码龄1年", "writerBlogNum": "62", "writerCollect": "681", "writerComment": "34", "writerFan": "355", "writerGrade": "3级", "writerIntegral": "768", "writerName": "计算机视觉农民工", "writerProfileAdress": "writer_image\\profile_120282581.jpg", "writerRankTotal": "24818", "writerRankWeekly": "60051", "writerThumb": "76", "writerVisitNum": "130410", "blog_read_count": "15672", "blog_time": "于 2021-09-14 11:06:44 发布", "blog_title": "Python爬虫入门教程！手把手教会你爬取网页数据", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>其实在当今社会，网络上充斥着大量有用的数据，我们只需要耐心的观察，再加上一些技术手段，就可以获取到大量的有价值数据。这里的“技术手段”就是网络爬虫。今天就给大家分享一篇爬虫基础知识和入门教程：</p>\n<h1>什么是爬虫？</h1>\n<p>爬虫就是自动获取网页内容的程序，例如搜索引擎，Google，Baidu 等，每天都运行着庞大的爬虫系统，从全世界的网站中爬虫数据，供用户检索时使用。</p>\n<h1><strong>爬虫流程</strong></h1>\n<p>其实把网络爬虫抽象开来看，它无外乎包含如下几个步骤</p>\n<ul><li>模拟请求网页。模拟浏览器，打开目标网站。</li><li>获取数据。打开网站之后，就可以自动化的获取我们所需要的网站数据。</li><li>保存数据。拿到数据之后，需要持久化到本地文件或者数据库等存储设备中。</li></ul>\n<p>那么我们该如何使用 Python 来编写自己的爬虫程序呢，在这里我要重点介绍一个 Python 库：Requests。</p>\n<h1><strong>Requests 使用</strong></h1>\n<p>Requests 库是 Python 中发起 HTTP 请求的库，使用非常方便简单。</p>\n<p><strong>模拟发送 HTTP 请求</strong></p>\n<p>发送 GET 请求</p>\n<p>当我们用浏览器打开豆瓣首页时，其实发送的最原始的请求就是 GET 请求</p>\n<pre><code class=\"language-python\">import requests\nres = requests.get('http://www.douban.com')\nprint(res)\nprint(type(res))\n&gt;&gt;&gt;\n&lt;Response [200]&gt;\n&lt;class 'requests.models.Response'&gt;</code></pre>\n<blockquote>\n<p>可以看到，我们得到的是一个 Response 对象</p>\n</blockquote>\n<p>如果我们要获取网站返回的数据，可以使用 text 或者 content 属性来获取</p>\n<p>text：是以字符串的形式返回数据</p>\n<p>content：是以二进制的方式返回数据</p>\n<pre><code class=\"language-python\">print(type(res.text))\nprint(res.text)\n&gt;&gt;&gt;\n&lt;class 'str'&gt; &lt;!DOCTYPE HTML&gt;\n&lt;html lang=\"zh-cmn-Hans\" class=\"\"&gt;\n&lt;head&gt;\n&lt;meta charset=\"UTF-8\"&gt;\n&lt;meta name=\"google-site-verification\" content=\"ok0wCgT20tBBgo9_zat2iAcimtN4Ftf5ccsh092Xeyw\" /&gt;\n&lt;meta name=\"description\" content=\"提供图书、电影、音乐唱片的推荐、评论和价格比较，以及城市独特的文化生活。\"&gt;\n&lt;meta name=\"keywords\" content=\"豆瓣,广播,登陆豆瓣\"&gt;.....</code></pre>\n<p>发送 POST 请求</p>\n<p>对于 POST 请求，一般就是提交一个表单</p>\n<pre><code>r = requests.post('http://www.xxxx.com', data={\"key\": \"value\"})</code></pre>\n<p> </p>\n<blockquote>\n<p>data 当中，就是需要传递的表单信息，是一个字典类型的数据。</p>\n</blockquote>\n<p><strong>header 增强</strong></p>\n<p>对于有些网站，会拒绝掉没有携带 header 的请求的，所以需要做一些 header 增强。比如：UA，Cookie，host 等等信息。</p>\n<pre><code class=\"language-python\">header = {\"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36\",\n         \"Cookie\": \"your cookie\"}</code></pre>\n<h1>Python爬虫入门教程！手把手教会你爬取网页数据</h1>\n<p>2020-10-25 14:56·<a href=\"https://www.toutiao.com/c/user/token/MS4wLjABAAAA1wP28vXxz_xaC3_z7SNwPPdJJ0eAnDwatvX5N9BOZK8/?source=tuwen_detail\" title=\"数据分析不是个事儿\">数据分析不是个事儿</a></p>\n<p>其实在当今社会，网络上充斥着大量有用的数据，我们只需要耐心的观察，再加上一些技术手段，就可以获取到大量的有价值数据。这里的“技术手段”就是网络爬虫。今天就给大家分享一篇爬虫基础知识和入门教程：</p>\n<h1>什么是爬虫？</h1>\n<p>爬虫就是自动获取网页内容的程序，例如搜索引擎，Google，Baidu 等，每天都运行着庞大的爬虫系统，从全世界的网站中爬虫数据，供用户检索时使用。</p>\n<h1><strong>爬虫流程</strong></h1>\n<p>其实把网络爬虫抽象开来看，它无外乎包含如下几个步骤</p>\n<ul><li>模拟请求网页。模拟浏览器，打开目标网站。</li><li>获取数据。打开网站之后，就可以自动化的获取我们所需要的网站数据。</li><li>保存数据。拿到数据之后，需要持久化到本地文件或者数据库等存储设备中。</li></ul>\n<p>那么我们该如何使用 Python 来编写自己的爬虫程序呢，在这里我要重点介绍一个 Python 库：Requests。</p>\n<h1><strong>Requests 使用</strong></h1>\n<p>Requests 库是 Python 中发起 HTTP 请求的库，使用非常方便简单。</p>\n<p><strong>模拟发送 HTTP 请求</strong></p>\n<p>发送 GET 请求</p>\n<p>当我们用浏览器打开豆瓣首页时，其实发送的最原始的请求就是 GET 请求</p>\n<pre><code>import requests\nres = requests.get('http://www.douban.com')\nprint(res)\nprint(type(res))\n&gt;&gt;&gt;\n&lt;Response [200]&gt;\n&lt;class 'requests.models.Response'&gt;\n</code></pre>\n<blockquote>\n<p>可以看到，我们得到的是一个 Response 对象</p>\n</blockquote>\n<p>如果我们要获取网站返回的数据，可以使用 text 或者 content 属性来获取</p>\n<p>text：是以字符串的形式返回数据</p>\n<p>content：是以二进制的方式返回数据</p>\n<pre><code>print(type(res.text))\nprint(res.text)\n&gt;&gt;&gt;\n&lt;class 'str'&gt; &lt;!DOCTYPE HTML&gt;\n&lt;html lang=\"zh-cmn-Hans\" class=\"\"&gt;\n&lt;head&gt;\n&lt;meta charset=\"UTF-8\"&gt;\n&lt;meta name=\"google-site-verification\" content=\"ok0wCgT20tBBgo9_zat2iAcimtN4Ftf5ccsh092Xeyw\" /&gt;\n&lt;meta name=\"description\" content=\"提供图书、电影、音乐唱片的推荐、评论和价格比较，以及城市独特的文化生活。\"&gt;\n&lt;meta name=\"keywords\" content=\"豆瓣,广播,登陆豆瓣\"&gt;.....\n</code></pre>\n<p>发送 POST 请求</p>\n<p>对于 POST 请求，一般就是提交一个表单</p>\n<pre><code>r = requests.post('http://www.xxxx.com', data={\"key\": \"value\"})\n</code></pre>\n<blockquote>\n<p>data 当中，就是需要传递的表单信息，是一个字典类型的数据。</p>\n</blockquote>\n<p><strong>header 增强</strong></p>\n<p>对于有些网站，会拒绝掉没有携带 header 的请求的，所以需要做一些 header 增强。比如：UA，Cookie，host 等等信息。</p>\n<pre><code>header = {\"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36\",\n         \"Cookie\": \"your cookie\"}\nres = requests.get('http://www.xxx.com', headers=header)\n</code></pre>\n<p><strong>解析 HTML</strong></p>\n<p>现在我们已经获取到了网页返回的数据，即 HTML 代码，下面就需要解析 HTML，来提取其中有效的信息。</p>\n<p><strong>BeautifulSoup</strong></p>\n<p>BeautifulSoup 是 Python 的一个库，最主要的功能是从网页解析数据。</p>\n<pre><code class=\"language-python\">from bs4 import BeautifulSoup  # 导入 BeautifulSoup 的方法\n# 可以传入一段字符串，或者传入一个文件句柄。一般都会先用 requests 库获取网页内容，然后使用 soup 解析。\nsoup = BeautifulSoup(html_doc,'html.parser')  # 这里一定要指定解析器，可以使用默认的 html，也可以使用 lxml。\nprint(soup.prettify())  # 按照标准的缩进格式输出获取的 soup 内容。</code></pre>\n<p>BeautifulSoup 的一些简单用法 </p>\n<pre><code class=\"language-python\">print(soup.title)  # 获取文档的 title\nprint(soup.title.name)  # 获取 title 的 name 属性\nprint(soup.title.string)  # 获取 title 的内容\nprint(soup.p)  # 获取文档中第一个 p 节点\nprint(soup.p['class'])  # 获取第一个 p 节点的 class 内容\nprint(soup.find_all('a'))  # 获取文档中所有的 a 节点，返回一个 list\nprint(soup.find_all('span', attrs={'style': \"color:#ff0000\"}))  # 获取文档中所有的 span 且 style 符合规则的节点，返回一个 list</code></pre>\n<p>具体的用法和效果，我会在后面的实战中详细说明。</p>\n<p><strong>XPath 定位</strong></p>\n<p>XPath 是 XML 的路径语言，是通过元素和属性进行导航定位的。几种常用的表达式</p>\n<p>表达式含义node选择 node 节点的所有子节点/从根节点选取//选取所有当前节点.当前节点..父节点@属性选取text()当前路径下的文本内容</p>\n<p>一些简单的例子</p>\n<pre><code class=\"language-python\">xpath('node')  # 选取 node 节点的所有子节点\nxpath('/div')  # 从根节点上选取 div 元素\nxpath('//div')  # 选取所有 div 元素\nxpath('./div')  # 选取当前节点下的 div 元素\nxpath('//@id')  # 选取所有 id 属性的节点</code></pre>\n<p>  当然，XPath 非常强大，但是语法也相对复杂，不过我们可以通过 Chrome 的开发者工具来快速定位到元素的 xpath，如下图</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\b3085361ffd769b751095a89e8b7dcfc.png\"/></p>\n<p>得到的 xpath 为</p>\n<pre><code>//*[@id=\"anony-nav\"]/div[1]/ul/li[1]/a\n</code></pre>\n<p>在实际的使用过程中，到底使用 BeautifulSoup 还是 XPath，完全取决于个人喜好，哪个用起来更加熟练方便，就使用哪个。</p>\n<h1>爬虫实战：爬取豆瓣海报</h1>\n<p>我们可以从豆瓣影人页，进入都影人对应的影人图片页面，比如以刘涛为例子，她的影人图片页面地址为</p>\n<blockquote>\n<p>https://movie.douban.com/celebrity/1011562/photos/</p>\n</blockquote>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\e52290e31eb9942a6422574c267d6647.png\"/></p>\n<p>下面我们就来分析下这个网页</p>\n<h1><strong>目标网站页面分析</strong></h1>\n<p>注意：网络上的网站页面构成总是会变化的，所以这里你需要学会分析的方法，以此类推到其他网站。正所谓授人以鱼不如授人以渔，就是这个原因。</p>\n<h1><strong>Chrome 开发者工具</strong></h1>\n<p>Chrome 开发者工具（按 F12 打开），是分析网页的绝佳利器，一定要好好使用。</p>\n<p>我们在任意一张图片上右击鼠标，选择“检查”，可以看到同样打开了“开发者工具”，而且自动定位到了该图片所在的位置</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\c8b1a044579267406cf5c163b9f301fb.png\"/></p>\n<p>可以清晰的看到，每张图片都是保存在 li 标签中的，图片的地址保存在 li 标签中的 img 中。</p>\n<p>知道了这些规律后，我们就可以通过 BeautifulSoup 或者 XPath 来解析 HTML 页面，从而获取其中的图片地址。</p>\n<h1><strong>代码编写</strong></h1>\n<p>我们只需要短短的几行代码，就能完成图片 url 的提取</p>\n<pre><code>import requests\nfrom bs4 import BeautifulSoup \n\nurl = 'https://movie.douban.com/celebrity/1011562/photos/'\nres = requests.get(url).text\ncontent = BeautifulSoup(res, \"html.parser\")\ndata = content.find_all('div', attrs={'class': 'cover'})\npicture_list = []\nfor d in data:\n    plist = d.find('img')['src']\n    picture_list.append(plist)\nprint(picture_list)\n&gt;&gt;&gt;\n['https://img1.doubanio.com/view/photo/m/public/p2564834267.jpg', 'https://img1.doubanio.com/view/photo/m/public/p860687617.jpg', 'https://img1.doubanio.com/view/photo/m/public/p2174001857.jpg', 'https://img1.doubanio.com/view/photo/m/public/p1563789129.jpg', 'https://img3.doubanio.com/view/photo/m/public/p2363429946.jpg', 'https://img1.doubanio.com/view/photo/m/public/p2382591759.jpg', 'https://img3.doubanio.com/view/photo/m/public/p2363269182.jpg', 'https://img1.doubanio.com/view/photo/m/public/p1959495269.jpg', 'https://img3.doubanio.com/view/photo/m/public/p2356638830.jpg', 'https://img3.doubanio.com/view/photo/m/public/p1959495471.jpg', 'https://img3.doubanio.com/view/photo/m/public/p1834379290.jpg', 'https://img3.doubanio.com/view/photo/m/public/p2325385303.jpg', 'https://img3.doubanio.com/view/photo/m/public/p2361707270.jpg', 'https://img3.doubanio.com/view/photo/m/public/p2325385321.jpg', 'https://img3.doubanio.com/view/photo/m/public/p2196488184.jpg', 'https://img1.doubanio.com/view/photo/m/public/p2186019528.jpg', 'https://img1.doubanio.com/view/photo/m/public/p2363270277.jpg', 'https://img3.doubanio.com/view/photo/m/public/p2325240501.jpg', 'https://img1.doubanio.com/view/photo/m/public/p2258657168.jpg', 'https://img1.doubanio.com/view/photo/m/public/p2319710627.jpg', 'https://img3.doubanio.com/view/photo/m/public/p2319710591.jpg', 'https://img3.doubanio.com/view/photo/m/public/p2311434791.jpg', 'https://img1.doubanio.com/view/photo/m/public/p2363270708.jpg', 'https://img3.doubanio.com/view/photo/m/public/p2258657185.jpg', 'https://img3.doubanio.com/view/photo/m/public/p2166193915.jpg', 'https://img3.doubanio.com/view/photo/m/public/p2363265595.jpg', 'https://img3.doubanio.com/view/photo/m/public/p2312085755.jpg', 'https://img3.doubanio.com/view/photo/m/public/p2311434790.jpg', 'https://img3.doubanio.com/view/photo/m/public/p2276569205.jpg', 'https://img1.doubanio.com/view/photo/m/public/p2165332728.jpg']</code></pre>\n<p>可以看到，是非常干净的列表，里面存储了海报地址。<br/> 但是这里也只是一页海报的数据，我们观察页面发现它有好多分页，如何处理分页呢。</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\4076785880cd2a298db53520ae02fcd2.png\"/></p>\n<h1><strong>分页处理</strong></h1>\n<p>我们点击第二页，看看浏览器 url 的变化</p>\n<blockquote>\n<p>https://movie.douban.com/celebrity/1011562/photos/?type=C&amp;start=30&amp;sortby=like&amp;size=a&amp;subtype=a</p>\n</blockquote>\n<p>发现浏览器 url 增加了几个参数</p>\n<p>再点击第三页，继续观察 url</p>\n<blockquote>\n<p>https://movie.douban.com/celebrity/1011562/photos/?type=C&amp;start=60&amp;sortby=like&amp;size=a&amp;subtype=a</p>\n</blockquote>\n<p>通过观察可知，这里的参数，只有 start 是变化的，即为变量，其余参数都可以按照常理来处理</p>\n<p>同时还可以知道，这个 start 参数应该是起到了类似于 page 的作用，start = 30 是第二页，start = 60 是第三页，依次类推，最后一页是 start = 420。</p>\n<p>于是我们处理分页的代码也呼之欲出了</p>\n<p>首先将上面处理 HTML 页面的代码封装成函数</p>\n<pre><code>def get_poster_url(res):\n    content = BeautifulSoup(res, \"html.parser\")\n    data = content.find_all('div', attrs={'class': 'cover'})\n    picture_list = []\n    for d in data:\n        plist = d.find('img')['src']\n        picture_list.append(plist)\n    return picture_list</code></pre>\n<p>然后我们在另一个函数中处理分页和调用上面的函数</p>\n<pre><code>def fire():\n    page = 0\n    for i in range(0, 450, 30):\n        print(\"开始爬取第 %s 页\" % page)\n        url = 'https://movie.douban.com/celebrity/1011562/photos/?type=C&amp;start={}&amp;sortby=like&amp;size=a&amp;subtype=a'.format(i)\n        res = requests.get(url).text\n        data = get_poster_url(res)\n        page += 1\n</code></pre>\n<p>此时，我们所有的海报数据都保存在了 data 变量中，现在就需要一个下载器来保存海报了</p>\n<pre><code>def download_picture(pic_l):\n    if not os.path.exists(r'picture'):\n        os.mkdir(r'picture')\n    for i in pic_l:\n        pic = requests.get(i)\n        p_name = i.split('/')[7]\n        with open('picture\\\\' + p_name, 'wb') as f:\n            f.write(pic.content)\n</code></pre>\n<p>再增加下载器到 fire 函数，此时为了不是请求过于频繁而影响豆瓣网的正常访问，设置 sleep time 为1秒</p>\n<pre><code>def fire():\n    page = 0\n    for i in range(0, 450, 30):\n        print(\"开始爬取第 %s 页\" % page)\n        url = 'https://movie.douban.com/celebrity/1011562/photos/?type=C&amp;start={}&amp;sortby=like&amp;size=a&amp;subtype=a'.format(i)\n        res = requests.get(url).text\n        data = get_poster_url(res)\n        download_picture(data)\n        page += 1\n        time.sleep(1)\n</code></pre>\n<p>下面就执行 fire 函数，等待程序运行完成后，当前目录下会生成一个 picture 的文件夹，里面保存了我们下载的所有海报</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\ac65472c2f89a022b1757efa5ae076b7.png\"/></p>\n<p> </p>\n<h1>核心代码讲解</h1>\n<p>下面再来看下完整的代码</p>\n<pre><code>import requests\nfrom bs4 import BeautifulSoup\nimport time\nimport osdef fire():\n    page = 0\n    for i in range(0, 450, 30):\n        print(\"开始爬取第 %s 页\" % page)\n        url = 'https://movie.douban.com/celebrity/1011562/photos/?type=C&amp;start={}&amp;sortby=like&amp;size=a&amp;subtype=a'.format(i)\n        res = requests.get(url).text\n        data = get_poster_url(res)\n        download_picture(data)\n        page += 1\n        time.sleep(1)def get_poster_url(res):\n    content = BeautifulSoup(res, \"html.parser\")\n    data = content.find_all('div', attrs={'class': 'cover'})\n    picture_list = []\n    for d in data:\n        plist = d.find('img')['src']\n        picture_list.append(plist)\n    return picture_listdef download_picture(pic_l):\n    if not os.path.exists(r'picture'):\n        os.mkdir(r'picture')\n    for i in pic_l:\n        pic = requests.get(i)\n        p_name = i.split('/')[7]\n        with open('picture\\\\' + p_name, 'wb') as f:\n            f.write(pic.content)if __name__ == '__main__':\n    fire()\n</code></pre>\n<p><strong>fire 函数</strong></p>\n<p>这是一个主执行函数，使用 range 函数来处理分页。</p>\n<ul><li>range 函数可以快速的创建整数列表，在 for 循环时及其好用。函数中的0代表从0开始计数，450代表一直迭代到450，不包含450，30代表步长，即每次递增的数字间隔。range(0, 450, 30)，依次会输出：0，30，60，90 …</li><li>format 函数，是一种字符串格式化方式</li><li>time.sleep(1) 即为暂停1秒钟</li></ul>\n<p><strong>get_poster_url 函数</strong></p>\n<p>这个就是解析 HTML 的函数，使用的是 BeautifulSoup</p>\n<ul><li>通过 find_all 方法查找所有 class 为 “cover” 的 div 元素，返回的是一个列表</li><li>使用 for 循环，循环上一步拿到的列表，取出 src 的内容，append 到列表中</li><li>append 是列表的一个方法，可以在列表后面追加元素</li></ul>\n<p><strong>download_picture 函数</strong></p>\n<p>简易图片下载器</p>\n<ul><li>首先判断当前目录下是否存在 picture 文件夹，os.path.exists</li><li>os 库是非常常用用来操作系统相关的命令库，os.mkdir 就是创建文件夹</li><li>split 用于切割字符串，取出角标为7的元素，作为存储图片的名称</li><li>with 方法用来快速打开文件，打开的进程可以自行关闭文件句柄，而不再需要手动执行 f.close() 关闭文件</li></ul>\n<h1>总结</h1>\n<p>本节讲解了爬虫的基本流程以及需要用到的 Python 库和方法，并通过一个实际的例子完成了从分析网页，到数据存储的全过程。其实爬虫，无外乎模拟请求，解析数据，保存数据。</p>\n<p>当然有的时候，网站还会设置各种反爬机制，比如 cookie 校验，请求频度检查，非浏览器访问限制，JS 混淆等等，这个时候就需要用到反反爬技术了，比如抓取 cookie 放到 headers 中，使用代理 IP 访问，使用 Selenium 模拟浏览器等待方式。</p>\n<p>由于本课程不是专门的爬虫课，这些技能就留待你自己去探索挖掘啦。</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\7fae6b98f933472d2310890555a96265.png\"/></p>\n<p> </p>\n<p><strong> 作为过来人，跟大家聊一聊我的自学心得，希望可以帮助大家少走弯路，少踩坑。</strong></p>\n<p><strong>更多Python、爬虫、人工智能配套视频教程+书籍可以+v 免费领取。</strong></p>\n<p> <img alt=\"\" height=\"396\" src=\"image\\20210914110457247.jpg\" width=\"396\"/></p>\n<p><strong>对方向选择、学习规划、学习路线、职业发展方面有问题的可以加群：809160367</strong></p>\n<p><img alt=\"\" src=\"image\\20210913104034379.png\"/></p>\n<p> <img alt=\"\" height=\"167\" src=\"image\\20210914110642808.jpg\" width=\"720\"/></p>\n</div>\n</div>"}