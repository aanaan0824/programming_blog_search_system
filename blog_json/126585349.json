{"blogid": "126585349", "writerAge": "码龄1年", "writerBlogNum": "112", "writerCollect": "1142", "writerComment": "482", "writerFan": "5190", "writerGrade": "5级", "writerIntegral": "2021", "writerName": "十八岁讨厌Java", "writerProfileAdress": "writer_image\\profile_126585349.jpg", "writerRankTotal": "8674", "writerRankWeekly": "210", "writerThumb": "450", "writerVisitNum": "37513", "blog_read_count": "302", "blog_time": "于 2022-08-30 07:58:40 发布", "blog_title": "Java如何实现统计在线人数的功能？", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>很多人在笔试或者面试中问到：现在要你实现一个统计在线人数的功能，你该怎么设计？</p>\n<p>不知道的朋友，这篇文章告诉你。</p>\n<p><strong>先说答案：可以利用监听器Listener来实现</strong></p>\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"1.%20%E7%9B%91%E5%90%AC%E5%99%A8%E7%9A%84%E7%AE%80%E4%BB%8B-toc\" style=\"margin-left:0px;\"><a href=\"#1.%20%E7%9B%91%E5%90%AC%E5%99%A8%E7%9A%84%E7%AE%80%E4%BB%8B\">1. 监听器的简介</a></p>\n<p id=\"2.%20Java%E7%9B%91%E5%90%AC%E5%99%A8%E7%9A%84%E7%B1%BB%E5%9E%8B-toc\" style=\"margin-left:0px;\"><a href=\"#2.%20Java%E7%9B%91%E5%90%AC%E5%99%A8%E7%9A%84%E7%B1%BB%E5%9E%8B\">2. Java监听器的类型</a></p>\n<p id=\"(1)ServletContextListener-toc\" style=\"margin-left:40px;\"><a href=\"#%281%29ServletContextListener\">(1)ServletContextListener</a></p>\n<p id=\"(2)HttpSessionListener-toc\" style=\"margin-left:40px;\"><a href=\"#%282%29HttpSessionListener\">(2)HttpSessionListener</a></p>\n<p id=\"(3)ServletRequestListener-toc\" style=\"margin-left:40px;\"><a href=\"#%283%29ServletRequestListener\">(3)ServletRequestListener</a></p>\n<p id=\"(4)ServletContextAttributeListener-toc\" style=\"margin-left:40px;\"><a href=\"#%284%29ServletContextAttributeListener\">(4)ServletContextAttributeListener</a></p>\n<p id=\"(5)HttpSessionAttributeListener%EF%BC%9A-toc\" style=\"margin-left:40px;\"><a href=\"#%285%29HttpSessionAttributeListener%EF%BC%9A\">(5)HttpSessionAttributeListener：</a></p>\n<p id=\"(6)ServletRequestAttributeListener%EF%BC%9A-toc\" style=\"margin-left:40px;\"><a href=\"#%286%29ServletRequestAttributeListener%EF%BC%9A\">(6)ServletRequestAttributeListener：</a></p>\n<p id=\"(7)HttpSessionActivationListener-toc\" style=\"margin-left:40px;\"><a href=\"#%287%29HttpSessionActivationListener\">(7)HttpSessionActivationListener</a></p>\n<p id=\"3.%E7%9B%91%E5%90%AC%E5%99%A8Listener%E5%AE%9E%E7%8E%B0%E7%BB%9F%E8%AE%A1%E4%BA%BA%E6%95%B0%E5%8A%9F%E8%83%BD%C2%A0-toc\" style=\"margin-left:0px;\"><a href=\"#3.%E7%9B%91%E5%90%AC%E5%99%A8Listener%E5%AE%9E%E7%8E%B0%E7%BB%9F%E8%AE%A1%E4%BA%BA%E6%95%B0%E5%8A%9F%E8%83%BD%C2%A0\">3.监听器Listener实现统计人数功能 </a></p>\n<p id=\"4.Redis%E5%AE%9E%E7%8E%B0%E7%BB%9F%E8%AE%A1%E4%BA%BA%E6%95%B0%E5%8A%9F%E8%83%BD%C2%A0-toc\" style=\"margin-left:0px;\"><a href=\"#4.Redis%E5%AE%9E%E7%8E%B0%E7%BB%9F%E8%AE%A1%E4%BA%BA%E6%95%B0%E5%8A%9F%E8%83%BD%C2%A0\">4.Redis实现统计人数功能 </a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h1 id=\"1.%20%E7%9B%91%E5%90%AC%E5%99%A8%E7%9A%84%E7%AE%80%E4%BB%8B\"><strong>1. 监听器的简介</strong></h1>\n<p>监听器就是一个实现特定接口的普通java程序，这个程序专门用于监听另一个java对象的方法调用或属性改变，当被监听对象发生上述事件后，监听器某个方法将立即被执行。</p>\n<p></p>\n<h1 id=\"2.%20Java%E7%9B%91%E5%90%AC%E5%99%A8%E7%9A%84%E7%B1%BB%E5%9E%8B\"><strong>2. Java监听器的类型</strong></h1>\n<h2 id=\"(1)ServletContextListener\"><strong>(1)ServletContextListener</strong></h2>\n<p><strong>用于监听WEB，应用启动和销毁的事件</strong></p>\n<p><strong>public void contextInitialized(ServletContextEvent sce):在初始化web应用时执行</strong></p>\n<p><strong> public void contextDestroyed(ServletContextEvent sce) {}:在销毁web应用时执行</strong></p>\n<p></p>\n<h2 id=\"(2)HttpSessionListener\"><strong>(2)HttpSessionListener</strong></h2>\n<p><strong>用于监听Session对象的创建和销毁</strong></p>\n<p><strong>public void sessionCreated(HttpSessionEvent se) {}:session创建的时候执行</strong></p>\n<p><strong>public void sessionDestroyed(HttpSessionEvent se) {}: session被销毁的时候执行</strong></p>\n<p></p>\n<h2 id=\"(3)ServletRequestListener\"><strong>(3)ServletRequestListener</strong></h2>\n<p><strong>用于监听Requset对象的创建和销毁</strong></p>\n<p><strong>public void requsetCreated(HttpSessionEvent se) {}:requset创建的时候执行</strong></p>\n<p><strong>public void requestDestroyed(HttpSessionEvent se) {}: requset被销毁的时候执行</strong></p>\n<p></p>\n<h2 id=\"(4)ServletContextAttributeListener\"><strong>(4)ServletContextAttributeListener</strong></h2>\n<p><strong>用于监听WEB作用域属性的改动，包括：增加属性、删除属性、修改属性</strong></p>\n<p><strong>attributeAdded(ServletContextEvent sce):向ServletContext中添加属性时执行</strong></p>\n<p><strong>attributeAdded(ServletContextRemoved sce):ServletContext中删除属性时执行</strong></p>\n<p><strong>attributeReplaced(ServletContextRemoved sce):ServletContext中修改属性时执行</strong></p>\n<p></p>\n<h2 id=\"(5)HttpSessionAttributeListener%EF%BC%9A\"><strong>(5)HttpSessionAttributeListener</strong>：</h2>\n<p><strong>用于监听Session作用域属性的改动，包括：增加属性、删除属性、修改属性</strong></p>\n<h2 id=\"(6)ServletRequestAttributeListener%EF%BC%9A\"><strong>(6)ServletRequestAttributeListener</strong>：</h2>\n<p><strong>用于监听Requset作用域属性的改动，包括：增加属性、删除属性、修改属性</strong> </p>\n<h2 id=\"(7)HttpSessionActivationListener\"><strong>(7)HttpSessionActivationListener</strong></h2>\n<p><strong>用于监听某个对象在Session中的序列化和反序列化</strong></p>\n<p></p>\n<h1 id=\"3.%E7%9B%91%E5%90%AC%E5%99%A8Listener%E5%AE%9E%E7%8E%B0%E7%BB%9F%E8%AE%A1%E4%BA%BA%E6%95%B0%E5%8A%9F%E8%83%BD%C2%A0\">3.<strong>监听器Listener实现统计人数功能</strong> </h1>\n<p><strong>(1)先创建监听器包listener在新建OnlineListener类</strong></p>\n<blockquote>\n<p>package listener;<br/> import javax.servlet.ServletContext;<br/> import javax.servlet.ServletContextEvent;<br/> import javax.servlet.ServletContextListener;<br/> import javax.servlet.annotation.WebListener;<br/> import javax.servlet.http.HttpSessionAttributeListener;<br/> import javax.servlet.http.HttpSessionEvent;<br/> import javax.servlet.http.HttpSessionListener;<br/> import javax.servlet.http.HttpSessionBindingEvent;<br/>  <br/> @WebListener()<br/> public class OnlineListener implements ServletContextListener,HttpSessionListener, HttpSessionAttributeListener {<!-- --></p>\n<p><br/>     private static int count=0;<br/>  <br/>     public OnlineListener() {//构造函数<br/>     }<br/>  <br/>     // ServletContextListener的实现方法，在初始化web应用时执行，你可以在此处初始化server上下文相关数据<br/>     public void contextInitialized(ServletContextEvent sce) {//应用初始化完成<br/>    <br/>     }<br/>    <br/>     // ServletContextListener的实现方法，在web应用关闭时执行<br/>     public void contextDestroyed(ServletContextEvent sce) {<!-- --><br/>      <br/>     }<br/>  <br/>     // HttpSessionListener的实现方法，session被创建的时候执行<br/>     public void sessionCreated(HttpSessionEvent se) {//创建<br/>         count++;<br/>         ServletContext app = se.getSession().getServletContext();<br/>         app.setAttribute(\"count\",count);<br/>     }</p>\n<p><br/>    // HttpSessionListener的实现方法，session被销毁的时候执行<br/>     public void sessionDestroyed(HttpSessionEvent se) {<!-- --><br/>         count--;<br/>         ServletContext app = se.getSession().getServletContext();<br/>         app.setAttribute(\"count\",count);<br/>     }<br/> }</p>\n</blockquote>\n<p><strong>(2)创建监听器servlet的接口</strong></p>\n<blockquote>\n<p>import javax.servlet.ServletContext;<br/> import javax.servlet.ServletException;<br/> import javax.servlet.annotation.WebServlet;<br/> import javax.servlet.http.HttpServlet;<br/> import javax.servlet.http.HttpServletRequest;<br/> import javax.servlet.http.HttpServletResponse;<br/> import java.io.IOException;<br/> import java.io.PrintWriter;<br/>  <br/> @WebServlet(name = \"OnlineServlet\",urlPatterns = \"/online\")<br/> public class OnlineServlet extends HttpServlet {<!-- --><br/>     protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {<!-- --><br/>      this.doGet(request, response);<br/>     }<br/>  <br/>     protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {<!-- --><br/>       String op=request.getParameter(\"op\");<br/>       String result=\"\";<br/>       switch (op){<!-- --><br/>           case \"login\":<br/>               //request.getSession()触发监听器的sessionCreated<br/>               ServletContext app=request.getSession().getServletContext();<br/>               int count= (int) app.getAttribute(\"count\");<br/>               result=String.format(\"当前%d人在线\",count);<br/>               break;<br/>           case \"logout\":<br/>               //销毁session，触发监听器的sessionDestroy<br/>               request.getSession().invalidate();//销毁session<br/>               result=\"您已经退出了！\";<br/>       }<br/>         response.setContentType(\"text/html;charset=utf-8\");<br/>         PrintWriter out=response.getWriter();<br/>         out.write(result);<br/>         out.close();<br/>     }<br/> }</p>\n</blockquote>\n<p></p>\n<h1 id=\"4.Redis%E5%AE%9E%E7%8E%B0%E7%BB%9F%E8%AE%A1%E4%BA%BA%E6%95%B0%E5%8A%9F%E8%83%BD%C2%A0\">4.<strong>Redis实现统计人数功能</strong> </h1>\n<p><strong>需求：平均访问时常，平均同时在线人数，最高同时在线人数</strong></p>\n<p><strong>（1）先设计数据表：</strong></p>\n<p>开始访问页面时间，离开页面时间表：（id，place，ip，user_id，user_name, begin_time, end_time, env, info,len_min）</p>\n<p>统计表：平均访问时常，平均同时在线人数，最高同时在线人数（id，day，age_len_visit_min, acu, pcu）</p>\n<p>统计记录表：每分钟的同时在线人数。 （id，min_time, num）</p>\n<p>（2）使用redis存储当前在线用户，每次调用可以看作浏览了一分钟(根据业务可以再细化，只需要定时任务记录上次一分钟和当前一分钟的用户，即可算出，某一个用户在某个页面的访问时常。<br/> （3）同时记录用户开始访问页面时间，离开页面时间，即可分析出后续。<br/> （4）为方便数据处理，可以记录每个页面每分钟的访问量。</p>\n<p>（5）redis, 存储2个hash：</p>\n<p>begin，定时器存储到的hash集合，记录详细信息<br/> now，接口传递过来的用户访问集合，记录刷新时间<br/> 通过定时器来进行更新，刷新操作。<br/> ps: hash中单独的key不可以自动设置过期，或者使用redis监听，使用String类型的key，监听是过滤，匹配到自己需要处理的再进行处理即可。</p>\n</div>\n</div>"}