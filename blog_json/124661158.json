{"blogid": "124661158", "writerAge": "码龄2年", "writerBlogNum": "27", "writerCollect": "534", "writerComment": "547", "writerFan": "1847", "writerGrade": "5级", "writerIntegral": "1967", "writerName": "一码超人", "writerProfileAdress": "writer_image\\profile_124661158.jpg", "writerRankTotal": "9640", "writerRankWeekly": "1202", "writerThumb": "673", "writerVisitNum": "29813", "blog_read_count": "882", "blog_time": "于 2022-05-09 11:51:38 发布", "blog_title": "php使用thinkphp快速搭建swoole玩转协程", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h2><strong>swoole4开始支持了类似go的协程，以下是进程、线程、协程之间的联系。</strong></h2>\n<p></p>\n<p>1，进程<br/> 经典定义：一个执行中程序的实例。系统中的每个程序都运行在某个进程的上下文中。（-摘自 CSAPP）</p>\n<p>进程是系统资源分配的最小单位</p>\n<p></p>\n<p>2，线程（thread）<br/> 线程就是运行在进程上下文中的逻辑流。</p>\n<p>线程是操作系统能够进行运算调度的最小单位。</p>\n<p></p>\n<p>3，协程<br/> 相对 子例程而言，协程更为一般和灵活，但在实践中使用没有子例程那样广泛。</p>\n<p>根据维基百科对子例程的描述：是一个大型程序中的某部分代码，由一个或多个语句块组成。它负责完成某项特定任务，而且相较于其他代码，具备相对的独立性。我可以将子例程理解为一个函数。<br/>  </p>\n<p></p>\n<h2><strong>协程与线程的区别:</strong></h2>\n<p><br/> 1 一个线程可以多个协程，一个进程也可以单独拥有多个协程。</p>\n<p>2 线程进程都是同步机制，而协程则是异步。</p>\n<p>3 协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态。</p>\n<p>4线程是抢占式，而协程是非抢占式的，所以需要用户自己释放使用权来切换到其他协程，因此同一时间其实只有一个协程拥有运行权，相当于单线程的能力。</p>\n<p>5协程并不是取代线程, 而且抽象于线程之上, 线程是被分割的CPU资源, 协程是组织好的代码流程, 协程需要线程来承载运行, 线程是协程的资源, 但协程不会直接使用线程, 协程直接利用的是执行器(Interceptor), 执行器可以关联任意线程或线程池, 可以使当前线程, UI线程, 或新建新程.。</p>\n<p>6 线程是协程的资源。协程通过Interceptor来间接使用线程这个资源。</p>\n<p>7 极高的执行效率：因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显；</p>\n<p>8 不需要多线程的锁机制：因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。<br/>  </p>\n<h2><strong>废话有点密了哈哈，本文将采用宝塔+thinkphp6+swoole搭建。具体流程如下：</strong></h2>\n<p>首先让我们来看看thinkphp6的手册，据说是支持了swoole扩展快速搭建。</p>\n<p>链接：<a href=\"https://www.kancloud.cn/manual/thinkphp6_0/1359700\" title=\"Swoole · ThinkPHP6.0完全开发手册 · 看云\">Swoole · ThinkPHP6.0完全开发手册 · 看云</a></p>\n<p>说真的，文档写的太对付了，不像workerman那样直接简单。</p>\n<p>这里我打算用另一种方式快速搭建。</p>\n<p>thinkphp支持自定义指令，链接：<a href=\"https://www.kancloud.cn/manual/thinkphp6_0/1037651\" title=\"自定义指令 · ThinkPHP6.0完全开发手册 · 看云\">自定义指令 · ThinkPHP6.0完全开发手册 · 看云</a></p>\n<h2>根据这个创建一个swoolews指令，如下：</h2>\n<p>1、安装宝塔（可略过）：</p>\n<p><a href=\"https://www.bt.cn/new/download.html\" title=\"宝塔面板下载，免费全能的服务器运维软件\">宝塔面板下载，免费全能的服务器运维软件</a></p>\n<p>2、安装thinkphp6（可略过）：</p>\n<p><a href=\"https://www.kancloud.cn/manual/thinkphp6_0/1037481\" title=\"安装 · ThinkPHP6.0完全开发手册 · 看云\">安装 · ThinkPHP6.0完全开发手册 · 看云</a></p>\n<p>3、创建自定义指令：</p>\n<p><img alt=\"\" height=\"519\" src=\"image\\e3ec4f9186364ab3967f295f9a3255bf.png\" width=\"993\"/></p>\n<p> <img alt=\"\" height=\"1040\" src=\"image\\43a6ea9b1c2348afacfb9780d35b451e.png\" width=\"1200\"/></p>\n<p> <img alt=\"\" height=\"1040\" src=\"image\\539cda02682f424ba83a5eca0f3587d7.png\" width=\"1200\"/></p>\n<pre><code class=\"language-php\">'swoolews' =&gt; 'app\\command\\Swoolews',</code></pre>\n<p> </p>\n<p> <img alt=\"\" height=\"1040\" src=\"image\\6ab3d35179f9459095fa11f73f3d3aaf.png\" width=\"1200\"/></p>\n<p> 4、直接去swoole官方文档（抄代码！哈哈！）：</p>\n<p><a href=\"https://wiki.swoole.com/#/start/start_ws_server\" title=\"Swoole4 文档\">Swoole4 文档</a></p>\n<p><img alt=\"\" height=\"905\" src=\"image\\9fa34332b0ff49f6a210b97d202af196.png\" width=\"1200\"/></p>\n<p> <img alt=\"\" height=\"1040\" src=\"image\\9b342a4701f94cfeb56c3d6fdaac4f76.png\" width=\"1200\"/></p>\n<p> </p>\n<pre><code class=\"language-php\">&lt;?php\ndeclare (strict_types = 1);\n\nnamespace app\\command;\n\nuse think\\console\\Command;\nuse think\\console\\Input;\nuse think\\console\\input\\Argument;\nuse think\\console\\input\\Option;\nuse think\\console\\Output;\n\nclass Swoolews extends Command\n{\n    protected function configure()\n    {\n        // 指令配置\n        $this-&gt;setName('swoolews')\n            -&gt;setDescription('the swoolews command');\n    }\n\n    protected function execute(Input $input, Output $output)\n    {\n        // 指令输出\n        $output-&gt;writeln('swoolews');\n\n        //创建WebSocket Server对象，监听0.0.0.0:9502端口\n        $ws = new \\Swoole\\WebSocket\\Server('0.0.0.0', 9501);\n\n        //监听WebSocket连接打开事件\n        $ws-&gt;on('Open', function ($ws, $request) {\n            $ws-&gt;push($request-&gt;fd, \"hello, welcome\\n\");\n        });\n\n        //监听WebSocket消息事件\n        $ws-&gt;on('Message', function ($ws, $frame) {\n            echo \"Message: {$frame-&gt;data}\\n\";\n            $ws-&gt;push($frame-&gt;fd, \"server: {$frame-&gt;data}\");\n        });\n\n        //监听WebSocket连接关闭事件\n        $ws-&gt;on('Close', function ($ws, $fd) {\n            echo \"client-{$fd} is closed\\n\";\n        });\n\n        $ws-&gt;start();\n\n\n    }\n}\n</code></pre>\n<p> </p>\n<p> 5、在项目目录下启动ws服务并测试（注意！记得服务器和宝塔开启9501端口，咱们服务配置的是9501端口）：</p>\n<p><img alt=\"\" height=\"905\" src=\"image\\f0b157af8b41473e88482b25edf80abf.png\" width=\"1200\"/></p>\n<p> 测试ws网站链接：<a href=\"http://coolaf.com/tool/chattest\" title=\"在线websocket测试-online tool-postjson\">在线websocket测试-online tool-postjson</a></p>\n<p> </p>\n<p> 随便发送个消息：</p>\n<p><img alt=\"\" height=\"905\" src=\"image\\b1a76de9e8d74e5f9de6175de461f121.png\" width=\"1200\"/></p>\n<p> </p>\n<p> <img alt=\"\" height=\"905\" src=\"image\\c45e3c0373c341288f5bfb29ad7e3fb6.png\" width=\"1200\"/></p>\n<p> 有回应就说明没有问题喽，当然上述代码可能不易于维护，你也可以根据swoole官方文档给的基础知识改写一下：</p>\n<p><a href=\"https://wiki.swoole.com/#/learn?id=%E5%9B%9B%E7%A7%8D%E8%AE%BE%E7%BD%AE%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%9A%84%E6%96%B9%E5%BC%8F\" title=\"Swoole4 文档\">Swoole4 文档</a></p>\n<p>6、测试协程</p>\n<p>协程文档链接：<a href=\"https://wiki.swoole.com/#/start/coroutine\" title=\"Swoole4 文档\">Swoole4 文档</a></p>\n<p> <img alt=\"\" height=\"905\" src=\"image\\437721718a6341bd85376c59816c9b0f.png\" width=\"1200\"/></p>\n<p> <img alt=\"\" height=\"1040\" src=\"image\\d0a304709c0449e2bc6b20fbb7af0a18.png\" width=\"1200\"/></p>\n<p> </p>\n<pre><code class=\"language-php\">&lt;?php\ndeclare (strict_types = 1);\n\nnamespace app\\command;\n\nuse think\\console\\Command;\nuse think\\console\\Input;\nuse think\\console\\input\\Argument;\nuse think\\console\\input\\Option;\nuse think\\console\\Output;\nuse Swoole\\Coroutine;\nuse function Swoole\\Coroutine\\go;\nclass Swoolews extends Command\n{\n    protected function configure()\n    {\n        // 指令配置\n        $this-&gt;setName('swoolews')\n            -&gt;setDescription('the swoolews command');\n    }\n\n    protected function execute(Input $input, Output $output)\n    {\n        // 指令输出\n        $output-&gt;writeln('swoolews');\n\n        //创建WebSocket Server对象，监听0.0.0.0:9502端口\n        $ws = new \\Swoole\\WebSocket\\Server('0.0.0.0', 9501);\n\n        //监听WebSocket连接打开事件\n        $ws-&gt;on('Open', function ($ws, $request) {\n            $ws-&gt;push($request-&gt;fd, \"hello, welcome\\n\");\n        });\n\n        //监听WebSocket消息事件\n        $ws-&gt;on('Message', function ($ws, $frame) {\n            echo \"Message: {$frame-&gt;data}\\n\";\n            //协程测试\n            for($i=0;$i&lt;10;$i++) {\n                go(function () use ($ws ,$frame, $i) {\n\n                    for ($n = 100; $n--;) {\n                        usleep(1000);\n                    }\n                });\n            }\n            $ws-&gt;push($frame-&gt;fd, \"server: 完成\");\n        });\n\n        //监听WebSocket连接关闭事件\n        $ws-&gt;on('Close', function ($ws, $fd) {\n            echo \"client-{$fd} is closed\\n\";\n        });\n\n        $ws-&gt;start();\n\n\n    }\n}\n</code></pre>\n<p> 重启服务</p>\n<p><img alt=\"\" height=\"905\" src=\"image\\b47d66300851420eaf6f8cb213f743d4.png\" width=\"1200\"/></p>\n<p> <img alt=\"\" height=\"905\" src=\"image\\cb04ab24c5264231adbd963b6ee23bff.png\" width=\"1200\"/></p>\n<p> 效果还是不错的！</p>\n<p>7、swoole协程与go协程的区别</p>\n<p>go语言协程相对智能很多，使用的是MPG模式调度协程～ 简单说就是产生的所有协程其它的线程是有空就能去执行的，是多cpu调度的，相当于有一个协程池，空闲的cpu会去池子里执行协程任务，相比swoole的单cpu调用更有效地利用系统资源。可以方便的实现API的并行处理，达到处理效率的最大化。 </p>\n<p>所以咱们也不去夸大swoole的能力，真正要说协程比较强大的还是goroutine，这个咱不犟。</p>\n<p>swoole协程还是在io操作上能提高效率，其他情况还是考虑php多进程，java多线程或go的goroutine吧！</p>\n<p></p>\n<p>记得三连哦！</p>\n<p>海蜘蛛：只要自己足够废物，那么就没有天敌！</p>\n</div>\n</div>"}