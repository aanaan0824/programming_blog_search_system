{"blogid": "122906959", "writerAge": "码龄2年", "writerBlogNum": "80", "writerCollect": "930", "writerComment": "1489", "writerFan": "2526", "writerGrade": "6级", "writerIntegral": "6616", "writerName": "The   August", "writerProfileAdress": "writer_image\\profile_122906959.jpg", "writerRankTotal": "2776", "writerRankWeekly": "1756", "writerThumb": "1880", "writerVisitNum": "69372", "blog_read_count": "1551", "blog_time": "于 2022-03-13 18:04:57 发布", "blog_title": "C++--多态", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-light\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p></p>\n<div class=\"toc\">\n<h3>C++--多态</h3>\n<ul><li><a href=\"#_1\">多态的定义及实现</a></li><li><ul><li><a href=\"#_7\">多态的构成条件</a></li><li><a href=\"#_73\">虚函数</a></li><li><a href=\"#_93\">虚函数的重写</a></li><li><a href=\"#C11_override__final_154\">C++11 override 和 final</a></li></ul>\n</li><li><a href=\"#_165\">重载、覆盖(重写)、隐藏(重定义)</a></li><li><a href=\"#_169\">抽象类</a></li><li><ul><li><a href=\"#_216\">接口继承和实现继承</a></li></ul>\n</li><li><a href=\"#_249\">多态的原理</a></li><li><ul><li><a href=\"#_250\">虚函数表</a></li><li><a href=\"#_330\">多态的原理</a></li><li><a href=\"#_370\">动态绑定与静态绑定</a></li></ul>\n</li><li><a href=\"#_378\">单继承和多继承关系的虚函数表</a></li><li><ul><li><a href=\"#_379\">单继承中的虚函数表</a></li><li><a href=\"#_451\">多继承中的虚函数表</a></li><li><a href=\"#_462\">菱形继承、菱形虚拟继承</a></li></ul>\n</li><li><a href=\"#_476\">总结</a></li></ul>\n</div>\n<p></p>\n<h1><a id=\"_1\"></a>多态的定义及实现</h1>\n<blockquote>\n<p>多态：通俗来说，就是多种形态，具体点就是去完成某个行为，当不同的对象去完成时会产生出不同的状态。</p>\n</blockquote>\n<h2><a id=\"_7\"></a>多态的构成条件</h2>\n<p><strong>多态是在不同继承关系的类对象，去调用同一函数，产生了不同的行为</strong></p>\n<p>在继承中要构成多态有两个条件：</p>\n<ol><li><strong>必须通过基类的指针或者引用调用虚函数</strong></li><li><strong>被调用的函数必须是虚函数，且派生类必须对基类的虚函数进行重写</strong></li></ol>\n<pre><code class=\"prism language-cpp\"><span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> _CRT_SECURE_NO_WARNINGS 1</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;iostream&gt;</span></span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Person</span> \n<span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n\t<span class=\"token keyword\">virtual</span> <span class=\"token keyword\">void</span> <span class=\"token function\">BuyTicket</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> \n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\tcout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"正常排队-全价买票\"</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span> \n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Student</span> <span class=\"token operator\">:</span> <span class=\"token keyword\">public</span> Person\n<span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n\t<span class=\"token keyword\">virtual</span> <span class=\"token keyword\">void</span> <span class=\"token function\">BuyTicket</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\">//重写/覆盖 父类虚函数</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\tcout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"正常排队-半价买票\"</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Soldier</span> <span class=\"token operator\">:</span> <span class=\"token keyword\">public</span> Person\n<span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n\t<span class=\"token keyword\">virtual</span> <span class=\"token keyword\">void</span> <span class=\"token function\">BuyTicket</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>   <span class=\"token comment\">//重写/覆盖 父类虚函数</span>\n\t<span class=\"token punctuation\">{<!-- --></span> \n\t\tcout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"优先买票-全价买票\"</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span> \n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span> \n\n<span class=\"token comment\">// 多态两个条件：</span>\n<span class=\"token comment\">//  1. 子类重写父类的虚函数</span>\n<span class=\"token comment\">//  2. 必修是父类的指针或者引用去调用虚函数</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">Func</span><span class=\"token punctuation\">(</span>Person<span class=\"token operator\">*</span> ptr<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token comment\">//多态--ptr指向父类对象调用父类的虚函数，指向子类对象调用子类虚函数</span>\n\tptr<span class=\"token operator\">-</span><span class=\"token operator\">&gt;</span><span class=\"token function\">BuyTicket</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\tPerson ps<span class=\"token punctuation\">;</span>\n\tStudent st<span class=\"token punctuation\">;</span>\n\tSoldier sd<span class=\"token punctuation\">;</span>\n\t\n\t<span class=\"token function\">Func</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>ps<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">Func</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>st<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">Func</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>sd<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>补充：</p>\n<ul><li>有些书籍会把多态进行更细的划分：</li><li>\n<ol><li>静态的多态–函数重载 调用同一个函数，传不同的参数，就有不同行为（形态）</li></ol> </li><li>\n<ol start=\"2\"><li>动态的多态–调用一个虚函数，不同对象去调用，就有不同的行为（形态）</li></ol> </li></ul>\n<h2><a id=\"_73\"></a>虚函数</h2>\n<p><strong>虚函数：即被virtual修饰的类成员函数称为虚函数</strong></p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Person</span> <span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n <span class=\"token keyword\">virtual</span> <span class=\"token keyword\">void</span> <span class=\"token function\">BuyTicket</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span> cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"买票-全价\"</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span> <span class=\"token comment\">//虚函数</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>注：这里的虚函数与虚继承使用了同一个关键字，但是要注意这两个语法并没有关联</p>\n<p>补充：</p>\n<ol><li>虚函数的作用是用来实现多态</li><li>virtual关键字只在声明时加上，在类外实现时不能加</li><li>static和virtual是不能同时使用的</li><li>友元函数不属于成员函数，不能成为虚函数</li><li>静态成员函数就不能设置为虚函数</li><li>静态成员函数与具体对象无关，属于整个类，核心关键是没有隐藏的this指针，可以通过类名::成员函数名 直接调用，此时没有this无法拿到虚表，就无法实现多态，因此不能设置为虚函数</li><li>尤其是父类的析构函数强力建议设置为虚函数，这样动态释放父类指针所指的子类对象时，能够达到析构的多态</li></ol>\n<h2><a id=\"_93\"></a>虚函数的重写</h2>\n<blockquote>\n<p>虚函数的重写(覆盖)：<strong>派生类中有一个跟基类完全相同的虚函数(即派生类虚函数与基类虚函数的返回值类型、函数名字、参数列表完全相同)，称子类的虚函数重写了基类的虚函数。</strong></p>\n</blockquote>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Person</span> <span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n\t<span class=\"token keyword\">virtual</span> <span class=\"token keyword\">void</span> <span class=\"token function\">BuyTicket</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span> cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"买票-全价\"</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Student</span> <span class=\"token operator\">:</span> <span class=\"token keyword\">public</span> Person <span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n\t<span class=\"token keyword\">virtual</span> <span class=\"token keyword\">void</span> <span class=\"token function\">BuyTicket</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span> cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"买票-半价\"</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n\n\t<span class=\"token comment\">/*void BuyTicket() { cout &lt;&lt; \"买票-半价\" &lt;&lt; endl; }*/</span>\n\n\t<span class=\"token comment\">/*注意：在重写基类虚函数时，派生类的虚函数在不加virtual关键字时，虽然也可以构成重写(因为继承后基类的虚函数被继承下来了在派生类依旧保持虚函数属性),但是该种写法不是很规范，不建议这样使用*/</span>\n\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">Func</span><span class=\"token punctuation\">(</span>Person<span class=\"token operator\">&amp;</span> p<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\tp<span class=\"token punctuation\">.</span><span class=\"token function\">BuyTicket</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\tPerson ps<span class=\"token punctuation\">;</span>\n\tStudent st<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token function\">Func</span><span class=\"token punctuation\">(</span>ps<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">Func</span><span class=\"token punctuation\">(</span>st<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p><strong>虚函数重写有两个例外：</strong></p>\n<ol><li><strong>协变(基类与派生类虚函数返回值类型不同)</strong><br/> 派生类重写基类虚函数时，与基类虚函数返回值类型不同。即基类虚函数返回基类对象的指针或者引用，派生类虚函数返回派生类对象的指针或者引用时，称为协变</li></ol>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\aed7c788ec6142279fad6ae9aa48cd36.png\"/></p>\n<p><strong>2. 析构函数的重写(基类与派生类析构函数的名字不同)</strong></p>\n<blockquote>\n<p>如果基类的析构函数为虚函数，此时派生类析构函数只要定义，无论是否加virtual关键字，都与基类的析构函数构成重写。虽然基类与派生类析构函数名字不同。虽然函数名不相同，看起来违背了重写的规则，其实不然，这里可以理解为编译器对析构函数的名称做了特殊处理，编译后析构函数的名称统一处理成destructor。</p>\n</blockquote>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\ddfdd319523c486dbab245c5f35a490b.png\"/><br/> 注：<strong>在普通场景下，虚函数是否重写都是可以的</strong><br/> <img alt=\"在这里插入图片描述\" src=\"image\\75e2b160fd234a33ab160d82df8bef4e.png\"/><br/> 注：new函数的特殊场景需要用多态（虚函数重写）才能解决问题</p>\n<p>总结：</p>\n<ol><li>虚函数的重写(覆盖)：派生类虚函数与基类虚函数的返回值类型、函数名字、参数列表完全相同</li><li>在重写基类虚函数时，派生类的虚函数在不加virtual关键字时，也可以构成重写</li><li>协变和析构函数是重写的两个特例</li></ol>\n<h2><a id=\"C11_override__final_154\"></a>C++11 override 和 final</h2>\n<p><strong>final：修饰虚函数，表示该虚函数不能再被重写</strong><br/> <img alt=\"在这里插入图片描述\" src=\"image\\ca324b6c59404330abfb469ce9df79aa.png\"/><br/> <strong>override: 检查派生类虚函数是否重写了基类某个虚函数，如果没有重写编译报错。</strong><br/> <img alt=\"在这里插入图片描述\" src=\"image\\6529900d1dfb4ea79668e71969905f4d.png\"/></p>\n<p>总结：<br/> C++对函数重写的要求比较严格，但是有些情况下由于疏忽，可能会导致函数名字母次序<br/> 写反而无法构成重载，而这种错误在编译期间是不会报出的，只有在程序运行时没有得到预期结果才来debug会得不偿失，因此：C++11提供了override和final两个关键字，可以帮助用户检测是否重写。</p>\n<h1><a id=\"_165\"></a>重载、覆盖(重写)、隐藏(重定义)</h1>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\edaf281a83534743b974ea97cbbc7d33.png\"/></p>\n<h1><a id=\"_169\"></a>抽象类</h1>\n<blockquote>\n<p>在虚函数的后面写上 =0 ，则这个函数为纯虚函数，包含纯虚函数的类叫做抽象类（也叫接口类）。</p>\n</blockquote>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Car</span>  <span class=\"token comment\">//抽象类</span>\n<span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n\t<span class=\"token keyword\">virtual</span> <span class=\"token keyword\">void</span> <span class=\"token function\">Drive</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Benz</span> <span class=\"token operator\">:</span><span class=\"token keyword\">public</span> Car\n<span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n\t<span class=\"token keyword\">virtual</span> <span class=\"token keyword\">void</span> <span class=\"token function\">Drive</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\tcout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Benz-舒适\"</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">BMW</span> <span class=\"token operator\">:</span><span class=\"token keyword\">public</span> Car\n<span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n\t<span class=\"token keyword\">virtual</span> <span class=\"token keyword\">void</span> <span class=\"token function\">Drive</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\tcout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"BMW-操控\"</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">Test</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\tCar<span class=\"token operator\">*</span> pBenz <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> Benz<span class=\"token punctuation\">;</span>\n\tpBenz<span class=\"token operator\">-</span><span class=\"token operator\">&gt;</span><span class=\"token function\">Drive</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\tCar<span class=\"token operator\">*</span> pBMW <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> BMW<span class=\"token punctuation\">;</span>\n\tpBMW<span class=\"token operator\">-</span><span class=\"token operator\">&gt;</span><span class=\"token function\">Drive</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token function\">Test</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>注：</p>\n<ul><li>抽象类不能实例化出对象</li><li>派生类继承抽象类后也不能实例化出对象，只有重写纯虚函数，派生类才能实例化出对象</li><li>纯虚函数规范了派生类必须重写，<strong>另外纯虚函数更体现出了接口继承</strong></li><li>抽象类中可以定义成员函数以及成员变量，只是不能实例化出对象罢了</li></ul>\n<h2><a id=\"_216\"></a>接口继承和实现继承</h2>\n<ul><li><strong>普通函数的继承是一种实现继承</strong>，派生类继承了基类函数，可以使用函数，继承的是函数的实现。</li><li><strong>虚函数的继承是一种接口继承</strong>，派生类继承的是基类虚函数的接口，目的是为了重写，达成多态，继承的是接口。所以如果<strong>不实现多态，不要把函数定义成虚函数。</strong></li></ul>\n<p><strong>注意一下这类情况：</strong></p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">A</span> \n<span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n\t<span class=\"token keyword\">virtual</span> <span class=\"token keyword\">void</span> <span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> val <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span> std<span class=\"token operator\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"A-&gt;\"</span> <span class=\"token operator\">&lt;&lt;</span> val <span class=\"token operator\">&lt;&lt;</span> std<span class=\"token operator\">::</span>endl<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n\t<span class=\"token keyword\">virtual</span> <span class=\"token keyword\">void</span> <span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span> <span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">B</span> <span class=\"token operator\">:</span> <span class=\"token keyword\">public</span> A \n<span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n\t<span class=\"token comment\">//虚函数的继承是一种接口继承</span>\n\t<span class=\"token keyword\">void</span> <span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> val <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span> std<span class=\"token operator\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"B-&gt;\"</span> <span class=\"token operator\">&lt;&lt;</span> val <span class=\"token operator\">&lt;&lt;</span> std<span class=\"token operator\">::</span>endl<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> argc<span class=\"token punctuation\">,</span> <span class=\"token keyword\">char</span><span class=\"token operator\">*</span> argv<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\tB<span class=\"token operator\">*</span> p <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> B<span class=\"token punctuation\">;</span>\n\tp<span class=\"token operator\">-</span><span class=\"token operator\">&gt;</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n\t<span class=\"token comment\">//注意：子类重写父类的虚函数时，只是将虚函数的实现方法重写，</span>\n\t<span class=\"token comment\">//函数声明不变（包括virtual、函数名、参数、参数顺序、缺省值都跟父类的保持一致）</span>\n\t<span class=\"token comment\">//相当于：</span>\n\t<span class=\"token comment\">/*void func(int val = 1) { std::cout &lt;&lt; \"B-&gt;\" &lt;&lt; val &lt;&lt; std::endl; }*/</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">//运行结果：B-&gt;1</span>\n</code></pre>\n<h1><a id=\"_249\"></a>多态的原理</h1>\n<h2><a id=\"_250\"></a>虚函数表</h2>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\a229ab1cec18420a81984c2f85b6b414.png\"/><br/> 注：</p>\n<ul><li>虚函数表（虚表）–虚函数的地址要被放到虚函数表中。</li><li>除了_b成员，还多一个__vfptr放在对象的前面 <strong>(注意有些平台可能会放到对象的最后面，这个跟平台有关)</strong> ，对象中的这个指针叫做虚函数表指针(v代表virtual，f代表function)。</li></ul>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\324f91fa5dce46d0a8226b8ef861ce1b.png\"/></p>\n<p><strong>总结：</strong></p>\n<ol><li>派生类对象d1、d2中也有一个虚表指针，d1、d2对象由两部分构成，一部分是父类继承下来的成员，虚表指针也就是存在部分的另一部分是自己的成员。</li><li>基类b1对象和派生类d1对象虚表是不一样的，这里Func1完成了重写，所以d1的虚表中存的是重写的Derive::Func1，所以虚函数的重写也叫作覆盖，覆盖就是指虚表中虚函数的覆盖。<strong>重写是语法的叫法，覆盖是原理层的叫法</strong>。</li><li>另外Func2继承下来后是虚函数，所以放进了虚表，<strong>Func3也继承下来了，但是不是虚函数，所以不会放进虚表。</strong></li><li>虚函数表本质是一个存虚函数指针的指针数组，一般情况这个数组最后面放了一个nullptr。</li><li><strong>派生类的虚表生成：a.先将基类中的虚表内容拷贝一份到派生类虚表中 b.如果派生类重写了基类中某个虚函数，用派生类自己的虚函数覆盖虚表中基类的虚函数 c.派生类自己新增加的虚函数按其在派生类中的声明次序增加到派生类虚表的最后。</strong></li><li>虚表存的是虚函数指针，不是虚函数，虚函数和普通函数一样的，都是存在代码段的，只是他的指针又存到了虚表中。另外对象中存的不是虚表，存的是虚表指针。<strong>虚表存在代码段的(常量区)</strong></li></ol>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Base</span>\n<span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n\t<span class=\"token keyword\">virtual</span> <span class=\"token keyword\">void</span> <span class=\"token function\">Func1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\tcout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Base::Func1()\"</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token keyword\">virtual</span> <span class=\"token keyword\">void</span> <span class=\"token function\">Func2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\tcout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Base::Func2()\"</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">private</span><span class=\"token operator\">:</span>\n\t<span class=\"token keyword\">int</span> _b <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">typedef</span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>vfptr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 打印虚表</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">PrintVFT</span><span class=\"token punctuation\">(</span>vfptr vft<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%p\\n\"</span><span class=\"token punctuation\">,</span> vft<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>size_t i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>vft<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\n\t\t<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"vft[%d]:%p-&gt;\"</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">,</span> vft<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\tvft<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\tBase bb<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span><span class=\"token operator\">*</span> p1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span><span class=\"token operator\">*</span> p2 <span class=\"token operator\">=</span> <span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">auto</span> pf <span class=\"token operator\">=</span> PrintVFT<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> b <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\n\t<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"栈帧变量:%p\\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"堆变量:%p\\n\"</span><span class=\"token punctuation\">,</span> p1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"常量区变量:%p\\n\"</span><span class=\"token punctuation\">,</span> p2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"函数地址变量:%p\\n\"</span><span class=\"token punctuation\">,</span> pf<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"静态变量:%p\\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"虚函数表地址:%p\\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token operator\">&amp;</span>bb<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\n\t<span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\d9ead1acbacf437ba2b4eefd0df3d75d.png\"/></p>\n<blockquote>\n<p>注：</p>\n<ol><li>父子类无论是否完成虚函数重写，都有各自的独立的虚表</li><li>一个类的所有对象，共享一张虚表</li><li><strong>多态之所以必须通过基类的指针或者引用调用虚函数原因是指针或引用可以根据该对象的地址找到对应基类的部分，从中找到虚函数表，执行对应的函数；而用赋值传参的方式是万万不行的，因为赋值传参只是将子类中的成员变量切片赋值到父类中去，而参数中的父类还是用的是父类的虚表 ，综上多态必须通过基类的指针或者引用调用虚函数</strong></li></ol>\n</blockquote>\n<h2><a id=\"_330\"></a>多态的原理</h2>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Person</span> <span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n\t<span class=\"token keyword\">virtual</span> <span class=\"token keyword\">void</span> <span class=\"token function\">BuyTicket</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> \n\t<span class=\"token punctuation\">{<!-- --></span> \n\t\tcout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"买票-全价\"</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span> \n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Student</span> <span class=\"token operator\">:</span> <span class=\"token keyword\">public</span> Person \n<span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n\t<span class=\"token keyword\">virtual</span> <span class=\"token keyword\">void</span> <span class=\"token function\">BuyTicket</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\tcout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"买票-半价\"</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span> \n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">Func</span><span class=\"token punctuation\">(</span>Person<span class=\"token operator\">&amp;</span> p<span class=\"token punctuation\">)</span> \n<span class=\"token punctuation\">{<!-- --></span>\n\tp<span class=\"token punctuation\">.</span><span class=\"token function\">BuyTicket</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\tPerson Mike<span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">Func</span><span class=\"token punctuation\">(</span>Mike<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\tStudent Johnson<span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">Func</span><span class=\"token punctuation\">(</span>Johnson<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\8f99c5610afd4313a36258d8fd72f19b.png\"/></p>\n<p><strong>总结：多态的虚函数调用，不是在编译时确定的，是运行起来以后到对象的中去找的。不满足多态的函数调用时编译时确认好的。</strong></p>\n<h2><a id=\"_370\"></a>动态绑定与静态绑定</h2>\n<ol><li>静态绑定又称为前期绑定(早绑定)，<strong>在程序编译期间确定了程序的行为</strong>，也称为静态多态，比如：函数重载</li><li>动态绑定又称后期绑定(晚绑定)，<strong>是在程序运行期间，根据具体拿到的类型确定程序的具体行为，调用具体的函数</strong>，也称为动态多态。</li></ol>\n<h1><a id=\"_378\"></a>单继承和多继承关系的虚函数表</h1>\n<h2><a id=\"_379\"></a>单继承中的虚函数表</h2>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\5922e35862574cfd8fafab4c44b0f901.png\"/><br/> <strong>解决方法（使用代码打印出虚表中的函数）：</strong></p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Base</span>\n<span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n\t<span class=\"token keyword\">virtual</span> <span class=\"token keyword\">void</span> <span class=\"token function\">Func1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\tcout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Base::Func1()\"</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token keyword\">virtual</span> <span class=\"token keyword\">void</span> <span class=\"token function\">Func2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\tcout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Base::Func2()\"</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\t\n<span class=\"token keyword\">private</span><span class=\"token operator\">:</span>\n\t<span class=\"token keyword\">int</span> _b <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Derive</span> <span class=\"token operator\">:</span> <span class=\"token keyword\">public</span> Base\n<span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n\t<span class=\"token keyword\">virtual</span> <span class=\"token keyword\">void</span> <span class=\"token function\">Func1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\tcout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Derive::Func1()\"</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\n\t<span class=\"token keyword\">virtual</span> <span class=\"token keyword\">void</span> <span class=\"token function\">Func3</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\tcout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Base::Func3()\"</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">private</span><span class=\"token operator\">:</span>\n\t<span class=\"token keyword\">int</span> _d <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">typedef</span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>vfptr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 打印虚表</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">PrintVFT</span><span class=\"token punctuation\">(</span>vfptr vft<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%p\\n\"</span><span class=\"token punctuation\">,</span> vft<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>size_t i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>vft<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\n\t\t<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"vft[%d]:%p-&gt;\"</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">,</span> vft<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\tvft<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\tBase b<span class=\"token punctuation\">;</span>\n\n\tDerive d<span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">PrintVFT</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>vfptr<span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token operator\">&amp;</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">PrintVFT</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>vfptr<span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token operator\">&amp;</span>d<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n</code></pre>\n<blockquote>\n<p>思路：取出b、d对象的头4bytes，就是虚表的指针，虚函数表本质是一个存虚函数指针的指针数组，这个数组最后面放了一个nullptr</p>\n<ol><li>先取b的地址，强转成一个int*的指针</li><li>再解引用取值，就取到了b对象头4bytes的值，这个值就是指向虚表的指针</li><li>再强转成vfptr*，因为虚表就是一个存vfptr类型(虚函数指针类型)的数组。</li><li>虚表指针传递给PrintVFT进行打印虚表</li><li>需要说明的是这个打印虚表的代码经常会崩溃，因为编译器有时对虚表的处理不干净，虚表最后面没有放nullptr，导致越界，这是编译器的问题。我们只需要点目录栏的-生成-清理解决方案，再编译就好了。</li></ol>\n</blockquote>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\90cba8af75234a1795ad110555229755.png\"/><br/> 注：这里vs编译器的监视窗口故意隐藏了这个函数，也可以认为是他的一个小bug</p>\n<h2><a id=\"_451\"></a>多继承中的虚函数表</h2>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\58d9d51958b04797a56a8d87080049c8.png\"/><br/> 总结：</p>\n<ul><li>多继承派生类的未重写的虚函数放在第一个继承基类部分的虚函数表中</li><li>多继承派生类重写的虚函数在两个基类的虚表中的虚函数地址是不同的，但访问的函数是一样的，可以看出vs编译器在实现上多封装了一层，所以虚函数地址是不同的<br/> <img alt=\"在这里插入图片描述\" src=\"image\\58409683a4304fa380ba3f3cde5f2446.png\"/></li></ul>\n<h2><a id=\"_462\"></a>菱形继承、菱形虚拟继承</h2>\n<p>实际中不建议设计出菱形继承及菱形虚拟继承，一方面太复杂容易出问题，另一方面这样的模型，访问基类成员有一定得性能损耗。菱形继承、菱形虚拟继承在实际中很少用。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\707f924b25e040c2a07a9a8154f35f94.png\"/></p>\n<p>注：</p>\n<ul><li>菱形虚拟继承中当“腰部”重写虚函数时，“底部”就必须重写虚函数；否则会造成重写不明确问题（因为“顶部放在了公共部分”，当“腰部”都修改时，对象不知道选择哪一个，因此就会造成这种情况）</li><li>菱形虚拟继承中当“腰部”没有重写虚函数时，“底部”重写虚函数（可写可不写），编译器也不会报错</li><li>菱形虚拟继承中当“腰部”全部都是重写“顶部”成员函数时（也可以“顶部”的成员函数部分被重写），“底部”就必须重写虚函数，那么就只有一份公共的虚函数表，顺序是基类的虚基表指针、基类成员变量，虚基表指针、基类成员变量、派生类成员变量，公共（“顶部”）虚函数表、公共（“顶部”）成员变量；否则顺序为基类的虚表指针、虚基表指针、基类成员变量，基类的虚表指针、虚基表指针、基类成员变量、派生类成员变量，公共（“顶部”）虚函数表、公共（“顶部”）成员变量</li></ul>\n<h1><a id=\"_476\"></a>总结</h1>\n<ol><li>inline函数可以是虚函数，不过编译器就忽略inline属性，这个函数就不再是inline，因为inline函数是没有地址的，他都在调用的地方展开了虚函数是要把地址放进虚函数表中。（VS中是这样的，一个函数即使虚函数又是内联函数是不可以的，因为inline函数没有地址，虚函数需要放到虚函数表这两个是矛盾的）</li><li>静态成员不可以是虚函数，因为静态成员函数没有this指针，使用类型::成员函数的调用方式无法访问虚函数表，所以静态成员函数无法放进虚函数表。</li><li>构造函数不可以是虚函数，因为对象中的虚函数表指针是在构造函数初始化列表阶段才初始化的。（1.构造函数搞成虚函数没有意义，因为子类中要调用父类构造函数初始化，写成虚函数的目的是多态，构造函数不需要多态的方式。2.对象的虚函数表指针是在构造函数初始化列表阶段初始化的。如果构造函数是虚函数那么调用构造函数时对象中的虚表指针都没有初始化）</li><li>析构函数可以是虚函数，并且最好把基类的析构函数定义成虚函数。子类指针分别指向new父类或者子类及delete场景下析构函数是虚函数。</li><li>对象访问普通函数快还是虚函数更快？首先如果是普通对象，是一样快的。如果是指针对象或者是引用对象，则调用的普通函数快，因为构成多态，运行时调用虚函数需要到虚函数表中去查找。</li><li>虚函数表是在编译阶段就生成的，一般情况下存在代码段(常量区)的。</li><li>在虚函数的后面写上 =0 ，则这个函数为纯虚函数，包含纯虚函数的类叫做抽象类（也叫接口类）。抽象类强制重写了虚函数，另外抽象类体现出了接口继承关系。</li><li>菱形虚拟继承中，派生类调用构造函数初始化时，编译器会优化“顶部”的构造函数次数（只调用一次，而且用的是”顶部“类的构造函数），派生类一般情况下构造顺序是：“顶部”、\"底部“继承”腰部“顺序、”底部“ （也可理解为声明的顺序）</li></ol>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}