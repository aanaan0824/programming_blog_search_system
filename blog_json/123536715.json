{"blogid": "123536715", "writerAge": "码龄4年", "writerBlogNum": "147", "writerCollect": "62", "writerComment": "5", "writerFan": "13", "writerGrade": "5级", "writerIntegral": "1785", "writerName": "Zoe 1", "writerProfileAdress": "writer_image\\profile_123536715.jpg", "writerRankTotal": "47807", "writerRankWeekly": "240224", "writerThumb": "16", "writerVisitNum": "61631", "blog_read_count": "3873", "blog_time": "已于 2022-04-14 17:48:36 修改", "blog_title": "MySQL数据库的四种隔离级别", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h1>一、首先介绍几个概念：</h1>\n<h3>1，脏读：</h3>\n<p>又称无效数据的读出，是指在数据库访问中，事务T1将某一值修改但是还未提交，然后事务T2读取该值，此后T1因为某种原因撤销对该值的修改并提交，这就导致了T2所读取到的数据是无效的，值得注意的是，脏读一般是针对于update操作的。</p>\n<h3>2、不可重复读：</h3>\n<p>是指在数据库访问中，一个<a href=\"https://baike.baidu.com/item/%E4%BA%8B%E5%8A%A1\" title=\"事务\">事务</a>范围内两个相同的查询却返回了不同数据。在一个事务内，多次读同一个数据。在这个事务还没有结束时，另一个事务也访问该同一数据并修改数据。那么，在第一个事务的两次读数据之间。由于另一个事务的修改，那么第一个事务两次读到的数据可能不一样，这样就发生了在一个事务内两次读到的数据是不一样的，因此称为不可重复读，即原始读取不可重复。</p>\n<h3>3，幻读：</h3>\n<p>事务A 按照一定条件进行数据读取， 期间事务B 插入了相同搜索条件的新数据，事务A再次按照原先条件进行读取时，发现了事务B 新插入的数据称为幻读。</p>\n<p><strong>不可重复读侧重于<span style=\"color:#fe2c24;\">修改</span>，幻读侧重于<span style=\"color:#fe2c24;\">新增或删除</span>。解决不可重复读的问题只需<span style=\"color:#fe2c24;\">锁住满足条件的行</span>，解决幻读需要<span style=\"color:#fe2c24;\">锁表</span></strong></p>\n<h2>二、四种隔离级别：</h2>\n<table align=\"center\" border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px;\"><tbody><tr><td style=\"text-align:center;\"><strong>隔离级别</strong></td><td style=\"text-align:center;\"><strong>脏读</strong></td><td style=\"text-align:center;\"><strong>不可重复读</strong></td><td style=\"text-align:center;\"><strong>幻读</strong></td></tr><tr><td style=\"text-align:center;\">读未提交（read-uncommitted）</td><td style=\"text-align:center;\">是</td><td style=\"text-align:center;\">是</td><td style=\"text-align:center;\">是</td></tr><tr><td style=\"text-align:center;\">读提交（read-committed）</td><td style=\"text-align:center;\">否</td><td style=\"text-align:center;\">是</td><td style=\"text-align:center;\">是</td></tr><tr><td style=\"text-align:center;\">可重读（repeatable-read）</td><td style=\"text-align:center;\">否</td><td style=\"text-align:center;\">否</td><td style=\"text-align:center;\">是</td></tr><tr><td style=\"text-align:center;\">可串行化（serializable）</td><td style=\"text-align:center;\">否</td><td style=\"text-align:center;\">否</td><td style=\"text-align:center;\">否</td></tr></tbody></table>\n<p><strong>read-uncommitted 读未提交：</strong></p>\n<p>在该级别，所有的事务都可以看到其他未提交事务的执行结果，本隔离级别很少用于实际应用，因为它的性能不比其他级别好多少。读取未提交的数据，也称之为脏读。</p>\n<p><strong>read-committed 读提交内容：</strong></p>\n<p>这是大多数数据库系统的默认隔离级别（但不是MYSQL默认的），它满足了隔离的简单定义：一个事务只能看见已提交事务所做的改变。也支持所谓的不可重复读。</p>\n<p><strong>repeatable-read 可重读：</strong></p>\n<p>是MYSQL默认的，确保统一事务的多个实例在并发读取数据时，会看到同样的数据行。</p>\n<p><strong>serializable 可串行化：</strong></p>\n<p>这是最高的隔离级别，他通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简而言之，他是在每个读的数据行上加上<strong>共享锁</strong>。在这个级别可能导致大量的超时现象和锁竞争。</p>\n<p><strong><span style=\"color:#1a439c;\">低级别的隔离级一般支持更高的并发处理，并拥有更低的系统开销。</span></strong></p>\n<h1><span style=\"color:#0d0016;\"><strong>三、事务</strong></span></h1>\n<p>事务的四个性值：ACID（原子性，一致性，隔离性和持久性）</p>\n<p><span style=\"color:#fe2c24;\"><strong>1、原子性</strong></span>：事务中包含有很多操作，这些操作要么全部执行，要么全部不执行，所以支持回滚操作。</p>\n<p><span style=\"color:#fe2c24;\"><strong>2、一致性</strong></span>：系统从一种一致性到另一种一致性状态。事物的一致性决定了一个系统设计和实现的复杂度。事务可以具有不同程度的一致性。</p>\n<p><strong>强一致性</strong>：读操作可以立即读到操作的更新操作。</p>\n<p><strong>弱一致性</strong>：提交的更新操作不一定立即会被读操作读到，这种情况会存在一个不一致窗口，指的是读操作可以读到最新值的一段时间。</p>\n<p><strong>最终一致性</strong>：（弱一致性的一种特殊情况）最终所有的事务都会读到之前事务更新的最新值。</p>\n<p><span style=\"color:#fe2c24;\"><strong>3、隔离性</strong></span>：有上面四种隔离性。</p>\n<p><span style=\"color:#fe2c24;\"><strong>4、持久性</strong></span>：事务的操作对数据库的影响时持久的。</p>\n</div>\n</div>"}