{"blogid": "121897899", "writerAge": "码龄2年", "writerBlogNum": "15", "writerCollect": "473", "writerComment": "85", "writerFan": "441", "writerGrade": "2级", "writerIntegral": "367", "writerName": "虚梦年华", "writerProfileAdress": "writer_image\\profile_121897899.jpg", "writerRankTotal": "70796", "writerRankWeekly": "486947", "writerThumb": "161", "writerVisitNum": "62091", "blog_read_count": "8507", "blog_time": "已于 2022-02-28 08:11:57 修改", "blog_title": "C#使用S7NetPlus以及PLCSIM Advanced V3.0实现西门子PLC仿真通讯", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h2>PLCSIM Advanced 简介</h2>\n<p>PLCSIM Advanced是西门子推出的一款功能强大的仿真软件，目前最新发布的版本为4.0，但鉴于新版本可能存在未知的bug，故本文使用V3.0。</p>\n<p>V3.0支持仿真1500PLC及ET 200SP，可实现Socket网络通讯功能，也可实现PLC之间、PLC与设备直接的ModbusTCP等通讯。</p>\n<p>V3.0安装时需要先安装WinPcap_4_1_3，V4.0则不需要。</p>\n<p>以下为两个版本的官网下载链接，下载时需要西门子账号，可以免费注册。</p>\n<p>以下为V3.0下载链接：</p>\n<p><a class=\"link-info\" href=\"https://support.industry.siemens.com/cs/document/109772889/trial-download-simatic-s7-plcsim-advanced-v3-0?dti=0&amp;lc=en-WW\" title=\"PLCSIM Advanced V3.0\">PLCSIM Advanced V3.0</a></p>\n<p><a class=\"link-info\" href=\"https://support.industry.siemens.com/cs/document/109776014/updates-for-s7-plcsim-advanced-v3-0?dti=0&amp;lc=en-WW\" title=\"V3.0的两个升级包（可选安装）\">V3.0的两个升级包（可选安装）</a></p>\n<p>以下为V4.0下载链接</p>\n<p><a class=\"link-info\" href=\"https://support.industry.siemens.com/cs/document/109795016/simatic-s7-plcsim-advanced-v4-0-trial-download?dti=0&amp;lc=en-WW\" title=\"PLCSIM Advanced V4.0\">PLCSIM Advanced V4.0</a></p>\n<hr/>\n<h2>S7 Net Plus 简介</h2>\n<p>西门子PLC通讯库，支持200、200smart、300、400、1200、1500系列PLC。</p>\n<p><a class=\"link-info\" href=\"https://github.com/S7NetPlus/s7netplus\" title=\"GitHub项目地址\">GitHub项目地址</a></p>\n<p><a class=\"link-info\" href=\"https://github.com/S7NetPlus/s7netplus/wiki\" title=\"说明文档\">说明文档</a></p>\n<hr/>\n<h2>配置PLCSIM Advanced</h2>\n<p>打开PLCSIM Advanced V3.0，如下图：</p>\n<p><img alt=\"\" height=\"645\" src=\"image\\5f078a5fa58947c3bbc1a61ed4b01e6e.png\" width=\"493\"/></p>\n<p>Online Access要选择右边的PLCSIM Virtual Eth.Adapter，左侧的PLCSIM不支持外部网络访问。</p>\n<p>TCP/IP communication with 可选以太网或者是本地虚拟网卡。local即为本地虚拟网卡，是在安装PLCSIM Advanced时自动安装的网络适配器。打开控制面板--&gt;网络和 Internet--&gt;网络连接，Siemens PLCSIM Virtual Ethernet Adapter就是此虚拟网卡。使用虚拟网卡只能在本机进行通讯仿真，而使用以太网则可以在局域网内进行仿真通讯。</p>\n<p>Start Virtual S7-1500 PLC为PLC设置，包括IP地址、子网掩码、默认网关及PLC型号。设置完成后点击Start按钮则会生成一个PLC实例。创建成功后就可以开始通讯仿真了。</p>\n<p>Virtual SIMATIC Memory Ca为打开保存PLC历史记录的文件夹的按钮。</p>\n<p>如下图所示，在Active PLC Instance(s)可以看到已成功创建的PLC。</p>\n<p><img alt=\"\" height=\"787\" src=\"image\\92ac744b22ba4cb3a083cb55b755c258.png\" width=\"492\"/></p>\n<hr/>\n<h2>下载测试DB块</h2>\n<p>在TIA Protal软件中，添加一个S7-1511的设备，然后在程序块中添加一个新的DB块，DB号设置为10。</p>\n<p>打开设备的属性 --&gt; 防护与安全 --&gt;连接机制，勾选“允许来自远程对象的PUT/GET通讯访问”。</p>\n<p>打开设备的属性 --&gt; PROFINET 接口 [X1] --&gt;以太网地址，按需设置PLC的IP地址。</p>\n<p>打开DB10的属性，取消勾选“优化块的访问”，并在DB10中新建如下图所示的变量，编译完成后则可以得到每个变量的偏移量，即此变量在DB10上的地址。</p>\n<p><img alt=\"\" height=\"332\" src=\"image\\41e9e954932442008a1626b617d02e6d.png\" width=\"1200\"/></p>\n<p>设置完成后，下载到刚刚使用PLCSIM Advanced创建的仿真PLC中，需要注意网段要设置成与仿真PLC同一网段。</p>\n<hr/>\n<h2>引用S7NetPlus</h2>\n<p>创建一个测试程序，此处创建的是一个控制台应用程序。</p>\n<p>在NuGet下载S7NetPlus，如下图所示，版本可按需选择</p>\n<p><img alt=\"\" height=\"654\" src=\"image\\3b3b1308ac3649b7a91a20cfd76ea8af.png\" width=\"1200\"/></p>\n<p>新建一个名为PLCInstance的类，创建PLC单例。</p>\n<pre><code class=\"language-cs\">    class PLCInstance\n    {\n        private PLCInstance()\n        {\n            plcObj = new Plc(CpuType.S71500, \"192.168.10.230\", 0, 1);\n        }\n\n        /// &lt;summary&gt;\n        /// PLC单例\n        /// &lt;/summary&gt;\n        public static PLCInstance Instance\n        {\n            get\n            {\n                return Nested.instance;\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// 防止调用此类静态方法时，创建新的实例\n        /// &lt;/summary&gt;\n        private class Nested\n        {\n            internal static readonly PLCInstance instance = null;\n            static Nested()\n            {\n                instance = new PLCInstance();\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// 私有PLC单例对象\n        /// &lt;/summary&gt;\n        private static Plc plcObj;\n\n        /// &lt;summary&gt;\n        /// 连接至PLC并返回连接状态\n        /// &lt;/summary&gt;\n        /// &lt;returns&gt;&lt;/returns&gt;\n        private bool ConnectToPLC()\n        {\n            try\n            {\n                plcObj.Open();\n                return plcObj.IsConnected ? true : false;\n            }\n            catch (Exception)\n            {\n\n                return false;\n            }\n\n        }\n\n        /// &lt;summary&gt;\n        /// 关闭连接\n        /// &lt;/summary&gt;\n        private void Disconnect()\n        {\n            plcObj.Close();\n        }\n    }</code></pre>\n<hr/>\n<h2>读写数据</h2>\n<p>S7NetPlus提供了多种读写的方式，可以读取字节自行解析或者按照指定格式写入字节，也可以指定地址进行读写，还可以使用变量、结构体或者类进行单个或者批量读写。</p>\n<h3>1、指定地址读写</h3>\n<p>这种方法可以在Read方法中以字符串形式传入需要读取的地址，返回的是Object类型的值，需要使用者自行做类型转换。Write方法则同理，以字符串的形式指定需要写入的地址，并在第二个参数传入需要写入的值，但是需要注意西门子PLC内的数据类型与C#的数据类型的对应。以下为读写DB10的0.0地址上的布尔量的值示例，此方式均支持读取与写入。</p>\n<pre><code class=\"language-cs\">//读取\nbool result = (bool)plc.Read(\"DB10.DBX0.0\");\n\n//写入\nplc.Write(\"DB10.DBX0.0\",!result);</code></pre>\n<p>虽然这种方式比较简单且方便，但是它是作者不推荐的方式，文档中原文如下：</p>\n<blockquote>\n<p>This method reads a single variable from the plc, by parsing the string and returning the correct result. While this is the easiest method to get started, is very inefficient because the driver sends a TCP request for every variable.</p>\n</blockquote>\n<p>意思就是，这种方法会通过解析传入的地址字符串来获取需要读写的地址，对于使用者来说是非常简单的使用方式，但是S7NetPlus会为每个通过这种方式读写的变量生成一个新的TCP请求，因此在读写多个变量时，执行效率会比较低。</p>\n<p>S7NetPlus使用的通讯本质上是西门子的S7通讯，通过发送七层通讯报文来建立与西门子PLC的TCP连接，后续也是根据S7通讯的通讯协议生成并发送报文来实现PLC的数据读写。所以当使用这种方式读写多个变量的时候，S7NetPlus内部为每个变量重复建立新的S7连接与发送读写报文的操作，而不是单个连接成功建立后在这个连接上进行批量的读写。</p>\n<p>简单理解就是这种方式效率比较低，会占用更多的资源。</p>\n<p></p>\n<h3>2、解析读写</h3>\n<p>这种方法需要指定DB的类型、DB号、起始地址、PLC数据类型及读取数量。虽然它需要传入的参数变多了，但是当需要读取多个地址连续且类型相同的变量时，仅需修改最后的读取数量，S7NetPlus就会自动读取这一连串的地址，并按照指定的变量类型解析出对应的值，文档中后面说到的多类型变量批量读取也是基于这种方法的。不过这种方式读取PLC内的字符串类型时，仍存在bug，所以当需要读写字符串的时候，推荐使用本文后面提及的字节读写的方式。</p>\n<p>示例如下：</p>\n<pre><code class=\"language-cs\">//读取\nbool result = (bool)plc.Read(DataType.DataBlock, 10, 0, VarType.Bit, 1);\n\n//写入\nplc.Write(DataType.DataBlock, 10, 0, true);</code></pre>\n<p>Read：</p>\n<p>第一个参数是DB的数据类型，可以是DB、定时器、计数器、Merker（内存）、输入、输出。</p>\n<p>第二个参数是DB号。</p>\n<p>第三个参数是起始地址。</p>\n<p>第四个参数是PLC内该变量的类型。</p>\n<p>第五个参数是需要读取的个数。</p>\n<p>Write：</p>\n<p>第一个参数是DB的数据类型，可以是DB、定时器、计数器、Merker（内存）、输入、输出。</p>\n<p>第二个参数是DB号。</p>\n<p>第三个参数是起始地址。</p>\n<p>第四个参数是需要写入的值。</p>\n<p></p>\n<h3>3、字节读写</h3>\n<p>这种方法将会读取指定DB块上一段连续的地址上的字节，不做任何解析直接以字节数组的形式返回。</p>\n<p>第一个参数是DB的数据类型，可以是DB、定时器、计数器、Merker（内存）、输入、输出。</p>\n<p>第二个参数是DB号。</p>\n<p>第三个参数是起始地址。</p>\n<p>第四个参数是读取的字节数。</p>\n<p>要使用这种方式读写数据，则需要非常熟悉PLC内各类型数据存储的格式，可以自行将读取上来的字节进行解析以获得所需数据。</p>\n<p>虽然这种方式理论上能读写任意的数据，但是解析数据的过程会比较麻烦，所以若非万不得已，个人建议尽量少用。</p>\n<p>此处仅提供PLC内String类型及WString类型的读取示例。</p>\n<pre><code class=\"language-cs\">//String读取\nbyte[] data = plc.ReadBytes(DataType.DataBlock, 10, 2, 254);\nstring result = Encoding.Default.GetString(data);</code></pre>\n<pre><code class=\"language-cs\">//Wstring读取\nbyte[] data = plc.ReadBytes(DataType.DataBlock, 10, 4, 508);\nstring result = Encoding.BigEndianUnicode.GetString(data);</code></pre>\n<p>在S7-1500中，一个String类型的变量占用256个字节，但是第一个字节是总字符数，第二个字节是当前字符数，所以真正的字符数据是从第三个字节开始的，共254个字节。</p>\n<p>同理，WString类型其实就是双字节的Sring，也就是说一个字符占用两个字节，所以一个WString类型的变量占用512个字节，第一、二个字节是总字符数，第三、四个字节是当前字符数，真正的字符数据是从第五个字节开始的，共508个字节。</p>\n<p>按照以上示例的方法，读取上来的字符串后面会带很多个\"\\0\"的字符，那是因为后面的空字节也读取上来了，正式使用时可以考虑使用.Replace(\"\\0\", \"\")来去除，或者解析第二个字节来获取字符长度进而转码。</p>\n<p>当写入字符串时，则需要根据不同的数据类型来生成对应字符串的字节数组，然后将该数组写入到指定地址中即可。</p>\n<p>需要注意的是，String类型的编码格式对应的是ASCII，而WString的则是C#中的BigEndianUnicode格式。在WString中，由于总长度与当前字符数是都是双字节数，所以在转换成字节数组的时候存在高低字节顺序问题。在这里就有一个大坑：这两个变量在C#中转换出来的字节数组跟PLC中存储的，高低字节是反过来的。这也就是为什么下面的WString的示例中需要对总字符数和当前字符数的两个字节数组进行反转。</p>\n<p>此处提供一种生成String类型和WString的字节数组的方法，可供参考：</p>\n<pre><code class=\"language-cs\">        /// &lt;summary&gt;\n        /// 获取西门子PLC字符串数组--String\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"str\"&gt;&lt;/param&gt;\n        /// &lt;returns&gt;&lt;/returns&gt;\n        private byte[] GetPLCStringByteArray(string str)\n        {\n            byte[] value = Encoding.Default.GetBytes(str);\n            byte[] head = new byte[2];\n            head[0] = Convert.ToByte(254);\n            head[1] = Convert.ToByte(str.Length);\n            value = head.Concat(value).ToArray();\n            return value;\n        }\n\n        /// &lt;summary&gt;\n        /// 获取西门子PLC字符串数组--WString\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"str\"&gt;&lt;/param&gt;\n        /// &lt;returns&gt;&lt;/returns&gt;\n        private byte[] GetPLCWStringByteArray(string str)\n        {\n            byte[] value = Encoding.BigEndianUnicode.GetBytes(str);\n            byte[] head = BitConverter.GetBytes((short)508);\n            byte[] length = BitConverter.GetBytes((short)str.Length);\n            Array.Reverse(head);\n            Array.Reverse(length);\n            head = head.Concat(length).ToArray();\n            value = head.Concat(value).ToArray();\n            return value;\n        }</code></pre>\n<p>使用示例如下：</p>\n<pre><code class=\"language-cs\">//写入String \nstring str = \"Example\";\nplc.Write(DataType.DataBlock, 10, 0, GetPLCStringByteArray(str));</code></pre>\n<pre><code class=\"language-cs\">//写入WString\nstring str = \"示例\";\nplc.Write(DataType.DataBlock, 10, 0, GetPLCWStringByteArray(str));</code></pre>\n<p></p>\n<h3>4、旧版本的字节读取注意事项</h3>\n<p>旧版本的单次字节读取是有字节数限制的，每一次读取的最大字节数为200，如果需要读写更多的字节，则需要多次读写并进行拼接，以下提供两种方法，可供参考：</p>\n<pre><code class=\"language-cs\">        /// &lt;summary&gt;\n        /// 循环读取\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"numBytes\"&gt;要读取的字节数&lt;/param&gt;\n        /// &lt;param name=\"db\"&gt;DB号&lt;/param&gt;\n        /// &lt;param name=\"startByteAdr\"&gt;起始地址&lt;/param&gt;\n        /// &lt;returns&gt;&lt;/returns&gt;\n        private byte[] CyclicReadMultipleBytes(int numBytes, int db, int startByteAdr = 0)\n        {\n            byte[] resultBytes = new byte[0];\n            int index = startByteAdr;\n            while (numBytes &gt; 0)\n            {\n                var maxToRead = Math.Min(numBytes, 200);\n                byte[] bytes = plc.ReadBytes(DataType.DataBlock, db, index, maxToRead);\n                if (bytes == null)\n                    return null;\n                resultBytes = resultBytes.Concat(bytes).ToArray();\n                numBytes -= maxToRead;\n                index += maxToRead;\n            }\n            return resultBytes;\n        }\n\n        /// &lt;summary&gt;\n        /// 递归读取\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"numBytes\"&gt;要读取的字节数&lt;/param&gt;\n        /// &lt;param name=\"db\"&gt;DB号&lt;/param&gt;\n        /// &lt;param name=\"startByteAdr\"&gt;起始地址&lt;/param&gt;\n        /// &lt;returns&gt;&lt;/returns&gt;\n        public static byte[] RecursiveReadMultipleBytes(int numBytes, int db, int startByteAdr = 0)\n        {\n            byte[] result = new byte[0];\n            if (numBytes &gt; 200)\n            {\n                byte[] temp = plc.ReadBytes(DataType.DataBlock, db, startByteAdr, 200);\n                numBytes -= 200;\n                result = temp.Concat(RecursiveReadMultipleBytes(numBytes, db, startByteAdr + 200)).ToArray();\n            }\n            else\n            {\n                byte[] temp = plc.ReadBytes(DataType.DataBlock, db, startByteAdr, numBytes);\n                result = result.Concat(temp).ToArray();\n                return result;\n            }\n\n            return result;\n        }</code></pre>\n<p>在读取一两千个字节的情况下，这两种方法速度都差不多，递归会稍微快一点点。不过新版本没有单次读取限制，所以正常情况下是不需要这两个方法的。</p>\n<p></p>\n<h3>5、其余读取方式</h3>\n<p>其它的读取方式可<a class=\"link-info\" href=\"https://github.com/S7NetPlus/s7netplus/wiki\" title=\"参考文档\">参考文档</a>，本文不再赘述。</p>\n<hr/>\n<h2>读取数据示例</h2>\n<p>PLCInstance：</p>\n<pre><code class=\"language-cs\">using S7.Net;\nusing System;\nusing System.Text;\n\nnamespace S7NetPlusExample\n{\n    class PLCInstance\n    {\n        private PLCInstance()\n        {\n            plcObj = new Plc(CpuType.S71500, \"192.168.10.230\", 0, 1);\n        }\n\n        /// &lt;summary&gt;\n        /// PLC单例\n        /// &lt;/summary&gt;\n        public static PLCInstance Instance\n        {\n            get\n            {\n                return Nested.instance;\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// 防止调用此类静态方法时，创建新的实例\n        /// &lt;/summary&gt;\n        private class Nested\n        {\n            internal static readonly PLCInstance instance = null;\n            static Nested()\n            {\n                instance = new PLCInstance();\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// 私有PLC单例对象\n        /// &lt;/summary&gt;\n        private static Plc plcObj;\n\n        /// &lt;summary&gt;\n        /// 连接至PLC并返回连接状态\n        /// &lt;/summary&gt;\n        /// &lt;returns&gt;&lt;/returns&gt;\n        private bool ConnectToPLC()\n        {\n            try\n            {\n                plcObj.Open();\n                return plcObj.IsConnected ? true : false;\n            }\n            catch (Exception)\n            {\n\n                return false;\n            }\n\n        }\n\n        /// &lt;summary&gt;\n        /// 关闭连接\n        /// &lt;/summary&gt;\n        private void Disconnect()\n        {\n            plcObj.Close();\n        }\n\n        /// &lt;summary&gt;\n        /// 读取示例数据\n        /// &lt;/summary&gt;\n        /// &lt;returns&gt;&lt;/returns&gt;\n        public string GetPLCInfo()\n        {\n            if (ConnectToPLC())\n            {\n                StringBuilder sbr = new StringBuilder();\n\n                //读取BOOL值\n                bool boolResult = (bool)plcObj.Read(DataType.DataBlock, 10, 0, VarType.Bit, 1);\n\n                //读取Int值\n                int intResult = (short)plcObj.Read(DataType.DataBlock, 10, 2, VarType.Int, 1);\n\n                //读取Real值\n                float realResult = (float)plcObj.Read(DataType.DataBlock, 10, 4, VarType.Real, 1);\n\n                //读取String值\n                byte[] stringData = plcObj.ReadBytes(DataType.DataBlock, 10, 10, 254);\n                string stringResult = Encoding.Default.GetString(stringData);\n\n                //读取WString\n                byte[] wstringData = plcObj.ReadBytes(DataType.DataBlock, 10, 268, 508);\n                string wstringResult = Encoding.BigEndianUnicode.GetString(wstringData);\n\n                Disconnect();\n\n                sbr.AppendLine($\"{boolResult}\");\n                sbr.AppendLine($\"{intResult}\");\n                sbr.AppendLine($\"{realResult}\");\n                sbr.AppendLine($\"{stringResult}\");\n                sbr.AppendLine($\"{wstringResult}\");\n\n                return sbr.ToString();                \n            }\n            else\n            {\n                return \"连接PLC失败\";\n            }           \n        }\n    }\n}</code></pre>\n<p>主程序：</p>\n<pre><code class=\"language-cs\">using System;\n\nnamespace S7NetPlusExample\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.WriteLine(PLCInstance.Instance.GetPLCInfo());\n\n            Console.ReadKey();\n        }\n    }\n}\n</code></pre>\n<p>运行结果：</p>\n<p><img alt=\"\" height=\"117\" src=\"image\\445540f250484ba3b3672b5f7504947b.png\" width=\"749\"/></p>\n<hr/>\n<h2>结尾</h2>\n<p>本文简单介绍了S7 Net Plus和PLCSIM Advanced的使用，以上内容均由本人亲自实践得出的结果，但仍有可改进的的地方。S7NetPlus的文档也有非常详细的介绍，如有更复杂的读写需求，可以参考文档。</p>\n</div>\n</div>"}