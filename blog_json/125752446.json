{"blogid": "125752446", "writerAge": "码龄2年", "writerBlogNum": "84", "writerCollect": "23", "writerComment": "0", "writerFan": "16", "writerGrade": "4级", "writerIntegral": "853", "writerName": "前端小草籽", "writerProfileAdress": "writer_image\\profile_125752446.jpg", "writerRankTotal": "24146", "writerRankWeekly": "8188", "writerThumb": "11", "writerVisitNum": "10009", "blog_read_count": "2586", "blog_time": "已于 2022-07-13 18:15:37 修改", "blog_title": "JS中的 回调函数（callback）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"1.%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%EF%BC%88callback%EF%BC%89%E5%91%A2%EF%BC%9F-toc\" style=\"margin-left:0px;\"><a href=\"#1.%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%EF%BC%88callback%EF%BC%89%E5%91%A2%EF%BC%9F\">1.什么是回调函数（callback）呢？</a></p>\n<p id=\"2.%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E7%82%B9%EF%BC%9F-toc\" style=\"margin-left:0px;\"><a href=\"#2.%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E7%82%B9%EF%BC%9F\">2.回调函数有哪些特点？</a></p>\n<p id=\"3.%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E4%B8%ADthis%E7%9A%84%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98-toc\" style=\"margin-left:0px;\"><a href=\"#3.%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E4%B8%ADthis%E7%9A%84%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98\">3.回调函数中this的指向问题</a></p>\n<p id=\"4.%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E5%88%B0%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%EF%BC%9F-toc\" style=\"margin-left:0px;\"><a href=\"#4.%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E5%88%B0%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%EF%BC%9F\">4.为什么要用到回调函数？</a></p>\n<p id=\"5.%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E5%92%8C%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%E7%9A%84%E5%85%B3%E7%B3%BB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E6%98%AF%E5%BC%82%E6%AD%A5%E4%B9%88%EF%BC%9F-toc\" style=\"margin-left:0px;\"><a href=\"#5.%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E5%92%8C%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%E7%9A%84%E5%85%B3%E7%B3%BB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E6%98%AF%E5%BC%82%E6%AD%A5%E4%B9%88%EF%BC%9F\">5.回调函数和异步操作的关系是什么？回调函数是异步么？</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h1 id=\"1.%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%EF%BC%88callback%EF%BC%89%E5%91%A2%EF%BC%9F\">1.什么是回调函数（callback）呢？</h1>\n<p>把函数当作一个参数传到另外一个函数中，当需要用这个函数是，再回调运行()这个函数.</p>\n<p>回调函数是一段可执行的代码段，它<strong>作为一个参数</strong>传递给其他的代码，其作用是<strong>在需要的时候方便调用</strong>这段（回调函数）代码。（作为参数传递到另外一个函数中，这个作为参数的函数就是回调函数）</p>\n<p>理解：函数可以作为一个参数传递到另外一个函数中。</p>\n<pre><code class=\"language-javascript\">    &lt;script&gt;\n        function add(num1, num2, callback) {\n            var sum = num1 + num2;\n            callback(sum);\n        }\n\n        function print(num) {\n            console.log(num);\n        }\n\n        add(1, 2, print); //3\n    &lt;/script&gt;</code></pre>\n<p>分析：add(1, 2, print);中，函数print作为一个参数传入到add函数中，但并不是马上起作用，而是var sum = num1 + num2;运行完之后需要打印输出sum的时候才会调用这个函数。(这个作为参数传递到另外一个函数中，这个作为参数的函数就是回调函数.</p>\n<p>匿名回调函数：</p>\n<pre><code class=\"language-javascript\">    &lt;script&gt;\n        function add(num1, num2, callback) {\n            var sum = num1 + num2;\n            callback(sum);\n        }\n\n        add(1, 2, function (sum) {\n            console.log(sum); //=&gt;3\n        });\n    &lt;/script&gt;</code></pre>\n<h1 id=\"2.%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E7%82%B9%EF%BC%9F\">2.回调函数有哪些特点？</h1>\n<p>1.不会立即执行</p>\n<p>回调函数作为参数传递给一个函数的时候，<strong>传递的只是函数的定义并不会立即执行</strong>。和普通的函数一样，<strong>回调函数在调用函数数中也要通过<code>()</code>运算符调用才会执行</strong>。</p>\n<p>2.回调函数是一个闭包</p>\n<p>回调函数是一个闭包，也就是说它能访问到其外层定义的变量。</p>\n<p>3.执行前类型判断</p>\n<p>在执行回调函数前最好确认其是一个函数。</p>\n<pre><code class=\"language-javascript\">    &lt;script&gt;\n        function add(num1, num2, callback) {\n            var sum = num1 + num2;\n            //判定callback接收到的数据是一个函数\n            if (typeof callback === 'function') {\n                //callback是一个函数，才能当回调函数使用\n                callback(sum);\n            }\n        }\n    &lt;/script&gt;</code></pre>\n<h1 id=\"3.%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E4%B8%ADthis%E7%9A%84%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98\">3.回调函数中this的指向问题</h1>\n<p>注意在<strong>回调函数调用时this的执行上下文并不是回调函数定义时的那个上下文，而是调用它的函数所在的上下文。</strong></p>\n<p>举例：</p>\n<pre><code class=\"language-javascript\">    &lt;script&gt;\n        function createData(callback){\n            callback();\n        }\n        var obj ={\n            data:100,\n            tool:function(){\n                createData(function(n){\n                    console.log(this,1111);  //window 1111\n                })   \n            }\n        }\n        obj.tool();\n    &lt;/script&gt;</code></pre>\n<p>分析：this指向是<strong> 离它最近的或者嵌套级别的 function/方法的调用者</strong>，这里离它最近的function是</p>\n<p>function(n)，会回到上面的callback()中，这时候调用者就不是obj而是window。</p>\n<p> 解决回调函数this指向的方法1：箭头函数</p>\n<blockquote>\n<p>回调函数（<strong>若回调函数是普通函数时</strong>）当参数传入另外的函数时，若不知道这个函数内部怎么调用回调函数，就会出现回调函数中的this指向不明确的问题（就比如上面例子中this指向的不是obj而是window）。所以 把<strong>箭头函数当回调函数，然后作为参数传入另外的函数中就不会出现this指向不明的问题</strong>。</p>\n</blockquote>\n<pre><code class=\"language-javascript\">    &lt;script&gt;\n        function createData(callback){\n            callback();\n        }\n        var obj ={\n            data:100,\n            tool:function(){\n                createData((n)=&gt;{\n                    this.data = n;\n                })   \n            }\n        }\n        obj.tool();\n        console.log(obj.data); \n    &lt;/script&gt;</code></pre>\n<p> 分析:回调函数用箭头函数写之后，this指向很明确，就是 离它最近的或者嵌套级别的 function/方法的调用者，所以这里是 obj 。</p>\n<p>解决回调函数this指向的方法2：var self = this;</p>\n<pre><code class=\"language-javascript\">    &lt;script&gt;\n        function createData(callback){\n            callback(999);\n        }\n        var obj ={\n            data:100,\n            tool:function(){\n                var self = this;   //这里的this指向obj，然后当一个变量取用\n                createData(function(n){\n                    self.data = n;\n                })   \n            }\n        }\n        obj.tool();\n        console.log(obj.data);\n    &lt;/script&gt;</code></pre>\n<p></p>\n<h1 id=\"4.%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E5%88%B0%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%EF%BC%9F\">4.为什么要用到回调函数？</h1>\n<p>有一个非常重要的原因 —— <strong>JavaScript 是事件驱动的语言</strong>。这意味着，<strong>JavaScript 不会因为要等待一个响应而停止当前运行，而是在监听其他事件时继续执行</strong>。来看一个基本的例子：</p>\n<pre><code class=\"language-javascript\">    &lt;script&gt;\n        function first() {\n            console.log(1);\n        }\n\n        function second() {\n            console.log(2);\n        }\n\n        first();\n        second();\n    &lt;/script&gt;</code></pre>\n<p> 分析:正如你所料，<code>first</code> 函数首先被执行，随后 <code>second</code> 被执行 —— 控制台输出:1  2</p>\n<p>但如果<strong>函数 <code>first</code> 包含某种不能立即执行的代码</strong>会如何呢？例如我们必须发送请求然后等待响应的 API 请求？为了模拟这种状况，我们将使用 <code>setTimeout</code>，它是一个在一段时间之后调用函数的 JavaScript 函数。我们将函数延迟 500 毫秒来模拟一个 API 请求，新代码长这样：</p>\n<pre><code class=\"language-javascript\">    &lt;script&gt;\n        function first() {\n            // 模拟代码延迟\n            setTimeout(function () {  //所以function(){console.log(1)}是回调函数\n                console.log(1);\n            }, 500);\n        }\n\n        function second() {\n            console.log(2);\n        }\n\n        first();\n        second();\n    &lt;/script&gt;</code></pre>\n<p>分析:这里 function(){console.log(1)}函数当作一个参数传入setTimeout函数中，因为setTimeout是官方提供得一个函数，里面有很多复杂的业务程序，所以函数 function(){console.log(1)}传入后，不一定马上运行，要setTimeout里面要运行到function(){console.log(1)}时才会运行该函数参数，那是不是整个程序就一直等setTimeout运行？不是的！！！</p>\n<p>整个程序运行结果为: 2  1 ,并不是原先的1 2 .<strong>即使我们首先调用了 <code>first()</code> 函数，我们记录的输出结果却在 <code>second()</code> 函数之后。</strong></p>\n<p>这不是 JavaScript 没有按照我们想要的顺序执行函数的问题，而是 <strong>JavaScript 在继续向下执行 <code>second()</code> 之前没有等待 <code>first()</code> 响应</strong>的问题。<strong>回调正是确保一段代码执行完毕之后再执行另一段代码的方式</strong>。</p>\n<p></p>\n<h1 id=\"5.%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E5%92%8C%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%E7%9A%84%E5%85%B3%E7%B3%BB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E6%98%AF%E5%BC%82%E6%AD%A5%E4%B9%88%EF%BC%9F\">5.回调函数和异步操作的关系是什么？回调函数是异步么？</h1>\n<blockquote>\n<p><strong>定义：</strong><a href=\"https://so.csdn.net/so/search?q=%E5%9B%9E%E8%B0%83&amp;spm=1001.2101.3001.7020\" title=\"回调\">回调</a>函数被认为是一种<strong>高级函数</strong>，一种被作为参数<strong>传递</strong>给另一个函数的高级函数。回调函数的<strong>本质是一种模式</strong>(一种解决常见问题的模式)，因此回调函数也被称为<strong>回调模式</strong>。 </p>\n<p><strong>简而言之：一个函数在另一个函数中被调用。而且可以当参数传给其他函数。</strong></p>\n</blockquote>\n<p>所以： <strong>回调函数和异步操作的关系是没有关系</strong>！！！ </p>\n<p>那为什么很多的异步操作都有回填函数啊？？</p>\n<p>问：你所知道的异步操作，是回调的作用么？？？  并不是。</p>\n<p>回调：更多的可以理解为一种业务逻辑把           异步编程：JS代码的执行顺序       </p>\n<p>简单理解：<strong>callback 顾名思义  打电话回来的意思</strong></p>\n<p>eg1：你点外卖，刚好你要吃的食物没有了，于是你在店老板那里留下了你的电话，过了几天店里有了，店员就打了你的电话，然后你接到电话后就跑到店里买了。在这个例子里，你的电话号码就叫回调函数，你把电话留给店员就叫登记回调函数，店里后来有货了叫做触发了回调关联的事件，店员给你打电话叫做调用回调函数，你到店里去取货叫做响应回调事件。</p>\n<p>eg2：再比如，你发送一个axios 请求，请求成功之后，触发成功的回调函数，请求失败触发失败的回调函数。这里面的回调函数更像是一个工具，后台通过这个工具告诉你，你成功了抑或是失败了。<strong>这里面的所有异步操作都和回调没关系，真正的异步是then方法。</strong></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n</div>\n</div>"}