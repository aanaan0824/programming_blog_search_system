{"blogid": "122257573", "writerAge": "码龄11年", "writerBlogNum": "540", "writerCollect": "1448", "writerComment": "287", "writerFan": "10682", "writerGrade": "7级", "writerIntegral": "15854", "writerName": "cplvfx", "writerProfileAdress": "writer_image\\profile_122257573.jpg", "writerRankTotal": "1105", "writerRankWeekly": "1022", "writerThumb": "415", "writerVisitNum": "1508857", "blog_read_count": "1637", "blog_time": "于 2021-12-31 16:22:35 发布", "blog_title": "c# .net 微信支付v3,支付结果通知处理；含AEAD_AES_256_GCM解码", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<blockquote>\n<p> c# .net 微信支付v3,支付结果通知处理；含AEAD_AES_256_GCM解码</p>\n<p>作者的程序框架：.NET Framework 4.6.1</p>\n</blockquote>\n<h1 style=\"text-align:center;\"><img alt=\"\" src=\"image\\6a0cd6c249d84433b732209b868c28f4.png\"/></h1>\n<p></p>\n<h1>微信官方说明地址：</h1>\n<h2> 注意重点：</h2>\n<p><a href=\"https://pay.weixin.qq.com/wiki/doc/apiv3/apis/chapter3_1_5.shtml\" title=\"微信支付-开发者文档\">微信支付-开发者文档</a></p>\n<p><a href=\"https://pay.weixin.qq.com/wiki/doc/apiv3/apis/chapter3_1_5.shtml\" title=\"https://pay.weixin.qq.com/wiki/doc/apiv3/apis/chapter3_1_5.shtml\">https://pay.weixin.qq.com/wiki/doc/apiv3/apis/chapter3_1_5.shtml</a></p>\n<pre><code>注意：\n• 同样的通知可能会多次发送给商户系统。商户系统必须能够正确处理重复的通知。 推荐的做法是，当商户系统收到通知进行处理时，先检查对应业务数据的状态，并判断该通知是否已经处理。如果未处理，则再进行处理；如果已处理，则直接返回结果成功。在对业务数据进行状态检查和处理之前，要采用数据锁进行并发控制，以避免函数重入造成的数据混乱。\n\n• 如果在所有通知频率后没有收到微信侧回调，商户应调用查询订单接口确认订单状态。\n\n\n特别提醒：商户系统对于开启结果通知的内容一定要做签名验证，并校验通知的信息是否与商户侧的信息一致，防止数据泄露导致出现“假通知”，造成资金损失。</code></pre>\n<h3>参数解密</h3>\n<pre><code class=\"language-cs\">下面详细描述对通知数据进行解密的流程：\n\n1、用商户平台上设置的APIv3密钥【微信商户平台—&gt;账户设置—&gt;API安全—&gt;设置APIv3密钥】，记为key；\n2、针对resource.algorithm中描述的算法（目前为AEAD_AES_256_GCM），取得对应的参数nonce和associated_data；\n3、使用key、nonce和associated_data，对数据密文resource.ciphertext进行解密，得到JSON形式的资源对象；\n\n注： AEAD_AES_256_GCM算法的接口细节，请参考rfc5116。微信支付使用的密钥key长度为32个字节，随机串nonce长度12个字节，associated_data长度小于16个字节并可能为空字符串。</code></pre>\n<h1>证书和回调报文解密</h1>\n<p><a href=\"https://pay.weixin.qq.com/wiki/doc/apiv3/wechatpay/wechatpay4_2.shtml\" title=\"微信支付-开发者文档\">微信支付-开发者文档</a></p>\n<p><a href=\"https://pay.weixin.qq.com/wiki/doc/apiv3/wechatpay/wechatpay4_2.shtml\" title=\"https://pay.weixin.qq.com/wiki/doc/apiv3/wechatpay/wechatpay4_2.shtml\">https://pay.weixin.qq.com/wiki/doc/apiv3/wechatpay/wechatpay4_2.shtml</a></p>\n<p>位置：文档中心&gt;开发指南&gt;证书和回调报文解密</p>\n<h2>官方提供的Net代码</h2>\n<pre><code class=\"language-cs\">public class AesGcm\n{\n    private static string ALGORITHM = \"AES/GCM/NoPadding\";\n    private static int TAG_LENGTH_BIT = 128;\n    private static int NONCE_LENGTH_BYTE = 12;\n    private static string AES_KEY = \"yourkeyhere\";\n\n    public static string AesGcmDecrypt(string associatedData, string nonce, string ciphertext)\n    {\n        GcmBlockCipher gcmBlockCipher = new GcmBlockCipher(new AesEngine());\n        AeadParameters aeadParameters = new AeadParameters(\n            new KeyParameter(Encoding.UTF8.GetBytes(AES_KEY)), \n            128, \n            Encoding.UTF8.GetBytes(nonce), \n            Encoding.UTF8.GetBytes(associatedData));\n        gcmBlockCipher.Init(false, aeadParameters);\n\n        byte[] data = Convert.FromBase64String(ciphertext);\n        byte[] plaintext = new byte[gcmBlockCipher.GetOutputSize(data.Length)];\n        int length = gcmBlockCipher.ProcessBytes(data, 0, data.Length, plaintext, 0);\n        gcmBlockCipher.DoFinal(plaintext, length);\n        return Encoding.UTF8.GetString(plaintext);\n    }\n}</code></pre>\n<blockquote>\n<p>这里有个坑，如果你直接用是会报错的</p>\n<p>所以需要引用一个包</p>\n</blockquote>\n<h2>给项目添加引用包</h2>\n<p>项目》引用》右键“NuGet”》搜索“Portable.BouncyCastle”》找到如图的包安装即可</p>\n<p><img alt=\"\" height=\"139\" src=\"image\\4f3dd6c2b8f34cdbbcf55923d5deaa42.png\" width=\"817\"/></p>\n<p> <img alt=\"\" height=\"533\" src=\"image\\1fa3e9c0342e41dabcdecc96d4daafff.png\" width=\"498\"/></p>\n<p>我安装版本数据</p>\n<p>描述：BouncyCastle portable version with support for .NET 4, .NET Standard 2.0</p>\n<p>版本：1.9.0</p>\n<p>作者：Claire Novotny</p>\n<p>发布日期：2021年10月19日 (2021/10/19)</p>\n<p>项目URL：<a href=\"https://www.bouncycastle.org/csharp/\" title=\"https://www.bouncycastle.org/csharp/\">https://www.bouncycastle.org/csharp/</a></p>\n<p></p>\n<h1>完整代码</h1>\n<h2>AEAD_AES_256_GCM 解码工具类</h2>\n<pre><code class=\"language-cs\">using Org.BouncyCastle.Crypto.Engines;\nusing Org.BouncyCastle.Crypto.Modes;\nusing Org.BouncyCastle.Crypto.Parameters;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace test1.WeiXinPay.Tools\n{\n    /// &lt;summary&gt;\n    /// 解密微信通知结果帮助类\n    /// 参考资料：https://pay.weixin.qq.com/wiki/doc/apiv3/wechatpay/wechatpay4_2.shtml\n    /// .NET5环境使用该代码，需要安装Portable.BouncyCastle组件\n    /// &lt;/summary&gt;\n    public class AesGcmHelper\n    {\n        private static string ALGORITHM = \"AES/GCM/NoPadding\";\n        private static int TAG_LENGTH_BIT = 128;\n        private static int NONCE_LENGTH_BYTE = 12;\n        private static string AES_KEY = string.Empty;\n\n        /// &lt;summary&gt;\n        ///  解密微信通知结果帮助类\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"associatedData\"&gt;通知数据resource下的associated_data&lt;/param&gt;\n        /// &lt;param name=\"nonce\"&gt;通知数据resource.nonce&lt;/param&gt;\n        /// &lt;param name=\"ciphertext\"&gt;通知数据resource.ciphertext&lt;/param&gt;\n        /// &lt;param name=\"APIV3Key\"&gt;APIV3的密钥key&lt;/param&gt;\n        /// &lt;returns&gt;&lt;/returns&gt;\n        public static string AesGcmDecrypt(string associatedData, string nonce, string ciphertext, string APIV3Key)\n        {\n            GcmBlockCipher gcmBlockCipher = new GcmBlockCipher(new AesEngine());\n            AeadParameters aeadParameters = new AeadParameters(\n                new KeyParameter(Encoding.UTF8.GetBytes(APIV3Key)),\n                128,\n                Encoding.UTF8.GetBytes(nonce),\n                Encoding.UTF8.GetBytes(associatedData));\n            gcmBlockCipher.Init(false, aeadParameters);\n\n            byte[] data = Convert.FromBase64String(ciphertext);\n            byte[] plaintext = new byte[gcmBlockCipher.GetOutputSize(data.Length)];\n            int length = gcmBlockCipher.ProcessBytes(data, 0, data.Length, plaintext, 0);\n            gcmBlockCipher.DoFinal(plaintext, length);\n            return Encoding.UTF8.GetString(plaintext);\n        }\n    }\n}\n</code></pre>\n<h2>所需模型代码</h2>\n<pre><code class=\"language-cs\">/// &lt;summary&gt;\n    /// 微信支付通过后的回调 模型\n    /// &lt;/summary&gt;\n    public class NotifyUrlModel\n    {\n        /// &lt;summary&gt;\n        /// 通知的唯一ID\n        /// &lt;/summary&gt;\n        public string id { get; set; }\n        /// &lt;summary&gt;\n        /// 通知创建的时间，遵循rfc3339标准格式，\n        /// &lt;/summary&gt;\n        public string create_time { get; set; }\n        /// &lt;summary&gt;\n        /// 通知的资源数据类型，支付成功通知为encrypt-resource\n        /// &lt;/summary&gt;\n        public string resource_type { get; set; }\n        /// &lt;summary&gt;\n        /// 通知的类型，支付成功通知的类型为TRANSACTION.SUCCESS\n        /// &lt;/summary&gt;\n        public string event_type { get; set; }\n        /// &lt;summary&gt;\n        /// 回调摘要:如：支付成功\n        /// &lt;/summary&gt;\n        public string summary { get; set; }\n        /// &lt;summary&gt;\n        /// 通知资源数据 json格式，\n        /// &lt;/summary&gt;\n        public ResourceModel resource { get; set; }\n    }\n\n    /// &lt;summary&gt;\n    /// 通知资源数据 json格式，\n    /// &lt;/summary&gt;\n    public class ResourceModel\n    {\n        /// &lt;summary&gt;\n        /// 原始回调类型，为transaction\n        /// &lt;/summary&gt;\n        public string original_type { get; set; }\n        /// &lt;summary&gt;\n        /// 对开启结果数据进行加密的加密算法，目前只支持AEAD_AES_256_GCM\n        /// &lt;/summary&gt;\n        public string algorithm { get; set; }\n        /// &lt;summary&gt;\n        /// Base64编码后的开启/停用结果数据密文\n        /// &lt;/summary&gt;\n        public string ciphertext { get; set; }\n        /// &lt;summary&gt;\n        /// 附加数据\n        /// &lt;/summary&gt;\n        public string associated_data { get; set; }\n        /// &lt;summary&gt;\n        /// 加密使用的随机串\n        /// &lt;/summary&gt;\n        public string nonce { get; set; }\n    }</code></pre>\n<p></p>\n<p></p>\n<h2>回调页面-业务代码</h2>\n<pre><code class=\"language-cs\"> /// &lt;summary&gt;\n        /// 订单回调地址\n        /// &lt;/summary&gt;\n        /// &lt;returns&gt;&lt;/returns&gt;\n        [HttpPost]\n        public JsonResult NotifyUrl()\n        {\n            var result = new { code= \"SUCCESS\" , message = \"成功\" };\n            var httpContext= HttpContext;\n            var request = Request;\n\n\n            try\n            {\n                #region 获取字符串流 \n                System.IO.Stream s = request.InputStream;\n                int count = 0;\n                byte[] buffer = new byte[1024];\n                StringBuilder builder = new StringBuilder();\n                while ((count = s.Read(buffer, 0, 1024)) &gt; 0)\n                {\n                    builder.Append(Encoding.UTF8.GetString(buffer, 0, count));\n                }\n                s.Flush();\n                s.Close();\n                s.Dispose();\n                var str = Encoding.UTF8.GetString(buffer);\n                #endregion\n\n\n                #region 获取请求头信息\n                StringBuilder RHeadersStr = new StringBuilder();\n                RHeadersStr.Append(\"{\");\n                foreach (var item in request.Headers)\n                {\n                    RHeadersStr.Append($\"\\\"{item.ToString()}\\\":\\\"{request.Headers[item.ToString()]}\\\",\");\n                }\n                RHeadersStr.Remove((RHeadersStr.Length - 1), 1);\n                RHeadersStr.Append(\"}\");  \n                #endregion\n\n                #region 把字符流和请求头的信息写入日志\n                log.Info($@\"\n                获取字符串流:{str.Trim('\\0')}\\r\\n\n                获取请求头信息:{RHeadersStr.ToString().Trim()}\\r\\n\n                ==================================================\\r\\n\n                \");\n                #endregion\n\n                #region 获取字符串流\n                string contentStr = str.Trim('\\0');\n                #endregion\n\n                #region 获取请求头信息\n                string headersStr = RHeadersStr.ToString().Trim();\n                #endregion\n\n                NotifyUrlModel notifyUrlModel = JsonConvert.DeserializeObject&lt;NotifyUrlModel&gt;(contentStr);\n                JObject headers = JsonConvert.DeserializeObject&lt;JObject&gt;(contentStr);\n\n                string APIV3Key = \"XXXXXadsadsadasddddAPIV3Key\";\n\n                //获取解码数据\n                var decryptStr = AesGcmHelper.AesGcmDecrypt(notifyUrlModel.resource.associated_data, notifyUrlModel.resource.nonce, notifyUrlModel.resource.ciphertext, APIV3Key);\n\n\n            }\n            catch (Exception e)\n            {\n                log.Error(e.LogErrorTxt());\n                throw;\n            }\n\n\n\n\n            return Json(result);\n        }</code></pre>\n<p></p>\n</div>\n</div>"}