{"blogid": "123967875", "writerAge": "码龄6年", "writerBlogNum": "33", "writerCollect": "3877", "writerComment": "6653", "writerFan": "10628", "writerGrade": "10级", "writerIntegral": "142757", "writerName": "不正经的kimol君", "writerProfileAdress": "writer_image\\profile_123967875.jpg", "writerRankTotal": "2192", "writerRankWeekly": "7086", "writerThumb": "7810", "writerVisitNum": "603841", "blog_read_count": "16368", "blog_time": "于 2022-04-05 15:30:16 发布", "blog_title": "【摸鱼神器】基于python的BOSS识别系统", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-light\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p></p>\n<div class=\"toc\">\n<h3>【摸鱼神器】基于python的BOSS识别系统</h3>\n<ul><li><a href=\"#_2\">前言</a></li><li><a href=\"#_12\">一、整体设计</a></li><li><a href=\"#_18\">二、调用摄像头</a></li><li><a href=\"#_43\">三、人脸识别</a></li><li><ul><li><a href=\"#1__56\">1. 构建白名单库</a></li><li><a href=\"#2__176\">2. 人脸匹配</a></li></ul>\n</li><li><a href=\"#_214\">四、切换屏幕</a></li><li><a href=\"#_228\">五、完整代码</a></li><li><a href=\"#_351\">写在最后</a></li></ul>\n</div>\n<p></p>\n<h1><a id=\"_2\"></a>前言</h1>\n<blockquote>\n<p>Tip:本文仅供技术学习和参考，切勿滥用。珍爱工作，从我做起，滴滴~</p>\n</blockquote>\n<p>试想这样一个场景：一天，风和日丽，波澜不惊。你正在愉快地摸着鱼，是如此的惬意，如此的巴适。<br/> <img alt=\"在这里插入图片描述\" src=\"https://img-blog.csdnimg.cn/3a17b83bbade4a8d9650779249dcc3d8.webp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiN5q2j57uP55qEa2ltb2zlkJs=,size_14,color_FFFFFF,t_70,g_se,x_16#pic_center\"/><br/> 就在这时，你的BOSS突然出现，打断了这美好的瞬间，迎接你的将是无尽的…<br/> 经过这件事之后，你可能会想：<strong>”有没有一个工具，可以帮我迅速发现BOSS的到来，并迅速切换屏幕呢？“</strong></p>\n<p>于是，它来了。<strong>B</strong>oss <strong>R</strong>ecognition <strong>S</strong>ystem 迈着轻快的步伐来了。各位小伙伴，请系好安全带，咋们发车了🚗…（滴，学生卡）</p>\n<h1><a id=\"_12\"></a>一、整体设计</h1>\n<p>思路还是比较清晰，简单的。调用摄像头实时采集画面，通过人脸识别算法对人像进行检测，如果是BOSS则将屏幕切换到指定界面。示意图如下：<br/> <img alt=\"在这里插入图片描述\" src=\"image\\d1f0befea63d4e38b65e0f60cf8a8094.png\"/></p>\n<p>下面将对涉及到的每一部分进行介绍。</p>\n<h1><a id=\"_18\"></a>二、调用摄像头</h1>\n<p>这里可以直接用python的<strong>cv2</strong>库即可，利用pip安装：</p>\n<pre><code>pip install opencv-python\n</code></pre>\n<p>具体调用方法如下：</p>\n<pre><code>import cv2\n\nif __name__ == '__main__':\n    # 开启摄像头\n    video_capture = cv2.VideoCapture(0, cv2.CAP_DSHOW)\n    # 实时捕获图像\n    while True:\n        _, frame = video_capture.read()      # 读取每一帧图像\n        cv2.imshow('capture', frame)         # 展示画面\n        if cv2.waitKey(1) &amp; 0xFF == ord('q'):# 按Q退出\n            break\n    # 关闭摄像头\n    video_capture.release()\n</code></pre>\n<p>这样便能获取到视频的每一祯画面<strong>frame</strong>，接下来我们只需要对frame进行处理和识别就可以了。</p>\n<h1><a id=\"_43\"></a>三、人脸识别</h1>\n<p>目前人脸识别的开源算法和在线API接口有很多，都能帮助我们快速地实现人脸识别效果。但是考虑到BOSS识别是分秒必争的事儿🙈，网络延迟可能会让我们错过最佳“战机”。于是，我决定用本地的人脸识别算法。</p>\n<p>本次采用的是python中的开源人脸识别项目：<a href=\"https://zhuanlan.zhihu.com/p/45827914\">face_recognition</a>，只需要简单的几行代码便可实现人脸识别的效果。其安装方法如下：</p>\n<pre><code>pip install face_recognition\n</code></pre>\n<p><code>注意：使用face_recognition前需要安好dlib库。</code></p>\n<p>BOSS识别有两个思路：一个基于白名单，另一个则基于黑名单。白名单指的是除了白名单里的人像之外，都会触发切屏，其好处是不需要BOSS的照片用于学习，缺点是容易造成误判；而黑名单的好处是可以“精确打击”，但是需要搜集黑名单中对象的照片。<br/> 毕竟偷拍BOSS👴的照片成本太高了，老实巴交的我还是决定采用<strong>白名单</strong>的方式。</p>\n<h2><a id=\"1__56\"></a>1. 构建白名单库</h2>\n<p>读取本地图像库，计算每个人的人脸特征编码，构建出人脸白名单库：</p>\n<pre><code># 读取本地肖像库，建立识别白名单\ndef load_portrait(path=path):\n    '''\n    path：肖像库路径\n    '''\n    # 消息提示\n    print('&gt;&gt;&gt;本地图像库读取中，请稍后',end='')\n    for i in range(5):\n        print('.', end='')\n        time.sleep(0.3)\n    # 建立白名单\n    white_map = {}\n    for name in os.listdir(path):\n        filepath = '%s/%s'%(path, name)\n        avg_coding = np.zeros(128)\n        n = 0\n        for file in os.listdir(filepath):\n            if '.jpg' in file:\n                image = face_recognition.load_image_file('%s/%s'%(filepath, file))\n                encoding = face_recognition.face_encodings(image)[0]\n                avg_coding += encoding\n                n += 1\n        avg_coding /= n\n        white_map[name] = avg_coding\n        print('&gt;&gt;\"%s\"人脸数据加载完成！'%name)\n    return white_map\n</code></pre>\n<p>这里的目录结构如下：<br/> <img alt=\"在这里插入图片描述\" src=\"image\\78bfc72f1cb345d3acc551c8e2bb5221.png\"/><br/> data为人像数据存储的根目录，每个人的照片单独存于一个文件夹，并以001、002的顺序进行编号。我们可以手工搜集照片并添加进去，当然也能通过代码自动采集，方法如下：</p>\n<pre><code>import os\nimport cv2\nimport time\nimport threading\n\n# 全局变量\npath = './data' # 采集的图片存储位置\nchoice = '-1'   # 选择，用于判断操作，-1表示暂无选择\n\n# 定义捕捉函数\ndef capture(name):\n    '''\n    捕捉人像函数\n    '''\n    # 定于图片路径及文件名\n    global path, choice\n    jpgpath = '%s/%s'%(path, name)\n    if not os.path.exists(jpgpath):\n        os.mkdir(jpgpath)\n        i = 1 # 图片标号\n    else:\n        try:\n            i = int(os.listdir(jpgpath)[0][-7:-4])+1\n        except:\n            i = 1\n    # 开启摄像头\n    video_capture = cv2.VideoCapture(0, cv2.CAP_DSHOW)\n    # 循环捕捉头像\n    while True:\n        ret, frame = video_capture.read()\n        cv2.imshow('monitor', frame)\n        if cv2.waitKey(1) &amp; 0xFF == ord('q'):\n            break\n        if choice == '0':\n            choice = '-1'\n            filename = '%s-%s.jpg'%(name, str(i).zfill(3))\n            cv2.imwrite('%s/%s'%(jpgpath, filename), frame)\n            i += 1\n            print('\"%s\"保存成功！'%filename)\n        elif choice == '1':\n            choice = '-2'  # 用于标记退回上一层\n            break\n        elif choice == '-1':\n            continue\n        else:\n            choice = '-1'\n            print('输入错误...')\n    # 关闭摄像头\n    video_capture.release()      \n\nif __name__ == '__main__':    \n    # 创建目录\n    if not os.path.exists(path):\n        os.mkdir(path)\n    # 显示欢迎界面和说明\n    os.system('cls')\n    welcome = '''\n     _____           _             _ _      _____      _ _           _   \n    |  __ \\         | |           (_) |    / ____|    | | |         | |  \n    | |__) |__  _ __| |_ _ __ __ _ _| |_  | |     ___ | | | ___  ___| |_ \n    |  ___/ _ \\| '__| __| '__/ _` | | __| | |    / _ \\| | |/ _ \\/ __| __|\n    | |  | (_) | |  | |_| | | (_| | | |_  | |___| (_) | | |  __/ (__| |_ \n    |_|   \\___/|_|   \\__|_|  \\__,_|_|\\__|  \\_____\\___/|_|_|\\___|\\___|\\__| v0.1\n                                                                                                                                        \n    '''\n    print(welcome)\n    # 循环捕捉头像\n    while True:\n        choice_1 = input('&gt;&gt;选择（0-&gt;输入姓名，1-&gt;退出）：')\n        if choice_1 == '0':\n            name = input('&gt;&gt;姓名：')\n            print('摄像头启动中...')\n            time.sleep(1)\n            threading.Thread(target=capture, args=(name,)).start()\n            while True:\n                choice = input('&gt;&gt;选择（0-&gt;保存，1-&gt;退出）：')\n                time.sleep(0.1) # 等待子线程执行，防止逻辑混乱\n                if choice == '-2':\n                    choice = '-1'\n                    break\n        elif choice_1 == '1':\n            break\n        else:\n            print('输入错误')\n</code></pre>\n<h2><a id=\"2__176\"></a>2. 人脸匹配</h2>\n<p>在得到人像白名单之后，需要做的便是将视频中出现的人脸与白名单进行匹配，进而判断其身份。运用到的关键函数是<strong>compare_faces</strong>，其用法如下：</p>\n<pre><code>matches = face_recognition.compare_faces(known_face_encodings, face_encoding)\n</code></pre>\n<p>其中<strong>known_face_encodings</strong>为白名单中的人脸特征编码，<strong>face_encoding</strong>为视频中出现的人脸特征编码，与之一一进行比较，如果相吻合返回值则为<strong>True</strong>。<br/> 据此，可以定义一个人脸匹配的函数：</p>\n<pre><code>def recognize(frame, white_map):\n    '''\n    frame: 捕获的摄像头帧\n    white_map: 人像库白名单\n    '''\n    # 根据白名单，提取肖像编码\n    known_face_encodings = list(white_map.values())\n    known_face_names = list(white_map.keys())\n    # 图像预处理（包括大小调整、格式转换）\n    frame = cv2.resize(frame, (0, 0), fx=0.25, fy=0.25) # 调整图像大小，以减小计算需求\n    frame = frame[:, :, ::-1] # BGR-&gt;RGB\n    # 计算人脸的编码值\n    face_locations = face_recognition.face_locations(frame)\n    face_encodings = face_recognition.face_encodings(frame, face_locations)\n    # 计算的编码与白名单比较，获得其匹配的名字\n    face_names = []\n    for face_encoding in face_encodings:\n        # 默认为\"未知\"\n        name = '未知'\n        # 匹配\n        matches = face_recognition.compare_faces(known_face_encodings, face_encoding)\n        if True in matches:\n            index = matches.index(True)\n            name = known_face_names[index]\n        face_names.append(name)\n    return face_names, face_locations\n</code></pre>\n<p><font color=\"red\" size=\"2\">注：</font><font size=\"2\">①这里对图像进行了压缩，目的是提高计算效率，对其准确率的影响很小。②这里用了for循环，是因为一张图像中出现的人脸可能不止一个。</font></p>\n<h1><a id=\"_214\"></a>四、切换屏幕</h1>\n<p>利用<strong>PyQt5</strong>库打开一个全屏的窗口，把背景图替换为<font color=\"blue\">正在努力工作的画面</font>，便能轻松地实现瞒天过海，开心摸鱼了~</p>\n<pre><code>def lock_screen(image_path='lock.jpg'):\n    app = QApplication(sys.argv)\n    pixmap = QPixmap(image_path)\n    screen = QLabel()\n    screen.setPixmap(pixmap)\n    screen.showFullScreen()\n    sys.exit(app.exec_())\n</code></pre>\n<p>切换屏幕仅仅是一个参考，其实这一步你可以尝试更多的玩法，比如文字提示或者语音提示，又或者直接调用快捷键切换到指定窗口。</p>\n<h1><a id=\"_228\"></a>五、完整代码</h1>\n<p>结合上面几部分，完整代码如下：</p>\n<pre><code>import os\nimport cv2\nimport sys\nimport time\nimport numpy as np\nimport face_recognition\nfrom PyQt5.QtGui import QPixmap\nfrom PyQt5.QtWidgets import QApplication,QLabel\n\n# 全局变量\npath = './data'  # 人像存储路径\nshowflag = True  # 是否实时显示图像\n\n# 利用PyQt5打开全屏窗口，实现窗口替换效果\ndef lock_screen(image_path='lock.jpg'):\n    app = QApplication(sys.argv)\n    pixmap = QPixmap(image_path)\n    screen = QLabel()\n    screen.setPixmap(pixmap)\n    screen.showFullScreen()\n    sys.exit(app.exec_())\n\n# 读取本地肖像库，建立识别白名单\ndef load_portrait(path=path):\n    '''\n    path：肖像库路径\n    '''\n    # 消息提示\n    print('&gt;&gt;&gt;本地图像库读取中，请稍后',end='')\n    for i in range(5):\n        print('.', end='')\n        time.sleep(0.3)\n    # 建立白名单\n    white_map = {}\n    for name in os.listdir(path):\n        filepath = '%s/%s'%(path, name)\n        avg_coding = np.zeros(128)\n        n = 0\n        for file in os.listdir(filepath):\n            if '.jpg' in file:\n                image = face_recognition.load_image_file('%s/%s'%(filepath, file))\n                encoding = face_recognition.face_encodings(image)[0]\n                avg_coding += encoding\n                n += 1\n        avg_coding /= n\n        white_map[name] = avg_coding\n        print('&gt;&gt;\"%s\"人脸数据加载完成！'%name)\n    return white_map\n\n# 人脸识别，判断当前画面的人像是否与白名单中的匹配\ndef recognize(frame, white_map):\n    '''\n    frame: 捕获的摄像头帧\n    white_map: 人像库白名单\n    '''\n    # 根据白名单，提取肖像编码\n    known_face_encodings = list(white_map.values())\n    known_face_names = list(white_map.keys())\n    # 图像预处理（包括大小调整、格式转换）\n    frame = cv2.resize(frame, (0, 0), fx=0.25, fy=0.25) # 调整图像大小，以减小计算需求\n    frame = frame[:, :, ::-1] # BGR-&gt;RGB\n    # 计算人脸的编码值\n    face_locations = face_recognition.face_locations(frame)\n    face_encodings = face_recognition.face_encodings(frame, face_locations)\n    # 计算的编码与白名单比较，获得其匹配的名字\n    face_names = []\n    for face_encoding in face_encodings:\n        # 默认为\"未知\"\n        name = '未知'\n        # 匹配\n        matches = face_recognition.compare_faces(known_face_encodings, face_encoding)\n        if True in matches:\n            index = matches.index(True)\n            name = known_face_names[index]\n        face_names.append(name)\n    return face_names, face_locations\n    \nif __name__ == '__main__':\n    # 加载白名单\n    white_map = load_portrait(path)\n    #开启摄像头\n    video_capture = cv2.VideoCapture(0, cv2.CAP_DSHOW)\n    # 采集图像\n    flag = 0\n    while True:\n        flag %= 3\n        _, frame = video_capture.read()\n        if flag == 0: # 每3帧处理因此（提高处理速度，防止视频卡顿）\n            face_names, face_locations = recognize(frame, white_map)\n            if '未知' in face_names: # 如果有白名单之外的人\n                lock_screen()\n                break\n        flag += 1\n        if showflag:\n            # 将人脸框出\n            for (top, right, bottom, left), name in zip(face_locations, face_names):\n                # 改变坐标位置（因为处理时原图被缩小了4*4）\n                top *= 4\n                right *= 4\n                bottom *= 4\n                left *= 4\n                # 矩形框\n                cv2.rectangle(frame, (left, top), (right, bottom), (0, 0, 255), 2)\n                #加上姓名\n                cv2.rectangle(frame, (left, bottom - 35), (right, bottom), (0, 0, 255), cv2.FILLED)\n                font = cv2.FONT_HERSHEY_DUPLEX\n                cv2.putText(frame, name, (left + 6, bottom - 6), font, 1.0, (255, 255, 255), 1)\n            # 显示图像\n            cv2.imshow('monitor', frame)\n        # 按Q退出\n        if cv2.waitKey(1) &amp; 0xFF == ord('q'):\n            break\n    video_capture.release()\n    cv2.destroyAllWindows()\n</code></pre>\n<p>运行代码之后，先前的场景变得有所不同：还是那日，微风荡漾，你开心的摸着鱼。BOSS加快脚步想要抓个现行，当他刚一过来，电脑屏幕就已经切到了工作画面。BOSS微笑地频频点头：“小伙子，不错，工作很刻苦。”</p>\n<p>试想一下，就这操作，咱距离升职加薪，走上人生巅峰还远吗？（手动滑稽脸🙈）</p>\n<h1><a id=\"_351\"></a>写在最后</h1>\n<p>总体来说，本次的BOSS识别系统只是从想法的萌生到一次简单的尝试，还有许多可以优化的地方，比如识别的准确率和效率问题，感兴趣的小伙伴可以尝试着进一步优化。</p>\n<p>最后，想说的是：<strong>摸鱼不是重点，学习技术才是关键</strong>，希望大家可以在摸索和尝试中不断提升自己。</p>\n<p>我是kimol君，咋们下次再会~</p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\20201208000006826.jpg\"/><br/> <code>创作不易，大侠请留步… 动起可爱的双手，来个赞再走呗 (๑◕ܫ￩๑)</code></p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}