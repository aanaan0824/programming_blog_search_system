{"blogid": "124974279", "writerAge": "码龄2年", "writerBlogNum": "110", "writerCollect": "424", "writerComment": "57", "writerFan": "285", "writerGrade": "4级", "writerIntegral": "1236", "writerName": "会说法语的猪", "writerProfileAdress": "writer_image\\profile_124974279.jpg", "writerRankTotal": "15995", "writerRankWeekly": "11981", "writerThumb": "77", "writerVisitNum": "126023", "blog_read_count": "3020", "blog_time": "已于 2022-05-31 11:13:14 修改", "blog_title": "Vue集成three.js，并加载glb、gltf、FBX、json模型", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>最近刚开始做的一个项目，后面有个模块要通过three.js实现3D的场景，因为之前也没接触过3D这块，就提前学了一下，做个记录。</p>\n<p><strong>先上几个网址</strong></p>\n<p>ThreeJS官方：<a class=\"link-info\" href=\"http://www.thingjs.com/guide/city2/\" title=\"http://www.thingjs.com/guide/city2/\">http://www.thingjs.com/guide/city2/</a> </p>\n<p>ThreeJS文档：<a class=\"link-info\" href=\"https://threejs.org/docs/index.html#manual/en/introduction/Creating-a-scene\" title=\"https://threejs.org/docs/index.html#manual/en/introduction/Creating-a-scene\">https://threejs.org/docs/index.html#manual/en/introduction/Creating-a-scene</a>  </p>\n<p>免费模型网：<a class=\"link-info\" href=\"http://glbxz.com/err/search.php?keyword=%E5%85%8D%E8%B4%B9\" title=\"http://glbxz.com/err/search.php?keyword=%E5%85%8D%E8%B4%B9\">http://glbxz.com/err/search.php?keyword=%E5%85%8D%E8%B4%B9</a>  </p>\n<p>接下来就我做的一个demo开始 </p>\n<h1>安装</h1>\n<pre><code class=\"language-javascript\">npm i three\nnpm i three-orbitcontrols\nnpm i stats.js // 性能监测</code></pre>\n<h1>组件中引入 </h1>\n<pre><code class=\"language-javascript\">import * as THREE from 'three'\nimport * as Stats from 'stats.js'\nimport OrbitControls from 'three-orbitcontrols'\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader'\nimport { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader.js'\nimport { FBXLoader } from 'three/examples/jsm/loaders/FBXLoader.js'</code></pre>\n<h1>基本使用 </h1>\n<h3>1.创建场景 </h3>\n<pre><code class=\"language-javascript\">this.scene = new THREE.Scene();</code></pre>\n<h3>2.相机 </h3>\n<pre><code class=\"language-javascript\">this.camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);\n// 设置摄像机位置,相机方向逆X轴方向，倾斜向下看\nthis.camera.position.set(360, 360, 360);\n// 指向场景中心\nthis.camera.lookAt(this.scene.position);</code></pre>\n<h3>3. 渲染器</h3>\n<pre><code class=\"language-javascript\">this.renderer = new THREE.WebGLRenderer({ antialias: true });\n// 设置环境\nthis.renderer.setClearColor(new THREE.Color(\"#f1f9fb\"));\n// 设置场景大小\nthis.renderer.setSize(window.innerWidth / window.innerHeight);\n// 渲染器开启阴影效果\nthis.renderer.shadowMap.enabled = true;</code></pre>\n<h3>4.创建纹理加载器 </h3>\n<pre><code class=\"language-javascript\">this.textureLoader = new THREE.TextureLoader();</code></pre>\n<h3>5.创建组合对象 </h3>\n<blockquote>\n<p>加载外部模型的时候，基本上都是一个组合对象，因为外部模型都是比较大的，把零散的模型组合到一块便于操作，可以使用THREE.Group来操作一组对象，包括旋转，缩放，移动等，里面的子对象都会受到影响。THREE.Group继承自THREE.Object3D对象，并且和THREE.Object3D对象没有任何区别，仅仅是名字上的差异</p>\n</blockquote>\n<pre><code class=\"language-javascript\">this.groupBox = new THREE.Group();</code></pre>\n<h3>6.添加坐标轴，辅助判断位置 </h3>\n<pre><code class=\"language-javascript\">let axes = new THREE.AxesHelper(1000);\nthis.scene.add(axes);</code></pre>\n<h3>7.点光源 </h3>\n<pre><code class=\"language-javascript\">// 点光源\nlet point = new THREE.PointLight(0xffffff);\npoint.position.set(500, 300, 400); // 点光源位置\nthis.scene.add(point); // 点光源添加到场景中</code></pre>\n<h3>8.环境光 </h3>\n<pre><code class=\"language-javascript\">// 环境光\nlet ambient = new THREE.AmbientLight(0x999999);\nthis.scene.add(ambient);</code></pre>\n<h3>9.性能监测 </h3>\n<pre><code class=\"language-javascript\">//创建性能监测\nthis.stats = new Stats()\nthis.stats.showPanel(0) // 0: fps, 1: ms, 2: mb, 3+: custom\nthis.stats.domElement.style.position = 'absolute'; //绝对坐标  this.stats.domElement.style.left = '0px';// (0,0)px,左上角  \nthis.stats.domElement.style.top = '0px';\n$('#stats').appendChild(this.stats.domElement)</code></pre>\n<h3>10.相机控件 </h3>\n<pre><code class=\"language-javascript\">//创建相机控件\nthis.control = new OrbitControls(this.camera, this.renderer.domElement)\nthis.control.enableDamping = true\n// 动态阻尼系数 就是鼠标拖拽旋转灵敏度，阻尼越小越灵敏\nthis.control.dampingFactor = 0.5;\n// 是否可以缩放\nthis.control.enableZoom = true;\n// 是否自动旋转\nthis.control.autoRotate = false;\n// 设置相机距离原点的最近距离\nthis.control.minDistance = 20;\n// 设置相机距离原点的最远距离\nthis.control.maxDistance = 1000;\n// 是否开启右键拖拽\nthis.control.enablePan = true;\n// 上下翻转的最大角度\nthis.control.maxPolarAngle = 1.5;\n// 上下翻转的最小角度\nthis.control.minPolarAngle = 0.0;\n// 是否可以旋转\nthis.enableRotate = true;</code></pre>\n<h3>11.渲染canvas到容器 </h3>\n<pre><code class=\"language-javascript\">$('#container').appendChild(this.renderer.domElement);</code></pre>\n<h3>12.加载glb、gltf模型 </h3>\n<pre><code class=\"language-javascript\">loadGlbModel() {\n  const loader = new GLTFLoader()\n  // const dracoLoader = new DRACOLoader()\n  // dracoLoader.setDecoderPath('/draco/')\n  // dracoLoader.preload()\n  // loader.setDRACOLoader(dracoLoader)\n  loader.load(`${this.publicPath}model/12OJJ6MOWT722N61Z5N92KA9C.glb`, (gltf) =&gt; {\n    console.log(gltf, 'gltf-----&gt;&gt;&gt;')\n    gltf.scene.scale.set(100,100,100)  //  设置模型大小缩放\n    gltf.scene.position.set(0,0,0)\n    let axis = new THREE.Vector3(0,1,0);//向量axis\n    gltf.scene.rotateOnAxis(axis,Math.PI/2);\n    //绕axis轴逆旋转π/16\n    gltf.scene.rotateOnAxis(axis,Math.PI/-20);\n    gltf.scene.rotateOnAxis(axis,Math.PI/50);\n    // gltf.rotateY(Math.PI / 2);\n    // this.groupBox.add(gltf);\n    this.scene.add(gltf.scene)\n  }, (xhr) =&gt; {\n      console.log((xhr.loaded / xhr.total) * 100 + '% loaded')\n  }, (error) =&gt; {\n      console.error(error)\n  })\n},</code></pre>\n<h3>13.加载FBX模型 </h3>\n<pre><code class=\"language-javascript\">//  加载 FBX 模型\nloadFbxModel() {\n  const loader = new FBXLoader();\n  loader.load(`${this.publicPath}model/glbxz.com6031.FBX`, object =&gt; {//加载路径fbx文件\n    console.log(object, 'object-----&gt;&gt;&gt;')\n    object.traverse( child =&gt; {\n      if ( child.isMesh ){\n        child.castShadow = true;\n        child.receiveShadow = true;\n      }\n    });\n    this.scene.add(object);//模型\n  })\n},</code></pre>\n<h3>14.加载json模型 </h3>\n<pre><code class=\"language-javascript\">//加载 JSON格式 模型\nloadJsonModel() {\n  //设置相机位置\n  this.camera.position.z = 130\n  this.camera.position.y = 80\n  const loader = new THREE.ObjectLoader()\n  loader.load(`${this.publicPath}model/xxxx.json`, json =&gt; {\n    //处理加载模型为黑色问题\n    json.traverse(child =&gt; {\n      if (child.isMesh) {\n        child.material.emissive = child.material.color\n        child.material.emissiveMap = child.material.map\n      }\n    })\n    this.scene.add(group)\n  }, xhr =&gt; {\n    // called while loading is progressing\n    console.log(`${( xhr.loaded / xhr.total * 100 )}% loaded`);\n  }, error =&gt; {\n    // called when loading has errors\n    console.error('An error happened', error);\n  })\n},</code></pre>\n<h3>15.创建材质 </h3>\n<pre><code class=\"language-javascript\">// 创建材质\ncreateMaterial() {\n  // 创建三维用到的材质\n  /**\n   * \n   * MeshBasicMaterial: 网格基础材质\n   * MeshDepthMaterial: 网格深度材质\n   * MeshNormalMaterial: 网格法向材质\n   * MeshLambertMaterial: 网格Lambert 材质\n   * MeshPhongMaterial: 网格 Phong式材质\n   * MeshStandardMaterial: 网格标准材质\n   * MeshPhysicalMaterial: 网格物理材质\n   * MeshToonMaterial: 网格卡通材质\n   * ShadowMaterial: 阴影材质\n   * ShaderMaterial: 着色器材质\n   * LineBasicMaterial: 直线基础材质\n   * LineDashMaterial: 虚线材质\n   */\n  // 外墙\n  let wallMaterial = new THREE.MeshLambertMaterial({ color: 0x00ffff });\n  let wallGeo = new THREE.BoxGeometry(439 + 2 + 2, 120, 376.5 + 2 + 2); // 创建几何体\n  let wallMesh = new THREE.Mesh(wallGeo, wallMaterial);\n  wallMesh.position.set(0, 60, 0); //(0, 60, -14.95);\n  this.scene.add(wallMesh) // 添加结果到场景中\n  // 内墙\n  let wallInnerMaterial = new THREE.MeshLambertMaterial({\n    color: 0x2d1bff,\n  });\n  let wallInnerGeo = new THREE.BoxGeometry(439, 120, 376.5); //(270, 120, 390);\n  let wallInnerMesh = new THREE.Mesh(wallInnerGeo, wallInnerMaterial);\n  wallInnerMesh.position.set(0, 60, 0); //(0, 60, -14.95);\n  this.scene.add(wallInnerMesh)  // 添加结果到场景中\n  // 门\n  let doorTexture = this.textureLoader.load(\n    require(\"../../../../assets/img/1.png\") // 暂时注掉\n  );\n  let boxTextureMaterial = new THREE.MeshStandardMaterial({\n    map: doorTexture,\n    metalness: 0.2,\n    roughness: 0.07,\n    side: THREE.DoubleSide,\n  });\n  //let doorInnerMaterial = new THREE.MeshLambertMaterial({color: 0x2D1BFF});\n  let doorGeo = new THREE.BoxGeometry(2, 80, 74.5);\n  let doorMesh = new THREE.Mesh(doorGeo, boxTextureMaterial);\n  doorMesh.position.set(-220.5, 40, 0);\n  this.scene.add(doorMesh);  // 添加结果到场景中\n\n  /**\n   *  threeBSP - 引用还有问题\n   */\n  // //转BSP\n  // let wallBSP = new ThreeBSP(wallMesh);\n  // let wallInnerBSP = new ThreeBSP(wallInnerMesh);\n  // let doorBSP = new ThreeBSP(doorMesh);\n  // // let window1BSP = new ThreeBSP(this.createWindowRight());\n  // //let window2BSP = new ThreeBSP(this.createWindowRight());// createWindowLeft\n  // let wallResultBSP = wallBSP.subtract(wallInnerBSP);\n  // wallResultBSP = wallResultBSP.subtract(doorBSP);\n  // // wallResultBSP = wallResultBSP.subtract(window1BSP);\n  // //wallResultBSP = wallResultBSP.subtract(window2BSP);\n  // let wallResultMesh = wallResultBSP.toMesh();\n\n  // //转换后的Mesh配置属性\n  // let wallTexture = this.textureLoader.load(require(\"../../../../assets/img/3.jpg\")); // 暂时注掉\n  // let wallTextureMaterial = new THREE.MeshStandardMaterial({\n  //   map: wallTexture,\n  //   metalness: 0.2,\n  //   roughness: 0.07,\n  //   side: THREE.DoubleSide,\n  // });\n  // let wallInnerTexture = this.textureLoader.load(\n  //   require(\"../../../../assets/img/6.jpg\") // 暂时注掉\n  // );\n  // let wallInnerTextureMaterial = new THREE.MeshStandardMaterial({\n  //   map: wallInnerTexture,\n  //   metalness: 0.2,\n  //   roughness: 0.07,\n  //   side: THREE.DoubleSide,\n  // });\n  // let wallResultMeshMaterial = [];\n  // wallResultMeshMaterial.push(wallTextureMaterial);\n  // wallResultMeshMaterial.push(wallInnerTextureMaterial);\n  // //wallResultMeshMaterial.push(boxTextureMaterial);\n  // wallResultMesh.material = wallResultMeshMaterial;\n\n  // // console.log(wallResultMesh.geometry.faces, 112233);\n  // wallResultMesh.geometry.faces.forEach((item, i) =&gt; {\n  //   if (i &lt; 160) {\n  //     item.materialIndex = 0;\n  //   } else {\n  //     item.materialIndex = 1;\n  //   }\n  // });\n\n  // wallResultMesh.geometry.computeFaceNormals();\n  // wallResultMesh.geometry.computeVertexNormals();\n  // //添加结果到场景中\n  // this.scene.add(wallResultMesh);\n},</code></pre>\n<h3>16.进行渲染 </h3>\n<pre><code class=\"language-javascript\">render() {\n  let animate = () =&gt; {\n    //循环调用函数\n    this.clearAnim = requestAnimationFrame(animate)\n    //更新相机控件\n    this.control.update()\n    // 更新性能插件\n    this.stats.update()\n    //渲染界面\n    this.renderer.render(this.scene, this.camera)\n  }\n  animate()\n}</code></pre>\n<h3>17.为模型绑定事件 </h3>\n<p>这里以点击事件为例 </p>\n<pre><code class=\"language-javascript\">this.renderer.domElement.addEventListener('click', this.modelMouseClick, false)</code></pre>\n<pre><code class=\"language-javascript\">// 模型的点击事件\nmodelMouseClick( event ) {\n  var raycaster = new THREE.Raycaster();\n  var mouse = new THREE.Vector2();\n  // 将鼠标位置归一化为设备坐标。x 和 y 方向的取值范围是 (-1 to +1)\n  mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;\n  mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;\n  raycaster.setFromCamera(mouse, this.camera);\n  const intersects = raycaster.intersectObjects(this.scene.children);\n  // 根据它来判断点击的什么，length为0即没有点击到模型\n  console.log(intersects, 'intersects-----&gt;&gt;&gt;')\n}</code></pre>\n<h1>完整代码 </h1>\n<pre><code class=\"language-javascript\">&lt;template&gt;\n  &lt;div id=\"import-template\"&gt;\n    &lt;!-- 放性能监测的容器 --&gt;\n    &lt;div id=\"stats\"&gt;&lt;/div&gt;\n    &lt;!-- 3D模型容器 --&gt;\n    &lt;div id=\"container\"&gt;&lt;/div&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n// import '@/utils/ThreeBSP.js' // 不可以这么引\nimport * as THREE from 'three'\nimport * as Stats from 'stats.js'\n// import * as dat from 'dat.gui'\nimport OrbitControls from 'three-orbitcontrols'\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader'\nimport { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader.js'\nimport { FBXLoader } from 'three/examples/jsm/loaders/FBXLoader.js'\nconst $ = name =&gt; document.querySelector(name)\n\nexport default {\n  data() {\n    return {\n      scene: null, // 场景\n      camera: null, // 照相机\n      renderer: null, // 渲染器\n      mesh: null, // 网格\n      textureLoader: null, // 纹理加载器\n      mixer: null,\n      groupBox: null,\n      stats: null, // 性能监测\n      control: null, // 相机控件\n      publicPath: process.env.BASE_URL,\n      clearAnim: null,\n      clock: null\n    }\n  },\n  created() {\n    // this.init()\n  },\n  mounted() {\n    this.init()\n  },\n  destroyed() {\n    cancelAnimationFrame(this.clearAnim)  // 清除requestAnimationFrame\n    this.renderer.domElement.removeEventListener('click', this.modelMouseClick, false)\n    this.scene = null, // 场景\n    this.camera = null, // 照相机\n    this.renderer = null, // 渲染器\n    this.mesh = null, // 网格\n    this.textureLoader = null, // 纹理加载器\n    this.mixer = null,\n    this.groupBox = null,\n    this.stats = null, // 性能监测\n    this.control = null, // 相机控件\n    this.publicPath = process.env.BASE_URL,\n    this.clock = null\n  },\n  methods: {\n    //初始化\n    init() {\n      // 场景\n      this.scene = new THREE.Scene();\n      // 1.2 相机\n      this.camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);\n      // 设置摄像机位置,相机方向逆X轴方向，倾斜向下看\n      this.camera.position.set(360, 360, 360);\n      //this.camera.position.set(-20, 40 ,30)\n      // 指向场景中心\n      this.camera.lookAt(this.scene.position);\n      // 1.3 渲染器\n      this.renderer = new THREE.WebGLRenderer({ antialias: true });\n      // 创建纹理加载器\n      this.textureLoader = new THREE.TextureLoader();\n      // 创建一个组合对象\n      this.groupBox = new THREE.Group();\n      // 添加坐标轴，辅助判断位置\n      let axes = new THREE.AxesHelper(1000);\n      this.scene.add(axes);\n      // 设置环境\n      this.renderer.setClearColor(new THREE.Color(\"#f1f9fb\"));\n      // 设置场景大小\n      this.renderer.setSize(\n        $('#container').getBoundingClientRect().width,\n        $('#container').getBoundingClientRect().height\n      );\n      // 渲染器开启阴影效果\n      this.renderer.shadowMap.enabled = true;\n      // 点光源\n      let point = new THREE.PointLight(0xffffff);\n      point.position.set(500, 300, 400); // 点光源位置\n      this.scene.add(point); // 点光源添加到场景中\n      // 环境光\n      let ambient = new THREE.AmbientLight(0x999999);\n      this.scene.add(ambient);\n\n      //创建性能监测\n      this.stats = new Stats()\n      this.stats.showPanel(0) // 0: fps, 1: ms, 2: mb, 3+: custom\n      this.stats.domElement.style.position = 'absolute'; //绝对坐标  \n      this.stats.domElement.style.left = '0px';// (0,0)px,左上角  \n      this.stats.domElement.style.top = '0px';\n      $('#stats').appendChild(this.stats.domElement)\n\n      // 渲染div到canvas\n      $('#container').appendChild(this.renderer.domElement);\n\n      //创建相机控件\n      this.control = new OrbitControls(this.camera, this.renderer.domElement)\n      this.control.enableDamping = true\n      // 动态阻尼系数 就是鼠标拖拽旋转灵敏度，阻尼越小越灵敏\n      this.control.dampingFactor = 0.5;\n      // 是否可以缩放\n      this.control.enableZoom = true;\n      // 是否自动旋转\n      this.control.autoRotate = false;\n      // 设置相机距离原点的最近距离\n      this.control.minDistance = 20;\n      // 设置相机距离原点的最远距离\n      this.control.maxDistance = 1000;\n      // 是否开启右键拖拽\n      this.control.enablePan = true;\n      // 上下翻转的最大角度\n      this.control.maxPolarAngle = 1.5;\n      // 上下翻转的最小角度\n      this.control.minPolarAngle = 0.0;\n      // 是否可以旋转\n      this.enableRotate = true;\n      this.loadGlbModel(); // 加载 glb、gltf模型\n      // this.loadFbxModel() // 加载 FBX 模型\n      // this.loadJsonModel() // 加载 json 模型\n      // this.createMaterial() // 创建材质\n      // 最后进行渲染\n      this.render()\n    },\n    // 最后的渲染\n    render() {\n      let animate = () =&gt; {\n        //循环调用函数\n        this.clearAnim = requestAnimationFrame(animate)\n        //更新相机控件\n        this.control.update()\n        // 更新性能插件\n        this.stats.update()\n        //渲染界面\n        this.renderer.render(this.scene, this.camera)\n      }\n      animate()\n      //  为模型绑定点击事件\n      this.renderer.domElement.addEventListener('click', this.modelMouseClick, false)\n    },\n    // 创建材质\n    createMaterial() {\n      // 创建三维用到的材质\n      /**\n       * \n       * MeshBasicMaterial: 网格基础材质\n       * MeshDepthMaterial: 网格深度材质\n       * MeshNormalMaterial: 网格法向材质\n       * MeshLambertMaterial: 网格Lambert 材质\n       * MeshPhongMaterial: 网格 Phong式材质\n       * MeshStandardMaterial: 网格标准材质\n       * MeshPhysicalMaterial: 网格物理材质\n       * MeshToonMaterial: 网格卡通材质\n       * ShadowMaterial: 阴影材质\n       * ShaderMaterial: 着色器材质\n       * LineBasicMaterial: 直线基础材质\n       * LineDashMaterial: 虚线材质\n       */\n      // 外墙\n      let wallMaterial = new THREE.MeshLambertMaterial({ color: 0x00ffff });\n      let wallGeo = new THREE.BoxGeometry(439 + 2 + 2, 120, 376.5 + 2 + 2); // 创建几何体\n      let wallMesh = new THREE.Mesh(wallGeo, wallMaterial);\n      wallMesh.position.set(0, 60, 0); //(0, 60, -14.95);\n      this.scene.add(wallMesh)\n      // 内墙\n      let wallInnerMaterial = new THREE.MeshLambertMaterial({\n        color: 0x2d1bff,\n      });\n      let wallInnerGeo = new THREE.BoxGeometry(439, 120, 376.5); //(270, 120, 390);\n      let wallInnerMesh = new THREE.Mesh(wallInnerGeo, wallInnerMaterial);\n      wallInnerMesh.position.set(0, 60, 0); //(0, 60, -14.95);\n      this.scene.add(wallInnerMesh)\n      // 门\n      let doorTexture = this.textureLoader.load(\n        require(\"../../../../assets/img/1.png\") // 暂时注掉\n      );\n      let boxTextureMaterial = new THREE.MeshStandardMaterial({\n        map: doorTexture,\n        metalness: 0.2,\n        roughness: 0.07,\n        side: THREE.DoubleSide,\n      });\n      //let doorInnerMaterial = new THREE.MeshLambertMaterial({color: 0x2D1BFF});\n      let doorGeo = new THREE.BoxGeometry(2, 80, 74.5);\n      let doorMesh = new THREE.Mesh(doorGeo, boxTextureMaterial);\n      doorMesh.position.set(-220.5, 40, 0);\n      this.scene.add(doorMesh);\n\n      /**\n       *  threeBSP - 引用还有问题\n       */\n      // //转BSP\n      // let wallBSP = new ThreeBSP(wallMesh);\n      // let wallInnerBSP = new ThreeBSP(wallInnerMesh);\n      // let doorBSP = new ThreeBSP(doorMesh);\n      // // let window1BSP = new ThreeBSP(this.createWindowRight());\n      // //let window2BSP = new ThreeBSP(this.createWindowRight());// createWindowLeft\n      // let wallResultBSP = wallBSP.subtract(wallInnerBSP);\n      // wallResultBSP = wallResultBSP.subtract(doorBSP);\n      // // wallResultBSP = wallResultBSP.subtract(window1BSP);\n      // //wallResultBSP = wallResultBSP.subtract(window2BSP);\n      // let wallResultMesh = wallResultBSP.toMesh();\n\n      // //转换后的Mesh配置属性\n      // let wallTexture = this.textureLoader.load(require(\"../../../../assets/img/3.jpg\")); // 暂时注掉\n      // let wallTextureMaterial = new THREE.MeshStandardMaterial({\n      //   map: wallTexture,\n      //   metalness: 0.2,\n      //   roughness: 0.07,\n      //   side: THREE.DoubleSide,\n      // });\n      // let wallInnerTexture = this.textureLoader.load(\n      //   require(\"../../../../assets/img/6.jpg\") // 暂时注掉\n      // );\n      // let wallInnerTextureMaterial = new THREE.MeshStandardMaterial({\n      //   map: wallInnerTexture,\n      //   metalness: 0.2,\n      //   roughness: 0.07,\n      //   side: THREE.DoubleSide,\n      // });\n      // let wallResultMeshMaterial = [];\n      // wallResultMeshMaterial.push(wallTextureMaterial);\n      // wallResultMeshMaterial.push(wallInnerTextureMaterial);\n      // //wallResultMeshMaterial.push(boxTextureMaterial);\n      // wallResultMesh.material = wallResultMeshMaterial;\n\n      // // console.log(wallResultMesh.geometry.faces, 112233);\n      // wallResultMesh.geometry.faces.forEach((item, i) =&gt; {\n      //   if (i &lt; 160) {\n      //     item.materialIndex = 0;\n      //   } else {\n      //     item.materialIndex = 1;\n      //   }\n      // });\n\n      // wallResultMesh.geometry.computeFaceNormals();\n      // wallResultMesh.geometry.computeVertexNormals();\n      // //添加结果到场景中\n      // this.scene.add(wallResultMesh);\n    },\n    // 加载 GLTF 模型\n    loadGlbModel() {\n      const loader = new GLTFLoader()\n      // const dracoLoader = new DRACOLoader()\n      // dracoLoader.setDecoderPath('/draco/')\n      // dracoLoader.preload()\n      // loader.setDRACOLoader(dracoLoader)\n      loader.load(`${this.publicPath}model/12OJJ6MOWT722N61Z5N92KA9C.glb`, (gltf) =&gt; {\n        console.log(gltf, 'gltf-----&gt;&gt;&gt;')\n        gltf.scene.scale.set(100,100,100)  //  设置模型大小缩放\n        gltf.scene.position.set(0,0,0)\n        let axis = new THREE.Vector3(0,1,0);//向量axis\n        gltf.scene.rotateOnAxis(axis,Math.PI/2);\n        //绕axis轴逆旋转π/16\n        gltf.scene.rotateOnAxis(axis,Math.PI/-20);\n        gltf.scene.rotateOnAxis(axis,Math.PI/50);\n        // gltf.rotateY(Math.PI / 2);\n        // this.groupBox.add(gltf);\n        this.scene.add(gltf.scene)\n      }, (xhr) =&gt; {\n          console.log((xhr.loaded / xhr.total) * 100 + '% loaded')\n      }, (error) =&gt; {\n          console.error(error)\n      })\n    },\n    //  加载 FBX 模型\n    loadFbxModel() {\n      const loader = new FBXLoader();\n      loader.load(`${this.publicPath}model/glbxz.com6031.FBX`, object =&gt; {//加载路径fbx文件\n        console.log(object, 'object-----&gt;&gt;&gt;')\n        object.traverse( child =&gt; {\n          if ( child.isMesh ){\n            child.castShadow = true;\n            child.receiveShadow = true;\n          }\n        });\n        this.scene.add(object);//模型\n      })\n    },\n    //加载 JSON格式 模型\n    loadJsonModel() {\n      //设置相机位置\n      this.camera.position.z = 130\n      this.camera.position.y = 80\n      const loader = new THREE.ObjectLoader()\n      loader.load(`${this.publicPath}model/xxxx.json`, json =&gt; {\n        //处理加载模型为黑色问题\n        json.traverse(child =&gt; {\n          if (child.isMesh) {\n            child.material.emissive = child.material.color\n            child.material.emissiveMap = child.material.map\n          }\n        })\n        this.scene.add(group)\n      }, xhr =&gt; {\n        // called while loading is progressing\n        console.log(`${( xhr.loaded / xhr.total * 100 )}% loaded`);\n      }, error =&gt; {\n        // called when loading has errors\n        console.error('An error happened', error);\n      })\n    },\n    // 模型的点击事件\n    modelMouseClick( event ) {\n      var raycaster = new THREE.Raycaster();\n      var mouse = new THREE.Vector2();\n      // 将鼠标位置归一化为设备坐标。x 和 y 方向的取值范围是 (-1 to +1)\n      mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;\n      mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;\n      raycaster.setFromCamera(mouse, this.camera);\n      const intersects = raycaster.intersectObjects(this.scene.children);\n      // 根据它来判断点击的什么，length为0即没有点击到模型\n      console.log(intersects, 'intersects-----&gt;&gt;&gt;')\n    }\n  }\n}\n&lt;/script&gt;\n&lt;style scoped&gt;\n#import-template {\n  width: 100%;\n  height: 100%;\n}\n#stats {\n  width: 100%;\n  height: 50px;\n  position: relative;\n}\n#container {\n  width: 100%;\n  height: calc(100% - 50px);\n}\n&lt;/style&gt;</code></pre>\n<h1>效果 </h1>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/18c7ac6f2cc74d499f441cb0a4c9deb5.gif\"/>  </p>\n<p>最后再补充一下，有个threeBSP，，到现在还没知道怎么去引用，搞这个东西才两天，很多还需要慢慢摸索 ，好像这个threBSP不支持npm装，而且必须要引在THREE后面。。。慢慢再搞</p>\n<pre><code class=\"language-javascript\">&lt;script src=\"https://johnson2heng.github.io/three.js-demo/lib/threebsp.js\"&gt;&lt;/script&gt;</code></pre>\n<p> 这个是threeBSP在线的包，如果向上面例子按需引入THREE，那应该怎么去引这个包呢，， </p>\n<p>不断学习中。。。</p>\n<h1>补充 </h1>\n<p>接上面的问题，【已解决】ThreeBSP引入问题 </p>\n<p>见下篇博文 <a class=\"link-info\" href=\"https://blog.csdn.net/m0_51431448/article/details/124993744?spm=1001.2014.3001.5502\" title=\"Three.js引入ThreeBSP\">Three.js引入ThreeBSP</a> </p>\n</div>\n</div>"}