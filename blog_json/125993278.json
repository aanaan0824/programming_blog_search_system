{"blogid": "125993278", "writerAge": "码龄2年", "writerBlogNum": "156", "writerCollect": "9133", "writerComment": "2473", "writerFan": "22571", "writerGrade": "7级", "writerIntegral": "13219", "writerName": "柠檬叶子C", "writerProfileAdress": "writer_image\\profile_125993278.jpg", "writerRankTotal": "785", "writerRankWeekly": "635", "writerThumb": "6776", "writerVisitNum": "500623", "blog_read_count": "569", "blog_time": "已于 2022-08-02 13:44:49 修改", "blog_title": "【C++要笑着学】STL Array | 非类型模板参数 | 模板的特化 | 全特化与半特化 | 模板的优缺点", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>  <img alt=\"\" height=\"123\" src=\"image\\451dfef5a53e4c94a3ecbfb02d167973.png\" width=\"326\"/> C++ 表情包趣味教程 👉 <a href=\"https://blog.csdn.net/weixin_50502862/category_11602059.html\" title=\"《C++要笑着学》\">《C++要笑着学》</a><img alt=\"\" height=\"27\" src=\"image\\e1ba38fa85014c37b277079e48486d02.png\" width=\"27\"/><img alt=\"\" height=\"171\" src=\"image\\0e4fadbb649349aabfa24cf2b79d6bba.png\" width=\"1001\"/></p>\n<p><strong>💭 写在前面</strong></p>\n<p>我们之前讲过C++的模板，考虑到当时还没有将 STL，所以并没有一次性讲完，我们把剩余的部分放到了讲完部分 STL 容器的后面去讲，这样比较方去讲解。比如我们本章我们会通过 STL 的 array 去讲解非类型模板参数。本章还会重点讲解模板的特化，最后简单的探讨一下C++引入模板的优缺点。</p>\n<p><img alt=\"\" height=\"179\" src=\"image\\bb31940697fb406eaf76887d86bc6134.jpeg\" width=\"188\"/><strong> 本篇博客全站热榜排名：<span style=\"color:#a5a5a5;\">未上榜</span></strong></p>\n<p></p>\n<hr/>\n<h2>Ⅰ. 非类型模板参数（Nontype Template Parameters）</h2>\n<h3>0x00 引入：什么是非类型模板参数？</h3>\n<p><span style=\"color:#a5a5a5;\"><em>\" 对于函数模板和类模板，模板参数并不局限于类型，普通值也可以作为模板参数 \"</em></span></p>\n<p><img alt=\"\" height=\"88\" src=\"image\\685a647b54434524bacdd51df1fd098d.png\" width=\"289\"/>  STL 的<span style=\"color:#0d0016;\"> array </span>就有一个非类型模板参数。</p>\n<p><img alt=\"\" height=\"94\" src=\"image\\94df001a47e54f05b8085db9c1802eee.jpeg\" width=\"99\"/>注意看，我们普通定义的 <span style=\"color:#ad720d;\">T</span> 是类型，而<span style=\"color:#ad720d;\"> N </span>这里并不是类型，而是一个常量！</p>\n<p>类型模板参数定义的是虚拟类型，注重的是你要传什么，而 <span style=\"background-color:#f9eda6;\">非类型模板参数定义的是常量。</span></p>\n<pre><code class=\"language-cpp\">               \"非类型模板参数\"\n                     👇\ntemplate&lt;class T, size_t N&gt; class array;\n             👆    \n        \"类型模板参数\"</code></pre>\n<p></p>\n<h3>0x01 非类型模板参数的使用场景</h3>\n<p><strong>💭 举例：</strong>假设我们要定义一个静态栈： </p>\n<pre><code class=\"language-cpp\">#define N 100\n\ntemplate&lt;class T&gt; \nclass Stack {\n    private:\n        int _arr[N];\n        int _top;\n};</code></pre>\n<p><strong>❓ 思考：</strong>我现在想定义两个容量不一样的栈，一个容量是100 另一个是 500，能做到吗？</p>\n<p><img alt=\"\" height=\"272\" src=\"image\\45da3aaf58244a33b3777f8b5e06bb21.png\" width=\"598\"/></p>\n<p>这就像<span style=\"color:#956fe7;\"> typedef</span><span style=\"color:#ad720d;\"> </span>做不到一个存 <span style=\"color:#ad720d;\">int</span> 一个存 <span style=\"color:#ad720d;\">double</span>，而使用模板可以做到<span style=\"color:#0d0016;\"> st1</span> 存 <span style=\"color:#ad720d;\">int</span>，<span style=\"color:#0d0016;\">st2 </span>存<span style=\"color:#0d0016;\"> double</span>。</p>\n<p>这里你的<span style=\"color:#6eaad7;\"> #</span><span style=\"color:#511b78;\">define</span> 无论是改 100 还是改 500 都没办法解决这里的问题，</p>\n<p>对应的，这里使用非类型模板参数就可以做到<span style=\"color:#0d0016;\"> s1</span> 存 100，<span style=\"color:#0d0016;\">s2</span> 存 500。</p>\n<p></p>\n<p><strong>💡 解决方案：</strong>定义一个常量<span style=\"color:#0d0016;\"> </span><span style=\"color:#ad720d;\">N</span></p>\n<pre><code class=\"language-cpp\">// #define N 100\n\ntemplate&lt;class T, size_t N&gt;\nclass Stack {\n    private:\n        int _arr[N];\n        int _top;\n};\n\nint main(void) \n{\n    Stack&lt;int, 100&gt; st1;     // 我期望它的大小是100\n    Stack&lt;double, 500&gt; st2;  // 我期望它的大小是500\n\n    return 0;\n}</code></pre>\n<p>这里我们在模板这定义一个常量<span style=\"color:#0d0016;\"> </span><span style=\"color:#ad720d;\">N</span>，派遣它去做数组的大小。</p>\n<p>于是我们就可以在实例化<span style=\"color:#4da8ee;\"> Stack</span> 的时候指定其实例化对象的大小了，分别传 100 和 500。</p>\n<p><img alt=\"\" height=\"128\" src=\"image\\f2a1b84fbd6741d695994153ad376c4c.jpeg\" width=\"125\"/> 这比宏更爽！它能传一个常量过去，定义不同的对象可以传不同的常量过去。</p>\n<p></p>\n<p></p>\n<h3>0x02 一些值得注意的点</h3>\n<p><strong>📌 注意事项 ①：</strong><span style=\"background-color:#f9eda6;\">非类型模板参数是是常量，是不能修改的。</span></p>\n<pre><code class=\"language-cpp\">template&lt;class T, size_t N&gt; \nclass Stack {\n    public:\n        void f() {    // 修改常量试试看\n            N = 10; \n        }\n    private:\n        int _arr[N];\n        int _top;\n};\n\nint main(void) \n{\n    Stack&lt;int, 100&gt; st1;\n    st1.f();\n\n    return 0;\n}</code></pre>\n<blockquote>\n<p><strong>🚩 运行结果：</strong>（报错）</p>\n<p><span style=\"color:#fe2c24;\">test1711.cpp:10:15: error: lvalue required as left operand of assignment<br/>              N = 10;<br/>              ~~^~~~</span></p>\n</blockquote>\n<p></p>\n<p><strong>📌 注意事项②：</strong><span style=\"background-color:#f9eda6;\">有些类型是不能作为非类型模板参数的，比如浮点数、类对象以及字符串。</span></p>\n<p>非类型模板参数基本上都是整型，实际上也只有整型是有意义和价值的（可以这么理解）。</p>\n<p><img alt=\"\" height=\"299\" src=\"image\\204b066d0221412ab8628af4ea93396e.png\" width=\"522\"/></p>\n<p><span style=\"color:#a5a5a5;\">（char 也算整型，只不过是一个字节的整型，你不能因为它一个字节就歧视它）</span></p>\n<p></p>\n<p><strong>📌 注意事项③：</strong>非类型的模板参数必须在编译期就能确认结果。</p>\n<p></p>\n<p></p>\n<h3>0x03 顺便介绍一下 STL 的 array</h3>\n<p><img alt=\"\" height=\"131\" src=\"image\\31b7c1556acd414293417b38c29395e9.png\" width=\"134\"/> <span style=\"color:#a5a5a5;\"><em>\" 我们对 STL 的 array 安排的场次如此潦草，在这里穿插下随便讲讲好啦 \"</em></span></p>\n<p><strong>🔍 官方文档：</strong><a href=\"https://cplusplus.com/reference/array/array/?kw=array\" title=\"array - C++ Reference\">array - C++ Reference</a></p>\n<p>现在学了非类型模板参数了，我们现在再来回头看<span style=\"color:#4da8ee;\"> array</span>：</p>\n<p><img alt=\"\" height=\"157\" src=\"image\\7d19f7e6923847499123226406d851ac.png\" width=\"520\"/></p>\n<p><span style=\"color:#4da8ee;\">array </span>是 C++11 新增的，它有什么独特的地方吗？</p>\n<p><img alt=\"\" height=\"112\" src=\"image\\7b17b54208c943d5a0fea41a84b1c053.jpeg\" width=\"132\"/> 很可惜，基本没有，并且 <span style=\"color:#4da8ee;\">vector</span> 可以完全碾压 <span style=\"color:#4da8ee;\">array</span>……</p>\n<p>而且就算说它有，那也不是优势反而是劣势，这就是为什么我们没有这么积极的讲解 <span style=\"color:#4da8ee;\">array</span>。</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;array&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main(void)\n{\n    vector&lt;int&gt; v1(100, 0);\n    array&lt;int, 100&gt; a1;\n    \n    cout &lt;&lt; \"size of v1: \" &lt;&lt; sizeof(v1) &lt;&lt; endl;\n    cout &lt;&lt; \"size of a1: \" &lt;&lt; sizeof(a1) &lt;&lt; endl;\n\n    return 0;\n}</code></pre>\n<blockquote>\n<p><strong>🚩 运行结果：</strong></p>\n</blockquote>\n<p><img alt=\"\" height=\"138\" src=\"image\\60f0247b78f54d508f08c3a34edff49b.png\" width=\"457\"/></p>\n<p><span style=\"color:#4da8ee;\"><span style=\"background-color:#f9eda6;\">vector </span></span><span style=\"background-color:#f9eda6;\">是开在空间大的堆上的而 </span><span style=\"color:#4da8ee;\"><span style=\"background-color:#f9eda6;\">array</span></span><span style=\"background-color:#f9eda6;\"> 是开在寸土寸金的栈上的</span>，堆可比栈的空间大太多太多了。</p>\n<p>最尴尬的是 <span style=\"color:#4da8ee;\">array </span>能做的操作几乎 <span style=\"color:#4da8ee;\">vector</span> 都能做，因为 <span style=\"color:#4da8ee;\">vector </span>的存在 <span style=\"color:#4da8ee;\">array</span> 显得有些一无是处。</p>\n<p><img alt=\"\" height=\"58\" src=\"image\\b0b9e16f362d43eaad4db9a35dd1ef17.jpeg\" width=\"66\"/> 所以我们拿 array 去对标 vector 是不对的，拿去和原生数组比还是可以对比的。</p>\n<p>但是 <span style=\"color:#4da8ee;\">array </span>也只是封装过的原生数组罢了，是真的菜：</p>\n<pre><code class=\"language-cpp\">array&lt;int, 100&gt; a1;  // 封装过的原生数组\nint a2[100];         // 原生数组\n</code></pre>\n<p>比起原生数组，<span style=\"background-color:#f9eda6;\">array 的最大优势也只是有一个越界的检查，读和写都可以检查到是否越界。</span></p>\n<p>要对比的话也只能欺负一下原生数组，然而面对强大的<span style=\"color:#4da8ee;\"> vector</span>，<span style=\"color:#4da8ee;\">array </span>完全没有招架之力。</p>\n<p></p>\n<p>如何评价<span style=\"color:#4da8ee;\"> array</span>？在 C++11 增加完<span style=\"color:#4da8ee;\"> array</span> 后备受吐槽，从简化的角度来说完全可以不增加<span style=\"color:#4da8ee;\"> array</span>。</p>\n<p><img alt=\"\" height=\"81\" src=\"image\\969d2771c53a402db9412e0ba394386c.png\" width=\"100\"/> 我的评价是 —— </p>\n<p style=\"text-align:center;\"><em><span style=\"color:#a5a5a5;\">\" 十年磨一剑，但磨的是十年前的技术 \"</span></em></p>\n<p><strong>🔺 总结：</strong><span style=\"color:#4da8ee;\">array </span>相较于原生数组，有越界检查之优势，<span style=\"background-color:#f9eda6;\">实际中建议直接用 vector。</span></p>\n<p></p>\n<p></p>\n<h2>Ⅱ. 模板的特化（Template Specialization）</h2>\n<h3>0x01 引入：给特殊类型准备特殊模板</h3>\n<p><img alt=\"\" height=\"128\" src=\"https://img-blog.csdnimg.cn/f3f1faed40cd4079aea88b9af53368a1.gif\" width=\"128\"/> 通常情况下，使用模板可以实现一些与类型无关的代码</p>\n<p>但是，对于一些特殊类型，可能我们就要对其进行一些 \"特殊的处理\" 。</p>\n<p><strong>💭 举例：</strong>如果不对特殊类型进行特殊处理就可能会出现一些问题，比如：</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include \"Date.h\"    /* 引入自己实现的日期类 */\nusing namespace std;\n\n/* 判断左数是否比小于右数 */\ntemplate&lt;class T&gt;\nbool Less(T left, T right) {\n    return left &lt; right;\n}\n\nint main(void)\n{\n    cout &lt;&lt; Less(1, 2) &lt;&lt; endl;        // 可以比较，结果正确\n\n    Date d1(2022, 7, 7);\n    Date d2(2022, 7, 8);\n    cout &lt;&lt; Less(d1, d2) &lt;&lt; endl;      // 可以比较，结果正确\n\n    Date* p1 = new Date(2022, 7, 16);\n    Date* p2 = new Date(2022, 7, 15);\n    cout &lt;&lt; Less(p1, p2) &lt;&lt; endl;      // 可以比较，结果正确\n\n    return 0;\n}</code></pre>\n<blockquote>\n<strong>❓ 运行结果：</strong>（我们运行几次发现，其结果不稳定，对于 Date* 一会是真一会是假）\n</blockquote>\n<p><img alt=\"\" height=\"300\" src=\"image\\19e18332f66e4c8cbcbadb80f954b4b4.png\" width=\"616\"/></p>\n<p>问题出在没传指针，传的是<span style=\"color:#0d0016;\"> p1</span> 和 <span style=\"color:#0d0016;\">p2</span>，这里传 <span style=\"color:#fe2c24;\">*</span><span style=\"color:#0d0016;\">p1</span> 和<span style=\"color:#fe2c24;\"> </span><span style=\"color:#fe2c24;\">*</span><span style=\"color:#0d0016;\">p2</span><span style=\"color:#0d0016;\"> </span>就能解决。但是……</p>\n<p><img alt=\"\" height=\"108\" src=\"image\\2c90596823a947c2b40f1a1329c11bdb.png\" width=\"115\"/> 这时候冲出个土匪拿炸弹强迫你：不让你传星号，就必须传<span style=\"color:#0d0016;\"> p1 </span>和 <span style=\"color:#0d0016;\">p2，怎么办？</span></p>\n<p>不慌，我们还可以用一种特殊的方式 —— <strong>模板的特化</strong>，<span style=\"background-color:#f9eda6;\">针对某些类型要进行特殊化处理</span>。</p>\n<p></p>\n<h3>0x01 模板特化的步骤</h3>\n<p><img alt=\"\" height=\"44\" src=\"image\\ea8bdcc93f7744188c5ffd94597e79e5.jpeg\" width=\"53\"/> 首先，必须要先有一个基础的函数模板。</p>\n<p><img alt=\"\" height=\"45\" src=\"image\\5732addd9ccf49b59560504a0e9222df.jpeg\" width=\"54\"/> 其次，关键字<span style=\"color:#956fe7;\"> template</span> 后面接上一对空的 <span style=\"color:#0d0016;\">&lt;&gt; </span>尖括号。</p>\n<p><img alt=\"\" height=\"44\" src=\"image\\d8ea15b36ad744c8b8c699c1facb4b44.jpeg\" width=\"52\"/> 然后，函数名后跟一对尖括号，尖括号中指定需要特化的内容。</p>\n<p><img alt=\"\" height=\"45\" src=\"image\\4dc98a25521f4fea94282dadbc0394f5.jpeg\" width=\"54\"/> 最后，函数形参表必须要和模板函数的基础参数类型完全相同，不同编译器会恶心人。</p>\n<p></p>\n<p><strong>💬 代码演示：</strong>模板的特化</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include \"Date.h\"\nusing namespace std;\n\n// 必不可少的原本\ntemplate&lt;class T&gt;\nbool Less(T left, T right) {\n    return left &lt; right;\n}\n\n// 针对某些类型要特殊化处理 ———— 使用模板的特化解决\ntemplate&lt;&gt;\nbool Less&lt;Date*&gt;(Date* left, Date* right) {\n    return *left &lt; *right;\n}\n\nint main(void)\n{\n    cout &lt;&lt; Less(1, 2) &lt;&lt; endl;       // 可以比较，结果正确\n\n    Date d1(2022, 7, 7);\n    Date d2(2022, 7, 8);\n    cout &lt;&lt; Less(d1, d2) &lt;&lt; endl;     // 可以比较，结果正确\n\n    Date* p1 = new Date(2022, 7, 16);\n    Date* p2 = new Date(2022, 7, 15);\n    cout &lt;&lt; Less(p1, p2) &lt;&lt; endl;     // 可以比较，结果正确  \n\n    return 0;\n}</code></pre>\n<p></p>\n<blockquote>\n<p><strong>🚩 运行结果：</strong>（运行多次后发现结果正常，每次都一致）</p>\n</blockquote>\n<p><img alt=\"\" height=\"156\" src=\"image\\2015de5a36c04140b54cee6612384562.png\" width=\"495\"/></p>\n<p><strong>💡 解读：</strong>对于普通类型，它还是会调正常的模板。对于<span style=\"color:#ad720d;\"> Date*</span> 编译器就会发现这里有个专门为 <span style=\"color:#ad720d;\">Date* </span>而准备的特化版本，编译器会优先选择该特化版本。这，就是模板的特化。</p>\n<p><img alt=\"\" height=\"426\" src=\"image\\2f06fd68f40e48de9f5bf8a7806f19de.png\" width=\"607\"/></p>\n<p><img alt=\"\" height=\"70\" src=\"https://img-blog.csdnimg.cn/4423f1641dff4e329f4c2b88669b2235.gif\" width=\"71\"/> 当然了，函数内你可以自己设计如何去处理你想要处理的特殊情况，这都是你说的算：</p>\n<pre><code class=\"language-cpp\">template&lt;&gt;\nbool Less&lt;Date*&gt;(Date* left, Date* right) {\n    // 这里面你可以做各种处理\n}</code></pre>\n<p></p>\n<p><strong>❓ 思考：</strong>现在我们加一个普通函数，<span style=\"color:#ad720d;\">Date* </span>会走哪个版本？</p>\n<pre><code class=\"language-cpp\">// 原模板\ntemplate&lt;class T&gt;\nbool Less(T left, T right) {\n    return left &lt; right;\n}\n\n// 对模板特化的\ntemplate&lt;&gt;\nbool Less&lt;Date*&gt;(Date* left, Date* right) {\n    return *left &lt; *right;\n}\n\n// 直接匹配的普通函数\nbool Less(Date* left, Date* right) {\n    return *left &lt; *right;\n}</code></pre>\n<p><strong>🔑 答案：</strong>函数重载，会走直接匹配的普通函数版本，因为是现成的，不用实例化。你可以这么理解：原模板是生肉，模板特化是半生不熟的肉，直接匹配的普通函数是熟肉。</p>\n<p><strong>🔺 结论：</strong>函数模板不一定非要特化，因为在参数里面就可以处理，写一个匹配参数的普通函数也更容易理解。</p>\n<p></p>\n<h3>0x02 类模板的特化</h3>\n<p><img alt=\"\" height=\"94\" src=\"image\\b1f21b649104444b8211aa091a68cb3c.jpeg\" width=\"120\"/> 刚才函数模板不一定非要特化，因为可以写一个具体实现的函数。</p>\n<p>但是类模板我们没法实现一个具体的实际类型，就必须要特化了。</p>\n<p></p>\n<p>💭 比如这里 <span style=\"color:#0d0016;\">d2</span> 需要接收一个<span style=\"color:#ad720d;\"> int </span>和 一个<span style=\"color:#ad720d;\"> double</span> 的值：</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include \"Date.h\"\nusing namespace std;\n\ntemplate&lt;class T1, class T2&gt;\nclass Data {\npublic:\n\tData() {\n\t\tcout &lt;&lt; \"Data&lt;T1, T2&gt;\" &lt;&lt; endl;\n\t}\nprivate:\n\tT1 _d1;\n\tT2 _d2;\n};\n\nint main(void)\n{\n\tData&lt;int, int&gt; d1;\n\tData&lt;int, double&gt; d2;   // 需要特化解决\n\n\treturn 0;\n}</code></pre>\n<p></p>\n<p><strong>💬 代码演示：</strong>类模板的特化</p>\n<pre><code class=\"language-cpp\">template&lt;class T1, class T2&gt;\nclass Data {\npublic:\n\tData() {\n\t\tcout &lt;&lt; \"Data&lt;T1, T2&gt;\" &lt;&lt; endl;\n\t}\nprivate:\n\tT1 _d1;\n\tT2 _d2;\n};\n\n// 类模板的特化\ntemplate&lt;&gt;\nclass Data&lt;int, double&gt; {\npublic:\n\tData() {\n\t\tcout &lt;&lt; \"Data&lt;int, double&gt;\" &lt;&lt; endl;\n\t}\n};\n\nint main(void)\n{\n\tData&lt;int, int&gt; d1;\n\tData&lt;int, double&gt; d2;\n\n\treturn 0;\n}</code></pre>\n<blockquote>\n<p><strong>🚩 运行结果：</strong></p>\n</blockquote>\n<p><img alt=\"\" height=\"136\" src=\"image\\d5be107ac6ea437c95dc030754fec503.png\" width=\"442\"/></p>\n<p></p>\n<h3>0x03 全特化和半特化</h3>\n<p><img alt=\"\" height=\"52\" src=\"image\\0f48bed1c2d145e5ae529201a37f8581.jpeg\" width=\"52\"/><strong> 全特化：</strong>全特化即是将模板参数列表中所有的参数都确定化。</p>\n<p><span style=\"color:#a5a5a5;\">（我们刚才写的就是全特化）</span></p>\n<pre><code class=\"language-cpp\">...\n// 全特化\ntemplate&lt;&gt;\nclass Data&lt;int, double&gt; {\npublic:\n\tData() {\n\t\tcout &lt;&lt; \"Data&lt;int, double&gt;\" &lt;&lt; endl;\n\t}\n};\n</code></pre>\n<p></p>\n<p><img alt=\"\" height=\"50\" src=\"image\\8aa6183107a24f3fa70b964bd2e06840.jpeg\" width=\"46\"/><strong> 半特化（又称偏特化）：</strong>将部分参数类表中的一部分参数特化。</p>\n<p><span style=\"color:#a5a5a5;\">（半特化并不是特化一半，就像半缺省并不是缺省一半一样）</span></p>\n<pre><code class=\"language-cpp\">...\n// 半特化（偏特化）\ntemplate&lt;class T1&gt;\nclass Data&lt;T1, char&gt; {\npublic:\n\tData() {\n\t\tcout &lt;&lt; \"Data&lt;T1, char&gt;\" &lt;&lt; endl;\n\t}\n};\n\nint main(void)\n{\n\t// 只要第二个值是 char 都会匹配到半特化\n\tData&lt;int, char&gt; d3;\n\tData&lt;char, char&gt; d4;\n\n\treturn 0;\n}</code></pre>\n<p></p>\n<p><img alt=\"\" height=\"137\" src=\"image\\bf56cd40a16943cb9ccdc51ddc1c8a7a.jpeg\" width=\"137\"/> 半特化还有一种表现方式，<span style=\"background-color:#f9eda6;\">半特化可以用来对参数进行更进一步的限制。</span></p>\n<p><strong>💬 代码演示：</strong>限制两个参数都是指针</p>\n<pre><code class=\"language-cpp\">...\n// 半特化还可以对参数进行进一步限制\ntemplate&lt;class T1, class T2&gt;\nclass Data&lt;T1*, T2*&gt; {\npublic:\n\tData() {\n\t\tcout &lt;&lt; \"Data&lt;T1*, T2*&gt;\" &lt;&lt; endl;\n\t}\n};\n\nint main(void)\n{\n\t// 只要你两个参数都是指针，就匹配\n\tData&lt;int*, char*&gt; d5;\n\tData&lt;char*, string*&gt; d6;\n\tData&lt;char**, void*&gt; d7;\n\n\treturn 0;\n}</code></pre>\n<blockquote>\n<p><strong>🚩 运行结果：</strong></p>\n</blockquote>\n<p><img alt=\"\" height=\"152\" src=\"image\\899d4b53f3f2415e8d9fecf9aa841111.png\" width=\"487\"/></p>\n<p></p>\n<p><strong>💬 代码演示：</strong>限制两个参数都是引用</p>\n<pre><code class=\"language-cpp\">template&lt;class T1, class T2&gt;\nclass Data&lt;T1&amp;, T2&amp;&gt; {\npublic:\n\tData() {\n\t\tcout &lt;&lt; \"Data&lt;T1&amp;, T2&amp;&gt;\" &lt;&lt; endl;\n\t}\n};\n\nint main(void)\n{\n\t// 只要你两个参数都是引用，就匹配\n\tData&lt;int&amp;, int&amp;&gt; d8;\n\tData&lt;char&amp;, string&amp;&gt; d9;\n\n\treturn 0;\n}</code></pre>\n<blockquote>\n<p><strong>🚩 运行结果：</strong></p>\n</blockquote>\n<p><img alt=\"\" height=\"124\" src=\"image\\990e675b68df45afaa9047b67c1de8af.png\" width=\"462\"/></p>\n<p></p>\n<p></p>\n<h2>Ⅲ. 模板的优缺点</h2>\n<h3>0x00 优点</h3>\n<p>① 模板复用了代码，节省资源，更快的迭代开发，C++的标准模板库（STL）因此而产生。</p>\n<p>② 增强了代码的灵活性。</p>\n<p></p>\n<h3>0x01 缺点</h3>\n<p>① 模板会导致代码膨胀问题，也会导致编译时间变长。</p>\n<p>② 出现模板编译错误时，错误信息非常凌乱，不易定位错误。</p>\n<p></p>\n<p></p>\n<hr/>\n<p><img alt=\"\" height=\"62\" src=\"image\\7a80245f0b5f4021a033b3789a9efdeb.png\" width=\"707\"/></p>\n<pre><code class=\"language-cpp\">📌 [ 笔者 ]   王亦优\n📃 [ 更新 ]   2022.8.1\n❌ [ 勘误 ]   /* 暂无 */\n📜 [ 声明 ]   由于作者水平有限，本文有错误和不准确之处在所难免，\n              本人也很想知道这些错误，恳望读者批评指正！</code></pre>\n<table align=\"center\" border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:700px;\"><tbody><tr><td> <p><strong>📜 参考资料 </strong></p> <p><span style=\"color:#a5a5a5;\">C++reference[EB/OL]. []. http://www.cplusplus.com/reference/.</span></p> <p><span style=\"color:#a5a5a5;\">Microsoft. MSDN(Microsoft Developer Network)[EB/OL]. []. .</span></p> <p><span style=\"color:#a5a5a5;\">百度百科[EB/OL]. []. https://baike.baidu.com/.</span></p> <p><span style=\"color:#a5a5a5;\">比特科技. C++[EB/OL]. 2021[2021.8.31]. </span></p> </td></tr></tbody></table>\n</div>\n</div>"}