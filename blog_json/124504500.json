{"blogid": "124504500", "writerAge": "码龄5年", "writerBlogNum": "128", "writerCollect": "153", "writerComment": "37", "writerFan": "30", "writerGrade": "5级", "writerIntegral": "2226", "writerName": "php_kevlin", "writerProfileAdress": "writer_image\\profile_124504500.jpg", "writerRankTotal": "9927", "writerRankWeekly": "27576", "writerThumb": "45", "writerVisitNum": "110163", "blog_read_count": "708", "blog_time": "已于 2022-04-29 22:29:22 修改", "blog_title": "php开启opcache", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-dracula\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h5><a id=\"1_0\"></a>1.简介</h5>\n<p>OPcache 通过将 PHP 脚本预编译的字节码存储到共享内存中来提升 PHP 的性能， 存储预编译字节码的好处就是 省去了每次加载和解析 PHP 脚本的开销。</p>\n<blockquote>\n<p>注意: 如果需要将 » Xdebug 扩展和 OPcache 一起使用，必须在 Xdebug 扩展之前加载 OPcache 扩展。</p>\n</blockquote>\n<h5><a id=\"2_7\"></a>2.安装</h5>\n<p>1.在php.ini文件中</p>\n<pre><code class=\"prism language-php\">zend_extension<span class=\"token operator\">=</span>opcache<span class=\"token operator\">.</span>so \nopcache<span class=\"token operator\">.</span>enable<span class=\"token operator\">=</span><span class=\"token number\">1</span> \nopcache<span class=\"token operator\">.</span>enable_cli<span class=\"token operator\">=</span><span class=\"token number\">1</span>\n</code></pre>\n<p>2.重启php-fpm和apache,<br/> <img alt=\"在这里插入图片描述\" src=\"image\\7ac3f00ad1674a5980d8ea3aacdf4c1b.png\"/><br/> php.ini文件opcache参数:</p>\n<pre><code class=\"prism language-ini\">配置php.ini\n[Zend Opcache]\nzend_extension = /usr/local/php/lib/php/extensions/no-debug-non-zts-20090626/opcache.so\nopcache.enable=1 ;启用操作码缓存\nopcache.enable_cli=1 ;仅针对CLI环境启用操作码缓存\nopcache.memory_consumption=128 ;共享内存大小，单位MB\nopcache.interned_strings_buffer=8 ;存储临时字符串的内存大小，单位MB\nopcache.max_accelerated_files=4000 ;哈希表中可存储的脚本文件数量上限\n;opcache.max_wasted_percentage=5 ;浪费内存的上限，以百分比计\n;opcache.use_cwd=1;附加改脚本的工作目录,避免同名脚本冲突\nopcache.validate_timestamps=1 ;每隔revalidate_freq 设定的秒数 检查脚本是否更新\nopcache.revalidate_freq=60 ;\n;opcache.revalidate_path=0 ;如果禁用此选项，在同一个 include_path 已存在的缓存文件会被重用\n;opcache.save_comments=1 ;禁用后将也不会加载注释内容\nopcache.fast_shutdown=1 ;一次释放全部请求变量的内存\nopcache.enable_file_override=0 ; 如果启用，则在调用函数file_exists()， is_file() 以及 is_readable() 的时候， 都会检查操作码缓存\n;opcache.optimization_level=0xffffffff ;控制优化级别的二进制位掩码。\n;opcache.inherited_hack=1 ;PHP 5.3之前做的优化\n;opcache.dups_fix=0 ;仅作为针对 “不可重定义类”错误的一种解决方案。\n;opcache.blacklist_filename=\"\" ;黑名单文件为文本文件，包含了不进行预编译优化的文件名\n;opcache.max_file_size=0 ;以字节为单位的缓存的文件大小上限\n;opcache.consistency_checks=0 ;如果是非 0 值，OPcache 将会每隔 N 次请求检查缓存校验和\nopcache.force_restart_timeout=180 ; 如果缓存处于非激活状态，等待多少秒之后计划重启。\n;opcache.error_log=\"\" ;OPcache模块的错误日志文件\n;opcache.log_verbosity_level=1 ;OPcache模块的日志级别。致命（0）错误（1) 警告（2）信息（3）调试（4）\n;opcache.preferred_memory_model=\"\" ;OPcache 首选的内存模块。可选值包括： mmap，shm, posix 以及 win32。\n;opcache.protect_memory=0 ;保护共享内存，以避免执行脚本时发生非预期的写入。 仅用于内部调试。\n;opcache.mmap_base=null ;在Windows 平台上共享内存段的基地址\n</code></pre>\n<hr/>下面内容来自：[公众号](https://mp.weixin.qq.com/s/LS3xMPO2QHn7Si3h1xFL8Q) \n<h2><a id=\"_OPCache__51\"></a>. OPCache 介绍</h2>\n<p>一<br/> OPCache 是Zend官方出品的，开放自由的 opcode 缓存扩展，还具有代码优化功能，省去了每次加载和解析 PHP 脚本的开销。</p>\n<p>PHP 5.5.0 及后续版本中已经绑定了 OPcache 扩展。</p>\n<p>缓存两类内容:</p>\n<ul><li> <p>OPCode</p> </li><li> <p>Interned String，如注释、变量名等</p> </li></ul>\n<h2><a id=\"_OPCache__63\"></a>二. OPCache 原理</h2>\n<p>OPCache缓存的机制主要是：将编译好的操作码放入共享内存，提供给其他进程访问。</p>\n<p>这里就涉及到内存共享机制，另外所有内存资源操作都有锁的问题，我们一一解读。</p>\n<h3><a id=\"1__69\"></a>1 共享内存</h3>\n<p>UNIX/Linux 系统提供很多种进程间内存共享的方式：</p>\n<ul><li> <p><strong>System-V shm API: System V共享内存</strong>,</p>\n<ul><li>sysv shm是持久化的，除非被一个进程明确的删除，否则它始终存在于内存里，直到系统关机；</li></ul> </li><li> <p><strong>mmap API</strong>：</p>\n<ul><li> <p>mmap映射的内存在不是持久化的，如果进程关闭，映射随即失效，除非事先已经映射到了一个文件上</p> </li><li> <p>内存映射机制mmap是POSIX标准的系统调用，有匿名映射和文件映射两种</p> </li><li> <p>mmap的一大优点是把文件映射到进程的地址空间</p> </li><li> <p>避免了数据从用户缓冲区到内核page cache缓冲区的复制过程；</p> </li><li> <p>当然还有一个优点就是不需要频繁的read/write系统调用</p> </li></ul> </li><li> <p><strong>POSIX API：System V 的共享内存是过时的, POSIX共享内存提供了使用更简单、设计更合理的API.</strong></p> </li><li> <p><strong>Unix socket API</strong></p> </li></ul>\n<p>OPCache 使用了前三个共享内存机制，根据配置或者默认mmap 内存共享模式。</p>\n<p>依据PHP字节码缓存的场景，OPCache的内存管理设计非常简单，快速读写，不释放内存，过期数据置为Wasted。</p>\n<p>当Wasted内存大于设定值时，自动重启OPCache机制，清空并重新生成缓存。</p>\n<h3><a id=\"2__96\"></a>2 互斥锁</h3>\n<p>任何内存资源的操作，都涉及到锁的机制。</p>\n<p>共享内存：一个单位时间内，只允许一个进程执行写操作，允许多个进程执行读操作；</p>\n<p>写操作同时，不阻止读操作，以至于很少有锁死的情况。</p>\n<blockquote>\n<p>这就引发另外一个问题：新代码、大流量场景，进程排队执行缓存opcode操作；重复写入，导致资源浪费。</p>\n</blockquote>\n<h2><a id=\"_OPCache__107\"></a>三. OPCache 缓存解读</h2>\n<p>OPCache 是官方的Opcode 缓存解决方案，在PHP5.5版本之后，已经打包到PHP源码中一起发布。</p>\n<p>它将PHP编译产生的字节码以及数据缓存到共享内存中, 在每次请求，从缓存中直接读取编译后的opcode，进行执行。</p>\n<p>通过节省脚本的编译过程，提高PHP的运行效率。</p>\n<p>如果正在使用APC扩展，做同样的工作，现在强烈推荐OPCache来代替，尤其是PHP7中。</p>\n<h3><a id=\"1_OPCode__116\"></a>1 OPCode 缓存</h3>\n<ul><li> <p>Opcache 会缓存OPCode以及如下内容：</p> </li><li> <p>PHP脚本涉及到的函数</p> </li><li> <p>PHP脚本中定义的Class</p> </li><li> <p>PHP脚本文件路径</p> </li><li> <p>PHP脚本OPArray</p> </li><li> <p>PHP脚本自身结构/内容</p> </li></ul>\n<h3><a id=\"2_Interned_String__129\"></a>2 Interned String 缓存</h3>\n<p>首先我们需要理解，什么是 Interned String？</p>\n<p>在PHP5.4的时候, 引入了Interned String机制, 用于优化PHP对字符串的存储和处理。</p>\n<p>尤其是处理大块的字符串，比如PHP doces时，Interned String 可以优化内存。</p>\n<p>Interned String 缓存的内容包括：变量名称、类名、方法名、字符串、注释等。</p>\n<p>在PHP-FPM模式中，Interned String 缓存字符，仅限于Worker 进程内部。</p>\n<p>而缓存到OPCache中，那么Worker进程之间可以使用 Interned String 缓存的字符串，节省内存。</p>\n<p>我们需要注意一个事情，在PHP开发中，一般会有大段的注释，也会被缓存到OPCache中。</p>\n<p>可以通过php.ini的配置，关闭注释的缓存。</p>\n<p>但是，像Zend Framework等框架中，会引用注释，所以，是否关闭注释的缓存，需要区别对待。</p>\n<h2><a id=\"_OPCache__148\"></a>四. OPCache 更新策略</h2>\n<p>是缓存，都存在过期，以及更新策略等。</p>\n<p>而OPCache的更新策略非常简单，到期数据置为Wasted，达到设定值，清空缓存，重建缓存。</p>\n<p>这里需要注意：在高流量的场景下，重建缓存是一件非常耗费资源的事儿。</p>\n<p>OPCache 在创建缓存时并不会阻止其他进程读取。</p>\n<p>这会导致大量进程反复新建缓存。所以，不要设置OPCache过期时间</p>\n<p><strong>每次发布新代码时，都会出现反复新建缓存的情况。如何避免呢？</strong></p>\n<ul><li> <p>不要在高峰期发布代码，这是任何情况下都要遵守的规则</p> </li><li> <p>代码预热，比如使用脚本批量调PHP 访问URL，或者使用OPCache 暴露的API 如opcache_compile_file() 进行编译缓存</p> </li></ul>\n<h2><a id=\"_OPCache__165\"></a>五. OPCache 的配置</h2>\n<h3><a id=\"1__166\"></a>1 内存配置</h3>\n<ul><li> <p>opcache.preferred_memory_model=“mmap” OPcache 首选的内存模块。如果留空，OPcache 会选择适用的模块， 通常情况下，自动选择就可以满足需求。可选值包括：mmap，shm,posix 以及win32。</p> </li><li> <p>opcache.memory_consumption=64 OPcache 的共享内存大小，以兆字节为单位，默认64M</p> </li><li> <p>opcache.interned_strings_buffer=4 用来存储临时字符串的内存大小，以兆字节为单位，默认4M</p> </li><li> <p>opcache.max_wasted_percentage=5 浪费内存的上限，以百分比计。如果达到此上限，那么 OPcache 将产生重新启动续发事件。默认5</p> </li></ul>\n<h3><a id=\"2__175\"></a>2 允许缓存的文件数量以及大小</h3>\n<ul><li> <p>opcache.max_accelerated_files=2000 OPcache 哈希表中可存储的脚本文件数量上限。真实的取值是在质数集合{ 223, 463, 983, 1979, 3907, 7963, 16229, 32531, 65407, 130987 } 中找到的第一个大于等于设置值的质数。设置值取值范围最小值是200，最大值在 PHP 5.5.6 之前是100000，PHP 5.5.6 及之后是1000000。默认值2000</p> </li><li> <p>opcache.max_file_size=0 以字节为单位的缓存的文件大小上限。设置为 0 表示缓存全部文件。默认值0</p> </li></ul>\n<h3><a id=\"3__180\"></a>3 注释相关的缓存</h3>\n<ul><li> <p>opcache.load_commentsboolean 如果禁用，则即使文件中包含注释，也不会加载这些注释内容。本选项可以和* opcache.save_comments 一起使用，以实现按需加载注释内容。</p> </li><li> <p>opcache.fast_shutdown boolean 如果启用，则会使用快速停止续发事件。所谓快速停止续发事件是指依赖 Zend 引擎的内存管理模块 一次释放全部请求变量的内存，而不是依次释放每一个已分配的内存块。</p> </li></ul>\n<h3><a id=\"4__185\"></a>4 二级缓存的配置</h3>\n<ul><li> <p>opcache.file_cache 配置二级缓存目录并启用二级缓存。启用二级缓存可以在 SHM 内存满了、服务器重启或者重置 SHM 的时候提高性能。默认值为空字符串\"\"，表示禁用基于文件的缓存。</p> </li><li> <p>opcache.file_cache_onlyboolean 启用或禁用在共享内存中的 opcode 缓存。</p> </li><li> <p>opcache.file_cache_consistency_checksboolean 当从文件缓存中加载脚本的时候，是否对文件的校验和进行验证。</p> </li><li> <p>opcache.file_cache_fallbackboolean 在 Windows 平台上，当一个进程无法附加到共享内存的时候， 使用基于文件的缓存，也即：opcache.file_cache_only=1。需要显示的启用文件缓存。</p> </li></ul>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}