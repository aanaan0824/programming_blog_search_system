{"blogid": "125859394", "writerAge": "码龄1年", "writerBlogNum": "85", "writerCollect": "2633", "writerComment": "3307", "writerFan": "2912", "writerGrade": "6级", "writerIntegral": "8212", "writerName": "小黎的培培笔录", "writerProfileAdress": "writer_image\\profile_125859394.jpg", "writerRankTotal": "1688", "writerRankWeekly": "250", "writerThumb": "2970", "writerVisitNum": "77840", "blog_read_count": "1174", "blog_time": "于 2022-08-16 08:00:00 发布", "blog_title": "「Java 数据结构和算法」：图文详解---中缀表达式转后缀表达式。", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E4%B8%80%E3%80%81%E6%A0%88-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%80%E3%80%81%E6%A0%88\">一、栈</a></p>\n<p id=\"1%E3%80%81%E6%A0%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-toc\" style=\"margin-left:40px;\"><a href=\"#1%E3%80%81%E6%A0%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D\">1、栈的基本介绍</a></p>\n<p id=\"%C2%A02%E3%80%81%E6%A0%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A02%E3%80%81%E6%A0%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0\">2、栈的底层实现</a></p>\n<p id=\"%E4%BA%8C%E3%80%81%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BA%8C%E3%80%81%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F\">二、中缀表达式转后缀表达式</a></p>\n<p id=\"%C2%A01%E3%80%81%E6%8B%86%E8%A7%A3%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A01%E3%80%81%E6%8B%86%E8%A7%A3%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F\">1、拆解中缀表达式</a></p>\n<p id=\"2%E3%80%81%E4%B8%AD%E7%BC%80%E8%BD%AC%E5%90%8E%E7%BC%80%E7%9A%84%E7%AE%97%E6%B3%95-toc\" style=\"margin-left:40px;\"><a href=\"#2%E3%80%81%E4%B8%AD%E7%BC%80%E8%BD%AC%E5%90%8E%E7%BC%80%E7%9A%84%E7%AE%97%E6%B3%95\">2、中缀转后缀的算法</a></p>\n<p id=\"3%E3%80%81%E4%B8%AD%E7%BC%80%E8%BD%AC%E5%90%8E%E7%BC%80%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90-toc\" style=\"margin-left:40px;\"><a href=\"#3%E3%80%81%E4%B8%AD%E7%BC%80%E8%BD%AC%E5%90%8E%E7%BC%80%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90\">3、中缀转后缀代码解析</a></p>\n<p id=\"4%E3%80%81%E5%AF%B9%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E8%A1%8C%E8%AE%A1%E7%AE%97-toc\" style=\"margin-left:40px;\"><a href=\"#4%E3%80%81%E5%AF%B9%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E8%A1%8C%E8%AE%A1%E7%AE%97\">4、对后缀表达式进行计算</a></p>\n<hr id=\"hr-toc\"/>\n<h1>一、栈</h1>\n<blockquote>\n<h2 id=\"1%E3%80%81%E6%A0%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D\">1、栈的基本介绍</h2>\n<p>        栈是⼀个先⼊后出的有序列表。栈(stack)是限制线性表中元素的插⼊和删除只能在线性表的同⼀端进⾏的⼀种特殊线性表。允许插⼊和删除的⼀端，为变化的⼀端，称为栈顶(Top)，另⼀端为固定的⼀端，称为栈底(Bottom)。</p>\n<p>        根据栈的定义可知，最先放⼊栈中元素在栈底，最后放⼊的元素在栈顶，⽽删除元素刚好相反，最后放⼊的元素最先删除，最先放⼊的元素最后删除。</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\e0c2ec129af74ebea46d2ce17aba5e27.jpeg\"/></p>\n<h2 id=\"%C2%A02%E3%80%81%E6%A0%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0\"> 2、栈的底层实现</h2>\n<p><strong>▶ （1）创建一个类，模拟栈</strong></p>\n<p><strong>        </strong>maxSize ：栈的最大容量</p>\n<p>        top ：表示栈顶</p>\n<p>        stack ：数组用来存储数据</p>\n<pre><code>public class Stacks {\n    public int maxSize;\n    public int top ;\n    public int[] stack;\n\n    //构造器，传入栈的最大容量\n    public Stacks(int maxSize) {\n        this.maxSize = maxSize;\n        //初始化栈顶的位置为-1，栈空\n        top = -1;\n        //初始化数组，最大容量为栈的容量\n        stack = new int[maxSize];\n    }\n}</code></pre>\n<p><strong>▶ （2）判断栈空和栈满</strong></p>\n<p><strong>    ​​​​​​▷ 栈满</strong></p>\n<pre><code>    //因为底层是数组存储数据，所以索引从0开始，\n    //判断条件为 top == maxSize - 1\n    public boolean isFull(){\n        return top == maxSize - 1;\n    }</code></pre>\n<p><strong>    ▷ 栈空</strong></p>\n<pre><code>    public boolean isEmpty(){\n        return top == -1;\n    }</code></pre>\n<p><strong>▶ （3）入栈操作</strong></p>\n<p><strong>        </strong>首先判断是否栈满，栈满后则不能继续添加，先对栈顶进行加一，然后再放入数据。</p>\n<pre><code>    public void push(int data){\n        //判断是否栈满\n        if (isFull()){\n            System.out.println(\"栈满，无法入栈\");\n            return;\n        }\n        top++;\n        stack[top] = data;\n    }</code></pre>\n<p><strong>▶ （4）出栈操作</strong></p>\n<p><strong>        </strong>首先判断栈空，出栈操作其实就是将top减一即可，return stack[top--]; 这样操作是为了让我们知道出栈的数据是什么。</p>\n<pre><code>    public int pop(){\n        if (isEmpty()){\n            throw new RuntimeException(\"栈空，无法出栈！\");\n        }\n        //先出栈，后减减\n        return stack[top--];\n    }</code></pre>\n<p><strong>▶ （5）显示栈数据</strong></p>\n<pre><code>  public void show(){\n        if (isEmpty()){\n            System.out.println(\"栈空，无法显示！\");\n            return;\n        }\n        for (int i = top ; i &gt;= 0; i--){\n            System.out.printf(\"stack[%d] = %d\\n\", i , stack[i]);\n        }\n    }</code></pre>\n<p></p>\n</blockquote>\n<hr/>\n<h1 id=\"%E4%BA%8C%E3%80%81%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F\">二、中缀表达式转后缀表达式</h1>\n<blockquote>\n<h2 id=\"%C2%A01%E3%80%81%E6%8B%86%E8%A7%A3%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F\"> 1、拆解中缀表达式</h2>\n<p>        首先将中缀表达式拆解成一个一个的字符，存放到集合中，方便后面我们将中缀转后缀时的遍历操作。</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\055504e677be4d11b2a21878cf60b004.png\"/></p>\n<p style=\"text-align:center;\">首先用split分割操作将原数据分割到数组中存放，然后用增强for循环遍历并同时存放到创建好的stringList集合中。</p>\n<pre><code>    public static List&lt;String&gt; endList(String s){\n\n        String[] s1 = s.split(\"\");\n\n        List&lt;String&gt; stringList = new ArrayList&lt;&gt;();\n\n        for (String s2 : s1) {\n            stringList.add(s2);\n        }\n\n        return stringList;\n    }</code></pre>\n<p> <strong>▶ 补充运算符优先级的判断</strong></p>\n<p>        后面我们转换成后缀表达式时，需要判断运算符的优先级。</p>\n<pre><code>  public static int Calcu(String s){\n\n        char ch = s.charAt(0);\n\n        if (ch == '-' || ch == '+'){\n            return 0;\n        } else if (ch == '*' || ch == '/') {\n            return 1;\n        }\n        return -1;\n    }</code></pre>\n<h2 id=\"2%E3%80%81%E4%B8%AD%E7%BC%80%E8%BD%AC%E5%90%8E%E7%BC%80%E7%9A%84%E7%AE%97%E6%B3%95\">2、中缀转后缀的算法</h2>\n<p>  ▶ 初始化两个栈:运算符栈s1和储存中间结果的栈s2<br/>   ▶ 从左至右扫描中缀表达式<br/>   ▶ 遇到操作数时，将其压s2<br/>   ▶ 遇到运算符时, 比较其与s1栈顶运算符的优先级<br/>       ▷如果s1为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈<br/>       ▷否则，若优先级比栈项运算符的高，也将运算符压入s1<br/>       ▷否则,将s1栈顶的运算符弹出并压入到s2中 ,再次与s1中新的栈顶运算符相比较<br/>   ▶ 遇到括号时:<br/>       ▷ 如果是左括号“(”，则直接压入s1<br/>       ▷ 如果是右括号“)”，则依次弹出s1栈顶的运算符, 并压入s2，直到遇到左括号为止，此时将这一对括号丢弃<br/>   ▶ 重复步骤2至5,直到表达式的最右边<br/>   ▶ 将s1中剩余的运算符依次弹出并压入s2<br/>   ▶ 依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式</p>\n<h2 id=\"3%E3%80%81%E4%B8%AD%E7%BC%80%E8%BD%AC%E5%90%8E%E7%BC%80%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90\">3、中缀转后缀代码解析</h2>\n<p>        前面的算法说到，首先创建两个栈一个运算符栈和一个中间结果栈，但是根据上面算法的介绍，中间结果栈没有出栈操作，就是数据全部是存入，于是在写代码的时候我们可以将<strong>中间结果栈</strong>换成<strong>集合</strong>来存放数据。</p>\n<p style=\"text-align:center;\"> <img alt=\"\" src=\"image\\8940b95c20ab4d868d043b632451549d.png\"/></p>\n<p>         首先用增强for循环遍历原数据集合，然后进行判断，如果是数字就放入右方的集合中，如果是运算符就放入左方的符号栈中。</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\4a0a88c4f96a4b9a8823884dbdb88ddd.png\"/></p>\n<p>       进行运算符判断，如果是左括号“（  ” 就直接放入符号栈中，如果是右括号“ ）”，就取出符号栈栈顶的符号放入集合中，直到遇到左括号“（  ”，停止将栈顶的符号放入集合中，此时将栈顶出栈也就是去掉括号。</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\c0cafebadca44ee7aba4378c5eedbff9.png\"/></p>\n<p>         然后继续进行遍历放入数据和符号，如果是符号，就与符号栈的栈顶的符号进行比较，要放入运算符的运算级如果小于等于栈顶运算符的运算级，就将栈顶的运算符放入集合中，但下面的图中，运算符为括号，所以不用管，因为括号有单独的判断条件，所以直接放入。</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\207052404a3b4c529a11f27bded211e7.png\"/></p>\n<p>        遇到右括号又继续重复前面的操作。</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\628b2f380a0d4657bbec0229ae00896e.png\"/></p>\n<p>        放入运算符的优先级小于等于栈顶运算符的优先级，于是将栈顶的运算符放入集合中，然后放入的运算符继续放入符号栈中。</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\c250b880dfb64a96bc6fcfc021ed3e87.png\"/></p>\n<p>         最后循环结束，将符号栈中的运算符依次放入到集合中。</p>\n<pre><code>public static List&lt;String&gt; MiddleToEndExpress(List&lt;String&gt; strings){\n\n        //创建栈，存放运算符\n        Stack&lt;String&gt; operStack = new Stack&lt;&gt;();\n\n        //因为这个栈不需要出栈，所以使用集合\n        List&lt;String&gt; sumList = new ArrayList&lt;&gt;();\n\n        for (String s : strings) {\n\n            //判断是否是数据\n            if (s.matches(\"\\\\d+\")){\n\n               sumList.add(s);//是数据直接加入\n\n            }else if (s.equals(\"(\")){//判断是否是左括号\n\n                operStack.push(s);//是，直接放入符号栈\n\n            }else if (s.equals(\")\")){//判断是否是右括号\n\n                while (!operStack.peek().equals(\"(\")){//如果栈顶是左括号，退出循环\n\n                    sumList.add(operStack.pop());//不是左括号，就将栈顶的符号依次放入集合\n\n                }\n                //循环结束，表示栈顶是左括号，把左括号去掉，就去掉了一对括号\n                operStack.pop();\n\n            }else {//前面的判断都不是，那就是运算符\n               //如果符号栈为空，并且运算符小于等于栈顶的运算符优先级\n                while (operStack.size() != 0 &amp;&amp; Calcu(s) &lt;= Calcu(operStack.peek())){\n                    //就将栈顶的运算符放入集合中\n                    sumList.add(operStack.pop());\n\n                }\n                //然后将符号放入符号栈中\n                operStack.push(s);\n\n            }\n\n        }\n        \n        //遍历结束，将符号栈剩余的符号依次取出放入集合中\n        while (operStack.size() != 0){\n            sumList.add(operStack.pop());\n        }\n        //最后将集合返回\n        return sumList;\n    }</code></pre>\n<p><strong>最后结果为：结果中不能含括号，否则转换错误！</strong></p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\4f595f7d27e54f5e843ce62f92915e72.png\"/></p>\n<h2 id=\"4%E3%80%81%E5%AF%B9%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E8%A1%8C%E8%AE%A1%E7%AE%97\">4、对后缀表达式进行计算</h2>\n<p>        前面我们已经将中缀转成后缀表达式了，那么我们只需要直接计算了，首先还是遍历我们的集合（存放后缀表达式的）将数据暂时放入栈中方便我们操作，然后在遍历过程中进行判断，如果是数据就直接放入栈中，如果是运算符就从栈中取出两个数据进行运算，运算结果又放入栈中，直到栈中只存在一个数据时，就是最后的运算结果。</p>\n<pre><code>public static int endCalculator(List&lt;String&gt; stringList){\n        //创建栈，存放数据\n        Stack&lt;String&gt; dataStack = new Stack&lt;&gt;();\n        //循环遍历集合\n        for (String s : stringList) {\n\n            //正则表达式判断是否是数据，如果是，就放入栈中\n            if (s.matches(\"\\\\d+\")){\n\n                dataStack.push(s);\n\n            }else {//否则就是运算符\n                //取出两个数据\n                int num1 = Integer.parseInt(dataStack.pop());\n                int num2 = Integer.parseInt(dataStack.pop());\n                //存放运算结果的变量\n                int res = 0;\n                //判断运算符继续相应的运算\n                if (s.equals(\"+\")){\n                    res = num1 + num2;\n                }else if (s.equals(\"-\")) {\n                    res = num2 - num1;\n                }else if (s.equals(\"*\")) {\n                    res = num1 * num2;\n                }else if (s.equals(\"/\")) {\n                    res = num2 / num1;\n                }else {\n                    throw new RuntimeException(\"运算符异常！\");\n                }\n                //运算过后将结果又放入栈中\n                dataStack.push(\"\" + res);\n            }\n        }\n        //最后返回栈中唯一的数据既是结果\n        return Integer.parseInt(dataStack.pop());\n    }</code></pre>\n<p></p>\n</blockquote>\n</div>\n</div>"}