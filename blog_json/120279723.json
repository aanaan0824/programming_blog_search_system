{"blogid": "120279723", "writerAge": "码龄3年", "writerBlogNum": "74", "writerCollect": "116", "writerComment": "17", "writerFan": "371", "writerGrade": "4级", "writerIntegral": "876", "writerName": "Hello_RoyChen", "writerProfileAdress": "writer_image\\profile_120279723.jpg", "writerRankTotal": "26698", "writerRankWeekly": "15874", "writerThumb": "23", "writerVisitNum": "48086", "blog_read_count": "3561", "blog_time": "于 2021-09-14 08:47:56 发布", "blog_title": "c++读取yaml文件", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>1. 安装yaml库</p>\n<p>安装yaml-cpp</p>\n<p>yaml-cpp 是一个开源库，地址在 github 上，<a href=\"https://github.com/jbeder/yaml-cpp\" title=\"https://github.com/jbeder/yaml-cpp\">https://github.com/jbeder/yaml-cpp</a></p>\n<p>yaml-cpp 默认构建的就是静态库，也就是 unix 类系统下的 .a 文件，如果你想构建动态库的话，就需要在 cmake 时指定。</p>\n<p>下载解压之后</p>\n<pre><code>mkdir build \ncd build\ncmake -DYAML_BUILD_SHARED_LIBS=ON ..</code></pre>\n<p>编译成功后，会生成库文件，你只需要将库文件和头文件拷贝到你自己的工程当中，就可以使用了。</p>\n<p>编译完成后，复制build文件中的动态库文件</p>\n<blockquote>\n<p>libyaml-cpp.so</p>\n<p>libyaml-cpp.so.0.7</p>\n<p>libyaml-cpp.so.0.7.0</p>\n</blockquote>\n<p>以及头文件，将整个include复制到我们的工程目录下。</p>\n<p>2. 编写yaml工程</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\20210914085001398.png\"/></p>\n<p>config中包含文件 config.yaml，内容如下：</p>\n<pre><code>name: frank\nsex: male\nage: 18\n\nskills: \n  c++: 1\n  java: 1\n  android: 1\n  python: 1\n</code></pre>\n<p>src中包含文件 </p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\20210914085143757.png\"/></p>\n<p>include中的文件是我们从yaml中拷贝的include的头文件， 我把yaml-cpp的中的头文件都放到include下面了，如图所示：</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\20210914085344824.png\"/></p>\n<p>lib文件如图所示：</p>\n<p style=\"text-align:center;\"> <img alt=\"\" src=\"image\\20210914085413642.png\"/></p>\n<p>gpsmap.cpp内容如下：</p>\n<pre><code>#include \"gpsmap.h\"\n\nvoid getYamlParamters()\n{\n    YAML::Node config = YAML::LoadFile(\"../config/config.yaml\");\n    cout &lt;&lt; \"name:\" &lt;&lt; config[\"name\"].as&lt;string&gt;() &lt;&lt; endl;\n    cout &lt;&lt; \"sex:\" &lt;&lt; config[\"sex\"].as&lt;string&gt;() &lt;&lt; endl;\n    cout &lt;&lt; \"age:\" &lt;&lt; config[\"age\"].as&lt;int&gt;() &lt;&lt; endl;\n}</code></pre>\n<p>gpsmap.h</p>\n<pre><code>#ifndef GPSMAP_H\n#define GPSMAP_H\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;fstream&gt;\n#include \"include/yaml.h\"\nusing namespace std;\nvoid getYamlParamters();\n\n\n\n#endif</code></pre>\n<p>main.cpp如下</p>\n<pre><code>#include \"gpsmap.h\"\n\n\nint main(int argc,char** argv)\n{\n    getYamlParamters();\n    return 0;\n}</code></pre>\n<p> CMakeLists如下</p>\n<pre><code>cmake_minimum_required(VERSION 3.0)\nproject(gpsmap)\n# C++11 编译\nset(CMAKE_CXX_STANDARD 11)\n\n#${CMAKE_CURRENT_SOURCE_DIR}这是当前处理的CMakeLists.txt所在的目录,可以理解为一个绝对路径。\nset(INC_DIR ${CMAKE_CURRENT_SOURCE_DIR}/src/include)\nset(LIB_DIR ${CMAKE_CURRENT_SOURCE_DIR}/src/lib)\n\n#找到工程存放头文件路径\ninclude_directories(${INC_DIR})\n\n#将main.cpp以及gpsmap.cpp编译成可执行文件gpsmap\nadd_executable(gpsmap src/main.cpp src/gpsmap.cpp)\n\n#gpsmap链接yaml的动态库\ntarget_link_libraries(gpsmap \n                     ${LIB_DIR}/libyaml-cpp.so)\n</code></pre>\n<p>然后在build文件中</p>\n<p>cmake ..</p>\n<p>make</p>\n<p>./gpsmap</p>\n<p>输出结果</p>\n<blockquote>\n<p>name:frank<br/> sex:male<br/> age:18</p>\n</blockquote>\n<p>部分内容参考 </p>\n<p><a href=\"https://blog.csdn.net/Kevin_Xie86/article/details/88729580?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163153016116780262548993%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163153016116780262548993&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-88729580.pc_search_result_control_group&amp;utm_term=c%2B%2B+yaml%E4%BD%BF%E7%94%A8&amp;spm=1018.2226.3001.4187\" title=\"C++中使用yaml配置文件_Kevin_Xie86的博客-CSDN博客_c++ yml\">C++中使用yaml配置文件_Kevin_Xie86的博客-CSDN博客_c++ yml</a></p>\n</div>\n</div>"}