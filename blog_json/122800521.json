{"blogid": "122800521", "writerAge": "码龄2年", "writerBlogNum": "118", "writerCollect": "1455", "writerComment": "145", "writerFan": "858", "writerGrade": "5级", "writerIntegral": "1728", "writerName": "霸道小明", "writerProfileAdress": "writer_image\\profile_122800521.jpg", "writerRankTotal": "10015", "writerRankWeekly": "13442", "writerThumb": "437", "writerVisitNum": "137603", "blog_read_count": "31663", "blog_time": "已于 2022-02-23 22:59:37 修改", "blog_title": "C语言实现俄罗斯方块", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h1 id=\"main-toc\"><strong>目录</strong></h1>\n<p id=\"%E6%B8%B8%E6%88%8F%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA-toc\" style=\"margin-left:0px;\">    <a href=\"#%E6%B8%B8%E6%88%8F%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA\">一、游戏效果展示</a></p>\n<p id=\"%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E6%8B%B7%E8%B4%9D%E8%BF%90%E8%A1%8C-toc\" style=\"margin-left:0px;\">    <a href=\"#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E6%8B%B7%E8%B4%9D%E8%BF%90%E8%A1%8C\">二、完整代码，可以直接拷贝运行</a></p>\n<p id=\"%E4%B8%89%E3%80%81%E6%89%80%E9%9C%80%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83-toc\" style=\"margin-left:0px;\">    <a href=\"#%E4%B8%89%E3%80%81%E6%89%80%E9%9C%80%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83\">三、所需开发环境</a></p>\n<p id=\"%E5%9B%9B%E3%80%81%E5%85%B7%E4%BD%93%E9%A1%B9%E7%9B%AE%E5%AE%9E%E7%8E%B0-toc\" style=\"margin-left:0px;\">    <a href=\"#%E5%9B%9B%E3%80%81%E5%85%B7%E4%BD%93%E9%A1%B9%E7%9B%AE%E5%AE%9E%E7%8E%B0\">四、具体项目实现</a></p>\n<p id=\"%E2%91%A0%E6%B8%B8%E6%88%8F%E6%AC%A2%E8%BF%8E%E7%95%8C%E9%9D%A2%20welcome(%20)-toc\" style=\"margin-left:40px;\">    <a href=\"#%E2%91%A0%E6%B8%B8%E6%88%8F%E6%AC%A2%E8%BF%8E%E7%95%8C%E9%9D%A2%20welcome%28%20%29\">①游戏欢迎界面 welcome( )</a></p>\n<p id=\"%E2%91%A1%E6%B8%B8%E6%88%8F%E8%83%8C%E6%99%AF%20initGameScreen(%20)-toc\" style=\"margin-left:40px;\">    <a href=\"#%E2%91%A1%E6%B8%B8%E6%88%8F%E8%83%8C%E6%99%AF%20initGameScreen%28%20%29\">②游戏背景 initGameScreen( )</a></p>\n<p id=\"%E2%91%A2%E6%96%B9%E5%9D%97%E8%A1%A8%E7%A4%BA%20int%20block%5B%20%5D%5B%20%5D%5B%20%5D-toc\" style=\"margin-left:40px;\">    <a href=\"#%E2%91%A2%E6%96%B9%E5%9D%97%E8%A1%A8%E7%A4%BA%20int%20block%5B%20%5D%5B%20%5D%5B%20%5D\">③方块表示 int block[ ][ ][ ]</a></p>\n<p id=\"%E2%91%A3%E6%96%B0%E6%96%B9%E5%9D%97%E8%A1%A8%E7%A4%BAnextBlock(%20)-toc\" style=\"margin-left:40px;\">    <a href=\"#%E2%91%A3%E6%96%B0%E6%96%B9%E5%9D%97%E8%A1%A8%E7%A4%BAnextBlock%28%20%29\">④新方块表示nextBlock( )</a></p>\n<p id=\"%E2%91%A4%E8%AE%BE%E8%AE%A1%E6%B8%B8%E6%88%8F%E5%BE%AA%E7%8E%AFmain(%20)-toc\" style=\"margin-left:40px;\">    <a href=\"#%E2%91%A4%E8%AE%BE%E8%AE%A1%E6%B8%B8%E6%88%8F%E5%BE%AA%E7%8E%AFmain%28%20%29\">⑤设计游戏循环main( )</a></p>\n<p id=\"%E2%91%A5%E6%90%AD%E5%BB%BA%E7%94%A8%E6%88%B7%E6%93%8D%E4%BD%9C%E6%A1%86%E6%9E%B6move(%20)%E2%85%A0-toc\" style=\"margin-left:40px;\">    <a href=\"#%E2%91%A5%E6%90%AD%E5%BB%BA%E7%94%A8%E6%88%B7%E6%93%8D%E4%BD%9C%E6%A1%86%E6%9E%B6move%28%20%29%E2%85%A0\">⑥搭建用户操作框架move( )Ⅰ</a></p>\n<p id=\"%E2%91%A6%E5%88%A4%E6%96%AD%E6%96%B9%E5%9D%97%E8%83%BD%E5%90%A6%E5%90%91%E6%8C%87%E5%AE%9A%E6%96%B9%E5%90%91%E7%A7%BB%E5%8A%A8%20moveable(%20)-toc\" style=\"margin-left:40px;\">    <a href=\"#%E2%91%A6%E5%88%A4%E6%96%AD%E6%96%B9%E5%9D%97%E8%83%BD%E5%90%A6%E5%90%91%E6%8C%87%E5%AE%9A%E6%96%B9%E5%90%91%E7%A7%BB%E5%8A%A8%20moveable%28%20%29\">⑦判断方块能否向指定方向移动 moveable( )</a></p>\n<p id=\"%E2%91%A7%E6%B8%B8%E6%88%8F%E5%A4%B1%E8%B4%A5%E6%A3%80%E6%9F%A5%C2%A0-toc\" style=\"margin-left:40px;\">    <a href=\"#%E2%91%A7%E6%B8%B8%E6%88%8F%E5%A4%B1%E8%B4%A5%E6%A3%80%E6%9F%A5%C2%A0\">⑧游戏失败检查 failCheck( )</a></p>\n<p id=\"%E2%91%A8%E6%B8%85%E9%99%A4%E4%B8%8B%E9%99%8D%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E6%96%B9%E5%9D%97-toc\" style=\"margin-left:40px;\">    <a href=\"#%E2%91%A8%E6%B8%85%E9%99%A4%E4%B8%8B%E9%99%8D%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E6%96%B9%E5%9D%97\">⑨清除下降过程中的方块 clearBlock( )</a></p>\n<p id=\"%E2%91%A9%E5%88%A4%E6%96%AD%E6%96%B9%E5%9D%97%E6%97%8B%E8%BD%AC%20rotatable(%20)-toc\" style=\"margin-left:40px;\">    <a href=\"#%E2%91%A9%E5%88%A4%E6%96%AD%E6%96%B9%E5%9D%97%E6%97%8B%E8%BD%AC%20rotatable%28%20%29\">⑩判断方块旋转 rotatable( )</a></p>\n<p id=\"%E2%91%A0%E2%91%A0%E7%BB%98%E5%88%B6%E4%B8%8B%E9%99%8D%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E6%96%B9%E5%9D%97%20drawBlock(%20)-toc\" style=\"margin-left:40px;\">    <a href=\"#%E2%91%A0%E2%91%A0%E7%BB%98%E5%88%B6%E4%B8%8B%E9%99%8D%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E6%96%B9%E5%9D%97%20drawBlock%28%20%29\">①①绘制下降过程中的方块 drawBlock( )</a></p>\n<p id=\"%E2%91%A0%E2%91%A1%E5%BB%B6%E6%97%B6%E7%AD%89%E5%BE%85%20wait%20(%20)-toc\" style=\"margin-left:40px;\">    <a href=\"#%E2%91%A0%E2%91%A1%E5%BB%B6%E6%97%B6%E7%AD%89%E5%BE%85%20wait%20%28%20%29\">①②延时等待 wait ( )</a></p>\n<p id=\"%E2%91%A0%E2%91%A2%E5%9B%BA%E5%AE%9A%E6%96%B9%E5%9D%97%20mark(%20)-toc\" style=\"margin-left:40px;\">    <a href=\"#%E2%91%A0%E2%91%A2%E5%9B%BA%E5%AE%9A%E6%96%B9%E5%9D%97%20mark%28%20%29\">①③固定方块 mark( )</a></p>\n<p id=\"%E2%91%A0%E2%91%A3%E7%94%A8%E6%88%B7%E6%93%8D%E4%BD%9C%E6%A1%86%E6%9E%B6%E5%AE%8C%E5%96%84%E2%85%A1%20mov(%20)-toc\" style=\"margin-left:40px;\">   <a href=\"#%E2%91%A0%E2%91%A3%E7%94%A8%E6%88%B7%E6%93%8D%E4%BD%9C%E6%A1%86%E6%9E%B6%E5%AE%8C%E5%96%84%E2%85%A1%20mov%28%20%29\">①④用户操作框架完善Ⅱ mov( )</a></p>\n<p id=\"%E2%91%A0%E2%91%A4%E6%B6%88%E9%99%A4%E6%96%B9%E5%9D%97-toc\" style=\"margin-left:40px;\">   <a href=\"#%E2%91%A0%E2%91%A4%E6%B6%88%E9%99%A4%E6%96%B9%E5%9D%97\">①⑤消除方块 check( ) + down( )</a></p>\n<p id=\"%E2%91%A0%E2%91%A5%E6%9B%B4%E6%96%B0%E5%88%86%E6%95%B0%E5%92%8C%E7%AD%89%E7%BA%A7-toc\" style=\"margin-left:40px;\">   <a href=\"#%E2%91%A0%E2%91%A5%E6%9B%B4%E6%96%B0%E5%88%86%E6%95%B0%E5%92%8C%E7%AD%89%E7%BA%A7\">①⑥更新分数和等级 addScore( ) + updateGrade( )</a></p>\n<p id=\"%C2%A0%E4%BB%A3%E7%A0%81%E6%95%B4%E5%90%88%E8%BF%90%E8%A1%8C-toc\" style=\"margin-left:0px;\">    <a href=\"#%C2%A0%E4%BB%A3%E7%A0%81%E6%95%B4%E5%90%88%E8%BF%90%E8%A1%8C\"> 代码整合运行</a></p>\n<p id=\"%E4%BA%94%20%E3%80%81%E4%B8%8D%E8%B6%B3%E4%B9%8B%E5%A4%84-toc\" style=\"margin-left:0px;\">    <a href=\"#%E4%BA%94%20%E3%80%81%E4%B8%8D%E8%B6%B3%E4%B9%8B%E5%A4%84\">五 、不足之处</a></p>\n<hr id=\"hr-toc\"/>\n<h1>一、游戏效果展示</h1>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"523\" src=\"https://img-blog.csdnimg.cn/a53b4c2cbb984391b62e349c3180b59f.gif\" width=\"418\"/></p>\n<p>每个方块的朝向使用二维数组表示</p>\n<p><img alt=\"\" src=\"image\\309f4eba736b4a2abe53cccfa15a3564.png\"/></p>\n<h1 id=\"%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E6%8B%B7%E8%B4%9D%E8%BF%90%E8%A1%8C\">二、完整代码，可以直接拷贝运行</h1>\n<pre><code class=\"language-cpp\">#include&lt;graphics.h&gt;\n#include&lt;stdio.h&gt;\n#include&lt;time.h&gt;\n#include&lt;conio.h&gt;\t//kbhit()\n\nint score = 0;\t//总分\nint rank = 0;\t//等级\n\n#define BLOCK_COUNT 5\n#define BLOCK_WIDTH 5\n#define BLOCK_HEIGHT 5\n\n#define UNIT_SIZE 20\t//小方块宽度\n\n#define START_X 130\t\t//方块降落框，方块降落起始位置\n#define START_Y 30\n\n#define KEY_UP 87\t\t//用户操作\n#define KEY_LEFT 65\n#define KEY_RIGHT 68\n#define KEY_DOWN 83\n#define KEY_SPACE 32\n\n#define MinX 30\t\t//游戏左上角位置\n#define MinY 30\nint speed = 500;\t//方块降落速度\n\n\nint NextIndex = -1;\t\t//下一个方块\nint BlockIndex = -1;\t\t//当前方块\n\ntypedef enum {\t\t//方块朝向\n\tBLOCK_UP,\n\tBLOCK_RIGHT,\n\tBLOCK_LEFT,\n\tBLOCK_DOWN\n}block_dir_t;\n\ntypedef enum {\t\t//方块移动方向\n\tMOVE_DOWN,\n\tMOVE_LEFT,\n\tMOVE_RIGHT\n}move_dir_t;\n\n//方块颜色\nint color[BLOCK_COUNT] = {\n\tGREEN,\n\tCYAN,\n\tMAGENTA,\n\tYELLOW,\n\tBROWN\n};\nint visit[30][15];\t//访问数组visit[i][j] = 1表示该位置有方块\nint markColor[30][15];\t//对应位置颜色\nint block[BLOCK_COUNT * 4][BLOCK_WIDTH][BLOCK_HEIGHT] = {\n\t// | 形方块\n\t{ 0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0 },\n\t{ 0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0 },\n\t{ 0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0 },\n\t{ 0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0 },\n\t // L 形方块\n\t{ 0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,1,0,0,0,0,0,0 },\n\t{ 0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,0,0,0,0 },\n\t{ 0,0,0,0,0,0,1,1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0 },\n\t{ 0,0,0,0,0,0,0,0,1,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0 },\n\t// 田 形方块\n\t{ 0,0,0,0,0,0,1,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0 },\n\t{ 0,0,0,0,0,0,1,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0 },\n\t{ 0,0,0,0,0,0,1,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0 },\n\t{ 0,0,0,0,0,0,1,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0 },\n\t// T 形方块\n\t{ 0,0,0,0,0,0,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0 },\n\t{ 0,0,0,0,0,0,0,0,1,0,0,0,1,1,0,0,0,0,1,0,0,0,0,0,0 },\n\t{ 0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0 },\n\t{ 0,0,0,0,0,0,1,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0 },\n\t// Z 形方块\n\t{ 0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0 },\n\t{ 0,0,0,0,0,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0 },\n\t{ 0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0 },\n\t{ 0,0,0,0,0,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0 },\n};\n\n/***************************\n * 功能：欢迎页面\n * 输入：\n *\t\t无\n * 返回：\n *\t\t无\n **************************/\nvoid welcome() {\n\t//1.初始化画布\n\tinitgraph(550, 660);\n\t//2.设置窗口标题\n\tHWND window = GetHWnd();//获得窗口，获得当前窗口\n\tSetWindowText(window, _T(\"俄罗斯方块  小明来喽\"));\t//设置标题\n\n\t//3.设置游戏初始页面\n\tsetfont(40, 0, _T(\"微软雅黑\"));\t\t//设置文本的字体样式(高，宽（0表示自适应），字体）\n\tsetcolor(WHITE);\t// 设置颜色\n\touttextxy(205, 200, _T(\"俄罗斯方法\"));\n\n\tsetfont(20, 0, _T(\"楷体\"));\n\tsetcolor(WHITE);\t// 设置颜色\n\touttextxy(175, 300, _T(\"编程，从俄罗斯方块开始\"));\n\n\tSleep(3000);\n}\n\n/***************************\n * 功能：初始化游戏场景\n * 输入：\n *\t\t无\n * 返回：\n *\t\t无\n **************************/\nvoid initGameSceen() {\n\tchar str[16];\t//存放分数\n\t//1.清屏\n\tcleardevice();\n\t//2.画场景\n\trectangle(27, 27, 336, 635);\t//方块降落框外框\n\trectangle(29, 29, 334, 633);\t//方块降落框内框\n\trectangle(370, 50, 515, 195);\t//方块提示框\n\n\tsetfont(24, 0, _T(\"楷体\"));\t\t//写“下一个”\n\tsetcolor(LIGHTGRAY);\t//灰色\n\touttextxy(405, 215, _T(\"下一个：\"));\n\n\tsetcolor(RED);\t\t\t\t\t//写分数\n\touttextxy(405, 280, _T(\"分数：\"));\n\n\t//按指定格式，将score写入str\n\tsprintf_s(str, 16, \"%d\", score);\n\t//这里设置字符集为多字符，保证outtextxy可以写出变量str\n\touttextxy(415, 310, str);\n\n\touttextxy(405, 375, _T(\"等级：\"));\t//等级\n\n\t//按指定格式，将rank写入str\n\tsprintf_s(str, 16, \"%d\", rank);\n\t//这里设置字符集为多字符，保证outtextxy可以写出变量str\n\touttextxy(415, 405, str);\n\n\tsetcolor(LIGHTBLUE);\t//操作说明\n\touttextxy(390, 475, \"操作说明:\");\n\touttextxy(390, 500, \"↑: 旋转\");\n\touttextxy(390, 525, \"↓: 下降\");\n\touttextxy(390, 550, \"←: 左移\");\n\touttextxy(390, 575, \"→: 右移\");\n\touttextxy(390, 600, \"空格: 暂停\");\n}\n\n/*****************************************\n * 功能：清空方块提示框里的方块\n * 输入：\n *\t\t无\n * 返回：\n *\t\t无\n ****************************************/\nvoid clearBlock() {\n\tsetcolor(BLACK);\n\tsetfont(23, 0, \"楷体\");\n\tfor (int i = 0; i &lt; BLOCK_HEIGHT; ++i) {\n\t\tfor (int j = 0; j &lt; BLOCK_WIDTH; ++j) {\n\t\t\tint x = 391 + j * UNIT_SIZE;\n\t\t\tint y = 71 + i * UNIT_SIZE;\n\t\t\touttextxy(x, y, \"■\");\n\t\t}\n\t}\n}\n\n/*****************************************\n * 功能：清除降落过程中的方块\n * 输入：\n *\t\tx,y - 方块的坐标（二维数组左上角位置）\n *\t\tblock_dir_t - 方块方向\n * 返回：\n *\t\t无\n ****************************************/\nvoid clearBlock(int x, int y, block_dir_t blockDir) {\n\tsetcolor(BLACK);\n\t//\tsetfont(23, 0, \"楷体\");\n\tint id = BlockIndex * 4 + blockDir;\n\tfor (int i = 0; i &lt; BLOCK_HEIGHT; ++i) {\n\t\tfor (int j = 0; j &lt; BLOCK_WIDTH; ++j) {\n\t\t\tif (block[id][i][j] == 1) {\n\t\t\t\tint x2 = x + j * UNIT_SIZE;\n\t\t\t\tint y2 = y + i * UNIT_SIZE;\n\t\t\t\touttextxy(x2, y2, \"■\");\n\t\t\t}\n\t\t}\n\t}\n}\n\n/*****************************************\n * 功能：在提示框 与 降落框的起始位置画方块\n * 输入：\n *\t\tx,y - 方块的坐标（二维数组左上角位置）\n * 返回：\n *\t\t无\n ****************************************/\nvoid drawBlock(int x, int y) {\n\tsetcolor(color[NextIndex]);\n\tsetfont(23, 0, \"楷体\");\n\tfor (int i = 0; i &lt; BLOCK_HEIGHT; ++i) {\n\t\tfor (int j = 0; j &lt; BLOCK_WIDTH; ++j) {\n\t\t\tif (block[NextIndex * 4][i][j] == 1) {\n\t\t\t\tint x2 = x + j * UNIT_SIZE;\n\t\t\t\tint y2 = y + i * UNIT_SIZE;\n\t\t\t\touttextxy(x2, y2, \"■\");\n\t\t\t}\n\t\t}\n\t}\n}\n\n/*****************************************\n *功能：绘制下降过程中的方块\n *输入：\n *\t\tx,y - 方块的坐标（二维数组左上角位置）\n *\t\tblock_dir_t - 方块方向\n * 返回：\n *\t\t无\n ****************************************/\nvoid drawBlock(int x, int y, block_dir_t dir) {\n\tsetcolor(color[BlockIndex]);\n\tsetfont(23, 0, \"楷体\");\n\tint id = BlockIndex * 4 + dir;\n\tfor (int i = 0; i &lt; BLOCK_HEIGHT; ++i) {\n\t\tfor (int j = 0; j &lt; BLOCK_WIDTH; ++j) {\n\t\t\tif (block[id][i][j] == 1) {\n\t\t\t\t//擦除该方块的第i行第j列\n\t\t\t\touttextxy(x + j * UNIT_SIZE, y + i * UNIT_SIZE, \"■\");\n\t\t\t}\n\t\t}\n\t}\n}\n\n/*****************************************\n *功能：方块提示框中产生新方块\n *输入：\n *\t\t无\n *返回：\n *\t\t无\n ****************************************/\nvoid nextblock() {\n\tclearBlock();\n\t//产生随机数，随机选择方块\n\tsrand((unsigned)time(NULL));\t//使用时间函数的返回值，来作为随机种子\n\tNextIndex = rand() % BLOCK_COUNT;\t//产生0~5的随机数\n\tdrawBlock(391, 71);\n}\n\n /*****************************************\n  *功能：判断在指定位置向指定方向是否可以移动\n  *输入：\n  *\t\tx，y - 方块位置\n  *\t\tmoveDir - 下一步想要移动的方向\n  *\t\tblockDir - 当前方块的方向\n  * 返回：\n  *\t\ttrue - 可以移动\n  *\t\tfalse - 不可以移动\n  ****************************************/\nbool moveable(int x0, int y0, move_dir_t moveDir, block_dir_t blockDir) {\n\t//计算方块左上角在30×15的游戏区位置（第多少行， 第多少列）\n\tint x = (y0 - MinY) / UNIT_SIZE;\n\tint y = (x0 - MinX) / UNIT_SIZE;\n\tint ret = 1;\n\tint id = BlockIndex * 4 + blockDir;\n\tif (moveDir == MOVE_DOWN) {\n\t\tfor (int i = 0; i &lt; BLOCK_HEIGHT; ++i) {\n\t\t\tfor (int j = 0; j &lt; BLOCK_WIDTH; ++j) {\n\t\t\t\t//向下不能运动的条件：实心方块已经达到底部（x+i+1==30），或者底部已有方块\t\n\t\t\t\tif (block[id][i][j] == 1 &amp;&amp;\n\t\t\t\t\t(x + i + 1 == 30 || visit[x + i + 1][y + j] == 1)) {\n\t\t\t\t\tret = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse if (moveDir == MOVE_LEFT) {\n\t\tfor (int i = 0; i &lt; BLOCK_HEIGHT; ++i) {\n\t\t\tfor (int j = 0; j &lt; BLOCK_WIDTH; ++j) {\n\t\t\t\t//向左不能运动的条件：实心方块已经达到左边界(y+j==0),或者左边已有方块\n\t\t\t\tif (block[id][i][j] == 1 &amp;&amp;\n\t\t\t\t\t(y + j &lt;= 0 || visit[x + i][y + j - 1] == 1)) {\n\t\t\t\t\tret = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse if (moveDir == MOVE_RIGHT) {\n\t\tfor (int i = 0; i &lt; BLOCK_HEIGHT; ++i) {\n\t\t\tfor (int j = 0; j &lt; BLOCK_WIDTH; ++j) {\n\t\t\t\t//向下不能运动的条件：实心方块已经达到右边界（y+j+1&gt;=15)，或者右边已有方块\n\t\t\t\tif (block[id][i][j] == 1 &amp;&amp;\n\t\t\t\t\t(y + j + 1 &gt;= 15 || visit[x + i][y + j + 1] == 1)) {\n\t\t\t\t\tret = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\n/*****************************\n *功能：检测游戏是否结束\n *输入：\n *\t\t无\n * 返回：\n *\t\t无\n *****************************/\nvoid failCheck() {\n\t//游戏结束条件是顶部新被绘制出的方块就要“固化”，顶部新绘制的方块方向朝上，运动方向朝下\n\tif (!moveable(START_X, START_Y, MOVE_DOWN, (block_dir_t)BLOCK_UP)) {\n\t\tsetcolor(WHITE);\n\t\tsetfont(45, 0, \"隶体\");\n\t\touttextxy(75, 300, \"Game Over！\");\n\t\tSleep(1000);\n\t\tsystem(\"pause\");\n\t\tclosegraph();\n\t\texit(0);\n\t}\n}\n\n/**************************\n * 功能：延时等待\n * 输入：\n *\n * 返回：\n *\t\t无\n *************************/\nvoid wait(int interval) {\n\tint count = interval / 10;\n\tfor (int i = 0; i &lt; count; ++i) {\n\t\tSleep(10);\n\t\t//如果休眠期间用户有按键，则结束休眠\n\t\tif (_kbhit()) {\n\t\t\treturn;\n\t\t}\n\t}\n}\n\n/*****************************************\n * 功能：判断当前方块是否可以向指定方向旋转\n * 输入：\n *\t\tx，y - 方块位置（二维数组坐标）\n *\t\tdir - 方块旋转方向\n * 返回：\n *\t\ttrue - 可以旋转\n *\t\tfalse - 不可以旋转\n ****************************************/\nbool rotatable(int x, int y, block_dir_t dir) {\n\t//首先判断是否可以继续向下移动\n\tif (!moveable(x, y, MOVE_DOWN, dir)) {\n\t\treturn false;\n\t}\n\tint x2 = (y - MinY) / UNIT_SIZE;\n\tint y2 = (x - MinX) / UNIT_SIZE;\n\tint id = BlockIndex * 4 + dir;\n\tfor (int i = 0; i &lt; BLOCK_HEIGHT; ++i) {\n\t\tfor (int j = 0; j &lt; BLOCK_WIDTH; ++j) {\n\t\t\t//不能旋转条件：左右边界越界或者已有方块“阻挡”\n\t\t\tif (block[id][i][j] == 1 &amp;&amp; (y2 + j &lt; 0 || y2 + j &gt;= 15 || visit[x2 + i][y2 + j] == 1)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\n/*****************************************\n * 功能：\n * 输入：\n *\n * 返回：\n *\t\t无\n ****************************************/\nvoid mark(int x, int y, block_dir_t dir) {\n\tint id = BlockIndex * 4 + dir;\n\tint x2 = (y - MinY) / UNIT_SIZE;\n\tint y2 = (x - MinX) / UNIT_SIZE;\n\tfor (int i = 0; i &lt; BLOCK_HEIGHT; ++i) {\n\t\tfor (int j = 0; j &lt; BLOCK_WIDTH; ++j) {\n\t\t\tif (block[id][i][j] == 1) {\n\t\t\t\tvisit[x2 + i][y2 + j] = 1;\n\t\t\t\tmarkColor[x2 + i][y2 + j] = color[BlockIndex];\n\t\t\t}\n\t\t}\n\t}\n}\n\n/*****************************************\n * 功能：读取用户操作，时时更新降落的方块\n * 输入：\n *\t\t无\n * 返回：\n *\t\t无\n ****************************************/\nvoid move() {\n\tint x = START_X;\t//方块起始位置\n\tint y = START_Y;\n\tint k = 0;\n\tblock_dir_t blockDir = (block_dir_t)BLOCK_UP;\n\tint curSpeed = speed;\t//定义当前方块降落速度\n\t//读取用户操作前判断游戏是否结束\n\tfailCheck();\n\t//持续向下降落\n\twhile (1) {\n\t\tint curSpeed = speed;\t//定义当前方块降落速度\n\t\t//清除方块\n\t\tclearBlock(x, k + y, blockDir);\n\t\t//判断选择的方向\n\t\tif (_kbhit()) {\n\t\t\tint key = _getch();\n\t\t\tif (key == KEY_SPACE) {\n\t\t\t\tsystem(\"pause\");\n\t\t\t}\n\t\t\telse if (key == KEY_UP) {\n\t\t\t\tblock_dir_t nextDir = (block_dir_t)((blockDir + 1) % 4);\n\t\t\t\tif (rotatable(x, y + k, nextDir)) {\n\t\t\t\t\tblockDir = nextDir;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (key == KEY_LEFT) {\n\t\t\t\tif (moveable(x, y + k + 20, MOVE_LEFT, blockDir)) {\n\t\t\t\t\tx -= UNIT_SIZE;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (key == KEY_RIGHT) {\n\t\t\t\tif (moveable(x, y + k + 20, MOVE_RIGHT, blockDir)) {\n\t\t\t\t\tx += UNIT_SIZE;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (key == KEY_DOWN) {\n\t\t\t\tcurSpeed = 50;\n\t\t\t}\n\t\t}\n\t\tk += 20;\n\t\t//绘制方块\n\t\tdrawBlock(x, y + k, blockDir);\n\t\t//休眠\n\t\twait(curSpeed);\n\t\t//方块的固化处理，方块固定后结束循环，当前一个方块的move执行完毕\n\t\tif (!moveable(x, y + k, MOVE_DOWN, blockDir)) {\n\t\t\tmark(x, y + k, blockDir);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/*****************************************\n *功能：绘制刚从顶部降落的方块，更新提示框内的方块，调用方块降落函数move()\n *输入：\n *\t\t无\n * 返回：\n *\t\t无\n ****************************************/\nvoid newblock() {\n\tBlockIndex = NextIndex;\n\t//绘制刚从顶部下降的方块\n\tdrawBlock(START_X, START_Y);\n\t//让新出现方块暂停一会\n\tSleep(200);\n\t//右上角区域绘制下一个方块\n\tnextblock();\n\t//方块降落\n\tmove();\n}\n\n/*****************************************\n * 功能：消除第i行，并把上面的行都往下移\n * 输入：\n *\t\t无\n * 返回：\n *\t\t无\n ****************************************/\nvoid down(int x) {\n\tfor (int i = x; i &gt; 0; --i) {\n\t\tfor (int j = 0; j &lt; 15; ++j) {\n\t\t\tif (visit[i - 1][j] == 1) {\n\t\t\t\tvisit[i][j] = 1;\n\t\t\t\tmarkColor[i][j] = markColor[i - 1][j];\n\t\t\t\tsetcolor(markColor[i][j]);\n\t\t\t\touttextxy(20 * j + MinX, 20 * i + MinY, \"■\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvisit[i][j] = 0;\n\t\t\t\tsetcolor(BLACK);\n\t\t\t\touttextxy(20 * j + MinX, 20 * i + MinY, \"■\");\n\t\t\t}\n\t\t}\n\t}\n\t//清除最顶层方格\n\tsetcolor(BLACK);\n\tfor (int j = 0; j &lt; 15; ++j) {\n\t\tvisit[0][j] = 0;\n\t\touttextxy(20 * j + MinX, MinY, \"■\");\n\t}\n}\n\n/*****************************************\n * 功能：更新分数\n * 输入：\n *\t\t无\n * 返回：\n *\t\t无\n ****************************************/\nvoid addScore(int lines) {\n\tchar str[32];\n\tscore += lines * 10;\n\tsprintf_s(str, 32, \"%d\", score);\n\tsetcolor(RED);\n\touttextxy(415, 310, str);\n\n}\n\n/*************************\n * 功能：更新等级\n * 输入：\n *\t\t无\n * 返回：\n *\t\t无\n *************************/\nvoid updateGrade() {\n\t//更新等级\n\t//假设50分一级\n\trank = score / 50;\n\tchar str[32];\n\tsprintf_s(str, 32, \"%d\", rank);\n\tsetcolor(RED);\n\touttextxy(415, 405, str);\n\t//更新速度\n\tif (speed &lt;= 100) {\n\t\tspeed = 100;\n\t}\n\telse {\n\t\tspeed = 500 - rank * 20;\n\t}\n}\n\n/*************************\n * 功能：检查是否有满行方块\n * 输入：\n *\t\t无\n * 返回：\n *\t\t无\n *************************/\nvoid check() {\n\tint i, j;\n\tint clearLines = 0;\n\tfor (i = 29; i &gt;= 0; i--) {\n\t\t// 检查第i行有没有满\n\t\tfor (j = 0; j &lt; 15 &amp;&amp; visit[i][j]; j++);\n\t\t//执行到此处时，有两种情况：\n\t\t// 1. 第i行没有满，即表示有空位 此时 j&lt;15\n\t\t// 2. 第i行已满了，此时 j&gt;=15\n\t\tif (j &gt;= 15) {\n\t\t\t// 此时，第i行已经满了，就需要消除第i行\n\t\t\tdown(i);  //消除第i行，并把上面的行都下移\n\t\t\ti++;  // 因为最外层的循环中有 i--, 所以我们先i++, 使得下次循环时，再把这一行检查一下\n\t\t\tclearLines++;\n\t\t}\n\t}\n\t// 更新分数\n\taddScore(clearLines);\n\n\t// 更新等级(更新等级提示，更新速度）\n\tupdateGrade();\n}\n\nint main() {\n\twelcome();\n\tinitGameSceen();\n\t//产生新方块\n\tnextblock();\n\t//\tsystem(\"pause\");\n\tSleep(800);\n\n\t//初始化访问数组\n\tmemset(visit, 0, sizeof(visit));\n\n\twhile (1) {\n\t\tnewblock();\n\t\t//消除满行，并更新分数和速度\n\t\tcheck();\n\t}\n\tsystem(\"pause\");\n\tclosegraph();\n\treturn 0;\n}</code></pre>\n<h1 id=\"%E4%B8%89%E3%80%81%E6%89%80%E9%9C%80%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83\" style=\"margin-left:.0001pt;text-align:justify;\">三、所需开发环境</h1>\n<p style=\"margin-left:.0001pt;text-align:justify;\">1）安装VS2019，或VS其他版本</p>\n<p style=\"margin-left:.0001pt;text-align:justify;\">2）安装easyX图形库</p>\n<h1 id=\"%E5%9B%9B%E3%80%81%E5%85%B7%E4%BD%93%E9%A1%B9%E7%9B%AE%E5%AE%9E%E7%8E%B0\">四、具体项目实现</h1>\n<h2 id=\"%E2%91%A0%E6%B8%B8%E6%88%8F%E6%AC%A2%E8%BF%8E%E7%95%8C%E9%9D%A2%20welcome(%20)\">①游戏欢迎界面 welcome( )</h2>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"352\" src=\"image\\09c58000c7c242e59699114ddd115ad9.png\" width=\"281\"/></p>\n<p>在游戏开始前会有一个游戏欢迎页面，整个页面会持续大概三秒，之后便进入游戏场景。在游戏欢迎页面中，除了将显示游戏名称外，还要修改窗口标题。</p>\n<pre><code class=\"language-cpp\">/***************************\n * 功能：欢迎页面\n * 输入：\n *\t\t无\n * 返回：\n *\t\t无\n **************************/\nvoid welcome() {\n\t//1.初始化画布\n\tinitgraph(550, 660);\n\t//2.设置窗口标题\n\tHWND window = GetHWnd();//获得窗口，获得当前窗口\n\tSetWindowText(window, _T(\"俄罗斯方块  小明来喽\"));\t//设置标题\n\n\t//3.设置游戏初始页面\n\tsetfont(40, 0, _T(\"微软雅黑\"));\t\t//设置文本的字体样式(高，宽（0表示自适应），字体）\n\tsetcolor(WHITE);\t// 设置颜色\n\touttextxy(205, 200, _T(\"俄罗斯方法\"));\n\n\tsetfont(20, 0, _T(\"楷体\"));\n\tsetcolor(WHITE);\t// 设置颜色\n\touttextxy(175, 300, _T(\"编程，从俄罗斯方块开始\"));\n\n\tSleep(3000);\n}</code></pre>\n<h2 id=\"%E2%91%A1%E6%B8%B8%E6%88%8F%E8%83%8C%E6%99%AF%20initGameScreen(%20)\">②游戏背景 initGameScreen( ) </h2>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"352\" src=\"image\\11b1434a763747a5bc3ded64ca81ee03.png\" width=\"281\"/></p>\n<p> 绘制游戏场景</p>\n<pre><code class=\"language-cpp\">/***************************\n * 功能：初始化游戏场景\n * 输入：\n *\t\t无\n * 返回：\n *\t\t无\n **************************/\nvoid initGameSceen() {\n\tchar str[16];\t//存放分数\n\t//1.清屏\n\tcleardevice();\n\t//2.画场景\n\trectangle(27, 27, 336, 635);\t//方块降落框外框\n\trectangle(29, 29, 334, 633);\t//方块降落框内框\n\trectangle(370, 50, 515, 195);\t//方块提示框\n\n\tsetfont(24, 0, _T(\"楷体\"));\t\t//写“下一个”\n\tsetcolor(LIGHTGRAY);\t//灰色\n\touttextxy(405, 215, _T(\"下一个：\"));\n\n\tsetcolor(RED);\t\t\t\t\t//写分数\n\touttextxy(405, 280, _T(\"分数：\"));\n\n\t//按指定格式，将score写入str\n\tsprintf_s(str, 16, \"%d\", score);\n\t//这里设置字符集为多字符，保证outtextxy可以写出变量str\n\touttextxy(415, 310, str);\n\n\touttextxy(405, 375, _T(\"等级：\"));\t//等级\n\n\t//按指定格式，将rank写入str\n\tsprintf_s(str, 16, \"%d\", rank);\n\t//这里设置字符集为多字符，保证outtextxy可以写出变量str\n\touttextxy(415, 405, str);\n\n\tsetcolor(LIGHTBLUE);\t//操作说明\n\touttextxy(390, 475, \"操作说明:\");\n\touttextxy(390, 500, \"W: 旋转\");\n\touttextxy(390, 525, \"S: 下降\");\n\touttextxy(390, 550, \"A: 左移\");\n\touttextxy(390, 575, \"D: 右移\");\n\touttextxy(390, 600, \"空格: 暂停\");\n\tsystem(\"pause\");\n}</code></pre>\n<h2 id=\"%E2%91%A2%E6%96%B9%E5%9D%97%E8%A1%A8%E7%A4%BA%20int%20block%5B%20%5D%5B%20%5D%5B%20%5D\">③方块表示 int block[ ][ ][ ]</h2>\n<p><img alt=\"\" src=\"image\\d3a86e056a6d4421a9830e7d2b7dd20f.png\"/></p>\n<p>将每个方块的朝向用二维数组表示。此次共设计了五种方块，每个方块四种朝向，使用三维数组存储每个刚快及其朝向。1代表该点是方格。</p>\n<pre><code class=\"language-cpp\">#define BLOCK_COUNT 5\n#define BLOCK_WIDTH 5\n#define BLOCK_HEIGHT 5\n\nint block[BLOCK_COUNT * 4][BLOCK_WIDTH][BLOCK_HEIGHT] = {\n\t// | 形方块\n\t{ 0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0 },\n\t{ 0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0 },\n\t{ 0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0 },\n\t{ 0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0 },\n\t // L 形方块\n\t{ 0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,1,0,0,0,0,0,0 },\n\t{ 0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,0,0,0,0 },\n\t{ 0,0,0,0,0,0,1,1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0 },\n\t{ 0,0,0,0,0,0,0,0,1,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0 },\n\t// 田 形方块\n\t{ 0,0,0,0,0,0,1,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0 },\n\t{ 0,0,0,0,0,0,1,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0 },\n\t{ 0,0,0,0,0,0,1,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0 },\n\t{ 0,0,0,0,0,0,1,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0 },\n\t// T 形方块\n\t{ 0,0,0,0,0,0,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0 },\n\t{ 0,0,0,0,0,0,0,0,1,0,0,0,1,1,0,0,0,0,1,0,0,0,0,0,0 },\n\t{ 0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0 },\n\t{ 0,0,0,0,0,0,1,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0 },\n\t// Z 形方块\n\t{ 0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0 },\n\t{ 0,0,0,0,0,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0 },\n\t{ 0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0 },\n\t{ 0,0,0,0,0,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0 },\n};</code></pre>\n<h2 id=\"%E2%91%A3%E6%96%B0%E6%96%B9%E5%9D%97%E8%A1%A8%E7%A4%BAnextBlock(%20)\">④新方块表示nextBlock( )</h2>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"352\" src=\"image\\10db28c99e694a3e82e7640f316ba501.png\" width=\"281\"/></p>\n<p>在方块提示框中每次生成新方块由两个动作组成，首先是擦除方块，接着是绘制新方块。</p>\n<pre><code class=\"language-cpp\">/*****************************************\n * 功能：清空方块提示框里的方块\n * 输入：\n *\t\t无\n * 返回：\n *\t\t无\n ****************************************/\nvoid clearBlock() {\n\tsetcolor(BLACK);\n\tsetfont(23, 0, \"楷体\");\n\tfor (int i = 0; i &lt; BLOCK_HEIGHT; ++i) {\n\t\tfor (int j = 0; j &lt; BLOCK_WIDTH; ++j) {\n\t\t\tint x = 391 + j * UNIT_SIZE;\n\t\t\tint y = 71 + i * UNIT_SIZE;\n\t\t\touttextxy(x, y, \"■\");\n\t\t}\n\t}\n}\n\n\n/*****************************************\n * 功能：在提示框 与 降落框的起始位置画方块\n * 输入：\n *\t\tx,y - 方块的坐标（二维数组左上角位置）\n * 返回：\n *\t\t无\n ****************************************/\nvoid drawBlock(int x, int y) {\n\tsetcolor(color[NextIndex]);\n\tsetfont(23, 0, \"楷体\");\n\tfor (int i = 0; i &lt; BLOCK_HEIGHT; ++i) {\n\t\tfor (int j = 0; j &lt; BLOCK_WIDTH; ++j) {\n\t\t\tif (block[NextIndex * 4][i][j] == 1) {\n\t\t\t\tint x2 = x + j * UNIT_SIZE;\n\t\t\t\tint y2 = y + i * UNIT_SIZE;\n\t\t\t\touttextxy(x2, y2, \"■\");\n\t\t\t}\n\t\t}\n\t}\n}\n\n/*****************************************\n *功能：方块提示框中产生新方块\n *输入：\n *\t\t无\n *返回：\n *\t\t无\n ****************************************/\nvoid nextblock() {\n\tclearBlock();\n\t//产生随机数，随机选择方块\n\tsrand((unsigned)time(NULL));\t//使用时间函数的返回值，来作为随机种子\n\tNextIndex = rand() % BLOCK_COUNT;\t//产生0~5的随机数\n\tdrawBlock(391, 71);\n}\n</code></pre>\n<h2 id=\"%E2%91%A4%E8%AE%BE%E8%AE%A1%E6%B8%B8%E6%88%8F%E5%BE%AA%E7%8E%AFmain(%20)\">⑤设计游戏循环main( )</h2>\n<p> 在游戏框中每次生成新方块会进入对新方块降落处理，等处理完后便会循环</p>\n<pre><code class=\"language-cpp\">int main() {\n\twelcome();\n\tinitGameSceen();\n\t//产生新方块\n\tnextblock();\n\tSleep(800);\n\n\t//初始化访问数组\n\tmemset(visit, 0, sizeof(visit));\n\n\twhile (1) {\n\t\tnewblock();\n\t}\n\tsystem(\"pause\");\n\tclosegraph();\n\treturn 0;\n}\n\n/*****************************************\n *功能：绘制刚从顶部降落的方块，更新提示框内的方块，调用方块降落函数move()\n *输入：\n *\t\t无\n * 返回：\n *\t\t无\n ****************************************/\nvoid newblock() {\n\tBlockIndex = NextIndex;\n\t//绘制刚从顶部下降的方块\n\tdrawBlock(START_X, START_Y);\n\t//让新出现方块暂停一会\n\tSleep(200);\n\t//右上角区域绘制下一个方块\n\tnextblock();\n\t//方块降落\n\tmove();\n}</code></pre>\n<h2 id=\"%E2%91%A5%E6%90%AD%E5%BB%BA%E7%94%A8%E6%88%B7%E6%93%8D%E4%BD%9C%E6%A1%86%E6%9E%B6move(%20)%E2%85%A0\">⑥搭建用户操作框架move( )Ⅰ</h2>\n<p>用户操作框架：断游戏是否结束 → 擦除当前方块 → 用户按键操作 → 绘制新的方块 → 延时等待 → 方块是否要固化（固化则则表明对当前方块操作结束）。</p>\n<pre><code class=\"language-cpp\">#define KEY_UP 87\t\t//用户操作\n#define KEY_LEFT 65\n#define KEY_RIGHT 68\n#define KEY_DOWN 83\n#define KEY_SPACE 32\n\n/*****************************************\n * 功能：读取用户操作，时时更新降落的方块\n * 输入：\n *\t\t无\n * 返回：\n *\t\t无\n ****************************************/\nvoid move() {\n\t//读取用户操作前判断游戏是否结束\n\tfailCheck();\n\t//持续向下降落\n\twhile (1) {\n\t\t//清除方块\n\t        //to do\n\t\t//判断选择的方向\n\t\tif (_kbhit()) {\n\t\t\tint key = _getch();\n\t\t\tif (key == KEY_SPACE) {\n\t\t\t\t//to do\n\t\t\t}\n\t\t\telse if (key == KEY_UP) {\n\t\t\t\t//to do\n\t\t\t}\n\t\t\telse if (key == KEY_LEFT) {\n\t\t\t\t//to do\n\t\t\t}\n\t\t\telse if (key == KEY_RIGHT) {\n\t\t\t\t//to do\n\t\t\t}\n\t\t\telse if (key == KEY_DOWN) {\n\t\t\t\t//to do\n\t\t\t}\n\t\t}\n\t\t//绘制方块\n\t\t    //to do\n\t\t//休眠\n\t\t    //to do\n\t\t//方块的固化处理，方块固定后结束循环，当前一个方块的move执行完毕\n\t        //to do\n\t}\n}</code></pre>\n<h2 id=\"%E2%91%A6%E5%88%A4%E6%96%AD%E6%96%B9%E5%9D%97%E8%83%BD%E5%90%A6%E5%90%91%E6%8C%87%E5%AE%9A%E6%96%B9%E5%90%91%E7%A7%BB%E5%8A%A8%20moveable(%20)\">⑦判断方块能否向指定方向移动 moveable( )</h2>\n<p>当新方块刚从顶部绘制时就碰到了“固化”方块时则表明游戏结束，因此我们只需判断方块能否向下移动即可。这里先实现判断方块能否向指定方向移动功能。</p>\n<pre><code class=\"language-cpp\">/*****************************************\n  *功能：判断在指定位置向指定方向是否可以移动\n  *输入：\n  *\t\tx，y - 方块位置\n  *\t\tmoveDir - 下一步想要移动的方向\n  *\t\tblockDir - 当前方块的方向\n  * 返回：\n  *\t\ttrue - 可以移动\n  *\t\tfalse - 不可以移动\n  ****************************************/\nbool moveable(int x0, int y0, move_dir_t moveDir, block_dir_t blockDir) {\n\t//计算方块左上角在30×15的游戏区位置（第多少行， 第多少列）\n\tint x = (y0 - MinY) / UNIT_SIZE;\n\tint y = (x0 - MinX) / UNIT_SIZE;\n\tint ret = 1;\n\tint id = BlockIndex * 4 + blockDir;\n\tif (moveDir == MOVE_DOWN) {\n\t\tfor (int i = 0; i &lt; BLOCK_HEIGHT; ++i) {\n\t\t\tfor (int j = 0; j &lt; BLOCK_WIDTH; ++j) {\n\t\t\t\t//向下不能运动的条件：实心方块已经达到底部（x+i+1==30），或者底部已有方块\t\n\t\t\t\tif (block[id][i][j] == 1 &amp;&amp;\n\t\t\t\t\t(x + i + 1 == 30 || visit[x + i + 1][y + j] == 1)) {\n\t\t\t\t\tret = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse if (moveDir == MOVE_LEFT) {\n\t\tfor (int i = 0; i &lt; BLOCK_HEIGHT; ++i) {\n\t\t\tfor (int j = 0; j &lt; BLOCK_WIDTH; ++j) {\n\t\t\t\t//向左不能运动的条件：实心方块已经达到左边界(y+j==0),或者左边已有方块\n\t\t\t\tif (block[id][i][j] == 1 &amp;&amp;\n\t\t\t\t\t(y + j &lt;= 0 || visit[x + i][y + j - 1] == 1)) {\n\t\t\t\t\tret = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse if (moveDir == MOVE_RIGHT) {\n\t\tfor (int i = 0; i &lt; BLOCK_HEIGHT; ++i) {\n\t\t\tfor (int j = 0; j &lt; BLOCK_WIDTH; ++j) {\n\t\t\t\t//向下不能运动的条件：实心方块已经达到右边界（y+j+1&gt;=15)，或者右边已有方块\n\t\t\t\tif (block[id][i][j] == 1 &amp;&amp;\n\t\t\t\t\t(y + j + 1 &gt;= 15 || visit[x + i][y + j + 1] == 1)) {\n\t\t\t\t\tret = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n</code></pre>\n<h2 id=\"%E2%91%A7%E6%B8%B8%E6%88%8F%E5%A4%B1%E8%B4%A5%E6%A3%80%E6%9F%A5%C2%A0\">⑧游戏失败检查 failCheck( )</h2>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"352\" src=\"image\\1c4b536c8d134ab491caf42f4a1c51a3.png\" width=\"281\"/></p>\n<p> 游戏失败检测，当新绘制方块无法向下移动时则表明游戏失败。</p>\n<pre><code class=\"language-cpp\">/*****************************\n *功能：检测游戏是否结束\n *输入：\n *\t\t无\n * 返回：\n *\t\t无\n *****************************/\nvoid failCheck() {\n\t//游戏结束条件是顶部新被绘制出的方块就要“固化”，顶部新绘制的方块方向朝上，运动方向朝下\n\tif (!moveable(START_X, START_Y, MOVE_DOWN, (block_dir_t)BLOCK_UP)) {\n\t\tsetcolor(WHITE);\n\t\tsetfont(45, 0, \"隶体\");\n\t\touttextxy(75, 300, \"Game Over！\");\n\t\tSleep(1000);\n\t\tsystem(\"pause\");\n\t\tclosegraph();\n\t\texit(0);\n\t}\n}\n</code></pre>\n<h2 id=\"%E2%91%A8%E6%B8%85%E9%99%A4%E4%B8%8B%E9%99%8D%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E6%96%B9%E5%9D%97\">⑨清除下降过程中的方块 clearBlock( )</h2>\n<p>如果游戏未失败，则表明用户可以继续操作，在读取用户操作前要先将降落框内的方块清除。</p>\n<pre><code class=\"language-cpp\">/*****************************************\n * 功能：清除降落过程中的方块\n * 输入：\n *\t\tx,y - 方块的坐标（二维数组左上角位置）\n *\t\tblock_dir_t - 方块方向\n * 返回：\n *\t\t无\n ****************************************/\nvoid clearBlock(int x, int y, block_dir_t blockDir) {\n\tsetcolor(BLACK);\n\t//\tsetfont(23, 0, \"楷体\");\n\tint id = BlockIndex * 4 + blockDir;\n\tfor (int i = 0; i &lt; BLOCK_HEIGHT; ++i) {\n\t\tfor (int j = 0; j &lt; BLOCK_WIDTH; ++j) {\n\t\t\tif (block[id][i][j] == 1) {\n\t\t\t\tint x2 = x + j * UNIT_SIZE;\n\t\t\t\tint y2 = y + i * UNIT_SIZE;\n\t\t\t\touttextxy(x2, y2, \"■\");\n\t\t\t}\n\t\t}\n\t}\n}</code></pre>\n<h2 id=\"%E2%91%A9%E5%88%A4%E6%96%AD%E6%96%B9%E5%9D%97%E6%97%8B%E8%BD%AC%20rotatable(%20)\">⑩判断方块旋转 rotatable( )</h2>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"352\" src=\"https://img-blog.csdnimg.cn/912be43395df4adc8fa35279f03f6778.gif\" width=\"280\"/></p>\n<p> 如果方块在待转方向可以向下运动则表明方块可以旋转，因此这里只需少加利用moveable函数即可实现。</p>\n<pre><code class=\"language-cpp\">/*****************************************\n * 功能：判断当前方块是否可以向指定方向旋转\n * 输入：\n *\t\tx，y - 方块位置（二维数组坐标）\n *\t\tdir - 方块旋转方向\n * 返回：\n *\t\ttrue - 可以旋转\n *\t\tfalse - 不可以旋转\n ****************************************/\nbool rotatable(int x, int y, block_dir_t dir) {\n\t//首先判断是否可以继续向下移动\n\tif (!moveable(x, y, MOVE_DOWN, dir)) {\n\t\treturn false;\n\t}\n\tint x2 = (y - MinY) / UNIT_SIZE;\n\tint y2 = (x - MinX) / UNIT_SIZE;\n\tint id = BlockIndex * 4 + dir;\n\tfor (int i = 0; i &lt; BLOCK_HEIGHT; ++i) {\n\t\tfor (int j = 0; j &lt; BLOCK_WIDTH; ++j) {\n\t\t\t//不能旋转条件：左右边界越界或者已有方块“阻挡”\n\t\t\tif (block[id][i][j] == 1 &amp;&amp; (y2 + j &lt; 0 || y2 + j &gt;= 15 || visit[x2 + i][y2 + j] == 1)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}</code></pre>\n<h2 id=\"%E2%91%A0%E2%91%A0%E7%BB%98%E5%88%B6%E4%B8%8B%E9%99%8D%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E6%96%B9%E5%9D%97%20drawBlock(%20)\">①①绘制下降过程中的方块 drawBlock( )</h2>\n<p>  每次根据用户操作绘制新的方块</p>\n<pre><code class=\"language-cpp\">/*****************************************\n *功能：绘制下降过程中的方块\n *输入：\n *\t\tx,y - 方块的坐标（二维数组左上角位置）\n *\t\tblock_dir_t - 方块方向\n * 返回：\n *\t\t无\n ****************************************/\nvoid drawBlock(int x, int y, block_dir_t dir) {\n\tsetcolor(color[BlockIndex]);\n\tsetfont(23, 0, \"楷体\");\n\tint id = BlockIndex * 4 + dir;\n\tfor (int i = 0; i &lt; BLOCK_HEIGHT; ++i) {\n\t\tfor (int j = 0; j &lt; BLOCK_WIDTH; ++j) {\n\t\t\tif (block[id][i][j] == 1) {\n\t\t\t\t//擦除该方块的第i行第j列\n\t\t\t\touttextxy(x + j * UNIT_SIZE, y + i * UNIT_SIZE, \"■\");\n\t\t\t}\n\t\t}\n\t}\n}</code></pre>\n<h2 id=\"%E2%91%A0%E2%91%A1%E5%BB%B6%E6%97%B6%E7%AD%89%E5%BE%85%20wait%20(%20)\">①②延时等待 wait ( )</h2>\n<p>每次 处理完用户操作后会进入延时等待，等待时长会根据当前方块降落速度而定，在延时等待期间如果检测到用户有按键操作时则会结束等待。</p>\n<pre><code class=\"language-cpp\">/**************************\n * 功能：延时等待\n * 输入：\n *\n * 返回：\n *\t\t无\n *************************/\nvoid wait(int interval) {\n\tint count = interval / 10;\n\tfor (int i = 0; i &lt; count; ++i) {\n\t\tSleep(10);\n\t\t//如果休眠期间用户有按键，则结束休眠\n\t\tif (_kbhit()) {\n\t\t\treturn;\n\t\t}\n\t}\n}</code></pre>\n<h2 id=\"%E2%91%A0%E2%91%A2%E5%9B%BA%E5%AE%9A%E6%96%B9%E5%9D%97%20mark(%20)\">①③固定方块 mark( )</h2>\n<p>  每次绘制出新方块后判断方块是否还能继续移动，如果不能移动则表明方块需要固化。</p>\n<pre><code class=\"language-cpp\">/*****************************************\n * 功能：方块固定\n * 输入：\n *\t\tx,y - 方块坐标\n *\t\tdir - 方块朝向\n * 返回：\n *\t\t无\n ****************************************/\nvoid mark(int x, int y, block_dir_t dir) {\n\tint id = BlockIndex * 4 + dir;\n\tint x2 = (y - MinY) / UNIT_SIZE;\n\tint y2 = (x - MinX) / UNIT_SIZE;\n\tfor (int i = 0; i &lt; BLOCK_HEIGHT; ++i) {\n\t\tfor (int j = 0; j &lt; BLOCK_WIDTH; ++j) {\n\t\t\tif (block[id][i][j] == 1) {\n\t\t\t\tvisit[x2 + i][y2 + j] = 1;\n\t\t\t\tmarkColor[x2 + i][y2 + j] = color[BlockIndex];\n\t\t\t}\n\t\t}\n\t}\n}</code></pre>\n<h2 id=\"%E2%91%A0%E2%91%A3%E7%94%A8%E6%88%B7%E6%93%8D%E4%BD%9C%E6%A1%86%E6%9E%B6%E5%AE%8C%E5%96%84%E2%85%A1%20mov(%20)\">①④用户操作框架完善Ⅱ mov( )</h2>\n<p>将上述实现功能补充到操作框架中</p>\n<pre><code class=\"language-cpp\">void move() {\n\tint x = START_X;\t//方块起始位置\n\tint y = START_Y;\n\tint k = 0;\n\tblock_dir_t blockDir = (block_dir_t)BLOCK_UP;\n\tint curSpeed = speed;\t//定义当前方块降落速度\n\t//读取用户操作前判断游戏是否结束\n\tfailCheck();\n\t//持续向下降落\n\twhile (1) {\n\t\tint curSpeed = speed;\t//定义当前方块降落速度\n\t\t//清除方块\n\t\tclearBlock(x, k + y, blockDir);\n\t\t//判断选择的方向\n\t\tif (_kbhit()) {\n\t\t\tint key = _getch();\n\t\t\tif (key == KEY_SPACE) {\n\t\t\t\tsystem(\"pause\");\n\t\t\t}\n\t\t\telse if (key == KEY_UP) {\n\t\t\t\tblock_dir_t nextDir = (block_dir_t)((blockDir + 1) % 4);\n\t\t\t\tif (rotatable(x, y + k, nextDir)) {\n\t\t\t\t\tblockDir = nextDir;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (key == KEY_LEFT) {\n\t\t\t\tif (moveable(x, y + k + 20, MOVE_LEFT, blockDir)) {\n\t\t\t\t\tx -= UNIT_SIZE;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (key == KEY_RIGHT) {\n\t\t\t\tif (moveable(x, y + k + 20, MOVE_RIGHT, blockDir)) {\n\t\t\t\t\tx += UNIT_SIZE;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (key == KEY_DOWN) {\n\t\t\t\tcurSpeed = 50;\n\t\t\t}\n\t\t}\n\t\tk += 20;\n\t\t//绘制方块\n\t\tdrawBlock(x, y + k, blockDir);\n\t\t//休眠\n\t\twait(curSpeed);\n\t\t//方块的固化处理，方块固定后结束循环，当前一个方块的move执行完毕\n\t\tif (!moveable(x, y + k, MOVE_DOWN, blockDir)) {\n\t\t\tmark(x, y + k, blockDir);\n\t\t\tbreak;\n\t\t}\n\t}\n}</code></pre>\n<h2 id=\"%E2%91%A0%E2%91%A4%E6%B6%88%E9%99%A4%E6%96%B9%E5%9D%97\">①⑤消除方块 check( ) + down( )</h2>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"352\" src=\"https://img-blog.csdnimg.cn/a8435cd5a1354c7b82eac4533b0327db.gif\" width=\"280\"/></p>\n<p> 当对一个方块下降操作结束后，在已固化方块数组里查找“满行”方块，如果存在“满行”方块则要进行清除操作，接着更新用户分数和等级。</p>\n<p>g</p>\n<pre><code class=\"language-cpp\">/*************************\n * 功能：检查是否有满行方块\n * 输入：\n *\t\t无\n * 返回：\n *\t\t无\n *************************/\nvoid check() {\n\tint i, j;\n\tint clearLines = 0;\n\tfor (i = 29; i &gt;= 0; i--) {\n\t\t// 检查第i行有没有满\n\t\tfor (j = 0; j &lt; 15 &amp;&amp; visit[i][j]; j++);\n\t\t//执行到此处时，有两种情况：\n\t\t// 1. 第i行没有满，即表示有空位 此时 j&lt;15\n\t\t// 2. 第i行已满了，此时 j&gt;=15\n\t\tif (j &gt;= 15) {\n\t\t\t// 此时，第i行已经满了，就需要消除第i行\n\t\t\tdown(i);  //消除第i行，并把上面的行都下移\n\t\t\ti++;  // 因为最外层的循环中有 i--, 所以我们先i++, 使得下次循环时，再把这一行检查一下\n\t\t\tclearLines++;\n\t\t}\n\t}\n\t// 更新分数\n\taddScore(clearLines);\n\n\t// 更新等级(更新等级提示，更新速度）\n\tupdateGrade();\n}\n\n/*****************************************\n * 功能：消除第i行，并把上面的行都往下移\n * 输入：\n *\t\t无\n * 返回：\n *\t\t无\n ****************************************/\nvoid down(int x) {\n\tfor (int i = x; i &gt; 0; --i) {\n\t\tfor (int j = 0; j &lt; 15; ++j) {\n\t\t\tif (visit[i - 1][j] == 1) {\n\t\t\t\tvisit[i][j] = 1;\n\t\t\t\tmarkColor[i][j] = markColor[i - 1][j];\n\t\t\t\tsetcolor(markColor[i][j]);\n\t\t\t\touttextxy(20 * j + MinX, 20 * i + MinY, \"■\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvisit[i][j] = 0;\n\t\t\t\tsetcolor(BLACK);\n\t\t\t\touttextxy(20 * j + MinX, 20 * i + MinY, \"■\");\n\t\t\t}\n\t\t}\n\t}\n\t//清除最顶层方格\n\tsetcolor(BLACK);\n\tfor (int j = 0; j &lt; 15; ++j) {\n\t\tvisit[0][j] = 0;\n\t\touttextxy(20 * j + MinX, MinY, \"■\");\n\t}\n}\n</code></pre>\n<h2 id=\"%E2%91%A0%E2%91%A5%E6%9B%B4%E6%96%B0%E5%88%86%E6%95%B0%E5%92%8C%E7%AD%89%E7%BA%A7\">①⑥更新分数和等级 addScore( ) + updateGrade( )</h2>\n<p> 根据清除方块行数更新用户分数和等级。</p>\n<pre><code class=\"language-cpp\">/*****************************************\n * 功能：更新分数\n * 输入：\n *\t\t无\n * 返回：\n *\t\t无\n ****************************************/\nvoid addScore(int lines) {\n\tchar str[32];\n\tscore += lines * 10;\n\tsprintf_s(str, 32, \"%d\", score);\n\tsetcolor(RED);\n\touttextxy(415, 310, str);\n\n}\n\n/*************************\n * 功能：更新等级\n * 输入：\n *\t\t无\n * 返回：\n *\t\t无\n *************************/\nvoid updateGrade() {\n\t//更新等级\n\t//假设50分一级\n\trank = score / 50;\n\tchar str[32];\n\tsprintf_s(str, 32, \"%d\", rank);\n\tsetcolor(RED);\n\touttextxy(415, 405, str);\n\t//更新速度\n\tif (speed &lt;= 100) {\n\t\tspeed = 100;\n\t}\n\telse {\n\t\tspeed = 500 - rank * 20;\n\t}\n}</code></pre>\n<h1 id=\"%C2%A0%E4%BB%A3%E7%A0%81%E6%95%B4%E5%90%88%E8%BF%90%E8%A1%8C\"> 代码整合运行</h1>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/bf51f30efbd849e999b7077142c57074.gif\"/></p>\n<h1>如果大家对这类小游戏文章刚兴趣，小编又为大家准备了一篇推箱子游戏，欢迎大家浏览<a class=\"link-info\" href=\"https://blog.csdn.net/qq_54169998/article/details/122980890?spm=1001.2014.3001.5501\" title=\"C语言实现推箱子游戏\">C语言实现推箱子游戏</a></h1>\n<h1 id=\"%E4%BA%94%20%E3%80%81%E4%B8%8D%E8%B6%B3%E4%B9%8B%E5%A4%84\">五 、不足之处</h1>\n<ol><li>使用easyX绘图，导入游戏图片，从而使得游戏效果更为逼真</li><li>游戏战绩的保存</li><li>操作控制略有卡顿 </li></ol>\n</div>\n</div>"}