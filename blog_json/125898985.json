{"blogid": "125898985", "writerAge": "码龄6年", "writerBlogNum": "76", "writerCollect": "355", "writerComment": "334", "writerFan": "856", "writerGrade": "5级", "writerIntegral": "2532", "writerName": "木秀林", "writerProfileAdress": "writer_image\\profile_125898985.jpg", "writerRankTotal": "8183", "writerRankWeekly": "868", "writerThumb": "351", "writerVisitNum": "65652", "blog_read_count": "1145", "blog_time": "已于 2022-08-12 10:13:23 修改", "blog_title": "【面试专栏】第八篇：Java基础:集合篇-集合总结、集合工具类", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-light\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p></p>\n<div class=\"toc\">\n<h3>文章目录</h3>\n<ul><li><ul><li><a href=\"#_3\">集合对比&amp;选择</a></li><li><a href=\"#javautilCollections_30\">集合工具java.util.Collections</a></li><li><ul><li><a href=\"#_32\">列表排序（指定顺序）</a></li><li><a href=\"#_41\">列表快速查询下标</a></li><li><a href=\"#_50\">反转列表</a></li><li><a href=\"#_54\">随机打乱列表</a></li><li><a href=\"#_61\">交换指定列表两个元素位置</a></li><li><a href=\"#list_66\">填充list</a></li><li><a href=\"#_71\">拷贝集合（对元素而言是拷贝引用）</a></li><li><a href=\"#_74\">最大、最小值</a></li><li><a href=\"#_83\">集合出现次数（统计集合内元素的频次）</a></li><li><a href=\"#map_set_89\">map 转set</a></li><li><a href=\"#nn_92\">整体移动前n个元素到集合后面（或者后n个到前面）</a></li><li><a href=\"#_99\">不可变包装（用于集合元素固定不可修改）</a></li><li><a href=\"#_113\">同步集合包装(用于生成线程安全集合)</a></li><li><a href=\"#new__null_new__211\">单元素集合包装（避免new 集合返回）/空集合包装 (避免反回null 或者new 集合)</a></li></ul>\n</li><li><a href=\"#javautilArrayssort_227\">探索java.util.Arrays#sort排序算法</a></li></ul>\n</li></ul>\n</div>\n<p></p>\n<h2><a id=\"_3\"></a>集合对比&amp;选择</h2>\n<p>通过前面几天的集合文章：</p>\n<ul><li><a href=\"https://blog.csdn.net/qq_35530042/article/details/125792585\">【面试专栏】第三篇：Java基础:集合篇-List、Queue</a></li><li><a href=\"https://blog.csdn.net/qq_35530042/article/details/125860028\">【面试专栏】第四篇：Java基础:集合篇-Map、HashMap、Hashtable</a></li><li><a href=\"https://blog.csdn.net/qq_35530042/article/details/125898794\">【面试专栏】第五篇：Java基础:集合篇-LinkedHashMap、ConcurrentHashMap、TreeMap</a></li><li><a href=\"https://blog.csdn.net/qq_35530042/article/details/125922677\">【面试专栏】第六篇：Java基础:集合篇-HashSet、TreeSet</a></li><li><a href=\"https://blog.csdn.net/qq_35530042/article/details/125922689\">【面试专栏】第七篇：Java基础:集合篇-LinkedHashSet、BitSet、CopyOnWriteArraySet</a></li></ul>\n<p>简单总结回顾一下：</p>\n<p>Map 接口和 Collection 接口是所有集合框架的父接口；<br/> Collection 接口的子接口包括：Set 接口、List 接口和Queue接口；<br/> Map 接口的实现类主要有：HashMap、TreeMap、LinkedHashMap、Hashtable、ConcurrentHashMap 以及 Properties 等；<br/> Set 接口的实现类主要有：HashSet、TreeSet、LinkedHashSet 等；<br/> List 接口的实现类主要有：ArrayList、LinkedList、Stack 、Vector以及CopyOnWriteArrayList 等；<br/> Queue接口的主要实现类有：ArrayDeque、ArrayBlockingQueue、LinkedBlockingQueue、PriorityQueue等；</p>\n<ul><li>有序选择List 、无序去重选择Set</li><li>有序选择TreeMap、无序选择HashMap</li><li>线程安全有：Vector、Stack、CopyOnWriteArrayList、Hashtable、ConcurrentHashMap、CopyOnWriteArraySet</li><li>线程安全优先选择：CopyOnWriteArrayList、CopyOnWriteArraySet、ConcurrentHashMap</li></ul>\n<p>今天再介绍一种新的方式集合工具类实现线程安全。</p>\n<h2><a id=\"javautilCollections_30\"></a>集合工具java.util.Collections</h2>\n<h3><a id=\"_32\"></a>列表排序（指定顺序）</h3>\n<p>需要注意<code>列表如果为空会npe</code> , 内部使用的其实是java.util.Arrays#sort，这个在后面单独介绍</p>\n<ul><li>java.util.Collections#sort(java.util.List) 默认排序</li><li>java.util.Collections#sort(java.util.List, java.util.Comparator&lt;? super T&gt;) 带参数，可以指定排序类（这里也是和jdk8 lambda 结合后很便捷的点）</li></ul>\n<h3><a id=\"_41\"></a>列表快速查询下标</h3>\n<p>通过jdk封装的快速查询元素所在位置</p>\n<ul><li>java.util.Collections#binarySearch(java.util.List&lt;? extends java.lang.Comparable&lt;? super T&gt;&gt;, T)</li><li>java.util.Collections#binarySearch(java.util.List&lt;? extends T&gt;, T, java.util.Comparator&lt;? super T&gt;)</li></ul>\n<h3><a id=\"_50\"></a>反转列表</h3>\n<ul><li>java.util.Collections#reverse</li></ul>\n<h3><a id=\"_54\"></a>随机打乱列表</h3>\n<p>一些需要随机展示的场景需要打乱列表</p>\n<ul><li>java.util.Collections#shuffle(java.util.List&lt;?&gt;)</li></ul>\n<h3><a id=\"_61\"></a>交换指定列表两个元素位置</h3>\n<ul><li>java.util.Collections#swap(java.util.List&lt;?&gt;, int, int)</li></ul>\n<h3><a id=\"list_66\"></a>填充list</h3>\n<p>将指定元素填充满列表</p>\n<ul><li>java.util.Collections#fill</li></ul>\n<h3><a id=\"_71\"></a>拷贝集合（对元素而言是拷贝引用）</h3>\n<ul><li>java.util.Collections#copy</li></ul>\n<h3><a id=\"_74\"></a>最大、最小值</h3>\n<p>内部循环一遍根据排序找出最大最小返回</p>\n<ul><li>java.util.Collections#min(java.util.Collection&lt;? extends T&gt;)</li><li>java.util.Collections#min(java.util.Collection&lt;? extends T&gt;, java.util.Comparator&lt;? super T&gt;)</li><li>java.util.Collections#max(java.util.Collection&lt;? extends T&gt;)</li><li>java.util.Collections#max(java.util.Collection&lt;? extends T&gt;, java.util.Comparator&lt;? super T&gt;)</li></ul>\n<h3><a id=\"_83\"></a>集合出现次数（统计集合内元素的频次）</h3>\n<p>可以统计null的次数</p>\n<ul><li>java.util.Collections#frequency</li></ul>\n<h3><a id=\"map_set_89\"></a>map 转set</h3>\n<ul><li>java.util.Collections#newSetFromMap</li></ul>\n<h3><a id=\"nn_92\"></a>整体移动前n个元素到集合后面（或者后n个到前面）</h3>\n<p>当distance为正数时，将List集合的后distance个元素“整体”移到前面；当distance为负数时，将list集合的前distance个元素“整体”移到后边。该方法不会改变集合的长度。</p>\n<ul><li>java.util.Collections#rotate</li></ul>\n<h3><a id=\"_99\"></a>不可变包装（用于集合元素固定不可修改）</h3>\n<p>所有类型的集合都封装了一个对应的方法，实现原理就是内部<code>实现了一个集合的方法，调用修改集合修改方法抛出异常</code></p>\n<p><code>所以对于集合内对象的值是可以修改的，集合与对象的引用是不允许修改了</code></p>\n<ul><li>java.util.Collections#unmodifiableCollection</li><li>java.util.Collections#unmodifiableSet</li><li>java.util.Collections#unmodifiableSortedSet</li><li>java.util.Collections#unmodifiableList</li><li>java.util.Collections#unmodifiableMap</li><li>…</li></ul>\n<h3><a id=\"_113\"></a>同步集合包装(用于生成线程安全集合)</h3>\n<p>生成一个线程安全的集合对象，实现原理就是内部<code>实现了一个集合的同步方法，同步类就是集合自身引用，调用修改方法时 使用synchronized 锁住自身对象</code></p>\n<p>拿一个举例</p>\n<pre><code>\n /**\n     * @serial include\n     */\n    static class SynchronizedCollection&lt;E&gt; implements Collection&lt;E&gt;, Serializable {\n        private static final long serialVersionUID = 3053995032091335093L;\n\n        final Collection&lt;E&gt; c;  // Backing Collection\n        final Object mutex;     // Object on which to synchronize\n\n        SynchronizedCollection(Collection&lt;E&gt; c) {\n            this.c = Objects.requireNonNull(c);\n            mutex = this;\n        }\n\n        SynchronizedCollection(Collection&lt;E&gt; c, Object mutex) {\n            this.c = Objects.requireNonNull(c);\n            this.mutex = Objects.requireNonNull(mutex);\n        }\n\n        public int size() {\n            synchronized (mutex) {return c.size();}\n        }\n        public boolean isEmpty() {\n            synchronized (mutex) {return c.isEmpty();}\n        }\n        public boolean contains(Object o) {\n            synchronized (mutex) {return c.contains(o);}\n        }\n        public Object[] toArray() {\n            synchronized (mutex) {return c.toArray();}\n        }\n        public &lt;T&gt; T[] toArray(T[] a) {\n            synchronized (mutex) {return c.toArray(a);}\n        }\n\n        public Iterator&lt;E&gt; iterator() {\n            return c.iterator(); // Must be manually synched by user!\n        }\n\n        public boolean add(E e) {\n            synchronized (mutex) {return c.add(e);}\n        }\n        public boolean remove(Object o) {\n            synchronized (mutex) {return c.remove(o);}\n        }\n\n        public boolean containsAll(Collection&lt;?&gt; coll) {\n            synchronized (mutex) {return c.containsAll(coll);}\n        }\n        public boolean addAll(Collection&lt;? extends E&gt; coll) {\n            synchronized (mutex) {return c.addAll(coll);}\n        }\n        public boolean removeAll(Collection&lt;?&gt; coll) {\n            synchronized (mutex) {return c.removeAll(coll);}\n        }\n        public boolean retainAll(Collection&lt;?&gt; coll) {\n            synchronized (mutex) {return c.retainAll(coll);}\n        }\n        public void clear() {\n            synchronized (mutex) {c.clear();}\n        }\n        public String toString() {\n            synchronized (mutex) {return c.toString();}\n        }\n        // Override default methods in Collection\n        @Override\n        public void forEach(Consumer&lt;? super E&gt; consumer) {\n            synchronized (mutex) {c.forEach(consumer);}\n        }\n        @Override\n        public boolean removeIf(Predicate&lt;? super E&gt; filter) {\n            synchronized (mutex) {return c.removeIf(filter);}\n        }\n        @Override\n        public Spliterator&lt;E&gt; spliterator() {\n            return c.spliterator(); // Must be manually synched by user!\n        }\n        @Override\n        public Stream&lt;E&gt; stream() {\n            return c.stream(); // Must be manually synched by user!\n        }\n        @Override\n        public Stream&lt;E&gt; parallelStream() {\n            return c.parallelStream(); // Must be manually synched by user!\n        }\n        private void writeObject(ObjectOutputStream s) throws IOException {\n            synchronized (mutex) {s.defaultWriteObject();}\n        }\n    }\n\n</code></pre>\n<h3><a id=\"new__null_new__211\"></a>单元素集合包装（避免new 集合返回）/空集合包装 (避免反回null 或者new 集合)</h3>\n<p>这两种我认为是一种更优雅、更高性能（避免了创建很多个集合）的写法，但是需要注意在上层使用的时候<code>不能直接添加元素，不然会抛出异常</code>。</p>\n<p>单元素集合实现了集合方法，内部只保存一个元素</p>\n<ul><li>java.util.Collections#singleton</li><li>java.util.Collections#singletonList</li><li>java.util.Collections#singletonMap</li></ul>\n<p>空集合实现了集合方法，内部不存储元素，同时设置了静态变量，全局只有一个空集合</p>\n<ul><li>java.util.Collections#emptySet</li><li>java.util.Collections#emptyMap</li><li>…</li></ul>\n<h2><a id=\"javautilArrayssort_227\"></a>探索java.util.Arrays#sort排序算法</h2>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}