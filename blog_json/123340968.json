{"blogid": "123340968", "writerAge": "码龄9年", "writerBlogNum": "2", "writerCollect": "10", "writerComment": "0", "writerFan": "2", "writerGrade": "1级", "writerIntegral": "27", "writerName": "tangkaixuan_", "writerProfileAdress": "writer_image\\profile_123340968.jpg", "writerRankTotal": "207948", "writerRankWeekly": "432901", "writerThumb": "6", "writerVisitNum": "2305", "blog_read_count": "2270", "blog_time": "已于 2022-03-24 08:58:56 修改", "blog_title": "C# 调用Qt 库", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>因公司大部分底层库使用的Qt 开发，领导计划应用层用C# 而算法层用C++或者Qt，这就出现了混合编程的方式，现对C#的平台调用做一下总结。</p>\n<p>公共语音运行库提供了一系列能够使托管代码与非托管代码进行交互的解决方案</p>\n<p>主要包含三类互操作技术:</p>\n<p>1. 平台调用(P/Invoke):主要用于处理在托管代码中调用C库函数以及Win32 API 函数等非托管函数情形。</p>\n<p>2.C++ Interop：适用在托管代码与C++ 类库、核心算法库之间进行高效、灵活的互操作过程。</p>\n<p>3.COM Interop：该技术用于处理托管代码与COM之间的交互过程。</p>\n<p>注:以上参考&lt;&lt;精通.NET 互操作:P/Invoke,C++ Interop和COM Interop&gt;&gt; 黄际洲。</p>\n<p>此文章采用<strong>方案2</strong> 实现C# 对Qt 库的调用。</p>\n<p>因为Qt 中的信号和槽机制是无法通过CLR C++直接封装的(原因1:CLR C++ 继承的Object，Qt 中的类大部分继承QObject,CLR C++不支持多继承，所以无法将Qt信号和槽转换为 委托的形式，CLR C++可以封装没有使用信号和槽的Qt类,但是为了结构上统一不建议这样做)</p>\n<p>调用过程:</p>\n<p>1. 一般C# 调用 C++ 情况</p>\n<p>C# ------&gt; 托管 C++-----&gt;非托管C++</p>\n<p>2. C# 调用Qt</p>\n<p>C#----&gt;托管C++---&gt;非托管C++---&gt;Qt</p>\n<p>故 C# 调用Qt 多了一层 通过非托管C++ 封装Qt的过程(此过程主要是为了屏蔽Qt的信号和槽，将信号和槽转换为C++中的回调)</p>\n<p>下面正式开始封装演示，以加法运算为例 (此文章需要对Qt 、C# 环境搭建及开发有一定基础)</p>\n<p>实验环境:</p>\n<p>Windows10 、VS2019、Qt 5.14。</p>\n<p>1. 在 VS中新建 Qt项目 “MathHelper”,并创建 MathHelper 导出类，在头文件定义int Add(int data1,int data2);函数，并在cpp 文件中实现。</p>\n<p></p>\n<p><img alt=\"\" height=\"1030\" src=\"image\\97efb6ab876740f7a1f948943608d3e2.png\" width=\"1200\"/></p>\n<p>使MathHelper继承至QObject，并添加Q_OBJECT宏。</p>\n<p><img alt=\"\" height=\"395\" src=\"image\\4dcc33bbdcfd4a38807d64c9c0e1521f.png\" width=\"791\"/></p>\n<p></p>\n<p></p>\n<p></p>\n<p>说明:</p>\n<p>用途: 此项目用于模拟已存在的Qt库。</p>\n<p>2. 在VS中新建 Qt项目 “MathHelperWrapper”，并创建 MathHelperStdWrapper 导出类（如果创建项目过程中默认创建了\"MathHelperWrapper.h/cpp\"等文件建议将其重新命名为MathHelperStdWrapper ）。</p>\n<p><img alt=\"\" height=\"627\" src=\"image\\f824ed4c7a1a495eb08f26c27c048489.png\" width=\"1043\"/></p>\n<p></p>\n<p><img alt=\"\" height=\"1012\" src=\"image\\4ced804752cc4b3bb1d0b1b4444c6a29.png\" width=\"1200\"/></p>\n<p></p>\n<p>项目右键-&gt;高级-&gt;公共语言运行时支持-&gt; 选择\"公共语言运行时支持(clr)\"</p>\n<p></p>\n<p><img alt=\"\" height=\"558\" src=\"image\\db19058267c14eb5b88ca97fe80c3d58.png\" width=\"793\"/></p>\n<p>C/C++--&gt;语言--&gt;符合模式--&gt;否。</p>\n<p><img alt=\"\" height=\"548\" src=\"image\\210269a3875f46d7b8db8fdbc7766e94.png\" width=\"791\"/></p>\n<p></p>\n<p>选择MathHelperWrapper.cpp 右键 C/C++-&gt;常规--&gt;公共语言运行时支持-&gt;选择\"无公共语言运行时支持\"，此类的主要作用是将Qt转换为标准C++ 所以不需要CLR支持。</p>\n<p><img alt=\"\" height=\"930\" src=\"image\\a267c7f4052d4d88977533b5f3e5d561.png\" width=\"1200\"/></p>\n<p>在此项目新建 MathHelperCLRWrapper类，并设置为公开类。</p>\n<p><img alt=\"\" height=\"785\" src=\"image\\118e3521d17e492e84341311264066bc.png\" width=\"817\"/></p>\n<p></p>\n<p><img alt=\"\" height=\"174\" src=\"image\\7533e95a407a4c3bae020643f26eb471.png\" width=\"603\"/></p>\n<p></p>\n<p> 分别在 MathHelperStdWrapper  MathHelperCLRWrapper 类中创建 Add方法的封装以及 MathHelper MathHelperStdWrapper 对象指针，见图</p>\n<p><img alt=\"\" height=\"368\" src=\"image\\64a71a6c54af478790c05bd7d5ba56da.png\" width=\"659\"/></p>\n<p> <img alt=\"\" height=\"278\" src=\"image\\153d270f3ba4450bbc4cd2eef2b99853.png\" width=\"659\"/></p>\n<p> 在cpp文件构造函数中创建对应的对象，以及Add函数的封装。</p>\n<p><img alt=\"\" height=\"351\" src=\"image\\e8eca3c913414006a4ef128608b6daa6.png\" width=\"677\"/></p>\n<p><img alt=\"\" height=\"357\" src=\"image\\a251be2fe9774d8899dccf4075f81157.png\" width=\"721\"/></p>\n<p></p>\n<p>说明:</p>\n<p>此项目主要完成了Qt到CLR C++ 的转换(C# 是可以直接调用CLR C++的)。</p>\n<p>..StdWrapper 代表了标准C++（非托管）封装，...CLRWrapper 代表了CLR封装。</p>\n<p>此程序集完成了Qt 到CLR C++ 转换，其中包含两个过程</p>\n<p>a. Qt--&gt;标准C++（MathHelperStdWrapper  类）</p>\n<p>b. 标准C++-&gt;CLR C++。（MathHelperCLRWrapper  类）</p>\n<p>这两个转换过程分别放置于同一项目不同类中，其实也可以放置在两个不同项目中(一个项目用于Qt到标准C++的转换，另外一个项目用于标准C++到CLR C++ )</p>\n<p>此项目开始创建时选择Qt项目(而不是标准C++等)是因为1. 在Qt-&gt;标准C++转换过程中依然会用到Qt的头文件等，所以这样创建以后就默认包含了Qt头文件和库文件路径，无需在手动添加，2.使用Qt 的编译环境编译标准C++</p>\n<p></p>\n<p>----------------------20220307：23：03-----------------------未完待续</p>\n<p>3. 新建C#控制台项目MathHelperDemo</p>\n<p><img alt=\"\" height=\"979\" src=\"image\\4261bab72d9b485b8e23bcbf93fa532c.png\" width=\"1200\"/></p>\n<p> 在项目引用中右键添加引用，选择MathHelperWrapper</p>\n<p><img alt=\"\" height=\"608\" src=\"image\\c6e8261b3b724a0ba12bd59627aa28c6.png\" width=\"943\"/></p>\n<p></p>\n<p>在 main函数中添加测试代码:</p>\n<p><img alt=\"\" height=\"312\" src=\"image\\4a4120a6469946499e83bde754d1d897.png\" width=\"955\"/></p>\n<p></p>\n<p>4.编译解决方案</p>\n<p>5.将 MathHelper 编译好的dll放置于MathHelperDemo运行目录下(否则会报dll找不到情况)</p>\n<p>如图:<img alt=\"\" height=\"331\" src=\"image\\bcc51057fb1a4828bc6cce9a35c4a573.png\" width=\"502\"/></p>\n<p></p>\n<p>7.运行</p>\n<p><img alt=\"\" height=\"136\" src=\"image\\40a76b3826a04c1ea302c8dc2a5b85e8.png\" width=\"659\"/></p>\n<p>测试成功。</p>\n<p></p>\n<p>此项目建立了一个调用过程的简单结构</p>\n<p>下一步计划:</p>\n<p>1.增加信号和槽封装过程</p>\n<p>2.梳理常见数据类型了转换过程(字符串、数组、指针、引用)</p>\n<p>3.CLR C++ 不支持标准C++ 多线程问题。</p>\n<p></p>\n<p></p>\n<p>注:<br/> 测试过程中出现了一个问题</p>\n<p><img alt=\"\" height=\"304\" src=\"image\\3f1793d0332e4b528fc6a28393b95268.png\" width=\"540\"/></p>\n<p>这是因为在编译时C++ 与C# 选择的CPU平台类型不一致导致的，将平台统一改为x64或者x32 统一就可以了</p>\n<p></p>\n<p><img alt=\"\" height=\"509\" src=\"image\\de36dd4df23143ef9372f5ca2e1735f5.png\" width=\"707\"/></p>\n<p></p>\n<p>代码连接</p>\n<p>链接：https://pan.baidu.com/s/12hOj26tRvktXM9jM4_5ucA<br/> 提取码：vjx7</p>\n</div>\n</div>"}