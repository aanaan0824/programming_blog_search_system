{"blogid": "126482914", "writerAge": "码龄1年", "writerBlogNum": "19", "writerCollect": "14", "writerComment": "13", "writerFan": "83", "writerGrade": "3级", "writerIntegral": "620", "writerName": "雾远望", "writerProfileAdress": "writer_image\\profile_126482914.jpg", "writerRankTotal": "30426", "writerRankWeekly": "5684", "writerThumb": "414", "writerVisitNum": "4102", "blog_read_count": "269", "blog_time": "于 2022-08-25 14:24:53 发布", "blog_title": "Session会话追踪的实现机制", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h1>前言</h1>\n<p>         HTTP协议是一个无状态协议，什么是无状态协议呢？  Web应用程序无法区分收到的不同的HTTP请求是否是同一个浏览器发出的。</p>\n<p>        在Web应用程序中，Servlet和客户的通信采用“请求/响应”的模式。那服务器又是如何分别不同用户的呢？例如：当一个用户登录成功后，如果他继续访问其他页面，Web程序如何才能识别出该用户身份？   </p>\n<p>        为了跟踪用户状态， Servlet容器提供了Session机制用以跟踪用户。服务器可以向浏览器分配一个唯一ID，并以Cookie的形式发送到浏览器，浏览器在后续访问时总是附带此Cookie，这样，服务器就可以识别用户身份。</p>\n<h1>什么是Session机制？</h1>\n<p>        Session相当于程序在服务器上建立的一份客户档案，当程序需要为某个客户端的请求创建一个Session时，服务器首先检查这个客户端的请求里是否包含了一个Session标识(即SessionId),如果已经包含一个sessionId则说明以前已经为此客户创建过Session，服务器就按照SessionId把这个Session检索出来使用。如果客户请求不包含sessionId，会自动获得一个Session ID。并本次响应中返回给客户端保存。<br/><br/>         我们把这种基于唯一ID识别用户身份的机制称为Session。如果用户在一段时间内没有访问服务器，那么Session会自动失效，下次即使带着上次分配的Session ID访问，服务器也认为这是一个新用户，会分配新的Session ID。一次Session会话中往往包含着若干次request请求。</p>\n<p><br/>         JavaEE的Servlet机制内建了对Session的支持。当我们需要获取Session时，可以通过request请求对象的getSession()方法。例如；</p>\n<pre><code class=\"language-java\">HttpSession session=request.getSession();</code></pre>\n<p><br/><br/> 服务器识别Session的关键就是依靠一个名为JSESSIONID的Cookie。在Servlet中第一次调用request.getSession()时，Servlet容器自动创建一个Session ID，然后通过一个名为JSESSIONID的Cookie发送给浏览器：</p>\n<p>例如运行如下代码：</p>\n<pre><code class=\"language-java\">@WebServlet(\"/text_session.do\")\npublic class TextSessionServlet extends HttpServlet {\n\t@Override\n\tprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n\t\tSystem.out.println(\"TextSessionServlet被GET到\");\n\t\n\t\t// 第一次在访问Session时，服务器会创建Session\n\t\t// 并根据Session_ID,创建一个名称为\"JSESSIONID\"的Cookie,将Session_ID保存在Cookie\n\t\t// 将该Cookie响应回至浏览器保存\n\t\t// 接下来的每次发起请求时，客户端浏览器都会在请求中，添加JESSIONID\n\t\t// 用于服务器确认\"身份\"\n\t\tHttpSession session =req.getSession();\n\t\tSystem.out.println(session.getId());\n\t}\n}</code></pre>\n<p>控制台结果：</p>\n<p><img alt=\"\" height=\"539\" src=\"image\\f526ef4920fe4300bbcf63754cacec38.png\" width=\"1166\"/> 网页请求头所在第一次创建Session返回JSESSIONID：</p>\n<p><img alt=\"\" height=\"814\" src=\"image\\322c8cc5e26f4d9bbf41b9bc5eff576a.png\" width=\"1200\"/></p>\n<p></p>\n<h1><br/> Cookie</h1>\n<p>        实际上，Servlet提供的HttpSession本质上就是通过一个名为JSESSIONID的Cookie来跟踪用户会话的。除了这个名称外，其他名称的Cookie我们可以任意使用。<br/>         创建一个新Cookie时，除了指定名称和值以外，通常需要设置setPath(\"/\")，浏览器根据此前缀决定是否发送Cookie。如果一个Cookie调用了setPath(\"/user/\")，那么浏览器只有在请求以/user/开头的路径时才会附加此Cookie。通过setMaxAge()设置Cookie的有效期，单位为秒，最后通过resp.addCookie()把它添加到响应。<br/>         通过创建Cookie，我们可以实现在客户端浏览器中存储数据的目的，例如保存用户名和密码。在Chrome浏览器中，单个 Cookie的长度不能超过 4069 个字符（包括 name，但不包括 = 号）。<br/> 我们可以在浏览器看到服务器发送的Cookie，以百度为例：</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\c6231d8e0799bd03c035d774d5ef3c46.png\"/></p>\n<p>创建<code>Cookie对象</code>：</p>\n<pre><code class=\"language-java\">@WebServlet(\"/text_cookie.do\")\npublic class TextCookieServlet extends HttpServlet {\n\t@Override\n\tprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n\t\t//创建cookie对象\n\t\tCookie cookie1=new Cookie(\"phone_number\", \"12323234545\");\n\t\tCookie cookie2=new Cookie(\"name\", \"xiaoming\");\n\t\tCookie cookie3=new Cookie(\"sex\", \"boy\");\n\t\tCookie cookie4=new Cookie(\"height\", \"188cm\");\n\t\tcookie1.setMaxAge(24*24*60*7);//设置过期时间，单位为秒\n\t\tcookie2.setMaxAge(24*24*60*7);//设置过期时间，单位为秒\n\t\tcookie3.setMaxAge(24*24*60*7);//设置过期时间，单位为秒\n\t\tcookie4.setMaxAge(24*24*60*7);//设置过期时间，单位为秒\n\t\t\n\t\t//响应\n\t\tresp.addCookie(cookie1);//添加至响应头\n\t\tresp.addCookie(cookie2);//添加至响应头\n\t\tresp.addCookie(cookie3);//添加至响应头\n\t\tresp.addCookie(cookie4);//添加至响应头\n\t\n\t}\n}</code></pre>\n<p> </p>\n<p id=\"u4c33f84d\">如果我们要读取<code>Cookie</code>，例如，在<code>TextCookieServlet</code>中，读取<code>Cookie</code>以获取用户设置的语言，可以写一个方法如下：</p>\n<pre><code class=\"language-java\">@WebServlet(\"/text_get_cookie.do\")\npublic class TextGetCookieServlet extends HttpServlet {\n\t@Override\n\tprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n\t\tSystem.out.println(\"测试获取cookie\");\n\t\tCookie[] cookies=req.getCookies();\n\t\tif (cookies!=null) {\n\t\t\tfor (Cookie cookie : cookies) {\n\t\t\t\tSystem.out.println(cookie.getName());\n\t\t\t\tSystem.out.println(cookie.getValue());\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t}\n}\n</code></pre>\n<p>观察控制台： </p>\n<p><img alt=\"\" height=\"670\" src=\"image\\d7ef2822fbc1498ebb3bb519ef7c329b.png\" width=\"1200\"/> </p>\n<p id=\"u01da2e08\">所以，读取<code>Cookie</code>主要依靠遍历<code>HttpServletRequest</code>附带的所有<code>Cookie</code></p>\n</div>\n</div>"}