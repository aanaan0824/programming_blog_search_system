{"blogid": "126743157", "writerAge": "码龄24天", "writerBlogNum": "53", "writerCollect": "0", "writerComment": "0", "writerFan": "49", "writerGrade": "3级", "writerIntegral": "530", "writerName": "web13216030568", "writerProfileAdress": "writer_image\\profile_126743157.jpg", "writerRankTotal": "38269", "writerRankWeekly": "11269", "writerThumb": "0", "writerVisitNum": "2606", "blog_read_count": "11", "blog_time": "于 2022-09-07 12:25:29 发布", "blog_title": "JVM - 本地方法接口和本地方法栈", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h2><a id=\"_JVM_2\"></a># <code>JVM</code>本地方法接口和本地方法栈</h2>\n<blockquote>\n<p><code>JDK</code>版本：<code>1.8</code></p>\n</blockquote>\n<h3><a id=\"_1_7\"></a># 1、本地方法</h3>\n<p>使用<code>Java</code>代码调用非<code>Java</code>代码的接口称作为<code>Native Method</code>。该方法的实现由非<code>Java</code>语言实现，比如<code>C</code>或者<code>C++</code>。这是<code>Java Doc中给出的解释</code>：<code>A native method is a Java method whose implementation is provided by non-java code.</code></p>\n<p>在定义一个<code>Native Method</code>时，并不提供实现体(类似于<code>Java</code>中的<code>interface</code>)，并不关系其底层是使用哪种语言、如何进行具体实现的。</p>\n<p>本地接口的作用是融合不同的编程语言为<code>Java</code>所用：</p>\n<p><img alt=\"本地方法接口\" src=\"image\\ea5b5b545d274e6caeb1033e0457c31e.png\"/></p>\n<p>标识符<code>native</code>可以与其它<code>java</code>标识符连用，但是<code>abstract</code>除外：</p>\n<pre><code>public class IHaveNatives{\n    \n    public native void methodNative1(int x);\n    \n    public native static long methodNative2();\n    \n    private native synchronized float methodNative3(Object o);\n    \n    native void methodNative4(int[] ary) throws Exception;\n    \n}\n</code></pre>\n<hr/>\n<h3><a id=\"_2_34\"></a># 2、为什么使用本地方法</h3>\n<p><code>Java</code>语言使用起来非常方便，然而有些层次的任务用<code>Java</code>实现起来不容易，或者开发者对程序的效率很在意时。就可以使用<code>Native Method</code>方法解决。</p>\n<p><strong>与<code>Java</code>环境的交互</strong>：</p>\n<p>有时<code>Java</code>应用需要与<code>Java</code>外面的环境进行交互，这是本地方法存在的主要原因。当<code>Java</code>需要与一些底层系统，如操作系统或某些硬件交换信息的场景。本地方法正是这样的一种交流机制：<code>Native Method</code>提供了一个非常简洁的接口，开发者无需了解<code>Java</code>应用之外的繁琐实现细节，直接调用接口即可。</p>\n<p><strong>与操作系统的交互</strong>：</p>\n<p><code>JVM</code>支持着<code>Java</code>语言本身和运行时库，它是<code>Java</code>程序赖以生存的平台，它由一个字节码解释器和一些连接到本地代码的库组成。但是着并不是一个完整的系统，它经常需要依赖于一些底层系统的支持，这些底层系统都是非常强大的操作系统。通过调用本地方法接口，使得<code>Java</code>很容易地实现了<code>jre</code>与底层操作系统之间的交互，甚至<code>JVM</code>的一些部分就是使用<code>C</code>语言编写的。如果需要使用一些<code>Java</code>语言本身没有提供封装的操作系统特性时，也需要使用本地方法。</p>\n<p><strong>Sun’s Java</strong>：</p>\n<p><code>Sun</code>公司的解释器是使用<code>C</code>语言进行实现的，着使得它能像一些普通的<code>C</code>语言一样与外部进行交互。<code>jre</code>大部分是用<code>Java</code>语言编写的，它通过本地方法接口与外界进行交互。例如：<code>java.lang.Thread</code>的<code>setPriority()</code>方法就是使用<code>Java</code>语言实现的，但是它正真实现调用的是该类中的本地方法<code>setPriority()</code>方法。这个本地方法是使用<code>C</code>语言进行实现的，并被植入<code>JVM</code>内部，在<code>Windows 95</code>的平台上这个本地方法最终将调用<code>Win32 setPriority() API</code>。这是一个本地方法的具体实现由<code>JVM</code>直接提供，更多的情况是本地方法由外部的动态链接库(<code>external dynamic link library</code>)提供，然后被<code>JVM</code>调用。</p>\n<hr/>\n<h3><a id=\"_3_52\"></a># 3、本地方法栈</h3>\n<p><code>Java</code>虚拟机栈用于管理<code>Java</code>方法的调用，而本地方法栈用于管理本地方法的调用。本地方法栈也是线程私有的。</p>\n<p>本地方法栈允许被实现成固定或者是可动态扩展的内存大小，在内存溢出方面是相同的。</p>\n<ul><li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，<code>Java</code>虚拟机将会抛出一个<code>StackOverflowError</code>错误。</li><li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存空间，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，<code>Java</code>虚拟机将会抛出一个<code>StackOverflowError</code>错误。</li></ul>\n<p>本地方法是由<code>C</code>语言实现的。它的具体做法是<code>Native Method Stack</code>中登记<code>native</code>放啊，在<code>Execution Engine</code>执行时加载本地方法库。</p>\n<p><img alt=\"本地方法栈与接口\" src=\"image\\4ae015b05ed743e3a85bc949d8d56022.png\"/></p>\n<p>当某一个线程调用一个本地方法时，它就进入了一个全新的并且不再受<code>JVM</code>虚拟机管控的空间，它和<code>JVM</code>虚拟机拥有相同的权限。</p>\n<ul><li>本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区。</li><li>本地方法甚至可以直接使用本地处理器中的寄存器。</li><li>本地方法可以从本地内存的堆空间中分配任意数量的内存空间。</li></ul>\n<p>并不是所有的<code>JVM</code>都支持本地方法，因为<code>Java</code>虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果<code>JVM</code>产品不打算支持<code>native</code>方法，也可以无需实现本地方法栈。在<code>Hotspot</code>虚拟机中直接将本地方法栈和虚拟机栈合并在一起。</p>\n<hr/>\n<p><a href=\"https://github.com/kapbc/Java-Kapcb\">GitHub源码地址</a>：<code>https://github.com/kapbc/Java-Kapcb/tree/master/src/main/java/com/kapcb/ccc/jvm</code></p>\n<blockquote>\n<p>备注：此文为笔者学习<code>JVM</code>的笔记，鉴于本人技术有限，文中难免出现一些错误，感谢大家批评指正。</p>\n</blockquote>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}