{"blogid": "126419931", "writerAge": "码龄170天", "writerBlogNum": "41", "writerCollect": "136", "writerComment": "67", "writerFan": "406", "writerGrade": "3级", "writerIntegral": "698", "writerName": "一言不合就撒娇", "writerProfileAdress": "writer_image\\profile_126419931.jpg", "writerRankTotal": "25315", "writerRankWeekly": "1026", "writerThumb": "161", "writerVisitNum": "13566", "blog_read_count": "1405", "blog_time": "于 2022-08-20 17:24:43 发布", "blog_title": "十大排序算法（面试必备）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F-toc\" style=\"margin-left:0px;\"><a href=\"#%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F\">简单排序</a></p>\n<p id=\"1%E3%80%81%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F-toc\" style=\"margin-left:40px;\"><a href=\"#1%E3%80%81%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F\">1、冒泡排序</a></p>\n<p id=\"2%E3%80%81%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#2%E3%80%81%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%C2%A0\">2、选择排序 </a></p>\n<p id=\"3%E3%80%81%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F-toc\" style=\"margin-left:40px;\"><a href=\"#3%E3%80%81%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F\">3、插入排序</a></p>\n<p id=\"%E9%AB%98%E7%BA%A7%E6%8E%92%E5%BA%8F-toc\" style=\"margin-left:0px;\"><a href=\"#%E9%AB%98%E7%BA%A7%E6%8E%92%E5%BA%8F\">高级排序</a></p>\n<p id=\"4%E3%80%81%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%EF%BC%88%E7%BC%A9%E5%B0%8F%E5%A2%9E%E9%87%8F%E6%8E%92%E5%BA%8F%EF%BC%89-toc\" style=\"margin-left:40px;\"><a href=\"#4%E3%80%81%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%EF%BC%88%E7%BC%A9%E5%B0%8F%E5%A2%9E%E9%87%8F%E6%8E%92%E5%BA%8F%EF%BC%89\">4、希尔排序（缩小增量排序）</a></p>\n<p id=\"%C2%A05%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A05%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F\"> 5、归并排序</a></p>\n<p id=\"6%E3%80%81%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-toc\" style=\"margin-left:40px;\"><a href=\"#6%E3%80%81%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F\">6、快速排序</a></p>\n<p id=\"%C2%A07%E3%80%81%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A07%E3%80%81%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F\"> 7、计数排序</a></p>\n<p id=\"8%E3%80%81%E5%A0%86%E6%8E%92%E5%BA%8F-toc\" style=\"margin-left:40px;\"><a href=\"#8%E3%80%81%E5%A0%86%E6%8E%92%E5%BA%8F\">8、堆排序</a></p>\n<p id=\"%C2%A09%E3%80%81%E6%A1%B6%E6%8E%92%E5%BA%8F-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A09%E3%80%81%E6%A1%B6%E6%8E%92%E5%BA%8F\"> 9、桶排序</a></p>\n<p id=\"10%E3%80%81%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F-toc\" style=\"margin-left:40px;\"><a href=\"#10%E3%80%81%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F\">10、基数排序</a></p>\n<p id=\"%E6%80%BB%E7%BB%93%EF%BC%9A-toc\" style=\"margin-left:0px;\"><a href=\"#%E6%80%BB%E7%BB%93%EF%BC%9A\">总结：</a></p>\n<p id=\"1%E3%80%81%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#1%E3%80%81%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94%C2%A0\">1、十大排序算法对比 </a></p>\n<p id=\"2%E3%80%81%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%E3%80%81%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%E3%80%81%E6%A1%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E5%8C%BA%E5%88%AB-toc\" style=\"margin-left:40px;\"><a href=\"#2%E3%80%81%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%E3%80%81%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%E3%80%81%E6%A1%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E5%8C%BA%E5%88%AB\">2、基数排序、计数排序、桶排序的区别</a></p>\n<p id=\"3%E3%80%81%E4%BB%8E%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%9D%A5%E8%AF%B4%EF%BC%9A-toc\" style=\"margin-left:40px;\"><a href=\"#3%E3%80%81%E4%BB%8E%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%9D%A5%E8%AF%B4%EF%BC%9A\">3、从时间复杂度来说：</a></p>\n<p id=\"4%E3%80%81%E8%AE%BA%E6%98%AF%E5%90%A6%E6%9C%89%E5%BA%8F%E5%AF%B9%E6%8E%92%E5%BA%8F%E7%9A%84%E5%BD%B1%E5%93%8D%EF%BC%9A-toc\" style=\"margin-left:40px;\"><a href=\"#4%E3%80%81%E8%AE%BA%E6%98%AF%E5%90%A6%E6%9C%89%E5%BA%8F%E5%AF%B9%E6%8E%92%E5%BA%8F%E7%9A%84%E5%BD%B1%E5%93%8D%EF%BC%9A\">4、论是否有序对排序的影响：</a></p>\n<p id=\"三选择排序算法的依据-toc\" style=\"margin-left:40px;\"><a href=\"#%E4%B8%89%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E4%BE%9D%E6%8D%AE\">5、选择排序算法的依据</a></p>\n<p id=\"6%E3%80%81%E5%BF%AB%E6%8E%92%E3%80%81%E5%86%92%E6%B3%A1%E3%80%81%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9A-toc\" style=\"margin-left:40px;\"><a href=\"#6%E3%80%81%E5%BF%AB%E6%8E%92%E3%80%81%E5%86%92%E6%B3%A1%E3%80%81%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9A\">6、快排、冒泡、插入排序的优缺点：</a></p>\n<hr id=\"hr-toc\"/>\n<p><em><span style=\"color:#0d0016;\"><strong>每个排序算法的讲解，都包括了算法描述，图形演示，算法实现三个部分。</strong></span></em></p>\n<p><em><span style=\"color:#0d0016;\"><strong>另外，一定要动手试着敲一敲代码哦！！！</strong></span></em></p>\n<h1 id=\"%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F\"><span style=\"color:#ff9900;\">简单排序</span></h1>\n<h2 id=\"1%E3%80%81%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F\"><span style=\"color:#4da8ee;\">1、冒泡排序</span></h2>\n<h3 id=\"%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0%EF%BC%9A\"><strong><span style=\"color:#956fe7;\">算法描述</span>：</strong></h3>\n<ol><li>首先在未排序数组的首位开始，和后面相邻的数字进行比较，如果前面一个比后面一个大则进行交换</li><li>接下来再将第二个位置的数字和后面相邻的数字进行比较，如果大，那么进行交换，直到将最大的数字交换到数字尾部</li><li>然后呢，再从排序的数组的首部开始，重复前面的2个步骤，讲最大数字交换到未排序的数组 尾部</li><li>以此类推，直到排序完毕</li></ol>\n<h3 id=\"%E5%9B%BE%E5%BD%A2%E6%BC%94%E7%A4%BA%EF%BC%9A%C2%A0\"><strong><span style=\"color:#956fe7;\">图形演示</span><span style=\"color:#ff9900;\">：</span></strong> </h3>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/69bad5e0e2f648109d6691f79347d9a1.gif\"/></p>\n<p></p>\n<h3 id=\"%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%EF%BC%9A\"><strong><span style=\"color:#ff9900;\">算法实现</span>：</strong></h3>\n<pre><code class=\"language-java\">    public static void main(String[] args) {\n        int[] arr={1,2,5,3,7,9,6,4,0,9,5};\n        for (int i = 0; i &lt; arr.length-1; i++) {\n            for (int j = 0; j &lt; arr.length-i-1; j++) {\n                if(arr[j]&gt;arr[j+1]) {\n                    int tmp=arr[j];\n                    arr[j]=arr[j+1];\n                    arr[j+1]=tmp;\n                }\n            }\n        }\n        for (int i = 0; i &lt; arr.length; i++) {\n            System.out.print(arr[i]+\" \");\n        }\n    }</code></pre>\n<h2 id=\"2%E3%80%81%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%C2%A0\"><span style=\"color:#4da8ee;\">2、选择排序</span> </h2>\n<h3><strong><span style=\"color:#ff9900;\">算法描述</span></strong>：</h3>\n<ol><li>首先在未排序序列中找到最小元素，存放在排序序列的起始位置</li><li>再从剩余未排序元素中继续寻找最小元素，放到已排序序列的尾部</li><li>以此类推，直到所有元素排序完毕</li></ol>\n<h3 id=\"%E5%9B%BE%E5%BD%A2%E6%BC%94%E7%A4%BA%EF%BC%9A\"><span style=\"color:#ff9900;\"><strong>图形演示</strong>：</span></h3>\n<h3 id=\"%E2%80%8B%E7%BC%96%E8%BE%91\" style=\"text-align:center;\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/1811561abf2a463b9e4ff9b5813bf56c.gif\"/></h3>\n<h3><strong><span style=\"color:#ff9900;\">算法实现：</span></strong></h3>\n<pre><code class=\"language-java\">    public static void main(String[] args) {\n        int[] arr={1,2,5,3,7,9,6,4,0,9,5};\n        int min=0;\n        for (int i = 0; i &lt; arr.length; i++) {\n            min=i;\n            for (int j = i+1; j &lt; arr.length; j++) {\n                if(arr[min]&gt;arr[j]) {\n                    min=j;\n                }\n            }\n            int tmp=arr[min];\n            arr[min]=arr[i];\n            arr[i]=tmp;\n        }\n        for (int i = 0; i &lt; arr.length; i++) {\n            System.out.print(arr[i]+\" \");\n        }\n    }</code></pre>\n<p></p>\n<h2 id=\"3%E3%80%81%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F\"><span style=\"color:#4da8ee;\">3、插入排序</span></h2>\n<h3><span style=\"color:#ff9900;\"><strong>算法描述</strong></span>：</h3>\n<ol><li>从第一个元素开始，该元素可以认为已经被排序</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li><li>如果该元素（已排序）大于新元素，将该元素移到下一个位置</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li><li>将新元素插图到相应的位置</li><li>重复步骤2~5</li></ol>\n<h3><strong><span style=\"color:#ff9900;\">图形演示：</span></strong></h3>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/36d7734bd41d4111b5c4f29acb982516.gif\"/></p>\n<h3 id=\"%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%EF%BC%9A%C2%A0\"><strong><span style=\"color:#ff9900;\">算法实现： </span></strong></h3>\n<p> 代码1：</p>\n<pre><code class=\"language-java\">    public static void main(String[] args) {\n        int[] nums={1,5,7,9,3,2,4,0,6,8,5};\n        int start=1;\n        for(start=1;start&lt;nums.length;start++) {\n            int insert=nums[start];//待插入元素\n            while(start&gt;0) {\n                if(nums[start-1]&gt;insert) {\n                    nums[start]=nums[start-1];\n                } else {\n                    nums[start]=insert;\n                    break;\n                }\n                start--;\n            }\n            if(start==0) {\n                nums[0]=start;\n            }\n        }\n\n        for (int i = 0; i &lt; nums.length; i++) {\n            System.out.print(nums[i]+\" \");\n        }\n    }</code></pre>\n<p>代码2：</p>\n<pre><code class=\"language-java\">    public static void main(String[] args) {\n        Scanner scanner=new Scanner(System.in);\n        int[] nums={1,5,7,9,3,2,4,0,6,8,5};\n        int start=1;\n        for(start=1;start&lt;nums.length;start++) {\n            int insert=nums[start];//待插入元素\n            int j=start-1;\n            for(j=start-1;j&gt;=0;j--) {\n                if(insert&lt;nums[j]) {\n                    nums[j+1]=nums[j];//往后挪一个\n                } else {\n                    break;\n                }\n            }\n            nums[j+1]=insert;//本行代码不可以放在break前面\n        }\n\n        for (int i = 0; i &lt; nums.length; i++) {\n            System.out.print(nums[i]+\" \");\n        }\n    }</code></pre>\n<h1 id=\"%E9%AB%98%E7%BA%A7%E6%8E%92%E5%BA%8F\"><span style=\"color:#ff9900;\">高级排序</span></h1>\n<h2 id=\"4%E3%80%81%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%EF%BC%88%E7%BC%A9%E5%B0%8F%E5%A2%9E%E9%87%8F%E6%8E%92%E5%BA%8F%EF%BC%89\"><span style=\"color:#4da8ee;\">4、希尔排序（缩小增量排序）</span></h2>\n<p>是插入排序的一种更高效的排序改进版本</p>\n<h3><span style=\"color:#956fe7;\"><strong>算法描述：</strong></span></h3>\n<ol><li>先根据数组的长度/n，获取增量k（第一次n=2）</li><li>按增量序列个数k进行分组，一般可以分为k组</li><li>根据已分好的组进行插入排序（每组排序，根据对应的增量k来找到当前的元素）</li><li>当每组都排序完毕之后，回到第一步将n*2再次分组进行插入排序，直到最终k=1时，再执行一次插入排序完成最终的排序</li></ol>\n<h3><span style=\"color:#956fe7;\"><strong>图形演示：</strong></span></h3>\n<p><img alt=\"\" height=\"491\" src=\"image\\70e035537fd54fb89cc04b5aff6fea5d.png\" width=\"1200\"/></p>\n<p><img alt=\"\" height=\"203\" src=\"image\\1b98b81aef66421ca23c92500a72dbd3.png\" width=\"1200\"/> <img alt=\"\" height=\"1032\" src=\"image\\e3eb926aa1734cb6bec5f4d9429152d7.png\" width=\"1200\"/></p>\n<p> <img alt=\"\" height=\"193\" src=\"image\\ef87c808e6ac4f7595f0e8cafbb4facd.png\" width=\"1200\"/></p>\n<h3 id=\"%E2%80%8B%E7%BC%96%E8%BE%91%C2%A0%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%EF%BC%9A\"><img alt=\"\" height=\"411\" src=\"image\\a68b691fbaf845f4935c1e0a1fce4e1e.png\" width=\"1200\"/> <span style=\"color:#956fe7;\"><strong>算法实现：</strong></span></h3>\n<p></p>\n<pre><code class=\"language-java\">    public static void main(String[] args) {\n        int[] nums={1,5,7,9,3,2,4,0,6,8,5};\n        //控制增量序列,增量序列为1的时候为最后一趟\n        for (int i = nums.length/2; i &gt; 0; i/=2) {\n            //根据增量序列，找到每组比较序列的最后一个数的位置\n            for (int j = i; j &lt;nums.length ; j++) {\n                //根据该比较序列的最后一个数的位置，依次向前执行插入排序\n                for (int k = j-i; k &gt;= 0 ; k-=i) {\n                    if(nums[k]&gt;nums[k+i]) {\n                        int tmp=nums[k];\n                        nums[k]=nums[k+i];\n                        nums[k+i]=tmp;\n                    }\n                }\n            }\n        }\n        System.out.println(Arrays.toString(nums));\n    }</code></pre>\n<h2 id=\"%C2%A05%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F\"><span style=\"color:#956fe7;\"> </span><span style=\"color:#4da8ee;\">5、归并排序</span></h2>\n<h3><span style=\"color:#956fe7;\"><strong>算法描述：</strong></span></h3>\n<ol><li>归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，即，将问题分成一些小的问题然后递归求解，而治的阶段将分的阶段得到的各答案“修补”在一起，即分而治之</li><li>归并排序是稳定排序，它是一种十分高效的排序，能利用完全二叉树特性的排序一般性能都不会太差。Java中Arrays.sort()采用了一种名为TimSort的排序算法，就是归并排序的优化版本。</li><li>归并排序的最好最坏，平均时间复杂度都是O(nlogn)</li><li>归并排序核心思想是先分再治，具体算法描述如下：</li></ol>\n<ul><li>先将未排序数组/2进行分组，然后将分好的数组继续/2再次分组，知道无法分组，这个就是分的过程</li><li>然后再将之后再把两个数组大小为1合并为一个大小为2的，再把两个大小为2的合并成4的，同时在合并的过程中完成数组的排序，最终直到全部大小的数组合并起来，这个就是治的过程</li></ul>\n<p>我的乖乖，看起来好像是云里雾里的，是不是？不慌不慌，看下面的图，就会豁然开朗哒！！！</p>\n<p><img alt=\"\" height=\"1142\" src=\"image\\3cb7408031564f988dd74422e12ff0f2.png\" width=\"1200\"/></p>\n<p>5.治的过程中会为两个数组设计两个游标，和一个新的数组</p>\n<ul><li>分别比较两个游标指对应数组的元素，将小的插入到新的数组中</li><li>然后向后移动较小的数组的游标，继续进行比较</li><li>反复前面两步，最终将两个数组中的元素排序合并到新的数组中</li></ul>\n<p>有点糊？看</p>\n<h3><span style=\"color:#956fe7;\">图形演示：</span></h3>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/a8e3da812f4e48ddaa583c349b40f75f.gif\"/> </p>\n<h3 id=\"%C2%A0%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%EF%BC%9A\"> <span style=\"color:#956fe7;\"><strong>算法实现：</strong></span></h3>\n<pre><code class=\"language-java\">public class Test {\n    public static void main(String[] args) {\n        int[] arr = {8, 10, -1, 6, 7, 3, 0, 40, 70};\n        int[] temp = new int[arr.length];//归并排序需要额外的空间\n        mergeSort(arr, 0, arr.length - 1, temp);\n        System.out.println(Arrays.toString(arr));\n    }\n\n    //分\n    public static void mergeSort(int[] arr, int left, int right, int[] temp) {\n        if (left &lt; right) {\n            int mid = (left + right) / 2;//中间索引\n            mergeSort(arr, left, mid, temp);//向左递归分解\n            mergeSort(arr, mid + 1, right, temp);//向右递归分解\n            merge(arr, left, mid, right, temp);//合并\n        }\n    }\n\n    //治\n    public static void merge(int[] arr, int left, int mid, int right, int[] temp) {\n        int i = left;//i为指向左边序列第一个元素的索引\n        int j = mid + 1;//j为指向右边序列第一个元素的索引\n        int t = 0;//指向临时temp数组的当前索引\n\n        //先把左右两边有序数据按规则存入temp数组中,直到有一边的数据全部填充temp中\n        while (i &lt;= mid &amp;&amp; j &lt;= right) {\n            if (arr[i] &lt;= arr[j]) {\n                temp[t] = arr[i];\n                t++;\n                i++;\n            } else {\n                temp[t] = arr[j];\n                t++;\n                j++;\n            }\n        }\n\n        //将有剩余数据的一边全部存入temp中\n        while (i &lt;= mid) {//左边序列有剩余元素\n            temp[t] = arr[i];\n            t++;\n            i++;\n        }\n        while (j &lt;= right) {//右边序列有剩余元素\n            temp[t] = arr[j];\n            t++;\n            j++;\n        }\n\n         //将temp中的元素拷贝到arr中\n        \n        t = 0;\n        int tempLeft = left;\n        while (tempLeft &lt;= right) {\n            arr[tempLeft] = temp[t];\n            t++;\n            tempLeft++;\n        }\n    }\n}</code></pre>\n<h2 id=\"6%E3%80%81%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F\"><span style=\"color:#4da8ee;\">6、快速排序</span></h2>\n<h3 id=\"%C2%A0%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0%EF%BC%9A\"> <span style=\"color:#956fe7;\"><strong>算法描述：</strong></span></h3>\n<ol><li>快速排序是对冒泡排序的一种改进，，通过分而治之的思想，减少排序中交换和遍历的次数，整个过程可以通过递归的方式完成：</li><li>通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列</li><li>具体描述：</li></ol>\n<ul><li>从数列中挑出一个元素，称为\"基准\"。</li><li>重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区操作。</li><li>递归地把小于基准值元素的子数列和大于基准值元素的子数列排序。<br/>  </li></ul>\n<h3><strong><span style=\"color:#956fe7;\">图形演示：</span></strong></h3>\n<p style=\"text-align:center;\"> <img alt=\"\" src=\"https://img-blog.csdnimg.cn/942afca28ce54e81adf79a213742784f.gif\"/></p>\n<h3><strong><span style=\"color:#956fe7;\">算法实现：</span></strong></h3>\n<pre><code class=\"language-java\">public class Test {\n    public static void main(String[] args) {\n        int[] array={3,5,6,7,8,3,2,1,9,5,3};\n        quickSort(array);\n        System.out.println(Arrays.toString(array));\n    }\n   //快速排序\n    public static void quickSort(int[] array) {\n        int len;\n        if (array == null || (len = array.length) == 0 || len == 1) {\n            return;\n        }\n        sort(array, 0, len - 1);\n    }\n\n\n     //快排核心算法，递归实现\n    public static void sort(int[] array, int left, int right) {\n        //1.设置递归条件\n        if (left &gt; right) {\n            return;\n        }\n        //2.声明左右指针以及基准值。这里的基准值设置为i与j相遇的位置为每次的基准值,初始值为第一个元素。\n        int i = left;\n        int j = right;\n        int base = array[left];\n        //3.控制while循环找到i=j的位置\n        while (i != j) {\n            //先 从右往左找到一个小于基准值的点(哪边作为初始值哪边后走),且保证i一直在j左侧。\n            while (array[j] &gt;= base &amp;&amp; i &lt; j) {\n                j--;\n            }\n            //同理，从左往右找到大于基准值的点，与j交换\n            while (array[i] &lt;= base &amp;&amp; i &lt; j) {\n                i++;\n            }\n            //此时的i与j已经相等，交换(这个if好像可有可无...待验证)。\n            if (i &lt; j) {\n                int temp = array[i];\n                array[i] = array[j];\n                array[j] = temp;\n            }\n        }\n        //此时一次交换完毕，重新设置基准值(基准值为第一个元素)。\n        array[left] = array[i];\n        array[i] = base;\n        //递归进行 右侧进行\n        sort(array, left, i - 1);\n        // 左侧进行\n        sort(array, i + 1, right);\n\n    }\n}\n</code></pre>\n<h2 id=\"%C2%A07%E3%80%81%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F\"><span style=\"color:#4da8ee;\"> 7、计数排序</span></h2>\n<h3><span style=\"color:#956fe7;\"><strong>算法描述：</strong></span></h3>\n<ol><li>计数排序是非基于比较的排序算法</li><li>优势在于在对一定范围内的整数排序时，他的时间复杂度为O(n+k)【其中k是整数的范围】，快于任何比较排序算法，是一种牺牲空间换取时间的做法，而且当O(k)&gt;O(nlog(n))的时候，其效率反而不如基于比较的排序（基于比较的排序的时间复杂度在理论上，下限是O(nlog(n))，如归并排序，堆排序）</li><li>计数排序是一种适合于最大值最小值的差值不是很大的排序，也就是说重复的数据会比较多的情况</li><li>具体实现过程：</li></ol>\n<ul><li>首先遍历整个数组，找到最大值</li><li>然后根据最大值创建一个临时数组，用于统计每个数字出现的次数，例如：tmp[i]=m,表示元素i一共出现 m 次</li><li>最后再把临时数组统计的数据从小到大返回到原来的数组中，这样就是有序的</li></ul>\n<h3><span style=\"color:#956fe7;\">图形演示：</span></h3>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/922d84ab07c245ea9c3b65176c1ec937.gif\"/><span style=\"color:#d7d8d9;\"> </span></p>\n<h3><strong><span style=\"color:#956fe7;\">算法实现：</span></strong></h3>\n<pre><code class=\"language-java\">    public static void main(String[] args) {\n        int[] nums={1,5,7,2,3,4,8,9,4,5};\n        int max=nums[0];\n        for (int i = 0; i &lt; nums.length; i++) {\n            if(nums[i]&gt;max) {\n                max=nums[i];\n            }\n        }\n        //临时数组——计数数组\n        int[] arr=new int[max+1];\n        for (int i = 0; i &lt; nums.length; i++) {\n            arr[nums[i]]+=1;\n        }\n        int j=0;\n        for (int i = 0; i &lt; arr.length; i++) {\n            while(arr[i]!=0) {\n                nums[j]=i;\n                arr[i]--;\n                j++;\n            }\n        }\n        System.out.println(Arrays.toString(nums));\n    }</code></pre>\n<h2 id=\"8%E3%80%81%E5%A0%86%E6%8E%92%E5%BA%8F\"><span style=\"color:#4da8ee;\">8、堆排序</span></h2>\n<h3 id=\"%E5%85%B3%E4%BA%8E%E5%A0%86%E7%9A%84%E7%9F%A5%E8%AF%86%E6%99%AE%E5%8F%8A%EF%BC%9A\"><span style=\"color:#956fe7;\"><strong>关于堆的知识普及：</strong></span></h3>\n<ol><li>堆排序是指利用堆这种数据结构所设计的一种排序算法，它是一种选择排序，他的最好最坏及平均时间复杂度均是O(nlog(n))</li><li>堆是一颗完全二叉树：</li></ol>\n<ul><li>当所有的结点的值都大于或等于其左右的子结点的值称为大顶堆</li><li>当所有的结点的值都小于或等于其左右的子结点的值称为小顶堆 </li></ul>\n<p> <img alt=\"\" height=\"741\" src=\"image\\cdaa89bac79f45baabd0f66d601cc35a.png\" width=\"868\"/></p>\n<h3 id=\"%E2%80%8B%E7%BC%96%E8%BE%91%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0%C2%A0%EF%BC%9A\"><img alt=\"\" height=\"697\" src=\"image\\1e0a6d5ec83842b3922d7bdcfd61136a.png\" width=\"758\"/><span style=\"color:#956fe7;\"><strong>算法描述</strong></span> <span style=\"color:#956fe7;\"><strong>：</strong></span></h3>\n<p>1、首先，将待排序的数组构造一个大顶堆</p>\n<ul><li>从最后一个非叶子结点开始，和其结点进行比较</li><li>如果子结点比根节点大，则选择较大的子结点和根结点进行交换</li><li>如果没有发生交换，则从倒数第二个非叶子结点继续比较</li><li>以上的做法就是将较大的元素向树的高层进行交换。注意：当树的层次较多的时候，如果在发生根节点和子结点发生交换之后，还需要继续将交换的结点与其下的子节点继续比较，直到没有子结点位置</li><li>最终从最后一个非叶子结点遍历到根结点，交换完之后大顶堆就构造完毕了</li></ul>\n<h3><span style=\"color:#956fe7;\"><strong>图形演示：</strong></span></h3>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/8f899015b7e240d08c02decc1d182be8.gif\"/> </p>\n<p>2、那么，堆的根结点，则是数组中的最大值</p>\n<p>3、将根结点和末尾元素进行交换，之后末尾就是最大值</p>\n<p>4、然后将剩余的n-1元素重新构造成一大顶堆，然后将跟结点和末尾（n-1）元素进行交换，这样n和n-1已经有序了</p>\n<p>5、剩下的n-2元素继续构造大顶堆和最后n-2交换，如此反复直到排序排序完毕</p>\n<h3 id=\"%E5%AE%8C%E6%95%B4%E5%9B%BE%E5%BD%A2%E6%BC%94%E7%A4%BA%EF%BC%88%E6%8E%A5%E7%9D%80%E4%B8%8A%E9%9D%A2%EF%BC%89%EF%BC%9A\"><span style=\"color:#956fe7;\"><strong>完整图形演示（接着上面）：</strong></span></h3>\n<p>由于大小GIF大小有限制，所以分成了多个展示：</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/8a9d7f1526434392b78b4c1a0701eda5.gif\"/></p>\n<p>  </p>\n<p><img alt=\"\" src=\"https://img-blog.csdnimg.cn/eb24ee6112ef47548e25d3e33a1722a4.gif\"/><img alt=\"\" src=\"https://img-blog.csdnimg.cn/cc0262db9f4942168e2543a7ab9539e6.gif\"/> </p>\n<h3><strong><span style=\"color:#956fe7;\">算法实现：</span></strong></h3>\n<pre><code class=\"language-java\">import java.util.Arrays;\n\npublic class HeapSort {\n    public static void main(String[] args) {\n        int[] arr = {3, 5, 2, 7,4,5,8,2,1,9,0,5,4};\n        heapSort(arr);\n        System.out.println(Arrays.toString(arr));\n    }\n\n    //堆排序\n    public static void heapSort(int[] arr) {\n        //将无序序列构建成一个堆\n        for (int i = arr.length / 2 - 1; i &gt;= 0; i--) {\n            adjustHeap(arr, i, arr.length);\n        }\n        //将堆顶元素和末尾元素交换,将最大元素放置数组末端\n        //重新调整至堆结构,然后继续将堆顶元素和当前末尾元素交换,以此往复\n        for (int i = arr.length - 1; i &gt; 0; i--) {\n            int temp = arr[i];\n            arr[i] = arr[0];\n            arr[0] = temp;\n            adjustHeap(arr, 0, i);\n        }\n    }\n\n    // 将二叉树调整为堆\n     \n    public static void adjustHeap(int[] arr, int i, int length) {\n        int temp = arr[i];\n        //k=2i+1是i的左子结点\n        for (int k = i * 2 + 1; k &lt; length; k = k * 2 + 1) {\n            if (k + 1 &lt; length &amp;&amp; arr[k] &lt; arr[k + 1])//左子结点的值&lt;右子结点的值\n                k++;//指向右节点\n            if (arr[k] &gt; temp) {//如果子结点的值&gt;根节点的值\n                arr[i] = arr[k];//将较大的值赋给当前结点\n                i = k;//i指向k,继续循环比较\n            } else\n                break;\n        }\n        //for循环后,已经将以i为根结点的树的最大值,放在了顶部\n        arr[i] = temp;//将temp值放到调整后的位置\n    }\n}\n</code></pre>\n<h2 id=\"%C2%A09%E3%80%81%E6%A1%B6%E6%8E%92%E5%BA%8F\"> <span style=\"color:#4da8ee;\">9、桶排序</span></h2>\n<h3><span style=\"color:#956fe7;\"><strong>算法描述</strong></span>：</h3>\n<p><strong>就是把一个数组分成几个桶（其实是几个区间，从小到大或从大到小的几个区间）装，然后让每个桶（区间）有序，然后取出来放一起就可以了，相当于把几个有序的段拿出来放一起，自然还是有序的，当然需要是按照区间的顺序拿了。</strong></p>\n<h3 id=\"%C2%A0%E5%9B%BE%E5%BD%A2%E6%BC%94%E7%A4%BA%EF%BC%9A\"> <span style=\"color:#956fe7;\">图形演示：</span></h3>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/24d58208b4b8467fae39fbee936032f5.gif\"/></p>\n<h3> <span style=\"color:#956fe7;\">算法实现：</span></h3>\n<pre><code class=\"language-java\">package com.keafmd.Sequence;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\n\npublic class BucketSort {\n\n    public static void bucketSort(int[] arr){\n        bucketSort(arr,true);\n    }\n\n    public static void bucketSort(int[] arr,boolean ascending){\n        if(arr==null||arr.length==0){\n            return;\n        }\n        //计算最大值与最小值\n        int max = Integer.MIN_VALUE;\n        int min = Integer.MAX_VALUE;\n        for(int i=0;i&lt;arr.length;i++){\n            max = Math.max(arr[i],max);\n            min = Math.min(arr[i],min);\n        }\n\n        //计算桶的数量\n        int bucketNUm = (max-min)/ arr.length+1;\n        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = new ArrayList&lt;&gt;(bucketNUm);\n        for(int i=0;i&lt;bucketNUm;i++){\n            bucketArr.add(new ArrayList&lt;&gt;());\n        }\n\n        //将每个元素放入桶中\n        for(int i=0;i&lt;arr.length;i++){\n            int num = (arr[i]-min)/ (arr.length);\n            bucketArr.get(num).add(arr[i]);\n        }\n\n        //对每个桶进行排序\n        for (int i = 0; i &lt; bucketArr.size(); i++) {\n            //用系统的排序，速度肯定没话说\n            Collections.sort(bucketArr.get(i));\n        }\n\n        //将桶中元素赋值到原序列\n        int index;\n        if(ascending){\n            index=0;\n        }else{\n            index=arr.length-1;\n        }\n\n        for(int i=0;i&lt;bucketArr.size();i++){\n            for(int j= 0;j&lt;bucketArr.get(i).size();j++){\n                arr[index] = bucketArr.get(i).get(j);\n                if(ascending){\n                    index++;\n                }else{\n                    index--;\n                }\n            }\n\n        }\n\n    }\n}\n</code></pre>\n<h2 id=\"10%E3%80%81%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F\"><span style=\"color:#4da8ee;\">10、基数排序</span></h2>\n<h3><span style=\"color:#956fe7;\">算法描述：</span></h3>\n<p>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p>\n<p>基数排序是效率高并且稳定的排序法。（所谓稳定是什么呢？比如对一个原始数组：3，1，43，1 排序，使用基数排序后的数组为 1，1，3，43，第一个1在前面，第二个1在后面）<br/>  </p>\n<h3><span style=\"color:#956fe7;\">图形演示：</span> </h3>\n<p><img alt=\"\" src=\"https://img-blog.csdnimg.cn/280b93be74864a1a9f388e0629402f56.gif\"/></p>\n<h3> <span style=\"color:#956fe7;\">算法实现：</span></h3>\n<pre><code class=\"language-java\">package DataStructures.Sort;\n\nimport java.util.Arrays;\n\npublic class RadixSort {\n    public static void main(String[] args) {\n        int[] arr = new int[]{53, 3, 542, 748, 14, 214};\n        radixSort(arr);\n    }\n\n    /**\n     * @param arr\n     * @author ZJ\n     * Description 基数排序\n     * date 2022-05-11 22:01:50 22:01\n     */\n    public static void radixSort(int[] arr) {\n        //定义一个二维数组，表示10个桶，每个桶就是一个一维数组\n        int[][] bucket = new int[10][arr.length];//很明显，基数排序使用了空间换时间\n\n        //为了记录每个桶中实际存放了多少个数据，定义一个一维数组来记录每次放入数据的个数\n        //比如bucketElementCounts[0]=3，意思是bucket[0]存放了3个数据\n        int[] bucketElementCounts = new int[10];\n\n        int digitOfElement = 0;//每次取出的元素的位数\n\n        //找到数组中最大数的位数\n        int max = 0;\n        for (int i = 0; i &lt; arr.length; i++) {\n            if (max &lt; String.valueOf(arr[i]).length()) {\n                max = String.valueOf(arr[i]).length();\n            }\n        }\n\n        int index = 0;\n        for (int i = 0, n = 1; i &lt; max; i++, n *= 10) {\n            //第i+1轮排序（针对每个元素的位进行排序处理）\n            for (int j = 0; j &lt; arr.length; j++) {\n                digitOfElement = arr[j] / n % 10;//取出每个元素的位\n                bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];//放入对应的桶\n                bucketElementCounts[digitOfElement]++;\n            }\n            //按照这个桶的顺序（一维数组的下标取出数据），放入原来的数组\n            index = 0;\n            //遍历每一个桶，并将桶中数据放入原数组\n            for (int k = 0; k &lt; bucketElementCounts.length; k++) {\n                //如果桶中有数据，我们才放到原数组\n                if (bucketElementCounts[k] != 0) {\n                    //循环第k个桶，放入\n                    for (int l = 0; l &lt; bucketElementCounts[k]; l++) {\n                        arr[index] = bucket[k][l];\n                        index++;\n                    }\n                }\n                bucketElementCounts[k] = 0;//置零!!!!!\n            }\n            System.out.println(\"第\" + i + 1 + \"轮排序后\" + Arrays.toString(arr));\n        }\n    }\n}\n</code></pre>\n<h1 id=\"%E6%80%BB%E7%BB%93%EF%BC%9A\"><span style=\"color:#956fe7;\">总结：</span></h1>\n<h2 id=\"1%E3%80%81%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94%C2%A0\"><span style=\"color:#6eaad7;\">1、十大排序算法对比 </span></h2>\n<p><img alt=\"\" src=\"image\\20210624180751650.png\"/></p>\n<h3 id=\"%E8%A1%A5%E5%85%85%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E7%A8%B3%E5%AE%9A%E6%80%A7%EF%BC%9F\"><span style=\"color:#4da8ee;\">补充：什么是稳定性？</span></h3>\n<blockquote>\n<p>比如对一个原始<a href=\"https://so.csdn.net/so/search?q=%E6%95%B0%E7%BB%84&amp;spm=1001.2101.3001.7020\" title=\"数组\">数组</a>：3，1，43，1 排序，使用基数排序后的数组为 1，1，3，43，第一个1在前面，第二个1在后面）</p>\n</blockquote>\n<h2 id=\"2%E3%80%81%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%E3%80%81%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%E3%80%81%E6%A1%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E5%8C%BA%E5%88%AB\"><span style=\"color:#6eaad7;\">2、基数排序、<a href=\"https://so.csdn.net/so/search?q=%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F&amp;spm=1001.2101.3001.7020\" title=\"计数排序\">计数排序</a>、桶排序的区别</span></h2>\n<blockquote>\n<p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p>\n<ul><li>基数排序：根据键值的每位数字来分配桶；</li><li>计数排序：每个桶只存储单一键值；</li><li>桶排序：每个桶存储一定范围的数值； </li></ul>\n</blockquote>\n<h2 id=\"3%E3%80%81%E4%BB%8E%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%9D%A5%E8%AF%B4%EF%BC%9A\"><span style=\"color:#6eaad7;\">3、从时间复杂度来说：</span></h2>\n<blockquote>\n<ol><li>平方阶O(n²)排序：各类简单排序：<strong>直接插入、直接选择和冒泡排序</strong></li><li>线性对数阶O(nlog₂n)排序：<strong>快速排序、堆排序和归并排序</strong></li><li>O(n1+§))排序，§是介于0和1之间的常数：<strong>希尔排序</strong></li><li>线性阶O(n)排序：<strong>基数排序，此外还有桶、箱排序</strong></li></ol>\n</blockquote>\n<h2 id=\"4%E3%80%81%E8%AE%BA%E6%98%AF%E5%90%A6%E6%9C%89%E5%BA%8F%E5%AF%B9%E6%8E%92%E5%BA%8F%E7%9A%84%E5%BD%B1%E5%93%8D%EF%BC%9A\"><br/><span style=\"color:#6eaad7;\">4、论是否有序对排序的影响：</span></h2>\n<blockquote>\n<ol><li>当<span style=\"color:#6eaad7;\">原数据有序或基本有序时，直接插入排序和冒泡排序</span>将大大减少比较次数和移动记录的次数，时间复杂度可降至O（n）；</li><li>而快速排序则相反，当原表基本有序时，将蜕化为冒泡排序，时间复杂度提高为O（n2）；</li><li>原数据是否有序，<span style=\"color:#6eaad7;\">对简单选择排序、堆排序、归并排序和基数排序的时间复杂度影响不大。</span></li></ol>\n</blockquote>\n<h2 id=\"三选择排序算法的依据\"><span style=\"color:#6eaad7;\">5、选择排序算法的依据</span></h2>\n<p>        从以下四点来谈谈如何选择：</p>\n<blockquote>\n<p><strong>1</strong>．待排序的记录数目n的大小；</p>\n<p><strong>2</strong>．记录本身数据量的大小，也就是记录中除关键字外的其他信息量的大小；</p>\n<p><strong>3</strong>．关键字的结构及其分布情况；</p>\n<p><strong>4</strong>．对排序稳定性的要求。</p>\n</blockquote>\n<h3 id=\"%E8%AE%BE%E5%BE%85%E6%8E%92%E5%BA%8F%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%AA%E6%95%B0%E4%B8%BAn.\"><span style=\"color:#ff9900;\">设待排序元素的个数为n.</span></h3>\n<blockquote>\n<p><strong>1）</strong>当n较大，则应采用时间复杂度为O(nlog2n)的排序方法：<strong>快速排序、堆排序或归并排序</strong>。</p>\n<p><strong>2）</strong> 当n较大，内存空间允许，且要求稳定性 =》<strong>归并排序</strong></p>\n<p><strong>3）</strong>当n较小，可采用<strong>直接插入或直接选择排序</strong>。</p>\n<p><strong>4）</strong>一般不使用或不直接使用传统的冒泡排序。</p>\n<p><strong>5）</strong>基数排序<br/> 它是一种稳定的排序算法，但有一定的局限性：</p>\n<ol><li>　　关键字可分解。</li><li>　　记录的关键字位数较少，如果密集更好</li><li>        如果是数字时，最好是无符号的，否则将增加相应的映射复杂度，可先将其正负分开排序。</li></ol>\n</blockquote>\n<h2 id=\"6%E3%80%81%E5%BF%AB%E6%8E%92%E3%80%81%E5%86%92%E6%B3%A1%E3%80%81%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9A\"><span style=\"color:#6eaad7;\"><strong>6、快排、冒泡、插入排序的优缺点</strong></span>：</h2>\n<blockquote>\n<h3 id=\"%E5%BF%AB%E6%8E%92%EF%BC%9A\"><span style=\"color:#ff9900;\"><strong>快排</strong>：</span></h3>\n<p>优点：<span style=\"color:#4da8ee;\">极快，数据移动少</span>；是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短；</p>\n<p>缺点：不稳定；</p>\n</blockquote>\n<blockquote>\n<h3 id=\"%E5%86%92%E6%B3%A1%EF%BC%9A\"><span style=\"color:#ff9900;\">冒泡：</span></h3>\n<p>优点：稳定</p>\n<p>缺点：<span style=\"color:#4da8ee;\">慢，每次只能移动两个相邻的数据；</span></p>\n</blockquote>\n<blockquote>\n<h3 id=\"%E6%8F%92%E5%85%A5%EF%BC%9A\"><span style=\"color:#ff9900;\">插入：</span></h3>\n<p>优点：稳定，快</p>\n<p>缺点：<span style=\"color:#4da8ee;\">比较次数不一定，比较次数越少，插入点后的数据移动越多，特别是数据量庞大的时候</span></p>\n</blockquote>\n<p> 下期见！！！</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/f9df153251c84fbda9fdad148b1ffa91.gif\"/> </p>\n</div>\n</div>"}