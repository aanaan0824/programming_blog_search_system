{"blogid": "123731842", "writerAge": "码龄3年", "writerBlogNum": "128", "writerCollect": "810", "writerComment": "174", "writerFan": "74", "writerGrade": "5级", "writerIntegral": "2006", "writerName": "铁锤妹妹@", "writerProfileAdress": "writer_image\\profile_123731842.jpg", "writerRankTotal": "14888", "writerRankWeekly": "27367", "writerThumb": "282", "writerVisitNum": "270775", "blog_read_count": "6806", "blog_time": "已于 2022-06-17 16:24:10 修改", "blog_title": "理解js中的同步和异步", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p>首先要先了解下js单线程</p>\n<h3><a id=\"js_3\"></a>一、为什么js是单线程?</h3>\n<blockquote>\n<p>其实，JavaScript的单线程，与它的用途是有很大关系，我们都知道，JavaScript作为浏览器的脚本语言，主要用来实现与用户的交互，利用JavaScript，我们可以实现对DOM的各种各样的操作，如果JavaScript是多线程的话，一个线程在一个DOM节点中增加内容，另一个线程要删除这个DOM节点，那么这个DOM节点究竟是要增加内容还是删除呢？这会带来很复杂的同步问题，因此，JavaScript是单线程的</p>\n</blockquote>\n<h3><a id=\"_6\"></a>二、同步任务和异步任务</h3>\n<p><strong>（1）为什么会有同步和异步？</strong></p>\n<p>因为JavaScript的单线程，因此同个时间只能处理同个任务，所有任务都需要排队，前一个任务执行完，才能继续执行下一个任务，但是，如果前一个任务的执行时间很长，比如文件的读取操作或ajax操作，后一个任务就不得不等着，拿ajax来说，当用户向后台获取大量的数据时，不得不等到所有数据都获取完毕才能进行下一步操作，用户只能在那里干等着，严重影响用户体验。<br/> 因此，JavaScript在设计的时候，就已经考虑到这个问题，主线程可以完全不用等待文件的读取完毕或ajax的加载成功，可以先挂起处于等待中的任务，先运行排在后面的任务，等到文件的读取或ajax有了结果后，再回过头执行挂起的任务，因此，任务就可以分为<code><strong>同步任务和异步任务。</strong></code><br/> <strong>其实同步和异步，<br/> 无论如何，做事情的时候都是只有一条流水线（单线程），<br/> 同步和异步的差别就在于这条流水线上各个流程的执行顺序不同。</strong></p>\n<p><strong>(2) 同步任务</strong></p>\n<p>同步任务是指在<code>主线程上排队执行的任务，只有前一个任务执行完毕，才能继续执行下一个任务</code>，当我们打开网站时，网站的渲染过程，比如元素的渲染，其实就是一个同步任务。</p>\n<p><strong>(3) 异步任务</strong></p>\n<p>异步任务是指<code>不进入主线程，而进入任务队列的任务，只有任务队列通知主线程，某个异步任务可以执行了，该任务才会进入主线程</code>，当我们打开网站时，像图片的加载，音乐的加载，其实就是一个异步任务</p>\n<pre><code class=\"prism language-javascript\"> <span class=\"token operator\">&lt;</span>script<span class=\"token operator\">&gt;</span>\n      <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n         console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span><span class=\"token number\">5000</span><span class=\"token punctuation\">)</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>script<span class=\"token operator\">&gt;</span>\n</code></pre>\n<p>执行顺序是这样的，先输出1和2等待5秒后输出3<br/> <img alt=\"在这里插入图片描述\" src=\"image\\1b5a34d47403419ea86bf88ab653bd19.png\"/><br/> 上述代码具体的执行过程是：</p>\n<blockquote>\n<p><strong>1. 先执行执行栈中的同步任务</strong><br/> <strong>2. 遇到异步任务（回调函数）就放入任务队列中</strong><br/> <strong>3. 一旦执行栈中的同步任务执行完毕，系统就会按次序读取任务队列中的异步任务，被读取的异步任务结束等待状态，进入执行栈开始执行。</strong><br/> <img alt=\"在这里插入图片描述\" src=\"image\\ae7f3fd862034d82a9a57cda4afebd92.png\"/></p>\n</blockquote>\n<p><strong>(4) 异步机制</strong></p>\n<p>那么，JavaScript中的异步是怎么实现的呢？那要需要说下<code>回调和事件循环</code>这两个概念啦</p>\n<p>首先要先说下任务队列，前面也介绍了，异步任务是不会进入主线程，而是会先进入<code>任务队列</code>，任务队列其实是一个<code>先进先出</code>的数据结构，也是一个事件队列，比如说文件读取操作，因为这是一个异步任务，因此该任务会被添加到任务队列中，等到IO完成后，就会在任务队列中<code>添加一个事件</code>，表示异步任务完成啦，可以进入执行栈啦~ 但是这时候，主线程不一定有空，当主线程处理完其它任务有空时，就会读取任务队列，读取里面有哪些事件，排在前面的事件会被优先进行处理，如果该任务指定了<code>回调函数</code>，那么主线程在处理该事件时，就会执行回调函数中的代码，也就是执行异步任务啦</p>\n<p>单线程从任务队列中读取任务是不断循环的，每次执行栈被清空后，都会在任务队列中读取新的任务，如果没有任务，就会等待，直到有新的任务，这就叫做任务循环，因为每个任务都是由一个事件触发的，因此也叫做<code>事件循环</code></p>\n<p>总的来说，JavaScript的异步机制包括以下几个步骤</p>\n<blockquote>\n<p><strong>1. 所有同步任务都在主线程上执行，形成一个执行栈。</strong><br/> <strong>2. 主线程之外，还存在一个任务队列，只要异步任务有了结果，就会在任务队列中放置一个事件</strong><br/> <strong>3. 一旦执行栈中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈中，先执行微任务队列再执行宏任务队列。</strong><br/> <code><strong>4. 主线程不断的重复上面的第三步</strong></code></p>\n</blockquote>\n<h3><a id=\"js_57\"></a>三、js常见的异步操作（个人理解需要耗时很长的操作）</h3>\n<p>1） setTimeout (setInterval)<br/> 2）AJAX<br/> 3）事件绑定(如：.on，.bind，.listen，.addEventListener，.observe)<br/> 4）观察者模式(例如：websocket中就有发布和订阅之类的操作)<br/> 5）promise 是一个异步操作，但是它是一个异步操作的解决方案，即保存着异步操作的结果，可以把异步函数以同步函数的形式写出来（Promise的成功|失败的回调（.then（）/.catch（））<br/> 6）async/await — 使用generator的语法糖，可以理解为是generator的一种改进<br/> 7）generator函数 — 使用promise的语法糖，可以理解为是promise的另一种拓展</p>\n<h3><a id=\"__66\"></a>三、 异步转同步的方式</h3>\n<p>为了解决异步编程，出现了三种类似的用于解决异步操作的方案。<code><strong>（个人理解这种方式为了解决异步操作的，都是异步操作变成同步；需要取到上个方法返回的值，才能继续正常往下执行，见下方回调函数具体需求的描述）</strong></code></p>\n<p><strong>1）回调函数</strong>（回调函数就是将一个函数当作另一个主函数的参数来使用的函数。）</p>\n<p>这是异步编程最基本的方法</p>\n<blockquote>\n<p>需求：<br/> 假定有两个函数 test1 和 test2，后者等待前者的执行结果。<br/> 如果test1()是一个比较耗时的任务，就会把test1放入任务队列中，先执行test2的代码，这样test2需要的变量会报错undfind；所以可以考虑改写test1()，把test2()写成test1()的回调函数<br/> 改写如下：</p>\n</blockquote>\n<pre><code class=\"prism language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">test1</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">callback</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span> <span class=\"token comment\">//(主函数)</span>\n   console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'执行了test1'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">//主函数任务代码</span>\n　 <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n　　 <span class=\"token function\">callback</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n　　<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">test2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span><span class=\"token comment\">//回调函数</span>\n   console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'执行了test2'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">test1</span><span class=\"token punctuation\">(</span>test2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 执行</span>\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\3b469007650c4301b1c7eba9e8b4cfda.png\"/><br/> <strong>解读：</strong><br/> <code>回调函数是传统的一种异步编程解决方案，其原理就是将一个函数当作参数传递到另一个主函数中，当主函数执行完自身的内容之后，在运行传递进来的回调函数。</code></p>\n<p>采用这种方式，我们把同步操作变成了异步操作，test1()不会堵塞程序运行，相当于先执行主程序的主要逻辑，将耗时的操作推迟执行。</p>\n<p><code>优点：</code>简单，容易理解和部署，缺点是不利于代码的阅读和维护，各个部分之间高度耦合，流程会很混乱<br/> <code>缺点：</code>一个任务只能有一个回调函数</p>\n<p><strong>2）promise</strong></p>\n<p>已经知道setTimeout是一种异步操作了，因此这里的例子可以将每一个setTimeout拟作一次接口请求</p>\n<blockquote>\n<p>需求：<br/> 存在两个函数a(), b(), 需要在a() 函数所有内容执行完毕之后，再执行b（）函数；但是a（）函数又存在异步操作（获取数据）；<br/> 如果按顺序执行a(),b()，就会导致b（）先执行，出现数据内容不存在的情况（a是异步的）（可能想表达的是b函数依赖a函数的某些数据吧）；<br/> 因此使用promise来处理</p>\n</blockquote>\n<p>自我理解：</p>\n<blockquote>\n<p>因为a()函数里有异步操作，就会放入任务队列，等同步操作执行完毕再从任务队列进入主线程执行；<br/> 现在想按照 a() =&gt;b() 顺序执行；所以需要promise，通过resolve获取成功的值之后，结果作为.then的返回值，再去调用b()</p>\n</blockquote>\n<p>先不用.then（）处理异步任务<br/> <img alt=\"在这里插入图片描述\" src=\"image\\e60f2d6d0133460f8408698e43b77b5e.png\"/><br/> <img alt=\"在这里插入图片描述\" src=\"image\\846439878c8c4d61af5f26b4d221b92e.png\"/><br/> 用.then() 处理异步任务<br/> <img alt=\"在这里插入图片描述\" src=\"image\\2b27bf10caed4ac8ba73c2762dd58796.png\"/><br/> 这样就达成了理想的效果，先执行a()函数，然后执行b()函数。<br/> <img alt=\"在这里插入图片描述\" src=\"image\\fd760b0b380f4b1a916296edecf5387e.png\"/><br/> <strong>3）async-await的基础用法</strong></p>\n<p>3.1 <code>async </code>函数和普通函数一样执行，是generator的语法糖。<br/> 3.2 <code>async</code>函数的返回值是<code>Promise 对象</code>，所以可以用.then方法指定下一步的操作，return语句返回的值，会成为then方法回调函数的参数</p>\n<pre><code class=\"prism language-javascript\"> <span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">return</span> <span class=\"token string\">'hello world'</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">result</span> <span class=\"token operator\">=&gt;</span> <span class=\"token punctuation\">{<!-- --></span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<p>3.3 基本使用示例：多个异步操作完成后才会进行后续操作</p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\d2082f6232ab4441807959670dd92e51.png\"/><br/> <img alt=\"\" src=\"image\\abacccedcacc4c6f8cf184427995ca70.png\"/><br/> await后面的函数建议 返回 Promise对象(即return new Promise((resolve,reject)=&gt;{})) 并且主动调用resolve()才能够进行后续的then或者是后续的await操作，倘若是执行了reject(reject的参数会被catch方法的回调函数接收到)或者throw抛出错误之类的就会导致当前执行中断。</p>\n<blockquote>\n<p><strong>注意1</strong>：await命令后面的Promise对象，运行结果可能是rejected，所以最好把await命令放在<code>try…catch</code>代码块中。<br/> <strong>注意2</strong>：多个await命令后面的异步操作，如果<code>不存在先后关联</code>，最好让它们<code>同时触发</code>。不然会增加耗时；<br/> 这样做的好处就是，如果两个await直接运行则需要2秒的时间才会运行后续的内容，<br/> 但是像这样处理一下，两个就会同时开始，即只需要1秒就可以运行后续的内容了。<br/> <img alt=\"在这里插入图片描述\" src=\"image\\4bc357ba2c4e4384adb98a089cda63d0.png\"/></p>\n</blockquote>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}