{"blogid": "126534975", "writerAge": "码龄1年", "writerBlogNum": "53", "writerCollect": "2679", "writerComment": "1947", "writerFan": "4906", "writerGrade": "6级", "writerIntegral": "5849", "writerName": "老师我作业忘带了", "writerProfileAdress": "writer_image\\profile_126534975.jpg", "writerRankTotal": "2756", "writerRankWeekly": "26", "writerThumb": "1768", "writerVisitNum": "158686", "blog_read_count": "34228", "blog_time": "已于 2022-09-01 11:08:28 修改", "blog_title": "openCV实践项目：拖拽虚拟方块", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p></p>\n<h1>一、项目效果：</h1>\n<p class=\"img-center\"><img alt=\"\" height=\"360\" src=\"https://img-blog.csdnimg.cn/27234904f0284e498aa9390a8006383d.gif\" width=\"640\"/></p>\n<p><u>学校宿舍今天搬家，累麻了，突然发现展示处理的也很粗糙，就这样吧嘿嘿~~~</u></p>\n<p></p>\n<h1>二、核心流程：</h1>\n<p>1、openCV读取视频流、在每一帧图片上画一个矩形。</p>\n<p>2、使用mediapipe获取手指关键点坐标。</p>\n<p>3、根据手指坐标位置和矩形的坐标位置，判断手指点是否在矩形上，如果在则矩形跟随手指移动。</p>\n<p></p>\n<h1>三、代码流程：</h1>\n<h2>环境准备：</h2>\n<ul><li>python: 3.8.8</li><li>opencv: 4.2.0.32</li><li>mediapipe: 0.8.10.1</li></ul>\n<p><strong>注：</strong></p>\n<p>1、opencv版本过高或过低可能出现一些如摄像头打不开、闪退等问题，python版本影响opencv可选择的版本。</p>\n<p>2、pip install mediapipe 后可能导致openCV无法正常使用，卸了重新下载，习惯了就好。</p>\n<p></p>\n<h2>1. 读取摄像头视频，画矩形：</h2>\n<pre><code class=\"language-python\">import cv2\nimport time\nimport numpy as np\n\n\n# 调用摄像头 0 默认摄像头 \ncap = cv2.VideoCapture(0)\n\n# 初始方块数据\nx = 100\ny = 100\nw = 100\nh = 100\n\n# 读取一帧帧照片\nwhile True:\n    # 返回frame图片\n    rec,frame = cap.read()\n    \n    # 镜像\n    frame = cv2.flip(frame,1)\n    \n    # 画矩形 \n    cv2.rectangle(frame, (x, y), (x + w, y + h), (255, 0, 255), -1)\n\n    # 显示画面\n    cv2.imshow('frame',frame)\n    \n    # 退出条件\n    if cv2.waitKey(1) &amp; 0xFF == ord('q'):\n        break\n    \ncap.release()\ncv2.destroyAllWindows() </code></pre>\n<p>这是很基础的一步操作，此时我们运行这段代码，摄像头打开，我们会惊讶地看到自己英俊的脸庞，且左上角有个100*100的紫色矩形。</p>\n<p></p>\n<h2>2. 导入mediapipe处理手指坐标</h2>\n<pre><code class=\"language-python\">pip install mediapipe</code></pre>\n<p>此时可能出现一些问题，比如openCV突然用不了了，没关系，卸载了重新下。</p>\n<p>mediapipe详细信息：<a href=\"https://google.github.io/mediapipe/solutions/hands\" title=\"Hands - mediapipe (google.github.io)\">Hands - mediapipe (google.github.io)</a></p>\n<p class=\"img-center\"><img alt=\"\" height=\"360\" src=\"image\\d9708b9f213b4e32bcfac094b270839b.png\" width=\"734\"/></p>\n<p class=\"img-center\"><img alt=\"\" height=\"270\" src=\"image\\a36e9e53eb4344b8b2feba8adcf81994.png\" width=\"738\"/></p>\n<p>简单来说，它会返回给我们21个手指关键点的坐标，即它在视频画面的位置比例( 0~1 )，我们乘以对应画面的宽高，就能得到手指对应的坐标了。</p>\n<p>本次用到食指和中指指尖，也就是8号和12号。</p>\n<p></p>\n<h3>2.1 配置一些基础信息：</h3>\n<pre><code class=\"language-python\">import cv2\nimport time\nimport numpy as np\nimport mediapipe as mp\n\n\nmp_drawing = mp.solutions.drawing_utils\nmp_drawing_styles = mp.solutions.drawing_styles\nmp_hands = mp.solutions.hands\n\nhands =  mp_hands.Hands(\n    static_image_mode=True,\n    max_num_hands=2,\n    min_detection_confidence=0.5)</code></pre>\n<h3>2.2 在处理每一帧图像时，加入：</h3>\n<pre><code class=\"language-python\">    frame.flags.writeable = False\n    frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)\n    # 返回结果\n    results = hands.process(frame)\n\n    frame.flags.writeable = True\n    frame = cv2.cvtColor(frame, cv2.COLOR_RGB2BGR)</code></pre>\n<p>当我们在视频流中读取每一帧图片时，将其从BGR转为RGB供给mediapipe生成的hands对象读取，它会返回这张图片中手指关键点的信息，我们只需要继续对其作画，画在每一帧图片上。</p>\n<pre><code class=\"language-python\">    # 如果结果不为空\n    if results.multi_hand_landmarks:\n\n        # 遍历双手(根据读取顺序，一只只手遍历、画画)\n        for hand_landmarks in results.multi_hand_landmarks:\n            mp_drawing.draw_landmarks(\n                frame,\n                hand_landmarks,\n                mp_hands.HAND_CONNECTIONS,\n                mp_drawing_styles.get_default_hand_landmarks_style(),\n                mp_drawing_styles.get_default_hand_connections_style())</code></pre>\n<h3>2.3 至此步骤完整代码</h3>\n<pre><code class=\"language-python\">import cv2\nimport time\nimport numpy as np\nimport mediapipe as mp\n\n\nmp_drawing = mp.solutions.drawing_utils\nmp_drawing_styles = mp.solutions.drawing_styles\nmp_hands = mp.solutions.hands\n\nhands =  mp_hands.Hands(\n    static_image_mode=True,\n    max_num_hands=2,\n    min_detection_confidence=0.5)\n\n\n# 调用摄像头 0 默认摄像头 \ncap = cv2.VideoCapture(0)\n\n# 方块初始数组\nx = 100\ny = 100\nw = 100\nh = 100\n\n\n# 读取一帧帧照片\nwhile True:\n    # 返回frame图片\n    rec,frame = cap.read()\n    \n    # 镜像\n    frame = cv2.flip(frame,1)\n    \n    \n    \n    frame.flags.writeable = False\n    frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)\n    # 返回结果\n    results = hands.process(frame)\n\n    frame.flags.writeable = True\n    frame = cv2.cvtColor(frame, cv2.COLOR_RGB2BGR)\n    \n    \n    # 如果结果不为空\n    if results.multi_hand_landmarks:\n\n        # 遍历双手(根据读取顺序，一只只手遍历、画画)\n        # results.multi_hand_landmarks n双手\n        # hand_landmarks 每只手上21个点信息\n        for hand_landmarks in results.multi_hand_landmarks:\n            mp_drawing.draw_landmarks(\n                frame,\n                hand_landmarks,\n                mp_hands.HAND_CONNECTIONS,\n                mp_drawing_styles.get_default_hand_landmarks_style(),\n                mp_drawing_styles.get_default_hand_connections_style())\n    \n    \n    # 画矩形 \n    cv2.rectangle(frame, (x, y), (x + w, y + h), (255, 0, 255), -1)\n\n    # 显示画面\n    cv2.imshow('frame',frame)\n    \n    # 退出条件\n    if cv2.waitKey(1) &amp; 0xFF == ord('q'):\n        break\n    \ncap.release()\ncv2.destroyAllWindows() </code></pre>\n<p>此时我们运行看一下还挺有意思的：</p>\n<p class=\"img-center\"><img alt=\"\" height=\"276\" src=\"https://img-blog.csdnimg.cn/d6bcf8ea6ac443aa9bad340432a5ceb8.gif\" width=\"491\"/></p>\n<p></p>\n<h2>3. 位置计算</h2>\n<p>我们这个实验要求拖动方块，那肯定也有不拖动的时候，因此不妨根据上一步获取<span style=\"color:#fe2c24;\"><strong>食指(8)</strong></span>和<span style=\"color:#fe2c24;\"><strong>中指(12)</strong></span><span style=\"color:#4da8ee;\"><strong>指尖</strong></span>的位置，如果这俩离得近，我们就在他与方块重合的时候，根据手指的位置改变方块的坐标。</p>\n<p class=\"img-center\"><img alt=\"\" height=\"270\" src=\"image\\a36e9e53eb4344b8b2feba8adcf81994.png\" width=\"738\"/></p>\n<p></p>\n<p></p>\n<h1>完整代码：</h1>\n<p class=\"img-center\"><img alt=\"\" height=\"284\" src=\"image\\9539480d0a8e477eba11ccdb0628c520.png\" width=\"727\"/></p>\n<p></p>\n<pre><code class=\"language-python\">import cv2\nimport time\nimport math\nimport numpy as np\nimport mediapipe as mp\n\n# mediapipe配置\nmp_drawing = mp.solutions.drawing_utils\nmp_drawing_styles = mp.solutions.drawing_styles\nmp_hands = mp.solutions.hands\nhands =  mp_hands.Hands(\n    static_image_mode=True,\n    max_num_hands=2,\n    min_detection_confidence=0.5)\n\n\n# 调用摄像头 0 默认摄像头 \ncap = cv2.VideoCapture(0)\n\n# cv2.namedWindow(\"frame\", 0)\n# cv2.resizeWindow(\"frame\", 960, 640)\n\n\n# 获取画面宽度、高度\nwidth = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))\nheight = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))\n\n\n# 方块初始数组\nx = 100\ny = 100\nw = 100\nh = 100\n\nL1 = 0\nL2 = 0\n\non_square = False\nsquare_color = (0, 255, 0)\n\n# 读取一帧帧照片\nwhile True:\n    # 返回frame图片\n    rec,frame = cap.read()\n    \n    # 镜像\n    frame = cv2.flip(frame,1)\n    \n    \n    \n    frame.flags.writeable = False\n    frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)\n    # 返回结果\n    results = hands.process(frame)\n\n    frame.flags.writeable = True\n    frame = cv2.cvtColor(frame, cv2.COLOR_RGB2BGR)\n    \n    \n    # 如果结果不为空\n    if results.multi_hand_landmarks:\n\n\n        # 遍历双手(根据读取顺序，一只只手遍历、画画)\n        # results.multi_hand_landmarks n双手\n        # hand_landmarks 每只手上21个点信息\n        for hand_landmarks in results.multi_hand_landmarks:\n            mp_drawing.draw_landmarks(\n                frame,\n                hand_landmarks,\n                mp_hands.HAND_CONNECTIONS,\n                mp_drawing_styles.get_default_hand_landmarks_style(),\n                mp_drawing_styles.get_default_hand_connections_style())\n            \n            # 记录手指每个点的x y 坐标\n            x_list = []\n            y_list = []\n            for landmark in hand_landmarks.landmark:\n                x_list.append(landmark.x)\n                y_list.append(landmark.y)\n                \n            \n            # 获取食指指尖\n            index_finger_x, index_finger_y = int(x_list[8] * width),int(y_list[8] * height)\n\n            # 获取中指\n            middle_finger_x,middle_finger_y = int(x_list[12] * width), int(y_list[12] * height)\n\n\n            # 计算两指尖距离\n            finger_distance = math.hypot((middle_finger_x - index_finger_x), (middle_finger_y - index_finger_y))\n\n            # 如果双指合并(两之间距离近)\n            if finger_distance &lt; 60:\n\n                # X坐标范围 Y坐标范围\n                if (index_finger_x &gt; x and index_finger_x &lt; (x + w)) and (\n                        index_finger_y &gt; y and index_finger_y &lt; (y + h)):\n\n                    if on_square == False:\n                        L1 = index_finger_x - x\n                        L2 = index_finger_y - y\n                        square_color = (255, 0, 255)\n                        on_square = True\n\n            else:\n                # 双指不合并/分开\n                on_square = False\n                square_color = (0, 255, 0)\n\n            # 更新坐标\n            if on_square:\n                x = index_finger_x - L1\n                y = index_finger_y - L2\n            \n            \n\n    # 图像融合 使方块不遮挡视频图片\n    overlay = frame.copy()\n    cv2.rectangle(frame, (x, y), (x + w, y + h), square_color, -1)\n    frame = cv2.addWeighted(overlay, 0.5, frame, 1 - 0.5, 0)\n    \n\n    # 显示画面\n    cv2.imshow('frame',frame)\n    \n    # 退出条件\n    if cv2.waitKey(1) &amp; 0xFF == ord('q'):\n        break\n    \ncap.release()\ncv2.destroyAllWindows() </code></pre>\n<p></p>\n</div>\n</div>"}