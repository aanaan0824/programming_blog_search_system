{"blogid": "123116284", "writerAge": "码龄4年", "writerBlogNum": "7", "writerCollect": "16", "writerComment": "0", "writerFan": "4", "writerGrade": "1级", "writerIntegral": "73", "writerName": "一路向北i", "writerProfileAdress": "writer_image\\profile_123116284.jpg", "writerRankTotal": "190586", "writerRankWeekly": "1007920", "writerThumb": "3", "writerVisitNum": "9078", "blog_read_count": "895", "blog_time": "于 2022-02-28 14:26:07 发布", "blog_title": "C# .NetCore知识点", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h2><a id=\"1netCore_0\"></a>1、.netCore的执行过程</h2>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\5a8c2ffba18c4e5582862c61e335174d.png\"/></p>\n<h2><a id=\"2controllerservice_2\"></a>2、如何在controller中注入service?</h2>\n<p>在Config Services方法中配置这个service<br/> 在Controller的构造函数中 添加这个依赖注入</p>\n<h2><a id=\"3netCorenet_6\"></a>3、.netCore比.net更具优势的地方是什么？</h2>\n<p>跨平台，可以运行在 Windows 、Linux 和 MAC 系统上<br/> 对框架本身安装没有依赖，所有依赖都和程序本身在一起<br/> .netCore处理请求的效率更高，进而可以处理更多的请求<br/> 具有更多的安装配置方法</p>\n<h2><a id=\"4netCore_12\"></a>4、.netCore主要的特性有哪些？</h2>\n<p>依赖注入<br/> 日志系统架构<br/> 引入了一个跨平台的网络服务器kestrel，可以没有iis 、apache和nginx就可单独运行<br/> 可以使用命令行创建应用<br/> 使用AppSettings.json来配置工程<br/> 使用start up来注册服务<br/> 更好的支持异步编程<br/> 支持web socket和signal IR<br/> 对于跨网站的请求的预防和保护机制</p>\n<h2><a id=\"5NetCore_Filter_23\"></a>5、.NetCore Filter如何支持依赖注入</h2>\n<p>通过全局注册，支持依赖注入<br/> 通过TypeFilter（typeof(Filter)）标记在方法，标记在控制器<br/> 通过ServiceType（typeof(Filter)）标记在方法，标记在控制器，必须要注册Filter这类<br/> TypeFilter和ServiceType的本质是实现了一个IFilterFactory接口</p>\n<h2><a id=\"6NetCore__28\"></a>6、.NetCore 中有哪些异常处理方案</h2>\n<ul><li>继承Controller，重写OnActionExecuted</li><li>使用 ActionFilterAttribute</li><li>使用 IExceptionFilter</li><li>使用ExceptionHandler</li><li>自定义Middleare处理</li></ul>\n<h2><a id=\"7NetCore_34\"></a>7、介绍一下.NetCore中服务的生命周期</h2>\n<p>ASP.NET Core支持依赖注入软件设计模式，它允许在不同的组件中注入我们的服务，并且控制服务的初始化。有些服务可以在短时间内初始化，并且只能在某个特别的组件，以及请求中才能用到；而还有一些服务，仅仅只用初始化一次，就可以在整个应用程序中使用。</p>\n<p>Singleton — 单例模式<br/> 只有一个服务的实例被创建，这个实例，存储在内存中，可以在整个应用程序中使用。我们可以对一些初始化代价比较大的服务，使用Singleton模式。</p>\n<pre><code class=\"prism language-csharp\">services<span class=\"token punctuation\">.</span><span class=\"token generic-method\"><span class=\"token function\">AddSingleton</span><span class=\"token generic class-name\"><span class=\"token punctuation\">&lt;</span>IProductService<span class=\"token punctuation\">,</span>ProductService<span class=\"token punctuation\">&gt;</span></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>Scoped — 作用域模式<br/> 这种模式下，将会为每一个请求，都创建一个服务的实例。所有同一个请求中的中间件、MVC控制器等等，都会得到一个相同的服务实例。Entity Framework Context就是一个Scoped服务最好的参考例子。</p>\n<pre><code class=\"prism language-csharp\">services<span class=\"token punctuation\">.</span><span class=\"token generic-method\"><span class=\"token function\">AddScoped</span><span class=\"token generic class-name\"><span class=\"token punctuation\">&lt;</span>IProductService<span class=\"token punctuation\">,</span>ProductService<span class=\"token punctuation\">&gt;</span></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>Transient — 短暂的、瞬变的<br/> Transient模式下，服务每次被请求的时候，都会创建一个服务实例，这种模式特别适合轻量级、无状态的服务。</p>\n<pre><code class=\"prism language-csharp\">services<span class=\"token punctuation\">.</span><span class=\"token generic-method\"><span class=\"token function\">AddTransient</span><span class=\"token generic class-name\"><span class=\"token punctuation\">&lt;</span>IProductService<span class=\"token punctuation\">,</span>ProductService<span class=\"token punctuation\">&gt;</span></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h2><a id=\"8_55\"></a>8、什么是依赖注入</h2>\n<p>依赖注入是一个过程，就是当一个类需要调用另一个类来完成某项任务的时候，在调用类里面不要去new被调用的类的对象，而是通过注入的方式来获取这样一个对象。具体的实现就是在调用类里面有一个被调用类的接口，然后通过调用接口的函数来完成任务。比如A调用B，而B实现了接口C，那么在A里面用C定义一个变量D，这个变量的实例不在A里面创建，而是通过A的上下文来获取。这样做的好处就是将类A和B分开了，他们之间靠接口C来联系，从而实现对接口编程。</p>\n<h2><a id=\"9_57\"></a>9、依赖注入有几种方式</h2>\n<p>setter注入：<br/> 就是在类A里面定义一个C接口的属性D，在A的上下文通过B实例化一个对象，然后将这个对象赋值给属性D。主要就是set 与 get<br/> 构造函数注入：<br/> 就是在创建A的对象的时候，通过参数将B的对象传入到A中。<br/> 还有常用的注入方式就是工厂模式的应用了，这些都可以将B的实例化放到A外面，从而让A和B没有关系。还有一个接口注入，就是在客户类（A）的接口中有一个服务类(B)的属性。在实例化了这个接口的子类后，对这个属性赋值，这和setter注入一样。<br/> 接口注入：<br/> 相比构造函数注入和属性注入，接口注入显得有些复杂，使用也不常见。具体思路是先定义一个接口，包含一个设置依赖的方法。然后依赖类，继承并实现这个接口。</p>\n<h2><a id=\"10_65\"></a>10、控制反转是什么</h2>\n<p>控制反转（Inversion of Control，缩写为Ioc），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫依赖注入（Dependency Injection，简称DI），还有一种方式叫依赖查找（Dependency Lookup）。<br/> 通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。</p>\n<h2><a id=\"11_68\"></a>11、依赖注入有哪些著名的框架？</h2>\n<p>Unity、autofac、http://spring.net、MEF、Injection、Asp.Net Core的ServiceCollection。</p>\n<h2><a id=\"12dot_net_corestartup_class_70\"></a>12、什么是dot net core的startup class？</h2>\n<p>StartUp.Class是.NetCore应用的入口。所有的.netCore应用必须有这个class，这个类用来配置服务。这个类的调用是在program main函数里面进行配置的。类的名字可以自己定义。</p>\n<h2><a id=\"13startup_classconfigure_72\"></a>13、startup class的configure方法有什么作用？</h2>\n<p>这个方法来定义整个应用如何响应HTTP请求。它有几个比较重要的参数，application builder、Hosting environment、logo factory，在这里我们可以配置一些中间件用来处理路径、验证和session等。</p>\n<h2><a id=\"14Middleware_74\"></a>14、什么是中间件（Middleware）？</h2>\n<p>中间件是组装到应用程序管道中以处理请求和响应的软件。<br/> 每个组件：</p>\n<ul><li>选择是否将请求传递给管道中的下一个组件</li><li>可以在调用管道中的下一个组件之前和之后执行工作</li></ul>\n<h2><a id=\"15_81\"></a>15、中间件的使用场景有哪些？</h2>\n<p>身份验证，Session存储，日志记录等<br/> 其实我们的Asp.net core项目中本身已经包含了很多个中间件。比如 身份认证中间件UseAuthorization()等系列。</p>\n<h2><a id=\"16_84\"></a>16、列举官方常用的中间件？</h2>\n<p>异常/错误处理 当应用在开发环境中运行时： 开发人员异常页中间件 (UseDeveloperExceptionPage) 报告应用运行时错误。 数据库错误页中间件报告数据库运行时错误。 当应用在生产环境中运行时： 异常处理程序中间件 (UseExceptionHandler) 捕获以下中间件中引发的异常。 HTTP 严格传输安全协议 (HSTS) 中间件 (UseHsts) 添加 Strict-Transport-Security 标头。<br/> HTTPS 重定向中间件 (UseHttpsRedirection) 将 HTTP 请求重定向到 HTTPS。<br/> 静态文件中间件 (UseStaticFiles) 返回静态文件，并简化进一步请求处理。<br/> Cookie 策略中间件 (UseCookiePolicy) 使应用符合欧盟一般数据保护条例 (GDPR) 规定。用于路由请求的路由中间件 (UseRouting)。<br/> 身份验证中间件 (UseAuthentication) 尝试对用户进行身份验证，然后才会允许用户访问安全资源。<br/> 用于授权用户访问安全资源的授权中间件 (UseAuthorization)。<br/> 会话中间件 (UseSession) 建立和维护会话状态。 如果应用使用会话状态，请在 Cookie 策略中间件之后和 MVC 中间件之前调用会话中间件。<br/> 用于将 Razor Pages 终结点添加到请求管道的终结点路由中间件（带有 MapRazorPages 的 UseEndpoints）。</p>\n<h2><a id=\"17_94\"></a>17、中间件的执行顺序</h2>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\b54244b90b324833b658a984e3b3558b.png\"/><br/> 从图片中看到执行顺序就是在第一个中间件中执行第一步，然后执行第二个中间件的第一步，然后执行第三个中间件，之后返回执行第二个中间件的第二部在执行第一个中间件的第二部，整体像绕了一个圈子。</p>\n<h2><a id=\"18application_builderuserun_97\"></a>18、application builder的use和run方法有什么区别？</h2>\n<p>这两个方法都是在start up class中的configure方法中调用的。都是用来向应用请求管道里面添加中间件的。use方法可以调用下一个中间件的添加，而run不会。</p>\n<h2><a id=\"19dot_net_core_map_99\"></a>19、dot net core 管道里面的map拓展有什么作用?</h2>\n<p>可以针对不同的路径添加不同的中间件</p>\n<h2><a id=\"20dot_net_core_101\"></a>20、dot net core里面的路径是如何处理的？</h2>\n<p>路径处理是用来为进入的请求寻找处理函数的机制。所有的路径在函数运行开始时进行注册。<br/> 主要有两种路径处理方式， 常规路径处理和属性路径处理。常规路径处理就是用MapRoute的方式设定调用路径，属性路径处理是指在调用函数的上方设定一个路径属性。</p>\n<h2><a id=\"21dot_net_core_104\"></a>21、dot net core工程里面有哪些常见的工程文件？</h2>\n<p>global、launchsetting、appsettings、bundleconfig、bower、package</p>\n<h2><a id=\"22_106\"></a>22、依赖注入实现原理？</h2>\n<p>实现DI，核心在于依赖注入容器（IContainer），该容器具有以下功能：</p>\n<ul><li>（容器）保存可用服务的合集</li><li>（注册）提供一种方式将各种部件与他们依赖的服务绑定到一起</li><li>（解析点）为应用程序提供一种方式来请求已配置的对象</li></ul>\n<h2><a id=\"23ASPNET_CoreIP_112\"></a>23、ASP.NET Core项目如何设置IP地址和端口号？</h2>\n<p>可以使用Properties文件夹下的launchSettings配置文件来配置不同的启动方式的时候，分别配置IP和端口号。</p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}