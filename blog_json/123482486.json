{"blogid": "123482486", "writerAge": "码龄2年", "writerBlogNum": "40", "writerCollect": "301", "writerComment": "226", "writerFan": "316", "writerGrade": "4级", "writerIntegral": "1184", "writerName": "cls-evd", "writerProfileAdress": "writer_image\\profile_123482486.jpg", "writerRankTotal": "34428", "writerRankWeekly": "279336", "writerThumb": "358", "writerVisitNum": "33185", "blog_read_count": "1867", "blog_time": "已于 2022-03-22 17:07:38 修改", "blog_title": "C++入门（六）之String", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p><strong>目录</strong></p>\n<p><a href=\"#%E4%B8%80%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E4%B9%A0string%E7%B1%BB%EF%BC%9F\">一、为什么学习string类？</a></p>\n<p style=\"margin-left:40px;\"><a href=\"#C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2\">C语言中的字符串</a></p>\n<p style=\"margin-left:40px;\"><a href=\"#%E7%AE%97%E6%B3%95%E9%A2%98%E4%BD%BF%E7%94%A8\">算法题使用</a></p>\n<p style=\"margin-left:0px;\"><a href=\"#%E4%BA%8C%E3%80%81%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%AD%E7%9A%84string%E7%B1%BB\">二、标准库中的string类</a></p>\n<p style=\"margin-left:40px;\"><a href=\"#string%E7%B1%BB\">string类</a></p>\n<p style=\"margin-left:40px;\"><a href=\"#string%E6%96%87%E6%A1%A3%E4%BB%8B%E7%BB%8D\">string文档介绍</a></p>\n<p style=\"margin-left:40px;\"><a href=\"#string%E7%9A%84%E5%BA%95%E5%B1%82%E7%AE%80%E4%BB%8B\">string的底层简介</a></p>\n<p style=\"margin-left:40px;\"><a href=\"#%E4%B8%AD%E6%96%87%E7%9A%84%E7%BC%96%E7%A0%81%E8%A1%A8\">中文的编码表</a></p>\n<p style=\"margin-left:40px;\"><a href=\"#string%E7%9A%84%E5%A4%B4%E6%96%87%E4%BB%B6\">string的头文件</a></p>\n<p style=\"margin-left:0px;\"><a href=\"#%E4%B8%89%E3%80%81string%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3%E8%AF%B4%E6%98%8E%C2%A0%C2%A0\">三、string类的常用接口说明  </a></p>\n<p style=\"margin-left:40px;\"><a href=\"#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%C2%A0\">构造函数 </a></p>\n<p style=\"margin-left:40px;\"><a href=\"#string%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%B9%E9%87%8F%E6%93%8D%E4%BD%9C\">string类对象的容量操作</a></p>\n<p style=\"margin-left:80px;\"><a href=\"#%281%29%20%E8%AE%A1%E7%AE%97%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%95%BF%E5%BA%A6%20size%E4%B8%8Elengh\">(1) 计算对象的长度 size与lengh</a></p>\n<p style=\"margin-left:80px;\"><a href=\"#%282%29%20max_size\">(2) max_size</a></p>\n<p style=\"margin-left:80px;\"><a href=\"#%283%29capacity\">(3)capacity</a></p>\n<p style=\"margin-left:80px;\"><a href=\"#%284%29clear%C2%A0\">(4)clear </a></p>\n<p style=\"margin-left:80px;\"><a href=\"#%285%29string%E7%9A%84%E5%A2%9E%E5%AE%B9reserve%E4%B8%8Eresize\">(5)string的增容reserve与resize</a></p>\n<p style=\"margin-left:80px;\"><a href=\"#%287%29%20empty\">(7) empty</a></p>\n<p style=\"margin-left:40px;\"><a href=\"#string%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%8F%8A%E9%81%8D%E5%8E%86%E6%93%8D%E4%BD%9C\">string类对象的访问及遍历操作</a></p>\n<p style=\"margin-left:80px;\"><a href=\"#%E2%80%8B%281%29operator%20%5B%20%5D%C2%A0%20%E5%AF%B9%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E8%A1%8C%E9%81%8D%E5%8E%86%C2%A0\">​(1)operator [ ]  对字符串进行遍历 </a></p>\n<p style=\"margin-left:80px;\"><a href=\"#%282%29%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%BF%9B%E8%A1%8C%E9%81%8D%E5%8E%86\">(2)迭代器进行遍历</a></p>\n<p style=\"margin-left:80px;\"><a href=\"#%283%29%20%E8%8C%83%E5%9B%B4for%20%E8%87%AA%E5%8A%A8%E5%BE%80%E5%90%8E%E8%BF%AD%E4%BB%A3%EF%BC%8C%E8%87%AA%E5%8A%A8%E5%88%A4%E6%96%AD%E7%BB%93%E6%9D%9F%EF%BC%88C%2B%2B11%E6%89%8D%E6%94%AF%E6%8C%81%EF%BC%89%C2%A0\">(3) 范围for 自动往后迭代，自动判断结束（C++11才支持） </a></p>\n<p style=\"margin-left:80px;\"><a href=\"#%284%29%20%E5%8F%8D%E5%90%91%E8%BF%AD%E4%BB%A3%E5%99%A8%20%E5%80%92%E7%9D%80%E9%81%8D%E5%8E%86%C2%A0\">(4) 反向迭代器 倒着遍历 </a></p>\n<p style=\"margin-left:80px;\"><a href=\"#%285%29const%20%E8%BF%AD%E4%BB%A3%E5%99%A8%C2%A0%C2%A0%C2%A0\">(5)const 迭代器   </a></p>\n<p style=\"margin-left:80px;\"><a href=\"#%286%29%20at\">(6) at</a></p>\n<p style=\"margin-left:40px;\"><a href=\"#string%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E6%93%8D%E4%BD%9C\">string类对象的修改操作</a></p>\n<p style=\"margin-left:80px;\"><a href=\"#%C2%A0%C2%A0%281%29%E6%8F%92%E5%85%A5%E5%AD%97%E7%AC%A6\">(1)插入字符</a></p>\n<p style=\"margin-left:80px;\"><a href=\"#%282%29%20c_str\">(2) c_str</a></p>\n<p style=\"margin-left:80px;\"><a href=\"#%283%29%20find%E4%B8%8Erfind%E5%8F%8Asubstr\">(3) find与rfind及substr</a></p>\n<p style=\"margin-left:80px;\"><a href=\"#%284%29insert\">(4)insert</a></p>\n<p style=\"margin-left:80px;\"><a href=\"#%285%29erase\">(5)erase</a></p>\n<p style=\"margin-left:40px;\"><a href=\"#string%E7%B1%BB%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0\">string类非成员函数</a></p>\n<p style=\"margin-left:80px;\"><a href=\"#%E2%80%8B%281%29operator%20%2B%C2%A0\">​(1)operator + </a></p>\n<p style=\"margin-left:80px;\"><a href=\"#%282%29%20%E6%B5%81%E6%8F%90%E5%8F%96%E5%92%8C%E6%B5%81%E6%8F%92%E5%85%A5\">(2) 流提取和流插入</a></p>\n<p style=\"margin-left:80px;\"><a href=\"#%C2%A0%283%29%E6%AF%94%E8%BE%83%E5%A4%A7%E5%B0%8F\">(3)比较大小</a></p>\n<p style=\"margin-left:80px;\"><a href=\"#%284%29stoi%28string%20to%20int%29\">(4)stoi(string to int)</a></p>\n<p style=\"margin-left:80px;\"><a href=\"#%285%29to_string\">(5)to_string</a></p>\n<p style=\"margin-left:80px;\"><a href=\"#%286%29getline\">(6)getline</a></p>\n<hr/>\n<p></p>\n<h1><strong>一、为什么学习</strong><strong>string</strong><strong>类？</strong></h1>\n<h2><strong>C</strong><strong>语言中的字符串 </strong></h2>\n<div>\n    C语言中，字符串是以'\\0'结尾的一些字符的集合，为了操作方便，C标准库中提供了一些str系列的库函数，但是这些库函数与字符串是分离开的，不太符合OOP的思想，而且底层空间需要用户自己管理，稍不留神可能还会越界访问。\n</div>\n<h2>算法题使用</h2>\n<div>\n    在OJ中，有关字符串的题目基本以string类的形式出现，而且在常规工作中，为了简单、方便、快捷，基本都使用string类，很少有人去使用C库中的字符串操作函数\n</div>\n<p></p>\n<h1><strong>二、标准库中的</strong><strong>string</strong><strong>类</strong></h1>\n<h2><strong>string</strong><strong>类</strong></h2>\n<p>我们可以通过这个网址<a href=\"http://www.cplusplus.com/reference/string/string/?kw=string\" title=\"string - C++ Reference\">string - C++ Reference</a> 去了解彼岸准库中的string是怎样去定义。</p>\n<h2>string文档介绍</h2>\n<ul><li>1. 字符串是表示字符序列的类</li><li>2. 标准的字符串类提供了对此类对象的支持，其接口类似于标准字符容器的接口，但添加了专门用于操作单字节字符字符串的设计特性。</li><li>3. string类是使用char(即作为它的字符类型，使用它的默认char_traits和分配器类型(关于模板的更多信息，请参阅basic_string)。</li><li>4. string类是basic_string模板类的一个实例，它使用char来实例化basic_string模板类，并用char_traits 和allocator作为basic_string的默认参数(根于更多的模板信息请参考basic_string)。</li><li>5. 注意，这个类独立于所使用的编码来处理字节:如果用来处理多字节或变长字符(如UTF-8)的序列，这个类的所有成员(如长度或大小)以及它的迭代器，将仍然按照字节(而不是实际编码的字符)来操作。</li></ul>\n<div>\n<strong>总结： </strong>\n</div>\n<ul><li>1. string是表示字符串的字符串类</li><li>2. 该类的接口与常规容器的接口基本相同，再添加了一些专门用来操作string的常规操作。</li><li>3. string在底层实际是：basic_string模板类的别名，typedef basic_string&lt;char, char_traits, allocator&gt; string;</li><li>4. 不能操作多字节或者变长字符的序列。</li></ul>\n<div></div>\n<div>\n<strong>在使用string类时，必须包含#include&lt;string&gt;以及using namespace std; </strong>\n</div>\n<h2>string的底层简介</h2>\n<p>通过文档简介我们知道string的原生类是一个类模板，大致如下：</p>\n<div>\n<pre><code class=\"language-cpp\">typedef basic_string&lt;char&gt; string;\ntemplate&lt;class T&gt;\nclass basic_string\n{\nprivate:\n\tT* str;\n    //...\n};</code></pre>\n</div>\n<p><strong>我们不经想到，为什么字符串类型会是T，字符串类型不就是char类型吗，难道还有别的类型？</strong></p>\n<blockquote>\n<p>这个地方就与<strong>编码</strong>有关，计算机是由美国人发明的，早起计算机只是显示英文的。显示英文就比较的简单，单纯的需要26个英文字母进行组合就可以，算上大小写，及标点符号一共也就128个，去表示常见的英文绰绰有余。计算机存储英文（只有二进制）编码就是一个值与对应的符号建立映射关系，这个映射关系就叫做编码表。<strong>英文的编码表就是ASCII表，用来表示英文。</strong></p>\n</blockquote>\n<blockquote>\n<p><strong>ASCII码值的意思</strong>就是指：你表示的一个字符在内存当中存储的时候对应的那个整形值（用二进制存储的）</p>\n<p>eg1:大写字母A的ASCII码意思是在机器内存中是以数字65的2进制形式存放的。</p>\n</blockquote>\n<p>eg2：对这个字符串数组而言，实际上存的这些字符对应的值（语言规定字符串以\\0 结束）</p>\n<div>\n<pre><code class=\"language-cpp\">int main()\n{\n\tchar str[] = \"hello\";\n\treturn 0;\n}</code></pre>\n</div>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\d94bd246d9ad4c449445753bfc6b1603.png\"/></p>\n<p>后来为了<strong>计算机在全世界普及</strong>，不能仅仅只适用英语，由此出现了Unicode表示全世界文字编码表，同时Unicode又包含ASCII，utf-8,utf-16,utf-32等等。</p>\n<h2>中文的编码表</h2>\n<p>英文，每个字母对应一个值就可，而一个字节8个比特位，就有2^8个（256）状态，所以对于英文很容易就表示完了。如果用一个字符去表示一个中文，最多就只能表示256个汉字，这是远远不够的。一个字节不够，两个字节来凑，两个字节就有2^16种状态，就能表示65000多个汉字，但是如果表示一个汉字的比特位越多，就代表着汉字占的空间就越大，这是非常不好的，utf-8,就是将一些常见的汉字用2个字节去编写，生僻的字用3个或4个去编写，并且指定一系列的规则。不同值对应不同汉字...,Linux下默认的就是utf-8。</p>\n<blockquote>\n<p>eg:存的是对应的值，要显示的话用这些值去对应的表里去查</p>\n<div>\n<pre><code class=\"language-cpp\">int main()\n{\n\tchar str[] = \"喝水\";\n\treturn 0;\n}</code></pre>\n</div>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\b7b1ec6a7dd5463395bdb9f5463b0055.png\"/></p>\n<p>还有一个有意思的事情就是，我们对字符串++，文字的内容是会改变的 </p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\26ab3c2a76f14f7abf96b01912788ca3.png\"/></p>\n</blockquote>\n<p>所有的编译器都允许选编码，如果编译器的编码和你所写的对应不上就会出现乱码 windows在中国受众者多，所以给中文自己量身定做了编码表--gdk,windows下默认编码的就是gdk， </p>\n<blockquote>\n<p>基于一些编码的原因，有些字符串就会用两个字符去表示，所以就有了wchar_t;如果是有wchar_t,就建议使用wstring(匹配wchar_t)</p>\n<h2><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\aad3442b2d9542ea83e26d1e90036f5e.png\"/></h2>\n</blockquote>\n<h2>string的头文件</h2>\n<p><strong>string的头文件是#include&lt;string&gt;用的时候切记加上</strong></p>\n<p>如果不包头文件,这样写是可以编译通过的 </p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\c47f3432703a4ccc9387cd0987274420.png\"/></p>\n<p>但是使用流插入和流提取就会报错（VS2013） </p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\d84b0a5c94ca446eb782c8d1af38657d.png\"/></p>\n<p>可vs2019就不会</p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\da2a2c8bcaca4352ac730feb9b6248a0.png\"/></p>\n<p>博主还是建议包上这个头文件，有总比没有强。 </p>\n<h1><strong>三、string</strong><strong>类的常用接口说明 </strong> </h1>\n<h2>构造函数 </h2>\n<p><strong>打星的非常重要，其余可以了解</strong></p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\94f2cbad82bd41ffa91e28581fbb16b9.png\"/></p>\n<p>（1）无参构造，带参构造，拷贝构造  </p>\n<blockquote>\n<div>\n<pre><code class=\"language-cpp\">int main()\n{\n\tstring s1;  //无参构造\n\tstring s2(\"hello world\"); //带参的\n\tstring s3(s2); //拷贝构造\n\n\tcin &gt;&gt; s1;\n\tcout &lt;&lt; s1 &lt;&lt; endl;\n\tcout &lt;&lt; s2 &lt;&lt; endl;\n\tcout &lt;&lt; s3 &lt;&lt; endl;\n}</code></pre>\n</div>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\7b8f6fce580349ae8344b6194f7c604d.png\"/></p>\n</blockquote>\n<p>（2）</p>\n<div>\n<pre><code class=\"language-cpp\">string (const string&amp; str, size_t pos, size_t len = npos);</code></pre>\n</div>\n<p>    pos代表从那个位置开始 。len代表拷贝的长度，这个len给了一个缺省值npos,代表的就是从该位置取以后所有的字符直到结尾。<strong>ps:npos的值就是-1，-1给给无符号的就是整形的最大值（-1的补码是全1，给给无符号的就是整形的最大值）</strong> </p>\n<blockquote>\n<div>\n<pre><code class=\"language-cpp\">int main()\n{\n\tstring s2(\"hello world\"); //带参的\n\n\tstring s4(s2, 2, 6);\n\tcout &lt;&lt; s4 &lt;&lt; endl;\n}</code></pre>\n</div>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\738a01112c8440eb88c3ede1728e71c6.png\"/></p>\n<p>s4:从s2第二个位置开始，拷贝后面的6个字符。</p>\n<p>eg2:</p>\n<div>\n<pre><code class=\"language-cpp\">int main()\n{\n\tstring s2(\"hello world\"); //带参的\n\n\tstring s5(s2, 2, 100);\n\tcout &lt;&lt; s5 &lt;&lt; endl;\n\n\tstring s6(s2, 2);\n\tcout &lt;&lt; s6 &lt;&lt; endl;\n}</code></pre>\n</div>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\3a408670993a4602b1933a8620f1d51c.png\"/></p>\n<p>↑s5:从s2第二个位置开始，拷贝后面的100个字符。</p>\n<p> s6:从s2第二个位置开始，拷贝后面的所有个字符（证明缺省值npos）。</p>\n</blockquote>\n<p>(3) </p>\n<div>\n<pre><code class=\"language-cpp\">string (const char* s, size_t n);</code></pre>\n</div>\n<blockquote>\n<div>\n<pre><code class=\"language-cpp\">int main()\n{\n\tstring s2(\"hello world\"); //带参的\n\n\tstring s7(\"hello world\",3);\n\tcout &lt;&lt; s7 &lt;&lt; endl;\n}</code></pre>\n</div>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\d6e31c4ad5714422904ce95885bf2597.png\"/></p>\n<p>s7:去hello world 的前三个字母初始化</p>\n</blockquote>\n<p>（4）</p>\n<div>\n<pre><code class=\"language-cpp\">string (size_t n, char c);</code></pre>\n</div>\n<blockquote>\n<div>\n<pre><code class=\"language-cpp\">int main()\n{\n\tstring s8(10, '!'); //看起来有用实际没用\n\tcout &lt;&lt; s8 &lt;&lt; endl;\n}</code></pre>\n</div>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\374f541626914947a2848aaab32794f8.png\"/></p>\n<p>s8:用10个！初始化</p>\n</blockquote>\n<h2><strong>string</strong><strong>类对象的容量操作 </strong></h2>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\c14307c9317d4210bb8e3c0a1802d720.png\"/></p>\n<h3>(1)<strong> 计算对象的长度 size与lengh</strong></h3>\n<div>\n<pre><code class=\"language-cpp\">int main()\n{\n\tstring s1;\n\tcin &gt;&gt; s1;\n\n\t//不包含最后作为标识符的\\0,算的是有效字符的长度\n\tcout &lt;&lt; s1.size() &lt;&lt; endl;  //重要\n\tcout &lt;&lt; s1.length() &lt;&lt; endl; //了解\n}</code></pre>\n</div>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\0bf119ff86e04bf5abce3834fb0163bb.png\"/></p>\n<h3>(2) max_size</h3>\n<p><strong>功能：告诉我们这个字符串最长能有多长（与内存有关）</strong></p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\555403d5b8c141eab8eb1d3335e394c2.png\"/></p>\n<h3>(3)capacity</h3>\n<p><strong>功能：告诉我们这个字符串的容量有多大（就是最多能存多少个字符）</strong></p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\1978a65c98bf42eeaaa6e1401cdd8f69.png\"/></p>\n<p><strong>虽然显示的是15，但实际的空间是16，因为有个\\0, 但是容量指的是能存多少个有效字符。</strong></p>\n<h3>(4)clear </h3>\n<p><strong>功能：把有效数据都清理掉,空间保留</strong></p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\0f81fab01d814b3e83400ccded7e02f7.png\"/></p>\n<h3>(5)string的增容reserve与resize</h3>\n<blockquote>\n<p>以下是自动string自动扩容的一段程序，通过结果得出增容一般情况下会1.5倍的进行增容 </p>\n<div>\n<pre><code class=\"language-cpp\">void TestPushBcak()\n{\n\tstring s;\n\tsize_t sz = s.capacity();\n\tcout &lt;&lt; \"capacity changed: \" &lt;&lt; sz &lt;&lt; endl;\n\tcout &lt;&lt; \"making s grow:\\n\";\n\tfor (int i = 0; i &lt; 1000; ++i)\n\t{\n\t\ts += 'c';\n\t\tif (sz != s.capacity())\n\t\t{\n\t\t\tsz = s.capacity();\n\t\t\tcout &lt;&lt; \"capacity changed: \" &lt;&lt; sz &lt;&lt; endl;\n\t\t}\n\t}\n\n}\nint main()\n{\n\tTestPushBcak();\n}</code></pre>\n</div>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_15,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\f3936b5087d24814b31d9aab70d49172.png\"/></p>\n</blockquote>\n<p>但是每次增容都是有代价的，而且这个代价是不小的，如果你已经知道你需要多少空间，你是可以利用reserve减少增容的代价。</p>\n<blockquote>\n<p><strong>reserve 只开空间，影响容量，可以改变string的容量。</strong></p>\n<div>\n<pre><code class=\"language-cpp\">void TestPushBcak()\n{\n\tstring s;\n\ts.reserve(1000); //申请至少能存储1000个字符的空间\n\tsize_t sz = s.capacity();\n\tcout &lt;&lt; \"capacity changed: \" &lt;&lt; sz &lt;&lt; endl;\n\tcout &lt;&lt; \"making s grow:\\n\";\n\tfor (int i = 0; i &lt; 1000; ++i)\n\t{\n\t\ts += 'c';\n\t\tif (sz != s.capacity())\n\t\t{\n\t\t\tsz = s.capacity();\n\t\t\tcout &lt;&lt; \"capacity changed: \" &lt;&lt; sz &lt;&lt; endl;\n\t\t}\n\t}\n}\nint main()\n{\n\tTestPushBcak();\n}</code></pre>\n</div>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\7e3590e71cff4118981a39f1aed6ee7c.png\"/></p>\n</blockquote>\n<p><strong>resize 是将字符串中的有效字符个数改为n个，当字符个数增多时，会对多出来的空间给一个初始值，进行初始化，默认初始值是 /0 ;</strong></p>\n<blockquote>\n<p>开始s1 里面的size是0，capacity是15</p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\eba188f092a14d799b51d0fb05cd0936.png\"/></p>\n<p>使用resize后，size被扩成了100，capacity因为size的改变而改变，且这100个size都填充成立 /0 .</p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\ac7d4241c49049448cf04a428901a9c4.png\"/></p>\n</blockquote>\n<blockquote>\n<p>resize也可以自定义初始值</p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\bf392ca4c18b4dca802840970c0529b8.png\"/></p>\n</blockquote>\n<p><strong>reserve与rsize的异同 </strong></p>\n<blockquote>\n<p>reserve只是单纯的改变容量，rsize是改变有效字符个数，进而改变容量，并且会对改变的有效字符个数进行初始化</p>\n<div>\n<pre><code class=\"language-cpp\">void Test()\n{\n\tstring s1;\n\ts1.reserve(100);\n\n\tstring s2;\n\ts2.resize(100);\n}\nint main()\n{\n\tTest();\n}</code></pre>\n</div>\n<p> <img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\5f675dab81e547f89189381c8a06f4ec.png\"/></p>\n</blockquote>\n<p></p>\n<blockquote>\n<p> 用reserve和resize进行扩容并不会影响之前的数据</p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\a51ab85a5ec14ff48db61db9843c2a7c.png\"/></p>\n<p>但是如果用resize缩小size就会删除数据 </p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\07966b25406544a4a43b985dc8861d37.png\"/></p>\n</blockquote>\n<p><strong>对于string而言reserve更有用。</strong></p>\n<h3><strong>(7) empty</strong></h3>\n<p><strong>功能：判断字符串是否为空</strong></p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\80b5ad130fe342c2ad165fa9dca4046c.png\"/></p>\n<p></p>\n<h2><strong>string</strong><strong>类对象的访问及遍历操作</strong></h2>\n<h3><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\328a3030c0104cb3b511e507ee56e774.png\"/>(1)<strong>operator [ ]  对字符串进行遍历</strong> </h3>\n<div>\n<pre><code class=\"language-cpp\">char&amp; operator[] (size_t pos);\nconst char&amp; operator[] (size_t pos) const;</code></pre>\n</div>\n<blockquote>\n<p> eg1:遍历字符</p>\n<div>\n<pre><code class=\"language-cpp\">int main()\n{\n\tstring s1(\"hello world\");\n\tfor (size_t i = 0; i &lt; s1.size(); i++) //读每个位置的字符\n\t{\n\t\t//cout &lt;&lt; s1.operator[](i) &lt;&lt; \" \";//本质调用\n\t\tcout &lt;&lt; s1[i] &lt;&lt; \" \";\n\t}\n\tcout &lt;&lt; endl;\n}</code></pre>\n</div>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\79af68e88d114d65943a5487be878416.png\"/></p>\n<p> eg2: 修改字符，每个字符+1后都改变了</p>\n<div>\n<pre><code class=\"language-cpp\">int main()\n{\n\tstring s1(\"hello world\");\n\tfor (size_t i = 0; i &lt; s1.size(); i++) //读每个位置的字符\n\t{\n\t\t//cout &lt;&lt; s1.operator[](i) &lt;&lt; \" \";//本质调用\n\t\tcout &lt;&lt; s1[i] &lt;&lt; \" \";\n\t}\n\tcout &lt;&lt; endl;\n\tfor (size_t i = 0; i &lt; s1.size(); i++) //写每个位置的字符,operator[]的返回值是这个地方的引用\n\t{\n\t\ts1[i] += 1;\n\t}\n\tcout &lt;&lt; endl;\n\tcout &lt;&lt; s1 &lt;&lt; endl;\n}</code></pre>\n</div>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\388fbb35f41146caa3a02d798d65e419.png\"/></p>\n<p><strong>为什呢能进行修改呢？</strong></p>\n<p>因为[ ] 的返回值是char 类型的引用。</p>\n<div>\n<pre><code class=\"language-cpp\">//实际底层实现\nchar&amp; operator[](size_t pos)\n{\n   //...\t\n   return _str[pos];\n}\n//底层是一个字符串数组，如果想修改第i个位置的字符，就返回这第[i]个位置的引用</code></pre>\n</div>\n<p>编译器编译会转换成是 s1.operator[](i),然后这个函数调用会有一个返回值，这个返回值是第i个位置那个字符的引用，对他加等，赋值就可以修改第i的值,所以这里的引用是为了修改这个地方的值，出了作用域这个对象还在，因为这个数组是开在堆上的，堆上出了作用域不受影响</p>\n<p><strong>这里的引用返回不是为了减少拷贝，而是为了支持修改对象</strong></p>\n</blockquote>\n<h3>(2)迭代器进行遍历</h3>\n<p>用法及说明：</p>\n<blockquote>\n<p>eg:修改及遍历字符</p>\n<div>\n<pre><code class=\"language-cpp\">int main()\n{\n\tstring s1(\"hello world\");\n\tstring::iterator it = s1.begin();\n\twhile (it != s1.end())\n\t{\n\t\tcout &lt;&lt; *it &lt;&lt; \" \";\n\t\t++it;\n\t}\n\tcout &lt;&lt; endl;\n\n\tit = s1.begin();\n\twhile (it != s1.end())\n\t{\n\t\t*it += 1;\n\t\t++it;\n\t}\n\tcout &lt;&lt; endl;\n\n\tit = s1.begin();\n\twhile (it != s1.end())\n\t{\n\t\tcout &lt;&lt; *it &lt;&lt; \" \";\n\t\t++it;\n\t}\n\n}</code></pre>\n</div>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\7afe5b4df78f402899089231b08c84f1.png\"/></p>\n<p>it是一个像指针一样的东西，但是它又不一定是个指针，在这可以认为是个指针。这个迭代器是内嵌类型是在string类里面定义的，所以要指定类域。</p>\n<p>把迭代器想象成像指针一样的类型</p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\ede74fce8c734fad9ebc80c4afb0daba.png\"/></p>\n</blockquote>\n<p>PS：第二次调用it的时候,就不用在写string::iterator了，不用定义it了，但还是得重给他初始化。</p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\13837b7ecd4b4c138bcc5f80976ff72f.png\"/></p>\n<h3>(3) 范围for 自动往后迭代，自动判断结束（C++11才支持） </h3>\n<blockquote>\n<p>  eg1:遍历字符</p>\n<div>\n<pre><code class=\"language-cpp\">int main()\n{\n\tstring s1(\"hello world\");\n\tfor (auto e : s1)\n\t{\n\t\tcout &lt;&lt; e &lt;&lt; \" \";\n\t}\n}</code></pre>\n</div>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\ee66643c66fe42db9075b8ebd7b46146.png\"/></p>\n<p> eg2:修改字符</p>\n<div>\n<pre><code class=\"language-cpp\">int main()\n{\n\tstring s1(\"hello world\");\n\tfor (auto e : s1)\n\t{\n\t\tcout &lt;&lt; e &lt;&lt; \" \";\n\t}\n\tcout &lt;&lt; endl;\n\tfor (auto&amp; e : s1)\n\t{\n\t\te += 1;\n\t}\n\tfor (auto e : s1)\n\t{\n\t\tcout &lt;&lt; e &lt;&lt; \" \";\n\t}\n}</code></pre>\n</div>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\08401e02b3cd4cabb01bf88a94d9fa75.png\"/></p>\n<p></p>\n</blockquote>\n<h3>(4) 反向迭代器 倒着遍历 </h3>\n<blockquote>\n<div>\n<pre><code class=\"language-cpp\">int main()\n{\n\tstring s1(\"hello world\");\n\tstring::reverse_iterator rit = s1.rbegin();\n\twhile (rit != s1.rend())\n\t{\n\t\tcout &lt;&lt; *rit &lt;&lt; \" \";\n\t\t++rit;\n\t}\n}</code></pre>\n</div>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\f03ee262fc8947e0b340b4c1189fdc7b.png\"/> <img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\1fe24f6afa4243179769e6c174eea257.png\"/></p>\n<p></p>\n</blockquote>\n<p>ps：用auto自动推到出它是迭代器也是可以的</p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\fe9990dbc1f645d0b2b1a7375eb3b9f4.png\"/></p>\n<p> <img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\c67c010f1f7d4cfd910e7dbbd7fe9a3e.png\"/></p>\n<p><strong>问题1：迭代器遍历的意义是什么呢？</strong></p>\n<blockquote>\n<p>对于string，无论正着遍历还是倒着遍历，下标+[ ]都足够好用，为什么还需要迭代器呢？对于string来说下标和 [ ] 就足够好用，确实可以不用迭代器。但是对于其他容器（数据结构）呢？</p>\n<p>迭代器的意义就在于所有的容器都可以使用迭代器这种方法去修改访问。而且你会了一种容器的迭代器，其他容器的迭代器就差不多都会了。所以对于string，你得会用迭代器，但是对于string来说，一般我们还是喜欢下标+[ ]。</p>\n<p>eg：list，map/set,不支持下标+ [ ] 遍历</p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\410c29dfc6c74a07ae39861607de8e43.png\"/></p>\n</blockquote>\n<p><strong>问题2：使用迭代器的时候是否能将 != 改为 &lt; 或者  &gt; ？</strong></p>\n<blockquote>\n<p>答案：对于string来说是可以的，因为它的底层就是数组，但是对于其他容器来讲就是不行的所以建议用 != ,不建议用&gt;或者&lt;.  以链表为例，对于链表来说后面的地址不一定比前面的地址大。</p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\73547aa7cfc44bfdaf3969a892c34cb2.png\"/> <img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\39c240fe2bec4f4988797b9bfe5e2633.png\"/></p>\n</blockquote>\n<p></p>\n<h3>(5)const 迭代器   </h3>\n<blockquote>\n<p>正向迭代器和反向迭代器都提供了const 版本，为什么呢？</p>\n<p>为的就是提供给const对象是用。</p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_16,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\fb4f852480744a61b0aec2050c1eaf7f.png\"/></p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_19,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\0b7613c76f7d4f259dc2bc712f2a50c1.png\"/></p>\n</blockquote>\n<p>eg:对于下面这种函数</p>\n<blockquote>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_18,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\2dac052954bb40dca6ec09bedc287b93.png\"/>     </p>\n<p>s是被const修饰的只能读不能改，如果用普通的迭代器，就会报错，const begin返回的是const_iterator而这里返回的却是iterator所以报错。</p>\n<p>正确写法:</p>\n<div>\n<pre><code class=\"language-cpp\">void fun(const string&amp; s)\n{\n\t\n\tstring::const_iterator it = s.begin();\n\twhile(it != s.end())\n\t{\n\t\tcout &lt;&lt; *it &lt;&lt;\" \";\n\t\tit++;\n\t}\n\n}\nint main()\n{\n\tstring str(\"hello\");\n\tfun(str);\n}</code></pre>\n</div>\n<p> <img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\ef814b7a032f4a9283f6802d894ee7b5.png\"/></p>\n<p>同样也不能对他进行修改了 <img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\790f859c49dc4b4e8cafe5f950481b7d.png\"/></p>\n<p>同样可以写成auto让他自动推导 </p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_18,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\00539cbeb1dd42c28c9cffe3386211ea.png\"/></p>\n</blockquote>\n<h3>(6) at</h3>\n<p>功能和operator[]是一毛一样的.</p>\n<blockquote>\n<div>\n<pre><code class=\"language-cpp\">int main()\n{\n\tstring s1(\"hello world\");\n\tfor (size_t i = 0; i &lt; s1.size(); i++) //读每个位置的字符\n\t{\n\t\t\n\t\tcout &lt;&lt; s1.at(i) &lt;&lt; \" \";\n\t}\n\tcout &lt;&lt; endl;\n\tfor (size_t i = 0; i &lt; s1.size(); i++) \n\t{\n\t\ts1.at(i)+= 1;\n\t}\n\tcout &lt;&lt; endl;\n\tcout &lt;&lt; s1 &lt;&lt; endl;\n\n}</code></pre>\n</div>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\a6388ad5038646e1a959896515714563.png\"/></p>\n</blockquote>\n<p>at与operator[ ]的区别 </p>\n<blockquote>\n<p>at与operator[ ]  的区别在于检查越界的方式不一样<br/> operator[]检查异常的错误是断言。at检查错误的方式是抛异常，一般用operator []</p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\aec1aa0cdeb440f88edb47401200f3f9.png\"/></p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\93086a4681a145d28f71b0aafb42a033.png\"/></p>\n</blockquote>\n<h2><strong>string</strong><strong>类对象的修改操作 </strong></h2>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\81dff3fb2db74594b0ca2fe85d4c6f96.png\"/></p>\n<h3>(1)插入字符</h3>\n<blockquote>\n<p> push_back 插入一个字符</p>\n<p> append  插入字符串</p>\n<p> += 插入字符串或者插入一个完整字符</p>\n</blockquote>\n<div>\n<pre><code class=\"language-cpp\">int main()\n{\n\tstring s1;\n\ts1.push_back('a'); //插入一个字符\n\n\ts1.append(\"abcd\");\n\tcout &lt;&lt; s1 &lt;&lt;endl;\n\n\ts1 += ':';\n\ts1 += \"hahahh\";\n\tcout &lt;&lt; s1 &lt;&lt; endl; //插入直接推荐用+=，其他两个了解一下\n}</code></pre>\n</div>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\f28e395debb34753a122b47163b25c10.png\"/></p>\n<div>\n<strong>   在string尾部追加字符时，s.push_back(c) / s.append(1, c) / s += 'c'三种的实现方式差不多，一般</strong>\n<strong>情况下string类的+=操作用的比较多，+=操作不仅可以连接单个字符，还可以连接字符串。</strong>\n</div>\n<p></p>\n<h3>(2) c_str</h3>\n<blockquote>\n<div>\n<pre><code class=\"language-cpp\">int main()\n{\n\tstring s(\"hello world\");\n\tcout &lt;&lt; s &lt;&lt; endl;\n\tcout &lt;&lt; s.c_str() &lt;&lt; endl;\n}</code></pre>\n</div>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\c64d3bd5fbf94e94bc440a1e603089dc.png\"/></p>\n<p>这两个s虽然输出结果一样但是意义不一样，<strong>c_str返回c格式的字符串</strong></p>\n</blockquote>\n<p>实际当中也很有意义：</p>\n<ol><li> 要跟C库里面的函数结合，就用它。</li><li> 假如有个file的字符串是用string来存的，想用C语言的形式打开一个文件</li></ol>\n<blockquote>\n<p> eg:打开文件</p>\n<div>\n<pre><code class=\"language-cpp\">int main()\n{\n\t//要跟C库里面的函数结合，就用它\n\tstring file(\"test.txt\"); //假如有个file的字符串是用string来存的，想用C语言的形式打开一个文件\n\t//FILE* fout=fopen(file, \"w\"); //如果给file参数是匹配不上的,因为fopen的第一个参数必须是const char*\n\tFILE* fout = fopen(file.c_str(), \"w\");\n}</code></pre>\n</div>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\a72e7f2abd1d4ec588e335a1ddb937a8.png\"/></p>\n<p> 直接传是不行的，因为fopen的第一个参数必须是const char*。这时候借助c_str就行了</p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\4845f1a61b39484ab8088470cb5cb393.png\"/></p>\n</blockquote>\n<h3>(3) find与rfind及substr</h3>\n<blockquote>\n<p>find 有以下四种重载</p>\n<div>\n<pre><code class=\"language-cpp\">size_t find (const string&amp; str, size_t pos = 0) const;\nsize_t find (const char* s, size_t pos = 0) const;\nsize_t find (const char* s, size_t pos, size_t n) const;\nsize_t find (char c, size_t pos = 0) const;</code></pre>\n</div>\n<p><strong>find判别方法</strong>：如果找到了，返回的是第一个找到这个字符的位置的下标，如果没找到返回的就是npos（42亿9千万的位置）取出找到的字符就要用到<strong>substr。</strong></p>\n</blockquote>\n<blockquote>\n<p><strong>substr</strong>：从pos这个位置开始，取len个字符（len给npos的缺省值）</p>\n<div>\n<pre><code class=\"language-cpp\">string substr (size_t pos = 0, size_t len = npos) const;</code></pre>\n</div>\n</blockquote>\n<p>先介绍最后一个：比如说对上面这个file要求取出文件的后缀，先用find找到<strong> . </strong>再用substr提取出<strong>.</strong>后面的内容 。 </p>\n<blockquote>\n<div>\n<pre><code class=\"language-cpp\">int main()\n{\n\tstring file(\"test.txt\"); \n\tFILE* fout = fopen(file.c_str(), \"w\");\n\t\n\t//要求取出文件的后缀\n\tsize_t pos = file.find(\".\");\n\tif (pos != string::npos)\n\t{\n\t\t//从当前位置开始去len个字符串\n\t\t//string suffix = file.substr(pos,file.size()-pos);\n\t\tstring suffix = file.substr(pos);\n\t\tcout &lt;&lt; suffix &lt;&lt; endl;\n\t}\n\n}</code></pre>\n</div>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\b3ee712e1f7d45ae9eb2000734b7f7ed.png\"/></p>\n<p>ps:长度计算原理</p>\n<p>1.0 len=file.size()-pos;</p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_17,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\0f96b6cb776443a4ae689946c75d019c.png\"/></p>\n<p>2.0 当然也可以不用计算len，利用len的缺省值npos,自动把后面全取完</p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\adc936644233493b82b53eaf9844d34a.png\"/></p>\n</blockquote>\n<p>    如果对于下面这段代码呢 ？具有连续后缀，find使用起来就相对困难，这时候就可以使用rfind进行倒着取（从右往左去找），用法与刚才类似。 </p>\n<blockquote>\n<div>\n<pre><code class=\"language-cpp\">int main()\n{\n\n\tstring file(\"test.txt.zip\");\n\tFILE* fout = fopen(file.c_str(), \"w\");\n\n\t//要求取出文件的后缀\n\tsize_t pos = file.rfind(\".\");\n\tif (pos != string::npos)\n\t{\n\t\t//从当前位置开始去len个字符串\n\t\t//string suffix = file.substr(pos,file.size()-pos);\n\t\tstring suffix = file.substr(pos);\n\t\tcout &lt;&lt; suffix &lt;&lt; endl;\n\t}\n\n}</code></pre>\n</div>\n<p> <img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\c9565eb479ec4ef29179ccf93fae52f7.png\"/></p>\n</blockquote>\n<p></p>\n<p>  对于网址一般有三部分构成，协议/域名/统一资源定位假设要求要把这三个部分解析出来那又该怎么办呢？ </p>\n<p> 就比如对博主博客的网址进行解析：</p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\30ae34ced1b348cd901b92ae41ae8007.png\"/></p>\n<blockquote>\n<p> 1.0 提取协议http或者https就叫做协议，所以找到带一个：即可</p>\n<pre><code class=\"language-cpp\">\tsize_t pos1 = url.find(\":\");\n\tstring protocol = url.substr(0, pos1 - 0);\n\tcout &lt;&lt; protocol &lt;&lt; endl;</code></pre>\n<p>2.0 提取域名就要直到中间的斜杠/  ,这时候就要借助find的另一个功能，从指定位置开始查找</p>\n<p>因为协议的格式是固定的，所以要从：后的第三个位置开始查找斜杠 /</p>\n<pre><code class=\"language-cpp\">size_t find (const string&amp; str, size_t pos = 0) const;</code></pre>\n<pre><code class=\"language-cpp\">\tsize_t pos2=url.find('/',pos1+3 );\n\tstring domain = url.substr(pos1 + 3, pos2 - (pos1 + 3));\n\tcout &lt;&lt; domain &lt;&lt; endl;</code></pre>\n<p>3.0 uri就是最后剩余的，比较简单，直接默认提取出全部字符串即可 </p>\n<pre><code class=\"language-cpp\">\tstring uri = url.substr(pos2+1);\n\tcout &lt;&lt; uri &lt;&lt; endl;</code></pre>\n<p><code class=\"language-cpp\">完整过程：</code></p>\n<pre><code class=\"language-cpp\">int main()\n{\n\tstring url(\"https://mp.csdn.net/mp_blog/creation/editor/123482486\");\n\t//对于网址，协议/\n\tsize_t pos1 = url.find(\":\");\n\tstring protocol = url.substr(0, pos1 - 0);\n\tcout &lt;&lt; protocol &lt;&lt; endl;\n\n\tsize_t pos2=url.find('/',pos1+3 );\n\tstring domain = url.substr(pos1 + 3, pos2 - (pos1 + 3));\n\tcout &lt;&lt; domain &lt;&lt; endl;\n\n\tstring uri = url.substr(pos2+1);\n\tcout &lt;&lt; uri &lt;&lt; endl;\n\n}</code></pre>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\88fc55566af443a59bd7c9acf995657a.png\"/></p>\n<p></p>\n</blockquote>\n<h3>(4)insert</h3>\n<p><strong>不到万不得已，不建议使用，因为时间复杂度是O(N)，效率太低</strong></p>\n<blockquote>\n<p><strong>insert的三种重载</strong></p>\n<pre><code class=\"language-cpp\">string&amp; insert (size_t pos, size_t n, char c);\niterator insert (iterator p, char c);\nstring&amp; insert (size_t pos, const string&amp; str);</code></pre>\n</blockquote>\n<p>eg:头插 </p>\n<blockquote>\n<pre><code class=\"language-cpp\">int main()\n{\n\tstring s(\"hello world\");\n\tcout &lt;&lt; s &lt;&lt; endl;\n\ts.insert(0,1,'x'); //插入一个字符\n\tcout &lt;&lt; s &lt;&lt; endl;\n\ts.insert(s.begin(), 'y');//插入一个字符，用迭代器\n\tcout &lt;&lt; s &lt;&lt; endl;\n\ts.insert(0, \"hahaha\");//插入一个字符串\n\tcout &lt;&lt; s &lt;&lt; endl;\n}</code></pre>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\1e2282747530460c994da924c41b47c8.png\"/></p>\n</blockquote>\n<p>eg:从中间位置进行插入  </p>\n<blockquote>\n<pre><code class=\"language-cpp\">int main()\n{\n\tstring s(\"hello world\");\n\tcout &lt;&lt; s &lt;&lt; endl;\n\ts.insert(0, 2, 'x'); //插入2个字符\n\tcout &lt;&lt; s &lt;&lt; endl;\n\ts.insert(3, \"!!!!\"); //从第3个位置插入字符串\n\tcout &lt;&lt; s &lt;&lt; endl;\n}</code></pre>\n<p> <img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\27b27e96e3d94108bd261be8179630a3.png\"/></p>\n</blockquote>\n<h3>(5)erase</h3>\n<p><strong>删除中间和头部位置同样不建议使用，因为效率低.</strong></p>\n<blockquote>\n<p><strong>erase的函数定义</strong></p>\n<pre><code class=\"language-cpp\"> string&amp; erase (size_t pos = 0, size_t len = npos);</code></pre>\n</blockquote>\n<p>eg:  </p>\n<blockquote>\n<pre><code class=\"language-cpp\">int main()\n{\n\tstring s(\"hello world\");\n\tcout &lt;&lt; s &lt;&lt; endl;\n\ts.erase(0, 1); //将头上第一个字符删掉想\n\tcout &lt;&lt; s &lt;&lt; endl;\n\ts.erase(s.size() - 1, 1);\n\tcout &lt;&lt; s &lt;&lt; endl;  //将尾部的一个字符删除\n\ts.erase(3); //保留了前三个字符。因为后面都删完了\n\tcout &lt;&lt; s &lt;&lt; endl;\n}</code></pre>\n<p> <img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_19,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\170a2449773641aa9e43550f17733038.png\"/></p>\n</blockquote>\n<h2>string类非成员函数</h2>\n<h3><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\487655d35c7c4e108b187a3073191d8f.png\"/>(1)operator + </h3>\n<p>与+=实现的功能相同，只不过+不会改变本身</p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\455cf19a826145238f8b5320e8ee0595.png\"/></p>\n<div>\n<strong>PS：建议尽量少用，因为传值返回，导致深拷贝效率低</strong>\n</div>\n<h3>(2) 流提取和流插入</h3>\n<p>支持直接输入输出字符串</p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\7783252583d7446b82c2dd781159a9eb.png\"/></p>\n<h3>(3)比较大小</h3>\n<blockquote>\n<p>支持string与string比较，也支持自定义类型与string比较，如果是真返回1，如果是假返回0.</p>\n<pre><code class=\"language-cpp\">int main()\n{\n\tstring s1(\"hello world\");\n\tstring s2(\"hello\");\n\n\tcout &lt;&lt;( s1 &gt; s2 )&lt;&lt; endl;\n\n\tcout &lt;&lt; (\"world\" &gt; s1) &lt;&lt; endl;\n\n\tcout &lt;&lt; (s1 &lt; \"hhhhhhhh\") &lt;&lt; endl;\n}</code></pre>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\5f103f8d68cc46c7b62c79a849a8c487.png\"/></p>\n<p>实际中经常用的还是string与string比，剩下的不常用</p>\n</blockquote>\n<h3>(4)stoi(string to int)</h3>\n<p>功能：将字符串类型转成整形</p>\n<blockquote>\n<p>stoi定义：给一个字符串将它转化成整形，后面两个参数不用管，我们用默认缺省即可</p>\n<pre><code class=\"language-cpp\">int stoi (const string&amp;  str, size_t* idx = 0, int base = 10);</code></pre>\n</blockquote>\n<blockquote>\n<p>eg：</p>\n<pre><code class=\"language-cpp\">int main()\n{\n\tstring _str(\"1234\");\n\tint val = stoi(_str);\n\tcout &lt;&lt; val &lt;&lt; endl;\n}</code></pre>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\4205141a56804a889b10edaeb7adac8a.png\"/></p>\n</blockquote>\n<h3>(5)to_string</h3>\n<blockquote>\n<p>to_string定义（有多个重载）</p>\n<p>功能：将整形，浮点型等等转成字符串</p>\n<pre><code class=\"language-cpp\">string to_string (int val);\nstring to_string (long val);\nstring to_string (long long val);\nstring to_string (unsigned val);\nstring to_string (unsigned long val);\nstring to_string (unsigned long long val);\nstring to_string (float val);\nstring to_string (double val);\nstring to_string (long double val);</code></pre>\n</blockquote>\n<p>eg: </p>\n<blockquote>\n<pre><code class=\"language-cpp\">int main()\n{\n\tstring pi = \"pi is \" + to_string(3.1415926);\n\tstring str = to_string(3.1415926);\n\tcout &lt;&lt; str &lt;&lt; endl;\n\tcout &lt;&lt; pi &lt;&lt; '\\n';\n\t\n\treturn 0;\n}</code></pre>\n<p>通过监视我们可以看出确实被准换成了字符串，ps:浮点型准换默认保留小数点后六位 </p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\d884919a03f849e9bde4ee544c303025.png\"/></p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\afc25a5dc9d442ea86808b7d1001b56f.png\"/></p>\n</blockquote>\n<h3>(6)getline</h3>\n<p>功能：获取一行字符串,它的好处在于能接受到空格</p>\n<blockquote>\n<p>getline定义：</p>\n<pre><code class=\"language-cpp\">istream&amp; getline (istream&amp; is, string&amp; str, char delim);\nistream&amp; getline (istream&amp; is, string&amp; str);</code></pre>\n</blockquote>\n<p>eg: getline可以接受空格</p>\n<p> <img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\05980d00e28a451094315d96bd3fad0e.png\"/></p>\n<p> cin接受不了空格</p>\n<p><img alt=\"watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2xzLWV2ZA==,size_20,color_FFFFFF,t_70,g_se,x_16\" src=\"image\\3b5761b10b734a2aab40440aed5865e0.png\"/></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n</div>\n</div>"}