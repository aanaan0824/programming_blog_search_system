{"blogid": "123636501", "writerAge": "码龄5年", "writerBlogNum": "33", "writerCollect": "26", "writerComment": "0", "writerFan": "12", "writerGrade": "3级", "writerIntegral": "446", "writerName": "XiaoGuaiSs", "writerProfileAdress": "writer_image\\profile_123636501.jpg", "writerRankTotal": "46340", "writerRankWeekly": "286070", "writerThumb": "14", "writerVisitNum": "34558", "blog_read_count": "1497", "blog_time": "已于 2022-03-23 11:56:11 修改", "blog_title": "四、仓储模式", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h3>一、什么是仓储(Respository)</h3>\n<p>仓储(Respository)是存在于工作单元和数据库之间单独分离出来的一层，是对数据访问的封装。其优点：</p>\n<p>　　　　1）业务层不需要知道它的具体实现，达到了分离关注点。</p>\n<p>　　　　2）提高了对数据库访问的维护，对于仓储的改变并不会改变业务的逻辑，数据库可以用Sql Server（该系列博客使用）、MySql等。</p>\n<h3>二、目录结构</h3>\n<p><img alt=\"\" height=\"167\" src=\"image\\dc6a964d604d447a976d10f57c5cdd2b.png\" width=\"312\"/></p>\n<h3>三、目录解析</h3>\n<p>        1、<strong>Common:公共层</strong>：用于封装一些常用公用方法</p>\n<p>        2、<strong>Models数据层</strong>：用于存放数据库对应的实体类与一些自定义实体类。一般在前端接口中，都需要固定的数据返回格式，就定义了下面的ResultModel.cs</p>\n<pre><code class=\"language-cs\">namespace Model\n{\n    /// &lt;summary&gt;\n    /// 通用返回信息类\n    /// &lt;/summary&gt;\n    public class ResultModel&lt;T&gt;\n    {\n        /// &lt;summary&gt;\n        /// 状态码\n        /// &lt;/summary&gt;\n        public int Code { get; set; } = 0;\n        /// &lt;summary&gt;\n        /// 返回信息\n        /// &lt;/summary&gt;\n        public string Msg { get; set; } = \"\";\n        /// &lt;summary&gt;\n        /// 数据行数\n        /// &lt;/summary&gt;\n        public int? Count { get; set; } = 0;\n        /// &lt;summary&gt;\n        /// 返回数据集合\n        /// &lt;/summary&gt;\n        public T? Data { get; set; } = default;\n\n        /// &lt;summary&gt;\n        /// 成功\n        /// &lt;/summary&gt;\n        /// &lt;returns&gt;&lt;/returns&gt;\n        public ResultModel&lt;T&gt; Success(T? t = default, int? c = 0)\n        {\n            return new ResultModel&lt;T&gt;\n            {\n                Code = 200,\n                Msg = \"Success\",\n                Count = c,\n                Data = t\n            };\n        }\n\n        /// &lt;summary&gt;\n        /// 错误\n        /// &lt;/summary&gt;\n        /// &lt;returns&gt;&lt;/returns&gt;\n        public ResultModel&lt;T&gt; Error(string m = \"Error\")\n        {\n            return new ResultModel&lt;T&gt;\n            {\n                Code = 400,\n                Msg = m,\n                Count = 0\n            };\n        }\n\n        /// &lt;summary&gt;\n        /// 找不到\n        /// &lt;/summary&gt;\n        /// &lt;returns&gt;&lt;/returns&gt;\n        public ResultModel&lt;T&gt; NotFound()\n        {\n            return new ResultModel&lt;T&gt;\n            {\n                Code = 404,\n                Msg = \"NotFound\",\n            };\n        }\n\n        /// &lt;summary&gt;\n        /// 异常\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"ex\"&gt;&lt;/param&gt;\n        /// &lt;returns&gt;&lt;/returns&gt;\n        public ResultModel&lt;T&gt; Exception(Exception ex)\n        {\n            //可以写个异常日志（用于测试，就没写）\n            return new ResultModel&lt;T&gt;\n            {\n                Code = 500,\n                Msg = ex.Message,\n                Count = 0\n            };\n        }\n    }\n}</code></pre>\n<p></p>\n<p></p>\n<p>         3、<strong>IRepository和 Repository ：仓储层</strong>，负责数据的CRUD（增删改查）。Repository 是一个独立的层，介于领域层与数据映射层（数据访问层）之间。它的存在让领域层感觉不到数据访问层的存在，它提供一个类似集合的接口提供给领域层进行领域对象的访问。</p>\n<p>我们定义了IRepository层，提供了所有的操作接口,这里简单定义一个测试接口</p>\n<pre><code class=\"language-cs\">    public interface ITestRepository\n    {\n        /// &lt;summary&gt;\n        /// 求和\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"i\"&gt;&lt;/param&gt;\n        /// &lt;param name=\"j\"&gt;&lt;/param&gt;\n        /// &lt;returns&gt;&lt;/returns&gt;\n        int Sum(int i, int j);\n    }</code></pre>\n<p>然后再在 TestRepository.cs 中去实现该接口，记得要添加引用。</p>\n<pre><code class=\"language-cs\">    public class TestRepository : ITestRepository\n    {\n\n        public int Sum(int i, int j)\n        {\n            return i + j;\n        }\n    }</code></pre>\n<p>        4、<strong>IServices和 Service：</strong>业务逻辑层，和我们三层架构中的BLL很相似，只负责调用仓储层的数据操作和做一定的逻辑处理，至于是如何与数据库进行交互的就不用他去管，这样可以达到一定程度的解耦，例如公司需要更换数据库从SQLSERVER到MySQL，那Service层就不需要做任何变动了。</p>\n<pre><code class=\"language-cs\">    public interface ITestService\n    {\n        /// &lt;summary&gt;\n        /// 求和\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"i\"&gt;&lt;/param&gt;\n        /// &lt;param name=\"j\"&gt;&lt;/param&gt;\n        /// &lt;returns&gt;&lt;/returns&gt;\n        int Sum(int i, int j);\n    }</code></pre>\n<p>然后再在 TestService 中去实现该接口</p>\n<pre><code class=\"language-cs\">    public class TestServic : ITestService\n    {\n        ITestRepository test = new TestRepository();\n        public int Sum(int i, int j)\n        {\n            return test.Sum(i, j);\n        }\n    }</code></pre>\n<p>然后再到接口处调用即可</p>\n<pre><code class=\"language-cs\">        /// &lt;summary&gt;\n        /// 求和\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"i\"&gt;&lt;/param&gt;\n        /// &lt;param name=\"j\"&gt;&lt;/param&gt;\n        /// &lt;returns&gt;&lt;/returns&gt;\n        [HttpGet]\n        public int Sum(int i, int j)\n        {\n            ITestService testService = new TestService();\n            return testService.Sum(i, j);\n        }</code></pre>\n<p></p>\n</div>\n</div>"}