{"blogid": "123749696", "writerAge": "码龄1年", "writerBlogNum": "62", "writerCollect": "231", "writerComment": "21", "writerFan": "12", "writerGrade": "3级", "writerIntegral": "710", "writerName": "nilmao", "writerProfileAdress": "writer_image\\profile_123749696.jpg", "writerRankTotal": "64932", "writerRankWeekly": "364177", "writerThumb": "69", "writerVisitNum": "85973", "blog_read_count": "6259", "blog_time": "于 2022-03-26 21:23:58 发布", "blog_title": "var 、let 和 const 的区别", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<ul><li> <p>var 声明的范围是函数作用域，let 和 const 声明的范围是块作用域</p> </li><li> <p>var 声明的变量会被提升到函数作用域的顶部，let 和 const 声明的变量不存在提升，且具有暂时性死区特征</p> </li><li> <p>var 允许在同一个作用域中重复声明同一个变量，let 和 const 不允许</p> </li><li> <p>在全局作用域中使用 var 声明的变量会成为 window 对象的属性，let 和 const 声明的变量则不会</p> </li><li> <p>const 的行为与 let 基本相同，唯一 一个重要的区别是，使用 const 声明的变量必须进行初始化，且不能被修改</p> </li></ul>\n<table><tbody><tr><th>关键字</th><th>变量提升</th><th>块级作用域</th><th>重复声明同名变量</th><th>重新赋值</th></tr><tr><td>var</td><td>√</td><td>×</td><td>√</td><td>√</td></tr><tr><td>let</td><td>×</td><td>√</td><td>×</td><td>√</td></tr><tr><td>const</td><td>×</td><td>√</td><td>×</td><td>×</td></tr></tbody></table>\n<h1>1.作用域</h1>\n<p><code><span style=\"color:#fe2c24;\"><strong>var</strong></span></code>没有<strong>块级作用域</strong>，而<span style=\"color:#fe2c24;\"><strong><code>let</code></strong></span>声明的范围是<strong>块作用域; </strong>一对大括号 就是 一个块级作用域</p>\n<pre><code class=\"language-javascript\">if (true) {\n    var message = \"hello\";\n    console.log(message); // hello\n}\nconsole.log(message); // hello\n\n\nif (true) {\n    let message = \"hello\";\n    console.log(message); // hello\n}\nconsole.log(message); // error: message is not defined\n\n</code></pre>\n<p><span style=\"color:#fe2c24;\"><strong><code>let</code> </strong></span>不允许同一个块作用域中出现<strong>冗余声明</strong>：</p>\n<pre><code class=\"language-javascript\">if (true) { \n    // error: 无法重新声明块范围变量“a”\n    let a;\n    let a;\n}</code></pre>\n<p>JS 引擎会记录用于变量声明的标识符及其所在的块作用域，因此嵌套使用相同的标识符不会报错，这是因为同一个块中没有重复声明：</p>\n<pre><code class=\"language-javascript\">let a = 666;\nconsole.log(a); // 666\nif (true) {\n    let a = '啊哈哈';\n    console.log(a); // 啊哈哈\n}</code></pre>\n<p><strong><span style=\"color:#fe2c24;\"><code>var</code></span></strong>和<strong><span style=\"color:#fe2c24;\"><code>let</code></span></strong>声明的并不是不同类型的变量，它们只是指出变量在相关作用域如何存在，所以对声明冗余报错不会因混用<strong><span style=\"color:#fe2c24;\"><code>var</code></span></strong>和<strong><span style=\"color:#fe2c24;\"><code>let</code></span></strong>而受影响：</p>\n<pre><code class=\"language-javascript\">// error\nvar a;\nlet a;\n\n// error\nlet b;\nvar b;</code></pre>\n<h2>2.变量提升</h2>\n<pre><code class=\"language-javascript\">//用var命名的变量有变量提升\nconsole.log(num1);  // undefined\nvar num1 = 10;\n// 以上代码运行时,相当于下面的写法\n​\nvar num2;  // 声明提升到作用域最顶端\nconsole.log(num2);  // undefined\nnum = 10;\n/*****************************************/\n//用 let 或 const 命名的变量有变量提升\nconsole.log(num3); // Uncaught ReferenceError: num3 is not defined\nlet num3 = 10;      \n​\nconsole.log(num4); // Uncaught ReferenceError: num4 is not defined\nconst num4 = 10;</code></pre>\n<h3>3.暂时性死区</h3>\n<p>只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，<strong>只有等到声明变量的那一行代码出现，才可以获取和使用该变量</strong></p>\n<pre><code class=\"language-javascript\">var tmp = 123; // 声明\nif (true) {\n  tmp = 'abc'; // 报错 因为本区域有tmp声明变量\n  let tmp; // 绑定if这个块级的作用域 不能出现tmp变量\n}</code></pre>\n<p><strong>暂时性死区和不能变量提升的意义在于: </strong>为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。</p>\n<h1>4.<strong>重复声明同名变量 和 重新赋值</strong></h1>\n<pre><code class=\"language-javascript\">//var 关键字可以声明同名变量,实际第二次声明是对第一次声明的变量重新赋值\nvar num1 = 10;\nvar num1 = 20;\nconsole.log(num1);  // 20\n​\n//let 和const 关键字不能重复声明同名变量,即使之前是用var声明的也会报错\nvar num2 = 10;\nlet num2 = 20;  // Uncaught SyntaxError: Identifier 'num2' has already been declared \n​\n//let 和 var 在声明变量时,可以不用初始化\nlet num3;  \nconsole.log(num3);  // undefined\nvar num4;  \nconsole.log(num4);  // undefined\n​\n//const 声明常量时必须初始化,因为 `const` 关键字声明的是常量,声明后不能再赋值\nconst num5;  // Uncaught SyntaxError: Missing initializer in const declaration\n​</code></pre>\n<pre><code class=\"language-javascript\">//let 声明的变量可以重新赋值\nlet num1 = 10;\nnum1 = 20;\nconsole.log(num1);  // 20\n//const 只能在声明时赋值，之后不能再重新赋值\nconst num2 = 10;\nnum2 = 20;  // Uncaught TypeError: Assignment to constant variable.</code></pre>\n<h1>5.扩展</h1>\n<h2>        5.1.全局声明</h2>\n<p>        使用<code>var</code>在全局作用域中声明的变量会成为<code>window</code>对象的属性，<code>let</code>和<code>const</code>声明的变量则不会：</p>\n<pre><code class=\"language-javascript\">var a = 666;\nconsole.log(window.a); // 666\n\nlet b = 666;\nconsole.log(window.b); // undefined\n\nconst c = 666;\nconsole.log(window.c); // undefined\n</code></pre>\n<h2>        5.2.for 循环中的var 和 let 声明的区别</h2>\n<pre><code class=\"language-javascript\">for (var i = 0; i &lt; 5; i++) {\n    setTimeout( () =&gt; {\n        console.log(i); // 5、5、5、5、5\n    }, 0 )\n}\n\nfor (let i = 0; i &lt; 5; i++) {\n    setTimeout( () =&gt; {\n        console.log(i); // 0、1、2、3、4\n    }, 0 )\n}</code></pre>\n<p>var是因为在退出循环时，迭代变量保存的是导致循环退出的值，也就是 5。在之后异步执行超时逻辑时，所有的<code>i</code>都是同一个变量，因此输出的都是同一个最终值。</p>\n<p>而在使用<code>let</code>声明迭代变量时，JS 引擎在后台会为每个迭代循环声明一个新的迭代变量，每个 setTimeout 引用的都是不同的变量实例，所以 console.log 输出的是我们期望的值，也就是循环执行过程中每个迭代变量的值。</p>\n<p></p>\n<p></p>\n</div>\n</div>"}