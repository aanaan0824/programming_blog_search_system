{"blogid": "125722525", "writerAge": "码龄1年", "writerBlogNum": "103", "writerCollect": "5466", "writerComment": "4193", "writerFan": "7302", "writerGrade": "7级", "writerIntegral": "13154", "writerName": "三分苦", "writerProfileAdress": "writer_image\\profile_125722525.jpg", "writerRankTotal": "783", "writerRankWeekly": "296", "writerThumb": "4503", "writerVisitNum": "116086", "blog_read_count": "189", "blog_time": "于 2022-08-08 09:05:06 发布", "blog_title": "【 C++ 】vector的模拟实现", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"00-toc\" style=\"margin-left:80px;\"><a href=\"#00\">1、基本成员变量</a></p>\n<p id=\"11-toc\" style=\"margin-left:80px;\"><a href=\"#11\">2、默认成员函数</a></p>\n<p id=\"22-toc\" style=\"margin-left:80px;\"><a href=\"#22\">        构造函数</a></p>\n<p id=\"33-toc\" style=\"margin-left:80px;\"><a href=\"#33\">        析构函数</a></p>\n<p id=\"44-toc\" style=\"margin-left:80px;\"><a href=\"#44\">        拷贝构造函数</a></p>\n<p id=\"55-toc\" style=\"margin-left:80px;\"><a href=\"#55\">        赋值运算符重载函数</a></p>\n<p id=\"77-toc\" style=\"margin-left:80px;\"><a href=\"#77\">3、容器访问相关函数接口</a></p>\n<p id=\"88-toc\" style=\"margin-left:80px;\"><a href=\"#88\">        operator[ ]运算符重载</a></p>\n<p id=\"99-toc\" style=\"margin-left:80px;\"><a href=\"#99\">        迭代器</a></p>\n<p id=\"000-toc\" style=\"margin-left:80px;\"><a href=\"#000\">        范围for</a></p>\n<p id=\"111-toc\" style=\"margin-left:80px;\"><a href=\"#111\">4、vector空间增长问题</a></p>\n<p id=\"222-toc\" style=\"margin-left:80px;\"><a href=\"#222\">        size和capacity</a></p>\n<p id=\"333-toc\" style=\"margin-left:80px;\"><a href=\"#333\">        reserve扩容</a></p>\n<p id=\"444-toc\" style=\"margin-left:80px;\"><a href=\"#444\">        resize</a></p>\n<p id=\"555-toc\" style=\"margin-left:80px;\"><a href=\"#555\">        swap交换数据</a></p>\n<p id=\"666-toc\" style=\"margin-left:80px;\"><a href=\"#666\">5、增加的相关函数接口</a></p>\n<p id=\"777-toc\" style=\"margin-left:80px;\"><a href=\"#777\">        push_back尾插</a></p>\n<p id=\"888-toc\" style=\"margin-left:80px;\"><a href=\"#888\">        insert</a></p>\n<p id=\"999-toc\" style=\"margin-left:80px;\"><a href=\"#999\">6、删除的相关函数接口</a></p>\n<p id=\"0000-toc\" style=\"margin-left:80px;\"><a href=\"#0000\">        pop_back尾删</a></p>\n<p id=\"1111-toc\" style=\"margin-left:80px;\"><a href=\"#1111\">        erase</a></p>\n<p id=\"2222-toc\" style=\"margin-left:80px;\"><a href=\"#2222\">        clear清空数据</a></p>\n<p id=\"3333-toc\" style=\"margin-left:80px;\"><a href=\"#3333\">7、源码链接</a></p>\n<hr/>\n<h3>1、基本成员变量</h3>\n<blockquote>\n<p><img alt=\"\" height=\"204\" src=\"image\\88d937ae983442b49716c27320cf8f92.png\" width=\"655\"/></p>\n<pre><code class=\"language-cpp\">namespace cpp\n{\n\ttemplate&lt;class T&gt;\n\tclass vector\n\t{\n\tpublic:\n\t\ttypedef T* iterator;\n\t\ttypedef const T* const_iterator;\n\tprivate:\n\t\titerator _start;\t  //指向容器的头\n\t\titerator _finish;\t  //指向有效数据的尾\n\t\titerator _endofstoage;//指向容器的尾\n\t};\n}</code></pre>\n</blockquote>\n<hr/>\n<h3 id=\"11\">2、默认成员函数</h3>\n<h3 id=\"22\">构造函数</h3>\n<blockquote>\n<ul><li><span style=\"background-color:#edf6e8;\">1、无参构造函数</span></li></ul>\n<p>只需要把每个成员变量初始化为nullptr即可。</p>\n<pre><code class=\"language-cpp\">//无参构造函数\nvector()\n\t:_start(nullptr)\n\t, _finish(nullptr)\n\t, _endofstoage(nullptr)\n{}</code></pre>\n<ul><li><span style=\"background-color:#edf6e8;\">2、带参构造函数</span></li></ul>\n<p>vector的带参构造函数首先在初始化列表对基本成员变量初始化，在将迭代器区间在[first, last)的数据一个个尾插到容器当中即可：</p>\n<pre><code class=\"language-cpp\">//带参构造函数\ntemplate &lt;class InputIterator&gt;\nvector(InputIterator first, InputIterator last)\n\t: _start(nullptr)\n\t, _finish(nullptr)\n\t, _endofstoage(nullptr)\n{\n    //将迭代器区间在[first, last)的数据一个个尾插到容器当中\n\twhile (first != last)\n\t{\n\t\tpush_back(*first);\n\t\tfirst++;\n\t}\n}</code></pre>\n<ul><li><span style=\"background-color:#edf6e8;\">3、用n个val去初始化vector</span></li></ul>\n<p>vector的构造函数还支持用n个val去初始化，只需要先调用reserve函数开辟n个大小的空间，再利用for循环把val的值依次push_back尾插进去即可。</p>\n<pre><code class=\"language-cpp\">//用n个val来构造vector\nvector(size_t n, const T&amp; val = T())\n\t: _start(nullptr)\n\t, _finish(nullptr)\n\t, _endofstoage(nullptr)\n{\n\treserve(n);\n\tfor (size_t i = 0; i &lt; n; i++)\n\t{\n\t\tpush_back(val);\n\t}\n}</code></pre>\n<p>这样写会出现一个问题：内存寻址错误。当我想实现下面的语句时：</p>\n<pre><code class=\"language-cpp\">cpp::vector&lt;int&gt; v(10, 4);</code></pre>\n<p>这里我调用的地方两个参数都是int，此时调用构造函数时匹配的是第二个传迭代器区间的构造函数，导致这样的原因在于<span style=\"color:#956fe7;\">编译器会优先寻找最匹配的那个函数</span>。此构造函数的第一个参数是unsigned int类型，所以不会优先匹配此构造函数。因此我们需要再<span style=\"color:#956fe7;\">重载一个第一个参数为int类型的构造函数即可解决</span>：</p>\n<pre><code class=\"language-cpp\">vector(int n, const T&amp; val = T())\n\t: _start(nullptr)\n\t, _finish(nullptr)\n\t, _endofstoage(nullptr)\n{\t\t\n    reserve(n);\n\tfor (int i = 0; i &lt; n; i++)\n\t{\n\t\tpush_back(val);\n\t}\n}</code></pre>\n</blockquote>\n<hr/>\n<h3 id=\"33\">析构函数</h3>\n<blockquote>\n<p>首先判断该容器_start是否为空，不为空就释放空间+置空即可。</p>\n<pre><code class=\"language-cpp\">//析构函数\n~vector()\n{\n\tif (_start)//避免释放空指针\n\t{\n\t\tdelete[] _start;//释放容器所指向的空间\n\t\t_start = _finish = _endofstoage = nullptr;//置空\n\t}\t\n}</code></pre>\n</blockquote>\n<hr/>\n<h3 id=\"44\">拷贝构造函数</h3>\n<blockquote>\n<p>拷贝构造可以借助先前string的拷贝构造思路，利用现代方法解决，首先对基本成员变量进行初始化，接着建立一个tmp的模板将要拷贝的数据利用构造函数去传递过去，再将这个tmp模板与自己交换即可。</p>\n<pre><code class=\"language-cpp\">//拷贝构造函数\nvector(const vector&lt;T&gt;&amp; v)\n\t:_start(nullptr)\n\t, _finish(nullptr)\n\t, _endofstoage(nullptr)\n{\n\tvector&lt;T&gt; tmp(v.begin(), v.end());//调用构造函数\n\tswap(tmp);\n}</code></pre>\n</blockquote>\n<hr/>\n<h3 id=\"55\">赋值运算符重载函数</h3>\n<blockquote>\n<p>这里是传值传参，没有引用传参，直接利用vector调用构造函数返回的值与左值进行swap交换即可进行赋值</p>\n<pre><code class=\"language-cpp\">//赋值运算符重载\nvector&lt;T&gt;&amp; operator=(vector&lt;T&gt; v)//调用构造\n{\n\tthis-&gt;swap(v);//交换这两个对象\n\treturn *this;//返回\n}</code></pre>\n</blockquote>\n<hr/>\n<h3 id=\"77\">3、容器访问相关函数接口</h3>\n<h3 id=\"88\">operator[ ]运算符重载</h3>\n<blockquote>\n<p>直接返回pos位置的数据即可进行下标+[ ]的方式进行访问</p>\n<pre><code class=\"language-cpp\">//operator[]运算符重载\nT&amp; operator[](size_t pos)\n{\n    assert(pos &lt; size());//检测pos的合法性\n    return _start[pos];\n}</code></pre>\n<p>为了方便const对象也可以调用[ ]运算符重载，因此还推出了一个const版本的[ ]运算符重载。</p>\n<pre><code class=\"language-cpp\">//const版本的[]运算符重载\nconst T&amp; operator[](size_t pos) const\n{\n\tassert(pos &lt; size());//检测pos的合法性\n\treturn _start[pos];\t\n}</code></pre>\n</blockquote>\n<hr/>\n<h3 id=\"99\">迭代器</h3>\n<blockquote>\n<p>vector的begin直接返回容器的_start起始位置即可，vector的end返回容器的_finish的位置。</p>\n<pre><code class=\"language-cpp\">//begin\niterator begin()\n{\n\treturn _start;//返回容器起始位置\n}\n//end\niterator end()\n{\n\treturn _finish;//返回有效数据下一个的地址\n}</code></pre>\n<p>这里迭代器同样也要考虑到const对象调用的可能性，因此推出const版本的迭代器如下：</p>\n<pre><code class=\"language-cpp\">//const版本迭代器\nconst_iterator begin() const\n{\n\treturn _start;\n}\n//end\nconst_iterator end() const\n{\n\treturn _finish;\n}</code></pre>\n</blockquote>\n<hr/>\n<h3 id=\"000\">范围for</h3>\n<blockquote>\n<p>和前面一样，范围for的底层是通过迭代器实现的，写法也很简单：</p>\n<pre><code class=\"language-cpp\">void test_vector()\n{\n\tcpp::vector&lt;int&gt; v;\n\tv.push_back(1);\n\tv.push_back(2);\n\tv.push_back(3);\n\tv.push_back(4);\n\tv.push_back(5);\n    //范围for\n\tfor (auto e : v)\n\t{\n\t\tcout &lt;&lt; e &lt;&lt; \" \";//1 2 3 4 5\n\t}\n}</code></pre>\n</blockquote>\n<hr/>\n<h3 id=\"111\">4、vector空间增长问题</h3>\n<h3 id=\"222\">size和capacity</h3>\n<blockquote>\n<p>指针相减可以得到对应的个数，因此获取size只需_finish - _start。获取capacity只需_endofstoage - _start。</p>\n<ul><li><span style=\"background-color:#edf6e8;\">size函数：</span></li></ul>\n<pre><code class=\"language-cpp\">size_t size() const //最好加上const，普通对象和const对象均可调用\n{\n\treturn _finish - _start; //指针相减就能得到size的个数\n}</code></pre>\n<ul><li><span style=\"background-color:#edf6e8;\">capacity函数：</span></li></ul>\n<pre><code class=\"language-cpp\">size_t capacity() const\n{\n\treturn _endofstoage - _start;\n}</code></pre>\n</blockquote>\n<hr/>\n<h3 id=\"333\">reserve扩容</h3>\n<blockquote>\n<p>reserve扩容和string的扩容非常相似。先开辟一块新的扩好容的空间，如果旧空间里头有数据，那么就利用for循环将容器中的数据一个一个拷贝到新空间，再释放旧空间，最后指向新空间。如果没有，直接指向新空间即可。</p>\n<pre><code class=\"language-cpp\">//reserve扩容\nvoid reserve(size_t n)\n{\n\tsize_t sz = size();//提前算出size()的大小，方便后续更新_finish\n\tif (n &gt; capacity())\n\t{\n\t\tT* tmp = new T[n];\n\t\tif (_start)//判断旧空间是否有数据\n\t\t{\n\t\t\t//不能用memcpy，因为memcpy是浅拷贝\n\t\t\tfor (size_t i = 0; i &lt; size(); i++)\n\t\t\t{\n\t\t\t\ttmp[i] = _start[i];//将容器当中的数据一个个拷贝到tmp当中\n\t\t\t}\n\t\t\tdelete[] _start;//释放旧空间\n\t\t}\n\t\t_start = tmp;//指向新空间\n\t}\n\t//更新_finish和_endofstoage\n\t_finish = _start + sz;\n\t_endofstoage = _start + n;\n}</code></pre>\n<ul><li><span style=\"background-color:#fefcd8;\">补充1：</span></li></ul>\n<p>在扩容结束后要记得更新_finish和_endofstoage，这里的_finsh要加上原先的size()长度，要先用变量sz保存下来，否则后续扩容后会更改指针的指向由原先的_start变为tmp，若直接+ size()函数的返回值会导致结果为随机值。</p>\n<ul><li><span style=\"background-color:#fefcd8;\">补充2：</span></li></ul>\n<p>不能使用memcpy进行数据拷贝，因为memcpy是浅拷贝，它会将一段内存空间中内容原封不动的拷贝到另外一段内存空间中，导致后续delete时拷贝过的数据一并给delete了，具体我下篇博文详谈。</p>\n</blockquote>\n<hr/>\n<h3 id=\"444\">resize</h3>\n<blockquote>\n<ol><li>如果 <em>n</em> 小于当前容器的size()，则内容将减少到其前 <em>n</em> 个元素，删除超出（并销毁）的元素。</li><li>如果 <em>n</em> 大于当前容器 size()，则通过在末尾插入所需数量的元素以达到 <em>n</em> 的大小来扩展内容。若指定了 <em>val</em>，则新元素将初始化为 <em>val</em> 的副本，否则，它们将进行值初始化。</li><li>如果 <em>n</em> 也大于当前容器容量capacity()，则会自动重新分配分配的存储空间。</li></ol>\n<pre><code class=\"language-cpp\">//resize\n//void resize(size_t n, T val = T())\nvoid resize(size_t n, const T&amp; val = T()) //利用T()调用默认构造函数的值进行初始化，这样写说明C++的内置类型也有自己的构造函数\n{\n\t//如果 n &gt; capacity()容量，就需要扩容\n\tif (n &gt; capacity())\n\t{\n\t\treserve(n);\n\t}\n\t//如果 n &gt; size()，就需要把有效数据_finish到_start + n之间的数据置为缺省值val\n\tif (n &gt; size())\n\t{\n\t\twhile (_finish &lt; _start + n)\n\t\t{\n\t\t\t*_finish = val;\n\t\t\t_finish++;\n\t\t}\n\t}\n\t//如果 n &lt; size()，更新有效数据到_start + n\n\telse\n\t{\t\t\n    \t_finish = _start + n;\n\t}\n}</code></pre>\n<ul><li><strong>补充：</strong>C++的内置类型也有自己的构造函数和析构函数，这样才能更好的支持模板。</li></ul>\n<pre><code class=\"language-cpp\">void test()\n{\n\tint i = 0;\n\tint j = int();\n\tint k = int(1);\n\tcout &lt;&lt; i &lt;&lt; endl;//0\n\tcout &lt;&lt; j &lt;&lt; endl;//0\n\tcout &lt;&lt; k &lt;&lt; endl;//1\n}</code></pre>\n</blockquote>\n<hr/>\n<h3 id=\"555\">swap交换数据</h3>\n<blockquote>\n<p>直接调用库函数的swap去进行成员变量的交换即可。</p>\n<pre><code class=\"language-cpp\">//交换函数\nvoid swap(vector&lt;T&gt;&amp; v)\n{\n\tstd::swap(_start, v._start);\n\tstd::swap(_finish, v._finish);\n\tstd::swap(_endofstoage, v._endofstoage);\n}</code></pre>\n</blockquote>\n<hr/>\n<h3 id=\"666\">5、增加的相关函数接口</h3>\n<h3 id=\"777\">push_back尾插</h3>\n<blockquote>\n<p>push_back尾插和之前写过的尾插大同小异，先判断是否需要扩容，把尾插的值赋过去，再更新有效数据地址_finish即可：</p>\n<pre><code class=\"language-cpp\">void push_back(const T&amp; x)\n{\n\t//检测是否需要扩容\n\tif (_finish == _endofstoage)\n\t{\n\t\tsize_t newcapcacity = capacity() == 0 ? 4 : capacity() * 2;\n\t\treserve(newcapcacity);\n\t}\n\t*_finish = x;\n\t_finish++;\n}</code></pre>\n<p>这里push_back还可以复用下文实现好的insert进行尾插，当insert中的pos为_finish时，insert实现的就是push_back尾插。而_finish可以通过调用迭代器end函数来解决。</p>\n<pre><code class=\"language-cpp\">void push_back(const T&amp; x)\n{\n\t//法二：复用insert\n\tinsert(end(), x); //当insert中的参数pos为end()时，就是尾插\n}</code></pre>\n</blockquote>\n<hr/>\n<h3 id=\"888\">insert</h3>\n<blockquote>\n<p>首先要坚持插入的位置是否越界，以及是否需要扩容。接着检测是否需要扩容。再挪动数据，最后把值插入进去。</p>\n<ul><li><span style=\"background-color:#fefcd8;\">注意：</span></li></ul>\n<p>注意<span style=\"color:#956fe7;\">扩容以后，pos就失效了，要记得更新pos，否则会发生迭代器失效</span>。可以通过设定变量n来计算扩容前pos指针位置和_start指针位置的相对距离，最后在扩容后，让_start再加上先前算好的相对距离n就是更新后的pos指针的位置了。<span style=\"color:#ff9900;\">其实这里还有一个迭代器失效的问题，具体是啥，</span><span style=\"color:#ff9900;\">后续专门推出一篇迭代器失效的文章</span>。下面给出完善修正后的insert：</p>\n<pre><code class=\"language-cpp\">//insert\niterator insert(iterator pos, const T&amp; x)\n{\n\t//检测参数合法性\n\tassert(pos &gt;= _start &amp;&amp; pos &lt;= _finish);\n\t//检测是否需要扩容\n\t/*扩容以后pos就失效了，需要更新一下*/\n\tif (_finish == _endofstoage)\n\t{\n\t\tsize_t n = pos - _start;//计算pos和start的相对距离\n\t\tsize_t newcapcacity = capacity() == 0 ? 4 : capacity() * 2;\n\t\treserve(newcapcacity);\n\t\tpos = _start + n;//防止迭代器失效，要让pos始终指向与_start间距n的位置\n\t}\n\t//挪动数据\n\titerator end = _finish - 1;\n\twhile (end &gt;= pos)\n\t{\n\t\t*(end + 1) = *(end);\n\t\tend--;\n\t}\n\t//把值插进去\n\t*pos = x;\n\t_finish++;\n\treturn pos;\n}</code></pre>\n</blockquote>\n<hr/>\n<h3 id=\"999\">6、删除的相关函数接口</h3>\n<h3 id=\"0000\">pop_back尾删</h3>\n<blockquote>\n<p>首先判断_finish是否大于_start，若大于，直接_finsh--即可，否则啥也不需要操作。</p>\n<pre><code class=\"language-cpp\">void pop_back()\n{\n\tif (_finish &gt; _start)//判断是否可以进行删除\n\t{\n\t\t_finish--;\n\t}\n}</code></pre>\n<p>pop_back也可以复用下文的erase实现，当erase的参数为_finish时，实现的就是尾删，而_finish可以通过调用迭代器end()函数来解决。</p>\n<pre><code class=\"language-cpp\">void pop_back()\n{\n\t//法二：复用erase\n\terase(end() - 1);\n    //不能用end()--，因为end()是传值返回，返回的是临时对象，临时对象具有常性，不能自身++或--，因此要用end() - 1\n}</code></pre>\n</blockquote>\n<hr/>\n<h3 id=\"1111\">erase</h3>\n<blockquote>\n<p>首先要检查删除位置pos的合法性，其次从pos + 1的位置开始往前覆盖即可删除pos位置，最后记得返回的值为删除位置的下一个位置，其实返回的就是pos，因为在pos删除后，下一个值会覆盖到pos的位置上。</p>\n<pre><code class=\"language-cpp\">//erase\niterator erase(iterator pos)\n{\n\t//检查合法性\n\tassert(pos &gt;= _start &amp;&amp; pos &lt; _finish);\n\t//从pos + 1的位置开始往前覆盖，即可完成删除pos位置的值\n\titerator it = pos + 1;\n\twhile (it &lt; _finish)\n\t{\n\t\t*(it - 1) = *it;\t\t\n        it++;\n\t}\n\t_finish--;\n\treturn pos;\n}</code></pre>\n<ul><li><span style=\"background-color:#fefcd8;\">补充1：</span></li></ul>\n<p>一般vector删除数据，都不考虑缩容的方案，当size() &lt; capacity() / 2 时，可以考虑开一个size()大小的新空间，拷贝数据，释放旧空间。缩容的本质是时间换空间。一般设计不会考虑缩容，因为实际比较关注时间效率，不是太关注空间效率，因为现在硬件设备空间都比较大，空间存储也比较便宜。</p>\n<ul><li><span style=\"background-color:#fefcd8;\">补充2：</span></li></ul>\n<ol><li>erase也会存在失效，erase的失效是意义变了，或者不存在有效访问数据有效范围。</li><li>一般不会使用缩容的方案，那么erase的失效，一般也不存在野指针的失效。</li></ol>\n<p>后续专门推出一篇博文讲解迭代器失效。这里先给出结论：</p>\n<ol><li>erase(pos)以后pos失效了，pos的意义变了，但是在不同平台下面对于访问pos的反应是不一样的，我们用的时候要以失效的角度去看待此问题。</li><li>对于insert和erase造成迭代器失效问题，linux的g++平台检查很佛系，基本靠操作系统本身野指针越界检擦机制。windows下VS系列检擦更严格一些，使用一些强制检擦机制，意义变了可能会检擦出来。</li><li>虽然g++对于迭代器失效检查时是非常佛系的，但是套在实际场景中，迭代器意义变了，也会出现各种问题。</li></ol>\n</blockquote>\n<hr/>\n<h3 id=\"2222\">clear清空数据</h3>\n<blockquote>\n<p>只需要把起始位置的指针_start赋给有效数据指针_finish即可完成数据的清空。</p>\n<pre><code class=\"language-cpp\">//clear清空数据\nvoid clear()\n{\n\t_finish = _start;\n}</code></pre>\n</blockquote>\n<hr/>\n<h3 id=\"3333\">7、源码链接</h3>\n<blockquote>\n<p>源码链接直达：<a class=\"link-info\" href=\"https://gitee.com/bit-zy/xzy--c/blob/master/stl_vector/stl_vector/vector.h\" title=\"vector模拟实现完善版\">vector模拟实现完善版</a></p>\n</blockquote>\n</div>\n</div>"}