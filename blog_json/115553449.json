{"blogid": "115553449", "writerAge": "码龄2年", "writerBlogNum": "23", "writerCollect": "4645", "writerComment": "208", "writerFan": "1960", "writerGrade": "5级", "writerIntegral": "1663", "writerName": "笨笨杨", "writerProfileAdress": "writer_image\\profile_115553449.jpg", "writerRankTotal": "486873", "writerRankWeekly": "23489", "writerThumb": "711", "writerVisitNum": "134309", "blog_read_count": "64251", "blog_time": "于 2021-04-09 16:33:47 发布", "blog_title": "Sql优化总结！详细！（2021最新面试必问）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-light\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p></p>\n<div class=\"toc\">\n<h3>Sql优化</h3>\n<ul><li><a href=\"#Sql_1\">Sql执行顺序</a></li><li><a href=\"#Sql_25\">基础Sql优化</a></li><li><ul><li><a href=\"#SQLselect__26\">查询SQL尽量不要使用select *，而是具体字段</a></li><li><a href=\"#whereor_43\">避免在where子句中使用or来连接条件</a></li><li><a href=\"#varcharchar_71\">使用varchar代替char</a></li><li><a href=\"#_88\">尽量使用数值替代字符串类型</a></li><li><a href=\"#_94\">查询尽量避免返回大量数据</a></li><li><a href=\"#explainSQL_97\">使用explain分析你SQL执行计划</a></li><li><a href=\"#_108\">是否使用了索引及其扫描类型</a></li><li><a href=\"#name_129\">创建name字段的索引</a></li><li><a href=\"#like_136\">优化like语句：</a></li><li><a href=\"#_183\">字符串怪现象</a></li><li><a href=\"#5_202\">索引不宜太多，一般5个以内</a></li><li><a href=\"#_208\">索引不适合建在有大量重复数据的字段上</a></li><li><a href=\"#where_211\">where限定查询的数据</a></li><li><a href=\"#_228\">避免在索引列上使用内置函数</a></li><li><a href=\"#where_268\">避免在where中对字段进行表达式操作</a></li><li><a href=\"#where_295\">避免在where子句中使用!=或&lt;&gt;操作符</a></li><li><a href=\"#distinct_314\">去重distinct过滤字段要少</a></li><li><a href=\"#wherenull_335\">where中使用默认值代替null</a></li></ul>\n</li><li><a href=\"#SQL_368\">高级SQL优化</a></li><li><ul><li><a href=\"#_369\">批量插入性能提升</a></li><li><a href=\"#_388\">批量删除优化</a></li><li><a href=\"#_420\">伪删除设计</a></li><li><a href=\"#group_by_428\">提高group by语句的效率</a></li><li><a href=\"#_447\">复合索引最左特性</a></li><li><a href=\"#_486\">排序字段创建索引</a></li><li><a href=\"#_514\">删除冗余和重复的索引</a></li><li><a href=\"#5_535\">不要有超过5个以上的表连接</a></li><li><a href=\"#inner_join_left_joinright_joininner_join_541\">inner join 、left join、right join，优先使用inner join</a></li><li><a href=\"#in_550\">in子查询的优化</a></li><li><a href=\"#union_allunion_588\">尽量使用union all替代union</a></li></ul>\n</li></ul>\n</div>\n<p></p>\n<h1><a id=\"Sql_1\"></a>Sql执行顺序</h1>\n<ul><li> <p><strong>(8)</strong> <code>SELECT</code><strong>(9)</strong> <code>DISTINCT</code> column,…<br/> 选择字段 、去重</p> </li><li> <p><strong>(6)</strong> <code>AGG_FUNC(column or expression)</code>,…<br/> 聚合函数</p> </li><li> <p><strong>(1)</strong> <code>FROM [left_table]</code><br/> 选择表</p> </li><li> <p><strong>(3)</strong> &lt;join_type&gt; <code>JOIN</code> &lt;right_table&gt;<br/> 链接</p> </li><li> <p><strong>(2)</strong> <code>ON</code> &lt;join_condition&gt;<br/> 链接条件</p> </li><li> <p><strong>(4)</strong> <code>WHERE</code> &lt;where_condition&gt;<br/> 条件过滤</p> </li><li> <p><strong>(5)</strong> <code>GROUP BY</code> &lt;group_by_list&gt;<br/> 分组</p> </li><li> <p><strong>(7)</strong> <code>HAVING</code> &lt;having_condition&gt;<br/> 分组过滤</p> </li><li> <p><strong>(10)</strong> <code>ORDER BY</code> &lt;order_by_list&gt;<br/> 排序</p> </li><li> <p><strong>(11)</strong> <code>LIMIT</code> count OFFSET count;<br/> 分页</p> </li></ul>\n<h1><a id=\"Sql_25\"></a>基础Sql优化</h1>\n<h2><a id=\"SQLselect__26\"></a>查询SQL尽量不要使用select *，而是具体字段</h2>\n<p><strong>反例：</strong></p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> student\n</code></pre>\n<p><strong>正例：</strong></p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">SELECT</span> id<span class=\"token punctuation\">,</span>NAME <span class=\"token keyword\">FROM</span> student\n</code></pre>\n<p><strong>理由：</strong></p>\n<ul><li>字段多时，大表能达到100多个字段甚至达200多个字段</li><li>只取需要的字段，节省资源、减少网络开销</li><li>select * 进行查询时，很可能不会用到索引，就会造成全表扫描</li></ul>\n<h2><a id=\"whereor_43\"></a>避免在where子句中使用or来连接条件</h2>\n<p>查询id为1或者薪水为3000的用户：</p>\n<p><strong>反例：</strong></p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> student <span class=\"token keyword\">WHERE</span> id<span class=\"token operator\">=</span><span class=\"token number\">1</span> <span class=\"token operator\">OR</span> salary<span class=\"token operator\">=</span><span class=\"token number\">30000</span>\n</code></pre>\n<p><strong>正例：</strong><br/> 使用union all</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> student <span class=\"token keyword\">WHERE</span> id<span class=\"token operator\">=</span><span class=\"token number\">1</span>\n<span class=\"token keyword\">UNION</span> <span class=\"token keyword\">ALL</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> student <span class=\"token keyword\">WHERE</span> salary<span class=\"token operator\">=</span><span class=\"token number\">30000</span>\n</code></pre>\n<p>分开两条sql写</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> student <span class=\"token keyword\">WHERE</span> id<span class=\"token operator\">=</span><span class=\"token number\">1</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> student <span class=\"token keyword\">WHERE</span> salary<span class=\"token operator\">=</span><span class=\"token number\">30000</span>\n</code></pre>\n<p><strong>理由：</strong></p>\n<ul><li>使用or可能会使索引失效，从而全表扫描</li><li>对于or没有索引的salary这种情况，假设它走了id的索引，但是走到salary查询条件时，它还得全表扫描。也就是说整个过程需要三步：全表扫描+索引扫描+合并。如果它一开始就走全表扫描，直接一遍扫描就搞定。虽然mysql是有优化器的，处于效率与成本考虑，遇到or条件，索引还是可能失效的</li></ul>\n<h2><a id=\"varcharchar_71\"></a>使用varchar代替char</h2>\n<p><strong>反例：</strong></p>\n<pre><code class=\"prism language-sql\"><span class=\"token punctuation\">`</span>deptname<span class=\"token punctuation\">`</span> <span class=\"token keyword\">char</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'部门名称'</span>\n</code></pre>\n<p><strong>正例：</strong></p>\n<pre><code class=\"prism language-sql\"><span class=\"token punctuation\">`</span>deptname<span class=\"token punctuation\">`</span> <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">COMMENT</span> <span class=\"token string\">'部门名称'</span>\n</code></pre>\n<p><strong>理由：</strong></p>\n<ul><li>varchar变长字段按数据内容实际长度存储，存储空间小，可以节省存储空间</li><li>char按声明大小存储，不足补空格</li><li>其次对于查询来说，在一个相对较小的字段内搜索，效率更高</li></ul>\n<h2><a id=\"_88\"></a>尽量使用数值替代字符串类型</h2>\n<ul><li><strong>主键（id）</strong>：primary key优先使用数值类型int，tinyint</li><li><strong>性别（sex）</strong>：0-代表女，1-代表男；数据库没有布尔类型，mysql推荐使用tinyint</li><li><strong>支付方式（payment）</strong>：1-现金、2-微信、3-支付宝、4-信用卡、5-银行卡</li><li><strong>服务状态（state）</strong>：1-开启、2-暂停、3-停止</li><li><strong>商品状态（state）</strong>：1-上架、2-下架、3-删除</li></ul>\n<h2><a id=\"_94\"></a>查询尽量避免返回大量数据</h2>\n<p>如果查询返回数据量很大，就会造成查询时间过长，网络传输时间过长。同时，大量数据返回也可能没有实际意义。如返回上千条甚至更多，用户也看不过来。<br/> 通常采用分页，一页习惯10/20/50/100条。</p>\n<h2><a id=\"explainSQL_97\"></a>使用explain分析你SQL执行计划</h2>\n<p>SQL很灵活，一个需求可以很多实现，那哪个最优呢？SQL提供了explain关键字，它可以分析你的SQL执行计划，看它是否最佳。Explain主要看SQL是否使用了索引。</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">EXPLAIN</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> student <span class=\"token keyword\">WHERE</span> id<span class=\"token operator\">=</span><span class=\"token number\">1</span>\n</code></pre>\n<p>返回结果：<br/> <img alt=\"在这里插入图片描述\" src=\"image\\20210409162148132.png\"/></p>\n<h2><a id=\"_108\"></a>是否使用了索引及其扫描类型</h2>\n<p><a href=\"https://blog.csdn.net/weixin_53601359/article/details/115558427\">SQL索引概念（详解B+树）</a></p>\n<p><strong><code>type：</code></strong></p>\n<ul><li><mark>ALL</mark> 全表扫描，没有优化，最慢的方式</li><li><mark>index</mark> 索引全扫描</li><li><mark>range</mark> 索引范围扫描，常用语&lt;，&lt;=，&gt;=，between等操作</li><li><mark>ref</mark> 使用非唯一索引扫描或唯一索引前缀扫描，返回单条记录，常出现在关联查询中</li><li><mark>eq_ref</mark> 类似ref，区别在于使用的是唯一索引，使用主键的关联查询</li><li><mark>const</mark> 当查询是对主键或者唯一键进行精确查询，系统会把匹配行中的其他列作为常数处理</li><li><mark>null MySQL</mark>不访问任何表或索引，直接返回结果</li><li><mark>System</mark> 表只有一条记录(实际中基本不存在这个情况)</li></ul>\n<blockquote>\n<p><strong>性能排行：</strong><br/> System &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL</p>\n</blockquote>\n<p><strong><code>possible_keys：</code></strong></p>\n<ul><li>显示可能应用在这张表中的索引</li></ul>\n<p><strong><code>key：</code></strong></p>\n<ul><li>真正使用的索引方式</li></ul>\n<h2><a id=\"name_129\"></a>创建name字段的索引</h2>\n<p>提高查询速度的最简单最佳的方式</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">ALTER</span> <span class=\"token keyword\">TABLE</span> student <span class=\"token keyword\">ADD</span> <span class=\"token keyword\">INDEX</span> index_name <span class=\"token punctuation\">(</span>NAME<span class=\"token punctuation\">)</span>\n</code></pre>\n<h2><a id=\"like_136\"></a>优化like语句：</h2>\n<p>模糊查询，程序员最喜欢的就是使用like，但是like很可能让你的索引失效</p>\n<p><strong>反例：</strong></p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">EXPLAIN</span>\n<span class=\"token keyword\">SELECT</span> id<span class=\"token punctuation\">,</span>NAME <span class=\"token keyword\">FROM</span> student <span class=\"token keyword\">WHERE</span> NAME <span class=\"token operator\">LIKE</span> <span class=\"token string\">'%1'</span>\n<span class=\"token keyword\">EXPLAIN</span>\n<span class=\"token keyword\">SELECT</span> id<span class=\"token punctuation\">,</span>NAME <span class=\"token keyword\">FROM</span> student <span class=\"token keyword\">WHERE</span> NAME <span class=\"token operator\">LIKE</span> <span class=\"token string\">'%1%'</span>\n</code></pre>\n<p><strong>正例：</strong></p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">EXPLAIN</span>\n<span class=\"token keyword\">SELECT</span> id<span class=\"token punctuation\">,</span>NAME <span class=\"token keyword\">FROM</span> student <span class=\"token keyword\">WHERE</span> NAME <span class=\"token operator\">LIKE</span> <span class=\"token string\">'1%'</span>\n</code></pre>\n<p><strong>理由：</strong><br/> 未使用索引：故意使用sex非索引字段</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">EXPLAIN</span>\n<span class=\"token keyword\">SELECT</span> id<span class=\"token punctuation\">,</span>NAME <span class=\"token keyword\">FROM</span> student <span class=\"token keyword\">WHERE</span> NAME<span class=\"token operator\">=</span><span class=\"token number\">1</span> <span class=\"token operator\">OR</span> sex<span class=\"token operator\">=</span><span class=\"token number\">1</span>\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\20210409162257456.png\"/></p>\n<p>主键索引生效</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">EXPLAIN</span>\n<span class=\"token keyword\">SELECT</span> id<span class=\"token punctuation\">,</span>NAME <span class=\"token keyword\">FROM</span> student <span class=\"token keyword\">WHERE</span> id<span class=\"token operator\">=</span><span class=\"token number\">1</span>\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\20210409162254883.png\"/></p>\n<p>索引失效，type=ALL，全表扫描</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">EXPLAIN</span>\n<span class=\"token keyword\">SELECT</span> id<span class=\"token punctuation\">,</span>NAME <span class=\"token keyword\">FROM</span> student <span class=\"token keyword\">WHERE</span> id <span class=\"token operator\">LIKE</span> <span class=\"token string\">'%1'</span>\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\20210409162252199.png\"/></p>\n<h2><a id=\"_183\"></a>字符串怪现象</h2>\n<p><strong>反例：</strong></p>\n<pre><code class=\"prism language-sql\"><span class=\"token comment\">#未使用索引</span>\n<span class=\"token keyword\">EXPLAIN</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> student <span class=\"token keyword\">WHERE</span> NAME<span class=\"token operator\">=</span><span class=\"token number\">123</span>\n</code></pre>\n<p><strong>正例：</strong></p>\n<pre><code class=\"prism language-sql\"><span class=\"token comment\">#使用索引</span>\n<span class=\"token keyword\">EXPLAIN</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> student <span class=\"token keyword\">WHERE</span> NAME<span class=\"token operator\">=</span><span class=\"token string\">'123'</span>\n</code></pre>\n<p><strong>理由：</strong></p>\n<ul><li>为什么第一条语句未加单引号就不走索引了呢？这是因为不加单引号时，是字符串跟数字的比较，它们类型不匹配，MySQL会做隐式的类型转换，把它们转换为数值类型再做比较</li></ul>\n<h2><a id=\"5_202\"></a>索引不宜太多，一般5个以内</h2>\n<ul><li>索引并不是越多越好，虽其提高了查询的效率，但却会降低插入和更新的效率</li><li>索引可以理解为一个就是一张表，其可以存储数据，其数据就要占空间</li><li>再者，索引表的一个特点，其数据是排序的，那排序要不要花时间呢？肯定要</li><li>insert或update时有可能会重建索引，如果数据量巨大，重建将进行记录的重新排序，所以建索引需要慎重考虑，视具体情况来定</li><li>一个表的索引数最好不要超过5个，若太多需要考虑一些索引是否有存在的必要</li></ul>\n<h2><a id=\"_208\"></a>索引不适合建在有大量重复数据的字段上</h2>\n<p>如性别字段。因为SQL优化器是根据表中数据量来进行查询优化的，如果索引<br/> 列有大量重复数据，Mysql查询优化器推算发现不走索引的成本更低，很可能就放弃索引了。</p>\n<h2><a id=\"where_211\"></a>where限定查询的数据</h2>\n<p>数据中假定就一个男的记录</p>\n<p><strong>反例：</strong></p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">SELECT</span> id<span class=\"token punctuation\">,</span>NAME <span class=\"token keyword\">FROM</span> student <span class=\"token keyword\">WHERE</span> sex<span class=\"token operator\">=</span><span class=\"token string\">'男'</span>\n</code></pre>\n<p><strong>正例：</strong></p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">SELECT</span> id<span class=\"token punctuation\">,</span>NAME <span class=\"token keyword\">FROM</span> student <span class=\"token keyword\">WHERE</span> id<span class=\"token operator\">=</span><span class=\"token number\">1</span> <span class=\"token operator\">AND</span> sex<span class=\"token operator\">=</span><span class=\"token string\">'男'</span>\n</code></pre>\n<p><strong>理由：</strong></p>\n<ul><li>需要什么数据，就去查什么数据，避免返回不必要的数据，节省开销</li></ul>\n<h2><a id=\"_228\"></a>避免在索引列上使用内置函数</h2>\n<p>业务需求：查询最近七天内新生儿（用学生表替代下）</p>\n<p><strong>给birthday字段创建索引：</strong></p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">ALTER</span> <span class=\"token keyword\">TABLE</span> student <span class=\"token keyword\">ADD</span> <span class=\"token keyword\">INDEX</span> idx_birthday <span class=\"token punctuation\">(</span>birthday<span class=\"token punctuation\">)</span>\n</code></pre>\n<p><strong>当前时间加7天：</strong></p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token function\">NOW</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\t\n<span class=\"token keyword\">SELECT</span> DATE_ADD<span class=\"token punctuation\">(</span><span class=\"token function\">NOW</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">INTERVAL</span> <span class=\"token number\">7</span> <span class=\"token keyword\">DAY</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<p><strong>反例：</strong></p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">EXPLAIN</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> student\n<span class=\"token keyword\">WHERE</span> DATE_ADD<span class=\"token punctuation\">(</span>birthday<span class=\"token punctuation\">,</span><span class=\"token keyword\">INTERVAL</span> <span class=\"token number\">7</span> <span class=\"token keyword\">DAY</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&gt;=</span><span class=\"token function\">NOW</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p><strong>正例：</strong></p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">EXPLAIN</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> student\n<span class=\"token keyword\">WHERE</span>  birthday <span class=\"token operator\">&gt;=</span> DATE_ADD<span class=\"token punctuation\">(</span><span class=\"token function\">NOW</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">INTERVAL</span> <span class=\"token number\">7</span> <span class=\"token keyword\">DAY</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p><strong>理由：</strong></p>\n<ul><li> <p>使用索引列上内置函数</p> </li><li> <p>索引失效：<br/> <img alt=\"在这里插入图片描述\" src=\"image\\20210409162359706.png\"/></p> </li><li> <p>索引有效：<br/> <img alt=\"在这里插入图片描述\" src=\"image\\20210409162405558.png\"/></p> </li></ul>\n<h2><a id=\"where_268\"></a>避免在where中对字段进行表达式操作</h2>\n<p><strong>反例：</strong></p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">EXPLAIN</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> student <span class=\"token keyword\">WHERE</span> id<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token operator\">=</span><span class=\"token operator\">+</span><span class=\"token number\">1</span>\n</code></pre>\n<p><strong>正例：</strong></p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">EXPLAIN</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> student <span class=\"token keyword\">WHERE</span> id<span class=\"token operator\">=</span><span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token operator\">+</span><span class=\"token number\">1</span>\n</code></pre>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">EXPLAIN</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> student <span class=\"token keyword\">WHERE</span> id<span class=\"token operator\">=</span><span class=\"token number\">1</span>\n</code></pre>\n<p><strong>理由：</strong></p>\n<ul><li>SQL解析时，如果字段相关的是表达式就进行全表扫描</li></ul>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\20210409162410691.png\"/></p>\n<ul><li>字段干净无表达式，索引生效<br/> <img alt=\"在这里插入图片描述\" src=\"image\\20210409162421235.png\"/></li></ul>\n<h2><a id=\"where_295\"></a>避免在where子句中使用!=或&lt;&gt;操作符</h2>\n<p>应尽量避免在where子句中使用!=或&lt;&gt;操作符，否则引擎将放弃使用索引而进行全表扫描。记住实现业务优先，实在没办法，就只能使用，并不是不能使用。如果不能使用，SQL也就无需支持了。</p>\n<p><strong>反例：</strong></p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">EXPLAIN</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> student <span class=\"token keyword\">WHERE</span> salary<span class=\"token operator\">!=</span><span class=\"token number\">3000</span>\n</code></pre>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">EXPLAIN</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> student <span class=\"token keyword\">WHERE</span> salary<span class=\"token operator\">&lt;&gt;</span><span class=\"token number\">3000</span>\n</code></pre>\n<p><strong>理由：</strong></p>\n<ul><li>使用!=和&lt;&gt;很可能会让索引失效<br/> <img alt=\"在这里插入图片描述\" src=\"image\\20210409162430222.png\"/></li></ul>\n<h2><a id=\"distinct_314\"></a>去重distinct过滤字段要少</h2>\n<pre><code class=\"prism language-sql\"><span class=\"token comment\">#索引失效</span>\n<span class=\"token keyword\">EXPLAIN</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token keyword\">DISTINCT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> student\n</code></pre>\n<pre><code class=\"prism language-sql\"><span class=\"token comment\">#索引生效</span>\n<span class=\"token keyword\">EXPLAIN</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token keyword\">DISTINCT</span> id<span class=\"token punctuation\">,</span>NAME <span class=\"token keyword\">FROM</span> student\n</code></pre>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">EXPLAIN</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token keyword\">DISTINCT</span> NAME <span class=\"token keyword\">FROM</span> student\n</code></pre>\n<p><strong>理由：</strong></p>\n<ul><li>带distinct的语句占用cpu时间高于不带distinct的语句。因为当查询很多字段时，如果使用distinct，数据库引擎就会对数据进行比较，过滤掉重复数据，然而这个比较、过滤的过程会占用系统资源，如cpu时间</li></ul>\n<h2><a id=\"wherenull_335\"></a>where中使用默认值代替null</h2>\n<p><strong>环境准备：</strong></p>\n<pre><code class=\"prism language-sql\"><span class=\"token comment\">#修改表，增加age字段，类型int，非空，默认值0</span>\n<span class=\"token keyword\">ALTER</span> <span class=\"token keyword\">TABLE</span> student <span class=\"token keyword\">ADD</span> age <span class=\"token keyword\">INT</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<pre><code class=\"prism language-sql\"><span class=\"token comment\">#修改表，增加age字段的索引，名称为idx_age</span>\n<span class=\"token keyword\">ALTER</span> <span class=\"token keyword\">TABLE</span> student <span class=\"token keyword\">ADD</span> <span class=\"token keyword\">INDEX</span> idx_age <span class=\"token punctuation\">(</span>age<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p><strong>反例：</strong></p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">EXPLAIN</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> student <span class=\"token keyword\">WHERE</span> age <span class=\"token operator\">IS</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span>\n</code></pre>\n<p><strong>正例：</strong></p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">EXPLAIN</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> student <span class=\"token keyword\">WHERE</span> age<span class=\"token operator\">&gt;</span><span class=\"token number\">0</span>\n</code></pre>\n<p><strong>理由：</strong></p>\n<ul><li>并不是说使用了is null 或者 is not null 就会不走索引了，这个跟mysql版本以及查询成本都有关</li><li>如果mysql优化器发现，走索引比不走索引成本还要高，就会放弃索引，这些条件 !=，&lt;&gt;，is null，is not null经常被认为让索引失效，其实是因为一般情况下，查询的成本高，优化器自动放弃索引的</li><li>如果把null值，换成默认值，很多时候让走索引成为可能，同时，表达意思也相对清晰一点</li></ul>\n<h1><a id=\"SQL_368\"></a>高级SQL优化</h1>\n<h2><a id=\"_369\"></a>批量插入性能提升</h2>\n<p>大量数据提交，上千，上万，批量性能非常快，mysql独有</p>\n<p><strong>多条提交：</strong></p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> student <span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">,</span>NAME<span class=\"token punctuation\">)</span> <span class=\"token keyword\">VALUES</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token string\">'name1'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> student <span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">,</span>NAME<span class=\"token punctuation\">)</span> <span class=\"token keyword\">VALUES</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span><span class=\"token string\">'name2'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p><strong>批量提交：</strong></p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> student <span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">,</span>NAME<span class=\"token punctuation\">)</span> <span class=\"token keyword\">VALUES</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token string\">'name1'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span><span class=\"token string\">'name2'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p><strong>理由：</strong></p>\n<ul><li>默认新增SQL有事务控制，导致每条都需要事务开启和事务提交；而批量处理是一次事务开启和提交。自然速度飞升</li><li>数据量小体现不出来</li></ul>\n<h2><a id=\"_388\"></a>批量删除优化</h2>\n<p>避免同时修改或删除过多数据，因为会造成cpu利用率过高，会造成锁表操作，从而影响别人对数据库的访问。</p>\n<p><strong>反例：</strong></p>\n<pre><code class=\"prism language-sql\"><span class=\"token comment\">#一次删除10万或者100万+？</span>\n<span class=\"token keyword\">delete</span> <span class=\"token keyword\">from</span> student <span class=\"token keyword\">where</span> id <span class=\"token operator\">&lt;</span><span class=\"token number\">100000</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<pre><code class=\"prism language-sql\"><span class=\"token comment\">#采用单一循环操作，效率低，时间漫长</span>\n<span class=\"token keyword\">for</span>（<span class=\"token keyword\">User</span> <span class=\"token keyword\">user</span>:list）{\n  <span class=\"token keyword\">delete</span> <span class=\"token keyword\">from</span> student<span class=\"token punctuation\">;</span>\n}\n</code></pre>\n<p><strong>正例：</strong></p>\n<pre><code class=\"prism language-sql\"><span class=\"token comment\">#分批进行删除，如每次500</span>\n<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>{\n<span class=\"token keyword\">delete</span> student <span class=\"token keyword\">where</span> id<span class=\"token operator\">&lt;</span><span class=\"token number\">500</span><span class=\"token punctuation\">;</span>\n}\n</code></pre>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">delete</span> student <span class=\"token keyword\">where</span> id<span class=\"token operator\">&gt;=</span><span class=\"token number\">500</span> <span class=\"token operator\">and</span> id<span class=\"token operator\">&lt;</span><span class=\"token number\">1000</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p><strong>理由：</strong></p>\n<ul><li>一次性删除太多数据，可能造成锁表，会有lock wait timeout exceed的错误，所以建议分批操作</li></ul>\n<h2><a id=\"_420\"></a>伪删除设计</h2>\n<p>商品状态（state）：1-上架、2-下架、3-删除</p>\n<p><strong>理由：</strong></p>\n<ul><li>这里的删除只是一个标识，并没有从数据库表中真正删除，可以作为历史记录备查</li><li>同时，一个大型系统中，表关系是非常复杂的，如电商系统中，商品作废了，但如果直接删除商品，其它商品详情，物流信息中可能都有其引用。</li><li>通过where state=1或者where state=2过滤掉数据，这样伪删除的数据用户就看不到了，从而不影响用户的使用</li><li>操作速度快，特别数据量很大情况下</li></ul>\n<h2><a id=\"group_by_428\"></a>提高group by语句的效率</h2>\n<p>可以在执行到该语句前，把不需要的记录过滤掉</p>\n<p><strong>反例：先分组，再过滤</strong></p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">select</span> job，avg（salary） <span class=\"token keyword\">from</span> employee  \n<span class=\"token keyword\">group</span> <span class=\"token keyword\">by</span> job \n<span class=\"token keyword\">having</span> job <span class=\"token operator\">=</span><span class=\"token string\">'president'</span> <span class=\"token operator\">or</span> job <span class=\"token operator\">=</span> <span class=\"token string\">'managent'</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p><strong>正例：先过滤，后分组</strong></p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">select</span> job，avg（salary） <span class=\"token keyword\">from</span> employee \n<span class=\"token keyword\">where</span> job <span class=\"token operator\">=</span><span class=\"token string\">'president'</span> <span class=\"token operator\">or</span> job <span class=\"token operator\">=</span> <span class=\"token string\">'managent'</span> \n<span class=\"token keyword\">group</span> <span class=\"token keyword\">by</span> job<span class=\"token punctuation\">;</span>\n</code></pre>\n<h2><a id=\"_447\"></a>复合索引最左特性</h2>\n<p>创建复合索引，也就是多个字段</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">ALTER</span> <span class=\"token keyword\">TABLE</span> student <span class=\"token keyword\">ADD</span> <span class=\"token keyword\">INDEX</span> idx_name_salary <span class=\"token punctuation\">(</span>NAME<span class=\"token punctuation\">,</span>salary<span class=\"token punctuation\">)</span>\n</code></pre>\n<p>满足复合索引的左侧顺序，哪怕只是部分，复合索引生效</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">EXPLAIN</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> student <span class=\"token keyword\">WHERE</span> NAME<span class=\"token operator\">=</span><span class=\"token string\">'name1'</span>\n</code></pre>\n<p>没有出现左边的字段，则不满足最左特性，索引失效</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">EXPLAIN</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> student <span class=\"token keyword\">WHERE</span> salary<span class=\"token operator\">=</span><span class=\"token number\">3000</span>\n</code></pre>\n<p>复合索引全使用，按左侧顺序出现 name,salary，索引生效</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">EXPLAIN</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> student <span class=\"token keyword\">WHERE</span> NAME<span class=\"token operator\">=</span><span class=\"token string\">'陈子枢'</span> <span class=\"token operator\">AND</span> salary<span class=\"token operator\">=</span><span class=\"token number\">3000</span>\n</code></pre>\n<p>虽然违背了最左特性，但MYSQL执行SQL时会进行优化，底层进行颠倒优化</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">EXPLAIN</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> student <span class=\"token keyword\">WHERE</span> salary<span class=\"token operator\">=</span><span class=\"token number\">3000</span> <span class=\"token operator\">AND</span> NAME<span class=\"token operator\">=</span><span class=\"token string\">'name1'</span>\n</code></pre>\n<p><strong>理由：</strong></p>\n<ul><li>复合索引也称为联合索引</li><li>当我们创建一个联合索引的时候，如(k1,k2,k3)，相当于创建了（k1）、(k1,k2)和(k1,k2,k3)三个索引，这就是最左匹配原则</li><li>联合索引不满足最左原则，索引一般会失效，但是这个还跟Mysql优化器有关的</li></ul>\n<h2><a id=\"_486\"></a>排序字段创建索引</h2>\n<p>什么样的字段才需要创建索引呢？原则就是where和order by中常出现的字段就创建索引。</p>\n<pre><code class=\"prism language-sql\"><span class=\"token comment\">#使用*，包含了未索引的字段，导致索引失效</span>\n<span class=\"token keyword\">EXPLAIN</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> student <span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span> NAME<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">EXPLAIN</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> student <span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span> NAME<span class=\"token punctuation\">,</span>salary\n\n<span class=\"token comment\">#name字段有索引</span>\n<span class=\"token keyword\">EXPLAIN</span>\n<span class=\"token keyword\">SELECT</span> id<span class=\"token punctuation\">,</span>NAME <span class=\"token keyword\">FROM</span> student <span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span> NAME\n\n<span class=\"token comment\">#name和salary复合索引</span>\n<span class=\"token keyword\">EXPLAIN</span>\n<span class=\"token keyword\">SELECT</span> id<span class=\"token punctuation\">,</span>NAME <span class=\"token keyword\">FROM</span> student <span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span> NAME<span class=\"token punctuation\">,</span>salary\n\n<span class=\"token keyword\">EXPLAIN</span>\n<span class=\"token keyword\">SELECT</span> id<span class=\"token punctuation\">,</span>NAME <span class=\"token keyword\">FROM</span> student <span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span> salary<span class=\"token punctuation\">,</span>NAME\n\n<span class=\"token comment\">#排序字段未创建索引，性能就慢</span>\n<span class=\"token keyword\">EXPLAIN</span>\n<span class=\"token keyword\">SELECT</span> id<span class=\"token punctuation\">,</span>NAME <span class=\"token keyword\">FROM</span> student <span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span> sex\n</code></pre>\n<h2><a id=\"_514\"></a>删除冗余和重复的索引</h2>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">SHOW</span> <span class=\"token keyword\">INDEX</span> <span class=\"token keyword\">FROM</span> student \n\n<span class=\"token comment\">#创建索引index_name</span>\n<span class=\"token keyword\">ALTER</span> <span class=\"token keyword\">TABLE</span> student <span class=\"token keyword\">ADD</span> <span class=\"token keyword\">INDEX</span> index_name <span class=\"token punctuation\">(</span>NAME<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">#删除student表的index_name索引</span>\n<span class=\"token keyword\">DROP</span> <span class=\"token keyword\">INDEX</span> index_name <span class=\"token keyword\">ON</span> student <span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">#修改表结果，删除student表的index_name索引</span>\n<span class=\"token keyword\">ALTER</span> <span class=\"token keyword\">TABLE</span> student <span class=\"token keyword\">DROP</span> <span class=\"token keyword\">INDEX</span> index_name <span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">#主键会自动创建索引，删除主键索引</span>\n<span class=\"token keyword\">ALTER</span> <span class=\"token keyword\">TABLE</span> student <span class=\"token keyword\">DROP</span> <span class=\"token keyword\">PRIMARY</span> <span class=\"token keyword\">KEY</span> <span class=\"token punctuation\">;</span>\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\20210409164210552.png\"/></p>\n<h2><a id=\"5_535\"></a>不要有超过5个以上的表连接</h2>\n<ul><li>关联的表个数越多，编译的时间和开销也就越大</li><li>每次关联内存中都生成一个临时表</li><li>应该把连接表拆开成较小的几个执行，可读性更高</li><li>如果一定需要连接很多表才能得到数据，那么意味着这是个糟糕的设计了</li><li>阿里规范中，建议多表联查三张表以下</li></ul>\n<h2><a id=\"inner_join_left_joinright_joininner_join_541\"></a>inner join 、left join、right join，优先使用inner join</h2>\n<p>三种连接如果结果相同，优先使用inner join，如果使用left join左边表尽量小</p>\n<ul><li>inner join 内连接，只保留两张表中完全匹配的结果集</li><li>left join会返回左表所有的行，即使在右表中没有匹配的记录</li><li>right join会返回右表所有的行，即使在左表中没有匹配的记录</li></ul>\n<p><strong>理由：</strong></p>\n<ul><li>如果inner join是等值连接，返回的行数比较少，所以性能相对会好一点</li><li>同理，使用了左连接，左边表数据结果尽量小，条件尽量放到左边处理，意味着返回的行数可能比较少。这是mysql优化原则，就是小表驱动大表，小的数据集驱动大的数据集，从而让性能更优</li></ul>\n<h2><a id=\"in_550\"></a>in子查询的优化</h2>\n<p>日常开发实现业务需求可以有两种方式实现：</p>\n<ul><li>一种使用数据库SQL脚本实现</li><li>一种使用程序实现<br/> 如需求：查询所有部门的所有员工：</li></ul>\n<pre><code class=\"prism language-sql\"><span class=\"token comment\">#in子查询</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> tb_user <span class=\"token keyword\">WHERE</span> dept_id <span class=\"token operator\">IN</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">SELECT</span> id <span class=\"token keyword\">FROM</span> tb_dept<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">#这样写等价于：</span>\n\n<span class=\"token comment\">#先查询部门表</span>\n<span class=\"token keyword\">SELECT</span> id <span class=\"token keyword\">FROM</span> tb_dept\n\n<span class=\"token comment\">#再由部门dept_id，查询tb_user的员工</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> tb_user u<span class=\"token punctuation\">,</span>tb_dept d <span class=\"token keyword\">WHERE</span> u<span class=\"token punctuation\">.</span>dept_id <span class=\"token operator\">=</span> d<span class=\"token punctuation\">.</span>id\n</code></pre>\n<p>假设表A表示某企业的员工表，表B表示部门表，查询所有部门的所有员工，很容易有以下程序实现，可以抽象成这样的一个嵌套循环：</p>\n<pre><code class=\"prism language-sql\">List<span class=\"token operator\">&lt;&gt;</span> resultSet<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span>B<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>i<span class=\"token operator\">+</span><span class=\"token operator\">+</span><span class=\"token punctuation\">)</span> {\n  <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>j<span class=\"token operator\">&lt;</span>A<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>j<span class=\"token operator\">+</span><span class=\"token operator\">+</span><span class=\"token punctuation\">)</span> {\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>id<span class=\"token operator\">=</span><span class=\"token operator\">=</span>B<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">)</span> {\n      resultSet<span class=\"token punctuation\">.</span><span class=\"token keyword\">add</span><span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n    }\n  }\n}\n</code></pre>\n<p>上面的需求使用SQL就远不如程序实现，特别当数据量巨大时。</p>\n<p><strong>理由：</strong></p>\n<ul><li>数据库最费劲的就是程序链接的释放。假设链接了两次，每次做上百万次的数据集查询，查完就结束，这样就只做了两次；相反建立了上百万次链接，申请链接释放反复重复，就会额外花费很多实际，这样系统就受不了了，慢，卡顿</li></ul>\n<h2><a id=\"union_allunion_588\"></a>尽量使用union all替代union</h2>\n<p><strong>反例：</strong></p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> student\n<span class=\"token keyword\">UNION</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> student\n</code></pre>\n<p><strong>正例：</strong></p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> student\n<span class=\"token keyword\">UNION</span> <span class=\"token keyword\">ALL</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> student\n</code></pre>\n<p><strong>理由：</strong></p>\n<ul><li>union和union all的区别是，union会自动去掉多个结果集合中的重复结果，而union all则将所有的结果全部显示出来，不管是不是重复</li><li>union：对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序</li><li>union在进行表链接后会筛选掉重复的记录，所以在表链接后会对所产生的结果集进行排序运算，删除重复的记录再返回结果。实际大部分应用中是不会产生重复的记录，最常见的是过程表与历史表UNION</li></ul>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}