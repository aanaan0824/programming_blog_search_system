{"blogid": "126658793", "writerAge": "码龄5年", "writerBlogNum": "297", "writerCollect": "1271", "writerComment": "229", "writerFan": "11348", "writerGrade": "6级", "writerIntegral": "7038", "writerName": "秃了也弱了。", "writerProfileAdress": "writer_image\\profile_126658793.jpg", "writerRankTotal": "2087", "writerRankWeekly": "512", "writerThumb": "345", "writerVisitNum": "585812", "blog_read_count": "419", "blog_time": "于 2022-09-02 22:30:00 发布", "blog_title": "mysql一条语句是如何被执行的——带你了解mysql语句执行内部顺序", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-light\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p></p>\n<div class=\"toc\">\n<h3>文章目录</h3>\n<ul><li><a href=\"#_2\">写在前面</a></li><li><a href=\"#MySQL_10\">MySQL基本架构</a></li><li><ul><li><a href=\"#_19\">超详细架构图</a></li><li><a href=\"#_21\">连接器</a></li><li><a href=\"#_54\">查询缓存</a></li><li><a href=\"#_69\">解析器</a></li><li><ul><li><a href=\"#MySQL_80Parser_77\">MySQL 8.0对Parser所做的改进</a></li></ul>\n</li><li><a href=\"#_357\">优化器</a></li><li><a href=\"#_386\">执行器</a></li><li><a href=\"#_405\">存储引擎</a></li></ul>\n</li><li><a href=\"#SQL_420\">SQL语句执行时间分析</a></li><li><a href=\"#_463\">参考资料</a></li></ul>\n</div>\n<p></p>\n<h1><a id=\"_2\"></a>写在前面</h1>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> <span class=\"token keyword\">table</span> <span class=\"token keyword\">where</span> id<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>日常开发中，执行以上的SQL语句时，所呈现给我们的是输入一条SQL，输出一行结果，却不知道这条语句在 MySQL 内部的执行过程。</p>\n<p>今天咱们就捋一捋一条SQL语句在MySql中是如何执行的。</p>\n<h1><a id=\"MySQL_10\"></a>MySQL基本架构</h1>\n<p>MySQL 是典型的 C/S 架构，即 Client/Server 架构，服务器端程序使用的 mysqld。整体的 MySQL 流程如下图所示：<br/> <img alt=\"在这里插入图片描述\" src=\"image\\775a03913a2e49198c55c471416320ec.png\" width=\"600\"/><br/> Server（SQL） 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p>\n<p>存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。</p>\n<p>下图便是一条SQL语句的执行过程了：<br/> <img alt=\"在这里插入图片描述\" src=\"image\\cc83eea5fc4b46bc8fcea358415a4dbb.png\" width=\"300\"/></p>\n<h2><a id=\"_19\"></a>超详细架构图</h2>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\447baada345f468ea37ca350fe2a1648.png\"/></p>\n<h2><a id=\"_21\"></a>连接器</h2>\n<p>在MySQL拿到这条SQL语句之前，首先你得先连接到MySQL数据库，这时候接待你的就是连接器。</p>\n<p>连接器负责跟客户端建立连接、获取权限、维持和管理连接。连接命令一般是这么写的：</p>\n<pre><code class=\"prism language-sql\">mysql <span class=\"token operator\">-</span>h$ip <span class=\"token operator\">-</span>P$port <span class=\"token operator\">-</span>u$<span class=\"token keyword\">user</span> <span class=\"token operator\">-</span>p\n</code></pre>\n<p>连接命令中的 mysql 是客户端工具，用来跟服务端建立连接。<br/> 在完成经典的 TCP 握手后，连接器就要开始认证你的身份，这个时候用的就是你输入的用户名和密码。<br/> 如果用户名或密码不对，你就会收到一个\"Access denied for user\"的错误，然后客户端程序结束执行。<br/> 如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。</p>\n<p>这就意味着，一个用户成功建立连接后，<strong>即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限</strong>。修改完成后，只有再新建的连接才会使用新的权限设置。</p>\n<p>连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，可以在 show processlist 命令中看到它。</p>\n<p>以下其中的 Command 列显示为“Sleep”的这一行，就表示现在系统里面有一个空闲连接。<br/> <img alt=\"在这里插入图片描述\" src=\"image\\a59445ebb37f425093e34bbad3bee8a7.png\"/><br/> 客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数 wait_timeout 控制的，默认值是 8 小时。</p>\n<p>如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒： Lost connection to MySQL server during query。这时候如果你要继续，就需要重连，然后再执行请求了。</p>\n<p>数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。</p>\n<p>建立连接的过程通常是比较复杂的，所以我建议你在使用中要尽量减少建立连接的动作，也就是尽量使用长连接。</p>\n<p>但是全部使用长连接后，你可能会发现，有些时候 MySQL 占用内存涨得特别快，这是因为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是 MySQL 异常重启了。</p>\n<p>怎么解决这个问题呢？你可以考虑以下两种方案。</p>\n<ul><li>定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。</li><li>如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</li><li>使用数据库连接池。</li></ul>\n<h2><a id=\"_54\"></a>查询缓存</h2>\n<p>连接建立完成后，你就可以执行 select 语句了。执行逻辑就会来到第二步：查询缓存。</p>\n<p>之前执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中。<br/> Server 如果在查询缓存中发现了这条 SQL 语句，就会直接将结果返回给客户端；如果没有，就进入到解析器阶段。</p>\n<p>但是大多数情况下我会建议你不要使用查询缓存，为什么呢？因为查询缓存往往弊大于利。<br/> 需要说明的是，因为查询缓存往往效率不高（如果数据频繁修改，缓存失效的频率非常高，这样的话缓存使用效率就会很低，除非是一张系统表，数据改动不大，才适合使用缓存），所以<strong>在 MySQL8.0 之后就抛弃了这个功能</strong>。</p>\n<p>将参数 query_cache_type 设置成 DEMAND，对于默认的 SQL 语句都不使用查询缓存。<br/> 而对于你确定要使用查询缓存的语句，可以用 SQL_CACHE 显式指定：</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">select</span> SQL_CACHE <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> <span class=\"token keyword\">table</span> <span class=\"token keyword\">where</span> ID<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h2><a id=\"_69\"></a>解析器</h2>\n<p>解析器的作用就是对SQL进行语法分析。<br/> 如果有语法问题，会直接提示语法错误：</p>\n<pre><code class=\"prism language-sql\">elect <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> t <span class=\"token keyword\">where</span> ID<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\nERROR <span class=\"token number\">1064</span> <span class=\"token punctuation\">(</span><span class=\"token number\">42000</span><span class=\"token punctuation\">)</span>: You have an error <span class=\"token operator\">in</span> your <span class=\"token keyword\">SQL</span> syntax<span class=\"token punctuation\">;</span> <span class=\"token keyword\">check</span> the manual that corresponds <span class=\"token keyword\">to</span> your MySQL server version <span class=\"token keyword\">for</span> the <span class=\"token keyword\">right</span> syntax <span class=\"token keyword\">to</span> <span class=\"token keyword\">use</span> near <span class=\"token string\">'elect * from t where ID=1'</span> at line <span class=\"token number\">1</span>\n</code></pre>\n<h3><a id=\"MySQL_80Parser_77\"></a>MySQL 8.0对Parser所做的改进</h3>\n<p>1、背景介绍<br/> 众所周知，MySQL Parser是利用C/C++实现的开源yacc/lex组合，也就是 GNU bison/flex。Flex负责生成tokens， Bison负责语法解析。开始介绍MySQL 8.0的新特新之前，我们先简单了解一下通用的两种Parser。一种是Bottom-up parser，另外一种是Top-down parser。</p>\n<p>2、Bottom-up parser<br/> Bottom-up解析是从parse tree底层开始向上构造，然后将每个token移进（shift），进而规约（reduce）为较大的token，最终按照语法规则的定义将所有token规约（reduce）成为一个token。移进过程是有先后顺序的，如果按照某种顺序不能将所有token规约为一个token，解析器将会回溯重新选定规约顺序。如果在规约（reduce）的过程中出现了既可以移进生成一个新的token，也可以规约为一个token，这种情况就是我们通常所说的shift/reduce conflicts.</p>\n<p>3、Top-down parser<br/> Top-down解析是从parse tree的顶层开始向下构造历。这种解析的方法是假定输入的解析字符串是符合当前定义的语法规则，按照规则的定义自顶开始逐渐向下遍历。遍历的过程中如果出现了不满足语法内部的逻辑定义，解析器就会报出语法错误。</p>\n<p>如果愿意详细了解这两种parser的却别，可以参考https://qntm.org/top。</p>\n<p>4、MySQL8.0对parser所做的改进<br/> Bison是一个bottom-up的parser。但是由于历史原因，MySQL的语法输入是按照Top-down的方式来书写的。这样的方式导致MySQL的parser语法上有包含了很多的reduce/shift conflicts；另外由于一些空的或者冗余的规则定义也使得的MySQL parser越来越复杂。为了应对未来越来越多的语法规则，以及优化MySQL parser的解析性能，MySQL 8.0对MySQL parser做了非常大的改进。当前的MySQL 8.0.1 Milestone release的代码中对于Parser的改进仍未全部完成，还有几个相关的worklog在继续。</p>\n<p>改进之后，MySQL parser可以达到如下状态：</p>\n<p>（1）MySQL parser将会成为一个不涉及状态信息（即：不包含执行状态的上下文信息）的bottom-up parser；<br/> （2）减少parse tree上的中间节点，减少冗余规则<br/> （3）更少的reduce/shift conflicts<br/> （4）语法解析阶段，只包含以下简单操作：<br/> ① 创建parse tree node<br/> ② 返回解析的最终状态信息<br/> ③ 有限的访问系统变量<br/> （5）MySQL parser执行流程将会由<br/> SQL input -&gt; lex. scanner -&gt; parser -&gt; AST (SELECT_LEX, Items etc) -&gt; executor</p>\n<p>变成</p>\n<p>SQL input -&gt; lex. scanner -&gt; parser -&gt; parse tree -&gt; AST -&gt; executor</p>\n<p>下面我们通过看一个MySQL 8.0 中对SELECT statement所做的修改来看一下MySQL parser的改进。</p>\n<p>SELECT statement可以说是MySQL中用处非常广泛的一个语句，比如CREATE VIEW, SELECT, CREATE TABLE, UNION, SUBQUERY等操作。 通过下图我们看一下MySQL8.0之前的版本是如何支持这些语法规则的。<br/> <img alt=\"在这里插入图片描述\" src=\"image\\d4029801519a4a9f99c5ddf9885073a6.png\"/><br/> MySQL8.0中对于这些语法规则的支持如下图：<br/> <img alt=\"在这里插入图片描述\" src=\"image\\062f7b6c53134ec3968a9c6b7c98ee2e.png\"/><br/> 通过如上两个图的对比，显然MySQL8.0的parser清爽了许多。当然我们也清晰的看到MySQL8.0中对于MySQL parser所做的改进。相同的语法规则只有一处定义，消除了过去版本中按照top-down方式书写的冗余语法定义。当然通过这样的简化也可以看到实际的效果， shift/reduce conflicts也减少了很多：<br/> <img alt=\"在这里插入图片描述\" src=\"image\\07c352107b394d61a4cfe15ad284b525.png\"/><br/> 下面我们看看MySQL 8.0是如何将所有的SELECT statement操作定义为一个Query specification，并为所有其他操作所引用的：</p>\n<p>Parse tree上所有的node都定义为Parse_tree_node的子类。Parse_tree_node的结构体定义如下：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">typedef</span> Parse_tree_node_tmpl<span class=\"token operator\">&lt;</span>Parse_context<span class=\"token operator\">&gt;</span> Parse_tree_node<span class=\"token punctuation\">;</span> \n<span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">typename</span> <span class=\"token class-name\">Context</span><span class=\"token operator\">&gt;</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Parse_tree_node_tmpl</span>\n<span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token keyword\">private</span><span class=\"token operator\">:</span>\n  <span class=\"token comment\">/*\n    False right after the node allocation. The contextualize/contextualize_\n    function turns it into true.\n  */</span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">ifndef</span> <span class=\"token expression\">DBUG_OFF</span></span>\n  <span class=\"token keyword\">bool</span> contextualized<span class=\"token punctuation\">;</span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">endif</span><span class=\"token comment\">//DBUG_OFF</span></span>\n  <span class=\"token comment\">/*\n    这个变量是由于当前仍旧有未完成的相关worklog，parser的refactor还没有彻底完成。当前的parser中还有一部分上下文依赖的关系没有独立出来。\n    等到整个parse refactor完成之后该变量就会被移除。\n  */</span>\n  <span class=\"token keyword\">bool</span> transitional<span class=\"token punctuation\">;</span> \n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n  <span class=\"token comment\">/*\n    Memory allocation operator are overloaded to use mandatory MEM_ROOT\n    parameter for cheap thread-local allocation.\n    Note: We don't process memory allocation errors in refactored semantic\n    actions: we defer OOM error processing like other error parse errors and\n    process them all at the contextualization stage of the resulting parse\n    tree.\n  */</span>\n  <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token keyword\">operator</span> <span class=\"token keyword\">new</span><span class=\"token punctuation\">(</span>size_t size<span class=\"token punctuation\">,</span> MEM_ROOT <span class=\"token operator\">*</span>mem_root<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throw</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">{<!-- --></span> <span class=\"token keyword\">return</span> <span class=\"token function\">alloc_root</span><span class=\"token punctuation\">(</span>mem_root<span class=\"token punctuation\">,</span> size<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token keyword\">operator</span> <span class=\"token keyword\">delete</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>ptr<span class=\"token punctuation\">,</span>size_t size<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span> <span class=\"token function\">TRASH</span><span class=\"token punctuation\">(</span>ptr<span class=\"token punctuation\">,</span> size<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token keyword\">operator</span> <span class=\"token keyword\">delete</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>ptr<span class=\"token punctuation\">,</span> MEM_ROOT <span class=\"token operator\">*</span>mem_root<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span><span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">protected</span><span class=\"token operator\">:</span>\n  <span class=\"token function\">Parse_tree_node</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">ifndef</span> <span class=\"token expression\">DBUG_OFF</span></span>\n    contextualized<span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    transitional<span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">endif</span><span class=\"token comment\">//DBUG_OFF</span></span>\n  <span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n   <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\n  <span class=\"token comment\">/*\n    True if contextualize/contextualized function has done:\n  */</span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">ifndef</span> <span class=\"token expression\">DBUG_OFF</span></span>\n  <span class=\"token keyword\">bool</span> <span class=\"token function\">is_contextualized</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{<!-- --></span> <span class=\"token keyword\">return</span> contextualized<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">endif</span><span class=\"token comment\">//DBUG_OFF</span></span>\n\n  <span class=\"token comment\">/*\n   这个函数是需要被所有子类继承的，所有子类需要定义属于自己的上下文环境。通过调用子类的重载函数，进而初始化每个Parse tree node。\n  */</span>\n  <span class=\"token keyword\">virtual</span> <span class=\"token keyword\">bool</span> <span class=\"token function\">contextualize</span><span class=\"token punctuation\">(</span>THD <span class=\"token operator\">*</span>thd<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">/**\n    my_parse_error() function replacement for deferred reporting of parse\n    errors\n\n    @param      thd     current THD\n    @param      pos     location of the error in lexical scanner buffers\n  */</span>\n  <span class=\"token keyword\">void</span> <span class=\"token function\">error</span><span class=\"token punctuation\">(</span>THD <span class=\"token operator\">*</span>thd<span class=\"token punctuation\">)</span> <span class=\"token keyword\">const</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>当前MySQL8.0的源码中执行流程为：</p>\n<pre><code class=\"prism language-cpp\">mysql_parse\n<span class=\"token operator\">|</span>\nparse_sql\n<span class=\"token operator\">|</span>\nMYSQLparse\n<span class=\"token operator\">|</span>\n<span class=\"token class-name\">Parse_tree_node</span><span class=\"token double-colon punctuation\">::</span><span class=\"token function\">contextualize</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">/* 经过Bison进行语法解析之后生成相应的Parse tree node。然后调用contextualize对Parse tree node进行上下文初始化。\n                                   初始化上下文后形成一个AST(Abstract Syntax Tree)节点。*/</span>\n</code></pre>\n<p>接下来我们以SELECT statement来看一下PT_SELECT_STMT::contexualize()做些什么工作：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">PT_select_stmt</span> <span class=\"token operator\">:</span> <span class=\"token base-clause\"><span class=\"token keyword\">public</span> <span class=\"token class-name\">Parse_tree_node</span></span>\n<span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token keyword\">bool</span> <span class=\"token function\">contextualize</span><span class=\"token punctuation\">(</span>Parse_context <span class=\"token operator\">*</span>pc<span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token comment\">// 这里初始化Parse_tree_node</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>super<span class=\"token double-colon punctuation\">::</span><span class=\"token function\">contextualize</span><span class=\"token punctuation\">(</span>pc<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n\n    pc<span class=\"token operator\">-&gt;</span>thd<span class=\"token operator\">-&gt;</span>lex<span class=\"token operator\">-&gt;</span>sql_command<span class=\"token operator\">=</span> m_sql_command<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token comment\">// 调用PT_query_specification来进行上下文初始化</span>\n    <span class=\"token keyword\">return</span> m_qe<span class=\"token operator\">-&gt;</span><span class=\"token function\">contextualize</span><span class=\"token punctuation\">(</span>pc<span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span>\n      <span class=\"token function\">contextualize_safe</span><span class=\"token punctuation\">(</span>pc<span class=\"token punctuation\">,</span> m_into<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">private</span><span class=\"token operator\">:</span>\n\tPT_query_expression <span class=\"token operator\">*</span>m_qe；<span class=\"token comment\">//通过m_qe来引用query_expression</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">PT_query_expression</span> <span class=\"token operator\">:</span> <span class=\"token base-clause\"><span class=\"token keyword\">public</span> <span class=\"token class-name\">Parse_tree_node</span></span>\n<span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t<span class=\"token keyword\">bool</span> <span class=\"token function\">contextualize</span><span class=\"token punctuation\">(</span>Parse_context <span class=\"token operator\">*</span>pc<span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t  <span class=\"token comment\">// 判断是否需要独立的名空间</span>\n      pc<span class=\"token operator\">-&gt;</span>select<span class=\"token operator\">-&gt;</span><span class=\"token function\">set_braces</span><span class=\"token punctuation\">(</span>m_parentheses <span class=\"token operator\">||</span> pc<span class=\"token operator\">-&gt;</span>select<span class=\"token operator\">-&gt;</span>braces<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      m_body<span class=\"token operator\">-&gt;</span><span class=\"token function\">set_containing_qe</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Parse_tree_node</span><span class=\"token double-colon punctuation\">::</span><span class=\"token function\">contextualize</span><span class=\"token punctuation\">(</span>pc<span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span>\n      <span class=\"token comment\">// 初始化SELECT主体上下文</span>\n        m_body<span class=\"token operator\">-&gt;</span><span class=\"token function\">contextualize</span><span class=\"token punctuation\">(</span>pc<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n\t  <span class=\"token comment\">// 这里会初始化ORDER, LIMIT子句</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>contextualized <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">contextualize_order_and_limit</span><span class=\"token punctuation\">(</span>pc<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n\n\t  <span class=\"token comment\">// 这里会对SELECT表达式里包含的存储过程或者UDF继续进行上下文初始化</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">contextualize_safe</span><span class=\"token punctuation\">(</span>pc<span class=\"token punctuation\">,</span> m_procedure_analyse<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>m_procedure_analyse <span class=\"token operator\">&amp;&amp;</span> pc<span class=\"token operator\">-&gt;</span>select<span class=\"token operator\">-&gt;</span><span class=\"token function\">master_unit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-&gt;</span><span class=\"token function\">outer_select</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">my_error</span><span class=\"token punctuation\">(</span>ER_WRONG_USAGE<span class=\"token punctuation\">,</span> <span class=\"token function\">MYF</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"PROCEDURE\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"subquery\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>m_lock_type<span class=\"token punctuation\">.</span>is_set <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>pc<span class=\"token operator\">-&gt;</span>thd<span class=\"token operator\">-&gt;</span>lex<span class=\"token operator\">-&gt;</span><span class=\"token function\">is_explain</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">{<!-- --></span>\n        pc<span class=\"token operator\">-&gt;</span>select<span class=\"token operator\">-&gt;</span><span class=\"token function\">set_lock_for_tables</span><span class=\"token punctuation\">(</span>m_lock_type<span class=\"token punctuation\">.</span>lock_type<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        pc<span class=\"token operator\">-&gt;</span>thd<span class=\"token operator\">-&gt;</span>lex<span class=\"token operator\">-&gt;</span>safe_to_cache_query<span class=\"token operator\">=</span> m_lock_type<span class=\"token punctuation\">.</span>is_safe_to_cache_query<span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token keyword\">private</span>： \n  <span class=\"token keyword\">bool</span> contextualized<span class=\"token punctuation\">;</span>\n  PT_query_expression_body <span class=\"token operator\">*</span>m_body<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* 这个类包含了SELECT语句的主要部分，select_list, FROM, GROUP BY, HINTs等子句。\n                                      这里m_body变量其实是PT_query_expression_body的子类 PT_query_expression_body_primary */</span>\n  PT_order <span class=\"token operator\">*</span>m_order<span class=\"token punctuation\">;</span> <span class=\"token comment\">// ORDER BY node</span>\n  PT_limit_clause <span class=\"token operator\">*</span>m_limit<span class=\"token punctuation\">;</span> <span class=\"token comment\">// LIMIT node</span>\n  PT_procedure_analyse <span class=\"token operator\">*</span>m_procedure_analyse<span class=\"token punctuation\">;</span> <span class=\"token comment\">//存储过程相关</span>\n  Default_constructible_locking_clause m_lock_type<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">bool</span> m_parentheses<span class=\"token punctuation\">;</span>\n\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">PT_query_expression_body_primary</span> <span class=\"token operator\">:</span> <span class=\"token base-clause\"><span class=\"token keyword\">public</span> <span class=\"token class-name\">PT_query_expression_body</span></span>\n<span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">PT_query_expression_body</span><span class=\"token double-colon punctuation\">::</span><span class=\"token function\">contextualize</span><span class=\"token punctuation\">(</span>pc<span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span>\n\t\t\tm_query_primary<span class=\"token operator\">-&gt;</span><span class=\"token function\">contextualize</span><span class=\"token punctuation\">(</span>pc<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\t\t\t<span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">private</span>：\n  PT_query_primary <span class=\"token operator\">*</span>m_query_primary<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 这里是SELECT表达式的定义类PT_query_specification的父类</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// PT_query_specification是SELECT表达式的定义类，它定义了SELECT表达式中绝大部分子句</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">PT_query_specification</span> <span class=\"token operator\">:</span> <span class=\"token base-clause\"><span class=\"token keyword\">public</span> <span class=\"token class-name\">PT_query_primary</span></span>\n<span class=\"token punctuation\">{<!-- --></span>\n  <span class=\"token keyword\">typedef</span> PT_query_primary super<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">private</span><span class=\"token operator\">:</span>\n  PT_hint_list <span class=\"token operator\">*</span>opt_hints<span class=\"token punctuation\">;</span>\n  Query_options options<span class=\"token punctuation\">;</span>\n  PT_item_list <span class=\"token operator\">*</span>item_list<span class=\"token punctuation\">;</span>\n  PT_into_destination <span class=\"token operator\">*</span>opt_into1<span class=\"token punctuation\">;</span>\n  Mem_root_array_YY<span class=\"token operator\">&lt;</span>PT_table_reference <span class=\"token operator\">*</span><span class=\"token operator\">&gt;</span> from_clause<span class=\"token punctuation\">;</span> <span class=\"token comment\">// empty list for DUAL</span>\n  Item <span class=\"token operator\">*</span>opt_where_clause<span class=\"token punctuation\">;</span>\n  PT_group <span class=\"token operator\">*</span>opt_group_clause<span class=\"token punctuation\">;</span>\n  Item <span class=\"token operator\">*</span>opt_having_clause<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">bool</span> <span class=\"token class-name\">PT_query_specification</span><span class=\"token double-colon punctuation\">::</span><span class=\"token function\">contextualize</span><span class=\"token punctuation\">(</span>Parse_context <span class=\"token operator\">*</span>pc<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>super<span class=\"token double-colon punctuation\">::</span><span class=\"token function\">contextualize</span><span class=\"token punctuation\">(</span>pc<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n\n  pc<span class=\"token operator\">-&gt;</span>select<span class=\"token operator\">-&gt;</span>parsing_place<span class=\"token operator\">=</span> CTX_SELECT_LIST<span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>options<span class=\"token punctuation\">.</span>query_spec_options <span class=\"token operator\">&amp;</span> SELECT_HIGH_PRIORITY<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">{<!-- --></span>\n    Yacc_state <span class=\"token operator\">*</span>yyps<span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>pc<span class=\"token operator\">-&gt;</span>thd<span class=\"token operator\">-&gt;</span>m_parser_state<span class=\"token operator\">-&gt;</span>m_yacc<span class=\"token punctuation\">;</span>\n    yyps<span class=\"token operator\">-&gt;</span>m_lock_type<span class=\"token operator\">=</span> TL_READ_HIGH_PRIORITY<span class=\"token punctuation\">;</span>\n    yyps<span class=\"token operator\">-&gt;</span>m_mdl_type<span class=\"token operator\">=</span> MDL_SHARED_READ<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> \n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>options<span class=\"token punctuation\">.</span><span class=\"token function\">save_to</span><span class=\"token punctuation\">(</span>pc<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n  \n  <span class=\"token comment\">// 这里开始初始化SELECT list项</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>item_list<span class=\"token operator\">-&gt;</span><span class=\"token function\">contextualize</span><span class=\"token punctuation\">(</span>pc<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// Ensure we're resetting parsing place of the right select</span>\n  <span class=\"token function\">DBUG_ASSERT</span><span class=\"token punctuation\">(</span>pc<span class=\"token operator\">-&gt;</span>select<span class=\"token operator\">-&gt;</span>parsing_place <span class=\"token operator\">==</span> CTX_SELECT_LIST<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  pc<span class=\"token operator\">-&gt;</span>select<span class=\"token operator\">-&gt;</span>parsing_place<span class=\"token operator\">=</span> CTX_NONE<span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// 初始化SELECT INTO子句</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">contextualize_safe</span><span class=\"token punctuation\">(</span>pc<span class=\"token punctuation\">,</span> opt_into1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// 初始化FROM子句</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>from_clause<span class=\"token punctuation\">.</span><span class=\"token function\">empty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">contextualize_array</span><span class=\"token punctuation\">(</span>pc<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>from_clause<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    pc<span class=\"token operator\">-&gt;</span>select<span class=\"token operator\">-&gt;</span>context<span class=\"token punctuation\">.</span>table_list<span class=\"token operator\">=</span>\n      pc<span class=\"token operator\">-&gt;</span>select<span class=\"token operator\">-&gt;</span>context<span class=\"token punctuation\">.</span>first_name_resolution_table<span class=\"token operator\">=</span>\n        pc<span class=\"token operator\">-&gt;</span>select<span class=\"token operator\">-&gt;</span>table_list<span class=\"token punctuation\">.</span>first<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\">// 初始化WHERE条件</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">itemize_safe</span><span class=\"token punctuation\">(</span>pc<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>opt_where_clause<span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span>\n  <span class=\"token comment\">// 初始化GROUP子句   </span>\n      <span class=\"token function\">contextualize_safe</span><span class=\"token punctuation\">(</span>pc<span class=\"token punctuation\">,</span> opt_group_clause<span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span>\n  <span class=\"token comment\">// 初始化HAVING子句</span>\n      <span class=\"token function\">itemize_safe</span><span class=\"token punctuation\">(</span>pc<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>opt_having_clause<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n\n  pc<span class=\"token operator\">-&gt;</span>select<span class=\"token operator\">-&gt;</span><span class=\"token function\">set_where_cond</span><span class=\"token punctuation\">(</span>opt_where_clause<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  pc<span class=\"token operator\">-&gt;</span>select<span class=\"token operator\">-&gt;</span><span class=\"token function\">set_having_cond</span><span class=\"token punctuation\">(</span>opt_having_clause<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// 初始化HINTs</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>opt_hints <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pc<span class=\"token operator\">-&gt;</span>thd<span class=\"token operator\">-&gt;</span>lex<span class=\"token operator\">-&gt;</span>sql_command <span class=\"token operator\">==</span> SQLCOM_CREATE_VIEW<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{<!-- --></span> <span class=\"token comment\">// Currently this also affects ALTER VIEW.</span>\n      <span class=\"token function\">push_warning_printf</span><span class=\"token punctuation\">(</span>pc<span class=\"token operator\">-&gt;</span>thd<span class=\"token punctuation\">,</span> Sql_condition<span class=\"token double-colon punctuation\">::</span>SL_WARNING<span class=\"token punctuation\">,</span>\n                          ER_WARN_UNSUPPORTED_HINT<span class=\"token punctuation\">,</span>\n                          <span class=\"token function\">ER_THD</span><span class=\"token punctuation\">(</span>pc<span class=\"token operator\">-&gt;</span>thd<span class=\"token punctuation\">,</span> ER_WARN_UNSUPPORTED_HINT<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n                          <span class=\"token string\">\"CREATE or ALTER VIEW\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>opt_hints<span class=\"token operator\">-&gt;</span><span class=\"token function\">contextualize</span><span class=\"token punctuation\">(</span>pc<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>综上我们以SELECT statement为例对MySQL8.0在MySQL parser方面所做的改进进行了简单介绍。这样的改进对于MySQL parser也许是一小步，但对于MySQL未来的可扩展确实是迈出了一大步。Parse tree独立出来，通过Parse tree再来构建AST，这样的方式下将简化MySQL对于Parse tree的操作，最大的受益者就是Prepared statement。等到MySQL parse的所有worklog完成之后，MySQL用户期盼多年的global prepared statement也就顺其自然实现了。</p>\n<p>当然MySQL parser的改进让我们已经看到Oracle MySQL在对MySQL optimizier方面对于PARSER，optimizer， executor三个阶段的松解耦工作已经展开了。未来期待Optimizer生成的plan也可以像当前的parser一样成为一个纯粹的Plan，执行上下文与Plan也可以独立开来。只有到了executor阶段才生成相应的执行上下文。这样一来对于MySQL optimizer未来的可扩展势必会起到如虎添翼的作用。</p>\n<h2><a id=\"_357\"></a>优化器</h2>\n<p>MySQL拿到SQL后，会将它转化它认为最优的语句以及选择最优的执行方案，比如调整join语句中表的连接顺序、去除无效的条件、当表中有多个索引时决定选择哪一个等等。<br/> <img alt=\"在这里插入图片描述\" src=\"image\\c0745164e98e4e6ca43b958eacd32f18.png\" width=\"400\"/><br/> <strong>数据库层面优化</strong><br/> 众所周知，数据库运行速度最重要的是其本身的基础设计：</p>\n<p>1、表结构是否合理，字段是否符合标准规范，是否满足程序运行的基础单元。例如频繁更新的应哟个程序通常有很多表，较少的列，而分析大量数据的应用程序则有很少的表，很多的列。</p>\n<p>2、是否正确使用了索引，来提高查询效率？</p>\n<p>3、您是否为每个表的建立，考虑使用合适的存储引擎，充分考虑到每个存储引擎的特点和优势。忒特别是，事务存储引擎或非事务存储引擎，这对于性能和可扩展性非常重要。</p>\n<p>4、您是否为每个表使用了适当的行格式，当然这取决于您所选择的存储引擎。比如，压缩表使用较少的磁盘空间，需要更少的磁盘I/O来读写数据。压缩表适用于所有InnoDB表的所有类型的工作负载，以及只读MyISAM表</p>\n<p>5、应用程序是否使用了合适的锁策略。比如，尽可能的允许共享访问，以便可以提升读的性能，当然对请求的独占也是非常关键的。这一点同样取决于存储引擎的选择，InnoDB存储引擎自身可以处理大多数锁定问题，从而实现很好的并发性能。</p>\n<p>6、用于缓存的所有内存区域的大小设置是否合理？也就是说，大到足以容纳经常访问的数据，但又不会大到使物理内存过载并导致分页。要配置的主要内存区域是 InnoDB 缓冲池和 MyISAM 密钥缓存。</p>\n<p><strong>硬件层面的优化</strong><br/> 随着数据库的使用场景越来越丰富，任何数据库都最终会遇到硬件性能瓶颈。DBA必须评估是否可以调整应用程序和重新配置服务器已避免这谢瓶颈，或者增加足够的硬件资源。主要的硬件瓶颈来源于以下几点：</p>\n<p>1、磁盘寻道。也就是磁盘找到一条数据所需要的时间。现在的磁盘，平均时间通常低于 10 毫秒，因此理论上我们每秒可以进行大约 100 次寻道。这个时间随着新磁盘的增加而缓慢改善，并且很难针对单个表进行优化。优化寻道时间的方法是将数据分布到多个磁盘上。</p>\n<p>2、磁盘读写。当磁盘在正确的位置时，我们需要读取或写入数据。现在的磁盘，一个磁盘可提供至少 10–20MB/s 的吞吐量。这比查找更容易优化，因为您可以从多个磁盘并行读取。</p>\n<p>3、CPU 时钟周期。当数据在主存中时，我们必须对其进行处理以获得我们的结果。与内存相比，拥有一张大表是最常见的限制因素。但是对于小表，速度通常不是问题。</p>\n<p>4、内存带宽。当 CPU 需要的数据超出 CPU 高速缓存的容量时，主内存带宽就会成为瓶颈。对于大多数系统来说，这是一个不常见的瓶颈，但还是需要注意。</p>\n<h2><a id=\"_386\"></a>执行器</h2>\n<p>开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限，如果没有，就会返回没有权限的错误，如下所示 (在工程实现上，如果命中查询缓存，会在查询缓存返回结果的时候，做权限验证。查询也会在优化器之前调用 precheck 验证权限)。</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> T <span class=\"token keyword\">where</span> ID<span class=\"token operator\">=</span><span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n\nERROR <span class=\"token number\">1142</span> <span class=\"token punctuation\">(</span><span class=\"token number\">42000</span><span class=\"token punctuation\">)</span>: <span class=\"token keyword\">SELECT</span> command denied <span class=\"token keyword\">to</span> <span class=\"token keyword\">user</span> <span class=\"token string\">'b'</span><span class=\"token variable\">@'localhost'</span> <span class=\"token keyword\">for</span> <span class=\"token keyword\">table</span> <span class=\"token string\">'T'</span>\n</code></pre>\n<p>上一条SQL，ID 字段没有索引的话，执行逻辑应该是这样子的：<br/> 1.调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存在结果集中；<br/> 2.调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。<br/> 3.执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。<br/> 4.至此，这个语句就执行完成了。</p>\n<p>对于有索引的表，第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。</p>\n<p>数据库的慢查询日志中看到一个 rows_examined 的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。</p>\n<p>在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟 rows_examined 并不是完全相同的。</p>\n<h2><a id=\"_405\"></a>存储引擎</h2>\n<p>MySQL 的存储引擎采用了插件的形式，每个存储引擎都面向一种特定的数据库应用环境。同时开源的 MySQL 还允许开发人员设置自己的存储引擎，下面是一些常见的存储引擎：</p>\n<p>1、InnoDB 存储引擎：它是 MySQL 5.5 版本之后默认的存储引擎，最大的特点是支持事务、行级锁定、外键约束等。</p>\n<p>2、MyISAM 存储引擎：在 MySQL 5.5 版本之前是默认的存储引擎，不支持事务，也不支持外键，最大的特点是速度快，占用资源少。</p>\n<p>3、Memory 存储引擎：使用系统内存作为存储介质，以便得到更快的响应速度。不过如果 mysqld 进程崩溃，则会导致所有的数据丢失，因此我们只有当数据是临时的情况下才使用 Memory 存储引擎。</p>\n<p>4、NDB 存储引擎：也叫做 NDB Cluster 存储引擎，主要用于 MySQL Cluster 分布式集群环境，类似于 Oracle 的 RAC 集群。</p>\n<p>5、Archive 存储引擎：它有很好的压缩机制，用于文件归档，在请求写入时会进行压缩，所以也经常用来做仓库。</p>\n<p>需要注意的是，数据库的设计在于表的设计，而在 MySQL 中每个表的设计都可以采用不同的存储引擎，我们可以根据实际的数据处理需要来选择存储引擎，这也是 MySQL 的强大之处。</p>\n<h1><a id=\"SQL_420\"></a>SQL语句执行时间分析</h1>\n<p>1、开启profiling<br/> 首先我们需要看下 profiling 是否开启，开启它可以让 MySQL 收集在 SQL 执行时所使用的资源情况，命令如下：</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">select</span> @<span class=\"token variable\">@profiling</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\3f7f00255be14198aad7513be514b1f5.png\" width=\"400\"/><br/> profiling=0 代表关闭，我们需要把 profiling 打开，即设置为 1：</p>\n<pre><code class=\"prism language-sql\">mysql<span class=\"token operator\">&gt;</span> <span class=\"token keyword\">set</span> profiling<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>2、随便执行一个sql查询</p>\n<pre><code class=\"prism language-sql\"><span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> wucai<span class=\"token punctuation\">.</span>heros<span class=\"token punctuation\">;</span>\n</code></pre>\n<p>3、查看当前会话所产生的所有 profiles<br/> <img alt=\"在这里插入图片描述\" src=\"image\\d6945a16d3f048db9883e637e314d94d.png\" width=\"400\"/><br/> 你会发现我们刚才执行了两次查询，Query ID 分别为 1 和 2。</p>\n<p>4、如果我们想要获取上一次查询的执行时间，可以使用：</p>\n<pre><code class=\"prism language-sql\">mysql<span class=\"token operator\">&gt;</span> <span class=\"token keyword\">show</span> profile<span class=\"token punctuation\">;</span>\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\4ee79f6b41614406957741b9ac630488.png\" width=\"500\"/><br/> 5、也可以查询指定的 Query ID，比如：</p>\n<pre><code class=\"prism language-sql\">mysql<span class=\"token operator\">&gt;</span> <span class=\"token keyword\">show</span> profile <span class=\"token keyword\">for</span> query <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>6、<br/> 在 8.0 版本之后，MySQL 不再支持缓存的查询。</p>\n<p>一旦数据表有更新，缓存都将清空，因此只有数据表是静态的时候，或者数据表很少发生变化时，使用缓存查询才有价值，否则如果数据表经常更新，反而增加了 SQL 的查询时间。</p>\n<p>使用 select version() 来查看 MySQL 的版本情况</p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\4d18c0b576654e51add96319eb300f88.png\" width=\"400\"/></p>\n<h1><a id=\"_463\"></a>参考资料</h1>\n<p>https://zhuanlan.zhihu.com/p/299667488<br/> http://mysql.taobao.org/monthly/2017/04/02/<br/> https://blog.csdn.net/qq_43842093/article/details/124810925<br/> https://blog.csdn.net/bingo199/article/details/122625491</p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}