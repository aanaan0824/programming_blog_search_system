{"blogid": "126655542", "writerAge": "码龄115天", "writerBlogNum": "47", "writerCollect": "10", "writerComment": "8", "writerFan": "19", "writerGrade": "3级", "writerIntegral": "501", "writerName": "迷途君", "writerProfileAdress": "writer_image\\profile_126655542.jpg", "writerRankTotal": "35273", "writerRankWeekly": "8812", "writerThumb": "22", "writerVisitNum": "6312", "blog_read_count": "168", "blog_time": "于 2022-09-02 11:13:48 发布", "blog_title": "linux驱动开发：中断和时间管理", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"-toc\" style=\"margin-left:40px;\"></p>\n<p id=\"%E4%B8%AD%E6%96%AD-toc\" style=\"margin-left:40px;\"><a href=\"#%E4%B8%AD%E6%96%AD\">中断</a></p>\n<p id=\"1.%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-toc\" style=\"margin-left:80px;\"><a href=\"#1.%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\">1.基本概念</a></p>\n<p id=\"2.%E5%85%B1%E4%BA%AB%E4%B8%AD%E6%96%AD-toc\" style=\"margin-left:80px;\"><a href=\"#2.%E5%85%B1%E4%BA%AB%E4%B8%AD%E6%96%AD\">2.共享中断</a></p>\n<p id=\"3.%E9%A9%B1%E5%8A%A8%E4%B8%AD%E7%9A%84%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86-toc\" style=\"margin-left:80px;\"><a href=\"#3.%E9%A9%B1%E5%8A%A8%E4%B8%AD%E7%9A%84%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86\">3.驱动中的中断处理</a></p>\n<p id=\"4.linux%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E6%9E%B6%E6%9E%84%EF%BC%88top%20half%20%2B%20bottom%20half%EF%BC%89-toc\" style=\"margin-left:80px;\"><a href=\"#4.linux%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E6%9E%B6%E6%9E%84%EF%BC%88top%20half%20%2B%20bottom%20half%EF%BC%89\">4.linux中断处理程序架构（top half + bottom half）</a></p>\n<p id=\"5.%E5%AE%9E%E7%8E%B0%E5%BA%95%E5%8D%8A%E9%83%A8%E7%9A%84%E6%9C%BA%E5%88%B6-toc\" style=\"margin-left:80px;\"><a href=\"#5.%E5%AE%9E%E7%8E%B0%E5%BA%95%E5%8D%8A%E9%83%A8%E7%9A%84%E6%9C%BA%E5%88%B6\">5.实现底半部的机制</a></p>\n<p id=\"5.1%20%E8%BD%AF%E4%B8%AD%E6%96%AD-toc\" style=\"margin-left:80px;\"><a href=\"#5.1%20%E8%BD%AF%E4%B8%AD%E6%96%AD\">5.1 软中断</a></p>\n<p id=\"5.2%20tasklet-toc\" style=\"margin-left:80px;\"><a href=\"#5.2%20tasklet\">5.2 tasklet</a></p>\n<p id=\"5.3%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97-toc\" style=\"margin-left:80px;\"><a href=\"#5.3%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97\">5.3工作队列</a></p>\n<p id=\"%E6%97%B6%E9%92%9F-toc\" style=\"margin-left:40px;\"><a href=\"#%E6%97%B6%E9%92%9F\">时钟</a></p>\n<p id=\"1.%E5%86%85%E6%A0%B8%E5%BB%B6%E6%97%B6-toc\" style=\"margin-left:80px;\"><a href=\"#1.%E5%86%85%E6%A0%B8%E5%BB%B6%E6%97%B6\">1.内核延时</a></p>\n<p id=\"2.%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8-toc\" style=\"margin-left:80px;\"><a href=\"#2.%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8\">2.内核定时器</a></p>\n<p id=\"3.%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97-toc\" style=\"margin-left:80px;\"><a href=\"#3.%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97\">3.延时队列</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h2 id=\"%E4%B8%AD%E6%96%AD\">中断</h2>\n<h3 id=\"1.%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\">1.基本概念</h3>\n<p>        所谓中断是指cpu在执行程序的过程中，出现了某些突发事件急待处理，CPU必须暂停执行当前的程序，转而去处理突发事件，处理完毕后cpu再返回到原来的位置继续执行。根据中断的来源，中断可以分为内部中断与外部中断。根据中断是否可以屏蔽，中断可以分为可屏蔽中断与不可屏蔽中断。根据跳转方法不同，可以分为向量中断与非向量中断。向量中断，不同的中断号对应于不同的中断入口地址，非向量中断多个中断共享一个中断入口地址，需要在中断服务程序中进行区分。</p>\n<h3 id=\"2.%E5%85%B1%E4%BA%AB%E4%B8%AD%E6%96%AD\">2.共享中断</h3>\n<p>由于中断控制器的管脚有限，所以在某些体系结构上有两个或两个以上的设备被接到了同一根中断线上，这样两个设备中的任何一个 设备产生了中断，都会触发中断，但linux内核不能判断新产生的这个中断究竟属于哪个设备，于是将共用一根中断线的中断处理函数通过不同的struct irqaction结构体包装起来，然后用链表链接起来，内核得到IRQ号后，就遍历链表上的每一个struct irqaction对象，然后调用其handler成员所指向的中断处理函数。在中断处理函数中，驱动开发者应该判断该中断是否是由自己管理的设备产生的，如果是则进行相应的中断处理，如果不是直接返回。</p>\n<blockquote>\n<p>struct irqaction结构类型定义：</p>\n<p>struct irqaction{<!-- --></p>\n<p>        irq_handler_t      handler;  //指向驱动开发者编写的中断处理函数的指针</p>\n<p>        void                      *dev_id;//区分共享中断中的不同设备的ID</p>\n<p>        void __percpu    *percpu_dev_id;</p>\n<p>        struct irqaction    *next;//将共享同一IRQ号的struct irqaction对象链接在一起的指针</p>\n<p>        irq_handler_t       *thread;</p>\n<p>        struct task_struct   *thread;</p>\n<p>        unsigned int           irq;//irq号</p>\n<p>        unsigned int           flags;//以IRQF_开头的一组标志</p>\n<p>        unsigned long       thread_flags;</p>\n<p>        unsigned long      thread_mask;</p>\n<p>        const char             *name;</p>\n<p>        struct pro_dir_entry     **dir;</p>\n<p>}___cacheline_internodealigned_in_smp;</p>\n</blockquote>\n<h3 id=\"3.%E9%A9%B1%E5%8A%A8%E4%B8%AD%E7%9A%84%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86\">3.驱动中的中断处理</h3>\n<p>不难发现，要在驱动中支持中断，则需要构造一个struct irqaction的结构对象，并根据irq号加入到对应的链表中。</p>\n<blockquote>\n<p><strong>注册一个中断处理函数的函数原型</strong></p>\n<p><strong>int request_irq</strong>(</p>\n<p>                unsigned int irq,//<span style=\"color:#fe2c24;\">设备上所用中断的IRQ号，内核中的，决定构造的对象被插入哪个链表</span><br/>                 irqreturn_t (*handler)(int, void *, struct pt_regs *),//<span style=\"color:#fe2c24;\">指向中断处理函数的指针，初始化对象中的handler成员</span><br/>                 unsigned long flags, //<span style=\"color:#fe2c24;\">与中断相关的标志，用来初始化对象中的flags成员，一般有上升沿触发，下降沿触发，高低电平触发等</span><br/>                 const char *dev_name,//<span style=\"color:#fe2c24;\">该中断在/proc中的名字，用于初始化struct irqaction对象中的name成员</span><br/>                 void *dev_id);//<span style=\"color:#fe2c24;\">区别共享中断中的不同设备所对应的struct irqaction对象，用于初始化dev_id成员</span></p>\n<p></p>\n<p>返回值：函数成功返回0，失败返回负值。</p>\n</blockquote>\n<blockquote>\n<p><strong>释放中断函数原型</strong><br/> void free_irq(unsigned int irq, void *dev_id);</p>\n<p>dev_id:共享中断必须要传递一个非NULL的实参，和request_irq中的dev_id保持一致</p>\n</blockquote>\n<p>中断处理函数应该快速完成，不能消耗太长时间，因为如果执行时间过长，那么其他的中断将被挂起，从而对其他中断造成严重的影响，但中断的处理往往又是复杂的，那么这就要引出我们接下来将提到的中断上半部和下半部！另外，在中断处理函数中一定不能调用调度器，即不能调用可能造成进程切换的函数（因为中断处理程序一旦被切换，将不能再次被调度）下面列举一些可能导致进程切换的函数：</p>\n<blockquote>\n<p>kfifo_to_user    kfifo_from_user   copy_from_user  copy_to_user  wait_event_xxx</p>\n</blockquote>\n<h3 id=\"4.linux%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E6%9E%B6%E6%9E%84%EF%BC%88top%20half%20%2B%20bottom%20half%EF%BC%89\">4.linux中断处理程序架构（top half + bottom half）</h3>\n<p>        设备的中断会打断内核中进程的正常调度和运行，系统为了效率必然要求中断服务程序进可能短小精悍。但是实际情况是中断需要完成的事情并不简单，需要消耗大量的时间。<br/>          linux内核的中断处理机制，为了解决这一问题，将中断程序设计成顶半部+底半部。顶半部完成较紧急的事情，剩下的事情挂到底半部中去执行，底半部中完成是事情相对复杂，也更加耗时，中断处理的重心也就落到了底半部中。</p>\n<h3 id=\"5.%E5%AE%9E%E7%8E%B0%E5%BA%95%E5%8D%8A%E9%83%A8%E7%9A%84%E6%9C%BA%E5%88%B6\">5.实现底半部的机制</h3>\n<h3 id=\"5.1%20%E8%BD%AF%E4%B8%AD%E6%96%AD\">5.1 软中断</h3>\n<p>软中断是中断下半部机制的一种</p>\n<blockquote>\n<p>struct softirq_action     //表述软中断的结构<br/> open_softirq();         //关联<br/> raise_softirq();         //触发软中断</p>\n</blockquote>\n<p>虽然软中断可以实现中断下半部，但软中断基本是内核开发者预定义好的，通常用在对性能要求比较高的场合，需要一些编程技巧，不太适合驱动开发者。</p>\n<h3 id=\"5.2%20tasklet\">5.2 tasklet</h3>\n<p>虽然软中断通常由内核开发者设计，但内核开发者保留了一个软中断给驱动开发者，就是TASKLET_SOFTIRQ，相应的函数原型：</p>\n<blockquote>\n<p>void tasklet_func(unsigned long);</p>\n<p> <br/> DECLARE_TASKLET(my_tasklet, tasklet_func, 0);          //定义my_tasklet,并关联处理函数</p>\n<p><br/> tasklet_schedule(&amp;my_tasklet);                         //调度，顶半部结尾处执行（对应的下半部保证至少会执行一次）<br/>  </p>\n</blockquote>\n<p>看示例代码：</p>\n<pre><code class=\"language-cpp\">struct resource *irqres;\nint my_probe(struct platform_device *pdev);\nint my_remove(struct platform_device *pdev);\n\n\nvoid my_task(unsigned long args);         \nDECLARE_TASKLET(mytasklet, my_task, 0);  //定义了mytasklet，并关联了处理函数\n\n#if 0\n   mykey3@1133{\n\t\t\tcompatible =\"fs,mykey3\";\n\t\t\tinterrupt-parent = &lt;&amp;gpx1&gt;;\n\t\t\tinterrupts = &lt;2 2&gt;;\n    };\n#endif \n\n\n//定义platform_driver对象\nstruct of_device_id of_matches[]={\n    {.compatible=\"fs,mykey3\"},           //修改匹配规则，从设备树  \n    {},                                  //获取key3相关硬件信息\n};\nstatic struct platform_driver mydriver ={\n    .probe = my_probe,\n    .remove = my_remove,\n    .driver = {\n        .name = \"key\",               \n        .of_match_table =  of_matches,  //通过设备树匹配\n    },\n};  \n\nirqreturn_t key_irq_handler(int irqnum, void *args)\n{\n    printk(\"top half \\n\");\n    tasklet_schedule(&amp;mytasklet);  //调度mytasklet\n    return IRQ_HANDLED;\n}\nvoid my_task(unsigned long args)\n{\n    printk(\"bottom half\\n\");\n    return ;\n}\n\nint my_probe(struct platform_device *pdev)\n{\n    int ret;\n    //通过设备树获取 硬件资源\n    printk(\"match\\n\");\n    irqres = platform_get_resource(pdev,IORESOURCE_IRQ,0);\n    if(irqres==NULL){\n        return -1;\n    }\n    printk(\"irqnum:%#x\\n\",irqres-&gt;start);\n\n    //硬件操作\n    ret = request_irq(irqres-&gt;start, key_irq_handler, irqres-&gt;flags,\"key3\",NULL);\n    if(ret!=0){\n        return ret;\n    }\n    printk(\"request irq\\n\");\n    \n    return 0;\n\n}\nint my_remove(struct platform_device *pdev)\n{\n    printk(\"driver remove\\n\");\n    free_irq(irqres-&gt;start,NULL);\n    return 0;\n}\n\n\nstatic int mod_init(void)\n{\n    return  platform_driver_register(&amp;mydriver);  //平台驱动注册\n}\nstatic void mod_exit(void)\n{\n    platform_driver_unregister(&amp;mydriver);        //平台驱动注销\n}\n\nmodule_init(mod_init);\nmodule_exit(mod_exit);\nMODULE_LICENSE(\"GPL\");</code></pre>\n<h3 id=\"5.3%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97\">5.3工作队列</h3>\n<p>前面讲解额下半部机制都有一个限制，软中断和tasklet中不能睡眠，也就是说在中断上下文中执行不能直接或间接地调用调度器，所以为了解决这个问题，内核提出了工作队列这种下半部机制，巩工作队列可以休眠。内核在启动的时候创建一个或多个内核工作线程，当工作线程取出工作队列的每一个工作，然后执行，当队列没有工作时，工作线程休眠。当驱动想要延迟执行某一个工作时，构造一个工作队列节点对象，然后加入到相应的工作队列，并唤醒工作线程，工作线程取出队列上的节点来完成工作，所有工作完成后又休眠。</p>\n<p>工作队列节点的结构类型定义：</p>\n<blockquote>\n<p>struct work_struct{<!-- --></p>\n<p>        atomic_long_t  data;  //传递给工作函数的参数，可以是一个整型数，但一般为指针</p>\n<p>        strruct list_head entry;//构成工作队列的链表节点对象</p>\n<p>        work_func_t    func;//工作函数</p>\n<p>..........................................</p>\n<p>};</p>\n</blockquote>\n<p>常用的与工作队列相关的函数和宏：</p>\n<blockquote>\n<p>struct work_struct xxx_wq;</p>\n<p>void xxx_do_work(struct work_struct *work);//工作函数</p>\n<p></p>\n<p>DECLARE_WORK(n,f)//静态定义一个工作队列节点，n为节点名字，f为工作函数</p>\n<p>DECLARE_DELAYED_WORK(n,f)//静态定义一个延迟的工作队列节点，n为节点名字，f为工作函数</p>\n<p>INIT_WORK(&amp;xxx_wq, xxx_do_work);    //动态分配的工作队列节点的初始化</p>\n<p></p>\n<p>schedule_work(&amp;xxx_wq);                                //调度将工作队列节点加入到内核定义的全局工作队列中，顶半部结尾处执行</p>\n<p>schedule_delayed_work(&amp;xxx_wq,unsigned long delay);                                //调度在delay指定的时间后将工作队列节点延迟加入到内核定义的全局工作队列中</p>\n</blockquote>\n<p>工作队列特性：</p>\n<p>1.工作队列的工作函数允许在进程上下文，可以调度调度器</p>\n<p>2.如果上一个工作还没有完成，又重新调度下一个工作，那么新的工作将不会被调度。</p>\n<p></p>\n<h2 id=\"%E6%97%B6%E9%92%9F\">时钟</h2>\n<p>在硬件的操作中经常会用到延时，比如要保持芯片的复位时间持续多久，芯片复位后至少要延迟多长时间才能去访问芯片，等。为此内核提供了一组延时操作函数。</p>\n<h3 id=\"1.%E5%86%85%E6%A0%B8%E5%BB%B6%E6%97%B6\">1.内核延时</h3>\n<blockquote>\n<p>//1.短延时<br/> void ndelay(unsigned long nsecs);  //纳秒<br/> void udelay(unsigned long usecs);  //微秒<br/> #define mdelay(n)   udelay((n) * 1000)  ;  //毫秒<br/> //本质都是忙等，是靠白白消耗CPU的时间来获得延时的，一般不推荐使用</p>\n<p></p>\n<p>//2.睡着延时<br/> void msleep(unsigned int msecs);                            //毫秒<br/> unsigned long msleep_interruptible(unsigned int msecs);  //毫秒，休眠可以被信号打断<br/> static inline void ssleep(unsigned int seconds);          //秒</p>\n<p></p>\n</blockquote>\n<h3 id=\"2.%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8\">2.内核定时器</h3>\n<p>有时候需要在设定的时间到期后自动执行一个操作，这就是定时。经典的定时器都是基于一个硬件定时器的，该定时器周期性产生中断，产生中断的次数可以进行配置，内核源码中以HZ这个宏来代表这个配置值，也就是说这个硬件定时器每秒钟就会产生HZ次中断。该定时器自开机以来产生的中断次数会被记录在<span style=\"color:#fe2c24;\"><strong>jiffies全局变量</strong></span>中。</p>\n<blockquote>\n<p>struct timer_list {<!-- --><br/>     struct list_head entry;                //双向链表节点的对象，用于构成双向链表<br/>     unsigned long expires;             //定时值 （是当前jiffies基础上添加的一个延时）<br/>     struct tvec_base *base;<br/>     void (*function)(unsigned long);   //定时器处理函数<br/>     unsigned long data;                //传参，通常为一个指针<br/>     int slack;</p>\n<p><br/> #ifdef CONFIG_TIMER_STATS<br/>     int start_pid;<br/>     void *start_site;<br/>     char start_comm[16];<br/> #endif</p>\n<p><br/> #ifdef CONFIG_LOCKDEP<br/>     struct lockdep_map lockdep_map;<br/> #endif<br/> }</p>\n</blockquote>\n<p>低分辨率定时器的相关函数如下：</p>\n<blockquote>\n<p><strong>struct timer_list my_timer;   //定义定时器<br/> void init_timer(struct timer_list *timer);  //初始化<br/> void add_timer(struct timer_list *timer);   //注册并启动，将定时器添加到内核中的定时器链表中<br/> int del_timer(struct timer_list * timer);  //删除，从内核链表中删除该定时器<br/> int del_timer_sync(struct timer_list *timer); //等待使用完后删除<br/> int mod_timer(struct timer_list *timer, unsigned long expires); //修改</strong></p>\n</blockquote>\n<p>看一段代码：</p>\n<pre><code class=\"language-cpp\">struct resource *irqres;\nint my_probe(struct platform_device *pdev);\nint my_remove(struct platform_device *pdev);\n\n\nstruct timer_list mytimer; //定义定时器对象\n\nvoid timer_out(unsigned long args);  //定时器处理函数\n\n//定义platform_driver对象\nstruct of_device_id of_matches[]={\n    {.compatible=\"fs,mykey3\"},           //修改匹配规则，从设备树  \n    {},                                  //获取key3相关硬件信息\n};\nstatic struct platform_driver mydriver ={\n    .probe = my_probe,\n    .remove = my_remove,\n    .driver = {\n        .name = \"key\",               \n        .of_match_table =  of_matches,  //通过设备树匹配\n    },\n};  \n\nvoid timer_out(unsigned long args)\n{\n    printk(\"timer out\\n\");\n\n    mod_timer(&amp;mytimer,jiffies+2*HZ); //周期执行，定时2s\n\n}\n\nint my_probe(struct platform_device *pdev)\n{\n    printk(\"match\\n\");\n\n    init_timer(&amp;mytimer);                //初始化定时器\n    \n    mytimer.function = timer_out;\n    mytimer.expires = jiffies + 2*HZ ;   //延时2s\n    \n    add_timer(&amp;mytimer);                 //注册到内核，并启动\n    \n    return 0;\n\n}\nint my_remove(struct platform_device *pdev)\n{\n    printk(\"driver remove\\n\");\n\n    del_timer_sync(&amp;mytimer);\n    //删除定时器\n    return 0;\n\n}\n\n\nstatic int mod_init(void)\n{\n    return  platform_driver_register(&amp;mydriver);  //平台驱动注册\n}\nstatic void mod_exit(void)\n{\n    platform_driver_unregister(&amp;mydriver);        //平台驱动注销\n}\n\nmodule_init(mod_init);\nmodule_exit(mod_exit);\nMODULE_LICENSE(\"GPL\");</code></pre>\n<h3 id=\"3.%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97\">3.延时队列</h3>\n<p>对于周期性的任务，linux内核还提供一种封装好延时队列(delayed_work),本质是利用工作队列+定时器实现。</p>\n<blockquote>\n<p>struct delayed_work {<!-- --><br/>      struct work_struct work;<br/>      struct timer_list timer; <br/>      struct workqueue_struct *wq;<br/>      int cpu;<br/> };</p>\n</blockquote>\n<blockquote>\n<p>struct delayed_work delaytask;                   //定义<br/> void my_delay_work(struct work_struct *work);       //设计处理函数<br/> INIT_DELAYED_WORK(&amp;delaytask,my_delay_work);      //关联</p>\n</blockquote>\n<blockquote>\n<p>static inline bool schedule_delayed_work(struct delayed_work *dwork,                      unsigned long delay); //定时执行</p>\n<p></p>\n<p>//取消delayed_work<br/> bool cancel_delayed_work(struct delayed_work *dwork);<br/> bool cancel_delayed_work_sync(struct delayed_work *dwork);</p>\n</blockquote>\n<pre><code class=\"language-cpp\">struct resource *irqres;\nint my_probe(struct platform_device *pdev);\nint my_remove(struct platform_device *pdev);\n\nstruct delayed_work delaytask;//定义延时队列对象\nvoid my_delay_work(struct work_struct *work);//延时工作函数\n\n//定义platform_driver对象\nstruct of_device_id of_matches[]={\n    {.compatible=\"fs,mykey3\"},           //修改匹配规则，从设备树  \n    {},                                  //获取key3相关硬件信息\n};\nstatic struct platform_driver mydriver ={\n    .probe = my_probe,\n    .remove = my_remove,\n    .driver = {\n        .name = \"key\",               \n        .of_match_table =  of_matches,  //通过设备树匹配\n    },\n};  \nvoid my_delay_work(struct work_struct *work)\n{\n    printk(\"my_delay_work\\n\");\n    schedule_delayed_work(&amp;delaytask, 2*HZ);  \n}\n\nint my_probe(struct platform_device *pdev)\n{\n    printk(\"match\\n\");\n\n    INIT_DELAYED_WORK(&amp;delaytask,my_delay_work);//关联\n    \n    schedule_delayed_work(&amp;delaytask, 2*HZ);  //定时2s执行\n    \n    return 0;\n\n}\n\nint my_remove(struct platform_device *pdev)\n{\n    printk(\"driver remove\\n\");\n\n    cancel_delayed_work_sync(&amp;delaytask);\n    \n    return 0;\n\n}\n\n\nstatic int mod_init(void)\n{\n    return  platform_driver_register(&amp;mydriver);  //平台驱动注册\n}\nstatic void mod_exit(void)\n{\n    platform_driver_unregister(&amp;mydriver);        //平台驱动注销\n}\n\nmodule_init(mod_init);\nmodule_exit(mod_exit);\nMODULE_LICENSE(\"GPL\");</code></pre>\n<p></p>\n<p></p>\n</div>\n</div>"}