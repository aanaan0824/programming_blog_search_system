{"blogid": "126741934", "writerAge": "码龄1年", "writerBlogNum": "56", "writerCollect": "0", "writerComment": "0", "writerFan": "3", "writerGrade": "3级", "writerIntegral": "588", "writerName": "编程界的谢菲尔德", "writerProfileAdress": "writer_image\\profile_126741934.jpg", "writerRankTotal": "38579", "writerRankWeekly": "11268", "writerThumb": "1", "writerVisitNum": "7750", "blog_read_count": "13", "blog_time": "于 2022-09-07 11:36:40 发布", "blog_title": "c++新特性 深入元组", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h1><strong>1.元组简介</strong></h1>\n<p>tuple是一个固定大小的不同类型值的集合，是泛化的std::pair。我们也可以把他当做一个通用的结构体来用，不需要创建结构体又获取结构体的特征，在某些情况下可以取代结构体使程序更简洁，直观。std::tuple理论上可以有无数个任意类型的成员变量，而std::pair只能是2个成员，因此在需要保存3个及以上的数据时就需要使用tuple元组了。</p>\n<p>    tuple（元组）在c++11中开始引用的。tuple看似简单，其实它是简约而不简单，可以说它是c++11中一个既简单又复杂的东东，关于它简单的一面是它很容易使用，复杂的一面是它内部隐藏了太多细节，要揭开它神秘的面纱时又比较困难。</p>\n<h1>2.tuple的创建以及初始化</h1>\n<blockquote>\n<p>std::string name;<br/> std::tuple&lt;string &amp;, int&gt; tpRef(name, 30);<br/> // 对tpRef第一个元素赋值，同时name也被赋值 - 引用<br/> std::get&lt;0&gt;(tpRef) = \"Sven\";<br/>  <br/> // name输出也是Sven<br/> std::cout &lt;&lt; \"name: \" &lt;&lt; name &lt;&lt; '\\n';</p>\n</blockquote>\n<h1> 3.有关tuple的操作</h1>\n<h2> 3.1等价结构体</h2>\n<p>     开篇讲过在某些时候tuple可以等同于结构体一样使用，这样既方便又快捷。如</p>\n<pre><code class=\"language-cpp\">struct person {\n    char *m_name;\n    char *m_addr;\n    int  *m_ages;\n};\n \n//可以用tuple来表示这样的一个结构类型，作用是一样的。\nstd::tuple&lt;const char *, const char *, int&gt;</code></pre>\n<h2> 3.2获取元组取个数和合并元组</h2>\n<p>tuple_size&lt;decltype(u)&gt;::value;</p>\n<p>tuple_cat;</p>\n<pre><code class=\"language-cpp\">#include&lt;tuple&gt;\n#include&lt;iostream&gt;\n\nint main()\n{\n    std::tuple&lt;double,char,std::string&gt; u(2.6,'c',\"王五\");\n    std::cout&lt;&lt;std::tuple_size&lt;decltype(u)&gt;::value&lt;&lt;std::endl;\n    std::tuple&lt;double,char,std::string&gt; v(1.6,'d',\"陈六\");\n    auto new_tuple=std::tuple_cat(std::move(u),std::move(v));\n    std::cout&lt;&lt;std::get&lt;5&gt;(new_tuple)&lt;&lt;\"\\n\";\n}</code></pre>\n<h1>3.3获取元组类型</h1>\n<pre><code class=\"language-cpp\">std::tuple&lt;std::string, int&gt; tp(\"Sven\", 20);\n \n// 得到第二个元素类型\n \nstd::tuple_element&lt;1, decltype(tp)&gt;::type ages;  // ages就为int类型\n \nages = std::get&lt;1&gt;(tp);\n \nstd::cout &lt;&lt; \"ages: \" &lt;&lt; ages &lt;&lt; '\\n';\n \n//输出结果： \nages: 20</code></pre>\n<h2>3.4解包和引用</h2>\n<pre><code class=\"language-cpp\">#include&lt;tuple&gt;\n#include&lt;iostream&gt;\n#include&lt;variant&gt;\n\nauto get_student(int id)\n{\n    if(id==0)\n    return std::make_tuple(3.8,'A',\"张三\");\n     if(id==1)\n    return std::make_tuple(3.3,'c',\"李四\");\n     if(id==2)\n    return std::make_tuple(2.9,'d',\"王五\");\n    return std::make_tuple(0.0,'D',\"null\");\n    \n}\nint main()\n{\n    auto student=get_student(0);\n    std::cout &lt;&lt; \"ID: 0, \"\n    &lt;&lt; \"GPA: \" &lt;&lt; std::get&lt;0&gt;(student) &lt;&lt; \", \"\n    &lt;&lt; \" 成绩: \" &lt;&lt; std::get&lt;1&gt;(student) &lt;&lt; \", \"\n    &lt;&lt; \" 姓名: \" &lt;&lt; std::get&lt;2&gt;(student) &lt;&lt; '\\n';\n    double gpa;\n    char grade;\n    std::string name;\n\n    std::tie(gpa,grade,name)=get_student(1);\n    std::cout &lt;&lt; \"ID: 1, \"\n    &lt;&lt; \"GPA: \" &lt;&lt; gpa &lt;&lt; \", \"\n    &lt;&lt; \" 成绩: \" &lt;&lt; grade &lt;&lt; \", \"\n    &lt;&lt; \" 姓名: \" &lt;&lt; name &lt;&lt; \"\\n\";\n     \n     \n}\n//output\nID: 0, GPA: 3.8,  成绩: A,  姓名: 张三\nID: 1, GPA: 3.3,  成绩: c,  姓名: 李四</code></pre>\n<p>但有时候tuple包含的多个元素时只需要其中的一个或两个元素，如此可以通过std::ignore进行变量占位，这样将会忽略提取对应的元素</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;tuple&gt;\n#include &lt;utility&gt;\n \nint main(int argc, char **argv) {\n    std::tuple&lt;std::string, int, std::string, int&gt; tp;\n    tp = std::make_tuple(\"Sven\", 25, \"Shanghai\", 21);\n \n    // 定义接收变量\n    std::string name;\n    std::string addr;\n    int ages;\n    int areaCode = 110;\n \n    std::tie(name, ages, std::ignore, std::ignore) = tp;\n    std::cout &lt;&lt; \"Output: \" &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"name: \" &lt;&lt; name &lt;&lt;\", \";\n    std::cout &lt;&lt; \"addr: \" &lt;&lt; addr &lt;&lt; \", \";\n    std::cout &lt;&lt; \"ages: \" &lt;&lt; ages &lt;&lt; \", \";\n    std::cout &lt;&lt; \"areaCode: \" &lt;&lt; areaCode &lt;&lt; '\\n';\n \n    return 0;\n}\n \n//输出结果：\nOutput: \nname: Sven, addr: , ages: 25, areaCode: 110</code></pre>\n<h2>3.5遍历</h2>\n<pre>tuple不支持迭代，只能通过元素索引(或tie解包)进行获取元素的值。但是给定的索引必须是在编译器就已经给定，不能在运行期进行动态传递，否则将发生编译错误：\n</pre>\n<blockquote>\n<p>tuple不支持迭代，只能通过元素索引(或tie解包)进行获取元素的值。但是给定的索引必须是在编译器就已经给定，不能在运行期进行动态传递，否则将发生编译错误：</p>\n</blockquote>\n<p> 正确遍历：</p>\n<pre><code class=\"language-cpp\">// 帮助程序用于将元组转换为可变参数模板函数参数\n// sequence_generator&lt;3&gt;::type will be sequence&lt;0, 1, 2&gt;.\ntemplate &lt;int...&gt;\nstruct sequence {};\ntemplate &lt;int N, int... S&gt;\nstruct sequence_generator : sequence_generator&lt;N - 1, N - 1, S...&gt; {};\ntemplate &lt;int... S&gt;\nstruct sequence_generator&lt;0, S...&gt; {\n  typedef sequence&lt;S...&gt; type;\n};\n\ntemplate&lt;typename T, typename F, int... S&gt;\nvoid for_each(T&amp;&amp; t, F f, sequence&lt;S...&gt;)\n{\n    auto l = { (f(std::get&lt;S&gt;(t)), 0)... };\n}\n\ntemplate&lt;typename... Args, typename F&gt;\nvoid for_each_in_tuple(std::tuple&lt;Args...&gt; const&amp; t, F f)\n{\n    for_each(t, f, typename sequence_generator&lt;sizeof...(Args)&gt;::type());\n}\n\nstruct functor {\n    template&lt;typename T&gt;\n    void operator()(T&amp;&amp; t)\n    {\n        std::cout &lt;&lt; t &lt;&lt; std::endl;\n    }\n};\n\nint main()\n{\n    std::tuple&lt;double, char, std::string&gt; t = std::make_tuple(3.14, 'A', \"StoneLiu\");\n    for_each_in_tuple(t, functor());\n}\n</code></pre>\n<p></p>\n</div>\n</div>"}