{"blogid": "126690354", "writerAge": "码龄4年", "writerBlogNum": "225", "writerCollect": "1076", "writerComment": "188", "writerFan": "11959", "writerGrade": "5级", "writerIntegral": "4071", "writerName": "小毕超", "writerProfileAdress": "writer_image\\profile_126690354.jpg", "writerRankTotal": "4055", "writerRankWeekly": "688", "writerThumb": "640", "writerVisitNum": "739624", "blog_read_count": "108", "blog_time": "于 2022-09-04 16:16:16 发布", "blog_title": "CGLIB 动态代理使用", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h2><a id=\"CGLIB_0\"></a>一、CGLIB</h2>\n<p>Cglib是一个强大的，高性能，高质量的代码生成类库。它可以在运行期扩展JAVA类与实现JAVA接口。其底层实现是通过ASM字节码处理框架来转换字节码并生成新的类。大部分功能实际上是ASM所提供的，Cglib只是封装了ASM，简化了ASM操作，实现了运行期生成新的class。</p>\n<p>运行时动态的生成一个被代理类的子类（通过ASM字节码处理框架实现），子类重写了被代理类中所有非 final 的方法。在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势植入横切逻辑。</p>\n<p><strong>Cglib优缺点：</strong></p>\n<p><strong>优点</strong>：JDK动态代理要求被代理的类必须实现接口，当需要代理的类没有实现接口时Cglib代理是一个很好的选择。实现扩展功能，对我们方法实现增强、安全性、冗余性提高代码复用机制。</p>\n<p><strong>缺点</strong>：对于被代理类中的final方法，无法进行代理，因为子类中无法重写final函数</p>\n<p>注意：jdk7 开始 jdk 动态代理效率比 cglib 要高。</p>\n<h2><a id=\"CGLIB_13\"></a>二、CGLIB代理实现</h2>\n<p>实现 MethodInterceptor 接口的 intercept 方法后，所有生成的代理方法都调用这个方法。<br/> intercept方法的具体参数有</p>\n<ol><li>obj 目标类的实例</li><li>method 目标方法实例（通过反射获取的目标方法实例）</li><li>args 目标方法的参数</li><li>proxy 代理类的实例<br/> 该方法的返回值就是目标方法的返回值。</li></ol>\n<pre><code>@Slf4j\npublic class CglibMethodInterceptor implements MethodInterceptor {\n    @Override\n    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {\n        log.info(\"&lt;目标方法之前开始执行....&gt;\");\n        Object result = proxy.invokeSuper(obj, args);\n        log.info(\"&lt;目标方法之后开始执行....&gt;\");\n        return result;\n    }\n}\n</code></pre>\n<p>创建目标代理对象：</p>\n<pre><code>@Slf4j\npublic class TargetObject {\n    \n    public String exec(String param) {\n        log.info(\"&lt;param:{}&gt;\", param);\n        return \"ok\";\n    }\n}\n</code></pre>\n<p>使用 CGLIB 代理目标方法：</p>\n<pre><code>public class Test {\n    public static void main(String[] args) {\n        Enhancer enhancer = new Enhancer();\n        enhancer.setSuperclass(TargetObject.class);\n        enhancer.setCallback(new CglibMethodInterceptor());\n        TargetObject targetObject = (TargetObject) enhancer.create();\n        String result = targetObject.exec(\"ABC\");\n        System.out.println(result);\n    }\n}\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\cb993814d59c47758f8d0832c5295a99.png\"/></p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}