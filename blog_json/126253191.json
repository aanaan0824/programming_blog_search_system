{"blogid": "126253191", "writerAge": "码龄2年", "writerBlogNum": "73", "writerCollect": "1114", "writerComment": "728", "writerFan": "2646", "writerGrade": "5级", "writerIntegral": "2905", "writerName": "你帅你先说.", "writerProfileAdress": "writer_image\\profile_126253191.jpg", "writerRankTotal": "6616", "writerRankWeekly": "719", "writerThumb": "1334", "writerVisitNum": "83345", "blog_read_count": "10995", "blog_time": "于 2022-08-17 21:33:14 发布", "blog_title": "[计算机网络]HTTP、UDP、TCP协议", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-light\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<blockquote>\n<p>●🧑个人主页:<a href=\"https://blog.csdn.net/qq_52363432?type=lately\">你帅你先说.</a><br/> ●📃欢迎点赞👍关注💡收藏💖<br/> ●📖既选择了远方，便只顾风雨兼程。<br/> ●🤟欢迎大家有问题随时私信我！<br/> ●🧐版权：本文由<font color=\"orange\" face=\"黑体\" size=\"3\">[你帅你先说.]</font>原创，CSDN首发，侵权必究。</p>\n</blockquote>\n<p></p>\n<div class=\"toc\">\n<h3>📌📌📌为您导航📌📌📌</h3>\n<ul><li><a href=\"#1HTTP_7\">1.HTTP协议</a></li><li><ul><li><a href=\"#11URL_8\">1.1URL</a></li><li><a href=\"#12HTTP_32\">1.2HTTP协议格式</a></li><li><ul><li><a href=\"#121HTTP_33\">1.2.1HTTP请求格式</a></li><li><a href=\"#122HTTP_38\">1.2.2HTTP响应格式</a></li></ul>\n</li><li><a href=\"#13HTTP_42\">1.3HTTP封装和解包</a></li><li><a href=\"#14HTTP_52\">1.4HTTP方法</a></li><li><a href=\"#15HTTP_69\">1.5HTTP状态码</a></li><li><a href=\"#16cookiesession_91\">1.6cookie和session</a></li><li><a href=\"#17HTTP_102\">1.7HTTP报文属性</a></li><li><a href=\"#18HTTP_113\">1.8HTTP简易实现</a></li></ul>\n</li><li><a href=\"#2_281\">2.传输层</a></li><li><ul><li><a href=\"#21_282\">2.1再谈端口号</a></li><li><a href=\"#22_287\">2.2端口号范围划分</a></li><li><a href=\"#23_308\">2.3常见查看网络状态命令</a></li><li><a href=\"#24UDP_326\">2.4UDP协议</a></li><li><ul><li><a href=\"#241UDP_327\">2.4.1UDP协议段格式</a></li><li><a href=\"#242UDP_333\">2.4.2UDP的特点</a></li><li><a href=\"#243UDP_338\">2.4.3UDP的缓冲区</a></li><li><a href=\"#244UDP_344\">2.4.4基于UDP的应用层协议</a></li></ul>\n</li><li><a href=\"#25TCP_352\">2.5TCP协议</a></li><li><ul><li><a href=\"#251TCP_353\">2.5.1TCP协议段格式</a></li><li><a href=\"#252TCP_390\">2.5.2TCP缓冲区</a></li><li><a href=\"#253_396\">2.5.3超时重传机制</a></li><li><a href=\"#254_411\">2.5.4连接管理机制</a></li></ul>\n</li></ul>\n</li></ul>\n</div>\n<p></p>\n<h1><a id=\"1HTTP_7\"></a>1.HTTP协议</h1>\n<h2><a id=\"11URL_8\"></a>1.1URL</h2>\n<blockquote>\n<p>平时我们俗称的 “网址” 其实就是说的 URL。</p>\n</blockquote>\n<p>前面说过，<code>IP + Port </code>可以唯一的确定网络中的一个进程，但是我们无法唯一确定一个资源。我们所谓的网络资源，一定是存在于网络中的一台Linux机器上，Linux保存资源的方式，都是以文件的方式保存的，而Linux标识唯一 一个资源的方式是通过路径。所以我们就通过<code>IP+Linux路径</code>来唯一确认一个网络资源，也就是URL。<br/> 那URL由什么组成？<br/> 来看下面这个例子</p>\n<pre><code>http://www.xxx.com:80/dir/index.htm?uid=1#ch1\n</code></pre>\n<p><code>http</code>:使用的协议<br/> <code>www.xxx.com</code>:服务器地址<br/> <code>80</code>:端口号<br/> <code>dir/index.htm</code>:带层次的文件路径<br/> <strong>urlencode和urldecode</strong></p>\n<blockquote>\n<p>像 / ? : 等这样的字符, 已经被url当做特殊意义理解了。因此这些字符不能随意出现。<br/> 比如, 某个参数中需要带有这些特殊字符, 就必须先对特殊字符进行转义</p>\n</blockquote>\n<p><strong>转义的规则如下:</strong><br/> 将需要转码的字符转为16进制，然后从右到左，取4位(不足4位直接处理)，每2位做一位，前面加上%，编码成%XY格式。<br/> 例如:<br/> A7FFE8B4<br/> 转义后<br/> %A7%FF%E8%B4</p>\n<h2><a id=\"12HTTP_32\"></a>1.2HTTP协议格式</h2>\n<h3><a id=\"121HTTP_33\"></a>1.2.1HTTP请求格式</h3>\n<p>首先我们要知道的是，无论是请求还是响应，http基本上都是<code>按照行为单位</code>进行构建请求或者响应的。<br/> <img alt=\"在这里插入图片描述\" src=\"image\\ee0a91c4d7bc44e09be888eaed61f991.png\"/><br/> 请求行+请求报头+空行我们称为<code>http请求报头</code>。<br/> 请求正文我们称为<code>有效载荷</code>。</p>\n<h3><a id=\"122HTTP_38\"></a>1.2.2HTTP响应格式</h3>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\f1356655039c4e33a76b8fa1ca1bccd9.png\"/><br/> 响应行+响应报头+空行我们称为<code>http响应报头</code>。<br/> 响应正文我们称为<code>有效载荷</code>。</p>\n<h2><a id=\"13HTTP_42\"></a>1.3HTTP封装和解包</h2>\n<p>首先，http的读取和发送都是把协议内容处理成一个<code>大字符串</code>，例如:<br/> xxxx\\n<br/> yyyy\\n<br/> zzzz\\n<br/> 处理后<br/> “xxxx\\nyyyy\\nzzzz\\n”<br/> http格式里有一个空行，这个空行将http一分为二，当读到空行，我们就知道我已经把报头部分给读完了。<br/> 也就是这样一个过程，先读第一行，把请求行读完了，然后不断往下读，直到读到空行，说明报头部分也被读完了，接下来读取正文部分，那么问题来了，读取正文的时候要怎么判定什么时候读取结束？？？实际上在报头中有一个<code>Content-Length</code>属性，它的大小即为正文的大小，所以我们可以根据这个来决定什么时候读取结束。(没有正文情况不存在Content-Length)在这里还要在补充一个http报头里经常会出现的属性:<code>Content-Type</code>，它描述的是正文的类型。</p>\n<h2><a id=\"14HTTP_52\"></a>1.4HTTP方法</h2>\n<table><thead><tr><th>方法</th><th>说明</th><th>支持的HTTP协议版本</th></tr></thead><tbody><tr><td><strong>GET</strong></td><td><strong>获取资源</strong></td><td><strong>1.0、1.1</strong></td></tr><tr><td><strong>POST</strong></td><td><strong>传输实体主体</strong></td><td><strong>1.0、1.1</strong></td></tr><tr><td>PUT</td><td>传输文件</td><td>1.0、1.1</td></tr><tr><td><strong>HEAD</strong></td><td><strong>获得报文首部</strong></td><td><strong>1.0、1.1</strong></td></tr><tr><td>DELETE</td><td>删除文件</td><td>1.0、1.1</td></tr><tr><td>OPTIONS</td><td>询问支持的方法</td><td>1.1</td></tr><tr><td>TRACE</td><td>追踪的路径</td><td>1.1</td></tr></tbody></table>\n<p>我们可以通过<code>GET / HTTP/1.0</code>这种方法来获取资源，这里特别注意<code>/</code>并不是我们之前所说的根目录，而是web根目录。说的简单点，如果这样写默认请求的就是<code>网站的首页</code>。<br/> <strong>GET和POST的区别</strong><br/> <strong>GET:</strong><br/> 如果提交参数(假设是网页中提交表单信息)，GET是通过URL的方式进行提交的。例如:<code>GET /a/b/xxxxxname=hello&amp;passwd=123456 HTTP/1.1</code>。GET方法不私密，会将重要信息回显到URL的输入框。GET方法通过URL提交参数，而URL是有大小限制的。<br/> <strong>POST:</strong><br/> 如果提交参数(假设是网页中提交表单信息)，POST是通过正文提交参数的。例如:<code>name=hello&amp;passwd=123456</code>这个会出现在正文内容里，所以说POST方法更私密(私密并不等于安全)。POST方法通过正文提交参数，一般正文没有大小限制。</p>\n<h2><a id=\"15HTTP_69\"></a>1.5HTTP状态码</h2>\n<table><thead><tr><th></th><th>类别</th><th>原因短语</th></tr></thead><tbody><tr><td>1xx</td><td>Informational(信息性状态码)</td><td>接收的请求正在处理</td></tr><tr><td>2xx</td><td>Success(成功状态码)</td><td>接求正常处理完毕</td></tr><tr><td>3xx</td><td>Redirection(重定向状态码)</td><td>需要进行附加操作以完成请求</td></tr><tr><td>4xx</td><td>Client Error(客户端错误状态码)</td><td>服务器无法处理请求</td></tr><tr><td>5xx</td><td>Server Error(服务器错误状态码)</td><td>服务器处理请求出错</td></tr></tbody></table>\n<p>状态码实际上对我们来说是一个既熟悉又陌生的概念，我这样说这个概念可能大家会懵逼。<br/> <img alt=\"在这里插入图片描述\" src=\"image\\06e6d6f054a44d7ab1cdf251ecb0d3f7.png\"/><br/> 当你看到这张图，你就瞬间明白了状态码是什么。<br/> 最常见的状态码, 比如<code>200(OK), 404(Not Found), 403(Forbidden), 302(Redirect, 重定向), 504(Bad Gateway)</code><br/> 在这里我们要重点来讲一讲3开头的重定向。<br/> 重定向分为两种:<br/> 1.永久重定向301<br/> 2.临时重定向302或307<br/> <strong>永久重定向:</strong><br/> 当一个网站搬迁时，你访问旧网址肯定是访问不上的，那么老用户可能也不知道新网址是什么，永久重定向就是当你访问旧网址的时候帮你直接跳转到新网站。如果旧网址有被你保存到书签里，网站还会自动帮你更新为新网址。<br/> <strong>临时重定向:</strong><br/> 当你在某个网站需要输入账号密码时，登录完成后会自动跳转回某个页面。<br/> 因为重定向是由浏览器给我们提供支持的，所以浏览器必须识别这些状态，并告诉我们应该跳转到哪一个页面去，所以HTTP的报头里还会有一个属性Location，就是用来表示新的网址的。</p>\n<h2><a id=\"16cookiesession_91\"></a>1.6cookie和session</h2>\n<p>在平时上网过程中不知道你有没有发现这样一种现象，比如你上b站，当你登录了一次之后，下一次再访问b站实际上就已经是登录状态了，不需要再手动登录，我们知道<code>HTTP协议本身是一种无状态的协议</code>，所以HTTP不会保存你的登录状态。但HTTP可以提供一些技术支持来保证网站具有<code>\"会话保持\"</code>功能，而cookie就是用来做会话保持的。<br/> 我们可以自己手动查看cookie的。<br/> <img alt=\"在这里插入图片描述\" src=\"image\\e4e60ae91f72484d9f52ab3a158fd2c1.png\"/><br/> <strong>cookie</strong><br/> 1.cookie其实是一个文件，该文件里面保存的是我们用户的私密信息<br/> 2.若网站有cookie，则HTTP在发起任何请求的时候，都会自动在报文中携带该cookie信息。<br/> cookie有分为<code>文件版</code>和<code>内存版</code>。文件版即使把页面关了信息也还存在，内存版当把页面关闭就会自动销毁信息。<br/> cookie虽好，但单纯使用cookie是具有一定的安全隐患的。如果别人盗取了cookie文件，那么就可以以我的身份来获取我的资源。所以就有了一个新的技术:session。<br/> session技术的核心手段就是<code>把用户的私密信息保存在服务器端。</code><br/> HTTP报文属性里保留了session的id，这个session id具有唯一标识session文件的功能，可以通过session id来找到服务器磁盘上对应的session文件。</p>\n<h2><a id=\"17HTTP_102\"></a>1.7HTTP报文属性</h2>\n<p>报文里的属性上面我们已经提到了很多，在这里做一个总结。</p>\n<blockquote>\n<p><code>Content-Type</code>: 数据类型(text/html等)。<br/> <code>Content-Length</code>: 正文的长度。<br/> <code>Host</code>: 客户端告知服务器, 所请求的资源是在哪个主机的哪个端口上。<br/> <code>User-Agent</code>: 声明用户的操作系统和浏览器版本信息。<br/> <code>referer</code>: 当前页面是从哪个页面跳转过来的。<br/> <code>location</code>: 搭配3xx状态码使用, 告诉客户端接下来要去哪里访问。<br/> <code>Cookie</code>: 用于在客户端存储少量信息. 通常用于实现会话(session)的功能。<br/> <code>Connection</code>:链接方式，1.0使用的是短链接(一个请求，一个响应)，1.1使用的是长链接(一个链接，一直保持不中断，通过减少频繁建立tcp链接来达到提高效率的目的)。keep-alive表示长链接，close表示短链接。</p>\n</blockquote>\n<h2><a id=\"18HTTP_113\"></a>1.8HTTP简易实现</h2>\n<p><strong>makefile</strong></p>\n<pre><code class=\"prism language-c\">Http<span class=\"token operator\">:</span>Http<span class=\"token punctuation\">.</span>cpp\n\tg<span class=\"token operator\">++</span> <span class=\"token operator\">-</span>o $@ $<span class=\"token operator\">^</span> <span class=\"token operator\">-</span>std<span class=\"token operator\">=</span>c<span class=\"token operator\">++</span><span class=\"token number\">11</span> <span class=\"token operator\">-</span>lpthread\n\n<span class=\"token punctuation\">.</span>PHONY<span class=\"token operator\">:</span>clean\nclean<span class=\"token operator\">:</span>\n\trm <span class=\"token operator\">-</span>f Http\n</code></pre>\n<p>为了方便后续使用，我们将之前的各种接口封装成一个类。<br/> <strong>sock.hpp</strong></p>\n<pre><code class=\"prism language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">pragma</span> <span class=\"token expression\">once</span></span>\n\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream&gt;</span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;string&gt;</span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;cstring&gt;</span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;cstdlib&gt;</span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;sys/socket.h&gt;</span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;netinet/in.h&gt;</span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;arpa/inet.h&gt;</span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;unistd.h&gt;</span></span>\n\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Sock</span>\n<span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">Socket</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token keyword\">int</span> sock <span class=\"token operator\">=</span> <span class=\"token function\">socket</span><span class=\"token punctuation\">(</span>AF_INET<span class=\"token punctuation\">,</span> SOCK_STREAM<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>sock <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{<!-- --></span>\n            cerr <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"socket error\"</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n            <span class=\"token function\">exit</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> sock<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">Bind</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> sock<span class=\"token punctuation\">,</span> <span class=\"token keyword\">uint16_t</span> port<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token keyword\">struct</span> <span class=\"token class-name\">sockaddr_in</span> local<span class=\"token punctuation\">;</span>\n        <span class=\"token function\">memset</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>local<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>local<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        local<span class=\"token punctuation\">.</span>sin_family <span class=\"token operator\">=</span> AF_INET<span class=\"token punctuation\">;</span>\n        local<span class=\"token punctuation\">.</span>sin_port <span class=\"token operator\">=</span> <span class=\"token function\">htons</span><span class=\"token punctuation\">(</span>port<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        local<span class=\"token punctuation\">.</span>sin_addr<span class=\"token punctuation\">.</span>s_addr <span class=\"token operator\">=</span> INADDR_ANY<span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span>sock<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> <span class=\"token class-name\">sockaddr</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token operator\">&amp;</span>local<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>local<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{<!-- --></span>\n            cerr <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"bind error!\"</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n            <span class=\"token function\">exit</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">Listen</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> sock<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">listen</span><span class=\"token punctuation\">(</span>sock<span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{<!-- --></span>\n            cerr <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"listen error !\"</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n            <span class=\"token function\">exit</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">Accept</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> sock<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token keyword\">struct</span> <span class=\"token class-name\">sockaddr_in</span> peer<span class=\"token punctuation\">;</span>\n        socklen_t len <span class=\"token operator\">=</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>peer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> fd <span class=\"token operator\">=</span> <span class=\"token function\">accept</span><span class=\"token punctuation\">(</span>sock<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> <span class=\"token class-name\">sockaddr</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token operator\">&amp;</span>peer<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>len<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>fd <span class=\"token operator\">&gt;=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{<!-- --></span>\n            <span class=\"token keyword\">return</span> fd<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">Connect</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> sock<span class=\"token punctuation\">,</span> std<span class=\"token double-colon punctuation\">::</span>string ip<span class=\"token punctuation\">,</span> <span class=\"token keyword\">uint16_t</span> port<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token keyword\">struct</span> <span class=\"token class-name\">sockaddr_in</span> server<span class=\"token punctuation\">;</span>\n        <span class=\"token function\">memset</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>server<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>server<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        server<span class=\"token punctuation\">.</span>sin_family <span class=\"token operator\">=</span> AF_INET<span class=\"token punctuation\">;</span>\n        server<span class=\"token punctuation\">.</span>sin_port <span class=\"token operator\">=</span> <span class=\"token function\">htons</span><span class=\"token punctuation\">(</span>port<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        server<span class=\"token punctuation\">.</span>sin_addr<span class=\"token punctuation\">.</span>s_addr <span class=\"token operator\">=</span> <span class=\"token function\">inet_addr</span><span class=\"token punctuation\">(</span>ip<span class=\"token punctuation\">.</span><span class=\"token function\">c_str</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token function\">connect</span><span class=\"token punctuation\">(</span>sock<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> <span class=\"token class-name\">sockaddr</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token operator\">&amp;</span>server<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>server<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{<!-- --></span>\n            cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Connect Success!\"</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">else</span>\n        <span class=\"token punctuation\">{<!-- --></span>\n            cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Connect Failed!\"</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n            <span class=\"token function\">exit</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p><strong>Http.cpp</strong></p>\n<pre><code class=\"prism language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">\"Sock.hpp\"</span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;pthread.h&gt;</span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">SIZE</span> <span class=\"token expression\"><span class=\"token number\">1024</span><span class=\"token operator\">*</span><span class=\"token number\">10</span></span></span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">Usage</span><span class=\"token punctuation\">(</span>std<span class=\"token operator\">::</span>string proc<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n    std<span class=\"token operator\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Usage: \"</span> <span class=\"token operator\">&lt;&lt;</span> proc <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" port\"</span> <span class=\"token operator\">&lt;&lt;</span> std<span class=\"token operator\">::</span>endl<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token function\">HandlerHttpRequest</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>args<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token comment\">//Http协议，如果自己写的话，本质是，我们要根据协议内容，来进行文本分析！</span>\n\n    <span class=\"token keyword\">int</span> sock <span class=\"token operator\">=</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>args<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">delete</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>args<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">pthread_detach</span><span class=\"token punctuation\">(</span><span class=\"token function\">pthread_self</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\n    <span class=\"token keyword\">char</span> buffer<span class=\"token punctuation\">[</span>SIZE<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">memset</span><span class=\"token punctuation\">(</span>buffer<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>buffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token class-name\">ssize_t</span> s <span class=\"token operator\">=</span> <span class=\"token function\">recv</span><span class=\"token punctuation\">(</span>sock<span class=\"token punctuation\">,</span> buffer<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>buffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>s <span class=\"token operator\">&gt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{<!-- --></span>\n        buffer<span class=\"token punctuation\">[</span>s<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        std<span class=\"token operator\">::</span>cout  <span class=\"token operator\">&lt;&lt;</span> buffer<span class=\"token punctuation\">;</span> <span class=\"token comment\">//查看http的请求格式! </span>\n\n        std<span class=\"token operator\">::</span>string http_response <span class=\"token operator\">=</span> <span class=\"token string\">\"http/1.0 200 OK\\n\"</span><span class=\"token punctuation\">;</span>\n        http_response <span class=\"token operator\">+=</span> <span class=\"token string\">\"Content-Type: text/plain\\n\"</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//text/plain,正文是普通的文本</span>\n        http_response <span class=\"token operator\">+=</span> <span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//空行</span>\n        http_response <span class=\"token operator\">+=</span> <span class=\"token string\">\"This is a test\"</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token function\">send</span><span class=\"token punctuation\">(</span>sock<span class=\"token punctuation\">,</span> http_response<span class=\"token punctuation\">.</span><span class=\"token function\">c_str</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> http_response<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token function\">close</span><span class=\"token punctuation\">(</span>sock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> nullptr<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> argc<span class=\"token punctuation\">,</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>argv<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span> argc <span class=\"token operator\">!=</span> <span class=\"token number\">2</span> <span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token function\">Usage</span><span class=\"token punctuation\">(</span>argv<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">exit</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\t<span class=\"token comment\">//短链接版本(即一次请求,一次响应,每次都关闭套接字)</span>\n    <span class=\"token class-name\">uint16_t</span> port <span class=\"token operator\">=</span> <span class=\"token function\">atoi</span><span class=\"token punctuation\">(</span>argv<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> listen_sock <span class=\"token operator\">=</span> Sock<span class=\"token operator\">::</span><span class=\"token function\">Socket</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    Sock<span class=\"token operator\">::</span><span class=\"token function\">Bind</span><span class=\"token punctuation\">(</span>listen_sock<span class=\"token punctuation\">,</span> port<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    Sock<span class=\"token operator\">::</span><span class=\"token function\">Listen</span><span class=\"token punctuation\">(</span>listen_sock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span> <span class=\"token punctuation\">;</span> <span class=\"token punctuation\">;</span> <span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token keyword\">int</span> sock <span class=\"token operator\">=</span> Sock<span class=\"token operator\">::</span><span class=\"token function\">Accept</span><span class=\"token punctuation\">(</span>listen_sock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>sock <span class=\"token operator\">&gt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">{<!-- --></span>\n            <span class=\"token class-name\">pthread_t</span> tid<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>parm <span class=\"token operator\">=</span> new <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span>sock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token function\">pthread_create</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>tid<span class=\"token punctuation\">,</span> nullptr<span class=\"token punctuation\">,</span> HandlerHttpRequest<span class=\"token punctuation\">,</span> parm<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>当你运行时，格式为<code>./Http 端口号</code>。那怎样能请求呢？<br/> 打开浏览器，复制上你的公网IP，然后<code>:端口号</code>，例如xx.xx.xx.xx:8888，此时你的云服务器就能获取到请求。<br/> <img alt=\"在这里插入图片描述\" src=\"image\\d40293f1ed6642bb8e1d590a62e94834.png\"/></p>\n<h1><a id=\"2_281\"></a>2.传输层</h1>\n<h2><a id=\"21_282\"></a>2.1再谈端口号</h2>\n<blockquote>\n<p>端口号(Port)标识了一个主机上进行通信的不同的应用程序。</p>\n</blockquote>\n<p>在TCP/IP协议中， 用 “源IP”, “源端口号”, “目的IP”, “目的端口号”, “协议号” 这样一个五元组来标识一个通信(可以通过netstat -n查看)。<br/> <img alt=\"在这里插入图片描述\" src=\"image\\e89b9e42903c41aba99e70aadba546e7.png\"/></p>\n<h2><a id=\"22_287\"></a>2.2端口号范围划分</h2>\n<blockquote>\n<p>0 - 1023: 知名端口号, HTTP, FTP, SSH等这些广为使用的应用层协议, 他们的端口号都是固定的。</p>\n</blockquote>\n<ul><li>ssh服务器, 使用22端口</li><li>ftp服务器, 使用21端口</li><li>telnet服务器, 使用23端口</li><li>http服务器, 使用80端口</li><li>https服务器, 使用443端口</li></ul>\n<pre><code class=\"prism language-c\">cat <span class=\"token operator\">/</span>etc<span class=\"token operator\">/</span>services <span class=\"token comment\">//可以查看知名端口号</span>\n</code></pre>\n<blockquote>\n<p>1024 - 65535: 操作系统动态分配的端口号。客户端程序的端口号, 就是由操作系统从这个范围分配的。</p>\n</blockquote>\n<p><strong>两个经典问题:</strong></p>\n<ol><li>一个进程是否可以bind多个端口号?<br/> 可以。</li><li>一个端口号是否可以被多个进程bind?<br/> 不可以。端口号就是用来唯一标识主机内的一个进程。</li></ol>\n<h2><a id=\"23_308\"></a>2.3常见查看网络状态命令</h2>\n<p><strong>netstat</strong><br/> 语法：netstat [选项]<br/> 功能：查看网络状态<br/> 常用选项：</p>\n<blockquote>\n<ul><li>n 拒绝显示别名，能显示数字的全部转化成数字。</li><li>l 仅列出有在 Listen (监听) 的服务状态。</li><li>p 显示建立相关链接的程序名。</li><li>t (tcp)仅显示tcp相关选项。</li><li>u (udp)仅显示udp相关选项。</li><li>a (all)显示所有选项，默认不显示LISTEN相关。</li></ul>\n</blockquote>\n<p><strong>pidof</strong><br/> 在查看服务器的进程id时非常方便。<br/> 语法：pidof [进程名]<br/> 功能：通过进程名, 查看进程id</p>\n<h2><a id=\"24UDP_326\"></a>2.4UDP协议</h2>\n<h3><a id=\"241UDP_327\"></a>2.4.1UDP协议段格式</h3>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\9a8b5ec4f495428ca00054c3a8bf1e7a.png\"/></p>\n<blockquote>\n<p>16位UDP长度, 表示整个数据报(UDP首部+UDP数据)的最大长度。<br/> 如果校验和出错, 就会直接丢弃。(<strong>这里说明了UDP是不可靠的</strong>)</p>\n</blockquote>\n<h3><a id=\"242UDP_333\"></a>2.4.2UDP的特点</h3>\n<blockquote>\n<ul><li><code>无连接</code>: 知道对端的IP和端口号就直接进行传输, 不需要建立连接。</li><li><code>不可靠</code>: 没有确认机制, 没有重传机制; 如果因为网络故障该段无法发到对方, UDP协议层也不会给应用层返回任何错误信息。</li><li><code>面向数据报</code>: 不能够灵活的控制读写数据的次数和数量。(<code>应用层交给UDP多长的报文, UDP原样发送, 既不会拆分, 也不会合并。</code>)</li></ul>\n</blockquote>\n<h3><a id=\"243UDP_338\"></a>2.4.3UDP的缓冲区</h3>\n<blockquote>\n<p>UDP<code>没有真正意义上的发送缓冲区</code>。调用sendto会直接交给内核, 由内核将数据传给网络层协议进行后续的传输动作。<br/> UDP<code>具有接收缓冲区</code>。 但是这个接收缓冲区不能保证收到的UDP报的顺序和发送UDP报的顺序一致。如果缓冲区满了, 再到达的UDP数据就会被丢弃。</p>\n</blockquote>\n<p>UDP的socket既能读, 也能写, 这个概念叫做<code>全双工</code>。</p>\n<h3><a id=\"244UDP_344\"></a>2.4.4基于UDP的应用层协议</h3>\n<blockquote>\n<p><strong>NFS</strong>: 网络文件系统<br/> <strong>TFTP</strong>: 简单文件传输协议<br/> <strong>DHCP</strong>: 动态主机配置协议<br/> <strong>BOOTP</strong>: 启动协议(用于无盘设备启动)<br/> <strong>DNS</strong>: 域名解析协议<br/> <strong>自定义应用层协议</strong>:我们自己定义的协议。</p>\n</blockquote>\n<h2><a id=\"25TCP_352\"></a>2.5TCP协议</h2>\n<h3><a id=\"251TCP_353\"></a>2.5.1TCP协议段格式</h3>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\3db29d042ca347a6a6a132c563976ca6.png\"/><br/> <strong>4位TCP报头长度</strong>: 表示该TCP头部有多少个<strong>32位bit</strong>(有多少个4字节)。也就是以4个字节为单位的，那我们算一算TCP头部能达到的最大长度是多少，4个bit位最大是1111也就是15，所以TCP头部最大长度为4 × 15 = 60。<br/> 而一个TCP(选项以上的部分是一个标准TCP)的标准长度是20字节，也就是说选项最多40字节，还能知道首部的这四位一般是表示20 / 4 = 5，也就是一般这四位是<code>0101</code>。<br/> <strong>16位窗口大小:</strong><br/> 这个大小实际上是用来控制客户端给我传输数据的速度的，设想一种情况，要是客户端一直给我发送数据，服务端一直接收直到服务端的缓冲区满了，此时客户端还在发送数据，这一份数据没办法处理，只能丢弃。而16位窗口大小表明了接收缓冲区中剩余空间的大小，这可以告诉客户端服务端还有多大的接收能力，让客户端控制发送数据的速度。换句话说，16位窗口大小的本质就是<code>流量控制</code>。<br/> <strong>6个标志位:</strong><br/> <strong>ACK:</strong><br/> ACK机制，ACK全称acknowledge，也就是应答。我们前面说过TCP是一个可靠的传输协议，可靠就体现在这。<br/> 我们看到TCP协议段里有一个序号和一个确认序号，这两个是用来干嘛的？<br/> 在通信过程中，客户端向服务端发起请求，服务端向客户端响应，但这一过程并不能保证是可靠的，因为客户端发起响应，服务端并不能保证每一次都会应答，有可能因为网络等各种原因没有应答，那这样就没办法保证TCP的可靠性。TCP将每个字节的数据都进行了编号，即为32位序号，而32位确认序号的意思则是<code>在这个确认序号之前的数据都已经收到了</code>，什么意思呢？<br/> 举个例子，例如服务端给客户端的确认序号是1001，那么意思就是1-1000序号的数据全部接收完毕。ACK机制不仅保证了数据能够被准确接收，而且还能保证发送的数据能够按发送的顺序被接收方所接收。<br/> <strong>SYN:</strong><br/> 这个标志是用来表明请求建立连接的。<br/> 这里就涉及到我们前面所讲的三次握手。<br/> <code>第一次握手:</code><br/> 客户端发送SYN请求和服务端建立连接。<br/> <code>第二次握手：</code><br/> 服务端发送ACK确认应答以及SYN请求和客户端建立连接。<br/> <code>第三次握手:</code><br/> 客户端发送ACK确认应答。<br/> <strong>RST:</strong><br/> 可能很多人会陷入一个误区，以为我们讲三次握手，那么三次握手一定能成功，这是不一定的。三次握手中最有可能出现问题的是第三次，因为第三次握手当客户端发送ACK后，此时不管服务端有没有接收到，客户端都认为连接已经建立完成，而服务端则认为还没有建立完成，这种情况就会导致建立失败，而为了解决这种情况，就有了标志位RST来重置连接，重置异常连接是连接异常的一种情况，只要是双方连接出现异常都可以发送RST来进行连接重置。<br/> <strong>PSH:</strong><br/> 告知对方，尽快将接收缓冲区中的数据进行向上交付。<br/> <strong>URG:</strong><br/> 如果想让一个数据尽快的被上传读到，就可以设置URG，表明该报文中携带了紧急数据，需要被优先处理，16位的紧急指针就是用来处理紧急数据的。<br/> <strong>FIN:</strong><br/> 最后这个标志位涉及到了四次挥手。<br/> <strong>第一次挥手:</strong><br/> 当客户端不想向服务端请求服务时，想要和服务端断开连接，此时客户端向服务端发送FIN。<br/> <strong>第二次挥手:</strong><br/> 服务端接收到客户端的FIN，会给客户端一个应答，发送ACK。<br/> <strong>第三次挥手:</strong><br/> 服务端也向客户端发送一个FIN请求断开连接。<br/> <strong>第四次挥手:</strong><br/> 客户端收到服务端的FIN，也给服务端一个应答，发送ACK。</p>\n<h3><a id=\"252TCP_390\"></a>2.5.2TCP缓冲区</h3>\n<p>TCP和UDP类似，也是有自己的缓冲区，不同的是，TCP既有接收缓冲区也有发送缓冲区。<br/> 在应用层进行sendto时不是直接把数据发到网络上，而是把数据拷贝到TCP的发送缓冲区，等到服务端调用recv再把数据拷贝到服务端的接收缓冲区。<br/> <strong>为什么TCP/UDP需要有缓冲区？</strong></p>\n<ol><li>提高应用层效率</li><li>只有TCP协议可以知道对方的网络状态，所以也只有TCP协议能知道如何发，什么时候发，发多少，出错了怎么处理，因为缓冲区的存在，所以可以做到应用层和TCP进行解耦。</li></ol>\n<h3><a id=\"253_396\"></a>2.5.3超时重传机制</h3>\n<p>听名字很好理解，就是超过某个时间还没送达数据就会重新传送。数据没送达对应两种情况</p>\n<ol><li>客户端给服务端发送数据时，可能因为网络拥堵等原因，数据无法到达服务端。如果客户端在一个特定时间间隔内没有收到服务端发来的确认应答，就会进行重发。</li><li>当我们发送对应的报文，发送方没有收到ACK，就一定是对方没有收到对应的报文数据吗？<br/> 也有可能是客户端没有接收到ACK，客户端就会认为数据丢了，这样就会造成服务端会收到很多重复数据。针对这种情况我们有必要去区分数据包是真丢了还是只是ACK没有接收到吗？<br/> 完全没必要，这种情况我们可以把它当成第一种情况一样处理，我们就认为数据包丢了，对于重复的数据包，TCP能够识别出来并根据序列号进行去重。</li></ol>\n<p><strong>那么，超时的时间如何确定？</strong><br/> TCP为了保证无论在任何环境下都能比较高性能的通信, 因此会动态计算这个最大超时时间。</p>\n<blockquote>\n<ul><li>Linux中(BSD Unix和Windows也是如此), 超时以500ms为一个单位进行控制, 每次判定超时重发的超时时间都是500ms的整数倍。</li><li>如果重发一次之后, 仍然得不到应答, 等待 2*500ms 后再进行重传。</li><li>如果仍然得不到应答, 等待 4*500ms 进行重传。依次类推, 以指数形式递增。</li><li>累计到一定的重传次数, TCP认为网络或者对端主机出现异常, 强制关闭连接。</li></ul>\n</blockquote>\n<h3><a id=\"254_411\"></a>2.5.4连接管理机制</h3>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\f73661e0b5d946c99ea2dd5b791543d6.png\"/><br/> 现在来看这张图你会发现这里的过程大部分前面都已经提过了。<br/> <strong>对于三次握手，不知你是否思考过为什么是三次握手？</strong><br/> 1.因为TCP是全双工的，只有经过第三次握手，才能确保双向都可以接收到对方发送的数据。<br/> 2.防止重复连接。在网络状况比较差的情况下，发送方可能会连续发送多次建立连接的请求。如果 TCP 握手的次数只有两次，那么接收方只能选择接受或者拒绝请求，但它并不清楚这次的请求是否是正常的请求。如果 TCP 是三次握手的话，那么客户端在接收到服务器端seq+1的消息之后，就可以判断当前的连接是否为历史连接，如果判断为历史连接的话就会发送RST给服务器端终止连接，如果判断当前连接不是历史连接的话就会发送SYN来建立连接。<br/> <strong>类似地，为什么是四次挥手？</strong><br/> 三次握手概括来说就是<code>SYN SYN+ACK ACK</code>，四次握手则是<code>FIN ACK FIN ACK</code>，你可能会疑惑，为什么四次挥手不能是<code>FIN FIN + ACK ACK</code>。因为当客户端发送FIN给服务端时，仅仅代表客户端不会再发送数据报文了，但仍可以接收数据报文。此时服务端可能还有相应的数据报文需要继续发送（还没发送FIN），因此需要先发送ACK报文，告诉对方已经收到FIN，避免客户端过长时间未收到确认应答导致超时重传。等到服务端数据发送完之后,，服务端才会发送断开连接请求。<br/> <strong>TIME_WAIT状态</strong><br/> 当服务端发送FIN给客户端，客户端会进入一个TIME_WAIT状态，等待两个MSL(maximum segment lifetime)的时间后才能回到CLOSED状态。<br/> <strong>为什么需要一个TIME_WAIT状态？</strong><br/> 1.为了尽量保证历史发送的网络数据在网络中被清除。<br/> 2.可靠的终止TCP连接。假如ACK丢失，那么服务器将会重发FIN，客户端需要停留在TIME_WAIT状态以处理重复收到的FIN。</p>\n<p>针对于第一点，举个例子，我们在绑定端口号时经常会遇到这种情况，当你绑定一个端口号你结束服务后，想马上再次绑定相同的端口号，此时会报错<code>bind error</code>，就是因为虽然你解绑了端口号，但那份资源还没有被释放，所以没办法再次绑定。</p>\n<p><strong>为什么是TIME_WAIT的时间是2MSL?</strong><br/> MSL是TCP报文的最大生存时间, 因此TIME_WAIT持续存在2MSL的话，就能保证在两个传输方向上的尚未被接收或迟到的报文段都已经消失(否则服务器立刻重启, 可能会收到来自上一个进程的迟到的数据, 但是这种数据很可能是错误的)，同时也是在理论上保证最后一个报文可靠到达(假设最后一个ACK丢失, 那么服务器会再重发一个FIN。这时虽然客户端的进程不在了, 但是TCP连接还在, 仍然可以重发LAST_ACK)。</p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}