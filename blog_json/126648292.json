{"blogid": "126648292", "writerAge": "码龄4年", "writerBlogNum": "43", "writerCollect": "132", "writerComment": "19", "writerFan": "17", "writerGrade": "4级", "writerIntegral": "1213", "writerName": "追逐ぢ", "writerProfileAdress": "writer_image\\profile_126648292.jpg", "writerRankTotal": "16670", "writerRankWeekly": "73828", "writerThumb": "53", "writerVisitNum": "69427", "blog_read_count": "405", "blog_time": "已于 2022-09-01 17:52:41 修改", "blog_title": "主流跨域方式解析！", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>我们在写前后端分离的项目时，数据要通过前端页面发送请求接口返回拿到数据后然后渲染到页面上的，在这时如果前端页面所在的服务器和后端的接口服务器不同源的话，就会出现跨域问题，比如这样。</p>\n<p><img alt=\"\" height=\"529\" src=\"image\\dab13cd07a1c436e8a3d3ffbbea5d423.png\" width=\"854\"/></p>\n<p>因为前端页面服务跑在5500端口上，去请求没有经过跨域处理的服务端口为80的接口服务器时，因为端口不同受浏览器同源策略的影响，浏览器会阻止非同源的请求。</p>\n<p><strong>同源策略：</strong></p>\n<ol><li>协议</li><li>主机</li><li>端口</li></ol>\n<p>只要两个服务器满足以上任意一个条件，那么这两个服务器即非同源，默认情况下浏览器会阻止非同源请求从而使前端页面拿不到数据。</p>\n<p><strong>实例解析：</strong></p>\n<p><strong>一:</strong><strong>CORS（跨域资源共享）</strong></p>\n<p>　　当访问跨域的服务器时，浏览器会检查返回的http响应头</p>\n<p>　　Access-Control-Allow-Origin:  “允许被访问的源地址”<br/> 　　Access-Control-Allow-Methods: “允许的请求方法”<br/> 　　Access-Control-Allow-Headers: “允许携带的http请求头字段”<br/> 只有当前端页面所发的请求符合这些响应头字段的要求时，浏览器才允许访问成功，否则就会报访问80端口时的错误。</p>\n<p><strong>8083服务器设置cors响应头字段使能被跨域访问 ↓</strong></p>\n<p><img alt=\"\" height=\"903\" src=\"image\\3727b6e10d3f46a0a354f6181e5437c8.png\" width=\"1200\"/></p>\n<h1>二:nginx代理转发 </h1>\n<p>      nginx代理转发原理是同源策略只限制于浏览器端的服务器，当后端服务器访问后端服务器时即使是非同源也是可以正常访问的，所以我们构建一个8081端口的nginx服务器，并开启cors使得我们前端的5500端口可以访问该8081的服务器，然后再将请求转发给没有cors的80服务器（即 5500 -&gt; 8081 -&gt; 80）</p>\n<p><strong>开启8081的nginx服务并设置cors响应头 ↓</strong></p>\n<p><img alt=\"\" height=\"880\" src=\"image\\31643cd273df408aa2ba4e6323fb11ea.png\" width=\"1177\"/></p>\n<h1> 三:node自定义代理转发 </h1>\n<p>实现原理和nginx差不多，只不过这个代理服务器是我们自己编写实现</p>\n<p><strong>自定义端口为8082的代理服务器，设置跨域cors响应头，请求转发给端口为80的无跨域处理服务器 ↓</strong></p>\n<p><img alt=\"\" height=\"871\" src=\"image\\4d173a3547084d2d9218f97dc90dfbd8.png\" width=\"1200\"/></p>\n<h1> 四:jsonp方式</h1>\n<p>该跨域方式原理为script标签可以不受同源策略影响，前端页面定义回调函数并将该回调函数名作为请求url参数名，后端服务器将数据作为回调函数的实参包裹渲染给前端页面，此时触发前端页面的回调函数，形参即为后端传过来的数据</p>\n<pre><code class=\"language-javascript\">// jsonp跨域原理（通过script标签不受同源策略影响）\n var script = document.createElement(\"script\");\n script.src = 'http://localhost:'+port+'/test?callback=getJsonpData';\n document.body.appendChild(script);\n script.onload = function () {\n     document.body.removeChild(script)\n }\n                     \n// jsonp方式回调函数\nfunction getJsonpData(data) {\n  let port = document.querySelector('input').value\n  if(data){\n      let li = document.createElement('li')\n      li.textContent = (port ? port : '80') + \":\" + data.messgae\n    document.querySelector(\"ul\").appendChild(li)\n   }else{\n       let li = document.createElement('li')\n       li.textContent = (port ? port : '80') + \":\" + \"访问失败\"\n       document.querySelector(\"ul\").appendChild(li)\n    }\n}</code></pre>\n<p><strong>node端8084实现jsonp方式的服务器 ↓</strong></p>\n<p><img alt=\"\" height=\"866\" src=\"image\\931d6687bc154fd887590cd4a4aeb1d1.png\" width=\"1200\"/></p>\n<p></p>\n</div>\n</div>"}