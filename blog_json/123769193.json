{"blogid": "123769193", "writerAge": "码龄2年", "writerBlogNum": "77", "writerCollect": "705", "writerComment": "36", "writerFan": "627", "writerGrade": "4级", "writerIntegral": "1063", "writerName": "莫凡-11", "writerProfileAdress": "writer_image\\profile_123769193.jpg", "writerRankTotal": "25616", "writerRankWeekly": "213492", "writerThumb": "110", "writerVisitNum": "100944", "blog_read_count": "4044", "blog_time": "于 2022-03-27 11:05:41 发布", "blog_title": "unordered_set基本用法", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h2><a id=\"Unodered_Set_0\"></a>Unodered Set</h2>\n<p>无序集(<strong>unorder sets</strong>)是一种不按特定顺序存储唯一元素的容器，允许根据元素的值快速检索单个元素。</p>\n<p>在<code>unordered_set</code>中，元素的值同时也是唯一标识它的键。键是不可变的，因此，<code>unordered_set</code>中的元素在容器中不能被修改，但是它们可以被插入和删除。</p>\n<p>在内部，<code>unordered_set</code>中的元素并不按照任何特定的顺序排序，而是根据它们的散列值组织到桶中，从而允许根据它们的值直接快速访问单个元素(平均时间复杂度为常数)。</p>\n<p>与set容器相比，Unordered_set容器通过键访问单个元素的速度更快，尽管它们通常在通过元素的子集进行范围迭代时效率较低。</p>\n<hr/>\n<h2><a id=\"_10\"></a>容器的属性</h2>\n<h3><a id=\"_11\"></a>关联性</h3>\n<p>关联容器中的元素是通过它们的键引用的，而不是通过它们在容器中的绝对位置引用的。</p>\n<h3><a id=\"_13\"></a>无序性</h3>\n<p>无序容器使用哈希表组织元素，允许通过键快速访问元素。</p>\n<h3><a id=\"set_15\"></a>具有set特性</h3>\n<p>元素的值也是用来标识它的键。即<code>value</code>就是<code>key</code>。</p>\n<h3><a id=\"key_17\"></a>独一无二的<code>key</code></h3>\n<p>容器中没有两个元素具有相同的键。</p>\n<h3><a id=\"Allocatoraware_19\"></a>Allocator-aware</h3>\n<p>容器使用一个allocator对象来动态地处理其存储需求。即当你插入或者删除数据时，容器会自动处理空间。</p>\n<hr/>\n<h2><a id=\"_23\"></a>常用方法</h2>\n<ul><li><code>unorder_set&lt;string&gt; first</code>容器定义</li><li><code>first.empty()</code>判断容器是否是空，是空返回<code>true</code>，反之为<code>false</code></li><li><code>first.size()</code>返回容器大小</li><li><code>first.maxsize()</code>返回容器最大尺寸</li><li><code>first.begin()</code>返回迭代器开始</li><li><code>first.end()</code>返回迭代器结束</li><li><code>first.find(value)</code>返回value在迭代器的位置</li><li><code>first.count(key)</code>返回key在容器的个数</li><li><code>first.insert(value)</code>将value插入到容器中</li><li><code>first.erase(key)</code>通过key删除</li><li><code>first.clear()</code>清空容器</li></ul>\n<p><strong>迭代器的使用</strong></p>\n<pre><code class=\"prism language-c++\">#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;unordered_set&gt;\n\nusing namespace std;\n\nint main()\n{\n\tunordered_set&lt;string&gt; myset = {\"Mercury\",\"Venus\",\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\",\"Uranus\",\"Neptune\"};\n\tfor (auto it = myset.begin(); it != myset.end(); ++it)\n\t\tcout &lt;&lt; *it &lt;&lt; endl;\n\treturn 0;\n}\n</code></pre>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}