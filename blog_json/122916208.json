{"blogid": "122916208", "writerAge": "码龄5年", "writerBlogNum": "217", "writerCollect": "40205", "writerComment": "1140", "writerFan": "79500", "writerGrade": "7级", "writerIntegral": "21456", "writerName": "张维鹏", "writerProfileAdress": "writer_image\\profile_122916208.jpg", "writerRankTotal": "425", "writerRankWeekly": "374", "writerThumb": "6845", "writerVisitNum": "4535072", "blog_read_count": "28397", "blog_time": "已于 2022-04-22 04:13:54 修改", "blog_title": "Nacos配置中心用法详细介绍", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>        上篇文章介绍了 <a class=\"link-info\" href=\"https://blog.csdn.net/a745233700/article/details/122915663\" title=\"Nacos 作为注册中心的用法\">Nacos 作为注册中心的用法</a>，除此之外，Nacos 还能作为配置中心使用，那这篇文章就介绍下 Nacos 作为配置中心的基本用法，首先我们先了解下为什么需要使用配置中心。</p>\n<h1>一、为什么需要配置中心：</h1>\n<p>在没有配置中心之前，传统应用配置的存在以下痛点：</p>\n<p>（1）采用本地静态配置，无法保证实时性：修改配置不灵活且需要经过较长的测试发布周期，无法尽快通知到客户端，还有些配置对实时性要求很高，比方说主备切换配置或者碰上故障需要修改配置，这时通过传统的静态配置或者重新发布的方式去配置，那么响应速度是非常慢的，业务风险非常大</p>\n<p>（2）易引发生产事故：比如在发布的时候，容易将测试环境的配置带到生产上，引发生产事故。</p>\n<p>（3）配置散乱且格式不标准：有的用properties格式，有的用xml格式，还有的存DB，团队倾向自造轮子，做法五花八门。</p>\n<p>（4）配置缺乏安全审计、版本控制、配置权限控制功能：谁？在什么时间？修改了什么配置？无从追溯，出了问题也无法及时回滚到上一个版本；无法对配置的变更发布进行认证授权，所有人都能修改和发布配置。</p>\n<p>        而配置中心区别于传统的配置信息分散到系统各个角落的方式，对系统中的配置文件进行集中统一管理，而不需要逐一对单个的服务器进行管理。那这样做有什么好处呢？</p>\n<p>（1）通过配置中心，可以使得配置标准化、格式统一化</p>\n<p>（2）当配置信息发生变动时，修改实时生效，无需要重新重启服务器，就能够自动感知相应的变化，并将新的变化统一发送到相应程序上，快速响应变化。比方说某个功能只是针对某个地区用户，还有某个功能只在大促的时段开放，使用配置中心后只需要相关人员在配置中心动态去调整参数，就基本上可以实时或准实时去调整相关对应的业务。</p>\n<p>（3）通过审计功能还可以追溯问题</p>\n<p></p>\n<h1>二、Nacos配置中心的使用：</h1>\n<p>        微服务中配置中心的主流解决方案主要有三种：Nacos、Apollo、Config+Bus，不过这篇文章我们主要介绍 Nacos 作为配置中心的用法，对其他两种方式感兴趣的读者请自行上网查阅</p>\n<h2>1、Springboot 整合 Nacos 配置中心：</h2>\n<p>（1）首先我们声明项目的版本信息：</p>\n<pre><code>&lt;properties&gt;\n    &lt;spring-boot.version&gt;2.3.2.RELEASE&lt;/spring-boot.version&gt;\n    &lt;spring-cloud.version&gt;Hoxton.SR9&lt;/spring-cloud.version&gt;\n    &lt;spring-cloud-alibaba.version&gt;2.2.6.RELEASE&lt;/spring-cloud-alibaba.version&gt;\n&lt;/properties&gt;\n\n&lt;!--  只声明依赖，不引入依赖 --&gt;\n&lt;dependencyManagement&gt;\n    &lt;dependencies&gt;\n        &lt;!-- 声明springBoot版本 --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;\n            &lt;version&gt;${spring-boot.version}&lt;/version&gt;\n            &lt;type&gt;pom&lt;/type&gt;\n            &lt;scope&gt;import&lt;/scope&gt;\n        &lt;/dependency&gt;\n        &lt;!-- 声明springCloud版本 --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;\n            &lt;version&gt;${spring-cloud.version}&lt;/version&gt;\n            &lt;type&gt;pom&lt;/type&gt;\n            &lt;scope&gt;import&lt;/scope&gt;\n        &lt;/dependency&gt;\n        &lt;!-- 声明 springCloud Alibaba 版本 --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;\n            &lt;version&gt;${spring-cloud-alibaba.version}&lt;/version&gt;\n            &lt;type&gt;pom&lt;/type&gt;\n            &lt;scope&gt;import&lt;/scope&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n&lt;/dependencyManagement&gt;</code></pre>\n<p>（2）添加 nacos 配置中心的 maven 依赖：</p>\n<pre><code>&lt;!-- SpringCloud Ailibaba Nacos Config --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;\n&lt;/dependency&gt;</code></pre>\n<p>（3）在 application.properties 文件中添加 nacos 配置中心相关配置：</p>\n<pre><code>spring.profiles.active=dev\nspring.application.name=cloud-producer-server\nserver.port=8080\n\n# nacos 配置中心地址\nspring.cloud.nacos.config.server-addr=localhost:8848\n# 配置文件的类型\nspring.cloud.nacos.config.file-extension=yaml</code></pre>\n<p>（4）在 nacos 控制台新建一个 DataID 为 cloud-producer-server-dev.yaml 的配置集：</p>\n<blockquote>\n<p>为什么 DataID 的命名为 cloud-producer-server-dev.yaml 会在下文介绍</p>\n</blockquote>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"508\" src=\"image\\e23d079cda45492e9cd2b72885a0e434.png\" width=\"1200\"/></p>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"465\" src=\"image\\f8306d436c3943b7bf5bda7ed8a84723.png\" width=\"862\"/></p>\n<p> （5）编写测试类：</p>\n<pre><code class=\"language-java\">//配置发布之后，动态刷新配置\n@RefreshScope\n@RestController\n@RequestMapping(\"provider\")\npublic class ProviderController\n{\n    // 使用原生注解@Value()导入配置\n    @Value(\"${user.id}\")\n    private String id;\n    @Value(\"${user.name}\")\n    private String name;\n    @Value(\"${user.age}\")\n    private String age;\n\n    @GetMapping(\"getNacosConfig\")\n    public String providerTest()\n    {\n        return \"我是provider，已成功获取nacos配置中心的数据：(id:\" + id + \",name:\" + name + \",age:\" + age +\")\";\n    }\n}</code></pre>\n<p>（6）启动服务验证：</p>\n<p>        启动项目，访问 <a href=\"http://localhost:8080/provider/getNacosConfig\" title=\"http://localhost:8080/provider/getNacosConfig\">http://localhost:8080/provider/getNacosConfig</a> 接口，可以看到 nacos 配置中心的配置信息已经生效并被成功获取到了</p>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"163\" src=\"image\\2fd89514175c49a3b475af82da01b0ff.png\" width=\"750\"/></p>\n<p>（7）验证动态刷新配置：</p>\n<p>        配置的动态刷新是配置中心最核心的功能之一，假设我现在需要修改 user.name 的值，那么我直接改变 Nacos 中的配置会生效吗？我们试下直接将 Nacos 中的配置修改成 “zhangsan”，如下图：</p>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"683\" src=\"image\\71e004e0f26a48639cf62bd745256f62.png\" width=\"1200\"/></p>\n<p> 此时不重启项目并重新访问该接口，结果如下：</p>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"160\" src=\"image\\0ffe3effa6bd45cab9818681850bb797.png\" width=\"715\"/></p>\n<p>        我们发现配置已经动态刷新了，这是为什么呢？其实是由于我们在类上添加了 @RefreshScope 注解而产生的效果。</p>\n<pre><code class=\"language-java\">//配置发布之后，动态刷新配置\n@RefreshScope\n@RestController\n@RequestMapping(\"provider\")\npublic class ProviderController</code></pre>\n<h2>2、Nacos 的核心概念：</h2>\n<h3>2.1、Data ID：</h3>\n<p><strong>（1）Data ID 的命名格式：</strong></p>\n<p>        前面我们演示了在 nacos 控制台新建一个 DataID 为 cloud-producer-server-dev.yaml 的数据集，那么这个 Data ID 是什么呢？Data ID 是配置集的唯一标识，一个应用可以包含多个配置集，每个配置集都需要被一个有意义的名称标识。那么 Data ID 怎么取值呢？格式通俗一点就是 “前缀-环境-扩展名”，如下所示：</p>\n<blockquote>\n<p>${spring.cloud.nacos.config.prefix}-${spring.profiles.active}.${spring.cloud.nacos.config.file-extension}</p>\n</blockquote>\n<p>① prefix：前缀，默认是 spring.application.name 的值，也可以通过配置项 spring.cloud.nacos.config.prefix 来配置。</p>\n<pre><code># 若不指定，默认采用应用名的方案\nspring.application.name=cloud-producer-server\n\n# 手动指定配置的dataID前缀标识\n# spring.cloud.nacos.config.prefix=cloud-producer-server-config</code></pre>\n<p>② active：配置运行环境，即为当前环境对应的 profile。</p>\n<blockquote>\n<p>注意：当 spring.profiles.active 为空时，对应的连接符 ”-“ 也将不存在，dataId 的拼接格式变成 ${prefix}.${file-extension}</p>\n</blockquote>\n<pre><code># dev表示开发环境\nspring.profiles.active=dev</code></pre>\n<p>③ file-exetension：配置文件的类型，默认是 properties，也可以通过配置项 spring.cloud.nacos.config.file-extension 来配置，目前支持的类型有 TEXT、JSON、XML、YAML、HTML、Properties</p>\n<pre><code># 指定配置文件类型为yaml文件\nspring.cloud.nacos.config.file-extension=yaml</code></pre>\n<p>④ 最终配置：</p>\n<p>        经过前面三个步骤，我们最终在nacos配置中心的控制台新增配置文件就是：cloud-producer-server.yaml</p>\n<h3>2.2、环境隔离-命名空间Namespace：</h3>\n<p>        Nacos 引入命名空间 Namespace 的概念来进行多环境配置和服务的管理及隔离。例如，你可能存在本地开发环境dev、测试环境test、生产环境prod 三个不同的环境，那么可以创建三个不同的 Namespace 区分不同的环境。创建方式如下：</p>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"371\" src=\"image\\3f2dd1513e45417590c997cd9c8ab65f.png\" width=\"612\"/></p>\n<p> 创建完成后，就可以在Nacos 控制台的配置列表上面看到不同的命名空间了，如下图：</p>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"351\" src=\"image\\98918253fdd84a399d8899203b121b97.png\" width=\"637\"/></p>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"304\" src=\"image\\91ec7e523db04393be85b96668686f06.png\" width=\"644\"/></p>\n<p>        成功创建新命名空间后，就可以在 springboot 的配置文件配置命名空间的 id 切换到对应的命名空间，并获取对应空间下的配置文件，但在没有指定命名空间配置的情况下，默认的配置都是在 public 空间中，指定命名空间的方式如下：</p>\n<pre><code># 对应创建的命名空间的ID，此处对应的是dev命名空间\ncloud.nacos.config.namespace=483bb765-a42d-4112-90bc-50b8dff768b3</code></pre>\n<h3>2.3、业务隔离-Group分组：</h3>\n<p>        Group 也可以实现环境隔离的功能，但 Group 设计的目的主要是做同一个环境中的不同服务分组，把不同的微服务的配置文件划分到同一个分组里面去，Nacos 如果不指定 Group，则默认的分组是 DEFAULT_GROUP。</p>\n<p>        如果没有 Group，试想一下这个场景：有两个微服务，一个是订单系统，一个是用户系统，但是他们有着相同的配置，比如 datasource-url，那么如何区分呢？这时候 Group 就派上用场了。上述场景中订单系统、用户系统可以单独分为一个组，比如 ORDER_GROUP、USER_GROUP，当然这是比较细粒度的分组，根据企业的业务也可以多个微服务分为一组。</p>\n<p>        接下来我们演示一下创建配置集时以及集成时如何指定分组，还是前面的例子，新建配置集是在如下位置指定Group分组：</p>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"484\" src=\"image\\43e3111f040b4c7a9723e61e336cab7e.png\" width=\"1200\"/></p>\n<p> 接下来在 application.properties 文件分组：</p>\n<pre><code>spring.cloud.nacos.config.namespace=483bb765-a42d-4112-90bc-50b8dff768b3</code></pre>\n<h3>3、小结：</h3>\n<p>Nacos 实现配置管理和动态配置刷新很简单，总结如下步骤：</p>\n<ul><li>① 添加对应 spring-cloud-starter-alibaba-nacos-config 依赖</li><li>② 使用原生注解 @Value() 导入配置</li><li>③ 使用原生注解 @RefreshScope 刷新配置</li><li>④ 根据自己业务场景做好多环境配置隔离(Namespace)、不同业务配置隔离(Group)</li></ul>\n<h3>4、共享配置：</h3>\n<p>        当我们微服务的数量越来越多，势必会有相同的配置，这时我们可以将相同的配置抽取出来作为项目中共有的配置，比如集群中的数据源信息、日志的配置信息，nacos 也是支持这种一个配置中心多个配置集这种写法的。</p>\n<p>（1）我们在nacos中新建两个 Data ID 分别是 db.yaml 和 log.yaml 的文件。</p>\n<p>（2）在配置文件中分别加入部分配置内容</p>\n<p>（3）在 Springboot 项目中添加如下的 nacos 配置：</p>\n<pre><code>spring:\n  cloud:\n    nacos:\n      config:\n        extension-configs[0]:\n          data-id: db.yaml\n          # 默认为DEFAULT_GROUP\n          group: DEFAULT_GROUP\n          # 是否动态刷新，默认为false\n          refresh: true\n        extension-configs[1]:\n          data-id: log.yaml\n          group: DEFAULT_GROUP\n          refresh: true</code></pre>\n<p>为了更加清晰的在多个应用间配置共享的 Data Id，官方推荐使用 shared-configs，配置如下：</p>\n<pre><code>spring:\n  cloud:\n    nacos:\n      config:\n        shared-configs[0]:\n          data-id: db.yaml\n          # 默认为DEFAULT_GROUP\n          group: DEFAULT_GROUP   \n          # 是否动态刷新，默认为false\n          refresh: true   \n        shared-configs[1]:\n          data-id: log.yaml\n          group: DEFAULT_GROUP\n          refresh: true</code></pre>\n<p>（4）思考：在这2个文件中出现相同配置，nacos如何选取？</p>\n<p>        当多个 Data Id 同时出现相同的配置时，它的优先级关系是 spring.cloud.nacos.config.extension-configs[n].data-id 其中 n 的值越大，优先级越高。</p>\n<blockquote>\n<p>注意：spring.cloud.nacos.config.extension-configs[n].data-id 的值必须带文件扩展名，文件扩展名既可支持 properties，又可以支持 yaml/yml。此时 spring.cloud.nacos.config.file-extension 的配置对自定义扩展配置的 Data Id 文件扩展名没有影响。</p>\n</blockquote>\n<p>（5）不同方式配置加载优先级：</p>\n<p>        Nacos 配置中心目前提供以下三种配置能力从 Nacos 拉取相关的配置，当三种方式共同使用时，他们的一个优先级关系是:A &lt; B &lt; C：</p>\n<ul><li>A：通过 spring.cloud.nacos.config.shared-configs[n].data-id 支持多个共享 Data Id 的配置</li><li>B：通过 spring.cloud.nacos.config.extension-configs[n].data-id 的方式支持多个扩展 Data Id 的配置</li><li>C：通过内部相关规则(spring.cloud.nacos.config.prefix、spring.cloud.nacos.config.file-extension、spring.cloud.nacos.config.group)自动生成相关的 Data Id 配置</li></ul>\n<hr/>\n<blockquote>\n<p>相关阅读：</p>\n<p><a href=\"https://blog.csdn.net/a745233700/article/details/117448077\" title=\"常见的服务器架构入门：从单体架构、EAI 到 SOA 再到微服务和 ServiceMesh\">常见的服务器架构入门：从单体架构、EAI 到 SOA 再到微服务和 ServiceMesh</a></p>\n<p><a href=\"https://blog.csdn.net/a745233700/article/details/122401700\" title=\"常见分布式理论（CAP、BASE）和一致性协议（Gosssip协议、Raft一致性算法）\">常见分布式理论（CAP、BASE）和一致性协议（Gosssip协议、Raft一致性算法）</a></p>\n<p><a href=\"https://blog.csdn.net/a745233700/article/details/120814088\" title=\"一致性哈希算法原理详解\">一致性哈希算法原理详解</a></p>\n<p><a href=\"https://blog.csdn.net/a745233700/article/details/122915663\" title=\"Nacos注册中心的部署与用法详细介绍\">Nacos注册中心的部署与用法详细介绍</a></p>\n<p><a href=\"https://blog.csdn.net/a745233700/article/details/122916208\" title=\"Nacos配置中心用法详细介绍\">Nacos配置中心用法详细介绍</a></p>\n<p><a href=\"https://blog.csdn.net/a745233700/article/details/122916856\" title=\"SpringCloud OpenFeign 远程HTTP服务调用用法与原理\">SpringCloud OpenFeign 远程HTTP服务调用用法与原理</a></p>\n<p><a href=\"https://blog.csdn.net/a745233700/article/details/122445199\" title=\"什么是RPC？RPC框架dubbo的核心流程\">什么是RPC？RPC框架dubbo的核心流程</a></p>\n<p><a href=\"https://blog.csdn.net/a745233700/article/details/120819219\" title=\"服务容错设计：流量控制、服务熔断、服务降级\">服务容错设计：流量控制、服务熔断、服务降级</a></p>\n<p><a href=\"https://blog.csdn.net/a745233700/article/details/122733366\" title=\"sentinel 限流熔断神器详细介绍\">sentinel 限流熔断神器详细介绍</a></p>\n<p><a href=\"https://blog.csdn.net/a745233700/article/details/122725604\" title=\"Sentinel 规则持久化到 apollo 配置中心\">Sentinel 规则持久化到 apollo 配置中心</a></p>\n<p><a href=\"https://blog.csdn.net/a745233700/article/details/122659459\" title=\"Sentinel-Dashboard 与 apollo 规则的相互同步\">Sentinel-Dashboard 与 apollo 规则的相互同步</a></p>\n<p><a href=\"https://blog.csdn.net/a745233700/article/details/122917167\" title=\"Spring Cloud Gateway 服务网关的部署与使用详细介绍\">Spring Cloud Gateway 服务网关的部署与使用详细介绍</a></p>\n<p><a href=\"https://blog.csdn.net/a745233700/article/details/122917160\" title=\"Spring Cloud Gateway 整合 sentinel 实现流控熔断\">Spring Cloud Gateway 整合 sentinel 实现流控熔断</a></p>\n<p><a href=\"https://blog.csdn.net/a745233700/article/details/122917137\" title=\"Spring Cloud Gateway 整合 knife4j 聚合接口文档\">Spring Cloud Gateway 整合 knife4j 聚合接口文档</a></p>\n<p><a href=\"https://blog.csdn.net/a745233700/article/details/122402303\" title=\"常见分布式事务详解（2PC、3PC、TCC、Saga、本地事务表、MQ事务消息、最大努力通知）\">常见分布式事务详解（2PC、3PC、TCC、Saga、本地事务表、MQ事务消息、最大努力通知）</a></p>\n<p><a href=\"https://blog.csdn.net/a745233700/article/details/122402795\" title=\"分布式事务Seata原理\">分布式事务Seata原理</a></p>\n<p><a href=\"https://blog.csdn.net/a745233700/article/details/122656108\" title=\"RocketMQ事务消息原理\">RocketMQ事务消息原理</a></p>\n</blockquote>\n<hr/>\n<p>参考文章：</p>\n<p><a href=\"https://blog.csdn.net/ron03129596/article/details/109019400\" title=\"SpringBoot2.X整合Nacos做配置中心\">SpringBoot2.X整合Nacos做配置中心</a></p>\n<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&amp;mid=2247493854&amp;idx=1&amp;sn=4b3fb7f7e17a76000733899f511ef915&amp;scene=21#wechat_redirect\" title=\"五十五张图告诉你微服务的灵魂摆渡者Nacos究竟有多强？\">五十五张图告诉你微服务的灵魂摆渡者Nacos究竟有多强？</a></p>\n</div>\n</div>"}