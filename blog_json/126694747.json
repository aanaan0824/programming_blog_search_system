{"blogid": "126694747", "writerAge": "码龄1年", "writerBlogNum": "41", "writerCollect": "40", "writerComment": "116", "writerFan": "112", "writerGrade": "3级", "writerIntegral": "699", "writerName": "又是想闲鱼的一天", "writerProfileAdress": "writer_image\\profile_126694747.jpg", "writerRankTotal": "26983", "writerRankWeekly": "62198", "writerThumb": "146", "writerVisitNum": "8147", "blog_read_count": "102", "blog_time": "已于 2022-09-06 15:14:52 修改", "blog_title": "关于线程的那些事", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<ol><li>线程创建</li><li>线程中断</li><li>线程等待</li><li>线程休眠</li><li>线程状态</li><li>线程实例</li></ol>\n<p></p>\n<h3><strong>一.线程的创建---这里给出五种方法</strong></h3>\n<p>方法一:</p>\n<pre>继承Thread 重写run方法</pre>\n<pre><code>class MyThread extends Thread{\n    @Override\n    public void run() {\n        System.out.println(\"thread\");\n    }\n}\n\npublic class Text1 {\n\n    public static void main(String[] args) {\n        MyThread myThread = new MyThread();\n        myThread.start();\n\n    }\n}\n</code></pre>\n<p>方法二:</p>\n<pre>实现MyRunnable接口,重写run</pre>\n<pre><code>class MyRunnable implements Runnable {\n    @Override\n    public void run() {\n        System.out.println(\"thread\");\n    }\n}\n\npublic class Text2 {\n    public static void main(String[] args) {\n        MyRunnable myRunnable = new MyRunnable();\n        Thread thread = new Thread(myRunnable);\n        thread.start();\n    }\n}</code></pre>\n<p>方法三:</p>\n<pre>使用匿名内部类 实现创建Thread子类</pre>\n<pre><code>public class Text3 {\n    public static void main(String[] args) {\n        Thread thread = new MyThread(){\n            @Override\n            public void run() {\n                System.out.println(\"thread\");\n            }\n        };\n        thread.start();\n    }\n}</code></pre>\n<p>方法四:</p>\n<pre>使用匿名内部类 实现 实现Runnable接口</pre>\n<pre><code>public class Text4 {\n\n    public static void main(String[] args) {\n        Thread thread = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(\"thread\");\n            }\n        });\n        thread.start();\n    }\n}</code></pre>\n<p>方法五:</p>\n<pre>lambda 表达式</pre>\n<pre><code>public class Text5 {\n\n    public static void main(String[] args) {\n        Thread thread = new Thread(() -&gt; {\n            System.out.println(\"thread\");\n        });\n        thread.start();\n    }\n}\n\n</code></pre>\n<p>注意一下,线程真正的创建是thread.start();</p>\n<p></p>\n<h3><strong>二.线程中断</strong></h3>\n<p>线程中断--其实是让线程快一点结束(run执行完了,线程就执行完了),不是让它半路停下!</p>\n<p>介绍两个方法</p>\n<p>1.自己设置一个 -举个栗子~~</p>\n<p><img alt=\"\" height=\"625\" src=\"image\\a1102a4457f447e883d8d3b9a9c2f816.png\" width=\"975\"/></p>\n<p></p>\n<pre><code>public class Text6 {\n    private static boolean t = true;\n\n    public static void main(String[] args) {\n\n        Thread thread = new Thread(() -&gt;{\n            while(t){\n                System.out.println(\"thread\");\n                try {\n                    sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            System.out.println(\"线程执行完了\");\n        });\n\n        thread.start();\n\n        try {\n            Thread.sleep(3000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        t = false;\n        System.out.println(\"设置线程执行完了\");\n    }\n\n\n}</code></pre>\n<p>2.用标准库里自带的</p>\n<p><img alt=\"\" height=\"802\" src=\"image\\f27ea4d599f34dc5b8f495c4efaf2342.png\" width=\"871\"/></p>\n<p></p>\n<pre><code>public class Text7 {\n\n    public static void main(String[] args) {\n\n        Thread thread = new Thread(() -&gt;{\n            while(!Thread.currentThread().isInterrupted()){\n                System.out.println(\"thread\");\n                try {\n                    sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                    //break;\n                }\n            }\n            System.out.println(\"线程执行完了\");\n        });\n\n        thread.start();\n\n        try {\n            Thread.sleep(3000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        thread.interrupt();\n        System.out.println(\"设置线程执行完了\");\n    }\n}</code></pre>\n<p>我们发现它还是没停下来,没关系,加一个break就行</p>\n<p></p>\n<p>从中我们也能发现Java中断线程也不是强制的,它是 立即处理,不理会,装作不理会 (像回消息~~)</p>\n<p></p>\n<h3><strong>三.线程等待</strong></h3>\n<p><strong>      </strong>  用join 在main函数中调用thread.join效果就是--main函数阻塞等待,thread线程执行完了,main才继续</p>\n<p><img alt=\"\" height=\"564\" src=\"image\\50a58052d3224ab493d5c2f6be42e481.png\" width=\"770\"/></p>\n<p></p>\n<pre><code>public class Text8 {\n\n    public static void main(String[] args) throws InterruptedException {\n        Thread thread = new Thread(() -&gt; {\n            while(true){\n                System.out.println(\"thread\");\n                try {\n                    sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        });\n        thread.start();\n        thread.join();\n        System.out.println(\"main等待\");\n        while(true){\n            System.out.println(\"main\");\n            try {\n                sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}</code></pre>\n<p></p>\n<h3><strong>四.线程休眠</strong></h3>\n<p>        线程休眠就是sleep,调用了则这个PCB就被移动到,另外一个 '阻塞队列' 中,时间到了,就在回到, '就绪队列' 的原来位置</p>\n<p></p>\n<h3><strong>五线程状态</strong></h3>\n<p></p>\n<div>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px;\"><tbody><tr><td style=\"width:150px;\"><span style=\"color:#333333;\">NEW</span></td><td style=\"width:348px;\"><span style=\"color:#333333;\">安排了工作</span><span style=\"color:#333333;\">, 但</span><span style=\"color:#333333;\">还未开始</span></td></tr><tr><td style=\"width:150px;\"><span style=\"color:#333333;\">RUNNABLE</span></td><td style=\"width:348px;\"><span style=\"color:#333333;\">可工作</span> <span style=\"color:#333333;\">(正在工作中和即将开始工作)</span></td></tr><tr><td style=\"width:150px;\"><span style=\"color:#333333;\">BLOCKED</span></td><td style=\"width:348px;\"><span style=\"color:#333333;\">排队等着其他事情 </span></td></tr><tr><td style=\"width:150px;\"><span style=\"color:#333333;\">WAITING</span></td><td style=\"width:348px;\"><span style=\"color:#333333;\">排队等着其他事情 </span></td></tr><tr><td style=\"width:150px;\"><span style=\"color:#333333;\">TIMED_WAITING</span></td><td style=\"width:348px;\"><span style=\"color:#333333;\">排队等着其他事情 </span></td></tr><tr><td style=\"width:150px;\"><span style=\"color:#333333;\">TERMINATED</span></td><td style=\"width:348px;\"><span style=\"color:#333333;\">工作完成了</span></td></tr></tbody></table>\n<p> 简单来说:<img alt=\"\" height=\"403\" src=\"image\\e211ba37672143e8b144b26649bb0d85.png\" width=\"745\"/></p>\n<p></p>\n<p></p>\n<p><img alt=\"\" height=\"740\" src=\"image\\84fbd6fd2cf346e2b6e80a7f65a0bf1a.png\" width=\"647\"/></p>\n<p><img alt=\"\" height=\"162\" src=\"image\\a145a7c5f3a34cd387679aa0ad375ebb.png\" width=\"383\"/></p>\n<pre><code>public class Text9 {\n\n    public static void main(String[] args) {\n        Thread thread = new Thread(() -&gt; {\n            for (int i = 0; i &lt; 50; i++) {\n\n            }\n        });\n        System.out.println(thread.getState());\n        thread.start();\n        while(thread.isAlive()){\n            System.out.println(thread.getState());\n        }\n        System.out.println(thread.getState());\n    }</code></pre>\n<h3>六.线程实例</h3>\n<p></p>\n<pre><code class=\"hljs\">public class Text10 {\n\n    public static void main(String[] args) {\n        Thread thread = new MyThread(){\n            @Override\n            public void run() {\n                System.out.println(this.getName());\n            }\n        };\n        thread.start();\n    }\n}</code></pre>\n<p></p>\n</div>\n</div>\n</div>"}