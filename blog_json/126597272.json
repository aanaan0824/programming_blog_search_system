{"blogid": "126597272", "writerAge": "码龄1年", "writerBlogNum": "34", "writerCollect": "374", "writerComment": "523", "writerFan": "797", "writerGrade": "5级", "writerIntegral": "1878", "writerName": "猪皮兄弟", "writerProfileAdress": "writer_image\\profile_126597272.jpg", "writerRankTotal": "10284", "writerRankWeekly": "142", "writerThumb": "615", "writerVisitNum": "30912", "blog_read_count": "747", "blog_time": "已于 2022-08-31 22:21:46 修改", "blog_title": "【C++】类和对象（二）构造函数&&析构函数&&拷贝构造函数", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-tomorrow-night\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p>🧸🧸🧸<font color=\"red\"><strong>各位大佬大家好，我是猪皮兄弟</strong></font>🧸🧸🧸<br/> <img alt=\"在这里插入图片描述\" src=\"image\\a0538806e6ab460399e548c01e7abb41.png\"/></p>\n<p>    <font color=\"red\"><strong>今天的内容是构造函数，析构函数，拷贝构造。这几个默认成员函数你都知道了解和会用吗？快来看看吧！</strong></font></p>\n<p></p>\n<div class=\"toc\">\n<h3>文章目录</h3>\n<ul><li><a href=\"#_14\">一、构造函数</a></li><li><ul><li><a href=\"#1_19\">1.构造函数特性</a></li><li><a href=\"#2C_51\">2.C++编译器生成的默认构造对不同类型的处理</a></li><li><a href=\"#3_55\">3.这里是给缺省值而不是初始化</a></li></ul>\n</li><li><a href=\"#_71\">二、析构函数</a></li><li><ul><li><a href=\"#1_74\">1.析构函数特性</a></li><li><a href=\"#2_116\">2.默认析构函数的特点</a></li></ul>\n</li><li><a href=\"#_130\">三、拷贝构造函数</a></li><li><ul><li><a href=\"#1_134\">1.拷贝构造的特点</a></li><li><a href=\"#2_162\">2.拷贝构造的处理</a></li></ul>\n</li><li><a href=\"#_181\">四、总结</a></li></ul>\n</div>\n<p></p>\n<p>    <font color=\"red\"><strong>如果一个类里面什么都没有，简称为空类，那么空类中真的什么都没有吗？并不是，任何类在不写时，编译器会自动生成以下六个默认成员函数。</strong></font><br/> <img alt=\"在这里插入图片描述\" src=\"image\\9852991da3754a4489b52f40b6860fd5.png\"/><br/>     <font color=\"red\"><strong>下面我们就主要拿日期类来做一下演示</strong></font></p>\n<h1><a id=\"_14\"></a>一、构造函数</h1>\n<p><mark><strong>因为我们很多时候都会忘记去初始化，比如说栈，为了保证对象一定会被初始化—&gt;引出了构造函数</strong></mark></p>\n<blockquote>\n<p>构造函数是用来初始化的，因为对象只需要被初始化一次，所以只有对象被实例化的时候调用，其他时候都不会调用构造函数。构造函数是可以有默认参数的（也就是缺省参数）</p>\n</blockquote>\n<h2><a id=\"1_19\"></a>1.构造函数特性</h2>\n<p><strong>1.函数名和类名相同<br/> 2.没有返回值<br/> 3.对象实例化的时候自动调用去初始化<br/> 4.构造函数可以进行函数重载，比如无参，有参<br/> 5.如果类中没有显示定义构造函数，那么C++编译器会默认生成一个<br/>     一个默认的无参构造。<br/> 6.默认构造函数有三种（默认构造函数的特点是不传参就可以使用）<br/>     a.编译器自己生成<br/>     b.全缺省的构造函数<br/>     c.我们自己写的无参构造</strong></p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Date</span>\n<span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n\t<span class=\"token function\">Date</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> year<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> month<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> day<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token comment\">//缺省参数</span>\n\t<span class=\"token comment\">//在没有对其进行传参的时候，就用缺省参数，并且半缺省的话只能从右往左缺省</span>\n\t<span class=\"token comment\">//这里还能用初始化列表，等会儿演示</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\t_year<span class=\"token operator\">=</span>year<span class=\"token punctuation\">;</span>\n\t\t_month<span class=\"token operator\">=</span>month<span class=\"token punctuation\">;</span>\n\t\t_day<span class=\"token operator\">=</span>day<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">private</span><span class=\"token operator\">:</span>\n\t<span class=\"token keyword\">int</span> _year<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> _month<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> _day<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h2><a id=\"2C_51\"></a>2.C++编译器生成的默认构造对不同类型的处理</h2>\n<p><strong>我们不去写构造函数C++编译器会自己生成一个默认构造，这个默认构造函数的处理是：对内置类型不作处理，对自定义类型去调用自定义类型的</strong><font color=\"red\"><strong>默认构造</strong></font></p>\n<h2><a id=\"3_55\"></a>3.这里是给缺省值而不是初始化</h2>\n<p><font color=\"red\"><strong>C++设计的缺陷，本来内置类型也该一并处理，但是并没有，所以在C++11打了一个补丁</strong></font></p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Date</span>\n<span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">private</span><span class=\"token operator\">:</span>\n\t<span class=\"token keyword\">int</span> _year<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> _month<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> _day<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//这是给的缺省值</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\b6ebca07e41549c7af3b056dc530dd95.png\"/></p>\n<hr/>\n<h1><a id=\"_71\"></a>二、析构函数</h1>\n<p><font color=\"red\"><strong>析构函数在对象生命结束之前自动调用，但是析构函数不是完成对对象本身的销毁，因为局部对象的销毁工作是由编译器来完成的，析构函数销毁的是比如说new出来空间</strong></font></p>\n<h2><a id=\"1_74\"></a>1.析构函数特性</h2>\n<p><strong>1.析构函数名是在类名前面加上~<br/> 2.无参数，无返回值类型(因为没有参数，所以并不存在函数重载)<br/> 3.一个类只有一个析构函数，如果我们 不自己定义，编译器又会自己生成默认的析构函数<br/> 4.对象声明周期结束时，C++编译系统自动调用析构函数</strong></p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Date</span>\n<span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n\t<span class=\"token operator\">~</span><span class=\"token function\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\t<span class=\"token comment\">//不需要我们去销毁什么，Date类不写也可以</span>\n\t<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">private</span><span class=\"token operator\">:</span>\n\t<span class=\"token keyword\">int</span> _year<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> _month<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> _day<span class=\"token punctuation\">;</span>\n\t\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//分号一定不要忘了</span>\n</code></pre>\n<p><strong>有些函数没有什么需要清理的，比如日期函数只有成员变量需要清理，但是又是存在栈上的，会自动清理，所以日期函数没有必要写析构函数，我们不显式定义，系统又会自动生成默认的析构函数</strong><br/> <font color=\"red\"><strong>但是像栈这种</strong></font></p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Stack</span>\n<span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n\t<span class=\"token operator\">~</span><span class=\"token function\">Stack</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\t<span class=\"token function\">free</span><span class=\"token punctuation\">(</span>_array<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//下面的不写也没什么，都要销毁了，只是一个好习惯</span>\n\t\t_array<span class=\"token operator\">=</span><span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">;</span>\n\t\t_top<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\t\t_capacity<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n\t<span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>_array<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> _top<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> _capacity<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h2><a id=\"2_116\"></a>2.默认析构函数的特点</h2>\n<p><mark>跟构造函数类似，析构函数对内置类型不处理，对自定义类型去调用该自定义类型的析构函数</mark><br/> <strong>那么为了析构函数对内置类型不处理呢？<br/> 主要是不知道该如何处理，比如是一个指针，有可能是malloc/fopen的等等，它不知道你想去干嘛，所以不敢处理</strong></p>\n<hr/>\n<h1><a id=\"_130\"></a>三、拷贝构造函数</h1>\n<p><mark><strong>创建对象时，按一个与已存在对象创建一摸一样的新对象</strong></mark><br/> <strong>拷贝构造函数：只有单个形参，该形参是对本类类型对象的引用（一般常用const修饰），再用已存在的类类型创建新对象时由编译器自动调用。</strong></p>\n<h2><a id=\"1_134\"></a>1.拷贝构造的特点</h2>\n<p><strong>1.拷贝构造函数是构造函数的一种函数重载<br/> 2.<font color=\"red\">拷贝构造函数的形参只有一个并且必须是本类类型对象的引用</font></strong>，(传指针也是可以的，只是用法怪怪的)<br/> <img alt=\"在这里插入图片描述\" src=\"image\\4ceae3fb882e4b189dc1978b92a14591.png\"/><br/> <font color=\"red\"><strong>使用传值方式编译器会直接报错，因为会引发无穷递归调用</strong></font>,<strong>因为传值是对实参的一份拷贝，所以又会调用拷贝构造，然后又因为是传值的拷贝构造，又会调用拷贝构造去传参</strong><br/> <img alt=\"在这里插入图片描述\" src=\"image\\bff38344f42c4cc69091a393d6e0f569.png\"/></p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Date</span>\n<span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n\t<span class=\"token function\">Date</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> Date<span class=\"token operator\">&amp;</span>d<span class=\"token punctuation\">)</span><span class=\"token comment\">//其实参数是两个，有一个隐藏的this指针</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\t_year<span class=\"token operator\">=</span>d<span class=\"token punctuation\">.</span>_year<span class=\"token punctuation\">;</span>\n\t\t_month<span class=\"token operator\">=</span>d<span class=\"token punctuation\">.</span>_month<span class=\"token punctuation\">;</span>\n\t\t_day<span class=\"token operator\">=</span>d<span class=\"token punctuation\">.</span>_day<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token comment\">//如果用指针，那么使用的时候就会这样用</span>\n\t<span class=\"token comment\">//Date d1;</span>\n\t<span class=\"token comment\">//Date d(&amp;d1);//我不是拷贝它吗，我穿他的地址是想干什么呢？</span>\n<span class=\"token keyword\">private</span><span class=\"token operator\">:</span>\n\t<span class=\"token keyword\">int</span> _year<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> _month<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> _day<span class=\"token punctuation\">;</span>\t\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h2><a id=\"2_162\"></a>2.拷贝构造的处理</h2>\n<p><strong>a.若未显示定义，编译器也会生成默认的拷贝构造函数。默认的拷贝构造函数对象（内置类型）按内存存储按字节序完成拷贝，这种拷贝叫做浅拷贝，或者值拷贝</strong><br/> <strong>b.内置类型是按字节方式直接拷贝的，而自定义类型是调用自定义类型的拷贝构造函数完成拷贝的</strong></p>\n<p><font color=\"red\"><strong>这里就涉及到了深浅拷贝的问题</strong></font></p>\n<blockquote>\n<p>像拷贝构造函数，它把内置类型和自定义类型都处理了，那么还有我们自己写的必要吗？<br/> 这里就涉及到了深浅拷贝的问题<br/> 浅拷贝（值拷贝）拷贝出来的是同一块空间，当对象生命周期结束时，会调用析构函数去free，同一块空间不能free两次，所以，析构函数会崩溃<br/> 浅拷贝两大问题：<br/> <strong>1.一个对象修改会影响另一个对象<br/> 2.会析构两次，程序崩溃</strong><br/> 解决办法：自己实现深拷贝，后面再说</p>\n</blockquote>\n<hr/>\n<h1><a id=\"_181\"></a>四、总结</h1>\n<p><font color=\"red\"><strong>上面对C++构造函数，析构函数与拷贝构造重要知识点进行了总结，感谢大家的支持，后面我会继续更新类和对象有关方面的内容！</strong></font><br/> <img alt=\"在这里插入图片描述\" src=\"image\\cc22094f8d2c4aecb86ec1ac6bd261a1.png\"/></p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}