{"blogid": "124178166", "writerAge": "码龄7年", "writerBlogNum": "81", "writerCollect": "135", "writerComment": "5", "writerFan": "9", "writerGrade": "4级", "writerIntegral": "1096", "writerName": "Rosita.", "writerProfileAdress": "writer_image\\profile_124178166.jpg", "writerRankTotal": "23502", "writerRankWeekly": "76934", "writerThumb": "28", "writerVisitNum": "81498", "blog_read_count": "2824", "blog_time": "已于 2022-07-22 11:39:27 修改", "blog_title": "C++ vector内存分配及正确释放", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%EF%BC%9A-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%EF%BC%9A\">内存分配</a></p>\n<p id=\"%E5%86%85%E5%AD%98%E9%87%8A%E6%94%BE%EF%BC%9A-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%86%85%E5%AD%98%E9%87%8A%E6%94%BE%EF%BC%9A\">内存释放</a></p>\n<p id=\"1.clear()-toc\" style=\"margin-left:40px;\"><a href=\"#1.clear%28%29\">1.清空vector的元素：clear()</a></p>\n<p id=\"2.clear()%2B%C2%A0shrink_to_fit()%3B-toc\" style=\"margin-left:40px;\"><a href=\"#2.clear%28%29%2B%C2%A0shrink_to_fit%28%29%3B\">2.释放内存：clear() + shrink_to_fit()</a></p>\n<p id=\"3.%20swap()%3B-toc\" style=\"margin-left:40px;\"><a href=\"#3.%20swap%28%29%3B\">3.释放vector中多余的空间或释放整个vector空间：swap()</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h1 id=\"%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%EF%BC%9A\">内存分配</h1>\n<blockquote>\n<p>1.<strong>C++ vector</strong>：相当于一个动态数组，它的内存会随着size的增加而不断的增长。</p>\n<p><br/> 2.<strong>内存分配的两个函数</strong>：</p>\n<p>2.1.size()返回实际占用内存的个数</p>\n<p>2.2.capacity()，返回实际申请的空间大小，一般来说，<span style=\"background-color:#ffd900;\">capacity &gt;= size 。</span></p>\n<p></p>\n<p>3.<strong>扩容</strong>：当capacity和size相等时，vector就会扩容，capacity会成倍增长。个人验证扩容后vector占内存为原来的<span style=\"background-color:#ffd900;\">2倍</span>，但有人说扩容后是原来内存的1.5倍，可能与系统相关。</p>\n<p></p>\n<p>4.<strong>扩容原理</strong>：以vector最常用的push_back为例，调用push_back时，若当前容量（capacity）已经不能够容纳新的元素，即此时capacity=size，那么vector会重新申请一块内存，把之前的内存里的元素拷贝到新的内存当中，然后把push_back的元素拷贝到新的内存中，最后要析构原有的vector并释放原有的内存。这个过程的效率是极低的，为了避免频繁的分配内存，C++每次申请内存一般都会成倍的增长，例如之前是4，那么重新申请后就是8，以此类推。</p>\n<p></p>\n<p>5.<strong>扩容隐患</strong>：由于每次内存分配成倍数申请，可能引发内存分配不足抛出bad_alloc异常，推荐以下的解决方案：<a href=\"https://qa.1r1g.com/sf/ask/661970991/#\" title=\"如何在C++中处理bad_alloc？ | 经验摘录\">如何在C++中处理bad_alloc？ | 经验摘录</a>。</p>\n</blockquote>\n<p>3.扩容验证代码：</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint  main(){\nvector&lt;int&gt; vec(10);\ncout &lt;&lt; \"vec.size: \"&lt;&lt; vec.size() &lt;&lt;endl;\ncout &lt;&lt; \"vec.capacity；\"&lt;&lt; vec.capacity()&lt;&lt;endl;\nvec.push_back(1);\ncout &lt;&lt; \"vec.size: \"&lt;&lt; vec.size() &lt;&lt;endl;\ncout &lt;&lt; \"vec.capacity：\"&lt;&lt; vec.capacity()&lt;&lt;endl;\n\n}</code></pre>\n<p>运行结果如图：</p>\n<p><img alt=\"\" height=\"187\" src=\"image\\f01272b9334d4024ae48254de6274109.png\" width=\"485\"/></p>\n<p></p>\n<h1 id=\"%E5%86%85%E5%AD%98%E9%87%8A%E6%94%BE%EF%BC%9A\">内存释放</h1>\n<p></p>\n<h2 id=\"1.clear()\">1.清空vector的元素：clear()</h2>\n<blockquote>\n<p>使用clear()不会真正释放内存，capacity()无变化</p>\n</blockquote>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main(){\n\tvector&lt;int&gt; vec;\n\t//手动空间100 \n\tvec.reserve(100);\n\tvec.push_back(1);\n\tvec.push_back(2);\n\tcout &lt;&lt;\"vec.size(): \" &lt;&lt; vec.size() &lt;&lt; endl;\n\tcout &lt;&lt;\"vec.capasity(): \" &lt;&lt; vec.capacity() &lt;&lt; endl;\n\tvec.clear();\n\tcout &lt;&lt;\"After vec.size(): \" &lt;&lt; vec.size() &lt;&lt; endl;\n\tcout &lt;&lt;\" After vec.capasity(): \" &lt;&lt; vec.capacity() &lt;&lt; endl;\n\t\n\treturn 0;\n}  </code></pre>\n<p>运行结果如图：</p>\n<p><img alt=\"\" height=\"194\" src=\"image\\319dd98165534a78b2cd1383370f463b.png\" width=\"913\"/></p>\n<h2></h2>\n<h2 id=\"2.clear()%2B%C2%A0shrink_to_fit()%3B\">2.释放内存：clear() + shrink_to_fit()</h2>\n<blockquote>\n<p>想要彻底释放内存，C11引入了shrink_to_fit();，在执行完clear()后执行，可完全释放内存</p>\n</blockquote>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main(){\n\tvector&lt;int&gt; vec;\n\t//手动空间100 \n\tvec.reserve(100);\n\tvec.push_back(1);\n\tvec.push_back(2);\n\tcout &lt;&lt;\"vec.size(): \" &lt;&lt; vec.size() &lt;&lt; endl;\n\tcout &lt;&lt;\"vec.capasity(): \" &lt;&lt; vec.capacity() &lt;&lt; endl;\n\tvec.clear();\n\tvec.shrink_to_fit();\n\tcout &lt;&lt;\"After vec.size(): \" &lt;&lt; vec.size() &lt;&lt; endl;\n\tcout &lt;&lt;\"After vec.capasity(): \" &lt;&lt; vec.capacity() &lt;&lt; endl;\n\t\n\treturn 0;\n}  </code></pre>\n<p>运行结果如图:</p>\n<p><img alt=\"\" height=\"205\" src=\"image\\68bb0513100c47c2a5f53e274c9ae849.png\" width=\"715\"/></p>\n<p></p>\n<h2 id=\"3.%20swap()%3B\">3.释放vector中多余的空间或释放整个vector空间：swap()</h2>\n<p>1.swap的用法有以下两种：</p>\n<blockquote>\n<p>1.释放vector中多余的空间</p>\n<p>2.释放整个vector空间</p>\n</blockquote>\n<p>构造函数也不同：</p>\n<blockquote>\n<p>释放整个vecter空间：vector&lt;int&gt; ().swap(vec);</p>\n<p>释放vec中多余空间：vector&lt;int&gt; (vec).swap(vec);</p>\n</blockquote>\n<p>2.swap交换技巧释放内存空间的思想：vector()使用默认构造函数建立临时vector对象，再对该临时对象上调用swap()成员，swap调用之后对象vector占用的空间就等于一个默认构造的对象的大小，临时对象就具有原来对象vector的大小，而临时对象随机被析构，从而其占用的空间被释放调。</p>\n<p>例：vector释放全部占用内存</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main(){\n\tvector&lt;int&gt; vec;\n\t//手动空间100 \n\tvec.reserve(100);\n\tvec.push_back(1);\n\tvec.push_back(2);\n\tcout &lt;&lt;\"vec.size(): \" &lt;&lt; vec.size() &lt;&lt; endl;\n\tcout &lt;&lt;\"vec.capasity(): \" &lt;&lt; vec.capacity() &lt;&lt; endl;\n\tvector&lt;int&gt; ().swap(vec);\n\tcout &lt;&lt;\"After vec.size(): \" &lt;&lt; vec.size() &lt;&lt; endl;\n\tcout &lt;&lt;\"After vec.capasity(): \" &lt;&lt; vec.capacity() &lt;&lt; endl;\n\t\n\treturn 0;\n}  </code></pre>\n<p>运行结果如图：</p>\n<p><img alt=\"\" height=\"282\" src=\"image\\3e78b817caec4653b47ae0c26ed4aa4a.png\" width=\"1200\"/></p>\n<p></p>\n<p></p>\n</div>\n</div>"}