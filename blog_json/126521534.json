{"blogid": "126521534", "writerAge": "码龄2年", "writerBlogNum": "14", "writerCollect": "631", "writerComment": "483", "writerFan": "879", "writerGrade": "4级", "writerIntegral": "1517", "writerName": "小影~", "writerProfileAdress": "writer_image\\profile_126521534.jpg", "writerRankTotal": "12439", "writerRankWeekly": "118", "writerThumb": "526", "writerVisitNum": "12626", "blog_read_count": "1016", "blog_time": "于 2022-08-25 14:43:13 发布", "blog_title": "RabbitMQ延迟队列", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%F0%9F%92%8C%20%E4%BB%8B%E7%BB%8D-toc\" style=\"margin-left:0px;\"><a href=\"#%F0%9F%92%8C%20%E4%BB%8B%E7%BB%8D\">💌 介绍</a></p>\n<p id=\"%F0%9F%92%92%20%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-toc\" style=\"margin-left:0px;\"><a href=\"#%F0%9F%92%92%20%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\">💒 使用场景</a></p>\n<p id=\"%F0%9F%8F%B3%E2%80%8D%F0%9F%8C%88%20%E6%A8%A1%E6%8B%9F%E6%A1%88%E4%BE%8B-toc\" style=\"margin-left:0px;\"><a href=\"#%F0%9F%8F%B3%E2%80%8D%F0%9F%8C%88%20%E6%A8%A1%E6%8B%9F%E6%A1%88%E4%BE%8B\">🏳‍🌈 模拟案例</a></p>\n<p id=\"%F0%9F%93%95%20%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C-toc\" style=\"margin-left:40px;\"><a href=\"#%F0%9F%93%95%20%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C\">📕 准备工作</a></p>\n<p id=\"%F0%9F%8F%B4%20%E5%86%99%E6%B3%95%E4%B8%80-toc\" style=\"margin-left:40px;\"><a href=\"#%F0%9F%8F%B4%20%E5%86%99%E6%B3%95%E4%B8%80\">🏴 写法一(死信队列TTL)</a></p>\n<p id=\"%C2%A0RabbitMQ%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A0RabbitMQ%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6\"> RabbitMQ配置文件</a></p>\n<p id=\"%C2%A0%E7%94%9F%E4%BA%A7%E8%80%85-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A0%E7%94%9F%E4%BA%A7%E8%80%85\"> 生产者</a></p>\n<p id=\"%E6%B6%88%E8%B4%B9%E8%80%85-toc\" style=\"margin-left:80px;\"><a href=\"#%E6%B6%88%E8%B4%B9%E8%80%85\">消费者</a></p>\n<p id=\"%E6%B5%8B%E8%AF%95-toc\" style=\"margin-left:80px;\"><a href=\"#%E6%B5%8B%E8%AF%95\">测试</a></p>\n<p id=\"%F0%9F%8F%B4%20%E5%86%99%E6%B3%95%E4%BA%8C%20(%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97TTL)-toc\" style=\"margin-left:40px;\"><a href=\"#%F0%9F%8F%B4%20%E5%86%99%E6%B3%95%E4%BA%8C%20%28%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97TTL%29\">🏴 写法二 (死信队列TTL)</a></p>\n<p id=\"%C2%A0RabbitMQ%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-toc\" style=\"margin-left:80px;\"><a href=\"#%C2%A0RabbitMQ%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6\"> RabbitMQ配置文件</a></p>\n<p id=\"%E7%94%9F%E4%BA%A7%E8%80%85-toc\" style=\"margin-left:80px;\"><a href=\"#%E7%94%9F%E4%BA%A7%E8%80%85\">生产者</a></p>\n<p id=\"%E6%B6%88%E8%B4%B9%E8%80%85-toc\" style=\"margin-left:80px;\"><a href=\"#%E6%B6%88%E8%B4%B9%E8%80%85\">消费者</a></p>\n<p id=\"%E6%B5%8B%E8%AF%95-toc\" style=\"margin-left:80px;\"><a href=\"#%E6%B5%8B%E8%AF%95\">测试</a></p>\n<p id=\"%F0%9F%9A%A9%20%E5%86%99%E6%B3%95%E4%B8%89%20(%E6%8F%92%E4%BB%B6%E7%89%88%E6%9C%AC-%E6%8E%A8%E8%8D%90)-toc\" style=\"margin-left:40px;\"><a href=\"#%F0%9F%9A%A9%20%E5%86%99%E6%B3%95%E4%B8%89%20%28%E6%8F%92%E4%BB%B6%E7%89%88%E6%9C%AC-%E6%8E%A8%E8%8D%90%29\">🚩 写法三 (插件版本-推荐)</a></p>\n<p id=\"%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85-toc\" style=\"margin-left:80px;\"><a href=\"#%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85\">插件安装</a></p>\n<p id=\"RabbitMQ%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-toc\" style=\"margin-left:80px;\"><a href=\"#RabbitMQ%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6\">RabbitMQ配置文件</a></p>\n<p id=\"%E7%94%9F%E4%BA%A7%E8%80%85-toc\" style=\"margin-left:80px;\"><a href=\"#%E7%94%9F%E4%BA%A7%E8%80%85\">生产者</a></p>\n<p id=\"%E6%B6%88%E8%B4%B9%E8%80%85-toc\" style=\"margin-left:80px;\"><a href=\"#%E6%B6%88%E8%B4%B9%E8%80%85\">消费者</a></p>\n<p id=\"%E6%B5%8B%E8%AF%95-toc\" style=\"margin-left:80px;\"><a href=\"#%E6%B5%8B%E8%AF%95\">测试</a></p>\n<p id=\"%F0%9F%91%8D%20%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%E6%96%B9%E6%B3%95%E6%8E%A8%E8%8D%90%C2%A0-toc\" style=\"margin-left:0px;\"><a href=\"#%F0%9F%91%8D%20%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%E6%96%B9%E6%B3%95%E6%8E%A8%E8%8D%90%C2%A0\">👍 延迟队列方法推荐 </a></p>\n<hr/>\n<h1 id=\"%F0%9F%92%8C%20%E4%BB%8B%E7%BB%8D\">💌 介绍</h1>\n<p>顾名思义：首先它要具有队列的特性，再给它附加一个延迟消费队列消息的功能，也就是说可以指定队列中的消息在哪个时间点被消费。</p>\n<h1 id=\"%F0%9F%92%92%20%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\">💒 使用场景</h1>\n<ul><li>预支付订单创建成功后，30分钟后还没有支付，自动取消订单，修改订单状态</li><li>用户注册成功后，如果3天没有登录则进行短信提醒</li><li>优惠券过期前发送短信进行提醒</li><li>....</li></ul>\n<p>以上场景都可以用延时队列来完成</p>\n<hr/>\n<h1 id=\"%F0%9F%8F%B3%E2%80%8D%F0%9F%8C%88%20%E6%A8%A1%E6%8B%9F%E6%A1%88%E4%BE%8B\">🏳‍🌈 模拟案例</h1>\n<p><strong>需求：</strong>生产者发布消息，10秒、60秒后消费者拿到消息进行消费</p>\n<h2 id=\"%F0%9F%93%95%20%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C\">📕 准备工作</h2>\n<p>导入RabbitMQ依赖</p>\n<pre><code class=\"language-java\">&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;\n&lt;/dependency&gt;</code></pre>\n<p> 配置RabbitMQ连接相关信息</p>\n<pre><code class=\"language-XML\">#MySQL\nspring:\n  rabbitmq:\n    host: 127.0.0.1\n    port: 5672 \n    username: xxxx\n    password: xxx\n\nserver:\n  port: 8087</code></pre>\n<hr/>\n<h2 id=\"%F0%9F%8F%B4%20%E5%86%99%E6%B3%95%E4%B8%80\">🏴 写法一(死信队列TTL)</h2>\n<p><span style=\"color:#fe2c24;\">生产者</span>生产消息——&gt;到交换机分发给对应的队列(A10秒过期，B60秒过期)——&gt;过期后到死信交换机——&gt;<span style=\"color:#fe2c24;\">消费者</span>进行消费（执行顺序如下图）<img alt=\"\" height=\"294\" src=\"image\\8b7175b231af46c2936bda13acae3f12.png\" width=\"1200\"/></p>\n<h3 id=\"%C2%A0RabbitMQ%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6\"> RabbitMQ配置文件</h3>\n<pre><code class=\"language-java\">import org.springframework.amqp.core.*;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\nimport java.util.HashMap;\n\n/**\n * @author 小影\n * @create: 2022/8/18 10:26\n * @describe：mq配置 如示例图配置：2交换机、4队列、4路由key\n */\n@Configuration\npublic class RabbitMQConfiguration {\n   // 延迟交换机\n   public static final String DELAY_EXCHANGE_NAME = \"delay.exchange\";\n   // 延迟队列\n   public static final String DELAY_QUEUE_NAME_A = \"delay.queue.a\";\n   public static final String DELAY_QUEUE_NAME_B = \"delay.queue.b\";\n   // 延迟队列路由key\n   public static final String DELAY_QUEUE_ROUTING_KEY_A = \"delay.routingKey.a\";\n   public static final String DELAY_QUEUE_ROUTING_KEY_B = \"delay.routingKey.b\";\n\n   // 死信交换机\n   public static final String DEAD_LETTER_EXCHANGE_NAME = \"dead.letter.exchange\";\n   // 死信队列\n   public static final String DEAD_LETTER_QUEUE_NAME_A = \"dead.letter.queue.a\";\n   public static final String DEAD_LETTER_QUEUE_NAME_B = \"dead.letter.queue.b\";\n   // 私信队列路由key\n   public static final String DEAD_LETTER_ROUTING_KEY_A = \"dead.letter.delay_10s.routingkey.a\";\n   public static final String DEAD_LETTER_ROUTING_KEY_B = \"dead.letter.delay_60s.routingkey.b\";\n\n   // 声明延迟交换机\n   @Bean(\"delayExchange\")\n   public DirectExchange delayExchange() {\n      return new DirectExchange(DELAY_EXCHANGE_NAME);\n   }\n\n   // 声明死信交换机\n   @Bean(\"deadLetterExchange\")\n   public DirectExchange deadLetterExchange() {\n      return new DirectExchange(DEAD_LETTER_EXCHANGE_NAME);\n   }\n\n   // 声明延迟队列A，延迟10s，并且绑定到对应的死信交换机\n   @Bean(\"delayQueueA\")\n   public Queue delayQueueA() {\n      HashMap&lt;String, Object&gt; args = new HashMap&lt;&gt;();\n      // 声明队列绑定的死信交换机\n      args.put(\"x-dead-letter-exchange\", DEAD_LETTER_EXCHANGE_NAME);\n      // 声明队列的属性路由key\n      args.put(\"x-dead-letter-routing-key\", DEAD_LETTER_ROUTING_KEY_A);\n      // 声明队列的消息TTL存活时间\n      args.put(\"x-message-ttl\", 10000);\n      return QueueBuilder.durable(DELAY_QUEUE_NAME_A).withArguments(args).build();\n   }\n\n   // 声明延迟队列B，延迟60s，并且绑定到对应的死信交换机\n   @Bean(\"delayQueueB\")\n   public Queue delayQueueB() {\n      HashMap&lt;String, Object&gt; args = new HashMap&lt;&gt;();\n      // 声明队列绑定的死信交换机\n      args.put(\"x-dead-letter-exchange\", DEAD_LETTER_EXCHANGE_NAME);\n      // 声明队列的属性路由key\n      args.put(\"x-dead-letter-routing-key\", DEAD_LETTER_ROUTING_KEY_B);\n      // 声明队列的消息TTL存活时间\n      args.put(\"x-message-ttl\", 60000);\n      return QueueBuilder.durable(DELAY_QUEUE_NAME_B).withArguments(args).build();\n   }\n\n   // 声明死信队列A，用于接收延迟10S的消息\n   @Bean(\"deadLetterQueueA\")\n   public Queue deadLetterQueueA() {\n      return new Queue(DEAD_LETTER_QUEUE_NAME_A);\n   }\n\n   // 声明死信队列B，用于接收延迟60S的消息\n   @Bean(\"deadLetterQueueB\")\n   public Queue deadLetterQueueB() {\n      return new Queue(DEAD_LETTER_QUEUE_NAME_B);\n   }\n\n   // 设置延迟队列A的绑定关系\n   @Bean\n   public Binding delayBindingA(@Qualifier(\"delayQueueA\") Queue queue,\n                                @Qualifier(\"delayExchange\") DirectExchange exchange) {\n      return BindingBuilder.bind(queue).to(exchange).with(DELAY_QUEUE_ROUTING_KEY_A);\n   }\n\n   // 设置延迟队列B的绑定关系\n   @Bean\n   public Binding delayBindingB(@Qualifier(\"delayQueueB\") Queue queue,\n                                @Qualifier(\"delayExchange\") DirectExchange exchange) {\n      return BindingBuilder.bind(queue).to(exchange).with(DELAY_QUEUE_ROUTING_KEY_B);\n   }\n\n   // 设置死信队列A的绑定关系\n   @Bean\n   public Binding deadLetterBindingA(@Qualifier(\"deadLetterQueueA\") Queue queue,\n                                @Qualifier(\"deadLetterExchange\") DirectExchange exchange) {\n      return BindingBuilder.bind(queue).to(exchange).with(DEAD_LETTER_ROUTING_KEY_A);\n   }\n   // 设置死信队列B的绑定关系\n   @Bean\n   public Binding deadLetterBindingB(@Qualifier(\"deadLetterQueueB\") Queue queue,\n                                     @Qualifier(\"deadLetterExchange\") DirectExchange exchange) {\n      return BindingBuilder.bind(queue).to(exchange).with(DEAD_LETTER_ROUTING_KEY_B);\n   }\n}</code></pre>\n<p>此配置文件的代码关系图如下</p>\n<p><img alt=\"\" height=\"1200\" src=\"image\\7580bdcce72b4595a334514ed9b03a54.png\" width=\"1200\"/></p>\n<h3 id=\"%C2%A0%E7%94%9F%E4%BA%A7%E8%80%85\"> 生产者</h3>\n<pre><code class=\"language-java\">import static com.ying.demo.config.RabbitMQConfiguration.DELAY_EXCHANGE_NAME;\nimport static com.ying.demo.config.RabbitMQConfiguration.DELAY_QUEUE_ROUTING_KEY_A;\nimport static com.ying.demo.config.RabbitMQConfiguration.DELAY_QUEUE_ROUTING_KEY_B;\n/**\n * @author 小影\n * @create: 2022/8/18 11:13\n * @describe：延迟消息生产者\n */\n@Component\npublic class DelayMessageProducer {\n\n   @Resource\n   private RabbitTemplate rabbitTemplate;\n\n   public void send(String message,int type) {\n      switch (type){\n         case 1: // 10s的消息\n            // param：队列名称、路由key、消息\n            rabbitTemplate.convertAndSend(DELAY_EXCHANGE_NAME, DELAY_QUEUE_ROUTING_KEY_A, message);\n            break;\n         case 2:// 60s的消息\n            rabbitTemplate.convertAndSend(DELAY_EXCHANGE_NAME, DELAY_QUEUE_ROUTING_KEY_B, message);\n            break;\n      }\n   }\n}</code></pre>\n<h3 id=\"%E6%B6%88%E8%B4%B9%E8%80%85\">消费者</h3>\n<pre><code class=\"language-java\">import com.rabbitmq.client.Channel;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.amqp.core.Message;\nimport org.springframework.amqp.rabbit.annotation.RabbitListener;\nimport org.springframework.stereotype.Component;\nimport java.time.LocalDateTime;\nimport static com.ying.demo.config.RabbitMQConfiguration.DEAD_LETTER_QUEUE_NAME_A;\nimport static com.ying.demo.config.RabbitMQConfiguration.DEAD_LETTER_QUEUE_NAME_B;\n\n/**\n * @author 小影\n * @create: 2022/8/18 11:19\n * @describe：死信消费者\n */\n@Slf4j\n@Component\npublic class DeadLetterQueueConsumer {\n\n   /**\n    * 监听私信队列A\n    * @param message\n    * @param channel 作手动回执、确认\n    */\n   @RabbitListener(queues = DEAD_LETTER_QUEUE_NAME_A)\n   public void receiveA(Message message, Channel channel) {\n      String msg = new String(message.getBody());\n      log.info(\"当前时间：{}，死信队列A收到消息：{}\", LocalDateTime.now(),msg);\n   }\n\n   /**\n    * 监听私信队列B\n    * @param message\n    * @param channel 作手动回执、确认\n    */\n   @RabbitListener(queues = DEAD_LETTER_QUEUE_NAME_B)\n   public void receiveB(Message message, Channel channel) {\n      String msg = new String(message.getBody());\n      log.info(\"当前时间：{}，死信队列B收到消息：{}\", LocalDateTime.now(),msg);\n   }\n}\n</code></pre>\n<h3 id=\"%E6%B5%8B%E8%AF%95\">测试</h3>\n<pre><code class=\"language-java\">@Slf4j\n@RestController\n@RequestMapping(\"rabbitmq\")\npublic class RabbitMqController {\n   @Resource\n   private DelayMessageProducer producer;\n\n   @GetMapping(\"send\")\n   public void send(String message, Integer type) {\n      log.info(\"当前时间：{}，消息：{}，延迟类型：{}\", LocalDateTime.now(), message, Objects.requireNonNull(type));\n      producer.send(message, type);\n   }\n}</code></pre>\n<p><strong>分别请求</strong>：</p>\n<p>http://localhost:8089/rabbitmq/send?message=我是10秒&amp;type=1</p>\n<p>http://localhost:8089/rabbitmq/send?message=我是60秒&amp;type=2</p>\n<p><img alt=\"\" height=\"138\" src=\"image\\967525c549694066a0631b29f1e64fb7.png\" width=\"553\"/></p>\n<p>如果出现异常：Channel shutdown: channel error; protocol method：#method(reply-code=406, reply-text=PRECONDITION_FAILED - inequivalent arg 'type' for exchange 'delay.exchange' in vhost '/': received ''x-delayed-message'' but current is 'direct', class-id=40, method-id=10</p>\n<p>可能是mq已经存在交换机了先去删掉</p>\n<p><strong>弊端</strong>：后期要扩展其他不同延时的时间，就需要增加延时的配置，非常麻烦</p>\n<hr/>\n<h2 id=\"%F0%9F%8F%B4%20%E5%86%99%E6%B3%95%E4%BA%8C%20(%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97TTL)\">🏴 写法二 (死信队列TTL)</h2>\n<p><span style=\"color:#fe2c24;\">生产者</span>生产消息(并设置过期时间)——&gt;到交换机分发给延迟队列——&gt;过期后到死信交换机——&gt;<span style=\"color:#fe2c24;\">消费者</span>进行消费（执行顺序如下图）</p>\n<p><img alt=\"\" height=\"235\" src=\"image\\f085b61f989a4551b3a50d593280db05.png\" width=\"1200\"/></p>\n<h3> RabbitMQ配置文件</h3>\n<pre><code class=\"language-java\">import org.springframework.amqp.core.*;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\nimport java.util.HashMap;\n\n/**\n * @author 小影\n * @create: 2022/8/18 10:26\n * @describe：mq配置 如示例图配置：2交换机、2队列、2路由key\n */\n@Configuration\npublic class RabbitMQConfiguration {\n   // 延迟交换机\n   public static final String DELAY_EXCHANGE_NAME = \"delay.exchange\";\n   // 延迟队列\n   public static final String DELAY_QUEUE_NAME = \"delay.queue\";\n   // 延迟队列路由key\n   public static final String DELAY_QUEUE_ROUTING_KEY = \"delay.routingKey\";\n\n   // 死信交换机\n   public static final String DEAD_LETTER_EXCHANGE_NAME = \"dead.letter.exchange\";\n   // 死信队列\n   public static final String DEAD_LETTER_QUEUE_NAME = \"dead.letter.queue\";\n   // 私信队列路由key\n   public static final String DEAD_LETTER_ROUTING_KEY = \"dead.letter.routingkey\";\n\n   // 声明延迟交换机\n   @Bean(\"delayExchange\")\n   public DirectExchange delayExchange() {\n      return new DirectExchange(DELAY_EXCHANGE_NAME);\n   }\n\n   // 声明死信交换机\n   @Bean(\"deadLetterExchange\")\n   public DirectExchange deadLetterExchange() {\n      return new DirectExchange(DEAD_LETTER_EXCHANGE_NAME);\n   }\n\n   // 声明延迟队列,不设置存活时间，并且绑定到对应的死信交换机\n   @Bean(\"delayQueue\")\n   public Queue delayQueue() {\n      HashMap&lt;String, Object&gt; args = new HashMap&lt;&gt;();\n      // 声明队列绑定的死信交换机\n      args.put(\"x-dead-letter-exchange\", DEAD_LETTER_EXCHANGE_NAME);\n      // 声明队列的属性路由key\n      args.put(\"x-dead-letter-routing-key\", DEAD_LETTER_ROUTING_KEY);\n      return QueueBuilder.durable(DELAY_QUEUE_NAME).withArguments(args).build();\n   }\n\n\n   // 声明死信队列\n   @Bean(\"deadLetterQueue\")\n   public Queue deadLetterQueue() {\n      return new Queue(DEAD_LETTER_QUEUE_NAME);\n   }\n\n\n   // 设置延迟队列的绑定关系\n   @Bean\n   public Binding delayBinding(@Qualifier(\"delayQueue\") Queue queue,\n                               @Qualifier(\"delayExchange\") DirectExchange exchange) {\n      return BindingBuilder.bind(queue).to(exchange).with(DELAY_QUEUE_ROUTING_KEY);\n   }\n\n\n   // 设置死信队列的绑定关系\n   @Bean\n   public Binding deadLetterBinding(@Qualifier(\"deadLetterQueue\") Queue queue,\n                                    @Qualifier(\"deadLetterExchange\") DirectExchange exchange) {\n      return BindingBuilder.bind(queue).to(exchange).with(DEAD_LETTER_ROUTING_KEY);\n   }\n\n}</code></pre>\n<h3 id=\"%E7%94%9F%E4%BA%A7%E8%80%85\">生产者</h3>\n<pre><code class=\"language-java\">import static com.ying.demo.config.RabbitMQConfiguration.DELAY_EXCHANGE_NAME;\nimport static com.ying.demo.config.RabbitMQConfiguration.DELAY_QUEUE_ROUTING_KEY;\n/**\n * @author 小影\n * @create: 2022/8/18 11:13\n * @describe：延迟消息生产者\n */\n@Component\npublic class DelayMessageProducer {\n\n   @Resource\n   private RabbitTemplate rabbitTemplate;\n\n   /**\n    *\n    * @param message 消息\n    * @param delayTime 存活时间\n    */\n   public void send(String message,String delayTime) {\n      // param：延迟交换机，路由KEY，存活时间\n      rabbitTemplate.convertAndSend(DELAY_EXCHANGE_NAME, DELAY_QUEUE_ROUTING_KEY, message, msg -&gt; {\n         msg.getMessageProperties().setExpiration(delayTime);\n         return msg;\n      });\n   }\n}</code></pre>\n<h3>消费者</h3>\n<pre><code class=\"language-java\">import com.rabbitmq.client.Channel;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.amqp.core.Message;\nimport org.springframework.amqp.rabbit.annotation.RabbitListener;\nimport org.springframework.stereotype.Component;\nimport java.time.LocalDateTime;\nimport static com.ying.demo.config.RabbitMQConfiguration.DEAD_LETTER_QUEUE_NAME;\n\n/**\n * @author 小影\n * @create: 2022/8/18 11:19\n * @describe：死信消费者\n */\n@Slf4j\n@Component\npublic class DeadLetterQueueConsumer {\n\n   /**\n    * 监听私信队列A\n    * @param message\n    * @param channel 作手动回执、确认\n    */\n   @RabbitListener(queues = DEAD_LETTER_QUEUE_NAME)\n   public void receiveA(Message message, Channel channel) {\n      String msg = new String(message.getBody());\n      log.info(\"当前时间：{}，死信队列收到消息：{}\", LocalDateTime.now(),msg);\n   }\n\n}</code></pre>\n<h3>测试</h3>\n<pre><code class=\"language-java\">@Slf4j\n@RestController\n@RequestMapping(\"rabbitmq\")\npublic class RabbitMqController {\n   @Resource\n   private DelayMessageProducer producer;\n   @GetMapping(\"send\")\n   public void send(String message, String delayTime) {\n      log.info(\"当前时间：{}，消息：{}，存活时间：{}\", LocalDateTime.now(), message, delayTime);\n      producer.send(message, delayTime);\n\n   }\n}</code></pre>\n<p><strong>分别请求</strong></p>\n<p>http://localhost:8089/rabbitmq/send?message=我是60秒&amp;delayTime=60000</p>\n<p>http://localhost:8089/rabbitmq/send?message=我是10秒&amp;delayTime=10000</p>\n<p><strong>弊端：</strong>由于是先进先出的，如果60秒进去了，10秒在进去，10秒结束了，他要等60秒结束，60秒出来10秒才能出来</p>\n<hr/>\n<h2 id=\"%F0%9F%9A%A9%20%E5%86%99%E6%B3%95%E4%B8%89%20(%E6%8F%92%E4%BB%B6%E7%89%88%E6%9C%AC-%E6%8E%A8%E8%8D%90)\">🚩 写法三 (插件版本-推荐)</h2>\n<p>安装插件后会生成新的Exchange类型 <span style=\"color:#ff9900;\">x-delayed-message</span> ，该类型消息支持延迟投递机制，接收消息后并未立即将消息投递至目标队列，而是存储在mnesia(一个分布式数据库)中，随后检测消息延迟时间，如达到投递时间讲其通过 <span style=\"color:#ff9900;\">x-delayed-type</span> 类型标记的交换机投至目标队列。 </p>\n<p><img alt=\"\" height=\"304\" src=\"image\\30b16a1f45024a4f83ef46fee40b71eb.png\" width=\"845\"/></p>\n<h3 id=\"%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85\">插件安装</h3>\n<p>1.进入mq官网社区插件：<a href=\"https://rabbitmq.com/community-plugins.html\" title=\"Community Plugins — RabbitMQ\">Community Plugins — RabbitMQ</a></p>\n<p>2.找到rabbitmq_delayed_message_exchange</p>\n<p><img alt=\"\" height=\"666\" src=\"image\\15ea33afe2024389b411b75b6086106f.png\" width=\"682\"/></p>\n<p> 选择对应版本的ez文件下载</p>\n<p> <a href=\"https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/releases\" title=\"Releases · rabbitmq/rabbitmq-delayed-message-exchange · GitHub\">Releases · rabbitmq/rabbitmq-delayed-message-exchange · GitHub</a></p>\n<p> <img alt=\"\" height=\"412\" src=\"image\\6f8bbbe54c784ffb8f27bbc6a203f863.png\" width=\"1200\"/></p>\n<p> 注：我的MQ是通过yum安装的</p>\n<p> 1.在系统中查看安装的rabbitmq</p>\n<pre><code class=\"hljs\">rpm -qa |grep rabbitmq</code></pre>\n<p><img alt=\"\" height=\"42\" src=\"image\\2ca6b515d0c1443685e33e8ee2dd0171.png\" width=\"450\"/></p>\n<p> 2.查询mq的安装的相关文件目录</p>\n<pre><code class=\"hljs\">rpm -ql rabbitmq-server-3.10.7-1.el8.noarch</code></pre>\n<p><img alt=\"\" height=\"312\" src=\"image\\664deb6705b34c8d82f617959069aeca.png\" width=\"667\"/></p>\n<p> 翻到最下面发现mnesia的安装目录； mnesia=分布式数据库，看看就好</p>\n<p><img alt=\"\" height=\"140\" src=\"image\\656af68f5ccb4b4fbf19f2a09e9e15cc.png\" width=\"421\"/></p>\n<p> 然后把我们下载的ez安装包解压放到 /usr/lib/rabbitmq/lib/rabbitmq_server-3.10.7/plugins 里面</p>\n<p><img alt=\"\" height=\"127\" src=\"image\\70cd6702cfb6497788fbff605bddbb94.png\" width=\"74\"/></p>\n<p>3.重启RabbitMQ服务</p>\n<pre><code class=\"hljs\">systemctl restart rabbitmq-server.service</code></pre>\n<p>4.重启插件</p>\n<pre><code class=\"hljs\">rabbitmq-plugins enable rabbitmq_delayed_message_exchange</code></pre>\n<p> <img alt=\"\" height=\"269\" src=\"image\\0ee8f74d009445e28f5248f868a1f8fc.png\" width=\"812\"/></p>\n<hr/>\n<h3 id=\"RabbitMQ%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6\">RabbitMQ配置文件</h3>\n<pre><code class=\"language-java\">/**\n * @author 小影\n * @create: 2022/8/18 10:26\n * @describe：mq配置 如示例图配置：1交换机、1队列、1路由key\n */\n@Configuration\npublic class RabbitMQConfiguration {\n   // 延迟交换机\n   public static final String DELAY_EXCHANGE_NAME = \"delay.exchange\";\n   // 延迟队列\n   public static final String DELAY_QUEUE_NAME = \"delay.queue\";\n   // 延迟队列路由key\n   public static final String DELAY_QUEUE_ROUTING_KEY = \"delay.routingKey\";\n\n   // 声明延迟交换机\n   @Bean(\"delayExchange\")\n   public CustomExchange delayExchange() {\n      HashMap&lt;String, Object&gt; args = new HashMap&lt;&gt;();\n      args.put(\"x-delayed-type\", \"direct\");\n      return new CustomExchange(DELAY_EXCHANGE_NAME,\"x-delayed-message\",true,false,args);\n   }\n\n\n   // 声明延迟队列\n   @Bean(\"delayQueue\")\n   public Queue delayQueue() {\n      return new Queue(DELAY_QUEUE_NAME);\n   }\n\n\n   // 设置延迟队列的绑定关系\n   @Bean\n   public Binding delayBinding(@Qualifier(\"delayQueue\") Queue queue,\n                               @Qualifier(\"delayExchange\") CustomExchange exchange) {\n      return BindingBuilder.bind(queue).to(exchange).with(DELAY_QUEUE_ROUTING_KEY).noargs();\n   }\n}</code></pre>\n<h3>生产者</h3>\n<pre><code class=\"language-java\">import static com.ying.demo.config.RabbitMQConfiguration.DELAY_EXCHANGE_NAME;\nimport static com.ying.demo.config.RabbitMQConfiguration.DELAY_QUEUE_ROUTING_KEY;\n/**\n * @author 小影\n * @create: 2022/8/18 11:13\n * @describe：延迟消息生产者\n */\n@Component\npublic class DelayMessageProducer {\n\n   @Resource\n   private RabbitTemplate rabbitTemplate;\n\n   /**\n    *\n    * @param message 消息\n    * @param delayTime 存活时间\n    */\n   public void send(String message,Integer delayTime) {\n      // param：延迟交换机，路由KEY，存活时间\n      rabbitTemplate.convertAndSend(DELAY_EXCHANGE_NAME, DELAY_QUEUE_ROUTING_KEY, message, msg -&gt; {\n         msg.getMessageProperties().setDelay(delayTime);\n         return msg;\n      });\n   }\n}</code></pre>\n<h3>消费者</h3>\n<pre><code class=\"language-java\">import static com.ying.demo.config.RabbitMQConfiguration.DELAY_QUEUE_NAME;\n\n/**\n * @author 小影\n * @create: 2022/8/18 11:19\n * @describe：消费者\n */\n@Slf4j\n@Component\npublic class DeadLetterQueueConsumer {\n\n   /*\n    * 监听私信队列\n    * @param message\n    * @param channel 作手动回执、确认\n    */\n   @RabbitListener(queues = DELAY_QUEUE_NAME)\n   public void receiveA(Message message, Channel channel) {\n      String msg = new String(message.getBody());\n      log.info(\"当前时间：{}，延迟队列收到消息：{}\", LocalDateTime.now(),msg);\n   }\n\n}</code></pre>\n<h3>测试</h3>\n<pre><code class=\"language-java\">@Slf4j\n@RestController\n@RequestMapping(\"rabbitmq\")\npublic class RabbitMqController {\n   @Resource\n   private DelayMessageProducer producer;\n   @GetMapping(\"send\")\n   public void send(String message, Integer delayTime) {\n      log.info(\"当前时间：{}，消息：{}，存活时间：{}\", LocalDateTime.now(), message, delayTime);\n      producer.send(message, delayTime);\n\n   }\n}</code></pre>\n<p>启动项目查看rabbitmq的可视化界面</p>\n<p>如下图此时生成的交换机是x-delayed-message类型的</p>\n<p><img alt=\"\" height=\"541\" src=\"image\\e2d7b6137eca429cac8101e2ae82936c.png\" width=\"858\"/></p>\n<p> <strong>分别发送：</strong></p>\n<p>http://localhost:8089/rabbitmq/send?message=我是60秒&amp;delayTime=60000</p>\n<p>http://localhost:8089/rabbitmq/send?message=我是10秒&amp;delayTime=10000</p>\n<p><img alt=\"\" height=\"104\" src=\"image\\216a8de35287453b95713d0cd67fa29b.png\" width=\"545\"/></p>\n<p> 结局并不是60秒先被消费，完成了我们的意愿。</p>\n<p><strong>原理：</strong></p>\n<ol><li>交换机里面有个数据库，生产者生产信息把这个信息放入数据库中</li><li>交换机里面的插件就会一直监听这个时间</li><li>时间到了把对应数据取出来，放入队列，让消费者进行消费</li></ol>\n<p></p>\n<h1 id=\"%F0%9F%91%8D%20%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%E6%96%B9%E6%B3%95%E6%8E%A8%E8%8D%90%C2%A0\">👍 延迟队列方法推荐 </h1>\n<p><img alt=\"\" height=\"1200\" src=\"image\\cd02f27284124aa1b245f8bad2b3123c.png\" width=\"1057\"/></p>\n<p> 这是小编在开发学习使用和总结，  这中间或许也存在着不足，希望可以得到大家的理解和建议。如有侵权联系小编！</p>\n</div>\n</div>"}