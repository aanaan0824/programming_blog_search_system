{"blogid": "126575151", "writerAge": "码龄1年", "writerBlogNum": "49", "writerCollect": "574", "writerComment": "1071", "writerFan": "952", "writerGrade": "5级", "writerIntegral": "2375", "writerName": "♔亮点♔", "writerProfileAdress": "writer_image\\profile_126575151.jpg", "writerRankTotal": "8727", "writerRankWeekly": "68", "writerThumb": "794", "writerVisitNum": "10096", "blog_read_count": "506", "blog_time": "于 2022-08-29 08:19:20 发布", "blog_title": "猿创征文 | Java 泛型&类库&枚举&反射机制 要点", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p></p>\n<div class=\"toc\">\n<h3>要点目录</h3>\n<ul><li><a href=\"#_6\">一、泛型</a></li><li><a href=\"#_27\">二、常用类库</a></li><li><a href=\"#_59\">三、枚举</a></li><li><a href=\"#Java_80\">四、Java反射机制</a></li></ul>\n</div>\n<p></p>\n<h1><a id=\"_6\"></a>一、泛型</h1>\n<blockquote>\n<p>1、泛型可以使程序的操作更加安全，可以避免发生类转换异常。</p>\n</blockquote>\n<blockquote>\n<p>2、在程序中如果使用类时没有指定泛型，则泛型将被擦除掉，将使用<code>Object</code>接收参数。</p>\n</blockquote>\n<blockquote>\n<p>3、可以使用通配符“<code>？</code>”接收全部的泛型类型对象。</p>\n</blockquote>\n<blockquote>\n<p>4、通过<code>&lt;？extends类&gt;</code>可以设置泛型的上限，通过<code>&lt;？super类&gt;</code>可以设置泛型的下限。</p>\n</blockquote>\n<blockquote>\n<p>5、泛型方法可以定义在泛型类中，也可以定义在普通类中。</p>\n</blockquote>\n<blockquote>\n<p>6、泛型可以在接口中定义，实现泛型接口的子类要指明具体的泛型类型。</p>\n</blockquote>\n<blockquote>\n<p>7、泛型可以嵌套使用。</p>\n</blockquote>\n<blockquote>\n<p>8、在程序中定义没有方法的接口，这样的接口一般称为标识接口。</p>\n</blockquote>\n<h1><a id=\"_27\"></a>二、常用类库</h1>\n<blockquote>\n<p>1、在一个字符串内容需要频繁修改时，使用<code>StringBuffer</code>可以提升操作性能，因为 <code>StringBuffer</code>内容可以改变，而String内容不可以改变。</p>\n</blockquote>\n<blockquote>\n<p>2、<code>StringBuffer类</code>中提供了大量的字符串操作方法，如增加、替换、插入等。</p>\n</blockquote>\n<blockquote>\n<p>3、<code>Runtime</code>表示运行时在一个JVM中只存在一个Runtime，所以如果要想取得 Runtime类的对象，直接使用Runtime类中提供的静态方法<code>getRuntime()</code>即可。</p>\n</blockquote>\n<blockquote>\n<p>4、国际化程序实现的基本原理为：所有的语言信息以<code>key—&gt;value</code>的形式保存在资源文件之中，程序通过<code>key</code>找到相应的<code>value</code>,根据其所设置国家的<code>Locale</code>对象不同，找到的资源文件也不同。要想实现国际化必须依靠<code>Locale</code>、<code>ResourceBundle</code>两个类共同完成。</p>\n</blockquote>\n<blockquote>\n<p>5、<code>System类是系统类</code>，可以取得系统的相关信息，使用<code>System.gc()</code>方法可以强制性地进行垃圾的收集操作，调用此方法实际上就是调用了Runtime类中的<code>gc()</code>方法。</p>\n</blockquote>\n<blockquote>\n<p>6、<code>Format类</code>为格式化操作类，主要的3个子类是<code>MessageFormat</code>、<code>NumberFormat</code>、 <code>DateFormat</code>。</p>\n</blockquote>\n<blockquote>\n<p>7、使用<code>Date类</code>可以方便地取得时间，但取得的时间格式不符合地域的风格，所以可以使用<code>SimpleDateFomat类</code>进行日期的格式化操作。</p>\n</blockquote>\n<blockquote>\n<p>8、处理大数字可以使用<code>Biglnteger</code>和<code>BigDecimal</code>类，当需要精确小数点操作位数时应使用<code>BigDecimaI</code>类。</p>\n</blockquote>\n<blockquote>\n<p>9、通过<code>Random类</code>可以取得指定范围的随机数字。</p>\n</blockquote>\n<blockquote>\n<p>10、如果一个类的对象要被克隆，则此对象所在的类必须实现<code>Cloneable</code>接口。</p>\n</blockquote>\n<blockquote>\n<p>11、要对一组对象进行排序，则必须使用比较器，比较器接口<code>Comparable</code>中定义了<code> compareTo()</code>的比较方法，用来设置比较规则。</p>\n</blockquote>\n<blockquote>\n<p>12、正则表达式是开发中最常使用的一种验证方法，String类中的<code>replaceAll()</code>、<code>split()</code>、 <code>matches()</code>方法都对正则有所支持。</p>\n</blockquote>\n<blockquote>\n<p>13、可以使用<code>Time</code>和<code>TimeTask</code>类完成系统的定时操作。</p>\n</blockquote>\n<h1><a id=\"_59\"></a>三、枚举</h1>\n<blockquote>\n<p>1、在程序中可以使用一个枚举来指定对象的取值范围。</p>\n</blockquote>\n<blockquote>\n<p>2、在Java中使用<code>enum</code>关键字定义一个枚举类，每一个枚举类都是继承<code>Enum类</code>。</p>\n</blockquote>\n<blockquote>\n<p>3、在枚举中可以通过<code>values()</code>方法取得枚举中的全部内容。</p>\n</blockquote>\n<blockquote>\n<p>4、在枚举类中可以定义构造方法，但在设置枚举范围时必须显式地调用构造方法。</p>\n</blockquote>\n<blockquote>\n<p>5、所有的枚举类都可以直接使用<code>Comparable</code>进行排序，因为<code>Enum类</code>实现了<code>Comparable</code>接口。</p>\n</blockquote>\n<blockquote>\n<p>6、Java类集中提供枚举的支持类是<code>EnumMap</code>、<code>EnumSet</code>。</p>\n</blockquote>\n<h1><a id=\"Java_80\"></a>四、Java反射机制</h1>\n<blockquote>\n<p>1、<code>Class类</code>是反射机制操作的源头。</p>\n</blockquote>\n<blockquote>\n<p>2、Class类的对象有3种实例化方式：<br/> （1）通过Object类中的<code>getClass()</code>方法。<br/> （2）通过“<code>类.class</code> ”的形式。<br/> （3）通过<code>Class.forName()</code>方法，此种方式最为常用。</p>\n</blockquote>\n<blockquote>\n<p>3、可以通过Class类中的<code>newInstance()</code>方法进行对象的实例化操作，但是要求类中必须存在无参构造方法，如果类中没有无参构造，则必须使用<code>Constructor类</code>完成对象的实例化操作。</p>\n</blockquote>\n<blockquote>\n<p>4、可以通过反射取得一个类所继承的父类、实现的接口、类中的全部构造方法、全部普通方法及全部属性。</p>\n</blockquote>\n<blockquote>\n<p>5、使用反射机制可以通过<code>Method</code>调用类中的方法，也可以直接操作类中的属性。</p>\n</blockquote>\n<blockquote>\n<p>6、动态代理可以解决开发中代理类过多的问题，提供统一的代理功能实现。</p>\n</blockquote>\n<blockquote>\n<p>7、在程序的开发中使用反射机制并结合属性文件，可以达到程序代码与配置文件相分离的目的。</p>\n</blockquote>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}