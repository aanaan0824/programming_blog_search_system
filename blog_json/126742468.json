{"blogid": "126742468", "writerAge": "码龄1年", "writerBlogNum": "363", "writerCollect": "182", "writerComment": "16", "writerFan": "8116", "writerGrade": "5级", "writerIntegral": "3783", "writerName": "m0_67402588", "writerProfileAdress": "writer_image\\profile_126742468.jpg", "writerRankTotal": "5266", "writerRankWeekly": "1043", "writerThumb": "39", "writerVisitNum": "175600", "blog_read_count": "16", "blog_time": "于 2022-09-07 11:38:50 发布", "blog_title": "JDK11-JVM参数配置详解", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h3><a id=\"_2\"></a>示例配置</h3>\n<h5><a id=\"server_4\"></a>-server</h5>\n<h5><a id=\"Xmx4g_6\"></a>-Xmx4g</h5>\n<h5><a id=\"Xms4g_8\"></a>-Xms4g</h5>\n<h5><a id=\"Xss256k_10\"></a>-Xss256k</h5>\n<h5><a id=\"XXMaxDirectMemorySize256m_12\"></a>-XX:MaxDirectMemorySize=256m</h5>\n<blockquote>\n<p>heap ByteBuffer -&gt; -XX:Xmx -&gt; 一种是heap ByteBuffer,该类对象分配在JVM的堆内存里面，直接由Java虚拟机负责垃圾回收。</p>\n<p>direct ByteBuffer -&gt; -XX:MaxDirectMemorySize -&gt; 一种是direct ByteBuffer是通过jni在虚拟机外内存中分配的。通过jmap无法查看该快内存的使用情况。只能通过top来看它的内存使用情况。</p>\n</blockquote>\n<h5><a id=\"XXUseG1GC_18\"></a>-XX:+UseG1GC</h5>\n<h5><a id=\"XXUseCompressedOops_20\"></a>-XX:+UseCompressedOops</h5>\n<blockquote>\n<p>new一个空对象在32为系统中占用内存大小是8byte（对象头，在堆中）+4byte（对象的引用地址，在栈中）=12byte；</p>\n<p>new一个空对象在64为系统中占用内存大小是16byte（对象头，在堆中）+8byte（对象的引用地址，在栈中）=24byte；</p>\n<p>可想而知同一个对象在64位系统中占的内存加大一半了，不仅消耗运行内存，而且GC回收时挺耗cpu的。</p>\n<p>jvm的属性-XX:+UseCompressedOops在JDK 1.6和之后的版本都默认开启了，所以jvm开启了压缩之后64为系统的对象也只占用12byte。</p>\n</blockquote>\n<h5><a id=\"XXUseCompressedClassPointers_30\"></a>-XX:+UseCompressedClassPointers</h5>\n<blockquote>\n<p>由于UseCompressedClassPointers的开启是依赖于UseCompressedOops的开启，因此，要使UseCompressedClassPointers起作用，得先开启UseCompressedOops，并且开启UseCompressedOops 也默认强制开启UseCompressedClassPointers，关闭UseCompressedOops 默认关闭UseCompressedClassPointers。</p>\n<p>如果开启类指针压缩，+UseCompressedClassPointers，根据上面的条件，结果跟只开启UseCompressedOops一样，会在内存中消耗20个字节，o指针占4个字节，Object对象占16个字节。</p>\n</blockquote>\n<h5><a id=\"XXSegmentedCodeCache_36\"></a>-XX:+SegmentedCodeCache</h5>\n<blockquote>\n<p>通过 SegmentedCodeCache参数可以选择按照整体初始化，还是分段初始化。</p>\n<p>通过 -XX:ReservedCodeCacheSize参数可以指定Code Cache的初始化大小，这个默认值在不同的JDK版本也不同，目前我这边调试的是OpenJDK11，默认大小是240M，这个已经够用了。</p>\n</blockquote>\n<h5><a id=\"verbosegc_42\"></a>-verbose:gc</h5>\n<blockquote>\n<p>包含在-XX:+PrintGCDetails中，用于打印GC详情</p>\n</blockquote>\n<h5><a id=\"XXPrintCommandLineFlags_46\"></a>-XX:+PrintCommandLineFlags</h5>\n<blockquote>\n<p>打印JVM所有参数</p>\n</blockquote>\n<h5><a id=\"XXExplicitGCInvokesConcurrent_50\"></a>-XX:+ExplicitGCInvokesConcurrent</h5>\n<blockquote>\n<p>这个参数会在system.gc()的时候使用CMS垃圾回收器，降低gc耗时</p>\n</blockquote>\n<h5><a id=\"Djavasecurityegdfiledevurandom_54\"></a>-Djava.security.egd=file:/dev/./urandom</h5>\n<blockquote>\n<p>SecureRandom在java各种组件中使用广泛，可以可靠的产生随机数。但在大量产生随机数的场景下，性能会较低。这时可以使用<a href=\"http://file/dev/urandom%22%E8%BF%99%E4%B8%AA%E5%8F%82%E6%95%B0%E5%B0%86%E4%B8%8D%E7%94%9F%E6%95%88%E3%80%82\">\"-Djava.security.egd=</a><a href=\"http://file/dev/urandom\">file:/dev/./urandom</a><a href=\"http://file/dev/urandom%22%E8%BF%99%E4%B8%AA%E5%8F%82%E6%95%B0%E5%B0%86%E4%B8%8D%E7%94%9F%E6%95%88%E3%80%82\">\"</a>加快随机数产生过程。</p>\n<p>參考鏈接：</p>\n<p>https://blog.51cto.com/leo01/1795447</p>\n</blockquote>\n<h5><a id=\"XloggcsafepointdatalogSERVICE_NAMEgclogtimeuptimefilecount100filesize50M_62\"></a>-Xlog:gc*,safepoint:/data/log/${SERVICE_NAME}/gc.log:time,uptime:filecount=100,filesize=50M</h5>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}