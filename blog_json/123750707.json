{"blogid": "123750707", "writerAge": "码龄4年", "writerBlogNum": "97", "writerCollect": "163", "writerComment": "27", "writerFan": "12", "writerGrade": "4级", "writerIntegral": "1225", "writerName": "coder_Alger", "writerProfileAdress": "writer_image\\profile_123750707.jpg", "writerRankTotal": "24568", "writerRankWeekly": "43797", "writerThumb": "39", "writerVisitNum": "59872", "blog_read_count": "3592", "blog_time": "已于 2022-06-08 15:37:21 修改", "blog_title": "C/C++二维数组指针（指向二维数组的指针）详解", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h2>多维数组与指针</h2>\n<p>用指针变量可以指向一维数组中的元素，也可以指向多维数组中的元素。<br/><br/><strong>1) 多维数组元素的地址</strong><br/> 设有一个二维数组 a，它有 3 行 4 列。它的定义为：<br/>     int a[3][4]={<!-- -->{1,3,5,7},{9,11,13,15},{17,18,21,23}};<br/> a 是一个数组名。a 数组包含 3 行，即 3 个元素：a [0]，a [1]，a [2]。而每一元素又是一个一维数组，它包含 4 个元素 (即 4 个列元素)，例如，a [0] 所代表的一维数组又包含 4 个元素： a [0][0]， a [0][1]， a [0][2]， a [0][3]，如图所示。可以认为二维数组是 “数组的数组”，即数组 a 是由 3 个一维数组所组成的。<br/>  </p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\33f1cc5623be9b0eb43ad49160c9a6fa.png\"/></p>\n<p>从二维数组的角度来看，a 代表二维数组首元素的地址，现在的首元素不是一个整型变量，而是由 4 个整型元素所组成的一维数组，因此 a 代表的是首行的起始地址 (即第 0 行的起始地址，&amp;a [0])，a+1 代表 a [1] 行的首地址，即 &amp; a [1]。<br/><br/> a [0]，a [1]，a [2] 既然是一维数组名，而 C++ 又规定了数组名代表数组首元素地址，因此 a [0] 代表一维数组 a [0] 中 0 列元素的地址，即 &amp; a [0][0]。a [1] 的值是 &amp; a [1][0]，a [2] 的值是 &amp; a [2][0]。<br/>  </p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\9358faf34554bc80f886b8ac2428570b.png\"/></p>\n<p>0 行 1 列元素的地址可以直接写为 &amp; a [0][1]，也可以用指针法表示。a [0] 为一维数组名，该一维数组中序号为 1 的元素显然可以用 a [0]+1 来表示。<br/><br/> 欲得到 a [0][1] 的值，用地址法怎么表示呢？既然 a [0]+1 是 a [0][1] 元素的地址，那么，*(a [0]+1) 就是 a [0][1] 元素的值。而 a [0] 又是和 *(a+0) 无条件等价的，因此也可以用 *(*(a+0)+1) 表示 a [0][1] 元素的值。依此类推，<span style=\"background-color:#a2e043;\">*(a [i]+j) 或 *(*(a+i)+j) 是 a [i][j] 的值。</span><br/>  </p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\f7ec1367b6a3664ca46141037cf6a006.png\"/></p>\n<p><strong>2) 指向多维数组元素的指针变量</strong><br/> ① 指向数组元素的指针变量<br/> 【例1】输出二维数组各元素的值。这里采用的方法是用基类型为整型的指针变量先后指向各元素，逐个输出它们的值。（三种方法均可）</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\nusing namespace std;\nint main()\n{\n\tint a[3][4] = { 1,3,5,7,9,11,13,15,17,19,21,23 };\n\t//p是基类型为整型的指针变量\n\t//p = a[0]  等同于 p = &amp;a[0][0];  也即0行首元素的地址\n\tint* p;                              \n\tfor (p = a[0]; p &lt; a[0] + 12; p++)\n\t\tcout &lt;&lt; *p &lt;&lt; \" \";\n\n\tfor (int i = 0;i&lt;3;i++)\n\t{\n\t\tfor (int j = 0;j&lt;4;j++)\n\t\t{\n\t\t\t//cout &lt;&lt; *(*(a + i) + j) &lt;&lt; \" \";\n\t\t\tcout &lt;&lt; *(a[i] + j) &lt;&lt; \" \";\n\t\t}\n\t}\n\tcout &lt;&lt; endl;\n\treturn 0;\n}</code></pre>\n<h3>关于指向数组元素的指针变量的几点说明：</h3>\n<ul><li>p 是指向整型数据的指针变量，在 for 语句中对 p 赋初值 a [0]，也可以写成 “p=&amp;a [0][0]”。</li><li>循环结束的条件是 “p&lt;a [0]+12”，只要满足 p&lt;a [0]+12，就继续执行循环体。</li><li>执行 “cout&lt;&lt;*p;” 输出 p 当前所指的列元素的值，然后执行 p++，使 p 指向下一个列元素。</li></ul>\n<h3>②指向由 m 个元素组成的一维数组的指针变量</h3>\n<p>可以定义一个指针变量，它不是指向一个整型元素，而是指向一个包含 m 个元素的一维数组。这时，如果指针变量 p 先指向 a [0](即 p=&amp;a [0])，则 p+1 不是指向 a [0][1]，而是指向 a [1]，p 的增值以一维数组的长度为单位。</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\bbecfce892521e256b3ffe9e5611e9c6.png\"/></p>\n<p>【例2】输出二维数组任一行任一列元素的值。</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\nusing namespace std;\nint main( )\n{\n    int a[3][4]={1,3,5,7,9,11,13,15,17,19,21,23};\n    int (*p)[4],i,j;\n    cin&gt;&gt;i&gt;&gt;j;\n    p=a;\n    cout&lt;&lt;*(*(p+i)+j)&lt;&lt;endl;\n    return 0;\n}</code></pre>\n<p>由于执行了 “p=a”，等同于\"p = &amp;a[0] \"使 p 指向 a [0]。因此 p+2 是二维数组 a 中序号为 2 的行的起始地址 (由于 p 是指向一维数组的指针变量，因此 p 加 1，就指向下一个一维数组)。*(p+2)+3 是 a 数组 2 行 3 列元素地址。*(*(p+2)+3) 是 a [2][3] 的值。</p>\n<p class=\"img-center\"><img alt=\"\" src=\"image\\cea2ef250ffa44a8b048a157e9c143b0.png\"/></p>\n<p></p>\n<p><strong>3) 用指向数组的指针作函数参数</strong><br/> 一维数组名可以作为函数参数传递，多维数组名也可作函数参数传递。</p>\n<p>【例3】输出二维数组各元素的值。题目与例1相同，但本题用一个函数实现输出，用多维数组名作函数参数。</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\nusing namespace std;\nint main( )\n{\n    void output(int (*p)[4]);  //函数声明 \n    int a[3][4]={1,3,5,7,9,11,13,15,17,19,21,23};\n    output(a);  //多维数组名作函数参数\n    return 0;\n}\n\n//相当于  p = a;或者 p = &amp;a[0];\nvoid output(int (*p)[4])  //形参是指向一维数组的指针变量\n{\n    int i,j;\n    for(i=0;i&lt;3;i++)\n        for(j=0;j&lt;4;j++)\n            cout&lt;&lt;*(*(p+i)+j)&lt;&lt;\" \";\n    cout&lt;&lt;endl;\n}</code></pre>\n<h3>指针数组和二维数组指针的区别</h3>\n<p>指针数组和二维数组指针在定义时非常相似，只是括号的位置不同：</p>\n<pre><code class=\"language-cpp\">int *(p1[5]); //指针数组，可以去掉括号直接写作\n\nint *p1[5]; int (*p2)[5]; //二维数组指针，不能去掉括号</code></pre>\n<p>指针数组和二维数组指针有着本质上的区别：指针数组是一个数组，只是每个元素保存的都是指针，以上面的 p1 为例，在 32 位环境下它占用 4×5 = 20 个字节的内存。二维数组指针是一个指针，它指向一个二维数组，以上面的 p2 为例，它占用 4 个字节的内存。</p>\n<h3>二级指针</h3>\n<p>使用二级指针初始化一级指针</p>\n<p><img alt=\"\" height=\"337\" src=\"image\\c65d2f5cd6684dc89a26d35bccc4cce6.png\" width=\"865\"/></p>\n<pre><code class=\"language-cpp\">#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;stdlib.h&gt;\nenum\n{\n    Success,NameErr,SexErr,StrNumErr,ScoreErr\n};\ntypedef struct stu\n{\n    char *name;\n    char *sex;\n    char *strNum;\n    float *score;\n}STU;\nint init(STU ** p)\n{\n    *p = (STU *)malloc(sizeof(STU));//*p就是ps,申请一块空间里面存放4个不同类型的指针，将首地址赋值给ps\n    //初始化一级指针，使这4个不同类型的指针都有所指向\n    (*p)-&gt;name = (char *)malloc(sizeof(100));\n    if((*p)-&gt;name == NULL)\n        return NameErr;\n    (*p)-&gt;sex = (char *)malloc(sizeof(char));\n    if((*p)-&gt;sex == NULL)\n        return SexErr;\n    (*p)-&gt;strNum = (char *)malloc(sizeof(30));\n    if((*p)-&gt;strNum == NULL)\n        return StrNumErr;\n    (*p)-&gt;score = (float *)malloc(sizeof(float));\n    if((*p)-&gt;score == NULL)\n        return ScoreErr;\n    return Success;\n}\nint main(void)\n{\n    STU * ps = NULL;\n\n    int ret = init(&amp;ps);\n    if(ret != Success)\n        return -1;\n    strcpy(ps-&gt;name,\"wahaha\");\n    *(ps-&gt;sex) = 'x';\n    strcpy(ps-&gt;strNum,\"语文\");\n    *(ps-&gt;score) = 66.5;\n\n    printf(\"姓名：%s\\n性别：%c\\n科目：%s\\n分数：%.2f\\n\",ps-&gt;name,*(ps-&gt;sex),ps-&gt;strNum,*(ps-&gt;score));\n    return 0;\n}</code></pre>\n</div>\n</div>"}