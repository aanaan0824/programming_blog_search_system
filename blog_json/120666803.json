{"blogid": "120666803", "writerAge": "码龄3年", "writerBlogNum": "1", "writerCollect": "281", "writerComment": "2", "writerFan": "7", "writerGrade": "1级", "writerIntegral": "30", "writerName": "努力工作的皮卡丘", "writerProfileAdress": "writer_image\\profile_120666803.jpg", "writerRankTotal": "720709", "writerRankWeekly": "1200634", "writerThumb": "17", "writerVisitNum": "9048", "blog_read_count": "9005", "blog_time": "于 2021-10-09 16:17:08 发布", "blog_title": "2021年嵌入式面试题汇总（最新经典）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h3 id=\"%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2%EF%BC%9A%E7%A7%8B%E6%8B%9B%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91%E6%96%B9%E5%90%91%EF%BC%8C%E7%BB%8F%E8%BF%87%E4%BA%86%E5%BE%88%E5%A4%9A%E5%9C%BA%E7%9A%84%E7%AC%94%E8%AF%95%E4%B8%8E%E9%9D%A2%E8%AF%95%EF%BC%8C%E5%9C%A8%E5%87%86%E5%A4%87%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9C%8B%E4%BA%86%E9%9D%9E%E5%B8%B8%E5%A4%9A%E7%9A%84%E8%B5%84%E6%96%99%EF%BC%8C%E7%8E%B0%E5%9C%A8%E6%8A%8A%E4%BB%96%E4%BB%AC%E6%95%B4%E7%90%86%E4%B8%80%E4%B8%8B%EF%BC%8C%E6%9C%89%E7%9A%84%E8%B5%84%E6%96%99%E7%9C%8B%E8%BF%87%E4%BA%86%E8%A7%89%E5%BE%97%E4%B8%8D%E9%94%99%E5%B0%B1%E4%BF%9D%E5%AD%98%E4%B8%8B%E6%9D%A5%E4%BA%86%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%9C%89%E4%B8%8D%E5%AF%B9%E7%9A%84%E5%9C%B0%E6%96%B9%EF%BC%8C%E6%AC%A2%E8%BF%8E%E6%89%B9%E8%AF%84%E6%8C%87%E6%AD%A3%EF%BC%8C%E4%BE%B5%E6%9D%83%E8%81%94%E5%88%A0%EF%BC%81%EF%BC%88%E6%85%A2%E6%85%A2%E6%9B%B4%E6%96%B0%E8%BF%87%E7%A8%8B%E4%B8%AD........%EF%BC%89\">写在前面：秋招嵌入式开发方向，经过了很多场的笔试与面试，在准备的过程中看了非常多的资料，现在把他们整理一下，有的资料看过了觉得不错就保存下来了，如果有不对的地方，欢迎批评指正，侵权联删！（慢慢更新过程中........）</h3>\n<h3 id=\"-------------------------------------------------------------------------------------------------------------------\">-------------------------------------------------------------------------------------------------------------------</h3>\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2%EF%BC%9A%E7%A7%8B%E6%8B%9B%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91%E6%96%B9%E5%90%91%EF%BC%8C%E7%BB%8F%E8%BF%87%E4%BA%86%E5%BE%88%E5%A4%9A%E5%9C%BA%E7%9A%84%E7%AC%94%E8%AF%95%E4%B8%8E%E9%9D%A2%E8%AF%95%EF%BC%8C%E5%9C%A8%E5%87%86%E5%A4%87%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9C%8B%E4%BA%86%E9%9D%9E%E5%B8%B8%E5%A4%9A%E7%9A%84%E8%B5%84%E6%96%99%EF%BC%8C%E7%8E%B0%E5%9C%A8%E6%8A%8A%E4%BB%96%E4%BB%AC%E6%95%B4%E7%90%86%E4%B8%80%E4%B8%8B%EF%BC%8C%E6%9C%89%E7%9A%84%E8%B5%84%E6%96%99%E7%9C%8B%E8%BF%87%E4%BA%86%E8%A7%89%E5%BE%97%E4%B8%8D%E9%94%99%E5%B0%B1%E4%BF%9D%E5%AD%98%E4%B8%8B%E6%9D%A5%E4%BA%86%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%9C%89%E4%B8%8D%E5%AF%B9%E7%9A%84%E5%9C%B0%E6%96%B9%EF%BC%8C%E6%AC%A2%E8%BF%8E%E6%89%B9%E8%AF%84%E6%8C%87%E6%AD%A3%EF%BC%8C%E4%BE%B5%E6%9D%83%E8%81%94%E5%88%A0%EF%BC%81%EF%BC%88%E6%85%A2%E6%85%A2%E6%9B%B4%E6%96%B0%E8%BF%87%E7%A8%8B%E4%B8%AD........%EF%BC%89-toc\" style=\"margin-left:80px;\"></p>\n<p id=\"1%E3%80%81c%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-toc\" style=\"margin-left:80px;\"><a href=\"#1%E3%80%81c%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B\" title=\"1、c语言内存模型\">1、c语言内存模型</a></p>\n<p id=\"2%E3%80%81C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89%E5%9C%A8%E4%BB%80%E4%B9%88%E5%9C%B0%E6%96%B9-toc\" style=\"margin-left:80px;\"><a href=\"#2%E3%80%81C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89%E5%9C%A8%E4%BB%80%E4%B9%88%E5%9C%B0%E6%96%B9\" title=\"2、C语言中的变量定义在什么地方\">2、C语言中的变量定义在什么地方</a></p>\n<p id=\"3%E3%80%81C%E8%AF%AD%E8%A8%80%E4%BB%A3%E7%A0%81%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C%E7%9A%84%E3%80%81%E5%85%B3%E4%BA%8E%E6%A0%88%E7%9A%84%E7%9B%B8%E5%85%B3-toc\" style=\"margin-left:80px;\"><a href=\"#3%E3%80%81C%E8%AF%AD%E8%A8%80%E4%BB%A3%E7%A0%81%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C%E7%9A%84%E3%80%81%E5%85%B3%E4%BA%8E%E6%A0%88%E7%9A%84%E7%9B%B8%E5%85%B3\" title=\"3、C语言代码如何运行的、关于栈的相关\">3、C语言代码如何运行的、关于栈的相关</a></p>\n<p id=\"4%E3%80%81%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0%E4%B8%8E%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%86-toc\" style=\"margin-left:80px;\"><a href=\"#4%E3%80%81%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0%E4%B8%8E%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%86\" title=\"4、指针函数与函数指针的区分\">4、指针函数与函数指针的区分</a></p>\n<p id=\"5%E3%80%81Static%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8-toc\" style=\"margin-left:80px;\"><a href=\"#5%E3%80%81Static%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8\" title=\"5、Static关键字的作用\">5、Static关键字的作用</a></p>\n<p id=\"6%E3%80%81const%E4%BD%9C%E7%94%A8-toc\" style=\"margin-left:80px;\"><a href=\"#6%E3%80%81const%E4%BD%9C%E7%94%A8\" title=\"6、const作用\">6、const作用</a></p>\n<p id=\"7%E3%80%81%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB-toc\" style=\"margin-left:80px;\"><a href=\"#7%E3%80%81%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB\" title=\"7、进程与线程的区别\">7、进程与线程的区别</a></p>\n<p id=\"8%E3%80%81%E9%93%BE%E8%A1%A8%E4%B8%8E%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB-toc\" style=\"margin-left:80px;\"><a href=\"#8%E3%80%81%E9%93%BE%E8%A1%A8%E4%B8%8E%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB\" title=\"8、链表与数组的区别\">8、链表与数组的区别</a></p>\n<p id=\"9%E3%80%81%23define%E5%AE%8F%E5%AE%9A%E4%B9%89%E4%B8%8Etypedef%E7%9A%84%E5%8C%BA%E5%88%AB-toc\" style=\"margin-left:80px;\"><a href=\"#9%E3%80%81%23define%E5%AE%8F%E5%AE%9A%E4%B9%89%E4%B8%8Etypedef%E7%9A%84%E5%8C%BA%E5%88%AB\" title=\"9、#define宏定义与typedef的区别\">9、#define宏定义与typedef的区别</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h3 id=\"1%E3%80%81c%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B\">1、c语言内存模型</h3>\n<p><img alt=\"\" height=\"401\" src=\"image\\20211009105544778.png\" width=\"373\"/><img alt=\"\" height=\"387\" src=\"image\\20211009105559912.png\" width=\"304\"/></p>\n<h3 id=\"2%E3%80%81C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89%E5%9C%A8%E4%BB%80%E4%B9%88%E5%9C%B0%E6%96%B9\">2、C语言中的变量定义在什么地方</h3>\n<p><strong>内存中供用户使用的存储空间分为三部分</strong>：1、程序区，2、静态存储区3、动态存储区。</p>\n<p>内存中局部变量定义在栈区，全局变量和静态变量放在静态数据区。</p>\n<p>还不理解可参考：<a href=\"https://blog.csdn.net/qian27enjoy/article/details/82624031\" title=\"动态存储区、静态存储区、堆和栈的区别_qian_enjoy-CSDN博客\">动态存储区、静态存储区、堆和栈的区别_qian_enjoy-CSDN博客</a></p>\n<h3 id=\"3%E3%80%81C%E8%AF%AD%E8%A8%80%E4%BB%A3%E7%A0%81%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C%E7%9A%84%E3%80%81%E5%85%B3%E4%BA%8E%E6%A0%88%E7%9A%84%E7%9B%B8%E5%85%B3\">3、C语言代码如何运行的、关于栈的相关</h3>\n<p>   1、预处理--编译--汇编--链接</p>\n<p>      （1）预处理(Preprocessing)：用于将所有的#include头文件以及宏定义替换成其真正的内容；</p>\n<p>      （2）编译(Compilation)：将经过预处理之后的程序转换成特定汇编代码的过程；</p>\n<p>      （3）汇编(Assemble)：将上一步的汇编代码转换成机器码，产生的文件叫做目标文件(.o)；</p>\n<p>      （4）链接(Linking)：链接过程将多个目标文件以及所需的库文件(.so等)链接成最终的可执行文件(.exe)。</p>\n<p>   2、程序定义的“局部变量”会放在计算机内存中（栈），栈在数据结构是最基本的操作，只有两个操作，一个是push入栈，另一个是pop出栈。在c的栈中，是从栈顶向下开始存入变量的。</p>\n<h3 id=\"4%E3%80%81%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0%E4%B8%8E%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%86\">4、指针函数与函数指针的区分</h3>\n<p>指针函数</p>\n<p>简单来说，就是一个返回指针的函数。本质是一个函数，函数返回的类型是一个指针。</p>\n<p>普通函数的声明：</p>\n<pre><code> int sort (int a,int b);</code></pre>\n<p>指针函数的声明：</p>\n<pre><code> int *sort(int a,int b);</code></pre>\n<p>函数指针</p>\n<p>本质是一个指针变量，该指针指向这个函数。总结来说，函数指针就是指向函数的指针。</p>\n<p>函数指针的声明：</p>\n<pre><code> int  (*sort)(int a,int b);</code></pre>\n<p>函数指针的赋值有两种方法：</p>\n<pre><code> sort=&amp;a;\n sort=a;</code></pre>\n<p>取地址运算符&amp;不是必需的，因为一个函数标识符就表示了它的地址，如果是函数调用，还必须包含一个圆括号括起来的参数表。</p>\n<p><strong>两者的不同</strong></p>\n<p>1、定义不同</p>\n<p>指针函数本质上是一个函数，其返回值时指针。</p>\n<p>函数指针本质上式一个指针，其指向一个函数。</p>\n<p>2、写法不同</p>\n<pre><code> 指针函数:int *sort(int a,int b);\n 函数指针：int (*sort)(int a,int b);</code></pre>\n<p></p>\n<h3 id=\"5%E3%80%81Static%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8\">5、Static关键字的作用</h3>\n<p>1、作用于变量：（参考内存分部，静态存储区与动态存储区，看前面的3和4）</p>\n<p><strong>用Static声明局部变量</strong>------局部变量是指在代码块内定义的变量，只在代码块内起作用，其缺省的存储方式是自动变量或说是动态存储的，即指令执行到变量时才会给变量分配存储单元，调出代码块时释放内存单元。用Static关键字声明后，是变量成为静态的局部变量，即编译时就为变量分配存储单元，直到程序结束时才释放。这样，使得该局部变量有记忆功能，可以记忆上次的数据，不过由于仍是局部变量，因而只能在代码块内部使用（作用域不变）。</p>\n<p><strong>用Static声明全局变量</strong>-----全局变量指在所有代码块{}之外定义的变量，它缺省为静态变量，编译时分配内存，程序结束时释放内存单元。同时全局变量作用域很广，整个文件都有效甚至别的文件也能引用它。为了限制某些全局变量的作用域，使其只在本文件中有效，而不能被其他文件引用，可以用static关键字对其作出声明。</p>\n<p></p>\n<p><strong>总结：</strong>用static声明局部变量，使其变为静态存储方式(静态数据区)，作用域不变；用static声明外部变量，其本身就是静态变量，这只会改变其连接方式，使其只在本文件内部有效，而其他文件不可连接或引用该变量。</p>\n<p></p>\n<p>2、作用于函数</p>\n<p>使用static用于函数定义时，对函数的连接方式产生影响，使得函数只在本文件内部有效，对其他文件是不可见的。这样的函数又叫作静态函数。使用静态函数的好处是，不用担心与其他文件的同名函数产生干扰，另外也是对函数本身的一种保护机制。</p>\n<p>　　如果想要其他文件可以引用本地函数，则要在函数定义时使用关键字extern，表示该函数是外部函数，可供其他文件调用。另外在要引用别的文件中定义的外部函数的文件中，使用extern声明要用的外部函数即可。</p>\n<p></p>\n<h3 id=\"6%E3%80%81const%E4%BD%9C%E7%94%A8\">6、const作用</h3>\n<p>1、定义常量</p>\n<p>(1)const<strong>(修饰的变量不可变)</strong></p>\n<p>修饰变量，以下两种定义形式在本质上是一样的。它的含义是：const修饰的类型为TYPE的变量value是不可变的,readonly。</p>\n<pre><code>TYPE const ValueName = value;\n\nconst TYPE ValueName = value;</code></pre>\n<p></p>\n<p>(2)将const改为外部连接,作用于扩大至全局,编译时会分配内存,并且可以不进行初始化,仅仅作为声明,编译器认为在程序其他地方进行了定义. <strong>(修饰的外部链接可以不用定义直接声明使用)</strong></p>\n<pre><code>extend const int ValueName = value;</code></pre>\n<p></p>\n<p>2、指针使用const（）</p>\n<p>(1)指针本身是常量不可变</p>\n<pre><code>char * const pContent;\n\nconst (char*) pContent;</code></pre>\n<p>(2)指针所指向的内容是常量不可变</p>\n<pre><code>const char *pContent;\n\nchar const *pContent;</code></pre>\n<p>(3)两者都不可变</p>\n<pre><code>const char* const pContent;</code></pre>\n<p>(4)还有其中区别方法，沿着<em>号划一条线：如果const位于</em>的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；如果const位于*的右侧，const就是修饰指针本身，即指针本身是常量。</p>\n<p></p>\n<h3 id=\"7%E3%80%81%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB\">7、进程与线程的区别</h3>\n<p><strong>根本区别：</strong>进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位</p>\n<p><strong>在开销方面：</strong>每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。</p>\n<p><strong>所处环境</strong>：在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）</p>\n<p><strong>内存分配方面：</strong>系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源。</p>\n<p><strong>包含关系</strong>：没有线程的进程可以看做是单线程的，如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。</p>\n<p><strong>总结一下：进程：1、操作系统会分配地址空间 2、一个进程当中可以有多个线程</strong></p>\n<p><strong>线程：1、没有独立的地址空间 2、一个进程里的多个线程可以共享该进程的所有资源 3、线程有自己的栈、堆和局部变量 4、线程是不能独立执行的</strong></p>\n<p></p>\n<p><strong>补充：</strong></p>\n<p><strong>1、同步和互斥的区别</strong></p>\n<p>当有多个线程的时候，经常需要去同步这些线程以访问同一个数据或资源。例如，假设有一个程序，其中一个线程用于把文件读到内存，而另一个线程用于统计文件中的字符数。当然，在把整个文件调入内存之前，统计它的计数是没有意义的。但是，由于每个操作都有自己的线程，操作系统会把两个线程当作是互不相干的任务分别执行，这样就可能在没有把整个文件装入内存时统计字数。为解决此问题，你必须使两个线程同步工作。</p>\n<p>所谓同步，是指散步在不同进程之间的若干程序片断，它们的运行必须严格按照规定的某种先后次序来运行，这种先后次序依赖于要完成的特定的任务。如果用对资源的访问来定义的话，同步是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源。</p>\n<p>所谓互斥，是指散布在不同进程之间的若干程序片断，当某个进程运行其中一个程序片段时，其它进程就不能运行它们之中的任一程序片段，只能等到该进程运行完这个程序片段后才可以运行。如果用对资源的访问来定义的话，互斥某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。</p>\n<p><strong>2、进程间通信的方式</strong></p>\n<p>（1）管道（pipe）及有名管道（named pipe）：管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。</p>\n<p>（2）信号（signal）：信号是在软件层次上对中断机制的一种模拟，它是比较复杂的通信方式，用于通知进程有某事件发生，一个进程收到一个信号与处理器收到一个中断请求效果上可以说是一致的。</p>\n<p>（3）消息队列（message queue）：消息队列是消息的链接表，它克服了上两种通信方式中信号量有限的缺点，具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息。</p>\n<p>（4）共享内存（shared memory）：可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。</p>\n<p>（5）信号量（semaphore）：主要作为进程之间及同一种进程的不同线程之间得同步和互斥手段。</p>\n<p>（6）套接字（socket）：这是一种更为一般得进程间通信机制，它可用于网络中不同机器之间的进程间通信，应用非常广泛。</p>\n<p></p>\n<h3 id=\"8%E3%80%81%E9%93%BE%E8%A1%A8%E4%B8%8E%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB\">8、链表与数组的区别</h3>\n<p>链表是一种上一个元素的引用指向下一个元素的存储结构，链表通过指针来连接元素与元素；</p>\n<p>链表分为：单向链表、双向链表、循环链表</p>\n<p>链表是链式的存储机构；数组是顺序的存储机构</p>\n<p>链表通过指针来连接元素与元素，数组则是把所有元素按次序依次存储。</p>\n<p><strong>总结：</strong></p>\n<p>1）数组便于查询和修改，但是不方便新增和删除</p>\n<p>2）链表适合新增和删除，但是不适合查询，根据业务情况使用合适的数据结构和算法是在大数据量和高并发时必须要考虑的问题</p>\n<p></p>\n<h3 id=\"9%E3%80%81%23define%E5%AE%8F%E5%AE%9A%E4%B9%89%E4%B8%8Etypedef%E7%9A%84%E5%8C%BA%E5%88%AB\">9、#define宏定义与typedef的区别</h3>\n<p><strong># define宏定义是字符替换，typedef是定义类型，是声明一种新的类型，等同自带的基本类型。</strong></p>\n<ul><li> <p>#define是宏，处理的时候位于编译前阶段，宏处理器基本上对你的C/C++程序不会有任何的感知。它只处理宏的语法。而编译阶段的“程序”得到的是宏处理完的结果。</p> </li><li> <p>typedef是编译阶段的一部分。它的意义是单一的。</p> </li></ul>\n<p><strong>宏定义只是简单的字符串代换，是在预处理完成的，而typedef是在编译时处理的，它不是作简单的代换，而是对类型说明符进行重新命令。被命名的标识符具有类型定义说明的功能。</strong></p>\n<pre></pre>\n<pre><code> #include&lt;stdio.h&gt;\n #include&lt;iostream&gt;\n #define PIN1 char*\n typedef char* PIN2;\n ​\n int main() {\n     //使用#define相当于：char* x, y;就是说x是char指针类型，而y是char类型\n     PIN1 x, y;\n     //使用typedef相当于：char* x, char* y;就是说x是char指针类型，而y也是char指针类型\n     PIN2 a, b;\n     printf(\"By #define ：%d  %d\\n\\n\", sizeof(x), sizeof(y));\n     printf(\"By typedef ：%d  %d\\n\\n\", sizeof(a), sizeof(b));\n     system(\"pause\");\n     return 0;\n}</code></pre>\n<p></p>\n</div>\n</div>"}