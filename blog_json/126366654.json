{"blogid": "126366654", "writerAge": "码龄1年", "writerBlogNum": "65", "writerCollect": "4806", "writerComment": "7286", "writerFan": "10057", "writerGrade": "7级", "writerIntegral": "13228", "writerName": "陈橘又青", "writerProfileAdress": "writer_image\\profile_126366654.jpg", "writerRankTotal": "833", "writerRankWeekly": "6", "writerThumb": "5008", "writerVisitNum": "366052", "blog_read_count": "353", "blog_time": "于 2022-08-17 21:02:47 发布", "blog_title": "【刷题记录15】Java工程师丨腾讯面试真题（3）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<blockquote>\n<p><strong>题目地址：</strong></p>\n<blockquote>\n<p><strong> 传送门</strong>： <a href=\"https://www.nowcoder.com/link/pc_csdncpt_qing_java\" title=\"牛客网 - 找工作神器|笔试题库|面试经验|实习招聘内推，求职就业一站解决_牛客网\">牛客网 - 找工作神器|笔试题库|面试经验|实习招聘内推，求职就业一站解决_牛客网</a></p>\n</blockquote>\n<hr/>\n</blockquote>\n<p><strong>Java面试练习题刷题记录</strong></p>\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E4%B8%80%E3%80%81%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%B7%B3%E8%B7%83%E9%97%AE%E9%A2%98-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%80%E3%80%81%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%B7%B3%E8%B7%83%E9%97%AE%E9%A2%98\">一、机器人跳跃问题</a></p>\n<p id=\"%E4%BA%8C%E3%80%81%E5%AD%97%E5%85%B8%E5%BA%8F-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BA%8C%E3%80%81%E5%AD%97%E5%85%B8%E5%BA%8F\">二、字典序</a></p>\n<p id=\"%E4%B8%89%E3%80%81%E5%BC%82%E6%88%96-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%89%E3%80%81%E5%BC%82%E6%88%96\">三、异或</a></p>\n<p id=\"%E5%9B%9B%E3%80%81%E6%89%BE%E9%9B%B6-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%9B%9B%E3%80%81%E6%89%BE%E9%9B%B6\">四、找零</a></p>\n<p id=\"%E4%BA%94%E3%80%81%E6%80%BB%E7%BB%93-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BA%94%E3%80%81%E6%80%BB%E7%BB%93\">五、总结</a></p>\n<hr id=\"hr-toc\"/>\n<h1 id=\"%E4%B8%80%E3%80%81%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%B7%B3%E8%B7%83%E9%97%AE%E9%A2%98\">一、机器人跳跃问题</h1>\n<h2 id=\"%E6%8F%8F%E8%BF%B0\">描述</h2>\n<p>机器人正在玩一个古老的基于DOS的游戏。游戏中有N+1座建筑——从0到N编号，从左到右排列。编号为0的建筑高度为0个单位，编号为i的建筑的高度为H(i)个单位。</p>\n<p>起初， 机器人在编号为0的建筑处。每一步，它跳到下一个（右边）建筑。假设机器人在第k个建筑，且它现在的能量值是E, 下一步它将跳到第个k+1建筑。它将会得到或者失去正比于与H(k+1)与E之差的能量。如果 H(k+1) &gt; E 那么机器人就失去 H(k+1) - E 的能量值，否则它将得到 E - H(k+1) 的能量值。</p>\n<p>游戏目标是到达第个N建筑，在这个过程中，能量值不能为负数个单位。现在的问题是机器人以多少能量值开始游戏，才可以保证成功完成游戏？</p>\n<h3 id=\"%E8%BE%93%E5%85%A5%E6%8F%8F%E8%BF%B0%EF%BC%9A\">输入描述：</h3>\n<p>第一行输入，表示一共有 N 组数据.<br/> 第二个是 N 个空格分隔的整数，H1, H2, H3, ..., Hn 代表建筑物的高度</p>\n<h3 id=\"%E8%BE%93%E5%87%BA%E6%8F%8F%E8%BF%B0%EF%BC%9A\">输出描述：</h3>\n<p>输出一个单独的数表示完成游戏所需的最少单位的初始能量</p>\n<blockquote>\n<h2 id=\"%E7%A4%BA%E4%BE%8B1\">示例1</h2>\n<p>输入：</p>\n<pre>5\n3 4 3 2 4</pre>\n<p>输出：</p>\n<pre>4</pre>\n<h2 id=\"%E7%A4%BA%E4%BE%8B2\">示例2</h2>\n<p>输入：</p>\n<pre>3\n4 4 4</pre>\n<p>输出：</p>\n<pre>4</pre>\n<h2 id=\"%E7%A4%BA%E4%BE%8B3\">示例3</h2>\n<p>输入：</p>\n<pre>3\n1 6 4</pre>\n<p>输出：</p>\n<pre>3</pre>\n</blockquote>\n<h2 id=\"%E5%A4%87%E6%B3%A8%EF%BC%9A\">备注：</h2>\n<p><strong>数据约束：</strong></p>\n<p>1 &lt;= N &lt;= 10^5</p>\n<p>1 &lt;= H(i) &lt;= 10^5</p>\n<p>题解：</p>\n<pre><code>import java.util.Scanner;\nimport java.util.*;\n\n\n\npublic class Main{\n\n\n    public static void main(String[] args) {\n\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n\n        double res = 0;\n        for(int i=1;i&lt;=N;i++){\n            res += sc.nextInt()*Math.pow(2, N - i);\n        }\n        System.out.println((int)Math.ceil(res/Math.pow(2, N)));\n    }\n\n\n\n}\n</code></pre>\n<h1 id=\"%E4%BA%8C%E3%80%81%E5%AD%97%E5%85%B8%E5%BA%8F\">二、字典序</h1>\n<h2>描述</h2>\n<p>给定整数n和m, 将1到n的这n个整数按字典序排列之后, 求其中的第m个数。<br/> 对于n=11, m=4, 按字典序排列依次为1, 10, 11, 2, 3, 4, 5, 6, 7, 8, 9, 因此第4个数是2.<br/> 对于n=200, m=25, 按字典序排列依次为1 10 100 101 102 103 104 105 106 107 108 109 11 110 111 112 113 114 115 116 117 118 119 12 120 121 122 123 124 125 126 127 128 129 13 130 131 132 133 134 135 136 137 138 139 14 140 141 142 143 144 145 146 147 148 149 15 150 151 152 153 154 155 156 157 158 159 16 160 161 162 163 164 165 166 167 168 169 17 170 171 172 173 174 175 176 177 178 179 18 180 181 182 183 184 185 186 187 188 189 19 190 191 192 193 194 195 196 197 198 199 2 20 200 21 22 23 24 25 26 27 28 29 3 30 31 32 33 34 35 36 37 38 39 4 40 41 42 43 44 45 46 47 48 49 5 50 51 52 53 54 55 56 57 58 59 6 60 61 62 63 64 65 66 67 68 69 7 70 71 72 73 74 75 76 77 78 79 8 80 81 82 83 84 85 86 87 88 89 9 90 91 92 93 94 95 96 97 98 99 因此第25个数是120…</p>\n<h3>输入描述：</h3>\n<p>输入仅包含两个整数n和m。<br/> 数据范围:<br/> 对于20%的数据, 1 &lt;= m &lt;= n &lt;= 5 ;<br/> 对于80%的数据, 1 &lt;= m &lt;= n &lt;= 10^7 ;<br/> 对于100%的数据, 1 &lt;= m &lt;= n &lt;= 10^18.</p>\n<h3>输出描述：</h3>\n<p>输出仅包括一行, 即所求排列中的第m个数字.</p>\n<blockquote>\n<h2>示例1</h2>\n<p>输入：</p>\n<pre>11 4\n</pre>\n<p>输出：</p>\n<pre>2\n</pre>\n</blockquote>\n<p>题解：</p>\n<pre><code>import java.util.Scanner;\n\nclass DictOrder {\n    public long solve(long n,long m){\n        //start with subtree which started with 1\n        long ans = 1;\n        while (m!=0){\n            long cnt = getCountWithPre(ans,n);\n            if(cnt&gt;=m){\n                // go to subtree\n                m --;\n                if(m==0)\n                    break;\n                ans *= 10;//go to subtree with \"ans+ 0\"\n            }else {\n                m-=cnt;\n                ans+=1;// goto brother tree\n            }\n        }\n        return ans;\n    }\n\n    public long getCountWithPre(long pre, long n){\n        /*\n        * get count of tree node which start with pre\n        * return count: count of tree node with pre\n        * */\n        long cnt = 1;\n        long p=10;\n        for(; pre * p &lt;= n; p*=10){\n            //the max of this subtree not bigger than n\n            if(pre*p+p-1&lt;n)\n            cnt+=p;\n            else {\n                cnt += n-p*pre+1;// n is include\n            }\n        }\n        return cnt;\n    }\n}\npublic class Main{\n    public static void main(String[] args) {\n        DictOrder dictOrder = new DictOrder();\n        Scanner sc = new Scanner(System.in);\n        while (sc.hasNext())\n        {\n            long n = sc.nextLong();\n            long m = sc.nextLong();\n            System.out.println(dictOrder.solve(n,m));\n        }\n    }\n}\n</code></pre>\n<h1 id=\"%E4%B8%89%E3%80%81%E5%BC%82%E6%88%96\">三、异或</h1>\n<h2>描述</h2>\n<p>给定整数m以及n各数字A1,A2,..An，将数列A中所有元素两两异或，共能得到n(n-1)/2个结果，请求出这些结果中大于m的有多少个。</p>\n<h3>输入描述：</h3>\n<p>第一行包含两个整数n,m.<br/> 第二行给出n个整数A1，A2，...，An。<br/> 数据范围<br/> 对于30%的数据，1 &lt;= n, m &lt;= 1000<br/> 对于100%的数据，1 &lt;= n, m, Ai &lt;= 10^5</p>\n<h3>输出描述：</h3>\n<p>输出仅包括一行，即所求的答案</p>\n<blockquote>\n<h2>示例1</h2>\n<p>输入：</p>\n<pre>3 10  \n6 5 10\n</pre>\n<p>输出：</p>\n<pre>2\n</pre>\n</blockquote>\n<p>题解：</p>\n<pre><code>import java.util.Scanner;\n\npublic class Main {\n    private static class TrieTree {\n        TrieTree[] next = new TrieTree[2];\n        int count = 1;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        while (sc.hasNext()){\n            int n = sc.nextInt();\n            int m = sc.nextInt();\n            int[] a = new int[n];\n            for (int i = 0; i &lt; n; i++) {\n                a[i] = sc.nextInt();\n            }\n            System.out.println(solve(a, m));\n        }\n    }\n\n    private static long solve(int[] a, int m) {\n        TrieTree trieTree = buildTrieTree(a);\n        long result = 0;\n        for (int i = 0; i &lt; a.length; i++) {\n            result += queryTrieTree(trieTree, a[i], m, 31);\n        }\n        return result / 2;\n    }\n\n    private static long queryTrieTree(TrieTree trieTree, int a, int m, int index) {\n        if(trieTree == null)\n            return 0;\n\n        TrieTree current = trieTree;\n        for (int i = index; i &gt;= 0; i--) {\n            int aDigit = (a &gt;&gt; i) &amp; 1;\n            int mDigit = (m &gt;&gt; i) &amp; 1;\n            if(aDigit == 1 &amp;&amp; mDigit == 1) {\n                if(current.next[0] == null)\n                    return 0;\n                current = current.next[0];\n            } else if (aDigit == 0 &amp;&amp; mDigit == 1) {\n                if(current.next[1] == null)\n                    return 0;\n                current = current.next[1];\n            } else if (aDigit == 1 &amp;&amp; mDigit == 0) {\n                long p = queryTrieTree(current.next[1], a, m, i - 1);\n                long q = current.next[0] == null ? 0 : current.next[0].count;\n                return p + q;\n            } else if (aDigit == 0 &amp;&amp; mDigit == 0) {\n                long p = queryTrieTree(current.next[0], a, m, i - 1);\n                long q = current.next[1] == null ? 0 : current.next[1].count;\n                return p + q;\n            }\n        }\n        return 0;\n    }\n\n    private static TrieTree buildTrieTree(int[] a) {\n        TrieTree trieTree = new TrieTree();\n        for (int i = 0; i &lt; a.length; i++) {\n            TrieTree current = trieTree;\n            for (int j = 31; j &gt;= 0; j--) {\n                int digit = (a[i] &gt;&gt; j) &amp; 1;\n                if(current.next[digit] == null) {\n                    current.next[digit] = new TrieTree();\n                } else {\n                    current.next[digit].count ++;\n                }\n                current = current.next[digit];\n            }\n        }\n        return trieTree;\n    }\n}</code></pre>\n<h1 id=\"%E5%9B%9B%E3%80%81%E6%89%BE%E9%9B%B6\">四、找零</h1>\n<h2>描述</h2>\n<p>Z国的货币系统包含面值1元、4元、16元、64元共计4种硬币，以及面值1024元的纸币。现在小Y使用1024元的纸币购买了一件价值为N(0&lt;N≤1024)N (0 &lt; N \\le 1024)N(0&lt;N≤1024)的商品，请问最少他会收到多少硬币？</p>\n<h3>输入描述：</h3>\n<p>一行，包含一个数N。</p>\n<h3>输出描述：</h3>\n<p>一行，包含一个数，表示最少收到的硬币数。</p>\n<blockquote>\n<h2>示例1</h2>\n<p>输入：</p>\n<pre>200</pre>\n<p>输出：</p>\n<pre>17</pre>\n<p>说明：</p>\n<pre>花200，需要找零824块，找12个64元硬币，3个16元硬币，2个4元硬币即可。</pre>\n</blockquote>\n<h2>备注：</h2>\n<pre>对于100%的数据，N(0&lt;N≤1024)N (0 &lt; N \\le 1024)N(0&lt;N≤1024)。</pre>\n<p>题解：</p>\n<pre><code>import java.util.Scanner; //java.util为包名，Scanner为类名\n\npublic class Main\n{\n\tpublic static void main(String[] args) // 切莫少了传入参数\n\t{\n\t\tScanner input = new Scanner( System.in ); //使用前先导入Scanner类\n        int N = input.nextInt(); //next() 为方法\n        input.close();\n        int Z = 1024-N;\n        int n64 = Z/64;\n        int S = Z-64*n64; // *不能少，和数学里的带分数的单项式不同\n        int n16 = S/16;\n        S = S-16*n16; //切莫重复定义，应用之前剩下的来减\n        int n4 = S/4;\n        S = S-4*n4;\n        int NS = n64+n16+n4+S;\n        System.out.println( NS ); //输出语句切莫和C语言搞混\n\t}\n}</code></pre>\n<hr/>\n<h1 id=\"%E4%BA%94%E3%80%81%E6%80%BB%E7%BB%93\">五、总结</h1>\n<p><strong>我几乎每天都会在<a class=\"link-info\" href=\"https://www.nowcoder.com/link/pc_csdncpt_qing_java\" title=\"【牛客网】\">【牛客网】</a></strong><strong>刷题训练来使自己对各种算法随时保持一个清晰的状态。要知道<u>眼过千遍不如手过一遍</u></strong><strong>，想成为一名合格的开发工程师，更要逼迫自己养成动手的好习惯。</strong></p>\n<p><strong>相较于其他平台，<a class=\"link-info\" href=\"https://www.nowcoder.com/link/pc_csdncpt_qing_java\" title=\"牛客\">牛客</a> 的题目更面向工作，不光有“面试必刷101道”，还有海量大厂真题，内容全程免费，非常的友好。</strong> </p>\n<p><img alt=\"\" height=\"428\" src=\"image\\2fd2e12585a144bab58b23b1cb7ee5e5.png\" width=\"560\"/></p>\n<p></p>\n<blockquote>\n<p>牛客网还支持<strong>ACM模式</strong>，没有练习过的一定要提前适应！像某团、某为，都要求自己处理输入输出，如果不提前练习会很吃亏的！</p>\n<p>牛客的题解更新迭代也很快，讨论区也有技巧的分享，能帮你把所有盲点扫清楚，整体来说还是非常推荐去练习的~</p>\n<p><strong>传送门</strong>： <a href=\"https://www.nowcoder.com/link/pc_csdncpt_qing_java\" title=\"牛客网 - 找工作神器|笔试题库|面试经验|实习招聘内推，求职就业一站解决_牛客网\">牛客网 - 找工作神器|笔试题库|面试经验|实习招聘内推，求职就业一站解决_牛客网</a></p>\n</blockquote>\n<hr/>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\ee7ed110c27643ddb9f6a044db5f3dec.jpeg\"/></p>\n<p></p>\n</div>\n</div>"}