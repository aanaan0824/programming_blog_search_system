{"blogid": "126685307", "writerAge": "码龄15年", "writerBlogNum": "452", "writerCollect": "5630", "writerComment": "2679", "writerFan": "24806", "writerGrade": "7级", "writerIntegral": "16479", "writerName": "Hann Yang", "writerProfileAdress": "writer_image\\profile_126685307.jpg", "writerRankTotal": "550", "writerRankWeekly": "199", "writerThumb": "5948", "writerVisitNum": "644415", "blog_read_count": "296", "blog_time": "已于 2022-09-05 16:21:43 修改", "blog_title": "go语言｜数据结构：二叉树可视化（制作svg格式树形图）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\5c5c77badfc044529e5618243a0d01c4.png\"/></p>\n<p>最近一直在刷二叉树题目，但在要验证结果时，通常用中序遍历、层序遍历查看结果，验证起来没有画图来得直观，所有想到自己动手制作二叉树的树形图。 直接开干，先从svg入手：</p>\n<h2>什么是SVG？</h2>\n<h3>SVG定义</h3>\n<p>SVG是可伸缩矢量图形 (Scalable Vector Graphics)，于2003年1月14日成为 W3C 推荐标准。</p>\n<p>SVG 用来定义用于网络的基于矢量的图形<br/> SVG 使用 XML 格式定义图形<br/> SVG 是万维网联盟的标准<br/> SVG 与诸如 DOM 和 XSL 之类的 W3C 标准是一个整体</p>\n<h3>SVG优点</h3>\n<p>SVG 可被非常多的工具读取和修改（比如记事本）<br/> SVG 与 JPEG 和 GIF 图像比起来，尺寸更小，且可压缩性更强。<br/> SVG 图像在放大或改变尺寸的情况下其图形质量不会有所损失<br/> SVG 图像可在任何的分辨率下被高质量地打印<br/> SVG 图像中的文本是可选的，同时也是可搜索的（很适合制作地图）<br/> SVG 可以与 JavaScript 技术一起运行<br/> SVG 是开放的标准<br/> SVG 文件是纯粹的 XML</p>\n<h3>预定义元素</h3>\n<p>矩形 &lt;rect&gt;<br/> 圆形 &lt;circle&gt;<br/> 椭圆 &lt;ellipse&gt;<br/> 直线 &lt;line&gt;<br/> 文字 &lt;text&gt;<br/> 路径 &lt;path&gt;<br/> 折线 &lt;polyline&gt;<br/> 多边形 &lt;polygon&gt;<br/> ... more ... </p>\n<p><img alt=\"\" src=\"image\\2f3933abc3524e66a7607b5f99ec9eed.png\"/></p>\n<p>制作二叉树的树形图，就使用圆形、直线、文字三种元素即可：</p>\n<h3>圆形 &lt;circle&gt;</h3>\n<pre><code class=\"language-XML\">&lt;svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\"&gt;\n  &lt;circle cx=\"150\" cy=\"50\" r=\"30\" stroke=\"black\" stroke-width=\"2\" fill=\"orange\"/&gt;\n&lt;/svg&gt;</code></pre>\n<p> cx和cy属性定义圆点的x和y坐标；r属性定义圆的半径<br/> 如果省略cx和cy，圆的中心会被设置为(0, 0)</p>\n<h3>直线 &lt;line&gt;</h3>\n<pre><code class=\"language-XML\">&lt;svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\"&gt;\n  &lt;line x1=\"50\" y1=\"50\" x2=\"200\" y2=\"200\" style=\"stroke:red;stroke-width:2\"/&gt;\n&lt;/svg&gt;</code></pre>\n<p>x1，y1，x2，y2 属性定义线条的直线两端点的坐标</p>\n<h3>文字 &lt;text&gt;</h3>\n<pre><code class=\"language-XML\">&lt;svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\"&gt;\n  &lt;text x=\"30\" y=\"150\" fill=\"red\"&gt;Welcome to Hann's HomePage&lt;/text&gt;\n&lt;/svg&gt;</code></pre>\n<p>x，y 属性定义文字左对齐显示时的起始坐标（居中对齐则是文字中间点）<br/> fill 属性定义文字的颜色</p>\n<p><img alt=\"\" src=\"image\\457bbc1292264f938afb3d6efa96fcf6.png\"/></p>\n<h2>结点SVG格式</h2>\n<h3>根结点</h3>\n<p>由&lt;circle&gt;和&lt;text&gt;组成，存放结点的数据域</p>\n<pre><code class=\"language-XML\">\t&lt;g id=\"0,0\"&gt;\n\t&lt;circle cx=\"400\" cy=\"50\" r=\"30\" stroke=\"black\" stroke-width=\"2\" fill=\"orange\" /&gt;\n\t&lt;text x=\"400\" y=\"50\" fill=\"red\" font-size=\"20\" text-anchor=\"middle\" dominant-baseline=\"middle\"&gt;1&lt;/text&gt;\n\t&lt;/g&gt;</code></pre>\n<h3>子树结点</h3>\n<p>比根结点多出&lt;line&gt;元素，用来表示父结点左或右指针的指向</p>\n<pre><code class=\"language-XML\">\t&lt;g id=\"1,0\"&gt;\n\t&lt;circle cx=\"200\" cy=\"170\" r=\"30\" stroke=\"black\" stroke-width=\"2\" fill=\"orange\" /&gt;\n\t&lt;text x=\"200\" y=\"170\" fill=\"red\" font-size=\"20\" text-anchor=\"middle\" dominant-baseline=\"middle\"&gt;2&lt;/text&gt;\n\t&lt;line x1=\"200\" y1=\"140\" x2=\"379\" y2=\"71\" style=\"stroke:black;stroke-width:2\"/&gt;\n\t&lt;/g&gt;</code></pre>\n<h3>叶结点</h3>\n<p>与子树结点相同，为区别显示把&lt;circle&gt;填充色改为greenlight</p>\n<pre><code class=\"language-XML\">\t&lt;g id=\"1,1\"&gt;\n\t&lt;circle cx=\"600\" cy=\"170\" r=\"30\" stroke=\"black\" stroke-width=\"2\" fill=\"lightgreen\" /&gt;\n\t&lt;text x=\"600\" y=\"170\" fill=\"red\" font-size=\"20\" text-anchor=\"middle\" dominant-baseline=\"middle\"&gt;3&lt;/text&gt;\n\t&lt;line x1=\"600\" y1=\"140\" x2=\"421\" y2=\"71\" style=\"stroke:black;stroke-width:2\"/&gt;\n\t&lt;/g&gt;</code></pre>\n<hr/>\n<h2>结点坐标</h2>\n<h3>坐标的确定</h3>\n<p>结点坐标确定，把二叉树还原成满二叉树，结点位置标记为：</p>\n<p>[ [0,0], [1,0], [1,1], [2,0], [2,1], [2,2], [2,3], [3,0]......]，再用循环计算出各点坐标。</p>\n<h3>连线的夹角</h3>\n<p>实际上不用考虑连线夹角，只要计算出连线始终两端点的坐标即可：</p>\n<p><img alt=\"\" height=\"871\" src=\"image\\5700e35f82604061ac370e5830f05d97.png\" width=\"1200\"/></p>\n<h2>结点文本</h2>\n<p>以字符串形式保存好属性变量的特征关键词，用于遍历二叉树时替换成实际数据：</p>\n<pre><code class=\"language-Go\">func XmlNode(M, N, X, Y int, Data string, Color ...string) string {\n\tvar cColor, tColor string\n\tR := 30\n\tNode := `&lt;Tab&gt;&lt;g id=\"M,N\"&gt;\n\t&lt;circle cx=\"X\" cy=\"Y\" r=\"RC\" stroke=\"black\" stroke-width=\"2\" fill=\"COLOR\" /&gt;\n\t&lt;text x=\"X\" y=\"Y\" fill=\"TextColor\" font-size=\"20\" text-anchor=\"middle\"\n\t\tdominant-baseline=\"middle\"&gt;DATA&lt;/text&gt;\n\t&lt;ROOT/&gt;\n\t&lt;/g&gt;&lt;CrLf&gt;`\n\tif len(Color) == 0 {\n\t\tcColor, tColor = \"orange\", \"red\" //分别圆形背景色，文字颜色\n\t} else if len(Color) == 1 {\n\t\tcColor, tColor = Color[0], \"red\"\n\t} else {\n\t\tcColor, tColor = Color[0], Color[1]\n\t}\n\tNode = strings.Replace(Node, \"M\", strconv.Itoa(M), 1)\n\tNode = strings.Replace(Node, \"N\", strconv.Itoa(N), 1)\n\tNode = strings.Replace(Node, \"X\", strconv.Itoa(X), 2)\n\tNode = strings.Replace(Node, \"Y\", strconv.Itoa(Y), 2)\n\tNode = strings.Replace(Node, \"RC\", strconv.Itoa(R), 1)\n\tNode = strings.Replace(Node, \"DATA\", Data, 1)\n\tNode = strings.Replace(Node, \"COLOR\", cColor, 1)\n\tNode = strings.Replace(Node, \"TextColor\", tColor, 1)\n\tNode = strings.Replace(Node, \"&lt;CrLf&gt;\", \"\\n\", -1)\n\tNode = strings.Replace(Node, \"&lt;Tab&gt;\", \"\\t\", -1)\n\tNode = strings.Replace(Node, \"\\n\\t\\t\", \" \", -1)\n\treturn Node\n}</code></pre>\n<h2>二叉树转SVG</h2>\n<p>遍历二叉树对应的满二叉树，读出数据域并计算坐标，转成svg格式：</p>\n<h3>二叉树转svg</h3>\n<pre><code class=\"language-Go\">func (bt *biTree) Xml4Tree() string {\n\tvar Xml, Node string\n\tHead := \"&lt;svg xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/\" +\n\t\t\"1999/xlink\\\" version=\\\"1.1\\\" width=\\\"Width\\\" height=\\\"Height\\\"&gt;\\nCONTENT&lt;/svg&gt;\"\n\tLine := `&lt;line x1=\"X1\" y1=\"Y1\" x2=\"X2\" y2=\"Y2\" style=\"stroke:black;stroke-width:2\"/&gt;`\n\tLink := `&lt;a xlink:href=\"https://blog.csdn.net/boysoft2002\" target=\"_blank\"&gt;\n\t&lt;text x=\"5\" y=\"20\" fill=\"blue\"&gt;Hann's CSDN Homepage&lt;/text&gt;&lt;/a&gt;`\n\tList := bt.LevelNullwith()\n\tLevels := len(List)\n\tfor i := Levels - 1; i &gt;= 0; i-- {\n\t\tnegative := -1\n\t\tTmpXml := \"\"\n\t\tfor j := 0; j &lt; Pow2(i); j++ {\n\t\t\tt := Pow2(Levels - i - 1)\n\t\t\tx, y := 50*(2*t*j+t), 120*i+50\n\t\t\tif List[i][j] != nil {\n\t\t\t\tfillColor := \"orange\"\n\t\t\t\tif i == Levels-1 || i &gt; 0 &amp;&amp; i &lt; Levels-1 &amp;&amp;\n\t\t\t\t\tList[i+1][j*2] == nil &amp;&amp; List[i+1][j*2+1] == nil {\n\t\t\t\t\tfillColor = \"lightgreen\"\n\t\t\t\t}\n\t\t\t\tTmpStr := \"\"\n\t\t\t\tswitch List[i][j].(type) {\n\t\t\t\tcase int:\n\t\t\t\t\tTmpStr = strconv.Itoa(List[i][j].(int))\n\t\t\t\tcase float64:\n\t\t\t\t\tTmpStr = strconv.FormatFloat(List[i][j].(float64), 'g', -1, 64)\n\t\t\t\tcase string:\n\t\t\t\t\tTmpStr = List[i][j].(string)\n\t\t\t\tdefault:\n\t\t\t\t\tTmpStr = \"Error Type\"\n\t\t\t\t}\n\t\t\t\tXml = XmlNode(i, j, x, y, TmpStr, fillColor)\n\t\t\t}\n\t\t\tif i &gt; 0 {\n\t\t\t\tline1 := strings.Replace(Line, \"X1\", strconv.Itoa(x), 1)\n\t\t\t\tline1 = strings.Replace(line1, \"Y1\", strconv.Itoa(y-30), 1)\n\t\t\t\tnegative *= -1\n\t\t\t\tx0, y0 := 21, 21\n\t\t\t\tx += 50*negative*(2*t*j%2+t) - negative*x0\n\t\t\t\tline1 = strings.Replace(line1, \"X2\", strconv.Itoa(x), 1)\n\t\t\t\tline1 = strings.Replace(line1, \"Y2\", strconv.Itoa(y-120+y0), 1)\n\t\t\t\tXml = strings.Replace(Xml, \"&lt;ROOT/&gt;\", line1, 1)\n\t\t\t}\n\t\t\tif List[i][j] != nil {\n\t\t\t\tTmpXml += Xml\n\t\t\t}\n\t\t}\n\t\tNode = TmpXml + Node\n\t}\n\tXml = strings.Replace(Head, \"CONTENT\", Node, 1)\n\tXml = strings.Replace(Xml, \"Width\", strconv.Itoa(Pow2(Levels)*50), 1)\n\tXml = strings.Replace(Xml, \"Height\", strconv.Itoa(Levels*120), 1)\n\tXml = strings.Replace(Xml, \"&lt;ROOT/&gt;\", Link, 1)\n\treturn Xml\n}</code></pre>\n<h3>写入文件、调取浏览</h3>\n<p>要把.svg文件的默认打开方式关联为默认浏览器，否则不显示而是提示是否要下载</p>\n<pre><code class=\"language-Go\">    //......\n\tfor index, text := range texts {\n\t\tsvgFile := \"./biTree0\" + strconv.Itoa(index+1) + \".svg\"\n\t\tfile, err1 = os.Create(svgFile)\n\t\tif err1 != nil {\n\t\t\tpanic(err1)\n\t\t}\n\t\t_, err1 = io.WriteString(file, text)\n\t\tif err1 != nil {\n\t\t\tpanic(err1)\n\t\t}\n\t\tfile.Close()\n\t\texec.Command(\"cmd\", \"/c\", \"start\", svgFile).Start()\n\t\t//Linux 代码：\n\t\t//exec.Command(\"xdg-open\", svgFile).Start()\n\t\t//Mac 代码：\n\t\t//exec.Command(\"open\", svgFile).Start()\n\t}\n    //......</code></pre>\n<h3> 满二叉树按层作图</h3>\n<pre><code class=\"language-Go\">func Xml4Full(Levels int) string {\n\tvar Xml, Node string\n\tHead := \"&lt;svg xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/\" +\n\t\t\"1999/xlink\\\" version=\\\"1.1\\\" width=\\\"Width\\\" height=\\\"Height\\\"&gt;\\nCONTENT&lt;/svg&gt;\"\n\tLine := `&lt;line x1=\"X1\" y1=\"Y1\" x2=\"X2\" y2=\"Y2\" style=\"stroke:black;stroke-width:2\"/&gt;`\n\tLink := `&lt;a xlink:href=\"https://blog.csdn.net/boysoft2002\" target=\"_blank\"&gt;\n\t&lt;text x=\"5\" y=\"20\" fill=\"blue\"&gt;Hann's CSDN Homepage&lt;/text&gt;&lt;/a&gt;`\n\tfor i := 0; i &lt; Levels; i++ {\n\t\tnegative := -1\n\t\tfor j := 0; j &lt; Pow2(i); j++ {\n\t\t\tt := Pow2(Levels - i - 1)\n\t\t\tx, y := 50*(2*t*j+t), 120*i+50\n\t\t\tif Levels != 1 &amp;&amp; i == Levels-1 {\n\t\t\t\tXml = XmlNode(i, j, x, y, strconv.Itoa(Pow2(i)+j), \"lightgreen\")\n\t\t\t} else {\n\t\t\t\tXml = XmlNode(i, j, x, y, strconv.Itoa(Pow2(i)+j))\n\t\t\t}\n\t\t\tif i &gt; 0 {\n\t\t\t\tline1 := strings.Replace(Line, \"X1\", strconv.Itoa(x), 1)\n\t\t\t\tline1 = strings.Replace(line1, \"Y1\", strconv.Itoa(y-30), 1)\n\t\t\t\tnegative *= -1\n\t\t\t\tx0, y0 := 21, 21\n\t\t\t\t//过连线起始端的半径与纵轴线夹角取45度时x,y坐标修正值21,21[30/1.414]\n\t\t\t\t//取30度时 x0,y0:= 15,30-26；取60度时 x0,y0:= 26[15*1.732],15\n\t\t\t\tx += 50*negative*(2*t*j%2+t) - negative*x0\n\t\t\t\tline1 = strings.Replace(line1, \"X2\", strconv.Itoa(x), 1)\n\t\t\t\tline1 = strings.Replace(line1, \"Y2\", strconv.Itoa(y-120+y0), 1)\n\t\t\t\tXml = strings.Replace(Xml, \"&lt;ROOT/&gt;\", line1, 1)\n\t\t\t}\n\t\t\tNode += Xml\n\t\t}\n\t}\n\tXml = strings.Replace(Head, \"CONTENT\", Node, 1)\n\tXml = strings.Replace(Xml, \"Width\", strconv.Itoa(Pow2(Levels)*50), 1)\n\tXml = strings.Replace(Xml, \"Height\", strconv.Itoa(Levels*120), 1)\n\tXml = strings.Replace(Xml, \"&lt;ROOT/&gt;\", Link, 1)\n\treturn Xml\n}</code></pre>\n<h2>全部源代码</h2>\n<p>本文所用的二叉树插图，都是用以下代码制作svg图片，然后另存png格式上传：</p>\n<pre><code class=\"language-Go\">package main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"os/exec\"\n\t\"strconv\"\n\t\"strings\"\n)\n\ntype btNode struct {\n\tData   interface{}\n\tLchild *btNode\n\tRchild *btNode\n}\n\ntype biTree struct {\n\tRoot *btNode\n}\n\nfunc Build(data interface{}) *biTree {\n\tvar list []interface{}\n\tif data == nil {\n\t\treturn &amp;biTree{}\n\t}\n\tswitch data.(type) {\n\tcase []interface{}:\n\t\tlist = append(list, data.([]interface{})...)\n\tdefault:\n\t\tlist = append(list, data)\n\t}\n\tif len(list) == 0 {\n\t\treturn &amp;biTree{}\n\t}\n\tnode := &amp;btNode{Data: list[0]}\n\tlist = list[1:]\n\tQueue := []*btNode{node}\n\tfor len(list) &gt; 0 {\n\t\tif len(Queue) == 0 {\n\t\t\t//panic(\"Given array can not build binary tree.\")\n\t\t\treturn &amp;biTree{Root: node}\n\t\t}\n\t\tcur := Queue[0]\n\t\tval := list[0]\n\t\tQueue = Queue[1:]\n\t\tif val != nil {\n\t\t\tcur.Lchild = &amp;btNode{Data: val}\n\t\t\tif cur.Lchild != nil {\n\t\t\t\tQueue = append(Queue, cur.Lchild)\n\t\t\t}\n\t\t}\n\t\tlist = list[1:]\n\t\tif len(list) &gt; 0 {\n\t\t\tval := list[0]\n\t\t\tif val != nil {\n\t\t\t\tcur.Rchild = &amp;btNode{Data: val}\n\t\t\t\tif cur.Rchild != nil {\n\t\t\t\t\tQueue = append(Queue, cur.Rchild)\n\t\t\t\t}\n\t\t\t}\n\t\t\tlist = list[1:]\n\t\t}\n\t}\n\treturn &amp;biTree{Root: node}\n}\n\nfunc (bt *biTree) AppendNode(data interface{}) {\n\troot := bt.Root\n\tif root == nil {\n\t\tbt.Root = &amp;btNode{Data: data}\n\t\treturn\n\t}\n\tQueue := []*btNode{root}\n\tfor len(Queue) &gt; 0 {\n\t\tcur := Queue[0]\n\t\tQueue = Queue[1:]\n\t\tif cur.Lchild != nil {\n\t\t\tQueue = append(Queue, cur.Lchild)\n\t\t} else {\n\t\t\tcur.Lchild = &amp;btNode{Data: data}\n\t\t\treturn\n\t\t}\n\t\tif cur.Rchild != nil {\n\t\t\tQueue = append(Queue, cur.Rchild)\n\t\t} else {\n\t\t\tcur.Rchild = &amp;btNode{Data: data}\n\t\t\tbreak\n\t\t}\n\t}\n}\n\nfunc Copy(bt *biTree) *biTree {\n\troot := bt.Root\n\tif root == nil {\n\t\treturn &amp;biTree{}\n\t}\n\tnode := &amp;btNode{Data: root.Data}\n\tQueue1, Queue2 := []*btNode{root}, []*btNode{node}\n\tfor len(Queue1) &gt; 0 {\n\t\tp1, p2 := Queue1[0], Queue2[0]\n\t\tQueue1, Queue2 = Queue1[1:], Queue2[1:]\n\t\tif p1.Lchild != nil {\n\t\t\tNode := &amp;btNode{Data: p1.Lchild.Data}\n\t\t\tp2.Lchild = Node\n\t\t\tQueue1 = append(Queue1, p1.Lchild)\n\t\t\tQueue2 = append(Queue2, Node)\n\t\t}\n\t\tif p1.Rchild != nil {\n\t\t\tNode := &amp;btNode{Data: p1.Rchild.Data}\n\t\t\tp2.Rchild = Node\n\t\t\tQueue1 = append(Queue1, p1.Rchild)\n\t\t\tQueue2 = append(Queue2, Node)\n\t\t}\n\t}\n\treturn &amp;biTree{Root: node}\n}\n\nfunc Mirror(bt *biTree) *biTree {\n\troot := bt.Root\n\tif root == nil {\n\t\treturn &amp;biTree{}\n\t}\n\tnode := &amp;btNode{Data: root.Data}\n\tQueue1, Queue2 := []*btNode{root}, []*btNode{node}\n\tfor len(Queue1) &gt; 0 {\n\t\tp1, p2 := Queue1[0], Queue2[0]\n\t\tQueue1, Queue2 = Queue1[1:], Queue2[1:]\n\t\tif p1.Lchild != nil {\n\t\t\tNode := &amp;btNode{Data: p1.Lchild.Data}\n\t\t\tp2.Rchild = Node\n\t\t\tQueue1 = append(Queue1, p1.Lchild)\n\t\t\tQueue2 = append(Queue2, Node)\n\t\t}\n\t\tif p1.Rchild != nil {\n\t\t\tNode := &amp;btNode{Data: p1.Rchild.Data}\n\t\t\tp2.Lchild = Node\n\t\t\tQueue1 = append(Queue1, p1.Rchild)\n\t\t\tQueue2 = append(Queue2, Node)\n\t\t}\n\t}\n\treturn &amp;biTree{Root: node}\n}\n\nfunc (bt *biTree) BForder2D() [][]interface{} {\n\tvar res [][]interface{}\n\troot := bt.Root\n\tif root == nil {\n\t\treturn res\n\t}\n\tQueue := []*btNode{root}\n\tfor len(Queue) &gt; 0 {\n\t\tNodes := []interface{}{}\n\t\tLevels := len(Queue)\n\t\tfor Levels &gt; 0 {\n\t\t\tcur := Queue[0]\n\t\t\tQueue = Queue[1:]\n\t\t\tNodes = append(Nodes, cur.Data)\n\t\t\tLevels--\n\t\t\tif cur.Lchild != nil {\n\t\t\t\tQueue = append(Queue, cur.Lchild)\n\t\t\t}\n\t\t\tif cur.Rchild != nil {\n\t\t\t\tQueue = append(Queue, cur.Rchild)\n\t\t\t}\n\t\t}\n\t\tres = append(res, Nodes)\n\t}\n\treturn res\n}\n\nfunc (bt *biTree) LevelNullwith(Fills ...interface{}) [][]interface{} {\n\tvar Nodes [][]interface{}\n\tvar Fill0 interface{}\n\tif len(Fills) == 0 {\n\t\tFill0 = nil\n\t} else if len(Fills) == 1 {\n\t\tFill0 = Fills[0]\n\t} else {\n\t\tpanic(\"Error: number of parameters is greater than 1\")\n\t}\n\troot := bt.Root\n\tif root == nil {\n\t\treturn Nodes\n\t}\n\tCount := 0\n\tQueue := []*btNode{root}\n\tfor len(Queue) &gt; 0 {\n\t\tnodes := []interface{}{}\n\t\tLevel := len(Queue)\n\t\tfor Level &gt; 0 {\n\t\t\tcur := Queue[0]\n\t\t\tQueue = Queue[1:]\n\t\t\tnodes = append(nodes, cur.Data)\n\t\t\tCount++\n\t\t\tLevel--\n\t\t\tif cur.Lchild != nil {\n\t\t\t\tQueue = append(Queue, cur.Lchild)\n\t\t\t}\n\t\t\tif cur.Rchild != nil {\n\t\t\t\tQueue = append(Queue, cur.Rchild)\n\t\t\t}\n\t\t}\n\t\tNodes = append(Nodes, nodes)\n\t}\n\tnewbiTree := Copy(bt)\n\tfor i := 1; i &lt; Pow2(len(Nodes))-Count; i++ {\n\t\tnewbiTree.AppendNode(Fill0)\n\t}\n\treturn newbiTree.BForder2D()\n}\n\nfunc XmlNode(M, N, X, Y int, Data string, Color ...string) string {\n\tvar cColor, tColor string\n\tR := 30\n\tNode := `&lt;Tab&gt;&lt;g id=\"M,N\"&gt;\n\t&lt;circle cx=\"X\" cy=\"Y\" r=\"RC\" stroke=\"black\" stroke-width=\"2\" fill=\"COLOR\" /&gt;\n\t&lt;text x=\"X\" y=\"Y\" fill=\"TextColor\" font-size=\"20\" text-anchor=\"middle\"\n\t\tdominant-baseline=\"middle\"&gt;DATA&lt;/text&gt;\n\t&lt;ROOT/&gt;\n\t&lt;/g&gt;&lt;CrLf&gt;`\n\tif len(Color) == 0 {\n\t\tcColor, tColor = \"orange\", \"red\"\n\t} else if len(Color) == 1 {\n\t\tcColor, tColor = Color[0], \"red\"\n\t} else {\n\t\tcColor, tColor = Color[0], Color[1]\n\t}\n\tNode = strings.Replace(Node, \"M\", strconv.Itoa(M), 1)\n\tNode = strings.Replace(Node, \"N\", strconv.Itoa(N), 1)\n\tNode = strings.Replace(Node, \"X\", strconv.Itoa(X), 2)\n\tNode = strings.Replace(Node, \"Y\", strconv.Itoa(Y), 2)\n\tNode = strings.Replace(Node, \"RC\", strconv.Itoa(R), 1)\n\tNode = strings.Replace(Node, \"DATA\", Data, 1)\n\tNode = strings.Replace(Node, \"COLOR\", cColor, 1)\n\tNode = strings.Replace(Node, \"TextColor\", tColor, 1)\n\tNode = strings.Replace(Node, \"&lt;CrLf&gt;\", \"\\n\", -1)\n\tNode = strings.Replace(Node, \"&lt;Tab&gt;\", \"\\t\", -1)\n\tNode = strings.Replace(Node, \"\\n\\t\\t\", \" \", -1)\n\treturn Node\n}\n\nfunc Pow2(x int) int { //x&gt;=0\n\tres := 1\n\tfor i := 0; i &lt; x; i++ {\n\t\tres *= 2\n\t}\n\treturn res\n}\n\nfunc Xml4Full(Levels int) string {\n\tvar Xml, Node string\n\tHead := \"&lt;svg xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/\" +\n\t\t\"1999/xlink\\\" version=\\\"1.1\\\" width=\\\"Width\\\" height=\\\"Height\\\"&gt;\\nCONTENT&lt;/svg&gt;\"\n\tLine := `&lt;line x1=\"X1\" y1=\"Y1\" x2=\"X2\" y2=\"Y2\" style=\"stroke:black;stroke-width:2\"/&gt;`\n\tLink := `&lt;a xlink:href=\"https://blog.csdn.net/boysoft2002\" target=\"_blank\"&gt;\n\t&lt;text x=\"5\" y=\"20\" fill=\"blue\"&gt;Hann's CSDN Homepage&lt;/text&gt;&lt;/a&gt;`\n\tfor i := 0; i &lt; Levels; i++ {\n\t\tnegative := -1\n\t\tfor j := 0; j &lt; Pow2(i); j++ {\n\t\t\tt := Pow2(Levels - i - 1)\n\t\t\tx, y := 50*(2*t*j+t), 120*i+50\n\t\t\tif Levels != 1 &amp;&amp; i == Levels-1 {\n\t\t\t\tXml = XmlNode(i, j, x, y, strconv.Itoa(Pow2(i)+j), \"lightgreen\")\n\t\t\t} else {\n\t\t\t\tXml = XmlNode(i, j, x, y, strconv.Itoa(Pow2(i)+j))\n\t\t\t}\n\t\t\tif i &gt; 0 {\n\t\t\t\tline1 := strings.Replace(Line, \"X1\", strconv.Itoa(x), 1)\n\t\t\t\tline1 = strings.Replace(line1, \"Y1\", strconv.Itoa(y-30), 1)\n\t\t\t\tnegative *= -1\n\t\t\t\tx0, y0 := 21, 21\n\t\t\t\t//过连线起始端的半径与纵轴线夹角取45度时x,y坐标修正值21,21[30/1.414]\n\t\t\t\t//取30度时 x0,y0:= 15,30-26；取60度时 x0,y0:= 26[15*1.732],15\n\t\t\t\tx += 50*negative*(2*t*j%2+t) - negative*x0\n\t\t\t\tline1 = strings.Replace(line1, \"X2\", strconv.Itoa(x), 1)\n\t\t\t\tline1 = strings.Replace(line1, \"Y2\", strconv.Itoa(y-120+y0), 1)\n\t\t\t\tXml = strings.Replace(Xml, \"&lt;ROOT/&gt;\", line1, 1)\n\t\t\t}\n\t\t\tNode += Xml\n\t\t}\n\t}\n\tXml = strings.Replace(Head, \"CONTENT\", Node, 1)\n\tXml = strings.Replace(Xml, \"Width\", strconv.Itoa(Pow2(Levels)*50), 1)\n\tXml = strings.Replace(Xml, \"Height\", strconv.Itoa(Levels*120), 1)\n\tXml = strings.Replace(Xml, \"&lt;ROOT/&gt;\", Link, 1)\n\treturn Xml\n}\n\nfunc (bt *biTree) Xml4Tree() string {\n\tvar Xml, Node string\n\tHead := \"&lt;svg xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/\" +\n\t\t\"1999/xlink\\\" version=\\\"1.1\\\" width=\\\"Width\\\" height=\\\"Height\\\"&gt;\\nCONTENT&lt;/svg&gt;\"\n\tLine := `&lt;line x1=\"X1\" y1=\"Y1\" x2=\"X2\" y2=\"Y2\" style=\"stroke:black;stroke-width:2\"/&gt;`\n\tLink := `&lt;a xlink:href=\"https://blog.csdn.net/boysoft2002\" target=\"_blank\"&gt;\n\t&lt;text x=\"5\" y=\"20\" fill=\"blue\"&gt;Hann's CSDN Homepage&lt;/text&gt;&lt;/a&gt;`\n\tList := bt.LevelNullwith()\n\tLevels := len(List)\n\tfor i := Levels - 1; i &gt;= 0; i-- {\n\t\tnegative := -1\n\t\tTmpXml := \"\"\n\t\tfor j := 0; j &lt; Pow2(i); j++ {\n\t\t\tt := Pow2(Levels - i - 1)\n\t\t\tx, y := 50*(2*t*j+t), 120*i+50\n\t\t\tif List[i][j] != nil {\n\t\t\t\tfillColor := \"orange\"\n\t\t\t\tif i == Levels-1 || i &gt; 0 &amp;&amp; i &lt; Levels-1 &amp;&amp;\n\t\t\t\t\tList[i+1][j*2] == nil &amp;&amp; List[i+1][j*2+1] == nil {\n\t\t\t\t\tfillColor = \"lightgreen\"\n\t\t\t\t}\n\t\t\t\tTmpStr := \"\"\n\t\t\t\tswitch List[i][j].(type) {\n\t\t\t\tcase int:\n\t\t\t\t\tTmpStr = strconv.Itoa(List[i][j].(int))\n\t\t\t\tcase float64:\n\t\t\t\t\tTmpStr = strconv.FormatFloat(List[i][j].(float64), 'g', -1, 64)\n\t\t\t\tcase string:\n\t\t\t\t\tTmpStr = List[i][j].(string)\n\t\t\t\tdefault:\n\t\t\t\t\tTmpStr = \"Error Type\"\n\t\t\t\t}\n\t\t\t\tXml = XmlNode(i, j, x, y, TmpStr, fillColor)\n\t\t\t}\n\t\t\tif i &gt; 0 {\n\t\t\t\tline1 := strings.Replace(Line, \"X1\", strconv.Itoa(x), 1)\n\t\t\t\tline1 = strings.Replace(line1, \"Y1\", strconv.Itoa(y-30), 1)\n\t\t\t\tnegative *= -1\n\t\t\t\tx0, y0 := 21, 21\n\t\t\t\tx += 50*negative*(2*t*j%2+t) - negative*x0\n\t\t\t\tline1 = strings.Replace(line1, \"X2\", strconv.Itoa(x), 1)\n\t\t\t\tline1 = strings.Replace(line1, \"Y2\", strconv.Itoa(y-120+y0), 1)\n\t\t\t\tXml = strings.Replace(Xml, \"&lt;ROOT/&gt;\", line1, 1)\n\t\t\t}\n\t\t\tif List[i][j] != nil {\n\t\t\t\tTmpXml += Xml\n\t\t\t}\n\t\t}\n\t\tNode = TmpXml + Node\n\t}\n\tXml = strings.Replace(Head, \"CONTENT\", Node, 1)\n\tXml = strings.Replace(Xml, \"Width\", strconv.Itoa(Pow2(Levels)*50), 1)\n\tXml = strings.Replace(Xml, \"Height\", strconv.Itoa(Levels*120), 1)\n\tXml = strings.Replace(Xml, \"&lt;ROOT/&gt;\", Link, 1)\n\treturn Xml\n}\n\nfunc main() {\n\n\tvar file *os.File\n\tvar err1 error\n\n\tlist1 := []interface{}{\"-\", \"*\", 6, \"+\", 3, nil, nil, 2, 8}\n\tlist2 := []interface{}{1, 2, 3, 4, 5, nil, 6, 7, 8}\n\ttree1 := Build(list1)\n\ttree2 := Build(list2)\n\ttree3 := Mirror(tree2)\n\ttexts := []string{tree1.Xml4Tree(), tree2.Xml4Tree(), tree3.Xml4Tree(), Xml4Full(4)}\n\n\tfor index, text := range texts {\n\t\tsvgFile := \"./biTree0\" + strconv.Itoa(index+1) + \".svg\"\n\t\tfile, err1 = os.Create(svgFile)\n\t\tif err1 != nil {\n\t\t\tpanic(err1)\n\t\t}\n\t\t_, err1 = io.WriteString(file, text)\n\t\tif err1 != nil {\n\t\t\tpanic(err1)\n\t\t}\n\t\tfile.Close()\n\t\texec.Command(\"cmd\", \"/c\", \"start\", svgFile).Start()\n\t\t//Linux 代码：\n\t\t//exec.Command(\"xdg-open\", svgFile).Start()\n\t\t//Mac 代码：\n\t\t//exec.Command(\"open\", svgFile).Start()\n\t}\n\n\tfmt.Println(\"Welcome to my homepage: https://blog.csdn.net/boysoft2002\")\n\texec.Command(\"cmd\", \"/c\", \"start\", \"https://blog.csdn.net/boysoft2002\").Start()\n\n}\n</code></pre>\n<p>至此，已达成自己的预想结果，算法实在有点笨拙，但总算成功了。如有达人会更好的算法，且刚好看到此文，请务必给予点拨指教（不吝）......</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\62c7f0ad00f34f16b0423ddcffd49a7c.png\"/><span style=\"color:#fe2c24;\"> 上面一长条“细线”并非分割线，而是11层的满二叉树，太宽了点击放大看看！</span></p>\n</div>\n</div>"}