{"blogid": "125684478", "writerAge": "码龄1年", "writerBlogNum": "25", "writerCollect": "2049", "writerComment": "1518", "writerFan": "2633", "writerGrade": "6级", "writerIntegral": "4561", "writerName": "猿力猪", "writerProfileAdress": "writer_image\\profile_125684478.jpg", "writerRankTotal": "4640", "writerRankWeekly": "15864", "writerThumb": "1555", "writerVisitNum": "113002", "blog_read_count": "47674", "blog_time": "已于 2022-07-13 12:19:28 修改", "blog_title": "【OpenCV】车辆识别 C++ OpenCV 原理介绍 + 案例实现", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h1 id=\"%E7%9B%AE%E5%BD%95\">目录</h1>\n<p id=\"%E5%89%8D%E8%A8%80%C2%A0-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%89%8D%E8%A8%80%C2%A0\">前言 </a></p>\n<p id=\"%E4%B8%80%E3%80%81OpenCV%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%80%E3%80%81OpenCV%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86\">一、图像处理</a></p>\n<p id=\"%E5%9B%BE%E5%83%8F%E4%BA%8C%E5%80%BC%E5%8C%96-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%9B%BE%E5%83%8F%E4%BA%8C%E5%80%BC%E5%8C%96\">💻二值化处理</a></p>\n<p id=\"%E8%86%A8%E8%83%80%E8%85%90%E8%9A%80-toc\" style=\"margin-left:40px;\"><a href=\"#%E8%86%A8%E8%83%80%E8%85%90%E8%9A%80\">💻膨胀、腐蚀</a></p>\n<p id=\"%E5%BC%80%E8%BF%90%E7%AE%97%E9%97%AD%E8%BF%90%E7%AE%97-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%BC%80%E8%BF%90%E7%AE%97%E9%97%AD%E8%BF%90%E7%AE%97\">💻开运算、闭运算</a></p>\n<p id=\"%E4%BA%8C%E3%80%81%E6%A1%88%E4%BE%8B%E5%AE%9E%E7%8E%B0-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BA%8C%E3%80%81%E6%A1%88%E4%BE%8B%E5%AE%9E%E7%8E%B0\">二、案例实现</a></p>\n<p id=\"Step1%EF%BC%9A%E7%81%B0%E5%BA%A6%E5%A4%84%E7%90%86-toc\" style=\"margin-left:40px;\"><a href=\"#Step1%EF%BC%9A%E7%81%B0%E5%BA%A6%E5%A4%84%E7%90%86\">Step1：灰度处理</a></p>\n<p id=\"Step2%EF%BC%9A%E5%AF%B9%E8%A7%86%E9%A2%91%E8%BF%9B%E8%A1%8C%E5%B8%A7%E5%B7%AE%E5%A4%84%E7%90%86-toc\" style=\"margin-left:40px;\"><a href=\"#Step2%EF%BC%9A%E5%AF%B9%E8%A7%86%E9%A2%91%E8%BF%9B%E8%A1%8C%E5%B8%A7%E5%B7%AE%E5%A4%84%E7%90%86\">Step2：对视频进行帧差处理</a></p>\n<p id=\"Step3%EF%BC%9A%E4%BA%8C%E5%80%BC%E5%8C%96%E5%A4%84%E7%90%86-toc\" style=\"margin-left:40px;\"><a href=\"#Step3%EF%BC%9A%E4%BA%8C%E5%80%BC%E5%8C%96%E5%A4%84%E7%90%86\">Step3：二值化处理</a></p>\n<p id=\"Step4%EF%BC%9A%E8%85%90%E8%9A%80%E5%A4%84%E7%90%86-toc\" style=\"margin-left:40px;\"><a href=\"#Step4%EF%BC%9A%E8%85%90%E8%9A%80%E5%A4%84%E7%90%86\">Step4：腐蚀处理</a></p>\n<p id=\"Step5%EF%BC%9A%E8%86%A8%E8%83%80%E5%A4%84%E7%90%86%C2%A0-toc\" style=\"margin-left:40px;\"><a href=\"#Step5%EF%BC%9A%E8%86%A8%E8%83%80%E5%A4%84%E7%90%86%C2%A0\">Step5：膨胀处理 </a></p>\n<p id=\"Step6%EF%BC%9A%E6%A0%87%E8%AE%B0%E3%80%81%E6%A1%86%E9%80%89%E7%9B%AE%E6%A0%87-toc\" style=\"margin-left:40px;\"><a href=\"#Step6%EF%BC%9A%E6%A0%87%E8%AE%B0%E3%80%81%E6%A1%86%E9%80%89%E7%9B%AE%E6%A0%87\">Step6：标记、框选目标</a></p>\n<p id=\"%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81\">💡完整代码</a></p>\n<p id=\"%E4%B8%89%E3%80%81%E6%80%BB%E7%BB%93-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%89%E3%80%81%E6%80%BB%E7%BB%93\">三、总结</a> </p>\n<hr/>\n<h1 id=\"%E5%89%8D%E8%A8%80%C2%A0\">前言 </h1>\n<p>本文主要以<strong><span style=\"color:#be191c;\">车辆识别</span></strong>为目标，利用 <span style=\"color:#be191c;\"><strong>C++语言</strong></span> 结合 <span style=\"color:#be191c;\"><strong>Qt + OpenCV</strong> </span>进行图像处理相关步骤的讲解</p>\n<h1 id=\"%E4%B8%80%E3%80%81OpenCV%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86\">一、图像处理</h1>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\11db41505a094c71ba8038d414a1e948.png\"/></p>\n<h2 id=\"%E5%9B%BE%E5%83%8F%E4%BA%8C%E5%80%BC%E5%8C%96\">💻二值化处理</h2>\n<p><span style=\"color:#494949;\"><strong>二值化：</strong></span>是通过遍历灰度图中点，将图像信息二值化处理，处理过后的图片只有黑白两种色值</p>\n<p><img alt=\"\" height=\"835\" src=\"image\\f81f963406c74b998b0fe7e0b90ea709.png\" width=\"1200\"/></p>\n<blockquote>\n<p><strong><span style=\"color:#494949;\">📍</span>作用：</strong></p>\n<ul><li>图像的二值化就是将图像上的像素点的灰度值设置为0或255，这样将使整个图像呈现出明显的黑白效果</li><li>在数字图像处理中，二值图像占有非常重要的地位，图像的二值化使图像中数据量大为减少，从而能凸显出目标的轮廓</li></ul>\n</blockquote>\n<blockquote>\n<p><strong><span style=\"color:#494949;\">📍全局阈值：</span></strong></p>\n<p><strong>函数：<span style=\"color:#4da8ee;\">threshold（）</span></strong></p>\n<p><strong>参数：</strong></p>\n<p><span style=\"color:#ff9900;\">参数1：</span>InputArray类型的src，输入数组，填单通道 , 8或32位浮点类型的Mat即可 </p>\n<p><span style=\"color:#ff9900;\">参数2：</span>OutputArray类型的dst，函数调用后的运算结果存在这里，即这个参数用于存放输出结果，且和第一个参数中的Mat变量有一样的尺寸和类型</p>\n<p><span style=\"color:#ff9900;\">参数3：</span>double类型的thresh，阈值的具体值</p>\n<p><span style=\"color:#ff9900;\">参数4：</span>double类型的maxval，当第5个参数阈值类型type取 THRESH_BINARY 或THRESH_BINARY_INV阈值类型时的最大值</p>\n<p><span style=\"color:#ff9900;\">参数5：</span>int类型的type，取阀值的算法</p>\n<p></p>\n<p><strong><span style=\"color:#494949;\">📍</span></strong><span style=\"color:#494949;\"><strong>局部阈值：</strong></span></p>\n<p><strong>函数：<span style=\"color:#4da8ee;\">adaptiveThreshold（）</span></strong></p>\n<p><strong>参数：</strong></p>\n<p><span style=\"color:#ff9900;\">参数1：</span>InputArray类型的src，输入图像，填单通道，单8位浮点类型Mat即可</p>\n<p><span style=\"color:#ff9900;\">参数2：</span>函数运算后的结果存放在这。即为输出图像</p>\n<p><span style=\"color:#ff9900;\">参数3：</span>预设满足条件的最大值</p>\n<p><span style=\"color:#ff9900;\">参数4：</span>指定自适应阈值算法，可选择ADAPTIVE_THRESH_MEAN_C 或 ADAPTIVE_THRESH_GAUSSIAN_C两种</p>\n<p><span style=\"color:#ff9900;\">参数5：</span>指定阈值类型，可选择THRESH_BINARY或者THRESH_BINARY_INV两种</p>\n<p>（即二进制阈值或反二进制阈值）</p>\n<p><span style=\"color:#ff9900;\">参数6：</span>表示邻域块大小，用来计算区域阈值，一般选择为3、5、7等</p>\n<p><span style=\"color:#ff9900;\">参数7：</span>参数C表示与算法有关的参数，它是一个从均值或加权均值提取的常数，可以是负数</p>\n</blockquote>\n<h2 id=\"%E8%86%A8%E8%83%80%E8%85%90%E8%9A%80\">💻膨胀、腐蚀</h2>\n<p><img alt=\"\" height=\"339\" src=\"image\\6364c315eb5e475384785417d3028290.png\" width=\"983\"/></p>\n<ul><li>膨胀和腐蚀是针对图片的二值化数据进行操作的主要是针对高亮部分</li></ul>\n<blockquote>\n<ul><li>膨胀就是使用算法，将图像的边缘扩大些，作用就是将目标的边缘或者是内部的坑填掉 </li><li>腐蚀就是使用算法，将图像的边缘腐蚀掉，作用就是将目标的边缘的“毛刺”踢除掉</li></ul>\n</blockquote>\n<p><strong>1️⃣膨胀过程</strong> </p>\n<p>膨胀是求局部最大值的操作，核B与图形卷积，即计算核B覆盖的区域的像素点的最大值，并把这个最大值赋值给参考点指定的像素，这样就会使图像中的高亮区域逐渐增长</p>\n<p><img alt=\"\" height=\"597\" src=\"image\\c6c84c0b61aa4292aaa49bc47895b409.png\" width=\"1014\"/></p>\n<p><strong>2️⃣腐蚀过程</strong></p>\n<p>腐蚀可以理解为B的中心（锚点）沿着A的内边界走了一圈。腐蚀也是对高亮部分而言，A区域之外的部分 &lt; A的高亮像素，所里里面被外面取代</p>\n<p><img alt=\"\" height=\"587\" src=\"image\\76b3e008b9ce4854bbe773b954066673.png\" width=\"1000\"/></p>\n<h2 id=\"%E5%BC%80%E8%BF%90%E7%AE%97%E9%97%AD%E8%BF%90%E7%AE%97\">💻开运算、闭运算</h2>\n<p><strong>1️⃣开运算：</strong>先腐蚀再膨胀，用来消除小物体 </p>\n<p><img alt=\"\" height=\"492\" src=\"image\\b3a5668d14c6420a95ecd8061f099574.png\" width=\"1200\"/></p>\n<p><strong>2️⃣闭运算：</strong> 先膨胀再腐蚀，用于排除小型黑洞</p>\n<p><img alt=\"\" height=\"459\" src=\"image\\6aa6536e2c2b44d8bed1612631d77b13.png\" width=\"1200\"/></p>\n<h1 id=\"%E4%BA%8C%E3%80%81%E6%A1%88%E4%BE%8B%E5%AE%9E%E7%8E%B0\">二、案例实现</h1>\n<p><img alt=\"\" height=\"1200\" src=\"image\\c178c4d78883416f99013bb7fae689da.png\" width=\"1200\"/></p>\n<h2 id=\"Step1%EF%BC%9A%E7%81%B0%E5%BA%A6%E5%A4%84%E7%90%86\">Step1：灰度处理</h2>\n<ul><li>将传入的两帧先进行处理，先将其转化成RGB类型图片再转化为灰度图 </li></ul>\n<pre><code class=\"language-cpp\">    cvtColor(frontFrame,frontGray,CV_BGR2GRAY);//前一帧灰度处理\n    cvtColor(afterFrame,afterGray,CV_BGR2GRAY);//后一帧灰度处理</code></pre>\n<h2 id=\"Step2%EF%BC%9A%E5%AF%B9%E8%A7%86%E9%A2%91%E8%BF%9B%E8%A1%8C%E5%B8%A7%E5%B7%AE%E5%A4%84%E7%90%86\">Step2：<strong>对视频进行帧差处理</strong></h2>\n<ul><li>将两帧图片进行帧差处理，将对比结果存储在diff中</li></ul>\n<pre><code class=\"language-cpp\">    //【帧差法】对比两帧图像之间差异，捕获运动物体\n    //缺点:所有运动的物体都会展现\n    Mat diff;\n    absdiff(frontGray,afterGray,diff);//前后两帧对比存在diff中</code></pre>\n<ul><li><span style=\"color:#ed7976;\"><strong>灰度图 + 帧差处理</strong></span>后，效果如下：</li></ul>\n<p><img alt=\"\" height=\"659\" src=\"image\\c4edfaab69d5415bbba4c9db18c99757.png\" width=\"1200\"/></p>\n<h2 id=\"Step3%EF%BC%9A%E4%BA%8C%E5%80%BC%E5%8C%96%E5%A4%84%E7%90%86\">Step3：<strong>二值化处理</strong></h2>\n<ul><li>我们可以看到，公交车的识别区块并不是很明显，因此，接下来我们对视频进行二值化处理</li></ul>\n<pre><code class=\"language-cpp\">    //【二值化】黑白分明\n    //局部阈值\n    threshold(diff,diff,25,255,CV_THRESH_BINARY);</code></pre>\n<ul><li>黑白更加分明，效果如下：</li></ul>\n<p><img alt=\"\" height=\"1200\" src=\"image\\f22e0e62e7de4f4d9cb01ba0ecbe2e8c.png\" width=\"1200\"/></p>\n<h2 id=\"Step4%EF%BC%9A%E8%85%90%E8%9A%80%E5%A4%84%E7%90%86\">Step4：腐蚀处理</h2>\n<ul><li>我们会发现，二值化处理后，比原来多出好多的白色的小点，这时候我们就需要进行腐蚀处理，腐蚀掉<strong><span style=\"color:#ed7976;\">&lt;x*x</span></strong>方块大小的像素，这里设置了<span style=\"color:#ed7976;\"><strong>4*4</strong></span>，来清除大部分噪点 </li></ul>\n<pre><code class=\"language-cpp\">    //【腐蚀处理】将背景中的白色噪点尽可能去除 降噪处理\n    Mat element = cv::getStructuringElement(MORPH_RECT,Size(4,4));//小于4*4方块的白色噪点都会被腐蚀\n    erode(diff,diff,element);</code></pre>\n<ul><li>腐蚀处理之后，效果如下：</li></ul>\n<p><img alt=\"\" height=\"660\" src=\"image\\acb7efd5be9447ef9a114147c2a71257.png\" width=\"1200\"/></p>\n<h2 id=\"Step5%EF%BC%9A%E8%86%A8%E8%83%80%E5%A4%84%E7%90%86%C2%A0\">Step5：膨胀处理 </h2>\n<ul><li>噪点相较于之前确实少了很多，但是运动的物体也被腐蚀掉了很多，可能会识别不到一些移动车辆，这里我们继续进行膨胀处理，将我们的目标像素图像变“胖”</li></ul>\n<pre><code class=\"language-cpp\">    //【膨胀处理】将白色区域扩大,更加明显，利于目标识别\n    Mat element2=cv::getStructuringElement(MORPH_RECT,Size(30,30));\n    dilate(diff,diff,element2);</code></pre>\n<ul><li>膨胀处理后，效果如下：</li></ul>\n<p><img alt=\"\" height=\"640\" src=\"image\\a5473a84f8044fafb2b9b5e0a3737190.png\" width=\"1200\"/></p>\n<h2 id=\"Step6%EF%BC%9A%E6%A0%87%E8%AE%B0%E3%80%81%E6%A1%86%E9%80%89%E7%9B%AE%E6%A0%87\">Step6：标记、框选目标</h2>\n<ul><li>最后，将我们的目标像素图像进行标记，并且加一个框把移动的物体框选出来</li></ul>\n<pre><code class=\"language-cpp\">    //动态物体的位置进行标记\n    vector&lt;vector&lt;Point&gt;&gt;contours;\n    findContours(diff,contours,CV_RETR_EXTERNAL,CV_CHAIN_APPROX_SIMPLE,Point(0,0));\n\n    //提取关键点\n    vector&lt;vector&lt;Point&gt;&gt;contours_poly(contours.size());\n    vector&lt;Rect&gt;boundRect(contours.size());\n    //确定四个点来进行框住目标物体\n    int x,y,w,h;\n    int num=contours.size();\n    for(int i = 0;i &lt; num;i++)\n    {\n        approxPolyDP(Mat(contours[i]),contours_poly[i],3,true);\n        boundRect[i]=boundingRect(Mat(contours_poly[i]));\n        x=boundRect[i].x;\n        y=boundRect[i].y;\n        w=boundRect[i].width;\n        h=boundRect[i].height;\n        //绘制矩形\n        rectangle(resFrame,Point(x,y),Point(x+w,y+h),Scalar(255,0,0),2);//Scalar颜色\n    }</code></pre>\n<ul><li>完成上述所有步骤后，效果如下： </li></ul>\n<p><img alt=\"\" height=\"248\" src=\"https://img-blog.csdnimg.cn/2ac62a998ce04f2da7cf0504cb0c9c0c.gif\" width=\"788\"/></p>\n<h2 id=\"%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81\"><strong>💡完整代码</strong></h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;opencv2/opencv.hpp&gt;\nusing namespace std;\nusing namespace cv;\n\nMat MoveCheck(Mat &amp;frontFrame,Mat &amp;afterFrame)\n{\n\n    Mat frontGray,afterGray;//前后灰度处理\n    Mat resFrame = afterFrame.clone();\n\n    //【灰度处理】\n    cvtColor(frontFrame,frontGray,CV_BGR2GRAY);//前一帧灰度处理\n    cvtColor(afterFrame,afterGray,CV_BGR2GRAY);//后一帧灰度处理\n\n    //【帧差法】对比两帧图像之间差异，捕获运动物体\n    //缺点:所有运动的物体都会展现\n    Mat diff;\n    absdiff(frontGray,afterGray,diff);//前后两帧对比存在diff中\n    //imshow(\"diff\",diff);\n\n    //【二值化】黑白分明\n    //局部阈值\n    threshold(diff,diff,25,255,CV_THRESH_BINARY);\n    //imshow(\"threshold\",diff);\n\n    //【腐蚀处理】将背景中的白色噪点尽可能去除 降噪处理\n    Mat element = cv::getStructuringElement(MORPH_RECT,Size(4,4));//小于4*4方块的白色噪点都会被腐蚀\n    erode(diff,diff,element);\n    //imshow(\"erode\",diff);\n\n    //【膨胀处理】将白色区域扩大,更加明显，利于目标识别\n    Mat element2=cv::getStructuringElement(MORPH_RECT,Size(30,30));\n    dilate(diff,diff,element2);\n    //imshow(\"dilate\",diff);\n\n    //开运算:先腐蚀后膨胀，去掉高亮物体背景中白色的噪点，凸显高亮物体\n    //闭运算:先膨胀后腐蚀，去掉高亮物体内部的黑色小坑洞，凸显高亮物体\n\n    //动态物体的位置进行标记\n    vector&lt;vector&lt;Point&gt;&gt;contours;\n    findContours(diff,contours,CV_RETR_EXTERNAL,CV_CHAIN_APPROX_SIMPLE,Point(0,0));\n\n    //提取关键点\n    vector&lt;vector&lt;Point&gt;&gt;contours_poly(contours.size());\n    vector&lt;Rect&gt;boundRect(contours.size());\n    //确定四个点来进行框住目标物体\n    int x,y,w,h;\n    int num=contours.size();\n    for(int i = 0;i &lt; num;i++)\n    {\n        approxPolyDP(Mat(contours[i]),contours_poly[i],3,true);\n        boundRect[i]=boundingRect(Mat(contours_poly[i]));\n        x=boundRect[i].x;\n        y=boundRect[i].y;\n        w=boundRect[i].width;\n        h=boundRect[i].height;\n        //绘制矩形\n        rectangle(resFrame,Point(x,y),Point(x+w,y+h),Scalar(255,0,0),2);//Scalar颜色\n    }\n    return resFrame;\n}\nint main(int argc, char *argv[])\n{\n\n    Mat frame;\n    Mat temp;\n    Mat res;\n    int count = 0;\n    VideoCapture cap(\"C:/Users/86177/Desktop/image/carMove.mp4\");//视频路径\n\n    while(cap.read(frame))\n    {\n        count++;\n        if(count == 1)\n        {\n            res = MoveCheck(frame,frame);\n        }\n        else\n        {\n            res = MoveCheck(temp,frame);\n        }\n        temp = frame.clone();\n        imshow(\"frame\",frame);\n        imshow(\"res\",res);\n        waitKey(25);//延时\n    }\n\n    return 0;\n}\n</code></pre>\n<h1 id=\"%E4%B8%89%E3%80%81%E6%80%BB%E7%BB%93\">三、总结</h1>\n<blockquote>\n<ul><li>本文主要讲解了OpenCV图像处理基本的原理，包括<span style=\"color:#be191c;\"><strong>帧差法</strong></span>、<span style=\"color:#be191c;\"><strong>二值化</strong></span>、<span style=\"color:#be191c;\"><strong>膨胀腐蚀</strong></span>、<span style=\"color:#be191c;\"><strong>开运算</strong></span>、<span style=\"color:#be191c;\"><strong>闭运算</strong></span></li><li>以车辆识别为例子，详细讲解了图像处理相关操作，在各个步骤是怎么样的一个效果</li><li>车辆识别在我们日常生活中非常常见，是一个很经典的案例，本案例算是初步实现，但是，通过案例也发现，帧差法的缺点显而易见，测试视频存在很多干扰，比如说其他移动的物体，例如，风比较大，树叶跟着动，我们的框选位置就会受到干扰，不一定是我们预期想要的目标，接下来也会继续对这方面进行深入探究和学习，争取做到更好！</li></ul>\n</blockquote>\n<p></p>\n<p><span style=\"color:#38d8f0;\"><strong><em>以上就是本文的全部内容啦！如果对您有帮助，麻烦点赞啦！收藏啦！欢迎各位评论区留言</em>！！！</strong></span></p>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"345\" src=\"https://img-blog.csdnimg.cn/32106ac8cf264ce0afbd7c1d3a680eb8.gif\" width=\"636\"/></p>\n</div>\n</div>"}