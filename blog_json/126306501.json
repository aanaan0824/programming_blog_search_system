{"blogid": "126306501", "writerAge": "码龄6年", "writerBlogNum": "420", "writerCollect": "756", "writerComment": "88", "writerFan": "257", "writerGrade": "6级", "writerIntegral": "6116", "writerName": "努力写题的tyf", "writerProfileAdress": "writer_image\\profile_126306501.jpg", "writerRankTotal": "605210", "writerRankWeekly": "162907", "writerThumb": "277", "writerVisitNum": "195798", "blog_read_count": "60", "blog_time": "已于 2022-09-07 17:04:44 修改", "blog_title": "菜鸡的秋招升级打怪之旅", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<blockquote>\n<p>记录秋招。。。</p>\n</blockquote>\n<h2>旷视一面（2022.08.12）</h2>\n<ul><li>softmax，交叉熵loss实现</li></ul>\n<p><img alt=\"softmax=\\frac{e^{z_i}}{\\sum_{j=1}^Ce^{z_j}}\" class=\"mathcode\" src=\"https://latex.codecogs.com/gif.latex?softmax%3D%5Cfrac%7Be%5E%7Bz_i%7D%7D%7B%5Csum_%7Bj%3D1%7D%5ECe%5E%7Bz_j%7D%7D\"/></p>\n<p><img alt=\"L_{CE}=\\frac{1}{N}\\sum_{i=1}^{N}-log(\\frac{e^{z_i}}{\\sum_{j=1}^Ce^{z_j}})\" class=\"mathcode\" src=\"https://latex.codecogs.com/gif.latex?L_%7BCE%7D%3D%5Cfrac%7B1%7D%7BN%7D%5Csum_%7Bi%3D1%7D%5E%7BN%7D-log%28%5Cfrac%7Be%5E%7Bz_i%7D%7D%7B%5Csum_%7Bj%3D1%7D%5ECe%5E%7Bz_j%7D%7D%29\"/></p>\n<pre><code>import numpy as np\nimport torch\nimport torch.nn.functional as F\n\ndef softmax(logits):\n    logits_exp = torch.exp(logits)\n    logits_softmax = logits_exp / torch.sum(logits_exp, dim=1, keepdims=True)\n    return logits_softmax\n\ndef cross_entropy(logits_softmax, label):\n    log_res = torch.log(logits_softmax)\n    one_hot = torch.zeros_like(logits_softmax)\n    one_hot.scatter_(1,label.view(-1, 1),1)\n    loss = -torch.sum(log_res*one_hot, dim=1).mean()\n    return loss\n\n# softmax\nlogits=torch.randn([2,5]) # B x C\nlabel=torch.tensor([0,3])\nlogits_softmax=softmax(logits)\nprint(logits_softmax)\nprint(F.softmax(logits,dim=1)) # 验证\n\n# 预测的值\ny_pred = torch.argmax(logits_softmax, dim=1)\nprint(y_pred)\n\n# cross_entropy\nprint(cross_entropy(logits_softmax, label))\nprint(F.cross_entropy(logits, label))\n'''\n输出\ntensor([[0.1391, 0.1638, 0.0294, 0.4314, 0.2363],\n        [0.2304, 0.2246, 0.3404, 0.0679, 0.1367]])\ntensor([[0.1391, 0.1638, 0.0294, 0.4314, 0.2363],\n        [0.2304, 0.2246, 0.3404, 0.0679, 0.1367]])\ntensor([3, 2])\ntensor(2.3307)\ntensor(2.3307)\n'''\n</code></pre>\n<ul><li>【补充】计算IOU</li></ul>\n<pre><code>def compute_iou(box1, box2):\n    '''\n    box 0,1,2,3: x1,y1,x2,y2\n    '''\n    area1 = (box1[2]-box1[0]) * (box1[3]-box1[1])\n    area2 = (box2[2]-box2[0]) * (box2[3]-box2[1])\n    \n    area_sum = area1 + area2\n    x1=max(box1[0], box2[0])\n    y1=max(box1[1], box2[1])\n    \n    x2=min(box1[2], box2[2])\n    y2=min(box1[3], box2[3])\n    \n    if x1 &gt;= x2 or y1 &gt;= y2:\n        return 0\n    \n    area_jiao = (x2-x1) * (y2-y1)\n    print(area_sum, area_jiao)\n    iou = area_jiao / (area_sum - area_jiao)\n    return iou\n    \nbox1=torch.tensor([1,3,4,5]).float()\nbox2=torch.tensor([3,4,6,8]).float()\nprint(compute_iou(box1, box2))\n'''\n输出\ntensor(18.) tensor(1.)\ntensor(0.0588)\n'''</code></pre>\n<ul><li>【补充】计算NMS</li></ul>\n<pre><code>def NMS(boxes, scores, thresh=0.03):\n    sorted_scores, idx = torch.sort(scores, descending=True)\n    sorted_boxes = boxes[idx]\n    result_boxes = []\n    \n    while len(sorted_boxes) &gt; 1:\n        box=sorted_boxes[0]\n        result_boxes.append(box)\n        \n        sorted_boxes = sorted_boxes[1:]\n        saved_idx = []\n        for i, item in enumerate(sorted_boxes):\n            if(compute_iou(box, item)&lt;thresh):\n                saved_idx.append(i)\n        sorted_boxes = sorted_boxes[saved_idx]\n    if len(sorted_boxes)&gt; 0:\n        result_boxes.append(sorted_boxes[0])\n    return result_boxes\n\nbox0 = torch.tensor([100,100,200,200]).float()\nbox1=torch.tensor([1,3,4,5]).float()\nbox2=torch.tensor([3,4,6,8]).float()\nscores = torch.tensor([0.5, 0.8, 0.9])\n\nboxes = []\nboxes.append(box0)\nboxes.append(box1)\nboxes.append(box2)\nboxes = torch.cat(boxes, dim=0).reshape(3,-1)\nNMS(boxes, scores)\n'''\n输出\n[tensor([3., 4., 6., 8.]), tensor([100., 100., 200., 200.])]\n'''</code></pre>\n<p>2. 反转链表</p>\n<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\ntypedef pair&lt;int,int&gt; P;\nconst int N=505;\n\nstruct ListNode{\n    int val;\n    ListNode *next;\n    ListNode(int x): val(x), next(NULL) {}\n};\n\nvoid print(ListNode *p){\n    if(p!=NULL){\n        printf(\"%d \", p-&gt;val);\n        print(p-&gt;next);\n    }\n}\n\nListNode *reverse_list(ListNode *root){\n    ListNode *pre=NULL;\n    ListNode *cur=root;\n    while(cur!=NULL){\n        ListNode *nex=cur-&gt;next;\n        cur-&gt;next=pre;\n        pre=cur;\n        cur=nex;\n    }\n    return pre;\n}\n\nint main(){\n    int n,a;\n    scanf(\"%d\",&amp;n);\n    ListNode *head=new ListNode(-1);\n    ListNode *p=head;\n    for(int i=0;i&lt;n;i++){\n        scanf(\"%d\",&amp;a);\n        ListNode *now=new ListNode(a);\n        p-&gt;next=now;\n        p=p-&gt;next;\n    }\n    print(head-&gt;next);\n    ListNode *rev_head=reverse_list(head-&gt;next);\n    printf(\"\\n\");\n    print(rev_head);\n}\n</code></pre>\n<h2>旷视二面（2022.08.12）</h2>\n<ul><li>长尾识别中Decoupling方法为什么有效</li><li>人脸loss中为什么||W||=1了，但是head classes权重的模长还是较长</li><li>大数定律。。。</li></ul>\n<p>挂。。。</p>\n<h2>快手一面：</h2>\n<ul><li>最长递增子序列<a class=\"link-info\" href=\"https://leetcode.cn/problems/longest-increasing-subsequence/\" title=\"leetcode300\">leetcode300</a></li></ul>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    int dp[2505];\n    int lengthOfLIS(vector&lt;int&gt;&amp; nums) {\n        int n=nums.size();\n        dp[0]=1;\n        int ans=dp[0];\n        for(int i=1;i&lt;n;i++){\n            dp[i]=1;\n            for(int j=0;j&lt;i;j++){\n                if(nums[j]&lt;nums[i]){\n                    dp[i]=max(dp[i], dp[j]+1);\n                }\n            }\n            ans=max(dp[i], ans);\n        }\n        return ans;\n    }\n};</code></pre>\n<h2>超参数一面：</h2>\n<ul><li> <p><a href=\"https://leetcode.cn/problems/vvXgSW/\" title=\"剑指 Offer II 078. 合并排序链表\">剑指 Offer II 078. 合并排序链表</a></p> </li></ul>\n<p>方法一：优先队列，把链表的每个元素看出单个元素送到优先队列中</p>\n<pre><code class=\"language-cpp\">/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    struct cmp{\n        bool operator()(ListNode *a, ListNode *b){\n            return a-&gt;val &gt; b-&gt;val;\n        }\n    };\n    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) {\n        priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, cmp&gt;pq;\n        int n=lists.size();\n        for(int i=0;i&lt;n;i++){\n            if(lists[i])pq.push(lists[i]);\n        }\n        ListNode *res=new ListNode(-1);\n        ListNode *p=res;\n        while(!pq.empty()){\n            ListNode *tmp=pq.top();\n            pq.pop();\n            p-&gt;next=tmp;\n            p=p-&gt;next;\n            if(tmp-&gt;next){\n                pq.push(tmp-&gt;next);\n            }\n        }\n        return res-&gt;next;\n    }\n};</code></pre>\n<p>方法二：归并排序</p>\n<pre><code class=\"language-cpp\">/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* Merge(ListNode *left, ListNode *right){\n        if(left==NULL)return right;\n        if(right==NULL)return left;\n        ListNode *ans=new ListNode(-1);\n        ListNode *p=ans;\n        while(left&amp;&amp;right){\n            if(left-&gt;val&lt;=right-&gt;val){\n                p-&gt;next=left;\n                left=left-&gt;next;\n            }\n            else{\n                p-&gt;next=right;\n                right=right-&gt;next;\n            }\n            p=p-&gt;next;\n        }\n        if(left)p-&gt;next=left;\n        if(right)p-&gt;next=right;\n        return ans-&gt;next;\n    }\n    ListNode* merge_sort(vector&lt;ListNode*&gt;lists, int b, int e){\n        if(b==e)return lists[b];\n        if(b&gt;e)return NULL;\n        int m=(b+e)/2;\n        ListNode *left=merge_sort(lists, b, m);\n        ListNode *right=merge_sort(lists, m+1, e);\n        return Merge(left, right);\n    }\n    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) {\n        return merge_sort(lists, 0, lists.size()-1);\n    }\n};</code></pre>\n<ul><li> <p><a href=\"https://leetcode.cn/problems/wtcaE1/\" title=\"剑指 Offer II 016. 不含重复字符的最长子字符串\">剑指 Offer II 016. 不含重复字符的最长子字符串</a></p> </li></ul>\n<pre><code class=\"language-cpp\">class Solution {\npublic:\n    unordered_map&lt;char,int&gt;pos;\n    int lengthOfLongestSubstring(string s) {\n        int n=s.length();\n        int left=0;\n        int ans=0;\n\n        for(int i=0;i&lt;n;i++){\n            if(pos[s[i]]-1&gt;=left){//交叉重复\n                ans=max(ans, i-left);\n                left=pos[s[i]];\n            }\n            pos[s[i]]=i+1;\n        }\n        ans=max(ans, n-left);\n        return ans;\n    }\n};</code></pre>\n<h2> 超参数一面：</h2>\n<ul><li>pytorch用的什么并行训练方法：<a class=\"link-info\" href=\"https://blog.csdn.net/weixin_42483745/article/details/124900099\" title=\"5种pytorch并行训练方法\">5种pytorch并行训练方法</a></li><li>训练用的训练集大小：</li></ul>\n<p><img alt=\"\" height=\"300\" src=\"image\\eff5296bc15a481391071b107dbe4ea0.png\" width=\"1200\"/> <img alt=\"\" height=\"812\" src=\"image\\0ee3e1baa78948f9b4602706bd3750f2.png\" width=\"1040\"/></p>\n<ul><li> 调用randint4（随机生成0-3），构造randint5（随机生成0-4），要求等概率</li></ul>\n<p>面试官的提示：5个人掷骰子决定谁去拿快递，那么掷到1-5就对应的人去，掷到6就再来一次</p>\n<p>那么，这里可以看成调用2次randint4函数分别得到x，y，那么4x+y的范围是0-15（其实也就是x有4种，4x+y可以构造成等概率即两两不相等的16种）</p>\n<p>由于16种结果是等概率的，我们只要前15种，如果是最后1种的话，就再来一次。</p>\n<p>则调用randint4中rand函数的期望是：2*（1+1/16+1/16^2+1/16^3...）=2*(1+1/15)</p>\n<p>此处感谢瓜佬的思路。。。</p>\n<pre><code class=\"language-cpp\">#include&lt;bits/stdc++.h&gt;\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair&lt;int,int&gt; P;\nconst int N=100005;\nconst ll mod=1e9+7;\nint randint4(){\n    return rand()%4;\n}\n\nint randint5(){\n    int x=randint4();\n    int y=randint4();\n    int sum=4*x+y;\n    if(sum+1!=16){\n        return (sum+1)%5;\n    }\n    else{\n        return randint5();\n    }\n}\n\nint main(){\n    for(int i=1;i&lt;=10;i++){\n        cout&lt;&lt;randint5()&lt;&lt;endl;\n    }\n}\n</code></pre>\n<p></p>\n</div>\n</div>"}