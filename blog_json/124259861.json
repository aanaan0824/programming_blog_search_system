{"blogid": "124259861", "writerAge": "码龄2年", "writerBlogNum": "176", "writerCollect": "1787", "writerComment": "483", "writerFan": "11545", "writerGrade": "5级", "writerIntegral": "3654", "writerName": "接着奏乐接着舞。", "writerProfileAdress": "writer_image\\profile_124259861.jpg", "writerRankTotal": "4479", "writerRankWeekly": "384", "writerThumb": "1071", "writerVisitNum": "215522", "blog_read_count": "5738", "blog_time": "于 2022-04-18 21:52:56 发布", "blog_title": "前端401错误 & 解决方法:响应拦截器", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"1.%E8%AF%A5%E9%97%AE%E9%A2%98%E5%87%BA%E7%8E%B0%E7%9A%84%E5%8E%9F%E5%9B%A0-toc\" style=\"margin-left:40px;\"><a href=\"#1.%E8%AF%A5%E9%97%AE%E9%A2%98%E5%87%BA%E7%8E%B0%E7%9A%84%E5%8E%9F%E5%9B%A0\">1.该问题出现的原因</a></p>\n<p id=\"2.%20%E5%A4%84%E7%90%86401%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%8E%9F%E7%90%86-toc\" style=\"margin-left:40px;\"><a href=\"#2.%20%E5%A4%84%E7%90%86401%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%8E%9F%E7%90%86\">2.处理401问题的解决方案原理</a></p>\n<p id=\"3.%E4%BD%BF%E7%94%A8%E5%93%8D%E5%BA%94%E6%8B%A6%E6%88%AA%E5%99%A8%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98-toc\" style=\"margin-left:40px;\"><a href=\"#3.%E4%BD%BF%E7%94%A8%E5%93%8D%E5%BA%94%E6%8B%A6%E6%88%AA%E5%99%A8%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98\">3.使用响应拦截器解决问题</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h2 id=\"1.%E8%AF%A5%E9%97%AE%E9%A2%98%E5%87%BA%E7%8E%B0%E7%9A%84%E5%8E%9F%E5%9B%A0\"><span style=\"color:#511b78;\">1.该问题出现的原因</span></h2>\n<blockquote>\n<p>在前后端分离项目中，最常见的是前端点击登录后，后端返回token字符串，这个token可以看作是一个“令牌”，就比如你去酒店办理入住后，拿到的房卡，那代表你有着进去房间的权限。</p>\n<hr/>\n<p><span style=\"color:#fe2c24;\"><strong>1. 登录用户的token过期 </strong></span></p>\n<p><span style=\"color:#be191c;\"><strong>token是具有时效性的，生活中，如你登录腾讯视频，接下来几天你再登录就不用输入账号密码，而时间很长如半个月后，你还要重新输入账号密码登录，这个过程就是token过期。</strong></span></p>\n<p><span style=\"color:#be191c;\"><strong>具体多久过期，一般是和后端商量着来，后台管理类项目如企业内部的项目为了安全性且并不会过多的考虑用户体验，一般设为很短或者干脆不做这个。</strong></span></p>\n<p><span style=\"color:#be191c;\"><strong>而像腾讯视频，淘宝，京东之类的商业类项目需要考虑用户体验，且对于安全性要求并不高，一般设置为7~14天比较合适。</strong></span></p>\n<hr/>\n<p><span style=\"color:#ad720d;\">2. 用户未登录情况,返回401错误,应该回到登录页（这个不一定是401错误）</span></p>\n<hr/>\n<p><span style=\"color:#1a439c;\"><strong>3.小结：很普遍的功能，80%的项目都会做这个功能</strong></span></p>\n</blockquote>\n<hr/>\n<p></p>\n<p></p>\n<h2 id=\"2.%20%E5%A4%84%E7%90%86401%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%8E%9F%E7%90%86\"><span style=\"color:#1a439c;\">2. 处理401问题的解决方案原理</span></h2>\n<hr/>\n<p><span style=\"color:#fe2c24;\"><strong>完整的逻辑为： </strong></span></p>\n<p><strong><span style=\"color:#fe2c24;\"> 前端请求接口api --&gt; 返回401错误 --&gt; 前端判断是否有refresh_token --&gt;如果有就用refresh_token请求新的token --&gt; 后台成功返回一个新的token给我们 --&gt; 更新vuex+本地存储持久化 --&gt; 然后重新发送请求 --&gt; 带上新的token请求数据</span></strong></p>\n<p><strong><span style=\"color:#fe2c24;\">当然，如果没有refresh_token就老老实实去登录吧！</span></strong></p>\n<hr/>\n<p><img alt=\"\" height=\"331\" src=\"image\\9e4d07e7e971428cad928de02f349871.png\" width=\"847\"/></p>\n<hr/>\n<p> </p>\n<blockquote>\n<p><span style=\"color:#511b78;\"><strong>方案： 目前常见的处理方式是：当用户登陆成功之后，返回的token中有两个值</strong></span></p>\n<hr/>\n<p><strong><span style=\"color:#b95514;\">原理：一个是token，他的有效期是2小时（举例），一个是姑且称为refresh_token，他的有效期长，比如是14天，假设用户登录后2小时后，token过期了，那么我们看一下refresh_token在不在，在的话，就用refresh_token再次发送，后端会返回一个新的token。</span></strong></p>\n<hr/>\n<p><strong><span style=\"color:#fe2c24;\">核心点：1.解决401问题重点在于让用户“无感”，也就是说用户不知道token过期也不需要用户再次登录，需要的是我们程序员去处理。</span></strong></p>\n<p><strong><span style=\"color:#fe2c24;\">               2.解决这个问题的地方在响应拦截器</span></strong></p>\n</blockquote>\n<p><img alt=\"\" height=\"433\" src=\"image\\8fc37dcae0f54f1ba7209ef7906bff6b.png\" width=\"831\"/></p>\n<hr/>\n<h2 id=\"3.%E4%BD%BF%E7%94%A8%E5%93%8D%E5%BA%94%E6%8B%A6%E6%88%AA%E5%99%A8%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98\"><span style=\"color:#be191c;\">3.使用响应拦截器解决问题</span></h2>\n<hr/>\n<h3 id=\"3.1%20%E4%BD%9C%E7%94%A8\"><span style=\"color:#511b78;\">3.1 作用</span></h3>\n<blockquote>\n<p><span style=\"color:#be191c;\"><strong>所有从后端回来的响应都会集中进入响应拦截器中,如果发生401错误就可以解决</strong></span></p>\n</blockquote>\n<p> <img alt=\"\" height=\"236\" src=\"image\\49a9158ed49b415cb016e5827205221f.png\" width=\"748\"/></p>\n<p> </p>\n<hr/>\n<p> </p>\n<p>以下是我封装的响应拦截器（可以通用），主要完成两件事：</p>\n<p>处理401问题，以及注入token</p>\n<pre><code class=\"language-javascript\">import router from '../router/auth.js'\n \n \n// 响应拦截器\nrequest.interceptors.response.use(function (response) {\n  console.log('响应拦截器', response)\n  return response\n}, async function (error) {\n  // 如果发生了错误，判断是否是401\n  console.dir(error)\n  if (error.response.status === 401) {\n    // 出现401就在这里面 开始处理 ---\n    console.log('响应拦截器-错误-401')\n    const refreshToken = store.state.tokenInfo.refresh_token\n    // if (有refresh_token) {       ---- 有refresh_token\n    if (refreshToken) {\n      // 1. 请求新token\n      try {\n        const res = await axios({\n          url: 'http://localhost:8000/v1_0/authorizations',\n          method: 'PUT',\n          headers: {\n            Authorization: `Bearer ${refreshToken}`\n          }\n        })\n        console.log('请求新token', res.data.data.token)\n        // 2. 保存到vuex\n        store.commit('mSetToken', {   // mSetToken是前面定义的mutations名字\n          refresh_token: refreshToken,\n          token: res.data.data.token\n        })\n        // 3. 重发请求\n        //    request是上面创建的axios的实例，它会自动从vuex取出token带上\n        return request(error.config)\n      } catch (error) {\n        // 1. 清除token\n        store.commit('mSetToken', {})  \n        // 2. 去到登录页(如果有token值，就不能到login)\n        const backtoUrl = encodeURIComponent(router.currentRoute.fullPath)\n        router.push('/login?backto=' + backtoUrl)  \n        return Promise.reject(error) \n      }\n    } else {\n       // 如果没有refresh_token的时候   ----没有refresh_token\n      // 1.去到登录页\n      // 2.清除token\n      store.commit('mSetToken', {})\n      const backtoUrl = encodeURIComponent(router.currentRoute.fullPath)  // 回到原来跳过来的的页面,不加?后面的一串就会到首页\n      router.push('/login?backto=' + backtoUrl)\n      return Promise.reject(error)  // 返回错误信息\n    }\n  } else {\n    return Promise.reject(error)\n  }\n})</code></pre>\n<p></p>\n</div>\n</div>"}