{"blogid": "126743462", "writerAge": "码龄61天", "writerBlogNum": "95", "writerCollect": "2", "writerComment": "0", "writerFan": "152", "writerGrade": "4级", "writerIntegral": "1161", "writerName": "娜娜带你学架构师", "writerProfileAdress": "writer_image\\profile_126743462.jpg", "writerRankTotal": "21111", "writerRankWeekly": "7361", "writerThumb": "1", "writerVisitNum": "6480", "blog_read_count": "9", "blog_time": "于 2022-09-07 12:59:22 发布", "blog_title": "jvm.dll加载", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-light\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p>**简述<br/> **　　<br/> 　　众所周知java.exe是java class文件的执行程序，但实际上java.exe程序只是<br/> 　　一个执行的外壳，它会装载jvm.dll（windows下，以下皆以windows平台为例，<br/> 　　<a href=\"http://linux.chinaitlab.com/\">linux</a>下和solaris下其实类似，为：libjvm.so），这个动态连接库才是java<br/> 　　虚拟机的实际操作处理所在。本文探究java.exe程序是如何查找和装载jvm.dll<br/> 　　动态库，并调用它进行class文件执行处理的。<br/> 　　<br/> 　　<strong>源代码</strong><br/> 　　<br/> 　　本文分析之代码，《<a href=\"http://java.chinaitlab.com/\">Java</a>TM 2 SDK, Standard Edition, v1.4.2 fcs<br/> 　　Community Source Release》，可从sun官方网站<a href=\"http://download.chinaitlab.com/\">下载</a>，主要分析的源代码为：<br/> 　　j2se/src/share/bin/java.c<br/> 　　j2se/src/windows/bin/java_md.c<br/> 　　<br/> 　　<strong>java.c是什么东西</strong><br/> 　　<br/> 　　‘java程序’源代码<br/> 　　所谓‘java程序’，包括jdk中的java.exe/javac.exe/javadoc.exe，java.c源<br/> 　　代码中通过JAVA_ARGS宏来控制生成的代码，如果该宏没定义则编译文件控制生<br/> 　　成java.exe否则编译文件控制生成其他的‘java程序’。<br/> 　　比如：<br/> 　　j2se/make/java/javac/Makefile（这是javac编译文件）中：<br/> 　　$(CD) …/…/sun/javac ; $(MAKE) <span class=\"katex--inline\"><span class=\"katex\"><span class=\"katex-mathml\">\n    \n     \n      \n       \n        @\n       \n       \n        R\n       \n       \n        E\n       \n       \n        L\n       \n       \n        E\n       \n       \n        A\n       \n       \n        S\n       \n       \n        E\n       \n       \n        =\n       \n      \n      \n       @ RELEASE=\n      \n     \n    </span><span class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.6944em;\"></span><span class=\"mord\">@</span><span class=\"mord mathnormal\" style=\"margin-right: 0.0576em;\">RE</span><span class=\"mord mathnormal\">L</span><span class=\"mord mathnormal\" style=\"margin-right: 0.0576em;\">E</span><span class=\"mord mathnormal\">A</span><span class=\"mord mathnormal\" style=\"margin-right: 0.0576em;\">SE</span><span class=\"mspace\" style=\"margin-right: 0.2778em;\"></span><span class=\"mrel\">=</span></span></span></span></span>(RELEASE) FULL_VERSION=$(FULL_VERSION)<br/> 　　j2se/make/sun/javac/javac/Makefile（由上面Makefile文件调用）中：<br/> 　　JAVA_ARGS = “{ /”-J-ms8m/“, /“com.sun.tools.javac.Main/” }”<br/> 　　则由同一份java.c代码生成的javac.exe程序就会直接调用java类方法：<br/> 　　com.sun.tools.javac.Main，这样使其执行起来就像是直接运行的一个exe文件，<br/> 　　而未定义JAVA_ARGS的java.exe程序则会调用传递过来参数中的类方法。<br/> 　　<br/> 　　<strong>从java.c的main入口函数说起</strong><br/> 　　<br/> 　　main()函数中前面一段为重新分配参数指针的处理。<br/> 　　然后调用函数：CreateExecutionEnvironment，该函数主要查找java运行环境的<br/> 　　目录，和jvm.dll这个虚拟机核心动态连接库文件路径所在。根据操作系统不同，<br/> 　　该函数有不同实现版本，但大体处理逻辑相同，我们看看windows平台该函数的处<br/> 　　理（j2se/src/windows/bin/java_md.c）。<br/> 　　<br/> 　　CreateExecutionEnvironment函数主要分为三步处理：<br/> 　　a、查找jre路径。<br/> 　　b、装载jvm.cfg中指定的虚拟机动态连接库（jvm.dll）参数。<br/> 　　c、取jvm.dll文件路径。<br/> 　　<br/> 　　<strong>实现：</strong><br/> 　　<br/> 　　a、查找jre路径是通过java_md.c中函数：GetJREPath实现的。<br/> 　　该函数首先调用GetApplicationHome函数，GetApplicationHome函数调用windows<br/> 　　API函数GetModuleFileName取java.exe程序的绝对路径，以我的jdk安装路径为例，<br/> 　　为：“D:/java/j2sdk1.4.2_04/bin/java.exe”，然后去掉文件名取绝对路径为：<br/> 　　“D:/java/j2sdk1.4.2_04/bin”，之后会在去掉最后一级目录，现在绝对路径为：<br/> 　　“D:/java/j2sdk1.4.2_04”。<br/> 　　然后GetJREPath函数继续判断刚刚取的路径+/bin/java.dll组合成的这个java.dll<br/> 　　文件是否存在，如果存在则“D:/java/j2sdk1.4.2_04”为JRE路径，否则判断取得<br/> 　　的“D:/java/j2sdk1.4.2_04”路径+/jre/bin/java.dll文件是否存在，存在则<br/> 　　“D:/java/j2sdk1.4.2_04/jre”为JRE路径。如果上面两种情况都不存在，则从注<br/> 　　册表中去查找（参见函数GetPublicJREHome）。<br/> 　　<br/> 　　<strong>函数：GetPublicJREHome先查找</strong><br/> 　　HKEY_LOCAL_MACHINE/Software/<a href=\"http://java.chinaitlab.com/\">Java</a>Soft/Java Runtime Environment/CurrentVersion<br/> 　　键值“当前JRE版本号”，判断“当前JRE版本号”是否为1.4做为版本号，如果是则<br/> 　　取HKEY_LOCAL_MACHINE/Software/JavaSoft/Java Runtime Environment/“当前JRE版本号”<br/> 　　/JavaHome的路径所在为JRE路径。<br/> 　　<br/> 　　我的JDK返回的JRE路径为：“D:/java/j2sdk1.4.2_04/jre”。<br/> 　　<br/> 　　b、装载jvm.cfg虚拟机动态连接库配置文件是通过java.c中函数:ReadKnownVMs实现<br/> 　　的。<br/> 　　该函数首先组合jvm.cfg文件的绝对路径，JRE路径+/lib+/ARCH（CPU构架）+/jvm.cfg<br/> 　　ARCH（CPU构架）的判断是通过java_md.c中GetArch函数判断的，该函数中windows平<br/> 　　台只有两种情况：WIN64的‘ia64’，其他情况都为‘i386’。我的为i386所以jvm.cfg<br/> 　　文件绝对路径为：“D:/java/j2sdk1.4.2_04/jre/lib/i386/jvm.cfg”。文件内容如<br/> 　　下：<br/> 　　## @(#)jvm.cfg　 1.7 03/01/23# # Copyright 2003 Sun Microsystems, Inc. All rights reserved.# SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.# # ### List of JVMs that can be used as an option to java, javac, etc.# Order is important – first in this list is the default JVM.# NOTE that this both this file and its format are UNSUPPORTED and# WILL GO AWAY in a future release.## You may also select a JVM in an arbitrary location with the# “-XXaltjvm=&lt;jvm_dir&gt;” option, but that too is unsupported# and may not be available in a future release.#-client KNOWN-server KNOWN-hotspot ALIASED_TO -client-classic WARN-native ERROR-green ERROR<br/> 　　<br/> 　　（如果细心的话，我们会发现在JDK目录中我的为：“D:/java/j2sdk1.4.2_04/jre/bin/client”和“D:/java/j2sdk1.4.2_04/jre/bin/server”两个目录下都存在jvm.dll文件。而java正是通过jvm.cfg配置文件来管理这些不同版本的jvm.dll的。）<br/> 　　<br/> 　　ReadKnownVMs函数会将该文件中的配置内容读入到一个JVM配置结构的全局变量中，该函数首先跳过注释（以‘#’开始的行），然后读取以‘-’开始的行指定的jvm参数，每一行为一个jvm信息，第一部分为jvm虚拟机名称，第二部分为配置参数，比如行：<br/> 　　“-client KNOWN”则“-client”为虚拟机名称，而“KNOWN”为配置类型参数，“KNOWN”<br/> 　　表示该虚拟机的jvm.dll存在，而“ALIASED_TO”表示为另一个jvm.dll的别名，“WARN”<br/> 　　表示该虚拟机的jvm.dll不存在但运行时会用其他存在的jvm.dll替代执行，而“ERROR”<br/> 　　同样表示该类虚拟机的jvm.dll不存在且运行时不会找存在的jvm.dll替代而直接抛出错误<br/> 　　信息。<br/> 　　<br/> 　　在运行java程序时指定使用那个虚拟机的判断是由java.c中函数：CheckJvmType判断，该函数会检查java运行参数中是否有指定jvm的参数，然后从ReadKnownVMs函数读取的jvm.cfg数据结构中去查找，从而指定不同的jvm类型（最终导致装载不同jvm.dll）。有两种方法可以指定jvm类型，一种按照jvm.cfg文件中的jvm名称指定，第二种方法是直接指定，它们执行的方法分别是“java -J&lt;jvm.cfg中jvm名称&gt;”、“java -XXaltjvm=&lt;jvm类型名称&gt;”或“java -J-XXaltjvm=&lt;jvm类型名称&gt;”。如果是第一种参数传递方式，CheckJvmType函数会取参数‘-J’后面的jvm名称，然后从已知的jvm配置参数中查找如果找到同名的则去掉该jvm名称前的‘-’直接返回该值；而第二种方法，会直接返回“-XXaltjvm=”或“-J-XXaltjvm=”后面的jvm类型名称；如果在运行java时未指定上面两种方法中的任一一种参数，CheckJvmType会取配置文件中第一个配置中的jvm名称，去掉名称前面的‘-’返回该值。CheckJvmType函数的这个返回值会在下面的函数中汇同jre路径组合成jvm.dll的绝对路径。<br/> 　　<br/> 　　比如：如果在运行java程序时使用“java -J-client test”则ReadKnownVMs会读取参数“-client”然后查找jvm.cfg读入的参数中是否有jvm名称为“-client”的，如果有则去掉jvm名称前的“-”直接返回“client”；而如果在运行java程序时使用如下参数：<br/> 　　“java -XXaltjvm=D:/java/j2sdk1.4.2_04/jre/bin/client test”，则ReadKnownVMs<br/> 　　会直接返回“D:/java/j2sdk1.4.2_04/jre/bin/client”；如果不带上面参数执行如：<br/> 　　“java test”，因为在jvm.cfg配置文件中第一个存在的jvm为“-client”，所以函数<br/> 　　ReadKnownVMs也会去掉jvm名称前的“-”返回“client”。其实这三中情况都是使用的<br/> 　　“D:/java/j2sdk1.4.2_04/jre/bin/client/jvm.dll”这个jvm动态连接库处理test这个class的，见下面GetJVMPath函数。<br/> 　　<br/> 　　c、取jvm.dll文件路径是通过java_md.c中函数：GetJVMPath实现的。<br/> 　　由上面两步我们已经获得了JRE路径和jvm的类型字符串。GetJVMPath函数判断CheckJvmType<br/> 　　返回的jvm类型字符串中是否包含了‘/’或‘/’如果包含则以该jvm类型字符串+/jvm.dll作为JVM的全路径，否则以JRE路径+/bin+/jvm类型字符串+/jvm.dll作为JVM的全路径。<br/> 　　<br/> 　　看看上面的例子，第一种情况“java -J-client test”jvm.dll路径为：<br/> 　　JRE路径+/bin+/jvm类型字符串+/jvm.dll 按照我的JDK路径则为：<br/> 　　“D:/java/j2sdk1.4.2_04/jre”+“/bin”+“/client”+“/jvm.dll”。<br/> 　　第二种情况“java -XXaltjvm=D:/java/j2sdk1.4.2_04/jre/bin/client test”路径为：<br/> 　　jvm类型字符串+/jvm.dll即为：“D:/java/j2sdk1.4.2_04/jre/bin/client”+“/jvm.dll”<br/> 　　第三种情况“java test”为：“D:/java/j2sdk1.4.2_04/jre”+“/bin”+“/client”<br/> 　　+“/jvm.dll”与情况一相同。所以这三种情况都是调用的jvm动态连接库“D:/javaj2sdk1.4.2_04/jre/bin/client/jvm.dll”处理test类的。<br/> 　　<br/> 　　我们来进一步验证一下：<br/> 　　打开cmd控制台：<br/> 　　<br/> 　　设置java装载调试<br/> 　　E:/work/java_research&gt;set _JAVA_LAUNCHER_DEBUG=1<br/> 　　<br/> 　　情况一<br/> 　　E:/work/java_research&gt;java -J-client test.ScanDirectory<br/> 　　----_JAVA_LAUNCHER_DEBUG----</p>\n<p>JREpathisD:/java/j2sdk1.4.2_04/jre<br/> jvm.cfg[0]=-&gt;-client&lt;-<br/> jvm.cfg[1]=-&gt;-server&lt;-<br/> jvm.cfg[2]=-&gt;-hotspot&lt;-<br/> jvm.cfg[3]=-&gt;-classic&lt;-<br/> jvm.cfg[4]=-&gt;-native&lt;-<br/> jvm.cfg[5]=-&gt;-green&lt;-<br/> 299microsecondstoparsejvm.cfg<br/> JVMpathisD:/java/j2sdk1.4.2_04/jre/bin/client/jvm.dll<br/> 2897microsecondstoLoadJavaVM<br/> JavaVMargs:<br/> version0x00010002,ignoreUnrecognizedisJNI_FALSE,nOptionsis2<br/> option[0]=‘-Djava.class.path=.’<br/> option[1]=‘-Dsun.java.command=test.ScanDirectory’<br/> 50001microsecondstoInitializeJVM<br/> Main-Classis’test.ScanDirectory’<br/> Apps’argcis0<br/> 10208microsecondstoloadmainclass<br/> ----_JAVA_LAUNCHER_DEBUG----<br/> usage:javatest.ScanDirectoryDIR[outputfile]<br/> 情况二<br/> E:/work/java_research&gt;java-XXaltjvm=D:/java/j2sdk1.4.2_04/jre/bin/clienttest.ScanDirectory<br/> ----_JAVA_LAUNCHER_DEBUG----<br/> JREpathisD:/java/j2sdk1.4.2_04/jre<br/> jvm.cfg[0]=-&gt;-client&lt;-<br/> jvm.cfg[1]=-&gt;-server&lt;-<br/> jvm.cfg[2]=-&gt;-hotspot&lt;-<br/> jvm.cfg[3]=-&gt;-classic&lt;-<br/> jvm.cfg[4]=-&gt;-native&lt;-<br/> jvm.cfg[5]=-&gt;-green&lt;-<br/> 386microsecondstoparsejvm.cfg<br/> JVMpathisD:/java/j2sdk1.4.2_04/jre/bin/client/jvm.dll<br/> 2795microsecondstoLoadJavaVM<br/> JavaVMargs:<br/> version0x00010002,ignoreUnrecognizedisJNI_FALSE,nOptionsis2<br/> option[0]=‘-Djava.class.path=.’<br/> option[1]=‘-Dsun.java.command=test.ScanDirectory’<br/> 49978microsecondstoInitializeJVM<br/> Main-Classis’test.ScanDirectory’<br/> Apps’argcis0<br/> 9598microsecondstoloadmainclass<br/> ----_JAVA_LAUNCHER_DEBUG----<br/> usage:javatest.ScanDirectoryDIR[outputfile]<br/> 情况三<br/> E:/work/java_research&gt;javatest.ScanDirectory<br/> ----_JAVA_LAUNCHER_DEBUG----<br/> JREpathisD:/java/j2sdk1.4.2_04/jre<br/> jvm.cfg[0]=-&gt;-client&lt;-<br/> jvm.cfg[1]=-&gt;-server&lt;-<br/> jvm.cfg[2]=-&gt;-hotspot&lt;-<br/> jvm.cfg[3]=-&gt;-classic&lt;-<br/> jvm.cfg[4]=-&gt;-native&lt;-<br/> jvm.cfg[5]=-&gt;-green&lt;-<br/> 381microsecondstoparsejvm.cfg<br/> JVMpathisD:/java/j2sdk1.4.2_04/jre/bin/client/jvm.dll<br/> 3038microsecondstoLoadJavaVM<br/> JavaVMargs:<br/> version0x00010002,ignoreUnrecognizedisJNI_FALSE,nOptionsis2<br/> option[0]=‘-Djava.class.path=.’<br/> option[1]=‘-Dsun.java.command=test.ScanDirectory’<br/> 50080microsecondstoInitializeJVM<br/> Main-Classis’test.ScanDirectory’<br/> Apps’argcis0<br/> 10215microsecondstoloadmainclass<br/> ----_JAVA_LAUNCHER_DEBUG----<br/> usage:javatest.ScanDirectoryDIR[outputfile]<br/> 三个的JVM路径都为：<br/> JVMpathisD:/java/j2sdk1.4.2_04/jre/bin/client/jvm.dll</p>\n<p>其他情况<br/> E:/work/java_research&gt;java-J-servertest.ScanDirectory<br/> ----_JAVA_LAUNCHER_DEBUG----<br/> JREpathisD:/java/j2sdk1.4.2_04/jre<br/> jvm.cfg[0]=-&gt;-client&lt;-<br/> jvm.cfg[1]=-&gt;-server&lt;-<br/> jvm.cfg[2]=-&gt;-hotspot&lt;-<br/> jvm.cfg[3]=-&gt;-classic&lt;-<br/> jvm.cfg[4]=-&gt;-native&lt;-<br/> jvm.cfg[5]=-&gt;-green&lt;-<br/> 377microsecondstoparsejvm.cfg<br/> JVMpathisD:/java/j2sdk1.4.2_04/jre/bin/server/jvm.dll<br/> 2985microsecondstoLoadJavaVM<br/> JavaVMargs:<br/> version0x00010002,ignoreUnrecognizedisJNI_FALSE,nOptionsis2<br/> option[0]=‘-Djava.class.path=.’<br/> option[1]=‘-Dsun.java.command=test.ScanDirectory’<br/> 62382microsecondstoInitializeJVM<br/> Main-Classis’test.ScanDirectory’<br/> Apps’argcis0<br/> 12413microsecondstoloadmainclass<br/> ----_JAVA_LAUNCHER_DEBUG----<br/> usage:javatest.ScanDirectoryDIR[outputfile]<br/> E:/work/java_research&gt;java-XXaltjvm=D:/java/j2sdk1.4.2_04/jre/bin/servertest.ScanDirectory<br/> ----_JAVA_LAUNCHER_DEBUG----<br/> JREpathisD:/java/j2sdk1.4.2_04/jre<br/> jvm.cfg[0]=-&gt;-client&lt;-<br/> jvm.cfg[1]=-&gt;-server&lt;-<br/> jvm.cfg[2]=-&gt;-hotspot&lt;-<br/> jvm.cfg[3]=-&gt;-classic&lt;-<br/> jvm.cfg[4]=-&gt;-native&lt;-<br/> jvm.cfg[5]=-&gt;-green&lt;-<br/> 376microsecondstoparsejvm.cfg<br/> JVMpathisD:/java/j2sdk1.4.2_04/jre/bin/server/jvm.dll<br/> 2937microsecondstoLoadJavaVM<br/> JavaVMargs:<br/> version0x00010002,ignoreUnrecognizedisJNI_FALSE,nOptionsis2<br/> option[0]=‘-Djava.class.path=.’<br/> option[1]=‘-Dsun.java.command=test.ScanDirectory’<br/> 62725microsecondstoInitializeJVM<br/> Main-Classis’test.ScanDirectory’<br/> Apps’argcis0<br/> 8942microsecondstoloadmainclass<br/> ----_JAVA_LAUNCHER_DEBUG----<br/> usage:javatest.ScanDirectoryDIR[outputfile]</p>\n<p>由上面可以看出，如果我们安装了多个jdk或jre版本的话，使用“java-XXaltjvm=”<br/> 可以通过绝对路径指定到其他版本的jvm.dll上去，至于能不能运行还有待测试。</p>\n<p>我们下面回到java.c的main函数中看看上面找到的jvm.dll是如何装载挂接执行的。</p>\n<p>该操作大致分为三步：<br/> a、装载jvm.dll动态连接库。<br/> b、初始化jvm.dll并挂接到JNIEnv（JNI调用接口）实例。<br/> c、调用JNIEnv实例装载并处理class类。</p>\n<p>实现：<br/> a、装载jvm.dll动态连接库是由main函数调用java_md.c中LoadJavaVM函数实现的。<br/> main函数首先构造了一个InvocationFunctions结构的局部变量，InvocationFunctions<br/> 结构有两个函数指针：<br/> typedefstruct{CreateJavaVM_tCreateJavaVM;GetDefaultJavaVMInitArgs_tGetDefaultJavaVMInitArgs;}InvocationFunctions;<br/> 函数LoadJavaVM中先调用windowsAPI函数：LoadLibrary装载jvm.dll动态连接库，<br/> 之后将jvm.dll中的导出函数JNI_CreateJavaVM和JNI_GetDefaultJavaVMInitArgs<br/> 挂接到InvocationFunctions变量的CreateJavaVM和GetDefaultJavaVMInitArgs函数<br/> 指针变量上。jvm.dll的装载工作宣告完成。</p>\n<p>b、初始化jvm.dll并挂接到JNIEnv（JNI调用接口）实例是通过java.c中函数：<br/> InitializeJVM完成的。<br/> main方法中首先定义了一个JNIEnv结构的指针，JNIEnv结构中定义了许多与装载class<br/> 类文件、查找类方法、调用类方法有关的函数指针变量。InitializeJVM会调用上面<br/> 以挂接jvm.dll中JNI_CreateJavaVM的InvocationFunctions结构变量的CreateJavaVM方法，即调用jvm.dll中函数JNI_CreateJavaVM，该函数会将JNIEnv结构的实例返回到main中的JNIEnv结构的指针上。这样main中的JNIEnv指针获取了JNIEnv实例后，就可以开始对class文件进行处理了。</p>\n<p>c、调用JNIEnv实例装载并处理class类。<br/> a)如果是执行jar包。<br/> 如果执行的是一个jar包的话，main函数会调用java.c中的函数：GetMainClassName，该函数使用JNIEnv实例构造并调用java类：java.util.jar.JarFile中方法getManifest()并从返回的Manifest对象中取getAttributes(“Main-Class”)的值，即jar包中文件：<br/> META-INF/MANIFEST.MF指定的Main-Class的主类名作为运行的主类。<br/> 之后main函数会调用java.c中LoadClass方法装载该主类（使用JNIEnv实例的FindClass）。<br/> b)如果是执行class方法。<br/> main函数直接调用java.c中LoadClass方法装载该类。</p>\n<p>然后main函数调用JNIEnv实例的GetStaticMethodID方法查找装载的class主类中<br/> “publicstaticvoidmain(String[]args)”方法，并判断该方法是否为public方法，然后调用JNIEnv实例的CallStaticVoidMethod方法调用该java类的main方法。</p>\n<p>总结<br/> 由上面的代码分析可以看出几个问题。<br/> a、为什么JDK和JRE不一定通过安装，直接拷到硬盘上，设置path环境变量就可以执行。因为java运行获取jre路径的首选方法正是直接通过获取java.exe绝对路径来判断的，如果通过修改注册表选项而不设置path环境变量也可以找到jre路径所在。修改方法如下：<br/> 首先我们将java.exe拷到任意目录下，我的拷到e:/temp下，在cmd中运行：<br/> 清空path环境变量<br/> E:/temp&gt;setpath=<br/> E:/temp&gt;java<br/> Erroropeningregistrykey’Software/JavaSoft/JavaRuntimeEnvironment’<br/> Error:couldnotfindjava.dll<br/> Error:couldnotfindJava2RuntimeEnvironment.</p>\n<p>导入如下注册表文件（java.reg）<br/> WindowsRegistryEditorVersion5.00[HKEY_LOCAL_MACHINE/SOFTWARE/JavaSoft][HKEY_LOCAL_MACHINE/SOFTWARE/JavaSoft/JavaRuntimeEnvironment]“CurrentVersion”=“1.4”[HKEY_LOCAL_MACHINE/SOFTWARE/JavaSoft/JavaRuntimeEnvironment/1.4]“JavaHome”=“D://java//j2sdk1.4.2_04//jre”</p>\n<p>再执行显示执行正常，如下：<br/> E:/temp&gt;javaUsage:java[-options]class[args…](toexecuteaclass)orjava[-options]-jarjarfile[args…](toexecuteajarfile)whereoptionsinclude:-clienttoselectthe\"client\"VM-servertoselectthe\"server\"VM-hotspotisasynonymforthe\"client\"VM[deprecated]ThedefaultVMisclient.-cp&lt;classsearchpathofdirectoriesandzip/jarfiles&gt;-classpath&lt;classsearchpathofdirectoriesandzip/jarfiles&gt;A;separatedlistofdirectories,JARarchives,andZIParchivestosearchforclassfiles.-D=setasystemproperty-verbose[:class|gc|jni]enableverboseoutput-versionprintproductversionandexit-showversionprintproductversionandcontinue–helpprintthishelpmessage-Xprinthelponnon-standardoptions-ea[:…|:]-enableassertions[:…|:]enableassertions-da[:…|:]-disableassertions[:…|:]disableassertions-esa|-enablesystemassertionsenablesystemassertions-dsa|-disablesystemassertionsdisablesystemassertions<br/> b、java.exe是通过jvm.cfg文件或直接指定jvm.dll路径来装载执行java程序的。<br/> 见上面例子。<br/> c、不同实现版本的jvm.dll必然存在一个名为：JNI_CreateJavaVM的导出函数，<br/> java.exe正是通过调用该函数获得JNIEnv调用接口来装载执行class类的。这个<br/> 函数也是我们下一步研究javavm实作技巧的研究出发点。<br/> JNI_CreateJavaVM函数位于：hotspot/src/share/vm/prims/jni.cpp文件中。<br/> 　　----_JAVA_LAUNCHER_DEBUG----</p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}