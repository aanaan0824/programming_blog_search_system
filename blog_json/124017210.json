{"blogid": "124017210", "writerAge": "码龄1年", "writerBlogNum": "12", "writerCollect": "44", "writerComment": "2", "writerFan": "21", "writerGrade": "2级", "writerIntegral": "132", "writerName": "阿卜Get", "writerProfileAdress": "writer_image\\profile_124017210.jpg", "writerRankTotal": "80972", "writerRankWeekly": "487833", "writerThumb": "7", "writerVisitNum": "10437", "blog_read_count": "2631", "blog_time": "已于 2022-04-08 15:49:17 修改", "blog_title": "Type-C PD快充基础讲解 + 实例（开源）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>现阶段快充的技术应用非常广泛，快充适配器在我们身边也随处可见，那快充是如何实现的呢？是不是有很多小伙伴存在这类的疑惑。那我们今天就一起来会会它，看一看快充是不是如我们想的那般神秘。<br/> 另外，我们身边有各种各样的受电设备需要不同的功率充电或运作，这时候往往需要对应着功率来配置一个适配器。那如果我们能随心所欲的去“控制”快充适配器输出对应的电压，不就能用一个快充适配器来满足不同功率设备的供电吗？这样一来就能解决原装适配器带来的限制，不再为原装适配器的丢失以及损坏而烦恼。<br/> 　并且将快充的技术应用在产品中，可以摆脱设备充电时效率慢及时间长的难题，也可以满足无电池设备的功率问题。那下文我将针对最近比较流行的USB PD快充进行讲解，并演示如何控制适配器输出不同的电压。<br/>    下面我先会简易的讲解一下PD通讯过程，有兴趣想要深入了解USB PD协议的小伙伴可以到 www.usb.org 下载PD协议相关手册。<br/> 1、首先来了解PD通讯数据的基本结构：Preamble + SOP + Message + CRC + EOP。如下图：<br/> (1) Preamble：64bit连续的0/1数据的前导码（0开头，1结尾，频率303kHZ左右）。<br/> (2) SOP：同步码1/2/3组成（包含类型：SOP，SOP`,SOP``），告知是在与Cable/Sink通讯。<br/> (3) Message：Header + Object 用于传递命令、请求、响应。<br/> (4) CRC：CRC-32 用于对消息的校验。<br/> (5) EOP：“01101”用于作为结束标志。<br/><img alt=\"\" src=\"image\\0bef572194b94b94a4c54af46c289ac5.png\"/></p>\n<p>2、PD通讯数据的基本结构我们了解了，那么PD通讯物理层是如何收发消息的呢？废话就不多说了，接下来我将会从接受／发送两部分进行讲解。<br/> 　　先来说下如何发送消息，首先将数据Data和校验码CRC进行4b5b编码后通过BMC发送到CC线上，这就完成PD消息的发送，是不是很简单，也没那么神秘吧！如下图：</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\a0752aca50df44a4ab30389a133efbfa.png\"/><br/>  </p>\n<p></p>\n<p> 至于接收消息刚好和发送消息反过来，当检测到CC上有消息到来时，物理层会通过BMC进行接收，然后检查SOP类型，最后进行4b5b解码，将会得到数据Data和CRC校验码。如下图：</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\6a19eb3f326441339bb14710ebe87bb2.png\"/></p>\n<p></p>\n<p>3、讲到这里应该有小伙伴开始对4b5b编解码、BMC编解码很疑惑吧？其实 4b5b是PD通讯规定的数据手段，这样能有效的避免数据在传输时造成传输错误。BMC编解码则是在数据4b5b转换的基础上进行电平的翻转（0不变，1翻转）。那么数据是如何进行4b5b转换呢？USB PD手册中给出了解答，如下图：</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\208636f5831f449fb0339ce557d4417a.png\"/></p>\n<p></p>\n<p>通过上述简易的分析，可以了解USB PD收发消息的基本概念，能得出PD通讯是需要基于一些硬性条件，比如：需要4b5b编解码、BMC发送、消息校验等。至于博主为什么会在众多单片机产品中选择CH543而不是其它单片机呢？是因为 CH543内置了USB PD收发器PHY和USB Power Delivery控制器，另外PD通讯时是可以自动BMC编解码、4B5B编解码、CRC校验。这样一来不仅能大量的节约代码空间，还能减轻工程带来的难度（嘿嘿，因为不用进行4B5B转码，不用CRC校验，也不用编写前导包。这些都好折磨人，现在可就轻松了不少）。</p>\n<p>  并且CH543是利用USB PD中断来处理PD消息，这一功能是很多单片机不具备的，一般的单片机是通过在while(1)循环中采用查询的方式进行收发消息，这样不仅大量的占用主函数代码空间，同时还会造成代码阅读上不必要的困扰，这样对比一下CH543还是蛮香的。 <img alt=\"\" src=\"image\\68253ab3ded44c0eba8f4e7265432010.png\"/></p>\n<p style=\"text-align:center;\">接下来进入主题了，来看下硬件方面的设计吧，在硬件方面使用了CH543主控MCU的两个引脚（P10：CC1和P11：CC2），就可以轻松实现PD Sink端（是不是觉得不可思议），工程使用的demo板是从www.wch.cn那里申请，有兴趣的小伙伴可以去看看。硬件原理图如下：<img alt=\"\" src=\"image\\607072c63eb44b109f8261407299513d.png\"/></p>\n<p> 现在就来看下效果：</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/3baac84308d8430f8f5d57a2c73b2116.gif\"/></p>\n<p> 硬件方面讲完了，下面来看一下软件方面的处理，我这次编写的是PD Sink受电端，有兴趣的小伙伴可以根据PD快充通讯具体流程（如下图），反推出写出Source供电端（可以做个简易版的适配器）。另外还可以查阅PD 相关资料进行拓展编写VDM、PPS消息等。本文代码将会在文章最后打包奉上（包含：Source、Sink、VDM）。</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"image\\4f6f0f2bb38c4de6bcb274ac1bdf85ad.png\"/></p>\n<p>我本次编写的是受电端Sink，由上图可以知道PD快充的基本操作流程，那么我只需要在合适的场景下及时回复Good CRC和Request，就能完成USB PD通讯。在消息处理上，我是根据CH543 USB PD中断的特点来进行相应消息处理，软件如下：</p>\n<pre><code>void PD_PHY_ISR(void) interrupt INT_NO_USBPD using 1\n{\n\tif ( PIF_RX_RST ) {/*接收到复位信息中断*/\n\t\tprintf(\"RST \");\n\t\tPD_PHY_HRST_ISR();\t\t//收到HRST\n\t\tPD_PHY_RX_INIT();\n\t}\n\tif ( PIF_RX_ACT ){/*数据包接受完成中断*/\n\t    TR0 = 0;  ET0 = 0; \n\t\t\tPIF_RX_ACT = 0;\n\t\tif ( (UPD_INT_FG &amp; MASK_PD_STAT) == PD_RX_SOP0 ) {\t//收到HRST或SOP数据\t\t\n\t\t\tUnion_Header = (_Union_Header *)PD_RX_BUF;    //强制转化\t\t\t\n\t\t\t\t\tif ( PD_PHY_STAT.WaitingGoodCRC ) {\t  //是否在等待GoodCRC\n\t\t\t\t\t  if(Union_Header-&gt;HeaderStruct.MsgType == GoodCRC){\n\t\t\t\t\t\t\tPD_PHY_STAT.WaitingGoodCRC = 0;\t  \t\n\t\t\t\t\t\t\tif(PD_PHY_STAT.SendingRequest == 1){ PD_PHY_STAT.SendingRequest = 0;}\t\n\t\t\t\t\t\t\tSend_Count = 0;\n\t\t\t\t\t\t\tPD_PROT_ISR();      \t\t\t\t\t\n\t\t\t\t}\n\t\t\t}else {\t\t\n\t\t\t\t\tswitch(Union_Header-&gt;HeaderStruct.MsgType)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase SourceCap:\n\t\t\t\t\t\t\t\t NDORcv=Union_Header-&gt;HeaderStruct.NDO;\n\t\t\t\t\t\t\t   memcpy(PD_Source,PD_RX_BUF,30);\n\t\t\t\t\t\t\t\t PD_PHY_STAT.SendingRequest = 1;\n\t\t\t\t\t\t\t\t break;\n\t\t\t\t\t\tcase Request:\n\t\t\t\t\t\t\t\t break;\n\t\t\t\t\t\tcase Accept:\n\t\t\t\t\t\t\t   MsgID ++;\n\t\t\t\t\t\t\t\t break;\n\t\t\t\t\t\tcase Reject:\n\t\t\t\t\t\t\t\t break;\n\t\t\t\t\t\tcase PS_RDY:\n\t\t\t\t\t\t\t\t break;\n\t\t\t\t\t\tcase GetSrcCap:\n\t\t\t\t\t\t\t    MsgID++;\n\t\t\t\t\t\t\t   PD_PHY_STAT.SendingSourceCap = 1;\n\t\t\t\t\t\t     break;\n\t\t\t\t\t\tcase GetSinkCap:\n\t\t\t\t\t\t\t\t MsgID++;\n\t\t\t\t\t\t\t\t PD_PHY_STAT.SendingSinkCap = 1;\t  \n\t\t\t\t\t\t\t\t break;\n\t\t\t\t\t  case SourceCap_VDM:\n\t\t\t\t\t\t\t\t break;\t\n\t\t\t\t\t\tdefault :\n\t\t\t\t\t\tbreak;\t\n\t\t\t\t\t}\n\t\t\t\t\t\tmDelayuS(25);\n\t\t\t\t\t  PD_PHY_STAT.SendingGoodCRC = 1;\t//置发送GoodCRC标志位\n\t\t\t\t\t\tPD_PHY_TX_GoodCRC();\t\t\t\t//回复GoodCRC\t\n\t\t\t}\t\n\t}else PD_PHY_RX_INIT();\n}\n\tif ( PIF_TX_END ) {\t\t/*数据包发送完成中断 */\n\t  \tPIF_TX_END = 0;\n\t\t\tif(CCSel == 1){  //发送完成关闭低压\n\t\t\t\tCC1_CTRL &amp;= ~bCC_LVO;\t\n\t\t\t}else if(CCSel == 2){\n\t\t\t CC2_CTRL &amp;= ~bCC_LVO;\t\n\t\t\t}\t    \n\t\tif ( PD_PHY_STAT.SendingGoodCRC ==1 ) {                       \n\t\t\tPD_PHY_STAT.SendingGoodCRC = 0;\n\t\t\tPD_PROT_ISR(); //GoodCRC发送完成，向Prot转交数据\n\t\t}else {\t\t\t/*开始接收GoodCRC*/\n\t\t\t\t\tPD_PHY_STAT.WaitingGoodCRC = 1;\t\n\t\t\t\t\t   mTimer_x_SetData(10000);    //5ms\n\t\t\t\t\tPD_PHY_RX_INIT();\n\t\t}\n\t}\n}\n</code></pre>\n<p style=\"text-align:center;\"> 因为作为Sink端请求电压是最为重要的，那么该如何来请求电压呢？里面将会涉及到怎样的知识点？下图就详细讲解了PD Request数据各个位的作用。有兴趣的小伙伴可以查阅USB PD协议对应着理解。<img alt=\"\" src=\"image\\7d83924144e54e21819eb68da5e1ccae.png\"/></p>\n<p>根据上图提示，进行软件编写Request，因为Request包含一个请求项Data Object，所以NDO固定为1（表示Header之后有几个字节的数据）。<br/>    Message ID是根据消息次序来决定（一般Sink发送Request为起始0，后续Sink发送时ID自动加一，回复Good CRC除外），Message ID最大为7，若超过则从0重新计数。<br/> PorPwrRole表示电源角色，Source为1，Sink为0。<br/> Rev2表示PD的版本信息，0x01表示PD2.0,0x10表示PD3.0。<br/>    PortDataRole表示数据角色，根据需求来填写主从，1表示主，0表示从。<br/>    MessageType表示此项内容是什么类型数据，0x02表示Request，0x01表示GoodCRC。<br/>    Objpos 表示请求SourceCap档位中的第几项，1：第一项、2：第二项、、、、<br/>    Capability Mismatch表示能力不匹配，0：匹配，1：不匹配。<br/>    USB Communications 表示USB通讯能力，按需求配置。<br/>    No USB Suspend 表示没有USB挂起，0：有USB挂起，0：没有USB挂起。<br/>    Unchunked Extended Message 未分块的扩展信息。<br/>    Operation Current in 10mA units表示请求电压的电流大小。<br/>    Max Operation Current in 10mA units表示最大承受电流。<br/>  下面是用CH543编写Request的代码：</p>\n<pre><code>void PD_PHY_TX_Request(void)\n{\n\tUINT16 Volt_Value;\n  UINT8 temp=0xff;  //pdo 档位\n\tUINT8 i;\n\tUINT16 Temp;\n\tUINT16 Data_H8;\n\tUINT16 Cur_Temp = 0; \n\t\n\tfor (i=0;i!=NDORcv;i++) \n\t{\n\t\t\tUnion_SrcCap = (_Union_SrcCap *)&amp;PD_Source[2+(4*i)];  \n\t\t\tData_H8 = (Union_SrcCap-&gt;SrcCapStruct.DataH8);\n\t\t\tif((Data_H8 &gt;&gt; 6 ) == 3)\n\t\t\t{\n\t\t\t\t\tPPS_Flag = 1;\n\t\t\t\t\tprintf(\"\\r %d is PPS\\n\",(UINT16)(i+1));\n\t\t\t}else{\n\t\t\t\t\t\t\tTemp = (PD_Source[3+(i&lt;&lt;2)] &gt;&gt; 2)+((PD_Source[4+(i&lt;&lt;2)] &amp; 0x0F)&lt;&lt;6);\n\t\t\t\t\t\t\tTemp*=50;\n\t\t\t\t\t\t\tif (Temp &lt;= Volt_Value ) \n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif(Temp &gt; Cur_Temp) \n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tCur_Temp = Temp;\n\t\t\t\t\t\t\t\t\ttemp = i+1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t }\n\t}\n\tif(Temp_PDO != temp )\n\t{\n\t\tprintf(\"No requested voltage! \\r\\n\");\n\t\tprintf(\"Request adjacent voltage! \\r\\n\");\n\t}\n\tif(temp != 0xff)\n\t{\n\t\t\tUPD_T_SOP = UPD_SOP0;\n\t\t\tUPD_T_LEN = 6;\n\t\t\tPD_TX_BUF[5] =( (temp&lt;&lt;4) | 0x02);\n\t\t\tPD_TX_BUF[4] = ((PD_Source[3+((temp - 1)&lt;&lt;2)]&amp;0x03)&lt;&lt;2) |(PD_Source[2+((temp - 1)&lt;&lt;2)]&gt;&gt;6) | (PD_Source[4+((temp - 1)&lt;&lt;2)] &amp;0xF0);\n\t\t\tPD_TX_BUF[3] =(PD_Source[3+((temp - 1)&lt;&lt;2)]&amp;0x03) | (PD_Source[2+((temp - 1)&lt;&lt;2)]&lt;&lt;2);\n\t\t\tPD_TX_BUF[2] = PD_Source[2+((temp - 1)&lt;&lt;2)];\n\t\t\tPD_TX_BUF[1] = (0x10 | (MsgID &lt;&lt; 1));\n\t\t\tPD_TX_BUF[0] =0x02 | (0xC0 &amp; PD_Source[0]);\n\t\t\tPD_PHY_TX_INIT();\n\t}else{\t\n\t  printf(\"No Matched Volt.\\r\\n\");\n\t}\n}</code></pre>\n<p> 相信很多小伙伴都有发现PD进行充电时，充电电压并不是一直保持不变的，而是可以动态切换请求电压，那是如何进行动态切换的呢？动态请求电压会出现什么样的现象？针对这一个疑惑，我就利用IO中断来对请求的档位进行加减，实现这样现象。软件代码如下：</p>\n<pre><code>\tif(Gears_Plus == 1)\n\t{\n     if(P1_5 == 1)\n\t\t {\n\t\t\t PD_Request_Gears += 1;\n\t\t\t Gears_Plus = 0;\n\t\t }\n\t\tif(PD_Request_Gears&gt;5)\t\n\t\t {\n      PD_Request_Gears = 1;\n\t\t }\t\t\t\n\t}\n\tif(Gears_Sub == 1)\n\t{\n\t\t if(P1_4 == 1)\n\t\t {\n\t\t\t PD_Request_Gears -= 1;\n\t\t\t Gears_Sub = 0;\n\t\t }\n     if(PD_Request_Gears&lt;1)\t\n\t\t {\n      PD_Request_Gears = 5;\n\t\t }\t\t\t \n\t}\n\t</code></pre>\n<p> 通过验证动态请求电压是可行的（如下图），这样的话各位小伙伴可以利用快充适配器来得到一个动态电压（5V、9V、12V、15V、20V），提供给不同的用电设备使用，也可以将USB PD快充的技术应用到自己的产品中，不就能摆脱了传统充电时间长和功率小的问题了嘛！</p>\n<p>至此PD Sink端的应用就要告一段落了，附件是硬件、软件资料，小伙伴们可以按需下载。</p>\n<p><a href=\"https://bbs.21ic.com/icview-3205568-1-1.html\" title=\"PD快充也没那么神秘（开源资料） - 单片机论坛,单片机技术交流论坛 - 21ic电子技术开发论坛\">PD快充也没那么神秘（开源资料） - 单片机论坛,单片机技术交流论坛 - 21ic电子技术开发论坛</a></p>\n</div>\n</div>"}