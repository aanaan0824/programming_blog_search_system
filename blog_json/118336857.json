{"blogid": "118336857", "writerAge": "码龄2年", "writerBlogNum": "35", "writerCollect": "127", "writerComment": "11", "writerFan": "124", "writerGrade": "2级", "writerIntegral": "394", "writerName": "代码搬运工小菜狗", "writerProfileAdress": "writer_image\\profile_118336857.jpg", "writerRankTotal": "83791", "writerRankWeekly": "485344", "writerThumb": "29", "writerVisitNum": "18547", "blog_read_count": "2085", "blog_time": "已于 2022-06-05 11:18:27 修改", "blog_title": "C++面向对象程序设计期末复习笔记[吉林大学](结合历年题速成85)", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-tomorrow-night\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h2><a id=\"1_0\"></a>1.头文件</h2>\n<p>头文件的作用就是被其他的.cpp包含进去的.它们本身并不参与编译，但实际上,它们的内容却在多个.cpp文件中得到了编译.根据\"定义只能一次\"原则我们知道,头文件中<strong>不能放定义</strong>.(注:<code>int a;</code>是定义，开辟存储空间了，而 <code>extern int a;</code>是一个声明,因为没有开辟空间)</p>\n<p>但是,\"不能放定义\"这个规则有三个例外:</p>\n<p>1)可放<strong>const</strong>对象的定义.因为全局的const对象链接属性默认是<strong>内部链接</strong>，所以只在当前文件有效.所以即使头文件被包含到多个<code>.cpp</code>文件中,这个对象也都只在包含它的那个文件中有效,对其他文件来说是不可见的,所以便不会导致多重定义.同理,<strong>static</strong>对象的定义也可以放进头文件.</p>\n<p>2)可放<strong>内联</strong>(inline)函数的定义.遇到inline函数时,编译器就需要把它内联展开(根据它的定义),而并非普通函数那样可先声明再链接(内联函数<strong>不会链接</strong>),所以编译器就需要在编译时看到内联函数的完整定义才行.inline函数若只能定义一次可就太麻烦了,所以C++规定内联函数可以<strong>定义多次</strong>,只要其在一个<code>.cpp</code>文件中只出现一次且在所有<code>.cpp</code>文件中，这个内联函数的定义是一样的，就能通过编译.故把内联函数定义放进头文件,是个明智的做法.</p>\n<p>3)可放<strong>类定义</strong>.创建类的对象时,编译器需要清楚这个类的定义,才能分配空间,所以应该把类定义放到头文件中.在C++中,如果函数成员在类的定义体中被定义,那么编译器会视这个函数为<strong>内联的</strong>.因此把函数成员的定义写进类定义体,一起放进头文件中是合法的.(注:但是如果把函数成员的定义写在类定义的头文件中但没有写进类定义,是不合法的,因为这个函数成员此时就不是内联的了;一旦头文件被两个或两个以上的<code>.cpp</code>文件包含,这个函数成员就被重定义了.)</p>\n<p><strong>综上,头文件的规范</strong><br/> 1)一般包括类定义,函数声明,extern变量(注:定义于函数外的变量称作外部变量, 函数内的变量称为局部变量;若在函数内部定义了与外部变量名称相同的变量, 则不会使用外部变量)<br/> 2)在编译时已知的const对象定义(用常量表达式初始化)<br/> 3)inline函数的定义<br/> 4)类定义中,能用指针或引用的就别用对象进行声明,因为引用和指针只需一个类型声明,而对象需要该类型的定义,此时要为声明式和定义式提供不同的头文件.<br/> 5)头文件中不能用<code>using</code>:<br/> e.g.只能用<code>std::cin&gt;&gt;a;</code>而不能写<code>using std cin; cin&gt;&gt;a;</code><br/> <strong>头文件卫士</strong><br/> 当<code>b.h</code>中include了<code>a.h</code>,而且一个程序员在不知情的情况下在一个<code>.cpp</code>文件中同时include了<code>a.h</code>和<code>b.h</code>,这就在同一个文件中include了<code>a.h</code>两次,虽然以上写的三个例外在多个源文件中可以被定义,但却不可以在同一个源文件中定义两次,这就出现问题了.为了解决这种问题,需要用头文件卫士<code>#ifndef,#define....#endif</code></p>\n<h2><a id=\"2extern_20\"></a>2.变量声明(特总结extern)</h2>\n<p>变量声明相当于向编译器保证此变量以给定的名称和类型存在,使得编译器不需要知道变量完整细节即可继续编译,可以在程序中多次声明一个变量,但是一个变量只能在某个函数,代码块或文件中被<strong>定义一次</strong>.<br/> 当你在<code>a.cpp</code>中声明了一个extern变量<code>var</code>后,你可以在<code>a.cpp</code>中用这个变量,声明语句告诉了编译器:这个符号是在其他文件中定义的，我这里先用着，你链接的时候再到别的地方去找找看它到底是什么吧.但注意:extern变量必须是能够引用到的,也即被引用的变量<strong>var是外链接的</strong>,C++中能够被其他模块以extern修饰符引用到的变量通常是<strong>全局变量</strong>。<br/> 注:你不能写<code>extern int i=3;</code>这种语句,会被编译器提示不能对外部变量的局部声明进行初始化;但是你可以分两步:</p>\n<pre><code class=\"prism language-cpp\">\t<span class=\"token keyword\">extern</span> <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">;</span>\n\ti<span class=\"token operator\">=</span><span class=\"token number\">3</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//这种写法就是对的了</span>\n</code></pre>\n<p><strong>extern 修饰函数声明</strong></p>\n<p>如果<code>a.cpp</code>里有一个函数<code>int f(int x)</code>那么可以在<code>b.cpp</code>里<code>extern int f(int x)</code><br/> 那么这样直接引用和用头文件引用函数有何区别?这样做的一个明显的好处是，会加速程序的编译（确切的说是预处理）的过程,节省时间.</p>\n<h2><a id=\"3_33\"></a>3.构造函数与析构函数</h2>\n<p>★<br/> 实现自定义构造函数<strong>必须使用初始化列表</strong>的情况:</p>\n<p>1)类中有const数据成员,e.g.<code>const int num;</code>(注:const对象或引用只能初始化但是不能赋值,构造函数的函数体内只能<strong>赋值</strong>而不能初始化,因此初始化const对象或引用的<strong>唯一机会</strong>是构造函数函数体之前的初始化列表中.)(换种说法:常量<strong>只能初始化不能赋值</strong>，所以必须放在初始化列表里面)<br/> 2)类中有引用型数据成员,e.g.<code>int&amp;a;</code>引用必须在定义的时候初始化，并且不能重新赋值,所以也要写在初始化列表里面<br/> 3)类中有对象成员但其类型中没有无参构造函数,所以必须在初始化列表中指明相应有参构造函数.<br/> 4)基类中缺少无参构造函数,必须在初始化列表中指明基类的有参构造函数.<br/> 5)没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化，而是直接调用拷贝构造函数初始化</p>\n<p>★<br/> <strong>派生类构造函数的初始化列表问题</strong>:</p>\n<p>派生类构造函数的初始化列表可以包含:</p>\n<ol><li>基类的无参构造函数</li><li>基类的拷贝构造函数</li><li>派生类中非静态对象成员的初始化</li><li>派生类的子对象初始化(//q:跟3是不是一码事?)</li><li>派生类中一般数据成员的初始化</li></ol>\n<p>不能包含:</p>\n<ol><li>基类中非静态对象成员的初始化</li><li>基类成员变量(例如:<code>int base_a;</code>的初始化,如果非要初始化基类中的成员,只能调用基类的有参构造函数进行初始化,如下:)</li></ol>\n<pre><code class=\"prism language-cpp\"> \t<span class=\"token function\">B</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span><span class=\"token function\">A</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span><span class=\"token punctuation\">}</span><span class=\"token comment\">//基类A的有参构造函数为A(int i=0):base_a(i){}</span>\n</code></pre>\n<p>(或者如下:)</p>\n<pre><code class=\"prism language-cpp\">\t<span class=\"token function\">B</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>a<span class=\"token operator\">=</span><span class=\"token number\">5</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span><span class=\"token comment\">//不在初始化列表中直接初始化的基类的数据成员,这样是可以的</span>\n\t<span class=\"token comment\">//但这种方法的原理不再是初始化,而是改变a原本的值!!</span>\n\t<span class=\"token comment\">//当然,你应该尽量使用初始化列表而非赋值.</span>\n\t<span class=\"token comment\">//注:B不能访问A的私有成员 只可访问保护成员!</span>\n</code></pre>\n<p>★<br/> <strong>创建派生类对象时,构造函数的执行顺序</strong></p>\n<p>1.基类的构造函数<br/> 若有初始化列表中的显式调用基类的有参构造函数,就调用<br/> 若无,则编译器把基类的<strong>默认构造函数插入到初始化列表中</strong>，即<code>B() =&gt; B():A()</code><br/> 2.对象成员的构造函数<br/> 若在初始化列表中则直接调用<strong>拷贝构造</strong>函数</p>\n<p>3.派生类的构造函数</p>\n<p><strong>★<br/> 调用拷贝构造函数的情况:</strong><br/> 1)用类的一个对象去初始化另一个对象时<br/> 2)函数的形参是类的对象,调用函数,进行<strong>形参与实参的结合</strong>时<br/> 3)函数的返回值是类的对象，函数完成调用返回时（产生一个<strong>临时对象</strong>）</p>\n<p>★<br/> <strong>析构函数私有化(或者protected化)</strong><br/> 析构函数私有化可以保证一个对象只在堆上生成,只能用new生成.而且不能delete,因为delete会调用析构函数.想要把它释放,需要弄一个成员函数完成delete操作.如下:</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">void</span> <span class=\"token class-name\">OnlyCanBeNew</span><span class=\"token double-colon punctuation\">::</span><span class=\"token function\">Destroy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> \n<span class=\"token punctuation\">{<!-- --></span> \n    <span class=\"token keyword\">delete</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">}</span> \n</code></pre>\n<p>(注:既然只允许delete对象,那么该对象一定是建立在堆上的,因此应禁止用户在函数外直接调用构造函数在栈上,因此构造函数也应是private的)</p>\n<p>○还有一种情况,当你想在析构之前再完成一些事情的时候,可以先把直接的析构函数给private化,再写一个函数先去完成你想让这个函数在析构函数之前做的事情,再在函数最后执行析构函数,如下:</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">A</span>\n<span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n   <span class=\"token function\">A</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span><span class=\"token punctuation\">}</span>\n   <span class=\"token keyword\">void</span> <span class=\"token function\">ReleaseObject</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n   <span class=\"token punctuation\">{<!-- --></span>\n      <span class=\"token comment\">//可以在这之前做一些其他事情</span>\n      <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n      <span class=\"token operator\">~</span><span class=\"token function\">A</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//最后析构</span>\n   <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">private</span><span class=\"token operator\">:</span>\n   <span class=\"token operator\">~</span><span class=\"token function\">A</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>这样就没有办法delete了，因为<code>~A()</code>无法被别人调用。但是别人可以通过调用<br/> public的函数<code>ReleaseObject</code>，这个函数本身是有权利调用<code>~A()</code>的。这样就确<br/> 保了在析构之前一定会做一些你想做的事情。这也可以说<code>~A()</code>被<code>ReleaseObject</code>函数包装起来了.</p>\n<h2><a id=\"4_121\"></a>4.各种关系(组合,聚合等)</h2>\n<p>★<br/> <strong>组合与聚合</strong><br/> (组合是聚合的一种形式)组合与聚合的有本质上的区别:</p>\n<p>○若A与B是组合关系,则B在A<strong>创建的时刻</strong>创建,A包含有B的全局对象(???没看懂这句话)</p>\n<p>组合方式一般代码会这样写：<br/> A类的构造函数中创建B类的对象,即当A类的一个对象产生时,B类的对象随之产生,当A类的这个对象消亡时,它所包含的B类的对象也随之消亡.</p>\n<p>○若A与B是聚合关系,则A可以包含B对象,但B不是A的组成成分,A包含有B的全局对象,但B可以不在A创建的同时创建.</p>\n<p>聚合方式一般代码会这样写：<br/> A类的对象在创建时不会立即创建B类的对象,而是等待一个外界的对象<strong>传给它</strong></p>\n<p>e.g.在A类中引用B类的一个引用b，当A类消亡时，b这个引用<strong>所指对象也<br/> 同时消亡</strong>（没有任何一个引用指向它，成了<strong>垃圾对象</strong>），这种情况叫组合;<br/> 反之b所指的对象还会有另外的引用它，这种情况叫聚合</p>\n<p>★<br/> <strong>依赖关系,泛化关系</strong></p>\n<p>○依赖关系<br/> 如果在类中用到对方(如:<strong>作为类的成员;作为函数返回值;作为函数接受的参数;在函数中被使用到</strong>),少了对方连编译都无法通过,则称为依赖关系.</p>\n<p>○泛化关系<br/> 泛化关系其实就是<strong>继承关系</strong>,是依赖关系的<strong>特例</strong>.(若B类继承了A类,称AB间存在泛化关系)</p>\n<p><strong>注:依赖关系耦合最弱!!</strong></p>\n<h2><a id=\"5_152\"></a>5.虚函数,虚基类(各种虚)</h2>\n<p>虚函数的作用是允许在派生类中重新定义与基类同名的函数，并且可以通过<strong>基类指针或引用</strong>来访问基类和派生类中的同名函数。</p>\n<p>★<br/> <strong>虚函数特点以及一些注意事项:</strong><br/> 1)可以<strong>寻址</strong>;这一点就排除了构造函数和内联函数.(注:虚函数可以是内联函数,但是在虚函数表现<strong>多态性</strong>的时候不能inline.因为虚函数是在<strong>运行期表现多态性</strong>,而inline是在<strong>编译期</strong>让编译器来判断能否inline)因为虚函数表中存放的是虚函数入口地址,如果函数不能寻址,自然不能是虚函数.<br/> 2)依赖于对象调用.因为虚函数存在于虚函数表中,有一个虚函数指针指向这个表,所以要调用虚函数,必须通过<strong>虚函数指针</strong>,而虚函数指针是存在于对象中的.<br/> 3)动态联编规定，只能通过指向基类的<strong>指针</strong>或基类对象的<strong>引用</strong>来调用虚函数，其格式：<br/> 　　指向基类的指针变量名-&gt;虚函数名（实参表）<br/> 　　或 基类对象的引用名. 虚函数名（实参表）<br/> 4)类的成员函数中<strong>静态</strong>成员函数也不能是虚函数,因为静态成员函数不属于任何一个对象或实例,也就不存在this指针的使用,而虚函数表恰恰要用this指针(<strong>this指针-&gt;vptr(4字节）-&gt;vtable -&gt;virtual虚函数</strong>)<br/> 5)只需要在声明函数的类体中使用关键字“virtual”将函数声明为虚函数，而定义函数时<strong>不需要</strong>使用关键字“virtual”.<br/> 6)当将基类中的某一成员函数声明为虚函数后,派生类中的同名函数<strong>自动成为虚函数</strong></p>\n<p>★<br/> <strong>虚基类:</strong><br/> “B和C同时继承A，而B和C都被D继承”这种菱形的继承结构,需要用到虚基类.<br/> 其实这种情况下,除了虚基类之外,还可以用<strong>作用域标识符</strong>来区分B和C中的func(),如B::func().</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;iostream&gt;</span></span>\n     <span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n     <span class=\"token keyword\">class</span> <span class=\"token class-name\">A</span><span class=\"token punctuation\">{<!-- --></span>\n     \t<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n     \t\t<span class=\"token function\">A</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>a<span class=\"token operator\">=</span><span class=\"token number\">5</span><span class=\"token punctuation\">;</span>cout<span class=\"token operator\">&lt;&lt;</span><span class=\"token string\">\"A=\"</span><span class=\"token operator\">&lt;&lt;</span>a<span class=\"token operator\">&lt;&lt;</span>endl<span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span>\n     \tprocted<span class=\"token operator\">:</span>\n     \t\t<span class=\"token keyword\">int</span> a<span class=\"token punctuation\">;</span>\n     \t<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">class</span> <span class=\"token class-name\">B</span><span class=\"token operator\">:</span><span class=\"token base-clause\"><span class=\"token keyword\">public</span> <span class=\"token class-name\">A</span></span><span class=\"token punctuation\">{<!-- --></span>\n    \t<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    \t\t<span class=\"token function\">B</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    \t\t<span class=\"token punctuation\">{<!-- --></span>a<span class=\"token operator\">=</span>a<span class=\"token operator\">+</span><span class=\"token number\">10</span><span class=\"token punctuation\">;</span>cout<span class=\"token operator\">&lt;&lt;</span><span class=\"token string\">\"B=\"</span><span class=\"token operator\">&lt;&lt;</span>a<span class=\"token operator\">&lt;&lt;</span>endl<span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">class</span> <span class=\"token class-name\">C</span><span class=\"token operator\">:</span><span class=\"token base-clause\"><span class=\"token keyword\">public</span> <span class=\"token class-name\">A</span></span><span class=\"token punctuation\">{<!-- --></span>\n    \t<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    \t\t<span class=\"token function\">C</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>a<span class=\"token operator\">=</span>a<span class=\"token operator\">+</span><span class=\"token number\">20</span><span class=\"token punctuation\">;</span>cout<span class=\"token operator\">&lt;&lt;</span><span class=\"token string\">\"C=\"</span><span class=\"token operator\">&lt;&lt;</span>a<span class=\"token operator\">&lt;&lt;</span>endl<span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">class</span> <span class=\"token class-name\">D</span><span class=\"token operator\">:</span><span class=\"token base-clause\"><span class=\"token keyword\">public</span> <span class=\"token class-name\">B</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">public</span> <span class=\"token class-name\">C</span></span><span class=\"token punctuation\">{<!-- --></span>\n    \t<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    \t\t<span class=\"token function\">D</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n    \t\tcout<span class=\"token operator\">&lt;&lt;</span><span class=\"token string\">\"B::a=\"</span><span class=\"token operator\">&lt;&lt;</span>B<span class=\"token double-colon punctuation\">::</span>a<span class=\"token operator\">&lt;&lt;</span>endl<span class=\"token punctuation\">;</span>\n    \t\tcout<span class=\"token operator\">&lt;&lt;</span><span class=\"token string\">\"C::a=\"</span><span class=\"token operator\">&lt;&lt;</span>C<span class=\"token double-colon punctuation\">::</span>a<span class=\"token operator\">&lt;&lt;</span>endl<span class=\"token punctuation\">;</span>\n    \t\t<span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\t\n <span class=\"token keyword\">int</span>  <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n  D obj<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n</code></pre>\n<p>以上程序的构造函数调用顺序:<code>A() B() A() C()</code>;因为先定义B,而B又是派生自A,所以先调用A的构造函数,再B的构造函数,又定义了C,同理.</p>\n<p><strong>但是</strong>,我们来看如果定义为虚基类(也就是在继承的那个冒号和\"<code>public A</code>\"之间再加一个\"<code>virtual</code>\"即\"<code>virtual public A</code>\")(其实写成\"<code>public virtual A</code>\"也是一样的),此时ABC三个类里的数据成员a不再是无关联的,BC中的a不再是A中<strong>拷贝过去</strong>的a,相反的,现在这个a由基类A,两个派生类B,C所<strong>共有</strong>,BC构造函数对同一个a进行修改.如下:</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;iostream&gt;</span></span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">class</span> <span class=\"token class-name\">A</span><span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n\t\t<span class=\"token function\">A</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n\t\t\ta<span class=\"token operator\">=</span><span class=\"token number\">5</span><span class=\"token punctuation\">;</span>cout<span class=\"token operator\">&lt;&lt;</span><span class=\"token string\">\"base=\"</span><span class=\"token operator\">&lt;&lt;</span>a<span class=\"token operator\">&lt;&lt;</span>endl<span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span>\n\n\t<span class=\"token keyword\">protected</span><span class=\"token operator\">:</span>\n\t <span class=\"token keyword\">int</span> a<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">B</span><span class=\"token operator\">:</span><span class=\"token base-clause\"><span class=\"token keyword\">virtual</span> <span class=\"token keyword\">public</span> <span class=\"token class-name\">A</span></span><span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n\t\t<span class=\"token function\">B</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>a<span class=\"token operator\">+=</span><span class=\"token number\">10</span><span class=\"token punctuation\">;</span>cout<span class=\"token operator\">&lt;&lt;</span><span class=\"token string\">\"base1=\"</span><span class=\"token operator\">&lt;&lt;</span>a<span class=\"token operator\">&lt;&lt;</span>endl<span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">C</span><span class=\"token operator\">:</span><span class=\"token base-clause\"><span class=\"token keyword\">virtual</span> <span class=\"token keyword\">public</span> <span class=\"token class-name\">A</span></span><span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n\t <span class=\"token function\">C</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>a<span class=\"token operator\">+=</span><span class=\"token number\">20</span><span class=\"token punctuation\">;</span>cout<span class=\"token operator\">&lt;&lt;</span><span class=\"token string\">\"base2=\"</span><span class=\"token operator\">&lt;&lt;</span>a<span class=\"token operator\">&lt;&lt;</span>endl<span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">D</span><span class=\"token operator\">:</span><span class=\"token base-clause\"><span class=\"token keyword\">public</span> <span class=\"token class-name\">B</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">public</span> <span class=\"token class-name\">C</span></span><span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n\t\t<span class=\"token function\">D</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>cout<span class=\"token operator\">&lt;&lt;</span><span class=\"token string\">\"derived a =\"</span><span class=\"token operator\">&lt;&lt;</span>a<span class=\"token operator\">&lt;&lt;</span>endl<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\nD obj<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>我们此时再看他们的构造函数执行顺序:<br/> 首先B和C都是由A派生出来的,所以先<strong>统一</strong>构造A,调用A的构造函数;然后,按照顺序调用B和C的构造函数,总体顺序是这样:<code>A() B() C();</code></p>\n<p>*同一层级的继承中,基类的顺序:<strong>虚基类优先于非虚基类构造函数的执行</strong><br/> *如果一个派生类有一个直接或<strong>间接</strong>的虚基类,那么派生类的构造函数的成员初始化列表中<strong>必须</strong>列出对虚基类构造函数的调用,如果未被列出,则表示使用该虚基类的<strong>缺省构造函数</strong>来初始化派生类对象中的虚基类对象.所以,要求这个虚基类必须要有无参构造函数,没有的话会报错.</p>\n<p>注:<br/> 1.基类的析构函数<strong>必须</strong>定义为virtual,如果不是虚函数的话,<strong>子类的析构函数将不被调用</strong>,就没法正确释放子类的空间,造成内存泄漏.(见下一个主题内存泄漏)</p>\n<p><strong>★<br/> 纯虚函数和抽象类</strong></p>\n<p>纯虚函数:就是<strong>没有函数体</strong>而直接在括号后边写\"=0\"的函数:e.g.<code>virtual double func()=0;</code><br/> 意义:如果是一个纯虚函数,则在虚函数表中,其函数<strong>指针的值就是0</strong>.即如果是纯虚函数,那么就在虚函数表中实实在在的写上0,如果是普通的虚函数,那就肯定是一个有意义的值(入口地址).<br/> 我们把含有纯虚函数的类称作抽象类.当基类是一个抽象类时,子类也可以是抽象类,当然也可以不是抽象类.例如基类base里面有俩纯虚函数<code>virtual int f1()=0,virtual double f2()=0,</code>在子类child1里面,我们把f1\"非纯虚函数化\"也就是用函数体代替掉\"=0\",例如可以<code>virtual int f1(){printf(\"000\");}</code>而保持<code>virtual double f2()=0</code>,这样的话child1仍然是个抽象类,无法实例化;然后再让子类child2去继承child1,并且把f2也变成非纯虚函数,这时child2就不再是抽象类,而可以实例化了.</p>\n<h2><a id=\"6_254\"></a>6.内存泄漏</h2>\n<p>造成内存泄漏的可能原因:</p>\n<p>1)当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄漏<br/> 2)delete掉一个void*类型的指针，导致没有调用到对象的析构函数，析构的所有清理工作都没有去执行从而导致内存的泄漏,如下:</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n\tObject<span class=\"token operator\">*</span> a <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token function\">Object</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token char\">'A'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//Object*指针指向一个Object对象；\t</span>\n\t<span class=\"token keyword\">void</span><span class=\"token operator\">*</span> b <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token function\">Object</span><span class=\"token punctuation\">(</span><span class=\"token number\">20</span><span class=\"token punctuation\">,</span> <span class=\"token char\">'B'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//void*指针指向一个Object对象；</span>\n\t<span class=\"token keyword\">delete</span> a<span class=\"token punctuation\">;</span><span class=\"token comment\">//执行delete，编译器自动调用析构函数；</span>\n\t<span class=\"token keyword\">delete</span> b<span class=\"token punctuation\">;</span><span class=\"token comment\">//执行delete，但编译器不调用析构函数，导致data的内存没回收;</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>3)new创建了一对象数组,内存回收时却只调用了delete,没用<strong>delete []</strong>,导致只有对象数组的<strong>第一个对象的析构函数</strong>得到执行并回收了内存,数组的其他对象所占内存得不到回收导致内存泄漏；<br/> 4)浅拷贝,两个指针指向同一块内存,这样析构的时候两个对象两次析构,则同一块内存空间被释放2次,造成内存泄漏.所以如果一个类里面有指针成员变量，要么必须显式地写<strong>拷贝构造函数</strong>和<strong>重载赋值运算</strong>符，要么<strong>禁用</strong>拷贝构造函数和重载赋值运算符<br/> 5)指针数组的情况,只释放了数组,没释放每个指针元素指向的内存空间(应先用一个<strong>循环释放</strong>掉每个指针元素指向的内存空间,再delete[] arr.</p>\n<h2><a id=\"7const_273\"></a>7.const辨析</h2>\n<p>在函数中,若参数用<strong>值传递</strong>,则不需要加const,加了也没用,因为函数将自动产生<strong>临时变量</strong>用于复制该参,该输入参数本来就无需保护.若用指针或引用传递且我们不希望改变参数的值,那么加上const就可以保护参数免于被改变:e.g. <code>void Func(const A &amp;a)</code>.<br/> 那么是否应将<code>void Func(int x)</code> 改写为<code>void Func(const int&amp;x)</code>,以便提高效率？完全没有必要,因为<strong>内部</strong>数据类型的参数不存在构造,析构的过程,而复制也非常快,“值传递”和“引用传递”的效率几乎相当。<br/> 故对于<strong>非内部数据类型</strong>的输入参数,应该将“值传递”的方式改为“const引用传递”以提高效率,例如将<code>void Func(A a)</code> 改为<code>void Func(const A &amp;a)</code>.</p>\n<p><strong>★<br/> const在函数前后的辨析</strong></p>\n<p>○const在前:用const修饰函数的返回值.<br/> 如果给以“指针传递”方式的函数返回值加const修饰，那么函数返回值（即指针）的内容不能被修改，该返回值只能被赋给<strong>加const修饰的同类型指针</strong>,如下:</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span> <span class=\"token function\">GetString</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span><span class=\"token operator\">*</span> pt <span class=\"token operator\">=</span> <span class=\"token function\">GetString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//不能写char* pt= GetString();</span>\n</code></pre>\n<p>但是,如果函数返回值采用<strong>值传递</strong>,由于函数会把返回值复制到外部临时的存储单元中,加const修饰没有任何价值.</p>\n<p>○const在后:const(常)成员函数.<br/> 任何<strong>不会修改数据成员</strong>的函数都应该声明为const类型.</p>\n<p>★<br/> <strong>常成员函数的特点和注意事项:</strong><br/> 1)const对象只能访问const成员函数,而非const对象可以访问任意的成员函数,<strong>包括const</strong>成员函数.<br/> 2)const对象的成员是<strong>不可修改</strong>的,然而const对象通过指针维护的对象却是可以修改的.<br/> 3)const成员函数<strong>不可以修改对象</strong>的数据,不管对象是否具有const性质.<br/> 4)而加上<strong>mutable修饰符</strong>的数据成员,对于任何情况下通过<strong>任何手段都可修改</strong>,自然此时的const成员函数是可以修改它的(先不看了,这个不了解)<br/> 5)常成员函数的this指针为:<code>const 类型名 *const this</code>(不允许改变this指向的对象)而正常的this指针为:<code>类型名* const this</code></p>\n<h2><a id=\"8static_301\"></a>8.static(静态数据成员和函数)</h2>\n<p><strong>★<br/> 静态数据成员</strong></p>\n<p>要对静态数据成员定义和初始化必须在<strong>类的外面</strong>也就是在全局作用域中定义,如果定义不给出初值,<strong>则默认初值为0</strong>,如下:</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Test</span><span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n\t<span class=\"token keyword\">int</span> <span class=\"token function\">GetA</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">const</span><span class=\"token punctuation\">{<!-- --></span><span class=\"token keyword\">return</span> a<span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">private</span><span class=\"token operator\">:</span>\n\t<span class=\"token comment\">//静态数据成员</span>\n\t<span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> a<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//int Test::a;如果这样定义不赋予初值则初值为零</span>\n<span class=\"token keyword\">int</span> Test<span class=\"token double-colon punctuation\">::</span>a <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream&gt;</span></span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\tTest T<span class=\"token punctuation\">;</span>\n\tstd<span class=\"token double-colon punctuation\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> T<span class=\"token punctuation\">.</span><span class=\"token function\">GetA</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> std<span class=\"token double-colon punctuation\">::</span>endl<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>★<br/> <strong>静态成员函数</strong></p>\n<p>静态成员函数就是在类的成员函数前加上static关键字.<br/> 1)静态成员函数不能调用非静态成员函数，但是反过来是可以的<br/> 2)静态成员函数没有this指针,即静态成员函数<strong>不能使用修饰符</strong>(也就是函数后面的const关键字)</p>\n<p>注:<br/> 1)静态数据成员可以作为成员函数的<strong>默认形参</strong>，而普通数据成员则不可以,如下:</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Test</span><span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n\t<span class=\"token comment\">//静态数据成员</span>\n\t<span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> a<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> b<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">void</span> <span class=\"token function\">fun_1</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//正确</span>\n\t<span class=\"token keyword\">void</span> <span class=\"token function\">fun_2</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//报错</span>\n</code></pre>\n<p>2)静态数据成员的类型可以是<strong>所属类的类型</strong>,普通数据成员则不可以.普通数据成员的只能声明为 所属类类型的<strong>指针或引用</strong><br/> 3)静态数据成员<strong>在const函数中可以修改</strong>，而普通的数据成员不能修改</p>\n<h2><a id=\"9_349\"></a>9.单例模式</h2>\n<p>1)保证一个类只有<strong>一个实例</strong>，并提供一个全局访问点<br/> 2)<strong>禁止拷贝</strong></p>\n<p>示例代码:</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Singleton</span><span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n\t<span class=\"token function\">Singleton</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> Singleton<span class=\"token operator\">&amp;</span><span class=\"token punctuation\">)</span><span class=\"token operator\">=</span><span class=\"token keyword\">delete</span><span class=\"token punctuation\">;</span>\n\tSingleton <span class=\"token operator\">&amp;</span> <span class=\"token keyword\">operator</span><span class=\"token operator\">=</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> Singleton<span class=\"token operator\">&amp;</span><span class=\"token punctuation\">)</span><span class=\"token operator\">=</span><span class=\"token keyword\">delete</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">static</span> Singleton <span class=\"token operator\">&amp;</span><span class=\"token function\">get_instance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\t<span class=\"token keyword\">static</span> Singleton instance<span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">return</span> instance<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">private</span><span class=\"token operator\">:</span>\n\t<span class=\"token function\">Singleton</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h2><a id=\"10_370\"></a>10.友元函数,友元类</h2>\n<p>1)友元函数<strong>没有this指针</strong>.<br/> 2)因为友元函数是<strong>类外</strong>的函数,所以它的声明可以放在类的<strong>私有段或公有段</strong>且没有区别.<br/> 3)友元函数<strong>不能被继承.</strong><br/> 4)友元类:类Y的<strong>所有</strong>成员函数都是类X的友元函数–提供一种类之间<strong>合作</strong>的一种方式<br/> 友元类的所有函数都<strong>自动变</strong>为友元函数.<br/> 友元类的代码,如下:</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">girl</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">boy</span>\n<span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n　　<span class=\"token keyword\">void</span> <span class=\"token function\">disp</span><span class=\"token punctuation\">(</span>girl <span class=\"token operator\">&amp;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">void</span> boy<span class=\"token double-colon punctuation\">::</span><span class=\"token function\">disp</span><span class=\"token punctuation\">(</span>girl <span class=\"token operator\">&amp;</span>x<span class=\"token punctuation\">)</span> <span class=\"token comment\">//函数disp()为类boy的成员函数，也是类girl的友元函数</span>\n<span class=\"token punctuation\">{<!-- --></span>\n　　cout<span class=\"token operator\">&lt;&lt;</span><span class=\"token string\">\"girl's name is:\"</span><span class=\"token operator\">&lt;&lt;</span>x<span class=\"token punctuation\">.</span>name<span class=\"token operator\">&lt;&lt;</span><span class=\"token string\">\",age:\"</span><span class=\"token operator\">&lt;&lt;</span>x<span class=\"token punctuation\">.</span>age<span class=\"token operator\">&lt;&lt;</span>endl<span class=\"token punctuation\">;</span><span class=\"token comment\">//借助友元，在boy的成员函数disp中，借助girl的对象，直接访问girl的私有变量</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">girl</span>\n<span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">private</span>：\n　　<span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>name<span class=\"token punctuation\">;</span>\n　　<span class=\"token keyword\">int</span> age<span class=\"token punctuation\">;</span>\n　　<span class=\"token keyword\">friend</span> boy<span class=\"token punctuation\">;</span> <span class=\"token comment\">//声明类boy是类girl的友元</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h2><a id=\"n_399\"></a>n.一些杂碎知识点</h2>\n<p>☆this指针的类型:<code>类名*const</code><br/> 多态性是将接口与实现进行分离<br/> 作用域限定符为<code>::</code><br/> f(0)这个表示方法中,0可以表示数值也可以表示<strong>空指针</strong></p>\n<p>构造函数和析构函数<strong>不会被子类继承</strong>,在子类的析构函数中会调用父类的析构函数.子类的构造函数会默认调用父类的无参构造函数.<br/> 赋值运算符重载函数也<strong>不会被子类继承</strong>,只是在子类的赋值运算符重载函数中会调用父类的赋值运算符重载函数(???先记住)</p>\n<p>按值传递会调用拷贝构造函数,按引用传递不会.</p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}