{"blogid": "126715946", "writerAge": "码龄1年", "writerBlogNum": "43", "writerCollect": "667", "writerComment": "2072", "writerFan": "2894", "writerGrade": "5级", "writerIntegral": "4024", "writerName": "令辰柒", "writerProfileAdress": "writer_image\\profile_126715946.jpg", "writerRankTotal": "4450", "writerRankWeekly": "86", "writerThumb": "1236", "writerVisitNum": "19953", "blog_read_count": "114", "blog_time": "于 2022-09-06 22:02:27 发布", "blog_title": "【数据结构与算法】时间复杂度&&空间复杂度", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<blockquote>\n<p><span style=\"color:#0d0016;\">✨hello，进来的小伙伴们，你们好呐！✨</span></p>\n<p><span style=\"color:#0d0016;\">🌯🌯系列专栏：【数据结构与算法】</span></p>\n<p><span style=\"color:#0d0016;\">🍗🍗本篇内容：夯实基础——认识时间复杂度和空间复杂度！</span></p>\n<p><span style=\"color:#0d0016;\">🥞🥞作者简介：双非本科大三在读的一名Java初学者，星夜漫长，你我同行！</span></p>\n<p><span style=\"color:#0d0016;\">🥤🥤给大家介绍一个超级好用的刷题网站——牛客网！</span></p>\n<p><a class=\"link-info\" href=\"https://www.nowcoder.com/link/pc_csdncpt_lc_c\" title=\"点击链接注册，开启刷题之路！\">点击链接注册，开启刷题之路！</a></p>\n</blockquote>\n<p style=\"text-align:center;\"><img alt=\"506c8955c307428e81e0d030b21c77ae.png\" src=\"image\\506c8955c307428e81e0d030b21c77ae.png\"/></p>\n<h1> 一、算法效率</h1>\n<p>🥭🥭衡量一个算法好坏的标准可以从这个算法的运行速度和所需的内存空间两个角度来分析，那么这两个因素哪个究竟是优先考虑的呢？</p>\n<p><span style=\"background-color:#a2e043;\">🍄🍄即时间效率被称为时间复杂度，而空间效率被称作空间复杂度。 时间复杂度主要衡量的是一个算法的运行速度，而空间复杂度主要衡量一个算法所需要的额外空间。</span></p>\n<h3>一、时间复杂度</h3>\n<p>🥠🥠定义：算法中的基本操作的执行次数，为算法的时间复杂度。</p>\n<p>下面我将通过几个实例来演示如何计算一个算法的时间复杂度。</p>\n<p>🚤🚤1.大O的渐进表示法</p>\n<p>大O符号（Big O notation）：是用于描述函数渐进行为的数学符号。</p>\n<p><span style=\"background-color:#ffd900;\">🛰️🛰️推导大O阶方法：</span></p>\n<p><span style=\"background-color:#ffd900;\">1、用常数1取代运行时间中的所有加法常数。</span><br/><span style=\"background-color:#ffd900;\">2、在修改后的运行次数函数中，只保留最高阶项。</span><br/><span style=\"background-color:#ffd900;\">3、如果最高阶项存在且不是1，则去除与这个项目相乘的常数。得到的结果就是大O阶。</span></p>\n<p>好了，那么知道了推导方法，我们看下面这个实例：</p>\n<p><span style=\"background-color:#a2e043;\"> 请计算一下func1基本操作执行了多少次？</span></p>\n<pre><code class=\"language-cpp\">void func1(int N){\n  int count = 0;\n  for (int i = 0; i &lt; N ; i++) {\n    for (int j = 0; j &lt; N ; j++) {\n      count++;\n   }\n }\nfor (int k = 0; k &lt; 2 * N ; k++) {\n    count++;\n }\n  int M = 10;\n  while ((M--) &gt; 0) {\n    count++;\n }\n  System.out.println(count);\n}</code></pre>\n<p>🍼🍼解答：</p>\n<p><span style=\"color:#0d0016;\">我们可以看到fun（）函数里面开头是双层循环，先看最里面的j从0遍历到n-1共循环了N次，那么每循环一个j，外层循环i就会循环n次，也就是说循环了n*n次，也就是计算了n^2次,所以执行的基本操作次数n^2；接着看我们的K，因为k是小于2*n的，所以这部分代码执行的基本操作次数就是2*n；最后while（m--），因为M的值是10，所以执行的基本操作次数是10，加起来是n^2+2*n+10；</span></p>\n<p><span style=\"color:#0d0016;\">再根据上面的推导大O阶方法，常数用1取代，那么m就为1；又因为保留最高阶项，所以去掉我们的2*n；因为我们的最高阶项系数是1，所以最后得到的结果是n^2+1，那么我们可以想象一下，当n足够大时，这个1还有保留的必要吗？显然，我们可以省去1，那么func1()的时间复杂度就是O(n^2)；🍬🍬</span></p>\n<blockquote>\n<p><span style=\"color:#956fe7;\"><strong>🍖🍖结论：大O的渐进表示法去掉了那些对结果影响不大的项，简洁明了的表示出了执行次数。</strong></span></p>\n</blockquote>\n<p><span style=\"background-color:#a2e043;\">另外有些算法的时间复杂度存在最好、平均和最坏情况：</span><br/><span style=\"background-color:#a2e043;\">最坏情况：任意输入规模的最大运行次数(上界)</span><br/><span style=\"background-color:#a2e043;\">平均情况：任意输入规模的期望运行次数</span><br/><span style=\"background-color:#a2e043;\">最好情况：任意输入规模的最小运行次数(下界)</span></p>\n<blockquote>\n<p><span style=\"color:#956fe7;\"><strong>✈️✈️在实际中一般情况关注的是算法的最坏运行情况！</strong></span></p>\n</blockquote>\n<p><strong>实例2：</strong></p>\n<p><span style=\"background-color:#a2e043;\">计算func3的时间复杂度？</span></p>\n<pre><code class=\"language-cpp\">void func3(int N, int M) {\n  int count = 0;\n  for (int k = 0; k &lt; M; k++) {\n    count++;\n }\n  for (int k = 0; k &lt; N ; k++) {\n    count++;\n }\n  System.out.println(count);</code></pre>\n<p><span style=\"background-color:#38d8f0;\">⛵⛵解答：</span></p>\n<p><span style=\"background-color:#38d8f0;\">可以看到，fun3是由两个循环来组成，所以基本语句的执行次数就是M+N，由于M和N是未知的，所以时间复杂度为O（M+N）。</span></p>\n<p><strong>实例3</strong></p>\n<p><span style=\"background-color:#a2e043;\">计算fun4的时间复杂度？</span></p>\n<pre><code class=\"language-cpp\">void func4(int N) {\n  int count = 0;\n  for (int k = 0; k &lt; 100; k++) {\n    count++;\n }\n  System.out.println(count);\n}</code></pre>\n<p> <span style=\"background-color:#38d8f0;\"> 🚀🚀解答：</span></p>\n<p><span style=\"background-color:#38d8f0;\">这一题猛一看上去就是 O（100）嘛，没的说，这么简单，其实从理论上来说没有问题的，因为基本操作执行了100次，但是根据我们的大O推导法，这里的100是常数项，那么时间复杂度就是O（1）。</span></p>\n<p>下面我们来看几个难度升级的例子！</p>\n<p style=\"text-align:center;\"><img alt=\"4cb8e3ad4c45457aa09a9c1cdf711157.jpeg\" src=\"image\\4cb8e3ad4c45457aa09a9c1cdf711157.jpeg\"/></p>\n<p></p>\n<p><strong>实例4：</strong><br/><span style=\"background-color:#a2e043;\">计算bubbleSort的时间复杂度？</span></p>\n<pre><code class=\"language-cpp\">void bubbleSort(int[] array) {\n    for (int end = array.length; end &gt; 0; end--) {\n      boolean sorted = true;\n      for (int i = 1; i &lt; end; i++) {\n        if (array[i - 1] &gt; array[i]) {\n          Swap(array, i - 1, i);\n          sorted = false;\n       }\n     }\n      if (sorted == true) {\n        break;\n     }\n   }\n}</code></pre>\n<p><span style=\"color:#0d0016;\">🛸🛸解答：</span></p>\n<p><span style=\"color:#0d0016;\">这里就要用到我们的最好情况和最坏情况了，我们可以发现冒泡排序最好的情况下是执行了N次，即数组是有序的，只要遍历到每一个元素即可；那么最坏的情况就是数组是倒序的，那么第一个元素就要和每个其余的元素相比较，比较次数是n-1  第二个元素比较次数就是N-2 ……依次到最后比较一次，那么总共的比较次数就是1+2+……+（n-1）次，根据等差数列求和得最后的次数为</span></p>\n<p><span style=\"color:#0d0016;\">(N*(N-1))/2；在根据大O阶推导法，所以fun4的时间复杂度就是O(n^2);</span></p>\n<p><strong>实例5：</strong></p>\n<p><span style=\"background-color:#a2e043;\">计算阶乘递归factorial的时间复杂度？</span></p>\n<pre><code class=\"language-cpp\">long factorial(int N) {\nreturn N &lt; 2 ? N : factorial(N-1) * N;\n}</code></pre>\n<p><span style=\"background-color:#38d8f0;\">🚛🚛解答：</span></p>\n<p><span style=\"background-color:#38d8f0;\">我们可以发现基本操作递归了N次，根据递归的时间复杂度= 递归的次数*每次递归执行的次数</span></p>\n<p><span style=\"background-color:#38d8f0;\">——&gt;时间复杂度为O(N)。</span></p>\n<p><strong>实例6：</strong></p>\n<p><span style=\"background-color:#a2e043;\">计算斐波那契递归fibonacci的时间复杂度？</span></p>\n<pre><code class=\"language-cpp\">int fibonacci(int N) {\nreturn N &lt; 2 ? N : fibonacci(N-1)+fibonacci(N-2);\n}</code></pre>\n<p><span style=\"background-color:#38d8f0;\">🚐🚐解答：</span></p>\n<p><span style=\"background-color:#38d8f0;\">这一题是求斐波那契数列第n项的值，我们可以发现当我们要求第n项的值时，我们需要知道第n-1项和n-2项的值，而要求的第n-1项的值，我们需要求出n-2项的值，如此下去，我们可以发现，基本操作呈现二叉树的形式分布，最后可以推导出fibonacci（）的时间复杂度为O(2^N);</span></p>\n<p style=\"text-align:center;\"><img alt=\"774f999a0f404c4bb57e24b9a8d859ed.png\" src=\"image\\774f999a0f404c4bb57e24b9a8d859ed.png\"/></p>\n<h3> 二、空间复杂度</h3>\n<p><span style=\"background-color:#ffd900;\">🚚🚚上面已经提到，空间复杂度是对一个算法在运行过程中临时占用多少内存空间大小的量度，那么我们的空间复杂度也是用大O渐进表示法！</span></p>\n<p>下面我们看几个实例：</p>\n<p><span style=\"background-color:#a2e043;\">实例1：计算bubbleSort的空间复杂度？</span></p>\n<pre><code class=\"language-cpp\">void bubbleSort(int[] array) {\n  for (int end = array.length; end &gt; 0; end--) {\n    boolean sorted = true;\n    for (int i = 1; i &lt; end; i++) {\n      if (array[i - 1] &gt; array[i]) {\n        Swap(array, i - 1, i);\n        sorted = false;\n     }\n   }\n    if (sorted == true) {\n      break;\n   }</code></pre>\n<p><span style=\"background-color:#a2e043;\">🚔🚔解答：</span></p>\n<p><span style=\"background-color:#a2e043;\">可以发现我们的函数参数传进来一个数组array（实际上传的是array首元素的地址），我们在函数的执行过程中并没有开辟新的空间，所以空间复杂度为O(1)。</span></p>\n<p><span style=\"background-color:#ffd900;\">实例2：计算fibonacci的空间复杂度？</span></p>\n<pre><code class=\"language-cpp\">int[] fibonacci(int n) {\n  long[] fibArray = new long[n + 1];\n  fibArray[0] = 0;\n  fibArray[1] = 1;\n  for (int i = 2; i &lt;= n ; i++) {\n  fibArray[i] = fibArray[i - 1] + fibArray [i - 2];\n }\n  return fibArray;\n}</code></pre>\n<p><span style=\"background-color:#a2e043;\">🚲🚲解答:这里我们在计算斐波那契数列第n项的值时动态开辟了N个空间，所以空间复杂度为 O(N)。</span></p>\n<p><span style=\"background-color:#38d8f0;\">实例3：计算阶乘递归Factorial的空间复杂度？</span></p>\n<pre><code class=\"language-cpp\">long factorial(int N) {\nreturn N &lt; 2 ? N : factorial(N-1)*N;\n}</code></pre>\n<p><span style=\"background-color:#a2e043;\">🛵🛵解答：根据我们的时间复杂度已经计算过的，我们可以了解到递归调用了N次，所以开辟了N个栈帧，每个栈帧使用了常数个空间，所以空间复杂度为O(N)，即可以理解为当我们的n-1 在执行完毕的时候会释放栈空间，这个时候在执行右边的n-2，所以最终开辟的空间大小以最深的来理解，如图蓝色箭头所示，即为N.</span></p>\n<p style=\"text-align:center;\"><img alt=\"2cc17dc4d3a54915ae5332321188ae0e.png\" src=\"image\\2cc17dc4d3a54915ae5332321188ae0e.png\"/></p>\n<p></p>\n<p></p>\n<p></p>\n</div>\n</div>"}