{"blogid": "126566099", "writerAge": "码龄2年", "writerBlogNum": "471", "writerCollect": "1076", "writerComment": "34", "writerFan": "8774", "writerGrade": "6级", "writerIntegral": "5373", "writerName": "暮晓引流软件", "writerProfileAdress": "writer_image\\profile_126566099.jpg", "writerRankTotal": "2995", "writerRankWeekly": "724", "writerThumb": "131", "writerVisitNum": "212611", "blog_read_count": "378", "blog_time": "于 2022-08-28 08:53:00 发布", "blog_title": "学习Redis这一篇就够了", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h3><a id=\"_2\"></a>这里写目录标题</h3>\n<ul><li><a href=\"#_2\">本文脑图</a></li><li><a href=\"#redis_4\">redis基本数据结构</a></li><li>\n<ul><li><a href=\"#_6\">本文脑图</a></li><li><a href=\"#_8\">前言</a></li><li><a href=\"#Redis_25\">Redis核心对象</a></li><li><a href=\"#String_45\">String类型</a></li><li>\n<ul><li><a href=\"#int_50\">int</a></li><li><a href=\"#SDS_56\">SDS</a></li><li><a href=\"#SDSc_68\">SDS与c语言字符串对比</a></li><li><a href=\"#String_91\">String类型应用</a></li></ul> </li><li><a href=\"#Hash_130\">Hash类型</a></li><li>\n<ul><li><a href=\"#_135\">字典</a></li><li>\n<ul><li><a href=\"#rehash_143\">rehash</a></li><li><a href=\"#rehash_157\">渐进式rehash</a></li></ul> </li><li><a href=\"#ziplist_168\">ziplist</a></li><li><a href=\"#_193\">应用场景</a></li><li>\n<ul><li><a href=\"#_198\">存储用户数据</a></li><li><a href=\"#ID_212\">分布式生成唯一ID</a></li></ul> </li></ul> </li><li><a href=\"#List_234\">List类型</a></li><li>\n<ul><li><a href=\"#_253\">应用场景</a></li></ul> </li><li><a href=\"#Set_383\">Set集合</a></li><li>\n<ul><li><a href=\"#_398\">应用场景</a></li></ul> </li><li><a href=\"#ZSet_424\">ZSet集合</a></li><li>\n<ul><li><a href=\"#_448\">应用场景</a></li></ul> </li></ul> </li><li><a href=\"#Redis_483\">Redis内存分配策略</a></li><li>\n<ul><li><a href=\"#_485\">概述</a></li><li><a href=\"#_509\">淘汰策略</a></li><li><a href=\"#LRU_537\">LRU算法</a></li><li><a href=\"#LFU_570\">LFU算法</a></li><li><a href=\"#_581\">删除过期键策略</a></li><li><a href=\"#RDBAOF__596\">RDB和AOF 的淘汰处理</a></li></ul> </li><li><a href=\"#Redis_608\">Redis缓存三大问题</a></li><li>\n<ul><li><a href=\"#_610\">前言</a></li><li><a href=\"#_625\">缓存穿透</a></li><li>\n<ul><li><a href=\"#_631\">缓存空对象</a></li><li><a href=\"#_677\">布隆过滤器</a></li></ul> </li><li><a href=\"#_863\">缓存击穿</a></li><li><a href=\"#_931\">缓存雪崩</a></li></ul> </li><li><a href=\"#redis_958\">redis持久化</a></li><li>\n<ul><li>\n<ul><li>\n<ul><li><a href=\"#_960\">本文脑图</a></li><li><a href=\"#RDB_971\">RDB持久化机制</a></li><li>\n<ul><li><a href=\"#_985\">持久化触发时机</a></li><li><a href=\"#RDB_1054\">RDB的优缺点</a></li></ul> </li><li><a href=\"#AOF_1059\">AOF持久化机制</a></li><li>\n<ul><li><a href=\"#AOF_1070\">AOF触发机制</a></li><li><a href=\"#AOF_1085\">AOF重写机制</a></li><li><a href=\"#AOF_1135\">AOF的优缺点</a></li></ul> </li><li><a href=\"#_1144\">混合持久化</a></li><li><a href=\"#RDBAOF_1155\">RDB和AOF优势和劣势</a></li></ul> </li></ul> </li></ul> </li><li><a href=\"#redis_1160\">redis事务</a></li><li>\n<ul><li><a href=\"#_1162\">前言</a></li><li><a href=\"#_1173\">事务介绍</a></li><li><a href=\"#_1195\">开始事务</a></li><li><a href=\"#_1200\">命令入队</a></li><li><a href=\"#_1225\">执行事务</a></li><li><a href=\"#WATCH__1275\">WATCH 命令</a></li><li><a href=\"#_1307\">错误处理</a></li><li><a href=\"#RedisMysql_1361\">Redis事务与Mysql事务</a></li></ul> </li><li><a href=\"#_1372\">集群</a></li><li>\n<ul><li><a href=\"#_1374\">集群概述</a></li><li><a href=\"#_1381\">单机</a></li><li>\n<ul><li><a href=\"#_1391\">优点</a></li><li><a href=\"#_1393\">缺点</a></li><li><a href=\"#_1397\">实操搭建</a></li></ul> </li><li><a href=\"#_1511\">主从模式</a></li><li>\n<ul><li><a href=\"#_1512\">原理</a></li><li><a href=\"#_1529\">优点</a></li><li><a href=\"#_1537\">缺点</a></li><li><a href=\"#_1543\">实操搭建</a></li><li><a href=\"#_1596\">测试</a></li></ul> </li><li><a href=\"#_1616\">哨兵模式</a></li><li>\n<ul><li><a href=\"#_1617\">原理</a></li><li><a href=\"#_1634\">节点通信</a></li><li><a href=\"#_1655\">上线和下线</a></li><li><a href=\"#_1663\">选举算法</a></li><li><a href=\"#_1679\">优点</a></li><li><a href=\"#_1684\">缺点</a></li><li><a href=\"#_1688\">实操搭建</a></li></ul> </li><li><a href=\"#Cluster_1723\">Cluster模式</a></li><li>\n<ul><li><a href=\"#_1730\">数据分区原理</a></li><li><a href=\"#_1743\">节点通信</a></li><li><a href=\"#_1755\">数据请求</a></li><li><a href=\"#_1779\">扩容和收缩</a></li><li><a href=\"#_1788\">优点</a></li><li><a href=\"#_1793\">缺点</a></li><li><a href=\"#_1799\">实操搭建</a></li></ul> </li></ul> </li><li><a href=\"#_1818\">应用</a></li><li>\n<ul><li><a href=\"#1_1820\">1.订阅与发布简介</a></li><li><a href=\"#_1831\">命令实操</a></li><li>\n<ul><li><a href=\"#_1838\">发布消息</a></li><li><a href=\"#_1844\">订阅频道</a></li><li><a href=\"#_1853\">取消订阅</a></li><li><a href=\"#_1872\">按模式订阅</a></li><li><a href=\"#_1891\">取消按模式订阅</a></li><li><a href=\"#_1909\">查看订阅消息</a></li></ul> </li><li><a href=\"#_1929\">代码实练</a></li><li><a href=\"#2Redis_2135\">2.Redis实现的分布式锁</a></li></ul> </li></ul>\n<h1><a id=\"_102\"></a>本文脑图</h1>\n<p><img alt=\"\" src=\"image\\20200818225220354.png\"/></p>\n<h1><a id=\"redis_107\"></a>redis基本数据结构</h1>\n<h2><a id=\"_110\"></a>本文脑图</h2>\n<p><img alt=\"\" src=\"image\\20200614113047180.png\"/></p>\n<h2><a id=\"_115\"></a>前言</h2>\n<p>Redis是基于c语言编写的开源非关系型内存数据库，可以用作数据库、缓存、消息中间件，这么优秀的东西客定要一点一点的吃透它。</p>\n<p>这是关于Redis五种数据结构详解，包括这五种的数据结构的底层原理实现。</p>\n<p>理论肯定是要用于实践的，因此最重要的还是实战部分，也就是这里还会讲解五种数据结构的应用场景。</p>\n<p>话不多说，我们直接进入主题，很多人都知道Redis的五种数据结构包括以下五种：</p>\n<ol><li><code>String</code>：字符串类型</li><li><code>List</code>：列表类型</li><li><code>Set</code>：无序集合类型</li><li><code>ZSet</code>：有序集合类型</li><li><code>Hash</code>：哈希表类型</li></ol>\n<p>但是作为一名优秀的程序员可能不能只停留在只会用着五种类型进行crud工作，还是得深入了解这五种数据结构的底层原理。</p>\n<h2><a id=\"Redis_134\"></a>Redis核心对象</h2>\n<p>在Redis中有一个<strong>核心的对象</strong>叫做<code>redisObject</code> ，是用来表示所有的key和value的，用redisObject结构体来表示<code>String、Hash、List、Set、ZSet</code>五种数据类型。</p>\n<p><code>redisObject</code>的源代码在<code>redis.h</code>中，使用c语言写的，感兴趣的可以自行查看，关于redisObject我这里画了一张图，表示redisObject的结构如下所示：</p>\n<p><img alt=\"闪瞎人的五颜六色图\" src=\"image\\20200614104817292.png\"/></p>\n<p>在redisObject中<strong>type表示属于哪种数据类型，encoding表示该数据的存储方式</strong>，也就是底层的实现的该数据类型的数据结构。因此这篇文章具体介绍的也是encoding对应的部分。</p>\n<p>那么encoding中的存储类型又分别表示什么意思呢？具体数据类型所表示的含义，如下图所示：</p>\n<p><img alt=\"图片截图出自《Redis设计与实现第二版》\" src=\"image\\20200614111129928.png\"/></p>\n<p>可能看完这图，还是觉得一脸懵。不慌，会进行五种数据结构的详细介绍，这张图只是让你找到每种中数据结构对应的储存类型有哪些，大概脑子里有个印象。</p>\n<p>举一个简单的例子，你在Redis中设置一个字符串<code>key 234</code>，然后查看这个字符串的存储类型就会看到为int类型，非整数型的使用的是embstr储存类型，具体操作如下图所示：</p>\n<p><img alt=\"\" src=\"image\\20200614113522120.png\"/></p>\n<h2><a id=\"String_155\"></a>String类型</h2>\n<p>String是Redis最基本的数据类型，上面的简介中也说到Redis是用c语言开发的。但是Redis中的字符串和c语言中的字符串类型却是有明显的区别。</p>\n<p>String类型的数据结构存储方式有三种<code>int、raw、embstr</code>。那么这三种存储方式有什么区别呢？</p>\n<h3><a id=\"int_162\"></a>int</h3>\n<p>Redis中规定假如存储的是<strong>整数型值</strong>，比如<code>set num 123</code>这样的类型，就会使用 int的存储方式进行存储，在redisObject的<strong>ptr属性</strong>中就会保存该值。</p>\n<p><img alt=\"\" src=\"image\\20200614161909985.png\"/></p>\n<h3><a id=\"SDS_168\"></a>SDS</h3>\n<p>假如存储的<strong>字符串是一个字符串值并且长度大于32个字节</strong>就会使用<code>SDS（simple dynamic string）</code>方式进行存储，并且encoding设置为raw；若是<strong>字符串长度小于等于32个字节</strong>就会将encoding改为embstr来保存字符串。</p>\n<p>SDS称为<strong>简单动态字符串</strong>，对于SDS中的定义在Redis的源码中有的三个属性<code>int len、int free、char buf[]</code>。</p>\n<p>len保存了字符串的长度，free表示buf数组中未使用的字节数量，buf数组则是保存字符串的每一个字符元素。</p>\n<p>因此当你在Redsi中存储一个字符串Hello时，根据Redis的源代码的描述可以画出SDS的形式的redisObject结构图如下图所示：</p>\n<p><img alt=\"\" src=\"image\\20200614165239167.png\"/></p>\n<h3><a id=\"SDSc_180\"></a>SDS与c语言字符串对比</h3>\n<p>Redis使用SDS作为存储字符串的类型肯定是有自己的优势，SDS与c语言的字符串相比，SDS对c语言的字符串做了自己的设计和优化，具体优势有以下几点：</p>\n<p>（1）c语言中的字符串并不会记录自己的长度，因此<strong>每次获取字符串的长度都会遍历得到，时间的复杂度是O(n)</strong>，而Redis中获取字符串只要读取len的值就可，时间复杂度变为O(1)。</p>\n<p>（2）<strong>c语言</strong>中两个字符串拼接，若是没有分配足够长度的内存空间就<strong>会出现缓冲区溢出的情况</strong>；而<strong>SDS</strong>会先根据len属性判断空间是否满足要求，若是空间不够，就会进行相应的空间扩展，所以<strong>不会出现缓冲区溢出的情况</strong>。</p>\n<p>（3）SDS还提供<strong>空间预分配</strong>和<strong>惰性空间释放</strong>两种策略。在为字符串分配空间时，分配的空间比实际要多，这样就能<strong>减少连续的执行字符串增长带来内存重新分配的次数</strong>。</p>\n<p>当字符串被缩短的时候，SDS也不会立即回收不适用的空间，而是通过<code>free</code>属性将不使用的空间记录下来，等后面使用的时候再释放。</p>\n<p>具体的空间预分配原则是：<strong>当修改字符串后的长度len小于1MB，就会预分配和len一样长度的空间，即len=free；若是len大于1MB，free分配的空间大小就为1MB</strong>。</p>\n<p>（4）SDS是二进制安全的，除了可以储存字符串以外还可以储存二进制文件（如图片、音频，视频等文件的二进制数据）；而c语言中的字符串是以空字符串作为结束符，一些图片中含有结束符，因此不是二进制安全的。</p>\n<p>为了方便易懂，做了一个c语言的字符串和SDS进行对比的表格，如下所示：</p>\n<p>c语言字符串</p>\n<p>SDS</p>\n<p>获取长度的时间复杂度为O(n)</p>\n<p>获取长度的时间复杂度为O(1)</p>\n<p>不是二进制安全的</p>\n<p>是二进制安全的</p>\n<p>只能保存字符串</p>\n<p>还可以保存二进制数据</p>\n<p>n次增长字符串必然会带来n次的内存分配</p>\n<p>n次增长字符串内存分配的次数&lt;=n</p>\n<h3><a id=\"String_218\"></a>String类型应用</h3>\n<p>说到这里我相信很多人可以说已经精通Redis的String类型了，但是纯理论的精通，理论还是得应用实践，上面说到String可以用来存储图片，现在就以图片存储作为案例实现。</p>\n<p>（1）首先要把上传得图片进行编码，这里写了一个工具类把图片处理成了Base64得编码形式，具体得实现代码如下：</p>\n<pre><code> /**\n     * 将图片内容处理成Base64编码格式\n     * @param file\n     * @return\n     */\n    public static String encodeImg(MultipartFile file) {\n        byte[] imgBytes = null;\n        try {\n            imgBytes = file.getBytes();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        BASE64Encoder encoder = new BASE64Encoder();\n        return imgBytes==null?null:encoder.encode(imgBytes );\n    }\n</code></pre>\n<p>（2）第二步就是把处理后的图片字符串格式存储进Redis中，实现得代码如下所示：</p>\n<pre><code>    /**\n     * Redis存储图片\n     * @param file\n     * @return\n     */\n    public void uploadImageServiceImpl(MultipartFile image) {\n        String imgId = UUID.randomUUID().toString();\n        String imgStr= ImageUtils.encodeImg(image);\n        redisUtils.set(imgId , imgStr);\n        // 后续操作可以把imgId存进数据库对应的字段，如果需要从redis中取出，只要获取到这个字段后从redis中取出即可。\n    }\n</code></pre>\n<p>这样就是实现了图片得二进制存储，当然String类型得数据结构得应用也还有常规计数：<strong>统计微博数、统计粉丝数</strong>等。</p>\n<h2><a id=\"Hash_258\"></a>Hash类型</h2>\n<p>Hash对象的实现方式有两种分别是<code>ziplist、hashtable</code>，其中hashtable的存储方式key是String类型的，value也是以<code>key value</code>的形式进行存储。</p>\n<p>字典类型的底层就是hashtable实现的，明白了字典的底层实现原理也就是明白了hashtable的实现原理，hashtable的实现原理可以于HashMap的是底层原理相类比。</p>\n<h3><a id=\"_265\"></a>字典</h3>\n<p>两者在新增时都会通过key计算出数组下标，不同的是计算法方式不同，HashMap中是以hash函数的方式，而hashtable中计算出hash值后，还要通过sizemask 属性和哈希值再次得到数组下标。</p>\n<p>我们知道hash表最大的问题就是hash冲突，为了解决hash冲突，假如hashtable中不同的key通过计算得到同一个index，就会形成单向链表（<strong>链地址法</strong>），如下图所示：</p>\n<p><img alt=\"\" src=\"image\\20200614230029399.png\"/></p>\n<h4><a id=\"rehash_273\"></a>rehash</h4>\n<p>在字典的底层实现中，value对象以每一个dictEntry的对象进行存储，当hash表中的存放的键值对不断的增加或者减少时，需要对hash表进行一个扩展或者收缩。</p>\n<p>这里就会和HashMap一样也会就进行rehash操作，进行重新散列排布。从上图中可以看到有<code>ht[0]</code>和<code>ht[1]</code>两个对象，先来看看对象中的属性是干嘛用的。</p>\n<p>在hash表结构定义中有四个属性分别是<code>dictEntry **table、unsigned long size、unsigned long sizemask、unsigned long used</code>，分别表示的含义就是<strong>哈希表数组、hash表大小、用于计算索引值，总是等于size-1、hash表中已有的节点数</strong>。</p>\n<p>ht[0]是用来最开始存储数据的，当要进行扩展或者收缩时，ht[0]的大小就决定了ht[1]的大小，ht[0]中的所有的键值对就会重新散列到ht[1]中。</p>\n<p>扩展操作：ht[1]扩展的大小是比当前 ht[0].used 值的二倍大的第一个 2 的整数幂；收缩操作：ht[0].used 的第一个大于等于的 2 的整数幂。</p>\n<p>当ht[0]上的所有的键值对都rehash到ht[1]中，会重新计算所有的数组下标值，当数据迁移完后ht[0]就会被释放，然后将ht[1]改为ht[0]，并新创建ht[1]，为下一次的扩展和收缩做准备。</p>\n<h4><a id=\"rehash_287\"></a>渐进式rehash</h4>\n<p>假如在rehash的过程中数据量非常大，Redis不是一次性把全部数据rehash成功，这样会导致Redis对外服务停止，Redis内部为了处理这种情况采用<strong>渐进式的rehash</strong>。</p>\n<p>Redis将所有的rehash的操作分成多步进行，直到都rehash完成，具体的实现与对象中的<code>rehashindex</code>属性相关，<strong>若是rehashindex 表示为-1表示没有rehash操作</strong>。</p>\n<p>当rehash操作开始时会将该值改成0，在渐进式rehash的过程<strong>更新、删除、查询会在ht[0]和ht[1]中都进行</strong>，比如更新一个值先更新ht[0]，然后再更新ht[1]。</p>\n<p>而新增操作直接就新增到ht[1]表中，ht[0]不会新增任何的数据，这样保证<strong>ht[0]只减不增，直到最后的某一个时刻变成空表</strong>，这样rehash操作完成。</p>\n<p>上面就是字典的底层hashtable的实现原理，说完了hashtable的实现原理，我们再来看看Hash数据结构的两一种存储方式<strong>ziplist（压缩列表）</strong></p>\n<h3><a id=\"ziplist_299\"></a>ziplist</h3>\n<p>压缩列表<code>（ziplist）</code>是一组连续内存块组成的顺序的数据结构，压缩列表能够节省空间，压缩列表中使用多个节点来存储数据。</p>\n<p>压缩列表是列表键和哈希键底层实现的原理之一，<strong>压缩列表并不是以某种压缩算法进行压缩存储数据，而是它表示一组连续的内存空间的使用，节省空间</strong>，压缩列表的内存结构图如下：</p>\n<p><img alt=\"\" src=\"image\\20200615073948813.png\"/></p>\n<p>压缩列表中每一个节点表示的含义如下所示：</p>\n<ol><li><code>zlbytes</code>：4个字节的大小，记录压缩列表占用内存的字节数。</li><li><code>zltail</code>：4个字节大小，记录表尾节点距离起始地址的偏移量，用于快速定位到尾节点的地址。</li><li><code>zllen</code>：2个字节的大小，记录压缩列表中的节点数。</li><li><code>entry</code>：表示列表中的每一个节点。</li><li><code>zlend</code>：表示压缩列表的特殊结束符号<code>'0xFF'</code>。</li></ol>\n<p>再压缩列表中每一个entry节点又有三部分组成，包括<code>previous_entry_ength、encoding、content</code>。</p>\n<ol><li><code>previous_entry_ength</code>表示前一个节点entry的长度，可用于计算前一个节点的其实地址，因为他们的地址是连续的。</li><li>encoding：这里保存的是content的内容类型和长度。</li><li>content：content保存的是每一个节点的内容。</li></ol>\n<p><img alt=\"\" src=\"image\\20200615080410692.png\"/></p>\n<p>说到这里相信大家已经都hash这种数据结构已经非常了解，若是第一次接触Redis五种基本数据结构的底层实现的话，建议多看几遍，下面来说一说hash的应用场景。</p>\n<h3><a id=\"_325\"></a>应用场景</h3>\n<p>哈希表相对于String类型存储信息更加直观，擦欧总更加方便，经常会用来做用户数据的管理，存储用户的信息。</p>\n<p>hash也可以用作高并发场景下使用Redis生成唯一的id。下面我们就以这两种场景用作案例编码实现。</p>\n<h4><a id=\"_331\"></a>存储用户数据</h4>\n<p>第一个场景比如我们要储存用户信息，一般使用用户的ID作为key值，保持唯一性，用户的其他信息（地址、年龄、生日、电话号码等）作为value值存储。</p>\n<p>若是传统的实现就是将用户的信息封装成为一个对象，通过序列化存储数据，当需要获取用户信息的时候，就会通过反序列化得到用户信息。</p>\n<p><img alt=\"\" src=\"image\\20200615194704412.png\"/></p>\n<p>但是这样必然会造成序列化和反序列化的性能的开销，并且若是只修改其中的一个属性值，就需要把整个对象序列化出来，操作的动作太大，造成不必要的性能开销。</p>\n<p>若是使用Redis的hash来存储用户数据，就会将原来的value值又看成了一个k v形式的存储容器，这样就不会带来序列化的性能开销的问题。</p>\n<p><img alt=\"\" src=\"image\\20200615195616246.png\"/></p>\n<h4><a id=\"ID_345\"></a>分布式生成唯一ID</h4>\n<p>第二个场景就是生成分布式的唯一ID，这个场景下就是把redis封装成了一个工具类进行实现，实现的代码如下：</p>\n<pre><code>    // offset表示的是id的递增梯度值\n    public Long getId(String key,String hashKey,Long offset) throws BusinessException{\n        try {\n            if (null == offset) {\n                offset=1L;\n            }\n            // 生成唯一id\n            return redisUtil.increment(key, hashKey, offset);\n        } catch (Exception e) {\n            //若是出现异常就是用uuid来生成唯一的id值\n            int randNo=UUID.randomUUID().toString().hashCode();\n            if (randNo &lt; 0) {\n                randNo=-randNo;\n            }\n            return Long.valueOf(String.format(\"%16d\", randNo));\n        }\n    }\n</code></pre>\n<h2><a id=\"List_368\"></a>List类型</h2>\n<p>Redis中的列表在3.2之前的版本是使用<code>ziplist</code>和<code>linkedlist</code>进行实现的。在3.2之后的版本就是引入了<code>quicklist</code>。</p>\n<p>ziplist压缩列表上面已经讲过了，我们来看看linkedlist和quicklist的结构是怎么样的。</p>\n<p>linkedlist是一个双向链表，他和普通的链表一样都是由指向前后节点的指针。插入、修改、更新的时间复杂度尾O(1)，但是查询的时间复杂度确实O(n)。</p>\n<p>linkedlist和quicklist的底层实现是采用链表进行实现，在c语言中并没有内置的链表这种数据结构，Redis实现了自己的链表结构。</p>\n<p><img alt=\"\" src=\"image\\20200615202451471.png\"/></p>\n<p>Redis中链表的特性：</p>\n<ol><li>每一个节点都有指向前一个节点和后一个节点的指针。</li><li>头节点和尾节点的prev和next指针指向为null，所以链表是无环的。</li><li>链表有自己长度的信息，获取长度的时间复杂度为O(1)。</li></ol>\n<p>Redis中List的实现比较简单，下面我们就来看看它的应用场景。</p>\n<h3><a id=\"_389\"></a>应用场景</h3>\n<p>Redis中的列表可以实现<strong>阻塞队列</strong>，结合lpush和brpop命令就可以实现。生产者使用lupsh从列表的左侧插入元素，消费者使用brpop命令从队列的右侧获取元素进行消费。</p>\n<p>（1）首先配置redis的配置，为了方便我就直接放在<code>application.yml</code>配置文件中，实际中可以把redis的配置文件放在一个<code>redis.properties</code>文件单独放置，具体配置如下：</p>\n<pre><code>spring\n\tredis:\n\t\thost: 127.0.0.1\n\t\tport: 6379\n\t\tpassword: user\n\t\ttimeout: 0\n\t\tdatabase: 2\n\t\tpool:\n\t\t\tmax-active: 100\n\t\t\tmax-idle: 10\n\t\t\tmin-idle: 0\n\t\t\tmax-wait: 100000\n</code></pre>\n<p>（2）第二步创建redis的配置类，叫做<code>RedisConfig</code>，并标注上<code>@Configuration</code>注解，表明他是一个配置类。</p>\n<pre><code>@Configuration\npublic class RedisConfiguration {\n\n@Value(\"${spring.redis.host}\")\nprivate String host;\n@Value(\"${spring.redis.port}\")\nprivate int port;\n@Value(\"${spring.redis.password}\")\nprivate String password;\n@Value(\"${spring.redis.pool.max-active}\")\nprivate int maxActive;\n@Value(\"${spring.redis.pool.max-idle}\")\nprivate int maxIdle;\n@Value(\"${spring.redis.pool.min-idle}\")\nprivate int minIdle;\n@Value(\"${spring.redis.pool.max-wait}\")\nprivate int maxWait;\n@Value(\"${spring.redis.database}\")\nprivate int database;\n@Value(\"${spring.redis.timeout}\")\nprivate int timeout;\n\n@Bean\npublic JedisPoolConfig getRedisConfiguration(){\n\tJedisPoolConfig jedisPoolConfig= new JedisPoolConfig();\n\tjedisPoolConfig.setMaxTotal(maxActive);\n\tjedisPoolConfig.setMaxIdle(maxIdle);\n\tjedisPoolConfig.setMinIdle(minIdle);\n\tjedisPoolConfig.setMaxWaitMillis(maxWait);\n\treturn jedisPoolConfig;\n}\n\n@Bean\npublic JedisConnectionFactory getConnectionFactory() {\n\tJedisConnectionFactory factory = new JedisConnectionFactory();\n\tfactory.setHostName(host);\n\tfactory.setPort(port);\n\tfactory.setPassword(password);\n\tfactory.setDatabase(database);\n\tJedisPoolConfig jedisPoolConfig= getRedisConfiguration();\n\tfactory.setPoolConfig(jedisPoolConfig);\n\treturn factory;\n}\n\n@Bean\npublic RedisTemplate&lt;?, ?&gt; getRedisTemplate() {\n\tJedisConnectionFactory factory = getConnectionFactory();\n\tRedisTemplate&lt;?, ?&gt; redisTemplate = new StringRedisTemplate(factory);\n\treturn redisTemplate;\n}\n}\n</code></pre>\n<p>（3）第三步就是创建Redis的工具类RedisUtil，自从学了面向对象后，就喜欢把一些通用的东西拆成工具类，好像一个一个零件，需要的时候，就把它组装起来。</p>\n<pre><code>@Component\npublic class RedisUtil {\n\n@Autowired\nprivate RedisTemplate&lt;String, Object&gt; redisTemplate;\n/**\n* 存消息到消息队列中\n* @param key 键\n* @param value 值\n* @return\n*/\npublic boolean lPushMessage(String key, Object value) {\n\ttry {\n\t\t\tredisTemplate.opsForList().leftPush(key, value);\n\t\t\treturn true;\n\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\treturn false;\n\t}\n}\n\n/**\n* 从消息队列中弹出消息 - &lt;rpop：非阻塞式&gt;\n* @param key 键\n* @return\n*/\npublic Object rPopMessage(String key) {\n\ttry {\n\t\t\treturn redisTemplate.opsForList().rightPop(key);\n\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\treturn null;\n\t}\n}\n\n/**\n* 查看消息\n* @param key 键\n* @param start 开始\n* @param end 结束 0 到 -1代表所有值\n* @return\n*/\npublic List&lt;Object&gt; getMessage(String key, long start, long end) {\n\ttry {\n\t\t\treturn redisTemplate.opsForList().range(key, start, end);\n\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\treturn null;\n\t}\n}\n</code></pre>\n<p>这样就完成了Redis消息队列工具类的创建，在后面的代码中就可以直接使用。</p>\n<h2><a id=\"Set_520\"></a>Set集合</h2>\n<p>Redis中列表和集合都可以用来存储字符串，但是<strong>Set是不可重复的集合，而List列表可以存储相同的字符串</strong>，Set集合是无序的这个和后面讲的ZSet有序集合相对。</p>\n<p>Set的底层实现是<strong>ht和intset</strong>，ht（哈希表）前面已经详细了解过，下面我们来看看inset类型的存储结构。</p>\n<p>inset也叫做整数集合，用于保存整数值的数据结构类型，它可以保存<code>int16_t</code>、<code>int32_t</code> 或者<code>int64_t</code> 的整数值。</p>\n<p>在整数集合中，有三个属性值<code>encoding、length、contents[]</code>，分别表示编码方式、整数集合的长度、以及元素内容，length就是记录contents里面的大小。</p>\n<p>在整数集合新增元素的时候，若是超出了原集合的长度大小，就会对集合进行升级，具体的升级过程如下：</p>\n<ol><li>首先扩展底层数组的大小，并且数组的类型为新元素的类型。</li><li>然后将原来的数组中的元素转为新元素的类型，并放到扩展后数组对应的位置。</li><li>整数集合升级后就不会再降级，编码会一直保持升级后的状态。</li></ol>\n<h3><a id=\"_537\"></a>应用场景</h3>\n<p>Set集合的应用场景可以用来<strong>去重、抽奖、共同好友、二度好友</strong>等业务类型。接下来模拟一个添加好友的案例实现：</p>\n<pre><code>@RequestMapping(value = \"/addFriend\", method = RequestMethod.POST)\npublic Long addFriend(User user, String friend) {\n    String currentKey = null;\n    // 判断是否是当前用户的好友\n    if (AppContext.getCurrentUser().getId().equals(user.getId)) {\n        currentKey = user.getId.toString();\n    }\n    //若是返回0则表示不是该用户好友\n    return currentKey==null?0l:setOperations.add(currentKey, friend);\n}\n</code></pre>\n<p>假如两个用户A和B都是用上上面的这个接口添加了很多的自己的好友，那么有一个需求就是要实现获取A和B的共同好友，那么可以进行如下操作：</p>\n<pre><code>public Set intersectFriend(User userA, User userB) {\n    return setOperations.intersect(userA.getId.toString(), userB.getId.toString());\n}\n</code></pre>\n<p>举一反三，还可以实现A用户自己的好友，或者B用户自己的好友等，都可以进行实现。</p>\n<h2><a id=\"ZSet_563\"></a>ZSet集合</h2>\n<p>ZSet是有序集合，从上面的图中可以看到ZSet的底层实现是<code>ziplist</code>和<code>skiplist</code>实现的，ziplist上面已经详细讲过，这里来讲解skiplist的结构实现。</p>\n<p><code>skiplist</code>也叫做<strong>跳跃表</strong>，跳跃表是一种有序的数据结构，它通过每一个节点维持多个指向其它节点的指针，从而达到快速访问的目的。</p>\n<p>skiplist由如下几个特点：</p>\n<ol><li>有很多层组成，由上到下节点数逐渐密集，最上层的节点最稀疏，跨度也最大。</li><li>每一层都是一个有序链表，只扫包含两个节点，头节点和尾节点。</li><li>每一层的每一个每一个节点都含有指向同一层下一个节点和下一层同一个位置节点的指针。</li><li>如果一个节点在某一层出现，那么该以下的所有链表同一个位置都会出现该节点。</li></ol>\n<p>具体实现的结构图如下所示：</p>\n<p><img alt=\"\" src=\"image\\20200615220409163.png\"/></p>\n<p>在跳跃表的结构中有head和tail表示指向头节点和尾节点的指针，能后快速的实现定位。level表示层数，len表示跳跃表的长度，BW表示后退指针，在从尾向前遍历的时候使用。</p>\n<p>BW下面还有两个值分别表示分值（score）和成员对象（各个节点保存的成员对象）。</p>\n<p>跳跃表的实现中，除了最底层的一层保存的是原始链表的完整数据，上层的节点数会越来越少，并且跨度会越来越大。</p>\n<p>跳跃表的上面层就相当于索引层，都是为了找到最后的数据而服务的，数据量越大，条表所体现的查询的效率就越高，和平衡树的查询效率相差无几。</p>\n<h3><a id=\"_589\"></a>应用场景</h3>\n<p>因为ZSet是有序的集合，因此ZSet在实现排序类型的业务是比较常见的，比如在首页推荐10个最热门的帖子，也就是阅读量由高到低，排行榜的实现等业务。</p>\n<p>下面就选用获取排行榜前前10名的选手作为案例实现，实现的代码如下所示：</p>\n<pre><code>@Autowired\nprivate RedisTemplate redisTemplate;\n\t/**\n\t * 获取前10排名\n\t * @return\n\t */\n    public static List&lt;levelVO &gt; getZset(String key, long baseNum, LevelService levelService){\n        ZSetOperations&lt;Serializable, Object&gt; operations = redisTemplate.opsForZSet();\n        // 根据score分数值获取前10名的数据\n        Set&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; set = operations.reverseRangeWithScores(key,0,9);\n        List&lt;LevelVO&gt; list= new ArrayList&lt;LevelVO&gt;();\n        int i=1;\n        for (ZSetOperations.TypedTuple&lt;Object&gt; o:set){\n            int uid = (int) o.getValue();\n            LevelCache levelCache = levelService.getLevelCache(uid);\n            LevelVO levelVO = levelCache.getLevelVO();\n            long score = (o.getScore().longValue() - baseNum + levelVO .getCtime())/CommonUtil.multiplier;\n            levelVO .setScore(score);\n            levelVO .setRank(i);\n            list.add( levelVO );\n            i++;\n        }\n        return list;\n    }\n</code></pre>\n<p>以上的代码实现大致逻辑就是根据score分数值获取前10名的数据，然后封装成lawyerVO对象的列表进行返回。</p>\n<p>到这里我们已经精通Redis的五种基本数据类型了，又可以去和面试官扯皮了，扯不过就跑路吧，或者这篇文章多看几遍，相信对你总是有好处的。</p>\n<h1><a id=\"Redis_625\"></a>Redis内存分配策略</h1>\n<h2><a id=\"_628\"></a>概述</h2>\n<p>今天就带来了一个面试常问的一个问题：<strong>假如你的Redis内存满了怎么办？</strong> 长期的把Redis作为缓存使用，总有一天会存满的时候对吧。</p>\n<p>这个面试题不慌呀，在Redis中有配置参数<code>maxmemory</code>可以<strong>设置Redis内存的大小</strong>。</p>\n<p>在Redis的配置文件<code>redis.conf</code>文件中，配置<code>maxmemory</code>的大小参数如下所示：</p>\n<p><img alt=\"\" src=\"image\\20200519220333869.png\"/></p>\n<p>实际生产中肯定不是<code>100mb</code>的大小哈，不要给误导了，这里我只是让大家认识这个参数，一般小的公司都是设置为<code>3G</code>左右的大小。</p>\n<p>除了在配置文件中配置生效外，还可以通过命令行参数的形式，进行配置，具体的配置命令行如下所示：</p>\n<pre><code>//获取maxmemory配置参数的大小\n127.0.0.1:6379&gt; config get maxmemory\n//设置maxmemory参数为100mb\n127.0.0.1:6379&gt; config set maxmemory 100mb\n</code></pre>\n<p>倘若实际的存储中超出了Redis的配置参数的大小时，Redis中有<strong>淘汰策略</strong>，把<strong>需要淘汰的key给淘汰掉，整理出干净的一块内存给新的key值使用</strong>。</p>\n<p>接下来我们就详细的聊一聊Redis中的淘汰策略，并且深入的理解每个淘汰策略的原理和应用的场景。</p>\n<h2><a id=\"_653\"></a>淘汰策略</h2>\n<p>Redis提供了<strong>6种的淘汰策略</strong>，其中默认的是<code>noeviction</code>，这6中淘汰策略如下：</p>\n<ol><li><code>noeviction</code>(<strong>默认策略</strong>)：若是内存的大小达到阀值的时候，所有申请内存的指令都会报错。</li><li><code>allkeys-lru</code>：所有key都是使用<strong>LRU算法</strong>进行淘汰。</li><li><code>volatile-lru</code>：所有<strong>设置了过期时间的key使用LRU算法</strong>进行淘汰。</li><li><code>allkeys-random</code>：所有的key使用<strong>随机淘汰</strong>的方式进行淘汰。</li><li><code>volatile-random</code>：所有<strong>设置了过期时间的key使用随机淘汰</strong>的方式进行淘汰。</li><li><code>volatile-ttl</code>：所有设置了过期时间的key<strong>根据过期时间进行淘汰，越早过期就越快被淘汰</strong>。</li></ol>\n<p>假如在Redis中的数据有<strong>一部分是热点数据，而剩下的数据是冷门数据</strong>，或者<strong>我们不太清楚我们应用的缓存访问分布状况</strong>，这时可以使用<code>allkeys-lru</code>。</p>\n<p>假如所有的数据访问的频率大概一样，就可以使用<code>allkeys-random</code>的淘汰策略。</p>\n<p>假如要配置具体的淘汰策略，可以在<code>redis.conf</code>配置文件中配置，具体配置如下所示：</p>\n<p><img alt=\"\" src=\"image\\20200519225413746.png\"/></p>\n<p>这只需要把注释给打开就可以，并且配置指定的策略方式，另一种的配置方式就是命令的方式进行配置，具体的执行命令如下所示：</p>\n<pre><code>// 获取maxmemory-policy配置\n127.0.0.1:6379&gt; config get maxmemory-policy\n// 设置maxmemory-policy配置为allkeys-lru\n127.0.0.1:6379&gt; config set maxmemory-policy allkeys-lru\n</code></pre>\n<p>在介绍6种的淘汰策略方式的时候，说到了LRU算法，<strong>那么什么是LRU算法呢？</strong></p>\n<h2><a id=\"LRU_683\"></a>LRU算法</h2>\n<p><code>LRU(Least Recently Used)</code>即表示最近最少使用，也就是在最近的时间内最少被访问的key，算法根据数据的历史访问记录来进行淘汰数据。</p>\n<p>它的核心的思想就是：<strong>假如一个key值在最近很少被使用到，那么在将来也很少会被访问</strong>。</p>\n<p>实际上Redis实现的LRU并不是真正的LRU算法，也就是名义上我们使用LRU算法淘汰键，但是实际上被淘汰的键并不一定是真正的最久没用的。</p>\n<p>Redis使用的是近似的LRU算法，<strong>通过随机采集法淘汰key，每次都会随机选出5个key，然后淘汰里面最近最少使用的key</strong>。</p>\n<p>这里的5个key只是默认的个数，具体的个数也可以在配置文件中进行配置，在配置文件中的配置如下图所示：</p>\n<p><img alt=\"\" src=\"image\\20200519231937596.png\"/></p>\n<p>当近似LRU算法取值越大的时候就会越接近真实的LRU算法，可以这样理解，因为<strong>取值越大那么获取的数据就越全，淘汰中的数据的就越接近最近最少使用的数据</strong>。</p>\n<p>那么为了实现根据时间实现LRU算法，Redis必须为每个key中额外的增加一个内存空间用于存储每个key的时间，大小是3字节。</p>\n<p>在Redis 3.0中对近似的LRU算法做了一些优化，Redis中会维护大小是<code>16</code>的一个候选池的内存。</p>\n<p>当第一次随机选取的采样数据，数据都会被放进候选池中，并且候选池中的数据会根据时间进行排序。</p>\n<p>当第二次以后选取的数据，只有<strong>小于候选池内的最小时间</strong>的才会被放进候选池中。</p>\n<p>当某一时刻候选池的数据满了，那么时间最大的key就会被挤出候选池。当执行淘汰时，直接从候选池中选取最近访问时间最小的key进行淘汰。</p>\n<p>这样做的目的就是选取出最近似符合最近最少被访问的key值，能够正确的淘汰key值，因为随机选取的样本中的最小时间可能不是真正意义上的最小时间。</p>\n<p>但是LRU算法有一个弊端：就是假如一个key值在以前都没有被访问到，然而最近一次被访问到了，那么就会认为它是热点数据，不会被淘汰。</p>\n<p>然而有些数据以前经常被访问到，只是最近的时间内没有被访问到，这样就导致这些数据很可能被淘汰掉，这样一来就会出现误判而淘汰热点数据。</p>\n<p>于是在Redis 4.0的时候除了LRU算法，新加了一种LFU算法，<strong>那么什么是LFU算法算法呢？</strong></p>\n<h2><a id=\"LFU_718\"></a>LFU算法</h2>\n<p><code>LFU(Least Frequently Used)</code>即表示最近频繁被使用，也就是最近的时间段内，频繁被访问的key，它以最近的时间段的被访问次数的频率作为一种判断标准。</p>\n<p>它的核心思想就是：根据key最近被访问的频率进行淘汰，比较少被访问的key优先淘汰，反之则优先保留。</p>\n<p>LFU算法反映了一个key的热度情况，不会因为LRU算法的偶尔一次被访问被认为是热点数据。</p>\n<p>在LFU算法中支持<code>volatile-lfu</code>策略和<code>allkeys-lfu</code>策略。</p>\n<p>以上介绍了Redis的6种淘汰策略，这6种淘汰策略旨在告诉我们怎么做，但是什么时候做？这个还没说，下面我们就来详细的了解Redis什么时候执行淘汰策略。</p>\n<h2><a id=\"_731\"></a>删除过期键策略</h2>\n<p>在Redis种有三种删除的操作此策略，分别是：</p>\n<ol><li><strong>定时删除</strong>：创建一个定时器，定时的执行对key的删除操作。</li><li><strong>惰性删除</strong>：每次只有再访问key的时候，才会检查key的过期时间，若是已经过期了就执行删除。</li><li><strong>定期删除</strong>：每隔一段时间，就会检查删除掉过期的key。</li></ol>\n<p><strong>定时删除</strong>对于<strong>内存来说是友好的</strong>，定时清理出干净的空间，但是对于<strong>cpu来说并不是友好的</strong>，程序需要维护一个定时器，这就会占用cpu资源。</p>\n<p><strong>惰性的删除</strong>对于<strong>cpu来说是友好的</strong>，cpu不需要维护其它额外的操作，但是对于<strong>内存来说是不友好的</strong>，因为要是有些key一直没有被访问到，就会一直占用着内存。</p>\n<p>定期删除是上面两种方案的折中方案**，每隔一段时间删除过期的key，也就是根据具体的业务，合理的取一个时间定期的删除key**。</p>\n<p>通过<strong>最合理控制删除的时间间隔</strong>来删除key，减<strong>少对cpu的资源的占用消耗</strong>，使删除操作合理化。</p>\n<h2><a id=\"RDBAOF__748\"></a>RDB和AOF 的淘汰处理</h2>\n<p>在Redis中持久化的方式有两种<code>RDB</code>和<code>AOF</code>，具体这两种详细的持久化介绍，可以参考这一篇文章[]。</p>\n<p>在RDB中是以快照的形式获取内存中某一时间点的数据副本，在创建RDB文件的时候可以通过<code>save</code>和<code>bgsave</code>命令执行创建RDB文件。</p>\n<p><strong>这两个命令都不会把过期的key保存到RDB文件中</strong>，这样也能达到删除过期key的效果。</p>\n<p>当在启动Redis载入RDB文件的时候，<code>Master</code>不会把过期的key载入，而<code>Slave</code>会把过期的key载入。</p>\n<p>在AOF模式下，Redis提供了Rewite的优化措施，执行的命令分别是<code>REWRITEAOF</code>和<code>BGREWRITEAOF</code>，<strong>这两个命令都不会把过期的key写入到AOF文件中，也能删除过期key</strong>。</p>\n<h1><a id=\"Redis_761\"></a>Redis缓存三大问题</h1>\n<h2><a id=\"_764\"></a>前言</h2>\n<p>日常的开发中，无不都是使用数据库来进行数据的存储，由于一般的系统任务中通常不会存在高并发的情况，所以这样看起来并没有什么问题。</p>\n<p>一旦涉及大数据量的需求，如一些<strong>商品抢购</strong>的情景，或者<strong>主页访问量</strong>瞬间较大的时候，单一使用数据库来保存数据的系统会因为<strong>面向磁盘</strong>，<strong>磁盘读/写</strong>速度问题有严重的性能弊端，详细的<strong>磁盘读写原理</strong>请参考这一片[]。</p>\n<p>在这一瞬间成千上万的请求到来，需要系统在<strong>极短的时间</strong>内完成成<strong>千上万</strong>次的<strong>读/写操作</strong>，这个时候往往不是数据库能够承受的，极其容易造成数据库系统瘫痪，最终导致服务宕机的严重生产问题。</p>\n<p>为了克服上述的问题，项目通常会引入<strong>NoSQL</strong>技术，这是一种<strong>基于内存</strong>的<strong>数据库</strong>，并且提供一定的<strong>持久化</strong>功能。</p>\n<p><code>Redis</code>技术就是<code>NoSQL</code>技术中的一种。<code>Redis</code>缓存的使用，极大的提升了应用程序的性能和效率，特别是<strong>数据查询</strong>方面。</p>\n<p>但同时，它也带来了一些问题。其中，最要害的问题，就是数据的一致性问题，从严格意义上讲，这个问题无解。如果对<strong>数据的一致性</strong>要求很高，那么就不能使用<strong>缓存</strong>。</p>\n<p>另外的一些典型问题就是，<strong>缓存穿透</strong>、<strong>缓存击穿</strong>和<strong>缓存雪崩</strong>。本篇文章从实际代码操作，来提出解决这三个缓存问题的方案，毕竟Redis的缓存问题是实际面试中高频问点，理论和实操要兼得。</p>\n<h2><a id=\"_781\"></a>缓存穿透</h2>\n<p>缓存穿透是指查询一条数据库和缓存都没有的一条数据，就会一直查询数据库，对数据库的访问压力就会增大，缓存穿透的解决方案，有以下两种：</p>\n<ol><li><strong>缓存空对象</strong>：代码维护较简单，但是效果不好。</li><li><strong>布隆过滤器</strong>：代码维护复杂，效果很好。</li></ol>\n<h3><a id=\"_789\"></a>缓存空对象</h3>\n<p>缓存空对象是指当一个请求过来缓存中和数据库中都不存在该请求的数据，第一次请求就会跳过缓存进行数据库的访问，并且访问数据库后返回为空，此时也将该空对象进行缓存。</p>\n<p>若是再次进行访问该空对象的时候，就会直接<strong>击中缓存</strong>，而不是再次<strong>数据库</strong>，缓存空对象实现的原理图如下：</p>\n<p><img alt=\"\" src=\"image\\20200411100759260.png\"/></p>\n<p>缓存空对象的实现代码如下：</p>\n<pre><code>public class UserServiceImpl {\n     @Autowired\n     UserDAO userDAO;\n     @Autowired\n     RedisCache redisCache;\n \n     public User findUser(Integer id) {\n          Object object = redisCache.get(Integer.toString(id));\n          // 缓存中存在，直接返回\n          if(object != null) {\n               // 检验该对象是否为缓存空对象，是则直接返回null\n               if(object instanceof NullValueResultDO) {\n                    return null;\n               }\n               return (User)object;\n          } else {  \n               // 缓存中不存在，查询数据库\n               User user = userDAO.getUser(id);\n               // 存入缓存\n               if(user != null) {\n                    redisCache.put(Integer.toString(id),user);\n               } else {\n                    // 将空对象存进缓存\n                    redisCache.put(Integer.toString(id), new NullValueResultDO());\n               }\n               return user;\n          }\n     }          \n}\n</code></pre>\n<p>缓存空对象的实现代码很简单，但是缓存空对象会带来比较大的问题，就是缓存中会存在很多空对象，占用<strong>内存的空间</strong>，浪费资源，一个解决的办法就是设置空对象的<strong>较短的过期时间</strong>，代码如下：</p>\n<pre><code>// 再缓存的时候，添加多一个该空对象的过期时间60秒\nredisCache.put(Integer.toString(id), new NullValueResultDO(),60);\n</code></pre>\n<h3><a id=\"_836\"></a>布隆过滤器</h3>\n<p>布隆过滤器是一种基于<strong>概率</strong>的<strong>数据结构</strong>，主要用来判断某个元素是否在集合内，它具有<strong>运行速度快</strong>（时间效率），<strong>占用内存小</strong>的优点（空间效率），但是有一定的<strong>误识别率</strong>和<strong>删除困难</strong>的问题。它只能告诉你某个元素一定不在集合内或可能在集合内。</p>\n<p>在计算机科学中有一种思想：<strong>空间换时间，时间换空间</strong>。一般两者是不可兼得，而布隆过滤器运行效率和空间大小都兼得，它是怎么做到的呢？</p>\n<p>在布隆过滤器中引用了一个<strong>误判率</strong>的概念，即它可能会把不属于这个集合的元素认为可能属于这个集合，但是不会把属于这个集合的认为不属于这个集合，布隆过滤器的特点如下：</p>\n<ol><li>一个非常大<strong>的二进制位数组</strong> （数组里只有0和1）</li><li>若干个<strong>哈希函数</strong></li><li><strong>空间效率</strong>和<strong>查询效率高</strong></li><li>不存在<strong>漏报</strong>（False Negative）：某个元素在某个集合中，肯定能报出来。</li><li>可能存在<strong>误报</strong>（False Positive）：某个元素不在某个集合中，可能也被爆出来。</li><li>不提供删除方法，代码维护困难。</li><li>位数组初始化都为0，它不存元素的具体值，当元素经过哈希函数哈希后的值（也就是数组下标）对应的数组位置值改为1。</li></ol>\n<p>实际布隆过滤器存储数据和查询数据的原理图如下：</p>\n<p><img alt=\"\" src=\"image\\20200411110041782.png\"/></p>\n<p>可能很多读者看完上面的特点和原理图，还是看不懂，别急下面通过图解一步一步的讲解布隆过滤器，总而言之一句简单的话概括就是布隆过滤器是一个<strong>很大二进制</strong>的<strong>位数组</strong>，数组里面<strong>只存0和1</strong>。</p>\n<p>初始化的布隆过滤器的结构图如下：</p>\n<p><img alt=\"\" src=\"image\\20200411110343825.png\"/></p>\n<p>以上只是画了布隆过滤器的很小很小的一部分，实际布隆过滤器是非常大的数组（这里的大是指它的<strong>长度大</strong>，并不是指它所占的<strong>内存空间大</strong>）。</p>\n<p><strong>那么一个数据是怎么存进布隆过滤器的呢？</strong></p>\n<p>当一个数据进行存入布隆过滤器的时候，会经过如干个哈希函数进行哈希（若是对哈希函数还不懂的请参考这一片[]），得到对应的哈希值作为数组的下标，然后将初始化的位数组对应的下标的值修改为1，结果图如下：</p>\n<p><img alt=\"\" src=\"image\\20200411110444296.png\"/></p>\n<p>当再次进行存入第二个值的时候，修改后的结果的原理图如下：</p>\n<p><img alt=\"\" src=\"image\\20200411110640460.png\"/></p>\n<p>所以每次存入一个数据，就会哈希函数的计算，计算的结果就会作为下标，在布隆过滤器中有多少个哈希函数就会计算出多少个下标，布隆过滤器插入的流程如下：</p>\n<ol><li>将要添加的元素给m个哈希函数</li><li>得到对应于位数组上的m个位置</li><li>将这m个位置设为1</li></ol>\n<p><strong>那么为什么会有误判率呢？</strong></p>\n<p>假设在我们多次存入值后，在布隆过滤器中存在x、y、z这三个值，布隆过滤器的存储结构图如下所示：</p>\n<p><img alt=\"\" src=\"image\\20200411111551119.png\"/></p>\n<p>当我们要查询的时候，比如查询a这个数，实际中a这个数是不存在布隆过滤器中的，经过2哥哈希函数计算后得到a的哈希值分别为2和13，结构原理图如下：</p>\n<p><img alt=\"\" src=\"image\\20200411112038115.png\"/></p>\n<p>经过查询后，发现2和13位置所存储的值都为1，但是2和13的下标分别是x和z经过计算后的下标位置的修改，该布隆过滤器中实际不存在a，那么布隆过滤器就会误判改值可能存在，因为布隆过滤器不存<strong>元素值</strong>，所以存在<strong>误判率</strong>。</p>\n<p>那么具体布隆过布隆过滤的判断的准确率和一下<strong>两个因素</strong>有关：</p>\n<ol><li><strong>布隆过滤器大小</strong>：越大，误判率就越小，所以说布隆过滤器一般长度都是非常大的。</li><li><strong>哈希函数的个数</strong>：哈希函数的个数越多，那么误判率就越小。</li></ol>\n<p><strong>那么为什么不能删除元素呢？</strong></p>\n<p>原因很简单，因为删除元素后，将对应元素的下标设置为零，可能别的元素的下标也引用改下标，这样别的元素的判断就会收到影响，原理图如下：</p>\n<p><img alt=\"\" src=\"image\\20200411113051903.png\"/></p>\n<p>当你删除z元素之后，将对应的下标10和13设置为0，这样导致x和y元素的下标受到影响，导致数据的判断不准确，所以直接不提供删除元素的api。</p>\n<p>以上说的都是布隆过滤器的原理，只有理解了原理，在实际的运用才能如鱼得水，下面就来实操代码，手写一个简单的布隆过滤器。</p>\n<p>对于要手写一个布隆过滤器，首先要明确布隆过滤器的核心：</p>\n<ul><li>若干哈希函数</li><li>存值得Api</li><li>判断值得Api</li></ul>\n<p>实现得代码如下：</p>\n<pre><code>public class MyBloomFilter {\n    // 布隆过滤器长度\n    private static final int SIZE = 2 &lt;&lt; 10;\n    // 模拟实现不同的哈希函数\n    private static final int[] num= new int[] {5, 19, 23, 31,47, 71};   \n    // 初始化位数组\n    private BitSet bits = new BitSet(SIZE);\n    // 用于存储哈希函数\n    private MyHash[] function = new MyHash[num.length];\n    \n    // 初始化哈希函数\n    public MyBloomFilter() {\n        for (int i = 0; i &lt; num.length; i++) {\n            function [i] = new MyHash(SIZE, num[i]);\n        }\n    }\n   \n    // 存值Api \n    public void add(String value) {\n        // 对存入得值进行哈希计算\n        for (MyHash f: function) {\n            // 将为数组对应的哈希下标得位置得值改为1\n            bits.set(f.hash(value), true);\n        }\n    }\n   \n    // 判断是否存在该值得Api \n    public boolean contains(String value) {\n        if (value == null) {\n            return false;\n        }\n        boolean result= true;\n        for (MyHash f : func) {\n            result= result&amp;&amp; bits.get(f.hash(value));\n        }\n        return result;\n    }\n}\n</code></pre>\n<p>哈希函数代码如下：</p>\n<pre><code>public static class MyHash {\n        private int cap;\n        private int seed;\n        // 初始化数据\n        public MyHash(int cap, int seed) {\n            this.cap = cap;\n            this.seed = seed;\n        }\n        // 哈希函数\n        public int hash(String value) {\n            int result = 0;\n            int len = value.length();\n            for (int i = 0; i &lt; len; i++) {\n                result = seed * result + value.charAt(i);\n            }\n            return (cap - 1) &amp; result;\n        }\n    }\n</code></pre>\n<p>布隆过滤器测试代码如下：</p>\n<pre><code>    public static void test {\n        String value = \"4243212355312\";\n        MyBloomFilter filter = new MyBloomFilter();\n        System.out.println(filter.contains(value));\n        filter.add(value);\n        System.out.println(filter.contains(value));\n    }\n</code></pre>\n<p>以上就是手写了一个非常简单得布隆过滤器，但是实际项目中可能事由牛人或者大公司已经帮你写好的，如谷歌的<code>Google Guava</code>，只需要在项目中引入一下依赖：</p>\n<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.google.guava&lt;/groupId&gt;\n    &lt;artifactId&gt;guava&lt;/artifactId&gt;\n    &lt;version&gt;27.0.1-jre&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p>实际项目中具体的操作代码如下：</p>\n<pre><code>public static void MyBloomFilterSysConfig {\n\n     @Autowired\n     OrderMapper orderMapper\n     \n    // 1.创建布隆过滤器  第二个参数为预期数据量10000000，第三个参数为错误率0.00001\n    BloomFilter&lt;CharSequence&gt; bloomFilter =  BloomFilter.create(Funnels.stringFunnel(Charset.forName(\"utf-8\")),10000000, 0.00001);\n    // 2.获取所有的订单，并将订单的id放进布隆过滤器里面\n    List&lt;Order&gt; orderList = orderMapper.findAll()\n    for (Order order;orderList ) {\n        Long id = order.getId();\n        bloomFilter.put(\"\" + id);\n    }\n}\n</code></pre>\n<p>在实际项目中会启动一个<strong>系统任务</strong>或者<strong>定时任务</strong>，来初始化布隆过滤器，将热点查询数据的id放进布隆过滤器里面，当用户再次请求的时候，使用布隆过滤器进行判断，改订单的id是否在布隆过滤器中存在，不存在直接返回null，具体操作代码：</p>\n<pre><code>// 判断订单id是否在布隆过滤器中存在\nbloomFilter.mightContain(\"\" + id)\n</code></pre>\n<p>布隆过滤器的缺点就是要维持容器中的数据，因为订单数据肯定是频繁变化的，实时的要更新布隆过滤器中的数据为最新。</p>\n<h2><a id=\"_1023\"></a>缓存击穿</h2>\n<p><strong>缓存击穿</strong>是指一个<code>key</code>非常热点，在不停的扛着大并发，<strong>大并发</strong>集中对这一个点进行访问，当这个key在失效的瞬间，持续的<strong>大并发</strong>就穿破缓存，直接请求数据库，瞬间对数据库的访问压力增大。</p>\n<p>缓存击穿这里强调的是<strong>并发</strong>，造成缓存击穿的原因有以下两个：</p>\n<ol><li>该数据没有人查询过 ，第一次就大并发的访问。（冷门数据）</li><li>添加到了缓存，reids有设置数据失效的时间 ，这条数据刚好失效，大并发访问（热点数据）</li></ol>\n<p>对于缓存击穿的解决方案就是加锁，具体实现的原理图如下：</p>\n<p><img alt=\"\" src=\"image\\20200411153315173.png\"/></p>\n<p>当用户出现<strong>大并发</strong>访问的时候，在查询缓存的时候和查询数据库的过程加锁，只能第一个进来的请求进行执行，当第一个请求把该数据放进缓存中，接下来的访问就会直接集中缓存，防止了<strong>缓存击穿</strong>。</p>\n<p>业界比价普遍的一种做法，即根据key获取value值为空时，锁上，从数据库中<code>load</code>数据后再释放锁。若其它线程获取锁失败，则等待一段时间后重试。这里要注意，分布式环境中要使用<strong>分布式锁</strong>，<strong>单机</strong>的话用普通的锁（<code>synchronized</code>、<code>Lock</code>）就够了。</p>\n<p>下面以一个获取商品库存的案例进行代码的演示，<strong>单机版</strong>的锁实现具体实现的代码如下：</p>\n<pre><code>// 获取库存数量\npublic String getProduceNum(String key) {\n    try {\n        synchronized (this) {   //加锁\n            // 缓存中取数据，并存入缓存中\n            int num= Integer.parseInt(redisTemplate.opsForValue().get(key));\n            \n            if (num&gt; 0) {\n                //没查一次库存-1\n                redisTemplate.opsForValue().set(key, (num- 1) + \"\");\n                System.out.println(\"剩余的库存为num：\" + (num- 1));\n            } else {\n                System.out.println(\"库存为0\");\n            }\n        }\n    } catch (NumberFormatException e) {\n        e.printStackTrace();\n    } finally {\n    }\n    return \"OK\";\n}\n</code></pre>\n<p><strong>分布式</strong>的锁实现具体实现的代码如下：</p>\n<pre><code>public String getProduceNum(String key) {\n    // 获取分布式锁\n    RLock lock = redissonClient.getLock(key);\n    try {\n        // 获取库存数\n        int num= Integer.parseInt(redisTemplate.opsForValue().get(key));  \n        // 上锁           \n        lock.lock();\n        if (num&gt; 0) {\n            //减少库存，并存入缓存中\n            redisTemplate.opsForValue().set(key, (num - 1) + \"\");\n            System.out.println(\"剩余库存为num：\" + (num- 1));\n        } else {\n            System.out.println(\"库存已经为0\");\n        }\n    } catch (NumberFormatException e) {\n        e.printStackTrace();\n    } finally {\n        //解锁\n        lock.unlock();\n    }\n    return \"OK\";\n}\n</code></pre>\n<h2><a id=\"_1093\"></a>缓存雪崩</h2>\n<p>缓存雪崩 是指在某一个时间段，缓存集中过期失效。此刻无数的请求直接绕开缓存，直接请求数据库。</p>\n<p>造成缓存雪崩的原因，有以下两种：</p>\n<ol><li>reids宕机</li><li>大部分数据失效</li></ol>\n<p>比如天猫双11，马上就要到双11零点，很快就会迎来一波抢购，这波商品在23点集中的放入了缓存，假设缓存一个小时，那么到了凌晨24点的时候，这批商品的缓存就都过期了。</p>\n<p>而对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰，对数据库造成压力，甚至压垮数据库。</p>\n<p>缓存雪崩的原理图如下，当正常的情况下，key没有大量失效的用户访问原理图如下：</p>\n<p><img alt=\"\" src=\"image\\20200411160745295.png\"/></p>\n<p>当某一时间点，key大量失效，造成的缓存雪崩的原理图如下：</p>\n<p><img alt=\"\" src=\"image\\20200411161306232.png\"/></p>\n<p>对于缓存雪崩的解决方案有以下两种：</p>\n<ol><li>搭建高可用的集群，防止单机的redis宕机。</li><li>设置不同的过期时间，防止同意之间内大量的key失效。</li></ol>\n<blockquote>\n<p>针对业务系统，永远都是具体情况具体分析，没有最好，只有最合适。于缓存其它问题，缓存满了和数据丢失等问题，我们后面继续深入的学习。最后也提一下三个词LRU、RDB、AOF，通常我们采用LRU策略处理溢出，Redis的RDB和AOF持久化策略来保证一定情况下的数据安全。</p>\n</blockquote>\n<h1><a id=\"redis_1122\"></a>redis持久化</h1>\n<h4><a id=\"_1125\"></a>本文脑图</h4>\n<p><img alt=\"\" src=\"image\\20200505232201367.png\"/></p>\n<p><code>Redis</code>是一个基于内存的非关系型的数据库，数据保存在内存中，但是内存中的数据也容易发生丢失。这里Redis就为我们提供了持久化的机制，分别是<code>RDB(Redis DataBase)</code>和<code>AOF(Append Only File)</code>。</p>\n<p>Redis在以前的版本中是单线程的，而在6.0后对Redis的io模型做了优化，<code>io Thread</code>为多线程的，但是<code>worker Thread</code>仍然是单线程。</p>\n<p>在Redis启动的时候就会去加载持久化的文件，如果没有就直接启动，在启动后的某一时刻由继续持久化内存中产生的数据。</p>\n<p>接下来我们就来详细了解Redis的两种持久化机制<code>RDB(Redis DataBase)</code>和<code>AOF(Append Only File)</code>。</p>\n<h4><a id=\"RDB_1137\"></a>RDB持久化机制</h4>\n<p>什么是RDB持久化呢？RDB持久化就是将当前进程的数据以生成快照的形式持久化到磁盘中。对于快照的理解，我们可以理解为将当前线程的数据以拍照的形式保存下来。</p>\n<p>RDB持久化的时候会单独fork一个与当前进程一摸一样的子进程来进行持久化，因此RDB持久化有如下特点：</p>\n<ol><li>开机恢复数据快。</li><li>写入持久化文件快。</li></ol>\n<p>RDB的持久化也是Redis默认的持久化机制，它会把内存中的数据以快照的形式写入默认文件名为<code>dump.rdb</code>中保存。</p>\n<p>在安装后的Redis中，Redis的配置都在<code>redis.conf</code>文件中，如下图所示，<code>dbfilename</code>就是配置RDB的持久化文件名。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\20200506232121606.png\"/></p>\n<h5><a id=\"_1152\"></a>持久化触发时机</h5>\n<p>在RDB机制中触发内存中的数据进行持久化，有以下三种方式：</p>\n<p>（1）<strong>save命令：</strong></p>\n<p>save命令不会fork子进程，通过阻塞当前Redis服务器，直到RDB完成为止，所以该命令在生产中一般不会使用。save命令执行原理图如下:</p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\20200507073951298.png\"/></p>\n<p>在redis.conf的配置中<code>dir</code>的配置就是RDB持久化后生成rdb二进制文件所在的位置，默认的位置是<code>./</code>，表示当前位置，哪里启动redis，就会在哪里生成持久化文件，如下图所示：</p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\20200507074629992.png\"/></p>\n<p>下面我们进行一下实操，演示一下二进制文件生成的过程，在我本机的电脑虚拟机中，我所在的位置如下，该文件夹是新创建的redis的数据存储文件夹。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\20200507080808985.png\"/></p>\n<p>然后我们直接在该位置启动我们的Redis服务，启动的命令如下：</p>\n<pre><code>/root/redis-4.0.6/src/redis-server /root/redis-4.0.6/redis.conf\n</code></pre>\n<p>接着通过该命令：<code>ps -aux | grep redis</code>，查看我们的redis服务是否正常启动，若是显示如下图所示，则表示Redis是正常启动的：</p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\20200507081644202.png\"/></p>\n<p>正常启动后，直接登陆Redis，可以通过以下命令登陆Redis，如下图所示：</p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\20200507081855530.png\"/></p>\n<p>因为当前中Redis是新安装的，数据都是为空，什么都没有，然后通过下图的命令随意向Redis中输入几条命令，最后执行<code>save</code>命令，在该文件夹下就会出现<code>dump.rdb</code>持久化的数据文件。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\20200507082105977.png\"/></p>\n<p>当然上面说到，在新安装的Redis中默认的RDB数据持久化位置为<code>./</code>文件，一般我们会把它改成服务器自己的特定位置下，原理都是一样的，可以自己进行尝试，这里不再进行演示。</p>\n<p>（2）<strong>bgsave命令：</strong></p>\n<p><code>bgsave</code>命令会在后台fork一个与Redis主线程一摸一样的子线程，由子线程负责内存中的数据持久化。</p>\n<p>这样fork与主线程一样的子线程消耗了内存，但是不会阻塞主线程处理客户端请求，是以空间换时间的方式快照内存中的数据到到文件中。</p>\n<p><code>bgsave</code>命令阻塞只会发生在fork子线程的时候，这段时间发生的非常短，可以忽略不计，如下图是 bgsave执行的流程图：</p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\20200507191631279.png\"/></p>\n<p>上面说到redis.conf中的<code>dir</code>配置是配置持久化文件生成的指定的目录，<code>dbfilename</code>是配置生成的文件名，也可以通过命令行使用命令来动态的设置这两个配置，命令如下：</p>\n<pre><code>config set dir{newDir}\nconfig set dbfilename{newFileName}\n</code></pre>\n<p>（3）<strong>自动化</strong></p>\n<p>除了上面在命令行使用save和bgsave命令触发持久化，也可以在<code>redis.conf</code>配置文件中，完成配置，如下图所示：</p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\20200507192828457.png\"/></p>\n<p>在新安装的redis中由默认的以上三个save配置，<code>save 900 1</code>表示900秒内如果至少有1个key值变化，则进行持久化保存数据；</p>\n<p><code>save 300 10</code>则表示300秒内如果至少有10个key值发生变化，则进行持久化，<code>save 60 10000</code>以此类推。</p>\n<p>通过以上的分析可以得出以下save和bgsave的对比区别：</p>\n<ol><li>save是<strong>同步</strong>持久化数据，而bgsave是<strong>异步</strong>持久化数据。</li><li><code>save</code>不会fork子进程，通过<strong>主进程</strong>持久化数据，会<strong>阻塞</strong>处理客户端的请求，而<code>bdsave</code>会<code>fork</code>子进程持久化数据，同时还可以处理客户端请求，高效。</li><li>save<strong>不会消耗内存</strong>，而bgsave<strong>会消耗内存</strong>。</li></ol>\n<h5><a id=\"RDB_1221\"></a>RDB的优缺点</h5>\n<p><strong>缺点：</strong> RDB持久化后的文件是紧凑的二进制文件，适合于备份、全量复制、大规模数据恢复的场景，对数据完整性和一致性要求不高，RDB会丢失最后一次快照的数据。</p>\n<p><strong>优点：</strong> 开机的恢复数据快，写入持久化文件快。</p>\n<h4><a id=\"AOF_1227\"></a>AOF持久化机制</h4>\n<p>AOF持久化机制是以日志的形式记录Redis中的每一次的增删改操作，不会记录查询操作，以文本的形式记录，打开记录的日志文件就可以查看操作记录。</p>\n<p>AOF是默认不开启的，若是像开启AOF，在如下图的配置修改即可：</p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\20200507200033143.png\"/></p>\n<p>只需要把<code>appendonly no</code>修改为<code>appendonly yes</code>即可开启，在AOF中通过<code>appendfilename</code>配置生成的文件名，该文件名默认为<code>appendonly.aof</code>，路径也是通过dir配置的，这个于RDB的一样，具体的配置信息如下图所示：</p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\2020050720034171.png\"/></p>\n<h5><a id=\"AOF_1239\"></a>AOF触发机制</h5>\n<p>AOF带来的持久化更加安全可靠，默认提供<strong>三种</strong>触发机制，如下所示：</p>\n<ol><li><code>no</code>：表示等操作系统等数据缓存同步到磁盘中（快、持久化没保证）。</li><li><code>always</code>：同步持久化，每次发生数据变更时，就会立即记录到磁盘中（慢，安全）。</li><li><code>everysec</code>：表示每秒同步一次（默认值，很快，但是会丢失一秒内的数据）。</li></ol>\n<p>AOF中每秒同步也是异步完成的，<strong>效率是非常高</strong>的，由于该机制对日志文件的写入操作是采用<code>append</code>的形式。</p>\n<p>因此在写入的过程即使宕机，也不会丢失已经存入日志文件的数据，数据的完整性是非常高的。</p>\n<p>在新安装的Redis的配置文件中，AOF的配置如下所示：</p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\20200507201238235.png\"/></p>\n<h5><a id=\"AOF_1255\"></a>AOF重写机制</h5>\n<p>但是，在写入所有的操作到日志文件中时，就会出现日志文件很多重复的操作，甚至是无效的操作，导致日志文件越来越大。</p>\n<p>所谓的无效的的操作，举个例子，比如某一时刻对一个k++，然后后面的某一时刻k–，这样k的值是保持不变的，那么这两次的操作就是无效的。</p>\n<p>如果像这样的无效操作很多，记录的文件臃肿，就浪费了资源空间，所以在Redis中出现了<code>rewrite</code>机制。</p>\n<p>redis提供了bgrewriteaof命令。将内存中的数据以命令的方式保存到临时文件中，同时会fork出一条新进程来将文件重写。</p>\n<p>重写AOF的日志文件不是读取旧的日志文件瘦身，而是将内存中的数据用命令的方式重写一个AOF文件，重新保存替换原来旧的日志文件，因此内存中的数据才是最新的。</p>\n<p>重写操作也会<code>fork</code>一个子进程来处理重写操作，重写以内存中的数据作为重写的源，避免了操作的冗余性，保证了数据的最新。</p>\n<p>在Redis以append的形式将修改的数据写入老的磁盘中 ，同时Redis也会创建一个新的文件用于记录此期间有哪些命令被执行。</p>\n<p>下面进行演示一下AOF的操作，首先先打开AOF机制，修改配置文件中的<code>appendonly no</code>为<code>appendonly yes</code>，然后执行如下图的操作：</p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\20200507202541200.png\"/></p>\n<p>都显示执行成功，ls以下查看此时当前的文件夹终究会出现<code>appendonly.aof</code><br/> ，AOF的数据持久化文件，通过cat命令查看内容：</p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\20200507202738498.png\"/></p>\n<p>从上面的存储的文件中可以看出，每一个命令是非常有规律的，比如第一次执行<code>key *</code>映射到该配置文件中的命令如下：</p>\n<pre><code>*2 //表示该命令两组key 为一组 * 为一组\n$6 //表示SELECT有6字符\nSELECT\n$1 //表示下面的0一个字符\n0\n</code></pre>\n<p>然后执行<code>set k1 1</code>的命令，此命令映射到文件中的命令如下：</p>\n<pre><code>*3 //表示该命令有三组set为一组 k1为一组 1为一组\n$3 // 表示set有三个字符\nset // 表示执行了set命令\n$2 // 表示k1有两个字符\nk1 // key值\n$1 // 便是value值的字符长度为1\n1  // value值\n</code></pre>\n<p>当AOF的日志文件增长到一定大小的时候Redis就能够bgrewriteaof对日志文件进行重写瘦身。当AOF配置文件大于改配置项时自动开启重写（这里指超过原大小的100%）。</p>\n<p>该配置可以通过如下的配置项进行配置：</p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\20200507204110866.png\"/></p>\n<h5><a id=\"AOF_1306\"></a>AOF的优缺点</h5>\n<p><strong>优点：</strong> AOF更好保证数据不会被丢失，最多只丢失一秒内的数据，通过foek一个子进程处理持久化操作，保证了主进程不会进程io操作，能高效的处理客户端的请求。</p>\n<p>另外重写操作保证了数据的有效性，即使日志文件过大也会进行重写。</p>\n<p>AOF的日志文件的记录可读性非常的高，即使某一时刻有人执行<code>flushall</code>清空了所有数据，只需要拿到aof的日志文件，然后把最后一条的flushall给删除掉，就可以恢复数据。</p>\n<p><strong>缺点：</strong> 对于相同数量的数据集而言，AOF文件通常要大于RDB文件。RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。AOF在运行效率上往往会慢于RDB。</p>\n<h4><a id=\"_1316\"></a>混合持久化</h4>\n<p>在redis4.0后混合持久化（RDB+AOF）对重写的优化，4.0版本的混合持久化默认是关闭的，可以通过以下的配置开启混合持久化：</p>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\20200507205817706.png\"/></p>\n<p>混合持久化也是通过<code>bgrewriteaof</code>来完成的，不同的是当开启混合持久化时，fork出的子进程先将共享内存的数据以RDB方式写入aof文件中，然后再将重写缓冲区的增量命令以AOF方式写入文件中。</p>\n<p>写入完成后通知主进程统计信息，并将新的含有RDB格式和AOF格式的AOF文件替换旧的AOF文件。简单的说：新的AOF文件前半段是以RDB格式的全量数据后半段是AOF格式的增量数据。</p>\n<p><strong>优点：</strong> 混合持久化结合<strong>RDB持久化</strong>和<strong>AOF持久化</strong>的优点，由于绝大部分的格式是RDB格式，加载速度快，增量数据以AOF方式保存，数据更少的丢失。</p>\n<h4><a id=\"RDBAOF_1328\"></a>RDB和AOF优势和劣势</h4>\n<p>rdb适合大规模的数据恢复，由于rdb时异快照的形式持久化数据，恢复的数据快，在一定的时间备份一次，而aof的保证数据更加完整，损失的数据只在秒内。</p>\n<p>具体哪种更适合生产，在官方的建议中两种持久化机制同时开启，如果两种机制同时开启，优先使用aof持久化机制。</p>\n<h1><a id=\"redis_1334\"></a>redis事务</h1>\n<h2><a id=\"_1337\"></a>前言</h2>\n<p>前几天有读者说自己面试被问到Redis的事务，虽然不常用，但是面试竟然被问到，平时自己没有注意Redis的事务这一块，面试的时候被问到非常不好受。</p>\n<p>虽然，这位读者面试最后算是过了，但是薪资方面没有拿到自己理想的薪资。</p>\n<p>其实这个也是正常的，一般面试被问到烂大街的，谁还问你啊，专门挑一些不常见的来问你，就是为了压你的薪资。</p>\n<p>所以在这里写一篇文章对Redis的事务进行详细的讲解，估计对Redis事务从理解到原理深入这一篇就够了。</p>\n<p>以后面试都不用担心了再被问道Redis的事务了，这一篇主要讲解Redis事务原理和实操的演练，理解理论的同时也通过实操来证实理论。</p>\n<h2><a id=\"_1350\"></a>事务介绍</h2>\n<p>Redis事务是一组命令的集合，将多个命令进行打包，然后这些命令会被顺序的添加到队列中，并且按顺序的执行这些命令。</p>\n<p><strong>Redis事务中没有像Mysql关系型数据库事务隔离级别的概念，不能保证原子性操作，也没有像Mysql那样执行事务失败会进行回滚操作</strong>。</p>\n<p>这个与Redis的特点：<strong>快速、高效</strong>有着密切的关联，<strong>因为一些列回滚操作、像事务隔离级别那这样加锁、解锁，是非常消耗性能的</strong>。所以，Redis中执行事务的流程只需要简单的下面三个步骤：</p>\n<ol><li>开始事务（MULTI）</li><li>命令入队</li><li>执行事务（EXEC）、撤销事务（DISCARD ）</li></ol>\n<p>在Redis中事务的实现主要是通过如下的命令实现的：</p>\n<p>命令</p>\n<p>功能描述</p>\n<p>MULTI</p>\n<p><strong>事务开始的命令</strong>，执行该命令后，后面执行的对Redis数据类型的<strong>操作命令都会顺序的放进队列中</strong>，等待执行EXEC命令后队列中的命令才会被执行</p>\n<p>DISCARD</p>\n<p><strong>放弃执行队列中的命令</strong>，你可以理解为Mysql的回滚操作，<strong>并且将当前的状态从事务状态改为非事务状态</strong>。</p>\n<p>EXEC</p>\n<p>执行该命令后<strong>表示顺序执行队列中的命令</strong>，执行完后并将结果显示在客户端，<strong>将当前状态从事务状态改为非事务状态</strong>。若是执行该命令之前有key被执行WATCH命令并且又被其它客户端修改，那么就会放弃执行队列中的所有命令，在客户端显示报错信息，若是没有修改就会执行队列中的所有命令。</p>\n<p>WATCH key</p>\n<p>表示指定监视某个key，<strong>该命令只能在MULTI命令之前执行</strong>，如果监视的key被其他客户端修改，<strong>EXEC将会放弃执行队列中的所有命令</strong></p>\n<p>UNWATCH</p>\n<p><strong>取消监视之前通过WATCH 命令监视的key</strong>，通过执行EXEC 、DISCARD 两个命令之前监视的key也会被取消监视</p>\n<p>以上就是一个Redis事务的执行过程包含的命令，下面就来详细的围绕着这几个命令进行讲解。</p>\n<h2><a id=\"_1391\"></a>开始事务</h2>\n<p><code>MULTI</code> 命令表示事务的开始，当看到OK表示已经进入事务的状态：<br/> <img alt=\"\" src=\"image\\20200703073228192.png\"/><br/> 该命令执行后客户端会将<strong>当前的状态从非事务状态修改为事务状态</strong>，这一状态的切换是将客户端的<code>flags</code>属性中打开<code>REDIS_MULTI</code>来完成的，该命令可以理解关系型数据库Mysql的<code>BEGIN TRANCATION</code>语句：<br/> <img alt=\"\" src=\"image\\20200703074516186.png\"/></p>\n<h2><a id=\"_1399\"></a>命令入队</h2>\n<p>执行完MULTI命令后，后面执行的操作Redis五种类型的命令都会按顺序的进入命令队列中，该部分也是真正的业务逻辑的部分。</p>\n<p>Redis客户端的命令执行后若是当前状态处于事务状态命令就会进入队列中，并且返回<code>QUEUED</code>字符串，表示该命令已经进入了命令队列中，并且<strong>事务队列是以先进先出（FIFO）的方式保存入队的命令</strong>的。<br/> <img alt=\"\" src=\"image\\20200703080352386.png\"/><br/> 若是当前状态是非事务状态就会立即执行命令，并将结果返回客户端。在事务状态<strong>执行操作事务的命令就会被立即执行</strong>，如<code>EXEC、DISCARD、UNWATCH</code>。<br/> <img alt=\"\" src=\"image\\20200703080802488.png\"/><br/> 结合上面的分析，Redis执行命令的流程如下图所示：<br/> <img alt=\"\" src=\"image\\20200703215457160.png\"/><br/> 事务的命令队列中有三个参数分别是：<strong>要执行的命令</strong>、<strong>命令的参数</strong>、<strong>参数的个数</strong>。例如：通过执行如下的命令：</p>\n<pre><code>redis&gt; MULTI\nOK\nredis&gt; SET name \"黎杜\"\nQUEUED\nredis&gt; GET name\nQUEUED\n</code></pre>\n<p>那么对应上面的队列中三个参数如下表格所示：</p>\n<p>执行的命令</p>\n<p>命令的参数</p>\n<p>参数的个数</p>\n<p>SET</p>\n<p>[“name”, “黎杜”]</p>\n<p>2</p>\n<p>GET</p>\n<p>[“name”]</p>\n<p>1</p>\n<h2><a id=\"_1440\"></a>执行事务</h2>\n<p>当客户端执行EXEC命令的时候，上面的命令队列就会被按照先进先出的顺序被执行，当然执行的结果有成功有失败，这个后面分析。</p>\n<p>上面说到当客户端处于非事务的状态命令发送到服务端会被立即执行，若是客户端处于事务状态命令就会被放进命令队列。</p>\n<p>命令入队的时候，会按照顺序进入队列，队列以先进先出的特点来执行队列中的命令。</p>\n<p>若是客户端处于事务状态，执行的是<code>EXEC、DISCARD、UNWATCH</code>这些操作事务的命令，也会被立即执行。<br/> <img alt=\"\" src=\"image\\20200703215457160.png\"/><br/> <strong>（1）正常执行</strong></p>\n<p>还是上面的例子，执行如下的代码：</p>\n<pre><code>redis&gt; MULTI\nOK\nredis&gt; SET name \"黎杜\"\nQUEUED\nredis&gt; GET name\nQUEUED\n</code></pre>\n<p>所有的命令进入了队列，当最后执行EXEC，首先会执行SET命令，然后执行GET命令，并且执行后的结果也会进入一个队列中保存，最后返回给客户端：</p>\n<p>回复的类型</p>\n<p>回复的内容</p>\n<p>status code reply</p>\n<p>OK</p>\n<p>bulk reply</p>\n<p>“黎杜”</p>\n<p>所以最后你会在客户端看到<strong>OK、黎杜</strong>，这样的结果显示，这个也就是一个事务成功执行的过程。</p>\n<p>至此一个事务就完整的执行完成，并且此时客户端也从事务状态更改为非事务状态。<br/> <img alt=\"\" src=\"image\\20200703223053698.png\"/></p>\n<p><strong>（2）放弃事务</strong></p>\n<p>当然你也可以放弃执行该事务，只要你再次执行DISCARD操作就会放弃执行此次的事务。具体代码如下所示：</p>\n<pre><code>redis&gt; MULTI\nOK\nredis&gt; SET name \"黎杜\"\nQUEUED\nredis&gt; GET name\nQUEUED\nredis&gt; DISCARD    // 放弃执行事务\nOK\n</code></pre>\n<p>DISCARD命令取消一个事务的时候，就会将命令队列清空，并且将客户端的状态从事务状态修改为非事务的状态。</p>\n<p><strong>Redis的事务是不可重复的</strong>，当客户端处于事务状态的时候，再次向服务端发送MULTI命令时，直接就会向客户端返回错误。</p>\n<h2><a id=\"WATCH__1500\"></a>WATCH 命令</h2>\n<p><code>WATCH</code>命令是在MULTI命令之前执行的，表示监视任意数量的key，与它对应的命令就是<code>UNWATCH</code>命令，取消监视的key。</p>\n<p><code>WATCH</code>命令有点<strong>类似于乐观锁机制</strong>，在事务执行的时候，若是被监视的任意一个key被更改，则队列中的命令不会被执行，直接向客户端返回(nil)表示事务执行失败。</p>\n<p>下面我们来演示一下WATCH命令的操作流程，具体实现代码如下：</p>\n<pre><code>redis&gt; WATCH num\nOK\nredis&gt; MULTI\nOK\nredis&gt; incrby num 10\nQUEUED\nredis&gt; decrby num 1\nQUEUED\nredis&gt; EXEC   // 执行成功\n</code></pre>\n<p>这个是<code>WATCH</code>命令的正常的操作流程，若是在其它的客户端，修改了被监视的任意key，就会放弃执行该事务，如下图所示：</p>\n<p>客户端一</p>\n<p>客户端二</p>\n<p>WATCH num</p>\n<p>MULTI</p>\n<p>incrby num 10</p>\n<p>get num</p>\n<p>decrby num 1</p>\n<p>EXEC</p>\n<p>执行失败，返回(nil)</p>\n<p>WATCH命令的底层实现中保存了<code>watched_keys</code> 字典，<strong>字典的键保存的是监视的key，值是一个链表，链表中的每个节点值保存的是监视该key的客户端</strong>。<br/> <img alt=\"\" src=\"image\\20200703232716480.png\"/><br/> 若是某个客户端不再监视某个key，该客户端就会从链表中脱离。如client3，通过执行UNWATCH命令，不再监视key1：<br/> <img alt=\"\" src=\"image\\20200703232916783.png\"/></p>\n<h2><a id=\"_1545\"></a>错误处理</h2>\n<p>上面说到Redis是没有回滚机制的，那么执行的过程，若是不小心敲错命令，Redis的命令发送到服务端没有被立即执行，所以是暂时发现不到该错误。</p>\n<p>那么在Redis中的错误处理主要分为两类：<strong>语法错误</strong>、<strong>运行错误</strong>。下面主要来讲解一下这两类错误的区别。</p>\n<p><strong>（1）语法错误</strong></p>\n<p>比如执行命令的时候，命令的不存在或者错误的敲错命令、参数的个数不对等都会导致语法错误。</p>\n<p>下面来演示一下，执行下面的四个命令，前后的两个命令是正确的，中间的两个命令是错误的，如下所示：</p>\n<pre><code>127.0.0.1:6379&gt; multi\nOK\n127.0.0.1:6379&gt; set num 1\nQUEUED\n127.0.0.1:6379&gt; set num\n(error) ERR wrong number of arguments for 'set' command\n127.0.0.1:6379&gt; ssset num 3\n(error) ERR unknown command 'ssset'\n127.0.0.1:6379&gt; set num 2\nQUEUED\n127.0.0.1:6379&gt; exec\n(error) EXECABORT Transaction discarded because of previous errors.\n</code></pre>\n<p>语法错误是在Redis语法检测的时候就能发现的，所以当你执行错误命令的时候，也会即使的返回错误的提示。</p>\n<p>最后，即使命令进入队列，只要存在语法错误，该队列中的命令都不会被执行，会直接向客户端返回事务执行失败的提示。</p>\n<p><strong>（2）运行错误</strong></p>\n<p>执行时使用不同类型的操作命令操作不同数据类型就会出现运行时错误，这种错误时Redis在不执行命令的情况下，是无法发现的。</p>\n<pre><code>127.0.0.1:6379&gt; multi\nOK\n127.0.0.1:6379&gt; set num 3\nQUEUED\n127.0.0.1:6379&gt; sadd num 4\nQUEUED\n127.0.0.1:6379&gt; set num 6\nQUEUED\n127.0.0.1:6379&gt; exec\n1) OK\n2) (error) WRONGTYPE Operation against a key holding the wrong kind of value\n3) OK\n127.0.0.1:6379&gt; get key\n\"6\"\n</code></pre>\n<p>这样就会导致，正确的命令被执行，而错误的命令不会不执行，这也显示出Redis的事务并不能保证数据的一致性，因为中间出现了错误，有些语句还是被执行了。</p>\n<p>这样的结果只能程序员自己根据之前执行的命令，自己一步一步正确的回退，所谓自己的烂摊子，自己收拾。</p>\n<h2><a id=\"RedisMysql_1600\"></a>Redis事务与Mysql事务</h2>\n<p>我们知道关系性数据库Mysql中具有事务的四大特性：<strong>原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）</strong>。</p>\n<p>但是Redis的事务为了保证Redis除了客户端的请求高效，去除了传统关系型数据库的<strong>事务回滚、加锁、解锁</strong>这些消耗性能的操作，Redis的事务实现简单。</p>\n<p>原子性中Redis的事务只能保证单个命令的原子性，多个命令就无法保证，如上面索道的运行时错误，即使中间有运行时错误出现也会正确的执行后面正确的命令，不具有回滚操作。</p>\n<p>既然没有了原子性，数据的一致性也就无法保证，这些都需要程序员自己手动去实现。</p>\n<p>Reids在进行事务的时候，不会被中断知道事务的运行结束，也具有一定的隔离性，并且Redis也能持久化数据。</p>\n<h1><a id=\"_1613\"></a>集群</h1>\n<h2><a id=\"_1616\"></a>集群概述</h2>\n<p>Redis作为缓存的高效中间件，在我们日常的开发中被频繁的使用，今天就来说一说Redis的四种模式，分别是<strong>单机版、主从复制、哨兵、以及集群模式</strong>。</p>\n<p>可能，在一般公司的程序员使用单机版基本都能解决问题，在Redis的官网给出的数据是<code>10W QPS</code>，这对于应付一般的公司绰绰有余了，再不行就来个主从模式，实现都写分离，性能又大大提高。</p>\n<p>但是，我们作为有抱负的程序员，仅限于单机版和主从模式的crud是不行的，至少也要了解<strong>哨兵</strong>和<strong>集群模式</strong>的原理，这样面试的时候才能和面试官扯皮啊。</p>\n<h2><a id=\"_1625\"></a>单机</h2>\n<p>单机版的Redis就比较简单了，基本90%的程序员都是用过，官网推荐操作Redis的第三方依赖库是Jedis，在SpringBoot项目中，引入下面依赖就可以直接使用了：</p>\n<pre><code>&lt;dependency&gt;\n\t  &lt;groupId&gt;redis.clients&lt;/groupId&gt;\n\t  &lt;artifactId&gt;jedis&lt;/artifactId&gt;\n\t  &lt;version&gt;${jedis.version}&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<h3><a id=\"_1637\"></a>优点</h3>\n<p>单机版的Redis也有很多优点，比如实现实现简单、维护简单、部署简单、维护成本非常低，不需要其它额外的开支。</p>\n<h3><a id=\"_1641\"></a>缺点</h3>\n<p>但是，因为是单机版的Redis所以也存在很多的问题，比如最明显的单点故障问题，一个Redis挂了，所有的请求就会直接打在了DB上。</p>\n<p>并且一个Redis抗并发数量也是有限的，同时要兼顾读写两种请求，只要访问量一上来，Redis就受不了了，另一方面单机版的Redis数据量存储也是有限的，数据量一大，再重启Redis的时候，就会非常的慢，所以局限性也是比较大的。</p>\n<h3><a id=\"_1647\"></a>实操搭建</h3>\n<p>单机版的搭建教程，在网上有非常多的全面的教程，基本就是傻瓜式操作，特别是在本地搭建的话，基本使用yum快捷方便，几句命令就搞定了，这里推荐一个搭建教程：https://www.cnblogs.com/<br/> zuidongfeng/p/8032505.html。</p>\n<p>上面这个教程讲的非常的详细，环境的搭建本来是运维的工作，但是作为程序员尝试自己去搭建环境还是有必要的，而且搭建环境这种东西，基本就是一劳永逸，搭建一次，可能下次换电脑或者重装虚拟机才会再次搭建。</p>\n<p>这里也放出redis常用的<code>redis.conf</code>的配置项，并且附带注释，看我是不是很暖男：</p>\n<pre><code>daemonize yes  // 设置后台启动，一般设置yes\npidfile /var/run/redis.pid // edis以守护进程方式运行时,redis默认会把pid写入/var/run/redis.pid文件\nport 6379 // 默认端口为6379\nbind 127.0.0.1 //主机地址，设置未0.0.0.0表示都可以访问。127.0.0.1表示只允许本机访问\ntimeout 900  // 客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能\nlogfile stdout // 日志记录方式，默认为标准输出\nlogfile \"./redis7001.log\"  # 指明日志文件名\ndatabases 16 // 设置数据库的数量，默认数据库为0\nsave  //有多少次更新操作，就将数据同步到数据文件\n\tRedis默认配置文件中提供了三个条件：\n\tsave 900 1 //900秒（15分钟）内有1个更改\n\tsave 300 10 //300秒（5分钟）内有10个更改\n\tsave 60 10000  // 60秒内有10000个更改\nrdbcompression yes // 指定存储至本地数据库时是否压缩数据\ndbfilename dump.rdb //指定本地数据库文件名\ndir ./    //指定本地数据库存放目录\nslaveof  // 主从同步设置，设置主数据库的ip和端口\n# 如果非零，则设置SO_KEEPALIVE选项来向空闲连接的客户端发送ACK\ntcp-keepalive 60\n# 默认如果开启RDB快照(至少一条save指令)并且最新的后台保存失败，Redis将会停止接受写操作\n# 这将使用户知道数据没有正确的持久化到硬盘，否则可能没人注意到并且造成一些灾难\nstop-writes-on-bgsave-error yes\n# 默认如果开启RDB快照(至少一条save指令)并且最新的后台保存失败，Redis将会停止接受写操作。\nstop-writes-on-bgsave-error yes\n# 当导出到 .rdb 数据库时是否用LZF压缩字符串对象\nrdbcompression yes\n# 版本5的RDB有一个CRC64算法的校验和放在了文件的最后。这将使文件格式更加可靠。\nrdbchecksum yes\n# 持久化数据库的文件名\ndbfilename dump-master.rdb\n# 工作目录\ndir /usr/local/redis-4.0.8/redis_master/\n# slav服务连接master的密码\nmasterauth testmaster123\n# 当一个slave失去和master的连接，或者同步正在进行中，slave的行为可以有两种：\n#1) 如果 slave-serve-stale-data 设置为 \"yes\" (默认值)，slave会继续响应客户端请求，可能是正常数据，或者是过时了的数据，也可能是还没获得值的空数据。\n# 2) 如果 slave-serve-stale-data 设置为 \"no\"，slave会回复\"正在从master同步\n# （SYNC with master in progress）\"来处理各种请求，除了 INFO 和 SLAVEOF 命令。\nslave-serve-stale-data yes\n# 配置是否仅读\nslave-read-only yes\n# 如果你选择“yes”Redis将使用更少的TCP包和带宽来向slaves发送数据。但是这将使数据传输到slave上有延迟，Linux内核的默认配置会达到40毫秒\n# 如果你选择了 \"no\" 数据传输到salve的延迟将会减少但要使用更多的带宽\nrepl-disable-tcp-nodelay no\n# slave的优先级，优先级数字小的salve会优先考虑提升为master\nslave-priority 100\n# 密码验证\nrequirepass testmaster123\n# redis实例最大占用内存，一旦内存使用达到上限，Redis会根据选定的回收策略（参见：\n# maxmemmory-policy）删除key\nmaxmemory 3gb\n# 最大内存策略：如果达到内存限制了，Redis如何选择删除key。\n# volatile-lru -&gt; 根据LRU算法删除带有过期时间的key。\n# allkeys-lru -&gt; 根据LRU算法删除任何key。\n# volatile-random -&gt; 根据过期设置来随机删除key, 具备过期时间的key。 \n# allkeys-&gt;random -&gt; 无差别随机删, 任何一个key。 \n# volatile-ttl -&gt; 根据最近过期时间来删除（辅以TTL）, 这是对于有过期时间的key \n# noeviction -&gt; 谁也不删，直接在写操作时返回错误。\nmaxmemory-policy volatile-lru\n# AOF开启\nappendonly no\n# aof文件名\nappendfilename \"appendonly.aof\"\n# fsync() 系统调用告诉操作系统把数据写到磁盘上，而不是等更多的数据进入输出缓冲区。\n# 有些操作系统会真的把数据马上刷到磁盘上；有些则会尽快去尝试这么做。\n# Redis支持三种不同的模式：\n# no：不要立刻刷，只有在操作系统需要刷的时候再刷。比较快。\n# always：每次写操作都立刻写入到aof文件。慢，但是最安全。\n# everysec：每秒写一次。折中方案。 \nappendfsync everysec\n# 如果AOF的同步策略设置成 \"always\" 或者 \"everysec\"，并且后台的存储进程（后台存储或写入AOF\n# 日志）会产生很多磁盘I/O开销。某些Linux的配置下会使Redis因为 fsync()系统调用而阻塞很久。\n# 注意，目前对这个情况还没有完美修正，甚至不同线程的 fsync() 会阻塞我们同步的write(2)调用。\n# 为了缓解这个问题，可以用下面这个选项。它可以在 BGSAVE 或 BGREWRITEAOF 处理时阻止主进程进行fsync()。\n# 这就意味着如果有子进程在进行保存操作，那么Redis就处于\"不可同步\"的状态。\n# 这实际上是说，在最差的情况下可能会丢掉30秒钟的日志数据。（默认Linux设定）\n# 如果你有延时问题把这个设置成\"yes\"，否则就保持\"no\"，这是保存持久数据的最安全的方式。\nno-appendfsync-on-rewrite yes\n# 自动重写AOF文件\nauto-aof-rewrite-percentage 100\nauto-aof-rewrite-min-size 64mb\n# AOF文件可能在尾部是不完整的（这跟system关闭有问题，尤其是mount ext4文件系统时\n# 没有加上data=ordered选项。只会发生在os死时，redis自己死不会不完整）。\n# 那redis重启时load进内存的时候就有问题了。\n# 发生的时候，可以选择redis启动报错，并且通知用户和写日志，或者load尽量多正常的数据。\n# 如果aof-load-truncated是yes，会自动发布一个log给客户端然后load（默认）。\n# 如果是no，用户必须手动redis-check-aof修复AOF文件才可以。\n# 注意，如果在读取的过程中，发现这个aof是损坏的，服务器也是会退出的，\n# 这个选项仅仅用于当服务器尝试读取更多的数据但又找不到相应的数据时。\naof-load-truncated yes\n# Lua 脚本的最大执行时间，毫秒为单位\nlua-time-limit 5000\n# Redis慢查询日志可以记录超过指定时间的查询\nslowlog-log-slower-than 10000\n# 这个长度没有限制。只是要主要会消耗内存。你可以通过 SLOWLOG RESET 来回收内存。\nslowlog-max-len 128\n# 客户端的输出缓冲区的限制，可用于强制断开那些因为某种原因从服务器读取数据的速度不够快的客户端\nclient-output-buffer-limit normal 0 0 0\nclient-output-buffer-limit slave 256mb 64mb 60\nclient-output-buffer-limit pubsub 32mb 8mb 60\n# 当一个子进程重写AOF文件时，文件每生成32M数据会被同步\naof-rewrite-incremental-fsync yes\n</code></pre>\n<p>由于，单机版的Redis在并发量比较大的时候，并且需要较高性能和可靠性的时候，单机版基本就不适合了，于是就出现了<strong>主从模式</strong>。</p>\n<h2><a id=\"_1762\"></a>主从模式</h2>\n<h3><a id=\"_1765\"></a>原理</h3>\n<p>主从的原理还算是比较简单的，一主多从，<strong>主数据库（master）可以读也可以写（read/write），从数据库仅读（only read）</strong>。</p>\n<p>但是，主从模式一般实现<strong>读写分离</strong>，<strong>主数据库仅写（only write）</strong>，减轻主数据库的压力，下面一张图搞懂主从模式的原理：</p>\n<p><img alt=\"\" src=\"image\\20200819225047906.png\"/></p>\n<p>主从模式原理就是那么简单，那他执行的过程（工作机制）又是怎么样的呢？再来一张图：</p>\n<p><img alt=\"\" src=\"image\\20200819225904123.png\"/><br/> 当开启主从模式的时候，他的具体工作机制如下：</p>\n<ol><li>当slave启动后会向master发送<code>SYNC</code>命令，master节后到从数据库的命令后通过<code>bgsave</code>保存快照（<strong>RDB持久化</strong>），并且期间的执行的些命令会被缓存起来。</li><li>然后master会将保存的快照发送给slave，并且继续缓存期间的写命令。</li><li>slave收到主数据库发送过来的快照就会加载到自己的数据库中。</li><li>最后master讲缓存的命令同步给slave，slave收到命令后执行一遍，这样master与slave数据就保持一致了。</li></ol>\n<h3><a id=\"_1783\"></a>优点</h3>\n<p>之所以运用主从，是因为主从一定程度上解决了单机版并发量大，导致请求延迟或者redis宕机服务停止的问题。</p>\n<p>从数据库分担主数据库的读压力，若是主数据库是只写模式，那么实现读写分离，主数据库就没有了读压力了。</p>\n<p>另一方面解决了单机版单点故障的问题，若是主数据库挂了，那么从数据库可以随时顶上来，综上来说，主从模式一定程度上提高了系统的可用性和性能，是实现哨兵和集群的基础。</p>\n<p>主从同步以异步方式进行同步，期间Redis仍然可以响应客户端提交的查询和更新的请求。</p>\n<h3><a id=\"_1793\"></a>缺点</h3>\n<p>主从模式好是好，他也有自己的缺点，比如数据的一致性问题，假如主数据库写操作完成，那么他的数据会被复制到从数据库，若是还没有即使复制到从数据库，读请求又来了，此时读取的数据就不是最新的数据。</p>\n<p>若是从主同步的过程网络出故障了，导致主从同步失败，也会出现问题数据一致性的问题。</p>\n<p>主从模式不具备自动容错和恢复的功能，一旦主数据库，从节点晋升未主数据库的过程需要人为操作，维护的成本就会升高，并且主节点的写能力、存储能力都会受到限制。</p>\n<h3><a id=\"_1801\"></a>实操搭建</h3>\n<p>下面的我们来实操搭建一下主从模式，主从模式的搭建还是比较简单的，我这里一台centos 7虚拟机，使用开启redis多实例的方法搭建主从。</p>\n<p>redis中开启多实例的方法，首先创建一个文件夹，用于存放redis集群的配置文件：</p>\n<pre><code>mkdir redis\n</code></pre>\n<p>然后粘贴复制<code>redis.conf</code>配置文件：</p>\n<pre><code>cp /root/redis-4.0.6/redis.conf /root/redis/redis-6379.conf\ncp /root/redis-4.0.6/redis.conf /root/redis/redis-6380.conf\ncp /root/redis-4.0.6/redis.conf /root/redis/redis-6381.conf\n</code></pre>\n<p>复制三份配置文件，一主两从，6379端口作为主数据库（master），6380、6381作为从数据库（slave）。</p>\n<p>首先是配置主数据库的配置文件：<code>vi redis-6379.conf</code>：</p>\n<pre><code>bind 0.0.0.0 # 注释掉或配置成0.0.0.0表示任意IP均可访问。\nprotected-mode no # 关闭保护模式，使用密码访问。\nport 6379  # 设置端口，6380、6381依次为6380、6381。\ntimeout 30 # 客户端连接空闲多久后断开连接，单位秒，0表示禁用\ndaemonize yes # 在后台运行\npidfile /var/run/redis_6379.pid  # pid进程文件名，6380、6381依次为redis_6380.pid、redis_6381.pid\nlogfile /root/reids/log/6379.log # 日志文件，6380、6381依次为6380.log、6381.log\nsave 900 1 # 900s内至少一次写操作则执行bgsave进行RDB持久化\nsave 300 10\nsave 60 10000 \nrdbcompression yes #是否对RDB文件进行压缩，建议设置为no，以（磁盘）空间换（CPU）时间\ndbfilename dump.rdb # RDB文件名称\ndir /root/redis/datas # RDB文件保存路径，AOF文件也保存在这里\nappendonly yes # 表示使用AOF增量持久化的方式\nappendfsync everysec # 可选值 always， everysec，no，建议设置为everysec\nrequirepass 123456 # 设置密码\n</code></pre>\n<p>然后，就是修改从数据库的配置文件，在从数据库的配置文件中假如以下的配置信息：</p>\n<pre><code>slaveof 127.0.0.1 6379 # 配置master的ip，port\nmasterauth 123456 # 配置访问master的密码\nslaveof-serve-stale-data no \n</code></pre>\n<p>接下来就是启动三个redis实例，启动的命令，先cd到redis的src目录下，然后执行：</p>\n<pre><code>./redis-server /root/redis/6379.conf\n./redis-server /root/redis/6380.conf\n./redis-server /root/redis/6381.conf\n</code></pre>\n<p>通过命令<code>ps -aux | grep redis</code>，查看启动的redis进程：<br/> <img alt=\"\" src=\"image\\20200820204333336.png\"/><br/> 如上图所示，表示启动成功，下面就开始进入测试阶段。</p>\n<h3><a id=\"_1857\"></a>测试</h3>\n<p>我这里使用SecureCRT作为redis连接的客户端，同时启动三个SecureCRT，分别连接redis1的三个实例，启动时指定端口以及密码：</p>\n<pre><code>./redis-cli -p 6379 -a 123456\n</code></pre>\n<p><img alt=\"\" src=\"image\\20200820204731199.png\"/><br/> 启动后，在master（6379），输入：set name ‘ldc’，在slave中通过get name，可以查看：</p>\n<p><img alt=\"\" src=\"image\\20200820205001147.png\"/><br/> 数据同步成功，这有几个坑一个是redis.conf中没有设置对bind，会导致非本机的ip被过滤掉，一般配置0.0.0.0就可以了。</p>\n<p>另一个是没有配置密码requirepass 123456，会导致IO一直连接异常，这个是我遇到的坑，后面配置密码后就成功了。</p>\n<p>还有，就是查看redis的启动日志可以发现有两个warning，虽然不影响搭建主从同步，看着挺烦人的，但是有些人会遇到，有些人不会遇到。</p>\n<p>但是，我这个人比较有强迫症，百度也是有解决方案的，这里就不讲了，交给你们自己解决，这里只是告诉你有这个问题，有些人看都不看日志的，看到启动成功就认为万事大吉了，也不看日志，这习惯并不好。</p>\n<p><img alt=\"\" src=\"image\\20200820205612260.png\"/></p>\n<h2><a id=\"_1878\"></a>哨兵模式</h2>\n<h3><a id=\"_1881\"></a>原理</h3>\n<p>哨兵模式是主从的升级版，因为主从的出现故障后，不会自动恢复，需要人为干预，这就很蛋疼啊。</p>\n<p>在主从的基础上，实现哨兵模式就是为了监控主从的运行状况，对主从的健壮进行监控，就好像哨兵一样，只要有异常就发出警告，对异常状况进行处理。</p>\n<p><img alt=\"\" src=\"image\\20200820210040554.png\"/><br/> 所以，总的概括来说，哨兵模式有以下的优点（功能点）：</p>\n<ol><li><strong>监控</strong>：监控master和slave是否正常运行，以及哨兵之间也会相互监控</li><li><strong>自动故障恢复</strong>：当master出现故障的时候，会自动选举一个slave作为master顶上去。</li></ol>\n<p>哨兵模式的监控配置信息，是通过配置从数据库的<code>sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</code> 来指定的，比如：</p>\n<pre><code>// mymaster 表示给master数据库定义了一个名字，后面的是master的ip和端口，1表示至少需要一个Sentinel进程同意才能将master判断为失效，如果不满足这个条件，则自动故障转移（failover）不会执行\nsentinel monitor mymaster 127.0.0.1 6379 1\n</code></pre>\n<h3><a id=\"_1899\"></a>节点通信</h3>\n<p>当然还有其它的配置信息，其它配置信息，在环境搭建的时候再说。当哨兵启动后，会与master建立一条连接，用于订阅master的<code>_sentinel_:hello</code>频道。</p>\n<p>该频道用于获取监控该master的其它哨兵的信息。并且还会建立一条定时向master发送INFO命令获取master信息的连接。</p>\n<p><strong>当哨兵与master建立连接后，定期会向（10秒一次）master和slave发送INFO命令，若是master被标记为主观下线，频率就会变为1秒一次。</strong></p>\n<p>并且，定期向<code>_sentinel_:hello</code>频道发送自己的信息，以便其它的哨兵能够订阅获取自己的信息，发送的内容包含<strong>哨兵的ip和端口、运行id、配置版本、master名字、master的ip端口还有master的配置版本</strong>等信息。</p>\n<p>以及，<strong>定期的向master、slave和其它哨兵发送PING命令（每秒一次），以便检测对象是否存活</strong>，若是对方接收到了PING命令，无故障情况下，会回复PONG命令。</p>\n<p>所以，哨兵通过建立这两条连接、通过定期发送INFO、PING命令来实现哨兵与哨兵、哨兵与master之间的通信。</p>\n<p>这里涉及到一些概念需要理解，INFO、PING、PONG等命令，后面还会有MEET、FAIL命令，以及主观下线，当然还会有客观下线，这里主要说一下这几个概念的理解：</p>\n<ol><li>INFO：该命令可以获取主从数据库的最新信息，可以实现新结点的发现</li><li>PING：该命令被使用最频繁，该命令封装了自身节点和其它节点的状态数据。</li><li>PONG：当节点收到MEET和PING，会回复PONG命令，也把自己的状态发送给对方。</li><li>MEET：该命令在新结点加入集群的时候，会向老节点发送该命令，表示自己是个新人</li><li>FAIL：当节点下线，会向集群中广播该消息。</li></ol>\n<h3><a id=\"_1921\"></a>上线和下线</h3>\n<p>当哨兵与master相同之后就会定期一直保持联系，若是某一时刻哨兵发送的PING在指定时间内没有收到回复（<code>sentinel down-after-milliseconds master-name milliseconds</code> 配置），那么发送PING命令的哨兵就会认为该master<strong>主观下线</strong>（<code>Subjectively Down</code>）。</p>\n<p>因为有可能是哨兵与该master之间的网络问题造成的，而不是master本身的原因，所以哨兵同时会询问其它的哨兵是否也认为该master下线，若是认为该节点下线的哨兵达到一定的数量（<strong>前面的quorum字段配置</strong>），就会认为该节点<strong>客观下线</strong>（<code>Objectively Down</code>）。</p>\n<p>若是没有足够数量的sentinel同意该master下线，则该master客观下线的标识会被移除；若是master重新向哨兵的PING命令回复了客观下线的标识也会被移除。</p>\n<h3><a id=\"_1929\"></a>选举算法</h3>\n<p>当master被认为客观下线后，又是怎么进行故障恢复的呢？原来哨兵中首先选举出一个老大哨兵来进行故障恢复，选举老大哨兵的算法叫做<strong>Raft算法</strong>：</p>\n<ol><li>发现master下线的哨兵（sentinelA）会向其它的哨兵发送命令进行拉票，要求选择自己为哨兵大佬。</li><li>若是目标哨兵没有选择其它的哨兵，就会选择该哨兵（sentinelA）为大佬。</li><li>若是选择sentinelA的哨兵超过半数（半数原则），该大佬非sentinelA莫属。</li><li>如果有多个哨兵同时竞选，并且可能存在票数一致的情况，就会等待下次的一个随机时间再次发起竞选请求，进行新的一轮投票，直到大佬被选出来。</li></ol>\n<p>选出大佬哨兵后，大佬哨兵就会对故障进行自动回复，从slave中选出一名slave作为主数据库，选举的规则如下所示：</p>\n<ol><li>所有的slave中<code>slave-priority</code>优先级最高的会被选中。</li><li>若是优先级相同，会选择偏移量最大的，因为偏移量记录着数据的复制的增量，越大表示数据越完整。</li><li>若是以上两者都相同，选择ID最小的。</li></ol>\n<p>通过以上的层层筛选最终实现故障恢复，当选的slave晋升为master，其它的slave会向新的master复制数据，若是down掉的master重新上线，会被当作slave角色运行。</p>\n<h3><a id=\"_1946\"></a>优点</h3>\n<p>哨兵模式是主从模式的升级版，所以在系统层面提高了系统的可用性和性能、稳定性。当master宕机的时候，能够自动进行故障恢复，需不要人为的干预。</p>\n<p>哨兵于哨兵之间、哨兵与master之间能够进行及时的监控，心跳检测，及时发现系统的问题，这都是弥补了主从的缺点。</p>\n<h3><a id=\"_1952\"></a>缺点</h3>\n<p>哨兵一主多从的模式同样也会遇到写的瓶颈，已经存储瓶颈，若是master宕机了，故障恢复的时间比较长，写的业务就会受到影响。</p>\n<p>增加了哨兵也增加了系统的复杂度，需要同时维护哨兵模式。</p>\n<h3><a id=\"_1958\"></a>实操搭建</h3>\n<p>最后，我们进行一下哨兵模式的搭建，配置哨兵模式还是比较简单的，在上面配置的主从模式的基础上，同时创建一个文件夹用于存放三个哨兵的配置文件：</p>\n<pre><code>mkdir /root/redis-4.0.6/sentinel.conf  /root/redis/sentinel/sentinel1.conf \nmkdir /root/redis-4.0.6/sentinel.conf  /root/redis/sentinel/sentinel2.conf \nmkdir /root/redis-4.0.6/sentinel.conf  /root/redis/sentinel/sentinel3.conf \n</code></pre>\n<p>分别在这三个文件中添加如下配置：</p>\n<pre><code>daemonize yes # 在后台运行\nsentinel monitor mymaster 127.0.0.1 6379 1 # 给master起一个名字mymaster，并且配置master的ip和端口\nsentinel auth-pass mymaster 123456 # master的密码\nport 26379 #另外两个配置36379,46379端口\nsentinel down-after-milliseconds mymaster 3000 # 3s未回复PING就认为master主观下线\nsentinel parallel-syncs mymaster 2  # 执行故障转移时，最多可以有2个slave实例在同步新的master实例\nsentinel failover-timeout mymaster 100000 # 如果在10s内未能完成故障转移操作认为故障转移失败\n</code></pre>\n<p>配置完后分别启动三台哨兵：</p>\n<pre><code>./redis-server sentinel1.conf --sentinel\n./redis-server sentinel2.conf --sentinel\n./redis-server sentinel3.conf --sentinel\n</code></pre>\n<p>然后通过：<code>ps -aux|grep redis</code>进行查看：<br/> <img alt=\"\" src=\"image\\2020082122573158.png\"/><br/> 可以看到三台redis实例以及三个哨兵都已经正常启动，现登陆6379，通过INFO Repliaction查看master信息：</p>\n<p><img alt=\"\" src=\"image\\20200821225948963.png\"/><br/> 当前master为6379，然后我们来测试一下哨兵的自动故障恢复，直接kill掉6379进程，然后通过登陆6380再次查看master的信息：</p>\n<p><img alt=\"\" src=\"image\\20200821230311905.png\"/><br/> 可以看到当前的6380角色是master，并且6380可读可写，而不是只读模式，这说明我们的哨兵是起作用了，搭建成功，感兴趣的可以自行搭建，也有可能你会踩一堆的坑。</p>\n<h2><a id=\"Cluster_1995\"></a>Cluster模式</h2>\n<p>最后，Cluster是真正的集群模式了，哨兵解决和主从不能自动故障恢复的问题，但是同时也存在难以扩容以及单机存储、读写能力受限的问题，并且集群之前都是一台redis都是全量的数据，这样所有的redis都冗余一份，就会大大消耗内存空间。</p>\n<p>集群模式实现了Redis数据的分布式存储，实现数据的分片，每个redis节点存储不同的内容，并且解决了在线的节点收缩（下线）和扩容（上线）问题。</p>\n<p>集群模式真正意义上实现了系统的高可用和高性能，但是集群同时进一步使系统变得越来越复杂，接下来我们来详细的了解集群的运作原理。</p>\n<h3><a id=\"_2004\"></a>数据分区原理</h3>\n<p>集群的原理图还是很好理解的，在Redis集群中采用的使虚拟槽分区算法，会把redis集群分成16384 个槽（0 -16383）。</p>\n<p>比如：下图所示三个master，会把0 -16383范围的槽可能分成三部分（0-5000）、（5001-11000）、（11001-16383）分别数据三个缓存节点的槽范围。</p>\n<p><img alt=\"\" src=\"image\\20200821231740363.png\"/><br/> 当客户端请求过来，会首先通过对key进行CRC16 校验并对 16384 取模（CRC16(key)%16383）计算出key所在的槽，然后再到对应的槽上进行取数据或者存数据，这样就实现了数据的访问更新。</p>\n<p><img alt=\"\" src=\"image\\2020082209480475.png\"/></p>\n<p>之所以进行分槽存储，是将一整堆的数据进行分片，防止单台的redis数据量过大，影响性能的问题。</p>\n<h3><a id=\"_2017\"></a>节点通信</h3>\n<p>节点之间实现了将数据进行分片存储，那么节点之间又是怎么通信的呢？这个和前面哨兵模式讲的命令基本一样。</p>\n<p>首先新上线的节点，会通过 Gossip 协议向老成员发送Meet消息，表示自己是新加入的成员。</p>\n<p>老成员收到Meet消息后，在没有故障的情况下会恢复PONG消息，表示欢迎新结点的加入，除了第一次发送Meet消息后，之后都会发送定期PING消息，实现节点之间的通信。</p>\n<p><img alt=\"\" src=\"image\\20200822094911166.png\"/></p>\n<p>通信的过程中会为每一个通信的节点开通一条tcp通道，之后就是定时任务，不断的向其它节点发送PING消息，这样做的目的就是为了了解节点之间的元数据存储情况，以及健康状况，以便即使发现问题。</p>\n<h3><a id=\"_2029\"></a>数据请求</h3>\n<p>上面说到了槽信息，在Redis的底层维护了<code>unsigned char myslots[CLUSTER_SLOTS/8]</code> 一个数组存放每个节点的槽信息。</p>\n<p>因为他是一个二进制数组，只有存储0和1值，如下图所示：</p>\n<p><img alt=\"\" src=\"image\\20200822095444284.png\"/></p>\n<p>这样数组只表示自己是否存储对应的槽数据，若是1表示存在该数据，0表示不存在该数据，这样查询的效率就会非常的高，类似于布隆过滤器，二进制存储。</p>\n<p>比如：集群节点1负责存储0-5000的槽数据，但是此时只有0、1、2存储有数据，其它的槽还没有存数据，所以0、1、2对应的值为1。</p>\n<p>并且，每个redis底层还维护了一个clusterNode数组，大小也是16384，用于储存负责对应槽的节点的ip、端口等信息，这样每一个节点就维护了其它节点的元数据信息，便于及时的找到对应的节点。</p>\n<p>当新结点加入或者节点收缩，通过PING命令通信，及时的更新自己clusterNode数组中的元数据信息，这样有请求过来也就能及时的找到对应的节点。</p>\n<p><img alt=\"\" src=\"image\\20200822100050154.png\"/><br/> 有两种其它的情况就是，若是请求过来发现，数据发生了迁移，比如新节点加入，会使旧的缓存节点数据迁移到新结点。</p>\n<p>请求过来发现旧节点已经发生了数据迁移并且数据被迁移到新结点，由于每个节点都有clusterNode信息，通过该信息的ip和端口。此时旧节点就会向客户端发一个MOVED 的重定向请求，表示数据已经迁移到新结点上，你要访问这个新结点的ip和端口就能拿到数据，这样就能重新获取到数据。</p>\n<p>倘若正在发正数据迁移呢？旧节点就会向客户端发送一个ASK 重定向请求，并返回给客户端迁移的目标节点的ip和端口，这样也能获取到数据。</p>\n<h3><a id=\"_2052\"></a>扩容和收缩</h3>\n<p>扩容和收缩也就是节点的上线和下线，可能节点发生故障了，故障自动回复的过程（节点收缩）。</p>\n<p>节点的收缩和扩容时，会重新计算每一个节点负责的槽范围，并发根据虚拟槽算法，将对应的数据更新到对应的节点。</p>\n<p>还有前面的讲的新加入的节点会首先发送Meet消息，详细可以查看前面讲的内容，基本一样的模式。</p>\n<p>以及发生故障后，哨兵老大节点的选举，master节点的重新选举，slave怎样晋升为master节点，可以查看前面哨兵模式选举过程。</p>\n<h3><a id=\"_2062\"></a>优点</h3>\n<p>集群模式时一个无中心的架构模式，将数据进行分片，分不到对应的槽中，每个节点存储不同的数据内容，通过路由能够找到对应的节点负责存储的槽，能够实现高效率的查询。</p>\n<p>并且集群模式增加了横向和纵向的扩展能力，实现节点加入和收缩，集群模式时哨兵的升级版，哨兵的优点集群都有。</p>\n<h3><a id=\"_2068\"></a>缺点</h3>\n<p>缓存的最大问题就是带来数据一致性问题，在平衡数据一致性的问题时，兼顾性能与业务要求，大多数都是以最终一致性的方案进行解决，而不是强一致性。</p>\n<p>并且集群模式带来节点数量的剧增，一个集群模式最少要6台机，因为要满足半数原则的选举方式，所以也带来了架构的复杂性。</p>\n<p>slave只充当冷备，并不能缓解master的读的压力。</p>\n<h3><a id=\"_2076\"></a>实操搭建</h3>\n<p>集群模式的部署比较简单，只要在redis.conf加入下面的配置信息即可：</p>\n<pre><code>port 6379# 本示例6个节点端口分别为6379、6380、6381、6382、6383、6384\ndaemonize yes # r后台运行 \npidfile /var/run/redis_6379.pid # 分别对应6379、6380、6381、6382、6383、6384\ncluster-enabled yes # 开启集群模式 \nmasterauth 123456# 如果设置了密码，需要指定master密码\ncluster-config-file nodes_6379.conf # 集群的配置文件，同样对应6379、6380、6381、6382、6383、6384六个节点\ncluster-node-timeout 10000 # 请求超时时间\n</code></pre>\n<p>同时开启这六个实例，通过下面的命令将这六个实例以集群的方式运行</p>\n<pre><code>./redis-cli --cluster create --cluster-replicas 1 127.0.0.1:6379 127.0.0.1:6380 127.0.0.1:6381  127.0.0.1:6382  127.0.0.1:6383  127.0.0.1:6384  -a 123456\n</code></pre>\n<p>这样就实现了集群的搭建，好了这一期就完成了，看了一下字数一共1.7W字，原创不易，看完点个在看和分享，不要白嫖我，传承中华民族的良好美德。</p>\n<h1><a id=\"_2096\"></a>应用</h1>\n<h2><a id=\"1_2099\"></a>1.订阅与发布简介</h2>\n<p>Redis发布与发布功能（<code>Pub/Sub</code>）是基于事件座位基本的通信机制，是目前应用比较普遍的通信模型，它的目的主要是<strong>解除消息的发布者与订阅者之间的耦合关系</strong>。</p>\n<p>Redis作为消息发布和订阅之间的服务器，起到桥梁的作用，在Redis里面有一个<code>channel</code>的概念，也就是频道，发布者通过指定发布到某个频道，然后只要有订阅者订阅了该频道，该消息就会发送给订阅者，原理图如下所示：<br/> <img alt=\"\" src=\"image\\20200804214323283.png\"/><br/> Redis同时也可以使用list类型实现消息队列（消息队列的实现以及应用场景会在下一篇文章继续讲解）。</p>\n<p>Redis的发布与订阅的功能应用还是比较广泛的，它的应用场景有很多。比如：最常见的就是实现实时聊天的功能，还是有就是博客的粉丝文章的推送，当博主推送原创文章的时候，就会将文章实时推送给博主的粉丝。</p>\n<p>简介完Redis的发布于订阅功能，下面就要来实操一下，包括linux命令的实操和java代码的实现。</p>\n<h2><a id=\"_2112\"></a>命令实操</h2>\n<p>这里就假设各位读者都已经安装好自己的虚拟机环境和Redis了，若是没有安装好的，可以参考这一篇博文：https://www.cnblogs.com/<br/> zuidongfeng/p/8032505.html</p>\n<p>我这里是已经安装好了Redis了，直接启动我们的Redis，我已经设置好了开机启动，上面的那篇博文有讲解怎么设置开机启动。</p>\n<p><img alt=\"\" src=\"image\\20200804215725794.png\"/></p>\n<h3><a id=\"_2122\"></a>发布消息</h3>\n<p>Redis中发布消息的命令是publish，具体使用如下所示：</p>\n<p><img alt=\"\" src=\"image\\20200804215924682.png\"/><br/> PUBLISH test “haha”：<code>test</code>表示频道的名称，<code>haha</code>表示发布的内容，这样就完成了一个一个消息的发布，后面的返回<code>（integer）0</code>表示0人订阅。</p>\n<h3><a id=\"_2129\"></a>订阅频道</h3>\n<p>于此同时再启动一个窗口，这个窗口作为订阅者，订阅者的命令<code>subscribe</code>，使用SUBSCRIBE test就表示订阅了test这个频道<br/> <img alt=\"\" src=\"image\\20200804220959106.png\"/><br/> 订阅后返回的结果中由三条信息，<strong>第一个表示类型、第二个表示订阅的频道，第三个表示订阅的数量</strong>。接着在第一个窗口进行发布消息：</p>\n<p><img alt=\"\" src=\"image\\20200804221522352.png\"/><br/> 可以看到发布者发布的消息，订阅者都会实时的接收到，并发订阅者收到的信息中也会出现三条信息，分别表示：<strong>返回值的类型、频道名称、消息内容</strong>。</p>\n<h3><a id=\"_2138\"></a>取消订阅</h3>\n<p>若是想取消之前的订阅可以使用unsubscribe命令，格式为：</p>\n<pre><code>unsubscribe  频道名称\n// 取消之前订阅的test频道\nunsubscribe  test\n</code></pre>\n<p>输入命令后，返回以下结果：</p>\n<pre><code>[root@pinyoyougou-docker src]# ./redis-cli \n127.0.0.1:6379&gt; UNSUBSCRIBE test\n1) \"unsubscribe\"\n2) \"test\"\n3) (integer) 0\n</code></pre>\n<p>它分别表示：<strong>返回值的类型、频道的名称、该频道订阅的数量</strong>。</p>\n<h3><a id=\"_2158\"></a>按模式订阅</h3>\n<p>除了直接以特定的名城进行订阅，还可以按照模式进行订阅，模式的方式进行订阅可以一次订阅多个频道，按照模式进行订阅的命令为<code>psubscribe</code>，具体格式如下：</p>\n<pre><code>psubscribe  模式\n// 表示订阅名称以ldc开头的频道\npsubscribe  ldc*\n</code></pre>\n<p>输入上面的命令后，返回如下结果：</p>\n<pre><code>127.0.0.1:6379&gt; PSUBSCRIBE ldc*\nReading messages... (press Ctrl-C to quit)\n1) \"psubscribe\"\n2) \"ldc*\"\n3) (integer) 1\n</code></pre>\n<p>这个也是非常简单，分别表示：<strong>返回的类型（表示按模式订阅类型）、订阅的模式、订阅数</strong>。</p>\n<h3><a id=\"_2178\"></a>取消按模式订阅</h3>\n<p>假如你想取消之前的按模式订阅，可以使用<code>punsubscribe</code>来取消，具体格式：</p>\n<pre><code>punsubscribe 模式\n// 取消频道名称按照ldc开头的频道\npunsubscribe ldc*\n</code></pre>\n<p>他的返回值，如下所示：</p>\n<pre><code>127.0.0.1:6379&gt; PUNSUBSCRIBE ldc*\n1) \"punsubscribe\"\n2) \"ldc*\"\n3) (integer) 0\n</code></pre>\n<p>这个就不多说了，表示的意思和上面的一样，可以看到上面的命令都是有规律的订阅SUBSCRIBE，取消就是UNSUBSCRIBE，前面加前缀UN，按模式订阅也是。</p>\n<h3><a id=\"_2197\"></a>查看订阅消息</h3>\n<p>（1）你想查看某一个模式下订阅数是大于零的频道，可以使用如下格式的命令进行操作：</p>\n<pre><code>pubsub channels 模式\n// 查看频道名称以ldc模式开头的订阅数大于零的频道\npubsub channels ldc*\n</code></pre>\n<p>（2）假如你想查看某一个频道的订阅数，可以使用如下命令：</p>\n<pre><code>pubsub numsub 频道名称\n</code></pre>\n<p>（3）查看按照模式的订阅数，可以使用如下命令进行操作：</p>\n<pre><code>pubsub numpat\n</code></pre>\n<p>到这里以上的命令操作就基本结束了，下面就来代码实战。</p>\n<h2><a id=\"_2218\"></a>代码实练</h2>\n<p>（1）首先第一步想要操作Redis，再SpringBoot项目中引入jedis的依赖，毕竟jedis是官方推荐使用操作Redis的工具。</p>\n<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;redis.clients&lt;/groupId&gt;\n    &lt;artifactId&gt;jedis&lt;/artifactId&gt;\n    &lt;version&gt;2.9.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p>（2）然后创建发布者<code>Publisher</code>，用于消息的发布，具体代码如下：</p>\n<pre><code>package com.ldc.org.myproject.demo.redis;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\n\n/**\n * 发布者\n * @author liduchang\n *\n */\npublic class Publisher extends Thread{\n\t// 连接池\t\n\tprivate final JedisPool jedisPool;\n\t// 发布频道名称\n\tprivate String name;\n\t\n\tpublic Publisher(JedisPool jedisPool, String name) {\n\t\tsuper();\n\t\tthis.jedisPool = jedisPool;\n\t\tthis.name = name;\n\t}\n\t\n\t@Override\n\tpublic void run() {\n\t\t// 获取要发布的消息\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\t// 获取连接\n\t\tJedis resource = jedisPool.getResource();\n\t\twhile (true) {\n\t\t\tString message = null;\n\t\t\ttry {\n\t\t\t\tmessage = reader.readLine();\n\t\t\t\tif (!\"exit\".equals(message)) {\n\t\t\t\t\t// 发布消息\n\t\t\t\t\tresource.publish(name, \"发布者:\"+Thread.currentThread().getName()+\"发布消息：\"+message);\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n}\n</code></pre>\n<p>（3）接着创建订阅类<code>Subscriber</code>，并且继承<code>JedisPubSub</code> 类，重写<code>onMessage、onSubscribe、onUnsubscribe</code>三个方法，这三个方法的调用时机在注释上都有说明，具体的实现代码如下：</p>\n<pre><code>package com.ldc.org.myproject.demo.redis;\n\nimport com.fasterxml.jackson.core.sym.Name;\nimport redis.clients.jedis.JedisPubSub;\n\n/**\n * 订阅者\n * @author liduchang\n */\npublic class Subscriber extends JedisPubSub {\n\t//订阅频道名称\n\tprivate String name;\n\t\n\tpublic Subscriber(String name) {\n\t\tthis.name = name;\n\t}\n\n\t/**\n\t * 订阅者收到消息时会调用\n\t */\n\t@Override\n\tpublic void onMessage(String channel, String message) {\n\t\t// TODO Auto-generated method stub\n\t\tsuper.onMessage(channel, message);\n\t\tSystem.out.println(\"频道：\"+channel+\"  接受的消息为：\"+message);\n\t}\n\n\t/**\n\t * 订阅了频道会被调用\n\t */\n\t@Override\n\tpublic void onSubscribe(String channel, int subscribedChannels) {\n\t\tSystem.out.println(\"订阅了频道:\"+channel+\"  订阅数为：\"+subscribedChannels);\n\t}\n\n\t/**\n\t * 取消订阅频道会被调用\n\t */\n\t@Override\n\tpublic void onUnsubscribe(String channel, int subscribedChannels) {\n\t\tSystem.out.println(\"取消订阅的频道：\"+channel+\"  订阅的频道数量为：\"+subscribedChannels);\n\t}\n}\n</code></pre>\n<p>（4）这次创建的才是真正的订阅者<code>SubThread</code>，上面的Subscriber是指为了测试实订阅的时候或者发布消息，能够有信息输出：</p>\n<pre><code>package com.ldc.org.myproject.demo.redis;\n\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\n\n/**\n * 订阅者线程\n * @author liduchang\n *\n */\npublic class SubThread extends Thread {\n\t\n\tprivate final JedisPool jedisPool;\n\t\n\tprivate final Subscriber subscriber;\n\t\n\tprivate String name;\n\t\n\tpublic SubThread(JedisPool jedisPool,Subscriber subscriber,String name) {\n\t\tsuper();\n\t\tthis.jedisPool = jedisPool;\n\t\tthis.subscriber = subscriber;\n\t\tthis.name = name;\n\t}\n\t\n\t@Override\n\tpublic void run() {\n\t\tJedis jedis = null;\n\t\ttry {\n\t\t\tjedis = jedisPool.getResource();\n\t\t\t// 订阅频道为name\n\t\t\tjedis.subscribe(subscriber, name);\n\t\t} catch (Exception e) {\n\t\t\tSystem.err.println(\"订阅失败\");\n\t\t    e.printStackTrace();\n\t\t} finally {\n\t\t\tif (jedis!=null) {\n\t\t\t\t // jedis.close();\n\t\t\t\t //归还连接到redis池中\n\t\t\t\tjedisPool.returnResource(jedis);\n\t\t\t}\n\t\t}\n\t}\n}\n</code></pre>\n<p>（5）后面就是测试了，分别测试发布与订阅的测试，发布者为<code>TestPublisher</code>，订阅者为<code>TestSubscriber</code>：</p>\n<pre><code>package com.ldc.org.myproject.demo.redis;\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\nimport redis.clients.jedis.JedisPool;\n\npublic class TestPublisher {\n\t\n\tpublic static void main(String[] args) throws InterruptedException {\n\t\tJedisPool jedisPool = new JedisPool(\"192.168.163.155\");\n\t\t// 向ldc频道发布消息\n\t\tPublisher publisher = new Publisher(jedisPool, \"ldc\");\n\t\tpublisher.start();\n\t}\n}\n</code></pre>\n<p>订阅者</p>\n<pre><code>package com.ldc.org.myproject.demo.redis;\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\nimport redis.clients.jedis.JedisPool;\n\npublic class TestSubscriber1 {\n\t\n\tpublic static void main(String[] args) throws InterruptedException {\n\t\tJedisPool jedisPool = new JedisPool(\"192.168.163.155\",6379);\n\t\tSubscriber subscriber = new Subscriber(\"黎杜\");\n\t\t// 订阅ldc频道\n\t\tSubThread thread= new SubThread(jedisPool, subscriber, \"ldc\");\n\t\tthread.start();\n\t\tThread.sleep(600000);\n\t\t// 取消订阅\n\t\tsubscriber.unsubscribe(\"ldc\");\n\t}\n}\n</code></pre>\n<p>这里为了测试方便就直接创建线程的方式，更好的话可以使用线程池的方式通过线程池的<code>submit</code>方法来执行线程，若是不用了可以使用<code>shutdown</code>方式关闭。</p>\n<p>好了这一期的Redis的实现订阅与发布的讲解就说完了，我们下一期在讲解Redis的集群的知识，下期再见。</p>\n<h2><a id=\"2Redis_2425\"></a>2.Redis实现的分布式锁</h2>\n<p>之前讲了一片Redis事务的文章，很多读者Redis事务有啥用，主要是因为Redis的事务并没有Mysql的事务那么强大，所以一般的公司一般确实是用不到。</p>\n<p>这里就来说一说Redis事务的一个实际用途，它可以用来实现一个简单的秒杀系统的库存扣减，下面我们就来进行代码的实现。</p>\n<p>（1）首先使用线程池初始化5000个客户端。</p>\n<pre><code>public static void intitClients() {\n\tExecutorService threadPool= Executors.newCachedThreadPool();\n\tfor (int i = 0; i &lt; 5000; i++) {\n\t\tthreadPool.execute(new Client(i));\n\t}\n\tthreadPool.shutdown();\n\t\n\twhile(true){ \n         if(threadPool.isTerminated()){  \n             break;  \n         }  \n     }  \n}\n</code></pre>\n<p>（2）接着初始化商品的库存数为1000。</p>\n<pre><code>public static void initPrductNum() {\n\t\tJedis jedis = RedisUtil.getInstance().getJedis();\n\t\tjedisUtils.set(\"produce\", \"1000\");// 初始化商品库存数\n\t\tRedisUtil.returnResource(jedis);// 返还数据库连接\n\t}\n}\n</code></pre>\n<p>（3）最后是库存扣减的每条线程的处理逻辑。</p>\n<pre><code>/**\n * 顾客线程\n * \n * @author linbingwen\n *\n */\nclass client implements Runnable {\n\tJedis jedis = null;\n\tString key = \"produce\"; // 商品数量的主键\n\tString name;\n \n\tpublic ClientThread(int num) {\n\t\tname= \"编号=\" + num;\n\t}\n \n\tpublic void run() {\n\t\n\t\twhile (true) {\n\t\t\tjedis = RedisUtil.getInstance().getJedis();\n\t\t\ttry {\n\t\t\t\tjedis.watch(key);\n\t\t\t\tint num= Integer.parseInt(jedis.get(key));// 当前商品个数\n\t\t\t\tif (num&gt; 0) {\n\t\t\t\t\tTransaction ts= jedis.multi(); // 开始事务\n\t\t\t\t\tts.set(key, String.valueOf(num - 1)); // 库存扣减\n\t\t\t\t\tList&lt;Object&gt; result = ts.exec(); // 执行事务\n\t\t\t\t\tif (result == null || result.isEmpty()) {\n\t\t\t\t\t\tSystem.out.println(\"抱歉，您抢购失败，请再次重试\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tSystem.out.println(\"恭喜您，抢购成功\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"抱歉，商品已经卖完\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t} finally {\n\t\t\t\tjedis.unwatch(); // 解除被监视的key\n\t\t\t\tRedisUtil.returnResource(jedis);\n\t\t\t}\n\t\t}\n\t}\n}\n</code></pre>\n<p>在代码的实现中有一个重要的点就是<strong>商品的数据量被watch了</strong>，当前的客户端只要发现数量被改变就会抢购失败，然后不断的自旋进行抢购。</p>\n<p>这个是基于Redis事务实现的简单的秒杀系统，Redis事务中的<code>watch</code>命令有点类似乐观锁的机制，只要发现商品数量被修改，就执行失败。</p>\n<p>Redis实现分布式锁的第二种方式，可以使用<code>setnx、getset、expire、del</code>这四个命令来实现。</p>\n<ol><li><code>setnx</code>：命令表示如果key不存在，就会执行set命令，若是key已经存在，不会执行任何操作。</li><li><code>getset</code>：将key设置为给定的value值，并返回原来的旧value值，若是key不存在就会返回返回nil 。</li><li><code>expire</code>：设置key生存时间，当当前时间超出了给定的时间，就会自动删除key。</li><li><code>del</code>：删除key，它可以删除多个key，语法如下：<code>DEL key [key …]</code>，若是key不存在直接忽略。</li></ol>\n<p>下面通过一个代码案例是实现以下这个命令的操作方式：</p>\n<pre><code>public void redis(Produce produce) {\n        long timeout= 10000L; // 超时时间\n        Long result= RedisUtil.setnx(produce.getId(), String.valueOf(System.currentTimeMillis() + timeout));\n        if (result!= null &amp;&amp; result.intValue() == 1) { // 返回1表示成功获取到锁\n\t        RedisUtil.expire(produce.getId(), 10);//有效期为5秒，防止死锁\n\t        //执行业务操作\n\t        ......\n\t        //执行完业务后，释放锁\n\t        RedisUtil.del(produce.getId());\n        } else {\n           System.println.out(\"没有获取到锁\")\n        }\n    }\n</code></pre>\n<p>在线程A通过<code>setnx</code>方法尝试去获取到produce对象的锁，若是获取成功旧会返回1，获取不成功，说明当前对象的锁已经被其它线程锁持有。</p>\n<p>获取锁成功后并设置key的生存时间，能够有效的防止出现死锁，最后就是通过<code>del</code>来实现删除key，这样其它的线程就也可以获取到这个对象的锁。</p>\n<p>执行的逻辑很简单，但是简单的同时也会出现问题，比如你在执行完setnx成功后设置生存时间不生效，此时服务器宕机，那么key就会一直存在Redis中。</p>\n<p>当然解决的办法，你可以在服务器<code>destroy</code>函数里面再次执行：</p>\n<pre><code>RedisUtil.del(produce.getId());\n</code></pre>\n<p>或者通过<strong>定时任务检查是否有设置生存时间</strong>，没有的话都会统一进行设置生存时间。</p>\n<p>还有比较好的解决方案就是，在上面的执行逻辑里面，若是没有获取到锁再次进行key的生存时间：</p>\n<pre><code>public void redis(Produce produce) {\n        long timeout= 10000L; // 超时时间\n        Long result= RedisUtil.setnx(produce.getId(), String.valueOf(System.currentTimeMillis() + timeout));\n        if (result!= null &amp;&amp; result.intValue() == 1) { // 返回1表示成功获取到锁\n\t        RedisUtil.expire(produce.getId(), 10);//有效期为10秒，防止死锁\n\t        //执行业务操作\n\t        ......\n\t        //执行完业务后，释放锁\n\t        RedisUtil.del(produce.getId());\n        } else {\n            String value= RedisUtil.get(produce.getId());\n            // 存在该key，并且已经超时\n            if (value!= null &amp;&amp; System.currentTimeMillis() &gt; Long.parseLong(value)) {\n                String result = RedisUtil.getSet(produce.getId(), String.valueOf(System.currentTimeMillis() + timeout)); \n                if (result == null || (result != null &amp;&amp; StringUtils.equals(value, result))) {\n                     RedisUtil.expire(produce.getId(), 10);//有效期为10秒，防止死锁\n\t\t\t        //执行业务操作\n\t\t\t        ......\n\t\t\t        //执行完业务后，释放锁\n\t\t\t        RedisUtil.del(produce.getId());\n                } else {\n                    System.println(\"没有获取到锁\")\n                }\n            } else {\n                System.println(\"没有获取到锁\")\n            }\n        }\n    }\n</code></pre>\n<p>这里对上面的代码进行了改进，在获取setnx失败的时候，再次重新判断该key的锁时间是否失效或者不存在，并重新设置生存的时间，避免出现死锁的情况。</p>\n<p>第三种Redis实现分布式锁，可以使用<code>Redisson</code>来实现，它的实现简单，已经帮我们封装好了，屏蔽了底层复杂的实现逻辑。</p>\n<p>先来一个Redisson的原理图，后面回对这个原理图进行详细的介绍：<br/> <img alt=\"图片来源于网络\" src=\"image\\20200712164801569.png\"/></p>\n<p>我们在实际的项目中要使用它，只需要引入它的依赖，然后执行下面的代码：</p>\n<pre><code>RLock lock = redisson.getLock(\"lockName\");\nlock.locl();\nlock.unlock();\n</code></pre>\n<p>并且它还支持<strong>Redis单实例、Redis哨兵、redis cluster、redis master-slave</strong>等各种部署架构，都给你完美的实现，不用自己再次拧螺丝。</p>\n<p>但是，crud的同时还是要学习一下它的底层的实现原理，下面我们来了解下一下，对于一个分布式的锁的框架主要的学习分为下面的5个点：</p>\n<ol><li>加锁机制</li><li>解锁机制</li><li>生存时间延长机制</li><li>可重入加锁机制</li><li>锁释放机制</li></ol>\n<p>只要掌握一个框架的这五个大点，基本这个框架的核心思想就已经掌握了，若是要你去实现一个锁机制框架，就会有大体的一个思路。</p>\n<p><code>Redisson</code>中的加锁机制是通过lua脚本进行实现，<code>Redisson</code>首先会通过<strong>hash算法</strong>，选择<code>redis cluster</code>集群中的一个节点，接着会把一个lua脚本发送到Redis中。</p>\n<p>它底层实现的lua脚本如下：</p>\n<pre><code>returncommandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, command,\n\t\"if (redis.call('exists', KEYS[1]) == 0) then \" +\n\t      \"redis.call('hset', KEYS[1], ARGV[2], 1); \" +\n\t      \"redis.call('pexpire', KEYS[1], ARGV[1]); \" +\n\t      \"return nil; \" +\n\t  \"end; \" +\n\t  \"if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then \" +\n\t      \"redis.call('hincrby', KEYS[1], ARGV[2], 1); \" +\n\t      \"redis.call('pexpire', KEYS[1], ARGV[1]); \" +\n\t      \"return nil; \" +\n\t  \"end; \" +\n\t  \"return redis.call('pttl', KEYS[1]);\",\n\t    Collections.&lt;Object&gt;singletonList(getName()), internalLockLeaseTime, getLockName(threadId));\n</code></pre>\n<p><strong>redis.call()的第一个参数表示要执行的命令，KEYS[1]表示要加锁的key值，ARGV[1]表示key的生存时间，默认时30秒，ARGV[2]表示加锁的客户端的ID。</strong></p>\n<p>比如第一行中<code>redis.call('exists', KEYS[1]) == 0)</code> 表示执行exists命令判断Redis中是否含有KEYS[1]，这个还是比较好理解的。</p>\n<p>lua脚本中封装了要执行的业务逻辑代码，它能够保证执行业务代码的原子性，它通过<code>hset lockName</code>命令完成加锁。</p>\n<p>若是第一个客户端已经通过<code>hset</code>命令成功加锁，当第二个客户端继续执行lua脚本时，会发现锁已经被占用，就会通过<code>pttl myLock</code>返回第一个客户端的持锁生存时间。</p>\n<p>若是还有生存时间，表示第一个客户端会继续持有锁，那么第二个客户端就会不停的自旋尝试取获取锁。</p>\n<p>假如第一个客户端持有锁的时间快到期了，想继续持有锁，可以给它启动一个<code>watch dog</code>看门狗，他是一个后台线程会每隔10秒检查一次，可以不断的延长持有锁的时间。</p>\n<p><code>Redisson</code>中可重入锁的实现是通过<code>incrby lockName</code>来实现，<strong>重入一个计数就会+1，释放一次锁计数就会-1</strong>。</p>\n<p>最后，使用完锁后执行<code>del lockName</code>就可以直接<strong>释放锁</strong>，这样其它的客户端就可以争抢到该锁了。</p>\n<p>这就是分布式锁的开源Redisson框架底层锁机制的实现原理，我们可以在生产中实现该框架实现分布式锁的高效使用。</p>\n<p>下面通过一个多窗口抢票的例子代码来实现：</p>\n<pre><code>public class SellTicket implements Runnable {\n    private int ticketNum = 1000;\n    RLock lock = getLock();\n    // 获取锁 \n    private RLock getLock() {\n        Config config = new Config();\n        config.useSingleServer().setAddress(\"redis://localhost:6379\");\n        Redisson redisson = (Redisson) Redisson.create(config);\n        RLock lock = redisson.getLock(\"keyName\");\n        return lock;\n    }\n \n    @Override\n    public void run() {\n        while (ticketNum&gt;0) {\n            // 获取锁,并设置超时时间\n            lock.lock(1, TimeUnit.MINUTES);\n            try {\n                if (ticketNum&gt; 0) {\n                    System.out.println(Thread.currentThread().getName() + \"出售第 \" + ticketNum-- + \" 张票\");\n                }\n            } finally {\n                lock.unlock(); // 释放锁\n            }\n        }\n    }\n}\n</code></pre>\n<p>测试的代码如下：</p>\n<pre><code>public class Test {\n    public static void main(String[] args) {\n        SellTicket sellTick= new SellTicket();\n        // 开启5五条线程，模拟5个窗口\n        for (int i=1; i&lt;=5; i++) {\n            new Thread(sellTick, \"窗口\" + i).start();\n        }\n    }\n}\n</code></pre>\n<p>是不是感觉很简单，因为多线程竞争共享资源的复杂的过程它在底层都帮你实现了，屏蔽了这些复杂的过程，而你也就成为了优秀的API调用者。</p>\n<p>上面就是Redis三种方式实现分布式锁的方式，基于Redis的实现方式基本都会选择Redisson的方式进行实现，因为简单命令，不用自己拧螺丝，开箱即用。</p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}