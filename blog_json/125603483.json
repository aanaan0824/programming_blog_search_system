{"blogid": "125603483", "writerAge": "码龄143天", "writerBlogNum": "45", "writerCollect": "429", "writerComment": "924", "writerFan": "1754", "writerGrade": "5级", "writerIntegral": "2220", "writerName": "兔7", "writerProfileAdress": "writer_image\\profile_125603483.jpg", "writerRankTotal": "8995", "writerRankWeekly": "1616", "writerThumb": "641", "writerVisitNum": "13726", "blog_read_count": "1130", "blog_time": "已于 2022-07-19 14:48:15 修改", "blog_title": "【C++】继承（C++重中之重）（学习与复习兼顾）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p style=\"text-align:center;\"><img alt=\"\" height=\"90\" src=\"https://img-blog.csdnimg.cn/b6f20f614157431ba83ad9378ab10a32.gif\" width=\"714\"/></p>\n<p><img alt=\"\" height=\"747\" src=\"image\\af03afb19d1a401cb431bb52b1b046d1.png\" width=\"1200\"/></p>\n<blockquote>\n<p><strong>🏠 大家好，我是 <span style=\"color:#ff9900;\">兔7</span> ，一位努力学习C++的博主~💬</strong></p>\n<p><strong>🍑 如果文章知识点有错误的地方，请指正！和大家一起学习，一起进步👀</strong></p>\n<p><strong>🚀 如有不懂，可以随时向我提问，我会全力讲解~</strong></p>\n<p><strong>🔥 如果感觉博主的文章还不错的话，<u>希望大家关注、点赞、收藏三连支持一下博主哦</u>~！</strong></p>\n<p><strong>🔥 你们的支持是我创作的动力！</strong></p>\n<p id=\"2.2%E5%9B%BE%E8%A7%A3\"><strong>🧸 <span style=\"color:#fe2c24;\">我相信现在的努力的艰辛，都是为以后的美好最好的见证！</span></strong></p>\n<p><span style=\"color:#fe2c24;\"><strong>🧸 人的心态决定姿态！</strong></span></p>\n<p><strong>🚀 本文章CSDN首发！</strong></p>\n</blockquote>\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E5%89%8D%E8%A8%80-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%89%8D%E8%A8%80\">前言</a></p>\n<p id=\"0.%C2%A0%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7-toc\" style=\"margin-left:0px;\"><a href=\"#0.%C2%A0%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7\">0. 面向对象的三大特性</a></p>\n<p id=\"1.%20%E7%BB%A7%E6%89%BF%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%9A%E4%B9%89-toc\" style=\"margin-left:0px;\"><a href=\"#1.%20%E7%BB%A7%E6%89%BF%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%9A%E4%B9%89\">1. 继承的概念及定义</a></p>\n<p id=\"1.1%20%E7%BB%A7%E6%89%BF%E7%9A%84%E6%A6%82%E5%BF%B5-toc\" style=\"margin-left:40px;\"><a href=\"#1.1%20%E7%BB%A7%E6%89%BF%E7%9A%84%E6%A6%82%E5%BF%B5\">1.1 继承的概念</a></p>\n<p id=\"1.2%20%E7%BB%A7%E6%89%BF%E5%AE%9A%E4%B9%89-toc\" style=\"margin-left:40px;\"><a href=\"#1.2%20%E7%BB%A7%E6%89%BF%E5%AE%9A%E4%B9%89\">1.2 继承定义</a></p>\n<p id=\"1.2.1%E5%AE%9A%E4%B9%89%E6%A0%BC%E5%BC%8F-toc\" style=\"margin-left:80px;\"><a href=\"#1.2.1%E5%AE%9A%E4%B9%89%E6%A0%BC%E5%BC%8F\">1.2.1定义格式</a></p>\n<p id=\"1.2.2%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E5%92%8C%E8%AE%BF%E9%97%AE%E9%99%90%E5%AE%9A%E7%AC%A6-toc\" style=\"margin-left:80px;\"><a href=\"#1.2.2%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E5%92%8C%E8%AE%BF%E9%97%AE%E9%99%90%E5%AE%9A%E7%AC%A6\">1.2.2继承关系和访问限定符</a></p>\n<p id=\"1.2.3%E7%BB%A7%E6%89%BF%E5%9F%BA%E7%B1%BB%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8F%98%E5%8C%96-toc\" style=\"margin-left:80px;\"><a href=\"#1.2.3%E7%BB%A7%E6%89%BF%E5%9F%BA%E7%B1%BB%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8F%98%E5%8C%96\">1.2.3继承基类成员访问方式的变化</a></p>\n<p id=\"%E6%80%BB%E7%BB%93%EF%BC%9A-toc\" style=\"margin-left:80px;\"><a href=\"#%E6%80%BB%E7%BB%93%EF%BC%9A\">总结：</a></p>\n<p id=\"%C2%A02.%E5%9F%BA%E7%B1%BB%E5%92%8C%E6%B4%BE%E7%94%9F%E7%B1%BB%E5%AF%B9%E8%B1%A1%E8%B5%8B%E5%80%BC%E8%BD%AC%E6%8D%A2-toc\" style=\"margin-left:0px;\"><a href=\"#%C2%A02.%E5%9F%BA%E7%B1%BB%E5%92%8C%E6%B4%BE%E7%94%9F%E7%B1%BB%E5%AF%B9%E8%B1%A1%E8%B5%8B%E5%80%BC%E8%BD%AC%E6%8D%A2\"> 2.基类和派生类对象赋值转换</a></p>\n<p id=\"%E2%80%8B%E7%BC%96%E8%BE%913.%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F-toc\" style=\"margin-left:0px;\"><a href=\"#%E2%80%8B%E7%BC%96%E8%BE%913.%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F\">​编辑3.继承中的作用域</a></p>\n<p id=\"4.%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:0px;\"><a href=\"#4.%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0\">4.派生类的默认成员函数</a></p>\n<p id=\"4.1%20%E6%98%BE%E7%A4%BA%E8%B0%83%E7%94%A8-toc\" style=\"margin-left:40px;\"><a href=\"#4.1%20%E6%98%BE%E7%A4%BA%E8%B0%83%E7%94%A8\">4.1 显示调用</a></p>\n<p id=\"%C2%A04.2%C2%A0%E4%B8%8D%E9%9C%80%E8%A6%81%E6%98%BE%E7%A4%BA%E8%B0%83%E7%94%A8-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A04.2%C2%A0%E4%B8%8D%E9%9C%80%E8%A6%81%E6%98%BE%E7%A4%BA%E8%B0%83%E7%94%A8\"> 4.2 不需要显示调用</a></p>\n<p id=\"%E6%80%BB%E7%BB%93%EF%BC%9A-toc\" style=\"margin-left:40px;\"><a href=\"#%E6%80%BB%E7%BB%93%EF%BC%9A\">总结：</a></p>\n<p id=\"%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A-toc\" style=\"margin-left:80px;\"><a href=\"#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A\">面试题：</a></p>\n<p id=\"5.%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%8F%8B%E5%85%83-toc\" style=\"margin-left:0px;\"><a href=\"#5.%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%8F%8B%E5%85%83\">5.继承与友元</a></p>\n<p id=\"6.%20%E7%BB%A7%E6%89%BF%E4%B8%8E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98-toc\" style=\"margin-left:0px;\"><a href=\"#6.%20%E7%BB%A7%E6%89%BF%E4%B8%8E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98\">6. 继承与静态成员</a></p>\n<p id=\"7.%20%E5%A4%8D%E6%9D%82%E7%9A%84%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF%E5%8F%8A%E8%8F%B1%E5%BD%A2%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF-toc\" style=\"margin-left:0px;\"><a href=\"#7.%20%E5%A4%8D%E6%9D%82%E7%9A%84%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF%E5%8F%8A%E8%8F%B1%E5%BD%A2%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF\">7. 复杂的菱形继承及菱形虚拟继承</a></p>\n<p id=\"7.1%C2%A0%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF%E9%97%AE%E9%A2%98-toc\" style=\"margin-left:40px;\"><a href=\"#7.1%C2%A0%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF%E9%97%AE%E9%A2%98\">7.1 菱形继承问题</a></p>\n<p id=\"7.2%20%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF-toc\" style=\"margin-left:40px;\"><a href=\"#7.2%20%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF\">7.2 虚拟继承</a></p>\n<p id=\"7.3%C2%A0%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF%E8%A7%A3%E5%86%B3%E6%95%B0%E6%8D%AE%E5%86%97%E4%BD%99%E5%92%8C%E4%BA%8C%E4%B9%89%E6%80%A7%E7%9A%84%E5%8E%9F%E7%90%86-toc\" style=\"margin-left:40px;\"><a href=\"#7.3%C2%A0%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF%E8%A7%A3%E5%86%B3%E6%95%B0%E6%8D%AE%E5%86%97%E4%BD%99%E5%92%8C%E4%BA%8C%E4%B9%89%E6%80%A7%E7%9A%84%E5%8E%9F%E7%90%86\">7.3 虚拟继承解决数据冗余和二义性的原理</a></p>\n<p id=\"%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF%EF%BC%9A-toc\" style=\"margin-left:80px;\"><a href=\"#%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF%EF%BC%9A\">菱形继承：</a></p>\n<p id=\"%E8%8F%B1%E5%BD%A2%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF%EF%BC%9A-toc\" style=\"margin-left:80px;\"><a href=\"#%E8%8F%B1%E5%BD%A2%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF%EF%BC%9A\">菱形虚拟继承：</a></p>\n<p id=\"%E9%97%AE%E9%A2%98%EF%BC%9A-toc\" style=\"margin-left:80px;\"><a href=\"#%E9%97%AE%E9%A2%98%EF%BC%9A\">问题：</a></p>\n<p id=\"8.%E7%BB%A7%E6%89%BF%E7%9A%84%E6%80%BB%E7%BB%93%E5%92%8C%E5%8F%8D%E6%80%9D-toc\" style=\"margin-left:0px;\"><a href=\"#8.%E7%BB%A7%E6%89%BF%E7%9A%84%E6%80%BB%E7%BB%93%E5%92%8C%E5%8F%8D%E6%80%9D\">8.继承的总结和反思</a></p>\n<p id=\"%E7%BB%A7%E6%89%BF%E5%92%8C%E7%BB%84%E5%90%88-toc\" style=\"margin-left:40px;\"><a href=\"#%E7%BB%A7%E6%89%BF%E5%92%8C%E7%BB%84%E5%90%88\">继承和组合</a></p>\n<p id=\"9.%20%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95%E9%A2%98-toc\" style=\"margin-left:0px;\"><a href=\"#9.%20%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95%E9%A2%98\">9. 笔试面试题</a></p>\n<hr id=\"hr-toc\"/>\n<h1><span style=\"color:#faa572;\">前言</span></h1>\n<p>       <strong> <span style=\"background-color:#fbd4d0;\">继承的重要性和C++中类和对象相同，都是非常非常重要，所以大家认真仔细学习~</span></strong></p>\n<p><strong>        此博客为博主以后复习的资料，所以大家放心学习，总结的很全面，每段代码都给大家发了出来，大家如果有疑问可以尝试去调试。</strong></p>\n<p><strong>        <span style=\"color:#79c6cd;\">大家一定要认真看图，图里的文字都是精华，好多的细节都在图中展示、写出来了，所以大家一定要仔细哦~</span></strong></p>\n<p><strong>        感谢大家对我的支持，感谢大家的喜欢， <span style=\"color:#ff9900;\">兔7</span> 祝大家在学习的路上一路顺利，生活的路上顺心顺意~！</strong></p>\n<h1 id=\"0.%C2%A0%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7\"><span style=\"color:#faa572;\"><strong>0. 面向对象的三大特性</strong></span></h1>\n<p><strong><span style=\"color:#79c6cd;\">封装</span>：数据和方法都封装到一起，通过访问限定符更好的管理数据的方法。</strong></p>\n<p><strong><a class=\"link-info\" href=\"https://blog.csdn.net/weixin_69725192/article/details/125332464?spm=1001.2014.3001.5501\" title=\"【C++】类和对象\">【C++】类和对象</a></strong></p>\n<p><strong><span style=\"color:#79c6cd;\">继承</span>：类抽象级别的复用，公共数据和方法提取到父类，更好实现现实世界的关系。</strong></p>\n<p><strong> <a class=\"link-info\" href=\"https://blog.csdn.net/weixin_69725192/article/details/125603483\" title=\"【C++】继承\">【C++】继承</a></strong></p>\n<p><strong><span style=\"color:#79c6cd;\">多态</span>：完成某个行为，当不同的对象去完成时会产生不同的状态，与现实世界更贴切了。</strong></p>\n<p><strong>（我的下一篇文章会是多态，等我写完了我再将链接贴在这里）</strong></p>\n<h1 id=\"1.%20%E7%BB%A7%E6%89%BF%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%9A%E4%B9%89\"><span style=\"color:#faa572;\">1. 继承的概念及定义</span></h1>\n<h2 id=\"1.1%20%E7%BB%A7%E6%89%BF%E7%9A%84%E6%A6%82%E5%BF%B5\"><span style=\"color:#9c8ec1;\">1.1 继承的概念</span></h2>\n<p><strong>        <span style=\"color:#79c6cd;\">继承</span>(inheritance)机制是面向对象程序设计<span style=\"color:#79c6cd;\">使代码可以复用</span>的最重要的手段，它允许程序员在<span style=\"color:#79c6cd;\">保持原有类特性的基础上进行扩展</span>，增加功能，这样产生新的类，称派生类（或子类）。继承<span style=\"color:#79c6cd;\">呈现了面向对象程序设计的层次结构</span>， 体现了由简单到复杂的认知过程。以前我们接触的复用都是函数之间的复用，<span style=\"color:#79c6cd;\">继承是类设计层次的复用</span>。</strong></p>\n<pre><code class=\"language-cpp\">class Person\n{\npublic:\n\tvoid Print()\n\t{\n\t\tcout &lt;&lt; \"name:\" &lt;&lt; _name &lt;&lt; endl;\n\t\tcout &lt;&lt; \"age:\" &lt;&lt; _age &lt;&lt; endl;\n\t}\nprotected:\n\tstring _name = \"兔7\"; // 姓名\n\tint _age = 18; // 年龄\n};\nclass Student : public Person\n{\nprotected:\n\tint _stuid; // 学号\n};\nclass Teacher : public Person\n{\nprotected:\n\tint _jobid; // 工号\n};\nint main()\n{\n\tStudent s;\n\tTeacher t;\n\ts.Print();\n\tt.Print();\n\treturn 0;\n}</code></pre>\n<p><img alt=\"\" height=\"683\" src=\"image\\cc7e7719804b493d8250c2ac13893503.png\" width=\"660\"/></p>\n<h2 id=\"1.2%20%E7%BB%A7%E6%89%BF%E5%AE%9A%E4%B9%89\"><span style=\"color:#9c8ec1;\">1.2 继承定义</span></h2>\n<h3 id=\"1.2.1%E5%AE%9A%E4%B9%89%E6%A0%BC%E5%BC%8F\"><span style=\"color:#98c091;\">1.2.1定义格式</span></h3>\n<p>        <strong>下面我们看到Person是基类，也称作父类。Student是派生类，也称作子类。</strong></p>\n<p><img alt=\"\" height=\"444\" src=\"image\\2743b443d3d54768b1e43d8a8983916b.png\" width=\"699\"/></p>\n<h3 id=\"1.2.2%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E5%92%8C%E8%AE%BF%E9%97%AE%E9%99%90%E5%AE%9A%E7%AC%A6\"><span style=\"color:#98c091;\">1.2.2继承关系和访问限定符</span></h3>\n<p><img alt=\"\" height=\"303\" src=\"image\\012b4ffee43f4ab0b81873881942b668.png\" width=\"1010\"/></p>\n<h3 id=\"1.2.3%E7%BB%A7%E6%89%BF%E5%9F%BA%E7%B1%BB%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8F%98%E5%8C%96\"><span style=\"color:#98c091;\">1.2.3继承基类成员访问方式的变化</span></h3>\n<table align=\"center\" border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:660px;\"><thead><tr><th style=\"width:153px;\">类成员/继承方式</th><th style=\"width:163px;\">public继承</th><th style=\"width:172px;\">protected继承</th><th style=\"width:168px;\">private继承</th></tr></thead><tbody><tr><td style=\"width:153px;\"><strong>基类的public成员</strong></td><td style=\"width:163px;\">派生类的public成员</td><td style=\"width:172px;\">派生类的protected成员</td><td style=\"width:168px;\">派生类的private成员</td></tr><tr><td style=\"width:153px;\"><strong>基类的protected成员</strong></td><td style=\"width:163px;\">派生类的protected成员</td><td style=\"width:172px;\">派生类的protected成员</td><td style=\"width:168px;\">派生类的private成员</td></tr><tr><td style=\"width:153px;\"><strong>基类的private成员</strong></td><td style=\"width:163px;\">在派生类中不可见</td><td style=\"width:172px;\">在派生类中不可见</td><td style=\"width:168px;\">在派生类中不可见</td></tr></tbody></table>\n<h3 id=\"%E6%80%BB%E7%BB%93%EF%BC%9A\"><span style=\"color:#fe2c24;\"><strong>总结：</strong></span></h3>\n<blockquote>\n<ol><li><strong>基类private成员在派生类中无论以什么方式继承都是不可见的。这里的<span style=\"color:#79c6cd;\">不可见是指基类的私有成员还是被继承到了派生类对象中，但是语法上限制派生类对象不管在类里面还是类外面都不能去访问它。</span> </strong></li><li><strong>基类private成员在派生类中是不能被访问，如果基类成员不想在类外直接被访问，但需要在派生类中能访问，就定义为protected。<span style=\"color:#79c6cd;\">可以看出保护成员限定符是因继承才出现的。</span> </strong></li><li><strong>实际上面的表格我们进行一下总结会发现，基类的私有成员在子类都是不可见。基类的其他成员在子类的访问方式 == Min(成员在基类的访问限定符，继承方式)，public &gt; protected &gt; private。</strong></li><li><strong>使用关键字class时默认的继承方式是private，使用struct时默认的继承方式是public，<span style=\"color:#79c6cd;\">不过最好显示的写出继承方式。</span></strong></li><li><strong><span style=\"color:#79c6cd;\">在实际运用中一般使用都是public继承，几乎很少使用protetced/private继承</span>，也不提倡使用protetced/private继承，因为protetced/private继承下来的成员都只能在派生类的类里面使用，实际中扩展维护性不强。</strong></li></ol>\n</blockquote>\n<pre><code class=\"language-cpp\">class Person\n{\npublic:\n\tvoid Print()\n\t{\n\t\tcout &lt;&lt; _name &lt;&lt; endl;\n\t}\nprotected:\n\tstring _name; // 姓名\nprivate:\n\tint _age = 1; // 年龄\n};\n\n// class Student : private Person\n// class Student : protected Person\nclass Student : public Person\n{\nprotected:\n\tint _stunum; // 学号\n};\n\nint main()\n{\n\tStudent s;\n\ts.Print();\n\treturn 0;\n}</code></pre>\n<p><img alt=\"\" height=\"616\" src=\"image\\babbeb30ff3e4720bf789506bcbf7f2a.png\" width=\"555\"/></p>\n<h1 id=\"%C2%A02.%E5%9F%BA%E7%B1%BB%E5%92%8C%E6%B4%BE%E7%94%9F%E7%B1%BB%E5%AF%B9%E8%B1%A1%E8%B5%8B%E5%80%BC%E8%BD%AC%E6%8D%A2\"><span style=\"color:#faa572;\"> 2.基类和派生类对象赋值转换</span></h1>\n<blockquote>\n<ol><li><strong><span style=\"color:#79c6cd;\">派生类对象</span>可以赋值给 <span style=\"color:#79c6cd;\">基类的对象 / 基类的指针 / 基类的引用</span> 。这里有个形象的说法叫切片或者切割。寓意把派生类中父类那部分切来赋值过去。 </strong></li><li><strong>基类对象不能赋值给派生类对象。</strong></li><li><strong>基类的指针可以通过强制类型转换赋值给派生类的指针。但是只有基类的指针是指向派生类对象时才是安全的。这里基类如果是多态类型，可以使用RTTI(Run-Time Type Information)的dynamic_cast 来进行识别后进行安全转换。（ps：这个我后面会讲到，这里只是提一下~）</strong></li></ol>\n</blockquote>\n<p><img alt=\"\" height=\"703\" src=\"image\\f60b80896d8e44b18bbc1544e91d8569.png\" width=\"1007\"/></p>\n<pre><code class=\"language-cpp\">class Person\n{\nprotected:\n\tstring _name; // 姓名\n\tstring _sex; // 性别\n\tint _age; // 年龄\n};\nclass Student : public Person\n{\npublic:\n\tint _No; // 学号\n};\nint main()\n{\n\tStudent sobj;\n\t// 1.子类对象可以赋值给父类对象/指针/引用\n\tPerson pobj = sobj;\n\tPerson* pp = &amp;sobj;\n\tPerson&amp; rp = sobj;\n\n\t//2.基类对象不能赋值给派生类对象\n\t// sobj = pobj;\n\n\t// 3.基类的指针可以通过强制类型转换赋值给派生类的指针\n\tpp = &amp;sobj;\n\tStudent * ps1 = (Student*)pp; // 这种情况转换时可以的。\n\tps1-&gt;_No = 10;\n\n\tpp = &amp;pobj;\n\tStudent* ps2 = (Student*)pp; // 这种情况转换时虽然可以，但是会存在越界访问的问题\n\tps2-&gt;_No = 10; // 很危险，这里程序直接崩了\n\treturn 0;\n}</code></pre>\n<p>     <strong>   这里强转的时候也是很危险的，下图会展示和说明：</strong></p>\n<h1 id=\"%E2%80%8B%E7%BC%96%E8%BE%913.%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F\"><img alt=\"\" height=\"504\" src=\"image\\d9f79260401f49b880e81507b6c0c309.png\" width=\"959\"/><span style=\"color:#faa572;\">3.继承中的作用域</span></h1>\n<blockquote>\n<ol><li><strong>在继承体系中<span style=\"color:#79c6cd;\">基类</span>和<span style=\"color:#79c6cd;\">派生类</span>都有<span style=\"color:#79c6cd;\">独立的作用域</span>。</strong></li><li><strong>子类和父类中有同名成员，<span style=\"color:#79c6cd;\">子类成员将屏蔽父类对同名成员的直接访问，这种情况叫隐藏，也叫重定义。</span>（在子类成员函数中，可以<span style=\"color:#79c6cd;\">使用基类::基类成员显示访问</span>）</strong></li><li><strong>需要注意的是如果是成员函数的隐藏，只需要函数名相同就构成隐藏。 </strong></li><li><strong>注意在实际中在<span style=\"color:#79c6cd;\">继承体系里</span>面最好<span style=\"color:#79c6cd;\">不要定义同名的成员</span>。</strong></li></ol>\n</blockquote>\n<pre><code class=\"language-cpp\">class Person\n{\nprotected:\n\tstring _name = \"兔7\"; // 姓名\n\tint _num = 777; // 身份证号\n};\nclass Student : public Person\n{\npublic:\n\tvoid Print()\n\t{\n\t\tcout &lt;&lt; \" 姓名:\" &lt;&lt; _name &lt;&lt; endl;\n\t\tcout &lt;&lt; \" 身份证号:\" &lt;&lt; Person::_num &lt;&lt; endl;\n\t\tcout &lt;&lt; \" 学号:\" &lt;&lt; _num &lt;&lt; endl;\n\t}\nprotected:\n\tint _num = 999; // 学号\n};\nint main()\n{\n\tStudent s1;\n\ts1.Print();\n\treturn 0;\n};\n</code></pre>\n<p><img alt=\"\" height=\"559\" src=\"image\\116320ce636d47fdbea18fb523a55a86.png\" width=\"776\"/></p>\n<pre><code class=\"language-cpp\">class A\n{\npublic:\n\tvoid fun()\n\t{\n\t\tcout &lt;&lt; \"func()\" &lt;&lt; endl;\n\t}\n};\nclass B : public A\n{\npublic:\n\tvoid fun(int i)\n\t{\n\t\tA::fun();\n\t\tcout &lt;&lt; \"func(int i)-&gt;\" &lt;&lt; i &lt;&lt; endl;\n\t}\n};\nint main()\n{\n\tB b;\n\tb.fun(10);\n\treturn 0;\n};\n</code></pre>\n<p> <img alt=\"\" height=\"517\" src=\"image\\789ae3c137234db7a4992284b4f8d67b.png\" width=\"622\"/></p>\n<h1 id=\"4.%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0\"><span style=\"color:#faa572;\">4.派生类的默认成员函数</span></h1>\n<p><strong>        6个默认成员函数，<span style=\"color:#79c6cd;\">\"默认\"</span>的意思就是指我们不写，编译器会变我们自动生成一个，那么在派生类中，这几个成员函数是如何生成的呢？</strong></p>\n<blockquote>\n<ol><li><strong><span style=\"color:#79c6cd;\">派生类的构造函数必须调用基类的构造函数初始化基类的那一部分成员。</span>如果基类没有默认的构造函数，则必须在派生类构造函数的初始化列表阶段显示调用。</strong></li><li><strong><span style=\"color:#79c6cd;\">派生类的拷贝构造函数必须调用基类的拷贝构造完成基类的拷贝初始化。</span> </strong></li><li><strong><span style=\"color:#79c6cd;\">派生类的operator=必须要调用基类的operator=完成基类的复制。</span> </strong></li><li><strong><span style=\"color:#79c6cd;\">派生类的析构函数会在被调用完成后自动调用基类的析构函数清理基类成员。</span>因为这样才能保证派生类对象先清理派生类成员再清理基类成员的顺序。 </strong></li><li><strong><span style=\"color:#79c6cd;\">派生类对象初始化先调用基类构造再调派生类构造。</span> </strong></li><li><strong>派生类对象析构清理<span style=\"color:#79c6cd;\">先调用派生类析构再调基类的析构</span>。</strong></li></ol>\n</blockquote>\n<p><img alt=\"\" height=\"350\" src=\"image\\117b935112034222aaae24c98e0fa2a0.png\" width=\"1123\"/></p>\n<p><strong>        接下来我会挑上面的点进行演示并讲解，我先给大家代码，大家先忘后看，如果自己需要感受，等看完再去尝试~</strong></p>\n<pre><code class=\"language-cpp\">class Person\n{\npublic:\n\tPerson(const char* name)\n\t\t: _name(name)\n\t{\n\t\tcout &lt;&lt; \"Person()\" &lt;&lt; endl;\n\t}\n\n\tPerson(const Person&amp; p)\n\t\t: _name(p._name)\n\t{\n\t\tcout &lt;&lt; \"Person(const Person&amp; p)\" &lt;&lt; endl;\n\t}\n\n\tPerson&amp; operator=(const Person&amp; p)\n\t{\n\t\tcout &lt;&lt; \"Person operator=(const Person&amp; p)\" &lt;&lt; endl;\n\t\tif (this != &amp;p)\n\t\t\t_name = p._name;\n\n\t\treturn *this;\n\t}\n\n\t~Person() // -&gt; 因为后面多态的一些原因，任何类析构函数名都会被统一处理成destructor()\n\t{\n\t\tcout &lt;&lt; \"~Person()\" &lt;&lt; endl;\n\t}\nprotected:\n\tstring _name; // 姓名\n};\n\nclass Student : public Person\n{\npublic:\n\tStudent(const char* name, int id)\n\t\t: Person(name)\n\t\t,_id(id)\n\t{\n\t\t// 调用父类构造函数初始化继承的父类部分\n\t\t// 再初始化自己的成员\n\t\tcout &lt;&lt; \"Student()\" &lt;&lt; endl;\n\t}\n\n\tStudent(const Student&amp; s)\n\t\t:Person(s)  // -&gt; s传递给Person&amp; s 是一个切片行为\n\t\t, _id(s._id)\n\t{\n\t\t// 类似构造函数\n\t\tcout &lt;&lt; \"Student(const Student&amp; s)\" &lt;&lt; endl;\n\t}\n\n\t// s1 = s3;\n\tStudent&amp; operator=(const Student&amp; s)\n\t{\n\t\t// 同上\n\t\tif (this != &amp;s)\n\t\t{\n\t\t\t// 小心这里是隐藏\n\t\t\tPerson::operator=(s);\n\t\t\t_id = s._id;\n\t\t}\n\t\tcout &lt;&lt; \"Student&amp; operator=(const Student&amp; s)\" &lt;&lt; endl;\n\t\treturn *this;\n\t}\n\n\t// -&gt; 因为后面多态的一些原因，任何类析构函数名都会被统一处理成destructor()\n\t~Student() // 编译器认为子类的析构函数和父类的析构函数构成隐藏\n\t{\n\t\t//Person::~Person(); // 所以这里想调用，需要指定父类的\n\n\t\t// 清理自己的\n\t\t// delete ptr;\n\n\t\tcout &lt;&lt; \"~Student()\"&lt;&lt;endl;\n\t\t// 为了保证析构时，保持先子再父的后进先出的顺序析构\n\t\t// 子类析构函数完成后，会自动去调用父类的析构函数\n\t}\n\nprivate:\n\tint _id;\n};\n\n\nint main()\n{\n\tStudent s1(\"兔7\", 1);\n\t//Student s2(s1);\n\t//Student s3(\"李四\", 2);\n\t//s1 = s3;\n\n\treturn 0;\n}</code></pre>\n<h2 id=\"4.1%20%E6%98%BE%E7%A4%BA%E8%B0%83%E7%94%A8\"><span style=\"color:#9c8ec1;\">4.1 显示调用</span></h2>\n<p><img alt=\"\" height=\"674\" src=\"image\\c369e6446fda4ff3b7241edb2e135b24.png\" width=\"771\"/></p>\n<h2 id=\"%C2%A04.2%C2%A0%E4%B8%8D%E9%9C%80%E8%A6%81%E6%98%BE%E7%A4%BA%E8%B0%83%E7%94%A8\"> <span style=\"color:#9c8ec1;\">4.2 不需要显示调用</span></h2>\n<p><strong>        这里就要注意了，这里的是很多小伙伴没搞懂的地方，认识起来~！</strong></p>\n<p><img alt=\"\" height=\"409\" src=\"image\\795bc2e6ea7b4860a9f6349639371ec9.png\" width=\"734\"/></p>\n<p><strong>         其实这里我们可以先这么想，正常来说，我们是应该先析构~Student()再析构~Person()吧，<span style=\"color:#79c6cd;\">因为我们先构造的基类后构造的派生类，所以我们析构的时候应该先析构派生类，再析构基类。</span></strong></p>\n<p><img alt=\"\" height=\"297\" src=\"image\\d1ac09ae14334f76be50e0f6bd4a7d7d.png\" width=\"539\"/></p>\n<p><strong>         所以我们就能确定，<span style=\"color:#79c6cd;\">肯定是最上面的~Person() 有问题</span>，这样我们就找到方向了，接下来我们从这个方向去找问题：</strong></p>\n<p><img alt=\"\" height=\"420\" src=\"image\\4cdb3d770c0d476a95c71dc14cf4579c.png\" width=\"740\"/></p>\n<h2><span style=\"color:#9c8ec1;\"><strong>总结：</strong></span></h2>\n<p>    <strong>    下图就是上面的总结，只要大家能看懂下图，就说明你已经清楚了，<span style=\"color:#79c6cd;\">这里我还要再说一下，子类（派生类）析构的时候会自动调用父类（基类）！</span></strong></p>\n<p><img alt=\"\" height=\"339\" src=\"image\\00de92ef24e8493d9079f991c3f874b3.png\" width=\"900\"/></p>\n<h3 id=\"%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A\"><span style=\"color:#fe2c24;\"><strong>面试题：</strong></span></h3>\n<p><strong>        设计出一个类，让这个类不能被继承，你要怎么设计？</strong></p>\n<p><strong>        其实这个问题挺容易想到的，那不就是设成私有么，前面的概念说到过，设成私有后其他类就不能访问到了，那也就继承不了了。</strong></p>\n<p><strong>        <span style=\"color:#79c6cd;\">那么为什么呢？有必要全设成私有么？</span>这又是一个问题。</strong></p>\n<pre><code class=\"language-cpp\">class A\n{\nprivate:\n\tA()\n\t{}\n};\n\nclass B : public A\n{\n};\n\nint main()\n{\n\tB b;\n\n\treturn 0;\n}</code></pre>\n<p><img alt=\"\" height=\"403\" src=\"image\\48a843cc52bf4711a4b0999b5e512a29.png\" width=\"532\"/></p>\n<p><strong>        所以我们<span style=\"color:#79c6cd;\">只要将构造函数设成私有就OK了</span>，没有必要全设成私有，将构造函数设成私有<span style=\"color:#79c6cd;\">严格来说不是不能继承，而是你继承了也没用，因为它生成不了对象，所以也就没有意义了。</span></strong></p>\n<h1 id=\"5.%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%8F%8B%E5%85%83\"><span style=\"color:#faa572;\">5.继承与友元</span></h1>\n<p><strong>         <span style=\"color:#79c6cd;\">友元关系不能继承</span>，也就是说基类友元不能访问子类私有和保护成员。</strong></p>\n<pre><code class=\"language-cpp\">class Student;\nclass Person\n{\npublic:\n friend void Display(const Person&amp; p, const Student&amp; s);\nprotected:\n string _name; // 姓名\n};\nclass Student : public Person\n{\nprotected:\n int _stuNum; // 学号\n};\nvoid Display(const Person&amp; p, const Student&amp; s)\n{\n cout &lt;&lt; p._name &lt;&lt; endl;\n cout &lt;&lt; s._stuNum &lt;&lt; endl;\n}\nvoid main()\n{\n Person p;\n Student s;\n Display(p, s);\n}\n</code></pre>\n<p><img alt=\"\" height=\"621\" src=\"image\\c94e1ed88ed04fc7914d3b09d94888b9.png\" width=\"777\"/></p>\n<h1 id=\"6.%20%E7%BB%A7%E6%89%BF%E4%B8%8E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98\"><span style=\"color:#faa572;\">6. 继承与静态成员</span></h1>\n<p><strong>        <span style=\"color:#79c6cd;\">基类定义了static静态成员，则整个继承体系里面只有一个这样的成员。</span>无论派生出多少个子类，都只有一 个static成员实例 。</strong></p>\n<pre><code class=\"language-cpp\">class Person\n{\npublic:\n\tPerson() { ++_count; }\nprotected:\n\tstring _name; // 姓名\npublic:\n\tstatic int _count; // 统计人的个数。\n};\n\nint Person::_count = 0;\nclass Student : public Person\n{\nprotected:\n\tint _stuNum; // 学号\n};\n\nclass Graduate : public Student\n{\nprotected:\n\tstring _seminarCourse; // 研究科目\n};\n\nint main()\n{\n\tStudent s1;\n\tStudent s2;\n\tStudent s3;\n\tGraduate s4;\n\tcout &lt;&lt; \" 人数 :\" &lt;&lt; Person::_count &lt;&lt; endl;\n\tStudent::_count = 0;\n\tcout &lt;&lt; \" 人数 :\" &lt;&lt; Person::_count &lt;&lt; endl;\n\treturn 0;\n}</code></pre>\n<p><img alt=\"\" height=\"763\" src=\"image\\8a76734ff6f149f39344e4811f2db61b.png\" width=\"612\"/></p>\n<h1 id=\"7.%20%E5%A4%8D%E6%9D%82%E7%9A%84%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF%E5%8F%8A%E8%8F%B1%E5%BD%A2%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF\"><span style=\"color:#faa572;\">7. 复杂的菱形继承及菱形虚拟继承</span></h1>\n<p><strong><span style=\"color:#79c6cd;\">        </span><span style=\"color:#0d0016;\">单继承：一个子类</span><span style=\"color:#79c6cd;\">只有一个直接父类</span><span style=\"color:#0d0016;\">时称这个继承关系为单继承。</span></strong></p>\n<p><img alt=\"\" height=\"253\" src=\"image\\00a6f34ae81c4ca5bab10aa4737f3ac4.png\" width=\"416\"/></p>\n<p><span style=\"color:#79c6cd;\"><strong>     </strong></span><span style=\"color:#0d0016;\"><strong>   多继承：</strong></span><span style=\"color:#79c6cd;\"><strong>一个子类有两个或以上直接父类</strong></span><span style=\"color:#0d0016;\"><strong>时称这个继承关系为多继承。</strong></span></p>\n<p><img alt=\"\" height=\"207\" src=\"image\\e2da95485f474eb69cf9a8b8e6cce050.png\" width=\"480\"/></p>\n<p><strong><span style=\"color:#79c6cd;\">        </span><span style=\"color:#0d0016;\">菱形继承：菱形继承是多继承的一种特殊情况。</span></strong></p>\n<p><img alt=\"\" height=\"334\" src=\"image\\f10b3123822c455888bb86556be80a88.png\" width=\"672\"/></p>\n<h2 id=\"7.1%C2%A0%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF%E9%97%AE%E9%A2%98\"><span style=\"color:#9c8ec1;\">7.1 菱形继承问题</span></h2>\n<p>        <span style=\"color:#79c6cd;\"><strong> </strong></span><span style=\"color:#0d0016;\"><strong>菱形继承的问题：从下面的对象成员模型构造，可以看出菱形继承有</strong></span><span style=\"color:#79c6cd;\"><strong>数据冗余和二义性</strong></span><span style=\"color:#0d0016;\"><strong>的问题。在Assistant的对象中Person成员会有两份。</strong></span></p>\n<p><img alt=\"\" height=\"463\" src=\"image\\a639b26394764291a6ef92ebe803f9e0.png\" width=\"455\"/></p>\n<p><strong>        所以我们在访问的时候就会出现下面这个问题：</strong></p>\n<p><img alt=\"\" height=\"642\" src=\"image\\37a758efd4cc4b528a33ab86d77c6964.png\" width=\"652\"/></p>\n<p><strong>        那么我们其实可以通过下面的方式解决二义性的问题。</strong></p>\n<p><img alt=\"\" height=\"644\" src=\"image\\630aebb6ac0a46b4bd31406f32169dbd.png\" width=\"866\"/></p>\n<p><strong>         但是我们也说了，数据冗余的问题解决不能解决，但是C++不能容忍数据冗余和二义性，所以提出了一个新方案：<span style=\"color:#79c6cd;\">虚拟继承 virtual </span>。</strong></p>\n<p><img alt=\"\" height=\"353\" src=\"image\\f897540a4329400f8c2bb64dec63e84f.png\" width=\"715\"/></p>\n<h2 id=\"7.2%20%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF\"><span style=\"color:#9c8ec1;\">7.2 虚拟继承</span></h2>\n<p>        <strong><span style=\"color:#79c6cd;\">虚拟继承可以解决菱形继承的二义性和数据冗余的问题。</span>如上面的继承关系，在Student和Teacher的继承Person时使用虚拟继承，即可解决问题。<span style=\"color:#79c6cd;\">也就是说是在腰上虚拟继承，不要在其他地方去使用</span><span style=\"color:#fe2c24;\"><span style=\"background-color:#fbd4d0;\">virtual</span></span>关键字<span style=\"color:#79c6cd;\">。</span></strong></p>\n<p><img alt=\"\" height=\"661\" src=\"image\\f9db71cae607438891c79e15618a9ef5.png\" width=\"1050\"/></p>\n<h2 id=\"7.3%C2%A0%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF%E8%A7%A3%E5%86%B3%E6%95%B0%E6%8D%AE%E5%86%97%E4%BD%99%E5%92%8C%E4%BA%8C%E4%B9%89%E6%80%A7%E7%9A%84%E5%8E%9F%E7%90%86\"><span style=\"color:#9c8ec1;\">7.3 虚拟继承解决数据冗余和二义性的原理</span></h2>\n<p><strong>        为了研究虚拟继承原理，我们给出了一个简化的菱形继承继承体系，借助<span style=\"color:#79c6cd;\">内存窗口观察对象成员的模型。</span></strong></p>\n<p> <strong>        我们在看解没解决的问题的时候，<span style=\"background-color:#fbd4d0;\">不要通过监视看，监视窗口看到的不真实，因为监视窗口被编译器处理过。建议使用内存窗口观察。</span></strong></p>\n<pre><code class=\"language-cpp\">class A\n{\npublic:\n\tint _a;\n};\nclass B : public A\n// class B : virtual public A\n{\npublic:\n\tint _b;\n};\nclass C : public A\n// class C : virtual public A\n{\npublic:\n\tint _c;\n};\nclass D : public B, public C\n{\npublic:\n\tint _d;\n};\nint main()\n{\n\tD d;\n\td.B::_a = 1;\n\td.C::_a = 2;\n\td._b = 3;\n\td._c = 4;\n\td._d = 5;\n\treturn 0;\n}</code></pre>\n<h3 id=\"%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF%EF%BC%9A\"><strong><span style=\"color:#fe2c24;\"><span style=\"background-color:#fbd4d0;\">菱形继承：</span></span></strong></h3>\n<p><img alt=\"\" height=\"691\" src=\"image\\7ef69785ec404199978caa52a2795d37.png\" width=\"620\"/></p>\n<h3 id=\"%E8%8F%B1%E5%BD%A2%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF%EF%BC%9A\"><strong><span style=\"color:#fe2c24;\"><span style=\"background-color:#fbd4d0;\">菱形虚拟继承：</span></span></strong></h3>\n<p><img alt=\"\" height=\"704\" src=\"image\\39f80a585ca24dc997fb63dbba21cb09.png\" width=\"576\"/></p>\n<p><strong>        虚继承是为了填补多继承带来的菱形继承的坑。<span style=\"color:#79c6cd;\">虽然继承补了菱形继承的坑，但是也付出了很大的代价。</span></strong></p>\n<p><strong>        1. 对象模型更复杂了，学习理解成本很高。</strong></p>\n<p><strong>        2. 有一定效率影响，要找好几次才能找到 A 。</strong></p>\n<p><strong>        所以实际中，一般情况下，建议不要设计出菱形继承，那么就不会用菱形虚拟继承，就不会出这么多问题了。</strong></p>\n<h3 id=\"%E9%97%AE%E9%A2%98%EF%BC%9A\"><span style=\"color:#fe2c24;\">问题：</span></h3>\n<p><img alt=\"\" height=\"403\" src=\"image\\328c7b2c61cf4171a8c186dd96f7c72d.png\" width=\"779\"/></p>\n<p><strong>        请大家想一想，应用了刚才的知识哦~</strong></p>\n<p><img alt=\"\" height=\"272\" src=\"image\\29fb8d6544ec4f3cb2fa6621df29629a.png\" width=\"544\"/></p>\n<h1 id=\"8.%E7%BB%A7%E6%89%BF%E7%9A%84%E6%80%BB%E7%BB%93%E5%92%8C%E5%8F%8D%E6%80%9D\"><strong><span style=\"color:#faa572;\">8.继承的总结和反思</span></strong></h1>\n<blockquote>\n<ol><li><strong><span style=\"color:#79c6cd;\">很多人说C++语法复杂，其实多继承就是一个体现。有了多继承</span>，就存在菱形继承，有了菱形继承就有菱形虚拟继承，底层实现就很复杂。所以一般不建议设计出多继承，一定不要设计出菱形继承。否则在复杂度及性能上都有问题。</strong></li><li><strong>多继承可以认为是C++的缺陷之一，很多后来的OO语言都没有多继承，如Java。</strong></li><li><strong>但是谁让<span style=\"color:#ff9900;\"> 兔7</span> 喜欢C++呢，冲就完了~！</strong></li></ol>\n</blockquote>\n<h2 id=\"%E7%BB%A7%E6%89%BF%E5%92%8C%E7%BB%84%E5%90%88\"><span style=\"color:#9c8ec1;\">继承和组合</span></h2>\n<blockquote>\n<ul><li><strong>public继承是一种 <span style=\"color:#79c6cd;\">is-a </span>的关系。也就是说每个派生类对象都是一个基类对象。 </strong></li><li><strong>组合是一种 <span style=\"color:#79c6cd;\">has-a </span>的关系。假设B组合了A，每个B对象中都有一个A对象。 </strong></li><li><strong>优先使用对象组合，而不是类继承 。 </strong></li><li><strong>继承允许你根据基类的实现来定义派生类的实现。这种通过生成派生类的复用通常被称为<span style=\"color:#79c6cd;\">白箱复用 (white-box reuse)</span>。术语\"白箱\"是相对可视性而言：<span style=\"background-color:#fbd4d0;\">在继承方式中，基类的内部细节对子类可见 。继承一定程度破坏了基类的封装，基类的改变，对派生类有很大的影响。派生类和基类间的依赖关系很强，耦合度高。</span></strong></li><li><strong>对象组合是类继承之外的另一种复用选择。新的更复杂的功能可以通过组装或组合对象来获得。对象组合要求被组合的对象具有良好定义的接口。这种复用风格被称为<span style=\"color:#79c6cd;\">黑箱复用(black-box reuse)</span>，<span style=\"background-color:#fbd4d0;\">因为对象的内部细节是不可见的。对象只以\"黑箱\"的形式出现。 组合类之间没有很强的依赖关系， 耦合度低</span>。优先使用对象组合有助于你保持每个类被封装。 </strong></li><li><strong>实际尽量多去用组合。组合的耦合度低，代码维护性好。不过继承也有用武之地的，有些关系就适合继承那就用继承，另外要实现多态，也必须要继承。类之间的关系可以用继承，可以用组合，就用组合。</strong></li></ul>\n</blockquote>\n<p><img alt=\"\" height=\"509\" src=\"image\\a0b0cd026cb74332a56bfc9d46aa004d.png\" width=\"1200\"/></p>\n<p><strong>        那既然组合比继承好，那就不用继承了么？当然不是，通过我们上边学习的它的优点，即使它万般不好，它的优点也是不可磨灭的，也验证了一点，存在即合理，所以我们还要看情况进行判断到底使用哪个，我们看下面两个例子：</strong></p>\n<p><img alt=\"\" height=\"556\" src=\"image\\ca16d91f0d0542328f8cc735af6235b4.png\" width=\"949\"/></p>\n<h1 id=\"9.%20%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95%E9%A2%98\"><span style=\"color:#ff9900;\">9. 笔试面试题</span></h1>\n<blockquote>\n<ol><li><strong>什么是菱形继承？菱形继承的问题是什么？ </strong></li><li><strong>什么是菱形虚拟继承？如何解决数据冗余和二义性的 </strong></li><li><strong>继承和组合的区别？什么时候用继承？什么时候用组合？</strong></li></ol>\n</blockquote>\n<p><strong>        自己想想吧，看看能不能总结出来，这些我可都讲过了哦~如果能说出来，说明你已经毕业了~！你已经是一只合格的 TWO TWO 了，如果没有，那就看看自己的问题，去回顾一下吧~！</strong></p>\n<p><img alt=\"\" height=\"1200\" src=\"image\\1130eff4d00145daa82b9fd06f15d824.jpeg\" width=\"1200\"/></p>\n<p></p>\n<p><strong>        如上就是 <span style=\"color:#fe2c24;\"><span style=\"background-color:#9c8ec1;\">继承</span></span> 的所有知识，如果大家喜欢看此文章并且有收获，可以支持下 <span style=\"color:#ff9900;\">兔7</span> ，给 <span style=\"color:#ff9900;\">兔7</span> 三连加关注，你的关注是对我最大的鼓励，也是我的创作动力~！</strong> </p>\n<p><strong>        再次感谢大家观看，感谢大家支持！</strong></p>\n</div>\n</div>"}