{"blogid": "124651895", "writerAge": "码龄1年", "writerBlogNum": "54", "writerCollect": "2628", "writerComment": "2224", "writerFan": "4023", "writerGrade": "6级", "writerIntegral": "5486", "writerName": "偷偷敲代码的青花瓷", "writerProfileAdress": "writer_image\\profile_124651895.jpg", "writerRankTotal": "4892", "writerRankWeekly": "42474", "writerThumb": "2249", "writerVisitNum": "100327", "blog_read_count": "2506", "blog_time": "已于 2022-05-08 19:43:41 修改", "blog_title": "动态规划——0/1背包问题(全网最细+图文解析)", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-light\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p><strong><font size=\"5\">✨动态规划——0/1背包问题(全网最细+图文解析)</font></strong></p>\n<hr/>\n<p><strong>作者介绍:</strong></p>\n<blockquote>\n<p><strong>🎓作者</strong>:青花瓷✨<br/> <strong>👀作者的Gitee</strong>:<a href=\"https://gitee.com/bitcleverlover\">代码仓库</a><br/> <strong>📌系列文章推荐:</strong><br/> ✨1.<a href=\"https://blog.csdn.net/Biteht/article/details/124298926?spm=1001.2014.3001.5501\">数据结构与算法—算法篇之动态规划(一)</a><br/> ✨2.<a href=\"https://blog.csdn.net/Biteht/article/details/124015718?spm=1001.2014.3001.5501\">【Java刷题特辑第一章】——【点进来花两把游戏的时间学习晚上睡觉都踏实了】</a><br/> ✨3.<a href=\"https://blog.csdn.net/Biteht/article/details/124444190?spm=1001.2014.3001.5501\">【Java刷题特辑第二章】—— 这些经典笔试题,你确定都做过吗?</a><br/> ✨✨我和大家一样都是热爱编程✨,很高兴能在此和大家分享知识,希望在分享知识的同时,能和大家一起共同进步,取得好成绩🤳,今天和大家分享的章节是<code>动态规划——0/1背包问题(全网最细+图文解析)</code><br/> ,如果有错误❌,欢迎指正哟😋,咋们废话不多说,跟紧步伐,开始学习吧~😊</p>\n</blockquote>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\7eac3f3df47148a1b2e4be72f47fe4f6.png\"/></p>\n<hr/>\n<p>前言:</p>\n<blockquote>\n<p><strong>背包问题是一个很经典的动态规划问题,这一篇博客采取图文解析的方式,帮助你更好的理解,废话不多说,我们开始学习吧✨🤳</strong></p>\n</blockquote>\n<hr/>\n<p></p>\n<div class=\"toc\">\n<h3>文章目录</h3>\n<ul><li><a href=\"#01_21\">0/1背包问题</a></li><li><ul><li><a href=\"#_37\">解题思路</a></li><li><a href=\"#_51\">代码实现</a></li></ul>\n</li><li><a href=\"#_94\">✨🎉总结</a></li></ul>\n</div>\n<p></p>\n<h1><a id=\"01_21\"></a>0/1背包问题</h1>\n<p><strong>一 题目描述:</strong></p>\n<blockquote>\n<p><strong>有n个物品，它们有各自的体积和价值，现有给定容量的背包，如何让背包里装入的物品具有最大的价值总和？</strong></p>\n</blockquote>\n<p><strong>为了方便讲解和理解,下面讲述个例子:</strong><br/> <img alt=\"在这里插入图片描述\" src=\"image\\866d4a555c0d43c2a295d20a0c987fee.png\"/></p>\n<p><strong>二 总体思路:</strong></p>\n<blockquote>\n<p>根据<code>动态规划解题步骤</code>（问题抽象化、建立模型、寻找约束条件、判断是否满足最优性原理、找大问题与小问题的递推关系式、填表、寻找解组成）找出01背包问题的最优解以及解组成，然后编写代码实现。</p>\n</blockquote>\n<p>如果对<code>动态规划解题思路以及步骤和如何推导转移方程</code>还不清楚的同学可以去看一下我前面发的一篇DP大总结希望能够帮到你:<a href=\"https://blog.csdn.net/Biteht/article/details/124298926?spm=1001.2014.3001.5501\">数据结构与算法—算法篇之动态规划(一)</a></p>\n<p><strong>三 动态规划的原理:</strong></p>\n<blockquote>\n<p>动态规划方法的原理就是把多阶段决策过程转化为一系列的单阶段决策问题，利用各个阶段之间的递推关系，逐个确定每个阶段的最优化决策，最终堆叠出多阶段决策的最优化决策结果。</p>\n</blockquote>\n<h2><a id=\"_37\"></a>解题思路</h2>\n<p><strong>首先我们先来推导,找一下递推关系和状态转移方程:</strong><br/> <img alt=\"在这里插入图片描述\" src=\"image\\79dd412aef3b4e8e83e7778672332e93.png\"/><br/> <strong>很显然这道题的状态转移方程:</strong></p>\n<blockquote>\n<p>为了方便理解 这里 <code>W代表物品的重量(背包容量),V代表物品的价值,f(k,w)代表:当背包容量为w,现有K件物品可以装,所能偷到的最大价值</code></p>\n</blockquote>\n<p><img alt=\"在这里插入图片描述\" src=\"image\\dcc716c1230747fb851133ef002ded9a.png\"/><br/> 填表,首先初始化边界条件,然后一行一行的填表:<br/> <strong>根据前面的推导,这个表格很容易就能填,我们只需要把对应的价值填上去就行了</strong><br/> <img alt=\"在这里插入图片描述\" src=\"image\\4429c0b4f3de4c3d8525d7c9102b800a.png\"/></p>\n<h2><a id=\"_51\"></a>代码实现</h2>\n<pre><code>/**\n     * 0-1背包\n     * @param val 价值\n     * @param weight 重量\n     * @param W 背包容量\n     * @return 最优解\n     */\n    public static int func(int[] val, int[] weight, int W) {\n        int N = weight.length;   //记录所有的物品数\n        int[][] V = new int[N + 1][W + 1];  //创建背包矩阵\n        //初始化矩阵 列，背包容量为0\n        for (int col = 0; col &lt;= W; col++) {\n            V[0][col] = 0;\n        }\n        for (int row = 0; row &lt;= N; row++) {\n            V[row][0] = 0;\n        }\n        for (int i = 1; i &lt;= N; i++) {  //一行一行填充值\n            for (int j = 1; j &lt;= W; j++) {  //一列一列填充值\n                if (weight[i - 1] &lt;= j) {  //如果当前物品重量小于等于背包中的当前重量 i为1是，weight[0]是第一个物品的重量\n                    //比较不加入该物品时该重量的最大价值（前一行）与当前物品的价值+可以容纳的剩余重量的价值\n                    V[i][j] = Math.max(val[i-1] + V[j-1][j - weight[i-1]],V[i-1][j]);\n                } else { //如果当前物品重量大于背包中的当前重量\n                    V[i][j]=V[i-1][j];  //直接使用前一行的最优解\n                }\n            }\n        }\n        /*打印矩阵\n        for (int[] rows: V) {\n            for (int col : rows) {\n                System.out.format(\"%5d\",col);\n            }\n            System.out.println();\n        }*/\n        return V[N][W];\n\n    }\n\n</code></pre>\n<h1><a id=\"_94\"></a>✨🎉总结</h1>\n<p><strong>“种一颗树最好的是十年前,其次就是现在”</strong><br/> 所以,<br/> <strong>“让我们一起努力吧,去奔赴更高更远的山海”</strong></p>\n<p>如果有错误❌,欢迎指正哟😋</p>\n<p><strong>🎉如果觉得收获满满,可以动动小手,点点赞👍,支持一下哟🎉</strong><br/> <img alt=\"在这里插入图片描述\" src=\"image\\88ef93cbf1f74960a903620c70829508.png\"/></p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}