{"blogid": "124694727", "writerAge": "码龄4年", "writerBlogNum": "22", "writerCollect": "97", "writerComment": "13", "writerFan": "647", "writerGrade": "3级", "writerIntegral": "414", "writerName": "moonfish_930", "writerProfileAdress": "writer_image\\profile_124694727.jpg", "writerRankTotal": "69679", "writerRankWeekly": "86270", "writerThumb": "35", "writerVisitNum": "29354", "blog_read_count": "1343", "blog_time": "于 2022-05-10 18:42:51 发布", "blog_title": "rust 交叉编译，吐血整理", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p>这两天一直在搞rust的交叉编译，大概花了1天半时间才搞明白。官方的文档说的很简单，始终不起作用，直到看了下面的文章才醍醐灌顶。从原理到详细步骤都有了。</p>\n<h1><a id=\"_2\"></a>原文链接</h1>\n<p><a href=\"https://danielmangum.com/posts/risc-v-bytes-rust-cross-compilation/\">RISC-V Bytes: Rust Cross-Compilation · Daniel Mangum</a></p>\n<p>感谢Daniel</p>\n<p>我自己也总结了一下，如果有朋友需要的话可以参考</p>\n<h1><a id=\"_10\"></a>简洁版</h1>\n<p>在工程目录下建立文件夹和配置文件</p>\n<pre><code class=\"prism language-bash\"><span class=\"token function\">mkdir</span> .cargo <span class=\"token operator\">&amp;&amp;</span> <span class=\"token builtin class-name\">cd</span> .cargo <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">touch</span> config.toml\n</code></pre>\n<p>然后运行即可</p>\n<pre><code class=\"prism language-bash\">cargo build\n</code></pre>\n<h1><a id=\"_24\"></a>详解版</h1>\n<h2><a id=\"_26\"></a>原理</h2>\n<p>以前用过C语言的交叉编译，需要注意的是两个，一个是编译链工具，另一个是sysroot。</p>\n<p>主要步骤有两个</p>\n<ol><li>利用编译链工具中的编译器编译c文件，这一步一般没有问题</li><li>利用编译链工具中的链接器将.o文件和从其他系统中拷贝过来的sysroot中的库文件链接到一起</li></ol>\n<p>rust的交叉编译似乎更简单一点。</p>\n<p>首先rust的编译链工具是跨平台的，不需要重新下载。比如你已经有一个编译链工具，使用如下命令显示</p>\n<pre><code class=\"prism language-bash\">rustup show\n</code></pre>\n<p>在我的电脑上得到</p>\n<blockquote>\n<p>Default host: x86_64-unknown-linux-gnu<br/> rustup home: /home/ubuntu/.rustup</p>\n<h2><a id=\"installed_toolchains_48\"></a>installed toolchains</h2>\n<p>stable-aarch64-unknown-linux-gnu (default)<br/> stable-x86_64-unknown-linux-gnu</p>\n<h2><a id=\"active_toolchain_54\"></a>active toolchain</h2>\n<p>stable-aarch64-unknown-linux-gnu (default)<br/> (error reading rustc version)</p>\n</blockquote>\n<p>说明我拥有两个工具链。但是上述的配置是错误的，应该使用的工具链为stable-x86_64-unknown-linux-gnu（我使用的是ubuntu22, 虚拟机，x86）。</p>\n<p>stable-x86_64-unknown-linux-gnu 这个工具链（toolchain）可以再我这个主机（host）上编任何目标（target）平台的程序，而不用像c语言一样，切换一个平台就需要重新下载一次新的toolchain。</p>\n<p>其次虽然工具链是单一的，但是target库跟c语言一样，需要链接，所以每一个target都需要下载自己的库文件。比较好的地方是c语言的库文件和头文件需要自己手动从其他系统拷贝过来，但是rust的库文件只需要命令行下载即可！非常方便。</p>\n<p>记住这两点，工具链和库，那么交叉编译就基本没问题了。</p>\n<h2><a id=\"_68\"></a>步骤</h2>\n<p>说一下环境，vmware下跑的ubuntu22虚拟机，输入</p>\n<pre><code class=\"prism language-bash\"><span class=\"token function\">uname</span> -a\n</code></pre>\n<blockquote>\n<p>Linux ubuntu-virtual-machine 5.15.0-27-generic #28-Ubuntu SMP Thu Apr 14 04:55:28 UTC 2022 x86_64 x86_64 x86_64 GNU/Linux</p>\n</blockquote>\n<p>初始状态下已经安装rustup，如果没有的话，可以访问网站</p>\n<p>https://www.rust-lang.org/tools/install</p>\n<p>或者输入命令（linux系统有效）安装一下即可</p>\n<pre><code class=\"prism language-bash\"><span class=\"token function\">curl</span> --proto <span class=\"token string\">'=https'</span> --tlsv1.2 -sSf https://sh.rustup.rs <span class=\"token operator\">|</span> <span class=\"token function\">sh</span>\n</code></pre>\n<ol><li> <p>确认目标机器。我需要在x86下编译，然后在arm64上跑程序。所以使用的是 aarch64-unknown-linux-gnu 。输入命令即可查看</p> <pre><code class=\"prism language-bash\">rustup target list\n</code></pre> <p>此时确认一下自己的工具链</p> <pre><code class=\"prism language-bash\">rustup show\n</code></pre>\n<blockquote>\n<p>Default host: x86_64-unknown-linux-gnu<br/> rustup home: /home/ubuntu/.rustup</p>\n<p>stable-x86_64-unknown-linux-gnu (default)<br/> rustc 1.60.0 (7737e0b5c 2022-04-04)</p>\n</blockquote> <p>可以看到目前只有一个工具链，没有target(其实有target，但是target是本机，所以不显示)。所以此时编译出来的程序可以在本地跑起来</p> <pre><code class=\"prism language-bash\">cargo new hello\n<span class=\"token builtin class-name\">cd</span> hello\ncargo run\n</code></pre>\n<blockquote>\n<p>Compiling hello v0.1.0 (/home/ubuntu/test/hello)<br/> Finished dev [unoptimized + debuginfo] target(s) in 4.94s<br/> Running <code>target/debug/hello</code><br/> Hello, world!</p>\n</blockquote> </li><li> <p>下载arm库</p> <pre><code class=\"prism language-bash\">rustup target <span class=\"token function\">add</span> aarch64-unknown-linux-gnu\n</code></pre> <p>运行命令确认</p> <pre><code class=\"prism language-bash\">rustup show\n</code></pre>\n<blockquote>\n<p>Default host: x86_64-unknown-linux-gnu<br/> rustup home: /home/ubuntu/.rustup</p>\n<h2><a id=\"installed_targets_for_active_toolchain_136\"></a>installed targets for active toolchain</h2>\n<p>aarch64-unknown-linux-gnu<br/> x86_64-unknown-linux-gnu</p>\n<h2><a id=\"active_toolchain_142\"></a>active toolchain</h2>\n<p>stable-x86_64-unknown-linux-gnu (default)<br/> rustc 1.60.0 (7737e0b5c 2022-04-04)</p>\n</blockquote> <p>此时有一个toolchain，两个target；其中aarch64-unknown-linux-gnu就是我需要的</p> </li><li> <p>下载目标平台gcc，配置target和链接器<br/> 这一步非常关键，而且让人迷惑。rust编译程序的过程需要用到自己的工具链，同时还需要用到gcc的链接工具！但是他们的名字非常接近但是又不完全一样。<br/> 还有一个我之前屡次失败的原因是：rust安装方式有问题！！！！！！！！！！我之前用的是</p> <pre><code class=\"prism language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">apt</span> <span class=\"token function\">install</span> cargo\n</code></pre> <p>这样会导致rustup的路径出现问题，千万要注意如果想正确编译的话必须用官网推荐的安装方法，也就是</p> <pre><code class=\"prism language-bash\"><span class=\"token function\">curl</span> --proto <span class=\"token string\">'=https'</span> --tlsv1.2 -sSf https://sh.rustup.rs <span class=\"token operator\">|</span> <span class=\"token function\">sh</span>\n</code></pre> <p>首先安装gcc</p> <pre><code class=\"prism language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">apt-get</span> <span class=\"token function\">install</span> -qq gcc-aarch64-linux-gnu\n</code></pre> <p>安装完成后如果输入以下命令有结果的话说明安装成功</p> <pre><code class=\"prism language-bash\">aarch64-linux-gnu-gcc -v\n</code></pre> <p>然后添加配置文件。在刚才建立的工程目录 hello 下</p> <pre><code class=\"prism language-bash\"><span class=\"token function\">mkdir</span> .cargo <span class=\"token operator\">&amp;&amp;</span> <span class=\"token builtin class-name\">cd</span> .cargo <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">touch</span> config.toml\n</code></pre> <p>将以下内容复制入config.toml内即可</p>\n<blockquote>\n<p>[build]<br/> target = “aarch64-unknown-linux-gnu”</p>\n<p>[target.aarch64-unknown-linux-gnu]<br/> linker = “aarch64-linux-gnu-gcc”</p>\n</blockquote> </li><li> <p>编译并运行</p> <pre><code class=\"prism language-bash\">cargo clean\ncargo build\ncargo run\n</code></pre> <p>如果输出以下信息，表示编译成功</p>\n<blockquote>\n<pre><code>Finished dev [unoptimized + debuginfo] target(s) in 0.00s\n Running `target/aarch64-unknown-linux-gnu/debug/hello`\n</code></pre>\n<p>target/aarch64-unknown-linux-gnu/debug/hello: 1: cannot open @8: No such file<br/> target/aarch64-unknown-linux-gnu/debug/hello: 1: ELF��g@�:: not found<br/> target/aarch64-unknown-linux-gnu/debug/hello: 2: @+*@@@0ppp<br/> �D��������+�-�: not found<br/> target/aarch64-unknown-linux-gnu/debug/hello: 3: �: not found<br/> target/aarch64-unknown-linux-gnu/debug/hello: 4: �: not found<br/> target/aarch64-unknown-linux-gnu/debug/hello: 5: Syntax error: “(” unexpected</p>\n</blockquote> <p>注意将hello程序拷贝出来后放入目标系统</p> <pre><code class=\"prism language-bash\"><span class=\"token function\">chmod</span> +x hello \n./hello\n</code></pre> <p>会产生如下信息</p>\n<blockquote>\n<p>./hello: /lib/aarch64-linux-gnu/libc.so.6: version `GLIBC_2.28’ not found (required by ./hello)</p>\n</blockquote> <p>说明目标系统的ubuntu版本过低。。。。</p> <p>两种选择，目标系统升级系统到ubuntu22，或者host系统降级到ubuntu18即可。</p> </li></ol>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}