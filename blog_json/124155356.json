{"blogid": "124155356", "writerAge": "码龄4年", "writerBlogNum": "28", "writerCollect": "84", "writerComment": "42", "writerFan": "5", "writerGrade": "3级", "writerIntegral": "643", "writerName": "Big Cole", "writerProfileAdress": "writer_image\\profile_124155356.jpg", "writerRankTotal": "51282", "writerRankWeekly": "404510", "writerThumb": "32", "writerVisitNum": "75598", "blog_read_count": "4884", "blog_time": "已于 2022-04-21 10:32:57 修改", "blog_title": "2022年php真实面试题整理", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<h2><a id=\"2022_php__0\"></a>2022年 php 面试题整理分享</h2>\n<h2><a id=\"1__2\"></a><strong>1. 单列模式实现方式</strong></h2>\n<p>单例模式 顾名思义就是一个类只能有一个实例，不能重复调用，只能实例化一次，像整个系统提供这个实例。可以避免大量的new操作，减少资源消耗，典型的数据库类的实例化，<br/> 三私一公 ，</p>\n<ul><li>私有构造方法，防止类在外部进行实例化</li></ul>\n<pre><code class=\"prism language-php\"><span class=\"token comment\">//私有的 构造方法 防止外部进行调用，只能内部调用 </span>\n\n<span class=\"token keyword\">private</span>  <span class=\"token keyword\">function</span> <span class=\"token function-definition function\">__construct</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token comment\">//可以写 操作数据库的方法，当时实例化的时候，调用自己来实现 </span>\n\n<span class=\"token punctuation\">}</span>\n\n</code></pre>\n<ul><li>私有的静态变量，直接在内部进行调用</li></ul>\n<pre><code class=\"prism language-php\"><span class=\"token comment\">//私有的 静态变量 只能内部调用，外部不能使用</span>\n\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token variable\">$object</span><span class=\"token operator\">=</span><span class=\"token constant\">null</span><span class=\"token punctuation\">;</span>\n\n</code></pre>\n<ul><li>私有的克隆方法，访问外部克隆</li></ul>\n<pre><code class=\"prism language-php\"><span class=\"token comment\">//私有的克隆方法</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">function</span> <span class=\"token function-definition function\">_clone</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<ul><li>公有的静态方法</li></ul>\n<pre><code class=\"prism language-php\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">function</span> <span class=\"token function-definition function\">getObj</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n     <span class=\"token comment\">//非常关键这个 instanceof 判断类或者方法是否 在本类中  不存在返回当期类 </span>\n     <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span> <span class=\"token operator\">!</span><span class=\"token punctuation\">(</span><span class=\"token keyword static-context\">self</span><span class=\"token operator\">::</span><span class=\"token variable\">$object</span> <span class=\"token keyword\">instanceof</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n          <span class=\"token comment\">//给静态变量赋值 </span>\n \t      <span class=\"token keyword static-context\">self</span><span class=\"token operator\">::</span><span class=\"token variable\">$object</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">;</span>\n\t  <span class=\"token punctuation\">}</span>\n\t  <span class=\"token comment\">// 静态变量有值说明 已经实例化过，直接返回静态类  </span>\n\t   <span class=\"token keyword\">return</span> <span class=\"token keyword static-context\">self</span><span class=\"token operator\">::</span><span class=\"token variable\">$object</span>\n<span class=\"token punctuation\">}</span>\n\n</code></pre>\n<p>调用的</p>\n<pre><code class=\"prism language-php\"><span class=\"token variable\">$data</span> <span class=\"token operator\">=</span> <span class=\"token class-name static-context\">newClass</span><span class=\"token operator\">::</span><span class=\"token function\">getObj</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<h2><a id=\"2__58\"></a><strong>2. 防止反射、防止克隆方式</strong></h2>\n<p>php 反射<br/> 面向对象编程中对象被赋予了自省的能力，而这个自省的过程就是反射<br/> 反射，直观理解就是根据到达地找到出发地和来源。比如，一个光秃秃的对象，我们可以仅仅通过这个对象就能知道它所属的类、拥有哪些方法<br/> 反射是指在PHP运行状态中，扩展分析<strong>PHP程序，导出或提出关于类、方法、属性、参数等的详细信息，包括注释。这种动态获取信息</strong>以及动态调用对象方法的功能称为反射<br/> 在平常开发中，用到反射的地方不多：一个是对对象进行调试，另一个是获取类的信息。在MVC和插件开发中，使用反射很常见，但是反射的消耗也很大，在可以找到替代方案的情况下，就不要滥用 具体参考 <a href=\"https://www.php.cn/write/3491.html\">反射</a><br/> 防止被反射，可以设置成私有的属性和方法<br/> php克隆：外部可以复制自己本类 ，clone() 方法 防止克隆，讲设置一个私有的克隆方法，即可</p>\n<h2><a id=\"3_MYsql__68\"></a>3. <strong>MYsql 锁</strong></h2>\n<p>排它锁 （写锁） 关键字 for updte<br/> select * from table where a=1 for update<br/> 对于普通 SELECT 语句，InnoDB 不会加任何锁；只能在事务执行过程中使用加锁<br/> 锁只有在执行commit或者rollback的时候才会释放，并且所有的锁都是在同一时刻被释放<br/> 共享锁就是读锁 lock in share mode<br/> SELECT * FROM table_name WHERE … LOCK IN SHARE MODE。<br/> 事务执行完后自动释放</p>\n<h2><a id=\"4_76\"></a>4.最左原则</h2>\n<p>顾名思义 从最左边进行匹配查询 ，一直向右边匹配，只遇到范围内查询进行停止 （&lt; &gt; + %）；</p>\n<h2><a id=\"5__78\"></a>5. 覆盖索引</h2>\n<p>通俗理解，所查询的列，都已经设置索引，不需要进行全表进行查询，这样可以提高查询效率，也叫覆盖索引 Using index</p>\n<h2><a id=\"6_bhash_80\"></a>6. b+树与hash数据结构的时间复杂度</h2>\n<p>如果等值的时候 hash 执行 一次查询 O（1） b+树 最多是O（n）。<br/> 如果带有 范围查询 则就是 O（N） b+树一般 三层 具体区别<a href=\"https://blog.csdn.net/weixin_43841693/article/details/107301253\">请查看</a></p>\n<h2><a id=\"7_io_83\"></a>7. 如何减少io</h2>\n<p>SQL/index，使用合适的索引减少扫描的行数、减少回表查询。可以减少磁盘io</p>\n<h2><a id=\"8_b_85\"></a>8. b+树层高、好处、为啥不用二叉树</h2>\n<p>B+树层一般高为三层（可以存2千w数据），叶子节点保存索引和数据，分叶子节点保存索引，减少内存的使用，可以节约资源，而且相互之间有指针，可以提高查找效率。数据结构比较稳定。<br/> 二叉树是链表结构，相当于全表扫描。查询效率比b+树慢</p>\n<h2><a id=\"9myisam_innodb_88\"></a>9.myisam innodb</h2>\n<p><strong>innodb</strong> 5.0以上版本，默认存储引擎 ，支持事务，支持外键，支行锁，可以进行数据恢复，不保存数据行数。<br/> <strong>myisam</strong> 5.0之前默认版本，不支持事务，不支持外键，支持表锁，不支持并发操作。适合快速插入和删除的操作，对数据的完整性要求不高<br/> <strong>memory</strong>存储引擎是MySQL中的一类特殊的存储引擎。其数据在内存中存储</p>\n<h2><a id=\"10Nginxphp_92\"></a>10.Nginx和php怎么交互的</h2>\n<p>1.发起请求到nginx<br/> 2.通过fastcgi接口协议，php-pfm将接受的请求发送wrapper客户端<br/> 3.wrapper会生成一个新的线程调用php动态程序解析服务器 将处理 的数据<br/> 4.返回给php-fpm ,在通过fastcgi协议，返回给nginx ,<br/> 5.然后nginx构造一个响应报文将结果返回给用户</p>\n<h2><a id=\"11nginx___98\"></a>11.nginx 服务限流 漏桶，令牌桶</h2>\n<p>计数器算法：在一段时间间隔内（时间窗/时间区间），处理请求的最大数量固定，超过部分不做处理。<br/> 漏桶算法：水流如漏桶中，然后漏桶一定的速度出水，当流如的水速度大于漏水的速度，会直接溢出，可以看出漏桶算法强行限制数据的传输速度；<br/> 令牌桶 ： 系统以一个额定的速度，往桶中加令牌，如果请求需要被处理，则需要从桶中获取一个令牌，当桶中没有令牌的时候 ，则拒绝服务</p>\n<h2><a id=\"12Get_64k_103\"></a>12.Get长度有限制 64k是浏览器限制</h2>\n<h2><a id=\"13_Post__105\"></a>13 Post 是两次请求原因</h2>\n<p>第一条为options请求，第二条请求才是我们预想中的请求<br/> 在发生正式的请求之前，先进行一次预检请求。看服务端返回一些信息，浏览器拿到之后，看后台是否允许进行访问<br/> 为什么先发起了一条options请求 ：只要是带自定义header的跨域请求 就会发生opntions 请求<br/> 解决办法 避开跨域 使用简单的简单跨域请求 不在head头部加自定义内容</p>\n<h2><a id=\"14session_cookie_110\"></a>14.session cookie</h2>\n<p>基础问题</p>\n<h2><a id=\"15_epoll_poll_select_113\"></a>15.网络编程 epoll poll select区别</h2>\n<p>selet poll epoll 都属于 IO多路复用的机制 ，IO多路复用就是通过一种机制，可以监视多个描述符，一旦某个描述符就绪，就能够通知程序进行相应的读写操作；<br/> 但select poll epoll 本质都是同步io操作 。因为他们需要在读写操作就绪后自己复杂进行读写，也就是说这个读写过程是阻塞的。而异步io则，无需自己负责进行读写，异步IO的实现会负责把数据从内核拷贝到用户空间。<br/> <strong>select 时间复杂度大于O（n）</strong><br/> 它仅仅知道有io事件发生了，但不知道是那个流发生了，可能是一个，也可能是多个，甚至全部，所以只能<strong>无差别轮询</strong>所有的流，找到读出数据或者能写入数据的流，然后对他操作，<br/> <strong>poll 时间复杂度O（n）</strong><br/> POLL本质和slect没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，但是没有最大的链接数的限制，原因是它基于链表来存储；<br/> <strong>epoll 时间复杂度O（1）</strong><br/> 不同于忙于轮询和无差别轮询，epoll会把那个流发生了怎么样 的IO，事件通知我们，所以说epoll实际是<strong>事件驱动</strong>，每个事件上都管理fd的 ，此时我们对这些流的都意义的；</p>\n<h2><a id=\"16redis_bitmap_123\"></a>16.redis bitmap</h2>\n<p>，BitMap 底层是基于 Redis 的字符串类型实现的<br/> 数组的每个单元只能存储0和1，数组的下标在 Bitmaps 中叫做偏移量。<br/> 可以做完布隆过滤器使用</p>\n<h2><a id=\"17redis__127\"></a>17.redis 发布订阅</h2>\n<p>使用pub和 sub的 方式处理消息，它采用事件作为基本的通信机制，提供大规模系统所要求的松散耦合的交互模式：订阅者(如客户端)以事件订阅的方式表达出它有兴趣接收的一个事件或一类事件；发布者(如服务器)可将订阅者感兴趣的事件随时通知相关订阅者。<br/> publish 发布消息<br/> subscribe 订阅消息</p>\n<h2><a id=\"18Redis__132\"></a>18.Redis锁如何实现的 基于什么原理</h2>\n<p>setnx 设置锁 但是必须用exprie 失效时间，只在键 key 不存在的情况下，将键 key 的值设置为 value 。若键 key 已经存在， 则 SETNX 命令不做任何动作<br/> set 可以自带过期时间<br/> <strong>原理：xxxxx</strong></p>\n<h2><a id=\"19_136\"></a>19.一致性哈希</h2>\n<h2><a id=\"20_138\"></a>20.边缘触发和水平触发</h2>\n<h2><a id=\"21_140\"></a>21.五种数据格式的查询时间复杂度</h2>\n<p>1.字符串 结构 可以简单保存缓存数据<br/> 2.list 双向链表 可以简单做队列使用<br/> 3.hash 保存对象类型的缓存数据<br/> 4.set 集合 交集 差集<br/> 5zet 有序集合 排行榜 排序的<br/> 参考 <a href=\"https://www.jianshu.com/p/9c86e1556b68\">redis五种数据结构底层原理</a></p>\n<h2><a id=\"22_147\"></a>22.三种集群</h2>\n<p>主从复制 哨兵 集群</p>\n<p>https http<br/> Ssl非对称加密加密<br/> 证书+信任链 rsa加密<br/> 非对称加密效率低<br/> 对称加密数据传输</p>\n<p>kafka rabbitmq区别</p>\n<p>Kafa使用场景</p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>"}