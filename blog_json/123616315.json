{"blogid": "123616315", "writerAge": "码龄1年", "writerBlogNum": "92", "writerCollect": "1012", "writerComment": "1167", "writerFan": "3881", "writerGrade": "5级", "writerIntegral": "4484", "writerName": "K稳重", "writerProfileAdress": "writer_image\\profile_123616315.jpg", "writerRankTotal": "3880", "writerRankWeekly": "5689", "writerThumb": "1325", "writerVisitNum": "53788", "blog_read_count": "1440", "blog_time": "于 2022-03-22 22:13:51 发布", "blog_title": "【Java成王之路】第十四篇：Java SE(面向对象编程—组合、多态)", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h1 id=\"%E6%9C%AC%E8%8A%82%E7%9B%AE%E6%A0%87\">本节目标</h1>\n<p>组合</p>\n<p>多态</p>\n<p>一、什么是组合</p>\n<blockquote>\n<p>和继承类似, 组合也是一种表达类之间关系的方式, 也是能够达到代码重用的效果. 例如表示一个学校:</p>\n<pre><code>public class Student { \n ... \n} \npublic class Teacher { \n ... \n} \npublic class School { \n public Student[] students; \n public Teacher[] teachers; \n} </code></pre>\n<p>组合并没有涉及到特殊的语法(诸如 extends 这样的关键字), 仅仅是将一个类的实例作为另外一个类的字段. 这是我们设计类的一种常用方式之一</p>\n<p>组合表示 has - a 语义</p>\n<p>在刚才的例子中, 我们可以理解成一个学校中 \"包含\" 若干学生和教师</p>\n<p>继承表示 is - a 语义</p>\n<p>在上面的 \"动物和狗\" 的例子中, 我们可以理解成一只狗也 \"是\" 一种动物.</p>\n</blockquote>\n<p>二、什么是多态</p>\n<blockquote>\n<p>多态：字面理解：一种事物多种形态（这句话万万不可和面试官说） </p>\n</blockquote>\n<p>向上转型： </p>\n<blockquote>\n<p>向上转型：一句话，父类引用，引用子类对象</p>\n<pre><code>class Animal{\n    public String name;\n    public int age;\n\n    public void eat(){\n        System.out.println(\"eat()\");\n    }\n\n    public Animal(String name,int age){\n        this.name = name;\n        this.age = age;\n    }\n}\nclass Dag extends Animal {\n    public Dag(String name,int age){\n        super(name,age);\n    }\n\n\n}\nclass Bird extends Animal{\n\n    public String wing;\n\n    public void fly(){\n        System.out.println(age+\"fly\");\n\n    }\n\n    public Bird(String name,int age,String wing){\n        super(name,age);\n        this.wing = wing;\n    }\n\n}\npublic class TestDemo{\n    public static void main(String[] args) {\n        //Dag dag = new Dag(\"HAHAH\",12);\n        //Animal animal = dag;\n        Animal animal1 = new Dag(\"HAHAH\",12);\n    }</code></pre>\n<p><img alt=\"\" height=\"319\" src=\"image\\525985b166b74f37ad03cf15f75be4c5.png\" width=\"1095\"/></p>\n<p>什么情况下会发什么向上转型：</p>\n<p>1、直接赋值</p>\n<p>2、方法传参</p>\n<p>3、方法返回</p>\n<p>直接赋值的方式我们已经演示了. 另外两种方式和直接赋值没有本质区别</p>\n<p>方法传参：</p>\n<p><img alt=\"\" height=\"420\" src=\"image\\40716fef8db049e4889c627f505209a1.png\" width=\"783\"/></p>\n<p> 此时形参 animal 的类型是 Animal (基类), 实际上对应到 Dag (父类) 的实例</p>\n<p> 方法返回：</p>\n<p><img alt=\"\" height=\"186\" src=\"image\\3601fc4d9785449fafdb21884a820846.png\" width=\"693\"/></p>\n</blockquote>\n<p>动态绑定：</p>\n<blockquote>\n<p>动态绑定：</p>\n<p>两个前提：</p>\n<p>1、父类引用，引用子类的对象</p>\n<p>2、通过这个父类引用，调用父类和子类同名的覆盖方法</p>\n<p>同名的覆盖方法，术语：重写</p>\n<p>重写：</p>\n<p>1：方法名相同</p>\n<p>2：参数列表校相同（个数+类型）</p>\n<p>3：返回值相同</p>\n<p>重写必须在父子类的情况下</p>\n<p>动态绑定是多态的基础</p>\n<pre><code>\n// Animal.java \npublic class Animal { \n protected String name; \n public Animal(String name) { \n this.name = name; \n } \n public void eat(String food) { \n System.out.println(\"我是一只小动物\"); \n System.out.println(this.name + \"正在吃\" + food); \n } \n} \n// Bird.java \npublic class Bird extends Animal { \n public Bird(String name) { \n super(name); \n } \n public void eat(String food) { \n System.out.println(\"我是一只小鸟\"); \n System.out.println(this.name + \"正在吃\" + food); \n } \n} \n// Test.java \npublic class Test { \n public static void main(String[] args) { \n Animal animal1 = new Animal(\"圆圆\"); \n animal1.eat(\"谷子\"); \n Animal animal2 = new Bird(\"扁扁\"); \n animal2.eat(\"谷子\"); \n } \n} \n// 执行结果\n我是一只小动物\n圆圆正在吃谷子\n我是一只小鸟\n扁扁正在吃谷子\n</code></pre>\n<p>此时, 我们发现:</p>\n<p>animal1 和 animal2 虽然都是 Animal 类型的引用, 但是 animal1 指向 Animal 类型的实例, animal2 指向 Bird 类型的实例.</p>\n<p>针对 animal1 和 animal2 分别调用 eat 方法, 发现 animal1.eat() 实际调用了父类的方法, 而 animal2.eat() 实际调用了子类的方法</p>\n<p>因此, 在 Java 中, 调用某个类的方法, 究竟执行了哪段代码 (是父类方法的代码还是子类方法的代码) , 要看究竟这个引 用指向的是父类对象还是子类对象. 这个过程是程序运行时决定的(而不是编译期), 因此称为 动态绑定</p>\n<p>注意事项：</p>\n<p>1、方法不可以是static的</p>\n<p>2、子类的访问修饰限定符，要大于等于父类的访问修饰限定符</p>\n<p>3、private方法，不能重写</p>\n<p>4、被final修饰的方法，不能被重写</p>\n</blockquote>\n<blockquote>\n<p>另外, 针对重写的方法, 可以使用 @Override 注解来显式指定</p>\n<pre><code>// Bird.java \npublic class Bird extends Animal { \n @Override \n private void eat(String food) { \n ... \n } \n} \n</code></pre>\n<p>有了这个注解能帮我们进行一些合法性校验. 例如不小心将方法名字拼写错了 (比如写成 aet), 那么此时编译器就会发 现父类中没有 aet 方法, 就会编译报错, 提示无法构成重写. 我们推荐在代码中进行重写方法时显式加上 @Override 注解</p>\n</blockquote>\n<p>总结：</p>\n<p>我们先简单的了解一下多态的概念，后续多态的有关知识我们会通过代码的方式，加深对多态的理解和认识，让大家能跟完完全全的掌握多态的语法知识。</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/d1e0b4bfb49c40efab3b0cfbf8d51ffe.gif\"/></p>\n<p> </p>\n<p></p>\n<p></p>\n</div>\n</div>"}