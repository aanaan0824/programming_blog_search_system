{"blogid": "126082771", "writerAge": "码龄1年", "writerBlogNum": "111", "writerCollect": "554", "writerComment": "666", "writerFan": "1101", "writerGrade": "5级", "writerIntegral": "2374", "writerName": "逆风飞翔的小叔", "writerProfileAdress": "writer_image\\profile_126082771.jpg", "writerRankTotal": "7913", "writerRankWeekly": "1819", "writerThumb": "501", "writerVisitNum": "557916", "blog_read_count": "8140", "blog_time": "于 2022-07-31 20:44:11 发布", "blog_title": "java 处理树形结构数据", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h1>前言</h1>\n<p></p>\n<p>问题的背景大概是这样的，有下面这样一个excel表，原始数据结构如下：</p>\n<p></p>\n<p><img alt=\"\" height=\"249\" src=\"image\\30c6f407d3994352950eef419dbdd10c.png\" width=\"773\"/></p>\n<p></p>\n<p><strong>需求点：</strong></p>\n<ul><li>导入excel的机构层级数据到mysql的机构表（这里假设为 depart）;</li><li>导入的机构数据以层级进行保存和区分；</li><li>界面展示时需要以完整的树形层级进行展示；</li></ul>\n<p></p>\n<h1>处理过程</h1>\n<p></p>\n<p>按照上面已知的信息，设计一个简单的机构表</p>\n<p></p>\n<pre><code class=\"language-sql\">CREATE TABLE `depart` (\n  `depart_id` varchar(64) DEFAULT NULL,\n  `pid` varchar(64) DEFAULT NULL,\n  `name` varchar(255) DEFAULT NULL,\n  `path` varchar(255) DEFAULT NULL\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\n</code></pre>\n<p></p>\n<p>接下来分析下具体的实现；</p>\n<p></p>\n<p><strong>1、导入的时候以层级保存数据 </strong></p>\n<p></p>\n<p>有做过树形结构处理业务的小伙伴们对树形结构的处理并不陌生，主要就是在机构表中合理运用 id 和 pid 构建数据层级关系，期间可能涉及到递归的操作（不建议在数据库层面递归）；</p>\n<p></p>\n<p>但我们说具体问题具体分析，比如按照上面的exce表的数据结构，以 “/产品研发中心/业务一部” 这个机构为例做简单说明</p>\n<p></p>\n<ul><li>以 “/” 区分，这条数据涉及到2个部门，“产品研发中心” 为一级部门，而 “业务一部” 为其子部门，即二级部门；</li><li>按照第一步的分析，需要将这条数据拆开来做处理，通过部门名称以及其所在层级（业务中可能还存在其他字段），即在查库过程中作为查询条件；</li><li>需要考虑excel中的数据存在性，比如 “产品研发中心” 这条数据在数据库中可能存在，也可能不存在，“业务一部” 也可能存在或不存在；</li><li>在第三步的基础上，需要按照程序的逻辑设置一定的规则，大概如下：1、顶级部门不存在，可以认为这条数据在数据库中不存在，处理的时候直接按照正常的规则；2、顶级部门存在，直接处理最后一级数据；</li><li>不考虑中间部门层级，像 “/A/B/C” 中的B是否存在问题；</li></ul>\n<p></p>\n<p><strong>2、返回树形层级结构数据</strong></p>\n<p></p>\n<p>相比导入来说，返回树形层级结构相对来说，已经有相对成熟的处理方式，大致思路如下：</p>\n<ul><li>查询所有数据（如果考虑动态加载另说）；</li><li>构建返回数据的树形结构（可根据 id 和 pid 的关系）；</li></ul>\n<p>树形结构的返回对象结构大致如下</p>\n<pre><code class=\"language-java\">public class DepartDTO {\n\n    private String departId;\n\n    private String pid;\n\n    private String name;\n\n    private String path;\n\n    private String pname;\n\n    private List&lt;DepartDTO&gt; children;\n\n}</code></pre>\n<p></p>\n<h1>返回树形层级数据</h1>\n<p></p>\n<p>先来做第二个需求，由于解决思路已经给出，只需要按照思路进行即可，下面贴出主要的逻辑代码</p>\n<p></p>\n<pre><code class=\"language-java\">    public static String random() {\n        return UUID.randomUUID().toString().replaceAll(\"-\", \"\");\n    }\n\n\n    public static List&lt;DepartDTO&gt; getDepartTree(List&lt;DepartDTO&gt; allDepart) {\n        //查询到的所有的部门数据\n        //List&lt;DepartDTO&gt; allDepart = getAllDepart();\n        //最高级别用户集合\n        List&lt;DepartDTO&gt; roots = new ArrayList&lt;&gt;();\n        List&lt;DepartDTO&gt; res = new ArrayList&lt;&gt;();\n        for (DepartDTO departDto : allDepart) {\n            //-1表示最高级别的用户\n            if (departDto.getPid().equals(\"0\")) {\n                roots.add(departDto);\n            }\n        }\n        //从最高级别用户开始遍历，递归找到该用户的下级用户，将带有下级的最高级用户放入返回结果中\n        for (DepartDTO userDto : roots) {\n            userDto = buildUserTree(allDepart, userDto);\n            res.add(userDto);\n        }\n        return res;\n    }\n\n    public static DepartDTO buildUserTree(List&lt;DepartDTO&gt; allDeparts, DepartDTO departDTO) {\n        List&lt;DepartDTO&gt; children = new ArrayList&lt;&gt;();\n        //遍历查到的所有用户\n        for (DepartDTO departDTO1 : allDeparts) {\n            //-1代表根节点，无需重复比较\n            if (departDTO1.getPid().equals(\"0\") || departDTO1.getPname().equals(\"\") || departDTO1.getPname() == null)\n                continue;\n            //当前用户的上级编号和传入的用户编号相等，表示该用户是传入用户的下级用户\n            if (departDTO1.getPname().equals(departDTO.getName())) {\n                //递归调用，再去寻找该用户的下级用户\n                departDTO1 = buildUserTree(allDeparts, departDTO1);\n                //当前用户是该用户的一个下级用户，放入children集合内\n                children.add(departDTO1);\n            }\n        }\n        //给该用户的children属性赋值，并返回该用户\n        departDTO.setChildren(children);\n        return departDTO;\n    }</code></pre>\n<p></p>\n<p>这里先直接模拟一部分的数据，通过这部分的数据做处理</p>\n<pre><code class=\"language-java\">static List&lt;String&gt; departLists = new ArrayList&lt;&gt;();\n\n    static {\n\n        departLists.add(\"/产品研发中心/业务中台部\");\n        departLists.add(\"/产品研发中心/技术中台部\");\n        departLists.add(\"/产品研发中心/技术中台部/产品A组\");\n        departLists.add(\"/总裁办\");\n        departLists.add(\"/总裁办/品牌管理部\");\n    }\n\n\n    public static void main(String[] args) {\n        List&lt;DepartDTO&gt; allDepart = getAllDepart();\n        List&lt;DepartDTO&gt; departTree = getDepartTree(allDepart);\n        System.out.println(departTree);\n    }</code></pre>\n<p></p>\n<p>上面程序用到的两个工具类</p>\n<pre><code class=\"language-java\">public class PathUtils {\n\n    public static List&lt;String&gt; getPaths(String path) {\n        List&lt;String&gt; parentPaths = getParentPaths(path);\n        parentPaths.add(path);\n        return parentPaths;\n    }\n\n    public static String getParentPath(String path) {\n        return StringUtils.substringBeforeLast(StringUtils.removeEnd(path, \"/\"), \"/\");\n    }\n\n    public static List&lt;String&gt; getParentPaths(String path) {\n        List&lt;String&gt; paths = new ArrayList&lt;&gt;();\n        while (true) {\n            path = getParentPath(path);\n            if (StringUtils.isBlank(path)) {\n                break;\n            }\n            paths.add(path);\n        }\n\n        paths.sort(String::compareTo);\n        return paths;\n    }\n\n    /**\n     * 拼接部门名称完整路径，如 湖北省，襄阳市，谷城县，最终组装成 : 湖北省/襄阳市/谷城县\n     *\n     * @param paths\n     * @return\n     */\n    public static String merge(List&lt;String&gt; paths) {\n        return merge(paths, null);\n    }\n\n    public static String merge(List&lt;String&gt; paths, Function&lt;String, String&gt; function) {\n        if (CollectionUtils.isEmpty(paths)) {\n            return null;\n        }\n\n        Stream&lt;String&gt; stream = paths.stream();\n        if (Objects.nonNull(function)) {\n            stream = stream.map(function);\n        }\n\n        return stream.filter(Objects::nonNull).collect(joining(\"/\", \"/\", \"\"));\n    }\n\n    public static String getNextPath(String path) {\n        path = StringUtils.removeEnd(path, \"/\");\n        String parentPath = StringUtils.substringBeforeLast(path, \"/\");\n        int val = NumberUtils.toInt(StringUtils.substringAfterLast(path, \"/\")) + 1;\n        return parentPath + \"/\" + StringUtils.leftPad(String.valueOf(val), 4, \"0\");\n    }\n\n    public static String getNextPath(String parentPath, List&lt;String&gt; childPaths) {\n        if (CollectionUtils.isEmpty(childPaths)) {\n            return parentPath + \"/001\";\n        }\n        if (childPaths.size() + 1 &gt;= 1000) {\n            throw new RuntimeException(\"同级机构最多支持9999个\");\n        }\n        //获取同级最大值路径\n        Collections.sort(childPaths, Comparator.reverseOrder());\n        String maxPath = childPaths.get(0);\n        if (StringUtils.isNotBlank(maxPath)) {\n            return PathUtils.getNextPath(maxPath);\n        }\n        return parentPath + \"/001\";\n    }\n\n    public static void main(String[] args) {\n        /*System.out.println(getParentPaths(\"/001/002/003/004/\"));\n        List&lt;String&gt; childPaths = new ArrayList&lt;&gt;();\n        childPaths.add(\"/001\");\n        childPaths.add(\"/007\");\n        childPaths.add(\"/1000\");\n        childPaths.add(\"/001\");\n        childPaths.add(\"/901\");\n        childPaths.add(\"/766\");\n        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();\n        childPaths.forEach(item -&gt;{\n            result.add(Integer.valueOf(item.substring(1)));;\n        });\n        Integer max = Collections.max(result);\n        System.out.println(max);*/\n        String pathNames = \"/产品研发中心/业务中台部\";\n        String substring = pathNames.substring(pathNames.lastIndexOf(\"/\") + 1);\n        System.out.println(substring);\n\n        //String paths = \"/001/002/003/004/\";\n        String paths = \"/001/001\";\n        List&lt;String&gt; parentPaths = getParentPaths(paths);\n\n        System.out.println(parentPaths);\n\n    }\n\n    public static String getMaxPath(List&lt;String&gt; pathList) {\n        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();\n        pathList.forEach(item -&gt; {\n            result.add(Integer.valueOf(item.substring(1)));\n            ;\n        });\n        Integer max = Collections.max(result);\n        return String.valueOf(\"/\" + max);\n    }\n\n}\n</code></pre>\n<p></p>\n<p>最后写个接口模拟下</p>\n<pre><code class=\"language-java\">     //localhost:8087/getAllDepart\n    @GetMapping(\"/getAllDepart\")\n    public Object getAllDepart() {\n       \n        return departService.importDepart();\n    }</code></pre>\n<p></p>\n<p>运行上面的main程序，观察控制台输出结果</p>\n<p><img alt=\"\" height=\"251\" src=\"image\\bb39108757e54f98b6bfdec4344f8bff.png\" width=\"1200\"/></p>\n<p></p>\n<p>用格式化工具处理下再看，这即为我们期待的结果，实际业务中，只需要在 getAllDepart 这个方法中，将获取数据从数据库查询即可；</p>\n<pre><code class=\"language-java\">[\n    {\n        \"departId\":\"e1c6d8ba4a504b7da85472ca713be107\",\n        \"pid\":\"0\",\n        \"name\":\"产品研发中心\",\n        \"path\":null,\n        \"pname\":\"\",\n        \"children\":[\n            {\n                \"departId\":\"8e39b272531449ca96c0668ae60d2c2f\",\n                \"pid\":\"e1c6d8ba4a504b7da85472ca713be107\",\n                \"name\":\"业务中台部\",\n                \"path\":null,\n                \"pname\":\"产品研发中心\",\n                \"children\":[\n\n                ]\n            },\n            {\n                \"departId\":\"ecfe24e1769248df885287c7e153f9e6\",\n                \"pid\":\"e1c6d8ba4a504b7da85472ca713be107\",\n                \"name\":\"技术中台部\",\n                \"path\":null,\n                \"pname\":\"产品研发中心\",\n                \"children\":[\n                    {\n                        \"departId\":\"0218c648abdf4867ad5ea1e99098d526\",\n                        \"pid\":\"ecfe24e1769248df885287c7e153f9e6\",\n                        \"name\":\"产品A组\",\n                        \"path\":null,\n                        \"pname\":\"技术中台部\",\n                        \"children\":[\n\n                        ]\n                    }\n                ]\n            }\n        ]\n    },\n    {\n        \"departId\":\"843bfa6b371e4d7d8d44894d939ca0a5\",\n        \"pid\":\"0\",\n        \"name\":\"总裁办\",\n        \"path\":null,\n        \"pname\":\"\",\n        \"children\":[\n            {\n                \"departId\":\"12dc458b6996484394e2026d5b0f547e\",\n                \"pid\":\"843bfa6b371e4d7d8d44894d939ca0a5\",\n                \"name\":\"品牌管理部\",\n                \"path\":null,\n                \"pname\":\"总裁办\",\n                \"children\":[\n\n                ]\n            }\n        ]\n    }\n]</code></pre>\n<p></p>\n<h1>数据导入</h1>\n<p></p>\n<p>其实，只要按照上文的处理思路做即可，但是这里提一个在逻辑编写过程中遇到的一个比较难处理的问题，即机构的 path 上；</p>\n<p></p>\n<p>这里必须要说一下这个 path 的事情，path 在真实的业务场景中，是一个非常重要，并且在众多的使用场景中高频使用的字段，因为对一个机构来说，通过业务的区分，这个path一定是唯一的存在； </p>\n<p></p>\n<p>仍然使用文章开头的那些数据，最终将 “/产品研发中心/业务一部” 这样的数据入库时，需要将数据组装成一个个对象插入到数据库，同时，插入数据之前，层级也需要组装好，那么对于 “/产品研发中心/业务一部” 这样一条数据，可以想象到，将会产生两个 depart 对象，这里我们考虑下面两个简单的场景；</p>\n<ol><li>如果顶级部门不存在，全量导入，比如 “/产品研发中心/业务一部” 这样一条数据，当 “/产品研发中心” 不存在时，完整导入；</li><li>“/产品研发中心/业务一部” ，当  “产品研发中心” 存在时，只需导入 “业务一部” ；</li></ol>\n<p></p>\n<p>下面来看核心代码</p>\n<p></p>\n<pre><code class=\"language-java\">@Service\npublic class DepartTest {\n\n    @Autowired\n    private DepartDao departDao;\n\n    @Autowired\n    private TransactionUtils transactionUtils;\n\n    @Autowired\n    private DataSourceTransactionManager dataSourceTransactionManager;\n\n    static List&lt;String&gt; departLists = new ArrayList&lt;&gt;();\n\n    private static final String tenantId = \"e10adc3949ba59abbe56e057f20f88dd\";\n\n    static {\n        departLists.add(\"/top1\");\n        departLists.add(\"/top1/ch1\");\n        departLists.add(\"/top1/ch1/ch2\");\n\n    }\n\n    public static List&lt;String&gt; getFullNames(String departName) {\n        List&lt;String&gt; result = new ArrayList&lt;&gt;();\n        String[] splitNames = departName.split(\"/\");\n        for (int i = 0; i &lt; splitNames.length; i++) {\n            if (!StringUtils.isEmpty(splitNames[i])) {\n                result.add(splitNames[i]);\n            }\n        }\n        return result;\n    }\n\n\n    public List&lt;DepartDTO&gt; getAllDepart() {\n\n        List&lt;DepartDTO&gt; departDTOS = new ArrayList&lt;&gt;();\n        //保存 部门名称和部门ID的映射关系\n        Map&lt;String, String&gt; nameDepartIdMap = new HashMap&lt;&gt;();\n        List&lt;Depart&gt; dbExistDepart = new ArrayList&lt;&gt;();\n        List&lt;Depart&gt; newDeparts = new ArrayList&lt;&gt;();\n\n        for (String single : departLists) {\n            //全部的部门名称\n            List&lt;String&gt; fullNames = getFullNames(single);\n            //直接父级\n            String parentPath = PathUtils.getParentPath(single);\n            //处理顶级的部门数据【只有自己本身，比如 \"/总裁办\"】\n            if (StringUtils.isEmpty(parentPath)) {\n                //1、说明当前只有一级，即顶级数据\n                //2、如果是顶级数据，则需要判断数据库是否存在，如果已经存在，不用管，如果不存在，生成新的相关数据\n                Depart depart = departDao.getTopDepartByName(fullNames.get(0));\n                if (depart != null) {\n                    nameDepartIdMap.put(fullNames.get(0), depart.getDepartId());\n                    //确认数据库已经存在过的，后面只需要新建部门与用户的关系即可\n                    dbExistDepart.add(depart);\n                    continue;\n                }\n                //如果数据不存在，新生成\n                String departId = random();\n                Depart newDepart = new Depart();\n                newDepart.setDepartId(departId);\n                newDepart.setName(fullNames.get(0));\n                newDepart.setPid(\"0\");\n                newDepart.setPath(DepartUtils.getNextPath(tenantId, \"0\"));\n                TransactionStatus transaction = transactionUtils.getTransaction();\n                try {\n                    departDao.insert(newDepart);\n                    //设置手动提交事务\n                    dataSourceTransactionManager.commit(transaction);\n                } catch (Exception e) {\n                    dataSourceTransactionManager.rollback(transaction);\n                }\n                newDeparts.add(newDepart);\n                nameDepartIdMap.put(fullNames.get(0), departId);\n                continue;\n            }\n\n            //如果是非顶级的，则需要拆开  /产品研发中心/技术中台部/产品A组\n            for (int i = 0; i &lt; fullNames.size(); i++) {\n                String currentDepart = fullNames.get(i);\n                //遍历的时候从顶级开始\n                if (nameDepartIdMap.containsKey(currentDepart))\n                    continue;\n\n                if (i == 0) {\n                    TransactionStatus transaction = transactionUtils.getTransaction();\n                    //仍然是顶级，需要先查数据库\n                    Depart topDepart = departDao.getTopDepartByName(currentDepart);\n                    if (topDepart != null) {\n                        nameDepartIdMap.put(fullNames.get(0), topDepart.getDepartId());\n                        dbExistDepart.add(topDepart);\n                    } else {\n                        //如果数据不存在，新生成\n                        String departId = random();\n                        Depart _depart = new Depart();\n                        _depart.setDepartId(departId);\n                        _depart.setName(fullNames.get(0));\n                        _depart.setTenantId(tenantId);\n                        _depart.setPid(\"0\");\n                        _depart.setPath(DepartUtils.getNextPath(tenantId, \"0\"));\n                        try {\n                            departDao.insert(_depart);\n                            //设置手动提交事务\n                            dataSourceTransactionManager.commit(transaction);\n                        } catch (Exception e) {\n                            dataSourceTransactionManager.rollback(transaction);\n                        }\n                        if (fullNames.size() == 1) {\n                            newDeparts.add(_depart);\n                        }\n                    }\n                    continue;\n                }\n                //处理其他层级数据\n                String parentName = parentPath.substring(parentPath.lastIndexOf(\"/\") + 1);\n                //开启一个新的事务\n                TransactionStatus transaction = transactionUtils.getTransaction();\n                //判断自身是否已经存在了\n                Depart dbCurrentDepart = departDao.getDepartByNameAndPid(currentDepart, nameDepartIdMap.get(parentName));\n                if (dbCurrentDepart != null) {\n                    //如果已经存在了，直接跳过\n                    dbExistDepart.add(dbCurrentDepart);\n                    nameDepartIdMap.put(currentDepart, dbCurrentDepart.getDepartId());\n                    dataSourceTransactionManager.commit(transaction);\n                    continue;\n                }\n\n                Depart _depart = new Depart();\n                _depart.setTenantId(tenantId);\n                String departId = random();\n                _depart.setDepartId(departId);\n                _depart.setName(currentDepart);\n                String pid = nameDepartIdMap.get(parentName);\n\n                //判断上级部门在数据库是否真的存在\n                Depart directParent = departDao.getDepartById(nameDepartIdMap.get(parentName));\n\n                boolean isCurrentDepartDbExist = false;\n                if (directParent != null) {\n                    _depart.setPid(pid);\n                    String nextPath = DepartUtils.getNextPath(tenantId, pid);\n                    _depart.setPath(nextPath);\n                    departDao.insert(_depart);\n                    dataSourceTransactionManager.commit(transaction);\n                    //父级存在时\n                    nameDepartIdMap.put(currentDepart, departId);\n                }\n\n                //如果是最后的那一个，才是本次实际要关联的部门数据\n                if (i == fullNames.size() - 1) {\n                    if (isCurrentDepartDbExist) {\n                        dbExistDepart.add(_depart);\n                        nameDepartIdMap.put(currentDepart, departId);\n                        continue;\n                    }\n                    newDeparts.add(_depart);\n                    nameDepartIdMap.put(currentDepart, departId);\n                }\n            }\n        }\n        return departDTOS;\n    }\n\n\n    public static String random() {\n        return UUID.randomUUID().toString().replaceAll(\"-\", \"\");\n    }\n}\n</code></pre>\n<p></p>\n<p>在代码编写过程中，有一个比较难处理的问题，就是在读取外部数据，组装depart 的path的时候，为什么这么讲呢？</p>\n<p>要知道，根据上面描述的两种实现情况，path 可能需要动态组装而成，很多同学可能会说，可以先把depart对象全部组装完成，最后再通过层级关系构建出 path 的完整路径；</p>\n<p>事实上，一开始我也是这么想的，但是最终发现这样走不通，原因就在于 顶级部门 “/产品研发中心”在数据库中可能存在，也可能不存在，而 path的生成一定是需要结合数据库的某些业务字段动态查询而构造出来的；</p>\n<p>所以如果先组装完成数据再构建path，这样带来的问题复杂性将会大大增加；</p>\n<p>那么比较可行的而且可以实现的方式就是，在组装数据的过程中，动态查库进行组装数据；</p>\n<p>但是小编在编码的时候发现，如果使用springboot工程自身的事务管理器的话，无论是哪种事务隔离级别，都将无法满足这样一个需求，即 “前一步将父级部门数据插入，子部门能够查到父级的数据”这样一个问题；</p>\n<p>所以为了达到这个目的，这里采用了 jdbc 手动管理事务的方式进行；</p>\n<p></p>\n<p>那么通过上面的方式，就可以实现层级数据的导入效果了，具体逻辑可以参考注释说明进行理解；</p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>\n</div>\n</div>"}