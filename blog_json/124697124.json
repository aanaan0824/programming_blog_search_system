{"blogid": "124697124", "writerAge": "码龄3年", "writerBlogNum": "102", "writerCollect": "111", "writerComment": "5", "writerFan": "93", "writerGrade": "4级", "writerIntegral": "1078", "writerName": "@seven@", "writerProfileAdress": "writer_image\\profile_124697124.jpg", "writerRankTotal": "17804", "writerRankWeekly": "34393", "writerThumb": "33", "writerVisitNum": "50745", "blog_read_count": "1823", "blog_time": "于 2022-05-17 14:07:47 发布", "blog_title": "ubuntu下protobuf安装使用（详解）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h1>1.安装</h1>\n<h2>1.1安装前的环境</h2>\n<p>以下几个库都有安装</p>\n<blockquote>\n<p>sudo apt-get install autoconf automake libtool curl make g++ unzip</p>\n</blockquote>\n<h2>1.2安装</h2>\n<p><span style=\"color:#fe2c24;\">注意</span>：以下命令在<span style=\"color:#fe2c24;\">超级用户</span>下执行</p>\n<blockquote>\n<p> sudo apt-get install autoconf automake libtool curl make g++ unzip<br/>  git clone https://github.com/google/protobuf.git #安装子模块<br/>  cd protobuf<br/>  git submodule update --init --recursive<br/>  ./autogen.sh<br/>  ./configure<br/>  make<br/>   # 如果没有克隆子模块，make check会失败但是可以继续make install,但是使用某些功能时可能会出错</p>\n<p>make check<br/>  sudo make install<br/>  sudo ldconfig # refresh shared library cache.</p>\n</blockquote>\n<h2>1.2.1安装完成之后，配置protobuf命令 </h2>\n<blockquote>\n<p>更改环境变量：<br/> vim /etc/profile<br/> 在文件的末尾添加如下的两行:<br/> export PATH=$PATH:/usr/local/protobuf/bin/<br/> export PKG_CONFIG_PATH=/usr/local/protobuf/lib/pkgconfig/<br/><br/> 更改完成之后，执行如下命令立即执行：</p>\n</blockquote>\n<blockquote>\n<p>source /etc/profile<br/><br/> 这一步是必须的，因为如果少了这一步，会出现找不到protoc的命令错误。</p>\n</blockquote>\n<blockquote>\n<p>配置动态链接库<br/> vim /etc/ld.so.conf<br/> 在文件中添加/usr/local/protobuf/lib（注意: 在新行处添加）<br/><br/> 更改完成之后，执行如下命令立即执行：</p>\n</blockquote>\n<blockquote>\n<p>ldconfig</p>\n</blockquote>\n<h2>1.3.安装成功</h2>\n<blockquote>\n<p>protoc --version</p>\n</blockquote>\n<p></p>\n<h2>1.4.卸载</h2>\n<blockquote>\n<pre><code>sudo apt-get remove libprotobuf-dev</code></pre>\n<p></p>\n</blockquote>\n<h1>2.如何使用ProtoBuf </h1>\n<p>创建Person.proto文件，这里主要定义协议</p>\n<pre><code>syntax=\"proto3\";\npackage tutorial;\nmessage Person\n{\n\tstring name = 1;\n\tint32 id = 2;\n\tstring email = 3;\n \n\tenum PhoneType\n\t{\n\t\tMOBILE = 0;\n\t\tHOME = 1;\n\t\tWORK = 2;\n\t}\n \n\tmessage PhoneNumber\n\t{\n\t\tstring number = 1;\n\t\tPhoneType type = 2; \n\t}\n \n\trepeated PhoneNumber phone = 4;\n}\n \nmessage AddressBook\n{\n\trepeated Person person =1;\n}\n</code></pre>\n<p> 现在将定义的协议转化为我们编程语言能够识别的文件</p>\n<pre><code>#查看里面的命令\nprotoc --help\n#输出文件\n protoc Person.proto --cpp_out=.\n</code></pre>\n<p><img alt=\"\" height=\"806\" src=\"image\\0052e4bbcf34461db881574008412986.png\" width=\"1001\"/> </p>\n<p> </p>\n<p> 然后定义一个源文件，用来测试</p>\n<p>main.cpp</p>\n<pre><code>#include \"Person.pb.h\"\n#include &lt;fstream&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n \nvoid PromptForAddress(tutorial::Person*);\n \nint main(int argc, char* argv[])\n{\n\tGOOGLE_PROTOBUF_VERIFY_VERSION;\n\tif(2 != argc)\n\t{\n\t\t//必须指定电话本名称才执行程序\n\t    cerr &lt;&lt; \"Usage:  \" &lt;&lt; argv[0] &lt;&lt; \" ADDRESS_BOOK_FILE\" &lt;&lt; endl;\n\t    return -1;\n\t}\n \n\ttutorial::AddressBook address_book;\n \n\tfstream in(\"ADDRESS_BOOK_FILE\", ios::binary | ios::in);\n\tif(!in)\n\t{\n\t\tcerr &lt;&lt; \"open file ADDRESS_BOOK_FILE failed!\\n\";\n\t\treturn -1;\n\t}\n\t\n\tif(!address_book.ParseFromIstream(&amp;in))\n\t{\n\t\tcerr &lt;&lt; \"Parse File ADDRESS_BOOK_FILE failed!\\n\";\n\t\treturn -1;\n\t}\n\t\n\tin.close();\n\t//增加一个Person，可通过多次调用该接口增加联系人\n\t//具有repeated的属性可通过add_fieldname方法增加一个属性\n\tPromptForAddress(address_book.add_person());\n \n\tfstream out(\"ADDRESS_BOOK_FILE\", ios::binary | ios::out | ios::trunc);\n\tif(!address_book.SerializeToOstream(&amp;out))\n\t{\n\t\tcerr &lt;&lt; \"Failed to Write Address Book!\\n\";\n\t\treturn -1;\t\n\t}\n \n\t//可选的，回收所有ProtoBuf分配的对象\n\tgoogle::protobuf::ShutdownProtobufLibrary();\n\treturn 0;\n}\n \n \nvoid PromptForAddress(tutorial::Person* person)\n{\n\tcout&lt;&lt;\"Enter a Person ID number: \";\n\tint id;\n\tcin &gt;&gt; id;\n\tperson-&gt;set_id(id);\n\t/*忽略CIN的前256个字符，或者忽略CIN的换行符之前的字符，包括换行符\n\t这样的话不会将换行符之前的其他类型的数据保留在输入缓冲中\t\n\t*/\n\tcin.ignore(256, '\\n');\n\tcout&lt;&lt;\"Enter name: \";\n\tgetline(cin, *person-&gt;mutable_name());\n \n\tcout&lt;&lt; \"Enter email address (blank for none): \";\n\tstring email;\n\tgetline(cin,email);\n\tif(!email.empty())\n\t\tperson-&gt;set_email(email);\n\twhile(true)\n\t{\n\t\tcout&lt;&lt;\"Enter a phone number (or leave blank to finish): \";\n\t\tstring number;\n\t\tgetline(cin, number);\n\t\tif(number.empty())\n\t\t\tbreak;\n\t\ttutorial::Person::PhoneNumber* phone_number = person-&gt;add_phone();\n\t\tphone_number-&gt;set_number(number);\n \n\t\tcout&lt;&lt;\"Is this a mobile, home, or work phone? \";\n\t\tstring type;\n\t\tgetline(cin, type);\n\t\tif(type == \"mobile\")\n\t\t\tphone_number-&gt;set_type(tutorial::Person::MOBILE);\n\t\telse if( type == \"home\")\n\t\t\tphone_number-&gt;set_type(tutorial::Person::HOME);\n\t\telse if (type == \"work\")\n\t\t\tphone_number-&gt;set_type(tutorial::Person::WORK);\n\t\telse\n\t\t{\n\t\t\tcout &lt;&lt; \"Unknown phone type.  Using default.\" &lt;&lt; endl;\n\t\t\tphone_number-&gt;set_type(tutorial::Person::HOME);\n\t\t}\n\t\t\n\t}\n\t\n}</code></pre>\n<p> 然后编译即可，但是编译千万不要忘记加库</p>\n<pre><code> g++ main.cpp Person.pb.cc -lprotobuf\n</code></pre>\n<p></p>\n</div>\n</div>"}