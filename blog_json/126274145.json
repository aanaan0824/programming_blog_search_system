{"blogid": "126274145", "writerAge": "码龄2年", "writerBlogNum": "70", "writerCollect": "3155", "writerComment": "3022", "writerFan": "12179", "writerGrade": "6级", "writerIntegral": "8026", "writerName": "程序猿追", "writerProfileAdress": "writer_image\\profile_126274145.jpg", "writerRankTotal": "1707", "writerRankWeekly": "74", "writerThumb": "2787", "writerVisitNum": "110935", "blog_read_count": "1162", "blog_time": "已于 2022-08-10 21:03:10 修改", "blog_title": "【算法合集】学习算法第三天（二叉树遍历篇）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<blockquote>\n<p>✅🎡个人主页：<a href=\"https://blog.csdn.net/aasd23?spm=1000.2115.3001.5343\" title=\"程序猿追\">程序猿追</a></p>\n<p>✅🎡系列专栏：<a href=\"https://blog.csdn.net/aasd23/category_11805404.html?spm=1001.2014.3001.5482\" title=\"算法合集\">算法合集</a></p>\n<p>✅🎡目前状态：创建Java学习之路（零基础到就业实战）系列，目前更新到JAVAWEB开发</p>\n<p>✅🎡作者简介：大家好，我是程序猿追，全栈领域新星创作者，算法爱好者，常在作者周榜排名前30，某不知名的 ACMer</p>\n<p>✅🎡推荐一款刷题面试找工作三不误的网站——<a href=\"https://www.nowcoder.com/link/pc_csdncpt_cxyz_sf\" title=\"牛客网\">牛客网</a></p>\n<p>✅🎡个人名言：不积跬步无以至千里，趁年轻，使劲拼，给未来的自己一个交代！</p>\n</blockquote>\n<p></p>\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86\">二叉树的前序遍历</a></p>\n<p id=\"%E9%A2%98%E8%A7%A3%E4%BB%A3%E7%A0%81-toc\" style=\"margin-left:40px;\"><a href=\"#%E9%A2%98%E8%A7%A3%E4%BB%A3%E7%A0%81\">题解代码</a></p>\n<p id=\"%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86\">二叉树的中序遍历</a></p>\n<p id=\"%C2%A0%E9%A2%98%E8%A7%A3%E4%BB%A3%E7%A0%81-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A0%E9%A2%98%E8%A7%A3%E4%BB%A3%E7%A0%81\"> 题解代码</a></p>\n<p id=\"%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86\">二叉树的后序遍历</a></p>\n<p id=\"%E9%A2%98%E8%A7%A3%E4%BB%A3%E7%A0%81-toc\" style=\"margin-left:40px;\"><a href=\"#%E9%A2%98%E8%A7%A3%E4%BB%A3%E7%A0%81\">题解代码</a></p>\n<p id=\"%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-toc\" style=\"margin-left:0px;\"><a href=\"#%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86\">求二叉树的层序遍历</a></p>\n<p id=\"%E9%A2%98%E8%A7%A3%E4%BB%A3%E7%A0%81-toc\" style=\"margin-left:40px;\"><a href=\"#%E9%A2%98%E8%A7%A3%E4%BB%A3%E7%A0%81\">题解代码</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<p></p>\n<h1 id=\"%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86\">二叉树的前序遍历</h1>\n<blockquote>\n<p><strong>描述</strong></p>\n<p>给你二叉树的根节点 root ，返回它节点值的 前序<em> </em>遍历。</p>\n<p>数据范围：二叉树的节点数量满足 0≤n≤100  ，二叉树节点的值满足1≤val≤100  ，树的各节点的值各不相同</p>\n</blockquote>\n<blockquote>\n<p>示例1： </p>\n<p><img alt=\"\" height=\"229\" src=\"image\\632526253f35454e918e1d334d757560.png\" width=\"189\"/></p>\n<p></p>\n</blockquote>\n<p></p>\n<blockquote>\n<p><strong>输入：</strong></p>\n<pre>{1,#,2,3}</pre>\n<p><strong>返回值：</strong></p>\n<pre>[1,2,3]</pre>\n</blockquote>\n<h2 id=\"%E9%A2%98%E8%A7%A3%E4%BB%A3%E7%A0%81\">题解代码</h2>\n<pre><code class=\"language-java\">import java.util.*;\npublic class Solution {\n    public void preorder(List&lt;Integer&gt; list, TreeNode root){\n        //遇到空节点则返回 fast-template\n        if(root == null)\n            return;\n        //先遍历根节点\n        list.add(root.val);\n        //再去左子树\n        preorder(list, root.left);\n        //最后去右子树\n        preorder(list, root.right);\n    }\n    public int[] preorderTraversal (TreeNode root) {\n        //添加遍历结果的数组\n        List&lt;Integer&gt; list = new ArrayList();\n        //递归前序遍历\n        preorder(list, root);\n        //返回的结果\n        int[] res = new int[list.size()];\n        for(int i = 0; i &lt; list.size(); i++)\n            res[i] = list.get(i);\n        return res;}\n}</code></pre>\n<h1 id=\"%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86\">二叉树的中序遍历</h1>\n<blockquote>\n<p><strong>描述</strong></p>\n<p>给定一个二叉树的根节点root，返回它的中序遍历结果。</p>\n<p></p>\n<p>数据范围：树上节点数满足0≤n≤1000，树上每个节点的值满足 0≤val≤1000<br/> 进阶：空间复杂度 O(n)，时间复杂度 O(n)</p>\n</blockquote>\n<p><strong>示例1</strong></p>\n<blockquote>\n<p><strong>输入：</strong></p>\n<pre>{1,2,#,#,3}</pre>\n<p><strong>返回值：</strong></p>\n<pre>[2,3,1]\n</pre>\n<p>说明：</p>\n<pre>\n</pre>\n</blockquote>\n<p></p>\n<blockquote>\n<p>示例2</p>\n<p><strong>输入：</strong></p>\n<p>{}</p>\n<p><strong>返回值：</strong></p>\n<p>[]</p>\n<p>示例3</p>\n<p><strong>输入：</strong></p>\n<p>{1,2}</p>\n<p><strong>返回值：</strong></p>\n<p>[2,1]</p>\n<p><strong>说明：</strong></p>\n<p>示例4</p>\n<p><strong>输入：</strong></p>\n<p>{1,#,2}</p>\n<p><strong>返回值：</strong></p>\n<p>[1,2]</p>\n</blockquote>\n<h2 id=\"%C2%A0%E9%A2%98%E8%A7%A3%E4%BB%A3%E7%A0%81\"> 题解代码</h2>\n<pre><code class=\"language-java\">import java.util.*;\npublic class Solution {\n    public void inorder(List&lt;Integer&gt; list, TreeNode root){\n        //遇到空节点则返回 fast-template\n        if(root == null)\n            return;\n        //先去左子树\n        inorder(list, root.left);\n        //再访问根节点\n        list.add(root.val);\n        //最后去右子树\n        inorder(list, root.right);\n    }\n    public int[] inorderTraversal (TreeNode root) {\n         //添加遍历结果的数组\n        List&lt;Integer&gt; list = new ArrayList();\n        //递归中序遍历\n        inorder(list, root);\n        //返回的结果\n        int[] res = new int[list.size()];\n        for(int i = 0; i &lt; list.size(); i++)\n            res[i] = list.get(i);\n        return res;}\n}</code></pre>\n<h1 id=\"%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86\">二叉树的后序遍历</h1>\n<blockquote>\n<p><strong>描述</strong></p>\n<p>给定一个二叉树，返回他的后序遍历的序列。</p>\n<p>后序遍历是值按照 左节点-&gt;右节点-&gt;根节点 的顺序的遍历。</p>\n<p>数据范围：二叉树的节点数量满足0≤n≤100  ，二叉树节点的值满足 11≤val≤100  ，树的各节点的值各不相同</p>\n<p></p>\n<p><strong>样例图</strong></p>\n<p><img alt=\"\" height=\"214\" src=\"image\\6ea92b9215cb4ba89da209a4765f7578.png\" width=\"323\"/></p>\n<p></p>\n<p></p>\n<p>示例1</p>\n<p><strong>输入：</strong></p>\n<pre>{1,#,2,3}</pre>\n<p><strong>返回值：</strong></p>\n<pre>[3,2,1]\n</pre>\n<p><strong>说明：</strong></p>\n<pre>如题面图   </pre>\n<p>示例2</p>\n<p><strong>输入：</strong></p>\n<pre>{1}</pre>\n<p><strong>返回值：</strong></p>\n<pre>[1]</pre>\n</blockquote>\n<h2>题解代码</h2>\n<pre><code class=\"language-java\">import java.util.*;\npublic class Solution {\n    public void postorder(List&lt;Integer&gt; list, TreeNode root){\n        //遇到空节点则返回 fast-template\n        if(root == null)\n            return;\n         //先去左子树\n        postorder(list, root.left);\n        //再去右子树\n        postorder(list, root.right);\n        //最后访问根节点\n        list.add(root.val);\n    }\n    public int[] postorderTraversal (TreeNode root) {\n        //添加遍历结果的数组\n        List&lt;Integer&gt; list = new ArrayList();\n        //递归后序遍历\n        postorder(list, root);\n        //返回的结果\n        int[] res = new int[list.size()];\n        for(int i = 0; i &lt; list.size(); i++)\n            res[i] = list.get(i);\n        return res;}\n}</code></pre>\n<h1 id=\"%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86\">求二叉树的层序遍历</h1>\n<p>描述</p>\n<blockquote>\n<p>给定一个二叉树，返回该二叉树层序遍历的结果，（从左到右，一层一层地遍历）<br/> 例如：<br/> 给定的二叉树是{3,9,20,#,#,15,7},<br/><img alt=\"\" height=\"219\" src=\"image\\29e445f5bb70484eaaa9ec06409f246d.png\" width=\"267\"/><br/> 该二叉树层序遍历的结果是<br/> [<br/> [3],<br/> [9,20],<br/> [15,7] </p>\n<p>]</p>\n<p>数据范围：二叉树的节点数满足 1≤n≤105 </p>\n<p></p>\n<p>示例1</p>\n<p><strong>输入：</strong></p>\n<p>{1,2}<br/><strong>返回值：</strong><br/> [[1],[2]]</p>\n<p>示例2</p>\n<p><strong>输入：</strong></p>\n<p>{1,2,3,4,#,#,5}</p>\n<p><strong>返回值：</strong></p>\n<p>[[1],[2,3],[4,5]]</p>\n</blockquote>\n<h2>题解代码</h2>\n<pre><code class=\"language-java\">import java.util.*;\npublic class Solution {\n    public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; levelOrder (TreeNode root) {\n        ArrayList&lt;ArrayList&lt;Integer&gt; &gt; res = new ArrayList();\n        if(root == null)\n            //如果是空，则直接返回空数组 fast-template\n            return res;\n        //队列存储，进行层次遍历\n        Queue&lt;TreeNode&gt; q = new ArrayDeque&lt;TreeNode&gt;();\n        q.add(root);\n        while(!q.isEmpty()){\n            //记录二叉树的某一行\n            ArrayList&lt;Integer&gt; row = new ArrayList();\n            int n = q.size();\n            //因先进入的是根节点，故每层结点多少，队列大小就是多少\n            for(int i = 0; i &lt; n; i++){\n                TreeNode cur = q.poll();\n                row.add(cur.val);\n                //若是左右孩子存在，则存入左右孩子作为下一个层次\n                if(cur.left != null)\n                    q.add(cur.left);\n                if(cur.right != null)\n                    q.add(cur.right);\n            }\n            //每一层加入输出\n            res.add(row);\n        }\n        return res;}\n}</code></pre>\n<p></p>\n<blockquote>\n<p>算法对程序员来说及其重要，语言和开发平台不断变化，但是万变不离其宗的是那些算法和理论，依稀记得我那个玩的很好的一个学长（在大二就拿到了 offer），他告诉我想找一个好的工作，那刷题一定是必不可少的</p>\n<p>现在算法刷题平台还是蛮多的，给大家介绍一个我认为与大厂关联最深的平台——<a href=\"https://www.nowcoder.com/link/pc_csdncpt_cxyz_sf\" title=\"牛客网\">牛客网</a></p>\n</blockquote>\n<p></p>\n</div>\n</div>"}