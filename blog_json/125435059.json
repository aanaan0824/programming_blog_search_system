{"blogid": "125435059", "writerAge": "码龄7年", "writerBlogNum": "19", "writerCollect": "56", "writerComment": "19", "writerFan": "19", "writerGrade": "2级", "writerIntegral": "249", "writerName": "白开水儿", "writerProfileAdress": "writer_image\\profile_125435059.jpg", "writerRankTotal": "70743", "writerRankWeekly": "168645", "writerThumb": "32", "writerVisitNum": "14828", "blog_read_count": "1259", "blog_time": "已于 2022-06-29 12:18:38 修改", "blog_title": "C、C++ 对于char*和char[]的理解", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"style.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<h1> 1、char*和char[]的共同点</h1>\n<p>都是指针，指向第一个字符所在的地址</p>\n<h1>2、char*的用法</h1>\n<div>\n<pre><code class=\"language-cpp\">char a[] = \"aaa\";\nchar* p1 = a;  //char*是常量指针（常量的指针），刚好a就是个指针常量。\nchar* p2 = \"ppp\"; //不建议\nconst char* p2 = \"ppp\";//等效于 char const* p2 = \"ppp\";</code></pre>\n</div>\n<p>char*是一个常量指针（常量的指针），即它指向的内存中的内容不能发生改变，但它可以改变自身的指向。</p>\n<p>另外，不加const，直接将一个常量字符串赋值给char*是有隐患的（即char*p = \"ppp\"），它会做如下的操作：</p>\n<p>1、在栈区开辟内存放char* p。</p>\n<p>2、在文字常量区（即常量存储区）开辟内存放\"ppp\"。</p>\n<p>3、将\"ppp\"中第一个字符的内存地址赋值给p。</p>\n<p>崩溃隐患：当编译strcmp(p, \"hello\");时系统不会报错，因为符合第一个参数char*第二个参数const char*的参数限制。实际运行时，系统将试图修改文字常量区的内容，而文字常量区属于只读区，进而引发崩溃。若加上const就会避免它进入该类函数哈哈~</p>\n<p>如果一定要改变值，应该写char* p  = \"ccc\";改变p在文字常量区的指向。</p>\n<p><img alt=\"\" src=\"image\\07e742bb84d14b6995fe265ab4e9aa4c.png\"/>​</p>\n<h1> 3、char[]的用法</h1>\n<div>\n<pre><code class=\"language-cpp\">//char[]\nchar a[20] = \"aaa\";\nchar b[] = \"bbbbb\";\nchar c[] = {'s','t','r','i','n','g','\\0'};\nchar d[] = {\"dddd\"};\n\n//一般这样初始化\nchar num[20] = {0};\n//初始化的目的是为了添加\\0，否则\\0会跑到莫名其妙的地方导致很多错误。\n//ASCII码中0对应的是nul符，即\\0。这一行的意义就是给0~19都赋\\0。</code></pre>\n</div>\n<p>第一行中，\"aaa\"中的每一个字符分别赋值给数组中的每一个元素并存储在栈上，数组位置不够的字符以\"\\0\"填充，且a[19]一定是\"\\0\"。 </p>\n<p>另外，由于char[]是一个指针常量，它等同于<code>char *const a(但这玩意儿不能用于读入，暂时理解是没有指定长度)，</code>因此指针中所保存的地址不能发生变化，下面的写法就是错误的。</p>\n<div>\n<pre><code class=\"language-cpp\">char a[] = \"aaa\";\na = \"hello\"; // \"hello\"会在文字常量区开辟一片新内存</code></pre>\n</div>\n<p>应该改变地址内保存的值</p>\n<div>\n<pre><code class=\"language-cpp\">a[0] = 'b';</code></pre>\n</div>\n<h1>4、怎么输出char*地址</h1>\n<p>虽然指针名就代表的是地址，但在输出时需要加&amp;，仅限cout。</p>\n<p>C++：</p>\n<div>\n<pre><code class=\"language-cpp\">const char* p = \"ppp\"; \ncout&lt;&lt;&amp;p&lt;&lt;endl; //地址 方法一\ncout&lt;&lt;(void*)p&lt;&lt;endl;//地址 方法二\ncout&lt;&lt;p&lt;&lt;endl; //ppp\n</code></pre>\n</div>\n<p>C:</p>\n<pre><code>const char* a = \"ppp\";\nprintf(\"%p \\n\", a); //16进制地址，不过 %p的输出格式并不统一，有的编译器带0x前缀，有的不带\nprintf(\"%#X \\n\", a);//16进制地址，前缀统一是0x\nprintf(\"%s \\n\", a);  //ppp</code></pre>\n<h1>5、strlen和sizeof</h1>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:571px;\"><tbody><tr><td style=\"width:105px;\"></td><td style=\"width:185px;\">sizeof</td><td style=\"width:280px;\">strlen</td></tr><tr><td style=\"width:105px;\">性质</td><td style=\"width:185px;\">运算符</td><td style=\"width:280px;\">函数</td></tr><tr><td style=\"width:105px;\">功能</td><td style=\"width:185px;\">以字节为单位计算操作数占用的内存大小</td><td style=\"width:280px;\">计算字符串的长度（strlen函数遇到\\0就会停止下来，返回\\0前出现的字符个数，不包括\\0）</td></tr><tr><td style=\"width:105px;\">时间</td><td style=\"width:185px;\">编译时</td><td style=\"width:280px;\">运行时</td></tr><tr><td style=\"width:105px;\">参数</td><td style=\"width:185px;\">类型/各种object</td><td style=\"width:280px;\">const char*\\char*\\char[]</td></tr><tr><td style=\"width:105px;\">返回值</td><td style=\"width:185px;\">size_t</td><td style=\"width:280px;\">size_t</td></tr><tr><td style=\"width:105px;\">头文件</td><td style=\"width:185px;\">运算符没有头文件</td><td style=\"width:280px;\">string.h</td></tr></tbody></table>\n<p>ps：</p>\n<p>(1)它们返回的都是size_t，这是一种记录操作数大小的数据类型，属于无符号长整型，因此不要用减法比较返回值，因为结果始终是无符号长整型（非负数）。</p>\n<p>(2)sizeof常用参数一览</p>\n<pre><code class=\"language-cpp\">struct test{\n    int num;\n}\nint a;\nsizeof(int);\nsizeof(a);\nsizeof(test);//sizeof(struct test);\nsizeof(fun());//该函数必须有返回值</code></pre>\n<p>(3)sizeof的主要功能是参与存储分配，例如：</p>\n<pre><code class=\"language-cpp\">void* malloc(size_t size);\nsize_t fread(void* ptr, size_t size, size_t nmemb, FILE* stream);\nvoid* memset(void* s, int c, sizeof(s));</code></pre>\n<h1>6、char*和string</h1>\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px;\"><tbody><tr><td style=\"width:90px;\">区别</td><td style=\"width:193px;\">string</td><td style=\"width:216px;\">char*</td></tr><tr><td style=\"width:90px;\">本质</td><td style=\"width:193px;\">STL中的一个容器，string封装了char*。</td><td style=\"width:216px;\">指针</td></tr><tr><td style=\"width:90px;\">内存管理</td><td style=\"width:193px;\">由系统管理，除非系统内存池用完，否则不会出现内存问题</td><td style=\"width:216px;\">栈/堆，如果是堆需要手动释放</td></tr></tbody></table>\n<p>string和const char*互转</p>\n<pre><code class=\"language-cpp\">//string转const char*\n#include &lt;string&gt;\nstring s = \"sss\";\nconst char* c = s.c_str();\n\n//const char*转string\nconst char* c = \"ppp\";\nstring s = c;</code></pre>\n<p>string和char*互转</p>\n<pre><code class=\"language-cpp\">//string转char*\n#include &lt;string&gt;\nstring str = \"string\";\n//法一\nchar* chr = const_cast&lt;char*&gt;(str.c_str());\n//法二\nchar *cstr = &amp;str[0];\n\n\n//char*转string\nchar* c = \"ppp\";\nstring s = c;</code></pre>\n<h1>7、赋NULL时究竟在做什么</h1>\n<p>C++：</p>\n<pre><code class=\"language-cpp\">/* Define NULL pointer value */\n#ifndef NULL\n    #ifdef __cplusplus\n        #define NULL    0\n    #else  /* __cplusplus */\n        #define NULL    ((void *)0)\n    #endif  /* __cplusplus */\n#endif  /* NULL */</code></pre>\n<p>C：</p>\n<pre><code>#define NULL    ((void *)0)</code></pre>\n<h1>小结</h1>\n<p>1、const在*前修饰指定的类型，const在*之后修饰指针。</p>\n<p>2、 读入只能是char []，因为读入需要明确的地址，注意必须标定长度。</p>\n<p>        改值还得是char*，因为方便。</p>\n<div>\n<pre><code class=\"language-cpp\">//一般读入\nchar num[20];//必须标定长度\ncin&gt;&gt;num;\nscanf(\"%s\", num);\n\n//还可以这样读入\nchar num[20];//必须标定长度\nchar* p = num;\ncin&gt;&gt;p;</code></pre>\n</div>\n<p>3、char[]在运行时刻赋值，char*在编译时刻赋值</p>\n<p>参考文章：</p>\n<p><a class=\"has-card\" href=\"https://blog.csdn.net/bitcarmanlee/article/details/124166842\" title=\"char * 与char []区别总结_bitcarmanlee的博客-CSDN博客_char和char*的区别\"><span class=\"link-card-box\"><span class=\"link-title\">char * 与char []区别总结_bitcarmanlee的博客-CSDN博客_char和char*的区别</span><span class=\"link-desc\">1.先上结论c++代码里头经常见到char * 与char []的写法，这两种写法都可以表示一个字符串。比如：void charcode() { char* a = \"c1\"; char b[] = \"c2\"; printf(\"a=%s, b=%s\", a, b);}上面这段代码，最后输出的结果为a=c1, b=c2所以这两种方式都可以表示字符串，那么区别到底是什么？我们先说结论，后面再来分析：char * 这种方式表示常量指针，char[] 这种表示指针常量！2</span><span class=\"link-link\"><img alt=\"\" class=\"link-link-icon\" src=\"https://g.csdnimg.cn/static/logo/favicon32.ico\"/>https://blog.csdn.net/bitcarmanlee/article/details/124166842</span></span></a><a class=\"has-card\" href=\"https://blog.csdn.net/Jing_JiaNan/article/details/121170349\" title=\"char数组的地址怎么输出_JINGpuzzle的博客-CSDN博客_char数组的地址\"><span class=\"link-card-box\"><span class=\"link-title\">char数组的地址怎么输出_JINGpuzzle的博客-CSDN博客_char数组的地址</span><span class=\"link-desc\">对于int这样的数据类型如int num[3];cout&lt;&lt;num&lt;&lt;endl;输出第一个元素的地址cout&lt;&lt;&amp;num[1]&lt;&lt;endl;输出第二个元素的地址但是我们知道char字符串数组会比较特殊我们先来看这样一个例子按理说数组名不就应该是数组的第一个元素的地址吗，为什么他把整个字符串都给输出了？好，下面我们再来看一个例子因此我们可以得出这样的答案，cout在遇到char的指针时，会输出整个字符串，直..</span><span class=\"link-link\"><img alt=\"\" class=\"link-link-icon\" src=\"https://g.csdnimg.cn/static/logo/favicon32.ico\"/>https://blog.csdn.net/Jing_JiaNan/article/details/121170349</span></span></a><a class=\"has-card\" href=\"https://blog.csdn.net/qq_32103261/article/details/80221014\" title=\"c++指针（一）——指针的定义以及写法_大豆木南的博客-CSDN博客_c++定义指针\"><span class=\"link-card-box\"><span class=\"link-title\">c++指针（一）——指针的定义以及写法_大豆木南的博客-CSDN博客_c++定义指针</span><span class=\"link-desc\">本系列讲述指针的文章一共分为六篇文章目录如下：一、c++中指针的定义以及写法二、定义变量时的内存分配三、指针与数组名的关系四、常量指针与常量指针五、指针的指针六、指针和引用好了，按照这个顺序开启探索c++指针之旅~一、c++中指针的定义int *p; //*号前有空格，可以是任意个空格int* p; //*号后有空格，可以是任意个空格int*p; //*号前后都没有空格int * p; //...</span><span class=\"link-link\"><img alt=\"\" class=\"link-link-icon\" src=\"https://g.csdnimg.cn/static/logo/favicon32.ico\"/>https://blog.csdn.net/qq_32103261/article/details/80221014</span></span></a></p>\n</div>\n</div>"}