<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<blockquote>
<p><strong>题目地址：</strong></p>
<blockquote>
<p><strong> 传送门</strong>： <a href="https://www.nowcoder.com/link/pc_csdncpt_qing_java" title="牛客网 - 找工作神器|笔试题库|面试经验|实习招聘内推，求职就业一站解决_牛客网">牛客网 - 找工作神器|笔试题库|面试经验|实习招聘内推，求职就业一站解决_牛客网</a></p>
</blockquote>
<hr/>
</blockquote>
<p><strong>Java面试练习题刷题记录</strong></p>
<p id="main-toc"><strong>目录</strong></p>
<p id="%E4%B8%80%E3%80%81%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC">一、最大差值</a></p>
<p id="%E4%BA%8C%E3%80%81%E6%A3%8B%E5%AD%90%E7%BF%BB%E8%BD%AC-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E6%A3%8B%E5%AD%90%E7%BF%BB%E8%BD%AC">二、棋子翻转</a></p>
<p id="%C2%A0%E4%B8%89%E3%80%81%E6%8B%9C%E8%AE%BF-toc" style="margin-left:0px;"><a href="#%C2%A0%E4%B8%89%E3%80%81%E6%8B%9C%E8%AE%BF"> 三、拜访</a></p>
<p id="%E5%9B%9B%E3%80%81%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%86%85%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%86%85%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2">四、直方图内最大矩形</a></p>
<p id="%E4%BA%94%E3%80%81%E6%80%BB%E7%BB%93-toc" style="margin-left:0px;"><a href="#%E4%BA%94%E3%80%81%E6%80%BB%E7%BB%93">五、总结</a></p>
<hr/>
<h1 id="%E4%B8%80%E3%80%81%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC">一、最大差值</h1>
<h2 id="%E6%8F%8F%E8%BF%B0">描述</h2>
<p>有一个长为 n 的数组 A ，求满足 0 ≤ a ≤ b &lt; n 的 A[b] - A[a] 的最大值。</p>
<p>给定数组 A 及它的大小 n ，请返回最大差值。</p>
<p>数据范围： 2&lt;n≤2∗105 2 &lt; n \le 2*10^5\ 2&lt;n≤2∗105  ，数组中的值满足 0≤∣val∣≤5∗108 0 \le |val| \le 5*10^8 \ 0≤∣val∣≤5∗108 </p>
<blockquote>
<h2 id="%E7%A4%BA%E4%BE%8B1">示例1</h2>
<p>输入：</p>
<pre>[5,1],2</pre>
<p>返回值：</p>
<pre>0
</pre>
<h2 id="%E7%A4%BA%E4%BE%8B2">示例2</h2>
<p>输入：</p>
<pre>[5,6],2</pre>
<p>返回值：</p>
<pre>1
</pre>
</blockquote>
<p>题解：</p>
<pre><code class="language-java">import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param A int整型一维数组 
     * @param n int整型 
     * @return int整型
     */
    public int getDis (int[] A, int n) {
        // write code here
        
        int res = 0;
        int min = Integer.MAX_VALUE;
        for (int i = 0; i &lt; n; i++) {
            min = Math.min(min, A[i]);
            res = Math.max(res, A[i] - min);
        }
        return res;
    }
}
</code></pre>
<hr/>
<h1 id="%E4%BA%8C%E3%80%81%E6%A3%8B%E5%AD%90%E7%BF%BB%E8%BD%AC"><strong>二、棋子翻转</strong></h1>
<h2>描述</h2>
<p>在 4x4 的棋盘上摆满了黑白棋子，黑白两色棋子的位置和数目随机，其中0代表白色，1代表黑色；左上角坐标为 (1,1) ，右下角坐标为 (4,4) 。</p>
<p>现在依次有一些翻转操作，要对以给定翻转坐标(x,y)（也即第x行第y列）为中心的上下左右四个棋子的颜色进行翻转。</p>
<p>给定两个数组 A 和 f ，分别代表 初始棋盘 和 哪些要进行翻转的位置(x,y) ，请返回经过所有翻转操作后的棋盘。</p>
<p></p>
<p>例如输入[[0,0,1,1],[1,0,1,0],[0,1,1,0],[0,0,1,0]],[[2,2],[3,3],[4,4]]时，初始键盘如下图所示：</p>
<p><img alt="" height="320" src="image\e323b5a588dd469c884bac25dd5fe7aa.png" width="327"/></p>
<p> </p>
<p>对应的输出为[[0,1,1,1],[0,0,1,0],[0,1,1,0],[0,0,1,0]]，如下图所示：<br/><img alt="" height="317" src="image\2091f96fad7d4a289c6f5ded687ed93e.png" width="312"/></p>
<h2>示例1</h2>
<blockquote>
<p>输入：</p>
<pre>[[0,0,1,1],[1,0,1,0],[0,1,1,0],[0,0,1,0]],[[2,2],[3,3],[4,4]]</pre>
<p>返回值：</p>
<pre>[[0,1,1,1],[0,0,1,0],[0,1,1,0],[0,0,1,0]]
</pre>
</blockquote>
<p>题解：</p>
<pre><code class="language-java">import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param A int整型二维数组 
     * @param f int整型二维数组 
     * @return int整型二维数组
     */
    public int[][] flipChess (int[][] A, int[][] f) {
        // write code here
        int m = A.length;
        int n = A[0].length;
        for(int i = 0; i &lt; f.length; i++) {
            int x = f[i][0] - 1, y = f[i][1] - 1;
            if(x &gt; 0) A[x - 1][y] = 1 - A[x - 1][y];
            if(y &gt; 0) A[x][y - 1] = 1 - A[x][y - 1];
            if(x + 1 &lt; m) A[x + 1][y] = 1 - A[x + 1][y];
            if(y + 1 &lt; n) A[x][y + 1] = 1 - A[x][y + 1];
        }
        return A;
    }
}
</code></pre>
<hr/>
<h1 id="%C2%A0%E4%B8%89%E3%80%81%E6%8B%9C%E8%AE%BF"> 三、拜访</h1>
<h2>描述</h2>
<p>现在有一个城市销售经理，需要从公司出发，去拜访市内的某位商家，已知他的位置以及商家的位置，但是由于城市道路交通的原因，他每次移动只能在左右中选择一个方向 或 在上下中选择一个方向，现在问他有多少种最短方案到达商家地址。</p>
<p>给定一个地图 CityMap 及它的 行长度 n 和 列长度 m ，其中1代表经理位置， 2 代表商家位置， -1 代表不能经过的地区， 0 代表可以经过的地区，请返回方案数，保证一定存在合法路径。保证矩阵的长宽都小于等于 10。</p>
<p>注意：需保证所有方案的距离都是最短的方案</p>
<p>数据范围：2≤n,m≤102 \leq n,m \leq 102≤n,m≤10</p>
<p>例如当输入为[[2,0,0,0],[0,-1,-1,0],[0,-1,1,0],[0,0,0,0]],4,4时，对应的4行4列CityMap如下图所示：</p>
<p><img alt="" height="480" src="image\b813066991594b5d823c4b2e05afc912.png" width="477"/></p>
<p>经理的位置在(2,2)，商家的位置在(0,0)，经分析，经理到达商家地址的最短方案有两种，分别为：</p>
<p>(2,2)-&gt;(2,3)-&gt;(1,3)-&gt;(0,3)-&gt;(0,2)-&gt;(0,1)-&gt;(0,0)</p>
<p>和</p>
<p>(2,2)-&gt;(3,2)-&gt;(3,1)-&gt;(3,0)-&gt;(2,0)-&gt;(1,0)-&gt;(0,0)，所以对应的返回值为2</p>
<h2>示例1</h2>
<blockquote>
<p>输入：</p>
<pre>[[0,1,0],[2,0,0]],2,3</pre>
<p>返回值：</p>
<pre>2
</pre>
</blockquote>
<p>题解：</p>
<pre><code class="language-java">import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param CityMap int整型二维数组 
     * @param n int整型 
     * @param m int整型 
     * @return int整型
     */
    int[][] directions = new int[][]{<!-- -->{1,0}, {-1, 0}, {0,1}, {0, -1}};
    public int countPath (int[][] CityMap, int n, int m) {
        // write code here
        int ans = 0;
        Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;();
        int[][] dist = new int[n][m];
        int[][] dp = new int[n][m];
        boolean[][] visited = new boolean[n][m];
        for(int i=0; i&lt;n; i++){
            for(int j=0; j&lt;m; j++){
                if(CityMap[i][j]==1){ //确认出发点
                    queue.offer(new int[]{i,j});
                    dist[i][j] = 1;  //出发点距离为1
                    dp[i][j] = 1;  //出发点的最短路径数为1
                }
            }
        }
        while(!queue.isEmpty()){
            int[] p = queue.poll();
            int x = p[0], y = p[1];
            if(CityMap[x][y]==2){
                return dp[x][y];
            }
            CityMap[x][y] = -1;
            for(int[] direction : directions){
                int newx = x + direction[0];
                int newy = y + direction[1];
                if(newx&gt;=n || newx&lt;0 || newy&lt;0 || newy&gt;=m || CityMap[newx][newy]==-1){  //判断不可达
                    continue;
                }
                if(dist[newx][newy]==0 || dist[newx][newy]==dist[x][y]+1){  //dist[newx][newy]为0或当前访问点加1，则说明可以通过当前访问点到达目标点，且为最短路径
                    dp[newx][newy] += dp[x][y];  
                    dist[newx][newy] = dist[x][y] + 1;
                }
                
                if(!visited[newx][newy]){  //通过visited数组防止重复加入访问队列
                    queue.offer(new int[]{newx, newy});
                    visited[newx][newy] = true;
                }
            }
        }
        return -1;
    }
}
</code></pre>
<hr/>
<h1 id="%E5%9B%9B%E3%80%81%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%86%85%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2">四、直方图内最大矩形</h1>
<h2>描述</h2>
<p>给定一个数组heights，长度为n，height[i]是在第i点的高度，那么height[i]表示的直方图，能够形成的最大矩形是多少?</p>
<p>1.每个直方图宽度都为1</p>
<p>2.直方图都是相邻的</p>
<p>3.如果不能形成矩形，返回0即可</p>
<p>4.保证返回的结果不会超过231-1</p>
<p>数据范围:</p>
<p>0&lt;=heights[i]&lt;=1040 &lt;= heights[i] &lt;= 10^40&lt;=heights[i]&lt;=104</p>
<p>0&lt;=heights.length&lt;=1050 &lt;= heights.length &lt;=10^50&lt;=heights.length&lt;=105</p>
<p>如输入[3,4,7,8,1,2]，那么如下:</p>
<p><img alt="" height="504" src="image\90acf955f28049b1ab8864641d1dd5fa.png" width="837"/></p>
<h2>示例1</h2>
<blockquote>
<p>输入：</p>
<pre>[3,4,7,8,1,2]</pre>
<p>返回值：</p>
<pre>14
</pre>
</blockquote>
<h2>示例2</h2>
<blockquote>
<p>输入：</p>
<pre>[1,7,3,2,4,5,8,2,7]</pre>
<p>返回值：</p>
<pre>16
</pre>
</blockquote>
<p> 题解：</p>
<pre><code class="language-java">import java.util.*;

public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param heights int整型一维数组 
     * @return int整型
     */
    public int largestRectangleArea (int[] heights) {
        //总宽度
        int n=heights.length;
        //新建单调栈
        ArrayDeque&lt;Integer&gt; stack=new ArrayDeque&lt;&gt;();
        
        int res=0;
        for(int i=0;i&lt;n;i++){
            //只要栈顶元素比当前大，则可以统计以栈顶元素为高的最大面积
            while(!stack.isEmpty()&amp;&amp;heights[stack.peek()]&gt;heights[i]){
                //由于单调栈内元素是单调不递减的，L到i-1之间的高度一定大于等于curHeight
                int curHeight=heights[stack.pop()];
                //如果栈中元素为空，说明0到i-1之间的高度均大于等于curHeight
                int L=stack.isEmpty()?0:stack.peek()+1;
                res=Math.max(res,(i-L)*curHeight);
            }
            stack.push(i);
        }
        
        //如果遍历完之后，单调栈还不为空，则继续统计可能的最大面积
        while(!stack.isEmpty()){
            int curHeight=heights[stack.pop()];
            int L=stack.isEmpty()?0:stack.peek()+1;
            res=Math.max(res,(n-L)*curHeight);
        }
        
        return res;
    }
}
</code></pre>
<hr/>
<h1 id="%E4%BA%94%E3%80%81%E6%80%BB%E7%BB%93">五、总结</h1>
<p><strong>我几乎每天都会在<strong><a href="https://www.nowcoder.com/link/pc_csdncpt_qing_java" title="【牛客网】">【牛客网】</a></strong></strong><strong>刷题训练来使自己对各种算法随时保持一个清晰的状态。要知道<u>眼过千遍不如手过一遍</u></strong><strong>，想成为一名合格的开发工程师，更要逼迫自己养成动手的好习惯。</strong></p>
<p><strong>相较于其他平台，<strong><a href="https://www.nowcoder.com/link/pc_csdncpt_qing_java" title="牛客">牛客</a></strong> 的题目更面向工作，不光有“面试必刷101道”，还有海量大厂真题，内容全程免费，非常的友好。</strong> </p>
<p><img alt="" height="428" src="image\2fd2e12585a144bab58b23b1cb7ee5e5.png" width="560"/></p>
<p></p>
<blockquote>
<p>牛客网还支持<strong>ACM模式</strong>，没有练习过的一定要提前适应！像某团、某为，都要求自己处理输入输出，如果不提前练习会很吃亏的！</p>
<p>牛客的题解更新迭代也很快，讨论区也有技巧的分享，能帮你把所有盲点扫清楚，整体来说还是非常推荐去练习的~</p>
<p><strong>传送门</strong>： <a href="https://www.nowcoder.com/link/pc_csdncpt_qing_java" title="牛客网 - 找工作神器|笔试题库|面试经验|实习招聘内推，求职就业一站解决_牛客网">牛客网 - 找工作神器|笔试题库|面试经验|实习招聘内推，求职就业一站解决_牛客网</a></p>
</blockquote>
<hr/>
<p style="text-align:center;"><img alt="" src="image\5f8beec27f064327b7e12d0ce82d2595.png"/> </p>
<p> </p>
</div>
</div>