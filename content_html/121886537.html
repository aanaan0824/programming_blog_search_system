<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<p id="main-toc"><strong>目录</strong></p>
<p id="-toc" style="margin-left:0px;"></p>
<p id="1.%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B9%8B%E5%9B%9E%E9%A6%96%E6%8E%8F(doge)-toc" style="margin-left:0px;"><a href="#1.%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B9%8B%E5%9B%9E%E9%A6%96%E6%8E%8F%28doge%29">1.构造函数之回首掏(doge)</a></p>
<p id="1.1%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%BD%93%E8%B5%8B%E5%80%BC-toc" style="margin-left:40px;"><a href="#1.1%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%BD%93%E8%B5%8B%E5%80%BC">1.1构造函数体赋值</a></p>
<p id="1.2%20%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8-toc" style="margin-left:40px;"><a href="#1.2%20%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8">1.2 初始化列表</a></p>
<p id="1.3%20explicit%E5%85%B3%E9%94%AE%E5%AD%97-toc" style="margin-left:40px;"><a href="#1.3%20explicit%E5%85%B3%E9%94%AE%E5%AD%97">1.3 explicit关键字</a></p>
<p id="2.%C2%A0static%E6%88%90%E5%91%98-toc" style="margin-left:0px;"><a href="#2.%C2%A0static%E6%88%90%E5%91%98">2. static成员</a></p>
<p id="2.1%20%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#2.1%20%E6%A6%82%E5%BF%B5">2.1 概念</a></p>
<p id="%C2%A02.2%20%E7%89%B9%E6%80%A7-toc" style="margin-left:40px;"><a href="#%C2%A02.2%20%E7%89%B9%E6%80%A7"> 2.2 特性</a></p>
<p id="3.C%2B%2B11%20%E7%9A%84%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:0px;"><a href="#3.C%2B%2B11%20%E7%9A%84%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96">3.C++11 的成员初始化</a></p>
<p id="4.%E5%8F%8B%E5%85%83-toc" style="margin-left:0px;"><a href="#4.%E5%8F%8B%E5%85%83">4.友元</a></p>
<p id="4.1%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#4.1%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0">4.1友元函数</a></p>
<p id="4.2%E5%8F%8B%E5%85%83%E7%B1%BB-toc" style="margin-left:40px;"><a href="#4.2%E5%8F%8B%E5%85%83%E7%B1%BB">4.2友元类</a></p>
<p id="5.%E5%86%85%E9%83%A8%E7%B1%BB(%E4%BA%86%E8%A7%A3)-toc" style="margin-left:0px;"><a href="#5.%E5%86%85%E9%83%A8%E7%B1%BB%28%E4%BA%86%E8%A7%A3%29">5.内部类(了解)</a></p>
<hr id="hr-toc"/>
<h1 id="1.%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B9%8B%E5%9B%9E%E9%A6%96%E6%8E%8F(doge)">1.构造函数之回首掏(doge)</h1>
<h2 id="1.1%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%BD%93%E8%B5%8B%E5%80%BC">1.1构造函数体赋值</h2>
<p>上一节得内容中学到了在创建对象时，编译器通过调用构造函数，给对象中各个成员变量一个合适的初始值。</p>
<pre><code class="language-cpp">class Date
{
public:
    Date(int year = 0, int month = 1, int day = 1)
    {
        _year = year;
        _month = month;
        _day = day;
    }
private:
    int _year;
    int _month;
    int _day;
};</code></pre>
<p>虽然上述构造函数调用之后，对象中已经有了一个初始值，但是不能将其称作为类对象成员的初始化，<strong>构造函数体中的语句只能将其称作为赋初值，而不能称作初始化</strong>。</p>
<p>因为<strong>初始化只能初始化一次，而构造函数体内可以多次赋值。</strong><br/>  </p>
<h2 id="1.2%20%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8">1.2 初始化列表</h2>
<p>对于一些特殊类型的变量如果使用函数体赋值的方式赋初值是不能实现的。</p>
<p>例如：引用，const，自定义(没有默认构造函数)这些成员变量。</p>
<p>对于解决这些变量的初始化，C++中提供了初始化列表的方式初始化。</p>
<p>初始化列表则可以理解为：一个变量在定义时的初始化。</p>
<blockquote>
<p><strong>初始化列表：</strong>以一个冒号开始，接着是一个以逗号分隔的数据成员列表，每个"成员变量"后面跟一个放在括号中的初始值或表达式。</p>
</blockquote>
<p>举个栗子： </p>
<pre><code class="language-cpp">class A
{
public:
	A(int x)
	{
		_x = x;
	}
private:
	int _x;
};


class Date
{
public:
	//Date(int year = 0, int month = 1, int day = 1)
	//{
	//	_year = year;
	//	_month = month;
	//	_day = day;
	//}

	// 对于const变量和引用变量，他们在定义是时必须初始化，他们不能放在函数体内初始化
	// 所以初始化列表初始化可以理解成一个变量在定义时的初始化过程

	Date(int year = 0, int month = 1, int day = 1)
		// 初始化列表初始化
		: _year(year)
		, _month(month)

		, _a(10)// const 变量
		, _b(year)// 引用变量
		, _xx(1) // A类中没有默认构造函数(不需要参数就可以调用的函数)，只能显示调用
		
	{
		// 函数体内初始化
		_day = day;
	}
private:

	// 这里只是变量的声明
	int _year;
	int _month;
	int _day;

	const int _a; // 必须在定义的时候初始化
	int&amp; _b;
	A _xx;
};

int main()
{
	Date d1;
	return 0;
}</code></pre>
<blockquote>
<p> <strong>注意：</strong></p>
<p>           <strong>1.每个成员变量在初始化列表中只能出现一次(初始化只能初始化一次)</strong></p>
<p>          <strong> 2.类中包含以下成员，必须放在初始化列表位置进行初始化：</strong></p>
<p>                   <strong>(1).引用成员变量</strong></p>
<p>                  <strong> (2).const成员变量</strong></p>
<p>                  <strong> (3).自定义类型成员(该类没有默认构造函数)</strong></p>
<p>           <strong> 3.尽量使用初始化列表初始化，因为不管是否使用初始化列表，对于自定义类型成</strong></p>
<p><strong>               员变量，一定会先使用初始化列表初始化，内置类型没有区别。</strong></p>
<p><strong>            4. </strong>成员变量在类中<strong>声明次序</strong>就是其在初始化列表中的<strong>初始化顺序</strong>，与其在初始化列</p>
<p>                表中的先后次序无关<br/>  </p>
</blockquote>
<p></p>
<p>对于第3点，举个例子：</p>
<pre><code class="language-cpp">class Time
{
public:
	Time(int hour= 0)
		:_hour(hour)
	{
		cout &lt;&lt; "Time()" &lt;&lt; endl;
		cout &lt;&lt; _hour &lt;&lt; endl;
	}
private:
	int _hour;
};

class Date
{
public:
	Date(int day, int hour)// 不使用初始化列表，这里就会去调用他的默认构造函数
	{}                     // 就会与我们期望的结果不符,我们希望初始化_t = 20
private:                   // 而这里会初始化_t = 0
	int _day;              // 所以对自定义类型的初始化就不能使用他的默认构造函数
	Time _t;
};

int main()
{
	Date d(10,20);
	return 0;
}</code></pre>
<p>对于自定义类型有一下两种初始化方法： </p>
<pre><code class="language-cpp">class Date
{
public:
    // 初始化列表初始化 构造函数
	Date(int day, int hour)
		:_t(hour)
		,_day(day)
	{}

    // 函数体内初始化(较麻烦) 构造函数+operator+=
	//Date(int day, int hour)
	//{
	//	Time t(hour);
	//	_t = t;
	//}


private:
	int _day;
	Time _t;
};</code></pre>
<p></p>
<p>对于第4点，举个例子：下面这段代码会输出什么？</p>
<pre><code class="language-cpp">class A
{
public:
    A(int a)
    :_a1(a)
    ,_a2(_a1)
    {}
    void Print() 
    {
        cout&lt;&lt;_a1&lt;&lt;" "&lt;&lt;_a2&lt;&lt;endl;
    }
private:
    int _a2;
    int _a1;
}；

int main() 
{
    A aa(1);
    aa.Print();
}</code></pre>
<p>分析：由于在类中先声明_a2, 后声明_a1, 所以在定义时会先定义a2，后定义a1；而_a2是拷贝_a1的值，_a1这时还未初始化，所以这里_a2会是随机值；_a1会被初始化为1。</p>
<p><img alt="" height="595" src="image\6cbcdb751ba642aaa132956f9259e4bf.png" width="798"/></p>
<p></p>
<h2 id="1.3%20explicit%E5%85%B3%E9%94%AE%E5%AD%97">1.3 explicit关键字</h2>
<p>构造函数不仅可以构造与初始化对象，对于<strong>单个参数的构造函数</strong>，还具有<strong>类型转换</strong>的作用。</p>
<p><strong>用explicit修饰构造函数，将会禁止单参构造函数的隐式转换。</strong></p>
<pre><code class="language-cpp">class A
{
public:
	A(int a)
		:_a(a)
	{}

    // explicit A(int a)
	//	:_a(a)
	//{}
private:
	int _a;
};


int main()
{
	A aa1(10);
	// 单参数的构造函数，支持隐式类型转换
	A aa2 = 20; // 早期的编译器： A tmp(20)+A aa2(tmp);
	return 0;   // 现在做了优化后：A aa2(20)
}</code></pre>
<h1 id="2.%C2%A0static%E6%88%90%E5%91%98"><br/> 2. static成员</h1>
<h2 id="2.1%20%E6%A6%82%E5%BF%B5">2.1 概念</h2>
<blockquote>
<p><strong>声明为static的类成员称为类的静态成员，</strong></p>
<p><strong>用static修饰的成员变量，称之为静态成员变量；</strong></p>
<p><strong>用static修饰的成员函数，称之为静态成员函数。</strong></p>
<p><strong>注意：静态的成员变量一定要在类外进行初始化</strong></p>
</blockquote>
<pre><code class="language-cpp">#include&lt;iostream&gt;

using namespace std;

// 计算一个类A定义了多少个对象
class A
{
public:
	A()
	{
		++_n;
	}
	A(const A&amp; a)
	{
		++_n;
	}
	void Print()
	{
		cout &lt;&lt; this-&gt;Get_n() &lt;&lt; endl;
	}

	// 静态成员函数：没有this指针，不能访问非静态成员
	static int Get_n()
	{
		return _n;
	}

private:
	// 不在构造函数初始化
	static int _n;// n存在静态区，属于整个类，也属于类的所有对象
};

// 静态成员初始化，不受访问限定符的限制(特例)
int A::_n = 0;// 这里初始化时不用加static

// 类似这里，const不能修改，但是定义的时候可以，否则没办法初始化
// const int n = 10;
// n = 20;

int main()
{
	A a;
	A a1;
	cout &lt;&lt; sizeof(A) &lt;&lt; endl;// 类中的成员变量是静态的，所以类的大小为1
	cout &lt;&lt; sizeof(a) &lt;&lt; endl;
	cout &lt;&lt; a1.Get_n() &lt;&lt; endl;
	cout &lt;&lt; A().Get_n() &lt;&lt; endl;// 如果用匿名函数的方式调用，会定义一个对象比较麻烦，所以可以增加静态成员函数
	cout &lt;&lt; A::Get_n() &lt;&lt; endl;// 访问方式 类名::静态函数名
	
	return 0;
}</code></pre>
<p></p>
<h2 id="%C2%A02.2%20%E7%89%B9%E6%80%A7"> 2.2 特性</h2>
<blockquote>
<ol><li>静态成员为所有类对象所共享，不属于某个具体的实例</li><li>静态成员变量必须在类外定义，定义时不添加static关键字</li><li><strong> 类静态成员即可用类名::静态成员或者对象.静态成员来访问</strong></li><li><strong>静态成员函数没有隐藏的this指针，不能访问任何非静态成员</strong></li><li>静态成员和类的普通成员一样，也有public、protected、private3种访问级别，也可以具有返回值</li><li>静态成员函数不能调用非静态成员函数</li><li>非静态成员函数可以调用类的静态成员函数</li></ol>
</blockquote>
<p></p>
<h1 id="3.C%2B%2B11%20%E7%9A%84%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96">3.C++11 的成员初始化</h1>
<p>C++11支持<strong>非静态成员变量</strong>在<strong>声明时进行初始化赋值</strong>，但是要注意<strong>不是初始化</strong>，这里<strong>是给声明的成员变量缺省值。</strong></p>
<pre><code class="language-cpp">class Time
{
public:
	Time(int t = 0)
	{
		_t = t;
	}

	int _t = 20;
};
class Date
{
public:
	void Print()
	{
		cout &lt;&lt; _year &lt;&lt; "-" &lt;&lt; _month &lt;&lt; "-" &lt;&lt; _day &lt;&lt; endl;
		cout &lt;&lt; _a &lt;&lt; endl;
		cout &lt;&lt; T._t &lt;&lt; endl;
	}
private:
    // 非静态成员变量，可以在成员声明时给缺省值。
	int _year = 2021;
	int _month = 12;
	int _day = 20;
	static int _a;
	Time T = 20;
};

int Date::_a = 10;

int main()
{
	Date d1;
	d1.Print();
	return 0;
}</code></pre>
<p></p>
<h1 id="4.%E5%8F%8B%E5%85%83">4.友元</h1>
<h2 id="4.1%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0">4.1友元函数</h2>
<p>上次的内容中学习了运算符重载，那这里能否实现对自定义类型直接输入(&gt;&gt;)和输出(&lt;&lt;)运算符的重载？</p>
<p>注意：C++中的 &lt;&lt; 和 &gt;&gt; 是已经重载过的运算符，他们被重载在istream 和ostream两个类中。</p>
<p> <a class="link-info" href="https://www.cplusplus.com/reference/ostream/ostream/operator%3C%3C/" title="CppReference">CppReference</a></p>
<p><img alt="" height="479" src="image\7afb06ec0f2a4f728f99efa29995cab6.png" width="1163"/></p>
<pre><code class="language-cpp">class Date
{
public:
    Date(int year, int month, int day)
    : _year(year)
    , _month(month)
    , _day(day)
    {}
    
    // 这里有返回值是为了能够连续输出
    ostream&amp; operator&lt;&lt;(ostream&amp; out)// ostream&amp; operator&lt;&lt;(Data*this, ostream&amp; out)
    {
        out&lt;&lt;_year&lt;&lt;"-"&lt;&lt;_month&lt;&lt;"-"&lt;&lt;_day;
        return out;
    }
private:
    int _year;
    int _month;
    int _day;
};
int main()
{
    Date d(2021, 12, 20);
    //cout&lt;&lt;d;  // 不能调用(this指针指向的是cout)
    d&lt;&lt;cout;    // 不符合使用习惯
    return 0;
}</code></pre>
<blockquote>
<p>按照以前会将operator&lt;&lt;重载成一个成员函数。</p>
<p>但是会有问题， 对于有两个操作数的操作符，第一个操作数是他的第一个参数，第二个操作数是他的第二个参数，所以这里显然不会像以前那样第一个参数是this指针,指向的是第一个参数。</p>
<p>而这里他的this指针指向的是cout，所以在使用时需要将两个操作时交换位置。但这样不符合我们的使用习惯。</p>
</blockquote>
<p>所以这里会<strong>写成一个全局的函数。</strong></p>
<p><strong>但是也会产生问题：全局的函数中不能访问到类中的私有成员。</strong></p>
<p>于是就有了友元函数<strong>：友元函数可以直接访问类的私有成员，它是定义在类外部的普通函数，不属于任何类，但需要在类的内部声明，声明时需要加friend关键字。</strong></p>
<pre><code class="language-cpp">class Date
{
    // 友元(友元可以定义在类中的任意位置)
	// 如果需要类外面的函数访问类中的私有成员就可以使用友元
	// 一般情况下不建议多使用友元，友元是一种破坏封装的行为
    friend ostream&amp; operator&lt;&lt;(ostream&amp; out, const Date&amp; d);
    friend istream&amp; operator&gt;&gt;(istream&amp; in, Date&amp; d);
public:
    Date(int year, int month, int day)
        : _year(year)
        , _month(month)
        , _day(day)
    {}
 
private:
    int _year;
    int _month;
    int _day;
};

ostream&amp; operator&lt;&lt;(ostream&amp; out, const Date&amp; d)
{
    out &lt;&lt; d._year &lt;&lt; "-" &lt;&lt; d._month &lt;&lt; "-" &lt;&lt; d._day;
    return out;
}

istream&amp; operator&gt;&gt;(istream&amp; in, Date&amp; d)
{
    in &gt;&gt; d._year &gt;&gt; d._month &gt;&gt; d._day;
    return in;
}
int main()
{
    Date d(2021, 12, 20);
    cout &lt;&lt; d &lt;&lt; endl;
    return 0;
};</code></pre>
<blockquote>
<p><strong>注意：</strong></p>
<ul><li>友元函数可访问类的私有和保护成员，但不是类的成员函数</li><li>友元函数不能用const修饰</li><li>友元函数可以在类定义的任何地方声明，不受类访问限定符限制</li><li>一个函数可以是多个类的友元函数</li><li>友元函数的调用与普通函数的调用和原理相同</li></ul>
</blockquote>
<p></p>
<h2 id="4.2%E5%8F%8B%E5%85%83%E7%B1%BB">4.2友元类</h2>
<blockquote>
<p>友元类的所有成员函数都可以是另一个类的友元函数，都可以访问另一个类中的非公有成员。</p>
<ul><li>友元关系是单向的，不具有交换性。</li></ul>
<p>比如上述Time类和Date类，在Time类中声明Date类为其友元类，那么可以在Date类中直接访问Time类的私有成员变量，但想在Time类中访问Date类中私有的成员变量则不行。</p>
<ul><li>友元关系不能传递</li></ul>
<p>如果B是A的友元，C是B的友元，则不能说明C时A的友元</p>
</blockquote>
<pre><code class="language-cpp">class Time
{
	friend class Date; // 声明日期类为时间类的友元类，则在日期类中就直接访问Time类中的私有成员变量
public:
	Time(int hour = 0, int minute = 0, int second = 0)
		: _hour(hour)
		, _minute(minute)
		, _second(second)
	{}
private:
	int _hour;
	int _minute;
	int _second;
};

class Date
{
public:
	Date(int year = 2021, int month = 12, int day = 20)
		: _year(year)
		, _month(month)
		, _day(day)
	{
		// 需要访问Time类中的私有成员变量
		_t._hour = 1;
		_t._minute = 1;
		_t._second = 1;
	}

	void SetTimeOfDate(int hour, int minute, int second)
	{
		// 直接访问Time类中的私有成员变量
		_t._hour = hour;
		_t._minute = minute;
		_t._second = second;
	}
private:
	int _year; 
	int _month;
	int _day;
	Time _t;
};</code></pre>
<p></p>
<h1 id="5.%E5%86%85%E9%83%A8%E7%B1%BB(%E4%BA%86%E8%A7%A3)">5.内部类(了解)</h1>
<p><strong>概念：</strong>如果一个类定义在另一个类的内部，这个内部类就叫做内部类。</p>
<p>注意此时这个内部类是一个独立的类，它不属于外部类，更不能通过外部类的对象去调用内部类。外部类对内部类没有任何优越的访问权限。</p>
<p>注意：内部类就是外部类的友元类。注意友元类的定义，内部类可以通过外部类的对象参数来访问外部类中的所有成员。但是外部类不是内部类的友元(即外部类不能访问内部类的成员)。</p>
<blockquote>
<p><strong>特性：</strong></p>
<ol><li>内部类可以定义在外部类的public、protected、private都是可以的。</li><li>注意内部类可以直接访问外部类中的static、枚举成员，不需要外部类的对象/类名。</li><li>sizeof(外部类)=外部类，和内部类没有任何关系。</li></ol>
</blockquote>
<pre><code class="language-cpp">class A
{
private:
	static int aa;
	int n;
public:
	class B
	{
	public:
		void Print(const A&amp; a)
		{
			cout &lt;&lt; a.aa &lt;&lt; endl;// 内部类可以通过对象访问外部类的成员
			cout &lt;&lt; a.n &lt;&lt; endl;
		}
	};
};

int A::aa = 10;

int main()
{
	A::B b;       // 创建内部类的对象b
	b.Print(A()); // 调用对象b中的成员函数，通过匿名对象访问外部类的成员
	return 0;
}</code></pre>
<p></p>
</div>
</div>