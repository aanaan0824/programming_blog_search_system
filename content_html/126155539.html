<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<blockquote>
<p style="text-align:center;"><strong>Hi！我是Duoni！</strong></p>
</blockquote>
<p></p>
<p><strong><img alt="d3801154c39743509738312e129cbba2.jpeg" src="https://img-blog.csdnimg.cn/d3801154c39743509738312e129cbba2.jpeg"/></strong></p>
<p id="main-toc"><strong>目录</strong></p>
<p id="%F0%9F%8D%8A%E5%BC%95%E7%94%A8-toc" style="margin-left:0px;"><a href="#%F0%9F%8D%8A%E5%BC%95%E7%94%A8">🍊引用</a></p>
<p id="%F0%9F%8D%8A%E5%BC%95%E7%94%A8%E4%B8%8E%E5%8F%96%E5%9C%B0%E5%9D%80%E7%AC%A6%E7%9A%84%E5%8C%BA%E5%88%86-toc" style="margin-left:40px;"><a href="#%F0%9F%8D%8A%E5%BC%95%E7%94%A8%E4%B8%8E%E5%8F%96%E5%9C%B0%E5%9D%80%E7%AC%A6%E7%9A%84%E5%8C%BA%E5%88%86">🍊引用与取地址符的区分</a></p>
<p id="%F0%9F%8D%8A%E5%BC%95%E7%94%A8%E7%9A%84%E7%89%B9%E6%80%A7-toc" style="margin-left:40px;"><a href="#%F0%9F%8D%8A%E5%BC%95%E7%94%A8%E7%9A%84%E7%89%B9%E6%80%A7">🍊引用的特性</a></p>
<p id="%F0%9F%8D%8A%E5%BC%95%E7%94%A8%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:40px;"><a href="#%F0%9F%8D%8A%E5%BC%95%E7%94%A8%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">🍊引用的应用场景</a></p>
<p id="%F0%9F%8D%8A%E4%BC%A0%E5%80%BC%E8%BF%94%E5%9B%9E%E4%B8%8E%E4%BC%A0%E5%BC%95%E7%94%A8%E8%BF%94%E5%9B%9E-toc" style="margin-left:0px;"><a href="#%F0%9F%8D%8A%E4%BC%A0%E5%80%BC%E8%BF%94%E5%9B%9E%E4%B8%8E%E4%BC%A0%E5%BC%95%E7%94%A8%E8%BF%94%E5%9B%9E">🍊传值返回与传引用返回</a></p>
<p id="%F0%9F%8D%8A%E4%BC%A0%E5%80%BC%E8%BF%94%E5%9B%9E-toc" style="margin-left:40px;"><a href="#%F0%9F%8D%8A%E4%BC%A0%E5%80%BC%E8%BF%94%E5%9B%9E">🍊传值返回</a></p>
<p id="%F0%9F%8D%8A%E4%BC%A0%E5%80%BC%E8%BF%94%E5%9B%9E%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px;"><a href="#%F0%9F%8D%8A%E4%BC%A0%E5%80%BC%E8%BF%94%E5%9B%9E%E7%9A%84%E5%AE%9E%E7%8E%B0">🍊传值返回的实现</a></p>
<p id="%F0%9F%8D%8A%E4%BC%A0%E5%BC%95%E7%94%A8%E8%BF%94%E5%9B%9E-toc" style="margin-left:40px;"><a href="#%F0%9F%8D%8A%E4%BC%A0%E5%BC%95%E7%94%A8%E8%BF%94%E5%9B%9E">🍊传引用返回</a></p>
<p id="%F0%9F%8D%8A%E4%BC%A0%E5%BC%95%E7%94%A8%E8%BF%94%E5%9B%9E%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px;"><a href="#%F0%9F%8D%8A%E4%BC%A0%E5%BC%95%E7%94%A8%E8%BF%94%E5%9B%9E%E7%9A%84%E5%AE%9E%E7%8E%B0">🍊传引用返回的实现</a></p>
<p id="%F0%9F%8D%8A%E4%BC%A0%E5%80%BC%E8%BF%94%E5%9B%9E%E4%B8%8E%E4%BC%A0%E5%BC%95%E7%94%A8%E8%BF%94%E5%9B%9E%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9-toc" style="margin-left:0px;"><a href="#%F0%9F%8D%8A%E4%BC%A0%E5%80%BC%E8%BF%94%E5%9B%9E%E4%B8%8E%E4%BC%A0%E5%BC%95%E7%94%A8%E8%BF%94%E5%9B%9E%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9">🍊传值返回与传引用返回的优缺点</a></p>
<p id="%F0%9F%8D%8A%E5%B8%B8%E5%BC%95%E7%94%A8-toc" style="margin-left:0px;"><a href="#%F0%9F%8D%8A%E5%B8%B8%E5%BC%95%E7%94%A8">🍊常引用</a></p>
<p id="%F0%9F%8D%8A%E6%9D%83%E9%99%90%E8%A7%84%E5%88%99-toc" style="margin-left:40px;"><a href="#%F0%9F%8D%8A%E6%9D%83%E9%99%90%E8%A7%84%E5%88%99">🍊权限规则</a></p>
<p id="%F0%9F%8D%8A%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-toc" style="margin-left:40px;"><a href="#%F0%9F%8D%8A%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">🍊隐式类型转换</a></p>
<p id="%F0%9F%8D%8A%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:0px;"><a href="#%F0%9F%8D%8A%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB">🍊指针与引用的区别</a></p>
<p id="%F0%9F%8D%8A%E5%BC%95%E7%94%A8%E4%B8%8E%E6%8C%87%E9%92%88%E5%BA%95%E5%B1%82%E5%88%A8%E6%9E%90-toc" style="margin-left:0px;"><a href="#%F0%9F%8D%8A%E5%BC%95%E7%94%A8%E4%B8%8E%E6%8C%87%E9%92%88%E5%BA%95%E5%B1%82%E5%88%A8%E6%9E%90">🍊引用与指针底层刨析</a></p>
<p id="%F0%9F%8D%8A%E5%BA%95%E5%B1%82%E5%88%A8%E6%9E%90-toc" style="margin-left:40px;"><a href="#%F0%9F%8D%8A%E5%BA%95%E5%B1%82%E5%88%A8%E6%9E%90">🍊底层刨析</a></p>
<p id="%F0%9F%8D%8A%E6%B1%87%E7%BC%96%E8%A7%A3%E8%AF%BB-toc" style="margin-left:80px;"><a href="#%F0%9F%8D%8A%E6%B1%87%E7%BC%96%E8%A7%A3%E8%AF%BB">🍊汇编解读</a></p>
<p id="%F0%9F%8D%8A%E5%BC%95%E7%94%A8%E5%AE%9E%E7%8E%B0%E9%83%A8%E5%88%86-toc" style="margin-left:80px;"><a href="#%F0%9F%8D%8A%E5%BC%95%E7%94%A8%E5%AE%9E%E7%8E%B0%E9%83%A8%E5%88%86">🍊引用实现部分</a></p>
<p id="%F0%9F%8D%8A%E6%8C%87%E9%92%88%E5%AE%9E%E7%8E%B0%E9%83%A8%E5%88%86-toc" style="margin-left:80px;"><a href="#%F0%9F%8D%8A%E6%8C%87%E9%92%88%E5%AE%9E%E7%8E%B0%E9%83%A8%E5%88%86">🍊指针实现部分</a></p>
<hr id="hr-toc"/>
<p></p>
<p></p>
<h1 id="%F0%9F%8D%8A%E5%BC%95%E7%94%A8">🍊引用</h1>
<p></p>
<p></p>
<p><strong>引用概念：</strong>引用并不是一个独立定义的变量或其他值，而是一个对已存在的变量或其他值取了一个别名。这一期间编译器不会为他开辟空间（语法角度），它与其引用对象共同使用内存空间，对别名进行操作会影响引用对象。</p>
<p></p>
<p></p>
<blockquote>
<p style="text-align:center;"><strong>引用用法：类型&amp; 引用变量名 = 引用对象名</strong></p>
</blockquote>
<p style="text-align:center;"></p>
<p style="text-align:center;"></p>
<pre><code class="language-cpp">int num_a = 6;
int&amp; num_b = num_a;//num_b是num_a的别名</code></pre>
<p></p>
<p></p>
<p>为了便于理解，我们将取别名再理解为<strong>取外号。</strong></p>
<p></p>
<p></p>
<p>tips：”小狗“被取了别名叫”修勾“。</p>
<p></p>
<p></p>
<hr/>
<p></p>
<h2 id="%F0%9F%8D%8A%E5%BC%95%E7%94%A8%E4%B8%8E%E5%8F%96%E5%9C%B0%E5%9D%80%E7%AC%A6%E7%9A%84%E5%8C%BA%E5%88%86">🍊引用与取地址符的区分</h2>
<p></p>
<p></p>
<p><strong>&amp;符在类型名后的是引用</strong></p>
<p></p>
<p></p>
<pre><code class="language-cpp">int num_a = 6;
int&amp; num_b = num_a;//给变量num_a定义了一个名为num_b的别名</code></pre>
<p></p>
<p></p>
<p><strong>&amp;符在变量名前是取地址</strong></p>
<p></p>
<p></p>
<pre><code class="language-cpp">int num_a = 6;
int* num_b = &amp;num_a;//取num_a的地址给num_b</code></pre>
<p></p>
<p></p>
<p><strong>附：定义别名真的不会另开空间吗</strong></p>
<p></p>
<p></p>
<pre><code class="language-cpp">int main()
{
       int num_a = 6;
       int&amp; num_b = num_a;//num_b是num_a的别名
       std::cout &lt;&lt; "变量num_a的地址：" &lt;&lt; &amp; num_a &lt;&lt; std::endl;
       std::cout &lt;&lt; "别名num_b的地址：" &lt;&lt; &amp; num_b &lt;&lt; std::endl;
       return 0;
}</code></pre>
<p></p>
<p></p>
<p><img alt="15fa449c143144b59900353e3e4c231d.png" src="https://img-blog.csdnimg.cn/15fa449c143144b59900353e3e4c231d.png"/></p>
<p></p>
<p></p>
<p></p>
<p><strong>小结：从语法角度上，定义别名，其别名是和引用对象共占一块空间的。</strong></p>
<p></p>
<p></p>
<p><strong>tips：底层上，引用实际是依靠指针实现的，具体后期深入。</strong></p>
<p></p>
<p></p>
<p><strong>附：对别名的修改会影响到引用对象吗？</strong></p>
<p></p>
<p></p>
<pre><code class="language-cpp">int main()
{
       int num_a = 6;
       int&amp; num_b = num_a;
       std::cout &lt;&lt; "引用对象修改前：" &lt;&lt; num_a &lt;&lt; std::endl;
       std::cout &lt;&lt; "别名修改前：" &lt;&lt; num_b &lt;&lt; std::endl;
       num_b--;
       std::cout &lt;&lt; std::endl;
       std::cout &lt;&lt; "引用对象修改后：" &lt;&lt; num_a &lt;&lt; std::endl;
       std::cout &lt;&lt; "别名修改后：" &lt;&lt; num_b &lt;&lt; std::endl;
       return 0;
}</code></pre>
<p></p>
<p><img alt="f8eb612aaf28466895c78d634b462917.png" src="https://img-blog.csdnimg.cn/f8eb612aaf28466895c78d634b462917.png"/></p>
<p></p>
<p></p>
<p><strong>小结：对别名的操作会直接对引用对象进行影响。</strong></p>
<p></p>
<p></p>
<hr/>
<p></p>
<p></p>
<h2 id="%F0%9F%8D%8A%E5%BC%95%E7%94%A8%E7%9A%84%E7%89%B9%E6%80%A7">🍊引用的特性</h2>
<p></p>
<p></p>
<p><strong>1.引用在定义时必须被初始化</strong></p>
<p></p>
<p></p>
<pre><code class="language-cpp">int main()
{
       int&amp; val;//错误，引用的定义（使用）必须指明引用对象
       return 0;
}</code></pre>
<p></p>
<p></p>
<p><img alt="809c08786ef14efea1ff0543f6ea6753.png" src="https://img-blog.csdnimg.cn/809c08786ef14efea1ff0543f6ea6753.png"/></p>
<p></p>
<p></p>
<p><strong>2.一个变量可以有多个引用，而一个别名也可以有多个别名</strong></p>
<p></p>
<p></p>
<pre><code class="language-cpp">int main()
{
       int num_a = 2;
       int&amp; num_1 = num_a;//一个变量可以拥有多个别名
       int&amp; num_2 = num_a;
       int&amp; num_3 = num_a;
       int&amp; num_cp1 = num_1;//一个别名可以拥有多个别名
       int&amp; num_cp2 = num_1;
       int&amp; num_cp3 = num_1;
       std::cout &lt;&lt; "我们都是变量num_a的别名：" &lt;&lt; num_1 &lt;&lt; " " &lt;&lt; num_2 &lt;&lt; " " &lt;&lt; num_3 &lt;&lt; std::endl;
       std::cout &lt;&lt; "我们都是别名num_1的别名：" &lt;&lt; num_cp1 &lt;&lt; " " &lt;&lt; num_cp2 &lt;&lt; " " &lt;&lt; num_cp3 &lt;&lt; std::endl;
       return 0;
}</code></pre>
<p></p>
<p><img alt="0732a43f6f194855af24f7b2117c37a9.png" src="https://img-blog.csdnimg.cn/0732a43f6f194855af24f7b2117c37a9.png"/></p>
<p></p>
<p></p>
<p><strong>3.引用一旦引用某一实体，就不能够再引用其他实体。</strong></p>
<p></p>
<p></p>
<pre><code class="language-cpp">int main()
{
       int val_a = 2;
       int val_b = 6;
       int&amp; num_cp = val_a;
       num_cp = val_b;//num_cp不能够再改变实体，在这只能进行赋值动作
       std::cout &lt;&lt; &amp;val_a &lt;&lt; std::endl;//观察num_cp十分还是val_a的别名
       std::cout &lt;&lt; &amp;num_cp &lt;&lt; std::endl;
       return 0;
}</code></pre>
<p></p>
<p></p>
<p><img alt="69ef9382e4624902be99e74ef08c021a.png" src="https://img-blog.csdnimg.cn/69ef9382e4624902be99e74ef08c021a.png"/></p>
<p></p>
<p></p>
<hr/>
<p></p>
<p></p>
<h2 id="%F0%9F%8D%8A%E5%BC%95%E7%94%A8%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">🍊引用的应用场景</h2>
<p></p>
<p></p>
<p><strong>1.可用于做参数（输出型参数）</strong></p>
<p></p>
<p></p>
<pre><code class="language-cpp">void Change_Num(int&amp; num_1, int&amp; num_2)//用引用接收参数
{
       num_1 = 60;//是否会对原值进行改变？
       num_2 = 80;
}

int main()
{
       int val_1 = 6;
       int val_2 = 8;
       Change_Num(val_1, val_2);//传参
       std::cout &lt;&lt; "val_1:" &lt;&lt; val_1 &lt;&lt; std::endl;
       std::cout &lt;&lt; "val_2:" &lt;&lt; val_2 &lt;&lt; std::endl;
       return 0;
}</code></pre>
<p></p>
<p><img alt="4936535437734be9a770268a2e1e6b28.png" src="https://img-blog.csdnimg.cn/4936535437734be9a770268a2e1e6b28.png"/></p>
<p></p>
<p></p>
<p><strong>优点：提高了传参的效率，相对于指针的传址解引用修改。引用做参数能更加直观、便利的完成操作。</strong></p>
<p></p>
<p></p>
<p><strong>tips：输入型参数与输出型参数是什么？</strong></p>
<p></p>
<p></p>
<blockquote>
<p>(1)、输入型参数是指：传参处传递的是普通变量，且在函数执行后，不会对外部的实体产生影响。</p>
</blockquote>
<p></p>
<p></p>
<blockquote>
<p>(2)、输出型参数是指：传参处传递的是地址，或者在接收参数时使用别名接收，运行后会对外部实体产生影响。</p>
</blockquote>
<p></p>
<p></p>
<p><strong>2.大型对象的传参，提高效率。（节省了参数拷贝的环节）</strong></p>
<p></p>
<p></p>
<p><strong>3、做返回值</strong>（输出型返回值，调用者可通过返回值修改引用对象。减少返回时的一次临时拷贝，提高效率）</p>
<p></p>
<p></p>
<hr/>
<h1></h1>
<p></p>
<h1 id="%F0%9F%8D%8A%E4%BC%A0%E5%80%BC%E8%BF%94%E5%9B%9E%E4%B8%8E%E4%BC%A0%E5%BC%95%E7%94%A8%E8%BF%94%E5%9B%9E">🍊传值返回与传引用返回</h1>
<p></p>
<p></p>
<h2 id="%F0%9F%8D%8A%E4%BC%A0%E5%80%BC%E8%BF%94%E5%9B%9E">🍊传值返回</h2>
<p></p>
<p></p>
<p>传值返回的意义：函数结束后，通过临时拷贝带回所需要的值。</p>
<p></p>
<p></p>
<pre><code class="language-cpp">int test_return()
{
       int num = 6;
       return num;//第三步对值进行拷贝，产生值的临时拷贝//返回的只是num的一份临时拷贝
}

int main()//第一步栈空间开辟
{
       int val = test_return();//第二步调用函数//第三步接收返回值
       return 0;
}</code></pre>
<p></p>
<p></p>
<hr/>
<p></p>
<p></p>
<h3 id="%F0%9F%8D%8A%E4%BC%A0%E5%80%BC%E8%BF%94%E5%9B%9E%E7%9A%84%E5%AE%9E%E7%8E%B0">🍊传值返回的实现</h3>
<p></p>
<p></p>
<p></p>
<p><strong>进入主函数，main函数在栈帧创建空间，再调用test_return函数，test_return函数在栈帧开辟空间，走到（return num值）的那一步，编译器做了两个动作：</strong></p>
<p></p>
<p></p>
<p><strong>局部变量的生命周期取决于所存储的物理空间，栈空间在函数执行完毕后就会销毁，这也说明函数内的一切局部变量将随着栈空间的销毁而被销毁。</strong></p>
<p></p>
<p></p>
<p><strong>而如果直接将值进行返回，那将是错误的，因为在函数结束后，所有的局部变量空间都被销毁，此时的返回值并不存在，最终形成了一次越界访问的错误，该值也会是一个随机值。</strong></p>
<p></p>
<p></p>
<p><strong>为了返回有效的值，编译器是这么处理的：第一步，当进行到（return num值）时，会对num进行一次临时拷贝，存储它的数据。第二步，再将这一份临时拷贝的数据进行返回拷贝。</strong></p>
<p></p>
<p></p>
<hr/>
<p></p>
<p></p>
<p><strong>附：若函数中所返回值不存放在栈区，那编译器会怎么做？</strong></p>
<p></p>
<p></p>
<pre><code class="language-cpp">int test_return()
{
       static int num = 6;//我存放在静态区，栈帧销毁与我无关
       //int num = 6;
       return num;
}</code></pre>
<p></p>
<p></p>
<p><strong>确实，静态变量存放在静态区，栈区的销毁动作也并不能影响到它。但编译器同样还是会进行临时拷贝再返回的动作，因为这么做是最安全的。</strong></p>
<p></p>
<p></p>
<p><strong>小结：只要是传值返回，都会形成临时拷贝。</strong></p>
<p></p>
<p></p>
<hr/>
<h2></h2>
<p></p>
<h2 id="%F0%9F%8D%8A%E4%BC%A0%E5%BC%95%E7%94%A8%E8%BF%94%E5%9B%9E">🍊传引用返回</h2>
<p></p>
<p></p>
<pre><code class="language-cpp">int&amp; test_return()//返回num的别名
{
       int num = 6;//局部变量在函数结束后会被销毁
       return num;
}

int main()
{
       int val = test_return();
       return 0;
}</code></pre>
<p></p>
<p></p>
<hr/>
<h3></h3>
<p></p>
<h3 id="%F0%9F%8D%8A%E4%BC%A0%E5%BC%95%E7%94%A8%E8%BF%94%E5%9B%9E%E7%9A%84%E5%AE%9E%E7%8E%B0">🍊传引用返回的实现</h3>
<p></p>
<p></p>
<p><strong>num成为引用对象，别名被返回。但函数结束意味着栈帧中局部变量的销毁，而别名一旦被定义引用对象便无法再修改。此时别名被返回到主函数中，若对别名进行访问，其结果是未被定义且不确定的。（可能是原值，也可能是随机值）</strong></p>
<p></p>
<p></p>
<p><strong>小结;</strong>如果引用对象出了作用域一定被销毁，那么便一定不能使用引用返回，只能使用传值返回。若要使用传引用返回，那么前提一定要保证引用对象出作用域<strong>不被销毁</strong>。</p>
<p></p>
<p></p>
<p><strong>附：</strong>引用对象被销毁后，再次用别名访问，得到的一定是随机值。<strong>因为栈空间销毁后，所有地址都保存着一个随机值，虽然引用对象被销毁，但空间一直存在！</strong></p>
<p></p>
<p></p>
<p><strong>tips：</strong>引用对象是全局变量或静态变量或是存于堆空间，就可使用引用返回。</p>
<p></p>
<p></p>
<hr/>
<p></p>
<p></p>
<h1 id="%F0%9F%8D%8A%E4%BC%A0%E5%80%BC%E8%BF%94%E5%9B%9E%E4%B8%8E%E4%BC%A0%E5%BC%95%E7%94%A8%E8%BF%94%E5%9B%9E%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9">🍊传值返回与传引用返回的优缺点</h1>
<p></p>
<p></p>
<p><strong>传值返回的优缺点</strong></p>
<p></p>
<p></p>
<blockquote>
<p><strong>优点：安全、稳定，应用范围广</strong></p>
<p><strong>缺点：需要进行一次临时拷贝，效率低、速度慢</strong></p>
</blockquote>
<p></p>
<p></p>
<p><strong>传引用返回的优缺点</strong></p>
<p>   </p>
<p></p>
<blockquote>
<p><strong>优点：不用临时拷贝，直接返回别名、对别名的修改可以直接影响实体、高效</strong></p>
<p><strong>缺点：要满足使用条件，才可使用（出作用域不被销毁）</strong></p>
</blockquote>
<p></p>
<p></p>
<hr/>
<h1></h1>
<p></p>
<h1 id="%F0%9F%8D%8A%E5%B8%B8%E5%BC%95%E7%94%A8">🍊常引用</h1>
<p></p>
<p></p>
<p>常引用的意义：<strong>const对引用进行修饰，限制权限。</strong></p>
<p></p>
<p></p>
<hr/>
<h2></h2>
<h2 id="%F0%9F%8D%8A%E6%9D%83%E9%99%90%E8%A7%84%E5%88%99">🍊权限规则</h2>
<p></p>
<p><strong>1.权限无法被放大</strong></p>
<p></p>
<p></p>
<pre><code class="language-cpp">int main()
{
       const int val = 6;//val由const修饰，只可读，不可写
       int&amp; num = val;//num是变量val的别名，权限发生改变：可读可写。错误！权限被放大
       return 0;
}</code></pre>
<p></p>
<p></p>
<p><img alt="9a0087a639cf4fefbbeda39439d7aed9.png" src="https://img-blog.csdnimg.cn/9a0087a639cf4fefbbeda39439d7aed9.png"/></p>
<p></p>
<p></p>
<p><strong>2.权限可以平移</strong></p>
<p></p>
<p></p>
<pre><code class="language-cpp">int main()
{
       const int val = 6;//权限：可读，不可写
       const int&amp; num = val;//权限：可读，不可写。正确，权限平移
       return 0;
}</code></pre>
<p></p>
<p></p>
<p><strong>3.权限可以被缩小</strong></p>
<p></p>
<p></p>
<pre><code class="language-cpp">int main()
{
       int val = 6;//权限：可读，可写
       const int&amp; num = val;//权限：可读，不可写。正确，权限缩小
       return 0;
}</code></pre>
<p></p>
<hr/>
<h2></h2>
<h2></h2>
<h2 id="%F0%9F%8D%8A%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">🍊隐式类型转换</h2>
<p></p>
<p></p>
<p>隐式类型转换的意义：不同类型间的转换，通常情况下，<strong>小类型会隐式转换成大类型</strong>。</p>
<p></p>
<p></p>
<pre><code class="language-cpp">int main()
{
       int a = 6;
       double b = a;
       //整形变量会向双精度浮点值进行转换，形成一个临时变量进行提升，不会对本体进行改变
       return 0;
}</code></pre>
<p></p>
<p></p>
<p>tips：不同类型间的运算或赋值，变量会进行隐式转换。小类型会向大类型进行提升、截断。</p>
<p></p>
<p></p>
<blockquote>
<p>这一过程是在临时变量上进行实现，因为小类型本身的体量过小，没有办法在本体进行提升，所以本体不会发生改变，但也不会被使用，使用的是提升后的那份临时变量。</p>
</blockquote>
<p></p>
<p></p>
<p><strong>附：为什么没有发生权限问题？</strong></p>
<p></p>
<p></p>
<blockquote>
<p>因为在类型转化中将整形a提升为双精度浮点值后，虽然临时变量具有常性，但表达式本身也只是赋值功能，将临时变量赋值给b，并没有发生权限的改变。</p>
<p></p>
<p>因为权限规则只对指针和引用有效。</p>
</blockquote>
<p></p>
<p></p>
<pre><code class="language-cpp">int main()
{
       int a = 6;
       double&amp; b = a;//定义整形a为双精度浮点值b的引用对象，错误！
       //整形变量会向双精度浮点值进行转换，在临时变量中进行二进制的提升，所以此时临时变量具有常性，权限不能被扩大。错误！
       return 0;
}</code></pre>
<p></p>
<p><img alt="35f21a6955db459ca223e100797b618f.png" src="https://img-blog.csdnimg.cn/35f21a6955db459ca223e100797b618f.png"/></p>
<p></p>
<p></p>
<p>tips：进行隐式类型转换后，临时变量具有常性，所以不能够成为b的引用对象，因为如此的话，具有常性的临时变量权限将受到放大，这是不符合规则的。</p>
<p></p>
<p>若要正确的对其进行引用，应该加上const修饰别名，起到权限平移的功能。</p>
<p></p>
<pre><code class="language-cpp">       const double&amp; b = a;</code></pre>
<p></p>
<p>附：引用的作用在于形成别名，并且对别名具有可访问、可操作的功能，所以会引发类型转化后的权限问题。所以今后在函数参数接收上或具有类型转换的表达式中，最好使用const修饰，提高接收度。</p>
<p></p>
<p></p>
<hr/>
<h1></h1>
<h1></h1>
<h1 id="%F0%9F%8D%8A%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB">🍊指针与引用的区别</h1>
<p></p>
<blockquote>
<p><strong>1.在定义时，引用必须初始化，而指针不要求必须初始化</strong></p>
<p></p>
<pre><code class="language-cpp">int main()
{
       int&amp; pre;//error:未初始化引用
       int* ret;
       return 0;
}</code></pre>
<p></p>
<p><img alt="383c2d6c91b44e44a5ba2bfd2b8dfdf2.png" src="https://img-blog.csdnimg.cn/383c2d6c91b44e44a5ba2bfd2b8dfdf2.png"/></p>
<p></p>
<p></p>
<p><strong>2.没有空引用，但有空指针</strong></p>
<p></p>
<pre><code class="language-cpp">int main()
{
       int&amp; pre = nullptr;//不存在对空的引用
       int* ret = nullptr;
       return 0;
}</code></pre>
<p></p>
<p><img alt="38f7ef59137248888c7463f488b4a34e.png" src="https://img-blog.csdnimg.cn/38f7ef59137248888c7463f488b4a34e.png"/></p>
<p></p>
<p><strong>3.引用在初始化阶段引用一个实体后，就不能再引用其他实体。而指针可以在任何情况下改变指向。（同类型实体）</strong></p>
<p></p>
<p>引用举例</p>
<p></p>
<pre><code class="language-cpp">using namespace std;
int main()
{
       int num_1 = 5;
       int num_2 = 10;
       int&amp; pre = num_1;
       pre = num_2;
       cout &lt;&lt; "pre别名的值:" &lt;&lt; pre &lt;&lt; " " &lt;&lt; "pre引用对象地址：" &lt;&lt; &amp;pre &lt;&lt; endl;
       cout &lt;&lt; "num_1的地址" &lt;&lt; &amp;num_1 &lt;&lt; endl;
       cout &lt;&lt; "num_2的地址" &lt;&lt; &amp;num_2 &lt;&lt; endl;
       return 0;
}</code></pre>
<p></p>
<p><img alt="3be9d4aea32e4de8a4e47ec644828592.png" src="https://img-blog.csdnimg.cn/3be9d4aea32e4de8a4e47ec644828592.png"/></p>
<p></p>
<p>tips：初始化时别名的引用对象为num_1，尽管后面又被“貌似”的引用num_2,但其只是赋值操作。究其根本就是，别名的赋值操作改变了num_1的值，但并不能改变别名的引用对象。</p>
<p></p>
<p>指针举例</p>
<p></p>
<pre><code class="language-cpp">int main()
{
       int num_1 = 10;
       int num_2 = 20;
       cout &lt;&lt; "num_1：" &lt;&lt; &amp;num_1 &lt;&lt; "  " &lt;&lt; "num_2：" &lt;&lt; &amp;num_2 &lt;&lt; endl;
       int* pre = &amp;num_1;
       cout &lt;&lt; "pre初始化指向的实体地址：" &lt;&lt; " " &lt;&lt; pre &lt;&lt; endl;
       pre = &amp;num_2;
       cout &lt;&lt; "pre改变指向的实体地址：" &lt;&lt; "   " &lt;&lt; pre &lt;&lt; endl;
       return 0;
}</code></pre>
<p></p>
<p><img alt="d40332b01b934639a51c414bf59174c4.png" src="https://img-blog.csdnimg.cn/d40332b01b934639a51c414bf59174c4.png"/></p>
<p></p>
<p>tips:指针确实可以任意修改指向，而引用则不可以随意改变实体。</p>
<p></p>
<p><strong>4.在sizeof操作符中的含义不同，引用的大小取决于引用对象的类型大小，指针的大小取决于系统环境，32位平台下指针大小为：4字节，64位平台下指针大小为：8字节。</strong></p>
<p></p>
<pre><code class="language-cpp">int main()
{
       short num = 2;
       short&amp; pre = num;//引用的大小取决于引用对象的类型大小
       short* p = &amp;num;//指针的大小取决于环境
       cout &lt;&lt; "pre:" &lt;&lt; sizeof(pre) &lt;&lt; "  " &lt;&lt; "p：" &lt;&lt; sizeof(p) &lt;&lt; endl;
       return 0;
}</code></pre>
<p></p>
<p><img alt="afa9e2bc017c4150a2c94077e6370ae7.png" src="https://img-blog.csdnimg.cn/afa9e2bc017c4150a2c94077e6370ae7.png"/></p>
<p></p>
<p><strong>5.引用进行自加的效果会让引用对象的值增加1，指针的自加会让指针向后偏移一个类型大小。</strong></p>
<p></p>
<pre><code class="language-cpp">int main()
{
       int num = 5;
       int&amp; pre = num;
       int* p = &amp;num;
       cout &lt;&lt; "pre:" &lt;&lt; ++pre &lt;&lt; "  " &lt;&lt; "p:" &lt;&lt; ++p &lt;&lt; endl;
       //pre++表示引用对象值自加1，指针自加则表示向后访问一个自身类型大小的地址
       return 0;
}</code></pre>
<p></p>
<p><img alt="68a69bd28f1143849e51b85194f82958.png" src="https://img-blog.csdnimg.cn/68a69bd28f1143849e51b85194f82958.png"/></p>
<p></p>
<p><strong>6.有多级指针，但没有多级引用。</strong></p>
<p></p>
<pre><code class="language-cpp">int main()
{
       int num = 5;
       int* p = &amp;num;
       int** pp = &amp;p;//有多级指针
       int&amp; pre = num;
       int&amp; ppre = pre;//不能形成多级引用，在这只表示：给别名取一个别名
       return 0;
}</code></pre>
<p></p>
<p><strong>7.访问方式不同：指针需要显式的解引用访问，引用则可以直接使用别名访问。（编译器自己处理）</strong></p>
<p></p>
<pre><code class="language-cpp">int main()
{
       int num = 2;
       int&amp; pre = num;
       int* p = &amp;num;
       cout &lt;&lt; "pre:" &lt;&lt; pre &lt;&lt; "  " &lt;&lt; "p:" &lt;&lt; *p &lt;&lt; endl;
       //引用可直接使用别名访问实体对象，指针必须使用解引用才可访问实体对象
       return 0;
}</code></pre>
<p></p>
<p><img alt="121366004d484b2a88302c425247649f.png" src="https://img-blog.csdnimg.cn/121366004d484b2a88302c425247649f.png"/></p>
<p></p>
<p><strong>8.引用的使用比指针要安全。</strong></p>
</blockquote>
<p></p>
<p></p>
<hr/>
<h1></h1>
<h1 id="%F0%9F%8D%8A%E5%BC%95%E7%94%A8%E4%B8%8E%E6%8C%87%E9%92%88%E5%BA%95%E5%B1%82%E5%88%A8%E6%9E%90">🍊引用与指针底层刨析</h1>
<p></p>
<p>从语法角度来看，引用自身是不开辟空间，是与引用对象共用一块空间。但在底层，引用的实现却并不是如此。</p>
<p></p>
<p><strong>先说结论：引用的实现需要开辟空间，并且底层是依靠指针实现，之所以使用方法不同，在于等于引用进行了封装。</strong></p>
<p></p>
<hr/>
<h2></h2>
<h2 id="%F0%9F%8D%8A%E5%BA%95%E5%B1%82%E5%88%A8%E6%9E%90">🍊底层刨析</h2>
<p></p>
<p><strong>代码：</strong></p>
<pre><code class="language-cpp">int main()
{
       int num = 20;
       int&amp; pre = num;
       pre = 30;
       int* p = &amp;num;
       *p = 40;
       return 0;
}</code></pre>
<p></p>
<p><strong>汇编：</strong></p>
<p></p>
<pre><code class="language-cpp">       int num = 20;
005F1FDF  mov         dword ptr [num],14h 
       int&amp; pre = num;
005F1FE6  lea         eax,[num] 
005F1FE9  mov         dword ptr [pre],eax 
       pre = 30;
005F1FEC  mov         eax,dword ptr [pre] 
005F1FEF  mov         dword ptr [eax],1Eh 
       int* p = &amp;num;
005F1FF5  lea         eax,[num] 
005F1FF8  mov         dword ptr [p],eax 
       *p = 40;
005F1FFB  mov         eax,dword ptr [p] 
005F1FFE  mov         dword ptr [eax],28h</code></pre>
<p></p>
<hr/>
<h3></h3>
<h3 id="%F0%9F%8D%8A%E6%B1%87%E7%BC%96%E8%A7%A3%E8%AF%BB">🍊汇编解读</h3>
<p></p>
<blockquote>
<pre><code class="language-cpp">       int num = 20;
005F1FDF  mov         dword ptr [num],14h </code></pre>
<p></p>
<p>首先创建一个四个字节的空间用于存储整形。dword表示：d指的是double（双倍），word表示两个字节，共四个字节，num是变量名，将八进制的20存进变量中。（mov）代表移动。</p>
</blockquote>
<p></p>
<hr/>
<p></p>
<h3 id="%F0%9F%8D%8A%E5%BC%95%E7%94%A8%E5%AE%9E%E7%8E%B0%E9%83%A8%E5%88%86">🍊引用实现部分</h3>
<p></p>
<blockquote>
<pre><code class="language-cpp">       int&amp; pre = num;
005F1FE6  lea         eax,[num] </code></pre>
<p></p>
<p>将num的地址存入到寄存器eax中。</p>
<p></p>
<p>lea表示：装入有效地址，操作数必须为地址。</p>
<p></p>
<p></p>
<pre><code class="language-cpp">005F1FE9  mov         dword ptr [pre],eax </code></pre>
<p></p>
<p>将寄存器eax中的值移动到pre中。</p>
<pre><code class="language-cpp">       pre = 30;
005F1FEC  mov         eax,dword ptr [pre] </code></pre>
<p></p>
<p>将pre的值移动至寄存器eax中。</p>
<p></p>
<pre><code class="language-cpp">005F1FEF  mov         dword ptr [eax],1Eh </code></pre>
<p></p>
<p>将八进制的30移动到存放pre值的寄存器eax中，相当于赋值操作。</p>
<p></p>
</blockquote>
<p></p>
<p><strong>小结：从汇编代码中，可以证实使用引用是必须开辟空间的。</strong></p>
<p></p>
<hr/>
<p></p>
<p></p>
<h3 id="%F0%9F%8D%8A%E6%8C%87%E9%92%88%E5%AE%9E%E7%8E%B0%E9%83%A8%E5%88%86">🍊指针实现部分</h3>
<p></p>
<blockquote>
<pre><code class="language-cpp">       int* p = &amp;num;
005F1FF5  lea         eax,[num] </code></pre>
<p></p>
<p>将变量num的地址存进寄存器eax中。</p>
<p></p>
<p></p>
<pre><code class="language-cpp">005F1FF8  mov         dword ptr [p],eax </code></pre>
<p></p>
<p>开辟一个四个字节的指针，将寄存器eax的值存进整形指针p中。</p>
<pre><code class="language-cpp">       *p = 40;
005F1FFB  mov         eax,dword ptr [p] </code></pre>
<p></p>
<p>将p的值移动到寄存器eax中。</p>
<p></p>
<pre><code class="language-cpp">005F1FFE  mov         dword ptr [eax],28h</code></pre>
<p></p>
<p>将八进制的40赋值给eax。</p>
<p></p>
<p><strong>小结：指针与引用的底层实现相同！</strong></p>
<p></p>
</blockquote>
<p></p>
<p></p>
<hr/>
<p></p>
<p><strong>附：指针与引用的相似处</strong></p>
<p></p>
<p>都可以用作函数参数或返回值（输出型参数、输出型返回值）。</p>
<p></p>
<p><strong>tips：</strong>引用的不可多级引用是其的缺点，体现在单链表的实现，不可以使用引用，指针更有优势。</p>
<p></p>
<p>小结：指针更为复杂，功能更为强大，可适用的场景更广，但也更为的危险。引用更加的便捷与安全，但适用性还是比指针要狭小一些。</p>
<p></p>
<hr/>
<p></p>
<blockquote>
<p style="text-align:center;"><strong>文章到这就结束啦！如果喜欢就关注Duoni叭！</strong></p>
</blockquote>
<p></p>
</div>
</div>