<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<p id="main-toc"><strong>目录</strong></p>
<p id="%E4%B8%80%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E8%AE%BE%E8%AE%A1-toc" style="margin-left:40px;"><a href="#%E4%B8%80%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E8%AE%BE%E8%AE%A1">一、结构体的设计</a></p>
<p id="%E4%BA%8C%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96">二、结构体变量的初始化</a></p>
<p id="2.1%E7%BB%93%E6%9E%84%E4%BD%93%E5%9C%A8%E5%86%85%E5%AD%98%E8%A1%A8%E7%A4%BA%EF%BC%9B-toc" style="margin-left:80px;"><a href="#2.1%E7%BB%93%E6%9E%84%E4%BD%93%E5%9C%A8%E5%86%85%E5%AD%98%E8%A1%A8%E7%A4%BA%EF%BC%9B">2.1结构体在内存表示；</a></p>
<p id="2.2%E7%BB%93%E6%9E%84%E4%BD%93%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9B-toc" style="margin-left:80px;"><a href="#2.2%E7%BB%93%E6%9E%84%E4%BD%93%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9B">2.2结构体初始化；</a></p>
<p id="%C2%A02.3%E7%BB%93%E6%9E%84%E4%BD%93%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F-toc" style="margin-left:80px;"><a href="#%C2%A02.3%E7%BB%93%E6%9E%84%E4%BD%93%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F"> 2.3结构体指针变量</a></p>
<p id="%C2%A02.4%E7%BB%93%E6%9E%84%E4%BD%93%E5%B5%8C%E5%A5%97%E7%BB%93%E6%9E%84%E4%BD%93-toc" style="margin-left:80px;"><a href="#%C2%A02.4%E7%BB%93%E6%9E%84%E4%BD%93%E5%B5%8C%E5%A5%97%E7%BB%93%E6%9E%84%E4%BD%93"> 2.4结构体嵌套结构体</a></p>
<p id="%E4%B8%89%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%C2%A0-toc" style="margin-left:40px;"><a href="#%E4%B8%89%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%C2%A0">三、结构体成员访问 </a></p>
<p id="3.1%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE-toc" style="margin-left:80px;"><a href="#3.1%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE">3.1、结构体成员访问</a></p>
<p id="3.2%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%98%E9%87%8F%E5%92%8C%E6%8C%87%E9%92%88-toc" style="margin-left:80px;"><a href="#3.2%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%98%E9%87%8F%E5%92%8C%E6%8C%87%E9%92%88">3.2、结构体变量和指针</a></p>
<p id="%E2%80%8B%C2%A03.3%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E5%87%BD%E6%95%B0%C2%A0-toc" style="margin-left:80px;"><a href="#%E2%80%8B%C2%A03.3%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E5%87%BD%E6%95%B0%C2%A0">​3.3、结构体和函数 </a></p>
<p id="%E5%9B%9B%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E6%95%B0%E7%BB%84-toc" style="margin-left:40px;"><a href="#%E5%9B%9B%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E6%95%B0%E7%BB%84">四、结构体与数组</a></p>
<p id="%E4%BA%94%E3%80%81%E8%AE%A1%E7%AE%97%E7%BB%93%E6%9E%84%E4%BD%93%E5%A4%A7%E5%B0%8F-toc" style="margin-left:40px;"><a href="#%E4%BA%94%E3%80%81%E8%AE%A1%E7%AE%97%E7%BB%93%E6%9E%84%E4%BD%93%E5%A4%A7%E5%B0%8F">五、计算结构体大小</a></p>
<p id="%E4%B8%89%E4%B8%AA%E8%A7%84%E5%88%99%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E4%B8%89%E4%B8%AA%E8%A7%84%E5%88%99%EF%BC%9A">三个规则：</a></p>
<p id="%E4%BE%8B1%E3%80%81-toc" style="margin-left:80px;"><a href="#%E4%BE%8B1%E3%80%81">例1</a>、<a href="#%E2%80%8B">​</a></p>
<p id="%C2%A0%E4%BE%8B2%E3%80%81-toc" style="margin-left:80px;"><a href="#%C2%A0%E4%BE%8B2%E3%80%81"> 例2、</a></p>
<p id="%E6%8C%87%E5%AE%9A%E5%AF%B9%E9%BD%90%E5%80%BC-toc" style="margin-left:80px;"><a href="#%E6%8C%87%E5%AE%9A%E5%AF%B9%E9%BD%90%E5%80%BC">指定对齐值</a></p>
<p id="%E6%80%BB%E7%BB%93-toc" style="margin-left:80px;"><a href="#%E6%80%BB%E7%BB%93">总结</a></p>
<hr id="hr-toc"/>
<h1>一、结构体的设计</h1>
<p>C语言提供了基本的数据结构，例如 char 、short 、int 、float....等类型；这些偶称为内置类型。怎样设计出来属于自己的类型？</p>
<p>程序员可以使用结构体来封装一些属性，设计出新的类型，在C语言中称为结构体类型。</p>
<p>结构体的定义形式为</p>
<pre><code class="language-cpp">struct 结构体名
{
   成员列表（可以是基本的数据类型，指针，数组或其他结构类型）
};</code></pre>
<p><strong>举个例子来说吧；</strong></p>
<p>客观事务（实体）是复杂的，要描述它必须从多方面进行；也就是用不同的数据类型来描述不同的方面；用学生实体来说：</p>
<p>学生拥有什么？ 学号、姓名、性别、年龄；</p>
<pre><code class="language-cpp">struct Student
{
  char s_id[8];
  char s_name[8];
  char s_sex[4];
  int s_age;
};</code></pre>
<p>注意以下几点;</p>
<p>（1）、关键字struct是数据类型说明符，指出下面说的是结构体类型；</p>
<p>（2）、标识符Student是结构体的类型名；</p>
<p>（3）、最后的分号一定要写；</p>
<h2 id="%E4%BA%8C%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96">二、结构体变量的初始化</h2>
<p>结构体是一种数据类型，也就是说可以用它来定义变量。</p>
<p>结构体就像一个“模板”，定义出来的变量都具有相同的性质。可以将结构体比作“图纸”，结构体变量比作“零件”，根据同一张图纸生产出来的零件的特性都是一样的；</p>
<p>结构体是一种数据类型，是创建变量的模板，不占用内存空间；结构体变量才包含了实实在在的数据、需要存储空间；</p>
<h3 id="2.1%E7%BB%93%E6%9E%84%E4%BD%93%E5%9C%A8%E5%86%85%E5%AD%98%E8%A1%A8%E7%A4%BA%EF%BC%9B">2.1结构体在内存表示；</h3>
<p><img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP5bCP5ZyG6IS4,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/c7f76fe2a26c4a7ca31ab92b9be54025.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP5bCP5ZyG6IS4,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<p> C语言中  struct 不可少</p>
<h3 id="2.2%E7%BB%93%E6%9E%84%E4%BD%93%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9B"><strong>2.2结构体初始化；</strong></h3>
<p><img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP5bCP5ZyG6IS4,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/a655c1efa9c4483ca9acccb7f10c8896.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP5bCP5ZyG6IS4,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<h3 id="%C2%A02.3%E7%BB%93%E6%9E%84%E4%BD%93%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F"> 2.3结构体指针变量</h3>
<p><img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP5bCP5ZyG6IS4,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/cc454bdcedc74bd08034cda36d04b6ba.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP5bCP5ZyG6IS4,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<h3 id="%C2%A02.4%E7%BB%93%E6%9E%84%E4%BD%93%E5%B5%8C%E5%A5%97%E7%BB%93%E6%9E%84%E4%BD%93"> 2.4结构体嵌套结构体</h3>
<p><img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP5bCP5ZyG6IS4,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/6a53a041c5ef42d5870134cf6349cc04.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP5bCP5ZyG6IS4,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<h2 id="%E4%B8%89%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%C2%A0">三、结构体成员访问 </h2>
<h3 id="3.1%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE">3.1、结构体成员访问</h3>
<p>结构体变量使用   <strong>.</strong>   访问；</p>
<p>结构体变量<strong>.</strong>对象</p>
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
struct Date
{
	int year;
	int month;
	int day;
};
struct Student
{
	char s_name[20];
	struct Date birthday;
	float score;
};
int main()
{
	struct Student stu = { "liuwen",2000,10,1,99.9 };
	printf("name=%s\nbirtyday=%d.%d.%d\nscore=%f\n", stu.s_name, stu.birthday.year, stu.birthday.month, stu.birthday.day, stu.score);
	stu.score = 77;
	printf("name=%s\nbirtyday=%d.%d.%d\nscore=%f\n", stu.s_name, stu.birthday.year, stu.birthday.month, stu.birthday.day, stu.score);
	return 0;</code></pre>
<h2 id="%E2%80%8B"><img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP5bCP5ZyG6IS4,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/9713d7dfbb904dd59322c6fd754435d0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP5bCP5ZyG6IS4,size_20,color_FFFFFF,t_70,g_se,x_16"/></h2>
<p><strong>注意：对结构体变量整体赋值有三种情况</strong></p>
<p> （1）定义结构体变量（用{}初始化）</p>
<p>（2）用已定义的结构体变量初始化</p>
<p>（3）结构体类型相同的变量可以作为整体相互赋值；</p>
<p><strong>在C语言中不存在结构体类型的强制转换。</strong></p>
<h3 id="3.2%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%98%E9%87%8F%E5%92%8C%E6%8C%87%E9%92%88"><strong>3.2、结构体变量和指针</strong></h3>
<p>内置类型可以定义指针变量，结构体类型也可以定义结构体类型指针；</p>
<p>结构体类型指针访问成员的获取和赋值形式：</p>
<p><strong>（1）（*p）. 成员名（.的优先级高于*，（*p）两边括号不能少）</strong></p>
<p><strong>（2）   p-&gt;成员名（-&gt;指向符）</strong></p>
<p>示例：</p>
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
//#define _CRT_SECURE_NO_WARNINGS
struct Inventory//商品
{
	char description[20];//货物名
	int quantity;//库存数据
};
int main()
{
	struct Inventory sta = { "iphone",20 };
	struct Inventory* stp = &amp;sta;
	char name[20] = { 0 };
	int num = 0;
	(*stp).quantity = 30;
	stp-&gt;quantity = 30;
	strcpy_s(name,sizeof(stp-&gt;description),stp-&gt;description);
	printf("%s %d\n", stp-&gt;description, stp-&gt;quantity);
	printf("%s %d\n", (*stp).description, (*stp).quantity);
	return 0;
}</code></pre>
<h2><img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP5bCP5ZyG6IS4,size_15,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/420e92ce264248f3bd7730b36bac5d09.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP5bCP5ZyG6IS4,size_15,color_FFFFFF,t_70,g_se,x_16"/></h2>
<h3 id="%E2%80%8B%C2%A03.3%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E5%87%BD%E6%95%B0%C2%A0"><img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP5bCP5ZyG6IS4,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/43035c2eb19e4f849afe87662f890c94.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP5bCP5ZyG6IS4,size_20,color_FFFFFF,t_70,g_se,x_16"/> 3.3、结构体和函数 </h3>
<p>示例：</p>
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#define _CRT_SECURE_NO_WARNINGS
struct School
{
	char s_name[20];//学校
	int s_age;
};
void Print_a(struct School sx)
{
	printf("%s %d\n", sx.s_name, sx.s_age);
}
void Print_c(struct School* sp)
{
	printf("%s %d\n", sp-&gt;s_name, sp-&gt;s_age);
}
int main()
{
	struct School sx = { "xi'an",100 };
	Print_a(sx);
	Print_c(&amp;sx);
	return 0;
}</code></pre>
<h2><img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP5bCP5ZyG6IS4,size_13,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/eaf5225077e14e1c9e8513b50f4ded88.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP5bCP5ZyG6IS4,size_13,color_FFFFFF,t_70,g_se,x_16"/></h2>
<p> 内存什么的看上面；</p>
<p>两种传参那个更好？通过内存可以看出来；</p>
<h2 id="%E5%9B%9B%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E6%95%B0%E7%BB%84">四、结构体与数组</h2>
<p><strong>结构体数组，是指数组中的每一个元素都是一个结构体类型。</strong>在实际应用中，C语言结构体数组常被用来表示有相同的数据结构的群体，比如一个班的学生，一个公司的员工等；</p>
<p>例如：</p>
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#define _CRT_SECURE_NO_WARNINGS
struct Student
{
	char s_name[20];//姓名
	int age;//年龄
	float score;//成绩
};
int main()
{
	struct Student cla[] =
	{
		{"liuwen",18,149.9},
		{"qnge",18,145},
		{"anan",19,188},
	};
	return 0;
}
</code></pre>
<h2 id="%E4%BA%94%E3%80%81%E8%AE%A1%E7%AE%97%E7%BB%93%E6%9E%84%E4%BD%93%E5%A4%A7%E5%B0%8F">五、计算结构体大小</h2>
<h3 id="%E4%B8%89%E4%B8%AA%E8%A7%84%E5%88%99%EF%BC%9A">三个规则：</h3>
<p>（1）、结构体变量的首地址，必须是结构体变量的“最大基本数据类型成员所占字节数”的整数倍；</p>
<p>（2）结构体变量中的每个成员相对于结构体首地址的偏移量，都是该成员基本数据类型所占字节数的整数倍；</p>
<p>（3）、结构体变量的总大小，为结构体变量中“最大基本数据类型成员所占字节”的整数倍；</p>
<p>示例：<strong>假设总零地址开始（计算）</strong></p>
<h3 id="%E4%BE%8B1%E3%80%81"><strong>例1、</strong></h3>
<pre><code class="language-cpp">struct node
{
	char cha;
	int ia;
	char chb;
};
int main()
{
	int size = 0;
	struct node sd = { 'a',2,'b' };
	printf("%d\n", sizeof(struct node));//12
	return 0;
}</code></pre>
<p><img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP5bCP5ZyG6IS4,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/a9ee6c12c1734b0c9bd8d8effd69cb17.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP5bCP5ZyG6IS4,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<h3><img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP5bCP5ZyG6IS4,size_12,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/2517e87eb97a4270a9f57788fc5ca012.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP5bCP5ZyG6IS4,size_12,color_FFFFFF,t_70,g_se,x_16"/></h3>
<h3 id="%C2%A0%E4%BE%8B2%E3%80%81"> 例2、</h3>
<pre><code class="language-cpp">struct node
{
	char cha;
	char chb;
	int ia;
};
int main()
{
	int size = 0;
	struct node sd = { 'a','b',2 };
	printf("%d\n", sizeof(struct node));//12
	return 0;
}</code></pre>
<p><img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP5bCP5ZyG6IS4,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/352ce255353f47418a7b03d93ef99eb5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP5bCP5ZyG6IS4,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<p><img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP5bCP5ZyG6IS4,size_12,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/b9f0c21ac3a84842aef9ad098109a22c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP5bCP5ZyG6IS4,size_12,color_FFFFFF,t_70,g_se,x_16"/></p>
<p><strong>为什么要理解字节对齐问题?</strong></p>
<p>(1)内存大小的基本单位是字节(byte),理论上来讲，可以从任意地址访问变量,但是实际上, cup并非逐字节读写内存，而是以2,4,或8的倍数的字节块来读写内存，因此就会对基本数据类型的地址作出一些限制， 即它的地址必须是2, 4或8的倍数。那么就要求各种数据类型按照一定的规则在空间. 上排列，这就是对齐。</p>
<p>(2)有些平台每次读都是从偶地址开始，如果一个int 型(假设为32位系统)如果存放在偶地址开始的地方那么一个读周期就可以读出这32bit,而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数据。显然在读取效率上下降很多。</p>
<p>(3)由于不同平台对齐方式可能不同，如此一来,同样的结构在不同的平台其大小可能不同，在无意识的情况下,互相发送的数据可能出现错乱，甚至引|发严重的问题。</p>
<h3 id="%E6%8C%87%E5%AE%9A%E5%AF%B9%E9%BD%90%E5%80%BC">指定对齐值</h3>
<p>预处理指令# pragma pack(n)可以改变默认对齐数。n取值是1,2, 4,8, 16。</p>
<h3 id="%E6%80%BB%E7%BB%93">总结</h3>
<p>1)结构体变量的首地址，必须是MIN{"<strong>结构体最大基本数据类型成员所占字节数</strong>",指定对齐方式}大小的整数倍。<br/> 2)结构体每个成员相对于结构体首地址的偏移量，都是MIN{<!-- --><strong>基本数据类型成员,指定对齐方式</strong>}大小的整数倍。<br/> 3)结构体的总大小，为MIN{结构体“<strong>最大基本数据类型成员所占字节数</strong>”(将嵌套结构体里的基本类型也算上,得出最大基本数据类型成员所占字节数)，指定对齐方式} 大小的整数倍。<br/>  </p>
<h3><br/>  </h3>
<p></p>
</div>
</div>