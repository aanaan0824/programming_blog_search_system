<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<div>
<p id="main-toc"><strong>目录</strong></p>
<p id="%C2%A01.%20%E5%9B%BA%E5%AE%9A%E6%95%B0%E9%87%8F%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0-toc" style="margin-left:40px;"><a href="#%C2%A01.%20%E5%9B%BA%E5%AE%9A%E6%95%B0%E9%87%8F%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0"> 1. 固定数量的线程池</a></p>
<p id="a.%C2%A0%C2%A0%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C-toc" style="margin-left:80px;"><a href="#a.%C2%A0%C2%A0%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C">a.  线程池返回结果</a></p>
<p id="b.%C2%A0%E2%BE%83%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%90%8D%E7%A7%B0%E6%88%96%E4%BC%98%E5%85%88%E7%BA%A7-toc" style="margin-left:80px;"><a href="#b.%C2%A0%E2%BE%83%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%90%8D%E7%A7%B0%E6%88%96%E4%BC%98%E5%85%88%E7%BA%A7">b. ⾃定义线程池名称或优先级</a></p>
<p id="2.%20%E5%B8%A6%E7%BC%93%E5%AD%98%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0-toc" style="margin-left:40px;"><a href="#2.%20%E5%B8%A6%E7%BC%93%E5%AD%98%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0">2. 带缓存的线程池</a></p>
<p id="3.%C2%A0%E6%89%A7%E2%BE%8F%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1-toc" style="margin-left:40px;"><a href="#3.%C2%A0%E6%89%A7%E2%BE%8F%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1">3. 执⾏定时任务</a></p>
<p id="a.%C2%A0%E5%BB%B6%E8%BF%9F%E6%89%A7%E2%BE%8F(%E2%BC%80%E6%AC%A1)-toc" style="margin-left:80px;"><a href="#a.%C2%A0%E5%BB%B6%E8%BF%9F%E6%89%A7%E2%BE%8F%28%E2%BC%80%E6%AC%A1%29">a. 延迟执⾏(⼀次)</a></p>
<p id="b.%C2%A0%E5%9B%BA%E5%AE%9A%E9%A2%91%E7%8E%87%E6%89%A7%E2%BE%8F-toc" style="margin-left:80px;"><a href="#b.%C2%A0%E5%9B%BA%E5%AE%9A%E9%A2%91%E7%8E%87%E6%89%A7%E2%BE%8F">b. 固定频率执⾏</a></p>
<p id="c.%20scheduleAtFixedRate%20VS%20scheduleWithFixedDelay-toc" style="margin-left:80px;"><a href="#c.%20scheduleAtFixedRate%20VS%20scheduleWithFixedDelay">c. scheduleAtFixedRate VS scheduleWithFixedDelay</a></p>
<p id="4.%C2%A0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%8D%95%E7%BA%BF%E7%A8%8B-toc" style="margin-left:40px;"><a href="#4.%C2%A0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%8D%95%E7%BA%BF%E7%A8%8B">4. 定时任务单线程</a></p>
<p id="5.%C2%A0%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0-toc" style="margin-left:40px;"><a href="#5.%C2%A0%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0">5. 单线程线程池</a></p>
<p id="6.%C2%A0%E6%A0%B9%E6%8D%AE%E5%BD%93%E5%89%8DCPU%E2%BD%A3%E6%88%90%E7%BA%BF%E7%A8%8B%E6%B1%A0-toc" style="margin-left:40px;"><a href="#6.%C2%A0%E6%A0%B9%E6%8D%AE%E5%BD%93%E5%89%8DCPU%E2%BD%A3%E6%88%90%E7%BA%BF%E7%A8%8B%E6%B1%A0">6. 根据当前CPU⽣成线程池</a></p>
<p id="7.%C2%A0ThreadPoolExecutor%EF%BC%88%E7%9C%8B%E4%B8%8B%E4%B8%80%E7%AF%87%EF%BC%89-toc" style="margin-left:40px;"><a href="#7.%C2%A0ThreadPoolExecutor%EF%BC%88%E7%9C%8B%E4%B8%8B%E4%B8%80%E7%AF%87%EF%BC%89">7. ThreadPoolExecutor</a></p>
<hr id="hr-toc"/>
<p></p>
</div>
<div>
<span style="color:#262626;">线程池的创建⽅法总共有 </span>
<span style="color:#262626;">7 </span>
<span style="color:#262626;">种，但总体来说可分为 </span>
<span style="color:#262626;">2 </span>
<span style="color:#262626;">类：</span>
</div>
<div>
<blockquote>
<div>
<span style="color:#ff9900;"><strong><em>        1. 通过 ThreadPoolExecutor 创建的线程池； </em></strong></span>
</div>
<div>
<span style="color:#ff9900;"><strong><em>        2. 通过 Executors 创建的线程池。 </em></strong></span>
</div>
</blockquote>
<div></div>
<div>
<div>
<span style="color:#262626;">线程池的创建⽅式总共包含以下 </span>
<span style="color:#262626;">7 </span>
<span style="color:#262626;">种（其中 </span>
<span style="color:#262626;">6 </span>
<span style="color:#262626;">种是通过 </span>
<span style="color:#262626;">Executors </span>
<span style="color:#262626;">创建的，</span>
<span style="color:#262626;">1 </span>
<span style="color:#262626;">种是通过 </span>
</div>
<div>
<span style="color:#262626;">ThreadPoolExecutor 创建的）： </span>
</div>
<div>
<blockquote>
<div>
<span style="color:#262626;">        1. Executors.newFixedThreadPool：创建⼀个固定⼤⼩的线程池，可控制并发的线程数，超出的线程会在队列中等待； </span>
</div>
<div>
<span style="color:#262626;">        2. Executors.newCachedThreadPool：创建⼀个可缓存的线程池，若线程数超过处理所需，缓存⼀段时间后会回收，若线程数不够，则新建线程； </span>
</div>
<div>
<span style="color:#262626;">        3. Executors.newSingleThreadExecutor：创建单个线程数的线程池，它可以保证先进先出的执⾏顺序； </span>
</div>
<div>
<span style="color:#262626;">        4. Executors.newScheduledThreadPool：创建⼀个可以执⾏延迟任务的线程池； </span>
</div>
<div>
<span style="color:#262626;">        5. Executors.newSingleThreadScheduledExecutor：创建⼀个单线程的可以执⾏延迟任务的线程池； </span>
</div>
<div>
<p></p>
<div>
<span style="color:#262626;">        6. Executors.newWorkStealingPool：创建⼀个抢占式执⾏的线程池（任务执⾏顺序不确定）【JDK1.8 </span>
<span style="color:#262626;">添加】。 </span>
</div>
<div>
<span style="color:#262626;">        7. ThreadPoolExecutor：最原始的创建线程池的⽅式，它包含了 </span>
<span style="color:#262626;">7 </span>
<span style="color:#262626;">个参数可供设置，后⾯会详细讲。 </span>
</div>
</div>
</blockquote>
</div>
</div>
</div>
<h2 id="%C2%A01.%20%E5%9B%BA%E5%AE%9A%E6%95%B0%E9%87%8F%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0"> 1. 固定数量的线程池</h2>
<pre><code class="language-java">public class ThreadPoolDemo3 {
    public static void main(String[] args) {
        ExecutorService threadPool = Executors.newFixedThreadPool(2);
        //添加任务方式 1
        threadPool.submit(new Runnable() {
            @Override
            public void run() {
                System.out.println(Thread.currentThread().getName());
            }
        });

        //添加任务方式2
        threadPool.execute(new Runnable() {
            @Override
            public void run() {
                System.out.println(Thread.currentThread().getName());
            }
        });
    }
}
输出：
pool-1-thread-1
pool-1-thread-2</code></pre>
<h3 id="a.%C2%A0%C2%A0%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C">a.  <span style="color:#262626;">线程池返回结果 </span></h3>
<pre><code class="language-java">public class ThreadPoolDemo4 {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        ExecutorService threadPool =  Executors.newFixedThreadPool(2);
        //执行任务
        Future&lt;Integer&gt; result = threadPool.submit(new Callable&lt;Integer&gt;() {
            @Override
            public Integer call() throws Exception {
                int num = new Random().nextInt(10);
                System.out.println("随机数" + num);
                return num;
            }
        });

        //打印线程池返回方式
        System.out.println("返回结果：" + result.get());
    }
}
输出
随机数8
返回结果：8</code></pre>
<blockquote>
<p><em><span style="color:#ff9900;"><strong>使用submit可以执行有返回值的任务或者是无返回值的任务；而execute只能执行不带返回值的任务。 </strong></span></em></p>
</blockquote>
<p></p>
<p class="img-center"><img alt="" height="173" src="image\58160ec92ac147ba94e6960e0382b13c.png" width="522"/></p>
<p></p>
<h3 id="b.%C2%A0%E2%BE%83%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%90%8D%E7%A7%B0%E6%88%96%E4%BC%98%E5%85%88%E7%BA%A7">b. <span style="color:#262626;">⾃定义线程池名称或优先级 </span></h3>
<pre><code class="language-java">public class ThreadPoolDemo5 {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
         // 创建线程工厂
        ThreadFactory threadFactory = new ThreadFactory() {
            @Override
            public Thread newThread(Runnable r) {
                //！！！！！！！一定要注意：要把任务Runnable设置给新创建的线程
                Thread thread = new Thread(r);
                //设置线程的命名规则
                thread.setName("我的线程" + r.hashCode());
                //设置线程的优先级
                thread.setPriority(Thread.MAX_PRIORITY);
                return thread;
            }
        };
        ExecutorService threadPool = Executors.newFixedThreadPool(2,threadFactory);
        //执行任务1
        Future&lt;Integer&gt; result = threadPool.submit(new Callable&lt;Integer&gt;() {
            @Override
            public Integer call() throws Exception {
                int num = new Random().nextInt(10);
                System.out.println(Thread.currentThread().getPriority() + ", 随机数：" + num);
                return num;
            }
        });
        //打印线程池返回结果
        System.out.println("返回结果：" + result.get());
    }
}
</code></pre>
<blockquote>
<p> 提供的功能：</p>
<p><em><strong><span style="color:#ff9900;">        1. 设置（线程池中）线程的命名规则。</span></strong></em></p>
<p><em><strong><span style="color:#ff9900;">        2. 设置线程的优先级。</span></strong></em></p>
<p><em><strong><span style="color:#ff9900;">        3. 设置线程分组。</span></strong></em></p>
<p><em><strong><span style="color:#ff9900;">        4. 设置线程类型（用户线程、守护线程）。</span></strong></em></p>
</blockquote>
<h2 id="2.%20%E5%B8%A6%E7%BC%93%E5%AD%98%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0">2. <span style="color:#262626;">带缓存的线程池 </span></h2>
<pre><code class="language-java">public class ThreadPoolDemo6 {
    public static void main(String[] args) {
        //创建线程池
        ExecutorService service = Executors.newCachedThreadPool();
        for (int i = 0; i &lt; 10; i++) {
            int finalI = i;
            service.submit(() -&gt; {
                System.out.println("i : " + finalI + "|线程名称：" + Thread.currentThread().getName());
            });
        }
    }
}
输出
i : 1|线程名称：pool-1-thread-2
i : 4|线程名称：pool-1-thread-5
i : 3|线程名称：pool-1-thread-4
i : 5|线程名称：pool-1-thread-6
i : 0|线程名称：pool-1-thread-1
i : 2|线程名称：pool-1-thread-3
i : 6|线程名称：pool-1-thread-7
i : 7|线程名称：pool-1-thread-8
i : 8|线程名称：pool-1-thread-9
i : 9|线程名称：pool-1-thread-1</code></pre>
<blockquote>
<p><em><span style="color:#ff9900;"><strong> 优点：线程池会根据任务数量创建线程池，并且在一定时间内可以重复使用这些线程，产生相应的线程池。</strong></span></em></p>
<p><em><span style="color:#ff9900;"><strong>缺点：适用于短时间有大量任务的场景，它的缺点是可能会占用很多的资源。</strong></span></em></p>
</blockquote>
<h2 id="3.%C2%A0%E6%89%A7%E2%BE%8F%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1">3. <span style="color:#262626;">执⾏定时任务</span></h2>
<h3 id="a.%C2%A0%E5%BB%B6%E8%BF%9F%E6%89%A7%E2%BE%8F(%E2%BC%80%E6%AC%A1)"><span style="color:#262626;">a. 延迟执⾏(⼀次) </span></h3>
<pre><code class="language-java">public class ThreadPoolDemo7 {
    public static void main(String[] args) {
        //创建线程池
        ScheduledExecutorService service = Executors.newScheduledThreadPool(5);
        System.out.println("添加任务的时间：" + LocalDateTime.now());
        //执行定时任务（延迟3s执行）只执行一次
        service.schedule(new Runnable() {
            @Override
            public void run() {
                System.out.println("执行子任务：" + LocalDateTime.now());
            }
        },3, TimeUnit.SECONDS);
    }
}
输出
添加任务的时间：2022-04-13T14:19:39.983
执行子任务：2022-04-13T14:19:42.987</code></pre>
<p class="img-center"><img alt="" height="213" src="image\1bb6de00a83b4a03a0ab714a459f7b41.png" width="538"/></p>
<p>  </p>
<h3 id="b.%C2%A0%E5%9B%BA%E5%AE%9A%E9%A2%91%E7%8E%87%E6%89%A7%E2%BE%8F"><span style="color:#262626;">b. 固定频率执⾏ </span></h3>
<pre><code class="language-java">public class ThreadPoolDemo8 {
    public static void main(String[] args) {
        //创建线程池
        ScheduledExecutorService service = Executors.newScheduledThreadPool(5);
        System.out.println("添加任务时间：" + LocalDateTime.now());
        //2s之后开始执行定时任务，定时任务每隔4s执行一次
        service.scheduleAtFixedRate(new Runnable() {
            @Override
            public void run() {
                System.out.println("执行任务：" + LocalDateTime.now());
            }
        },2,4, TimeUnit.SECONDS);
    }
}
输出
添加任务时间：2022-04-13T14:24:38.810
执行任务：2022-04-13T14:24:40.814
执行任务：2022-04-13T14:24:44.814
执行任务：2022-04-13T14:24:48.813
执行任务：2022-04-13T14:24:52.815
执行任务：2022-04-13T14:24:56.813
执行任务：2022-04-13T14:25:00.813
执行任务：2022-04-13T14:25:04.814
执行任务：2022-04-13T14:25:08.813
... ...
... ...
执行任务：2022-04-13T14:26:44.814
执行任务：2022-04-13T14:26:48.813</code></pre>
<p class="img-center"><img alt="" height="204" src="image\d302cc93fa734ee38fdb96c4ec0d0abb.png" width="558"/></p>
<p></p>
<p><strong><span style="color:#fe2c24;"> 注意事项：</span></strong></p>
<pre><code class="language-java">public class ThreadPoolDemo9 {
    public static void main(String[] args) {
        //创建线程池
        ScheduledExecutorService service = Executors.newScheduledThreadPool(5);
        System.out.println("添加任务时间：" + LocalDateTime.now());
        service.scheduleAtFixedRate(new Runnable() {
            @Override
            public void run() {
                System.out.println("执行任务： " + LocalDateTime.now());
                try {
                    Thread.sleep(5 * 1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        },2,4, TimeUnit.SECONDS);
    }
}
输出
添加任务时间：2022-04-13T14:33:34.551
执行任务： 2022-04-13T14:33:36.556
执行任务： 2022-04-13T14:33:41.557
执行任务： 2022-04-13T14:33:46.559
执行任务： 2022-04-13T14:33:51.561
执行任务： 2022-04-13T14:33:56.562
执行任务： 2022-04-13T14:34:01.564
执行任务： 2022-04-13T14:34:06.566
执行任务： 2022-04-13T14:34:11.566
执行任务： 2022-04-13T14:34:16.567
执行任务： 2022-04-13T14:34:21.570
执行任务： 2022-04-13T14:34:26.570
... ....</code></pre>
<p class="img-center"><img alt="" height="208" src="image\6b542f145d6941fb89a3c9f3c874bf23.png" width="609"/></p>
<p></p>
<p class="img-center"><img alt="" height="202" src="image\2d69c80bb6634055871a2b7fa81b5720.png" width="605"/></p>
<p></p>
<h3 id="c.%20scheduleAtFixedRate%20VS%20scheduleWithFixedDelay"><span style="color:#262626;">c. scheduleAtFixedRate VS scheduleWithFixedDelay </span></h3>
<p></p>
<blockquote>
<div>
<em><span style="color:#ff9900;"><strong>scheduleAtFixedRate 是以上⼀次任务的开始时间，作为下次定时任务的参考时间的（参考时间+延迟任务=任务执⾏）。 </strong></span></em>
</div>
<div></div>
<div>
<em><span style="color:#ff9900;"><strong>scheduleWithFixedDelay 是以上⼀次任务的结束时间，作为下次定时任务的参考时间的。</strong></span></em>
<span style="color:#262626;"> </span>
</div>
</blockquote>
<pre><code class="language-java">public class ThreadPoolDemo10 {
    public static void main(String[] args) {
        //创建线程池
        ScheduledExecutorService service = Executors.newScheduledThreadPool(5);
        System.out.println("添加任务时间：" + LocalDateTime.now());
        //2s之后开始执行定时任务，定时任务每隔4s执行一次
        service.scheduleWithFixedDelay(new Runnable() {
            @Override
            public void run() {
                System.out.println("执行任务：" + LocalDateTime.now());
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, 2, 4, TimeUnit.SECONDS);
    }
}
输出
添加任务时间：2022-04-13T14:46:02.871
执行任务：2022-04-13T14:46:04.876
执行任务：2022-04-13T14:46:09.878
执行任务：2022-04-13T14:46:14.880
执行任务：2022-04-13T14:46:19.883
执行任务：2022-04-13T14:46:24.885
执行任务：2022-04-13T14:46:29.888
执行任务：2022-04-13T14:46:34.888
执行任务：2022-04-13T14:46:39.891
执行任务：2022-04-13T14:46:44.893
执行任务：2022-04-13T14:46:49.895
执行任务：2022-04-13T14:46:54.897
执行任务：2022-04-13T14:46:59.900
执行任务：2022-04-13T14:47:04.901
... ...
</code></pre>
<p></p>
<p class="img-center"><img alt="" height="166" src="image\06ff563acbad4eb284f6916c862a1fcf.png" width="521"/></p>
<p></p>
<h2 id="4.%C2%A0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%8D%95%E7%BA%BF%E7%A8%8B"><span style="color:#262626;">4. 定时任务单线程</span></h2>
<pre><code class="language-java">public class ThreadPoolDemo11 {
    public static void main(String[] args) {
        ScheduledExecutorService service = Executors.newSingleThreadScheduledExecutor();
        System.out.println("添加任务的时间:" + LocalDateTime.now());
        service.schedule(new Runnable() {
            @Override
            public void run() {
                System.out.println("执行时间：" + LocalDateTime.now());
            }
        },2, TimeUnit.SECONDS );
    }
}
输出
添加任务的时间:2022-04-13T15:06:38.100
执行时间：2022-04-13T15:06:40.106</code></pre>
<h2 id="5.%C2%A0%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span style="color:#262626;">5. 单线程线程池</span></h2>
<pre><code class="language-java">public class ThreadPoolDemo12 {
    public static void main(String[] args) {
        ExecutorService service = Executors.newSingleThreadScheduledExecutor();
        for (int i = 0; i &lt; 10; i++) {
            service.submit(new Runnable() {
                @Override
                public void run() {
                    System.out.println("线程名：" + Thread.currentThread().getName());
                }
            });
        }
    }
}
输出
线程名：pool-1-thread-1
线程名：pool-1-thread-1
线程名：pool-1-thread-1
线程名：pool-1-thread-1
线程名：pool-1-thread-1
线程名：pool-1-thread-1
线程名：pool-1-thread-1
线程名：pool-1-thread-1
线程名：pool-1-thread-1
线程名：pool-1-thread-1
</code></pre>
<p><em><span style="color:#fe2c24;"><strong>（MS） 为什么不直接用线程？</strong></span></em></p>
<blockquote>
<p><em><span style="color:#fe2c24;"><strong>单线程的线程池又什么意义？</strong></span></em></p>
<p><em><span style="color:#fe2c24;"><strong>        1. 复用线程。</strong></span></em></p>
<p><em><span style="color:#fe2c24;"><strong>        2. 单线程的线程池提供了任务队列和拒绝策略（当任务队列满了之后（Integer.MAX_VALUE），新来的任务就会拒绝策略）</strong></span></em></p>
</blockquote>
<h2 id="6.%C2%A0%E6%A0%B9%E6%8D%AE%E5%BD%93%E5%89%8DCPU%E2%BD%A3%E6%88%90%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span style="color:#262626;">6. </span><span style="color:#262626;">根据当前CPU⽣成线程池</span></h2>
<pre><code class="language-java">public class ThreadPoolDemo13 {
    public static void main(String[] args) {
        ExecutorService service = Executors.newWorkStealingPool();
        for (int i = 0; i &lt; 10; i++) {
            service.submit(() -&gt; {
                System.out.println("线程名" + Thread.currentThread().getName());
            });
            
            while(!service.isTerminated()) {
            }
        }
    }
}
输出
线程名ForkJoinPool-1-worker-1</code></pre>
<h2 id="7.%C2%A0ThreadPoolExecutor%EF%BC%88%E7%9C%8B%E4%B8%8B%E4%B8%80%E7%AF%87%EF%BC%89"><span style="color:#262626;">7. </span><span style="color:#262626;">ThreadPoolExecutor</span></h2>
<p><a class="has-card" href="https://blog.csdn.net/m0_48273471/article/details/124171220" title="线程池的使用（7种创建方法）_Youcan.的博客-CSDN博客"><span class="link-card-box"><span class="link-title">线程池的使用（7种创建方法）_Youcan.的博客-CSDN博客</span><span class="link-link"><img alt="" class="link-link-icon" src="https://g.csdnimg.cn/static/logo/favicon32.ico"/>https://blog.csdn.net/m0_48273471/article/details/124171220</span></span></a></p>
<p></p>
</div>
</div>