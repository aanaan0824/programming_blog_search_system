<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="markdown_views prism-atom-one-light" id="content_views">
<svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
<path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
</svg>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/b234cfa4ca5d47d293521839cf58c0d4.jpeg#pic_center"/></p>
<blockquote>
<p>🎉作者简介:👓<span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         
          博主在读机器人研究生，目前研一。对计算机后端感兴趣，喜欢
         
         
          c
         
         
          +
         
         
          +
         
         
          ,
         
         
          g
         
         
          o
         
         
          ,
         
         
          p
         
         
          y
         
         
          t
         
         
          h
         
         
          o
         
         
          n
         
         
          ,
         
         
          目前熟悉
         
         
          c
         
         
          +
         
         
          +
         
         
          ，
         
         
          g
         
         
          o
         
         
          语言，数据库，网络编程，了解分布式等相关内容
         
        
       
       
        \textcolor{orange}{博主在读机器人研究生，目前研一。对计算机后端感兴趣，喜欢c++,go,python,目前熟悉c++，go语言，数据库，网络编程，了解分布式等相关内容}
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7667em; vertical-align: -0.0833em;"></span><span class="mord cjk_fallback" style="color: orange;">博主在读机器人研究生，目前研一。对计算机后端感兴趣，喜欢</span><span class="mord mathnormal" style="color: orange;">c</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin" style="color: orange;">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord" style="color: orange;">+</span><span class="mpunct" style="color: orange;">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em; color: orange;">g</span><span class="mord mathnormal" style="color: orange;">o</span><span class="mpunct" style="color: orange;">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal" style="color: orange;">p</span><span class="mord mathnormal" style="margin-right: 0.0359em; color: orange;">y</span><span class="mord mathnormal" style="color: orange;">t</span><span class="mord mathnormal" style="color: orange;">h</span><span class="mord mathnormal" style="color: orange;">o</span><span class="mord mathnormal" style="color: orange;">n</span><span class="mpunct" style="color: orange;">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord cjk_fallback" style="color: orange;">目前熟悉</span><span class="mord mathnormal" style="color: orange;">c</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin" style="color: orange;">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord" style="color: orange;">+</span><span class="mord cjk_fallback" style="color: orange;">，</span><span class="mord mathnormal" style="margin-right: 0.0359em; color: orange;">g</span><span class="mord mathnormal" style="color: orange;">o</span><span class="mord cjk_fallback" style="color: orange;">语言，数据库，网络编程，了解分布式等相关内容</span></span></span></span></span><br/> 📃<span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         
          个人主页：
         
        
       
       
        \textcolor{gray}{个人主页：}
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord cjk_fallback" style="color: gray;">个人主页：</span></span></span></span></span> <a href="https://blog.csdn.net/weixin_45043334?spm=1011.2266.3001.5343">小呆鸟_coding</a><br/> 🔎<span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         
          支持
         
         
          :
         
        
       
       
        \textcolor{gray}{支持:}
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord cjk_fallback" style="color: gray;">支持</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel" style="color: gray;">:</span></span></span></span></span><span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         
          如果觉得博主的文章还不错或者您用得到的话，可以免费的关注一下博主，如果三连收藏支持就更好啦
         
        
       
       
        \textcolor{green}{如果觉得博主的文章还不错或者您用得到的话，可以免费的关注一下博主，如果三连收藏支持就更好啦}
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord cjk_fallback" style="color: green;">如果觉得博主的文章还不错或者您用得到的话，可以免费的关注一下博主，如果三连收藏支持就更好啦</span></span></span></span></span>👍<span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         
          就是给予我最大的支持！
         
        
       
       
        \textcolor{green}{就是给予我最大的支持！}
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord cjk_fallback" style="color: green;">就是给予我最大的支持！</span></span></span></span></span>🎁<br/> 💛本文摘要💛</p>
<table><tbody><tr><td bgcolor="Pink">本专栏主要是对c++ primer这本圣经的总结，以及每章的相关笔记。目前正在复习这本书。同时希望能够帮助大家一起，学完这本书。 本文主要讲解第9章 顺序容器 </td></tr></tbody></table>
<p></p>
<div class="toc">
<h3>文章目录</h3>
<ul><li><ul><li><a href="#91__14">❄️9.1 顺序容器概述</a></li><li><a href="#92__45">❄️9.2 容器库概述</a></li><li><ul><li><a href="#921__94">⛄️9.2.1 迭代器</a></li><li><a href="#923_begin__end__106">⛄️9.2.3 begin 和 end 成员</a></li><li><a href="#924__116">⛄️9.2.4 容器定义和初始化</a></li><li><a href="#925_swap_178">⛄️9.2.5 赋值和swap</a></li><li><a href="#926__213">⛄️9.2.6 容器大小操作</a></li></ul>
</li><li><a href="#93__227">❄️9.3 顺序容器操作</a></li><li><ul><li><a href="#931__229">⛄️9.3.1 向顺序容器添加元素</a></li><li><a href="#932__274">⛄️9.3.2 访问元素</a></li><li><a href="#933__325">⛄️9.3.3 删除元素</a></li><li><a href="#934_forward_list_354">⛄️9.3.4 特殊的forward_list操作</a></li><li><a href="#935__373">⛄️9.3.5 改变容器大小</a></li><li><a href="#936__393">⛄️9.3.6 容器操作可能使迭代器失效</a></li></ul>
</li><li><a href="#94_vector_416">❄️9.4 vector对象是如何增长的</a></li><li><a href="#95_string_438">❄️9.5 额外的string操作</a></li><li><ul><li><a href="#951_string_442">⛄️9.5.1 构造string的其他方法</a></li><li><a href="#952_string_487">⛄️9.5.2 改变string的其他方法</a></li><li><a href="#953_string_534">⛄️9.5.3 string搜索操作</a></li><li><a href="#954_compare__568">⛄️9.5.4 compare 函数</a></li><li><a href="#955__582">⛄️9.5.5 数值转换</a></li></ul>
</li><li><a href="#96__603">❄️9.6 容器适配器</a></li></ul>
</li></ul>
</div>
<p></p>
</blockquote>
<h2><a id="91__14"></a>❄️9.1 顺序容器概述</h2>
<ul><li><strong>顺序容器</strong>（sequential container）：为程序员提供了控制元素存储和访问顺序的能力。这种顺序不依赖于元素的值，而是与元素加入容器时的位置相对应。</li><li>顺序容器都提供了<code>快速顺序访问元素</code>的能力。</li><li><code>所有容器都提供高效的动态内存管理</code></li></ul>
<p><strong>顺序容器类型</strong></p>
<table><thead><tr><th>容器类型</th><th align="left">介绍</th></tr></thead><tbody><tr><td><code>vector</code></td><td align="left">可变大小数组。<code>支持快速随机访问</code>。<code>在尾部插入/删除速度快</code>。</td></tr><tr><td><code>deque</code></td><td align="left">双端队列。<code>支持快速随机访问</code>。在头尾位置插入/删除速度很快。</td></tr><tr><td><code>list</code></td><td align="left"><code>双向链表</code>。<code>只支持双向顺序访问</code>。在<code>list</code>中任何位置进行插入/删除操作速度都很快。</td></tr><tr><td><code>forward_list</code></td><td align="left"><code>单向链表</code>。<code>只支持单向顺序访问</code>。在链表任何位置进行插入/删除操作速度都很快。</td></tr><tr><td><code>array</code></td><td align="left"><code>固定大小数组</code>。支持快速随机访问。不能添加或者删除元素。</td></tr><tr><td><code>string</code></td><td align="left">与<code>vector</code>相似的容器，但专门用于保存字符。<code>随机访问快</code>。在尾部插入/删除速度快。</td></tr></tbody></table>
<ul><li><code>vector\deque\string\array</code> 都是<code>顺序存储结构</code>。 list 是<code>链式存储结构</code>。但是他们都是顺序容器</li><li>farward_list 没有 size 操作</li><li>array 是一种比内置数组更好的类型。</li><li>list 的额外内存开销相比其他大很多。</li></ul>
<p><strong>容器的选择</strong></p>
<ul><li>通常使用<code>vector</code>是最好的选择，除非你有很好的理由选择其他容器。</li><li>如果有<code>很多小的元素</code>且<code>空间开销很重要</code>，不用 list</li><li>如果需要在中间位置插入/删除，用 list或forward_list</li><li>如果需要在头尾位置插入/删除，用 deque</li><li>如果需要随机访问，用 vector 或 deque</li><li>如果需要在中间位置插入，而后随机访问： 
  <ul><li>如果可以通过排序解决，就像插到尾部，而后排序</li></ul>
<ul><li>在输入阶段用 list ，输入完成后拷贝到 vector 中</li></ul> </li></ul>
<h2><a id="92__45"></a>❄️9.2 容器库概述</h2>
<pre><code class="prism language-c"><span class="token char">'类型别名'</span>
iterator
const_iterator
value_type           <span class="token comment">// 容器元素类型。定义方式： vector&lt;int&gt;::value_type</span>
reference            <span class="token comment">// 元素类型的引用。定义方式： vector&lt;int&gt;::reference</span>
const_reference      <span class="token comment">// 元素的 const 左值类型</span>
size_type
difference_type     <span class="token comment">//带符号整形，保存俩个迭代器之间的距离</span>

<span class="token char">'构造函数'</span><span class="token operator">-</span><span class="token char">'三种通用的构造函数：同类拷贝、迭代器范围初始化、列表初始化'</span>
C <span class="token function">c1</span><span class="token punctuation">(</span>c2<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 拷贝构造函数，容器类型与元素类型必须都相同</span>
C <span class="token function">c1</span><span class="token punctuation">(</span>c2<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>c2<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 要求两种元素类型可以转换即可。</span>
C c1<span class="token punctuation">{<!-- --></span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment">// 使用初始化列表，容器的大小与初始化列表一样大</span>

C <span class="token function">c</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">// 这两种接受大小参数的初始化方式只有顺序容器能用，且 string 无法使用</span>
C <span class="token function">c</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token char">'赋值与swap'</span>
c1 <span class="token operator">=</span> c2<span class="token punctuation">;</span>
c1 <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>
a<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 两种 swap 等价</span>

<span class="token char">'大小'</span>
c<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
c<span class="token punctuation">.</span><span class="token function">max_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// c 可以保存的最大元素数目，是整个内存层面的容量，不是已分配内存。不同于 caplity, caplity 只能用于 vector，queue，string</span>
c<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token char">'添加/删除元素（不适用于array）'</span>
c<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 将 args 中的元素拷贝进 c</span>
c<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>inits<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 使用 inits 构造 c 中的一个元素</span>
c<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 删除指定的元素</span>
c<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token char">'关系运算符'</span>
<span class="token operator">==</span><span class="token punctuation">;</span> <span class="token operator">!=</span><span class="token punctuation">;</span> <span class="token operator">&lt;</span><span class="token punctuation">;</span> <span class="token operator">&lt;=</span><span class="token punctuation">;</span> <span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token operator">&gt;=</span>   <span class="token comment">// 所有容器都支持相等和不等运算符。无序关联容器不支持大于小于运算符。</span>

<span class="token char">'获取迭代器'</span>
c<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
c<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> c<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 返回 const_iterator</span>

<span class="token char">'反向容器的额外成员'</span>
reverse_iterator       <span class="token comment">// 逆序迭代器，这是一个和 iterator 不同的类型</span>
const_reverse_iterator 
c<span class="token punctuation">.</span><span class="token function">rbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>c<span class="token punctuation">.</span><span class="token function">rend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
c<span class="token punctuation">.</span><span class="token function">crbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>c<span class="token punctuation">.</span><span class="token function">crend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<h3><a id="921__94"></a>⛄️9.2.1 迭代器</h3>
<ul><li>迭代器范围是<code>左闭右开</code>,<code>[begin(), end())</code></li><li><code>begin()</code>指向容器的<code>第一个元素</code>，<code>end()</code>指向容器<code>最后元素的下一位</code>，当<code>begin() == end()</code>则容器为空。</li><li>所有迭代器都可以递增，<code>forward_list</code> 不可以递减</li></ul>
<pre><code class="prism language-c">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">::</span>iterator iter <span class="token operator">=</span> vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 准确定义迭代器的方式。</span>

<span class="token char">'c++11新特性'</span>
<span class="token keyword">auto</span> iter <span class="token operator">=</span> vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<h3><a id="923_begin__end__106"></a>⛄️9.2.3 begin 和 end 成员</h3>
<pre><code class="prism language-c">c<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 返回 iterator</span>
c<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> c<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 返回 const_iterator</span>
c<span class="token punctuation">.</span><span class="token function">rbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>c<span class="token punctuation">.</span><span class="token function">rend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//反向迭代器，返回reverse_iterator</span>
c<span class="token punctuation">.</span><span class="token function">crbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>c<span class="token punctuation">.</span><span class="token function">crend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//返回const_reverse_iterator</span>
</code></pre>
<p>当不需要写访问时应该使用<code>cbegin()</code> 和 <code>cend()</code></p>
<h3><a id="924__116"></a>⛄️9.2.4 容器定义和初始化</h3>
<table><thead><tr><th align="left">操作</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left"><code>C c;</code></td><td align="left">默认构造函数，构造空容器</td></tr><tr><td align="left"><code>C c1(c2);</code>或<code>C c1 = c2;</code></td><td align="left">构造<code>c2</code>的拷贝<code>c1</code></td></tr><tr><td align="left"><code>C c(b, e)</code></td><td align="left">构造<code>c</code>，将迭代器<code>b</code>和<code>e</code>指定范围内的所有元素拷贝到<code>c</code></td></tr><tr><td align="left"><code>C c(a, b, c...)</code>或 <code>C c = {a, b, c}</code></td><td align="left">列表初始化<code>c</code></td></tr><tr><td align="left"><code>C c(n)</code></td><td align="left">只支持顺序容器，且不包括<code>array</code>，包含<code>n</code>个元素，这些元素进行了值初始化</td></tr><tr><td align="left"><code>C c(n, t)</code></td><td align="left">包含<code>n</code>个初始值为<code>t</code>的元素</td></tr></tbody></table>
<p><strong>将一个容器初始化为另一个容器的拷贝有俩种方法</strong></p>
<ol><li>直接拷贝整个容器</li><li>拷贝由一个迭代器对指定的元素范围</li></ol>
<pre><code class="prism language-c">list<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> authors <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token string">"world"</span><span class="token punctuation">,</span> <span class="token string">"xdn"</span><span class="token punctuation">}</span>
vector<span class="token operator">&lt;</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">&gt;</span> articles <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"an"</span><span class="token punctuation">,</span> <span class="token string">"the"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

list<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> <span class="token function">list2</span><span class="token punctuation">(</span>authors<span class="token punctuation">)</span>   <span class="token comment">//正确类型匹配</span>
deque<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> <span class="token function">de</span><span class="token punctuation">(</span>authors<span class="token punctuation">)</span>     <span class="token comment">//错误，容器类型不匹配</span>
vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> <span class="token function">word</span><span class="token punctuation">(</span>articles<span class="token punctuation">)</span> <span class="token comment">//错误，元素类型不匹配</span>
list<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> <span class="token function">words</span><span class="token punctuation">(</span>articles<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> articles<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 正确， const char* 类型可以转换成 string类型</span>
</code></pre>
<p><strong>注意</strong>：</p>
<ul><li>直接拷贝整个容器，<code>要求俩个容器的类型以及元素的类型必须匹配</code></li><li>拷贝迭代器范围，<code>不要求俩个容器的类型以及元素的类型必须匹配，只要元素可以进行转换就可以</code></li></ul>
<p><strong>array 初始化</strong></p>
<ul><li>定义<code>array</code>既要指定元素类型，还要指定容器大小</li></ul>
<pre><code class="prism language-c">array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token number">42</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>              <span class="token comment">// 定义一个有42个int 的数组</span>
array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token number">42</span><span class="token operator">&gt;</span><span class="token operator">::</span>size_type<span class="token punctuation">;</span>   <span class="token comment">// 定义数组类型也需要包括元素类型和大小</span>
</code></pre>
<ul><li> <p>只有顺序容器的构造函数才接受大小参数，关联容器并不支持。</p> </li><li> <p>array具有<code>固定大小</code>。</p> </li><li> <p>和其他容器不同，<code>默认构造的array是非空的</code>。</p> </li><li> <p>array 不支持普通容器的构造函数</p> </li><li> <p>array 列表初始化时，列表元素个数小于等于 array 大小，剩余元素默认初始化为 0</p> </li><li> <p>array <code>只能默认初始化或列表初始化</code>，如果定义的数组很大并且需要初始化，可以先默认初始化然后用 fill 函数填充值。</p> </li></ul>
<p><strong>array赋值</strong></p>
<ul><li>不能对内置数组拷贝或赋值，但是 array 可以。</li><li>使用一个 array 对另一个 array 赋值，需要两个array 元素类型与大小都相同。</li><li>不能用花括号列表对 array 赋值（只可以初始化）</li><li><code>要求俩个array的元素类型和大小都要一样</code></li></ul>
<pre><code class="prism language-c"><span class="token char">'数组'</span>
<span class="token keyword">int</span> digs<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">}</span>
<span class="token keyword">int</span> copy<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> digs<span class="token punctuation">;</span>    <span class="token comment">//错误,内置数组不支持拷贝或赋值</span>

<span class="token char">'array'</span>
array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token operator">&gt;</span> ar <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token operator">&gt;</span> br <span class="token operator">=</span> ar<span class="token punctuation">;</span> <span class="token comment">//正确，只要数组类型匹配即可</span>

br <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>                <span class="token comment">//错误，只能用花括号初始化，不能赋值</span>
</code></pre>
<h3><a id="925_swap_178"></a>⛄️9.2.5 赋值和swap</h3>
<ul><li>下面操作适用于所有容器。除array外</li><li>array 类型不支持assign操作，也不允许用花括号的值列表进行赋值，只能进行初始化。</li><li>对容器使用赋值运算符（除 array 外），将会使该容器的所有元素被替换。如果两个容器大小不等，赋值后都与右边容器的原大小相同。</li></ul>
<table><thead><tr><th align="left">操作</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left"><code>c1 = c2;</code></td><td align="left">将<code>c1</code>中的元素替换成<code>c2</code>中的元素</td></tr><tr><td align="left"><code>c1 = {a, b, c...}</code></td><td align="left">将<code>c1</code>中的元素替换成列表中的元素（不适用于<code>array</code>）</td></tr><tr><td align="left"><code>c1.swap(c2)</code></td><td align="left">交换<code>c1</code>和<code>c2</code>的元素</td></tr><tr><td align="left"><code>swap(c1, c2)</code></td><td align="left">等价于<code>c1.swap(c2)</code></td></tr><tr><td align="left"><code>c.assign(b, e)</code></td><td align="left">将<code>c</code>中的元素替换成迭代器<code>b</code>和<code>e</code>表示范围中的元素，<code>b</code>和<code>e</code>不能指向<code>c</code>中的元素</td></tr><tr><td align="left"><code>c.assign(il)</code></td><td align="left">将<code>c</code>中的元素替换成初始化列表<code>il</code>中的元素</td></tr><tr><td align="left"><code>c.assign(n, r)</code></td><td align="left">将<code>c</code>中的元素替换为<code>n</code>个值是<code>t</code>的元素</td></tr></tbody></table>
<p><strong>使用assign(仅顺序容器)</strong></p>
<ul><li>assign 是<code>赋值操作</code>，可以用于<code>顺序容器</code>。</li><li><code>“=” 要求两边类型相同， assign 要求只要可以转换即可</code></li></ul>
<pre><code class="prism language-c">lst<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 使用迭代器范围赋值</span>
lst<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>il<span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment">// il是一个花括号包围的元素值列表</span>
lst<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment">// 将 lst 的元素替换为 n 个 t</span>
<span class="token char">'操作等价于'</span>
lst<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
lst<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>lst<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p><strong>swap</strong></p>
<ul><li>对 <code>array</code> ，swap 交换两个 <code>array 中的元素值</code>。<code>指针、引用和迭代器绑定的元素不变</code>（值变）。</li><li>对于<code>其他容器</code>，swap 不交换元素，<code>只交换数据结构</code>，因此 swap 操作非常快。</li><li>对于 <code>string</code>，swap 后，<code>指针、引用和迭代器会失效</code>。对于其他容器，交换后指针指向了另一个容器的相同位置。迭代器并不失效</li><li><code>统一使用 swap(a,b)</code>，而非 a.swap(b)</li><li>对于 array，swap 操作的时间与元素数目成正比，对于其他容器，swap 操作的时间是常数。</li></ul>
<h3><a id="926__213"></a>⛄️9.2.6 容器大小操作</h3>
<table><thead><tr><th align="left">操作</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left"><code>c.size()</code></td><td align="left"><code>c</code>中元素的数目（不支持<code>forward_list</code>）</td></tr><tr><td align="left"><code>c.max_size()</code></td><td align="left"><code>c</code>中可保存的最大元素数目</td></tr><tr><td align="left"><code>c.empty()</code></td><td align="left">若<code>c</code>中存储了元素，返回<code>false</code>，否则返回<code>true</code></td></tr></tbody></table>
<ul><li>所有的容器都支持上面操作，只有<code>forword_list没有size()操作</code></li></ul>
<p><strong>俩个容器内的元素进行比较需要保证俩点</strong></p>
<ol><li>俩个容器必须是相同类型的容器，并且保存相同类型的元素</li><li>元素类型要支持关系运算符（例如你随便定义一个类类型，如果里面没有重载关系运算符，那么你这俩个类类型，不能进行比较）</li></ol>
<h2><a id="93__227"></a>❄️9.3 顺序容器操作</h2>
<h3><a id="931__229"></a>⛄️9.3.1 向顺序容器添加元素</h3>
<ul><li><code>注意向 vector、string 或 deque 插入元素会使所有指向容器的迭代器、引用和指针失效。</code></li><li>添加的都是<code>元素的拷贝</code>，不是元素本身。</li><li>头尾添加返回 void，中间添加返回指向新添加元素的迭代器</li></ul>
<table><thead><tr><th align="left">操作</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left"><code>c.push_back(t)</code></td><td align="left">在<code>c</code>尾部创建一个值为<code>t</code>的元素，返回<code>void</code></td></tr><tr><td align="left"><code>c.emplace_back(args)</code></td><td align="left">同上</td></tr><tr><td align="left"><code>c.push_front(t)</code></td><td align="left">在<code>c</code>头部创建一个值为<code>t</code>的元素，返回<code>void</code></td></tr><tr><td align="left"><code>c.emplace_front(args)</code></td><td align="left">同上</td></tr><tr><td align="left"><code>c.insert(p, t)</code></td><td align="left">在迭代器<code>p</code>指向的元素之前创建一个值是<code>t</code>的元素，返回指向新元素的迭代器</td></tr><tr><td align="left"><code>c.emplace(p, args)</code></td><td align="left">同上</td></tr><tr><td align="left"><code>c.insert(p, n, t)</code></td><td align="left">在迭代器<code>p</code>指向的元素之前插入<code>n</code>个值为<code>t</code>的元素，返回指向第一个新元素的迭代器；如果<code>n</code>是0，则返回<code>p</code></td></tr><tr><td align="left"><code>c.insert(p, b, e)</code></td><td align="left">将迭代器<code>b</code>和<code>e</code>范围内的元素，插入到<code>p</code>指向的元素之前；如果范围为空，则返回<code>p</code></td></tr><tr><td align="left"><code>c.insert(p, il)</code></td><td align="left"><code>il</code>是一个花括号包围中的元素值列表，将其插入到<code>p</code>指向的元素之前；如果<code>il</code>是空，则返回<code>p</code></td></tr></tbody></table>
<ul><li>因为这些操作会改变大小，因此不适用于<code>array</code>。</li></ul>
<p><strong>push</strong></p>
<ul><li>vector 和 string 不支持 <code>push_front</code> 和 <code>emplace_front</code>；</li><li>forward_list 不支持<code> push_back</code> 和 <code>emplace_back</code>；</li><li>forward_list有自己专有版本的insert和emplace。</li></ul>
<pre><code class="prism language-c">c<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 尾部添加一个 t</span>
c<span class="token punctuation">.</span><span class="token function">push_front</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 头部添加一个 t</span>
</code></pre>
<p><strong>insert</strong></p>
<ul><li>insert 返回值是指向添加的元素中第一个元素的迭代器</li><li>inset 是在迭代器指向的位置之前插入一个值</li><li><code>emplace 函数在容器中直接构造元素</code>，传递给emplace函数的参数必须与元素类型的构造函数<code>相匹配</code>，因此一般可以为空（默认初始化）。</li></ul>
<p><strong>emplace(c++ 11)</strong></p>
<ul><li>新标准引入三个新成员-<code> emplace_front</code>, <code>emplace_back</code>, <code>emplace</code></li><li>当调用push 或insert成员函数时，是将元素拷贝到容器中，<code>而emplace 则将参数传递给元素类型的构造对象</code>。</li><li>emplace 返回值是指向添加元素的迭代器</li></ul>
<pre><code class="prism language-c">c<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 在尾部添加一个由 args 构建的元素</span>
c<span class="token punctuation">.</span><span class="token function">emplace_front</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 在头部添加一个由 args 构建的元素</span>
c<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 在迭代器 p 所指元素之前添加一个由 args 构建的元素</span>
</code></pre>
<h3><a id="932__274"></a>⛄️9.3.2 访问元素</h3>
<ul><li>访问元素要确保<code>容器非空</code>，不然会出现错误</li><li><code>at和下标操作只适用于string、vector、deque、array。</code></li></ul>
<table><thead><tr><th align="left">操作</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left"><code>c.back()</code></td><td align="left">返回<code>c</code>中尾元素的引用。若<code>c</code>为空，函数行为未定义</td></tr><tr><td align="left"><code>c.front()</code></td><td align="left">返回<code>c</code>中头元素的引用。若<code>c</code>为空，函数行为未定义</td></tr><tr><td align="left"><code>c[n]</code></td><td align="left">返回<code>c</code>中下标是<code>n</code>的元素的引用，<code>n</code>时候一个无符号证书。若<code>n&gt;=c.size()</code>，则函数行为未定义</td></tr><tr><td align="left"><code>c.at(n)</code></td><td align="left">返回下标为<code>n</code>的元素引用。如果下标越界，则抛出<code>out_of_range</code>异常</td></tr></tbody></table>
<p><strong>begin/end</strong></p>
<ul><li>begin()/end() 返回<code>迭代器</code></li></ul>
<p><strong>front/back</strong></p>
<ul><li>front()/back() 返回<code>元素的引用</code>,可以对<code>元素进行修改</code></li></ul>
<pre><code class="prism language-c">c<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
c<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//返回的是尾元素的引用（注意不同于尾后迭代器）</span>

</code></pre>
<p><strong>at</strong></p>
<ul><li>at返回下标为 n 的<code>元素的引用</code></li><li>at可以快速随机访问的容器都可以使用下标。</li><li>使用下标一定要保证<code>下标不越界</code>，可以用 at 函数。当下标越界，at 函数会抛出一个 <code>out_of_range</code> 异常</li></ul>
<pre><code class="prism language-c">c<span class="token punctuation">[</span>n<span class="token punctuation">]</span>
c<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//返回下标为 n 的元素的引用</span>
</code></pre>
<p><strong>auto 获得引用</strong></p>
<ul><li>如果要通过 auto 获得元素的引用，定义时一定要记得加上引用符号</li></ul>
<pre><code class="prism language-c">c<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>        <span class="token comment">//将42赋予c中的第一个元素</span>
<span class="token keyword">auto</span> <span class="token operator">&amp;</span>v <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//获取指向最后一个元素的引用</span>
v <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">;</span>              <span class="token comment">//通过引用可以改变元素的值</span>

<span class="token keyword">auto</span> v2 <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//v2不是一个引用，它是c.back()的一个拷贝</span>
v2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token comment">//未改变c中的元素</span>
</code></pre>
<p><strong>理解</strong>：</p>
<ol><li>c.front() 返回的是<code>引用</code>，因此可以通过 c.front() = 32; 来给 c 的首元素赋值。</li><li>而<code>auto b = c.front()</code>得到的 b 是等号右端元素的拷贝，不是引用</li></ol>
<h3><a id="933__325"></a>⛄️9.3.3 删除元素</h3>
<ul><li>头尾删除返回<code> void</code>，特定位置删除返回被<code>删除元素之后元素的迭代器</code></li><li><code>vector/string</code> 不支持<code> pop_front</code>，<code>forward_list 不支持 pop_back。</code></li><li>forward_list 有自己特殊版本的 erase。</li></ul>
<table><thead><tr><th align="left">操作</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left"><code>c.pop_back()</code></td><td align="left">删除<code>c</code>中尾元素，若<code>c</code>为空，则函数行为未定义。函数返回<code>void</code></td></tr><tr><td align="left"><code>c.pop_front()</code></td><td align="left">删除<code>c</code>中首元素，若<code>c</code>为空，则函数行为未定义。函数返回<code>void</code></td></tr><tr><td align="left"><code>c.erase(p)</code></td><td align="left">删除迭代器<code>p</code>指向的元素，返回一个指向被删除元素之后的元素的迭代器，若<code>p</code>本身是尾后迭代器，则函数行为未定义</td></tr><tr><td align="left"><code>c.erase(b, e)</code></td><td align="left">删除迭代器<code>b</code>和<code>e</code>范围内的元素，返回指向最后一个被删元素之后元素的迭代器，若<code>e</code>本身就是尾后迭代器，则返回尾后迭代器</td></tr><tr><td align="left"><code>c.clear()</code></td><td align="left">删除<code>c</code>中所有元素，返回<code>void</code></td></tr></tbody></table>
<ul><li><code>删除迭代器所指定的元素，返回一个指向被删除元素之后元素的迭代器</code></li></ul>
<p><strong>删除多个元素</strong></p>
<pre><code class="prism language-c">c<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
c<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 和 c.clear() 等价</span>
</code></pre>
<p><strong>总结</strong></p>
<ul><li>删除之前要<code>确保元素存在</code></li><li>删除 deque 种除首尾之外的任何元素都会使所有迭代器、引用和指针失效。</li><li>删除 vector 或 string 中的元素会使<code>指向删除点之后</code>位置的迭代器、引用和指针失效。</li><li>删除 list 中的元素<code>不会影响</code>指向其他位置的迭代器、引用、指针。</li></ul>
<h3><a id="934_forward_list_354"></a>⛄️9.3.4 特殊的forward_list操作</h3>
<ul><li><code>forward_list</code> 是<code>单向链表</code>，添加和删除操作都会同时改变前驱和后继结点，因此一般的添加和删除都不适用于 forward_list</li><li><code>forward_lis</code>t定义了<code>before_begin</code>，即首前（off-the-begining）迭代器，允许我们再在首元素之前添加或删除元素。</li></ul>
<table><thead><tr><th align="left">操作</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left"><code>lst.before_begin()</code></td><td align="left">返回指向链表首元素之前不存在的元素的迭代器，此迭代器不能解引用。</td></tr><tr><td align="left"><code>lst.cbefore_begin()</code></td><td align="left">同上，但是返回的是常量迭代器。</td></tr><tr><td align="left"><code>lst.insert_after(p, t)</code></td><td align="left">在迭代器<code>p</code>之后插入元素。<code>t</code>是一个对象</td></tr><tr><td align="left"><code>lst.insert_after(p, n, t)</code></td><td align="left">在迭代器<code>p</code>之后插入元素。<code>t</code>是一个对象，<code>n</code>是数量。若<code>n</code>是0则函数行为未定义</td></tr><tr><td align="left"><code>lst.insert_after(p, b, e)</code></td><td align="left">在迭代器<code>p</code>之后插入元素。由迭代器<code>b</code>和<code>e</code>指定范围。</td></tr><tr><td align="left"><code>lst.insert_after(p, il)</code></td><td align="left">在迭代器<code>p</code>之后插入元素。由<code>il</code>指定初始化列表。</td></tr><tr><td align="left"><code>emplace_after(p, args)</code></td><td align="left">使用<code>args</code>在<code>p</code>之后的位置，创建一个元素，返回一个指向这个新元素的迭代器。若<code>p</code>为尾后迭代器，则函数行为未定义。</td></tr><tr><td align="left"><code>lst.erase_after(p)</code></td><td align="left">删除<code>p</code>指向位置之后的元素，返回一个指向被删元素之后的元素的迭代器，若<code>p</code>指向<code>lst</code>的尾元素或者是一个尾后迭代器，则函数行为未定义。</td></tr><tr><td align="left"><code>lst.erase_after(b, e)</code></td><td align="left">类似上面，删除对象换成从<code>b</code>到<code>e</code>指定的范围。</td></tr></tbody></table>
<ul><li>inster_after在迭代器p之后的位置上插入元素，返回的是一个指向最后一个插入元素的迭代器</li></ul>
<h3><a id="935__373"></a>⛄️9.3.5 改变容器大小</h3>
<ul><li><code>resize() 用来增大或缩小容器。</code></li><li>如果要求的<code>大小小于当前大小</code>，<code>尾部会被删除</code>，如果要求的<code>大小大于当前大小</code>，会把<code>新元素添加到尾部</code></li></ul>
<table><thead><tr><th align="left">操作</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left"><code>c.resize(n)</code></td><td align="left">调整<code>c</code>的大小为<code>n</code>个元素，若<code>n&lt;c.size()</code>，则多出的元素被丢弃。若必须添加新元素，对新元素进行值初始化</td></tr><tr><td align="left"><code>c.resize(n, t)</code></td><td align="left">调整<code>c</code>的大小为<code>n</code>个元素，任何新添加的元素都初始化为值<code>t</code></td></tr></tbody></table>
<ul><li>resize函数接收可选参数，用来初始化添加到容器中的元素，如果未提供此参数，新元素会值初始化。</li><li>假如容器保存的是<code>类类型</code>，且resize向容器添加元素，我们必须<code>提供初始值</code>，或者<code>元素类型必须提供默认构造函数</code></li></ul>
<p><strong>总结</strong></p>
<ul><li>对于往容器插入元素（<code>insert()</code>),在迭代器<code>p指向的元素之前</code>，插入一个元素，返回指向<code>新元素的迭代器</code></li><li>对于往容器删除元素（<code>erase()</code>）,删除迭代器<code>p所指向的元素</code>，返回一个指向<code>删除元素之后的元素的迭代器</code></li><li>对于<code>forward_list</code>插入操作（<code>insert_after()</code>）,在<code>迭代器p之后插入元素</code>，返回一个指向<code>最后一个插入元素的迭代器。</code></li><li>对于<code>forward_list</code>删除操作（<code>erase_after()</code>）, 删除<code>迭代器p之后的元素</code>，返回一个指向<code>被删除元素之后元素的迭代器</code></li><li>值初始化：对于容器而言，可以只提供元素个数而省略初始值，此时库会创建一个值初始化元素初值，并把它赋给容器中的所有元素。这个值初始化有容器当中元素类型决定（例如int，容器自动初始化为0，string容器自动初始化为空字符串）</li></ul>
<h3><a id="936__393"></a>⛄️9.3.6 容器操作可能使迭代器失效</h3>
<ul><li> <p><code>添加和删除元素都可能使指针、引用、迭代器失效。使用失效的指针、引用、迭代器是很严重的错误。</code></p> </li><li> <p>在向容器添加元素后：</p>
<ul><li>如果容器是<code>vector</code>或<code>string</code>，且存储空间被重新分配，则指向容器的迭代器、指针、引用都会失效。</li><li>对于<code>deque</code>，插入到除首尾位置之外的任何位置都会导致指向容器的迭代器、指针、引用失效。如果在首尾位置添加元素，迭代器会失效，但指向存在元素的引用和指针不会失效。</li><li>对于<code>list</code>和<code>forward_list</code>，指向容器的迭代器、指针和引用依然有效。</li></ul> </li><li> <p>在从一个容器中删除元素后：</p>
<ul><li>对于<code>list</code>和<code>forward_list</code>，指向容器其他位置的迭代器、引用和指针仍然有效。</li><li>对于<code>deque</code>，如果在首尾之外的任何位置删除元素，那么指向被删除元素外其他元素的迭代器、指针、引用都会失效；如果是删除<code>deque</code>的尾元素，则尾后迭代器会失效，但其他不受影响；如果删除的是<code>deque</code>的头元素，这些也不会受影响。</li><li>对于<code>vector</code>和<code>string</code>，指向被删元素之前的迭代器、引用、指针仍然有效。</li></ul> </li></ul>
<p><strong>编写改变容器的循环程序</strong></p>
<ul><li><code>必须保证每次改变容器后都更新迭代器。</code></li><li>insert 和 erase 都会返回迭代器，更新很容易。<code>调用 erase 后，不需要递增迭代器，调用 insert 后，需要递增两次。</code></li></ul>
<p><strong>不要保存 end() 返回的迭代器</strong></p>
<ul><li>push、pop、首尾 emplace 操作<code>都没有返回值，但是都会改变尾后迭代器</code>，因此不能保存 end() 返回值。</li><li><code>for 循环判断条件中的 end() 每轮都会重新获取迭代器进行判断，因此不用担心（也因此速度会略慢，当不改变容器大小时，采用下标更快）</code></li></ul>
<h2><a id="94_vector_416"></a>❄️9.4 vector对象是如何增长的</h2>
<ul><li><code>vector</code>和<code>string</code>在内存中是<code>连续存储</code>的，为了避免每添加一个元素就要重新分配一次空间，<code>在每次获取新的内存空间时，vector和string通常会分配比新空间需求更大的内存空间</code>。容器预留这些空间作为备用，可以保存新的元素。</li><li>虽然每次重新分配需要移动所有元素，但是其扩张操作通常<code>比list和deque快</code></li></ul>
<p><strong>管理容量的成员函数</strong></p>
<table><thead><tr><th align="left">操作</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left"><code>c.shrink_to_fit()</code></td><td align="left">将<code>capacity()</code>减少到和<code>size()</code>相同大小</td></tr><tr><td align="left"><code>c.capacity()</code></td><td align="left">不重新分配内存空间的话，<code>c</code>可以保存多少个元素</td></tr><tr><td align="left"><code>c.reverse(n)</code></td><td align="left">分配至少能容纳<code>n</code>个元素的内存空间</td></tr></tbody></table>
<ul><li>shrink_to_fit只适用于<code>vector、string和deque</code></li><li>capacity和reverse只适用于<code>vector和string</code>。</li></ul>
<p><strong>注意</strong></p>
<ul><li>c.reserve(n) <code>不会减小容量，只会增大容量</code>，当需求容量大于当前容量，才会分配内存，否则什么都不做。</li><li>c.resize(), <code>只改变容器中元素的数目，并不改变容器的容量</code></li><li>c.shrink_to_fit() 只是一个请求，实现时标准库可能会不执行。</li></ul>
<p><strong>capacity和size</strong></p>
<ul><li>capacity表示<code>不分配新的内存空间前提下它最多保存多少元素</code></li><li>size是指<code>它已经保存元素的数目。</code></li></ul>
<h2><a id="95_string_438"></a>❄️9.5 额外的string操作</h2>
<ul><li>除了与顺序容器共同的操作之外，string提供了一些额外的操作。主要用于<code>c风格字符串</code>和<code>下标访问</code>,允许用下标代替迭代器。</li></ul>
<h3><a id="951_string_442"></a>⛄️9.5.1 构造string的其他方法</h3>
<table><thead><tr><th align="left">操作</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left"><code>string s(cp, n)</code></td><td align="left"><code>s</code>是<code>cp</code>指向的数组中前<code>n</code>个字符的拷贝，此数组</td></tr><tr><td align="left"><code>string s(s2, pos2)</code></td><td align="left"><code>s</code>是<code>string s2</code>从下标<code>pos2</code>开始的字符的拷贝。若<code>pos2 &gt; s2.size()</code>，则构造函数的行为未定义。</td></tr><tr><td align="left"><code>string s(s2, pos2, len2)</code></td><td align="left"><code>s</code>是<code>string s2</code>从下标<code>pos2</code>开始的<code>len2</code>个字符的拷贝。</td></tr></tbody></table>
<ul><li>string 的构造函数可以接受一个 string 或 const char* 参数用来指定开始位置，然后接受一个计数值用来指定范围。</li><li>当用<code>const char *</code>创建string时，指针指向的数组必须是以空字符串结尾，拷贝操作遇到空字符串时停止。</li><li>如果传递的是<code>string对象</code>，那么可以提供一个<code>可选位置</code>和一个<code>计数值</code></li><li>如果传递的是<code>数组对象</code>,那么如果传递了数组，并且加上计数值，那么数组就不需要以空字符串结尾，否则没有计数值的话，会出现未定义错误。</li></ul>
<pre><code class="prism language-c"><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>cp <span class="token operator">=</span> <span class="token string">"hello world!!!"</span>   <span class="token comment">//以空字符串结束的数组</span>
<span class="token keyword">char</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token char">'H'</span><span class="token punctuation">,</span> <span class="token char">'W'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>             <span class="token comment">//不是以空字符串结束的数组</span>

string <span class="token function">s1</span><span class="token punctuation">(</span>cp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//正确，一空字符串结尾</span>
string <span class="token function">s2</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">//错误，不是空字符串结尾，而且也没有提供计数值</span>
string <span class="token function">s3</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">//正确</span>

string <span class="token function">s4</span><span class="token punctuation">(</span>cp <span class="token operator">+</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>  <span class="token comment">//正确,从cp[6]开始拷贝，拷贝85个字符</span>
string <span class="token function">s5</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>   <span class="token comment">//正确，对象时string,从下标6的位置开始，拷贝5个字符   </span>
</code></pre>
<p><strong>substr</strong></p>
<ul><li><code>s.substr(pos,n) 返回 s 的一部分或全部拷贝，范围由参数指定。</code></li></ul>
<table><thead><tr><th align="left">操作</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left"><code>s.substr(pos, n)</code></td><td align="left">返回一个<code>string</code>，包含<code>s</code>中从<code>pos</code>开始的<code>n</code>个字符的拷贝。<code>pos</code>的默认值是0，<code>n</code>的默认值是<code>s.size() - pos</code>，即拷贝从<code>pos</code>开始的所有字符。</td></tr></tbody></table>
<pre><code class="prism language-c">string s2 <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 返回从下标 0 开始，长度为 5 的子序列</span>
string s2 <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 返回从下标 6 开始到最后的子序列</span>
</code></pre>
<p><strong>总结</strong></p>
<ul><li>所有的拷贝或者substr有四种情况： 
  <ol><li>括号中俩个参数<code>(p, n)</code>，p + n没有超过string大小，分别是从下标p位置，拷贝n个字符</li><li>括号中俩个参数<code>(p, n)</code>，p + n超过string大小，此时会拷贝到字符尾部</li><li>括号中一个参数<code>(p)</code>，从下标p的位置，一直拷贝到最后</li><li>括号中一个参数，但是该参数超过了string的值，此时会抛出异常</li></ol> </li></ul>
<h3><a id="952_string_487"></a>⛄️9.5.2 改变string的其他方法</h3>
<p><strong>string 支持顺序容器的 assign、insert、erase 操作，此外还增加了两个额外的操作</strong></p>
<ol><li>接受下标版本的 insert 和 erase</li><li>接受 C 风格字符数组的 insert 和 assign</li><li>append 和 replace 函数</li></ol>
<table><thead><tr><th align="left">操作</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left"><code>s.insert(pos, args)</code></td><td align="left">在<code>pos</code>之前插入<code>args</code>指定的字符。<code>pos</code>可以使是下标或者迭代器。接受下标的版本返回指向<code>s</code>的引用；接受迭代器的版本返回指向第一个插入字符的迭代器。</td></tr><tr><td align="left"><code>s.erase(pos, len)</code></td><td align="left">删除从<code>pos</code>开始的<code>len</code>个字符，如果<code>len</code>被省略，则删除后面所有字符，返回指向<code>s</code>的引用。</td></tr><tr><td align="left"><code>s.assign(args)</code></td><td align="left">将<code>s</code>中的字符替换成<code>args</code>指定的字符。返回一个指向<code>s</code>的引用。</td></tr><tr><td align="left"><code>s.append(args)</code></td><td align="left">将<code>args</code>指定的字符追加到<code>s</code>，返回一个指向<code>s</code>的引用。</td></tr><tr><td align="left"><code>s.replace(range, args)</code></td><td align="left">删除<code>s</code>中范围<code>range</code>中的字符，替换成<code>args</code>指定的字符。返回一个指向<code>s</code>的引用。</td></tr></tbody></table>
<p><strong>接受下标的 insert 和 erase</strong></p>
<ul><li>insert 和 erase 接受下标的版本返回的是<code>一个指向 s 的引用（区别于迭代器版本返回指向第一个插入字符的迭代器）</code>。</li><li>insert 的所有版本都是<code>第一部分参数为 pos，后面的参数为待插入的字符</code></li><li><code>erase 的所有版本的参数都是 pos，pos 分为 起始位置 和 终止位置/长度</code></li></ul>
<pre><code class="prism language-c">s<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token char">'!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 在 s 末尾（s[s.size()]之前）插入 5 个感叹号，注意实际上不存在 s[s.size()];</span>
s<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> s2<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> s2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 在 s[0] 之前插入 s2 第四个字符开始的 s2.size()-3 个字符</span>
s<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">// 从 s 删除最后 5 个字符</span>
</code></pre>
<p><strong>接受 C 风格字符数组的 insert 和 assign</strong></p>
<ul><li>assign 的所有版本的参数都是要赋的值，由 起始位置 + 终止位置/长度 组成</li><li>replace 的所有版本的参数都是第一部分参数为要删除的范围，第二部分为要插入的字符。</li></ul>
<pre><code class="prism language-c"><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> cp <span class="token operator">=</span> <span class="token string">"stately,plump Buck"</span><span class="token punctuation">;</span>
s<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>cp<span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">// 用从 cp 开始的前 7 个字符向 s 赋值</span>
s<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cp<span class="token operator">+</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 将从 cp+7 开始到 cp 末尾的字符插入到 s 末尾</span>
</code></pre>
<p><strong>append 和 replace</strong></p>
<ul><li>append：在 string 末尾进行插入操作。</li><li>replace：等价于调用 erase 和 insert 操作。</li></ul>
<pre><code class="prism language-c">s<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">" 4th Ed."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 等价于 s.insert(s.size()," 4th Ed.");</span>

s<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
s<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token string">"5th"</span><span class="token punctuation">)</span>        <span class="token comment">//等价于</span>
s<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"5th"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 从下标 11 开始，删除三个字符并插入 3 个新字符</span>
</code></pre>
<h3><a id="953_string_534"></a>⛄️9.5.3 string搜索操作</h3>
<ul><li><code>string</code>类提供了6个不同的搜索函数，每个函数都有4个重载版本。</li><li>每个搜索操作都返回一个<code>string::size_type</code>值，表示匹配发生位置的下标。如果搜索失败则返回一个名为<code>string::npos</code>的static成员（类型是<code>string::size_type</code>，初始化值是<code>-1</code>，也就是string最大的可能大小）。</li></ul>
<p><strong>注意</strong>：</p>
<ul><li><code>find</code> 和 <code>rfind </code>查找的是<code>给定的整个 args</code>，而剩下的查找的是给定的 args 中包含的<code>任意一个字符</code>。</li></ul>
<pre><code class="prism language-c">s<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment">// 查找 s 中 args 第一次出现的位置</span>
s<span class="token punctuation">.</span><span class="token function">rfind</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">// 查找 s 中 args 最后一次出现的位置</span>
s<span class="token punctuation">.</span><span class="token function">find_first_of</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 查找 s 中 args 的任意一个字符第一次出现的位置</span>
s<span class="token punctuation">.</span><span class="token function">find_last_of</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 查找 s 中 args 的任意一个字符最后一次出现的位置</span>
s<span class="token punctuation">.</span><span class="token function">find_first_not_of</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 查找 s 中第一个不在 args 中的字符</span>
s<span class="token punctuation">.</span><span class="token function">find_last_not_of</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 查找 s 中最后一个不在 args 中的字符</span>

<span class="token char">'args为以下形式'</span>
c<span class="token punctuation">,</span>pos         <span class="token comment">// 字符，pos 为搜索开始位置(	从s中位置pos开始查找字符c。pos默认是0)</span>
s2<span class="token punctuation">,</span>pos       <span class="token comment">// 字符串(	从s中位置pos开始查找字符串s。pos默认是0)</span>
cp<span class="token punctuation">,</span>pos       <span class="token comment">// 以空字符结尾的 c 风格字符串(从s中位置pos开始查找指针cp指向的以空字符结尾的C风格字符串。pos默认是0)</span>
cp<span class="token punctuation">,</span>pos<span class="token punctuation">,</span>n     <span class="token comment">// c 风格字符串的前 n 个字符(	从s中位置pos开始查找指针cp指向的前n个字符。pos和n无默认值。)</span>
</code></pre>
<p><strong>使用 pos 循环查找所有 str 包含的字符的位置</strong></p>
<pre><code class="prism language-c">string<span class="token operator">::</span>size_type pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>pos<span class="token operator">=</span>s<span class="token punctuation">.</span><span class="token function">find_first_of</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span>pos<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> string<span class="token operator">::</span>npos <span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    cout <span class="token operator">&lt;&lt;</span> pos <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token operator">++</span>pos<span class="token punctuation">;</span><span class="token punctuation">}</span>
</code></pre>
<h3><a id="954_compare__568"></a>⛄️9.5.4 compare 函数</h3>
<ul><li>逻辑类似于C标准库的strcmp函数，根据s是等于、大于还是小于参数指定的字符串</li><li><code>俩个string对象</code>比较或者<code>一个string对象一个字符数组</code>, 可以比较<code>整体或一部分字符串</code></li><li>s.compare返回<code>0、正数或负数</code>。</li></ul>
<pre><code class="prism language-c"><span class="token keyword">int</span> cmp <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> cmp <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>pos1<span class="token punctuation">,</span>n1<span class="token punctuation">,</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 将 s 中 pos1 开始的前 n1 个字符与 s2 比较</span>
<span class="token keyword">int</span> cmp <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>pos1<span class="token punctuation">,</span>n1<span class="token punctuation">,</span>s2<span class="token punctuation">,</span>pos2<span class="token punctuation">,</span>n2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 将 s 中 pos1 开始的前 n1 个字符与 s2 中从 pos2 开始的 n2 个字符进行比较</span>
<span class="token keyword">int</span> cmp <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>cp<span class="token punctuation">)</span>                   <span class="token comment">// 将 s 与 cp 指向的字符数组比较</span>
<span class="token keyword">int</span> cmp <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>pos1<span class="token punctuation">,</span>n1<span class="token punctuation">,</span>cp<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> cmp <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>pos1<span class="token punctuation">,</span>n1<span class="token punctuation">,</span>cp<span class="token punctuation">,</span>n2<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<h3><a id="955__582"></a>⛄️9.5.5 数值转换</h3>
<table><thead><tr><th align="left">转换</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left"><code>to_string(val)</code></td><td align="left">一组重载函数，返回数值<code>val</code>的<code>string</code>表示。<code>val</code>可以使任何算术类型。对每个浮点类型和<code>int</code>或更大的整型，都有相应版本的<code>to_string()</code>。和往常一样，小整型会被提升。</td></tr><tr><td align="left"><code>stoi(s, p, b)</code></td><td align="left">返回<code>s</code>起始子串（表示整数内容）的数值，<code>p</code>是<code>s</code>中第一个非数值字符的下标，默认是0，<code>b</code>是转换所用的基数。返回<code>int</code></td></tr><tr><td align="left"><code>stol(s, p, b)</code></td><td align="left">返回<code>long</code></td></tr><tr><td align="left"><code>stoul(s, p, b)</code></td><td align="left">返回<code>unsigned long</code></td></tr><tr><td align="left"><code>stoll(s, p, b)</code></td><td align="left">返回<code>long long</code></td></tr><tr><td align="left"><code>stoull(s, p, b)</code></td><td align="left">返回<code>unsigned long long</code></td></tr><tr><td align="left"><code>stof(s, p)</code></td><td align="left">返回<code>s</code>起始子串（表示浮点数内容）的数值，<code>p</code>是<code>s</code>中第一个非数值字符的下标，默认是0。返回<code>float</code></td></tr><tr><td align="left"><code>stod(s, p)</code></td><td align="left">返回<code>double</code></td></tr><tr><td align="left"><code>stold(s, p)</code></td><td align="left">返回<code>long double</code></td></tr></tbody></table>
<p><strong>例子</strong></p>
<pre><code class="prism language-c">string s2 <span class="token operator">=</span> <span class="token string">"pi = 3.14"</span><span class="token punctuation">;</span>
<span class="token keyword">double</span> d <span class="token operator">=</span> <span class="token function">stod</span><span class="token punctuation">(</span>s2<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>s2<span class="token punctuation">.</span><span class="token function">find_first_of</span><span class="token punctuation">(</span><span class="token string">"+-.0123456789"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 先使用查询方法找出第一个数值字符(因为+ - . 0 1 2在s2中都不存在，所以继续找下一个为3，此时3在s2中是下标为5的位置)，返回5，就变成了stod(s2.substr(5)),将字符串从下标为5的位置一直到结束，转换成double类型</span>
</code></pre>
<h2><a id="96__603"></a>❄️9.6 容器适配器</h2>
<ul><li>标准库定义了三个顺序容器适配器:<code>stack、queue、priority_queue</code>。</li><li>容器，函数，迭代器都有适配器</li><li>适配器是一种机制，是某种事物的行为看起来像另一种事物。</li></ul>
<p><strong>适配器的通用操作和类型</strong></p>
<pre><code class="prism language-c">size_type<span class="token punctuation">;</span>
value_type<span class="token punctuation">;</span>
container_type<span class="token punctuation">;</span>  <span class="token comment">// 实现适配器的底层容器类型。</span>

A a<span class="token punctuation">;</span>             <span class="token comment">//创建一个名为a的空适配器</span>
A <span class="token function">a</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>           <span class="token comment">//创建一个名为a的适配器，带有容器c的一个拷贝</span>
关系运算符        <span class="token comment">//每个适配器都支持所有关系运算符：==、!=、&lt;、 &lt;=、&gt;、&gt;=这些运算符返回底层容器的比较结果</span>
a<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token comment">//若a包含任何元素，返回false;否则返回true</span>
a<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment">//返回a中的元素数目</span>
<span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span>      <span class="token comment">//交换a和b的内容，a和b必须有相同类型，包括底层容器类型也必须相同</span>
a<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>       <span class="token comment">//同上</span>
</code></pre>
<ul><li>所有适配器要求容器具有添加和删除元素的能力，因此array不能当适配器</li></ul>
<p><strong>初始化操作</strong></p>
<ul><li> <p>默认情况下，stack 和 queue 是基于 <code>deque </code>实现的， priority_queue 是在 <code>vector </code>之上实现的。</p> </li><li> <p>因此可以直接用一个 <code>deque </code>来初始化 <code>stack 和 queue</code>。注意：<code>是直接使用容器对象，不是使用迭代器表示的范围。</code></p> </li><li> <p>priority_queue 不能使用无序的 vector 初始化。</p> </li></ul>
<pre><code class="prism language-c">deque<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> deq<span class="token punctuation">;</span>
stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">sta</span><span class="token punctuation">(</span>deq<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 用 deq 初始化 sta</span>
</code></pre>
<p><strong>如果要使用其他顺序容器实现适配器，要在创建适配器时用一个顺序容器作为第二个类型参数。</strong></p>
<pre><code class="prism language-c">stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> sta<span class="token punctuation">;</span>  <span class="token comment">// 定义基于 vector 实现的 stack</span>
</code></pre>
<p><strong>总结</strong></p>
<ul><li><code>stack</code> 可以构造于 <code>vector, list, deque</code> 之上。</li><li><code>queue</code> 可以构造于 <code>list, deque</code> 之上。</li><li><code>priority_queue </code>可以构造于 <code>vector、deque </code>之上。</li></ul>
<p><strong>栈适配器：stack</strong></p>
<pre><code class="prism language-c">s<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
s<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
s<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 由 args 构造元素并压入栈顶</span>
s<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
s<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">swap</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span> s<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p><strong>队列适配器：queue</strong></p>
<pre><code class="prism language-c">q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 删除 queue 的首元素</span>
q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 在 queue 末尾插入一个元素</span>
q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 构造元素</span>

q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 返回首元素</span>
q<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 返回尾元素。</span>

q<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">swap</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span>q2<span class="token punctuation">)</span><span class="token punctuation">;</span>q<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>q2<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<ul><li>queue 为先进先出队列。</li><li>queue 和 priority_queue 都定义在头文件 queue 中。</li></ul>
<p><strong>优先队列：priority_queue</strong></p>
<ul><li>创建 stack, queue, priority_queue 时都可以用一个顺序容器作为第二个类型参数，此外创建 priority_quque 时还可以额外传递第三个参数：一个函数对象来决定如何对 priority_queue 中的元素进行排序。</li></ul>
<p><strong>大根堆和小根堆</strong></p>
<ul><li>priority_queue 默认采用的是 less ，默认情况下 q.top() 是最大的元素，即大根堆。</li></ul>
<pre><code class="prism language-c"> priority_queue <span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> q<span class="token punctuation">;</span>      <span class="token comment">// 默认采用 vector 作为容器，采用 less&lt;Type&gt; 比较元素，是大根堆</span>
 priority_queue <span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> greater<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token operator">&gt;</span> q<span class="token punctuation">;</span>  <span class="token comment">// 采用 greater&lt;Type&gt; 比较元素，生成小根堆</span>
</code></pre>
<p><strong>其他操作：</strong></p>
<pre><code class="prism language-c">q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 删除 priority_queue 的最高优先级元素</span>
q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 在 priority_queue 适当的位置插入一个元素</span>
q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 构造元素</span>
q<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 返回最高优先级元素</span>
q<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">swap</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> q2<span class="token punctuation">)</span><span class="token punctuation">;</span> q<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>q2<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<ul><li>priority_queue 为元素建立优先级。新加入的元素排在所有优先级比它低的元素之前。priority_queue 元素可以重复</li><li>priority_queue 不能使用无序的 vector 初始化。</li></ul>
</div>
<link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css" rel="stylesheet"/>
<link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css" rel="stylesheet"/>
</div>