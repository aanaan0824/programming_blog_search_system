<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<p></p>
<p id="main-toc"><strong>目录</strong></p>
<p id="%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#%E5%89%8D%E8%A8%80">前言</a></p>
<p id="%E4%B8%80%E3%80%81PyJnius-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81PyJnius">一、PyJnius</a></p>
<p id="1.%E4%B8%8B%E8%BD%BD%E6%96%B9%E5%BC%8F-toc" style="margin-left:40px;"><a href="#1.%E4%B8%8B%E8%BD%BD%E6%96%B9%E5%BC%8F">1.下载方式</a></p>
<p id="%E6%96%B9%E6%B3%95%E4%B8%80-toc" style="margin-left:80px;"><a href="#%E6%96%B9%E6%B3%95%E4%B8%80">方法一</a></p>
<p id="%C2%A0%E6%96%B9%E6%B3%95%E4%BA%8C-toc" style="margin-left:80px;"><a href="#%C2%A0%E6%96%B9%E6%B3%95%E4%BA%8C"> 方法二</a></p>
<p id="2.%E7%9B%B8%E5%85%B3%E4%BE%9D%E8%B5%96-toc" style="margin-left:40px;"><a href="#2.%E7%9B%B8%E5%85%B3%E4%BE%9D%E8%B5%96">2.相关依赖</a></p>
<p id="%E4%BA%8C%E3%80%81%E4%BD%BF%E7%94%A8%E6%B5%8B%E8%AF%95-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E4%BD%BF%E7%94%A8%E6%B5%8B%E8%AF%95">二、使用测试</a></p>
<p id="%E4%B8%89%E3%80%81Reflection%E7%B1%BB-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81Reflection%E7%B1%BB">三、Reflection类</a></p>
<p id="%E5%9B%9B%E3%80%81Reflection%E5%87%BD%E6%95%B0-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81Reflection%E5%87%BD%E6%95%B0">四、Reflection函数</a></p>
<p id="1.jnius.autoclass(name)-toc" style="margin-left:40px;"><a href="#1.jnius.autoclass%28name%29">1.jnius.autoclass(name)</a></p>
<p id="%C2%A0Python%E4%B8%AD%E7%9A%84Java%E7%B1%BB%E5%AE%9E%E7%8E%B0%C2%A0-toc" style="margin-left:40px;"><a href="#%C2%A0Python%E4%B8%AD%E7%9A%84Java%E7%B1%BB%E5%AE%9E%E7%8E%B0%C2%A0"> Python中的Java类实现 </a></p>
<p id="jnius.java_method-toc" style="margin-left:80px;"><a href="#jnius.java_method">jnius.java_method</a></p>
<p id="Java%E7%AD%BE%E5%90%8D%E6%A0%BC%E5%BC%8F%C2%A0-toc" style="margin-left:40px;"><a href="#Java%E7%AD%BE%E5%90%8D%E6%A0%BC%E5%BC%8F%C2%A0">Java签名格式 </a></p>
<p id="JVM%E9%80%89%E9%A1%B9%E5%92%8C%E7%B1%BB%E8%B7%AF%E5%BE%84%C2%A0-toc" style="margin-left:40px;"><a href="#JVM%E9%80%89%E9%A1%B9%E5%92%8C%E7%B1%BB%E8%B7%AF%E5%BE%84%C2%A0">JVM选项和类路径 </a></p>
<p id="%E5%AE%8C%E6%95%B4%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B%3A-toc" style="margin-left:40px;"><a href="#%E5%AE%8C%E6%95%B4%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B%3A">完整使用案例:</a></p>
<p id="%E7%82%B9%E5%85%B3%E6%B3%A8%EF%BC%8C%E9%98%B2%E8%B5%B0%E4%B8%A2%EF%BC%8C%E5%A6%82%E6%9C%89%E7%BA%B0%E6%BC%8F%E4%B9%8B%E5%A4%84%EF%BC%8C%E8%AF%B7%E7%95%99%E8%A8%80%E6%8C%87%E6%95%99%EF%BC%8C%E9%9D%9E%E5%B8%B8%E6%84%9F%E8%B0%A2-toc" style="margin-left:40px;"><a href="#%E7%82%B9%E5%85%B3%E6%B3%A8%EF%BC%8C%E9%98%B2%E8%B5%B0%E4%B8%A2%EF%BC%8C%E5%A6%82%E6%9C%89%E7%BA%B0%E6%BC%8F%E4%B9%8B%E5%A4%84%EF%BC%8C%E8%AF%B7%E7%95%99%E8%A8%80%E6%8C%87%E6%95%99%EF%BC%8C%E9%9D%9E%E5%B8%B8%E6%84%9F%E8%B0%A2">点关注，防走丢，如有纰漏之处，请留言指教，非常感谢</a></p>
<hr id="hr-toc"/>
<p></p>
<h1 id="%E5%89%8D%E8%A8%80"><a id="_7"></a>前言</h1>
<p>最近一直在研究HiveSQL的源码以及ANTLR包的源码，比较无奈的是工程上我还是偏向于使用Pycharm和python编程语言。其实编程语言选择都无所谓只是工具罢了，主要的是其中解析抽象树AST的思想以及方法。但是基础的语法方法需要掌握，比如Python调库以及引用，JAVA的import规则以及jar包的引用。要做成工程化的程序，程序员就必须有一定的工具使用能力，比如anaconda和IDEA的基础使用方法，做HiveSQL血缘分析的时候遇到了很多大坑以及众多BUG报错，对于自身代码能力和解决问题的能力也有一定的成长。好了废话不多说，就让我们来研究如何来使用该库实现相应功能吧。<strong>博主将长期维护自己博客的文章，如有披露错误或者不理解之处请尽情在评论区留下发言</strong>。希望能够帮助到需要掌握该库的各位。</p>
<hr/>
<h1 id="%E4%B8%80%E3%80%81PyJnius">一、PyJnius</h1>
<p>PyJnius库正如文章标题，是一个用于访问Java类的Python库。PyJnius官网：<a href="https://pyjnius.readthedocs.io/en/stable/" title="Welcome to Pyjnius — Pyjnius 1.0a1 documentation">Welcome to Pyjnius — Pyjnius 1.0a1 documentation</a></p>
<p>github：</p>
<p><a href="https://github.com/kivy/pyjnius" title="GitHub - kivy/pyjnius: Access Java classes from Python">GitHub - kivy/pyjnius: Access Java classes from Python</a></p>
<p>PyJnius库主要分为三个部分：</p>
<ul><li>jnius</li><li>jnius_config</li><li>setup_sdist</li></ul>
<p>现在的PyJnius库的版本为1.4.2。该库通过JVM虚拟机实现调用。</p>
<h2 id="1.%E4%B8%8B%E8%BD%BD%E6%96%B9%E5%BC%8F">1.下载方式</h2>
<h3 id="%E6%96%B9%E6%B3%95%E4%B8%80">方法一</h3>
<p>直接通过在cmd命令提示符里面输入：</p>
<pre><code>pip install pyjnius</code></pre>
<p>但是这种方式很可能由于连接不稳定失败，建议换个源再下载：</p>
<pre><code>pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple pyjnius
</code></pre>
<p>conda的下载：</p>
<pre><code>conda install -c conda-forge pyjnius</code></pre>
<h3 id="%C2%A0%E6%96%B9%E6%B3%95%E4%BA%8C"> 方法二</h3>
<p>直接去Pypi上面下载whl文件也很快，毕竟现在连外网很不稳定，网速很慢。大家可以在本人资源列表上面下载whl匹配版本的文件：</p>
<p><a href="https://download.csdn.net/download/master_hunter/86438210" title="pyjnius-1.4.2-cp37-cp37m-win32.whl-Python文档类资源-CSDN下载">pyjnius-1.4.2-cp37-cp37m-win32.whl-Python文档类资源-CSDN下载</a></p>
<p>下载whl文件之后进入cmd上面cd到当前下载的目录下面，pip该文件就好了。</p>
<h2 id="2.%E7%9B%B8%E5%85%B3%E4%BE%9D%E8%B5%96">2.相关依赖</h2>
<p>由于是调用的JAVA的Class类那肯定需要的依赖比较多，需要安装cython这个库，如果大家有装acaconda的话去环境里面下载就好了，而pyjnius在anaconda里面是没有的，也不知道是不是我版本太低了没有找到。当然网络连接稳定的直接pip就好了，接连的话要在下载一个gcc编译器：</p>
<pre><code>yum install gcc gcc-++
pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple cython
</code></pre>
<p> 当然自然需要JAVA环境了，需要大家自行下载JDK，我相信这个是个程序员应该都装过，那么JAVA_HOME应该都配置过了，但是这里需要再额外配置一下环境变量PATH，需要找到jvm.dll：</p>
<pre><code>C:\Program Files\Java\jdk1.7.0_79\jre\bin\server </code></pre>
<p>其中java的中的bin目录下server里面就有java的jvm.dll文件了。</p>
<h1 id="%E4%BA%8C%E3%80%81%E4%BD%BF%E7%94%A8%E6%B5%8B%E8%AF%95">二、使用测试</h1>
<p>我们可以试试调用JAVA自身的一些类来使用，就类似于python自带的原始库。我建议是如果大家想要使用其他的jar包的话最好是使用pycharm来实现，Jupyter是我主要用的一个编译器但是使用jnius的话config设置路径的话会报错，如果使用pycharm就没有事。</p>
<pre><code class="language-python">from jnius import autoclass

Stack = autoclass('java.util.Stack')
stack = Stack()
stack.push('hello world')</code></pre>
<p><img alt="" height="75" src="image\fe800335d7fd4276852eef0678418550.png" width="339"/></p>
<p> 如果返回类型不是Python类型，Pyjnius使用Java反射提供一个新的autoclass（）。</p>
<pre><code class="language-python">System = autoclass('java.lang.System')
System</code></pre>
<p><img alt="" height="52" src="image\3db0d39dbca7495e955d4e2400835a95.png" width="376"/></p>
<pre><code class="language-python">System.out</code></pre>
<p><img alt="" height="80" src="image\83481d5d76e746609ee21699d01a1aed.png" width="1197"/></p>
<p> 递归反射可以提供一个Reflection返回的Java对象的适当对象。</p>
<h1 id="%E4%B8%89%E3%80%81Reflection%E7%B1%BB"><a id="2_34"></a>三、Reflection类</h1>
<p>用于反映Java类的基。其思想是对这个JavaClass进行子类化，添加一些JavaMethod、JavaStaticMethod，JavaField和JavaStaticField。</p>
<p>类似这种形式：</p>
<pre><code class="language-python">from jnius import JavaClass, MetaJavaClass

class Stack(JavaClass):
    __javaclass__ = 'java/util/Stack'
    __metaclass__ = MetaJavaClass</code></pre>
<ul><li>__metaclass__: 必须设置为MetaJavaClass，否则，声明的所有方法/字段将不会链接到JavaClass。</li><li>__javaclass__:表示Java类名，格式为“org/lang/class”（例如“Java/util/Stack”），而不是“org.lang.class”。</li><li>__javaconstructor__:如果未设置，假设默认构造函数不带参数。否则，它可以是构造函数的所有可能签名的列表。</li></ul>
<p>例如，字符串java类的反射如下所示：</p>
<pre><code class="language-python">class String(JavaClass):
    __javaclass__ == 'java/lang/String'
    __metaclass__ = MetaJavaClass
    __javaconstructor__ == (
        '()V',
        '(Ljava/lang/String;)V',
        '([C)V',
        '([CII)V',
        # ...
    )</code></pre>
<p>  </p>
<p>还有更多类就不一一详说了，核心类就这三个，更多的类都是基于此衍生出来的</p>
<h1 id="%E5%9B%9B%E3%80%81Reflection%E5%87%BD%E6%95%B0">四、Reflection函数</h1>
<h2 id="1.jnius.autoclass(name)">1.jnius.autoclass(name)</h2>
<p>返回表示从name传递的类的JavaClass。名称必须采用a.b.c格式，而不是a/b/c格式。</p>
<pre><code class="language-python">from jnius import autoclassQ
autoclass('java.lang.System')</code></pre>
<p> <img alt="" height="49" src="image\af20477c99344783852bec1070e146ee.png" width="467"/></p>
<p>当JAVA出现了Python的关键字时（例如from、class等）的成员。需要使用getattr（）来访问该成员，然后才能调用它：</p>
<pre><code class="language-python">from jnius import autoclass
func_from = getattr(autoclass('some.java.Class'),'from')
func_from()</code></pre>
<p> SomeClass还有一个特例。类文本，可以将其作为SomeClass的结果找到。getClass（）或__javaclass__ python属性中。</p>
<h2 id="%C2%A0Python%E4%B8%AD%E7%9A%84Java%E7%B1%BB%E5%AE%9E%E7%8E%B0%C2%A0"> Python中的Java类实现 </h2>
<p>从Python类创建Java类的基础。可以完全用Python实现java接口。<br/> 实际上，将创建一个Python类，它模仿声明的__javainterfaces__列表。当将这个类的实例提供给Java时，Java将只接受它并调用声明的接口方法。在幕后，我们正在捕获调用，并将其重定向到使用声明的Python方法。创建的类将充当Java接口的代理。<br/> 但是需要至少定义__javainterfaces__属性，并使用java_method（）修饰符声明java方法。</p>
<pre><code class="language-python">from jnius import PythonJavaClass, java_method

class PythonListIterator(PythonJavaClass):
    __javainterfaces__ = ['java/util/ListIterator']

    def __init__(self, collection, index=0):
        super(TestImplemIterator, self).__init__()
        self.collection = collection
        self.index = index

    @java_method('()Z')
    def hasNext(self):
        return self.index &lt; len(self.collection.data) - 1

    @java_method('()Ljava/lang/Object;')
    def next(self):
        obj = self.collection.data[self.index]
        self.index += 1
        return obj</code></pre>
<ul><li>__javainterfaces__:要代理的Java接口列表，格式为“org/lang/Class”（例如“Java/util/Iterator”），而不是“org.lang.Class”。</li><li>__javacontext__:指示要使用的类加载器，“系统”或“应用程序”。默认值为“系统”。</li></ul>
<h3 id="jnius.java_method">jnius.java_method</h3>
<p>与PythonJavaClass一起使用的装饰函数。java_signature必须与接口的所需签名匹配。默认情况下，方法的名称将是Python方法的名称。如果多个签名具有相同的Java方法名，仍然可以强制执行。</p>
<pre><code class="language-python">class PythonListIterator(PythonJavaClass):
    __javainterfaces__ = ['java/util/ListIterator']

    @java_method('()Ljava/lang/Object;')
    def next(self):
        obj = self.collection.data[self.index]
        self.index += 1
        return obj</code></pre>
<h2 id="Java%E7%AD%BE%E5%90%8D%E6%A0%BC%E5%BC%8F%C2%A0">Java签名格式 </h2>
<p>Java签名有一种特殊的格式，一开始可能很难理解。让我们看看细节。签名的格式为：</p>
<pre><code class="language-python">(&lt;argument1&gt;&lt;argument2&gt;&lt;...&gt;)&lt;return type&gt;</code></pre>
<p> 签名任何部分的所有类型都可以是以下类型之一：</p>
<ul><li>L&lt;java class&gt;; = represent a Java object of the type &lt;java class&gt;</li><li>Z = represent a java/lang/Boolean;</li><li>B = represent a java/lang/Byte;</li><li>C = represent a java/lang/Character;</li><li>S = represent a java/lang/Short;</li><li>I = represent a java/lang/Integer;</li><li>J = represent a java/lang/Long;</li><li>F = represent a java/lang/Float;</li><li>D = represent a java/lang/Double;</li><li>V = represent void, available only for the return type</li></ul>
<p>所有类型都可以具有[前缀以指示数组。返回类型可以是V或空。</p>
<pre><code class="language-python">(ILjava/util/List;)V
-&gt; argument 1 is an integer
-&gt; argument 2 is a java.util.List object
-&gt; the method doesn't return anything.

(java.util.Collection;[java.lang.Object;)V
-&gt; argument 1 is a Collection
-&gt; argument 2 is an array of Object
-&gt; nothing is returned

([B)Z
-&gt; argument 1 is a Byte []
-&gt; a boolean is returned</code></pre>
<p> 在Python中实现Java时，Java方法的签名必须匹配。Java提供了一个名为javap的工具来获取任何Java类的签名。例如：</p>
<pre><code class="language-java">$ javap -s java.util.Iterator
Compiled from "Iterator.java"
public interface java.util.Iterator{
public abstract boolean hasNext();
  Signature: ()Z
public abstract java.lang.Object next();
  Signature: ()Ljava/lang/Object;
public abstract void remove();
  Signature: ()V
}</code></pre>
<h2 id="JVM%E9%80%89%E9%A1%B9%E5%92%8C%E7%B1%BB%E8%B7%AF%E5%BE%84%C2%A0">JVM选项和类路径 </h2>
<p>在调用导入JNIU之前需要设置JVM选项，因为它们在VM启动后无法更改。为此，可以：</p>
<pre><code class="language-python">#antlrtest.py
import jnius_config
jnius_config.add_options('-Xms4096m')
jnius_config.set_classpath('./','./jar_package/antlr-3.5.2-complete.jar')
import jnius</code></pre>
<p>其中 ：</p>
<p>jnius_config.add_options():此选项为Jvm参数：</p>
<ul><li>-Xms4096m：初始堆内存4g</li><li>-Xmx4096m：最大堆内存4g</li><li>-Xmn1024m：年轻代1g</li><li>-Xss256K：每个线程占用的空间</li><li>-XX:+DisableExplicitGC：禁止显示调用gc</li><li>-XX:MaxTenuringThreshold=15：在年轻代存活次数</li><li>-XX:+UseParNewGC：对年轻代采用多线程并行回收</li><li>-XX:+UseConcMarkSweepGC：年老代采用CMS回收</li><li>-XX:+CMSParallelRemarkEnabled：在使用UseParNewGC 的情况下, 尽量减少 mark 的时间</li><li>-XX:+UseCMSCompactAtFullCollection：在使用concurrent gc 的情况下, 防止 memoryfragmention, 对live object 进行整理, 使 memory 碎片减少</li><li>-XX:LargePageSizeInBytes=128m：指定 Java heap的分页页面大小</li><li>-XX:+UseFastAccessorMethods：get,set 方法转成本地代码</li><li>-XX:+UseCMSInitiatingOccupancyOnly：指示只有在 oldgeneration 在使用了初始化的比例后concurrent collector 启动收集</li><li>-XX:CMSInitiatingOccupancyFraction=70：年老代到达70%进行gc</li><li>-Djava.awt.headless=true ：Headless模式是系统的一种配置模式。在该模式下，系统缺少了显示设备、键盘或鼠标。</li><li>-XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:/home/gclogs/gc.log：打印日志信息</li></ul>
<p>jnius_config.set_classpath():JAVAclassPATH，路径可为想要运行的所有jar包。</p>
<p>如果使用这些函数设置了类路径，它将覆盖任何类路径环境变量。应将多个选项或路径条目作为多个参数提供给add_和set_函数。如果未提供类路径且未设置类路径，则路径默认为“.”。此功能在Android上不可用。</p>
<h2 id="%E5%AE%8C%E6%95%B4%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B%3A">完整使用案例:</h2>
<p>pyjnius库的实际内容没有多少，主要是桥梁作用，这里放上一段使用pyjnius来调用JAVAjar包的实际案例：</p>
<pre><code class="language-python">#antlrtest.py
import jnius_config
jnius_config.set_classpath('./','./grammar/hive310/antlr-3.5.2-complete.jar')
import jnius
StringStream = jnius.autoclass('org.antlr.runtime.ANTLRStringStream')
Lexer  = jnius.autoclass('grammar.hive310.HiveLexer')
TokenStream  = jnius.autoclass('org.antlr.runtime.CommonTokenStream')

cstream = StringStream("select * from new_table;")
inst = Lexer(cstream)
ts = TokenStream()
ts.setTokenSource(inst)
ts.fill()

jlist = ts.getTokens()
tsize = jlist.size()
for i in range(tsize):
    print(jlist.get(i).getText())

</code></pre>
<blockquote>
<p>select<br/>  <br/> *<br/>  <br/> from<br/>  <br/> new_table<br/> ;<br/> &lt;EOF&gt;</p>
<p>Process finished with exit code 0</p>
</blockquote>
<hr/>
<p> </p>
<h2 id="%E7%82%B9%E5%85%B3%E6%B3%A8%EF%BC%8C%E9%98%B2%E8%B5%B0%E4%B8%A2%EF%BC%8C%E5%A6%82%E6%9C%89%E7%BA%B0%E6%BC%8F%E4%B9%8B%E5%A4%84%EF%BC%8C%E8%AF%B7%E7%95%99%E8%A8%80%E6%8C%87%E6%95%99%EF%BC%8C%E9%9D%9E%E5%B8%B8%E6%84%9F%E8%B0%A2">点关注，防走丢，<strong>如有纰漏之处，请留言指教，非常感谢</strong></h2>
<p>以上就是本期全部内容。我是fanstuck ，有问题大家随时留言讨论 ，我们下期见。</p>
</div>
</div>