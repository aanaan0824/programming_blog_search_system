<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<p>本项目是基于自学b站中 黑马程序员 的瑞吉外卖项目:视频链接：</p>
<p><a class="has-card" href="https://www.bilibili.com/video/BV13a411q753?spm_id_from=333.337.search-card.all.click" title="黑马程序员Java项目实战《瑞吉外卖》，轻松掌握springboot + mybatis plus开发核心技术的真java实战项目_哔哩哔哩_bilibili"><span class="link-card-box"><span class="link-title">黑马程序员Java项目实战《瑞吉外卖》，轻松掌握springboot + mybatis plus开发核心技术的真java实战项目_哔哩哔哩_bilibili</span><span class="link-link"><img alt="" class="link-link-icon" src="image\icon-default.png"/>https://www.bilibili.com/video/BV13a411q753?spm_id_from=333.337.search-card.all.click</span></span></a>这篇博客是<span style="color:#fe2c24;"><strong>记录自己学习该项目的markdown笔记</strong></span>；并且自己把视频中一些没实现的功能给实现了；<span style="color:#38d8f0;"><strong>本人技术可能不到位，笔记仅供参考学习使用</strong></span><span style="color:#fe2c24;"><strong>；</strong></span></p>
<p><span style="color:#fe2c24;"><strong>本人自己把视频中老师没讲的一些功能给实现了，比如，后台按条件查询客户订单，用户个人查询自己的订单，菜品，套餐的启售，停售，购物车中菜品或者是套餐数量减少，后台套餐的修改。代码不一定规范，但是功能是没问题的！！！</strong></span></p>
<p>项目中的资料下载链接：（从黑马公众号获取到的最初状态的源码，后面自己补充了一些课程没讲的功能，功能的实现代码在我博客的笔记中有）</p>
<p>链接：https://pan.baidu.com/s/1cdHI5cDjyHKZ4_0GmIevnQ <br/> 提取码：668a</p>
<p id="main-toc"></p>
<p id="main-toc"><strong>目录</strong></p>
<p id="%E4%B8%80%E3%80%81%E9%A1%B9%E7%9B%AE%E8%83%8C%E6%99%AF%E4%BB%8B%E7%BB%8D%C2%A0-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E9%A1%B9%E7%9B%AE%E8%83%8C%E6%99%AF%E4%BB%8B%E7%BB%8D%C2%A0">一、项目背景介绍 </a></p>
<p id="%E4%BA%8C%E3%80%81%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%95%B4%E4%BD%93%E4%BB%8B%E7%BB%8D-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%95%B4%E4%BD%93%E4%BB%8B%E7%BB%8D">二、软件开发整体介绍</a></p>
<p id="%E4%B8%89%E3%80%81%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA">三、开发环境的搭建</a></p>
<p id="%E2%91%A0%E6%95%B0%E6%8D%AE%E5%BA%93%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA-toc" style="margin-left:40px;"><a href="#%E2%91%A0%E6%95%B0%E6%8D%AE%E5%BA%93%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA">①数据库环境的搭建</a></p>
<p id="%E2%91%A1maven%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA-toc" style="margin-left:40px;"><a href="#%E2%91%A1maven%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA">②maven项目搭建</a></p>
<p id="%E2%91%A2%E5%AF%BC%E5%85%A5%E5%89%8D%E7%AB%AF%E6%96%87%E4%BB%B6-toc" style="margin-left:40px;"><a href="#%E2%91%A2%E5%AF%BC%E5%85%A5%E5%89%8D%E7%AB%AF%E6%96%87%E4%BB%B6">③导入前端文件</a></p>
<p id="%E5%9B%9B%E3%80%81%E5%90%8E%E5%8F%B0%E7%99%BB%E9%99%86%E5%8A%9F%E8%83%BD%E5%BC%80%E5%8F%91-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E5%90%8E%E5%8F%B0%E7%99%BB%E9%99%86%E5%8A%9F%E8%83%BD%E5%BC%80%E5%8F%91">四、后台登陆功能开发</a></p>
<p id="%E2%91%A0%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E2%91%A0%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%EF%BC%9A">①需求分析：</a></p>
<p id="%E2%91%A1%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E2%91%A1%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91%EF%BC%9A">②代码开发：</a></p>
<p id="%E5%AE%9E%E4%BD%93%E7%B1%BB%E5%92%8Cmapper%E7%9A%84%E5%BC%80%E5%8F%91-toc" style="margin-left:80px;"><a href="#%E5%AE%9E%E4%BD%93%E7%B1%BB%E5%92%8Cmapper%E7%9A%84%E5%BC%80%E5%8F%91">实体类和mapper的开发</a></p>
<p id="service-toc" style="margin-left:80px;"><a href="#service">service</a></p>
<p id="%E5%B0%81%E8%A3%85%E8%BF%94%E5%9B%9E%E7%9A%84%E7%BB%93%E6%9E%9C%E7%B1%BB-toc" style="margin-left:80px;"><a href="#%E5%B0%81%E8%A3%85%E8%BF%94%E5%9B%9E%E7%9A%84%E7%BB%93%E6%9E%9C%E7%B1%BB">封装返回的结果类</a></p>
<p id="controller-toc" style="margin-left:80px;"><a href="#controller">controller</a></p>
<p id="%E2%91%A2%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E2%91%A2%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95%EF%BC%9A">③功能测试：</a></p>
<p id="%E4%BA%94%E3%80%81%E5%90%8E%E5%8F%B0%E7%B3%BB%E7%BB%9F%E9%80%80%E5%87%BA%E5%8A%9F%E8%83%BD-toc" style="margin-left:0px;"><a href="#%E4%BA%94%E3%80%81%E5%90%8E%E5%8F%B0%E7%B3%BB%E7%BB%9F%E9%80%80%E5%87%BA%E5%8A%9F%E8%83%BD">五、后台系统退出功能</a></p>
<p id="%E5%85%AD%E3%80%81%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97-toc" style="margin-left:0px;"><a href="#%E5%85%AD%E3%80%81%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97">六、员工管理模块</a></p>
<p id="%E5%AE%8C%E5%96%84%E7%99%BB%E9%99%86%E5%8A%9F%E8%83%BD-toc" style="margin-left:40px;"><a href="#%E5%AE%8C%E5%96%84%E7%99%BB%E9%99%86%E5%8A%9F%E8%83%BD">完善登陆功能</a></p>
<p id="%E6%96%B0%E5%A2%9E%E5%91%98%E5%B7%A5-toc" style="margin-left:40px;"><a href="#%E6%96%B0%E5%A2%9E%E5%91%98%E5%B7%A5">新增员工</a></p>
<p id="%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7-toc" style="margin-left:80px;"><a href="#%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7">全局异常捕获</a></p>
<p id="%E5%91%98%E5%B7%A5%E4%BF%A1%E6%81%AF%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2-toc" style="margin-left:40px;"><a href="#%E5%91%98%E5%B7%A5%E4%BF%A1%E6%81%AF%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2">员工信息分页查询</a></p>
<p id="%E5%90%AF%E7%94%A8%2F%E7%A6%81%E7%94%A8%E5%91%98%E5%B7%A5%E8%B4%A6%E5%8F%B7-toc" style="margin-left:40px;"><a href="#%E5%90%AF%E7%94%A8%2F%E7%A6%81%E7%94%A8%E5%91%98%E5%B7%A5%E8%B4%A6%E5%8F%B7">启用/禁用员工账号</a></p>
<p id="%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B6%88%E6%81%AF%E8%BD%AC%E6%8D%A2%E5%99%A8-toc" style="margin-left:80px;"><a href="#%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B6%88%E6%81%AF%E8%BD%AC%E6%8D%A2%E5%99%A8">使用自定义消息转换器</a></p>
<p id="%E7%BC%96%E8%BE%91%E5%91%98%E5%B7%A5%E4%BF%A1%E6%81%AF-toc" style="margin-left:40px;"><a href="#%E7%BC%96%E8%BE%91%E5%91%98%E5%B7%A5%E4%BF%A1%E6%81%AF">编辑员工信息</a></p>
<p id="%E4%B8%83%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86-toc" style="margin-left:0px;"><a href="#%E4%B8%83%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86">七、菜品分类管理</a></p>
<p id="%E5%85%AC%E5%85%B1%E5%AD%97%E6%AE%B5%E5%A1%AB%E5%85%85(%E8%BF%99%E9%87%8C%E6%9C%89%E9%87%8D%E7%82%B9)-toc" style="margin-left:40px;"><a href="#%E5%85%AC%E5%85%B1%E5%AD%97%E6%AE%B5%E5%A1%AB%E5%85%85%28%E8%BF%99%E9%87%8C%E6%9C%89%E9%87%8D%E7%82%B9%29">公共字段填充(这里有重点)</a></p>
<p id="%E6%96%B0%E5%A2%9E%E5%88%86%E7%B1%BB-toc" style="margin-left:40px;"><a href="#%E6%96%B0%E5%A2%9E%E5%88%86%E7%B1%BB">新增分类</a></p>
<p id="%E8%8F%9C%E5%93%81%E7%B1%BB%E7%9A%84%E5%88%86%E9%A1%B5-toc" style="margin-left:40px;"><a href="#%E8%8F%9C%E5%93%81%E7%B1%BB%E7%9A%84%E5%88%86%E9%A1%B5">菜品类的分页</a></p>
<p id="%E5%88%A0%E9%99%A4%E5%88%86%E7%B1%BB%EF%BC%88%E8%BF%99%E9%87%8C%E6%9C%89%E6%B3%A8%E6%84%8F%E7%82%B9%EF%BC%89-toc" style="margin-left:40px;"><a href="#%E5%88%A0%E9%99%A4%E5%88%86%E7%B1%BB%EF%BC%88%E8%BF%99%E9%87%8C%E6%9C%89%E6%B3%A8%E6%84%8F%E7%82%B9%EF%BC%89">删除分类（这里有注意点）</a></p>
<p id="%E4%BF%AE%E6%94%B9%E5%88%86%E7%B1%BB-toc" style="margin-left:40px;"><a href="#%E4%BF%AE%E6%94%B9%E5%88%86%E7%B1%BB">修改分类</a></p>
<p id="%E5%85%AB%E3%80%81%E8%8F%9C%E5%93%81%E7%AE%A1%E7%90%86%E7%9A%84%E4%B8%9A%E5%8A%A1%E5%8A%9F%E8%83%BD-toc" style="margin-left:0px;"><a href="#%E5%85%AB%E3%80%81%E8%8F%9C%E5%93%81%E7%AE%A1%E7%90%86%E7%9A%84%E4%B8%9A%E5%8A%A1%E5%8A%9F%E8%83%BD">八、菜品管理的业务功能</a></p>
<p id="%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89-toc" style="margin-left:40px;"><a href="#%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89">文件的上传和下载（重点）</a></p>
<p id="%E6%96%B0%E5%A2%9E%E8%8F%9C%E5%93%81%EF%BC%88%E4%B8%9A%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%98%AF%E9%87%8D%E7%82%B9%EF%BC%89-toc" style="margin-left:40px;"><a href="#%E6%96%B0%E5%A2%9E%E8%8F%9C%E5%93%81%EF%BC%88%E4%B8%9A%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%98%AF%E9%87%8D%E7%82%B9%EF%BC%89">新增菜品（业务的实现是重点）</a></p>
<p id="%E6%8E%A5%E6%94%B6%E9%A1%B5%E9%9D%A2%E6%8F%90%E4%BA%A4%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%88%E6%B6%89%E5%8F%8A%E4%B8%A4%E5%BC%A0%E8%A1%A8%EF%BC%89-toc" style="margin-left:40px;"><a href="#%E6%8E%A5%E6%94%B6%E9%A1%B5%E9%9D%A2%E6%8F%90%E4%BA%A4%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%88%E6%B6%89%E5%8F%8A%E4%B8%A4%E5%BC%A0%E8%A1%A8%EF%BC%89">接收页面提交的数据（涉及两张表）</a></p>
<p id="%E8%8F%9C%E5%93%81%E4%BF%A1%E6%81%AF%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2(%E5%8A%9F%E8%83%BD%E5%AE%8C%E5%96%84%E9%87%8C%E9%9D%A2%E7%9A%84%E4%BB%A3%E7%A0%81%E8%A6%81%E7%86%9F%E6%82%89%2C%E6%9C%89%E9%9B%86%E5%90%88%E6%B3%9B%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2%EF%BC%8C%E5%AF%B9%E8%B1%A1copy)-toc" style="margin-left:40px;"><a href="#%E8%8F%9C%E5%93%81%E4%BF%A1%E6%81%AF%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2%28%E5%8A%9F%E8%83%BD%E5%AE%8C%E5%96%84%E9%87%8C%E9%9D%A2%E7%9A%84%E4%BB%A3%E7%A0%81%E8%A6%81%E7%86%9F%E6%82%89%2C%E6%9C%89%E9%9B%86%E5%90%88%E6%B3%9B%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2%EF%BC%8C%E5%AF%B9%E8%B1%A1copy%29">菜品信息分页查询(功能完善里面的代码要熟悉,有集合泛型的转换，对象copy)</a></p>
<p id="%E4%BF%AE%E6%94%B9%E8%8F%9C%E5%93%81(%E5%9B%9E%E6%98%BE%E5%92%8C%E4%BF%9D%E5%AD%98%E4%BF%AE%E6%94%B9%E9%83%BD%E6%98%AF%E4%B8%A4%E5%BC%A0%E8%A1%A8)-toc" style="margin-left:40px;"><a href="#%E4%BF%AE%E6%94%B9%E8%8F%9C%E5%93%81%28%E5%9B%9E%E6%98%BE%E5%92%8C%E4%BF%9D%E5%AD%98%E4%BF%AE%E6%94%B9%E9%83%BD%E6%98%AF%E4%B8%A4%E5%BC%A0%E8%A1%A8%29">修改菜品(回显和保存修改都是两张表)</a></p>
<p id="%E8%8F%9C%E5%93%81%E4%BF%A1%E6%81%AF%E7%9A%84%E5%9B%9E%E6%98%BE%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E8%8F%9C%E5%93%81%E4%BF%A1%E6%81%AF%E7%9A%84%E5%9B%9E%E6%98%BE%EF%BC%9A">菜品信息的回显：</a></p>
<p id="%E4%BF%9D%E5%AD%98%E4%BF%AE%E6%94%B9%EF%BC%9A(%E9%87%8D%E7%82%B9)-toc" style="margin-left:80px;"><a href="#%E4%BF%9D%E5%AD%98%E4%BF%AE%E6%94%B9%EF%BC%9A%28%E9%87%8D%E7%82%B9%29">保存修改：(重点)</a></p>
<p id="%E9%9C%80%E8%A6%81%E8%87%AA%E5%B7%B1%E5%8D%95%E7%8B%AC%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8A%9F%E8%83%BD-toc" style="margin-left:40px;"><a href="#%E9%9C%80%E8%A6%81%E8%87%AA%E5%B7%B1%E5%8D%95%E7%8B%AC%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8A%9F%E8%83%BD">需要自己单独实现的功能</a></p>
<p id="%E4%B9%9D%E3%80%81%E5%A5%97%E9%A4%90%E7%AE%A1%E7%90%86-toc" style="margin-left:0px;"><a href="#%E4%B9%9D%E3%80%81%E5%A5%97%E9%A4%90%E7%AE%A1%E7%90%86">九、套餐管理</a></p>
<p id="%E6%B7%BB%E5%8A%A0%E8%8F%9C%E5%93%81%E6%95%B0%E6%8D%AE%E5%9B%9E%E6%98%BE-toc" style="margin-left:40px;"><a href="#%E6%B7%BB%E5%8A%A0%E8%8F%9C%E5%93%81%E6%95%B0%E6%8D%AE%E5%9B%9E%E6%98%BE">添加菜品数据回显</a></p>
<p id="%E4%BF%9D%E5%AD%98%E6%B7%BB%E5%8A%A0%E5%A5%97%E9%A4%90%EF%BC%88%E7%90%86%E8%A7%A3%E9%87%8C%E9%9D%A2%E7%9A%84%E5%85%B3%E7%B3%BB%E6%9C%89%E7%82%B9%E5%9B%B0%E9%9A%BE%EF%BC%89-toc" style="margin-left:40px;"><a href="#%E4%BF%9D%E5%AD%98%E6%B7%BB%E5%8A%A0%E5%A5%97%E9%A4%90%EF%BC%88%E7%90%86%E8%A7%A3%E9%87%8C%E9%9D%A2%E7%9A%84%E5%85%B3%E7%B3%BB%E6%9C%89%E7%82%B9%E5%9B%B0%E9%9A%BE%EF%BC%89">保存添加套餐（理解里面的关系有点困难）</a></p>
<p id="%E5%A5%97%E9%A4%90%E4%BF%A1%E6%81%AF%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2-toc" style="margin-left:40px;"><a href="#%E5%A5%97%E9%A4%90%E4%BF%A1%E6%81%AF%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2">套餐信息分页查询</a></p>
<p id="%E5%88%A0%E9%99%A4%E5%A5%97%E9%A4%90-toc" style="margin-left:40px;"><a href="#%E5%88%A0%E9%99%A4%E5%A5%97%E9%A4%90">删除套餐</a></p>
<p id="%E9%9C%80%E8%A6%81%E8%87%AA%E5%B7%B1%E5%8D%95%E7%8B%AC%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8A%9F%E8%83%BD-toc" style="margin-left:40px;"><a href="#%E9%9C%80%E8%A6%81%E8%87%AA%E5%B7%B1%E5%8D%95%E7%8B%AC%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8A%9F%E8%83%BD">需要自己单独实现的功能</a></p>
<p id="%E5%A5%97%E9%A4%90%E7%AE%A1%E7%90%86%E7%9A%84%E5%90%AF%E5%94%AE%EF%BC%8C%E5%81%9C%E5%94%AE-toc" style="margin-left:80px;"><a href="#%E5%A5%97%E9%A4%90%E7%AE%A1%E7%90%86%E7%9A%84%E5%90%AF%E5%94%AE%EF%BC%8C%E5%81%9C%E5%94%AE">套餐管理的启售，停售</a></p>
<p id="%E5%A5%97%E9%A4%90%E7%AE%A1%E7%90%86%E7%9A%84%E4%BF%AE%E6%94%B9-toc" style="margin-left:80px;"><a href="#%E5%A5%97%E9%A4%90%E7%AE%A1%E7%90%86%E7%9A%84%E4%BF%AE%E6%94%B9">套餐管理的修改</a></p>
<p id="%E5%90%8E%E5%8F%B0%E8%AE%A2%E5%8D%95%E5%B1%95%E7%A4%BA%E5%92%8C%E6%9F%A5%E8%AF%A2%EF%BC%88%E8%87%AA%E5%B7%B1%E5%86%99%E7%9A%84%EF%BC%8C%E6%9C%89%E9%87%8D%E7%82%B9%EF%BC%89-toc" style="margin-left:80px;"><a href="#%E5%90%8E%E5%8F%B0%E8%AE%A2%E5%8D%95%E5%B1%95%E7%A4%BA%E5%92%8C%E6%9F%A5%E8%AF%A2%EF%BC%88%E8%87%AA%E5%B7%B1%E5%86%99%E7%9A%84%EF%BC%8C%E6%9C%89%E9%87%8D%E7%82%B9%EF%BC%89">后台订单展示和查询</a></p>
<p id="%E6%89%8B%E6%9C%BA%E7%AB%AF%E5%BC%80%E5%8F%91-toc" style="margin-left:0px;"><a href="#%E6%89%8B%E6%9C%BA%E7%AB%AF%E5%BC%80%E5%8F%91">手机端开发</a></p>
<p></p>
<h1 id="%E4%B8%80%E3%80%81%E9%A1%B9%E7%9B%AE%E8%83%8C%E6%99%AF%E4%BB%8B%E7%BB%8D%C2%A0">一、项目背景介绍 </h1>
<p><img alt="" height="324" src="image\92727ae292b14a24996d5a526a5ee90c.png" width="1175"/></p>
<p><img alt="" height="267" src="image\3e90581aedf64d4eb4b646b51d3b4929.png" width="1112"/></p>
<p><img alt="" height="138" src="image\a3a09d1a239d486abd3306426e52662d.png" width="783"/></p>
<p>技术选型：</p>
<p><img alt="" height="369" src="image\db9ec8dbf6504234858b7399aa76e76f.png" width="1164"/></p>
<p> <img alt="" height="607" src="image\12f1d5ebc08e4b80b4d0b5fa11e1d727.png" width="1158"/></p>
<p> <img alt="" height="618" src="image\de19a5cef07e4ae78a24dba01a82d467.png" width="1150"/></p>
<p></p>
<h1 id="%E4%BA%8C%E3%80%81%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%95%B4%E4%BD%93%E4%BB%8B%E7%BB%8D">二、软件开发整体介绍</h1>
<p><img alt="" height="732" src="image\963fad196e7b4aeb9b823f22ebb8a899.png" width="1153"/></p>
<p><img alt="" height="399" src="image\9856cd7e85254ce1bb1cb7b394b79b91.png" width="1169"/></p>
<p></p>
<p></p>
<h1 id="%E4%B8%89%E3%80%81%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA">三、开发环境的搭建</h1>
<h2 id="%E2%91%A0%E6%95%B0%E6%8D%AE%E5%BA%93%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA">①数据库环境的搭建</h2>
<p>1.创建数据库：</p>
<p><img alt="" height="366" src="image\361b21dabc88456aa485f33e93be488b.png" width="958"/></p>
<p>2.导入表结构，直接运行外部SQL文件；</p>
<p><img alt="" height="457" src="image\22ab750199ce4d1db22226f7843cb271.png" width="440"/></p>
<p> <img alt="" height="553" src="image\d4b95aa97f2f4a1cacd8fc49ba618055.png" width="850"/></p>
<p>数据表的说明：</p>
<table><thead><tr><th>序号</th><th>表名</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>employee</td><td>员工表</td></tr><tr><td>2</td><td>category</td><td>菜品和套餐分类表</td></tr><tr><td>3</td><td>dish</td><td>菜品表</td></tr><tr><td>4</td><td>setmeal</td><td>套餐表</td></tr><tr><td>5</td><td>setmeal_dish</td><td>套餐菜品关系表</td></tr><tr><td>6</td><td>dish_flavor</td><td>菜品口味关系表</td></tr><tr><td>7</td><td>user</td><td>用表(c端)</td></tr><tr><td>8</td><td>address_book</td><td>地址薄表</td></tr><tr><td>9</td><td>shopping_cart</td><td>购物车表</td></tr><tr><td>10</td><td>orders</td><td>订单表</td></tr><tr><td>11</td><td>orders_detail</td><td>订单明细表</td></tr></tbody></table>
<p></p>
<h2 id="%E2%91%A1maven%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA">②maven项目搭建</h2>
<p> 1.创建一个maven项目</p>
<p><img alt="" height="467" src="image\4bdf4db101e645f0a6bed07ebd40a51d.png" width="1194"/></p>
<p>注意:创建maven项目后，一定要检查项目的编码，maven仓库的配置，jdk的配置等；</p>
<p><img alt="" height="342" src="image\577d56316ac244c08371e50f2fd40aa6.png" width="1193"/><img alt="" height="293" src="image\1a0262a93bf8495a9b9892216a7a4519.png" width="1190"/></p>
<p><img alt="" height="396" src="image\d96d70510ba44b24b4451cafede42ab9.png" width="1193"/></p>
<p> 2.导入pom文件</p>
<pre><code class="language-XML">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.6.6&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;

    &lt;groupId&gt;com.itheima&lt;/groupId&gt;
    &lt;artifactId&gt;reggie_take_out&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
            &lt;scope&gt;compile&lt;/scope&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;3.4.2&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;version&gt;1.18.20&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
            &lt;version&gt;1.2.76&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;commons-lang&lt;/groupId&gt;
            &lt;artifactId&gt;commons-lang&lt;/artifactId&gt;
            &lt;version&gt;2.6&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;1.1.23&lt;/version&gt;
        &lt;/dependency&gt;

    &lt;/dependencies&gt;

    &lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;version&gt;2.6.6&lt;/version&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
    &lt;/build&gt;

&lt;/project&gt;</code></pre>
<p> 3.创建application.yml文件：</p>
<pre><code class="language-bash">server:
  port: 8080
spring:
  application:
    # 应用的名称，选择性配置
    name: reggie_take_out
  datasource:
    druid:
      driver-class-name: com.mysql.cj.jdbc.Driver
      url: jdbc:mysql://localhost:3306/reggie?serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=false&amp;allowPublicKeyRetrieval=true
      username: root
      password: root
mybatis-plus:
  configuration:
    #在映射实体或者属性时，将数据库中表名和字段名中的下划线去掉，按照驼峰命名法映射
    map-underscore-to-camel-case: true
    # 把SQL的查询的过程输出到控制台
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
  global-config:
    db-config:
      id-type: ASSIGN_ID</code></pre>
<p> 3.创建Boot程序入口</p>
<pre><code class="language-java">package com.itheima.reggie;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

/**
 * @author LJM
 * @create 2022/4/14
 */
@Slf4j
@SpringBootApplication
@ServletComponentScan
public class ReggieApplication {
    public static void main(String[] args) {
        SpringApplication.run(ReggieApplication.class,args);
        log.info("项目启动成功...");
    }
}</code></pre>
<p>4.运行Boot程序，看是否成功；</p>
<p></p>
<h2 id="%E2%91%A2%E5%AF%BC%E5%85%A5%E5%89%8D%E7%AB%AF%E6%96%87%E4%BB%B6">③导入前端文件</h2>
<p>注意前端文件的位置，在Boot项目中，前台默认就只能访问 resource目录下的static和template文件夹下的文件；所以如果要使用这种方式，直接创建一个static目录就行，然后把这些前端资源放在这个static目录下就行；</p>
<p>如果你不想把前端文件放在这两个默认的文件夹下，那么就可以自己定义mvc的支持，这里我们使用的就是这方式；（多学习一种定义的方法，以后自定义映射的时候可以使用）</p>
<p><img alt="" height="597" src="image\2ccd159f824e48568fdf26532919c75e.png" width="777"/></p>
<pre><code class="language-java">package com.itheima.reggie.config;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;

/**
 * @author LJM
 * @create 2022/4/14
 */
@Slf4j
@Configuration
public class WebMvcConfig extends WebMvcConfigurationSupport {
    /**
     * 设置资源映射
     * @param registry
     * 前面表示的是浏览器访问的请求
     * 后面表示的是要把请求映射到哪里去
     */
    @Override
    protected void addResourceHandlers(ResourceHandlerRegistry registry) {
        log.info("开始进行静态资源映射");
        registry.addResourceHandler("/backend/**").addResourceLocations("classpath:/backend/");
 registry.addResourceHandler("/front/**").addResourceLocations("classpath:/front/");
    }
}
</code></pre>
<p><strong>记得在启动程序加上@ServletComponentScan这个注解，否则这个配置类不会生效；</strong></p>
<p></p>
<p></p>
<h1 id="%E5%9B%9B%E3%80%81%E5%90%8E%E5%8F%B0%E7%99%BB%E9%99%86%E5%8A%9F%E8%83%BD%E5%BC%80%E5%8F%91">四、后台登陆功能开发</h1>
<h2 id="%E2%91%A0%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%EF%BC%9A">①需求分析：</h2>
<p>需求分析是通过产品原型来进行的，这个是项目经理负责的；</p>
<p></p>
<h2 id="%E2%91%A1%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91%EF%BC%9A">②代码开发：</h2>
<p>前端页面访问地址：<a href="http://localhost:8080/backend/page/login/login.html" title="http://localhost:8080/backend/page/login/login.html">http://localhost:8080/backend/page/login/login.html</a></p>
<p><img alt="" height="714" src="image\3c80ed36b7ed4ea8884541aa9554ba6d.png" width="1171"/></p>
<p> 查看登陆请求信息：点击登录会发送登录请求：<a href="http://localhost:8080/employee/login" title="http://localhost:8080/employee/login">http://localhost:8080/employee/login</a></p>
<p>我们去后端进行代码开发相关的接口就行；</p>
<p>创建相关的包：</p>
<p><img alt="" height="597" src="image\5a1743cdefc64ff7aa1db0458ec1bf6a.png" width="741"/></p>
<p></p>
<h3 id="%E5%AE%9E%E4%BD%93%E7%B1%BB%E5%92%8Cmapper%E7%9A%84%E5%BC%80%E5%8F%91">实体类和mapper的开发</h3>
<p>在entity导入实体类employee类；</p>
<p>使用mybatis-plus提供的自动生成mapper:</p>
<pre><code class="language-java">package com.itheima.reggie.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.itheima.reggie.entity.Employee;
import org.apache.ibatis.annotations.Mapper;

@Mapper
public interface EmployeeMapper extends BaseMapper&lt;Employee&gt; {
}</code></pre>
<p> 使用快捷键 Ctrl + f3 就可以看见mybatis-plus 帮我们定义的mapper接口：</p>
<p><img alt="" height="752" src="image\5865ca23fa174b8ca311068bc433594c.png" width="1000"/></p>
<p></p>
<h3 id="service">service</h3>
<pre><code class="language-java">package com.itheima.reggie.service;
import com.baomidou.mybatisplus.extension.service.IService;
import com.itheima.reggie.entity.Employee;

public interface EmployeeService extends IService&lt;Employee&gt; {
    
}</code></pre>
<pre><code class="language-java">package com.itheima.reggie.service.impl;

import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.itheima.reggie.entity.Employee;
import com.itheima.reggie.mapper.EmployeeMapper;
import org.springframework.stereotype.Service;

/**
 * @author LJM
 * @create 2022/4/15
 */
@Service						//这两个泛型一个是实体类对应的mapper,一个是实体类
public class EmployeeServiceImpl extends ServiceImpl&lt;EmployeeMapper,Employee&gt; implements EmployeeService {

}</code></pre>
<p>查看帮我们实现的方法：</p>
<p><img alt="" height="855" src="image\133908d5ef064a619daa6d50f7a2b3a7.png" width="1010"/></p>
<p></p>
<h3 id="%E5%B0%81%E8%A3%85%E8%BF%94%E5%9B%9E%E7%9A%84%E7%BB%93%E6%9E%9C%E7%B1%BB">封装返回的结果类</h3>
<p>创建一个新的包，common，用来存放共同使用的类，把这个返回结果类放入这个公共包；</p>
<pre><code class="language-java">package com.itheima.reggie.common;
import lombok.Data;
import java.util.HashMap;
import java.util.Map;
/**
 * 通用返回结果类，服务端响应的数据最终都会封装成此对象
 * @param &lt;T&gt;
 */
@Data
public class R&lt;T&gt; {

    private Integer code; //编码：1成功，0和其它数字为失败
    private String msg; //错误信息
    private T data; //数据
    private Map map = new HashMap(); //动态数据

    public static &lt;T&gt; R&lt;T&gt; success(T object) {
        R&lt;T&gt; r = new R&lt;T&gt;();
        r.data = object;
        r.code = 1;
        return r;
    }

    public static &lt;T&gt; R&lt;T&gt; error(String msg) {
        R r = new R();
        r.msg = msg;
        r.code = 0;
        return r;
    }

    public R&lt;T&gt; add(String key, Object value) {
        this.map.put(key, value);
        return this;
    }
}</code></pre>
<p></p>
<h3 id="controller">controller</h3>
<p>登陆的具体流程图：在平板上，记得传过来。</p>
<p>先处理业务逻辑，然后再编码！！！</p>
<pre><code class="language-bash">1、将页面提交的密码password进行md5加密处理
2、根据页面提交的用户名username查询数据库
3、如果没有查询到则返回登录失败结果
4、密码比对，如果不一致则返回登录失败结果
5、查看员工状态，如果为已禁用状态，则返回员工已禁用结果
6、登录成功，将员工id存入Session并返回登录成功结果</code></pre>
<pre><code class="language-java">package com.itheima.reggie.controller;

import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;
import com.itheima.reggie.common.R;
import com.itheima.reggie.entity.Employee;
import com.itheima.reggie.service.EmployeeService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.util.DigestUtils;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import javax.servlet.http.HttpServletRequest;
import java.nio.charset.StandardCharsets;

/**
 * @author LJM
 * @create 2022/4/15
 */
@RestController
@Slf4j
@RequestMapping("/employee")
public class EmployeeController {

    @Autowired
    private EmployeeService employeeService;

    @PostMapping("/login") //使用restful风格开发
    public R&lt;Employee&gt; login(HttpServletRequest request, @RequestBody Employee employee){//接收前端的json数据,这个json数据是在请求体中的
        //这里为什么还有接收一个request对象的数据?
        //登陆成功后，我们需要从请求中获取员工的id，并且把这个id存到session中，这样我们想要获取登陆对象的时候就可以随时获取
        
        //1、将页面提交的密码password进行md5加密处理
        String password = employee.getPassword();//从前端用户登录拿到的用户密码
        password = DigestUtils.md5DigestAsHex(password.getBytes());//对用户密码进行加密
        
        //2、根据页面提交的用户名username查询数据库
        LambdaQueryWrapper&lt;Employee&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();
        queryWrapper.eq(Employee::getUsername,employee.getUsername());
        //在设计数据库的时候我们对username使用了唯一索引,所以这里可以使用getOne方法
        Employee emp = employeeService.getOne(queryWrapper);//这里的切入Wrapper是什么？
        
        //3、如果没有查询到则返回登录失败结果
        if (emp == null ){
            return R.error("用户不存在");
        }
        
        //4、密码比对，如果不一致则返回登录失败结果
        if (!emp.getPassword().equals(password)){
            //emp.getPassword()用户存在后从数据库查询到的密码(加密状态的)  password是前端用户自己输入的密码(已经加密处理)
            return R.error("密码不正确");
        }
        
        //5、查看员工状态，如果为已禁用状态，则返回员工已禁用结果
        if (emp.getStatus() == 0){
            return R.error("账号已禁用");
        }
        
        //6、登录成功，将员工id存入Session并返回登录成功结果
        request.getSession().setAttribute("employee",emp.getId());
        //把从数据库中查询到的用户返回出去
        return R.success(emp);
    }
}</code></pre>
<h2 id="%E2%91%A2%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95%EF%BC%9A">③功能测试：</h2>
<p>使用debug的形式启动项目，然后在浏览器访问:<a href="http://localhost:8080/backend/page/login/login.html" title="http://localhost:8080/backend/page/login/login.html">http://localhost:8080/backend/page/login/login.html</a></p>
<p>然后打开浏览器的f12,查看具体的请求情况：</p>
<p><img alt="" height="399" src="image\a3f6be67411b4c1bb7c96b33262407dd.png" width="1184"/></p>
<p>在后台查看debug的状态：</p>
<p><img alt="" height="569" src="image\738b0ba9ecc34135a91a986803167b3a.png" width="1192"/> 运行成功后：（这个密码是123456），数据存在了浏览器中：这个代码是吧返回的数据保持在浏览器中：</p>
<pre><code class="language-javascript">localStorage.setItem('userInfo',JSON.stringify(res.data))</code></pre>
<p>在浏览器我们可以看见，key为userInfo，value为我们返回的数据；</p>
<p><img alt="" height="772" src="image\ad70731c1b9f4caeb9b57110e7a7887a.png" width="1200"/></p>
<p></p>
<h1 id="%E4%BA%94%E3%80%81%E5%90%8E%E5%8F%B0%E7%B3%BB%E7%BB%9F%E9%80%80%E5%87%BA%E5%8A%9F%E8%83%BD">五、后台系统退出功能</h1>
<p>点击退出按钮，发送退出的请求：<a href="http://localhost:8080/employee/logout" title="http://localhost:8080/employee/logout">http://localhost:8080/employee/logout</a></p>
<p><img alt="" height="328" src="image\db3a496960af4922b7bb6fd528fb8ffe.png" width="1200"/></p>
<p> 后端代码处理：</p>
<p>①在controller中创建对应的处理方法来接受前端的请求，请求方式为post；</p>
<p>②清理session中的用户id</p>
<p>③返回结果（前端页面会进行跳转到登录页面）</p>
<p>前端代码，也要把浏览器中的数据给清除；</p>
<p><img alt="" height="373" src="image\da92d3f05d3d481b86139aa0ec501d05.png" width="1191"/></p>
<pre><code class="language-java"> /**
     * 退出功能
     * ①在controller中创建对应的处理方法来接受前端的请求，请求方式为post；
     * ②清理session中的用户id
     * ③返回结果（前端页面会进行跳转到登录页面）
     * @return
     */
    @PostMapping("/logout")
    public R&lt;String&gt; logout(HttpServletRequest request){
        //清理session中的用户id
        request.getSession().removeAttribute("employee");
        return R.success("退出成功");
    }</code></pre>
<p>功能测试：先登陆，然后退出即可；看浏览器中的数据是否会被清除；</p>
<p></p>
<h1 id="%E5%85%AD%E3%80%81%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97">六、员工管理模块</h1>
<h2 id="%E5%AE%8C%E5%96%84%E7%99%BB%E9%99%86%E5%8A%9F%E8%83%BD">完善登陆功能</h2>
<p><strong>问题分析</strong>：前面的登陆存在一个问题，如果用户不进行登陆，直接访问系统的首页，照样可以正常访问，这种设计是不合理的，我们希望看到的效果是只有完成了登陆后才可以访问系统中的页面，如果没有登陆则跳转到登陆页面；</p>
<p>那么如何实现？</p>
<p><strong>答案就是使用过滤器或者是拦截器，在拦截器或者是过滤器中判断用户是否已经完成了登陆，如果没有登陆则跳转到登陆页面；</strong></p>
<p><strong>代码实现</strong>：这里使用的是过滤器；</p>
<p>①创建自定义过滤器LongCheckFilter</p>
<pre><code class="language-java">package com.itheima.reggie.filter;
import lombok.extern.slf4j.Slf4j;
import javax.servlet.*;
import javax.servlet.annotation.WebFilter;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
/**
 * @author LJM
 * @create 2022/4/15
 * 检查用户是否已经完成登陆
 * filterName过滤器名字
 * urlPatterns拦截的请求，这里是拦截所有的请求
 *
 */
@WebFilter(filterName = "LongCheckFilter",urlPatterns = "/*")
@Slf4j
public class LongCheckFilter implements Filter {
    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {

        HttpServletRequest request = (HttpServletRequest) servletRequest;
        HttpServletResponse response = (HttpServletResponse) servletResponse;
        log.info("拦截到的请求:{}",request.getRequestURL());
        //对请求进行放行
        filterChain.doFilter(request,response);
    }
}</code></pre>
<p>②在启动类加上注解@ServletComponentScan</p>
<p>然后先测试一下过滤器能不能生效，具体的逻辑等下再书写；发送请求，看后台能不能打印拦截的信息：</p>
<p><img alt="" height="170" src="image\e5876d65c9964e478c5d48e253b75255.png" width="1200"/></p>
<p> ③完善过滤器的处理逻辑</p>
<p><img alt="" height="486" src="image\ccee02d7db30467697f337f0ac3a8775.png" width="968"/></p>
<p> 具体逻辑的代码实现：</p>
<pre><code class="language-java">package com.itheima.reggie.filter;

import com.alibaba.fastjson.JSON;
import com.itheima.reggie.common.R;
import lombok.extern.slf4j.Slf4j;
import org.springframework.util.AntPathMatcher;

import javax.servlet.*;
import javax.servlet.annotation.WebFilter;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

/**
 * @author LJM
 * @create 2022/4/15
 * 检查用户是否已经完成登陆
 * filterName过滤器名字
 * urlPatterns拦截的请求，这里是拦截所有的请求
 *
 */
@WebFilter(filterName = "LongCheckFilter",urlPatterns = "/*")
@Slf4j
public class LongCheckFilter implements Filter {

    //路径匹配器，支持通配符
    public static final AntPathMatcher PATH_MATCHER = new AntPathMatcher();

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {

        //对请求和响应进行强转,我们需要的是带http的
        HttpServletRequest request = (HttpServletRequest) servletRequest;
        HttpServletResponse response = (HttpServletResponse) servletResponse;

        //1、获取本次请求的URI
        String requestURL = request.getRequestURI();
        //定义不需要处理的请求路径  比如静态资源(静态页面我们不需要拦截,因为此时的静态页面是没有数据的)
        String[] urls = new String[]{
                "/employee/login",
                "/employee/logout",
                "/backend/**",
                "/front/**"
        };

        //做调试用的
        //log.info("拦截到请求：{}",requestURL);

        //2、判断本次请求是否需要处理
        boolean check = check(urls, requestURL);
        //3、如果不需要处理，则直接放行
        if(check){
            //log.info("本次请求{}不需要处理",requestURL);
            filterChain.doFilter(request,response);
            return;
        }
        //4、判断登录状态，如果已登录，则直接放行
        if(request.getSession().getAttribute("employee") != null){
            //log.info("用户已登录，用户id为：{}",request.getSession().getAttribute("employee"));
            filterChain.doFilter(request,response);
            return;
        }
        //log.info("用户未登录");
        //5、如果未登录则返回未登录结果，通过输出流方式向客户端页面响应数据,具体响应什么数据，看前端的需求，然后前端会根据登陆状态做页面跳转
        response.getWriter().write(JSON.toJSONString(R.error("NOTLOGIN")));
        return;

    }

    /**
     * 路径匹配，检查本次请求是否需要放行
     * @param urls
     * @param requestURI
     * @return
     */
    public boolean check(String[] urls,String requestURI){
        for (String url : urls) {
            //把浏览器发过来的请求和我们定义的不拦截的url做比较，匹配则放行
            boolean match = PATH_MATCHER.match(url, requestURI);
            if(match){
                return true;
            }
        }
        return false;
    }
}</code></pre>
<p><strong>功能测试:</strong> 发起几个请求看看后台的输出，和能不能访问到资源里面的数据，和能不能跳转，注意，上面的后台日志代码已经被注释，需要在后台看到日志的话，需要把注释去掉；</p>
<p></p>
<h2 id="%E6%96%B0%E5%A2%9E%E5%91%98%E5%B7%A5">新增员工</h2>
<p></p>
<p><img alt="" height="596" src="image\332e11ea40ea464496b1692084c66dac.png" width="1054"/></p>
<p>数据模型：</p>
<p>新增员工，其实就是将我们的新增页面录入的员工数据插入到employee表；注意：employee表中对username字段加入了唯一的约束，<strong>因为username是员工的登陆账号，必须是唯一的！</strong></p>
<p><img alt="" height="178" src="image\f79086b1c01c43a0b65df23a19c8cbe0.png" width="1200"/></p>
<p>employee表中的status字段默认设置为1，表示员工状态可以正常登陆；  </p>
<p><img alt="" height="324" src="image\18a783219c76467ca20925811614bfb1.png" width="1199"/></p>
<p> 代码开发：</p>
<p>梳理一下代码执行的流程：</p>
<p><img alt="" height="680" src="image\614a23222acf4080be67edd51843035e.png" width="1039"/></p>
<pre><code class="language-java">    /**
     * 新增员工
     * @param employee
     * @return
     */
    @PostMapping()//因为请求就是 /employee 在类上已经写了，所以咱俩不用再写了
    public R&lt;String&gt; save(HttpServletRequest request,@RequestBody Employee employee){

        //对新增的员工设置初始化密码123456,需要进行md5加密处理，后续员工可以直接修改密码
        employee.setPassword(DigestUtils.md5DigestAsHex("123456".getBytes()));

        employee.setCreateTime(LocalDateTime.now());
        employee.setUpdateTime(LocalDateTime.now());

        //获得当前登录用户的id
        Long empId = (Long) request.getSession().getAttribute("employee");

        employee.setCreateUser(empId); //创建人的id,就是当前用户的id（在进行添加操作的id）
        employee.setUpdateUser(empId);//最后的更新人是谁
        //mybatis提供的新增方法
        employeeService.save(employee);

        return R.success("新增员工成功");
    }</code></pre>
<p> 功能测试：登陆之后，点击添加，然后确认，然后去数据库看一下新增数据成功没，新增成功，那就表示代码可以执行； 注意：但是因为我们把username设置为唯一索引，所以下次再新增用户的时候，就会出现异常，这个异常是MySQL数据库抛出来的；</p>
<p>解决bug:</p>
<p><img alt="" height="363" src="image\0f38dc4c38944bf8b188946fa9cbafe0.png" width="1118"/></p>
<p></p>
<h3 id="%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7">全局异常捕获</h3>
<p>这个全局异常捕获写在common包下；</p>
<pre><code class="language-java">package com.itheima.reggie.common;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;
import java.sql.SQLIntegrityConstraintViolationException;

/**
 * @author LJM
 * @create 2022/4/15
 * 全局异常处理
 */
@ControllerAdvice(annotations = {RestController.class, Controller.class}) //表示拦截哪些类型的controller注解
@ResponseBody
@Slf4j
public class GlobalExceptionHandler {

    /**
     * 处理SQLIntegrityConstraintViolationException异常的方法
     * @return
     */
    @ExceptionHandler(SQLIntegrityConstraintViolationException.class)
    public R&lt;String&gt; exceptionHandle(SQLIntegrityConstraintViolationException exception){
        log.error(exception.getMessage()); //报错记得打日志
        if (exception.getMessage().contains("Duplicate entry")){
            //获取已经存在的用户名，这里是从报错的异常信息中获取的
            String[] split = exception.getMessage().split(" ");
            String msg = split[2] + "这个用户名已经存在";
            return R.error(msg);
        }
        return R.error("未知错误");
    }
}</code></pre>
<p>功能测试：登陆后，添加一个一个已经存在账号名，看前端页面提示的是什么信息，以及看后台是否输出了报错日志；</p>
<p><img alt="" height="317" src="image\1f68f80414bf4ae58c9e7a79909da8ee.png" width="1190"/></p>
<p><img alt="" height="647" src="image\db18e3911c324ed5895b243658b274dc.png" width="1198"/></p>
<h2 id="%E5%91%98%E5%B7%A5%E4%BF%A1%E6%81%AF%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2">员工信息分页查询</h2>
<p>需求分析：系统中的员工比较多的时候，如果在一个页面中全部展示出来会显得比较乱，不便于查看，所以一般都系统中都会以分页的方式来展示列表数据。</p>
<p><img alt="" height="143" src="image\307b2deb43e94907a6ef36103b186e34.png" width="954"/></p>
<p> 流程分析：</p>
<p><img alt="" height="617" src="image\7e88843866774df2a9d598993ae2fdc7.png" width="1153"/></p>
<p> Java代码：</p>
<pre><code class="language-java">//配置mybatis-plus的分页插件
package com.itheima.reggie.config;
import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;
import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
/**
 * @author LJM
 * @create 2022/4/15
 * 配置mybatis-plus提供的分页插件拦截器
 */
@Configuration
public class MybatisPlusConfig {
    
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor(){
        MybatisPlusInterceptor mybatisPlusInterceptor = new MybatisPlusInterceptor();
        mybatisPlusInterceptor.addInnerInterceptor(new PaginationInnerInterceptor());
        return mybatisPlusInterceptor;
    }
}</code></pre>
<pre><code class="language-java">    /**
     * 员工信息分页
     * @param page  当前页数
     * @param pageSize 当前页最多存放数据条数,就是这一页查几条数据
     * @param name 根据name查询员工的信息
     * @return
     */
    @GetMapping("/page")
    public R&lt;Page&gt; page(int page,int pageSize,String name){
    //这里之所以是返回page对象(mybatis-plus的page对象)，是因为前端需要这些分页的数据(比如当前页，总页数)
        //在编写前先测试一下前端传过来的分页数据有没有被我们接受到
        //log.info("page = {},pageSize = {},name = {}" ,page,pageSize,name);

        //构造分页构造器  就是page对象
        Page pageInfo = new Page(page,pageSize);

        //构造条件构造器  就是动态的封装前端传过来的过滤条件  记得加泛型
        LambdaQueryWrapper&lt;Employee&gt; queryWrapper = new LambdaQueryWrapper();
        //根据条件查询  注意这里的条件是不为空
        queryWrapper.like(StringUtils.isNotEmpty(name),Employee::getName,name);
        //添加一个排序条件
        queryWrapper.orderByDesc(Employee::getUpdateTime);
        //执行查询  这里不用封装了mybatis-plus帮我们做好了
        employeeService.page(pageInfo,queryWrapper);

        return R.success(pageInfo);
    }</code></pre>
<p>功能测试：分页的三个时机，①用户登录成功时，分页查询一次 ②用户使用条件查询的时候分页一次 ③跳转页面的时候分页查询一次</p>
<h2 id="%E5%90%AF%E7%94%A8%2F%E7%A6%81%E7%94%A8%E5%91%98%E5%B7%A5%E8%B4%A6%E5%8F%B7">启用/禁用员工账号</h2>
<p><strong>需求分析：</strong></p>
<p>在员工管理列表页面中，可以对某个员工账号进行启用或者是禁用操作。账号禁用的员工不能登陆系统，启用后的员工可以正常登陆；</p>
<p>需要注意的是：只有管理员(admin用户)才可以对其他普通用户进行启用操作，禁用操作，所以普通用户登录系统后启用，禁用按钮不显示；</p>
<p>并且如果某个员工账号的状态为正常，则按钮显示为’‘禁用’，如果员工账号状态为已禁用，则按钮显示为“启用”。</p>
<p>普通员工登录系统后，启用，禁用按钮不显示；</p>
<p><strong>代码开发：</strong></p>
<p><img alt="" height="719" src="image\d5ee07cbf2914ac682c21372626858f5.png" width="945"/></p>
<p><strong>注意:这里修改状态码要反着来，因为正常的用户你只能把它设置为禁用；已经禁用的账号你只能把它设置为正常</strong></p>
<p><img alt="" height="580" src="image\96581ba9e468410bbf7bf2ee96c66e98.png" width="1149"/></p>
<p>流程分析：</p>
<p><img alt="" height="602" src="image\b0ea5baf41cb4f278bdebab0b45a1d44.png" width="855"/></p>
<p><strong>注意：</strong>启用，禁用的员工账号，本质上就是一个更新操作，也就是对status状态字段进行修改操作；</p>
<p>在controller中创建update方法，<strong>此方法是一个通用的修改员工信息的方法</strong>,因为status也是employee中的一个属性而已；这里使用了动态SQL的功能，根据具体的数据修改对应的字段信息；</p>
<p></p>
<pre><code class="language-java">  /**
     * 根据id修改员工信息
     * @param employee
     * @return
     */
    @PutMapping
    public R&lt;String&gt; update(HttpServletRequest request,@RequestBody Employee employee){
        log.info(employee.toString());

        Long empId = (Long)request.getSession().getAttribute("employee");
        employee.setUpdateTime(LocalDateTime.now());
        employee.setUpdateUser(empId);
        employeeService.updateById(employee);

        return R.success("员工信息修改成功");
    }</code></pre>
<p>功能测试：测试的时候我们发现出现了问题，就是我们修改员工的状态，提示信息显示修改成功，但是我们去数据库查验证的时候，发现员工的状态码压根就没有变化，这是为什么呢？</p>
<p><img alt="" height="175" src="image\d3edf655fcfa4dd89b5bcc9404bdb01b.png" width="1200"/></p>
<p><strong>仔细观察id后，我们会发现后台的SQL语句使用的id和数据库中的id是不一样的！</strong></p>
<p>原因是：mybatis-plus对id使用了雪花算法，所以存入数据库中的id是19为长度，但是<strong>前端的js只能保证数据的前16位的数据的精度，对我们id后面三位数据进行了四舍五入，所以就出现了精度丢失</strong>；就会出现前度传过来的id和数据里面的id不匹配，就没办法正确的修改到我们想要的数据；</p>
<p>当然另一种解决bug的方法是:关闭mybatis-plus的雪花算法来处理ID，我们使用自增ID的策略来往数据库添加id就行；</p>
<h3 id="%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B6%88%E6%81%AF%E8%BD%AC%E6%8D%A2%E5%99%A8">使用自定义消息转换器</h3>
<p> <strong>代码bug修复：</strong></p>
<p>思路：既然js对long型的数据会进行精度丢失，那么我们就对数据进行转型，我们<strong>可以在服务端（Java端）给页面响应json格式的数据时进行处理，将long型的数据统一转换为string字符串；</strong></p>
<p>代码实现步骤：</p>
<p><img alt="" height="487" src="image\be4d4386c6f84285a0ae6d208626e2e1.png" width="1150"/></p>
<p> 步骤一：自定义消息转换类</p>
<pre><code class="language-java">package com.itheima.reggie.common;

import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.fasterxml.jackson.databind.ser.std.ToStringSerializer;
import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateDeserializer;
import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateTimeDeserializer;
import com.fasterxml.jackson.datatype.jsr310.deser.LocalTimeDeserializer;
import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateSerializer;
import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateTimeSerializer;
import com.fasterxml.jackson.datatype.jsr310.ser.LocalTimeSerializer;
import java.math.BigInteger;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import static com.fasterxml.jackson.databind.DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES;

/**
 * 对象映射器:基于jackson将Java对象转为json，或者将json转为Java对象
 * 将JSON解析为Java对象的过程称为 [从JSON反序列化Java对象]
 * 从Java对象生成JSON的过程称为 [序列化Java对象到JSON]
 */
public class JacksonObjectMapper extends ObjectMapper {

    public static final String DEFAULT_DATE_FORMAT = "yyyy-MM-dd";
    public static final String DEFAULT_DATE_TIME_FORMAT = "yyyy-MM-dd HH:mm:ss";
    public static final String DEFAULT_TIME_FORMAT = "HH:mm:ss";

    public JacksonObjectMapper() {
        super();
        //收到未知属性时不报异常
        this.configure(FAIL_ON_UNKNOWN_PROPERTIES, false);

        //反序列化时，属性不存在的兼容处理
        this.getDeserializationConfig().withoutFeatures(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);


        SimpleModule simpleModule = new SimpleModule()
                .addDeserializer(LocalDateTime.class, new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))
                .addDeserializer(LocalDate.class, new LocalDateDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))
                .addDeserializer(LocalTime.class, new LocalTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)))

                .addSerializer(BigInteger.class, ToStringSerializer.instance)
                .addSerializer(Long.class, ToStringSerializer.instance)
                .addSerializer(LocalDateTime.class, new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))
                .addSerializer(LocalDate.class, new LocalDateSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))
                .addSerializer(LocalTime.class, new LocalTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)));

        //注册功能模块 例如，可以添加自定义序列化器和反序列化器
        this.registerModule(simpleModule);
    }
}</code></pre>
<p>步骤二：在前面的webMvcConfig 配置类中扩展spring mvc 的消息转换器，在此消息转换器中使用spring提供的对象转换器进行Java对象到json数据的转换；</p>
<pre><code class="language-java">     /**
     * 扩展mvc框架的消息转换器
     * @param converters
     */
    @Override
    protected void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) {
        //log.info("扩展消息转换器...");
        //创建消息转换器对象
        MappingJackson2HttpMessageConverter messageConverter = new MappingJackson2HttpMessageConverter();
        //设置对象转换器，底层使用Jackson将Java对象转为json
        messageConverter.setObjectMapper(new JacksonObjectMapper());
        //将上面的消息转换器对象追加到mvc框架的转换器集合中
        //转换器是有优先级顺序的，这里我们把自己定义的消息转换器设置为第一优先级，所以会优先使用我们的转换器来进行相关数据进行转换，如果我们的转换器没有匹配到相应的数据来转换，那么就会去寻找第二个优先级的转换器，以此类推
        converters.add(0,messageConverter);
    }</code></pre>
<p>然后启动程序，使用f12查看服务器响应到浏览器的用户id是不是变成了字符串，和数据库中是否相对应；</p>
<p><img alt="" height="168" src="image\5e27ae42c8c849c59d4fe1ad4d732f6f.png" width="860"/></p>
<p>发现对应，即消息转换器配置成功；</p>
<p>然后再去测试 启用与禁用 员工账号这个功能，发现操作更新成功，并且数据库修改成功；</p>
<h2 id="%E7%BC%96%E8%BE%91%E5%91%98%E5%B7%A5%E4%BF%A1%E6%81%AF">编辑员工信息</h2>
<p> 需求分析：</p>
<p><img alt="" height="553" src="image\d3c1d20105e0428fb08f90a412840e84.png" width="1200"/></p>
<p><img alt="" height="624" src="image\beb9f03d3fe141b4a127622608c39a87.png" width="1053"/> 数据回显后端代码：其实主要逻辑在前端。。。。。</p>
<pre><code class="language-java">/**
     * 根据前端传过来的员工id查询数据库进行数据会显给前端
     * @param id
     * @return
     */
    @GetMapping("/{id}")
    public R&lt;Employee&gt; getById(@PathVariable Long id){
        Employee employee = employeeService.getById(id);
        if (employee != null){
            return R.success(employee) ;
        }
        return R.error("没有查询到该员工信息");

    }</code></pre>
<p>修改回显数据后，点击保存，会发送一个update的请求给后端，前面我们已经写了这个update的controller，所以只需要在前端跳转发请求就行；这样就实现了方法的复用，减少了代码两；</p>
<p><img alt="" height="213" src="image\924457d6f7ea4560b8e6bebf4732c223.png" width="1089"/></p>
<p>功能测试：自己测试编辑，看能不能数据回显，可不可以修改成功，修改后数据库的数据有没有跟着变化；</p>
<p></p>
<h1 id="%E4%B8%83%E3%80%81%E8%8F%9C%E5%93%81%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86">七、菜品分类管理</h1>
<h2 id="%E5%85%AC%E5%85%B1%E5%AD%97%E6%AE%B5%E5%A1%AB%E5%85%85(%E8%BF%99%E9%87%8C%E6%9C%89%E9%87%8D%E7%82%B9)">公共字段填充(这里有重点)</h2>
<p> 问题分析：</p>
<p><img alt="" height="533" src="image\077988504c154809bbedcb8cbc49328e.png" width="1163"/></p>
<p><img alt="" height="339" src="image\d92fcc8e24064f8492084f3d6fa7f4f1.png" width="1196"/></p>
<pre><code class="language-java">把相关的注解加在需要mybatis-plus自动帮我们填充的字段上面
    
    @TableField(fill = FieldFill.INSERT) //插入时填充字段
    private LocalDateTime createTime;

    @TableField(fill = FieldFill.INSERT_UPDATE) //插入和更新时填充字段
    private LocalDateTime updateTime;

    @TableField(fill = FieldFill.INSERT) //插入时填充字段
    private Long createUser;

    @TableField(fill = FieldFill.INSERT_UPDATE) //插入和更新时填充字段
    private Long updateUser;</code></pre>
<p> 然后设置一个处理类：在此类中为公共字段赋值，需要实现 接口；</p>
<pre><code class="language-java">package com.itheima.reggie.common;

import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;
import lombok.extern.slf4j.Slf4j;
import org.apache.ibatis.reflection.MetaObject;

import java.time.LocalDateTime;

/**
 * @author LJM
 * @create 2022/4/16
 * 自定义元数据对象处理器
 */
@Slf4j
@Component   //注意:这个要记得交给spring容器管理，不然这个功能就没发用。。。。
//那么怎么确定你要添加的功能是不是要交给容器管理呢？就是你直接写了一个工具类或者是功能类，需要对数据库的数据或者是数据库数据的结果产生影响的时候，你明明写了这样一个类，但是功能却没有生效，那么这个时候就要首先考虑是不是容器没有托管这个类
public class MyMetaObjecthandler implements MetaObjectHandler {

    /**
     * 插入操作，自动填充
     * @param metaObject
     */
    @Override
    public void insertFill(MetaObject metaObject) {
        metaObject.setValue("createTime", LocalDateTime.now());
        metaObject.setValue("updateTime",LocalDateTime.now());
        
        metaObject.setValue("createUser", new Long(1));  //这里的id是不能直接获取的，所以这里先写死，后面教你怎么动态获取员工id
        metaObject.setValue("updateUser",new Long(1));
    }

    /**
     * 更新操作，自动填充
     * @param metaObject
     */
    @Override
    public void updateFill(MetaObject metaObject) {
        metaObject.setValue("updateTime",LocalDateTime.now());
        metaObject.setValue("updateUser",new Long(1));
    }
}
</code></pre>
<p><strong>功能完善：</strong></p>
<p><img alt="" height="238" src="image\bb9efa76b4fd4b369bdaf6962011957f.png" width="1152"/></p>
<p><img alt="" height="509" src="image\e1e254aedaa74ad7b3538ff2faea471a.png" width="1132"/><img alt="" height="524" src="image\370c9468031e4f5ba660582ae6be76f2.png" width="1192"/></p>
<p><img alt="" height="230" src="image\b980f4f926b14de79d3dd5828a8fba99.png" width="1156"/></p>
<p></p>
<p>然后<strong>为了动态的获取员工的id</strong>,这里我们使用了threadLocal这个局部变量来获取和存储员工id;</p>
<p>创建一个工具类来设置和获取threadLocal中的员工id, <strong>注意：要先把数据设置进threadLocal中，才能获取到</strong></p>
<pre><code class="language-java">package com.itheima.reggie.common;

/**
 * @author LJM
 * @create 2022/4/16
 *  基于ThreadLocal封装工具类，用户保存和获取当前登录用户id
 */
public class BaseContext {
    //用来存储用户id
    private static ThreadLocal&lt;Long&gt; threadLocal = new ThreadLocal&lt;&gt;();

    /**
     * 设置值
     * @param id
     */
    public static void setCurrentId(Long id){
        threadLocal.set(id);
    }

    /**
     * 获取值
     * @return
     */
    public static Long getCurrentId(){
        return threadLocal.get();
    }
}
</code></pre>
<p>在前面我们写的LongCheckFilter这个过滤器中，把这个地方的代码加上添加和保存id的代码</p>
<pre><code class="language-java">//4、判断登录状态，如果已登录，则直接放行
        if(request.getSession().getAttribute("employee") != null){
            //log.info("用户已登录，用户id为：{}",request.getSession().getAttribute("employee"));
            //把用户id存储到本地的threadLocal
            Long emId = (Long) request.getSession().getAttribute("employee");
            BaseContext.setCurrentId(emId);

            filterChain.doFilter(request,response);
            return;
        }</code></pre>
<pre><code class="language-java">把处理器中的静态id改为动态获取：
metaObject.setValue("createUser", BaseContext.getCurrentId());
metaObject.setValue("updateUser",BaseContext.getCurrentId());</code></pre>
<p><img alt="" height="662" src="image\65a70a99f4dd40bfbf197578e4146ad5.png" width="1154"/><img alt="" height="617" src="image\25ddd47b2eb1431e80fb0fdbb0044f55.png" width="1194"/></p>
<p><img alt="" height="494" src="image\5d41c39d2cc941819741984a09c11f0b.png" width="1193"/></p>
<p> 这里的ID之所以全为1，是因为操作添加员工这个功能的管理员为admin，它的id就是1；</p>
<p></p>
<h2 id="%E6%96%B0%E5%A2%9E%E5%88%86%E7%B1%BB">新增分类</h2>
<p>需求分析：</p>
<p><img alt="" height="561" src="image\439a73e8d5d94926bf31828e5deaa414.png" width="1142"/></p>
<p><img alt="" height="400" src="image\f2b51de7cfac4c0191b4fd7ec751c91f.png" width="1152"/></p>
<p></p>
<p>数据模型：</p>
<p>从资料去复制实体Category类到entity包；</p>
<p>数据库中的表结构：</p>
<p><img alt="" height="699" src="image\779492f160054d93b4b1646f606d25a2.png" width="1116"/></p>
<p> <img alt="" height="437" src="image\92cec0437e6449589ef1ecc424b8e55a.png" width="1103"/></p>
<p>创建mapper:</p>
<pre><code class="language-java">package com.itheima.reggie.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.itheima.reggie.entity.Category;
import org.apache.ibatis.annotations.Mapper;

@Mapper
public interface CategoryMapper extends BaseMapper&lt;Category&gt; {
}</code></pre>
<p><img alt="" height="772" src="image\f9134681beff4b428e69a7ac481f2a34.png" width="1200"/></p>
<p> 创建service：</p>
<pre><code class="language-java">package com.itheima.reggie.service;

import com.baomidou.mybatisplus.extension.service.IService;
import com.itheima.reggie.entity.Category;

/**
 * @author LJM
 * @create 2022/4/16
 */
public interface CategoryService extends IService&lt;Category&gt; {
}</code></pre>
<pre><code class="language-java">package com.itheima.reggie.service.impl;

import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.itheima.reggie.entity.Category;
import com.itheima.reggie.mapper.CategoryMapper;
import com.itheima.reggie.service.CategoryService;
import org.springframework.stereotype.Service;

/**
 * @author LJM
 * @create 2022/4/16
 */
@Service
public class CategoryServiceImpl extends ServiceImpl&lt;CategoryMapper, Category&gt; implements CategoryService {

}</code></pre>
<p><strong>编写controller：</strong></p>
<p><img alt="" height="510" src="image\b1a912281027452490981e5f5f58584c.png" width="1141"/></p>
<p> 我们发现新增菜品分类的请求地址是:<a href="http://localhost:8080/category" title="http://localhost:8080/category">http://localhost:8080/category</a></p>
<p>提交的数据格式为：</p>
<pre><code class="language-java">{name: "湘菜", type: "1", sort: "1"}</code></pre>
<pre><code class="language-java">/**
     * 新增套餐分类
     * @param category
     * @return
     */
    @PostMapping
    public R&lt;String&gt; save(@RequestBody Category category){
        log.info("{category}" ,category);
        categoryService.save(category);
        return R.success("新增分类成功");
    }</code></pre>
<p>功能测试：登录后，点击添加新增菜品分类，看是否成功，数据库的数据是否变化；</p>
<p></p>
<h2 id="%E8%8F%9C%E5%93%81%E7%B1%BB%E7%9A%84%E5%88%86%E9%A1%B5">菜品类的分页</h2>
<p><img alt="" height="642" src="image\332e2e4523d44972a6fa57e7fa6fcd26.png" width="985"/></p>
<p> 代码开发：</p>
<pre><code class="language-java">   /**
     * 分页查询
     * @param page
     * @param pageSize
     * @return
     */
    @GetMapping("/page")
    public R&lt;Page&gt; page(int page,int pageSize){

        //创建一个分页构造器
        Page&lt;Category&gt; categoryPage = new Page&lt;&gt;(page,pageSize);
        //创建一个条件构造器  用来排序用的  注意这个条件构造器一定要使用泛型，否则使用条件查询这个方法的时候会报错
        LambdaQueryWrapper&lt;Category&gt; queryWrapper = new LambdaQueryWrapper();
        //添加排序条件 ，根据sort字段进行排序
        queryWrapper.orderByAsc(Category::getSort);
        categoryService.page(categoryPage,queryWrapper);
        return R.success(categoryPage);
    }</code></pre>
<p>功能测试：</p>
<p><img alt="" height="432" src="image\e20fe772de8d461a8ef01341a2e4a6f3.png" width="1182"/></p>
<h2 id="%E5%88%A0%E9%99%A4%E5%88%86%E7%B1%BB%EF%BC%88%E8%BF%99%E9%87%8C%E6%9C%89%E6%B3%A8%E6%84%8F%E7%82%B9%EF%BC%89">删除分类（这里有注意点）</h2>
<p> 需求分析：</p>
<p><img alt="" height="538" src="image\78e56e68d07645b3bedfaff3b93465b0.png" width="1170"/></p>
<p>代码实现： 注意这里的删除功能是不完整的，<strong>因为可能需要删除的数据是与其他表关联的，所以删除之前要先判断该条数据是否与其他表中的数据关联；</strong></p>
<pre><code class="language-java">    /**
     * 根据id来删除分类的数据
     * @param id
     * @return
     */
    @DeleteMapping()
    public R&lt;String&gt; delete(@RequestParam("ids") Long ids){ //注意这里前端传过来的数据是ids
        categoryService.removeById(ids);
        return R.success("分类信息删除成功");
    }</code></pre>
<p> <strong>功能完善：</strong></p>
<p><img alt="" height="309" src="image\fb2c93acdac048e09018a4351b0e8401.png" width="1146"/></p>
<p>创建对应的mapper:</p>
<pre><code class="language-java">package com.itheima.reggie.mapper;
import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.itheima.reggie.entity.Dish;
import org.apache.ibatis.annotations.Mapper;

/**
 * @author LJM
 * @create 2022/4/16
 */
@Mapper
public interface DishMapper extends BaseMapper&lt;Dish&gt; {

}</code></pre>
<pre><code class="language-java">package com.itheima.reggie.mapper;
import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.itheima.reggie.entity.Setmeal;
import org.apache.ibatis.annotations.Mapper;
/**
 * @author LJM
 * @create 2022/4/16
 */
@Mapper
public interface SetmealMapper extends BaseMapper&lt;Setmeal&gt; {
}</code></pre>
<p>创建service：</p>
<pre><code class="language-java">package com.itheima.reggie.service;

import com.baomidou.mybatisplus.extension.service.IService;
import com.itheima.reggie.entity.Dish;

/**
 * @author LJM
 * @create 2022/4/16
 */
public interface DishService extends IService&lt;Dish&gt; {
}</code></pre>
<pre><code class="language-java">package com.itheima.reggie.service;

import com.baomidou.mybatisplus.extension.service.IService;
import com.itheima.reggie.entity.Setmeal;

public interface SetmealService extends IService&lt;Setmeal&gt; {
}</code></pre>
<pre><code class="language-java">package com.itheima.reggie.service.impl;

import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.itheima.reggie.entity.Dish;
import com.itheima.reggie.mapper.DishMapper;
import com.itheima.reggie.service.DishService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

/**
 * @author LJM
 * @create 2022/4/16
 */
@Service
@Slf4j
public class DishServiceImpl extends ServiceImpl&lt;DishMapper, Dish&gt; implements DishService {
}
</code></pre>
<pre><code class="language-java">package com.itheima.reggie.service.impl;

import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.itheima.reggie.entity.Setmeal;
import com.itheima.reggie.mapper.SetmealMapper;
import com.itheima.reggie.service.SetmealService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

/**
 * @author LJM
 * @create 2022/4/16
 */
@Service
@Slf4j
public class SetmealServiceImpl extends ServiceImpl&lt;SetmealMapper, Setmeal&gt; implements SetmealService {
}</code></pre>
<p>添加自定义的service方法：(就是我们需要的业务mybatis没有提供，所以就需要自己另外在service创建新的方法，并且在相关的业务中实现)</p>
<pre><code class="language-java">//在CategoryService中定义自己需要的方法，直接写就行
void remove(Long id);</code></pre>
<pre><code class="language-java">在CategoryService实现类中重写该方法：

自定义异常类，因为这里需要抛异常了：</code></pre>
<pre><code class="language-java">package com.itheima.reggie.common;

/**
 * 自定义业务异常类
 */
public class CustomException extends RuntimeException {
    public CustomException(String message){
        super(message);
    }
}
</code></pre>
<pre><code class="language-java">//然后在外面前面写的GlobalExceptionHandler全局异常捕获器中添加该异常，这样就可以把相关的异常信息显示给前端操作的人员看见

/**
     * 处理自定义的异常，为了让前端展示我们的异常信息，这里需要把异常进行全局捕获，然后返回给前端
     * @param exception
     * @return
     */
    @ExceptionHandler(CustomException.class)
    public R&lt;String&gt; exceptionHandle(CustomException exception){
        log.error(exception.getMessage()); //报错记得打日志
        //这里拿到的message是业务类抛出的异常信息，我们把它显示到前端
        return R.error(exception.getMessage());
    }</code></pre>
<pre><code class="language-java">/**
     * 根据id删除 分类，删除之前需要进行判断是否有关联数据
     * @param id
     */
    @Override
    public void remove(Long id) {
        LambdaQueryWrapper&lt;Dish&gt; dishLambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;();
        //添加查询条件
        dishLambdaQueryWrapper.eq(Dish::getCategoryId,id);
        //注意:这里使用count方法的时候一定要传入条件查询的对象，否则计数会出现问题，计算出来的是全部的数据的条数
        int count = dishService.count(dishLambdaQueryWrapper);

        //查询当前分类是否关联了菜品，如果已经管理，直接抛出一个业务异常
        if (count &gt; 0){
            //已经关联了菜品，抛出一个业务异常
            throw new CustomException("当前分类项关联了菜品,不能删除");
        }

        //查询当前分类是否关联了套餐，如果已经管理，直接抛出一个业务异常
        LambdaQueryWrapper&lt;Setmeal&gt; setmealLambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;();
        setmealLambdaQueryWrapper.eq(Setmeal::getCategoryId,id);
        //注意:这里使用count方法的时候一定要传入条件查询的对象，否则计数会出现问题，计算出来的是全部的数据的条数
        int setmealCount = setmealService.count(setmealLambdaQueryWrapper);
        if (setmealCount &gt; 0){
            //已经关联了套餐，抛出一个业务异常
            throw new CustomException("当前分类项关联了套餐,不能删除");
        }
        //正常删除
        super.removeById(id);

    }</code></pre>
<p>然后在controller调用刚刚实现的方法就行：把之前的remove方法给删除就行，重新调用我们自己实现的方法；</p>
<pre><code class="language-java">    /**
     * 根据id来删除分类的数据
     * @param id
     * @return
     */
    @DeleteMapping
    public R&lt;String&gt; delete(@RequestParam("ids") Long id){ //注意这里前端传过来的数据是ids

        categoryService.remove(id);
        return R.success("分类信息删除成功");

    }</code></pre>
<p>测试：自己添加测试数据测试就行；记得一定要测试一下删除有相关联的数据，看会不会删除和在前端提示异常信息；</p>
<h2></h2>
<h2 id="%E4%BF%AE%E6%94%B9%E5%88%86%E7%B1%BB">修改分类</h2>
<p></p>
<p><img alt="" height="567" src="image\152ff8d9b1aa4aa8a6d6af0c0d8d79b7.png" width="1133"/></p>
<p>这里的编辑的数据回显，前端已经帮我们做好了，所以我们就不需要去数据库查询了，这样可以减少对数据库的操作；</p>
<p><img alt="" height="460" src="image\63b818357ca64c9caf5b1be290d7bdd4.png" width="937"/></p>
<pre><code class="language-java">    /**
     * 根据id修改分类
     * @param category
     * @return
     */
    @PutMapping
    public R&lt;String&gt; update(@RequestBody Category category){
        categoryService.updateById(category);
        return R.success("修改分类信息成功");
    }</code></pre>
<p>记得在对应的实体类加上公共字段的值设置：前面我们配置了这个，所以这里只需要加注解就行；</p>
<pre><code class="language-java">    //创建时间
    @TableField(fill = FieldFill.INSERT)
    private LocalDateTime createTime;

    //更新时间
    @TableField(fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updateTime;

    //创建人
    @TableField(fill = FieldFill.INSERT)
    private Long createUser;

    //修改人
    @TableField(fill = FieldFill.INSERT_UPDATE)
    private Long updateUser;</code></pre>
<h1 id="%E5%85%AB%E3%80%81%E8%8F%9C%E5%93%81%E7%AE%A1%E7%90%86%E7%9A%84%E4%B8%9A%E5%8A%A1%E5%8A%9F%E8%83%BD">八、菜品管理的业务功能</h1>
<h2 id="%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89">文件的上传和下载（重点）</h2>
<p>整体介绍：</p>
<p><img alt="" height="536" src="image\1e0583d679ba4d60bc47c18d71811f68.png" width="1199"/></p>
<p><img alt="" height="296" src="image\e4c91746030647e7a12701a1f502e035.png" width="1177"/><img alt="" height="530" src="image\6f89ee9a2a754ca395cf7a6ecf77b00e.png" width="1158"/> </p>
<p> <strong>文件下载：</strong></p>
<p><img alt="" height="289" src="image\8122a9ecbe9b41df887b9f5e3babdc16.png" width="969"/></p>
<p> <img alt="" height="531" src="image\eaafb785a7c54134b62cf4bc3d24a102.png" width="1120"/></p>
<p> <img alt="" height="430" src="image\5e7ecce00e0c42f2a0ec566f9a133c60.png" width="1108"/></p>
<p></p>
<p><strong>后端具体代码的实现：</strong></p>
<p>yml配置文件：配置上传图片的存储位置；</p>
<pre><code class="language-bash">reggie:
  path: E:\reggie\</code></pre>
<pre><code class="language-java">package com.itheima.reggie.controller;

import com.itheima.reggie.common.R;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;

import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServletResponse;
import java.io.*;
import java.util.UUID;

/**
 * @author LJM
 * @create 2022/4/16
 * 文件上传和下载
 */
@RestController
@RequestMapping("/common")
public class CommonController {

    @Value("${reggie.path}")
    private String basePath;

    /**
     * 文件的上传
     * @param file
     * @return
     */
    @PostMapping("/upload")
    public R&lt;String&gt; upload(MultipartFile file){
        //这个file是一个临时文件，需要转存到指定位置，否则本次请求完成后临时文件会删除

        //拿到文件的原始名
        String originalFilename = file.getOriginalFilename();
        //拿到文件的后缀名 比如 .png  .jpg
        String suffix = originalFilename.substring(originalFilename.lastIndexOf("."));
        //使用uuid生成的作为文件名的一部分，这样可以防止文件名相同造成的文件覆盖
        String fileName = UUID.randomUUID().toString() + suffix;

        //创建一个目录对象，看传文件的时候，接收文件的目录存不存在
        File dir = new File(basePath);
        if (!dir.exists()){
            //文件目录不存在，直接创建一个目录
            dir.mkdirs();
        }

        try {
            //把前端传过来的文件进行转存
            file.transferTo(new File(basePath + fileName));
        }catch (IOException e){
            e.printStackTrace();
        }

        return R.success(fileName);
    }


    @GetMapping("/download")
    public void download(String name, HttpServletResponse response){
        try {
            //输入流，通过输入流读取文件内容  这里的name是前台用户需要下载的文件的文件名
            //new File(basePath + name) 是为了从存储图片的地方获取用户需要的图片对象
            FileInputStream fileInputStream = new FileInputStream(new File(basePath + name));
            //输出流，通过输出流将文件写回浏览器
            ServletOutputStream outputStream = response.getOutputStream();

            //设置写回去的文件类型
            response.setContentType("image/jpeg");

            //定义缓存区，准备读写文件
            int len  = 0 ;
            byte[] buff = new byte[1024];
            while ((len = fileInputStream.read(buff)) != -1){
                outputStream.write(buff,0,len);
                outputStream.flush();
            }
            //关流
            outputStream.close();
            fileInputStream.close();

        }catch (Exception e){
            e.printStackTrace();
        }
    }
}</code></pre>
<p>注意：这里上传的文件的文件名要和这个地方的一样，<strong>接收文件的参数的名不能随便定义，要和下面的name的值一致</strong>；</p>
<p><img alt="" height="226" src="image\20dd6314a6d0415d8583ff07fa0e5292.png" width="1200"/></p>
<h2 id="%E6%96%B0%E5%A2%9E%E8%8F%9C%E5%93%81%EF%BC%88%E4%B8%9A%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%98%AF%E9%87%8D%E7%82%B9%EF%BC%89">新增菜品（业务的实现是重点）</h2>
<p> 需求分析：</p>
<p><img alt="" height="526" src="image\d5dd73cb7e874118b29e301871255ee7.png" width="1150"/></p>
<p>数据模型：</p>
<p><img alt="" height="682" src="image\458852f683fe4527a07fdd1c5ffde370.png" width="1200"/> <img alt="" height="305" src="image\a597c315dc374b7aa0f2c918d81c9147.png" width="1185"/></p>
<p>代码开发：</p>
<p><img alt="" height="290" src="image\c22b1618a2fa4c16b2c617fc8ce08018.png" width="1086"/></p>
<p> 创建相关的mapper和service层：</p>
<pre><code class="language-java">package com.itheima.reggie.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.itheima.reggie.entity.DishFlavor;
import org.apache.ibatis.annotations.Mapper;

@Mapper
public interface DishFlavorMapper extends BaseMapper&lt;DishFlavor&gt; {
}</code></pre>
<pre><code class="language-java">package com.itheima.reggie.service;

import com.baomidou.mybatisplus.extension.service.IService;
import com.itheima.reggie.entity.DishFlavor;

public interface DishFlavorService extends IService&lt;DishFlavor&gt;  {
}</code></pre>
<pre><code class="language-java">package com.itheima.reggie.service.impl;

import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.itheima.reggie.entity.DishFlavor;
import com.itheima.reggie.mapper.DishFlavorMapper;
import com.itheima.reggie.service.DishFlavorService;
import org.springframework.stereotype.Service;

/**
 * @author LJM
 * @create 2022/4/16
 */
@Service
public class DishFlavorServiceImpl extends ServiceImpl&lt;DishFlavorMapper, DishFlavor&gt; implements DishFlavorService {
}</code></pre>
<p><strong>编写controller：</strong></p>
<p><img alt="" height="302" src="image\ed3735b3d392489a8a439366896c67dc.png" width="1178"/></p>
<p> 先获取和返回菜品分类列表; 前端主要的代码;</p>
<pre><code class="language-javascript">// 获取菜品分类列表
const getCategoryList = (params) =&gt; {
  return $axios({
    url: '/category/list',
    method: 'get',
    params
  })
}

if (res.code === 1) {
     this.dishList = res.data   //这里就相当于把所有的category对象的数据赋值给dishList
   }

这是菜品分类和数据双向绑定的前端代码:  我们返回的是一个集合，
&lt;/el-form-item&gt;
          &lt;el-form-item
            label="菜品分类:"
            prop="categoryId"
          &gt;
            &lt;el-select
              v-model="ruleForm.categoryId"
              placeholder="请选择菜品分类"
            &gt;
              &lt;el-option v-for="(item,index) in dishList" :key="index" :label="item.name" :value="item.id" /&gt;
            &lt;/el-select&gt;
          &lt;/el-form-item&gt;</code></pre>
<p>在CategoryController书写查询代码，不过这里的返回值和参数接收值可能和自己想的有点不一样。。。<strong>这个的返回值和参数值 值得多思考一下；</strong> 这里之所以返回list集合，是因为这个要展示的数据是引用类型的数据集，集合可以存放任意类型的数据；</p>
<pre><code class="language-java"> /**
     * 根据条件查询分类数据
     * @param category
     * @return
     */
    @GetMapping("/list")
    //这个接口接收到参数其实就是一个前端传过来的type,这里之所以使用Category这个类来接受前端的数据，是为了以后方便
    //因为这个Category类里面包含了type这个数据,返回的数据多了，你自己用啥取啥就行
    private R&lt;List&lt;Category&gt;&gt; list(Category category){
        //条件构造器
        LambdaQueryWrapper&lt;Category&gt; queryWrapper = new LambdaQueryWrapper();
        //添加查询条件
        queryWrapper.eq(category.getType() != null,Category::getType,category.getType());
        //添加排序条件  使用两个排序条件,如果sort相同的情况下就使用更新时间进行排序
        queryWrapper.orderByAsc(Category::getSort).orderByDesc(Category::getUpdateTime);
        List&lt;Category&gt; list = categoryService.list(queryWrapper);

        return R.success(list);
    }</code></pre>
<p>测试的返回数据:</p>
<p><img alt="" height="814" src="image\867a3e4d00794a2a887a34e740704b7b.png" width="1164"/></p>
<p></p>
<h2 id="%E6%8E%A5%E6%94%B6%E9%A1%B5%E9%9D%A2%E6%8F%90%E4%BA%A4%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%88%E6%B6%89%E5%8F%8A%E4%B8%A4%E5%BC%A0%E8%A1%A8%EF%BC%89">接收页面提交的数据（涉及两张表）</h2>
<p>点击保存按钮的时候，把前端的json数据提交到后台，后台接收数据，对数据进行处理；要与两张表打交道，一个是dish一个是dish_flavor表；</p>
<p><strong>先用前端页面向后端发一次请求，看看前端具体的请求是什么，我们好写controller；然后再看前端提交携带的参数是什么，我们好选择用什么类型的数据来接收！！！</strong></p>
<p>看下图：这是前端传过来的具体参数，我们需要什么参数类型来接收这些数据就大概知道了；因为这里传过来的参数比较复杂，所以这里有两种方式进行封装，第一：创建与这些数据对应的实体类（dto） ，第二使用map来接收；</p>
<p><img alt="" height="495" src="image\1d0fdc5a1cec46c5a82b12a2b1d3b092.png" width="1048"/></p>
<p>这里我们选择使用第一种方式；</p>
<pre><code class="language-java">package com.itheima.reggie.dto;

import com.itheima.reggie.entity.Dish;
import com.itheima.reggie.entity.DishFlavor;
import lombok.Data;
import java.util.ArrayList;
import java.util.List;

@Data
public class DishDto extends Dish {

    private List&lt;DishFlavor&gt; flavors = new ArrayList&lt;&gt;();

    private String categoryName;  //后面要用的

    private Integer copies;  //后面要用的
}</code></pre>
<p> <img alt="" height="370" src="image\0056d628a6dd4038a87840a9acf0e7d4.png" width="1200"/></p>
<p> 前端关键代码：</p>
<pre><code class="language-javascript">&lt;el-button
  type="primary"
  @click="submitForm('ruleForm')"
&gt;
  保存
&lt;/el-button&gt;

let params = {...this.ruleForm}
// params.flavors = this.dishFlavors
params.status = this.ruleForm ? 1 : 0
params.price *= 100   //存到数据库的时候是以分为单位，所以这里x100
params.categoryId = this.ruleForm.categoryId
params.flavors = this.dishFlavors.map(obj =&gt; ({ ...obj, value: JSON.stringify(obj.value) }))


if (this.actionType == 'add') {
     delete params.id
     addDish(params).then(res =&gt; {
     if (res.code === 1) {
     this.$message.success('菜品添加成功！')
     if (!st) {
     this.goBack()
      } else {   ....


// 新增接口
const addDish = (params) =&gt; {
  return $axios({
    url: '/dish',
    method: 'post',
    data: { ...params }
  })
}</code></pre>
<p></p>
<p>后端代码：</p>
<p>在DishService中新增一个方法：</p>
<pre><code class="language-java">//新增菜品,同时插入菜品对应的口味数据,需要同时操作两张表:dish  dish_flavor
void saveWithFlavor(DishDto dishDto);</code></pre>
<p>相关的实现：</p>
<pre><code class="language-java">@Autowired
private DishFlavorService dishFlavorService;
/**
 * 新增菜品同时保存对应的口味数据
 * @param dishDto
 */
@Override
@Transactional //涉及到对多张表的数据进行操作,需要加事务，需要事务生效,需要在启动类加上事务注解生效
public void saveWithFlavor(DishDto dishDto) {
    //保存菜品的基本信息到菜品表dish中
    this.save(dishDto);
    Long dishId = dishDto.getId();

    //为了把dishId  set进flavors表中
    //拿到菜品口味
    List&lt;DishFlavor&gt; flavors = dishDto.getFlavors();
    //这里对集合进行赋值 可以使用循环或者是stream流
    flavors = flavors.stream().map((item) -&gt;{
        //拿到的这个item就是这个DishFlavor集合
        item.setDishId(dishId);
        return item; //记得把数据返回去
    }).collect(Collectors.toList()); //把返回的集合搜集起来,用来被接收

    //把菜品口味的数据到口味表 dish_flavor  注意dish_flavor只是封装了name value 并没有封装dishId(从前端传过来的数据发现的,然而数据库又需要这个数据)
    dishFlavorService.saveBatch(dishDto.getFlavors()); //这个方法是批量保存
}</code></pre>
<p>在启动类开启事务： 加上这个注解就行 @EnableTransactionManagement</p>
<p>controller 层的代码：</p>
<pre><code class="language-java">package com.itheima.reggie.controller;

import com.itheima.reggie.common.R;
import com.itheima.reggie.dto.DishDto;
import com.itheima.reggie.service.DishService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * @author LJM
 * @create 2022/4/16
 */
@RestController
@RequestMapping("/dish")
@Slf4j
public class DishController {

    @Autowired
    private DishService dishService;

    /**
     * 新增菜品
     * @param dishDto
     * @return
     */
    @PostMapping
    public R&lt;String&gt; save(@RequestBody DishDto dishDto){ //前端提交的是json数据的话，我们在后端就要使用这个注解来接收参数，否则接收到的数据全是null
        dishService.saveWithFlavor(dishDto);
        return R.success("新增菜品成功");
    }
}</code></pre>
<p><strong>功能测试：记得功能测试！</strong></p>
<p></p>
<h2 id="%E8%8F%9C%E5%93%81%E4%BF%A1%E6%81%AF%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2(%E5%8A%9F%E8%83%BD%E5%AE%8C%E5%96%84%E9%87%8C%E9%9D%A2%E7%9A%84%E4%BB%A3%E7%A0%81%E8%A6%81%E7%86%9F%E6%82%89%2C%E6%9C%89%E9%9B%86%E5%90%88%E6%B3%9B%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2%EF%BC%8C%E5%AF%B9%E8%B1%A1copy)">菜品信息分页查询(功能完善里面的代码要熟悉,有集合泛型的转换，对象copy)</h2>
<p>需求分析：</p>
<p><img alt="" height="561" src="image\da8831b93f054499a4353d70eb03940a.png" width="1151"/></p>
<p><img alt="" height="390" src="image\28ce341d05d047e6906d8dc677ca54da.png" width="1138"/></p>
<p> <strong>图片下载的请求前面已经写好了，前端也写好了相关的请求，所以第二步的图片下载和展示就不需要我们管了；</strong></p>
<p><strong>代码编写：</strong></p>
<p>controller层的代码:不过这里是有bug的，后面会改善；</p>
<pre><code class="language-java">/**
 * 菜品信息分页查询
 * @param page
 * @param pageSize
 * @param name
 * @return
 */
@GetMapping("/page")
public R&lt;Page&gt; page(int page,int pageSize,String name){
    
    //构造一个分页构造器对象
    Page&lt;Dish&gt; dishPage = new Page&lt;&gt;(page,pageSize);
    
    //构造一个条件构造器
    LambdaQueryWrapper&lt;Dish&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();
    //添加过滤条件 注意判断是否为空  使用对name的模糊查询
    queryWrapper.like(name != null,Dish::getName,name);
    //添加排序条件  根据更新时间降序排
    queryWrapper.orderByDesc(Dish::getUpdateTime);
    //去数据库处理分页 和 查询
    dishService.page(dishPage,queryWrapper);
    
    //因为上面处理的数据没有分类的id,这样直接返回R.success(dishPage)虽然不会报错，但是前端展示的时候这个菜品分类这一数据就为空
    return R.success(dishPage);
}</code></pre>
<p><strong>功能完善：</strong>引入了DishDto</p>
<pre><code class="language-java">package com.itheima.reggie.dto;

import com.itheima.reggie.entity.Dish;
import com.itheima.reggie.entity.DishFlavor;
import lombok.Data;
import java.util.ArrayList;
import java.util.List;

@Data
public class DishDto extends Dish {

    private List&lt;DishFlavor&gt; flavors = new ArrayList&lt;&gt;();

    private String categoryName;

    private Integer copies; //后面用的
}</code></pre>
<pre><code class="language-java">/**
     * 菜品信息分页查询
     * @param page
     * @param pageSize
     * @param name
     * @return
     */
    @GetMapping("/page")
    public R&lt;Page&gt; page(int page,int pageSize,String name){

        //构造一个分页构造器对象
        Page&lt;Dish&gt; dishPage = new Page&lt;&gt;(page,pageSize);
        Page&lt;DishDto&gt; dishDtoPage = new Page&lt;&gt;(page,pageSize);
        //上面对dish泛型的数据已经赋值了，这里对DishDto我们可以把之前的数据拷贝过来进行赋值

        //构造一个条件构造器
        LambdaQueryWrapper&lt;Dish&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();
        //添加过滤条件 注意判断是否为空  使用对name的模糊查询
        queryWrapper.like(name != null,Dish::getName,name);
        //添加排序条件  根据更新时间降序排
        queryWrapper.orderByDesc(Dish::getUpdateTime);
        //去数据库处理分页 和 查询
        dishService.page(dishPage,queryWrapper);

        //获取到dish的所有数据 records属性是分页插件中表示分页中所有的数据的一个集合
        List&lt;Dish&gt; records = dishPage.getRecords();

        List&lt;DishDto&gt; list = records.stream().map((item) -&gt;{
            //对实体类DishDto进行categoryName的设值

            DishDto dishDto = new DishDto();
            //这里的item相当于Dish  对dishDto进行除categoryName属性的拷贝
            BeanUtils.copyProperties(item,dishDto);
            //获取分类的id
            Long categoryId = item.getCategoryId();
            //通过分类id获取分类对象
            Category category = categoryService.getById(categoryId);
            if ( category != null){
                //设置实体类DishDto的categoryName属性值
                String categoryName = category.getName();
                dishDto.setCategoryName(categoryName);
            }
            return dishDto;
        }).collect(Collectors.toList());

        //对象拷贝  使用框架自带的工具类，第三个参数是不拷贝到属性
        BeanUtils.copyProperties(dishPage,dishDtoPage,"records");
        dishDtoPage.setRecords(list);
        //因为上面处理的数据没有分类的id,这样直接返回R.success(dishPage)虽然不会报错，但是前端展示的时候这个菜品分类这一数据就为空
        //所以进行了上面的一系列操作
        return R.success(dishDtoPage);
    }</code></pre>
<p>records的值： protected List&lt;T&gt; records;</p>
<p><img alt="" height="531" src="image\68ef9d5c84fa4221aa9da21acdb1778a.png" width="1196"/></p>
<p> <strong>功能测试：</strong></p>
<p><img alt="" height="536" src="image\2aee94b4c6204e518265c10bcd1d285a.png" width="1200"/></p>
<p></p>
<h2 id="%E4%BF%AE%E6%94%B9%E8%8F%9C%E5%93%81(%E5%9B%9E%E6%98%BE%E5%92%8C%E4%BF%9D%E5%AD%98%E4%BF%AE%E6%94%B9%E9%83%BD%E6%98%AF%E4%B8%A4%E5%BC%A0%E8%A1%A8)">修改菜品(回显和保存修改都是两张表)</h2>
<p>需求分析：</p>
<p><img alt="" height="606" src="image\5ae3ea87adba48fca6b4e7db55013e25.png" width="1200"/></p>
<p> <strong>代码开发：</strong> </p>
<p><img alt="" height="449" src="image\21ee149b7dbd43e78f2db570bbdfba7e.png" width="1100"/></p>
<p>第一次交互的后端代码已经完成了；菜品分类的信息前面做新增菜品的时候就已经完成了，这里前端发一个相关接口的请求就行；</p>
<p>第三次交互，图片的下载前面也已经写了，所以前端直接发生请求就行；</p>
<h2 id="%E8%8F%9C%E5%93%81%E4%BF%A1%E6%81%AF%E7%9A%84%E5%9B%9E%E6%98%BE%EF%BC%9A">菜品信息的回显：</h2>
<p>在service添加自己要实现的方法：</p>
<pre><code>//根据id来查询菜品信息和对应的口味信息
DishDto getByIdWithFlavor(Long id);</code></pre>
<p> 方法的 实现：</p>
<pre><code class="language-java">	@Autowired
    private DishFlavorService dishFlavorService;
/**
 * 根据id来查询菜品信息和对应的口味信息
 * @param id
 * @return
 */
@Override
public DishDto getByIdWithFlavor(Long id) {
    //查询菜品的基本信息  从dish表查询
    Dish dish = this.getById(id);

    //查询当前菜品对应的口味信息,从dish_flavor查询  条件查询
    LambdaQueryWrapper&lt;DishFlavor&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();
    queryWrapper.eq(DishFlavor::getDishId,dish.getId());
    List&lt;DishFlavor&gt; flavors = dishFlavorService.list(queryWrapper);

    //然后把查询出来的flavors数据set进行 DishDto对象
    DishDto dishDto = new DishDto();
    //把dish表中的基本信息copy到dishDto对象，因为才创建的dishDto里面的属性全是空
    BeanUtils.copyProperties(dish,dishDto);
    dishDto.setFlavors(flavors);

    return dishDto;
}</code></pre>
<p><strong>controller 层的编写：</strong></p>
<pre><code class="language-java">/**
 * 根据id来查询菜品信息和对应的口味信息
 * @param id
 * @return
 */
@GetMapping("/{id}")
public R&lt;DishDto&gt; get(@PathVariable Long id){  //这里返回什么数据是要看前端需要什么数据,不能直接想当然的就返回Dish对象
    DishDto dishDto = dishService.getByIdWithFlavor(id);
    return R.success(dishDto);
}</code></pre>
<h3 id="%E4%BF%9D%E5%AD%98%E4%BF%AE%E6%94%B9%EF%BC%9A(%E9%87%8D%E7%82%B9)">保存修改：(重点)</h3>
<p>保存修改设计两张表的数据的修改：</p>
<p>DishService中添加自己实现的方法：</p>
<pre><code class="language-java">//更新菜品信息同时还更新对应的口味信息
void updateWithFlavor(DishDto dishDto);</code></pre>
<p>相关的实现：</p>
<pre><code class="language-java">   @Override
    @Transactional
    public void updateWithFlavor(DishDto dishDto) {
        //更新dish表的基本信息  因为这里的dishDto是dish的子类
        this.updateById(dishDto);

        //更新口味信息---》先清理再重新插入口味信息
        //清理当前菜品对应口味数据---dish_flavor表的delete操作
        LambdaQueryWrapper&lt;DishFlavor&gt; queryWrapper = new LambdaQueryWrapper();
        queryWrapper.eq(DishFlavor::getDishId,dishDto.getId());
        dishFlavorService.remove(queryWrapper);

        //添加当前提交过来的口味数据---dish_flavor表的insert操作
        List&lt;DishFlavor&gt; flavors = dishDto.getFlavors();

        //下面这段流的代码我注释,然后测试，发现一次是报dishId没有默认值(先测)，两次可以得到结果(后测，重新编译过，清除缓存过),相隔半个小时
        //因为这里拿到的flavorsz只有name和value(这是在设计数据封装的问题),不过debug测试的时候发现有时候可以拿到全部数据,有时候又不可以...  所以还是加上吧。。。。。
        flavors = flavors.stream().map((item) -&gt; {
            item.setDishId(dishDto.getId());
            return item;
        }).collect(Collectors.toList());

        dishFlavorService.saveBatch(flavors);

    }</code></pre>
<p><strong>小插曲：</strong></p>
<p>stream流没有被注释的时候，dishDto里面所有的属性都可以获取的；</p>
<p><img alt="" height="559" src="image\bad87d20422042acb0ae5c8527698718.png" width="1196"/></p>
<p><img alt="" height="432" src="image\00339c20c2a44dc5946b98988a676e5b.png" width="1192"/></p>
<p> 注释掉的话：debug发现传进来的dishDto中的dishId为null以及id全为null；那么是不是意味着前面的使用id查询的语句也执行失败？</p>
<p><img alt="" height="699" src="image\05c4fd9e0463480f9dd968dbdbe91bca.png" width="1194"/></p>
<p> <img alt="" height="540" src="image\e4b8bd0160164841bddf3dab4405fd4a.png" width="1200"/></p>
<p></p>
<h2 id="%E9%9C%80%E8%A6%81%E8%87%AA%E5%B7%B1%E5%8D%95%E7%8B%AC%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8A%9F%E8%83%BD">需要自己单独实现的功能</h2>
<p>见我的另一篇博客：<a href="https://blog.csdn.net/weixin_53142722/article/details/124371940" title="(8条消息) 瑞吉外卖项目剩余功能补充_未来很长，别只看眼前的博客-CSDN博客">(8条消息) 瑞吉外卖项目剩余功能补充_未来很长，别只看眼前的博客-CSDN博客</a></p>
<p></p>
<h1 id="%E4%B9%9D%E3%80%81%E5%A5%97%E9%A4%90%E7%AE%A1%E7%90%86">九、套餐管理</h1>
<p>需求分析:</p>
<p><img alt="" height="573" src="image\4b82309c7d7f4503ab8564d601004d8e.png" width="1199"/></p>
<p><strong>数据模型：</strong></p>
<p><img alt="" height="750" src="image\b1cb8a942eae4dabb549217477def625.png" width="1200"/> <img alt="" height="505" src="image\fe6de7ee62ed4728868f1adbef93e5c7.png" width="1194"/></p>
<p></p>
<p>代码开发：</p>
<p>准备工作：</p>
<p><img alt="" height="460" src="image\26b98b370e1b484da61f8b1dc2cb4087.png" width="1200"/></p>
<p> 创建mapper：</p>
<pre><code class="language-java">package com.itheima.reggie.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.itheima.reggie.entity.SetmealDish;
import org.apache.ibatis.annotations.Mapper;

@Mapper
public interface SetmealDishMapper extends BaseMapper&lt;SetmealDish&gt; {
}</code></pre>
<p>创建service：</p>
<pre><code class="language-java">package com.itheima.reggie.service;

import com.baomidou.mybatisplus.extension.service.IService;
import com.itheima.reggie.entity.SetmealDish;

/**
 * @author LJM
 * @create 2022/4/17
 */
public interface SetmealDishService extends IService&lt;SetmealDish&gt; {
}</code></pre>
<p></p>
<pre><code class="language-java">package com.itheima.reggie.service.impl;

import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.itheima.reggie.entity.SetmealDish;
import com.itheima.reggie.mapper.SetmealDishMapper;
import com.itheima.reggie.service.SetmealDishService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

/**
 * @author LJM
 * @create 2022/4/17
 */
@Service
@Slf4j
public class SetmealDishServiceImpl extends ServiceImpl&lt;SetmealDishMapper, SetmealDish&gt; implements SetmealDishService {
}</code></pre>
<h2 id="%E6%B7%BB%E5%8A%A0%E8%8F%9C%E5%93%81%E6%95%B0%E6%8D%AE%E5%9B%9E%E6%98%BE">添加菜品数据回显</h2>
<p><strong>controller层代码：</strong></p>
<p><img alt="" height="553" src="image\96ec88c540c84522a332f0a03950fe9a.png" width="1200"/></p>
<p> 第一个交互前面写了；分类管理通过type的值来控制在前端展示的是 菜品分类(type=1) 或者是 套餐分类（type=2）</p>
<p><img alt="" height="625" src="image\953c266226464d33890bb06477226a61.png" width="816"/></p>
<p><img alt="" height="528" src="image\0f3e05c59a704ce59ae562f0ca3419b0.png" width="1200"/></p>
<p>第二个交互前面也写了，在categorycontroller里面的list方法；</p>
<p>第四和第五前面也写了；</p>
<p></p>
<p>第三个交互：前端请求的地址；</p>
<p><img alt="" height="537" src="image\f17cc37e9bde4a7cb445a521b6408fe4.png" width="1200"/></p>
<p> 在DishController书写代码：</p>
<pre><code class="language-java">    /**
     * 根据条件查询对应的菜品数据
     * @param dish
     * @return
     */
    @GetMapping("/list")
    public R&lt;List&lt;Dish&gt;&gt; list(Dish dish){ //会自动映射的
        //这里可以传categoryId,但是为了代码通用性更强,这里直接使用dish类来接受（因为dish里面是有categoryId的）,以后传dish的其他属性这里也可以使用
        //构造查询条件
        LambdaQueryWrapper&lt;Dish&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();
        queryWrapper.eq(dish.getCategoryId() != null ,Dish::getCategoryId,dish.getCategoryId());
        //添加条件，查询状态为1（起售状态）的菜品
        queryWrapper.eq(Dish::getStatus,1);

        //添加排序条件
        queryWrapper.orderByAsc(Dish::getSort).orderByDesc(Dish::getUpdateTime);

        List&lt;Dish&gt; list = dishService.list(queryWrapper);
        return R.success(list);
    }</code></pre>
<p> 控制台输出的sql语句：</p>
<pre><code class="language-java">SELECT id,name,category_id,price,code,image,description,status,sort,create_time,update_time,create_user,update_user,is_deleted FROM dish WHERE (category_id = ? AND status = ?) ORDER BY sort ASC,update_time DESC</code></pre>
<h2 id="%E4%BF%9D%E5%AD%98%E6%B7%BB%E5%8A%A0%E5%A5%97%E9%A4%90%EF%BC%88%E7%90%86%E8%A7%A3%E9%87%8C%E9%9D%A2%E7%9A%84%E5%85%B3%E7%B3%BB%E6%9C%89%E7%82%B9%E5%9B%B0%E9%9A%BE%EF%BC%89">保存添加套餐（理解里面的关系有点困难）</h2>
<p>实现要求：点击保存按钮，发送ajax请求,将套餐相关的数据以json形式提交到服务端；</p>
<p>前端提交请求：</p>
<p><img alt="" height="330" src="image\d2566a267ad24234acba40400c0fc927.png" width="1200"/></p>
<p> 前端携带的参数：<strong>重要</strong></p>
<p><img alt="" height="493" src="image\f0ada22059ad4231869c92a8785993ac.png" width="1200"/></p>
<p> <strong>根据前端传过来的数据我们可以在后端确定我们需要在后端使用什么来接受前端的参数；</strong></p>
<p>编写controller：上面的dishList，我们数据库并不需要这个数据，所以接收数据的实体类没有dishList这个属性也没有关系，前端传过来的数据都是自动映射到接收数据的实体类的属性上的，<strong>没有对应起来就不会映射。</strong></p>
<p>涉及两张表的操作：套餐表和菜品表；</p>
<pre><code class="language-java">    /**
     * 新增套餐
     * 涉及两张表的操作：套餐表和菜品表；
     * @param setmealDto
     * @return
     */
    @PostMapping
    public R&lt;String&gt; save(@RequestBody SetmealDto setmealDto){

        setmealService.saveWithDish(setmealDto);

        return R.success("新增套餐成功");
    }</code></pre>
<p>SetmealService中添加自定义的方法：</p>
<pre><code class="language-java">/**
 * 新增套餐，同时需要保存套餐和菜品的关联关系
 * @param setmealDto
 */
void saveWithDish(SetmealDto setmealDto);</code></pre>
<pre><code class="language-java">@Autowired
SetmealDishService setmealDishService;

/**
 * 新增套餐，同时需要保存套餐和菜品的关联关系
 * @param setmealDto
 */
@Transactional
@Override
public void saveWithDish(SetmealDto setmealDto) {
    //保存套餐的基本信息，操作setmeal,执行insert
    this.save(setmealDto);
    log.info(setmealDto.toString()); //查看一下这个套餐的基本信息是什么

    //保存套餐和菜品的关联信息，操作setmeal_dish ,执行insert操作
    List&lt;SetmealDish&gt; setmealDishes = setmealDto.getSetmealDishes();
    //注意上面拿到的setmealDishes是没有setmeanlId这个的值的，通过debug可以发现
    setmealDishes.stream().map((item)-&gt;{
        item.setSetmealId(setmealDto.getId());
        return item; //这里返回的就是集合的泛型
    }).collect(Collectors.toList());

    setmealDishService.saveBatch(setmealDishes); //批量保存
}</code></pre>
<p><strong>功能测试，自己测试；</strong></p>
<p></p>
<h2 id="%E5%A5%97%E9%A4%90%E4%BF%A1%E6%81%AF%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2">套餐信息分页查询</h2>
<p>需求分析：</p>
<p><img alt="" height="455" src="image\1ea2648e5b7342e883feae4433e58696.png" width="1185"/></p>
<p></p>
<p><strong>代码开发：</strong></p>
<p><strong>前端发起的请求以及携带的参数：</strong></p>
<p><img alt="" height="506" src="image\4e5186bcde6048e89835afb3a77ee26d.png" width="1178"/></p>
<p> 查询分页：</p>
<p><img alt="" height="736" src="image\a814208f453740f5aba4f830e3ce276a.png" width="1200"/></p>
<p> <img alt="" height="423" src="image\16d0a9bbca554dcea6ccc82b2fee2d17.png" width="1189"/></p>
<p><strong>controller层代码编写：</strong></p>
<pre><code class="language-java">/**
 * 套餐分页查询
 * @param page
 * @param pageSize
 * @param name
 * @return
 */
@GetMapping("/page")
public R&lt;Page&gt; page(int page, int pageSize, String name){

    //分页构造器对象
    Page&lt;Setmeal&gt; pageInfo = new Page&lt;&gt;(page,pageSize);
    //构造条件查询对象
    LambdaQueryWrapper&lt;Setmeal&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();
    //添加查询条件，根据name进行like模糊查询
    queryWrapper.like(name != null,Setmeal::getName,name);
    //添加排序条件，根据更新时间降序排列
    queryWrapper.orderByDesc(Setmeal::getUpdateTime);
    setmealService.page(pageInfo,queryWrapper);

    /**
     * 注意如果这里直接返回R.success(pageInfo)，
     * 虽然不会报错但是分页的数据的套餐分类的名字是显示不了的；
     * 因为这个分页的泛型是Setmeal,Setmeal只封装了f分类的Id categoryId，没有分类的名称 name
     * 所以又需要进行name的获取和设值
     */
    return R.success(pageInfo);
}</code></pre>
<p> <strong>bug修复：</strong></p>
<pre><code class="language-java">/**
 * 套餐分页查询
 * @param page
 * @param pageSize
 * @param name
 * @return
 */
@GetMapping("/page")
public R&lt;Page&gt; page(int page, int pageSize, String name){

    //分页构造器对象
    Page&lt;Setmeal&gt; pageInfo = new Page&lt;&gt;(page,pageSize);
    Page&lt;SetmealDto&gt; dtoPage = new Page&lt;&gt;(page,pageSize);

    //构造条件查询对象
    LambdaQueryWrapper&lt;Setmeal&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();
    //添加查询条件，根据name进行like模糊查询
    queryWrapper.like(name != null,Setmeal::getName,name);
    //添加排序条件，根据更新时间降序排列
    queryWrapper.orderByDesc(Setmeal::getUpdateTime);
    setmealService.page(pageInfo,queryWrapper);

    //对象的拷贝  注意这里要把分页数据的全集合records给忽略掉
    BeanUtils.copyProperties(pageInfo,dtoPage,"records");
    List&lt;Setmeal&gt; records = pageInfo.getRecords();

    //对records对象进行处理然后封装好赋值给list
    List&lt;SetmealDto&gt; list = records.stream().map((item)-&gt;{
        SetmealDto setmealDto = new SetmealDto();

        //对setmealDto进行除categoryName的属性进行拷贝(因为item里面没有categoryName)
        BeanUtils.copyProperties(item,setmealDto);

        //获取分类id  通过分类id获取分类对象  然后再通过分类对象获取分类名
        Long categoryId = item.getCategoryId();

        //根据分类id获取分类对象  判断是否为null
        Category category = categoryService.getById(categoryId);

        if (category != null){
            String categoryName = category.getName();
            setmealDto.setCategoryName(categoryName);
        }
        return setmealDto;
    }).collect(Collectors.toList());
    dtoPage.setRecords(list);

    return R.success(dtoPage);
}</code></pre>
<h2 id="%E5%88%A0%E9%99%A4%E5%A5%97%E9%A4%90">删除套餐</h2>
<p><img alt="" height="439" src="image\d6a5e92ee4b640409fb4d2be38f166fc.png" width="1197"/></p>
<p></p>
<p><strong>代码开发：</strong></p>
<p>单个套餐删除前端发的请求和携带的参数：</p>
<p><img alt="" height="433" src="image\5dc1ac4b89794510bb7afb309184f71d.png" width="1200"/></p>
<p> 套餐批量删除前端发的请求和携带的参数：</p>
<p><img alt="" height="418" src="image\8fdd43cb704349f5ada8e458f788bbd6.png" width="1200"/></p>
<p><img alt="" height="651" src="image\20f41802460943ca9b19b8bef96fb1ff.png" width="1200"/></p>
<p> <strong>controller层开发</strong></p>
<p>在SetmealService中添加自定义的方法：</p>
<pre><code class="language-java">/**
 * 删除套餐，同时需要删除套餐和菜品的关联数据
 * @param ids
 */
void removeWithDish(List&lt;Long&gt; ids);</code></pre>
<p>实现该方法：</p>
<pre><code class="language-java">/**
 * 删除套餐，同时需要删除套餐和菜品的关联数据
 * @param ids
 */
@Override
@Transactional
public void removeWithDish(List&lt;Long&gt; ids) {
    //sql语句应该是这样的:select count(*) setmeal where id in () and status = 1;
    //查询套餐的状态，看是否可以删除
    LambdaQueryWrapper&lt;Setmeal&gt; queryWrapper = new LambdaQueryWrapper();
    queryWrapper.in(Setmeal::getId,ids);
    queryWrapper.eq(Setmeal::getStatus,1);
    int count = this.count(queryWrapper);
    //如果不能删除，抛出一个业务异常
    if (count &gt; 0){
        throw new CustomException("套餐正在售卖中,不能删除");
    }
    //如果可以删除，先删除套餐表中的数据--setmeal 
    this.removeByIds(ids);
    //删除关系表中的数据--setmeal_dish
    //delete from setmeal_dish where setmeal_id in (1,2,3)
    LambdaQueryWrapper&lt;SetmealDish&gt; lambdaQueryWrapper = new LambdaQueryWrapper();
    lambdaQueryWrapper.in(SetmealDish::getSetmealId,ids);
    setmealDishService.remove(lambdaQueryWrapper);
}</code></pre>
<p><strong>功能测试；</strong></p>
<p></p>
<h2>需要自己单独实现的功能</h2>
<p>下面功能的具体代码在我的另一篇博客：<a href="https://blog.csdn.net/weixin_53142722/article/details/124371940" title="(8条消息) 瑞吉外卖项目剩余功能补充_未来很长，别只看眼前的博客-CSDN博客">(8条消息) 瑞吉外卖项目剩余功能补充_未来很长，别只看眼前的博客-CSDN博客</a></p>
<h3 id="%E5%A5%97%E9%A4%90%E7%AE%A1%E7%90%86%E7%9A%84%E5%90%AF%E5%94%AE%EF%BC%8C%E5%81%9C%E5%94%AE">套餐管理的启售，停售</h3>
<h3 id="%E5%A5%97%E9%A4%90%E7%AE%A1%E7%90%86%E7%9A%84%E4%BF%AE%E6%94%B9">套餐管理的修改</h3>
<h3 id="%E5%90%8E%E5%8F%B0%E8%AE%A2%E5%8D%95%E5%B1%95%E7%A4%BA%E5%92%8C%E6%9F%A5%E8%AF%A2%EF%BC%88%E8%87%AA%E5%B7%B1%E5%86%99%E7%9A%84%EF%BC%8C%E6%9C%89%E9%87%8D%E7%82%B9%EF%BC%89">后台订单展示和查询</h3>
<p></p>
<h1 id="%E6%89%8B%E6%9C%BA%E7%AB%AF%E5%BC%80%E5%8F%91">移动端开发</h1>
<p>见另一篇博客：</p>
<p></p>
</div>
</div>