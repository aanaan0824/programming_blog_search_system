<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="markdown_views prism-tomorrow-night" id="content_views">
<svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
<path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
</svg>
<p></p>
<div class="toc">
<h3>文章目录</h3>
<ul><li><a href="#x1F4D6_1">📖前言</a></li><li><a href="#1__6">1. 匿名对象</a></li><li><a href="#2_explicit_53">2. 单参数的构造函数与explicit的使用</a></li><li><ul><li><ul><li><a href="#21__54">2.1 隐式类型转换：</a></li><li><a href="#22_explicit_94">2.2 explicit的使用：</a></li></ul>
</li></ul>
</li><li><a href="#3__124">3. 编译器对连续构造的优化</a></li><li><ul><li><ul><li><a href="#31__125">3.1 正常的构造和拷贝构造：</a></li><li><a href="#32__171">3.2 编译器优化之后的构造和拷贝构造：</a></li><li><a href="#33__271">3.3 终极一题：</a></li></ul>
</li></ul>
</li><li><a href="#4__329">4. 友元类和内部类</a></li><li><ul><li><ul><li><a href="#41__330">4.1 友元类：</a></li><li><a href="#42__464">4.2 内部类：</a></li></ul>
</li></ul>
</li></ul>
</div>
<p></p>
<h1><a id="x1F4D6_1"></a>📖前言</h1>
<p>本章将会对类和对象中用类构造对象过程中出现的特殊情况分析讲解，因为有可能代码在不同的编译器上执行，不同编译器对特殊情况的处理不一样，可能会在不同的平台上的结果都不尽相同，<strong>所以本章仅为补充内容，供大家参考</strong>。</p>
<p><strong>注：</strong> <font color="blue">本篇博文代码运行的环境为VS编译器系列的2019版本。</font></p>
<hr/>
<h1><a id="1__6"></a>1. 匿名对象</h1>
<ul><li><strong>我们之前用类创造对象的时候格式都是：<font color="blue">类名 对象名;</font></strong></li><li><strong>现在提供一种新的方法，所创造出来的对象叫做匿名对象，格式是：<font color="green">类名（）;</font></strong></li></ul>
<p><strong>代码如下：</strong></p>
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">const</span> A<span class="token operator">&amp;</span> aa<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"const A&amp; aa"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"~A()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _a<span class="token punctuation">;</span>
	<span class="token keyword">int</span> _b<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	A aa<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

	<span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p><strong><font color="green">构造函数，拷贝构造，析构函数等都只是打印了一下，方便观察。</font></strong></p>
<p><font color="blue"><strong>运行结果：</strong></font><br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/a05258917f11404b9ed25573ccd10f3e.png#pic_center"/><br/> <strong>特点：</strong></p>
<ul><li>如图所见匿名对象的声明周期只有该匿名对象所在的那一行</li><li>该匿名对象所在的行执行结束之后，就会立刻调用析构函数销毁</li></ul>
<hr/>
<h1><a id="2_explicit_53"></a>2. 单参数的构造函数与explicit的使用</h1>
<h3><a id="21__54"></a>2.1 隐式类型转换：</h3>
<p>构造函数不仅可以构造与初始化对象，<strong>对于单个参数或者除第一个参数无默认值其余均有默认值的构造函数，还具有类型转换的作用</strong>。</p>
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Date</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">Date</span><span class="token punctuation">(</span><span class="token keyword">int</span> year<span class="token punctuation">)</span>
		<span class="token operator">:</span><span class="token function">_year</span><span class="token punctuation">(</span>year<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _year<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Date <span class="token function">d1</span><span class="token punctuation">(</span><span class="token number">2022</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//构造</span>

	<span class="token comment">//隐式类型的转换</span>
	Date d2 <span class="token operator">=</span> <span class="token number">2022</span><span class="token punctuation">;</span> <span class="token comment">//构造 ＋ 拷贝构造 -&gt; 优化 合二为一</span>
	<span class="token comment">//中间会生成临时变量</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<ul><li class="task-list-item"><input checked="true" class="task-list-item-checkbox" disabled="disabled" type="checkbox"/> <strong>Date d1(2022);</strong> - 普通的构造</li><li class="task-list-item"><input checked="true" class="task-list-item-checkbox" disabled="disabled" type="checkbox"/> <strong>Date d2 = 2022;</strong> - 隐式类型转换</li></ul>
<ul><li> <p>相当于用2022构造了一个<strong>临时对象或者匿名对象</strong>（具有常性），<strong>再用临时对象拷贝构造一个d2</strong></p> </li><li> <p>本来是先构造再拷贝构造：<strong><font color="blue">Date(2022) —&gt; Date d2(Date(2022))</font> ，但是结果是编译器对其进行了优化，<font color="red">直接优化成直接构造</font></strong></p> </li><li> <p><strong><font color="orange">构造 ＋ 拷贝构造 —&gt; 优化 合二为一</font></strong></p> </li></ul>
<p><strong>如下图所示，两种构造结果是一样的：</strong></p>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/e1288b866e704a74a077b292f9d87647.png#pic_center"/><br/> <strong>这两种构造的区别是：</strong></p>
<ul><li>第一个是直接构造</li><li>第二个是隐式类型转换</li></ul>
<p><strong><font color="red">标准并没有规定，取决于编译器自身的行为.</font></strong></p>
<h3><a id="22_explicit_94"></a>2.2 explicit的使用：</h3>
<p><strong>单参构造函数，没有使用explicit修饰，具有类型转换作用<br/> <font color="blue">explicit修饰构造函数，禁止类型转换—explicit去掉之后，代码可以通过编译</font></strong></p>
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Date</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">explicit</span> <span class="token function">Date</span><span class="token punctuation">(</span><span class="token keyword">int</span> year<span class="token punctuation">,</span> <span class="token keyword">int</span> month <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">int</span> day <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token operator">:</span> <span class="token function">_year</span><span class="token punctuation">(</span>year<span class="token punctuation">)</span>
	<span class="token punctuation">,</span> <span class="token function">_month</span><span class="token punctuation">(</span>month<span class="token punctuation">)</span>
	<span class="token punctuation">,</span> <span class="token function">_day</span><span class="token punctuation">(</span>day<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
	
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _year<span class="token punctuation">;</span>
	<span class="token keyword">int</span> _month<span class="token punctuation">;</span>
	<span class="token keyword">int</span> _day<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Date <span class="token function">d1</span><span class="token punctuation">(</span><span class="token number">2022</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	d1 <span class="token operator">=</span> <span class="token number">2023</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p><strong><font color="red">用explicit修饰构造函数，将会禁止构造函数的隐式转换。</font></strong></p>
<hr/>
<h1><a id="3__124"></a>3. 编译器对连续构造的优化</h1>
<h3><a id="31__125"></a>3.1 正常的构造和拷贝构造：</h3>
<p><strong>下面程序的运行结果是什么：</strong></p>
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Weight</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">Weight</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Weight()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token function">Weight</span><span class="token punctuation">(</span><span class="token keyword">const</span> Weight<span class="token operator">&amp;</span> w<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Weight(cosnt Weight&amp; w)"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token operator">~</span><span class="token function">Weight</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"~Weight()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

Weight <span class="token function">f</span><span class="token punctuation">(</span>Weight u<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Weight <span class="token function">v</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span>
	Weight w <span class="token operator">=</span> v<span class="token punctuation">;</span>

	<span class="token keyword">return</span> w<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Weight x<span class="token punctuation">;</span>
	<span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p><strong><font color="red">公布答案：</font></strong><br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/18815dfa4482482d89d9f64da34e2073.png#pic_center"/><br/> <strong>解释：</strong></p>
<ul><li>f函数是传值传参，实参拷贝给形参，所以要调用拷贝构造</li><li><strong>还未示例化出来的对象调用赋值重载的时候不是调用赋值重载，而是调用拷贝构造</strong></li><li>f函数是传值返回，不是传引用返回，所以函数f返回的时候会生成一个临时变量用来存放w对象的拷贝，这里又要调用一次拷贝构造</li><li><strong>f(x)是一个临时变量，也可以看做是匿名对象，生命周期就那一行，执行完就结束调用其析构函数</strong></li></ul>
<h3><a id="32__171"></a>3.2 编译器优化之后的构造和拷贝构造：</h3>
<p><strong><font color="green">单纯为了传参，弄一个匿名对象</font></strong></p>
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">//单纯为了传参，弄一个匿名对象</span>
	<span class="token function">f</span><span class="token punctuation">(</span><span class="token function">Weight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p><strong><font color="red">公布答案：</font></strong><br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/0e0ca53aa2c84193afdb18d63a15adac.png#pic_center"/></p>
<ul><li><strong>编译器在一个步骤里面，一个调用表达式中</strong></li><li><font color="green"><strong>连续步骤的构造 + 拷贝构造，或者拷贝构造 + 拷贝构造</strong></font></li></ul>
<p><strong>这时候有两种情况：</strong></p>
<ul><li class="task-list-item"><input checked="true" class="task-list-item-checkbox" disabled="disabled" type="checkbox"/> 构造 + 拷贝构造 （传统）</li><li class="task-list-item"><input checked="true" class="task-list-item-checkbox" disabled="disabled" type="checkbox"/> 直接构造 （优化之后）</li></ul>
<ul><li><strong><font color="green">胆大的编译器可能就会优化，合二为一，直接构造</font></strong></li><li><strong>但是C++标准中并没有规定编译器要不要优化，胆肥一点的编译器就会做，现在新的编译器胆都比较肥，都会做。</strong></li></ul>
<p><strong>知识关联：</strong></p>
<blockquote>
<p>和之前的那个隐式类型转换一样：Date d2 = 2022，本来应该是先用2022构造一个匿名对象，再用这个匿名对象去拷贝构造一样，但是最后被编译器优化，直接用2022去构造对象了</p>
</blockquote>
<p><strong>下面程序拷贝构造的次数是多少：</strong></p>
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Weight</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">Weight</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Weight()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token function">Weight</span><span class="token punctuation">(</span><span class="token keyword">const</span> Weight<span class="token operator">&amp;</span> w<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Weight(cosnt Weight&amp; w)"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	Weight<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Weight<span class="token operator">&amp;</span> w<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Weight&amp; operator=(const Weight&amp; w)"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token operator">~</span><span class="token function">Weight</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"~Weight()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

Weight <span class="token function">f</span><span class="token punctuation">(</span>Weight u<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Weight <span class="token function">v</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span>
	Weight w <span class="token operator">=</span> v<span class="token punctuation">;</span>

	<span class="token keyword">return</span> w<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Weight x<span class="token punctuation">;</span>
	Weight ret <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p><strong><font color="red">公布答案：</font></strong><br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/eda61b9bf7d5448da64cc72fe1c49e5e.png#pic_center"/><br/> <strong>解释如下：</strong></p>
<p><font color="blue">按照传统，中规中矩的，一步一步来构造拷贝构造，拷贝构造应该如下图所示：</font><br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/55203a79df9a432692f4d1490444b293.png#pic_center"/><br/> <strong><font color="green">在这里编译器也会有优化：</font></strong></p>
<ul><li><strong>4 和 5 两步会被编译器优化直接合并成一步，相当于w直接构造ret去了</strong></li></ul>
<p><strong>如下代码就能将优化阻断掉：</strong></p>
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Weight x<span class="token punctuation">;</span>
	Weight ret<span class="token punctuation">;</span>
	ret <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p><strong><font color="red">公布答案：</font></strong><br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/3e73b663281848bca7c4f581ca08d615.png#pic_center"/><br/> 这就是中规中矩的，一步一步构造拷贝构造的来，还调用了赋值重载。</p>
<p><strong>解释如下：</strong><br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/dd68a44f89b34c8bbebb005598e9c1a0.png#pic_center"/><br/> <strong><font color="blue">上述红点标出的均为拷贝构造。</font></strong><br/> 《深度探索C++对象模型》中有提到</p>
<h3><a id="33__271"></a>3.3 终极一题：</h3>
<p><strong>下面程序拷贝构造的次数是多少：</strong></p>
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Widget()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	<span class="token function">Widget</span><span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> w<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Widget(cosnt Widget&amp; w)"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	Widget<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> w<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Widget&amp; operator=(const Widget&amp; w)"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	<span class="token operator">~</span><span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"~Widget()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

Widget <span class="token function">f</span><span class="token punctuation">(</span>Widget u<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Widget <span class="token function">v</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span>
	Widget w <span class="token operator">=</span> v<span class="token punctuation">;</span>
	
	<span class="token keyword">return</span> w<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Widget x<span class="token punctuation">;</span>
	Widget y <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p><strong><font color="red">公布答案：</font></strong></p>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/639430d4036041a5aade11783716c811.png#pic_center"/><br/> <strong>解释如下：</strong><br/> 这就是中规中矩的，一步一步构造拷贝构造的来。<br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/ad06dd1caebe44078372cc2d821381ee.png#pic_center"/><br/> <strong>优化：</strong></p>
<ul><li><strong><font color="red">4 和 5合二为一</font></strong></li><li><strong><font color="red">8 和 9合二为一</font></strong></li></ul>
<p><strong><font color="blue">所以总共调用7次拷贝构造。</font></strong></p>
<hr/>
<h1><a id="4__329"></a>4. 友元类和内部类</h1>
<h3><a id="41__330"></a>4.1 友元类：</h3>
<p>在一些情况下面，是需要对类的私有数据，保护数据进行访问的<br/> 不提供友元的话，也可以有其他的方式，在类里面写一个函数将想要的值返回的形式带出去（java喜欢这种方式）</p>
<p><strong>C++中提出友元的概念：</strong></p>
<p><strong><font color="green">前倾回顾，友元函数：</font></strong><br/> <strong>如下代码：</strong></p>
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Date</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">//友元函数 - 我是你的朋友就能访问你的私有</span>
	<span class="token keyword">friend</span> ostream<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>ostream<span class="token operator">&amp;</span> out<span class="token punctuation">,</span> <span class="token keyword">const</span> Date<span class="token operator">&amp;</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token comment">//双操作数的运算符，第一个数是左操作数，第二个数是右操作数</span>
	<span class="token comment">//ostream&amp; operator&lt;&lt;(ostream&amp; out)</span>
	
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _year<span class="token punctuation">;</span>
	<span class="token keyword">int</span> _month<span class="token punctuation">;</span>
	<span class="token keyword">int</span> _day<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

ostream<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>ostream<span class="token operator">&amp;</span> out<span class="token punctuation">,</span> <span class="token keyword">const</span> Date<span class="token operator">&amp;</span> d<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">//通过对象去访问私有</span>
	out <span class="token operator">&lt;&lt;</span> d<span class="token punctuation">.</span>_year <span class="token operator">&lt;&lt;</span> <span class="token string">"/"</span> <span class="token operator">&lt;&lt;</span>  d<span class="token punctuation">.</span>_month  <span class="token operator">&lt;&lt;</span> <span class="token string">"/"</span> <span class="token operator">&lt;&lt;</span> d<span class="token punctuation">.</span>_day <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token keyword">return</span> out<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Date d<span class="token punctuation">;</span>
	<span class="token comment">//d &lt;&lt; cout;</span>

	cout <span class="token operator">&lt;&lt;</span> d<span class="token punctuation">;</span><span class="token comment">//这样更性形象</span>
	<span class="token comment">//为了更形象，且保留可读性，就要写成全局的</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p><strong>详情参考上一篇博客：</strong> 👉 <a href="https://blog.csdn.net/m0_63059866/article/details/126083775">传送门</a></p>
<hr/>
<p><strong><font color="blue">友元类：</font></strong></p>
<ul><li class="task-list-item"><input class="task-list-item-checkbox" disabled="disabled" type="checkbox"/> <strong>友元类的特性：</strong></li></ul>
<ul><li>友元类的所有成员函数都可以是另一个类的友元函数，都可以访问另一个类中的非公有成员(或者保护)。</li><li>友元关系是单向的，不具有交换性。</li><li>比如上述Time类和Date类，在Time类中声明Date类为其友元类，那么可以在Date类中直接访问Time</li><li>类的私有成员变量，但想在Time类中访问Date类中私有的成员变量则不行。</li></ul>
<ul><li class="task-list-item"><input class="task-list-item-checkbox" disabled="disabled" type="checkbox"/> <strong>友元关系不能传递:</strong></li></ul>
<ul><li>如果B是A的友元，C是B的友元，则不能说明C时A的友元。</li><li>友元关系不能继承，在继承位置再给大家详细介绍。</li></ul>
<pre><code class="prism language-cpp"><span class="token comment">//前置声明告诉编译器Date是个类的名字</span>
<span class="token keyword">class</span> <span class="token class-name">Date</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Time</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">friend</span> <span class="token keyword">void</span> <span class="token function">Func</span><span class="token punctuation">(</span><span class="token keyword">const</span> Date<span class="token operator">&amp;</span> d<span class="token punctuation">,</span> <span class="token keyword">const</span> Time<span class="token operator">&amp;</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">//友元类</span>
	<span class="token keyword">friend</span> <span class="token keyword">class</span> <span class="token class-name">Date</span><span class="token punctuation">;</span>
	<span class="token comment">//声明日期类为时间类的友元类</span>
	<span class="token comment">//则在日期类中就直接访问Time类中的私有成员变量</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token comment">//构造函数</span>
	<span class="token function">Time</span><span class="token punctuation">(</span><span class="token keyword">int</span> hour <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">int</span> minute <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">int</span> second <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span>
		<span class="token operator">:</span> <span class="token function">_hour</span><span class="token punctuation">(</span>hour<span class="token punctuation">)</span>
		<span class="token punctuation">,</span> <span class="token function">_minute</span><span class="token punctuation">(</span>minute<span class="token punctuation">)</span>
		<span class="token punctuation">,</span> <span class="token function">_second</span><span class="token punctuation">(</span>second<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

	<span class="token comment">//拷贝构造</span>
	<span class="token function">Time</span><span class="token punctuation">(</span><span class="token keyword">const</span> Time<span class="token operator">&amp;</span> T<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>

	<span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _hour<span class="token punctuation">;</span>
	<span class="token keyword">int</span> _minute<span class="token punctuation">;</span>
	<span class="token keyword">int</span> _second<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">//友元函数放到类里面的任意位置</span>
<span class="token comment">//一个函数也可以是多个类的友元</span>

<span class="token keyword">class</span> <span class="token class-name">Date</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">friend</span> <span class="token keyword">void</span> <span class="token function">Func</span><span class="token punctuation">(</span><span class="token keyword">const</span> Date<span class="token operator">&amp;</span> d<span class="token punctuation">,</span> <span class="token keyword">const</span> Time<span class="token operator">&amp;</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">Date</span><span class="token punctuation">(</span><span class="token keyword">int</span> year <span class="token operator">=</span> <span class="token number">1900</span><span class="token punctuation">,</span> <span class="token keyword">int</span> month <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">int</span> day <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span>
		<span class="token operator">:</span> <span class="token function">_year</span><span class="token punctuation">(</span>year<span class="token punctuation">)</span>
		<span class="token punctuation">,</span> <span class="token function">_month</span><span class="token punctuation">(</span>month<span class="token punctuation">)</span>
		<span class="token punctuation">,</span> <span class="token function">_day</span><span class="token punctuation">(</span>day<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

	<span class="token keyword">void</span> <span class="token function">SetTimeOfDate</span><span class="token punctuation">(</span><span class="token keyword">int</span> hour<span class="token punctuation">,</span> <span class="token keyword">int</span> minute<span class="token punctuation">,</span> <span class="token keyword">int</span> second<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">//直接访问时间类私有的成员变量 - 在Time类外面访问不了</span>
		_t<span class="token punctuation">.</span>_hour <span class="token operator">=</span> hour<span class="token punctuation">;</span>
		_t<span class="token punctuation">.</span>_minute <span class="token operator">=</span> minute<span class="token punctuation">;</span>
		_t<span class="token punctuation">.</span>_second <span class="token operator">=</span> second<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _year<span class="token punctuation">;</span>
	<span class="token keyword">int</span> _month<span class="token punctuation">;</span>
	<span class="token keyword">int</span> _day<span class="token punctuation">;</span>
	Time _t<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">//谁想访问我，谁就要变成我的友元</span>


<span class="token keyword">void</span> <span class="token function">Func</span><span class="token punctuation">(</span><span class="token keyword">const</span> Date<span class="token operator">&amp;</span> d<span class="token punctuation">,</span> <span class="token keyword">const</span> Time<span class="token operator">&amp;</span> t<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">//既要访问Date的私有，又要访问Time的私有</span>
	cout <span class="token operator">&lt;&lt;</span> d<span class="token punctuation">.</span>_year <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> t<span class="token punctuation">.</span>_hour <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Date d<span class="token punctuation">;</span>
	Time t<span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p><strong>建议：</strong><br/> <strong><font color="red">友元不建议多用，相当于把访问限定开了一个口子，不到万不得已不要用。</font></strong></p>
<hr/>
<h3><a id="42__464"></a>4.2 内部类：</h3>
<p><strong>概念：</strong></p>
<blockquote>
<p><strong>如果一个类定义在另一个类的内部，这个内部类就叫做内部类。</strong> 内部类是一个独立的类，它不属于外部类，更不能通过外部类的对象去访问内部类的成员。外部类对内部类没有任何优越的访问权限。</p>
</blockquote>
<p><strong>注意：</strong></p>
<blockquote>
<p><strong>内部类就是外部类的友元类，参见友元类的定义</strong>，内部类可以通过外部类的对象参数来访问外部类中的所有成员。<strong>但是外部类不是内部类的友元。</strong></p>
</blockquote>
<p><strong>特性：</strong></p>
<ol><li>内部类可以定义在外部类的public、protected、private都是可以的。</li><li><strong>注意内部类可以直接访问外部类中的static成员，不需要外部类的对象 / 类名。</strong></li><li>sizeof(外部类) = 外部类，和内部类没有任何关系。</li></ol>
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span> 
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token comment">//不算大小</span>
	<span class="token keyword">static</span> <span class="token keyword">int</span> k<span class="token punctuation">;</span>
	<span class="token keyword">int</span> h<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token comment">//A类里面没有一个B对象</span>
	
	<span class="token comment">//内部类</span>
	<span class="token comment">//B天生就是A的友元</span>
	<span class="token keyword">class</span> <span class="token class-name">B</span> 
	<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">public</span><span class="token operator">:</span>
		<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">const</span> A<span class="token operator">&amp;</span> a<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			cout <span class="token operator">&lt;&lt;</span> k <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">//OK</span>
			cout <span class="token operator">&lt;&lt;</span> a<span class="token punctuation">.</span>h <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">//OK</span>
		<span class="token punctuation">}</span>
	<span class="token keyword">private</span><span class="token operator">:</span>
		<span class="token keyword">int</span> _b<span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>

	<span class="token comment">A不是B的友元</span>
	<span class="token comment">//void Print(const B&amp; b)</span>
	<span class="token comment">//{<!-- --></span>
	<span class="token comment">//	b._b = 0;</span>
	<span class="token comment">//}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> A<span class="token double-colon punctuation">::</span>k <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">//用B类型定义一个对象 - 去A这个类域里面找B这个类型</span>
	<span class="token comment">//将内部类放在私有里面这个类就是专属的类，在类外面用不了</span>
	A<span class="token double-colon punctuation">::</span>B b<span class="token punctuation">;</span>
	b<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">//算这个类型的本质是算，这个类型定义的对象的大小</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p><strong><font color="red">公布答案：</font></strong></p>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/a8261496e2754e8aa09719038931568a.png#picf_center"/><br/> <strong><font color="purple">sizeof(A)讲解：</font></strong></p>
<ul><li>A类里面没有一个B对象，虽然是内部类</li><li>static 的成员变量也不算大小，因为计算大小算的是，类创造对象的大小，而static在静态区，不算在类所创造的对象里面，类创造的任何对象都能访问，指定类域也能访问</li><li>所以只有一个int的成员</li><li>所以大小是4</li></ul>
</div>
<link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css" rel="stylesheet"/>
<link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css" rel="stylesheet"/>
</div>