<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="markdown_views prism-atom-one-light" id="content_views">
<svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
<path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
</svg>
<p></p>
<div class="toc">
<h3>文章目录</h3>
<ul><li><a href="#_4">效果展示</a></li><li><ul><li><a href="#1__maven__16">1. 创建 maven 项目</a></li><li><a href="#2__23">2. 设计数据库</a></li><li><a href="#3__69">3. 封装数据库的操作代码</a></li><li><ul><li><a href="#31__DBUtil__71">3.1 创建 DBUtil 类</a></li><li><a href="#32__Blog_143">3.2 创建 Blog（代表一篇博客）</a></li><li><a href="#33__User_206">3.3 创建 User（代表一个用户）</a></li><li><a href="#34__BlogDao_240">3.4 创建类 BlogDao（对博客表进行操作）</a></li><li><a href="#35__UserDao__383">3.5 创建类 UserDao (对用户表进行操作)</a></li></ul>
</li><li><a href="#4__463">4. 导入之前已经写好的前端代码</a></li><li><a href="#5__466">5. 实现博客主页界面</a></li><li><ul><li><a href="#51__467">5.1 约定好前后端交互接口</a></li><li><a href="#52__BlogServlet_470">5.2 实现 BlogServlet</a></li><li><a href="#53___503">5.3 实现 前端代码</a></li></ul>
</li><li><a href="#6__560">6. 实现博客详情界面</a></li><li><ul><li><a href="#61__561">6.1 约定好前后端交互接口</a></li><li><a href="#62_BlogServlet_565">6.2 实现BlogServlet</a></li><li><a href="#63__617">6.3 实现前端代码</a></li></ul>
</li><li><a href="#7___664">7. 实现登录界面</a></li><li><ul><li><a href="#71__671">7.1 约定好前后端交互接口</a></li><li><a href="#72__LoginServlet_675">7.2 实现 LoginServlet</a></li><li><a href="#73__729">7.3 实现前端代码</a></li></ul>
</li><li><a href="#8__789">8. 实现登录状态判定功能</a></li><li><ul><li><a href="#81__792">8.1 约定前后端交互接口</a></li><li><a href="#82__LoginServlet__798">8.2 在 LoginServlet 进行代码添加</a></li><li><a href="#83__commonjs_881">8.3 在前端代码中创建 common.js</a></li><li><a href="#84__915">8.4 修改前端代码</a></li></ul>
</li><li><a href="#9__922">9. 实现显示用户信息功能</a></li><li><ul><li><a href="#91__923">9.1 约定好前后端交互接口</a></li><li><a href="#92__AuthorServlet__924">9.2 实现 AuthorServlet 代码</a></li><li><a href="#93__986">9.3 实现前端代码</a></li><li><ul><li><a href="#_989">针对博客列表页进行修改</a></li><li><a href="#_995">针对博客详情页</a></li></ul>
</li></ul>
</li><li><a href="#10__1003">10. 实现注销功能</a></li><li><ul><li><a href="#101__1005">10.1 约定好前后端交互接口</a></li><li><a href="#102__LogouServlet_1008">10.2 实现 LogouServlet</a></li><li><a href="#103__1036">10.3 实现前端代码</a></li></ul>
</li><li><a href="#11__1042">11. 实现发布博客功能</a></li><li><ul><li><a href="#111__1046">11.1 约定好前后端交互的接口</a></li><li><a href="#112_BlogServletdoPost_1050">11.2 在BlogServlet中添加doPost方法</a></li><li><a href="#113__1093">11.3 实现前端代码</a></li></ul>
</li><li><a href="#12__1166">12. 删除博客</a></li><li><ul><li><a href="#121__1168">12.1 约定号前后端交互接口</a></li><li><a href="#121__1172">12.1 实现前端代码</a></li><li><a href="#122_BlogDeleteServlet_1269">12.2 实现BlogDeleteServlet</a></li></ul>
</li></ul>
</li></ul>
</div>
<p></p>
<h1><a id="_4"></a>效果展示</h1>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/bfae7decc80448c4836099813d9a60f8.png"/></p>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/3472e61e46c44b80939e7c85e3129637.png"/></p>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/cc53bd380da54f85915f58ded0a3ee70.png"/></p>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/2321e25616f54197bb7369538b83cc22.png"/></p>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/64ec1703628b443b9ce78c82733916cd.png"/></p>
<hr/>
<h2><a id="1__maven__16"></a>1. 创建 maven 项目</h2>
<p>创建<strong>必要的目录</strong>，引入<strong>需要的依赖</strong></p>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/0de06631b6214d579d07874b07eedc23.png"/><br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/4cb8941cd4fa49edae5a48c1fdef986b.png"/><br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/c0da0691c0da48c680fb71af3651058f.png"/></p>
<h2><a id="2__23"></a>2. 设计数据库</h2>
<p>本系统要存入<font color="purple">博客文章的信息</font>和<font color="purple">用户的信息</font></p>
<p>创建博客表：</p>
<blockquote>
<p><code>博客的 id，博客的标题，博客的内容，博客的日期，博文的博主 id</code></p>
</blockquote>
<p>创建用户表：</p>
<blockquote>
<p><code>用户 id 用户名 用户密码</code></p>
</blockquote>
<pre><code>-- 创建一个数据库
create database if not exists java102_blog;

use java102_blog;

-- 创建一个博客表.
drop table if exists blog;
create table blog (
    blogId int primary key auto_increment,
    title varchar(1024),
    content mediumtext,
    userId int,         -- 文章作者的 id
    postTime datetime   -- 发布时间
);

---- 给博客表中插入点数据, 方便测试.
insert into blog values(null, '这是第一篇博客', '从今天开始, 我要认真学 Java', 1, now());
insert into blog values(null, '这是第二篇博客', '从昨天开始, 我要认真学 Java', 1, now());
insert into blog values(null, '这是第三篇博客', '从前天开始, 我要认真学 Java', 1, now());
insert into blog values(null, '这是第一篇博客', '从今天开始, 我要认真学 C++', 2, now());
insert into blog values(null, '这是第二篇博客', '从昨天开始, 我要认真学 C++', 2, now());
insert into blog values(null, '这是第三篇博客', '# 一级标题\n ### 三级标题\n &gt; 这是引用内容', 2, now());

-- 创建一个用户表
drop table if exists user;
create table user (
    userId int primary key auto_increment,
    username varchar(128) unique,    -- 后续会使用用户名进行登录, 一般用于登录的用户名都是不能重复的.
    password varchar(128)
);

insert into user values(null, 'zhangsan', '123');
insert into user values(null, 'lisi', '123');
insert into user values(null, 'ling', '123');
</code></pre>
<h2><a id="3__69"></a>3. 封装数据库的操作代码</h2>
<p>创建包 model 用来存放数据库的代码</p>
<h3><a id="31__DBUtil__71"></a>3.1 创建 DBUtil 类</h3>
<p>用于和数据库建立连接</p>
<pre><code>package model;

import com.mysql.cj.jdbc.MysqlDataSource;

import javax.sql.DataSource;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

/**
 *这个类 封装 和 建立 数据库 连接 的 操作
 */
public class DBUtil {
    private static final String URL = "jdbc:mysql://127.0.0.1:3306/java102_blog?characterEncoding=utf8&amp;useSSL=false";
    private static final String USERNAME = "root";
    private static final String PASSWORD = "707703";

    private volatile static DataSource dataSource = null;

    private static DataSource getDataSource() {
        if(dataSource == null) {
            synchronized (DBUtil.class) {
                if(dataSource == null) {
                    dataSource = new MysqlDataSource();
                    ((MysqlDataSource)dataSource).setUrl(URL);
                    ((MysqlDataSource)dataSource).setUser(USERNAME);
                    ((MysqlDataSource)dataSource).setPassword(PASSWORD);
                }
            }
        }
        return dataSource;
    }

    // 建立链接
    public static Connection getConnection() throws SQLException {
        return getDataSource().getConnection();
    }

    // 断开链接
    public static void close(Connection connection, PreparedStatement statement, ResultSet resultSet)  {
        if(resultSet != null) {
            try {
                resultSet.close();
            } catch (SQLException throwables) {
                throwables.printStackTrace();
            }
        }

        if(statement != null) {
            try {
                statement.close();
            } catch (SQLException throwables) {
                throwables.printStackTrace();
            }
        }

        if(connection != null) {
            try {
                connection.close();
            } catch (SQLException throwables) {
                throwables.printStackTrace();
            }
        }
    }
}


</code></pre>
<h3><a id="32__Blog_143"></a>3.2 创建 Blog（代表一篇博客）</h3>
<pre><code>package model;

import java.sql.Timestamp;
import java.text.SimpleDateFormat;

// 每个 blog对象 ，对应 blog 表里的一条记录
public class Blog {
    private int blogId;
    private String title;
    private String content;
    private int userId;
    private Timestamp postTime;

    public int getBlogId() {
        return blogId;
    }

    public void setBlogId(int blogId) {
        this.blogId = blogId;
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public String getContent() {
        return content;
    }

    public void setContent(String content) {
        this.content = content;
    }

    public int getUserId() {
        return userId;
    }

    public void setUserId(int userId) {
        this.userId = userId;
    }
    
    // 把这里 的 getter 方法给改了，不是返回一个 时间搓对象，而是返回一个 string（格式化的时间）
    public String getPostTime() {
        // 使用这个类 来完成时间戳到格式化日期的转换
        // 这个 转换过程，需要构造方法中制定要转换的格式，然后调用 format 来进行转换
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        return simpleDateFormat.format(postTime);
    }


    public void setPostTime(Timestamp postTime) {
        this.postTime = postTime;
    }
}

</code></pre>
<h3><a id="33__User_206"></a>3.3 创建 User（代表一个用户）</h3>
<pre><code>package model;

// 每个 model.User 对象, 期望能够表示 user 表中的一条记录.
public class User {
    private int userId = 0;
    private String username = "";
    private String password = "";
    public int getUserId() {
        return userId;
    }

    public void setUserId(int userId) {
        this.userId = userId;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }
}
</code></pre>
<h3><a id="34__BlogDao_240"></a>3.4 创建类 BlogDao（对博客表进行操作）</h3>
<p><strong>注意：</strong><br/> <strong>对数据进行插入删除操作时，执行 sql：</strong><br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/a1bbde23c62d4c4c9421645c09e2ccf6.png"/><br/> <strong>其他操作：</strong><br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/8313a3bd4eab458ba7a3fd46ec76a0af.png"/><br/> <strong>插入顺序：</strong><br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/c37c0fbe85e24428bfc05baa8c3ad084.png"/></p>
<pre><code>package model;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

/**
 * 这个类用于去封装博客表的 基本操作
 */
public class BlogDao {
    // 1.往博客表里，插入一个博客
    public void insert(Blog blog) {
        // JDBC 代码
        Connection connection = null;
        PreparedStatement statement = null;
        try {
            // 1. 先和数据库建立连接
            connection = DBUtil.getConnection();
            // 2. 构造 sql 语句
            String sql = "insert into blog values(null,?,?,?,now())";
            statement = connection.prepareStatement(sql);
            // 赋值
            statement.setString(1, blog.getTitle());
            statement.setString(2, blog.getContent());
            statement.setInt(3,blog.getUserId());
            // 3. 执行 sql
            statement.executeUpdate();
        } catch (SQLException throwables) {
            throwables.printStackTrace();
        }finally {
            // 4. 关闭连接，释放资源
            DBUtil.close(connection,statement,null);
        }
    }

    // 2. 获取博客列表中的所有博客信息
    public List&lt;Blog&gt; selectAll() {
        List&lt;Blog&gt; blogs = new ArrayList&lt;&gt;();
        // JDBC 代码
        Connection connection = null;
        PreparedStatement statement = null;
        ResultSet resultSet = null;
        try {
            // 1. 先建立链接
            connection = DBUtil.getConnection();
            // 2. 构造 sql 语句
            String sql = "select * from blog order by postTime desc";
            statement = connection.prepareStatement(sql);
            // 3. 执行 sql
            resultSet = statement.executeQuery();
            // 把查询到的数据 存储到 blogs 当中
            while (resultSet.next()) {
                Blog blog = new Blog();
                blog.setBlogId(resultSet.getInt("blogId"));
                blog.setTitle(resultSet.getString("title"));
                // 这里需要针对内容进行截断（太长，就去掉后面的）
                String content = resultSet.getString("content");
                if(content.length() &gt; 50) {
                    content = content.substring(0,50) + "..点进来吧我的宝";
                }
                blog.setContent(content);
                blog.setUserId(resultSet.getShort("userId"));
                blog.setPostTime(resultSet.getTimestamp("postTime"));
                blogs.add(blog);
            }
        } catch (SQLException throwables) {
            throwables.printStackTrace();
        }finally {
            DBUtil.close(connection,statement,resultSet);
        }
        return blogs;
    }

    // 3. 能够根据博客 id 获取到制定的博客内容（用于博客详情页）
    public Blog selectOne(int blogId) {
        Connection connection = null;
        PreparedStatement statement = null;
        ResultSet resultSet = null;
        try{
            // 1. 建立连接
            connection = DBUtil.getConnection();
            // 2. 构造 sql 语句
            String sql = "select * from blog where blogId = ?";
            statement = connection.prepareStatement(sql);
            statement.setInt(1,blogId);
            // 3. 执行 sql
            resultSet = statement.executeQuery();
            // 此处我们是使用 主键 来作为 查询条件，查询结果，要么是 1，要么是 0
            if(resultSet.next()) {
                Blog blog = new Blog();
                blog.setBlogId(resultSet.getInt("blogId"));
                blog.setTitle(resultSet.getString("title"));
                blog.setContent(resultSet.getString("content"));
                blog.setUserId(resultSet.getShort("userId"));
                blog.setPostTime(resultSet.getTimestamp("postTime"));
                return blog;
            }
        } catch (SQLException throwables) {
            throwables.printStackTrace();
        }finally {
            // 4. 关闭连接 释放资源
            DBUtil.close(connection,statement,resultSet);
        }
        return null;
    }

    // 4.  从博客列表中，根据博客 id 删除博客
    public void delete(int blogId) {
        Connection connection = null;
        PreparedStatement statement = null;
        try {
            // 1. 建立 连接
            connection = DBUtil.getConnection();
            // 2. 构造 sql 语句
            String sql = "delete from blog where blogId = ？";
            statement = connection.prepareStatement(sql);
            statement.setInt(1,blogId);
            // 3. 执行 sql
            statement.executeUpdate();
        } catch (SQLException throwables) {
            throwables.printStackTrace();
        }finally {
            DBUtil.close(connection,statement,null);
        }
    }
}

</code></pre>
<h3><a id="35__UserDao__383"></a>3.5 创建类 UserDao (对用户表进行操作)</h3>
<pre><code>package model;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

/**
 * 这个类用于 封装 用户表的 基本操作
 */
public class UserDao {

    // 1. 根据用户名 查找用户信息
    public User selectByName(String username) {
        Connection connection = null;
        PreparedStatement statement = null;
        ResultSet resultSet = null;
        try{
            // 1. 建立 连接
            connection = DBUtil.getConnection();
            // 2. 构造 sql 语句
            String sql = "select * from user where username = ?";
            statement = connection.prepareStatement(sql);
            statement.setString(1,username);
            // 3. 执行 sql
            resultSet = statement.executeQuery();
            if(resultSet.next()) {
                User user = new User();
                user.setUserId(resultSet.getInt("userId"));
                user.setUsername(resultSet.getString("username"));
                user.setPassword(resultSet.getString("password"));
                return user;
            }
        } catch (SQLException throwables) {
            throwables.printStackTrace();
        }finally {
            // 4. 关闭连接 释放资源
            DBUtil.close(connection,statement,resultSet);
        }
        return null;
    }

    // 2. 根据 用户 id 来找 用户信息
    // 博客详情页 就可以根据用户 id 来查询作者的名字，把作者名字显示出来
    public User selectById(int userId) {
        Connection connection = null;
        PreparedStatement statement = null;
        ResultSet resultSet = null;

        try {
            // 1. 建立连接
            connection = DBUtil.getConnection();
            // 2. 构造 sql 语句
            String sql = "select * from user where userId = ?";
            statement = connection.prepareStatement(sql);
            statement.setInt(1,userId);
            // 3. 执行sql
            resultSet = statement.executeQuery();
            // 此处的 username 使用 unique 约束，要么能查到一个，要么一个都查不到
            // 4. 遍历结果集
            if(resultSet.next()) {
                User user = new User();
                user.setUserId(resultSet.getInt("userId"));
                user.setUsername(resultSet.getString("username"));
                user.setPassword(resultSet.getString("password"));
                return user;
            }
        } catch (SQLException throwables) {
            throwables.printStackTrace();
        }finally {
            DBUtil.close(connection,statement,resultSet);
        }
        return null;
    }
}


</code></pre>
<h2><a id="4__463"></a>4. 导入之前已经写好的前端代码</h2>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/bf41afd9576f4c1091b76c653e989665.png"/></p>
<h2><a id="5__466"></a>5. 实现博客主页界面</h2>
<h3><a id="51__467"></a>5.1 约定好前后端交互接口</h3>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/bde0824166f44e669a30868db7b46cbe.png"/></p>
<h3><a id="52__BlogServlet_470"></a>5.2 实现 BlogServlet</h3>
<pre><code>import model.BlogDao;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.List;

// 通过这个类, 来处理 /blog 路径对应的请求
@WebServlet("/blog")
public class BlogServlet extends HttpServlet {
    private ObjectMapper objectMapper = new ObjectMapper();

    // 这个方法用来获取到数据库中的博客列表.
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {

        // 从数据库中查询到博客列表, 转成 JSON 格式, 然后直接返回即可.
        BlogDao blogDao = new BlogDao();
        List&lt;Blog&gt; blogs = blogDao.selectAll();
         //把 blogs 对象转成 JSON 格式.
        String respJson = objectMapper.writeValueAsString(blogs);
        resp.setContentType("application/json; charset=utf8");
        resp.getWriter().write(respJson);
    }
}
</code></pre>
<h3><a id="53___503"></a>5.3 实现 前端代码</h3>
<p><strong>在 blog_list.html 中 实现 ajax</strong></p>
<p><strong>注意：引入依赖</strong></p>
<pre><code>&lt;script src="http://libs.baidu.com/jquery/2.0.0/jquery.min.js"&gt;&lt;/script&gt;
    &lt;script&gt;
        // 在页面加载的时候, 通过 ajax 给服务器发送数据, 获取到博客列表信息, 并且显示在界面上. 
        function getBlogList() {
            $.ajax({
                type: 'get',
                url: 'blog',
                success: function(body) {
                    // 获取到的 body 就是一个 js 对象数组, 每个元素就是一个 js 对象, 根据这个对象构造 div
                    // 1. 先把 .right 里原有的内容给清空
                    let rightDiv = document.querySelector('.right');
                    rightDiv.innerHTML = '';
                    // 2. 遍历 body, 构造出一个个的 blogDiv
                    for (let blog of body) {
                        let blogDiv = document.createElement('div');
                        blogDiv.className = 'blog';
                        // 构造标题
                        let titleDiv = document.createElement('div');
                        titleDiv.className = 'title';
                        titleDiv.innerHTML = blog.title;
                        blogDiv.appendChild(titleDiv);
                        // 构造发布时间
                        let dateDiv = document.createElement('div');
                        dateDiv.className = 'date';
                        dateDiv.innerHTML = blog.postTime;
                        blogDiv.appendChild(dateDiv);
                        // 构造博客的摘要
                        let descDiv = document.createElement('div');
                        descDiv.className = 'desc';
                        descDiv.innerHTML = blog.content;
                        blogDiv.appendChild(descDiv);
                        // 构造 查看全文
                        let a = document.createElement('a');
                        a.innerHTML = '查看全文 &amp;gt;&amp;gt;';
                        // 此处希望点击之后能够跳转到 博客详情页 !!
                        // 这个跳转过程需要告知服务器要访问的是哪个博客的详情页. 
                        a.href = 'blog_detil.html?blogId=' + blog.blogId;
                        blogDiv.appendChild(a);

                        // 把 blogDiv 挂到 dom 树上!
                        rightDiv.appendChild(blogDiv);
                    }
                }, 
                error: function() {
                    alert("获取博客列表失败!");
                }
            });
        }

        getBlogList();
        &lt;/script&gt;
</code></pre>
<h2><a id="6__560"></a>6. 实现博客详情界面</h2>
<h3><a id="61__561"></a>6.1 约定好前后端交互接口</h3>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/16695162a4fe40fa8f3d90432fbaf782.png"/></p>
<h3><a id="62_BlogServlet_565"></a>6.2 实现BlogServlet</h3>
<p><strong>这里后端代码和博客列表页的获取，基本相同，就直接放到一个方法中，来实现！使用blogId参数来区别是获取博客列表还是详情</strong><br/> <strong>这里注意：博客列表页在也在BlogServlet中实现的，我们如何去区别呢？：</strong><br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/455eb5fe13be4cb2b447261868a45795.png"/></p>
<pre><code>package controller;

import com.fasterxml.jackson.databind.ObjectMapper;
import model.Blog;
import model.BlogDao;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.List;

/**
 * // doGet 获取博客列表页
 */
@WebServlet("/blog")
public class BlogServlet extends HttpServlet {

    private ObjectMapper objectMapper = new ObjectMapper();

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        resp.setContentType("application/json; charset=utf8");
        BlogDao blogDao = new BlogDao();
        // 先尝试获取到 req 中的 blogId 参数. 如果该参数存在, 说明是要请求博客详情
        // 如果该参数不存在, 说明是要请求博客的列表.
        String param = req.getParameter("blogId");
        if (param == null) {
            // 不存在参数, 获取博客列表
            List&lt;Blog&gt; blogs = blogDao.selectAll();
            // 把 blogs 对象转成 JSON 格式.
            String respJson = objectMapper.writeValueAsString(blogs);
            resp.getWriter().write(respJson);
        } else {
            // 存在参数, 获取博客详情
            int blogId = Integer.parseInt(param);
            Blog blog = blogDao.selectOne(blogId);
            String respJson = objectMapper.writeValueAsString(blog);
            resp.getWriter().write(respJson);
        }
    }
}

</code></pre>
<h3><a id="63__617"></a>6.3 实现前端代码</h3>
<p><strong>修改 <code>blog_detail.html</code>，让这个页面加载的时候，能够调用到上述的接口，来从服务器获取到博客数据</strong></p>
<p><strong>注意：</strong><br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/60fef7d5d57a43f89c4da023bc31ee12.png"/></p>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/e19af2e1a8d844c3a4718b9825c96b5d.png"/></p>
<blockquote>
<p><code> 在博客详情页中引入 editor</code></p>
</blockquote>
<hr/>
<pre><code>&lt;script&gt;
       
       function getBlogDetail() {
            $.ajax({
                type: 'get',
                // location.search 拿到了形如 '?blogId=5' 这样的一段内容
                url: 'blog2' + location.search,
                success: function(body) {
                    // 根据 body 中的内容来构造页面
                    
                    // 1. 构造博客标题S
                    let h3 = document.querySelector(".blog-content&gt;h3");
                    h3.innerHTML = body.title;
                    // 2. 构造博客发布时间
                    let dateDiv = document.querySelector('.date');
                    dateDiv.innerHTML = body.postTime;
                    // 3. 构造博客正文
                    // 如果直接把 content 设为 innerHTML, 此时展示在界面上的内容, 是原始的 markdown 字符串
                    // 咱们需要的是渲染后的, 带有格式的效果
                    // let content = document.querySelector('#content');
                    // content.innerHTML = body.content;

                    // 第一个参数对应 id=content 的 html 标签. 渲染后得到的 html 片段就会被放到这个 标签下. 
                    editormd.markdownToHTML('content', {
                        markdown: body.content
                    });
                }
            });
        }

        getBlogDetail();


    &lt;/script&gt;
</code></pre>
<h2><a id="7___664"></a>7. 实现登录界面</h2>
<p><strong>这里需要注意：啥样才算是已经登录</strong></p>
<blockquote>
<p><strong>用户有一个 session，同时 session 有一个 user 属性 ~<br/> 两者同时具备，才叫登录状态</strong></p>
</blockquote>
<p><strong>这里先给注销做铺垫：理解一下注销是如何操作的：</strong></p>
<blockquote>
<p><strong>注销只要破坏掉上面的任意一个条件就行了</strong></p>
</blockquote>
<h3><a id="71__671"></a>7.1 约定好前后端交互接口</h3>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/df75f1cc7c4d4ca58997be85bffc9841.png"/></p>
<h3><a id="72__LoginServlet_675"></a>7.2 实现 LoginServlet</h3>
<pre><code>package controller;

import com.fasterxml.jackson.databind.ObjectMapper;
import model.User;
import model.UserDao;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import java.io.IOException;


// 实现登录页面
@WebServlet("/login")
public class LoginServlet extends HttpServlet {
    private  ObjectMapper objectMapper = new ObjectMapper();

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        req.setCharacterEncoding("utf-8");
        resp.setCharacterEncoding("utf-8");
        // 1. 获取到请求中的参数
        String username = req.getParameter("username");
        String password = req.getParameter("password");
        if(username == null || "".equals(username) || password == null || "".equals(password)) {
            // 请求内容缺失，登录失败
            resp.setContentType("text/html; charset=utf8");
            resp.getWriter().write("当前的用户名或者密码为空");
            return;
        }
        // 2. 和数据库中的的内容进行比较
        UserDao userDao = new UserDao();
        User user = userDao.selectByName(username);
        if(user == null || !user.getPassword().equals(password)) {
            // 用户没有查到或者密码不匹配，登录失败
            resp.setContentType("text/html;charset=utf8");
            resp.getWriter().write("用户名或密码错误");
            return;
        }
        // 3. 如果比较通过，则创建会话
        HttpSession session = req.getSession(true);
        // 把刚才的用户信息，存储到会话中
        session.setAttribute("user",user);

        // 4. 返回一个重定向报文，跳转到博客列表页
        resp.sendRedirect("blog_list.html");
    }
 }
</code></pre>
<h3><a id="73__729"></a>7.3 实现前端代码</h3>
<p><strong>修改</strong><code>blog_login.html </code><strong>这里只需要在原来登录操作上套上一层 form 标签就可以了</strong><br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/a9c80c8d817243a1848e570b0813c701.png"/></p>
<p><strong>因为这里在原有的基础上填上了 form表单，我们在 css 中也会有一些改动</strong></p>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/3b024b0024de4c478e5d1d37a1dbeeb2.png"/></p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;登录页面&lt;/title&gt;
    &lt;link rel="stylesheet" href="css/common.css"&gt;
    &lt;link rel="stylesheet" href="css/blog_login.css"&gt;
&lt;/head&gt;
&lt;body&gt;
     &lt;!--这是导航栏 nav--&gt;
     &lt;div class = "nav"&gt;
        &lt;img src="imge/ph.png" alt=""&gt;
        &lt;!--标题 span--&gt;
        &lt;span&gt;我的博客系统&lt;/span&gt;
       &lt;!--这是一个空白元素用来占位置--&gt;
        &lt;div class="spacer"&gt;&lt;/div&gt;
        &lt;!--链接标签&lt;a&gt;--&gt;
        &lt;a href="blog_list.html"&gt;主页&lt;/a&gt;
        &lt;a href="blog_edit.html"&gt;写博客&lt;/a&gt;
        &lt;!--# 空链接--&gt; &lt;!--注销没必要显示在登录页面--&gt;&gt;
        &lt;!-- &lt;a href="#"&gt;注销&lt;/a&gt; --&gt;
    &lt;/div&gt;
    &lt;div class="login-container"&gt;


        &lt;form action="login" method="post"&gt;
            &lt;!--空白页--&gt;
        &lt;div class="login-dialog"&gt;
            &lt;h3&gt;登录&lt;/h3&gt;
            &lt;div class="row"&gt; &lt;!--一行--&gt;
                &lt;span&gt;用户名&lt;/span&gt;
                &lt;input type="text" id="username" name="username"&gt;
            &lt;/div&gt;
            &lt;div class="row"&gt;
                &lt;span&gt;密码&lt;/span&gt;
                &lt;input type="password" id="password" name="password"&gt;
            &lt;/div&gt;
            &lt;div class="row"&gt;
                &lt;!-- &lt;button&gt;提交&lt;/button&gt; --&gt;
                &lt;input type="submit" id="submit" value="提交"&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;/form&gt;

        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2><a id="8__789"></a>8. 实现登录状态判定功能</h2>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/6e1ee60c6a5d4bbfa6ad40d3637b16e9.png"/></p>
<h3><a id="81__792"></a>8.1 约定前后端交互接口</h3>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/a5057a18d3ce42fab838adb187d08675.png"/></p>
<h3><a id="82__LoginServlet__798"></a>8.2 在 LoginServlet 进行代码添加</h3>
<pre><code>package controller;

import com.fasterxml.jackson.databind.ObjectMapper;
import model.User;
import model.UserDao;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import java.io.IOException;


// 实现登录页面
@WebServlet("/login")
public class LoginServlet extends HttpServlet {
    private  ObjectMapper objectMapper = new ObjectMapper();

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        req.setCharacterEncoding("utf-8");
        resp.setCharacterEncoding("utf-8");
        // 1. 获取到请求中的参数
        String username = req.getParameter("username");
        String password = req.getParameter("password");
        if(username == null || "".equals(username) || password == null || "".equals(password)) {
            // 请求内容缺失，登录失败
            resp.setContentType("text/html; charset=utf8");
            resp.getWriter().write("当前的用户名或者密码为空");
            return;
        }
        // 2. 和数据库中的的内容进行比较
        UserDao userDao = new UserDao();
        User user = userDao.selectByName(username);
        if(user == null || !user.getPassword().equals(password)) {
            // 用户没有查到或者密码不匹配，登录失败
            resp.setContentType("text/html;charset=utf8");
            resp.getWriter().write("用户名或密码错误");
            return;
        }
        // 3. 如果比较通过，则创建会话
        HttpSession session = req.getSession(true);
        // 把刚才的用户信息，存储到会话中
        session.setAttribute("user",user);

        // 4. 返回一个重定向报文，跳转到博客列表页
        resp.sendRedirect("blog_list.html");
    }


 //   //  这个方法用来让前端检测当前的登录状态~~~~~~~~~~~~~~~~~~~~~~
    // 1）检测有无会话 2）检测有无属性
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
       resp.setContentType("application/json;charset=utf8");
       HttpSession session =  req.getSession(false);

       if(session == null) {
           // 1) 检测有无会话，无说明未登录
           // 创建对象--&gt; 里面为空
           User user = new User();
           resp.getWriter().write(objectMapper.writeValueAsString(user));
           return;
       }
       User user = (User) session.getAttribute("user");
       if(user == null) {
           // 2)虽然有会话，但是会话里如果没有 user 对象，也视为未登录
           user = new User();
           resp.getWriter().write(objectMapper.writeValueAsString(user));
           return;
       }
       // 已经登录的状态！
        // 注意，此处不要把密码返回到前端
        user.setPassword("");
        resp.getWriter().write(objectMapper.writeValueAsString(user));
    }
}

</code></pre>
<h3><a id="83__commonjs_881"></a>8.3 在前端代码中创建 common.js</h3>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/931e2566441441b487a9dfd41978da03.png"/></p>
<pre><code>// 这个文件里放一些 页面公共的代码
// 加上一个逻辑，通过 GET/login 这个接口来获取下当前的登录状态
function getUserInfo() {
    $.ajax({
        type: 'get',
        url: 'login',
        success: function(body) {
            // 判定此处的 body 是不是一个有效的 user 对象（userId 是否非 0）
            if(body.userId &amp;&amp; body.userId &gt;0) {
                // 登录成功
                // 不做处理
                console.log("当前用户登录成功！用户名：" + body.username);
            }else{
                // 登录失败
                // 让前端页面，跳转到 login.html
                alert("当前你尚未登录！请登录后再访问博客列表！");
                location.assign('blog_login.html');
            }
        },
        error: function() {
            alert("当前你尚未登录！请登录后再访问博客列表！");
                location.assign('blog_login.html');
        }
    });
    

}
getUserInfo();
</code></pre>
<h3><a id="84__915"></a>8.4 修改前端代码</h3>
<blockquote>
<p>在 <code>blog_list.html</code> <code>blog_detil.html</code> 中引入 js文件，就可以执行到里面的代码，也就进行了登录状态的监测了</p>
</blockquote>
<pre><code> &lt;script src="js/commom.js"&gt;&lt;/script&gt;
</code></pre>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/51a789b8c1e141eab9b357b938690a84.png"/><br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/18fba5877c4d438f9a52c6724cf25157.png"/></p>
<h2><a id="9__922"></a>9. 实现显示用户信息功能</h2>
<h3><a id="91__923"></a>9.1 约定好前后端交互接口</h3>
<h3><a id="92__AuthorServlet__924"></a>9.2 实现 AuthorServlet 代码</h3>
<pre><code>package controller;

import com.fasterxml.jackson.databind.ObjectMapper;
import model.Blog;
import model.BlogDao;
import model.User;
import model.UserDao;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;


/**
 * 根据博客 id 查 博客信息
 * 根据 博客信息里的 作者 id 查 作者信息
 */
@WebServlet("/authorInfo")
public class AuthorServlet  extends HttpServlet {
    private ObjectMapper objectMapper = new ObjectMapper();

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        resp.setContentType("application/json; charset=utf8");
        // 通过这个方法, 来获取到指定的博客的作者信息.
        String param = req.getParameter("blogId");
        if (param == null || "".equals(param)) {
            // 参数缺少了.
            resp.getWriter().write("{ \"ok\": false, \"reason\": \"参数缺失!\" }");
            return;
        }

        // 根据当前 blogId 在数据库中进行查找, 找到对应的 Blog 对象, 再进一步的根据 blog 对象, 找到作者信息.
        BlogDao blogDao = new BlogDao();
        Blog blog = blogDao.selectOne(Integer.parseInt(param));
        if (blog == null) {
            resp.getWriter().write("{ \"ok\": false, \"reason\": \"要查询的博客不存在!\" }");
            return;
        }

        // 根据 blog 对象, 查询到用户对象
        UserDao userDao = new UserDao();
        User author = userDao.selectById(blog.getUserId());
        if (author == null) {
            resp.getWriter().write("{ \"ok\": false, \"reason\": \"要查询的用户不存在!\" }");
            return;
        }

        // 把 author 返回到浏览器这边
        // 注意要把密码给干掉!
        author.setPassword("");
        resp.getWriter().write(objectMapper.writeValueAsString(author));

    }
}

</code></pre>
<h3><a id="93__986"></a>9.3 实现前端代码</h3>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/298b0b316eca4042a7b47e82a2141f79.png"/></p>
<h4><a id="_989"></a>针对博客列表页进行修改</h4>
<p><strong>在 common.js 中 修改代码</strong><br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/c3484cc769c84bdda9b32af1f8aada23.png"/></p>
<h4><a id="_995"></a>针对博客详情页</h4>
<pre><code>
</code></pre>
<h2><a id="10__1003"></a>10. 实现注销功能</h2>
<p><strong>在导航栏中安排一个“注销”按钮，当用户点击注销之后，就会在服务器上取消登录状态，并且能够跳转到登录页面</strong></p>
<h3><a id="101__1005"></a>10.1 约定好前后端交互接口</h3>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/e68a3892acc647aeb1525fa7bb3e80be.png"/></p>
<h3><a id="102__LogouServlet_1008"></a>10.2 实现 LogouServlet</h3>
<pre><code>package controller;

import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.*;
import java.io.IOException;
import java.util.Enumeration;

@WebServlet("/logout")
public class LogoutServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
            // 先找到当前用户的会话,
            HttpSession session = req.getSession(false);
            if (session == null) {
                // 用户没有登录!! 谈不上注销!
                resp.getWriter().write("当前用户尚未登录! 无法注销!");
                return;
            }
            // 然后把这个用户的会话中的信息给删掉就行了!!
            session.removeAttribute("user");
            resp.sendRedirect("blog_login.html");
        }
}
</code></pre>
<h3><a id="103__1036"></a>10.3 实现前端代码</h3>
<p><strong>将 blog_detail.html blog_list.html bloh_edit.htm中的注销标签进行修改</strong></p>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/774ee468c83e49aabeb95651935c315a.png"/></p>
<h2><a id="11__1042"></a>11. 实现发布博客功能</h2>
<p>在<code>博客编辑页</code>中，当用户输入<code>博客标题</code>，和<code>正文</code>之后，点击<code>发布</code><br/> 此时就会<code>把博客数据提交到服务器，由服务器存储到数据中</code></p>
<h3><a id="111__1046"></a>11.1 约定好前后端交互的接口</h3>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/f2870a2a82a8428d8c4ea24a2a11a3fb.png"/></p>
<h3><a id="112_BlogServletdoPost_1050"></a>11.2 在BlogServlet中添加doPost方法</h3>
<pre><code>@Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        HttpSession session = req.getSession(false);
        if (session == null) {
            // 当前用户未登录, 不能提交博客!
            resp.setContentType("text/html;charset=utf8");
            resp.getWriter().write("当前用户未登录, 不能提交博客!");
            return;
        }
        User user = (User) session.getAttribute("user");
        if (user == null) {
            // 当前用户未登录, 不能提交博客!
            resp.setContentType("text/html;charset=utf8");
            resp.getWriter().write("当前用户未登录, 不能提交博客!");
            return;
        }
        // 一定要先指定好请求按照哪种编码来解析
        req.setCharacterEncoding("utf8");
        // 先从请求中, 取出参数(博客的标题和正文)
        String title = req.getParameter("title");
        String content = req.getParameter("content");
        if (title == null || "".equals(title) || content == null || "".equals(content)) {
            // 直接告诉客户端, 请求参数不对
            resp.setContentType("text/html;charset=utf8");
            resp.getWriter().write("提交博客失败! 缺少必要的参数!");
            return;
        }
        // 构造 Blog 对象, 把当前的信息填进去, 并插入数据库中
        // 此处要给 Blog 设置的属性, 主要是 title, content, userId (作者信息)
        // postTime 和 blogId 都不需要手动指定, 都是插入数据库的时候自动生成的.
        Blog blog = new Blog();
        blog.setTitle(title);
        blog.setContent(content);
        // 作者 id 就是当前提交这个博客的用户的身份信息!!
        blog.setUserId(user.getUserId());
        BlogDao blogDao = new BlogDao();
        blogDao.insert(blog);
        // 重定向到, 博客列表页!
        resp.sendRedirect("blog_list.html");
    }
</code></pre>
<h3><a id="113__1093"></a>11.3 实现前端代码</h3>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/ece70739000d4f8d8ef0cef5e383dd28.png"/><br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/4f39156570f04066a1c5ea645d286b5b.png"/><br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/d509488551d74d769dcfa6d3d3455afe.png"/></p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;博客编辑页&lt;/title&gt;
    &lt;link rel="stylesheet" href="css/common.css"&gt;
    &lt;link rel="stylesheet" href="css/blog_edit.css"&gt;
   

    &lt;!-- 引入 editor.md 的依赖 --&gt;
    &lt;link rel="stylesheet" href="editor.md/css/editormd.min.css" /&gt;
    &lt;script src="js/jquery.min.js"&gt;&lt;/script&gt;
    &lt;script src="editor.md/lib/marked.min.js"&gt;&lt;/script&gt;
    &lt;script src="editor.md/lib/prettify.min.js"&gt;&lt;/script&gt;
    &lt;script src="editor.md/editormd.min.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;!-- 这是导航栏 --&gt;
    &lt;div class="nav"&gt;
        &lt;img src="imge/ph.png" alt=""&gt;
        &lt;span&gt;我的博客系统&lt;/span&gt;
        &lt;!-- 空白元素, 用来占位置 --&gt;
        &lt;div class="spacer"&gt;&lt;/div&gt;
        &lt;a href="blog_list.html"&gt;主页&lt;/a&gt;
        &lt;a href="blog_edit.html"&gt;写博客&lt;/a&gt;
        &lt;a href="logout"&gt;注销&lt;/a&gt;
    &lt;/div&gt;
    &lt;!-- 包裹整个博客编辑页内容的顶级容器 --&gt;
    
    &lt;div class="blog-edit-container"&gt;
        &lt;form action="blog" method="post" style="height: 100%"&gt;
            &lt;div class="title"&gt;
                &lt;input type="text" placeholder="在此处输入标题" name="title"&gt;
                &lt;!-- &lt;button&gt;发布文章&lt;/button&gt; --&gt;
                &lt;input type="submit" value="发布文章" id="submit"&gt;
            &lt;/div&gt;
            &lt;!-- 放置 md 编辑器 --&gt;
            &lt;div id="editor"&gt;
                    &lt;!-- 为了进行 form的提交，此处搞一下 textarea 多行编辑框，借助这个编辑框来实现表单的提交--&gt;
                    &lt;textarea name="content" style="display: none"&gt;&lt;/textarea&gt;
            &lt;/div&gt;
        &lt;/form&gt;
    &lt;/div&gt;




    &lt;script&gt;
        // 初始化编辑器
        let editor = editormd("editor", {
            // 这里的尺寸必须在这里设置. 设置样式会被 editormd 自动覆盖掉. 
            width: "100%",
            // 设定编辑器高度
            height: "calc(100% - 50px)",
            // 编辑器中的初始内容
            markdown: "# 在这里写下一篇博客",
            // 指定 editor.md 依赖的插件路径
            path: "editor.md/lib/",
            // 此处要加上一个重要的选项，然后 editr.md 就会自动把用户在编辑器输入的内容同步保存到 隐藏的 textarea中
            saveHTMLToTextarea:true,
        });
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2><a id="12__1166"></a>12. 删除博客</h2>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/e43f2b6992084b088e4a102854f232fc.png"/></p>
<h3><a id="121__1168"></a>12.1 约定号前后端交互接口</h3>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/2cd2f9264b9f404a9166a44025f02fb9.png"/></p>
<h3><a id="121__1172"></a>12.1 实现前端代码</h3>
<pre><code> &lt;script&gt;
         function getBlogDetail() {
            $.ajax({
                type: 'get',
                // location.search 拿到了形如 '?blogId=5' 这样的一段内容
                url: 'blog' + location.search,
                success: function(body) {
                    // 根据 body 中的内容来构造页面
                    // 1. 构造博客标题
                    let h3 = document.querySelector(".blog-content&gt;h3");
                    h3.innerHTML = body.title;
                    // 2. 构造博客发布时间
                    let dateDiv = document.querySelector('.date');
                    dateDiv.innerHTML = body.postTime;
                    // 3. 构造博客正文
                    // 如果直接把 content 设为 innerHTML, 此时展示在界面上的内容, 是原始的 markdown 字符串
                    // 咱们需要的是渲染后的, 带有格式的效果
                    // let content = document.querySelector('#content');
                    // content.innerHTML = body.content;

                    // 第一个参数对应 id=content 的 html 标签. 渲染后得到的 html 片段就会被放到这个 标签下. 
                    editormd.markdownToHTML('content', {
                        markdown: body.content
                    });
                }
            });
        }   

  // 加上一个逻辑，通过 GET /login 这个接口来获取下当前的登录状态          
    function getUserInfo(pageName) {
        $.ajax({
        type:'get',
        url: 'login',
        success: function(body) {
            // 判断此处的 body 是不是一个有效的user 对象（userId 是否为0）
            if(body.userId &amp;&amp; body.userId &gt; 0) {
                // 登录成功
                // 不做处理
                console.log("当前用户登录成功！用户名：" + body.username);

                // 在getUserInfo 的回调函数中，来调用获取用户信息
                getAuthorInfo(body);

                
            }else {
                // 登录失败
                // 让前端页面，跳转到 login.html
                alert("当前您尚未登录！请登录后再访问博客列表");
                location.assign('blog_login.html');
            }
        },
        error: function() {
            alert("当前您尚未登录！请登录后再访问博客列表");
            location.assign('blog_login.html');
        }
        });
    }
  
    // 判定用户的登录状态
    getUserInfo('blog_detail.html');

     // 从服务器获取一下当前博客的作者信息, 并显示到界面上. 
    // 参数 user 就是刚才从服务器拿到的当前登录用户的信息
    
        function getAuthorInfo(user) {
                $.ajax({
                   type: 'get',
                   url: 'authorInfo' + location.search,
                   success: function(body) {
                       // 此处的body，就是服务器返回的User对象,是文章作者信息
                       if(body.username) {
                            getBlogDetail();
                           changeUserName(body.username);
                           if(body.username == user.username ) {
                               // 作业和登录的用户是一个人，则显示 删除按钮
                               let navDiv = document.querySelector('.nav');
                               let a = document.createElement('a');
                               a.innerHTML = '删除';
                               // 点击删除，构造一个 形如 blogDelete？blogId = 6 这样的请求
                               a.href = 'blogDelete' + location.search;
                               navDiv.appendChild(a);
                           }
                       }else{
                           console.log("获取信息失败" + body.reason);
                       }
                   }
                });
            }

            function changeUserName(username) {
            let h3 = document.querySelector('.card&gt;h3');
            h3.innerHTML = username;
            }     
    &lt;/script&gt;
</code></pre>
<h3><a id="122_BlogDeleteServlet_1269"></a>12.2 实现BlogDeleteServlet</h3>
<pre><code>package controller;

import model.Blog;
import model.BlogDao;
import model.User;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import java.io.IOException;

/**
 * 实现删除功能
 */
@WebServlet("/blogDelete")
public class BlogDeleteServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        // 1. 检查当前用户是否登录
        HttpSession session = req.getSession(false);
        if (session == null) {
            resp.setContentType("text/html; charset=utf8");
            resp.getWriter().write("当前尚未登录, 不能删除!");
            return;
        }
        User user = (User) session.getAttribute("user");
        if (user == null) {
            resp.setContentType("text/html; charset=utf8");
            resp.getWriter().write("当前尚未登录, 不能删除!");
            return;
        }

        // 2. 获取到参数中的 blogId
        String blogId = req.getParameter("blogId");
        if (blogId == null || "".equals(blogId)) {
            resp.setContentType("text/html; charset=utf8");
            resp.getWriter().write("当前 blogId 参数不对!");
            return;
        }

        // 3. 获取要删除的博客信息.
        BlogDao blogDao = new BlogDao();
        Blog blog = blogDao.selectOne(Integer.parseInt(blogId));
        if (blog == null) {
            resp.setContentType("text/html; charset=utf8");
            resp.getWriter().write("当前要删除的博客不存在!");
            return;
        }

        // 4. 再次校验, 当前的用户是否就是博客的作者
        if (user.getUserId() != blog.getUserId()) {
            // 这一点在前端这里其实也处理过~~ 但是此处还是再校验一次, 不是坏事!!!
            resp.setContentType("text/html; charset=utf8");
            resp.getWriter().write("当前登录的用户不是作者, 没有权限删除!");
            return;
        }

        // 5. 确认无误, 开始删除
        blogDao.delete(Integer.parseInt(blogId));

        // 6. 重定向到博客列表页
        resp.sendRedirect("blog_list.html");
    }
    
}


</code></pre>
</div>
<link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css" rel="stylesheet"/>
<link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css" rel="stylesheet"/>
</div>