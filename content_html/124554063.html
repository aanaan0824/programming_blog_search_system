<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<p id="main-toc"><strong>目录</strong></p>
<p id="%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#%E5%89%8D%E8%A8%80">前言</a></p>
<p id="setup%E8%AF%AD%E6%B3%95%E7%B3%96-toc" style="margin-left:0px;"><a href="#setup%E8%AF%AD%E6%B3%95%E7%B3%96">setup语法糖</a></p>
<p id="%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95-toc" style="margin-left:40px;"><a href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95">一、基本用法</a></p>
<p id="%E5%8F%98%E9%87%8F%E5%92%8C%E6%96%B9%E6%B3%95%E4%B8%8D%E9%9C%80%E8%A6%81return-toc" style="margin-left:40px;"><a href="#%E5%8F%98%E9%87%8F%E5%92%8C%E6%96%B9%E6%B3%95%E4%B8%8D%E9%9C%80%E8%A6%81return">二、data和methods</a></p>
<p id="%E4%B8%89%E3%80%81%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7computed-toc" style="margin-left:40px;"><a href="#%E4%B8%89%E3%80%81%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7computed">三、计算属性computed</a></p>
<p id="%E5%9B%9B%E3%80%81%E7%9B%91%E5%90%AC%E5%99%A8watch%E3%80%81watchEffect-toc" style="margin-left:40px;"><a href="#%E5%9B%9B%E3%80%81%E7%9B%91%E5%90%AC%E5%99%A8watch%E3%80%81watchEffect">四、监听器watch、watchEffect</a></p>
<p id="%E4%BA%94%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4directive-toc" style="margin-left:40px;"><a href="#%E4%BA%94%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4directive">五、自定义指令directive</a></p>
<p id="import%E5%AF%BC%E5%85%A5%E7%9A%84%E5%86%85%E5%AE%B9%E5%8F%AF%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px;"><a href="#import%E5%AF%BC%E5%85%A5%E7%9A%84%E5%86%85%E5%AE%B9%E5%8F%AF%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8">六、import导入的内容可直接使用</a></p>
<p id="%E5%A3%B0%E6%98%8Eprops%E5%92%8Cemits%C2%A0-toc" style="margin-left:40px;"><a href="#%E5%A3%B0%E6%98%8Eprops%E5%92%8Cemits%C2%A0">七、声明props和emits </a></p>
<p id="%E7%88%B6%E7%BB%84%E4%BB%B6%E8%8E%B7%E5%8F%96%E5%AD%90%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B0%E6%8D%AE-toc" style="margin-left:40px;"><a href="#%E7%88%B6%E7%BB%84%E4%BB%B6%E8%8E%B7%E5%8F%96%E5%AD%90%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B0%E6%8D%AE">八、父组件获取子组件的数据</a></p>
<p id="%C2%A0provide%E5%92%8Cinject%E4%BC%A0%E5%80%BC-toc" style="margin-left:40px;"><a href="#%C2%A0provide%E5%92%8Cinject%E4%BC%A0%E5%80%BC"> 九、provide和inject传值</a></p>
<p id="%E5%8D%81%E3%80%81%E8%B7%AF%E7%94%B1useRoute%E5%92%8CuseRouter-toc" style="margin-left:40px;"><a href="#%E5%8D%81%E3%80%81%E8%B7%AF%E7%94%B1useRoute%E5%92%8CuseRouter">十、路由useRoute和useRouter</a></p>
<p id="使用自定义指令-toc" style="margin-left:40px;"><a href="#%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4">十一、对await异步的支持</a></p>
<p id="%E5%8D%81%E4%BA%8C%E3%80%81nextTick-toc" style="margin-left:40px;"><a href="#%E5%8D%81%E4%BA%8C%E3%80%81nextTick">十二、nextTick</a></p>
<p id="%E5%8D%81%E4%B8%89%E3%80%81%E5%85%A8%E5%B1%80%E5%B1%9E%E6%80%A7globalProperties-toc" style="margin-left:40px;"><a href="#%E5%8D%81%E4%B8%89%E3%80%81%E5%85%A8%E5%B1%80%E5%B1%9E%E6%80%A7globalProperties">十三、全局属性globalProperties</a></p>
<p id="%E5%8D%81%E5%9B%9B%E3%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-toc" style="margin-left:40px;"><a href="#%E5%8D%81%E5%9B%9B%E3%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">十四、生命周期</a></p>
<p id="%E5%8D%81%E4%BA%94%E3%80%81%E4%B8%8E%E6%99%AE%E9%80%9A%E7%9A%84script%E6%A0%87%E7%AD%BE%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px;"><a href="#%E5%8D%81%E4%BA%94%E3%80%81%E4%B8%8E%E6%99%AE%E9%80%9A%E7%9A%84script%E6%A0%87%E7%AD%BE%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8">十五、与普通的script标签一起使用</a></p>
<p id="%E5%8D%81%E5%85%AD%E3%80%81v-memo%E6%96%B0%E6%8C%87%E4%BB%A4-toc" style="margin-left:40px;"><a href="#%E5%8D%81%E5%85%AD%E3%80%81v-memo%E6%96%B0%E6%8C%87%E4%BB%A4">十六、v-memo新指令</a></p>
<p id="style%E6%96%B0%E7%89%B9%E6%80%A7-toc" style="margin-left:0px;"><a href="#style%E6%96%B0%E7%89%B9%E6%80%A7">style新特性</a></p>
<p id="%E5%B1%80%E9%83%A8%E6%A0%B7%E5%BC%8F-toc" style="margin-left:40px;"><a href="#%E5%B1%80%E9%83%A8%E6%A0%B7%E5%BC%8F">一、局部样式</a></p>
<p id="%E6%B7%B1%E5%BA%A6%E9%80%89%E6%8B%A9%E5%99%A8-toc" style="margin-left:40px;"><a href="#%E6%B7%B1%E5%BA%A6%E9%80%89%E6%8B%A9%E5%99%A8">二、深度选择器</a></p>
<p id="插槽选择器-toc" style="margin-left:40px;"><a href="#%E6%8F%92%E6%A7%BD%E9%80%89%E6%8B%A9%E5%99%A8">三、插槽选择器</a></p>
<p id="全局选择器-toc" style="margin-left:40px;"><a href="#%E5%85%A8%E5%B1%80%E9%80%89%E6%8B%A9%E5%99%A8">四、全局选择器</a></p>
<p id="混合使用局部与全局样式-toc" style="margin-left:40px;"><a href="#%E6%B7%B7%E5%90%88%E4%BD%BF%E7%94%A8%E5%B1%80%E9%83%A8%E4%B8%8E%E5%85%A8%E5%B1%80%E6%A0%B7%E5%BC%8F">五、混合使用局部与全局样式</a></p>
<p id="%E6%94%AF%E6%8C%81CSS%C2%A0Modules-toc" style="margin-left:40px;"><a href="#%E6%94%AF%E6%8C%81CSS%C2%A0Modules">六、支持CSS Modules</a></p>
<p id="%E4%B8%8Esetup%E4%B8%80%E5%90%8C%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px;"><a href="#%E4%B8%8Esetup%E4%B8%80%E5%90%8C%E4%BD%BF%E7%94%A8">七、与setup一同使用</a></p>
<p id="状态驱动的动态-css-toc" style="margin-left:40px;"><a href="#%E7%8A%B6%E6%80%81%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%8A%A8%E6%80%81-css">八、动态 CSS</a></p>
<hr id="hr-toc"/>
<p></p>
<h1>前言</h1>
<p>        <span style="color:#fe2c24;">满满的干货，建议收藏慢慢看，可以当作Vue3.0的学习资料。</span></p>
<p>        在vue2.0时期，组件里定义的各类变量、方法、计算属性等是分别存放到data、methods、computed...选项里，这样编写的代码不便于后期的查阅（查找一个业务逻辑需要在各个选项来回切换）。setup函数的推出就是为了解决这个问题，让新手开发者更容易上手...</p>
<h1 id="setup%E8%AF%AD%E6%B3%95%E7%B3%96">setup语法糖</h1>
<p>        setup是Vue3.0后推出的语法糖，并且在Vue3.2版本进行了大更新，像写普通JS一样写vue组件，对于开发者更加友好了；按需引入computed、watch、directive等选项，一个业务逻辑可以集中编写在一起，让代码更加简洁便于浏览。</p>
<h2 id="%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95">一、基本用法</h2>
<p>只需在&lt;script&gt;里添加一个setup属性，编译时会把&lt;script setup&gt;&lt;/script&gt;里的代码编译成一个setup函数</p>
<pre><code>&lt;script setup&gt;
console.log('hello script setup')
&lt;/script&gt;</code></pre>
<p>普通的&lt;script&gt;只会在组件被首次引入的时候执行一次，<span style="color:#fe2c24;">&lt;script setup&gt;里的代码会在每次组件实例被创建的时候执行</span><strong>。</strong></p>
<h2 id="%E5%8F%98%E9%87%8F%E5%92%8C%E6%96%B9%E6%B3%95%E4%B8%8D%E9%9C%80%E8%A6%81return">二、data和methods</h2>
<p>&lt;script setup&gt;里声明的变量和函数，不需要return暴露出去，就可以直接在template使用</p>
<pre><code>&lt;script setup&gt;
import { ref, reactive } from 'vue'    
// 普通变量
const msg = 'Hello!'

// 响应式变量
let num = ref(1111)         // ref声明基本类型变量
const obj = reactive({        // reactive声明对象类型变量，如Object、Array、Date...
    key: 'this is a object'
})

// 函数
function log() {
    console.log(msg)          // Hello
    console.log(num.value)    // 1111（可根据input输入值而改变）
    console.log(obj.key)      // this is a object
}
&lt;/script&gt;

&lt;template&gt;
    &lt;h1&gt;{<!-- -->{ msg }}&lt;/h1&gt;
    &lt;p&gt;{<!-- -->{obj.key}}&lt;/p&gt;
    &lt;input v-model="num" type="text" /&gt;
    &lt;button @click="log"&gt;打印日志&lt;/button&gt;
&lt;/template&gt;</code></pre>
<h2 id="%E4%B8%89%E3%80%81%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7computed">三、计算属性computed</h2>
<pre><code>&lt;script setup&gt;
import { ref, computed } from 'vue'

let count = ref(0)
const countPlus = computed(()=&gt;{
    return count.value+1
})
&lt;/script&gt;

&lt;template&gt;
    &lt;h1&gt;计数：{<!-- -->{ countPlus }}&lt;/h1&gt;
&lt;/template&gt;</code></pre>
<h2 id="%E5%9B%9B%E3%80%81%E7%9B%91%E5%90%AC%E5%99%A8watch%E3%80%81watchEffect">四、监听器watch、watchEffect</h2>
<p>1、watch监听器除了使用方式有区别之外，其他的与vue2.0没啥变化</p>
<pre><code>&lt;script setup&gt;
import { ref, reactive, watch } from 'vue'

// 监听ref
let count = ref(0)
watch(count, (newVal, oldVal)=&gt; {
    console.log('修改后', newVal)
    console.log('修改前', oldVal)
})

// 监听reactive属性
const obj = reactive({
    count: 0
})
watch(
    ()=&gt; obj.count,     // 一个函数，返回监听属性
    (newVal, oldVal)=&gt; {
        console.log('修改后', newVal)
        console.log('修改前', oldVal)
    },
    {
        immediate: true,     // 立即执行，默认为false
        deep: true     // 深度监听，默认为false
    }
)

const onChange = function(){
    count.value++
    obj.count++
}
&lt;/script&gt;

&lt;template&gt;
    &lt;button @click="onChange"&gt;改变count&lt;/button&gt;
&lt;/template&gt;</code></pre>
<p>2、watchEffect</p>
<p>watchEffect是Vue3.0新增的一个监听属性的方法，它与watch的区别在于watchEffect不需要指定监听对象，回调函数里可直接获取到修改后的属性的值</p>
<pre><code>&lt;script setup&gt;
import { ref, reactive, watchEffect } from 'vue'

let count = ref(0)
const obj = reactive({
    count: 0
})
setTimeout(()=&gt;{
    count.value++
    obj.count++
}, 1000)

watchEffect(()=&gt; {
    console.log('修改后的count', count.value)
    console.log('修改前的obj', obj.value)
})
&lt;/script&gt;</code></pre>
<h2 id="%E4%BA%94%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4directive">五、自定义指令directive</h2>
<p>以 <code>vNameOfDirective</code> 的形式来命名本地自定义指令，可以直接在模板中使用</p>
<pre><code>&lt;script setup&gt;
// 导入指令可重命名
// import { myDirective as vMyDirective } from './MyDirective.js'

// 自定义指令
const vMyDirective = {
  beforeMount: (el) =&gt; {
    // 在元素上做些操作
  }
}
&lt;/script&gt;
&lt;template&gt;
  &lt;h1 v-my-directive&gt;This is a Heading&lt;/h1&gt;
&lt;/template&gt;</code></pre>
<h2 id="import%E5%AF%BC%E5%85%A5%E7%9A%84%E5%86%85%E5%AE%B9%E5%8F%AF%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8">六、import导入的内容可直接使用</h2>
<p> 1、导入的模块内容，不需要通过 <code>methods</code> 来暴露它</p>
<pre><code>// utils.js 
export const onShow = function(name) {
    return 'my name is ' + name
}</code></pre>
<pre><code>// Show.vue
&lt;script setup&gt;
    import { onShow } from './utils.js'
&lt;/script&gt;
&lt;template&gt;
    &lt;div&gt;{<!-- -->{ onShow('jack') }}&lt;/div&gt;
&lt;/template&gt;</code></pre>
<p> 2、<span style="color:#fe2c24;"><strong>导入外部组件，不需要通过components注册使用</strong></span></p>
<pre><code>// Child.vue
&lt;template&gt;
    &lt;div&gt;I am a child&lt;/div&gt;
&lt;/template&gt;</code></pre>
<pre><code>// Parent.vue
&lt;script setup&gt;
    import Child from './Child.vue'
&lt;/script&gt;
&lt;template&gt;
    &lt;child&gt;&lt;/child&gt;
&lt;/template&gt;</code></pre>
<h2 id="%E5%A3%B0%E6%98%8Eprops%E5%92%8Cemits%C2%A0">七、声明props和emits </h2>
<p>在 <code>&lt;script setup&gt;</code> 中必须使用 <code>defineProps</code> 和 <code>defineEmits</code> API 来声明 <code>props</code> 和 <code>emits</code> ，它们具备完整的类型推断并且在 <code>&lt;script setup&gt;</code> 中是直接可用的</p>
<pre><code>// Child.vue
&lt;script setup&gt;

// 声明props
const props = defineProps({
    info: {
        type: String,
        default: ''
    }
})

// 声明emits
const $emit = defineEmits(['change'])

const onChange = function() {
    $emit('change', 'child返回值')
}
&lt;/script&gt;

&lt;template&gt;
    &lt;h1&gt;信息：{<!-- -->{ info }}&lt;/h1&gt;
    &lt;button @click="onChange"&gt;点击我&lt;/button&gt;
&lt;/template&gt;</code></pre>
<pre><code>// Parent.vue
&lt;script setup&gt;
import { ref } from 'vue'
import Child from './Child.vue'

const msg = ref('hello setup !')    // 响应式变量

const onAction = function(event) {
    console.log(event)    // child返回值
}
&lt;/script&gt;

&lt;template&gt;
    &lt;child :info="msg" @change="onAction"&gt;&lt;/child&gt;
&lt;/template&gt;</code></pre>
<p>如果使用了 Typescript，<a href="https://v3.cn.vuejs.org/api/sfc-script-setup.html#%E4%BB%85%E9%99%90-typescript-%E7%9A%84%E5%8A%9F%E8%83%BD" title="使用纯类型声明来声明 prop 和 emits">使用纯类型声明来声明 prop 和 emits</a> 也是可以的。</p>
<h2 id="%E7%88%B6%E7%BB%84%E4%BB%B6%E8%8E%B7%E5%8F%96%E5%AD%90%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B0%E6%8D%AE">八、父组件获取子组件的数据</h2>
<p>父组件要想通过ref获取子组件的变量或函数，子组件须使用<span style="color:#fe2c24;"><strong>defineExpose</strong></span>暴露出去</p>
<pre><code>// Child.vue
&lt;script setup&gt;
import { ref, defineExpose } from 'vue'

const info = ref('I am child')
const onChange = function() {
    console.log('Function of child')
}

// 暴露属性
defineExpose({
    info,
    onChange
})
&lt;/script&gt;

&lt;template&gt;
    &lt;h1&gt;信息：{<!-- -->{ info }}&lt;/h1&gt;
    &lt;button @click="onChange"&gt;点击我&lt;/button&gt;
&lt;/template&gt;</code></pre>
<pre><code>// Parent.vue
&lt;script setup&gt;
import { ref } from 'vue'
import Child from './Child.vue'

const childRef = ref()
const onAction = function() {
    console.log(childRef.value.info)    // I am child
    console.log(childRef.value.onChange())    // Function of child
}
&lt;/script&gt;

&lt;template&gt;
    &lt;child ref="childRef"&gt;&lt;/child&gt;
    &lt;button @click="onAction"&gt;获取子值&lt;/button&gt;
&lt;/template&gt;</code></pre>
<h2 id="%C2%A0provide%E5%92%8Cinject%E4%BC%A0%E5%80%BC"> 九、provide和inject传值</h2>
<p>无论组件层次结构有多深，父组件都可以通过<span style="color:#fe2c24;"><strong><code>provide</code></strong></span> 选项来其所有子组件提供数据，子组件通过<span style="color:#fe2c24;"><strong>inject</strong></span>接收数据</p>
<pre><code>// Parent.vue
&lt;script setup&gt;
import { ref, provide } from 'vue'
import Child from './Child.vue'

const msg = ref('Hello, my son')
const onShow = function() {
    console.log('I am your parent')
}

provide('myProvide', {
    msg,
    onShow
})
&lt;/script&gt;

&lt;template&gt;
    &lt;child&gt;&lt;/child&gt;
&lt;/template&gt;</code></pre>
<pre><code>// Child.vue
&lt;script setup&gt;
import { inject } from 'vue'

const provideState = inject('myProvide')    // 接收参数

const getData = function() {
    console.log(provideState.msg)    // Hello, my son
    console.log(provideState.onShow())    // I am your parent
}
&lt;/script&gt;

&lt;template&gt;
    &lt;button @click="getData"&gt;获取父值&lt;/button&gt;
&lt;/template&gt;</code></pre>
<h2 id="%E5%8D%81%E3%80%81%E8%B7%AF%E7%94%B1useRoute%E5%92%8CuseRouter">十、路由useRoute和useRouter</h2>
<pre><code>&lt;script setup&gt;
import { useRoute, useRouter } from 'vue-router'

const $route = useRoute()
const $router = userRouter()

// 路由信息
console.log($route.query)

// 路由跳转
$router.push('/login')
&lt;/script&gt;</code></pre>
<h2 id="使用自定义指令">十一、对await异步的支持</h2>
<p><code>&lt;script setup&gt;</code> 中可以使用顶层 <code>await</code>。结果代码会被编译成 <code>async setup()</code></p>
<pre><code>&lt;script setup&gt;
    const post = await fetch(`/api/post/1`).then(r =&gt; r.json())
&lt;/script&gt;</code></pre>
<h2 id="%E5%8D%81%E4%BA%8C%E3%80%81nextTick">十二、nextTick</h2>
<pre><code>// 方式一
&lt;script setup&gt;
import { nextTick } from 'vue'

nextTick(()=&gt;{
    console.log('Dom已更新！')
})
&lt;/script&gt;</code></pre>
<pre><code>// 方式二
&lt;script setup&gt;
import { nextTick } from 'vue'

await nextTick()    // nextTick是一个异步函数，返回一个Promise实例
// console.log('Dom已更新！')
&lt;/script&gt;</code></pre>
<h2 id="%E5%8D%81%E4%B8%89%E3%80%81%E5%85%A8%E5%B1%80%E5%B1%9E%E6%80%A7globalProperties">十三、全局属性globalProperties</h2>
<pre><code>// main.js里定义
import { createApp } from 'vue'
import App from './App.vue'
const app = createApp(App)

// 定义一个全局属性$global 
app.config.globalProperties.$global = 'This is a global property.' 

app.mount('#app')</code></pre>
<pre><code>// 组件内使用
&lt;script setup&gt;
import { getCurrentInstance } from 'vue'

// 获取vue实例
const { proxy } = getCurrentInstance()
// 输出
console.log(proxy.$global)    // This is a global property.
&lt;/script&gt;</code></pre>
<h2 id="%E5%8D%81%E5%9B%9B%E3%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">十四、生命周期</h2>
<p>setup()里访问组件的生命周期需要在生命周期钩子前加上“on”，并且没有beforeCreate和created生命周期钩子</p>
<blockquote>
<p>因为 <code>setup</code> 是围绕 <code>beforeCreate</code> 和 <code>created</code> 生命周期钩子运行的，所以不需要显式地定义它们。换句话说，在这些钩子中编写的任何代码都应该直接在 <code>setup</code> 函数中编写。</p>
</blockquote>
<p><img alt="" height="726" src="image\d7064ce777c948e5b1d105db5387753e.png" width="470"/></p>
<pre><code>// 使用方式
&lt;script setup&gt;
import { onMounted } from 'vue'

onMounted(()=&gt; {
    console.log('onMounted')
})
&lt;/script&gt;</code></pre>
<h2 id="%E5%8D%81%E4%BA%94%E3%80%81%E4%B8%8E%E6%99%AE%E9%80%9A%E7%9A%84script%E6%A0%87%E7%AD%BE%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8">十五、与普通的script标签一起使用</h2>
<p><code>&lt;script setup&gt;</code> 可以和普通的 <code>&lt;script&gt;</code> 一起使用。普通的 <code>&lt;script&gt;</code> 在有这些需要的情况下或许会被使用到：</p>
<ul><li>无法在 <code>&lt;script setup&gt;</code> 声明的选项，例如 <code>inheritAttrs</code> 或通过插件启用的自定义的选项；</li><li>声明命名导出，<code>&lt;script setup&gt;</code>定义的组件默认以组件文件的名称作为组件名；</li><li>运行副作用或者创建只需要执行一次的对象。</li></ul>
<pre><code>&lt;script&gt;
// 普通 &lt;script&gt;, 在模块范围下执行(只执行一次)
runSideEffectOnce()

// 声明额外的选项
export default {
  name: 'ComponentName',    // 组件重命名
  inheritAttrs: false,
  customOptions: {}
}
&lt;/script&gt;

&lt;script setup&gt;
// 在 setup() 作用域中执行 (对每个实例皆如此)
&lt;/script&gt;</code></pre>
<h2 id="%E5%8D%81%E5%85%AD%E3%80%81v-memo%E6%96%B0%E6%8C%87%E4%BB%A4">十六、v-memo新指令</h2>
<p>该指令与v-once类似，v-once是只渲染一次之后的更新不再渲染，而v-memo是根据条件来渲染。该指令接收一个固定长度的数组作为依赖值进行记忆比对，如果数组中的每个值都和上次渲染的时候相同，则该元素（含子元素）不刷新。</p>
<p>1、应用于普通元素或组件；</p>
<pre><code>&lt;template&gt;
&lt;-- 普通元素 --&gt;
&lt;div v-memo="[valueA, valueB]"&gt;
  ... 
&lt;/div&gt;

&lt;-- 组件 --&gt;
&lt;component v-memo="[valueA, valueB]"&gt;&lt;/component&gt;
&lt;/template&gt;

&lt;script setup&gt;
import component from "../compoents/component.vue"
&lt;/script&gt;</code></pre>
<p>当组件重新渲染的时候，如果 <code>valueA</code> 与 <code>valueB</code> 都维持不变，那么对这个 <code>&lt;div&gt;</code> 以及它的所有子节点的更新都将被跳过。</p>
<p>2、<strong>结合<code>v-for</code>使用</strong></p>
<p><code>v-memo</code> 仅供性能敏感场景的针对性优化，会用到的场景应该很少。渲染 <code>v-for</code> 长列表 (长度大于 1000) 可能是它最有用的场景：</p>
<pre><code>&lt;template&gt;
&lt;div v-for="item in list" :key="item.id" v-memo="[item.id === selected]"&gt;
  &lt;p&gt;ID: {<!-- -->{ item.id }} - selected: {<!-- -->{ item.id === selected }}&lt;/p&gt;
  &lt;p&gt;...more child nodes&lt;/p&gt;
&lt;/div&gt;
&lt;/template&gt;</code></pre>
<p>当selected发生变化时，只有item.id===selected的该项重新渲染，其余不刷新。</p>
<h1 id="style%E6%96%B0%E7%89%B9%E6%80%A7">style新特性</h1>
<p>Vue3.2版本对单文件组件的style样式进行了很多升级，如局部样式、css变量以及样式暴露给模板使用等。</p>
<h2 id="%E5%B1%80%E9%83%A8%E6%A0%B7%E5%BC%8F">一、局部样式</h2>
<p>当 <code>&lt;style&gt;</code> 标签带有 <code>scoped</code> attribute 的时候，它的 CSS 只会应用到当前组件的元素上：</p>
<pre><code>&lt;template&gt;
  &lt;div class="example"&gt;hi&lt;/div&gt;
&lt;/template&gt;

&lt;style scoped&gt;
.example {
  color: red;
}
&lt;/style&gt;</code></pre>
<h2 id="%E6%B7%B1%E5%BA%A6%E9%80%89%E6%8B%A9%E5%99%A8">二、深度选择器</h2>
<p>处于 <code>scoped</code> 样式中的选择器如果想要做更“深度”的选择，也即：影响到子组件，可以使用 <code>:deep()</code> 这个伪类：</p>
<pre><code>&lt;style scoped&gt;
.a :deep(.b) {
  /* ... */
}
&lt;/style&gt;</code></pre>
<blockquote>
<p>通过 <code>v-html</code> 创建的 DOM 内容不会被作用域样式影响，但你仍然可以使用深度选择器来设置其样式。</p>
</blockquote>
<h2 id="插槽选择器">三、插槽选择器</h2>
<p>默认情况下，作用域样式不会影响到 <code>&lt;slot/&gt;</code> 渲染出来的内容，因为它们被认为是父组件所持有并传递进来的。使用 <code>:slotted</code> 伪类以确切地将插槽内容作为选择器的目标：</p>
<pre><code>&lt;style scoped&gt;
:slotted(div) {
  color: red;
}
&lt;/style&gt;</code></pre>
<h2 id="全局选择器">四、全局选择器</h2>
<p>如果想让其中一个样式规则应用到全局，比起另外创建一个 <code>&lt;style&gt;</code>，可以使用 <code>:global</code> 伪类来实现：</p>
<pre><code>&lt;style scoped&gt;
:global(.red) {
  color: red;
}
&lt;/style&gt;</code></pre>
<h2 id="混合使用局部与全局样式">五、混合使用局部与全局样式</h2>
<p>你也可以在同一个组件中同时包含作用域样式和非作用域样式：</p>
<pre><code>&lt;style&gt;
/* global styles */
&lt;/style&gt;

&lt;style scoped&gt;
/* local styles */
&lt;/style&gt;</code></pre>
<h2 id="%E6%94%AF%E6%8C%81CSS%C2%A0Modules">六、支持CSS Modules</h2>
<p><code>&lt;style module&gt;</code> 标签会被编译为 <a href="https://github.com/css-modules/css-modules" title="CSS Modules">CSS Modules</a> 并且将生成的 CSS 类键暴露给组件：</p>
<p>1、 默认以<code>$style</code> 对象暴露给组件；</p>
<pre><code>&lt;template&gt;
  &lt;p :class="$style.red"&gt;
    This should be red
  &lt;/p&gt;
&lt;/template&gt;

&lt;style module&gt;
.red {
  color: red;
}
&lt;/style&gt;</code></pre>
<p>2、可以自定义注入module名称</p>
<pre><code>&lt;template&gt;
  &lt;p :class="classes.red"&gt;red&lt;/p&gt;
&lt;/template&gt;

&lt;style module="classes"&gt;
.red {
  color: red;
}
&lt;/style&gt;</code></pre>
<h2 id="%E4%B8%8Esetup%E4%B8%80%E5%90%8C%E4%BD%BF%E7%94%A8">七、与setup一同使用</h2>
<p>注入的类可以通过 <a href="https://v3.cn.vuejs.org/api/global-api.html#usecssmodule" title="useCssModule">useCssModule</a> API 在 <code>setup()</code> 和 <code>&lt;script setup&gt;</code> 中使用：</p>
<pre><code>&lt;script setup&gt;
import { useCssModule } from 'vue'

// 默认, 返回 &lt;style module&gt; 中的类
const defaultStyle = useCssModule()

// 命名, 返回 &lt;style module="classes"&gt; 中的类
const classesStyle = useCssModule('classes')
&lt;/script&gt;</code></pre>
<h2 id="状态驱动的动态-css">八、动态 CSS</h2>
<p>单文件组件的 <code>&lt;style&gt;</code> 标签可以通过 <code>v-bind</code> 这一 CSS 函数将 CSS 的值关联到动态的组件状态上：</p>
<pre><code>&lt;script setup&gt;
const theme = {
  color: 'red'
}
&lt;/script&gt;

&lt;template&gt;
  &lt;p&gt;hello&lt;/p&gt;
&lt;/template&gt;

&lt;style scoped&gt;
p {
  color: v-bind('theme.color');
}
&lt;/style&gt;</code></pre>
<p>（完） </p>
<p>参考文献：</p>
<p><a href="https://v3.cn.vuejs.org/api/sfc-spec.html" title="SFC 语法规范 | Vue.js">SFC 语法规范 | Vue.js</a></p>
<p><a class="link-info" href="https://juejin.cn/post/7006108454028836895#heading-43" title="Vue3.2 setup语法糖、Composition API、状态库Pinia归纳总监">Vue3.2 setup语法糖、Composition API、状态库Pinia归纳总监</a></p>
</div>
</div>