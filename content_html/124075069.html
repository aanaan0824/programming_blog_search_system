<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<p><span style="color:#a2e043;"><strong>我大概</strong></span><span style="color:#a2e043;"><strong>是乏</strong></span><span style="color:#a2e043;"><strong>了，横竖都开心不起来，站起身来皱了眉头，这悲伤是没来由的。</strong></span><span style="color:#956fe7;"><strong>作为一个曾经长期掌控不了系统时间的初级程序猿，在经过几天的探索以后，心血来潮总结下来分享给小伙伴们。小伙伴们或许会很期待吧，一篇博客如何让自己</strong></span><span style="color:#fe2c24;"><strong>成为掌控时间的强者</strong></span><span style="color:#956fe7;"><strong>呢？多说无益，开始正文！</strong></span></p>
<p id="main-toc"></p>
<p id="main-toc"><strong>目录</strong></p>
<p id="%E4%BB%8A%E5%A4%A9%E6%98%AF%E5%87%A0%E5%8F%B7%EF%BC%9F-toc" style="margin-left:0px;"><a href="#%E4%BB%8A%E5%A4%A9%E6%98%AF%E5%87%A0%E5%8F%B7%EF%BC%9F">今天是几号？</a></p>
<p id="time_t%20%E5%9E%8B%EF%BC%9A%E6%97%A5%E5%8E%86%E6%97%B6%E9%97%B4-toc" style="margin-left:40px;"><a href="#time_t%20%E5%9E%8B%EF%BC%9A%E6%97%A5%E5%8E%86%E6%97%B6%E9%97%B4">time_t 型：日历时间</a></p>
<p id="time%20%E5%87%BD%E6%95%B0%EF%BC%9A%E4%BB%A5%E6%97%A5%E5%8E%86%E6%97%B6%E9%97%B4%E7%9A%84%E5%BD%A2%E5%BC%8F%E6%9D%A5%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E6%97%B6%E9%97%B4-toc" style="margin-left:40px;"><a href="#time%20%E5%87%BD%E6%95%B0%EF%BC%9A%E4%BB%A5%E6%97%A5%E5%8E%86%E6%97%B6%E9%97%B4%E7%9A%84%E5%BD%A2%E5%BC%8F%E6%9D%A5%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E6%97%B6%E9%97%B4">time 函数：以日历时间的形式来获取当前时间</a></p>
<p id="tm%20%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%9A%E5%88%86%E8%A7%A3%E6%97%B6%E9%97%B4%EF%BC%88%E6%92%95%E8%A3%82%E6%97%B6%E9%97%B4%EF%BC%89-toc" style="margin-left:40px;"><a href="#tm%20%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%9A%E5%88%86%E8%A7%A3%E6%97%B6%E9%97%B4%EF%BC%88%E6%92%95%E8%A3%82%E6%97%B6%E9%97%B4%EF%BC%89">tm 结构体：分解时间（撕裂时间）</a></p>
<p id="localtime%20%E5%87%BD%E6%95%B0%EF%BC%9A%E6%8A%8A%E6%97%A5%E5%8E%86%E6%97%B6%E9%97%B4%E8%BD%AC%E6%8D%A2%E6%88%90%E8%A1%A8%E7%A4%BA%E6%9C%AC%E5%9C%B0%E6%97%B6%E9%97%B4%E7%9A%84%E5%88%86%E8%A7%A3%E6%97%B6%E9%97%B4-toc" style="margin-left:40px;"><a href="#localtime%20%E5%87%BD%E6%95%B0%EF%BC%9A%E6%8A%8A%E6%97%A5%E5%8E%86%E6%97%B6%E9%97%B4%E8%BD%AC%E6%8D%A2%E6%88%90%E8%A1%A8%E7%A4%BA%E6%9C%AC%E5%9C%B0%E6%97%B6%E9%97%B4%E7%9A%84%E5%88%86%E8%A7%A3%E6%97%B6%E9%97%B4">localtime 函数：把日历时间转换成表示本地时间的分解时间</a></p>
<p id="gmtime%20%E5%87%BD%E6%95%B0%EF%BC%9A%E6%8A%8A%E6%97%A5%E5%8E%86%E6%97%B6%E9%97%B4%E8%BD%AC%E6%8D%A2%E6%88%90UTC%E5%88%86%E8%A7%A3%E6%97%B6%E9%97%B4-toc" style="margin-left:40px;"><a href="#gmtime%20%E5%87%BD%E6%95%B0%EF%BC%9A%E6%8A%8A%E6%97%A5%E5%8E%86%E6%97%B6%E9%97%B4%E8%BD%AC%E6%8D%A2%E6%88%90UTC%E5%88%86%E8%A7%A3%E6%97%B6%E9%97%B4">gmtime 函数：把日历时间转换成UTC分解时间</a></p>
<p id="asctime%20%E5%87%BD%E6%95%B0%EF%BC%9A%E6%8A%8A%E5%88%86%E8%A7%A3%E6%97%B6%E9%97%B4%E8%BD%AC%E6%8D%A2%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2-toc" style="margin-left:40px;"><a href="#asctime%20%E5%87%BD%E6%95%B0%EF%BC%9A%E6%8A%8A%E5%88%86%E8%A7%A3%E6%97%B6%E9%97%B4%E8%BD%AC%E6%8D%A2%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2">asctime 函数：把分解时间转换成字符串</a></p>
<p id="ctime%20%E5%87%BD%E6%95%B0%EF%BC%9A%E6%8A%8A%E6%97%A5%E5%8E%86%E6%97%B6%E9%97%B4%E8%BD%AC%E6%8D%A2%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2-toc" style="margin-left:40px;"><a href="#ctime%20%E5%87%BD%E6%95%B0%EF%BC%9A%E6%8A%8A%E6%97%A5%E5%8E%86%E6%97%B6%E9%97%B4%E8%BD%AC%E6%8D%A2%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2">ctime 函数：把日历时间转换成字符串</a></p>
<p id="difftime%20%E5%87%BD%E6%95%B0%EF%BC%9A%E6%B1%82%E6%97%B6%E9%97%B4%E5%B7%AE-toc" style="margin-left:40px;"><a href="#difftime%20%E5%87%BD%E6%95%B0%EF%BC%9A%E6%B1%82%E6%97%B6%E9%97%B4%E5%B7%AE">difftime 函数：求时间差</a></p>
<p id="%E6%B1%82%E6%98%9F%E6%9C%9F-toc" style="margin-left:0px;"><a href="#%E6%B1%82%E6%98%9F%E6%9C%9F">求星期</a></p>
<p id="mktime%20%E5%87%BD%E6%95%B0%EF%BC%9A%E4%B8%A4%E6%9E%81%E5%8F%8D%E8%BD%AC-toc" style="margin-left:40px;"><a href="#mktime%20%E5%87%BD%E6%95%B0%EF%BC%9A%E4%B8%A4%E6%9E%81%E5%8F%8D%E8%BD%AC">mktime 函数：两极反转</a></p>
<p id="%E5%AE%8C%E7%BB%93-toc" style="margin-left:0px;"><a href="#%E5%AE%8C%E7%BB%93">完结</a></p>
<hr id="hr-toc"/>
<p></p>
<p></p>
<p></p>
<h1 id="%E4%BB%8A%E5%A4%A9%E6%98%AF%E5%87%A0%E5%8F%B7%EF%BC%9F">今天是几号？</h1>
<p>先来上本篇博客的第一段代码，小伙伴们来学习一下如何获取当前日期及时间：</p>
<pre><code class="language-cpp">//time01

#include &lt;stdio.h&gt;
#include &lt;time.h&gt;

void put_date(const struct tm* timer)
{
	char* wday_name[] = { "日","一","二","三","四","五","六" };

	printf("%4d年%02d月%02d日(%s)%02d时%02d分%02d秒", timer-&gt;tm_year + 1900,      //年
		timer-&gt;tm_mon + 1,                  //月
		timer-&gt;tm_mday,                     //日
		wday_name[timer-&gt;tm_wday],          //星期
		timer-&gt;tm_hour,                     //时
		timer-&gt;tm_min,                      //分
		timer-&gt;tm_sec);                     //秒
}

int main()
{
	time_t current;                     //日历时间
	struct tm* timer;                   //分解时间（结构体）

	time(&amp;current);                     //获取当前时间
	timer = localtime(&amp;current);        //转换成分解时间（本地时间）

	printf("当前日期和时间是");
	put_date(timer);
	printf("。\n");

	return 0;
}</code></pre>
<h2 id="time_t%20%E5%9E%8B%EF%BC%9A%E6%97%A5%E5%8E%86%E6%97%B6%E9%97%B4">time_t 型：日历时间</h2>
<p><strong>time_t 型，又称为日历时间</strong>，其实它很像int型和double型一样，能够进行加减乘除运算的算数型。具体等同于哪个类型取决于编程环境（不光决定日历时间的类型，还决定了其具体的值）。使用它需要加上&lt;time.h&gt;头文件定义。在大多数编译环境中把time_t 型等同于int型或long型，以<span style="color:#956fe7;"><strong>格林尼治标准时间，也就是1970年1月1日0时0分0秒后经过的秒数作为日历时间的具体值。</strong></span></p>
<p></p>
<h2 id="time%20%E5%87%BD%E6%95%B0%EF%BC%9A%E4%BB%A5%E6%97%A5%E5%8E%86%E6%97%B6%E9%97%B4%E7%9A%84%E5%BD%A2%E5%BC%8F%E6%9D%A5%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E6%97%B6%E9%97%B4">time 函数：以日历时间的形式来获取当前时间</h2>
<p>且看下表：</p>
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td></td><td>time</td></tr><tr><td>头文件</td><td>#include &lt;time.h&gt;</td></tr><tr><td>格式</td><td>time_t time(time_t *timer);</td></tr><tr><td>功能</td><td>决定当前的日历时间。未定义该值的表现形式</td></tr><tr><td>返回值</td><td>用所在编译环境中的最佳逼近返回求出的日历时间。若日历时间无效则返回值（time_t）1，当timer不为空指针时，将返回值赋给timer指向的对象。</td></tr></tbody></table>
<p>此函数在求出日历时间的基础上，<span style="color:#956fe7;"><strong>把日历时间存入参数timer指向的对象中，同时返回日历时间。</strong></span>因此我们可以根据不同的用途和个人喜好来选择各种调用方式。</p>
<p>我们通过运用<span style="color:#956fe7;"><strong>time(&amp;current);</strong></span> ，把指向变量current的指针作为参数传递给了<strong>time</strong>函数。</p>
<h2 id="tm%20%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%9A%E5%88%86%E8%A7%A3%E6%97%B6%E9%97%B4%EF%BC%88%E6%92%95%E8%A3%82%E6%97%B6%E9%97%B4%EF%BC%89">tm 结构体：分解时间（撕裂时间）</h2>
<p>尝试一下用<strong><span style="color:#4da8ee;">time_t型</span></strong>来表示时间的我们知道,它所表示的是我们极其不易理解的：</p>
<p><img alt="" height="59" src="image\2a5d17e40c624ef28d81577209e6b840.png" width="217"/></p>
<p></p>
<p>因此，我们可以使用另外一个表示方法，<strong>就是被成为撕裂时间的<span style="color:#956fe7;">tm结构体</span>类型。</strong></p>
<p>我们把<span style="color:#956fe7;"><strong>tm 结构体</strong></span>拿出来看看：</p>
<pre><code class="language-cpp">struct tm{
    int tm_sec;            //秒（0-61）
    int tm_min;            //分（0-59）
    int tm_hour;           //时（0-23）
    int tm_mday;           //日（0-31）
    int tm_mon;            //从一月开始的月份（0-11）
    int tm_year;           //从1900开始的年份
    int tm_wday;           //星期：星期日-星期六（0-6）
    int tm_yday;           //从1月1日开始的天数（0-365）
}；</code></pre>
<p>小伙伴们可以通过代码中的注释来理解各个成员表示的值。而当我们在浏览到秒的成员tm_min的值设在<span style="color:#a2e043;">0-61</span>，是因为考虑到了<span style="color:#956fe7;"><strong>”闰秒“</strong></span>。</p>
<h2 id="localtime%20%E5%87%BD%E6%95%B0%EF%BC%9A%E6%8A%8A%E6%97%A5%E5%8E%86%E6%97%B6%E9%97%B4%E8%BD%AC%E6%8D%A2%E6%88%90%E8%A1%A8%E7%A4%BA%E6%9C%AC%E5%9C%B0%E6%97%B6%E9%97%B4%E7%9A%84%E5%88%86%E8%A7%A3%E6%97%B6%E9%97%B4">localtime 函数：把日历时间转换成表示本地时间的分解时间</h2>
<p><span style="color:#fe2c24;"><strong>localtime 函数（通过tm结构体）用于把日历时间的值转换成分解时间。</strong></span></p>
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td></td><td><strong>localtime</strong></td></tr><tr><td>头文件</td><td><strong>#include &lt;time.h&gt;</strong></td></tr><tr><td>格式</td><td><strong>struct tm*localtime(const time_t *timer);</strong></td></tr><tr><td>功能</td><td>把timer指向的日历时间转换成用本地时间表示的分解时间</td></tr><tr><td>返回值</td><td>返回指向转换后的对象的指针</td></tr></tbody></table>
<p>正如locattime的字面以四所示，转换后得到的是本地时间。我们来看看它的表示图：</p>
<p><img alt="" height="615" src="image\d5e3de5916304ee2a212a1996b50fc08.png" width="1068"/></p>
<p></p>
<p> 最后我们再来分析一下 time01 程序。</p>
<p><strong>（1）在main函数中，我们运用了time 函数以time_t 型的日历时间的形式获取当前时间，将其转换成分解时间，即tm 结构体。</strong></p>
<p><strong>（2）如何再使用 put_date 接受转换后的结构，并用公历纪元显示分解时间；</strong></p>
<p><strong>（3）最后，在tm_year 桑加上1900，在tm_mon上加上1，由于表示星期的tm_wday从星期日到星期六分别对应0到6，因此可以利用数组wday_name 将其转换后中文字符串”日“，”一“，…”六“并显示出来。</strong></p>
<h2 id="gmtime%20%E5%87%BD%E6%95%B0%EF%BC%9A%E6%8A%8A%E6%97%A5%E5%8E%86%E6%97%B6%E9%97%B4%E8%BD%AC%E6%8D%A2%E6%88%90UTC%E5%88%86%E8%A7%A3%E6%97%B6%E9%97%B4">gmtime 函数：把日历时间转换成UTC分解时间</h2>
<p>只讲本地时间的话可谓太吝啬了，接下来我将给小伙伴们带来协调时间时（即UTC）。</p>
<p>gmtime 函数是用来执行UTC的函数，且看下表;</p>
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td></td><td><strong>gmtime</strong></td></tr><tr><td>头文件</td><td><strong>#include &lt;time.h&gt;</strong></td></tr><tr><td>格式</td><td><strong>struct tm *gmtime(const time_t *timer);</strong></td></tr><tr><td>功能</td><td>把timer指向的日历时间转换成用协调时间时表示的分解时间</td></tr><tr><td>返回值</td><td>返回指向转换后的对象的指针</td></tr></tbody></table>
<p>我们来看看如何运用gmtime函数，代码其实跟 time01 如出一辙：</p>
<pre><code class="language-cpp">//time02

#include &lt;stdio.h&gt;
#include &lt;time.h&gt;

void put_date(const struct tm* timer)
{
	char* wday_name[] = { "日","一","二","三","四","五","六" };

	printf("%4d年%02d月%02d日(%s)%02d时%02d分%02d秒", timer-&gt;tm_year + 1900,
		timer-&gt;tm_mon + 1,
		timer-&gt;tm_mday,
		wday_name[timer-&gt;tm_wday],
		timer-&gt;tm_hour,
		timer-&gt;tm_min,
		timer-&gt;tm_sec);
}

int main()
{
	time_t current;
	struct tm* timer;

	time(&amp;current);
	timer = gmtime(&amp;current);

	printf("当前日期和时间用UTC表示是");
	put_date(timer);
	printf("。\n");

	return 0;
}</code></pre>
<p><span style="color:#a2e043;"><strong>其实就是把timer = localtime(&amp;current); 改为timer = gmtime(&amp;current); 。</strong></span></p>
<h2 id="asctime%20%E5%87%BD%E6%95%B0%EF%BC%9A%E6%8A%8A%E5%88%86%E8%A7%A3%E6%97%B6%E9%97%B4%E8%BD%AC%E6%8D%A2%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2">asctime 函数：把分解时间转换成字符串</h2>
<p>再给小伙伴们分享一个函数，它可以把分解时间转换成字符串，能简单地表示出当前日期和时间，何乐而不为呢？且看下面代码：</p>
<pre><code class="language-cpp">//time03

#include &lt;stdio.h&gt;
#include &lt;time.h&gt;

int main()
{
	time_t current = time(NULL);

	printf("当前日期和时间：%s", asctime(localtime(&amp;current)));

	return 0;
}</code></pre>
<p><strong><span style="color:#956fe7;">asctime 函数是把分解时间转换成字符串形式的函数。</span></strong><span style="color:#4da8ee;">它生成和返回的字符串从左到右按星期/月/日/时/分/秒/年的顺序排列，用空白字符与冒号”：“隔开</span>。</p>
<p><img alt="" height="677" src="image\266dc0b9605d49339be3ff1770d185c2.png" width="1200"/></p>
<p> 我们可以看到，星期和月中分别存有其英语单词开头的3个字母（开头的字母是大写字母，而第2个和第3个是小写字母）。我们再来看看它的表：</p>
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td></td><td><strong>asctime</strong></td></tr><tr><td>头文件</td><td><strong>#include &lt;time.h&gt;</strong></td></tr><tr><td>格式</td><td><strong>char *asctime(const struct tm *timeptr);</strong></td></tr><tr><td>功能</td><td> <p>把timeptr指向的结构体的分解时间转换成下面这种形式的字符串</p> <p>Sun Apr 10 13:13:09:00 2022</p> </td></tr><tr><td>返回值</td><td>返回指向转换后的对象的指针</td></tr></tbody></table>
<h2 id="ctime%20%E5%87%BD%E6%95%B0%EF%BC%9A%E6%8A%8A%E6%97%A5%E5%8E%86%E6%97%B6%E9%97%B4%E8%BD%AC%E6%8D%A2%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2">ctime 函数：把日历时间转换成字符串</h2>
<p><span style="color:#4da8ee;"><strong>使用asctime函数时，我们为了把time_t型的日历时间转换成tm 结构体的分解时间，需要实现调用localtime 函数。这样一来，把日历时间转换成字符串就需要两个步骤了，未免太过于繁琐。ctime 函数就不一样了，只需一步便可！</strong></span></p>
<pre><code class="language-cpp">//time04

#include &lt;stdio.h&gt;
#include &lt;time.h&gt;

int main()
{
	time_t current = time(NULL);

	printf("当前日期和时间：%s", ctime(&amp;current));

	return 0;
}</code></pre>
<p>ctime 表如下：</p>
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td></td><td><strong>ctime</strong></td></tr><tr><td>头文件</td><td><strong>#include &lt;time.h&gt;</strong></td></tr><tr><td>格式</td><td><strong>char *ctime(const time_t *timer);</strong></td></tr><tr><td>功能</td><td>把timer指向的日历时间转换成与asctime函数具有相同字符串形式的本地时间，相当于asctime（localtime（timer））</td></tr><tr><td>返回值</td><td>返回以分解时间为实际参数的asctime函数返回的指针</td></tr></tbody></table>
<p></p>
<h2 id="difftime%20%E5%87%BD%E6%95%B0%EF%BC%9A%E6%B1%82%E6%97%B6%E9%97%B4%E5%B7%AE">difftime 函数：求时间差</h2>
<p>接下来我讲给你们带来如何利用time函数获取的日历时间来计算处理时间。先上代码：</p>
<pre><code class="language-cpp">//time05

#include &lt;time.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
	int a, b, c, d;
	int x;
	time_t start, end;

	srand(time(NULL));

	a = rand() % 100;
	b = rand() % 100;
	c = rand() % 100;
	d = rand() % 100;

	printf("%d+%d+%d+%d等于多少：", a, b, c, d);

	start = time(NULL);

	while (1)
	{
		scanf("%d", &amp;x);
		if (x == a + b + c + d)
			break;
		printf("回答错误！！\n请重新输入：");
	}

	end = time(NULL);

	printf("用时%.0f秒。\n", difftime(end, start));

	return 0;
}</code></pre>
<p><span style="color:#4da8ee;">p<strong>rintf("用时%.0f秒。\n", difftime(end, start)); 通过调用difftime 函数用来求两个日历时间的差。它的用法极其简单，把两个time_t 型的值作为参数（end-start）给出就行，并以秒为单位的double型数值的形式返回时间差。</strong></span></p>
<p>我们再来看看difftime的表：</p>
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td></td><td><strong>difftime</strong></td></tr><tr><td>头文件</td><td><strong>#include &lt;time.h&gt;</strong></td></tr><tr><td>格式</td><td><strong>double difftime(time_t time1,time_t time0);</strong></td></tr><tr><td>功能</td><td>计算两个日历时间的差time1 - time0</td></tr><tr><td>返回值</td><td>以秒为单位表示求得的时间差，将其作为double 型返回</td></tr></tbody></table>
<p></p>
<h1 id="%E6%B1%82%E6%98%9F%E6%9C%9F">求星期</h1>
<h2 id="mktime%20%E5%87%BD%E6%95%B0%EF%BC%9A%E4%B8%A4%E6%9E%81%E5%8F%8D%E8%BD%AC">mktime 函数：两极反转</h2>
<p>前面讲述了如果将日历时间转换成分解时间，现在我再来讲讲如何将本地时间的分解时间转换成日历时间，那就是使用mktime 函数，它的功能与localtime 函数进行的转换正好相反。</p>
<p>而且，这函数还带来了<span style="color:#956fe7;"><strong>意外之喜</strong></span>。<span style="color:#a2e043;"><strong>它可以计算并设定结构体的星期和一年中经过的天数的值</strong></span>。利用该功能的话，咱只需设定分解时间的年/月/日并调用<strong>mktime 函数</strong>，就能求出对应的星期。</p>
<p>我们来看看它的流程图：</p>
<p></p>
<p></p>
<p></p>
<p><img alt="" height="691" src="image\00a9cedf093e4094bf7febb79b4d9213.png" width="1200"/></p>
<p>这可真是<span style="color:#fe2c24;"><strong>两极反转</strong></span>啊！</p>
<p>最后，用一段华丽的代码了却此博客：</p>
<pre><code class="language-cpp">//time06

#include &lt;time.h&gt;
#include &lt;stdio.h&gt;

int dayofweek(int year, int month, int day)
{
	struct tm t;
	t.tm_year = year - 1900;
	t.tm_mon = month - 1;
	t.tm_mday = day;
	t.tm_hour = 0;
	t.tm_min = 0;
	t.tm_sec = 0;
	t.tm_isdst = -1;

	if (mktime(&amp;t) == (time_t)-1)
		return -1;
	return t.tm_wday;
}

int main()
{
	int y, m, d, w;
	char* ws[] = { "日","一","二","三","四","五","六" };

	printf("求星期。\n");
	printf("年：");		scanf("%d", &amp;y);
	printf("月：");		scanf("%d", &amp;m);
	printf("日：");		scanf("%d", &amp;d);

	w = dayofweek(y, m, d);

	if (w != -1)
		printf("这一天是星期%s。\n", ws[w]);
	else
		printf("无法求出星期。\n");

	return 0;
}</code></pre>
<p><img alt="" height="677" src="image\209738d318c141dfbdda2d955bbf0388.png" width="1200"/></p>
<p></p>
<p></p>
<p></p>
<p>time06 中定义的<span style="color:#4da8ee;"><strong>dayofweek 函数</strong></span>会根据接受的<strong>年/月/日</strong>这3个值来生成分解时间，然后再调用mktime 函数，之后函数会通过<strong>”附赠“</strong>的功能直接返回成员函数<strong>tm_wday </strong>中设定的值，值为0是星期日……</p>
<p>此外，<span style="color:#a2e043;"><strong>mktime函数返回错误时，说明程序有可能求出了错误的星期数值，因此函数dayofweek 会返回 -1</strong></span>。</p>
<p style="text-align:center;"><img alt="" src="image\1d56714b92024beb8ea113afd114e569.png"/></p>
<p></p>
<h1 id="%E5%AE%8C%E7%BB%93">完结</h1>
<p><span style="color:#956fe7;"><strong>很</strong></span><span style="color:#fe2c24;"><strong>感激阅读到这里的你</strong></span><span style="color:#956fe7;"><strong>，相信阅读完的你已经成为了</strong></span><span style="color:#fe2c24;"><strong>掌控时间的强者</strong></span><span style="color:#956fe7;"><strong>了吧！</strong><strong>精彩并不止于这些，学有余力的小伙伴可以看看下面这些博客，都是</strong><strong>有着</strong></span><span style="color:#fe2c24;"><strong>极多的技巧与干货❤！</strong></span></p>
<p><a href="https://blog.csdn.net/qq_64263760/article/details/122880908" title="C语言小游戏（一）----猜数游戏_施律.的博客-CSDN博客_c语言猜数游戏次数限制">C语言小游戏（一）----猜数游戏_施律.的博客-CSDN博客_c语言猜数游戏次数限制</a></p>
<p><strong><a href="https://blog.csdn.net/qq_64263760/article/details/124053651" title="《斗破CPP》 第壹章 ---- 初窥CPP_施律.的博客-CSDN博客">《斗破CPP》 第壹章 ---- 初窥CPP_施律.的博客-CSDN博客</a></strong></p>
<p><a href="https://blog.csdn.net/qq_64263760/article/details/124065720" title="《斗破CPP》 第贰章（上） ---- 初识分支句_施律.的博客-CSDN博客">《斗破CPP》 第贰章（上） ---- 初识分支句_施律.的博客-CSDN博客</a></p>
<p><span style="color:#956fe7;"><strong>如果觉得本篇博客对正在学习编程的你有帮助的话，</strong><strong>请给施律.</strong></span><span style="color:#fe2c24;"><strong>多一点的支持与关注</strong></span><span style="color:#956fe7;"><strong>！未来的一段时间里</strong></span><span style="color:#fe2c24;"><strong>施律.将和小伙伴们一起在编程的道路是越来越远</strong></span><span style="color:#956fe7;"><strong>，希望下次的我能为大家奉上更好的博客内容，也</strong></span><span style="color:#fe2c24;"><strong>希望下次的博客有你</strong></span><span style="color:#956fe7;"><strong>！</strong></span></p>
</div>
</div>