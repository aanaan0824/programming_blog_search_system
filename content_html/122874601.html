<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<h2>1 大小和容量</h2>
<p>        vector优异效率的秘诀之一，就是分配出“较其容纳的元素”更多的内存。为了能够高效运用vector，你应该了解大小和容量之间的关系。</p>
<p>        vector提供用以操作大小的函数有size()、empty()和max_size()。另一个与大小有关的函数是 capacity()，返回vector实际能够容纳的元素量。如果超越这个量，vector就有必要重新分配内部内存。</p>
<h3>1.1 内存空间只会增长，不会减小</h3>
<p>        vector在增加内部元素时会预留出更多的空间以容纳后面新加元素的存放，当现有容量不足以容纳新加元素时，会再分配出新的多出可容纳现有元素的空间。vector的实际容量不会随着内部元素的删除而减小。</p>
<h3>1.2 reference、pointer和iterator失效</h3>
<p>        即使删除元素，其reference、pointer和iterator也会继续有效，继续指向动作发生前的位置。然而安插动作却可能使reference、pointer和iterator失效。swap()和shrink_to_fit()也会使reference、pointer和iterator失效。</p>
<h2></h2>
<h2>2 缩减容量以符合元素个数</h2>
<h3>2.1 shrink_to_fit()（C++11）</h3>
<p>        可以缩减容量以符合当前的元素个数。但是这个请求不具强制力，具体缩减和优化情况取决于编译器。会使reference、pointer和iterator失效。</p>
<h3>2.2 vector&lt;类型&gt;(temp_vector).swap(temp_vector)</h3>
<p>        这种操作比较直接，但是也会使reference、pointer和iterator失效。</p>
<p></p>
<h2>3 释放vector的内存</h2>
<h3>3.1 clear()后调用shrink_to_fit()，取决于编译器（可能释放不完全）</h3>
<pre><code class="language-cpp">temp_vector.clear();
temp_vector.shrink_to_fit();</code></pre>
<h3>3.2 clear()后swap()<span style="color:#fe2c24;">（推荐）</span></h3>
<pre><code class="language-cpp">temp_vector.clear();
vector&lt;类型&gt;(temp_vector).swap(temp_vector);</code></pre>
<p></p>
</div>
</div>