<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="markdown_views prism-atom-one-light" id="content_views">
<svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
<path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
</svg>
<h2><a id="toc_0"></a>
<div class="toc">
<h3>文章目录</h3>
<ul><li><ul><li><a href="#toc_0">@[toc]</a></li></ul>
</li><li><a href="#font_color996633_font_4"><font color="#996633">日期类</font></a></li><li><ul><li><ul><li><a href="#font_colorFF0033_Datehfont_10"><font color="#FF0033">Date.h</font></a></li><li><a href="#font_colorFF0033_Datecppfont_43"><font color="#FF0033">Date.cpp</font></a></li><li><a href="#font_colorFF0033_testcppfont_75"><font color="#FF0033">test.cpp</font></a></li><li><a href="#font_colorFF0033_font_94"><font color="#FF0033">测试情况</font></a></li></ul>
</li><li><a href="#font_color9400D3_font_100"><font color="#9400D3">功能添加</font></a></li><li><ul><li><a href="#font_colorFF0033_font_163"><font color="#FF0033">日期加天数后那个日期</font></a></li><li><a href="#font_colorFF0033_font_194"><font color="#FF0033">日期加天数</font></a></li><li><a href="#font_colorFF0033_font_214"><font color="#FF0033">日期++，++日期</font></a></li><li><ul><li><a href="#font_color0000CC_font_218"><font color="#0000CC">前置++</font></a></li><li><a href="#font_color0000CC_font_234"><font color="#0000CC">后置++</font></a></li></ul>
</li><li><a href="#font_colorFF0033_font_257"><font color="#FF0033">日期减天数后那个日期</font></a></li><li><a href="#font_colorFF0033_font_289"><font color="#FF0033">日期减天数</font></a></li><li><a href="#font_colorFF0033_font_309"><font color="#FF0033">日期--，--日期</font></a></li><li><ul><li><a href="#font_color0000CC_font_313"><font color="#0000CC">前置--</font></a></li><li><a href="#font_color0000CC_font_328"><font color="#0000CC">后置--</font></a></li></ul>
</li></ul>
</li><li><a href="#font_color9400D3_bugfont_346"><font color="#9400D3">修一修bug</font></a></li><li><ul><li><a href="#font_colorFF0033_font_348"><font color="#FF0033">若是-=里面的日期是负数的话</font></a></li><li><a href="#font_colorFF0033_font_399"><font color="#FF0033">若是+=里面的日期是负数的话</font></a></li></ul>
</li><li><a href="#font_color9400D3_font_448"><font color="#9400D3">比较运算符</font></a></li><li><ul><li><a href="#font_colorFF0033__font_450"><font color="#FF0033">大于 &gt;</font></a></li><li><a href="#font_colorFF0033___font_484"><font color="#FF0033">等于 == </font></a></li><li><a href="#font_colorFF0033___font_502"><font color="#FF0033">大于等于 &gt;= </font></a></li><li><a href="#font_colorFF0033__font_518"><font color="#FF0033">小于&lt; </font></a></li><li><a href="#font_colorFF0033___font_535"><font color="#FF0033">小于等于 &lt;= </font></a></li><li><a href="#font_colorFF0033___font_551"><font color="#FF0033">不等于 != </font></a></li></ul>
</li><li><a href="#font_color9400D3_font_567"><font color="#9400D3">生活实际</font></a></li><li><ul><li><a href="#font_colorFF0033_font_569"><font color="#FF0033">我们思考一个问题就是日期减日期有没有意义</font></a></li></ul>
</li><li><a href="#font_color9400D3_font_608"><font color="#9400D3">代码</font></a></li><li><ul><li><a href="#font_colorFF0033_Datehfont_610"><font color="#FF0033">Date.h</font></a></li><li><a href="#font_colorFF0033_Datecppfont_661"><font color="#FF0033">Date.cpp</font></a></li><li><a href="#font_colorFF0033_testcppfont_910"><font color="#FF0033">test.cpp</font></a></li></ul>
</li></ul>
</li></ul>
</div></h2>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/a6b98ecf34854152a613875d7fd99553.gif#pic_center"/></p>
<h1><a id="font_color996633_font_4"></a><font color="#996633">日期类</font></h1>
<blockquote>
<p>我们要有一个习惯就是写代码或者是写项目的时候我们要<mark>写一点编一点</mark>，要养成良好的习惯，万万不可以写完了再编，然后出了一堆错误自己都不想看，我们先自己编个最小项目或者系统框架在加其他功能</p>
</blockquote>
<hr/>
<h3><a id="font_colorFF0033_Datehfont_10"></a><font color="#FF0033">Date.h</font></h3>
<blockquote>
<p><code>Date.h</code>就是一些头文件，声明啥的</p>
<p><img alt="image-20220120135217626" src="https://img-blog.csdnimg.cn/img_convert/b44cdcddf8e5c78a93e82497a0da6be9.png"/></p>
<pre><code class="prism language-c++">#pragma once
#include &lt;iostream&gt;
using std::cout;
using std::cin;
using std::endl;

class Date
{
public:
	Date(int year = 0, int month = 1, int day = 1);
	void Print();
	//像析构，拷贝构造，赋值重载可以不需要写，因为默认生成的就够用了，
	//像Stack才需要自己写这三个
	
	//日期加 减天数
	Date operator+(const int&amp; day);
	Date operator-(const int&amp; day);
private:
	int _year;
	int _month;
	int _day;
};
</code></pre>
</blockquote>
<hr/>
<h3><a id="font_colorFF0033_Datecppfont_43"></a><font color="#FF0033">Date.cpp</font></h3>
<blockquote>
<p><code>Date.cpp</code>这里面就是写日期类的函数了</p>
<p><img alt="image-20220120140010670" src="https://img-blog.csdnimg.cn/img_convert/0c9926958b585752c045127c4049ee67.png"/></p>
<pre><code class="prism language-c++">#include "Date.h"

Date::Date(int year, int month, int day)
{
	_year = year;
	_month = month;
	_day = day;
}
void Date::Print()
{
	cout &lt;&lt; _year &lt;&lt; "年" &lt;&lt; _month &lt;&lt; "月" &lt;&lt; _day &lt;&lt; "日" &lt;&lt; endl;
}

Date Date::operator+(const int&amp; day)
{
	return *this;
}
Date Date::operator-(const int&amp; day)
{
	return *this;
}
</code></pre>
</blockquote>
<hr/>
<h3><a id="font_colorFF0033_testcppfont_75"></a><font color="#FF0033">test.cpp</font></h3>
<blockquote>
<p><code>test.cpp</code></p>
<p><img alt="image-20220120140259451" src="https://img-blog.csdnimg.cn/img_convert/c65e4262ad3ed96c917fe262b682ed66.png"/></p>
<pre><code class="prism language-c++">#include "Date.h"

int main()
{
	Date d(2022,1,1);
	d.Print();
	return 0;
}
</code></pre>
</blockquote>
<hr/>
<h3><a id="font_colorFF0033_font_94"></a><font color="#FF0033">测试情况</font></h3>
<blockquote>
<p><img alt="image-20220120140650926" src="https://img-blog.csdnimg.cn/img_convert/5487c67643ff9042ace76849b1840342.png"/></p>
</blockquote>
<hr/>
<h2><a id="font_color9400D3_font_100"></a><font color="#9400D3">功能添加</font></h2>
<blockquote>
<p>当我们能基本丐版跑出来了那我们接下来的路还是要走的，我们要考虑到数据是否合理啊什么的</p>
<p><img alt="image-20220120141407902" src="https://img-blog.csdnimg.cn/img_convert/c2aca97fde181e5f848aeca9477c4a7c.png"/></p>
<p><mark>所以我们需要检查日期的合法性</mark></p>
<p><img alt="image-20220120191252815" src="https://img-blog.csdnimg.cn/img_convert/b06043394fb1b6a45ed0c629f50ba9ab.png"/></p>
<p><mark>上面的确是排除了百分之99的滤掉了，但是闰年2月是特殊考虑的反而没有代码实现</mark></p>
<p><img alt="image-20220120200401862" src="https://img-blog.csdnimg.cn/img_convert/b70dba68520d6b8477e04b1f88f72626.png"/></p>
<p><img alt="image-20220120205730088" src="https://img-blog.csdnimg.cn/img_convert/240482616689a3fea0f3736c341610f8.png"/></p>
<p><mark>我们可不可以优化一下，比如我就输错了一个日期你就直接程序死了是不是有点太霸道了，你应该抛出异常，或隔一下啥的</mark></p>
<p><img alt="image-20220120213917747" src="https://img-blog.csdnimg.cn/img_convert/72848d8ee62782362a0cd0b127b16b08.png"/></p>
<pre><code class="prism language-c++">inline int GetMonthDay(int year, int month)
{
	//数组存放平年每个月的天数  刚好对应的下标是月 里面的元素是天
	static int dayArray[13] = { 0,31,28,31,30,31,30,31,31,30,31,30,31 };
	//该月天数
	int day = dayArray[month];
	//闰年是4年一润百年不润或者四百年一润
	if (month == 2 
	&amp;&amp; (year % 4 == 0 &amp;&amp; year % 100 != 0) 
	|| year % 400 == 0)
	{
		//闰年的2月是29天
		day = 29;
	}
	return day;
}
Date::Date(int year, int month, int day)
{
	//检查日期的合法性
	if (year &gt; 0
	 &amp;&amp; month &gt; 0 &amp;&amp; month &lt;13
	 &amp;&amp; day &gt; 0 &amp;&amp; day &lt;= GetMonthDay(year,month))
	{
		_year = year;
		_month = month;
		_day = day;
	}
	else
	{
		cout &lt;&lt; endl;
		cout &lt;&lt; "非法日期" &lt;&lt; endl;
		cout &lt;&lt; year &lt;&lt; "年" &lt;&lt; month &lt;&lt; "月" &lt;&lt; day &lt;&lt; "日" &lt;&lt; endl;
	}
}
void Date::Print()
{
	cout &lt;&lt; _year &lt;&lt; "年" &lt;&lt; _month &lt;&lt; "月" &lt;&lt; _day &lt;&lt; "日" &lt;&lt; endl;
}
</code></pre>
</blockquote>
<hr/>
<h3><a id="font_colorFF0033_font_163"></a><font color="#FF0033">日期加天数后那个日期</font></h3>
<blockquote>
<p><img alt="image-20220120224532776" src="https://img-blog.csdnimg.cn/img_convert/411aa93653cc0e68f8caf257f8df601d.png"/></p>
<p><img alt="image-20220120225026789" src="https://img-blog.csdnimg.cn/img_convert/7e394a4f4a939724525b86b1bcba77aa.png"/></p>
<pre><code class="prism language-c++">Date&amp; Date::operator+=(const int&amp; day)
{
	//我们先不管，我们先直接把天加上去
	_day += day;
	//然后再判断合不合法
	while (_day &gt; GetMonthDay(_year,_month))
	{
		//先把当月的天数减掉
		_day -= GetMonthDay(_year, _month);
	    //然后月++
		_month++;
		//假如月也过了就年++
		if (_month &gt; 12)
		{
			_year++;
			_month = 1;
		}
	}
	return *this;
}
</code></pre>
</blockquote>
<hr/>
<h3><a id="font_colorFF0033_font_194"></a><font color="#FF0033">日期加天数</font></h3>
<blockquote>
<p><mark>仅仅就是加没有赋值过去，要和上面那个分清了，所以我需要一个中间临时变量（这个我们叫临时对象）来存储运算后的数据</mark></p>
<p><img alt="image-20220120231955244" src="https://img-blog.csdnimg.cn/img_convert/8714c5db189586e0d67995caa13d4459.png"/></p>
<pre><code class="prism language-c++">//日期加天数 不赋回去
Date Date::operator+(const int&amp; day)
{
	//首先创建一个临时对象  先把之前的拷贝复制给他
	Date ret(*this);
	//复用+=
	ret += day;
	return ret;
}
</code></pre>
</blockquote>
<hr/>
<h3><a id="font_colorFF0033_font_214"></a><font color="#FF0033">日期++，++日期</font></h3>
<blockquote>
<p><mark>日期加加和加加日期都是++，但是operator运算符重载怎么区分呢，</mark></p>
</blockquote>
<h4><a id="font_color0000CC_font_218"></a><font color="#0000CC">前置++</font></h4>
<blockquote>
<p><mark>前置++返回运算以后的值</mark></p>
<p><img alt="image-20220121112821927" src="https://img-blog.csdnimg.cn/img_convert/95e35da3a210c64da990abb224daebe5.png"/></p>
<pre><code class="prism language-c++">//++d  日期前置++ 被转换成d.operator++(&amp;d)
Date&amp; Date::operator++()
{
	//返回运算后的值
	*this += 1;
	return *this;
}
</code></pre>
</blockquote>
<h4><a id="font_color0000CC_font_234"></a><font color="#0000CC">后置++</font></h4>
<blockquote>
<p><mark>后置++返回运算前的值</mark></p>
<p><img alt="image-20220121113138932" src="https://img-blog.csdnimg.cn/img_convert/9d8005e9f0030559b6be93fc23cb94c9.png"/></p>
<pre><code class="prism language-c++">//d++  日期后置++ 被转换成d.operator++(&amp;d,0)
//这里的int仅仅是占位，不需要给实参，起到函数重载的作用
Date&amp; Date::operator++(int)
{
	//后置++返回运算前的值
	//所以需要一个临时对象先存起来
	Date tmp(*this);
	*this += 1;
	return tmp;
}
</code></pre>
</blockquote>
<hr/>
<h3><a id="font_colorFF0033_font_257"></a><font color="#FF0033">日期减天数后那个日期</font></h3>
<blockquote>
<p><img alt="image-20220121005942011" src="https://img-blog.csdnimg.cn/img_convert/4681db0b16f139384acfa96d8737f38e.png"/></p>
<p><img alt="image-20220121004438291" src="https://img-blog.csdnimg.cn/img_convert/4515c0eb4b62b1aaaf15ec7a2d884474.png"/></p>
<pre><code class="prism language-c++">//日期减天数同时赋回去
Date&amp; Date::operator-=(const int&amp; day)
{
	//啥也不多说，先把天减掉
	_day -= day;
	//不合法就等他合法
	while (_day &lt;= 0)
	{
		//先把月减了
		_month--;
		//先判断月是不是零，是的话就操作年了
		if (_month &lt;= 0)
		{
			_year--;
			_month = 12;
		}
		//然后让他加上正确的月的天数
		_day += GetMonthDay(_year,_month);		
	}
	return *this;
}
</code></pre>
</blockquote>
<hr/>
<h3><a id="font_colorFF0033_font_289"></a><font color="#FF0033">日期减天数</font></h3>
<blockquote>
<p><mark>复用上面那个函数就行</mark></p>
<p><img alt="image-20220121091205743" src="https://img-blog.csdnimg.cn/img_convert/7ae8ba4f04c0a9b7f1f4805f4a3ce18b.png"/></p>
<pre><code class="prism language-c++">//日期减天数 不赋回去
Date Date::operator-(const int&amp; day)
{
	Date ret(*this);
	//-=的复用
	ret -= day;
	return ret;
}

</code></pre>
</blockquote>
<hr/>
<h3><a id="font_colorFF0033_font_309"></a><font color="#FF0033">日期–，--日期</font></h3>
<blockquote>
<p><mark>日期减减和减减日期都是–，但是operator运算符重载怎么区分呢，</mark></p>
</blockquote>
<h4><a id="font_color0000CC_font_313"></a><font color="#0000CC">前置–</font></h4>
<blockquote>
<p><mark>前置–返回运算以后的值</mark></p>
<p><img alt="image-20220121114232992" src="https://img-blog.csdnimg.cn/img_convert/9dc6423902dc5a1e9e0473905be36610.png"/></p>
<pre><code class="prism language-c++">//前置减减
Date&amp; Date::operator--()
{
	*this -= 1;
	return *this;
}
</code></pre>
</blockquote>
<h4><a id="font_color0000CC_font_328"></a><font color="#0000CC">后置–</font></h4>
<blockquote>
<p><mark>后置–返回运算前的值</mark></p>
<p><img alt="image-20220121114447971" src="https://img-blog.csdnimg.cn/img_convert/5a4543545ef2278fb78868887d6e0f6b.png"/></p>
<pre><code class="prism language-c++">//后置减减
Date&amp; Date::operator--(int)
{
	Date tmp(*this);
	*this -= 1;
	return tmp;
}
</code></pre>
</blockquote>
<hr/>
<h2><a id="font_color9400D3_bugfont_346"></a><font color="#9400D3">修一修bug</font></h2>
<h3><a id="font_colorFF0033_font_348"></a><font color="#FF0033">若是-=里面的日期是负数的话</font></h3>
<blockquote>
<p><mark>我们有时候是需要考虑日期里面是有负数的</mark></p>
<p><img alt="image-20220121091654820" src="https://img-blog.csdnimg.cn/img_convert/7da73792dc395d903a9f5ebfdccac52e.png"/></p>
<p><img alt="image-20220121093425208" src="https://img-blog.csdnimg.cn/img_convert/bc35b8bc76db967d5555c84011c0c80c.png"/></p>
<p><mark>所以需要我们改一下代码，需要+=的代码，直接挪用</mark></p>
<p><img alt="image-20220121093822460" src="https://img-blog.csdnimg.cn/img_convert/f2df7a611ac6b09b51b861c5fec7bf16.png"/></p>
<p><mark>复用即可</mark></p>
<p><img alt="image-20220121104420037" src="https://img-blog.csdnimg.cn/img_convert/5ebeb25ad3c28ab7c6ad88bf2504dfb8.png"/></p>
<pre><code class="prism language-c++">//日期减天数同时赋回去
Date&amp; Date::operator-=(const int&amp; day)
{
	//每月天数超过他本身了也是违法的
	//复用+=即可
	if (day &lt; 0)
	{
		*this += -day;
	}
	else
	{
		//啥也不多说，先把天减掉
		_day -= day;
		//不合法就等他合法
		while (_day &lt;= 0)
		{
			//先把月减了
			_month--;
			//先判断月是不是零，是的话就操作年了
			if (_month &lt;= 0)
			{
				_year--;
				_month = 12;
			}
			//然后让他加上正确的月的天数
			_day += GetMonthDay(_year, _month);
		}
	}	
	return *this;
}
</code></pre>
</blockquote>
<hr/>
<h3><a id="font_colorFF0033_font_399"></a><font color="#FF0033">若是+=里面的日期是负数的话</font></h3>
<blockquote>
<p><mark>同样的+=里面有负数也是一样的处理</mark></p>
<p><img alt="image-20220121095701512" src="https://img-blog.csdnimg.cn/img_convert/f2c6bbf9e970ceeb91bef990f89a48aa.png"/></p>
<p><mark>所以我们也把-=的代码拎过来</mark></p>
<p><img alt="image-20220121100048995" src="https://img-blog.csdnimg.cn/img_convert/2d5a67b34736599ce37edc88212874fa.png"/></p>
<p><mark>同理复用即可</mark></p>
<p><img alt="image-20220121104225069" src="https://img-blog.csdnimg.cn/img_convert/4bcd712714d0cf7c9f6f21c330c27313.png"/></p>
<pre><code class="prism language-c++">//日期加天数同时赋回去
Date&amp; Date::operator+=(const int&amp; day)
{
	//负数复用-=的
	if (day &lt; 0)
	{
		*this -= -day;
	}
	else
	{
		//我们先不管，我们先直接把天加上去
		_day += day;
		//然后再判断合不合法
		while (_day &gt; GetMonthDay(_year, _month))
		{
			//先把当月的天数减掉
			_day -= GetMonthDay(_year, _month);
			//然后月++
			_month++;
			//假如月也过了就年++
			if (_month &gt; 12)
			{
				_year++;
				_month = 1;
			}
		}
	}
	return *this;
}

</code></pre>
</blockquote>
<hr/>
<h2><a id="font_color9400D3_font_448"></a><font color="#9400D3">比较运算符</font></h2>
<h3><a id="font_colorFF0033__font_450"></a><font color="#FF0033">大于 &gt;</font></h3>
<blockquote>
<p><mark>d1 &gt; d2</mark></p>
<p><img alt="image-20220121133559345" src="https://img-blog.csdnimg.cn/img_convert/88db96e57c99e3f819b2bff5b5db3460.png"/></p>
<pre><code class="prism language-c++">//比较
//大于  d1 &gt; d2转换成d1.operator&gt;(&amp;d1,d2)
bool Date::operator&gt;(const Date&amp; d)
{
	if (_year &gt; d._year)
	{
		return true;
	}
	else if (_year == d._year)
	{
		if (_month &gt; d._month)
		{
			return true;
		}
		else if(_month == d._month)
		{
			if (_day &gt; d._day)
				return true;
		}
	}
	//不是上面情况就false
	return false;
}
</code></pre>
</blockquote>
<hr/>
<h3><a id="font_colorFF0033___font_484"></a><font color="#FF0033">等于 == </font></h3>
<blockquote>
<p><mark>d1 == d2</mark></p>
<p><img alt="image-20220121133931343" src="https://img-blog.csdnimg.cn/img_convert/e3e13c633a458321c9e3612d1596fcec.png"/></p>
<pre><code class="prism language-c++">//等于
bool Date::operator==(const Date&amp; d)
{
	return _year == d._year
		&amp;&amp; _month == d._month
		&amp;&amp; _day == d._day;
}
</code></pre>
</blockquote>
<hr/>
<h3><a id="font_colorFF0033___font_502"></a><font color="#FF0033">大于等于 &gt;= </font></h3>
<blockquote>
<p><mark>d1 &gt;= d2</mark></p>
<p><img alt="image-20220121134249151" src="https://img-blog.csdnimg.cn/img_convert/8f447f23c4b372fee5d21014253d723a.png"/></p>
<pre><code class="prism language-c++">//大于等于
bool Date::operator&gt;=(const Date&amp; d)
{
	return *this &gt; d || *this == d;
}
</code></pre>
</blockquote>
<hr/>
<h3><a id="font_colorFF0033__font_518"></a><font color="#FF0033">小于&lt; </font></h3>
<blockquote>
<p><mark>d1 &lt; d2</mark></p>
<p><img alt="image-20220121134534106" src="https://img-blog.csdnimg.cn/img_convert/9502f3aabc3f35ede742ea6d114fb078.png"/></p>
<pre><code class="prism language-c++">//小于
bool Date::operator&lt;(const Date&amp; d)
{
	return !(*this &gt;= d);
}

</code></pre>
</blockquote>
<hr/>
<h3><a id="font_colorFF0033___font_535"></a><font color="#FF0033">小于等于 &lt;= </font></h3>
<blockquote>
<p><mark>d1 &lt;= d2</mark></p>
<p><img alt="image-20220121134843174" src="https://img-blog.csdnimg.cn/img_convert/f04a8b694d8a6ec0221ddfa2d0b01731.png"/></p>
<pre><code class="prism language-c++">//小于等于
bool Date::operator&lt;=(const Date&amp; d)
{
	return !(*this &gt; d);
}
</code></pre>
</blockquote>
<hr/>
<h3><a id="font_colorFF0033___font_551"></a><font color="#FF0033">不等于 != </font></h3>
<blockquote>
<p><mark>d1 != d2</mark></p>
<p><img alt="image-20220121135124953" src="https://img-blog.csdnimg.cn/img_convert/3ace342b884c9a1f5efe33b8cc461a28.png"/></p>
<pre><code class="prism language-c++">//不等于
bool Date::operator!=(const Date&amp; d)
{
	return !(*this == d);
}
</code></pre>
</blockquote>
<hr/>
<h2><a id="font_color9400D3_font_567"></a><font color="#9400D3">生活实际</font></h2>
<h3><a id="font_colorFF0033_font_569"></a><font color="#FF0033">我们思考一个问题就是日期减日期有没有意义</font></h3>
<blockquote>
<p>日期减日期是不是就是相差多少天，那你这个怎么操作呢</p>
<p><img alt="image-20220121155031505" src="https://img-blog.csdnimg.cn/img_convert/fe986fc0f0f465c823b8cabea5be05bd.png"/></p>
<pre><code class="prism language-c++">
//日期减日期
//通过计数的方式来  要是年减年 月减月就是无法找到实际多少天了
int Date::operator-(const Date&amp; d)
{
	//首先假设前面的大
	Date max = *this;
	//所以后面的就小
	Date min = d;
	//符号标记
	int flag = 1;
	//如果错了就交换
	if (max &lt; min)
	{
		max = d;
		min = *this;
		flag = -1;
	}
	//当min与max相同时就是停止计数的时候
	int count = 0;
	while (min != max)
	{
		min++;
		count++;
	}
	//出来就把计数返回出去顺带着标记
	return count * flag;
}
</code></pre>
</blockquote>
<hr/>
<h2><a id="font_color9400D3_font_608"></a><font color="#9400D3">代码</font></h2>
<h3><a id="font_colorFF0033_Datehfont_610"></a><font color="#FF0033">Date.h</font></h3>
<blockquote>
<p><code>Date.h</code></p>
<pre><code class="prism language-c++">#pragma once
#include &lt;iostream&gt;
#include &lt;assert.h&gt;
using std::cout;
using std::cin;
using std::endl;

class Date
{
public:
	Date(int year = 0, int month = 1, int day = 1);
	void Print();
	//像析构，拷贝构造，赋值重载可以不需要写，因为默认生成的就够用了，
	//像Stack才需要自己写这三个
	
	//日期加 减天数  然后同时赋值赋过去
	Date&amp; operator+=(const int&amp; day);
	Date&amp; operator-=(const int&amp; day);
	//日期加 减天数  不需要赋值
	Date operator+(const int&amp; day);
	Date operator-(const int&amp; day);
	//日期前置后置加加
	Date&amp; operator++();
	Date&amp; operator++(int);
	//日期前置后置减减
	Date&amp; operator--();
	Date&amp; operator--(int);
	//比较
	bool operator&gt;(const Date&amp; d);
	bool operator&lt;(const Date&amp; d);
	bool operator&gt;=(const Date&amp; d);
	bool operator&lt;=(const Date&amp; d);
	bool operator==(const Date&amp; d);
	bool operator!=(const Date&amp; d);
	//日期减日期
	int operator-(const Date&amp; d);
private:
	int _year;
	int _month;
	int _day;
};

</code></pre>
</blockquote>
<hr/>
<h3><a id="font_colorFF0033_Datecppfont_661"></a><font color="#FF0033">Date.cpp</font></h3>
<blockquote>
<p><code>Date.cpp</code></p>
<pre><code class="prism language-c++">#include "Date.h"

inline int GetMonthDay(int year, int month)
{
	//数组存放平年每个月的天数  刚好对应的下标是月 里面的元素是天
	static int dayArray[13] = { 0,31,28,31,30,31,30,31,31,30,31,30,31 };
	//该月天数
	int day = dayArray[month];
	//闰年是4年一润百年不润或者四百年一润
	if (month == 2 
	&amp;&amp; (year % 4 == 0 &amp;&amp; year % 100 != 0) 
	|| year % 400 == 0)
	{
		//闰年的2月是29天
		day = 29;
	}
	return day;
}

//构造函数
Date::Date(int year, int month, int day)
{
	//检查日期的合法性
	if (year &gt; 0
	 &amp;&amp; month &gt; 0 &amp;&amp; month &lt;13
	 &amp;&amp; day &gt; 0 &amp;&amp; day &lt;= GetMonthDay(year,month))
	{
		_year = year;
		_month = month;
		_day = day;
	}
	else
	{
		cout &lt;&lt; endl;
		cout &lt;&lt; "非法日期" &lt;&lt; endl;
		cout &lt;&lt; year &lt;&lt; "年" &lt;&lt; month &lt;&lt; "月" &lt;&lt; day &lt;&lt; "日" &lt;&lt; endl;
	}
}

//日期打印
void Date::Print()
{
	cout &lt;&lt; _year &lt;&lt; "年" &lt;&lt; _month &lt;&lt; "月" &lt;&lt; _day &lt;&lt; "日" &lt;&lt; endl;
}

//日期加天数同时赋回去
Date&amp; Date::operator+=(const int&amp; day)
{
	//负数复用-=的
	if (day &lt; 0)
	{
		*this -= -day;
	}
	else
	{
		//我们先不管，我们先直接把天加上去
		_day += day;
		//然后再判断合不合法
		while (_day &gt; GetMonthDay(_year, _month))
		{
			//先把当月的天数减掉
			_day -= GetMonthDay(_year, _month);
			//然后月++
			_month++;
			//假如月也过了就年++
			if (_month &gt; 12)
			{
				_year++;
				_month = 1;
			}
		}
	}
	return *this;
}

//日期加天数 不赋回去
Date Date::operator+(const int&amp; day)
{
	//首先创建一个临时对象  先把之前的拷贝复制给他
	Date ret(*this);
	//复用+=
	ret += day;
	return ret;
}

//++d  日期前置++ 被转换成d.operator++(&amp;d)
Date&amp; Date::operator++()
{
	//返回运算后的值
	*this += 1;
	return *this;
}
//d++  日期后置++ 被转换成d.operator++(&amp;d,0)
//这里的int仅仅是占位，不需要给实参，起到函数重载的作用
Date&amp; Date::operator++(int)
{
	//后置++返回运算前的值
	//所以需要一个临时对象先存起来
	Date tmp(*this);
	*this += 1;
	return tmp;
}

//日期减天数同时赋回去
Date&amp; Date::operator-=(const int&amp; day)
{
	//每月天数超过他本身了也是违法的
	//复用+=即可
	if (day &lt; 0)
	{
		*this += -day;
	}
	else
	{
		//啥也不多说，先把天减掉
		_day -= day;
		//不合法就等他合法
		while (_day &lt;= 0)
		{
			//先把月减了
			_month--;
			//先判断月是不是零，是的话就操作年了
			if (_month &lt;= 0)
			{
				_year--;
				_month = 12;
			}
			//然后让他加上正确的月的天数
			_day += GetMonthDay(_year, _month);
		}
	}	
	return *this;
}

//日期减天数 不赋回去
Date Date::operator-(const int&amp; day)
{
	Date ret(*this);
	//-=的复用
	ret -= day;
	return ret;
}

//前置减减
Date&amp; Date::operator--()
{
	*this -= 1;
	return *this;
}

//后置减减
Date&amp; Date::operator--(int)
{
	Date tmp(*this);
	*this -= 1;
	return tmp;
}

//比较
//大于  d1 &gt; d2转换成d1.operator&gt;(&amp;d1,d2)
bool Date::operator&gt;(const Date&amp; d)
{
	if (_year &gt; d._year)
	{
		return true;
	}
	else if (_year == d._year)
	{
		if (_month &gt; d._month)
		{
			return true;
		}
		else if(_month == d._month)
		{
			if (_day &gt; d._day)
				return true;
		}
	}
	//不是上面情况就false
	return false;
}
//等于
bool Date::operator==(const Date&amp; d)
{
	return _year == d._year
		&amp;&amp; _month == d._month
		&amp;&amp; _day == d._day;
}
//大于等于
bool Date::operator&gt;=(const Date&amp; d)
{
	return *this &gt; d || *this == d;
}
//小于
bool Date::operator&lt;(const Date&amp; d)
{
	return !(*this &gt;= d);
}

//小于等于
bool Date::operator&lt;=(const Date&amp; d)
{
	return !(*this &gt; d);
}

//不等于
bool Date::operator!=(const Date&amp; d)
{
	return !(*this == d);
}

//日期减日期
//通过计数的方式来  要是年减年 月减月就是无法找到实际多少天了
int Date::operator-(const Date&amp; d)
{
	//首先假设前面的大
	Date max = *this;
	//所以后面的就小
	Date min = d;
	//符号标记
	int flag = 1;
	//如果错了就交换
	if (max &lt; min)
	{
		max = d;
		min = *this;
		flag = -1;
	}
	//当min与max相同时就是停止计数的时候
	int count = 0;
	while (min != max)
	{
		min++;
		count++;
	}
	//出来就把计数返回出去顺带着标记
	return count * flag;
}




</code></pre>
</blockquote>
<h3><a id="font_colorFF0033_testcppfont_910"></a><font color="#FF0033">test.cpp</font></h3>
<blockquote>
<p><code>test.cpp</code></p>
<pre><code class="prism language-cPP">#include "Date.h"

void test1()
{
	//前置++和后置++都完成++，不同的地方在于是返回值不同
	Date d(2022, 1, 1);
	d ++;
	//后置++返回++以前的值
	d.Print();

	++d;
	//前置++返回++以后的值
	d.Print();
}

void test2()
{
	//前置--和后置--都完成--，不同的地方在于是返回值不同
	Date d(2022, 1, 1);
	d--;
	//后置--返回--以前的值
	d.Print();

	--d;
	//前置--返回--以后的值
	d.Print();
}
void test3()
{
	Date d1(2022, 1, 2);
	Date d2(2022, 1, 2);
	cout &lt;&lt; (d1 != d2) &lt;&lt; endl;
	d2 -= 1;
	cout &lt;&lt; (d1 != d2) &lt;&lt; endl;
}

void test4()
{
	Date d1(2024, 1, 2);
	Date d2(2022, 5, 7);
	cout &lt;&lt; d1 - d2 &lt;&lt; endl;
	cout &lt;&lt; d2 - d1 &lt;&lt; endl;
}


int main()
{
	test1();
	test2();
	test3();
	test4();

	Date d(2022,1,1);
	d += -40;
	d.Print();

	Date d2(2022, 1, 1);
	d2 += 4000;
	d2.Print();

	Date d3(2022, 1, 1);
	d3 = d3 + 3000;
	d3.Print();

	Date d4(2022, 1, 1);
	d4 -= -3000;
	d4.Print();

	Date d5(2022, 1, 1);
	d5 = d5-2000;
	d5.Print();
	return 0;
}
</code></pre>
</blockquote>
</div>
<link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css" rel="stylesheet"/>
<link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css" rel="stylesheet"/>
</div>