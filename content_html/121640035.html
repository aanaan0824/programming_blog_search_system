<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<p id="main-toc"><strong>目录</strong></p>
<p id="%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#%E5%89%8D%E8%A8%80">前言</a></p>
<p id="%E6%AD%A3%E6%96%87-toc" style="margin-left:0px;"><a href="#%E6%AD%A3%E6%96%87">正文</a></p>
<p id="%E6%8F%92%E6%A7%BD%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-toc" style="margin-left:40px;"><a href="#%E6%8F%92%E6%A7%BD%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">插槽是什么？</a></p>
<p id="%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%E6%8F%92%E6%A7%BD%EF%BC%9F-toc" style="margin-left:40px;"><a href="#%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%E6%8F%92%E6%A7%BD%EF%BC%9F">怎么使用插槽？</a></p>
<p id="%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95-toc" style="margin-left:80px;"><a href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95">基本用法</a></p>
<p id="%E5%90%8E%E5%A4%87%EF%BC%88%E9%BB%98%E8%AE%A4%EF%BC%89%E5%86%85%E5%AE%B9-toc" style="margin-left:80px;"><a href="#%E5%90%8E%E5%A4%87%EF%BC%88%E9%BB%98%E8%AE%A4%EF%BC%89%E5%86%85%E5%AE%B9">后备（默认）内容</a></p>
<p id="%E5%85%B7%E5%90%8D%E6%8F%92%E6%A7%BD-toc" style="margin-left:80px;"><a href="#%E5%85%B7%E5%90%8D%E6%8F%92%E6%A7%BD">具名插槽</a></p>
<p id="%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD-toc" style="margin-left:80px;"><a href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD">作用域插槽</a></p>
<p id="%E6%8F%92%E6%A7%BD%E7%89%88%E6%9C%AC%E5%8F%98%E5%8C%96-toc" style="margin-left:80px;"><a href="#%E6%8F%92%E6%A7%BD%E7%89%88%E6%9C%AC%E5%8F%98%E5%8C%96">插槽版本变化</a></p>
<p id="%E6%80%BB%E7%BB%93-toc" style="margin-left:0px;"><a href="#%E6%80%BB%E7%BB%93">总结</a></p>
<hr id="hr-toc"/>
<h1>前言</h1>
<p>Vue中的插槽（slot）在项目中用的也是比较多的，今天就来介绍一下插槽的基本使用以及Vue版本更新之后的插槽用法变化。</p>
<h1 id="%E6%AD%A3%E6%96%87">正文</h1>
<h2 id="%E6%8F%92%E6%A7%BD%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">插槽是什么？</h2>
<p>插槽就是子组件中的提供给父组件使用的一个占位符，用&lt;slot&gt;&lt;/slot&gt; 表示，父组件可以在这个占位符中填充任何模板代码，如 HTML、组件等，填充的内容会替换子组件的&lt;slot&gt;&lt;/slot&gt;标签。简单理解就是子组件中留下个“坑”，父组件可以使用指定内容来补“坑”。以下举例子帮助理解。</p>
<h2 id="%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%E6%8F%92%E6%A7%BD%EF%BC%9F">怎么使用插槽？</h2>
<h3 id="%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95">基本用法</h3>
<p>现在，有两个组件，A与B，分别如下：</p>
<p>A.vue</p>
<pre><code class="language-javascript">&lt;template&gt;
  &lt;div&gt;
    &lt;p&gt;我是A组件&lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name:'A',
  data(){
    return {

    }
  }
}
&lt;/script&gt;</code></pre>
<p>B.vue</p>
<pre><code class="language-javascript">&lt;template&gt;
  &lt;div&gt;
    &lt;p&gt;我是B组件&lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name:'B',
  data(){
    return {

    }
  }
}
&lt;/script&gt;</code></pre>
<p>将B组件引入A组件里面（此时B为A的子组件）</p>
<pre><code class="language-javascript">&lt;template&gt;
  &lt;div&gt;
    &lt;p&gt;我是A组件&lt;/p&gt;
    &lt;B&gt;&lt;B/&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import B from './B.vue'    //引入B组件
export default {
  name:'A',
  components:{      //注册B组件
    B
  },
  data(){
    return {

    }
  }
}
&lt;/script&gt;</code></pre>
<p>页面效果如下：</p>
<p><img alt="" height="396" src="image\1bd06df062c54f7d8ba4fefd40035cb2.png" width="806"/></p>
<p>准备工作完毕，现在，在B组件里面使用插槽（slot）</p>
<pre><code class="language-javascript">&lt;template&gt;
  &lt;div&gt;
    &lt;p&gt;我是B组件&lt;/p&gt;
    &lt;slot&gt;&lt;/slot&gt;     //插槽的使用方式
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name:'B',
  data(){
    return {

    }
  }
}
&lt;/script&gt;</code></pre>
<p>此时页面并无变化（最开始的情况），当然，B组件中使用了插槽slot之后，相当于留下了一个“坑”，占了个位置。 那么如何验证其存在了呢？</p>
<p>此时，修改A组件里面的代码</p>
<pre><code class="language-javascript">&lt;template&gt;
  &lt;div&gt;
    &lt;p&gt;我是A组件&lt;/p&gt;
    &lt;B&gt;  
      验证插槽是否生效      //用B组件标签包裹内容，验证slot
    &lt;/B&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import B from './B.vue'
export default {
  name:'A',
  components:{
    B
  },
  data(){
    return {

    }
  }
}
&lt;/script&gt;</code></pre>
<p>此时页面的效果如下：</p>
<p><img alt="" height="404" src="image\eb96cc317ef442d18f436cb78f6aa1ab.png" width="813"/>页面中多出了在A中用B包裹的内容。没错，这就是插槽的基本使用，是不是很简单？</p>
<p>Vue 实现了一套内容分发的 API，这套 API 的设计灵感源自 <a href="https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md" title="Web Components 规范草案">Web Components 规范草案</a>，将 <code>&lt;slot&gt;</code> 元素作为承载分发内容的出口。</p>
<p>如上面的例子，当组件渲染的时候，<code>&lt;slot&gt;&lt;/slot&gt;</code> 将会被替换为“验证插槽是否生效”（即指定内容）。插槽内可以包含任何模板代码，包括 HTML：</p>
<pre><code class="language-javascript">&lt;template&gt;
  &lt;div class="main"&gt;
    &lt;p&gt;我是A组件&lt;/p&gt;
    &lt;B&gt;
      &lt;span style="color:red"&gt;验证插槽是否生效&lt;/span&gt;    //内容为html
    &lt;/B&gt;
  &lt;/div&gt;
&lt;/template&gt;</code></pre>
<p>页面效果如下：</p>
<p><img alt="" height="398" src="image\ec23ee96b6274eeda453e03798c10b85.png" width="796"/>插槽内也可以放其他组件，如此时再新建一个组件C：</p>
<pre><code class="language-javascript">&lt;template&gt;
  &lt;div&gt;
    &lt;p&gt;我是C组件&lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name:'C',
  data(){
    return {

    }
  }
}
&lt;/script&gt;</code></pre>
<p>在A组件中，将B组件包裹的内容换成C组件：</p>
<pre><code class="language-javascript">&lt;template&gt;
  &lt;div class="main"&gt;
    &lt;p&gt;我是A组件&lt;/p&gt;
    &lt;B&gt;
      &lt;!-- &lt;span style="color:red"&gt;验证插槽是否生效&lt;/span&gt; --&gt;
      &lt;C /&gt;         //插入C组件
    &lt;/B&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import B from './B.vue'
import C from './C.vue'   //引入C组件
export default {
  name:'A',
  components:{
    B,
    C      //注册C组件
  },
  data(){
    return {

    }
  }
}
&lt;/script&gt;</code></pre>
<p>页面效果如下：</p>
<p><img alt="" height="393" src="image\a52d3431777140249931671073a005cb.png" width="807"/>此时检查页面元素，我们会发现，在原本B组件中&lt;slot&gt;&lt;/slot&gt;的位置，替换成了C组件：  </p>
<pre><code class="language-javascript">//B.vue
&lt;template&gt;
  &lt;div&gt;
    &lt;p&gt;我是B组件&lt;/p&gt;
    &lt;slot&gt;&lt;/slot&gt;
  &lt;/div&gt;
&lt;/template&gt;

//观察页面元素,&lt;slot&gt;&lt;/slot&gt;被替换成C组件</code></pre>
<p><img alt="" height="266" src="image\893809431c4e418db0818b5458efb59a.png" width="909"/></p>
<p>也印证了开篇对插槽作用的解释，即使用&lt;slot&gt;&lt;/slot&gt;的组件指定的位置留一个坑，如果在外部，使用其组件包裹某内容（可以是任何模板代码，也可以是HTML，还可以是组件），则该内容就会被分发到&lt;slot&gt;&lt;/slot&gt;处（一个有趣的说法就是把“坑”补上），渲染出来。当然，也可以不放任何内容，不影响组件渲染，就好比最开始的情况。</p>
<p>注意：如果B组件的 <code>template</code> 中<strong>没有</strong>包含一个 <code>&lt;slot&gt;</code> 元素，即不使用插槽，则该组件起始标签和结束标签之间的任何内容都会被抛弃。例如：</p>
<pre><code class="language-javascript">//B.vue
&lt;template&gt;
  &lt;div&gt;
    &lt;p&gt;我是B组件&lt;/p&gt;
    &lt;!-- &lt;slot&gt;&lt;/slot&gt; --&gt;   //不使用插槽
  &lt;/div&gt;
&lt;/template&gt;</code></pre>
<pre><code class="language-javascript">//A.vue
&lt;template&gt;
  &lt;div&gt;
    &lt;p&gt;我是A组件&lt;/p&gt;
    &lt;B&gt;
      &lt;!-- &lt;span style="color:red"&gt;验证插槽是否生效&lt;/span&gt; --&gt;
      &lt;C /&gt;
    &lt;/B&gt;
  &lt;/div&gt;
&lt;/template&gt;

//此时在&lt;B&gt;&lt;/B&gt;包裹的内容都会被抛弃</code></pre>
<p>页面效果如下，在B组件中插入的C组件被抛弃了，因为B组件中没使用插槽：</p>
<p><img alt="" height="393" src="image\d6ad73d6a9d244a1ac37ce43c663ab20.png" width="792"/></p>
<h3 id="%E5%90%8E%E5%A4%87%EF%BC%88%E9%BB%98%E8%AE%A4%EF%BC%89%E5%86%85%E5%AE%B9">后备（默认）内容</h3>
<p>有时为一个插槽设置具体的后备 (也就是默认的) 内容是很有用的，它只会在没有提供内容的时候被渲染。例如在B组件中：</p>
<pre><code class="language-javascript">&lt;template&gt;
  &lt;div&gt;
    &lt;slot&gt;&lt;/slot&gt;
  &lt;/div&gt;
&lt;/template&gt;</code></pre>
<p>我们可能希望这个B组件内绝大多数情况下都渲染文本“我是B组件”。为了将“我是B组件”作为后备内容，我们可以将它放在 <code>&lt;slot&gt;</code> 标签内：</p>
<pre><code class="language-javascript">&lt;template&gt;
  &lt;div&gt;
    &lt;slot&gt;&lt;p&gt;我是B组件&lt;/p&gt;&lt;/slot&gt;
  &lt;/div&gt;
&lt;/template&gt;</code></pre>
<p>现在当我在一个父级组件中使用B组件并且不提供任何插槽内容时：</p>
<pre><code class="language-javascript">&lt;B&gt;&lt;/B&gt;</code></pre>
<p>后备内容“我是B组件”将会被渲染：</p>
<p><img alt="" height="161" src="image\30f069e48534470fa3ba9fa4fe0f1b08.png" width="729"/>但是如果我们提供内容： </p>
<pre><code class="language-javascript">&lt;B&gt;
  &lt;p&gt;我是插槽内容&lt;/p&gt;
&lt;/B&gt;</code></pre>
<p>则这个提供的内容将会被渲染从而取代后备内容： </p>
<p><img alt="" height="155" src="image\c70c089571674b40b8f13f0cd68dfdfe.png" width="732"/></p>
<h3 id="%E5%85%B7%E5%90%8D%E6%8F%92%E6%A7%BD">具名插槽</h3>
<p>所谓具名插槽，顾名思义就是起了名字的插槽。有时我们需要多个插槽，例如当我们想使用某种通用模板：</p>
<pre><code class="language-javascript">&lt;template&gt;
  &lt;div&gt;
    &lt;header&gt;
      &lt;!-- 我们希望把页头放这里 --&gt;
    &lt;/header&gt;
    &lt;main&gt;
      &lt;!-- 我们希望把主要内容放这里 --&gt;
    &lt;/main&gt;
    &lt;footer&gt;
      &lt;!-- 我们希望把页脚放这里 --&gt;
    &lt;/footer&gt;
  &lt;/div&gt;
&lt;/template&gt;</code></pre>
<p>对于这样的情况，<code>&lt;slot&gt;</code> 元素有一个特殊的 attribute：<code>name</code>。这个 attribute 可以用来定义额外的插槽： </p>
<pre><code class="language-javascript">//B.vue
&lt;template&gt;
  &lt;div&gt;
    &lt;header&gt;
      &lt;slot name="header"&gt;&lt;/slot&gt;
    &lt;/header&gt;
    &lt;main&gt;
      &lt;slot&gt;&lt;/slot&gt;
    &lt;/main&gt;
    &lt;footer&gt;
      &lt;slot name="footer"&gt;&lt;/slot&gt;
    &lt;/footer&gt;
  &lt;/div&gt;
&lt;/template&gt;</code></pre>
<p>一个不带 <code>name</code> 的 <code>&lt;slot&gt;</code> 出口会带有隐含的名字“default”。</p>
<p>在向具名插槽提供内容的时候，我们可以在一个 <code>&lt;template&gt;</code> 元素上使用 <code>slot</code> 指令，并以 <code>slot</code> 的参数的形式提供其名称（当然也可以直接放在标签中，如&lt;div slot="header"&gt;）：</p>
<pre><code class="language-javascript">&lt;template&gt;
  &lt;div&gt;
    &lt;p&gt;我是A组件&lt;/p&gt;
    &lt;B&gt;
      &lt;template slot="header"&gt;
        &lt;p&gt;我是header部分&lt;/p&gt;
      &lt;/template&gt;

      &lt;p&gt;我是main（默认插槽）部分&lt;/p&gt;

      &lt;template slot="footer"&gt;
        &lt;p&gt;我是footer部分&lt;/p&gt;
      &lt;/template&gt;
    &lt;/B&gt;
  &lt;/div&gt;
&lt;/template&gt;</code></pre>
<p>现在 <code>&lt;template&gt;</code> 元素中的所有内容都将会被传入相应的插槽。任何没有被包裹在带有<code>slot</code> 的 <code>&lt;template&gt;</code> 中的内容都会被视为默认插槽的内容。</p>
<p>页面效果如下：</p>
<p><img alt="" height="405" src="image\a481e32bd1854eaeab83e9111b9420c3.png" width="808"/></p>
<p>观察页面元素，内容被放入相应名字的插槽中：</p>
<p><img alt="" height="290" src="image\4b1451bac9754fc3aca475535db7ff81.png" width="861"/>Tips：说到这里就不得不提一下，这种方式在项目中比较常用，可以当成一个复用（通用）模板组件。如多个组件的布局使用相似模板，只是具体内容不同，那么我们可以使用这种插槽方式封装成一个通用组件，在其他组件使用的时候只需要传对应的内容到对应名字的插槽即可，不需要将该模板在每个组件重新写一遍，减少代码冗余，大大提高开发效率。</p>
<h3 id="%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD">作用域插槽</h3>
<p>有时让插槽内容能够访问子组件中才有的数据是很有用的。现在，假设B组件：</p>
<pre><code class="language-javascript">&lt;template&gt;
  &lt;div&gt;
    &lt;p&gt;我是B组件&lt;/p&gt;
    &lt;slot&gt;{<!-- -->{obj.firstName}}&lt;/slot&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name:'B',
  data(){
    return {
      obj:{
        firstName:'leo',
        lastName:'lion'
      }
    }
  }
}
&lt;/script&gt;</code></pre>
<p>我们可能想换掉备用内容，用“lion”来显示。如下，在A组件：</p>
<pre><code class="language-javascript">&lt;template&gt;
  &lt;div&gt;
    &lt;p&gt;我是A组件&lt;/p&gt;
    &lt;B&gt;
      {<!-- -->{obj.lastName}}
    &lt;/B&gt;
  &lt;/div&gt;
&lt;/template&gt;</code></pre>
<p>然而上述代码不会正常工作，因为只有B组件可以访问到 obj，而我们提供的内容是在父级渲染的，即在父级作用域中。页面并无变化：</p>
<p><img alt="" height="393" src="image\082ddb40b0564b6397fdb3d5e8997460.png" width="777"/>为了让 obj在父级的插槽内容中可用，我们可以将 obj作为 <code>&lt;slot&gt;</code> 元素的一个 attribute 绑定上去：</p>
<pre><code class="language-javascript">&lt;template&gt;
  &lt;div&gt;
    &lt;p&gt;我是B组件&lt;/p&gt;
    &lt;slot :obj="obj"&gt;{<!-- -->{obj.firstName}}&lt;/slot&gt;
  &lt;/div&gt;
&lt;/template&gt;</code></pre>
<p>绑定在 <code>&lt;slot&gt;</code> 元素上的 attribute 被称为<strong>插槽 prop</strong>。现在在父级作用域中，我们可以使用带值的 <code>slot-scope</code> 来定义我们提供的插槽 prop 的名字：</p>
<pre><code class="language-javascript">&lt;template&gt;
  &lt;div class="main"&gt;
    &lt;p&gt;我是A组件&lt;/p&gt;
    &lt;B&gt;
      &lt;template slot-scope="data"&gt;
        {<!-- -->{data.obj.lastName}}
      &lt;/template&gt;
    &lt;/B&gt;
  &lt;/div&gt;
&lt;/template&gt;</code></pre>
<p>在这个例子中，我们选择将包含所有插槽 prop 的对象命名为 data，但你也可以使用任意你喜欢的名字。此时页面效果如下：</p>
<p><img alt="" height="401" src="image\f221449f2c3046aaa6d046c3c653abf1.png" width="786"/>如果你有使用过ElementUI里面的表格el-table，当改变某一列展示的字段时，我们经常使用：</p>
<pre><code class="language-javascript">&lt;el-table-column&gt;
  &lt;template slot-scope="scope"&gt;
    &lt;span&gt;{<!-- -->{scope.row.xxx}}&lt;/span&gt;
  &lt;/template&gt;
&lt;/el-table-column&gt;
</code></pre>
<h3 id="%E6%8F%92%E6%A7%BD%E7%89%88%E6%9C%AC%E5%8F%98%E5%8C%96">插槽版本变化</h3>
<p><code>v-slot</code> 指令自 Vue 2.6.0 起被引入，提供更好的支持 <code>slot</code> 和 <code>slot-scope</code> attribute 的 API 替代方案。<code>v-slot</code> 完整的由来参见这份 <a href="https://github.com/vuejs/rfcs/blob/master/active-rfcs/0001-new-slot-syntax.md" title="RFC">RFC</a>。在接下来所有的 2.x 版本中 <code>slot</code> 和 <code>slot-scope</code> attribute 仍会被支持，但已经被官方废弃且不会出现在 Vue 3 中。也就是说，在vue2版本中，我们仍可以使用slot跟slot-scope，但是在vue3中就只能使用v-slot了。</p>
<p>原来的带有slot的具名插槽</p>
<pre><code class="language-javascript">//B.vue
&lt;template&gt;
  &lt;div&gt;
    &lt;header&gt;
      &lt;slot name="header"&gt;&lt;/slot&gt;
    &lt;/header&gt;
    &lt;main&gt;
      &lt;slot&gt;&lt;/slot&gt;
    &lt;/main&gt;
    &lt;footer&gt;
      &lt;slot name="footer"&gt;&lt;/slot&gt;
    &lt;/footer&gt;
  &lt;/div&gt;
&lt;/template&gt;</code></pre>
<p>写法变化，使用v-slot</p>
<pre><code class="language-javascript">&lt;template&gt;
  &lt;div&gt;
    &lt;p&gt;我是A组件&lt;/p&gt;
    &lt;B&gt;
      &lt;template v-slot:header&gt;
        &lt;p&gt;我是header部分&lt;/p&gt;
      &lt;/template&gt;

      &lt;p&gt;我是main（默认插槽）部分&lt;/p&gt;

      &lt;template v-slot:footer&gt;
        &lt;p&gt;我是footer部分&lt;/p&gt;
      &lt;/template&gt;
    &lt;/B&gt;
  &lt;/div&gt;
&lt;/template&gt;</code></pre>
<p>原来的作用域插槽</p>
<pre><code class="language-javascript">&lt;template&gt;
  &lt;div class="main"&gt;
    &lt;p&gt;我是A组件&lt;/p&gt;
    &lt;B&gt;
      &lt;template slot-scope="data"&gt;
        {<!-- -->{data.obj.lastName}}
      &lt;/template&gt;
    &lt;/B&gt;
  &lt;/div&gt;
&lt;/template&gt;</code></pre>
<p>写法变化，使用v-slot</p>
<pre><code class="language-javascript">&lt;template&gt;
  &lt;div class="main"&gt;
    &lt;p&gt;我是A组件&lt;/p&gt;
    &lt;B&gt;
      &lt;template v-slot="data"&gt;
        {<!-- -->{data.obj.lastName}}
      &lt;/template&gt;
    &lt;/B&gt;
  &lt;/div&gt;
&lt;/template&gt;</code></pre>
<h1 id="%E6%80%BB%E7%BB%93">总结</h1>
<p>在 2.6.0 中，为具名插槽和作用域插槽引入了一个新的统一的语法 (即 <code>v-slot</code> 指令)。它取代了 <code>slot</code> 和 <code>slot-scope</code> 这两个目前已被废弃但未被移除且仍在<a href="https://cn.vuejs.org/v2/guide/components-slots.html#%E5%BA%9F%E5%BC%83%E4%BA%86%E7%9A%84%E8%AF%AD%E6%B3%95" title="文档中">文档中</a>的 attribute。新语法的由来可查阅这份 <a href="https://github.com/vuejs/rfcs/blob/master/active-rfcs/0001-new-slot-syntax.md" title="RFC">RFC</a>。注意slot版本变化，vue2中仍可以使用slot与slot-scope，但是vue3只能使用v-slot了，切记，避免踩坑。</p>
</div>
</div>