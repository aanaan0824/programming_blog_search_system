<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<p id="main-toc"><strong>目录</strong></p>
<p id="-toc" style="margin-left:0px;"></p>
<p id="stack%E5%AE%B9%E5%99%A8-toc" style="margin-left:0px;"><a href="#stack%E5%AE%B9%E5%99%A8">stack容器</a></p>
<p id="%C2%A0stack%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#%C2%A0stack%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"> stack 基本概念</a></p>
<p id="stack%20%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3-toc" style="margin-left:40px;"><a href="#stack%20%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3">stack 常用接口</a></p>
<p id="%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0stack%E7%B1%BB-toc" style="margin-left:40px;"><a href="#%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0stack%E7%B1%BB">模拟实现stack类</a></p>
<p style="margin-left:40px;"></p>
<p id="queue%20%E5%AE%B9%E5%99%A8-toc" style="margin-left:0px;"><a href="#queue%20%E5%AE%B9%E5%99%A8">queue 容器</a></p>
<p id="queue%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#queue%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">queue 基本概念</a></p>
<p id="queue%20%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3-toc" style="margin-left:40px;"><a href="#queue%20%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3">queue 常用接口</a></p>
<p id="%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0queue%E7%B1%BB-toc" style="margin-left:40px;"><a href="#%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0queue%E7%B1%BB">模拟实现queue类</a></p>
<p style="margin-left:40px;"></p>
<p id="%E2%85%A1.%C2%A0%20%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97-toc" style="margin-left:0px;"><a href="#%E2%85%A1.%C2%A0%20%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97">优先级队列 - priority queue</a></p>
<p id="0x00%20priority_queue%20%E7%9A%84%E4%BB%8B%E7%BB%8D-toc" style="margin-left:80px;"><a href="#0x00%20priority_queue%20%E7%9A%84%E4%BB%8B%E7%BB%8D"> priority_queue 的概念</a></p>
<p id="0x01%20%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px;"><a href="#0x01%20%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E7%9A%84%E4%BD%BF%E7%94%A8">优先级队列的使用</a></p>
<p id="%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0priority_queue%E7%B1%BB-toc" style="margin-left:40px;"><a href="#%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0priority_queue%E7%B1%BB">模拟实现priority_queue类</a></p>
<p style="margin-left:40px;"></p>
<p id="%E2%85%A2.%20%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97-toc" style="margin-left:0px;"><a href="#%E2%85%A2.%20%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97">双端队列 - double ended queue</a></p>
<p id="deque%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#deque%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">deque容器基本概念</a></p>
<p id="deque%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#deque%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">deque构造函数</a></p>
<p id="deque%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C-toc" style="margin-left:40px;"><a href="#deque%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C">deque赋值操作</a></p>
<p id="deque%E5%A4%A7%E5%B0%8F%E6%93%8D%E4%BD%9C-toc" style="margin-left:40px;"><a href="#deque%E5%A4%A7%E5%B0%8F%E6%93%8D%E4%BD%9C">deque大小操作</a></p>
<p id="deque%20%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4-toc" style="margin-left:40px;"><a href="#deque%20%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4">deque 插入和删除</a></p>
<p id="deque%20%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96-toc" style="margin-left:40px;"><a href="#deque%20%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96">deque 数据存取</a></p>
<p id="deque%20%E6%8E%92%E5%BA%8F-toc" style="margin-left:40px;"><a href="#deque%20%E6%8E%92%E5%BA%8F">deque 排序</a></p>
<p id="deque%EF%BC%8Cstack%20%E5%92%8C%20queue%20%E7%9A%84%E5%BA%95%E5%B1%82%E9%BB%98%E8%AE%A4%E5%AE%B9%E5%99%A8-toc" style="margin-left:0px;">         <a href="#deque%EF%BC%8Cstack%20%E5%92%8C%20queue%20%E7%9A%84%E5%BA%95%E5%B1%82%E9%BB%98%E8%AE%A4%E5%AE%B9%E5%99%A8">deque，stack 和 queue 的底层默认容器</a></p>
<p id="deque%20%E7%9A%84%E7%BC%BA%E9%99%B7-toc" style="margin-left:40px;"><a href="#deque%20%E7%9A%84%E7%BC%BA%E9%99%B7">deque 的缺陷</a></p>
<hr id="hr-toc"/>
<p></p>
<h1></h1>
<h1></h1>
<h1 id="stack%E5%AE%B9%E5%99%A8">stack容器</h1>
<p></p>
<h2 id="%C2%A0stack%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"> stack 基本概念</h2>
<blockquote>
<ol><li>栈是一种特殊的线性表，只允许在<strong>固定的一端</strong>进行插入和删除元素的操作。</li><li>进行数据插入的删除和操作的一端，称为 <strong>栈顶 </strong>。另一端则称为 <strong>栈底 </strong>。</li><li><strong><strong>stack是一种</strong>先进后出</strong>(First In Last Out,FILO)的数据结构，它只有一个出口栈中只有顶端的元素才可以被外界使用，因此栈不允许有遍历行为</li></ol>
<ul><li>栈中进入数据称为 — <strong>入栈</strong> <code>push</code></li><li>栈中弹出数据称为 — <strong>出栈</strong> <code>pop</code></li></ul>
<p><img alt="" height="321" src="image\0a4835a5a38d4ce2a02c517c1d595027.png" width="772"/></p>
<p><strong>文档介绍：</strong><a href="https://cplusplus.com/reference/stack/stack/?kw=stack" title="stack - C++ Reference">stack - C++ Reference</a> </p>
<ul><li>stack 是一种容器适配器，专门用在具有后进先出操作的上下文环境中，其删除只能从容器的一端进行 元素的插入与提取操作。</li><li>stack 是作为容器适配器被实现的，容器适配器即是对特定类封装作为其底层的容器，并提供一组特定 的成员函数来访问其元素，将特定类作为其底层的，元素特定容器的尾部(即栈顶)被压入和弹出。</li><li>标准容器 vector、deque、list 均符合这些需求，默认情况下，如果没有为 stack 指定特定的底层容器， 默认情况下使用 deque。<br/>  </li></ul>
</blockquote>
<p></p>
<p></p>
<h2 id="stack%20%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3">stack 常用接口</h2>
<blockquote>
<p>功能描述：栈容器常用的对外接口</p>
<p>构造函数：</p>
<ul><li><code>stack&lt;T&gt; stk;</code> //stack采用模板类实现， stack对象的默认构造形式</li><li><code>stack(const stack &amp;stk);</code> //拷贝构造函数</li></ul>
<p>赋值操作：</p>
<ul><li><code>stack&amp; operator=(const stack &amp;stk);</code> //重载等号操作符</li></ul>
<p>数据存取：</p>
<ul><li><code>push(elem);</code> //向栈顶添加元素</li><li><code>pop();</code> //从栈顶移除第一个元素</li><li><code>top();</code> //返回栈顶元素</li></ul>
<p>大小操作：</p>
<ul><li><code>empty();</code> //判断堆栈是否为空</li><li><code>size();</code> //返回栈的大小</li></ul>
</blockquote>
<p> <strong>示例：</strong></p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt; 
using namespace std;
#include &lt;stack&gt;

//栈容器常用接口
void test01()
{
	//创建栈容器 栈容器必须符合先进后出
	stack&lt;int&gt; s;

	//向栈中添加元素，叫做 压栈 入栈
	s.push(10);
	s.push(20);
	s.push(30);

	while (!s.empty()) {
		//输出栈顶元素
		cout &lt;&lt; "栈顶元素为： " &lt;&lt; s.top() &lt;&lt; endl;
		//弹出栈顶元素
		s.pop();
	}
	cout &lt;&lt; "栈的大小为：" &lt;&lt; s.size() &lt;&lt; endl;

}

int main() {

	test01();

	system("pause");

	return 0;
}
</code></pre>
<blockquote>
<p>输出：</p>
<p>栈顶元素为： 30<br/> 栈顶元素为： 20<br/> 栈顶元素为： 10<br/> 栈的大小为：0</p>
</blockquote>
<p></p>
<h2 id="%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0stack%E7%B1%BB">模拟实现stack类</h2>
<p>函数接口</p>
<pre><code class="language-cpp">  #include&lt;deque&gt;

  template&lt;class T, class Con = deque&lt;T&gt;&gt;

  class stack

  {

  public:

    stack();

    void push(const T&amp; x);

    void pop();

    T&amp; top();

    const T&amp; top()const;

    size_t size()const;

    bool empty()const;

  private:

    Con _c;

  };</code></pre>
<p>模拟实现</p>
<pre><code class="language-cpp">/*

*思路：

* 1. stack和queue的模拟实现思路一样，都是通过容器适配而成

* 2. 容器的模板参数Con给出容器deque作为底层的默认容器(使用的过程中也可以自己指定容器)

* 3. stack和queue的方式实现在底层都是转为调用适配容器，只要容器能够满足所有的转调用操作，都可以充当适配   容器

* 4. 由于stack和queue是通过其他容器适配而成，所以stack和queue称为容器适配器

*/
#include&lt;deque&gt;

  template&lt;class T, class Con = deque&lt;T&gt;&gt;

  class stack
  {
  public:

    stack()
    {}
    void push(const T&amp; x)
    {
      _c.push_back(x);
    }

    void pop()
    {
      _c.pop_back();
    }

    T&amp; top()
    {
      return _c.back();
    }

    const T&amp; top()const
    {
      return _c.back();
    }

    size_t size()const
    {
      return _c.size();
    }

    bool empty()const

    {
      return _c.empty();
    }

  private:
    Con _c;

  };</code></pre>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<h1 id="queue%20%E5%AE%B9%E5%99%A8">queue 容器</h1>
<h2 id="queue%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">queue 基本概念</h2>
<blockquote>
<p><strong>概念：<strong>Queue是一种</strong>先进先出</strong>(First In First Out,FIFO)的数据结构，它有两个出口</p>
<p>队列容器允许从一端新增元素，从另一端移除元素</p>
<p>队列中只有队头和队尾才可以被外界使用，因此队列不允许有遍历行为</p>
<p>队列中进数据称为 — <strong>入队</strong> <code>push</code></p>
<p>队列中出数据称为 — <strong>出队</strong> <code>pop</code></p>
<p class="img-center"><img alt="" src="image\b93fb2776ff44dda0cde8082799240fe.png"/></p>
<p><strong>文档介绍：</strong><a href="https://cplusplus.com/reference/queue/queue/" title="queue - C++ Reference">queue - C++ Reference</a></p>
<ul><li>队列是一种容器适配器，专门用于在FIFO上下文(先进先出)中操作，其中从容器一端插入元素，另一端 提取元素。</li><li>队列作为容器适配器实现，容器适配器即将特定容器类封装作为其底层容器类，queue 提供一组特定的 成员函数来访问其元素。元素从队尾入队列，从队头出队列。</li><li>标准容器类 deque 和 list 满足了这些要求。默认情况下，如果没有为 queue 实例化指定容器类，则使用标 准容器 deque。</li></ul>
</blockquote>
<p><br/>  </p>
<h2 id="queue%20%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3">queue 常用接口</h2>
<blockquote>
<p>功能描述：栈容器常用的对外接口</p>
<p>构造函数：</p>
<ul><li><code>queue&lt;T&gt; que;</code> //queue采用模板类实现，queue对象的默认构造形式</li><li><code>queue(const queue &amp;que);</code> //拷贝构造函数</li></ul>
<p>赋值操作：</p>
<ul><li><code>queue&amp; operator=(const queue &amp;que);</code> //重载等号操作符</li></ul>
<p>数据存取：</p>
<ul><li><code>push(elem);</code> //往队尾添加元素</li><li><code>pop();</code> //从队头移除第一个元素</li><li><code>back();</code> //返回最后一个元素</li><li><code>front();</code> //返回第一个元素</li></ul>
<p>大小操作：</p>
<ul><li><code>empty();</code> //判断堆栈是否为空</li><li><code>size();</code> //返回栈的大小</li></ul>
</blockquote>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt; 
using namespace std;
#include &lt;stack&gt;
#include &lt;queue&gt;

class Person
{
public:
	Person(string name, int age)
	{
		this-&gt;m_Name = name;
		this-&gt;m_Age = age;
	}

	string m_Name;
	int m_Age;
};

void test01() {

	//创建队列
	queue&lt;Person&gt; q;

	//准备数据
	Person p1("唐僧", 30);
	Person p2("孙悟空", 1000);
	Person p3("猪八戒", 900);
	Person p4("沙僧", 800);

	//向队列中添加元素  入队操作
	q.push(p1);
	q.push(p2);
	q.push(p3);
	q.push(p4);

	//队列不提供迭代器，更不支持随机访问	
	while (!q.empty()) {
		//输出队头元素
		cout &lt;&lt; "队头元素-- 姓名： " &lt;&lt; q.front().m_Name 
              &lt;&lt; " 年龄： "&lt;&lt; q.front().m_Age &lt;&lt; endl;
        
		cout &lt;&lt; "队尾元素-- 姓名： " &lt;&lt; q.back().m_Name  
              &lt;&lt; " 年龄： " &lt;&lt; q.back().m_Age &lt;&lt; endl;
        
		cout &lt;&lt; endl;
		//弹出队头元素
		q.pop();
	}

	cout &lt;&lt; "队列大小为：" &lt;&lt; q.size() &lt;&lt; endl;
}

int main() {

	test01();

	system("pause");

	return 0;
}
</code></pre>
<blockquote>
<p>输出：</p>
<p>队头元素-- 姓名： 唐僧 年龄： 30<br/> 队尾元素-- 姓名： 沙僧 年龄： 800</p>
<p>队头元素-- 姓名： 孙悟空 年龄： 1000<br/> 队尾元素-- 姓名： 沙僧 年龄： 800</p>
<p>队头元素-- 姓名： 猪八戒 年龄： 900<br/> 队尾元素-- 姓名： 沙僧 年龄： 800</p>
<p>队头元素-- 姓名： 沙僧 年龄： 800<br/> 队尾元素-- 姓名： 沙僧 年龄： 800</p>
<p>队列大小为：0</p>
</blockquote>
<p></p>
<h2 id="%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0queue%E7%B1%BB">模拟实现queue类</h2>
<p>函数接口</p>
<pre><code class="language-cpp">  template&lt;class T, class Con = deque&lt;T&gt;&gt;

  class queue

  {

  public:

    queue();

    void push(const T&amp; x);

    void pop();

    T&amp; back();

    const T&amp; back()const;

    T&amp; front();

    const T&amp; front()const;

    size_t size()const;

    bool empty()const;

  private:

    Con _c;

  };</code></pre>
<p>模拟实现</p>
<pre><code class="language-cpp">/*

*思路：

* 1. stack和queue的模拟实现思路一样，都是通过容器适配而成

* 2. 容器的模板参数Con给出容器deque作为底层的默认容器(使用的过程中也可以自己指定容器)

* 3. stack和queue的方式实现在底层都是转为调用适配容器，只要容器能够满足所有的转调用操作，都可以充当适配   容器

* 4. 由于stack和queue是通过其他容器适配而成，所以stack和queue称为容器适配器

*/
#include&lt;deque&gt;
template&lt;class T, class Con = deque&lt;T&gt;&gt;

  class queue

  {

  public:

    queue()
    {}

    void push(const T&amp; x)
    {
      _c.push_back(x);
    }

    void pop()
    {
      _c.pop_front();
    }

    T&amp; back()
    {
      return _c.back();
    }

    const T&amp; back()const
    {
      return _c.back();
    }

    T&amp; front()
    {
      return _c.front();
    }

    const T&amp; front()const
    {
      return _c.front();
    }

    size_t size()const
    {
      return _c.size();
    }

    bool empty()const
    {
      return _c.empty();
    }

  private:

    Con _c;

  };</code></pre>
<p></p>
<p></p>
<p></p>
<p></p>
<h1 id="%E2%85%A1.%C2%A0%20%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97"><a href="https://so.csdn.net/so/search?q=%E4%BC%98%E5%85%88%E7%BA%A7&amp;spm=1001.2101.3001.7020" title="优先级">优先级</a>队列 - priority queue</h1>
<h3 id="0x00%20priority_queue%20%E7%9A%84%E4%BB%8B%E7%BB%8D"> priority_queue 的概念</h3>
<blockquote>
<p>优先级队列（priority_queue）其实，不满足先进先出的条件，更像是数据类型中的“堆”。优先级队列每次出队的元素是队列中优先级最高的那个元素，而不是队首的元素。这个优先级可以通过元素的大小等进行定义。比如定义元素越大优先级越高，那么每次出队，都是将当前队列中最大的那个元素出队</p>
<p class="img-center"><img alt="" src="image\6bd0fd024f41016a5b5a092df7868924.jpeg"/></p>
<p></p>
<p><strong>文档介绍：</strong><a href="https://cplusplus.com/reference/queue/priority_queue/" title="priority_queue - C++ Reference">priority_queue - C++ Reference</a></p>
<ul><li>优先队列是一种容器适配器，根据严格的弱排序标准，它的第一个元素总是它所包含的元素中最大的。</li><li>此上下文类似于堆，在堆中可以随时插入元素，并且只能检索最大堆元素（优先队列中位于顶部的元素）。</li><li>优先队列被实现为容器适配器，容器适配器即将特定容器类封装作为其底层容器类，queue提供一组特 定的成员函数来访问其元素。元素从特定容器的“尾部”弹出，其称为优先队列的顶部。</li><li>标准容器类 vector 和 deque 满足这些需求。默认情况下，如果没有为特定的 priority_queue 类实例化指 定容器类，则使用 vector。</li><li>需要支持随机访问迭代器，以便始终在内部保持堆结构。容器适配器通过在需要时自动调用算法函数 make_heap、push_heap 和 pop_heap 来自动完成此操作。</li></ul>
</blockquote>
<p><br/>  </p>
<h2 id="0x01%20%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E7%9A%84%E4%BD%BF%E7%94%A8">优先级队列的使用</h2>
<blockquote>
<p>优先级队列默认使用 vector 作为其底层存储数据的容器，</p>
<p>在 vector 上又使用了堆算法将 vector 中元素构造成堆的结构，因为 priority_queue 就是堆。</p>
<p>所有需要用到堆的地方，都可以考虑使用 priority_queue。</p>
<p>值得注意的是，priority_queue 默认为大根堆。</p>
<p><span style="background-color:#f9eda6;">优先级队列默认大的优先级高，传的是 less 仿函数，底层是一个大堆；</span></p>
<p><span style="background-color:#f9eda6;">如果想控制小的优先级高，需手动传 greater 仿函数，其底层是一个小堆。</span><br/>  </p>
<ul><li>empty()：检测容器是否为空</li><li>size()：返回容器中有效元素个数</li><li>front()：返回容器中第一个元素的引用</li><li>push_back()：在容器尾部插入元素</li><li>pop_back()：删除容器尾部元素</li></ul>
<p></p>
</blockquote>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;functional&gt;  // greater算法的头文件
using namespace std;

void test_priority_queue() 
{
    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; pQ;
  
    pQ.push(2);
    pQ.push(5);
    pQ.push(1);
    pQ.push(6);
    pQ.push(8);
    while (!pQ.empty()) {
        cout &lt;&lt; pQ.top() &lt;&lt; " ";
        pQ.pop();
    }
    cout &lt;&lt; endl;


    priority_queue&lt;int&gt; pQ2;
 //默认是用 vector 存储的，注意这里没有明确指定 less 还是 greater，所以默认为 less。
    pQ2.push(2);
    pQ2.push(5);
    pQ2.push(1);
    pQ2.push(6);
    pQ2.push(8);
    while (!pQ2.empty()) {
        cout &lt;&lt; pQ2.top() &lt;&lt; " ";
        pQ2.pop();
    }
    cout &lt;&lt; endl;
}



int main() {
    test_priority_queue();
    return 0;
}</code></pre>
<blockquote>
<p>输出：</p>
<p>1 2 5 6 8<br/> 8 6 5 2 1</p>
</blockquote>
<p>默认是用 vector 存储的，注意这里没有明确指定 less 还是 greater，所以默认为 less。</p>
<p>我们在定义优先级队列时主动去传 greater&lt;int&gt; 即可令该优先级队列以小的优先级高。</p>
<p></p>
<h2 id="%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0priority_queue%E7%B1%BB">模拟实现priority_queue类</h2>
<p>函数接口</p>
<pre><code class="language-cpp">namespace bit

{

  #include&lt;vector&gt;

  #include&lt;functional&gt;

  template &lt;class T, class Container = vector&lt;T&gt;, class Compare = less&lt;T&gt; &gt;

  class priority_queue

  {

  public:

    priority_queue();

    template &lt;class InputIterator&gt;

    priority_queue(InputIterator first, InputIterator last);

    bool empty() const;

    size_t size() const;

    T&amp; top() const;

    void push(const T&amp; x);

    void pop();

  private:

    Container c;

    Compare comp;

  };

};</code></pre>
<p>模拟实现</p>
<pre><code class="language-cpp">namespace bit

{

  //函数对象 less
  template&lt;class T&gt;

  struct less
  {
    bool operator()(const T&amp; left, const T&amp; right)
    { 
      return left &lt; right; 
    }
  };

  //函数对象 greater
  template&lt;class T&gt;

  struct greater
  {
    bool operator()(const T&amp; left, const T&amp; right)
    { 
      return left &gt; right; 
    }
  };
   

namespace bit
{

  //函数对象 less
  template&lt;class T&gt;
  struct less
  {
    bool operator()(const T&amp; left, const T&amp; right)
    { 
      return left &lt; right; 
    }
  };


  //函数对象 greater
  template&lt;class T&gt;
  struct greater
  {
    bool operator()(const T&amp; left, const T&amp; right)
    { 
      return left &gt; right; 
    }
  };

   

  template &lt;class T, class Container = std::vector&lt;T&gt;, class Compare = less&lt;T&gt; &gt;
  class priority_queue
  {
  public:

    //创建空的优先级队列
    priority_queue():c()
    {}

    template &lt;class InputIterator&gt;
    priority_queue(InputIterator first, InputIterator last)
      :c(first, last)
    {
      //将c中的元素调整为堆的结构，默认为大堆
      int count = c.size();
      int root = ((count - 2) &gt;&gt; 1);
      for (; root &gt;= 0; root--)
       AdjustDown(root);
    }

    bool empty() const
    {
      return c.empty();
    }

    size_t size() const
    {
      return c.size();
    }

    // 堆顶元素不允许修改，因为：堆顶元素修改可以会破坏堆的特性

    const T&amp; top() const
    {
      return c.front();
    }

    void push(const T&amp; x)
    {
      c.push_back(x);
      //push_heap(c.begin(), c.end(), comp);
      AdjustUp(c.size() - 1);
    }

    void pop()
    {
      if (empty())
       return;
      std:swap(c.front(), c.back());
      c.pop_back();
      AdjustDown(0);
    }

  private:

    //向上调整

    void AdjustUp(int child)
    {

      int parent = ((child - 1) &gt;&gt; 1);
      while (child)
      {
        if (Com(c[parent], c[child]))
        {
          std::swap(c[child], c[parent]);
          child = parent;
          parent = ((child - 1) &gt;&gt; 1);
       }
        else  return;

      }

    }

     

    //向下调整
    void AdjustDown(int parent)
    {
      int child = parent * 2 + 1;
      while (child &lt; c.size())
      {

        // 找以parent为根的较大的孩子
        if (child + 1 &lt; c.size() &amp;&amp; Com(c[child], c[child+1]))
        child += 1;

        // 检测双亲是否满足情况
        if (Com(c[parent], c[child]))
        {
          std::swap(c[child], c[parent]);
          parent = child;
          child = parent * 2 + 1;
       }
       else  return;

      }

    }

  private:

    Container c;

Compare Com;
  };

};</code></pre>
<p></p>
<p></p>
<h1 id="%E2%85%A2.%20%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97">双端队列 - double ended queue</h1>
<p></p>
<h2 id="deque%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">deque容器基本概念</h2>
<blockquote>
<p><strong>功能：</strong></p>
<ul><li>双端数组，可以对头端进行插入删除操作</li></ul>
<p><strong>deque与vector区别：</strong></p>
<ul><li> <p>deque 可以在头尾两端进行插入和删除操作，且时间复杂度为 <img alt="O(1)" src="https://latex.codecogs.com/gif.latex?O%281%29"/>，比vector快,</p> </li><li>vector访问元素时的速度会比deque快,这和两者内部实现有关</li></ul>
<h3 id="%E2%80%8B%E7%BC%96%E8%BE%91"><img alt="" height="568" src="image\8f2efb7eef67490ba4eaa474de82d3a5.png" width="1002"/></h3>
<p></p>
<p><strong>deque内部工作原理:</strong></p>
<p>deque内部有个<strong>中控器</strong>，维护每段缓冲区中的内容，缓冲区中存放真实数据</p>
<p>中控器维护的是每个缓冲区的地址，使得使用deque时像一片连续的内存空间</p>
<p><img alt="" height="595" src="image\88b588716e9e44c4a510f1e205acd104.png" width="1104"/></p>
<p></p>
<ul><li>deque容器的迭代器也是支持随机访问的</li></ul>
</blockquote>
<p></p>
<h2 id="deque%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">deque构造函数</h2>
<p></p>
<ul><li><code>deque&lt;T&gt;</code> deqT; //默认构造形式</li><li><code>deque(beg, end);</code> //构造函数将[beg, end)区间中的元素拷贝给本身。</li><li><code>deque(n, elem);</code> //构造函数将n个elem拷贝给本身。</li><li><code>deque(const deque &amp;deq);</code> //拷贝构造函数</li></ul>
<p>注意：</p>
<pre><code class="language-cpp">void printDeque(deque&lt;int&gt;&amp; d) 
{
	for (deque&lt;int&gt;::iterator it = d.begin(); it != d.end(); it++) {
		cout &lt;&lt; *it &lt;&lt; " ";

	}
	cout &lt;&lt; endl;
}
无const，迭代器用iterator

void printDeque(const deque&lt;int&gt;&amp; d) 
{
	for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) {
		cout &lt;&lt; *it &lt;&lt; " ";

	}
	cout &lt;&lt; endl;
}
有const限定用cosnt_iterator</code></pre>
<p><strong>示例：</strong></p>
<p></p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;
#include &lt;deque&gt;

void printDeque(const deque&lt;int&gt;&amp; d) 
{
	for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) {
		cout &lt;&lt; *it &lt;&lt; " ";

	}
	cout &lt;&lt; endl;
}
//deque构造
void test01() {

	deque&lt;int&gt; d1; //无参构造函数
	for (int i = 0; i &lt; 10; i++)
	{
		d1.push_back(i);
	}
	printDeque(d1);
	deque&lt;int&gt; d2(d1.begin(),d1.end());
	printDeque(d2);

	deque&lt;int&gt;d3(10,100);
	printDeque(d3);

	deque&lt;int&gt;d4 = d3;
	printDeque(d4);
}

int main() {

	test01();

	system("pause");

	return 0;
}
</code></pre>
<p></p>
<blockquote>
<p>输出：</p>
<p>0 1 2 3 4 5 6 7 8 9<br/> 0 1 2 3 4 5 6 7 8 9<br/> 100 100 100 100 100 100 100 100 100 100<br/> 100 100 100 100 100 100 100 100 100 100</p>
</blockquote>
<p>deque容器和vector容器的构造方式几乎一致，灵活使用即可</p>
<p></p>
<p></p>
<h2 id="deque%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C">deque赋值操作</h2>
<ul><li> <p><code>deque&amp; operator=(const deque &amp;deq);</code> //重载等号操作符</p> </li><li> <p><code>assign(beg, end);</code> //将[beg, end)区间中的数据拷贝赋值给本身。</p> </li><li> <p><code>assign(n, elem);</code> //将n个elem拷贝赋值给本身。</p> </li></ul>
<p></p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;
#include &lt;deque&gt;

void printDeque(const deque&lt;int&gt;&amp; d) 
{
	for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) {
		cout &lt;&lt; *it &lt;&lt; " ";

	}
	cout &lt;&lt; endl;
}
//赋值操作
void test01()
{
	deque&lt;int&gt; d1;
	for (int i = 0; i &lt; 10; i++)
	{
		d1.push_back(i);
	}
	printDeque(d1);

	deque&lt;int&gt;d2;
	d2 = d1;
	printDeque(d2);

	deque&lt;int&gt;d3;
	d3.assign(d1.begin(), d1.end());
	printDeque(d3);

	deque&lt;int&gt;d4;
	d4.assign(10, 100);
	printDeque(d4);

}

int main() {

	test01();

	system("pause");

	return 0;
}
</code></pre>
<blockquote>
<p>输出：</p>
<p>0 1 2 3 4 5 6 7 8 9<br/> 0 1 2 3 4 5 6 7 8 9<br/> 0 1 2 3 4 5 6 7 8 9<br/> 100 100 100 100 100 100 100 100 100 100</p>
</blockquote>
<p></p>
<p></p>
<h2 id="deque%E5%A4%A7%E5%B0%8F%E6%93%8D%E4%BD%9C">deque大小操作</h2>
<ul><li> <p><code>deque.empty();</code> //判断容器是否为空</p> </li><li> <p><code>deque.size();</code> //返回容器中元素的个数</p> </li><li> <p><code>deque.resize(num);</code> //重新指定容器的长度为num,若容器变长，则以默认值填充新位置。</p> <p>​ //如果容器变短，则末尾超出容器长度的元素被删除。</p> </li><li> <p><code>deque.resize(num, elem);</code> //重新指定容器的长度为num,若容器变长，则以elem值填充新位置。</p> <p>​ //如果容器变短，则末尾超出容器长度的元素被删除。</p> <p>​</p> </li><li><strong>deque没有容量的概念</strong></li></ul>
<p><strong>示例：</strong></p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;
#include &lt;deque&gt;

void printDeque(const deque&lt;int&gt;&amp; d) 
{
	for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) {
		cout &lt;&lt; *it &lt;&lt; " ";

	}
	cout &lt;&lt; endl;
}

//大小操作
void test01()
{
	deque&lt;int&gt; d1;
	for (int i = 0; i &lt; 10; i++)
	{
		d1.push_back(i);
	}
	printDeque(d1);

	//判断容器是否为空
	if (d1.empty()) {
		cout &lt;&lt; "d1为空!" &lt;&lt; endl;
	}
	else {
		cout &lt;&lt; "d1不为空!" &lt;&lt; endl;
		//统计大小
		cout &lt;&lt; "d1的大小为：" &lt;&lt; d1.size() &lt;&lt; endl;
	}

	//重新指定大小
	d1.resize(15, 1);
	printDeque(d1);

	d1.resize(5);
	printDeque(d1);
}

int main() {

	test01();

	system("pause");

	return 0;
}
</code></pre>
<blockquote>
<p>输出：</p>
<p>0 1 2 3 4 5 6 7 8 9<br/> d1不为空!<br/> d1的大小为：10<br/> 0 1 2 3 4 5 6 7 8 9 1 1 1 1 1<br/> 0 1 2 3 4</p>
</blockquote>
<p></p>
<p></p>
<h2 id="deque%20%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4">deque 插入和删除</h2>
<p>两端插入操作：</p>
<ul><li><code>push_back(elem);</code> //在容器尾部添加一个数据</li><li><code>push_front(elem);</code> //在容器头部插入一个数据</li><li><code>pop_back();</code> //删除容器最后一个数据</li><li><code>pop_front();</code> //删除容器第一个数据</li></ul>
<p>指定位置操作：</p>
<ul><li> <p><code>insert(pos,elem);</code> //在pos位置插入一个elem元素的拷贝，返回新数据的位置。</p> </li><li> <p><code>insert(pos,n,elem);</code> //在pos位置插入n个elem数据，无返回值。</p> </li><li> <p><code>insert(pos,beg,end);</code> //在pos位置插入[beg,end)区间的数据，无返回值。</p> </li><li> <p><code>clear();</code> //清空容器的所有数据</p> </li><li> <p><code>erase(beg,end);</code> //删除[beg,end)区间的数据，返回下一个数据的位置。</p> </li><li> <p><code>erase(pos);</code> //删除pos位置的数据，返回下一个数据的位置。</p> <p>​</p> <p>​</p> </li></ul>
<p><strong>示例：</strong></p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;
#include &lt;deque&gt;

void printDeque(const deque&lt;int&gt;&amp; d) 
{
	for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) {
		cout &lt;&lt; *it &lt;&lt; " ";

	}
	cout &lt;&lt; endl;
}
//两端操作
void test01()
{
	deque&lt;int&gt; d;
	//尾插
	d.push_back(10);
	d.push_back(20);
	//头插
	d.push_front(100);
	d.push_front(200);

	printDeque(d);

	//尾删
	d.pop_back();
	//头删
	d.pop_front();
	printDeque(d);
	cout&lt;&lt;endl;
}

//插入
void test02()
{
	deque&lt;int&gt; d;
	d.push_back(10);
	d.push_back(20);
	d.push_front(100);
	d.push_front(200);
	printDeque(d);

	d.insert(d.begin(), 1000);
	printDeque(d);

	d.insert(d.begin(), 2,10000);
	printDeque(d);

	deque&lt;int&gt;d2;
	d2.push_back(1);
	d2.push_back(2);
	d2.push_back(3);

	d.insert(d.begin(), d2.begin(), d2.end());
	printDeque(d);
	cout&lt;&lt;endl;

}

//删除
void test03()
{
	deque&lt;int&gt; d;
	d.push_back(10);
	d.push_back(20);
	d.push_front(100);
	d.push_front(200);
	printDeque(d);

	d.erase(d.begin());
	printDeque(d);

	//d.erase(d.begin(), d.end());
	d.clear();
	printDeque(d);

}

int main() {

	test01();

	test02();

    test03();
    
	system("pause");

	return 0;
}

</code></pre>
<blockquote>
<p>输出：</p>
<p>200 100 10 20<br/> 100 10</p>
<p></p>
<p>200 100 10 20<br/> 1000 200 100 10 20<br/> 10000 10000 1000 200 100 10 20<br/> 1 2 3 10000 10000 1000 200 100 10 20</p>
<p></p>
<p>200 100 10 20<br/> 100 10 20</p>
<p>（空字符串）<br/>  </p>
</blockquote>
<p></p>
<p></p>
<h2 id="deque%20%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96">deque 数据存取</h2>
<ul><li><code>at(int idx);</code> //返回索引idx所指的数据</li><li><code>operator[];</code> //返回索引idx所指的数据</li><li><code>front();</code> //返回容器中第一个数据元素</li><li><code>back();</code> //返回容器中最后一个数据元素</li></ul>
<p></p>
<p>除了用迭代器获取deque容器中元素，[ ]和at也可以</p>
<p><strong>示例：</strong></p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;
#include &lt;deque&gt;

void printDeque(const deque&lt;int&gt;&amp; d) 
{
	for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) {
		cout &lt;&lt; *it &lt;&lt; " ";

	}
	cout &lt;&lt; endl;
}

//数据存取
void test01()
{

	deque&lt;int&gt; d;
	d.push_back(10);
	d.push_back(20);
	d.push_front(100);
	d.push_front(200);

	for (int i = 0; i &lt; d.size(); i++) {
		cout &lt;&lt; d[i] &lt;&lt; " ";
	}
	cout &lt;&lt; endl;


	for (int i = 0; i &lt; d.size(); i++) {
		cout &lt;&lt; d.at(i) &lt;&lt; " ";
	}
	cout &lt;&lt; endl;

	cout &lt;&lt; "front:" &lt;&lt; d.front() &lt;&lt; endl;

	cout &lt;&lt; "back:" &lt;&lt; d.back() &lt;&lt; endl;

}

int main() {

	test01();

	system("pause");

	return 0;
}

</code></pre>
<blockquote>
<p>输出：</p>
<p>200 100 10 20<br/> 200 100 10 20<br/> front:200<br/> back:20</p>
</blockquote>
<p></p>
<p></p>
<h2 id="deque%20%E6%8E%92%E5%BA%8F">deque 排序</h2>
<ul><li><code>sort(iterator beg, iterator end)</code> //对beg和end区间内元素进行排序</li></ul>
<p><strong>示例：</strong></p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;
#include &lt;deque&gt;
#include &lt;algorithm&gt;

void printDeque(const deque&lt;int&gt;&amp; d) 
{
	for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) {
		cout &lt;&lt; *it &lt;&lt; " ";

	}
	cout &lt;&lt; endl;
}

void test01()
{

	deque&lt;int&gt; d;
	d.push_back(10);
	d.push_back(20);
	d.push_front(100);
	d.push_front(200);
	printDeque(d);
	
	sort(d.begin(), d.end());
	printDeque(d);
	
	sort(d.begin(), d.end(),greater&lt;int&gt;());
	printDeque(d);
}

int main() {

	test01();

	system("pause");

	return 0;
}
</code></pre>
<blockquote>
<p>输出：</p>
<p>200 100 10 20<br/> 10 20 100 200<br/> 200 100 20 10</p>
</blockquote>
<p></p>
<h1 id="deque%EF%BC%8Cstack%20%E5%92%8C%20queue%20%E7%9A%84%E5%BA%95%E5%B1%82%E9%BB%98%E8%AE%A4%E5%AE%B9%E5%99%A8">deque，stack 和 queue 的底层默认容器</h1>
<blockquote>
<p></p>
<p> 在 stack 和 queue 的实现上，是选择 deque 作为底层默认容器的。</p>
<p></p>
<div>
<span style="color:#777777;">stack</span>
<span style="color:#777777;">是一种后进先出的特殊线性数据结构，因此只要具有</span>
<span style="color:#777777;">push_back()</span>
<span style="color:#777777;">和</span>
<span style="color:#777777;">pop_back()</span>
<span style="color:#777777;">操作的线性结构，都可以作为stack</span>
<span style="color:#777777;">的底层容器，比如</span>
<span style="color:#777777;">vector</span>
<span style="color:#777777;">和</span>
<span style="color:#777777;">list</span>
<span style="color:#777777;">都可以；</span>
<span style="color:#777777;">queue是先进先出的特殊线性数据结构，只要具有 push_back和pop_front</span>
<span style="color:#777777;">操作的线性结构，都可以作为</span>
<span style="color:#777777;">queue</span>
<span style="color:#777777;">的底层容器，比如</span>
<span style="color:#777777;">list</span>
<span style="color:#777777;">。但是</span>
<span style="color:#777777;">STL</span>
<span style="color:#777777;">中对</span>
<span style="color:#777777;">stack</span>
<span style="color:#777777;">和 queue默认选择</span>
<span style="color:#777777;">deque</span>
<span style="color:#777777;">作为其底层容器，主要是因为：</span>
</div>
<div></div>
<ol><li><span style="color:#0d0016;">stack 和 queue 不需要遍历（因此 stack 和 queue 没有迭代器），只需要在固定的一端或者两端进行操作。</span></li><li><span style="color:#0d0016;">在 stack 中元素增长时，deque 比 vector 的效率高（扩容时不需要搬移大量数据）；queue  中的元素增长时，deque 不仅效率高，而且内存使用率高。 结合了 deque 的优点，而完美的避开了其缺陷。</span><br/>  </li></ol>
</blockquote>
<p></p>
<h2 id="deque%20%E7%9A%84%E7%BC%BA%E9%99%B7">deque 的缺陷</h2>
<blockquote>
<div>
<span style="color:#777777;"><strong>deque</strong></span>
<span style="color:#777777;"><strong>有一个致命缺陷：<span style="background-color:#f9eda6;">不适合遍历</span>，因为在遍历时，</strong></span>
<span style="color:#777777;"><strong>deque</strong></span>
<span style="color:#777777;"><strong>的迭代器要频繁的去检测其是否移动到</strong></span>
<span style="color:#777777;"><strong>某段小空间的边界，导致效率低下</strong></span>
<span style="color:#777777;">，而序列式场景中，可能需要经常遍历，因此</span>
<span style="color:#777777;"><strong>在实际中，需要线性结构</strong></span>
<span style="color:#777777;"><strong>时，大多数情况下优先考虑</strong></span>
<span style="color:#777777;"><strong>vector</strong></span>
<span style="color:#777777;"><strong>和</strong></span>
<span style="color:#777777;"><strong>list</strong></span>
<span style="color:#777777;">，</span>
<span style="color:#777777;">deque</span>
<span style="color:#777777;">的应用并不多，而</span>
<strong><span style="color:#777777;"><span style="background-color:#f9eda6;">目前能看到的一个应用就是，</span></span><span style="color:#777777;"><span style="background-color:#f9eda6;">STL</span></span><span style="color:#777777;"><span style="background-color:#f9eda6;">用其作</span></span><span style="color:#777777;"><span style="background-color:#f9eda6;">为</span></span><span style="color:#777777;"><span style="background-color:#f9eda6;">stack</span></span><span style="color:#777777;"><span style="background-color:#f9eda6;">和</span></span><span style="color:#777777;"><span style="background-color:#f9eda6;">queue</span></span><span style="color:#777777;"><span style="background-color:#f9eda6;">的底层数据结构</span></span></strong>
</div>
<div>
<img alt="" height="523" src="image\8e4ee6e51f9c4700844134e252b5395c.png" width="1042"/>
</div>
<p></p>
</blockquote>
</div>
</div>