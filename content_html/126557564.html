<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="markdown_views prism-atom-one-dark" id="content_views">
<svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
<path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
</svg>
<p></p>
<div class="toc">
<h3>文章目录</h3>
<ul><li><ul><li><a href="#MySQL_5">MySQL官网</a></li></ul>
</li><li><a href="#_10">一、基本概念了解</a></li><li><ul><li><a href="#_12">什么是数据库</a></li><li><a href="#_16">关系型数据库和非关系型数据库</a></li><li><a href="#SQL_22">什么是SQL</a></li></ul>
</li><li><a href="#_30">二、常见面试题</a></li><li><ul><li><a href="#MySQL_32">MySQL常用的搜索引擎</a></li><li><a href="#MySQLOracle__38">MySQL，Oracle 默认端口号</a></li><li><a href="#SQL__43">SQL 中的日期和时间类型</a></li><li><a href="#SQL__datetime__timestamp__63">SQL 中 datetime 和 timestamp 的区别</a></li><li><a href="#varchar__char__71">varchar 与 char 的区别?</a></li><li><a href="#_77">关联查询，分组，排序，分页，数据库聚合函数</a></li><li><a href="#_97">表与表之间的关系</a></li><li><a href="#having__where__116">having 与 where 的区别</a></li><li><a href="#_123">查询过程中的执行顺序</a></li><li><a href="#dropdeletetruncate__128">drop，delete，truncate 的区别</a></li><li><a href="#union__union_all__134">union 与 union all 的区别</a></li><li><a href="#_140">内连接与外连接的区别</a></li><li><a href="#_157">数据库的五大约束</a></li><li><a href="#_193">什么是事务</a></li><li><a href="#_197">项目中如何使用事务：</a></li><li><a href="#_202">数据库中如何操作事务</a></li><li><a href="#_216">事务的四大特性</a></li><li><a href="#_226">事务的隔离级别</a></li><li><a href="#_239">什么是视图，游标是什么</a></li><li><a href="#_268">什么是简单视图，什么是复杂视图</a></li><li><a href="#_272">描述下创建索引的几种方式</a></li><li><a href="#_305">谈谈数据库索引的优缺点</a></li><li><a href="#_314">数据库如何查询优化</a></li><li><a href="#MySQL__Oracle__328">MySQL 和 Oracle 的区别</a></li><li><a href="#_346">数据库三大范式</a></li></ul>
</li></ul>
</div>
<p></p>
<hr/>
<h2><a id="MySQL_5"></a>MySQL官网</h2>
<p><a href="https://www.mysql.com/">MySQL官网</a></p>
<hr/>
<h1><a id="_10"></a>一、基本概念了解</h1>
<h2><a id="_12"></a>什么是数据库</h2>
<p>数据库（DataBase）是用来组织、存储和管理数据的仓库。</p>
<h2><a id="_16"></a>关系型数据库和非关系型数据库</h2>
<ul><li>关系型数据库：关系型数据库是一个结构化的数据库，创建在关系模型（二维表格模型）基础上，一般面向于记录。 
  <ul><li>MySQL，Oracle，SQL Server</li></ul> </li><li>非关系型数据库：NoSQL（NoSQL = Not Only SQL ），意思是“不仅仅是 SQL”，是非关系型数据库的总称。 
  <ul><li>Redis（键值型），MongoDB（文档型），HBase（列存储），Neo4J（图形）</li><li></li></ul> </li></ul>
<h2><a id="SQL_22"></a>什么是SQL</h2>
<p>SQL（英文全称：Structured Query Language）是结构化查询语言，专门用来访问和处理数据库的编程语言。</p>
<ul><li>SQL 是一门数据库编程语言</li><li>SQL 语言只能在关系型数据库中使用</li></ul>
<hr/>
<h1><a id="_30"></a>二、常见面试题</h1>
<h2><a id="MySQL_32"></a>MySQL常用的搜索引擎</h2>
<ul><li>InnoDB（常用，唯一对事务支持的搜索引擎）</li><li>MyISAM（常用，查询多的时候性能好，ISAM升级版）</li><li>ISAM（不常用）</li><li>MEMORY（不常用）</li></ul>
<h2><a id="MySQLOracle__38"></a>MySQL，Oracle 默认端口号</h2>
<ul><li>MySQL：3306</li><li>Oracle：1521</li></ul>
<h2><a id="SQL__43"></a>SQL 中的日期和时间类型</h2>
<ul><li>year 
  <ul><li>年份</li><li><code>YYYY</code></li></ul> </li><li>date 
  <ul><li>日历日期（年月日）</li><li><code>YYYY-MM-DD</code></li></ul> </li><li>time 
  <ul><li>时分秒</li><li><code>HH-MM-SS</code></li></ul> </li><li>datetime 
  <ul><li>年月日时分秒</li><li><code>YYYY-MM-DD HH:MM:SS</code></li></ul> </li><li>timestamp 
  <ul><li>混合日期和时间，可作时间戳</li><li><code>YYYY-MM-DD HH:MM:SS</code></li><li>可设置默认值</li><li><code>timestamp</code> 的数值是与时区相关 
    <ul><li>以<code>UTC</code>（Universal Time Coordinated）系统协调时区（全时间统一公用的时间）进行存储，以系统当前所在时区进行显示</li></ul> </li></ul> </li></ul>
<h2><a id="SQL__datetime__timestamp__63"></a>SQL 中 datetime 和 timestamp 的区别</h2>
<table><thead><tr><th>对比</th><th>timestamp</th><th>datetime</th></tr></thead><tbody><tr><td>存储空间</td><td>4字节</td><td>8字节</td></tr><tr><td>时区</td><td>与时区有关</td><td>不受时区影响</td></tr><tr><td>时间范围</td><td>1970-01-01 00:00:01 ~ 2038-01-19 03:14:07</td><td>1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</td></tr></tbody></table>
<h2><a id="varchar__char__71"></a>varchar 与 char 的区别?</h2>
<ul><li>char 是一种固定长度的类型，不足的部分用隐藏空格填充，空间的使用会有浪费</li><li>varchar 则是一种可变长度的类型，节省空间</li><li>varchar 查询效率比 char 高</li><li>一般定长的数据选用 char 类型，比如身份证号，手机号，电话等，长度变化很大的可以使用 varchar 类型</li></ul>
<h2><a id="_77"></a>关联查询，分组，排序，分页，数据库聚合函数</h2>
<ul><li>关联查询 
  <ul><li>内联 <code>[inner] join on</code></li><li>外联 
    <ul><li>左联 <code>left join on</code></li><li>右联 <code>right join on</code></li></ul> </li></ul> </li><li>分组 <code>group by</code></li><li>排序 <code>order by</code>
<ul><li>默认升序 asc</li><li>降序 desc</li></ul> </li><li>分页 <code>limit</code>
<ul><li>limit num1（跳过的条数），num2（每页的条数）</li></ul> </li><li>聚合函数 
  <ul><li>max（最大值）</li><li>min（最小值）</li><li>sum（和）</li><li>avg（平均数）</li><li>count（统计个数）</li></ul> </li></ul>
<h2><a id="_97"></a>表与表之间的关系</h2>
<ul><li>一对一（不常用） 
  <ul><li>一个人 =&gt; 一个身份证号</li><li>一个人 =&gt; 一个国籍</li><li>一个学生 =&gt; 一个学号</li></ul> </li><li>一对多/多对一 
  <ul><li>从班级表的角度看：一个班级 =&gt; 多个学生</li><li>从学生表的角度看：多个学生 =&gt; 一个班级</li><li>一对多或者多对一的表关系中，我们会在多的那张表中去维护两张表之间的关系</li></ul> </li><li>多对多 
  <ul><li>从学生表的角度看：一个学生 =&gt; 多个课程</li><li>从课程表的角度看：一个课程 =&gt; 多个学生</li><li>所以多对多这种关系，我们一般会有一个中间表去维护两张表之间的关系</li></ul> </li></ul>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/6f7389d91bdc49a2a34cc48d09685c1a.png#pic_center"/><br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/7b0169c5541f40b99abde9ff985c9874.png#pic_center"/><br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/efa754e065444caa8955c33965c0ea7a.png#pic_center"/></p>
<h2><a id="having__where__116"></a>having 与 where 的区别</h2>
<ul><li>having 是在分组后对数据进行过滤</li><li>where 是在分组前对数据进行过滤</li><li>having 后面可以使用聚合函数</li><li>where 后面不可以使用聚合</li></ul>
<h2><a id="_123"></a>查询过程中的执行顺序</h2>
<pre><code class="prism language-sql"><span class="token keyword">select</span> 字段 <span class="token keyword">from</span> 表名 <span class="token keyword">where</span> 查询条件<span class="token punctuation">(</span>分组前<span class="token punctuation">)</span> <span class="token keyword">group</span> <span class="token keyword">by</span>（含聚合）<span class="token keyword">having</span> 查询条件<span class="token punctuation">(</span>分组后排序<span class="token punctuation">)</span> <span class="token keyword">order</span> <span class="token keyword">by</span><span class="token punctuation">(</span>排序<span class="token punctuation">)</span> <span class="token keyword">limit</span> 分页；
</code></pre>
<h2><a id="dropdeletetruncate__128"></a>drop，delete，truncate 的区别</h2>
<ul><li>drop 直接删掉表(删除表内数据及表结构)；</li><li>truncate 删除表数据及字段信息并帮助你重新重建这张表，表现形式，自增的 id 主键从 1 开始</li><li>delete 删除表中数据，可以在后面添加 where 字句。</li></ul>
<h2><a id="union__union_all__134"></a>union 与 union all 的区别</h2>
<ul><li>union 和 union all用于将两个或多个select语句的结果作为一个整体显示出来，作用是将多个结果合并在一起显示出来。</li><li>union all：对重复的数不会去重。（对两个结果集进行并集操作, 包括重复行, 即所有的结果全部显示, 不进行排序）</li><li>union：对重复的数据会去重。（对两个结果集进行并集操作, 不包括重复行, 同时进行默认规则的排序, 相当于distinct去重处理）</li></ul>
<h2><a id="_140"></a>内连接与外连接的区别</h2>
<ul><li> <p>内连接：<code>[inner] join on</code> 只显示两表共有的数据(交集数据)</p> <pre><code class="prism language-sql"><span class="token comment">#查找 emp 中拥有部门的所有员工信息(也包含部门信息)</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> emp e <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> dept d <span class="token keyword">ON</span> e<span class="token punctuation">.</span>dNo <span class="token operator">=</span> d<span class="token punctuation">.</span>deptNo<span class="token punctuation">;</span>
</code></pre> </li><li> <p>外连接：</p>
<ul><li>左连接：<code>left join on</code> 显示 join 左边的表的所有数据（不管两个表是否匹配），对于不匹配的部分都用 NULL 表示</li><li>右连接：<code>right join on</code> 显示 join 右边的表的所有数据（不管两个表是否匹配），对于不匹配的部分都用 NULL 表示</li></ul> </li></ul>
<p>以谁为主谁中的所有信息都出现</p>
<pre><code class="prism language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> emp e <span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> dept d <span class="token keyword">ON</span> e<span class="token punctuation">.</span>dNo <span class="token operator">=</span> d<span class="token punctuation">.</span>deptNo<span class="token punctuation">;</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> emp e <span class="token keyword">RIGHT</span> <span class="token keyword">JOIN</span> dept d <span class="token keyword">ON</span> e<span class="token punctuation">.</span>dNo <span class="token operator">=</span> d<span class="token punctuation">.</span>deptNo<span class="token punctuation">;</span>
</code></pre>
<h2><a id="_157"></a>数据库的五大约束</h2>
<ul><li>主键约束（Primay Key Coustraint） 唯一性，非空性(唯一且非空)</li><li>唯一约束（Unique Constraint） 唯一性（可以为空，但是只能有一个）</li><li>外键约束（Foreign Key Counstraint）需要建立两表间的关系，数据库中InnoDB存储引擎支持外键约束，MyISAM不支持外键约束</li><li>默认约束（Default Coustraint） 该数据的默认值</li><li>非空约束（Not Null Counstraint） 该字段不能为空</li><li>检查约束（Check Counstraint）对该列格式和范围的限制，自定义约束，自己决定限制条件</li></ul>
<p>网上有的说数据库的 5 大约束，有的是 6 大约束，<strong>MySQL中没有检查约束</strong> 的</p>
<pre><code class="prism language-sql"><span class="token comment">/*Oracle*/</span>
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> student<span class="token punctuation">(</span>
   id <span class="token keyword">int</span> <span class="token keyword">primary</span> <span class="token keyword">key</span> <span class="token keyword">auto_increment</span><span class="token punctuation">,</span><span class="token comment">/*主键约束*/</span>
   name <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token operator">not</span> <span class="token boolean">null</span><span class="token punctuation">,</span><span class="token comment">/*非空约束*/</span>
   sex <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">'男'</span><span class="token punctuation">,</span><span class="token comment">/*默认约束*/</span>
   age number<span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
   <span class="token keyword">check</span><span class="token punctuation">(</span>age<span class="token operator">&gt;=</span><span class="token number">18</span> <span class="token operator">and</span> age<span class="token operator">&lt;=</span><span class="token number">70</span><span class="token punctuation">)</span><span class="token comment">/*检查约束*/</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/*MySQL*/</span>
<span class="token keyword">CREATE</span> <span class="token keyword">DATABASE</span> <span class="token keyword">IF</span> <span class="token operator">NOT</span> <span class="token keyword">EXISTS</span> company<span class="token punctuation">;</span>
<span class="token keyword">USE</span> company<span class="token punctuation">;</span>
<span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> dept<span class="token punctuation">;</span>
<span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> emp<span class="token punctuation">;</span>
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> dept<span class="token punctuation">(</span>
  did <span class="token keyword">INT</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token keyword">AUTO_INCREMENT</span> <span class="token keyword">COMMENT</span> <span class="token string">'部门ID'</span><span class="token punctuation">,</span><span class="token comment">/*主键约束*/</span>
  dname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token keyword">UNIQUE</span> <span class="token keyword">COMMENT</span> <span class="token string">'部门名称'</span><span class="token comment">/*唯一约束*/</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> emp<span class="token punctuation">(</span>
  uid <span class="token keyword">INT</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token keyword">AUTO_INCREMENT</span> <span class="token keyword">COMMENT</span> <span class="token string">'员工ID'</span><span class="token punctuation">,</span>
  ename <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'员工姓名'</span><span class="token punctuation">,</span><span class="token comment">/*非空约束*/</span>
  etype <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token string">'普通员工'</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'员工类型'</span><span class="token punctuation">,</span> 
  dept_id <span class="token keyword">INT</span> <span class="token keyword">COMMENT</span> <span class="token string">'部门ID'</span><span class="token punctuation">,</span><span class="token comment">/*默认约束*/</span>
  <span class="token keyword">FOREIGN</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>dept_id<span class="token punctuation">)</span> <span class="token keyword">REFERENCES</span> dept<span class="token punctuation">(</span>did<span class="token punctuation">)</span><span class="token comment">/*外键约束*/</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<h2><a id="_193"></a>什么是事务</h2>
<p>事务是数据库操作最小的逻辑工作单元，它包含了一个或多个业务操作，这些操作要么都执行要么都不执行，是不可分割的，一起向系统去提交的。事务常常用来确保数据的一致性。</p>
<h2><a id="_197"></a>项目中如何使用事务：</h2>
<p>项目中我们通过 <code>@Transactional</code> 注解，这个注解是Spring框架提供的事务管理（声明式事务管理）<br/> 通常我们在业务层中，若一个方法中涉及到多个增删改查操作，此时需要在该方法上通过 <code>@Transactional</code> 注解开启事务管理；也可以在业务层接口上添加<code>@Transactional</code></p>
<h2><a id="_202"></a>数据库中如何操作事务</h2>
<ul><li>开启事务 
  <ul><li><code>BEGIN TRANSACTION</code></li></ul> </li><li>MySQL数据库中事务默认是开启的 
  <ul><li>查看事务状态 
    <ul><li><code>show variables like 'autocommit';</code>
<ul><li>on为开启</li></ul> </li></ul> </li><li><code>SET AUTOCOMMIT=0</code> 禁止自动提交</li><li><code>SET AUTOCOMMIT=1</code>开启自动提交</li></ul> </li><li>提交事务 
  <ul><li><code>COMMIT</code></li></ul> </li><li>回滚事务 
  <ul><li><code>ROLLBACK</code></li></ul> </li></ul>
<h2><a id="_216"></a>事务的四大特性</h2>
<ul><li>原子性： 
  <ul><li>事务是数据库的最小的工作单元，事务中包含的各操作要么都做，要么都不做。</li></ul> </li><li>一致性： 
  <ul><li>事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。当事务执行失败时，所有被该事务影响的数据都应该恢复到事务执行前的状态。</li></ul> </li><li>持久性： 
  <ul><li>一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的。</li></ul> </li><li>隔离性： 
  <ul><li>在事务执行过程中对数据的修改，在事务提交之前对其他事务不可见。接下来的其它操作或故障不应该对其执行结果有任何影响</li></ul> </li></ul>
<h2><a id="_226"></a>事务的隔离级别</h2>
<ul><li>READ UNCOMMITTED（读未提交数据） 
  <ul><li>特点：安全性最差，不能防止任何的并发读问题，但性能最高，不能推荐使用</li></ul> </li><li>READ COMMITTED（读已提交数据） 
  <ul><li>Oracle 默认的隔离级别</li><li>特点：安全性比"读未提交"较好，可以防止脏读，但不能防止不可重复度，也不能防止幻读，性能比"读未提交" 差。</li></ul> </li><li>REPEATABLE READ（可重复读） 
  <ul><li>MySQL 默认隔离级别</li><li>特点：安全性比"读已提交"较好,可以防止脏读、不可重复读，但不能防止幻读，性能比 “读已提交” 差。</li><li>由于 mysql 默认的隔离级别不允许出现脏读和不可重复读，因此要想在 mysql 中演示这两个现象，必须要设置 mysql 的隔离级别为最低级别，也就是 “读未提交”</li></ul> </li><li>SERIALIZABLE（串行化） 
  <ul><li>特点 : 安全性最好，可以防止脏读，不可重复读，幻读，性能最差，也不推荐使用</li></ul> </li></ul>
<h2><a id="_239"></a>什么是视图，游标是什么</h2>
<ul><li>视图： 
  <ul><li>是一种虚拟的表，具有和物理表相同的功能，表示一张表的部分数据,或者多张表的综合数据.其结构和数据是建立在对表的查询基础上。可以对视图进行增，改，查，操作，视图通常是有一个表或者多个表的行或列的子集。对视图的修改会影响基本表。它使得我们获取数据更容易，相比多表查询。</li><li>视图不存储数据，其中的所有数据均来自于真实表中，实际的数据来源可以来源自多张表，所以若实际的数据发生改变了，则视图也随之发生改变.视图可以嵌套</li><li>视图并不能提高查询效率</li><li>执行视图就是执行对应写好的SQL语句</li></ul> </li><li>游标： 
  <ul><li>是对查询出来的结果集作为一个单元来有效的处理。游标可以定在该单元中的特定行， 从结果集的当前行检索一行或多行。可以对结果集当前行做修改。一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要</li></ul> </li></ul>
<p>创建视图：</p>
<pre><code class="prism language-sql"><span class="token keyword">create</span> <span class="token keyword">view</span> 视图名 <span class="token keyword">as</span> <span class="token keyword">select</span>查询语句<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">create</span> <span class="token keyword">view</span> 视图名<span class="token punctuation">(</span>列名<span class="token number">1</span><span class="token punctuation">,</span>列名<span class="token number">2.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token keyword">select</span>查询语句<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre>
<p>使用视图：</p>
<pre><code class="prism language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> 视图名
</code></pre>
<p>删除视图：</p>
<pre><code class="prism language-sql"><span class="token keyword">drop</span> <span class="token keyword">view</span> 视图名
</code></pre>
<p>用途：</p>
<ul><li>筛选表中的行</li><li>防止未经许可的用户访问敏感数据</li><li>降低数据库的复杂程度</li><li>将多个物理数据库/表抽象为一个逻辑数据库/表</li></ul>
<h2><a id="_268"></a>什么是简单视图，什么是复杂视图</h2>
<ul><li>简单视图：一张表中抽出的字段信息创建的是简单视图</li><li>复杂视图：多张表中抽出的字段信息创建的是复杂视图</li></ul>
<h2><a id="_272"></a>描述下创建索引的几种方式</h2>
<p>MySQL 索引的建立对于 MySQL 的高效运行时很重要的，索引可以大大提高 MySQL 的检索速度。<br/> 创建索引时，需要确保该索引时应用在 SQL 查询语句的条件（一般作为 where 子句的条件）<br/> 创建索引的字段我们建议是唯一，不为空，经常被查询的字段。</p>
<ul><li>普通索引： 
  <ul><li>创建索引 
    <ul><li><code>CREATE INDEX indexName ON mytable (username(length));</code></li></ul> </li><li>修改表结构（添加索引） 
    <ul><li><code>ALTER table tableName ADD INDEX indexName (columnName);</code></li></ul> </li><li>创建表时直接指定<pre><code class="prism language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> mytable<span class="token punctuation">(</span>
       ID <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
       username <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
       <span class="token keyword">INDEX</span> <span class="token punctuation">[</span>indexName<span class="token punctuation">]</span> <span class="token punctuation">(</span>username<span class="token punctuation">(</span>length<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> </li></ul> </li><li>唯一索引： 
  <ul><li>创建索引 
    <ul><li><code>CREATE UNIQUE INDEX indexName ON mytable(username(length));</code></li></ul> </li><li>修改表结构 
    <ul><li><code>ALTER table mytable ADD UNIQUE [indexName] (username(length));</code></li></ul> </li><li>创建表的时候直接指定<pre><code class="prism language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> mytable<span class="token punctuation">(</span>
       ID <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
       username <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
       <span class="token keyword">UNIQUE</span> <span class="token punctuation">[</span>indexName<span class="token punctuation">]</span> <span class="token punctuation">(</span>username<span class="token punctuation">(</span>length<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> </li></ul> </li></ul>
<h2><a id="_305"></a>谈谈数据库索引的优缺点</h2>
<p>索引索然会大大提高了查询速度，同时却会降低更新表的速度，如对表进行 <code>INSERT</code>，<code>UPDATE</code>，<code>DELETE</code>。因为更新表时，MySQL 不仅要保存数据，还要保存一下索引文件。</p>
<ul><li>优点： 
  <ul><li>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</li></ul> </li><li>缺点： 
  <ul><li>增加了数据库的存储空间</li><li>减慢了数据录入的速度</li></ul> </li></ul>
<h2><a id="_314"></a>数据库如何查询优化</h2>
<ul><li>给关键字建立索引 
  <ul><li>经常使用某一个条件，就可以再这个条件上添加索引，比如： 
    <ul><li>经常通过 username 去查找，就可以再 username 上添加索引</li></ul> </li></ul> </li><li>使用存储过程,它使 SQL 变得更加灵活和高效</li><li>备份数据库和清理垃圾数据 
  <ul><li>短信发送验证码（4-6 位数字），校验功能；有个表会专门存储我们的验证码定时清理（晚上），SSM,springboot 框架都有</li></ul> </li><li>SQL 语句语法的优化 
  <ul><li>数据库中查询尽量不要写*号，查什么字段写什么字段</li><li>明确要查询的 sql 中只有一条记录，或者要求我们只有 1 条记录 
    <ul><li><code>select * from emp limit 1;</code></li></ul> </li></ul> </li><li>建立缓存（redis，memcache） 
  <ul><li>把我们经常使用的数据，不会修改的数据，存放到缓存中，这样会减少数据库的压力</li></ul> </li></ul>
<h2><a id="MySQL__Oracle__328"></a>MySQL 和 Oracle 的区别</h2>
<ul><li>MySQL 开源，Oracle 收费</li><li>端口号 
  <ul><li>MySQL：3306</li><li>Oracle：1521</li></ul> </li><li>数据类型 
  <ul><li>MySQL （tinyint，int，bigint，varchar，data(日期)，datetime(时间)，timestamp）</li><li>Oracle （number，varcher2，nvvarchar2，date(年月日，时分秒)）</li></ul> </li><li>分页 
  <ul><li>MySQL （limit）</li><li>Oracle （rownum 伪类）</li></ul> </li><li>对事务的支持 
  <ul><li>MySQL 
    <ul><li>InnoDB存储引擎支持事务</li><li>默认自动提交</li></ul> </li><li>Oracle</li></ul> </li></ul>
<h2><a id="_346"></a>数据库三大范式</h2>
<ul><li>第一范式 
  <ul><li>属性不可再分</li></ul> </li><li>第二范式 
  <ul><li>在一范式的基础上, 要求数据库表中的每个例或行必须可以被惟一地区分， 通常需要为表加上一个列， 以存储各个实例的惟一标识。 这个惟一属性列被称为主关键字或主键。</li></ul> </li><li>第三范式 
  <ul><li>在二范式的基础上, 要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。所以第三范式具有如下特征：1). 每一列只有一个值. 2). 每一行都能区分. 3). 每一个表都不包含其他表已经包含的非主关键字信息</li></ul> </li></ul>
<hr/>
<p><strong>- [x] 持续更新中…</strong></p>
</div>
<link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css" rel="stylesheet"/>
<link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css" rel="stylesheet"/>
</div>