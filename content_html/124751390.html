<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<p id="main-toc"><strong>目录</strong></p>
<p id="1%E3%80%81%E5%BC%95%E7%94%A8%E6%A6%82%E5%BF%B5-toc" style="margin-left:80px;"><a href="#1%E3%80%81%E5%BC%95%E7%94%A8%E6%A6%82%E5%BF%B5">1、引用概念</a></p>
<p id="2%E3%80%81%E5%BC%95%E7%94%A8%E7%89%B9%E6%80%A7-toc" style="margin-left:80px;"><a href="#2%E3%80%81%E5%BC%95%E7%94%A8%E7%89%B9%E6%80%A7">2、引用特性</a></p>
<p id="%E5%BC%95%E7%94%A8%E5%9C%A8%E5%AE%9A%E4%B9%89%E6%97%B6%E5%BF%85%E9%A1%BB%E5%88%9D%E8%AF%86%E5%8C%96-toc" style="margin-left:80px;"><a href="#%E5%BC%95%E7%94%A8%E5%9C%A8%E5%AE%9A%E4%B9%89%E6%97%B6%E5%BF%85%E9%A1%BB%E5%88%9D%E8%AF%86%E5%8C%96">        </a><a href="#%E5%BC%95%E7%94%A8%E5%9C%A8%E5%AE%9A%E4%B9%89%E6%97%B6%E5%BF%85%E9%A1%BB%E5%88%9D%E8%AF%86%E5%8C%96">引用在定义时必须初识化</a></p>
<p id="%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F%E5%8F%AF%E4%BB%A5%E6%9C%89%E5%A4%9A%E4%B8%AA%E5%BC%95%E7%94%A8-toc" style="margin-left:80px;"><a href="#%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F%E5%8F%AF%E4%BB%A5%E6%9C%89%E5%A4%9A%E4%B8%AA%E5%BC%95%E7%94%A8">        </a><a href="#%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F%E5%8F%AF%E4%BB%A5%E6%9C%89%E5%A4%9A%E4%B8%AA%E5%BC%95%E7%94%A8">一个变量可以有多个引用</a></p>
<p id="%E5%BC%95%E7%94%A8%E4%B8%80%E6%97%A6%E5%BC%95%E7%94%A8%E4%B8%80%E4%B8%AA%E5%AE%9E%E4%BD%93%EF%BC%8C%E5%86%8D%E4%B8%8D%E8%83%BD%E5%BC%95%E7%94%A8%E5%85%B6%E5%AE%83%E5%AE%9E%E4%BD%93-toc" style="margin-left:80px;"><a href="#%E5%BC%95%E7%94%A8%E4%B8%80%E6%97%A6%E5%BC%95%E7%94%A8%E4%B8%80%E4%B8%AA%E5%AE%9E%E4%BD%93%EF%BC%8C%E5%86%8D%E4%B8%8D%E8%83%BD%E5%BC%95%E7%94%A8%E5%85%B6%E5%AE%83%E5%AE%9E%E4%BD%93">        </a><a href="#%E5%BC%95%E7%94%A8%E4%B8%80%E6%97%A6%E5%BC%95%E7%94%A8%E4%B8%80%E4%B8%AA%E5%AE%9E%E4%BD%93%EF%BC%8C%E5%86%8D%E4%B8%8D%E8%83%BD%E5%BC%95%E7%94%A8%E5%85%B6%E5%AE%83%E5%AE%9E%E4%BD%93">引用一旦引用一个实体，再不能引用其它实体</a></p>
<p id="3%E3%80%81%E5%B8%B8%E5%BC%95%E7%94%A8-toc" style="margin-left:80px;"><a href="#3%E3%80%81%E5%B8%B8%E5%BC%95%E7%94%A8">3、常引用</a></p>
<p id="3.1%E3%80%81%E5%8F%96%E5%88%AB%E5%90%8D%E7%9A%84%E8%A7%84%E5%88%99-toc" style="margin-left:80px;"><a href="#3.1%E3%80%81%E5%8F%96%E5%88%AB%E5%90%8D%E7%9A%84%E8%A7%84%E5%88%99">        </a><a href="#3.1%E3%80%81%E5%8F%96%E5%88%AB%E5%90%8D%E7%9A%84%E8%A7%84%E5%88%99">3.1、取别名的规则</a></p>
<p id="%E6%9D%83%E9%99%90%E6%94%BE%E5%A4%A7error-toc" style="margin-left:80px;"><a href="#%E6%9D%83%E9%99%90%E6%94%BE%E5%A4%A7error">        </a>        <a href="#%E6%9D%83%E9%99%90%E6%94%BE%E5%A4%A7error">权限放大error</a></p>
<p id="%E6%9D%83%E9%99%90%E4%B8%8D%E5%8F%98-toc" style="margin-left:80px;"><a href="#%E6%9D%83%E9%99%90%E4%B8%8D%E5%8F%98">        </a>        <a href="#%E6%9D%83%E9%99%90%E4%B8%8D%E5%8F%98">权限不变</a></p>
<p id="%E6%9D%83%E9%99%90%E7%BC%A9%E5%B0%8F-toc" style="margin-left:80px;"><a href="#%E6%9D%83%E9%99%90%E7%BC%A9%E5%B0%8F">        </a>        <a href="#%E6%9D%83%E9%99%90%E7%BC%A9%E5%B0%8F">权限缩小</a></p>
<p id="3.2%E3%80%81%E6%8B%93%E5%B1%951%EF%BC%9A%E5%A6%82%E4%BD%95%E7%BB%99%E5%B8%B8%E9%87%8F%E5%8F%96%E5%88%AB%E5%90%8D-toc" style="margin-left:80px;"><a href="#3.2%E3%80%81%E6%8B%93%E5%B1%951%EF%BC%9A%E5%A6%82%E4%BD%95%E7%BB%99%E5%B8%B8%E9%87%8F%E5%8F%96%E5%88%AB%E5%90%8D">        </a><a href="#3.2%E3%80%81%E6%8B%93%E5%B1%951%EF%BC%9A%E5%A6%82%E4%BD%95%E7%BB%99%E5%B8%B8%E9%87%8F%E5%8F%96%E5%88%AB%E5%90%8D">3.2、拓展1：如何给常量取别名</a></p>
<p id="%E6%8B%93%E5%B1%952%EF%BC%9A%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F%E5%85%B7%E6%9C%89%E5%B8%B8%E6%80%A7-toc" style="margin-left:80px;"><a href="#%E6%8B%93%E5%B1%952%EF%BC%9A%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F%E5%85%B7%E6%9C%89%E5%B8%B8%E6%80%A7">        </a>        <a href="#%E6%8B%93%E5%B1%952%EF%BC%9A%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F%E5%85%B7%E6%9C%89%E5%B8%B8%E6%80%A7">拓展2：临时变量具有常性</a></p>
<p id="3.3%E3%80%81%E5%AF%B9%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E7%9A%84%E7%94%A8%E5%A4%84-toc" style="margin-left:80px;"><a href="#3.3%E3%80%81%E5%AF%B9%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E7%9A%84%E7%94%A8%E5%A4%84">        </a><a href="#3.3%E3%80%81%E5%AF%B9%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E7%9A%84%E7%94%A8%E5%A4%84">3.3、对权限控制的用处</a></p>
<p id="4%E3%80%81%E5%BC%95%E7%94%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:80px;"><a href="#4%E3%80%81%E5%BC%95%E7%94%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">4、引用的使用场景</a></p>
<p id="4.1%E3%80%81%E5%81%9A%E5%8F%82%E6%95%B0-toc" style="margin-left:80px;"><a href="#4.1%E3%80%81%E5%81%9A%E5%8F%82%E6%95%B0">        </a><a href="#4.1%E3%80%81%E5%81%9A%E5%8F%82%E6%95%B0">4.1、做参数</a></p>
<p id="4.2%E3%80%81%E5%81%9A%E8%BF%94%E5%9B%9E%E5%80%BC-toc" style="margin-left:80px;"><a href="#4.2%E3%80%81%E5%81%9A%E8%BF%94%E5%9B%9E%E5%80%BC">        </a><a href="#4.2%E3%80%81%E5%81%9A%E8%BF%94%E5%9B%9E%E5%80%BC">4.2、做返回值</a></p>
<p id="%E4%BC%A0%E5%80%BC%E8%BF%94%E5%9B%9E-toc" style="margin-left:80px;"><a href="#%E4%BC%A0%E5%80%BC%E8%BF%94%E5%9B%9E">        </a>         <a href="#%E4%BC%A0%E5%80%BC%E8%BF%94%E5%9B%9E">传值返回</a></p>
<p id="%E4%BC%A0%E5%BC%95%E7%94%A8%E8%BF%94%E5%9B%9E-toc" style="margin-left:80px;"><a href="#%E4%BC%A0%E5%BC%95%E7%94%A8%E8%BF%94%E5%9B%9E">        </a>         <a href="#%E4%BC%A0%E5%BC%95%E7%94%A8%E8%BF%94%E5%9B%9E">传引用返回</a></p>
<p id="5%E3%80%81%E4%BC%A0%E5%80%BC%E3%80%81%E4%BC%A0%E5%BC%95%E7%94%A8%E6%95%88%E7%8E%87%E6%AF%94%E8%BE%83-toc" style="margin-left:80px;"><a href="#5%E3%80%81%E4%BC%A0%E5%80%BC%E3%80%81%E4%BC%A0%E5%BC%95%E7%94%A8%E6%95%88%E7%8E%87%E6%AF%94%E8%BE%83">5、传值、传引用效率比较</a></p>
<p id="6%E3%80%81%E5%BC%95%E7%94%A8%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:80px;"><a href="#6%E3%80%81%E5%BC%95%E7%94%A8%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB">6、引用和指针的区别</a></p>
<hr/>
<h3>1、引用概念</h3>
<blockquote>
<p><span style="color:#956fe7;">引用不是新定义一个变量，而是给已存在变量取了一个别名</span>，编译器不会为引用变量开辟内存空间，它和它引用的变量共用同一块内存空间。</p>
<p>类型&amp; 引用变量名(对象名) = 引用实体；看代码：</p>
<pre><code class="language-cpp">int main()
{
	//把b叫做a的引用，也叫做b是a的别名
	int a = 10;
	int&amp; b = a;
	return 0;
}</code></pre>
<p>这里有一个变量a，a这块空间占4个字节，现在又给a取了一个名字叫b，也就是说a和b同时可以访问且修改这块空间，并且这里a和b的地址均是一样的。</p>
<p><img alt="" height="201" src="image\e609fd16c8dc4f36994beceaa3aea5ad.png" width="887"/></p>
<p><span style="color:#fe2c24;">引用的实质就是在取别名</span>，就好比西游记里的孙悟空，你叫他弼马温、齐天大圣、孙行者都是一个道理</p>
<p><span style="color:#956fe7;">既然引用是在取别名，那我对别名进行修改，就相当于对自己本身进行修改：</span></p>
<p><img alt="" height="300" src="image\e1e165758c354ea2bc95a8a091b0a011.png" width="1200"/></p>
</blockquote>
<hr/>
<h3 id="2%E3%80%81%E5%BC%95%E7%94%A8%E7%89%B9%E6%80%A7">2、引用特性</h3>
<blockquote>
<p>引用具有三大特性：</p>
<ol><li>引用在定义时必须初始化</li><li>一个变量可以有多个引用</li><li>引用一旦引用一个实体，再不能引用其它实体</li></ol>
<p>接下来，我将做具体演示：</p>
</blockquote>
<h3 id="%E5%BC%95%E7%94%A8%E5%9C%A8%E5%AE%9A%E4%B9%89%E6%97%B6%E5%BF%85%E9%A1%BB%E5%88%9D%E8%AF%86%E5%8C%96">引用在定义时必须初识化</h3>
<blockquote>
<p>我能否写出如下的引用呢？</p>
<pre><code class="language-cpp">int&amp; d;</code></pre>
<p><img alt="" height="126" src="image\1ad56e60748f46af886507980338b565.png" width="658"/></p>
<p>答案很明显，还没等你编译，就已经肉眼看见的错误了，综上，<span style="color:#956fe7;">引用在定义时必须初始化。</span></p>
</blockquote>
<h3 id="%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F%E5%8F%AF%E4%BB%A5%E6%9C%89%E5%A4%9A%E4%B8%AA%E5%BC%95%E7%94%A8">一个变量可以有多个引用</h3>
<blockquote>
<p>比如我有个变量a，你可以给其取个别名b，也可以取个别名c，<span style="color:#956fe7;">甚至给别名c再取别名d都可以</span>，<span style="color:#fe2c24;">并且这些别名和a的地址均是一样的，我改变其中一个，其它的也会随之改变</span>。</p>
<p><img alt="" height="297" src="image\a18895e0d694465cb6cdb4868ea558ee.png" width="1096"/></p>
</blockquote>
<h3 id="%E5%BC%95%E7%94%A8%E4%B8%80%E6%97%A6%E5%BC%95%E7%94%A8%E4%B8%80%E4%B8%AA%E5%AE%9E%E4%BD%93%EF%BC%8C%E5%86%8D%E4%B8%8D%E8%83%BD%E5%BC%95%E7%94%A8%E5%85%B6%E5%AE%83%E5%AE%9E%E4%BD%93">引用一旦引用一个实体，再不能引用其它实体</h3>
<blockquote>
<p>看代码：</p>
<p><img alt="" height="237" src="image\029b26e835f544c19f4582e773e90232.png" width="1129"/></p>
<p>在这段代码中，我们已经给a取别名b，随后把e的值赋给b，这里可不是对e取别名了，通过编译即可看出来，<span style="color:#956fe7;">b的地址同引用的a的地址，而不同于e的地址</span>。</p>
</blockquote>
<hr/>
<h3 id="3%E3%80%81%E5%B8%B8%E5%BC%95%E7%94%A8">3、常引用</h3>
<h3 id="3.1%E3%80%81%E5%8F%96%E5%88%AB%E5%90%8D%E7%9A%84%E8%A7%84%E5%88%99">3.1、取别名的规则</h3>
<blockquote>
<p>我们在取别名的时候，不是在所有情况下都可以随便取的，要在一定范围内。</p>
<p><span style="color:#fe2c24;">对原引用变量，权限只能缩小，不能放大。</span></p>
</blockquote>
<h3 id="%E6%9D%83%E9%99%90%E6%94%BE%E5%A4%A7error">权限放大error</h3>
<blockquote>
<p>我们都清楚C语言有个const，在C++的引用这一块也是有const引用的</p>
<p>假如我们现在有const修饰过的变量x，现在想对x取别名，还能像如下的方式进行吗？</p>
<pre><code class="language-cpp">//权限放大 err
const int x = 20;
int&amp; y = x;</code></pre>
<p>此时的y还是x的别名吗？编译起来一看全是错误</p>
<p><img alt="" height="363" src="image\c80a46a875ac40829abfcb55df654442.png" width="764"/></p>
<p>这就是典型的权限放大，学过C语言我们都清楚，const是只读的，对于变量x，我们只可以进行读，不能进行修改。而此时我们对x引用成y，且是int型的，此时y是可读可写的，不满足x的只读条件。</p>
<p><span style="color:#fe2c24;">那怎么样才能对x进行引用呢？</span><span style="color:#956fe7;">只需要确保权限不变即可</span>，见下文：</p>
</blockquote>
<h3 id="%E6%9D%83%E9%99%90%E4%B8%8D%E5%8F%98">权限不变</h3>
<blockquote>
<p>想要控制权限不变非常简单，<span style="color:#956fe7;">只需要对x引用的同时加上const修饰即可</span>，<span style="color:#fe2c24;">让变量y也是只读的</span></p>
<pre><code class="language-cpp">//权限不变
const int x = 20;
const int&amp; y = x;</code></pre>
<p>那如果变量没有加const修饰，但是在引用时加了const可以吗？这就是权限缩小，看下文：</p>
</blockquote>
<h3 id="%E6%9D%83%E9%99%90%E7%BC%A9%E5%B0%8F">权限缩小</h3>
<blockquote>
<pre><code class="language-cpp">//权限缩小
int c = 30;
const int&amp; d = c;</code></pre>
<p>我们针对上述代码进行编译，发现编译器没有任何报错，答案是可以的。</p>
<p>这里的c是可读可写的，我对c进行const引用，顶多就是把c改变为只读的，只是权限缩小，不违反要求，当然是可以的。</p>
</blockquote>
<h3 id="3.2%E3%80%81%E6%8B%93%E5%B1%951%EF%BC%9A%E5%A6%82%E4%BD%95%E7%BB%99%E5%B8%B8%E9%87%8F%E5%8F%96%E5%88%AB%E5%90%8D">3.2、拓展1：如何给常量取别名</h3>
<blockquote>
<p>可以给常量取别名吗？</p>
<pre><code class="language-cpp">int&amp; c = 20; // err</code></pre>
<p>其实是<span style="color:#956fe7;">不可以直接进行取别名的</span>，但是我们<span style="color:#fe2c24;">加上const就可以了</span>：</p>
<pre><code class="language-cpp">const int&amp; c = 20; // right</code></pre>
</blockquote>
<h3 id="%E6%8B%93%E5%B1%952%EF%BC%9A%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F%E5%85%B7%E6%9C%89%E5%B8%B8%E6%80%A7">拓展2：临时变量具有常性</h3>
<blockquote>
<p>看如下代码：</p>
<pre><code class="language-cpp">double d = 2.2;
int&amp; e = d;</code></pre>
<p>现在e能成为d的别名吗？</p>
<p><img alt="" height="336" src="image\58d3475855324b389f891db1395492e0.png" width="730"/></p>
<p>很明显不可以，编译器发生错误。但是我<span style="color:#956fe7;">加上const，发现它竟然就不会出错了</span>：</p>
<pre><code class="language-cpp">double d = 2.2;
const int&amp; e = d;</code></pre>
<p>怎么解释上述代码呢？这就需要我们先回顾下C语言的<span style="color:#956fe7;">类型转换</span></p>
<p>C++本身是在C语言的基础上走的，C语言在相似类型是允许隐式类型转换的。大给小会截断，小给大会提升。看如下代码：</p>
<pre><code class="language-cpp">double d = 2.2;
int f = d;</code></pre>
<p>编译器运行后：</p>
<p><img alt="" height="33" src="image\b16e543e8ab740f587f98042a705d08e.png" width="591"/></p>
<p>这里的会丢失数据其实就是会丢失精度</p>
<ul><li><span style="background-color:#fefcd8;">注意：</span></li></ul>
<p><span style="color:#956fe7;">这里在把d的值赋给f时并不是直接赋值的</span>，会把d的整数部分取出来，赋值给一个<span style="color:#fe2c24;">临时变量</span>，该临时变量大小4个字节，随后再把这个临时变量给给f</p>
<p class="img-center"><img alt="" height="130" src="image\1a426cba8765494e98423af7b1887433.png" width="486"/></p>
<p><span style="color:#fe2c24;">临时变量具有常性，就像被const修饰了一样，不能被修改</span></p>
<ul><li>谈到这，你就应该能够理解上文的这段代码为什么要加上const才能编译通过：</li></ul>
<pre><code class="language-cpp">double d = 2.2;
const int&amp; e = d;</code></pre>
<p>答案很简单，<span style="color:#956fe7;">这里e引用的是临时变量，临时变量具有常性，不能直接引用</span>，<span style="color:#fe2c24;">否则就是放大了权限，加上const才能保证其权限不变</span></p>
<ul><li>可能又会有人提问了，那为什么这段代码在赋值的时候不加上const呢？</li></ul>
<pre><code class="language-cpp">double d = 2.2;
int f = d;</code></pre>
<p>其实很简单，上述加const是在我引用的基础上加的，如若不加const，那么就是放大权限，让e变为可读可写的同时临时变量也如此，而此段代码中，对f的改变并不会影响到我临时变量，更不会影响到d，主要就是<span style="color:#956fe7;">普通的变量不存在权限放大或缩小</span>。</p>
<ul><li>此时又有人提问了，那么此时的e还是对d的引用吗？</li></ul>
<pre><code class="language-cpp">double d = 2.2;
const int&amp; e = d;</code></pre>
<p>这当然不是，<span style="color:#956fe7;">此时的e是对临时变量的引用，是临时变量的别名</span>。可以通过编译来验证：</p>
<p><img alt="" height="214" src="image\eec8a8cd5c5d4c518d18de7744d5a584.png" width="1173"/></p>
</blockquote>
<h3 id="3.3%E3%80%81%E5%AF%B9%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E7%9A%84%E7%94%A8%E5%A4%84">3.3、对权限控制的用处</h3>
<blockquote>
<p>这里简单提下，例如这个传参的问题。</p>
<p>如若函数写出普通的引用，那么很多参数可能会传不过来：</p>
<p><img alt="" height="486" src="image\fc7f8d5b189f419bafcb79811dcade6b.png" width="644"/></p>
<p>仔细看这段代码，只有a能正常传过去，后面的均传不过去，<span style="color:#956fe7;">因为后面传的参数均涉及权限放大，固然编译器会出错</span></p>
<p>但是当我们在函数的形参那加上const呢？</p>
<p><img alt="" height="485" src="image\6e0e2ca6bc774a779300f71efcd75a1b.png" width="723"/></p>
<p>加了const后编译器就会报错了 </p>
</blockquote>
<hr/>
<h3 id="4%E3%80%81%E5%BC%95%E7%94%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">4、引用的使用场景</h3>
<blockquote>
<p>引用的使用场景分为两个：</p>
<ol><li>做参数</li><li>做返回值</li></ol>
<p>接下来，我将会详细讲解下：</p>
</blockquote>
<h3 id="4.1%E3%80%81%E5%81%9A%E5%8F%82%E6%95%B0">4.1、做参数</h3>
<blockquote>
<p>就比如说我现在要写一个Swap函数，以前是用指针写的：</p>
<pre><code class="language-cpp">//指针版
void Swap(int* pa, int* pb)
{
	int tmp = *pa;
	*pa = *pb;
	*pb = tmp;
}</code></pre>
<p>而现在，我们就可以巧用引用来完成Swap函数</p>
<pre><code class="language-cpp">//引用版
void Swap(int&amp; x, int&amp; y)
{
	int tmp = x;
	x = y; 
	y = tmp;
}
//支持函数重载
void Swap(double&amp; x, double&amp; y)
{
	double tmp = x;
	x = y;
	y = tmp;
}</code></pre>
<p>现在，引用就可以做我的形参，就不用再像以前C语言那样总是取地址&amp;，并且在调用的时候也会非常方便，因为有函数重载的加持。</p>
<pre><code class="language-cpp">int main()
{
    //交换整数
	int a = 0, b = 1;
	Swap(a, b);
    //交换浮点数
	double c = 1.1, d = 2.2;
	Swap(c, d);
    return 0;
}</code></pre>
<ul><li><span style="color:#956fe7;">引用还有一个好处在输出型参数会得到体现：</span></li></ul>
<pre><code class="language-cpp">int* preorderTraversal(struct TreeNode* root, int* returnSize) {
    //……
}</code></pre>
<p>这里给一个*returnSize多少有点奇怪，其实这样写就非常方便：</p>
<pre><code class="language-cpp">int* preorderTraversal(struct TreeNode* root, int&amp; returnSize) {
    //……
}
int main()
{
    preorderTraversal(tree, size);
}</code></pre>
<p>加上引用会在调用时省去写&amp;，也更方便理解，减少对指针的使用。</p>
<p>综上，引用做参数的好处如下：</p>
<ol><li>输出型参数</li><li>减少拷贝、提高效率</li></ol>
<p>引用还有一个使用场景是做返回值，具体看下文：</p>
</blockquote>
<h3 id="4.2%E3%80%81%E5%81%9A%E8%BF%94%E5%9B%9E%E5%80%BC">4.2、做返回值</h3>
<blockquote>
<p>先看一段代码：</p>
<pre><code class="language-cpp">int Count()
{
	static int n = 0;
	n++;
	return n;
}
int main()
{
	cout &lt;&lt; Count() &lt;&lt; endl; //1
	cout &lt;&lt; Count() &lt;&lt; endl; //2
	cout &lt;&lt; Count() &lt;&lt; endl; //3
	return 0;
}</code></pre>
<p>针对此段代码，我们运行的结果是1、2、3。</p>
<ul><li>这里可能有人会提问为什么不是1、1、1呢？<span style="color:#956fe7;">注意这里使用了静态区的变量只会初始化一次</span>，也就是说我static int n = 0这行代码在编译时只有第一次会跳到这，其余两次均不会走这一行代码，你每次进去的n都是同一个n。通过调试我们就可以看出，这里n的地址始终都是一样的。</li></ul>
</blockquote>
<h3 id="%E4%BC%A0%E5%80%BC%E8%BF%94%E5%9B%9E">传值返回</h3>
<blockquote>
<p>传值返回是有讲究的。正如这段代码：</p>
<pre><code class="language-cpp">int Count()
{
	int n = 0;
	n++;
	return n;
}
int main()
{
	int ret = Count();
	return 0;
}</code></pre>
<p>在传值返回的过程中会产生一个临时变量（类型是int），如果这个临时变量小它会用寄存器替代，如果大就不会用寄存器替代。</p>
<p>具体返回的过程是<span style="color:#fe2c24;">先把函数的n拷贝给临时变量，再把临时变量拷贝给ret。</span></p>
<p><span style="color:#956fe7;"><strong>为什么要设计这个临时变量呢？</strong></span></p>
<p>上述代码不可以直接把n返回给ret，这里我们简要画个栈帧图即可看出：</p>
<p class="img-center"><img alt="" height="336" src="image\16aaa12fae3e44f6b0aa84925d099605.png" width="560"/></p>
<p>main函数里有个变量ret，汇编时会call一个指令跳到函数Count，Count里有一个变量n。这里不能把n直接传给ret，因为在函数Count调用完成后要拿一个值赋给ret，且函数调用完后函数栈帧就销毁了，<span style="color:#fe2c24;">所以赋给ret的这个值就是设计出的临时变量</span></p>
<p><span style="color:#956fe7;"><strong>如何证明我这中间会产生临时变量呢？</strong></span></p>
<p>只需要加个引用即可。</p>
<p><img alt="" height="490" src="image\3011b8c50f464e00b0ff6be216eefc2e.png" width="708"/></p>
<p>这里很明显编译发生错误。为什么呢？这里其实答案就很明显了，<span style="color:#956fe7;">这里ret之所以出错不就是因为其引用的是临时变量呢，因为临时变量具有常性，只读不可修改，直接引用则会出现上文所述的权限放大问题。</span> <span style="color:#fe2c24;">所以这不很巧合的验证了此函数调用中途会产生临时变量。</span></p>
<p>解决方法也很简单，保持权限不变即可，即加上const修饰：</p>
<p><img alt="" height="307" src="image\7a7e0bce620e428cb4352cbad595c52f.png" width="438"/></p>
</blockquote>
<h3 id="%E4%BC%A0%E5%BC%95%E7%94%A8%E8%BF%94%E5%9B%9E">传引用返回</h3>
<blockquote>
<p>我们对上述代码进行微调：</p>
<pre><code class="language-cpp">int&amp; Count()
{
	int n = 0;
	n++;
	return n;
}
int main()
{
	int ret = Count();
	return 0;
}</code></pre>
<p>这里加上了引用&amp;后，<span style="color:#956fe7;">中间也会产生一个临时变量，</span><span style="color:#fe2c24;">只是这个临时变量的类型是<strong>int&amp;</strong>。</span>我们把这个临时变量假定为tmp，<span style="color:#956fe7;">那么此时tmp就是n的别名，再把tmp赋值给ret</span>。<span style="color:#fe2c24;">这个过程不就是直接把n赋给ret吗</span>。这里区分于传值返回的核心就在于<span style="color:#ff9900;">传引用的返回就是n的别名。</span></p>
<p><span style="color:#956fe7;"><strong>如何证明传引用返回的是n的别名？</strong></span></p>
<p>只需要在函数调用时加个引用即可：</p>
<p><img alt="" height="529" src="image\c0ffcf42ad47407fbf2463fc3416d209.png" width="947"/></p>
<p>我们也可以通过打印法来验证：</p>
<p><img alt="" height="322" src="image\5849fe5103fb4f7d991a6be58930b780.png" width="833"/></p>
<p><span style="color:#956fe7;">这里ret和n的地址一样，也就意味着ret其实就是n的别名。</span>综上，传值返回和传引用的返回的区别如下：</p>
<ul><li>传值返回：会有一个拷贝</li><li>传引用返回：没有这个拷贝了，返回的直接就是返回变量的别名 </li></ul>
<p><span style="color:#956fe7;"><strong>现在又存在一个问题了：我传引用的代码对不对？</strong></span></p>
<p>我传引用返回后，ret就是n的别名，但是有没有想过，出了函数出了这个作用域我n不是都销毁了吗，怎么还会有别名呢？</p>
<p><span style="color:#fe2c24;">空间的销毁不是说空间就不在了</span>。空间的归还就好比你退房，虽然你退房了，但是这个房间还是在的，只是说使用权不是你的了。但是假说你在不小心的情况下留了一把钥匙，你依旧是可以进入这个房间，不过你这个行为是非法的。<span style="color:#fe2c24;">这个例子也就足矣说明了上述的代码是有问题的。是一个间接的非法访问。</span></p>
<p>仔细看我这段截图：</p>
<p><img alt="" height="373" src="image\121b3f814b0041588f3a02dd3c622dbd.png" width="945"/></p>
<p>这里第一次打印ret的值为1，第二次打印的ret为随机值，这就是因为发生了覆盖。这里你第一次打印是正常的，随后打印完后，函数栈帧销毁，此时又打印了其它东西，又会函数调用覆盖了原来函数的位置，当你第二次打印ret的值时自然就是随机值了。</p>
<p><span style="color:#956fe7;">综上这种情况是不能进行引用返回的。</span></p>
<ul><li><span style="color:#fe2c24;"><strong>若我非要引用返回呢？如何正确使用？</strong></span></li></ul>
<p><strong>加上static即可：</strong></p>
<pre><code class="language-cpp">int&amp; Count()
{
	static int n = 0;
	n++;
	cout &lt;&lt; "&amp;n: " &lt;&lt; &amp;n &lt;&lt; endl;
	return n;
}
int main()
{
	int&amp; ret = Count();
	cout &lt;&lt; ret &lt;&lt; endl;
	cout &lt;&lt; "&amp;ret: " &lt;&lt; &amp;ret &lt;&lt; endl;
	cout &lt;&lt; ret &lt;&lt; endl;
	return 0;
}</code></pre>
<p>加上了static后就把n放在了静态区了，出了作用域不会销毁，自然而然可以正确使用引用返回了，并且输出结果也是我们预期的：</p>
<p><img alt="" height="122" src="image\385be8e45ada4fb5a350ef97c914847d.png" width="508"/></p>
<ul><li><span style="background-color:#f9eda6;">注意：</span></li></ul>
<p>如果函数返回时，出了函数作用域，如果返回对象还未还给系统，则可以使用引用返回，如果已经还给系统了，则必须使用传值返回。否则就可能会出越界问题。</p>
<ul><li>再举一个例子：</li></ul>
<pre><code class="language-cpp">int&amp; Add(int a, int b)
{
	int c = a + b;
	return c;
}
int main()
{
	int&amp; ret = Add(1, 2);
	Add(3, 4);
	cout &lt;&lt; "Add(1, 2) is :" &lt;&lt; ret &lt;&lt; endl;  //7
	return 0;
}</code></pre>
<p>这段代码执行的结果ret的值为7，首先我Add(1，2)，调用完后，返回c的别名给ret，随即调用完Add栈帧销毁，当我第二次调用时c的值就被修改为7了，这里想表达的是这里是不安全的。</p>
<p><span style="color:#956fe7;">正常情况下我们应该加上static：</span></p>
<p><img alt="" height="319" src="image\d7c2c2b46f3247bc95bd8dfe58ad2807.png" width="835"/></p>
<p>加上static后这里ret的值就是3了，<span style="color:#fe2c24;">因为加上了static初始化只有一次。此时c在静态区了，销毁栈帧它还在。</span></p>
<ul><li>这里再演示下其被覆盖的情形：</li></ul>
<p>正常情况：</p>
<p><img alt="" height="392" src="image\9eea02500d31400ba3e423eaaea58ab7.png" width="863"/></p>
<p>不加static发生覆盖：</p>
<p><img alt="" height="405" src="image\e7c89bb2150d4934bd95f2509fc6ea8c.png" width="859"/></p>
</blockquote>
<hr/>
<h3 id="5%E3%80%81%E4%BC%A0%E5%80%BC%E3%80%81%E4%BC%A0%E5%BC%95%E7%94%A8%E6%95%88%E7%8E%87%E6%AF%94%E8%BE%83">5、传值、传引用效率比较</h3>
<blockquote>
<p>以值作为参数或者返回值类型，在传参和返回期间，函数不会直接传递实参或者将变量本身直接返回，而是传递实参或者返回变量的一份临时的拷贝，因此用值作为参数或者返回值类型，效率是非常低下的，尤其是当参数或者返回值类型非常大时，效率就更低。</p>
<pre><code class="language-cpp">#include &lt;time.h&gt;
struct A { int a[10000]; };
void TestFunc1(A a) {}
void TestFunc2(A&amp; a) {}
void TestRefAndValue()
{
	A a;
	// 以值作为函数参数
	size_t begin1 = clock();
	for (size_t i = 0; i &lt; 10000; ++i)
		TestFunc1(a);
	size_t end1 = clock();
	// 以引用作为函数参数
	size_t begin2 = clock();
	for (size_t i = 0; i &lt; 10000; ++i)
		TestFunc2(a);
	size_t end2 = clock();
	// 分别计算两个函数运行结束后的时间
	cout &lt;&lt; "TestFunc1(A)-time:" &lt;&lt; end1 - begin1 &lt;&lt; endl;
	cout &lt;&lt; "TestFunc2(A&amp;)-time:" &lt;&lt; end2 - begin2 &lt;&lt; endl;
}
int main()
{
	TestRefAndValue();
}</code></pre>
<p><img alt="" height="77" src="image\151b548c9d1f46fe8abf1091dbbed85a.png" width="547"/></p>
<ul><li><strong><span style="color:#956fe7;">值和引用的作为返回值类型的性能比较</span></strong></li></ul>
<pre><code class="language-cpp">#include &lt;time.h&gt;
struct A { int a[10000]; };
A a;
// 值返回
A TestFunc1() { return a; }
// 引用返回
A&amp; TestFunc2() { return a; }
void TestReturnByRefOrValue()
{
	// 以值作为函数的返回值类型
	size_t begin1 = clock();
	for (size_t i = 0; i &lt; 100000; ++i)
		TestFunc1();
	size_t end1 = clock();
	// 以引用作为函数的返回值类型
	size_t begin2 = clock();
	for (size_t i = 0; i &lt; 100000; ++i)
		TestFunc2();
	size_t end2 = clock();
	// 计算两个函数运算完成之后的时间
	cout &lt;&lt; "TestFunc1 time:" &lt;&lt; end1 - begin1 &lt;&lt; endl;
	cout &lt;&lt; "TestFunc2 time:" &lt;&lt; end2 - begin2 &lt;&lt; endl;
}
int main()
{
	TestReturnByRefOrValue();
}</code></pre>
<p><img alt="" height="82" src="image\6207ae2ae2e6452a9d419f630ec8842a.png" width="604"/></p>
</blockquote>
<hr/>
<h3 id="6%E3%80%81%E5%BC%95%E7%94%A8%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB">6、引用和指针的区别</h3>
<blockquote>
<p>引用和指针的不同点：</p>
<ol><li>引用概念上定义一个变量的别名，指针存储一个变量地址</li><li><strong>引用</strong>在定义时<strong>必须初始化</strong>，指针没有要求</li><li><strong>引用</strong>在初始化时引用一个实体后，就<strong>不能再引用其他实体</strong>，而指针可以在任何时候指向任何一个同类型实体</li><li><strong>没有NULL引用</strong>，但有NULL指针</li><li><strong>在sizeof中含义不同</strong>：<strong>引用</strong>结果为<strong>引用类型的大小</strong>，但<strong>指针</strong>始终是<strong>地址空间所占字节个数</strong>(32位平台下占4个字节)</li><li>引用自加即引用的实体增加1，指针自加即指针向后偏移一个类型的大小</li><li><strong>有多级指针，但是没有多级引用</strong></li><li>访问实体方式不同，<strong>指针需要显式解引用，引用编译器自己处理</strong></li><li><strong>引用比指针使用起来相对更安全</strong></li></ol>
<p>接下来就上述指针与引用不同点做详细解析：</p>
<ul><li>引用在定义时必须初始化，指针没有要求</li></ul>
<pre><code class="language-cpp">int&amp; r; //err 引用没有初始化
int* p; //right 指针可以不初始化</code></pre>
<ul><li>在sizeof中含义不同：引用结果为引用类型的大小，但直至始终时地址空间所占字节个数（32位平台下占4个字节）</li></ul>
<pre><code class="language-cpp">	double d = 2.2;
	double&amp; r = d;
	cout &lt;&lt; sizeof(r) &lt;&lt; endl; //8</code></pre>
<ul><li>在语法概念上引用就是一个别名，没有独立空间，和其引用实体共用同一块空间。</li></ul>
<p><img alt="" height="202" src="image\31e64b150c4f4656b614fd8ef13deae0.png" width="776"/></p>
<p>在底层实现上实际是有空间的，因为引用是按照指针方式来实现的。</p>
<pre><code class="language-cpp">int main()
{
	int a = 10;
	//语法角度而言：ra是a的别名，没有额外开空间
	//底层的角度：它们是一样的方式实现的
	int&amp; ra = a;
	ra = 20;
	//语法角度而言：pa存储a的空间地址，pa开了4/8字节的空间
	//底层的角度：它们是一样的方式实现的
	int* pa = &amp;a;
	*pa = 20;
	return 0;
}</code></pre>
<p>我们来看下引用和指针的汇编代码对比：<br/><img alt="" height="469" src="image\d9b3c1fceb794537b4c1be4ea95d0434.png" width="764"/></p>
<p>通过反汇编我们可以看出：引用是按照指针方式来实现的。</p>
</blockquote>
</div>
</div>