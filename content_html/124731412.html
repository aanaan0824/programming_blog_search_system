<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<p id="main-toc"><strong>目录</strong></p>
<p id="-toc" style="margin-left:0px;"></p>
<p id="%E5%97%A8%E5%92%AF%E9%93%81%E6%B1%81%E4%BB%AC%EF%BC%8C%E5%BE%88%E4%B9%85%E4%B8%8D%E8%A7%81%EF%BC%8C%E6%88%91%E8%BF%98%E6%98%AF%E4%BD%A0%E4%BB%AC%E7%9A%84%E8%80%81%E6%9C%8B%E5%8F%8B%E5%87%A1%E5%8F%94%EF%BC%8C%E8%BF%99%E9%87%8C%E4%B9%9F%E6%84%9F%E8%B0%A2%E5%90%84%E4%BD%8D%E5%B0%8F%E4%BC%99%E4%BC%B4%E7%9A%84%E7%82%B9%E8%B5%9E%E5%92%8C%E5%85%B3%E6%B3%A8%EF%BC%8C%E4%BD%A0%E4%BB%AC%E7%9A%84%E4%B8%89%E8%BF%9E%E6%98%AF%E6%88%91%E6%9C%80%E5%A4%A7%E7%9A%84%E5%8A%A8%E5%8A%9B%E5%93%88%EF%BC%8C%E6%88%91%E4%B9%9F%E4%B8%8D%E4%BC%9A%E8%BE%9C%E8%B4%9F%E5%90%84%E4%BD%8D%E7%9A%84%E6%9C%9F%E7%9B%BC%EF%BC%8C%E8%BF%99%E9%87%8C%E5%91%A2%E7%BB%99%E5%A4%A7%E5%AE%B6%E5%87%BA%E4%BA%86%E4%B8%80%E4%B8%AApytest%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%A7%A3%E3%80%82-toc" style="margin-left:0px;"><a href="#%E5%97%A8%E5%92%AF%E9%93%81%E6%B1%81%E4%BB%AC%EF%BC%8C%E5%BE%88%E4%B9%85%E4%B8%8D%E8%A7%81%EF%BC%8C%E6%88%91%E8%BF%98%E6%98%AF%E4%BD%A0%E4%BB%AC%E7%9A%84%E8%80%81%E6%9C%8B%E5%8F%8B%E5%87%A1%E5%8F%94%EF%BC%8C%E8%BF%99%E9%87%8C%E4%B9%9F%E6%84%9F%E8%B0%A2%E5%90%84%E4%BD%8D%E5%B0%8F%E4%BC%99%E4%BC%B4%E7%9A%84%E7%82%B9%E8%B5%9E%E5%92%8C%E5%85%B3%E6%B3%A8%EF%BC%8C%E4%BD%A0%E4%BB%AC%E7%9A%84%E4%B8%89%E8%BF%9E%E6%98%AF%E6%88%91%E6%9C%80%E5%A4%A7%E7%9A%84%E5%8A%A8%E5%8A%9B%E5%93%88%EF%BC%8C%E6%88%91%E4%B9%9F%E4%B8%8D%E4%BC%9A%E8%BE%9C%E8%B4%9F%E5%90%84%E4%BD%8D%E7%9A%84%E6%9C%9F%E7%9B%BC%EF%BC%8C%E8%BF%99%E9%87%8C%E5%91%A2%E7%BB%99%E5%A4%A7%E5%AE%B6%E5%87%BA%E4%BA%86%E4%B8%80%E4%B8%AApytest%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%A7%A3%E3%80%82">嗨咯铁汁们，很久不见，我还是你们的老朋友凡叔，这里也感谢各位小伙伴的点赞和关注，你们的三连是我最大的动力哈，我也不会辜负各位的期盼，这里呢给大家出了一个pytest自动化测试框架由浅入深详细讲解。</a></p>
<p id="%E4%B8%80%EF%BC%9A%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B-toc" style="margin-left:0px;"><a href="#%E4%B8%80%EF%BC%9A%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B">一：框架简介</a></p>
<p id="1%EF%BC%9APytest%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B%EF%BC%9A-toc" style="margin-left:0px;"><a href="#1%EF%BC%9APytest%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B%EF%BC%9A">1：Pytest框架简介：</a></p>
<p id="2%EF%BC%9Apytest%E6%A1%86%E6%9E%B6%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%EF%BC%9A-toc" style="margin-left:0px;"><a href="#2%EF%BC%9Apytest%E6%A1%86%E6%9E%B6%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%EF%BC%9A">2：pytest框架环境搭建：</a></p>
<p id="3%3Apytets%E6%89%A7%E8%A1%8C%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B-toc" style="margin-left:0px;"><a href="#3%3Apytets%E6%89%A7%E8%A1%8C%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B">3:pytets执行测试用例</a></p>
<p id="4%EF%BC%9A%E4%B8%80%E8%88%AC%E5%81%9A%E9%A1%B9%E7%9B%AE%E6%98%AF%E6%96%B0%E5%BB%BApackage%E5%8C%85%E7%9A%84%E3%80%80-toc" style="margin-left:0px;"><a href="#4%EF%BC%9A%E4%B8%80%E8%88%AC%E5%81%9A%E9%A1%B9%E7%9B%AE%E6%98%AF%E6%96%B0%E5%BB%BApackage%E5%8C%85%E7%9A%84%E3%80%80">4：一般做项目是新建package包的　</a></p>
<p id="5%EF%BC%9Apytest%E5%87%BD%E6%95%B0%E7%BA%A7%E5%88%AB-toc" style="margin-left:0px;"><a href="#5%EF%BC%9Apytest%E5%87%BD%E6%95%B0%E7%BA%A7%E5%88%AB">5：pytest函数级别</a></p>
<p id="6%EF%BC%9Apytest%E7%B1%BB%E7%BA%A7%E5%88%AB%EF%BC%88%E5%B7%A5%E4%BD%9C%E4%B8%80%E8%88%AC%E4%BB%A5%E7%B1%BB%E4%BD%8D%E5%8D%95%E5%85%83%EF%BC%8C%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97%E4%B8%80%E4%B8%AA%E7%B1%BB%EF%BC%8C%E7%99%BB%E5%BD%95%E7%B1%BB%EF%BC%8C%E8%AE%A2%E5%8D%95%E7%B1%BB%EF%BC%8C%E8%B4%AD%E7%89%A9%E7%B1%BB%EF%BC%89-toc" style="margin-left:0px;"><a href="#6%EF%BC%9Apytest%E7%B1%BB%E7%BA%A7%E5%88%AB%EF%BC%88%E5%B7%A5%E4%BD%9C%E4%B8%80%E8%88%AC%E4%BB%A5%E7%B1%BB%E4%BD%8D%E5%8D%95%E5%85%83%EF%BC%8C%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97%E4%B8%80%E4%B8%AA%E7%B1%BB%EF%BC%8C%E7%99%BB%E5%BD%95%E7%B1%BB%EF%BC%8C%E8%AE%A2%E5%8D%95%E7%B1%BB%EF%BC%8C%E8%B4%AD%E7%89%A9%E7%B1%BB%EF%BC%89">6：pytest类级别（工作一般以类位单元，一个模块一个类，登录类，订单类，购物类）</a></p>
<p id="7%EF%BC%9A%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E9%87%8C%E9%9D%A2%E7%9A%84%E7%8E%AF%E5%A2%83%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E9%99%A4-toc" style="margin-left:0px;"><a href="#7%EF%BC%9A%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E9%87%8C%E9%9D%A2%E7%9A%84%E7%8E%AF%E5%A2%83%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E9%99%A4">7：自动化测试里面的环境初始化与清除</a></p>
<p id="8%EF%BC%9Apytest%E5%89%8D%E7%BD%AE%E5%92%8C%E5%90%8E%E7%BD%AE%E6%9D%A1%E4%BB%B6%EF%BC%88%E7%8E%AF%E5%A2%83%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E9%99%A4%EF%BC%89%E3%80%80%E3%80%80-toc" style="margin-left:0px;"><a href="#8%EF%BC%9Apytest%E5%89%8D%E7%BD%AE%E5%92%8C%E5%90%8E%E7%BD%AE%E6%9D%A1%E4%BB%B6%EF%BC%88%E7%8E%AF%E5%A2%83%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E9%99%A4%EF%BC%89%E3%80%80%E3%80%80">8：pytest前置和后置条件（环境初始化与清除）　　</a></p>
<p id="9%EF%BC%9Apyets%E7%A7%8D%E6%9C%89%E5%9B%9B%E7%A7%8D%E7%BA%A7%E5%88%AB%E7%9A%84setup%E5%92%8Cteardown-toc" style="margin-left:0px;"><a href="#9%EF%BC%9Apyets%E7%A7%8D%E6%9C%89%E5%9B%9B%E7%A7%8D%E7%BA%A7%E5%88%AB%E7%9A%84setup%E5%92%8Cteardown">9：pyets种有四种级别的setup和teardown</a></p>
<p id="10%EF%BC%9Apytest%E9%87%8C%E9%9D%A2%E7%9A%84%E6%95%B0%E6%8D%AE%E5%88%9D%E5%A7%8B%E5%8C%96%E8%A3%85%E9%A5%B0%E5%99%A8fixture%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E-toc" style="margin-left:0px;"><a href="#10%EF%BC%9Apytest%E9%87%8C%E9%9D%A2%E7%9A%84%E6%95%B0%E6%8D%AE%E5%88%9D%E5%A7%8B%E5%8C%96%E8%A3%85%E9%A5%B0%E5%99%A8fixture%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E">10：pytest里面的数据初始化装饰器fixture参数说明</a></p>
<p id="%E3%80%80%E3%80%8011%EF%BC%9Afixture%C2%A0%E5%87%BD%E6%95%B0%E7%BA%A7%E5%88%AB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%8C%E7%8E%AF%E5%A2%83%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:0px;"><a href="#%E3%80%80%E3%80%8011%EF%BC%9Afixture%C2%A0%E5%87%BD%E6%95%B0%E7%BA%A7%E5%88%AB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%8C%E7%8E%AF%E5%A2%83%E5%88%9D%E5%A7%8B%E5%8C%96">　　11：fixture 函数级别的初始化，环境初始化</a></p>
<p id="%E3%80%80%E3%80%8012%EF%BC%9A%E7%B1%BB%E7%BA%A7%E5%88%AB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96class%EF%BC%8C%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8setup%E5%81%9A%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8fixture%E5%81%9A%E5%88%9D%E5%A7%8B%E5%8C%96%E3%80%80%E3%80%80-toc" style="margin-left:0px;"><a href="#%E3%80%80%E3%80%8012%EF%BC%9A%E7%B1%BB%E7%BA%A7%E5%88%AB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96class%EF%BC%8C%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8setup%E5%81%9A%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8fixture%E5%81%9A%E5%88%9D%E5%A7%8B%E5%8C%96%E3%80%80%E3%80%80">　　12：类级别的初始化class，可以使用setup做初始化，也可以使用fixture做初始化　　</a></p>
<p id="%E3%80%8013%EF%BC%9A%E7%B1%BB%E7%BA%A7%E5%88%AB%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AE%9E%E9%99%85%E4%BB%A3%E7%A0%81%EF%BC%9A%E5%88%9D%E5%A7%8B%E5%8C%96%E6%93%8D%E4%BD%9C%E6%98%AF%E7%99%BB%E5%BD%95%E6%93%8D%E4%BD%9C-toc" style="margin-left:0px;"><a href="#%E3%80%8013%EF%BC%9A%E7%B1%BB%E7%BA%A7%E5%88%AB%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AE%9E%E9%99%85%E4%BB%A3%E7%A0%81%EF%BC%9A%E5%88%9D%E5%A7%8B%E5%8C%96%E6%93%8D%E4%BD%9C%E6%98%AF%E7%99%BB%E5%BD%95%E6%93%8D%E4%BD%9C">　13：类级别初始化实际代码：初始化操作是登录操作</a></p>
<p id="%E3%80%8014%EF%BC%9A%E6%A8%A1%E5%9D%97%E7%BA%A7%E5%88%AB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96mudule%EF%BC%8C%E4%B8%8D%E7%AE%A1%E6%98%AF%E7%B1%BB%E8%BF%98%E6%98%AF%E6%96%B9%E6%B3%95%E3%80%80%E3%80%80%E3%80%80%E3%80%80%40pytest.fixture(scope%3D%22module%22)-toc" style="margin-left:0px;"><a href="#%E3%80%8014%EF%BC%9A%E6%A8%A1%E5%9D%97%E7%BA%A7%E5%88%AB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96mudule%EF%BC%8C%E4%B8%8D%E7%AE%A1%E6%98%AF%E7%B1%BB%E8%BF%98%E6%98%AF%E6%96%B9%E6%B3%95%E3%80%80%E3%80%80%E3%80%80%E3%80%80%40pytest.fixture%28scope%3D%22module%22%29">　14：模块级别的初始化mudule，不管是类还是方法　　　　@pytest.fixture(scope="module")</a></p>
<p id="%E3%80%80%E3%80%8015%EF%BC%9A%E4%B8%A4%E7%A7%8D%E8%B0%83%E7%94%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E6%B8%85%E9%99%A4%E5%87%BD%E6%95%B0%E7%9A%84%E6%96%B9%E5%BC%8F%2B%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B8%85%E9%99%A4%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:0px;"><a href="#%E3%80%80%E3%80%8015%EF%BC%9A%E4%B8%A4%E7%A7%8D%E8%B0%83%E7%94%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E6%B8%85%E9%99%A4%E5%87%BD%E6%95%B0%E7%9A%84%E6%96%B9%E5%BC%8F%2B%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B8%85%E9%99%A4%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E4%BD%BF%E7%94%A8">　　15：两种调用初始化和清除函数的方式+初始化清除函数的返回值的使用</a></p>
<p id="16%EF%BC%9Apytest%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8%EF%BC%88%E5%8F%82%E6%95%B0%E5%8C%96%EF%BC%89%E3%80%80-toc" style="margin-left:0px;"><a href="#16%EF%BC%9Apytest%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8%EF%BC%88%E5%8F%82%E6%95%B0%E5%8C%96%EF%BC%89%E3%80%80">16：pytest数据驱动（参数化）　</a></p>
<p id="17%EF%BC%9Apytest%E7%BB%93%E5%90%88allure%E6%8A%A5%E5%91%8A%E6%93%8D%E4%BD%9C%E3%80%80%E3%80%80-toc" style="margin-left:0px;"><a href="#17%EF%BC%9Apytest%E7%BB%93%E5%90%88allure%E6%8A%A5%E5%91%8A%E6%93%8D%E4%BD%9C%E3%80%80%E3%80%80">17：pytest结合allure报告操作　　</a></p>
<p id="%E3%80%80%E3%80%8018%EF%BC%9Aallure%E6%A8%A1%E6%8B%9F%E4%BB%A3%E7%A0%81-toc" style="margin-left:0px;"><a href="#%E3%80%80%E3%80%8018%EF%BC%9Aallure%E6%A8%A1%E6%8B%9F%E4%BB%A3%E7%A0%81">　　18：allure模拟代码</a></p>
<p id="%E3%80%80%E3%80%8019%EF%BC%9Aallure%E6%8A%A5%E5%91%8A%E7%9A%84%E4%BC%98%E5%8C%96-toc" style="margin-left:0px;"><a href="#%E3%80%80%E3%80%8019%EF%BC%9Aallure%E6%8A%A5%E5%91%8A%E7%9A%84%E4%BC%98%E5%8C%96">　　19：allure报告的优化</a></p>
<p id="%E3%80%8020%EF%BC%9A%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86%E7%82%B9-toc" style="margin-left:0px;"><a href="#%E3%80%8020%EF%BC%9A%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86%E7%82%B9">　20：其他知识点</a></p>
<p id="21%EF%BC%9Apytest%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90-toc" style="margin-left:0px;"><a href="#21%EF%BC%9Apytest%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90">21：pytest参数解析</a></p>
<p id="22%EF%BC%9Apytest%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E6%B8%85%E9%99%A4%EF%BC%9A-toc" style="margin-left:0px;"><a href="#22%EF%BC%9Apytest%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E6%B8%85%E9%99%A4%EF%BC%9A">22：pytest的初始化和清除：</a></p>
<p id="23%EF%BC%9Apytest%E4%B9%8B%EF%BC%9A%E4%B8%8D%E5%8F%AA%E6%98%AF%E6%B5%8B%E8%AF%95%E5%87%BD%E6%95%B0test_app%E8%83%BD%E5%8F%82%E6%95%B0%E5%8C%96%EF%BC%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0before_test%E4%B9%9F%E8%83%BD%E5%8F%82%E6%95%B0%E5%8C%96-toc" style="margin-left:0px;"><a href="#23%EF%BC%9Apytest%E4%B9%8B%EF%BC%9A%E4%B8%8D%E5%8F%AA%E6%98%AF%E6%B5%8B%E8%AF%95%E5%87%BD%E6%95%B0test_app%E8%83%BD%E5%8F%82%E6%95%B0%E5%8C%96%EF%BC%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0before_test%E4%B9%9F%E8%83%BD%E5%8F%82%E6%95%B0%E5%8C%96">23：pytest之：不只是测试函数test_app能参数化，初始化函数before_test也能参数化</a></p>
<p id="24%EF%BC%9Apytest%E6%A1%86%E6%9E%B6%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81%E4%B9%9F%E8%83%BD%E5%9C%A8cmd%E9%87%8C%E9%9D%A2%E7%9B%B4%E6%8E%A5%E8%BE%93%E5%85%A5%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C-toc" style="margin-left:0px;"><a href="#24%EF%BC%9Apytest%E6%A1%86%E6%9E%B6%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81%E4%B9%9F%E8%83%BD%E5%9C%A8cmd%E9%87%8C%E9%9D%A2%E7%9B%B4%E6%8E%A5%E8%BE%93%E5%85%A5%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C">24：pytest框架执行代码也能在cmd里面直接输入命令执行</a></p>
<p id="25%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F-toc" style="margin-left:0px;"><a href="#25%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F">25：分布式</a></p>
<p id="26%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><a href="#26%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0">26：分布式的实现</a></p>
<p id="27%EF%BC%9Apytest%E7%9A%84%E7%94%A8%E4%BE%8B%E5%AE%9A%E5%88%B6%E5%8C%96%E6%89%A7%E8%A1%8C%E3%80%80%E3%80%80mark%E6%A0%87%E7%AD%BE%EF%BC%8C-toc" style="margin-left:0px;"><a href="#27%EF%BC%9Apytest%E7%9A%84%E7%94%A8%E4%BE%8B%E5%AE%9A%E5%88%B6%E5%8C%96%E6%89%A7%E8%A1%8C%E3%80%80%E3%80%80mark%E6%A0%87%E7%AD%BE%EF%BC%8C">27：pytest的用例定制化执行　　mark标签，</a></p>
<hr id="hr-toc"/>
<p></p>
<h1 id="%E5%97%A8%E5%92%AF%E9%93%81%E6%B1%81%E4%BB%AC%EF%BC%8C%E5%BE%88%E4%B9%85%E4%B8%8D%E8%A7%81%EF%BC%8C%E6%88%91%E8%BF%98%E6%98%AF%E4%BD%A0%E4%BB%AC%E7%9A%84%E8%80%81%E6%9C%8B%E5%8F%8B%E5%87%A1%E5%8F%94%EF%BC%8C%E8%BF%99%E9%87%8C%E4%B9%9F%E6%84%9F%E8%B0%A2%E5%90%84%E4%BD%8D%E5%B0%8F%E4%BC%99%E4%BC%B4%E7%9A%84%E7%82%B9%E8%B5%9E%E5%92%8C%E5%85%B3%E6%B3%A8%EF%BC%8C%E4%BD%A0%E4%BB%AC%E7%9A%84%E4%B8%89%E8%BF%9E%E6%98%AF%E6%88%91%E6%9C%80%E5%A4%A7%E7%9A%84%E5%8A%A8%E5%8A%9B%E5%93%88%EF%BC%8C%E6%88%91%E4%B9%9F%E4%B8%8D%E4%BC%9A%E8%BE%9C%E8%B4%9F%E5%90%84%E4%BD%8D%E7%9A%84%E6%9C%9F%E7%9B%BC%EF%BC%8C%E8%BF%99%E9%87%8C%E5%91%A2%E7%BB%99%E5%A4%A7%E5%AE%B6%E5%87%BA%E4%BA%86%E4%B8%80%E4%B8%AApytest%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%A7%A3%E3%80%82">嗨咯铁汁们，很久不见，我还是你们的老朋友凡叔，这里也感谢各位小伙伴的点赞和关注，你们的三连是我最大的动力哈，我也不会辜负各位的期盼，这里呢给大家出了一个pytest自动化测试框架由浅入深详细讲解。</h1>
<p style="text-align:center;"><img alt="" src="image\c47c4d2867ab4c0c92c842fe4571624d.jpeg"/><span title="点击并拖拽以改变尺寸">​</span></p>
<p> </p>
<h1 id="%E4%B8%80%EF%BC%9A%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B"><strong>一：框架简介</strong></h1>
<p><strong>　　pytest，rf（学关键字语法，报告漂亮），unitest</strong><br/><strong>　　pytest是python的第三方单元测试框架，可以做系统测试，比unitest更简洁和高效，执行315种以上的插件，</strong></p>
<p><strong>　　　　同时兼容unittest框架，在unittest框架迁移到pytest框架的代码不需要重写代码</strong><br/><strong>　　unittest框架迁移到pytest框架的时候不需要重写代码</strong><br/><strong>　　纯python代码的自动化测试框架</strong></p>
<h1 id="1%EF%BC%9APytest%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B%EF%BC%9A"><strong>1：Pytest框架简介：</strong></h1>
<p><strong>　　接口测试方案：python</strong></p>
<p><strong>　　　　一：工具类：纯手工测试，用工具来做（postman jemeter soapui）--入门简单，不好扩展（后面很多框架定制化）</strong><br/><strong>　　　　二：代码类：现成的python框架：unitest(单元测试比较多，最原始的解释器自带的，不需要安装，不支持定制化，分布式) pytest（高级，效率高，支持定制化） nose</strong><br/><strong>　　　　　　rf（报告篇评论，需要学会--封装关键字）</strong><br/><strong>　　　　　　pytest和nose都是unitest扩展的更高级的一个库，框架，基于unitest</strong><br/><strong>　　　　三：测试平台：现成平台，公司自己定制开发的，不对外 （融合jmeter，）　　综合平台</strong><br/><strong>　　　　　　前端</strong><br/><strong>　　　　　　后端</strong><br/><strong>　　　　　　执行机制----框架pytest（一般融合了禅道，框架，邮件各种功能）</strong></p>
<p><strong>　　pytest是python的第三方单元测试框架，可以做系统测试，比unitest更简洁和高效，支持315种以上的插件，</strong></p>
<p><strong>　　同时兼容unittest框架，在unittest框架迁移到pytest框架的代码不需要重写代码</strong><br/><strong>　　unittest框架迁移到pytest框架的时候不需要重写代码</strong><br/><strong>　　纯python代码的自动化测试框架</strong></p>
<p><strong>　　pytest对比unitest框架的优势：高级，效率高，支持定制化，支持分布式，支持315种以上的丰富插件，还能向下兼容unitest</strong></p>
<p><strong>　　</strong><strong>pytest灵活：</strong></p>
<p><strong>　　　　1：定制化（定制化用例执行，定制化报告） </strong></p>
<p><strong>　　　　2：环境清除也灵活   　　以及各方面做的都比unittest更加灵活</strong></p>
<p><strong>　　pytest更加灵活，便捷，效率更高，　　还支持分布式（分布式是其他框架做不了）</strong></p>
<p><strong>　　分布式：1000个接口用例怎么跑，一条条跑很费劲，时间长，找几个同时分担执行测试用例（pytets独有的性质）</strong></p>
<h1 id="2%EF%BC%9Apytest%E6%A1%86%E6%9E%B6%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%EF%BC%9A"><strong>2：pytest框架环境搭建：</strong></h1>
<p><strong>　　pip pytest 　　　　　　　　　　　　　　  安装pytest</strong><br/><strong>　　pip install pytest-html 　　　　　　 　　  安装原生态报告模板--自带的（有点垃圾）</strong><br/><strong>　　Required-by: pytest-xdist(分布式测试), pytest-metadata, pytest-html, pytest-forked, allure-pytest</strong><br/><strong>　　100个接口用例，正常是一个个用例跑，时间很长，</strong><br/><strong>　　分布式-多个业务用例多条线来跑，提高效率（分布式设计用例---分布式逻辑设计，不要出现耦合，关联性太强的东西，否则会等待的）</strong></p>
<p style="text-align:center;"><strong><img alt="" src="image\f482460947f54baebd0946b3e6520ddb.jpeg"/></strong></p>
<p> </p>
<h1 id="3%3Apytets%E6%89%A7%E8%A1%8C%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B"><strong>3:pytets执行测试用例</strong></h1>
<p><strong>　　设计测试用例时候注意点（必须遵循的规则，否者不识别）：</strong></p>
<p><strong>　　　　1：.py测试文件必须以test（test_xxx）开头（或者以_test结尾）</strong><br/><strong>　　　　2：测试类必须以Test开头，并且不能有init方法-----测试类Test开头</strong><br/><strong>　　　　3：测试方法必须以test_开头</strong><br/><strong>　　　　4：断言必须使用assert</strong></p>
<h1 id="4%EF%BC%9A%E4%B8%80%E8%88%AC%E5%81%9A%E9%A1%B9%E7%9B%AE%E6%98%AF%E6%96%B0%E5%BB%BApackage%E5%8C%85%E7%9A%84%E3%80%80"><strong>4：一般做项目是新建package包的　</strong></h1>
<p><strong>　　项目文件</strong><br/><strong>　　　　lib库文件　　　　（登录接口源代码，其他接口公共的类,封装的库，登录的，订单的）（包）</strong><br/><strong>　　　　data文件　　　　（参数化数据，excel文件，yaml文件，csv文件---测试文件，用例，文档）(可以是普通文件夹)</strong><br/><strong>　　　　test_case文件　　（放测试用例的 ）（包）</strong><br/><strong>　　　　　　test_func01.py（测试用例，写的最好见名知意）</strong><br/><strong>　　　　report文件　　　　（存放测试报告的普通文件夹）</strong><br/><strong>　　　　config　　　　　　（配置文件）</strong></p>
<h1 id="5%EF%BC%9Apytest%E5%87%BD%E6%95%B0%E7%BA%A7%E5%88%AB"><strong>5：pytest函数级别</strong></h1>
<p>　　函数级别的测试用例必须test_开头：如下test_tc01，test_tc02两个测试用例</p>
<pre><code>import pytest
    def test_tc01():　　　　#定义函数类型测试用例　　
        assert 1+1==2  　　#断言
    def test_tc02():
        assert 1+1==3  　　#断言

    if __name__ == '__main__':
        pytest.main(["test_func01.py"])        #我主动运行我的pytest框架(自动调用所有的test测试函数，按照顺序依次运行，test开头的用例自动识别）</code></pre>
<h1 id="6%EF%BC%9Apytest%E7%B1%BB%E7%BA%A7%E5%88%AB%EF%BC%88%E5%B7%A5%E4%BD%9C%E4%B8%80%E8%88%AC%E4%BB%A5%E7%B1%BB%E4%BD%8D%E5%8D%95%E5%85%83%EF%BC%8C%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97%E4%B8%80%E4%B8%AA%E7%B1%BB%EF%BC%8C%E7%99%BB%E5%BD%95%E7%B1%BB%EF%BC%8C%E8%AE%A2%E5%8D%95%E7%B1%BB%EF%BC%8C%E8%B4%AD%E7%89%A9%E7%B1%BB%EF%BC%89"><strong>6：pytest类级别（工作一般以类位单元，一个模块一个类，登录类，订单类，购物类）</strong></h1>
<p><strong>　　类级别的测试l类必须以Test开头，并且类李不能有init方法，类里面的函数都是test_开头</strong></p>
<p><strong>　　封装好函数和类就行，其他的交给框架，设置好，框架帮你自动组织怎么运行</strong></p>
<p><strong>　　封装为了分层，后面更好维护，代码结构整洁</strong></p>
<pre><code>import pytest

class Test_login():  　　　　　　　　　　　　#登录模块的测试类
　　def test_login01(self):
    print("---test_login01----")
    assert 1 + 1 == 2
　　def test_login02(self):
    print("---test_login02----")
    assert 1 + 1 == 3
if __name__ == '__main__':
　　pytest.main(["test_func01.py","-s"])  #框架自己调用函数　　需要打印对应的信息，需要在列表里面加-s</code></pre>
<p style="text-align:center;"><strong><img alt="" src="image\9dae41d3ba6f44229ea6f247ed21ae2b.jpeg"/></strong></p>
<p> </p>
<h1 id="7%EF%BC%9A%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E9%87%8C%E9%9D%A2%E7%9A%84%E7%8E%AF%E5%A2%83%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E9%99%A4"><strong>7：自动化测试里面的环境初始化与清除</strong></h1>
<p><strong>　　</strong><strong>环境初始化目的：</strong></p>
<p><strong>　　　　清空测试环境的垃圾数据，前置条件</strong><strong>　　</strong></p>
<p><strong>　　　　</strong><strong>需不需要分层：需要</strong></p>
<p><strong>　　　　比如：</strong><strong>课程模块：课程模块的初始化需要</strong></p>
<p><strong>　　　　　　1：删除所有的课程 　　</strong></p>
<p><strong>　　　　　　</strong><strong>2：新增我们的一些课程（这个给修改/查询/删除接口使用）　　模块级别的（大的课程模块第一件事就是删除以前的课程）</strong></p>
<p><strong>　　　　　　　　</strong><strong>干掉数据后假如需要删除课程，这个接口需要单独的fixture的初始化，增加课程才能删除，其他的接口不需要这个fixture初始化，）</strong></p>
<p><strong>　　　　　　分层：模块层次的初始化，某个接口也需要初始化----框架的分层</strong></p>
<p><strong>　　　　　　条件初始化要和接口挂钩，接口该怎么就要怎么设计</strong></p>
<p><strong>　　环境初始化和清除，</strong></p>
<p><strong>　　　　一头一尾，两个不同概念，（环境的初始化也可以是清除数据）</strong><br/><strong> 　　　　一个接口可以多个级别的fixture，可以</strong> </p>
<p><strong>　　　　分布式：1：并行执行  2：分布式</strong></p>
<p><strong>　　　　</strong><strong>优化运行时间：分布式，（搭建环境麻烦）</strong></p>
<p><strong>　　</strong><strong>什么是环境初始化：</strong></p>
<p><strong>　　　　做这个用例之前想要做个操作，初始化动作，比如登录，首先需要连上这个项目(要先能ping通)，</strong></p>
<p><strong>　　　　环境初始化--比如课程新增需要数据全部清空，也是环境初始化</strong></p>
<p><strong>　　功能测试：保证测试环境数据和跑什么系统的，或者后台有什么进程执行，或者项目里面测试这功能，功能里面有没有垃圾数据要清除　　做个初始化 </strong></p>
<p><strong>　　unittest：最基础的框架，python自带（环境初始化和数据清除用setup和teardown）</strong></p>
<p><strong>　　jemeter：也有环境清除和初始化</strong></p>
<p><strong>　　不管做什么测试比如（功能，自动化，性能）都要对当前测试环境初始化，做完后要垃圾数据进行回收（特别是自动化，不然很多用例明明是对的会失败）</strong></p>
<p><strong>　　　　每次做一个场景，模块的时候，看看模块有没有需要前置的或者环境清除的步骤（基本操作流程）</strong></p>
<p><strong>　　pytest是unittest的升级版，对环境清除操作非常灵活（分层分级）</strong></p>
<p><strong>　　pytest：fixture操作类进行环境初始化  @fixture这样的一个装饰器</strong></p>
<p><strong>　　</strong><strong>pytest的fixture操作</strong></p>
<p><strong>　　　　</strong><strong>环境初始化与清除</strong></p>
<p><strong>　　　　pytest提供的fixture实现unitest中的setup/teardown功能，可以在每次执行case之前初始化数据</strong></p>
<p><strong>　　　　不同的是，fixture可以只在执行某几个特定case前运行，只需要在运行case前调用即可，比setup/teardown使用灵活</strong></p>
<p><strong>　　pytest的</strong><strong>初始化和清除可以类里面写个setup_class方法做，以类为单元，模块，包，方法为单元都可以，也可以用fixture来做</strong></p>
<p style="text-align:center;"></p>
<p> </p>
<h1 id="8%EF%BC%9Apytest%E5%89%8D%E7%BD%AE%E5%92%8C%E5%90%8E%E7%BD%AE%E6%9D%A1%E4%BB%B6%EF%BC%88%E7%8E%AF%E5%A2%83%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E9%99%A4%EF%BC%89%E3%80%80%E3%80%80"><strong>8：pytest前置和后置条件（环境初始化与清除）　　</strong></h1>
<p><strong>　　环境初始化</strong></p>
<p><strong>　　　　1：清除以前的数据  </strong></p>
<p><strong>　　　　2：测试的时候不是每个接口都要执行，可以定制化执行，固定执行某些接口，先执行删除用例，</strong></p>
<p><strong>　　　　　　但是数据已经被清除了，无法删除，修改--需要新增一批测试数据，所以这时候需要环境初始化和清除的想法</strong></p>
<p><strong>　　setup_class：类里面类级别的初始化，teardown</strong></p>
<p><strong>　　pytest初始化和前置条件,很多接口用例本身需要初始化,初始化分为很多层，</strong></p>
<p><strong>　　可以在整个外面做，也可以在里面做，测试类的初始化可以在类里面定义</strong></p>
<pre><code> import pytest
    class Test_login():  　　　　　　　　　　#登录模块的测试类
        #该测试类---有个前置的操作（初始化）
        def setup_class(self):　　　　　　#类级别的初始化--可选项
            #一个项目，先登录，再购物，登录就是购物类的前置条件，可以放在setup_class里面
            print("执行测试类之前，我需要执行操作")

        def test_login01(self):
            print("---test_login01----")
            assert 1 + 1 == 2
        def test_login02(self):
            print("---test_login02----")
            assert 1 + 1 == 3

        def teardown(self):　　　　　　　　　　　　#看业务本身需不需要初始化和清除环境，--可选项
            print("------该测试类的环境清除-----")

    if __name__ == '__main__':
        pytest.main(["test_func01.py","-s"]) </code></pre>
<h1 id="9%EF%BC%9Apyets%E7%A7%8D%E6%9C%89%E5%9B%9B%E7%A7%8D%E7%BA%A7%E5%88%AB%E7%9A%84setup%E5%92%8Cteardown"><strong>9：pyets种有四种级别的setup和teardown</strong></h1>
<p><strong>　　1：setup_module和teardown_module,在整个测试用例所在的文件中所在的文件中所有的方法运行前和运行后运行，只运行一次---模块的</strong><br/><strong>　　2：setup_class和teardown_class,在整个测试文件中的一个class中所有的用例的签后运行 ----class类</strong><br/><strong>　　3：setup_method和teardown_method,在class内的每个方法运行前后运行 ---------方法的</strong><br/><strong>　　4：setup_function和teardown_function,在非class下属的每个测试方法的前后运行 ----函数的</strong><br/><strong>　　　　分层分级（不同级别有不同方法）</strong></p>
<h1 id="10%EF%BC%9Apytest%E9%87%8C%E9%9D%A2%E7%9A%84%E6%95%B0%E6%8D%AE%E5%88%9D%E5%A7%8B%E5%8C%96%E8%A3%85%E9%A5%B0%E5%99%A8fixture%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E"><strong>10：pytest里面的数据初始化装饰器</strong><strong>fixture参数说明</strong></h1>
<pre><strong>    fixture_function: Optional[_FixtureFunction] = None,
    *,
    scope: "Union[_Scope, Callable[[str, Config], _Scope]]" = "function",  --scope参数:级别
    params: Optional[Iterable[object]] = None,------------------------------- params:参数
    autouse: bool = False,---------------------------------------------------- autouse：是否自动化执行
    ids: Optional[
        Union[
            Iterable[Union[None, str, float, int, bool]],
            Callable[[Any], Optional[object]],
        ]
    ] = None,
    name: Optional[str] = None</strong></pre>
<p><strong>　@pytest.fixture(scope=xxx,params=xxx,autouse=xxx)　</strong></p>
<p><strong>　　　　fiixture装饰器可以传单三个参数</strong></p>
<p><strong>　　　　　　1：</strong><strong>scope参数：初始化清除定义级别</strong></p>
<p><strong>　　　　　　  2：</strong><strong>params:参数</strong></p>
<p><strong>　　　　　　  3：</strong><strong>autouse：是否自动化执行</strong><strong>　</strong></p>
<p style="text-align:center;"><strong><img alt="" src="image\4c1e9663b097426ea3a39949bba23889.jpeg"/></strong></p>
<p> </p>
<h1 id="%E3%80%80%E3%80%8011%EF%BC%9Afixture%C2%A0%E5%87%BD%E6%95%B0%E7%BA%A7%E5%88%AB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%8C%E7%8E%AF%E5%A2%83%E5%88%9D%E5%A7%8B%E5%8C%96"><strong>　　11：</strong><strong>fixture </strong><strong>函数级别的初始化，环境初始化</strong></h1>
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> <p>12</p> <p>13</p> <p>14</p> <p>15</p> <p>16</p> <p>17</p> <p>18</p> <p>19</p> <p>20</p> <p>21</p> <p>22</p> <p>23</p> <p>24</p> <p>25</p> <p>26</p> <p>27</p> <p>28</p> <p>29</p> </td><td> <p><code>import</code> <code>pytest</code></p> <p></p> <p><code>　　　　　　　　　　　　　　　　</code><code>#函数级别的@pytest.fixture()初始化操作</code></p> <p><code>@pytest</code><code>.fixture()   　　　　</code><code>#标记函数是个初始化操作，标记后需要传给每个函数statr_func这个函数名才会执行初始化操作（函数级别的）</code></p> <p><code>def</code> <code>statr1_func():</code></p> <p><code>    </code><code>　　　　　　　　　　  </code><code>#这不是测试函数，一个普通函数,pytest执行用例只能识别test开头的方法和函数，所以pytest.main不会执行(不参加pytest用例)</code></p> <p><code>    </code><code>print</code><code>(</code><code>"------初始化操作1------"</code><code>)</code></p> <p></p> <p><code>@pytest</code><code>.fixture()</code></p> <p><code>def</code> <code>statr2_func():</code></p> <p><code>    </code><code>print</code><code>(</code><code>"------初始化操作2------"</code><code>)</code></p> <p></p> <p><code>#fixture:有哪些操作（可以多个初始化可以一起调，需要两个初始化，需要连接，需要登录）</code></p> <p><code>#这种写法很方便，函数需要statr_func1函数做一个初始化操作可以调用statr_func1这个函数，---def test_001(statr1_func):</code></p> <p><code># 需要其他初始化方法可以选择性调用其他初始化函数，传递函数名就行（灵活选择）----def test_002(statr2_func):</code></p> <p><code>#函数初始化操作需要传递几个函数也可以多个函数名传递--def test_003(statr2_func,statr1_func):</code></p> <p><code>#方便灵活</code></p> <p></p> <p><code>def</code> <code>test_001(statr1_func):</code></p> <p><code>    </code><code>print</code><code>(</code><code>"-----test01------"</code><code>)</code></p> <p></p> <p><code>def</code> <code>test_002(statr2_func):</code></p> <p><code>    </code><code>print</code><code>(</code><code>"-----test02 ------"</code><code>)</code></p> <p></p> <p><code>def</code> <code>test_003(statr2_func,statr1_func):</code></p> <p><code>    </code><code>print</code><code>(</code><code>"-----test03 ------"</code></p> <p></p> <p><code>if</code> <code>__name__ </code><code>=</code><code>=</code> <code>'__main__'</code><code>:</code></p> <p><code>    </code><code>pytest.main([</code><code>"test_pytest.py"</code><code>,</code><code>"-s"</code><code>])</code></p> </td></tr></tbody></table>
<h1><strong><img alt="" height="390" src="image\3e9b0ba6d0f64f12b975fbca9372f8c5.jpeg" width="390"/></strong></h1>
<h1 id="%E3%80%80%E3%80%8012%EF%BC%9A%E7%B1%BB%E7%BA%A7%E5%88%AB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96class%EF%BC%8C%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8setup%E5%81%9A%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8fixture%E5%81%9A%E5%88%9D%E5%A7%8B%E5%8C%96%E3%80%80%E3%80%80"><strong>　聪明的小伙伴就发现了，欸出bug了，</strong><code> </code><code>print</code><code>(</code><code>"-----test03 ------"这里明显少了个括号嘿嘿嘿，写代码还是要细心一点。记得加上【）】</code></h1>
<p style="text-align:center;"><code><img alt="" height="243" src="image\aebd246f411a4c30b80239d076a906c9.jpeg" width="363"/></code></p>
<p style="text-align:center;"> <img alt="" src="https://img-blog.csdnimg.cn/5e9ce2fab9c647fbb31bb7672d113ab1.gif"/></p>
<p style="text-align:center;"> <img alt="" src="image\2edf537d2ffd4ca3aca4a978515bc125.jpeg"/></p>
<p> </p>
<h1><strong>　12：类级别的初始化class，可以使用setup做初始化，也可以使用fixture做初始化　　</strong></h1>
<pre><code>  import pytest

        @pytest.fixture(scope="class")   　　　　　　　　#类级别的初始化函数  scope="class" 就是把这个初始化定义成类级别的
        def statr1_func():
            print("------初始化操作1------")

        class Test_00:　　　　　　　　　　　　　　　　　　#需要执行 Test_00测试类，需要做初始化(可以setup_class)
            # def setup_class(self):
            #     print("类内部的初始化,")  　　　　    #只对类有用,类级别的，类里只做一次(几个类的初始化操作一样这种不适合，需要重复写)
                                            　　     #fixture初始化类就是避免重复代码
            def test_001(self,statr1_func):
                print("-----test01------")

            def test_002(self,statr1_func):
                print("-----test02 ------")


        if __name__ == '__main__':
            pytest.main(["test_pytest01.py","-s"])</code></pre>
<pre><strong>

　　类级别初始化fixture，虽然test_001和test_002都调用了statr1_func这个类级别的初始化函数，但是执行类测试用例的时候只执行statr1_func初始函数一次
　　
　　多个类都可以调用statr1_func这个类级别的初始化方法,调用的时候最好放在类里的第一个函数，后面的函数可以不传(因为对应的是类级别的初始化)</strong></pre>
<p><strong> 　　</strong></p>
<pre><code>   import pytest
        @pytest.fixture(scope="class")   　　　　　　#类级别的初始化函数
        def statr1_func():
            print("------初始化操作1------")
                                                    #一个模块里面有函数用例也有类的用例怎么做：（class级别的初始化只对类有用，对函数没用）
        def test_003(statr1_func):                  #测试函数,
            print("-----test03------")

        class Test_00:                        #需要执行test00测试类，需要做初始化(可以setup_class)
            def test_001(self,statr1_func):
                print("-----test01------")

            def test_002(self,statr1_func):
                print("-----test02 ------")

        if __name__ == '__main__':
            pytest.main(["test_pytest01.py","-s"])</code></pre>
<pre><strong>

初始化方法</strong><strong>statr1_func定义成class类级别的，函数级别的测试测试用例test__003调用初始化函数会执行一次，
　　class类级别的测试用例Test_00调用初始化函数会执行一次（一共执行两次）
　　看级别的，整个模块的级别的化最好用module，否则有问题，fixture可以做return，会有返回值的，对应级别来做，
</strong></pre>
<pre><strong>执行结果：</strong></pre>
<p><strong>　　　　test_pytest01.py</strong><br/><strong>　　　　------初始化操作1------</strong><br/><strong>　　　　-----test03------</strong><br/><strong>　　　　.------初始化操作1------</strong><br/><strong>　　　　-----test01------</strong><br/><strong>　　　　.-----test02 ------ </strong></p>
<h1 id="%E3%80%8013%EF%BC%9A%E7%B1%BB%E7%BA%A7%E5%88%AB%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AE%9E%E9%99%85%E4%BB%A3%E7%A0%81%EF%BC%9A%E5%88%9D%E5%A7%8B%E5%8C%96%E6%93%8D%E4%BD%9C%E6%98%AF%E7%99%BB%E5%BD%95%E6%93%8D%E4%BD%9C"><strong>　13：类级别初始化实际代码：初始化操作是登录操作</strong></h1>
<pre><code>#课程模块的测试类
        import pytest
        from lib.api_lib.lesson import Lesson
        from lib.api_lib.lesson import Login
        from tools.execlMethod import get_excelData
        import json
        import os

        @pytest.fixture(scope="class")   　　　　　　　　#类级别的初始化函数
        def start_func():
            global sessionid
            sessionid = Login().login('{"username":"auto","password":"sdfsdfsdf"}')

        class Test_lesson:
            #1:课程新增接口,前置条件登录(封装完一个方法后想办法做数据驱动)，课程增加需要通过excel表用例来做
            @pytest.mark.parametrize("inData,repsData", get_excelData('2-课程模块', 2, 26))
            def test_lesson_add(self,start_func,inData,repsData):
                reps=Lesson(sessionid).lesson_add(inData)
                print(reps)
                assert reps["retcode"]==json.loads(repsData)["retcode"]

        if __name__ == '__main__':
            pytest.main(["test_lesson01.py", "-s", "--alluredir", "../report/tmp"])
            os.system("allure serve ../report/tmp")</code></pre>
<p style="text-align:center;"><strong><img alt="" height="314" src="image\a8992e6858e74babacade5ee80c49253.jpeg" width="293"/></strong></p>
<p> </p>
<h1 id="%E3%80%8014%EF%BC%9A%E6%A8%A1%E5%9D%97%E7%BA%A7%E5%88%AB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96mudule%EF%BC%8C%E4%B8%8D%E7%AE%A1%E6%98%AF%E7%B1%BB%E8%BF%98%E6%98%AF%E6%96%B9%E6%B3%95%E3%80%80%E3%80%80%E3%80%80%E3%80%80%40pytest.fixture(scope%3D%22module%22)"><strong>　14：模块级别的初始化mudule，不管是类还是方法　　　　@pytest.fixture(scope="module")</strong></h1>
<p><strong>　　　　模块（module）级别的初始化，（整个模块所有的类所有的东西要做一步操作，可以使用module这个模式）</strong></p>
<p><strong>　　　　只在模块运行前面只做一次，后面不做了，哪怕多调用也没用，一个模块里面有test_003函数测试用例，</strong></p>
<p><strong>　　　　也有classTest_00类级别的测试用例，定义一个模块级别的初始化函数statr1_func</strong></p>
<p><strong>　　　　函数里面调用初始化方法def test_003(statr1_func):和类里面的方法调用初始化方法test_001(self,statr1_func):，test_001(self,statr1_func):</strong></p>
<p><strong>　　　　整个模块执行的时候初始化函数都只执行一次（不管你这个模块里面调用多少次）</strong></p>
<pre><code>import pytest
        @pytest.fixture(scope="module")   　　　　　　#模块级别的初始化函数
        def statr1_func():
            print("------初始化操作1------")
            
        　　　　　　　　　　　　　　　　　　　　　　　　　　#一个模块里面有函数用例也有类的用例怎么做：（class级别的初始化只对类有用，对函数没用）
        def test_003(statr1_func):  　　　　　　　　  #测试函数,
            print("-----test03------")

        class Test_00:                        　　#需要执行test00测试类，需要做初始化(可以setup_class)
            # def setup_class(self):
            #     print("类内部的初始化,")  　　　　#只对类有用,类级别的，类里只做一次(几个类的初始化操作一样这种不适合，需要重复写)
            #                               　　　　#fixture初始化类就是避免重复代码

            def test_001(self,statr1_func):
                print("-----test01------")

            def test_001(self,statr1_func):
                print("-----test02 ------")

        if __name__ == '__main__':
            pytest.main(["test_pytest01.py","-s"])</code></pre>
<p><strong>　　　　　执行结果：test_pytest01.py</strong><br/><strong>　　　　　　　　　　------初始化操作1------</strong><br/><strong>　　　　　　　　　　-----test03------</strong><br/><strong>　　　　　　　　　　.-----test01------</strong><br/><strong>　　　　　　　　　　.-----test02 ------</strong></p>
<p><strong>　　　　在这个模块下面所有的都会调用（包级别的，包里面运行前做个环境清除）</strong></p>
<p><strong>　　　　需要在testcase文件夹里面创建一个conftest.py模块，这个</strong></p>
<p><strong>　　　　固定名称，pytest自动识别这个名称</strong></p>
<p><strong>　　　　testcase里面：新增课程前面需要登录，增加课程前面需要清除数据，需要2个级别的初始化，1：登录    2：整个环境的清除</strong></p>
<p><strong>　　　　test_case（测试用例文件夹）创建一个：conftest.py文件　　里面写包级别的初始化</strong></p>
<p><strong>　　　　</strong><strong>conftest.py文件里也能写类级别和模块级别的初始化，而且不需要调用，这个</strong><strong>conftest.py模块是pytest自动识别导入的</strong></p>
<pre><strong>        test_case　　　　　　　　　　　　　　　　#文件夹
            conftest.py           
                import pytest
                #包级别的初始化，在运行整个包之前做个初始化，包里面不同作用域，每个包里面都可以放一个，每个包里面的操作都可以不一样
                @pytest.fixture(scope="session",autouse=True)   　　　　　　　　#session级别的处于时候autouse=True默认自动执行
                def start_demo(request):                                     #包的开始
                    print("我是整个包的初始化")
                    def fin():  　　　　　　　　　　　　　　　　　　　　　　　　　　 #尾部这是包级别的，整个包做完后做个环境数据的清除    包的结束
                        print('---测试完成，包的数据清除---')

                    request.addfinalizer(fin)　　　　　　　　　　　　　　　　　　 #回调，当我整个包运行完了后回调fin这个方法

       #fixture的参数autouse: bool = False,---自动执行参数
　　　　#session的级别，包里面有很多模块，很多模块需要对整个包进行初始化在conftest.py里面做模块的数据初始化和清除（conftest.py只对当前包有用）
</strong></pre>
<p style="text-align:center;"><strong><img alt="" src="image\9b3b1cabe4dd4f4aa68ffa99cde35531.jpeg"/></strong></p>
<p> </p>
<h1 id="%E3%80%80%E3%80%8015%EF%BC%9A%E4%B8%A4%E7%A7%8D%E8%B0%83%E7%94%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E6%B8%85%E9%99%A4%E5%87%BD%E6%95%B0%E7%9A%84%E6%96%B9%E5%BC%8F%2B%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B8%85%E9%99%A4%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E4%BD%BF%E7%94%A8"><strong>　　15：两种调用初始化和清除函数的方式+初始化清除函数的返回值的使用</strong></h1>
<pre><code>import pytest
@pytest.fixture()
def befor_func():
    print('xxxxxxxxxxxxx测试用例的初始化xxxxxxxxxxxxxxxx')
    yield 10
    print('zzzzzzzzzzzzzzzzzz测试用例的清除zzzzzzzzzzzzzz')

def test_001(befor_func):　　　　　　　　　　　　　　　　#调用初始化和清除方式一：直接在测试用例里传递初始化清除函数的函数名来调用
    print("测试用例001")
    res=befor_func　　　　　　　　　　　　　　　　　　　　#如果初始化清除函数有返回值，可以直接这样接收参数来使用
    print(res)

@pytest.mark.usefixtures('befor_func')　　　　　　　　#调用初始化和清除方式二：使用usefixtures放在测试用例前面直接调用初始化清除函数
def test_002():
    print("测试用例002")

if __name__ == '__main__':
    pytest.main(["test1.py",'-s'])</code></pre>
<p>　<strong>　七：pytest前置条件+后置条件的两种写法</strong></p>
<p><strong>　　　　1：使用yield关键字来是实现　　推荐使用这种，因为yield关键字能返回函数的值</strong></p>
<pre><code>import pytest
@pytest.fixture()
def befor_func():
    print('xxxxxxxxxxxxx测试用例的初始化xxxxxxxxxxxxxxxx')
    yield 10　　　　　　　　　　　　　　　　　　　　　　　　　　　　#yield后面跟的是测试用例的后置条件，支持用例执行后就执行yield里的内容
    print('zzzzzzzzzzzzzzzzzz测试用例的清除zzzzzzzzzzzzzz')

def test_001(befor_func):
    print("测试用例001")
    res=befor_func
    print(res)

if __name__ == '__main__':
    pytest.main(["test1.py",'-s'])</code></pre>
<p><strong>　　　　2：使用finc()函数来实现　　　　这种就不能返回返回值了</strong></p>
<pre><code>
import pytest
@pytest.fixture()
def befor_func(request):
    print('xxxxxxxxxxxxx测试用例的初始化xxxxxxxxxxxxxxxx')
    def fin():　　　　　　　　　　　　　　　　　　　　　　　　#尾部这是后置条件，测试用例执行后就会调用这个函数　　　　　　
        print('zzzzzzzzzzzz测试用例的清除zzzzzzzzzzz')

    request.addfinalizer(fin)　　　　　　　　　　　　　　　#回调，当我整个包运行完了后回调fin这个方法　　　　　　　　　　
def test_001(befor_func):
    print("测试用例001")

if __name__ == '__main__':
    pytest.main(["test1.py",'-s'])</code></pre>
<pre></pre>
<p></p>
<h1 id="16%EF%BC%9Apytest%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8%EF%BC%88%E5%8F%82%E6%95%B0%E5%8C%96%EF%BC%89%E3%80%80"><strong>16：pytest数据驱动（参数化）　</strong></h1>
<p><strong>　　pytest数据驱动的意义：</strong></p>
<p><strong>　　　　参数化（登录用例4条，每一个账号密码都不同，使用框架把4个用例全部执行完，不需要for循环遍历执行，采用数据驱动方案来做）</strong></p>
<p><strong>　　　　pytest内置装饰器@pytest.mark.parametrize可以让测试数据参数化，把测试数据单独管理，类似ddt数据驱动的作用，方便代码和测试数据分离</strong></p>
<p><strong>　　@pytest.mark.parametrize("a",[1,2,3])：　　　　　　　　参数化传一组参数　　</strong></p>
<p><strong>　　@pytest.mark.parametrize("a,b", [(1,2),(3,4),(5,6)]) 　　   参数化传多组参数</strong></p>
<p><strong>　　登录账户密码（name和psw不同的用例组合，一个接口几十个用例怎么做----几十组数据----传的参数不同（什么请求方式和各种都一样）</strong></p>
<p><strong>　　可以把name和psw分别采取多组数据进行参数化，数据分离，一个接口跑4次，每次用不同的参数）</strong></p>
<pre><code>    import pytest
    #[(1,2),(3,4),(5,6)]   [1,2,3]
    class Test_login():  
        def setup_class(self):
            print("执行测试类之前，我需要执行操作")

        @pytest.mark.parametrize("a",[1,2,3])            #("变量名",[1,2,3]),数据需要封装成一个列表，多个数据需要封装成列表嵌套元组   ----数据驱动
        def test_login01(self,a):                  #数据驱动，一定要把变量名a引入引来，不然无法参数化</code></pre>
<pre><code>print("---test_login01----")
            assert 1 + 1 == a

        @pytest.mark.parametrize("a,b", [(1,2),(3,4),(5,6)])    #数据驱动传多组参数
        def test_login02(self,a,b):
             print("---test_login02----")
             assert a + 1 == b

        def teardown_class(self):
            print("------该测试类的环境清除-----")

    if __name__ == '__main__':
        pytest.main(["test_func01.py","-s"])  </code></pre>
<p style="text-align:center;"><img alt="" height="389" src="image\b8396d7c64ad4d1785d867032526188a.jpeg" width="363"/></p>
<p> </p>
<h1 id="17%EF%BC%9Apytest%E7%BB%93%E5%90%88allure%E6%8A%A5%E5%91%8A%E6%93%8D%E4%BD%9C%E3%80%80%E3%80%80"><strong>17：pytest结合allure报告操作　　</strong></h1>
<p><strong>　　一：pytest自带的报告框架  pytest-html</strong></p>
<p><strong>　　二：allure环境搭建（allure是报告库不是python专属的，很全面的框架）-allure报告漂亮</strong></p>
<p><strong>　　　　1：下载allure.zip（压缩包）</strong><br/><strong>　　　　2：解压allure.zip到一个文件目录</strong><br/><strong>　　　　3：将allure-2.13.3\bin路径添加到环境变量path</strong><br/><strong>　　　　4：pip install allure-pytest -------allure报告本身不是很漂亮，通过allure-pytest这个库可以定制化报告，让报告变得很漂亮</strong><br/><strong>　　　　5：验证（cmd输入allure）</strong></p>
<p><strong>　　三：allure和pytest联合执行生成报告：运行两条语句</strong></p>
<p><strong>　　　　1：执行pytest单元测试，生成的allure报告需要的数据存在/tmp目录</strong></p>
<p>　　　　pytest -sq --alluredir=../report/tmp　　　#pytest把allure报告的生成的中间文件放到一个临时文件里面（pytets生成报告，需要数据，所以先把数据存起来）</p>
<p>　　　　　　　　　　　　　　　　　　　　　　#所有的报告需要数据支持的，数据来源pytest框架本身，结果数据存到一个文件，存在../report/tmp文件夹　</p>
<p>　　　　　　　　　　　　　　　　　　　　　　#tmp临时文件，一般json格式　　　　　　</p>
<p><strong>　　　　2：执行命令，生成测试报告</strong></p>
<p>　　　　allure generate ../report/tmp -o ../report/report -clean   　　　　　　#allure指令生成对应报告</p>
<h1 id="%E3%80%80%E3%80%8018%EF%BC%9Aallure%E6%A8%A1%E6%8B%9F%E4%BB%A3%E7%A0%81"><strong>　　18：allure模拟代码</strong></h1>
<pre><code>  import pytest
        import os
        class Test_login():  
            def setup_class(self):
                print("执行测试类之前，我需要执行操作")

            @pytest.mark.parametrize("a",[1,2,3])
            def test_login01(self,a):  
                print("---test_login01----")
                assert 1 + 1 == a

            @pytest.mark.parametrize("a,b", [(1,2),(3,4),(5,6)])
            def test_login02(self,a,b):
                 print("---test_login02----")
                 assert a + 1 == b

            def teardown_class(self):
                print("------该测试类的环境清除-----")

        if __name__ == '__main__':
                            #需要打印对应的信息，需要在列表里面加-s
                            #1:--alluredir ---生成临时文件，测试用例的结果数据放到目录   --alluredir   存放目录
            pytest.main(["test_func01.py","-s","--alluredir","../report/tmp"])  #框架自己调用函数
                            #通过--alluredir把allure需要的数据存到../report/tmp这个路径下面
                            #../--所在路径的父级别目录是test_case的目录隔壁邻居report文件下tmp，专门放alluer报告生成的需要的数据源

                            # 2:临时数据没有报告的，allure generate allure才会生成报告   -----allure生成器生成allure报告--generate allure生成器,cmd指令
                            #需要os模块os.system()调用指令可以在local的cmd里面敲
            os.system("allure generate ../report/tmp -o ../report/report --clean")
                            #os.system("allure generate 报告需要的数据 -o 报告存放目录 --clean")
                            #-o生成
                            #allure generate生成报告指令，把../report/tmp 的文件-o生成报告out out一下，生成的报告放在../report/report
                            #--clean把上次报告清除一下用--clean
　 　　　　　　　　　　　　　　　#allure报告生成的是一个服务，（本地服务）和jinkins结合，放在整个里面去集成，放到公共服务器里面          </code></pre>
<h1 id="%E3%80%80%E3%80%8019%EF%BC%9Aallure%E6%8A%A5%E5%91%8A%E7%9A%84%E4%BC%98%E5%8C%96"><strong>　　19：allure报告的优化</strong></h1>
<pre><code>  import pytest
        import os
        import allure       
        @allure.feature("登录模块")                                                      #一级标题，大模块标题（类标签）
        class Test_login():                                                              
            def setup_class(self):                                                                  
                print("执行测试类之前，我需要执行操作")

            @allure.story("登录login01")                                                  # 二级标签（每个接口的标签）
            @allure.title("login01")                                                     # 标题，每个用例带个标题（报告体现在每个测试用例）(一个接口有几个用例，title用例的标签)
            @pytest.mark.parametrize("a",[1,2,3])                                      
            def test_login01(self,a):                                                      
                print("---test_login01----")
                assert 1 + 1 == a

            @allure.story("登录login02")                                                  # 二级标签，定制allure报告层级
            @allure.title("login02")                                                     #标题，每个用例带个标题（报告体现在每个测试用例）
            @pytest.mark.parametrize("a,b", [(1,2),(3,4),(5,6)])                      
            def test_login02(self,a,b):
                 print("---test_login02----")
                 assert a + 1 == b

            def teardown_class(self):                                               
                print("------该测试类的环境清除-----")


        @allure.feature("购物模块")
        class Test_Shopping():
            @allure.story("shopping")
            @allure.title("shopping01")
            @pytest.mark.parametrize("a,b", [(1, 2), (3, 4), (5, 6)])
            def test_shopping(self, a, b):
                print("---test_login02----")
                assert a + 1 == b
        if __name__ == '__main__':
            pytest.main(["test_func01.py","-s","--alluredir","../report/tmp"])    
            os.system("allure generate ../report/tmp -o ../report/report --clean")
            #allure报告生成的是一个服务，（本地服务）和jinkins结合，放在整个里面去集成，放到公共服务器里面     </code></pre>
<p style="text-align:center;"><strong><img alt="" height="446" src="image\ebd8e86f2f7445c3920aa28839975448.jpeg" width="490"/></strong></p>
<p> </p>
<h1 id="%E3%80%8020%EF%BC%9A%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86%E7%82%B9"><strong>　20：其他知识点</strong></h1>
<p><strong>　　　　测试用例一般写在excel表格文件里面，数据分离（维护好excel就行）</strong></p>
<p><strong>　　　　pytest--从头到尾到报告执行发邮件</strong></p>
<p><strong>　　　　字典是一种存储类型，json是一种格式（完全不同）</strong></p>
<h1 id="21%EF%BC%9Apytest%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90"><strong>21：pytest参数解析</strong></h1>
<p><strong>　</strong></p>
<pre><code>　pytest.main(['test_boss.py','-s','-k test_modify_psw','--alluredir=tmp/my_allure_results'])

　　　　test_boss.py 　　　　　　　　指定测试用例文件，
　　　　-s 　　　　　　　　　　　　 显示print语句
　　　　-k test_modify_psw 　　　　 指定某个测试用例

　　　　-n 　　　　　　　　　　　　表示用两个进程启动测试脚本

　　　　生成报告缓存文件　　--alluredir=tmp/my_allure_results

　　　　os.system('allure serve tmp/my_allure_results')　　　　打开测试报告，命令行需要python 的os模块调用</code></pre>
<h1 id="22%EF%BC%9Apytest%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E6%B8%85%E9%99%A4%EF%BC%9A"><strong>22：pytest的初始化和清除：</strong></h1>
<pre><code>import pytest
        #假设启动被测app的时候需要去填写配置项信息，每个的端口号不同，多终端需要两个appim server
        #这时候setup_module和teardown_module不能传参，搞不定，需要换一种方法做测试用例的初始化和清除，

        　　　　　　　　　　　　　　　　#setup_module以模块为作用域，不写module以测试用例（测试函数）为作用域
        # def setup_module(): 　　 #测试用例之前执行，原始的setup和teardown有个缺陷，里面不能传参数，
        #             　　　　　　   #默认test级别，每个测试用例执行的时候都会执行一次，希望当前某个模块执行的时候只执行一次（不管里面用例执行多少次）
        #             　　　　　　   #setup初始化和tear_down升个级，升级成module模块级别的
        #     print("启动被测app")
        #     print('连接appium服务')
        #
        # def teardown_module():
        #     print('关闭被测app')
        #     print('断开appium服务')

        #定义个函数，名字随便取　　使用@pytest.fixture装饰器把这个函数装饰成初始化清除函数
        @pytest.fixture(scope='module')    #作用域默认test，初始化，加装饰器，初始化清除函数,autouse=True（自动执行）这种方法不建议使用                               #
        def before_test():                   #初始化函数升级作用域到module模块级别
            print("启动被测app")
            print('连接appium服务')
            yield   #后面写清除动作，
            after_test()

        #清除函数，清除函数并不会直接被初始化函数使用，我们必须放在初始化函数yiled后面才能回被调用
        def after_test():
            print('关闭被测app')
            print('断开appium服务')
        #目前一共有两个port，需要测试两个手机，两个多终端,before_test需要装饰器标记

        #测试用例的参数化
        @pytest.mark.usefixtures('before_test')                        #这表示调用某个自定义的初始化函数，括号里面的字符串写被调用函数的名字
        @pytest.mark.parametrize('psw',['boss123','boss456'])
        def test_app(psw):                        #测试用例，可能涉及到其他参数,比如需要一些配置信息,测试用例涉及到参数，
　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　#多组参数需要使用装饰器pytest.mark.parametrize(数据驱动)，psw传参和形参名字对应的
            print('测试boss app')
            print(f'登录测试账号{psw}')

        if __name__ == '__main__':
            pytest.main(['pytest_ywt.py','-s'])</code></pre>
<h1 id="23%EF%BC%9Apytest%E4%B9%8B%EF%BC%9A%E4%B8%8D%E5%8F%AA%E6%98%AF%E6%B5%8B%E8%AF%95%E5%87%BD%E6%95%B0test_app%E8%83%BD%E5%8F%82%E6%95%B0%E5%8C%96%EF%BC%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0before_test%E4%B9%9F%E8%83%BD%E5%8F%82%E6%95%B0%E5%8C%96"><strong>23：pytest之：不只是测试函数test_app能参数化，初始化函数before_test也能参数化</strong></h1>
<p><strong>　　重点：</strong><strong>测试用例的参数化+初始化清除函数的参数化　　初始化清除函数的参数化能够实现appium的多终端测试</strong></p>
<p><strong>　　　　初始化清除函数的参数化，方法很多种：</strong></p>
<p><strong>　　　　before_test初始化函数注入参数，因为print(f'连接appium服务{port}')里面port需要变化的，</strong></p>
<p><strong>　　　　</strong><strong>@pytest.fixture(scope='module',params=[(4723,),(4727,)])　　：初始化清除函数的参数化</strong></p>
<p>　　　　　　始化函数装饰器里面加params参数传参，port=request.param[0] 来调用params里的参数</p>
<pre>　　　　　　#<strong>初始化清除函数的参数化：只传单个参数</strong>
<strong>            import pytest
            @pytest.fixture(scope='module',params=[(4723,),(4727,)])     #初始化清除函数的参数化params
            def before_test(request):           
                port=request.param[0] 　　　　　　　　　　　　　　#param[0]，假如注入多个参数一个port和一个data--需要params传元组，
                                                              #params=[(4723,100),(4727,200)],一个参数的话不需要写成列表嵌套元素，
　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　#params[0]代表获取元组第一个
                print("启动被测app")
                print(f'连接appium服务{port}')
                yield   #后面写清除动作，
                after_test()
            　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　#request是pytest的对象，我们在用对象里面的方法的时候pycham不会自动帮我们取显示名字，
　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　#它也不知道request里面到底什么内容
           </strong></pre>
<pre><code> def after_test():
                print('关闭被测app')
                print('断开appium服务')

            @pytest.mark.usefixtures('before_test')    
            @pytest.mark.parametrize('psw',['boss123','boss456'])
            def test_app(psw):                                   
                print('测试boss app')
                print(f'登录测试账号{psw}')

            if __name__ == '__main__':
                pytest.main(['pytest_ywt.py','-s'])    　　
　　　　　　#初始化清除函数的参数化：传多个参数　　　　　　　　　　　　　　
　　　　　　　import pytest</code></pre>
<pre><strong>　　　　　　　@pytest.fixture(scope='module',params=[(4723,'xiaomi'),(4727,'meizu')])  
            def before_testquest):           
                port=request.param[0]    　　　　　　#param[0]，假如注入多个参数一个port和一个data，需要params传元组，params=[(4723,100),(4727,200)],
                                            　　　　#一个参数的话不需要写成列表嵌套元素，request.params[0]代表获取元组第一个
                device=request.param[1]      　　　　#request.param[1]对应元素里面第二个参数，
                print(f"在{device}启动被测app")
                print(f'连接appium服务{port}')
                yield   #后面写清除动作，
                after_test()
                
            　　　　　　　　　　　　　　　　　　　　　　　　#request是pytest的对象，(固定写法：request.param)
　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　#我们在用对象里面的方法的时候pycham不会自动帮我们去显示名字，它也不知道request里面到底什么内容
         </strong></pre>
<pre><code>   def after_test():
                print('关闭被测app')
                print('断开appium服务')

            @pytest.mark.usefixtures('before_test')                    
            @pytest.mark.parametrize('psw',['boss123','boss456'])
            def test_app(psw):           
                                        
                print('测试boss app')
                print(f'登录测试账号{psw}')

            if __name__ == '__main__':
                pytest.main(['pytest_ywt.py','-s'])</code></pre>
<p style="text-align:center;"><strong><img alt="" src="image\2b521f0db06d48b58810366ba1e25c30.jpeg"/></strong></p>
<p> </p>
<h1 id="24%EF%BC%9Apytest%E6%A1%86%E6%9E%B6%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81%E4%B9%9F%E8%83%BD%E5%9C%A8cmd%E9%87%8C%E9%9D%A2%E7%9B%B4%E6%8E%A5%E8%BE%93%E5%85%A5%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C"><strong>24：pytest框架执行代码也能在cmd里面直接输入命令执行</strong></h1>
<p><strong>　　　　xxx\</strong><strong>test_case</strong><strong>&gt; </strong><strong>pytest -s     　　在test_case这个目录执行会运行test_case文件里面所有的测试文件（test开头的测试用例）</strong></p>
<h1 id="25%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F"><strong>25：分布式</strong></h1>
<p><strong>　　</strong><strong>设置用例每个模块独立，有什么前置做到模块里面，比如测试10个模块，用相关联来做，不能做分布式(并发执行)</strong></p>
<p><strong>　　</strong><strong>每个模块独立还能定制执行那个模块，关联性太强做不到</strong><strong>　　</strong></p>
<p><strong>　　</strong><strong>最好做到每个接口都独立化（前置条件做好）不要做太大关联性的接口</strong></p>
<p><strong>　　每一层都能做环境清除和定制化（包，模块。类，函数）分层，为后面mark（定点执行哪些用例）和分布式打基础</strong></p>
<p><strong>　　分布式：必须做到用例的隔离（低耦合，高内聚），用例走串行风险很大，很难维护</strong></p>
<p><strong>　　　　3000个请求，全部独立化，然后分布式来做（效率提高几倍--几十倍）</strong></p>
<h1 id="26%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0"><strong>26：分布式的实现</strong></h1>
<p><strong>　　分布式的核心点：封装设计：相互独立，登录和课程相互独立，至少模块为单元要相互独立，封装相互独立，接口用例之间最好也相互独立　　才能进行分布式</strong></p>
<p><strong>　　一：pytest分布式环境搭建和理论介绍：</strong></p>
<p><strong>　　　　第一步：安装一个库  pip install pytest-xdist   　　分布式运行插件,可以做分布式（这个库有两种运行方式）</strong></p>
<p><strong>　　　　运行方式：</strong></p>
<p><strong>　　　　　　1：串行，顺序运行，串行运行，从头到尾</strong></p>
<p><strong>　　　　　　2：并行:pytest-xdist做分布式有两种，一种多核，一种多台机器</strong></p>
<p><strong>　　　　　　　　一：多核：单机多核来做（同时跑）     使用-n参数</strong></p>
<p><strong>　　　　　　　　　　电脑多核有假有真：超线程技术（8内核搞成16核），真8核假8核---</strong></p>
<p><strong>　　　　　　　　　　cpu个数：硬件，几个cpu槽，i9900.i710--一般电脑就算一个cpu，单cpu，服务器可能有多个cpu</strong></p>
<p><strong>　　　　　　　　　　核数：   电脑的核数，</strong></p>
<p><strong>　　　　　　　　　　逻辑核数：逻辑核数可以虚拟化，8核可以变成16核（超线程技术）</strong></p>
<p><strong>　　　　　　　　　　多核的话xdist本身的多核的话一般用逻辑核数来做的</strong></p>
<p><strong>　　　　　　　　二：多机（可以使用虚拟机）---需要搭环境，多台机器 很麻烦，装环境，下库</strong></p>
<p><strong>　　二：测试用例比较多怎么办：分布式   两种情况　　</strong></p>
<p><strong>　　　　1：量大：多机  （需要文件报告收集还需要搭环境，做起来比较麻烦）</strong></p>
<p><strong>　　　　2：单机多核　　很简单，加-n 参数就行  （做ui和需要一些时间等待的时候时间优化特别明显）</strong></p>
<p><strong>　　　　串行运行：本身是线程去跑的，python就一个进程，里面很多线程，</strong></p>
<p><strong>　　　　走进程的话需要多台机器来做，分量，  用例设计不好会有大问题，数据不对(用例一定要独立化)</strong></p>
<p><strong>　　　　并行和多机：用例一定要设计好，不然数据容易出错，逻辑独立（不能有任何关联，不能有前后关系）　　数据和代码封装时候独立化</strong></p>
<p><strong>　　三：分布式运行代码</strong></p>
<pre><strong>    #验证单机多核分布式
   </strong>
</pre>
<pre><code> import pytest
    import time

    def test_01():
        time.sleep(3)
        print("-----test01-----")

    def test_02():
        time.sleep(3)
        print("-----test01-----")


    if __name__ == '__main__':
        # pytest.main(["test_xdist.py","-sq"])  　　　　　　　　#这是串行跑的   6s
        pytest.main(["test_xdist.py", "-sq","-n","8"]) 　　　　#单机多核并行   加"-n","8" 参数  ，用8个核来跑,5.41s,时间少了
        #或者测试用例文件目录下 cmd，输入 pytest test_xdist.py -n 8  也可以    这样cmd里执行看到的结果更直观，
        #多核来跑在ui里面时间提升很大，ui里面很多地方需要sleep，等待元素（有等待的的提升比较大）多核跑更快
            #有等待的情况用多核跑效果越明显</code></pre>
<pre><strong>
            
        串行运行本身按照线程去跑的，python本身就一个进程，里面很多线程 
        走进程的话，多台机器做比较合适---分量，
        用例一定要设计好，不然数据容易出错，逻辑独立（不能有任何关联，不能有前后关系）----数据和代码封装时候独立化
    
pytest cmd执行多个模块用例：pytest test_xdist.py test_login.py -sq     　　：运行两个.py文件（写多个运行多个）
pytest cmd执行多个包的用例：pytest test_xdist test_login -sq           　　：运行test_xdist包和test_login 包
还可以运行不同模块的两个包,加包路径  case/test_xdist.py   case2/test2_xdist.py</strong></pre>
<h1 id="27%EF%BC%9Apytest%E7%9A%84%E7%94%A8%E4%BE%8B%E5%AE%9A%E5%88%B6%E5%8C%96%E6%89%A7%E8%A1%8C%E3%80%80%E3%80%80mark%E6%A0%87%E7%AD%BE%EF%BC%8C"><strong>27：pytest的用例定制化执行　　mark标签，</strong></h1>
<p><strong>　　</strong><strong>所有的接口不需要全部都跑（冒烟，定制化执行某些指定的业务，）　　　　　"-m","test_lesson_add"</strong><strong>　</strong></p>
<p><strong>　　</strong><strong>一：pytest框架mark标签　　标记非常丰富　　mark标签</strong></p>
<p><strong>　　　</strong><strong>mark标签：对于pytest，我们可以再每一个模块，每一个类，每一个方法和用例前面都加上mark，</strong></p>
<p><strong>　　　　　　　　那样我们在pytest运行的时候就可以只运行带有该mark标签的模块，类，用例</strong>　　</p>
<p>　<strong>　　　　　　　这样的话可以方便我们选择执行自动化时，是执行全部用例，某个模块用例，</strong></p>
<p><strong>　　　　　　　　某个流程用例，某个单独用例，总之就是可以某个单独的标签下所有用例</strong></p>
<p><strong>　　</strong><strong>mark可以标记不同层次的东西（类，函数，方法都可以标记）文件不用标记（本身就可以定制化执行）</strong></p>
<p><strong>　　@pytest.mark.lessson_moudle 　　给测试类贴个标签，标签名字叫lessson_moudle标识课程模块，</strong></p>
<p><strong>　　　　各个函数，类都可以贴上标签（类似别称），选择某个标签就运行某一个（灵活方便）</strong></p>
<p><strong>　　</strong><strong>什么都不选中照常运行，（全部运行，没有限制）</strong></p>
<p><strong>　　mark标签pytest运行可能报错，</strong></p>
<p><strong>　　　　</strong><strong>PytestUnknownMarkWarning报错:是一个标签的mark警告，整个pytest这么写不识别你，但是不会报错，只是警告，</strong></p>
<p><strong>　　　　消除警告（增加标签栏，相当于标签的声明）</strong></p>
<p><strong>　　　　标签声明写法：teach_sq文件夹里创建一个pytest.ini的文件（pycham需要安装ini插件 file-setting-plugins(搜索ini)社区版似乎不行）</strong></p>
<p><strong>　　　　　　pycham找不到可以离线装</strong></p>
<pre><strong>            teach_sq
                pytest.ini-----文件内容如下，相当于pytest的mark标签声明一下</strong>

<strong>　　　　　　　　　　　　#文件内容，markers后面把标签全部写上，　　　　</strong><strong>lessson_moudle   一个类级别的mark标签名，
　　　　　　　　　　　　#</strong><strong>test_lesson_add，</strong><strong>test_lesson_list，</strong><strong>test_lesson_delete   三个函数级别的mark标签名称
　　　　　　　　　　　　#　　mark标签名称: 描述   这样的格式来写，前面声明标签名称，后面是描述（随便写）</strong>
<strong>
                    [pytest]　　　　　　　　　　　　　　　　　　　　
                    markers=
                        lessson_moudle: teach_lesson　　　　　　　　(标签名: 描述  这样的格式 　　前面lesson_modle和</strong><strong>test_lesson_add等</strong><strong>是mark的标签名称,
　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　声明一个标签　　　　:冒号后面一定要加空格，规范)</strong></pre>
<pre><strong>                                                            　　　　后面的描述不建议写中文，会报错（需要转码，但是这个文件python自己调用的）
                        test_lesson_add: teach_lesson
                        test_lesson_list: teach_lesson
                        test_lesson_delete: teach_lesson</strong></pre>
<p><strong>　　定制化执行test_lesson_add一个接口： "-m","test_lesson_add"</strong></p>
<p><strong>　　pytest.main(["test_lesson01.py","-s","-m","test_lesson_add"])   ----   -m就可以实现，mark定制化执行</strong></p>
<p><strong>　　定制化执行多个接口--逻辑或就行："-m","test_lesson_add or test_lesson_delete"</strong></p>
<p><strong>　　pytest.main(["test_lesson01.py","-s","-m","test_lesson_add or test_lesson_delete"])</strong></p>
<p><strong>　　排除法排除一个-定制化除了某个接口不运行其他都运行---"-m","not test_lesson_add"</strong></p>
<p><strong>　　pytest.main(["test_lesson01.py","-s","-m","not test_lesson_add"])----除了test_lesson_add这个接口其他都运行</strong></p>
<p><strong>　　排除法排除多个-"-m","not (test_lesson_add or test_lesson_delete)"</strong></p>
<p><strong>　　pytest.main(["test_lesson01.py","-s","-m","not (test_lesson_add or test_lesson_delete)"])</strong></p>
<p><strong>　　筛选测试用例代码：</strong></p>
<pre><code>import pytest

@pytest.mark.zzzzz
def test_001():
    print('test_001')

def test_002():
    print('test_001')

if __name__ == '__main__':
    pytest.main(["test1.py",'-s','-m','zzzzz'])</code></pre>
<p><strong>　　二：定制化执行：（组装流程）</strong></p>
<p><strong>　　　　</strong><strong>1：mark标签：组装流程方便</strong></p>
<p><strong>　　　　　　-k：匹配筛选用例名称（可标准（全名）可模糊匹配）---指的是模块，-k和-m类似，有or和not，</strong></p>
<p><strong>　　　　　　  　　但是-k只运行所有的用例，然后有排除模式，选定模式，还要其他模式（-k在cmd里面写的）</strong></p>
<p><strong>　　　　　　　　pytest -k test_lesson01.py ：执行test_lesson01.py模块的测试用例（sq可以不写，只是不加打印,sq错误执行的时候会有很多信息可以打印，）</strong></p>
<p><strong>　　　　　　　　全部选中,测试包里面的模块全部被选中：pytest -k test，（差不多功能的模块写同样单词命名，这样-k可以一起匹配上）</strong></p>
<p><strong>　　　　　　　　lesson_1.py 和lesson_2.py：想运行两个文件　　pytest -k lesson  (默认模糊匹配lesson)</strong></p>
<p><strong>　　　　　　-m: 选择对应的标签(标签，mark需要打标签才能定制化执行，其他两个k和v不用打标签)</strong></p>
<p><strong>      　　　　 -v:节点，你要运行里面的某一个某一个里面的东西：(节点指定某一个)</strong></p>
<p><strong>　　　　　　示例：pytest_lesson.py::Test_lesson::test_01</strong></p>
<p><strong>　　　　　　　　 pytest -v pytest_lesson.py::Test_lesson::test_01</strong></p>
<p><strong>　　　　　　</strong><strong>-sq:（简化print打印信息）   -s:输出print打印    -q简化输出   </strong></p>
<p><strong>　　　　　　sq，错误时候显示错误信息，或者fail很多失败信息，很多打印的时候写sq打印（成功不用写）</strong></p>
<p><strong>　　三：跳过/条件跳过：通过上下条件判断这个东西要不要跑，（两种）　</strong>　　<strong>　skip</strong></p>
<p><strong>　　　　</strong><strong>1：跳过（没有条件的跳过，指定跳过，不需要满足什么条件）　　　　skip</strong></p>
<p><strong>　　　　　　@pytest.mark.skip("跳过test_lesson_add")　　　　　　　　</strong><strong>无条件跳过</strong></p>
<p><strong>　　　　　　接口函数前面写@pytest.mark.skip("跳过test_lesson_add")，</strong></p>
<p><strong>　　　　　　这个接口就会被无条件跳过，不执行（报告里面会描述出来）</strong></p>
<p><strong>　　　　2：有条件的跳过　　　　　　　　　　　　　　　　　　　　　　　　skipif</strong></p>
<p><strong>　　　　　　@pytest.mark.skipif(1==1,reason="条件需要前面完成某一个步骤--前面条件为真的时候则跳过函数，不为真执行函数")　　　　有条件的跳过</strong></p>
<p><strong>　　　　　　流程化需要跳过接口，1，2，3，</strong></p>
<p><strong>　　　　　　1为真运行的时候才执行2，1不执行2也不执行，直接跳过）</strong></p>
<p><strong>　　　　　　条件从哪里来，预期和实际的做个判断（找个前置条件做个判断是不是为真）</strong></p>
<p><strong>　　　　　　如果登录失败那么课程接口就不要取跑了（可以这么写）登录失败没有sessionid</strong></p>
<p><strong>　　　　使用场景：前面一个动作失败了后面的不要跑了，</strong></p>
<p><strong>　　　　　　　　　　前置条件,或者检测到服务器python环境不是要求的，不要跑，</strong></p>
<p><strong>　　　　　　　　　　对版本有要求（系统环境，解释器版本都可以作为代码要不要执行的前置条件）</strong></p>
<p><strong>　　　　标签只能到接口（方法层），不能指定到用例，用例是通过数据驱动来做的</strong></p>
<p><strong>　　四：</strong><strong>定制执行还有一种写法：　　指名道姓----(下面的指令可以在cmd控制台命令里面直接执行)</strong></p>
<p><strong>　　　　只执行Test1的测试用例，执行命令：pytest -sq test_xt.py::Test1                                  py文件到类，类级别的（::级别关系）</strong></p>
<p><strong>　　　　只想执行Test2中test_3，执行命令：pytest -sq test_xt.py::Test2::test_3   py文件，类，接口方法</strong></p>
<p><strong>　　　　同时执行多个条件：执行命令：pytest -sq test_xt.py::Test1::test01   test_xt.py::Test2::test02</strong></p>
<p><strong>　　　　也可以根据用例名称进行筛选-k，执行命令：pytest -sq -k 2 test_xt.py</strong></p>
<p style="margin-left:0;text-align:left;"></p>
<p style="margin-left:0px;text-align:center;"><img alt="" src="image\08d19a042e7c4c05883dd31e023f169c.jpeg"/><span title="点击并拖拽以改变尺寸">​</span></p>
<p> </p>
<p style="margin-left:0;text-align:left;"></p>
<p style="margin-left:0;text-align:left;"></p>
<p style="margin-left:0;text-align:left;"> 文章到这里就结束了，各位铁汁如果有什么觉得不对的可以发在评论区咱们来讨论哈，</p>
<p style="margin-left:0;text-align:left;">听说关注我并三连的铁汁都已经升职加薪暴富了哦！！！！</p>
</div>
</div>