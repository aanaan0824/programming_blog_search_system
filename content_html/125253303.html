<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<p>**线程池的七大参数**：<br/> 1.corePoolSize:线程池中的常驻核心线程数<br/> 2.maxinumPoolSize:线程池中能够容纳同时执行的最大线程数，此值必须大于等于一<br/> 3.keepAliveTime:多余的空闲线程的存活时间。<br/> 当前线程池数量超过corePoolSize时，当空闲时间达到keepAliveTime时，多余空闲线程会被销毁直到只剩下corePoolSize个线程为止。<br/> 4.unit:keepAliveTime的单位<br/> 5.workQueue:任务队列，被提交但是尚未被执行的任务。<br/> 6.threadFactory:表示生成线程池中工作线程的线程工厂，用于创建线程一般用默认的即可。<br/> 7.handler:拒绝策略，表示当队列满了并且工作线程-大于等于线程池的数量最大线程数（maxinumPoolSize）时如何来拒绝请求执行的runnable的策略。</p>
<p>示例：</p>
<p>线程池=银行网点</p>
<p>物理上的受理窗口，办理业务窗口</p>
<p>threadFactory默认-&gt;银行网点的logo/工作人员的制服和胸卡</p>
<p>1.当只有两个请求线程时，直接来到线程池中的核心线程中</p>
<p><img alt="" height="645" src="image\250ba035219c4df1a1a7e1e630d4a7ec.png" width="1200"/></p>
<p>2.当线程池核心线程被占用时，又来了三个请求，进入阻塞队列排队等待</p>
<p><img alt="" height="628" src="image\c076fbc8246940b48353cd231ed2573c.png" width="1200"/></p>
<p>3.再一次增加两个请求，启用临时线程，将阻塞队列中的请求，放置到临时线程中，新的请求加入到阻塞队列 </p>
<p><img alt="" height="615" src="image\2e42335c43ea48a08388efdae7ff1a37.png" width="1200"/></p>
<p>4.当又有多的请求进入时，阻塞队列已满，启用拒绝策略</p>
<p>5.在keepAliveTime的时间内，没有多余的线程请求了，就会销毁三个临时线程</p>
<p></p>
<p></p>
<p></p>
</div>
</div>