<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<h1><a id="_0"></a>学习目标：</h1>
<p> 如果你和我同样苦恼于游戏相关的数据怎么存储与读取，那么不妨看看这个up主有关Unity存档系统的教程。<a class="has-card" href="https://www.bilibili.com/video/BV1nQ4y1z7pZ/?spm_id_from=333.788.recommend_more_video.-1" title="[Unity] 存档系统 Part 1 | PlayerPrefs | Unity初学者系列教程 | 数据存取 | 存档读档 | Save&amp;Load_哔哩哔哩_bilibili"><span class="link-card-box"><span class="link-title">[Unity] 存档系统 Part 1 | PlayerPrefs | Unity初学者系列教程 | 数据存取 | 存档读档 | Save&amp;Load_哔哩哔哩_bilibili</span><span class="link-desc">在本视频中你将学到Unity引擎中三种常见的数据存储方式中的第一种：PlayerPrefs主要内容：什么是PlayerPrefs如何使用PlayerPrefsPlayerPrefs的优缺点以及适用范围构建一个基于PlayerPrefs的基础数据存取系统Unity存档系统第二部分 - JSON：BV1Cb4y1b71G————————————————————你好啊，我是阿严，一个小小的独立游戏开发者</span><span class="link-link"><img alt="" class="link-link-icon" src="image\fbb96f582b302308545eb56449afabe3ee5598d7.jpg@57w_57h_1c.png"/>https://www.bilibili.com/video/BV1nQ4y1z7pZ/?spm_id_from=333.788.recommend_more_video.-1</span></span></a></p>
<p>这里我将up主讲到的内容作为笔记，先给大伙开个头介绍JSON。</p>
<hr/>
<h1><a id="_10"></a>学习内容：</h1>
<h3><font face="monospace">  这里引用以为CSDN博主给JSON的介绍（</font><a class="has-card" href="https://blog.csdn.net/qq_41684621/article/details/113851644?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165301480816781483799120%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=165301480816781483799120&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-113851644-null-null.142%5Ev10%5Econtrol,157%5Ev4%5Econtrol&amp;utm_term=JSON&amp;spm=1018.2226.3001.4187" title="JSON 基本使用_兮动人的博客-CSDN博客_json.cn怎么用"><span class="link-card-box"><span class="link-title">JSON 基本使用_兮动人的博客-CSDN博客_json.cn怎么用</span><span class="link-link"><img alt="icon-default.png?t=M4AD" class="link-link-icon" src="https://csdnimg.cn/release/blog_editor_html/release2.1.3/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=M4AD"/>https://blog.csdn.net/qq_41684621/article/details/113851644?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165301480816781483799120%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=165301480816781483799120&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-113851644-null-null.142^v10^control,157^v4^control&amp;utm_term=JSON&amp;spm=1018.2226.3001.4187</span></span></a><font face="monospace">）</font></h3>
<p><span style="color:#fe2c24;"><strong>JSON，全称是 JavaScript Object Notation，即 JavaScript对象标记法。</strong></span></p>
<p><br/><span style="color:#fe2c24;"><strong>JSON是一种轻量级（Light-Meight)、基于文本的(Text-Based)、可读的(Human-Readable)格式。</strong></span></p>
<p><br/><span style="color:#fe2c24;"><strong>JSON 的名称中虽然带有JavaScript，但这是指其语法规则是参考JavaScript对象的，而不是指只能用于JavaScript 语言。</strong></span></p>
<p><br/><span style="color:#fe2c24;"><strong>JSON无论对于人，还是对于机器来说，都是十分便于阅读和书写的，而且相比 XML(另一种常见的数据交换格式)，文件更小，因此迅速成为网络上十分流行的交换格式。</strong></span></p>
<p><br/><span style="color:#fe2c24;"><strong>近年来JavaScript已经成为浏览器上事实上的标准语言，JavaScript 的风靡，与JSON 的流行也有密切的关系。</strong></span></p>
<p><br/><span style="color:#fe2c24;"><strong>因为JSON本身就是参考JavaScript 对象的规则定义的，其语法与JavaScript定义对象的语法几乎完全相同。</strong></span></p>
<p><br/><span style="color:#fe2c24;"><strong>JSON格式的创始人声称此格式永远不升级，这就表示这种格式具有长时间的稳定性，10 年前写的文件，10年后也能用,没有任何兼容性问题。</strong></span></p>
<p><br/><span style="color:#fe2c24;"><strong>原文链接：https://blog.csdn.net/qq_41684621/article/details/113851644</strong></span></p>
<p></p>
<p><span style="color:#fe2c24;"><strong>了解完什么是JSON后让我们看看官方API中关于JSON的属性</strong></span></p>
<p>转化为JSON格式，我们需要一个object类型，一个bool是为了将文本转为可读性更高的JavaScript格式 </p>
<p><img alt="" height="457" src="image\a8ab97527ef840e0bb4bc809ee5e76b1.png" width="968"/></p>
<p><img alt="" height="594" src="image\abb7703499164b0eb3f18d5cbe6dc7ab.png" width="1200"/></p>
<p><img alt="" height="775" src="image\6a540bc6a4e34f7b8fd0bf79525c6808.png" width="1200"/></p>
<p> </p>
<p>这个复写函数可以覆盖掉我们之前创建的object类型，用一个新的string类型的json来覆盖掉原有的数据 </p>
<p> <img alt="" height="764" src="image\11b1df5c6753400dba8284aac85e08d5.png" width="1200"/></p>
<p> </p>
<p>需要注意的是，转化的时候不应该用字段，这与json本身的特性有关，当你转化的时候会发现只有一个大括号，而是要将整个类一起转化，而且接受转化的数据类型必须是支持Untiy序列化，像什么static静态，readonly字段，是不能进行转化，up主非常贴心的制作了一张表格用来列出那些数据类型支持转化大伙务必要去看看。</p>
<p><img alt="" height="516" src="image\533e6e3bae4b4e40bdabca96fe42aa9d.png" width="937"/></p>
<p><img alt="" height="814" src="image\ec9dc115516f49d3a96821fd920af931.png" width="931"/> </p>
<p><img alt="" height="343" src="image\d1ce86c01a654d76a5782de0948d31fa.png" width="926"/> </p>
<p>了解上述属性和特征之类的以后，我们就可以使用JSON来存储不同类型的数据了。 </p>
<p></p>
<p></p>
<h1><a id="_22"></a>代码部分：</h1>
<p>  回到Unity中我们重新写SaveSystem脚本，这里涉及到的有try,catch捕获异常语句块，Path.Combine()将两个路径目录合并起来</p>
<p>Application.persistentDataPath因为发布到不同平台上的目录各有不同，使用这个属性能让我们保存的数据适应不同平台上。</p>
<pre><code class="language-cs">using UnityEngine;
using System.IO;
namespace SaveSystemTur
{
    public static  class SaveSystem
    {

        #region JSON

        public static void SaveByJSON(string saveFileName, object data)
        {
            var json = JsonUtility.ToJson(data);
            var path = Path.Combine(Application.persistentDataPath + saveFileName);

           
            try
            {
                File.WriteAllText(path, json);

#if UNITY_EDITOR
                Debug.Log($"Successfully save file to {path} . ");
#endif
            }
            catch (System.Exception exception)
            {

#if UNITY_EDITOR
                Debug.LogError($"Failed to save file to {path}\n {exception}");
#endif
            }
        }

        public static T LoadFromJSON&lt;T&gt;(string saveFileName)
        {
            var path = Path.Combine(Application.persistentDataPath, saveFileName);

            try 
            {
                var json = File.ReadAllText(path);
                var data = JsonUtility.FromJson&lt;T&gt;(json);

                return data;
            }
            catch(System.Exception exception)
            {
#if UNITY_EDITOR
                Debug.LogError($"Failed to load file to {path}\n {exception}");
#endif
                return default;
            }
         }
        #endregion

        #region DELETE

        public static void DeleteFile(string saveFileName)
        {
            var path = Path.Combine(Application.persistentDataPath, saveFileName);

            try
            {
                File.Delete(path);
            }
            catch (System.Exception exception)
            {
#if UNITY_EDITOR
                Debug.LogError($"Failed to delete file to {path}\n {exception}");
#endif

            }
        }


        #endregion
    }
}
</code></pre>
<p>完成后我们回到NewPlayerData上，比之前更省略的是我们除了SaveData和LoadData之外，我们只用了两个两三行函数从SaveSystem上调用函数即实现了保存Json格式文件。</p>
<pre><code class="language-cs">using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace SaveSystemTur
{
    public class NewPlayerData : MonoBehaviour
    {
        private const string PLAYER_DATA_KEY = "PlayerData";
        private const string PLAYER_DATA_FILE_NAME = "PlayerData.sav";
        #region Fields
        [SerializeField] string playerName = "";
        [SerializeField] int coin = 0;
        [SerializeField] int level = 0;

        [System.Serializable]
        class SaveData
        {
            public string playerName;
            public int playerLevel;
            public int playerCoin;
            public Vector3 playerPosition;
        }

        #endregion

        #region Propertries

        public string PlayerName =&gt; playerName;
        public int Coin =&gt; coin;
        public int Level =&gt; level;

        public Vector3 Position =&gt; transform.position;
        #endregion

        #region Save And Load
        public void Save()
        {
            SaveByJSON();
        }
        public void Load()
        {
            LoadFromJSON();
        }
        

        private SaveData SavingData()
        {
            var saveData = new SaveData();
            saveData.playerName = playerName;
            saveData.playerCoin = coin;
            saveData.playerLevel = level;
            saveData.playerPosition = transform.position;

            return saveData;
        }


        private void LoadData(SaveData saveData)
        {
            playerName = saveData.playerName;
            level = saveData.playerLevel;
            coin = saveData.playerCoin;
            transform.position = saveData.playerPosition;
        }

        [UnityEditor.MenuItem("Developer/Delete Player Data Prefs")]
        public static void DeletePlayerDataPrefs()
        {
            //PlayerPrefs.DeleteAll();
            PlayerPrefs.DeleteKey(PLAYER_DATA_KEY);
        }

        [UnityEditor.MenuItem("Developer/Delete Player Data Save File")]
        public static void DeletePlayerDataSaveFile()
        {
            //PlayerPrefs.DeleteAll();
            PlayerPrefs.DeleteKey(PLAYER_DATA_FILE_NAME);
        }

        #endregion

        #region JSON

        void SaveByJSON()
        {
            SaveSystem.SaveByJSON(PLAYER_DATA_FILE_NAME, SavingData());
        }

        void LoadFromJSON()
        {
            var saveData = SaveSystem.LoadFromJSON&lt;SaveData&gt;(PLAYER_DATA_FILE_NAME);

            LoadData(saveData);
        }
        #endregion

    }
}</code></pre>
<p> 其实可以在SaveByJSON为我们创建的文件的名字上给上保存日期</p>
<pre><code>void SaveByJSON()
        {
            SaveSystem.SaveByJSON($"{System.DateTime.Now:yyyy.dd.M HH-MM-ss}.sav", SavingData());
            //SaveSystem.SaveByJSON(PLAYER_DATA_FILE_NAME, SavingData());
        }</code></pre>
<p><img alt="" height="798" src="image\68c9f5eb6fb445e48ac7c68ca5ab1427.png" width="1060"/></p>
<p>这样我们的文件就陈宫保存在C盘了，而且也有我们按下保存的日期。</p>
</div>
</div>