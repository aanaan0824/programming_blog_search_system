<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="markdown_views prism-atom-one-dark" id="content_views">
<svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
<path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
</svg>
<h1><a id="_0"></a>写在前面</h1>
<blockquote>
<p>前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家:<a href="https://www.cbedai.net/wanglove"><font color="red" size="4"><u><strong>人工智能学习网站</strong></u></font></a></p>
</blockquote>
<p></p>
<div class="toc">
<h3>目录</h3>
<ul><li><a href="#_0">写在前面</a></li><li><a href="#_9">💖前言</a></li><li><a href="#Java_15">🎄Java基础知识</a></li><li><ul><li><a href="#_16">💟基础知识导图</a></li><li><a href="#IO_21">🎄IO流</a></li><li><a href="#Lambda_33">🎈Lambda</a></li><li><a href="#_36">🎃&amp;和&amp;&amp;的区别？</a></li><li><a href="#java_40">🎋在java中如何跳出当前的多重循环？</a></li><li><a href="#_51">🎨面向对象的三大特征</a></li><li><a href="#equals_88">🎍"=="和equals方法究竟有什么区别？</a></li><li><a href="#_92">🎎三个与取整有关的方法</a></li><li><a href="#Java_103">🎏Java中运算符</a></li><li><a href="#_124">✨重载和重写的区别？</a></li><li><a href="#StringStringBuffuerStringBuilder_128">🎢String和StringBuffuer、StringBuilder的区别？</a></li><li><a href="#javastopsuspend_138">🎨java中有几种方法实现一个线程？用什么关键字修饰同步方法？stop()和suspend()方法为何不推荐使用？</a></li><li><a href="#sleepwait_153">🎗sleep()和wait()有什么区别？</a></li><li><a href="#forif_elseswitchwhilebreakcontinue_162">🎃基本语句(for、if else、switch、while、break和continue)</a></li><li><a href="#_259">🎉关键字</a></li><li><a href="#publicprivateprotected__358">🥫作用域public、private、protected 以及不写时的区别？</a></li><li><a href="#forwardredirect_371">🥚forward和redirect两种跳转方式的区别？</a></li><li><a href="#HashMapHashtable_386">🍧HashMap和Hashtable的区别？</a></li><li><a href="#ListSetMap_390">🍨List、Set和Map的区别？</a></li><li><a href="#hashCodeequals_395">🍷hashCode与equals的区别与联系？</a></li><li><a href="#_413">🧉模式</a></li><li><a href="#Java_447">🥯Java常用类</a></li></ul>
</li><li><a href="#Java_552">🎄Java集合框架</a></li><li><ul><li><a href="#_555">🚀常用的三种集合接口：</a></li><li><a href="#List_559">🎉List(有序，可以重复的集合)</a></li><li><a href="#Set_HashSet_607">🎋Set(典型实现 HashSet()是一个无序，不可重复的集合)</a></li><li><a href="#Mapkeyvalue_key_value_636">🎡Map(key-value 的键值对，key 不允许重复，value可以)</a></li><li><ul><li><a href="#Map_685">🎄Map常用方法及实现类</a></li></ul>
</li><li><a href="#MapSet_717">🧨Map与Set关系</a></li></ul>
</li><li><a href="#Java_723">🎄Java多线程</a></li><li><ul><li><a href="#_724">🎗创建线程和启动</a></li><li><a href="#_786">🎀线程生命周期</a></li><li><a href="#_810">🎭线程管理</a></li><li><ul><li><a href="#sleep_811">🎗线程睡眠——sleep</a></li><li><a href="#yield_835">🎗线程让步——yield</a></li><li><a href="#_871">🎗设置线程的优先级</a></li><li><a href="#_905">🎗后台（守护）线程</a></li><li><a href="#_925">🎗正确结束线程</a></li></ul>
</li><li><a href="#_946">🎁线程同步</a></li><li><ul><li><a href="#_949">🎗同步方法</a></li><li><a href="#_959">🎗同步代码块</a></li><li><a href="#volatile_998">🎗使用特殊域变量(volatile)实现线程同步</a></li><li><a href="#Lock_1076">🎗使用重入锁（Lock）实现线程同步</a></li></ul>
</li><li><a href="#_1113">🧶线程通信</a></li><li><ul><li><a href="#ObjectwaitnotifynotifyAll_1114">🎗借助于Object类的wait()、notify()和notifyAll()实现通信</a></li><li><a href="#Condition_1220">🎗使用Condition控制线程通信</a></li></ul>
</li><li><a href="#_1265">👕线程池</a></li><li><ul><li><a href="#newSingleThreadExecutor_1277">🎗newSingleThreadExecutor()</a></li><li><a href="#newCachedThreadPool_1307">🎗newCachedThreadPool的使用</a></li><li><a href="#newFixedThreadPool_1335">🎗newFixedThreadPool的使用</a></li></ul>
</li><li><a href="#_1364">🧵线程五种状态</a></li></ul>
</li><li><a href="#Java_1382">🎄Java虚拟机</a></li><li><a href="#MySQL_1390">🎄MySQL</a></li><li><a href="#Spring_1396">🎄Spring相关知识点</a></li><li><ul><li><a href="#Bean_1397">🎨Bean生命周期</a></li><li><a href="#Spring_1412">🎪Spring应用</a></li><li><ul><li><a href="#_1413">🎗常用注解</a></li></ul>
</li><li><a href="#Spring_1433">🎠Spring优点</a></li><li><a href="#SpringIOC_1439">🎀Spring中IOC理解</a></li><li><a href="#SpringAOP_1444">🎇Spring中AOP理解</a></li><li><a href="#Spring_1462">🎭Spring配置方式</a></li><li><a href="#Spring_1467">🎢Spring中的设计模式</a></li><li><a href="#SpringMVC_1474">🧨SpringMVC执行流程</a></li></ul>
</li><li><a href="#_1488">🎄计算机网络</a></li><li><ul><li><a href="#OSITCPIP_1494">🎍OSI，TCP/IP，五层协议的体系结构，以及各层协议</a></li><li><a href="#IP_1516">🥽IP地址的分类</a></li><li><a href="#_1522">🥼各种协议</a></li><li><a href="#TCP_1531">👓TCP三次握手和四次挥手的全过程</a></li></ul>
</li><li><a href="#MQ_1547">🎄MQ消息队列</a></li><li><ul><li><a href="#MQ_1550">🧵MQ应用(异步解耦削峰)</a></li><li><ul><li><a href="#_1551">🎗异步提速</a></li><li><a href="#_1553">🎗解耦</a></li><li><a href="#_1556">🎗削峰填谷</a></li></ul>
</li><li><a href="#MQ_1560">🎊MQ选型</a></li><li><a href="#MQ_1562">🎁MQ消息队列相关资料分享</a></li></ul>
</li><li><a href="#Redis_1565">🎄Redis</a></li><li><ul><li><a href="#_1566">👟缓存击穿、缓存穿透、缓存雪崩</a></li><li><a href="#Redis_1569">🏀使用Redis做缓存的优点</a></li><li><a href="#redis__1582">⛳redis 常见数据结构以及使用场景分析</a></li><li><a href="#Redis_1619">🥅Redis主从复制与哨兵机制</a></li></ul>
</li><li><a href="#Nginx_1622">🎄Nginx</a></li><li><ul><li><a href="#Nginx_1623">🎁Nginx基本配置详解</a></li><li><a href="#Nginx_1747">🪁Nginx常用命令</a></li><li><a href="#Nginx_1784">🎨Nginx正向代理</a></li><li><a href="#Nginx_1822">🥏Nginx反向代理</a></li><li><a href="#Nginx_1863">🔮Nginx负载均衡</a></li></ul>
</li></ul>
</div>
<p></p>
<hr color="#000000" size='1"'/>
<h1><a id="_9"></a>💖前言</h1>
<p><font color="#999AAA">国内的互联网面试，恐怕是现存的、最接近科举考试的制度。而且，我国的八股文（<strong>基础知识、集合框架、多线程、线程的五种状态、虚拟机、MySQL、Spring相关、计算机网络、MQ系列等</strong>）确实是独树一帜。以美国为例，北美工程师面试比较重视算法（Coding），近几年也会加入Design轮（系统设计和面向对象设计OOD）和BQ轮（Behavioral question，行为面试问题）,今天博主为大家熬断半头青丝捋一捋这现代八股文</font></p>
<hr color="#000000" size='1"'/>
<h1><a id="Java_15"></a>🎄Java基础知识</h1>
<h2><a id="_16"></a>💟基础知识导图</h2>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/0d55d1bc7d194943a49ca9ed7a02973e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA55m95aSn6ZSF,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<p>需要完整图的小伙伴可联系博主</p>
<h2><a id="IO_21"></a>🎄IO流</h2>
<p>详情见博主此文:<a href="https://blog.csdn.net/weixin_45735355/article/details/118801875?spm=1001.2014.3001.5501">IO流知识体系详解</a></p>
<blockquote>
<p>按照流的方向：输入流（inputStream）和输出流（outputStream）.<br/> 按照实现功能分：节点流（可以从或向一个特定的地方（节点）读写数据。如 FileReader）和处理流（是对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读写。如 BufferedReader。处理流的构造方法总是要带一个其他的流对象做参数。一个流对象经过其他流的多次包装，称为流的链接）<br/> 按照处理数据的单位： 字节流和字符流。字节流继承于 InputStream 和 OutputStream，字符流继承于InputStreamReader 和 OutputStreamWriter。</p>
</blockquote>
<p><strong>字节流如何转为字符流</strong><br/> 字节输入流转字符输入流通过 InputStreamReader 实现，该类的构造函数可以传入 InputStream 对象。<br/> 字节输出流转字符输出流通过 OutputStreamWriter 实现，该类的构造函数可以传入 OutputStream 对象<br/> <strong>如何将一个 java 对象序列化到文件里</strong><br/> 在 java 中能够被序列化的类必须先实现 Serializable 接口，该接口没有任何抽象方法只是起到一个标记作用</p>
<h2><a id="Lambda_33"></a>🎈Lambda</h2>
<p>详情见博主此文:<a href="https://blog.csdn.net/weixin_45735355/article/details/119911204?spm=1001.2014.3001.5501">Lambda表达式详细讲解</a></p>
<h2><a id="_36"></a>🎃&amp;和&amp;&amp;的区别？</h2>
<blockquote>
<p><code>&amp;</code>：逻辑与（<code>and</code>）,运算符两边的表达式均为<code>true</code>时，整个结果才为<code>true</code><br/> <code>&amp;&amp;</code>：短路与，如果第一个表达式为<code>false</code>时，第二个表达式就不会计算了</p>
</blockquote>
<h2><a id="java_40"></a>🎋在java中如何跳出当前的多重循环？</h2>
<p>在循环语句外前面定义一个标号，然后在里层循环体的代码中使用带有标号的break语句，即可跳出循环。<br/> 比如：</p>
<pre><code class="prism language-java">ok<span class="token operator">:</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">break</span> ok<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h2><a id="_51"></a>🎨面向对象的三大特征</h2>
<p>1.封装</p>
<blockquote>
<p>作用：提高代码的安全性<br/> 1、将属性私有化，并提供对外界的接口（<code>get/set</code>方法）。<br/> 2、用<code>private</code>修饰的属性和方法，<strong>只能在本类中使用</strong>。</p>
</blockquote>
<p>2.继承</p>
<blockquote>
<p>作用：<strong>提高代码的复用性，减少重复代码</strong><br/> 1、子类可以继承父类非私有的属性和方法，不能继承构造方法和私有的属性和方法。<br/> 2、可以综合子类的共同特征来去提炼父亲的类。<br/> 3、子类在继承父类的各种属性和方法时，也可以有自己的属性和方法。<br/> 4、一个子类只能有一个父类，java只能单继承，不能多继承，因为多个类中的方法名相同，方法体不同，不知使用哪个。<br/> 5、一个类继承最顶端叫做基类或者超类，所有的超类叫做<code>object</code> 。<br/> 6、在继承关系中，如果父类没有无参数的构造方法，如何解决？<br/> 1.子类中添加一个和父类构造方法参数列表相同的构造方法，通过super参数传递给父类的构造方法<br/> 2.如果父类允许修改的时候，可以在父类中创建一个无参的构造方法<br/> 7、在继承关系中，代码块的执行顺序：<strong>父静&gt;子静&gt;父构造代码块&gt;父构造方法&gt;子构造代码块&gt;子构造方法</strong></p>
</blockquote>
<p>3.多态</p>
<blockquote>
<p>1.分类<br/> 编译时多态：在编译过程中察觉的多态，重载，向上转型。<br/> 运行时多态：在运行过程中察觉的多态，向下转型。<br/> 2.向上转型、向下转型是在继承关系中，向下转型必须在向上转型的基之上。<br/> 3.在继承关系中，父类的对象可以指向子类的实例，父类引用实体方法的时候，是调用子类重写以后的方法。<br/> 4.向上转型<br/> 父类的引用指向子类的实体<br/> 父类类名 <code>对象名=new 子类类();</code><br/> 优点：减少重复代码，提高代码的复用性<br/> 缺点:父类的引用无法调用子类特有的属性和方法<br/> 解决方案：向下转型<br/> 5.向下转型：<br/> 子类对象的父类引用赋给子类<br/> 子类类名 <code>对象名=（子类类名）父类对象;</code><br/> 6. instanceof 判断左边的对象是否属于右边的类 对象名 <code>instanceof</code> 类名（子类类名）<br/> 7.匿名对象<br/> <code>new</code> 类名()<strong>只有堆空间，没有栈空间</strong>，只能属于一次，为了节省代码。</p>
</blockquote>
<h2><a id="equals_88"></a>🎍"=="和equals方法究竟有什么区别？</h2>
<blockquote>
<p>==：表示两个变量的值是否相等，比较两个基本数据类型的数据或者引用变量，用 ==<br/> equals:用于比较两个独立对象的内容是否相同,字符串的比较也用equals</p>
</blockquote>
<h2><a id="_92"></a>🎎三个与取整有关的方法</h2>
<pre><code class="prism language-java"><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">ceil</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span>表示向上取整；<span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">ceil</span><span class="token punctuation">(</span><span class="token number">11.3</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">12</span><span class="token punctuation">;</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">ceil</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">11.3</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">-</span><span class="token number">12</span>。

<span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span>表示向下取整；<span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token number">11.6</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">11</span><span class="token punctuation">;</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">11.6</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">-</span><span class="token number">12</span>。

<span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">round</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span>表示四舍五入；<span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">round</span><span class="token punctuation">(</span><span class="token number">11.5</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">12</span><span class="token punctuation">;</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">round</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">11.5</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">-</span><span class="token number">11</span><span class="token punctuation">;</span>

<span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">round</span><span class="token punctuation">(</span><span class="token number">11.3</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">11</span><span class="token punctuation">;</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">round</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">11.3</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">-</span><span class="token number">11</span><span class="token punctuation">;</span>
</code></pre>
<h2><a id="Java_103"></a>🎏Java中运算符</h2>
<pre><code class="prism language-java">算术运算符：<span class="token operator">+</span> 、 <span class="token operator">-</span> 、 <span class="token operator">*</span> 、 <span class="token operator">/</span> 、 <span class="token operator">%</span> 、 <span class="token operator">++</span> 、 <span class="token operator">--</span>
赋值运算符：<span class="token operator">=</span> 、 <span class="token operator">+=</span> 、 <span class="token operator">-=</span> 、 <span class="token operator">*=</span> 、 <span class="token operator">/=</span> 、 <span class="token operator">%=</span>
关系运算符：<span class="token operator">&gt;</span> 、 <span class="token operator">&lt;</span> 、 <span class="token operator">&gt;=</span> 、 <span class="token operator">&lt;=</span> 、 <span class="token operator">==</span> 、 <span class="token operator">!=</span>
逻辑运算符：<span class="token operator">!</span> 、 <span class="token operator">&amp;</span> （只要有一个<span class="token boolean">false</span>  最终结果就是<span class="token boolean">false</span>） 、

         <span class="token operator">|</span> （但凡有一个<span class="token boolean">true</span>   最终结果就是<span class="token boolean">true</span>） 、

         <span class="token operator">^</span> （如果两边一样     最终结果为<span class="token boolean">false</span>   如果两边不同   最终结果为<span class="token boolean">true</span>）、

         <span class="token operator">&amp;&amp;</span>（如果第一个是<span class="token boolean">false</span> 那第二个不执行  最终结果是<span class="token boolean">false</span>）、

         <span class="token operator">||</span>（如果第一个表达式的结果是<span class="token boolean">true</span> 那第二个表达式 就不去计算了 <span class="token punctuation">,</span>最终结果是<span class="token boolean">true</span>）
位运算符： <span class="token operator">~</span> 、 <span class="token operator">&gt;&gt;</span> 、 <span class="token operator">&lt;&lt;</span> 、 <span class="token operator">&gt;&gt;&gt;</span>
字符串连接运算符：<span class="token operator">+</span>
三目运算符：<span class="token class-name">X</span> <span class="token operator">?</span> <span class="token class-name">Y</span> <span class="token operator">:</span> <span class="token class-name">Z</span>
            <span class="token class-name">X</span>为<span class="token keyword">boolean</span>类型表达式，先计算x的值，若为<span class="token boolean">true</span>，整个三目运算的结果为表达式<span class="token class-name">Y</span>的值，否则整个运算结果为表达式<span class="token class-name">Z</span>的值。
</code></pre>
<h2><a id="_124"></a>✨重载和重写的区别？</h2>
<blockquote>
<p>重载（<code>Overload</code>）：函数名相同，参数不同。可以改变返回值类型，参数的个数和类型。<br/> 重写（<code>Override</code>）：和父类的的方法名称、参数完全相同</p>
</blockquote>
<h2><a id="StringStringBuffuerStringBuilder_128"></a>🎢String和StringBuffuer、StringBuilder的区别？</h2>
<blockquote>
<p><code>String</code>:字符串数值不可变；<br/> <code>StringBuffer</code>：字符串可修改，可以动态构造字符数据。<code>StringBuffer</code>类是可以通过<code>Append()</code>来修改值。线程安全。<br/> <code>StringBuilder</code>：线程不安全。<br/> 三者在执行速度方面的比较：<strong><code>StringBuilder &gt; StringBuffer &gt; String</code></strong><br/> 对于三者使用的总结：<br/> 1.如果要操作<strong>少量的数据</strong>用 = <code>String</code>　　<br/> 2.<strong>单线程操作字符串缓冲区下操作大量数据</strong> = <code>StringBuilder</code><br/> 3.<strong>多线程操作字符串缓冲区下操作大量数据</strong> = <code>StringBuffer</code></p>
</blockquote>
<h2><a id="javastopsuspend_138"></a>🎨java中有几种方法实现一个线程？用什么关键字修饰同步方法？stop()和suspend()方法为何不推荐使用？</h2>
<blockquote>
<p>第一种：<strong>继承Thread类</strong>。New Thread(){}.start():表示调用子类对象的run方法<br/> 第二种：<strong>实现Runable接口</strong><br/> 第三种：<strong>线程池创建多线程</strong><br/> 第四种：<strong>实现Callable接口，重写call函数</strong><br/> 继承Thread类实现多线程，重写run方法时<strong>没有返回值也不能抛出异常</strong>，使<strong>用Callable接口</strong>就可以<strong>解决</strong>这个问题</p>
</blockquote>
<blockquote>
<p><strong>Callable接口和Runnable接口的不同之处：</strong><br/> 1.<code>Callable</code>规定的方法是call，而<code>Runnable</code>是<code>run</code><br/> 2.<code>call</code>方法可以抛出异常，但是<code>run</code>方法不行<br/> 3.<code>Callable</code>对象执行后可以有返回值，运行<code>Callable</code>任务可以得到一个<code>Future</code>对象，通过<code>Future</code>对象可以了解任务执行情况，可以取消任务的执行，而<code>Runnable</code>不可有返回值<br/> 用<code>synchronized</code> 关键字修饰同步方法。<br/> 反对使用<code>stop()</code>，是因为它不安全。<br/> <code>suspend()</code> <strong>方法容易发生死锁</strong>。调用 <code>suspend()</code> 的时候，目标线程会停下来，但却仍然持有在这之前获得的锁定。此时，其他任何线程都不能访问锁定的资源，除非被" 挂起"的线程恢复运行。对任何线程来说，如果它们想恢复目标线程，同时又试图使用任何一个锁定的资源，就会造成死锁。所以不应该使用 <code>suspend()</code> ，而应在自己的 <code>Thread</code> 类中置入一个标志，指出线程应该活动还是挂起。若标志指出线程应该挂起，便用 <code>wait()</code> 命其进入等待状态。若标志指出线程应当恢复，则用一个 <code>notify()</code><strong>重新启动线程</strong>。</p>
</blockquote>
<h2><a id="sleepwait_153"></a>🎗sleep()和wait()有什么区别？</h2>
<blockquote>
<p><code>sleep</code>是线程被调用时，占着<code>cpu</code>休眠，其他线程不能占用<code>cpu</code>，<code>os</code>认为该线程正在工作，不会让出系统资源，<code>wait</code>是进入等待池等待，让出系统资源，其他线程可以占用<code>cpu</code></p>
</blockquote>
<blockquote>
<p><code>sleep()</code>和<code>wait()</code>方法的区别可从两个角度阐述：<br/> 1.<strong>cpu的抢占权</strong>；2.<strong>锁旗标是否释放</strong><br/> 两者都会释放cpu的抢占权；<br/> <code>wait()</code>方法执行完即可释放锁旗标，进入线程的等待队列；<br/> <code>sleep()</code>执行完，不会释放，进入等待队列；</p>
</blockquote>
<h2><a id="forif_elseswitchwhilebreakcontinue_162"></a>🎃基本语句(for、if else、switch、while、break和continue)</h2>
<p>1.for循环语句</p>
<pre><code class="prism language-java"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">[</span>循环变量初始值设定<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">[</span>循环条件判断<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">[</span>改变循环变量的值<span class="token punctuation">]</span><span class="token punctuation">)</span>｛
     循环体
｝
注意：<span class="token number">1</span>、表达式<span class="token number">2</span>一般不可以省略，否则死循环
      <span class="token number">2</span>、表达式<span class="token number">3</span>可以省略，但是在循环体中必须有语句修改变量，以使表达式<span class="token number">2</span>在某一时刻为<span class="token boolean">false</span>结束循环。
      <span class="token number">3</span>、若同时省略表达式<span class="token number">1</span>，表表达式<span class="token number">3</span>，则相当于<span class="token keyword">while</span>（表达式<span class="token number">2</span>）语句
      <span class="token number">4</span>、三个表达式均省略 即<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span>语句，此时相当于<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>语句
      <span class="token number">5</span>、表达式<span class="token number">1</span>、表达式<span class="token number">3</span>可以是逗号表达式<span class="token punctuation">,</span>以使循环变量值在修改时可以对其它变量赋值
</code></pre>
<p>2.if…else… 判断语句</p>
<pre><code class="prism language-java"><span class="token number">1</span>、<span class="token keyword">if</span>（）<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

<span class="token number">2</span>、<span class="token keyword">if</span>（）<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

<span class="token number">3</span>、<span class="token keyword">if</span>（）<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

<span class="token number">4</span>、<span class="token keyword">if</span>（）<span class="token punctuation">{<!-- --></span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span>    

<span class="token number">5</span>、<span class="token keyword">if</span>（）执行语句 esle   执行语句 注意：执行语句只有一条语句的时候<span class="token punctuation">.</span>可以将<span class="token keyword">if</span> esle 的大括号省略

注意：<span class="token punctuation">(</span><span class="token punctuation">)</span>内是<span class="token keyword">boolean</span>类型表达式，<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>是语句块
    比较字符串用equals，比较内容。比较数值用<span class="token operator">==</span>，比较地址。
    基本数据类型：变量名、变量值在栈中。
    引用数据类型：变量名在栈中，变量值在常量池中。
</code></pre>
<p>3.while 循环语句</p>
<pre><code class="prism language-java"><span class="token keyword">while</span><span class="token punctuation">(</span> 条件表达式语句<span class="token punctuation">)</span>｛

     循环体语句<span class="token punctuation">;</span>

     <span class="token punctuation">}</span>

  <span class="token comment">//初始条件</span>


  <span class="token keyword">do</span>｛

    <span class="token comment">//循环体;</span>
	<span class="token comment">//迭代</span>
｝<span class="token keyword">while</span><span class="token punctuation">(</span> 循环条件判断<span class="token punctuation">)</span><span class="token punctuation">;</span> 
  注意：<span class="token number">1</span>、当第一次执行时，若表达式<span class="token operator">=</span><span class="token boolean">false</span>时，则<span class="token keyword">while</span>语句不执行，而<span class="token keyword">do</span><span class="token operator">/</span><span class="token keyword">while</span>语句执行一次后面的语句
  <span class="token number">2</span>、一定要切记在<span class="token keyword">switch</span>循环中，如果没有<span class="token keyword">break</span>跳出语句，每一个<span class="token keyword">case</span>都要执行一遍，在计算最终结果。
</code></pre>
<p>4.switch 语句</p>
<pre><code class="prism language-java"><span class="token keyword">switch</span><span class="token punctuation">(</span>表达式expr<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">case</span> const1<span class="token operator">:</span>

        statement1<span class="token punctuation">;</span>

        <span class="token keyword">break</span><span class="token punctuation">;</span>

    … …

    <span class="token keyword">case</span> constN<span class="token operator">:</span>

        statementN<span class="token punctuation">;</span>

        <span class="token keyword">break</span><span class="token punctuation">;</span>

    <span class="token punctuation">[</span><span class="token keyword">default</span><span class="token operator">:</span>

        statement_dafault<span class="token punctuation">;</span>

        <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">]</span>

<span class="token punctuation">}</span>
注意：<span class="token number">1</span>、表达式必须是<span class="token keyword">int</span>、<span class="token keyword">byte</span>、<span class="token keyword">char</span>、<span class="token keyword">short</span>、enmu、<span class="token class-name">String</span>类型
      <span class="token number">2</span>、constN必须是常量或者finall变量，不能是范围
      <span class="token number">3</span>、所有的<span class="token keyword">case</span>语句的值不能相同，否则编译会报错
      <span class="token number">4</span>、<span class="token keyword">default</span>可要可不要
      <span class="token number">5</span>、<span class="token keyword">break</span>用来执行完一个分支后使程序跳出<span class="token keyword">switch</span>语句块，否则会一直会执行下去。
</code></pre>
<p>5.if和switch的区别是什么?</p>
<blockquote>
<p>1、<code>if</code>可以判断范围，也可以判断一个值<br/> <code>switch</code>只能判断指定的值<br/> 2、若只判断指定的值，则使用<code>switch</code>语句，效率快<br/> if判断范围，对数据判断灵活，自身的格式也比较灵活</p>
</blockquote>
<p>6.break和continue区别是什么?</p>
<blockquote>
<p><code>break</code>跳出某个循环<br/> <code>continue</code>跳过某个循环<br/> 注意：if外有循环可以用<code>break</code>、<code>continue</code>，单纯if不可以用。</p>
</blockquote>
<h2><a id="_259"></a>🎉关键字</h2>
<pre><code class="prism language-java"><span class="token number">1</span>、<span class="token keyword">static</span>调用格式：

    <span class="token number">1</span>、同一个类中：
        静态的：

            方法名     属性名

            类名<span class="token punctuation">.</span>方法名  类名<span class="token punctuation">.</span>属性名

            对象名<span class="token punctuation">.</span>方法名 对象名<span class="token punctuation">.</span>属性名

        非静态的：

            对象名<span class="token punctuation">.</span>属性名 对象名<span class="token punctuation">.</span>方法名

    <span class="token number">2</span>、不同类中<span class="token operator">:</span>

        静态的：

            对象名<span class="token punctuation">.</span>方法名 对象名<span class="token punctuation">.</span>属性名

            类名<span class="token punctuation">.</span>方法名  类名<span class="token punctuation">.</span>属性名

        非静态的：

            对象名<span class="token punctuation">.</span>属性名 类名<span class="token punctuation">.</span>方法名

    注意：<span class="token number">1</span>、<span class="token keyword">static</span>可以修饰属性、方法、代码块，不可以修饰类和构造方法。

          <span class="token number">2</span>、静态方法随着类的加载而加载。

          <span class="token number">3</span>、在静态方法区内的东西只有一份，所有的对象共享这一份空间，只要有一个对象对属性进行修改，所有的对象调用都是修改后的数据。

          <span class="token number">4</span>、代码块的执行顺序：静态代码块（只被调用一次）<span class="token operator">&gt;</span>构造代码块<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token operator">&gt;</span>构造方法<span class="token operator">&gt;</span>普通方法（需调用）

<span class="token number">2</span>、<span class="token keyword">this</span>关键字

    <span class="token number">1</span>、可以调用属性和方法。

        <span class="token keyword">this</span><span class="token punctuation">.</span>属性名（全局变量）

        <span class="token keyword">this</span><span class="token punctuation">.</span>方法名（）<span class="token punctuation">;</span>

    <span class="token number">2</span>、在构造方法中：

        <span class="token number">1</span>、<span class="token keyword">this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>括号内的参数个数、顺序、类型根据调用的方法来决定。

        <span class="token number">2</span>、必须放在第一行，只能调用一次。

        <span class="token number">3</span>、调用构造方法时只能在构造方法中调用，调用属性和方法时可以在构造方法中可以在普通方法中。

        <span class="token number">4</span>、当全局变量和局部变量有重名字的时候，用<span class="token keyword">this</span>来区分。

<span class="token number">3</span>、<span class="token keyword">super</span>关键字

    <span class="token number">1</span>、<span class="token keyword">super</span>指代父类对象。

    <span class="token number">2</span>、<span class="token keyword">super</span>可以调用属性、方法、构造方法。

    <span class="token number">3</span>、<span class="token keyword">super</span>调用父类的构造方法。

    <span class="token number">4</span>、<span class="token keyword">super</span>调用构造方法时候必须放在第一行。

<span class="token number">4</span>、<span class="token keyword">final</span>最终的

    <span class="token number">1</span>、可以修饰全局变量，声明的时候必须赋值，只能赋值一次。

    <span class="token number">2</span>、可以修饰局部变量，声明时候可以不赋值，但也只能赋值一次。

    <span class="token number">3</span>、可以修饰方法，可以正常使用，不能被重写。

    <span class="token number">4</span>、可以修饰类，可以正常使用，不能被继承。

    <span class="token number">5</span>、用<span class="token keyword">final</span>修饰的属性通常叫常量。

    <span class="token number">6</span>、<span class="token keyword">static</span> <span class="token keyword">final</span> 全局变量。每个字母都要大写。

<span class="token number">5</span>、<span class="token keyword">this</span>和<span class="token keyword">super</span>的区别

    <span class="token number">1</span>、<span class="token keyword">this</span>指的是本类创建的对象。                           <span class="token keyword">super</span>指代的是父类的对象

    <span class="token number">2</span>、<span class="token keyword">this</span>可以调用属性、方法、构造方法。                   <span class="token keyword">super</span>也可以调用属性、方法、构造方法。

    <span class="token number">3</span>、<span class="token keyword">this</span>调用属性和方法的时候，调用自己本类的属性和方法。 如果本类没有，那就用<span class="token keyword">super</span>去父类中找

    <span class="token number">4</span>、<span class="token keyword">this</span>调用构造方法调用，调用本类的其他构造方法。       <span class="token keyword">super</span>调用父类的构造方法。

    <span class="token number">5</span>、<span class="token keyword">this</span>和<span class="token keyword">super</span>在调用构造方法的时候必须放在第一行。

    <span class="token number">6</span>、<span class="token keyword">this</span>和<span class="token keyword">super</span>不能同时存在

<span class="token number">6</span>、最小作用域最强原则：

    局域变量在此方法中，比全局变量在此方法中的作用强。
</code></pre>
<h2><a id="publicprivateprotected__358"></a>🥫作用域public、private、protected 以及不写时的区别？</h2>
<blockquote>
<p><code>private</code>修饰的成员变量和函数只能在类本身和内部类中被访问<br/> <code>protected</code> 修饰的成员变量和函数能被类本身、子类及同一个包中的类访问<br/> <code>public</code>修饰的成员变量和函数可以被类、子类、同一个包中的类以及任意其他类访问<br/> 默认情况（不写）下，属于一种包访问，即能被类本身以及同一个包中的类访问</p>
</blockquote>
<table><thead><tr><th>作用域</th><th>当前类</th><th>统一package</th><th>子孙类</th><th>其他package</th></tr></thead><tbody><tr><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>protected</td><td>√</td><td>√</td><td>√</td><td>×</td></tr><tr><td>friendly</td><td>√</td><td>√</td><td>×</td><td>×</td></tr><tr><td>private</td><td>√</td><td>×</td><td>×</td><td>×</td></tr></tbody></table>
<h2><a id="forwardredirect_371"></a>🥚forward和redirect两种跳转方式的区别？</h2>
<blockquote>
<p>1.从地址栏显示来说<br/> <code>forward</code>是服务器请求资源,服务器直接访问目标地址的<code>URL</code>,把那个<code>URL</code>的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址.<br/> <code>redirect</code>是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的<code>URL</code><br/> 2.从数据共享来说<br/> <code>forward</code>:转发页面和转发到的页面可以共享<code>request</code>里面的数据<br/> <code>redirect</code>:不能共享数据.<br/> 3.从运用地方来说<br/> <code>forward</code>:一般用于用户登陆的时候,根据角色转发到相应的模块<br/> <code>redirect</code>:一般用于用户注销登陆时返回主页面和跳转到其它的网站等<br/> 4.从效率来说<br/> <code>forward</code>:高<br/> <code>redirect</code>:低</p>
</blockquote>
<h2><a id="HashMapHashtable_386"></a>🍧HashMap和Hashtable的区别？</h2>
<blockquote>
<p><code>HashMap</code>：实现了Map接口，允许空(null)键值(key),由于非线程安全，在只有一个线程访问的情况下，效率高于Hashtable。<br/> <code>Hashtable</code>：不能将null作为key或者value。方法是同步的，线程安全。</p>
</blockquote>
<h2><a id="ListSetMap_390"></a>🍨List、Set和Map的区别？</h2>
<blockquote>
<p>List:是存储单列数据的集合，存储有顺序，允许重复。继承Collection接口。<br/> Set: 是存储单列数据的集合。继承Collection接口。不允许重复。<br/> Map:存储键和值这样的双列数据的集合，存储数据无顺序，键(key)不能重复，值(value)。可以重复。</p>
</blockquote>
<h2><a id="hashCodeequals_395"></a>🍷hashCode与equals的区别与联系？</h2>
<p>一、equals方法的作用</p>
<blockquote>
<p>1、默认情况（没有覆盖equals方法）下equals方法都是调用Object类的equals方法，而Object的equals方法主要用于判断对象的内存地址引用是不是同一个地址（是不是同一个对象）。<br/> 2 、要是类中覆盖了equals方法，那么就要根据具体的代码来确定equals方法的作用了，覆盖后一般都是通过对象的内容是否相等来判断对象是否相等。</p>
</blockquote>
<p>二、Hashcode（）方法：</p>
<blockquote>
<p>1、我们并没有覆盖equals方法只覆盖了hashCode方法，两个对象虽然hashCode一样，但在将stu1和stu2放入set集合时由于equals方法比较的两个对象是false，所以就没有在比较两个对象的hashcode值。<br/> 2、覆盖一下equals方法和hashCode方法，stu1和stu2通过equals方法比较相等，而且返回的hashCode值一样，所以放入set集合中时只放入了一个对象。<br/> 3、我们让两个对象equals方法比较相等，但hashCode值不相等试试，虽然stu1和stu2通过equals方法比较相等，但两个对象的hashcode的值并不相等，所以在将stu1和stu2放入set集合中时认为是两个不同的对象。</p>
</blockquote>
<p>总结：</p>
<blockquote>
<p>1、equals方法用于比较对象的内容是否相等（覆盖以后）<br/> 2、hashcode方法只有在集合中用到<br/> 3、当覆盖了equals方法时，比较对象是否相等将通过覆盖后的equals方法进行比较（判断对象的内容是否相等）。<br/> 4、将对象放入到集合中时，首先判断要放入对象的hashcode值与集合中的任意一个元素的hashcode值是否相等，如果不相等直接将该对象放入集合中。如果hashcode值相等，然后再通过equals方法判断要放入对象与集合中的任意一个对象是否相等，如果equals判断不相等，直接将该元素放入到集合中，否则不放入。</p>
</blockquote>
<h2><a id="_413"></a>🧉模式</h2>
<p>1、单例模式</p>
<blockquote>
<p>分类：懒汉式、饿汉式<br/> 1、构造方法私有化<br/> 2、在本类中创建本类对象<br/> 3、保证对象的唯一性final<br/> 4、给外界提供得到对象的方法 static<br/> 5、在多线程中，饿汉式安全，懒汉式不安全</p>
</blockquote>
<p>2、简单工厂模式</p>
<blockquote>
<p>批量创建对象<br/> 1 创建工厂类 : 创建对象的方法<br/> 2 果汁类 是所有种类果汁的父类<br/> 3 在工厂类的方法中返回果汁类<br/> 4 根据测试类中传递的字符串判断到底返回哪种果汁<br/> 5 测试类通过工厂类返回果汁对象</p>
</blockquote>
<p>3、建造者模式</p>
<blockquote>
<p>内部类使用场景<br/> 目的：静态内部类创建外部类对象<br/> 1、 创建外部类，在其中创建一个静态内部类<br/> 2、静态内部类中写属性，构造方法和set get方法<br/> 3、静态内部类中写一个方法，必须返回外部类对象<br/> 4、 给外部类创建对象，传递参数。</p>
</blockquote>
<p>4、装饰者模式</p>
<blockquote>
<p>1、在处理流中使用<br/> 2、子类重写父类的方法,提高父类方法的功能及效率<br/> 3、为了尽可能减少重复代码,在重写的方法中用父类的对象调用父类原来的方法<br/> 4、得到父类对象可以通过将父类对象作为子类属性,通过子类构造方法传递父类对象</p>
</blockquote>
<h2><a id="Java_447"></a>🥯Java常用类</h2>
<p>1.装箱拆箱</p>
<pre><code class="prism language-java"><span class="token number">1</span>、装箱<span class="token operator">:</span>把基本数据类型转成包装类类型
<span class="token number">2</span>、拆箱<span class="token operator">:</span>把包装类类型转成基本数据类型
<span class="token number">3</span>、为什么要包装类
    八种基本数据类型不满足面向对象的思想，不包括属性和方法。如果给基本数据类型添加功能，只能创建其包装类，将方法和属性封装进去<span class="token punctuation">(</span>jdk5<span class="token punctuation">.</span><span class="token number">0</span>以后出现了自动拆箱，装箱<span class="token punctuation">)</span>
<span class="token number">4</span>、<span class="token class-name">Integer</span>支持字符串，但字符串必须是数字。<span class="token class-name">Integer</span> integer3<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     比较大小，大返回整数，小于返回负数，相等返回<span class="token number">0</span>

   <span class="token function">toBinaryString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    将十进制数转成二进制，返回<span class="token class-name">String</span>字符串的表现形式

   <span class="token function">toHexString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   将十进制转成十六进制

   <span class="token function">toOctalString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 将十进制转成八进制

   <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      将<span class="token keyword">int</span>类型数据转成<span class="token class-name">String</span>字符串

   <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   将<span class="token keyword">int</span>转成integer类型对象

   <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   将<span class="token keyword">int</span>转成integer类型对象

   <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      将<span class="token class-name">Integer</span>转成<span class="token keyword">int</span>
</code></pre>
<p>2.String字符串</p>
<pre><code class="prism language-java"><span class="token operator">==</span>                  比较地址
<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token punctuation">)</span>               比较内容
<span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span>         忽略大小写比较是否相同
<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              字符串截取出指定的下标开始
<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                比较大小
<span class="token punctuation">.</span><span class="token function">compareToIgnore</span><span class="token punctuation">(</span><span class="token punctuation">)</span>          忽略大小比较
<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token punctuation">)</span>               将参数字符串连接到指定字符串后面
<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token punctuation">)</span>             是否包含参数字符串
<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token punctuation">)</span>               以指定前缀开头
<span class="token punctuation">.</span><span class="token function">endsWith</span><span class="token punctuation">(</span><span class="token punctuation">)</span>             以指定后缀结尾
<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span>               第一次出现
<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>            指定位置开始索引
<span class="token punctuation">.</span><span class="token function">lastIndexOf</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span>           最后一次出现
<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>string11<span class="token punctuation">.</span><span class="token function">lastIndexOf</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>截取指定位置
<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>string11<span class="token punctuation">.</span><span class="token function">lastIndexOf</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> string11<span class="token punctuation">.</span><span class="token function">lastIndexOf</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//截取字符串，指定开始位置和结束位置</span>
<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token char">'a'</span><span class="token punctuation">,</span> <span class="token char">'b'</span><span class="token punctuation">)</span>          替换指定字符串，替换所有的
<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span>              全部转为大写
<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span>              全部转成小写
<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                 去掉字符串前后的空格，中间的去不掉
</code></pre>
<p>3.Boolean</p>
<pre><code class="prism language-java"><span class="token class-name">Boolean</span> <span class="token keyword">boolean</span><span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Boolean</span><span class="token punctuation">(</span><span class="token string">"false"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">boolean</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>4.正则表达式</p>
<pre><code class="prism language-java">字符类
<span class="token punctuation">[</span>abc<span class="token punctuation">]</span>       a、b、c其中任意一个
<span class="token punctuation">[</span><span class="token operator">^</span>abc<span class="token punctuation">]</span>      除了a、b、c中的任意一个
<span class="token punctuation">[</span>a<span class="token operator">-</span>zA<span class="token operator">-</span><span class="token class-name">Z</span><span class="token punctuation">]</span>     a<span class="token operator">-</span>z或<span class="token class-name">A</span><span class="token operator">-</span><span class="token class-name">Z</span>范围中的任意一个
<span class="token punctuation">[</span>a<span class="token operator">-</span>zA<span class="token operator">-</span>Z0<span class="token operator">-</span><span class="token number">9</span><span class="token punctuation">]</span>  a<span class="token operator">-</span>z <span class="token class-name">A</span><span class="token operator">-</span><span class="token class-name">Z</span> <span class="token number">0</span><span class="token operator">-</span><span class="token number">9</span> 其中任意一个
<span class="token punctuation">[</span>……<span class="token punctuation">]</span>         可以自己定义范围
预定字符类
\d   数字<span class="token number">0</span><span class="token operator">-</span><span class="token number">9</span>
\<span class="token class-name">D</span>   非数字<span class="token number">0</span><span class="token operator">-</span><span class="token number">9</span>
\s   空白字符：<span class="token punctuation">[</span> \t\n\x0B\f\r<span class="token punctuation">]</span>
\<span class="token class-name">S</span>   非空白字符：\s
\w   单词字符：<span class="token punctuation">[</span>a<span class="token operator">-</span>zA<span class="token operator">-</span>Z_0<span class="token operator">-</span><span class="token number">9</span><span class="token punctuation">]</span>
\<span class="token class-name">W</span>   非单词字符\w
数量词
<span class="token operator">?</span>     一次或者一次也没有
<span class="token operator">*</span>      <span class="token number">0</span>次到多次
<span class="token operator">+</span>      一次或者多次
<span class="token punctuation">{<!-- --></span>n<span class="token punctuation">}</span>    恰好n次
<span class="token punctuation">{<!-- --></span>n<span class="token punctuation">,</span><span class="token punctuation">}</span>   至少n次
<span class="token punctuation">{<!-- --></span>n<span class="token punctuation">,</span>m<span class="token punctuation">}</span>  至少n次但不超过m次
<span class="token punctuation">.</span><span class="token function">matches</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    匹配是否适合
<span class="token punctuation">.</span><span class="token function">spil</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   拆分
</code></pre>
<p>5.时间相关类</p>
<pre><code class="prism language-java"><span class="token number">1</span>、<span class="token class-name">Date</span>类
    <span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>计算毫秒

<span class="token number">2</span>、<span class="token class-name">SimpleDateFormat</span>类  格式化时间
    <span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>返回的是<span class="token class-name">String</span>字符串

<span class="token number">3</span>、<span class="token class-name">Calendar</span>接口  日历字段之间的转换提供了一些方法
    <span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Calendar</span><span class="token punctuation">.</span>YEAR<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Calendar</span><span class="token punctuation">.</span>MONTH<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 默认是当前月份减一    从0开始的  </span>
    <span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Calendar</span><span class="token punctuation">.</span>DAY_OF_MONTH<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Calendar</span><span class="token punctuation">.</span>DAY_OF_WEEK<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Calendar</span> calendar <span class="token operator">=</span> <span class="token class-name">Calendar</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Date</span> date <span class="token operator">=</span> calendar<span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token number">4</span>、<span class="token class-name">Runtime</span>运行时时间
    <span class="token punctuation">.</span><span class="token function">freeMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 当前的系统剩余空间

<span class="token number">5</span>、<span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>退出程序，参数是<span class="token number">0</span> 是正常退出
   <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>调用垃圾回收器 ，不一定能够起来 ，只是起到一个促进的作用
</code></pre>
<h1><a id="Java_552"></a>🎄Java集合框架</h1>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/09e6b3c34b114e24ac2ad7c3c461a5d0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA55m95aSn6ZSF,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<h2><a id="_555"></a>🚀常用的三种集合接口：</h2>
<blockquote>
<p>1.List：继承自Collection。可以存在相同的对象，有序的。具体实现类有ArrayList，LinkedList，Vector等（已经被抛弃，很少使用）<br/> 2.Set：继承自Collection。不能存在相同的对象，无序的，就是数学意义上的集合。具体实现类有HashSet，LinkedHashSet，TreeSet等。<br/> 3.Map：以键值对的形式存放对象。key-value。一般是key为String类型，value为Object的类型。具体实现类有HashMap，LinkedHashMap，TreeMap等。</p>
</blockquote>
<h2><a id="List_559"></a>🎉List(有序，可以重复的集合)</h2>
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
</code></pre>
<p>由于 List 接口是继承于 Collection 接口，所以基本的方法如上所示。</p>
<blockquote>
<p>1、List 接口的三个典型实现：<br/> ①、<code>List list1 = new ArrayList();</code><br/> 底层数据结构是数组，<strong>查询快，增删慢;线程不安全，效率高</strong><br/> ②、<code>List list2 = new Vector();</code><br/> 底层数据结构是数组，<strong>查询快，增删慢;线程安全，效率低</strong>,几乎已经淘汰了这个集合<br/> ③、<code>List list3 = new LinkedList();</code><br/> 底层数据结构是链表，<strong>查询慢，增删快;线程不安全，效率高</strong></p>
</blockquote>
<p>代码示例:</p>
<pre><code class="prism language-java"><span class="token comment">//产生一个 List 集合，典型实现为 ArrayList</span>
        <span class="token class-name">List</span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//添加三个元素</span>
        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"Tom"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"Bob"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"Marry"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//构造 List 的迭代器</span>
        <span class="token class-name">Iterator</span> it <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//通过迭代器遍历元素</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token class-name">Object</span> obj <span class="token operator">=</span> it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//System.out.println(obj);</span>
        <span class="token punctuation">}</span>

        <span class="token comment">//在指定地方添加元素</span>
        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">//在指定地方替换元素</span>
        list<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">//获得指定对象的索引</span>
        <span class="token keyword">int</span> i<span class="token operator">=</span>list<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"索引为："</span><span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">//遍历：普通for循环</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
             <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
</code></pre>
<h2><a id="Set_HashSet_607"></a>🎋Set(典型实现 HashSet()是一个无序，不可重复的集合)</h2>
<blockquote>
<p>HashSet 基于 HashMap 实现，使用了 HashMap 的 K 作为元素存储，V 为 new Object() ，在 add() 方法中如果两个元素的 Hash 值相同，则通过 equals 方法比较是否相等。<br/> LinkedHashSet LinkedHashSet 继承于 HashSet，并且其内部是通过 LinkedHashMap 来实现的。<br/> TreeSet 红黑树实现有序唯一。</p>
</blockquote>
<p>1、<code>Set hashSet = new HashSet();</code></p>
<blockquote>
<p>①、<strong>HashSet</strong>:不能保证元素的顺序；不可重复；不是线程安全的；集合元素可以为 NULL;<br/> ②、其底层其实是一个数组，存在的意义是加快查询速度。我们知道在一般的数组中，元素在数组中的索引位置是随机的，元素的取值和元素的位置之间不存在确定的关系，因此，在数组中查找特定的值时，需要把查找值和一系列的元素进行比较，此时的查询效率依赖于查找过程中比较的次数。而 HashSet 集合底层数组的索引和值有一个确定的关系：<code>index=hash(value)</code>,那么只需要调用这个公式，就能快速的找到元素或者索引。<br/> ③、对于 HashSet: 如果两个对象通过 equals() 方法返回 true，这两个对象的 hashCode 值也应该相同。<br/> 1、当向HashSet集合中存入一个元素时，<strong>HashSet</strong>会先调用该对象的hashCode()方法来得到该对象的<strong>hashCode</strong>值，然后根据<strong>hashCode</strong>值决定该对象在HashSet中的存储位置<br/> 1.1、如果 <strong>hashCode</strong> 值不同，直接把该元素存储到 <code>hashCode()</code> 指定的位置<br/> 1.2、如果 <strong>hashCode</strong> 值相同，那么会继续判断该元素和集合对象的 equals() 作比较<br/> 1.2.1、<code>hashCode</code> 相同，<strong>equals</strong> 为 <strong>true</strong>，则视为同一个对象，不保存在 hashSet()中<br/> 1.2.2、<code>hashCode</code> 相同，<strong>equals</strong> 为 <strong>false</strong>，则存储在之前对象同槽位的链表上，这非常麻烦，我们应该约束这种情况，即保证：如果两个对象通过 <code>equals()</code> 方法返回 true，这两个对象的 hashCode 值也应该相同。<br/> 注意：每一个存储到 哈希 表中的对象，都得提供 <code>hashCode()</code> 和 <code>equals()</code> 方法的实现，用来判断是否是同一个对象<br/> 　　　对于 <code>HashSet</code> 集合，我们要保证如果两个对象通过 <code>equals()</code> 方法返回 <strong>true</strong>，这两个对象的 <strong>hashCode</strong> 值也应该相同。</p>
</blockquote>
<p>常见的 hashCode()算法：<br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/efa84c2afdf84d7c8b676b9ba98d2a02.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA55m95aSn6ZSF,size_20,color_FFFFFF,t_70,g_se,x_16"/><br/> 2、<code>Set linkedHashSet = new LinkedHashSet();</code></p>
<blockquote>
<p>不可以重复，有序，因为底层采用 链表 和 哈希表的算法。链表保证元素的添加顺序，哈希表保证元素的唯一性</p>
</blockquote>
<p>3、<code>Set treeSet = new TreeSet();</code></p>
<blockquote>
<p><code>TreeSet</code>:有序；不可重复，底层使用 红黑树算法，擅长于范围查询。<br/> 如果使用 <code>TreeSet()</code> 无参数的构造器创建一个 <code>TreeSet</code> 对象, 则要求放入其中的元素的类必须实现 <code>Comparable</code> 接口所以, 在其中不能放入 <code>null</code> 元素<br/> 必须放入同样类的对象(默认会进行排序) 否则可能会发生类型转换异常.我们可以使用泛型来进行限制</p>
</blockquote>
<h2><a id="Mapkeyvalue_key_value_636"></a>🎡Map(key-value 的键值对，key 不允许重复，value可以)</h2>
<blockquote>
<p>1、严格来说 <code>Map</code> 并不是一个集合，而是两个集合之间 的映射关系。<br/> 2、这两个集合没每一条数据通过映射关系，我们可以看成是一条数据。即 <code>Entry(key,value）</code>。Map 可以看成是由多个 Entry 组成。<br/> 3、因为 Map 集合即没有实现于 <code>Collection</code> 接口，也没有实现 <code>Iterable</code> 接口，所以不能对 <code>Map</code> 集合进行 <code>for-each</code> 遍历。</p>
</blockquote>
<p>代码示例:</p>
<pre><code class="prism language-java"><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> hashMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//添加元素到 Map 中</span>
        hashMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"key1"</span><span class="token punctuation">,</span> <span class="token string">"value1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        hashMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"key2"</span><span class="token punctuation">,</span> <span class="token string">"value2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        hashMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"key3"</span><span class="token punctuation">,</span> <span class="token string">"value3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        hashMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"key4"</span><span class="token punctuation">,</span> <span class="token string">"value4"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        hashMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"key5"</span><span class="token punctuation">,</span> <span class="token string">"value5"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         
        <span class="token comment">//删除 Map 中的元素,通过 key 的值</span>
        hashMap<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">"key1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         
        <span class="token comment">//通过 get(key) 得到 Map 中的value</span>
        <span class="token class-name">Object</span> str1 <span class="token operator">=</span> hashMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"key1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         
        <span class="token comment">//可以通过 添加 方法来修改 Map 中的元素</span>
        hashMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"key2"</span><span class="token punctuation">,</span> <span class="token string">"修改 key2 的 Value"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         
        <span class="token comment">//通过 map.values() 方法得到 Map 中的 value 集合</span>
        <span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> value <span class="token operator">=</span> hashMap<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj <span class="token operator">:</span> value<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token comment">//System.out.println(obj);</span>
        <span class="token punctuation">}</span>
         
        <span class="token comment">//通过 map.keySet() 得到 Map 的key 的集合，然后 通过 get(key) 得到 Value</span>
        <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> set <span class="token operator">=</span> hashMap<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">String</span> str <span class="token operator">:</span> set<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token class-name">Object</span> obj <span class="token operator">=</span> hashMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//System.out.println(str+"="+obj);</span>
        <span class="token punctuation">}</span>
         
        <span class="token comment">//通过 Map.entrySet() 得到 Map 的 Entry集合，然后遍历</span>
        <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> entrys <span class="token operator">=</span> hashMap<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> entry<span class="token operator">:</span> entrys<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token class-name">String</span> key <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">Object</span> value2 <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>key<span class="token operator">+</span><span class="token string">"="</span><span class="token operator">+</span>value2<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
         
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>hashMap<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<h3><a id="Map_685"></a>🎄Map常用方法及实现类</h3>
<pre><code class="prism language-java">    <span class="token number">1.</span>添加：
        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>value<span class="token punctuation">)</span> <span class="token comment">//在key位置上存储value值，key存在则覆盖原有值；</span>
        map<span class="token punctuation">.</span><span class="token function">putAll</span><span class="token punctuation">(</span><span class="token class-name">Map</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将Map集合m放在map中</span>
    <span class="token number">2.</span>删除：
        map<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//清空map中的数据</span>
        map<span class="token punctuation">.</span><span class="token function">remvoe</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//删除key及其位置上的元素，返回其值。</span>
    <span class="token number">3.</span>判断：
        map<span class="token punctuation">.</span><span class="token function">containsValue</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//判断集合是否包含value值</span>
        map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//判断集合是否包含key键</span>
    <span class="token number">4.</span>获取：
        map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//获取key键上的value值</span>
        map<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//获取map集合的大小</span>
        <span class="token class-name">Collection</span> c <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token comment">// 返回map集合中的value值 的Collection集合；</span>
        <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span> <span class="token class-name">K</span> <span class="token punctuation">&gt;</span></span> set <span class="token operator">=</span> <span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//取出key的所有值的Set集合</span>
        <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">&lt;</span> <span class="token class-name">K</span> <span class="token punctuation">,</span> <span class="token class-name">V</span> <span class="token punctuation">&gt;</span> <span class="token punctuation">&gt;</span></span>set <span class="token operator">=</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>实现类:</p>
<blockquote>
<p>1.<code>Hashtable</code> ： 底层用哈希表实现，不允许存在null键和值，集合线程安全（线程同步） jdk1.0以前常用<br/> 2.<code>HashMap</code> ： 底层用哈希表实现，运行存在null的键和值，集合线程不同步，用法与Hastable相同<br/> 3.<code>TreeMap</code> ： 底层用二叉树实现，用于需要排序的Map集合中<br/> 4.<code>Properties</code>:继承Hastbale，主要用于流中文件固化<br/> 5.<code>ConcurrentHashMap</code>:线程安全的 HashMap。<br/> 1.7 采用分段锁的形式加锁；1.8 使用 Synchronized 和 CAS 实现同步，若数组的 Node 为空，则通过 CAS 的方式设置值，不为空则加在链表的第一个节点。获取第一个元素是否为空使用 Unsafe 类提供的 getObjectVolatile 保证可见性。<br/> 对于读操作，数组由 volatile 修饰，同时数组的元素为 Node，Node 的 K 使用 final 修饰，V 使用 volatile 修饰，下一个节点也用 volatile 修饰，保证多线程的可见性。<br/> 6.<code>LinkedHashMap</code> :继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。</p>
</blockquote>
<h2><a id="MapSet_717"></a>🧨Map与Set关系</h2>
<blockquote>
<p>1、都有几个类型的集合。HashMap 和 HashSet ，都采 哈希表算法；TreeMap 和 TreeSet 都采用 红-黑树算法；LinkedHashMap 和 LinkedHashSet 都采用 哈希表算法和红-黑树算法。<br/> 2、分析 Set 的底层源码，我们可以看到，Set 集合 就是 由 Map 集合的 Key 组成</p>
</blockquote>
<h1><a id="Java_723"></a>🎄Java多线程</h1>
<h2><a id="_724"></a>🎗创建线程和启动</h2>
<blockquote>
<p>(1)继承<code>Thread</code>类创建线程类<br/> 通过继承<code>Thread</code>类创建线程类的具体步骤和具体代码如下：<br/> • 定义一个继承<code>Thread</code>类的子类，并重写该类的<code>run()</code>方法；<br/> • 创建<code>Thread</code>子类的实例，即创建了线程对象；<br/> • 调用该线程对象的<code>start()</code>方法启动线程。</p>
</blockquote>
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">SomeThead</span> <span class="token keyword">extends</span> <span class="token class-name">Thraad</span>   <span class="token punctuation">{<!-- --></span> 
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token punctuation">{<!-- --></span> 
     <span class="token comment">//do something here  </span>
    <span class="token punctuation">}</span>  
 <span class="token punctuation">}</span> 
 
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
 <span class="token class-name">SomeThread</span> oneThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SomeThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   
  步骤<span class="token number">3</span>：启动线程：   
 oneThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>(2)实现<code>Runnable</code>接口创建线程类<br/> 通过实现<code>Runnable</code>接口创建线程类的具体步骤和具体代码如下：<br/> • 定义<code>Runnable</code>接口的实现类，并重写该接口的<code>run()</code>方法；<br/> • 创建<code>Runnable</code>实现类的实例，并以此实例作为<code>Thread</code>的<code>target</code>对象，即该Thread对象才是真正的线程对象。</p>
</blockquote>
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">SomeRunnable</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span>   <span class="token punctuation">{<!-- --></span> `在这里插入代码片`
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token punctuation">{<!-- --></span> 
  <span class="token comment">//do something here  </span>
  <span class="token punctuation">}</span>  
<span class="token punctuation">}</span> 
<span class="token class-name">Runnable</span> oneRunnable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SomeRunnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   
<span class="token class-name">Thread</span> oneThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>oneRunnable<span class="token punctuation">)</span><span class="token punctuation">;</span>   
oneThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
</code></pre>
<blockquote>
<p>(3)通过<code>Callable</code>和<code>Future</code>创建线程<br/> 通过<code>Callable</code>和<code>Future</code>创建线程的具体步骤和具体代码如下：<br/> • 创建<code>Callable</code>接口的实现类，并实现<code>call()</code>方法，该<code>call()</code>方法将作为线程执行体，并且有返回值。<br/> • 创建<code>Callable</code>实现类的实例，使用<code>FutureTask</code>类来包装<code>Callable</code>对象，该<code>FutureTask</code>对象封装了该<code>Callable</code>对象的<code>call()</code>方法的返回值。<br/> • 使用<code>FutureTask</code>对象作为Thread对象的target创建并启动新线程。<br/> • 调用<code>FutureTask</code>对象的<code>get()</code>方法来获得子线程执行结束后的返回值其中，Callable接口(<strong>也只有一个方法</strong>)定义如下：</p>
</blockquote>
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Callable</span>   <span class="token punctuation">{<!-- --></span> 
  <span class="token class-name">V</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">;</span>  
 <span class="token punctuation">}</span> 
  步骤<span class="token number">1</span>：创建实现<span class="token class-name">Callable</span>接口的类<span class="token class-name">SomeCallable</span><span class="token punctuation">(</span>略<span class="token punctuation">)</span><span class="token punctuation">;</span>   
  步骤<span class="token number">2</span>：创建一个类对象： 
      <span class="token class-name">Callable</span> oneCallable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SomeCallable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
  步骤<span class="token number">3</span>：由<span class="token class-name">Callable</span>创建一个<span class="token class-name">FutureTask</span>对象：   
    <span class="token class-name">FutureTask</span> oneTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token punctuation">(</span>oneCallable<span class="token punctuation">)</span><span class="token punctuation">;</span> 
  注释： <span class="token class-name">FutureTask</span>是一个包装器，它通过接受<span class="token class-name">Callable</span>来创建，它同时实现了 <span class="token class-name">Future</span>和<span class="token class-name">Runnable</span>接口。 
  步骤<span class="token number">4</span>：由<span class="token class-name">FutureTask</span>创建一个<span class="token class-name">Thread</span>对象：   
    <span class="token class-name">Thread</span> oneThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>oneTask<span class="token punctuation">)</span><span class="token punctuation">;</span>   
  步骤<span class="token number">5</span>：启动线程：  
    oneThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<h2><a id="_786"></a>🎀线程生命周期</h2>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/affeee1572d64267ba278fb2e6ca7320.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA55m95aSn6ZSF,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<blockquote>
<p>1、新建状态<br/> 用<strong>new</strong>关键字和<strong>Thread</strong>类或其子类建立一个线程对象后，该线程对象就处于新生状态。处于新生状态的线程有自己的内存空间，通过调用start方法进入就绪状态（<strong>runnable</strong>）。<br/> 注意：不能对已经启动的线程再次调用<code>start()</code>方法，否则会出现<code>Java.lang.IllegalThreadStateException</code>异常。<br/> 2、就绪状态<br/> 处于就绪状态的线程已经具备了运行条件，但<strong>还没有分配到CPU</strong>，处于<strong>线程就绪队列</strong>（尽管是采用队列形式，事实上，把它<strong>称为可运行池</strong>而不是可运行队列。因为cpu的调度不一定是<strong>按照先进先出的顺序来调度的</strong>），等待系统为其分配CPU。等待状态<strong>并不是执行状态</strong>，当系统选定一个等待<strong>执行的Thread对象后</strong>，它就会<strong>从等待执行状态进入执行状态</strong>，系统挑选的动作称之为“cpu调度”。一旦获得CPU，线程就进入运行状态并自动调用自己的run方法。<br/> 提示：如果希望子线程调用<code>start()</code>方法后<strong>立即执行</strong>，可以使用<code>Thread.sleep()</code>方式使主线程睡眠一伙儿，转去<strong>执行子线程</strong>。<br/> 3、运行状态<br/> 处于运行状态的线程最为复杂，它可以变为<strong>阻塞状态、就绪状态和死亡状态</strong>。<br/> 处于<strong>就绪状态</strong>的线程，如果获得了cpu的调度，就会从就绪状态变为运行状态，执行run()方法中的任务。如果该线程失去了cpu资源，就会又从运行状态变为就绪状态。重新等待系统分配资源。也可以对在运行状态的线程调用<code>yield()</code>方法，它就会让出cpu资源，再次变为就绪状态。<br/> 注： 当发生如下情况是，线程会从运行状态变为阻塞状态：<br/> ①、线程调用<strong>sleep</strong>方法主动放弃所占用的系统资源<br/> ②、线程调用一个阻塞式<strong>IO</strong>方法，在该方法返回之前，该线程被阻塞<br/> ③、线程试图获得一个同步监视器，但更改同步监视器正被其他线程所持有<br/> ④、线程在等待某个通知（<strong>notify</strong>）<br/> ⑤、程序调用了线程的<strong>suspend</strong>方法将线程挂起。不过该方法容易导致死锁，所以程序应该尽量避免使用该方法。<br/> 当线程的<code>run()</code>方法执行完，或者被强制性地终止，例如出现异常，或者调用了<code>stop()、desyory()</code>方法等等，就会从运行状态转变为死亡状态。<br/> 4、阻塞状态<br/> 处于运行状态的线程在某些情况下，如执行了<strong>sleep</strong>（睡眠）方法，或等待I/O设备等资源，将让出CPU并暂时停止自己的运行，进入阻塞状态。<br/> 在阻塞状态的线程不能进入就绪队列。只有当引起阻塞的原因消除时，如睡眠时间已到，或等待的I/O设备空闲下来，线程便转入就绪状态，重新到就绪队列中排队等待，被系统选中后从原来停止的位置开始继续运行。<br/> 5、死亡状态<br/> 当线程的<code>run()</code>方法执行完，或者被强制性地终止，就认为它死去。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。<strong>线程一旦死亡，就不能复生</strong>。 如果在一个死去的线程上调用<code>start()</code>方法，会抛出<code>java.lang.IllegalThreadStateException</code>异常。</p>
</blockquote>
<h2><a id="_810"></a>🎭线程管理</h2>
<h3><a id="sleep_811"></a>🎗线程睡眠——sleep</h3>
<p>Java提供了一些便捷的方法用于会线程状态的控制。具体如下：</p>
<p>1、线程睡眠——sleep<br/> 如果我们需要让当前正在执行的线程暂停一段时间，并进入阻塞状态，则可以通过调用Thread的sleep方法。<br/> 注：</p>
<blockquote>
<p>（1）sleep是静态方法，最好不要用Thread的实例对象调用它，因为它睡眠的始终是当前正在运行的线程，而不是调用它的线程对象，它只对正在运行状态的线程对象有效。如下面的例子：</p>
</blockquote>
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test1</span> <span class="token punctuation">{<!-- --></span>  
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{<!-- --></span>  
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token class-name">MyThread</span> myThread<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
        myThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
        myThread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//这里sleep的就是main线程，而非myThread线程  </span>
        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">100</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>  
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"main"</span><span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>（2）Java线程调度是Java多线程的核心，只有良好的调度，才能充分发挥系统的性能，提高程序的执行效率。但是不管程序员怎么编写调度，只能最大限度的影响线程执行的次序，而不能做到精准控制。因为使用sleep方法之后，线程是进入阻塞状态的，只有当睡眠的时间结束，才会重新进入到就绪状态，而就绪状态进入到运行状态，是由系统控制的，我们不可能精准的去干涉它，所以如果调用Thread.sleep(1000)使得线程睡眠1秒，可能结果会大于1秒。</p>
</blockquote>
<h3><a id="yield_835"></a>🎗线程让步——yield</h3>
<blockquote>
<p><code>yield()方法和sleep()</code>方法有点相似，它也是<strong>Thread类提供的一个静态的方法</strong>，它也可以<strong>让当前正在执行的线程暂停</strong>，让出cpu资源给其他的线程。但是和<code>sleep()</code>方法不同的是，它<strong>不会进入到阻塞状态</strong>，而是<strong>进入到就绪状态</strong>。<code>yield()</code>方法只是<strong>让当前线程暂停一下</strong>，<strong>重新进入就绪的线程池中</strong>，让系统的线程调度器重新调度器重新调度一次，完全可能出现这样的情况：当某个线程调用<code>yield()</code>方法之后，线程调度器又将其调度出来重新进入到运行状态执行。</p>
</blockquote>
<p>实际上，当某个线程调用了yield()方法暂停之后，优先级与当前线程相同，或者优先级比当前线程更高的就绪状态的线程更有可能获得执行的机会，当然，只是有可能，因为我们不可能精确的干涉cpu调度线程。用法如下：</p>
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test1</span> <span class="token punctuation">{<!-- --></span>  
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{<!-- --></span>  
        <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token string">"低级"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token string">"中级"</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token string">"高级"</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>  
  
<span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{<!-- --></span>  
    <span class="token keyword">public</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> pro<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>  
        <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 设置线程的名称  </span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setPriority</span><span class="token punctuation">(</span>pro<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 设置优先级  </span>
    <span class="token punctuation">}</span>  
  
    <span class="token annotation punctuation">@Override</span>  
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>  
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">30</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>  
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"线程第"</span> <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token string">"次执行！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> <span class="token number">5</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>  
                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token keyword">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>注：关于sleep()方法和yield()方的区别如下：<br/> ①、sleep方法暂停当前线程后，会进入阻塞状态，只有当睡眠时间到了，才会转入就绪状态。而yield方法调用后 ，是直接进入就绪状态，所以有可能刚进入就绪状态，又被调度到运行状态。<br/> ②、sleep方法声明抛出了InterruptedException，所以调用sleep方法的时候要捕获该异常，或者显示声明抛出该异常。而yield方法则没有声明抛出任务异常。<br/> ③、sleep方法比yield方法有更好的可移植性，通常不要依靠yield方法来控制并发线程的执行。</p>
</blockquote>
<h3><a id="_871"></a>🎗设置线程的优先级</h3>
<blockquote>
<p>每个线程执行时都有一个优先级的属性，优先级高的线程可以获得较多的执行机会，而优先级低的线程则获得较少的执行机会。与线程休眠类似，线程的优先级仍然无法保障线程的执行次序。只不过，优先级高的线程获取CPU资源的概率较大，优先级低的也并非没机会执行。</p>
</blockquote>
<blockquote>
<p>每个线程默认的优先级都与创建它的父线程具有相同的优先级，在默认情况下，main线程具有普通优先级。</p>
</blockquote>
<blockquote>
<p>注：Thread类提供了setPriority(int newPriority)和getPriority()方法来设置和返回一个指定线程的优先级，其中setPriority方法的参数是一个整数，范围是1~·0之间，也可以使用Thread类提供的三个静态常量：</p>
</blockquote>
<blockquote>
<p>MAX_PRIORITY =10<br/> MIN_PRIORITY =1<br/> NORM_PRIORITY =5</p>
</blockquote>
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test1</span> <span class="token punctuation">{<!-- --></span>  
        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{<!-- --></span>  
            <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token string">"高级"</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
            <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token string">"低级"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
    <span class="token punctuation">}</span>  
      
    <span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{<!-- --></span>  
        <span class="token keyword">public</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span><span class="token keyword">int</span> pro<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>  
            <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//设置线程的名称  </span>
            <span class="token function">setPriority</span><span class="token punctuation">(</span>pro<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//设置线程的优先级  </span>
        <span class="token punctuation">}</span>  
        <span class="token annotation punctuation">@Override</span>  
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>  
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>  
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"线程第"</span> <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token string">"次执行！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
            <span class="token punctuation">}</span>  
        <span class="token punctuation">}</span>  
    <span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>注：<strong>虽然Java提供了10个优先级别，但这些优先级别需要操作系统的支持。不同的操作系统的优先级并不相同，而且也不能很好的和Java的10个优先级别对应。所以我们应该使用MAX_PRIORITY、MIN_PRIORITY和NORM_PRIORITY三个静态常量来设定优先级，这样才能保证程序最好的可移植性。</strong></p>
</blockquote>
<h3><a id="_905"></a>🎗后台（守护）线程</h3>
<blockquote>
<p>守护线程使用的情况较少，但并非无用，举例来说，JVM的垃圾回收、内存管理等线程都是守护线程。还有就是在做数据库应用时候，使用的数据库连接池，连接池本身也包含着很多后台线程，监控连接个数、超时时间、状态等等。调用线程对象的方法setDaemon(true)，则可以将其设置为守护线程。守护线程的用途为：<br/> • 守护线程通常用于执行一些后台作业，例如在你的应用程序运行时播放背景音乐，在文字编辑器里做自动语法检查、自动保存等功能。<br/> • Java的垃圾回收也是一个守护线程。守护线的好处就是你不需要关心它的结束问题。例如你在你的应用程序运行的时候希望播放背景音乐，如果将这个播放背景音乐的线程设定为非守护线程，那么在用户请求退出的时候，不仅要退出主线程，还要通知播放背景音乐的线程退出；如果设定为守护线程则不需要了。</p>
</blockquote>
<p>setDaemon方法的详细说明：</p>
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">setDaemon</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> on<span class="token punctuation">)</span>        将该线程标记为守护线程或用户线程。当正在运行的线程都是守护线程时，<span class="token class-name">Java</span> 虚拟机退出。    
         该方法必须在启动线程前调用。 该方法首先调用该线程的 checkAccess 方法，且不带任何参数。这可能抛出 <span class="token class-name">SecurityException</span>（在当前线程中）。   
  参数：
     on <span class="token operator">-</span> 如果为 <span class="token boolean">true</span>，则将该线程标记为守护线程。    
  抛出：    
    <span class="token class-name">IllegalThreadStateException</span> <span class="token operator">-</span> 如果该线程处于活动状态。    
    <span class="token class-name">SecurityException</span> <span class="token operator">-</span> 如果当前线程无法修改该线程。
</code></pre>
<blockquote>
<p>注：<strong>JRE判断程序是否执行结束的标准是所有的前台执线程行完毕了，而不管后台线程的状态，因此，在使用后台县城时候一定要注意这个问题。</strong></p>
</blockquote>
<h3><a id="_925"></a>🎗正确结束线程</h3>
<blockquote>
<p><code>Thread.stop()、Thread.suspend、Thread.resume、Runtime.runFinalizersOnExit</code>这些终止线程运行的方法已经被废弃了，使用它们是极端不安全的！想要安全有效的结束一个线程，可以使用下面的方法：<br/> • 正常执行完run方法，然后结束掉；<br/> • 控制循环条件和判断条件的标识符来结束掉线程。</p>
</blockquote>
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{<!-- --></span>  
    <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>  
    <span class="token keyword">boolean</span> next<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>  
    <span class="token annotation punctuation">@Override</span>  
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>  
        <span class="token keyword">while</span> <span class="token punctuation">(</span>next<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>  
            <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">==</span><span class="token number">10</span><span class="token punctuation">)</span>  
                next<span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">;</span>  
            i<span class="token operator">++</span><span class="token punctuation">;</span>  
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>
</code></pre>
<h2><a id="_946"></a>🎁线程同步</h2>
<blockquote>
<p>java允许多线程并发控制，当多个线程同时操作一个可共享的资源变量时（如数据的增删改查），将会导致数据不准确，相互之间产生冲突，因此加入同步锁以避免在该线程没有完成操作之前，被其他线程的调用，从而保证了该变量的唯一性和准确性。</p>
</blockquote>
<h3><a id="_949"></a>🎗同步方法</h3>
<blockquote>
<p>即有synchronized关键字修饰的方法。由于java的每个对象都有一个内置锁，当用此关键字修饰方法时，内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。</p>
</blockquote>
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>注： <strong><code>synchronized</code>关键字也可以修饰静态方法，此时如果调用该静态方法，将会锁住整个类</strong></p>
</blockquote>
<h3><a id="_959"></a>🎗同步代码块</h3>
<blockquote>
<p>即有<code>synchronized</code>关键字修饰的语句块。被该关键字修饰的语句块会自动被加上内置锁，从而实现同步。</p>
</blockquote>
<pre><code class="prism language-java"> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Bank</span> <span class="token punctuation">{<!-- --></span>  
     
        <span class="token keyword">private</span> <span class="token keyword">int</span> count <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//账户余额  </span>
     
        <span class="token comment">//存钱  </span>
        <span class="token keyword">public</span>   <span class="token keyword">void</span> <span class="token function">addMoney</span><span class="token punctuation">(</span><span class="token keyword">int</span> money<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>  
     
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>  
                count <span class="token operator">+=</span>money<span class="token punctuation">;</span>  
            <span class="token punctuation">}</span>  
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"存进："</span><span class="token operator">+</span>money<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
     
        <span class="token comment">//取钱  </span>
        <span class="token keyword">public</span>   <span class="token keyword">void</span> <span class="token function">subMoney</span><span class="token punctuation">(</span><span class="token keyword">int</span> money<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>  
     
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>  
                <span class="token keyword">if</span><span class="token punctuation">(</span>count<span class="token operator">-</span>money <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>  
                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"余额不足"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
                    <span class="token keyword">return</span><span class="token punctuation">;</span>  
                <span class="token punctuation">}</span>  
                count <span class="token operator">-=</span>money<span class="token punctuation">;</span>  
            <span class="token punctuation">}</span>  
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token operator">+</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"取出："</span><span class="token operator">+</span>money<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
     
        <span class="token comment">//查询  </span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lookMoney</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>  
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"账户余额："</span><span class="token operator">+</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>注：<strong>同步是一种高开销的操作，因此应该尽量减少同步的内容。通常没有必要同步整个方法，使用synchronized代码块同步关键代码即可。</strong></p>
</blockquote>
<h3><a id="volatile_998"></a>🎗使用特殊域变量(volatile)实现线程同步</h3>
<blockquote>
<p>• volatile关键字为域变量的访问提供了一种免锁机制；<br/> • 使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新；<br/> • 因此每次使用该域就要重新计算，而不是使用寄存器中的值；<br/> • volatile不会提供任何原子操作，它也不能用来修饰final类型的变量。</p>
</blockquote>
<pre><code class="prism language-java"> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SynchronizedThread</span> <span class="token punctuation">{<!-- --></span>
 
        <span class="token keyword">class</span> <span class="token class-name">Bank</span> <span class="token punctuation">{<!-- --></span>
 
            <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> account <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
 
            <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getAccount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">return</span> account<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
 
            <span class="token comment">/**
             * 用同步方法实现
             * 
             * @param money
             */</span>
            <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">save</span><span class="token punctuation">(</span><span class="token keyword">int</span> money<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                account <span class="token operator">+=</span> money<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
 
            <span class="token comment">/**
             * 用同步代码块实现
             * 
             * @param money
             */</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">save1</span><span class="token punctuation">(</span><span class="token keyword">int</span> money<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    account <span class="token operator">+=</span> money<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
 
        <span class="token keyword">class</span> <span class="token class-name">NewThread</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">private</span> <span class="token class-name">Bank</span> bank<span class="token punctuation">;</span>
 
            <span class="token keyword">public</span> <span class="token class-name">NewThread</span><span class="token punctuation">(</span><span class="token class-name">Bank</span> bank<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>bank <span class="token operator">=</span> bank<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
 
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token comment">// bank.save1(10);</span>
                    bank<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token string">"账户余额为："</span> <span class="token operator">+</span>bank<span class="token punctuation">.</span><span class="token function">getAccount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
 
        <span class="token punctuation">}</span>
 
        <span class="token comment">/**
         * 建立线程，调用内部类
         */</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">useThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">Bank</span> bank <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Bank</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">NewThread</span> new_thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NewThread</span><span class="token punctuation">(</span>bank<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">Thread</span> thread1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>new_thread<span class="token punctuation">)</span><span class="token punctuation">;</span>
            thread1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">Thread</span> thread2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>new_thread<span class="token punctuation">)</span><span class="token punctuation">;</span>
            thread2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
 
        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">SynchronizedThread</span> st <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SynchronizedThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            st<span class="token punctuation">.</span><span class="token function">useThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>注：<strong>多线程中的非同步问题主要出现在对域的读写上，如果让域自身避免这个问题，则就不需要修改操作该域的方法。用final域，有锁保护的域和volatile域可以避免非同步的问题。</strong></p>
</blockquote>
<h3><a id="Lock_1076"></a>🎗使用重入锁（Lock）实现线程同步</h3>
<blockquote>
<p>在JavaSE5.0中新增了一个java.util.concurrent包来支持同步。<strong>ReentrantLock</strong>类是可重入、互斥、实现了<strong>Lock</strong>接口的锁，它与使用<strong>synchronized</strong>方法和快具有相同的基本行为和语义，并且扩展了其能力。<strong>ReenreantLock</strong>类的常用方法有：</p>
</blockquote>
<pre><code class="prism language-java"><span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> 创建一个<span class="token class-name">ReentrantLock</span>实例         
 <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> 获得锁        
 <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> 释放锁
</code></pre>
<blockquote>
<p>注：<strong><code>ReentrantLock()</code>还有一个可以创建公平锁的构造方法，但由于能大幅度降低程序运行效率，不推荐使用</strong></p>
</blockquote>
<pre><code class="prism language-java"><span class="token comment">//只给出要修改的代码，其余代码与上同</span>
        <span class="token keyword">class</span> <span class="token class-name">Bank</span> <span class="token punctuation">{<!-- --></span>
            
            <span class="token keyword">private</span> <span class="token keyword">int</span> account <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
            <span class="token comment">//需要声明这个锁</span>
            <span class="token keyword">private</span> <span class="token class-name">Lock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getAccount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">return</span> account<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">//这里不再需要synchronized </span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">save</span><span class="token punctuation">(</span><span class="token keyword">int</span> money<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">try</span><span class="token punctuation">{<!-- --></span>
                    account <span class="token operator">+=</span> money<span class="token punctuation">;</span>
                <span class="token punctuation">}</span><span class="token keyword">finally</span><span class="token punctuation">{<!-- --></span>
                    lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                
            <span class="token punctuation">}</span>
        ｝
</code></pre>
<h2><a id="_1113"></a>🧶线程通信</h2>
<h3><a id="ObjectwaitnotifynotifyAll_1114"></a>🎗借助于Object类的wait()、notify()和notifyAll()实现通信</h3>
<blockquote>
<p>线程执行wait()后，就放弃了运行资格，处于冻结状态；<br/> 线程运行时，内存中会建立一个线程池，冻结状态的线程都存在于线程池中，notify()执行时唤醒的也是线程池中的线程，线程池中有多个线程时唤醒第一个被冻结的线程。<br/> notifyall(), 唤醒线程池中所有线程。</p>
</blockquote>
<p>注：</p>
<blockquote>
<p>(1)<code>wait(), notify(),notifyall()</code>都用在同步里面，因为这3个函数是对持有锁的线程进行操作，而只有同步才有锁，所以要使用在同步中；<br/> (2)<code>wait(),notify(),notifyall()</code>, 在使用时必须标识它们所操作的线程持有的锁，因为等待和唤醒必须是同一锁下的线程；而锁可以是任意对象，所以这3个方法都是<strong>Object</strong>类中的方法。</p>
</blockquote>
<p>单个消费者生产者例子如下：</p>
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Resource</span><span class="token punctuation">{<!-- --></span>  <span class="token comment">//生产者和消费者都要操作的资源  </span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>  
    <span class="token keyword">private</span> <span class="token keyword">int</span> count<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>  
    <span class="token keyword">private</span> <span class="token keyword">boolean</span> flag<span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">;</span>  
    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>  
        <span class="token keyword">if</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span>  
            <span class="token keyword">try</span><span class="token punctuation">{<!-- --></span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>  
        <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token operator">=</span>name<span class="token operator">+</span><span class="token string">"---"</span><span class="token operator">+</span>count<span class="token operator">++</span><span class="token punctuation">;</span>  
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"...生产者..."</span><span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        flag<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>  
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">out</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>  
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span>  
            <span class="token keyword">try</span><span class="token punctuation">{<!-- --></span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>  
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"...消费者..."</span><span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        flag<span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">;</span>  
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>  
<span class="token keyword">class</span> <span class="token class-name">Producer</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{<!-- --></span>  
    <span class="token keyword">private</span> <span class="token class-name">Resource</span> res<span class="token punctuation">;</span>  
    <span class="token class-name">Producer</span><span class="token punctuation">(</span><span class="token class-name">Resource</span> res<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>  
        <span class="token keyword">this</span><span class="token punctuation">.</span>res<span class="token operator">=</span>res<span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>  
        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>  
            res<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"商品"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>  
<span class="token keyword">class</span> <span class="token class-name">Consumer</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{<!-- --></span>  
    <span class="token keyword">private</span> <span class="token class-name">Resource</span> res<span class="token punctuation">;</span>  
    <span class="token class-name">Consumer</span><span class="token punctuation">(</span><span class="token class-name">Resource</span> res<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>  
        <span class="token keyword">this</span><span class="token punctuation">.</span>res<span class="token operator">=</span>res<span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>  
        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>  
            res<span class="token punctuation">.</span><span class="token function">out</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>  
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProducerConsumerDemo</span><span class="token punctuation">{<!-- --></span>  
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>  
        <span class="token class-name">Resource</span> r<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Resource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token class-name">Producer</span> pro<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token class-name">Consumer</span> con<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Consumer</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token class-name">Thread</span> t1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>pro<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token class-name">Thread</span> t2<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>con<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
        t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span><span class="token comment">//运行结果正常，生产者生产一个商品，紧接着消费者消费一个商品。</span>
</code></pre>
<p>多个消费者生产者例子如下：</p>
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Resource</span><span class="token punctuation">{<!-- --></span>  
        <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>  
        <span class="token keyword">private</span> <span class="token keyword">int</span> count<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>  
        <span class="token keyword">private</span> <span class="token keyword">boolean</span> flag<span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">;</span>  
        <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>  
            <span class="token keyword">while</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token comment">/*原先是if,现在改成while，这样生产者线程从冻结状态醒来时，还会再判断flag.*/</span>  
                <span class="token keyword">try</span><span class="token punctuation">{<!-- --></span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>  
            <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token operator">=</span>name<span class="token operator">+</span><span class="token string">"---"</span><span class="token operator">+</span>count<span class="token operator">++</span><span class="token punctuation">;</span>  
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"...生产者..."</span><span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>  
            flag<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>  
            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*原先是notity(), 现在改成notifyAll(),这样生产者线程生产完一个商品后可以将等待中的消费者线程唤醒，否则只将上面改成while后，可能出现所有生产者和消费者都在wait()的情况。*/</span>  
        <span class="token punctuation">}</span>  
        <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">out</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>  
            <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span> <span class="token comment">/*原先是if,现在改成while，这样消费者线程从冻结状态醒来时，还会再判断flag.*/</span>  
                <span class="token keyword">try</span><span class="token punctuation">{<!-- --></span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>  
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"...消费者..."</span><span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>  
            flag<span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">;</span>  
            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/*原先是notity(), 现在改成notifyAll(),这样消费者线程消费完一个商品后可以将等待中的生产者线程唤醒，否则只将上面改成while后，可能出现所有生产者和消费者都在wait()的情况。*/</span>  
        <span class="token punctuation">}</span>  
    <span class="token punctuation">}</span>  
    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProducerConsumerDemo</span><span class="token punctuation">{<!-- --></span>  
        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>  
            <span class="token class-name">Resource</span> r<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Resource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
            <span class="token class-name">Producer</span> pro<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>  
            <span class="token class-name">Consumer</span> con<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Consumer</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>  
            <span class="token class-name">Thread</span> t1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>pro<span class="token punctuation">)</span><span class="token punctuation">;</span>  
            <span class="token class-name">Thread</span> t2<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>con<span class="token punctuation">)</span><span class="token punctuation">;</span>  
            <span class="token class-name">Thread</span> t3<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>pro<span class="token punctuation">)</span><span class="token punctuation">;</span>  
            <span class="token class-name">Thread</span> t4<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>con<span class="token punctuation">)</span><span class="token punctuation">;</span>  
            t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
            t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
            t3<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
            t4<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
    <span class="token punctuation">}</span>
</code></pre>
<h3><a id="Condition_1220"></a>🎗使用Condition控制线程通信</h3>
<blockquote>
<p>jdk1.5中，提供了多线程的升级解决方案为：<br/> （1）将同步synchronized替换为显式的Lock操作；<br/> （2）将Object类中的wait(), notify(),notifyAll()替换成了Condition对象，该对象可以通过Lock锁对象获取;<br/> （3）一个Lock对象上可以绑定多个Condition对象，这样实现了本方线程只唤醒对方线程，而jdk1.5之前，一个同步只能有一个锁，不同的同步只能用锁来区分，且锁嵌套时容易死锁。</p>
</blockquote>
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Resource</span><span class="token punctuation">{<!-- --></span>  
        <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>  
        <span class="token keyword">private</span> <span class="token keyword">int</span> count<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>  
        <span class="token keyword">private</span> <span class="token keyword">boolean</span> flag<span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">;</span>  
        <span class="token keyword">private</span> <span class="token class-name">Lock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*Lock是一个接口，ReentrantLock是该接口的一个直接子类。*/</span>  
        <span class="token keyword">private</span> <span class="token class-name">Condition</span> condition_pro<span class="token operator">=</span>lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/*创建代表生产者方面的Condition对象*/</span>  
        <span class="token keyword">private</span> <span class="token class-name">Condition</span> condition_con<span class="token operator">=</span>lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/*使用同一个锁，创建代表消费者方面的Condition对象*/</span>  
          
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>  
            lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//锁住此语句与lock.unlock()之间的代码  </span>
            <span class="token keyword">try</span><span class="token punctuation">{<!-- --></span>  
                <span class="token keyword">while</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span>  
                    condition_pro<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//生产者线程在conndition_pro对象上等待  </span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token operator">=</span>name<span class="token operator">+</span><span class="token string">"---"</span><span class="token operator">+</span>count<span class="token operator">++</span><span class="token punctuation">;</span>  
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"...生产者..."</span><span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>  
                flag<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>  
                 condition_con<span class="token punctuation">.</span><span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
            <span class="token punctuation">}</span>  
            <span class="token keyword">finally</span><span class="token punctuation">{<!-- --></span>  
                lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//unlock()要放在finally块中。  </span>
            <span class="token punctuation">}</span>  
        <span class="token punctuation">}</span>  
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">out</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>  
            lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//锁住此语句与lock.unlock()之间的代码  </span>
            <span class="token keyword">try</span><span class="token punctuation">{<!-- --></span>  
                <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span>  
                    condition_con<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//消费者线程在conndition_con对象上等待  </span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"...消费者..."</span><span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>  
            flag<span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">;</span>  
            condition_pro<span class="token punctuation">.</span><span class="token function">signqlAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/*唤醒所有在condition_pro对象下等待的线程，也就是唤醒所有生产者线程*/</span>  
            <span class="token punctuation">}</span>  
            <span class="token keyword">finally</span><span class="token punctuation">{<!-- --></span>  
                lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
            <span class="token punctuation">}</span>  
        <span class="token punctuation">}</span>  
    <span class="token punctuation">}</span>
</code></pre>
<h2><a id="_1265"></a>👕线程池</h2>
<p>优点:</p>
<blockquote>
<p>(1). 降低资源消耗。通过重复利用已创建的线程，降低线程创建和销毁造成的消耗。<br/> (2). 提供响应速度。当任务到达时，任务可以不需要等待线程创建就能立即执行。<br/> (3).提供线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。但是要做到合理地利用线程，必须对其原理了如指掌。<br/> (4).防止服务器过载，形成内存溢出，或者CPU耗尽。</p>
</blockquote>
<p>创建线程池常见的三种方法:</p>
<blockquote>
<p>1、newSingleThreadExecutor：创建一个单线程的线程池。<br/> 2、newFixedThreadPool：创建固定大小的线程池。<br/> 3、newCachedThreadPool：创建一个可缓存的线程池。</p>
</blockquote>
<h3><a id="newSingleThreadExecutor_1277"></a>🎗newSingleThreadExecutor()</h3>
<blockquote>
<p>创建一个单线程的线程池。这个线程只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常而结束，那么会有一个新的线程来代替它。此线程保证所有的任务的执行顺序按照任务的提交顺序执行。</p>
</blockquote>
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SingleThreadExecutorDemo</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">ExecutorService</span> executorService<span class="token operator">=</span><span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">final</span> <span class="token keyword">int</span> no<span class="token operator">=</span>i<span class="token punctuation">;</span>
            <span class="token class-name">Runnable</span> task<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                
                <span class="token annotation punctuation">@Override</span>
                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token keyword">try</span><span class="token punctuation">{<!-- --></span>
                        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"into "</span><span class="token operator">+</span>no<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000L</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"end "</span><span class="token operator">+</span>no<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span><span class="token punctuation">;</span>
            <span class="token comment">//交由线程池处理任务</span>
            executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        executorService<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"main thread have terminate"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>   
<span class="token punctuation">}</span>
</code></pre>
<h3><a id="newCachedThreadPool_1307"></a>🎗newCachedThreadPool的使用</h3>
<blockquote>
<p>创建一个缓冲池大小可根据需要伸缩的线程池，但是在以前构造的线程可用时将重用它们。对于执行很多短期异步任务而言，这些线程池通常可提供程序性能。调用execute将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有60s未被使用的线程。因此，长时间保持空闲的线程池不会使用任何资源。</p>
</blockquote>
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CachedThreadPoolDemo</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">ExecutorService</span> executorService<span class="token operator">=</span><span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">20</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">final</span> <span class="token keyword">int</span> no<span class="token operator">=</span>i<span class="token punctuation">;</span>
            <span class="token class-name">Runnable</span> task<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token annotation punctuation">@Override</span>
                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token keyword">try</span><span class="token punctuation">{<!-- --></span>
                        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"into "</span><span class="token operator">+</span>no<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10001L</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"end "</span><span class="token operator">+</span>no<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span><span class="token punctuation">;</span>
            executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"main thread have terminate"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        executorService<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>   
</code></pre>
<h3><a id="newFixedThreadPool_1335"></a>🎗newFixedThreadPool的使用</h3>
<blockquote>
<p>创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。在任意点，在大多数nThreads线程会处于处理任务的活动状态。如果在所有线程处于活动状态时提交附加任务，则在有可用线程之前，附加任务将在队列中等待。如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新的线程将代替它执行后续任务（如果需要）。在某个线程被显示关闭之前，池中的线程将一直存在。</p>
</blockquote>
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> newFixedThreadPoolDemo <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">ExecutorService</span> executorService<span class="token operator">=</span><span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">20</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">final</span> <span class="token keyword">int</span> no<span class="token operator">=</span>i<span class="token punctuation">;</span>
            <span class="token class-name">Runnable</span> task<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token annotation punctuation">@Override</span>
                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token keyword">try</span><span class="token punctuation">{<!-- --></span>
                        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"into "</span><span class="token operator">+</span>no<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000L</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"end "</span><span class="token operator">+</span>no<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span><span class="token punctuation">;</span>
            executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"main thread have terminate"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        executorService<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<h2><a id="_1364"></a>🧵线程五种状态</h2>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/ab8f3c8914ff418baaeea8ca53cdee03.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA55m95aSn6ZSF,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<blockquote>
<p>1.New (新创建)<br/> 　　当用new操作符创建一个线程时，如new Thread®，该线程还没有开始运行。这意外这它的状态是new。此时程序还没有开始运行线程中的代码，在线程运行之前还有一些基础工作要做。<br/> 2.Runnable (可运行/就绪)<br/> 　　一旦处于新状态的线程调用start方法(如图中的1所示)，线程就处于Runnbale状态。<br/> 　　处于Runnable状态的线程还未运行run()方法的代码，只有在获得CPU时间片才开始运行。<br/> 3.Running (运行中)<br/> 　　当线程获得CPU时间片，线程就进入Running状态(如图中的2所示)。<br/> 处于Running状态的线程有可能在运行中CPU时间片用完，而run方法没运行完，线程就又进入Runnable状态。<br/> 　　通常情况下，运行中的线程一直处于Running与Runnable交替转换的过程中。<br/> 4.Blocked (等待/阻塞/睡眠)<br/> 　　当线程在Running状态中，遇到阻塞等待锁、等待用户输入、调用sleep()方法、调用join等待其他线程情况，会导致线程进入阻塞状态(Blocked)。<br/> 　　处于阻塞状态的线程，在阻塞等待结束之后，会进入Runnable状态，等等获得CPU时间片继续运行程序。<br/> 5.Dead (死亡)<br/> 　　当线程运行完run方法，直接进入死亡状态Dead 。</p>
</blockquote>
<h1><a id="Java_1382"></a>🎄Java虚拟机</h1>
<p>Jvm相关资料:<br/> 链接：<a href="https://pan.baidu.com/s/1jc4A9Lq3RDchq3ooMgDnIg">Jvm面试资料</a><br/> 提取码：u5i9</p>
<p>废话不说 直接看大佬操作:<a href="https://blog.csdn.net/qq_41701956/article/details/100074023">jvm</a></p>
<h1><a id="MySQL_1390"></a>🎄MySQL</h1>
<p>MySQL相关资料:<br/> 链接：<a href="https://pan.baidu.com/s/15EsjjZRNqQ6Nh8lDt_Axrw">MySQL</a><br/> 提取码：1jbm<br/> 详情见博主之前文章:<a href="https://blog.csdn.net/weixin_45735355/article/details/119672412?spm=1001.2014.3001.5501">MySQL入门到毕业</a></p>
<h1><a id="Spring_1396"></a>🎄Spring相关知识点</h1>
<h2><a id="Bean_1397"></a>🎨Bean生命周期</h2>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/806c66cd289f48a9900494aaa3d1f045.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA55m95aSn6ZSF,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<blockquote>
<p>面试中经常问到的bean的生命周期，先看绿色的部分，bean的创建过程：<br/> 第1步：调用bean的构造方法创建bean；<br/> 第2步：通过反射调用setter方法进行属性的依赖注入；<br/> 第3步：如果实现BeanNameAware接口的话，会设置bean的name；<br/> 第4步：如果实现了BeanFactoryAware，会把bean factory设置给bean；<br/> 第5步：如果实现了ApplicationContextAware，会给bean设置ApplictionContext；<br/> 第6步：如果实现了BeanPostProcessor接口，则执行前置处理方法；<br/> 第7步：实现了InitializingBean接口的话，执行afterPropertiesSet方法；<br/> 第8步：执行自定义的init方法；<br/> 第9步：执行BeanPostProcessor接口的后置处理方法。<br/> 这时，就完成了bean的创建过程。<br/> 在使用完bean需要销毁时，会先执行DisposableBean接口的destroy方法，然后在执行自定义的destroy方法。</p>
</blockquote>
<h2><a id="Spring_1412"></a>🎪Spring应用</h2>
<h3><a id="_1413"></a>🎗常用注解</h3>
<p>a.类型类注释：</p>
<blockquote>
<p>类型类注释包括<code>controller</code>、<code>service</code>等，需要重点了解<br/> 其中component和bean注解的区别如下：<br/> <code>@Component</code>注解在类上使用表明这个类是个组件类，需要Spring为这个类创建bean。<br/> <code>@Bean</code>注解使用在方法上，告诉Spring这个方法将会返回一个Bean对象，需要把返回的对象注册到Spring的应用上下文中。</p>
</blockquote>
<p>b.设置类注解</p>
<blockquote>
<p>重点了解<code>@Autowire</code>和<code>@Qualifier</code>以及<code>bytype、byname</code>等不同的自动装配机制。</p>
</blockquote>
<p>c.web类注解</p>
<blockquote>
<p>主要以了解为主，关注<code>@RequestMapping、@GetMapping、@PostMapping</code>等路径匹配注解，以及<code>@PathVariable、@RequestParam</code> 等参数获取注解。</p>
</blockquote>
<p>d.功能类注解</p>
<blockquote>
<p>包括<code>@ImportResource</code>引用配置、<code>@ComponentScan</code>注解自动扫描、<code>@Transactional</code>事务注解等等，这里不一一介绍了。</p>
</blockquote>
<h2><a id="Spring_1433"></a>🎠Spring优点</h2>
<blockquote>
<p>（1）spring属于低侵入式设计，代码的污染极低；<br/> （2）spring的DI机制将对象之间的依赖关系交由框架处理，减低组件的耦合性；<br/> （3）Spring提供了AOP技术，支持将一些通用任务，如安全、事务、日志、权限等进行集中式管理，从而提供更好的复用。<br/> （4）spring对于主流的应用框架提供了集成支持。</p>
</blockquote>
<h2><a id="SpringIOC_1439"></a>🎀Spring中IOC理解</h2>
<blockquote>
<p>（1）<strong>IOC就是控制反转，指创建对象的控制权转移给Spring框架进行管理，并由Spring根据配置文件去创建实例和管理各个实例之间的依赖关系</strong>，对象与对象之间松散耦合，也利于功能的复用。DI依赖注入，和控制反转是同一个概念的不同角度的描述，即 应用程序在运行时依赖IoC容器来动态注入对象需要的外部依赖。<br/> （2）最直观的表达就是，以前创建对象的主动权和时机都是由自己把控的，IOC让对象的创建不用去new了，可以由spring自动生产，使用java的反射机制，根据配置文件在运行时动态的去创建对象以及管理对象，并调用对象的方法的。<br/> （3）Spring的IOC有三种注入方式 ：构造器注入、setter方法注入、根据注解注入。</p>
</blockquote>
<h2><a id="SpringAOP_1444"></a>🎇Spring中AOP理解</h2>
<blockquote>
<p>AOP，一般称为面向切面，作为面向对象的一种补充，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”（Aspect），减少系统中的重复代码，降低了模块间的耦合度，提高系统的可维护性。可用于权限认证、日志、事务处理。</p>
</blockquote>
<p>AOP实现的关键在于 代理模式，AOP代理主要分为静态代理和动态代理。静态代理的代表为AspectJ；动态代理则以Spring AOP为代表。</p>
<blockquote>
<p>（1）AspectJ是<strong>静态代理，也称为编译时增强</strong>，AOP框架会在编译阶段生成<strong>AOP代理类</strong>，并将AspectJ(切面)织入到<strong>Java字节码中</strong>，运行的时候就是增强之后的AOP对象。<br/> （2）Spring AOP使用的<strong>动态代理</strong>，所谓的动态代理就是说AOP框架<strong>不会去修改字节码</strong>，而是每次运行时在内存中临时为方法<strong>生成一个AOP对象</strong>，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。</p>
</blockquote>
<p>Spring AOP中的动态代理主要有两种方式，JDK动态代理和CGLIB动态代理：</p>
<blockquote>
<p>① JDK动态代理只提供接口的代理，不支持类的代理，要求被代理类实现接口。JDK动态代理的核心是<strong>InvocationHandler接口和Proxy类</strong>，在获取代理对象时，使用Proxy类来动态创建目标类的代理类（即最终真正的代理类，这个类继承自Proxy并实现了我们定义的接口），当代理对象调用真实对象的方法时， InvocationHandler 通过<code>invoke()</code>方法反射来调用目标类中的代码，动态地将横切逻辑和业务编织在一起；<br/> InvocationHandler 的 invoke(Object proxy,Method method,Object[] args)：proxy是最终生成的代理对象; method 是被代理目标实例的某个具体方法; args 是被代理目标实例某个方法的具体入参, 在方法反射调用时使用。<br/> ② 如果被代理类没有实现接口，那么<strong>Spring AOP</strong>会选择使用<strong>CGLIB</strong>来动态代理目标类。CGLIB（Code Generation Library），是一个<strong>代码生成的类库</strong>，可以在运行时动态的生成指定类的一个<strong>子类对象</strong>，并<strong>覆盖其中特定方法并添加增强代码</strong>，从而实现AOP。CGLIB是<strong>通过继承的方式做的动态代理</strong>，因此如果某个类被标记为<strong>final</strong>，那么它是<strong>无法使用CGLIB</strong>做动态代理的。</p>
</blockquote>
<blockquote>
<p>（3）静态代理与动态代理区别在于生成AOP代理对象的时机不同，相对来说AspectJ的静态代理方式具有更好的性能，但是AspectJ需要特定的编译器进行处理，而Spring AOP则无需特定的编译器处理。</p>
</blockquote>
<p>IoC让相互协作的组件保持松散的耦合，而AOP编程允许你把遍布于应用各层的功能分离出来形成可重用的功能组件。</p>
<h2><a id="Spring_1462"></a>🎭Spring配置方式</h2>
<blockquote>
<p><strong>基于XML的配置:基于注解的配置：</strong> Spring在2.5版本以后开始支持用注解的方式来配置依赖注入。可以用注解的方式来替代XML方式的bean描述，可以将bean描述转移到组件类的内部，只需要在相关类上、方法上或者字段声明上使用注解即可。注解注入将会被容器在XML注入之前被处理，所以后者会覆盖掉前者对于同一个属性的处理结果</p>
</blockquote>
<blockquote>
<p><strong>基于Java的配置：</strong> Spring对Java配置的支持是由<code>@Configuration</code>注解和<code>@Bean</code>注解来实现的。由<code>@Bean</code>注解的方法将会实例化、配置和初始化一个新对象，这个对象将由Spring的IoC容器来管理。@Bean声明所起到的作用与元素类似。被<code>@Configuration</code>所注解的类则表示这个类的主要目的是作为bean定义的资源。被<code>@Configuration</code>声明的类可以通过在同一个类的内部调用<code>@bean</code>方法来设置嵌入bean的依赖关系。</p>
</blockquote>
<h2><a id="Spring_1467"></a>🎢Spring中的设计模式</h2>
<blockquote>
<p>1.代理模式—在AOP和remoting中被用的比较多。<br/> 2.单例模式—在spring配置文件中定义的bean默认为单例模式。<br/> 模板方法—用来解决代码重复的问题 比如. RestTemplate, JmsTemplate, JpaTemplate。 前端控制器—Srping提供了DispatcherServlet来对请求进行分发。 视图帮助(View Helper )—Spring提供了一系列的JSP标签，高效宏来辅助将分散的代码整合在视图里。 依赖注入—贯穿于BeanFactory / ApplicationContext接口的核心理念。<br/> 3.工厂模式—BeanFactory用来创建对象的实例。<br/> 4.Builder模式- 自定义配置文件的解析bean是时采用builder模式，一步一步地构建一个beanDefinition<br/> 5.策略模式：Spring 中策略模式使用有多个地方，如 Bean 定义对象的创建以及代理对象的创建等。这里主要看一下代理对象创建的策略模式的实现。 前面已经了解 Spring 的代理方式有两个 Jdk 动态代理和 CGLIB 代理。这两个代理方式的使用正是使用了策略模式。</p>
</blockquote>
<h2><a id="SpringMVC_1474"></a>🧨SpringMVC执行流程</h2>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/3853feca09514f57b4ad56892bf38945.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA55m95aSn6ZSF,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<blockquote>
<p>1.DispatcherServlet接收到一个URL请求<br/> 2.根据URL到HandlerMapping中查找处理器<br/> 3.返回给DispatcherServlet一个Handler执行链<br/> 4.DispatcherServlet请求HandlerAdapter适配器，找到对应的Handler<br/> 5.执行Handler即Controller的相关业务逻辑<br/> 6.Handler返回ModelAndView到HandlerAdapter<br/> 7.HandlerAdapter返回ModelAndView到DispatcherServlet<br/> 8.DispatcherServlet请求ViewRessolver视图解析器，找到对应的View根据ModelAndView生成视图对象<br/> 9.DispatcherServlet返回View</p>
</blockquote>
<p>深入学习可查看此文:<a href="https://blog.csdn.net/a745233700/article/details/80959716">Spring常见面试题总结（超详细回答）</a></p>
<h1><a id="_1488"></a>🎄计算机网络</h1>
<p>计算机网络相关资料:<br/> 链接：<a href="https://pan.baidu.com/s/1x9gqS6c-Ck9rEHpdDPCoyA">计算机网络</a><br/> 提取码：1wq1</p>
<h2><a id="OSITCPIP_1494"></a>🎍OSI，TCP/IP，五层协议的体系结构，以及各层协议</h2>
<blockquote>
<p>OSI分层 （7层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。<br/> TCP/IP分层（4层）：网络接口层、 网际层、运输层、 应用层。<br/> 五层协议 （5层）：物理层、数据链路层、网络层、运输层、 应用层。<br/> 每一层的协议如下：<br/> 物理层：RJ45、CLOCK、IEEE802.3 （中继器，集线器，网关）<br/> 数据链路：PPP、FR、HDLC、VLAN、MAC （网桥，交换机）<br/> 网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器）<br/> 传输层：TCP、UDP、SPX<br/> 会话层：NFS、SQL、NETBIOS、RPC<br/> 表示层：JPEG、MPEG、ASII<br/> 应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS</p>
</blockquote>
<p>每层作用:</p>
<blockquote>
<p>物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）<br/> 数据链路层：将比特组装成帧和点到点的传递（帧Frame）<br/> 网络层：负责数据包从源到宿的传递和网际互连（包PackeT）<br/> 传输层：提供端到端的可靠报文传递和错误恢复（段Segment）<br/> 会话层：建立、管理和终止会话（会话协议数据单元SPDU）<br/> 表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）<br/> 应用层：允许访问OSI环境的手段（应用协议数据单元APDU）</p>
</blockquote>
<h2><a id="IP_1516"></a>🥽IP地址的分类</h2>
<blockquote>
<p>A类地址：以0开头， 第一个字节范围：0~127（1.0.0.0 - 126.255.255.255）；<br/> B类地址：以10开头， 第一个字节范围：128~191（128.0.0.0 - 191.255.255.255）；<br/> C类地址：以110开头， 第一个字节范围：192~223（192.0.0.0 - 223.255.255.255）；<br/> 10.0.0.0—10.255.255.255， 172.16.0.0—172.31.255.255， 192.168.0.0—192.168.255.255。（Internet上保留地址用于内部）</p>
</blockquote>
<h2><a id="_1522"></a>🥼各种协议</h2>
<blockquote>
<p>ICMP协议：因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。<br/> TFTP协议：是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。<br/> HTTP协议：超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。<br/> DHCP协议：动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段。<br/> NAT协议：网络地址转换属接入广域网(WAN)技术，是一种将私有（保留）地址转化为合法IP地址的转换技术，<br/> DHCP协议：一个局域网的网络协议，使用UDP协议工作，用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。<br/> RARP协议 ：RARP是逆地址解析协议，作用是完成硬件地址到IP地址的映射，主要用于无盘工作站，因为给无盘工作站配置的IP地址不能保存。工作流程：在网络中配置一台RARP服务器，里面保存着IP地址和MAC地址的映射关系，当无盘工作站启动后，就封装一个RARP数据包，里面有其MAC地址，然后广播到网络上去，当服务器收到请求包后，就查找对应的MAC地址的IP地址装入响应报文中发回给请求者。因为需要广播请求报文，因此RARP只能用于具有广播能力的网络。</p>
</blockquote>
<h2><a id="TCP_1531"></a>👓TCP三次握手和四次挥手的全过程</h2>
<p>三次握手：</p>
<blockquote>
<p>第一次握手：客户端发送syn包(syn=x)到服务器，并进入SYN_SEND状态，等待服务器确认；<br/> 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态；<br/> 第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。</p>
</blockquote>
<blockquote>
<p>握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。</p>
</blockquote>
<p>四次挥手:<br/> 与建立连接的“三次握手”类似，断开一个TCP连接则需要“四次挥手”。</p>
<blockquote>
<p>第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。<br/> 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。<br/> 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。<br/> 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。</p>
</blockquote>
<h1><a id="MQ_1547"></a>🎄MQ消息队列</h1>
<p>博主用的较多的是RabbitMq 可见此文:<a href="https://blog.csdn.net/weixin_45735355/article/details/118700568?spm=1001.2014.3001.5501">消息队列—RabbitMQ深入研究(含Springboot+RabbitMQ整合)</a></p>
<h2><a id="MQ_1550"></a>🧵MQ应用(异步解耦削峰)</h2>
<h3><a id="_1551"></a>🎗异步提速</h3>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/ce0351f0d87548e19972ec82d926c880.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA55m95aSn6ZSF,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<h3><a id="_1553"></a>🎗解耦</h3>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/91da2dc5568b4381ba819f30a5ff5e74.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA55m95aSn6ZSF,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<h3><a id="_1556"></a>🎗削峰填谷</h3>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/06c7efe0b8b74c6aaeefaf3e50e618cd.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA55m95aSn6ZSF,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<h2><a id="MQ_1560"></a>🎊MQ选型</h2>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/4a1349c4d19f42cbbb54dc96877d6a12.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA55m95aSn6ZSF,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<h2><a id="MQ_1562"></a>🎁MQ消息队列相关资料分享</h2>
<p>链接：<a href="https://pan.baidu.com/s/1NMsH_j7gmpjvAqeSecLt_A">MQ相关资料</a><br/> 提取码：u11g</p>
<h1><a id="Redis_1565"></a>🎄Redis</h1>
<h2><a id="_1566"></a>👟缓存击穿、缓存穿透、缓存雪崩</h2>
<p><a href="https://blog.csdn.net/weixin_45735355/article/details/118928897?spm=1001.2014.3001.5501">三张图带你吃透缓存击穿、雪崩、穿透（超详细）</a></p>
<h2><a id="Redis_1569"></a>🏀使用Redis做缓存的优点</h2>
<p>高性能：</p>
<blockquote>
<p>假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在数缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可</p>
</blockquote>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/2c2b427299514b1199a0808cd9f657ad.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA55m95aSn6ZSF,size_20,color_FFFFFF,t_70,g_se,x_16"/><br/> 高并发：</p>
<blockquote>
<p>直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库</p>
</blockquote>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/53edf87a6b0b47208746efd068d12470.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA55m95aSn6ZSF,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<h2><a id="redis__1582"></a>⛳redis 常见数据结构以及使用场景分析</h2>
<ol><li>String</li></ol>
<blockquote>
<p>常用命令: <code>set,get,decr,incr,mget</code> 等。<br/> String数据结构是简单的key-value类型，value其实不仅可以是String，也可以是数字。 常规key-value缓存应用；</p>
</blockquote>
<p>2.Hash</p>
<blockquote>
<p>常用命令： <code>hget,hset,hgetall</code> 等。<br/> Hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值。 比如我们可以Hash数据结构来存储用户信息，商品信息等等。比如下面我就用 hash 类型存放了我本人的一些信息：</p>
</blockquote>
<pre><code class="prism language-java">key<span class="token operator">=</span><span class="token class-name">JavaUser293847</span>
value<span class="token operator">=</span><span class="token punctuation">{<!-- --></span>
  <span class="token string">"id"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  <span class="token string">"name"</span><span class="token operator">:</span> <span class="token string">"SnailClimb"</span><span class="token punctuation">,</span>
  <span class="token string">"age"</span><span class="token operator">:</span> <span class="token number">22</span><span class="token punctuation">,</span>
  <span class="token string">"location"</span><span class="token operator">:</span> <span class="token string">"Wuhan, Hubei"</span>
<span class="token punctuation">}</span>
</code></pre>
<p>3.List</p>
<blockquote>
<p>常用命令: <code>lpush,rpush,lpop,rpop,lrange</code>等<br/> list 就是链表，Redis list 的应用场景非常多，也是Redis最重要的数据结构之一，比如微博的关注列表，粉丝列表，消息列表等功能都可以用Redis的 list 结构来实现。<br/> Redis list 的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。<br/> 另外可以通过 lrange 命令，就是从某个元素开始读取多少个元素，可以基于 list 实现分页查询，这个很棒的一个功能，基于 redis 实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西（一页一页的往下走），性能高。</p>
</blockquote>
<p>4.Set</p>
<blockquote>
<p>常用命令： <code>sadd,spop,smembers,sunion</code> 等<br/> set 对外提供的功能与list类似是一个列表的功能，特殊之处在于 set 是可以自动排重的。<br/> 当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。可以基于 set 轻易实现交集、并集、差集的操作。</p>
</blockquote>
<p>5.Sorted Set</p>
<blockquote>
<p>常用命令： <code>zadd,zrange,zrem,zcard</code>等<br/> 和set相比，sorted set增加了一个权重参数score，使得集合中的元素能够按score进行有序排列。</p>
</blockquote>
<blockquote>
<p>举例： 在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息，适合使用 Redis 中的 SortedSet 结构进行存储。</p>
</blockquote>
<h2><a id="Redis_1619"></a>🥅Redis主从复制与哨兵机制</h2>
<p><a href="https://www.jianshu.com/p/40212051ccc9">Redis|主从复制与哨兵机制</a></p>
<h1><a id="Nginx_1622"></a>🎄Nginx</h1>
<h2><a id="Nginx_1623"></a>🎁Nginx基本配置详解</h2>
<p><a href="https://www.nginx.cn/76.html">nginx基本配置与参数说明</a></p>
<pre><code class="prism language-java">##
# 全局配置
##

user www<span class="token operator">-</span>data<span class="token punctuation">;</span>             ## 配置 worker 进程的用户和组
worker_processes auto<span class="token punctuation">;</span>     ## 配置 worker 进程启动的数量，建议配置为 CPU 核心数
error_log logs<span class="token operator">/</span>error<span class="token punctuation">.</span>log<span class="token punctuation">;</span>  ## 全局错误日志
pid <span class="token operator">/</span>run<span class="token operator">/</span>nginx<span class="token punctuation">.</span>pid<span class="token punctuation">;</span>        ## 设置记录主进程 ID 的文件
worker_rlimit_nofile <span class="token number">8192</span><span class="token punctuation">;</span> ## 配置一个工作进程能够接受并发连接的最大数

##
# 工作模式及连接数上限
##
events <span class="token punctuation">{<!-- --></span>
    # epoll 是多路复用 IO（<span class="token class-name">I</span><span class="token operator">/</span><span class="token class-name">O</span> <span class="token class-name">Multiplexing</span>）中的一种方式，
    # 仅用于 <span class="token class-name">Linux</span> <span class="token number">2.6</span> 以上内核，可以大大提高 <span class="token class-name">Nginx</span> 性能
    use epoll
        
    # 单个后台 worker process 进程的最大并发链接数
    # 并发总数 max_clients <span class="token operator">=</span> worker_professes <span class="token operator">*</span> worker_connections
    worker_connections <span class="token number">4096</span><span class="token punctuation">;</span>  ## <span class="token class-name">Defaule</span><span class="token operator">:</span> <span class="token number">1024</span>
    # multi_accept on<span class="token punctuation">;</span>  ## 指明 worker 进程立刻接受新的连接
<span class="token punctuation">}</span>

##
# http 模块
##

http <span class="token punctuation">{<!-- --></span>

    ##
    # <span class="token class-name">Basic</span> <span class="token class-name">Settings</span>
    ##
    
    #sendfile 指令指定 nginx 是否调用 sendfile 函数（zero copy 方式）来输出文件，
    #对于普通应用，必须设为 on<span class="token punctuation">,</span>
    #如果用来进行下载等应用磁盘 IO 重负载应用，可设置为 off，
    #以平衡磁盘与网络 <span class="token class-name">I</span><span class="token operator">/</span><span class="token class-name">O</span> 处理速度，降低系统的 uptime<span class="token punctuation">.</span>
    sendfile on<span class="token punctuation">;</span>
    tcp_nopush on<span class="token punctuation">;</span>
    tcp_nodelay on<span class="token punctuation">;</span>
    keepalive_timeout <span class="token number">65</span><span class="token punctuation">;</span>      ## 连接超时时间
    types_hash_max_size <span class="token number">2048</span><span class="token punctuation">;</span>  ## 指定散列类型表的最大大小
    # server_tokens off<span class="token punctuation">;</span>

    # server_names_hash_bucket_size <span class="token number">64</span><span class="token punctuation">;</span>  # <span class="token keyword">this</span> seems <span class="token keyword">to</span> <span class="token namespace">be</span> required <span class="token keyword">for</span> some vhosts
    # server_name_in_redirect off<span class="token punctuation">;</span>
    
    include <span class="token operator">/</span>etc<span class="token operator">/</span>nginx<span class="token operator">/</span>mime<span class="token punctuation">.</span>types<span class="token punctuation">;</span>  ## 设定 mine 类型
    default_type application<span class="token operator">/</span>octet<span class="token operator">-</span>stream<span class="token punctuation">;</span>
   
    # 设定请求缓冲
    client_header_buffer_size    <span class="token number">128</span>k<span class="token punctuation">;</span> # 指定客户端请求头缓存大小，当请求头大于 <span class="token number">1</span>KB 时会用到该项
    large_client_header_buffers  <span class="token number">4</span> <span class="token number">128</span>k<span class="token punctuation">;</span> # 最大数量和最大客户端请求头的大小
    
    ##
    # SSL <span class="token class-name">Settings</span>
    ##
    
    # 启用所有协议，禁用已废弃的不安全的SSL <span class="token number">2</span> 和SSL <span class="token number">3</span>
    ssl_protocols <span class="token class-name">TLSv1</span> <span class="token class-name">TLSv1</span><span class="token number">.1</span> <span class="token class-name">TLSv1</span><span class="token number">.2</span><span class="token punctuation">;</span> # <span class="token class-name">Dropping</span> <span class="token class-name">SSLv3</span><span class="token punctuation">,</span> ref<span class="token operator">:</span> POODLE
    # 让服务器选择要使用的算法套件
    ssl_prefer_server_ciphers on<span class="token punctuation">;</span>

    ##
    # <span class="token class-name">Logging</span> <span class="token class-name">Settings</span>
    ##

    access_log <span class="token operator">/</span><span class="token keyword">var</span><span class="token operator">/</span>log<span class="token operator">/</span>nginx<span class="token operator">/</span>access<span class="token punctuation">.</span>log<span class="token punctuation">;</span>  ## 访问日志
    error_log <span class="token operator">/</span><span class="token keyword">var</span><span class="token operator">/</span>log<span class="token operator">/</span>nginx<span class="token operator">/</span>error<span class="token punctuation">.</span>log<span class="token punctuation">;</span>    ## 错误日志

    ##
    # <span class="token class-name">Gzip</span> <span class="token class-name">Settings</span>
    ##

    gzip on<span class="token punctuation">;</span>
    gzip_disable <span class="token string">"msie6"</span><span class="token punctuation">;</span>

    # gzip_vary on<span class="token punctuation">;</span>
    # gzip_proxied any<span class="token punctuation">;</span>
    # gzip_comp_level <span class="token number">6</span><span class="token punctuation">;</span>
    # gzip_buffers <span class="token number">16</span> <span class="token number">8</span>k<span class="token punctuation">;</span>
    # gzip_http_version <span class="token number">1.1</span><span class="token punctuation">;</span>
    # gzip_types text<span class="token operator">/</span>plain text<span class="token operator">/</span>css application<span class="token operator">/</span>json application<span class="token operator">/</span>javascript text<span class="token operator">/</span>xml application<span class="token operator">/</span>xml application<span class="token operator">/</span>xml<span class="token operator">+</span>rss text<span class="token operator">/</span>javascript<span class="token punctuation">;</span>

    ##
    # <span class="token class-name">Virtual</span> <span class="token class-name">Host</span> <span class="token class-name">Configs</span>
    ##

    include <span class="token operator">/</span>etc<span class="token operator">/</span>nginx<span class="token operator">/</span>conf<span class="token punctuation">.</span>d<span class="token comment">/*.conf;   # 这个文件夹默认是空的
    include /etc/nginx/sites-enabled/*; # 开启的 Server 服务配置

}

##
# mail 模块
##
        
mail {
    # See sample authentication script at:
    # http://wiki.nginx.org/ImapAuthenticateWithApachePhpScript

    # auth_http localhost/auth.php;
    # pop3_capabilities "TOP" "USER";
    # imap_capabilities "IMAP4rev1" "UIDPLUS";

    server {
        listen     localhost:110;
        protocol   pop3;
        proxy      on;
    }

    server {
        listen     localhost:143;
        protocol   imap;
        proxy      on;
    }
}
</span></code></pre>
<h2><a id="Nginx_1747"></a>🪁Nginx常用命令</h2>
<pre><code class="prism language-java">## 查看 <span class="token class-name">Nginx</span> 程序文件目录<span class="token operator">:</span><span class="token operator">/</span>usr<span class="token operator">/</span>sbin<span class="token operator">/</span>nginx
$ ps  <span class="token operator">-</span>ef <span class="token operator">|</span> grep nginx

## 查看 nginx<span class="token punctuation">.</span>conf 配置文件目录<span class="token operator">:</span><span class="token operator">/</span>etc<span class="token operator">/</span>nginx<span class="token operator">/</span>nginx<span class="token punctuation">.</span>conf
$ nginx <span class="token operator">-</span>t                 
$ vim <span class="token operator">/</span>etc<span class="token operator">/</span>nginx<span class="token operator">/</span>nginx<span class="token punctuation">.</span>conf

## 配置文件目录：<span class="token operator">/</span>etc<span class="token operator">/</span>nginx

## 虚拟主机配置文件目录：<span class="token operator">/</span>etc<span class="token operator">/</span>nginx<span class="token operator">/</span>sites<span class="token operator">-</span>available<span class="token operator">/</span>
## 虚拟主机文件夹目录：<span class="token operator">/</span><span class="token keyword">var</span><span class="token operator">/</span>www<span class="token operator">/</span>，详情可在 <span class="token operator">/</span>etc<span class="token operator">/</span>nginx<span class="token operator">/</span>sites<span class="token operator">-</span>available<span class="token operator">/</span> 中配置
## 默认网页文件目录：<span class="token operator">/</span>usr<span class="token operator">/</span>share<span class="token operator">/</span>nginx<span class="token operator">/</span>html

## 测试配置文件，只检查配置文件是否存在语法错误
$ nginx <span class="token operator">-</span>t <span class="token operator">-</span>c <span class="token operator">&lt;</span>path<span class="token operator">-</span><span class="token keyword">to</span><span class="token operator">-</span>nginx<span class="token punctuation">.</span>conf<span class="token operator">&gt;</span>
$ sudo nginx <span class="token operator">-</span>t <span class="token operator">-</span>c <span class="token operator">/</span>etc<span class="token operator">/</span>nginx<span class="token operator">/</span>nginx<span class="token punctuation">.</span>conf

## 启动 <span class="token class-name">Nginx</span> 服务
$ nginx 安装目录 <span class="token operator">-</span>c <span class="token operator">&lt;</span>path<span class="token operator">-</span><span class="token keyword">to</span><span class="token operator">-</span>nginx<span class="token punctuation">.</span>conf<span class="token operator">&gt;</span>
$ sudo <span class="token operator">/</span>etc<span class="token operator">/</span>init<span class="token punctuation">.</span>d<span class="token operator">/</span>nginx start

## 停止 <span class="token class-name">Nginx</span> 服务
$ sudo <span class="token operator">/</span>usr<span class="token operator">/</span>sbin<span class="token operator">/</span>nginx <span class="token operator">-</span>s stop 

## 重启 <span class="token class-name">Nginx</span> 
$ sudo <span class="token operator">/</span>usr<span class="token operator">/</span>sbin<span class="token operator">/</span>nginx <span class="token operator">-</span>s reload  # <span class="token number">0.8</span> 版本之后的方法
$ kill <span class="token operator">-</span>HUP pid     # 向 master 进程发送信号从容地重启 <span class="token class-name">Nginx</span>，即服务不中断

$ sudo service nginx start
$ sudo service nginx stop
$ sudo service nginx restart
</code></pre>
<h2><a id="Nginx_1784"></a>🎨Nginx正向代理</h2>
<blockquote>
<p>正向代理：内网服务器主动去请求外网的服务的一种行为<br/> 光看概念，可能有读者还是搞不明白：什么叫做“正向”，什么叫做“代理”，我们分别来理解一下这两个名词。<br/> 正向：相同的或一致的方向<br/> 代理：自己做不了的事情或者自己不打算做的事情，委托或依靠别人来完成。<br/> 借助解释，回归到nginx的概念，正向代理其实就是说客户端无法主动或者不打算完成主动去向某服务器发起请求，而是委托了nginx代理服务器去向服务器发起请求，并且获得处理结果，返回给客户端。<br/> 从下图可以看出：客户端向目标服务器发起的请求，是由代理服务器代替它向目标主机发起，得到结果之后，通过代理服务器返回给客户端。</p>
</blockquote>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/1f64b6685be844329349f40bc4eb4956.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA55m95aSn6ZSF,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<p>正向代理的配置:</p>
<pre><code class="prism language-java">server <span class="token punctuation">{<!-- --></span> 
#指定DNS服务器IP地址   
resolver <span class="token number">114.114</span><span class="token number">.114</span><span class="token number">.114</span><span class="token punctuation">;</span>    
#指定代理端口     
listen <span class="token number">8080</span><span class="token punctuation">;</span>   
location <span class="token operator">/</span> <span class="token punctuation">{<!-- --></span> 
#设定代理服务器的协议和地址（固定不变）     
proxy_pass http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>$http_host$request_uri<span class="token punctuation">;</span>  
<span class="token punctuation">}</span>   
<span class="token punctuation">}</span>
</code></pre>
<p>这样就可以做到内网中端口为8080的服务器主动请求到1.2.13.4的主机上，如在Linux下可以：</p>
<pre><code class="prism language-java">curl <span class="token operator">--</span>proxy proxy_server<span class="token operator">:</span><span class="token number">8080</span> http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>taobao<span class="token punctuation">.</span>com<span class="token operator">/</span> 
</code></pre>
<p>正向代理的关键配置：</p>
<blockquote>
<p>1.resolver：DNS服务器IP地址<br/> 2.listen：主动发起请求的内网服务器端口<br/> 3.proxy_pass：代理服务器的协议和地址</p>
</blockquote>
<h2><a id="Nginx_1822"></a>🥏Nginx反向代理</h2>
<blockquote>
<p>反向代理：reverse proxy，是指用代理服务器来接受客户端发来的请求，然后将请求转发给内网中的上游服务器，上游服务器处理完之后，把结果通过nginx返回给客户端。<br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/6a1f7cdc16834cd9983aa7f96f9304c4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA55m95aSn6ZSF,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
</blockquote>
<blockquote>
<p>举个栗子：一个服务器的80端口只有一个，而服务器中可能有多个项目，如果A项目是端口是8081，B项目是8082，C项目是8083，假设指向该服务器的域名为www.xxx.com，此时访问B项目是www.xxx.com:8082，以此类推其它项目的URL也是要加上一个端口号，这样就很不美观了，这时我们把80端口给nginx服务器，给每个项目分配一个独立的子域名，如A项目是a.xxx.com，并且在nginx中设置每个项目的转发配置，然后对所有项目的访问都由nginx服务器接受，然后根据配置转发给不同的服务器处理。具体流程如下:</p>
</blockquote>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/a934ee71ebd64b1dbd552685ed86befe.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA55m95aSn6ZSF,size_20,color_FFFFFF,t_70,g_se,x_16"/><br/> 反向代理配置:</p>
<pre><code class="prism language-java">server <span class="token punctuation">{<!-- --></span> 
    #监听端口 
    listen <span class="token number">80</span><span class="token punctuation">;</span> 
    #服务器名称，也就是客户端访问的域名地址 
    server_name  a<span class="token punctuation">.</span>xxx<span class="token punctuation">.</span>com<span class="token punctuation">;</span> 
    #nginx日志输出文件 
    access_log  logs<span class="token operator">/</span>nginx<span class="token punctuation">.</span>access<span class="token punctuation">.</span>log  main<span class="token punctuation">;</span> 
    #nginx错误日志输出文件 
    error_log  logs<span class="token operator">/</span>nginx<span class="token punctuation">.</span>error<span class="token punctuation">.</span>log<span class="token punctuation">;</span> 
    root   html<span class="token punctuation">;</span> 
    index  index<span class="token punctuation">.</span>html index<span class="token punctuation">.</span>htm index<span class="token punctuation">.</span>php<span class="token punctuation">;</span> 
    location <span class="token operator">/</span> <span class="token punctuation">{<!-- --></span> 
        #被代理服务器的地址 
        proxy_pass  http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>localhost<span class="token operator">:</span><span class="token number">8081</span><span class="token punctuation">;</span> 
        #对发送给客户端的URL进行修改的操作 
        proxy_redirect     off<span class="token punctuation">;</span> 
        proxy_set_header   <span class="token class-name">Host</span>             $host<span class="token punctuation">;</span> 
        proxy_set_header   <span class="token class-name">X</span><span class="token operator">-</span><span class="token class-name">Real</span><span class="token operator">-</span>IP        $remote_addr<span class="token punctuation">;</span> 
        proxy_set_header   <span class="token class-name">X</span><span class="token operator">-</span><span class="token class-name">Forwarded</span><span class="token operator">-</span><span class="token class-name">For</span>  $proxy_add_x_forwarded_for<span class="token punctuation">;</span> 
        proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504<span class="token punctuation">;</span> 
        proxy_max_temp_file_size <span class="token number">0</span><span class="token punctuation">;</span> 
   <span class="token punctuation">}</span> 
<span class="token punctuation">}</span>
</code></pre>
<p>这样就可以通过a.xxx.com来访问a项目对应的网站了，而不需要带上难看的端口号。</p>
<p>反向代理的配置关键点是：</p>
<blockquote>
<p>1.server_name：代表客户端向服务器发起请求时输入的域名<br/> 2.proxy_pass：代表源服务器的访问地址，也就是真正处理请求的服务器(localhost+端口号)。</p>
</blockquote>
<h2><a id="Nginx_1863"></a>🔮Nginx负载均衡</h2>
<blockquote>
<p>负载均衡：将服务器接收到的请求按照规则分发的过程，称为负载均衡。负载均衡是反向代理的一种体现。<br/> 可能绝大部分人接触到的web项目，刚开始时都是一台服务器就搞定了，但当网站访问量越来越大时，单台服务器就扛不住了，这时候需要增加服务器做成集群来分担流量压力，而在架设这些服务器时，nginx就充当了接受流量和分流的作用了，当请求到nginx服务器时，nginx就可以根据设置好的负载信息，把请求分配到不同的服务器，服务器处理完毕后，nginx获取处理结果返回给客户端，这样，用nginx的反向代理，即可实现了负载均衡。</p>
</blockquote>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/0f400a5ec38f49668a7ebe02c37e02d8.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA55m95aSn6ZSF,size_20,color_FFFFFF,t_70,g_se,x_16"/><br/> nginx实现负载均衡有几种模式：</p>
<blockquote>
<p>1.轮询：每个请求按时间顺序逐一分配到不同的后端服务器，也是nginx的默认模式。轮询模式的配置很简单，只需要把服务器列表加入到upstream模块中即可。<br/> 下面的配置是指：负载中有三台服务器，当请求到达时，nginx按照时间顺序把请求分配给三台服务器处理。</p>
</blockquote>
<blockquote>
<p>2.ip_hash：每个请求按访问IP的hash结果分配，同一个IP客户端固定访问一个后端服务器。可以保证来自同一ip的请求被打到固定的机器上，可以解决session问题。<br/> 下面的配置是指：负载中有三台服务器，当请求到达时，nginx优先按照ip_hash的结果进行分配，也就是同一个IP的请求固定在某一台服务器上，其它则按时间顺序把请求分配给三台服务器处理。</p>
</blockquote>
<blockquote>
<p>3.url_hash：按访问url的hash结果来分配请求，相同的url固定转发到同一个后端服务器处理。</p>
</blockquote>
<p>而在每一种模式中，每一台服务器后面的可以携带的参数有：</p>
<blockquote>
<p>1.down: 当前服务器暂不参与负载<br/> 2.weight: 权重，值越大，服务器的负载量越大。<br/> 3.max_fails：允许请求失败的次数，默认为1。<br/> 4.fail_timeout:max_fails次失败后暂停的时间。<br/> 5.backup：备份机， 只有其它所有的非backup机器down或者忙时才会请求backup机器。</p>
</blockquote>
<p>最后给大家分享一些资料 需要可联系博主:<br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/89fe139d477d4fd6b3bb26f334a9c0e6.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA55m95aSn6ZSF,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
</div>
<link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css" rel="stylesheet"/>
<link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css" rel="stylesheet"/>
</div>