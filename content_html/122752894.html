<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="markdown_views prism-atom-one-light" id="content_views">
<svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
<path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
</svg>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/b5c88a1b82974504858f886e1db760b6.gif#pic_center"/></p>
<p></p>
<div class="toc">
<h3>文章目录</h3>
<ul><li><a href="#font_color996633_STLfont_7"><font color="#996633">STL</font></a></li><li><ul><li><a href="#font_color9400D3_STLfont_9"><font color="#9400D3">什么是STL</font></a></li><li><a href="#font_color9400D3_STLfont_13"><font color="#9400D3">STL版本</font></a></li><li><ul><li><a href="#font_colorFF0033_font_15"><font color="#FF0033">原始版本</font></a></li><li><a href="#font_colorFF0033_P_J_font_19"><font color="#FF0033">P. J. 版本</font></a></li><li><a href="#font_colorFF0033_RWfont_23"><font color="#FF0033">RW版本</font></a></li><li><a href="#font_colorFF0033_SGIfont_27"><font color="#FF0033">SGI版本</font></a></li></ul>
</li><li><a href="#font_color9400D3_STLfont_31"><font color="#9400D3">STL的六大组件</font></a></li><li><a href="#font_color9400D3_STLfont_35"><font color="#9400D3">如何学习STL</font></a></li><li><a href="#font_color9400D3_STLfont_49"><font color="#9400D3">STL的缺陷</font></a></li></ul>
</li><li><a href="#font_color996633_stringfont_58"><font color="#996633">接下来我们要学的第一个容器就是string</font></a></li><li><ul><li><a href="#font_color9400D3_stringfont_60"><font color="#9400D3">为什么学习string类？</font></a></li><li><ul><li><a href="#font_colorFF0033_Cfont_62"><font color="#FF0033">C语言中的字符串</font></a></li></ul>
</li><li><a href="#font_color9400D3_stringfont_66"><font color="#9400D3">标准库中的string类</font></a></li><li><ul><li><a href="#font_colorFF0033_stringfont_68"><font color="#FF0033">string类(了解)</font></a></li><li><a href="#font_colorFF0033_stringfont_87"><font color="#FF0033">string类的常用接口说明（注意下面我只讲解最常用的接口）</font></a></li><li><ul><li><a href="#font_color0000CC_1stringfont_89"><font color="#0000CC">1.string类对象的常见构造</font></a></li><li><a href="#font_color0000CC_2stringfont_135"><font color="#0000CC">2.string类对象的容量操作</font></a></li><li><a href="#font_color0000CC_3stringfont_230"><font color="#0000CC">3.string类对象的访问及遍历操作</font></a></li><li><a href="#font_color0000CC_4stringfont_287"><font color="#0000CC">4.string类对象的修改操作</font></a></li><li><a href="#font_color0000CC_5stringfont_428"><font color="#0000CC">5.string类非成员函数</font></a></li></ul>
</li><li><a href="#font_colorFF0033_font_440"><font color="#FF0033">几题小菜</font></a></li><li><ul><li><a href="#font_color0000CC_httpsleetcodecncomproblemsfirstuniquecharacterinastringfont_442"><font color="#0000CC">[找字符串中第一个只出现一次的字符](https://leetcode-cn.com/problems/first-unique-character-in-a-string/)</font></a></li><li><ul><li><a href="#font_colorFF00FF_font_448"><font color="#FF00FF">下标+[]</font></a></li><li><a href="#font_colorFF00FF_font_475"><font color="#FF00FF">迭代器</font></a></li><li><a href="#font_colorFF00FF_forfont_503"><font color="#FF00FF">范围for</font></a></li></ul>
</li><li><a href="#httpsleetcodecncomproblemsreverseonlyletters_529">仅仅反转字母</a></li><li><a href="#font_color0000CC_httpswwwnowcodercompractice8c949ea5f36f422594b306a2300315datpId37tqId21224rp5ruactivityojqrutahuaweiquestionrankingfont_567"><font color="#0000CC">[**字符串最后一个单词的长度**](https://www.nowcoder.com/practice/8c949ea5f36f422594b306a2300315da?tpId=37&amp;&amp;tqId=21224&amp;rp=5&amp;ru=/activity/oj&amp;qru=/ta/huawei/question-ranking)</font></a></li><li><a href="#httpsleetcodecncomproblemsvalidpalindrome_599">验证回文串</a></li><li><a href="#httpsleetcodecncomproblemsaddstrings_677">字符串相加</a></li></ul>
</li></ul>
</li></ul>
</li></ul>
</div>
<br/>
<img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/b4f5602989e64831a6f44d397527fcaf.gif#pic_center"/>
<p></p>
<h1><a id="font_color996633_STLfont_7"></a><font color="#996633">STL</font></h1>
<h2><a id="font_color9400D3_STLfont_9"></a><font color="#9400D3">什么是STL</font></h2>
<blockquote>
<p>STL(standard template libaray-标准模板库)：<mark>是C++标准库的重要组成部分</mark>，不仅是一个可复用的组件库，而且<mark>是一个包罗数据结构与算法的软件框架</mark></p>
</blockquote>
<h2><a id="font_color9400D3_STLfont_13"></a><font color="#9400D3">STL版本</font></h2>
<h3><a id="font_colorFF0033_font_15"></a><font color="#FF0033">原始版本</font></h3>
<blockquote>
<p>Alexander Stepanov、Meng Lee 在惠普实验室完成的原始版本，本着开源精神，他们声明允许任何人任意运用、拷贝、修改、传播、商业使用这些代码，无需付费。唯一的条件就是也需要向原始版本一样做开源使用。 HP 版本–所有STL实现版本的始祖</p>
</blockquote>
<h3><a id="font_colorFF0033_P_J_font_19"></a><font color="#FF0033">P. J. 版本</font></h3>
<blockquote>
<p>由P. J. Plauger开发，继承自HP版本，被Windows Visual C++采用，不能公开或修改，缺陷：可读性比较低，符号命名比较怪异</p>
</blockquote>
<h3><a id="font_colorFF0033_RWfont_23"></a><font color="#FF0033">RW版本</font></h3>
<blockquote>
<p>由Rouge Wage公司开发，继承自HP版本，被C+ + Builder 采用，不能公开或修改，可读性一般。</p>
</blockquote>
<h3><a id="font_colorFF0033_SGIfont_27"></a><font color="#FF0033">SGI版本</font></h3>
<blockquote>
<p>由Silicon Graphics Computer Systems，Inc公司开发，继承自HP版 本。被GCC(Linux)采用，可移植性好，可公开、修改甚至贩卖，从命名风格和编程 风格上看，阅读性非常高。<mark>我们后面学习STL要阅读部分源代码，主要参考的就是这个版本。</mark></p>
</blockquote>
<h2><a id="font_color9400D3_STLfont_31"></a><font color="#9400D3">STL的六大组件</font></h2>
<blockquote>
<p><img alt="image-20220127112155030" src="https://img-blog.csdnimg.cn/img_convert/8e40b0e72f12e8b76ef2a1b3fd16c051.png"/></p>
</blockquote>
<h2><a id="font_color9400D3_STLfont_35"></a><font color="#9400D3">如何学习STL</font></h2>
<blockquote>
<p><img alt="image-20220127112859314" src="https://img-blog.csdnimg.cn/img_convert/008362516133a92a1b703b7713e6ba7d.png"/></p>
<p><strong>简单总结一下：</strong></p>
<p><mark>学习STL的三个境界：</mark></p>
<ol><li>能用，</li><li>明理，</li><li>能扩展 。</li></ol>
<p><mark>进公司前要把前两层修炼熟悉,第三层是在公司中修炼的</mark></p>
</blockquote>
<h2><a id="font_color9400D3_STLfont_49"></a><font color="#9400D3">STL的缺陷</font></h2>
<blockquote>
<ol><li>STL库的更新太慢了。这个得严重吐槽，上一版靠谱是C++98，中间的C++03基本一些修订。C++11出<br/> 来已经相隔了13年，STL才进一步更新。</li><li>STL现在都没有支持线程安全。并发环境下需要我们自己加锁。且锁的粒度是比较大的。</li><li>STL极度的追求效率，导致内部比较复杂。比如类型萃取，迭代器萃取。</li><li>STL的使用会有代码膨胀的问题，比如使用vector/vector/vector这样会生成多份代码，当然这是模板语<br/> 法本身导致的。</li></ol>
</blockquote>
<h1><a id="font_color996633_stringfont_58"></a><font color="#996633">接下来我们要学的第一个容器就是string</font></h1>
<h2><a id="font_color9400D3_stringfont_60"></a><font color="#9400D3">为什么学习string类？</font></h2>
<h3><a id="font_colorFF0033_Cfont_62"></a><font color="#FF0033">C语言中的字符串</font></h3>
<blockquote>
<p>C语言中，字符串是以’\0’结尾的一些字符的集合，为了操作方便，C标准库中提供了一些str系列的库函数，但是这些库函数与字符串是分离开的，不太符合OOP的思想，而且底层空间需要用户自己管理，稍不留神可能还会越界访问</p>
</blockquote>
<h2><a id="font_color9400D3_stringfont_66"></a><font color="#9400D3">标准库中的string类</font></h2>
<h3><a id="font_colorFF0033_stringfont_68"></a><font color="#FF0033">string类(了解)</font></h3>
<blockquote>
<p><a href="http://www.cplusplus.com/reference/string/string/?kw=string">string类的文档介绍</a></p>
<ol><li>字符串是表示字符序列的类</li><li>标准的字符串类提供了对此类对象的支持，其接口类似于标准字符容器的接口，但添加了专门用于操作单字节字符字符串的设计特性。</li><li>string类是使用char(即作为它的字符类型，使用它的默认char_traits和分配器类型(关于模板的更多信息，请参阅basic_string)。</li><li>string类是basic_string模板类的一个实例，它使用char来实例化basic_string模板类，并用char_traits和allocator作为basic_string的默认参数(根于更多的模板信息请参考basic_string)。</li><li>注意，这个类独立于所使用的编码来处理字节:如果用来处理多字节或变长字符(如UTF-8)的序列，这个类的所有成员(如长度或大小)以及它的迭代器，将仍然按照字节(而不是实际编码的字符)来操作。</li></ol>
<p><mark>总结：</mark></p>
<ol><li>string是表示字符串的字符串类</li><li>该类的接口与常规容器的接口基本相同，再添加了一些专门用来操作string的常规操作。</li><li>string在底层实际是：basic_string模板类的别名，typedef basic_string&lt;char, char_traits, allocator&gt;string;</li><li>不能操作多字节或者变长字符的序列。</li></ol>
<p><strong>在使用string类时，必须包含#include头文件以及using namespace std;</strong></p>
</blockquote>
<h3><a id="font_colorFF0033_stringfont_87"></a><font color="#FF0033">string类的常用接口说明（注意下面我只讲解最常用的接口）</font></h3>
<h4><a id="font_color0000CC_1stringfont_89"></a><font color="#0000CC">1.string类对象的常见构造</font></h4>
<blockquote>
<table><thead><tr><th align="center">(<a href="http://www.cplusplus.com/reference/string/string/string/">constructor</a>)函数名称</th><th>功能说明</th></tr></thead><tbody><tr><td align="center">string() （重点）</td><td>构造空的string类对象，即空字符串</td></tr><tr><td align="center">string(const char* s) （重点）</td><td>用C-string来构造string类对象</td></tr><tr><td align="center">string(size_t n, char c)</td><td>string类对象中包含n个字符c</td></tr><tr><td align="center">string(const string&amp;s) （重点）</td><td>拷贝构造函数</td></tr></tbody></table>
<p><img alt="image-20220128152201077" src="https://img-blog.csdnimg.cn/img_convert/a19e568e5d03edf00490e074c8895ac2.png"/></p>
<p><mark>学STL，重点讲最常用30%左右的接口函数，其他很少用，如果有一天我们需要用，就去看文档</mark></p>
<p><img alt="image-20220128160854899" src="https://img-blog.csdnimg.cn/img_convert/3c96f528c7d64ccad81e0d57c514da1a.png"/></p>
<p><img alt="image-20220128161158196" src="https://img-blog.csdnimg.cn/img_convert/20c31e2ac64211d8d4f1d99c5bc98304.png"/></p>
<pre><code class="prism language-c++">int main()
{
	string s1;              //无参构造
	string s2("Hello c++"); //带参数构造
	string s3 = "Hello c++";//编译器优化的直接构造
	string s4(s2);          //拷贝构造

	string s5(s4, 2, string::npos);    //部分构造
	string s6("123456789", 5);         //构造前n个字符
	//这个作用就是假如以后要写网络的代码，截取前几个字符会用到
	const char* url = "http://www.cplusplus.com/reference/string/string/string/";
	string s7(url, 5);
	string s8(10, 'x');     //构造n个一样的字符


	cout &lt;&lt; s1 &lt;&lt; endl;
	cout &lt;&lt; s2 &lt;&lt; endl;
	cout &lt;&lt; s3 &lt;&lt; endl;
	cout &lt;&lt; s4 &lt;&lt; endl;
	cout &lt;&lt; s5 &lt;&lt; endl;
	cout &lt;&lt; s6 &lt;&lt; endl;
	cout &lt;&lt; s7 &lt;&lt; endl;
	cout &lt;&lt; s8 &lt;&lt; endl;

	return 0;
}
</code></pre>
</blockquote>
<h4><a id="font_color0000CC_2stringfont_135"></a><font color="#0000CC">2.string类对象的容量操作</font></h4>
<blockquote>
<table><thead><tr><th>函数名称</th><th>功能说明</th></tr></thead><tbody><tr><td><a href="http://www.cplusplus.com/reference/string/string/size/">size</a>（重点）</td><td>返回字符串有效字符长度</td></tr><tr><td><a href="http://www.cplusplus.com/reference/string/string/length/">length</a></td><td>返回字符串有效字符长度</td></tr><tr><td><a href="http://www.cplusplus.com/reference/string/string/capacity/">capacity</a></td><td>返回空间总大小</td></tr><tr><td><a href="http://www.cplusplus.com/reference/string/string/empty/">empty</a> （重点）</td><td>检测字符串释放为空串，是返回true，否则返回false</td></tr><tr><td><a href="http://www.cplusplus.com/reference/string/string/clear/">clear</a> （重点）</td><td>清空有效字符</td></tr><tr><td><a href="http://www.cplusplus.com/reference/string/string/reserve/">reserve</a> （重点）</td><td>为字符串预留空间</td></tr><tr><td><a href="http://www.cplusplus.com/reference/string/string/resize/">resize</a> （重点）</td><td>将有效字符的个数该成n个，多出的空间用字符c填充</td></tr></tbody></table>
<p><mark>实际上length在string中就是数组长度，和size一样，那为什么要两个一样的呢，是因为历史上string出来的要比stl早，string在官网文档也没有归类到容器里面（但他就是容器），而是放在了头文件里面，size是普法，length是只用与string的</mark></p>
<p><strong>注意：</strong></p>
<ol><li>size()与length()方法底层实现原理完全相同，引入size()的原因是为了与其他容器的接口保持一致，一般情况下基本都是用size()。</li><li>clear()只是将string中有效字符清空，不改变底层空间大小。</li><li>resize(size_t n) 与 resize(size_t n, char c)都是将字符串中有效字符个数改变到n个，不同的是当字符个数增多时：resize(n)用0来填充多出的元素空间，resize(size_t n, char c)用字符c来填充多出的元素空间。注意：resize在改变元素个数时，如果是将元素个数增多，可能会改变底层容量的大小，如果是将元素个数减少，底层空间总大小不变。</li><li>reserve(size_t res_arg=0)：为string预留空间，不改变有效元素个数，当reserve的参数小于string的底层空间总大小时，reserver不会改变容量大小。</li></ol>
<p><img alt="image-20220128164211665" src="https://img-blog.csdnimg.cn/img_convert/af31ff8ad311997f27e516a7c621a240.png"/></p>
<p><mark>这里提一嘴 at 的作用和 [] 是一样的，可以认为是早期语法可能不太支持 [] 所以才有at这个接口代替，后面支持了，at就基本不用了，他们也不是完全一样，他们越界就不一样</mark></p>
<p><img alt="image-20220128175822354" src="https://img-blog.csdnimg.cn/img_convert/b3232030604a6c574e24326e98808c32.png"/></p>
<p><img alt="image-20220129123039488" src="https://img-blog.csdnimg.cn/img_convert/31fb1804631f94dc6518e99202a4a137.png"/></p>
<p><mark>reserve给足空间就可以防止多次增容，那么resize可以吗</mark></p>
<p><img alt="image-20220129153150305" src="https://img-blog.csdnimg.cn/img_convert/82541a31fa4ae33e39ad39c3d3c0b7dc.png"/></p>
<p><mark>我们也可以看看相同的代码在不同平台跑出来的结果</mark></p>
<p><img alt="image-20220129154447987" src="https://img-blog.csdnimg.cn/img_convert/263ccc7f77c58ea506f2a7bdcaf14948.png"/></p>
<p><img alt="image-20220129163550632" src="https://img-blog.csdnimg.cn/img_convert/280edb1d7b67a6a341ddd57cc09cf2cf.png"/></p>
<pre><code class="prism language-c++">int main()
{
	string s1 = "Hello world";
	string s2 ="world";
	//判断字符串是否为空
	cout &lt;&lt;"s1.empty "&lt;&lt; s1.empty() &lt;&lt; endl;
	cout &lt;&lt; "s2.empty " &lt;&lt; s2.empty() &lt;&lt; endl;
	//大小
	cout &lt;&lt; "s1.size " &lt;&lt; s1.size() &lt;&lt; endl;
	cout &lt;&lt; "s2.size " &lt;&lt; s2.size() &lt;&lt; endl;
	//容量
	cout &lt;&lt;"s1.capacity "&lt;&lt; s1.capacity() &lt;&lt; endl;
	cout &lt;&lt;"s2.capacity "&lt;&lt; s2.capacity() &lt;&lt; endl &lt;&lt; endl;
	//清掉所有的数据，就是size变成零,但是空间不释放
	s1.clear();
	cout &lt;&lt; "s1.size " &lt;&lt; s1.size() &lt;&lt; endl;
	cout &lt;&lt; "s1.capacity " &lt;&lt; s1.capacity() &lt;&lt; endl &lt;&lt; endl;
	//在对象中插入n个字符，默认字符是‘\0’
	//想要放其他字符就
	s1.resize(15);
	string s3 = s2;
	s2.resize(1,'x');
	s3.resize(16,'x');
	cout &lt;&lt;"s2:    "&lt;&lt; s2 &lt;&lt; endl;
	cout &lt;&lt;"s3:    "&lt;&lt; s3 &lt;&lt; endl;
	cout &lt;&lt; "s1.size " &lt;&lt; s1.size() &lt;&lt; endl;
	cout &lt;&lt; "s2.size " &lt;&lt; s2.size() &lt;&lt; endl;
	cout &lt;&lt; "s1.capacity " &lt;&lt; s1.capacity() &lt;&lt; endl;
	cout &lt;&lt; "s2.capacity " &lt;&lt; s2.capacity() &lt;&lt; endl &lt;&lt; endl;
	//请求一个容量的改变  
	s2.reserve(40);
	cout &lt;&lt; "s2:    " &lt;&lt; s2 &lt;&lt; endl;
	cout &lt;&lt; "s2.size " &lt;&lt; s2.size() &lt;&lt; endl;
	cout &lt;&lt; "s2.capacity " &lt;&lt; s2.capacity() &lt;&lt; endl &lt;&lt; endl;
	string s4;
	直接给足空间防止多次增容	
	//s4.reserve(127);
	//看看resize可不可以防止多次增容
	s4.resize(127);
	int old_capacity = s4.capacity();
	for (char ch = 0; ch &lt; 127; ch++)
	{
		s4 += ch;
		//查看增容情况
		if (old_capacity != s4.capacity())
		{
			cout &lt;&lt; "增容：" &lt;&lt; old_capacity &lt;&lt;"-&gt;"&lt;&lt; s4.capacity()&lt;&lt; endl;
		}
		old_capacity = s4.capacity();
	}
	cout &lt;&lt; s4 &lt;&lt; endl &lt;&lt; endl;
	return 0;
}
</code></pre>
</blockquote>
<h4><a id="font_color0000CC_3stringfont_230"></a><font color="#0000CC">3.string类对象的访问及遍历操作</font></h4>
<blockquote>
<table><thead><tr><th>函数名称</th><th>功能说明</th></tr></thead><tbody><tr><td><a href="http://www.cplusplus.com/reference/string/string/operator%5B%5D/">operator[]</a> （重点）</td><td>返回pos位置的字符，const string类对象调用</td></tr><tr><td><a href="http://www.cplusplus.com/reference/string/string/begin/">begin</a>+ <a href="http://www.cplusplus.com/reference/string/string/end/">end</a></td><td>begin获取一个字符的迭代器 + end获取最后一个字符下一个位置的迭代器</td></tr><tr><td><a href="http://www.cplusplus.com/reference/string/string/rbegin/">rbegin</a> + <a href="http://www.cplusplus.com/reference/string/string/rend/">rend</a></td><td>begin获取一个字符的迭代器 + end获取最后一个字符下一个位置的迭代器</td></tr><tr><td>范围for</td><td>C++11支持更简洁的范围for的新遍历方式</td></tr></tbody></table>
<p><mark>迭代器</mark></p>
<p><mark>迭代器意义：像string，vector支持[]遍历，但是list，map等等容器不支持[],我们就要用迭代器遍历，所以迭代器是一种统一的使用方式</mark></p>
<p><img alt="image-20220128181708095" src="https://img-blog.csdnimg.cn/img_convert/5efe13ccf392aad9e8257e980f6cd11d.png"/></p>
<pre><code class="prism language-c++">int main()
{
	string s1 = "Hello c++";
	//迭代器
	string::iterator it = s1.begin();//begin是返回开始位置的迭代器
	while (it != s1.end())//end是返回结束位置的迭代器
	{
		static char tmp = 'a';
		*it++ = tmp++;
	}
	it = s1.begin();
	while (it != s1.end())//end是返回结束位置的迭代器
	{
		cout &lt;&lt; *it &lt;&lt; " ";
		it++;		
	}
	return 0;
}
</code></pre>
<p><mark>反向迭代器</mark></p>
<p><img alt="image-20220128185001736" src="https://img-blog.csdnimg.cn/img_convert/5d9c23f60629b90194416b326ad7251c.png"/></p>
<pre><code class="prism language-c++">int main()
{
	string s1 = "Hello c++";
	//反向迭代器
	string::reverse_iterator rit = s1.rbegin();
	while (rit != s1.rend())
	{
		cout &lt;&lt; *rit &lt;&lt; " ";
		rit++;
	}
	return 0;
}
</code></pre>
<p><img alt="image-20220128221641116" src="https://img-blog.csdnimg.cn/img_convert/1bac88788db010a29819cb01b21046d9.png"/></p>
</blockquote>
<h4><a id="font_color0000CC_4stringfont_287"></a><font color="#0000CC">4.string类对象的修改操作</font></h4>
<blockquote>
<table><thead><tr><th>函数名称</th><th>功能说明</th></tr></thead><tbody><tr><td><a href="http://www.cplusplus.com/reference/string/string/push_back/">push_back</a></td><td>在字符串后尾插字符c</td></tr><tr><td><a href="http://www.cplusplus.com/reference/string/string/append/">append</a></td><td>在字符串后追加一个字符串</td></tr><tr><td><a href="http://www.cplusplus.com/reference/string/string/operator+=/">operator+=</a> (重点)</td><td>在字符串后追加字符串str</td></tr><tr><td><a href="http://www.cplusplus.com/reference/string/string/c_str/">c_str</a>(重点)</td><td>返回C格式字符串</td></tr><tr><td><a href="http://www.cplusplus.com/reference/string/string/find/">find</a> + <a href="http://www.cplusplus.com/reference/string/string/npos/">npos</a>(重点)</td><td>从字符串pos位置开始往后找字符c，返回该字符在字符串中的位置</td></tr><tr><td><a href="http://www.cplusplus.com/reference/string/string/rfind/">rfind</a></td><td>从字符串pos位置开始往前找字符c，返回该字符在字符串中的位置</td></tr><tr><td><a href="http://www.cplusplus.com/reference/string/string/substr/">substr</a></td><td>在str中从pos位置开始，截取n个字符，然后将其返回</td></tr></tbody></table>
<p><strong>注意：</strong></p>
<ol><li>在string尾部追加字符时，s.push_back© / s.append(1, c) / s += 'c’三种的实现方式差不多，一般情况下string类的+=操作用的比较多，+=操作不仅可以连接单个字符，还可以连接字符串。</li><li>对string操作时，如果能够大概预估到放多少字符，可以先通过reserve把空间预留好。</li></ol>
<p><img alt="image-20220129011010870" src="https://img-blog.csdnimg.cn/img_convert/c8fbf49867267240d732bb68a59b8f14.png"/></p>
<pre><code class="prism language-c++">int main()
{
	string s;
	s.push_back('h');
	s.push_back('e');
	s.push_back('l');
	s.push_back('l');
	s.push_back('o');
	cout &lt;&lt; s &lt;&lt; endl;

	s.append(" world");
	cout &lt;&lt; s &lt;&lt; endl;
	string s2 = "!!!!!!";
	s.append(s2);
	cout &lt;&lt; s &lt;&lt; endl;

	//但是不巧的是实际中最喜欢用的是+=
	string s3;
	s3 += 'X';
	s3 += "你好";
	s3 += s2;
	cout &lt;&lt; s3 &lt;&lt; endl;
	//尽量少用insert，因为底层实现是数组，头部或者中间需要挪动数据
	s3.insert(0, "x");
	s3.insert(0,"hhhh");
	cout &lt;&lt; s3 &lt;&lt; endl;
	//删除
	string s4 = s3;
	string s5 = s3;
	string s6 = s3;
	s4.erase(3, 100);//从第三个开始删除
	s5.erase(3);//从第三个开始删除，一直删完
	s6.erase(); //直接删光
	cout &lt;&lt; s4 &lt;&lt; endl;
	cout &lt;&lt; s5 &lt;&lt; endl;
	cout &lt;&lt; s6 &lt;&lt; endl;
	return 0;
}
</code></pre>
<p><img alt="image-20220129185118237" src="https://img-blog.csdnimg.cn/img_convert/901a05ea408b26c99fce7574ec51293a.png"/></p>
<pre><code class="prism language-c++">int main()
{
	string s("Hello world");
	cout &lt;&lt; s &lt;&lt; endl;        //这边调的是operator&lt;&lt;(cout,s);
	cout &lt;&lt; s.c_str() &lt;&lt; endl;//这边调用的是内置类型operator&lt;&lt;(cout,const char*);

	s.resize(20);
	s += "!!!";
	cout &lt;&lt; s &lt;&lt; endl;
	cout &lt;&lt; s.c_str() &lt;&lt; endl;
	return 0;
}
</code></pre>
<p><img alt="image-20220129202118400" src="https://img-blog.csdnimg.cn/img_convert/26e50818df25e1184464ed791d285c17.png"/></p>
<pre><code class="prism language-c++">int main()
{
	//假设我们需要取文件名的后缀
	string filename = "text.txt.zip";
	size_t pos = filename.rfind('.');
	if (pos != string::npos)
	{
		string suff(filename, pos);
		cout &lt;&lt; suff &lt;&lt; endl;
	}
	return 0;
}
</code></pre>
<p><img alt="image-20220130103936419" src="https://img-blog.csdnimg.cn/img_convert/c34f5ee206de6c8a7d4119faf319d30a.png"/></p>
<pre><code class="prism language-c++">//取域名
string GetDomain(const string&amp; url)
{
	size_t pos = url.find("://");
	if (pos != string::npos)
	{
		//找到域名的最开始位置
		size_t start = pos + 3;
		//从域名开始的位置向后面找 ’/‘ 
		size_t end = url.find('/', start);
		if (end != string::npos)
		{
			return url.substr(start, end - start);
		}
	}
	//假如没有就返回一个匿名对象
	return string();
}
//取协议
string GetProtocol(const string&amp; url)
{
	size_t pos = url.find("://");
	if (pos != string::npos)
	{
		return url.substr(0, pos);
	}
	//假如没有就返回一个匿名对象
	return string();
}
int main()
{
	//分别取出域名和协议名
	string url1 = "http://www.cplusplus.com/reference/string/string/find/";
	string url2 = "https://juejin.cn/creator/home";
	cout &lt;&lt; GetDomain(url1) &lt;&lt; endl;
	cout &lt;&lt; GetProtocol(url1) &lt;&lt; endl;
	cout &lt;&lt; GetDomain(url2) &lt;&lt; endl;
	cout &lt;&lt; GetProtocol(url2) &lt;&lt; endl;
	return 0;
}
</code></pre>
</blockquote>
<h4><a id="font_color0000CC_5stringfont_428"></a><font color="#0000CC">5.string类非成员函数</font></h4>
<blockquote>
<table><thead><tr><th>函数</th><th>功能说明</th></tr></thead><tbody><tr><td><a href="http://www.cplusplus.com/reference/string/string/operator+/">operator+</a></td><td>尽量少用，因为传值返回，导致深拷贝效率低</td></tr><tr><td><a href="http://www.cplusplus.com/reference/string/string/operator%3E%3E/">operator&gt;&gt;</a> （重点）</td><td>输入运算符重载</td></tr><tr><td><a href="http://www.cplusplus.com/reference/string/string/operator%3C%3C/">operator&lt;&lt;</a> （重点）</td><td>输出运算符重载</td></tr><tr><td><a href="http://www.cplusplus.com/reference/string/string/getline/">getline</a> （重点）</td><td>获取一行字符串</td></tr><tr><td><a href="http://www.cplusplus.com/reference/string/string/operators/">relational operators</a> （重点）</td><td>大小比较</td></tr></tbody></table>
</blockquote>
<h3><a id="font_colorFF0033_font_440"></a><font color="#FF0033">几题小菜</font></h3>
<h4><a id="font_color0000CC_httpsleetcodecncomproblemsfirstuniquecharacterinastringfont_442"></a><font color="#0000CC"><a href="https://leetcode-cn.com/problems/first-unique-character-in-a-string/">找字符串中第一个只出现一次的字符</a></font></h4>
<blockquote>
<p>用这题来练手3种遍历</p>
</blockquote>
<blockquote>
<p><img alt="image-20220127165401047" src="https://img-blog.csdnimg.cn/img_convert/5e79dae354b7dd5615eb42d09f55a67a.png"/></p>
<h5><a id="font_colorFF00FF_font_448"></a><font color="#FF00FF">下标+[]</font></h5>
<p><img alt="image-20220127170528297" src="https://img-blog.csdnimg.cn/img_convert/ffa59cf824d00096d783fd4133db9c91.png"/></p>
<pre><code class="prism language-c++">class Solution {
public:
 int firstUniqChar(string s) {
     //26个字母计数数组
     int count[26] = {0};
     int i= 0;
     //遍历计数
     for(i = 0;i&lt;s.size();i++)
     {
         count[s[i]-97]++;
     }
     //找第一个是1的
     for(i = 0;i&lt;s.size();i++)
     {
         if(1 == count[s[i]-97])
         return i;
     }
     return -1;
 }
};
</code></pre>
<h5><a id="font_colorFF00FF_font_475"></a><font color="#FF00FF">迭代器</font></h5>
<p><img alt="image-20220127185059304" src="https://img-blog.csdnimg.cn/img_convert/0fb3939f634b401e28475aacbf7e90d7.png"/></p>
<pre><code class="prism language-c++">class Solution {
public:
 int firstUniqChar(string s) {
     //26个字母计数数组
     int count[26] = {0};
     //迭代器
     string::iterator it = s.begin();
     while(it != s.end())
     {
         count[*it-97]++;
         it++;
     }
     //找第一个是1的
     for(int i = 0;i&lt;s.size();i++)
     {
         if(1 == count[s[i]-97])
         return i;
     }
     return -1;
 }
};
</code></pre>
<h5><a id="font_colorFF00FF_forfont_503"></a><font color="#FF00FF">范围for</font></h5>
<p><img alt="image-20220127190748999" src="https://img-blog.csdnimg.cn/img_convert/cfa33cb402ed92b0f7d417148a5d4b1d.png"/></p>
<pre><code class="prism language-c++">class Solution {
public:
 int firstUniqChar(string s) {
     //26个字母计数数组
     int count[26] = {0};
     //范围for
    for(auto&amp; e:s)
    {
         count[e-97]++;
    }
     //找第一个是1的
     for(int i = 0;i&lt;s.size();i++)
     {
         if(1 == count[s[i]-97])
         return i;
     }
     return -1;
 }
};
</code></pre>
</blockquote>
<h4><a id="httpsleetcodecncomproblemsreverseonlyletters_529"></a><a href="https://leetcode-cn.com/problems/reverse-only-letters/">仅仅反转字母</a></h4>
<blockquote>
<p><img alt="image-20220128105728308" src="https://img-blog.csdnimg.cn/img_convert/5c8f115b3b52625f457f5874211a847c.png"/></p>
<p><img alt="image-20220128105637326" src="https://img-blog.csdnimg.cn/img_convert/caff7e34483fb7ce2095bf6e1bce8631.png"/></p>
<pre><code class="prism language-c++">class Solution {
public:
    //判断是否是字母
    bool isletter(const char ch)
    {
        if((ch &gt;= 'a' &amp;&amp; ch&lt;='z') ||(ch &gt;= 'A' &amp;&amp; ch &lt;='Z'))
        return true;
        return false;
    }
    string reverseOnlyLetters(string s) {
        if(!s.size())
         return s;
       //头尾下标
       int begin = 0,end = s.size()-1;
       while(begin &lt; end)
       {
           while(begin &lt; end &amp;&amp; !isletter(s[begin]))
                begin++;
           while(begin &lt; end &amp;&amp; !isletter(s[end]))
                end--;
            swap(s[begin],s[end]);
            begin++;
            end--;
       }
       return s;   
    }
};
</code></pre>
</blockquote>
<h4><a id="font_color0000CC_httpswwwnowcodercompractice8c949ea5f36f422594b306a2300315datpId37tqId21224rp5ruactivityojqrutahuaweiquestionrankingfont_567"></a><font color="#0000CC"><a href="https://www.nowcoder.com/practice/8c949ea5f36f422594b306a2300315da?tpId=37&amp;&amp;tqId=21224&amp;rp=5&amp;ru=/activity/oj&amp;qru=/ta/huawei/question-ranking"><strong>字符串最后一个单词的长度</strong></a></font></h4>
<blockquote>
<p><img alt="image-20220127211552511" src="https://img-blog.csdnimg.cn/img_convert/af1ea505a660fd0318287c3e29291bcd.png"/></p>
<p><img alt="image-20220130112625865" src="https://img-blog.csdnimg.cn/img_convert/bd0086d63a86d5c39b8b0c1a43a53455.png"/></p>
<p><img alt="image-20220130113017517" src="https://img-blog.csdnimg.cn/img_convert/06b41f5c631fc98fa44af5b179c0a611.png"/></p>
<pre><code class="prism language-c++">#include &lt;iostream&gt;
using namespace std;


int main()
{
    string str;
    getline(cin,str);
    size_t pos = str.rfind(' ');
    if(pos != string::npos)
    {
        cout&lt;&lt; str.size()-pos-1&lt;&lt;endl;
    }
    else
    {
        cout&lt;&lt; str.size()&lt;&lt;endl;
    }
    return 0;
}
</code></pre>
</blockquote>
<h4><a id="httpsleetcodecncomproblemsvalidpalindrome_599"></a><a href="https://leetcode-cn.com/problems/valid-palindrome/">验证回文串</a></h4>
<blockquote>
<p><img alt="image-20220127212716778" src="https://img-blog.csdnimg.cn/img_convert/d984a6577c6e27c68c5491e65a8d412c.png"/></p>
<p><img alt="image-20220130130005327" src="https://img-blog.csdnimg.cn/img_convert/59aa12fc48a51ddbdf1a7abaaf46a93b.png"/></p>
<pre><code class="prism language-C++">class Solution {
public:
    bool isPalindrome(string s) {
        //创建两个空字符串
        string str1,str2,str3;        
        //反向迭代器
        string::reverse_iterator rit = s.rbegin();
        while(rit != s.rend())
        {
            if(*rit &gt;= 'A' &amp;&amp; *rit &lt;='Z')
                str1 += *rit+32;
            else if(*rit &gt;= 'a' &amp;&amp; *rit&lt;='z')
                str1 += *rit;
            else if(*rit &gt;= '0' &amp;&amp; *rit&lt;='9')
                str1 += *rit;
            rit++;
        }
        str2 = str1;
        //再来一次反向迭代器
        string::reverse_iterator rt = str2.rbegin();
        while(rt != str2.rend())
           str3 += *rt++;
        if(str3 == str2)
            return true;
        else
            return false;
    }
};
</code></pre>
<p><img alt="image-20220130132239335" src="https://img-blog.csdnimg.cn/img_convert/a68b088304145ee8c3f43095842b3521.png"/></p>
<pre><code class="prism language-C++">class Solution {
public:
    //判断字母数字
    bool islettername(const char&amp; ch){
        if(ch &gt;= 'a' &amp;&amp; ch &lt;= 'z'
        || (ch &gt;= '0' &amp;&amp; ch &lt;='9'))
        return true;
        return false;
    }
    bool isPalindrome(string s) {
        //先把s里面大写全部改成小写的
        for(auto&amp; e:s)
        {
            if(e&gt;='A' &amp;&amp; e&lt;='Z')
            e+=32;
        }
        int begin = 0;
        int end = s.size()-1;
        while(begin &lt; end)
        {
            while(begin &lt; end &amp;&amp; !islettername(s[begin]))
            begin++;
            while(begin &lt; end &amp;&amp; !islettername(s[end]))
            end--;
            if(s[begin] == s[end])
            {
                 begin++; end--;
            }
            else
            return false;
        }
        return true;
    }
};
</code></pre>
</blockquote>
<h4><a id="httpsleetcodecncomproblemsaddstrings_677"></a><a href="https://leetcode-cn.com/problems/add-strings/">字符串相加</a></h4>
<blockquote>
<p><img alt="image-20220130133032959" src="https://img-blog.csdnimg.cn/img_convert/305bb9459760725fcc729eba4a8bc987.png"/></p>
<p><img alt="image-20220130141528575" src="https://img-blog.csdnimg.cn/img_convert/b3f5082d6a7190980cb4715872943ff0.png"/></p>
<pre><code class="prism language-c++">class Solution {
public:
    string addStrings(string num1, string num2) {
        //两个下标
        int end1 = num1.size()-1,end2 = num2.size()-1;
        //计算后的对象
        string ansStr;
        //进位
        int carry = 0;
        while(end1&gt;=0 || end2&gt;=0)
        {
            int n1 = 0;
            if(end1 &gt;= 0){
                n1 = num1[end1] - '0';
                end1--;
            }
            int n2 = 0;
            if(end2 &gt;= 0){
                n2 = num2[end2] - '0';
                end2--;
            }
            //两个位置开始相加
            int ret = n1+n2+carry;
            if(ret &gt; 9){
                ret -= 10;
                carry = 1;
            }
            else
                carry = 0;
            //这是就准备插字符
            ansStr.insert(0,1,ret+'0');
        }
        //插最后一个进位的
        if(carry)
        ansStr.insert(0,1,carry+'0');
        return ansStr;
    }
};
</code></pre>
<p><mark>实际上我们可以看到提交时间看到我们时间复杂度不行，那是因为我们头插了insert了，字符串越长，挪动的就越恶心，也就效率越低，所以我就直接尾插，到最后再来个逆置reverse就行了，这时候就看我们选用的接口了，基本一题都有好几种解法</mark></p>
<p><img alt="image-20220130143407011" src="https://img-blog.csdnimg.cn/img_convert/27a4e91bdf352fb6a82bf408989606bc.png"/></p>
<pre><code class="prism language-c++">class Solution {
public:
    string addStrings(string num1, string num2) {
        //两个下标
        int end1 = num1.size()-1,end2 = num2.size()-1;
        //计算后的对象
        string ansStr;
        //进位
        int carry = 0;
        while(end1&gt;=0 || end2&gt;=0)
        {
            int n1 = 0;
            if(end1 &gt;= 0){
                n1 = num1[end1] - '0';
                end1--;
            }
            int n2 = 0;
            if(end2 &gt;= 0){
                n2 = num2[end2] - '0';
                end2--;
            }
            //两个位置开始相加
            int ret = n1+n2+carry;
            if(ret &gt; 9){
                ret -= 10;
                carry = 1;
            }
            else
                carry = 0;
            //这是就准备插字符  我们这就直接尾插
            ansStr += (ret +'0');
        }
        //插最后一个进位的
        if(carry)
        ansStr += (carry +'0');
        //然后逆置就行
        reverse(ansStr.begin(),ansStr.end());
        return ansStr;
    }
};
</code></pre>
</blockquote>
</div>
<link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css" rel="stylesheet"/>
<link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css" rel="stylesheet"/>
</div>