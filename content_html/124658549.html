<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<p></p>
<p></p>
<p id="main-toc"></p>
<p id="main-toc"><strong>目录</strong></p>
<p id="1.%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E-toc" style="margin-left:40px;"><a href="#1.%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E">1.线程和进程是什么？举例说明</a></p>
<p id="2.%20js%E4%B8%AD%E7%9A%84%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%3F%20%E4%BA%86%E8%A7%A3%E5%8C%85%E8%A3%85%E5%AF%B9%E8%B1%A1%E5%90%97%EF%BC%9F-toc" style="margin-left:40px;"><a href="#2.%20js%E4%B8%AD%E7%9A%84%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%3F%20%E4%BA%86%E8%A7%A3%E5%8C%85%E8%A3%85%E5%AF%B9%E8%B1%A1%E5%90%97%EF%BC%9F">2. js中的基础数据类型有哪几种? 了解包装对象吗？</a></p>
<p id="3.%E5%AF%B9%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E4%BA%86%E8%A7%A3-toc" style="margin-left:40px;"><a href="#3.%E5%AF%B9%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E4%BA%86%E8%A7%A3">3.对内存泄漏的了解</a></p>
<p id="4.js%E4%B8%AD%E6%95%B0%E7%BB%84%E5%90%88%E5%B9%B6%E7%9A%84%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#4.js%E4%B8%AD%E6%95%B0%E7%BB%84%E5%90%88%E5%B9%B6%E7%9A%84%E6%96%B9%E6%B3%95">4.js中数组合并的方法</a></p>
<p id="5.%E5%90%88%E5%B9%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#5.%E5%90%88%E5%B9%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95">5.合并对象的方法</a></p>
<p id="6.%E4%BB%80%E4%B9%88%E6%98%AF%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%EF%BC%9F-toc" style="margin-left:40px;"><a href="#6.%E4%BB%80%E4%B9%88%E6%98%AF%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%EF%BC%9F">6.什么是作用域，什么是作用域链？</a></p>
<p id="7.JS%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%EF%BC%885%E7%A7%8D%EF%BC%89%EF%BC%9F-toc" style="margin-left:40px;"><a href="#7.JS%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%EF%BC%885%E7%A7%8D%EF%BC%89%EF%BC%9F">7.JS如何实现异步编程（5种）？</a></p>
<p id="js中的堆内存与栈内存-toc" style="margin-left:40px;"><a href="#js%E4%B8%AD%E7%9A%84%E5%A0%86%E5%86%85%E5%AD%98%E4%B8%8E%E6%A0%88%E5%86%85%E5%AD%98">8.js中的堆内存与栈内存</a></p>
<p id="9.%E5%A6%82%E4%BD%95%E5%8E%BB%E5%88%A4%E6%96%ADjs%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9F-toc" style="margin-left:40px;"><a href="#9.%E5%A6%82%E4%BD%95%E5%8E%BB%E5%88%A4%E6%96%ADjs%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9F">9.如何去判断js数据类型？</a></p>
<p id="10%EF%BC%8C%E6%80%8E%E4%B9%88%E5%85%81%E8%AE%B8%E8%B7%A8%E5%9F%9F%EF%BC%88%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%EF%BC%89-toc" style="margin-left:40px;"><a href="#10%EF%BC%8C%E6%80%8E%E4%B9%88%E5%85%81%E8%AE%B8%E8%B7%A8%E5%9F%9F%EF%BC%88%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%EF%BC%89">10，怎么允许跨域（跨域解决办法）</a></p>
<p id="C%E3%80%81Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86-toc" style="margin-left:80px;"><a href="#C%E3%80%81Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86">C、Nginx反向代理</a></p>
<p id="D%E3%80%81webpack%20%EF%BC%88%E5%9C%A8vue.config.js%E6%96%87%E4%BB%B6%E4%B8%AD%EF%BC%89%E4%B8%AD%20%E9%85%8D%E7%BD%AEwebpack-dev-server-toc" style="margin-left:80px;"><a href="#D%E3%80%81webpack%20%EF%BC%88%E5%9C%A8vue.config.js%E6%96%87%E4%BB%B6%E4%B8%AD%EF%BC%89%E4%B8%AD%20%E9%85%8D%E7%BD%AEwebpack-dev-server">D、webpack （在vue.config.js文件中）中 配置webpack-dev-server</a></p>
<p id="11.%E6%80%8E%E4%B9%88%E8%AE%A9%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B1%9E%E6%80%A7%E4%B8%8D%E5%8F%AF%E8%A2%AB%E6%94%B9%E5%8F%98-toc" style="margin-left:40px;"><a href="#11.%E6%80%8E%E4%B9%88%E8%AE%A9%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B1%9E%E6%80%A7%E4%B8%8D%E5%8F%AF%E8%A2%AB%E6%94%B9%E5%8F%98">11.怎么让对象的一个属性不可被改变</a></p>
<p id="%EF%BC%881%EF%BC%89%20Object.defineProperty()-toc" style="margin-left:80px;"><a href="#%EF%BC%881%EF%BC%89%20Object.defineProperty%28%29">（1） Object.defineProperty()</a></p>
<p id="2%EF%BC%89object.preventExtensions()-toc" style="margin-left:80px;"><a href="#2%EF%BC%89object.preventExtensions%28%29">2）object.preventExtensions()</a></p>
<p id="12.%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%80%E7%94%A8%E7%9A%84%E5%86%85%E6%A0%B8-toc" style="margin-left:40px;"><a href="#12.%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%80%E7%94%A8%E7%9A%84%E5%86%85%E6%A0%B8">12.浏览器所用的内核</a></p>
<p id="13%E3%80%81%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E6%98%AF%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E8%BF%98%E6%98%AF%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%88%E8%A1%A5%E5%85%A8funcA()%7B%7D%EF%BC%89-toc" style="margin-left:40px;"><a href="#13%E3%80%81%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E6%98%AF%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E8%BF%98%E6%98%AF%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%88%E8%A1%A5%E5%85%A8funcA%28%29%7B%7D%EF%BC%89">13、判断一个函数是普通函数还是构造函数（补全funcA(){}）</a></p>
<p id="14.JavaScript%20%E4%B8%AD%E7%9A%84%E6%8F%90%E5%8D%87%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-toc" style="margin-left:40px;"><a href="#14.JavaScript%20%E4%B8%AD%E7%9A%84%E6%8F%90%E5%8D%87%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">14.JavaScript 中的提升是什么？</a></p>
<p id="15%E3%80%81js%E6%9C%89%E5%93%AA%E4%BA%9B%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%EF%BC%9F%E3%80%80-toc" style="margin-left:40px;"><a href="#15%E3%80%81js%E6%9C%89%E5%93%AA%E4%BA%9B%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%EF%BC%9F%E3%80%80">15、js有哪些内置对象？　</a></p>
<p id="16.%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81-toc" style="margin-left:40px;"><a href="#16.%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81">16.防抖和节流</a></p>
<p id="函数防抖-toc" style="margin-left:80px;"><a href="#%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96">函数防抖</a></p>
<p id="函数节流-toc" style="margin-left:80px;"><a href="#%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81">函数节流</a></p>
<p id="17.%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D-toc" style="margin-left:40px;"><a href="#17.%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D">17.对象的深拷贝</a></p>
<p id="18%E3%80%81%C2%A0Nodelist%E5%92%8CHTMLCollection%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:40px;"><a href="#18%E3%80%81%C2%A0Nodelist%E5%92%8CHTMLCollection%E7%9A%84%E5%8C%BA%E5%88%AB">18、 Nodelist和HTMLCollection的区别</a></p>
<p id="%C2%A019.js%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%99%90%E5%88%B6-toc" style="margin-left:40px;"><a href="#%C2%A019.js%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%99%90%E5%88%B6"> 19.js严格模式的限制</a></p>
<p id="%E2%80%8B%E7%BC%96%E8%BE%91-toc" style="margin-left:40px;"></p>
<p></p>
<hr/>
<p></p>
<h2 id="1.%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E">1.线程和进程是什么？举例说明</h2>
<p><br/> 进程：cpu分配资源的最小单位（是能拥有资源和独立运行的最小单位）<br/> 线程：是cpu最小的调度单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）<br/> 栗子：比如进程=火车，线程就是车厢</p>
<p>一个进程内有多个线程，执行过程是多条线程共同完成的，线程是进程的部分。<br/> 一个火车可以有多个车厢<br/> 每个进程都有独立的代码和数据空间，程序之间切换会产生较大的开销；线程可以看作轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器，线程之间切换的开销小。<br/> 【多列火车比多个车厢更耗资源】<br/> 【一辆火车上的乘客很难换到另外一辆火车，比如站点换乘，但是同一辆火车上乘客很容易从A车厢换到B车厢】<br/> 同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的<br/> 【一辆火车上不同车厢的人可以共用各节车厢的洗手间，但是不是火车上的乘客无法使用别的火车上的洗手间】</p>
<p>为什么js是单线程<br/> JS是单线程的原因主要和JS的用途有关，JS主要实现浏览器与用户的交互，以及操作DOM。<br/> 如果JS被设计为多线程，如果一个线程要修改一个DOM元素，另一个线程要删除这个DOM元素，这时浏览器就不知道该怎么办，为了避免复杂的情况产生，所以JS是单线程的。</p>
<p>为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。</p>
<h2 id="2.%20js%E4%B8%AD%E7%9A%84%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%3F%20%E4%BA%86%E8%A7%A3%E5%8C%85%E8%A3%85%E5%AF%B9%E8%B1%A1%E5%90%97%EF%BC%9F">2. js中的基础数据类型有哪几种? 了解包装对象吗？</h2>
<p><br/> 答：六种，string, number, boolean, undefiend, null, symbol<br/> 基础数据类型临时创建的临时对象，称为包装对象。其中 number、boolean 和 string 有包装对象，代码运行的过程中会找到对应的包装对象，然后包装对象把属性和方法给了基本类型，然后包装对象被系统进行销毁。</p>
<p></p>
<h2 id="3.%E5%AF%B9%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E4%BA%86%E8%A7%A3">3.对内存泄漏的了解</h2>
<p><br/> 1. 理解<br/> - 定义：程序中已在堆中分配的内存，因为某种原因未释放或者无法释放的问题<br/> - 简单理解: 无用的内存还在占用，得不到释放和归还，比较严重的时候，无用的内存还会增加，从而导致整个系统卡顿，甚至崩溃。<br/><br/> 2. 生命周期<br/> 1. 分配期<br/>   分配所需要的内存，在js中，是自动分配的<br/> 2. 使用期<br/>   使用分配的内存，就是读写变量或者对象的属性值<br/> 3. 释放期<br/>   不需要时将该内存释放，js会自动释放(除了闭包和一些bug以外)<br/>   内存泄漏就是出现在这个时期，内存没有被释放导致的<br/><br/> 3. 可能出现内存泄漏的原因<br/> 1. 意外的全局变量<br/> 2. DOM元素清空时，还存在引用<br/> 3. 闭包<br/> 4. 遗忘的定时器</p>
<p><strong>如何优化内存泄漏?</strong></p>
<ul><li>全局变量先声明在使用</li><li>避免过多使用闭包。</li><li>注意清除定时器和事件监听器。</li></ul>
<p></p>
<h2 id="4.js%E4%B8%AD%E6%95%B0%E7%BB%84%E5%90%88%E5%B9%B6%E7%9A%84%E6%96%B9%E6%B3%95">4.js中数组合并的方法</h2>
<p>js 数组合并<br/> let arr1 = ['温情', '刘聪']<br/> let arr2 = ['杨和苏', '邓紫棋']<br/> let arr3 = ['周延']<br/><br/><strong>1. arr1.concat(arr2, ······)</strong><br/> es5 Array.concat() 合并两个数组, 返回新数组，不会改变原数组<br/> arr = arr1.concat(arr2, arr3);<br/> console.log(arr);  // ["温情", "刘聪", "杨和苏", "邓紫棋", "周延"]<br/><br/><strong>2. […arr1, …arr2，······]</strong><br/> es6 展开运算符(…)<br/> arr = [...arr1, ...arr2, ...arr3];<br/> console.log(arr);  // ["温情", "刘聪", "杨和苏", "邓紫棋", "周延"]<br/><br/><strong>3. push(…arr)</strong><br/> push 结合 ...[] 来实现, 会更改原数组<br/> arr1.push(...arr2, ...arr3)<br/> console.log(arr1);  // ["温情", "刘聪", "杨和苏", "邓紫棋", "周延"<br/><br/><strong>适合两个数组，不适合多个数组的方法</strong><br/><strong>1. for + push</strong><br/> for(let i in arr2) {<!-- --><br/>     arr1.push(arr2[i])<br/> }<br/> console.log(arr1);  // ["温情", "刘聪", "杨和苏", "邓紫棋"]<br/><br/><strong>2. arr1.push.apply(arr1, arr2)</strong><br/> arr1.push.apply(arr1, arr2)<br/> console.log(arr1);  // ["温情", "刘聪", "杨和苏", "邓紫棋"]</p>
<p></p>
<h2 id="5.%E5%90%88%E5%B9%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95">5.合并对象的方法</h2>
<p><strong>Object.assign()</strong><br/> es6 Object.assign()方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target)<br/> Object.assign()方法的第一个参数是目标对象，后面的参数都是源对象。<br/> let obj1 = {name: '温情'}<br/> let obj2 = {age: '22'}</p>
<p><strong>const newObj = Object.assign({}, obj1, obj2);</strong><br/> console.log(newObj);  // {name: "温情", age: "22"}<br/><br/> !注意! Object.assign()实行的是浅拷贝，也就是说如果源对象的属性是一个对象，那么目标对象得到的是这个对象的引用</p>
<p>let obj1 = {name: {chinese: '杨和苏', english: 'keyNG'}}<br/> const newObj = Object.assign({}, obj1);<br/> console.log(newObj);  // name: {chinese: "杨和苏", english: "keyNG"}<br/> obj1.name.english = 'pig';<br/> console.log(newObj);  // name: {chinese: "杨和苏", english: "pig"}</p>
<p></p>
<h2 id="6.%E4%BB%80%E4%B9%88%E6%98%AF%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%EF%BC%9F">6.什么是作用域，什么是作用域链？</h2>
<ul><li>规定变量和函数的可使用范围称为作用域</li><li>查找变量或者函数时，需要从局部作用域到全局作用域依次查找，这些作用域的集合称作用域链。</li></ul>
<p></p>
<h2 id="7.JS%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%EF%BC%885%E7%A7%8D%EF%BC%89%EF%BC%9F"><strong>7.JS如何实现异步编程（5种）？</strong></h2>
<p><br/> 1）回调函数(callback)<br/> 优点：解决了同步的问题（只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。）<br/> 缺点：回调地狱，每个任务只能指定一个回调函数,不能 return.</p>
<p>2)事件监听。这种思路是说异步任务的执行不取决于代码的顺序，而取决于某个事件是否发生。比如一个我们注册一个按钮的点击事件或者注册一个自定义事件，然后通过点击或者trigger的方式触发这个事件。</p>
<p>3)Promise</p>
<p>4)Generator</p>
<p>5)生成器 async/await,是ES7提供的一种解决方案。</p>
<p></p>
<h2 id="js中的堆内存与栈内存">8.js中的<a href="https://so.csdn.net/so/search?q=%E5%A0%86%E5%86%85%E5%AD%98&amp;spm=1001.2101.3001.7020" title="堆内存">堆内存</a>与栈内存</h2>
<p>在js引擎中对变量的存储主要有两种位置，<strong>堆内存和栈内存</strong>。</p>
<p>和java中对<a href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&amp;spm=1001.2101.3001.7020" title="内存">内存</a>的处理类似，<strong>栈内存</strong>主要用于存储各种<strong>基本类型的</strong>变量，包括Boolean、Number、String、Undefined、Null，**以及对象变量的指针，这时候栈内存给人的感觉就像一个线性排列的空间，每个小单元大小基本相等。</p>
<p>而堆内存主要负责像对象Object这种变量类型的存储，如下图</p>
<p><img alt="" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvNDYxOTc2LzIwMTgwOC80NjE5NzYtMjAxODA4MjMyMTE1MTE0MzQtMTcwNzU3OTc5NC5wbmc?x-oss-process=image/format,png"/></p>
<p></p>
<p><strong>栈内存中的变量一般都是已知大小或者有范围上限的</strong>，算作一种简单存储。<strong>而堆内存存储的对象类型数据对于大小这方面，一般都是未知的</strong>。个人认为，这也是为什么null作为一个object类型的变量却存储在栈内存中的原因。</p>
<p><strong>因此当我们定义一个const对象的时候，<u>我们说的常量其实是指针</u>，就是const对象对应的堆内存指向是不变的，但是堆内存中的数据本身的大小或者属性是可变的。而<u>对于const定义的基础变量而言，这个值就相当于const对象的指针</u>，是不可变。</strong></p>
<p>既然知道了const在内存中的存储，那么const、let定义的变量不能二次定义的流程也就比较容易猜出来了，每次使用const或者let去初始化一个变量的时候，会首先遍历当前的内存栈，看看有没有重名变量，有的话就返回错误。</p>
<p>说到这里，有一个十分很容易忽略的点，之前也是自己一直没有注意的就是，使用new关键字初始化的之后是不存储在栈内存中的。为什么呢？new大家都知道，根据构造函数生成新实例，这个时候生成的是<strong>对象</strong>，而不是基本类型。再看一个例子</p>
<p><img alt="" height="168" src="image\f47b7407ab704459ae922e8779ce6875.png" width="652"/></p>
<p> 我们可以看到new一个String，出来的是对象，而直接字面量赋值和工厂模式出来的都是字符串。但是根据我们上面的分析大小相对固定可预期的即便是对象也可以存储在栈内存的，比如null，为啥这个不是呢？再继续看</p>
<p><img alt="" height="88" src="image\6e2e46d349d14fd5af23eb19efa628b5.png" width="293"/></p>
<p> 很明显，如果a，b是存储在栈内存中的话，两者应该是明显相等的，就像null === null是true一样，但结果两者并不相等，说明两者都是存储在堆内存中的，指针指向不一致。</p>
<p><br/>  </p>
<h2 id="9.%E5%A6%82%E4%BD%95%E5%8E%BB%E5%88%A4%E6%96%ADjs%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9F">9.如何去判断js数据类型？</h2>
<p><strong>         首先我们可以用typeof去判断，typeof只能判断基本数据类型，对于引用数据类型，- -律返回object,在js中，数组是一种特殊的对象类型， 因此typeof-个数组,返回的是object.<br/>         还可以通过instanceof来判断，它不能检测基本数据类型，它是用来判断个实例是否属于某种类型， 使用它的方式可以用Ainstanceof B，如果A是B的实例，则返回true,否则返回flase。<br/>         然后还可以用constructor来判断，除了undefined和nul1之外，其它类型都可以通过constructor来判断,<br/>         但是如果声明了一个构造函数，并且把它的原型指向改变了，这种情况下，constructor也不能准确的判断。<br/>         通过0bject . prototype . toString,判断一个对象 只属于某种内置类型，但是不能准确的判断一个实例是否属于某种类型。<br/> 原因是因为实例对象可能会自定义toString方法，把这个方法给覆盖掉，我们可以通过函数. call( )方法，可以在任意值上调用这个方法，帮助我们判断这个值的类型。</strong></p>
<p></p>
<h2 id="10%EF%BC%8C%E6%80%8E%E4%B9%88%E5%85%81%E8%AE%B8%E8%B7%A8%E5%9F%9F%EF%BC%88%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%EF%BC%89">10，怎么允许跨域（跨域解决办法）</h2>
<p><strong>A、JSONP</strong><br/> 在页面上，js脚本，css样式文件，图片这三种资源是可以与页面本身不同源的。jsonp就利用了script标签进行跨域取得数据。<br/> JSONP允许用户传递一个callback参数给服务器端，然后服务器端返回数据时会将这个callback参数作为函数名来包裹住JSON数据。这样客户端就可以随意定制自己的函数来自动处理返回的数据了。<br/> JSONP只能解决get请求，不能解决post请求。<br/>  </p>
<pre><code class="language-javascript">&lt;script&gt;
        function callback(data){
            console.log(data);
        }
    &lt;/script&gt;
    &lt;script src="http://localhost:80/?callback=callback"&gt;&lt;/script&gt;
</code></pre>
<p>使用ajax实现跨域：</p>
<pre><code class="language-javascript">&lt;script src="http://code.jquery.com/jquery-latest.js"&gt;&lt;/script&gt; 

  $.ajax({
            url:'http://localhost:80/?callback=callback',
            method:'get',
            dataType:'jsonp', //=&gt; 执行jsonp请求
            success:(res) =&gt; {
                console.log(res);
            }
        })
    
        function callback(data){
            console.log(data);
        }
</code></pre>
<p></p>
<p><strong>B、 CORS跨域资源共享：</strong><br/> 浏览器会自动进行CORS通信，实现CORS通信的关键是后端。服务端设置Access-Control-Allow-Origin就可以开启CORS。该属性表示哪些域名跨域访问资源。<br/> 主要设置以下几个属性：<br/> Access-Control-Allow-Origin//允许跨域的域名<br/> Access-Control-Allow-Headers//允许的header类型<br/> Access-Control-Allow-Methods//跨域允许的请求方式</p>
<h3 id="C%E3%80%81Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86">C、Nginx反向代理</h3>
<p>通过nginx配置一个代理服务器将客户机请求转发给内部网络上的目标服务器；并将服务器上返回的结果返回给客户端。</p>
<h3 id="D%E3%80%81webpack%20%EF%BC%88%E5%9C%A8vue.config.js%E6%96%87%E4%BB%B6%E4%B8%AD%EF%BC%89%E4%B8%AD%20%E9%85%8D%E7%BD%AEwebpack-dev-server"><a name="t27"></a><a id="Dwebpack_vueconfigjs_webpackdevserver_283"></a>D、webpack （在vue.config.js文件中）中 配置webpack-dev-server</h3>
<pre><code class="language-javascript">devServer: {
        proxy: {
          '/api': {
            target: "http://39.98.123.211",
            changeOrigin: true,  //是否跨域
          },
        },
      },
</code></pre>
<h2 id="11.%E6%80%8E%E4%B9%88%E8%AE%A9%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B1%9E%E6%80%A7%E4%B8%8D%E5%8F%AF%E8%A2%AB%E6%94%B9%E5%8F%98">11.怎么让对象的一个属性不可被改变</h2>
<h3 id="%EF%BC%881%EF%BC%89%20Object.defineProperty()"><a name="t88"></a><a id="1_ObjectdefineProperty_910"></a>（1） Object.defineProperty()</h3>
<p>可以使用Object.defineProperty()方法，让对象的某一个属性不可变，把对象某一属性的writable和configurable设置为false.</p>
<pre><code class="language-javascript">let obj = {a:1,b:2};
      Object.defineProperty(obj,'c',{
        value:100000,
        writable:false,//当该属性的 writable 键值为 true 时，属性的值才能被赋值操作修改
        configurable:false//当为true时，该属性的描述符才能够被改变，同时该属性也能从对应的对象上被删除。
      })
      
      obj.c = 282031283
      console.log(obj.c)//100000
</code></pre>
<h3 id="2%EF%BC%89object.preventExtensions()">2）object.preventExtensions()</h3>
<p>让对象不能添加新属性，可以使用object.preventExtensions()方法。（但是可以修改属性值）</p>
<pre><code class="language-javascript">	  let obj = {a:1,b:2};
      Object.preventExtensions(obj);
      obj.c = 1000;
      console.log(obj)
</code></pre>
<h2 id="12.%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%80%E7%94%A8%E7%9A%84%E5%86%85%E6%A0%B8">12.浏览器所用的内核</h2>
<p><br/> IE：Trident内核<br/> Chrome:以前是webkit内核，现在是Blink内核<br/> Firefox:Gecko（/ˈɡekoʊ/）内核<br/> Safari:webkit内核<br/> Opera:最初使用的是presto内核，后来加入谷歌大军，从webkit内核又变成了Blink内核<br/> 360，猎豹浏览器：IE+chrome双内核</p>
<p></p>
<h2 id="13%E3%80%81%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E6%98%AF%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E8%BF%98%E6%98%AF%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%88%E8%A1%A5%E5%85%A8funcA()%7B%7D%EF%BC%89">13、判断一个函数是普通函数还是构造函数（补全funcA(){}）</h2>
<blockquote>
<p>构造函数中this指向new创建的实例。所以可通过在函数内部判断this是否为当前函数的实例进而判断当前函数是否作为构造函数。</p>
</blockquote>
<pre><code class="language-javascript">		function A(){
            if(this instanceof A){
                console.log('我是构造函数')
            }else{
                console.log('我是普通函数')
            }
        }
        A();
        new A();
</code></pre>
<h2 id="14.JavaScript%20%E4%B8%AD%E7%9A%84%E6%8F%90%E5%8D%87%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><strong>14.JavaScript 中的提升是什么？</strong></h2>
<p>提升意味着所有的声明都被移动到作用域的顶部。这发生在代码运行之前。</p>
<p>对于函数，这意味着你可以从作用域中的任何位置调用它们，甚至在它们被定义之前。</p>
<pre><code class="language-javascript">hello();  // Prints "Hello world! " even though the function is called "before" declaration
 
 
function hello(){ 
  console.log("Hello world! ");
}</code></pre>
<p>对于变量，提升有点不同。它在作用域的顶部将 undefined 分配给它们。</p>
<p>例如，在定义变量之前调用它：</p>
<pre><code class="language-javascript">console.log(dog);//undefined
var dog = "Spot";</code></pre>
<p></p>
<p>结果是：</p>
<pre><code>undefined</code></pre>
<p>这可能令人惊讶，因为你可能预计它会导致错误。</p>
<p>用var声明一个函数或变量，无论你在哪里声明它，它总是被移动到作用域的顶部。</p>
<p></p>
<p></p>
<h2 id="15%E3%80%81js%E6%9C%89%E5%93%AA%E4%BA%9B%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%EF%BC%9F%E3%80%80"><strong>15、js有哪些内置对象？</strong>　</h2>
<p><br/> 数据封装类对象：Object、Array、Boolean、Number 和 String<br/> 　　其他对象：Function、Arguments、Math、Date、RegExp、Error....</p>
<h2 id="16.%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81">16.防抖和节流</h2>
<h3 id="函数防抖"><strong>函数防抖</strong></h3>
<p>当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定时间到来之前，又触发了事件，就重新开始延时。也就是说当一个用户一直触发这个函数，且每次触发函数的间隔小于既定时间，那么防抖的情况下只会执行一次。</p>
<p>举个例子：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;防抖&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
搜索：&lt;input type="text" id="input1"&gt;

    &lt;script&gt;
        // 防抖 
        // 默认值200ms
        function debounce(fn,dalay=200) {
         let  timer=0;
            return function(){
             if(timer)   clearTimeout(timer);
                timer=setTimeout(()=&gt;{
                     fn.apply(this,arguments)//透传this和参数
                     timer=0
                },dalay)
            }           
        }
      
        const input=document.getElementById("input1");
        input.addEventListener("keyup",debounce(()=&gt;{
            console.log("发起搜索"+input.value)
        },1000))

   

    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<h3 id="函数节流">函数节流</h3>
<p>当持续触发事件时，保证在一定时间内只调用一次事件处理函数，意思就是说，假设一个用户一直触发这个函数，且每次触发小于既定值，函数节流会每隔这个时间调用一次<br/> 用一句话总结防抖和节流的区别：防抖是将多次执行变为最后一次执行，节流是将多次执行变为每隔一段时间执行</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;throttle&lt;/title&gt;
    &lt;div id="div1" draggable="true" style="width:100px;height: 50px;background-color:gray; "&gt;
        可拖拽
    &lt;/div&gt;
&lt;/head&gt;
&lt;body&gt;
    

    &lt;script&gt;
        // 节流 不管时间触发了多少次 在规定事件内只会执行一次 
        function throttle(fn,delay=200) {
            let timer=0;
            return function(){
                if(timer) return ;
                timer=setTimeout(()=&gt;{
                     fn.apply(this,arguments)//透传this和参数
                     timer=0
                },delay)
            }
        }

        const div1=document.getElementById("div1");
        div1.addEventListener("drag",throttle((e)=&gt;{
            console.log("鼠标的位置"+e.offsetX,e.offsetY)
        },2000))



    
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>总结防抖和节流函数： js代码区别就在于if这里是清除定时器还是直接return终止函数</p>
<pre><code class="language-javascript"> function throttleOrDebounce(fn,delay=3000) {
            let timer=0;
            return function (){
                // 防抖
                // if(timer) clearTimeout(timer);
                // 节流
                if (timer) return;
                timer=setTimeout(()=&gt;{
                       fn.apply(this,arguments)
                       timer=0
                },delay)
            }
        }</code></pre>
<p></p>
<h2 id="17.%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D">17.对象的深拷贝</h2>
<p> 深拷贝就是对目标的完全拷贝，不像浅拷贝那样只是复制了一层引用，而是就连值也都复制了。</p>
<p> 深拷贝之后，两个对象将毫无关联，不会相互影响。</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset="utf-8"&gt;
		&lt;title&gt;&lt;/title&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;script type="text/javascript"&gt;
			let obj = {
				name: "张三",
				list: [1, 2, 3, 4, 5, 6],
				eat(){
					console.log(this.name+"正在吃")
				}
			}

			// 深拷贝
			function deepClone(obj) {
				// 如果是引用数据类型 
				if (typeof obj == 'object') {
					let result = Array.isArray(obj) ? [] : {}
					for (key in obj) {
						result[key] = deepClone(obj[key])
					}
					return result
				} else {
					return obj
				}
			}

		    let obj1 = deepClone(obj)
			obj.hight = '1.78m'
			obj1.age = 18;
			obj1.like='dog'
			console.log(obj, obj1)


      

			
		&lt;/script&gt;
	&lt;/body&gt;

&lt;/html&gt;
</code></pre>
<h2 id="18%E3%80%81%C2%A0Nodelist%E5%92%8CHTMLCollection%E7%9A%84%E5%8C%BA%E5%88%AB">18、 Nodelist和HTMLCollection的区别</h2>
<p>1.Nodelist是返回节点的集合，而nodelist里面也有数组，因此元素也是节点的一种，也就是元素节点<strong> nodelist包含所有的节点 ：注释节点、text节点、element节点.....等</strong></p>
<pre><code class="language-html">&lt;div class="a"&gt;
    &lt;div class="cc"&gt;&lt;/div&gt;
&lt;/div&gt;


console.log(document.getElementsByClassName('a')[0].childNodes);//nodelist
console.log(document.getElementsByClassName('a')[0].children);//Htmlcollection</code></pre>
<p><img alt="" src="https://img-blog.csdnimg.cn/20201024190704393.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTYzODkwOQ==,size_16,color_FFFFFF,t_70#pic_center"/></p>
<p> 2.<strong>HTMLCollection是html元素的集合</strong>，是节点的一种，<strong>它里面只有元素节点</strong>，并且元素节点可以包含很多的节点， 因此我们可以理解为HTMLCollection是Nodelist集合的一种。Nodelist和HTMLCollection都是伪数组</p>
<p> 可以看到HTMLCollection中只包含了 div元素</p>
<p> <img alt="" height="130" src="image\8dad29475cca4d57b826691460b5b9f5.png" width="328"/></p>
<p> 最后在上一张图 加深理解：</p>
<p><img alt="" height="737" src="image\edeb32e4f4ac45768f77ef16b8e91b5d.png" width="1200"/></p>
<h2 id="%C2%A019.js%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%99%90%E5%88%B6"> 19.js严格模式的限制</h2>
<h2 id="%E2%80%8B%E7%BC%96%E8%BE%91"><img alt="" height="174" src="image\6be11b01200c4dfcbc51375dde10b69c.png" width="291"/></h2>
<p><strong>1.变量必须声明后再使用</strong><br/><strong>2.函数的参数不能有同名属性，否则报错</strong><br/><strong>3.不能使用with语句</strong><br/> 4.不能对只读属性赋值，否则报错<br/> 5.不能使用前缀 0 表示八进制数，否则报错<br/> 6.不能删除不可删除的属性，否则报错<br/> 7.不能删除变量delete prop，会报错，只能删除属性delete global[prop]<br/> 8.eval不会在它的外层作用域引入变量<br/> 9.eval和arguments不能被重新赋值<br/> 10.arguments不会自动反映函数参数的变化<br/> 11.不能使用arguments.callee<br/> 12.不能使用arguments.caller<br/><strong>13.禁止this指向全局对象window</strong><br/> 14.不能使用fn.caller和fn.arguments获取函数调用的堆栈<br/> 15.增加了保留字（比如protected、static和interface）</p>
<p><strong>16.创建eval作用域 ，使eval具有自己独立的作用域</strong></p>
<p></p>
<h2>20 js中的宏任务和微任务</h2>
<p> 1）首先理解一下单线程和异步</p>
<p><img alt="" height="354" src="image\7aef592047bb43eb957e85ee6c484d12.png" width="691"/></p>
<p></p>
<p> 2）宏任务和微任务</p>
<p></p>
<p><img alt="" height="671" src="image\810588cafcf640d9a565d2bd9ac8f5db.png" width="1200"/></p>
<p> 还有一个不常用的微任务<img alt="" height="29" src="image\4e17551289004afebe034a8c3a89dec6.png" width="160"/> 作用是监听dom树的变化</p>
<p></p>
<p>微任务 比宏任务执行的 快</p>
<p></p>
<h2><strong>21 vdom真的很快吗？（框架）</strong></h2>
<p><img alt="" height="634" src="image\5e83f2e5233a4222acb2dca7b2f9c5fd.png" width="1064"/></p>
<p> <img alt="" height="649" src="image\8cd28c931ce743859f7a2d8b96dd8841.png" width="1200"/></p>
<p> </p>
<p> 数据驱动试图的技术方法：vdom （虚拟dom）、</p>
<p>原因：数据和试图分离 如果dom全部更新--不行 所以使用虚拟dom</p>
<p>  data变化==&gt;生成 vnode 和oldnode进行对比（diff算法）新、旧两个虚拟dom进行比较==&gt;找到需要更新的部分 ==&gt;局部dom更新</p>
<p>使用jquery：直接操作dom节点</p>
<p><strong>从dom变化上来说，常规的dom操作更快，但是从完整的链条来说（包括研发、运维、设计、开发、测试，整个软件工程的完整链条来看），vdom更快，简化了代码逻辑</strong></p>
<p>vdom并不快，JS直接操作DOM才是最快的<br/> 但“数据驱动视图”要有合适的技术方案，不能全部 DOM重建<br/> vdom 就是目前最合适的技术方案（并不是因为它快，而是合适)</p>
<p></p>
<h2>22.for和foreach谁更快，为什么？</h2>
<p>使用性能测试之后发现for更快，为什么呢？</p>
<p>for 更快</p>
<p>原因：<br/><strong>forEach每次都要创建一个函数来调用，而for不会创建函数，</strong></p>
<p><strong>函数需要独立的作用域，会有额外的开销</strong></p>
<p>越“低级”的代码，性能往往越好<br/> 日常开发别只考虑性能，forEach代码可读性更好（基于时间复杂度一样的情况下，使用可读性更好的方式更佳）</p>
<p></p>
<h2>23 进程和线程</h2>
<p>进程process vs 线程thread<br/><br/> ◆进程，OS<strong>进行资源分配和调度的最小单位</strong>，<strong>有独立内存空间</strong><br/> ◆线程，OS<strong>进行运算调度的最小单位</strong>，<strong>共享进程内存空间</strong></p>
<p> </p>
<p><img alt="" height="545" src="image\0024701d1bd14095b967ddac08752289.png" width="977"/></p>
<p></p>
<p>为何需要多进程?<br/> 多核CPU ，更适合处理多进程<br/> ◆内存较大，多个进程才能更好的利用（单进程有内存上限)<br/> ◆总之，“压榨”机器资源，更快，更节省<br/><br/><br/>  </p>
<p></p>
<p></p>
<p></p>
</div>
</div>