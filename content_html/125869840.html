<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<p id="main-toc"></p>
<p id="main-toc"><strong>目录</strong></p>
<p id="-toc" style="margin-left:0px;"></p>
<p id="vector%E5%AE%B9%E5%99%A8-toc" style="margin-left:0px;"><a href="#vector%E5%AE%B9%E5%99%A8">vector容器</a></p>
<p id="vector%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#vector%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">vector构造函数</a></p>
<p id="vector%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C-toc" style="margin-left:40px;"><a href="#vector%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C">vector赋值操作</a></p>
<p id="vector%E5%AE%B9%E9%87%8F%E5%92%8C%E5%A4%A7%E5%B0%8F-toc" style="margin-left:40px;"><a href="#vector%E5%AE%B9%E9%87%8F%E5%92%8C%E5%A4%A7%E5%B0%8F">vector容量和大小</a></p>
<p id="vector%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4-toc" style="margin-left:40px;"><a href="#vector%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4">vector插入和删除</a></p>
<p id="vector%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96-toc" style="margin-left:40px;"><a href="#vector%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96">vector数据存取</a></p>
<p id="vector%E4%BA%92%E6%8D%A2%E5%AE%B9%E5%99%A8-toc" style="margin-left:40px;"><a href="#vector%E4%BA%92%E6%8D%A2%E5%AE%B9%E5%99%A8">vector互换容器</a></p>
<p id="vector%E9%A2%84%E7%95%99%E7%A9%BA%E9%97%B4-toc" style="margin-left:40px;"><a href="#vector%E9%A2%84%E7%95%99%E7%A9%BA%E9%97%B4">vector预留空间</a></p>
<p id="%C2%A0reserve%EF%BC%88%EF%BC%89%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px;"><a href="#%C2%A0reserve%EF%BC%88%EF%BC%89%E7%9A%84%E5%AE%9E%E7%8E%B0"> reserve（）的实现</a></p>
<p></p>
<p id="vector%E7%9A%84%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><a href="#vector%E7%9A%84%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0">vector的增删查改的模拟实现</a></p>
<p></p>
<p id="%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE%E7%BB%83%E4%B9%A0%C2%A0-toc" style="margin-left:0px;"><a href="#%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE%E7%BB%83%E4%B9%A0%C2%A0">经典题目练习 </a></p>
<p id="1.%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92OJ-toc" style="margin-left:40px;"><a href="#1.%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92OJ">1.杨辉三角OJ</a></p>
<p id="2.%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9%20OJ-toc" style="margin-left:40px;"><a href="#2.%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9%20OJ">2.删除排序数组中的重复项 OJ</a></p>
<p id="3.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97%C2%A0-toc" style="margin-left:40px;"><a href="#3.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97%C2%A0">3. 数组中出现次数超过一半的数字 </a></p>
<p id="4.%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97-toc" style="margin-left:40px;"><a href="#4.%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97">4.只出现一次的数字</a></p>
<p id="5.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88-toc" style="margin-left:40px;"><a href="#5.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88">5.电话号码字母组合</a></p>
<p id="6.%C2%A0%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C%20%C2%A0-toc" style="margin-left:40px;"><a href="#6.%C2%A0%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C%20%C2%A0">6. 连续子数组的最大和  </a></p>
<hr id="hr-toc"/>
<p></p>
<h1 id="vector%E5%AE%B9%E5%99%A8">vector容器</h1>
<p></p>
<h2 id="vector%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">vector构造函数</h2>
<blockquote>
<ul><li><code>vector&lt;T&gt; v;</code> //采用模板实现类实现，默认构造函数</li><li><code>vector(v.begin(), v.end());</code> //将v[begin(), end())区间中的元素拷贝给本身。</li><li><code>vector(n, elem);</code> //构造函数将n个elem拷贝给本身。</li><li><code>vector(const vector &amp;vec);</code> //拷贝构造函数。</li></ul>
</blockquote>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt; 
using namespace std;

#include &lt;vector&gt;

void printVector(vector&lt;int&gt;&amp; v) {

	for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) {
		cout &lt;&lt; *it &lt;&lt; " ";
	}
	cout &lt;&lt; endl;
}

void test01()
{
	vector&lt;int&gt; v1; //无参构造 默认构造 
	for (int i = 0; i &lt; 10; i++)
	{
		v1.push_back(i);
	}
	printVector(v1);
	//通过区间方式构造 
	vector&lt;int&gt; v2(v1.begin(), v1.end());
	printVector(v2);
	// n个元素e方式构造 
	vector&lt;int&gt; v3(10, 0);
	printVector(v3);
	//拷贝构造 
	vector&lt;int&gt; v4(v3);
	printVector(v4);
}

int main() {

	test01();

	system("pause");

	return 0;
}
</code></pre>
<blockquote>
<p>输出：</p>
<p>0 1 2 3 4 5 6 7 8 9<br/> 0 1 2 3 4 5 6 7 8 9<br/> 0 0 0 0 0 0 0 0 0 0<br/> 0 0 0 0 0 0 0 0 0 0</p>
</blockquote>
<p></p>
<p></p>
<p></p>
<h2 id="vector%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C">vector赋值操作</h2>
<blockquote>
<ul><li> <p><code>vector&amp; operator=(const vector &amp;vec);</code>//重载等号操作符</p> </li><li> <p><code>assign(beg, end);</code> //将[beg, end)区间中的数据拷贝赋值给本身。</p> </li><li> <p><code>assign(n, elem);</code> //将n个elem拷贝赋值给本身。</p> </li></ul>
</blockquote>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt; 
using namespace std;
#include &lt;vector&gt;

void printVector(vector&lt;int&gt;&amp; v) {

	for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) {
		cout &lt;&lt; *it &lt;&lt; " ";
	}
	cout &lt;&lt; endl;
}

//赋值操作
void test01()
{
	vector&lt;int&gt; v1; //无参构造
	for (int i = 0; i &lt; 10; i++)
	{
		v1.push_back(i);
	}
	printVector(v1);

	vector&lt;int&gt;v2;
	v2 = v1;
	printVector(v2);

	vector&lt;int&gt;v3;
	v3.assign(v1.begin(), v1.end());
	printVector(v3);

	vector&lt;int&gt;v4;
	v4.assign(10, 100);
	printVector(v4);
}

int main() {

	test01();

	system("pause");

	return 0;
}


</code></pre>
<blockquote>
<p>输出：</p>
<p>0 1 2 3 4 5 6 7 8 9<br/> 0 1 2 3 4 5 6 7 8 9<br/> 0 1 2 3 4 5 6 7 8 9<br/> 100 100 100 100 100 100 100 100 100 100</p>
</blockquote>
<p></p>
<h2 id="vector%E5%AE%B9%E9%87%8F%E5%92%8C%E5%A4%A7%E5%B0%8F">vector容量和大小</h2>
<blockquote>
<ul><li> <p><code>empty();</code> //判断容器是否为空</p> </li><li> <p><code>capacity();</code> //容器的容量</p> </li><li> <p><code>size();</code> //返回容器中元素的个数</p> </li><li> <p><code>resize(int num);</code> //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。</p> <p>​ //如果容器变短，则末尾超出容器长度的元素被删除。</p> </li><li> <p><code>resize(int num, elem);</code> //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。</p> <p>​ //如果容器变短，则末尾超出容器长度的元素被删除</p> </li></ul>
</blockquote>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt; 
using namespace std;
#include &lt;vector&gt;

void printVector(vector&lt;int&gt;&amp; v) {

	for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) {
		cout &lt;&lt; *it &lt;&lt; " ";
	}
	cout &lt;&lt; endl;
}

void test01()
{
	vector&lt;int&gt; v1;
	for (int i = 0; i &lt; 10; i++)
	{
		v1.push_back(i);
	}
	printVector(v1);
	if (v1.empty())
	{
		cout &lt;&lt; "v1为空" &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; "v1不为空" &lt;&lt; endl;
		cout &lt;&lt; "v1的容量 = " &lt;&lt; v1.capacity() &lt;&lt; endl;
		cout &lt;&lt; "v1的大小 = " &lt;&lt; v1.size() &lt;&lt; endl;
	}

	//resize 重新指定大小 ，若指定的更大，默认用0填充新位置，可以利用重载版本替换默认填充
	v1.resize(15,10);
	printVector(v1);

	//resize 重新指定大小 ，若指定的更小，超出部分元素被删除
	v1.resize(5);
	printVector(v1);
}

int main() {

	test01();

	system("pause");

	return 0;
}



</code></pre>
<p><img alt="" height="235" src="image\c2dce1b1d6444be78b717b8732b2ee85.png" width="468"/></p>
<p></p>
<p></p>
<p></p>
<h2 id="vector%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4">vector插入和删除</h2>
<blockquote>
<ul><li><code>push_back(ele);</code> //尾部插入元素ele</li><li><code>pop_back();</code> //删除最后一个元素</li><li><code>insert(const_iterator pos, ele);</code> //迭代器指向位置pos插入元素ele</li><li><code>insert(const_iterator pos, int count,ele);</code>//迭代器指向位置pos插入count个元素ele</li><li><code>erase(const_iterator pos);</code> //删除迭代器指向的元素</li><li><code>erase(const_iterator start, const_iterator end);</code>//删除迭代器从start到end之间的元素</li><li><code>clear();</code> //删除容器中所有元素</li></ul>
</blockquote>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt; 
using namespace std;

#include &lt;vector&gt;

void printVector(vector&lt;int&gt;&amp; v) {

	for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) {
		cout &lt;&lt; *it &lt;&lt; " ";
	}
	cout &lt;&lt; endl;
}

//插入和删除
void test01()
{
	vector&lt;int&gt; v1;
	//尾插
	v1.push_back(10);
	v1.push_back(20);
	v1.push_back(30);
	v1.push_back(40);
	v1.push_back(50);
	printVector(v1);
	//尾删
	v1.pop_back();
	printVector(v1);
	//插入
	v1.insert(v1.begin(), 100);
	printVector(v1);

	v1.insert(v1.begin(), 2, 1000);
	printVector(v1);

	//删除
	v1.erase(v1.begin());
	printVector(v1);

	//清空
	v1.erase(v1.begin(), v1.end());
	v1.clear();
	printVector(v1);
}

int main() {

	test01();

	system("pause");

	return 0;
}


</code></pre>
<blockquote>
<p>输出：</p>
<p>10 20 30 40 50<br/> 10 20 30 40<br/> 100 10 20 30 40<br/> 1000 1000 100 10 20 30 40<br/> 1000 100 10 20 30 40</p>
</blockquote>
<p></p>
<p></p>
<h2 id="vector%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96">vector数据存取</h2>
<blockquote>
<ul><li><code>at(int idx);</code> //返回索引idx所指的数据</li><li><code>operator[];</code> //返回索引idx所指的数据</li><li><code>front();</code> //返回容器中第一个数据元素</li><li><code>back();</code> //返回容器中最后一个数据元素</li></ul>
</blockquote>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt; 
using namespace std;
#include &lt;vector&gt;

void test01()
{
	vector&lt;int&gt;v1;
	for (int i = 0; i &lt; 10; i++)
	{
		v1.push_back(i);
	}

	for (int i = 0; i &lt; v1.size(); i++)
	{
		cout &lt;&lt; v1[i] &lt;&lt; " ";
	}
	cout &lt;&lt; endl;

	for (int i = 0; i &lt; v1.size(); i++)
	{
		cout &lt;&lt; v1.at(i) &lt;&lt; " ";
	}
	cout &lt;&lt; endl;

	cout &lt;&lt; "v1的第一个元素为： " &lt;&lt; v1.front() &lt;&lt; endl;
	cout &lt;&lt; "v1的最后一个元素为： " &lt;&lt; v1.back() &lt;&lt; endl;
}

int main() {

	test01();

	system("pause");

	return 0;
}

</code></pre>
<blockquote>
<p>输出：</p>
<p>0 1 2 3 4 5 6 7 8 9<br/> 0 1 2 3 4 5 6 7 8 9<br/> v1的第一个元素为： 0<br/> v1的最后一个元素为： 9</p>
</blockquote>
<p></p>
<p></p>
<p></p>
<p></p>
<h2 id="vector%E4%BA%92%E6%8D%A2%E5%AE%B9%E5%99%A8">vector互换容器</h2>
<blockquote>
<ul><li><code>swap(vec);</code> // 将vec与本身的元素互换</li></ul>
</blockquote>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt; 
using namespace std;
#include &lt;vector&gt;

void printVector(vector&lt;int&gt;&amp; v) {

	for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) {
		cout &lt;&lt; *it &lt;&lt; " ";
	}
	cout &lt;&lt; endl;
}

void test01()
{
	vector&lt;int&gt;v1;
	for (int i = 0; i &lt; 10; i++)
	{
		v1.push_back(i);
	}
	printVector(v1);

	vector&lt;int&gt;v2;
	for (int i = 10; i &gt; 0; i--)
	{
		v2.push_back(i);
	}
	printVector(v2);

	//互换容器
	cout &lt;&lt; "互换后" &lt;&lt; endl;
	v1.swap(v2);
	printVector(v1);
	printVector(v2);
}

void test02()
{
	vector&lt;int&gt; v;
	for (int i = 0; i &lt; 100000; i++) {
		v.push_back(i);
	}

	cout &lt;&lt; "v的容量为：" &lt;&lt; v.capacity() &lt;&lt; endl;
	cout &lt;&lt; "v的大小为：" &lt;&lt; v.size() &lt;&lt; endl;

	v.resize(3);

	cout &lt;&lt; "v的容量为：" &lt;&lt; v.capacity() &lt;&lt; endl;
	cout &lt;&lt; "v的大小为：" &lt;&lt; v.size() &lt;&lt; endl;

	//收缩内存
	vector&lt;int&gt;(v).swap(v); //匿名对象

	cout &lt;&lt; "v的容量为：" &lt;&lt; v.capacity() &lt;&lt; endl;
	cout &lt;&lt; "v的大小为：" &lt;&lt; v.size() &lt;&lt; endl;
}

int main() {

	test01();

	test02();

	system("pause");

	return 0;
}


</code></pre>
<blockquote>
<p>输出：</p>
<p>0 1 2 3 4 5 6 7 8 9<br/> 10 9 8 7 6 5 4 3 2 1<br/> 互换后<br/> 10 9 8 7 6 5 4 3 2 1<br/> 0 1 2 3 4 5 6 7 8 9<br/> v的容量为：131072<br/> v的大小为：100000<br/> v的容量为：131072<br/> v的大小为：3<br/> v的容量为：3<br/> v的大小为：3</p>
</blockquote>
<p>总结：swap可以使两个容器互换，可以达到实用的<strong>收缩内存</strong>效果</p>
<p></p>
<p></p>
<h2 id="vector%E9%A2%84%E7%95%99%E7%A9%BA%E9%97%B4">vector预留空间</h2>
<blockquote>
<p><code>reserve(int len);</code>//容器预留len个元素长度，预留位置不初始化，元素不可访问。</p>
</blockquote>
<p>vector开辟空间原理：</p>
<p>当空间不够时，会重新开辟一块更大的空间，将原来空间内容拷贝到这个更大的空间，并指向这块空间；<img alt="" height="472" src="image\ad12a0b12e0547febf47e1742b98899e.png" width="882"/></p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt; 
using namespace std;
#include &lt;vector&gt;

void test01()
{
	vector&lt;int&gt; v;

	//预留空间
	//v.reserve(100000);

	int num = 0;
	int* p = NULL;
	for (int i = 0; i &lt; 100000; i++) {
		v.push_back(i);
		if (p != &amp;v[0]) {
			p = &amp;v[0];
			num++;
		}
	}

	cout &lt;&lt; "num:" &lt;&lt; num &lt;&lt; endl;
}

int main() {

	test01();
    
	system("pause");

	return 0;
}


</code></pre>
<blockquote>
<p>输出：（不同编译器结果不同）</p>
<p> num:18</p>
</blockquote>
<p>利用开辟空间原理判断指向的地址是否改变，我们发现vector存100000个元素时要改变18次，即重新开辟并拷贝18次；这样非常耗费时间；</p>
<p>当我们使用reserve直接预留100000空间时，则只需要一次，非常节约时间</p>
<h3 id="%C2%A0reserve%EF%BC%88%EF%BC%89%E7%9A%84%E5%AE%9E%E7%8E%B0"> reserve（）的实现</h3>
<pre><code class="language-cpp">/* reserve */
void reserve(size_t new_capacity) {
	if (new_capacity &gt; capacity()) {  			// 检查是否真的需要扩容
		if (_finish == _eos) {
			size_t sz = size();   // 提前把size算好
 
			T* tmp = new T[new_capacity];
			if (_start) {
				// memcpy(tmp, _start, sizeof(T) * size());   有问题！
 
					//自己把原空间的数据拷贝到新空间
				for (size_t i = 0; i &lt; sz; i++) { 
					// 如果T是int，一个一个拷贝没问题
					// 如果T是string等自定义问题，一个一个拷贝调用的是T的深拷贝，也不会出问题。
					tmp[i] = _start[i];  
				}
					
				delete[] _start;                          // 并释放原有的旧空间
			}
 
			_start = tmp;                    // 指向新空间
			_finish = tmp + sz;			     // 现场算size() 会有问题，因为start已经被更新成tmp了
			_eos = _start + new_capacity;
		}
	}
}</code></pre>
<p></p>
<p></p>
<p></p>
<h1>vector迭代器失效问题</h1>
<h3>1、缺位删除</h3>
<p>下面这个代码输出的是？</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

#include &lt;vector&gt;

using namespace std;

int main(void)

{

	vector&lt;int&gt;array;

	array.push_back(100);

	array.push_back(300);

	array.push_back(300);

	array.push_back(300);

	array.push_back(300);

	array.push_back(500);

	vector&lt;int&gt;::iterator itor;

	for (itor = array.begin(); itor != array.end(); itor++)

	{

		if (*itor == 300)

		{

			itor = array.erase(itor);

		}

	}

	for (itor = array.begin(); itor != array.end(); itor++)

	{

		cout &lt;&lt; *itor &lt;&lt; " ";

	}

	return 0;

}</code></pre>
<blockquote>
<p> 100 500 ？？错误！！</p>
<p></p>
<p> for(itor=array.begin();itor!=array.end();itor++)</p>
<p>{<!-- --></p>
<p>        if(* itor==300) //向量的数据为300时进行删除</p>
<p>        {<!-- --></p>
<p>                //删除之后迭代器进行返回赋值，不会导致迭代器失效，删除当前数据，</p>
<p>                //后面的数据相当于会向前移动,此时itor还是指向下一个300数据，</p>
<p>                //但是由于循环回去，for循环末尾itor++会让迭代器指向下一个</p>
<p>                //数据，因此会错失一次300的比较判断</p>
<p>                itor=array.erase(itor);</p>
<p>        }</p>
<p>}</p>
<p>所以答案为: 100 300 300 500 </p>
</blockquote>
<p></p>
<h3>2、删除导致迭代器失效</h3>
<p>结果是？</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

#include &lt;vector&gt;

using namespace std;

int main()

{

	int ar[] = { 1,2,3,4,0,5,6,7,8,9 };

	int n = sizeof(ar) / sizeof(int);

	vector&lt;int&gt; v(ar, ar + n);

	vector&lt;int&gt;::iterator it = v.begin();

	while (it != v.end())

	{

		if (*it != 0)

			cout &lt;&lt; *it;

		else
		{
			v.erase(it);
			*it=5;
		}
		it++;
	}

	return 0;

}

</code></pre>
<blockquote>
<p>A.程序运行崩溃</p>
<p>B.1 2 3 4 5 0 6 7 8 9</p>
<p>C.1 2 3 4 5 6 7 8 9</p>
<p>D.1 2 3 4 6 7 8 9</p>
<hr/>
<p>分析:当迭代器的值为0时，此时会进行删除，删除后如果迭代器不重新赋值，会导致原来的迭代器失效，此时针对一个已经失效的迭代器在进行++,会导致程序崩溃</p>
<p>故答案为A</p>
</blockquote>
<hr/>
<p></p>
<h1 id="vector%E7%9A%84%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0">vector的增删查改的模拟实现</h1>
<p>函数接口：</p>
<pre><code class="language-cpp">namespace bit

{

  template&lt;class T&gt;

  class vector

  {

  public:

    // Vector的迭代器是一个原生指针

    typedef T* iterator；

    typedef const T* const_iterator；

    iterator begin()；

    iterator end()；

    const_iterator cbegin()；

    const_iterator cend() const；



    // construct and destroy

    vector()；

    vector(int n, const T&amp; value = T())；

    template&lt;class InputIterator&gt;

    vector(InputIterator first, InputIterator last)；

    vector(const vector&lt;T&gt;&amp; v)；

    vector&lt;T&gt;&amp; operator= (vector&lt;T&gt; v)；

    ~vector()；

    // capacity

    size_t size() const ；

    size_t capacity() const；

    void reserve(size_t n)；

    void resize(size_t n, const T&amp; value = T())；



    ///access///

    T&amp; operator[](size_t pos)；

    const T&amp; operator[](size_t pos)const；



    ///modify/

    void push_back(const T&amp; x)；

    void pop_back()；

    void swap(vector&lt;T&gt;&amp; v)；

    iterator insert(iterator pos, const T&amp; x)；

    iterator erase(Iterator pos)；

  private:

    iterator _start; // 指向数据块的开始

    iterator _finish; // 指向有效数据的尾

    iterator _endOfStorage; // 指向存储容量的尾

  };

}</code></pre>
<p> 模拟实现</p>
<pre><code class="language-cpp">namespace bit
{
  template&lt;class T&gt;
  class vector
  {
  public:
    // Vector的迭代器是一个原生指针

    typedef T* iterator；

    typedef const T* const_iterator；

    iterator begin()
    {
      return _start;
    }
    iterator end()
    {
      return _finish;
    }
    const_iterator cbegin()const
    {
      return _start;
    }
    const_iterator cend() const
    {
      return _finish;
    }


    // construct and destroy
    vector(): _start(nullptr), _finish(nullptr), _endOfStorage(nullptr)
    {}
    vector(int n, const T&amp; value = T())
      : _start(nullptr), _finish(nullptr),_endOfStorage(nullptr)
    {
      reserve(n);
      while (n--)
      {
        push_back(value);
      }
    }

    template&lt;class InputIterator&gt;

    vector(InputIterator first, InputIterator last)
    {
      reserve(last - first);
      while (first != last)
      {
        push_back(*first);
        ++first;
      }
    }

    vector(const vector&lt;T&gt;&amp; v)
      : _start(nullptr), _finish(nullptr), _endOfStorage(nullptr)
    {
      reserve(v.capacity());
      iterator it = begin();
      const_iterator vit = v.cbegin();
      while (vit != v.cend())
      {
       *it++ = *vit++;
      }
      _finish = _start + v.size();
      _endOfStorage = _start + v.capacity();
    }

    vector&lt;T&gt;&amp; operator= (vector&lt;T&gt; v)
    {
      swap(v);
      return *this;
    }

    ~vector()
    {
      delete[] _start;
      _start = _finish = _endOfStorage = nullptr;
    }


    // capacity
    size_t size() const 
    {
      return _finish - _start;
    }

    size_t capacity() const
    {
      return _endOfStorage - _start;
    }

    void reserve(size_t n)
    {

      if (n &gt; capacity())
      {
        size_t oldSize = size();
        T* tmp = new T[n];
        if (_start)
        {
          for (size_t i = 0; i &lt; oldSize; ++i)
          tmp[i] = _start[i];
        }
        _start = tmp;
        _finish = _start + size;
        _endOfStorage = _start + n;
      }

    }

    void resize(size_t n, const T&amp; value = T())
    {
      // 1.如果n小于当前的size，则数据个数缩小到n
      if (n &lt;= size())
      {
        _finish = _start + n;
        return;
      }

      // 2.空间不够则增容
      if (n &gt; capacity())
       reserve(n);

      // 3.将size扩大到n
      iterator it = _finish;
      iterator _finish = _start + n;
      while (it != _finish)
      {
        *it = value;
        ++it;
      }
    }

    ///access///

    T&amp; operator[](size_t pos)
    {
      return _start[pos];
    }

    const T&amp; operator[](size_t pos)const
    {
      return _start[pos];
    }


    ///modify/

    void push_back(const T&amp; x)
    {
      insert(end(), x);
    }

    void pop_back()
    {
      erase(--end());
    }

    void swap(vector&lt;T&gt;&amp; v)
    {
      swap(_start, v._start);
      swap(_finish, v._finish);
      swap(_endOfStorage, v._endOfStorage);
    }

    iterator insert(iterator pos, const T&amp; x)
    {
      assert(pos &lt;= _finish);

      // 空间不够先进行增容
      if (_finish == _endOfStorage)
      {
        size_t size = size();
        size_t newCapacity = (0 == capacity())? 1 : capacity() * 2;
        reserve(newCapacity);

        // 如果发生了增容，需要重置pos
        pos = _start + size;
      }

      iterator end = _finish - 1;
      while (end &gt;= pos)
      {
        *(end + 1) = *end;
        --end;
      }
      *pos = x;
      ++_finish;
      return pos;
    }


    // 返回删除数据的下一个数据

// 方便解决:一边遍历一边删除的迭代器失效问题

    iterator erase(Iterator pos)
    {
      // 挪动数据进行删除
      iterator begin = pos + 1;
      while (begin != _finish) 
      {
        *(begin - 1) = *begin;
        ++begin;
      }
      --_finish;
      return pos;
    }
  private:
    iterator _start; // 指向数据块的开始
    iterator _finish; // 指向有效数据的尾
    iterator _endOfStorage; // 指向存储容量的尾

  };

}</code></pre>
<p></p>
<h1 id="%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE%E7%BB%83%E4%B9%A0%C2%A0">经典题目练习 </h1>
<h2 id="1.%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92OJ">1.<span style="color:#4183c4;">杨辉三角</span><span style="color:#4183c4;">OJ</span></h2>
<p><img alt="" height="981" src="image\c898850bfa7c4107b15919a168363581.png" width="839"/></p>
<blockquote>
<p>模拟；练一练二维vector </p>
</blockquote>
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; generate(int numRows) {
        vector&lt;vector&lt;int&gt;&gt; vv;
        vv.resize(numRows);
        for(size_t i=1;i&lt;=numRows;i++)
        {
            vv[i-1].resize(i,0);

            vv[i-1][0]=1;
            vv[i-1][i-1]=1;
        }

        for(int i=0;i&lt;vv.size();i++)
        {
            for(int j=0;j&lt;vv[i].size();j++){
                if(vv[i][j]==0)
                {
                    vv[i][j]=vv[i-1][j]+vv[i-1][j-1];
                }
            }
        }
        return vv;
    }
};</code></pre>
<p></p>
<p></p>
<h2 id="2.%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9%20OJ"><span style="color:#4183c4;">2.删除排序数组中的重复项</span><span style="color:#4183c4;"> OJ </span></h2>
<p><img alt="" height="733" src="image\d3a528bf477a462482789a580558108d.png" width="840"/></p>
<blockquote>
<p> 快慢指针：</p>
<p>所谓快：不加条件判断的数组下标累计<br/> 所谓慢：加上条件判断的数组下标累计</p>
</blockquote>
<div>
<pre><code class="language-cpp">class Solution {
public:
    int removeDuplicates(vector&lt;int&gt;&amp; nums) {
        int n=nums.size();
        if(n==0){
            return 0;
        }
        int fast=1,slow=1;
        while(fast&lt;n)
        {
            if(nums[fast]!=nums[fast-1]){
                nums[slow]=nums[fast];
                slow++;
            }
            fast++;
        }
        return slow;
    }
};</code></pre>
<p></p>
</div>
<div></div>
<h2 id="3.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97%C2%A0"><span style="color:#777777;">3. </span><span style="color:#4183c4;">数组中出现次数超过一半的数字</span><span style="color:#4183c4;"> </span></h2>
<p><img alt="" height="903" src="image\cd5c5f7052984799a327b5e228507aec.png" width="1088"/></p>
<blockquote>
<p><strong>最优解：<span style="color:#fe2c24;">候选法</span> </strong></p>
<p>思想就是：如果两个数不相等，就消去这两个数，最坏情况下，每次消去一个众数和一个非众数，那么如果存在众数，最后留下的数肯定是众数（因为超过数组一半）。</p>
<ol><li>假设cond为候选人，cnt为票数（要找到票最多的当选）；</li><li>如果cnt为0，说明没有候选人或者该候选人票不够选不了；</li><li>否则，如果cnt &gt; 0, 表示有候选人，如果当前数=cond，则++cnt，否则--cnt</li></ol>
</blockquote>
<div>
<pre><code class="language-cpp">class Solution {
public:
    int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers) {
        int cond = 0;
        int cnt = 0;
        for (int i=0; i&lt;numbers.size(); ++i) 
        {
            if (cnt == 0) 
            {
                cond = numbers[i];
                ++cnt;
            }
            else
            {
                if (cond == numbers[i]) ++cnt;
                else --cnt;
            }
        }
        return cond;
    }
};</code></pre>
<p></p>
<p></p>
</div>
<h2 id="4.%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97"><a href="https://leetcode.cn/problems/single-number/" title="4.只出现一次的数字">4.只出现一次的数字</a></h2>
<p><img alt="" height="480" src="image\3a918d89287548739e6e825560adf380.png" width="1047"/></p>
<blockquote>
<p>不需要额外空间的方法，就往位运算上想</p>
<ol><li> <p>交换律：a ^ b ^ c &lt;=&gt; a ^ c ^ b</p> </li><li> <p>任何数于0异或为任何数 0 ^ n =&gt; n</p> </li><li> <p>相同的数异或为0: n ^ n =&gt; 0</p> </li></ol>
</blockquote>
<div>
<pre><code class="language-cpp">class Solution {
public:
    int singleNumber(vector&lt;int&gt;&amp; nums) {
        int ret=0;
        for(auto e:nums)
            ret^=e;
        return ret;
    }
};</code></pre>
<p></p>
</div>
<h2 id="5.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88"><span style="color:#777777;">5.</span><span style="color:#4183c4;">电话号码字母组合</span></h2>
<p><img alt="" height="878" src="image\8556e549f286474a8a9149b1eced3402.png" width="883"/></p>
<p><img alt="" height="417" src="image\9f914ece2ee742f09346a390419665c6.png" width="703"/></p>
<blockquote>
<p> 思路：</p>
<p>由题意知就是把字母一一组合；</p>
<ol><li>首先使用哈希表存储每个数字对应的所有可能的字母，然后进行回溯操作</li><li>假设输入“234”，进入递归，首先获得str第一个字符‘2’然后转成数字，取数字映射的字符串</li><li>开始遍历字符“abc”，刚取到‘a’时再进入递归取第二个字符‘3’，取数字映射的字符串“def”后开始遍历，以此类推我们的combineStr为“adg”</li><li>取到“adg”时就到顶了，利用di==digits.size()判断，将取到的组合数保存到retV并开始回溯；</li><li>由auto ch : str 我们会遍历“ghi”，按照上述同理方法得到“adh”,“adi”，然后回溯到第二次取‘e’，同理得“aeg”，“aeh”，“aei”</li><li>最终取到3*3*3种排列</li></ol>
<p>回溯算法用于寻找所有的可行解，如果发现一个解不可行，则会舍弃不可行的解。在这道题中，由于每个数字对应的每个字母都可能进入字母组合，因此不存在不可行的解，直接穷举所有的解即可。</p>
</blockquote>
<pre><code class="language-cpp">class Solution {
    string nums[10]={"","","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"};
public:
    void Combine(string digits,int di,string combineStr,vector&lt;string&gt;&amp; retV)
    {
        if(di==digits.size())
        {
            retV.push_back(combineStr);
            return;
        }
        int num=digits[di]-'0';
        string str=nums[num];

        for(auto ch:str)
        {
            Combine(digits,di+1,combineStr+ch,retV);
        }
    }
    vector&lt;string&gt; letterCombinations(string digits) {
        vector&lt;string&gt; retV;
        if(digits.empty())
            return retV;
        int i=0;
        string str;
        Combine(digits,i,str,retV);
        return retV;
    }
};</code></pre>
<p>顺手打败全国的人~~ </p>
<p><img alt="" height="434" src="image\5da1f0e6304e4a25a0f57493a983b17d.png" width="1200"/></p>
<p></p>
<p></p>
<div></div>
<h2 id="6.%C2%A0%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C%20%C2%A0"><span style="color:#777777;">6. </span><span style="color:#4183c4;">连续子数组的最大和</span><span style="color:#4183c4;"> </span> </h2>
<div></div>
<div>
<p><img alt="" height="767" src="image\b6597488ad694597a650c675175f63e2.png" width="1200"/></p>
</div>
<blockquote>
 经典动态规划 
 <ul><li>step 1：可以用dp数组表示以下标 i 为终点的最大连续子数组和。</li><li>step 2：遍历数组，每次遇到一个新的数组元素，连续的子数组要么加上变得更大，要么这个元素本身就更大，要么会更小，更小我们就舍弃，因此状态转移为dp[i]=max(dp[i−1]+array[i],array[i])                                                                                  </li><li>step 3：因为连续数组可能会断掉，每一段只能得到该段最大值，因此我们需要维护一个最大值。</li></ul>
</blockquote>
<pre><code class="language-cpp">class Solution {
public:
    int FindGreatestSumOfSubArray(vector&lt;int&gt; array) {
        vector&lt;int&gt; dp(array.size(),0);
        dp[0]=array[0];
        int maxv=dp[0];
        for(int i=1;i&lt;array.size();i++)
        {
            dp[i]=max(dp[i-1]+array[i],array[i]);
            maxv=max(maxv,dp[i]);
        }
        return maxv;
    }
};</code></pre>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
</div>
</div>