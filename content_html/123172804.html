<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<p>  <img alt="" height="109" src="image\451dfef5a53e4c94a3ecbfb02d167973.png" width="286"/>  ​​​​​​ 🤣 爆笑教程 👉  <a href="https://blog.csdn.net/weixin_50502862/category_11602059.html" title="《C++要笑着学》">《C++要笑着学》</a> 👈 火速订阅<strong>  </strong>🔥<img alt="" height="123" src="image\32974baa747043f9907e5bbd13639957.png" width="679"/><span title="点击并拖拽以改变尺寸">​</span></p>
<div>
<p class="img-center"><img alt="" height="140" src="image\e93da4c927c947788f55506404f2eb3e.png" width="466"/><span title="点击并拖拽以改变尺寸">​</span></p>
</div>
<p id="main-toc"><strong>💭 写在前面</strong></p>
<p>本章将对<strong>C++</strong>的基础，<strong>引用 </strong>部分的知识进行讲解。</p>
<p>有些地方为了能够加深理解，我们会举几个比较有意思的栗子，在讲解的同时会适当的整活。</p>
<p>我觉得这篇博客是我目前写的最好的一篇，希望大家能看到底！</p>
<p>如果觉得文章不错，可以 "一键三连" 支持一下博主！你们的关注就是我更新的最大动力！</p>
<p></p>
<hr/>
<h2 id="%E2%85%A0.%C2%A0%E5%BC%95%E7%94%A8%E7%9A%84%E6%A6%82%E5%BF%B5">Ⅰ. 引用的概念</h2>
<h3 id="0x00%20%E5%BC%95%E5%85%A5%E8%AF%9D%E9%A2%98">0x00 引入话题</h3>
<p><img alt="" height="29" src="image\9f0f94bb1a254f1c96b8550c9b52faae.png" width="31"/><span title="点击并拖拽以改变尺寸">​</span>不知道大伙知不知道<em> "抓捕周树人跟我鲁迅有什么关系" </em> 这个梗 ~ </p>
<p><img alt="" height="551" src="image\bc2d75887fc6466c8116a19553044f4f.png" width="416"/><span title="点击并拖拽以改变尺寸">​</span></p>
<p>这段是2018年电视剧《楼外楼》中鲁迅先生的一段台词。剧中一个没文化的军官带着一批人要来抓捕周树人，鲁迅让他们拿出搜捕令，他们拿了出来，鲁迅看过之后就说：抓捕周树人和我鲁迅有什么关系？于是这群人都以为是抓错人了，就走了。</p>
<p>这一段其实是在嘲讽他们没有文化，连作家的笔名都不知道。</p>
<p>"抓捕周树人跟我鲁迅有什么关系" ，当然有关系了！哈哈哈哈哈哈。</p>
<p></p>
<p><img alt="" height="294" src="image\32e8c56a19c445ee94b996c3dd3fdd70.png" width="433"/><span title="点击并拖拽以改变尺寸">​</span></p>
<p>后来这个军官才知道鲁迅是周树人的笔名，他们要抓的人正是鲁迅。</p>
<p>🔺 这个 "笔名" 其实就是<strong>引用</strong>，我们继续往下学习。</p>
<p></p>
<h3 id="0x01%20%E6%A6%82%E5%BF%B5">0x01 什么是引用</h3>
<p>😂 第一次接触 "引用" 的概念时，直接看词去理解，真的会让人一脸懵逼……</p>
<p>但是如果用 "取别名" 或 "取绰号" 来理解，就没有那么难以理解了。</p>
<p><img alt="" height="359" src="image\6f2c22f6cb9844efbac50881eb230bd2.png" width="514"/><span title="点击并拖拽以改变尺寸">​</span></p>
<p></p>
<p>🤔 但是如果用 "取别名" 或 "取绰号" 来理解，就没有那么难以理解了。</p>
<p>📚 概念：引用就是给一个已经存在的变量取一个别名。</p>
<p></p>
<p>📜 语法：<span style="color:#ad720d;">数据类型</span><span style="color:#be191c;"><strong>&amp;</strong></span>  引用名<strong> =</strong>  引用实体；</p>
<p>                               👆 这里的&amp;可不是取地址啊！它是放在数据类型后面的<span style="color:#be191c;"><strong>&amp;</strong></span>，一定要区分开来！</p>
<p>💬 代码演示：</p>
<div>
<pre><code class="language-cpp hljs"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
</span>{
    <span class="hljs-type">int</span> ZhouShuRen = <span class="hljs-number">1881</span>;
    <span class="hljs-type">int</span>&amp; LuXun = ZhouShuRen;  <span class="hljs-comment">// 鲁迅就是周树人的引用</span>

    cout &lt;&lt; ZhouShuRen &lt;&lt; endl;
    cout &lt;&lt; LuXun &lt;&lt; endl;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>
</div>
<blockquote>
<p>🚩 运行结果： 1881 1881</p>
</blockquote>
<p>🔑 解读：</p>
<p>引用在语法层，我们要理解这里没有开新空间，就是对原来的取了一个新名称而已。</p>
<p><img alt="" height="75" src="image\9292c0ac56124e81b5b549db776a831b.png" width="244"/><span title="点击并拖拽以改变尺寸">​</span></p>
<p></p>
<p>📌 注意事项：</p>
<p>① 引用并不是新定义一个变量，只是给一个变量取别名。</p>
<p>② 编译器不会为引用的变量开辟内存空间，它和它引用的变量会共用同一块内存空间。</p>
<p><img alt="" height="226" src="image\6ce8577110be46a8954ff60cb639653e.png" width="429"/><span title="点击并拖拽以改变尺寸">​</span></p>
<p></p>
<p></p>
<p></p>
<h3 id="0x02%20%E5%BC%95%E7%94%A8%E7%9A%84%E7%89%B9%E6%80%A7">0x02 引用的特性</h3>
<p><img alt="" height="85" src="image\d10eba70d3a5494e965706b3ede7da8b.png" width="85"/><span title="点击并拖拽以改变尺寸">​</span> <strong>引用在定义时必须初始化！</strong></p>
<p>初始化时必须要指定清楚，你到底是要给谁取别名。</p>
<p><img alt="" height="123" src="https://img-blog.csdnimg.cn/73fbaabc6d704730b0622ae97e0b2cf3.gif" width="149"/><span title="点击并拖拽以改变尺寸">​</span>含糊不清是不行的，你都不知道要给谁取别名，你取他干甚呢？</p>
<p></p>
<p>💬 又到了大伙最爱的踩坑环节：</p>
<div>
<pre><code class="language-cpp hljs"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
</span>{
    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;
    <span class="hljs-type">int</span>&amp; b;      <span class="hljs-comment">// ❌</span>

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>
</div>
<p><img alt="" height="291" src="image\f4759f50d79048be8f193e0e2c0491d1.png" width="1147"/><span title="点击并拖拽以改变尺寸">​</span></p>
<p></p>
<p><img alt="" height="71" src="image\475293de0d294403b2fbf16515c748ce.png" width="89"/><span title="点击并拖拽以改变尺寸">​</span> <strong>一个变量可以有多个引用。</strong></p>
<p>一个人当然可以有多个绰号，所以一个变量也可以有多个别名。</p>
<p></p>
<p>💬 代码演示：（川普  川建国  懂王）</p>
<div>
<pre><code class="language-cpp hljs"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
</span>{
    <span class="hljs-type">int</span> Trump = <span class="hljs-number">2333</span>;           <span class="hljs-comment">// 变量</span>
    <span class="hljs-type">int</span>&amp; ChuanJianGuo = Trump;  <span class="hljs-comment">// 引用1</span>
    <span class="hljs-type">int</span>&amp; DongWang = Trump;      <span class="hljs-comment">// 引用2</span>

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
</div>
<p></p>
<p><img alt="" height="70" src="image\30b2d2973eea4578b56d50710ecc672e.png" width="84"/><span title="点击并拖拽以改变尺寸">​</span> <strong>引用一旦引用了一个实体，就不能引用其他实体了。 </strong></p>
<div>
<pre><code class="language-cpp hljs"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
</span>{
	<span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;
	<span class="hljs-type">int</span>&amp; ra = a;

	<span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;
	ra = b;       <span class="hljs-comment">// ?</span>

	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>
</div>
<p>（这里取名为 <strong>ra</strong>，因为引用的英文是 reference，所以我后面命名变量时会简写为<strong> r</strong>，或者 <strong>ref </strong>来代表引用）</p>
<p>❓ 问号处是什么意思呢？这里是让<strong> ra </strong>变成 <strong>b </strong>的别名，还是把<strong> b</strong> 的值赋值给 <strong>ra </strong>呢？</p>
<p>💡 这里是赋值，我们打开监视窗口看一下：</p>
<p><img alt="" height="214" src="image\8c77913af4dc4cf0996091df69ccafaf.png" width="585"/><span title="点击并拖拽以改变尺寸">​</span></p>
<p></p>
<p>🔺 引用是不会变的，我们定义它的时候它是谁的别名，就是谁的别名了。</p>
<p>以后就不会改了，它是从一而终的！！！</p>
<p></p>
<p>💬 引用和指针是截然不同的，指针是可以改变指向的：</p>
<div>
<pre><code class="language-cpp hljs"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
</span>{
    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;
    <span class="hljs-type">int</span>* p1 = &amp;a;

    <span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;
    p1 = &amp;b;  <span class="hljs-comment">// 改变指针指向</span>

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>
</div>
<p>🔑 解析：指针在这里就像极了渣男！</p>
<p><img alt="" height="850" src="image\6038058d56a0497698d4cc9999f0f602.png" width="1200"/><span title="点击并拖拽以改变尺寸">​</span></p>
<p>📚 这里再提一句，引用的底层其实就是指针。</p>
<p>你可以这么理解，引用他不想像以前那样做渣男了，于是回炉重造！</p>
<p><strong>《重生之我不是渣男》</strong>，开始一生只爱一个人了！</p>
<p><img alt="" height="213" src="image\0f7aaa544140424eb18ecb985eb58f2b.png" width="317"/><span title="点击并拖拽以改变尺寸">​</span></p>
<p></p>
<p></p>
<h2 id="%E2%85%A1.%20%E5%BC%95%E7%94%A8%E7%9A%84%E5%BA%94%E7%94%A8">Ⅱ. 引用的应用</h2>
<h3 id="0x00%C2%A0%E5%BC%95%E5%85%A5">0x00 引入</h3>
<p><img alt="" height="48" src="image\8447ae82110f472ca65e2721b52a444e.png" width="48"/><span title="点击并拖拽以改变尺寸">​</span>  平常这么写其实没什么意义：</p>
<div>
<pre><code class="language-cpp hljs"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;
<span class="hljs-type">int</span>&amp; ra = a;</code></pre>
</div>
<p>❗  它真正有用的地方在于它能够做参数和做返回值。</p>
<p></p>
<h3 id="0x01%C2%A0%E5%BC%95%E7%94%A8%E5%81%9A%E5%8F%82%E6%95%B0"><strong>0x01 引用做参数</strong></h3>
<p><img alt="" height="42" src="https://img-blog.csdnimg.cn/049e504e0b5c4a2f955bc88512f952b7.gif" width="42"/><span title="点击并拖拽以改变尺寸">​</span> 我们在C语言教学中讲过<span style="color:#4da8ee;"> Swap </span>两数交换的三种方式。 </p>
<p>我们当时用的最多的就是利用临时变量去进行交换。</p>
<p>如果把它写成函数形式就是这样：</p>
<div>
<pre><code class="language-cpp hljs"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Swap</span><span class="hljs-params">(<span class="hljs-type">int</span>* px, <span class="hljs-type">int</span>* py)</span> </span>{
    <span class="hljs-type">int</span> tmp = *px;
    *px = *py;
    *py = tmp;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
</span>{
    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;
    <span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;
    <span class="hljs-built_in">Swap</span>(&amp;a, &amp;b);  <span class="hljs-comment">// 传址</span>

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>
</div>
<p><img alt="" height="55" src="image\8556924c96cf46dab933317613df8c9c.png" width="66"/><span title="点击并拖拽以改变尺寸">​</span> 这里我们调用 <span style="color:#4da8ee;">Swap</span> 函数需要传地址，</p>
<p>因为形参是实参的一份临时拷贝，改变形参并不会对实参产生实质性的影响。</p>
<p></p>
<p>💬 但是，我们学了引用之后我们就可以这么玩：</p>
<p><img alt="" height="204" src="image\6c4270f5b468490f904863491c11dd72.png" width="141"/><span title="点击并拖拽以改变尺寸">​</span>  </p>
<div>
<pre><code class="language-cpp hljs"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Swap</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; ra, <span class="hljs-type">int</span>&amp; rb)</span> </span>{
    <span class="hljs-type">int</span> tmp = ra;
    ra = rb;
    rb = tmp;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
</span>{
    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;
    <span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;
    <span class="hljs-built_in">Swap</span>(a, b);  <span class="hljs-comment">// 这里既没有传值，也没有传地址，而是传引用</span>

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>
</div>
<blockquote>
<p>🔍 监视结果如下：</p>
</blockquote>
<p><img alt="" height="358" src="image\b47ec1fb0b284201b1fe3faa8a95fe26.png" width="980"/><span title="点击并拖拽以改变尺寸">​</span></p>
<p></p>
<p></p>
<p>❓ 是怎么做到交换的？</p>
<p>🔑 我们知道，形参是定义在栈帧里面的。</p>
<p>实际调用这个函数的时候，才会给 <strong>ra</strong> 和 <strong>rb</strong> 开空间。调用这个函数的时候，把实参传给形参。</p>
<p>那什么时候开始定义的？实参传给形参的时候开始定义的。</p>
<p><strong>ra</strong> 是 <strong>a</strong> 的别名，<strong>rb</strong> 是 <strong>b </strong>的别名，所以 <strong>ra</strong> 和 <strong>rb </strong>的交换，就是<strong> a</strong> 和 <strong>b</strong> 的交换。</p>
<p>因此，我们利用这一特点，就可以轻松实现两数的交换。</p>
<p></p>
<p>🔺 我们来梳理一下，顺带复习一下之前讲的函数重载。 </p>
<p>💬 现在我们一共学了三种传参方式：传值、传地址、传引用。</p>
<div>
<pre><code class="language-cpp hljs"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Swap</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{
    <span class="hljs-type">int</span> tmp = x;
    x = y;
    y = tmp;
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Swap</span><span class="hljs-params">(<span class="hljs-type">int</span>* px, <span class="hljs-type">int</span>* py)</span> </span>{
    <span class="hljs-type">int</span> tmp = *px;
    *px = *py;
    *py = tmp;
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Swap</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; rx, <span class="hljs-type">int</span>&amp; ry)</span> </span>{
    <span class="hljs-type">int</span> tmp = rx;
    rx = ry;
    ry = tmp;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
</span>{
    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;
    <span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;

    <span class="hljs-built_in">Swap</span>(&amp;a, &amp;b);
    <span class="hljs-built_in">Swap</span>(a, b);  <span class="hljs-comment">// 报错 ❌  </span>

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
</div>
<p><img alt="" height="109" src="image\e4f05510b9534f5aa4e667641cddf4e6.png" width="106"/><span title="点击并拖拽以改变尺寸">​</span> 这里 <span style="color:#4da8ee;">Swap</span>(a，b) 为什么会报错呢？</p>
<p>这三个 <span style="color:#4da8ee;">Swap </span>是可以构成函数重载的，</p>
<p>只要不影响它的函数名修饰规则，就不会构影响！</p>
<p>换言之，修饰出来的函数名不一样，就支持重载！</p>
<blockquote>
<p>void Swap(int x, int y);              _Z4swapixiy</p>
<p>void Swap(int* px, int* py);       _Z4swaprxry</p>
<p>void Swap(int&amp; rx, int&amp; ry);       _Z4swappxpy</p>
</blockquote>
<p><img alt="" height="100" src="https://img-blog.csdnimg.cn/e8fb183775dd4cdaa1f21ff7b273ad70.gif" width="100"/><span title="点击并拖拽以改变尺寸">​</span>但是 <span style="color:#4da8ee;">Swap</span>(a，b) 调用时存在歧义。调用不明确！</p>
<p>它不知道调用哪一个，是传值还是传引用，所以会报错。</p>
<p></p>
<p>当时再讲数据结构单链表的时候用的是二级指针，当时没有采用头结点的方式。</p>
<p>那么要传指针的地址，自然要用二级指针的方式接收。</p>
<p>现在我们学了引用，我们就可以试着用引用的方法来解决了（这里我们把<strong> .c</strong> 改为<strong> .cpp</strong>）</p>
<p></p>
<p><img alt="" height="50" src="image\c64467505c6e4794b79067474c14a2d9.png" width="46"/><span title="点击并拖拽以改变尺寸">​</span> 任何类型都是可以取别名的，指针也不例外：</p>
<div>
<pre><code class="language-cpp hljs"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;
<span class="hljs-type">int</span>&amp; ra = a;

<span class="hljs-type">int</span>* pa = &amp;a;
<span class="hljs-type">int</span>*&amp; rpa = pa</code></pre>
</div>
<p></p>
<p><img alt="" height="52" src="image\18834be9f1854c218e1bfbaba4bdf6b5.png" width="52"/><span title="点击并拖拽以改变尺寸">​</span> 我们来看如何用引用的方法来实现！</p>
<p>💬 SList.h：</p>
<div>
<pre><code class="language-cpp hljs"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span>

<span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> SLNodeDataType;

<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="class_ hljs-title">SingleListNode</span> {
    SLNodeDataType data;           <span class="hljs-comment">// 用来存放节点的数据</span>
    <span class="hljs-keyword">struct</span> <span class="class_ hljs-title">SingleListNode</span>* next;   <span class="hljs-comment">// 指向后继节点的指针</span>
} SLNode;                          

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SListPrint</span><span class="hljs-params">(SLNode* pHead)</span></span>;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SListPushBack</span><span class="hljs-params">(SLNode*&amp; rpHead, SLNodeDataType x)</span></span>;
<span class="hljs-comment">// ... 略</span></code></pre>
</div>
<p></p>
<p>💬 SList.cpp：</p>
<div>
<pre><code class="language-cpp hljs"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"SList.h"</span></span>

<span class="hljs-comment">/* 打印 */</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SListPrint</span><span class="hljs-params">(SLNode* pHead)</span> </span>{
    SLNode* cur = pHead;
    <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">NULL</span>) {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d -&gt; "</span>, cur-&gt;data);
        cur = cur-&gt;next;
    }
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"NULL\n"</span>);
}

<span class="hljs-comment">/* 创建新节点 */</span>
<span class="hljs-function">SLNode* <span class="hljs-title">CreateNewNode</span><span class="hljs-params">(SLNodeDataType x)</span> </span>{
    <span class="hljs-comment">//创建，开辟空间</span>
    SLNode* new_node = (SLNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(SLNode));
    <span class="hljs-comment">//malloc检查</span>
    <span class="hljs-keyword">if</span> (new_node == <span class="hljs-literal">NULL</span>) {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"malloc failed!\n"</span>);
        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);
    }
    <span class="hljs-comment">//放置</span>
    new_node-&gt;data = x; <span class="hljs-comment">//存传入的数据</span>
    new_node-&gt;next = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">//next默认置空</span>

    <span class="hljs-keyword">return</span> new_node; <span class="hljs-comment">//递交新节点</span>
}

<span class="hljs-comment">/* 尾插（指针的引用） */</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SListPushBack</span><span class="hljs-params">(SLNode*&amp; rpHead, SLNodeDataType x)</span> </span>{
    <span class="hljs-comment">//创建新节点</span>
    SLNode* new_node = <span class="hljs-built_in">CreateNewNode</span>(x);
    <span class="hljs-comment">//如果链表是空的</span>
    <span class="hljs-keyword">if</span> (rpHead == <span class="hljs-literal">NULL</span>) {
        <span class="hljs-comment">//直接插入即可</span>
        rpHead = new_node;
    }
    <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">//找到尾结点</span>
        SLNode* end = rpHead;
        <span class="hljs-keyword">while</span> (end-&gt;next != <span class="hljs-literal">NULL</span>) {
            end = end-&gt;next; <span class="hljs-comment">//令end指向后继节点</span>
        }
        <span class="hljs-comment">//插入</span>
        end-&gt;next = new_node;
    }
}</code></pre>
</div>
<p>🔑 解读： 这里的 <span style="color:#ad720d;">SLNode*</span><span style="color:#be191c;"><strong>&amp;</strong></span><strong> rpHead</strong> 就是<strong> pHead</strong> 的一个别名。</p>
<p></p>
<p>💬 Test.cpp：</p>
<div>
<pre><code class="language-cpp hljs"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"SList.h"</span></span>

<span class="hljs-comment">// 这里我们不传二级指针了。</span>
<span class="hljs-comment">//void TestSList1()</span>
<span class="hljs-comment">//{<!-- --></span>
<span class="hljs-comment">//	SLNode* pList = NULL;</span>
<span class="hljs-comment">//	SListPushBack(&amp;pList, 1);</span>
<span class="hljs-comment">//	SListPushBack(&amp;pList, 2);</span>
<span class="hljs-comment">//	SListPushBack(&amp;pList, 3);</span>
<span class="hljs-comment">//	SListPushBack(&amp;pList, 4);</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//	SListPrint(pList);</span>
<span class="hljs-comment">//}</span>

<span class="hljs-comment">// 使用引用的方法：</span>
<span class="hljs-comment">// 我们传 指针的 引用！</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TestSList2</span><span class="hljs-params">()</span>
</span>{
	SLNode* pList = <span class="hljs-literal">NULL</span>;
	<span class="hljs-built_in">SListPushBack</span>(pList, <span class="hljs-number">1</span>);
	<span class="hljs-built_in">SListPushBack</span>(pList, <span class="hljs-number">2</span>);
	<span class="hljs-built_in">SListPushBack</span>(pList, <span class="hljs-number">3</span>);
	<span class="hljs-built_in">SListPushBack</span>(pList, <span class="hljs-number">4</span>);

	<span class="hljs-built_in">SListPrint</span>(pList);
}


<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
	<span class="hljs-built_in">TestSList2</span>();

	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>
</div>
<p>🔑 解读：这里我们采用引用的方法，调用 <span style="color:#ad720d;">SListPushBack</span> 时传递的就是 <strong>pList </strong>的引用。</p>
<p></p>
<p><img alt="" height="55" src="image\20f73c181157463491d8b9bfbb1218c0.png" width="66"/><span title="点击并拖拽以改变尺寸">​</span> 这里补充一下，为了能够更简单地表示，有些书上还有这种写法。</p>
<p>定义链表结构的时候 <span style="color:#956fe7;">typedef</span> 多定义一个<span style="color:#ad720d;"> pSLNode*</span></p>
<div>
<pre><code class="language-cpp hljs"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span>

<span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> SLNodeDataType;        <span class="hljs-comment">// SLNodeDataType == int</span>

<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="class_ hljs-title">SingleListNode</span> {
    SLNodeDataType data;           <span class="hljs-comment">// 用来存放节点的数据 int data</span>
    <span class="hljs-keyword">struct</span> <span class="class_ hljs-title">SingleListNode</span>* next;   <span class="hljs-comment">// 指向后继节点的指针</span>
} SLNode, *pSLNode; 

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SListPrint</span><span class="hljs-params">(pSLNode pHead)</span></span>;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SListPushBack</span><span class="hljs-params">(pSLNode&amp; rpHead, SLNodeDataType x)</span></span>;
<span class="hljs-comment">// 这么一来，就会出现这种写法 👆</span>
<span class="hljs-comment">// 很多书上的写法是这样的，我们一开始讲链表的时候</span>
<span class="hljs-comment">// 因为当时还没有出C++的教学，所以没有用这种方法。</span></code></pre>
</div>
<p><img alt="" height="333" src="image\62235731b4d54d3da94968f57ec46ff7.png" width="271"/><span title="点击并拖拽以改变尺寸">​</span></p>
<p></p>
<h3 id="0x02%20%E4%BC%A0%E5%80%BC%E8%BF%94%E5%9B%9E">0x02 传值返回</h3>
<p><img alt="" height="225" src="image\8f53c9b8ad274ffdb3855c56f0d1f7ba.png" width="234"/><span title="点击并拖拽以改变尺寸">​</span> 讲引用返回前，我们需要做一点点铺垫。</p>
<p></p>
<p>💬 传值返回：</p>
<div>
<pre><code class="language-cpp hljs"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{
    <span class="hljs-type">int</span> c = a + b;
    <span class="hljs-keyword">return</span> c;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
</span>{
    <span class="hljs-type">int</span> ret = <span class="hljs-built_in">Add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);
    cout &lt;&lt; ret &lt;&lt; endl;
    
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>
</div>
<p>🔑 解读：</p>
<p><img alt="" height="364" src="image\0f0fba7b8ef441bea30e8f8a7352a220.png" width="430"/><span title="点击并拖拽以改变尺寸">​</span></p>
<p>这里<span style="color:#956fe7;"> return </span>的时候会生成一个临时变量（<strong>c</strong> 为 3）</p>
<p>将 3 复制给这个临时变量，然后返回给<strong> ret</strong></p>
<p>如果我们直接把 <strong>c</strong> 交给<strong> ret</strong>，就会出现一些问题。</p>
<p>如果直接取 <strong>c </strong>给 <strong>ret</strong>，取到的是 3 还是 <em>随机值</em>，就要取决于栈帧是否销毁空间！</p>
<p><img alt="" height="78" src="image\c5b1fa60071349528afd664e00678d0f.png" width="77"/><span title="点击并拖拽以改变尺寸">​</span> 这个时候严格来说，其实都是非法访问了。</p>
<p>因为这块空间已经还给操作系统了，这就取决于编译器了。</p>
<p>有的编译器会清，有的编译器不会清，这就太玄学了！</p>
<p>所以，在这中间会生成一个临时变量，来递交给<strong> ret </strong>。</p>
<p>而不是直接用 <strong>c </strong>作为返回值，造成非法访问。</p>
<p>所以这里不会直接用 <strong>c </strong>作为返回值，而是生成一个临时变量。</p>
<p></p>
<p><img alt="" height="116" src="image\3d0b201b31b64fb8bb7c9ef4d9634afe.png" width="118"/><span title="点击并拖拽以改变尺寸">​</span> 那么问题来了，这个临时变量是存在哪里的呢？</p>
<p>① 如果 <strong>c</strong> 比较小（4或8），一般是寄存器来干存储临时变量的活。</p>
<p>② 如果 <strong>c </strong>比较大，临时变量就会放在调用 <span style="color:#956fe7;">Add</span> 函数的栈帧中。</p>
<p></p>
<p>🔺 总结：<span style="background-color:#f9eda6;">所有的传值返回都会生成一个拷贝</span></p>
<p>（这是编译器的机制，就像传值传参会生成一份拷贝一样）</p>
<p></p>
<p><img alt="" height="150" src="image\93db09fa07864f3c99eb39ebc4a89158.png" width="215"/><span title="点击并拖拽以改变尺寸">​</span>我们用 <strong>VS</strong> 来反汇编操作一下，加深理解：</p>
<p><img alt="" height="1200" src="image\fb0a80136dd24272bfb1e4427461bb62.png" width="1198"/><span title="点击并拖拽以改变尺寸">​</span></p>
<p> 🔑 解读：我们可以清楚的看到，确实是通过寄存器将 <strong>a + b </strong>的结果交给 <strong>ret</strong> 的。</p>
<p></p>
<p></p>
<h3 id="0x03%20%E5%BC%95%E7%94%A8%E5%81%9A%E8%BF%94%E5%9B%9E%E5%80%BC">0x03 引用做返回值</h3>
<p><img alt="" height="233" src="image\ea00ff2a4e8645dda339facb0d8078d5.png" width="268"/><span title="点击并拖拽以改变尺寸">​</span>我们已经知道，这里会生成一个临时变量了。</p>
<p>我们现在回到正题，我们来试试引用的返回。</p>
<p></p>
<p>💬 体会下面的代码：</p>
<div>
<pre><code class="language-cpp hljs"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">Add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{
    <span class="hljs-type">int</span> c = a + b;
    <span class="hljs-keyword">return</span> c;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
</span>{
    <span class="hljs-type">int</span> ret = <span class="hljs-built_in">Add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);
    cout &lt;&lt; ret &lt;&lt; endl;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>
</div>
<p>🔑 引用返回的意思就是，不会生成临时变量，直接返回<strong> c </strong>的别名。</p>
<p><img alt="" height="335" src="image\669107111b9040cfa47261e46d30f077.png" width="624"/><span title="点击并拖拽以改变尺寸">​</span></p>
<p>❌ 这段代码存在的问题：</p>
<p>① 存在非法访问，因为 <span style="color:#956fe7;">Add</span>(1, 2) 的返回值是 <strong>c</strong> 的引用，所以 Add 栈帧销毁后，会去访问<strong> c </strong>位置空间。</p>
<p>② 如果 <span style="color:#956fe7;">Add </span>函数栈帧销毁，清理空间，那么取<strong> c</strong> 值的时候取到的就是随机值，给<strong> ret</strong> 就是随机值，当前这个取决于编译器实现了。<strong>VS </strong>下销毁栈帧，是不清空间数据的。</p>
<blockquote>
<p><strong>栈帧：</strong>C语言中，每个栈帧对应着一个未运行完的函数。栈帧中保存了该函数的返回地址和局部变量。</p>
</blockquote>
<p><img alt="" height="58" src="image\c72844ede7c1459fb4cf530d778f561c.png" width="66"/><span title="点击并拖拽以改变尺寸">​</span> 既然不清空间数据，那还担心什么呢？</p>
<p>💭 我们来看看下面这种情况：</p>
<div>
<pre><code class="language-cpp hljs"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">Add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{
    <span class="hljs-type">int</span> c = a + b;
    <span class="hljs-keyword">return</span> c;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
</span>{
    <span class="hljs-type">int</span>&amp; ret = <span class="hljs-built_in">Add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);
    cout &lt;&lt; ret &lt;&lt; endl;
    <span class="hljs-built_in">Add</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);
    cout &lt;&lt; ret &lt;&lt; endl;  <span class="hljs-comment">// 这里ret变成30了</span>

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>
</div>
<blockquote>
<p>🚩 运行结果：</p>
</blockquote>
<p><img alt="" height="223" src="image\6af7e09c0ed943629cce8838afd3d1b0.png" width="785"/><span title="点击并拖拽以改变尺寸">​</span></p>
<p>🔑 解读：我们并没有动 <strong>ret</strong>，但是 <strong>ret</strong> 的结果变成了 30，因为栈帧被改了。</p>
<p>当再次调用 <span style="color:#956fe7;">Add </span>时，这块栈帧的 "所有权" 就不是你的了。</p>
<p>我函数销毁了，栈帧就空出来了，新的函数覆盖了之前那个已经销毁的栈帧，</p>
<p><img alt="" height="57" src="image\a1dda4c6bab448f8bd1e6d19b923b9ef.png" width="56"/><span title="点击并拖拽以改变尺寸">​</span> 所以<strong> ret </strong>的结果变成 30 了。</p>
<p></p>
<p><img alt="" height="48" src="image\2bbbb10dc0424ead860e1e2f4854b423.png" width="48"/><span title="点击并拖拽以改变尺寸">​</span> 似乎还是不太好理解，为了加深印象，我举个形象（奇葩）的例子：</p>
<p>其实，操作系统对内存空间的管理就像是房东一样。</p>
<p>我们使用的内存就好比是找房东租房子一样。</p>
<p>建立栈帧，函数调用完成后，把房子还给房东了。</p>
<p>但是你偷偷地把行李箱留在了房间里，</p>
<p>如果恰好没有人来住这个房间，你去取这个行李箱时完全没有问题的。</p>
<p>但是如果有人住了，新的租客没动你的行李箱，也不会有问题。</p>
<p>就怕这个新租客把你放在这的行李箱给丢了，甚至直接把你的行李箱占为己有了。</p>
<p>把你里面的衣服（数据）都给扔了，还把自己臭袜子放进去了。</p>
<p>这时你再回去取你的行李箱，取到的也只有臭袜子了，也不是你的衣服了。</p>
<p><img alt="" height="448" src="image\1a33eeb973e44400872682a8318f70d4.png" width="948"/><span title="点击并拖拽以改变尺寸">​</span></p>
<p></p>
<p>🤣 呼呼啦啦说一大堆，结论就是：不要轻易使用引用返回！</p>
<p>❓ 那引用返回有什么存在的意义呢？等我们后面讲完类和对象后再细说。</p>
<p></p>
<p>🔺 总结：</p>
<p>日常当中是不建议用引用返回的，如果函数返回时，出了函数的作用域，</p>
<p><span style="background-color:#f9eda6;">如果返回对象还未还给操作系统，则可以使用引用返回</span>，如果已经还给操作系统了，</p>
<p>就不要用引用返回了，老老实实传值返回就行了。</p>
<p><img alt="" height="95" src="image\1b1145263d78411c8d3f0d21fe2ca6ac.png" width="96"/><span title="点击并拖拽以改变尺寸">​</span> 通俗点说就是 —— <span style="background-color:#f9eda6;">看返回对象还在不在栈帧内，在的话就可以使用引用返回。</span></p>
<p></p>
<p>💬 举个例子：静态变量，全局变量，出了作用域不会销毁</p>
<div>
<pre><code class="language-cpp hljs"><span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">Count</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-type">static</span> <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;
    n++;
    <span class="hljs-comment">// ...</span>
    <span class="hljs-keyword">return</span> n;
}</code></pre>
</div>
<p></p>
<p></p>
<p>📌 注意事项：临时变量具有常性</p>
<div>
<pre><code class="language-cpp hljs"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> N 10</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;


<span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">At</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>{
    <span class="hljs-type">static</span> <span class="hljs-type">int</span> arr[N];
    <span class="hljs-keyword">return</span> arr[i];  <span class="hljs-comment">// 返回的是数组的第i个的引用（别名）</span>
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
</span>{
    <span class="hljs-comment">// 写</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) {
        <span class="hljs-built_in">At</span>(i) = <span class="hljs-number">10</span> + i;  <span class="hljs-comment">// 依次给 11 12 13 14…… 给 At</span>
    }

    <span class="hljs-comment">// 读</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) {
        cout &lt;&lt; <span class="hljs-built_in">At</span>(i) &lt;&lt; <span class="hljs-string">" "</span>;  <span class="hljs-comment">// 获取值，但是只是打印</span>
    }
    cout &lt;&lt; endl;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>
</div>
<blockquote>
<p>🚩 运行结果如下：</p>
</blockquote>
<p><img alt="" height="202" src="image\066878e78ee845178ab5d5424d3bb4f4.png" width="1031"/><span title="点击并拖拽以改变尺寸">​</span></p>
<p>具有常性，临时变量是右值（不可被修改），可以读但不能修改。</p>
<p><img alt="" height="399" src="image\e29f12ebd3204c98a1875becca171bbc.png" width="555"/><span title="点击并拖拽以改变尺寸">​</span></p>
<p></p>
<p></p>
<h2 id="%E2%85%A2.%20%E5%85%B3%E4%BA%8E%E5%BC%95%E7%94%A8%E7%9A%84%E6%8E%A2%E8%AE%A8">Ⅲ. 关于引用的探讨</h2>
<h3 id="0x00%C2%A0%E6%AF%94%E8%BE%83%E4%BC%A0%E5%80%BC%E5%92%8C%E4%BC%A0%E5%BC%95%E7%94%A8%E7%9A%84%E6%95%88%E7%8E%87">0x00 比较传值和传引用的效率</h3>
<p><img alt="" height="121" src="https://img-blog.csdnimg.cn/0caec237539245fe9996cf8f6423d1a4.gif" width="121"/><span title="点击并拖拽以改变尺寸">​</span></p>
<p>❓ 那传值返回和传引用返回的区别是什么呢？</p>
<p>💡 <span style="background-color:#f9eda6;">传引用返回速度更快。</span></p>
<p></p>
<p>📚 以值作为参数或者返回值类型，在传参和返回期间， </p>
<p>函数不会直接传递实参或者将变量本身直接返回，而是传递实参或者返回变量的一份临时拷贝。</p>
<p>因此值作为参数或者返回值类型，效率是非常低下的，</p>
<p>尤其是当参数或者返回值类型非常大时，效率就更低。</p>
<p></p>
<p><strong>传值和传引用的效率比较：</strong></p>
<div>
<pre><code class="language-cpp hljs"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-keyword">struct</span> <span class="class_ hljs-title">S</span> {
	<span class="hljs-type">int</span> arr[<span class="hljs-number">10000</span>];
};

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CallByValue</span><span class="hljs-params">(S a)</span> </span>{
	;
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CallByReference</span><span class="hljs-params">(S&amp; a)</span> </span>{
	;
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TimeCompare</span><span class="hljs-params">()</span> </span>{
	S s1;

	<span class="hljs-comment">/* 以值作为函数参数 */</span>
	<span class="hljs-type">size_t</span> begin1 = <span class="hljs-built_in">clock</span>();
	<span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++) {
		<span class="hljs-built_in">CallByValue</span>(s1);
	}
	<span class="hljs-type">size_t</span> end1 = <span class="hljs-built_in">clock</span>();

	<span class="hljs-comment">/* 以引用作为函数参数 */</span>
	<span class="hljs-type">size_t</span> begin2 = <span class="hljs-built_in">clock</span>();
	<span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++) {
		<span class="hljs-built_in">CallByReference</span>(s1);
	}
	<span class="hljs-type">size_t</span> end2 = <span class="hljs-built_in">clock</span>();

	<span class="hljs-comment">/* 计算两个函数运行结束后的时间 */</span>
	cout &lt;&lt; <span class="hljs-string">"Call by Value: "</span> &lt;&lt; end1 - begin1 &lt;&lt; endl;
	cout &lt;&lt; <span class="hljs-string">"Call By Reference: "</span> &lt;&lt; end2 - begin2 &lt;&lt; endl;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
</span>{
	<span class="hljs-built_in">TimeCompare</span>();

	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>
</div>
<blockquote>
<p>🚩 运行结果：</p>
</blockquote>
<p><img alt="" height="131" src="image\1d0274ea4c6f419b921c869530fc2855.png" width="576"/><span title="点击并拖拽以改变尺寸">​</span></p>
<p></p>
<p></p>
<p><strong>值和引用作为返回值类型的性能对比：</strong></p>
<p>💬 记录起始时间和结束时间，从而计算出两个函数完成之后的时间。</p>
<div>
<pre><code class="language-cpp hljs"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-keyword">struct</span> <span class="class_ hljs-title">S</span> {
	<span class="hljs-type">int</span> arr[<span class="hljs-number">10000</span>];
};

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ByValue</span><span class="hljs-params">(S a)</span> </span>{
	;
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ReturnByReference</span><span class="hljs-params">(S&amp; a)</span> </span>{
	;
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TimeCompare</span><span class="hljs-params">()</span> </span>{

	S s1;
	<span class="hljs-comment">/* 以值作为函数参数 */</span>
	<span class="hljs-type">size_t</span> begin1 = <span class="hljs-built_in">clock</span>();
	<span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++) {
		<span class="hljs-built_in">ByValue</span>(s1);
	}
	<span class="hljs-type">size_t</span> end1 = <span class="hljs-built_in">clock</span>();

	<span class="hljs-comment">/* 以引用作为函数参数 */</span>
	<span class="hljs-type">size_t</span> begin2 = <span class="hljs-built_in">clock</span>();
	<span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++) {
		<span class="hljs-built_in">ReturnByReference</span>(s1);
	}
	<span class="hljs-type">size_t</span> end2 = <span class="hljs-built_in">clock</span>();

	<span class="hljs-comment">/* 计算两个函数运行结束后的时间 */</span>
	cout &lt;&lt; <span class="hljs-string">"Return By Value: "</span> &lt;&lt; end1 - begin1 &lt;&lt; endl;
	cout &lt;&lt; <span class="hljs-string">"Return By Reference: "</span> &lt;&lt; end2 - begin2 &lt;&lt; endl;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
</span>{
	<span class="hljs-built_in">TimeCompare</span>();

	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>
</div>
<blockquote>
<p> 🚩 运行结果如下：</p>
</blockquote>
<p><img alt="" height="157" src="image\02634526a53f4745bfc6837980253f41.png" width="636"/><span title="点击并拖拽以改变尺寸">​</span></p>
<p><img alt="" height="99" src="image\32ed7e6d010b46c19604dfb7d06af3ad.png" width="87"/><span title="点击并拖拽以改变尺寸">​</span> 传值返回会创建临时变量，每次会拷贝 40000 byte。</p>
<p>而传引用返回没有拷贝，所以速度会快很多很多，因为是全局变量所以栈帧不销毁。</p>
<p>所以这种场景我们就可以使用传引用返回，从而提高程序的运行效率。</p>
<p></p>
<p>🔺 总结：传值和船只真在作为传参以及返回值类型上效率相差十分悬殊。</p>
<p>引用的作用主要体现在传参和传返回值：</p>
<p>① 引用传参和传返回值，有些场景下面，可以提高性能（大对象 + 深拷贝对象）。</p>
<p>② 引用传参和传返回值，输出型参数和输出型返回值。</p>
<blockquote>
<p>有些场景下面，形参的改变可以改变实参。</p>
<p>有些场景下面，引用返回，可以减少拷贝、改变返回对象。（了解一下，后面会学）</p>
<p>引用后面用的非常的多！非常重要！</p>
</blockquote>
<p></p>
<h3 id="0x01%20%E5%BC%95%E7%94%A8%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB">0x01 引用和指针的区别</h3>
<p><strong>在语法概念上：</strong>引用就是一个别名，没有独立空间，和其引用实体共用同一块空间。</p>
<p><img alt="" height="253" src="image\f67b06fc7750458cb0da31c95a3e7094.png" width="588"/><span title="点击并拖拽以改变尺寸">​</span></p>
<p> <strong>但是在底层的实现上：</strong>实际上是有空间的，因为引用是按照指针方式来实现的。</p>
<div>
<pre><code class="language-cpp hljs"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
</span>{
	<span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;
	<span class="hljs-type">int</span>&amp; ra = a;
	ra = <span class="hljs-number">20</span>;

	<span class="hljs-type">int</span>* pa = &amp;a;
	*pa = <span class="hljs-number">20</span>;

	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>
</div>
<p>🔍 我们来看看引用和指针的汇编代码对比：</p>
<p><img alt="" height="587" src="image\bab0cd1d22b44f98b642e191060bc6f2.png" width="1200"/><span title="点击并拖拽以改变尺寸">​</span></p>
<p></p>
<h3 id="0x02%20%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E4%B8%8D%E5%90%8C%E7%82%B9">0x02 指针和引用的不同点</h3>
<blockquote>
<p>总结 ❌      整活 ✅ </p>
</blockquote>
<p>① 引用是在概念上定义一个变量的别名，而指针是存储一个变量的地址。</p>
<p>② 引用在定义时必须初始化，而指针是最好初始化，不初始化也不会报错。</p>
<div>
<pre><code class="language-cpp hljs"><span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;
<span class="hljs-type">int</span>&amp; ra;    ❌ 必须初始化!

<span class="hljs-type">int</span>* pa;    ✅ 可以不初始化</code></pre>
</div>
<p>③ 引用在初始化时引用一个实体后，就不能再引用其他实体，而指针可以在任何时候指向任何一个同类型的实体。</p>
<p>④ 有空指针，但是没有空引用。</p>
<p><img alt="" height="239" src="image\0c7df444f38741b1afbe0dded861a333.png" width="479"/><span title="点击并拖拽以改变尺寸">​</span></p>
<p>⑤ 在 <span style="color:#ad720d;">sizeof </span>中含义不同，引用结果为引用类型的大小，但指针始终是地址空间所占字节数（64位平台下占8个字节）</p>
<div>
<pre><code class="language-cpp hljs"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
</span>{
    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;
    <span class="hljs-type">int</span>&amp; ra = a;
    <span class="hljs-type">int</span>* pa = &amp;a;

    cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(ra) &lt;&lt; endl;
    cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(pa) &lt;&lt; endl;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>
</div>
<blockquote>
<p>🚩 运行结果如下：（本机为64位环境）</p>
</blockquote>
<p><img alt="" height="168" src="image\3f0d5025c2a944438b2c986b1566ba04.png" width="1019"/><span title="点击并拖拽以改变尺寸">​</span></p>
<p>⑥ 引用<strong>++</strong>即引用的实体增加1，指针<strong>++</strong>即指针向后偏移一个类型的大小。</p>
<div>
<pre><code class="language-cpp hljs"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
</span>{
    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;
    <span class="hljs-type">int</span>&amp; ra = a;
    <span class="hljs-type">int</span>* pa = &amp;a;

    cout &lt;&lt; <span class="hljs-string">"ra加加前："</span> &lt;&lt; ra &lt;&lt; endl;
    ra++;
    cout &lt;&lt; <span class="hljs-string">"ra加加后："</span> &lt;&lt; ra &lt;&lt; endl;

    cout &lt;&lt; <span class="hljs-string">"pa加加前："</span> &lt;&lt; pa &lt;&lt; endl;
    pa++;
    cout &lt;&lt; <span class="hljs-string">"pa加加后："</span> &lt;&lt; pa &lt;&lt; endl;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
</div>
<blockquote>
<p>🚩 运行结果如下：</p>
</blockquote>
<p><img alt="" height="307" src="image\c9c97998b0204795bf75add1873afea6.png" width="536"/><span title="点击并拖拽以改变尺寸">​</span></p>
<p></p>
<p>⑦ 有多级指针，但是没有多级引用。</p>
<p><img alt="" height="275" src="image\55abd641af65467abf0b8dc382fde2a8.png" width="432"/><span title="点击并拖拽以改变尺寸">​</span></p>
<p></p>
<p>⑧ 访问实体方式不同，指针需要显式解引用，引用编译器自己处理。</p>
<div>
<pre><code class="language-cpp hljs"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
</span>{
    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;
    <span class="hljs-type">int</span>&amp; ra = a;
    <span class="hljs-type">int</span>* pa = &amp;a;

    cout &lt;&lt; ra &lt;&lt; endl;    <span class="hljs-comment">// 引用直接是编译器自己处理，即取即用。</span>
    cout &lt;&lt; *pa &lt;&lt; endl;   <span class="hljs-comment">// 指针得加解引用操作符*，才能取到。</span>

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>
</div>
<blockquote>
<p>🚩 运行结果如下：</p>
</blockquote>
<p><img alt="" height="148" src="image\448dfd53a6564f939f949dab6de9074f.png" width="518"/><span title="点击并拖拽以改变尺寸">​</span></p>
<p></p>
<p>⑨ 引用比指针使用起来相对更加安全。</p>
<p><img alt="" height="250" src="image\6f14678ed71540acbe2f9beabb34a751.png" width="624"/><span title="点击并拖拽以改变尺寸">​</span></p>
<p></p>
<p>🔺 总结：指针使用起来更复杂一些，更容易出错一些。<span style="color:#a5a5a5;">（指针和引用的区别，面试经常考察）</span></p>
<p>使用指针有考虑空指针，野指针等等问题，指针太灵活了，所以相对而言没有引用安全！</p>
<p><img alt="" height="641" src="image\63d61ab4c752483faaeab2f18aaef057.png" width="1198"/><span title="点击并拖拽以改变尺寸">​</span></p>
<p></p>
<p></p>
<h2 id="%E2%85%A3.%C2%A0%20%E5%B8%B8%E5%BC%95%E7%94%A8">Ⅳ.  常引用</h2>
<h3 id="0x00%20%E5%B8%B8%E5%BC%95%E7%94%A8%E7%9A%84%E6%A6%82%E5%BF%B5">0x00 常引用的概念</h3>
<p><img alt="" height="52" src="https://img-blog.csdnimg.cn/b09ad40697634877a449d4c0db9de90e.gif" width="90"/><span title="点击并拖拽以改变尺寸">​</span> 如果既要利用引用来提高程序的效率，又想要保护传递给函数的数据不能在函数中被改变，就应使用常引用。</p>
<p>📜 语法：<span style="color:#ad720d;">const</span> <span style="color:#ad720d;">数据类型</span><span style="color:#be191c;"><strong>&amp;</strong></span>  引用名<strong> =</strong>  引用实体；</p>
<p>一共有三种情况：分别是权限的放大、保持权限不变、权限的缩小。</p>
<p></p>
<h3 id="0x01%20%E6%9D%83%E9%99%90%E7%9A%84%E6%94%BE%E5%A4%A7">0x01 权限的放大</h3>
<p>💬 下面是一个引用的例子：</p>
<div>
<pre><code class="language-cpp hljs"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
</span>{
    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;
    <span class="hljs-type">int</span>&amp; ra = a;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>
</div>
<p></p>
<p>💬 如果对引用实体使用 <span style="color:#ad720d;">const </span>修饰，直接引用会导致报错：</p>
<div>
<pre><code class="language-cpp hljs"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
</span>{
    <span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;
    <span class="hljs-type">int</span>&amp; ra = a;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>
</div>
<blockquote>
<p>🚩 运行结果如下：（报错）</p>
</blockquote>
<p><img alt="" height="227" src="image\941ea356fa1e4f2292b596f082853733.png" width="498"/><span title="点击并拖拽以改变尺寸">​</span></p>
<p></p>
<p>🔑 分析：导致这种问题的原因是，我本身标明了<span style="color:#ad720d;"> const</span>，这块空间上的值不能被修改。</p>
<p>我自己都不能修改，你<strong> ra </strong>变成我<strong> a </strong>的引用，意味着你 <strong>ra </strong>可以修改我的<strong> a</strong>，</p>
<p>这就是属于权限的放大问题，<strong>a</strong> 是可读的，你<strong> ra</strong> 要变成可读可写的，当然不行。</p>
<p>这要是能让你随随便便修改，那我岂不是 <span style="color:#ad720d;">const</span> 了个寂寞？</p>
<p><img alt="" height="173" src="https://img-blog.csdnimg.cn/f23bb7db1f4e4761930ad336e3cb0006.gif" width="173"/><span title="点击并拖拽以改变尺寸">​</span> 这合理吗？这不合理！</p>
<p>❓ 那么如何解决这样的问题，我们继续往下看。</p>
<p></p>
<h3 id="0x02%20%E4%BF%9D%E6%8C%81%E6%9D%83%E9%99%90%E7%9A%84%E4%B8%80%E8%87%B4">0x02 保持权限的一致</h3>
<p><img alt="" height="55" src="image\fab84f48cc2f402ca0b100c081ec4011.png" width="66"/><span title="点击并拖拽以改变尺寸">​</span> 既然引用实体用了<span style="color:#ad720d;"> const</span> 进行修饰，我直接引用的话属于权限的放大，</p>
<p>我们可以给引用前面也加上<span style="color:#ad720d;"> const</span>，让他们的权限保持不变。</p>
<p></p>
<p>💬 给引用前面加上 const：</p>
<div>
<pre><code class="language-cpp hljs"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
</span>{
    <span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;
    <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; ra = a;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>
</div>
<p>🔑 解读：<span style="color:#ad720d;">const int</span><strong><span style="color:#be191c;">&amp;</span> ra</strong> = <strong>a</strong> 的意思就是，我变成你的别名，但是我不能修改你。</p>
<p>这样 <strong>a </strong>是可读不可写的，<strong>ra</strong> 也是可读不可写的，这样就保持了权限的不变。</p>
<p>如果我们想使用引用，但是不希望它被修改，我们就可以使用常引用来解决。</p>
<p></p>
<h3 id="0x03%20%E6%9D%83%E9%99%90%E7%9A%84%E7%BC%A9%E5%B0%8F">0x03 权限的缩小</h3>
<p><img alt="" height="58" src="image\f0597c85f04c4f31b2a3012f0b394248.png" width="66"/><span title="点击并拖拽以改变尺寸">​</span> 如果引用实体并没有被 <span style="color:#ad720d;">const</span> 修饰，是可读可写的，</p>
<p>但是我希望它的引用不能修改它，我们可以用常引用来解决。</p>
<p></p>
<p>💬 <strong>a </strong>是可读可写的，但是我限制<strong> ra </strong>是可读单不可写：</p>
<div>
<pre><code class="language-cpp hljs"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
</span>{
    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;
    <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; ra = a;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>
</div>
<p>🔑 解读：这当然是可以的，这就是权限的缩小。</p>
<p>举个例子，就好比你办身份证，你的本名是可以印在身份证上的，</p>
<p>但是你的绰号可以印在身份证上吗？</p>
<p><img alt="" height="231" src="image\dd0140c11e7548be9198f72b7de5efe7.png" width="407"/><span title="点击并拖拽以改变尺寸">​</span></p>
<p>所以就需要加以限制，你的绰号可以被人喊，但是不能写在身份证上。</p>
<p></p>
<p> <img alt="" height="196" src="image\2bcd4f8dd6304b9fabf037dbe528c910.png" width="241"/><span title="点击并拖拽以改变尺寸">​</span>   所以，权限的缩小，你可以理解为是一种自我的约束。</p>
<p></p>
<p></p>
<h3 id="0x04%20%E5%B8%B8%E5%BC%95%E7%94%A8%E7%9A%84%E5%BA%94%E7%94%A8">0x04 常引用的应用</h3>
<p>💬 举个例子：</p>
<p><img alt="" height="57" src="image\951186ce02ed47909fc563b0279821c9.png" width="55"/><span title="点击并拖拽以改变尺寸">​</span> 假设 <strong>x</strong> 是一个大对象，或者是后面学的深拷贝的对象</p>
<p>那么尽量用引用传参，以减少拷贝。</p>
<p>如果 <span style="color:#956fe7;">Func </span>函数中不需要改变<strong> x</strong>，那么这里就尽量使用 <span style="color:#ad720d;">const</span> 引用传参。</p>
<div>
<pre><code class="language-cpp hljs"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Func</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; x)</span> </span>{
    cout &lt;&lt; x &lt;&lt; endl;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
</span>{
    <span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;
    <span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;  

    <span class="hljs-built_in">Func</span>(a);  <span class="hljs-comment">// ❌ 报错，涉及权限的放大</span>
    <span class="hljs-built_in">Func</span>(b);  <span class="hljs-comment">// 权限是一致的，没问题</span>

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>
</div>
<p>加 <span style="color:#ad720d;">const</span> 后，让权限保持一致：</p>
<div>
<pre><code class="language-cpp hljs"><span class="hljs-comment">// "加上保持权限的一致"</span>
           👇
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Func</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; x)</span> </span>{
    cout &lt;&lt; x &lt;&lt; endl;
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
</span>{
     👇
    <span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;
    <span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;  

    <span class="hljs-built_in">Func</span>(a);  <span class="hljs-comment">// 权限是一致的</span>
    <span class="hljs-built_in">Func</span>(b);  <span class="hljs-comment">// 权限的缩小</span>

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
</div>
<p>🔑 解读：如此一来，<strong>a</strong> 是可读不可写的，传进 <span style="color:#956fe7;">Func </span>函数中也是可读不可写的，</p>
<p>就保持了权限的一致了。<strong>b</strong> 是可读可写的，刚才形参还没使用 <span style="color:#ad720d;">const</span> 修饰之前，</p>
<p><strong>x </strong>是可读可写的，但是加上 <span style="color:#ad720d;">const</span> 后，属于权限的缩小，<strong>x </strong>就是可读但不可写的了。</p>
<blockquote>
<p>常引用后期会用的比较多，现在理解的不深刻也没关系，早晚的事情。</p>
<p>后面讲类和对象的时候会反复讲的，印象会不断加深的。</p>
</blockquote>
<p></p>
<h3 id="0x05%C2%A0%E5%B8%A6%E5%B8%B8%E6%80%A7%E7%9A%84%E5%8F%98%E9%87%8F%E7%9A%84%E5%BC%95%E7%94%A8">0x05 带常性的变量的引用</h3>
<p>💬 先看代码：</p>
<div>
<pre><code class="language-cpp hljs"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
</span>{
    <span class="hljs-type">double</span> d = <span class="hljs-number">3.14</span>;
    <span class="hljs-type">int</span> i = d;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
</div>
<p><img alt="" height="48" src="image\bcc4569ddc754a98b3a90e1814958909.png" width="50"/><span title="点击并拖拽以改变尺寸">​</span> 这里的 <strong>d</strong> 是可以给<strong> i</strong> 的，这个在C语言里面叫做 <em>隐式类型转换 </em>。</p>
<p>它会把 <strong>d</strong> 的整型部分给 <strong>i</strong>，浮点数部分直接丢掉。</p>
<p></p>
<p>❓ 但是我在这里加一个引用呢？</p>
<div>
<pre><code class="language-cpp hljs"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
</span>{
    <span class="hljs-type">double</span> d = <span class="hljs-number">3.14</span>;
    <span class="hljs-type">int</span>&amp; i = d;  <span class="hljs-comment">// 我能不能用i去引用d呢？</span>

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>
</div>
<blockquote>
<p>🚩 运行结果：（报错）</p>
</blockquote>
<p>直接用<strong> i </strong>去引用<strong> d </strong>是会报错的，思考下是为什么？</p>
<p>这里可能有的朋友要说，<strong>d</strong> 是浮点型，<strong>i </strong>是整型啊，会不会是因为类型不同导致的？</p>
<p><img alt="" height="137" src="https://img-blog.csdnimg.cn/6652bb7c77404f87a62a43b9766fc05a.gif" width="165"/><span title="点击并拖拽以改变尺寸">​</span>但是奇葩的是 —— 如果我在它前面加上一个 <span style="color:#ad720d;">const</span> 修饰，</p>
<p>却又不报错了，这又是为什么？</p>
<div>
<pre><code class="language-cpp hljs"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
</span>{
    <span class="hljs-type">double</span> d = <span class="hljs-number">3.14</span>;
    <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; i = d;  <span class="hljs-comment">// ??? 又可以了</span>

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>
</div>
<p><img alt="" height="103" src="https://img-blog.csdnimg.cn/8dafb1b7e4214e159da8a59e1ca53d89.gif" width="90"/><span title="点击并拖拽以改变尺寸">​</span><em> <span style="color:#a5a5a5;">哎它* *滴！const，const 为什么行！！！</span></em></p>
<p></p>
<p>🔑 解析：因为 <span style="background-color:#f9eda6;">内置类型产生的</span><span style="background-color:#f9eda6;">临时变量具有常性，不能被修改。</span></p>
<p>隐式类型转换不是直接发生的，而是现在中间产生一个临时变量。</p>
<p>是先把 <strong>d</strong> 给了临时变量，然后再把东西交给<strong> i </strong>的：</p>
<p><img alt="" height="462" src="image\8c1bc85bcd174732a883bfbd566a9bb6.png" width="1200"/><span title="点击并拖拽以改变尺寸">​</span></p>
<p>如果这里用了引用，生成的是临时变量的别名，</p>
<p>又因为临时变量是一个右值，是不可以被修改的，所以导致了报错。</p>
<p></p>
<p>🔺 结论：<span style="background-color:#f9eda6;">如果引用的是一个带有常性的变量，就要用带 </span><span style="color:#ad720d;"><span style="background-color:#f9eda6;">const</span></span><span style="background-color:#f9eda6;"> 的引用。</span></p>
<p></p>
<h3 id="0x06%20%E5%B8%B8%E5%BC%95%E7%94%A8%E5%81%9A%E5%8F%82%E6%95%B0">0x06 常引用做参数</h3>
<p><img alt="" height="104" src="https://img-blog.csdnimg.cn/bf6c08d49f8d41439c9b92efba38ad13.gif" width="134"/><span title="点击并拖拽以改变尺寸">​</span> <span style="background-color:#f9eda6;">使用引用传参，如果函数中不改变参数的值，建议使用</span><span style="color:#ad720d;"><span style="background-color:#f9eda6;"> const</span></span><span style="color:#be191c;"><strong><span style="background-color:#f9eda6;"> 引用</span></strong></span></p>
<p></p>
<p>💬 举个例子：</p>
<p>一般栈的打印，是不需要改变参数的值的，这里就可以加上 <span style="color:#ad720d;">const </span></p>
<div>
<pre><code class="language-cpp hljs"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">StackPrint</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> Stack&amp; st)</span> </span>{...}</code></pre>
</div>
<p><span style="color:#ad720d;">const 数据类型</span><span style="color:#be191c;"><strong>&amp;</strong></span>  可以接收各种类型的对象。</p>
<p>使用<span style="color:#ad720d;"> const </span>的引用好处有很多，如果传入的是 <span style="color:#ad720d;">const </span>对象，就是权限保持不变；</p>
<p>普通的对象，就是权限的缩小；中间产生临时变量，也可以解决。</p>
<p>因为<span style="color:#ad720d;"> const </span>引用的通吃的，它的价值就在这个地方，如果不加<span style="color:#ad720d;"> const </span>就只能传普通对象。</p>
<p><img alt="" height="366" src="image\1eafa5b6fe0c47b7b860be3c1c5a0b1e.png" width="466"/><span title="点击并拖拽以改变尺寸">​</span></p>
<p></p>
<p><img alt="" height="82" src="image\effbba124f4a490abea09ff05fdb2ca3.png" width="85"/><span title="点击并拖拽以改变尺寸">​</span><strong> 谢谢你读到这里！</strong></p>
<p><img alt="" height="62" src="image\7a80245f0b5f4021a033b3789a9efdeb.png" width="707"/><span title="点击并拖拽以改变尺寸">​</span>​</p>
<pre><code class="language-cpp">📌 [ 笔者 ]   王亦优
📃 [ 更新 ]   2022.2.28
❌ [ 勘误 ]   /* 暂无 */
📜 [ 声明 ]   由于作者水平有限，本文有错误和不准确之处在所难免，
              本人也很想知道这些错误，恳望读者批评指正！</code></pre>
<table align="center" border="1" cellpadding="1" cellspacing="1"><tbody><tr><td> <p style="text-align:right;"><strong>📜 参考资料 </strong></p> <p style="text-align:right;"><span style="color:#a5a5a5;">Microsoft. MSDN(Microsoft Developer Network)[EB/OL]. []. .</span></p> <p style="text-align:right;"><span style="color:#a5a5a5;">百度百科[EB/OL]. []. https://baike.baidu.com/.</span></p> <p style="text-align:right;"><span style="color:#a5a5a5;">比特科技. C++[EB/OL]. 2021[2021.8.31]. .</span></p> <p style="text-align:right;"><span style="color:#a5a5a5;">程序员面试宝典[M]. 5. .</span></p> </td></tr></tbody></table>
</div>
</div>