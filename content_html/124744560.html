<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="markdown_views prism-atom-one-dark" id="content_views">
<svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
<path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
</svg>
<p></p>
<div class="toc">
<h3>万丈高楼平地起——C++入门（下卷）</h3>
<ul><li><a href="#_1">😏前言</a></li><li><a href="#6__6">💓6. 引用</a></li><li><ul><li><a href="#61__8">💞6.1 引用概念</a></li><li><a href="#62__104">💞6.2 引用特性</a></li><li><a href="#63__141">💞6.3 常引用</a></li><li><ul><li><a href="#631__143">💘6.3.1 常引用规则</a></li><li><a href="#632__196">💘6.3.2 注意点</a></li></ul>
</li><li><a href="#64__264">💞6.4 使用场景</a></li><li><a href="#65__533">💞6.5 传值、传引用传指针效率比较</a></li><li><ul><li><a href="#651__535">💘6.5.1 传值、传引用传指针作为参数效率比较</a></li><li><a href="#652__581">💘6.5.2 传值、传引用传指针作为返回值返回效率比较</a></li></ul>
</li><li><a href="#66__629">💞6.6 引用和指针的区别</a></li></ul>
</li><li><a href="#7__686">💓7. 内联函数</a></li><li><ul><li><a href="#71__688">💞7.1 概念</a></li><li><a href="#72__736">💞7.2 特性</a></li><li><a href="#73__841">💞7.3 关联面试题</a></li></ul>
</li><li><a href="#8_autoC11_861">💓8. auto关键字(C++11)</a></li><li><ul><li><a href="#82_auto_897">💞8.2 auto的使用细则</a></li><li><a href="#83_auto_935">8.3 auto不能推导的场景</a></li><li><a href="#84_auto_965">💞8.4 auto的意义</a></li></ul>
</li><li><a href="#9_for_969">💓9. 基于范围的for循环</a></li><li><ul><li><a href="#91_for_971">💞9.1 范围for的语法</a></li><li><a href="#92_for_1015">💞9.2 范围for的使用条件</a></li></ul>
</li><li><a href="#10_nullptrC11_1032">💓10. 指针空值nullptr(C++11)</a></li><li><ul><li><a href="#101_C98_1034">💞10.1 C++98中的指针空值</a></li></ul>
</li><li><a href="#11_const_1092">💓11. const限定符再补充</a></li><li><ul><li><a href="#111_const_1094">💞11.1 const再补充</a></li><li><a href="#112_constconst_1130">💞11.2 底层const和顶层const</a></li><li><a href="#113_constexpr_1140">💞11.3 constexpr和常量表达式</a></li><li><ul><li><a href="#1131__1142">💘11.3.1 常量表达式</a></li><li><a href="#1132_constexprC11_1155">💘11.3.2 constexpr变量（C++11）</a></li><li><a href="#1133__1167">💘11.3.3 字面值类型</a></li><li><a href="#1134_constexpr_1179">💘11.3.4 指针和constexpr</a></li></ul>
</li></ul>
</li></ul>
</div>
<p></p>
<h1><a id="_1"></a>😏前言</h1>
<blockquote>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/55c72306b6fa4c2982d3b7cd6c9b8901.gif"/><br/> 哈喽大家好，我是<span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         
          
           鹿
          
          
           九
          
          
           丸
          
         
        
       
       
        \color{red}{鹿九丸}
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0em; vertical-align: 0em;"></span><span class="mord" style="color: red;"><span class="mord cjk_fallback" style="color: red;">鹿</span><span class="mord cjk_fallback" style="color: red;">九</span><span class="mord cjk_fallback" style="color: red;">丸</span></span></span></span></span></span>，今天给大家带来的是C++入门系列的下卷，关注我博客的话应该已经看到我已经三四天没有更新博客了，今天的内容很多，比上卷应该是还要多一些，补充了很多的细节，希望大家能够有所收获！<br/> 如果大家在看我的博客的过程中或者学习的过程中以及在学习方向上有什么问题或者想跟我交流的话可以加我的企鹅号：<span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         
          2361038962
         
        
       
       
        \color{red}{2361038962}
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord" style="color: red;"><span class="mord" style="color: red;">2</span><span class="mord" style="color: red;">3</span><span class="mord" style="color: red;">6</span><span class="mord" style="color: red;">1</span><span class="mord" style="color: red;">0</span><span class="mord" style="color: red;">3</span><span class="mord" style="color: red;">8</span><span class="mord" style="color: red;">9</span><span class="mord" style="color: red;">6</span><span class="mord" style="color: red;">2</span></span></span></span></span></span>，或者寄邮件到相应的邮箱里：<span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         
          
           2361038962
          
          
           @
          
          
           q
          
          
           q
          
          
           .
          
          
           c
          
          
           o
          
          
           m
          
         
        
       
       
        \color{red}{2361038962@qq.com}
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord" style="color: red;"><span class="mord" style="color: red;">2</span><span class="mord" style="color: red;">3</span><span class="mord" style="color: red;">6</span><span class="mord" style="color: red;">1</span><span class="mord" style="color: red;">0</span><span class="mord" style="color: red;">3</span><span class="mord" style="color: red;">8</span><span class="mord" style="color: red;">9</span><span class="mord" style="color: red;">6</span><span class="mord" style="color: red;">2</span><span class="mord" style="color: red;">@</span><span class="mord mathdefault" style="margin-right: 0.03588em; color: red;">q</span><span class="mord mathdefault" style="margin-right: 0.03588em; color: red;">q</span><span class="mord" style="color: red;">.</span><span class="mord mathdefault" style="color: red;">c</span><span class="mord mathdefault" style="color: red;">o</span><span class="mord mathdefault" style="color: red;">m</span></span></span></span></span></span>，我会尽量帮大家进行解答！</p>
</blockquote>
<h1><a id="6__6"></a>💓6. 引用</h1>
<h2><a id="61__8"></a>💞6.1 引用概念</h2>
<p><strong>引用</strong>不是新定义一个变量，而是<strong>给已存在变量取了一个别名</strong>，编译器不会为引用变量开辟内存空间，它和它引用的变量<strong>共用同一块内存空间</strong>。</p>
<pre><code class="prism language-cpp">类型<span class="token operator">&amp;</span> 引用变量名<span class="token punctuation">(</span>对象名<span class="token punctuation">)</span> <span class="token operator">=</span> 引用实体；
</code></pre>
<p>例如：</p>
<pre><code class="prism language-cpp"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token keyword">int</span><span class="token operator">&amp;</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span><span class="token comment">//b叫做a的引用，或者称b是a的别名</span>
<span class="token keyword">int</span><span class="token operator">&amp;</span> c <span class="token operator">=</span> a<span class="token punctuation">;</span>
<span class="token keyword">int</span><span class="token operator">&amp;</span> d <span class="token operator">=</span> b<span class="token punctuation">;</span><span class="token comment">//可以对引用取别名</span>
<span class="token comment">//b、c、d都是a的别名，都可以用来修改变量a的值</span>
</code></pre>
<p>图示：</p>
<p><img alt="image-20220430095443228" src="https://img-blog.csdnimg.cn/img_convert/5fb32a8f5f67d4924bb40adf244bf2a7.png"/></p>
<p>通过监视可以看到：</p>
<p><img alt="image-20220430095904809" src="https://img-blog.csdnimg.cn/img_convert/51c35df1c7fb23185c66dfb2495b72cb.png"/></p>
<p><mark>a、b、c、d四个标识符的值都是一样的，并且对其进行取地址后其地址也是一样的。</mark></p>
<p><strong>那么引用的用处在哪呢？</strong></p>
<pre><code class="prism language-C++">#include&lt;iostream&gt;
using namespace std;
void Swap(int&amp; a, int&amp; b)
{
	int tmp = a;
	a = b;
	b = tmp;
}
int main()
{
	int a = 5;
	int b = 10;
	cout &lt;&lt; a &lt;&lt; ' ' &lt;&lt; b &lt;&lt; endl;
	Swap(a, b);
	cout &lt;&lt; a &lt;&lt; ' ' &lt;&lt; b &lt;&lt; endl;
	return 0;
}
</code></pre>
<p>运行结果：</p>
<p><img alt="image-20220430100540802" src="https://img-blog.csdnimg.cn/img_convert/7442e1fd920d4ba59ea34f4327da0c4e.png"/></p>
<p>此处可以看到，<mark>使用引用后，我们不需要传递变量的地址，不需要使用指针就能在函数中交换两个变量的值。</mark></p>
<p><mark>注意：引用也能够改变指针变量的值。</mark></p>
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">&amp;</span> pa<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	pa <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span><span class="token operator">*</span> pa <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> pa <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token function">f</span><span class="token punctuation">(</span>pa<span class="token punctuation">)</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> pa <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>上面代码的运行结果是：</p>
<p><img alt="image-20220430101736634" src="https://img-blog.csdnimg.cn/img_convert/07c7c815a912f3c4d513edf606613059.png"/></p>
<p>在函数中pa指针变量的值被修改成了空指针。</p>
<p><mark>C++中常常会有这么一句话：不能定义引用的引用，这句话是什么意思？</mark></p>
<blockquote>
<p>回顾C语言，指针的指针，就是二级指针，所以引用的引用就是“二级引用”，所以不能定义引用的引用这句话的意思就是C++中不存在二级引用。所以下面的操作是非法的：</p>
<pre><code class="prism language-cpp"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">int</span><span class="token operator">&amp;</span> ia <span class="token operator">=</span> a<span class="token punctuation">;</span>
<span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> iia <span class="token operator">=</span> ia<span class="token punctuation">;</span>
</code></pre>
<p><mark>iia的定义是非法的。</mark></p>
</blockquote>
<h2><a id="62__104"></a>💞6.2 引用特性</h2>
<p><strong>（1）引用在定义时必须初始化</strong>。</p>
<p>下面的操作是非法的：</p>
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>
</code></pre>
<p>我们在初始化变量时，初始值会被拷贝到新建的对象中。然而定义引用时，程序把引用它和它的初始值绑定在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另一个对象，因此引用必须在定义的时候初始化。</p>
<p><strong>对象和引用的关系</strong></p>
<blockquote>
<p><mark>对象是具有某种数据类型的内存空间。而引用并不占据内存空间，所以引用并非对象，相反的，它只是为一个已经存在的对象所起的另一个名字。</mark></p>
</blockquote>
<p><strong>（2）一个变量可以有多个引用</strong></p>
<p><strong>（3）引用一旦引用一个实体，再不能引用其他实体</strong>。这是和指针的一个大的区别，指针可以在初始化后指向其它的地址空间。</p>
<p>当然，我们一般也无法引用其它的实体，比如我们下面的操作：</p>
<pre><code class="prism language-cpp"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">int</span><span class="token operator">&amp;</span> ia <span class="token operator">=</span> a<span class="token punctuation">;</span>
<span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
<span class="token keyword">int</span><span class="token operator">&amp;</span> ib <span class="token operator">=</span> b<span class="token punctuation">;</span>
ib <span class="token operator">=</span> a<span class="token punctuation">;</span>
ib <span class="token operator">=</span> ia<span class="token punctuation">;</span>
</code></pre>
<p>我们在上面进行的最后这两行操作，比如<code>ib = a</code>和<code>ib = ia</code>都是进行的赋值操作，而不是对引用的更改。</p>
<blockquote>
<p>当引用作为左值时，是被指向的那个对象本身的内存空间，比如在上面的例子中，就是指代的标识符ib指向的那个整型变量b的内存空间。</p>
<p>当引用作为右值时，是被指向的那个对象本身的内存空间所存储的值，在上面的例子中，ia在作为右值时就是a这个变量所指向的内存空间中存储的值10。</p>
</blockquote>
<h2><a id="63__141"></a>💞6.3 常引用</h2>
<h3><a id="631__143"></a>💘6.3.1 常引用规则</h3>
<p>规则介绍：</p>
<pre><code class="prism language-cpp"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre>
<p>（1）<strong>普通引用引用普通变量</strong>。（合法操作，无限制）</p>
<pre><code class="prism language-cpp"><span class="token keyword">int</span><span class="token operator">&amp;</span> ia <span class="token operator">=</span> a<span class="token punctuation">;</span>
</code></pre>
<p>（2）<strong>常引用引用普通变量</strong>。（合法操作，<mark>无法通过常引用来修改普通变量</mark>）</p>
<pre><code class="prism language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> ia <span class="token operator">=</span> a<span class="token punctuation">;</span>
</code></pre>
<p>下面的操作是非法的：</p>
<pre><code class="prism language-cpp">ia <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
</code></pre>
<p>（3）<strong>常引用引用常变量</strong>。（合法操作，<mark>无法通过常引用来修改常变量</mark>）</p>
<pre><code class="prism language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> ib <span class="token operator">=</span> ib<span class="token punctuation">;</span>
</code></pre>
<p>下面操作是非法的：</p>
<pre><code class="prism language-cpp">ib <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
</code></pre>
<p>（4）<strong>普通引用引用常变量</strong>。（非法操作）</p>
<p>下面操作是非法的：</p>
<pre><code class="prism language-cpp"><span class="token keyword">int</span><span class="token operator">&amp;</span> ib <span class="token operator">=</span> b<span class="token punctuation">;</span>
</code></pre>
<p>总结：</p>
<p><mark>取别名的原则：对原引用变量，权限只能缩小，不能放大。</mark></p>
<p><strong>在上面的例子中，（2）就是权限的缩小，变量a是可读可写的，但是引用ia就是只能读的了，所以就是权限；（4）就是权限的放大，常变量b是只读的，但是引用ib是可读可写的，所以这就是权限的扩大。</strong></p>
<h3><a id="632__196"></a>💘6.3.2 注意点</h3>
<p>（1）<mark>常引用可以对常量取别名。</mark></p>
<pre><code class="prism language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
</code></pre>
<p>此时的权限既没有扩大也没有缩小，因为a的权限就是只读的，100作为常量的权限也是只读的。</p>
<p>（2）<mark>引用的类型都要和与之绑定的对象严格匹配。</mark></p>
<pre><code class="prism language-cpp"><span class="token keyword">double</span> d <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span>
<span class="token keyword">int</span><span class="token operator">&amp;</span> id <span class="token operator">=</span> d<span class="token punctuation">;</span>
</code></pre>
<p><strong>此处的引用是非法操作，引用类型的初始值必须是int型对象。</strong></p>
<p>但是在int的前面加上一个const就可以了，如下操作：</p>
<pre><code class="prism language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> id <span class="token operator">=</span> d<span class="token punctuation">;</span>
</code></pre>
<p>我们知道，在将double类型的变量赋值给int型时，会发生隐式类型转换：</p>
<pre><code class="prism language-cpp"><span class="token keyword">double</span> pi <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> a <span class="token operator">=</span> pi<span class="token punctuation">;</span>
</code></pre>
<p>在将pi赋值给变量a的过程中，实际上发生了一个类型转换，即3.14被转换成int类型发生了截断，这个过程中会有一个临时变量来存储3.14这个值，存储位置一般是寄存器，下面用图来表示：</p>
<p><img alt="image-20220510184758376" src="https://img-blog.csdnimg.cn/img_convert/50ecda630788c74c432ec97a50005561.png"/></p>
<pre><code class="prism language-cpp"><span class="token keyword">double</span> d <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> id <span class="token operator">=</span> d<span class="token punctuation">;</span>
</code></pre>
<p>此处ri引用了一个int型的数，对ri得操作应该是整数运算，但d却是一个双精度浮点数而非整数，因此为了让id绑定一个整数，编译器把上述代码变成了如下形式：</p>
<pre><code class="prism language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> temp <span class="token operator">=</span> d<span class="token punctuation">;</span><span class="token comment">//由双精度浮点数生成一个临时的整型常量</span>
<span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> id <span class="token operator">=</span> temp<span class="token punctuation">;</span><span class="token comment">//由id绑定这个临时量</span>
</code></pre>
<p><strong>在这种情况下，id绑定了一个临时量对象。所谓临时量对象就是当编译器需要一个空间（寄存器或内存空间）来暂存表达式临时创建的一个未命名的对象。C++程序员常常把临时对象称为临时量。</strong></p>
<p><mark>临时变量具有常性，是只读常量，所以能被const进行引用，如果没有const，就属于权限的放大。</mark></p>
<p><mark>注意：在将寄存器中的3赋值给3的过程中，本质上还是值的拷贝，即将寄存器中3的二进制位拷贝到变量a的内存空间中，对变量a进行修改，寄存器中的值不会有所改变，引用亦是如此。</mark></p>
<p>当然，还有另外一种理解（只作为理解）：</p>
<blockquote>
<p>问：pi作为右值时代表的是什么？</p>
<p>答：pi作为右值时就是pi变量空间中存储的值，所以上面的代码就相当于是下面这段代码：</p>
<pre><code class="prism language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> a <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span>
</code></pre>
<p>3.14是只读常量，因为左边的类型是const int&amp;，所以发生了强制类型转换，变成了3，3作为临时变量具有常性，所以能够被赋值给a。</p>
</blockquote>
<p><strong>注意：普通对象不存在权限的放大与缩小的问题，如我们通常使用的赋值表达式<code>int a = 3</code>，a只是一个普通变量，只是将3的二进制位拷贝到变量a所在的内存空间中，所以不存在权限的放大与缩小的问题。因为a的改变不会改变10，只有指针和引用才会存在权限的放大与缩小的问题。</strong></p>
<h2><a id="64__264"></a>💞6.4 使用场景</h2>
<ol><li> <p><strong>做参数</strong></p> <pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> right<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> temp <span class="token operator">=</span> left<span class="token punctuation">;</span>
	left <span class="token operator">=</span> right<span class="token punctuation">;</span>
	right <span class="token operator">=</span> temp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
    <span class="token function">Swap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//实现了变量a和b的交换，交换之后a的值位20，b的值为10</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> </li></ol>
<blockquote>
<p>意义：</p>
<ul><li><strong>一定程度上规避指针，使代码更容易理解</strong></li><li><strong>减少值拷贝，提高效率</strong></li></ul>
</blockquote>
<ol start="2"><li> <p><strong>做返回值</strong></p> <p>首先先看下面的一段代码：</p> <pre><code class="prism language-cpp"><span class="token keyword">int</span><span class="token operator">&amp;</span> <span class="token function">Count</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">static</span> <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span>；
	n<span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> n<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token function">Count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token function">Count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token function">Count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <p>上面的输出结果是123，因为n是静态全局变量，存储在静态区，声明周期在整个程序运行期间始终存在，且静态全局变量只初始化一次，所以只运行一次<code>static int n = 0</code>，所以输出结果是123。</p> <p>下面看这段代码：</p> <pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">Count</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    n<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> n<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token function">Count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <p><mark>注意：无论是函数在进行传参还是函数在传返回值的时候，都会形成一个临时变量，如果所传的参数或返回值较小，那么临时变量就用寄存器进行传递，否则就不用寄存器替代。</mark></p>
<blockquote>
<p>问：为什么要出现一个临时变量？</p>
<p>答：如果没有临时变量，在Count()函数调用结束之后，函数栈帧就销毁了，n所在的内存空间就无法使用了，所以就无法将返回值进行返回。</p>
<p>但是如果我们将n的值放在一个临时变量中，这个临时变量可能是寄存器，也有可能是内存中的某一个空间（比如在调用Count()函数之前提前在main()函数中开辟好要存储返回值的空间），但无论如何，这个临时变量都已经不在Count()函数的栈帧上了，所以我们可以在Count()函数栈帧销毁之后依然可以将n的值传递回main函数中。</p>
</blockquote> <p><strong>那么传值返回的意义是什么呢？意义就是临时变量的类型是int类型。</strong></p> <p>此时看下面这段代码：</p> <pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">Count</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    n<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> n<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> ret <span class="token operator">=</span> <span class="token function">Count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <p>这个程序可以正常运行，为什么呢？因为<code>return n</code>传递的临时变量具有常性，可以被常引用接收，实际上上面这段代码类似于<code>const int&amp; ret = 1</code>。</p> <p>再看下面这段代码：</p> <pre><code class="prism language-cpp"><span class="token keyword">int</span><span class="token operator">&amp;</span> <span class="token function">Count</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    n<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> n<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token function">Count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <p>上面这段代码是什么意思呢？表示<code>return</code>返回的临时变量的类型是<code>int&amp;</code>，这个引用是Count()栈帧中变量n的引用或者别名。</p> <p><mark>总结：如果返回类型是int，那么临时变量就是返回值的临时拷贝，类型就是int，如果返回类型是<code>int&amp;</code>，那么临时变量就是被调用函数栈帧中所要传变量的引用。</mark></p> <p>再看下面这段代码：</p> <pre><code class="prism language-cpp"><span class="token keyword">int</span><span class="token operator">&amp;</span> <span class="token function">Count</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    n<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> n<span class="token punctuation">;</span><span class="token comment">//返回的是n的别名</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span><span class="token operator">&amp;</span> ret <span class="token operator">=</span> <span class="token function">Count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <p>临时变量的类型是<code>int&amp;</code>类型，所以也能被<code>int&amp;</code>类型的ret来接收。</p> <p><code>return n</code>，返回的是n的别名，又将n的别名赋值给ret，即ret是别名的别名，就是n的别名。</p> <p>采用如下方式进行验证：</p> <pre><code class="prism language-cpp"><span class="token keyword">int</span><span class="token operator">&amp;</span> <span class="token function">Count</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    n<span class="token operator">++</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Count:"</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>n <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> n<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span><span class="token operator">&amp;</span> ret <span class="token operator">=</span> <span class="token function">Count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"main:"</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>ret <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <p>运行结果：</p> <p><img alt="image-20220510220222171" src="https://img-blog.csdnimg.cn/img_convert/69c37c7096aaf8e7130984bf71be9100.png"/></p> <p><strong>ret和n的地址是一样的，说明ret就是n的别名。</strong></p>
<blockquote>
<p><strong>传值返回和传引用返回有什么区别？</strong></p>
<p>传值返回：会有一个拷贝。</p>
<p>传引用返回：没有拷贝，函数返回的直接就是返回变量的别名。</p>
</blockquote> <p>问：上面例子中的Count栈帧已经销毁了，为什么还存在n的别名？我们甚至还能在main函数中访问到n？</p> <p>答：函数栈帧的销毁只是我们不再拥有那段空间的使用权，那段空间依旧存在，我们依然可以通过引用或者指针去访问它，但是那段空间一旦被其它的函数栈帧所覆盖，那么我们再次进行访问输出，得到的就是一个随机值。如下面的代码所示：</p> <pre><code class="prism language-cpp"><span class="token keyword">int</span><span class="token operator">&amp;</span> <span class="token function">Count</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    n<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> n<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span><span class="token operator">&amp;</span> ret <span class="token operator">=</span> <span class="token function">Count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> ret <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> ret <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> ret <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <p>运行结果：</p> <p><img alt="image-20220510223117657" src="https://img-blog.csdnimg.cn/img_convert/9412519fb5f7105d00961be085ab818e.png"/></p> <p>在第一次输出正确结果的原因是因为原来的栈帧销毁后内存空间中的值并没有改变，当然，这种行为是非法的，类似野指针，后面两次输出结果错误是因为cout调用了函数，栈帧被覆盖了，所以输出结果就是随机值。</p>
<blockquote>
<p><strong>问：什么场景下可以用引用返回来减少拷贝？什么时候只能用传值返回？</strong></p>
<p><strong>答：如果函数返回时，出了函数作用域，如果返回对象还未还给系统（例如static变量或者全局变量），则可以使用引用返回，如果已 经还给系统了，则必须使用传值返回。</strong></p>
</blockquote> <p>此时看下面这段代码：</p> <pre><code class="prism language-cpp"><span class="token keyword">int</span><span class="token operator">&amp;</span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> c <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
    <span class="token keyword">return</span> c<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span><span class="token operator">&amp;</span> ret <span class="token operator">=</span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Add(1,2) is :"</span> <span class="token operator">&lt;&lt;</span> ret <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <p>输出结果：</p> <p><img alt="image-20220510230746090" src="https://img-blog.csdnimg.cn/img_convert/8b57942bbba8bf55a834b424cf09d7ed.png"/></p> <p>出现7的结果如下：</p> <p>ret是Add函数中局部变量c的别名，虽然在函数Add(1,2)调用之后销毁了，但是值仍然保存在那，通过ret仍然能够找到那块空间，再次调用Add(3,4)那个函数，c变量的那段空间所存储的值变成了7，这就是输出结果为7的原因。当然，如果我们像下面这样进行修改代码，就会出现不是7而是随机数的结果：</p> <pre><code class="prism language-cpp"><span class="token keyword">int</span><span class="token operator">&amp;</span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> c <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
    <span class="token keyword">return</span> c<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span><span class="token operator">&amp;</span> ret <span class="token operator">=</span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Add(1,2) is :"</span> <span class="token operator">&lt;&lt;</span> ret <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Add(1,2) is :"</span> <span class="token operator">&lt;&lt;</span> ret <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <p>输出结果：</p> <p><img alt="image-20220511085645057" src="https://img-blog.csdnimg.cn/img_convert/64ade44f84b291cdc7f708fd32fbd970.png"/></p> <p>第二次输出结果就是随机数了，原因就是之前Add所在的栈帧空间因为第一次cout相关函数的调用栈帧被覆盖了，所以会输出随机数。</p> <p>如果我们继续像下面这样修改代码，就会出现不一样的结果：</p> <pre><code class="prism language-cpp"><span class="token keyword">int</span><span class="token operator">&amp;</span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> c <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
    <span class="token keyword">return</span> c<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span><span class="token operator">&amp;</span> ret <span class="token operator">=</span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Add(1,2) is :"</span> <span class="token operator">&lt;&lt;</span> ret <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Add(1,2) is :"</span> <span class="token operator">&lt;&lt;</span> ret <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <p>输出结果：</p> <p><img alt="image-20220511085919433" src="https://img-blog.csdnimg.cn/img_convert/d9d681b665a00ac885b41153264377a7.png"/></p> <p>因为static变量是存在于静态区的，生命周期是整个程序的运行期间，会一直存在，所以输出结果为3，且再次进行打印也会输出同样的结果。</p> </li></ol>
<h2><a id="65__533"></a>💞6.5 传值、传引用传指针效率比较</h2>
<h3><a id="651__535"></a>💘6.5.1 传值、传引用传指针作为参数效率比较</h3>
<p>以值作为参数或者返回值类型，在传参和返回期间，函数不会直接传递实参或者将变量本身直接返回，而是 传递实参或者返回变量的一份临时的拷贝，因此用值作为参数或者返回值类型，效率是非常低下的，尤其是当参数或者返回值类型非常大时，效率就更低。</p>
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;time.h&gt;</span></span>
<span class="token keyword">struct</span> <span class="token class-name">A</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">10000</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">TestFunc1</span><span class="token punctuation">(</span>A a<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">TestFunc2</span><span class="token punctuation">(</span>A<span class="token operator">&amp;</span> a<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">TestFunc3</span><span class="token punctuation">(</span>A<span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">TestRefAndValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	A a<span class="token punctuation">;</span>
	<span class="token comment">// 以值作为函数参数</span>
	size_t begin1 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
		<span class="token function">TestFunc1</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	size_t end1 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 以引用作为函数参数</span>
	size_t begin2 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
		<span class="token function">TestFunc2</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	size_t end2 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//以指针作为函数参数</span>
	size_t begin3 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
		<span class="token function">TestFunc3</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	size_t end3 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 分别计算两个函数运行结束后的时间</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"TestFunc1(A)-time:"</span> <span class="token operator">&lt;&lt;</span> end1 <span class="token operator">-</span> begin1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"TestFunc2(A&amp;)-time:"</span> <span class="token operator">&lt;&lt;</span> end2 <span class="token operator">-</span> begin2 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"TestFunc3(&amp;A)-time:"</span> <span class="token operator">&lt;&lt;</span> end3 <span class="token operator">-</span> begin3 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">TestRefAndValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>运行结果：</p>
<p><img alt="image-20220510204604698" src="https://img-blog.csdnimg.cn/img_convert/f0c2e8d9bdc9ccdfcb33c78c36fd294e.png"/></p>
<p>从上图中可以看出，传指针和传引用比传值效率高很多。</p>
<h3><a id="652__581"></a>💘6.5.2 传值、传引用传指针作为返回值返回效率比较</h3>
<p>代码：</p>
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;time.h&gt;</span></span>
<span class="token keyword">struct</span> <span class="token class-name">A</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">10000</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
A a<span class="token punctuation">;</span>
<span class="token comment">// 值返回</span>
A <span class="token function">TestFunc1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> a<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token comment">// 引用返回</span>
A<span class="token operator">&amp;</span> <span class="token function">TestFunc2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> a<span class="token punctuation">;</span> <span class="token punctuation">}</span>
A<span class="token operator">*</span> <span class="token function">TestFunc3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">TestReturnByRefOrValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 以值作为函数的返回值类型</span>
	size_t begin1 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
		<span class="token function">TestFunc1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	size_t end1 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 以引用作为函数的返回值类型</span>
	size_t begin2 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
		<span class="token function">TestFunc2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	size_t end2 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//以指针作为函数的返回类型</span>
	size_t begin3 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
		<span class="token function">TestFunc3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	size_t end3 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 计算两个函数运算完成之后的时间</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"TestFunc1 time:"</span> <span class="token operator">&lt;&lt;</span> end1 <span class="token operator">-</span> begin1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"TestFunc2 time:"</span> <span class="token operator">&lt;&lt;</span> end2 <span class="token operator">-</span> begin2 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"TestFunc3 time:"</span> <span class="token operator">&lt;&lt;</span> end3 <span class="token operator">-</span> begin3 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">TestReturnByRefOrValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>运行截图：</p>
<p><img alt="image-20220511091244023" src="https://img-blog.csdnimg.cn/img_convert/240d92ebc451f2583a1288c989ad2198.png"/></p>
<p><mark>通过上述代码的比较，发现传值和指针或引用在作为传参以及返回值类型上效率相差很大，传指针和传引用的的效率相差不大。</mark></p>
<h2><a id="66__629"></a>💞6.6 引用和指针的区别</h2>
<blockquote>
<p>在<strong>语法概念</strong>上引用就是一个别名，没有独立空间，和其引用实体共用同一块空间。</p>
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span><span class="token operator">&amp;</span> ra <span class="token operator">=</span> a<span class="token punctuation">;</span>

	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"&amp;a = "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"&amp;ra = "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>ra <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>在<strong>底层实现</strong>上实际是有空间的，因为<strong>引用是按照指针方式</strong>来实现的。</p>
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>

	<span class="token keyword">int</span><span class="token operator">&amp;</span> ra <span class="token operator">=</span> a<span class="token punctuation">;</span>
	ra <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>

	<span class="token keyword">int</span><span class="token operator">*</span> pa <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>
	<span class="token operator">*</span>pa <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>引用和指针的汇编代码比较：</p>
<p><img alt="image-20220511093015613" src="https://img-blog.csdnimg.cn/img_convert/e83b11b508a20b3cdeff78f76803dd7b.png"/></p>
<p>可以看到两者的汇编代码是一样的，所以它们的底层实现是一模一样的。</p>
<p>指针和引用赋值的汇编代码比较：</p>
<p><img alt="image-20220511094413630" src="https://img-blog.csdnimg.cn/img_convert/94ffe9a20ba5aba3a93719677400cb04.png"/></p>
<p>使用指针和使用引用进行赋值从汇编代码上看，它们也是完全一样的。</p>
</blockquote>
<blockquote>
<p>引用和指针的不同点：</p>
<ol><li><strong>引用</strong>在定义时必须<strong>初始化</strong>，指针没有要求</li><li><strong>引用</strong>在初始化时引用一个实体后，就<strong>不能再引用其他实体</strong>，而指针可以在任何时候指向任何一个同类型 实体</li><li><strong>没有NULL引用</strong>，但有NULL指针</li><li><strong>在sizeof中含义不同</strong>：<strong>引用</strong>结果为<strong>引用类型或者说是引用变量的大小</strong>，但<strong>指针</strong>始终是**地址空间所占字节个数(**32位平台下占 4个字节)</li><li>引用自加即引用的实体增加1，指针自加即指针向后偏移一个类型的大小</li><li><strong>有多级指针</strong>，<strong>但是没有多级引用</strong></li><li>访问实体方式不同，<strong>指针需要显式解引用</strong>，<strong>引用编译器自己处理</strong></li><li><strong>引用比指针使用起来相对更安全</strong></li><li>从语法上来说，引用并没有开辟额外的空间，只是一个别名，指针开辟了空间，存储地址；但从底层上来说，引用和指针一样，开辟了空间存放地址。</li></ol>
</blockquote>
<h1><a id="7__686"></a>💓7. 内联函数</h1>
<h2><a id="71__688"></a>💞7.1 概念</h2>
<p>以inline修饰的函数叫做内联函数，<strong>编译时</strong>C++编译器会在<strong>调用内联函数的地方展开</strong>，没有函数压栈的开销， 内联函数提升程序运行的效率。</p>
<blockquote>
<p><strong>为什么要出现inline？</strong></p>
<p><strong>解决宏函数晦涩难懂，容易写错的问题，因为要考虑到优先级问题，所以要加很多的括号；另一方面宏不支持调试，并且没有类型安全的检查等问题，使用内联函数能够解决上面的问题。</strong></p>
</blockquote>
<p><img alt="image-20220511161852244" src="https://img-blog.csdnimg.cn/img_convert/dd6880318fc995a36ec337915904a343.png"/></p>
<p>如果在上述函数前增加inline关键字将其改成内联函数，在编译期间编译器会用函数体替换函数的调用。</p>
<p>如果使用了内联函数，如下面代码所示：</p>
<pre><code class="prism language-cpp"><span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> left <span class="token operator">+</span> right<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	ret <span class="token operator">=</span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>在汇编语言查看时将不会看到call调用Add()函数。</p>
<p>使用inline后查看方式如下：</p>
<ol><li>在release模式下，查看编译器生成的汇编代码中是否存在call Add，查看结果如下：（注：默认的debug版本下内联函数不会展开，但在release版本下会展开）<br/> <img alt="image-20220511163321449" src="https://img-blog.csdnimg.cn/img_convert/29c683b0720ed1c35809c770dcea7705.png"/><br/> 发现在release版本下无法查看汇编代码。</li><li>在debug模式下，需要对编译器进行设置，否则不会展开(因为debug模式下，编译器默认不会对代码进 行优化，以下给出vs2019的设置方式) 
  <ol><li>右击项目工程，点击属性。<br/> <img alt="image-20220511163846479" src="https://img-blog.csdnimg.cn/img_convert/5dba19d1a27c80f8edd8e00f1c19abe1.png"/></li><li>如下操作：<br/> <img alt="image-20220511164508252" src="https://img-blog.csdnimg.cn/img_convert/1ee754cfa7dbe0df9224a5714671022f.png"/></li><li>如下操作：<br/> <img alt="image-20220511164152187" src="https://img-blog.csdnimg.cn/img_convert/307ac2946962d07320c404f816d22750.png"/></li></ol> </li></ol>
<p>上述操作完成后查看反汇编：</p>
<p><img alt="image-20220511164654293" src="https://img-blog.csdnimg.cn/img_convert/e3c43285a7156f05249eb95c287de842.png"/></p>
<p>此时inline内联函数就实现了展开，没有了call汇编指令，即函数的调用。</p>
<h2><a id="72__736"></a>💞7.2 特性</h2>
<blockquote>
<ol><li> <p>inline是一种以空间换时间的做法，省去调用函数额开销。所以代码很长（一般10行以上就算长）或者有循环/递归的函数不适宜 使用作为内联函数。</p> </li><li> <p>inline对于编译器而言只是一个建议，编译器会自动优化，如果定义为inline的函数体内有循环/递归等 等，编译器优化时会忽略掉内联。</p> </li><li> <p>inline不建议声明和定义分离，分离会导致链接错误。因为inline函数被展开，符号表里就没有对应的函数地址了，链接就会找不到。</p> <pre><code class="prism language-cpp"><span class="token comment">// Func.h</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Func.cpp</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"Func.h"</span></span>
<span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// main.cpp</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"Func.h"</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">func</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <p>这样程序会出现链接错误。</p> <p>程序像下面这样进行修改就不会出现问题：</p> <pre><code class="prism language-cpp"><span class="token comment">// Func.h</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"Func.h"</span></span>
<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// main.cpp</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"Func.h"</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">func</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <p>因为Func.h文件里的文本内容会在main.cpp文件中展开，所以不会出现链接错误。</p> <p>当然，下面还有两种特殊的情况：</p> <p>（1）声明的时候带inline，定义的时候不带inline</p> <pre><code class="prism language-cpp"><span class="token comment">// Func.h</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Func.cpp</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"Func.h"</span></span>
<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// main.cpp</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"Func.h"</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">func</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <p>此时程序可以正常运行，没有出现链接错误，此时inline并没有发挥应有的作用，func函数并没有展开。</p> <p>（2）声明的时候不带inline，定义的时候带inline。</p> <pre><code class="prism language-cpp"><span class="token comment">// Func.h</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Func.cpp</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"Func.h"</span></span>
<span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// main.cpp</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"Func.h"</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">func</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <p>此时程序不能正常运行，出现链接错误，因为Func.cpp文件汇编形成的符号表里依旧没有func函数的地址，所以会链接失败。</p> </li></ol>
</blockquote>
<p><mark>注意：如果在函数定义中加了inline，那么在函数声明中就可以不必再加了，这样也能达到inline的使用效果。</mark></p>
<h2><a id="73__841"></a>💞7.3 关联面试题</h2>
<blockquote>
<p><strong>宏的优缺点？</strong></p>
<p>优点：</p>
<ol><li>增强代码的复用性。</li><li>提高性能。</li></ol>
<p>缺点：</p>
<ol><li>不方便调试宏。（因为预编译阶段进行了替换）</li><li>导致代码可读性差，可维护性差，容易误用。</li><li>没有类型安全的检查 。</li></ol>
<p><strong>C++有哪些技术替代宏？</strong></p>
<ol><li>常量定义 换用const</li><li>函数定义 换用内联函数</li></ol>
</blockquote>
<h1><a id="8_autoC11_861"></a>💓8. auto关键字(C++11)</h1>
<p>在早期C/C++中auto的含义是：使用auto修饰的变量，是具有自动存储器的局部变量。</p>
<p>C++11中，标准委员会赋予了auto全新的含义即：<strong>auto不再是一个存储类型指示符，而是作为一个新的类型 指示符来指示编译器，auto声明的变量必须由编译器在编译时期推导而得。</strong></p>
<p>补充知识：<code>typeid().name</code>函数可以用来让编译器告知某个变量的类型是什么，该函数的返回类型是一个字符串。</p>
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">TestAuto</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
	<span class="token keyword">auto</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span><span class="token comment">//a是整型，编译器推导出变量b的类型是int型</span>
	<span class="token keyword">auto</span> c <span class="token operator">=</span> <span class="token char">'a'</span><span class="token punctuation">;</span><span class="token comment">//'a'是字符型，编译器推导出变量c的类型是char类型</span>
	<span class="token keyword">auto</span> d <span class="token operator">=</span> <span class="token function">TestAuto</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//TestAuto函数的返回类型是int型，编译器推导出变量d的类型是int型</span>
    <span class="token keyword">const</span> <span class="token keyword">int</span> e <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> ie <span class="token operator">=</span> <span class="token operator">&amp;</span>e<span class="token punctuation">;</span>

	cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">//输出结果为int</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">//输出结果为char</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">//输出结果为int</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>ie<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">//输出结果为const int *  </span>

	<span class="token comment">//auto e; 无法通过编译，使用auto定义变量时必须对其进行初始化</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p><strong>【注意】</strong></p>
<p>使用auto定义变量时必须对其进行初始化，在编译阶段编译器需要根据初始化表达式来推导auto的实际类 型。因此auto并非是一种“类型”的声明，而是一个类型声明时的“占位符”，编译器在编译期会将auto替换为变量实际的类型。</p>
</blockquote>
<h2><a id="82_auto_897"></a>💞8.2 auto的使用细则</h2>
<ol><li> <p>auto与指针和引用结合起来使用 用auto声明指针类型时，用auto和auto*没有任何区别，但用auto声明引用类型时则必须加&amp;</p> <pre><code class="prism language-cpp"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span><span class="token operator">*</span> pa <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span><span class="token comment">//指定pa为指针类型</span>
<span class="token keyword">auto</span><span class="token operator">*</span> ppa <span class="token operator">=</span> <span class="token operator">&amp;</span>pa<span class="token punctuation">;</span>
<span class="token keyword">auto</span><span class="token operator">&amp;</span> ia <span class="token operator">=</span> a<span class="token punctuation">;</span><span class="token comment">//指定ia的类型为引用类型</span>
<span class="token keyword">auto</span><span class="token operator">*</span> pa <span class="token operator">=</span> a<span class="token punctuation">;</span><span class="token comment">//程序非法，因为指定了pa的类型是指针类型，但是我们却给它赋了地址</span>
cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>pa<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">//输出结果为int *</span>
cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>ppa<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">//输出结果为int **</span>
cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>ia<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">//输出结果为int</span>
</code></pre> </li><li> <p>在同一行定义多个变量<br/> <mark>当在同一行声明多个变量时，这些变量必须是相同的类型，否则编译器将会报错，因为编译器实际只对 第一个类型进行推导，然后用推导出来的类型定义其他变量。</mark></p> <pre><code class="prism language-cpp"><span class="token keyword">auto</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span> d <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span><span class="token comment">//错误的使用方式</span>
<span class="token keyword">auto</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span><span class="token comment">//正确的使用方式，i是整数，p是整型指针</span>
<span class="token keyword">auto</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token comment">//正确的使用方式，因为经过编译器推导之后，程序会变成下面的定义方式</span>
<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
</code></pre> </li><li> <p>auto在使用时会遵循隐式类型转换的规则。比如下面这样：</p> <pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">auto</span> a <span class="token operator">=</span> <span class="token number">3.14</span> <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token comment">//表达式3.14和5相加后的类型转换为double类型，值为8.14</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> </li></ol>
<h2><a id="83_auto_935"></a>8.3 auto不能推导的场景</h2>
<ol><li> <p><strong>auto不能作为函数的参数和返回值</strong></p> <pre><code class="prism language-cpp"><span class="token comment">// 此处代码编译失败，auto不能作为形参类型，因为编译器无法对a的实际类型进行推导</span>
<span class="token keyword">void</span> <span class="token function">TestAuto1</span><span class="token punctuation">(</span><span class="token keyword">auto</span> a<span class="token punctuation">)</span><span class="token comment">//注意：auto也不能作为缺省参数，例如：void TestAuto1(auto a = 10) {}</span>
<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token keyword">auto</span> <span class="token function">TestAuto2</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>问：为什么会存在这种限制呢？</p>
<p>答：因为我们要把相应的一些函数接口暴露出来给用户的，用户需要知道如何使用，需要传什么样的参数，需要什么样的变量来接收返回值，而且函数的参数和返回值都是auto的话，函数的可读性就不太好了，并且也会加大编译器的工作量。</p>
</blockquote> </li><li> <p><strong>auto不能直接用来声明数组</strong></p> <pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">TestAuto</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token keyword">auto</span> b<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">4</span>，<span class="token number">5</span>，<span class="token number">6</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> </li><li> <p><strong>为了避免与C++98中的auto发生混淆，C++11只保留了auto作为类型指示符的用法</strong></p> </li><li> <p><strong>auto在实际中最常见的优势用法就是跟以后会讲到的C++11提供的新式for循环，还有lambda表达式等 进行配合使用。</strong></p> </li></ol>
<h2><a id="84_auto_965"></a>💞8.4 auto的意义</h2>
<p>程序员不必再写出冗长的数据类型，只需要在类型的前面放置一个<code>auto</code>即可，减轻程序员的任务。</p>
<h1><a id="9_for_969"></a>💓9. 基于范围的for循环</h1>
<h2><a id="91_for_971"></a>💞9.1 范围for的语法</h2>
<p>在C++98中如果要遍历一个数组，可以按照以下方式进行：</p>
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">TestFor</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
		array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span>

	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> p <span class="token operator">=</span> array<span class="token punctuation">;</span> p <span class="token operator">&lt;</span> array <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>p<span class="token punctuation">)</span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>对于一个有范围的集合而言，由程序员来说明循环的范围是多余的，有时候还会容易犯错误。因此C++11中 引入了基于范围的for循环。for循环后的括号由冒号“ ：”分为两部分：第一部分是范围内用于迭代的变量， 第二部分则表示被迭代的范围。</p>
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">TestFor</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token comment">//下面的auto是元素的类型，我们也可以将其写为int，因为数组元素都是int类型</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> e <span class="token operator">:</span> array<span class="token punctuation">)</span><span class="token comment">//必须使用引用才能拷贝，因为e只是array数组中元素的临时拷贝</span>
		e <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span>

	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> e <span class="token operator">:</span> array<span class="token punctuation">)</span>
		cout <span class="token operator">&lt;&lt;</span> e <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">TestFor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>范围for工作原理：依次取数组array中的元素，然后将其赋值给临时变量e（但是e的改变不会改变数组，除非使用引用），然后达到了遍历的目的。</p>
<p><mark>注意：与普通循环类似，可以用continue来结束本次循环，也可以用break来跳出整个循环。</mark></p>
<blockquote>
<p>这种写法的意义是什么？</p>
<p>其一是方便书写，其二是方便修改代码。例如我们向数组中添加了几个元素之后，使用这种方法就无需修改循环次数，且不用书写冗长的<code>sizeof(array)/sizeof(array[0])</code>。</p>
</blockquote>
<h2><a id="92_for_1015"></a>💞9.2 范围for的使用条件</h2>
<blockquote>
<ol><li> <p><strong>for循环迭代的范围必须是确定的 对于数组而言，就是数组中第一个元素和最后一个元素的范围；对于类而言，应该提供begin和end的 方法，begin和end就是for循环迭代的范围。</strong><br/> 注意：以下代码就有问题，因为for的范围不确定</p> <pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">TestFor</span><span class="token punctuation">(</span><span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> e <span class="token operator">:</span> array<span class="token punctuation">)</span>
		cout<span class="token operator">&lt;&lt;</span> e <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <p>函数传过去的实参只是一个地址，编译器无法知道我们想向后遍历多大的范围。</p> </li><li> <p><strong>迭代的对象要实现++和==的操作。</strong></p> </li></ol>
</blockquote>
<h1><a id="10_nullptrC11_1032"></a>💓10. 指针空值nullptr(C++11)</h1>
<h2><a id="101_C98_1034"></a>💞10.1 C++98中的指针空值</h2>
<p>在良好的C/C++编程习惯中，声明一个变量时最好给该变量一个合适的初始值，否则可能会出现不可预料的 错误，比如未初始化的指针。如果一个指针没有合法的指向，我们基本都是按照如下方式对其进行初始化：</p>
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">TestPtr</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span><span class="token operator">*</span> p1 <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span><span class="token operator">*</span> p2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

	<span class="token comment">// ……</span>
<span class="token punctuation">}</span>
</code></pre>
<p>NULL实际是一个宏，在传统的C头文件(stddef.h)中，可以看到如下代码：</p>
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression"><span class="token constant">NULL</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">__cplusplus</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NULL</span> <span class="token expression"><span class="token number">0</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NULL</span> <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
</code></pre>
<p>可以看到，NULL可能被定义为字面常量0，或者被定义为无类型指针(void*)的常量。不论采取何种定义，在 使用空值的指针时，都不可避免的会遇到一些麻烦，比如：</p>
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"f(int)"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"f(int*)"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">f</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">f</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>程序本意是想通过f(NULL)调用指针版本的f(int*)函数，但是由于NULL被定义成0，预处理之后NULL被替换成了0，因此与程序的初衷相悖。</p>
<p><strong>在C++98中，字面常量0既可以是一个整形数字，也可以是无类型的指针(void*)常量，但是编译器默认情况下 将其看成是一个整形常量，如果要将其按照指针方式来使用，必须对其进行强转(void *)0</strong>。</p>
<blockquote>
<p>注意：</p>
<ol><li><strong>在使用nullptr表示指针空值时，<mark>不需要包含头文件</mark>，因为nullptr是C++11作为新关键字引入的。</strong></li><li><strong>在C++11中，sizeof(nullptr) 与 sizeof((void*)0)所占的字节数相同</strong>。</li><li><strong>为了提高代码的健壮性，在后续表示指针空值时建议最好使用nullptr。</strong></li></ol>
</blockquote>
<p><strong>注意：nullptr的本质就是<code>(void*)0</code>。</strong></p>
<h1><a id="11_const_1092"></a>💓11. const限定符再补充</h1>
<h2><a id="111_const_1094"></a>💞11.1 const再补充</h2>
<p>因为const对象一旦创建后其值就不能被改变，所以const对象必须初始化，初始值可以是任何复杂的表达式。</p>
<pre><code class="prism language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">get_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//正确，运行时初始化</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">43</span><span class="token punctuation">;</span><span class="token comment">//正确，编译时初始化</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> k<span class="token punctuation">;</span><span class="token comment">//错误，k没有进行初始化</span>
</code></pre>
<p><mark>注意：默认状态下，const对象仅在文件内有效，所以当多个文件中出现了同名的const变量时，起始等同于在不同的文件中定义了独立的变量。</mark></p>
<p>如果我们想让我们某个文件中定义的变量具有外部链接属性（在其它文件中可以使用），那么对于const变量的定义或者声明都添加extern关键字即可，这样只需要定义一次即可（即带有初始化的表达式出现一次即可）。</p>
<p>例如：</p>
<pre><code class="prism language-cpp"><span class="token comment">//file1.cpp</span>
<span class="token keyword">extern</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token comment">//file2.cpp</span>
<span class="token keyword">extern</span> <span class="token keyword">int</span> a<span class="token punctuation">;</span>
<span class="token comment">//此时在file.cpp中就可以使用常量a，且其值为10</span>
</code></pre>
<p>file.cpp头文件中的定义由extern做了限定，其作用是a并非本文件所独有，它的定义将在别处出现。</p>
<p>当然，像下面这样是不行的：</p>
<pre><code class="prism language-cpp"><span class="token comment">//file.h</span>
<span class="token keyword">extern</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token comment">//file.cpp</span>
<span class="token keyword">extern</span> <span class="token keyword">int</span> a<span class="token punctuation">;</span>
<span class="token comment">//此时如果想在file.cpp中使用file.h中的a，就必须在file.cpp文件中包含file.h，为什么？因为头文件不参与编译，更不会参与链接</span>
</code></pre>
<h2><a id="112_constconst_1130"></a>💞11.2 底层const和顶层const</h2>
<blockquote>
<p>问：什么是顶层const？什么是底层const？</p>
<p>答：顶层const指的就是指针常量（指针本身是个常量，指针指向不能改变），底层const指的就是常量指针（指针指向的常量不能被改变）。</p>
<p>下图可以方便理解：</p>
<p><img alt="image-20220512210544977" src="https://img-blog.csdnimg.cn/img_convert/7ac32647486ec8dc294fd1577a6c2145.png"/></p>
</blockquote>
<h2><a id="113_constexpr_1140"></a>💞11.3 constexpr和常量表达式</h2>
<h3><a id="1131__1142"></a>💘11.3.1 常量表达式</h3>
<p>常量表达式是指<mark>不会改变并且在编译过程就能得到运算结果的表达式</mark>。显然，字面值属于常量表达式，用常量表达式初始化的const对象也是常量表达式。</p>
<p><strong>一个对象（或表达式）是不是常量表达式由它的数据类型和初始值共同决定</strong>，例如：</p>
<pre><code class="prism language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> max_files <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token comment">//max_files是常量表达式</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> limit <span class="token operator">=</span> max_files <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//limit是常量表达式，max_files + 1也是常量表达式</span>
<span class="token keyword">int</span> staff_size <span class="token operator">=</span> <span class="token number">27</span><span class="token punctuation">;</span><span class="token comment">//staff_size不是常量表达式</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> sz <span class="token operator">=</span> <span class="token function">get_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//sz不是常量表达式，因为sz是在运行过程中得到的</span>
</code></pre>
<h3><a id="1132_constexprC11_1155"></a>💘11.3.2 constexpr变量（C++11）</h3>
<p>在一个复杂系统中，我们很难分辨一个初始值是不是常量表达式，所以C++ 11新标准规定。允许将变量声明为constexpr类型以便由编译器来检验变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化。</p>
<pre><code class="prism language-cpp"><span class="token keyword">constexpr</span> <span class="token keyword">int</span> mf <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token comment">//20是常量表达式</span>
<span class="token keyword">constexpr</span> <span class="token keyword">int</span> limit <span class="token operator">=</span> mf <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//mf + 1是常量表达式</span>
<span class="token keyword">constexpr</span> sz <span class="token operator">=</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//只有当size是一个constexpr函数时才是一条正确的声明语句</span>
</code></pre>
<p>一般来说，如果我们认定某个变量是一个常量表达式，我们就把它声明为constexpr类型。</p>
<h3><a id="1133__1167"></a>💘11.3.3 字面值类型</h3>
<p><strong>常量表达式的值需要在编译时就得到计算，因此对声明constexpr时用到的类型必须有所限制。因为这些类型一般比较简单，值也显而易见、容易得到，就把它们称为“字面值类型”。</strong></p>
<p><strong>算术类型、引用和指针都属于字面值类型。自定义类Sales_item、IO库、string类型则不属于字面值类型，也就不能被定义成constexpr。</strong></p>
<p><strong>尽管指针和引用都能定义成constexpr，但它们的初始值却受到严格限制，一个constexpr的初始值必须是nullptr或者0，或者是存储与某个固定地址中的对象。</strong></p>
<p><strong>函数体内定义的变量一般来说并非存放在固定地址中，因此constexpr指针不能指向这样的变量。相反的，定义于所有函数体之外的对象其地址固定不变，能用来初始化constexpr指针。</strong></p>
<p><strong>允许函数定义一类有效范围超出函数本身的变量，这类变量和定义在函数体之外的变量也有固定地址。因此，constexpr引用能绑定到这样的变量上，constexpr指针也能指向这样的变量。</strong></p>
<h3><a id="1134_constexpr_1179"></a>💘11.3.4 指针和constexpr</h3>
<p>在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针指向的对象无关。</p>
<pre><code class="prism language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token comment">//p是一个指向整型常量的指针</span>
<span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token comment">//q是一个指向整数的常量指针</span>
</code></pre>
<p>与其它常量指针类似，constexpr指针既可以指向常量也可以指向一个非常量。</p>
<pre><code class="prism language-cpp"><span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token operator">*</span>np <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token comment">//np是一个指向整数的常量指针，其值为空</span>
<span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">constexpr</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span><span class="token comment">//i的类型是整型常量</span>
<span class="token comment">//i和j都必须定义在函数体之外</span>
<span class="token keyword">constexpr</span> <span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span><span class="token comment">//p是常量指针，指向整型常量i</span>
<span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token operator">*</span>pi <span class="token operator">=</span> <span class="token operator">&amp;</span>j<span class="token punctuation">;</span><span class="token comment">//pi是常量指针，指向整数j</span>
</code></pre>
</div>
<link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css" rel="stylesheet"/>
<link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css" rel="stylesheet"/>
</div>