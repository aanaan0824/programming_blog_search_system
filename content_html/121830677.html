<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<p></p>
<p></p>
<p id="main-toc"><strong>目录</strong></p>
<p id="%E4%B8%80%E3%80%81%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9A%E4%B9%89-toc" style="margin-left:40px;"><a href="#%E4%B8%80%E3%80%81%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9A%E4%B9%89">一、数组的定义</a></p>
<p id="1.%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-toc" style="margin-left:80px;"><a href="#1.%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">1.基本概念</a></p>
<p id="2.%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-toc" style="margin-left:80px;"><a href="#2.%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">2.抽象数据类型</a></p>
<p id="%E4%BA%8C%E3%80%81%E6%95%B0%E7%BB%84%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E5%92%8C%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E3%80%81%E6%95%B0%E7%BB%84%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E5%92%8C%E5%AE%9E%E7%8E%B0">二、数组的顺序存储和实现</a></p>
<p id="1.%E8%A1%8C%E4%BC%98%E5%85%88%E5%AD%98%E5%82%A8-toc" style="margin-left:80px;"><a href="#1.%E8%A1%8C%E4%BC%98%E5%85%88%E5%AD%98%E5%82%A8">1.行优先存储</a></p>
<p id="2.%E5%88%97%E4%BC%98%E5%85%88%E5%AD%98%E5%82%A8-toc" style="margin-left:80px;"><a href="#2.%E5%88%97%E4%BC%98%E5%85%88%E5%AD%98%E5%82%A8">2.列优先存储</a></p>
<p id="3.%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E5%AD%98%E5%82%A8%E5%9C%B0%E5%9D%80-toc" style="margin-left:80px;"><a href="#3.%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E5%AD%98%E5%82%A8%E5%9C%B0%E5%9D%80">3.多维数组存储地址</a></p>
<p id="%E4%B8%89%E3%80%81%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8-toc" style="margin-left:40px;"><a href="#%E4%B8%89%E3%80%81%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8">三、特殊矩阵的压缩存储</a></p>
<p id="1.%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-toc" style="margin-left:80px;"><a href="#1.%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">1.基本概念</a></p>
<p id="2.%E4%B8%89%E8%A7%92%E7%9F%A9%E9%98%B5-toc" style="margin-left:80px;"><a href="#2.%E4%B8%89%E8%A7%92%E7%9F%A9%E9%98%B5">2.三角矩阵</a></p>
<p id="3.%E5%B8%A6%E7%8A%B6%E7%9F%A9%E9%98%B5-toc" style="margin-left:80px;"><a href="#3.%E5%B8%A6%E7%8A%B6%E7%9F%A9%E9%98%B5">3.带状矩阵</a></p>
<p id="4.%E4%B8%89%E5%85%83%E7%BB%84%E8%A1%A8%E7%A4%BA%E6%B3%95-toc" style="margin-left:80px;"><a href="#4.%E4%B8%89%E5%85%83%E7%BB%84%E8%A1%A8%E7%A4%BA%E6%B3%95">4.三元组表示法</a></p>
<p id="%E2%80%8B-toc" style="margin-left:40px;"><a href="#%E2%80%8B">​</a></p>
<p id="%E5%9B%9B%E3%80%81%E5%B9%BF%E4%B9%89%E8%A1%A8-toc" style="margin-left:40px;"><a href="#%E5%9B%9B%E3%80%81%E5%B9%BF%E4%B9%89%E8%A1%A8">四、广义表</a></p>
<p id="1.%E6%A6%82%E5%BF%B5-toc" style="margin-left:80px;"><a href="#1.%E6%A6%82%E5%BF%B5">1.概念</a></p>
<p id="2.%E8%BF%90%E7%AE%97-toc" style="margin-left:80px;"><a href="#2.%E8%BF%90%E7%AE%97">2.运算</a></p>
<p id="2.%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84-toc" style="margin-left:80px;"><a href="#2.%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84">2.存储结构</a></p>
<hr id="hr-toc"/>
<hr/>
<h2 id="%E4%B8%80%E3%80%81%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9A%E4%B9%89">一、数组的定义</h2>
<h3 id="1.%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">1.基本概念</h3>
<blockquote>
<ul><li><strong>数组</strong>：按照一定格式排列<span style="color:#fe2c24;">同属性</span>的值，为<span style="color:#fe2c24;">相同数据类型</span>元素的集合。常用的有一维数组A[5]、二维数组A[5][5]、多维数组等。</li><li><strong>二维数组</strong>：通常把二维数组作为多维数组的代表，可以看出m个n维的线性表组成，如：<img alt="" height="237" src="image\1569c25c640c45a3a3049dc6db5d1181.png" width="534"/>  </li></ul>
</blockquote>
<h3 id="2.%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">2.抽象数据类型</h3>
<blockquote>
<ul><li> <p style="margin-left:0;text-align:justify;"><span style="color:#fe2c24;">ADT Array</span> {<!-- --><br/><strong>数据对象</strong>：D＝{aj1j2…jn | ji =0,...,bi-1, i=1,2,..,n,       n(&gt;0)称为数组的维数，bi是数组第i维的长度， ji是数组元素的第i维下标，aj1j2…jn∈ElemSet }<br/><strong>数据关系</strong>：R＝{R1, R2, ..., Rn }<br/>   Ri＝{&lt;aj1,...ji,...jn, aj1,...ji+1,...jn, &gt; | 0 ≤jk ≤bk -1, 1 ≤ k ≤ n 且k≠ i, 0 ≤ ji ≤bi -2,    aj1…ji…jn , aj1…ji+1…jn∈D, i=2,...,n </p> </li></ul>
</blockquote>
<h2 id="%E4%BA%8C%E3%80%81%E6%95%B0%E7%BB%84%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E5%92%8C%E5%AE%9E%E7%8E%B0">二、数组的顺序存储和实现</h2>
<blockquote>
<ul><li><strong>存储结构</strong>：数组建立后，数组的个数及维数已经确定，故一般采用顺序存储结构</li><li><strong>存储位置</strong>：<span style="color:#000000;">Loc</span><span style="color:#000000;">（</span><span style="color:#000000;">a</span><span style="color:#000000;">ij</span><span style="color:#000000;">）</span><span style="color:#000000;">= Loc</span><span style="color:#000000;">（a[0][0]</span><span style="color:#000000;">）</span><span style="color:#000000;">+</span><span style="color:#000000;">（       </span><span style="color:#000000;">）*size</span><span style="color:#000000;">（</span><span style="color:#000000;">0≤i≤m</span><span style="color:#000000;">， </span><span style="color:#000000;">0≤j≤n</span><span style="color:#000000;">）</span></li><li><strong>存储次序</strong>： 
   <ul><li>按行优先存储</li><li>按列优先存储</li></ul></li></ul>
</blockquote>
<h3 id="1.%E8%A1%8C%E4%BC%98%E5%85%88%E5%AD%98%E5%82%A8">1.行优先存储</h3>
<p><img alt="" height="100" src="image\d3a4e3a4c89d435a89f84c7f3d102fb5.png" width="400"/></p>
<blockquote>
<p><strong>行优先存储</strong>：将二维数组从第一行到最后一行，按照次序放到一维线性表中，存储位置首元素地址+((i-1)*n+j-1)*1, n为列数</p>
</blockquote>
<h3 id="2.%E5%88%97%E4%BC%98%E5%85%88%E5%AD%98%E5%82%A8">2.列优先存储</h3>
<p style="text-align:center;"><img alt="" height="100" src="image\b214cd9ab5264e878a2060e3d6ad39a7.png" width="400"/></p>
<blockquote>
<p><strong>行优先存储</strong>：将二维数组从第一列到最后一列，按照次序放到一维线性表中，存储位置首元素地址+((j-1)*m+i-1)*1, m为行数</p>
</blockquote>
<h3 id="3.%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E5%AD%98%E5%82%A8%E5%9C%B0%E5%9D%80">3.多维数组存储地址</h3>
<p style="text-align:center;"><img alt="" height="100" src="image\350ab13b08964dc3b5dd2fa8b597a3c9.png" width="400"/></p>
<blockquote>
<ol><li>以上述的一个四位数组为例，首先我们写一个一维数组A[4]（大小和给定的维数相同），上面是四维</li><li>四维数组大小分别为3 4 5 6，A[3]=1,A[2]=6,A[1]=5*6,A[0]=4*5*6,对应相乘</li><li>最后因为求<span style="color:#000000;">A</span><span style="color:#fe2c24;">1</span><span style="color:#38d8f0;">2</span><span style="color:#9c8ec1;">4</span><span style="color:#1c7331;">1</span><span style="color:#000000;">所以结果为   </span><span style="color:#000000;">A</span><span style="color:#000000;">0000+</span><span style="color:#fe2c24;">1</span><span style="color:#000000;">*</span><span style="color:#0d0016;">A[0]</span><span style="color:#000000;">+</span><span style="color:#38d8f0;">2</span><span style="color:#000000;">*</span><span style="color:#0d0016;">A[1</span><span style="color:#339933;">]</span><span style="color:#000000;">+</span><span style="color:#9c8ec1;">4</span><span style="color:#000000;">*</span><span style="color:#0d0016;">A[1]</span><span style="color:#000000;">+</span><span style="color:#1c7331;">1</span><span style="color:#000099;">*</span><span style="color:#0d0016;">A[0]</span></li></ol>
</blockquote>
<h2 id="%E4%B8%89%E3%80%81%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8">三、特殊矩阵的压缩存储</h2>
<h3>1.基本概念</h3>
<blockquote>
<ul><li><strong>稀疏矩阵</strong>：矩阵存储的一种特殊情况，其元素为0个数远大于非0元素个数</li><li><strong>压缩方式</strong>：一维线性表存储，如下图：<img alt="" height="94" src="image\9baece8bbb1e41abbdfd20c829273c20.png" width="639"/></li><li><strong>稀疏因子</strong>： <img alt="" height="112" src="image\dd23aa13d87c41b2b8240b457ad660a7.png" width="776"/></li></ul>
</blockquote>
<h3 id="2.%E4%B8%89%E8%A7%92%E7%9F%A9%E9%98%B5">2.三角矩阵</h3>
<p style="text-align:center;"><img alt="" src="image\a298d006fdfc41ac825f8c095a7519eb.png"/></p>
<blockquote>
<ul><li> <strong>元素个数</strong>：n*(n+1)/2</li><li><strong>按行存储的上三角矩阵</strong>：Loc[i,j]=Loc[1,1]+j*(j-1)/2+i-1</li><li><strong>按行存储的下三角矩阵</strong>：Loc[i,j]=Loc[1,1]+i*(i-1)/2+j-1</li></ul>
</blockquote>
<h3 id="3.%E5%B8%A6%E7%8A%B6%E7%9F%A9%E9%98%B5">3.带状矩阵</h3>
<p style="text-align:center;"><img alt="" height="100" src="image\ca5bf2cf129c43e6be4614370961cae4.png" width="400"/></p>
<blockquote>
<ul><li> <p style="text-align:left;"><span style="color:#0d0016;"><strong>按行存储</strong>：Loc[i,j]=Loc[1,1]+2(i-1)+(j-1)</span></p> </li></ul>
</blockquote>
<h3 id="4.%E4%B8%89%E5%85%83%E7%BB%84%E8%A1%A8%E7%A4%BA%E6%B3%95">4.三元组表示法</h3>
<p style="text-align:center;"><img alt="" height="100" src="image\22b74c54eac14e6a942b526194a72996.png" width="500"/></p>
<blockquote>
<ul><li>i  j 分别表示二维数组的横纵坐标，v表示坐标对应的非0值</li></ul>
</blockquote>
<p><strong>三元组转置动态演示：</strong></p>
<h2 id="%E2%80%8B" style="text-align:center;"><img alt="" height="100" src="https://img-blog.csdnimg.cn/18ad13f41e2e4935ac28a66767f390b7.gif" width="500"/></h2>
<p><strong>编码实现：</strong></p>
<pre><code class="language-cpp">void FastTransposeSMatrix(TSMatrix M, TSMatrix &amp;T) 
　{
　　// 采用三元组顺序表存储表示，求稀疏矩阵M的转置矩阵 T
　　T.mu = M.nu;
　　T.nu = M.mu;
　　T.tu = M.tu;
　　if (T.tu) {
　　　for (col=1; col&lt;=M. nu; ++col)
　　　　num[col] = 0;
　　　for (t=1; t&lt;=M. tu; ++t)
　　　　++num[M.data[t].j];　// 求 M 中每一列所含非零元的个数
　　　cpot[1] = 1;
//求第col列中第一个非零元素在b.data中的序号
for (col=2; col&lt;=M. nu; ++col)
　　cpot[col] = cpot[col-1] + num[col-1];
　　　　// 求T中每一行的第一个非零元在T.data中的序号
for (p=1; p&lt;=M.tu; ++p) { 　// 转置矩阵元素
　　col = M.data[p].j; q = cpot[col];
　　T.data[q].i =M.data[p].j;
　　T.data[q].j =M.data[p].i;
　　T.data[q].e =M.data[p].e;
　　++cpot[col]; 
　　　} // for
　　} // if
} // FastTransposeSMatrix
T(n)=O(M的列数n+非零元个数t，若 t 与m*n同数量级，则T(n)=O(m*n)
</code></pre>
<h2 id="%E5%9B%9B%E3%80%81%E5%B9%BF%E4%B9%89%E8%A1%A8">四、广义表</h2>
<h3 id="1.%E6%A6%82%E5%BF%B5">1.概念</h3>
<blockquote>
<ul><li><strong>广义表</strong>：n个表元素组成的有限序列，<span style="color:#000000;">GL = (d</span><span style="color:#000000;">0</span><span style="color:#000000;">, d</span><span style="color:#000000;">1</span><span style="color:#000000;">, </span><span style="color:#000000;">…</span><span style="color:#000000;">, d</span><span style="color:#000000;">n-1</span><span style="color:#000000;">)   GL是表名，d为表元素</span></li><li><strong>表头（head）</strong>:表中第一个元素，GetHead()取表头 </li><li><strong>表尾（tail）</strong>:表中最后一个元素，GetTail()取表尾</li><li><strong>长度</strong>：最外层包含元素的个数</li><li><strong>深度</strong>：最大所含括弧的重数</li></ul>
</blockquote>
<h3 id="2.%E8%BF%90%E7%AE%97"><span style="color:#38d8f0;">2.运算</span></h3>
<p style="text-align:center;"><img alt="" src="image\dc62870b3f61458e82708ecbacc52616.png"/></p>
<blockquote>
<ul><li> <strong>GetHead</strong> :取广义表的第一个元素，去除最外一层括号</li><li> <strong>GetTail :</strong> 取广义表的最后一个元素，不去除最外一层括号</li><li><strong>深度</strong>  ：最大的括号重数，上图D E F  A深度分别为1 2 2 1 </li><li><strong>长度 </strong>：表中元素个数，上图E和F元素个数为2</li></ul>
</blockquote>
<h3 id="2.%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84">3.存储结构</h3>
<blockquote>
<ul><li><strong>特点</strong>：由于广义表是递归定义的一种带有层次的非线性结构，数据元素具有不同的结构，常常采用链式存储</li><li><strong>表结点</strong>：标志域、表头指针域、表尾指针域组成</li><li><strong>原子结点</strong>：标志域、值域组成</li></ul>
</blockquote>
<p><strong>头尾链表存储结构：</strong></p>
<p style="text-align:center;"><img alt="" height="150" src="image\5b313491c4c24d6ea68da856f9a803db.png" width="500"/></p>
<p><strong>代码实现：</strong></p>
<pre><code class="language-cpp">typedef enum{ATOM, LIST} ElemTag;  /* ATOM==0:原子,LIST==1:子表 */
 typedef struct GLNode
 {
   ElemTag tag; /* 公共部分,用于区分原子结点和表结点 */
   union  /* 原子结点和表结点的联合部分 */
   {
     AtomType atom; /* atom是原子结点的值域,AtomType由用户定义 */
     struct 
           {  struct GLNode *hp,*tp;
		} htp;  /*表结点的指针域htp,包括表头指针域hp和表尾指针域tp*/
	} atom_htp;  /* atom_htp 是原子结点的值域atom和表结点的指针域htp 的联合体域*/
 }*GList,GLNode;  /* 广义表类型 */</code></pre>
<p><strong>扩展线性链表存储结构：</strong></p>
<p style="text-align:center;"><img alt="" height="235" src="image\e23709b9a5d54380a4a3377136e96349.png" width="500"/></p>
<p><strong>代码实现：</strong></p>
<pre><code class="language-cpp">typedef enum{ATOM, LIST}ElemTag; // ATOM==0:原子,LIST==1:子表
 typedef struct GLNode
 {
   ElemTag  tag;   // 公共部分,用于区分原子结点和表结点 union {                   // 原子结点和表结点的联合部分
     AtomType  atom;  // 原子结点的值域 
    struct  GLNode *hp;  // 表结点的表头指针
   }atom_hp;
   struct  GLNode  *tp; // 相当于线性链表的next,指向下一个元素结点 
}*GList,GLNode; // 广义表类型GList是一种扩展的线性链表
</code></pre>
<h3><strong>附录：</strong></h3>
<blockquote>
<ul><li> <p id="articleContentId"><a href="https://blog.csdn.net/qq_53673551/article/details/121749001" title="【图解数据结构】串全面总结">【图解数据结构】串全面总结</a></p> </li><li> <p id="articleContentId"><a href="https://blog.csdn.net/qq_53673551/article/details/122012979" title="【图解数据结构】栈全面总结">【图解数据结构】栈全面总结</a></p> </li><li> <p id="articleContentId"><a href="https://blog.csdn.net/qq_53673551/article/details/122016182" title="【图解数据结构】队列全面总结">【图解数据结构】队列全面总结</a></p> </li><li> <p id="articleContentId"><a href="https://blog.csdn.net/qq_53673551/article/details/121830677" title="【图解数据结构】数组和广义表全面总结">【图解数据结构】数组和广义表全面总结</a></p> </li><li> <p id="articleContentId"><a href="https://blog.csdn.net/qq_53673551/article/details/121876245" title="【图解数据结构】排序全面总结(一)">【图解数据结构】排序全面总结(一)</a></p> </li><li> <p id="articleContentId"><a href="https://blog.csdn.net/qq_53673551/article/details/121889971" title="【图解数据结构】排序全面总结(二)">【图解数据结构】排序全面总结(二)</a></p> </li><li> <p id="articleContentId"><a href="https://blog.csdn.net/qq_53673551/article/details/122267375" title="【图解数据结构】树和二叉树全面总结（上）">【图解数据结构】树和二叉树全面总结（上）</a></p> </li><li> <p><a href="https://blog.csdn.net/qq_53673551/article/details/122268207?spm=1001.2014.3001.5501" title="【图解数据结构】数和二叉树全面总结（中）">【图解数据结构】数和二叉树全面总结（中）</a></p> </li><li> <p>欢迎大家订阅专栏！</p> </li></ul>
</blockquote>
<p></p>
</div>
</div>