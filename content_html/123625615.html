<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="markdown_views prism-atom-one-dark" id="content_views">
<svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
<path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
</svg>
<p><font size="5">😀大家好，我是<strong>白晨</strong>，一个不是很能熬夜😫，但是也想日更的人✈。</font>如果喜欢这篇文章，<strong>点个赞</strong>👍，<strong>关注一下</strong>👀白晨吧！你的支持就是我最大的动力！💪💪💪</p>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/6bc2bf04f5ee40b794642f8570c6a5ac.gif?#pic_center"/></p>
<p></p>
<div class="toc">
<h3>文章目录</h3>
<ul><li><a href="#_11">📔前言</a></li><li><a href="#1_28">📕1.公式选择</a></li><li><a href="#2_61">📗2.实现难点解析</a></li><li><a href="#3_171">📘3.代码实现</a></li><li><a href="#_284">📙后记</a></li></ul>
</div>
<p></p>
<hr/>
<h1><a id="_11"></a>📔前言</h1>
<hr/>
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        π
       
      
      
       π
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">π</span></span></span></span></span> 一直是一个备受数学界青睐的数字。从古至今，无数的学者都在努力探求着 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        π
       
      
      
       π
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">π</span></span></span></span></span> 精确值。🤼‍♂️从祖冲之到欧拉，📖从圣经到《数理精蕴》，从东至西，历经几千年的发展，特别是在计算机发明之后，对于 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        π
       
      
      
       π
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">π</span></span></span></span></span> 的求解可以说是一日千里，现在计算到几十亿位以后已经不值得惊讶。</p>
<p>🧐这篇文章，白晨想带大家去了解利用计算机求解 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        π
       
      
      
       π
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">π</span></span></span></span></span> 的一种方法，其中涉及到 C++，链表，大数四则运算等知识点。我会尽可能详细的讲解每一个难点的实现。</p>
<p>题目参考：</p>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/490253bb80194826b1b63f5a50631a33.png?#pic_centerx-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA55m95pmo5bm25LiN5piv5b6I6IO954as5aSc,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<p>这次我们的最低目标是在3000ms的限制内，实现计算 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        π
       
      
      
       π
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">π</span></span></span></span></span> 到小数点后500位。</p>
<hr/>
<h1><a id="1_28"></a>📕1.公式选择</h1>
<hr/>
<p>首先，如果不清楚如何计算 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        π
       
      
      
       π
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">π</span></span></span></span></span> 的同学可以先参考下面的文章，有助于理解下面的公式选择。</p>
<blockquote>
<p><a href="https://www.zhihu.com/question/24940378">π 是怎么算出来的？</a></p>
</blockquote>
<p>相信大家看完后已经对 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        π
       
      
      
       π
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">π</span></span></span></span></span> 的求法有一定的认识了，所以这里给出几个关于 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        π
       
      
      
       π
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">π</span></span></span></span></span> 的几个公式：</p>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/9c6c5cf53a074da7a30ab7b5d1bcfc36.png?#pic_centerx-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA55m95pmo5bm25LiN5piv5b6I6IO954as5aSc,size_9,color_FFFFFF,t_70,g_se,x_16"/></p>
<p>我们这里选择第三个公式，为什么呢？</p>
<p>当然是因为第三个公式是题目给出的反正切函数的幂次展开式啦（bushi）</p>
<p>其实是因为第三个公式是线性收敛，平均每计算一次就会得到0.3个有效数字，相比于第四个<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        a
       
       
        r
       
       
        c
       
       
        t
       
       
        a
       
       
        n
       
       
        x
       
      
      
       arctanx
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.61508em; vertical-align: 0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right: 0.02778em;">r</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">x</span></span></span></span></span>泰勒展开公式（莱布尼茨公式）来说，效率上会高出很多，而且最重要的一点是它比较容易实现，递推公式如下：</p>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/c3665a5f6043454ea7de169204c1bc90.png?#pic_center"/></p>
<p>将其展开就是第三个公式，大家可以对比着看。</p>
<blockquote>
<p>关于<span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         a
        
        
         r
        
        
         c
        
        
         t
        
        
         a
        
        
         n
        
        
         x
        
       
       
        arctanx
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.61508em; vertical-align: 0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right: 0.02778em;">r</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">x</span></span></span></span></span>泰勒展开计算 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         π
        
       
       
        π
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">π</span></span></span></span></span> 可以参考此篇文章：<a href="https://blog.csdn.net/xfxyy_sxfancy/article/details/48378121">π的计算</a></p>
</blockquote>
<p>反正切函数的幂次展开式的推导具体过程：</p>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/062b840747544f989d4588fc91f10dbe.png?#pic_centerx-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA55m95pmo5bm25LiN5piv5b6I6IO954as5aSc,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<hr/>
<h1><a id="2_61"></a>📗2.实现难点解析</h1>
<hr/>
<blockquote>
<ul><li>关于大数实现：</li></ul>
</blockquote>
<p>这里我们选择 C++ 模板中的 list 类来实现（也可以使用string类等，只要可以进行大数四则运算就可以，这里为了符合题意使用链表），由于 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        π
       
      
      
       π
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">π</span></span></span></span></span> 的整数部分为3，所以我们只需要一位来存储整数部分，也即front存储整数部分，其余小数点以后的位顺次向后连接。</p>
<p>我们的核心目标是要实现：</p>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/fafde340af934e42b867bd1cd024b087.png#pic_center"/></p>
<p>我们将上面的任务拆开，分解成一个个独立的任务</p>
<blockquote>
<ul><li><span class="katex--inline"><span class="katex"><span class="katex-mathml">
      
       
        
         
          R
         
         
          (
         
         
          n
         
         
          )
         
         
          ∗
         
         
          n
         
        
        
         R(n) * n
        
       
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.00773em;">R</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span></span></span></span></span></li></ul>
</blockquote>
<p>这里我们选择模拟竖式乘法：</p>
<ul><li>从链表尾结点开始，每个结点的数乘n。</li><li>结点中只能存放个位数，所以当乘得结果大于等于10，需要保存进位。</li><li>每次计算乘法时，还需要加上前一个数的进位。</li><li>循环上述过程，直到头节点。</li></ul>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/f2154b31de394f78a357616e4ab967fc.gif?#pic_center"/></p>
<blockquote>
<ul><li><span class="katex--inline"><span class="katex"><span class="katex-mathml">
      
       
        
         
          R
         
         
          (
         
         
          n
         
         
          )
         
         
          ∗
         
         
          n
         
         
          /
         
         
          （
         
         
          2
         
         
          ∗
         
         
          n
         
         
          +
         
         
          1
         
         
          ）
         
        
        
         R(n) * n/（2*n+1）
        
       
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.00773em;">R</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord cjk_fallback">（</span><span class="mord">2</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.66666em; vertical-align: -0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span><span class="mord cjk_fallback">）</span></span></span></span></span></li></ul>
</blockquote>
<p>这里我们选择模拟竖式除法：</p>
<ul><li>用上面乘法得到的结果除以(2n + 1)。</li><li>除法与乘法相反，我们要从头节点开始除法。</li><li>每一位除以(2n + 1)得到的结果就是：(此节点的值 + 上一个结点的余数*10) /(2n + 1)。</li><li>再保存这个结点除以(2n + 1)后所得的余数。</li><li>循环上述过程，直到尾节点</li></ul>
<p>此处不再演示，大家可以类比乘法动手模拟一下，其实非常相似，代码也很相似。</p>
<blockquote>
<ul><li><span class="katex--inline"><span class="katex"><span class="katex-mathml">
      
       
        
         
          S
         
         
          u
         
         
          m
         
         
          (
         
         
          n
         
         
          +
         
         
          1
         
         
          )
         
         
          =
         
         
          S
         
         
          u
         
         
          m
         
         
          (
         
         
          n
         
         
          )
         
         
          +
         
         
          R
         
         
          (
         
         
          n
         
         
          +
         
         
          1
         
         
          )
         
        
        
         Sum(n + 1) = Sum(n) + R(n + 1)
        
       
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.05764em;">S</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.05764em;">S</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.00773em;">R</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></li></ul>
</blockquote>
<p>这就是递推公式的最后一步，将上面计算得到的 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        R
       
       
        (
       
       
        n
       
       
        +
       
       
        1
       
       
        )
       
      
      
       R(n+1)
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.00773em;">R</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span> 加到 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        S
       
       
        u
       
       
        m
       
       
        (
       
       
        n
       
       
        )
       
      
      
       Sum(n)
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.05764em;">S</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span> 上，这其实就是一个大数加法的问题，我们选择模拟竖式加法：</p>
<ul><li>从最低位开始， <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         R
        
        
         (
        
        
         n
        
        
         +
        
        
         1
        
        
         )
        
       
       
        R(n+1)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.00773em;">R</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span> 与 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         S
        
        
         u
        
        
         m
        
        
         (
        
        
         n
        
        
         )
        
       
       
        Sum(n)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.05764em;">S</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span> 对应的位相加。</li><li>相加得到的值如果大于等于10，需要进位。</li><li>对应位相加得到的结果需要加上进位</li><li>循环上述过程，直到头节点</li></ul>
<p>此过程与乘法非常相近，在后面的代码实现中我们可以看出。</p>
<blockquote>
<ul><li>关于链表结点个数</li></ul>
</blockquote>
<p>链表结点数代表着小数点后的位数，所以当然是结点越多越精确，但是结点数太多会影响性能。如果我们要实现500位的精确值，我的建议是创建550~600个结点即可。</p>
<blockquote>
<ul><li>关于要迭代的次数</li></ul>
</blockquote>
<p>这里有两种根据所求精度估算大致的迭代的次数的方法：</p>
<ol><li> <p>估算精度</p> <pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> 
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">double</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		a <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
		b <span class="token operator">=</span> i<span class="token punctuation">;</span>
		sum <span class="token operator">=</span> sum <span class="token operator">+</span> <span class="token function">log10</span><span class="token punctuation">(</span>a <span class="token operator">/</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
		i<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">&gt;</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> i<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>参考文章：<a href="https://blog.csdn.net/abcdef0623/article/details/115333771?spm=1001.2014.3001.5502">数据结构实验1.2—高精度计算PI值（西工大）</a></p>
</blockquote> </li><li> <p>估算有效数字</p> </li></ol>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/e6b2af3aa7a949cd82d07619a7432e59.png"/></p>
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">double</span> ret <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span>n<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>ret <span class="token operator">/</span> <span class="token number">0.3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>参考文章：<a href="https://www.zhihu.com/question/312520105">目前求 π 的算法中哪种收敛最快？</a></p>
</blockquote>
<p>以上两种方法都可以使用，根据我在release发布版本的测试下，两种方法没有数量级的差别，所以使用哪一种都可以。</p>
<p><strong>注：如果要提升精度，必须也增大结点个数，不能只增加迭代次数</strong></p>
<p>测试结果：</p>
<blockquote>
<p><strong>方法一：</strong><br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/fe1d4d3068694db7ab87d3ab8ba10c48.png?#pic_centerx-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA55m95pmo5bm25LiN5piv5b6I6IO954as5aSc,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<p><strong>方法二：</strong><br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/63ba142796b74151897857e6bd1869af.png?#pic_centerx-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA55m95pmo5bm25LiN5piv5b6I6IO954as5aSc,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
</blockquote>
<hr/>
<h1><a id="3_171"></a>📘3.代码实现</h1>
<hr/>
<pre><code class="prism language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;time.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;list&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;math.h&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token comment">// 估测要计算的次数</span>
<span class="token comment">// 方法一：</span>
<span class="token keyword">int</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> 
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">double</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		a <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
		b <span class="token operator">=</span> i<span class="token punctuation">;</span>
		sum <span class="token operator">=</span> sum <span class="token operator">+</span> <span class="token function">log10</span><span class="token punctuation">(</span>a <span class="token operator">/</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
		i<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">&gt;</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> i<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 方法二：</span>
<span class="token keyword">int</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">double</span> ret <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span>n<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>ret <span class="token operator">/</span> <span class="token number">0.3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
<span class="token comment">// 定义我们需要多少个结点</span>
<span class="token macro property">#<span class="token directive keyword">define</span> NODE_NUM 550</span>
	list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">num</span><span class="token punctuation">(</span>NODE_NUM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 存放R(n)</span>
	list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">sum</span><span class="token punctuation">(</span>NODE_NUM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 存放Sum(n)</span>
	<span class="token keyword">int</span> print<span class="token punctuation">;</span><span class="token comment">// 所需精度</span>
	cin <span class="token operator">&gt;&gt;</span> print<span class="token punctuation">;</span>
	<span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token function">count</span><span class="token punctuation">(</span>print<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 所需迭代次数</span>
    
	<span class="token comment">// 我们直接将 R(1) 初始化为2，这样就可以免去后面再统一乘2</span>
	num<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
	sum<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
	
	<span class="token comment">// 这里循环的 i 就是 n </span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> cnt<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>			
		<span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">// 记录进位，补位情况</span>

	 <span class="token comment">// 计算R(n + 1)</span>
	
		<span class="token comment">// 计算 R(n) * n</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">::</span>reverse_iterator cur1 <span class="token operator">=</span> num<span class="token punctuation">.</span><span class="token function">rbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> cur1 <span class="token operator">!=</span> num<span class="token punctuation">.</span><span class="token function">rend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> cur1<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 每一位都是本位乘i，再加上进位</span>
			<span class="token keyword">int</span> val <span class="token operator">=</span> <span class="token operator">*</span>cur1 <span class="token operator">*</span> i <span class="token operator">+</span> ret<span class="token punctuation">;</span>
            <span class="token comment">// 保存进位</span>
			ret <span class="token operator">=</span> val <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">;</span>
            <span class="token comment">// 保存本位</span>
			<span class="token operator">*</span>cur1 <span class="token operator">=</span> val <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token comment">// 计算 R(n) * n / (2n + 1)</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">::</span>iterator cur1 <span class="token operator">=</span> num<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> cur1 <span class="token operator">!=</span> num<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> cur1<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 除数</span>
			<span class="token keyword">int</span> div <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token comment">// 加上前一位的余数</span>
			<span class="token keyword">int</span> val <span class="token operator">=</span> <span class="token operator">*</span>cur1 <span class="token operator">+</span> ret <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">;</span>
            <span class="token comment">// 除法，保存本位</span>
			<span class="token operator">*</span>cur1 <span class="token operator">=</span> val <span class="token operator">/</span> div<span class="token punctuation">;</span>
            <span class="token comment">// 保存余数</span>
			ret <span class="token operator">=</span> val <span class="token operator">-</span> <span class="token operator">*</span>cur1 <span class="token operator">*</span> div<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token comment">// 计算 sum += R(n + 1)</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> cur2 <span class="token operator">=</span> sum<span class="token punctuation">.</span><span class="token function">rbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cur1 <span class="token operator">=</span> num<span class="token punctuation">.</span><span class="token function">rbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> cur2 <span class="token operator">!=</span> sum<span class="token punctuation">.</span><span class="token function">rend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> cur2<span class="token operator">++</span><span class="token punctuation">,</span> cur1<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 大数加法</span>
			<span class="token keyword">int</span> val <span class="token operator">=</span> <span class="token operator">*</span>cur1 <span class="token operator">+</span> <span class="token operator">*</span>cur2 <span class="token operator">+</span> ret<span class="token punctuation">;</span>
			<span class="token operator">*</span>cur2 <span class="token operator">=</span> val <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>
			ret <span class="token operator">=</span> val <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	
	<span class="token punctuation">}</span>
	<span class="token comment">// 打印</span>
	cout <span class="token operator">&lt;&lt;</span> sum<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'.'</span><span class="token punctuation">;</span>
	list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">::</span>iterator it <span class="token operator">=</span> sum<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	it<span class="token operator">++</span><span class="token punctuation">;</span>

	<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> print<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>it<span class="token punctuation">;</span>
		it<span class="token operator">++</span><span class="token punctuation">;</span>
		i<span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<hr/>
<h1><a id="_284"></a>📙后记</h1>
<hr/>
<p>这个方法其实还是有改进的细节，比如：</p>
<ol><li>将输入输出更换为scanf和printf，因为其实在效率上 cin和cout 比前者慢了几十倍，在输出大型数字时，效率会受影响。</li><li>公式限制，其实比反正切幂次展开更高效的公式还是很多，这里只是为了实现简单和逻辑清晰而选择了反正切幂次展开，大家有兴趣可以参考下图公式自己去实现。</li></ol>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/8436d305ee6643c0a4566c6cf5cf7e67.png?#pic_centerx-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA55m95pmo5bm25LiN5piv5b6I6IO954as5aSc,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<blockquote>
<p>参考文章：<a href="https://www.zhihu.com/question/312520105">目前求 π 的算法中哪种收敛最快？</a></p>
</blockquote>
<hr/>
<p>这是一个新的系列 ——【算法】，想来想去将这个计算 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        π
       
      
      
       π
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">π</span></span></span></span></span> 的文章放到了【算法】系列的开篇。因为其中确实有不少算法的实现，并且难度不是很大，很适合想学习C++或者算法的入门学习，在探求 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        π
       
      
      
       π
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">π</span></span></span></span></span> 的实践中一路学习高数🦄和编程（bushi）。</p>
<p>如果解析有不对之处还请指正，我会尽快修改，多谢大家的包容。</p>
<p>如果大家喜欢这个系列，还请大家多多支持啦😋！</p>
<p>如果这篇文章有帮到你，还请给我一个<code>大拇指</code> 👍和<code>小星星</code> ⭐️支持一下白晨吧！喜欢白晨【算法】系列的话，不如<code>关注</code>👀白晨，以便看到最新更新哟！！！</p>
<p>我是不太能熬夜的白晨，我们下篇文章见。</p>
</div>
<link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css" rel="stylesheet"/>
<link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css" rel="stylesheet"/>
</div>