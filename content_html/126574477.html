<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="markdown_views prism-github-gist" id="content_views">
<svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
<path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
</svg>
<p></p>
<div class="toc">
<h3>文章目录</h3>
<ul><li><a href="#_7">基本思想</a></li><li><a href="#_15">递归版本</a></li><li><a href="#_32">非递归版本</a></li><li><a href="#Hoare_60">Hoare法</a></li><li><ul><li><a href="#_62">算法步骤</a></li><li><a href="#_69">动图演示</a></li><li><a href="#_73">代码实现</a></li><li><a href="#Hoare_95">Hoare法必须先从右边开始走</a></li></ul>
</li><li><a href="#_102">挖坑法</a></li><li><ul><li><a href="#_104">算法步骤</a></li><li><a href="#_111">动图演示</a></li><li><a href="#_115">代码实现</a></li></ul>
</li><li><a href="#_138">前后指针法</a></li><li><ul><li><a href="#_140">算法步骤</a></li><li><a href="#_146">动图演示</a></li><li><a href="#_150">代码实现</a></li></ul>
</li><li><a href="#_168">快速排序的两种优化方法（可合并使用）</a></li><li><ul><li><a href="#_170">优化一：</a></li><li><a href="#_231">优化二：</a></li></ul>
</li><li><a href="#_251">复杂度、稳定性分析</a></li></ul>
</div>
<br/> 快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。
<p></p>
<p>快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。</p>
<p>快速排序又是一种分而治之思想在排序算法上的典型应用。</p>
<h1><a id="_7"></a>基本思想</h1>
<p>对于待排序序列，使用<strong>某种划分方法</strong>排好一个值key，使得key前面的所有值都比key小，key后面的所有值都比key大（升序），从而以key为界限分成了左右两个待排序的子序列，然后分别对子序列进行上述步骤。</p>
<p>框架分为两种：递归和非递归</p>
<p>某种划分方法分为三种：Hoare、挖坑法、前后指针法</p>
<h1><a id="_15"></a>递归版本</h1>
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">QuickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">&gt;=</span> right<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
	<span class="token comment">//对待排序序列使用划分方法，得到基准值的下标keyi</span>
	<span class="token keyword">int</span> keyi <span class="token operator">=</span> <span class="token function">QuickSortPart</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//划分有三种方法</span>
	<span class="token comment">// 划分成功后以keyi为边界形成了左右两部分 [left, keyi - 1] 和 [keyi + 1, right]</span>
	<span class="token comment">// 递归排[left, keyi - 1]</span>
	<span class="token function">QuickSort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> left<span class="token punctuation">,</span> keyi <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 递归排[keyi + 1, right]</span>
	<span class="token function">QuickSort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> keyi <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h1><a id="_32"></a>非递归版本</h1>
<p>递归的本质实际就是在控制待排序序列的区间，而非递归版本就是用栈模拟递归去保存和使用待排序序列的区间</p>
<pre><code class="prism language-c"><span class="token comment">//使用栈的前序遍历模拟递归</span>
<span class="token keyword">void</span> <span class="token function">QuickSortNoR</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	Stack obj<span class="token punctuation">;</span>
    <span class="token function">StackInit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">StackPush</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>obj<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将待排序序列的左右区间入栈</span>
    <span class="token function">StackPush</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>obj<span class="token punctuation">,</span> left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">StackEmpty</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token function">StackTop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//取出待排序序列的左右区间</span>
        <span class="token function">StackPop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token function">StackTop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">StackPop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> keyi <span class="token operator">=</span> <span class="token function">QuickSortPart</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//排序区间内的数据，得到基准值的下标keyi</span>
        <span class="token function">StackPush</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>obj<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将基准值右边的区间入栈</span>
        <span class="token function">StackPush</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>obj<span class="token punctuation">,</span> keyi <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">StackPush</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>obj<span class="token punctuation">,</span> keyi <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将基准值左边的区间入栈</span>
        <span class="token function">StackPush</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>obj<span class="token punctuation">,</span> left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">StackDestroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h1><a id="Hoare_60"></a>Hoare法</h1>
<h2><a id="_62"></a>算法步骤</h2>
<ol><li>从数列中选出一个基准值（key），一般为数列的第一个元素</li><li>从后往前遍历挑出比key小的值，停下；从前往后遍历挑出比key大的值，停下；然后交换这两个值</li><li>继续从后往前遍历……从前往后遍历……交换，直到左边和右边相遇记录为meeti，此时交换key和meeti的值</li><li>返回相遇位置meeti，从而完成分区。</li></ol>
<h2><a id="_69"></a>动图演示</h2>
<p><img alt="hoare" src="https://img-blog.csdnimg.cn/img_convert/0643c427d75b23aa2579951b7aedea60.gif"/></p>
<h2><a id="_73"></a>代码实现</h2>
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">QuickSortPart</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> keyi <span class="token operator">=</span> left<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> a<span class="token punctuation">[</span>keyi<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            right<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> a<span class="token punctuation">[</span>keyi<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            left<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">int</span> meeti <span class="token operator">=</span> left<span class="token punctuation">;</span>
    <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>keyi<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>meeti<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> meeti<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h2><a id="Hoare_95"></a>Hoare法必须先从右边开始走</h2>
<p>因为只有先从右边开始走，才能够保证相遇位置meeti比keyi的值小，原因如下：</p>
<ol><li>左边去相遇右边时，由于右边先停，而右边停的条件是值小于key，所以此时相遇点的值小于key</li><li>右边去相遇左边时，左边此时是上一次交换之后的位置，此时的左边位置的值是小于key的，所以相遇点的值小于key</li></ol>
<h1><a id="_102"></a>挖坑法</h1>
<h2><a id="_104"></a>算法步骤</h2>
<ol><li>从数列中选出一个基准值（key），一般为数列的第一个元素，将基准值key取出，把该位置记录成一个坑hole</li><li>从后往前寻找比key小的值，然后将该值填入hole中，该值的原位置记录为新的hole</li><li>从前往后寻找比key大的值，然后将该值填入hole中，该值的原位置记录为新的hole</li><li>直到前后位置相遇，将key填入hole中，返回hole即可完成分区</li></ol>
<h2><a id="_111"></a>动图演示</h2>
<p><img alt="挖坑法" src="https://img-blog.csdnimg.cn/img_convert/bf6c486cf5ba5114c2aa0f4840078666.gif"/></p>
<h2><a id="_115"></a>代码实现</h2>
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">QuickSortPart</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> key <span class="token operator">=</span> a<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> hole <span class="token operator">=</span> left<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> key<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            right<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        a<span class="token punctuation">[</span>hole<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span>
        hole <span class="token operator">=</span> right<span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> key<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            left<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        a<span class="token punctuation">[</span>hole<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>
        hole <span class="token operator">=</span> left<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    a<span class="token punctuation">[</span>hole<span class="token punctuation">]</span> <span class="token operator">=</span> key<span class="token punctuation">;</span>
    <span class="token keyword">return</span> hole<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h1><a id="_138"></a>前后指针法</h1>
<h2><a id="_140"></a>算法步骤</h2>
<ol><li>从数列中选出一个基准值（key），一般为数列的第一个元素</li><li>前指针cur和后指针prev从前往后遍历，cur一直移动，当遇到小于key的值时，prev才往前移动，如果cur和prev不相等则交换两值（cur和prev之间有两种状态，要么prev和cur紧贴之间无数据，要么prev和cur之间有数据并且该数据是大于key的）</li><li>当cur遍历完之后，prev之前的数据全部小于prev，之后的数据全部大于prev，于是就从prev为界限分区了，此时返回prev</li></ol>
<h2><a id="_146"></a>动图演示</h2>
<p><img alt="前后指针" src="https://img-blog.csdnimg.cn/img_convert/2e8ed8b8378bd802d2d6374293159866.gif"/></p>
<h2><a id="_150"></a>代码实现</h2>
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">QuickSortPart</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> keyi <span class="token operator">=</span> left<span class="token punctuation">;</span>
    <span class="token keyword">int</span> prev <span class="token operator">=</span> left<span class="token punctuation">;</span>
    <span class="token keyword">int</span> cur <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>cur <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>cur<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>keyi<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">++</span>prev <span class="token operator">!=</span> cur<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>prev<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        cur<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>keyi<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>prev<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> prev<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h1><a id="_168"></a>快速排序的两种优化方法（可合并使用）</h1>
<h2><a id="_170"></a>优化一：</h2>
<p>快速排序最理想的状态也就是最优的时间复杂度为<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        O
       
       
        (
       
       
        N
       
       
        ∗
       
       
        l
       
       
        o
       
       
        
         g
        
        
         N
        
       
       
        )
       
      
      
       O(N*log^{N})
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.109em;">N</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1.0913em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8413em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right: 0.109em;">N</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>，而达到这一目的的最好的情况是每次分区时，都几乎是从中间分区的，这样才能够达到把<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        N
       
      
      
       N
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.109em;">N</span></span></span></span></span>个数据分为<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        l
       
       
        o
       
       
        
         g
        
        
         N
        
       
      
      
       log^{N}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.0358em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8413em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right: 0.109em;">N</span></span></span></span></span></span></span></span></span></span></span></span></span>层，而如果当待排序序列是有序时，则快速排序会把<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        N
       
      
      
       N
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.109em;">N</span></span></span></span></span>个数据分为<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        N
       
      
      
       N
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.109em;">N</span></span></span></span></span>层，就会使得时间复杂度变为<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        O
       
       
        (
       
       
        
         N
        
        
         2
        
       
       
        )
       
      
      
       O(N^{2})
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.0641em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.109em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>，这是非常糟糕的，所以为了减少这种情况，出现了一个优化函数。</p>
<p>该函数的功能是取到序列的第一个数、中间的数、最后一个数，然后比较大小，返回大小为中间的那个数的下标。</p>
<p>下一步就是将该下标的值与序列的第一个值交换，这样就会造成，假设之前的序列是有序的，而现在的序列的第一个值会是序列中间的那个值，从而以该值为key分区时能够减少只分出一个区的情况，即减少把N个数据分为N层的情况。</p>
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">GetMidIndex</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> begin<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> mid <span class="token operator">=</span> begin <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>end <span class="token operator">-</span> begin<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>begin<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> a<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> mid<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>begin<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> a<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> end<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> begin<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>begin<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> a<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> begin<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> a<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> end<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> mid<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>该函数这样使用（以Hoare法举例）</p>
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">QuickSortPart</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token function">GetMidIndex</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//上面是优化，其它两种分区方法也是这样使用优化</span>
    <span class="token keyword">int</span> keyi <span class="token operator">=</span> left<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> a<span class="token punctuation">[</span>keyi<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            right<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> a<span class="token punctuation">[</span>keyi<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            left<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">int</span> meeti <span class="token operator">=</span> left<span class="token punctuation">;</span>
    <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>keyi<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>meeti<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> meeti<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h2><a id="_231"></a>优化二：</h2>
<p>快速排序的理想状态就是将<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        N
       
      
      
       N
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.109em;">N</span></span></span></span></span>个数据分成<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        l
       
       
        o
       
       
        
         g
        
        
         N
        
       
      
      
       log^{N}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.0358em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8413em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right: 0.109em;">N</span></span></span></span></span></span></span></span></span></span></span></span></span>层，达到近似完全二叉树的形状，而完全二叉树的最后三层递归将会达到整个递归过程中的87.5%，而最后的三层递归也就最多只有8个数据，与其让这8个数据递归这么多次还不如直接进行插入排序，这样将会减少巨额的递归次数，从而优化排序的速度。</p>
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">QuickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">&gt;=</span> right<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;=</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token comment">//当数据小于等于8时，不再进行递归了，改为插入排序</span>
        <span class="token function">Insert</span><span class="token punctuation">(</span>a <span class="token operator">+</span> left<span class="token punctuation">,</span> right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span><span class="token punctuation">{<!-- --></span><span class="token comment">//当数据量大于8时，才去递归</span>
        <span class="token keyword">int</span> keyi <span class="token operator">=</span> <span class="token function">QuickSortPart</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">QuickSort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> left<span class="token punctuation">,</span> keyi <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">QuickSort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> keyi <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<h1><a id="_251"></a>复杂度、稳定性分析</h1>
<ol><li> <p><strong>时间复杂度</strong></p> <p><strong>最优时间复杂度<span class="katex--inline"><span class="katex"><span class="katex-mathml">
       
        
         
          
           O
          
          
           (
          
          
           N
          
          
           ∗
          
          
           l
          
          
           o
          
          
           
            g
           
           
            N
           
          
          
           )
          
         
         
          O(N*log^{N})
         
        
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.109em;">N</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1.0913em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8413em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right: 0.109em;">N</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></strong></p> <p><strong>最差时间复杂度<span class="katex--inline"><span class="katex"><span class="katex-mathml">
       
        
         
          
           O
          
          
           (
          
          
           
            N
           
           
            2
           
          
          
           )
          
         
         
          O(N^{2})
         
        
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.0641em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.109em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></strong></p> </li><li> <p><strong>空间复杂度</strong></p> <p><strong>最优空间复杂度<span class="katex--inline"><span class="katex"><span class="katex-mathml">
       
        
         
          
           O
          
          
           (
          
          
           l
          
          
           o
          
          
           
            g
           
           
            N
           
          
          
           )
          
         
         
          O(log^{N})
         
        
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.0913em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8413em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right: 0.109em;">N</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></strong></p> <p><strong>最差时间复杂度<span class="katex--inline"><span class="katex"><span class="katex-mathml">
       
        
         
          
           O
          
          
           (
          
          
           N
          
          
           )
          
         
         
          O(N)
         
        
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.109em;">N</span><span class="mclose">)</span></span></span></span></span></strong></p> <p>递归主要消耗在栈空间，非递归主要消耗在堆上</p> </li><li> <p><strong>稳定性</strong></p> <p>快速排序<strong>是不稳定的</strong></p> </li></ol>
</div>
<link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css" rel="stylesheet"/>
<link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css" rel="stylesheet"/>
</div>