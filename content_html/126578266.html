<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<p id="main-toc"><strong>目录</strong></p>
<p id="-toc" style="margin-left:0px;"></p>
<p id="1.Vector%E7%9A%84%E4%BB%8B%E7%BB%8D-toc" style="margin-left:0px;"><a href="#1.Vector%E7%9A%84%E4%BB%8B%E7%BB%8D">1.Vector的介绍</a></p>
<p id="1.1%20Vector%E7%9A%84%E4%BB%8B%E7%BB%8D-toc" style="margin-left:40px;"><a href="#1.1%20Vector%E7%9A%84%E4%BB%8B%E7%BB%8D">1.1 Vector的介绍</a></p>
<p id="2.Vector%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:0px;"><a href="#2.Vector%E7%9A%84%E4%BD%BF%E7%94%A8">2.Vector的使用</a></p>
<p id="2.1%20vector%E7%9A%84%E5%AE%9A%E4%B9%89-toc" style="margin-left:40px;"><a href="#2.1%20vector%E7%9A%84%E5%AE%9A%E4%B9%89">2.1 vector的定义</a></p>
<p id="2.2%20vector%20%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8%C2%A0-toc" style="margin-left:40px;"><a href="#2.2%20vector%20%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8%C2%A0">2.2 vector 迭代器的使用 </a></p>
<p id="2.3%20vector%E7%9A%84%E7%A9%BA%E9%97%B4%E5%A2%9E%E9%95%BF%E9%97%AE%E9%A2%98-toc" style="margin-left:40px;"><a href="#2.3%20vector%E7%9A%84%E7%A9%BA%E9%97%B4%E5%A2%9E%E9%95%BF%E9%97%AE%E9%A2%98">2.3 vector的空间增长问题</a></p>
<p id="3.%20vector%E7%9A%84%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9-toc" style="margin-left:0px;"><a href="#3.%20vector%E7%9A%84%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9">3. vector的增删查改</a></p>
<p id="3.1%20push_back%20%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89-toc" style="margin-left:40px;"><a href="#3.1%20push_back%20%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89">3.1 push_back （重点）</a></p>
<p id="3.2%20pop_back%20(%E9%87%8D%E7%82%B9)-toc" style="margin-left:40px;"><a href="#3.2%20pop_back%20%28%E9%87%8D%E7%82%B9%29">3.2 pop_back (重点)</a></p>
<p id="3.3%20insert-toc" style="margin-left:40px;"><a href="#3.3%20insert">3.3 insert</a></p>
<p id="3.4%20erase-toc" style="margin-left:40px;"><a href="#3.4%20erase">3.4 erase</a></p>
<p id="3.5%20operator%20%5B%20%5D%C2%A0-toc" style="margin-left:40px;"><a href="#3.5%20operator%20%5B%20%5D%C2%A0">3.5 operator [ ] </a></p>
<hr id="hr-toc"/>
<p></p>
<p></p>
<p></p>
<h1 id="1.Vector%E7%9A%84%E4%BB%8B%E7%BB%8D">1.Vector的介绍</h1>
<h2 id="1.1%20Vector%E7%9A%84%E4%BB%8B%E7%BB%8D">1.1 Vector的介绍</h2>
<p><a class="link-info" href="http://www.cplusplus.com/reference/vector/vector/" title="vector官方文档介绍">vector官方文档介绍</a></p>
<blockquote>
<p>1.vector是表示可变大小数组的序列容器。</p>
<p></p>
<div>
<span style="color:#777777;">2. </span>
<span style="color:#777777;">就像数组一样，</span>
<span style="color:#777777;">vector</span>
<span style="color:#777777;">也采用的连续存储空间来存储元素。也就是意味着可以采用下标对</span>
<span style="color:#777777;">vector</span>
<span style="color:#777777;">的元素进行访问，和数组一样高效。但是又不像数组，它的大小是可以动态改变的，而且它的大小会被容器自动处理。</span>
</div>
<div></div>
<div>
<div>
<span style="color:#777777;">3. </span>
<span style="color:#777777;">本质讲，</span>
<span style="color:#777777;">vector</span>
<span style="color:#777777;">使用动态分配数组来存储它的元素。当新元素插入时候，这个数组需要被重新分配大小 为了增加存储空间。其做法是，分配一个新的数组，然后将全部元素移到这个数组。就时间而言，这是一个相对代价高的任务，因为每当一个新的元素加入到容器的时候，vector</span>
<span style="color:#777777;">并不会每次都重新分配大小。</span>
</div>
<div></div>
<div>
<div>
<span style="color:#777777;">4. vector</span>
<span style="color:#777777;">分配空间策略：</span>
<span style="color:#777777;">vector</span>
<span style="color:#777777;">会分配一些额外的空间以适应可能的增长，因为存储空间比实际需要的存储空间更大。不同的库采用不同的策略权衡空间的使用和重新分配。但是无论如何，重新分配都应该是对数增长的间隔大小，以至于在末尾插入一个元素的时候是在常数时间的复杂度完成的。 </span>
</div>
<div></div>
<div>
<span style="color:#777777;">5. </span>
<span style="color:#777777;">因此，</span>
<span style="color:#777777;">vector</span>
<span style="color:#777777;">占用了更多的存储空间，为了获得管理存储空间的能力，并且以一种有效的方式动态增长。 </span>
</div>
<div></div>
<div>
<span style="color:#777777;">6. </span>
<span style="color:#777777;">与其它动态序列容器相比（</span>
<span style="color:#777777;">deque, list and forward_list</span>
<span style="color:#777777;">），</span>
<span style="color:#777777;"> vector</span>
<span style="color:#777777;">在访问元素的时候更加高效，在末尾添加和删除元素相对高效。对于其它不在末尾的删除和插入操作，效率更低。比起list</span>
<span style="color:#777777;">和</span>
<span style="color:#777777;">forward_list统一的迭代器和引用更好</span>
</div>
</div>
</div>
</blockquote>
<p></p>
<h1 id="2.Vector%E7%9A%84%E4%BD%BF%E7%94%A8"><strong>2.Vector的使用</strong></h1>
<p>vector在实际中非常重要且使用，因此我们需要熟悉使用常用的接口，以下将从常用的接口入手并进行模拟实现</p>
<p>vector模拟实现的基本结构：</p>
<pre><code class="language-cpp">template&lt;class T&gt;
class vector
{
public:
		typedef T* iterator;
		typedef const T* const_iterator;
	    
        //无参构造
        vector()
			:_start(nullptr)
			, _finish(nullptr)
			, _endofstoage(nullptr)
		{}

		//资源管理
		~vector()
		{
			if (_start)
			{
				delete[] _start;
				_start = _finish = _endofstoage = nullptr;
			}
		}


        size_t size() const
		{
			return _finish - _start;
		}


		size_t capacity() const
		{
			return _endofstoage - _start;
		}	
private:
		iterator _start;
		iterator _finish;
		iterator _endofstoage;
};</code></pre>
<h2 id="2.1%20vector%E7%9A%84%E5%AE%9A%E4%B9%89">2.1 vector的定义</h2>
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>构造函数声明<a href="https://cplusplus.com/reference/vector/vector/vector/" title="constructor">constructor</a></td><td>接口说明</td></tr><tr><td>
<div>
<span style="color:#777777;">vector()</span>
<span style="color:#777777;">（重点）</span>
</div> </td><td>
<div>
<span style="color:#777777;">无参构造</span>
</div> </td></tr><tr><td>
<div>
<span style="color:#777777;">vector (const vector&amp; x); </span>
<span style="color:#777777;">（重点） </span>
</div> </td><td>
<div>
<span style="color:#777777;">拷贝构造</span>
</div> </td></tr><tr><td>
<div>
<span style="color:#777777;">vector</span>
<span style="color:#777777;">（</span>
<span style="color:#777777;">size_type n, const value_type&amp; val = value_type()</span>
<span style="color:#777777;">）</span>
</div> </td><td>
<div>
<span style="color:#777777;">构造并初始化</span>
<span style="color:#777777;">n</span>
<span style="color:#777777;">个</span>
<span style="color:#777777;">val </span>
</div> </td></tr><tr><td>
<div>
<span style="color:#777777;">vector (InputIterator first, InputIterator last); </span>
</div> </td><td>
<div>
<span style="color:#777777;">使用迭代器进行初始化构造</span>
</div> </td></tr></tbody></table>
<pre><code class="language-cpp">//无参构造
vector()
	:_start(nullptr)
	, _finish(nullptr)
	, _endofstoage(nullptr)
{}

//拷贝构造
void swap(vector&lt;T&gt;&amp; v)
{
	std::swap(_start, v._start);
	std::swap(_finish, v._finish);
	std::swap(_endofstoage, v._endofstoage);
}

//vector(const vector&amp; v)
vector(const vector&lt;T&gt;&amp; v)
	:_start(nullptr)
	, _finish(nullptr)
	, _endofstoage(nullptr)
{
	vector tmp(v.begin(), v.end());
	swap(tmp);
}

//初始化n个val 
vector(size_t n, const T&amp; val = T())
	:_start(nullptr)
	, _finish(nullptr)
	, _endofstoage(nullptr)
{
	reserve(n);
	for (size_t i = 0; i &lt; n; ++i)
	{
		push_back(val);
	}
}

//使用迭代化区间初始化
template &lt;class InputIterator&gt;
vector(InputIterator first, InputIterator last)
	:_start(nullptr)
	, _finish(nullptr)
	, _endofstoage(nullptr)
{
	while (first != last)
	{
		push_back(*first);
		++first;
	}
}</code></pre>
<h2 id="2.2%20vector%20%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8%C2%A0">2.2 vector 迭代器的使用 </h2>
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>iterator的使用</td><td>接口说明</td></tr><tr><td>begin+end （重点）</td><td>
<div>
<span style="color:#777777;">获取第一个数据位置的</span>
<span style="color:#777777;">iterator/const_iterator</span>
<span style="color:#777777;">， 获取最后一个数据的下一个位置 </span>
</div>
<div>
<span style="color:#777777;">的</span>
<span style="color:#777777;">iterator/const_iterator</span>
</div> </td></tr><tr><td>rbegin+rend（反向迭代器）</td><td>
<div>
<span style="color:#777777;">获取最后一个数据位置的</span>
<span style="color:#777777;">reverse_iterator</span>
<span style="color:#777777;">，获取第一个数据前一个位置的 </span>
</div>
<div>
<span style="color:#777777;">reverse_iterator </span>
</div> </td></tr></tbody></table>
<p></p>
<pre><code class="language-cpp">iterator begin()
{
	return _start;
}
iterator end()
{
	return _finish;
}

const iterator begin() const
{
	return _start;
}
const iterator end() const
{
	return _finish;
}</code></pre>
<h2 id="2.3%20vector%E7%9A%84%E7%A9%BA%E9%97%B4%E5%A2%9E%E9%95%BF%E9%97%AE%E9%A2%98">2.3 vector的空间增长问题</h2>
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>容量空间</td><td>接口说明</td></tr><tr><td>size</td><td>
<div>
<span style="color:#777777;">获取数据个数</span>
</div> </td></tr><tr><td>capacity</td><td>
<div>
<span style="color:#777777;">获取容量大小</span>
</div> </td></tr><tr><td>empty</td><td>
<div>
<span style="color:#777777;">判断是否为空</span>
</div> </td></tr><tr><td>resize（重点）</td><td>
<div>
<span style="color:#777777;">改变</span>
<span style="color:#777777;">vector</span>
<span style="color:#777777;">的</span>
<span style="color:#777777;">size</span>
</div> </td></tr><tr><td>reserve（重点）</td><td>
<div>
<span style="color:#777777;">改变</span>
<span style="color:#777777;">vector</span>
<span style="color:#777777;">的</span>
<span style="color:#777777;">capacity </span>
</div> </td></tr></tbody></table>
<pre><code class="language-cpp">void resize(size_t n, T val = T())
{
	if (n &gt; capacity())
	{

		reserve(n);
	}
	if (n &gt; size())
	{
		while (_finish &lt; _start + n)
		{
			*_finish = val;
			++_finish;
		}
	}
	else
	{
		_finish = _start + n;
	}
}
</code></pre>
<pre><code class="language-cpp">void reserve(size_t n)
{
	size_t sz = size();
	if (n &gt; capacity())
	{
		T* tmp = new T[n];
		if (_start)
		{
			//这里会造成浅拷贝问题
			//memcpy(tmp, _start, size() * sizeof(T));
			for (size_t i = 0; i &lt; size(); ++i)
			{
				tmp[i] = _start[i];
			}

			delete[] _start; 
		}
		_start = tmp;
	}
	_finish = _start + sz;
	_endofstoage = _start + n;

}</code></pre>
<p><span style="color:#fe2c24;"><strong>注意：</strong></span></p>
<p>1、我们在扩容的时候有一个小细节，capacity的容量扩容在vs和g++下分别运行是有区别的，在Vs下caoacity的扩容是按1.5倍增长的；在g++下是按2倍增长的。不能固化的认为，vector的增长都是2倍，具体增长的多少要根据需求定义。Vs是PJ盘本的STL，g++是SGI版本的STL。</p>
<pre><code class="language-cpp">//vs下
int main()
{
	vector&lt;int&gt; v;
	size_t sz = v.capacity();
	for (int i = 0; i &lt; 100; ++i)
	{
		v.push_back(i);
		if (sz != v.capacity())
		{
			sz = v.capacity();
			cout &lt;&lt; "capacity changed: " &lt;&lt; sz &lt;&lt; '\n';
		}
	}

	return 0;
}</code></pre>
<p><img alt="" height="417" src="image\98a6375403834e6aaf65e43fa28ea967.png" width="786"/></p>
<p><img alt="" height="806" src="image\a143e4b894c84523bbbf6e7532430eb1.png" width="641"/></p>
<p></p>
<h1 id="3.%20vector%E7%9A%84%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9">3. vector的增删查改</h1>
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>
<div>
<span style="color:#777777;"><strong>vector</strong></span>
<span style="color:#777777;"><strong>增删查改 </strong></span>
</div> </td><td>
<div>
<span style="color:#777777;"><strong>接口说明 </strong></span>
</div> </td></tr><tr><td>
<div>
<span style="color:#4183c4;"><strong><a class="link-info" href="http://www.cplusplus.com/reference/vector/vector/push_back/" title="push_back">push_back</a></strong></span>
<span style="color:#777777;">（重点）</span>
</div> </td><td>尾插</td></tr><tr><td>
<div>
<span style="color:#4183c4;"><strong><a class="link-info" href="http://www.cplusplus.com/reference/vector/vector/pop_back/" title="pop_back">pop_back</a></strong></span>
<span style="color:#777777;">（重点）</span>
</div> </td><td>
<div>
<span style="color:#777777;">尾删</span>
</div> </td></tr><tr><td>
<div>
<span style="color:#4183c4;"><strong><a class="link-info" href="https://cplusplus.com/reference/algorithm/find/?kw=find" title="find">find</a> </strong></span>
</div> </td><td>
<div>
<span style="color:#777777;">查找。（注意这个是算法模块实现，不是</span>
<span style="color:#777777;">vector</span>
<span style="color:#777777;">的成员接口）</span>
</div> </td></tr><tr><td>
<div>
<span style="color:#4183c4;"><strong><a class="link-info" href="https://cplusplus.com/reference/vector/vector/insert/" title="insert">insert</a></strong></span>
</div> </td><td>
<div>
<span style="color:#777777;">在</span>
<span style="color:#777777;">pos</span>
<span style="color:#777777;">之前插入</span>
<span style="color:#777777;">val </span>
</div> </td></tr><tr><td>
<div>
<span style="color:#4183c4;"><strong><a class="link-info" href="https://cplusplus.com/reference/vector/vector/erase/" title="erase">erase</a></strong></span>
</div> </td><td>
<div>
<span style="color:#777777;">删除</span>
<span style="color:#777777;">pos</span>
<span style="color:#777777;">位置的数据 </span>
</div> </td></tr><tr><td>
<div>
<span style="color:#4183c4;"><strong><a class="link-info" href="https://cplusplus.com/reference/vector/vector/swap/" title="swap">swap</a></strong></span>
</div> </td><td>
<div>
<span style="color:#777777;">交换两个</span>
<span style="color:#777777;">vector</span>
<span style="color:#777777;">的数据空间 </span>
</div> </td></tr><tr><td>
<div>
<span style="color:#4183c4;"><strong><a class="link-info" href="https://cplusplus.com/reference/vector/vector/operator%5B%5D/" title="operator[]">operator[]</a></strong></span>
<span style="color:#777777;">（重点）</span>
</div> </td><td>
<div>
<span style="color:#777777;">像数组一样访问</span>
</div> </td></tr></tbody></table>
<h2 id="3.1%20push_back%20%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89">3.1 push_back （重点）</h2>
<pre><code class="language-cpp">		void push_back(const T&amp; x)
		{
			if (_finish == _endofstoage)
			{
				size_t newCapacity = capacity() == 0 ? 4 : capacity() * 2;
				reserve(newCapacity);
			}
			*_finish = x;
			++_finish;

			//insert(end(), x);
		}</code></pre>
<p> 方法：</p>
<p>1、实现要考虑是否需要扩容，如果 _finish == _endofstoage 则需要扩容</p>
<p>2、尾插元素， ++_finish</p>
<h2 id="3.2%20pop_back%20(%E9%87%8D%E7%82%B9)">3.2 pop_back (重点)</h2>
<p>pop_back比较简单，尾删的逻辑不是删除而是覆盖，因此只需要--_finish即可</p>
<pre><code class="language-cpp">		void pop_back()
		{
			if (_finish &gt; _start)
			{
				--_finish;
			}
			//erase(end() - 1);
		}</code></pre>
<h2 id="3.3%20insert">3.3 insert</h2>
<p>insert插入是在pos位置之前插入x</p>
<p>方法：</p>
<p>1、判断pos位置的合法性。</p>
<p>2、判断是否需要扩容，如果需要扩容则注意，这里会引发<span style="color:#fe2c24;">迭代器失效问题。</span></p>
<blockquote>
<p>由于迭代器失效问题比较复杂，情况多样，我总结了一篇单独的博客供大家参考：</p>
<p><a href="https://blog.csdn.net/qq_58325487/article/details/126595973" title="[ C++ ] STL_vector -- 迭代器失效问题">[ C++ ] STL_vector -- 迭代器失效问题</a> </p>
</blockquote>
<p>3、 挪动数据，由后往前走，让前一个覆盖后一个。</p>
<p>4、插入数据，++_finish， 返回pos位置</p>
<pre><code class="language-cpp">		iterator insert(iterator pos, const T&amp; x)
		{
			//检查
			assert(pos &gt;= _start &amp;&amp; pos &lt;= _finish);
			//空间不够  扩容
			//扩容以后 pos就失效了
			if (_finish == _endofstoage)
			{
				//使用相对距离来计算确定pos位置
				size_t n = pos - _start;
				size_t newCapacity = capacity() == 0 ? 4 : capacity() * 2;
				reserve(newCapacity);
				pos = _start + n;
			}

			//挪动数据
			iterator end = _finish - 1;
			while (end &gt;= pos)
			{
				*(end + 1) = *end;
				--end;
			}
			*pos = x;
			++_finish;

			return pos;
		}</code></pre>
<h2 id="3.4%20erase">3.4 erase</h2>
<p><span style="color:#777777;">erase是删除</span><span style="color:#777777;">pos</span><span style="color:#777777;">位置的数据</span></p>
<p><span style="color:#777777;">方法：</span></p>
<p><span style="color:#777777;">1、判断pos位置的合法性。</span></p>
<p><span style="color:#777777;">2.、拿到pos位置下一个位置的迭代器，从前往后，后一个覆盖前一个。</span></p>
<p><span style="color:#777777;">3、最后--_finish，返回pos位置</span></p>
<pre><code class="language-cpp">        iterator erase(iterator pos)
		{
			assert(pos &gt;= _start &amp;&amp; pos &lt;= _finish);
			iterator it = pos + 1;
			while (it != _finish)
			{
				*(it - 1) = *it;
				++it;
			}
			--_finish;

			return pos;
		}</code></pre>
<h2 id="3.5%20operator%20%5B%20%5D%C2%A0">3.5 operator [ ] </h2>
<p>重载的operator [ ] 就是取到pos位置对应的数据即可，比较简单</p>
<pre><code class="language-cpp">		T&amp; operator[](size_t pos)
		{
			assert(pos &lt; size());
			return _start[pos];
		}

		const T&amp; operator[](size_t pos) const
		{
			assert(pos &lt; size());
			return _start[pos];
		}</code></pre>
<p></p>
<p> (本篇完)</p>
</div>
</div>