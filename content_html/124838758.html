<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="markdown_views prism-atom-one-dark" id="content_views">
<svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
<path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
</svg>
<p>1.题目名称：批阅奏章<br/> 某朝皇帝有大臣n名（1&lt;=n&lt;=1000），分别编号大臣1~n。某日皇帝身体抱恙，奏章堆积如山无法及时一一批阅，便命身旁內侍帮他把奏章按指定顺序排序后再阅。于是皇帝亲自挑选了几个值得信赖的重臣并排好序，要求把他们的奏章按排好的顺序放到前面，其他的按照编号升序排列即可。现在要求你写一个程序来帮皇上解决这个问题，即已知奏章总数和顺序、钦点重臣的排列顺序，求得皇帝查阅奏章的顺序。<br/> 输入描述：<br/> 第一行输入两个整数p（1&lt;=p&lt;=5000）和q，其中p表示堆积奏章的总数、q表示皇帝钦点重臣数<br/> 第二行输入p个数，表示所有按呈递顺序递上来的奏章来自于哪个大臣（大臣编号）<br/> 第三行输入q个数，表示皇帝钦点并排好序的重臣编号<br/> 输出描述：<br/> 输出奏章按指定顺序排好序后，皇帝按大臣编号批阅的顺序<br/> 输入样例：<br/> 5 3<br/> 5 4 3 2 1<br/> 3 5 4<br/> 输出样例：<br/> 3 5 4 1 2<br/> 答案：</p>
<pre><code>line1 = list(map(int,input('ddd').split()))
p = line1[0]
q = line1[1]
article_author = list(map(int,input('ddd').split()))
persons = list(map(int,input('ddd').split()))
result =[]
article_author.sort()
for p1 in persons:
    for a1 in range(0,len(article_author)):
        if article_author[a1] == p1:
            result.append(p1)
            article_author[a1] = 0
for a1 in article_author:
    if a1!=0:
        result.append(a1)
print_text = list(map(str,result))
print(" ".join(print_text))
</code></pre>
<p>2.题目名称：报价<br/> 时间限制：1000ms内存限制：256M<br/> 题目描述<br/> 给定某股票每日的报价和一个目标值，请在所有报价中找出和为目标值的那两天的报价，并打印出对应的报价。<br/> 假设每种输入只会对应一个答案，且每日的报价不会重复。<br/> 你需要按报价从小到大的顺序打印答案。</p>
<p>输入描述：<br/> 输入：第一行是某股票每日的报价，这些报价是正整数且用空格相隔，例如：17 20 33<br/> 第二行是目标值，例如：37<br/> 输出描述：<br/> 输出：对应的报价，报价之间用空格相隔，例如：17 20<br/> 示例<br/> 示例1<br/> 输入<br/> 17 20 33<br/> 37<br/> 复制<br/> 输出<br/> 17 20<br/> 复制<br/> 答案：</p>
<pre><code>list1=list(map(int,input().split()))
goal=int(input())
list1.sort()
for i in list1:
    if (goal-i) in list1:
        print(str(i)+" "+str(goal-i))
        break
</code></pre>
<p>3.题目名称：水仙花数<br/> 时间限制：1000ms内存限制：256M<br/> 题目描述<br/> 如果一个 3 位数等于其各位数字的立方和，则称这个数为水仙花数。<br/> 例如：153 = 1^3 + 5^3 + 3^3，因此 153 就是一个水仙花数<br/> 输入描述：<br/> 输入一个整数a与一个整数b, 用空格分隔<br/> 输出描述：<br/> 输出a到b区间内的水仙花数<br/> 示例<br/> 示例1<br/> 输入<br/> 100 170<br/> 复制<br/> 输出<br/> 153<br/> 复制<br/> 答案：</p>
<pre><code>a,b = map(int,input().split())
for n in range(a,b+1):
    x = int(str(n)[0])
    y = int(str(n)[1])
    z = int(str(n)[2])
    if n == x**3 + y**3 + z**3:
        print(n)
</code></pre>
<p>4.题目名称：字符串查找和比较(pass)<br/> 时间限制：1000ms内存限制：256M<br/> 题目描述<br/> 写函数实现如下功能，给定字符串A和B,输出A和B中的最长公共子串。比如A=“aocdfe” B=“pmcdfa” 则输出"cdf"。<br/> 输入描述：<br/> 输入待处理的两个字符串 str1，str2<br/> 输出描述：<br/> 找出两个字符串最长的公共子串<br/> 示例 示例1<br/> 输入<br/> aocdfe<br/> pmcdfa<br/> 输出<br/> Cdf<br/> 答案：</p>
<pre><code>A = str(input(""))
B = str(input(""))
if len(A)&gt;len(B):
    A,B = B,A
out_put=[]
for i in range(len(A),0,-1):
    for j in range(0,len(A)-i+1):
        if A[j:j+i] in B:
            print(A[j:j+i])
            out_put.append(A[j:j+i])
    if out_put:
        break
</code></pre>
<p>5.题目名称：尼姆博弈<br/> 时间限制：1000ms内存限制：256M<br/> 题目描述<br/> 你和你的朋友，两个人一起玩 Nim 游戏：<br/> 桌子上有一堆石头。<br/> 你们轮流进行自己的回合，你作为先手。<br/> 每一回合，轮到的人拿掉 1 - 3 块石头。<br/> 拿掉最后一块石头的人就是获胜者。<br/> 假设你们每一步都是最优解。请编写一个函数，来判断你是否可以在给定石头数量为 n 的情况下赢得游戏。如果可以赢，返回 true；否则，返回 false 。<br/> 输入描述：<br/> 整数n<br/> 输出描述：<br/> true或false<br/> 示例<br/> 示例1<br/> 输入<br/> 4<br/> 复制<br/> 输出<br/> False<br/> 答案：</p>
<pre><code>num = int(input())
if num % 4 == 0:
    print("false")
else:
    print("true")

</code></pre>
<p>6.题目名称：罗马数字转整数(pass)<br/> 时间限制：1000ms内存限制：256M<br/> 题目描述<br/> 罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p>
<p>例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。<br/> 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>
<p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br/> X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br/> C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br/> 给定一个罗马数字，将其转换成整数。<br/> 输入描述：<br/> 罗马数字<br/> 输出描述：<br/> 转换后的整数<br/> 示例<br/> 示例1<br/> 输入 III<br/> 输出 3<br/> 答案：</p>
<pre><code>src = input()
n_value = {"Z":0,"I":1,"V":5,"X":10,"L":50,"C":100,"D":500,"M":1000}
pre_value = {"I":"Z","V":"I","X":"I","L":"X","C":"X","D":"C","M":"C"}
result = 0
last_char = ""
for _c in src:
    result+= n_value[_c]
    if last_char == pre_value[_c]:
        result-= n_value[last_char] * 2
    last_char = _c
print(result)

</code></pre>
<p>7.题目名称：员工排序<br/> 时间限制：1000ms内存限制：256M<br/> 题目描述<br/> 某公司要针对员工情况统一调薪，现有一个员工列表，包含姓名、职级、工作年限、工资信息。现要求将该列表按以下规则重新排序：</p>
<p>1、职级高的排在前面</p>
<p>2、若职级相同，按工资少的排前面</p>
<p>3、若工资相同，工作年限长的排前面</p>
<p>输入描述：<br/> 第一行输入一个整数n，表示员工列表中员工的人数</p>
<p>接下来的n行，分别输入员工的姓名、职级、工作年限和工资信息，各项信息用空格分隔</p>
<p>输出描述：<br/> 输出按要求重新排列的员工列表，每名员工信息（姓名、职级、工作年限和工资）占一行</p>
<p>示例<br/> 示例1<br/> 输入<br/> 6<br/> 张三 3 3 3000<br/> 李四 3 4 3000<br/> 王五 3 3 4000<br/> 赵六 4 3 3000<br/> 陆奇 4 4 4000<br/> 闫八 4 4 3980.99<br/> 复制<br/> 输出<br/> 赵六 4 3 3000.00<br/> 闫八 4 4 3980.99<br/> 陆奇 4 4 4000.00<br/> 李四 3 4 3000.00<br/> 张三 3 3 3000.00<br/> 王五 3 3 4000.00<br/> 答案：</p>
<pre><code>num = int(input())
employees = []
for _i in range(0,num):
    employees.append(input().split())
src_data = list(map(lambda x:[x[0],int(x[1]),int(x[2]),float(x[3])],employees))
src_data.sort(key=lambda x: -1000000000000*x[1] + 10000*x[3] - x[2])
for _i in src_data:
    print("%s %d %d %0.2f" % (_i[0],_i[1],_i[2],_i[3]))
</code></pre>
<p>8.题目名称：汉诺塔<br/> 时间限制：1000ms内存限制：256M<br/> 题目描述<br/> 有三个立柱A、B、C。A柱上穿有大小不等的圆盘N个，较大的圆盘在下，较小的圆盘在上。要求把A柱上的圆盘全部移到C柱上，保持大盘在下、小盘在上的规律（可借助B柱）。每次移动只能把一个柱子最上面的圆盘移到另一个柱子的最上面。请输出移动过程。</p>
<p>输入描述：<br/> 输入一个整数n</p>
<p>输出描述：<br/> 输出移动过程</p>
<p>示例<br/> 示例1<br/> 输入<br/> 3<br/> 复制<br/> 输出<br/> a-&gt;c<br/> a-&gt;b<br/> c-&gt;b<br/> a-&gt;c<br/> b-&gt;a<br/> b-&gt;c<br/> a-&gt;c<br/> 复制</p>
<pre><code>def han_nuo(n,src,tmp,dest):
    if n &lt;= 0:
        return
    if n == 1:
        print(src + "-&gt;" + dest)
        return
    han_nuo(n-1,src,dest,tmp)
    print(src + "-&gt;" + dest)
    han_nuo(n-1,tmp,src,dest)
    
num = int(input())
han_nuo(num,"a","b","c")
</code></pre>
<p>9.题目名称：交换数值<br/> 时间限制：1000ms内存限制：256M<br/> 题目描述<br/> 将整数a、b的值进行交换，并且不使用任何中间变量。<br/> 输入描述：<br/> 输入待处理的两个整数 a 和b<br/> 输出描述：<br/> a 和b 的值交换<br/> 示例<br/> 示例1<br/> 输入<br/> a=100<br/> b=200<br/> 复制<br/> 输出<br/> a=200<br/> b=100<br/> 复制<br/> 答案</p>
<pre><code>a = int(input().split('=')[1])
b = int(input().split('=')[1])
a,b = b,a
print("a=%d"%a)
print("b=%d"%b)
</code></pre>
<p>10.题目名称：进程排序(pass)<br/> 某系统中有n个进程，每个进程都有自己唯一的进程id（PID），同时每个进程最多还有一个父进程，父进程id为（PPID），和一个或多个子进程。<br/> 若某进程没有父进程，则PPID为0。 当某一进程被终止时，其子进程也将被终止。<br/> 现给出进程id列表和起对应的父进程id列表，当要终止某一进程时，计算最终会终止哪些进程，并将要终止的PID按升序排列。<br/> 输入描述：<br/> 第一行输入两个整数n和k，n表示当前系统中运行的进程数；k表示要终止进程的PID<br/> 第二行输入n个正整数，表示进程列表，每个整数表示进程的PID<br/> 第三行输入n个正整数，表示进程列表中的进程对应的父进程PPID列表。<br/> 输出描述：<br/> 输出当进程k终止时，所有会被终止的进程PID，并按PID升序排列，每个PID用空格分隔。<br/> 输入样例：<br/> 4 5<br/> 1 3 10 5<br/> 3 0 5 3<br/> 输出样例：5 10<br/> 答案：</p>
<pre><code>import copy
n,k=map(int,input().split(' '))
pids=list(map(int,input().split(' ')))
ppids=list(map(int,input().split(' ')))
t=[k]
A=[k]
while len(set(t)&amp;set(ppids))&gt;0:
    zk=[]
    for x in t:
        for i in range(len(ppids)):
            if ppids[i]==x:
                zk.append(pids[i])
                A.append(pids[i])
    t=copy.deepcopy(zk)
A.sort()
li=[str(x) for x in A]
print(' '.join(li))

</code></pre>
<p>11.题目名称：丑数<br/> 时间限制：1000ms内存限制：256M<br/> 题目描述<br/> 给你一个整数 n ，请你判断 n 是否为 丑数 。如果是，返回 true ；否则，返回 false 。<br/> 丑数 就是只包含质因数 2、3 和/或 5 的正整数。(1通常被视为丑数)<br/> 输入描述：<br/> 整数n<br/> 输出描述：true或false<br/> 示例 示例1<br/> 输入6<br/> 输出true<br/> 答案：</p>
<pre><code>m=int(input())
def cnum(n):
    while True:
        if n &lt;= 0:
            return False
        elif n==1 or n==2 or n==3 or n==5:
            return True
        elif n % 2 ==0:
            n = n/2
        elif n % 3 ==0:
            n = n/3
        elif n % 5 ==0:
            n = n/5
        else:
            return False
f=cnum(m)
if f == True:
    print("true")
else:
    print("false")

</code></pre>
<p>12、 克拉兹猜想：任取一正整数，如果是偶数，将其除以2。如果是奇数，将其乘以3再加1，然后重复这个过程，最后结果都会陷入4 2 1 的循环。<br/> 比如序列：13, 40, 20, 10, 5, 16, 8, 4, 2, 1, 4, 2, 1<br/> 请通过编程实现，当4,2,1重复第二次的时候，结束循环。请输出以下3个序列：<br/> [13, 40, 20, 10, 5, 16, 8, 4, 2, 1, 4, 2, 1]<br/> [31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1, 4, 2, 1]<br/> [101, 304, 152, 76, 38, 19, 58, 29, 88, 44, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1, 4, 2, 1]</p>
<pre><code>def collatz(number):
    res=number%2
    if res==0:
        return number//2
    else:
        return number*3+1

num=13
in_list=[13,31,101]
for  num in in_list:
    jg_list = [num]
    while True:
        num=collatz(num)
        jg_list.append(num)
        if jg_list.count(1)==2:
            break
    print(jg_list)
----------------------------------------------------------
</code></pre>
<p>如果输入的数 是 1 2 就不适用上面的程序 必须改用下面</p>
<pre><code>num= int(input())
arr = input()

in_list = [int(n) for n in arr.split()]
def collatz(number):
    res=number%2
    if res==0:
        return number//2
    else:
        return number*3+1

for  num in in_list:
    jg_list = [num]
    while True:
        num=collatz(num)
        jg_list.append(num)
        if jg_list[-6:]==[4,2,1,4,2,1]:
            break
    print(jg_list)
</code></pre>
<p>13、给定一组数，按照数组中出现的次数依次从大到小排序，出现次数一样的按照数组中的先后顺序输出<br/> 比如：<br/> 输入：1 1 1 1 3 3 3 4 5 2 6 6 6 6 6<br/> 输出：6 6 6 6 6 1 1 1 1 3 3 3 4 5 2¶</p>
<pre><code>n=map(int,input().split())
n=list(n)

jg_list=[]
for index,value in enumerate(n):
    j=n.count(value)
    jg=[value,index,j]
    jg_list.append(jg)

jg_list.sort(key=lambda x:x[1])
jg_list.sort(key=lambda x:x[2],reverse=True)


for x in jg_list:
    print(x[0],'',end='')
</code></pre>
<p>14、完数：一个数如果恰好等于它的因子之和，这个数就称为"完数"。例如6=1＋2＋3。编程找出10000以内的所有完数。</p>
<pre><code>jg=[]
for i in range(1,10000):
    sum1 = 0
    for j in range(1,int(i/2)+1):
        if i/j==int(i/j):
            sum1+=j
    if sum1==i:
        jg.append(i)
print(jg)
</code></pre>
<p>15、利用条件运算符的嵌套来完成此题：学习成绩&gt;=90分的同学用A表示，60-89分之间的用B表示，60分以下的用C表示</p>
<pre><code>def main():
    s = int(input('请输入成绩:'))
    if s&gt;=90:
        grade = 'A'
    elif s&gt;=60:
        grade = 'B'
    else:
        grade = 'C'
    print(grade)
main()
</code></pre>
<p>16、递归案例 求斐波那契列数列1，1，2，3，5，8，13 的第30位</p>
<pre><code>def f(n):
      return 1 if n==1 or n==2 else f(n-1)+f(n-2)

n=int(input())

ls=[]
for i in range(1,n+1):
    if i==1 or i==2:
       ls.append(1)
    else:
       ls.append(ls[i-2]+ls[i-3])
       
print(ls)
</code></pre>
<h2><a id="N_533"></a>求整数N的阶乘</h2>
<pre><code>n=int(input())
def f(n):
    if n==1:
        return(n)
    else:
        return(n*f(n-1))
        
print(f(1),f(2),f(3),f(4),f(5),f(6))
        
print(f(n))
</code></pre>
<p>#求整数N的阶乘</p>
<pre><code>def f(n):
    if n==1:
        return(n)
    else:
        return(n*f(n-1))
        
n=int(input())
ls=[]
for i in range(1,n+1):
     if i==1:
         ls.append(1)
     else:
         ls.append(f(i))
print(ls)   
     
print(f(1),f(2),f(3),f(4),f(5),f(6))
        
print(f(n))
</code></pre>
</div>
<link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css" rel="stylesheet"/>
<link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css" rel="stylesheet"/>
</div>