<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="markdown_views prism-atom-one-dark" id="content_views">
<svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
<path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
</svg>
<p></p>
<div class="toc">
<h3>2022年第十三届蓝桥杯省赛C/C++B组个人题解</h3>
<ul><li><a href="#_A__1">试题 A: 九进制转十进制（数学）</a></li><li><a href="#_B__14">试题 B: 顺子日期（语文）</a></li><li><a href="#_C__63">试题 C: 刷题统计（模拟）</a></li><li><ul><li><ul><li><a href="#_65">【样例输入】</a></li><li><a href="#_69">【样例输出】</a></li></ul>
</li></ul>
</li><li><a href="#_D__126">试题 D: 修剪灌木（找规律）</a></li><li><ul><li><a href="#_128">【样例输入】</a></li><li><a href="#_132">【样例输出】</a></li></ul>
</li><li><a href="#_E_X__226">试题 E: X 进制减法（数学）</a></li><li><ul><li><a href="#_228">【样例输入】</a></li><li><a href="#_236">【样例输出】</a></li></ul>
</li><li><a href="#_F____293">试题 F: 统计子矩阵（前缀和 + 双指针）</a></li><li><ul><li><a href="#_295">【样例输入】</a></li><li><a href="#_302">【样例输出】</a></li></ul>
</li><li><a href="#_G__398">试题 G: 积木画（动态规划）</a></li><li><ul><li><a href="#_400">【样例输入】</a></li><li><a href="#_404">【样例输出】</a></li></ul>
</li><li><a href="#_H_BFS_448">试题 H: 扫雷（BFS）</a></li><li><ul><li><a href="#_450">【样例输入】</a></li><li><a href="#_457">【样例输出】</a></li></ul>
</li><li><a href="#_I_DP___550">试题 I: 李白打酒加强版（三维DP / 回溯）</a></li><li><ul><li><a href="#_552">【样例输入】</a></li><li><a href="#_556">【样例输出】</a></li></ul>
</li><li><a href="#_J__649">试题 J: 砍竹子</a></li><li><ul><li><a href="#_651">【样例输入】</a></li><li><a href="#_656">【样例输出】</a></li></ul>
</li><li><a href="#_664">总结</a></li></ul>
</div>
<p></p>
<h1><a id="_A__1"></a>试题 A: 九进制转十进制（数学）</h1>
<p><img alt="A" src="https://img-blog.csdnimg.cn/0d6ee64a4ce64c3aba2ca067cb2f4262.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IOM6ZSF5YiH5Zu-5LuU,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center"/></p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cmath&gt; 
using namespace std;

int main() {
	cout &lt;&lt; 2 * pow(9, 0) + 2 * pow(9, 1) + 0 * pow(9, 2) + 2 * pow(9, 3) &lt;&lt; endl;
	return 0;
}
</code></pre>
<p>答案：1478</p>
<h1><a id="_B__14"></a>试题 B: 顺子日期（语文）</h1>
<p><img alt="B" src="https://img-blog.csdnimg.cn/c4f22219423b4478b39e77cc1a120f5f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IOM6ZSF5YiH5Zu-5LuU,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center"/><br/> 目前有很多争议，分为 3 种答案：4，5，14<br/> 我考试时写的答案是 5<br/> 不过我观察到网友更多的答案是 4<br/> 而比赛后当天晚上的蓝桥云课说的是 14（非官方）</p>
<p>我来总结一下：</p>
<p>第一种答案：5<br/> 看题，在说明 20220123时，说它出现了一个顺子：123。<br/> 所以可以认为是只有 123 这一个顺子，而 012 是不算顺子的。<br/> 然后在说明 20221023 时又涉及到了 210 这个逆着的顺子，但它说这不是一个顺子日期。因此认为这里更明确了 0 不可以被包括进去，而逆序的可以算是顺子。</p>
<pre><code>20220123
20220321
20221123
20221230
20221231
</code></pre>
<p>第二种答案：4<br/> 即认为 012 和逆序的顺子（如 210）都不算是顺子，因此把上面的 20220321 去掉</p>
<pre><code>20220123
20221123
20221230
20221231
</code></pre>
<p>第三种答案：14<br/> 题目说的顺子是：连续的三个数字，并不是三位数。所以 012 也算是顺子。再由第二个例子 20221023 得知：210 这种逆序的不算顺子。<br/> <strong>如果要算上 012，那么第二个例子就把 210 这种逆序的给否掉啦</strong></p>
<pre><code>20220120
20220121
20220122
20220123
20220124
20220125
20220126
20220127
20220128
20220129
20221012
20221123
20221230
20221231
</code></pre>
<p>我目前也不知道正确答案，只能等官方解释吧<br/> orz</p>
<h1><a id="_C__63"></a>试题 C: 刷题统计（模拟）</h1>
<p><img alt="C1" src="https://img-blog.csdnimg.cn/94861c26039e48c6a59d0cb9f0f930a6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IOM6ZSF5YiH5Zu-5LuU,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center"/></p>
<h3><a id="_65"></a>【样例输入】</h3>
<pre><code>10 20 99
</code></pre>
<h3><a id="_69"></a>【样例输出】</h3>
<pre><code>8
</code></pre>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/4b324abf484e4e118bdcc14e5521432a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IOM6ZSF5YiH5Zu-5LuU,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center"/></p>
<p>陷阱：注意 a, b, n 要用 long long 存<br/> 考试时写的代码：只考虑到了 n 要用 long long 存，竟然没用 long long 存 a, b，还没考虑到时间可能还会超限</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;

int main() {
	int cnt = 1;
	long long n;
	int a, b;
	cin &gt;&gt; a &gt;&gt; b &gt;&gt; n;
	long long sum = 0;
	while (sum &lt; n) {
		if (cnt % 7 == 0 || cnt % 7 == 6) {
			sum += b;
		}
		else {
			sum += a;
		}
		cnt++;
	}
	// 当超出时退出while循环，所以答案需要减一。
	cout &lt;&lt; cnt - 1 &lt;&lt; endl;
	return 0;
}
</code></pre>
<p>赛后优化代码：先取余再暴力</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;

int main() {
	long long a, b, n;
	cin &gt;&gt; a &gt;&gt; b &gt;&gt; n;
	int week = 5 * a + 2 * b;
	long long ans = n / week * 7;
	n %= week;
	int sum = 0;
	for (int i = 1; i &lt;= 7 &amp;&amp; sum &lt; n; i++) {
		if (i % 7 == 6 || i % 7 == 0) {
			sum += b;
		}
		else {
			sum += a;
		}
		ans++;
	}
	cout &lt;&lt; ans &lt;&lt; endl;
	return 0;
} 
</code></pre>
<h1><a id="_D__126"></a>试题 D: 修剪灌木（找规律）</h1>
<p><img alt="D1" src="https://img-blog.csdnimg.cn/63187f3649ed44dfa012b37223f6af0a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IOM6ZSF5YiH5Zu-5LuU,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center"/></p>
<h2><a id="_128"></a>【样例输入】</h2>
<pre><code>3
</code></pre>
<h2><a id="_132"></a>【样例输出】</h2>
<pre><code>4
2
4
</code></pre>
<p><img alt="D2" src="https://img-blog.csdnimg.cn/34d72c95588e4e6bac9d120f29b6fab2.png#pic_center"/><br/> 首先用暴力找规律，然后再根据规律简化代码</p>
<pre><code>// 暴力代码：来回走两次。注意回的时候要把两个边界去掉。

#include &lt;iostream&gt;
#include &lt;cstring&gt;
using namespace std;

const int maxn = 1e4 + 100;
int a[maxn];
int maxHeight[maxn];

int main() {
	int n;
	while (cin &gt;&gt; n) {
		memset(a, 0, sizeof(a));
		memset(maxHeight, 0, sizeof(maxHeight));
		
		// 来回走两次
		for (int today = 0; today &lt; n; today++) {
			for (int i = 0; i &lt; n; i++) {
				a[i]++;
				if (a[i] &gt; maxHeight[i]) {
					maxHeight[i] = a[i];
				}
				if (i == today) {
					a[i] = 0;
				}
			}
		}
		for (int today = n - 2; today &gt; 0; today--) {
			for (int i = 0; i &lt; n; i++) {
				a[i]++;
				if (a[i] &gt; maxHeight[i]) {
					maxHeight[i] = a[i];
				}
				if (i == today) {
					a[i] = 0;
				}
			}
		}
		for (int today = 0; today &lt; n; today++) {
			for (int i = 0; i &lt; n; i++) {
				a[i]++;
				if (a[i] &gt; maxHeight[i]) {
					maxHeight[i] = a[i];
				}
				if (i == today) {
					a[i] = 0;
				}
			}
		}
		for (int today = n - 2; today &gt; 0; today--) {
			for (int i = 0; i &lt; n; i++) {
				a[i]++;
				if (a[i] &gt; maxHeight[i]) {
					maxHeight[i] = a[i];
				}
				if (i == today) {
					a[i] = 0;
				}
			}
		}
		for (int i = 0; i &lt; n; i++) {
			cout &lt;&lt; maxHeight[i] &lt;&lt; " ";
		}
		cout &lt;&lt; endl &lt;&lt; endl;
	}
	return 0;
}
</code></pre>
<p>结果如下：<br/> <img alt="D2" src="https://img-blog.csdnimg.cn/0fb0527075c74992bf699c8c23a0d805.png#pic_center"/><br/> 通过找规律可以简化代码：</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;

int main() {
	int n;
	cin &gt;&gt; n;
	for (int i = 0; i &lt; n; i++) {
		cout &lt;&lt; max(i, n - i - 1) * 2 &lt;&lt; endl; 
	}
	return 0;
}
</code></pre>
<h1><a id="_E_X__226"></a>试题 E: X 进制减法（数学）</h1>
<p><img alt="E1" src="https://img-blog.csdnimg.cn/0bffd8430fbd4a8da9b9612bc7869f2a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IOM6ZSF5YiH5Zu-5LuU,size_17,color_FFFFFF,t_70,g_se,x_16#pic_center"/></p>
<h2><a id="_228"></a>【样例输入】</h2>
<pre><code>11
3
10 4 0
3
1 2 0
</code></pre>
<h2><a id="_236"></a>【样例输出】</h2>
<pre><code>94
</code></pre>
<p><img alt="E2" src="https://img-blog.csdnimg.cn/e13bd284fd3e46d69ca2de820fbedc51.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IOM6ZSF5YiH5Zu-5LuU,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center"/><br/> 比赛时看了一个小时，读不懂题 <strong>orz…</strong><br/> 这题十分的抽象，很难理解</p>
<p>这里先说明一下问题描述中的 321 是如何转换为 65 的<br/> 由题：个位是 2 进制，十位是 10 进制，百位是 8 进制。<br/> 题目第一行就说了：进制规定了数字在数位上逢几进一。意思是：<strong>个位每数 2 个，十位进 1，十位每数 10 个，百位进 1。</strong><br/> 首先定义结果 sum = 0<br/> ① 看个位：个位为 1，那么只需数一次即可到 1，然后让结果加上 1，即 <strong>sum += 1</strong><br/> ② 看十位：十位为 2，因为个位是二进制，所以十位要到 2 的话，就需要经过这样的变换：00 -&gt; 01 -&gt; 10 -&gt; 11 -&gt; 20。可以看出：十位每加 1，个位就需要变换 2 次，所以要使十位变成 2，则一共<strong>需要变换 2（十位的值） * 2（个位的进制） 次</strong>。然后让结果再加上它，即 <strong>sum += 2 * 2</strong><br/> ③ 看百位：百位为 3，根据十位的分析，同理得：要使百位变成 3，则<strong>需要变换 3（百位的值） * 10（十位的进制） * 2（个位的进制）次</strong>。然后让结果再加上它，即 <strong>sum += 3 * 10 * 2</strong><br/> 综上：321 转换为了 <strong>sum = 1 + 2 * 2 + 3 * 10 * 2 = 65</strong></p>
<p>公式：<br/> A = ( a[n - 1] * X[n - 2] * X[n - 3] * … * X[0] ) + ( a[n - 2] * X[n - 3] * X[n - 4] * … * X[0] ) + … + a[0]<br/> B = ( b[n - 1] * X[n - 2] * X[n - 3] * … * X[0] ) + ( b[n - 2] * X[n - 3] * X[n - 4] * … * X[0] ) + … + b[0]<br/> A - B = (( a[n - 1] - b[n - 1] ) * X[n - 2] * X[n - 3] * … * X[0] ) + (( a[n - 2] - b[n - 2] ) * X[n - 3] * X[n - 4] * … * X[0] ) + ( a[0] - b[0] )<br/> 优化：（秦九韶算法）<br/> 设 d[n - 1] = a[n - 1] - b[n - 1]<br/> A - B = ((( d[n - 1] * X[n - 2] + d[n - 2] ) * X[n - 3] + d[n - 3] ) * X[n - 4] + … d[0] ) …</p>
<p>代码：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

const int MOD = 1e9 + 7;
const int maxn = 1e5 + 100;
int a[maxn];
int b[maxn];

int main() {
	int n, m1, m2, m;
	scanf("%d", &amp;n);
	scanf("%d", &amp;m1);
	// 逆序来存，确保让个位对齐，多余位置的值都是 0 
	for (int i = m1 - 1; i &gt;= 0; i--) {
		scanf("%d", &amp;a[i]);
	}
	scanf("%d", &amp;m2);
	for (int i = m2 - 1; i &gt;= 0; i--) {
		scanf("%d", &amp;b[i]);
	}
	m = max(m1, m2);
	int res = 0;
	for (int i = m - 1; i &gt;= 0; i--) {
		res = (res * max({ 2, a[i] + 1, b[i] + 1 }) % MOD + a[i] - b[i]) % MOD;
	}
	printf("%d\n", res);
	return 0;
}
</code></pre>
<h1><a id="_F____293"></a>试题 F: 统计子矩阵（前缀和 + 双指针）</h1>
<p><img alt="F1" src="https://img-blog.csdnimg.cn/76881b800090400cad58f9dec3079fa1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IOM6ZSF5YiH5Zu-5LuU,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center"/></p>
<h2><a id="_295"></a>【样例输入】</h2>
<pre><code>3 4 10
1 2 3 4
5 6 7 8
9 10 11 12
</code></pre>
<h2><a id="_302"></a>【样例输出】</h2>
<pre><code>19
</code></pre>
<p><img alt="F2" src="https://img-blog.csdnimg.cn/7cfed83172034c519ca96613be641f5d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IOM6ZSF5YiH5Zu-5LuU,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center"/><br/> <img alt="F3" src="https://img-blog.csdnimg.cn/d9290607a3da4fca86c8c74949ea4409.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IOM6ZSF5YiH5Zu-5LuU,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center"/><br/> <s>注意 k 已经超了 int 范围（虽然我到不了那就已经超时了，但还是要注意的）</s> 看错了看错了，k 的值是 2.5 * 10 ^ 8，而 int 的范围是 -21 4748 3648 ～ 21 4748 3647 (21 * 10 ^ 8)</p>
<p>方法①：前缀和 + 双指针<br/> 首先求出每一列的前缀和，然后利用双指针将若干行切割开</p>
<table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table>
<p><img alt="F4" src="https://img-blog.csdnimg.cn/773a353886b8452ca6f380c259a88884.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IOM6ZSF5YiH5Zu-5LuU,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center"/><br/> <img alt="F5" src="https://img-blog.csdnimg.cn/d036f04957294a66bd699aceffdff1d3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IOM6ZSF5YiH5Zu-5LuU,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center"/></p>
<pre><code>#include &lt;iostream&gt;
using namespace std;

const int maxn = 505;
int s[maxn][maxn];

int main() {
	memset(s, 0, sizeof(s));
	int n, m, k;
	scanf("%d %d %d", &amp;n, &amp;m, &amp;k);
	for (int i = 1; i &lt;= n; i++) {
		for (int j = 1; j &lt;= m; j++) {
			scanf("%d", &amp;s[i][j]);
			s[i][j] += s[i - 1][j];
		}
	}
	int res = 0;
	// 上下边界
	for (int up = 1; up &lt;= n; up++) {
		for (int down = up; down &lt;= n; down++) {
			int sum = 0;
			// 左右边界
			for (int left = 1, right = 1; right &lt;= m; right++) {
				sum += s[down][right] - s[up - 1][right];
				while (sum &gt; k) {
					sum -= s[down][left] - s[up - 1][left];
					left++;
				}
				res += right - left + 1;
			}
		}
	}
	printf("%d\n", res);
	return 0;
}
</code></pre>
<p>方法②：暴力（过30%数据，比赛时不会做直接暴力 6 个 for！随便看看就好啦）</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;

int mat[550][550];

int main() {
	int n, m;
	long long k;
	cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;
	for (int i = 1; i &lt;= n; i++) {
		for (int j = 1; j &lt;= m; j++) {
			cin &gt;&gt; mat[i][j];
		}
	}
	long long sum = 0;
	long long cnt = 0;
	for (int h1 = 1; h1 &lt;= n; h1++) {
		for (int h2 = h1; h2 &lt;= n; h2++) {
			for (int l1 = 1; l1 &lt;= m; l1++) {
				for (int l2 = l1; l2 &lt;= m; l2++) {
					sum = 0;
					for (int h = h1; h &lt;= h2; h++) {
						for (int l = l1; l &lt;= l2; l++) {
							sum += mat[h][l];
						}
					}
					if (sum &lt;= k) {
						cnt++;
					}
				}
			}
		}
	}
	cout &lt;&lt; cnt &lt;&lt; endl;
	return 0;
}
</code></pre>
<h1><a id="_G__398"></a>试题 G: 积木画（动态规划）</h1>
<p><img alt="G1" src="https://img-blog.csdnimg.cn/1e03fe04814e40fdbfdb5ceca90703b8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IOM6ZSF5YiH5Zu-5LuU,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center"/></p>
<h2><a id="_400"></a>【样例输入】</h2>
<pre><code>3
</code></pre>
<h2><a id="_404"></a>【样例输出】</h2>
<pre><code>5
</code></pre>
<p><img alt="G2" src="https://img-blog.csdnimg.cn/da6a0593f88d4ed199b040e6d4e759c7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IOM6ZSF5YiH5Zu-5LuU,size_18,color_FFFFFF,t_70,g_se,x_16#pic_center"/><br/> 陷阱：注意要<strong>取模取模取模</strong>，经常有人忘记这回事！！！<br/> （是的，比如说，我倒数第二题就忘记取模了。。。。。<br/> 这道题足足用了我三张白纸，我从 n = 1 画到了 n = 6，写了一个小时。<br/> 我认为 dp 就是找规律，可是，该死的是我 n = 6 的时候漏画了一种情况（三列横着的摆放），导致一直找不到规律。。。</p>
<p>这道题的规律是，第 n 列可以通过前面的排列，再加上那几种基础的排列得到。<br/> 第一种情况：<br/> dp[n] 可以通过 dp[n - 1] 加上普通的一列得到<br/> 第二种情况：<br/> dp[n] 可以通过 dp[n - 2] 加上两块横的得到<br/> 第三种情况：<br/> dp[n] 可以通过 dp[n - 3] 加上两个三角形的堆起来得到，但要注意的是，<strong>这两个三角形的堆叠方式有两种</strong>，所以要加上两倍的 dp[n - 3]<br/> <strong>第四种情况：</strong>（我考试的时候给漏掉了555，<strong>不过我现在还是没考虑完整，待完善…</strong><br/> dp[n]可以通过 dp[n - 4] 加上由左右两个各一个三角形，中间若干个横块的组合得到，同第三种情况，这个组合可以倒过来，即有两种堆叠方式，因此要加上两倍的 dp[n - 4]<br/> 综上：dp[n] = dp[n - 1] + dp[n - 2] + dp[n - 3] * 2 + dp[n - 4] * 2 <strong>（错解，待完善）</strong></p>
<pre><code>#include &lt;iostream&gt;
using namespace std;

const long long MOD = 1e9 + 7;

const int maxn = 1e7 + 100;
long long dp[maxn];

int main() {
	int n;
	cin &gt;&gt; n;
	dp[0] = 1;
	dp[1] = 1;
	dp[2] = 2;
	dp[3] = 5;
	for (int i = 4; i &lt;= n; i++) {
		// 注意每次相加后都要取余
		dp[i] = (((((dp[i - 1] + dp[i - 2]) % MOD) + dp[i - 3] * 2) % MOD) + dp[i - 4] * 2) % MOD;
	}
	cout &lt;&lt; dp[n] &lt;&lt; endl;
	return 0;
}
</code></pre>
<h1><a id="_H_BFS_448"></a>试题 H: 扫雷（BFS）</h1>
<p><img alt="H1" src="https://img-blog.csdnimg.cn/26e8a6c9961047efb4a61db2b50d01e2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IOM6ZSF5YiH5Zu-5LuU,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center"/></p>
<h2><a id="_450"></a>【样例输入】</h2>
<pre><code>2 1
2 2 4
4 4 2
0 0 5
</code></pre>
<h2><a id="_457"></a>【样例输出】</h2>
<pre><code>2
</code></pre>
<p><img alt="H2" src="https://img-blog.csdnimg.cn/6e2c7a6b040e43a08e60890eeecf63a8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IOM6ZSF5YiH5Zu-5LuU,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center"/><br/> 赛前半小时又专门看了眼 BFS，用上了！<br/> 陷阱①：一个点处可以存在多个炸雷和排雷火箭。当炸雷位于爆炸范围的边界上时也会被引爆。<br/> 陷阱②：有 m 个排雷火箭，但只要求在最后输出一个整数表示答案（我比赛时就输出了 m 次答案…）</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;cmath&gt;
#include &lt;map&gt;
using namespace std;

const int maxn = 50100;
// 记录坐标和半径
int x_pos[maxn];
int y_pos[maxn];
int radius[maxn];
bool vis[maxn]; // 用来记录这个点爆炸了没有

// 用于 bfs 的 struct，更方便处理
struct point {
	int x, y, r;
	// 将结构体放入 map 中，需要自己写一个 operator 来排序，因为 map 本身是有序的
	bool operator &lt; (const point&amp; p) const {
		if (x == p.x) {
			if (y == p.y) {
				return r &lt; p.y;
			}
			return y &lt; p.y;
		}
		return x &lt; p.x;
	}
};

map&lt;point, int&gt; all;

double getDis(int x1, int y1, int x2, int y2) {
	return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
}

int bfs(point begin, int n) {
	int cnt = 0;
	queue&lt;point&gt; q;
	q.push(begin);
	while (!q.empty()) {
		point cur = q.front();
		q.pop();
		// 遍历以 2 倍半径为边长的正方形，找到其爆炸所涉及到的炸雷
		for (int i = cur.y - cur.r; i &lt;= cur.y + cur.r; i++) {
			for (int j = cur.x - cur.r; j &lt;= cur.x + cur.r; j++) {
				if (getDis(j, i, cur.x, cur.y) &gt; cur.r) {
					continue;
				}
				point temp;
				temp.y = i, temp.x = j;
				for (int k = 0; k &lt; n; k++) {
					if (!vis[k] &amp;&amp; x_pos[k] == temp.x &amp;&amp; y_pos[k] == temp.y) {
						temp.r = radius[k];
						q.push(temp);
						cnt++;
						all[temp]--;
						vis[k] = true; // 标记为已爆炸
					}
				}
			}
		}
	}
	return cnt;
}

int main() {
	int n, m;
	cin &gt;&gt; n &gt;&gt; m;
	for (int i = 0; i &lt; n; i++) {
		cin &gt;&gt; x_pos[i] &gt;&gt; y_pos[i] &gt;&gt; radius[i];
		vis[i] = false; // 初始化都还没有爆炸
	}
	int cnt = 0;
	for (int i = 0; i &lt; m; i++) {
		point p;
		cin &gt;&gt; p.x &gt;&gt; p.y &gt;&gt; p.r;
		// 我比赛时输出了 m 次结果，裂开了
		// int cnt = 0;
		cnt += bfs(p, n);
		// cout &lt;&lt; cnt &lt;&lt; endl;
	}
	cout &lt;&lt; cnt &lt;&lt; endl;
	return 0;
}
</code></pre>
<h1><a id="_I_DP___550"></a>试题 I: 李白打酒加强版（三维DP / 回溯）</h1>
<p><img alt="I1" src="https://img-blog.csdnimg.cn/cc5f80bbfc844c94bd18d08470f90b79.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IOM6ZSF5YiH5Zu-5LuU,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center"/></p>
<h2><a id="_552"></a>【样例输入】</h2>
<pre><code>5 10
</code></pre>
<h2><a id="_556"></a>【样例输出】</h2>
<pre><code>14
</code></pre>
<p><img alt="I2" src="https://img-blog.csdnimg.cn/834f4c0ce28549b8ba901fc10e717469.png#pic_center"/><br/> <img alt="I3" src="https://img-blog.csdnimg.cn/aa7a2fab8ec64d66aa759be715346b1c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IOM6ZSF5YiH5Zu-5LuU,size_12,color_FFFFFF,t_70,g_se,x_16#pic_center"/><br/> 泪目了，写题解发现 我 竟 然 <strong>忘记取模了忘记取模了忘记取模了</strong>5555555555<br/> <strong>大家一定要记得取模！！！</strong></p>
<p>做法一：三维dp（赛后学习的优化方法）</p>
<p>三个维度分别对应：走了多少步、经过了多少家酒馆，酒壶中还剩多少酒<br/> 在走到第 n 步时，他可能是从花走来的，也有可能是从酒馆走来的，所以要加上上一步遇到花的所有可能走法，再加上上一步遇到酒馆的所有可能走法。</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;

const int MOD = 1e9 + 7;
const int maxn = 105; 
long long dp[maxn][maxn][maxn] = { 0 };

int main() {
	int n, m;
	cin &gt;&gt; n &gt;&gt; m;
	// 初始化 dp
	dp[0][0][2] = 1;
	for (int i = 1; i &lt;= n + m; i++) {
		for (int j = 0; j &lt;= i; j++) {
			for (int k = 0; k &lt;= 100; k++) {
				// 遇到了花后抵达第 i 步
				dp[i][j][k] = (dp[i][j][k] + dp[i - 1][j][k + 1]) % MOD;
				// 遇到了酒馆后抵达第 i 步
				// 当 k % 2 == 0 时才有可能是从酒馆走来的，因为经过酒馆后酒就加倍了
				if (j != 0 &amp;&amp; k % 2 == 0) {
					dp[i][j][k] = (dp[i][j][k] + dp[i - 1][j - 1][k / 2]) % MOD;
				}
			}
		}
	}
	cout &lt;&lt; dp[n + m - 1][n][1] &lt;&lt; endl;
	return 0;
}
</code></pre>
<p>做法二：回溯法（比赛时用的方法）</p>
<p>年前和年后都练了一段时间的回溯，觉得特别有意思。<br/> 赛前半小时还专门看了一眼！！然后考试最后半个小时花了 20min 就写出来了。<br/> 本来一下子就写出框架了，不过太着急了，很多题目条件没看清楚，导致找了好久错误，不过还好，这题答案错了的话就是比正确答案大一些，很容易发现错误。</p>
<p>主要错误如下：<br/> ① 一共必须要且仅要经过 N 次店，M 次花<br/> ② 最后一次遇到的必须是花<br/> ③ 最后遇到花后，酒必须喝光<br/> ④ 在中途遇到花时，酒不能为空</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
using namespace std;

const int MOD = 1e9 + 7;

void backTrack(vector&lt;char&gt;&amp; temp, vector&lt;vector&lt;char&gt; &gt;&amp; ans, int n, int m, int nn, int mm, int jiu) {
	if (jiu &lt; 0) return; // 如果遇到花却没酒了，则不符合条件
	if (nn &gt; n || mm &gt; m) return; // 如果经过了多于 N 次店、M 次花，则不符合条件
	if (temp.size() == n + m) {
		if (jiu == 0 &amp;&amp; temp.back() == '0') { // 如果最后到达的是店也不符合条件
			ans.push_back(temp);
		}
		return;
	}
	
	temp.push_back('0');
	backTrack(temp, ans, n, m, nn, mm + 1, jiu - 1);
	temp.pop_back();
	temp.push_back('1');
	backTrack(temp, ans, n, m, nn + 1, mm, jiu * 2);
	temp.pop_back();
}

int main() {
	int n, m;
	cin &gt;&gt; n &gt;&gt; m;
	int jiu = 2;
	vector&lt;char&gt; temp;
	vector&lt;vector&lt;char&gt; &gt; ans;
	backTrack(temp, ans, n, m, 0, 0, jiu);
	cout &lt;&lt; ans.size() % MOD &lt;&lt; endl;
	return 0;
}
</code></pre>
<h1><a id="_J__649"></a>试题 J: 砍竹子</h1>
<p><img alt="J1" src="https://img-blog.csdnimg.cn/e5236704ebca4e07ad7ca8577d01995d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IOM6ZSF5YiH5Zu-5LuU,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center"/></p>
<h2><a id="_651"></a>【样例输入】</h2>
<pre><code>6
2 1 4 2 6 7
</code></pre>
<h2><a id="_656"></a>【样例输出】</h2>
<pre><code>5
</code></pre>
<p><img alt="J2" src="https://img-blog.csdnimg.cn/c4da0fafb6cd47e884444d478cf57fd3.png#pic_center"/><br/> <img alt="J3" src="https://img-blog.csdnimg.cn/b43587cd39b544bfa79984f3b2f2a502.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IOM6ZSF5YiH5Zu-5LuU,size_14,color_FFFFFF,t_70,g_se,x_16#pic_center"/><br/> 还剩最后十分钟，没时间做了，看了眼题也确实不会做。</p>
<h1><a id="_664"></a>总结</h1>
<p>① 注意题目要求，记得取模！<br/> ② 注意范围，可能要用 long long<br/> ③ 不要在一道题卡太长时间，比如我在 E 题卡了一个小时都没看懂题，就应该早早换题，最后换换思路再回来看或许反而能看懂了</p>
</div>
<link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css" rel="stylesheet"/>
<link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css" rel="stylesheet"/>
</div>