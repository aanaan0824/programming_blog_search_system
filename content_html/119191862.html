<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="markdown_views prism-atom-one-dark" id="content_views">
<svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
<path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
</svg>
<h2><a id="Python_0"></a>Python期末考试知识点（史上最全）</h2>
<blockquote>
<p>✅作者简介：大家好我是编程ID<br/> 📃个人主页：编程ID的csdn博客<br/> 系列专栏：python<br/> 💬推荐一款模拟面试、刷题神器👉<a href="https://www.nowcoder.com/link/pc_csdncpt_bcid_python">点击跳转进入网站</a></p>
</blockquote>
<p><img alt="请添加图片描述" src="https://img-blog.csdnimg.cn/3607773700ec43ef98e8f9a572748120.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ3NDcwMQ==,size_16,color_FFFFFF,t_70"/><br/> <img alt="请添加图片描述" src="https://img-blog.csdnimg.cn/443e413dae8e4092adefd25b7c2e9d4b.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ3NDcwMQ==,size_16,color_FFFFFF,t_70"/></p>
<p><img alt="请添加图片描述" src="https://img-blog.csdnimg.cn/d2128fdcc13a4d109818139ea8aa4424.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ3NDcwMQ==,size_16,color_FFFFFF,t_70"/></p>
<p><img alt="请添加图片描述" src="https://img-blog.csdnimg.cn/6133da20809b400b9a1e43b906d16118.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ3NDcwMQ==,size_16,color_FFFFFF,t_70"/></p>
<p><img alt="请添加图片描述" src="https://img-blog.csdnimg.cn/4a3d86269be043238785a222e0f6982b.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ3NDcwMQ==,size_16,color_FFFFFF,t_70"/></p>
<p><img alt="请添加图片描述" src="https://img-blog.csdnimg.cn/2c393a80a4c94d7ea00ed0295aedaad8.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ3NDcwMQ==,size_16,color_FFFFFF,t_70"/><br/> <img alt="请添加图片描述" src="https://img-blog.csdnimg.cn/41f470b9520d4e9fafd67bc5a402f4b8.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ3NDcwMQ==,size_16,color_FFFFFF,t_70"/></p>
<p><img alt="请添加图片描述" src="https://img-blog.csdnimg.cn/06829a4c0d3c407f85aea235c6fec4fa.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ3NDcwMQ==,size_16,color_FFFFFF,t_70"/></p>
<h2><a id="python_25"></a>python简介</h2>
<pre><code>Python是一种解释型语言
Python使用缩进对齐组织代码执行，所以没有缩进的代码，都会在载入时自动执行
数据类型：整形          int              无限大 
                  浮点型      float            小数
                  复数         complex       由实数和虚数组成

Python中有6个标准的数据类型：
        Number(数字)
        String(字符串)
        List(列表)
        Tuple(元组)
        Sets(集合)
        Dictionart(字典)
其中不可变得数据：
               Number(数字)            String(字符串)            Tuple(元组)            Sets(集合)
可变得：
               List(列表)         Dictionart(字典)    
我们可以用type或者isinstance来判断类型
</code></pre>
<p><img alt="请添加图片描述" src="https://img-blog.csdnimg.cn/82128dc5dd2649c4912479340fe1860d.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ3NDcwMQ==,size_16,color_FFFFFF,t_70"/></p>
<p>type()不会认为子类是一种父类类型。<br/> isinstance()会认为子类是一种父类类型</p>
<pre><code>python中定义变量，不需要写变量类型，但是必须初始化。会根据我们写的数据类型，自动匹配
变量命名规则：由字母，数字，下划线组成，第一个必须字母或者下划线，对大小写敏感，不能是关键字

输入与输出
    在我们需要输入中文的时候，需要包含头文件  # -*- coding: UTF-8 -*- 或者 #coding=utf-8
    输入    a=input("请输入一个数字")          返回值为str类型
    输出    print('hello world')                        当然这里也可以严格按照格式控制符去输出变量值
        例如：print("now a=%d,b=%d"%(a,b))        双引号后面没有逗号
     print默认换行，我们可以print( end='')，修改默认参数让他不换行，
                                也可以在print()后面加逗号  print(xxx) ,   这样也可以不换行    测试发现：只适合在2.7版本
</code></pre>
<ol start="2"><li>基础语法<br/> 运算符：<br/> 算术运算符： 多了一个**，代表 幂方 5**5 就是5的5次方 还多了一个 // 整数除法<br/> 逻辑运算符： and,or,not 与，或，非<br/> 赋值运算符： 没有++，–<br/> 身份运算符： is is not</li></ol>
<p>成员关系运算符: in not in<br/> 总结：多出来了** 和 // //就是整除的意思 比如 5//3结果为 1 但是5/3结果为小数 1.6666666667</p>
<pre><code>运算符优先级(下面由高到低)：幂运算符最高
幂运算符                **
正负号                    + -
算术运算符            *，/，//，+，-
比较运算符            &lt;,&lt;=,&gt;,&gt;=,==,!=
逻辑运算符            not,and,or    (not&gt;and&gt;or)
</code></pre>
<p>选择结构<br/> if-else<br/> if-elif-else(这里可以不写else)</p>
<pre><code>     逻辑结果
        python里面只要是"空”的东西都是false    ""(中间有空格就为真，这里什么都不写，为假)    空元组，空列表，空字典    0 都为false
</code></pre>
<p>字符串<br/> <img alt="请添加图片描述" src="https://img-blog.csdnimg.cn/3852c9d5683d4fa19727021c0fa4b6b4.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ3NDcwMQ==,size_16,color_FFFFFF,t_70"/></p>
<p>Pis:在字符串前面添加一个 r，表示原始字符串，不会发生转义<br/> 列表<br/> list是处理一组有序项目的数据结构，用方括号定义<br/> 列表的操作：<br/> 一，通过下标去访问列表中的值 (可以用切片的方式去访问)</p>
<pre><code>     输出结果：这里就用了切片的方式去访问1到5
      
重点：这里切片的使用方法要注意，我们写的1:5实际访问的是下标为1,2,3,4.没有5！
</code></pre>
<p><img alt="请添加图片描述" src="https://img-blog.csdnimg.cn/1c2f57716760454bbe49d349e53638b7.png"/></p>
<p>二，更新列表（列表是可以修改的）<br/> 通过下标去直接修改他的值</p>
<p>三，删除列表元素（del + 列表项） 删除项remove()后面说<br/> <img alt="请添加图片描述" src="https://img-blog.csdnimg.cn/825af6cbdf9b4f2cbe8448e1399f81f9.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ3NDcwMQ==,size_16,color_FFFFFF,t_70"/></p>
<p>四，列表的脚本操作符</p>
<p><img alt="请添加图片描述" src="https://img-blog.csdnimg.cn/46b4ab5e17cb47d09f71df934d493b58.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ3NDcwMQ==,size_16,color_FFFFFF,t_70"/></p>
<p>五，对于列表截取，拼接<br/> <img alt="请添加图片描述" src="https://img-blog.csdnimg.cn/68c630bc12fa4909aed841dc97713f02.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ3NDcwMQ==,size_16,color_FFFFFF,t_70"/></p>
<p>六，list自带函数 (其中有元组转列表)</p>
<p>方法 功能<br/> max(list) 返回列表元素最大值<br/> min(list) 返回列表元素最小值<br/> list(seq) 元组转列表<br/> list.append(obj) 在列表末尾添加新对象<br/> list.count(obj) 统计某个元素在列表出现的次数<br/> list.extend(seq) 在末尾添加新列表，扩展列表<br/> list.index(obj) 在列表中找出某个值第一个匹配性的索引位置<br/> list.insert(index,obj) 将对象插入列表，其中的index，为插入的位置，原来该位置后面的元素包含该位置元素，都统一后移<br/> list.pop(obj=list[-1])<br/> 有默认参数,即最后一项 删除指定位置元素并返回，他和del的区别在于del是一个关键字。而pop是内建函数，我们无法用变量去接收del删除的项 （参数可以不写，默认删除最后一项）<br/> list.remove(obj) 移出列表中某个值第一次匹配的项<br/> list.reverse() 反向列表中的元素(收尾互换)，不代表倒序排列！<br/> list.sort() 对列表进行排序<br/> list.copy() 复制列表<br/> list.clear() 清空列表</p>
<p>Set集合<br/> 集合是一个无序不重复元素的序列<br/> 基本功能就是进行成员关系测试，和删除重复元素 （所谓成员关系测试就是查看他们是否重复，两个集合的交集…）<br/> 可以使用 { } 或者set()函数来创建集合 但是创建一个空集合必须适用set()<br/> <img alt="请添加图片描述" src="https://img-blog.csdnimg.cn/bb1b06644c2c46ebba3235217731d547.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ3NDcwMQ==,size_16,color_FFFFFF,t_70"/></p>
<h2><a id="_156"></a>编程语言的进化：机器语言、汇编语言、高级语言</h2>
<p>机器语言：由于计算机内部只能接受二进制代码，因此，用二进制代码0或1描述的指令称为机器指令，全部机器指令的集合构成计算机的机器语言。</p>
<p>汇编语言：实质和机器语言是相同的，都是直接对硬件操作，只不过指令采用英文缩写的标识符，更容易识别和记忆。</p>
<p>高级语言：高级语言对开发人员更加友好，开发效率大大提高</p>
<p>高级语言所编制的程序不能直接被计算机识别，必须经过转换才能被执行。</p>
<p>高级语言按转换方式可分为：编译型、解释型</p>
<p>编译型：指在应用源程序执行之前，将程序源代码转换成目标代码，因此其目标代码可以脱离其语言环境独立执行。</p>
<p>编译后程序运行时不需要重新翻译，直接使用翻译的结果就行。程序执行效率高，依懒性编译器，跨平台性差。如C、C++、GO、Delphi等</p>
<p>解释型：应用程序源代码一边由相应语言的解释器翻译成目标代码，一边执行，因此效率比较低，不能生成可独立执行的可执行文件，应用程序不能脱离其解释器。如Python、Java、PHP、Ruby等。跨平台性好、开发效率不高。</p>
<p>编译型语言执行速度快，不依赖语言环境运行，跨平台差</p>
<p>解释型跨平台好，一份代码，到处运行。缺点是执行速度慢，依赖解释器运行。</p>
<p>Python创始人：Guido van Rossum（龟叔）</p>
<p>Python诞生在1989年</p>
<p>2008年12月出现Python3.0</p>
<p>2010年出现一个过渡版本Python2.7（最多只支持到2020年,之后不支持2.0版本）</p>
<p>Python解释器是用C语言写的</p>
<p>Python解释器种类有：CPython、IPython、PyPy、Jython、IronPython</p>
<p>测试安装是否成功：</p>
<p>windows–&gt;运行–&gt;输入cmd,回车，弹出cmd程序，输入Python，如果进入交互环境，代表安装成功。</p>
<p>print(‘hello world!’)</p>
<p>保存为helloworld.py,注意.py后缀名的作用：命名约束规范，方便程序员识别代码。</p>
<p>进入cmd命令行，执行Python helloworld.py,看结果。</p>
<p>注意文件名前面加python的原因是要把代码交给python解释器去解释执行</p>
<p>内存和磁盘的关系：内存存取速度快，断电就丢失；磁盘存取速度慢，永久保存。</p>
<p>Python交互器是主要用来对代码进行调试用的</p>
<p>变量：先定义后使用</p>
<p>变量作用：存数据，占内存，存储程序运行的中间结果，可以被后面的代码调用。</p>
<p>声明变量：变量名=变量的值</p>
<p>变量的命名规则：</p>
<p>1.变量名只能是数字、字母或下划线的任意组合</p>
<p>2.变量名的第一个字符不能是数字</p>
<p>3.以下关键字不能声明为变量名[‘and’,‘as’,‘assert’,‘break’,‘class’,‘continue’,‘def’,‘elif’,‘else’,‘except’,‘exec’,‘finally’,‘for’,‘from’,‘global’,‘if’,‘import’,‘in’,‘is’,‘lambda’,‘not’,‘or’,‘pass’,‘print’,‘raise’,‘return’,‘try’,‘while’,‘with’,‘yield’]</p>
<p>常量：程序在执行过程中不能改变的量</p>
<p>在Python中没有一个专门的语法代表常量，程序员约定俗成的变量名全部大写代表常量。</p>
<p>读取用户输入</p>
<p>name = input(“what’s your name:”)print(“hello”+name)</p>
<p>输入用户姓名和密码</p>
<p>username= input(“username:”)</p>
<p>password= input(“password:”)print(username,password)</p>
<p>注释:解释说明，帮助阅读代码。</p>
<p>单行注释：#</p>
<p>多行注释：‘’‘…’‘’</p>
<p>数据类型</p>
<p>数据类型-数字类型</p>
<p>int（整型）：32位机器上：-2<strong>31 —— 2</strong>31-1 64位同样的道理</p>
<p>long（长整型）：Python的长整型没有指定位宽。（Python3里不再有long类型）</p>
<p>float（浮点型）：</p>
<p>数据类型-字符串类型</p>
<p>字符串：在Python中，加了引号的字符都被认为是字符串！</p>
<p>注意：单双引号是没有任何区别的；多行字符串必须用多引号。</p>
<p>布尔类型：</p>
<p>只有两个值True、False ，主要用来做逻辑判断</p>
<p>格式化输出：（%s 以一个字符替换 %d以一个整数替换 %f以一个浮点数替换）都是一个占位符 %是一个连接符</p>
<p>运算符</p>
<p>算术运算符（+,-,*,/,%,**,//），</p>
<p>比较运算符(==,!=,&lt;&gt;,&gt;,&lt;,&gt;=,&lt;=)，</p>
<p>逻辑运算符(and,or,not)，</p>
<p>赋值运算符(=,+=,*=,/=,%=,**=,//=)，</p>
<p>成员运算符(in,not in)，</p>
<p>身份运算符(is , is not)，</p>
<p>位运算(&gt;&gt;,&lt;&lt;)</p>
<p>流程控制</p>
<p>单分支：</p>
<p>if 条件：</p>
<p>满足条件后要执行的代码块</p>
<p>多分支：</p>
<p>if 条件：</p>
<p>满足条件后要执行的代码块</p>
<p>elif 条件：</p>
<p>上面的条件不满足就走这个</p>
<p>elif 条件：</p>
<p>上面的条件不满足就走这个</p>
<p>elif 条件：</p>
<p>上面的条件不满足就走这个</p>
<p>else:</p>
<p>上面的条件不满足就走这个</p>
<p>while循环</p>
<p>while 条件：</p>
<p>执行代码…</p>
<p>Dead Loop</p>
<p>count=0</p>
<p>while True:</p>
<p>print(“你个基佬！！！”,count)</p>
<p>count+=1</p>
<p>循环终止语句：break语句或continue语句</p>
<p>break语句：用于完全结束一个循环，跳出循环体执行后面的语句</p>
<p>continue语句：只终止本次循环，接着执行后面的循环</p>
<p>while…else用法</p>
<p>当while循环正常执行完，中间没有被break终止的话，就会执行else后面的语句。</p>
<p>二进制运算、字符编码、数据类型</p>
<p>二进制（0,1）、八进制（0-7）、十进制（0-9）、十六（0-9，A-F）进制的转换</p>
<p>四位二进制表示一位十六进制</p>
<p>oct() 八进制 hex()十六进制</p>
<p>char(num)将ASCII值得数字转换成ASCII字符，范围只能是0-255</p>
<p>ord(char)接受一个ASCII值字符，返回相应的ASCII值</p>
<p>每一位0或1所占的空间单位为bit(比特)，这是计算机中最小的表示单位</p>
<p>8bits = 1Bytes字节,最小的存储单位，1bytes缩写为1B</p>
<p>1024Bytes = 1KB = 1KB</p>
<p>1024KB = 1MB</p>
<p>1024MB =1GB</p>
<p>1024GB = 1TB</p>
<p>1024TB = 1PB</p>
<p>ASCII 256，每一个字符占8位</p>
<p>Unicode编码(统一码、万国码):规定了所有的字符和符号最少由16位表示</p>
<p>UTF-8:ascii码中的内容用1个字节保存，欧洲的字符用2个字节保存，东亚的字符用3个字节保存…</p>
<p>winsows系统中文版默认编码是GBK</p>
<p>Mac OS\Linux系统默认编码是UTF-8</p>
<p>UTF是为unicode编码 设计的一种在存储和传输时节省空间的编码方案。</p>
<p>无论以什么编码在内存里显示字符，存到硬盘上都是二进制。不同编码的二进制是不一样的</p>
<p>存到硬盘上以何种编码存的，那么读的时候还得以同样的编码读，否则就乱码了。</p>
<p>python2.x默认编码是ASCII；默认不支持中文，支持中文需要加：#<em>*</em> coding:utf-8 <em>*</em> 或者 #!encoding:utf-8</p>
<p>Python3.x默认编码是UTF-8，默认支持中文</p>
<p>Python数据类型</p>
<p>字符串 str</p>
<p>数字：整型（int）长整型(long) 浮点型(float) 布尔（bool） 复数（complex）</p>
<p>列表 list</p>
<p>元组 tuple</p>
<p>字典 dictionary</p>
<p>集合:可变集合(set) 不可变集合（frozenset）</p>
<p>不可变类型：数字，字符串，元组</p>
<p>可变类型：列表，字典，集合</p>
<p>899590-20180512120213031-26929447.png</p>
<p>字符串</p>
<p>特点：有序、不可变</p>
<p>字符串的常用方法:isdigit,replace,find,count,index,strip,split,format,join,center</p>
<p>ContractedBlock.gif</p>
<p>ExpandedBlockStart.gif</p>
<p>1 s = “abcd”</p>
<p>2 print(s.swapcase()) #都变成大写字母</p>
<p>3</p>
<p>4 print(s.capitalize()) #都变成首字母大写</p>
<p>5</p>
<p>6 print(s.center(50,"<em>")) #打印变量s的字符串 指定长度为50，字符串长度不够的用</em>号补齐</p>
<p>7</p>
<p>8 print(s.count(“a”,0,5)) #统计字符串a在变量里有几个；0,5代表统计范围是下标从0-5的范围</p>
<p>9</p>
<p>10 print(s.endswith(“!”)) #是否是以什么结尾的。</p>
<p>11</p>
<p>12 print(s.startswith(“a”)) #判断以什么开始</p>
<p>13</p>
<p>14</p>
<p>15 s = “a b”</p>
<p>16 print(s.expandtabs(20)) #相当于在a和b中间的tab长度变成了20个字符，交互模式可看出效果</p>
<p>17</p>
<p>18 s.find(“a”,0,5) #查找字符串，并返回索引</p>
<p>19</p>
<p>20 s.format() #字符串格式化</p>
<p>21 s1 = “my name is {0},i am {1} years old”</p>
<p>22 print(s1)23 print(s1.format(“aaa”,22)) #分别把{0}替换成aaa {1}替换成22</p>
<p>24 #也可以写成如下</p>
<p>25 s1 = “my name is {name},i am {age} years old”</p>
<p>26 s1.format(name=“aaa”,age = 22) #字典形式赋值</p>
<p>27</p>
<p>28 #s.format_map() #后续补充</p>
<p>29</p>
<p>30</p>
<p>31 print(s.index(“a”)) #返回索引值</p>
<p>32</p>
<p>33 print(s.isalnum()) #查看是否是一个阿拉伯字符 包含数字和字母</p>
<p>34</p>
<p>35 print(s.isalpha()) #查看是否是一个阿拉伯数字 不包含字母</p>
<p>36</p>
<p>37 print(s.isdecimal()) #判断是否是一个整数</p>
<p>38</p>
<p>39 print(s.isdigit()) #判断是否是一个整数</p>
<p>40</p>
<p>41 print(s.isidentifier()) #判断字符串是否是一个可用的合法的变量名</p>
<p>42</p>
<p>43 print(s.islower()) #判断是否是小写字母</p>
<p>44</p>
<p>45 print(s.isnumeric()) #判断只有数字在里边</p>
<p>46</p>
<p>47 print(s.isprintable()) #判断是否可以被打印，linux的驱动不能被打印</p>
<p>48</p>
<p>49 print(s.isspace()) #判断是否是一个空格</p>
<p>50</p>
<p>51 print(s.istitle()) #判断是否是一个标题 每个字符串的首字母大写 Hello Worlld</p>
<p>52</p>
<p>53 print(s.isupper()) #判断是否都是大写</p>
<p>54</p>
<p>55 #s.join()</p>
<p>56 name = [“a”,“b”,“1”,“2”]57 name2 = “”.join(name) #列表转成字符串，把列表里边的元素都join到字符串中</p>
<p>58 print(name2) #得出ab12</p>
<p>59</p>
<p>60 #s.ljust</p>
<p>61 s = “Hello World”</p>
<p>62 print(s.ljust(50,“-”)) #给字符串从左往右设置长度为50，字符串长度不够用 - 补充</p>
<p>63</p>
<p>64 print(s.lower()) #字符串都变成小写</p>
<p>65</p>
<p>66 print(s.upper()) #变大写</p>
<p>67</p>
<p>68 print(s.strip()) #脱掉括号里边的，可以是空格 换行 tab …</p>
<p>69</p>
<p>70 s.lstrip() #只脱掉左边的空格</p>
<p>71 s.rstrip() #只拖点右边的空格</p>
<p>72</p>
<p>73 #s.maketrans() #</p>
<p>74 str_in = “abcdef” #必须是一一对应</p>
<p>75 str_out = “!@#$%^” #必须是一一对应</p>
<p>76 tt = str.maketrans(str_in,str_out) #生成对应表，就像密码表一样</p>
<p>77 print(tt)78 #结果：{97: 33, 98: 64, 99: 35, 100: 36, 101: 37, 102: 94}</p>
<p>79</p>
<p>80 print(s.translate(tt)) #s.translate方法调用 加密方法tt 给 s的字符串加密</p>
<p>81 #结果：H%llo Worl$</p>
<p>82</p>
<p>83 #s.partition()</p>
<p>84 s = “Hello World”</p>
<p>85 print(s.partition(“o”)) #把字符串用 从左到右第一个o把 字符串分成两半</p>
<p>86 #结果：(‘Hell’, ‘o’, ’ World’)</p>
<p>87</p>
<p>88 s.replace(“原字符”,“新字符”,2) #字符串替换，也可以写换几次 默认全换，可以设置count次数</p>
<p>89</p>
<p>90 s.rfind(“o”) #查找最右边的字符，也有开始和结束</p>
<p>91</p>
<p>92 print(s.rindex(“o”) ) #查找最右边的字符的索引值</p>
<p>93</p>
<p>94 s.rpartition(“o”) #从最右边的字符开始 把字符串分成两半</p>
<p>95</p>
<p>96 s.split() #已括号里边的把字符串分成列表，括号里可以是空格、等字符来分成列表</p>
<p>97</p>
<p>98 s.rsplit() #从最右边以 某字符 来分开字符串</p>
<p>99</p>
<p>100 s.splitlines() #设置以换行的形式 把字符串分成列表</p>
<p>101</p>
<p>102 print(s.swapcase()) #字母换成相反的大小写，大的变成小，小的变成大</p>
<p>103 #结果“：hELLO wORLD</p>
<p>104 #原来的“hello World”</p>
<p>105</p>
<p>106 s.title() #把字符串变成title格式 Hello World</p>
<p>107</p>
<p>108 s.zfill(40) #把字符串变成40，字符串不够，从左往右用0 补齐</p>
<p>109</p>
<p>110</p>
<p>111 #“a\tb” 字符串中间的\t 被认为是tab 是4个或者8个空格</p>
<p>112 #整体意思是：a 有一个tab 然后 又有一个b</p>
<p>View Code</p>
<p>列表</p>
<p>列表的常用方法：创建、查询、切片、增加、修改、删除、循环、排序、反转、拼接、clear、copy</p>
<p>列表的特点：可以重复；列表是有序的</p>
<p>ContractedBlock.gif</p>
<p>ExpandedBlockStart.gif</p>
<p>1 1、创建2 ​ 方法一：list1 = [“a”, “b”]　　 #常用</p>
<p>3 ​ 方法二：list2 = list () 　　　 #一般不用这种方法</p>
<p>4</p>
<p>5 2、查询6 ​ 列表的索引 (也称下标)：7 列表从左到右下标是从0开始0、1、2、3…8 ​列表从右到左下标是从 - 1开始 -1 -2 -3…9</p>
<p>10 ​查询索引值：11 ​list1.index (a) 　　 #index查询找到第一个a程序就不走了，</p>
<p>12 list1[0] 　　 #通过a的索引 得出a</p>
<p>13 list1[-1]　　 #通过b的下标 得出b</p>
<p>14</p>
<p>15 当list1 = [1, 2, 3, 4, 4, 4, 4, 4, 4]16 列表里出现元素相同时，统计相同次数17 list1.count (4) 　　 #统计得出:6 代表列表有6个4</p>
<p>18</p>
<p>19 3、切片20 切片：通过索引 (或下标)21 截取列表中一段数据出来。22 list1 = [1, 2, 3, 4, 4, 4, 4, 4, 4]23 list1[0:2] 　　 #得出 [1,2] ，列表切片顾头不顾尾，也可成list1[:2]</p>
<p>24 list1[-5:] 　　 #得出[4,4,4,4,4]，取最后5个元素，只能从左往右取</p>
<p>25 按步长取元素：26 list1 = [1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5]27 list1[:6:2] 　　 #得出:[1, 3, 5] 　　:2 代表步长 ，每隔两步取一个元素</p>
<p>28 list1[::2] 　　 #得出:[1, 3, 5, 1, 3, 5] 　在列表所有元素中，每隔2步取一个数</p>
<p>29</p>
<p>30 4、增加31 list1 = [“a”, “b”, “c”]32 list1.append (“d”) 　　 #追加d到列表list1的最后 结果:[‘a’, ‘b’, ‘c’, ‘d’]</p>
<p>33 list1.insert (1, “aa”) 　　 #插入aa到列表下标为1的之前 　　得出结果:[‘a’, ‘aa’, ‘b’, ‘c’, ‘d’]</p>
<p>34</p>
<p>35 5、修改36 list1[1] = “bb” 　　 #直接给对应位置赋值，即是修改 结果:[‘a’, ‘bb’, ‘b’, ‘c’, ‘d’]</p>
<p>37 批量修改38 把[‘a’, ‘bb’, ‘b’, ‘c’, ‘d’]里的前两个元素替换掉39 list1[0:2] = “boy” 　　 #结果:[‘b’, ‘o’, ‘y’, ‘b’, ‘c’, ‘d’]</p>
<p>40</p>
<p>41 6、删除42 list1 = [‘b’, ‘o’, ‘y’, ‘b’, ‘c’, ‘d’]43 list1.pop () 　　 #默认删除最后一个元素 d</p>
<p>44 list1.remove (“o”) 　　 #删除元素O remove只能一个一个删除</p>
<p>45 list1.remove (0) 　　 #删除下标为0的元素 b</p>
<p>46 del list1[0] 　　 #删除下标为0的元素 del是一个全局删的方法</p>
<p>47 del list1[0:2] 　　 #del可以批量删除</p>
<p>48</p>
<p>49 7、for循环列表50 list1 = [1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5]51 for i in list1: #使用for循环循环列表list1里边的元素</p>
<p>52 range (10) 　　 #生成0到10 的数字</p>
<p>53</p>
<p>54 8、排序55 list1 = [“1”, “5”, “3”, “a”, “b”, “f”, “c”, “d”, “A”, “C”, “B”]56 list1.sort () #结果：[‘1’, ‘3’, ‘5’, ‘A’, ‘B’, ‘C’, ‘a’, ‘b’, ‘c’, ‘d’, ‘f’]</p>
<p>57</p>
<p>58 排序是按照ASCII码对应排序。59 反转60 list1.reverse () #结果：[‘f’, ‘d’, ‘c’, ‘b’, ‘a’, ‘C’, ‘B’, ‘A’, ‘5’, ‘3’, ‘1’]</p>
<p>61</p>
<p>62 9、两个列表拼一块63 #方法一</p>
<p>64 list1 = [1, 2, 3, 4, 5]65 list2 = [6, 7, 8, 9]66 list1 + list2 #结果：[1, 2, 3, 4, 5, 6, 7, 8, 9]</p>
<p>67 #​方法二</p>
<p>68 list1.extend (list2) 　　 #把列表2扩展到list1中</p>
<p>69 结果：[1, 2, 3, 4, 5, 6, 7, 8, 9]70</p>
<p>71 10、clear72 #清空列表</p>
<p>73 list2.clear () 　　 #清空list2</p>
<p>74</p>
<p>75 11、copy76 浅copy77 复制列表78 list2 =list1.copy ()79 当列表只有一层数据，没有列表嵌套列表的情况下，复制后的列表和原来的列表是完全独立的。80 当列表有多层嵌套的时候，列表嵌套里边的列表的内容是和原有列表是共享的。81 list1.copy () #所以这个叫做：浅copy</p>
<p>82</p>
<p>83 ​深copy:需要借助python模块84 importcopy85 list2 =copy.deepcopy (list1)86 深copy后，新的列表和旧的列表，不管有没有列表嵌套列表，都是完全独立的个体。87 可以通过查看列表名对应的内存地址分辨两个列表是否独立88 查看python解释器里边的内存地址：id (变量名)</p>
<p>View Code</p>
<p>元组</p>
<p>特点：有序的，不可变的列表</p>
<p>常用功能：index,count,切片</p>
<p>使用场景：显示的告知别人，此处数据不可修改；数据库连接配置信息等</p>
<p>hash函数</p>
<p>hash，一般翻译为“散列”，也有直接翻译为“哈希”的，就是把任意长度的输入，通过散列算法，变成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不通的输入可能会散列成相同的输出，所以不可能从散列值来确定唯一的输入值，简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。</p>
<p>特征：hash值的计算过程是依据这个值的一些特征计算的，这就要求被hash的值必须固定，因此被hash的值必须是不可变的。（不能保证输出的数据唯一的，容易造成冲突）</p>
<p>用途：文件签名；md5加密；密码验证</p>
<p>ContractedBlock.gif</p>
<p>ExpandedBlockStart.gif</p>
<p>1 &gt;&gt;&gt; hash(“abc”)2 -6784760005049606976</p>
<p>3 &gt;&gt;&gt; hash((1,2,3))4 2528502973977326415</p>
<p>View Code</p>
<p>字典</p>
<p>语法：info={}</p>
<p>特点：1.key-value结构，key必须是可hash、必须是不可变数据类型、必须唯一</p>
<p>2.每一个key必须对应一个value值，value可以存放任意多个值，可修改，可以不唯一</p>
<p>3.字典是无序的</p>
<p>字典的查找速度快是因为字典可以把每个key通过hash变成一个数字（数字是按照ASCII码表进行排序的）</p>
<p>字典的方法：增删改查 多级嵌套 等</p>
<p>ContractedBlock.gif</p>
<p>ExpandedBlockStart.gif</p>
<p>1 #字典方法</p>
<p>2 info ={3 “student01”:“aaa”,4 “student02”:“bbb”,5 “student03”:“ccc”</p>
<p>6 }7</p>
<p>8 #增加</p>
<p>9 info[“student04”] = “ddd”</p>
<p>10 info[“student05”] = “eee”</p>
<p>11 info[“student06”] = “fff”</p>
<p>12</p>
<p>13 #查询</p>
<p>14 #判断student01在不在info字典里</p>
<p>15 print(“student01” in info ) #返回True</p>
<p>16 print(info.get(“student01”)) #返回aaa，没有返回None</p>
<p>17 info[“student01”] #获取对应的value ，如果没有这个key 就报错，所以一般用get</p>
<p>18</p>
<p>19 #删除</p>
<p>20 print(info.pop(“student01”)) #删除key</p>
<p>21 print(info.popitem()) #随机删除一个key</p>
<p>22 del info[“student02”] #删除的key ，如果没有删除的key 就报错 KeyError: ‘student01’</p>
<p>23</p>
<p>24 info.clear() #清空字典</p>
<p>25</p>
<p>26 #多级字典嵌套</p>
<p>27 dic1 = {“aaa”: {“aa”: 11}, “bbb”: {“bb”: 22}}28</p>
<p>29 #其他方法</p>
<p>30 info ={31 “name1”: [22, “it”],32 “name2”: [24, “hr”],33 “name3”: 33</p>
<p>34 }35</p>
<p>36 info2 ={37 “name1”: 44,38 “name4”: 33,39 1: 2</p>
<p>40 }41 info.keys() #打印所有的key</p>
<p>42 info.values() #打印所有的value</p>
<p>43 info.items() #把字典转成一个列表</p>
<p>44 info.update(info2) #把两个字典合成一个,如果有重复的key ，info2里边的重复key会覆盖info里边的key</p>
<p>45 info.setdefault(“student07”,“abcdef”) #设置一个默认的key:value ,</p>
<p>46 #如果info字典里没有key student07 ，那么info字典里有添加 student07:abcdef</p>
<p>47 #如果info字典里已经手动添加了student07的key value，那么这里的student07:abcdef 就不起作用</p>
<p>48 print(info.fromkeys([“name1”,“name2”],“aaa”) ) #从一个可迭代的对象中批量生成key和相同的value</p>
<p>49</p>
<p>50 #字典的循环:高效循环</p>
<p>51 for k ininfo:52 print(k,info[k]) #打印key value</p>
<p>53</p>
<p>54 #另外一种方法 低效</p>
<p>55 for k,v in info.items(): #先把字典转成列表，在循环，所以低效</p>
<p>56 print(k,v)</p>
<p>View Code</p>
<p>集合</p>
<p>集合是一个无序的、不重复的数据组合</p>
<p>作用：1.去重</p>
<p>2.关系测试，测试两组数据之间的交集、差集、并集等关系</p>
<p>语法：</p>
<p>s = {} #如果为空，就是字典</p>
<p>s = {1,2,3,4} #就成了集合 set</p>
<p>s = {1,2,3,4,1,2} #有重复数据，显示结果就直接去重{1, 2, 3, 4}</p>
<p>列表转成给一个字典</p>
<p>l = [1,2,3,4,1,2]</p>
<p>l2 = set(l)</p>
<p>集合的方法</p>
<p>ContractedBlock.gif</p>
<p>ExpandedBlockStart.gif</p>
<p>1 #集合方法</p>
<p>2 s = {1,2,3,4,5} #定义一个集合</p>
<p>3</p>
<p>4 #增加</p>
<p>5 s.add(6)6 print(s) #{1, 2, 3, 4, 5, 6}</p>
<p>7</p>
<p>8 #删除</p>
<p>9 #随机删除</p>
<p>10 s.pop()11 print(s) #{2, 3, 4, 5, 6}</p>
<p>12 #指定删除,如果不存在，就报错</p>
<p>13 s.remove(6)14 print(s) #{2, 3, 4, 5}</p>
<p>15 #指定删除，如果不存在，不报错</p>
<p>16 s.discard(6)17 print(s)18</p>
<p>19 #联合其他集合，可以添加多个值</p>
<p>20 s.update([7,8,9])21 print(s) #{2, 3, 4, 5, 7, 8, 9}</p>
<p>22</p>
<p>23 #清空集合</p>
<p>24 s.clear()25</p>
<p>26</p>
<p>27 #集合的关系测试</p>
<p>28 iphone7 = {“alex”,“rain”,“jack”,“old_driver”}29 iphone8 = {“alex”,“shanshan”,“jack”,“old_boy”}30</p>
<p>31 #交集</p>
<p>32 print(iphone7.intersection(iphone8))33 print(iphone7 &amp;iphone8)34 #输出：</p>
<p>35 {‘jack’, ‘alex’}36 {‘jack’, ‘alex’}37</p>
<p>38 #差集</p>
<p>39 print(iphone7.difference(iphone8))40 print(iphone7 -iphone8)41 #输出：</p>
<p>42 {‘rain’, ‘old_driver’}43 {‘rain’, ‘old_driver’}44</p>
<p>45 #并集 把两个列表加起来</p>
<p>46 print(iphone7.union(iphone8))47 print(iphone7 |iphone8)48 #输出：</p>
<p>49 {‘rain’, ‘jack’, ‘old_driver’, ‘alex’, ‘shanshan’, ‘old_boy’}50 {‘rain’, ‘jack’, ‘old_driver’, ‘alex’, ‘shanshan’, ‘old_boy’}51</p>
<p>52 #对称差集 把不交集的取出来</p>
<p>53 print(iphone7.symmetric_difference(iphone8))54 #输出:</p>
<p>55 {‘rain’, ‘old_driver’, ‘shanshan’, ‘old_boy’}56</p>
<p>57 s = {1,2,3,4}58 s2 = {1,2,3,4,5,6,}59 #超集 谁是谁的父集</p>
<p>60 print(s2.issuperset(s)) #s2是s的父集</p>
<p>61 print(s2 &gt;=s)62 #输出：</p>
<p>63 True64 True65</p>
<p>66 #子集</p>
<p>67 print(s.issubset(s2)) #s是s2的子集</p>
<p>68 print(s &lt;=s2)69 #输出：</p>
<p>70 True71 True72</p>
<p>73 #判断两个集合是否不相交</p>
<p>74 print(s.isdisjoint(s2))75 #输出：</p>
<p>76 False #代表两个集合是相交的</p>
<p>77</p>
<p>78 s = {1,2,3,-1,-2}79 s2 = {1,2,3,4,5,6}80 s.difference_update(s2) #求出s和s2 的差集，并把差集 覆盖给 s</p>
<p>81 print(s) #结果：{-2, -1}</p>
<p>82</p>
<p>83 s.intersection_update(s2) #求出s和s2的交集，并把交集 覆盖给 s</p>
<p>84 print(s)85 print(s2)86 #结果:</p>
<p>87 {1, 2, 3}88 {1, 2, 3, 4, 5, 6}</p>
<p>View Code</p>
<p>字符编码</p>
<p>python3</p>
<p>文件编码默认 ：utf-8</p>
<p>字符串编码：unicode</p>
<p>python2</p>
<p>文件编码默认：ascii</p>
<p>字符串编码默认：ascii</p>
<p>如果文件头声明了utf-8，那字符串的编码是utf-8</p>
<p>unicode是一个单独的类型</p>
<p>python3的内存里：全部是unicode</p>
<p>python3执行代码的过程：</p>
<p>1、解释器找到代码文件，把代码字符串按文件头定义的编码加载到内存，转成unicode</p>
<p>2、把代码字符串按照python语法规则进行解释</p>
<p>3、所有的变量字符都会以unicode编码声明</p>
<p>在python2里边，默认编码是ASCII编码，那么文件头声明是utf-8的代码，在windows中将显示乱码</p>
<p>如何在windows上显示正常呢？（windows的默认编码是gbk）</p>
<p>1、字符串以gbk格式显示</p>
<p>2、字符串以unicode编码</p>
<p>修改方法：</p>
<p>1.UTF-8 – &gt;decode解码 --&gt; Unicode</p>
<p>2.Unicode – &gt; encode编码 – &gt; GBK / UTF-8</p>
<p>ContractedBlock.gif</p>
<p>ExpandedBlockStart.gif</p>
<p>1 s=“路飞学城”</p>
<p>2 print(“decode before:”,s)3 s2=s.decode(“utf-8”)4 print(“decode after:”,s2)5 print(type(s2))6 s3=s2.encoded(“gbk”)7 print(s3)8 print(type(s3))</p>
<p>View Code</p>
<p>python中bytes类型</p>
<p>二进制的组合转换成16进制来表示就称之为bytes类型，即字节类型，它把8个二进制组成一个bytes，用16进制来表示。</p>
<p>在python2里，bytes类型和字符串是本质上时没有区分的。</p>
<p>str = bytes</p>
<p>python2 以utf-8编码的字符串，在windows上不能显示，乱码。</p>
<p>如何在python2下实现一种，写一个软件，在全球各国电脑上 可以直接看？</p>
<p>以unicode编码写软件。</p>
<p>s = you_str.decode(“utf-8”)</p>
<p>s2= u"路飞"</p>
<p>unicode类型 也算字符串</p>
<p>文件头：</p>
<p>python2：以utf-8 or gbk 编码的代码，代码内容加载到内存，并不会被转成unicode，编码依然是utf-8 或 gbk。</p>
<p>python3：以utf-8 or gbk编码的代码，代码内容加到在内存，会被自动转成unicode。</p>
<p>在python3里，bytes类型主要来存储图片、视频等二进制格式的数据</p>
<p>str = unicode</p>
<p>默认就支持了全球的语言编码</p>
<p>常见编码错误的原因有：</p>
<p>1、python解释器的默认编码</p>
<p>2、python源文件文件编码</p>
<p>3、终端使用的编码（windows/linux/os）</p>
<p>4、操作系统的语言设置<br/> 一、模块、包</p>
<p>1、什么是模块？</p>
<p>1、把相同功的函数放在一个py文件里，称为模块。</p>
<p>2、一个PY文件就称为一个模块。</p>
<p>3、模块有什么好处：</p>
<p>1、容易维护。</p>
<p>2、减少变量和函数名冲突。</p>
<p>4、模块种类：</p>
<p>1、第三方模块——别人写的模块</p>
<p>2、内置模块——编译器自带模块(如：os、sys、等)</p>
<p>3、自定义模块——自己编写的模块</p>
<p>5、模块怎么导入：</p>
<p>通过import命令导入，eg:import os(模块名)</p>
<p>2、什么是包？</p>
<p>1、把多个模块放在同一个文件夹内，这个文件夹称为包。</p>
<p>2、文件夹称为包还有一个条件——文件夹里要有__init__.py模块。</p>
<p>3、模块与包有什么区别</p>
<p>1、模块——一个py文件就称一个模块</p>
<p>2、包——一个包含有__init__.py的文件夹称为一个包；一个包里可以有多个py模块。</p>
<p>json、pickle</p>
<p>1、什么是序列化？</p>
<p>1、把内存数据转换成字符串。</p>
<p>1、把内存数据保存到硬盘。</p>
<p>2、把内存数据传输给他人(由于网络传输是通过二进制传输，所以需要进行转换)。</p>
<p>2、序列化的模块有两个，json和pickle</p>
<p>2、json、pickle有什么优点和缺点？</p>
<p>1、json——把json所支持的数据转换成字符串</p>
<p>优点：体积小、跨平台。</p>
<p>缺点：只支持int、str、list、dict、tuple等类型。</p>
<p>2、pickle——把python所支持的所有类型转换成字符串</p>
<p>优点：支持python 全部数据类型</p>
<p>缺点：只能在python平台使用，占用空间大。</p>
<p>3、json和pickle有4个方法</p>
<p>load 、loads 、dump 、dumps</p>
<p>load:通过open函数的read文件方法，把内存数据转成字符串</p>
<p>loads:把内存数据转成字符串</p>
<p>dump:通过open函数的write文件方法，把字符串转换成相应的数据类型。</p>
<p>dumps:把字符串数据转成相应的数据类型。</p>
<p>shelve</p>
<p>1、什么是shelve？</p>
<p>1、shelve是一种key,value 形式的文件序列化模块;序列化后的数据是列表形式。</p>
<p>2、底层封装了pickle模块，支持pickle模块所支持的数据类型。</p>
<p>3、可以进行多次反序列化操作。</p>
<p>hashlib</p>
<p>1、什么是hashlib？</p>
<p>hashlib 模块——也称‘哈希’模块。</p>
<p>通过哈希算法，可以将一组不定长度的数据，生成一组固定长度的数据散列。</p>
<p>特点：</p>
<p>1、固定性——输入一串不定长度的数据，生成固定长度的数字散列。</p>
<p>2、唯一性——不同的输入所得出的数据不一样。</p>
<p>2、md5</p>
<p>输入一串不定长度的数据，生成128位固定长度的数据。</p>
<p>特点：</p>
<p>1、数字指纹——输入一串不定长度的数据，生成128位固定长度的数据(数字指纹)。</p>
<p>2、运算简单——通过简单的运算就可以得出。</p>
<p>3、放篡改——改动很少，得出的值都会不一样。</p>
<p>4、强碰撞——已知MD5值，想找到相同的MD5值很难。</p>
<p>函数</p>
<p>1、什么是函数？</p>
<p>把代码的集合通过函数名进行封装，调用时只需要调用其函数名即可。</p>
<p>有什么好处：</p>
<p>1、可扩展</p>
<p>2、减少重复代码</p>
<p>3、容易维护</p>
<p>2、函数的参数？</p>
<p>函数可以带参数：</p>
<p>形参：</p>
<p>1、在函数定义是指定。</p>
<p>2、函数调用时分配内存空间，函数运行结束，释放内存空间。</p>
<p>实参：</p>
<p>1、形式可以是常量、变量、表达式、函数等形式。</p>
<p>2、无论是何种形式，都必须要有明确的值，以便把数据传递给形参。</p>
<p>默认参数：</p>
<p>1、函数定义时可以指定默认参数(eg: def func(a,b=1))</p>
<p>2、传参时指定了默认参数，就使用传参时的值，没有指定，则使用默认参数的值。</p>
<p>关键参数：</p>
<p>1、函数传参时需按顺序传参，如果不按顺序传参可以使用关键参数传参。</p>
<p>非固定参数：</p>
<p>1、当不确定参数的数量时可以使用非固定参数。</p>
<p>2、非固定参数有两种：1.*args——(传入的参数以元组表示)。2.**kwargs——(传入的阐述用字典表示)</p>
<p>3、函数的返回值</p>
<p>1、函数可以把运算的结果返回。</p>
<p>2、函数可以有返回值，也可以没有返回值。</p>
<p>有返回值——通过return返回。</p>
<p>没有返回值——返回值为None</p>
<p>3、函数遇到return，代表函数运行结束。</p>
<p>4、函数的种类</p>
<p>嵌套函数——一个函数包含了另一个函数。</p>
<p>高阶函数——一个函数的参数引用了另一个函数，一个函数的返回值是另一个函数。</p>
<p>匿名函数——不用显式指定函数名的函数(lambrda)，常和map和filter配合使用。</p>
<p>递归函数</p>
<p>1、函数内部引用了函数自身</p>
<p>2、函数里有一个明确的结束条件。</p>
<p>递归函数的特性：</p>
<p>1、有一个明确的结束条件</p>
<p>2、每次递归的规模都应有所减少</p>
<p>3、递归函数的效率不高。</p>
<p>作用域</p>
<p>1、名称空间</p>
<p>名称空间就是存放变量名和变量值(eg:x=1)绑定关系的地方。</p>
<p>1、名称空间种类：</p>
<p>local：函数内部，包括形参和局部变量。</p>
<p>global：函数所在模块的名字空间。</p>
<p>buildin：内置函数的名字空间。</p>
<p>2、变量名的作用域范围的不同，是由这个变量名所在的名称空间所决定的。</p>
<p>全局范围：全局存活，全局有效。</p>
<p>局部范围：局部存活，局部有效。</p>
<p>2、作用域查找顺序</p>
<p>作用域查找顺序：</p>
<p>local——》enclosing function——》global——》builtin</p>
<p>local：函数内部，包括形参、局部参数。</p>
<p>enclosing function:内嵌函数。</p>
<p>global:函数所在模块。</p>
<p>builtin:内置函数。</p>
<p>闭包</p>
<p>1、什么是闭包</p>
<p>1、一个嵌套函数，分别有内函数，外函数。</p>
<p>2、内函数使用了外函数的变量。</p>
<p>3、外函数返回了内函数的应用地址。</p>
<p>4、那么这个嵌套函数就称为闭包。</p>
<p>2、闭包有什么意义</p>
<p>1、闭包返回的对象不仅仅是一个对象，而且还返回了这个函数的外层包裹的作用域。</p>
<p>2、无论这个函数在何处被调用，都优先使用其外层作用域。</p>
<p>装饰器</p>
<p>1、什么是装饰器</p>
<p>1、装饰器本质上就是一个闭包函数。</p>
<p>2、装饰器的作用是，在不改变原有函数的调用方式下，增加代码的功能。</p>
<blockquote>
<p>结束语 🥇🥇🥇<br/> 推荐一款模拟面试、Python刷题神器网站<a href="https://www.nowcoder.com/link/pc_csdncpt_bcid_python">点击链接注册即可 </a><br/> 1、算法篇（398题）：面试必刷100题、算法入门、面试高频榜单<br/> 2、SQL篇（82题）：快速入门、SQL必知必会、SQL进阶挑战、面试真题<br/> 3、大厂笔试真题：字节跳动、美团、百度、腾讯…</p>
</blockquote>
<p>不喜勿喷，喜欢的点个赞呗！</p>
</div>
<link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css" rel="stylesheet"/>
<link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css" rel="stylesheet"/>
</div>