<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<h1 id="%E7%9B%AE%E5%BD%95"><strong>目录</strong></h1>
<p id="%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#%E5%89%8D%E8%A8%80">前言</a></p>
<p id="%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%C2%A0%C2%A0-toc" style="margin-left:0px;"><a href="#%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%C2%A0%C2%A0">一、环境配置  </a></p>
<p id="1.%E5%AE%89%E8%A3%85ROS%C2%A0-toc" style="margin-left:40px;"><a href="#1.%E5%AE%89%E8%A3%85ROS%C2%A0">1.安装ROS </a></p>
<p id="%E6%91%84%E5%83%8F%E5%A4%B4%E8%B0%83%E7%94%A8-toc" style="margin-left:40px;"><a href="#%E6%91%84%E5%83%8F%E5%A4%B4%E8%B0%83%E7%94%A8">2.摄像头调用</a></p>
<p id="%E5%AF%BC%E5%85%A5OpenCV-toc" style="margin-left:40px;"><a href="#%E5%AF%BC%E5%85%A5OpenCV">3.导入OpenCV</a></p>
<p id="%E4%BA%8C%E3%80%81%E5%88%9B%E5%BB%BA%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4%E5%92%8C%E5%8A%9F%E8%83%BD%E5%8C%85-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E5%88%9B%E5%BB%BA%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4%E5%92%8C%E5%8A%9F%E8%83%BD%E5%8C%85">二、创建工作空间和功能包</a></p>
<p id="1.%E5%88%9B%E5%BB%BA%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4-toc" style="margin-left:40px;"><a href="#1.%E5%88%9B%E5%BB%BA%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4">1.创建工作空间</a></p>
<p id="2.%E5%88%9B%E5%BB%BA%E5%8A%9F%E8%83%BD%E5%8C%85-toc" style="margin-left:40px;"><a href="#2.%E5%88%9B%E5%BB%BA%E5%8A%9F%E8%83%BD%E5%8C%85">2.创建功能包</a></p>
<p id="%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E6%A3%80%E6%B5%8B-toc" style="margin-left:0px;"><a href="#%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E6%A3%80%E6%B5%8B">三、人脸识别检测相关代码</a></p>
<p id="1.python%E6%96%87%E4%BB%B6-toc" style="margin-left:40px;"><a href="#1.python%E6%96%87%E4%BB%B6">1.python文件</a></p>
<p id="2.lanuch%E6%96%87%E4%BB%B6%C2%A0-toc" style="margin-left:40px;"><a href="#2.lanuch%E6%96%87%E4%BB%B6%C2%A0">2.lanuch文件 </a></p>
<p id="CvBridge-toc" style="margin-left:40px;"><a href="#CvBridge">3.CvBridge</a></p>
<p id="%E5%BC%80%E5%A7%8B%E6%89%A7%E8%A1%8C-toc" style="margin-left:0px;"><a href="#%E5%BC%80%E5%A7%8B%E6%89%A7%E8%A1%8C">四、代码实测</a></p>
<p id="1.%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%E8%A1%8C%C2%A0-toc" style="margin-left:40px;"><a href="#1.%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%E8%A1%8C%C2%A0">1.执行命令行 </a></p>
<p id="%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E6%95%88%E6%9E%9C-toc" style="margin-left:40px;"><a href="#%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E6%95%88%E6%9E%9C">2.人脸识别效果</a></p>
<p id="%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3-toc" style="margin-left:0px;"><a href="#%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3">五、报错解决</a></p>
<p id="%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93%C2%A0-toc" style="margin-left:0px;"><a href="#%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93%C2%A0">六、总结</a></p>
<hr/>
<h1 id="%E5%89%8D%E8%A8%80">前言</h1>
<p>本文主要学习 <span style="color:#be191c;"><strong>ROS机器人操作系统 </strong></span>，在<span style="color:#000000;">ROS</span><span style="color:#000000;">系统里调用 </span><span style="color:#be191c;"><strong>OpenCV库 </strong></span><span style="color:#000000;">实现人脸识别任务</span></p>
<h1 id="%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%C2%A0%C2%A0">一、环境配置  </h1>
<h2 id="1.%E5%AE%89%E8%A3%85ROS%C2%A0">1.安装ROS </h2>
<pre><code>sudo apt-get install ros-kinetic-desktop-full
</code></pre>
<p>如果ROS还不懂如何安装的，可以看下这一篇：<a class="has-card" href="https://blog.csdn.net/m0_61745661/article/details/124534353" title="【Linux学习】虚拟机VMware 安装ROS 一条龙教程+部分报错解决_猿力猪的博客-CSDN博客_ros vmware"><span class="link-card-box"><span class="link-title">【Linux学习】虚拟机VMware 安装ROS 一条龙教程+部分报错解决_猿力猪的博客-CSDN博客_ros vmware</span><span class="link-desc">Linux下载安装ROS，一条龙详解！希望对您有所帮助！</span><span class="link-link"><img alt="" class="link-link-icon" src="https://g.csdnimg.cn/static/logo/favicon32.ico"/>https://blog.csdn.net/m0_61745661/article/details/124534353</span></span></a></p>
<h2 id="%E6%91%84%E5%83%8F%E5%A4%B4%E8%B0%83%E7%94%A8">2.摄像头调用</h2>
<p>安装摄像头组件相关的包，命令行如下：</p>
<pre><code>sudo apt-get install ros-kinetic-usb-cam</code></pre>
<p>启动摄像头，命令行如下：</p>
<pre><code>roslaunch usb_cam usb_cam-test.launch</code></pre>
<p>调用摄像头成功，如下图所示：</p>
<p><img alt="" height="1074" src="https://img-blog.csdnimg.cn/f65378920e014216a7fb264f11dba8bd.gif" width="1200"/></p>
<p>摄像头的驱动发布的相关数据，如下图所示：</p>
<p><img alt="" height="549" src="image\e8ef6b36e95b4523a239d47a24ee56d9.png" width="1097"/></p>
<p>摄像头 <strong>usb_cam/image_raw</strong> 这个话题，发布的消息的具体类型，如下图所示：</p>
<p><img alt="" height="346" src="image\d03a9edc9e844c2d84c51a5b3ebba528.png" width="768"/></p>
<p>那么图像消息里面的成员变量有哪些呢？</p>
<p>打印一下就知道了！一个消息类型里面的具体成员变量，如下图所示：</p>
<p><img alt="" height="401" src="image\9efe6c7f681e420eb0f68b1366e8dd8a.png" width="731"/></p>
<blockquote>
<ul><li><span style="color:#956fe7;"><strong>Header：</strong></span>很多话题消息里面都包含的</li></ul>
<p>        <span style="color:#4da8ee;"><strong>消息头：</strong></span>包含消息序号，时间戳和绑定坐标系</p>
<p>        <strong><span style="color:#4da8ee;">消息的序号：</span></strong>表示我们这个消息发布是排第几位的，并不需要我们手动去标定，每次</p>
<p>        发布消息的时候会自动地去累加</p>
<p>        <strong><span style="color:#4da8ee;">绑定坐标系：</span></strong>表示的是我们是针对哪一个坐标系去发布的header有时候也不需要去配置</p>
<ul><li><strong><span style="color:#956fe7;">height：</span></strong>图像的纵向分辨率</li><li><span style="color:#956fe7;"><strong>width：</strong></span>图像的横向分辨率</li><li><span style="color:#956fe7;"><strong>encoding：</strong></span>图像的编码格式，包含RGB、YUV等常用格式，都是原始图像的编码格式，不涉及图像压缩编码</li><li><span style="color:#956fe7;"><strong>is_bigendian: </strong></span>图像数据的大小端存储模式</li><li><strong><span style="color:#956fe7;">step：</span></strong>一行图像数据的字节数量，作为数据的步长参数</li><li><span style="color:#956fe7;"><strong>data：</strong></span>存储图像数据的数组，大小为step×height个字节</li><li><span style="color:#956fe7;"><strong>format：</strong></span>图像的压缩编码格式（jpeg、png、bmp）</li></ul>
</blockquote>
<h2 id="%E5%AF%BC%E5%85%A5OpenCV">3.导入OpenCV</h2>
<p><img alt="" height="511" src="image\5b957a73d068413d95098d811ac93dc4.png" width="1200"/></p>
<p>在ROS当中完成OpenCV的安装，命令行如下图所示：</p>
<pre><code>sudo apt-get install ros-kinetic-vision-opencv libopencv-dev python-opencv</code></pre>
<p>安装完成 </p>
<p><img alt="" height="336" src="image\217d6252ab8f406082c88db79d94835a.png" width="1200"/></p>
<h1 id="%E4%BA%8C%E3%80%81%E5%88%9B%E5%BB%BA%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4%E5%92%8C%E5%8A%9F%E8%83%BD%E5%8C%85">二、创建工作空间和功能包</h1>
<h2 id="1.%E5%88%9B%E5%BB%BA%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4">1.创建工作空间</h2>
<pre><code>mkdir -p ~/catkin_ws/src
cd ~/catkin_ws/src
catkin_init_workspace
</code></pre>
<ul><li>创建完成工作空间后，在根目录下面，执行编译整个工作空间  </li></ul>
<pre><code>cd ~/catkin_ws/
catkin_make
</code></pre>
<ul><li>工作空间中会自动生成两个文件夹：<span style="color:#4da8ee;"><strong>devel</strong></span>，<span style="color:#4da8ee;"><strong>build</strong></span></li><li>devel文件夹中产生几个setup.*sh形成的<a href="https://so.csdn.net/so/search?q=%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F&amp;spm=1001.2101.3001.7020" title="环境变量">环境变量</a>设置脚本，使用source命令运行这些脚本文件，则工作空间中的环境变量得以生效 </li></ul>
<pre><code>source devel/setup.sh
</code></pre>
<ul><li> 将环境变量设置到<strong><span style="color:#4da8ee;">/.bashrc文件</span></strong>中</li></ul>
<pre><code>gedit ~/.bashrc
</code></pre>
<ul><li>在打开的文件，最下面粘贴以下代码即可设置环境变量 </li></ul>
<pre><code>source ~/catkin_ws/devel/setup.bash
</code></pre>
<h2 id="2.%E5%88%9B%E5%BB%BA%E5%8A%9F%E8%83%BD%E5%8C%85">2.创建功能包</h2>
<ul><li> 开始创建</li></ul>
<pre><code>cd ~/catkin_ws/src
catkin_create_pkg learning std_msgs rospy roscpp
</code></pre>
<ul><li>回到根目录，编译并设置环境变量  </li></ul>
<pre><code>cd ~/catkin_ws
catkin_make
source ~/catkin_ws/devel/setup.sh
</code></pre>
<h1 id="%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E6%A3%80%E6%B5%8B">三、人脸识别检测相关代码</h1>
<ul><li>基于 Haar 特征的级联分类器检测算法</li><li>核心内容，如下所示：</li></ul>
<blockquote>
<ul><li><span style="color:#956fe7;"><strong>灰阶色彩转换</strong></span></li><li><span style="color:#956fe7;"><strong>缩小摄像头图像</strong></span></li><li><span style="color:#956fe7;"><strong>直方图均衡化</strong></span></li><li><span style="color:#956fe7;"><strong>检测人脸</strong></span></li></ul>
</blockquote>
<h2 id="1.python%E6%96%87%E4%BB%B6">1.python文件</h2>
<p id="face_detector.py"><strong>face_detector.py</strong></p>
<pre><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-
import rospy
import cv2
import numpy as np
from sensor_msgs.msg import Image, RegionOfInterest
from cv_bridge import CvBridge, CvBridgeError

class faceDetector:
    def __init__(self):
        rospy.on_shutdown(self.cleanup);

        # 创建cv_bridge
        self.bridge = CvBridge()
        self.image_pub = rospy.Publisher("cv_bridge_image", Image, queue_size=1)

        # 获取haar特征的级联表的XML文件，文件路径在launch文件中传入
        cascade_1 = rospy.get_param("~cascade_1", "")
        cascade_2 = rospy.get_param("~cascade_2", "")

        # 使用级联表初始化haar特征检测器
        self.cascade_1 = cv2.CascadeClassifier(cascade_1)
        self.cascade_2 = cv2.CascadeClassifier(cascade_2)

        # 设置级联表的参数，优化人脸识别，可以在launch文件中重新配置
        self.haar_scaleFactor  = rospy.get_param("~haar_scaleFactor", 1.2)
        self.haar_minNeighbors = rospy.get_param("~haar_minNeighbors", 2)
        self.haar_minSize      = rospy.get_param("~haar_minSize", 40)
        self.haar_maxSize      = rospy.get_param("~haar_maxSize", 60)
        self.color = (50, 255, 50)

        # 初始化订阅rgb格式图像数据的订阅者，此处图像topic的话题名可以在launch文件中重映射
        self.image_sub = rospy.Subscriber("input_rgb_image", Image, self.image_callback, queue_size=1)

    def image_callback(self, data):
        # 使用cv_bridge将ROS的图像数据转换成OpenCV的图像格式
        try:
            cv_image = self.bridge.imgmsg_to_cv2(data, "bgr8")     
            frame = np.array(cv_image, dtype=np.uint8)
        except CvBridgeError, e:
            print e

        # 创建灰度图像
        grey_image = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)

        # 创建平衡直方图，减少光线影响
        grey_image = cv2.equalizeHist(grey_image)

        # 尝试检测人脸
        faces_result = self.detect_face(grey_image)

        # 在opencv的窗口中框出所有人脸区域
        if len(faces_result)&gt;0:
            for face in faces_result: 
                x, y, w, h = face
                cv2.rectangle(cv_image, (x, y), (x+w, y+h), self.color, 2)

        # 将识别后的图像转换成ROS消息并发布
        self.image_pub.publish(self.bridge.cv2_to_imgmsg(cv_image, "bgr8"))

    def detect_face(self, input_image):
        # 首先匹配正面人脸的模型
        if self.cascade_1:
            faces = self.cascade_1.detectMultiScale(input_image, 
                    self.haar_scaleFactor, 
                    self.haar_minNeighbors, 
                    cv2.CASCADE_SCALE_IMAGE, 
                    (self.haar_minSize, self.haar_maxSize))
                                         
        # 如果正面人脸匹配失败，那么就尝试匹配侧面人脸的模型
        if len(faces) == 0 and self.cascade_2:
            faces = self.cascade_2.detectMultiScale(input_image, 
                    self.haar_scaleFactor, 
                    self.haar_minNeighbors, 
                    cv2.CASCADE_SCALE_IMAGE, 
                    (self.haar_minSize, self.haar_maxSize))
        
        return faces

    def cleanup(self):
        print "Shutting down vision node."
        cv2.destroyAllWindows()

if __name__ == '__main__':
    try:
        # 初始化ros节点
        rospy.init_node("face_detector")
        faceDetector()
        rospy.loginfo("Face detector is started..")
        rospy.loginfo("Please subscribe the ROS image.")
        rospy.spin()
    except KeyboardInterrupt:
        print "Shutting down face detector node."
        cv2.destroyAllWindows()
</code></pre>
<h2 id="2.lanuch%E6%96%87%E4%BB%B6%C2%A0">2.lanuch文件 </h2>
<p id="usb_cam.launch"><strong>usb_cam.launch</strong></p>
<ul><li><strong>摄像头启动文件</strong></li></ul>
<pre><code class="language-python">&lt;launch&gt;

  &lt;node name="usb_cam" pkg="usb_cam" type="usb_cam_node" output="screen" &gt;
    &lt;param name="video_device" value="/dev/video0" /&gt;
    &lt;param name="image_width" value="640" /&gt;
    &lt;param name="image_height" value="480" /&gt;
    &lt;param name="pixel_format" value="yuyv" /&gt;
    &lt;param name="camera_frame_id" value="usb_cam" /&gt;
    &lt;param name="io_method" value="mmap"/&gt;
  &lt;/node&gt;

&lt;/launch&gt;
</code></pre>
<p id="face_detector.launch"><strong>face_detector.launch</strong></p>
<ul><li><strong> 人脸识别启动文件</strong></li></ul>
<pre><code>&lt;launch&gt;
    &lt;node pkg="test2" name="face_detector" type="face_detector.py" output="screen"&gt;
        &lt;remap from="input_rgb_image" to="/usb_cam/image_raw" /&gt;
        &lt;rosparam&gt;
            haar_scaleFactor: 1.2
            haar_minNeighbors: 2
            haar_minSize: 40
            haar_maxSize: 60
        &lt;/rosparam&gt;
        &lt;param name="cascade_1" value="$(find robot_vision)/data/haar_detectors/haarcascade_frontalface_alt.xml" /&gt;
        &lt;param name="cascade_2" value="$(find robot_vision)/data/haar_detectors/haarcascade_profileface.xml" /&gt;
    &lt;/node&gt;
&lt;/launch&gt;</code></pre>
<h2 id="CvBridge">3.CvBridge</h2>
<ul><li>ROS 与 OpenCV 之间的数据连接是通过 CvBridge 来实现的</li><li>ROS Image Message与 OpenCV Ipllmage 之间连接的一个桥梁 </li></ul>
<p><strong>cv_bridge_test.py </strong></p>
<pre><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

import rospy
import cv2
from cv_bridge import CvBridge, CvBridgeError
from sensor_msgs.msg import Image

class image_converter:
    def __init__(self):    
        # 创建cv_bridge，声明图像的发布者和订阅者
        self.image_pub = rospy.Publisher("cv_bridge_image", Image, queue_size=1)
        self.bridge = CvBridge()
        self.image_sub = rospy.Subscriber("/usb_cam/image_raw", Image, self.callback)

    def callback(self,data):
        # 使用cv_bridge将ROS的图像数据转换成OpenCV的图像格式
        try:
            cv_image = self.bridge.imgmsg_to_cv2(data, "bgr8")
        except CvBridgeError as e:
            print e

        # 在opencv的显示窗口中绘制一个圆，作为标记
        (rows,cols,channels) = cv_image.shape
        if cols &gt; 60 and rows &gt; 60 :
            cv2.circle(cv_image, (60, 60), 30, (0,0,255), -1)

        # 显示Opencv格式的图像
        cv2.imshow("Image window", cv_image)
        cv2.waitKey(3)

        # 再将opencv格式额数据转换成ros image格式的数据发布
        try:
            self.image_pub.publish(self.bridge.cv2_to_imgmsg(cv_image, "bgr8"))
        except CvBridgeError as e:
            print e

if __name__ == '__main__':
    try:
        # 初始化ros节点
        rospy.init_node("cv_bridge_test")
        rospy.loginfo("Starting cv_bridge_test node")
        image_converter()
        rospy.spin()
    except KeyboardInterrupt:
        print "Shutting down cv_bridge_test node."
        cv2.destroyAllWindows()</code></pre>
<h1 id="%E5%BC%80%E5%A7%8B%E6%89%A7%E8%A1%8C">四、代码实测</h1>
<h2 id="1.%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%E8%A1%8C%C2%A0">1.执行命令行 </h2>
<p>分别在三个终端下运行，命令行如下：</p>
<ul><li>启动摄像头 </li></ul>
<pre><code>roslaunch robot_vision usb_cam.launch
</code></pre>
<ul><li>启动人脸识别</li></ul>
<pre><code>roslaunch robot_vision face_detector.launch
</code></pre>
<ul><li>打开人脸识别窗口</li></ul>
<pre><code>rqt_image_view</code></pre>
<h2 id="%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E6%95%88%E6%9E%9C">2.人脸识别效果</h2>
<p>拿了C站官方送的书来进行测试，识别的效果还是相当不错的，效果如下图所示:</p>
<p><img alt="" height="1146" src="https://img-blog.csdnimg.cn/5eba82a05570498f9b25c1ca919444cd.gif" width="1200"/></p>
<p></p>
<h1 id="%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3">五、报错解决</h1>
<p><strong>报错1：E：无法定位软件包 ros-kinetic-usb-cam</strong></p>
<p><img alt="" height="195" src="image\f749ed8cf9204fc9a18d4fa4d28efa17.png" width="889"/></p>
<p><strong>解决方法： 网上下载编译安装</strong></p>
<blockquote>
<p>$ cd catkin_ws/src<br/> $ git clone https://<a href="https://so.csdn.net/so/search?q=github&amp;spm=1001.2101.3001.7020" title="github">github</a>.com/bosch-ros-pkg/usb_cam.git<br/> $ cd ~/catkin_ws<br/> $ catkin_make</p>
</blockquote>
<p><strong>成功解决： </strong></p>
<p><img alt="" height="728" src="image\3494377fdd5c41239c117a0cd4cfdfdf.png" width="1200"/></p>
<p><strong>报错2：启动摄像头报错</strong></p>
<p><img alt="" height="194" src="image\420f84d379834bf8bd2f5ac263d5744b.png" width="958"/></p>
<p><strong>解决方法：输入以下命令行，再启动摄像头</strong></p>
<pre><code>source ~/catkin_ws/devel/setup.bash</code></pre>
<p><strong>成功解决：</strong> </p>
<p><img alt="" height="992" src="image\6ca44d8aefcf47f591e75200b4432998.png" width="1130"/></p>
<p><strong>报错3：虚拟机摄像头没连接报错</strong></p>
<p><img alt="" height="1014" src="image\078c7d01f12c4cde82fc99393b6f14a6.png" width="1200"/><strong>解决方法：打开虚拟机设置，更改usb版本为3.1</strong></p>
<p><img alt="" height="1200" src="image\9a98a93aeeb148ba994c4e2357a31d3c.png" width="1200"/></p>
<p><strong>可移动设备将摄像头设置连接</strong></p>
<p><img alt="" height="714" src="image\6bacf6438e4045afb6511c65dae96ea6.png" width="1200"/></p>
<p></p>
<h1 id="%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93%C2%A0"><strong>六、总结</strong> </h1>
<blockquote>
<ul><li>在ROS操作系统中调用 OpenCV 完成人脸识别还是比较有意思的，目前图像处理和人脸识别还是比较常用到的，本文主要记录学习过程，以及遇到的相关报错问题进行记录</li><li>如何对于特定目标的检测并显示出结果？如何优化让人脸识别的更精准？目前还在朝着这个方向进行思考和探究</li></ul>
</blockquote>
<p><strong>参考：</strong><br/><a href="https://blog.csdn.net/weixin_39059031/article/details/84100948?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%2284100948%22%2C%22source%22%3A%22m0_61745661%22%7D&amp;ctrtid=LeCU0" title="ubuntu16.04下ROS操作系统学习笔记（六 ）机器视觉-摄像头标定-ROS+OpenCv-人脸识别-物体跟踪-二维码识别_小小何先生的博客-CSDN博客">ubuntu16.04下ROS操作系统学习笔记（六 ）机器视觉-摄像头标定-ROS+OpenCv-人脸识别-物体跟踪-二维码识别_小小何先生的博客-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/ck784101777/article/details/106730978?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165685515816782248571284%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=165685515816782248571284&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-106730978-null-null.142%5Ev30%5Econtrol,185%5Ev2%5Econtrol&amp;utm_term=ros+opencv+%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E8%8A%82%E7%82%B9&amp;spm=1018.2226.3001.4187" title="ROS+OpenCV 人脸识别，物体识别_JJH的创世纪的博客-CSDN博客_ros图像识别">ROS+OpenCV 人脸识别，物体识别_JJH的创世纪的博客-CSDN博客_ros图像识别</a></p>
<p><a href="https://blog.csdn.net/weixin_44773732/article/details/122788822" title="《ROS机器人开发实践》功能包编译报错问题解决&amp;&amp;摄像头数据opencv_melodic18的博客-CSDN博客">《ROS机器人开发实践》功能包编译报错问题解决&amp;&amp;摄像头数据opencv_melodic18的博客-CSDN博客</a></p>
<p><a href="http://t.zoukankan.com/haijian-p-10847457.html" title="Ubuntu 16.04 安装摄像头驱动usb_cam - 走看看">Ubuntu 16.04 安装摄像头驱动usb_cam - 走看看</a></p>
<p><a href="https://blog.csdn.net/weixin_47272122/article/details/113586698" title="E: 无法定位软件包 ros-kinetic-usb-cam_＞＞＞111的博客-CSDN博客">E: 无法定位软件包 ros-kinetic-usb-cam_＞＞＞111的博客-CSDN博客</a></p>
<p></p>
<p><span style="color:#38d8f0;"><strong><em>以上就是本文的全部内容啦！如果对您有帮助，麻烦点赞啦！收藏啦！欢迎各位评论区留言</em>！！！</strong></span></p>
<p class="img-center"><img alt="" height="296" src="https://img-blog.csdnimg.cn/651c692b7a494c6aa604d3f01263e4fd.gif" width="526"/></p>
</div>
</div>