<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<blockquote>
<p> 🔝🔝🔝🔝🔝🔝🔝🔝🔝🔝🔝🔝 </p>
<p><strong>🥰 博客首页：<strong><a href="https://blog.csdn.net/knighthood2001?type=lately" title="knighthood2001">knighthood2001</a></strong></strong></p>
<p><strong>😗 欢迎点赞👍评论🗨️</strong></p>
<p><strong>❤️ 热爱python，期待与大家一同进步成长！！❤️</strong></p>
<p><strong>👀<a href="https://www.nowcoder.com/link/pc_csdncpt_knight_python" title="给大家推荐一款很火爆的刷题、面试求职网站">给大家推荐一款很火爆的刷题、面试求职网站</a>👀</strong></p>
</blockquote>
<p id="main-toc"><strong>目录</strong></p>
<p id="%E6%9F%A5%E6%89%BE-toc" style="margin-left:40px;"><strong><a href="#%E6%9F%A5%E6%89%BE"><span style="color:#956fe7;"><span style="background-color:#fefcd8;">查找</span></span></a></strong></p>
<p id="%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-toc" style="margin-left:80px;"><strong><a href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span style="color:#faa572;"><span style="background-color:#fefcd8;">二分查找</span></span></a></strong></p>
<p id="%E7%BA%BF%E6%80%A7%E6%9F%A5%E6%89%BE-toc" style="margin-left:80px;"><strong><a href="#%E7%BA%BF%E6%80%A7%E6%9F%A5%E6%89%BE"><span style="color:#1c7331;"><span style="background-color:#fefcd8;">线性查找</span></span></a></strong></p>
<p id="%E6%8E%92%E5%BA%8F%C2%A0-toc" style="margin-left:40px;"><strong><a href="#%E6%8E%92%E5%BA%8F%C2%A0"><span style="color:#956fe7;"><span style="background-color:#fefcd8;">排序 </span></span></a></strong></p>
<p id="%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F-toc" style="margin-left:80px;"><strong><a href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span style="color:#1c7331;"><span style="background-color:#fefcd8;">插入排序</span></span></a></strong></p>
<p id="%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-toc" style="margin-left:80px;"><strong><a href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span style="color:#1c7331;"><span style="background-color:#fefcd8;">快速排序</span></span></a></strong></p>
<p id="%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F-toc" style="margin-left:80px;"><strong><a href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span style="color:#faa572;"><span style="background-color:#fefcd8;">选择排序</span></span></a></strong></p>
<p id="%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F-toc" style="margin-left:80px;"><strong><a href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span style="color:#faa572;"><span style="background-color:#fefcd8;">冒泡排序</span></span></a></strong></p>
<p id="%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F-toc" style="margin-left:80px;"><strong><a href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span style="color:#1c7331;"><span style="background-color:#fefcd8;">归并排序</span></span></a></strong></p>
<p id="%E5%A0%86%E6%8E%92%E5%BA%8F-toc" style="margin-left:80px;"><strong><a href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span style="color:#1c7331;"><span style="background-color:#fefcd8;">堆排序</span></span></a></strong></p>
<p id="%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F-toc" style="margin-left:80px;"><strong><a href="#%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F"><span style="color:#1c7331;"><span style="background-color:#fefcd8;">计数排序</span></span></a></strong></p>
<p id="%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F-toc" style="margin-left:80px;"><strong><a href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span style="color:#1c7331;"><span style="background-color:#fefcd8;">希尔排序</span></span></a></strong></p>
<p id="%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F-toc" style="margin-left:80px;"><strong><a href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span style="color:#1c7331;"><span style="background-color:#fefcd8;">拓扑排序</span></span></a></strong></p>
<p id="%E6%80%BB%E7%BB%93-toc" style="margin-left:40px;"><strong><a href="#%E6%80%BB%E7%BB%93"><span style="color:#956fe7;"><span style="background-color:#fefcd8;">总结</span></span></a></strong></p>
<hr id="hr-toc"/>
<p>        笔者最近在找一些经典算法，这时候发现牛客网中有许多，笔者根据源码并进行了一下细微的调整，现将整理好的代码及运行结果写出来，需要进行刷题的可以<a class="link-info" href="https://www.nowcoder.com/link/pc_csdncpt_knight_python" title="点此进行注册，开启刷题之旅！！">点此进行注册，开启刷题之旅！！</a></p>
<p>        当然，牛客网中有些代码所展示出来的格式不太好 ，比如print ()而不是print()、有些会在行后面加‘;’，不太符合python的写法。不过这些不是最主要的，<span style="color:#98c091;"><strong>接下来开启python查找与排序之旅吧！！ </strong></span></p>
<hr/>
<h2 id="%E6%9F%A5%E6%89%BE"><span style="color:#956fe7;"><strong>查找</strong></span></h2>
<h3 id="%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><strong>二分查找</strong></h3>
<p>        <strong>二分搜索</strong>是一种在有序数组中查找某一特定元素的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。</p>
<p style="text-align:center;"><img alt="" src="image\5f16c36c81c7425999d31ca70fcaba55.png"/></p>
<pre><code class="language-python"># 返回 x 在 arr 中的索引，如果不存在返回 -1
def binarySearch (arr, l, r, x):
    # 基本判断
    if r &gt;= l:
        mid = int(l + (r - l)/2)
        # 元素整好的中间位置
        if arr[mid] == x:
            return mid
        # 元素小于中间位置的元素，只需要再比较左边的元素
        elif arr[mid] &gt; x:
            return binarySearch(arr, l, mid-1, x)
        # 元素大于中间位置的元素，只需要再比较右边的元素
        else:
            return binarySearch(arr, mid+1, r, x)
    else:
        # 不存在
        return -1

# 测试数组
arr = [ 2, 3, 4, 10, 40]
x = int(input('请输入元素：'))
# 函数调用
result = binarySearch(arr, 0, len(arr)-1, x)

if result != -1:
    print("元素在数组中的索引为 %d" % result)
else:
    print("元素不在数组中")</code></pre>
<p><strong>        运行结果： </strong></p>
<pre><code>请输入元素：4
元素在数组中的索引为 2</code></pre>
<pre><code>请输入元素：5
元素不在数组中</code></pre>
<h3 id="%E7%BA%BF%E6%80%A7%E6%9F%A5%E6%89%BE"><strong>线性查找</strong></h3>
<p>        <strong>线性查找</strong>指按一定的顺序检查数组中每一个元素，直到找到所要寻找的特定值为止。 </p>
<pre><code class="language-python">def search(arr, n, x):
    for i in range (0, n):
        if (arr[i] == x):
            return i
    return -1

# 在数组 arr 中查找字符 D
arr = [ 'A', 'B', 'C', 'D', 'E' ]
x = input("请输入要查找的元素：")
n = len(arr)
result = search(arr, n, x)
if(result == -1):
    print("元素不在数组中")
else:
    print("元素在数组中的索引为", result)</code></pre>
<p><strong>        运行结果： </strong></p>
<pre><code>请输入要查找的元素：A
元素在数组中的索引为 0
</code></pre>
<pre><code class="language-python">请输入要查找的元素：a
元素不在数组中</code></pre>
<h2 id="%E6%8E%92%E5%BA%8F%C2%A0"><span style="color:#956fe7;"><strong>排序</strong></span> </h2>
<h3 id="%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><strong>插入排序</strong></h3>
<p>        <strong>插入排序（Insertion Sort）</strong>是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
<p style="text-align:center;"><img alt="" src="https://img-blog.csdnimg.cn/4350e9600ff448a68588e3da8177c046.gif"/></p>
<pre><code class="language-python">def insertionSort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i-1
        while j &gt;= 0 and key &lt; arr[j]:
                arr[j+1] = arr[j]
                j -= 1
        arr[j+1] = key

arr = [12, 11, 13, 5, 6, 7, 9, 9, 17]
insertionSort(arr)
print("排序后的数组:")
print(arr)
</code></pre>
<p><strong>        运行结果：  </strong></p>
<pre><code>排序后的数组:
[5, 6, 7, 9, 9, 11, 12, 13, 17]</code></pre>
<p>当然也可以这样写，更简洁</p>
<pre><code class="language-python">list1 = [12, 11, 13, 5, 6, 7, 9, 9, 17]
for i in range(len(list1)-1, 0, -1):
    for j in range(0, i):
        if list1[i] &lt; list1[j]:
            list1[i], list1[j] = list1[j], list1[i]
print(list1)</code></pre>
<h3 id="%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><strong>快速排序</strong></h3>
<p>        <strong>快速排序</strong>使用<span style="color:#956fe7;"><strong>分治法（Divide and conquer）</strong></span>策略来把一个序列（list）分为较小和较大的2个子序列，然后递归地排序两个子序列。</p>
<p><strong>步骤为：</strong></p>
<ul><li>挑选基准值：从数列中挑出一个元素，称为"基准"（pivot）;</li><li>分割：重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（与基准值相等的数可以到任何一边）。在这个分割结束之后，对基准值的排序就已经完成;</li><li>递归排序子序列：递归地将小于基准值元素的子序列和大于基准值元素的子序列排序。</li></ul>
<p>递归到最底部的判断条件是数列的大小是零或一，此时该数列显然已经有序。</p>
<p>选取基准值有数种具体方法，此选取方法对排序的时间性能有决定性影响。</p>
<p style="text-align:center;"><img alt="" src="https://img-blog.csdnimg.cn/40769194694e4a7785c055fdd2b29c89.gif"/></p>
<pre><code class="language-python">def partition(arr, low, high):
    i = (low-1)         # 最小元素索引
    pivot = arr[high]

    for j in range(low, high):
        # 当前元素小于或等于 pivot
        if arr[j] &lt;= pivot:
            i = i+1
            arr[i], arr[j] = arr[j], arr[i]

    arr[i+1], arr[high] = arr[high], arr[i+1]
    return (i+1)

# arr[] --&gt; 排序数组
# low  --&gt; 起始索引
# high  --&gt; 结束索引

# 快速排序函数
def quickSort(arr, low, high):
    if low &lt; high:
        pi = partition(arr, low, high)
        quickSort(arr, low, pi-1)
        quickSort(arr, pi+1, high)
    return arr

arr = [10, 7, 8, 9, 1, 5]
n = len(arr)

print("排序后的数组:")
print(quickSort(arr, 0, n-1))</code></pre>
<p><strong>        运行结果：  </strong> </p>
<pre><code>排序后的数组:
[1, 5, 7, 8, 9, 10]</code></pre>
<h3 id="%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><strong>选择排序</strong></h3>
<p>       <strong> 选择排序（Selection sort）</strong>是一种简单直观的排序算法。它的工作原理如下。</p>
<p>        首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<p style="text-align:center;"><img alt="" src="https://img-blog.csdnimg.cn/d374241a9ceb47e8bc8faa4e0a0cd112.gif"/></p>
<pre><code class="language-python">A = [64, 25, 12, 22, 11]
for i in range(len(A)): 
    min_idx = i
    for j in range(i+1, len(A)):
        if A[min_idx] &gt; A[j]:
            min_idx = j

    A[i], A[min_idx] = A[min_idx], A[i]

print("排序后的数组：")
print(A)</code></pre>
<p><strong>        运行结果：  </strong> </p>
<pre><code>排序后的数组：
[11, 12, 22, 25, 64]</code></pre>
<h3 id="%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><strong>冒泡排序</strong></h3>
<p>        <strong>冒泡排序（Bubble Sort）</strong>也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢"浮"到数列的顶端。<img alt="" src="https://img-blog.csdnimg.cn/a44c7f0053084058b89adefa285548a7.gif"/></p>
<pre><code class="language-python">def bubbleSort(arr):
    n = len(arr)
    # 遍历所有数组元素
    for i in range(n):
        # Last i elements are already in place
        for j in range(0, n-i-1):

            if arr[j] &gt; arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr

arr = [64, 34, 25, 12, 22, 11, 90]

print("排序后的数组:")
print(bubbleSort(arr))</code></pre>
<p><strong>        运行结果：  </strong> </p>
<pre><code>排序后的数组:
[11, 12, 22, 25, 34, 64, 90]</code></pre>
<h3 id="%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><strong>归并排序</strong></h3>
<p>        <strong>归并排序（Merge sort，或mergesort）</strong>，是创建在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。</p>
<p><span style="color:#1c7892;"><strong>分治法:</strong></span></p>
<ul><li>分割：递归地把当前序列平均分割成两半。</li><li>集成：在保持元素顺序的同时将上一步得到的子序列集成到一起（归并）。</li></ul>
<p style="text-align:center;"><img alt="" src="https://img-blog.csdnimg.cn/d79f9368647648eca7bee66c829d9875.gif"/></p>
<pre><code class="language-python">def merge(arr, l, m, r):
    n1 = m - l + 1
    n2 = r - m

    # 创建临时数组
    L = [0] * (n1)
    R = [0] * (n2)

    # 拷贝数据到临时数组 arrays L[] 和 R[]
    for i in range(0, n1):
        L[i] = arr[l + i]

    for j in range(0, n2):
        R[j] = arr[m + 1 + j]

    # 归并临时数组到 arr[l..r]
    i = 0     # 初始化第一个子数组的索引
    j = 0     # 初始化第二个子数组的索引
    k = l     # 初始归并子数组的索引

    while i &lt; n1 and j &lt; n2:
        if L[i] &lt;= R[j]:
            arr[k] = L[i]
            i += 1
        else:
            arr[k] = R[j]
            j += 1
        k += 1

    # 拷贝 L[] 的保留元素
    while i &lt; n1:
        arr[k] = L[i]
        i += 1
        k += 1

    # 拷贝 R[] 的保留元素
    while j &lt; n2:
        arr[k] = R[j]
        j += 1
        k += 1

def mergeSort(arr, l, r):
    if l &lt; r:
        m = int((l+(r-1))/2)
        mergeSort(arr, l, m)
        mergeSort(arr, m+1, r)
        merge(arr, l, m, r)
    return arr

print ("给定的数组")
arr = [12, 11, 13, 5, 6, 7, 13]
print(arr)
n = len(arr)
mergeSort(arr, 0, n-1)
print("排序后的数组")
print(arr)</code></pre>
<p><strong>        运行结果：  </strong> </p>
<pre><code>给定的数组
[12, 11, 13, 5, 6, 7, 13]
排序后的数组
[5, 6, 7, 11, 12, 13, 13]</code></pre>
<h3 id="%E5%A0%86%E6%8E%92%E5%BA%8F"><strong>堆排序</strong></h3>
<p>       <strong> 堆排序（Heapsort）</strong>是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。</p>
<p style="text-align:center;"><img alt="" src="https://img-blog.csdnimg.cn/335fd6dbe0284b85ae36096768fb8cd5.gif"/></p>
<pre><code class="language-python">def heapify(arr, n, i):
    largest = i
    l = 2 * i + 1     # left = 2*i + 1
    r = 2 * i + 2     # right = 2*i + 2

    if l &lt; n and arr[i] &lt; arr[l]:
        largest = l

    if r &lt; n and arr[largest] &lt; arr[r]:
        largest = r

    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]  # 交换

def heapSort(arr):
    n = len(arr)
    # Build a maxheap.
    for i in range(n, -1, -1):
        heapify(arr, n, i)

    # 一个个交换元素
    for i in range(n-1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]   # 交换
        heapify(arr, i, 0)
    return arr

arr = [12, 11, 13, 5, 6, 7, 13, 18]
heapSort(arr)
print("排序后的数组")
print(heapSort(arr))
</code></pre>
<p><strong>        运行结果：  </strong> </p>
<pre><code class="language-python">排序后的数组
[5, 6, 7, 12, 11, 13, 13, 18]</code></pre>
<h3 id="%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F"><strong>计数排序</strong></h3>
<p>        <strong>计数排序</strong>的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
<p style="text-align:center;"><img alt="" src="https://img-blog.csdnimg.cn/7cb600d83e03429eae3738a677de240f.gif"/></p>
<p></p>
<pre><code class="language-python">def countSort(arr):

    output = [0 for i in range(256)]

    count = [0 for i in range(256)]

    ans = ["" for _ in arr]

    for i in arr:
        count[ord(i)] += 1

    for i in range(256):
        count[i] += count[i-1] 

    for i in range(len(arr)):
        output[count[ord(arr[i])]-1] = arr[i]
        count[ord(arr[i])] -= 1

    for i in range(len(arr)):
        ans[i] = output[i]
    return ans

arr = "wwwnowcodercom"
ans = countSort(arr)
print("字符数组排序 %s" %("".join(ans)))</code></pre>
<p><strong>        运行结果：  </strong> </p>
<pre><code>字符数组排序 ccdemnooorwwww</code></pre>
<h3 id="%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><strong>希尔排序</strong></h3>
<p>        <strong>希尔排序</strong>，也称<strong>递减增量排序算法</strong>，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。</p>
<p>        希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录"基本有序"时，再对全体记录进行依次直接插入排序。</p>
<p style="text-align:center;"><img alt="" src="https://img-blog.csdnimg.cn/f3ad32daf88840ef85fadb04d9049b1e.gif"/></p>
<pre><code class="language-python">def shellSort(arr):
    n = len(arr)
    gap = int(n/2)

    while gap &gt; 0:
        for i in range(gap, n):
            temp = arr[i]
            j = i
            while j &gt;= gap and arr[j-gap] &gt; temp:
                arr[j] = arr[j-gap]
                j -= gap
            arr[j] = temp
        gap = int(gap/2)
    return arr

arr = [12, 34, 54, 2, 3, 2, 5]

print("排序前:")
print(arr)
print("排序后:")
print(shellSort(arr))</code></pre>
<p><strong>        运行结果：  </strong> </p>
<pre><code>排序前:
[12, 34, 54, 2, 3, 2, 5]
排序后:
[2, 2, 3, 5, 12, 34, 54]
</code></pre>
<h3 id="%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><strong>拓扑排序</strong></h3>
<p>        对一个有向无环图(Directed Acyclic Graph简称DAG)G进行拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若边(u,v)∈E(G)，则u在线性序列中出现在v之前。通常，这样的线性序列称为满足拓扑次序(Topological Order)的序列，简称拓扑序列。简单的说，由某个集合上的一个偏序得到该集合上的一个全序，这个操作称之为拓扑排序。</p>
<p>        在图论中，由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序（英语：Topological sorting）：</p>
<ul><li>每个顶点出现且只出现一次；</li><li>若A在序列中排在B的前面，则在图中不存在从B到A的路径。</li></ul>
<p class="img-center"><img alt="" height="374" src="image\5010fb54f87a42f4b67fe1c978986a12.png" width="485"/></p>
<pre><code class="language-python">from collections import defaultdict

class Graph:
    def __init__(self, vertices):
        self.graph = defaultdict(list)
        self.V = vertices

    def addEdge(self, u, v):
        self.graph[u].append(v)

    def topologicalSortUtil(self, v, visited, stack):

        visited[v] = True

        for i in self.graph[v]:
            if visited[i] == False:
                self.topologicalSortUtil(i, visited, stack)

        stack.insert(0,v)

    def topologicalSort(self):
        visited = [False]*self.V
        stack = []

        for i in range(self.V):
            if visited[i] == False:
                self.topologicalSortUtil(i, visited, stack)

        print(stack)

g= Graph(6)
g.addEdge(5, 2)
g.addEdge(5, 0)
g.addEdge(4, 0)
g.addEdge(4, 1)
g.addEdge(2, 3)
g.addEdge(3, 1)

print("拓扑排序结果：")
g.topologicalSort()</code></pre>
<p><strong>        运行结果：  </strong> </p>
<pre><code>拓扑排序结果：
[5, 4, 2, 3, 1, 0]
</code></pre>
<h2 id="%E6%80%BB%E7%BB%93"><strong>总结</strong></h2>
<p>        以上全部内容全部来自<a class="link-info" href="https://www.nowcoder.com/link/pc_csdncpt_knight_python" title="牛客网">牛客网</a>，以上很多代码笔者更改过，并且全部检验过，可以运行且能得出目标结果，使得结果更加贴近我们平时所需，以上有些排序比较重要与热门，比如vb中也会学到的二分查找、选择排序、冒泡排序，以上代码如有错误，请指正。</p>
<p></p>
<p></p>
</div>
</div>