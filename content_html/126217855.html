<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="markdown_views prism-atom-one-dark" id="content_views">
<svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
<path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
</svg>
<h1><a id="___C_0"></a>🧑‍💻第一章 初识C++🧑‍💻</h1>
<p></p>
<div class="toc">
<h3>文章目录</h3>
<ul><li><a href="#___C_0">🧑‍💻第一章 初识C++🧑‍💻</a></li><li><a href="#_7">前言</a></li><li><a href="#C_18">一、C++简介</a></li><li><ul><li><a href="#1_C_19">1. 什么是C++？</a></li><li><a href="#2_C_27">2. C++有多重要呢？</a></li></ul>
</li><li><a href="#_48">二、关键字</a></li><li><a href="#_53">三、命名空间</a></li><li><ul><li><a href="#1__57">1. 命名空间定义</a></li><li><a href="#2__108">2. 命名空间使用</a></li></ul>
</li><li><a href="#_147">四、输入和输出</a></li><li><a href="#_171">五、缺省参数</a></li><li><a href="#_242">六、函数重载</a></li><li><ul><li><a href="#1__243">1. 概念</a></li><li><a href="#2__C_317">2. 为什么C++支持函数重载？</a></li></ul>
</li><li><a href="#_331">七、引用</a></li><li><ul><li><a href="#1___333">1. 引用概念</a></li><li><a href="#2___344">2. 引用特点</a></li><li><a href="#3___364">3. 使用场景</a></li><li><a href="#3___413">3. 引用和指针的区别</a></li></ul>
</li><li><a href="#_433">八、内联函数</a></li><li><a href="#autoC11_456">九、auto关键字(C++11)</a></li><li><a href="#forC11_468">十、基于范围的for循环(C++11)</a></li><li><a href="#_nullptrC11_490">十一、 指针空值nullptr(C++11)</a></li><li><a href="#_503">总结</a></li></ul>
</div>
<p></p>
<h1><a id="_7"></a>前言</h1>
<p>从本章开始，博主将持续更新C++学习经验分享，希望对看到这篇文章的你有所帮助。</p>
<p>C++是在C的基础之上，容纳进去了面向对象编程思想，并增加了许多有用的库，以及编程范式等。熟悉C语言之后，对C++学习有一定的帮助。</p>
<p>本章节主要目标：<strong>补充C语言语法的不足，以及C++是如何对C语言设计不合理的地方进行优化的</strong></p>
<hr/>
<h1><a id="C_18"></a>一、C++简介</h1>
<h2><a id="1_C_19"></a>1. 什么是C++？</h2>
<p>👇<br/> 1979年，贝尔实验室的本贾尼等人试图分析unix内核的时候，试图将内核模块化，于是在C语言的基础上进行扩展，<strong>增加了类的机制</strong>，完成了一个可以运行的预处理程序，称之为<strong>C with classes</strong>。</p>
<p>1982年，<strong>Bjarne Stroustrup</strong> 博士<strong>在C语言的基础上引入并扩充了面向对象的概念</strong>，发明了一种新的程序语言。为了表达该语言与C语言的渊源关系，<strong>命名为C++</strong>。因此：<strong>C++是基于C语言而产生的</strong>，它既可以进行C语言的过程化程序设计，又可以进行<strong>以抽象数据类型为特点的基于对象的程序设计，还可以进行面向对象的程序设计。</strong></p>
<p>语言的发展就像是练功打怪升级一样，也是逐步递进，由浅入深的过程。C++还在不断的向后发展。但是：现在公司主流使用还是<strong>C++98和C++11</strong>，所有大家不用追求最新，重点将C++98和C++11掌握好</p>
<h2><a id="2_C_27"></a>2. C++有多重要呢？</h2>
<p><strong>1、语言的使用广泛度：</strong></p>
<p><img alt="" src="image\953ad0d13ced4af486eb64e2ec944091.png"/><br/> 👆<br/> TIOBE - 2022年7月编程语言流行趋势排行榜 TOP榜单，从中可以看出，C/C++几乎一致稳居前5，不仅这个月如此，这三十年一直都在前五名之列。</p>
<p><strong>2、在工作领域</strong></p>
<ul><li>操作系统以及大型系统软件开发</li><li>服务器端开发</li><li>游戏开发</li><li>嵌入式和物联网领域</li><li>数字图像处理</li><li>人工智能</li><li>分布式应用</li></ul>
<p>除了上述领域外，在：科学计算、浏览器、流媒体开发、网络软件等都是C++比较适合的场景，作为一名老牌语言的常青树，C++都存在很大的价值。</p>
<h1><a id="_48"></a>二、关键字</h1>
<pre><code>C语言32个关键字，C++(98)总计63个关键字，C++(11)总计73个关键字
</code></pre>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/ca49a8b32fca4b359b79524fc74620f1.png"/><br/> 对于这里，不详细讲述，后面用到会解释。</p>
<h1><a id="_53"></a>三、命名空间</h1>
<p>👇在我们写C语言程序的时候，有时候会碰到这样的情况。<br/> <img alt="" src="image\f159ac1ba2d14c14a42cea049d2ccdda.png"/><br/> 发生这种情况的原因是rand即是函数，又是变量名，C语言没办法解决类似这样的命名冲突问题，所以C++提出了namespace来解决。所以说，<strong>使用命名空间的目的是对标识符的名称进行本地化，以避免命名冲突。</strong></p>
<h2><a id="1__57"></a>1. 命名空间定义</h2>
<blockquote>
<p>定义命名空间，需要使用到 <strong>namespace 关键字</strong>，后面跟命名空间的名字，然后接一对 { }即可，<strong>{ }中即为命名空间的成员</strong>。一个命名空间就<strong>定义了一个新的作用域</strong>，命名空间中的所有内容都<strong>局限</strong>于该命名空间中。</p>
</blockquote>
<p><strong>（1）命名空间中可以定义变量/函数/类型</strong></p>
<pre><code class="prism language-cpp"><span class="token keyword">namespace</span> Jared
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> rand <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> 					<span class="token comment">//命名空间中可以定义变量</span>
	<span class="token keyword">int</span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span>	<span class="token comment">//命名空间中可以定义函数		</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> left <span class="token operator">+</span> right<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">struct</span> <span class="token class-name">Node</span>						<span class="token comment">//命名空间中可以定义类型/结构体</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">struct</span> <span class="token class-name">Node</span><span class="token operator">*</span> next<span class="token punctuation">;</span>
		<span class="token keyword">int</span> val<span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> rand<span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">//rand默认是去全局去找，找到是函数指针。</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> Jared<span class="token double-colon punctuation">::</span>rand<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//指定去Jared域去找，找到是变量rand</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token class-name">Jared</span><span class="token double-colon punctuation">::</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">//调用Jared域中的Add函数，打印3</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p><strong>（2）命名空间可以嵌套</strong></p>
<pre><code class="prism language-cpp"><span class="token keyword">namespace</span> A
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">namespace</span> B
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">int</span> c<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> A<span class="token double-colon punctuation">::</span>B<span class="token double-colon punctuation">::</span>c <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">//打印1</span>
<span class="token punctuation">}</span>
</code></pre>
<p><strong>（3）同一个工程中允许存在多个相同名称的命名空间,编译器最后会合成同一个命名空间中。</strong></p>
<blockquote>
<p>🚨一个工程中的Test.h和Test.cpp和main.cpp中三个A命名空间会被合并成一个命名空间，这样会方便团队协作。</p>
</blockquote>
<h2><a id="2__108"></a>2. 命名空间使用</h2>
<p><strong>（1）加命名空间名称及作用域限定符</strong></p>
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> Jared<span class="token double-colon punctuation">::</span>rand<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p><strong>（2）使用using将命名空间中某个成员引入</strong></p>
<pre><code class="prism language-cpp"><span class="token keyword">using</span> Jared<span class="token double-colon punctuation">::</span>rand<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> rand<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p><strong>（3）使用using namespace 命名空间名称 引入</strong></p>
<pre><code class="prism language-cpp"><span class="token keyword">using</span> namespce Jared<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> rand<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//先去全局域去找，如果没有找到就去展开的Jared域去找</span>
	<span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>🚨看起来虽然方便了，using namespace std展开，标准库就全部暴露出来了，如果我们定义跟库重名的类型/对象/函数，就存在冲突问题。所以规范的工程项目中是不推荐这种方式的，日常练习可以使用。建议在项目开发中使用，像std::cout这样使用时指定命名空间 + using std::cout展开常用的库对象/类型等方式。</p>
</blockquote>
<h1><a id="_147"></a>四、输入和输出</h1>
<p>🎈使用C++问候世界，打印Hello world</p>
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>
<span class="token comment">// std是C++标准库的命名空间名，C++将标准库的定义实现都放到这个命名空间中</span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	cout<span class="token operator">&lt;&lt;</span><span class="token string">"Hello world!!!"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>🚨</p>
<blockquote>
<p>cout是ostream类型的全局对象， cin是istream类型的全局变量(这里再类和对象会详细说明)。使用cout标准输出对象(控制台)和cin标准输入对象(键盘)时，必须包含&lt; iostream &gt;头文件。endl是特殊的C++符号，表示换行输出,相当于"\n" 也包含在包含&lt; iostream &gt;头文件中。</p>
</blockquote>
<blockquote>
<p>std是C++标准库的命名空间名，C++将标准库的定义实现都放到这个命名空间中。 &lt;&lt;是流插入运算符，&gt;&gt;是流提取运算符。涉及运算符重载等知识(后面也会细说）。</p>
</blockquote>
<blockquote>
<p>使用C++输入输出更方便，不需要像printf/scanf输入输出时那样，需要手动控制格式。C++的输入输出可以自动识别变量类型。旧编译器(vc 6.0)中还支持&lt;iostream.h&gt;格式，后续编译器已不支持，因此推荐使用+std的方式</p>
</blockquote>
<pre><code class="prism language-cpp"><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">11</span><span class="token punctuation">;</span> <span class="token keyword">double</span> d<span class="token operator">=</span><span class="token number">11.11</span><span class="token punctuation">;</span>
cout<span class="token operator">&lt;&lt;</span>i<span class="token operator">&lt;&lt;</span>d<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token comment">//自动识别类型（原理：函数重占+运算符重载）</span>
</code></pre>
<h1><a id="_171"></a>五、缺省参数</h1>
<p>缺省参数是声明或定义函数时，为函数的参数指定一个缺省值。可以认为缺省参数本质上就是一个<strong>备胎</strong>。</p>
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">Func</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">Func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 没有传参时，使用参数的默认值，输出10</span>
	<span class="token function">Func</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 传参时，使用指定的实参，输出5</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>👀<strong>分类：</strong><br/> <strong>（1）全缺省参数</strong></p>
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">Func</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
<span class="token comment">///</span>
<span class="token punctuation">}</span>
</code></pre>
<p>传参只能从左向右开始，Func(10，20）只能是传给a和b。<br/> 错误示范：Func（，1，）这个在语法上是不被允许的。<br/> <strong>（2）半缺省参数</strong></p>
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">Func</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
<span class="token comment">///</span>
<span class="token punctuation">}</span>
</code></pre>
<p>1.必须从右往左连续缺省，不能间隔 错误示范： Func(int a=10, int b = , int c = 20)<br/> 2.调用的时候，因为没有全缺省所以不能传空参数，Func( )，全缺省则可以。</p>
<p>🚨</p>
<ul><li>缺省参数不能再函数声明和定义中同时出现，一般在函数声明的时候给缺省参数。</li><li>缺省值必须是常量或者全局变量</li></ul>
<p>看到这里你可能会问缺省参数有什么用❓<br/> 举个列子：</p>
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Stack</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">;</span>
	<span class="token keyword">int</span> size<span class="token punctuation">;</span>
	<span class="token keyword">int</span> capacity<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">StackInit</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Stack</span><span class="token operator">*</span> ps<span class="token punctuation">,</span> <span class="token keyword">int</span> InitCapacity <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	ps<span class="token operator">-&gt;</span>a <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> InitCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
	ps<span class="token operator">-&gt;</span>size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	ps<span class="token operator">-&gt;</span>capacity <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Stack st1<span class="token punctuation">;</span>
	<span class="token function">StackInit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st1<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	Stack st2<span class="token punctuation">;</span>
	<span class="token function">StackInit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st2<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>当我们用C语言写栈这个数据结构的时候，在初始化栈函数时给初始化容量一个缺省值4。在st1中，假设我知道栈里至少要存100个数据,我们直接传100即可。但时像st2这种情况，我们不知道栈里可以存多少个数据，我们不传，默认会开辟4个整数大小的空间，其他人使用的时候也会更加方便。<br/> 所以：<strong>缺省参数的作用就是使我们函数调用的更加灵活。</strong></p>
<h1><a id="_242"></a>六、函数重载</h1>
<h2><a id="1__243"></a>1. 概念</h2>
<p>在汉语中经常会出现<strong>一词多义</strong>的现象，比如包袱：可以指用布包起来的包。如，“把你的包袱拿好。”/也可以指某种负担。如。“你不要有思想包袱。”，人们可以通过上下文来判断该词的意思。在C++中也有类似的用法，就是函数重载。</p>
<blockquote>
<p>定义：函数重载：是函数的一种特殊情况，C++允许在<strong>同一作用域</strong>中声明几个功能类似的同名函数，这些同名函数的<strong>形参列表(参数个数 或 类型 或 类型顺序)不同</strong>，常用来处理实现功能类似数据类型不同的问题。</p>
</blockquote>
<p>例如：</p>
<pre><code class="prism language-cpp"><span class="token comment">// 1、参数类型不同</span>
<span class="token keyword">int</span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>	
	<span class="token keyword">return</span> left <span class="token operator">+</span> right<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">double</span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">double</span> left<span class="token punctuation">,</span> <span class="token keyword">double</span> right<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> left <span class="token operator">+</span> right<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 2、参数个数不同</span>
<span class="token keyword">void</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A(int a)"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 3、参数类型顺序不同</span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">char</span> b<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"f(int a,char b)"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">char</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> a<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"f(char b, int a)"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>👆<br/> 以上这些函数两两一组构成函数重载，分别对应参数类型不同、参数个数不同、参数类型顺序不同的情况。我们在使用重载的函数时候，也要根据形参的区别输入对应的实参。</p>
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>	
	<span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   
	<span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">10.1</span><span class="token punctuation">,</span> <span class="token number">20.2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">A</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">f</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token char">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">f</span><span class="token punctuation">(</span><span class="token char">'a'</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>🚨<br/> 下面这种情况时不构成函数重载的，返回值不同的时候编译器无法区分到底调用哪个函数</p>
<pre><code class="prism language-cpp"><span class="token keyword">short</span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> left <span class="token operator">+</span> right<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span>  right<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> left <span class="token operator">+</span> right<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>这种情况也不构成重载，虽然两个函数的参数是缺省值和非缺省值，但是依旧不影响修饰出来的函数名，所以不能构成函数重载。</p>
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">Func</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span><span class="token comment">//}</span>
<span class="token keyword">void</span> <span class="token function">Func</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span><span class="token comment">//}</span>
</code></pre>
<h2><a id="2__C_317"></a>2. 为什么C++支持函数重载？</h2>
<p>为什么C++支持函数重载，而C语言不支持函数重载呢？<br/> 首先来回顾一下C/C++程序运行起来要经历的几个阶段：<br/> 我们新建一个工程，里面包含 fun.h fun.c main.c 三个文件<br/> <strong>预处理</strong>：头文件展开、宏替换、条件编译、去掉注释 。在上述工作完成后生成fun.i 和main.i文件（fun.h文件在另外两个文件里面被展开）<br/> <strong>编译：</strong> 语法检查（语法分析、语义分析、词法分析）、符号汇总、生成汇编代码。在上述工作完成后生成fun.s 和main.s文件。<br/> <strong>汇编：</strong> 把汇编代码转换为二进制机器码，形成符号表。在上述工作完成后生成fun.o 和main.o文件。符号表里存放定义函数的地址信息<br/> <strong>链接：</strong> 合并目标文件、段表，符号表的合并和符号表的重定位。在上述工作完成后生成在a.out 或者a.exe文件。</p>
<p>在链接阶段，.o格式的目标文件合并到一起，生成a.out文件，链接器看到a.o调用Add函数的，但是没有Add函数的地址，就会到fun.o的符号表中找A函数的地址，然后链接到一起。每个编译器都有自己的函数名修饰规则，当Add函数是我们写的重载函时候，gcc的函数修饰后名字不变，而g++的函数修饰后变成_Z+函数长度+函数名+类型首字母。也正是g++函数名修饰规则的特点，即使函数名相同，只要参数不同，在g++中还是可以区分同名函数的重载的。C语言没办法支持重载，因为同名函数没办法区分。</p>
<p>也正是因为C和C++编译器对函数名字修饰规则的不同，C++中调用C语言实现的静态库或者动态库就会出现问题，导致链接失败，在符合表中找不到对应函数的名字，这种场景下就要使用<strong>extern “C”</strong>。在函数前加extern “C”，意思是告诉编译器，将该函数按照C语言规则来编译。</p>
<h1><a id="_331"></a>七、引用</h1>
<h2><a id="1___333"></a>1. 引用概念</h2>
<blockquote>
<p><strong>引用</strong>不是新定义一个变量，而是<strong>给已存在变量取了一个别名</strong>，编译器不会为引用变量开辟内存空间，它和它引用的变量<strong>共用同一块内存空间</strong>。<br/> <strong>用法：类型&amp; 引用变量名(对象名) = 引用实体；</strong></p>
</blockquote>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/30a27f427a3d4af799bb765490a2b05e.png"/><br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/ff77bd02b7d54fc2b2326f7888c652e5.png"/><br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/c5c5f4f3e6b44a1c99c03197462bda1e.png"/></p>
<p>👆从上图中，我们可以清晰的看出，a和b共用一块内存空间，同时a的改变会影响b，b的改变也会影响a，可以说a和b是完全相同的。</p>
<h2><a id="2___344"></a>2. 引用特点</h2>
<ol><li>引用在定义时必须<strong>初始化</strong></li><li>一个变量可以有<strong>多个引用</strong></li><li>引用一旦引用一个实体，在<strong>不能</strong>引用其他实体<br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/bccab04448d64bbfb33a33490d01a2cc.png"/><br/> 🚨<br/> 在引用常量的时候，经常会出一些问题</li></ol>
<pre><code class="prism language-cpp">	<span class="token keyword">const</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
	<span class="token comment">//int&amp; ra = a;		// 错，a为常量，常量只能可读，引用后就变成了可读可写。ra引用a属于权限放大，所以不行，权限不能放大，但是可以缩小</span>
	<span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> ra <span class="token operator">=</span> a<span class="token punctuation">;</span>	<span class="token comment">//正确，改为可读不可写</span>
	<span class="token comment">// int&amp; b = 10;		// 该语句编译时会出错，10为常量</span>
	<span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>	<span class="token comment">//正确，改为可读不可写</span>
	<span class="token keyword">double</span> d <span class="token operator">=</span> <span class="token number">12.34</span><span class="token punctuation">;</span>
	<span class="token comment">//int&amp; rd = d;		// 错误，d时double类型，转换为int类型会发生隐式转换，不会改变b而会生成临时变量，临时变量具有常性</span>
	<span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> rd <span class="token operator">=</span> d<span class="token punctuation">;</span>	<span class="token comment">//正确，改为可读不可写</span>
</code></pre>
<h2><a id="3___364"></a>3. 使用场景</h2>
<ol><li>做参数——输出型参数、大对象传参提高效率</li></ol>
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> y<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> tmp <span class="token operator">=</span> x<span class="token punctuation">;</span>
	x <span class="token operator">=</span> y<span class="token punctuation">;</span>
	y <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
	<span class="token function">Swap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">//2 0</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<ol start="3"><li>做返回值——输出型返回对象(调用者可以修改返回对象)、减少拷贝，提高效率</li></ol>
<pre><code class="prism language-cpp"><span class="token keyword">int</span><span class="token operator">&amp;</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">static</span> <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	n<span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token comment">// ...</span>
	<span class="token keyword">return</span> n<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>🚨切记不要出现类似的情况，下面这种情况，main开辟栈帧调用Add函数，Add函数开辟新的栈帧,出了Add函数，系统会清理栈帧将c置成随机值，所以这种程序使用引用返回本质上是不对的（虽然编译器不一定能检查出来），结果没有保障的。</p>
<pre><code class="prism language-cpp"><span class="token keyword">int</span><span class="token operator">&amp;</span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> c <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
	<span class="token keyword">return</span> c<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span><span class="token operator">&amp;</span> ret <span class="token operator">=</span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> ret <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p><strong>结论：</strong> 出了函数作用域，返回对象就销毁了，那么一定不能用引用返回，一定要用传值返回。传值返回会调用拷贝构造生成临时对象，这个临时对象保存在寄存器中用于返回，c再被析构。</p>
<p><strong>传值、传引用效率比较：</strong><br/> 以值作为参数或者返回值类型，在传参和返回期间，函数不会直接传递实参或者将变量本身直接返回，而是传递实参或者返回变量的一份临时的拷贝，因此用值作为参数或者返回值类型，效率是非常低下的，尤其是当参数或者返回值类型非常大时，效率就更低。</p>
<h2><a id="3___413"></a>3. 引用和指针的区别</h2>
<blockquote>
<p>在语法概念上引用就是一个别名，没有独立空间，和其引用实体共用同一块空间。<br/> 在<strong>底层</strong>实现上实际是有空间的，因为引用是按照指针方式来实现的。从汇编实现的角度，引用底层跟指针的汇编代码是<strong>一样</strong>的。<br/> 其实<strong>引用只是对指针进行了简单的封装</strong>，它的底层依然是通过指针实现的，引用占用的内存和指针占用的内存长度一样，在 32 位环境下是 4 个字节，在 64 位环境下是 8 个字节，之所以不能获取引用的地址，是因为编译器进行了内部转换。</p>
</blockquote>
<p>不同点：<br/> 👇</p>
<ol><li>引用概念上定义一个变量的别名，指针存储一个变量地址。</li><li><strong>引用</strong>在定义时必须<strong>初始化</strong>，指针没有要求。</li><li><strong>引用</strong>在初始化时引用一个实体后，就<strong>不能再引用其他实体</strong>，而指针可以在任何时候指向任何一个同类型实体。</li><li><strong>没有NULL引用</strong>，但有NULL指针。</li><li><strong>在sizeof中含义不同</strong>：<strong>引用</strong>结果为<strong>引用类型的大小</strong>，但<strong>指针</strong>始终是<strong>地址空间所占字节个数</strong>(32位平台下占4个字节)</li><li>引用自加即引用的实体增加1，指针自加即指针向后偏移一个类型的大小</li><li><strong>有多级指针，但是没有多级引用。</strong></li><li>访问实体方式不同，<strong>指针需要显式解引用，引用编译器自己处理。</strong></li><li><strong>引用比指针使用起来相对更安全</strong>，指针更强大，更危险，更复杂。</li></ol>
<h1><a id="_433"></a>八、内联函数</h1>
<blockquote>
<p>以<strong>inline修饰的函数</strong>叫做内联函数，编译时C++编译器会在<strong>调用内联函数的地方展开</strong>，<strong>没有函数调用建立栈帧的开销</strong>，内联函数提升程序运行的效率。本质上是对宏函数的优化。C++中基本上不再使用宏，尽量使用const、enum、inline去替代宏。</p>
</blockquote>
<p>宏的优点：1、复用性变强 2、宏函数提高代码效率，减少栈帧建立<br/> 宏的缺点：1、复杂，可读性差 2、传参没有类型安全检查 3、不方便调试</p>
<p>宏函数:</p>
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">ADD</span><span class="token expression"><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token operator">+</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>
</code></pre>
<p>普通函数：<br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/b3d83f55822e45c09417248d18cf9fa0.png"/><br/> 内敛函数：<br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/0def10bb1db64b088069f2dfe016a016.png"/><br/> 可以看出，内敛函数没有call Add函数</p>
<p><strong>特点：</strong></p>
<ul><li>inline是一种以<strong>空间换时间</strong>的做法，如果编译器将函数当成内联函数处理，<strong>在编译阶段，会用函数体替换函数调用</strong>，缺陷：可能会使目标文件变大，优势：少了调用开销，提高程序运行效率。</li><li><strong>inline对于编译器而言只是一个建议</strong>，<strong>不同编译器关于inline实现机制可能不同</strong>，一般建议：将<strong>函数规模较小</strong>(即函数不是很长，具体没有准确的说法，取决于编译器内部实现)、<strong>不是递归、频繁调用</strong>的函数采用inline修饰，否则编译器会忽略inline特性。</li><li>inline <strong>不建议声明和定义分离</strong>，分离会导致链接错误。因为inline被展开，就没有函数地址了，链接就会找不到。</li></ul>
<h1><a id="autoC11_456"></a>九、auto关键字(C++11)</h1>
<p><strong>auto会自动推导类型</strong></p>
<pre><code class="prism language-cpp">	<span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>
	<span class="token keyword">auto</span> b<span class="token operator">=</span>a<span class="token punctuation">;</span>
</code></pre>
<ul><li>使用auto定义变量时必须对其进行<strong>初始化</strong></li><li>当在同一行声明多个变量时，这些变量必须是<strong>相同的类型。</strong><code> auto a = 1, b = 2;</code></li><li>auto不能推导的场景：</li></ul>
<ol><li>auto不能作为函数的参数 <code>void TestAuto(auto a)//错误</code></li><li>auto不能直接用来声明数组 <code> </code>auto b[] = {4，5，6};//错误``</li></ol>
<h1><a id="forC11_468"></a>十、基于范围的for循环(C++11)</h1>
<blockquote>
<p>因此C++11中引入了基于范围的for循环。for循环后的括号由冒号“ ：”分为两部分：第一部分是范围内用于迭代的变量，第二部分则表示被迭代的范围。</p>
</blockquote>
<p>范围for，自动依次取array的数据，赋值给e ，自动迭代，自动判断结束</p>
<pre><code class="prism language-cpp"><span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> e <span class="token operator">:</span> array<span class="token punctuation">)</span>
	e <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> e <span class="token operator">:</span> array<span class="token punctuation">)</span>
	cout <span class="token operator">&lt;&lt;</span> e <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span>
</code></pre>
<p>🎈与普通循环类似，可以用continue来结束本次循环，也可以用break来跳出整个循环。<br/> for循环迭代的范围必须是确定的，对于数组而言，就是数组中第一个元素和最后一个元素的范围。<br/> 错误示范：</p>
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">TestFor</span><span class="token punctuation">(</span><span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> e <span class="token operator">:</span> array<span class="token punctuation">)</span><span class="token comment">//错误</span>
	cout<span class="token operator">&lt;&lt;</span> e <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h1><a id="_nullptrC11_490"></a>十一、 指针空值nullptr(C++11)</h1>
<p>NULL实际是一个宏 <code>#define NULL 0</code><br/> NULL可能被定义为字面常量0，或者被定义为无类型指针(void*)的常量，使用空值的指针时，会遇到一些麻烦。所以C++11使用nullptr关键字代替NULL</p>
<p>🎈</p>
<ol><li>在使用nullptr表示指针空值时，不需要包含头文件，因为nullptr是C++11作为新关键字引入的。</li><li>在C++11中，sizeof(nullptr) 与 sizeof((void*)0)所占的字节数相同。</li><li>为了提高代码的健壮性，在后续表示指针空值时建议最好使用nullptr。</li></ol>
<h1><a id="_503"></a>总结</h1>
<p>以上就是C++第一章的内容，主要是对C语言设计不足做的一些优化，为后面的学习打好基础，感谢收看！🧑‍💻</p>
</div>
<link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css" rel="stylesheet"/>
<link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css" rel="stylesheet"/>
</div>