<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<h1><strong>C#抽象类</strong>：</h1>
<p>C#抽象类是特殊的类，只是不能被实例化；除此以外，具有类的其他特性；重要的是抽象类可以包括抽象方法，这是普通类所不能的。抽象方法只能声明于抽象类中，且不包含任何实现，派生类必须覆盖它们。另外，抽象类可以派生自一个抽象类，可以覆盖基类的抽象方法也可以不覆盖，如果不覆盖，则其派生类必须覆盖它们。</p>
<p><code>abstract</code> 修饰符指示被修改内容的实现已丢失或不完整。 abstract 修饰符可用于类、方法、属性、索引和事件。 在类声明中使用 <code>abstract</code> 修饰符来指示某个类仅用作其他类的基类，而不用于自行进行实例化。 标记为抽象的成员必须由派生自抽象类的非抽象类来实现。</p>
<hr/>
<h1><a id="_6"></a><br/><br/> 抽象方法：</h1>
<p>用abstract修饰的方法，称为抽象方法。</p>
<blockquote>
<p>访问修饰符  abstract  方法返回值类型  方法名(参数列表);</p>
</blockquote>
<p>例如：</p>
<blockquote>
<p>public abstract void Practice(); </p>
</blockquote>
<p> 抽象方法是一种特殊的虚方法，它只起声明作用，所以只加一个“;”号，一定不能带实现部分。</p>
<p><strong>需要注意的是，抽象方法必须定义在抽象类中。</strong></p>
<hr/>
<h1><a id="_16"></a><br/><br/> 抽象类：</h1>
<p>定义抽象类时，若使用 abstract 修饰类，将其放到 class 关键字的前面，语法形式如下：</p>
<blockquote>
<p>访问修饰符  abstract class  类名<br/> {<!-- --><br/>     //类成员<br/> }</p>
</blockquote>
<p>其中“abstract”关键字也可以放到访问修饰符的前面。<br/><br/> 在抽象类中可以定义抽象方法，也可以定义非抽象方法。<br/><br/> 通常抽象类会被其他类继承，并重写其中的抽象方法或者虚方法。</p>
<p><strong>抽象类具有以下功能：</strong> </p>
<ul><li> <p>抽象类不能实例化。</p> </li><li> <p>抽象类可能包含抽象方法和访问器。</p> </li><li> <p>无法使用 <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/sealed" title="sealed">sealed</a> 修饰符来修改抽象类，因为两个修饰符的含义相反。 <code>sealed</code> 修饰符阻止类被继承，而 <code>abstract</code> 修饰符要求类被继承。</p> </li><li> <p>派生自抽象类的非抽象类，必须包含全部已继承的抽象方法和访问器的实际实现。</p> </li></ul>
<p>在方法或属性声明中使用 <code>abstract</code> 修饰符，以指示该方法或属性不包含实现。</p>
<p>抽象方法具有以下功能：</p>
<ul><li> <p>抽象方法是隐式的虚拟方法。</p> </li><li> <p>只有抽象类中才允许抽象方法声明。</p> </li><li> <p>由于抽象方法声明不提供实际的实现，因此没有方法主体；方法声明仅以分号结尾，且签名后没有大括号 ({ })。例如：</p> </li></ul>
<blockquote>
<p> public abstract void MyMethod();</p>
</blockquote>
<ul><li> <p>实现由方法override 提供，它是非抽象类的成员。</p> </li><li> <p>在抽象方法声明中使用 <span style="color:#fe2c24;">static  </span>或 <span style="color:#fe2c24;">virtual </span>修饰符是错误的。</p> </li></ul>
<p>除了声明和调用语法方面不同外，抽象属性的行为与抽象方法相似。</p>
<ul><li> <p>在静态属性上使用 <span style="color:#fe2c24;"><code>abstract</code> </span>修饰符是错误的。</p> </li><li> <p>通过包含使用  <span style="color:#fe2c24;">override</span> 修饰符的属性声明，可在派生类中重写抽象继承属性。</p> </li></ul>
<p>用简单的话来说抽象类的功能就是：<span style="color:#ff9900;">我是师傅（抽象类），你要是跟了（继承）师傅，你就必须得会干什么（实际实现）</span></p>
<p>例如：<span style="color:#ff9900;">老子会打人，那你也必须会打人，但你是轻轻的打，还是狠狠的打，你自己决定，但你必须得会打人。</span></p>
<p><strong><span style="color:#0d0016;">实例：</span></strong></p>
<p>类 <code>DerivedClass</code> 派生自抽象类 <code>BaseClass</code>。 抽象类包含抽象方法 <code>AbstractMethod</code>，以及两个抽象属性 <code>X</code> 和 <code>Y</code>。</p>
<pre><code class="language-cs">abstract class BaseClass   // Abstract class
{
    protected int _x = 100;
    protected int _y = 150;
    public abstract void AbstractMethod();   // Abstract method
    public abstract int X    { get; }
    public abstract int Y    { get; }
}

class DerivedClass : BaseClass
{
    public override void AbstractMethod()
    {
        _x++;
        _y++;
    }

    public override int X   // overriding property
    {
        get
        {
            return _x + 10;
        }
    }

    public override int Y   // overriding property
    {
        get
        {
            return _y + 10;
        }
    }

    static void Main()
    {
        var o = new DerivedClass();
        o.AbstractMethod();
        Console.WriteLine($"x = {o.X}, y = {o.Y}");
    }
}
// Output: x = 111, y = 161</code></pre>
<p></p>
<hr/>
<h1>总结：</h1>
<p>1，抽象类说明：</p>
<p>①.抽象类中如果有抽象方法，那么被继承的具体类一定要实现抽象类中得所有抽象方法。<br/> ②.当然，如果是抽象类B继承抽象类A，那么抽象类B可以实现基类A中的抽象方法，可以不实现A中得抽象方法</p>
<p>2，类（抽象类）的多态</p>
<blockquote>
<p>abstract class A<br/> {<!-- --><br/> public abstract void AFunction ();<br/> }<br/> abstract class B : A<br/> {<!-- --><br/> public abstract void BFunction ();<br/> }</p>
</blockquote>
<blockquote>
<p>class C : B<br/> {<!-- --><br/> public override void AFunction()<br/>   {<!-- --><br/>     Console.WriteLine ("AFucntion.");<br/>   }<br/> public override void BFunction()<br/>   {<!-- --><br/>     Console.WriteLine ("BFunction.");<br/>   }<br/> } </p>
</blockquote>
<p>3，总结：</p>
<p>1.抽象方法只作声明，而不包含实现，抽象方法旨在继承后实现，所以不能用private修饰。<br/> 2.抽象类不能被直接实例化。<br/> 3. 抽象类可以没有抽象属性和抽象方法，但是一旦有了抽象方法，就一定要把这个类声明为抽象类。<br/> 4.如果抽象类的派生类不是抽象类，那么必须重写抽象类的所有抽象方法。 </p>
</div>
</div>