<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<p id="main-toc"><strong>目录</strong></p>
<p id="1%E3%80%81%E6%A6%82%E8%BF%B0-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E6%A6%82%E8%BF%B0">1、概述</a></p>
<p id="1.1%E3%80%81%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7%E5%BA%93CrashReport%E5%92%8C%E8%B0%83%E8%AF%95%E5%99%A8-toc" style="margin-left:80px;"><a href="#1.1%E3%80%81%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7%E5%BA%93CrashReport%E5%92%8C%E8%B0%83%E8%AF%95%E5%99%A8">1.1、异常捕获库CrashRpt和调试器</a></p>
<p id="1.2%E3%80%81%E6%9C%89%E6%97%B6%E9%9C%80%E8%A6%81%E6%9F%A5%E7%9C%8B%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E5%8E%BB%E5%AE%9A%E4%BD%8D%E9%97%AE%E9%A2%98-toc" style="margin-left:80px;"><a href="#1.2%E3%80%81%E6%9C%89%E6%97%B6%E9%9C%80%E8%A6%81%E6%9F%A5%E7%9C%8B%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E5%8E%BB%E5%AE%9A%E4%BD%8D%E9%97%AE%E9%A2%98">1.2、有时需要查看汇编代码去定位问题</a></p>
<p id="2%E3%80%81CPU%E6%9E%B6%E6%9E%84-toc" style="margin-left:40px;"><a href="#2%E3%80%81CPU%E6%9E%B6%E6%9E%84">2、CPU架构</a></p>
<p id="2.1%E3%80%81%E5%BD%93%E5%89%8D%E4%B8%BB%E6%B5%81%E7%9A%84CPU%E6%9E%B6%E6%9E%84-toc" style="margin-left:80px;"><a href="#2.1%E3%80%81%E5%BD%93%E5%89%8D%E4%B8%BB%E6%B5%81%E7%9A%84CPU%E6%9E%B6%E6%9E%84">2.1、当前主流的CPU架构</a></p>
<p id="2.2%E3%80%81%E5%9B%BD%E4%BA%A7CPU%E4%BB%8B%E7%BB%8D-toc" style="margin-left:80px;"><a href="#2.2%E3%80%81%E5%9B%BD%E4%BA%A7CPU%E4%BB%8B%E7%BB%8D">2.2、国产CPU介绍</a></p>
<p id="2.3%E3%80%81X86%E6%9E%B6%E6%9E%84%E4%B8%8EARM%E6%9E%B6%E6%9E%84%E4%B8%8B%E7%9A%84%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E7%9A%84%E5%B7%AE%E5%BC%82%E7%A4%BA%E4%BE%8B%C2%A0%20%C2%A0%20%C2%A0%C2%A0-toc" style="margin-left:80px;"><a href="#2.3%E3%80%81X86%E6%9E%B6%E6%9E%84%E4%B8%8EARM%E6%9E%B6%E6%9E%84%E4%B8%8B%E7%9A%84%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E7%9A%84%E5%B7%AE%E5%BC%82%E7%A4%BA%E4%BE%8B%C2%A0%20%C2%A0%20%C2%A0%C2%A0">2.3、X86架构与ARM架构下的汇编代码的差异示例      </a></p>
<p id="3%E3%80%81%E5%B8%B8%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E5%B8%B8%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8">3、常用寄存器</a></p>
<p id="3.1%E3%80%81EAX%E5%AF%84%E5%AD%98%E5%99%A8-toc" style="margin-left:80px;"><a href="#3.1%E3%80%81EAX%E5%AF%84%E5%AD%98%E5%99%A8">3.1、EAX寄存器</a></p>
<p id="3.2%E3%80%81ECX%E5%AF%84%E5%AD%98%E5%99%A8-toc" style="margin-left:80px;"><a href="#3.2%E3%80%81ECX%E5%AF%84%E5%AD%98%E5%99%A8">3.2、ECX寄存器</a></p>
<p id="3.3%E3%80%81ESI%E5%92%8CEDI%E5%AF%84%E5%AD%98%E5%99%A8-toc" style="margin-left:80px;"><a href="#3.3%E3%80%81ESI%E5%92%8CEDI%E5%AF%84%E5%AD%98%E5%99%A8">3.3、ESI和EDI寄存器</a></p>
<p id="3.4%E3%80%81ESP%E5%92%8CEBP%E5%AF%84%E5%AD%98%E5%99%A8-toc" style="margin-left:80px;"><a href="#3.4%E3%80%81ESP%E5%92%8CEBP%E5%AF%84%E5%AD%98%E5%99%A8">3.4、ESP和EBP寄存器</a></p>
<p id="3.5%E3%80%81EIP%E5%AF%84%E5%AD%98%E5%99%A8-toc" style="margin-left:80px;"><a href="#3.5%E3%80%81EIP%E5%AF%84%E5%AD%98%E5%99%A8">3.5、EIP寄存器</a></p>
<p id="3.6%E3%80%81%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8-toc" style="margin-left:80px;"><a href="#3.6%E3%80%81%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8">3.6、段寄存器</a></p>
<p id="3.7%E3%80%81%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8EFlags-toc" style="margin-left:80px;"><a href="#3.7%E3%80%81%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8EFlags">3.7、标志寄存器EFlags</a></p>
<p id="4%E3%80%81%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4-toc" style="margin-left:40px;"><a href="#4%E3%80%81%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4">4、汇编指令</a></p>
<p id="4.1%E3%80%81%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E6%A6%82%E8%BF%B0-toc" style="margin-left:80px;"><a href="#4.1%E3%80%81%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E6%A6%82%E8%BF%B0">4.1、汇编指令概述</a></p>
<p id="4.2%E3%80%81call%E6%8C%87%E4%BB%A4%E5%92%8Cret%E6%8C%87%E4%BB%A4-toc" style="margin-left:80px;"><a href="#4.2%E3%80%81call%E6%8C%87%E4%BB%A4%E5%92%8Cret%E6%8C%87%E4%BB%A4">4.2、call指令和ret指令</a></p>
<p id="5%E3%80%81memcpy%E5%87%BD%E6%95%B0%E7%9A%84%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#5%E3%80%81memcpy%E5%87%BD%E6%95%B0%E7%9A%84%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">5、memcpy函数的汇编代码实现</a></p>
<p id="6%E3%80%81C%2B%2B%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%97%B6%E7%9A%84%E6%A0%88%E5%88%86%E5%B8%83-toc" style="margin-left:40px;"><a href="#6%E3%80%81C%2B%2B%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%97%B6%E7%9A%84%E6%A0%88%E5%88%86%E5%B8%83">6、C++函数调用时的栈分布</a></p>
<p id="6.1%E3%80%81%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%9A%84%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-toc" style="margin-left:80px;"><a href="#6.1%E3%80%81%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%9A%84%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86">6.1、函数调用的预备知识</a></p>
<p id="6.2%E3%80%81%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88%E5%88%86%E5%B8%83%E5%9B%BE-toc" style="margin-left:80px;"><a href="#6.2%E3%80%81%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88%E5%88%86%E5%B8%83%E5%9B%BE">6.2、函数调用栈分布图</a></p>
<p id="6.3%E3%80%81%E5%88%A9%E7%94%A8%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%97%B6%E7%9A%84%E6%A0%88%E5%88%86%E5%B8%83-toc" style="margin-left:80px;"><a href="#6.3%E3%80%81%E5%88%A9%E7%94%A8%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%97%B6%E7%9A%84%E6%A0%88%E5%88%86%E5%B8%83">6.3、利用汇编代码详解函数调用时的栈分布</a></p>
<p id="7%E3%80%81C%2B%2B%E8%99%9A%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%9A%84%E6%B1%87%E7%BC%96%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#7%E3%80%81C%2B%2B%E8%99%9A%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%9A%84%E6%B1%87%E7%BC%96%E5%AE%9E%E7%8E%B0">7、C++虚函数调用的汇编实现</a></p>
<p id="7.1%E3%80%81%E8%99%9A%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%A4%E6%AC%A1%E5%AF%BB%E5%9D%80-toc" style="margin-left:80px;"><a href="#7.1%E3%80%81%E8%99%9A%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%A4%E6%AC%A1%E5%AF%BB%E5%9D%80">7.1、虚函数调用过程中的两次寻址</a></p>
<p id="7.2%E3%80%81%E8%99%9A%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%9A%84%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E8%B5%B0%E8%AF%BB-toc" style="margin-left:80px;"><a href="#7.2%E3%80%81%E8%99%9A%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%9A%84%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E8%B5%B0%E8%AF%BB">7.2、虚函数调用的汇编代码走读</a></p>
<p id="8%E3%80%81IDA%E5%8F%8D%E6%B1%87%E7%BC%96%E5%B7%A5%E5%85%B7-toc" style="margin-left:40px;"><a href="#8%E3%80%81IDA%E5%8F%8D%E6%B1%87%E7%BC%96%E5%B7%A5%E5%85%B7">8、IDA反汇编工具</a></p>
<p id="9%E3%80%81%E6%80%BB%E7%BB%93-toc" style="margin-left:40px;"><a href="#9%E3%80%81%E6%80%BB%E7%BB%93">9、总结</a></p>
<hr id="hr-toc"/>
<p><a class="link-info has-card" href="https://blog.csdn.net/chenlycly/category_11397492.html" title="C++软件异常排查从入门到精通系列教程（专栏文章列表，欢迎订阅，持续更新...）"><span class="link-card-box"><span class="link-title">C++软件异常排查从入门到精通系列教程（专栏文章列表，欢迎订阅，持续更新...）</span><span class="link-link"><img alt="" class="link-link-icon" src="image\icon-default.png"/>https://blog.csdn.net/chenlycly/category_11397492.html</span></span></a>       在给开发部门的同事们做软件异常排查的技术分享时，我经常说这样一句话，我们在排查软件异常时，不仅要具备扎实的开发语言功底和业务能力，我们还要会使用多个软件工具来辅助问题的定位与排查，甚至还需要<strong>具备一定的汇编代码阅读与分析能力</strong>。软件异常最终发生在某条汇编指令上，汇编代码才能最直观、最本真地反映出问题的本质所在。</p>
<p>       作为高级语言的开发人员，大多数人对底层的汇编语言缺乏了解，很多人对汇编的认知还停留在大学教材上，很难将高级语言编写出来的代码与汇编指令对应起来。很多同事都觉得汇编比较难学，平时也很少接触到。同事们经常会问，汇编语言到底要学到什么程度，具体需要掌握哪些汇编领域的基本知识，才能很好地应对日常开发维护过程中遇到的多种软件异常问题。今天就来大概地给大家<strong>梳理一下排查C++软件异常所要了解和掌握的一些汇编方面的基本知识与要点</strong>。</p>
<h2 id="1%E3%80%81%E6%A6%82%E8%BF%B0">1、概述</h2>
<p class="img-center"><img alt="a9832a36cc5f42debfe04b3bdaa79b0d.png" height="1200" src="https://img-blog.csdnimg.cn/a9832a36cc5f42debfe04b3bdaa79b0d.png" width="685"/></p>
<p>       为了捕获到C++软件运行过程中的各种异常，我们需要给软件添加异常捕获模块以获取异常发生时的异常上下文信息并保存到dump文件中。在分析C++软件异常的过程中，可能需要去查看异常所在模块的汇编代码。</p>
<h3 id="1.1%E3%80%81%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7%E5%BA%93CrashReport%E5%92%8C%E8%B0%83%E8%AF%95%E5%99%A8">1.1、异常捕获库CrashRpt和调试器</h3>
<p class="img-center"><img alt="da0a7c198f5e4ccd9b0e16e8c03a0083.png" src="https://img-blog.csdnimg.cn/da0a7c198f5e4ccd9b0e16e8c03a0083.png"/></p>
<p>       在Windows系统中，各大厂商主要使用google的开源库CrashRpt来捕获异常，在很多知名软件的安装目录中都能看到CrashRpt库的身影。在Linux系统中，则只要稍加配置就可以让系统捕获异常并生成dump文件。</p>
<p>       拿到dump文件后，我们就可以使用调试工具打开dump文件进行分析了。在Windows系统中使用微软提供的强大调试工具Windbg，在Linux系统中则使用gcc套件中的gdb调试器。使用这些调试工具打开dump文件后，可以查<strong>看到发生异常的那条汇编指令</strong>，以及<strong>异常时的函数调用堆栈</strong>等信息。在拿到函数调用堆栈中相关库的符号库文件后，还可以<strong>看到具体的函数接口名及行号</strong>等详细信息，可以<strong>借助这些信息去对异常问题进行定位</strong>。</p>
<h3 id="1.2%E3%80%81%E6%9C%89%E6%97%B6%E9%9C%80%E8%A6%81%E6%9F%A5%E7%9C%8B%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E5%8E%BB%E5%AE%9A%E4%BD%8D%E9%97%AE%E9%A2%98">1.2、有时需要查看汇编代码去定位问题</h3>
<p class="img-center"><img alt="bae15614067b4c48b50fb752bf1324f4.png" height="173" src="https://img-blog.csdnimg.cn/bae15614067b4c48b50fb752bf1324f4.png" width="441"/></p>
<p>       有的崩溃仅凭上述信息难以定位问题，可能就需要去查看对应二进制文件的汇编代码上下文了。</p>
<p>       一般我们使用交互式反汇编工具IDA Pro来打开二进制文件，去查看二进制文件中的汇编代码。IDA Pro既支持打开Windows下的.exe、.dll等二进制文件，也可以打开Linux下的.bin、.so等二进制文件。</p>
<p>        那该如何查看汇编代码的上下文呢？一般我们不会直接去逐句地阅读IDA Pro解析出来的汇编代码，汇编代码比较晦涩难懂，通篇阅读汇编代码是需要很深的功底的。很多时候我们只需要<strong>对照着C++源代码，去看发生异常的那条汇编指令附件的上下文</strong>。但C++代码编译时，编译器会对代码进行大量的优化，我们最终看到的是经过优化后的二进制代码，所以有时很难一字一句地将汇编代码和C++代码对应起来，两者可能是有些出入的。</p>
<p>        对于编译器的优化，比如在C++源码中有个函数调用，但在汇编代码中可能都没有函数调用（没有call函数的指令），直接使用几条汇编代码就代替了函数的调用，这样就节省了函数调用的开销（<strong>开销包括函数参数入栈出栈、寄存器的保护线程与恢复现场等</strong>），有效地提高了代码的运行速度与效率。</p>
<p>       我们在排查问题时去阅读汇编代码上下文，一般是对照着C++源码进行的，然后依托汇编代码上下文中的注释，找到汇编代码与C++源码的对应关系，去搞懂汇编代码上下文的含义。为了阅读汇编代码，我们要<strong>了解一些常用的汇编指令及常用寄存器的使用</strong>（比如EAX用来存放函数的返回值，ECX用来传递C++对象地址的），<strong>熟悉函数调用时的参数入栈、栈分布及参数寻址</strong>，<strong>了解内存拷贝的汇编代码实现</strong>、<strong>了解虚函数调用的二次寻址的过程</strong>，去啃发生异常的那条汇编指令的上下文中的汇编代码。下面我们会详细地讲述这些需要掌握的汇编相关内容。</p>
<h2 id="2%E3%80%81CPU%E6%9E%B6%E6%9E%84">2、CPU架构</h2>
<p>       说到汇编指令，就不得不说与之紧密相关的<strong>CPU架构</strong>，不同架构有着不同的指令集。不同架构的汇编指令会有很大的差别，不仅在指令名称上有差别，寄存器名称上也有较大的不同。</p>
<h3 id="2.1%E3%80%81%E5%BD%93%E5%89%8D%E4%B8%BB%E6%B5%81%E7%9A%84CPU%E6%9E%B6%E6%9E%84">2.1、当前主流的CPU架构</h3>
<p class="img-center"><img alt="ae8af48772fd47b3a2afc8927e29c617.png" height="350" src="https://img-blog.csdnimg.cn/ae8af48772fd47b3a2afc8927e29c617.png" width="678"/></p>
<p>        目前比较权威的CPU架构有AMD和Intel的X86架构，华为海思广泛采用的ARM架构，MIPS架构，开源RISC-V架构，还有国产的龙芯LoogArch架构等。</p>
<p>       X86架构主要占据全球PC桌面和服务器领域大部分市场，PC桌面领域被Intel和AMD的CPU瓜分，服务器领域则大规模使用Intel的i系列高性能CPU和至强服务器专用CPU。</p>
<p>       ARM公司的ARM架构则牢牢称霸移动处理器市场，主流的手机CPU厂商高通、华为、三星、联发科等均使用ARM架构。</p>
<p>       已经终止开源的MIPS架构，已不复当年之勇，越来越多厂商都选择拥抱更加开放的开源RISC-V架构，甚至连X86架构巨头Intel和AMD都有介入。</p>
<p class="img-center"><img alt="05e58b90ee4a4544b89d1ed1b0421eb1.png" height="351" src="https://img-blog.csdnimg.cn/05e58b90ee4a4544b89d1ed1b0421eb1.png" width="674"/></p>
<p>       龙芯中科的国产龙芯LoogArch架构，具有完全自主产权，采用龙芯架构的龙芯CPU取得了长足的进步，逐步缩短与顶级厂商Intel和AMD的差距。纯国产龙芯CPU的研制成功，实现了复兴号高铁100%国产化，让国产重型歼击机歼20的雷达和北斗导航卫星都装上了中国芯！</p>
<h3 id="2.2%E3%80%81%E5%9B%BD%E4%BA%A7CPU%E4%BB%8B%E7%BB%8D">2.2、国产CPU介绍</h3>
<p>       既然说到CPU架构，我们顺便来看看国产CPU的发展情况。目前比较知名的国产CPU有<strong>龙芯、兆芯、华为鲲鹏、海光、申威和飞腾</strong>。因为国际形势的影响，国家开始大力推行国产化替代，各大IT厂商也在陆续推出国产化软硬件产品，使得这些国产CPU逐渐走到了历史的舞台！</p>
<p>       下面我们就看看这些国产化CPU的一些情况：</p>
<blockquote>
<p>🍀 <strong>龙芯CPU</strong>早期采用MIPS架构，后来自研了LoogArch架构，目前最强的一款是龙芯3A5000系列，12nm工艺，早期由意法半导体代工，后来12nm的交给台积电代工。</p>
<p>🌴 <strong>兆芯CPU</strong>采用X86架构，目前最强的是KX-U6780A 处理器，16nm工艺，由台积电代工。</p>
<p>🌾 <strong>海光CPU</strong>采用X86架构，主要用于服务器方面，最新的是海光7000系列，14nm工艺，代工方是三星、格芯。</p>
<p>🌻 <strong>华为鲲鹏CPU</strong>采用ARM架构，主要也用于服务器方面，最新型号是鲲鹏920，7nm工艺，由台积电代工。</p>
<p>🥦 <strong>飞腾CPU</strong>采用ARM架构，有桌面版，也有服务器版，最新桌面版型号是D2000系列，采用16nm工艺，由台积电代工。</p>
<p>🌳 <strong>申威CPU</strong>采用Alpha架构，后面又自研了SW指令集，目前最新的是申威SW26010系列，采用28nm工艺，主要用于超级计算机，由中芯国际代工。</p>
</blockquote>
<p>       我们日常使用的国产化桌面系统主要使用飞腾和龙芯的CPU，国产化操作系统方面则使用中标麒麟系统、银河麒麟系统和UOS通信系统，国产化服务器则主要使用海光的CPU。 </p>
<h3 id="2.3%E3%80%81X86%E6%9E%B6%E6%9E%84%E4%B8%8EARM%E6%9E%B6%E6%9E%84%E4%B8%8B%E7%9A%84%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E7%9A%84%E5%B7%AE%E5%BC%82%E7%A4%BA%E4%BE%8B%C2%A0%20%C2%A0%20%C2%A0%C2%A0"><strong>2.3、X86架构与ARM架构下的汇编代码的差异示例     </strong> </h3>
<p>       我们可以来看一下X86架构下的汇编代码与ARM架构下的汇编代码在细节上的区别。比如我们的客户端程序是运行在<strong>Intel X86架构上的软件</strong>，在该架构上编译出来的汇编代码片如下：</p>
<p class="img-center"><img alt="c246eeb2710846ff9dc4b6943e911c4f.png" height="610" src="https://img-blog.csdnimg.cn/c246eeb2710846ff9dc4b6943e911c4f.png" width="542"/></p>
<p>我们的部分业务服务器使用的是<strong>华为海思的CPU芯片（ARM架构）</strong>，在该架构上编译出来的汇编代码片如下：</p>
<p class="img-center"><img alt="b5176c5d0b384c49a6d9211d5add4fbe.png" src="https://img-blog.csdnimg.cn/b5176c5d0b384c49a6d9211d5add4fbe.png"/></p>
<p>       无论在<strong>汇编指令名称</strong>上，还是在<strong>寄存器名称</strong>上，两种架构下都有很大的差别。很多人可能对X86架构下的汇编指令比较熟悉，看到ARM架构下的汇编代码会觉得很不适应，更加的晦涩难懂。<br/> 本文涉及到汇编语言相关的内容，都是拿X86下的汇编指令来讲述的。</p>
<h2 id="3%E3%80%81%E5%B8%B8%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8">3、常用寄存器</h2>
<p>       最初X86中主要使用32位寄存器，后来AMD公司率先搞出了64位的X86寄存器。X86 32位寄存器主要有以下几类：</p>
<blockquote>
<p>🍈 <strong>4个数据寄存器</strong>：EAX、EBX、ECX和EDX；</p>
<p>🍍 <strong>2个变址和指针寄存器</strong>：ESI和EDI；<br/> 🍋 <strong>2个指针寄存器</strong>：ESP和EBP；<br/> 🥭 <strong>1个指令指针寄存器</strong>：EIP；<br/> 🍎 <strong>6个段寄存器</strong>：ES、CS、SS、DS、FS和GS；<br/> 🍏 <strong>1个标志寄存器</strong>：EFlags。</p>
</blockquote>
<p>       在X86-64寄存器中，所有寄存器都是64位，相对32位的x86寄存器来说，标识符发生了变化，比如从原来的ebp变成了rbp。为了保持兼容性，32位寄存器都可以继续使用，比如ebp寄存器，不过指向了rbp的低32位。X86-64的64位寄存器主要有以下几类</p>
<blockquote>
<p>🍐 <strong>64位下有16个寄存器</strong>：rax、rbx、rcx、rdx、esi、edi、rbp、rsp、r8、r9、r10、r11、r12、r13、r14、r15。</p>
<p>🍑 <strong>6个传参寄存器</strong>：依次为：rdi、rsi、rdx、rcx、r8、r9</p>
</blockquote>
<p>       因为32寄存器比较多见，本文讲解的问题中使用的都是32位寄存器，下面我们主要介绍一下32寄存器在C++汇编代码中的一些用途，了解这些寄存器的常用用途之后，对于阅读汇编代码很重要。</p>
<p>       有些人可能会有疑问，讲X86 32位寄存器是不是没什么意义了，现在用的应该都是64位寄存器了吧？<strong>在Windows系统中，C++编写的应用程序为了兼容32位操作系统，还是使用32位编译器编译的，所以用的还是32位寄存器</strong>，<strong>所以介绍32寄存器还是有用的！</strong></p>
<h3 id="3.1%E3%80%81EAX%E5%AF%84%E5%AD%98%E5%99%A8">3.1、EAX寄存器</h3>
<p>        在X86汇编指令中，<strong>EAX主要用于存放函数调用的返回值</strong>，比如返回一个C++类指针地址的函数GetContainerPtr：</p>
<pre><code class="language-cpp">IContainerUI* GetContainerPtr()
{
   // ......
}</code></pre>
<p>在call这个函数指令执行完成后，返回的类对象地址就保存到EAX寄存器中了。</p>
<p>       将返回值保存到EAX寄存器中，其实是被调用函数中的ret指令实现的。<strong>执行ret指令时,会将适合4个字节的任意类型的返回值，比如32位C++程序中的类对象地址、int型变量的值，保存到EAX寄存器中的</strong>。这个细节在阅读汇编代码时比较重要。</p>
<h3 id="3.2%E3%80%81ECX%E5%AF%84%E5%AD%98%E5%99%A8">3.2、ECX寄存器</h3>
<p>       在C++类的成员函数中都掩藏一个保存当前C++对象地址的this指针，成员函数中访问所属C++对象的成员变量时，都是通过this指针访问对应C++对象的成员变量的。</p>
<p>       在C++汇编代码中，在调用C++成员函数时会<strong>使用ECX寄存器用来传递C++对象地址</strong>，即C++对象中的this指针。</p>
<p>       在汇编代码中，在call一个类的成员函数之前，需要把对应的C++对象的地址先存入到ECX寄存器中。比如我们定义了COperateNum类，类中有个成员函数AddNum，我们使用COperateNum类定义了一个对象，然后通过该对象去调用类的成员函数AddNum，C++源代码如下所示：</p>
<pre><code class="language-cpp">class COperateNum
{
public:
	int AddNum( int a, int b )
	{
		int nSum = a + b;
		return nSum;
	}
};

// 定义一个类对象，然后通过该对象去调用类的成员函数
COperateNum oeprateNum;
int nNum1 = 3, nNum2 = 5;
oeprateNum.AddNum( nNum1, nNum2 );</code></pre>
<p>我们使用的是微软的Visual Studio开发环境，可以在调试状态下查看C++代码对应的汇编代码，这段C++代码对应的汇编代码如下：</p>
<p class="img-center"><img alt="48fd519fa3254eb2b52a1450fdd1443d.png" height="208" src="https://img-blog.csdnimg.cn/48fd519fa3254eb2b52a1450fdd1443d.png" width="491"/></p>
<p>在调用COperateNum类的成员函数AddNum时，会先将要传入的参数压到栈上（通过栈传递参数的值），然后将COperateNum对象的地址保存到ECX中，即通过ECX传递COperateNum类对象的地址，然后再去call COperateNum::AddNum函数。</p>
<p>       此外，ECX除了传递C++对象地址（this指针），还常<strong>用来存放循环执行的次数</strong>，下面在讲到memcpy的汇编代码实现时会详细说到这一点。</p>
<h3 id="3.3%E3%80%81ESI%E5%92%8CEDI%E5%AF%84%E5%AD%98%E5%99%A8">3.3、ESI和EDI寄存器</h3>
<p>       这两个是变址寄存器，ESI是源地址寄存器，EDI是目的地址寄存器，主要用于内存拷贝的串操作指令中，比如memcpy的汇编实现中。它们也可以作为通用寄存器来使用。</p>
<h3 id="3.4%E3%80%81ESP%E5%92%8CEBP%E5%AF%84%E5%AD%98%E5%99%A8">3.4、ESP和EBP寄存器</h3>
<p>       ESP是栈顶地址寄存器，EBP是栈基址寄存器，主要用来存放当前运行到的函数的栈起始地址（栈基址）和栈顶地址。</p>
<p>       下图是A函数调用B函数的栈分布图，可以看到B函数的栈基址和栈顶地址，当代码运行到B函数中时，B函数的栈基址就保存到EBP中，B函数的栈顶地址就保存在ESP寄存器中：</p>
<p class="img-center"><img alt="116aa6e835bc4ca3be31f2f3e9467b59.png" height="544" src="https://img-blog.csdnimg.cn/116aa6e835bc4ca3be31f2f3e9467b59.png" width="588"/></p>
<p>该图是函数调用时的大体栈分布图，这个图后面我们会详细说明，此处就不详细展开了。</p>
<p>       EBP和ESP这两个寄存器很重要，函数中的局部变量都是在函数所占用的栈空间地址范围中分配的，在函数的汇编代码中，<strong>函数的局部变量要么通过EBP来寻址，要么是通过ESP来寻址</strong>。此外，<strong>函数调用堆栈的栈回溯正是通过EBP寄存器来实现的</strong>。对于栈回溯的原理，感兴趣的可以看看这篇文章：</p>
<p><a class="has-card" href="https://blog.csdn.net/chenlycly/article/details/121002139" title="C++栈回溯原理"><span class="link-card-box"><span class="link-title">C++栈回溯原理</span><span class="link-desc">我们在使用VS调试源代码或使用Windbg调试exe程序时，遇到异常，调试器就会中断下来，然后就能查看到此刻的函数调用堆栈。软件是执行到某一句机器代码产生了异常，可以看成执行了某一句汇编代码产生了异常，通过一句汇编代码，是如何将所在线程此刻完整的函数调用堆栈给回溯进来的呢？下面我们就来讲讲栈回溯的原理。 要搞清楚栈回溯的原理，需要对照着函数调用时的栈分布情况来看：1、函数入口处的汇编代码 对照着上图，看一下函数入口的ebp和esp寄存器操作。...</span><span class="link-link"><img alt="" class="link-link-icon" src="https://g.csdnimg.cn/static/logo/favicon32.ico"/>https://blog.csdn.net/chenlycly/article/details/121002139</span></span></a></p>
<h3 id="3.5%E3%80%81EIP%E5%AF%84%E5%AD%98%E5%99%A8">3.5、EIP寄存器</h3>
<p>       EIP寄存器是用来存放即将要执行的汇编指令地址的。这里讲的汇编地址，是<strong>代码段的地址</strong>，和我们平时说的变量占用的内存（<strong>数据段地址</strong>）是两个概念，要注意区分一下，不要混淆。</p>
<p>       当CPU从EIP寄存器中将汇编指令地址载入到CPU中时，EIP寄存器中的地址会自动累加，累加的值正好就是被取走的那条汇编指令的长度，这样EIP寄存器中的地址就是即将要执行的下一条汇编指令的地址了。</p>
<p>       后面在讲到call指令和ret指令时，也会讲到EIP寄存器。</p>
<h3 id="3.6%E3%80%81%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8">3.6、段寄存器</h3>
<p>       常用的段寄存器有CS、SS、DS、ES、FS和GS，这里我们简单讲述一下这些段寄存器的用途。</p>
<blockquote>
<p><strong>🍅 代码段寄存器CS</strong>（Code Segment）</p>
<p>       存放当前正在运行的程序代码所在段的段基址，表示当前使用的指令代码可以从该段寄存器指定的存储器段中取得，相应的偏移量则由EIP寄存器提供。</p>
<p><strong>🍆 </strong><strong>数据段寄存器DS</strong>（Data Segment）</p>
<p>       指出当前程序使用的数据所存放段的最低地址，即存放数据段的段基址。</p>
<p><strong>🌽 堆栈段寄存器SS</strong>（Stack Segment）</p>
<p>       指出当前堆栈的底部地址，即存放堆栈段的段基址。</p>
<p><strong>🥬 附加段寄存器ES</strong>（Extra Segment）</p>
<p>       指出当前程序使用附加数据段的段基址，该段是串操作指令中目的串所在的段。</p>
<p><strong>🥕 FS和GS辅助段寄存器</strong></p>
<p>        FS和GS是80386起增加的两个辅助段寄存器。FS段寄存器Windows用来存储一些进程信息，FS段的首地址是存储这些进程信息的首地址，在内核态FS指向GDT表的0x30地址，在用户态FS等于0x3B。也就是说，当切换到用户态时，操作系统会把进程下正在执行的线程的某些信息写入到0X3B为起始地址的空间里。内核态时候也一样，操作系统也会写入一些关于内核程序的相关信息到0x30里。GS通常用作指向线程本地存储（TLS）的指针。</p>
</blockquote>
<p>       这些段寄存器我们只需要了解一下即可，不需要去深入追溯，汇编代码中会自动去维护这些段寄存器。</p>
<h3 id="3.7%E3%80%81%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8EFlags">3.7、标志寄存器EFlags</h3>
<p>       标记寄存器主要是用来存放<strong>条件码标志</strong>，条件码标记则<strong>用来记录程序中运行结果的状态信息</strong>，它们是根据有关指令的运行结果由(CPU)自动设置的。由于这些状态信息往往<strong>作为后续条件转移指令的转移控制条件</strong>，所以称为条件码。</p>
<p>       常见的标记位有：</p>
<blockquote>
<p>🥗 <strong>进位标志CF</strong>(Carry Flag)，记录运算时最高有效位产生的进位值。<br/> 🥙 <strong>符号标志SF</strong>(Sign Flag)，记录运算结果的符号。结果为负时置1，否则置0。<br/> 🌮 <strong>零标志ZF</strong>(Zero Flag)，运算结果为0时ZF位置1，否则置0。<br/> 🥪 <strong>溢出标志OF</strong>(Overflow Flag)，在运算过程中，如操作数超出了机器可表示数的范围称为溢出。溢出时OF位置1，否则置0。<br/> 🍛 <strong>辅助进位标志AF</strong>(Auxliliary Carry Flag)，记录运算时第3位（半个字节）产生的进位值。 <br/> 🍲 <strong>奇偶标志PF</strong>(Parity Flag)，用来为机器中传送信息时可能产生的代码出错情况提供检验条件。当结果操作数中1的个数为偶数时置1，否则置0。</p>
</blockquote>
<h2 id="4%E3%80%81%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4">4、汇编指令</h2>
<h3 id="4.1%E3%80%81%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E6%A6%82%E8%BF%B0">4.1、汇编指令概述</h3>
<p>       X86汇编指令包括通用数据传送类指令、算术运算类指令、逻辑运算类指令、串指令、程序转移类指令和伪指令等几大类。</p>
<blockquote>
<p>🐬 常见的<strong>数据传送类指令</strong>有mov、push、pop、lda等。<br/> 🐳 常用的<strong>算术运行类指令</strong>有add、sub、mul、div、inc、dec、cmp等。<br/> 🐋 常用的<strong>逻辑运算类指令</strong>有and、or、xor、not、test等。<br/> 🐟 常见的<strong>串指令</strong>则有movs、cmps、rep等。<br/> 🥽 常见的<strong>程序转移指令</strong>有jmp、jz、jnz、call、ret、loop等。<br/> 🎫 常见的<strong>伪指令</strong>有proc、assume、end等。</p>
</blockquote>
<p>      <strong> 这些指令大概知道就行了，在阅读汇编代码时遇到不懂的或者不确定的，可以到网上查一下对应汇编指令的详细说明</strong>，比如这篇文章中就有对具体指令的详细说明：</p>
<p><a class="has-card" href="https://blog.csdn.net/chenlycly/article/details/52235043" title="汇编指令速查表"><span class="link-card-box"><span class="link-title">汇编指令速查表</span><span class="link-desc">有时我们需要查看汇编代码去分析软件问题，汇编代码才能最直观地反映出软件的问题。为了方便大家理解并记忆汇编指令，读懂汇编代码的上下文，此处列出常用汇编指令的使用说明，以供参考。</span><span class="link-link"><img alt="" class="link-link-icon" src="https://g.csdnimg.cn/static/logo/favicon32.ico"/>https://blog.csdn.net/chenlycly/article/details/52235043</span></span></a>        为了辅助记忆，也可以到下文中去查看一下常用汇编指令的英文全称：</p>
<p><a class="has-card" href="https://blog.csdn.net/chenlycly/article/details/52240792" title="汇编指令英文全称"><span class="link-card-box"><span class="link-title">汇编指令英文全称</span><span class="link-desc">有时我们需要查看汇编代码去分析软件问题，汇编代码才能最直观地反映出软件的问题。为了方便大家理解并记忆汇编指令，此处列出常用汇编指令的英文全称，以供参考。</span><span class="link-link"><img alt="" class="link-link-icon" src="https://g.csdnimg.cn/static/logo/favicon32.ico"/>https://blog.csdn.net/chenlycly/article/details/52240792</span></span></a></p>
<h3 id="4.2%E3%80%81call%E6%8C%87%E4%BB%A4%E5%92%8Cret%E6%8C%87%E4%BB%A4">4.2、call指令和ret指令</h3>
<p>       call指令和ret指令对理解一些关键汇编代码很重要，所以这个地方要单独拿出来讲一下。<br/> 简单的说，<strong>call指令</strong>会跳转到指定的函数地址处执行，并将返回地址（主调函数中call指令的下一条指令）压入到栈上保存下来。</p>
<p>       <strong>ret指令</strong>则是退出当前函数，并从栈中取出主调函数的返回地址（下一条指令）放到IP寄存器中，让代码返回到主调函数返回地址对应的位置继续向下执行。</p>
<p>       <strong>CPU执行call指令和ret指令的具体过程</strong>如下：</p>
<blockquote>
<p>🦉<strong>call指令</strong>：CPU 将call func指令的机器码读入，IP寄存器就指向了主调函数中的call func指令的下一条指令（主调函数调用被调函数时的返回地址，被调用函数返回后执行该返回地址处的汇编指令），然后CPU执行call func指令，将当前的IP寄存器的值压栈（返回地址压入栈中），并将IP寄存器值改变为标号func处的地址（即call指令中的函数地址）；<br/> 🦅 <strong>ret指令</strong>：CPU将ret指令的机器码读入，IP寄存器指向了ret 指令后的内存单元，然后CPU执行ret指令，从栈中弹出函数执行完后的返回地址（pop出栈操作会加esp），送入 IP寄存器中。然后再执行IP寄存器中的指令，即返回地址，即调用函数下面的下一条指令。</p>
</blockquote>
<p>       此处我们还要重点提下EIP寄存器。<strong>EIP寄存器中存放的是下一条即将被执行到的指令</strong>，当<strong>CPU将要执行的指令从IP寄存器中读到CPU中准备执行，IP寄存器中的地址会自动累加，自动累加的值就是CPU刚取走的那条指令的长度值，这样IP寄存器就指向下一条要执行的指令</strong>（IP寄存器中的值就是指令地址）。当CPU执行完当前指令后，就从EIP寄存器中读取下一条指令地址，执行下一条指令，这样代码就不断地执行下去。</p>
<p>       注意，上面讲的地址均是<strong>代码段地址</strong>，和<strong>数据段的内存地址</strong>（变量的内存地址）是不同的。另外，上面讲的指令是二进制机器码，不是汇编代码，机器码和汇编代码有一一对应关系。比如我们在Visual Studio开发环境中可以看到如下的二进制机器码和汇编代码，如下：</p>
<h2 id="5%E3%80%81memcpy%E5%87%BD%E6%95%B0%E7%9A%84%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">5、memcpy函数的汇编代码实现</h2>
<p>       以下面一段执行memcpy操作的代码为例，将一个TStreamInfo结构体对象的值，拷贝到另一个TStreamInfo结构体对象中：</p>
<pre><code class="language-cpp">TStreamInfo* pStreamInfo = new TStreamInfo_Api;

// ...... // 对pStreamInfo进行赋值操作

TStreamInfo tCurStreamInfo;
memcpy( &amp;tCurStreamInfo, pStreamInfo, sizeof(tCurStreamInfo) );  </code></pre>
<p>我们再来看一下C函数memcpy的内部实现：</p>
<pre><code class="language-cpp">void * __cdecl memcpy (
        void * dst,
        const void * src,
        size_t count
        )
{
        void * ret = dst;
#if defined (_M_IA64)
        {
        __declspec(dllimport)
        void RtlCopyMemory( void *, const void *, size_t count );
        RtlCopyMemory( dst, src, count );
        }
#else  /* defined (_M_IA64) */
        /*
         * copy from lower addresses to higher addresses
         */
        while (count--) {
                *(char *)dst = *(char *)src;
                dst = (char *)dst + 1;
                src = (char *)src + 1;
        }
#endif  /* defined (_M_IA64) */

        return(ret);
}</code></pre>
<p>从memcpy内部的实现代码可以看出，<strong>通过循环去执行逐字节内存拷贝的操作</strong>。</p>
<p>        对于memcpy在汇编代码上的实现，在此给大家详细介绍一下，<strong>下次在看到类似的汇编代码时，就能知道对应的是memcpy的操作。</strong></p>
<p>       上面执行memcpy的C++代码，对应的汇编代码，类似于下面的汇编代码片：</p>
<p class="img-center"><img alt="e5b2fdef4e034d35965c1c2a063b48fa.png" height="591" src="https://img-blog.csdnimg.cn/e5b2fdef4e034d35965c1c2a063b48fa.png" width="525"/></p>
<p>       从汇编代码上看，memcpy内存拷贝的操作对应rep movsd指令，其中的d对应dword（在32位程序中是4字节），所以rep movsd等同于rep movs dword ptr es:[edi], dword ptr [esi]。这句汇编指令中用到了esi和edi寄存器，esi寄存器用于存放源内存地址，edi寄存器用于存放目标内存地址。</p>
<p>       指令中还用到rep重复执行指令，rep指令每次执行时都会把ecx寄存器中的值读出来，如果<strong>ecx值大于0</strong>，就执行后面语句，执行完后，会让<strong>ecx中的值减1</strong>，然后再去执行rep指令，再去判断ecx中的值，直到<strong>ecx中的值为0</strong>，就退出rep指令。所以，在rep movsd指令之前会<strong>将需要重复执行的次数压入到ecx寄存器</strong>中。</p>
<p>       对于rep movs dword ptr es:[edi],dword ptr [esi]，每次拷贝dword 4字节数据，拷贝要重复执行N次，每执行一次movs操作，esi和esi寄存器中值都会累加。</p>
<h2 id="6%E3%80%81C%2B%2B%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%97%B6%E7%9A%84%E6%A0%88%E5%88%86%E5%B8%83">6、C++函数调用时的栈分布</h2>
<p>       了解函数调用时的栈分布，对理解汇编代码的上下文至关重要。</p>
<h3 id="6.1%E3%80%81%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%9A%84%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86">6.1、函数调用的预备知识</h3>
<p>       <strong>函数调用是发生在某个线程中</strong>，单个线程的栈空间在创建线程时就固定下来了，在Windows系统中默认的线程栈空间大小为1MB，在创建线程时也可以修改这个默认值。</p>
<p>       <strong>函数中的局部变量是在栈空间中分配内存的</strong>，函数调用时的参数的传递也是通过栈内存来传递的。在程序运行到一个函数的入口时，当前这个函数的栈内存的大小就分配好了，这是代码在编译期间就确定下来的。</p>
<p>       另外，<strong>栈的使用方向从大地址向小地址的方向的</strong>，即先分配的栈内存是在大地址内存上的，后分配的内存是在小地址内存上的。</p>
<h3 id="6.2%E3%80%81%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88%E5%88%86%E5%B8%83%E5%9B%BE">6.2、函数调用栈分布图</h3>
<p>       以A函数调用B函数为例，函数调用时的栈分布如下所示：</p>
<p class="img-center"><img alt="116aa6e835bc4ca3be31f2f3e9467b59.png" height="538" src="https://img-blog.csdnimg.cn/116aa6e835bc4ca3be31f2f3e9467b59.png" width="581"/></p>
<p>        A函数在调用B函数时，会<strong>先将给B函数传递的参数压到栈上</strong>，然后去执行call指令，<strong>call指令会将主调函数中的返回地址压到栈上</strong>，然后跳转到B函数的起始地址（代码段地址）处执行。</p>
<p>       然后在B函数的入口处，会<strong>将A函数(主调函数)的栈基址</strong>（A函数的栈基址存放在ebp寄存器中）<strong>压入到栈上</strong>保存下来。<strong>保存主调函数的栈基址，是为了回溯出函数调用堆栈的</strong>，这点会涉及到函数调用的栈回溯原理。</p>
<h3 id="6.3%E3%80%81%E5%88%A9%E7%94%A8%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%97%B6%E7%9A%84%E6%A0%88%E5%88%86%E5%B8%83">6.3、利用汇编代码详解函数调用时的栈分布</h3>
<p>       下面我们通过一段C++测试代码，来查看发生函数调用时涉及到栈分布的汇编代码。我们编写了一个将两个int型整数相加的函数Add，然后在main函数中去调用这个Add函数，C++源代码如下：</p>
<pre><code class="language-cpp">int Add(inta,intb)
{
	int hSum = a+b;
	return nSum;
}

int __cdecl _tmain(int argc,_ TCHAR* argv[])
{
    int a = 3;
    int b = 4;

    int nSum = Add(a,b);
    printf(" nSum = %d\r\n", nSum );

    return 0;
}</code></pre>
<p>       我们使用Visual Studio开发环境，可以在调用Add函数的代码附近打断点，然后调试运行，当命中断点时，右键点击断点处的代码，在从弹出的右键菜单中点击“转到反汇编”菜单项：</p>
<p class="img-center"><img alt="266f90086a0a4fa3a949129b8c5a9f21.png" height="457" src="https://img-blog.csdnimg.cn/266f90086a0a4fa3a949129b8c5a9f21.png" width="378"/></p>
<p>可以查看到<strong>调用Add函数附近的汇编代码</strong>如下：</p>
<p class="img-center"><img alt="67d6c7b9f18040d19c206efca76cc612.png" height="505" src="https://img-blog.csdnimg.cn/67d6c7b9f18040d19c206efca76cc612.png" width="411"/></p>
<p>       从汇编代码可以看出，在call Add函数之前，<strong>先将传给Add函数的参数a和b的值压到栈上</strong>，然后再去执行call Add函数的指令。这个<strong>call指令会把主调函数的返回地址压到栈上</strong>，当Add函数执行完后，会返回到这个返回地址对应的汇编代码处开始继续向下执行。</p>
<p>       我们继续向下看，在执行完call指令后，<strong>Add函数的返回值就保存到eax寄存器中</strong>了，然后就把eax寄存器中的值设置给nSum变量了。</p>
<p>       如果要从汇编代码页面返回到源代码页面，可以右键点击汇编代码，在弹出的右键菜单中点击“转到源代码”菜单项，如下：</p>
<p class="img-center"><img alt="662579e6553443d99240952a3be58b4e.png" height="297" src="https://img-blog.csdnimg.cn/662579e6553443d99240952a3be58b4e.png" width="287"/></p>
<p>        然后我们再在Add函数中添加一个断点，让代码执行到该断点处，<strong>查看Add函数的汇编代码</strong>实现：</p>
<p class="img-center"><img alt="97855727e3a94f339a519c0410a1056d.png" height="411" src="https://img-blog.csdnimg.cn/97855727e3a94f339a519c0410a1056d.png" width="587"/></p>
<p>       <strong>在Add函数的入口处</strong>，先执行了这两句汇编代码：</p>
<pre><code class="language-bash">push ebp
mov ebp, esp</code></pre>
<p>每个函数的开头都有两句汇编指令。第一句汇编指令中的ebp寄存器中的值，其实是主调函数的栈基址，这句话是将主调函数的栈基址压到栈上保存下来。接下来的一句，是将esp栈顶寄存器中的值设置到ebp寄存器中，即当前的栈顶地址就是被调用函数的栈基址。ebp栈基址寄存器和esp栈顶寄存器中存放的栈基址和栈顶地址，是针对当前运行进入的某个函数来说的，即是该函数的栈基址和栈顶地址。</p>
<p>       <strong> 在Add函数结尾的地方</strong>，我们可以看到两句汇编指令：</p>
<pre><code class="language-bash">mov esp, ebp
pop ebp</code></pre>
<p>这两句汇编指令，也是所有函数结尾处都有的。在退出Add函数时，要将Add函数的ebp寄存器值设置到esp中，在返回到主调函数后esp就要指向主调函数的栈顶地址了。pop ebp，就是将之前保存的主调函数的栈基址，从栈内存中pop出来，设置到ebp寄存器中。Add函数返回到主调函数中后，ebp就要指向主调函数的栈基址了。</p>
<p>       <strong>最后执行的ret 8指令</strong>，也比较有意思，它有多个作用。首先，<strong>这个8是为了清理传入的两个int型变量占用的栈空间的</strong>，在函数返回后要保证栈平衡。其次，<strong>ret指令会从之前call指令压到栈上的主调函数的返回地址pop出来</strong>，然后设置到eip寄存器中，这样CPU就返回到主调函数中，从返回地址指向的汇编代码开始继续向下执行了。</p>
<p>       注意，上面截图中除了显示汇编代码，还显示了二进制机器码，其实汇编代码是机器码的便于记忆的书写形式，即<strong>汇编代码是机器码的助记符</strong>，二者是完全等同的。之所以显示二进制机器码，是因为我们在右键菜单中勾选了“显示代码字节”。</p>
<h2 id="7%E3%80%81C%2B%2B%E8%99%9A%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%9A%84%E6%B1%87%E7%BC%96%E5%AE%9E%E7%8E%B0"><strong>7、C++虚函数调用的汇编实现</strong></h2>
<p class="img-center"><img alt="45e2d06cf568488fa932d134c06d8ff2.png" src="https://img-blog.csdnimg.cn/45e2d06cf568488fa932d134c06d8ff2.png"/></p>
<p>       多态是C++中一个很重要的概念，C++代码中到处都在使用多态。多态可以描述为，将一个子类的对象赋给一个父类的指针，然后使用父类的指针去调用虚函数，实际调用的是子类实现的虚函数。</p>
<h3 id="7.1%E3%80%81%E8%99%9A%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%A4%E6%AC%A1%E5%AF%BB%E5%9D%80">7.1、虚函数调用过程中的两次寻址</h3>
<p>       多态中虚函数的调用需要到<strong>虚函数表</strong>中找到<strong>虚函数的地址</strong>（函数代码段地址），然后再去call这个虚函数，整个过程会涉及到两次寻址。</p>
<p>       整个过程中涉及到几个概念：<strong>虚函数表指针变量</strong>和<strong>虚函数表</strong>。只要类中有虚函数或者父类中有虚函数，那这个类中就会掩藏一个虚函数表指针，该指针中存放的就是虚函数表的首地址。虚函数表就是一段连续的内存，其中存放的就是虚函数地址，即每个虚函数的代码段地址。拿到虚函数的首地址，直接去call这个地址，就可以完成虚函数调用了。</p>
<p>       在虚函数调用的具体过程中，子类对象的首地址，就是子类对象的内存起始地址，而子类的虚函数表指针变量在所在对象的内存排布上位于类对象内存的第一位，所以<strong>子类对象的首地址，就是类中虚函数表指针的首地址</strong>，取出<strong>该首地址内存中的内容</strong>，就是虚函数表指针变量中的内容，<strong>就是虚函数表的首地址</strong>，这是<strong>第一次寻址</strong>。</p>
<p>       拿到虚函数表的首地址，再根据虚函数在虚函数表中的偏移，计算出目标虚函数在虚函数表中的位置，将该位置内存中的内容取出，就是虚函数的首地址，这样我们就可以直接去call这个虚函数的地址，完成虚函数调用了，这是<strong>第二次寻址</strong>。</p>
<h3 id="7.2%E3%80%81%E8%99%9A%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%9A%84%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E8%B5%B0%E8%AF%BB">7.2、虚函数调用的汇编代码走读</h3>
<p>        以如下的C++代码为例：</p>
<pre><code class="language-cpp">// 定义类
class CContact : public IContactPtr
{
    CContact();
    ~CContact();

    // ......

    // 类中的虚函数func1
    virtual func1();

    // ......
};

// 获取IContactPtr类指针
IContactPtr* GetContactPtr()
{ 
    // 此处return一个子类CContact对象地址
}

// 通过类指针调用类的虚函数func1
GetContactPtr()-&gt;func1();</code></pre>
<p>我们定义了一个继承于接口类IContactPtr的子类CContact，然后调用GetContactPtr接口获取一个父类的指针，指针中存放的是子类对象的地址，然后去调用虚函数func1。调用虚函数的func1的汇编代码如下：</p>
<p class="img-center"><img alt="5bca4b78dd5f45898521d65c8416a3ca.png" height="315" src="https://img-blog.csdnimg.cn/5bca4b78dd5f45898521d65c8416a3ca.png" width="572"/></p>
<p>先call函数 GetContactPtr获取CContact业务类指针，call完成后，CContact业务类指针<br/> 保存到eax寄存器中，下面来详细解释接下来的几句汇编代码：</p>
<blockquote>
<p>（1）<strong>mov   edx, [eax]  </strong><br/> eax寄存器中存放的C++类对象首地址，该类对象首地址就是类中成员变量虚函数表指针变量的地址（虚函数表指针变量在内存排列上位于C++对象的首位），所以对eax取址得到的就是虚函数表指针变量中存放的虚函数表的首地址，将虚函数表的首地址存到edx寄存器中（第一次寻址）。<br/> （2）<strong>mov   ecx, [ebp+var_8]  </strong><br/> 将[ebp+var_8]内存中保存的C++类对象首地址再给到ecx寄存器中，是为了调用虚函数（C++类的成员函数IsExistLocalArchFile）传递类的this指针的，C++的汇编代码中是通过ecx寄存器传递this指针的。<br/> （3）<strong>mov    eax, [edx+140h]  </strong> <br/> 目标虚函数在虚函数表中的偏移是140h，所以edx+140h就是目标虚函数在虚函数表中的内存地址，对edx+140h取址（即[edx+140h]）得到的就是虚函数表中存放的目标虚函数的首地址（虚函数代码段的地址），然后将虚函数的首地址放置到eax寄存器中，接下来直接去call eax，就是去调用虚函数了。（第二次寻址）</p>
</blockquote>
<p>至此，就完成虚函数的调用了。</p>
<p>       所以，<strong>在阅读到类似于上面的汇编代码时，就要下意识地想到，可能是虚函数调用对应的代码块。</strong>如果不了解虚函数调用的汇编代码实现，很难读懂这块汇编代码的。</p>
<h2 id="8%E3%80%81IDA%E5%8F%8D%E6%B1%87%E7%BC%96%E5%B7%A5%E5%85%B7">8、IDA反汇编工具</h2>
<p class="img-center"><img alt="853e55d835ca4ac4ba5932ee37c6f721.png" height="479" src="https://img-blog.csdnimg.cn/853e55d835ca4ac4ba5932ee37c6f721.png" width="683"/></p>
<p>       上面我们说过，可以在Visual Studio中查看C++代码对应的汇编代码。只需要在C++代码中设置断点，开启调试运行，当命中断点时，右键点击断点附近的C++源码，在弹出的右键菜单中点击“转到反汇编”，就可以看到汇编代码了。在右键菜单中点击“显示代码字节”，还可以看到二进制机器码。我们可以利用这个途径，去熟悉去学习汇编代码，有效地将C++源码和汇编代码联系起来。</p>
<p class="img-center"><img alt="d01052336cac4965bc1c98a1c1973700.png" height="280" src="https://img-blog.csdnimg.cn/d01052336cac4965bc1c98a1c1973700.png" width="421"/></p>
<p>       在实际工作中，我们一般使用反汇编工具IDA去打开二进制文件，查看二进制文件中的汇编代码。IDA既支持打开Windows下的.exe、.dll等二进制文件，也可以打开Linux下的.bin、.so等二进制文件。</p>
<p>       使用IDA查看WIndows平台上二进制文件的汇编代码时，最好拿来二进制文件对应的.pdb符号库文件（文件中包含函数及变量的符号信息），将pdb文件放在二进制文件的<strong>同级目录</strong>中，这样IDA在打开二进制文件时<strong>会去自动加载pdb符号库文件</strong>。加载符号库后，汇编代码中能看到<strong>具体的函数名及变量注解</strong>，以及<strong>一些额外的注释信息</strong>。通过这些注释信息，可以很好地将C++代码和汇编上下文对应起来，这样我们能快速搞懂汇编代码的上下文，定位发生异常的原因。</p>
<p>       至于如何使用IDA查看二进制文件的汇编代码，可以查看我之前写的一篇关于如何使用IDA的文章：</p>
<p><a class="has-card" href="https://blog.csdn.net/chenlycly/article/details/120635120" title="IDA反汇编工具使用详解"><span class="link-card-box"><span class="link-title">IDA反汇编工具使用详解</span><span class="link-desc">详细介绍IDA反汇编工具的使用。</span><span class="link-link"><img alt="" class="link-link-icon" src="https://g.csdnimg.cn/static/logo/favicon32.ico"/>https://blog.csdn.net/chenlycly/article/details/120635120</span></span></a>       其实这里我们只是用了IDA的一小部分功能，IDA应该是当今最强大的一款反汇编工具，在逆向工程领域有着广泛的应用。</p>
<p>       此外，在Windows系统中我们主要使用Windbg去分析软件异常，使用Windbg打开异常捕获模块捕获到的dump文件，至于如何使用Windbg可以查看文章：</p>
<p><a class="has-card" href="https://blog.csdn.net/chenlycly/article/details/120631007" title="Windbg调试工具使用详解"><span class="link-card-box"><span class="link-title">Windbg调试工具使用详解</span><span class="link-desc">1、Windbg简介Windbg是微软提供的Windows平台下强大的用户态和内核态调试利器，给我们分析Windows上软件的异常提供了极大的便利和有力的支持，比原始的直接查看代码分析异常的效率要来的高的多。Windbg在某些方面甚至要比微软的Visual Studio还要强大。 Windbg的主界面如上所示。Windbg可以静态分析dump文件，也可以对目标进程进行动态调试。Windbg可以直接启动进程，也可以附加到正在运行的目标进程上，可以查看进程运行时变量内存中的数据。Windbg在排查死..</span><span class="link-link"><img alt="" class="link-link-icon" src="https://g.csdnimg.cn/static/logo/favicon32.ico"/>https://blog.csdn.net/chenlycly/article/details/120631007</span></span></a></p>
<h2 id="9%E3%80%81%E6%80%BB%E7%BB%93">9、总结</h2>
<p>       以上是我多年来处理软件异常问题的心得和经验总结。大家在<strong>了解上面讲到的一些关于汇编语言的基本点和细节</strong>之后，<strong>结合一些排查软件异常常用的方法和工具软件</strong>，应该就能很好地应对日常开发维护中遇到的多种软件异常问题了。当然要熟练掌握这些技能，要去不断的实践，多去分析项目中遇到的多个异常问题，不断的积累经验。</p>
<p>       在日常开发维护工作中，不要仅仅只研究自己负责的模块问题，底层模块（比如网络模块、协议模块、组件模块、开源组件模块、音视频编解码模块等）的一些发生崩溃和异常，也可以去看看，主动去协助兄弟部门去排查，<strong>不仅能见识更多类型的软件异常，积累更多的经验，还能扩大眼界，能了解底层库的实现逻辑和编码的思想，这对于把握整个系统的业务有很大的作用</strong>！学习是需要主动的，需要主动去发掘一些学习的机会，再和其他开发组的同事一起联调、一起排查问题、一起交流时，也能学到不少东西的！</p>
<p>       有不少入职一两年的应届生，经常会说他们学不到什么东西了，其实很多时候还是他们不够主动，把眼光仅仅局限在自己做的模块中，没有积极主动地发掘学习的机会！</p>
<p>       我之前已经创建了<strong>C++软件异常排查的技术专栏</strong>，专栏中系统地讲述了<strong>引发C++软件异常的常见原因</strong>，并详细阐述了<strong>解决这些异常的常用方法</strong>以及<strong>一些常用的软件工具。</strong></p>
<p>       后面我会在该专栏中持续输出这类主题的文章，并给出项目中遇到的各种软件异常分析实例，争取给大家提供一些更具体的借鉴与参考。</p>
</div>
</div>