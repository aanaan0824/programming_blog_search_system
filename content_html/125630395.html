<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<p id="main-toc"><strong>目录</strong></p>
<p id="%E6%A6%82%E5%BF%B5-toc" style="margin-left:0px;"><a href="#%E6%A6%82%E5%BF%B5">概念</a></p>
<p id="%E5%B8%B8%E7%94%A8%E7%9A%84%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F-toc" style="margin-left:0px;"><a href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F">注入方式</a></p>
<p id="%E9%92%A9%E5%AD%90%E6%B3%A8%E5%85%A5-toc" style="margin-left:40px;"><a href="#%E9%92%A9%E5%AD%90%E6%B3%A8%E5%85%A5">钩子注入</a></p>
<p id="%E5%8E%9F%E7%90%86-toc" style="margin-left:80px;"><a href="#%E5%8E%9F%E7%90%86">原理</a></p>
<p id="%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81">示例代码</a></p>
<p id="%E4%BB%A3%E7%A0%81%E6%B3%A8%E8%A7%A3-toc" style="margin-left:80px;"><a href="#%E4%BB%A3%E7%A0%81%E6%B3%A8%E8%A7%A3">代码注解</a></p>
<p id="%E8%BF%90%E8%A1%8C%E6%88%AA%E5%9B%BE-toc" style="margin-left:80px;"><a href="#%E8%BF%90%E8%A1%8C%E6%88%AA%E5%9B%BE">运行截图</a></p>
<p id="%E8%BF%9C%E7%BA%BF%E7%A8%8B%E6%B3%A8%E5%85%A5-toc" style="margin-left:40px;"><a href="#%E8%BF%9C%E7%BA%BF%E7%A8%8B%E6%B3%A8%E5%85%A5">远线程注入</a></p>
<p id="%E5%8E%9F%E7%90%86-toc" style="margin-left:80px;"><a href="#%E5%8E%9F%E7%90%86">原理</a></p>
<p id="%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%C2%A0-toc" style="margin-left:80px;"><a href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%C2%A0">示例代码 </a></p>
<p id="%E7%AA%81%E7%A0%B4Session%200%20%E9%9A%94%E7%A6%BB%E7%9A%84%E8%BF%9C%E7%BA%BF%E7%A8%8B%E6%B3%A8%E5%85%A5%C2%A0-toc" style="margin-left:40px;"><a href="#%E7%AA%81%E7%A0%B4Session%200%20%E9%9A%94%E7%A6%BB%E7%9A%84%E8%BF%9C%E7%BA%BF%E7%A8%8B%E6%B3%A8%E5%85%A5%C2%A0">突破Session 0 隔离的远线程注入 </a></p>
<p id="%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%C2%A0-toc" style="margin-left:80px;"><a href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%C2%A0">示例代码 </a></p>
<p id="%E5%85%A5%E5%8F%A3%E7%82%B9%E6%B3%A8%E5%85%A5-toc" style="margin-left:40px;">*<a href="#%E5%85%A5%E5%8F%A3%E7%82%B9%E6%B3%A8%E5%85%A5">入口点注入</a></p>
<p id="%E5%8E%9F%E7%90%86-toc" style="margin-left:80px;"><a href="#%E5%8E%9F%E7%90%86">原理</a></p>
<p id="%E5%8F%82%E8%80%83%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#%E5%8F%82%E8%80%83%E4%BB%A3%E7%A0%81">参考代码</a></p>
<p id="%C2%A0APC%E6%B3%A8%E5%85%A5-toc" style="margin-left:40px;"><a href="#%C2%A0APC%E6%B3%A8%E5%85%A5"> APC注入</a></p>
<p id="一apc注入-toc" style="margin-left:80px;"><a href="#%E4%B8%80apc%E6%B3%A8%E5%85%A5">一、APC注入</a></p>
<p id="二api-toc" style="margin-left:80px;"><a href="#%E4%BA%8Capi">二、API</a></p>
<p id="三实现-toc" style="margin-left:80px;"><a href="#%E4%B8%89%E5%AE%9E%E7%8E%B0">三、实现</a></p>
<p id="%E5%9B%9B%E3%80%81%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#%E5%9B%9B%E3%80%81%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81">四、示例代码</a></p>
<hr id="hr-toc"/>
<p></p>
<h1 id="%E6%A6%82%E5%BF%B5"><strong>概念</strong></h1>
<p>要谈dll注入，首先则要了解dll ，对dll的概念和使用不熟悉的读者可移步<strong><a class="link-info" href="https://blog.csdn.net/weixin_40582034/article/details/125614198?spm=1001.2014.3001.5502" title=" dll概念和使用方式详解"> dll概念和使用方式详解</a></strong></p>
<p>所谓DLL注入就是将一个DLL放进某个进程的地址空间里，让它成为那个进程的一部分。这样该进程和dll共享同一内存空间，这样dll可以使用该进程的所有资源，随时监控程序运行。通常，我们将需要实现的功能封装生成dll文件，然后将其注入到某一进程中，从而在该进程中添加或扩展我们需要的功能。因此dll注入技术被广泛运用在恶意攻击、游戏外挂、木马等程序中。</p>
<h2></h2>
<h1 id="%E5%B8%B8%E7%94%A8%E7%9A%84%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F">注入方式</h1>
<p></p>
<h2 id="%E9%92%A9%E5%AD%90%E6%B3%A8%E5%85%A5">钩子注入</h2>
<h3 id="%E5%8E%9F%E7%90%86">原理</h3>
<p>利用函数<span style="color:#4da8ee;"><strong>SetWindowsHookEx</strong></span>来实现注入。该函数将一个应用程序定义的挂钩处理函数安装到挂钩链中去,可以通过<strong>安装挂钩处理过程来对系统的某些类型事件进行监控</strong>,这些事件与某个特定的线程或系统中的所有事件相关。如果我们需要向某一进程注入dll，则首先获取该进程中某一线程ID，在dll文件中封装我们的挂钩处理函数，对该线程设置钩子，当触发类型事件时，线程则调用dll文件中的挂钩函数。<span style="color:#fe2c24;"><strong><span style="background-color:#f9eda6;">此时，如果线程想要成功地调用该挂钩函数，必须先加载该dll文件，这样也就实现了我们的dll注入了。</span></strong></span></p>
<blockquote>
<p><strong>函数原型</strong></p>
<p><strong><span style="color:#fe2c24;"><span style="background-color:#f9eda6;">HHOOK SetWindowsHookExA(</span><br/><span style="background-color:#f9eda6;">    [in] int       idHook,</span><br/><span style="background-color:#f9eda6;">    [in] HOOKPROC  lpfn,</span><br/><span style="background-color:#f9eda6;">    [in] HINSTANCE hmod,</span><br/><span style="background-color:#f9eda6;">    [in] DWORD     dwThreadId</span><br/><span style="background-color:#f9eda6;">);</span></span></strong></p>
<p></p>
<p><code>[in] lpfn</code></p>
<p>指向挂接过程的指针。如果 <em>dwThreadId</em> 参数为零或指定由其他进程创建的线程的标识符，则 <em>lpfn</em> 参数必须指向 DLL 中的挂接过程。否则，<em>lpfn</em> 可以指向与当前进程关联的代码中的挂接过程。</p>
<p></p>
<p><code>[in] hmod</code></p>
<p>DLL 的句柄，其中包含 <em>lpfn</em> 参数所指向的挂钩过程。如果 <em>dwThreadId</em> 参数指定由当前进程创建的线程，并且挂接过程位于与当前进程关联的代码中，则必须将 <em>hMod</em> 参数设置为 <strong>NULL</strong>。</p>
<p></p>
<p><code>[in] dwThreadId</code></p>
<p>挂接过程要与之关联的线程的标识符。对于桌面应用程序，如果此参数为零，则挂钩过程将与在与调用线程相同的桌面上运行的所有现有线程相关联</p>
</blockquote>
<p></p>
<h3 id="%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81">示例代码</h3>
<p></p>
<p><strong>dll文件</strong></p>
<pre><code class="language-cpp">#include "pch.h"
#include&lt;windows.h&gt;
BOOL APIENTRY DllMain( HMODULE hModule,
                       DWORD  ul_reason_for_call,
                       LPVOID lpReserved
                     )
{
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}
HHOOK hhk = 0;

LRESULT CALLBACK KeyboardProc(
   int code,
   WPARAM wParam,
   LPARAM lParam
)
{
    if (code == HC_ACTION)
    {
        if (wParam == VK_HOME &amp;&amp; (lParam &amp; (1&lt;&lt;30)))
            MessageBoxA(NULL, "您按下了HOME键", "HOME",MB_OK);
    }

    return  CallNextHookEx(hhk, code, wParam, lParam);

}

extern "C" _declspec(dllexport)  HOOKPROC getDllPoint(void)
{
    return KeyboardProc;
}
</code></pre>
<p></p>
<p><strong>设置钩子</strong></p>
<pre><code class="language-cpp">typedef HOOKPROC(*func)(void);
void CInjectTestDlg::OnBnClickedButton1()
{
	HWND  hwnd = ::FindWindowA(NULL, "陈子青注入工具2.0");
	DWORD pid;
	DWORD thread_id = ::GetWindowThreadProcessId(hwnd, &amp;pid);
	
	HMODULE mod = LoadLibraryA("myDll.dll");
	func proc = (func)::GetProcAddress(mod, "getDllPoint");

	HOOKPROC fp=proc();
	
	HHOOK hhk= ::SetWindowsHookEx(WH_KEYBOARD, fp, mod, thread_id);
}

</code></pre>
<h3 id="%E4%BB%A3%E7%A0%81%E6%B3%A8%E8%A7%A3">代码注解</h3>
<p>首先获取窗口线程，加载dll文件获取<strong>getDllPoint</strong>函数，该函数返回<strong>钩子处理函数的地址</strong>，然后给窗口线程设置键盘钩子，当触发键盘事件时，该线程调用myDll.dll文件中的处理函数，那么该线程必须先加载该dll文件，这时也就等同于我们将myDll.dll注入到该程序中了。</p>
<p></p>
<h3 id="%E8%BF%90%E8%A1%8C%E6%88%AA%E5%9B%BE">运行截图</h3>
<p><em>点击注入，当按下HOME键时，弹出信息框。</em></p>
<p><img alt="" height="365" src="image\6e7cfb7932ba48fba396608be3e4c8a0.png" width="420"/></p>
<p></p>
<p></p>
<h2 id="%E8%BF%9C%E7%BA%BF%E7%A8%8B%E6%B3%A8%E5%85%A5">远线程注入</h2>
<h3>原理</h3>
<p>远线程注入比较好理解，通过<strong><span style="color:#4da8ee;">CreateRemoteThread</span></strong>函数在需要注入的进程中创建一个自己的线程，在该线程中调用系统的<span style="color:#4da8ee;"><strong>LoadLibraryA</strong></span>加载dll文件即可。</p>
<p><span style="color:#4da8ee;"><strong>LoadLibraryA</strong></span>函数<span style="color:#4da8ee;"><strong>Kernel32.dll</strong></span>中，因此可以通过加载<span style="color:#4da8ee;"><strong>Kernel32.dll</strong></span>以来获取<span style="color:#4da8ee;"><strong>LoadLibraryA</strong></span>函数地址，其函数的参数就是dll文件的路径。此时可以通过<span style="color:#4da8ee;"><strong>VirtualAllocEx</strong></span>函数在该进程中创建一块内存用来保存需要被注入dll文件路径。</p>
<blockquote>
<p><strong><span style="color:#4da8ee;">CreateRemoteThread函数原型</span></strong></p>
<p></p>
<p><strong><span style="color:#fe2c24;"><span style="background-color:#fefcd8;">HANDLE CreateRemoteThread(</span><br/><span style="background-color:#fefcd8;">  [in]  HANDLE                 hProcess,</span><br/><span style="background-color:#fefcd8;">  [in]  LPSECURITY_ATTRIBUTES  lpThreadAttributes,</span><br/><span style="background-color:#fefcd8;">  [in]  SIZE_T                 dwStackSize,</span><br/><span style="background-color:#fefcd8;">  [in]  LPTHREAD_START_ROUTINE lpStartAddress,</span><br/><span style="background-color:#fefcd8;">  [in]  LPVOID                 lpParameter,</span><br/><span style="background-color:#fefcd8;">  [in]  DWORD                  dwCreationFlags,</span><br/><span style="background-color:#fefcd8;">  [out] LPDWORD                lpThreadId</span><br/><span style="background-color:#fefcd8;">);</span></span></strong></p>
<p></p>
<p></p>
<p><code>[in] hProcess</code></p>
<p>要在其中创建线程的进程的句柄。句柄必须具有<strong>PROCESS_CREATE_THREAD</strong>、<strong>PROCESS_QUERY_INFORMATION</strong>、<strong>PROCESS_VM_OPERATION</strong>、<strong>PROCESS_VM_WRITE</strong>和<strong>PROCESS_VM_READ</strong>访问权限，并且在某些平台上没有这些权限可能会失败。有关详细信息，请参阅<a href="https://docs.microsoft.com/en-us/windows/desktop/ProcThread/process-security-and-access-rights" title="进程安全性和访问权限">进程安全性和访问权限</a>。</p>
<p></p>
<p><code>[in] lpThreadAttributes</code></p>
<p>指向<a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/legacy/aa379560%28v=vs.85%29" title="SECURITY_ATTRIBUTES">SECURITY_ATTRIBUTES</a>结构的指针，该结构指定新线程的安全描述符，并确定子进程是否可以继承返回的句柄。如果 <em>lpThreadAttributes</em> 为 NULL，则线程将获得默认的安全描述符，并且句柄无法继承。</p>
<p></p>
<p><code>[in] lpStartAddress</code></p>
<p>指向<strong>类型为 LPTHREAD_START_ROUTINE</strong>的应用程序定义函数的指针将由线程执行，并表示远程进程中线程的起始地址。该函数必须存在于远程进程中。有关详细信息，请参阅<a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/legacy/ms686736%28v=vs.85%29" title="线程过程">线程过程</a>。</p>
<p></p>
<p><code>[in] lpParameter</code></p>
<p>指向要传递给线程函数的变量的指针。</p>
<p></p>
<p><code>[in] dwCreationFlags</code></p>
<p>控制线程创建的标志。</p>
<table><tbody><tr><th>价值</th><th>意义</th></tr><tr><td> <p>0</p> </td><td>线程在创建后立即运行。</td></tr><tr><td><a id="CREATE_SUSPENDED"></a><a id="create_suspended"></a> <p><strong>CREATE_SUSPENDED</strong></p> <p>0x00000004</p> </td><td>线程是在挂起状态下创建的，并且在调用 <a href="https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-resumethread" title="ResumeThread">ResumeThread</a> 函数之前不会运行。</td></tr><tr><td><a id="STACK_SIZE_PARAM_IS_A_RESERVATION"></a><a id="stack_size_param_is_a_reservation"></a> <p><strong>STACK_SIZE_PARAM_IS_A_RESERVATION</strong></p> <p>0x00010000</p> </td><td><em>dwStackSize</em> 参数指定堆栈的初始保留大小。如果未指定此标志，<em>则 dwStackSize</em> 指定提交大小。</td></tr></tbody></table>
<p></p>
<p><code>[out] lpThreadId</code></p>
<p>指向接收线程标识符的变量的指针。</p>
<p>如果此参数为 <strong>NULL</strong>，则不返回线程标识符。</p>
</blockquote>
<p></p>
<blockquote>
<p><span style="color:#4da8ee;"><strong>VirtualAllocEx函数原型</strong></span></p>
<p></p>
<p><span style="color:#fe2c24;"><strong><span style="background-color:#fefcd8;">LPVOID VirtualAllocEx(</span><br/><span style="background-color:#fefcd8;">  [in]           HANDLE hProcess,</span><br/><span style="background-color:#fefcd8;">  [in, optional] LPVOID lpAddress,</span><br/><span style="background-color:#fefcd8;">  [in]           SIZE_T dwSize,</span><br/><span style="background-color:#fefcd8;">  [in]           DWORD  flAllocationType,</span><br/><span style="background-color:#fefcd8;">  [in]           DWORD  flProtect</span><br/><span style="background-color:#fefcd8;">); </span></strong></span></p>
<p></p>
<p></p>
<p style="margin-left:0;"><code>[in] hProcess</code></p>
<p style="margin-left:0;">进程的句柄。该函数在此进程的虚拟地址空间内分配内存。</p>
<p style="margin-left:0;">句柄必须具有<strong>PROCESS_VM_OPERATION</strong>访问权限。</p>
<p style="margin-left:0;"></p>
<p style="margin-left:0;"><code>[in, optional] lpAddress</code></p>
<p style="margin-left:0;">为要分配的页面区域指定所需起始地址的指针。</p>
<p style="margin-left:0;">如果要预留内存，该函数会将此地址向下舍入到分配粒度的最接近的倍数。</p>
<p style="margin-left:0;">如果要提交已预留的内存，则该函数会将此地址向下舍入到最近的页边界。若要确定主计算机上的页面大小和分配粒度，请使用 <a href="https://docs.microsoft.com/en-us/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getsysteminfo" title="GetSystemInfo">GetSystemInfo</a> 函数。</p>
<p style="margin-left:0;"></p>
<p style="margin-left:0;"><code>[in] dwSize</code></p>
<p style="margin-left:0;">要分配的内存区域的大小，以字节为单位。</p>
<p style="margin-left:0;">如果 <em>lpAddress</em> 为 <strong>NULL</strong>，则该函数将 <em>dwSize</em> 向上舍入到下一页边界。</p>
<p style="margin-left:0;">如果 <em>lpAddress</em> 不是 <strong>NULL</strong>，则该函数将分配包含从 <em>lpAddress 到 lpAddress</em>+<em>dwSize</em> 范围内的一个或多个字节的所有页面。这意味着，例如，跨越页面边界的 2 字节范围会导致函数同时分配这两个页面。</p>
<p style="margin-left:0;"></p>
<p style="margin-left:0;"><code>[in] flAllocationType</code></p>
<p style="margin-left:0;">内存分配的类型。此参数必须包含以下值之一。</p>
<div>
<table border="1" cellspacing="0"><tbody><tr><th style="text-align:left;vertical-align:top;">价值</th><th style="text-align:left;vertical-align:top;">意义</th></tr><tr><td style="text-align:left;vertical-align:top;"><a id="MEM_COMMIT"></a><a id="mem_commit"></a> <p><strong>MEM_COMMIT</strong></p> <p>0x00001000</p> </td><td style="text-align:left;vertical-align:top;">为指定的保留内存页分配内存费用（从内存的总大小和磁盘上的分页文件）。该函数还保证当调用方稍后最初访问内存时，内容将为零。除非/直到实际访问虚拟地址，否则不会分配实际的物理页。 <p style="margin-left:0;">要一步到位地保留和提交页面，请使用 调用 <strong>VirtualAllocEx</strong>。<code>MEM_COMMIT | MEM_RESERVE</code></p> <p style="margin-left:0;">尝试通过指定<strong>不MEM_RESERVE</strong>和非 <strong>NULL</strong> <em>lpAddress</em> 的<strong>MEM_COMMIT</strong>来提交特定地址范围将失败，除非已保留整个范围。生成的错误代码为 <strong>ERROR_INVALID_ADDRESS</strong>。</p> <p style="margin-left:0;">尝试提交已提交的页不会导致函数失败。这意味着您可以提交页面，而无需首先确定每个页面的当前提交状态。</p> <p style="margin-left:0;">如果 <em>lpAddress</em> 指定安全区内的地址，则必须<strong>MEM_COMMIT</strong> <em>flAllocationType</em>。</p> </td></tr><tr><td style="text-align:left;vertical-align:top;"><a id="MEM_RESERVE"></a><a id="mem_reserve"></a> <p><strong>MEM_RESERVE</strong></p> <p>0x00002000</p> </td><td style="text-align:left;vertical-align:top;">保留进程的一系列虚拟地址空间，而不在内存或磁盘上的分页文件中分配任何实际的物理存储。 <p style="margin-left:0;">您可以通过使用<strong>MEM_COMMIT</strong>再次调用<strong>VirtualAllocEx</strong>来提交保留页面。要一步到位地保留和提交页面，请使用 调用 <strong>VirtualAllocEx</strong>。<code>MEM_COMMIT | MEM_RESERVE</code></p> <p style="margin-left:0;">其他内存分配函数（如 <strong>malloc</strong> 和 <a href="https://docs.microsoft.com/en-us/windows/desktop/api/winbase/nf-winbase-localalloc" title="LocalAlloc">LocalAlloc</a>）在释放保留内存之前无法使用保留内存。</p> </td></tr><tr><td style="text-align:left;vertical-align:top;"><a id="MEM_RESET"></a><a id="mem_reset"></a> <p><strong>MEM_RESET</strong></p> <p>0x00080000</p> </td><td style="text-align:left;vertical-align:top;">指示不再对 <em>lpAddress</em> 和 <em>dwSize</em> 指定的内存范围中的数据感兴趣。不应从分页文件中读取或写入分页文件。但是，稍后将再次使用内存块，因此不应将其取消提交。此值不能与任何其他值一起使用。 <p style="margin-left:0;">使用此值并不能保证使用<strong>MEM_RESET</strong>操作的范围将包含零。如果希望范围包含零，请取消提交内存，然后重新提交。</p> <p style="margin-left:0;">当您使用<strong>MEM_RESET</strong>时，<strong>VirtualAllocEx</strong> 函数将忽略 <em>fProtect</em> 的值。但是，您仍必须将 <em>fProtect</em> 设置为有效的保护值，如<strong>PAGE_NOACCESS</strong>。</p> <p style="margin-left:0;">如果您使用<strong>MEM_RESET</strong>并且内存范围映射到文件，<strong>则VirtualAllocEx</strong>将返回错误。共享视图只有在映射到分页文件时才可接受。</p> </td></tr><tr><td style="text-align:left;vertical-align:top;"><a id="MEM_RESET_UNDO"></a><a id="mem_reset_undo"></a> <p><strong>MEM_RESET_UNDO</strong></p> <p>0x1000000</p> </td><td style="text-align:left;vertical-align:top;"><strong>MEM_RESET_UNDO</strong>应仅在之前已成功应用<strong>MEM_RESET</strong>的地址范围上调用。它指示调用方对 <em>lpAddress</em> 和 <em>dwSize</em> 指定的指定内存范围内的数据感兴趣，并尝试反转<strong>MEM_RESET</strong>的影响。如果函数成功，则意味着指定地址范围内的所有数据都完好无损。如果函数失败，则地址范围内至少有一些数据已替换为零。 <p style="margin-left:0;">此值不能与任何其他值一起使用。如果在之前未<strong>MEM_RESET</strong>的地址范围上调用<strong>MEM_RESET_UNDO</strong>，则行为未定义。指定<strong>MEM_RESET</strong>时，<strong>VirtualAllocEx</strong> 函数将忽略 <em>flProtect 的值</em>。但是，您仍必须将 <em>flProtect</em> 设置为有效的保护值，如<strong>PAGE_NOACCESS</strong>。</p> <p style="margin-left:0;"><strong>Windows Server 2008 R2、Windows 7、Windows Server 2008、Windows Vista、Windows Server 2003 和 Windows XP： MEM_RESET_UNDO</strong>标志在 Windows 8 和 Windows Server 2012 之前不受支持。</p> </td></tr></tbody></table>
</div>   
 <p style="margin-left:0;">此参数还可以指定以下值，如所示。</p>
<div>
<table border="1" cellspacing="0"><tbody><tr><th style="text-align:left;vertical-align:top;">价值</th><th style="text-align:left;vertical-align:top;">意义</th></tr><tr><td style="text-align:left;vertical-align:top;"><a id="MEM_LARGE_PAGES"></a><a id="mem_large_pages"></a> <p><strong>MEM_LARGE_PAGES</strong></p> <p>0x20000000</p> </td><td style="text-align:left;vertical-align:top;">使用<a href="https://docs.microsoft.com/en-us/windows/desktop/Memory/large-page-support" title="大页面支持">大页面支持</a>分配内存。 <p style="margin-left:0;">大小和对齐方式必须是大页最小值的倍数。若要获取此值，请使用 <a href="https://docs.microsoft.com/en-us/windows/desktop/api/memoryapi/nf-memoryapi-getlargepageminimum" title="GetLargePageMinimum">GetLargePageMinimum</a> 函数。</p> <p style="margin-left:0;">如果指定此值，则还必须指定<strong>MEM_RESERVE</strong>和<strong>MEM_COMMIT</strong>。</p> </td></tr><tr><td style="text-align:left;vertical-align:top;"><a id="MEM_PHYSICAL"></a><a id="mem_physical"></a> <p><strong>MEM_PHYSICAL</strong></p> <p>0x00400000</p> </td><td style="text-align:left;vertical-align:top;">保留可用于映射地址<a href="https://docs.microsoft.com/en-us/windows/desktop/Memory/address-windowing-extensions" title="窗口化扩展">窗口化扩展</a>插件 （AWE） 页的地址范围。 <p style="margin-left:0;">此值必须与<strong>MEM_RESERVE</strong>一起使用，不得与其他值一起使用。</p> </td></tr><tr><td style="text-align:left;vertical-align:top;"><a id="MEM_TOP_DOWN"></a><a id="mem_top_down"></a> <p><strong>MEM_TOP_DOWN</strong></p> <p>0x00100000</p> </td><td style="text-align:left;vertical-align:top;">在可能的最高地址分配内存。这可能比常规分配慢，尤其是在分配很多时。</td></tr></tbody></table>
</div>
<p style="margin-left:0;"></p>
<p style="margin-left:0;"><code>[in] flProtect</code></p>
<p style="margin-left:0;">要分配的页面区域的内存保护。如果要提交页，则可以指定任何一个<a href="https://docs.microsoft.com/en-us/windows/win32/Memory/memory-protection-constants" title="内存保护常量">内存保护常量</a>。</p>
<p style="margin-left:0;">如果 <em>lpAddress</em> 指定安全区内的地址，<em>则 flProtect</em> 不能是以下任何值：</p>
<ul style="margin-left:38px;"><li>PAGE_NOACCESS</li><li>PAGE_GUARD</li><li>PAGE_NOCACHE</li><li>PAGE_WRITECOMBINE</li></ul>
<p style="margin-left:0;">为安全区分配动态内存时，必须<strong>PAGE_READWRITE</strong>或<strong>PAGE_EXECUTE_READWRITE</strong> <em>flProtect</em> 参数。</p>
</blockquote>
<p></p>
<p></p>
<h3 id="%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%C2%A0">示例代码 </h3>
<pre><code class="language-cpp">void CInjectTestDlg::OnBnClickedButton2()
{
	const char* path = "E:\\工程文件\\myDll\\Debug\\mydll2.dll";//要注入的dll路径

	HWND  hwnd = ::FindWindowA(NULL, "陈子青注入工具2.0");
	DWORD pid;
	GetWindowThreadProcessId(hwnd, &amp;pid);

	HANDLE hProc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);

	LPVOID lpAddr =  VirtualAllocEx(hProc,NULL, strlen(path)+1, MEM_COMMIT, PAGE_READWRITE);
	WriteProcessMemory(hProc, lpAddr, path,strlen(path), NULL);

	HMODULE sysMod = LoadLibraryA("Kernel32.dll");


	
	LPTHREAD_START_ROUTINE fp =(LPTHREAD_START_ROUTINE) GetProcAddress(sysMod, "LoadLibraryA");
	
	CreateRemoteThread(hProc, NULL, NULL,(LPTHREAD_START_ROUTINE)fp, lpAddr, 0, NULL);
	

}</code></pre>
<p></p>
<h2 id="%E7%AA%81%E7%A0%B4Session%200%20%E9%9A%94%E7%A6%BB%E7%9A%84%E8%BF%9C%E7%BA%BF%E7%A8%8B%E6%B3%A8%E5%85%A5%C2%A0">突破Session 0 隔离的远线程注入 </h2>
<p>使用<span style="color:#4da8ee;"><strong>ZwCreateThreadEx</strong></span>函数，突破<em>SESSION 0</em>隔离，向system等权限的系统服务器进程中入时，由于系统的<em>SESSION 0</em>隔离机制，导致注入失败；我们可使用<em>ZwCreateThreadEx</em>函数进行远程线程注入。<em>ZwCreateThreadEx</em>函数在<em>ntdll.dll</em>中没有被声明，所以需要使用<em>GetProcAddress</em>从<em>ntdll.dll</em>中获取函数导出地址。该函数在官网文档里是查询不到的。其函数原型如下</p>
<blockquote>
<p>X64<br/><span style="color:#fe2c24;"><strong><span style="background-color:#ffd900;">DWORD ZwCreateThreadEx(</span><br/><span style="background-color:#ffd900;">    PHANDLE                    ThreadHandle,</span><br/><span style="background-color:#ffd900;">    ACCESS_MASK                DesiredAccess,</span><br/><span style="background-color:#ffd900;">    LPVOID                    ObjectAttributes,</span><br/><span style="background-color:#ffd900;">    HANDLE                    ProcessHandle,</span><br/><span style="background-color:#ffd900;">    LPTHREAD_START_ROUTINE    lpStartAddress,</span><br/><span style="background-color:#ffd900;">    LPVOID                    lpParameter,</span><br/><span style="background-color:#ffd900;">    ULONG                    CreateThreadFlags,</span><br/><span style="background-color:#ffd900;">    SIZE_T                    ZeroBits,</span><br/><span style="background-color:#ffd900;">    SIZE_T                    StackSize,</span><br/><span style="background-color:#ffd900;">    SIZE_T                    MaximumStackSize,</span><br/><span style="background-color:#ffd900;">    LPVOID                    pUnkown</span><br/><span style="background-color:#ffd900;">)</span></strong></span></p>
</blockquote>
<blockquote>
<p>X32<br/><strong><span style="color:#fe2c24;"><span style="background-color:#ffd900;">DWORD ZwCreateThreadEx(</span><br/><span style="background-color:#ffd900;">    PHANDLE ThreadHandle,</span><br/><span style="background-color:#ffd900;">    ACCESS_MASK DesiredAccess,</span><br/><span style="background-color:#ffd900;">    LPVOID ObjectAttributes,</span><br/><span style="background-color:#ffd900;">    HANDLE ProcessHandle,</span><br/><span style="background-color:#ffd900;">    LPTHREAD_START_ROUTINE lpStartAddress,</span><br/><span style="background-color:#ffd900;">    LPVOID lpParameter,</span><br/><span style="background-color:#ffd900;">    BOOL CreateSuspended,</span><br/><span style="background-color:#ffd900;">    DWORD dwStackSize,</span><br/><span style="background-color:#ffd900;">    DWORD dw1,</span><br/><span style="background-color:#ffd900;">    DWORD dw2,</span><br/><span style="background-color:#ffd900;">    LPVOID pUnkown);</span></span></strong></p>
</blockquote>
<h3><strong>示例代码 </strong></h3>
<pre><code class="language-cpp"> typedef_ZwCreateThreadEx ZwCreateThreadEx = (typedef_ZwCreateThreadEx)GetProcAddress(hNtdll, "ZwCreateThreadEx");
    if (NULL == ZwCreateThreadEx)
    {
        printf("获取ZwCreateThreadEx函数地址失败！");
        CloseHandle(hProcess);
        return FALSE;
    }

    //在目标进程中创建线程
    HANDLE hRemoteThread = NULL;
    //pfnStartAddress 为loadlibrary函数地址， pBuf 传参
    DWORD dwStatus = ZwCreateThreadEx(&amp;hRemoteThread, PROCESS_ALL_ACCESS, NULL, hProcess,
            pfnStartAddress, pBuf, 0, 0, 0, 0, NULL);
    if (NULL == hRemoteThread)
    {
        printf("目标进程中创建线程失败！");
        CloseHandle(hProcess);
        return FALSE;
    }
</code></pre>
<p></p>
<h2 id="%E5%85%A5%E5%8F%A3%E7%82%B9%E6%B3%A8%E5%85%A5">*入口点注入</h2>
<h3><strong>原理</strong></h3>
<p>在以<strong>CREATE_SUSPENDED</strong>的方式启动程序，进程启动时被挂起，此时该进程无法拿到任何权限和数据，此时修改PE文件的入口点代码，在进程入口点跳转到实现注入的代码段，并在此恢复入口点代码再跳转回入口点，让程序正常运行。</p>
<p>这样做的好处是：第一我们注入的代码时运行在进程的主线程中的；第二进程在拉起时就被暂定完成注入之后才开始运行，实现“神不知鬼不觉”的效果</p>
<p>实现过程中涉及如下关键技术点</p>
<p>① 获取程序入口点  <a class="link-info" href="https://blog.csdn.net/weixin_40582034/article/details/125716018?spm=1001.2014.3001.5502" title="C++获取程序入口点">C++获取程序入口点</a></p>
<p>② 进程的创建挂起  <a class="link-info" href="https://blog.csdn.net/weixin_40582034/article/details/125676893?spm=1001.2014.3001.5502" title="进程的创建与使用">进程的创建与使用</a></p>
<p>③  jmp 远跳 对应机器码 0xE9</p>
<p>④ 如何定位写入数据 技巧 ：通过 0xCCCCCCCC 来转换</p>
<p>⑤ 关于写入函数的问题，函数中涉及调用都是通过地址寻址来调用的，如果直接写入，该地址在对方内存空间中是无效的 。</p>
<p>⑥ Jmp调转的相对地址计算 = 跳转的目标地址 - 当前地址 - 0x5</p>
<p>该方法需要对注入进程的内存进行反复改写和恢复，修正过程中要在对方进程中进行Debug，因此需要一定的逆向基础真正完善，否则程序常常是容易崩溃的，</p>
<p></p>
<p>下面提供一段入口点注入的代码，仅供参考</p>
<h3 id="%E5%8F%82%E8%80%83%E4%BB%A3%E7%A0%81">参考代码</h3>
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;cstring&gt;
#include&lt;Windows.h&gt;
using namespace std;


char dllPath[MAX_PATH] = "E:\\工程文件\\EntryPointDemo\\Debug\\Dll1.dll";
const char exePath[MAX_PATH] = "C:\\Users\\Administrator\\Desktop\\game.exe";

typedef HMODULE(*_loadLibrayA)(LPCSTR);
typedef HMODULE (*_getModuleHandle)(LPCSTR);
typedef BOOL (*_virtualProtect)(LPVOID ,SIZE_T,DWORD,PDWORD);

typedef struct ROMOTE_DATA
{
	char path[MAX_PATH];//dll地址
	_loadLibrayA loadLibrary;
	DWORD entryPoint;
	_getModuleHandle getModuleHande;
	_virtualProtect  virtualProtect;
	char code[0x5];
	LPVOID injectAddr;

}*PROMOTE_DATA;

PROMOTE_DATA rotData;

DWORD GetEntryPointAddr();
void initRotData()
{
	//strcpy_s(rotData-&gt;path,dllPath);
	memcpy(rotData-&gt;path,dllPath,sizeof(dllPath));

	HMODULE hMod =  LoadLibraryA("Kernel32.dll");
	rotData-&gt;loadLibrary = (_loadLibrayA)GetProcAddress(hMod, "LoadLibraryA");
	//printf("loadLibrary :%x\n", rotData-&gt;loadLibrary);
	rotData-&gt;entryPoint = GetEntryPointAddr();

	rotData-&gt;getModuleHande = (_getModuleHandle)GetProcAddress(hMod, "GetModuleHandleA");
	//printf("getModuleHande:%x\n", rotData-&gt;getModuleHande);
	rotData-&gt;virtualProtect = (_virtualProtect)GetProcAddress(hMod, "VirtualProtect");
	//printf("virtualProtect: %x\n", rotData-&gt;virtualProtect);

}

DWORD GetEntryPointAddr()
{
	HANDLE hFile = CreateFileA(exePath, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	int szFile = GetFileSize(hFile, NULL);
	LPBYTE lpFile = new BYTE[szFile];
	int ret = ReadFile(hFile, lpFile, szFile, NULL, NULL);
	if (ret == 0)
	{
		printf("read file error:%d", GetLastError());
		return NULL;
	}

	PIMAGE_DOS_HEADER imgDosHeader = (PIMAGE_DOS_HEADER)lpFile;
	PIMAGE_NT_HEADERS imgNtHeader = (PIMAGE_NT_HEADERS)(lpFile + imgDosHeader-&gt;e_lfanew);
	PIMAGE_OPTIONAL_HEADER imgOptionHeader = &amp;(imgNtHeader-&gt;OptionalHeader);

	DWORD bRet = imgOptionHeader-&gt;AddressOfEntryPoint;

	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);
	if (lpFile != NULL) delete[] lpFile;

	return bRet;
}

void InjectFunc()
{
	PROMOTE_DATA pData = (PROMOTE_DATA)0xCCCCCCCC;
	pData-&gt;loadLibrary(pData-&gt;path);

	char* prevcode = (char*)pData-&gt;entryPoint;
	for (int i = 0; i &lt; 0x5; i++) prevcode[i] = pData-&gt;code[i];

	unsigned point = pData-&gt;entryPoint;
	__asm
	{
		mov eax, point
		jmp eax
	}
}

void modifyEntryPoint(PROMOTE_DATA p)
{
	DWORD baseAddr= (DWORD)p-&gt;getModuleHande(0);
	p-&gt;entryPoint += baseAddr;

	DWORD lwt{};
	p-&gt;virtualProtect((LPVOID)p-&gt;entryPoint, 0x5, PAGE_EXECUTE_READWRITE, &amp;lwt);

	char *prevcode = (char*)p-&gt;entryPoint;
	for (int i = 0; i &lt; 5; ++i) p-&gt;code[i] = prevcode[i];
	prevcode[0] = 0xE9;//jmp
	unsigned distance = (unsigned)( (DWORD)p-&gt;injectAddr - p-&gt;entryPoint - 0x5);

	unsigned *_code = (unsigned*)(p-&gt;entryPoint+1);
	_code[0] = distance;

}
int main()
{
	STARTUPINFOA startUp;
	ZeroMemory(&amp;startUp, sizeof(STARTUPINFOA));
	PROCESS_INFORMATION  proInfo;
	ZeroMemory(&amp;proInfo, sizeof(PROCESS_INFORMATION));
	int bRet = CreateProcessA(exePath, NULL, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL,
		"C:\\Users\\Administrator\\Desktop\\",
		&amp;startUp, &amp;proInfo);
	if (bRet == 0)
	{
		printf("createprocess error:%d\n", GetLastError());
		return 0;
	}

	//进行入口点注入
	rotData = new ROMOTE_DATA;

	DWORD rotAddr=(DWORD)VirtualAllocEx(proInfo.hProcess, NULL, 0x3000, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	DWORD rotDataAddr = rotAddr + 0x200;
	
	initRotData();

	char modifyCode[0x200];
		
	memcpy(modifyCode, InjectFunc, sizeof(modifyCode));

	for (int i = 0; i &lt; 0x200; i++)
	{ 
		unsigned* pcode = (unsigned*)(&amp;modifyCode[i]);
		if(pcode[0] == 0xCCCCCCCC)
		{
			pcode[0] = (unsigned)rotDataAddr;
			break;
		}
	}

	DWORD injectAddr = rotAddr + 0x1000; //注入dll的函数
	rotData-&gt;injectAddr = (LPVOID)injectAddr;
	WriteProcessMemory(proInfo.hProcess, (LPVOID)rotDataAddr, rotData, 0x200, NULL);

	WriteProcessMemory(proInfo.hProcess, (LPVOID)injectAddr, modifyCode, 0x200, NULL);

	DWORD rotFuncAddr = rotAddr + 0x2000; //写入远程函数
	WriteProcessMemory(proInfo.hProcess, (LPVOID)rotFuncAddr, modifyEntryPoint, 0x500, NULL);

	HANDLE hProcHnd = CreateRemoteThread(proInfo.hProcess, NULL, 0,
		(LPTHREAD_START_ROUTINE)rotFuncAddr, (LPVOID)rotDataAddr, 0, NULL);
	if (hProcHnd != INVALID_HANDLE_VALUE) WaitForSingleObject(hProcHnd, INFINITE);
	else printf("CreateRemoteThread error : %d", GetLastError());

	//注入完成后恢复进程运行
	ResumeThread(proInfo.hThread);


	
	return 0;
}</code></pre>
<p></p>
<p></p>
<h2 id="%C2%A0APC%E6%B3%A8%E5%85%A5"> APC注入</h2>
<h3 id="一apc注入">一、APC注入</h3>
<p>什么是APC?<br/><br/><a href="https://bbs.pediy.com/thread-217298.htm#msg_header_h1_2" title="[原创]小Win，点一份APC（Apc机制详解）（一）-编程技术-看雪论坛-安全社区|安全招聘|bbs.pediy.com">[原创]小Win，点一份APC（Apc机制详解）（一）-编程技术-看雪论坛-安全社区|安全招聘|bbs.pediy.com</a><br/> 每一个线程都有自己的APC队列，使用QueueUserAPC函数把一个APC函数压入APC队列中。当处于处于用户模式的APC压入线程APC队列后，该线程并不直接调用APC函数，除非该线程处于可通知状态，调用的顺序为先入先出(FIFO)。</p>
<h3 id="二api">二、API</h3>
<p>QueueUserAPC函数<br/><a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-queueuserapc" title="QueueUserAPC function (processthreadsapi.h) - Win32 apps | Microsoft Docs">QueueUserAPC function (processthreadsapi.h) - Win32 apps | Microsoft Docs</a></p>
<h3 id="三实现">三、实现</h3>
<p>一个进程包含多个线程，为了确保能够执行插入的APC,应向目标进程的所有线程都插入相同的APC，实现加载DLL的操作<br/> 实现APC注入的具体流程如下:<br/> 首先，通过OpenProcess函数打开目标进程，获取目标进程的句柄。<br/> 然后，通过调用WIN32 API函数CreateToolhelp32Snapshot、Thread32First以及Thread32Next遍历线程快照，获取目标进程的所有ID。<br/> 接着，调用VirtualAllocEx函数在目标进程中申请内存，并通过WriteProcessMemory函数向内存中写入DLL的注入路径。<br/> 最后，遍历获取的线程ID，并调用OpenThread函数以THREAD_ALL_ACCESS访问权限打开线程，获取线程句柄。并调用QueueUserAPC函数向线程插入APC函数，设置APC函数的地址为LoadLibraryA函数的地址,并设置APC函数参数为上述DLL路径地址。</p>
<h3 id="%E5%9B%9B%E3%80%81%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81">四、示例代码</h3>
<pre><code class="language-cpp">#include "stdafx.h"
#include "ApcInject.h"


void ShowError(char *pszText)
{
	char szErr[MAX_PATH] = { 0 };
	::wsprintf(szErr, "%s Error[%d]\n", pszText);
	::MessageBox(NULL, szErr, "ERROR", MB_OK | MB_ICONERROR);
}


// 根据进程名称获取PID
DWORD GetProcessIdByProcessName(char *pszProcessName)
{
	DWORD dwProcessId = 0;
	PROCESSENTRY32 pe32 = { 0 };
	HANDLE hSnapshot = NULL;
	BOOL bRet = FALSE;
	::RtlZeroMemory(&amp;pe32, sizeof(pe32));
	pe32.dwSize = sizeof(pe32);

	// 获取进程快照
	hSnapshot = ::CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	if (NULL == hSnapshot)
	{
		ShowError("CreateToolhelp32Snapshot");
		return dwProcessId;
	}

	// 获取第一条进程快照信息
	bRet = ::Process32First(hSnapshot, &amp;pe32);
	while (bRet)
	{
		// 获取快照信息
		if (0 == ::lstrcmpi(pe32.szExeFile, pszProcessName))
		{
			dwProcessId = pe32.th32ProcessID;
			break;
		}

		// 遍历下一个进程快照信息
		bRet = ::Process32Next(hSnapshot, &amp;pe32);
	}

	return dwProcessId;
}


// 根据PID获取所有的相应线程ID
BOOL GetAllThreadIdByProcessId(DWORD dwProcessId, DWORD **ppThreadId, DWORD *pdwThreadIdLength)
{
	DWORD *pThreadId = NULL;
	DWORD dwThreadIdLength = 0;
	DWORD dwBufferLength = 1000;
	THREADENTRY32 te32 = { 0 };
	HANDLE hSnapshot = NULL;
	BOOL bRet = TRUE;

	do
	{
		// 申请内存
		pThreadId = new DWORD[dwBufferLength];
		if (NULL == pThreadId)
		{
			ShowError("new");
			bRet = FALSE;
			break;
		}
		::RtlZeroMemory(pThreadId, (dwBufferLength * sizeof(DWORD)));

		// 获取线程快照
		::RtlZeroMemory(&amp;te32, sizeof(te32));
		te32.dwSize = sizeof(te32);
		hSnapshot = ::CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
		if (NULL == hSnapshot)
		{
			ShowError("CreateToolhelp32Snapshot");
			bRet = FALSE;
			break;
		}

		// 获取第一条线程快照信息
		bRet = ::Thread32First(hSnapshot, &amp;te32);
		while (bRet)
		{
			// 获取进程对应的线程ID
			if (te32.th32OwnerProcessID == dwProcessId)
			{
				pThreadId[dwThreadIdLength] = te32.th32ThreadID;
				dwThreadIdLength++;
			}

			// 遍历下一个线程快照信息
			bRet = ::Thread32Next(hSnapshot, &amp;te32);
		}

		// 返回
		*ppThreadId = pThreadId;
		*pdwThreadIdLength = dwThreadIdLength;
		bRet = TRUE;

	} while (FALSE);

	if (FALSE == bRet)
	{
		if (pThreadId)
		{
			delete[]pThreadId;
			pThreadId = NULL;
		}
	}

	return bRet;
}


// APC注入
BOOL ApcInjectDll(char *pszProcessName, char *pszDllName)
{
	BOOL bRet = FALSE;
	DWORD dwProcessId = 0;
	DWORD *pThreadId = NULL;
	DWORD dwThreadIdLength = 0;
	HANDLE hProcess = NULL, hThread = NULL;
	PVOID pBaseAddress = NULL;
	PVOID pLoadLibraryAFunc = NULL;
	SIZE_T dwRet = 0, dwDllPathLen = 1 + ::lstrlen(pszDllName);
	DWORD i = 0;

	do
	{
		// 根据进程名称获取PID
		dwProcessId = GetProcessIdByProcessName(pszProcessName);
		if (0 &gt;= dwProcessId)
		{
			bRet = FALSE;
			break;
		}

		// 根据PID获取所有的相应线程ID
		bRet = GetAllThreadIdByProcessId(dwProcessId, &amp;pThreadId, &amp;dwThreadIdLength);
		if (FALSE == bRet)
		{
			bRet = FALSE;
			break;
		}

		// 打开注入进程
		hProcess = ::OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessId);
		if (NULL == hProcess)
		{
			ShowError("OpenProcess");
			bRet = FALSE;
			break;
		}

		// 在注入进程空间申请内存
		pBaseAddress = ::VirtualAllocEx(hProcess, NULL, dwDllPathLen, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
		if (NULL == pBaseAddress)
		{
			ShowError("VirtualAllocEx");
			bRet = FALSE;
			break;
		}
		// 向申请的空间中写入DLL路径数据 
		::WriteProcessMemory(hProcess, pBaseAddress, pszDllName, dwDllPathLen, &amp;dwRet);
		if (dwRet != dwDllPathLen)
		{
			ShowError("WriteProcessMemory");
			bRet = FALSE;
			break;
		}

		// 获取 LoadLibrary 地址
		pLoadLibraryAFunc = ::GetProcAddress(::GetModuleHandle("kernel32.dll"), "LoadLibraryA");
		if (NULL == pLoadLibraryAFunc)
		{
			ShowError("GetProcessAddress");
			bRet = FALSE;
			break;
		}

		// 遍历线程, 插入APC
		for (i = 0; i &lt; dwThreadIdLength; i++)
		{
			// 打开线程
			hThread = ::OpenThread(THREAD_ALL_ACCESS, FALSE, pThreadId[i]);
			if (hThread)
			{
				// 插入APC
				::QueueUserAPC((PAPCFUNC)pLoadLibraryAFunc, hThread, (ULONG_PTR)pBaseAddress);
				// 关闭线程句柄
				::CloseHandle(hThread);
				hThread = NULL;
			}
		}

		bRet = TRUE;

	} while (FALSE);

	// 释放内存
	if (hProcess)
	{
		::CloseHandle(hProcess);
		hProcess = NULL;
	}
	if (pThreadId)
	{
		delete[]pThreadId;
		pThreadId = NULL;
	}

	return bRet;
}</code></pre>
<p></p>
</div>
</div>