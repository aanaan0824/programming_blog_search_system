<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<h1 id="main-toc"><strong>目录：</strong></h1>
<p id="%C2%A01.DFS%EF%BC%88%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95%EF%BC%89-toc" style="margin-left:0px;"><a href="#%C2%A01.DFS%EF%BC%88%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95%EF%BC%89"> 1.DFS（单源最短路径算法）</a></p>
<p id="%E4%BE%8B%E9%A2%981%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E4%BE%8B%E9%A2%981%EF%BC%9A">例题1：</a></p>
<p id="%C2%A0DFS%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%C2%A0DFS%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90%EF%BC%9A"> DFS题目分析：</a></p>
<p id="%E4%BB%A3%E7%A0%81DFS%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E4%BB%A3%E7%A0%81DFS%EF%BC%9A">代码DFS：</a></p>
<p id="%C2%A02.Floyed%EF%BC%88%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6On%5E3%EF%BC%89-toc" style="margin-left:0px;"><a href="#%C2%A02.Floyed%EF%BC%88%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6On%5E3%EF%BC%89"> 2.Floyed（时间复杂度On^3）</a></p>
<p id="1.%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A-toc" style="margin-left:40px;"><a href="#1.%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A">1.应用场景：</a></p>
<p id="2.%E8%A7%A3%E6%9E%90%E7%AE%97%E6%B3%95%EF%BC%9A%C2%A0%20%C2%A0%C2%A0-toc" style="margin-left:40px;"><a href="#2.%E8%A7%A3%E6%9E%90%E7%AE%97%E6%B3%95%EF%BC%9A%C2%A0%20%C2%A0%C2%A0">2.解析算法：    </a></p>
<p id="%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%811%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%811%EF%BC%9A">核心代码1：</a></p>
<p id="%E6%88%91%E7%9A%84%E7%AC%94%E8%AE%B0-toc" style="margin-left:80px;"><a href="#%E6%88%91%E7%9A%84%E7%AC%94%E8%AE%B0">我的笔记</a></p>
<p id="%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%812%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%812%EF%BC%9A">核心代码2：</a></p>
<p id="%C2%A0Floyd%E4%BE%8B%E9%A2%98%EF%BC%9AAcWing%20854%20Floyd%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF-toc" style="margin-left:80px;"><a href="#%C2%A0Floyd%E4%BE%8B%E9%A2%98%EF%BC%9AAcWing%20854%20Floyd%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF"> Floyd例题：</a></p>
<p id="3.Dijksyta%E7%AE%97%E6%B3%95-toc" style="margin-left:0px;"><a href="#3.Dijksyta%E7%AE%97%E6%B3%95">3.Dijksyta算法</a></p>
<p id="1.%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A%E5%8D%95%E6%BA%90%E8%B7%AF%E5%BE%84%E6%9C%80%E7%9F%AD%EF%BC%88%E6%88%91%E5%8F%AA%E7%9C%8B%E5%87%BA%E6%9D%A5%E4%BA%86%E8%BF%99%E7%A7%8D%EF%BC%89%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6(On%5E2)-toc" style="margin-left:40px;"><a href="#1.%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A%E5%8D%95%E6%BA%90%E8%B7%AF%E5%BE%84%E6%9C%80%E7%9F%AD%EF%BC%88%E6%88%91%E5%8F%AA%E7%9C%8B%E5%87%BA%E6%9D%A5%E4%BA%86%E8%BF%99%E7%A7%8D%EF%BC%89%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%28On%5E2%29">1.应用场景：</a></p>
<p id="2.%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0%EF%BC%9A-toc" style="margin-left:40px;"><a href="#2.%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0%EF%BC%9A">2.算法描述：</a></p>
<p id="1.%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9A-toc" style="margin-left:80px;"><a href="#1.%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9A">1.初始化：</a></p>
<p id="2.for%EF%BC%9A-toc" style="margin-left:80px;"><a href="#2.for%EF%BC%9A">2.for：</a></p>
<p id="%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81%EF%BC%9A">核心代码：</a></p>
<p id="3.%E4%BE%8B%E9%A2%98%EF%BC%9A%EF%BC%88%E6%94%B9%E9%A2%98%E7%9B%AE%E6%9D%A5%E6%BA%90%E4%BA%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%EF%BC%89-toc" style="margin-left:40px;"><a href="#3.%E4%BE%8B%E9%A2%98%EF%BC%9A%EF%BC%88%E6%94%B9%E9%A2%98%E7%9B%AE%E6%9D%A5%E6%BA%90%E4%BA%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%EF%BC%89">3.例题：</a></p>
<p id="%C2%A0%E6%B3%A8%E6%84%8F%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%C2%A0%E6%B3%A8%E6%84%8F%EF%BC%9A"> 注意：</a></p>
<p id="%C2%A0%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%C2%A0%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%EF%BC%9A"> 代码如下：</a></p>
<p id="4.SPFA%E7%AE%97%E6%B3%95-toc" style="margin-left:0px;"><a href="#4.SPFA%E7%AE%97%E6%B3%95">4.SPFA算法</a></p>
<p id="1.%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3%EF%BC%9A-toc" style="margin-left:40px;"><a href="#1.%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3%EF%BC%9A">1.算法思想：</a></p>
<p id="2.%E6%B3%A8%E6%84%8F%EF%BC%9A-toc" style="margin-left:40px;"><a href="#2.%E6%B3%A8%E6%84%8F%EF%BC%9A">2.注意：</a></p>
<p id="3.%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A-toc" style="margin-left:40px;"><a href="#3.%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A">3.算法分析：</a></p>
<p id="4.%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81%EF%BC%9A-toc" style="margin-left:40px;"><a href="#4.%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81%EF%BC%9A">4.核心代码：</a></p>
<p id="5.%E4%BE%8B%E9%A2%98%EF%BC%9AP3371%20%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%EF%BC%88%E5%BC%B1%E5%8C%96%E7%89%88%EF%BC%89%20-%20%E6%B4%9B%E8%B0%B7%20%7C%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E6%95%99%E8%82%B2%E6%96%B0%E7%94%9F%E6%80%81%20(luogu.com.cn)-toc" style="margin-left:40px;"><a href="#5.%E4%BE%8B%E9%A2%98%EF%BC%9AP3371%20%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%EF%BC%88%E5%BC%B1%E5%8C%96%E7%89%88%EF%BC%89%20-%20%E6%B4%9B%E8%B0%B7%20%7C%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E6%95%99%E8%82%B2%E6%96%B0%E7%94%9F%E6%80%81%20%28luogu.com.cn%29">5.例题：</a></p>
<p id="%C2%A0%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%C2%A0%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90%EF%BC%9A"> 题目分析：</a></p>
<p id="%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%EF%BC%9A">代码如下：</a></p>
<p id="%E6%80%BB%E7%BB%93%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E6%80%BB%E7%BB%93%EF%BC%9A">5.总结：</a></p>
<p><span style="color:#956fe7;"><strong>那让我为大家介绍这四种算法吧！</strong></span></p>
<h1 id="%C2%A01.DFS%EF%BC%88%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95%EF%BC%89"> <span style="color:#0d0016;">1.DFS（单源最短路径算法）</span></h1>
<h2 id="%E4%BE%8B%E9%A2%981%EF%BC%9A"><strong><span style="color:#0d0016;">例题1：</span></strong></h2>
<blockquote>
<p><span style="color:#0d0016;">        建立一个有向图，n代表城市个数，有m行连接数据，x代表连接初始点，y代表连接点，r代表线权。求城市1到城市5的最短路径。</span></p>
</blockquote>
<p><img alt="" height="328" src="image\2461dc7f80a74f1ab39bd09dfed6a054.png" width="662"/></p>
<p></p>
<p><strong>输入：</strong></p>
<pre><code class="language-cpp">5 8
1 2 2
2 3 3
3 4 4
4 5 5
5 3 3
1 5 10
3 1 4
2 5 7</code></pre>
<p><strong>输出：</strong></p>
<pre><code>9</code></pre>
<blockquote>
<h2 id="%C2%A0DFS%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90%EF%BC%9A"><strong> DFS题目分析</strong>：</h2>
<p>        用dfs进行搜索的话，递归的出口是什么？-&gt;</p>
<p>        当然是扫描到最后一个城市的时候，然后记录下此时的路径值，如果之后搜索的测试值比之前的值小，则更新路径的值，搜索完所有的路径后，输出<strong>最小值</strong>，其中用<strong>VIS数组</strong>进行标记和回溯。</p>
</blockquote>
<h3 id="%E4%BB%A3%E7%A0%81DFS%EF%BC%9A"><strong>代码DFS：</strong></h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
//从城市1到城市5最短路径为多少？
int mp[105][105];//图
int vis[105];//测试数组
int x, y, r;
int n; int m;
int minx = 1000000;
void dfs(int step, int sum) {
	if (sum &gt; minx) {
		return;
	}
	if (step == n) {//当扫描到最后一个城市时		
		if(sum&lt;minx){
			minx = sum;//更新
			return;
		}
	}
	for (int i = 1; i &lt;=n; i++) {
		if (mp[step][i] != 0 &amp;&amp;vis[i]==0) {//该点没有被标记，且该点存在连接
			vis[i] = 1;
			dfs(i, sum + mp[step][i]);
			vis[i] = 0;
		}
	}
}
int main()
{
	cin &gt;&gt; n&gt;&gt;m;
	while (m--) {
		cin &gt;&gt; x &gt;&gt; y &gt;&gt; r;
		mp[x][y] = r;//该图为有向图，是由x到y的距离
	}
	dfs(1, 0);
	cout &lt;&lt; minx &lt;&lt; endl;
}</code></pre>
<h1 id="%C2%A02.Floyed%EF%BC%88%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6On%5E3%EF%BC%89"> 2<span style="color:#0d0016;">.Floyed（时间复杂度On^3）</span></h1>
<h2 id="1.%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A"><span style="color:#0d0016;"><strong>1.应用场景</strong>：</span></h2>
<p><span style="color:#0d0016;">1.多源最短路径。（缺点：时间复杂度相对较高，但是可以解决负权边问题）</span></p>
<p><span style="color:#0d0016;">2.找最小环。</span></p>
<p><span style="color:#0d0016;">3.倍增。</span></p>
<h2 id="2.%E8%A7%A3%E6%9E%90%E7%AE%97%E6%B3%95%EF%BC%9A%C2%A0%20%C2%A0%C2%A0"><span style="color:#0d0016;">2.解析算法：    </span></h2>
<p><span style="color:#0d0016;">        通过插入点和中转点来缩短路径，先将图中各点连线都初始化为无穷，再进行建图，中转所有的点，不断更新最小值输出：</span></p>
<h3 id="%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%811%EF%BC%9A"><span style="color:#0d0016;">核心代码1：</span></h3>
<pre><code class="language-cpp"> for (int k = 1; k &lt;= n; k++) {//从1到n依次各点进行中转
        for (int i = 1; i &lt;= n; i++) {
            for (int j = 1; j &lt;= n; j++) {
                if (e[i][j] &gt; e[i][k] + e[k][j]) {//如果该路径更短，更新成该路径
                    e[i][j] = e[i][k] + e[k][j];
                }
            }
        }
    }</code></pre>
<h3 id="%E6%88%91%E7%9A%84%E7%AC%94%E8%AE%B0"><strong>我的笔记</strong></h3>
<p>然后就是<strong>我的笔记</strong>啦：（还是比较详细的）</p>
<p><img alt="" height="894" src="image\8225ea37ee5847a085d5ec79d8b968d0.png" width="613"/></p>
<p>         这里由不得思考一个问题，Floyd算法无非就是动态规划，<span style="color:#fe2c24;"><strong>状态转移方程</strong></span>为<img alt="e[i][j]=max(e[i][j],e[i][k]+e[k][j])" class="mathcode" src="https://latex.codecogs.com/gif.latex?e%5Bi%5D%5Bj%5D%3Dmax%28e%5Bi%5D%5Bj%5D%2Ce%5Bi%5D%5Bk%5D&amp;plus;e%5Bk%5D%5Bj%5D%29"/></p>
<h3 id="%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%812%EF%BC%9A">核心代码2：</h3>
<pre><code class="language-cpp">void floyed(){
    for (int k = 1; k &lt;= n; k++) {//从1到n依次各点进行中转
        for (int i = 1; i &lt;= n; i++) {
            for (int j = 1; j &lt;= n; j++) {
                if (e[i][j] &gt; e[i][k] + e[k][j]) {//如果该路径更短，更新成该路径
                    e[i][j] = max(e[i][j],e[i][k] + e[k][j]);
                }
            }
        }
    }
}</code></pre>
<h3 id="%C2%A0Floyd%E4%BE%8B%E9%A2%98%EF%BC%9AAcWing%20854%20Floyd%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF"> Floyd例题：</h3>
<p><strong>AcWing 854 Floyd求最短路</strong></p>
<p>题目描述：</p>
<p>给定一个n个点m条边的有向图，图中可能存在重边和自环，边权可能为负数。</p>
<p>再给定k个询问，每个询问包含两个整数x和y，表示查询从点x到点y的最短距离，如果路径不存在，则输出“impossible”。</p>
<p>数据保证图中<strong>不存在负权回路</strong>。</p>
<p><strong>输入格式</strong></p>
<p>第一行包含三个整数n，m，k</p>
<p>接下来m行，每行包含三个整数x，y，z，表示点x和点y之间存在一条有向边，边长为z。</p>
<p>接下来k行，每行包含两个整数x，y，表示询问点x到点y的最短距离。</p>
<p>输出格式</p>
<p>共k行，每行输出一个整数，表示询问的结果（<strong>最小路径</strong>），若询问两点间不存在路径，则输出“impossible”。</p>
<p><strong>数据范围</strong></p>
<p>1≤n≤200,<br/> 1≤k≤n^2<br/> 1≤m≤20000,<br/> 图中涉及边长绝对值均不超过10000。</p>
<p><strong>输入：</strong></p>
<pre><code>3 3 2
1 2 1
2 3 2
1 3 1
2 1
1 3</code></pre>
<p><strong>输出：</strong></p>
<pre><code class="language-cpp">impossible
1</code></pre>
<p><strong>题目注意：</strong></p>
<p>1.初始图矩阵的建立。</p>
<p>2.如果有重复的边如何处理。</p>
<p>3.输出的时候如何判断x，y没有路径。</p>
<p><strong>代码如下：</strong></p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
const int INF = 1e9;
int n, m, k;
int x, y, r;
int e[300][300];
void floyed() {
    for (int k = 1; k &lt;= n; k++) {//从1到n依次各点进行中转
        for (int i = 1; i &lt;= n; i++) {
            for (int j = 1; j &lt;= n; j++) {
                if (e[i][j] &gt; e[i][k] + e[k][j]) {//如果该路径更短，更新成该路径
                    e[i][j] = max(e[i][j], e[i][k] + e[k][j]);
                }
            }
        }
    }
}
int main()
{
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;
    for (int i = 1; i &lt;= n; i++) {//建立初始的图，赋值
        for (int j = 1; j &lt;= n; j++) {
            if (i == j) {
                e[i][j] = 0;
            }
            else {
                e[i][j] = INF;
            }
        }
    }
    while (m--) {
        cin &gt;&gt; x &gt;&gt; y &gt;&gt; r;
        e[x][y] = min(e[x][y], r);//处理重复边的值
    }
    floyed();
    while(k--)
    {
        cin &gt;&gt; x &gt;&gt; y;
        if (e[x][y] &gt; INF / 2) {//说明x到y没有路可以走
            cout &lt;&lt; "impossible" &lt;&lt; endl;
        }
        else {
            cout &lt;&lt; e[x][y] &lt;&lt; endl;//输出最短路径
        }
    }
}
</code></pre>
<p>         今天的分享暂时先到这里，明天持续更新.....</p>
<h1 id="3.Dijksyta%E7%AE%97%E6%B3%95">3.Dijksyta算法</h1>
<h2 id="1.%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A%E5%8D%95%E6%BA%90%E8%B7%AF%E5%BE%84%E6%9C%80%E7%9F%AD%EF%BC%88%E6%88%91%E5%8F%AA%E7%9C%8B%E5%87%BA%E6%9D%A5%E4%BA%86%E8%BF%99%E7%A7%8D%EF%BC%89%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6(On%5E2)">1.应用场景：</h2>
<p><strong>单源路径最短（<s>我只看出来了这种</s>）时间复杂度(On^2)</strong></p>
<p><strong>注意</strong>：不能求<span style="color:#fe2c24;"><strong>负权值</strong></span>.</p>
<h2 id="2.%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0%EF%BC%9A">2.算法描述：</h2>
<p>设起点为x，dis[v]表示s到v的最短路径</p>
<h3 id="1.%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9A"><strong>1.初始化</strong>：</h3>
<p><strong><span style="color:#fe2c24;">起点初始化为0。其余点初始化为无穷大</span></strong></p>
<h3 id="2.for%EF%BC%9A"><strong>2.for：</strong></h3>
<p>a.在没有访问的顶点中找到一个顶点u，使得dis[u]是最小的。（不断搜索到下一个路径最小的点，更新）。</p>
<p>b.u为已确定的最短路径（将不再对该点及之前的点进行搜索）。</p>
<h3 id="%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81%EF%BC%9A">核心代码：</h3>
<pre><code class="language-cpp">int dijkstra(int n, int m) {//n为顶点数，m为起点开始的位置   
    while (true) {
        fill(dis, dis + maxn, INF);
        dis[m] = 0;//初始化起点为0
        int index = -1;
        int minx = 0;//定义
        for (int i = 1; i &lt;= n; i++) {
            if (!vis[i] &amp;&amp; minx &gt; dis[i]) {//寻找到该点
                index = i;
                minx = dis[i];
            }
        }
        if (index == -1) {//说明没有点可以继续搜索了
            break;//退出循环条件
        }
        vis[index] = 1;//已经确定该点为最短路径点了，标记上踢出
        for (int j = 1; j &lt;= n; j++) {
            if (dis[j] &gt; dis[index] + mp[index][j]&amp;&amp;vis[j]==0&amp;&amp;mp[index][j]!=INF) {//该点有路可以走
                dis[j] = dis[index] + mp[index][j];//值得思考有DP思想
            }
        }
    }
}</code></pre>
<h2 id="3.%E4%BE%8B%E9%A2%98%EF%BC%9A%EF%BC%88%E6%94%B9%E9%A2%98%E7%9B%AE%E6%9D%A5%E6%BA%90%E4%BA%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%EF%BC%89"><strong>3.例题：</strong></h2>
<p><strong>（改题目来源于算法笔记）</strong></p>
<p><img alt="" height="522" src="image\6f89ffe4a1dd4b7487faa4f8c76860cd.png" width="578"/></p>
<p><strong>题目要求</strong>：求V0到其他位置s的最短路径。</p>
<p><strong>输入格式</strong>：</p>
<p>n为有几个顶点，m为几条边，s为起点。</p>
<p>第二行到第m+1行输入x,y,r，分别为x结点到y结点，边权为r。</p>
<p><strong>输出格式：</strong>从s到个顶点的最短路径。</p>
<p><strong>输入：</strong></p>
<pre><code>6 8 0
0 1 1
0 3 4
0 4 4
1 3 2
2 5 1
3 2 2
3 4 3
4 5 3</code></pre>
<p><strong>输出：</strong></p>
<pre><code>0 1 5 3 4 6</code></pre>
<p> <strong>题目分析</strong>： 不断去找路径最短的那个顶点，标记，搜索下一个最短顶点即可。（图示-&gt;）</p>
<p><img alt="" height="780" src="image\c336cd08fe20406c9c2fcf64ee60fafb.png" width="348"/></p>
<h3 id="%C2%A0%E6%B3%A8%E6%84%8F%EF%BC%9A"><strong> 注意：</strong></h3>
<p>1.vis数组的标记。</p>
<p>2.更新顶点，没有路径的点就不进行扫描。</p>
<p>3.循环的终止条件。</p>
<h3 id="%C2%A0%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%EF%BC%9A"> 代码如下：</h3>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
using namespace std;
const int maxn = 1000;//规定一个最大顶点数
const int INF = 199999999;
int n, m, s;
int mp[maxn][maxn];
int dis[maxn];
bool vis[maxn] = { false };
void Dijkstra(int s) {
	memset(dis, 0x7f, sizeof(dis));
	dis[s] = 0;
	for (int i = 1; i &lt;= n; i++) {//循环了n次
		int index = -1;
		int minx = INF;
		for (int j = 0; j &lt; n; j++) {
			if (vis[j] == false &amp;&amp; dis[j] &lt; minx) {
				index = j;//记录这个搜索到的路径最小的点。
				minx = dis[j];//更新最小值
			}
		}
		if (index == -1) {//没有路可以走了
			return;
		}
		vis[index] = true;//标记该点
		for (int i = 0; i &lt; n; i++) {
			if (vis[i] == false &amp;&amp; mp[index][i] != INF &amp;&amp; dis[index] + mp[index][i] &lt; dis[i]) {
				dis[i] = dis[index] + mp[index][i];//优化更新dis[i]
			}
		}
	}
}
int main() {
	int x, y, r;
	cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;
	memset(mp, 0x7f, sizeof(mp));
	for (int i = 1; i &lt;= m; i++) {
		cin &gt;&gt; x &gt;&gt; y &gt;&gt; r;
		mp[x][y] = r;
	}
	Dijkstra(s);//将起点输入进去
	for (int i = 0; i &lt; n; i++) {
		cout &lt;&lt; dis[i] &lt;&lt; " ";
	}
	return 0;
}
</code></pre>
<p>      完美撒花！继续更新SPFA算法。  </p>
<h1 id="4.SPFA%E7%AE%97%E6%B3%95">4.SPFA算法</h1>
<h2 id="1.%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3%EF%BC%9A"><strong>1.算法思想：</strong></h2>
<p><strong>队列优化，</strong>去掉一些无用的松弛操作，用队列来维护松弛造作的点。继承了<strong>Bellman-Ford算法</strong>的思想，但时间复杂度相对来说提高了很多。</p>
<p>与BFS的算法有一些类似，利用了STL队列。</p>
<h2 id="2.%E6%B3%A8%E6%84%8F%EF%BC%9A"><strong>2.注意：</strong></h2>
<p>虽然大多数情况spfa跑的比较快，但时间复杂度仍为（Onm），主要用应用于有负边权的情况（如果没有负边权，推荐使用<strong>Dijkstra</strong>算法）。利用了<span style="color:#fe2c24;"><strong>邻接表建图</strong></span>，数据结构的基础一定要掌握好，而且该算法很容易超时，被卡，必须要谨慎选择该算法。</p>
<h2 id="3.%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A"><strong>3.算法分析：</strong></h2>
<blockquote>
<p>1.用<strong>dis数组</strong>记录点到有向图的任意一点距离，初始化起点距离为0，其余点均为INF，起点入队。</p>
<p>2.判断该点是否存在。（未存在就入队，标记）</p>
<p>3.队首出队，<strong>并将该点标记为没有访问过</strong>，方便下次入队。</p>
<p>4.遍历以对首为起点的有向边（t,i）,如果<span style="color:#fe2c24;"><strong>dis[i]&gt;dis[t]+w(t,i)</strong></span>,则更新dis[i]。</p>
<p>5.如果i不在队列中，则入队标记，一直到循环为空。</p>
</blockquote>
<h2 id="4.%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81%EF%BC%9A">4.核心代码：</h2>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
using namespace std;
const int INF = 1000000000;
const int maxn = 1000;
int dis[maxn];//记录最小路径的数组
bool vis[maxn];//标记
struct node {
    int s1;//记录结点
    int side;//边权
};
vector&lt;node&gt;mp[maxn];//用vector建立邻接表
void Spfa(int s) {
    queue&lt;int&gt;v;
    vis[s] = 1; v.push(s); dis[s] = 0;
    while (!v.empty()) {
        int q = v.front();
        v.pop(); vis[q] = 0;
        for (int i = 0; i &lt; mp[q].size(); i++) {
            if (dis[mp[q][i].s1] &gt; dis[q] + mp[q][i].side) {
                dis[mp[q][i].s1] = dis[q] + mp[q][i].side;//更新最短路径。            
                if (!vis[mp[q][i].s1]) {//是在更新新的值条件里面判断，一定特别注意这点
                    v.push(mp[q][i].s1);
                    vis[mp[q][i].s1] = 1;//标记未标记过的点
                }
            }
        }
    }
}</code></pre>
<p> 完美撒花！！！</p>
<h2 id="5.%E4%BE%8B%E9%A2%98%EF%BC%9AP3371%20%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%EF%BC%88%E5%BC%B1%E5%8C%96%E7%89%88%EF%BC%89%20-%20%E6%B4%9B%E8%B0%B7%20%7C%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E6%95%99%E8%82%B2%E6%96%B0%E7%94%9F%E6%80%81%20(luogu.com.cn)">5.例题：</h2>
<p><a href="https://www.luogu.com.cn/problem/P3371" title="P3371 【模板】单源最短路径（弱化版） - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)">P3371 【模板】单源最短路径（弱化版） - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<p><strong>题目背景：</strong></p>
<p>本题测试数据为随机数据，在考试中可能会出现构造数据让SPFA不通过（<s><strong><span style="color:#fe2c24;">但本题可以用SPFA过</span></strong></s>），如有需要请移步 <a href="https://www.luogu.org/problemnew/show/P4779" title="P4779">P4779</a></p>
<p><strong>题目描述：</strong></p>
<p>如题，给出一个<span style="color:#fe2c24;"><strong>有向图</strong></span>，请输出从某一点出发到所有点的最短路径长度。</p>
<h2 id="%E2%80%8B"><img alt="" height="278" src="image\247be8c8773d480e8132c3c41ea53920.png" width="942"/></h2>
<p><strong>输入输出样例：</strong></p>
<p><strong>输入 ：</strong></p>
<pre><code class="language-cpp">4 6 1
1 2 2
2 3 2
2 4 1
1 3 5
3 4 3
1 4 4</code></pre>
<p><strong>输出 ：</strong></p>
<pre><code>0 2 4 3</code></pre>
<p><img alt="" height="329" src="image\c4b4e8418de546e387b444b8c86e1981.png" width="991"/><strong> 样例说明：</strong></p>
<p class="img-center"><img alt="" height="422" src="image\4dae5efb65b67b0b87a40f5d41d387ad.png" width="572"/></p>
<p>图片1到3和1到4的文字位置调换</p>
<h3 id="%C2%A0%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90%EF%BC%9A"><strong> 题目分析</strong>：</h3>
<p>建立一个<strong>有向图</strong>，输出s到第i个结点的最短距离。（<strong><s><span style="color:#fe2c24;">无疑是套刚刚那个模板</span></s></strong>）</p>
<h3 id="%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%EF%BC%9A"><strong>代码如下：</strong></h3>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 10001;
const long long INF = 2147483647;
int dis[maxn];//记录最小路径的数组
int vis[maxn];//标记
int n, m, s;
struct node {
    int s1;//记录结点
    int side;//边权
};
void init() {
    for (int i = 1; i &lt;= n; i++) {
        dis[i] = INF;
        vis[i] = 0;
    }
}
vector&lt;node&gt;mp[maxn];//用vector建立邻接表
void Spfa(int s) {
    queue&lt;int&gt;v;   
    vis[s] = 1; v.push(s); dis[s] = 0;
    while (!v.empty()) {
        int q = v.front();
        v.pop(); vis[q] = 0;
        for (int i = 0; i &lt; mp[q].size(); i++) {
            if (dis[mp[q][i].s1] &gt; dis[q] + mp[q][i].side) {
                dis[mp[q][i].s1] = dis[q] + mp[q][i].side;//更新最短路径。
                if (vis[mp[q][i].s1]) {
                    continue;//如果已经标记，则继续下一次循环
                }
                v.push(mp[q][i].s1);
            }
            
        }
    }
}
int main()
{
    int x, y, r;
   
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;
    init();
    while (m--) {
        node h;
        cin &gt;&gt; x &gt;&gt; y &gt;&gt; r;
        h.s1 = y;//因为该图为有向图，记录指向的结点
        h.side = r;//记录路径
        mp[x].push_back(h);
    }
    Spfa(s);
    for (int i = 1; i &lt;= n; i++) {        
            cout &lt;&lt; dis[i] &lt;&lt; " ";
    }
} 
</code></pre>
<p>        于是我-&gt;<img alt="" height="612" src="image\1198a793066d4add87080fb7048c250e.png" width="1200"/></p>
<p>         AC了，那SPFA算法就到此结束了，总体来说注意细节，在数据较大时候谨慎使用.</p>
<h1 id="%E6%80%BB%E7%BB%93%EF%BC%9A">5.总结：</h1>
<blockquote>
<p>1.DFS，Dijkstra，SPFA主要解决<strong>单源最短路径</strong>。</p>
<p>2.Floyed时间复杂度较高，但是可以解决多源最短路径。</p>
<p>3.Dijkstra虽然效率比较高，但是<strong>无法解决负权值</strong>的问题。</p>
<p>4.SPFA在数据较大的时候容易被卡，但更加有利于解决有负边权的情况，以及判断是否有负环。</p>
<p>5.在图论中一定要掌握好<strong>邻接表和邻接矩阵</strong>的建立。</p>
</blockquote>
<p>         基础知识充分了解之后，就是形成知识网络练习的过程了，希望阅读该文章后能让自己以及读者在图论方面有更深刻得到理解。图，何止是图！！！</p>
</div>
</div>