<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<p id="main-toc"><strong>目录</strong></p>
<p id="%E4%B8%80%E3%80%81%E9%9C%80%E6%B1%82-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E9%9C%80%E6%B1%82">一、需求</a></p>
<p id="%E4%BA%8C%E3%80%81%E6%9B%B4%E6%96%B0%E6%96%87%E4%BB%B6%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%99%A8-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E6%9B%B4%E6%96%B0%E6%96%87%E4%BB%B6%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%99%A8">二、更新文件列表生成器</a></p>
<p id="%E4%B8%89%E3%80%81%E8%BD%AF%E4%BB%B6%E5%90%AF%E5%8A%A8%E5%99%A8-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E8%BD%AF%E4%BB%B6%E5%90%AF%E5%8A%A8%E5%99%A8">三、软件启动器</a></p>
<p id="1.%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E6%9B%B4%E6%96%B0-toc" style="margin-left:40px;"><a href="#1.%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E6%9B%B4%E6%96%B0">1.判断是否需要更新</a></p>
<p id="1%EF%BC%89%E6%A3%80%E6%B5%8B%E5%88%B0%E6%96%B0%E7%89%88%E6%9C%AC%EF%BC%8C%E6%98%AF%E5%90%A6%E6%9B%B4%E6%96%B0%E8%BD%AF%E4%BB%B6-toc" style="margin-left:80px;"><a href="#1%EF%BC%89%E6%A3%80%E6%B5%8B%E5%88%B0%E6%96%B0%E7%89%88%E6%9C%AC%EF%BC%8C%E6%98%AF%E5%90%A6%E6%9B%B4%E6%96%B0%E8%BD%AF%E4%BB%B6">1）检测到新版本，是否更新软件</a></p>
<p id="2%EF%BC%89%E7%89%88%E6%9C%AC%E8%BF%87%E6%97%A7%EF%BC%8C%E8%AF%B7%E6%9B%B4%E6%96%B0%E5%88%B0%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC-toc" style="margin-left:80px;"><a href="#2%EF%BC%89%E7%89%88%E6%9C%AC%E8%BF%87%E6%97%A7%EF%BC%8C%E8%AF%B7%E6%9B%B4%E6%96%B0%E5%88%B0%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC">2）版本过旧，请更新到最新版本</a></p>
<p id="3%EF%BC%89%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD-toc" style="margin-left:40px;"><a href="#3%EF%BC%89%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD">2.文件下载</a></p>
<p id="4%EF%BC%89%E6%89%A7%E8%A1%8C%20%E4%B8%8B%E8%BD%BD%EF%BC%8C%E8%A6%86%E7%9B%96%EF%BC%8C%E5%88%A0%E9%99%A4%20%E4%BB%BB%E5%8A%A1-toc" style="margin-left:40px;"><a href="#4%EF%BC%89%E6%89%A7%E8%A1%8C%20%E4%B8%8B%E8%BD%BD%EF%BC%8C%E8%A6%86%E7%9B%96%EF%BC%8C%E5%88%A0%E9%99%A4%20%E4%BB%BB%E5%8A%A1">3.执行 下载，覆盖，删除任务</a></p>
<p id="5%EF%BC%89%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C-toc" style="margin-left:40px;"><a href="#5%EF%BC%89%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C">4.执行结果</a></p>
<p id="%E5%9B%9B%E3%80%81%E6%90%AD%E5%BB%BA%E6%9B%B4%E6%96%B0%E6%9C%8D%E5%8A%A1%E5%99%A8-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E6%90%AD%E5%BB%BA%E6%9B%B4%E6%96%B0%E6%9C%8D%E5%8A%A1%E5%99%A8">四、搭建更新服务器</a></p>
<p id="%E4%BA%94%E3%80%81%E6%B5%8B%E8%AF%95-toc" style="margin-left:0px;"><a href="#%E4%BA%94%E3%80%81%E6%B5%8B%E8%AF%95">五、整体测试</a></p>
<p id="%E7%BB%93%E6%9D%9F-toc" style="margin-left:0px;"><a href="#%E7%BB%93%E6%9D%9F">结束</a></p>
<hr id="hr-toc"/>
<p></p>
<p></p>
<h1 id="%E4%B8%80%E3%80%81%E9%9C%80%E6%B1%82">一、需求</h1>
<p>在Unity里面，有XLua，ILRuntime 这样的热更新框架，有Unity经验的人都知道，在Unity里面发布的各个平台，哪怕是Windows平台，根本不必关闭程序才能进行更新，但是 Winform 项目必须关闭程序才进行下载替换，我也在网上找了一下，目前 Winform 还没看到什么比较好的开源框架，于是我自己动手写了一个</p>
<p>效果如下：</p>
<p style="text-align:center;"><img alt="" class="left" src="https://img-blog.csdnimg.cn/8d699a0874db478482b48b95c5b07337.gif"/></p>
<p>在 Windows 平台，客户端自动更新方法一般如下面几个步骤，最少需要做三个软件</p>
<p><span style="color:#fe2c24;"><strong>1.更新文件列表生成器</strong></span></p>
<p><span style="color:#fe2c24;"><strong>2.软件启动器</strong></span></p>
<p><span style="color:#fe2c24;"><strong>3.软件本体（只能由软件启动器 打开）</strong></span></p>
<p>软件启动入口可以加密码，防止用户随意打开</p>
<p></p>
<h1 id="%E4%BA%8C%E3%80%81%E6%9B%B4%E6%96%B0%E6%96%87%E4%BB%B6%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%99%A8">二、<strong>更新文件列表生成器</strong></h1>
<p>我们知道，在原有基础上更新文件必要的三个基础：新增，覆盖，删除，那么问题来了，新增和删除好理解，在覆盖文件这块，假如：最新文件和旧版文件有一个同名的文件都叫 Test.dll，这时候要怎么判断是否进行下载和替换？</p>
<p>这个问题，可以用文件的哈希值去解决，如果客户端匹配不上，那么就需要从服务器下载和替换了，代码如下：</p>
<pre><code class="language-cs">using System;
using System.IO;
using System.Security.Cryptography;

namespace Test
{
    internal class Program
    {
        static void Main(string[] args)
        {
            string path1 = "D:\\单据备份\\53.png";
            string saveHash = "97-9F-FC-54-BF-C0-95-B8-15-64-C5-AC-81-03-DE-90-13-CD-03-D5";
            using (HashAlgorithm hash = HashAlgorithm.Create())
            {
                using (FileStream file1 = new FileStream(path1, FileMode.Open))
                {
                    byte[] hashByte1 = hash.ComputeHash(file1);//哈希算法根据文本得到哈希码的字节数组
                    string str1 = BitConverter.ToString(hashByte1);//将字节数组装换为字符串
                    Console.WriteLine(str1);

                    if (saveHash.Equals(str1))
                        Console.WriteLine("两个文件相同");
                    else
                        Console.WriteLine("两个文件不相同");
                }
            }

            Console.ReadKey();
        }
    }
}
</code></pre>
<p>更新文件生成器界面如下，将最新的软件文件放到服务器一个固定的文件夹，然后用更新文件生成器就可以生成文件列表等数据了</p>
<p><img alt="" height="274" src="image\d9bbed1c0e1a4c6382512db3bb733282.png" width="600"/></p>
<p>生成的是一个json文件，不过json文件是加密的，直接是看不出里面有什么的，这个需要在客户端软件启动器中进行解密。</p>
<p>加密json如下图</p>
<p><img alt="" height="72" src="image\c72a92d109bc46d1a2f1995a933ce3e5.png" width="600"/></p>
<p>这里加密了文件列表也是为了传输的安全。另外也可以加一些文件完整性校验，这个功能我暂时没加。</p>
<p>原 json 的格式如下</p>
<pre><code class="language-XML">{
	"DirectoryList": [],
	"FilesinfoList": [{
		"Path": "/2012年硕士研究生入学考试管理类专业硕士综合能力真题及参考答案.doc.pdf",
		"Hashs": "27-7B-18-DD-D6-A3-9A-CB-CE-79-D3-B1-62-C2-5E-0B-80-71-EB-37"
	}, {
		"Path": "/2013年全国硕士研究生入学统一考试英语试题及答案.pdf",
		"Hashs": "0D-63-3F-F6-7E-77-AB-DE-B4-7C-F6-20-66-72-AC-CF-B6-B8-C8-3A"
	}, {
		"Path": "/2014年全国硕士研究生入学统一考试管理类专业学位联考综合能力试题.pdf",
		"Hashs": "E7-06-D0-A5-7A-03-7F-09-D8-BB-5B-14-B2-88-40-0F-54-E6-79-4B"
	},  {
		"Path": "/全国硕士研究生入学统一考试数学一试题完整版.pdf",
		"Hashs": "6B-B6-0D-86-23-C9-EE-CB-D7-9D-55-17-06-81-DB-69-58-9E-81-14"
	}, {
		"Path": "/全国硕士研究生入学考试政治试题及答案.pdf",
		"Hashs": "2C-56-95-7E-7C-6F-B5-F9-18-CE-6D-22-89-5B-68-36-23-0D-D7-68"
	}, {
		"Path": "/全国硕士研究生入学考试数学二试题及解析(1).pdf",
		"Hashs": "D8-07-32-A0-56-94-7D-21-CD-B6-7D-C3-6B-04-7E-28-59-A1-D5-19"
	}, {
		"Path": "/全国硕士研究生入学考试英语(一)试题.pdf",
		"Hashs": "7E-07-67-36-15-D9-A4-59-5A-86-68-F9-9C-38-92-71-A2-03-21-34"
	}]
}</code></pre>
<p>Json 中的 DirectoryList 属于文件夹的路径列表，由于我打包的这个路径没用子文件夹，所以就是空的，FilesinfoList 则是文件列表。</p>
<p>更新文件列表生成器 代码并不复杂，只是将要打包的文件转化为一个json 文件，给客户端访问。</p>
<p>首先，先将加密的文件写好，新建一个类 DES</p>
<pre><code class="language-cs">using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using System.Threading.Tasks;

namespace Utils
{

    public class DESKey
    {
        /// &lt;summary&gt;
        /// Des默认密钥向量
        /// &lt;/summary&gt;
        public static byte[] IV = { 0x13, 0x35, 0x16, 0x78, 0x90, 0xAB, 0xCD, 0xEF };
        /// &lt;summary&gt;
        /// Des加解密钥必须8位
        /// &lt;/summary&gt;
        public const string Key = "4hghhgg";
    }

    public class DES
    {
        /// &lt;summary&gt;
        /// Des加密
        /// &lt;/summary&gt;
        /// &lt;param name="source"&gt;源字符串&lt;/param&gt;
        /// &lt;param name="key"&gt;des密钥，长度必须8位&lt;/param&gt;
        /// &lt;param name="iv"&gt;密钥向量&lt;/param&gt;
        /// &lt;returns&gt;加密后的字符串&lt;/returns&gt;
        public static string EncryptDes(string source, string key, byte[] iv)
        {
            using (DESCryptoServiceProvider desProvider = new DESCryptoServiceProvider())
            {
                byte[] rgbKeys = GetDesKey(key),
                    rgbIvs = iv,
                    inputByteArray = Encoding.UTF8.GetBytes(source);
                using (MemoryStream memoryStream = new MemoryStream())
                {
                    using (CryptoStream cryptoStream = new CryptoStream(memoryStream, desProvider.CreateEncryptor(rgbKeys, rgbIvs), CryptoStreamMode.Write))
                    {
                        cryptoStream.Write(inputByteArray, 0, inputByteArray.Length);
                        cryptoStream.FlushFinalBlock();
                        return Convert.ToBase64String(memoryStream.ToArray());
                    }
                }
            }
        }

        /// &lt;summary&gt;
        /// Des解密
        /// &lt;/summary&gt;
        /// &lt;param name="source"&gt;源字符串&lt;/param&gt;
        /// &lt;param name="key"&gt;des密钥，长度必须8位&lt;/param&gt;
        /// &lt;param name="iv"&gt;密钥向量&lt;/param&gt;
        /// &lt;returns&gt;解密后的字符串&lt;/returns&gt;
        public static string DecryptDes(string source, string key, byte[] iv)
        {
            using (DESCryptoServiceProvider desProvider = new DESCryptoServiceProvider())
            {
                byte[] rgbKeys = GetDesKey(key), rgbIvs = iv, inputByteArray = Convert.FromBase64String(source);
                using (MemoryStream memoryStream = new MemoryStream())
                {
                    using (CryptoStream cryptoStream = new CryptoStream(memoryStream, desProvider.CreateDecryptor(rgbKeys, rgbIvs), CryptoStreamMode.Write))
                    {
                        cryptoStream.Write(inputByteArray, 0, inputByteArray.Length);
                        cryptoStream.FlushFinalBlock();
                        return Encoding.UTF8.GetString(memoryStream.ToArray());
                    }
                }
            }
        }

        /// &lt;summary&gt;
        /// 获取Des8位密钥
        /// &lt;/summary&gt;
        /// &lt;param name="key"&gt;Des密钥字符串&lt;/param&gt;
        /// &lt;returns&gt;Des8位密钥&lt;/returns&gt;
        private static byte[] GetDesKey(string key)
        {
            if (string.IsNullOrEmpty(key))
            {
                throw new ArgumentNullException("key", "Des密钥不能为空");
            }
            if (key.Length &gt; 8)
            {
                key = key.Substring(0, 8);
            }
            if (key.Length &lt; 8)
            {
                // 不足8补全
                key = key.PadRight(8, '0');
            }
            return Encoding.UTF8.GetBytes(key);
        }
    }
}
</code></pre>
<p>Form1.cs</p>
<pre><code class="language-cs">using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace UpdateFileCreater
{
    public partial class Form1 : Form
    {
        public Form1()
        {
            InitializeComponent();
        }

        private class FileType
        {
            /// &lt;summary&gt;
            /// 路径
            /// &lt;/summary&gt;
            public string Path { get; set; }
            /// &lt;summary&gt;
            /// 哈希值
            /// &lt;/summary&gt;
            public string Hashs { get; set; }
        }

        private class UpdateFile
        {
            /// &lt;summary&gt;
            /// 文件夹列表
            /// &lt;/summary&gt;
            public List&lt;string&gt; DirectoryList { get; set; } = new List&lt;string&gt;();
            /// &lt;summary&gt;
            /// 文件列表
            /// &lt;/summary&gt;
            public List&lt;FileType&gt; FilesinfoList { get; set; } = new List&lt;FileType&gt;();
        }

        //需要生成列表的目录
        private string Path = "D:\\H\\本地服务器工具\\Software\\News\\";
        //存放json的位置
        private string FileConfigJsonPath = Application.StartupPath + "\\FileList.json";

        //本地文件的黑名单（不参与到更新）
        private static List&lt;string&gt; LocalFileBlacklist = new List&lt;string&gt;();

        //文件夹列表
        private static List&lt;string&gt; DirectorysList = new List&lt;string&gt;();
        //文件列表
        private static List&lt;FileType&gt; FilesinfoList = new List&lt;FileType&gt;();


        private void Form1_Load(object sender, EventArgs e)
        {
            this.TextBox_Path.Text = Path;

            //添加黑名单
            LocalFileBlacklist.Add("log4net.dll");
            LocalFileBlacklist.Add("log4net.xml");
            LocalFileBlacklist.Add("Newtonsoft.Json.dll");
            LocalFileBlacklist.Add("Newtonsoft.Json.xml");
        }

        /// &lt;summary&gt;
        /// 选择路径
        /// &lt;/summary&gt;
        /// &lt;param name="sender"&gt;&lt;/param&gt;
        /// &lt;param name="e"&gt;&lt;/param&gt;
        private void Button_SelectionPath_Click(object sender, EventArgs e)
        {
            FolderBrowserDialog dialog = new FolderBrowserDialog();
            dialog.Description = "请选择文件夹";
            dialog.SelectedPath = Path;
            if (dialog.ShowDialog() == DialogResult.OK)
            {
                if (string.IsNullOrEmpty(dialog.SelectedPath))
                {
                    MessageBox.Show(this, "文件夹路径不能为空", "提示");
                    return;
                }
                Path = dialog.SelectedPath;
                this.TextBox_Path.Text = Path;
            }
        }

        /// &lt;summary&gt;
        /// 生成文件
        /// &lt;/summary&gt;
        /// &lt;param name="sender"&gt;&lt;/param&gt;
        /// &lt;param name="e"&gt;&lt;/param&gt;
        private void Button_CreaterFile_Click(object sender, EventArgs e)
        {
            DirectorysList.Clear();
            FilesinfoList.Clear();

            if (System.IO.Directory.Exists(Path))
            {
                Task.Run(() =&gt;
                {
                    GetDirectoryFileList(Path);

                    if (FilesinfoList.Count &gt; 0)
                    {
                        UpdateFile updateFile = new UpdateFile();
                        updateFile.DirectoryList = DirectorysList;
                        updateFile.FilesinfoList = FilesinfoList;
                        //生成json文件
                        string json = JsonConvert.SerializeObject(updateFile);
                        //加密json文件
                        json = Utils.DES.EncryptDes(json, Utils.DESKey.Key, Utils.DESKey.IV);
                        WriteJsonFile(FileConfigJsonPath, json);
                        MessageBox.Show("生成文件成功！");
                    }
                });
            }
        }


        /// &lt;summary&gt;
        /// 获取一个文件夹下的所有文件和文件夹集合
        /// &lt;/summary&gt;
        /// &lt;param name="path"&gt;&lt;/param&gt;
        private void GetDirectoryFileList(string path)
        {
            DirectoryInfo directory = new DirectoryInfo(path);
            FileSystemInfo[] filesArray = directory.GetFileSystemInfos();
            foreach (var item in filesArray)
            {
                if (item.Attributes == FileAttributes.Directory)
                {
                    //添加文件夹
                    string dir = item.FullName.Replace(Path, "");
                    DirectorysList.Add(dir);
                    GetDirectoryFileList(item.FullName);
                }
                else
                {
                    string fileName = item.FullName.Replace(Path, "");
                    fileName = fileName.Replace(@"\", @"/");

                    //是否在黑名单中
                    bool isBlackList = false;
                    if (LocalFileBlacklist.Count &gt; 0)
                    {
                        for (int i = 0; i &lt; LocalFileBlacklist.Count; i++)
                        {
                            if (LocalFileBlacklist[i].Equals(fileName))
                            {
                                isBlackList = true;
                                break;
                            }
                        }
                    }
                    if (!isBlackList)
                    {
                        //添加文件
                        FileType fileType = new FileType();
                        fileType.Path = fileName;
                        fileType.Hashs = GetHashs(item.FullName);
                        FilesinfoList.Add(fileType);
                    }
                }
            }
        }

        /// &lt;summary&gt;
        /// 获取文件的哈希值
        /// &lt;/summary&gt;
        /// &lt;param name="path"&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        private string GetHashs(string path)
        {
            //创建一个哈希算法对象
            using (HashAlgorithm hash = HashAlgorithm.Create())
            {
                using (FileStream file1 = new FileStream(path, FileMode.Open))
                {
                    //哈希算法根据文本得到哈希码的字节数组
                    byte[] hashByte1 = hash.ComputeHash(file1);
                    //将字节数组装换为字符串
                    return BitConverter.ToString(hashByte1);
                }
            }
        }

        /// &lt;summary&gt;
        /// 将json字符串内容写入Json文件并保存（若json文件不存在则创建）
        /// &lt;/summary&gt;
        /// &lt;param name="path"&gt;路径&lt;/param&gt;
        /// &lt;param name="jsonConents"&gt;Json内容&lt;/param&gt;
        private void WriteJsonFile(string path, string jsonConents)
        {
            using (FileStream fs = new FileStream(path, FileMode.OpenOrCreate, System.IO.FileAccess.ReadWrite, FileShare.ReadWrite))
            {
                fs.Seek(0, SeekOrigin.Begin);
                fs.SetLength(0);
                using (StreamWriter sw = new StreamWriter(fs, Encoding.UTF8))
                {
                    sw.WriteLine(jsonConents);
                }
            }
        }
    }
}
</code></pre>
<p>这样 更新文件列表生成器 就基本完成了。</p>
<p></p>
<h1 id="%E4%B8%89%E3%80%81%E8%BD%AF%E4%BB%B6%E5%90%AF%E5%8A%A8%E5%99%A8">三、<strong>软件启动器</strong></h1>
<p>在我们平时用到的很多Windows软件打开时都会有软件启动器，大部分的作用都是基于软件的更新和文件的效验，这也形成了软件体系一个固定的框架，那么为什么要用软件启动器呢，那是因为，Windows软件打开以后，软件的文件就会被占用，无法进行删除，替换等操作，所以，想要更新软件，软件启动器是必须的。</p>
<p>软件启动器需要给项目添加管理员权限，软件启动器是启动软件之前，做的一些安全判断，比如文件是否完整，是否需要更新到最新版本，然后执行文件的新增，删除，覆盖 等任务。</p>
<p></p>
<h2 id="1.%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E6%9B%B4%E6%96%B0"><strong>1.判断是否需要更新</strong></h2>
<p>软件启动器的第一个作用就是判断是否需要更新了，这里其实可以设置是否需要强制更新，用提示框提示，提示框为：</p>
<h3 id="1%EF%BC%89%E6%A3%80%E6%B5%8B%E5%88%B0%E6%96%B0%E7%89%88%E6%9C%AC%EF%BC%8C%E6%98%AF%E5%90%A6%E6%9B%B4%E6%96%B0%E8%BD%AF%E4%BB%B6">1）检测到新版本，是否更新软件</h3>
<p>提示按钮，更新，取消</p>
<p>1-1 按钮---点击更新</p>
<p>打开文件下载界面</p>
<p>读取服务器文件列表</p>
<p>如果读取成功，</p>
<p>进入下一步，判断是否有需要更新软件</p>
<p>如果读取失败，处理方式有两种：</p>
<p>① 提示无法连接到服务器（无法进入主界面）</p>
<p>② 直接进入软件主界面</p>
<p>1-2 按钮---点击取消：进入软件本体</p>
<p>判断版本是否更新的方法：</p>
<pre><code class="language-cs">Version v1 = new Version(txt1.Text);
Version v2 = new Version(txt2.Text);
if (v1 &gt; v2)
{
    MessageBox.Show("版本1高于版本2");
}
if (v1 &lt; v2)
{
    MessageBox.Show("版本1低于版本2");
}</code></pre>
<p></p>
<h3 id="2%EF%BC%89%E7%89%88%E6%9C%AC%E8%BF%87%E6%97%A7%EF%BC%8C%E8%AF%B7%E6%9B%B4%E6%96%B0%E5%88%B0%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC">2）版本过旧，请更新到最新版本</h3>
<p>提示按钮，更新，退出</p>
<p>点击更新：打开文件下载界面</p>
<p>点击退出：退出文件启动器</p>
<p></p>
<h2 id="3%EF%BC%89%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD"><strong>2.文件下载</strong></h2>
<p>1.如果需要更新，将本地文件的哈希值和服务器返回的列表进行判断，如果服务器文件哈希值和本地文件哈希值不一致，那么就加入到下载列表</p>
<p>2.文件操作，更新软件本体通常的操作是：</p>
<p>① 新增文件直接下载</p>
<p>② 相同文件直接覆盖</p>
<p>③ 删除文件直接删除</p>
<p></p>
<h2 id="4%EF%BC%89%E6%89%A7%E8%A1%8C%20%E4%B8%8B%E8%BD%BD%EF%BC%8C%E8%A6%86%E7%9B%96%EF%BC%8C%E5%88%A0%E9%99%A4%20%E4%BB%BB%E5%8A%A1">3.<strong>执行 下载，覆盖，删除任务</strong></h2>
<p>需要操作的文件加入到任务列表（下载，覆盖，删除），需要专门写一个任务系统来执行此次操作，将每个子任务的结果显示到UI界面，这里可以用一个进度条和文本来显示执行的进度，</p>
<p>但也需要注意一点，自动更新系统都有一个毛病，就是不能确保文件的完整性，如果在下载的中途结束软件启动器进程，会导致软件的文件不全，从而打不开软件，解决这个问题，可以用一个文件夹先下载好文件，下完之后，直接覆盖现有的文件。</p>
<p></p>
<h2 id="5%EF%BC%89%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C"><strong>4.执行结果</strong></h2>
<p>如果执行完成，打开软件本体</p>
<p>如果执行失败，弹框显示错误信息，退出</p>
<p><span style="color:#fe2c24;">代码等待我优化完成上传</span></p>
<p></p>
<h1 id="%E5%9B%9B%E3%80%81%E6%90%AD%E5%BB%BA%E6%9B%B4%E6%96%B0%E6%9C%8D%E5%8A%A1%E5%99%A8">四、搭建更新服务器</h1>
<p>服务器可以使用软件来实现，不用的时候就关掉，在测试的时候，我们不必使用 IIS 这样的服务器，配置起来太麻烦了，软件名如下图</p>
<p><img alt="" height="115" src="image\3cc73dd8f1f04085946c8f82f85ab8ff.png" width="200"/></p>
<p>搭建软件服务器，主要有两个功能，</p>
<p>1.主要就是让客户端在启动的时候，判断是否需要更新，</p>
<p>2.当需要更新的时候，主动从服务器下载需要更新的文件</p>
<p>后续更新。。。。</p>
<p></p>
<h1 id="%E4%BA%94%E3%80%81%E6%B5%8B%E8%AF%95">五、整体测试</h1>
<p>后续更新。。。。</p>
<p></p>
<p></p>
<h1 id="%E7%BB%93%E6%9D%9F">结束</h1>
<p>如果这个帖子对你有用，欢迎 关注 + 点赞 + 留言，谢谢</p>
<p>end</p>
</div>
</div>