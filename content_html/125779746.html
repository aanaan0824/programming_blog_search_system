<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<p id="main-toc"><strong>目录</strong></p>
<p id="1%E3%80%81list%E7%9A%84%E4%BB%8B%E7%BB%8D-toc" style="margin-left:80px;"><a href="#1%E3%80%81list%E7%9A%84%E4%BB%8B%E7%BB%8D">1、list的介绍</a></p>
<p id="2%E3%80%81list%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:80px;"><a href="#2%E3%80%81list%E7%9A%84%E4%BD%BF%E7%94%A8">2、list的使用</a></p>
<p id="11-toc" style="margin-left:80px;"><a href="#11">     </a> <a href="#11">2.1、list的构造</a></p>
<p id="22-toc" style="margin-left:80px;"><a href="#22">      </a><a href="#22">2.2、迭代器的使用</a></p>
<p id="33-toc" style="margin-left:80px;"><a href="#33">               </a><a href="#33">begin和end</a></p>
<p id="44-toc" style="margin-left:80px;"><a href="#44">        </a>       <a href="#44">rbegin和rend</a></p>
<p id="55-toc" style="margin-left:80px;">               <a href="#55">范围for</a></p>
<p id="66-toc" style="margin-left:80px;"><a href="#66">     </a> <a href="#66">2.3、list元素获取</a></p>
<p id="77-toc" style="margin-left:80px;"><a href="#77">        </a>       <a href="#77">front和back</a></p>
<p id="88-toc" style="margin-left:80px;"><a href="#88">      </a><a href="#88">2.4、list的大小</a></p>
<p id="99-toc" style="margin-left:80px;"><a href="#99">        </a>       <a href="#99">empty</a></p>
<p id="111-toc" style="margin-left:80px;"><a href="#111">        </a>       <a href="#111">size</a></p>
<p id="222-toc" style="margin-left:80px;"><a href="#222">      </a><a href="#222">2.5、list修改的相关函数</a></p>
<p id="333-toc" style="margin-left:80px;"><a href="#333">        </a>       <a href="#333">push_front和pop_front</a></p>
<p id="444-toc" style="margin-left:80px;"><a href="#444">        </a>       <a href="#444">push_back和pop_back</a></p>
<p id="555-toc" style="margin-left:80px;"><a href="#555">        </a>       <a href="#555">insert</a></p>
<p id="666-toc" style="margin-left:80px;"><a href="#666">        </a>       <a href="#666">erase</a></p>
<p id="777-toc" style="margin-left:80px;"><a href="#777">        </a>       <a href="#777">swap</a></p>
<p id="888-toc" style="margin-left:80px;"><a href="#888">        </a>       <a href="#888">clear</a></p>
<p id="999-toc" style="margin-left:80px;"><a href="#999">     </a> <a href="#999">2.6、list的操作函数</a></p>
<p id="1111-toc" style="margin-left:80px;"><a href="#1111">        </a>       <a href="#1111">sort</a></p>
<p id="2222-toc" style="margin-left:80px;"><a href="#2222">        </a>       <a href="#2222">unique</a></p>
<p id="4%E3%80%81list%E4%B8%8Evector%E5%AF%B9%E6%AF%94-toc" style="margin-left:80px;"><a href="#4%E3%80%81list%E4%B8%8Evector%E5%AF%B9%E6%AF%94">3、list与vector对比</a></p>
<hr/>
<h3>1、list的介绍</h3>
<blockquote>
<ol><li>list是可以在常数范围内在任意位置进行插入和删除的序列式容器，并且该容器可以前后双向迭代。</li><li>list的底层是双向链表结构，双向链表中每个元素存储在互不相关的独立节点中，在节点中通过指针指向其前一个元素和后一个元素。</li><li>list与forward_list非常相似：最主要的不同在于forward_list是单链表，只能朝前迭代，已让其更简单高效。</li><li>与其他的序列式容器相比(array，vector，deque)，list通常在任意位置进行插入、移除元素的执行效率更好。</li><li>与其他序列式容器相比，list和forward_list最大的缺陷是不支持任意位置的随机访问，比如：要访问list的第6个元素，必须从已知的位置(比如头部或者尾部)迭代到该位置，在这段位置上迭代需要线性的时间开销；list还需要一些额外的空间，以保存每个节点的相关联信息(对于存储类型较小元素的大list来说这可能是一个重要因素</li></ol>
</blockquote>
<hr/>
<h3 id="2%E3%80%81list%E7%9A%84%E4%BD%BF%E7%94%A8">2、list的使用</h3>
<h3 id="11">2.1、list的构造</h3>
<blockquote>
<table border="2" cellpadding="1" cellspacing="1" style="width:655px;"><tbody><tr><td style="width:390px;"><span style="color:#0d0016;"><strong>构造函数</strong></span></td><td style="width:262px;"><span style="color:#0d0016;"><strong>接口说明</strong></span></td></tr><tr><td style="width:390px;"><span style="color:#0d0016;">1、</span><span style="color:#956fe7;">list()</span></td><td style="width:262px;"><span style="color:#0d0016;">构造空的list</span></td></tr><tr><td style="width:390px;"><span style="color:#0d0016;">2、</span><span style="color:#956fe7;">list (size_type n, const value_type&amp; val = value_type())</span></td><td style="width:262px;"><span style="color:#0d0016;">构造的list中包含n个值为val的元素</span></td></tr><tr><td style="width:390px;"><span style="color:#0d0016;">3、</span><span style="color:#956fe7;">list (const list&amp; x)</span></td><td style="width:262px;"><span style="color:#0d0016;">拷贝构造函数</span></td></tr><tr><td style="width:390px;"><span style="color:#0d0016;">4、</span><span style="color:#956fe7;">list (InputIterator first, InputIterator last)</span></td><td style="width:262px;"><span style="color:#0d0016;">用[first, last)区间中的元素构造list</span></td></tr></tbody></table>
<ul><li>1、<span style="color:#956fe7;">list()</span></li></ul>
<pre><code class="language-cpp">list&lt;int&gt; lt1;</code></pre>
<ul><li>2、<span style="color:#956fe7;">list (size_type n, const value_type&amp; val = value_type())</span></li></ul>
<pre><code class="language-cpp">list&lt;int&gt; lt2(5, 3);//构造5个值为3的元素</code></pre>
<ul><li>3、<span style="color:#956fe7;">list (const list&amp; x)</span></li></ul>
<pre><code class="language-cpp">list&lt;int&gt; lt3(lt2);//用lt2拷贝构造lt3</code></pre>
<ul><li>4、<span style="color:#956fe7;">list (InputIterator first, InputIterator last)</span></li></ul>
<pre><code class="language-cpp">//1、用l2的[begin(), end()）左闭右开的区间构造lt4
list&lt;int&gt; lt4(lt2.begin(), lt2.end());
//2、以数组为迭代器区间构造lt5
int array[] = { 1,2,3,4 };
list&lt;int&gt; lt5(array, array + sizeof(array) / sizeof(int));</code></pre>
</blockquote>
<hr/>
<h3 id="22">2.2、迭代器的使用</h3>
<blockquote>
<table border="2" cellpadding="1" cellspacing="1" style="width:535px;"><tbody><tr><td style="width:108px;"><strong><span style="color:#0d0016;">函数声明</span></strong></td><td style="width:425px;"><strong><span style="color:#0d0016;">接口说明</span></strong></td></tr><tr><td style="width:108px;"><span style="color:#0d0016;">1、</span><span style="color:#956fe7;">begin</span></td><td style="width:425px;"><span style="color:#0d0016;">返回第一个元素的迭代器</span></td></tr><tr><td style="width:108px;"><span style="color:#0d0016;">2、</span><span style="color:#956fe7;">end</span></td><td style="width:425px;"><span style="color:#0d0016;">返回最后一个元素下一个位置的迭代器</span></td></tr><tr><td style="width:108px;"><span style="color:#0d0016;">3、</span><span style="color:#956fe7;">rbegin</span></td><td style="width:425px;"><span style="color:#0d0016;">返回第一个元素的reverse_iterator,即end位置</span></td></tr><tr><td style="width:108px;"><span style="color:#0d0016;">4、</span><span style="color:#956fe7;">rend</span></td><td style="width:425px;"><span style="color:#0d0016;">返回最后一个元素下一个位置的reverse_iterator,即begin位置</span></td></tr></tbody></table>
</blockquote>
<h3 id="33">begin和end</h3>
<blockquote>
<p><span style="color:#956fe7;">begin是返回第一个元素的迭代器，end是返回最后一个元素下一个位置的迭代器</span>。可以通过迭代器进行元素访问：</p>
<pre><code class="language-cpp">void test()
{
	list&lt;int&gt; lt(5, 3);
	list&lt;int&gt;::iterator it = lt.begin();
	while (it != lt.end()) //不能用it &lt; lt.end()
	{
		cout &lt;&lt; *it &lt;&lt; " "; //3 3 3 3 3
		it++;
	}
}</code></pre>
<ul><li><strong><span style="background-color:#fefcd8;">注意：</span></strong>begin与end为正向迭代器，对迭代器执行++操作，迭代器向后移动</li></ul>
</blockquote>
<h3 id="44">rbegin和rend</h3>
<blockquote>
<p>和先前学到的string类似，rbegin的第一个元素为尾部end位置，rend返回的是begin的位置。</p>
<pre><code class="language-cpp">void test()
{
	list&lt;int&gt; lt;
	for (int i = 1; i &lt;= 4; i++)
	{
		lt.push_back(i);//1 2 3 4
	}
	list&lt;int&gt;::reverse_iterator rit = lt.rbegin();
	//或者用auto自动识别类型：auto rit = lt.rbegin();
	while (rit != lt.rend())
	{
		cout &lt;&lt; *rit &lt;&lt; " "; //4 3 2 1
		rit++;
	}
}</code></pre>
<ul><li><strong><span style="background-color:#fefcd8;">注意：</span></strong>rbegin(end)与rend(begin)为反向迭代器，对迭代器执行++操作，迭代器向前移动</li></ul>
</blockquote>
<h3 id="55">范围for</h3>
<blockquote>
<p>范围for的底层就是迭代器实现的，利用其也可进行元素访问：</p>
<pre><code class="language-cpp">void test()
{
	list&lt;int&gt; lt;
	for (int i = 1; i &lt;= 4; i++)
	{
		lt.push_back(i);//1 2 3 4
	}
	for (auto e : lt)
	{
		cout &lt;&lt; e &lt;&lt; " ";//1 2 3 4
	}
}</code></pre>
</blockquote>
<hr/>
<h3 id="66">2.3、list的元素获取</h3>
<blockquote>
<table border="2" cellpadding="1" cellspacing="1" style="width:489px;"><tbody><tr><td><strong><span style="color:#0d0016;">函数声明</span></strong></td><td style="width:352px;"><strong><span style="color:#0d0016;">接口声明</span></strong></td></tr><tr><td><span style="color:#0d0016;">1、</span><span style="color:#956fe7;">front</span></td><td style="width:352px;"><span style="color:#0d0016;">返回list第一个节点中值的引用</span></td></tr><tr><td><span style="color:#0d0016;">2、</span><span style="color:#956fe7;">back</span></td><td style="width:352px;"><span style="color:#0d0016;">返回list最后一个节点中值的引用</span></td></tr></tbody></table>
</blockquote>
<h3 id="77">front和back</h3>
<blockquote>
<p>front返回第一个元素，back返回最后一个元素</p>
<pre><code class="language-cpp">void test()
{
	list&lt;int&gt; lt;
	for (int i = 1; i &lt;= 4; i++)
	{
		lt.push_back(i);//1 2 3 4
	}
	cout &lt;&lt; lt.front() &lt;&lt; endl;//1
	cout &lt;&lt; lt.back() &lt;&lt; endl; //4
}</code></pre>
</blockquote>
<hr/>
<h3 id="88">2.4、list的大小</h3>
<blockquote>
<table border="2" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td><strong><span style="color:#0d0016;">函数声明</span></strong></td><td><strong><span style="color:#0d0016;">接口说明</span></strong></td></tr><tr><td><span style="color:#0d0016;">1、</span><span style="color:#956fe7;">empty</span></td><td><span style="color:#0d0016;">检测list是否为空，是返回true，不是返回false</span></td></tr><tr><td><span style="color:#0d0016;">2、</span><span style="color:#956fe7;">size</span></td><td> <p><span style="color:#0d0016;">返回list中有效节点的个数</span></p> </td></tr></tbody></table>
</blockquote>
<h3 id="99">empty</h3>
<blockquote>
<p>empty判断list是否为空</p>
<pre><code class="language-cpp">void test()
{
	list&lt;int&gt; lt;
	for (int i = 1; i &lt;= 4; i++)
	{
		lt.push_back(i);//1 2 3 4
	}
	cout &lt;&lt; lt.empty() &lt;&lt; endl;//0
}</code></pre>
</blockquote>
<h3 id="111">size</h3>
<blockquote>
<p>size用来获取list中有些元素个数</p>
<pre><code class="language-cpp">void test5()
{
	list&lt;int&gt; lt;
	for (int i = 1; i &lt;= 4; i++)
	{
		lt.push_back(i);//1 2 3 4
	}
	cout &lt;&lt; lt.size() &lt;&lt; endl;//4
}</code></pre>
</blockquote>
<hr/>
<h3 id="222">2.5、list修改的相关函数</h3>
<blockquote>
<table border="2" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td><strong><span style="color:#0d0016;">函数声明</span></strong></td><td><strong><span style="color:#0d0016;">接口声明</span></strong></td></tr><tr><td><span style="color:#0d0016;">1、</span><span style="color:#956fe7;">push_front</span></td><td><span style="color:#0d0016;">在list首元素前插入值为val的元素</span></td></tr><tr><td><span style="color:#0d0016;">2、</span><span style="color:#956fe7;">pop_front</span></td><td><span style="color:#0d0016;">删除list中第一个元素</span></td></tr><tr><td><span style="color:#0d0016;">3、</span><span style="color:#956fe7;">push_back</span></td><td><span style="color:#0d0016;">在list尾部插入值为val的元素</span></td></tr><tr><td><span style="color:#0d0016;">4、</span><span style="color:#956fe7;">pop_back</span></td><td><span style="color:#0d0016;">删除list中最后一个元素</span></td></tr><tr><td><span style="color:#0d0016;">5、</span><span style="color:#956fe7;">insert</span></td><td><span style="color:#0d0016;">在list position 位置中插入值为val的元素</span></td></tr><tr><td><span style="color:#0d0016;">6、</span><span style="color:#956fe7;">erase</span></td><td><span style="color:#0d0016;">删除list position位置的元素</span></td></tr><tr><td><span style="color:#0d0016;">7、</span><span style="color:#956fe7;">swap</span></td><td><span style="color:#0d0016;">交换两个list中的元素</span></td></tr><tr><td><span style="color:#0d0016;">8、</span><span style="color:#956fe7;">clear</span></td><td><span style="color:#0d0016;">清空list中的有效数据</span></td></tr></tbody></table>
</blockquote>
<h3 id="333">push_front和pop_front</h3>
<blockquote>
<p>push_front即头插，pop_front即头删。</p>
<pre><code class="language-cpp">void test()
{
	list&lt;int&gt; lt;
	for (int i = 1; i &lt;= 4; i++)
	{
		lt.push_back(i);//1 2 3 4
	}
	lt.push_front(0);//头插0
	cout &lt;&lt; lt.front() &lt;&lt; endl;//0
	lt.pop_front();//头删
	cout &lt;&lt; lt.front() &lt;&lt; endl;//1
}</code></pre>
</blockquote>
<h3 id="444">push_back和pop_back</h3>
<blockquote>
<p>push_back即尾插，pop_back即尾删。</p>
<pre><code class="language-cpp">void test6()
{
	list&lt;int&gt; lt;
	for (int i = 1; i &lt;= 4; i++)
	{
		lt.push_back(i);//1 2 3 4
	}
	lt.push_back(9);//尾插9
	cout &lt;&lt; lt.back() &lt;&lt; endl;//9
	lt.pop_back();//尾删
	cout &lt;&lt; lt.back() &lt;&lt; endl;//4
}</code></pre>
</blockquote>
<h3 id="555">insert</h3>
<blockquote>
<p>list中的insert支持下列三种插入方式：</p>
<ol><li>在指定位置插入一个值为val的元素</li><li>在指定位置插入n个值为val的元素</li><li>在指定位置插入一段左闭右开的迭代器区间</li></ol>
<pre><code class="language-cpp">void test()
{
	list&lt;int&gt; lt;
	for (int i = 1; i &lt;= 4; i++)
	{
		lt.push_back(i);//1 2 3 4
	}
	list&lt;int&gt;::iterator pos = find(lt.begin(), lt.end(), 3);
	//1、在3的位置插入值7
	lt.insert(pos, 7);
	for (auto e : lt)
		cout &lt;&lt; e &lt;&lt; " ";//1 2 7 3 4
	cout &lt;&lt; endl;

	//2、在3的位置插入5个-1
	pos = find(lt.begin(), lt.end(), 3);
	lt.insert(pos, 5, -1);
	for (auto e : lt)
		cout &lt;&lt; e &lt;&lt; " ";//1 2 7 -1 -1 -1 -1 -1 3 4
	cout &lt;&lt; endl;

	//3、在7的位置插入迭代器区间
	pos = find(lt.begin(), lt.end(), 7);
	list&lt;int&gt; lt2(3, 0);
	lt.insert(pos, lt2.begin(), lt2.end());
	for (auto e : lt)
		cout &lt;&lt; e &lt;&lt; " ";//1 2 0 0 0 7 -1 -1 -1 -1 -1 3 4
}</code></pre>
</blockquote>
<h3 id="666">erase</h3>
<blockquote>
<p>erase支持下列两种删除方式：</p>
<ol><li>删除在指定迭代器位置的元素</li><li>删除指定迭代器区间的元素</li></ol>
<pre><code class="language-cpp">void test()
{
	list&lt;int&gt; lt;
	for (int i = 1; i &lt;= 7; i++)
	{
		lt.push_back(i);//1 2 3 4 5 6 7
	}
	list&lt;int&gt;::iterator pos = find(lt.begin(), lt.end(), 2);
	//1、删除2位置的元素
	lt.erase(pos);
	for (auto e : lt)
		cout &lt;&lt; e &lt;&lt; " ";//1 3 4 5 6 7
	cout &lt;&lt; endl;
	//2、删除值为4后的所有元素
	pos = find(lt.begin(), lt.end(), 4);
	lt.erase(pos, lt.end());
	for (auto e : lt)
		cout &lt;&lt; e &lt;&lt; " ";//1 3
}</code></pre>
</blockquote>
<h3 id="777">swap</h3>
<blockquote>
<p>swap用于交换两个list的内容。</p>
<pre><code class="language-cpp">void test()
{
	list&lt;int&gt; lt1(5, -1);
	list&lt;int&gt; lt2(3, 7);
	lt2.swap(lt1);
	for (auto e : lt1)
		cout &lt;&lt; e &lt;&lt; " "; //7 7 7 
	cout &lt;&lt; endl;
	for (auto d : lt2)
		cout &lt;&lt; d &lt;&lt; " "; //-1 -1 -1 -1 -1
}</code></pre>
</blockquote>
<h3 id="888">clear</h3>
<blockquote>
<p>clear用来清空list中的有效数据。</p>
<pre><code class="language-cpp">void test()
{
	list&lt;int&gt; lt(5, -1);
	for (auto e : lt)
		cout &lt;&lt; e &lt;&lt; " ";//-1 -1 -1 -1 -1
	cout &lt;&lt; endl;
	lt.clear();
	for (auto e : lt)
		cout &lt;&lt; e &lt;&lt; " ";//空
}</code></pre>
</blockquote>
<hr/>
<h3 id="999">2.6、list的操作函数</h3>
<blockquote>
<table border="2" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td style="width:174px;"><strong><span style="color:#0d0016;">函数声明</span></strong></td><td style="width:323px;"><strong><span style="color:#0d0016;">接口说明</span></strong></td></tr><tr><td style="width:174px;"><span style="color:#0d0016;">1、</span><span style="color:#956fe7;">sort</span></td><td style="width:323px;"><span style="color:#0d0016;">对list进行排序</span></td></tr><tr><td style="width:174px;"><span style="color:#0d0016;">2、</span><span style="color:#956fe7;">unique</span></td><td style="width:323px;"><span style="color:#0d0016;">删除list中的重复元素</span></td></tr></tbody></table>
</blockquote>
<h3 id="1111">sort</h3>
<blockquote>
<p>list中的sort函数默认排升序。</p>
<pre><code class="language-cpp">void test()
{
	list&lt;int&gt; lt;
	for (int i = 3; i &gt;= -3; i--)
	{
		lt.push_back(i);//3 2 1 0 -1 -2 -3
	}
	lt.sort();
	for (auto e : lt)
		cout &lt;&lt; e &lt;&lt; " ";//-3 -2 -1 0 1 2 3
}</code></pre>
</blockquote>
<h3 id="2222">unique</h3>
<blockquote>
<p>unique是删除list中的重复元素。</p>
<pre><code class="language-cpp">void test()
{
	list&lt;int&gt; lt;
	lt.push_back(5);
	lt.push_back(1);
	lt.push_back(3);
	lt.push_back(2);
	lt.push_back(2);
	lt.push_back(5);
	lt.push_back(-1);
	lt.push_back(7);
	lt.sort();
	lt.unique();
	for (auto e : lt)
		cout &lt;&lt; e &lt;&lt; " ";//-1 1 2 3 5 7
}</code></pre>
<ul><li><strong>注意：</strong>要想对list进行真正的去重，必须先排序。</li></ul>
</blockquote>
<hr/>
<h3 id="4%E3%80%81list%E4%B8%8Evector%E5%AF%B9%E6%AF%94">3、list与vector对比</h3>
<blockquote>
<table border="2" cellpadding="1" cellspacing="1" style="width:639px;"><tbody><tr><td style="width:88px;"></td><td style="width:242px;"><strong><span style="color:#956fe7;">vector</span></strong></td><td style="width:305px;"><strong><span style="color:#956fe7;">list</span></strong></td></tr><tr><td style="width:88px;"><strong><span style="color:#0d0016;">底层结构</span></strong></td><td style="width:242px;"><span style="color:#0d0016;">动态顺序表，一段连续空间</span></td><td style="width:305px;"><span style="color:#0d0016;">带头结点的双向循环链表</span></td></tr><tr><td style="width:88px;"><strong><span style="color:#0d0016;">随即访问</span></strong></td><td style="width:242px;"><span style="color:#0d0016;">支持随机访问，访问某个元素效率O(1)</span></td><td style="width:305px;"><span style="color:#0d0016;">不支持随机访问，访问某个元素效率O(N)</span></td></tr><tr><td style="width:88px;"><strong><span style="color:#0d0016;">插入和删除</span></strong></td><td style="width:242px;"><span style="color:#0d0016;">任意位置插入和删除效率低，需要搬移元素，时间复杂度为O(N)，插入时有可能需要增容，增容：开辟新空间，拷贝元素，释放旧空间，导致效率更低</span></td><td style="width:305px;"><span style="color:#0d0016;">任意位置插入和删除效率高，不需要搬移元素，时间复杂度为O(1)</span></td></tr><tr><td style="width:88px;"><strong><span style="color:#0d0016;">空间利用率</span></strong></td><td style="width:242px;"><span style="color:#0d0016;">底层为连续空间，不容易造成内存碎片，空间利用率高，缓存利用率高</span></td><td style="width:305px;"><span style="color:#0d0016;">底层节点动态开辟，小节点容易造成内存碎片，空间利用率低，缓存利用率低</span></td></tr><tr><td style="width:88px;"><strong><span style="color:#0d0016;">迭代器</span></strong></td><td style="width:242px;"><span style="color:#0d0016;">原生态指针</span></td><td style="width:305px;"><span style="color:#0d0016;">对原生态指针(节点指针)进行封装</span></td></tr><tr><td style="width:88px;"><strong><span style="color:#0d0016;">迭代器失效</span></strong></td><td style="width:242px;"><span style="color:#0d0016;">在插入元素时，要给所有的迭代器重新赋值，因为插入元素有可能会导致重新扩容，致使原来迭代器失效，删除时，当前迭代器需要重新赋值否则会失效</span></td><td style="width:305px;"><span style="color:#0d0016;">插入元素不会导致迭代器失效，删除元素时，只会导致当前迭代器失效，其他迭代器不受影响</span></td></tr><tr><td style="width:88px;"><strong><span style="color:#0d0016;">使用场景</span></strong></td><td style="width:242px;"><span style="color:#0d0016;">需要高效存储，支持随机访问，不关心插入删除效率</span></td><td style="width:305px;"><span style="color:#0d0016;">大量插入和删除操作，不关心随机访问</span></td></tr></tbody></table>
</blockquote>
</div>
</div>