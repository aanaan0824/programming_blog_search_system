<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<p id="main-toc"><strong>目录</strong></p>
<p id="%E5%88%9D%E7%BA%A7%E9%98%B6%E6%AE%B5-toc" style="margin-left:0px;"><a href="#%E5%88%9D%E7%BA%A7%E9%98%B6%E6%AE%B5">初级阶段</a></p>
<p id="week1-day1%E4%BD%9C%E4%B8%9A-toc" style="margin-left:80px;"><a href="#week1-day1%E4%BD%9C%E4%B8%9A">week1-day1作业</a></p>
<p id="week1-day2%E4%BD%9C%E4%B8%9A-toc" style="margin-left:80px;"><a href="#week1-day2%E4%BD%9C%E4%B8%9A">week1-day2作业</a></p>
<p id="week1-day3%E4%BD%9C%E4%B8%9A-toc" style="margin-left:80px;"><a href="#week1-day3%E4%BD%9C%E4%B8%9A">week1-day3作业</a></p>
<p id="week2-day4%E4%BD%9C%E4%B8%9A1-toc" style="margin-left:80px;"><a href="#week2-day4%E4%BD%9C%E4%B8%9A1">week2-day4作业1</a></p>
<p id="week2-day5%E4%BD%9C%E4%B8%9A-toc" style="margin-left:80px;"><a href="#week2-day5%E4%BD%9C%E4%B8%9A">week2-day5作业</a></p>
<p id="week2-day6%E4%BD%9C%E4%B8%9A-toc" style="margin-left:80px;"><a href="#week2-day6%E4%BD%9C%E4%B8%9A">week2-day6作业</a></p>
<p id="%C2%A0week3-day7%E4%BD%9C%E4%B8%9A1-toc" style="margin-left:80px;"><a href="#%C2%A0week3-day7%E4%BD%9C%E4%B8%9A1"> week3-day7作业1</a></p>
<p id="week3-day7%E4%BD%9C%E4%B8%9A2-toc" style="margin-left:80px;"><a href="#week3-day7%E4%BD%9C%E4%B8%9A2">week3-day7作业2</a></p>
<p id="week3-day8%E4%BD%9C%E4%B8%9A-toc" style="margin-left:80px;"><a href="#week3-day8%E4%BD%9C%E4%B8%9A">week3-day8作业</a></p>
<p id="week3-day9%E4%BD%9C%E4%B8%9A-toc" style="margin-left:80px;"><a href="#week3-day9%E4%BD%9C%E4%B8%9A">week3-day9作业</a></p>
<p id="week4-day10%E4%BD%9C%E4%B8%9A-toc" style="margin-left:80px;"><a href="#week4-day10%E4%BD%9C%E4%B8%9A">week4-day10作业</a></p>
<p id="week4-day11%E4%BD%9C%E4%B8%9A-toc" style="margin-left:80px;"><a href="#week4-day11%E4%BD%9C%E4%B8%9A">week4-day11作业</a></p>
<p id="%C2%A0week4-day12%E4%BD%9C%E4%B8%9A-toc" style="margin-left:80px;"><a href="#%C2%A0week4-day12%E4%BD%9C%E4%B8%9A"> week4-day12作业</a></p>
<p id="%E4%B8%AD%E7%BA%A7%E9%98%B6%E6%AE%B5-toc" style="margin-left:40px;"><a href="#%E4%B8%AD%E7%BA%A7%E9%98%B6%E6%AE%B5">中级阶段</a></p>
<p id="%E4%B8%AD%E7%BA%A7-day1-toc" style="margin-left:80px;"><a href="#%E4%B8%AD%E7%BA%A7-day1">中级-day1</a></p>
<p id="%C2%A0%E4%B8%AD%E7%BA%A7-day2%E4%BD%9C%E4%B8%9A-toc" style="margin-left:80px;"><a href="#%C2%A0%E4%B8%AD%E7%BA%A7-day2%E4%BD%9C%E4%B8%9A"> 中级-day2作业</a></p>
<p id="%E4%B8%AD%E7%BA%A7day3%E4%BD%9C%E4%B8%9A-toc" style="margin-left:80px;"><a href="#%E4%B8%AD%E7%BA%A7day3%E4%BD%9C%E4%B8%9A">中级day3作业</a></p>
<p id="%E4%B8%AD%E7%BA%A7-day4%E4%BD%9C%E4%B8%9A-toc" style="margin-left:80px;"><a href="#%E4%B8%AD%E7%BA%A7-day4%E4%BD%9C%E4%B8%9A">中级-day4作业</a></p>
<p id="%C2%A0%E4%B8%AD%E7%BA%A7-day5%E4%BD%9C%E4%B8%9A%E2%80%8B-toc" style="margin-left:80px;"><a href="#%C2%A0%E4%B8%AD%E7%BA%A7-day5%E4%BD%9C%E4%B8%9A%E2%80%8B"> 中级-day5作业​</a></p>
<p id="%E4%B8%AD%E7%BA%A7-day6%E4%BD%9C%E4%B8%9A-toc" style="margin-left:80px;"><a href="#%E4%B8%AD%E7%BA%A7-day6%E4%BD%9C%E4%B8%9A">中级-day6作业</a></p>
<p id="%E4%B8%AD%E7%BA%A7-day7%E4%BD%9C%E4%B8%9A-toc" style="margin-left:80px;"><a href="#%E4%B8%AD%E7%BA%A7-day7%E4%BD%9C%E4%B8%9A">中级-day7作业</a></p>
<p id="%E4%B8%AD%E7%BA%A7-day8%E4%BD%9C%E4%B8%9A-toc" style="margin-left:80px;"><a href="#%E4%B8%AD%E7%BA%A7-day8%E4%BD%9C%E4%B8%9A">中级-day8作业</a></p>
<p id="%E4%B8%AD%E7%BA%A7-day9%E4%BD%9C%E4%B8%9A-toc" style="margin-left:80px;"><a href="#%E4%B8%AD%E7%BA%A7-day9%E4%BD%9C%E4%B8%9A">中级-day9作业</a></p>
<p id="%E4%B8%AD%E7%BA%A7-day10%E4%BD%9C%E4%B8%9A-toc" style="margin-left:80px;"><a href="#%E4%B8%AD%E7%BA%A7-day10%E4%BD%9C%E4%B8%9A">中级-day10作业</a></p>
<p id="%E4%B8%AD%E7%BA%A7day11-%E4%BD%9C%E4%B8%9A-toc" style="margin-left:80px;"><a href="#%E4%B8%AD%E7%BA%A7day11-%E4%BD%9C%E4%B8%9A">中级day11-作业</a></p>
<p id="%E4%B8%AD%E7%BA%A7day12-%E4%BD%9C%E4%B8%9A-toc" style="margin-left:80px;"><a href="#%E4%B8%AD%E7%BA%A7day12-%E4%BD%9C%E4%B8%9A">中级day12-作业</a></p>
<p id="%E9%AB%98%E7%BA%A7%E9%98%B6%E6%AE%B5-toc" style="margin-left:0px;"><a href="#%E9%AB%98%E7%BA%A7%E9%98%B6%E6%AE%B5">高级阶段</a></p>
<p id="%E9%AB%98%E7%BA%A7day1-%E4%BD%9C%E4%B8%9A-toc" style="margin-left:80px;"><a href="#%E9%AB%98%E7%BA%A7day1-%E4%BD%9C%E4%B8%9A">高级day1-作业</a></p>
<p id="%E9%AB%98%E7%BA%A7day2-%E4%BD%9C%E4%B8%9A-toc" style="margin-left:80px;"><a href="#%E9%AB%98%E7%BA%A7day2-%E4%BD%9C%E4%B8%9A">高级day2-作业</a></p>
<p style="margin-left:80px;"><a href="#%E9%AB%98%E7%BA%A7day2-%E4%BD%9C%E4%B8%9A">高级day3-作业</a></p>
<p style="margin-left:80px;"><a href="#%E9%AB%98%E7%BA%A7day2-%E4%BD%9C%E4%B8%9A">高级day4-作业</a></p>
<p style="margin-left:80px;"><a href="#%E9%AB%98%E7%BA%A7day2-%E4%BD%9C%E4%B8%9A">高级day5-作业</a></p>
<p style="margin-left:80px;"><a href="#%E9%AB%98%E7%BA%A7day2-%E4%BD%9C%E4%B8%9A">高级day6-作业</a></p>
<hr id="hr-toc"/>
<p></p>
<p></p>
<h1 id="%E5%88%9D%E7%BA%A7%E9%98%B6%E6%AE%B5">初级阶段</h1>
<h3 id="week1-day1%E4%BD%9C%E4%B8%9A">week1-day1作业</h3>
<p><img alt="" height="622" src="image\d11abacdba6f4ea1bcf4ce1204c63b92.png" width="1200"/></p>
<pre><code class="language-cpp">#include &lt;stdio.h&gt;

int main()
{
    printf("hello wangdao\n");
    
    return 0;
}
</code></pre>
<h3 id="week1-day2%E4%BD%9C%E4%B8%9A">week1-day2作业</h3>
<p><img alt="" height="546" src="image\4343e8eb913f4edd9efac089f777d5eb.png" width="1200"/></p>
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS //解决scanf编译报错问题(考试不需要写)
#include&lt;stdio.h&gt;

int main()
{
    int a,b;
    scanf("%d%d", &amp;a,&amp;b);//一定要在变量前加取地址符&amp;
    printf("%d\n", a+b);
}</code></pre>
<p></p>
<h3 id="week1-day3%E4%BD%9C%E4%B8%9A">week1-day3作业</h3>
<p><img alt="" height="550" src="image\04f11e9f74964d7589d30baa73a03c47.png" width="1200"/></p>
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS
#include&lt;stdio.h&gt;
int main()
{
    int a;
    scanf("%d", &amp;a);
    if (65 &lt; a &lt; 122)
        printf("%c", a);
    return 0;
} </code></pre>
<p></p>
<h3 id="week2-day4%E4%BD%9C%E4%B8%9A1">week2-day4作业1</h3>
<p><img alt="" height="694" src="image\c20e6ba7b30f4df19bef3b56af7c38ae.png" width="1200"/></p>
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS
#include&lt;stdio.h&gt;
int main()
{
    int year;
    scanf("%d", &amp;year);
    if (year % 400 == 0 || year % 4 == 0 &amp;&amp; year % 100 != 0)//能被4整除但不能被100整除或者能被400整除
    {
        printf("yes\n");

    }
    else {
        printf("no\n");
    }

}</code></pre>
<p></p>
<h3 id="week2-day5%E4%BD%9C%E4%B8%9A">week2-day5作业</h3>
<p><img alt="" height="578" src="image\0b44788c22d84ac0ad0c2f66c6e89ebc.png" width="1200"/></p>
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS
#include&lt;stdio.h&gt;
//一个scanf读多种类型的数据
//混合输入时每次在%c之前需要加入一个空格
int main()
{
    int i;
    char j;
    float k;
    scanf("%d %c%f", &amp;i, &amp;j, &amp;k);
    //printf("%.2f",(float)i+(float)j+k);
    printf("%0.2f\n", i + j + k);
    return 0;
}</code></pre>
<p></p>
<h3 id="week2-day6%E4%BD%9C%E4%B8%9A">week2-day6作业</h3>
<p><img alt="" height="729" src="image\92a90c37cd0d489587e20e763e6d8e37.png" width="1200"/></p>
<pre><code class="language-cpp"> #define _CRT_SECURE_NO_WARNINGS
#include&lt;stdio.h&gt;
//把最初输入的整型数a，反过来后，再存到另外一个整形数b，判断a和b是否相等，如果相等就输出yes，不等就输出no
int main() 
{
    int a,b,c,tmp;
    while (scanf("%d", &amp;a) != EOF)
    {
        b = 0;
        c = a;
        while (a)
        {
            tmp = a % 10;
            b = b * 10 + tmp;
            a = a / 10;
        }
        if (c == b)
        {
            printf("yes\n");
        }
        else
        {
            printf("no\n");
        }
    }
    return 0;
}</code></pre>
<p></p>
<h3 id="%C2%A0week3-day7%E4%BD%9C%E4%B8%9A1"> week3-day7作业1</h3>
<p><img alt="" height="734" src="image\d1f9f1462b874141a36762d55504cf03.png" width="1200"/></p>
<pre><code class="language-cpp">//while循环

 #define _CRT_SECURE_NO_WARNINGS
#include&lt;stdio.h&gt;
int main()
{
    int n;
    int i = 1;
    int total = 1;//存储最终的和
    scanf("%d", &amp;n);
    while (i &lt;= n)//while后面不能加分号，否则会进入死循环
    {
        total = total * i;
        i++;
    }
    printf("%d\n", total);
}

 //for循环

#define _CRT_SECURE_NO_WARNINGS
#include&lt;stdio.h&gt;
int main()
{
    int n;
    int i, total;
    scanf("%d", &amp;n);//读取输入
    //for语句中只能有两个分号
    for (i = 1, total = 1; i &lt;= n; i++)
    {
        total = total * i;
    }
    printf("%d\n", total);
}</code></pre>
<h3 id="week3-day7%E4%BD%9C%E4%B8%9A2">week3-day7作业2</h3>
<p><img alt="" height="612" src="image\484151fef82444b88f31e4e9323fec27.png" width="915"/></p>
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
int main() 
{
    int i, j, k, m, sum = 0;
    for (i = 1; i &lt;= 40; i++)
    {
        for (j = 1; j &lt;= 40; j++)
        {
            for (k = 1; k &lt;= 40; k++)
            {
                for (m = 1; m &lt;= 40; m++)
                {
                    if (i + j + k + m == 40 &amp;&amp; 10 * i + 5 * j + k + m * 2 == 100)
                    {
                        sum++;
                    }
                }
            }
        }
    }
    printf("%d", sum);
    return 0;
    
} </code></pre>
<h3 id="week3-day8%E4%BD%9C%E4%B8%9A">week3-day8作业</h3>
<p><img alt="" height="1089" src="image\a8fe00bb20684607ba0f22da196d7b54.png" width="1200"/></p>
<pre><code class="language-cpp"> #define _CRT_SECURE_NO_WARNINGS
#include&lt;stdio.h&gt;
int main()
{
    int a[100], n, k = 0;
    scanf("%d", &amp;n);//接下来要输入多少个元素
    for (int i = 0; i &lt; n; i++)
    {
        scanf("%d", &amp;a[i]);//如何往数组里元素读取数据
        if (a[i] == 2)
        {
            k++;
        }
    }
    printf("%d\n",k);
}</code></pre>
<h3 id="week3-day9%E4%BD%9C%E4%B8%9A">week3-day9作业</h3>
<p><img alt="" height="1200" src="image\90d910517c494f41b729cd290874d653.png" width="1200"/></p>
<pre><code class="language-cpp"> #define _CRT_SECURE_NO_WARNINGS
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
int main()
{
    char a[20];
    char b[20];
    int len;
    gets(a);
    len = strlen(a);//读取数组a的长度
    for (int i = 0; i &lt; len; i++)
    {
        b[i] = a[len - i - 1];//将a数组的下标存的数据赋值给逆转后b数组的下标
    }
    b[len] = '\0';//在b数组中，数据结束后添加结束符
    if (strcmp(a, b) &gt; 0)//判断原字符串是否大于逆转后的字符串
    {
        printf("1");
    }
    else if (strcmp(a, b) &lt; 0)
    {
        printf("-1");
    }
    else
    {
        printf("0");
    }
}</code></pre>
<h3 id="week4-day10%E4%BD%9C%E4%B8%9A">week4-day10作业</h3>
<p><img alt="" height="701" src="image\7587ddb308074dce9a6945512d0e0cbf.png" width="1200"/></p>
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS
#include&lt;stdio.h&gt;

void change(int *j)//j称为形参，j=&amp;i
{
    *j = *j/2;//指针的间接访问
}

int main()
{
    int i;//i是局部变量
    scanf("%d",&amp;i);
    change(&amp;i);//函数调用时，把&amp;i称为实参
    printf("%d\n", i);
    return 0;
}</code></pre>
<h3 id="week4-day11%E4%BD%9C%E4%B8%9A">week4-day11作业</h3>
<p><img alt="" height="1072" src="image\206ec9c685bf4a51a71768043ec84f8b.png" width="1200"/></p>
<p></p>
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS
#include&lt;stdio.h&gt;
//malloc可以帮我们实现动态数组
int main()
{
    int i;//申请多大的空间
    scanf("%d", &amp;i);
    char* p;
    p = malloc(i);//malloc申请空间的单位是字节
    char c;
    scanf("%c", &amp;c);//为了去除缓冲区里边的\n
    gets(p);//如果不通过上面的scanf去消除\n，gets不会卡住
    puts(p);
    return 0;
}</code></pre>
<h3 id="%C2%A0week4-day12%E4%BD%9C%E4%B8%9A"> week4-day12作业</h3>
<p><img alt="" height="1007" src="image\ffab7ad5732c4729927ccae356357eb2.png" width="1200"/></p>
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS
#include&lt;stdio.h&gt; 

int step(int n)
{
    if (1 == n || 2 == n)//递归的结束条件
    {
        return n;
    }
    return step(n - 1) + step(n - 2);//递归公式
}

int main()
{
    int n;//存储台阶
    scanf("%d", &amp;n);
    printf("%d\n", step(n));
    return 0;
}</code></pre>
<h2 id="%E4%B8%AD%E7%BA%A7%E9%98%B6%E6%AE%B5">中级阶段</h2>
<h3 id="%E4%B8%AD%E7%BA%A7-day1">中级-day1</h3>
<p><img alt="" height="566" src="image\20ecf95a81a74c9089e1ef523f6d50a4.png" width="1200"/></p>
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS
#include&lt;stdio.h&gt;

//结构体指针
struct student
{
    int num;
    char name[20];
    char sex;
};//结构体类型声明，注意最后一定要加分号
int main()
{
    struct student sarr[1];
    int i=0;
        scanf("%d%s %c", &amp;sarr[i].num, sarr[i].name, &amp;sarr[i].sex);
        printf("%d %s %c\n", sarr[i].num, sarr[i].name, sarr[i].sex);
    
    return 0;
}</code></pre>
<h3 id="%C2%A0%E4%B8%AD%E7%BA%A7-day2%E4%BD%9C%E4%B8%9A"> 中级-day2作业</h3>
<p><img alt="" height="718" src="image\cff8c7a1400a47e3924040f46bf722a5.png" width="1200"/></p>
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
void modify_pointer(char*&amp;p) {
    p = (char*)malloc(100);
    fgets(p, 100, stdin);//如果使用fgets传入的是一个指针变量，中间参数是指针指向的空间大小

}
int main() {
    char* p;
    modify_pointer(p);
    puts(p);
    return 0;
}</code></pre>
<h3 id="%E4%B8%AD%E7%BA%A7day3%E4%BD%9C%E4%B8%9A">中级day3作业</h3>
<p> <img alt="" height="1158" src="image\cf48f9e00f6249588270755f4db34f2f.png" width="1200"/></p>
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

#define MaxSize 50
typedef int ElemType;//顺序表中元素的类型
//静态分配
typedef struct {
    ElemType data[MaxSize];//定义的数组，用来存元素
    int length;//当前顺序表中有多少个元素
}SqList;

//i代表插入的位置，从1开始，e要插入的元素
bool ListInsert(SqList&amp; L, int i, ElemType e)
{
    if (i&lt;1 || i&gt;L.length + 1)//判断要插入的位置是否合法
        return false;
    if (L.length &gt;= MaxSize)//超出了空间,元素存储满了，不能再存了
        return false;
    for (int j = L.length; j &gt;= i; j--)//移动顺序表中的元素
        L.data[j] = L.data[j - 1];
    L.data[i - 1] = e;//数组下标从零开始，插入第一个位置，访问的下标为零
    L.length++;
    return true;//插入成功，返回true
}
//删除使用元素e的引用的目的是拿出对应的值
bool ListDelete(SqList&amp; L, int i, ElemType&amp; e)
{
    if (i&lt;1 || i&gt;L.length)//如果删除的位置是不合法
        return false;
    if (L.length == 0)//顺序表中没有元素，无需删除
    {
        return false;
    }
    e = L.data[i - 1];//获取顺序表中对应的元素，赋值给e
    for (int j = i; j &lt; L.length; j++)//从i的位置依次把元素往前覆盖
        L.data[j - 1] = L.data[j];
    L.length--;
    return true;//删除一个元素，顺序表长度减1
}
//打印顺序表元素
void PrintList(SqList&amp; L)
{
    for (int i = 0; i &lt; L.length; i++)
    {
        printf("%3d", L.data[i]);//要求所有元素打印到一排
    }
    printf("\n");
}
//要不要加引用，就是看是不是在子函数中去改变主函数中对应的变量，要改就要加
int main()
{
    
    SqList L;//顺序表的名称
    bool ret;//查看返回值，布尔型是true，或者false
    ElemType del;//用来存要删除的元素
    //首先手动在顺序表中赋值
    L.data[0] = 1;
    L.data[1] = 2;
    L.data[2] = 3;
    L.length = 3;//总计三个元素
    int i;
    scanf("%d\n", &amp;i);
    ret = ListInsert(L, 2, i);//往第二个位置插入6这个元素
    if (ret)
    {
        PrintList(L);//打印成功后的顺序表
    }
    else {
        printf("插入失败\n");
    }
    int k;
    scanf("%d\n", &amp;k);
    ret = ListDelete(L,k,del);//删除第一个位置的元素，把元素输出
    if (ret)
    {
        PrintList(L);
    }
    else {
        printf("false\n");
    }
    return 0;
}</code></pre>
<h3 id="%E4%B8%AD%E7%BA%A7-day4%E4%BD%9C%E4%B8%9A">中级-day4作业</h3>
<p><img alt="" height="1200" src="image\190286c3421349abb382b63fab0c85ad.png" width="1200"/></p>
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
typedef int ElemType;
typedef struct LNode {
    ElemType data;
    struct LNode* next;//指向下一个节点
}LNode,*LinkList;
//头插法新建链表
LinkList CreatList1(LinkList&amp; L)//list_head_insert
{
    LNode* s; int x;
    L = (LinkList)malloc(sizeof(LNode));//带头结点的链表
    L-&gt;next = NULL;//L-&gt;data里边没放东西
    scanf("%d", &amp;x);//从标准输入读取数据
    //3 4 5 6 9999
    while (x != 9999) {
        s = (LNode*)malloc(sizeof(LNode));//申请一个新空间给s，强制类型转换
        s-&gt;data = x;//把读取到的值，给新空间中的data成员
        s-&gt;next = L-&gt;next;//让新结点的next指针指向链表的第一个元素（第一个放我们数据的元素）
        L-&gt;next = s;//让s作为第一的元素
        scanf("%d", &amp;x);//读取标准输入
    }
    return L;
}
//尾插法新建链表
LinkList CreatList2(LinkList &amp;L)//list_tail_insert
{
    int x;
    L = (LinkList)malloc(sizeof(LNode));//带头结点的链表
    LNode* s, * r = L;//LinkList s,r=L;也可以，r代表链表表尾结点，指向链表尾部
    //3 4 5 6 9999
    scanf("%d\n", &amp;x);
    while (x!=9999)
    {
        s = (LNode*)malloc(sizeof(LNode));
        s-&gt;data = x;
        r-&gt;next = s;//让尾部节点指向新节点
        r = s;//r指向新的表尾结点
        scanf("%d\n", &amp;x);
    }
    r-&gt;next = NULL;//尾结点的next指针赋值为null
    return L;
    
}
//打印链表中每个结点的值
void PrintList(LinkList L)
{
    L = L-&gt;next;
    while (L != NULL)//NULL是为了代表一张空的藏宝图
    {
        printf("%3d", L-&gt;data);//打印当前节点数据
        L = L-&gt;next;//指向下一个节点
        if (L != NULL)
        {
            printf(" ");
        }
    }
    printf("\n");
}
int main()
{
    LinkList L;
    LinkList search;
    CreatList1(L);//输入数据可以为3 4 5 6 7 9999，头插法新建链表
    PrintList(L);//链表打印
    CreatList2(L);//输入数据可以为3 4 5 6 7 9999，尾插法新建链表
    PrintList(L);
    return 0;
} </code></pre>
<h3 id="%C2%A0%E4%B8%AD%E7%BA%A7-day5%E4%BD%9C%E4%B8%9A%E2%80%8B"> 中级-day5作业<img alt="" height="1200" src="image\d583fc9dfe824b0ea1b458772ed0dd19.png" width="1200"/></h3>
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
typedef int ElemType;
typedef struct LNode {
    ElemType data;
    struct LNode* next;//指向下一个节点
}LNode,*LinkList;
//尾插法建立链表
LinkList CreatList(LinkList&amp; L)//list_tail_insert
{
    int x;
    L = (LinkList)malloc(sizeof(LNode));//带头结点的链表
    LNode* s, * r = L;//LinkList s,r=L;也可以，r代表链表表尾结点，指向链表尾部
    //3 4 5 6 7 9999
    scanf("%d", &amp;x);
    while (x != 9999) {
        s = (LNode*)malloc(sizeof(LNode));
        s-&gt;data = x;
        r-&gt;next = s;//让尾部节点指向新节点
        r = s;//r指向新的尾部节点
        scanf("%d", &amp;x);
    }
    r-&gt;next = NULL;
    return L;
}
//按序号查找结点值
LNode* GetElem(LinkList L, int i)
{
    int j = 1;
    LNode* p = L-&gt;next;
    if (i == 0)
        return L;
    if (i &lt; 1)
        return NULL;
    while (p&amp;&amp;j&lt;i)
    {
        p = p-&gt;next;
        j++;
    }
    return p;
}
//新结点插入第i个位置
bool LinstFrontInsert(LinkList L, int i, ElemType e)
{
    LinkList p = GetElem(L, i - 1);
    if (NULL == p)
    {
        return false;
    }
    LinkList s = (LNode*)malloc(sizeof(LNode));//为新插入的节点申请空间
    s-&gt;data = e;
    s-&gt;next = p-&gt;next;
    p-&gt;next = s;
    return true;
}
//删除第i个节点
bool ListDelete(LinkList L, int i)
{
    LinkList p = GetElem(L, i - 1);
    if (NULL == p)
    {
        return false;
    }
    LinkList q;
    q = p-&gt;next;
    p-&gt;next = q-&gt;next;//断链
    free(q);//释放对应节点的空间
    return true;
}
//打印链表中每个节点的位置
void PrintList(LinkList L)
{
    L = L-&gt;next;
    while (L!=NULL)
    {
        printf("%3d", L-&gt;data);
        L = L-&gt;next;//指向下一个节点
    }
    printf("\n");
}


int main()
{
    LinkList L;
    LinkList search;
    CreatList(L);
    //PrintList(L);
    search = GetElem(L, 2);//查找第二个位置的元素的值
    if (search != NULL)
    {
        printf("%d\n", search-&gt;data);

    }
    LinstFrontInsert(L, 2, 99);//新结点插入第i个位置
    PrintList(L);
    ListDelete(L, 4);//删除第4个节点
    PrintList(L);
}</code></pre>
<h3 id="%E4%B8%AD%E7%BA%A7-day6%E4%BD%9C%E4%B8%9A">中级-day6作业</h3>
<p><img alt="" height="1060" src="image\e2045b3d20b64612acface9d925e2c90.png" width="1200"/></p>
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#define MaxSize 50
typedef int ElemType;
typedef struct {
    ElemType data[MaxSize];//数组
    int top;
}SqStack;
//栈初始化
void InitStack(SqStack&amp; S)
{
    S.top = -1;//代表栈为空
}

//入栈
bool Push(SqStack&amp; S, ElemType x)
{
    if (S.top == MaxSize - 1)//数组的大小不能改变，避免访问越界
    {
        return false;
    }
    S.data[++S.top] = x;
    return true;
}
//出栈
bool Pop(SqStack&amp; S, ElemType&amp; x)
{
    if (-1 == S.top)
        return false;
    x = S.data[S.top--];
    printf(" %d", x);
    return true;
}
//队列
typedef struct {
    ElemType data[5];//数组，存放MaxSize-1个元素
    int front, rear;//队列头，队列尾
}SqQueue;
//队列初始化
void InitQueue(SqQueue&amp; Q)//初始化队列
{
    Q.rear = Q.front = 0;
}
//入队
bool EnQueue(SqQueue&amp; Q, ElemType x)
{
    if ((Q.rear + 1) % MaxSize == Q.front)//判断是否队满
        return false;
    Q.data[Q.rear] = x;//3 4 5 6 7
    Q.rear = (Q.rear + 1) % MaxSize;
    return true;
}
//出队
bool DeQueue(SqQueue&amp; Q, ElemType&amp; x)
{
    if (Q.rear == Q.front)
        return false;
    x = Q.data[Q.front];//先进先出
    Q.front = (Q.front + 1) % MaxSize;
    printf(" %d", x);
    return true;
}
int main()
{
    SqStack S;//后进先出LIFO
    ElemType m;//用来存放拿出的元素
    InitStack(S);//初始化
    ElemType a, b, c;
    scanf("%d %d %d\n", &amp;a, &amp;b, &amp;c);
    Push(S, a);
    Push(S, b);
    Push(S, c);
    SqQueue Q;
    ElemType element;//存储出队元素
    InitQueue(Q);//初始化队列
    //入队
    int n = 1;
    int n1;
    while (n &lt; 5)
    {
        scanf("%d", &amp;n1);
        EnQueue(Q, n1);
        n = n + 1;
    }
    Pop(S, m);
    Pop(S, m);
    Pop(S, m);
    printf("\n");
    if (n &gt; 4)printf("false\n");
    for(int i=1;i&lt;n;i++)
    {
        DeQueue(Q, element);
    }
    return 0;

}</code></pre>
<h3 id="%E4%B8%AD%E7%BA%A7-day7%E4%BD%9C%E4%B8%9A">中级-day7作业</h3>
<p><img alt="" height="569" src="image\49d548af355e4124b496cef46872b506.png" width="1200"/></p>
<p></p>
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
typedef int ElemType;
typedef char BiElemType;
typedef struct BiTNode {
    BiElemType c;//C就是书籍上的data
    struct BiTNode* lchild;
    struct BiTNode* rchild;
}BiTNode, * BiTree;


typedef struct tag {
    BiTree p;
    struct tag* pnext;
}tag_t, * ptag_t;
//队列的相关数据结构
typedef struct LinkNode {
    ElemType data;
    struct LinkNode* next;
}LinkNode;
typedef struct {
    LinkNode* front, * rear;
}LinkQueue;
void InitQueue(LinkQueue&amp; Q);
bool IsEmpty(LinkQueue Q);
void EnQueue(LinkQueue&amp; Q, ElemType x);
bool DeQueue(LinkQueue&amp; Q, ElemType&amp; x);


//带头结点的队列
void InitQueue(LinkQueue&amp; Q)
{
    Q.front = Q.rear = (LinkNode*)malloc(sizeof(LinkNode));
    Q.front-&gt;next = NULL;
}

bool IsEmpty(LinkQueue Q)
{
    if (Q.front == Q.rear)
        return true;
    else
        return false;
}

void EnQueue(LinkQueue&amp; Q, ElemType x)
{
    LinkNode* s = (LinkNode*)malloc(sizeof(LinkNode));
    s-&gt;data = x; s-&gt;next = NULL;
    Q.rear-&gt;next = s;
    Q.rear = s;
}

bool DeQueue(LinkQueue&amp; Q, ElemType&amp; x)
{
    if (Q.front == Q.rear) return false;
    LinkNode* p = Q.front-&gt;next;//头结点什么都没存，所以头结点的下一个节点才有数据
    x = p-&gt;data;
    Q.front-&gt;next = p-&gt;next;
    if (Q.rear == p)
        Q.rear = Q.front;
    free(p);
    return true;
}


//前序遍历
void preOrder(BiTree p)
{
    if (p != NULL)
    {
        putchar(p-&gt;c);//等价于visit函数
        preOrder(p-&gt;lchild);
        preOrder(p-&gt;rchild);
    }
}

int main()
{
    BiTree pnew;
    int i, j, pos;
    char c;
    BiTree tree = NULL;//树根
    ptag_t phead = NULL, ptail = NULL, listpnew = NULL, pcur = NULL;//phead是队列头，ptail是队列尾
    while (scanf("%c", &amp;c) != EOF)
    {
        if (c == '\n')
        {
            break;
        }
        pnew = (BiTree)calloc(1, sizeof(BiTNode));//calloc申请空间并对空间进行初始化，赋值为0
        pnew-&gt;c = c;//数据放进去
        listpnew = (ptag_t)calloc(1, sizeof(tag_t));//给队列结点申请空间
        listpnew-&gt;p = pnew;
        if (NULL == tree)
        {
            tree = pnew;//树的根
            phead = listpnew;//队列头
            ptail = listpnew;//队列尾
            pcur = listpnew;
            continue;
        }
        else
        {
            ptail-&gt;pnext = listpnew;//新节点放入链表，通过尾插法
            ptail = listpnew;//ptail指向队列尾部
        }//pcur始终指向要插入的位置
        if (NULL == pcur-&gt;p-&gt;lchild)//如何把新节点放入树
        {
            pcur-&gt;p-&gt;lchild = pnew;//把新节点放到要插入结点的左边
        }
        else if (NULL == pcur-&gt;p-&gt;rchild)
        {
            pcur-&gt;p-&gt;rchild = pnew;//把新节点放到要插入结点的右边
            pcur = pcur-&gt;pnext;//左右都放了结点后，pcur指向队列的下一个
        }

    }
    preOrder(tree);
}</code></pre>
<h3 id="%E4%B8%AD%E7%BA%A7-day8%E4%BD%9C%E4%B8%9A">中级-day8作业</h3>
<p><img alt="" height="634" src="image\0767a46b29074e928e9938316b54f298.png" width="1200"/></p>
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
typedef char BiElemType;
typedef struct BiTNode {
    BiElemType c;//c就是书籍上的data
    struct BiTNode* lchild;
    struct BiTNode* rchild;
}BiTNode, * BiTree;

typedef struct tag {
    BiTree p;//树的某一个结点的地址值
    struct tag* pnext;
}tag_t, * ptag_t;
#define MaxSize 50
typedef BiTree ElemType;
//队列的相关数据结构
typedef struct LinkNode {
    ElemType data;
    struct LinkNode* next;
}LinkNode;
typedef struct {
    LinkNode* front, * rear;
}LinkQueue;
void InitQueue(LinkQueue&amp; Q);
bool IsEmpty(LinkQueue Q);
void EnQueue(LinkQueue&amp; Q, ElemType x);
bool DeQueue(LinkQueue&amp; Q, ElemType&amp; x);
//带头结点的队列
void InitQueue(LinkQueue&amp; Q)
{
    Q.front = Q.rear = (LinkNode*)malloc(sizeof(LinkNode));
    Q.front-&gt;next = NULL;
}

bool IsEmpty(LinkQueue Q)
{
    if (Q.front == Q.rear)
        return true;
    else
        return false;
}

void EnQueue(LinkQueue&amp; Q, ElemType x)
{
    LinkNode* s = (LinkNode*)malloc(sizeof(LinkNode));
    s-&gt;data = x; s-&gt;next = NULL;
    Q.rear-&gt;next = s;
    Q.rear = s;
}

bool DeQueue(LinkQueue&amp; Q, ElemType&amp; x)
{
    if (Q.front == Q.rear) return false;
    LinkNode* p = Q.front-&gt;next;//头结点什么都没存，所以头结点的下一个节点才有数据
    x = p-&gt;data;
    Q.front-&gt;next = p-&gt;next;
    if (Q.rear == p)
        Q.rear = Q.front;
    free(p);
    return true;
}

//中序遍历  hdibjeafcg
void InOrder(BiTree p)
{
    if (p != NULL)
    {
        InOrder(p-&gt;lchild);
        putchar(p-&gt;c);
        InOrder(p-&gt;rchild);
    }
}
//hidjebfgca  后序遍历
void PostOrder(BiTree p)
{
    if (p != NULL)
    {
        PostOrder(p-&gt;lchild);
        PostOrder(p-&gt;rchild);
        putchar(p-&gt;c);
    }
}

//层次遍历,层序遍历，广度优先遍历
void LevelOrder(BiTree T)
{
    LinkQueue Q;//辅助队列
    InitQueue(Q);//初始化队列
    BiTree p;
    EnQueue(Q, T);//树根入队
    while (!IsEmpty(Q))
    {
        DeQueue(Q, p);//出队当前结点并打印
        putchar(p-&gt;c);
        if (p-&gt;lchild != NULL) //入队左孩子
            EnQueue(Q, p-&gt;lchild);
        if (p-&gt;rchild != NULL)  //入队右孩子
            EnQueue(Q, p-&gt;rchild);
    }
}
int main()
{
    BiTree pnew;
    int i, j, pos;
    char c;
    BiTree tree = NULL;//树根
    ptag_t phead = NULL, ptail = NULL, listpnew = NULL, pcur = NULL;//phead就是队列头，ptail就是队列尾
    //abcdefghij
    while (scanf("%c", &amp;c) != EOF)
    {
        if (c == '\n')
        {
            break;
        }
        pnew = (BiTree)calloc(1, sizeof(BiTNode));//calloc申请空间并对空间进行初始化，赋值为0
        pnew-&gt;c = c;//数据放进去
        listpnew = (ptag_t)calloc(1, sizeof(tag_t));//给队列结点申请空间
        listpnew-&gt;p = pnew;
        if (NULL == tree)
        {
            tree = pnew;//树的根
            phead = listpnew;//队列头
            ptail = listpnew;//队列尾
            pcur = listpnew;
            continue;
        }
        else {
            ptail-&gt;pnext = listpnew;//新结点放入链表，通过尾插法
            ptail = listpnew;//ptail指向队列尾部
        }//pcur始终指向要插入的结点的位置
        if (NULL == pcur-&gt;p-&gt;lchild)//如何把新结点放入树
        {
            pcur-&gt;p-&gt;lchild = pnew;//把新结点放到要插入结点的左边
        }
        else if (NULL == pcur-&gt;p-&gt;rchild)
        {
            pcur-&gt;p-&gt;rchild = pnew;//把新结点放到要插入结点的右边
            pcur = pcur-&gt;pnext;//左右都放了结点后，pcur指向队列的下一个
        }
    }
    InOrder(tree);
    printf("\n");
    PostOrder(tree);
    printf("\n");
    LevelOrder(tree);
    printf("\n");
}</code></pre>
<h3 id="%E4%B8%AD%E7%BA%A7-day9%E4%BD%9C%E4%B8%9A">中级-day9作业</h3>
<p><img alt="" height="673" src="image\e5ef6673a72d4d63820266e2c45f4cfc.png" width="1200"/></p>
<p></p>
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
typedef int KeyType;
typedef struct BSTNode {
    KeyType key;
    struct BSTNode* lchild, * rchild;
}BSTNode, * BiTree;
//54 20 66 40 28 79 58
int BST_Insert(BiTree&amp; T, KeyType k)
{
    if (NULL == T)
    {
        //为新节点申请空间
        T = (BiTree)malloc(sizeof(BSTNode));
        T-&gt;key = k;
        T-&gt;lchild = T-&gt;rchild = NULL;
        return 1;//代表插入成功
    }
    else if (k == T-&gt;key)
        return 0;//发现相同元素，就不插入
    else if (k &lt; T-&gt;key)
        return BST_Insert(T-&gt;lchild, k);
    else
        return BST_Insert(T-&gt;rchild, k);
}

//创建二叉排序树
void Create_BST(BiTree&amp; T, KeyType str[], int n)
{
    T = NULL;
    int i = 0;
    while (i &lt; n)
    {
        BST_Insert(T, str[i]);
        i++;
    }
}
//中序遍历
void InOrder(BiTree T, KeyType str[], int&amp; pos)
{
    if (T != NULL)
    {
        InOrder(T-&gt;lchild, str, pos);
        printf("%3d", T-&gt;key);
        str[pos++] = T-&gt;key;//输出的同时存入数组
        InOrder(T-&gt;rchild, str, pos);
    }
}
typedef int ElemType;
typedef struct {
    ElemType* elem;//整形指针
    int TableLen;
}SSTable;
int Binary_Search(SSTable L, ElemType key)
{
    int low = 0, high = L.TableLen - 1, mid;
    while (low &lt;= high)
    {
        mid = (low + high) / 2;
        if (L.elem[mid] == key)
            return mid;
        else if (L.elem[mid] &gt; key)
            high = mid - 1;
        else
            low = mid + 1;
    }
    return -1;
}
int main()
{
    BiTree T = NULL;
    BiTree parent;//存储父亲节点的地址值
    BiTree search;
    KeyType str[10];//将要进入二叉排序树的元素值
    int i;
    for (i = 0; i &lt; 10; i++)
    {
        scanf("%d", &amp;str[i]);
    }
    Create_BST(T, str, 10);
    int pos = 0;
    InOrder(T, str, pos);//中序遍历把有序数组的结果存到str数组中
    printf("\n");
    SSTable L;
    L.elem = str;
    L.TableLen = 10;
    pos = Binary_Search(L, 21);
    printf("%d\n", pos);
    return 0;

}</code></pre>
<h3 id="%E4%B8%AD%E7%BA%A7-day10%E4%BD%9C%E4%B8%9A">中级-day10作业</h3>
<p><img alt="" height="627" src="image\cabcee19de2847c4a34638e0d300764d.png" width="1200"/></p>
<p></p>
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

int main()
{
    char j;
    scanf("%c",&amp;j);
    int i;
    int arr[9] = { 0,1,1,2,2,3,1,1,2 };
    for (i = 0; i &lt; 9; i++)
    {
        printf("%2d", arr[i]);
    }
    return 0;
}</code></pre>
<h3 id="%E4%B8%AD%E7%BA%A7day11-%E4%BD%9C%E4%B8%9A">中级day11-作业</h3>
<p><img alt="" height="781" src="image\1ccf5c12503e43d9a5b57b132594618e.png" width="1200"/></p>
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include &lt;time.h&gt;
#include&lt;string.h&gt;

typedef int ElemType;
typedef struct {
    ElemType* elem;//存储元素的起始地址
    int TableLen;
}SSTable;
void ST_Init(SSTable&amp; ST, ElemType A[],int len)
{
    ST.TableLen = len;
    ST.elem = (ElemType*)malloc(sizeof(ElemType) * ST.TableLen);
    int i;
    for (i = 0; i &lt; ST.TableLen; i++)
    {
        ST.elem[i] = A[i];
    }

}
void ST_print(SSTable ST)
{
    for (int i = 0; i &lt; ST.TableLen; i++)
    {
        printf("%3d", ST.elem[i]);
    }
    printf("\n");
}
void swap(ElemType&amp; a, ElemType&amp; b)
{
    ElemType tmp;
    tmp = a;
    a = b;
    b = tmp;
}
void BubbleSort1(ElemType A[], int n)
{
    int i, j, flag;
    for (i = 0; i &lt; n - 1; i++)//i是控制有多少个有序了
    {
        flag = 0;
        for (j = n - 1; j &gt; i; j--)//内层控制比较，交换
        {
            if (A[j - 1] &gt; A[j])
            {
                swap(A[j - 1], A[j]);
                flag = 1;
            }
        }
    }
}
int Partition(int* arr, int left, int right)
{
    int k, i;
    for (k = i = left; i &lt; right; i++)
    {
        if (arr[i] &lt; arr[right])
        {
            swap(arr[i], arr[k]);
            k++;
        }
    }
    swap(arr[k], arr[right]);
    return k;
}


//递归实现
void QuickSort(ElemType A[], int low, int high)
{
    if (low &lt; high)
    {
        int pivotpos = Partition(A, low, high);//分割点左边的元素都比分割点要小，右边的比分割点大
        QuickSort(A, low, pivotpos - 1);
        QuickSort(A, pivotpos + 1, high);
    }
}
void InsertSort(ElemType A[], int n)
{
    int i, j;
    for (i = 2; i &lt; n; i++)
    {
        if (A[i] &lt; A[i - 1])
        {
            A[0] = A[i];//放到暂存位置，A[0]既是暂存，也是哨兵
            for (j = i - 1; A[0] &lt; A[j]; --j)//移动元素，内层循环控制有序序列中的每一个元素和要插入的元素比较
                A[j + 1] = A[j];
            A[j + 1] = A[0];//把暂存元素插入到对应位置
        }
    }
}
int main()
{
    SSTable ST;
    ElemType A[10];
    int i;
    for (i = 0; i &lt; 10; i++)
    {
        scanf("%d", &amp;A[i]);
    }
    ST_Init(ST,A, 10);//初始化
    BubbleSort1(ST.elem, 10);//冒泡排序
    ST_print(ST);
    QuickSort(ST.elem, 0, 9);//快速排序
    ST_print(ST);
    InsertSort(ST.elem, 10);//插入排序
    ST_print(ST);
}

 </code></pre>
<h3 id="%E4%B8%AD%E7%BA%A7day12-%E4%BD%9C%E4%B8%9A">中级day12-作业</h3>
<p><img alt="" height="685" src="image\8f92104e87484273b525427e7a9c1034.png" width="1200"/></p>
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;
#include &lt;string.h&gt;
typedef int ElemType;
typedef struct {
	ElemType* elem;
	int TableLen;
}SSTable;

void ST_Init(SSTable&amp; ST, ElemType A[], int len)
{
	ST.TableLen = len;
	ST.elem = (ElemType*)malloc(sizeof(ElemType) * ST.TableLen);
	int i;
	for (i = 0; i &lt; ST.TableLen; i++)
	{
		ST.elem[i] = A[i];
	}

}
void ST_print(SSTable ST)
{
	for (int i = 0; i &lt; ST.TableLen; i++)
	{
		printf("%3d", ST.elem[i]);
	}
	printf("\n");
}
void swap(ElemType&amp; a, ElemType&amp; b)
{
	ElemType tmp;
	tmp = a;
	a = b;
	b = tmp;
}
void SelectSort(ElemType A[], int n)
{
	int i, j, min;//min记录最小的元素的下标
	for (i = 0; i &lt; n - 1; i++)//最多可以为8
	{
		min = i;
		for (j = i + 1; j &lt; n; j++)//j最多可以为9
		{
			if (A[j] &lt; A[min])
				min = j;
		}
		if (min != i)
		{
			swap(A[i], A[min]);
		}
	}
}
//调整子树
void AdjustDown1(ElemType A[], int k, int len)
{
	int dad = k;
	int son = 2 * dad + 1;
	while (son &lt;= len)
	{
		if (son + 1 &lt;= len &amp;&amp; A[son] &lt; A[son + 1])//看下有没有右孩子，比较左右孩子选大的
		{
			son++;
		}
		if (A[son] &gt; A[dad])//比较孩子和父亲
		{
			swap(A[son], A[dad]);
			dad = son;
			son = 2 * dad + 1;
		}
		else {
			break;
		}
	}
}

void HeapSort1(ElemType A[], int len)
{
	int i;
	for (i = len / 2; i &gt;= 0; i--)
	{
		AdjustDown1(A, i, len);
	}
	swap(A[0], A[len]);//交换顶部和数组最后一个元素
	for (i = len - 1; i &gt; 0; i--)
	{
		AdjustDown1(A, 0, i);//剩下元素调整为大根堆
		swap(A[0], A[i]);
	}
}
//选择排序与堆排序
int main()
{
	SSTable ST;
	ElemType A[10]; 
	int i;
	for (i = 0; i &lt; 10; i++)
	{
		scanf("%d", &amp;A[i]);
	}
	ST_Init(ST,A, 10);//初始化
	memcpy(ST.elem, A, sizeof(A));
	SelectSort(ST.elem,10);
	ST_print(ST);
	HeapSort1(ST.elem, 9);//零号元素不参与排序
	ST_print(ST);
	return 0;
}</code></pre>
<h1 id="%E9%AB%98%E7%BA%A7%E9%98%B6%E6%AE%B5">高级阶段</h1>
<h3 id="%E9%AB%98%E7%BA%A7day1-%E4%BD%9C%E4%B8%9A">高级day1-作业</h3>
<p><img alt="" height="540" src="image\c571f31c1c724fcf949c161c005e2183.png" width="1200"/></p>
<p></p>
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#define N 10
typedef int ElemType;
void Merge(ElemType A[], int low, int mid, int high)
{
	ElemType B[N];//为了降低操作次数
	int i, j, k;
	for (k = low; k &lt;= high; k++)//复制元素到B中
		B[k] = A[k];
	for (i = low, j = mid + 1, k = i; i &lt;= mid &amp;&amp; j &lt;= high; k++)//合并两个有序数组
	{
		if (B[i] &lt;= B[j])
			A[k] = B[i++];
		else
			A[k] = B[j++];
	}
	while (i &lt;= mid)//如果有剩余元素，接着放入即可
		A[k++] = B[i++];
	while (j &lt;= high)
		A[k++] = B[j++];
}
void MergeSort(ElemType A[], int low, int high)//递归分割
{
	if (low &lt; high)
	{
		int mid = (low + high) / 2;
		MergeSort(A, low, mid);
		MergeSort(A, mid + 1, high);
		Merge(A, low, mid, high);
	}
}
void print(int* a)
{
	for (int i = 0; i &lt; N; i++)
	{
		printf("%3d", a[i]);
	}
	printf("\n");
}
// 归并排序
int main()
{
	int A[10];
	int i;
	for (i = 0; i &lt; 10; i++)
	{
		scanf("%d", &amp;A[i]);
	}
	MergeSort(A, 0, 9);
	print(A);
	return 0;
}
</code></pre>
<h3 id="%E9%AB%98%E7%BA%A7day2-%E4%BD%9C%E4%B8%9A">高级day2-作业</h3>
<p><img alt="" height="1200" src="image\40e7b2eed10f4fd9891524216f0d57ce.png" width="1200"/></p>
<p></p>
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;malloc.h&gt;
#include &lt;string.h&gt;

#define MAX 100
#define isLetter(a)  ((((a)&gt;='a')&amp;&amp;((a)&lt;='z')) || (((a)&gt;='A')&amp;&amp;((a)&lt;='Z')))
#define LENGTH(a)  (sizeof(a)/sizeof(a[0]))

// 邻接表中表对应的链表的顶点
typedef struct _ENode
{
    int ivex;                   // 该边所指向的顶点的位置,是数组的下标
    struct _ENode* next_edge;   // 指向下一条弧的指针
}ENode, * PENode;

// 邻接表中表的顶点
typedef struct _VNode
{
    char data;              // 顶点信息
    ENode* first_edge;      // 指向第一条依附该顶点的弧
}VNode;

// 邻接表
typedef struct _LGraph
{
    int vexnum;             // 图的顶点的数目
    int edgnum;             // 图的边的数目
    VNode vexs[MAX];
}LGraph;

/*
 * 返回ch在matrix矩阵中的位置
 */
static int get_position(LGraph g, char ch)
{
    int i;
    for (i = 0; i &lt; g.vexnum; i++)//去顶点结构体数组中遍历每个顶点
        if (g.vexs[i].data == ch)
            return i;//返回的是对应顶点的下标
    return -1;
}
/*
 * 读取一个输入字符
 */
 static char read_char()
 {
     char ch;
 
     do {
         ch = getchar();
     } while (!isLetter(ch));
 
     return ch;
 }

/*
 * 将node链接到list的末尾
 */
static void link_last(ENode* list, ENode* node)
{
    ENode* p = list;

    while (p-&gt;next_edge)
        p = p-&gt;next_edge;
    p-&gt;next_edge = node;
}


/*
 * 深度优先搜索遍历图的递归实现
 */
static void DFS(LGraph G, int i, int* visited)
{
    ENode* node;

    visited[i] = 1;//要访问当前结点了，所以打印
    printf(" %c", G.vexs[i].data);
    node = G.vexs[i].first_edge;//拿当前顶点的后面一个顶点
    while (node != NULL)
    {
        if (!visited[node-&gt;ivex])//只要对应顶点没有访问过，深入到下一个顶点访问
            DFS(G, node-&gt;ivex, visited);
        node = node-&gt;next_edge;//某个顶点的下一条边，例如B结点的下一条边
    }
}

/*
 * 深度优先搜索遍历图
 */
void DFSTraverse(LGraph G)
{
    int i;
    int visited[MAX];       // 顶点访问标记

    // 初始化所有顶点都没有被访问
    for (i = 0; i &lt; G.vexnum; i++)
        visited[i] = 0;
    //从A开始深度优先遍历
    for (i = 0; i &lt; G.vexnum; i++)
    {
        if (!visited[i])
            DFS(G, i, visited);
    }
    printf("\n");
}

/*
 * 广度优先搜索（类似于树的层次遍历）
 */
void BFS(LGraph G)
{
    int head = 0;
    int rear = 0;
    int queue[MAX];     // 辅组队列
    int visited[MAX];   // 顶点访问标记
    int i, j, k;
    ENode* node;

    //每个顶点未被访问
    for (i = 0; i &lt; G.vexnum; i++)
        visited[i] = 0;
    //从零号顶点开始遍历
    for (i = 0; i &lt; G.vexnum; i++)//对每个连同分量均调用一次BFS
    {
        if (!visited[i])//如果没访问过，就打印，同时入队,最初是A
        {
            visited[i] = 1;//标记已经访问过
            printf(" %c", G.vexs[i].data);
            queue[rear++] = i;  // 入队列
        }
        while (head != rear) //第一个进来的是A，遍历A的每一条边
        {
            j = queue[head++];  // 出队列
            node = G.vexs[j].first_edge;
            while (node != NULL)
            {
                k = node-&gt;ivex;
                if (!visited[k])
                {
                    visited[k] = 1;
                    printf(" %c", G.vexs[k].data);
                    queue[rear++] = k;//类似于树的层次遍历，遍历到的同时入队
                }
                node = node-&gt;next_edge;
            }
        }
    }
    printf("\n");
}


/*
 * 创建邻接表对应的图(有向图)
 */
LGraph* create_example_lgraph_directed()
{
    char c1, c2;
    char vexs[] = { 'A', 'B', 'C', 'D', 'E', 'F', 'G' };
    char edges[][2] = {
        {'A', 'B'},
        {'B', 'C'},
        {'B', 'E'},
        {'B', 'F'},
        {'C', 'E'},
        {'D', 'C'},
        {'E', 'B'},
        {'E', 'D'},
        {'F', 'G'} };
    int vlen = LENGTH(vexs);
    int elen = LENGTH(edges);
    int i, p1, p2;
    ENode* node1;
    LGraph* pG;
    if ((pG = (LGraph*)malloc(sizeof(LGraph))) == NULL)
        return NULL;
    memset(pG, 0, sizeof(LGraph));

    // 初始化"顶点数"和"边数"
    pG-&gt;vexnum = vlen;
    pG-&gt;edgnum = elen;
    // 初始化"邻接表"的顶点
    for (i = 0; i &lt; pG-&gt;vexnum; i++)
    {
        pG-&gt;vexs[i].data = vexs[i];
        pG-&gt;vexs[i].first_edge = NULL;
    }

    // 初始化"邻接表"的边
    for (i = 0; i &lt; pG-&gt;edgnum; i++)
    {
        // 读取边的起始顶点和结束顶点
        c1 = edges[i][0];
        c2 = edges[i][1];

        p1 = get_position(*pG, c1);
        p2 = get_position(*pG, c2);
        // 初始化node1
        node1 = (ENode*)calloc(1, sizeof(ENode));
        node1-&gt;ivex = p2;
        // 将node1链接到"p1所在链表的末尾"
        if (pG-&gt;vexs[p1].first_edge == NULL)
            pG-&gt;vexs[p1].first_edge = node1;
        else
            link_last(pG-&gt;vexs[p1].first_edge, node1);
    }
      
    return pG;
}
int main()
{
    LGraph* pG;
    pG = create_example_lgraph_directed();
    DFSTraverse(*pG);//深度优先遍历
    BFS(*pG);//广度优先遍历
    return 0;
}</code></pre>
<h3>高级day3-作业</h3>
<p><img alt="" height="638" src="image\ac167bc757e94bec8591e5a587081553.png" width="1200"/></p>
<p> </p>
<pre><code class="language-cpp">#include&lt;stdio.h&gt;


int main()
{
	printf("%3d%3d\n", 0, 13);
	return 0;
}</code></pre>
<h3>高级day4-作业</h3>
<p><img alt="" height="603" src="image\1a92753c5949482c858c4b6a16f0fb82.png" width="1200"/></p>
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS
#include&lt;stdio.h&gt;
int main()
{
	int i;
	scanf("%d", &amp;i);
	printf("%2d\n", i &lt;&lt; 1);
	printf("%2d\n", i &gt;&gt; 1);
		return 0;
}</code></pre>
<h3> 高级day5-作业</h3>
<p><img alt="" height="530" src="image\dabfc4943f964b2d9d12619f30806ee7.png" width="1200"/></p>
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS
#include&lt;stdio.h&gt;
int main()
{
	int i;
	int arr[5];
	for (i = 0; i &lt; 5; i++)
	{
		scanf("%d", arr + i);

	}
	int result=0;
	for (i = 0; i &lt; 5; i++)
	{
		result ^= arr[i];
	}
	printf("%d\n", result);
		return 0;
}
</code></pre>
<h3> 高级day6-作业</h3>
<p><img alt="" height="677" src="image\30899c54c7334acca1bdd1deb62bb5b0.png" width="1200"/></p>
<pre><code class="language-cpp">#include&lt;stdio.h&gt;

int main()
{
	printf("mov\npush\npop\n");
	return 0;
}</code></pre>
<p> </p>
</div>
</div>