<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="markdown_views prism-atom-one-dark" id="content_views">
<svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
<path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
</svg>
<h1><a id="let_constvar_0"></a>let 、const和var的区别</h1>
<p>let、const、var在js中都是用于声明变量的，在没有进行ES6的学习前，我基本只会使用到var关键字进行变量的声明，但在了解了ES6之后就涉及到了块级作用域以及let，const了。</p>
<h4><a id="letconst_2"></a>let与const</h4>
<ul><li>let是用于替代var来声明变量（var是ES6之前用来声明变量的关键词）</li><li>const是用来声明常量的（var，let声明变量时，变量一旦初始化之后，还可以重新赋值，const声明常量，一旦初始化，就不能重新赋值了，否则会报错）</li></ul>
<h4><a id="const_5"></a>const详细介绍</h4>
<p><strong>使用const的原因：const 就是为了那些一旦初始化就不希望重新赋值的情况设计的</strong></p>
<ul><li>注意事项：使用const声明常量，一旦声明，就必须立即初始化</li><li><em><strong>特殊说明</strong>：const声明常量，允许在不重新赋值的情况下修改它的值（基本数据类型不可，只有引用数据类型可以，引用类型引用的是地址不是值）</em></li></ul>
<pre><code class="prism language-html">//基本数据类型赋值为常量之后是不可修改的
const name='zhangsan';
name='nn'; //x
//引用数据类型
const student={age:18};
//student={};
student.age=19; 
</code></pre>
<p><img alt="const的两种修改" src="https://img-blog.csdnimg.cn/143dbe67c80045f0bd6706433384efd0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcXFfNDY4ODM4MzU=,size_16,color_FFFFFF,t_70,g_se,x_16#pic_center"/></p>
<p><strong>const的傻瓜使用指南</strong><br/> 毕竟基础数据类型去修改const会报错，那其实可以都用const进行变量的声明，当变量后面发生变化时自然会报错（前提是你还记得住，还是不太推荐这个傻瓜指南的）。</p>
<h3><a id="_24"></a>块级作用域</h3>
<p>咱就是说块级作用域简单说明一下，const和let的使用区别是会涉及到这个的</p>
<h6><a id="_26"></a>啥是作用域</h6>
<p>常见的作用域主要分为几个类型：全局作用域、函数作用域、块状作用域、动态作用域。</p>
<table><thead><tr><th>对象</th><th>类型</th></tr></thead><tbody><tr><td>global/window</td><td>全局作用域</td></tr><tr><td>function</td><td>函数作用域（局部作用域）</td></tr><tr><td>{}</td><td>块级作用域</td></tr><tr><td>this</td><td>动态作用域</td></tr></tbody></table>
<h6><a id="_34"></a>啥是块级作用域</h6>
<p>JS中作用域有：全局作用域、函数作用域。没有块作用域的概念。ECMAScript 6(简称ES6)中新增了块级作用域，使用let声明的变量只能在块级作用域里访问，有“暂时性死区”的特性（也就是说声明前不可用）。</p>
<ul><li><strong>块级作用域：</strong></li></ul>
<ol><li>块级作用域：<strong>大部分包含{}的都可以构成块级作用域，但是函数和对象不构成块级作用域</strong>（函数属于的是函数作用域而不是块级作用域，对象的话，又不能在里面let）</li><li><strong>作用域链：内层作用域-&gt;外层作用域-&gt;…-&gt;全局作用域</strong><br/> <img alt="作用域" src="https://img-blog.csdnimg.cn/9899cec0800c45debf477f80ff4eac68.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcXFfNDY4ODM4MzU=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center"/><br/> <strong>其中对于变量的查找只能是由内到外的</strong></li></ol>
<h2><a id="constvarlet_41"></a>const，var和let的区别</h2>
<p>let、const、var的区别：<strong>①重复声明 ②变量提升 ③暂时性死区 ④块级作用域 ⑤window对象的属性和方法（全局作用域中）</strong></p>
<h5><a id="1__44"></a>1. 区别一：重复声明</h5>
<ul><li>var允许重复声明，let、const不允许<br/> <img alt="重复申明" src="https://img-blog.csdnimg.cn/3fd69260c71b49c5ab448dcc4cfd269d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcXFfNDY4ODM4MzU=,size_18,color_FFFFFF,t_70,g_se,x_16#pic_center"/><br/> 【需要注意的是重复声明指的是：已经存在的变量或常量，又声明了一遍（<strong>形参也算已经声明的变量</strong>）】</li></ul>
<h5><a id="2__50"></a>2. 区别二：变量提升</h5>
<ul><li>var会提升变量的声明到作用域的顶部，但let和const不会（说白了就是let和const没有变量提升）<br/> <img alt="变量提升" src="https://img-blog.csdnimg.cn/ad3b153ae65243959ee4c3c991dc7aa9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcXFfNDY4ODM4MzU=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center"/>（无论是常量还是变量最好还是声明后再进行定义）</li></ul>
<h5><a id="3__55"></a>3. 区别三：暂时性死区</h5>
<ul><li>只要作用域内存在let、const，它们所声明的变量或常量就会自动“绑定”这个区域，不再受外部作用域的影响<br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/53e2fea4fb5c47b2b9b6806b51c8f1d5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcXFfNDY4ODM4MzU=,size_18,color_FFFFFF,t_70,g_se,x_16#pic_center"/><br/> 【简单说明一下：这个暂时性死区说白了就是在函数作用域内部声明的变量将会与对应的函数作用域进行绑定（当然没有的话还是会向上查找），当函数内部存在重复声明或者变量提示时，就算外面的作用域已经声明了这个变量，它的运行还是认准的该函数作用域中的声明情况】<img alt="var的暂时性死区" src="https://img-blog.csdnimg.cn/a7c6c48b94164cffaf9f6f9c3a9396d9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcXFfNDY4ODM4MzU=,size_18,color_FFFFFF,t_70,g_se,x_16#pic_center"/></li></ul>
<h5><a id="4_window_60"></a>4. 区别四：window对象的属性和方法（全局作用域中）</h5>
<ul><li>全局作用域中，var声明的变量，通过function声明的函数，会自动变为window对象的变量，属性或方法，但const和let不会<br/> <img alt="区别四" src="https://img-blog.csdnimg.cn/6f1b4e28471c47e785c88bbd3a30d449.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcXFfNDY4ODM4MzU=,size_15,color_FFFFFF,t_70,g_se,x_16#pic_center"/></li></ul>
<h5><a id="5__63"></a>5. 区别五：块级作用域</h5>
<ul><li>var没有块级作用域，let和const有块级作用域<br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/ac2394869b4c482eaeb5e160cf499737.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcXFfNDY4ODM4MzU=,size_14,color_FFFFFF,t_70,g_se,x_16#pic_center"/></li></ul>
</div>
<link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css" rel="stylesheet"/>
<link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css" rel="stylesheet"/>
</div>