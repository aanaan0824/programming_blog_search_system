<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="markdown_views prism-tomorrow-night" id="content_views">
<svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
<path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
</svg>
<h2><a id="1__0"></a>1. 写在前面</h2>
<p>c++在线编译工具，可快速进行实验: <a href="https://www.bejson.com/runcode/cpp920/">https://www.bejson.com/runcode/cpp920/</a></p>
<p>这段时间打算重新把c++捡起来， 实习给我的一个体会就是算法工程师是去解决实际问题的，所以呢，不能被算法或者工程局限住，应时刻提高解决问题的能力，在这个过程中，我发现cpp很重要， 正好这段时间也在接触些c++开发相关的任务，所有想借这个机会把c++重新学习一遍。 在推荐领域， 目前我接触到的算法模型方面主要是基于Python， 而线上的服务全是c++(算法侧， 业务那边基本上用go)，我们所谓的模型，也一般是训练好部署上线然后提供接口而已。所以现在也终于知道，为啥只单纯熟悉Python不太行了， cpp，才是yyds。</p>
<p>和python一样， 这个系列是重温，依然不会整理太基础性的东西，更像是查缺补漏， 不过，c++对我来说， 已经5年没有用过了， 这个缺很大， 也差不多相当重学了， 所以接下来的时间， 重温一遍啦 😉</p>
<p>资料参考主要是<a href="http://c.biancheng.net/cplus/">C语言中文网</a>和<a href="https://light-city.club/sc/">光城哥写的C++教程</a>，然后再加自己的理解和编程实验作为辅助，加深印象，当然有些地方我也会通过其他资料(C++ Primer Plus)进行扩充。 关于更多的细节，还是建议看这两个教程。</p>
<p>今天这篇文章学习多文件编程， 对于C++项目， 往往都是很多个<code>.h</code>和<code>.cpp</code>文件组合在一起最后构成程序， 这里面其实有很多细节需要注意， 之前在实习的时候， 参与过C++项目开发， 经常在cpp里面找不到某个类的声明或者某个函数的定义等等报错问题， 当时还觉得奇怪，明明都写好了？ 怎么还是报找不到呢？ 其实像多文件编程里面， 头文件的引入，命名空间的使用， const常量的使用，以及过个文件如何在一起编译等，是有很多细节东西的， 这篇文章就把这几个地方整理下，这样就能从一个项目的角度再审视C++啦。</p>
<p>主要内容:</p>
<ul><li>C++多文件编程初步</li><li>C++如何防止头文件被重复引入</li><li>C++命名空间如何应用在多文件编程中</li><li>C++ const常量如何在多文件编程中用</li><li>C++多文件项目如何用g++命令执行</li><li>C++多文件编程更深层原理</li><li>g++, MakeFile和CMake小补</li><li>小总</li></ul>
<p>Ok, let’s go!</p>
<h2><a id="2_C_24"></a>2. C++多文件编程初步</h2>
<p>为啥要用多文件编程呢？ 我们不妨先拿个单文件编程看看，比如建立一个student.cpp， 然后写下面代码：</p>
<pre><code class="prism language-cpp"><span class="token comment">// Stuent.cpp</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
 
<span class="token keyword">class</span> <span class="token class-name">Stuent</span><span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span>
    <span class="token keyword">int</span> age<span class="token punctuation">;</span>
    <span class="token keyword">float</span> score<span class="token punctuation">;</span>
    
    <span class="token keyword">void</span> <span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        cout <span class="token operator">&lt;&lt;</span> name <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> age <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span> 
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    Stuent <span class="token operator">*</span>pStu <span class="token operator">=</span> <span class="token keyword">new</span> Stuent<span class="token punctuation">;</span>
    pStu <span class="token operator">-&gt;</span> name <span class="token operator">=</span> <span class="token string">"wuzhongqiang"</span><span class="token punctuation">;</span>
    pStu <span class="token operator">-&gt;</span> age <span class="token operator">=</span> <span class="token number">25</span><span class="token punctuation">;</span>
    pStu <span class="token operator">-&gt;</span> score <span class="token operator">=</span> <span class="token number">92.5f</span><span class="token punctuation">;</span>
    pStu <span class="token operator">-&gt;</span> <span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token keyword">delete</span> pStu<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>这个程序比较简单，就是定义了一个类，然后用类建了一个对象，把对象的基本信息通过成员函数的方式输出了一下。 就这么个简单的功能， 在一个文件里面，就用了20多行的代码， 如果我们想完成复杂一点的功能， 这个文件代码会非常多，几百行几千行都有可能。</p>
<p>这时候， 在程序中阅读代码是非常难受的，并且查找的时候也不方便， 很多代码再考虑到内聚和耦合， 这样写肯定是行不通的。 所以往往当程序非常复杂的时候，就考虑把代码写成多个文件， 然后放到不同的目录进行管理，这样维护代码的时候，就非常容易了。<strong>分散代码遵循的基本原则: 实现相同功能的代码存储在一个文件</strong>。</p>
<p>一个完整的c++项目常常是多个代码文件组成，根据后缀名不同，大致分为两类:</p>
<ul><li><code>.h</code>文件: 头文件，用于存放常量，函数的声明部分，类的声明部分</li><li><code>.cpp</code>文件: 源文件，用于存放变量，函数的定义部分，类的实现部分</li></ul>
<p>虽然类内部的成员函数可以在声明的同时进行定义(自动成为内联)， 但原则上不推荐这样使用。即使定义成员函数代码很少，定义也应该放在适当的.cpp文件中。</p>
<p>根据上面的规则，就可以把上面代码进行拆分。</p>
<pre><code class="prism language-cpp"><span class="token comment">// student.h</span>
<span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span>
	<span class="token keyword">int</span> age<span class="token punctuation">;</span>
	<span class="token keyword">float</span> score<span class="token punctuation">;</span>
	<span class="token keyword">void</span> <span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// student.cpp</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"student.h"</span></span>
<span class="token keyword">void</span> <span class="token class-name">Student</span><span class="token operator">::</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> name <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> age<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// main.cpp</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"student.h"</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	Student <span class="token operator">*</span>pStu <span class="token operator">=</span> <span class="token keyword">new</span> Student<span class="token punctuation">;</span>
	pStu <span class="token operator">-&gt;</span> name <span class="token operator">=</span> <span class="token string">"wuzhongqiang"</span><span class="token punctuation">;</span>
	pStu <span class="token operator">-&gt;</span> age <span class="token operator">=</span> <span class="token number">25</span><span class="token punctuation">;</span>
	pStu <span class="token operator">-&gt;</span> score <span class="token operator">=</span> <span class="token number">92.5f</span><span class="token punctuation">;</span>
	pStu <span class="token operator">-&gt;</span> <span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">delete</span> pStu<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>程序进行合理地划分时，需要额外将 <code>"student.h"</code> 分别引入到 student.cpp 文件和 main.cpp 文件中，因为这 2 个文件中需要使用 <code>student.h</code> 文件声明的 Student 类，就如同我们在使用 cin 和 cout 时需要提前引入 头文件一样。</p>
<blockquote>
<p>注意，引入编译器自带的头文件（包括标准头文件）用尖括号，例如 ；引入自定义的头文件用 “” 双引号，例如 “student.h”</p>
</blockquote>
<p>这样， 程序就显得非常清晰了。</p>
<h2><a id="3_C_99"></a>3. C++如何防止头文件被重复引入</h2>
<p>头文件包含命令<code>#include</code>的效果与直接复制粘贴头文件内容效果是一样的， 预处理器实际上也是这样做的， 它会读取头文件的内容，然后输出到<code>#include</code>命令所在的位置。</p>
<blockquote>
<p>头文件包含是一个递归的过程，如果被包含的头文件中还包含了其他头文件，预处理器会继续将它们也包含进来，这个过程一直持续下去…</p>
</blockquote>
<p>但这样会导致一个问题，就是<strong>重复引入同一个源文件</strong>。比如下面的程序:</p>
<pre><code class="prism language-cpp"><span class="token comment">//student.h</span>
<span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//......</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">//school.h</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"student.h"</span></span>
<span class="token keyword">class</span> <span class="token class-name">School</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//......</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    Student stu<span class="token punctuation">[</span><span class="token number">50</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">//main.cpp</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"student.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"school.h"</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//......</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>运行此项目会发现，编译器报“Student 类型重定义”错误。这是因为在 <code>school.h</code> 文件中已经 <code>#include</code> 了一次 <code>"student.h"</code>，而在 main.cpp 主程序又同时 <code>#include</code> 了 <code>"school.h"</code> 和 <code>"student.h"</code>，即 Student 类的定义被引入了 2 次，C++不允许同一个类被重复定义。</p>
<p>那么，我们既然知道了在school.h文件中已经引入了Student类，那如果去掉<code>main.cpp</code>中的引入student.h文件呢？ 这个确实能解决这里的问题，但并不适合所有"重复引入"的场景。</p>
<blockquote>
<p>比如，a.h中定义了个类型TYPE1， b.h中定义了个类型TYPE2， 而这俩里面都包含了stdio.h。 如果我main.cpp要同时使用TYPE1和TYPE2，就必须将a.h和b.h包含进来。 这时候stdio.h被重复包含， 而这个情况，我们无法用上面方法解决。</p>
</blockquote>
<p>下面整理， C++多文件编程中， 处理"多次#include导致重复引入"问题的方式， 有下面3种:</p>
<ol><li> <p>使用宏定义避免重复引入<br/> 实际多文件开发中，往往使用下面的宏定义来避免重复引入:</p> <pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">_NAME_H</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">_NAME_H</span></span>
<span class="token comment">// 头文件内容</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
</code></pre> <p>其中，_NAME_H是宏的名称。<mark>需要注意的是，这里设置的宏名必须是独一无二的，不要和项目中其他宏的名称相同</mark>。</p>
<blockquote>
<p>当程序第一次<code>#include</code>该文件时， 由于<code>_NAME_H</code>尚未定义，所以会定义<code>_NAME_H</code>并执行"头文件内容代码"， 当发生多次<code>#include</code>时， 因为前面定义好了<code>_NAME_H</code>， 所以不会重复执行"头文件内容"部分的代码了。</p>
</blockquote> <p>所以， 将上面项目中student.h文件做如下修改：</p> <pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">_STUDENT_H</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">_STUDENT_H</span></span>
<span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">{<!-- --></span>
	<span class="token comment">//....</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
</code></pre> <p>虽然该项目 <code>main.cpp</code> 文件中仍 <code>#include</code> 了 2 次 <code>"student.h"</code>，但鉴于 <code>_STUDENT_H</code> 宏只能定义一次，所以 Student 类也仅会定义一次。再次执行该项目会发现，其可以正常执行。</p> </li><li> <p>使用<code>#pragma once</code>避免重复引入<br/> 除了第一种最常用方式之外，还可以使用<code>#pragma one</code>指令，将其附加到指定文件的最开头位置。则该文件只会被<code>#include</code>一次。</p> <pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">prama</span> <span class="token expression">once</span></span>
<span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">{<!-- --></span>
	<span class="token comment">//.....</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <p><code>#ifndef</code>是通过定义独一无二的宏来避免重复引入的， 这意味每次引入头文件都要进行识别，效率不高。 但考虑C和C++都支持宏定义，所以项目使用<code>#ifndef</code>规避可能出现的"头文件重复引入"问题，不会影响项目的可移植性。<br/><br/><code>#pragma once</code>不涉及宏定义，当编译器遇到它时就会立刻知道当前文件只引入一次，所以效率很高。 但值得一提的是，并不是每个版本编译器都能识别<code>#pragma one</code>指令，所以兼容性可能不是很好。 另外， <code>#pragma once</code>只能作用于某个具体文件， 无法像#ifndef那样仅作用于指定的一段代码。</p> </li><li> <p>使用_Pragma操作符<br/> C99标准中新增加了一个和<code>#pragma</code>指令类似的<code>_Pragma</code>操作符，可以看做是<code>#pragma</code>的plus版，不仅实现了<code>#prama</code>所有功能，更重要的， <code>_Pragma</code>还能和宏搭配使用。</p> <p>当处理头文件重复引入问题， 可以把下面的具体加到相应文件开头:</p> <pre><code class="prism language-cpp"><span class="token function">_Pragma</span><span class="token punctuation">(</span><span class="token string">"once"</span><span class="token punctuation">)</span>
<span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{<!-- --></span>
<span class="token comment">//......</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <p>事实上，无论是 C 语言还是 C++，为防止用户重复引入系统库文件，几乎所有库文件中都采用了以上 3 种结构中的一种，这也是为什么重复引入系统库文件编译器也不会报错的原因。</p> </li></ol>
<p>这三种方法的后两种其实是一类， 特点是编译效率高，但可移植性差(编译器不支持，会发出警告等)， 而<code>#ifndef</code>特点是可移植性高，编译效率差。 一般常用的是<code>#ifndef / #define / #endif</code> 组合解决头文件被重复引入的问题。</p>
<h2><a id="4_C_184"></a>4. C++命名空间如何应用在多文件编程</h2>
<p>C++引入命名空间是为了避免合作开发项目时产生的命名冲突， 当进行多文件编程的时候， 通常是将声明部分(变量、函数和类等)划分到<code>.h</code>文件中， 将实现部分划分到<code>.cpp</code>文件中。</p>
<p>这时候，如果是要给变量、函数或类指定命名空间， 则该命名空间至少包含它们的声明部分， 所以多文件编程时， <strong>命名空间在.h头文件中</strong>。</p>
<pre><code class="prism language-cpp"><span class="token comment">// student_li.h</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">_STUDENT_LI_H</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">_STUDENT_LI_H</span></span>
<span class="token keyword">namespace</span> Li<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">{<!-- --></span>
		<span class="token keyword">public</span><span class="token operator">:</span>
			<span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>

<span class="token comment">// student_li.cpp</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"student_li.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">void</span> Li<span class="token operator">::</span><span class="token class-name">Student</span><span class="token operator">::</span><span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Li::display"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// student_han.h</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">_STUDENT_HAN_H</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">_STUDENT_HAN_H</span></span>
<span class="token keyword">namespace</span> Han<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">{<!-- --></span>
		<span class="token keyword">public</span><span class="token operator">:</span>
			<span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>

<span class="token comment">// student_han.cpp</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"student_han.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">void</span> Han<span class="token operator">::</span><span class="token class-name">Student</span><span class="token operator">::</span><span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Han::display"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// main.cpp</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"student_li.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"student_han.h"</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	Li<span class="token operator">::</span>Student stu1<span class="token punctuation">;</span>
	stu1<span class="token punctuation">.</span><span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	Han<span class="token operator">::</span>Student stu2<span class="token punctuation">;</span>
	stu2<span class="token punctuation">.</span><span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>当类的声明位于指定的命名空间中时，如果要在类的外部实现其成员方法，需同时注明所在命名空间名和类名（例如本项目中的 <code>Li::Student::display()</code> ）</p>
<p>不同的头文件中可以使用不同的命名空间， 也可以使用相同的命名空间， 但后者的前提是位于该命名空间中的成员必须保证互不相同，否则会发生"重定义"错误。</p>
<pre><code class="prism language-cpp"><span class="token comment">//demo1.h</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">_DEMO1_H</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">_DEMO1_H</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">namespace</span> demo <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"demo1::display"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">int</span> num<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>

<span class="token comment">//demo2.h</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">_DEMO2_H</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">_DEMO2_H</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">namespace</span> demo <span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 这个虽然名字也叫display， 但是与上面那个是重载函数，并不是同一个</span>
    <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"demo2::display"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//int num; 因为 demo1.h 中已经声明有同名的变量，取消注释会造成重定义错误</span>
<span class="token punctuation">}</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
</code></pre>
<h2><a id="5_C_const_267"></a>5. C++ const常量如何在多文件编程中用</h2>
<p>多文件编程中代码划分原则: 将变量、函数或者类的声明部分存放到<code>.h</code>文件，对应的实现部分放在<code>.cpp</code>文件。但const常量是个小例外。</p>
<blockquote>
<p>const修饰的变量必须在定义的同时进行初始化操作(extern修饰除外)， const修饰除了表明变量是常量， 还将所修饰的变量可见范围限制到了当前文件。这意味着， 除非const常量的定义和main主函数位于同一个<code>.cpp</code>文件，否则该const常量只能在其所在的<code>.cpp</code>文件使用。</p>
</blockquote>
<p>如何定义const常量， 才能在其他文件中使用呢？ 有下面三种方法：</p>
<ol><li> <p>const常量定义在<code>.h</code>头文件中<br/> 这个最常用， 虽然有点违背上面的规律， C++多文件编程中，另外另个违背规律的(类的定义和内联函数定义，他们通常也都定义在<code>.h</code>头文件)</p> <pre><code class="prism language-cpp"><span class="token comment">//demo.h</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">_DEMO_H</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">_DEMO_H</span></span>
<span class="token keyword">const</span> <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>

<span class="token comment">// mian.cpp</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"demo.h"</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> num <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <p>将const常量定义在.h头文件中，只需要引入头文件， 就可以使用。</p> </li><li> <p>借助extern先声明再定义const常量<br/> const常量的定义先可以遵循"声明在.h文件，定义在.cpp文件"， 借助extern关键字。</p> <pre><code class="prism language-cpp"><span class="token comment">//demo.h</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">_DEMO_H</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">_DEMO_H</span></span>
<span class="token keyword">extern</span> <span class="token keyword">const</span> <span class="token keyword">int</span> num<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>

<span class="token comment">// demo.cpp</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"demo.h"</span></span>
<span class="token keyword">const</span> <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>

<span class="token comment">// main.cpp</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"demo.h"</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> num <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <p>C++ const 关键字会限定变量的可见范围为当前文件，即无法在其它文件中使用该常量。而 extern 关键字会 const 限定可见范围的功能，它可以使 const 常量的可见范围恢复至整个项目。</p> </li><li> <p>借助extern直接定义const常量<br/> 这个是第二种方式的简化， 直接在demo.cpp中定义和初始化即可。</p> <pre><code class="prism language-cpp"><span class="token comment">// demo.cpp</span>
<span class="token keyword">extern</span> <span class="token keyword">const</span> <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre> </li></ol>
<p>第一种方式是最常用， 更简单的方式。</p>
<h2><a id="6_Cg_322"></a>6. C++多文件项目如何用g++命令执行</h2>
<p>Linux平台一般使用g++命令执行c++程序， 当然也会用makefile文件运行较大的C++项目， 想在后面整理这个， 这个东西可以看做是g++代码整理， 有了MakeFile， 执行程序会更加快速方便。 但前提， 我们必须先深入了解C++程序的执行过程。</p>
<p>这个上面的那个在线网站就不好使了，需要找一个Linux系统玩下面的案例了。 我这里是用的实验室服务器， 如果是自己本子，可以安装一个虚拟机。 关于这个我有很多篇文章整理。</p>
<pre><code class="prism language-cpp"><span class="token comment">// Linux上看是否安装了g++</span>
which g<span class="token operator">++</span>

<span class="token comment">// 如果没有 先装一下</span>
yum install gcc<span class="token operator">-</span>c<span class="token operator">++</span>
</code></pre>
<p>C++或者C程序的执行过程分为4步， 依次是预处理，编译，汇编和链接。</p>
<blockquote>
<p>C++多文件编程中有头文件(.h后缀)和源文件(.cpp后缀)， 需要注意， <strong>执行C++项目时， 头文件是不需要经历以上4个阶段的， 只有项目中所有源文件才必须经历</strong></p>
</blockquote>
<p>我们通过下面一个例子， 详细看下C++程序的执行过程。</p>
<p>首先， 建立一个c++项目目录， 我这里就直接建立"LearningC"目录， 然后在这里面新建三个文件<code>student.h, stduent.cpp, main.cpp</code>， 代码如下:</p>
<pre><code class="prism language-cpp"><span class="token comment">//student.h</span>
<span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span>
    <span class="token keyword">int</span> age<span class="token punctuation">;</span>
    <span class="token keyword">float</span> score<span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">//student.cpp</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span>   <span class="token comment">//std::cout、std::endl</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"student.h"</span>  <span class="token comment">//Student</span></span>
<span class="token keyword">void</span> <span class="token class-name">Student</span><span class="token operator">::</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> name <span class="token operator">&lt;&lt;</span> <span class="token string">"的年龄是"</span> <span class="token operator">&lt;&lt;</span> age <span class="token operator">&lt;&lt;</span> <span class="token string">"，成绩是"</span> <span class="token operator">&lt;&lt;</span> score <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//main.cpp</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"student.h"</span>  <span class="token comment">//Student</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    Student <span class="token operator">*</span>pStu <span class="token operator">=</span> <span class="token keyword">new</span> Student<span class="token punctuation">;</span>
    pStu<span class="token operator">-&gt;</span>name <span class="token operator">=</span> <span class="token string">"wuzhongqiang"</span><span class="token punctuation">;</span>
    pStu<span class="token operator">-&gt;</span>age <span class="token operator">=</span> <span class="token number">25</span><span class="token punctuation">;</span>
    pStu<span class="token operator">-&gt;</span>score <span class="token operator">=</span> <span class="token number">66.6f</span><span class="token punctuation">;</span>
    pStu<span class="token operator">-&gt;</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">delete</span> pStu<span class="token punctuation">;</span>  <span class="token comment">//删除对象</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>文件组织如下:<br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/468cc41448704dc7a7b52269310622cc.png#pic_center"/><br/> 下面用g++执行此项目。</p>
<ol><li> <p>预处理阶段， 生成.i文件 <code>--&gt;</code> 这一步，主要是做了宏替换， 注释删除工作等</p> <pre><code class="prism language-cpp">g<span class="token operator">++</span> <span class="token operator">-</span>E main<span class="token punctuation">.</span>cpp <span class="token operator">-</span>o main<span class="token punctuation">.</span>i
g<span class="token operator">++</span> <span class="token operator">-</span>E student<span class="token punctuation">.</span>cpp <span class="token operator">-</span>o student<span class="token punctuation">.</span>i
</code></pre> <p>这里的<code>-E</code>选项用于限定g++编译器只进行预处理，而不进行后续的3个阶段， <code>-o</code>选项用于指定生成文件的名称， 通常"<code>.i</code>"作为C++程序预处理后的文件后缀名。<br/> <br/>我们这里看一看下<code>.i</code>文件<code>cat main.i</code>。<br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/e3694c6c67bc497dae51354101c9e5c2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATWlyYWNsZTgwNzA=,size_1,color_FFFFFF,t_70,g_se,x_16#pic_center"/><br/> 比较清晰的是两点， 第一点是main.cpp的<code>#include "student.h"</code>， 这里直接用<code>studen.h</code>的内容替换了这句代码，同样<code>#include &lt;iostream&gt;</code>这句话，也让原内容替换掉。第二点是注释都干掉了。当然做了很多工作，我这只显示了最后一小部分。</p>
<blockquote>
<p><code>#include</code> 是一个来自 C 语言的宏命令，作用于程序执行的预处理阶段，其功能是将它后面所写文件中的内容，完完整整、一字不差地拷贝到当前文件中。</p>
</blockquote> </li><li> <p>经历编译阶段，即对预处理阶段得到的 -i 文件做进一步的语法分析，生成相应的汇编代码文件。</p> <pre><code class="prism language-cpp">g<span class="token operator">++</span> <span class="token operator">-</span>S main<span class="token punctuation">.</span>i <span class="token operator">-</span>o main<span class="token punctuation">.</span>s
g<span class="token operator">++</span> <span class="token operator">-</span>S student<span class="token punctuation">.</span>i <span class="token operator">-</span>o student<span class="token punctuation">.</span>s
</code></pre> <p>其中, <code>-S</code>选项用于限定g++编译器对指定文件编译，得到的汇编代码通常以".s"作为后缀名。我们这里依然是看下"<code>cat main.s</code>"。<br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/2cc3edf8bb3243c99c566da218626f77.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATWlyYWNsZTgwNzA=,size_1,color_FFFFFF,t_70,g_se,x_16#pic_center"/><br/> 这语言就不是我们能看懂的了，都是汇编语言了。</p> </li><li> <p>经历汇编阶段，即将汇编代码文件转换成可以执行的机器指令， 也就是二进制机器码 <code>-- &gt;</code> 生成目标文件，二进制机器码</p> <pre><code class="prism language-cpp">g<span class="token operator">++</span> <span class="token operator">-</span>c mian<span class="token punctuation">.</span>s <span class="token operator">-</span>o main<span class="token punctuation">.</span>o
g<span class="token operator">++</span> <span class="token operator">-</span>c student<span class="token punctuation">.</span>s <span class="token operator">-</span>o student<span class="token punctuation">.</span>o
</code></pre> <p><code>-c</code>指令限定g++编译器只进行汇编操作， 最终生成目标文件(本质是二进制文件)以"<code>.o</code>"作为后缀名。<br/> 这个依然是看一眼：<br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/7ff5226efbfe4f87bff0fcd114fb88b0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATWlyYWNsZTgwNzA=,size_2,color_FFFFFF,t_70,g_se,x_16#pic_center"/><br/> 这个更不是我们能看懂的了。</p> </li><li> <p>经历链接阶段，即将所有的目标文件组织成一个可以执行的二进制文件</p> <pre><code class="prism language-cpp">g<span class="token operator">++</span> main<span class="token punctuation">.</span>o student<span class="token punctuation">.</span>o <span class="token operator">-</span>o student<span class="token punctuation">.</span>exe
</code></pre> <p>注意，如果不用 <code>-o</code> 指定可执行文件的名称，默认情况下会生成 a.out 可执行文件。Linux 系统并不以文件的扩展名开分区文件类型，所以 a.out 和 student.exe 都是可执行文件，只是文件名称有区别罢了。<br/><br/>此时大功告成:<br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/9f9ab6afccaa4993826c5fde517cc7fa.png#pic_center"/></p> </li></ol>
<p>这个编译过程非常重要。当然，上面的这四步过程也可以直接一步到位:</p>
<pre><code class="prism language-cpp">g<span class="token operator">++</span> main<span class="token punctuation">.</span>cpp student<span class="token punctuation">.</span>cpp <span class="token operator">-</span>o student<span class="token punctuation">.</span>exe
</code></pre>
<h2><a id="7_C_419"></a>7. C++多文件编程更深层原理</h2>
<h3><a id="71__420"></a>7.1 更深一层</h3>
<p>C++多文件编程中，一个完整C++项目可以包含2类文件， 头文件(.h)和源文件(.cpp)。</p>
<p>同属一个C++项目中所有代码是分别进行编译的，只需要在编译成目标文件后再与其他目标文件做一次链接即可。</p>
<blockquote>
<p>例如，在 a.cpp 源文件中定义有一个全局函数 <code>a()</code>，而在文件 b.cpp 中需要调用这个函数。即便如此，处于编译阶段的 a.cpp 和 b.cpp 并不需要知道对方的存在，它们各自是独立编译的是，只要最后将编译得到的目标文件进行链接，整个程序就可以运行。</p>
</blockquote>
<p>那么，这个过程是怎么实现的呢？ b.cpp怎么就能找到a.cpp里面的<code>a()</code>函数了？ 怎么知道a()函数就在a.cpp中了？ 万一有多个<code>a()</code>函数咋办？ 下面一一来捋捋。</p>
<p>首先， 写程序的角度， 当文件b.cpp需要调用<code>a()</code>函数时， 只需要先声明一下该函数即可， 这是因为， 编译器在编译b.cpp的时候，会生成一个符号表， 类似<code>a()</code>这样看不到定义的符号就存到这个表中。 在链接阶段， 编译器就会在别的目标文件中寻找这个符号的定义， 一旦找到， 程序就可以顺利生成，否则，链接错误。</p>
<blockquote>
<p>这里的两个概念: 声明和定义</p>
<ul><li>定义： 某个符号完整的描述清楚， 是变量还是函数， 变量类型以及变量值是多少， 函数的参数有哪些以及返回值是什么等</li><li>声明: 仅仅告诉编译器该符号存在，至于该符号具体含义，等链接的时候才能知道</li></ul>
<p>也就是说， 定义的时候需要遵循C++语法规则完整描述一个符号， 而声明时只需要给出该符号原型即可。 一个符号允许被声明多次，但只能被定义一次，否则编译器不知道应该用哪个？</p>
</blockquote>
<p>基于声明和定义的不同，才有了 C++ 多文件编程的出现。试想如果有一个很常用的函数 <code>f()</code>，其会被程序中的很多 .cpp 文件调用，那么我们只需要在一个文件中定义此函数，然后在需要调用的这些文件中声明这个函数就可以了。</p>
<p>那么， 如果有几百函数， 声明该怎么办呢？ 一种简单的方法是将它们的声明全部放入一个文件中， 当需要时直接从文件中拷贝。 这种方法可行，但太麻烦， 于是乎头文件便可以发挥作用。</p>
<blockquote>
<p>所谓头文件， 其实它内容和.cpp文件内容是一样的，都是C++源代码， 唯一区别是在于头文件不用被编译。 我们把所有的函数声明全部放进一个头文件， 当某个.cpp源文件需要，就#include只接将头文件内容引入到.cpp中。 这样， 当.cpp在预处理的时候， #include引入的<code>.h</code>文件就会替换该文件中的所有声明。</p>
</blockquote>
<p>所以上面的三个问题， 其实就清楚了。 b.cpp首先会通过<code>#include</code>操作， 把<code>a()</code>函数声明内容复制过去，这样， 编译b.cpp的时候就知道有这么个符号了。 然后a.cpp和b.cpp都进行编译， 生成.o文件之后 进行链接， b.o就去a.o中找<code>a()</code>函数的定义。 而有多个<code>a()</code>函数的时候， 会进行命名空间的限制。</p>
<h3><a id="72_C_442"></a>7.2 C++头文件内应该写啥</h3>
<p><code>.h</code>头文件作用是被其他<code>.cpp</code>包含进去，其本身并不参与编译， 但它的内容会在多个<code>.cpp</code>中得到编译。</p>
<p>根据"符号的定义只有一次"的规则，就很容易理解，** 头文件中只能放变量和函数的声明而不能放他们定义**， 因为一个头文件内容实际上是会被其他多个不同.<code>cpp</code>文件引入且编译。 如果把函数和变量定义放在里面，这时候会发生重定义错误。</p>
<p>比如：</p>
<pre><code class="prism language-cpp"><span class="token comment">// 声明 ok</span>
<span class="token keyword">extern</span> <span class="token keyword">int</span> a<span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 定义 不OK</span>
<span class="token keyword">int</span> a<span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
</code></pre>
<p>但， 有三种情况是例外， 他们虽然属于定义的范畴，但应该放在<code>.h</code>文件中。</p>
<ol><li>头文件中可以定义const对象<br/> 全局的 const 对象默认是没有 extern 声明的，所以它只在当前文件中有效。把这样的对象写进头文件中，即使它被包含到其他多个 <code>.cpp</code> 文件中，这个对象也都只在包含它的那个文件中有效，对其他文件来说是不可见的，所以便不会导致多重定义。<br/><br/>与此同时，由于这些 .cpp 文件中的 const 对象都是从一个头文件中包含进去的，也就保证了这些 .cpp 文件中的 const 对象的值是相同的，可谓一举两得。<br/> 同理， static对象的定义也可以放进头文件</li><li>头文件中可以定义内联函数<br/> 内联函数(<code>inline</code> 修饰)是需要编译器在编译阶段根据其定义将它内联展开的(类似宏展开)，而并非像普通函数那样先声明再链接。这就意味着，编译器必须在编译时就找到内联函数的完整定义。</li><li>头文件中可以定义类<br/> 在程序中创建一个类的对象时， 编译器只有在这个类的定义完全可见情况下，才能知道这个类对象应该如何布局。所以关于类的定义要求，和内联函数是一样的，即把类定义放进头文件， 然后再使用这个类的<code>.cpp</code>文件中<code>#include</code>。<br/><br/>类的内部通常包含成员变量和成员函数， 成员变量要等到具体对象被创建时才会被定义(分配空间)， 但成员函数需要一开始就被定义。 通常做法是类定义放到头文件， 成员函数实现放在<code>.cpp</code>中。 当然，还有一种方法是在类定义的时候，直接把成员函数实现写好，此时编译器会将其看为内联函数。但尽量不这么做。</li></ol>
<h3><a id="73__467"></a>7.3 再看头文件重复引入错误</h3>
<p>C++多文件编程中, <code>.h</code>头文件中只包含声明语句的话， 即便被同一个<code>.cpp</code>文件引入多次也没有问题， 因为声明语句是可以重复的， 但上面有3种特例， 是可以把定义写入头文件， 并且这3种特例都是很常见的操作。</p>
<p>那么这个时候， 如果包含上面3种特例里面某一种的头文件，被多个<code>.cpp</code>文件引入， 就会出现重定义错误了。 C++提供了3种处理机制， 最常用的就是<code>#ifndef/#define/#endif</code>。</p>
<p>详细的看上面吧，到这里，就串起来了，也更加清晰啦。</p>
<h2><a id="8_gCMakeMakeFile_473"></a>8. g++，CMake和MakeFile小补</h2>
<p>这里补充点知识，就是MakeFile和CMake，这两个是这两天学习CV项目时偶然接触到的，所以就产生了好奇， 想看看这俩东西是啥，既然有了g++了， 为啥还要有这俩东西？</p>
<h3><a id="81_MakeFile_475"></a>8.1 MakeFile</h3>
<p>上面已经梳理清楚了一个完成C++项目的执行过程， 主要是分为四步: 预处理、编译、汇编、链接。g++命令确实可以对一个C++项目通过上面四步转成可执行文件，但在中大型项目里面，这样玩还是太复杂。 于是乎就有了MakeFile。</p>
<blockquote>
<p>Makefile 文件描述了 Linux 系统下 C/C++ 工程的编译规则，它用来自动化编译 C/C++ 项目。一旦写编写好 Makefile 文件，只需要一个 make 命令，整个工程就开始自动编译，不再需要手动执行 GCC 命令。</p>
</blockquote>
<p>一个中大型 C/C++ 工程的源文件有成百上千个，它们按照功能、模块、类型分别放在不同的目录中，Makefile 文件定义了一系列规则，指明了源文件的编译顺序、依赖关系、是否需要重新编译等。</p>
<blockquote>
<p>MakeFile文件是g++代码的整理， 有了MakeFile文件， 执行程序会更加快速方便， 而CMake是简化MakeFile编写，可以自动生成MakeFile文件</p>
</blockquote>
<p>当然，这里不会整理非常详细，因为我现在也只学到了点皮毛，只是通过一个例子看看这玩意咋用，现在学习首先是从应用角度开始， 关于原理和理论可以先参考<a href="http://c.biancheng.net/makefile/">上面的C语言中文网相关内容</a>，后面如果学习到更多，会继续补充。</p>
<p>首先， MakeFile文件的基本格式长下面这样:</p>
<pre><code class="prism language-cpp">target <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">:</span> prerequisites <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
   command
   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre>
<p>这里参数说明：</p>
<ul><li>target: 目标文件， 可以是object file，也可以是可执行文件</li><li>prerequisites - 生成target所需要的文件或目标</li><li>command - make需要执行的命令(任意shell命令), Makefile命令必须tab开头</li></ul>
<p>不用把这玩意想成多么高大上， 这其实就是个文件，更直接的说， 这玩意里面其实就是我们上面生成student.exe文件的全部指令，只不过只要有了这个文件， 我们就可以直接用make命令，直接生成可执行文件。 那你说， 那不还得把上面指令敲到MakeFile文件吗？ 其实有了CMake， 就不需要了。</p>
<p>Makefile五个重要的东西： 显示规则， 隐晦规则，变量定义， 文件指示和注释</p>
<ol><li> <p>显示规则：<br/> 通常在写makefile时使用的都是显式规则，这需要指明target和prerequisite文件。<br/> 一条规则可以包含多个target，这意味着其中每个target的prerequisite都是相同的。<br/> 当其中的一个target被修改后，整个规则中的其他target文件都会被重新编译或执行。</p> </li><li> <p>隐晦规则：<br/> make的自动推导功能所执行的规则</p> </li><li> <p>变量的定义：<br/> Makefile中定义的变量，一般是字符串</p> </li><li> <p>文件指示：<br/> Makefile中引用其他Makefile；指定Makefile中有效部分；定义一个多行命令</p> </li><li> <p>注释：<br/> Makefile只有行注释 “#”, 如果要使用或者输出"#"字符, 需要进行转义, "#</p> </li></ol>
<p>下面就拿上面那个student.cpp和main.cpp编译的例子来编写MakeFile文件。 LearningC目录下把其他的文件删除，只保留两个<code>.cpp</code>文件和一个<code>.h</code>文件。<br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/d403fd48d9ba43d9b1ff836aa73e06cc.png#pic_center"/><br/> 编写MakeFile文件， 同样是建立一个文件， 然后在里面开写。</p>
<ol><li> <p>编写clean， 作用是删除所有的.o文件和可执行文件， 以防带来杂乱干扰</p> <pre><code class="prism language-cpp">clean<span class="token operator">:</span>
	rm <span class="token operator">*</span>o student
</code></pre> <p>这里要是tab</p> </li><li> <p>编写目标文件1: 依赖文件1<br/> 目标文件就是想得到的文件， 依赖文件就是目前所拥有的东西。 目前只有student.cpp和main.cpp文件， 而目标文件就是得到对应的.o文件</p> <pre><code class="prism language-cpp">student<span class="token punctuation">.</span>o<span class="token operator">:</span>student<span class="token punctuation">.</span>cpp
	g<span class="token operator">++</span> <span class="token operator">-</span>c student<span class="token punctuation">.</span>cpp <span class="token operator">-</span>o student<span class="token punctuation">.</span>o
main<span class="token punctuation">.</span>o<span class="token operator">:</span>main<span class="token punctuation">.</span>cpp
	g<span class="token operator">++</span> <span class="token operator">-</span>c main<span class="token punctuation">.</span>cpp <span class="token operator">-</span>o main<span class="token punctuation">.</span>o
</code></pre> <p>和上面格式要对应上</p> </li><li> <p>编写目标文件2: 依赖文件2<br/> 这里和上面同理， 我们现在有了student.o和main.o文件了，接下来我们就是基于这两个，得到我们的可执行文件</p> <pre><code class="prism language-cpp">student<span class="token operator">:</span>student<span class="token punctuation">.</span>o main<span class="token punctuation">.</span>o
	g<span class="token operator">++</span> main<span class="token punctuation">.</span>o student<span class="token punctuation">.</span>o <span class="token operator">-</span>o student
</code></pre> </li></ol>
<p>这样就编写完了， 我们组织文件的时候， 是从下往上组织上面代码。<br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/125edd16428743eb88d073a34af1b5a7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATWlyYWNsZTgwNzA=,size_11,color_FFFFFF,t_70,g_se,x_16#pic_center"/><br/> 这样就编写好了makefil文件，然后我们只需要用make命令编译这个文件即可。<br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/a96ec139bb5045a69036a36e2cfd222e.png#pic_center"/><br/> 这样就会自动执行编译程序了， 每次我们想编译，只需要make这个文件， 而不需要之前手动一系列g++命令了。修改起来也非常方便。</p>
<p>当然，上面这个代码是一个最简单的版本了，下面我们尝试修改一下，让其稍微复杂一点， 主要是为了编译更高效。参考<a href="https://zhuanlan.zhihu.com/p/92010728">这篇文章</a><br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/9164d983ae954530b2f39c4863399216.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATWlyYWNsZTgwNzA=,size_1,color_FFFFFF,t_70,g_se,x_16#pic_center"/><br/> 当然， 真实大项目要比这个复杂的多，编写这个文件就类似于shell脚本那样，还有很多其他高级用法，比如定义变量， 条件判断等， 这些目前没用到， 详细的可以看上面给的那个链接。</p>
<h3><a id="82_Cmake_555"></a>8.2 Cmake</h3>
<p>说完了makefile文件，接下来， 整理下Cmake了</p>
<blockquote>
<p>CMake是一个跨平台的编译(Build)工具，可以用简单的语句来描述所有平台的编译过程，其是在make基础上发展而来的，早期的make需要程序员写Makefile文件，进行编译，而现在CMake能够通过对cmakelists.txt的编辑，轻松实现对复杂工程的组织</p>
</blockquote>
<p>首先， 需要先安装cmake</p>
<pre><code class="prism language-cpp">sudo apt<span class="token operator">-</span>get install cmake
cmake <span class="token operator">--</span>version
</code></pre>
<p>编译流程如下：</p>
<pre><code class="prism language-cpp"><span class="token number">1.</span> 编写Cmake配置文件CMakeLists<span class="token punctuation">.</span>txt<span class="token punctuation">,</span> 理解成Cmake所要处理的代码
<span class="token number">2.</span> 执行命令 cmake path生成MakeFile<span class="token punctuation">,</span> path是CmakeList<span class="token punctuation">.</span>txt所在目录
<span class="token number">3.</span> 使用make命令进行编译
</code></pre>
<p>这么说太抽象，还是拿上面例子实操下。</p>
<p>把之前编写的makefile以及生成的可执行文件删除掉， 然后建立一个build目录，以及建立CMakeLists.txt文件， 文件组织如下:<br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/5b15b19952d148e38b6a6473e78ae8c8.png#pic_center"/><br/> 注意这个组织方式，因为不同组织方式可能指定路径会不同。</p>
<p>接下来，我们编写CMakeLists.txt文件， vim下</p>
<pre><code class="prism language-cpp"><span class="token function">cmake_minimum_required</span><span class="token punctuation">(</span>VERSION <span class="token number">3.10</span><span class="token punctuation">)</span>

<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">set</span> <span class="token expression">the project name</span></span>
<span class="token function">project</span><span class="token punctuation">(</span>student<span class="token punctuation">)</span>

<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">add</span> <span class="token expression">the executable</span></span>
<span class="token function">add_executable</span><span class="token punctuation">(</span>student student<span class="token punctuation">.</span>cpp main<span class="token punctuation">.</span>cpp<span class="token punctuation">)</span>
</code></pre>
<p>这个是不是比上面编写MakeFile文件简单多了，并且这里面的大部分命令都是固定语法，相当于我们只需要指定一些参数即可。 首先， 先整理上面几个命令:</p>
<table><thead><tr><th>命令</th><th>命令语法</th><th>命令简述</th><th>使用范例</th></tr></thead><tbody><tr><td>cmake_minimum_required</td><td>cmake_minimum_required(VERSION major[.minor[.patch[.tweak]]][FATAL_ERROR])</td><td>用于指定需要的CMake 的最低版本</td><td>cmake_minimum_required(VERSION 3.10)</td></tr><tr><td>project</td><td>project( [languageName1 languageName2 … ] )</td><td>用于指定项目的名称，一般和项目的文件名称对应</td><td>project(student)</td></tr><tr><td>add_executable</td><td>add_executable( [WIN32] [MACOSX_BUNDLE][EXCLUDE_FROM_ALL] source1 source2 … sourceN)</td><td>用于指定从一组源文件 source1 source2 … sourceN 编译出一个可执行文件且命名为name</td><td>add_executable(student student.cpp main.cpp)</td></tr><tr><td>include_directories</td><td>include_directories([AFTER|BEFORE] [SYSTEM] dir1 dir2 …)</td><td>用于设定目录，这些设定的目录将被编译器用来查找 include 文件</td><td>include_directories(${PROJECT_SOURCE_DIR}/lib)</td></tr></tbody></table>
<p>这种命令太多了，需要平时多加积累， 由于我这里就用到了这几个， 所以先整理这几个，如果有其他命令需要用到，可以去官网查具体使用<a href="https://cmake.org/cmake/help/v2.8.8/cmake.html#section_Commands">https://cmake.org/cmake/help/v2.8.8/cmake.html#section_Commands</a></p>
<p>把上面CMakeLists.txt写好之后， 我们去build目录， 在这里面输入<code>cmake ../.</code></p>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/35de00644ec74e36bd8f91ee09f85f75.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATWlyYWNsZTgwNzA=,size_2,color_FFFFFF,t_70,g_se,x_16#pic_center"/><br/> 这里的<code>../.</code>表示CMakeLists.txt所在目录，cmake找的就是这个文件。 这样执行完了之后， build目录下面自动出来一个Makefile文件。 我们直接在本目录下make<br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/1089178d12e94bae9c8b46005c81efae.png#pic_center"/><br/> 这样， 就搞定啦。所以， Cmake编译大项目的时候还是非常方便的。</p>
<h2><a id="9__606"></a>9. 小总</h2>
<p>首先，还是先来一张导图把这一篇文章内容拎起来:<br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/2741a1dc01ce4868ab59dcf210f5c20d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATWlyYWNsZTgwNzA=,size_2,color_FFFFFF,t_70,g_se,x_16#pic_center"/><br/> 到这里， C++重温基础就过完了一遍， 这次学习基本上是参考C语言中文网的<a href="http://c.biancheng.net/cplus/">C++基础教程</a>走的，然后在学习过程中，遇到疑问或者不懂的， 再通过查阅其他资料进行补充， 其他资料主要参考是《C++ Primer Plus》书籍，无可非议， 比较权威。</p>
<p>这里不是打广告，跟了一遍C++教程，确实觉得站长内容写的非常详细且内容之间非常连贯，非常适合构建知识体系， 所以也非常感谢站长的教程， 当然我整理的这几篇博客算是笔记，更是对我之前C++知识的查缺补漏， 如果想学习更多细节， 还是建议去读站长的原教程。</p>
<p>C++语言一直给我的感觉就是非常有魅力，当然这种魅力我也说不出在哪，就是比较喜欢。当然， 离熟悉还差很远，离精通更是遥不可及，不过这一遍学习，我算是把知识框架搭建了起来， 我觉得这个东西对我学习来说非常重要， 不管学习什么知识，我觉得只要我有框架， 我就能持续学习，不断扩充， 这是一个非常有意思的事情。 所以，这十二篇博客，后面会根据所学持续扩充， 我也知道， 每一篇都非常长，但每次遇到问题，回来查阅的时候，我会发现非常的舒服，几乎相关内容都连在一块，查起来非常高效。也希望能帮助到更多的伙伴啦。</p>
<p>趁着在学校的这半年时间， 我博客会补充各种基础知识，形成框架体系，因为我觉得这个时候是建立知识框架最好的时间，通过实习，我发现一旦工作，我会变得非常浮躁， 那时候不适合静心学习，搭建框架， 只适合根据实际应用把新知识进行补充，来使得框架变丰满，只可惜，我是最后半年才悟到的，得抓紧了哈哈。</p>
<ul><li>语言方面： python和C++继续重温，依然是参考站长编写的教程， C++目前基础过完，后面会补几篇C语言之前不知道的关键知识，然后就是C++11新特性，然后就是STL库了，这个才是实际中常用的东西，感觉得系统走一遍</li><li>python数据分析的库后面得走一遍， 为后面工作打基础</li><li>Linux以及几个数据库教程走一遍，同样为后面工作打基础</li></ul>
<p>学校的时间是打基础最好的时间，所以继续Rush 😉</p>
</div>
<link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css" rel="stylesheet"/>
<link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css" rel="stylesheet"/>
</div>