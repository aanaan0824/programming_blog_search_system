<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<p id="main-toc"><strong>目录</strong></p>
<p id="1%E3%80%81C%20%2F%20C%2B%2B%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83-toc" style="margin-left:80px;"><a href="#1%E3%80%81C%20%2F%20C%2B%2B%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83">1、C / C++内存分布</a></p>
<p id="2%E3%80%81C%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F-toc" style="margin-left:80px;"><a href="#2%E3%80%81C%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F">2、C语言中动态内存管理方式</a></p>
<p id="malloc%20%2F%20calloc%20%2F%20realloc%20%2F%20free-toc" style="margin-left:80px;"><a href="#malloc%20%2F%20calloc%20%2F%20realloc%20%2F%20free">        </a><a href="#malloc%20%2F%20calloc%20%2F%20realloc%20%2F%20free">malloc / calloc / realloc / free</a></p>
<p id="3%E3%80%81C%2B%2B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F-toc" style="margin-left:80px;"><a href="#3%E3%80%81C%2B%2B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F">3、C++内存管理方式</a></p>
<p id="new%20%2F%20delete%20%E6%93%8D%E4%BD%9C%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B-toc" style="margin-left:80px;"><a href="#new%20%2F%20delete%20%E6%93%8D%E4%BD%9C%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B">        </a><a href="#new%20%2F%20delete%20%E6%93%8D%E4%BD%9C%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B">new / delete 操作内置类型</a></p>
<p id="new%20%2F%20delete%20%E6%93%8D%E4%BD%9C%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B-toc" style="margin-left:80px;"><a href="#new%20%2F%20delete%20%E6%93%8D%E4%BD%9C%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B">        </a><a href="#new%20%2F%20delete%20%E6%93%8D%E4%BD%9C%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B">new / delete 操作自定义类型</a></p>
<p id="4%E3%80%81operator%20new%E4%B8%8Eoperator%20delete%E5%87%BD%E6%95%B0%EF%BC%88%E9%87%8D%E8%A6%81%E7%82%B9%E8%BF%9B%E8%A1%8C%E8%AE%B2%E8%A7%A3%EF%BC%89-toc" style="margin-left:80px;"><a href="#4%E3%80%81operator%20new%E4%B8%8Eoperator%20delete%E5%87%BD%E6%95%B0%EF%BC%88%E9%87%8D%E8%A6%81%E7%82%B9%E8%BF%9B%E8%A1%8C%E8%AE%B2%E8%A7%A3%EF%BC%89">4、operator new与operator delete函数（重要点进行讲解）</a></p>
<p id="operator%20new%E4%B8%8Eoperator%20delete%E5%87%BD%E6%95%B0%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89-toc" style="margin-left:80px;"><a href="#operator%20new%E4%B8%8Eoperator%20delete%E5%87%BD%E6%95%B0%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89">        </a><a href="#operator%20new%E4%B8%8Eoperator%20delete%E5%87%BD%E6%95%B0%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89">operator new与operator delete函数（重点）</a></p>
<p id="operator%20new%E4%B8%8Eoperator%20delete%E7%9A%84%E7%B1%BB%E4%B8%93%E5%B1%9E%E9%87%8D%E8%BD%BD%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89-toc" style="margin-left:80px;"><a href="#operator%20new%E4%B8%8Eoperator%20delete%E7%9A%84%E7%B1%BB%E4%B8%93%E5%B1%9E%E9%87%8D%E8%BD%BD%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89">        </a><a href="#operator%20new%E4%B8%8Eoperator%20delete%E7%9A%84%E7%B1%BB%E4%B8%93%E5%B1%9E%E9%87%8D%E8%BD%BD%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89">operator new与operator delete的类专属重载（了解）</a></p>
<p id="5%E3%80%81new%E5%92%8Cdelete%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-toc" style="margin-left:80px;"><a href="#5%E3%80%81new%E5%92%8Cdelete%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">5、new和delete的实现原理</a></p>
<p id="%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B-toc" style="margin-left:80px;"><a href="#%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B">        </a><a href="#%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B">内置类型</a></p>
<p id="%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B-toc" style="margin-left:80px;"><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B">        </a><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B">自定义类型</a></p>
<p id="6%E3%80%81%E5%AE%9A%E4%BD%8Dnew%E8%A1%A8%E8%BE%BE%E5%BC%8F(placement-new)%20%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89-toc" style="margin-left:80px;"><a href="#6%E3%80%81%E5%AE%9A%E4%BD%8Dnew%E8%A1%A8%E8%BE%BE%E5%BC%8F%28placement-new%29%20%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89">6、定位new表达式(placement-new) （了解）</a></p>
<p id="7%E3%80%81%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98-toc" style="margin-left:80px;"><a href="#7%E3%80%81%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98">7、常见面试题</a></p>
<p id="7.1%E3%80%81malloc%2Ffree%E5%92%8Cnew%2Fdelete%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:80px;"><a href="#7.1%E3%80%81malloc%2Ffree%E5%92%8Cnew%2Fdelete%E7%9A%84%E5%8C%BA%E5%88%AB">        </a><a href="#7.1%E3%80%81malloc%2Ffree%E5%92%8Cnew%2Fdelete%E7%9A%84%E5%8C%BA%E5%88%AB">7.1、malloc/free和new/delete的区别</a></p>
<p id="7.2%E3%80%81%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F-toc" style="margin-left:80px;"><a href="#7.2%E3%80%81%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F">        </a><a href="#7.2%E3%80%81%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F">7.2、内存泄漏</a></p>
<p id="%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%8C%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%8D%B1%E5%AE%B3-toc" style="margin-left:80px;"><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%8C%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%8D%B1%E5%AE%B3">        </a>        <a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%8C%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%8D%B1%E5%AE%B3">什么是内存泄漏，内存泄漏的危害</a></p>
<p id="%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%88%86%E7%B1%BB%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89-toc" style="margin-left:80px;"><a href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%88%86%E7%B1%BB%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89">        </a>        <a href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%88%86%E7%B1%BB%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89">内存泄漏分类（了解）</a></p>
<p id="%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89-toc" style="margin-left:80px;"><a href="#%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89">        </a>        <a href="#%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89">如何检测内存泄漏（了解）</a></p>
<p id="%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F-toc" style="margin-left:80px;"><a href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F">        </a>        <a href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F">如何避免内存泄漏</a></p>
<p id="7.3%E3%80%81%E5%A6%82%E4%BD%95%E4%B8%80%E6%AC%A1%E5%9C%A8%E5%A0%86%E4%B8%8A%E7%94%B3%E8%AF%B74G%E7%9A%84%E5%86%85%E5%AD%98%EF%BC%9F-toc" style="margin-left:80px;"><a href="#7.3%E3%80%81%E5%A6%82%E4%BD%95%E4%B8%80%E6%AC%A1%E5%9C%A8%E5%A0%86%E4%B8%8A%E7%94%B3%E8%AF%B74G%E7%9A%84%E5%86%85%E5%AD%98%EF%BC%9F">        </a><a href="#7.3%E3%80%81%E5%A6%82%E4%BD%95%E4%B8%80%E6%AC%A1%E5%9C%A8%E5%A0%86%E4%B8%8A%E7%94%B3%E8%AF%B74G%E7%9A%84%E5%86%85%E5%AD%98%EF%BC%9F">7.3、如何一次在堆上申请4G的内存？</a></p>
<hr/>
<h3>1、C / C++内存分布</h3>
<blockquote>
<p>我们先来看下面的一段代码和相关问题</p>
<pre><code class="language-cpp">int globalVar = 1;
static int staticGlobalVar = 1;
void Test()
{
	static int staticVar = 1;
	int localVar = 1;
	int num1[10] = { 1, 2, 3, 4 };
	char char2[] = "abcd";
	const char* pChar3 = "abcd";
	int* ptr1 = (int*)malloc(sizeof(int) * 4);
	int* ptr2 = (int*)calloc(4, sizeof(int));
	int* ptr3 = (int*)realloc(ptr2, sizeof(int) * 4);
	free(ptr1);
	free(ptr3);
}</code></pre>
<p>来看看如下的几个问题：</p>
<pre><code class="language-cpp">1. 选择题：
选项: A.栈 B.堆 C.数据段 D.代码段
globalVar在哪里？__C__ staticGlobalVar在哪里？__C__
staticVar在哪里？__C__ localVar在哪里？__A__
num1 在哪里？__A__
char2在哪里？__A__ *char2在哪里？__A__
pChar3在哪里？__A__ *pChar3在哪里？__D__
ptr1在哪里？__A__ *ptr1在哪里？__B__

2. 填空题：
sizeof(num1) = __40__;
sizeof(char2) = __5__; strlen(char2) = __4__;
sizeof(pChar3) = __4/8__; strlen(pChar3) = __4__;
sizeof(ptr1) = __4/8__;</code></pre>
<p>其实这部分内容在C语言的时候我已经讲解过，这里给出博客链接<a class="link-info" href="https://blog.csdn.net/bit_zyx/article/details/122749352?spm=1001.2014.3001.5502" title="C/C++内存分配">C/C++内存分配</a></p>
<p>这里给出一幅图：<img alt="" src="image\c330999e29de48b99f9ff74e46298e06.png"/></p>
<p> C/C++程序内存分配的几个区域：</p>
<ul><li><strong>栈区（stack）</strong>：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。 栈区主要存放运行函数而分配的局部变量、函数参数、返回数据、返回地址等。</li><li><strong>堆区（heap）</strong>：一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。分配方式类似于链表。</li><li><strong>数据段（静态区）</strong>（static）存放全局变量、静态数据。程序结束后由系统释放。</li><li><strong>代码段</strong>：存放函数体（类成员函数和全局函数）的二进制代码。</li></ul>
<p>想看更多这方面练习的小伙伴可以点击这个链接：<a class="link-info" href="https://blog.csdn.net/bit_zyx/article/details/122570258" title="sizeof 、strlen 内存分配练习">sizeof 、strlen 内存分配练习</a></p>
</blockquote>
<hr/>
<h3 id="2%E3%80%81C%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F">2、C语言中动态内存管理方式</h3>
<blockquote>
<h3 id="malloc%20%2F%20calloc%20%2F%20realloc%20%2F%20free">malloc / calloc / realloc / free</h3>
<p>这部分内容我在C语言的博客中有详细全面的讲解，可以点击这块链接查看：<a class="link-info" href="https://blog.csdn.net/bit_zyx/article/details/122737321" title="C语言动态内存管理">C语言动态内存管理</a></p>
<p>这边给出代码演示：</p>
<pre><code class="language-cpp">void Test()
{
	int* p1 = (int*)malloc(sizeof(int));
	free(p1);
	int* p2 = (int*)calloc(4, sizeof(int));
	free(p2);
	int* p3 = (int*)realloc(p2, sizeof(int) * 10);
	free(p3);
}</code></pre>
<ul><li><strong><span style="background-color:#fefcd8;">malloc：</span></strong></li></ul>
<p>在内存的动态存储区中分配一块长度为size字节的连续区域，参数size为需要内存空间的长度，返回该区域的首地址</p>
<ul><li><strong><span style="background-color:#fefcd8;">calloc：</span></strong></li></ul>
<p>与malloc相似，不过函数calloc() 会将所分配的内存空间中的每一位都初始化为零</p>
<ul><li><strong><span style="background-color:#fefcd8;">realloc：</span></strong></li></ul>
<p> 给一个已经分配了地址的指针重新分配空间，可以做到对动态开辟内存大小的调整。</p>
<ul><li><span style="background-color:#edf6e8;">【面试题】：</span><strong>malloc/calloc/realloc的区别？</strong></li></ul>
<p></p>
<ol><li><span style="color:#fe2c24;">函数malloc不能初始化所分配的内存空间,而函数calloc能</span>.如果由malloc()函数分配的内存空间原来没有被使用过，则其中的每一位可能都是0;反之, 如果这部分内存曾经被分配过,则其中可能遗留有各种各样的数据.也就是说，使用malloc()函数的程序开始时(内存空间还没有被重新分配)能正常进行,但经过一段时间(内存空间还已经被重新分配)可能会出现问题.</li><li><span style="color:#fe2c24;">函数calloc() 会将所分配的内存空间中的每一位都初始化为零</span>,也就是说,如果你是为字符类型或整数类型的元素分配内存,那么这些元素将保证会被初始化为0;如果你是为指针类型的元素分配内存,那么这些元素通常会被初始化为空指针;</li><li>函数malloc向系统申请分配指定size个字节的内存空间.<span style="color:#fe2c24;">返回类型是 void<em>类型.void</em>表示未确定类型的指针</span>.C,C++规定，void* 类型可以强制转换为任何其它类型的指针.</li><li><span style="color:#fe2c24;">realloc可以对给定的指针所指的空间进行扩大或者缩小，无论是扩张或是缩小，原有内存的中内容将保持不变.</span>当然，对于缩小，则被缩小的那一部分的内容会丢失.realloc并不保证调整后的内存空间和原来的内存空间保持同一内存地址.相反，realloc返回的指针很可能指向一个新的地址.</li><li><span style="color:#fe2c24;">realloc是从堆上分配内存的</span>.当扩大一块内存空间时，realloc()试图直接从堆上现存的数据后面的那些字节中获得附加的字节，如果能够满足，此时即<span style="color:#956fe7;">原地扩</span>；如果数据后面的字节不够，那么就使用堆上第一个有足够大小的自由块，现存的数据然后就被拷贝至新的位置，而老块则放回到堆上.这句话传递的一个重要的信息就是数据可能被移动，即<span style="color:#956fe7;">异地扩</span></li></ol>
</blockquote>
<hr/>
<h3 id="3%E3%80%81C%2B%2B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F">3、C++内存管理方式</h3>
<blockquote>
<p>C语言内存管理方式在C++中可以继续使用，但有些地方就无能为力而且使用起来比较麻烦，因此C++又提出了自己的内存管理方式：通过<span style="color:#fe2c24;"><strong>new</strong></span>和<span style="color:#fe2c24;"><strong>delete</strong></span>操作符进行动态内存管理</p>
</blockquote>
<blockquote>
<h3 id="new%20%2F%20delete%20%E6%93%8D%E4%BD%9C%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B">new / delete 操作内置类型</h3>
<pre><code class="language-cpp">void Test()
{
	// new一个int类型的空间
	int* ptr4 = new int;
	// new一个int类型的空间并初始化为10
	int* ptr5 = new int(10);
	// new10个int类型的空间
	int* ptr6 = new int[10];
	// new10个int类型的空间并初始化
	int* ptr7 = new int[10]{ 10,9,8,7,6,5 }; //跟数组的初始化很像，大括号有几个，初始化几个，其余为0。不过C++11才支持的语法
	delete ptr4;
	delete ptr5;
	delete[] ptr6;
	delete[] ptr7;
}
</code></pre>
<p><img alt="" height="662" src="image\b7ba7d706c654d0fb99fc1dfb8a085c7.png" width="824"/></p>
<p><img alt="" height="377" src="image\d596cee0042545de9c46318f1b3537e6.png" width="611"/></p>
<p><strong>注意：</strong>申请和释放单个元素的空间，使用new和delete操作符，申请和释放连续的空间，使用new[ ]和delete[ ]</p>
<p><strong>总结：</strong>对于内置类型而言，用malloc和new，除了用法不同，没有什么区别。它们的区别在于自定义类型</p>
</blockquote>
<h3 id="new%20%2F%20delete%20%E6%93%8D%E4%BD%9C%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B">new / delete 操作自定义类型</h3>
<blockquote>
<p>先给出结论：</p>
<ul><li><strong>申请空间时：</strong>malloc只开空间，new既开空间又调用<span style="color:#956fe7;">构造函数</span>初始化。</li><li><strong>释放空间时：</strong>delete会调用<span style="color:#956fe7;">析构函数</span>，free不会</li></ul>
<p>先看下malloc和free：</p>
<p><img alt="" height="686" src="image\c03d0c1543d6442ea0c630e4bd8944e1.png" width="1200"/></p>
<p>很明显，malloc的对象只是开辟了空间，并没有初始化，free后也只是普通的释放。</p>
<p>再看下new和delete：</p>
<p><img alt="" height="691" src="image\888eceda107e4318beb50671ac3f8588.png" width="1200"/></p>
<p>当我们运行程序时，结果如下：</p>
<p><img alt="" height="591" src="image\d00cd7d03c794960a52ffe50e88d7aa8.png" width="1064"/></p>
<p>很明显，使用new，既可以开辟空间，又调用了构造函数从而完成初始化，而delete时调用了析构函数，以此释放空间。</p>
<p>在我们先前学习的链表中，C语言为了创建一个节点并将其初始化，需要单独封装一个函数进行初始化，我C++只需要用new即可开空间+初始化：</p>
<pre><code class="language-cpp">struct ListNode
{
	struct ListNode* _next;
	int _val;
    //构造函数
	ListNode(int val = 0) 
		:_next(nullptr)
		,_val(val)
	{}
};
int main()
{
	ListNode* n2 = new ListNode(10); //C++的new相当于我之前的BuyListNode函数
	return 0;
}</code></pre>
<p>如若只是单纯的区分malloc和new，那么malloc纯粹只开空间不初始化，而new既开空间又初始化。</p>
<p><img alt="" height="419" src="image\af9e4985e7a34acb9b187ea51e743733.png" width="1200"/></p>
<p><strong>总结：</strong>在申请自定义类型的空间时，new会调用<span style="color:#956fe7;">构造函数</span>，delete会调用<span style="color:#956fe7;">析构函数</span>，而malloc与free不会。</p>
<ul><li><strong>new和malloc还有一个区别就是在申请内存失败时的处理情况不同。</strong></li></ul>
<p>malloc如若开辟内存失败，会返回<span style="color:#fe2c24;">空指针</span>这个我们都晓得的，但是<span style="color:#956fe7;">new失败</span><span style="color:#494949;">会</span><span style="color:#fe2c24;">抛异常</span></p>
<p>仔细观察下面这段代码：</p>
<pre><code class="language-cpp">int main()
{
    //malloc失败，返回空指针
	int* p1 = (int*)malloc(sizeof(int) * 10);
	assert(p1); //malloc出来的p1需要检查合法性
    //new失败，抛异常
	int* p2 = new int;
	//new出来的p2不需要检查合法性
}</code></pre>
<p>为了演示malloc和new在开辟内存时失败的场景，这里给出一份测试：</p>
<pre><code class="language-cpp">int main()
{
	void* p3 = malloc(1024 * 1024 * 1024); //1G
	cout &lt;&lt; p3 &lt;&lt; endl;
	void* p4 = new char[1024 * 1024 * 1024];
	cout &lt;&lt; p4 &lt;&lt; endl;
}</code></pre>
<p><img alt="" height="312" src="image\5b23997931644124b31000f2e343ef47.png" width="1166"/></p>
<p>换个顺序看看：</p>
<p><img alt="" height="176" src="image\2b439145749340b1983410b774140b07.png" width="837"/></p>
<p>此段测试充分说明了我先开辟1G的大小是没有问题的，但是再开辟1个G的大小就会报错了，为了能够看出malloc和new均报错的场景，我们再定义一个指针占据这1G：</p>
<p><img alt="" height="311" src="image\7172aac9549a46028a29c13508f3a521.png" width="1144"/></p>
<p>此段测试更能够清楚的看出mallloc失败会返回空指针，而new失败会抛异常。 对于抛异常，我们理应进行捕获，不过这块内容我后续会讲到，这里先给个演示：</p>
<p><img alt="" height="422" src="image\fc6b7673e35e4ca6b7fae26f051c9d73.png" width="1056"/></p>
</blockquote>
<hr/>
<h3 id="4%E3%80%81operator%20new%E4%B8%8Eoperator%20delete%E5%87%BD%E6%95%B0%EF%BC%88%E9%87%8D%E8%A6%81%E7%82%B9%E8%BF%9B%E8%A1%8C%E8%AE%B2%E8%A7%A3%EF%BC%89">4、operator new与operator delete函数（重要点进行讲解）</h3>
<h3 id="operator%20new%E4%B8%8Eoperator%20delete%E5%87%BD%E6%95%B0%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89">operator new与operator delete函数（重点）</h3>
<blockquote>
<p><span style="color:#956fe7;">new</span>和<span style="color:#956fe7;">delete</span>是用户进行<span style="color:#956fe7;">动态内存申请和释放的操作符</span>，<span style="color:#fe2c24;">operator new</span> 和<span style="color:#fe2c24;">operator delete</span>是系统提供的<span style="color:#fe2c24;">全局函数</span>，<span style="color:#0d0016;">new在底层调用operator new全局函数来申请空间，delete在底层通过operator delete全局函数来释放空间。</span></p>
<ul><li><span style="color:#0d0016;"><strong>注意：</strong>operator new和operator delete不是对new和delete的重载，这是俩库函数。</span></li></ul>
<p>源码链接：<a class="link-info" href="https://gitee.com/bit-zy/class104/blob/master/operator%20new%20%E3%80%81operator%20delete/operator%20new%20%E3%80%81operator%20delete/operator.cpp" title="operator new、operator delete">operator new、operator delete</a></p>
<p><strong>o</strong><strong>perator new：</strong>该函数实际<span style="color:#956fe7;">通过malloc来申请空间</span>，当malloc申请空间<span style="color:#956fe7;">成功时直接返回</span>；申请空间失败，尝试执行空间不足应对措施，如果改应对措施用户设置了，则继续申请，否则<span style="color:#956fe7;">抛异常</span>。operator new本质是封装了malloc。operator delete本质是封装了free。</p>
<ul><li><strong>具体使用operator new和operator delete的操作如下：</strong></li></ul>
<pre><code class="language-cpp">int main()
{
	Stack* ps2 = (Stack*)operator new(sizeof(Stack));
	operator delete(ps2);

	Stack* ps1 = (Stack*)malloc(sizeof(Stack));
    assert(ps1);
	free(ps1);
}</code></pre>
<p>operator new和operator delete的功能和malloc、free一样。也不会去调用构造函数和析构函数，不过还是有区别的，<span style="color:#0d0016;">1、</span><span style="color:#956fe7;">operator new不需要检查开辟空间的合法性</span><span style="color:#0d0016;">。2、</span><span style="color:#956fe7;">operator new开辟空间失败就抛异常</span><span style="color:#0d0016;">。</span></p>
<ul><li><strong>operator new和operator delete的意义体现在<span style="color:#956fe7;">new和delete的底层原理</span>：</strong></li></ul>
<pre><code class="language-cpp">Stack* ps3 = new Stack;
new的底层原理：转换成调用operator new + 构造函数
delete ps3;
delete的底层原理：转换成调用operator delete + 析构函数</code></pre>
<p>new的底层原理就是转换成调用operator new + 构造函数，我们可以通过查看反汇编来验证：</p>
<p><img alt="" height="566" src="image\72e46333997640f58f164d79a4678e9f.png" width="1043"/></p>
<p>delete也是转换成调用operator delete + 析构函数，这里画图演示总结：</p>
<p><img alt="" height="232" src="image\a9a800e717f84830a71488375418b9fa.png" width="699"/></p>
</blockquote>
<h3 id="operator%20new%E4%B8%8Eoperator%20delete%E7%9A%84%E7%B1%BB%E4%B8%93%E5%B1%9E%E9%87%8D%E8%BD%BD%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89">operator new与operator delete的类专属重载（了解）</h3>
<blockquote>
<p>为了避免有些情况下我们反复的向堆申请释放空间，于是产生<span style="color:#956fe7;">池化技术（内存池）</span>，直接找内存池申请释放空间，此时效率更高更快。以后会详细讲解到池化技术，这里简要了解。而上述这俩的类专属重载就是在new调用operator new的时候就可以走内存池的机制从而提高效率。</p>
</blockquote>
<hr/>
<h3 id="5%E3%80%81new%E5%92%8Cdelete%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">5、new和delete的实现原理</h3>
<h3 id="%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B">内置类型</h3>
<blockquote>
<p>如果申请的是内置类型的空间，new和malloc，delete和free基本类似，不同的地方是：new/delete申请和释放的是单个元素的空间，<span style="color:#956fe7;">new[]和delete[]申请的是连续空间</span>，<span style="color:#956fe7;">而且new在申请空间失败时会抛异常，malloc会返回NULL</span>。</p>
</blockquote>
<h3 id="%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B">自定义类型</h3>
<blockquote>
<p><span style="color:#0d0016;"><strong>new的原理</strong></span></p>
<ol><li>调用operator new函数申请空间</li><li>在申请的空间上执行构造函数，完成对象的构造</li></ol>
<p><span style="color:#0d0016;"><strong>delete的原理</strong></span></p>
<ol><li>在空间上执行析构函数，完成对象中资源的清理工作</li><li>调用operator delete函数释放对象的空间</li></ol>
<p><span style="color:#0d0016;"><strong>new T[N]的原理</strong></span></p>
<ol><li>调用operator new[]函数，在operator new[]中实际调用operator new函数完成N个对象空间的申请</li><li>在申请的空间上执行N次构造函数</li></ol>
<p><span style="color:#0d0016;"><strong>delete[ ]的原理</strong></span></p>
<ol><li>在释放的对象空间上执行N次析构函数，完成N个对象中资源的清理</li><li>调用operator delete[]释放空间，实际在operator delete[]中调用operator delete来释放空间</li></ol>
</blockquote>
<hr/>
<h3 id="6%E3%80%81%E5%AE%9A%E4%BD%8Dnew%E8%A1%A8%E8%BE%BE%E5%BC%8F(placement-new)%20%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89">6、定位new表达式(placement-new) （了解）</h3>
<blockquote>
<p>定位new表达式是在<span style="color:#956fe7;">已分配的原始内存空间中调用构造函数初始化一个对象</span>。</p>
<p><strong>使用格式：</strong></p>
<pre><code class="language-cpp">new (place_address) type或者new (place_address) type(initializer-list)</code></pre>
<p>place_address必须是一个指针，initializer-list是类型的初始化列表</p>
<p><strong>使用场景：</strong></p>
<p>定位new表达式在实际中一般是配合内存池使用。因为内存池分配出的内存没有初始化，所以如果是自定义类型的对象，需要使用new的定义表达式进行显示调构造函数进行初始化</p>
<pre><code class="language-cpp">class Test
{
public:
	Test(int date = 2)
		: _data(date)
	{
		cout &lt;&lt; "Test():" &lt;&lt; this &lt;&lt; endl;
	}
	~Test()
	{
		cout &lt;&lt; "~Test():" &lt;&lt; this &lt;&lt; endl;
	}
private:
	int _data;
};
int main()
{
	// pt现在指向的只不过是与Test对象相同大小的一段空间，还不能算是一个对象，因为构造函数没有执行
	Test* pt1 = (Test*)malloc(sizeof(Test));
    //new (place_address) type
	new(pt1)Test; // 注意：如果Test类的构造函数有参数时，此处需要传参

    //new(place_address) type(initializer - list)
	Test* pt2 = (Test*)malloc(sizeof(Test));
	new(pt2)Test(10);
}
</code></pre>
</blockquote>
<hr/>
<h3 id="7%E3%80%81%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98">7、常见面试题</h3>
<h3 id="7.1%E3%80%81malloc%2Ffree%E5%92%8Cnew%2Fdelete%E7%9A%84%E5%8C%BA%E5%88%AB">7.1、malloc/free和new/delete的区别</h3>
<blockquote>
<p><strong>共同点：</strong></p>
<ul><li>都是从堆上申请空间，并且需要用户手动释放。</li></ul>
<p><strong>不同点：</strong></p>
<ol><li>malloc和free是函数，new和delete是操作符</li><li>malloc申请的空间不会初始化，new可以初始化</li><li>malloc申请空间时，需要手动计算空间大小并传递，new只需在其后跟上空间的类型即可</li><li>malloc的返回值为void*, 在使用时必须强转，new不需要，因为new后跟的是空间的类型</li><li>malloc申请空间失败时，返回的是NULL，因此使用时必须判空，new不需要，但是new需要捕获异常<span style="color:#956fe7;">（底层区别）</span></li><li>申请自定义类型对象时，malloc/free只会开辟空间，不会调用构造函数与析构函数，而new在申请空间后会调用构造函数完成对象的初始化，delete在释放空间前会调用析构函数完成空间中资源的清理<span style="color:#956fe7;">（底层区别）</span></li></ol>
</blockquote>
<h3 id="7.2%E3%80%81%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F">7.2、内存泄漏</h3>
<h3 id="%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%8C%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%8D%B1%E5%AE%B3">什么是内存泄漏，内存泄漏的危害</h3>
<blockquote>
<p><strong>什么是内存泄漏：</strong></p>
<ul><li>内存泄漏指因为疏忽或错误造成程序未能释放已经不再使用的内存的情况。内存泄漏并不是指内存在物理上的消失，而是应用程序分配某段内存后，因为设计错误，失去了对该段内存的控制，因而造成了内存的浪费。<span style="color:#956fe7;">（内存泄漏是指针丢了）</span></li></ul>
<p><strong>内存泄漏的危害：</strong></p>
<ul><li>长期运行的程序出现内存泄漏，影响很大，如操作系统、后台服务等等，出现内存泄漏会导致响应越来越慢，最终卡死</li></ul>
<pre><code class="language-cpp">void MemoryLeaks()
{
	// 1.内存申请了忘记释放
	int* p1 = (int*)malloc(sizeof(int));
	int* p2 = new int;
	// 2.异常安全问题
	int* p3 = new int[10];
	Func(); // 这里Func函数抛异常导致 delete[] p3未执行，p3没被释放.
	delete[] p3;
}</code></pre>
</blockquote>
<h3 id="%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%88%86%E7%B1%BB%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89">内存泄漏分类（了解）</h3>
<blockquote>
<p>C/C++程序中一般我们关心两种方面的内存泄漏：</p>
<p><strong>堆内存泄漏(Heap leak)</strong></p>
<ul><li>堆内存指的是程序执行中依据须要分配通过malloc / calloc / realloc / new等从堆中分配的一块内存，用完后必须通过调用相应的 free或者delete 删掉。假设程序的设计错误导致这部分内存没有被释放，那么以后这部分空间将无法再被使用，就会产生Heap Leak。</li></ul>
<p><strong>系统资源泄漏</strong></p>
<ul><li>指程序使用系统分配的资源，比方套接字、文件描述符、管道等没有使用对应的函数释放掉，导致系统资源的浪费，严重可导致系统效能减少，系统执行不稳定。</li></ul>
</blockquote>
<h3 id="%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89">如何检测内存泄漏（了解）</h3>
<blockquote>
<ul><li>在linux下内存泄漏检测：<a class="link-info" href="https://blog.csdn.net/gatieme/article/details/51959654" title="linux下几款内存泄漏检测工具">linux下几款内存泄漏检测工具</a></li><li>在windows下使用第三方工具：<a class="link-info" href="https://blog.csdn.net/GZrhaunt/article/details/56839765" title="VLD工具说明">VLD工具说明</a></li><li>其他工具：<a class="link-info" href="https://www.cnblogs.com/liangxiaofeng/p/4318499.html" title="内存泄漏工具比较">内存泄漏工具比较</a></li></ul>
</blockquote>
<h3 id="%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F">如何避免内存泄漏</h3>
<blockquote>
<ol><li>工程前期良好的设计规范，养成良好的编码规范，申请的内存空间记着匹配的去释放。ps：这个理想状态。但是如果碰上异常时，就算注意释放了，还是可能会出问题。需要下一条智能指针来管理才有保证。</li><li>采用RAII思想或者智能指针来管理资源。</li><li>有些公司内部规范使用内部实现的私有内存管理库。这套库自带内存泄漏检测的功能选项。</li><li>出问题了使用内存泄漏工具检测。ps：不过很多工具都不够靠谱，或者收费昂贵。</li></ol>
<p><strong>总结一下:</strong></p>
<ul><li>内存泄漏非常常见，解决方案分为两种：1、事前预防型。如智能指针等。2、事后查错型。如泄漏检测工具。</li></ul>
</blockquote>
<h3 id="7.3%E3%80%81%E5%A6%82%E4%BD%95%E4%B8%80%E6%AC%A1%E5%9C%A8%E5%A0%86%E4%B8%8A%E7%94%B3%E8%AF%B74G%E7%9A%84%E5%86%85%E5%AD%98%EF%BC%9F">7.3、如何一次在堆上申请4G的内存？</h3>
<blockquote>
<pre><code class="language-cpp">// 将程序编译成x64的进程，运行下面的程序试试？
#include &lt;iostream&gt;
using namespace std;
int main()
{
	void* p = new char[0xfffffffful];
	cout &lt;&lt; "new:" &lt;&lt; p &lt;&lt; endl;
	return 0;
}</code></pre>
<h3><img alt="" height="334" src="image\c0ea135a00474100bf5bf2ba1ec57caf.png" width="797"/></h3>
</blockquote>
</div>
</div>