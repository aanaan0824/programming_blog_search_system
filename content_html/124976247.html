<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="markdown_views prism-atom-one-dark" id="content_views">
<svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
<path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
</svg>
<p>析构函数·</p>
<p>定义一个对象，c++自动调用构造函数建立该对象并进行初始化，那么当一个对象的生命周期结束时，c++会自动调用一个函数注销该对象并进行善后工作，这个特殊的成员函数叫做析构函数</p>
<p>析构函数和类名相同，但在前面要加<sub>，如</sub>CGoods().</p>
<p>析构函数无函数返回类型，与构造函数在这方面是一样的。但析构函数不带任何参数。</p>
<p>一个类只有一个析构函数，这是和构造函数不一样的，</p>
<p>对象注销时，系统自动调用析构函数。</p>
<p>若类说明中没有给出析构函数，则c++会给出一个缺省的析构函数。</p>
<pre><code>class complex

{

   double real;

   double image;

public:

complex():real{},image{}

{

cout&lt;&lt;"create object:"&lt;&lt;this&lt;&lt;endl;

}

complex(double r,double i):real{r},image{i}{

cout&lt;&lt;"create object:"&lt;&lt;this&lt;&lt;endl;

}

~complex()

{

cout&lt;&lt;"destroy object:"&lt;&lt;this&lt;&lt;endl;

}

void print()const

{

cout&lt;&lt;"real="&lt;&lt;real&lt;&lt;'t'&lt;&lt;"image="&lt;&lt;image&lt;&lt;endl;

}

};

</code></pre>
<p>类的对象不能调动构造函数，但对象可以调动析构函数，对自己销毁。</p>
<p>构造函数是对资源的获取，析构函数是释放资源。</p>
<pre><code>class Int()

{

private:

value;

public:

Int (int x=0):value(x)

{

cout&lt;&lt;"create Int:"&lt;&lt;this&lt;&lt;value&lt;&lt;endl;

}

~Int():value()

{

cout&lt;&lt;"destory Int:"&lt;&lt;this&lt;&lt;endl;

}

void print() const

{

cout&lt;&lt;value&lt;&lt;endl;

}
void show()const{
cout &lt;&lt;"Int::show"&lt;&lt;endl;
}

};



int main()

{

Int a(1);

Int b(2);

Int c(3);

return 0;

}
</code></pre>
<pre><code>int main()

{

Int *ip=nullptr;

ip-&gt;show();

ip-&gt;print();

return 0;

}
</code></pre>
<p>ip指针可以调用show，但是不能调用print，因为print中打印value需要对ip解引用。</p>
<p>局部变量区设置为栈区。上面的例子中调用构造函数的顺序为abc，调用析构函数的顺序为cba。</p>
<p>在c++中开辟了空间没有对象，当想给这块空间赋值时需要使用定位new</p>
<p>如 int *p=new Int(10)(区别int *p=new Int{10})</p>
<p>new开辟空间时不用去判空，因为如果开辟失败会有返回bad alloc.(malloc 与 operator new的区别，开辟失败时的返回)。</p>
<pre><code>//ip用operator new来开辟,释放时也用operator delete
for (int i=0;i&lt;n;++i){

new(&amp;ip[i]) Int(i)

}
</code></pre>
<p>ps：成员函数设计时加const的好处:1.安全2.通用性好，既适用于普通对象也适用于常对象。</p>
<p>属性的值不能被外部找到，要想看到得通过函数将值带出来。</p>
</div>
<link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css" rel="stylesheet"/>
<link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css" rel="stylesheet"/>
</div>