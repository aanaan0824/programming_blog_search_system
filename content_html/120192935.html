<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="markdown_views prism-atom-one-dark" id="content_views">
<svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
<path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
</svg>
<h1><a id="_0"></a>前言</h1>
<blockquote>
<p>  <font color="FF4500"><b>「 数据结构 」</b></font> 和 <font color="FFa700"><b>「 算法 」</b></font> 是密不可分的，两者往往是<font color="ffd700"><b>「 相辅相成 」</b></font>的存在，所以，在学习 <font color="FF4500"><b>「 数据结构 」</b></font> 的过程中，不免会遇到各种<font color="FFa700"><b>「 算法 」</b></font>。<br/>  到底是先学 数据结构 ，还是先学 算法，我认为不必纠结这个问题，一定是一起学的。<br/>  数据结构 常用的操作一般为：<font color="13ae01"><b>「 增 」</b></font><font color="FF0500"><b>「 删 」</b></font><font color="ffd700"><b>「 改 」</b></font><font color="2290ff"><b>「 查 」</b></font>。基本上所有的数据结构都是围绕这几个操作进行展开的。<br/>  那么这篇文章，作者将主要来聊聊：<br/><br/> </p>
<center>
<font color="2290ff" size="5"><b>「 算法和数据结构 」</b></font>
</center>
<br/>
<img alt="" src="image\20210719224751824.png"/>
<br/>
<a href="#jump99"><font color="ff1f00" size="5"><b><u>直接跳到末尾</u></b></font></a> 获取粉丝专属福利
 <br/>
<div class="csdn-video-box">
<iframe allowfullscreen="true" data-mediaembed="bilibili" id="5OPDwdlY-1639950019877" src="https://player.bilibili.com/player.html?aid=764932417"></iframe>
<p>LeetCode算法学习路线</p>
</div>
<br/>
<a href="https://www.bilibili.com/video/BV1fr4y1D7Pz">完整版视频地址</a>
<br/>
<img alt="" src="image\d91936c19f6b49f89a40db2188cc5e8c.png"/>
<p></p>
</blockquote>
<table><thead><tr><th>专栏</th><th>定位</th><th>适宜人群</th></tr></thead><tbody><tr><td><a href="https://blog.csdn.net/whereisherofrom/category_11131373.html">「 光天化日学C语言 」</a></td><td><strong>「 入门 」</strong></td><td>没有任何语言基础</td></tr><tr><td><a href="https://blog.csdn.net/whereisherofrom/category_11492771.html">「 LeetCode零基础指南 」</a></td><td><strong>「 初级 」</strong></td><td>零基础快速上手力扣</td></tr><tr><td><a href="https://blog.csdn.net/whereisherofrom/category_11158834.html">「 C语言入门100例 」</a></td><td><strong>「 中级 」</strong></td><td>零基础持续C语言练习教程</td></tr><tr><td><a href="https://blog.csdn.net/whereisherofrom/category_11426012.html">「 算法零基础100讲 」</a></td><td><strong>「 高级 」</strong></td><td>零基础持续算法练习教程</td></tr><tr><td><a href="https://blog.csdn.net/whereisherofrom/category_11227297.html">「 画解数据结构 」</a></td><td><strong>「 高级 」</strong></td><td><strong>「 推荐 」</strong> 数据结构动图教程</td></tr><tr><td><a href="https://blog.csdn.net/whereisherofrom/category_11451355.html">「 算法进阶50讲 」</a></td><td><strong>「 资深 」</strong></td><td>进阶持续算法练习教程</td></tr><tr><td><a href="https://docs.qq.com/mind/DU01SVGpab2tWdlNj">「 LeetCode算法题集汇总 」</a></td><td><strong>「 资深 」</strong></td><td>全面的力扣算法题练习集锦</td></tr><tr><td><a href="https://blog.csdn.net/whereisherofrom/category_9273531.html">「 夜深人静写算法 」</a></td><td><strong>「 资级 」</strong></td><td>竞赛高端算法集锦</td></tr></tbody></table>
<blockquote>
<p>  在学习数据结构的过程中，如果你能够自己把图画出来，并且能够描述整个 <font color="13ae01"><b>「 增 」</b></font><font color="FF0500"><b>「 删 」</b></font><font color="ffd700"><b>「 改 」</b></font><font color="2290ff"><b>「 查 」</b></font> 的过程，那么说明你已经真正理解了数据结构的真谛，来看下下面几张图：<br/><br/> <img alt="" src="https://img-blog.csdnimg.cn/a1f66250029a4a3ea996e40fafac90d1.gif#pic_center"/><br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/0b8600a4a3e04bdea63e1969d4d99ab9.gif#pic_center"/><br/> <img alt="" src="https://img-blog.csdnimg.cn/c84d83855377473ab43852b947329ccd.gif#pic_center"/><br/> <img alt="" src="https://img-blog.csdnimg.cn/3f3079ffb2404a89bf64cf9bdadb8153.gif#pic_center"/></p>
</blockquote>
<p></p>
<div class="toc">
<h3>文章目录</h3>
<ul><li><a href="#_0">前言</a></li><li><a href="#_29">一、算法和数据结构的重要性</a></li><li><ul><li><a href="#1_30">1、为什么要学习算法</a></li><li><a href="#2_35">2、如何有效的学习</a></li><li><a href="#3_40">3、坚持并且把它当成兴趣</a></li><li><a href="#4_47">4、首先要有语言基础</a></li><li><a href="#5_66">5、九日集训</a></li><li><a href="#6_76">6、零基础如何学习算法</a></li><li><ul><li><a href="#1_90">1）位运算</a></li><li><a href="#2_102">2）线性代数</a></li><li><a href="#3_111">3）计算几何</a></li><li><a href="#4_118">4）数论</a></li><li><a href="#5___123">5）组合数学 和 概率论</a></li></ul>
</li><li><a href="#7_128">7、零基础如何学习数据结构</a></li><li><a href="#8_136">8、数据结构和算法是相辅相成的</a></li></ul>
</li><li><a href="#_141">二、数据结构是根基</a></li><li><ul><li><a href="#1_143">1、数组</a></li><li><ul><li><a href="#_146">一、概念</a></li><li><ul><li><a href="#1_147">1、顺序存储</a></li><li><a href="#2_150">2、存储方式</a></li><li><a href="#3_153">3、长度和容量</a></li><li><a href="#4_157">4、数据结构定义</a></li></ul>
</li><li><a href="#_171">二、常用接口实现</a></li><li><ul><li><a href="#1_172">1、索引</a></li><li><a href="#2_182">2、查找</a></li><li><a href="#3_201">3、获取长度</a></li><li><a href="#4_208">4、插入</a></li><li><a href="#5_229">5、删除</a></li></ul>
</li></ul>
</li><li><a href="#2_250">2、链表</a></li><li><ul><li><a href="#_253">一、概念</a></li><li><ul><li><a href="#1_255">1、链表定义</a></li><li><a href="#2_262">2、结点结构体定义</a></li><li><a href="#3_275">3、结点的创建</a></li></ul>
</li><li><a href="#___291">二、链表的创建 - 尾插法</a></li><li><ul><li><a href="#1_293">1、算法描述</a></li><li><a href="#2_295">2、动画演示</a></li><li><a href="#3_300">3、源码详解</a></li></ul>
</li><li><a href="#___323">三、链表的创建 - 头插法</a></li><li><ul><li><a href="#1_324">1、算法描述</a></li><li><a href="#2_327">2、动画演示</a></li><li><a href="#3_330">3、源码详解</a></li></ul>
</li></ul>
</li><li><a href="#3_348">3、哈希表</a></li><li><ul><li><a href="#_351">一、哈希表的概念</a></li><li><ul><li><a href="#1_352">1、查找算法</a></li><li><a href="#2_357">2、哈希表</a></li><li><a href="#2_367">2、哈希数组</a></li><li><a href="#3_371">3、关键字</a></li><li><a href="#4_381">4、哈希函数</a></li><li><a href="#5_388">5、哈希冲突</a></li><li><a href="#6_392">6、哈希地址</a></li></ul>
</li><li><a href="#_394">二、常用哈希函数</a></li><li><ul><li><a href="#1_395">1、直接定址法</a></li><li><a href="#2_405">2、平方取中法</a></li><li><a href="#3_409">3、折叠法</a></li><li><a href="#4_414">4、除留余数法</a></li><li><a href="#5_418">5、位与法</a></li></ul>
</li><li><a href="#_422">三、常见哈希冲突解决方案</a></li><li><ul><li><a href="#1_423">1、开放定址法</a></li><li><ul><li><a href="#1_424">1）原理讲解</a></li><li><a href="#2_427">2）动画演示</a></li></ul>
</li><li><a href="#2_432">2、再散列函数法</a></li><li><ul><li><a href="#1_433">1）原理讲解</a></li></ul>
</li><li><a href="#3_435">3、链地址法</a></li><li><ul><li><a href="#1_436">1）原理讲解</a></li><li><a href="#2_438">2）动画演示</a></li></ul>
</li><li><a href="#4_441">4、公共溢出区法</a></li><li><ul><li><a href="#1_442">1）原理讲解</a></li></ul>
</li></ul>
</li></ul>
</li><li><a href="#4_448">4、队列</a></li><li><ul><li><a href="#_451">一、概念</a></li><li><ul><li><a href="#1_452">1、队列的定义</a></li><li><a href="#2_456">2、队首</a></li><li><a href="#3_460">3、队尾</a></li></ul>
</li><li><a href="#_463">二、接口</a></li><li><ul><li><a href="#1_464">1、数据入队</a></li><li><a href="#2_467">2、数据出队</a></li><li><a href="#3_471">3、清空队列</a></li><li><a href="#4_475">4、获取队首数据</a></li><li><a href="#5_477">5、获取队列元素个数</a></li><li><a href="#6_479">6、队列的判空</a></li></ul>
</li></ul>
</li><li><a href="#5_485">5、栈</a></li><li><ul><li><a href="#_488">一、概念</a></li><li><ul><li><a href="#1_489">1、栈的定义</a></li><li><a href="#2_492">2、栈顶</a></li><li><a href="#3_496">3、栈底</a></li></ul>
</li><li><a href="#_500">二、接口</a></li><li><ul><li><a href="#1_501">1、数据入栈</a></li><li><a href="#2_505">2、数据出栈</a></li><li><a href="#3_509">3、清空栈</a></li><li><a href="#1_513">1、获取栈顶数据</a></li><li><a href="#2_515">2、获取栈元素个数</a></li><li><a href="#3_517">3、栈的判空</a></li></ul>
</li></ul>
</li><li><a href="#7_522">🌵7、二叉树</a></li><li><a href="#8_525">🌳8、多叉树</a></li><li><a href="#9_529">🌲9、森林</a></li><li><a href="#10_532">🍀10、树状数组</a></li><li><a href="#11_535">🌍11、图</a></li></ul>
</li><li><a href="#_606">三、四个入门算法</a></li><li><ul><li><a href="#1_607">1、排序</a></li><li><a href="#2_655">2、线性迭代</a></li><li><a href="#3_738">3、线性枚举</a></li><li><a href="#4_796">4、二分枚举</a></li></ul>
</li><li><a href="#_857">四、社区活跃奖励</a></li><li><ul><li><a href="#1_861">1、简介</a></li><li><a href="#2_865">2、内容简介</a></li><li><a href="#3_869">3、作者简介</a></li></ul>
</li><li><a href="#_877">五、粉丝专属福利</a></li></ul>
</div>
<p></p>
<h1><a id="_29"></a>一、算法和数据结构的重要性</h1>
<h2><a id="1_30"></a>1、为什么要学习算法</h2>
<p>  如果你只是想学会写代码，或许 <strong>「 算法与数据结构 」</strong> 并不是那么重要，但是，想要进一步发展自己的事业，<strong>「 算法与数据结构 」</strong> 是必不可少的。<br/>   现在一些主流的大厂，诸如：字节、网易、腾讯、阿里、美团、京东、滴滴 等等，在面时都会让候选人写一道 <strong>「 算法题 」</strong> ，如果你敲不出来，可能你的 <strong>offer</strong> 年包就打了骨折，或者直接与 <strong>offer</strong> 失之交臂，都是有可能的。<br/>   当然，它不能完全代表你的编码能力（因为有些算法确实是很巧妙，加上紧张的面试氛围，想不出来其实也是正常的），但是你能确保面试官是这么想的吗？我们要做的是十足的准备，既然决定出来，<strong>offer</strong> 当然是越高越好，毕竟大家都要养家糊口，房价又这么贵，如果能够在算法这一块取得先机，也不失为一个捷径。<br/>   所以，你问我算法和数据结构有什么用？我可以很明确的说，和你的年薪息息相关。当然，面试中 <strong>「算法与数据结构」</strong> 知识的考察只是面试内容的一部分。其它还有很多面试要考察的内容，当然不是本文主要核心内容，这里就不做展开了。</p>
<h2><a id="2_35"></a>2、如何有效的学习</h2>
<p>  这篇文章中，我会着重讲解一些常见的 <strong>「 算法和数据结构 」</strong> 的设计思想，并且配上动图。主要针对面试中常见的问题和新手朋友们比较难理解的点进行解析。当然，后面也会给出面向算法竞赛的提纲，如果有兴趣深入学习的欢迎在评论区留言，一起成长交流。<br/>   零基础学算法的最好方法，莫过于 <strong>「 刷题 」</strong> 了。任何事情都是需要 <strong>「 坚持 」</strong> 的，刷题也一样，没有刷够足够的题，就很难做出系统性的总结。所以上大学的时候，我花了三年的时间来刷题， 工作以后还是会抽点时间出来刷题。<br/>   当然，每天不需要花太多时间在这个上面，把这个事情做成一个 <strong>「 规划 」</strong> ，按照长期去推进。反正也没有 KPI 压力，就当成是工作之余的一种消遣，还能够提升思维能力。所谓： <strong>「 十年磨一剑，今朝把示君 」</strong> 。</p>
<h2><a id="3_40"></a>3、坚持并且把它当成兴趣</h2>
<p>  相信看我文章的大多数都是<font color="000000"><b>「 大学生 」</b></font>，能上大学的都是<font color="000000"><b>「 精英 」</b></font>，那么我们自然要<font color="000000"><b>「 精益求精 」</b></font>，如果你还是<font color="000000"><b>「 大一 」</b></font>，那么太好了，你拥有大把时间，当然你可以选择<font color="000000"><b>「 刷剧 」</b></font>，然而，<font color="000000"><b>「 学好算法 」</b></font>，三年后的你自然<font color="000000"><b>「 不能同日而语 」</b></font>。<br/>   如果你满足如下：<br/>   <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        (
       
       
        1
       
       
        )
       
      
      
       (1)
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span> <font color="FF0500"><b>有强烈欲望「 想要学好C语言 」的人</b></font><br/>   <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        (
       
       
        2
       
       
        )
       
      
      
       (2)
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span></span></span></span></span> <font color="FF4500"><b>有强烈欲望「 想要学好C++ 」的人</b></font><br/>   <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        (
       
       
        3
       
       
        )
       
      
      
       (3)
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mclose">)</span></span></span></span></span> <font color="ffd700"><b>有强烈欲望「 想要学好数据结构 」的人</b></font><br/>   <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        (
       
       
        4
       
       
        )
       
      
      
       (4)
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">4</span><span class="mclose">)</span></span></span></span></span> <font color="13ae01"><b>有强烈欲望「 想学好算法 」的人</b></font><br/>   <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        (
       
       
        5
       
       
        )
       
      
      
       (5)
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">5</span><span class="mclose">)</span></span></span></span></span> <font color="2290ff"><b>有强烈欲望「 想进大厂 」的人</b></font><br/>   如果你满足以上任意一点，那么，我们就是志同道合的人啦！<br/>   🔥联系作者，或者扫作者主页二维码加群，加入我们吧🔥</p>
<h2><a id="4_47"></a>4、首先要有语言基础</h2>
<p>  单纯学习语言未免太过枯燥乏味，所以建议一边学习一遍刷题，养成每天刷题的习惯，在刷题的过程中巩固语法，每过一个题相当于是一次正反馈，能够让你在刷题旅途中酣畅淋漓，从而更好的保证你一直坚持下去，在没有任何算法基础的情况下，可以按照我提供的专栏来刷题，这也是上上个视频提到的 九日集训 的完整教材，主要有以下几个内容：<br/> <img alt="" src="image\18fa967f632c41c88c73d172789a099f.png"/></p>
<p>  这个专栏主要讲解了一些 LeetCode 刷题时的一些难点和要点，主要分为以下几个章节，并且会持续补充一些方法论的文章。文章有试读，可以简单先看一看试读文章。</p>
<center>
<a href="https://blog.csdn.net/whereisherofrom/category_11492771.html"><font color="fd7f28"><b>🍠《<u>LeetCode零基础指南</u>》🍠</b></font></a>
</center>
<br/>
<center>
<a href="https://blog.csdn.net/WhereIsHeroFrom/article/details/120876065"><font color="fd7f28"><b>导读</b></font></a>
</center>
<center>
<a href="https://blog.csdn.net/WhereIsHeroFrom/article/details/120876221"><font color="fd7f28"><b>（第一讲）函数</b></font></a>
</center>
<center>
<a href="https://blog.csdn.net/WhereIsHeroFrom/article/details/121507083"><font color="fd7f28"><b>（第二讲）循环</b></font></a>
</center>
<center>
<a href="https://blog.csdn.net/WhereIsHeroFrom/article/details/120875955"><font color="fd7f28"><b>（第三讲）数组</b></font></a>
</center>
<center>
<a href="https://blog.csdn.net/WhereIsHeroFrom/article/details/121551694"><font color="fd7f28"><b>（第四讲）指针</b></font></a>
</center>
<center>
<a href="https://blog.csdn.net/WhereIsHeroFrom/article/details/120875926"><font color="fd7f28"><b>（第五讲）排序</b></font></a>
</center>
<center>
<a href="https://blog.csdn.net/WhereIsHeroFrom/article/details/121586834"><font color="fd7f28"><b>（第六讲）贪心</b></font></a>
</center>
<center>
<a href="https://blog.csdn.net/WhereIsHeroFrom/article/details/120875842"><font color="fd7f28"><b>（第七讲）矩阵</b></font></a>
</center>
<center>
<a href="https://blog.csdn.net/WhereIsHeroFrom/article/details/120875692"><font color="fd7f28"><b>（第八讲）二级指针</b></font></a>
</center>
<center>
<a href="https://blog.csdn.net/WhereIsHeroFrom/article/details/120875679"><font color="fd7f28"><b>（第九讲）简单递归</b></font></a>
</center>
<br/>
<h2><a id="5_66"></a>5、九日集训</h2>
<p>  「 九日集训 」是博主推出的一个能够白嫖付费专栏「 <a href="https://blog.csdn.net/whereisherofrom/category_11492771.html">LeetCode零基础指南</a> 」的活动。通过 <strong>「 专栏中的联系方式 」</strong> 或者 <strong>「 本文末尾的联系方式 」</strong> 联系博主，进行报名即可参加。九日一个循环，第二期计划 <strong>「 2021.12.02 」</strong> 开启。</p>
<blockquote>
<p>  玩法很简单，每天会开启一篇试读文章，要求有三点：<br/>   1）阅读完文章后，课后习题 <strong>「 全部刷完 」</strong>（都能在文中找到解法，需要自己敲一遍代码）；<br/>   2）写 <strong>「 学习报告 」</strong> 并发布社区 <a href="https://bbs.csdn.net/forums/hero?typeId=19611"><strong>九日集训(每日打卡)</strong></a> 频道<br/>   3）在 <strong>「 打卡帖 」</strong> 提交 <strong>「 学习报告 」</strong> 链接；</p>
</blockquote>
<p>  完成以上三点后方可晋级到下一天，所有坚持到 9天 的同学，会成为 <strong>「 英雄算法联盟合伙人 」</strong> 群成员，只限500个名额，优胜劣汰，和精英在一起，无论是沟通，学习，都能有更好的发展，你接触到的人脉也都是不一样的，等找工作的时候，我也会为大家打通 hr 和猎头，让你前程无忧～<br/>   详细规则参见：<a href="https://el4f837pzj.feishu.cn/docs/doccnBqapeNTOu6WJgat4eCrEsg">九日集训规则详解</a>。<br/>   目前第四轮「 九日集训 」已经进行到第四天，即将开启第五轮。</p>
<h2><a id="6_76"></a>6、零基础如何学习算法</h2>
<p>  数学是算法的基石，可以先从刷数学题开始。<br/>   LeetCode上的题目相比ACM来说，数学题较少，所以对数学有恐惧的同学也不必担心，比较常见的数学题主要有：位运算，线性代数，计算几何，组合数学 ，数论，概率论。<br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/37b6a31432884560adc581d3c665013b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Iux6ZuE5ZOq6YeM5Ye65p2l,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center"/></p>
<table><thead><tr><th>板块</th><th>题数</th></tr></thead><tbody><tr><td>位运算</td><td>30</td></tr><tr><td>线性代数</td><td>20</td></tr><tr><td>计算几何</td><td>5</td></tr><tr><td>组合数学</td><td>5</td></tr><tr><td>数论</td><td>5</td></tr><tr><td>概率论</td><td>5</td></tr></tbody></table>
<h3><a id="1_90"></a>1）位运算</h3>
<p>  位运算主要有：位与、位或、按位取反、异或、左移 和 右移。对应的文章可以看：</p>
<center>
<a href="https://blog.csdn.net/WhereIsHeroFrom/article/details/120876417"><font color="2290ff"><b><u>(第42讲) 位运算 (位与) 入门</u></b></font></a>
</center>
<center>
<a href="https://blog.csdn.net/WhereIsHeroFrom/article/details/121690450"><font color="2290ff"><b><u>(第44讲) 位运算 (位或) 入门</u></b></font></a>
</center>
<center>
<a href="https://blog.csdn.net/WhereIsHeroFrom/article/details/121739055"><font color="2290ff"><b><u>(第46讲) 位运算 (异或) 入门</u></b></font></a>
</center>
<center>
<a href="https://blog.csdn.net/WhereIsHeroFrom/article/details/121760206"><font color="2290ff"><b><u>(第48讲) 位运算 (左移) 入门</u></b></font></a>
</center>
<center>
<a href="https://blog.csdn.net/WhereIsHeroFrom/article/details/121782847"><font color="2290ff"><b><u>(第49讲) 位运算 (右移) 入门</u></b></font></a>
</center>
<center>
<a href="https://blog.csdn.net/WhereIsHeroFrom/article/details/121854342"><font color="2290ff"><b><u>(第50讲) 位运算 (取反) 入门</u></b></font></a>
</center>
<br/>
<p>  位运算是计算机的精华所在，是必须掌握的内容。大概每个运算操作刷 三 到 五 题就基本有感觉了。</p>
<h3><a id="2_102"></a>2）线性代数</h3>
<p>  线性代数在刷题中，主要内容有 <strong>矩阵运算</strong> 和 <strong>高斯消元</strong>。矩阵在程序中的抽象就是二维数组。如下：</p>
<center>
<a href="https://blog.csdn.net/WhereIsHeroFrom/article/details/120875842"><font color="fd7f28"><b>（第七讲）矩阵</b></font></a>
</center>
<br/>
<p>  高斯消元是求解多元一次方程组的，一般在竞赛中会遇到，面试一般不问，因为面试官可能也不会。</p>
<center>
<a href="https://blog.csdn.net/WhereIsHeroFrom/article/details/108907826"><font color="7761e8"><b>夜深人静写算法 (十六) 高斯消元</b></font></a>
</center>
<br/>
<h3><a id="3_111"></a>3）计算几何</h3>
<p>  数论 是 ACM 中一个比较重要的内容，至少一旦出现，一定不会是一个水题，编码量较大，但是在 LeetCode 中题型较少，可以适当掌握一些基础内容即可。对应文章如下：</p>
<center>
<a href="https://blog.csdn.net/WhereIsHeroFrom/article/details/111829732"><font color="7761e8"><b>夜深人静写算法 （四）- 计算几何入门</b></font></a>
</center>
<center>
<a href="https://blog.csdn.net/WhereIsHeroFrom/article/details/113102600"><font color="7761e8"><b>夜夜深人静写算法（十二）- 凸包</b></font></a>
</center>
<h3><a id="4_118"></a>4）数论</h3>
<p>  数论 是 ACM 中一个比较重要的内容，但是在 LeetCode 中题型较少，可以适当掌握一些基础内容即可。对应文章如下：</p>
<center>
<a href="https://blog.csdn.net/WhereIsHeroFrom/article/details/111693538"><font color="7761e8"><b>夜深人静写算法 (三) 初等数论入门</b></font></a>
</center>
<br/>
<h3><a id="5___123"></a>5）组合数学 和 概率论</h3>
<p>  组合数学 和 概率论，在 LeetCode 中题目较少，有兴趣可以刷一刷，没有兴趣就不要去刷了，毕竟兴趣才是最好的老师。对应的文章如下：</p>
<center>
<a href="https://blog.csdn.net/WhereIsHeroFrom/article/details/120875081"><font color="2290ff"><b>(第4讲) 组合数</b></font></a>
</center>
<center>
<a href="https://blog.csdn.net/WhereIsHeroFrom/article/details/121414040"><font color="2290ff"><b>(第30讲) 概率问题</b></font></a>
</center>
<h2><a id="7_128"></a>7、零基础如何学习数据结构</h2>
<p>  学习数据结构之前，选择一款相对来说心仪的教程是必不可少的，我这里准备了一个用动画来解释数据结构的教程，在我这也有，就是：</p>
<center>
<a href="https://blog.csdn.net/whereisherofrom/category_11227297.html"><font color="13ae01"><b>🌳《<u>画解数据结构</u>》🌳 </b></font></a>
</center>
<br/>   这是我目前来说，写的最用心的一个教程，里面汇集了大量的动图，目前更新已经过半，好评如潮。
<br/>  当然，一边学习，一边做一些练习题是必不可少的，接下来就是推荐一个我自己整理的题集了，这个题集汇集了大量的算法。可以帮你在前行的路上扫平不少障碍。 
<center>
<a href="https://docs.qq.com/mind/DU01SVGpab2tWdlNj"><font color="2290ff"><b>🌌《<u>算法入门指引</u>》🌌</b></font></a>
</center>
<br/>   在看上述题目时，如果遇到难以解决的问题，可以参考如下解题报告专栏： 
<center>
<a href="https://blog.csdn.net/whereisherofrom/category_11178770.html"><font color="f2102f"><b>🌌《<u>算法解题报告</u>》🌌</b></font></a>
</center>
<br/>
<h2><a id="8_136"></a>8、数据结构和算法是相辅相成的</h2>
<p>  如果你在刷题的过程中，已经爱上了算法，那么恭喜你，你将会无法自拔，一直刷题一直爽，在遇到一些高端的算法时，也不要惊慌，这里推荐一个竞赛选手金典图文教程，如下：</p>
<center>
<a href="https://blog.csdn.net/whereisherofrom/category_9273531.html"><font color="886ce4">💜<b>《<u>夜深人静写算法</u>》</b>💜</font></a>
</center>
<h1><a id="_141"></a>二、数据结构是根基</h1>
<p>  学习算法，数据结构是根基，没有一些数据结构做支撑，这个算法都没有落脚点，任何一个简单的算法都是需要数据结构来支撑的，比如最简单的算法，</p>
<h2><a id="1_143"></a>1、数组</h2>
<blockquote>
<p><strong>内存结构</strong>：内存空间连续<br/><strong>实现难度</strong>：简单<br/><strong>下标访问</strong>：支持<br/><strong>分类</strong>：静态数组、动态数组<br/><strong>插入时间复杂度</strong>：<span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         O
        
        
         (
        
        
         n
        
        
         )
        
       
       
        O(n)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span><br/><strong>查找时间复杂度</strong>：<span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         O
        
        
         (
        
        
         n
        
        
         )
        
       
       
        O(n)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span><br/><strong>删除时间复杂度</strong>：<span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         O
        
        
         (
        
        
         n
        
        
         )
        
       
       
        O(n)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span></p>
</blockquote>
<h3><a id="_146"></a>一、概念</h3>
<h4><a id="1_147"></a>1、顺序存储</h4>
<p>  顺序存储结构，是指用一段地址连续的存储单元依次存储线性表的数据元素。<br/> <img alt="" src="https://img-blog.csdnimg.cn/2021052910070993.gif#pic_center"/></p>
<h4><a id="2_150"></a>2、存储方式</h4>
<p>  在编程语言中，用一维数组来实现顺序存储结构，在C语言中，把第一个数据元素存储到下标为 0 的位置中，把第 2 个数据元素存储到下标为 1 的位置中，以此类推。</p>
<h4><a id="3_153"></a>3、长度和容量</h4>
<p>  数组的长度指的是数组当前有多少个元素，数组的容量指的是数组最大能够存放多少个元素。如果数组元素大于最大能存储的范围，在程序上是不允许的，可能会产生意想不到的问题，实现上是需要规避的。<br/> <img alt="" src="image\67912e8fc2a34566b5da5a0fe7ef49a6.png"/><br/>   如上图所示，数组的长度为 5，即红色部分；容量为 8，即红色 加 蓝色部分。</p>
<h4><a id="4_157"></a>4、数据结构定义</h4>
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXN</span> <span class="token expression"><span class="token number">1024</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DataType</span> <span class="token expression"><span class="token keyword">int</span>        </span><span class="token comment">// (1)</span></span>

<span class="token keyword">struct</span> <span class="token class-name">SeqList</span> <span class="token punctuation">{<!-- --></span>
    DataType data<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// (2)</span>
    <span class="token keyword">int</span> length<span class="token punctuation">;</span>             <span class="token comment">// (3)</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span> 
</code></pre>
<ul><li><span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         1
        
        
         )
        
       
       
        (1)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span> 数组类型为<code>DataType</code>，定义为<code>int</code>；</li><li><span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         2
        
        
         )
        
       
       
        (2)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span></span></span></span></span> <code>SeqList</code>定义的就是一个最多存放<code>MAXN</code>个元素的数组，<code>MAXN</code>代表数组容量；</li><li><span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         3
        
        
         )
        
       
       
        (3)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mclose">)</span></span></span></span></span> <code>length</code>代表数组长度，即当前的元素个数。</li></ul>
<h3><a id="_171"></a>二、常用接口实现</h3>
<h4><a id="1_172"></a>1、索引</h4>
<p>  <strong>索引</strong> 就是通过 <strong>数组下标</strong> 寻找 <strong>数组元素</strong> 的过程。C语言实现如下：</p>
<pre><code class="prism language-c">DataType <span class="token function">SeqListIndex</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">SeqList</span> <span class="token operator">*</span>sq<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> sq<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>          <span class="token comment">// (1)</span>
<span class="token punctuation">}</span>
</code></pre>
<ul><li><span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         1
        
        
         )
        
       
       
        (1)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span> 调用方需要注意 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         i
        
       
       
        i
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.65952em; vertical-align: 0em;"></span><span class="mord mathdefault">i</span></span></span></span></span> 的取值必须为非负整数，且小于数组最大长度。否则有可能导致异常，引发崩溃。</li><li>索引的算法时间复杂度为 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         O
        
        
         (
        
        
         1
        
        
         )
        
       
       
        O(1)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>。<br/> <img alt="" src="image\f1aa18a5b4514e25b97587036ccf9442.png"/></li></ul>
<h4><a id="2_182"></a>2、查找</h4>
<p>  <strong>查找</strong> 就是通过 <strong>数组元素</strong> 寻找 <strong>数组下标</strong> 的过程，是索引的逆过程。<br/>   对于有序数组，可以采用 二分 进行查找，时间复杂度为 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        O
       
       
        (
       
       
        l
       
       
        o
       
       
        
         g
        
        
         2
        
       
       
        n
       
       
        )
       
      
      
       O(log_2n)
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span>；对于无序数组，只能通过遍历比较，由于元素可能不在数组中，可能遍历全表，所以查找的最坏时间复杂度为 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        O
       
       
        (
       
       
        n
       
       
        )
       
      
      
       O(n)
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span>。<br/>   简单介绍一个线性查找的例子，实现如下：</p>
<pre><code class="prism language-c">DataType <span class="token function">SeqListFind</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">SeqList</span> <span class="token operator">*</span>sq<span class="token punctuation">,</span> DataType dt<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> sq<span class="token operator">-&gt;</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// (1)</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>sq<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> dt<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> i<span class="token punctuation">;</span>                 <span class="token comment">// (2)</span>
        <span class="token punctuation">}</span>    
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                        <span class="token comment">// (3)</span>
<span class="token punctuation">}</span>
</code></pre>
<ul><li><span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         1
        
        
         )
        
       
       
        (1)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span> 遍历数组元素；</li><li><span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         2
        
        
         )
        
       
       
        (2)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span></span></span></span></span> 对数组元素 和 传入的数据进行判等，一旦发现相等就返回对应数据的下标；</li><li><span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         3
        
        
         )
        
       
       
        (3)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mclose">)</span></span></span></span></span> 当数组遍历完还是找不到，说明这个数据肯定是不存在的，直接返回 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         −
        
        
         1
        
       
       
        -1
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span></span>。<br/> <img alt="" src="https://img-blog.csdnimg.cn/1204116368f0428c8901711a8ec26851.gif#pic_center"/></li></ul>
<h4><a id="3_201"></a>3、获取长度</h4>
<p>  获取 <strong>数组的长度</strong> 指的是查询当前有多少元素。可以直接用结构体的内部变量。C语言代码实现如下：</p>
<pre><code class="prism language-c">DataType <span class="token function">SeqListGetLength</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">SeqList</span> <span class="token operator">*</span>sq<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> sq<span class="token operator">-&gt;</span>length<span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
</code></pre>
<h4><a id="4_208"></a>4、插入</h4>
<p>  插入接口定义为：在数组的第 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        k
       
      
      
       k
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span></span></span></span></span> 个元素前插入一个数 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        v
       
      
      
       v
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span></span></span></span></span>。由于数组是连续存储的，那么从 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        k
       
      
      
       k
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span></span></span></span></span> 个元素往后的元素都必须往后移动一位，当 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        k
       
       
        =
       
       
        0
       
      
      
       k=0
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">0</span></span></span></span></span> 时，所有元素都必须移动，所以最坏时间复杂度为 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        O
       
       
        (
       
       
        n
       
       
        )
       
      
      
       O(n)
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span>。C语言代码实现如下：</p>
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">SeqListInsert</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">SeqList</span> <span class="token operator">*</span>sq<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">,</span> DataType v<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>sq<span class="token operator">-&gt;</span>length <span class="token operator">==</span> MAXN<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>                        <span class="token comment">// (1) </span>
    <span class="token punctuation">}</span> 
    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> sq<span class="token operator">-&gt;</span>length<span class="token punctuation">;</span> i <span class="token operator">&gt;</span> k<span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        sq<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> sq<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment">// (2) </span>
    <span class="token punctuation">}</span>
    sq<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">;</span>                     <span class="token comment">// (3) </span>
    sq<span class="token operator">-&gt;</span>length <span class="token operator">++</span><span class="token punctuation">;</span>                       <span class="token comment">// (4) </span>
    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>                            <span class="token comment">// (5) </span>
<span class="token punctuation">}</span>
</code></pre>
<ul><li><span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         1
        
        
         )
        
       
       
        (1)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span> 当元素个数已满时，返回 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         0
        
       
       
        0
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">0</span></span></span></span></span> 代表插入失败；</li><li><span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         2
        
        
         )
        
       
       
        (2)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span></span></span></span></span> 从第 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         k
        
       
       
        k
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span></span></span></span></span> 个数开始，每个数往后移动一个位置，注意必须逆序；</li><li><span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         3
        
        
         )
        
       
       
        (3)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mclose">)</span></span></span></span></span> 将第 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         k
        
       
       
        k
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span></span></span></span></span> 个数变成 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         v
        
       
       
        v
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span></span></span></span></span>；</li><li><span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         4
        
        
         )
        
       
       
        (4)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">4</span><span class="mclose">)</span></span></span></span></span> 插入了一个数，数组长度加一；</li><li><span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         5
        
        
         )
        
       
       
        (5)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">5</span><span class="mclose">)</span></span></span></span></span> 返回 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         1
        
       
       
        1
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span></span></span></span></span> 代表插入成功；</li></ul>
<h4><a id="5_229"></a>5、删除</h4>
<p>  插入接口定义为：将数组的第 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        k
       
      
      
       k
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span></span></span></span></span> 个元素删除。由于数组是连续存储的，那么第 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        k
       
      
      
       k
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span></span></span></span></span> 个元素删除，往后的元素势必要往前移动一位，当 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        k
       
       
        =
       
       
        0
       
      
      
       k=0
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">0</span></span></span></span></span> 时，所有元素都必须移动，所以最坏时间复杂度为 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        O
       
       
        (
       
       
        n
       
       
        )
       
      
      
       O(n)
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span>。C语言代码实现如下：</p>
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">SeqListDelete</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">SeqList</span> <span class="token operator">*</span>sq<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>sq<span class="token operator">-&gt;</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>                        <span class="token comment">// (1) </span>
    <span class="token punctuation">}</span> 
    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> k<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> sq<span class="token operator">-&gt;</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        sq<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> sq<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment">// (2) </span>
    <span class="token punctuation">}</span> 
    sq<span class="token operator">-&gt;</span>length <span class="token operator">--</span><span class="token punctuation">;</span>                       <span class="token comment">// (3) </span>
    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>                            <span class="token comment">// (4)  </span>
<span class="token punctuation">}</span>
</code></pre>
<ul><li><span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         1
        
        
         )
        
       
       
        (1)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span> 返回0代表删除失败；</li><li><span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         2
        
        
         )
        
       
       
        (2)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span></span></span></span></span> 从前往后；</li><li><span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         3
        
        
         )
        
       
       
        (3)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mclose">)</span></span></span></span></span> 数组长度减一；</li><li><span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         4
        
        
         )
        
       
       
        (4)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">4</span><span class="mclose">)</span></span></span></span></span> 返回1代表删除成功；</li><li>想要了解更多数组相关内容，可以参考：<u><a href="https://blog.csdn.net/WhereIsHeroFrom/article/details/118979494">《画解数据结构》（1 - 1）- 数组</a></u>。</li></ul>
<hr/>
<h2><a id="2_250"></a>2、链表</h2>
<blockquote>
<p><strong>内存结构</strong>：内存空间连续不连续，看具体实现<br/><strong>实现难度</strong>：一般<br/><strong>下标访问</strong>：不支持<br/><strong>分类</strong>：单向链表、双向链表、循环链表、DancingLinks<br/><strong>插入时间复杂度</strong>：<span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         O
        
        
         (
        
        
         1
        
        
         )
        
       
       
        O(1)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span><br/><strong>查找时间复杂度</strong>：<span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         O
        
        
         (
        
        
         n
        
        
         )
        
       
       
        O(n)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span><br/><strong>删除时间复杂度</strong>：<span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         O
        
        
         (
        
        
         1
        
        
         )
        
       
       
        O(1)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></p>
</blockquote>
<h3><a id="_253"></a>一、概念</h3>
<ul><li>对于顺序存储的结构，如数组，最大的缺点就是：<strong>插入</strong> 和 <strong>删除</strong> 的时候需要移动大量的元素。所以，基于前人的智慧，他们发明了链表。</li></ul>
<h4><a id="1_255"></a>1、链表定义</h4>
<blockquote>
<p>  <strong>链表</strong> 是由一个个 <strong>结点</strong> 组成，每个 <strong>结点</strong> 之间通过 <strong>链接关系</strong> 串联起来，每个 <strong>结点</strong> 都有一个 <strong>后继节点</strong>，最后一个 <strong>结点</strong> 的 <strong>后继结点</strong> 为 <strong>空结点</strong>。如下图所示：</p>
</blockquote>
<p><img alt="" src="image\10485d3373089b13fe59fadf925e43c0.png"/></p>
<ul><li>由链接关系<code>A -&gt; B</code>组织起来的两个结点，<code>B</code>被称为<code>A</code>的后继结点，<code>A</code>被称为<code>B</code>的前驱结点。</li><li><strong>链表</strong> 分为 <strong>单向链表</strong>、<strong>双向链表</strong>、<strong>循环链表</strong> 等等，本文要介绍的链表是 <strong>单向链表</strong>。</li><li>由于链表是由一个个 <strong>结点</strong> 组成，所以我们先来看下 <strong>结点</strong> 的实现。</li></ul>
<h4><a id="2_262"></a>2、结点结构体定义</h4>
<pre><code class="prism language-c"><span class="token keyword">typedef</span> <span class="token keyword">int</span> DataType<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">ListNode</span> <span class="token punctuation">{<!-- --></span>
    DataType data<span class="token punctuation">;</span>  <span class="token comment">// (1)</span>
    ListNode <span class="token operator">*</span>next<span class="token punctuation">;</span> <span class="token comment">// (2)</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<ul><li><span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         1
        
        
         )
        
       
       
        (1)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span> <strong>数据域</strong>：可以是任意类型，由编码的人自行指定；这段代码中，利用<code>typedef</code>将它和<code>int</code>同名，本文的 <strong>数据域</strong> 也会全部采用<code>int</code>类型进行讲解；</li><li><span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         2
        
        
         )
        
       
       
        (2)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span></span></span></span></span> <strong>指针域</strong>：指向 <strong>后继结点</strong> 的地址；</li><li>一个结点包含的两部分如下图所示：<br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/img_convert/255454fa46f752e8f22496983f59e932.png#pic_center"/></li></ul>
<h4><a id="3_275"></a>3、结点的创建</h4>
<ul><li>我们通过 C语言 中的库函数<code>malloc</code>来创建一个 <strong>链表结点</strong>，然后对 <strong>数据域</strong> 和 <strong>指针域</strong> 进行赋值，代码实现如下：</li></ul>
<pre><code class="prism language-c">ListNode <span class="token operator">*</span><span class="token function">ListCreateNode</span><span class="token punctuation">(</span>DataType data<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    ListNode <span class="token operator">*</span>node <span class="token operator">=</span> <span class="token punctuation">(</span>ListNode <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">malloc</span> <span class="token punctuation">(</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>ListNode<span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// (1)</span>
    node<span class="token operator">-&gt;</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>                                         <span class="token comment">// (2)</span>
    node<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>                                         <span class="token comment">// (3)</span>
    <span class="token keyword">return</span> node<span class="token punctuation">;</span>                                               <span class="token comment">// (4)</span>
<span class="token punctuation">}</span>
</code></pre>
<ul><li><span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         1
        
        
         )
        
       
       
        (1)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span> 利用系统库函数<code>malloc</code>分配一块内存空间，用来存放<code>ListNode</code>即链表结点对象；</li><li><span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         2
        
        
         )
        
       
       
        (2)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span></span></span></span></span> 将 <strong>数据域</strong> 置为函数传参<code>data</code>；</li><li><span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         3
        
        
         )
        
       
       
        (3)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mclose">)</span></span></span></span></span> 将 <strong>指针域</strong> 置空，代表这是一个孤立的 <strong>链表结点</strong>；</li><li><span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         4
        
        
         )
        
       
       
        (4)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">4</span><span class="mclose">)</span></span></span></span></span> 返回这个结点的指针。</li><li>创建完毕以后，这个孤立结点如下所示：<br/> <img alt="" src="image\92a5e6195224479f8b1bedd6c4624a4d.png"/></li></ul>
<h3><a id="___291"></a>二、链表的创建 - 尾插法</h3>
<ul><li>那么接下来，让我们看下如何通过一个 <strong>数组中的数据</strong> 来创建一个链表。</li></ul>
<h4><a id="1_293"></a>1、算法描述</h4>
<blockquote>
<p>  首先介绍 <strong>尾插法</strong> ，顾名思义，即 <strong>从链表尾部插入</strong> 的意思，就是记录一个 <strong>链表尾结点</strong>，然后遍历给定数组，将数组元素一个一个插到链表的尾部，每插入一个结点，则将它更新为新的 <strong>链表尾结点</strong>。注意初始情况下，<strong>链表尾结点</strong> 为空。</p>
</blockquote>
<h4><a id="2_295"></a>2、动画演示</h4>
<p><img alt="" src="https://img-blog.csdnimg.cn/8d0ce73e12ae4cf8b9761efc147775dd.gif#pic_center"/></p>
<blockquote>
<p>上图演示的是 <strong>尾插法</strong> 的整个过程，其中：<br/>  <font color="red"><b>head</b></font> 代表链表头结点，创建完一个结点以后，它就保持不变了；<br/>  <font color="red"><b>tail</b></font> 代表链表尾结点，即动图中的 <font color="52bc69"><b>绿色结点</b></font>；<br/>  <font color="red"><b>vtx</b></font> 代表正在插入链表尾部的结点，即动图中的 <font color="fe8a27"><b>橙色结点</b></font>，插入完毕以后，<font color="red"><b>vtx</b></font> 变成 <font color="red"><b>tail</b></font>；</p>
</blockquote>
<ul><li>看完这个动图，你应该已经大致理解了 <strong>链表的创建过程</strong>。那么接下来，我们用程序语言来描述一下整个过程，这里采用的是 <strong>C语言</strong> 的形式，如果你是 Java、C#、Python 技术栈的，也可以试着写出自己的版本。</li><li>语言并不是关键，思维才是关键。</li></ul>
<h4><a id="3_300"></a>3、源码详解</h4>
<ul><li>C语言 实现如下：</li></ul>
<pre><code class="prism language-c">ListNode <span class="token operator">*</span><span class="token function">ListCreateListByTail</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    ListNode <span class="token operator">*</span>head<span class="token punctuation">,</span> <span class="token operator">*</span>tail<span class="token punctuation">,</span> <span class="token operator">*</span>vtx<span class="token punctuation">;</span>         <span class="token comment">// (1) </span>
    <span class="token keyword">int</span> idx<span class="token punctuation">;</span>                              
    <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>                     <span class="token comment">// (2) </span>
    idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    vtx <span class="token operator">=</span> <span class="token function">ListCreateNode</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// (3) </span>
    head <span class="token operator">=</span> tail <span class="token operator">=</span> vtx<span class="token punctuation">;</span>                   <span class="token comment">// (4)  </span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">++</span>idx <span class="token operator">&lt;</span> n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>                   <span class="token comment">// (5) </span>
        vtx <span class="token operator">=</span> <span class="token function">ListCreateNode</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// (6) </span>
        tail<span class="token operator">-&gt;</span>next <span class="token operator">=</span> vtx<span class="token punctuation">;</span>                <span class="token comment">// (7) </span>
        tail <span class="token operator">=</span> vtx<span class="token punctuation">;</span>                      <span class="token comment">// (8)  </span>
    <span class="token punctuation">}</span> 
    <span class="token keyword">return</span> head<span class="token punctuation">;</span>                         <span class="token comment">// (9) </span>
<span class="token punctuation">}</span> 
</code></pre>
<blockquote>
<p>对应的注释如下：<br/>  <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         1
        
        
         )
        
       
       
        (1)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span> <code>head</code>存储头结点的地址，<code>tail</code>存储尾结点的地址，<code>vtx</code>存储当前正在插入结点的地址； <br/>  <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         2
        
        
         )
        
       
       
        (2)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span></span></span></span></span> 当需要创建的元素个数为 0 时，直接返回空链表； <br/>  <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         3
        
        
         )
        
       
       
        (3)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mclose">)</span></span></span></span></span> 创建一个 <strong>数据域</strong> 为<code>a[0]</code>的链表结点；<br/>  <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         4
        
        
         )
        
       
       
        (4)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">4</span><span class="mclose">)</span></span></span></span></span> 由于初始情况下只有一个结点，所以将链表头结点<code>head</code>和链表尾结点<code>tail</code>都置为<code>vtx</code>；<br/>  <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         5
        
        
         )
        
       
       
        (5)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">5</span><span class="mclose">)</span></span></span></span></span> 从数组第 1 个元素 (0 - based) 开始，循环遍历数组；<br/>  <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         6
        
        
         )
        
       
       
        (6)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">6</span><span class="mclose">)</span></span></span></span></span> 由于数组中第 0 个元素已经创建过了，所以这里只需要对除了第 0 个元素以外的数据创建链表结点； <br/>  <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         7
        
        
         )
        
       
       
        (7)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">7</span><span class="mclose">)</span></span></span></span></span> 结点创建出来后，将当前链表尾结点<code>tail</code>的 <strong>后继结点</strong> 置为<code>vtx</code>；<br/>  <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         8
        
        
         )
        
       
       
        (8)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">8</span><span class="mclose">)</span></span></span></span></span> 将最近创建的结点<code>vtx</code>作为新的 <strong>链表尾结点</strong>；<br/>  <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         9
        
        
         )
        
       
       
        (9)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">9</span><span class="mclose">)</span></span></span></span></span> 返回链表头结点；</p>
</blockquote>
<hr/>
<ul><li><strong>尾插法</strong> 比较符合直观的思维逻辑，但是就代码量来说还是有点长（注意：在实现相同功能的情况下，代码应该是越简洁，越简单越好的）。</li><li>于是，我们引入了另一种创建链表的方式 —— 头插法。</li></ul>
<h3><a id="___323"></a>三、链表的创建 - 头插法</h3>
<h4><a id="1_324"></a>1、算法描述</h4>
<blockquote>
<p>  <strong>头插法</strong>，顾名思义，就是每次从头结点前面进行插入，但是这样一来，就会导致插入的数据元素是 <strong>逆序</strong> 的，所以我们需要 <strong>逆序访问数组</strong> 执行插入，此所谓 <strong>负负得正</strong> 的思想。</p>
</blockquote>
<ul><li>它的特点是代码量短，且 <strong>常数时间复杂度</strong> 低。虽然没有 <strong>尾插法</strong> 那么直观，但是代码简洁，更加容易阅读。</li></ul>
<h4><a id="2_327"></a>2、动画演示</h4>
<p><img alt="" src="https://img-blog.csdnimg.cn/75e4131224d24a159d20f44bf8808509.gif#pic_center"/></p>
<blockquote>
<p>上图所示的是 <strong>头插法</strong> 的整个插入过程，其中：<br/>  <font color="red"><b>head</b></font> 代表链表头结点，即动图中的 <font color="52bc69"><b>绿色结点</b></font>，每新加一个结点，头结点就变成了新加入的结点；<br/>  <font color="red"><b>tail</b></font> 代表链表尾结点，创建完一个结点以后，它就保持不变了；<br/>  <font color="red"><b>vtx</b></font> 代表正在插入链表头部的结点，即动图中的 <font color="fe8a27"><b>橙色结点</b></font>，插入完毕以后，<font color="red"><b>vtx</b></font> 变成 <font color="red"><b>head</b></font>；</p>
</blockquote>
<h4><a id="3_330"></a>3、源码详解</h4>
<pre><code class="prism language-c">ListNode <span class="token operator">*</span><span class="token function">ListCreateListByHead</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    ListNode <span class="token operator">*</span>head <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token operator">*</span>vtx<span class="token punctuation">;</span>       <span class="token comment">// (1) </span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>                       <span class="token comment">// (2) </span>
        vtx <span class="token operator">=</span> <span class="token function">ListCreateNode</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// (3) </span>
        vtx<span class="token operator">-&gt;</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>              <span class="token comment">// (4) </span>
        head <span class="token operator">=</span> vtx<span class="token punctuation">;</span>                    <span class="token comment">// (5) </span>
    <span class="token punctuation">}</span> 
    <span class="token keyword">return</span> head<span class="token punctuation">;</span>                       <span class="token comment">// (6) </span>
<span class="token punctuation">}</span> 
</code></pre>
<blockquote>
<p>对应的注释如下：<br/>  <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         1
        
        
         )
        
       
       
        (1)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span> <code>head</code>存储头结点的地址，初始为空链表， <code>vtx</code>存储当前正在插入结点的地址； <br/>  <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         2
        
        
         )
        
       
       
        (2)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span></span></span></span></span> 总共需要插入 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         n
        
       
       
        n
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span></span></span></span></span> 个结点，所以采用逆序的 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         n
        
       
       
        n
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span></span></span></span></span> 次循环； <br/>  <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         3
        
        
         )
        
       
       
        (3)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mclose">)</span></span></span></span></span> 创建一个元素值为<code>a[i]</code>的链表结点，注意，由于逆序，所以这里 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         i
        
       
       
        i
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.65952em; vertical-align: 0em;"></span><span class="mord mathdefault">i</span></span></span></span></span> 的取值为 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         n
        
        
         −
        
        
         1
        
        
         →
        
        
         0
        
       
       
        n-1 \to 0
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.66666em; vertical-align: -0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">0</span></span></span></span></span>； <br/>  <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         4
        
        
         )
        
       
       
        (4)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">4</span><span class="mclose">)</span></span></span></span></span> 将当前创建的结点的 <strong>后继结点</strong> 置为 链表的头结点<code>head</code>； <br/>  <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         5
        
        
         )
        
       
       
        (5)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">5</span><span class="mclose">)</span></span></span></span></span> 将链表头结点<code>head</code>置为<code>vtx</code>； <br/>  <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         6
        
        
         )
        
       
       
        (6)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">6</span><span class="mclose">)</span></span></span></span></span> 返回链表头结点；</p>
</blockquote>
<hr/>
<ul><li> <p><strong>头插法</strong> 的代码量比 <strong>尾插法</strong> 少了三分之一，而且将 <strong>创建结点的逻辑</strong> 统一起来了。这句话什么意思呢？仔细观察可以发现，<strong>尾插法</strong> 在实现过程中，<code>ListCreateNode</code>在代码里出现了两次，而 <strong>头插法</strong> 只出现了一次，将流程简化了，所以还是推荐使用 <strong>头插法</strong>。</p> </li><li> <p>想要了解更多链表相关内容，可以参考：<u><a href="https://blog.csdn.net/WhereIsHeroFrom/article/details/118979800">《画解数据结构》（1 - 3）- 链表</a></u>。</p> </li></ul>
<hr/>
<h2><a id="3_348"></a>3、哈希表</h2>
<blockquote>
<p><strong>内存结构</strong>：哈希表本身连续，但是衍生出来的结点逻辑上不连续<br/><strong>实现难度</strong>：一般<br/><strong>下标访问</strong>：不支持<br/><strong>分类</strong>：正数哈希、字符串哈希、滚动哈希<br/><strong>插入时间复杂度</strong>：<span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         O
        
        
         (
        
        
         1
        
        
         )
        
       
       
        O(1)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span><br/><strong>查找时间复杂度</strong>：<span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         O
        
        
         (
        
        
         1
        
        
         )
        
       
       
        O(1)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span><br/><strong>删除时间复杂度</strong>：<span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         O
        
        
         (
        
        
         1
        
        
         )
        
       
       
        O(1)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></p>
</blockquote>
<h3><a id="_351"></a>一、哈希表的概念</h3>
<h4><a id="1_352"></a>1、查找算法</h4>
<p>  当我们在一个 <strong>链表</strong> 或者 <strong>顺序表</strong> 中 <strong>查找</strong> 一个数据元素 <strong>是否存在</strong> 的时候，唯一的方法就是遍历整个表，这种方法称为 <strong>线性枚举</strong>。<br/> <img alt="" src="https://img-blog.csdnimg.cn/2021052910070993.gif#pic_center"/><br/>   如果这时候，顺序表是有序的情况下，我们可以采用折半的方式去查找，这种方法称为 <strong>二分枚举</strong>。<br/>   <strong>线性枚举</strong> 的时间复杂度为 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        O
       
       
        (
       
       
        n
       
       
        )
       
      
      
       O(n)
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span>。<strong>二分枚举</strong> 的时间复杂度为 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        O
       
       
        (
       
       
        l
       
       
        o
       
       
        
         g
        
        
         2
        
       
       
        n
       
       
        )
       
      
      
       O(log_2n)
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span>。是否存在更快速的查找方式呢？这就是本要介绍的一种新的数据结构 —— 哈希表。</p>
<h4><a id="2_357"></a>2、哈希表</h4>
<p>  由于它不是顺序结构，所以很多数据结构书上称之为 <strong>散列表</strong>，下文会统一采用 <strong>哈希表</strong> 的形式来说明，作为读者，只需要知道这两者是同一种数据结构即可。<br/>   我们把需要<strong>查找的数据</strong>，通过一个 <strong>函数映射</strong>，找到 <strong>存储数据的位置</strong> 的过程称为 <strong>哈希</strong>。这里涉及到几个概念：<br/>   a）需要 <strong>查找的数据</strong> 本身被称为 <strong>关键字</strong>；<br/>   b）通过 <strong>函数映射</strong> 将 <strong>关键字</strong> 变成一个 <strong>哈希值</strong> 的过程中，这里的 <strong>函数</strong> 被称为 <strong>哈希函数</strong>；<br/>   c）生成 <strong>哈希值</strong> 的过程过程可能产生冲突，需要进行 <strong>冲突解决</strong>；<br/>   d）解决完冲突以后，实际 <strong>存储数据的位置</strong> 被称为 <strong>哈希地址</strong>，通俗的说，它就是一个数组下标；<br/>   e）存储所有这些数据的数据结构就是 <strong>哈希表</strong>，程序实现上一般采用数组实现，所以又叫 <strong>哈希数组</strong>。整个过程如下图所示：<br/> <img alt="" src="https://img-blog.csdnimg.cn/e6a56f91b20c4646b0400496dc003fe5.gif#pic_center"/></p>
<h4><a id="2_367"></a>2、哈希数组</h4>
<p>  为了方便下标索引，<strong>哈希表</strong> 的底层实现结构是一个数组，数组类型可以是任意类型，每个位置被称为一个槽。如下图所示，它代表的是一个长度为 8 的 <strong>哈希表</strong>，又叫 <strong>哈希数组</strong>。</p>
<p><img alt="" src="image\20210120064654913.png"/></p>
<h4><a id="3_371"></a>3、关键字</h4>
<p>  <strong>关键字</strong> 是哈希数组中的元素，可以是任意类型的，它可以是整型、浮点型、字符型、字符串，甚至是结构体或者类。如下的 A、C、M 都可以是关键字；</p>
<pre><code class="prism language-c"><span class="token keyword">int</span> A <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> C<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Hello World!"</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">Obj</span> <span class="token punctuation">{<!-- --></span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
Obj M<span class="token punctuation">;</span>
</code></pre>
<p>  哈希表的实现过程中，我们需要通过一些手段，将一个非整型的 <strong>关键字</strong> 转换成 <strong>数组下标</strong>，也就是 <strong>哈希值</strong>，从而通过 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        O
       
       
        (
       
       
        1
       
       
        )
       
      
      
       O(1)
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span> 的时间快速索引到它所对应的位置。<br/>   而将一个非整型的 <strong>关键字</strong> 转换成 <strong>整型</strong> 的手段就是 <strong>哈希函数</strong>。</p>
<h4><a id="4_381"></a>4、哈希函数</h4>
<p>  哈希函数可以简单的理解为就是小学课本上那个函数，即 <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml">
     
      
       
        
         y
        
        
         =
        
        
         f
        
        
         (
        
        
         x
        
        
         )
        
       
       
        y = f(x)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">y</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span></span></span>，这里的 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        f
       
       
        (
       
       
        x
       
       
        )
       
      
      
       f(x)
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span></span> 就是哈希函数，<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        x
       
      
      
       x
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">x</span></span></span></span></span> 是关键字，<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        y
       
      
      
       y
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">y</span></span></span></span></span> 是哈希值。好的哈希函数应该具备以下两个特质：<br/>   a）单射；<br/>   b）雪崩效应：输入值 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        x
       
      
      
       x
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">x</span></span></span></span></span> 的 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        1
       
      
      
       1
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span></span></span></span></span> 比特的变化，能够造成输出值 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        y
       
      
      
       y
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">y</span></span></span></span></span> 至少一半比特的变化；<br/>   单射很容易理解，图 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        (
       
       
        a
       
       
        )
       
      
      
       (a)
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mclose">)</span></span></span></span></span> 中已知哈希值 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        y
       
      
      
       y
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">y</span></span></span></span></span> 时，键 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        x
       
      
      
       x
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">x</span></span></span></span></span> 可能有两种情况，不是一个单射；而图 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        (
       
       
        b
       
       
        )
       
      
      
       (b)
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></span> 中已知哈希值 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        y
       
      
      
       y
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">y</span></span></span></span></span> 时，键 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        x
       
      
      
       x
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">x</span></span></span></span></span> 一定是唯一确定的，所以它是单射。由于 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        x
       
      
      
       x
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">x</span></span></span></span></span> 和 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        y
       
      
      
       y
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">y</span></span></span></span></span> 一一对应，这样就从本原上减少了冲突。<br/> <img alt="" src="image\1ea359360a97c0deff40a5e4d483e6a9.png"/>  雪崩效应是为了让哈希值更加符合随机分布的原则，哈希表中的键分布的越随机，利用率越高，效率也越高。<br/>   常用的哈希函数有：<strong>直接定址法</strong>、<strong>除留余数法</strong>、<strong>数字分析法</strong>、<strong>平方取中法</strong>、<strong>折叠法</strong>、<strong>随机数法</strong> 等等。有关哈希函数的内容，下文会进行详细讲解。</p>
<h4><a id="5_388"></a>5、哈希冲突</h4>
<p>  哈希函数在生成 <strong>哈希值</strong> 的过程中，如果产生 <strong>不同的关键字得到相同的哈希值</strong> 的情况，就被称为 <strong>哈希冲突</strong>。<br/>   即对于哈希函数 <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml">
     
      
       
        
         y
        
        
         =
        
        
         f
        
        
         (
        
        
         x
        
        
         )
        
       
       
        y = f(x)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">y</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span></span></span>，当关键字 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         x
        
        
         1
        
       
       
        ≠
       
       
        
         x
        
        
         2
        
       
      
      
       x_1 \neq x_2
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.69444em;"><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="rlap"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.19444em;"><span class=""></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>，但是却有 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        f
       
       
        (
       
       
        
         x
        
        
         1
        
       
       
        )
       
       
        =
       
       
        f
       
       
        (
       
       
        
         x
        
        
         2
        
       
       
        )
       
      
      
       f(x_1) = f(x_2)
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>，这时候，我们需要进行冲突解决。<br/>   冲突解决方法有很多，主要有：<strong>开放定址法</strong>、<strong>再散列函数法</strong>、<strong>链地址法</strong>、<strong>公共溢出区法</strong> 等等。有关解决冲突的内容，下文会进行详细讲解。</p>
<h4><a id="6_392"></a>6、哈希地址</h4>
<p>  <strong>哈希地址</strong> 就是一个 <strong>数组下标</strong> ，即哈希数组的下标。通过下标获得数据，被称为 <strong>索引</strong>。通过数据获得下标，被称为 <strong>哈希</strong>。平时工作的时候，和同事交流时用到的一个词 <strong>反查</strong> 就是说的 <strong>哈希</strong>。</p>
<h3><a id="_394"></a>二、常用哈希函数</h3>
<h4><a id="1_395"></a>1、直接定址法</h4>
<p>  <strong>直接定址法</strong> 就是 <strong>关键字</strong> 本身就是 <strong>哈希值</strong>，表示成函数值就是 <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml">
     
      
       
        
         f
        
        
         (
        
        
         x
        
        
         )
        
        
         =
        
        
         x
        
       
       
        f(x) = x
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">x</span></span></span></span></span></span>  例如，我们需要统计一个字符串中每个字符的出现次数，就可以通过这种方法。任何一个字符的范围都是 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        [
       
       
        0
       
       
        ,
       
       
        255
       
       
        ]
       
      
      
       [0, 255]
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">2</span><span class="mord">5</span><span class="mord">5</span><span class="mclose">]</span></span></span></span></span>，所以只要用一个长度为 256 的哈希数组就可以存储每个字符对应的出现次数，利用一次遍历枚举就可以解决这个问题。C代码实现如下：</p>
<pre><code class="prism language-c"><span class="token keyword">int</span> i<span class="token punctuation">,</span> hash<span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token operator">++</span>hash<span class="token punctuation">[</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>  这个就是最基础的直接定址法的实现。<code>hash[c]</code>代表字符<code>c</code>在这个字符串<code>str</code>中的出现次数。</p>
<h4><a id="2_405"></a>2、平方取中法</h4>
<p>  <strong>平方取中法</strong> 就是对 <strong>关键字</strong> 进行平方，再取中间的某几位作为 <strong>哈希值</strong>。<br/>   例如，对于关键字 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        1314
       
      
      
       1314
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mord">1</span><span class="mord">4</span></span></span></span></span>，得到平方为 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        1726596
       
      
      
       1726596
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span><span class="mord">7</span><span class="mord">2</span><span class="mord">6</span><span class="mord">5</span><span class="mord">9</span><span class="mord">6</span></span></span></span></span>，取中间三位作为哈希值，即 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        265
       
      
      
       265
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">2</span><span class="mord">6</span><span class="mord">5</span></span></span></span></span>。<br/>   平方取中法 比较适用于 <strong>不清楚关键字的分布，且位数也不是很大</strong> 的情况。</p>
<h4><a id="3_409"></a>3、折叠法</h4>
<p>  <strong>折叠法</strong> 是将关键字分割成位数相等的几部分（注意最后一部分位数不够可以短一些），然后再进行求和，得到一个 <strong>哈希值</strong>。<br/>   例如，对于关键字 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        5201314
       
      
      
       5201314
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">5</span><span class="mord">2</span><span class="mord">0</span><span class="mord">1</span><span class="mord">3</span><span class="mord">1</span><span class="mord">4</span></span></span></span></span>，将它分为四组，并且相加得到：<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        52
       
       
        +
       
       
        01
       
       
        +
       
       
        31
       
       
        +
       
       
        4
       
       
        =
       
       
        88
       
      
      
       52+01+31+4 = 88
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="mord">5</span><span class="mord">2</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="mord">0</span><span class="mord">1</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="mord">3</span><span class="mord">1</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">4</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">8</span><span class="mord">8</span></span></span></span></span>，这就是哈希值。<br/>   <strong>折叠法</strong> 比较适用于 <strong>不清楚关键字的分布，但是关键字位数较多</strong> 的情况。</p>
<h4><a id="4_414"></a>4、除留余数法</h4>
<p>  <strong>除留余数法</strong> 就是 <strong>关键字</strong> 模上 <strong>哈希表</strong> 长度，表示成函数值就是 <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml">
     
      
       
        
         f
        
        
         (
        
        
         x
        
        
         )
        
        
         =
        
        
         x
        
        
          
        
        
         m
        
        
         o
        
        
         d
        
        
          
        
        
         m
        
       
       
        f(x) = x \ mod \ m
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault">x</span><span class="mspace"> </span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace"> </span><span class="mord mathdefault">m</span></span></span></span></span></span>  其中 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        m
       
      
      
       m
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">m</span></span></span></span></span> 代表了哈希表的长度，这种方法，不仅可以对关键字直接取模，也可以在 平方取中法、折叠法 之后再取模。<br/>   例如，对于一个长度为 4 的哈希数组，我们可以将关键字 模 4 得到哈希值，如图所示：<br/> <img alt="" src="image\20210119200007902.png"/></p>
<h4><a id="5_418"></a>5、位与法</h4>
<p>  哈希数组的长度一般选择 2 的幂，因为我们知道取模运算是比较耗时的，而位运算相对较为高效。<br/>   选择 2 的幂作为数组长度，可以将 取模运算 转换成 二进制位与。<br/>   令 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        m
       
       
        =
       
       
        
         2
        
        
         k
        
       
      
      
       m = 2^k
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.849108em; vertical-align: 0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.849108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span></span>，那么它的二进制表示就是：<span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml">
     
      
       
        
         m
        
        
         =
        
        
         (
        
        
         1
        
        
         
          
           000...000
          
          
           ⏟
          
         
         
          k
         
        
        
         
          )
         
         
          2
         
        
       
       
        m = (1\underbrace{000...000}_{\rm k})_2
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 2.08411em; vertical-align: -1.33411em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord munder"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.64444em;"><span class="" style="top: -1.66589em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight">k</span></span></span></span></span><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord munder"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.64444em;"><span class="svg-align" style="top: -2.352em;"><span class="pstrut" style="height: 3em;"></span><span class="stretchy" style="height: 0.548em; min-width: 1.6em;"><span class="brace-left" style="height: 0.548em;">
<svg height="0.548em" preserveaspectratio="xMinYMin slice" viewbox="0 0 400000 548" width="400em">
<path d="M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13
 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688
 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7
-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z"></path>
</svg></span><span class="brace-center" style="height: 0.548em;">
<svg height="0.548em" preserveaspectratio="xMidYMin slice" viewbox="0 0 400000 548" width="400em">
<path d="M199572 214
c100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14
 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3
 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0
-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z"></path>
</svg></span><span class="brace-right" style="height: 0.548em;">
<svg height="0.548em" preserveaspectratio="xMaxYMin slice" viewbox="0 0 400000 548" width="400em">
<path d="M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3
 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237
-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z"></path>
</svg></span></span></span><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.648em;"><span class=""></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.33411em;"><span class=""></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span></span>，任何一个数模上 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        m
       
      
      
       m
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">m</span></span></span></span></span>，就相当于取了 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        m
       
      
      
       m
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">m</span></span></span></span></span> 的二进制低 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        k
       
      
      
       k
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span></span></span></span></span> 位，而 <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml">
     
      
       
        
         m
        
        
         −
        
        
         1
        
        
         =
        
        
         (
        
        
         
          
           111...111
          
          
           ⏟
          
         
         
          k
         
        
        
         
          )
         
         
          2
         
        
       
       
        m-1 = (\underbrace{111...111}_{\rm k})_2
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.66666em; vertical-align: -0.08333em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 2.08411em; vertical-align: -1.33411em;"></span><span class="mopen">(</span><span class="mord munder"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.64444em;"><span class="" style="top: -1.66589em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight">k</span></span></span></span></span><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord munder"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.64444em;"><span class="svg-align" style="top: -2.352em;"><span class="pstrut" style="height: 3em;"></span><span class="stretchy" style="height: 0.548em; min-width: 1.6em;"><span class="brace-left" style="height: 0.548em;">
<svg height="0.548em" preserveaspectratio="xMinYMin slice" viewbox="0 0 400000 548" width="400em">
<path d="M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13
 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688
 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7
-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z"></path>
</svg></span><span class="brace-center" style="height: 0.548em;">
<svg height="0.548em" preserveaspectratio="xMidYMin slice" viewbox="0 0 400000 548" width="400em">
<path d="M199572 214
c100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14
 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3
 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0
-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z"></path>
</svg></span><span class="brace-right" style="height: 0.548em;">
<svg height="0.548em" preserveaspectratio="xMaxYMin slice" viewbox="0 0 400000 548" width="400em">
<path d="M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3
 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237
-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z"></path>
</svg></span></span></span><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.648em;"><span class=""></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.33411em;"><span class=""></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span></span> ，所以和 位与 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        m
       
       
        −
       
       
        1
       
      
      
       m-1
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.66666em; vertical-align: -0.08333em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span></span></span></span></span> 的效果是一样的。即：<span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml">
     
      
       
        
         x
        
        
          
        
        
         %
        
        
          
        
        
         S
        
        
         =
        
        
         =
        
        
         x
        
        
          
        
        
         &amp;
        
        
          
        
        
         (
        
        
         S
        
        
         −
        
        
         1
        
        
         )
        
       
       
        x \ \% \ S == x \ \&amp; \ (S - 1)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.80556em; vertical-align: -0.05556em;"></span><span class="mord mathdefault">x</span><span class="mspace"> </span><span class="mord">%</span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right: 0.05764em;">S</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height: 0.36687em; vertical-align: 0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">x</span><span class="mspace"> </span><span class="mord">&amp;</span><span class="mspace"> </span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.05764em;">S</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></span>  除了直接定址法，其它三种方法都有可能导致哈希冲突，接下来，我们就来讨论下常用的一些哈希冲突的解决方案。</p>
<h3><a id="_422"></a>三、常见哈希冲突解决方案</h3>
<h4><a id="1_423"></a>1、开放定址法</h4>
<h5><a id="1_424"></a>1）原理讲解</h5>
<p>  <strong>开放定址法</strong> 就是一旦发生冲突，就去寻找下一个空的地址，只要哈希表足够大，总能找到一个空的位置，并且记录下来作为它的 <strong>哈希地址</strong>。公式如下：<span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml">
     
      
       
        
         
          f
         
         
          i
         
        
        
         (
        
        
         x
        
        
         )
        
        
         =
        
        
         (
        
        
         f
        
        
         (
        
        
         x
        
        
         )
        
        
         +
        
        
         
          d
         
         
          i
         
        
        
         )
        
        
          
        
        
         m
        
        
         o
        
        
         d
        
        
          
        
        
         m
        
       
       
        f_i(x) = (f(x)+d_i) \ mod \ m
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: -0.10764em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace"> </span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace"> </span><span class="mord mathdefault">m</span></span></span></span></span></span><br/>   这里的 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         d
        
        
         i
        
       
      
      
       d_i
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.84444em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 是一个数列，可以是常数列 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        (
       
       
        1
       
       
        ,
       
       
        1
       
       
        ,
       
       
        1
       
       
        ,
       
       
        .
       
       
        .
       
       
        .
       
       
        ,
       
       
        1
       
       
        )
       
      
      
       (1, 1, 1, ...,1)
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>，也可以是等差数列<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        (
       
       
        1
       
       
        ,
       
       
        2
       
       
        ,
       
       
        3
       
       
        ,
       
       
        .
       
       
        .
       
       
        .
       
       
        ,
       
       
        m
       
       
        −
       
       
        1
       
       
        )
       
      
      
       (1,2,3,...,m-1)
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>。</p>
<h5><a id="2_427"></a>2）动画演示</h5>
<p><img alt="" src="https://img-blog.csdnimg.cn/f07feb636e904adf814afb2f1eede981.gif#pic_center"/></p>
<blockquote>
<p>  上图中，采用的是哈希函数算法是 <strong>除留余数法</strong>，采用的哈希冲突解决方案是 <strong>开放定址法</strong>，哈希表的每个数据就是一个关键字，插入之前需要先进行查找，如果找到的位置未被插入，则执行插入；否则，找到下一个未被插入的位置进行插入；总共插入了 6 个数据，分别为：11、12、13、20、19、28。<br/>  这种方法需要注意的是，当插入数据超过哈希表长度时，不能再执行插入。</p>
</blockquote>
<p>  本文在第四章讲解 哈希表的现实 时采用的就是常数列的开放定址法。</p>
<h4><a id="2_432"></a>2、再散列函数法</h4>
<h5><a id="1_433"></a>1）原理讲解</h5>
<p>  <strong>再散列函数法</strong> 就是一旦发生冲突，就采用另一个哈希函数，可以是 平方取中法、折叠法、除留余数法 等等的组合，一般用两个哈希函数，产生冲突的概率已经微乎其微了。<br/>  <strong>再散列函数法</strong> 能够使关键字不产生聚集，当然，也会增加不少哈希函数的计算时间。</p>
<h4><a id="3_435"></a>3、链地址法</h4>
<h5><a id="1_436"></a>1）原理讲解</h5>
<p>  当然，产生冲突后，我们也可以选择不换位置，还是在原来的位置，只是把 <strong>哈希值</strong> 相同的用链表串联起来。这种方法被称为 <strong>链地址法</strong>。</p>
<h5><a id="2_438"></a>2）动画演示</h5>
<p><img alt="" src="https://img-blog.csdnimg.cn/3f3079ffb2404a89bf64cf9bdadb8153.gif#pic_center"/></p>
<blockquote>
<p>  上图中，采用的是哈希函数算法是 <strong>除留余数法</strong>，采用的哈希冲突解决方案是 <strong>链地址法</strong>，哈希表的每个数据保留了一个 <strong>链表头结点</strong> 和 <strong>尾结点</strong>，插入之前需要先进行查找，如果找到的位置，链表非空，则插入尾结点并且更新尾结点；否则，生成一个新的链表头结点和尾结点；总共插入了 6 个数据，分别为：11、12、13、20、19、28。</p>
</blockquote>
<h4><a id="4_441"></a>4、公共溢出区法</h4>
<h5><a id="1_442"></a>1）原理讲解</h5>
<p>  一旦产生冲突的数据，统一放到另外一个顺序表中，每次查找数据，在哈希数组中到的关键字和给定关键字相等，则认为查找成功；否则，就去公共溢出区顺序查找，这种方法被称为 <strong>公共溢出区法</strong>。<br/>   这种方法适合冲突较少的情况。<br/>   哈希表相关的内容，可以参考我的这篇文章：<a href="https://blog.csdn.net/WhereIsHeroFrom/article/details/112756337">夜深人静写算法（九）- 哈希表</a></p>
<hr/>
<h2><a id="4_448"></a>4、队列</h2>
<blockquote>
<p><strong>内存结构</strong>：看用数组实现，还是链表实现<br/><strong>实现难度</strong>：一般<br/><strong>下标访问</strong>：不支持<br/><strong>分类</strong>：FIFO、单调队列、双端队列<br/><strong>插入时间复杂度</strong>：<span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         O
        
        
         (
        
        
         1
        
        
         )
        
       
       
        O(1)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span><br/><strong>查找时间复杂度</strong>：理论上不支持<br/><strong>删除时间复杂度</strong>：<span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         O
        
        
         (
        
        
         1
        
        
         )
        
       
       
        O(1)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></p>
</blockquote>
<h3><a id="_451"></a>一、概念</h3>
<h4><a id="1_452"></a>1、队列的定义</h4>
<p>  <strong>队列</strong> 是仅限在 <strong>一端</strong> 进行 <strong>插入</strong>，<strong>另一端</strong> 进行 <strong>删除</strong> 的 <strong>线性表</strong>。<br/>   <strong>队列</strong> 又被称为 先进先出 （First In First Out） 的线性表，简称 FIFO 。<br/> <img alt="" src="image\320013ec60b94cb9b8e5fa7b9343d0e4.png"/></p>
<h4><a id="2_456"></a>2、队首</h4>
<p>  允许进行元素删除的一端称为 <strong>队首</strong>。如下图所示：<br/> <img alt="" src="image\797118422c9c43729915004c2b03e8c8.png"/></p>
<h4><a id="3_460"></a>3、队尾</h4>
<p>  允许进行元素插入的一端称为 <strong>队尾</strong>。如下图所示：<br/> <img alt="" src="image\6d2e9994c21144c28d3eee007f3fecfb.png"/></p>
<h3><a id="_463"></a>二、接口</h3>
<h4><a id="1_464"></a>1、数据入队</h4>
<p>  队列的插入操作，叫做 <strong>入队</strong>。它是将 <strong>数据元素</strong> 从 <strong>队尾</strong> 进行插入的过程，如图所示，表示的是 <strong>插入</strong> 两个数据（绿色 和 蓝色）的过程：<br/> <img alt="" src="https://img-blog.csdnimg.cn/cef3932334b14063b41d8efcf363c51f.gif#pic_center"/></p>
<h4><a id="2_467"></a>2、数据出队</h4>
<p>  队列的删除操作，叫做 <strong>出队</strong>。它是将 <strong>队首</strong> 元素进行删除的过程，如图所示，表示的是 依次 <strong>删除</strong> 两个数据（红色 和 橙色）的过程：<br/> <img alt="" src="https://img-blog.csdnimg.cn/ee4bfda682f54a5688b2c6a7c31c709c.gif#pic_center"/></p>
<h4><a id="3_471"></a>3、清空队列</h4>
<p>  队列的清空操作，就是一直 <strong>出队</strong>，直到队列为空的过程，当 <strong>队首</strong> 和 <strong>队尾</strong> 重合时，就代表队尾为空了，如图所示：<br/> <img alt="" src="https://img-blog.csdnimg.cn/bb6b16d141c7465699c21ac703f39a13.gif#pic_center"/></p>
<h4><a id="4_475"></a>4、获取队首数据</h4>
<p>  对于一个队列来说只能获取 <strong>队首</strong> 数据，一般不支持获取 其它数据。</p>
<h4><a id="5_477"></a>5、获取队列元素个数</h4>
<p>  队列元素个数一般用一个额外变量存储，<strong>入队</strong> 时加一，<strong>出队</strong> 时减一。这样获取队列元素的时候就不需要遍历整个队列。通过 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        O
       
       
        (
       
       
        1
       
       
        )
       
      
      
       O(1)
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span> 的时间复杂度获取队列元素个数。</p>
<h4><a id="6_479"></a>6、队列的判空</h4>
<p>  当队列元素个数为零时，就是一个 <strong>空队</strong>，<strong>空队</strong> 不允许 <strong>出队</strong> 操作。<br/>   有关队列的更多内容，可以参考我的这篇文章：<a href="https://blog.csdn.net/WhereIsHeroFrom/article/details/118987839">《画解数据结构》（1 - 6）- 队列</a></p>
<hr/>
<h2><a id="5_485"></a>5、栈</h2>
<blockquote>
<p><strong>内存结构</strong>：看用数组实现，还是链表实现<br/><strong>实现难度</strong>：一般<br/><strong>下标访问</strong>：不支持<br/><strong>分类</strong>：FILO、单调栈<br/><strong>插入时间复杂度</strong>：<span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         O
        
        
         (
        
        
         1
        
        
         )
        
       
       
        O(1)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span><br/><strong>查找时间复杂度</strong>：理论上不支持<br/><strong>删除时间复杂度</strong>：<span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         O
        
        
         (
        
        
         1
        
        
         )
        
       
       
        O(1)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></p>
</blockquote>
<h3><a id="_488"></a>一、概念</h3>
<h4><a id="1_489"></a>1、栈的定义</h4>
<p>  <strong>栈</strong> 是仅限在 <strong>表尾</strong> 进行 <strong>插入</strong> 和 <strong>删除</strong> 的 <strong>线性表</strong>。<br/>   <strong>栈</strong> 又被称为 后进先出 （Last In First Out） 的线性表，简称 LIFO 。</p>
<h4><a id="2_492"></a>2、栈顶</h4>
<p>  <strong>栈</strong> 是一个线性表，我们把允许 <strong>插入</strong> 和 <strong>删除</strong> 的一端称为 <strong>栈顶</strong>。<br/> <img alt="" src="image\54942d9da9714b02b972cc870fd57694.png"/></p>
<h4><a id="3_496"></a>3、栈底</h4>
<p>  和 <strong>栈顶</strong> 相对，另一端称为 <strong>栈底</strong>，实际上，栈底的元素我们不需要关心。<br/> <img alt="" src="image\6701aaa3d4e444f5b902f46fa4096b20.png"/></p>
<h3><a id="_500"></a>二、接口</h3>
<h4><a id="1_501"></a>1、数据入栈</h4>
<p>  栈的插入操作，叫做 <strong>入栈</strong>，也可称为 进栈、压栈。如下图所示，代表了三次入栈操作：<br/> <img alt="" src="https://img-blog.csdnimg.cn/367302f0d91d46a5bea0b52d328dbdd3.gif#pic_center"/></p>
<h4><a id="2_505"></a>2、数据出栈</h4>
<p>  栈的删除操作，叫做 <strong>出栈</strong>，也可称为 弹栈。如下图所示，代表了两次出栈操作：<br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/33f7388fb4f146bf83d6bf7316b2d3a8.gif#pic_center"/></p>
<h4><a id="3_509"></a>3、清空栈</h4>
<p>  一直 <strong>出栈</strong>，直到栈为空，如下图所示：<br/> <img alt="" src="https://img-blog.csdnimg.cn/5a150fb4006a4e919bfc661584f20ec1.gif#pic_center"/></p>
<h4><a id="1_513"></a>1、获取栈顶数据</h4>
<p>  对于一个栈来说只能获取 <strong>栈顶</strong> 数据，一般不支持获取 其它数据。</p>
<h4><a id="2_515"></a>2、获取栈元素个数</h4>
<p>  栈元素个数一般用一个额外变量存储，<strong>入栈</strong> 时加一，<strong>出栈</strong> 时减一。这样获取栈元素的时候就不需要遍历整个栈。通过 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        O
       
       
        (
       
       
        1
       
       
        )
       
      
      
       O(1)
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span> 的时间复杂度获取栈元素个数。</p>
<h4><a id="3_517"></a>3、栈的判空</h4>
<p>  当栈元素个数为零时，就是一个空栈，空栈不允许 <strong>出栈</strong> 操作。<br/>   栈相关的内容，可以参考我的这篇文章：<a href="https://blog.csdn.net/WhereIsHeroFrom/article/details/118987801">《画解数据结构》（1 - 5）- 栈</a></p>
<hr/>
<h2><a id="7_522"></a>🌵7、二叉树</h2>
<blockquote>
<p>优先队列 是 堆实现的，所以也属于 二叉树 范畴。它和队列不同，不属于线性表。<br/> <strong>内存结构</strong>：内存结构一般不连续，但是有时候实现的时候，为了方便，一般是物理连续，逻辑不连续<br/><strong>实现难度</strong>：较难<br/><strong>下标访问</strong>：不支持<br/><strong>分类</strong>：二叉树 和 多叉树<br/><strong>插入时间复杂度</strong>：看情况而定<br/><strong>查找时间复杂度</strong>：理论上 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         O
        
        
         (
        
        
         l
        
        
         o
        
        
         
          g
         
         
          2
         
        
        
         n
        
        
         )
        
       
       
        O(log_2n)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span><br/><strong>删除时间复杂度</strong>：看情况而定</p>
</blockquote>
<h2><a id="8_525"></a>🌳8、多叉树</h2>
<blockquote>
<p><strong>内存结构</strong>：内存结构一般不连续，但是有时候实现的时候，为了方便，一般是物理连续，逻辑不连续<br/><strong>实现难度</strong>：较难<br/><strong>下标访问</strong>：不支持<br/><strong>分类</strong>：二叉树 和 多叉树<br/><strong>插入时间复杂度</strong>：看情况而定<br/><strong>查找时间复杂度</strong>：理论上 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         O
        
        
         (
        
        
         l
        
        
         o
        
        
         
          g
         
         
          2
         
        
        
         n
        
        
         )
        
       
       
        O(log_2n)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span><br/><strong>删除时间复杂度</strong>：看情况而定</p>
</blockquote>
<ul><li>一种经典的多叉树是字典树，可以参考我的这篇文章：</li><li><a href="https://blog.csdn.net/WhereIsHeroFrom/article/details/112271312">夜深人静写算法（七）- 字典树</a></li></ul>
<h2><a id="9_529"></a>🌲9、森林</h2>
<ul><li>比较经典的森林是：并查集，可以参考我的这篇文章：</li><li><a href="https://blog.csdn.net/WhereIsHeroFrom/article/details/111879216">夜深人静写算法（五）- 并查集</a></li></ul>
<h2><a id="10_532"></a>🍀10、树状数组</h2>
<ul><li>树状数组是用来做 单点更新，成端求和 的问题的，有关于它的内容，可以参考：</li><li><a href="https://blog.csdn.net/WhereIsHeroFrom/article/details/113598114">夜深人静写算法（十三）- 树状数组</a></li></ul>
<h2><a id="11_535"></a>🌍11、图</h2>
<blockquote>
<p><strong>内存结构</strong>：不一定<br/><strong>实现难度</strong>：难<br/><strong>下标访问</strong>：不支持<br/><strong>分类</strong>：有向图、无向图<br/><strong>插入时间复杂度</strong>：根据算法而定<br/><strong>查找时间复杂度</strong>：根据算法而定<br/><strong>删除时间复杂度</strong>：根据算法而定</p>
</blockquote>
<p><strong>1、图的概念</strong></p>
<ul><li>在讲解最短路问题之前，首先需要介绍一下计算机中图（图论）的概念，如下：</li><li>图 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         G
        
       
       
        G
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault">G</span></span></span></span></span> 是一个有序二元组 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         V
        
        
         ,
        
        
         E
        
        
         )
        
       
       
        (V,E)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.05764em;">E</span><span class="mclose">)</span></span></span></span></span>，其中 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         V
        
       
       
        V
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.22222em;">V</span></span></span></span></span> 称为顶点集合，<span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         E
        
       
       
        E
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.05764em;">E</span></span></span></span></span> 称为边集合，<span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         E
        
       
       
        E
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.05764em;">E</span></span></span></span></span> 与 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         V
        
       
       
        V
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.22222em;">V</span></span></span></span></span> 不相交。顶点集合的元素被称为顶点，边集合的元素被称为边。</li><li>对于无权图，边由二元组 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         u
        
        
         ,
        
        
         v
        
        
         )
        
       
       
        (u,v)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span><span class="mclose">)</span></span></span></span></span> 表示，其中 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         u
        
        
         ,
        
        
         v
        
        
         ∈
        
        
         V
        
       
       
        u, v \in V
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.73354em; vertical-align: -0.19444em;"></span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.22222em;">V</span></span></span></span></span>。对于带权图，边由三元组 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         u
        
        
         ,
        
        
         v
        
        
         ,
        
        
         w
        
        
         )
        
       
       
        (u,v, w)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.02691em;">w</span><span class="mclose">)</span></span></span></span></span> 表示，其中 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         u
        
        
         ,
        
        
         v
        
        
         ∈
        
        
         V
        
       
       
        u, v \in V
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.73354em; vertical-align: -0.19444em;"></span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.22222em;">V</span></span></span></span></span>，<span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         w
        
       
       
        w
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.02691em;">w</span></span></span></span></span> 为权值，可以是任意类型。</li><li>图分为有向图和无向图，对于有向图， <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         u
        
        
         ,
        
        
         v
        
        
         )
        
       
       
        (u, v)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span><span class="mclose">)</span></span></span></span></span> 表示的是 从顶点 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         u
        
       
       
        u
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">u</span></span></span></span></span> 到 顶点 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         v
        
       
       
        v
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span></span></span></span></span> 的边，即 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         u
        
        
         →
        
        
         v
        
       
       
        u \to v
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">u</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span></span></span></span></span>；对于无向图，<span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         u
        
        
         ,
        
        
         v
        
        
         )
        
       
       
        (u, v)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span><span class="mclose">)</span></span></span></span></span> 可以理解成两条边，一条是 从顶点 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         u
        
       
       
        u
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">u</span></span></span></span></span> 到 顶点 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         v
        
       
       
        v
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span></span></span></span></span> 的边，即 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         u
        
        
         →
        
        
         v
        
       
       
        u \to v
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">u</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span></span></span></span></span>，另一条是从顶点 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         v
        
       
       
        v
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span></span></span></span></span> 到 顶点 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         u
        
       
       
        u
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">u</span></span></span></span></span> 的边，即 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         v
        
        
         →
        
        
         u
        
       
       
        v \to u
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">u</span></span></span></span></span>；</li></ul>
<p><strong>2、图的存储</strong></p>
<ul><li>对于图的存储，程序实现上也有多种方案，根据不同情况采用不同的方案。接下来以图二-3-1所表示的图为例，讲解四种存储图的方案。<br/> <img alt="" src="image\584bbd302f8b72da458c1550428320a5.png"/></li></ul>
<p><strong>1）邻接矩阵</strong></p>
<ul><li>邻接矩阵是直接利用一个二维数组对边的关系进行存储，矩阵的第 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         i
        
       
       
        i
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.65952em; vertical-align: 0em;"></span><span class="mord mathdefault">i</span></span></span></span></span> 行第 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         j
        
       
       
        j
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.85396em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.05724em;">j</span></span></span></span></span> 列的值 表示 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         i
        
        
         →
        
        
         j
        
       
       
        i \to j
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.65952em; vertical-align: 0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.85396em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.05724em;">j</span></span></span></span></span> 这条边的权值；特殊的，如果不存在这条边，用一个特殊标记 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         ∞
        
       
       
        \infty
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord">∞</span></span></span></span></span> 来表示；如果 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         i
        
        
         =
        
        
         j
        
       
       
        i = j
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.65952em; vertical-align: 0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.85396em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.05724em;">j</span></span></span></span></span>，则权值为 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         0
        
       
       
        0
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">0</span></span></span></span></span>。</li><li>它的优点是：实现非常简单，而且很容易理解；缺点也很明显，如果这个图是一个非常稀疏的图，图中边很少，但是点很多，就会造成非常大的内存浪费，点数过大的时候根本就无法存储。</li><li><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml">
      
       
        
         
          [
         
         
          
           
            
             
              0
             
            
           
           
            
             
              ∞
             
            
           
           
            
             
              3
             
            
           
           
            
             
              ∞
             
            
           
          
          
           
            
             
              1
             
            
           
           
            
             
              0
             
            
           
           
            
             
              2
             
            
           
           
            
             
              ∞
             
            
           
          
          
           
            
             
              ∞
             
            
           
           
            
             
              ∞
             
            
           
           
            
             
              0
             
            
           
           
            
             
              3
             
            
           
          
          
           
            
             
              9
             
            
           
           
            
             
              8
             
            
           
           
            
             
              ∞
             
            
           
           
            
             
              0
             
            
           
          
         
         
          ]
         
        
        
         \left[ \begin{matrix} 0 &amp; \infty &amp; 3 &amp; \infty \\ 1 &amp; 0 &amp; 2 &amp; \infty \\ \infty &amp; \infty &amp; 0 &amp; 3 \\ 9 &amp; 8 &amp; \infty &amp; 0 \end{matrix} \right]
        
       
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 4.80204em; vertical-align: -2.15003em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 2.65201em;"><span class="" style="top: -1.64999em;"><span class="pstrut" style="height: 3.155em;"></span><span class="delimsizinginner delim-size4"><span class="">⎣</span></span></span><span class="" style="top: -2.80499em;"><span class="pstrut" style="height: 3.155em;"></span><span class="delimsizinginner delim-size4"><span class="">⎢</span></span></span><span class="" style="top: -3.40599em;"><span class="pstrut" style="height: 3.155em;"></span><span class="delimsizinginner delim-size4"><span class="">⎢</span></span></span><span class="" style="top: -4.65201em;"><span class="pstrut" style="height: 3.155em;"></span><span class="delimsizinginner delim-size4"><span class="">⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 2.15003em;"><span class=""></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 2.65em;"><span class="" style="top: -4.81em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">0</span></span></span><span class="" style="top: -3.61em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">1</span></span></span><span class="" style="top: -2.41em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">∞</span></span></span><span class="" style="top: -1.21em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">9</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 2.15em;"><span class=""></span></span></span></span></span><span class="arraycolsep" style="width: 0.5em;"></span><span class="arraycolsep" style="width: 0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 2.65em;"><span class="" style="top: -4.81em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">∞</span></span></span><span class="" style="top: -3.61em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">0</span></span></span><span class="" style="top: -2.41em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">∞</span></span></span><span class="" style="top: -1.21em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">8</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 2.15em;"><span class=""></span></span></span></span></span><span class="arraycolsep" style="width: 0.5em;"></span><span class="arraycolsep" style="width: 0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 2.65em;"><span class="" style="top: -4.81em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">3</span></span></span><span class="" style="top: -3.61em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">2</span></span></span><span class="" style="top: -2.41em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">0</span></span></span><span class="" style="top: -1.21em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">∞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 2.15em;"><span class=""></span></span></span></span></span><span class="arraycolsep" style="width: 0.5em;"></span><span class="arraycolsep" style="width: 0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 2.65em;"><span class="" style="top: -4.81em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">∞</span></span></span><span class="" style="top: -3.61em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">∞</span></span></span><span class="" style="top: -2.41em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">3</span></span></span><span class="" style="top: -1.21em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 2.15em;"><span class=""></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 2.65201em;"><span class="" style="top: -1.64999em;"><span class="pstrut" style="height: 3.155em;"></span><span class="delimsizinginner delim-size4"><span class="">⎦</span></span></span><span class="" style="top: -2.80499em;"><span class="pstrut" style="height: 3.155em;"></span><span class="delimsizinginner delim-size4"><span class="">⎥</span></span></span><span class="" style="top: -3.40599em;"><span class="pstrut" style="height: 3.155em;"></span><span class="delimsizinginner delim-size4"><span class="">⎥</span></span></span><span class="" style="top: -4.65201em;"><span class="pstrut" style="height: 3.155em;"></span><span class="delimsizinginner delim-size4"><span class="">⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 2.15003em;"><span class=""></span></span></span></span></span></span></span></span></span></span></span></span></li></ul>
<p><strong>2）邻接表</strong></p>
<ul><li>邻接表是图中常用的存储结构之一，采用链表来存储，每个顶点都有一个链表，链表的数据表示和当前顶点直接相邻的顶点的数据<span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         v
        
        
         ,
        
        
         w
        
        
         )
        
       
       
        (v, w)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.02691em;">w</span><span class="mclose">)</span></span></span></span></span>，即 顶点 和 边权。</li><li>它的优点是：对于稀疏图不会有数据浪费；缺点就是实现相对邻接矩阵来说较麻烦，需要自己实现链表，动态分配内存。</li><li>如图所示，<span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         d
        
        
         a
        
        
         t
        
        
         a
        
       
       
        data
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span></span></span></span></span> 即 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         v
        
        
         ,
        
        
         w
        
        
         )
        
       
       
        (v, w)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.02691em;">w</span><span class="mclose">)</span></span></span></span></span> 二元组，代表和对应顶点 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         u
        
       
       
        u
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">u</span></span></span></span></span> 直接相连的顶点数据，<span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         w
        
       
       
        w
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.02691em;">w</span></span></span></span></span> 代表 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         u
        
        
         →
        
        
         v
        
       
       
        u \to v
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">u</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span></span></span></span></span> 的边权，<span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         n
        
        
         e
        
        
         x
        
        
         t
        
       
       
        next
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.61508em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">t</span></span></span></span></span> 是一个指针，指向下一个 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         v
        
        
         ,
        
        
         w
        
        
         )
        
       
       
        (v, w)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.02691em;">w</span><span class="mclose">)</span></span></span></span></span> 二元组。<br/> <img alt="" src="image\438a1d31420a69b16be0c0bde0ce6f64.png"/></li><li>在 C++ 中，还可以使用 vector 这个容器来代替链表的功能；</li></ul>
<pre><code class="prism language-cpp">    vector<span class="token operator">&lt;</span>Edge<span class="token operator">&gt;</span> edges<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre>
<p><strong>3）前向星</strong></p>
<ul><li>前向星是以存储边的方式来存储图，先将边读入并存储在连续的数组中，然后按照边的起点进行排序，这样数组中起点相等的边就能够在数组中进行连续访问了。</li><li>它的优点是实现简单，容易理解；缺点是需要在所有边都读入完毕的情况下对所有边进行一次排序，带来了时间开销，实用性也较差，只适合离线算法。</li><li>如图所示，表示的是三元组 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         u
        
        
         ,
        
        
         v
        
        
         ,
        
        
         w
        
        
         )
        
       
       
        (u, v, w)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.02691em;">w</span><span class="mclose">)</span></span></span></span></span> 的数组，<span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         i
        
        
         d
        
        
         x
        
       
       
        idx
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord mathdefault">x</span></span></span></span></span> 代表数组下标。<br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/img_convert/5487f324d41081c38a8fcf509685743b.png#pic_center"/></li><li>那么用哪种数据结构才能满足所有图的需求呢？</li><li>接下来介绍一种新的数据结构 —— 链式前向星。</li></ul>
<p><strong>4）链式前向星</strong></p>
<ul><li>链式前向星和邻接表类似，也是链式结构和数组结构的结合，每个结点 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         i
        
       
       
        i
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.65952em; vertical-align: 0em;"></span><span class="mord mathdefault">i</span></span></span></span></span> 都有一个链表，链表的所有数据是从 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         i
        
       
       
        i
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.65952em; vertical-align: 0em;"></span><span class="mord mathdefault">i</span></span></span></span></span> 出发的所有边的集合（对比邻接表存的是顶点集合），边的表示为一个四元组 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         u
        
        
         ,
        
        
         v
        
        
         ,
        
        
         w
        
        
         ,
        
        
         n
        
        
         e
        
        
         x
        
        
         t
        
        
         )
        
       
       
        (u, v, w, next)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">t</span><span class="mclose">)</span></span></span></span></span>，其中 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         u
        
        
         ,
        
        
         v
        
        
         )
        
       
       
        (u, v)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span><span class="mclose">)</span></span></span></span></span> 代表该条边的有向顶点对 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         u
        
        
         →
        
        
         v
        
       
       
        u \to v
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">u</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span></span></span></span></span>，<span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         w
        
       
       
        w
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.02691em;">w</span></span></span></span></span> 代表边上的权值，<span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         n
        
        
         e
        
        
         x
        
        
         t
        
       
       
        next
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.61508em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">t</span></span></span></span></span> 指向下一条边。</li><li>具体的，我们需要一个边的结构体数组 <code>edge[maxm]</code>，<code>maxm</code>表示边的总数，所有边都存储在这个结构体数组中，并且用<code>head[i]</code>来指向 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         i
        
       
       
        i
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.65952em; vertical-align: 0em;"></span><span class="mord mathdefault">i</span></span></span></span></span> 结点的第一条边。</li><li>边的结构体声明如下：</li></ul>
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Edge</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> u<span class="token punctuation">,</span> v<span class="token punctuation">,</span> w<span class="token punctuation">,</span> next<span class="token punctuation">;</span>
    <span class="token function">Edge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
    <span class="token function">Edge</span><span class="token punctuation">(</span><span class="token keyword">int</span> _u<span class="token punctuation">,</span> <span class="token keyword">int</span> _v<span class="token punctuation">,</span> <span class="token keyword">int</span> _w<span class="token punctuation">,</span> <span class="token keyword">int</span> _next<span class="token punctuation">)</span> <span class="token operator">:</span>
        <span class="token function">u</span><span class="token punctuation">(</span>_u<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">v</span><span class="token punctuation">(</span>_v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">w</span><span class="token punctuation">(</span>_w<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">next</span><span class="token punctuation">(</span>_next<span class="token punctuation">)</span> 
    <span class="token punctuation">{<!-- --></span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>edge<span class="token punctuation">[</span>maxm<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre>
<ul><li>初始化所有的<code>head[i] = -1</code>，当前边总数 <code>edgeCount = 0</code>；</li><li>每读入一条 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         u
        
        
         →
        
        
         v
        
       
       
        u \to v
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">u</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span></span></span></span></span> 的边，调用 <code>addEdge(u, v, w)</code>，具体函数的实现如下：</li></ul>
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">addEdge</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">,</span> <span class="token keyword">int</span> w<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    edge<span class="token punctuation">[</span>edgeCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">Edge</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">,</span> w<span class="token punctuation">,</span> head<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    head<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> edgeCount<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<ul><li>这个函数的含义是每加入一条边 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         u
        
        
         ,
        
        
         v
        
        
         ,
        
        
         w
        
        
         )
        
       
       
        (u, v, w)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.02691em;">w</span><span class="mclose">)</span></span></span></span></span>，就在原有的链表结构的首部插入这条边，使得每次插入的时间复杂度为 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         O
        
        
         (
        
        
         1
        
        
         )
        
       
       
        O(1)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>，所以链表的边的顺序和读入顺序正好是逆序的。这种结构在无论是稠密的还是稀疏的图上都有非常好的表现，空间上没有浪费，时间上也是最小开销。</li><li>调用的时候只要通过<code>head[i]</code>就能访问到由 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         i
        
       
       
        i
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.65952em; vertical-align: 0em;"></span><span class="mord mathdefault">i</span></span></span></span></span> 出发的第一条边的编号，通过编号到<code>edge</code>数组进行索引可以得到边的具体信息，然后根据这条边的<code>next</code>域可以得到第二条边的编号，以此类推，直到 <code>next</code>域为 -1 为止。</li></ul>
<pre><code class="prism language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> e <span class="token operator">=</span> head<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">~</span>e<span class="token punctuation">;</span> e <span class="token operator">=</span> edges<span class="token punctuation">[</span>e<span class="token punctuation">]</span><span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> v <span class="token operator">=</span> edges<span class="token punctuation">[</span>e<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">;</span>
    ValueType w <span class="token operator">=</span> edges<span class="token punctuation">[</span>e<span class="token punctuation">]</span><span class="token punctuation">.</span>w<span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre>
<ul><li>文中的 <code>~e</code>等价于 <code>e != -1</code>，是对<code>e</code>进行二进制取反的操作（-1 的的补码二进制全是 1，取反后变成全 0，这样就使得条件不满足跳出循环）。</li></ul>
<hr/>
<h1><a id="_606"></a>三、四个入门算法</h1>
<h2><a id="1_607"></a>1、排序</h2>
<ul><li>一般网上的文章在讲各种 <font color="0000ff"><b>「 排序 」</b></font> 算法的时候，都会甩出一张 <font color="f25605"><b>「 思维导图 」</b></font>，如下：</li></ul>
<p><img alt="" src="image\996c4e25fd5449439b528598e4109432.png"/></p>
<ul><li>当然，我也不例外……</li><li>这些概念也不用多说，只要你能够把<font color="13ae01"><b>「 快速排序 」</b></font>的思想理解了。基本上其它算法的思想也都能学会。这个思路就是经典的：<font color="2290ff"><b>「 要学就学最难的，其它肯定能学会 」</b></font>。因为当你连<font color="FFD700"><b>「 最难的 」</b></font>都已经 <font color="fe00ff"><b>「 KO 」</b></font> 了，其它的还不是<font color="f7803b"><b>「 小菜一碟 」</b></font>？信心自然就来了。</li><li>我们要战胜的其实不是<font color="13ae01"><b>「 算法 」</b></font>本身，而是我们对 <font color="13ae01"><b>「 算法 」</b></font> 的恐惧。一旦建立起<font color="blue"><b>「 自信心 」</b></font>，后面的事情，就<font color="2290ff"><b>「 水到渠成 」</b></font>了。</li><li>然而，实际情况比这可要简单得多。实际在上机刷题的过程中，不可能让你手写一个排序，你只需要知道 C++ 中 STL 的 sort 函数就够了，它的底层就是由【快速排序】实现的。</li><li>所有的排序题都可以做。我挑一个来说。至于上面说到的那十个排序算法，如果有缘，我会在八月份的这个专栏 <a href="https://blog.csdn.net/whereisherofrom/category_11227297.html">❤️<font color="e81224"><b><u>《画解数据结构》导航 </u></b></font>❤️</a> 中更新，尽情期待~~</li></ul>
<p><strong>I、例题描述</strong></p>
<blockquote>
<p>  给你两个有序整数数组 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         n
        
        
         u
        
        
         m
        
        
         s
        
        
         1
        
       
       
        nums1
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">1</span></span></span></span></span> 和 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         n
        
        
         u
        
        
         m
        
        
         s
        
        
         2
        
       
       
        nums2
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">2</span></span></span></span></span>，请你将 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         n
        
        
         u
        
        
         m
        
        
         s
        
        
         2
        
       
       
        nums2
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">2</span></span></span></span></span> 合并到 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         n
        
        
         u
        
        
         m
        
        
         s
        
        
         1
        
       
       
        nums1
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">1</span></span></span></span></span> 中，使 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         n
        
        
         u
        
        
         m
        
        
         s
        
        
         1
        
       
       
        nums1
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">1</span></span></span></span></span> 成为一个有序数组。初始化 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         n
        
        
         u
        
        
         m
        
        
         s
        
        
         1
        
       
       
        nums1
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">1</span></span></span></span></span> 和 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         n
        
        
         u
        
        
         m
        
        
         s
        
        
         2
        
       
       
        nums2
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">2</span></span></span></span></span> 的元素数量分别为 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         m
        
       
       
        m
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">m</span></span></span></span></span> 和 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         n
        
       
       
        n
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span></span></span></span></span> 。你可以假设 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         n
        
        
         u
        
        
         m
        
        
         s
        
        
         1
        
       
       
        nums1
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">1</span></span></span></span></span> 的空间大小等于 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         m
        
        
         +
        
        
         n
        
       
       
        m + n
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.66666em; vertical-align: -0.08333em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span></span></span></span></span>，这样它就有足够的空间保存来自 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         n
        
        
         u
        
        
         m
        
        
         s
        
        
         2
        
       
       
        nums2
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">2</span></span></span></span></span> 的元素。<br/>  <strong>样例输入：</strong><span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         n
        
        
         u
        
        
         m
        
        
         s
        
        
         1
        
        
         =
        
        
         [
        
        
         1
        
        
         ,
        
        
         2
        
        
         ,
        
        
         3
        
        
         ,
        
        
         0
        
        
         ,
        
        
         0
        
        
         ,
        
        
         0
        
        
         ]
        
        
         ,
        
        
         m
        
        
         =
        
        
         3
        
        
         ,
        
        
         n
        
        
         u
        
        
         m
        
        
         s
        
        
         2
        
        
         =
        
        
         [
        
        
         2
        
        
         ,
        
        
         5
        
        
         ,
        
        
         6
        
        
         ]
        
        
         ,
        
        
         n
        
        
         =
        
        
         3
        
       
       
        nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">1</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">0</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.83888em; vertical-align: -0.19444em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">2</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">[</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">6</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">3</span></span></span></span></span><br/>  <strong>样例输出：</strong> <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         [
        
        
         1
        
        
         ,
        
        
         2
        
        
         ,
        
        
         2
        
        
         ,
        
        
         3
        
        
         ,
        
        
         5
        
        
         ,
        
        
         6
        
        
         ]
        
       
       
        [1,2,2,3,5,6]
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">6</span><span class="mclose">]</span></span></span></span></span><br/>  <strong>原题出处：</strong> LeetCode 88. 合并两个有序数组</p>
</blockquote>
<p><strong>II、基础框架</strong></p>
<ul><li>c++ 版本给出的基础框架代码如下：</li></ul>
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums1<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums2<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p><strong>III、思路分析</strong></p>
<ul><li>这个题别想太多，直接把第二个数组的元素加到第一个数组元素的后面，然后直接排序就成。<br/> <img alt="" src="https://img-blog.csdnimg.cn/15b02fecfac0427b99c72d2ac7fad0d8.gif#pic_center"/></li></ul>
<p><strong>IV、时间复杂度</strong></p>
<ul><li>STL 排序函数的时间复杂度为 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         O
        
        
         (
        
        
         n
        
        
         l
        
        
         o
        
        
         
          g
         
         
          2
         
        
        
         n
        
        
         )
        
       
       
        O(nlog_2n)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span>，遍历的时间复杂度为 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         O
        
        
         (
        
        
         n
        
        
         )
        
       
       
        O(n)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span>，所以总的时间复杂度为 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         O
        
        
         (
        
        
         n
        
        
         l
        
        
         o
        
        
         
          g
         
         
          2
         
        
        
         n
        
        
         )
        
       
       
        O(nlog_2n)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span>。</li></ul>
<p><strong>IV、源码详解</strong></p>
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums1<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums2<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> m<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">+</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums2<span class="token punctuation">[</span>i<span class="token operator">-</span>m<span class="token punctuation">]</span><span class="token punctuation">;</span>               <span class="token comment">// (1)</span>
        <span class="token punctuation">}</span>
        <span class="token function">sort</span><span class="token punctuation">(</span>nums1<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums1<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// (2)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<ul><li><span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         1
        
        
         )
        
       
       
        (1)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span> 简单合并两个数组；</li><li><span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         2
        
        
         )
        
       
       
        (2)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span></span></span></span></span> 对数组1进行排序；</li></ul>
<p><strong>VI、本题小知识</strong></p>
<blockquote>
<p>  只要能够达到最终的结果，<span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         O
        
        
         (
        
        
         n
        
        
         )
        
       
       
        O(n)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span> 和 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         O
        
        
         (
        
        
         n
        
        
         l
        
        
         o
        
        
         
          g
         
         
          2
         
        
        
         n
        
        
         )
        
       
       
        O(nlog_2n)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span> 的差距其实并没有那么大。只要是和有序相关的，就可以调用这个函数，直接就出来了。</p>
</blockquote>
<hr/>
<h2><a id="2_655"></a>2、线性迭代</h2>
<ul><li>迭代就是一件事情重复的做，干的事情一样，只是参数的不同。一般配合的 数据结构 是 【数组】 或者 【链表】，实现方式也是一个循环。比 枚举 稍微复杂一点。</li></ul>
<p><strong>I、例题描述</strong></p>
<blockquote>
<p>  给定单链表的头节点 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         h
        
        
         e
        
        
         a
        
        
         d
        
       
       
        head
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault">d</span></span></span></span></span> ，要求反转链表，并返回反转后的链表头。<br/>  <strong>样例输入：</strong><span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         [
        
        
         1
        
        
         ,
        
        
         2
        
        
         ,
        
        
         3
        
        
         ,
        
        
         4
        
        
         ]
        
       
       
        [1,2,3,4]
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">4</span><span class="mclose">]</span></span></span></span></span><br/>  <strong>样例输出：</strong><span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         [
        
        
         4
        
        
         ,
        
        
         3
        
        
         ,
        
        
         2
        
        
         ,
        
        
         1
        
        
         ]
        
       
       
        [4, 3, 2, 1]
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">[</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></span><br/>  <strong>原题出处：</strong> LeetCode 206. 反转链表<br/> <img alt="" src="image\20210714070901579.png"/></p>
</blockquote>
<p><strong>II、基础框架</strong></p>
<ul><li>c++ 版本给出的基础框架代码如下：</li></ul>
<pre><code class="prism language-cpp"><span class="token comment">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */</span>
<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    ListNode<span class="token operator">*</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<ul><li>这里引入了一种数据结构 链表 <code>ListNode</code>；</li><li>成员有两个：数据域<code>val</code>和指针域<code>next</code>。</li><li>返回的是链表头结点；</li></ul>
<p><strong>III、思路分析</strong></p>
<ul><li>这个问题，我们可以采用头插法，即每次拿出第 2 个节点插到头部，拿出第 3 个节点插到头部，拿出第 4 个节点插到头部，… 拿出最后一个节点插到头部。</li><li>于是整个过程可以分为两个步骤：删除第 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         i
        
       
       
        i
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.65952em; vertical-align: 0em;"></span><span class="mord mathdefault">i</span></span></span></span></span> 个节点，将它放到头部，反复迭代 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         i
        
       
       
        i
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.65952em; vertical-align: 0em;"></span><span class="mord mathdefault">i</span></span></span></span></span> 即可。</li><li>如图所示：<br/> <img alt="" src="https://img-blog.csdnimg.cn/20210714085845562.gif#pic_center"/></li><li>我们发现，图中的蓝色指针永远固定在最开始的链表头结点上，那么可以以它为契机，每次删除它的<code>next</code>，并且插到最新的头结点前面，不断改变头结点<code>head</code>的指向，迭代 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         n
        
        
         −
        
        
         1
        
       
       
        n-1
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.66666em; vertical-align: -0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span></span></span></span></span> 次就能得到答案了。</li></ul>
<p><strong>IV、时间复杂度</strong></p>
<ul><li>每个结点只会被访问一次，执行一次头插操作，总共 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         n
        
       
       
        n
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span></span></span></span></span> 个节点的情况下，时间复杂度 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         O
        
        
         (
        
        
         n
        
        
         )
        
       
       
        O(n)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span>。</li></ul>
<p><strong>V、源码详解</strong></p>
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
    ListNode <span class="token operator">*</span><span class="token function">removeNextAndReturn</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> now<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>                 <span class="token comment">// (1) </span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>now <span class="token operator">==</span> <span class="token keyword">nullptr</span> <span class="token operator">||</span> now<span class="token operator">-&gt;</span>next <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>                                        <span class="token comment">// (2) </span>
        <span class="token punctuation">}</span>
        ListNode <span class="token operator">*</span>retNode <span class="token operator">=</span> now<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>                             <span class="token comment">// (3) </span>
        now<span class="token operator">-&gt;</span>next <span class="token operator">=</span> now<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>                               <span class="token comment">// (4) </span>
        <span class="token keyword">return</span> retNode<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    ListNode<span class="token operator">*</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        ListNode <span class="token operator">*</span>doRemoveNode <span class="token operator">=</span> head<span class="token punctuation">;</span>                             <span class="token comment">// (5) </span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>doRemoveNode<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>                                      <span class="token comment">// (6) </span>
            ListNode <span class="token operator">*</span>newHead <span class="token operator">=</span> <span class="token function">removeNextAndReturn</span><span class="token punctuation">(</span>doRemoveNode<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// (7) </span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>newHead<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>                                          <span class="token comment">// (8) </span>
                newHead<span class="token operator">-&gt;</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>                              
                head <span class="token operator">=</span> newHead<span class="token punctuation">;</span>                
            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>                                             <span class="token comment">// (9) </span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> head<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<ul><li><span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         1
        
        
         )
        
       
       
        (1)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span> <code>ListNode *removeNextAndReturn(ListNode* now)</code>函数的作用是删除<code>now</code>的<code>next</code>节点，并且返回；</li><li><span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         2
        
        
         )
        
       
       
        (2)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span></span></span></span></span> 本身为空或者下一个节点为空，返回空；</li><li><span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         3
        
        
         )
        
       
       
        (3)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mclose">)</span></span></span></span></span> 将需要删除的节点缓存起来，供后续返回；</li><li><span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         4
        
        
         )
        
       
       
        (4)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">4</span><span class="mclose">)</span></span></span></span></span> 执行删除 now-&gt;next 的操作；</li><li><span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         5
        
        
         )
        
       
       
        (5)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">5</span><span class="mclose">)</span></span></span></span></span> <code>doRemoveNode</code>指向的下一个节点是将要被删除的节点，所以<code>doRemoveNode</code>需要被缓存起来，不然都不知道怎么进行删除；</li><li><span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         6
        
        
         )
        
       
       
        (6)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">6</span><span class="mclose">)</span></span></span></span></span> 没有需要删除的节点了就结束迭代；</li><li><span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         7
        
        
         )
        
       
       
        (7)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">7</span><span class="mclose">)</span></span></span></span></span> 删除 doRemoveNode 的下一个节点并返回被删除的节点；</li><li><span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         8
        
        
         )
        
       
       
        (8)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">8</span><span class="mclose">)</span></span></span></span></span> 如果有被删除的节点，则插入头部；</li><li><span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         9
        
        
         )
        
       
       
        (9)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">9</span><span class="mclose">)</span></span></span></span></span> 如果没有，则跳出迭代。</li></ul>
<p><strong>VI、本题小知识</strong></p>
<blockquote>
<p>  复杂问题简单化的最好办法就是将问题拆细，比如这个问题中，将一个节点取出来插到头部这件事情可以分为两步：<br/>  1）删除给定节点；<br/>  2）将删除的节点插入头部；</p>
</blockquote>
<hr/>
<h2><a id="3_738"></a>3、线性枚举</h2>
<ul><li>线性枚举，一般配合的 数据结构 是 【数组】 或者 【链表】，实现方式就是一个循环。正因为只有一个循环，所以线性枚举解决的问题一般比较简单，而且很容易从题目中看出来。</li></ul>
<p><strong>I、例题描述</strong></p>
<blockquote>
<p>  编写一个函数，将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。<br/> 必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。<br/>  <strong>样例输入：</strong><span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         [
        
        
         “
        
        
         a
        
        
         ”
        
        
         ,
        
        
         “
        
        
         b
        
        
         ”
        
        
         ,
        
        
         “
        
        
         c
        
        
         ”
        
        
         ,
        
        
         “
        
        
         d
        
        
         ”
        
        
         ]
        
       
       
        [“a”, “b”, “c”, “d”]
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">[</span><span class="mord">“</span><span class="mord mathdefault">a</span><span class="mord">”</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">“</span><span class="mord mathdefault">b</span><span class="mord">”</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">“</span><span class="mord mathdefault">c</span><span class="mord">”</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">“</span><span class="mord mathdefault">d</span><span class="mord">”</span><span class="mclose">]</span></span></span></span></span><br/>  <strong>样例输出：</strong><span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         [
        
        
         “
        
        
         d
        
        
         ”
        
        
         ,
        
        
         “
        
        
         c
        
        
         ”
        
        
         ,
        
        
         “
        
        
         b
        
        
         ”
        
        
         ,
        
        
         “
        
        
         a
        
        
         ”
        
        
         ]
        
       
       
        [ “d”, “c”, “b”, “a”]
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">[</span><span class="mord">“</span><span class="mord mathdefault">d</span><span class="mord">”</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">“</span><span class="mord mathdefault">c</span><span class="mord">”</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">“</span><span class="mord mathdefault">b</span><span class="mord">”</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">“</span><span class="mord mathdefault">a</span><span class="mord">”</span><span class="mclose">]</span></span></span></span></span><br/>  <strong>原题出处：</strong> LeetCode 344. 反转字符串</p>
</blockquote>
<p><strong>II、基础框架</strong></p>
<ul><li>c++ 版本给出的基础框架代码如下，要求不采用任何的辅助数组；</li><li>也就是空间复杂度要求 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         O
        
        
         (
        
        
         1
        
        
         )
        
       
       
        O(1)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>。</li></ul>
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">reverseString</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> s<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p><strong>III、思路分析</strong></p>
<blockquote>
<p>  翻转的含义，相当于就是 第一个字符 和 最后一个交换，第二个字符 和 最后第二个交换，… 以此类推，所以我们首先实现一个交换变量的函数 <code>swap</code>，然后再枚举 第一个字符、第二个字符、第三个字符 …… 即可。<br/>  对于第 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         i
        
       
       
        i
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.65952em; vertical-align: 0em;"></span><span class="mord mathdefault">i</span></span></span></span></span> 个字符，它的交换对象是 第 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         l
        
        
         e
        
        
         n
        
        
         −
        
        
         i
        
        
         −
        
        
         1
        
       
       
        len-i-1
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.77777em; vertical-align: -0.08333em;"></span><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.74285em; vertical-align: -0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span></span></span></span></span> 个字符 (其中 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         l
        
        
         e
        
        
         n
        
       
       
        len
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span></span></span></span></span> 为字符串长度)。<code>swap</code>函数的实现，可以参考：<a href="https://blog.csdn.net/WhereIsHeroFrom/article/details/118208316">《C语言入门100例》 - 例2 | 交换变量</a>。</p>
</blockquote>
<p><strong>IV、时间复杂度</strong></p>
<ul><li>线性枚举的过程为 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         O
        
        
         (
        
        
         n
        
        
         )
        
       
       
        O(n)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span>，交换变量为 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         O
        
        
         (
        
        
         1
        
        
         )
        
       
       
        O(1)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>，两个过程是相乘的关系，所以整个算法的时间复杂度为 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         O
        
        
         (
        
        
         n
        
        
         )
        
       
       
        O(n)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span>。</li></ul>
<p><strong>IV、源码详解</strong></p>
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">&amp;</span> a<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">&amp;</span> b<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>            <span class="token comment">// (1)</span>
        <span class="token keyword">char</span> tmp <span class="token operator">=</span> a<span class="token punctuation">;</span>
        a <span class="token operator">=</span> b<span class="token punctuation">;</span>
        b <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">void</span> <span class="token function">reverseString</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> s<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> len <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>   <span class="token comment">// (2)</span>
            <span class="token function">swap</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> s<span class="token punctuation">[</span>len<span class="token operator">-</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<ul><li><span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         1
        
        
         )
        
       
       
        (1)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span> 实现一个变量交换的函数，其中<code>&amp;</code>是C++中的引用，在函数传参是经常用到，被称为：<strong>引用传递(pass-by-reference)</strong>，即被调函数的形式参数虽然也作为局部变量在堆栈中开辟了内存空间<br/> ，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过堆栈中存放的地址访问主调函数中的实参变量。</li></ul>
<blockquote>
<p>简而言之，函数调用的参数，可以传引用，从而使得函数返回时，传参值的改变依旧生效。</p>
</blockquote>
<ul><li><span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         2
        
        
         )
        
       
       
        (2)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span></span></span></span></span> 这一步是做的线性枚举，注意枚举范围是 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         [
        
        
         0
        
        
         ,
        
        
         l
        
        
         e
        
        
         n
        
        
         /
        
        
         2
        
        
         −
        
        
         1
        
        
         ]
        
       
       
        [0, len/2-1]
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></span>。</li></ul>
<p><strong>VI、本题小知识</strong></p>
<blockquote>
<p>函数调用的参数，可以传引用，从而使得函数返回时，传参值的改变依旧生效。</p>
</blockquote>
<hr/>
<h2><a id="4_796"></a>4、二分枚举</h2>
<ul><li>能用二分枚举的问题，一定可以用线性枚举来实现，只是时间上的差别，二分枚举的时间复杂度一般为对数级，效率上会高不少。同时，实现难度也会略微有所上升。我们通过平时开发时遇到的常见问题来举个例子。</li></ul>
<p><strong>I、例题描述</strong></p>
<blockquote>
<p>  软件开发的时候，会有版本的概念。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。假设你有 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         n
        
       
       
        n
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span></span></span></span></span> 个版本 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         [
        
        
         1
        
        
         ,
        
        
         2
        
        
         ,
        
        
         .
        
        
         .
        
        
         .
        
        
         ,
        
        
         n
        
        
         ]
        
       
       
        [1, 2, ..., n]
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault">n</span><span class="mclose">]</span></span></span></span></span>，你想找出导致之后所有版本出错的第一个错误的版本。可以通过调用<code>bool isBadVersion(version)</code>接口来判断版本号<code>version</code>是否在单元测试中出错。实现一个函数来查找第一个错误的版本。应该尽量减少对调用 API 的次数。<br/>  <strong>样例输入：</strong><span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         5
        
       
       
        5
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">5</span></span></span></span></span> 和 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         b
        
        
         a
        
        
         d
        
        
         =
        
        
         4
        
       
       
        bad = 4
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">a</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">4</span></span></span></span></span> <br/>  <strong>样例输出：</strong><span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         4
        
       
       
        4
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">4</span></span></span></span></span><br/>  <strong>原题出处：</strong> LeetCode 278. 第一个错误的版本</p>
</blockquote>
<p><strong>II、基础框架</strong></p>
<ul><li>c++ 版本给出的基础框架代码如下，其中<code>bool isBadVersion(int version)</code>是供你调用的 API，也就是当你调用这个 API 时，如果<code>version</code>是错误的，则返回<code>true</code>；否则，返回<code>false</code>；</li></ul>
<pre><code class="prism language-cpp"><span class="token comment">// The API isBadVersion is defined for you.</span>
<span class="token comment">// bool isBadVersion(int version);</span>

<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">firstBadVersion</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p><strong>III、思路分析</strong></p>
<ul><li>由题意可得，我们调用它提供的 API 时，返回值分布如下：</li><li><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml">
      
       
        
         
          000...000111...111
         
        
        
         000...000111...111
        
       
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span></span></span></span></span></span></li><li>其中 0 代表<code>false</code>，1 代表<code>true</code>；也就是一旦出现 1，就再也不会出现 0 了。</li><li>所以基于这思路，我们可以二分位置；</li></ul>
<blockquote>
<p>归纳总结为 2 种情况，如下：<br/>  1）当前二分到的位置 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         m
        
        
         i
        
        
         d
        
       
       
        mid
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span></span></span></span></span>，给出的版本是错误，那么从当前位置以后的版本不需要再检测了（因为一定也是错误的），并且我们可以肯定，出错的位置一定在 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         [
        
        
         l
        
        
         ,
        
        
         m
        
        
         i
        
        
         d
        
        
         ]
        
       
       
        [l, mid]
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mclose">]</span></span></span></span></span>；并且 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         m
        
        
         i
        
        
         d
        
       
       
        mid
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span></span></span></span></span> 是一个可行解，记录下来；<br/>  2）当前二分到的位置 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         m
        
        
         i
        
        
         d
        
       
       
        mid
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span></span></span></span></span>，给出的版本是正确，则出错位置可能在 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         [
        
        
         m
        
        
         i
        
        
         d
        
        
         +
        
        
         1
        
        
         ,
        
        
         r
        
        
         ]
        
       
       
        [mid+1, r]
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">r</span><span class="mclose">]</span></span></span></span></span>；</p>
</blockquote>
<p><strong>IV、时间复杂度</strong></p>
<ul><li>由于每次都是将区间折半，所以时间复杂度为 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         O
        
        
         (
        
        
         l
        
        
         o
        
        
         
          g
         
         
          2
         
        
        
         n
        
        
         )
        
       
       
        O(log_2n)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span>。</li></ul>
<p><strong>V、源码详解</strong></p>
<pre><code class="prism language-cpp"><span class="token comment">// The API isBadVersion is defined for you.</span>
<span class="token comment">// bool isBadVersion(int version);</span>

<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">firstBadVersion</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">long</span> <span class="token keyword">long</span> l <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> r <span class="token operator">=</span> n<span class="token punctuation">;</span>             <span class="token comment">// (1)</span>
        <span class="token keyword">long</span> <span class="token keyword">long</span> ans <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">)</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">long</span> <span class="token keyword">long</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>l <span class="token operator">+</span> r<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token function">isBadVersion</span><span class="token punctuation">(</span>mid<span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>       
                ans <span class="token operator">=</span> mid<span class="token punctuation">;</span>                  <span class="token comment">// (2)</span>
                r <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                l <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token comment">// (3)</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<ul><li><span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         1
        
        
         )
        
       
       
        (1)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span> 需要这里，这里两个区间相加可能超过 <code>int</code>，所以需要采用 64 位整型<code>long long</code>；</li><li><span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         2
        
        
         )
        
       
       
        (2)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span></span></span></span></span> 找到错误版本的嫌疑区间 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         [
        
        
         l
        
        
         ,
        
        
         m
        
        
         i
        
        
         d
        
        
         ]
        
       
       
        [l, mid]
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mclose">]</span></span></span></span></span>，并且 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         m
        
        
         i
        
        
         d
        
       
       
        mid
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span></span></span></span></span> 是确定的候选嫌疑位置；</li><li><span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         3
        
        
         )
        
       
       
        (3)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mclose">)</span></span></span></span></span> 错误版本不可能落在 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         [
        
        
         l
        
        
         ,
        
        
         m
        
        
         i
        
        
         d
        
        
         ]
        
       
       
        [l, mid]
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mclose">]</span></span></span></span></span>，所以可能在 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         [
        
        
         m
        
        
         i
        
        
         d
        
        
         +
        
        
         1
        
        
         ,
        
        
         r
        
        
         ]
        
       
       
        [mid+1, r]
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">r</span><span class="mclose">]</span></span></span></span></span>，需要继续二分迭代；</li></ul>
<p><strong>VI、本题小知识</strong><br/>   二分时，如果区间范围过大，<code>int</code>难以招架时，需要动用<code>long long</code>；</p>
<hr/>
<h1><a id="_857"></a>四、社区活跃奖励</h1>
<p><img alt="" src="image\250b7eab23414c75bb54bba38bc21bcf.jpg"/></p>
<h2><a id="1_861"></a>1、简介</h2>
<p>  与周志华编写的《机器学习》相比，本书多了对算法的数学原理详细严谨的推导。<br/>   与李锐翻译的《机器学习实战》相比，本书多了用面向对象思想将算法模块化，并且书中代码在Python 3 环境下运行。<br/>   为了照顾初学者，本书补充了全书涉及的高等数学、线性代数、概率论与数理统计、Jessen不等式等数学基础知识。</p>
<h2><a id="2_865"></a>2、内容简介</h2>
<p>  机器学习是一门涉及高等数学、线性代数、概率论、统计学和运筹学等领域的交叉学科。机器学习的基础就是数学，这也就要求学习者要有良好的数学基础。为了降低机器学习的学习门槛，本书深入浅出地对机器学习算法的数学原理进行了严谨的推导；并利用Python 3对各种机器学习算法进行复现，还利用介绍的算法在相应数据集上进行实战。本书主要内容包括机器学习及其数学基础；线性回归、局部加权线性回归两种回归算法；Logistic回归、Softmax回归和BP神经网络3种分类算法；模型评估与优化；K-Means聚类算法、高斯混合模型两种聚类算法和一种降维算法——主成分分析。<br/>   《机器学习入门：基于数学原理的Python实战》理论性与实用性兼备，既可作为初学者的入门书籍，也可作为求职者的面试宝典，更可作为职场人士转岗的实用手册。本书适合需要全面学习机器学习算法的初学者、希望掌握机器学习算法数学理论的程序员、想转行从事机器学习算法的专业人员、对机器学习算法兴趣浓厚的人员、专业培训机构学员和希望提高Python编程水平的程序员。</p>
<h2><a id="3_869"></a>3、作者简介</h2>
<p>  戴璞微，中国民航大学硕士，CSDN博客专家。曾获得全国大学生数学竞赛国家一等奖、北美数学建模二等奖，参与国家自然科学基金项目1项。对计算机视觉、机器学习和深度学习有深入研究。<br/>   潘斌，浙江大学应用数学系博士，现任辽宁石油化工大学理学院副院长。2018年入选辽宁省“兴辽英才计划”青年拔尖人才，2016年主持国家自然科学基金青年基金项目1项；2015年主持辽宁省自然科学基金项目1项；2016年主持浙江大学CAD&amp;CG国家重点实验室开放课题2项。近年来，指导本科生获全国大学生数学建模竞赛国家一等奖。</p>
<p>  京东自营购买链接：<a href="https://item.jd.com/12622435.html">链接</a><br/>   当当自营购买链接：<a href="http://product.dangdang.com/28511988.html">链接</a></p>
<h1><a id="_877"></a>五、粉丝专属福利</h1>
<p><span id="jump99"></span></p>
<blockquote>
<p><strong>语言入门</strong>：<a href="https://pan.baidu.com/s/1xLAWFd-sga7LQ8KFWbwwnQ">《光天化日学C语言》(示例代码) </a><br/> <strong>语言训练</strong>：<a href="https://pan.baidu.com/s/1OvpKXh0nproMophGFnhdJQ">《C语言入门100例》试用版</a><br/> <strong>数据结构</strong>：<a href="https://pan.baidu.com/s/1aGa5hYppG_1fDZF4H4xgYw">《画解数据结构》源码</a><br/> <strong>算法入门</strong>：<a href="https://docs.qq.com/mind/DU01SVGpab2tWdlNj">《算法入门》指引</a><br/> <strong>算法进阶</strong>：<a href="https://pan.baidu.com/s/1OvFw9KzKVf9LpwpgmWCkMA">《夜深人静写算法》算法模板</a></p>
</blockquote>
<center>
 👇🏻 添加 博主 参加 九日集训👇🏻
</center>
</div>
<link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css" rel="stylesheet"/>
<link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css" rel="stylesheet"/>
</div>