<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="markdown_views prism-atom-one-dark" id="content_views">
<svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
<path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
</svg>
<p>1、引用空间<br/> System.Threading.Task<br/> 2、定义<br/> Task类可以更好的控制并行操作，任务表示将完成的某个工作单元，该工作单元可以在单独的线程运行，可以以同步方式启动一个新任务。<br/> 3、启动任务的方式<br/> 任务处理程序<br/> public static void TaskMethod(string o){<!-- --><br/> Console.WriteLine(“进入任务处理程序”+o);<br/> }<br/> （1）、使用实例化的TaskFactory类，在其中将TaskMethod方法传递给StartNew方法<br/> var tf=new TaskFactory();<br/> Task t1=tf.StartNew(TaskMethod, “using task factory”);<br/> （2）、使用Task类的静态属性Factory来访问TaskFactory，以及调用StartNew方法<br/> Task t2=Task.Factory.StartNew(TaskMethod, “factory via a task”);<br/> （3）、用Task类的构造函数实例化Task对象，调用Task类的Start方法启动任务<br/> Task t3=new Task(TaskMethod, “using a task constructor and start”);<br/> t3.Start();<br/> （4）、调用Task类的Run方法启动任务<br/> Task t4=Task.Run(()=&gt;TaskMethod(“using run method”));<br/> Run方法没有可传递Action委托的重载版本，但通过传递Action类型的lambda表达式并在其实现中使用参数。<br/> 4、同步任务<br/> private static void RunSynchronousTask(){<!-- --><br/> TaskMethod(“just the main thread”);<br/> var t1=new Task(TaskMethod, “run sync”);<br/> t1.RunSynchronously();<br/> }<br/> 5、使用单独线程的任务<br/> 如果任务代码长时间运行，可使用TaskCreationOptions.LongRunning告诉任务调度器创建一个新线程。<br/> var t1=new Task(TaskMethod,“long running”,TaskCreationOptions.LongRunning);<br/> t1.Start();<br/> 6、任务结果返回<br/> public static double TaskWithResult(object o){<!-- --><br/> List l=(List)o;<br/> double d=0;<br/> if(l[1]!=0){<!-- --><br/> d=l[0]/l[1];<br/> }<br/> return d;<br/> }</p>
<p>public static void TaskWithResultDemo(){<!-- --><br/> var t1=new Task(TaskWithResult, l);<br/> t1.Start();<br/> Console.WriteLine(t1.Result);<br/> }<br/> 7、连续任务<br/> public static void TaskDoFirst(){<!-- --><br/> Console.WriteLine(“进入任务1处理程序”);<br/> }<br/> public static void TaskDoSecond(){<!-- --><br/> Console.WriteLine(“进入任务2处理程序”);<br/> }<br/> public static void ContinueTasks(){<!-- --><br/> Task t1=new Task(TaskDoFirst);<br/> Task t2=t1.ContinueWith(TaskDoSecond);<br/> Task t3=t1.ContinueWith(TaskDoSecond);<br/> Task t4=t2.ContinueWith(TaskDoSecond, TaskContinuationOptions.OnlyOnFaulted);<br/> t1.Start();<br/> }<br/> 8、等待任务<br/> WaitAll()方法阻塞调用任务，直到等待的所有任务完成为止；<br/> WhenAll()返回一个任务，允许用async关键字等待结果，不会阻塞等待任务。<br/> Task.Delay()方法指定从这个方法返回的任务完成前要等待的毫秒数。</p>
</div>
<link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css" rel="stylesheet"/>
<link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css" rel="stylesheet"/>
</div>