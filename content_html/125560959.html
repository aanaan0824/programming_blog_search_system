<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<h1 id="%E7%9B%AE%E5%BD%95">目录</h1>
<p id="%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#%E5%89%8D%E8%A8%80">前言</a></p>
<p id="%E4%B8%80%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%C2%A0-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%C2%A0">一、线程池介绍</a></p>
<p id="%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">💻线程池基本概念</a></p>
<p id="%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86-toc" style="margin-left:40px;"><a href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86">💻线程池组成部分</a></p>
<p id="%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%C2%A0-toc" style="margin-left:40px;"><a href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%C2%A0">💻线程池工作原理 </a></p>
<p id="%E4%BA%8C%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BB%A3%E7%A0%81%E5%B0%81%E8%A3%85-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BB%A3%E7%A0%81%E5%B0%81%E8%A3%85">二、线程池代码封装</a></p>
<p id="main.cpp-toc" style="margin-left:40px;"><a href="#main.cpp">🌈main.cpp</a></p>
<p id="%C2%A0ThreadPool.h-toc" style="margin-left:40px;"><a href="#%C2%A0ThreadPool.h">🌈ThreadPool.h</a></p>
<p id="%C2%A0%C2%A0ThreadPool.cpp-toc" style="margin-left:40px;"><a href="#%C2%A0%C2%A0ThreadPool.cpp">🌈ThreadPool.cpp</a></p>
<p id="%C2%A0ChildTask.h%C2%A0-toc" style="margin-left:40px;"><a href="#%C2%A0ChildTask.h%C2%A0">🌈ChildTask.h </a></p>
<p id="%C2%A0ChildTask.cpp-toc" style="margin-left:40px;"><a href="#%C2%A0ChildTask.cpp">🌈ChildTask.cpp</a></p>
<p id="%C2%A0BaseTask.h-toc" style="margin-left:40px;"><a href="#%C2%A0BaseTask.h">🌈BaseTask.h</a></p>
<p id="%C2%A0BaseTask.cpp-toc" style="margin-left:40px;"><a href="#%C2%A0BaseTask.cpp">🌈BaseTask.cpp</a></p>
<p id="%E4%B8%89%E3%80%81%E6%B5%8B%E8%AF%95%E6%95%88%E6%9E%9C-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E6%B5%8B%E8%AF%95%E6%95%88%E6%9E%9C">三、测试效果</a></p>
<p id="%E5%9B%9B%E3%80%81%E6%80%BB%E7%BB%93-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E6%80%BB%E7%BB%93">四、总结</a></p>
<p id="%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%A5%BD%E5%A4%84-toc" style="margin-left:40px;"><a href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%A5%BD%E5%A4%84">📌创建线程池的好处</a></p>
<hr/>
<h1 id="%E5%89%8D%E8%A8%80">前言</h1>
<p>本文主要学习<span style="color:#be191c;"><strong>Linux内核编程</strong></span>，结合<span style="color:#be191c;"><strong>Visual Studio 2019</strong></span>进行跨平台编程，内容包括线程池介绍以及线程池封装</p>
<h1 id="%E4%B8%80%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%C2%A0">一、线程池介绍</h1>
<p style="text-align:center;"><img alt="" height="405" src="image\25b11019e4bd498192bac62084213f54.png" width="461"/></p>
<h2 id="%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">💻线程池基本概念</h2>
<ul><li><span style="color:#be191c;"><strong>线程池</strong></span>是预先创建线程的一种技术 （服务器真正意义上实现高并发就必须用线程池）</li><li>🌰举个例子：生活中的水池，是装东西的容器，用来装水的，线程池当然就是拿来装线程的</li></ul>
<blockquote>
<ul><li>线程池在任务还没有到来之前，创建一定数量的线程，放入空闲队列中，这些线程都是处于阻塞状态，不消耗CPU，但占用较小的内存空间</li><li>当新任务到来时，缓冲池选择一个空闲线程，把任务传入此线程中运行，如果缓冲池已经没有空闲线程，则新建若干个线程，当系统比较空闲时，大部分线程都一直处于暂停状态，线程池自动销毁一部分线程，回收系统资源</li></ul>
</blockquote>
<h2 id="%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86">💻<strong>线程池组成部分</strong></h2>
<blockquote>
<ul><li><strong>线程池类</strong></li></ul>
<p>        维护工作者线程队列（包括空闲与忙碌队列）</p>
<p>        维护一个任务队列</p>
<p>        维护一个线程池调度器指针</p>
<ul><li><strong>线程池调度器</strong>（本身也是一个线程）</li></ul>
<p>        负责线程调度</p>
<p>        负责任务分配</p>
<ul><li><strong>工作者线程类</strong>（线程池中的线程类的封装）</li><li><strong>任务队列</strong></li><li><strong>任务接口</strong>（实际的业务逻辑都继承自该接口）</li></ul>
</blockquote>
<h2 id="%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%C2%A0">💻<strong>线程池工作原理 </strong></h2>
<p>根据服务器的需要，来设置线程的数量，可能是10条、20条、30条，根据服务器的承载，10条不代表只能做10个任务，总有任务做的快，有的做的慢，可能可以完成20个任务 </p>
<p><img alt="" height="1074" src="https://img-blog.csdnimg.cn/e1e608aeaca24f439da26619725121cc.gif" width="1200"/></p>
<p>🌰举个例子：如上动图所示，当我们服务器收到一个注册业务，是一个服务器要执行的任务，它会进入到任务队列，队列先进先出，顺次执行，任务会唤醒空闲列表当中的一个空闲的线程，接到任务之后，空闲线程会从空闲列表中消失，进入到忙碌列表，去完成对应的任务，完成任务后，从忙碌列表中出去，到空闲列表继续等待新任务</p>
<p>如果，所有的线程都在忙，都在做任务，这时候登录进来，先进入任务队列，会创建一个新的线程来接这个任务，当所有线程都完成任务，回到空闲列表后，新创建的线程销毁，留下原先设置的对应数量线程（类似，保留老员工，把实习生裁员）</p>
<blockquote>
<ul><li><strong>队列：</strong>先进先出</li><li><strong>空闲列表（链表）：</strong>不定长（有的时候可能需要创建新线程来接任务）</li><li><strong>忙碌列表（链表）：</strong>不定长（有的时候可能需要创建新线程来接任务）</li></ul>
</blockquote>
<p>话不多说，咱们上号，封装一下线程池相关函数，来进行测试 </p>
<p><img alt="" height="673" src="image\ebb9ac75e7d74284b42cacac2fff41fd.png" width="1200"/></p>
<h1 id="%E4%BA%8C%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BB%A3%E7%A0%81%E5%B0%81%E8%A3%85">二、线程池代码封装</h1>
<h2 id="main.cpp">🌈main.cpp</h2>
<ul><li>主函数，设置10条线程，来执行30个任务 </li></ul>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include "ThreadPool.h"
#include "ChildTask.h"
using namespace std;

int main()
{
	ThreadPool* pool = new ThreadPool(10);//10条线程

	for (int i = 0; i &lt; 30; i++)//设置30个任务
	{
		char buf[40] = { 0 };//初始化
		sprintf(buf, "%s%d", "任务", i);

		BaseTask* task = new ChildTask(buf);
		pool-&gt;pushTask(task);
	}

	while (1) {}

	return 0;
}</code></pre>
<h2 id="%C2%A0ThreadPool.h">🌈ThreadPool.h</h2>
<ul><li>对线程池进行设计，核心包括<strong>最大、最小线程数</strong>，<strong>忙碌列表</strong>，<strong>空闲列表</strong>，<strong>任务队列</strong>，<strong>互斥量</strong>，<strong>条件变量</strong>，以及<strong>线程执行函数</strong></li></ul>
<pre><code class="language-cpp">#pragma once
#include &lt;queue&gt;//队列
#include &lt;list&gt;//链表头文件
#include &lt;pthread.h&gt;//线程头文件
#include &lt;algorithm&gt;//find查找
#include &lt;iostream&gt;
#include "BaseTask.h"

using namespace std;

#define MIN_NUM 10//最小值 默认参数

class ThreadPool
{
public:
	ThreadPool(const int num = MIN_NUM);
	~ThreadPool();

	//判断任务队列是否为空
	bool QueueIsEmpty();
	//线程互斥量加锁解锁
	void Lock();
	void Unlock();
	//线程条件变量等待和唤醒
	void Wait();
	void WakeUp();

	//添加任务到任务队列
	void pushTask(BaseTask* task);
	//从任务队列移除任务
	BaseTask* popTask(BaseTask* task);

	//从忙碌回到空闲 工作结束
	void MoveToIdle(pthread_t id);

	//从空闲到忙碌 工作开始
	void MoveToBusy(pthread_t id);

	//线程执行函数
	static void* RunTime(void* vo);

private:
	int threadMinNum;//最大线程数量
	int threadMaxNum;//最小线程数量
	queue&lt;BaseTask*&gt;taskQueue;//任务队列
	list&lt;pthread_t&gt;busyList;//线程忙碌列表
	list&lt;pthread_t&gt;idleList;//线程空闲列表
	pthread_mutex_t mutex;//互斥量：做锁
	pthread_cond_t cond;//条件变量：让线程等待或者唤醒
};

</code></pre>
<h2 id="%C2%A0%C2%A0ThreadPool.cpp">🌈ThreadPool.cpp</h2>
<ul><li>对函数进行参数的设置，核心在于线程执行函数上的设置，在工作前和工作完设置打印，方便我们进行观察</li></ul>
<pre><code class="language-cpp">#include "ThreadPool.h"

ThreadPool::ThreadPool(const int num)
{
	this-&gt;threadMinNum = num;

	//条件变量、互斥量初始化
	pthread_mutex_init(&amp;this-&gt;mutex, NULL);
	pthread_cond_init(&amp;this-&gt;cond, NULL);

	pthread_t id;
	//线程num条创建
	for (int i = 0; i &lt; this-&gt;threadMinNum; i++)
	{
		//线程创建
		pthread_create(&amp;id, NULL, RunTime, this);
		this-&gt;idleList.push_back(id);//线程存入空闲列表
	}
}

ThreadPool::~ThreadPool()
{
}
//任务队列是否为空
bool ThreadPool::QueueIsEmpty()
{
	return this-&gt;taskQueue.empty();
}
//线程加锁
void ThreadPool::Lock()
{
	pthread_mutex_lock(&amp;this-&gt;mutex);
}
//线程解锁
void ThreadPool::Unlock()
{
	pthread_mutex_unlock(&amp;this-&gt;mutex);
}
//线程等待
void ThreadPool::Wait()
{
	pthread_cond_wait(&amp;this-&gt;cond, &amp;this-&gt;mutex);
}
//线程唤醒
void ThreadPool::WakeUp()
{
	pthread_cond_signal(&amp;this-&gt;cond);
}
//添加任务到任务队列
void ThreadPool::pushTask(BaseTask* task)
{
	Lock();
	taskQueue.push(task);
	Unlock();
	WakeUp();
}
//从任务队列移除任务
BaseTask* ThreadPool::popTask(BaseTask* task)
{
	task = this-&gt;taskQueue.front();//从队列头取
	this-&gt;taskQueue.pop();//删除队列头

	return task;
}
//从忙碌回到空闲 工作结束
void ThreadPool::MoveToIdle(pthread_t id)
{
	list&lt;pthread_t&gt;::iterator iter;
	iter = find(busyList.begin(), busyList.end(), id);

	if (iter != busyList.end())
	{
		//从忙碌移除
		this-&gt;busyList.erase(iter);
		//添加到空闲
		this-&gt;idleList.push_back(*iter);//this-&gt;idleList.push_back(id)
	}
}
//从空闲到忙碌 工作开始
void ThreadPool::MoveToBusy(pthread_t id)
{
	list&lt;pthread_t&gt;::iterator iter;
	iter = find(idleList.begin(), idleList.end(), id);

	if (iter != idleList.end())
	{
		//从空闲移除
		this-&gt;idleList.erase(iter);
		//添加到忙碌
		this-&gt;busyList.push_back(*iter);//this-&gt;idleList.push_back(id)
	}
}
//线程执行函数
void* ThreadPool::RunTime(void* vo)
{
	//拿到执行线程自己的id 因为后面要处理忙碌和空闲的情况
	pthread_t id = pthread_self();
	//确保主线程与子线程分离，子线程结束后，资源自动回收
	pthread_detach(id);
	//线程参数获取
	ThreadPool* argThis = (ThreadPool*)vo;

	while (true)
	{
		argThis-&gt;Lock();
		//如果任务队列为空 线程则一直等待 
		//知道任务队列不为空则会被pushTask函数唤醒线程
		while (argThis-&gt;QueueIsEmpty())
		{
			argThis-&gt;Wait();
		}
		argThis-&gt;MoveToBusy(id);

		cout &lt;&lt; "工作前  任务数:" &lt;&lt; argThis-&gt;taskQueue.size() &lt;&lt; endl;
		cout &lt;&lt; "工作前  busy:" &lt;&lt; argThis-&gt;busyList.size() &lt;&lt; endl;
		cout &lt;&lt; "工作前  idle:" &lt;&lt; argThis-&gt;idleList.size() &lt;&lt; endl;
		cout &lt;&lt; "-----------------------------------------------" &lt;&lt; endl;
		//取任务
		BaseTask* task;
		task = argThis-&gt;popTask(task);

		argThis-&gt;Unlock();

		//任务工作
		task-&gt;working();

		//工作结束
		argThis-&gt;Lock();
		argThis-&gt;MoveToIdle(id);
		argThis-&gt;Unlock();

		cout &lt;&lt; "工作完  任务数:" &lt;&lt; argThis-&gt;taskQueue.size() &lt;&lt; endl;
		cout &lt;&lt; "工作完  busy:" &lt;&lt; argThis-&gt;busyList.size() &lt;&lt; endl;
		cout &lt;&lt; "工作完  idle:" &lt;&lt; argThis-&gt;idleList.size() &lt;&lt; endl;
		cout &lt;&lt; "&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;" &lt;&lt; endl;
	}

	return nullptr;
}
</code></pre>
<h2 id="%C2%A0ChildTask.h%C2%A0">🌈ChildTask.h </h2>
<ul><li>子类配置 </li></ul>
<pre><code class="language-cpp">#pragma once
#include "BaseTask.h"
#include &lt;iostream&gt;
#include &lt;unistd.h&gt;//sleep头文件
using namespace std;

class ChildTask :
	public BaseTask
{
public:
	ChildTask(char* data);
	~ChildTask();
	void working();
};
</code></pre>
<h2 id="%C2%A0ChildTask.cpp">🌈ChildTask.cpp</h2>
<ul><li>子类设置延时模拟做任务的时间比较长 </li></ul>
<pre><code class="language-cpp">#include "ChildTask.h"

ChildTask::ChildTask(char* data) :BaseTask(data)//参数传给父类
{
}

ChildTask::~ChildTask()
{
}

void ChildTask::working()
{
	cout &lt;&lt; this-&gt;data &lt;&lt; "正在执行......" &lt;&lt; endl;
	sleep(3);//延时3秒 （模拟做业务的时间比较长）
}
</code></pre>
<h2 id="%C2%A0BaseTask.h">🌈BaseTask.h</h2>
<ul><li>基类设置结构体来装业务 </li></ul>
<pre><code class="language-cpp">#pragma once
#include &lt;string.h&gt;
class BaseTask
{
public:
	BaseTask(char* data);
	~BaseTask();
	char data[1024]; //装业务
	virtual void working() = 0;//虚函数
};

</code></pre>
<h2 id="%C2%A0BaseTask.cpp">🌈BaseTask.cpp</h2>
<ul><li>基类配置 </li></ul>
<pre><code class="language-cpp">#include "BaseTask.h"

BaseTask::BaseTask(char* data)
{
	bzero(this-&gt;data, sizeof(this-&gt;data));//清空
	memcpy(this-&gt;data, data, sizeof(data));
}

BaseTask::~BaseTask()
{
	delete this-&gt;data;//清除释放
}
</code></pre>
<h1 id="%E4%B8%89%E3%80%81%E6%B5%8B%E8%AF%95%E6%95%88%E6%9E%9C">三、测试效果</h1>
<ul><li>通过Linux连接VS进行跨平台编程，我们可以清晰的看到有几个线程是在做任务，几个线程是空闲的，整个过程就很清晰直观的展现出来了，如下动图所示： </li></ul>
<p><img alt="" height="1008" src="https://img-blog.csdnimg.cn/e6c67342a32a47cfa29a80ec5ac9ef23.gif" width="1200"/></p>
<ul><li>10条线程做30个任务的全部记录，如下如所示：</li></ul>
<p><img alt="" height="1200" src="image\db32f20cc97e4fa79238cc50ae787596.png" width="963"/></p>
<h1 id="%E5%9B%9B%E3%80%81%E6%80%BB%E7%BB%93">四、总结</h1>
<h2 id="%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%A5%BD%E5%A4%84">📌创建线程池的好处</h2>
<ul><li>线程池的使用，能让我们搭建的高并发服务器真正意义上做到高并发</li></ul>
<blockquote>
<ul><li><strong><span style="color:#956fe7;">降低资源消耗</span></strong></li></ul>
<p>        通过重复利用自己创建的线程降低线程创建和销毁造成的消耗</p>
<ul><li><strong><span style="color:#956fe7;">提高响应速度</span></strong></li></ul>
<p>        当任务到达时，任务可以不需要等待线程创建和销毁就能立即执行</p>
<ul><li><span style="color:#956fe7;"><strong>提高线程的可管理性</strong></span></li></ul>
<p>        线程式稀缺资源，如果无限的创建线程，不仅会消耗资源，还会降低系统的稳定性</p>
<p>        使用线程池可以进行统一分配，调优和监控</p>
</blockquote>
<p></p>
<p><span style="color:#38d8f0;"><strong><em>以上就是本文的全部内容啦！如果对您有帮助，麻烦点赞啦！收藏啦！欢迎各位评论区留言</em>！！！</strong></span></p>
<p style="text-align:center;"><img alt="" height="375" src="https://img-blog.csdnimg.cn/d65b1c3c42934093b5517179f115e8d1.gif" width="667"/></p>
<p></p>
</div>
</div>