<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<p id="main-toc"><strong>目录</strong></p>
<p id="-toc" style="margin-left:0px;"></p>
<p id="1%E3%80%81%E5%8F%8D%E5%B0%84%E4%BB%8B%E7%BB%8D-toc" style="margin-left:0px;"><a href="#1%E3%80%81%E5%8F%8D%E5%B0%84%E4%BB%8B%E7%BB%8D">1、反射介绍</a></p>
<p id="2%E3%80%81%E5%8F%8D%E5%B0%84API-toc" style="margin-left:0px;"><a href="#2%E3%80%81%E5%8F%8D%E5%B0%84API">2、反射API</a></p>
<p id="2.1%20%E8%8E%B7%E5%8F%96%E7%B1%BB%E5%AF%B9%E5%BA%94%E7%9A%84%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%89%E7%A7%8D%EF%BC%89-toc" style="margin-left:40px;"><a href="#2.1%20%E8%8E%B7%E5%8F%96%E7%B1%BB%E5%AF%B9%E5%BA%94%E7%9A%84%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%89%E7%A7%8D%EF%BC%89">2.1 获取类对应的字节码的对象（三种）</a></p>
<p id="2.2%20%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#2.2%20%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95">2.2 常用方法</a></p>
<p id="3%E3%80%81%E5%8F%8D%E5%B0%84%E7%9A%84%E5%BA%94%E7%94%A8-toc" style="margin-left:0px;"><a href="#3%E3%80%81%E5%8F%8D%E5%B0%84%E7%9A%84%E5%BA%94%E7%94%A8">3、反射的应用</a></p>
<p id="3.1%20%E5%88%9B%E5%BB%BA%20%3A%20%E6%B5%8B%E8%AF%95%E7%89%A9%E6%96%99%E7%B1%BB-toc" style="margin-left:40px;"><a href="#3.1%20%E5%88%9B%E5%BB%BA%20%3A%20%E6%B5%8B%E8%AF%95%E7%89%A9%E6%96%99%E7%B1%BB">3.1 创建 : 测试物料类</a></p>
<p id="3.2%20%E8%8E%B7%E5%8F%96%E7%B1%BB%E5%AF%B9%E8%B1%A1-toc" style="margin-left:40px;"><a href="#3.2%20%E8%8E%B7%E5%8F%96%E7%B1%BB%E5%AF%B9%E8%B1%A1">3.2 获取类对象</a></p>
<p id="3.3%20%E8%8E%B7%E5%8F%96%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-toc" style="margin-left:40px;"><a href="#3.3%20%E8%8E%B7%E5%8F%96%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F">3.3 获取成员变量</a></p>
<p id="3.4%20%E9%80%9A%E8%BF%87%E5%AD%97%E8%8A%82%E7%A0%81%E5%AF%B9%E8%B1%A1%E8%8E%B7%E5%8F%96%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#3.4%20%E9%80%9A%E8%BF%87%E5%AD%97%E8%8A%82%E7%A0%81%E5%AF%B9%E8%B1%A1%E8%8E%B7%E5%8F%96%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95">3.4 通过字节码对象获取类的成员方法</a></p>
<p id="3.5%20%E9%80%9A%E8%BF%87%E5%AD%97%E8%8A%82%E7%A0%81%E5%AF%B9%E8%B1%A1%E8%8E%B7%E5%8F%96%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#3.5%20%E9%80%9A%E8%BF%87%E5%AD%97%E8%8A%82%E7%A0%81%E5%AF%B9%E8%B1%A1%E8%8E%B7%E5%8F%96%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95">3.5 通过字节码对象获取类的构造方法</a></p>
<p id="4%E3%80%81%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1-toc" style="margin-left:0px;"><a href="#4%E3%80%81%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1">4、创建对象</a></p>
<hr id="hr-toc"/>
<p></p>
<h1 id="1%E3%80%81%E5%8F%8D%E5%B0%84%E4%BB%8B%E7%BB%8D">1、反射介绍</h1>
<p>        Reflection(反射) 是 Java 程序开发语言的特征之一，它允许运行中的 Java 程序对自身进行检查。被private封装的资源只能类内部访问，外部是不行的，但反射能直接操作类私有属性。反射可以在运行时获取一个类的所有信息，（包括成员变量，成员方法，构造器等），并且可以操纵类的字段、方法、构造器等部分。</p>
<p>        要想解剖一个类，必须先要获取到该类的字节码文件对象。而解剖使用的就是Class类中的方法。所以先要获取到每一个字节码文件对应的Class类型的对象。</p>
<p>        <strong><span style="color:#956fe7;">反射就是把java类中的各种成分映射成一个个的Java对象</span></strong>。<br/>         例如：一个类有：成员变量、方法、构造方法、包等等信息，利用反射技术可以对一个类进行解剖，把一个个组成部分映射成一个个对象。（其实：一个类中这些成员方法、构造方法、在加入类中都有一个类来描述）<br/>         <strong>加载的时候：</strong>Class对象的由来是将 .class 文件读入内存，并为之创建一个Class对象。</p>
<p>        <span style="color:#fe2c24;"><strong>Class类</strong></span></p>
<p>        <span style="color:#956fe7;"><strong>Class 类的实例表示正在运行的 Java 应用程序中的类和接口</strong></span>。也就是jvm中有N多的实例每个类都有该Class对象。（包括基本数据类型）<br/>         Class 没有公共构造方法。Class 对象是在加载类时由 Java 虚拟机以及通过调用类加载器中的defineClass 方法自动构造的。也就是这不需要我们自己去处理创建，JVM已经帮我们创建好了。</p>
<p>        我们知道Spring框架可以帮我们创建和管理对象。需要对象时，我们无需自己手动new对象，直接从Spring提供的容器中的Beans获取即可。<strong>Beans底层其实就是一个Map&lt;String,Object&gt;，最终通过getBean(“user”)来获取</strong>。而这其中最核心的实现就是利用反射技术。   </p>
<p><em><strong><span style="color:#fe2c24;">        Bean</span></strong></em></p>
<p><em>        1、Java面向对象，对象有方法和属性，那么就需要<strong>对象实例来调用方法和属性（即实例化）；</strong></em></p>
<p><em>        2、凡是有方法或属性的类都需要实例化，这样才能具象化去使用这些方法和属性；</em></p>
<p><em>        3、规律：<strong><span style="color:#956fe7;">凡是子类及带有方法或属性的类都要加上注册Bean到Spring IoC的注解</span>；（</strong>@Component , @Repository , @ Controller , @Service , @Configration<strong>）</strong></em></p>
<p><em>        4、<span style="color:#956fe7;">把Bean理解为类的代理或代言人（实际上确实是通过反射、代理来实现的），这样它就能代表类拥有该拥有的东西了</span></em></p>
<p><em>        5、在Spring中，<strong>你标识一个@符号，那么Spring就会来看看，并且从这里拿到一个Bean（注册）或者给出一个Bean（使用）</strong></em></p>
<h1 id="2%E3%80%81%E5%8F%8D%E5%B0%84API">2、反射API</h1>
<h2 id="2.1%20%E8%8E%B7%E5%8F%96%E7%B1%BB%E5%AF%B9%E5%BA%94%E7%9A%84%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%89%E7%A7%8D%EF%BC%89">2.1 获取类对应的字节码的对象（三种）</h2>
<p><strong>①</strong> 调用某个类的对象的getClass()方法，即：对象.getClass()；</p>
<pre><code class="language-java">Person p = new Person();
Class clazz = p.getClass();</code></pre>
<p><strong><span style="color:#fe2c24;">        注意：</span></strong>此处使用的是Object类中的getClass()方法，因为所有类都继承Object类，所以调用Object类中的getClass()方法来获取。</p>
<p><strong>②</strong> 调用类的class属性类获取该类对应的Class对象，即：类名.class</p>
<pre><code class="language-java">Class clazz = Person.class;</code></pre>
<p><strong>③</strong> 使用Class类中的forName()静态方法（最安全，性能最好）即：Class.forName(“类的全路径”)</p>
<pre><code class="language-java">Class clazz = Class.forName("类的全路径");</code></pre>
<p><strong><span style="color:#fe2c24;">        注意：</span></strong>在运行期间，一个类，只有一个Class对象产生。</p>
<p>        三种方式常用第三种，第一种对象都有了还要反射干什么。第二种需要导入类的包，依赖太强，不导包就抛编译错误。</p>
<h2 id="2.2%20%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95">2.2 常用方法</h2>
<p>        当我们获得了想要操作的类的Class对象后，可以通过Class类中的方法获取和查看该类中的方法和属性。</p>
<pre><code class="language-java">//获取包名、类名
clazz.getPackage().getName()//包名
clazz.getSimpleName()//类名
clazz.getName()//完整类名

//获取成员变量定义信息
getFields()//获取所有公开的成员变量,包括继承变量
getDeclaredFields()//获取本类定义的成员变量,包括私有,但不包括继承的变量
getField(变量名)
getDeclaredField(变量名)

//获取构造方法定义信息
getConstructor(参数类型列表)//获取公开的构造方法
getConstructors()//获取所有的公开的构造方法
getDeclaredConstructors()//获取所有的构造方法,包括私有
getDeclaredConstructor(int.class,String.class)

//获取方法定义信息
getMethods()//获取所有可见的方法,包括继承的方法
getMethod(方法名,参数类型列表)
getDeclaredMethods()//获取本类定义的的方法,包括私有,不包括继承的方法
getDeclaredMethod(方法名,int.class,String.class)

//反射新建实例
clazz.newInstance();//执行无参构造创建对象
clazz.newInstance(222,"韦小宝");//执行有参构造创建对象
clazz.getConstructor(int.class,String.class)//获取构造方法

//反射调用成员变量
clazz.getDeclaredField(变量名);//获取变量
clazz.setAccessible(true);//使私有成员允许访问
f.set(实例,值);//为指定实例的变量赋值,静态变量,第一参数给null
f.get(实例);//访问指定实例变量的值,静态变量,第一参数给null

//反射调用成员方法
Method m = Clazz.getDeclaredMethod(方法名,参数类型列表);
m.setAccessible(true);//使私有方法允许被调用
m.invoke(实例,参数数据);//让指定实例来执行该方法</code></pre>
<h1 id="3%E3%80%81%E5%8F%8D%E5%B0%84%E7%9A%84%E5%BA%94%E7%94%A8">3、反射的应用</h1>
<h2 id="3.1%20%E5%88%9B%E5%BB%BA%20%3A%20%E6%B5%8B%E8%AF%95%E7%89%A9%E6%96%99%E7%B1%BB">3.1 测试物料类</h2>
<p>创建包: com.reflection<br/> 创建类: Student.java*</p>
<pre><code class="language-java">package com.review;
/*本类用于复习反射的物料类*/
public class Student {
    //1.定义成员变量
    private String name;
    public int age;

    //2.给被封装属性提供get与set方法
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }

    //3.生成本类的无参构造与全参构造
    public Student(){}
    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }
    //4.提供本类的普通方法
    public void play(){
        System.out.println("不玩游戏，学Java！");
    }
    public void sunDay(int n){
        System.out.println("卷起来，没有假！");
    }
    //5.为了查看学生对象的具体属性与属性值，重写toString()
    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}</code></pre>
<h2 id="3.2%20%E8%8E%B7%E5%8F%96%E7%B1%BB%E5%AF%B9%E8%B1%A1">3.2 获取类对象</h2>
<p>由于经常使用的是第三种方法，所以以下使用第三种。</p>
<p>创建包: com.reflection<br/> 创建类: TestReflect.java</p>
<pre><code class="language-java">/*本类用于反射的测试*/
public class TestReflect {
    //1.可以创建程序的入口函数main()--此处不用
    //2.通过单元测试方法，获取目标类Student对应的字节码对象
    @Test
    public void getClazz() throws ClassNotFoundException {
        //练习获取字节码对象的3种方式
        Class&lt;?&gt; clazz1 = Class.forName("com.review.Student");
        Class&lt;?&gt; clazz2 = Student.class;
        Class&lt;?&gt; clazz3 = new Student().getClass();

        //打印的是Student类对应的字节码对象
        System.out.println(clazz1);//class com.reflection.Student
        //获取Student类对应的字节码对象clazz1的名字
        System.out.println(clazz1.getName());//com.reflection.Student
        //通过Student类对应的字节码对象，获取Student类的类名
        System.out.println(clazz1.getSimpleName());
        //通过Student类对应的字节码对象，获取Student类对应的包对象
        System.out.println(clazz1.getPackage());
        //通过Student类对应的字节码对象，先获取Student类对应的包对象，再获取这个包对象的名字
        System.out.println(clazz1.getPackage().getName());
    }
}</code></pre>
<h2 id="3.3%20%E8%8E%B7%E5%8F%96%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F">3.3 获取成员变量</h2>
<pre><code class="language-java">/**本类用来测试反射*/
public class TestReflect {
	//3.通过单元测试方法练习引用类型数组的定义与遍历
    @Test
    public void getStu() {
        //1.创建Student类的3个对象
        Student s1 = new Student("张三", 3);
        Student s2 = new Student("李四", 4);
        Student s3 = new Student("王五", 5);
        //2.创建数组将刚刚的3个对象存入数组中
        Student[] s = {s1, s2, s3};
        //3.直接打印数组，查看数组中的元素
        System.out.println(Arrays.toString(s));
        //4.遍历学生数组，拿到每一个学生对象，做进一步的操作
        for (Student stu : s) {
            //System.out.println(stu);
            stu.play();//通过遍历到的对象，执行play()
            System.out.println(stu.age);//通过遍历到的对象，打印age属性
        }
    }

	//4.通过单元测试方法，获取Student类中的成员变量
    @Test
    public void getFie() throws ClassNotFoundException {
        //1.获取Student类对应的字节码对象
        Class&lt;?&gt; clazz = Class.forName("com.review.Student");
        //2.通过Student类对应的字节码对象获取Student类中的成员变量们
        Field[] fs = clazz.getFields();
        //3.遍历数组，获取Student类中的每个成员变量的具体信息
        /*注意！目前成员变量的修饰符必须是public的才能获取到*/
        for(Field f : fs){
            System.out.println(f.getName());//通过本轮循环到的字段对象获取字段名
            System.out.println(f.getType());//通过本轮循环到的字段对象获取字段的类型
        }

    }
}</code></pre>
<h2 id="3.4%20%E9%80%9A%E8%BF%87%E5%AD%97%E8%8A%82%E7%A0%81%E5%AF%B9%E8%B1%A1%E8%8E%B7%E5%8F%96%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95">3.4 通过字节码对象获取类的成员方法</h2>
<pre><code class="language-java">/**本类用来测试反射*/
public class TestReflect {
    //5.通过单元测试方法，获取Student类中的成员方法
    @Test
    public void getFunction() {
        //1.获取Student类对应的字节码对象
        Class&lt;?&gt; clazz = Class.forName("com.review.Student");
        //2.通过Student类对应的字节码对象获取Student类中的成员方法们
        Method[] ms = clazz.getMethods();
        //3.通过高效for循环遍历数组，拿到每一个方法对象
        for (Method m : ms) {
            System.out.println(m);//直接打印遍历到的方法对象
            System.out.println(m.getName());//通过方法对象获取方法名
            Class&lt;?&gt;[] pt = m.getParameterTypes();//通过方法对象获取方法所有参数的数组
            System.out.println(Arrays.toString(pt));//打印方法参数的数组
        }

    }
}</code></pre>
<h2 id="3.5%20%E9%80%9A%E8%BF%87%E5%AD%97%E8%8A%82%E7%A0%81%E5%AF%B9%E8%B1%A1%E8%8E%B7%E5%8F%96%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95">3.5 通过字节码对象获取类的构造方法</h2>
<pre><code class="language-java">/**本类用来测试反射*/
public class TestReflect {
    //6.通过单元测试方法，获取Student类中的构造方法
    @Test
    public void getCons() {
        //1.获取字节码对象
        Class&lt;?&gt; clazz = Class.forName("com.review.Student");
        //2.通过字节码对象获取目标类Student的构造方法们
        Constructor&lt;?&gt;[] cs = clazz.getConstructors();
        //3.通过高效for循环遍历数组
        for(Constructor c : cs){
            System.out.println(c.getName());//打印本轮遍历到的构造方法的名字
            Class[] pt = c.getParameterTypes();//通过本轮遍历到的构造函数对象获取构造函数的参数类型
            System.out.println(Arrays.toString(pt));//打印参数类型
        }
    }
}</code></pre>
<h1 id="4%E3%80%81%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1">4、创建对象</h1>
<pre><code class="language-java">/**本类用来测试反射*/
public class TestReflect {
//7.通过单元测试方法，创建Student目标类的对象
    @Test
    public void getObject() throws Exception {
        //1.获取字节码对象
        Class&lt;?&gt; clazz = Class.forName("com.review.Student");
        
        //2.通过反射技术创建目标类的对象,注意抛出异常
        /*反射创建对象方案1：
            使用 目标类 的 无参构造 创建对象
        */
        Object o = clazz.newInstance();
        System.out.println(o);//这一步已经获取到了对象Student{name='null', age=0}

        /*反射创建对象方案2：
            使用 目标类 的 全参构造 创建对象
        * 思路：
        * 1.先获取指定的构造函数对象,注意需要指定构造函数的参数，传入的是.class字节码对象
        * 2.通过刚刚获取到的构造函数对象创建Student目标类的对象，并且给对象的属性赋值
        * */

        //3.获取目标类中指定的全参构造
        Constructor&lt;?&gt; c = clazz.getConstructor(String.class, int.class);
        //System.out.println(c);

        //4.通过获取到的构造函数：创建对象 + 给对象的属性赋值
        Object o2 = c.newInstance("赵六", 6);
        System.out.println(o2);
    }
}
</code></pre>
<p>参考链接1：<a href="https://blog.csdn.net/sinat_38259539/article/details/71799078" title="Java基础之—反射（非常重要）_敬业小码哥的博客-CSDN博客_jvav">Java基础之—反射（非常重要）_敬业小码哥的博客-CSDN博客_jvav</a></p>
<p>参考链接2：<a href="https://blog.csdn.net/weixin_43884234/article/details/115056812" title="一起学JAVA 反射学习(超详细)_程序媛 泡泡的博客-CSDN博客_java反射技术">一起学JAVA 反射学习(超详细)_程序媛 泡泡的博客-CSDN博客_java反射技术</a></p>
</div>
</div>