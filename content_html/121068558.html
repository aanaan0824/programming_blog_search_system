<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<h2><span style="color:#1a439c;">HashSet基础概念</span></h2>
<p>HashSet 是 <strong><span style="color:#ed7976;"><code>System.Collections.Generic</code> </span></strong>命名空间下的 <code>HashSet&lt;T&gt;</code> 类，是一个高性能且无序的集合。</p>
<p>因为HashSet是无序的，所以它既不能做排序操作，又不能像数组那样索引。在 <span style="color:#be191c;"><span style="background-color:#fefcd8;">HashSet 上只能使用foreach</span></span>来进行迭代，而无法使用for循环。</p>
<p>HashSet中的元素不重复（可以存放单一的null），即具有<span style="color:#be191c;"><span style="background-color:#fefcd8;">元素唯一性，</span></span>若向 HashSet 中插入重复元素，其内部会忽视此次操作，不会报出异常。因此若想拥有一个具有唯一值的集合，HashSet将会是一个具有超高效检索性能的极佳选择（例子：见Leecode刷题第三题）。</p>
<pre><code>static void Main(string[] args)
        {
            HashSet&lt;string&gt; hashSet = new HashSet&lt;string&gt;();
            hashSet.Add("A");
            hashSet.Add("B");
            hashSet.Add("C");
            hashSet.Add("D");
            hashSet.Add("D");
            Console.WriteLine("The number of elements is: {0}", hashSet.Count);
            Console.ReadKey();
        }

————————————————
版权声明：本文为CSDN博主「一线码农」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/huangxinchen520/article/details/111477946</code></pre>
<p>例如上述这段代码的输出结果就是：ABCD，最后一个重复的D被忽略了。</p>
<h2><span style="color:#1a439c;"><strong>HashSet的一些常用方法：</strong></span></h2>
<p>1）在HashSet中查找是否含有某元素：Contains方法</p>
<p>示例：</p>
<pre><code>hashSet.Contains("D")</code></pre>
<p>2）在HashSet中移除某元素：Remove 方法</p>
<p>示例：</p>
<pre><code>hashSet.Remove(item);</code></pre>
<p>3）删除 HashSet 中的所有元素： Clear 方法</p>
<h3><span style="color:#79c6cd;">HashSet对于集合Set的一些操作：</span></h3>
<p>4）判断 HashSet 是否为某一个集合的完全子集：IsProperSubsetOf方法</p>
<pre><code>HashSet&lt;string&gt; setA = new HashSet&lt;string&gt;() { "A", "B", "C", "D" };
HashSet&lt;string&gt; setB = new HashSet&lt;string&gt;() { "A", "B", "C", "X" };
HashSet&lt;string&gt; setC = new HashSet&lt;string&gt;() { "A", "B", "C", "D", "E" };
if (setA.IsProperSubsetOf(setC)) //是子集输出1，不是输出0
   Console.WriteLine("setC contains all elements of setA.");
if (!setA.IsProperSubsetOf(setB))
   Console.WriteLine("setB does not contains all elements of setA.");
</code></pre>
<p>5）集合的合并：UnionWith方法</p>
<pre><code>HashSet&lt;string&gt; setA = new HashSet&lt;string&gt;() { "A", "B", "C", "D", "E" };
HashSet&lt;string&gt; setB = new HashSet&lt;string&gt;() { "A", "B", "C", "X", "Y" };
setA.UnionWith(setB);
foreach(string str in setA)
{
   Console.WriteLine(str);
}
//最终setA的输出结果是ABCDEXY</code></pre>
<p>最终setA会输出setA和setB中的所有元素</p>
<p>6）两个 HashSet 的交集：IntersectWith 方法</p>
<pre><code>setA.IntersectWith(setB);</code></pre>
<p>输出结果是setA和setB集合中都有的元素</p>
<p>7）集合减，时间复杂度是 O(N)：ExceptWith 方法</p>
<pre><code>setA.ExceptWith(setB);</code></pre>
<p>输出setA集合中有但setB集合中没有的元素</p>
<p>8）两个集合都不全有的元素：SymmetricExceptWith 方法</p>
<pre><code>HashSet&lt;string&gt; setA = new HashSet&lt;string&gt;() { "A", "B", "C", "D", "E" };
HashSet&lt;string&gt; setB = new HashSet&lt;string&gt;() { "A", "X", "C", "Y" };
setA.SymmetricExceptWith(setB);
foreach (string str in setA)
{
  Console.WriteLine(str);
}
//对于这个示例，最终输出结果是BDEXY</code></pre>
</div>
</div>