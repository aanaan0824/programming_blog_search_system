<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<p id="main-toc"><strong>目录</strong></p>
<p id="STL%E7%AE%80%E4%BB%8B-toc" style="margin-left:0px;"><a href="#STL%E7%AE%80%E4%BB%8B">STL简介</a></p>
<p id="string%E7%B1%BB%E7%AE%80%E4%BB%8B-toc" style="margin-left:0px;"><a href="#string%E7%B1%BB%E7%AE%80%E4%BB%8B">string类简介</a></p>
<p style="margin-left:0px;"></p>
<p id="%E2%85%A1.%C2%A0%C2%A0string%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3-toc" style="margin-left:0px;"><a href="#%E2%85%A1.%C2%A0%C2%A0string%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3">Ⅰ.  string类的常用接口</a></p>
<p id="1%E3%80%81%E5%BA%93%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E5%BA%93%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0">string库函数中的构造</a></p>
<p id="%E8%A1%A5%E5%85%85%EF%BC%9A%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E6%94%AF%E6%8C%81%E4%BB%8Epos%E5%BC%80%E5%A7%8B%EF%BC%8C%E5%88%9D%E5%A7%8B%E5%8C%96npos%E4%B8%AA%E5%AD%97%E7%AC%A6-toc" style="margin-left:80px;"><a href="#%E8%A1%A5%E5%85%85%EF%BC%9A%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E6%94%AF%E6%8C%81%E4%BB%8Epos%E5%BC%80%E5%A7%8B%EF%BC%8C%E5%88%9D%E5%A7%8B%E5%8C%96npos%E4%B8%AA%E5%AD%97%E7%AC%A6">补充：拷贝构造支持从pos开始，初始化npos个字符</a></p>
<p style="margin-left:80px;"></p>
<p id="0x02%C2%A0%20sting%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%B9%E9%87%8F%E6%93%8D%E4%BD%9C-toc" style="margin-left:0px;"><a href="#0x02%C2%A0%20sting%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%B9%E9%87%8F%E6%93%8D%E4%BD%9C">Ⅱ. sting类对象的容量操作</a></p>
<p id="1%E3%80%81size()%E4%B8%8Elength()%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:40px;"><a href="#1%E3%80%81size%28%29%E4%B8%8Elength%28%29%E7%9A%84%E5%8C%BA%E5%88%AB">1、size()与length()的区别</a></p>
<p id="2%E3%80%81%E8%BF%94%E5%9B%9E%E7%A9%BA%E9%97%B4%E6%80%BB%E5%A4%A7%E5%B0%8F%E7%9A%84%20capacity()-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E8%BF%94%E5%9B%9E%E7%A9%BA%E9%97%B4%E6%80%BB%E5%A4%A7%E5%B0%8F%E7%9A%84%20capacity%28%29">2、返回空间总大小的 capacity()</a></p>
<p id="3%E3%80%81%E6%B8%85%E7%A9%BA%E6%9C%89%E6%95%88%E5%AD%97%E7%AC%A6%E7%9A%84%20clear()-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E6%B8%85%E7%A9%BA%E6%9C%89%E6%95%88%E5%AD%97%E7%AC%A6%E7%9A%84%20clear%28%29">3、清空有效字符的 clear()</a></p>
<p id="4%E3%80%81%C2%A0%20%E8%B0%83%E6%95%B4%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%A7%E5%B0%8F%C2%A0resize()-toc" style="margin-left:40px;"><a href="#4%E3%80%81%C2%A0%20%E8%B0%83%E6%95%B4%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%A7%E5%B0%8F%C2%A0resize%28%29">4、  调整字符串大小 resize()</a></p>
<p style="margin-left:40px;"><a href="#5%E3%80%81%E8%AF%B7%E6%B1%82%E6%9B%B4%E6%94%B9%E5%AE%B9%E9%87%8Freserve%28%29">5、请求更改容量reserve()</a></p>
<p style="margin-left:40px;"></p>
<p id="0x03%C2%A0%20string%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%8F%8A%E9%81%8D%E5%8E%86%E6%93%8D%E4%BD%9C-toc" style="margin-left:0px;"><a href="#0x03%C2%A0%20string%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%8F%8A%E9%81%8D%E5%8E%86%E6%93%8D%E4%BD%9C">Ⅲ. string类对象的访问及遍历操作</a></p>
<p id="1%E3%80%81%E8%AE%BF%E9%97%AE%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E7%AC%A6%E7%9A%84%20operator%5B%5D%20%E5%92%8C%20at()-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E8%AE%BF%E9%97%AE%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E7%AC%A6%E7%9A%84%20operator%5B%5D%20%E5%92%8C%20at%28%29">1、访问字符串字符的 operator[] 和 at()</a></p>
<p id="2%E3%80%81%E5%88%9D%E8%AF%86%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8Ebegin()%20%5C%20end()%20%5C%20rbegin()%20%5C%20rend()-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E5%88%9D%E8%AF%86%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8Ebegin%28%29%20%5C%20end%28%29%20%5C%20rbegin%28%29%20%5C%20rend%28%29">2、初识迭代器与begin() \ end() \ rbegin() \ rend()</a></p>
<p id="3%E3%80%81%E8%8C%83%E5%9B%B4for-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E8%8C%83%E5%9B%B4for">3、范围for</a></p>
<p style="margin-left:40px;"></p>
<p id="0x04%C2%A0%20string%20%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E6%93%8D%E4%BD%9C-toc" style="margin-left:0px;"><a href="#0x04%C2%A0%20string%20%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E6%93%8D%E4%BD%9C">Ⅳ.string 类对象的修改操作</a></p>
<p id="1%E3%80%81push_back()%20append()%20operator%2B%3D%E7%9A%84%E7%94%A8%E6%B3%95-toc" style="margin-left:40px;"><a href="#1%E3%80%81push_back%28%29%20append%28%29%20operator%2B%3D%E7%9A%84%E7%94%A8%E6%B3%95">1、string赋值与拼接push_back() append() operator+=的用法</a></p>
<p id="2%E3%80%81%E8%BF%94%E5%9B%9EC%E6%A0%BC%E5%BC%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%20c_str-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E8%BF%94%E5%9B%9EC%E6%A0%BC%E5%BC%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%20c_str">2、返回C格式字符串的 c_str</a></p>
<p id="3%E3%80%81%E8%BF%BD%E6%9F%A5%E5%AD%97%E7%AC%A6%E4%BD%8D%E7%BD%AE%E7%9A%84%20find()%20%E5%92%8C%E7%94%9F%E6%88%90%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%20substr()-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E8%BF%BD%E6%9F%A5%E5%AD%97%E7%AC%A6%E4%BD%8D%E7%BD%AE%E7%9A%84%20find%28%29%20%E5%92%8C%E7%94%9F%E6%88%90%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%20substr%28%29">3、追查字符位置的 find() 和生成子字符串的 substr()</a></p>
<p id="0x06%20%E5%80%92%E7%9D%80%E8%BF%BD%E6%9D%80%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%20rfind()%C2%A0%C2%A0-toc" style="margin-left:80px;"><a href="#0x06%20%E5%80%92%E7%9D%80%E8%BF%BD%E6%9D%80%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%20rfind%28%29%C2%A0%C2%A0">反向追查字符串的 rfind()  </a></p>
<p id="4%E3%80%81string%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83%E5%92%8C%E6%9B%BF%E6%8D%A2%20-%C2%A0replace()%20compare()-toc" style="margin-left:40px;"><a href="#4%E3%80%81string%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83%E5%92%8C%E6%9B%BF%E6%8D%A2%20-%C2%A0replace%28%29%20compare%28%29">4、string字符串比较和替换 - replace() compare()</a></p>
<p id="5%E3%80%81%C2%A0string%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4%20-%C2%A0insert()%C2%A0erase()-toc" style="margin-left:40px;"><a href="#5%E3%80%81%C2%A0string%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4%20-%C2%A0insert%28%29%C2%A0erase%28%29">5、 string插入和删除 - insert() erase()</a></p>
<p style="margin-left:40px;"></p>
<p id="%E2%85%A4.string%20%E7%B1%BB%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><a href="#%E2%85%A4.string%20%E7%B1%BB%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0">Ⅴ.string 类非成员函数的实现</a></p>
<p id="%E2%85%A5.%20operator%20%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD-toc" style="margin-left:40px;"><a href="#%E2%85%A5.%20operator%20%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">1.operator 运算符重载</a></p>
<p id="%E2%85%A6.%C2%A0%20%E6%B5%81%E6%8F%92%E5%85%A5%E5%92%8C%E6%B5%81%E6%8F%90%E5%8F%96-toc" style="margin-left:40px;"><a href="#%E2%85%A6.%C2%A0%20%E6%B5%81%E6%8F%92%E5%85%A5%E5%92%8C%E6%B5%81%E6%8F%90%E5%8F%96">2.流插入和流提取</a></p>
<p id="%E2%85%A7.%C2%A0%20%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81-toc" style="margin-left:0px;"><a href="#%E2%85%A7.%C2%A0%20%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81">完整代码</a></p>
<hr id="hr-toc"/>
<p></p>
<h1 id="STL%E7%AE%80%E4%BB%8B">STL简介</h1>
<p><br/> STL(standard template libaray-标准模板库)：是C++标准库的重要组成部分，不仅是一个可复用的组件库，而且是一个<strong>包罗数据结构与算法的软件框架</strong></p>
<p>其中包括六大组件：</p>
<ul><li>算法</li><li>容器</li><li>迭代器</li><li>空间适配器</li><li>仿函数</li><li>配接器</li></ul>
<p>而我们这个系列，实现的是各种各样的容器</p>
<p>网上有句话说：“不懂STL，不要说你会C++”。STL是C++中的优秀作品，有了它的陪伴，许多底层的数据结构以及算法都不需要自己重新造轮子，站在前人的肩膀上，健步如飞的快速开发。<br/><img alt="" height="1131" src="image\eeba47b01885424ea3a98e875c43ecc5.png" width="1200"/></p>
<p></p>
<h1 id="string%E7%B1%BB%E7%AE%80%E4%BB%8B"><a href="https://so.csdn.net/so/search?q=string%E7%B1%BB&amp;spm=1001.2101.3001.7020" title="string类">string类</a>简介</h1>
<p><strong>string是c++中表示字符串的容器，其底层的字符串表示方式仍然是以’\0’表示的字符串集合</strong>但是提供了比c语言更多的接口</p>
<p><strong>在使用string类时，必须包含string头文件以及using namespace std</strong></p>
<div>
<div>
<pre><code class="language-cpp">#include &lt;string&gt;       // 使用string类时，需引入头文件 &lt;string&gt;
using namespace std;    // 展开std</code></pre>
</div>
</div>
<p>string是C++风格的字符串，而string本质上是一个类</p>
<p><strong>string和char * 区别：</strong></p>
<ul><li>char * 是一个指针</li><li>string是一个类，类内部封装了char*，管理这个字符串，是一个char*型的容器。</li></ul>
<blockquote>
<p>string成员中包含了以下几个成员：</p>
<ul><li>字符串数组</li><li>字符串的有效字符大小</li><li>字符串容量</li><li>迭代器</li></ul>
<p>对以上点做出以下解释：</p>
<p><strong>迭代器</strong>提供了<strong>遍历整个字符串的方式</strong>，虽然string中的遍历没有迭代器会更加方便。但因为<strong>与STL中其它难以遍历的容器统一，所以string中并没有舍弃迭代器。</strong></p>
<p></p>
<p><strong>容量</strong>指的是类为我们的字符串数组开辟的空间，而有效字符个数指的是我们已经使用<strong>已经存储了元素的容量</strong>大小。</p>
<p></p>
<p>有效字符和容量都<strong>不包括’\0’</strong></p>
</blockquote>
<p>所以，我们模拟实现的字符串类型中，有以下成员：</p>
<div>
<div>
<pre><code class="language-cpp">char* _str;//字符串类型
size_t size;//字符串有效字符大小
size_t capacity;//字符串容量
</code></pre>
</div>
</div>
<p><span style="color:#fe2c24;"><strong>size_t 是 unsigned long long，传-1的实际值是2^64-1 </strong></span></p>
<hr/>
<p> 官方文本文档：</p>
<p><a href="https://cplusplus.com/reference/string/string/?kw=string" title="string类的文档介绍 - C++ Reference (cplusplus.com)">string类的文档介绍 - C++ Reference (cplusplus.com)</a></p>
<p>① string 是表示字符串的字符串类。</p>
<p>② 该类的接口与常规容器的接口基本相同，再添加了一些专门用来操作 string 的常规操作。</p>
<p>③ string在底层上实际是：basic_string 模板类的别名：</p>
<div>
<div>
<pre><code class="language-cpp">typedef basic_string&lt;char, char_traits, allocator&gt;string;</code></pre>
</div>
</div>
<p>④ 不能操作多字节或者变长字符的序列。<br/>  </p>
<p class="img-center"><img alt="" height="169" src="image\93ae75814a0a3ff00f156f49cba26cb2.jpeg" width="169"/></p>
<p></p>
<h1 id="%E2%85%A1.%C2%A0%C2%A0string%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3">Ⅰ.  string类的常用接口</h1>
<p><img alt="" height="377" src="image\164a7027972546fdb132bcb744a3ea1b.png" width="1200"/></p>
<p></p>
<table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td><a href="http://www.cplusplus.com/reference/string/string/string/" title="(constructor) 函数名称">(constructor) 函数名称</a></td><td>功能说明</td></tr><tr><td>string()                           （重点）</td><td>构造空的string类对象，即空字符</td></tr><tr><td>string(const char* s)      （重点）</td><td>用C-string来构造string类对象</td></tr><tr><td>string(size_t n, char c)    </td><td>string类对象中包含n个字符c</td></tr><tr><td>string(const string&amp; s)   （重点）</td><td>拷贝构造函数</td></tr></tbody></table>
<div>
<pre><code class="language-cpp">string()                      // 构造空的string类对象，即非空字符串。
string(cosnt char* s)         // 用C-string来构造string类对象
string(size_t n, char c)      // string类对象中包含n个字符c
string(const string&amp;s)        // 拷贝构造函数</code></pre>
</div>
<h2 id="1%E3%80%81%E5%BA%93%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0">string<a href="https://so.csdn.net/so/search?q=%E5%BA%93%E5%87%BD%E6%95%B0&amp;spm=1001.2101.3001.7020" title="库函数">库函数</a>中的构造</h2>
<p>库函数构造主要有<strong>默认构造</strong>，<strong>含参构造</strong>和<strong>拷贝构造</strong></p>
<p><strong>默认构造</strong>是构造出一个空字符串</p>
<div>
<pre><code class="language-cpp">string s1;
//构造出一个空字符串
</code></pre>
</div>
<p><strong>含参构造</strong>中我们可以传入c语言中的字符串指针或字符串数组类型</p>
<div>
<pre><code class="language-cpp">string s2("hello world!");
//构造出"hello world!字符串"</code></pre>
</div>
<div>
<pre><code class="language-cpp">string(const char* s = "")
	:_size(strlen(s)), _capacity(strlen(s))
{
	_str = new char[_capacity + 1];
	strcpy(_str, s);
}
</code></pre>
</div>
<p></p>
<p>也可以在string中构造n个相同的字符c</p>
<div>
<pre><code class="language-cpp">//string(size_t n,char c)
string s3(10,'a');
//第一个参数是个数n，第二个参数是字符c
//构造出的字符串：aaaaaaaaaa</code></pre>
</div>
<div>
<pre><code class="language-cpp">string(size_t n, char c)
	:_size(n), _capacity(n)
{
	_str = new char[_capacity + 1];
	memset(_str, c, _size);
	_str[_size] = '\0';
}
</code></pre>
</div>
<p></p>
<p><strong>拷贝构造使用某个其它stirng类的引用</strong></p>
<div>
<pre><code class="language-cpp">string s4(s1);//拷贝一份s1到s4中</code></pre>
</div>
<p>string 的拷贝构造： </p>
<div>
<pre><code class="language-cpp">/* s2(s1) */
string(const string&amp; s)
	: _str(new char[strlen(s._str) + 1]) {
	strcpy(_str, s._str);
}</code></pre>
</div>
<p>演示：</p>
<div>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt; 
using namespace std;

//string构造
void test01()
{
	string s1; //创建空字符串，调用无参构造函数
	cout &lt;&lt; "str1 = " &lt;&lt; s1 &lt;&lt; endl;

	const char* str = "hello world";
	string s2(str); //把c_string转换成了string

	cout &lt;&lt; "str2 = " &lt;&lt; s2 &lt;&lt; endl;

	string s3(s2); //调用拷贝构造函数
	cout &lt;&lt; "str3 = " &lt;&lt; s3 &lt;&lt; endl;

	string s4(10, 'a');
	cout &lt;&lt; "str3 = " &lt;&lt; s4 &lt;&lt; endl;
}
int main() {
	test01();
	return 0;
}
</code></pre>
</div>
<p> <img alt="" height="93" src="image\cb435eeea2954a4a8fc98929bfe1d2c0.png" width="233"/>​</p>
<h3 id="%E8%A1%A5%E5%85%85%EF%BC%9A%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E6%94%AF%E6%8C%81%E4%BB%8Epos%E5%BC%80%E5%A7%8B%EF%BC%8C%E5%88%9D%E5%A7%8B%E5%8C%96npos%E4%B8%AA%E5%AD%97%E7%AC%A6"><img alt="" src="image\9dfc678a449e48d496d3f24c348344de.png"/>补充：拷贝构造支持从pos开始，初始化npos个字符</h3>
<p><img alt="" height="25" src="image\3de82214c947489bb757a30467bc5a85.png" width="920"/>​</p>
<p> 我们发现长度 len 缺省值给的是 npos：</p>
<div>
<pre><code class="language-cpp">string (
    const string&amp; str, 
    size_t pos,         // 起始位置
    size_t len = npos   // 长度（缺省值给的npos）
    );</code></pre>
</div>
<blockquote>
<p><img alt="" height="477" src="image\39eed0af06c743dc9c5e015f29bf94e2.png" width="1200"/>​  </p>
<p>这个 npos 你可以理解为是 string 里的一个静态变量，它是 -1。</p>
<p>当你没有指定 len 时，因为 npos 是 -1，而又是 size_t 无符号整型，他长度将会是整形的最大值。</p>
<p>也就是说，如果你不传，它就相当于取整型最大值 2147483647，所以也就相当于取所有字符串了</p>
<div>
<pre><code class="language-cpp">int main(void)
{
	string s1("abcdef123456");
	string s2(s1, 2);       // 从第2个位置开始，初始化npos个长度的字符
	cout &lt;&lt; s2 &lt;&lt; endl;
 
	return 0;
}</code></pre>
</div>
<p></p>
</blockquote>
<p></p>
<p></p>
<h1 id="0x02%C2%A0%20sting%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%B9%E9%87%8F%E6%93%8D%E4%BD%9C">Ⅱ. sting类对象的容量操作</h1>
<table align="left" border="1" cellpadding="1" cellspacing="1"><tbody><tr><td>函数名称</td><td>功能说明</td></tr><tr><td><a href="http://www.cplusplus.com/reference/string/string/size/" title="size">size</a>     （重点）</td><td>返回字符串有效字符长度</td></tr><tr><td><a href="http://www.cplusplus.com/reference/string/string/length/" title="length">length</a></td><td>返回字符串有效字符长度</td></tr><tr><td><a href="http://www.cplusplus.com/reference/string/string/capacity/" title="capacity">capacity</a></td><td>返回空间总大小</td></tr><tr><td><a href="http://www.cplusplus.com/reference/string/string/empty/" title="empty">empty</a>  （重点）</td><td>检测字符串是否为空串，是返回true，否则返回 flase</td></tr><tr><td><a href="http://www.cplusplus.com/reference/string/string/clear/" title="clear">clear</a>    （重点）</td><td> <p>清空有效字符</p> </td></tr><tr><td><a href="http://www.cplusplus.com/reference/string/string/reserve/" title="reserve">reserve</a>（重点）</td><td>为字符串预留空间</td></tr><tr><td><a href="http://www.cplusplus.com/reference/string/string/resize/" title="resize">resize</a>   （重点）</td><td>将有效字符的个数改成n个，多出的空间用字符c填充</td></tr></tbody></table>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<h2 id="1%E3%80%81size()%E4%B8%8Elength()%E7%9A%84%E5%8C%BA%E5%88%AB">1、size()与length()的区别</h2>
<p><img alt="" height="628" src="image\46991d206b264656be9f18c14b1eb315.png" width="608"/>​</p>
<p></p>
<blockquote>
<p>①  size() 和 length() 的计算不包含 \0。</p>
<p>     解释：它不包含最后作为结尾标识符的 \0，告诉你的是有效的字符长度。</p>
<p></p>
<p>②  size() 和 length() 的功能都是返回字符串有效长度，功能上没有区别。</p>
<p>     解释： 这是一个 "历史包袱" 问题。</p>
</blockquote>
<p>总结：size()与length()方法<strong>底层实现原理完全相同</strong>，引入size()的原因是为了与其他容器的接口保持一致，一般情况下基本都是用size()。</p>
<p><img alt="" height="67" src="https://img-blog.csdnimg.cn/img_convert/e21f43b2ab119380e3d75682f42de7ac.gif" width="67"/></p>
<p></p>
<h2 id="2%E3%80%81%E8%BF%94%E5%9B%9E%E7%A9%BA%E9%97%B4%E6%80%BB%E5%A4%A7%E5%B0%8F%E7%9A%84%20capacity()">2、<strong>返回空间总大小的 capacity()</strong></h2>
<blockquote>
<p>返回当前为<a href="https://cplusplus.com/string" title="字符串">字符串</a>分配的存储空间的大小，以<strong>字节</strong>表示。<br/><br/> 此<em>容量</em>不一定等于<a href="https://cplusplus.com/string::length" title="字符串长度">字符串长度</a>。它可以等于或更大，额外的空间允许对象在向<a href="https://cplusplus.com/string" title="字符串">字符串</a>添加新字符时优化其操作。</p>
<p></p>
<p>请注意，此<em>容量</em>并不假定字符串<a href="https://cplusplus.com/string::length" title="的长度">的长度</a>有<a href="https://cplusplus.com/string" title="限制。">限制。</a>当此<em>容量</em>耗尽并且需要更多容量时，它由对象自动扩展（重新分配其存储空间）。<a href="https://cplusplus.com/string" title="字符串">字符串</a><a href="https://cplusplus.com/string::length" title="长度">长度</a>的理论限制由成员<a href="https://cplusplus.com/string::max_size" title="max_size">max_size</a>给出。</p>
</blockquote>
<p>总结：在算法中没什么用处，因为每个编译器分配空间方式都不同，所以值都有所出入</p>
<p></p>
<p></p>
<h2 id="3%E3%80%81%E6%B8%85%E7%A9%BA%E6%9C%89%E6%95%88%E5%AD%97%E7%AC%A6%E7%9A%84%20clear()">3、<strong>清空有效字符的 clear()</strong></h2>
<p>clear：擦除字符串的内容，<a href="https://cplusplus.com/string" title="该字符串">该字符串</a>将成为<a href="https://cplusplus.com/string::empty" title="空字符串">空字符串</a>（<a href="https://cplusplus.com/string::length" title="长度">长度</a>为 0 个字符）</p>
<div>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt; 
using namespace std;

int main()
{
	string s1("abcdef");
    cout &lt;&lt; "清空前: " &lt;&lt; s1 &lt;&lt; endl;
	cout &lt;&lt; s1.size() &lt;&lt; endl;
 	cout &lt;&lt; s1.capacity() &lt;&lt; endl;
	s1.clear();
	cout &lt;&lt; "清空后: " &lt;&lt; s1 &lt;&lt; endl;
	cout &lt;&lt; s1.size() &lt;&lt; endl;
	cout &lt;&lt; s1.capacity() &lt;&lt; endl;
	return 0;
}
</code></pre>
</div>
<p><img alt="" height="215" src="image\56dc5cc8cbf247bf8d4ddf66cc2174f1.png" width="474"/>​</p>
<p> 总结：clear()<strong>只是将string中有效字符清空</strong>，<strong>不改变底层空间大小</strong>。</p>
<p></p>
<h2 id="4%E3%80%81%C2%A0%20%E8%B0%83%E6%95%B4%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%A7%E5%B0%8F%C2%A0resize()">4、  调整字符串大小 resize()</h2>
<div>
<pre><code class="language-cpp">void resize (size_t n);
void resize (size_t n, char c);</code></pre>
</div>
<p>将字符串大小调整为 <em>n</em> 个字符<a href="https://cplusplus.com/string::length" title="的长度">的长度</a>。<br/><br/> 如果 <em>n</em> 小于当前<a href="https://cplusplus.com/string::length" title="字符串长度">字符串长度</a>，则当前值将缩短为其前 <em>n</em> 个字符，并删除超出 <em>n</em> 的字符。</p>
<div>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt; 
using namespace std;

int main()
{
	string s1("abcdef");
    s1.resize(3);
    cout&lt;&lt;s1&lt;&lt;endl;
    s1.resize(30,'1');
	cout&lt;&lt;s1&lt;&lt;endl;
	return 0;
}
</code></pre>
</div>
<p><img alt="" height="144" src="image\9ab56fe229f14701b33ef785d55e8d68.png" width="464"/>​</p>
<p></p>
<p>总结： resize(size_t n) 与 resize(size_t n, char c)都是将字符串中有效字符个数改变到n个，不同的是当字符个数增多时：<strong>resize(n)用0来填充多出的元素空间，resize(size_t n, char c)用字符c来填充多出的元素空间</strong>。</p>
<p>注意：resize在改变元素个数时，如果是将元素个数增多，<strong>可能会改变底层容量的大小</strong>，如果是将元素个数减少，底层空间总大小不变。</p>
<h3 id="resize()%20%E7%9A%84%E5%AE%9E%E7%8E%B0"><br/> resize() 的实现</h3>
<pre><code class="language-cpp">/* resize */
void resize(size_t new_capacity, char init_ch = '\0') {
	// 如果欲增容量比_size小
	if (new_capacity &lt;= _size) {
		_str[new_capacity] = '\0';      // 拿斜杠零去截断
		_size = new_capacity;           // 更新大小
	}
	// 欲增容量比_size大
	else {
		if (new_capacity &gt; _capacity) { 
			reserve(new_capacity);
		}
		// 起始位置，初始化字符，初始化个数
		memset(_str + _size, init_ch, new_capacity - _size);
		_size = _capacity;
		_str[_size] = '\0';
	}
}</code></pre>
<h2 id="5%E3%80%81%E8%AF%B7%E6%B1%82%E6%9B%B4%E6%94%B9%E5%AE%B9%E9%87%8Freserve()">5、请求更改容量reserve()</h2>
<div>
<pre><code class="language-cpp">void reserve (size_t n = 0);</code></pre>
</div>
<blockquote>
<p> 请求将<a href="https://cplusplus.com/string::capacity" title="字符串容量">字符串容量</a>适应计划<a href="https://cplusplus.com/string::size" title="的大小">的大小</a>更改为最多 <em>n</em> 个字符<a href="https://cplusplus.com/string::length" title="的长度">的长度</a>。<br/><br/> 如果 <em>n</em> 大于当前<a href="https://cplusplus.com/string::capacity" title="字符串容量">字符串容量</a>，则该函数会导致容器将其<a href="https://cplusplus.com/string::capacity" title="容量">容量</a>增加到 <em>n</em> 个字符（或更大）。<br/><br/> 在所有其他情况下，它被视为收缩<a href="https://cplusplus.com/string::capacity" title="字符串容量">字符串容量</a>的非约束性请求：容器实现可以自由地进行优化，并使<a href="https://cplusplus.com/string" title="字符串">字符串</a>的<a href="https://cplusplus.com/string::capacity" title="容量">容量</a>大于<em>n</em>。<br/><br/> 此函数对<a href="https://cplusplus.com/string::length" title="字符串长度">字符串长度</a>没有影响，并且无法更改其内容。</p>
</blockquote>
<p>与resize（）的对比： </p>
<p><img alt="" height="721" src="image\43c7ded82e21473eb199d0ce7f8a5208.png" width="759"/>​</p>
<p>可见reserve()仅仅改变容量，不改变长度 </p>
<p></p>
<p>总结： reserve(size_t res_arg=0)：<strong>为string预留空间，不改变有效元素个数</strong>，当reserve的参数小于string的底层空间总大小时，<strong>reserver不会改变容量大小。</strong></p>
<h3 id="0x00%20reserve()%20%E7%9A%84%E5%AE%9E%E7%8E%B0">reserve() 的实现</h3>
<pre><code class="language-cpp">/* 增容：reverse */
void reserve(size_t new_capacity) {
	if (new_capacity &gt; _capacity) {
		char* tmp = new char[new_capacity + 1];  // 开新空间
		strcpy(tmp, _str);                       // 搬运
		delete[] _str;                           // 释放原空间
 
		_str = tmp;                              // 没问题，递交给_str
		_capacity = new_capacity;                // 更新容量
	}
}</code></pre>
<p></p>
<h1 id="0x03%C2%A0%20string%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%8F%8A%E9%81%8D%E5%8E%86%E6%93%8D%E4%BD%9C">Ⅲ. string类对象的访问及遍历操作</h1>
<table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td>函数名称</td><td>功能说明</td></tr><tr><td><a href="http://www.cplusplus.com/reference/string/string/operator%5B%5D/" title="operator[]">operator[]</a></td><td>返回pos位置的字符，const string类对象调用</td></tr><tr><td><a href="http://www.cplusplus.com/reference/string/string/begin/" title="begin">begin</a> + <a href="http://www.cplusplus.com/reference/string/string/end/" title="end">end</a></td><td>begin获取一个字符的迭代器 + end获取最后一个字符下一个位置的迭代器</td></tr><tr><td><a href="http://www.cplusplus.com/reference/string/string/rbegin/" title="rbegin">rbegin</a> + <a href="http://www.cplusplus.com/reference/string/string/rend/" title="rend">rend</a></td><td>rbegin获取一个字符的反向迭代器 + rend获取最后一个字符下一个位置的迭代器</td></tr><tr><td>范围 for</td><td>C++11支持更简洁的范围 for 新遍历方式</td></tr></tbody></table>
<h2 id="1%E3%80%81%E8%AE%BF%E9%97%AE%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E7%AC%A6%E7%9A%84%20operator%5B%5D%20%E5%92%8C%20at()">1、访问字符串字符的 operator[] 和 at()</h2>
<p>如果访问这个字符串的每一个字符，会有： </p>
<div>
<pre><code>for (size_t i = 0; i &lt; s1.size(); i++) {
		cout &lt;&lt; s1[i] &lt;&lt; " ";
	}</code></pre>
</div>
<div>
<pre><code class="language-cpp">cout &lt;&lt; s1[i] &lt;&lt; " ";        
cout &lt;&lt; s1.operator[](i) &lt;&lt; " ";   // 取字符串第i个位置的字符的引用</code></pre>
</div>
<p>string 这里它作为函数调用，这就是 operator[]  ，并且等价于：cout &lt;&lt; s1.operator[](i) &lt;&lt; " ";</p>
<p>operator[] 的底层是这样设计的：</p>
<div>
<pre><code class="language-cpp">char&amp; operator[] (size_t pos)
{
    return _str[pos];
}</code></pre>
</div>
<p> 所以</p>
<p><img alt="" height="441" src="image\d4a5358e862a4d39b0c7959e38a5520d.png" width="454"/>​</p>
<p></p>
<hr/>
<h1 id="at()%C2%A0">at() </h1>
<p>除了 operator[] 还有一个 at() ，at() 也是早期支持的一个接口</p>
<p>它和 operator[] 用处是一样的，at() 是像函数一样去使用的：</p>
<div>
<pre><code class="language-cpp">int main(void)
{
	string s1("hello world");
 
	for (size_t i = 0; i &lt; s1.size(); i++) {
		s1.at(i) += 1;
	}
	cout &lt;&lt; s1 &lt;&lt; endl;
 
	return 0;
}</code></pre>
</div>
<p><strong>at() 和 operator[] 的区别</strong> —— 它们检查越界的方式不一样。</p>
<p> operator[] 是使用<strong>断言</strong>处理的，断言是一种激进的处理手段。</p>
<p>而 at() 是比较温柔的处理方式，如果 pos &gt;= size 就 <strong>throw 一个异常对象</strong>出去。</p>
<p></p>
<h2 id="2%E3%80%81%E5%88%9D%E8%AF%86%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8Ebegin()%20%5C%20end()%20%5C%20rbegin()%20%5C%20rend()">2、初识迭代器与begin() \ end() \ rbegin() \ rend()</h2>
<p>迭代器是 STL 六大组件之一，是用来访问和修改容器的。 </p>
<p><img alt="" height="683" src="image\e612b884fbe64cf59b0f95d7f6f3ca1d.png" width="612"/>​</p>
<p><img alt="" height="64" src="image\e66800e8e12341829d49cc206637b35d.png" width="281"/>​</p>
<p></p>
<p> 同理：</p>
<div>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt; 
using namespace std;

int main(void)
{
	string s1("hello");
	
    // 迭代器
	
  	for (string::reverse_iterator rit=s1.rbegin(); rit!=s1.rend(); ++rit)
    	cout &lt;&lt; *rit;
 
	return 0;
}

</code></pre>
</div>
<blockquote>
<p>输出：olleh</p>
</blockquote>
<p></p>
<p>迭代器遍历的意义：</p>
<ul><li>对于 string，你得会用迭代器，但是一般我们还是喜欢用 下标 + [] 遍历；</li><li>比如 list、map / set  不支持 下标 + [] 遍历，迭代器就排上用场了，这就是迭代器存在的意义。</li><li>迭代器是通用的遍历方式。</li></ul>
<p></p>
<p></p>
<h2 id="3%E3%80%81%E8%8C%83%E5%9B%B4for">3、范围for</h2>
<div>
<span style="color:#777777;"><strong>C++11</strong></span>
<span style="color:#777777;"><strong>支持更简洁的范围</strong></span>
<span style="color:#777777;"><strong>for</strong></span>
<span style="color:#777777;"><strong>的新遍历方式</strong></span>
</div>
<div>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt; 
using namespace std;

int main(void)
{
	string s1("hello");
	for (auto e : s1) {
		cout &lt;&lt; e &lt;&lt; " ";	//遍历
	}
	cout &lt;&lt; endl;

	for (auto e : s1) {    // 无引用修改
		e += 1;
	}
	cout &lt;&lt; "无引用 " &lt;&lt; s1 &lt;&lt; endl;

	for (auto&amp; e : s1) {    // 引用修改
		e += 1;
	}
	cout &lt;&lt; "引用修改 " &lt;&lt; s1 &lt;&lt; endl;

	return 0;
}</code></pre>
</div>
<p><img alt="" height="170" src="image\d9293f19bf784231a71f23e6107c867b.png" width="407"/>​</p>
<p> 详情可看下方连接的<a href="https://blog.csdn.net/qq_61386381/article/details/124952732#t15" title=" Ⅴ. auto关键字(C++11)"> Ⅴ. auto关键字(C++11)</a></p>
<p> <a href="https://blog.csdn.net/qq_61386381/article/details/124952732" title=" C++入门基础总结（最详细）"> C++入门基础总结（最详细）</a></p>
<p></p>
<p></p>
<h1 id="0x04%C2%A0%20string%20%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E6%93%8D%E4%BD%9C">Ⅳ.string 类对象的修改操作</h1>
<table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td>函数名称</td><td>功能说明</td></tr><tr><td><a href="http://www.cplusplus.com/reference/string/string/push_back/" title="push_back">push_back</a></td><td>在字符串后尾插字符c</td></tr><tr><td><a href="http://www.cplusplus.com/reference/string/string/append/" title="append">append</a></td><td>在字符后追加一个字符串</td></tr><tr><td><a href="http://www.cplusplus.com/reference/string/string/operator+=/" title="operator+=">operator+=</a>    （重点）</td><td>在字符串后追加字符串str</td></tr><tr><td><a href="http://www.cplusplus.com/reference/string/string/c_str/" title="c_str">c_str</a>              （重点）</td><td>返回c格式字符串</td></tr><tr><td><a href="http://www.cplusplus.com/reference/string/string/find/" title="find">find</a>  +  <a href="http://www.cplusplus.com/reference/string/string/npos/" title="npos">npos</a>  （重点）</td><td>从字符串pos位置开始往后找字符c，返回该字符自字符串中的位置</td></tr><tr><td><a href="http://www.cplusplus.com/reference/string/string/rfind/" title="rfind">rfind</a></td><td>从字符串pos位置开始往前找字符c，返回该字符在字符串中的位置</td></tr><tr><td><a href="http://www.cplusplus.com/reference/string/string/substr/" title="substr">substr</a></td><td>在str中从pos位置开始，截取n个字符，然后将其返回</td></tr></tbody></table>
<p></p>
<h2 id="1%E3%80%81push_back()%20append()%20operator%2B%3D%E7%9A%84%E7%94%A8%E6%B3%95">1、string赋值与拼接push_back() append() operator+=的用法</h2>
<blockquote>
<p><strong>push_back</strong>：插入一个字符，但只能插入一个字符</p>
<p></p>
<p><strong>append</strong>：可以插入字符串</p>
<p></p>
<p> <strong>operator+=</strong>：可以添加字符、字符串、对象</p>
<p><img alt="" height="251" src="image\bf4d57439263462fbca4db638a295c4e.png" width="1200"/>​</p>
<ul><li><code>string&amp; operator=(const char* s);</code> //char*类型字符串 赋值给当前的字符串</li><li><code>string&amp; operator=(const string &amp;s);</code> //把字符串s赋给当前的字符串</li><li><code>string&amp; operator=(char c);</code> //字符赋值给当前的字符串</li></ul>
</blockquote>
<p>演示：</p>
<div>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt; 
using namespace std;

string s="C++";
string s1="";

int main()
{
	s1.push_back('I');//只能单字符 
	cout&lt;&lt;s1&lt;&lt;endl;
	
	s1.append(" Love ");//插入字符串 
	cout&lt;&lt;s1&lt;&lt;endl;
	
	s1+='C';
 	cout&lt;&lt;s1&lt;&lt;endl;
 	s1+=" and ";
 	cout&lt;&lt;s1&lt;&lt;endl;
 	s1+=s;
 	cout&lt;&lt;s1&lt;&lt;endl;
	//可以添加字符、字符串、对象 
 
	return 0;
}</code></pre>
</div>
<p><img alt="" height="196" src="image\17a59f1517d9422c8a09466268bc8a62.png" width="431"/>​</p>
<p></p>
<h3 id="0x01%C2%A0push_back()%20%E7%9A%84%E5%AE%9E%E7%8E%B0">push_back() 的实现</h3>
<pre><code class="language-cpp">/* 字符串尾插：push_back */
void push_back(char append_ch) {
	if (_size == _capacity) {      // 检查是否需要增容
		reserve(_capacity == 0 ? 4 : _capacity * 2); 
	}
 
	_str[_size] = append_ch;       // 插入要追加的字符
	_size++;
	_str[_size] = '\0';            // 手动添加'\0'
}</code></pre>
<h3 id="0x02%C2%A0append()%20%E7%9A%84%E5%AE%9E%E7%8E%B0">append() 的实现</h3>
<pre><code class="language-cpp">/* 字符串追加：append */
void append(const char* append_str) {
	size_t len = strlen(append_str);     // 计算要追加的字符串的长度
	if (_size + len &gt; _capacity) {       // 检查是否需要增容
		reserve(_size + len);
	}
 
	strcpy(_str + _size, append_str);    // 首字符+大小就是\0位置
	_size += len;                        // 更新大小
}</code></pre>
<h3 id="0x03%C2%A0operator%2B%3D%C2%A0%E7%9A%84%E5%AE%9E%E7%8E%B0"> operator+= 的实现</h3>
<pre><code class="language-cpp">/* operator+= */
string&amp; operator+=(char append_ch) {
	push_back(append_ch);    // 复用push_back
	return *this;
}
string&amp; operator+=(const char* append_str) {
	append(append_str);      // 复用append
	return *this;
}</code></pre>
<p></p>
<p></p>
<p></p>
<p></p>
<h2 id="2%E3%80%81%E8%BF%94%E5%9B%9EC%E6%A0%BC%E5%BC%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%20c_str">2、返回C格式字符串的 c_str</h2>
<p>当我们用printf输出string类型时，就必须用c_str</p>
<p><img alt="" height="427" src="image\2453803e2fdc4c20a11e908157a720ae.png" width="923"/>​</p>
<p></p>
<div>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt; 
using namespace std;

int main() {
	string s1("hello string");
	cout &lt;&lt; s1 &lt;&lt; endl;  // 调用重载的流插入运算符打印的
	printf("%s\n",s1.c_str());
	//printf("%s\n",s1);
	cout &lt;&lt; s1.c_str() &lt;&lt; endl;  
	// 这是调字符串打印的，c_str 是遇到 \0 结束的，
}</code></pre>
</div>
<p><img alt="" height="597" src="image\430c7fc2fe67493b8168dba195a8a24c.png" width="875"/>​</p>
<p> 补充：转成字符串才能取地址时</p>
<div>
<pre><code class="language-cpp">// 获取file后缀
void Test() {
	string file("test.txt"); 
	FILE* pf = fopen(file.c_str(), "w");  
}</code></pre>
</div>
<p>比如这里需要打开文件，fopen 第一个参数要求是 const char*，</p>
<p>所以这里怎么能直接放 string 是不行的，这时候可以用 .c_str()  就可以把字符串的地址返回出来。</p>
<p><img alt="" height="72" src="https://img-blog.csdnimg.cn/img_convert/819d6e90db6bbefc4cfd2d8b4852cbf7.gif" width="94"/></p>
<p></p>
<h2 id="3%E3%80%81%E8%BF%BD%E6%9F%A5%E5%AD%97%E7%AC%A6%E4%BD%8D%E7%BD%AE%E7%9A%84%20find()%20%E5%92%8C%E7%94%9F%E6%88%90%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%20substr()">3、追查字符位置的 find() 和生成子字符串的 substr()</h2>
<p></p>
<p><strong>find</strong>：从字符串 pos 位置开始往后找字符 c ，返回该字符在字符串中的位置。</p>
<div>
<pre><code class="language-cpp">size_t find (const char* s, size_t pos = 0) const;</code></pre>
</div>
<p>find（'字符'，开始位置）; （不给开始位置默认从0开始）</p>
<p><strong>substr</strong>：在 str 中从 pos 位置开始，截取 n 个字符，然后返回一个新构造的对象，其值初始化为此对象的子字符串的副本。</p>
<div>
<pre><code class="language-cpp">string substr (size_t pos = 0, size_t len = npos) const;</code></pre>
</div>
<p> substr（开始位置，截取长度）；（不给截取长度默认缺省值无穷大npos）</p>
<p>演示：</p>
<div>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt; 
using namespace std;

int main() {
	//创建字符串记录网址
	string url("http://www.cplusplus.com/reference/string/string/find/");
 
	// 取出协议
	size_t pos1 = url.find(':'); //默认从头找
	string protocol = url.substr(0, pos1);
	cout &lt;&lt; protocol &lt;&lt; endl; 
 
	// 取出域名
	size_t pos2 = url.find('/', pos1 + 3);  
				// 冒号位置+3开始往后找（w位置） 
	string domain = url.substr(pos1 + 3, pos2 - (pos1 + 3));
	cout &lt;&lt; domain &lt;&lt; endl;
 
	// 取出路径
	string uri = url.substr(pos2 + 1);
	cout &lt;&lt; uri &lt;&lt; endl;

}</code></pre>
</div>
<p><img alt="" height="226" src="image\0eef802c227e410cbd97e62f64c94abf.png" width="539"/>​</p>
<p></p>
<h3 id="0x06%20%E5%80%92%E7%9D%80%E8%BF%BD%E6%9D%80%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%20rfind()%C2%A0%C2%A0">反向追查字符串的 rfind()  </h3>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt; 
using namespace std;

void test01()
{
	//查找
	string str1 = "abcdefgde";

	int pos = str1.find("de");

	if (pos == -1)
	{
		cout &lt;&lt; "未找到" &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; "pos = " &lt;&lt; pos &lt;&lt; endl;
	}
	
	pos = str1.rfind("de");

	cout &lt;&lt; "pos = " &lt;&lt; pos &lt;&lt; endl;

}


int main() {
	test01();
	return 0;
}
</code></pre>
<blockquote>
<p>pos = 3<br/> pos = 7</p>
</blockquote>
<p>与find（）同理，只是从右往左找而已</p>
<p></p>
<h3 id="0x06%C2%A0%E5%AE%9E%E7%8E%B0%20find()">find() 的实现</h3>
<p>find：查找字符</p>
<pre><code class="language-cpp">/* find */
size_t find(char aim_ch) {
	for (size_t i = 0; i &lt; _size; i++) {
		if (aim_ch == _str[i]) { 
			// 找到了
			return i;    // 返回下标
		}
	}
	// 找不到
	return npos;
}</code></pre>
<p> find：查找字符串</p>
<pre><code class="language-cpp">size_t find(const char* aim_str, size_t pos = 0) {
	const char* ptr = strstr(_str + pos, aim_str);
	if (ptr == nullptr) {
		return npos;
	}
	else {
		return ptr - _str;  // 减开头
	}
}</code></pre>
<p></p>
<p></p>
<p></p>
<h2 id="4%E3%80%81string%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83%E5%92%8C%E6%9B%BF%E6%8D%A2%20-%C2%A0replace()%20compare()">4、string字符串比较和替换 - <code>replace() compare()</code></h2>
<blockquote>
<ul><li><code>string&amp; replace(int pos, int n, const string&amp; str);</code> //替换从pos开始n个字符为字符串str</li><li><code>string&amp; replace(int pos, int n,const char* s);</code> //替换从pos开始的n个字符为字符串s</li></ul>
<p></p>
<ul><li><code>int compare(const string &amp;s) const;</code> //与字符串s比较</li><li><code>int compare(const char *s) const;</code> //与字符串s比较</li></ul>
</blockquote>
<p><code>replace():</code></p>
<pre><code class="language-cpp">void test02()
{
	//替换
	string str1 = "abcdefgde";
	str1.replace(1, 3, "1111");

	cout &lt;&lt; "str1 = " &lt;&lt; str1 &lt;&lt; endl;
}

int main() {
	test02();
	return 0;
}
</code></pre>
<blockquote>
<p>str1 = a1111efgde</p>
</blockquote>
<p></p>
<p><code>compare():</code></p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt; 
using namespace std;
//字符串比较
void test01()
{

	string s1 = "hello";
	string s2 = "aello";

	int ret = s1.compare(s2);

	if (ret == 0) {
		cout &lt;&lt; "s1 等于 s2" &lt;&lt; endl;
	}
	else if (ret &gt; 0)
	{
		cout &lt;&lt; "s1 大于 s2" &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; "s1 小于 s2" &lt;&lt; endl;
	}

}

int main() {

	test01();

	return 0;
}
</code></pre>
<p></p>
<h2 id="5%E3%80%81%C2%A0string%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4%20-%C2%A0insert()%C2%A0erase()">5、 string插入和删除 - <code>insert() erase()</code></h2>
<ul><li><code>string&amp; insert(int pos, const char* s);</code> //插入字符串</li><li><code>string&amp; insert(int pos, const string&amp; str);</code> //插入字符串</li><li><code>string&amp; insert(int pos, int n, char c);</code> //在指定位置插入n个字符c</li><li><code>string&amp; erase(int pos, int n = npos);</code> //删除从Pos开始的n个字符</li></ul>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt; 
using namespace std;
//字符串插入和删除
void test01()
{
	string str = "hello";
	str.insert(1, "111");
	cout &lt;&lt; str &lt;&lt; endl;

	str.erase(1, 3);  //从1号位置开始3个字符
	cout &lt;&lt; str &lt;&lt; endl;
}

int main() {

	test01();

	return 0;
}
</code></pre>
<blockquote>
<p>h111ello<br/> hello</p>
</blockquote>
<p></p>
<h3 id="0x07%C2%A0%E5%AE%9E%E7%8E%B0%20erase()">erase() 的实现</h3>
<pre><code class="language-cpp">/* 删除：erase */
string&amp; erase(size_t pos, size_t len = npos) {
	assert(pos &lt; _size);
 
	if (len == pos || pos + len &gt;= _size) {
		_str[pos] = '\0';    // 放置\0截断
		_size = pos;
	}
	else {
		strcpy(_str + pos, _str + pos + len);
		_size -= len;
	}
 
	return *this;
}</code></pre>
<h3 id="%C2%A00x04%C2%A0%E5%AE%9E%E7%8E%B0%20insert()">insert() 的实现</h3>
<p>insert：字符</p>
<pre><code class="language-cpp">/* 插入：insert */
string&amp; insert(size_t pos, char append_ch) {
	assert(pos &lt;= _size);
 
	// 检查是否需要增容
	if (_size == _capacity) {     
		reserve(_capacity == 0 ? 4 : _capacity * 2);
	}
			
	// 向后挪动数据
	//size_t end = _size;
	//while (end &gt;= (int)pos) {
	//	_str[end + 1] = _str[end];
	//	end--;
	//}
 
	size_t end = _size + 1;
	while (end &gt; pos) {
		_str[end] = _str[end - 1];
		end--;
	}
 
	// 插入
	_str[pos] = append_ch;
	_size++;
 
	return *this;
}</code></pre>
<p>insert：字符串</p>
<pre><code class="language-cpp">string&amp; insert(size_t pos, const char* append_str) {
	assert(pos &lt;= _size);
	size_t len = strlen(append_str);
 
	// 检查是否需要增容
	if (_size + len &gt; _capacity) {
		reserve(_size + len);
	}
 
	// 向后挪动数据
	size_t end = _size + len;
	while (end &gt; pos + len - 1) {
		_str[end] = _str[end - len];
		end--;
	}
 
	// 插入
	strncpy(_str + pos, append_str, len);
	_size += len;
 
	return *this;
}</code></pre>
<p></p>
<h1 id="%E2%85%A4.string%20%E7%B1%BB%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0">Ⅴ.string 类非成员函数的实现</h1>
<h2 id="%E2%85%A5.%20operator%20%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">1.operator 运算符重载</h2>
<p><img alt="" src="image\549f01c295774121bdef3a9a3d22a151.png"/>大型造轮子现场，核心为复用与调用</p>
<h3 id="0x00%20operator%3C"> operator&lt;</h3>
<pre><code class="language-cpp">/* s1 &lt; s2*/
bool operator&lt;(const string&amp; s1, const string&amp; s2) {
	size_t i1 = 0, i2 = 0;
	while (i1 &lt; s1.size() &amp;&amp; i1 &lt; s2.size()) {
		if (s1[i1] &lt; s2[i2]) {
			return true;
		} 
		else if (s1[i1] &gt; s2[i2]) {
			return false;
		}
		else {
			i1++;
			i2++;
		}
	}
	return i2 &lt; s2.size() ? true : false;
}</code></pre>
<p>当然，我们还可以实现的更简单些，直接用 strcmp 偷个懒：</p>
<pre><code class="language-cpp">/* s1 &lt; s2*/
bool operator&lt;(const string&amp; s1, const string&amp; s2) {
	return strcmp(s1.c_str(), s2.c_str()) &lt; 0;
}</code></pre>
<p></p>
<h3 id="0x01%20operator%3D"> operator==</h3>
<pre><code class="language-cpp">/* s1 == s2 */
bool operator==(const string&amp; s1, const string&amp; s2) {
	return strcmp(s1.c_str(), s2.c_str()) == 0;
}</code></pre>
<p></p>
<p><strong>接下来的操作可以复用 == 和 &lt;</strong></p>
<p><img alt="" height="120" src="image\94119bebb99d4546831118785f1bb471.png" width="221"/>高端的程序员，往往只需要最简单的编程方式~~</p>
<p></p>
<p> operator&lt;=</p>
<pre><code class="language-cpp">	/* s1 &lt;= s2 */
	bool operator&lt;=(const string&amp; s1, const string&amp; s2) {
		return s1 &lt; s2 || s1 == s2;
	}</code></pre>
<p>operator&gt;</p>
<pre><code class="language-cpp">    /* s1 &gt; s2 */
	bool operator&gt;(const string&amp; s1, const string&amp; s2) {
		return !(s1 &lt;= s2);
	}</code></pre>
<p>operator&gt;=</p>
<pre><code class="language-cpp">	/* s1 &gt;= s2 */
	bool operator&gt;=(const string&amp; s1, const string&amp; s2) {
		return !(s1 &lt; s2);
	}</code></pre>
<p>operator!=</p>
<pre><code class="language-cpp">	/* s1 != s2 */
	bool operator!=(const string&amp; s1, const string&amp; s2) {
		return !(s1 == s2);
	}</code></pre>
<p></p>
<h2 id="%E2%85%A6.%C2%A0%20%E6%B5%81%E6%8F%92%E5%85%A5%E5%92%8C%E6%B5%81%E6%8F%90%E5%8F%96">2.流插入和流提取</h2>
<h3 id="0x01%20%E5%AE%9E%E7%8E%B0%20operator%3C%3C">operator&lt;&lt; 的实现</h3>
<pre><code class="language-cpp">// cout &lt;&lt; s1  →  operator&lt;&lt;(cout, s1)
ostream&amp; operator&lt;&lt;(ostream&amp; out, const string&amp; s) {
	//for (auto ch : s) {
	//	out &lt;&lt; ch;
	//}
 
	for (size_t i = 0; i &lt; s.size(); i++) {
		out &lt;&lt; s[i];
	}
 
	return out;
}</code></pre>
<h3 id="0x02%20%E5%AE%9E%E7%8E%B0%20operator%3E%3E">operator&gt;&gt; 的实现</h3>
<pre><code class="language-cpp">// cin &gt;&gt;
istream&amp; operator&lt;&lt;(istream&amp; in, string&amp; s) {
	char ch = in.get();
	while (ch == '\n') {
		s += ch;
		ch = in.get();
	}
 
	return in;
}</code></pre>
<p></p>
<p></p>
<h1 id="%E2%85%A7.%C2%A0%20%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81">完整代码</h1>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;assert.h&gt;
using namespace std;
 
namespace chaos
{
	class string {
	public:
		/* 构造函数 */
		string(const char* str = "")
			: _size(strlen(str))        // 计算出字符串str的大小
			, _capacity(_size) {        // 初始容量等于字符串大小
 
			_str = new char[_capacity + 1];   // 开辟一块 "容量+1" 大小的空间 (_capacity存的是有效字符）
			strcpy(_str, str);                // 将传入的字符串str复制到 _str中
		}
 
		void Swap(string&amp; tmp) {
			swap(_str, tmp._str);
			swap(_size, tmp._size);
			swap(_capacity, tmp._capacity);
		}
 
		/* 拷贝构造函数：s2(s1) 
		string(const string&amp; src)
			: _size(src._size)                // 拷贝string大小
			, _capacity(src._capacity) {      // 拷贝string容量
			// 拷贝string内容
			_str = new char[src._capacity + 1];        // 开辟一块和src相同容量的空间
			strcpy(_str, src._str);					   // 将src中的_str内容拷贝到自己的_str中
		}
		*/
		string(const string&amp; src)
			: _str(nullptr)
			, _size(0)
			, _capacity(0) {
 
			string tmp(src._str);   // 拷贝构造一个src
			Swap(tmp);              // 现代写法：交换
		}
	
 
		/* 赋值重载：s1 = s3
		string&amp; operator=(const string&amp; src) {
			// 防止自己跟自己赋值
			if (this != &amp;src) {
				// 1. 暂时用tmp开辟一块相同的空间
				char* tmp = new char[src._capacity + 1];
				// 2. 把src的值复制给tmp
				strcpy(tmp, src._str);
				// 3. 释放this原空间
				delete[] _str;
				// 4. 没翻车，把tmp交付给_src
				_str = tmp;
				_size = src._size;
				_capacity = src._capacity;
			}
			return *this;
		}
		string&amp; operator=(const string&amp; src) {
			// 防止自己跟自己赋值
			if (this != &amp;src) {
				string tmp(src);   // 复用拷贝构造
				Swap(tmp);
			}
			return *this;
		}
		*/
		string&amp; operator=(string src) {
			Swap(src);    // 正好调用拷贝构造，不如让形参充当tmp
			return *this;
		}
 
 
		/* 返回C格式的字符串：c_str */
		const char* c_str() const {
			return _str;
		}
 
		/* 求字符串大小：size() */
		size_t size() const {
			return _size;
		}
 
		/* operator[] */
		char&amp; operator[](size_t pos) {
			assert(pos &lt; _size);
			return _str[pos];  // 返回字符串对应下标位置的元素
		}
		const char&amp; operator[](size_t pos) const {
			assert(pos &lt; _size);
			return _str[pos];
		}
 
		/* 迭代器 */
		typedef char* iterator;
		iterator begin() { 
			return _str;            // 返回第一个字符的位置
		}
		iterator end() {
			return _str + _size;    // 返回最后一个字符的位置
		}
 
		/* const迭代器 */
		typedef const char* const_iterator;
		const_iterator begin() const {
			return _str;
		}
		const_iterator end() const {
			return _str + _size;
		}
 
		/* reserve() */
		void reserve(size_t new_capacity) {
			if (new_capacity &gt; _capacity) {               // 检查是否真的需要扩容
				char* tmp = new char[new_capacity + 1];   // 开空间
				strcpy(tmp, _str);						  // 先搬运数据到tmp
 
				_str = tmp;								  // 没翻车，递交给_str
				_capacity = new_capacity;				  // 更新容量
			}
		}
 
		/* 字符尾插：push_back() */
		void push_back(char append_ch) {
			/*
			if (_size == _capacity) {                         // 检查是否需要扩容
				reserve(_capacity == 0 ? 4 : _capacity * 2);  // 首次给4，其他情况默认扩2倍
			}
			_str[_size] = append_ch;     // 插入要追加的字符
			_size++;						 
			_str[_size] = '\0';	         // 手动添加'\0'
			*/
 
			insert(_size, append_ch);
		}
 
		/* 字符串追加：append() */
		void append(const char* append_str) {
			/*
			size_t len = strlen(append_str);      // 计算出要追加的字符串的长度
			if (_size + len &gt; _capacity) {		  // 检查是否需要扩容
				reserve(_size + len);
			}
			strcpy(_str + _size, append_str);      // 首字符+大小，就是'\0'位置
			_size += len;						   // 更新大小
			*/
			
			insert(_size, append_str);
		}
 
		/* operator+= */
		string&amp; operator+=(char append_ch) {
			push_back(append_ch);
			return *this;
		}
		string&amp; operator+=(const char* append_str) {
			append(append_str);
			return *this;
		}
 
		/* insert */
		string&amp; insert(size_t pos, char append_ch) {
			assert(pos &lt;= _size);
 
			if (_size == _capacity) {		// 检查是否需要扩容
				reserve(_capacity == 0 ? 4 : _capacity * 2);
			}
 
			// 向后挪动数据
			size_t end = _size + 1;
			while (end &gt; pos) {
				_str[end] = _str[end - 1];
				end--;
			}
 
			// 插入
			_str[pos] = append_ch;
			_size++;
 
			return *this;
		}
		string&amp; insert(size_t pos, const char* append_str) {
			assert(pos &lt;= _size);
			size_t len = strlen(append_str);
 
			if (_size + len &gt; _capacity) {    // 检查是否需要增容
				reserve(_size + len);
			}
 
			// 向后挪动数据
			size_t end = _size + len;
			while (end &gt; pos + len - 1) {
				_str[end] = _str[end - len];
				end--;
			}
 
			// 插入
			strncpy(_str + pos, append_str, len);
			_size += len;
 
			return *this;
		}
 
		/* resize */
		void resize(size_t new_capacity, char init_ch = '\0') {
			// 如果欲增容量比_size小
			if (new_capacity &lt;= _size) {
				_str[new_capacity] = '\0';      // 拿斜杠零去截断
				_size = new_capacity;           // 更新大小
			}
			// 欲增容量比_size大
			else {
				if (new_capacity &gt; _capacity) {
					reserve(new_capacity);
				}
				// 起始位置，初始化字符，初始化个数
				memset(_str + _size, init_ch, new_capacity - _size);
				_size = _capacity;
				_str[_size] = '\0';
			}
		}
 
		/* find */
		size_t find(char aim_ch) {
			for (size_t i = 0; i &lt; _size; i++) {
				if (aim_ch == _str[i]) {
					// 找到了
					return i;    // 返回下标
				}
			}
			// 找不到
			return npos;
		}
		size_t find(const char* aim_str, size_t pos = 0) {
			const char* ptr = strstr(_str + pos, aim_str);
			if (ptr == nullptr) {
				return npos;
			}
			else {
				return ptr - _str;  // 减开头
			}
		}
 
		/* 删除：erase */
		string&amp; erase(size_t pos, size_t len = npos) {
			assert(pos &lt; _size);
 
			if (len == pos || pos + len &gt;= _size) {
				_str[pos] = '\0';    // 放置\0截断
				_size = pos;
			}
			else {
				strcpy(_str + pos, _str + pos + len);
				_size -= len;
			}
 
			return *this;
		}
 
		/* 析构函数 */
		~string() {
			if (_str != nullptr) {
				delete[] _str;
				_str = nullptr;
			}
			_size = _capacity = 0;
		}
 
	private:
		/* 成员变量 */
		char* _str;
		size_t _size;
		size_t _capacity;
 
	public:
		static const size_t npos;
	};
 
	/* 初始化npos */
	const size_t string::npos = -1;   // 无符号整型的-1，即整型最大值
 
	/* s1 &lt; s2*/
	bool operator&lt;(const string&amp; s1, const string&amp; s2) {
		/*
		size_t i1 = 0, i2 = 0;
		while (i1 &lt; s1.size() &amp;&amp; i1 &lt; s2.size()) {
			if (s1[i1] &lt; s2[i2]) {
				return true;
			}
			else if (s1[i1] &gt; s2[i2]) {
				return false;
			}
			else {
				i1++;
				i2++;
			}
		}
		return i2 &lt; s2.size() ? true : false;
		*/
 
		return strcmp(s1.c_str(), s2.c_str()) &lt; 0;
	}
 
	/* s1 == s2 */
	bool operator==(const string&amp; s1, const string&amp; s2) {
		return strcmp(s1.c_str(), s2.c_str()) == 0;
	}
 
	/* s1 &lt;= s2 */
	bool operator&lt;=(const string&amp; s1, const string&amp; s2) {
		return s1 &lt; s2 || s1 == s2;
	}
 
	/* s1 &gt; s2 */
	bool operator&gt;(const string&amp; s1, const string&amp; s2) {
		return !(s1 &lt;= s2);
	}
 
	/* s1 &gt;= s2 */
	bool operator&gt;=(const string&amp; s1, const string&amp; s2) {
		return !(s1 &lt; s2);
	}
 
 
	/* s1 != s2 */
	bool operator!=(const string&amp; s1, const string&amp; s2) {
		return !(s1 == s2);
	}
 
	// cout &lt;&lt; s1  →  operator&lt;&lt;(cout, s1)
	ostream&amp; operator&lt;&lt;(ostream&amp; out, const string&amp; s) {
		/*
		for (auto ch : s) {
			out &lt;&lt; ch;
		}
		*/
 
		for (size_t i = 0; i &lt; s.size(); i++) {
			out &lt;&lt; s[i];
		}
 
		return out;
	}
 
	// cin &gt;&gt;
	istream&amp; operator&lt;&lt;(istream&amp; in, string&amp; s) {
		char ch = in.get();
		while (ch == '\n') {
			s += ch;
			ch = in.get();
		}
 
		return in;
	}
 
 
 
	/* 测试用 */
	void test_string1() {
		string s1("hello world");
		string s2(s1);
		cout &lt;&lt; s1.c_str() &lt;&lt; endl;
		cout &lt;&lt; s2.c_str() &lt;&lt; endl;
 
		string s3("pig");
		cout &lt;&lt; s3.c_str() &lt;&lt; endl;
 
		s1 = s3;
		cout &lt;&lt; s1.c_str() &lt;&lt; endl;
	}
 
	void test_string2() {
		string s1("hello world");
		string s2;
 
		for (size_t i = 0; i &lt; s1.size(); i++) {
			cout &lt;&lt; s1[i] &lt;&lt; " ";
		}
		cout &lt;&lt; endl;
	}
 
	void test_string3() {
		string s1("hello world");
		string s2;
 
		s1[0] = 'F';
		for (size_t i = 0; i &lt; s1.size(); i++) {
			cout &lt;&lt; s1[i] &lt;&lt; " ";
		}
		cout &lt;&lt; endl;
	}
 
	void test_string4() {
		string s1("hello world");
 
		// 迭代器写
		string::iterator it = s1.begin();
		while (it != s1.end()) {
			*it += 1;
			it++;
		}
 
		// 迭代器读
		it = s1.begin();   // 重置起点
		while (it != s1.end()) {
			cout &lt;&lt; *it &lt;&lt; " ";
			it++;
		}
	}
 
	void test_string5() {
		string s1("hello world");
		cout &lt;&lt; s1.c_str() &lt;&lt; endl;
 
		s1.push_back('!');
		cout &lt;&lt; s1.c_str() &lt;&lt; endl;
 
		s1.push_back('A');
		cout &lt;&lt; s1.c_str() &lt;&lt; endl;
	}
 
	void test_string6() {
		string s1("hello world");
		cout &lt;&lt; s1.c_str() &lt;&lt; endl;
 
		s1 += '!';
		cout &lt;&lt; s1.c_str() &lt;&lt; endl;
 
		s1 += "this is new data";
		cout &lt;&lt; s1.c_str() &lt;&lt; endl;
	}
 
	void test_string7() {
		string s1("hello world");
		cout &lt;&lt; s1.c_str() &lt;&lt; endl;
 
		s1.insert(0, 'X');
		cout &lt;&lt; s1.c_str() &lt;&lt; endl;
 
		s1.insert(0, "hahahaha");
		cout &lt;&lt; s1.c_str() &lt;&lt; endl;
	}
 
	void test_string8() {
		string s1("hello world");
		cout &lt;&lt; s1.c_str() &lt;&lt; endl;
 
		s1.erase(5, 2);   // 从第五个位置开始，删两个字符
		cout &lt;&lt; s1.c_str() &lt;&lt; endl;
 
		s1.erase(5, 20);  // 从第五个位置开始，删完
		cout &lt;&lt; s1.c_str() &lt;&lt; endl;
 
	}
}
 </code></pre>
<p></p>
<p><img alt="" height="97" src="https://img-blog.csdnimg.cn/01efb8988c7f4d2f8c401fd886c2c8d1.gif" width="97"/>终于写完了！！</p>
<p> <img alt="" height="91" src="image\216a8fca12da69cd20ab1687ba790286.jpeg" width="98"/>不是，这还拿不下你？</p>
<p><a href="https://mp.csdn.net/mp_blog/creation/editor/125821363" title="Ⅲ、Ⅳ、Ⅴ、Ⅵ、Ⅶ、Ⅷ、">Ⅲ、Ⅳ、Ⅴ、Ⅵ、Ⅶ、Ⅷ、</a></p>
<p></p>
</div>
</div>