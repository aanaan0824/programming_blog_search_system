<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<h1 id="main-toc"><strong>目录</strong></h1>
<p id="%F0%9F%8C%BA21.%20%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8-toc" style="margin-left:0px;"><a href="#%F0%9F%8C%BA21.%20%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8">🌺哈夫曼树的基本概念</a></p>
<p id="1%EF%BC%89%E8%B7%AF%E5%BE%84-toc" style="margin-left:80px;"><a href="#1%EF%BC%89%E8%B7%AF%E5%BE%84">1）路径</a></p>
<p id="2%EF%BC%89%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6-toc" style="margin-left:80px;"><a href="#2%EF%BC%89%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6">2）路径长度</a></p>
<p id="3%EF%BC%89%E6%9D%83-toc" style="margin-left:80px;"><a href="#3%EF%BC%89%E6%9D%83">3）权</a></p>
<p id="4%EF%BC%89%E7%BB%93%E7%82%B9%E7%9A%84%E5%B8%A6%E6%9D%83%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6-toc" style="margin-left:80px;"><a href="#4%EF%BC%89%E7%BB%93%E7%82%B9%E7%9A%84%E5%B8%A6%E6%9D%83%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6">4）结点的带权路径长度</a></p>
<p id="5%EF%BC%89%E6%A0%91%E7%9A%84%E5%B8%A6%E6%9D%83%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6-toc" style="margin-left:80px;"><a href="#5%EF%BC%89%E6%A0%91%E7%9A%84%E5%B8%A6%E6%9D%83%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6">5）树的带权路径长度</a></p>
<p id="6%EF%BC%89%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91-toc" style="margin-left:80px;"><a href="#6%EF%BC%89%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91">6）哈夫曼树</a></p>
<p id="%F0%9F%8C%BA%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0%E7%AE%97%E6%B3%95-toc" style="margin-left:0px;"><a href="#%F0%9F%8C%BA%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0%E7%AE%97%E6%B3%95">🌺哈夫曼树的构造算法</a></p>
<p id="%F0%9F%8D%81%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B-toc" style="margin-left:40px;"><a href="#%F0%9F%8D%81%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B">🍁哈夫曼树的构造过程</a></p>
<p id="%F0%9F%8D%81%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#%F0%9F%8D%81%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0">🍁哈夫曼树算法的实现</a></p>
<p id="%EF%BC%881%EF%BC%89%E7%BB%93%E7%82%B9%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84-toc" style="margin-left:80px;"><a href="#%EF%BC%881%EF%BC%89%E7%BB%93%E7%82%B9%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84">1）结点的存储结构</a></p>
<p id="%EF%BC%882%EF%BC%89%E6%9E%84%E5%BB%BA%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91-toc" style="margin-left:80px;"><a href="#%EF%BC%882%EF%BC%89%E6%9E%84%E5%BB%BA%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91">2）构建哈夫曼树</a></p>
<hr id="hr-toc"/>
<p class="img-center"><img alt="94536690f848438fab30aa17191a6ea2.png" src="https://img-blog.csdnimg.cn/94536690f848438fab30aa17191a6ea2.png"/></p>
<h1 id="%F0%9F%8C%BA21.%20%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8">🌺哈夫曼树的基本概念</h1>
<blockquote>
<p><span style="color:#38d8f0;"><strong>Q：什么是哈夫曼树</strong></span></p>
<p><strong><span style="color:#ff9900;">A：</span></strong>哈夫曼树又称最优树，是一类带权路径长度最短的树。在正式了解哈夫曼树之前，我们需要了解一些概念。</p>
<p class="img-center"><img alt="" height="461" src="image\9093827e8f864108b06a8afb191254b6.png" width="441"/></p>
<hr/>
<h3 id="1%EF%BC%89%E8%B7%AF%E5%BE%84"><span style="background-color:#f9eda6;">1）路径</span></h3>
<p><span style="color:#38d8f0;"><strong>Q：什么是路径</strong></span></p>
<p><strong><span style="color:#ff9900;">A：</span></strong><span style="color:#be191c;">从树中一个结点到另一个结点之间的分支</span>构成这两个结点之间的路径。</p>
<hr/>
<h3 id="2%EF%BC%89%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6"><span style="background-color:#f9eda6;">2）路径长度</span></h3>
<p><span style="color:#38d8f0;"><strong>Q：什么是路径长度</strong></span></p>
<p><strong><span style="color:#ff9900;">A：</span></strong><span style="color:#be191c;">路径上的分支数目</span>称作路径长度。<span style="color:#956fe7;">如图根结点到结点B的路径长度为2</span></p>
<hr/>
<h3 id="3%EF%BC%89%E6%9D%83"><span style="background-color:#f9eda6;">3）权</span></h3>
<p><span style="color:#38d8f0;"><strong>Q：什么是权</strong></span></p>
<p><strong><span style="color:#ff9900;">A：</span></strong>若将<span style="color:#be191c;">树中结点赋给一个带有某种含义的数值</span>，则该数值称为该结点的权。<span style="color:#956fe7;">如图A的权是7</span></p>
<hr/>
<h3 id="4%EF%BC%89%E7%BB%93%E7%82%B9%E7%9A%84%E5%B8%A6%E6%9D%83%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6"><span style="background-color:#f9eda6;">4）结点的带权路径长度</span></h3>
<p><span style="color:#38d8f0;"><strong>Q：什么是结点的带权路径长度</strong></span></p>
<p><strong><span style="color:#ff9900;">A：</span></strong><span style="color:#be191c;">从该结点到树根之间的路径长度与结点上权的乘积</span></p>
<hr/>
<h3 id="5%EF%BC%89%E6%A0%91%E7%9A%84%E5%B8%A6%E6%9D%83%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6"><span style="background-color:#f9eda6;">5）树的带权路径长度</span></h3>
<p><span style="color:#38d8f0;"><strong>Q：什么是树的带权路径长度</strong></span></p>
<p><strong><span style="color:#ff9900;">A：</span></strong><span style="color:#be191c;">树中所有叶子结点的带权路径长度之和</span>，通常记作 WPL。<span style="color:#956fe7;">如图WPL=7*1+5*2+2*3+4*3=35</span></p>
<hr/>
<h3 id="6%EF%BC%89%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91"><span style="background-color:#f9eda6;">6）哈夫曼树</span></h3>
<p><span style="color:#38d8f0;"><strong>Q：什么是树的带权路径长度</strong></span></p>
<p><strong><span style="color:#ff9900;">A：</span></strong>给定n个权值作为n个叶子结点，构造一棵二叉树，<span style="color:#be191c;">若该树的带权路径长度达到最小，则称该二叉树为哈夫曼树，也被称为最优二叉树</span>。</p>
</blockquote>
<blockquote>
<p><span style="color:#38d8f0;"><strong>Q：哈夫曼树中具有不同权值的叶子结点的分布有什么特点呢？</strong></span></p>
<p><strong><span style="color:#ff9900;">A：</span></strong>从上面的例子中，可以直观的发现，<span style="color:#be191c;">在哈夫曼树中，权值越大的结点离根结点越近</span>。根据这个特点，哈夫曼最早给出了一个构造哈夫曼树的方法，称为哈夫曼算法。</p>
</blockquote>
<h1 id="%F0%9F%8C%BA%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0%E7%AE%97%E6%B3%95">🌺哈夫曼树的构造算法</h1>
<blockquote>
<h2 id="%F0%9F%8D%81%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B"><span style="background-color:#f9eda6;">🍁哈夫曼树的构造过程</span></h2>
<hr/>
<p><span style="color:#38d8f0;"><strong>Q：</strong></span>假设有4个叶子结点，权重依次是7，5，2，4，如何构建一颗哈夫曼树，也就是带权路径长度最小的树呢？</p>
<p class="img-center"><img alt="" height="73" src="image\299b0fa0a3d44991b76ca8a56748798c.png" width="455"/></p>
<p><span style="color:#a2e043;"><strong>第一步：</strong></span>将这4个结点分别作为4棵仅含有一个结点的二叉树，形成一个森林</p>
<p><span style="color:#a2e043;"><strong>第二步：</strong></span>选择当前权值最小的两个结点C和D，根据这两个结点生成一个新的父结点，<span style="color:#956fe7;">父节点的权值是这两个结点权值之和</span></p>
<p class="img-center"><img alt="" height="185" src="image\b6434fe78ece407b950fe010c2153bb0.png" width="183"/></p>
<p><span style="color:#a2e043;"><strong>第三步：</strong></span><span style="color:#956fe7;">选择当前权值最小的两个结点，再次根据这两个结点生成一个新的父结点</span>。现在剩下的结点有7，6，5，我们根据6和5生成新的父节点。</p>
<p class="img-center"><img alt="" height="301" src="image\77cd7e790c2c427786a17ec8e0ed8c2c.png" width="245"/></p>
<p> <span style="color:#a2e043;"><strong>第四步：</strong></span><span style="color:#956fe7;">选择当前权值最小的两个结点，再次根据这两个结点生成一个新的父结点</span>。现在剩下的结点有7，11，我们根据7和11生成新的父节点。</p>
<p class="img-center"><img alt="" height="462" src="image\a2099899e7c94c4da75582c3a7e7e5d2.png" width="437"/></p>
<p></p>
<p style="text-align:center;"><span style="color:#fe2c24;"><strong>就这样，我们得到了最终的二叉树</strong></span></p>
<hr/>
<h2 id="%F0%9F%8D%81%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0"><span style="background-color:#f9eda6;">🍁哈夫曼树算法的实现</span></h2>
<hr/>
<h3 id="%EF%BC%881%EF%BC%89%E7%BB%93%E7%82%B9%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span style="background-color:#d4e9d5;">1）结点的存储结构</span></h3>
<p>哈夫曼树是一种二叉树，树中每个结点要包含其双亲信息和孩子结点的信息，由此，每个结点的存储结构如图：</p>
<p class="img-center"><img alt="" height="36" src="image\39cb01f1c77d45a99c7c488d49bee894.png" width="320"/></p>
<pre><code class="language-cpp">typedef struct{ 
	int weight;		 			//结点的权值
	int parent,lchild,rchild; 	//结点的双亲、左孩子、右孩子的下标
) HTNode,*HuffmanTree; 			//动态分配数组存储哈夫曼树</code></pre>
<h3 id="%EF%BC%882%EF%BC%89%E6%9E%84%E5%BB%BA%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91"><span style="background-color:#d4e9d5;">2）构建哈夫曼树</span></h3>
<p><span style="color:#38d8f0;"><strong>构建哈夫曼树主要分为两大部步</strong></span></p>
<p>第一步为森林结点的<span style="color:#be191c;">初始化</span>，第二步为<span style="color:#be191c;">哈夫曼树的建立</span>。</p>
<p><strong>💬代码演示</strong></p>
<pre><code class="language-cpp">void CreateHuffmanTree(HuffmanTree &amp;HT,int n) 
{//构造哈夫曼树 HT
	if(n&lt;=1) return; 
	m=2*n-1; 
	HT=new HTNode[m+1]; 		//0 号单元未用，所以需要动态分配 m+l 个单元， HT[m)表示根结点
	for(i=1;i&lt;=m;++i) 			//将l~m号单元中的双亲、左孩子，右孩子的下标都初始化为0
	{
		HT[i].parent=O;
		HT[i].lchild=O;
		HT[i].rchild=O;
	} 
	for(i=1;i&lt;=n;++i)			//输人前 n 个单元中叶子结点的权值
		cin&gt;&gt;HT[i].weight; 
	
	
	for(i=n+1;i&lt;=m;++i)
	{//通过 n-1 次的选择、删除 、 合并来创建哈夫曼树
		Select (HT,i-1,s1,s2); 
		//在 HT[k] 中选择两个其双亲域为 0 且权值最小的结点，并返回它们在 HT 中的序号 s1和 s2
		HT[s1].parent=i;
		HT[s2].parent=i; 
		//得到新结点 i, 从森林中删除sl, s2, 将sl和s2 的双亲域由 0改为l.
		HT[i].lchild=s1;
		HT[i].rchild=s2; 		//sl, s2分别作为 i 的左右孩子
		HT[i].weight=HT[s1].weight+HT[s2].weight; // i 的权值为左右孩子权值之和
	}
}</code></pre>
</blockquote>
<p> </p>
</div>
</div>