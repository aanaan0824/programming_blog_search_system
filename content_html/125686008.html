<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<p id="main-toc"><strong>目录</strong></p>
<p id="1%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D">1、为什么要进行动态内存分配</a></p>
<p id="2.%20%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#2.%20%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%87%BD%E6%95%B0">2. 动态内存函数</a></p>
<p id="2.1malloc%E5%92%8Cfree-toc" style="margin-left:80px;"><a href="#2.1malloc%E5%92%8Cfree">2.1malloc和free</a></p>
<p id="2.2%20calloc-toc" style="margin-left:80px;"><a href="#2.2%20calloc">2.2 calloc</a></p>
<p id="2.3%20realloc-toc" style="margin-left:80px;"><a href="#2.3%20realloc">2.3 realloc</a></p>
<p id="3.%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E9%94%99%E8%AF%AF-toc" style="margin-left:40px;"><a href="#3.%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E9%94%99%E8%AF%AF">3.常见的动态内存错误</a></p>
<p id="%C2%A0%203.1%E5%AF%B9NULL%E6%8C%87%E9%92%88%E7%9A%84%E8%A7%A3%E5%BC%95%E7%94%A8%E9%94%99%E8%AF%AF-toc" style="margin-left:80px;"><a href="#%C2%A0%203.1%E5%AF%B9NULL%E6%8C%87%E9%92%88%E7%9A%84%E8%A7%A3%E5%BC%95%E7%94%A8%E9%94%99%E8%AF%AF">  3.1对NULL指针的解引用错误</a></p>
<p id="3.2%E5%AF%B9%E5%8A%A8%E6%80%81%E5%BC%80%E8%BE%9F%E7%A9%BA%E9%97%B4%E7%9A%84%E8%B6%8A%E7%95%8C%E8%AE%BF%E9%97%AE-toc" style="margin-left:80px;"><a href="#3.2%E5%AF%B9%E5%8A%A8%E6%80%81%E5%BC%80%E8%BE%9F%E7%A9%BA%E9%97%B4%E7%9A%84%E8%B6%8A%E7%95%8C%E8%AE%BF%E9%97%AE">3.2对动态开辟空间的越界访问</a></p>
<p id="3.3%20%E5%AF%B9%E9%9D%9E%E5%8A%A8%E6%80%81%E5%BC%80%E8%BE%9F%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8free%E9%87%8A%E6%94%BE-toc" style="margin-left:80px;"><a href="#3.3%20%E5%AF%B9%E9%9D%9E%E5%8A%A8%E6%80%81%E5%BC%80%E8%BE%9F%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8free%E9%87%8A%E6%94%BE">3.3 对非动态开辟内存使用free释放</a></p>
<p id="3.4%20%E4%BD%BF%E7%94%A8free%E9%87%8A%E6%94%BE%E4%B8%80%E5%9D%97%E5%8A%A8%E6%80%81%E5%BC%80%E8%BE%9F%E5%86%85%E5%AD%98%E7%9A%84%E4%B8%80%E9%83%A8%E5%88%86-toc" style="margin-left:80px;"><a href="#3.4%20%E4%BD%BF%E7%94%A8free%E9%87%8A%E6%94%BE%E4%B8%80%E5%9D%97%E5%8A%A8%E6%80%81%E5%BC%80%E8%BE%9F%E5%86%85%E5%AD%98%E7%9A%84%E4%B8%80%E9%83%A8%E5%88%86">3.4 使用free释放一块动态开辟内存的一部分</a></p>
<p id="3.5%20%E5%AF%B9%E5%90%8C%E4%B8%80%E5%9D%97%E5%86%85%E5%AD%98%E8%BF%9B%E8%A1%8C%E5%A4%9A%E6%AC%A1%E9%87%8A%E6%94%BE-toc" style="margin-left:80px;"><a href="#3.5%20%E5%AF%B9%E5%90%8C%E4%B8%80%E5%9D%97%E5%86%85%E5%AD%98%E8%BF%9B%E8%A1%8C%E5%A4%9A%E6%AC%A1%E9%87%8A%E6%94%BE">3.5 对同一块内存进行多次释放</a></p>
<p id="3.6%20%E5%8A%A8%E6%80%81%E5%BC%80%E8%BE%9F%E5%86%85%E5%AD%98%E5%BF%98%E8%AE%B0%E9%87%8A%E6%94%BE%EF%BC%88%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%89-toc" style="margin-left:80px;"><a href="#3.6%20%E5%8A%A8%E6%80%81%E5%BC%80%E8%BE%9F%E5%86%85%E5%AD%98%E5%BF%98%E8%AE%B0%E9%87%8A%E6%94%BE%EF%BC%88%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%89">3.6 动态开辟内存忘记释放（内存泄漏）</a></p>
<p id="4.%C2%A0C%2FC%2B%2B%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%BC%80%E8%BE%9F-toc" style="margin-left:40px;"><a href="#4.%C2%A0C%2FC%2B%2B%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%BC%80%E8%BE%9F">4. C/C++程序的内存开辟</a></p>
<p id="5.%E6%9F%94%E6%80%A7%E6%95%B0%E7%BB%84-toc" style="margin-left:40px;"><a href="#5.%E6%9F%94%E6%80%A7%E6%95%B0%E7%BB%84">5.柔性数组</a></p>
<p id="5.1%E6%9F%94%E6%80%A7%E6%95%B0%E7%BB%84%E7%9A%84%E7%89%B9%E7%82%B9-toc" style="margin-left:80px;"><a href="#5.1%E6%9F%94%E6%80%A7%E6%95%B0%E7%BB%84%E7%9A%84%E7%89%B9%E7%82%B9">5.1柔性数组的特点</a></p>
<p id="5.2%E6%9F%94%E6%80%A7%E6%95%B0%E7%BB%84%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:80px;"><a href="#5.2%E6%9F%94%E6%80%A7%E6%95%B0%E7%BB%84%E7%9A%84%E4%BD%BF%E7%94%A8">5.2柔性数组的使用</a></p>
<p id="5.3%20%E6%9F%94%E6%80%A7%E6%95%B0%E7%BB%84%E7%9A%84%E4%BC%98%E5%8A%BF-toc" style="margin-left:80px;"><a href="#5.3%20%E6%9F%94%E6%80%A7%E6%95%B0%E7%BB%84%E7%9A%84%E4%BC%98%E5%8A%BF">5.3 柔性数组的优势</a></p>
<hr id="hr-toc"/>
<p></p>
<h2>1、为什么要进行动态内存分配</h2>
<p>        首先我们来了解一下问什么要进行动态内存分配；我们先看下面两行代码：</p>
<pre><code>int val = 20;//在栈空间上开辟四个字节
char arr[10] = {0};//在栈空间上开辟10个字节的连续空间</code></pre>
<p>        这两行代码开辟的空间方式有两个特点：<br/>         1）空间开辟大小是固定的<br/>         2）数组在申明的时候，必须指定数组的长度，它所需要的内存在编译时进行分配</p>
<p>        而我们在实际应用中，对于空间的需求可不仅是上面的情况，在很多时候我们需要的空间大小在程序运行的时候才能知道，此时数组的编译时开辟空间的方式无法满足我们的需求，这时候就只能试试动态存开辟了。</p>
<h2 id="2.%20%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%87%BD%E6%95%B0">2. 动态内存函数</h2>
<h3 id="2.1malloc%E5%92%8Cfree">2.1malloc和free</h3>
<pre><code>void* malloc (size_t size);</code></pre>
<p>        mallloc这个函数向内存申请一块连续可用的空间，并返回指向这块空间的指针。如果<strong>开辟成功</strong>，则返回一个指向开辟好空间的指针。如果<strong>开辟失败</strong>，返回一个NULL指针，因此我们一定要对malloc的返回值做检查。<br/>         由于malloc的返回值的类型是 void* ，所以malloc函数并不知道开辟空间的类型，具体在使用的时候使用者自己来决定。<br/>         如果参数 size 为0，malloc的行为是标准是未定义的，这取决于编译器。</p>
<p>void free (void* ptr);</p>
<p>        free函数用来释放动态开辟的内存。如果参数 ptr 指向的空间不是动态开辟的，那free函数的行为是未定义的。如果参数 ptr 是<strong>NULL</strong>指针，则函数什么事都不做。</p>
<p><br/> malloc函数和free函数的声明都是在<strong> stdlib.h</strong> 头文件中。</p>
<h3 id="2.2%20calloc">2.2 calloc</h3>
<pre><code>void* calloc (size_t num, size_t size);</code></pre>
<p><br/>          calloc 函数和malloc函数一样也用来动态内存分配。calloc函数的功能是为 num 个大小为 size 的元素开辟一块空间，并且把空间的每个字节初始化为0。但与malloc不同的是 calloc 会在返回地址之前把申请的空间的每个字节初始化为全0。</p>
<p class="img-center"><img alt="" height="708" src="image\8fcb7b7f27ee461ba3c88f2f3ad31bc5.png" width="1188"/></p>
<p>        所以如果我们对申请的内存空间的内容要求初始化，那么就使用calloc函数来完成任务 。</p>
<h3 id="2.3%20realloc">2.3 realloc</h3>
<pre><code>void* realloc (void* ptr, size_t size)</code></pre>
<blockquote>
<p>ptr 是要调整的内存地址</p>
<p>size 调整之后新大小</p>
<p>返回值为调整之后的内存起始位置</p>
<p>这个函数调整原内存空间大小的基础上，还会将原来内存中的数据移动到 <strong>新</strong> 的空间</p>
</blockquote>
<p>        在申请空间时，有时会我们发现过去申请的空间太小，有时候我们又会觉得申请的空间过大，我们需要对内存的大小做灵活的调整。那 realloc 函数的出现就让动态内存管理更加灵活。</p>
<p></p>
<p>        realloc在调整内存空间的是存在两种情况：<br/>         第一种：原有空间之后<strong>有</strong>足够大的空间，此时扩展内存直接在原有内存之后直接追加空间，原来空间的数据不发生变化。</p>
<p>        第二种：原有空间之后<strong>没有</strong>足够大的空间，此时扩展空间是在堆空间上另找一个合适大小<br/> 的连续空间来使用。函数返回的是一个新的内存地址。</p>
<p>        如下图：</p>
<p class="img-center"><img alt="" height="577" src="image\baec0b0db0264ccb98aa34f7c31968ff.png" width="1110"/></p>
<p></p>
<h2 id="3.%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E9%94%99%E8%AF%AF">3.常见的动态内存错误</h2>
<p>        下来我们看一看常见的一些内存错误</p>
<h3 id="%C2%A0%203.1%E5%AF%B9NULL%E6%8C%87%E9%92%88%E7%9A%84%E8%A7%A3%E5%BC%95%E7%94%A8%E9%94%99%E8%AF%AF">  3.1对NULL指针的解引用错误</h3>
<pre><code>void test()
{
int *p = (int *)malloc(INT_MAX/4);
*p = 20;//如果p的值是NULL，就会有问题
free(p);
}</code></pre>
<p>        上述代码中，如果malloc开辟内存失败，会返回一个NULL指针。对NULL的解引用会导致未定义的行为。比如在很多平台上，该行为就可能会导致程序异常终止或拒绝服务。</p>
<h3 id="3.2%E5%AF%B9%E5%8A%A8%E6%80%81%E5%BC%80%E8%BE%9F%E7%A9%BA%E9%97%B4%E7%9A%84%E8%B6%8A%E7%95%8C%E8%AE%BF%E9%97%AE">3.2对动态开辟空间的越界访问</h3>
<pre><code>void test()
{
int i = 0;
int *p = (int *)malloc(10*sizeof(int));
if(NULL == p)
{
exit(EXIT_FAILURE);
}
for(i=0; i&lt;=10; i++)
{
*(p+i) = i;//当i是10的时候越界访问
}
free(p);
}</code></pre>
<h3 id="3.3%20%E5%AF%B9%E9%9D%9E%E5%8A%A8%E6%80%81%E5%BC%80%E8%BE%9F%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8free%E9%87%8A%E6%94%BE">3.3 对非动态开辟内存使用free释放</h3>
<pre><code>void test()
{
int a = 10;
int *p = &amp;a;
free(p);//ok?
}</code></pre>
<p>        如上述代码p指向的是a的地址，a一个局部变量是在栈区内开辟的，而free释放的是堆区内开辟的空间。</p>
<h3 id="3.4%20%E4%BD%BF%E7%94%A8free%E9%87%8A%E6%94%BE%E4%B8%80%E5%9D%97%E5%8A%A8%E6%80%81%E5%BC%80%E8%BE%9F%E5%86%85%E5%AD%98%E7%9A%84%E4%B8%80%E9%83%A8%E5%88%86">3.4 使用free释放一块动态开辟内存的一部分</h3>
<pre><code>void test()
{
int *p = (int *)malloc(100);
p++;
free(p);//p不再指向动态内存的起始位置
}</code></pre>
<h3 id="3.5%20%E5%AF%B9%E5%90%8C%E4%B8%80%E5%9D%97%E5%86%85%E5%AD%98%E8%BF%9B%E8%A1%8C%E5%A4%9A%E6%AC%A1%E9%87%8A%E6%94%BE">3.5 对同一块内存进行多次释放</h3>
<pre><code>void test()
{
int *p = (int *)malloc(100);
free(p);
free(p);//重复释放
}</code></pre>
<p>        free一个指针，只是清空该指针所指的堆区中的对应空间，但是该指针变量在栈中的值并没有没清空，依然指向原来分配的内存空间（但是该内存空间已经不属于该指针了，CPU随时可把该指针原来所指的空间分配给任何一个指针变量）。这时，再free一次时，由于该指针已经没有堆空间与之对应了，所以编译器将会提示出错。</p>
<p>所以正确的做法是将<strong>该指针释放后再置空</strong>。free(p); p-&gt;NULL；此时再次free(p)就不会报错。</p>
<h3 id="3.6%20%E5%8A%A8%E6%80%81%E5%BC%80%E8%BE%9F%E5%86%85%E5%AD%98%E5%BF%98%E8%AE%B0%E9%87%8A%E6%94%BE%EF%BC%88%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%89">3.6 动态开辟内存忘记释放（内存泄漏）</h3>
<pre><code>void test()
{
int *p = (int *)malloc(100);
if(NULL != p)
{
*p = 20;
}
}
int main()
{
test();
while(1);
}</code></pre>
<p>        在堆上分配的内存，如果不再使用了，就应该及时释放，以便后面其他地方可以使用。而 C 语言中的内存管理器不会自动回收不再使用的内存。如果忘了释放不再使用的内存，这些内存就不能被重用了，这就造成了内存泄漏。在堆上分配的内存，如果不再使用了，就应该及时释放，以便后面其他地方可以使用。一两处内存泄漏通常并不致于让程序崩溃，也不会带来逻辑上的错误，而且在进程退出时，系统会自动释放所有与该进程相关的内存（共享内存除外）。但是，量变会导致质变，一旦内存泄漏过多以致耗尽内存，后续内存分配将会失败，程序就可能因此而崩溃。</p>
<p><strong>重要的事情说三遍：<br/> 动态开辟的空间一定要释放，并且正确释放！</strong></p>
<p><strong>动态开辟的空间一定要释放，并且正确释放！</strong></p>
<p><strong>动态开辟的空间一定要释放，并且正确释放！</strong></p>
<h2 id="4.%C2%A0C%2FC%2B%2B%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%BC%80%E8%BE%9F"><strong>4. C/C++程序的内存开辟</strong></h2>
<p class="img-center"><img alt="" height="684" src="image\a5e3195a902045b0bd3a9b52fdf38f96.png" width="945"/></p>
<p></p>
<p><strong>栈区（stack）</strong>：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。 栈区主要存放运行函数而分配的局部变量、函数参数、返回数据、返回地址等。<br/><strong>堆区（heap）</strong>：一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。分配方式类似于链表。<br/><strong>数据段（静态区）（static）：</strong>存放全局变量、静态数据。程序结束后由系统释放。<br/><strong>代码段：</strong>存放函数体（类成员函数和全局函数）的二进制代码</p>
<h2 id="5.%E6%9F%94%E6%80%A7%E6%95%B0%E7%BB%84">5.柔性数组</h2>
<p>        C99 中，结构体中的最后一个元素允许是未知大小的数组，这就叫做『柔性数组』成员。</p>
<p>比如：</p>
<pre><code>typedef struct st_type
{
int i;
int a[0];//柔性数组成员
}type_a;</code></pre>
<h3 id="5.1%E6%9F%94%E6%80%A7%E6%95%B0%E7%BB%84%E7%9A%84%E7%89%B9%E7%82%B9">5.1柔性数组的特点</h3>
<p>        1）结构中的柔性数组成员前面必须至少一个其他成员。<br/>         2）sizeof 返回的这种结构大小不包括柔性数组的内存。<br/>         3）包含柔性数组成员的结构用malloc ()函数进行内存的动态分配，并且分配的内存应该大于结构的大小，以适应柔性数组的预期大小。</p>
<p>比如：</p>
<pre><code>typedef struct st_type
{
int i;
int a[0];//柔性数组成员
}type_a;
printf("%d\n", sizeof(type_a));//输出的是4</code></pre>
<h3 id="5.2%E6%9F%94%E6%80%A7%E6%95%B0%E7%BB%84%E7%9A%84%E4%BD%BF%E7%94%A8">5.2柔性数组的使用<br/>  </h3>
<pre><code>//代码1
int i = 0;
type_a *p = (type_a*)malloc(sizeof(type_a)+100*sizeof(int));
p-&gt;i = 100;
for(i=0; i&lt;100; i++)
{
p-&gt;a[i] = i;
}
free(p);</code></pre>
<p>        这样柔性数组成员a，获得了100个整型元素的连续空间。</p>
<h3 id="5.3%20%E6%9F%94%E6%80%A7%E6%95%B0%E7%BB%84%E7%9A%84%E4%BC%98%E5%8A%BF">5.3 柔性数组的优势</h3>
<p>        </p>
<pre><code>//代码2
typedef struct st_type
{
int i;
int *p_a;
}type_a;
type_a *p = (type_a *)malloc(sizeof(type_a));
p-&gt;i = 100;
p-&gt;p_a = (int *)malloc(p-&gt;i*sizeof(int));

for(i=0; i&lt;100; i++)
{
p-&gt;p_a[i] = i;
}
//释放空间
free(p-&gt;p_a);
p-&gt;p_a = NULL;
free(p);
p = NULL</code></pre>
<p>        在代码1和代码2中我们实现了同样的功能，但是代码1的实现有两个好处：</p>
<p>        1）方便内存释放<br/>         如果我们的代码是在一个给别人用的函数中做了二次内存分配，并把整个结构体返回给用户。用户调用free可以释放结构体，但是他们并不知道这个结构体内的成员也需要free。所以，如果我们把结构体的内存以及其成员要的内存一次性分配好了，并返回给用户一个结构体指针，用户做一次free就可以把所有的内存也给释放掉。<br/>         2）这样有利于访问速度.<br/>         连续的内存有益于提高访问速度，也有益于减少内存碎片。</p>
</div>
</div>