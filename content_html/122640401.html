<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<p>  <img alt="" height="109" src="image\451dfef5a53e4c94a3ecbfb02d167973.png" width="286"/>  ​​​​​​ 🤣 爆笑教程 👉  <a href="https://blog.csdn.net/weixin_50502862/category_11602059.html" title="《C++要笑着学》">《C++要笑着学》</a> 👈 火速订阅<strong>  </strong>🔥<img alt="" height="123" src="image\32974baa747043f9907e5bbd13639957.png" width="679"/></p>
<p><strong>💭 写在前面</strong></p>
<p>本章将带领大伙学习C++的缺省参数和函数重载部分的知识。对于一些容易出错的地方，我会帮大家踩坑演示一波。</p>
<p id="0x04%20%E5%85%A8%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0-toc" style="margin-left:80px;"></p>
<hr/>
<h2 id="%E4%B8%80%E3%80%81%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0">Ⅰ. 缺省参数</h2>
<h3 id="0x00%20%E5%BC%95%E5%85%A5">0x00 引入</h3>
<p><img alt="" height="160" src="image\d0f43553b7de4bc5911fd4c14c1b34b9.png" width="159"/></p>
<p>💬 这是一个简单的函数，功能就是打印出传递过来的数字：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

void Func(int num) {      // 此时接收，num = 1
    cout &lt;&lt; num &lt;&lt; endl;  
}

int main(void)
{
    Func(1);              // 传参：1
    
    return 0;
}</code></pre>
<blockquote>
<p>🚩 运行结果： 1</p>
</blockquote>
<p></p>
<p>❓ 如果我不想传参呢？我想直接调用<span style="color:#b95514;"> Func</span> 函数：</p>
<p><img alt="" height="116" src="image\980eed5f81e64127b984ac4f101bc43c.png" width="241"/></p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

void Func(int a) {
    cout &lt;&lt; a &lt;&lt; endl;
}

int main(void)
{
    Func();

    return 0;
}</code></pre>
<blockquote>
<p>🚩 运行结果：（报错）</p>
</blockquote>
<p><img alt="" height="464" src="image\eff9f84d0dde4eb9a02da55069d8bf6e.png" width="1112"/></p>
<p>💡 因为没有传递参数，所以自然会引发报错。</p>
<p>不过，在C++里我们可以利用一个叫 "缺省参数" 的东西，让该函数可以做到不传参也能运行的效果。</p>
<p></p>
<p>💬 利用 "缺省参数" ：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

void Func(int a = 0) {
    cout &lt;&lt; a &lt;&lt; endl;
}

int main(void)
{
    Func();

    return 0;
}</code></pre>
<blockquote>
<p>🚩 运行结果：（成功）</p>
</blockquote>
<p><img alt="" height="116" src="image\e247b89b392a45868cd2c454f6bdea8a.png" width="465"/></p>
<p><img alt="" height="165" src="image\7cc56cee23d64297a34a179c34ad1c17.png" width="162"/> 居然还能这么玩？下面我们就将学习这个神奇的 "缺省参数" 。</p>
<p></p>
<p></p>
<h3 id="0x01%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">0x01 基本概念</h3>
<p>神奇的 C++ 提供了缺省参数。</p>
<p>❓ 缺省参数，缺省……什么是缺省参数？</p>
<p><img alt="" height="344" src="image\e335d3126e43477c93a62e5f81576de9.png" width="431"/> 说人话就是 —— <strong>默认参数</strong>！！！</p>
<blockquote>
<p><span style="color:#1a439c;"><strong>【百度百科】</strong></span>缺省，即系统默认状态，意思与“默认”相同。</p>
</blockquote>
<p></p>
<p>📚 缺省参数：声明函数或定义函数时为函数的参数指定一个默认值。</p>
<p>该函数在调用时，如果没有指定实参，则采用该默认值；否则使用指定的实参。</p>
<p>简单来说就是：<span style="background-color:#f9eda6;">传参了就用传来的值，没传参就用默认值。</span></p>
<p></p>
<p></p>
<h3 id="0x02%20%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95">0x02 缺省参数的用法</h3>
<p>💬 代码演示：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

void Func(int a = 0) {     // 缺省值作为形参，传给 a
    cout &lt;&lt; a &lt;&lt; endl;
}

int main(void)
{
    Func(10);   // 传参时：使用指定的实参（传入10）
    Func();     // 没有传参时，使用默认的参数值（默认值：0）。

    return 0;
}</code></pre>
<blockquote>
<p>🚩 运行结果如下：</p>
</blockquote>
<p><img alt="" height="136" src="image\e912fed20a984551a512e69c89089a92.png" width="565"/></p>
<p></p>
<p>🔑 解析：</p>
<p><img alt="" height="350" src="image\ea927717c80f4e8889acf73059da1ac2.png" width="562"/></p>
<p>① 第一次调用 <span style="color:#ad720d;">Func</span> 时，指定了实参，就会照常传入，这里指定的是<span style="color:#b95514;"> 10</span>，所以传过去的是 <strong>10</strong>。</p>
<p>② 第二次调用 <span style="color:#ad720d;">Func</span> 时，并没有指定实参，所以进入函数后，形参<strong> a</strong> 会取缺省值 <span style="color:#b95514;">0 </span>作为参数的值。</p>
<p>③ 因此，第一次打印的结果是 <strong>10</strong>，第二次打印的结果是 <strong>0</strong>。</p>
<p></p>
<p>📌 注意：</p>
<p>① 声明不能在 .h 和 .cpp 里同时出现缺省参数，要么申明里写，要么在定义里写！</p>
<p><img alt="" height="729" src="image\351818391e674e3fba5bf3804a6d5482.png" width="1200"/></p>
<p>② 缺省值必须是常量或全局变量。</p>
<p>② 缺省参数C++里面的，C语言不支持（编译器不支持）。</p>
<p></p>
<p></p>
<h3 id="0x03%20%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0%E7%9A%84%E5%88%86%E7%B1%BB">0x03 缺省参数的分类</h3>
<p>📚 缺省参数分为<strong> 全缺省参数</strong> 和 <strong>半缺省参数</strong>。</p>
<p>① 全缺省参数：<span style="background-color:#f9eda6;">函数中的所有参数都给了缺省值。</span></p>
<p>② 半缺省参数：<span style="background-color:#f9eda6;">函数中的所有参数从右往左给一部分的缺省值。</span></p>
<p></p>
<h3 id="0x04%20%E5%85%A8%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0">0x04 全缺省参数</h3>
<p><img alt="" height="212" src="https://img-blog.csdnimg.cn/bc8d773b0c8e4664b2210c66d6f6d233.gif" width="346"/></p>
<p>📚 必须所有参数都带有缺省值，才能叫作全缺省参数。</p>
<p>💬 代码演示：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

void Func(int a = 10, int b = 20, int c = 30) {
    printf("%d %d %d\n", a, b, c);
}

int main(void)
{
    Func();           // 不穿，一个都没传
    Func(1);          // 只传了一个
    Func(1, 2);       // 传了两个，但没完全传
    Func(1, 2, 3);    // 全都传了，就没缺省参数什么事了

    return 0;
}</code></pre>
<blockquote>
<p>🚩 运行结果如下：</p>
</blockquote>
<p><img alt="" height="141" src="image\3af784cd19044f2abf5c3c4483af907c.png" width="440"/></p>
<p>🔑 解析：</p>
<p>① 第一次调用 <span style="color:#ad720d;">Func</span> 时，什么都没有传，所以结果直接就采用默认值。</p>
<p>② 第二次调用<span style="color:#ad720d;"> Func</span> 时，只传了一个参数，那么结果只有 a 不是默认值。</p>
<p>③ 第三次调用<span style="color:#ad720d;"> Func</span> 时，传了两个参数，那么结果只有 c 会是默认值了。</p>
<p>④ 最后一次调用<span style="color:#ad720d;"> Func</span> 时，所有参数都传了，那么结果都不会是默认值。</p>
<p></p>
<p><img alt="" height="117" src="image\ef6e97940b0041a3803d3a2ab046f00f.png" width="371"/></p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

void Func(int a = 10, int b = 20, int c = 30) {
    printf("%d %d %d\n", a, b, c);
}

int main(void)
{
    Func(, 2,);

    return 0;
}</code></pre>
<p><img alt="" height="135" src="image\a25d2f04a2ba4cee90f20dde93554dac.png" width="120"/>❌ 不可以！只传 <span style="color:#0d0016;">b</span> 不好传！</p>
<p>参数的传递按照语法是从左往右传递的，因为这是语法定死的，所以没有办法传。</p>
<p></p>
<p><img alt="" height="202" src="image\3c9248bf213741f6a8d66891474e346c.png" width="463"/></p>
<p><img alt="" height="52" src="image\eefc12555bf0497b8fcf258ebee44db4.png" width="52"/> 其实也并不是那么绝对的！在 <span style="background-color:#fbd4d0;">C++11</span> 以后，加了包装器以后是可以支持只传中间那个的，但是那个比较复杂，不适合在这里讲。</p>
<p></p>
<p></p>
<h3 id="0x04%C2%A0%E5%8D%8A%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0%C2%A0"><strong>0x04 半缺省参数</strong> </h3>
<p><img alt="" height="137" src="image\fdc79766910d4742a705e2b6ba59d7c1.png" width="469"/></p>
<p>📚 半缺省参数：<span style="background-color:#f9eda6;">函数中的所有参数从右往左连续地缺省一部分</span></p>
<p>这一部分可以是多个参数，也可以是一个参数（一个也算一部分），</p>
<p>但是它们必须是 "连续地" 。参数传递顺序根据根据函数调用约定。</p>
<p></p>
<p>📌 注意事项：</p>
<p>① 半缺省并不是缺省一半，而是缺省一部分。</p>
<p>② 半缺省参数必须从右往左缺省，且必须是连续地。即，<span style="background-color:#f9eda6;">必须从右往左连续缺省。</span></p>
<p></p>
<p><img alt="" height="232" src="image\0110f9d9b501495fa471b1a8e1541168.png" width="201"/></p>
<p>这是规定！这是大佬规定的！不服？</p>
<p><img alt="" height="181" src="image\e358e231ce5d4926b458cf0b12a2bf0a.png" width="210"/></p>
<p><img alt="" height="193" src="image\2c44778286e0494987c143106b9115ee.png" width="192"/>吐槽：既然不是缺省一半，还叫半缺省参数，这合理吗？这不合理！</p>
<p>这个 "半" 字确实用的不合理，倒不如叫 "部分缺省参数" ，会显得更加合理一些。</p>
<p></p>
<p>💬 代码演示：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

//                     👈 从左往右 "连续地"
void Func(int a, int b, int c = 30) {
    printf("%d %d %d\n", a, b, c);
}
/* 半缺省：从右往左连续地缺省一部分参数
   a - 必须传 （因为没缺省）
   b - 必须传 （因为没缺省）
   c - 可传可不传 （因为缺省了）
*/

int main(void)
{
    Func(1, 2);     // a b 没缺省，所以必须要传，c缺省了所以可以不传
    Func(1, 2, 3);  // 都传

    return 0;
}
</code></pre>
<blockquote>
<p>🚩 运行结果如下：</p>
</blockquote>
<p><img alt="" height="123" src="image\a3a3603b77354e12b7481649432d76ab.png" width="524"/></p>
<p></p>
<p>📜 建议：既然大佬是这么设计的，那我们也没办法。所以<span style="background-color:#f9eda6;">为了迎合这个特性，设计函数的时候如果有参数是必须要传递的，就放到前面；不是必须要传的，可以放到后面</span>（制作成缺省参数）。</p>
<p><img alt="" height="241" src="image\fc4c191d55fc464c969d83ea5fd961c7.png" width="260"/></p>
<p></p>
<p></p>
<h3 id="0x05%20%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">0x05 缺省参数的应用场景</h3>
<p>📚 缺省参数的运用场景有很多，我们随便举个例子。</p>
<p>我们在学习数据结构时，实现顺序表、栈时定义容量 <strong>capacity</strong> 时，默认值我们当时推荐的是给 <span style="color:#e6b223;">4</span>，这里就可以设置缺省值：</p>
<p><img alt="" height="140" src="image\8d5ce4794b26422ca875f85ef09d7924.png" width="244"/></p>
<p>💬 演示（仅展示部分代码）：</p>
<pre><code class="language-cpp">typedef struct Stack {
	int* array;
	int top;
	int capacity;
} Stack;

void StackInit (
	Stack* pst,  
	int capacity = 4  // 设置缺省值为4（默认容量为4）
	) 
{
	pst-&gt;array = (int*)malloc(sizeof(int) * capacity);
	pst-&gt;top = 0;
	pst-&gt;capacity = capacity;
}


int main()
{
	Stack st;
	StackInit(&amp;st);   // 不知道栈最多存多少数据，就用缺省值初始化
	StackInit(&amp;st, 100);   // 知道栈最多存100数据，显示传值。这样可以减少增容次数。

	return 0;
}</code></pre>
<blockquote>
<p>这么一来，就不需要考虑增容的概念了，这就是缺省参数的好处。所以，这个特性确实是很有用的，可以让我们更方便。</p>
</blockquote>
<p></p>
<p></p>
<h2 id="%E4%BA%8C%E3%80%81%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD">Ⅱ. 函数重载</h2>
<h3>0x00 引入</h3>
<p>自然语言中，同一句话，可能有多重意思，人们可以通过上下文来判断这句话的真实的含义：</p>
<p>国有两大体育项目不用看，也不用担心。一个是乒乓球，一个是国足。前者是 "谁也赢不了" ，后者是 "谁也赢不了" 。</p>
<p>"谁也赢不了" ，就相当于被重载了。</p>
<p></p>
<h3 id="0x01%20%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E7%9A%84%E6%A6%82%E5%BF%B5">0x01 函数重载的概念</h3>
<p style="text-align:center;"><img alt="" height="96" src="https://img-blog.csdnimg.cn/img_convert/3de701e9b17a9b11a4726bb2b1f7e764.gif" width="132"/></p>
<p>📚 函数重载：C++ 允许在同一个作用域中存在同名的函数。</p>
<p><span style="background-color:#f9eda6;">下面三个不同只要满足一个不同，就可以触发函数重载</span>：</p>
<p>① 参数类型不同</p>
<p>② 参数个数不同</p>
<p>③ 参数顺序不同</p>
<p></p>
<h3 id="0x02%20%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E7%9A%84%E4%B8%89%E7%A7%8D%E4%B8%8D%E5%90%8C">0x02 函数重载的三种不同</h3>
<p><strong>参数类型不同</strong></p>
<p><strong>💬 </strong>代码演示：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

int Add(int x, int y) {
	cout &lt;&lt; "int x, int y" &lt;&lt; endl;        // 为了方便区分
	return x + y;
}

double Add(double x, double y) {
	cout &lt;&lt; "double x, double y" &lt;&lt; endl;  // 为了方便区分
	return x + y;
}

int main(void)
{
	cout &lt;&lt; Add(1, 2) &lt;&lt; endl;
	cout &lt;&lt; Add(1.1, 2.2) &lt;&lt; endl;

	return 0;
}</code></pre>
<blockquote>
<p>🚩 运行结果如下：</p>
</blockquote>
<p><img alt="" height="150" src="image\3c7a8346689646a2a75e6f21cba7e962.png" width="481"/></p>
<p></p>
<p><strong>参数个数不同</strong></p>
<p>💬 代码演示：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

void Func(int a) {
	cout &lt;&lt; "Func(int a)" &lt;&lt; endl;
}

void Func(char b, int a) {
	cout &lt;&lt; "Func(char b, int a)" &lt;&lt; endl;
}
int main(void)
{
	Func(10);
	Func('A', 20);

	return 0;
}</code></pre>
<blockquote>
<p> 🚩 运行结果演示：</p>
</blockquote>
<p><img alt="" height="135" src="image\60c9b55625a143dd8bbd1a18172651b7.png" width="554"/></p>
<p></p>
<p><strong>参数顺序不同</strong></p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

void Func(int a, char b) {
	cout &lt;&lt; "int a, char b" &lt;&lt; endl;
}

void Func(char b, int a) {
	cout &lt;&lt; "char b, int a" &lt;&lt; endl;
}

int main(void)
{	
	Func(10, 'A');
	Func('A', 10);

	return 0;
}</code></pre>
<p><img alt="" height="149" src="image\8a355e4455e94d53a406f2ef8dd47365.png" width="489"/></p>
<p></p>
<p></p>
<h3 id="0x03%20%E4%B8%8D%E6%94%AF%E6%8C%81%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E7%9A%84%E6%83%85%E5%86%B5">0x03 不支持函数重载的情况</h3>
<p><img alt="" height="227" src="image\ebc157fd3e8c4505921603a3ab9e899a.png" width="319"/></p>
<p>❌ 返回值不同，调用时无法区分：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

int foo(double d) {
    ;
}

void foo(double d) {
    ;
}


int main(void)
{
    foo(1.1);  // ??? 会不知道这里到底是进 int foo 还是 void foo

    return 0;
}</code></pre>
<blockquote>
<p>🚩 运行结果：（报错）</p>
</blockquote>
<p><span style="background-color:#f9eda6;">函数重载不能依靠返回值的不同来构成重载</span>，因为调用时无法根据参数列表确定调用哪个重载函数。</p>
<p><img alt="" height="137" src="image\6105939dcf2549a5af6e6bb0e0afd2ef.png" width="527"/>  <img alt="" height="89" src="image\4605354d26974513a271775b8d62dc71.png" width="89"/></p>
<p></p>
<p><strong>❌ </strong>缺省值不同，不能构成重载！</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
void foo(int a) {
    cout &lt;&lt; "foo(int a)" &lt;&lt; endl;
}

void foo(int a = 10) {
    cout &lt;&lt; "foo(int a)" &lt;&lt; endl;
}

int main(void)
{
    foo(1);

    return 0;
}</code></pre>
<blockquote>
<p>🚩 运行结果：（报错）</p>
</blockquote>
<p><img alt="" height="64" src="image\af403957006e44afb8012cf4183fce9b.png" width="432"/></p>
<p></p>
<p>❎ 可构成重载但存在歧义，但使用时又是会出现问题：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

void func() {
    cout &lt;&lt; "func()" &lt;&lt; endl;
}

void func(int a = 0) {
    cout &lt;&lt; "func(int a)" &lt;&lt; endl;
}

int main(void)
{
    func();   // 调用存在歧义 ❌
    func(1);  // 可以 ✅

    return 0;
}</code></pre>
<blockquote>
<p>🚩 运行结果：（报错）</p>
</blockquote>
<p><img alt="" height="687" src="image\7f409fb46d11495d8ca87da1f742844b.png" width="1144"/></p>
<p></p>
<p> <img alt="" height="62" src="image\7a80245f0b5f4021a033b3789a9efdeb.png" width="707"/>​</p>
<pre><code class="language-cpp">📌 [ 笔者 ]   王亦优
📃 [ 更新 ]   2022.1.22
❌ [ 勘误 ]   qq_21049619：0X05示例代码的第22行写错了，
              和21行重复了，应该是StackInit(&amp;st, 100);【已修正】
              PeppaZH：Ⅰ0x02 解析处打印结果写反了【已修正】
              qq_15779857：0x05的例子第12行有误【已修正】
              三都嗯：某处举例不合适【已修正】
📜 [ 声明 ]   由于作者水平有限，本文有错误和不准确之处在所难免，
              本人也很想知道这些错误，恳望读者批评指正！</code></pre>
<table align="center" border="1" cellpadding="1" cellspacing="1"><tbody><tr><td> <p><strong>📜 参考资料 </strong></p> <p><span style="color:#7b7f82;">Microsoft. MSDN(Microsoft Developer Network)[EB/OL]. []. .</span></p> <p><span style="color:#7b7f82;">百度百科[EB/OL]. []. https://baike.baidu.com/.</span></p> <p><span style="color:#7b7f82;">比特科技. C++[EB/OL]. 2021[2021.8.31]. .</span></p> </td></tr></tbody></table>
<p></p>
</div>
</div>