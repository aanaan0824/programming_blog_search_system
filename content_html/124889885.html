<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<h1 id="main-toc"><strong>目录</strong></h1>
<p id="%F0%9F%8C%BA203.%20%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0-toc" style="margin-left:0px;"><a href="#%F0%9F%8C%BA203.%20%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0">🌺稀疏矩阵</a></p>
<p id="%F0%9F%8D%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-toc" style="margin-left:40px;"><a href="#%F0%9F%8D%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">🍁矩阵与稀疏矩阵的定义</a></p>
<p id="%F0%9F%8C%BA%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E7%9A%84%E8%BD%AC%E7%BD%AE-toc" style="margin-left:0px;"><a href="#%F0%9F%8C%BA%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E7%9A%84%E8%BD%AC%E7%BD%AE">🌺稀疏矩阵的转置</a></p>
<p id="%F0%9F%8D%81%E8%AF%A6%E7%BB%86%E6%80%9D%E8%B7%AF-toc" style="margin-left:40px;"><a href="#%F0%9F%8D%81%E8%AF%A6%E7%BB%86%E6%80%9D%E8%B7%AF">🍁详细思路</a></p>
<p id="%F0%9F%8D%80%E6%80%9D%E8%B7%AF%E4%B8%80%E3%80%90%E8%BF%AD%E4%BB%A3%E3%80%91-toc" style="margin-left:80px;"><a href="#%F0%9F%8D%80%E6%80%9D%E8%B7%AF%E4%B8%80%E3%80%90%E8%BF%AD%E4%BB%A3%E3%80%91">🍀思路一</a></p>
<p id="%F0%9F%8D%80%E6%80%9D%E8%B7%AF%E4%BA%8C-toc" style="margin-left:80px;"><a href="#%F0%9F%8D%80%E6%80%9D%E8%B7%AF%E4%BA%8C">🍀思路二</a></p>
<p id="%F0%9F%8C%BA%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E7%9A%84%E4%B9%98%E6%B3%95-toc" style="margin-left:0px;"><a href="#%F0%9F%8C%BA%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E7%9A%84%E4%B9%98%E6%B3%95">🌺稀疏矩阵的乘法</a></p>
<p id="%F0%9F%8D%81%E8%AF%A6%E7%BB%86%E6%80%9D%E8%B7%AF-toc" style="margin-left:40px;"><a href="#%F0%9F%8D%81%E8%AF%A6%E7%BB%86%E6%80%9D%E8%B7%AF">🍁详细思路</a></p>
<p class="img-center"><img alt="94536690f848438fab30aa17191a6ea2.png" src="https://img-blog.csdnimg.cn/94536690f848438fab30aa17191a6ea2.png"/></p>
<h1 id="%F0%9F%8C%BA203.%20%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0">🌺稀疏矩阵</h1>
<blockquote>
<h2 id="%F0%9F%8D%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span style="background-color:#f9eda6;">🍁矩阵与稀疏矩阵的定义</span></h2>
<hr/>
<p><span style="color:#38d8f0;"><strong>Q：什么是矩阵</strong></span></p>
<p></p>
<p><span style="color:#ff9900;"><strong>A：</strong></span>数学上，一个<span style="color:#956fe7;">矩阵</span>由 m 行 n 列的元素组成，是一个 m 行，n 列的表，m 和 n 是矩阵的<span style="color:#956fe7;">维度</span>。一般地，写作 mxn（读作“m乘n”）来指明一个 m 行 n 列矩阵。矩阵的元素个数总计为 mn 个。<span style="color:#be191c;">如果 m 等于 n ，矩阵为方阵</span>。</p>
<p></p>
<p class="img-center"><img alt="" height="336" src="image\8c5cfd90afc34440abc8f68e6e7698cc.png" width="624"/></p>
<p><span style="color:#be191c;">一般情况下，矩阵的标准存储方式是一个二维数组 a[MAX_ROWS][MAX_COLS] </span>。利用这种存储方式，可以通过 a[i][j] ，通过行下标，列下标快速找到任意元素的存储位置。</p>
<hr/>
<p><span style="color:#38d8f0;"><strong>Q：什么是稀疏矩阵</strong></span></p>
<p></p>
<p><span style="color:#ff9900;"><strong>A：</strong></span>一个矩阵的绝大部分都为零元素，我们把这种矩阵称为稀疏矩阵。</p>
<p class="img-center"><img alt="" height="319" src="image\619d511b3f3e4fcc8750a7b1f2bd1c3e.png" width="442"/></p>
<p><span style="color:#956fe7;"><strong> </strong></span></p>
<p><span style="color:#956fe7;"><strong>如图：</strong></span>矩阵中只有 2/15 是非零元素，这就是一个标准的稀疏矩阵</p>
<hr/>
<p><span style="color:#38d8f0;"><strong>Q：二维数组储存矩阵的缺点</strong></span></p>
<p></p>
<p><span style="color:#ff9900;"><strong>A：</strong></span>如果一个矩阵中包含很多零元素（是稀疏矩阵），就会浪费大量的存储空间。<span style="color:#be191c;">因此，稀疏矩阵的存储表示只需存储非零元素。</span></p>
<hr/>
<p><span style="color:#38d8f0;"><strong>Q：稀疏矩阵的存储方式</strong></span></p>
<p></p>
<p><span style="color:#ff9900;"><strong>A：</strong></span>通过对矩阵的分析，我们发现使用三元组 &lt;row,col,value&gt; 能够唯一的刻画矩阵的任意一个元素。<span style="color:#be191c;">这意味者可以使用三元数组来存储表示稀疏矩阵。</span></p>
<p><strong>💬 代码演示</strong></p>
<pre><code class="language-cpp">#define MAX_TERMS 101	//定义最大长度 
typedef struct{
	int col;
	int row;
	int xalue;
}term;
term a[MAX_TERMS];
</code></pre>
<p>我们可以用 a[0].row 表示行的数目，用 a[0].col 表示列的数目，用 a[0].value 表示非零元素的总数。其他位置 row 域存放行下标， col 域存放列下标，value 域存放元素值。<span style="color:#be191c;">三元组按照行的顺序排序，并且在同一行内按照列的顺序排序。</span></p>
<table align="center" border="1" cellpadding="1" cellspacing="1" style="width:500px;"><caption>
   稀疏矩阵存储为三元组
  </caption><thead><tr><th></th><th>行</th><th>列</th><th>值</th></tr></thead><tbody><tr><td>a[0]</td><td>5</td><td>6</td><td>4</td></tr><tr><td>a[1]</td><td>0</td><td>0</td><td>15</td></tr><tr><td>a[2]</td><td>1</td><td>1</td><td>11</td></tr><tr><td>a[3]</td><td>2</td><td>3</td><td>6</td></tr><tr><td>a[4]</td><td>4</td><td>0</td><td>9</td></tr></tbody></table>
<p></p>
</blockquote>
<p class="img-center"><img alt="94536690f848438fab30aa17191a6ea2.png" src="https://img-blog.csdnimg.cn/94536690f848438fab30aa17191a6ea2.png"/></p>
<h1 id="%F0%9F%8C%BA%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E7%9A%84%E8%BD%AC%E7%BD%AE">🌺稀疏矩阵的转置</h1>
<blockquote>
<h2 id="%F0%9F%8D%81%E8%AF%A6%E7%BB%86%E6%80%9D%E8%B7%AF"><span style="background-color:#f9eda6;">🍁详细思路</span></h2>
<p>为了转置一个矩阵，必须交换它的行和列。也就是说，原矩阵的任意元素 a[i][j] 应该成为其转置矩阵的元素 b[j][i]</p>
<hr/>
<h3 id="%F0%9F%8D%80%E6%80%9D%E8%B7%AF%E4%B8%80%E3%80%90%E8%BF%AD%E4%BB%A3%E3%80%91"><span style="background-color:#c7e6ea;">🍀思路一</span></h3>
<p>依次循环每一列，找到每一列的所有元素并把他们储存在转置矩阵的对应的行上。</p>
<pre><code class="language-cpp">//伪代码
for 对于 j 列的所有元素
    把元素&lt;i，j，value&gt;放置在元素&lt;j，i，value&gt;中</code></pre>
<p><strong>💬 代码演示</strong></p>
<pre><code class="language-cpp">void transpose(term a[],term b[])
//b是a的转置 
{
	int n,i,j,currentb;
	n=a[0].value;			//元素总数 
	b[0].row=a[0].col;		//b的行数=a的列数
	b[0].co 1=a[0].row;	    //b的列数=a的行数
	b[0].value =n;
	if(n&gt; 0) 
	{// 非零矩阵 
		currentb=1;
		for(i=0;i&lt;a[0].col;i++)
		//按a的列转置
			for(j=1;j&lt;=n;j++)
			//找出当前列的所有元素
				if(a[j].col==i)
				{//元素是当前列的，加入b
					b[currentb]. row=a[j]. col;
					b[currentb]. col=a[j]. row;
					b[currentb]. value=a[j]. value;
					currentb++;
				}
	}
}</code></pre>
<hr/>
<h3 id="%F0%9F%8D%80%E6%80%9D%E8%B7%AF%E4%BA%8C"><span style="background-color:#c7e6ea;">🍀思路二</span></h3>
<p><span style="color:#be191c;">首先确定原矩阵中每一列的元素个数，这也就是其转置矩阵中每一行的元素个数</span>。于是就可以得到转置矩阵每行的起始位置，从而，<span style="color:#956fe7;">可以将原矩阵的元素依次移到其转置矩阵中的恰当位置</span>。</p>
<p><strong>💬 代码演示</strong></p>
<pre><code class="language-cpp">void fast transpose(term a[], term b[])
{
//将a的转置矩阵存放于b中 
	int row terms[MAX_COL], starting pos[MAX_COL]; 
	int i,j, num_cols=a[0].col, num_terms=a[0].value;
	b[0].row=num_cols;b[0].col=a[0].row;
	b[0].value=num_terms;
	if(num_terms&gt;0){//非零矩阵
		for(i=0;i&lt;num_cols;i++)
			row_terms[i]=0;
		for(i=1;i&lt;=num_terms;i++)
			row_terms[a[i]. co]]++;
		starting_pos[0]=1;
		for(i=1;i&lt;num cols;i++)
			starting_pos[i]=starting_pos[i-1]+row_terms[i-l];
		for(i=1;i&lt;=num_terms;i++){
			j=starting_pos[a[i].col]++;
			b[j].row=a[i].col;b[j].col=a[i].row;
			b[j].value=a[i].value;
		}
	}
}</code></pre>
</blockquote>
<p class="img-center"><img alt="94536690f848438fab30aa17191a6ea2.png" src="https://img-blog.csdnimg.cn/94536690f848438fab30aa17191a6ea2.png"/></p>
<h1 id="%F0%9F%8C%BA%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E7%9A%84%E4%B9%98%E6%B3%95">🌺稀疏矩阵的乘法</h1>
<blockquote>
<p><span style="color:#38d8f0;"><strong>Q：什么是矩阵乘法</strong></span></p>
<p></p>
<p><span style="color:#ff9900;"><strong>A：</strong></span>设A为 mxp 的矩阵，B为 pxn 的矩阵，那么称 mxn 的矩阵D为矩阵A与B的乘积，记作D=AB，其中矩阵D中的第 i 行第 j 列元素可以表示为：</p>
<p class="img-center"><img alt="" height="68" src="image\21ffbc47a3f649f8a2ece920f8849b49.png" width="568"/></p>
<p><strong><span style="color:#956fe7;">注意：</span></strong>两个稀疏矩阵的乘积可能不再是稀疏矩阵</p>
<hr/>
<h2><span style="background-color:#f9eda6;">🍁详细思路</span></h2>
<hr/>
<p><span style="color:#be191c;">我们可以按照行的顺序计算D的元素</span>，把元素存放到正确的位置，这样就不用移动已计算出的元素的位置。一般情况下，必须遍历整个B才能得到第 j 列的所有元素。但是，<span style="color:#956fe7;">我们可以先计算 B 的转置</span>，使列元素顺序相续排序，可以避免重复多次遍历整个 B 。</p>
<p>对于找出的 A 的第 i 行和 B 的第 j 列的所有元素，做合并操作就能实现矩阵乘法。</p>
<p><strong>💬 代码演示</strong></p>
<pre><code class="language-cpp">void storesum(term a[],int *totald,int row,int column,int *sum)
{//如果 *sum！=0，它的行和列存储位置为 d 中的 *totald+1
	if(*sum)
		if(*tptald&lt;MAX_TERMS)
		{
			d[++*totald].row=row;
			d[*totald].col=column;
			d[*totald].value=*sum;
			*sum=0;
		}
		else{
			fprintf(stderr,"Numbers of terms in product exceeds %d\n",MAX_TERMS); 
			exit(1);
		}
}


void mmult(term a[], term b[], term d[])
//将两个稀疏矩阵相乘 
{
	int i,j,column,totalb=b[0].value,totald=0; 
	int rows_a=a[0].row,cols_a=a[0].col;
	totala=a[0].value;int cols_b=b[0].col;
	int row_begin=1, row=a[1].row, sum=0; 
	int new_b[MAX-TERMS][3];
	if(cols_a!=b[0].row){
		fprintf(stderr,"Incompatible matrices\n"); 
		exit(1);
	}
	fast_transpose(b.new_b);
	//设置边界条件
	a[totala+1].row=rows_a;
	new_b[totalb+1].row=cols_b; 
	new_b[totalb+1].col=0;
	for(i=1;i&lt;=totala;){
		column=new_b[1].row; 
		for(j=1;j&lt;=totalb+1;){
		//将a的行乘以b的列
			if(a[i].row!=row){
				storesum(d,&amp;totald,row,column,&amp;sum);
				i=row_begin;
				for(;new_b[j].row==column;j++)
					;
				column=new_b[j]. row;
			}
			else if(new_b[j].row!=column){
				storesum(d,&amp;totald,row,column,&amp;sum); 
				i=row_begin;
				column=new_b[j].row;
			}
			else switch(COMPARE(a[i].col,new_b[j].col)){
				case-1://转到a中的下一项
					i++;break;
				case 0://添加项，转到a和b的下一项 
					sum+=(a[i++].value*new_b[j++].value); break;
				case 1://来到b的下一项
					j++;
			}
	}// for j&lt;=totalb+1 结束循环 
	for(;a[i].row==row;i++)
		;
	row_begin=i;row=a[i].row;
	}//for i&lt;=totala 结束循环 
	d[0].row=rows_a;
	d[0].col=cols_b;d[0].value=totald;
}</code></pre>
</blockquote>
</div>
</div>