<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<p id="main-toc"><strong>目录</strong></p>
<p id="%C2%A0%E6%9C%AC%E6%95%99%E7%A8%8B%E9%85%8D%E5%A5%97%E8%A7%86%E9%A2%91-toc" style="margin-left:0px;"><a href="#%C2%A0%E6%9C%AC%E6%95%99%E7%A8%8B%E9%85%8D%E5%A5%97%E8%A7%86%E9%A2%91"> 本教程配套视频</a></p>
<p id="1.%20%E9%A1%B9%E7%9B%AE%E7%9B%AE%E6%A0%87-toc" style="margin-left:0px;"><a href="#1.%20%E9%A1%B9%E7%9B%AE%E7%9B%AE%E6%A0%87">1. 项目目标</a></p>
<p id="2.%20%E6%95%88%E6%9E%9C%E6%BC%94%E7%A4%BA-toc" style="margin-left:0px;"><a href="#2.%20%E6%95%88%E6%9E%9C%E6%BC%94%E7%A4%BA">2. 效果演示</a></p>
<p id="3.%20%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE-toc" style="margin-left:0px;"><a href="#3.%20%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE">3. 创建项目</a></p>
<p id="%C2%A04.%20%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1-toc" style="margin-left:0px;"><a href="#%C2%A04.%20%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1"> 4. 项目框架设计</a></p>
<p id="4.1%20%E8%AE%BE%E8%AE%A1%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6-toc" style="margin-left:40px;"><a href="#4.1%20%E8%AE%BE%E8%AE%A1%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6">4.1 设计项目框架</a></p>
<p id="4.2%20%E6%A0%B9%E6%8D%AE%E8%AE%BE%E8%AE%A1%E6%A1%86%E6%9E%B6%E5%88%9B%E5%BB%BA%E7%B1%BB-toc" style="margin-left:40px;"><a href="#4.2%20%E6%A0%B9%E6%8D%AE%E8%AE%BE%E8%AE%A1%E6%A1%86%E6%9E%B6%E5%88%9B%E5%BB%BA%E7%B1%BB">4.2 根据设计框架创建类</a></p>
<p id="%C2%A05.%20%E7%BB%99%E7%B1%BB%E6%B7%BB%E5%8A%A0%E4%B8%BB%E8%A6%81%E6%8E%A5%E5%8F%A3-toc" style="margin-left:0px;"><a href="#%C2%A05.%20%E7%BB%99%E7%B1%BB%E6%B7%BB%E5%8A%A0%E4%B8%BB%E8%A6%81%E6%8E%A5%E5%8F%A3"> 5. 给类添加主要接口</a></p>
<p id="5.1%20%E8%AE%BE%E8%AE%A1%E6%A3%8B%E7%9B%98%E7%B1%BBChess%E7%9A%84%E4%B8%BB%E8%A6%81%E6%8E%A5%E5%8F%A3-toc" style="margin-left:40px;"><a href="#5.1%20%E8%AE%BE%E8%AE%A1%E6%A3%8B%E7%9B%98%E7%B1%BBChess%E7%9A%84%E4%B8%BB%E8%A6%81%E6%8E%A5%E5%8F%A3">5.1 设计棋盘类Chess的主要接口</a></p>
<p id="%C2%A05.2%20%E8%AE%BE%E8%AE%A1AI%E7%B1%BB%E7%9A%84%E4%B8%BB%E8%A6%81%E6%8E%A5%E5%8F%A3-toc" style="margin-left:40px;"><a href="#%C2%A05.2%20%E8%AE%BE%E8%AE%A1AI%E7%B1%BB%E7%9A%84%E4%B8%BB%E8%A6%81%E6%8E%A5%E5%8F%A3"> 5.2 设计AI类的主要接口</a></p>
<p id="%C2%A05.3%20%E8%AE%BE%E8%AE%A1Man%E7%B1%BB%E7%9A%84%E4%B8%BB%E8%A6%81%E6%8E%A5%E5%8F%A3-toc" style="margin-left:40px;"><a href="#%C2%A05.3%20%E8%AE%BE%E8%AE%A1Man%E7%B1%BB%E7%9A%84%E4%B8%BB%E8%A6%81%E6%8E%A5%E5%8F%A3"> 5.3 设计Man类的主要接口</a></p>
<p id="%C2%A05.4%20%E8%AE%BE%E8%AE%A1ChessGame%E7%9A%84%E4%B8%BB%E8%A6%81%E6%8E%A5%E5%8F%A3-toc" style="margin-left:40px;"><a href="#%C2%A05.4%20%E8%AE%BE%E8%AE%A1ChessGame%E7%9A%84%E4%B8%BB%E8%A6%81%E6%8E%A5%E5%8F%A3"> 5.4 设计ChessGame的主要接口</a></p>
<p id="5.5%20%E6%B7%BB%E5%8A%A0%E5%90%84%E4%B8%AA%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#5.5%20%E6%B7%BB%E5%8A%A0%E5%90%84%E4%B8%AA%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0">5.5 添加各个接口的具体实现</a></p>
<p id="6.%20%E5%AE%9E%E7%8E%B0%E6%B8%B8%E6%88%8F%E6%8E%A7%E5%88%B6-toc" style="margin-left:0px;"><a href="#6.%20%E5%AE%9E%E7%8E%B0%E6%B8%B8%E6%88%8F%E6%8E%A7%E5%88%B6">6. 实现游戏控制</a></p>
<p id="6.1%20%E6%B7%BB%E5%8A%A0%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98-toc" style="margin-left:40px;"><a href="#6.1%20%E6%B7%BB%E5%8A%A0%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98">6.1 添加数据成员</a></p>
<p id="6.2%20%E5%AE%9E%E7%8E%B0%E6%B8%B8%E6%88%8F%E6%8E%A7%E5%88%B6%E5%95%8A-toc" style="margin-left:40px;"><a href="#6.2%20%E5%AE%9E%E7%8E%B0%E6%B8%B8%E6%88%8F%E6%8E%A7%E5%88%B6%E5%95%8A">6.2 实现游戏控制啊</a></p>
<p id="7.%20%E5%88%9B%E5%BB%BA%E6%B8%B8%E6%88%8F%C2%A0-toc" style="margin-left:0px;"><a href="#7.%20%E5%88%9B%E5%BB%BA%E6%B8%B8%E6%88%8F%C2%A0">7. 创建游戏 </a></p>
<p id="8.%20%E6%A3%8B%E7%9B%98%E7%9A%84%E2%80%9C%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E2%80%9D%E8%AE%BE%E8%AE%A1-toc" style="margin-left:0px;"><a href="#8.%20%E6%A3%8B%E7%9B%98%E7%9A%84%E2%80%9C%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E2%80%9D%E8%AE%BE%E8%AE%A1">8. 棋盘的“数据成员”设计</a></p>
<p id="9.%20%E4%BD%BF%E7%94%A8%E6%A3%8B%E7%9B%98%E7%B1%BB%E7%9A%84%E2%80%9C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E2%80%9D%20%E5%AF%B9%E6%A3%8B%E7%9B%98%E8%BF%9B%E8%A1%8C%E6%9E%84%E9%80%A0-toc" style="margin-left:0px;"><a href="#9.%20%E4%BD%BF%E7%94%A8%E6%A3%8B%E7%9B%98%E7%B1%BB%E7%9A%84%E2%80%9C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E2%80%9D%20%E5%AF%B9%E6%A3%8B%E7%9B%98%E8%BF%9B%E8%A1%8C%E6%9E%84%E9%80%A0">9. 使用棋盘类的“构造函数” 对棋盘进行构造</a></p>
<p id="10.%20%E6%A3%8B%E7%9B%98%E7%9A%84%E2%80%9C%E5%88%9D%E5%A7%8B%E5%8C%96%E2%80%9D%20-%20%E6%AD%A3%E5%9C%A8%E6%9B%B4%E6%96%B0-toc" style="margin-left:0px;"><a href="#10.%20%E6%A3%8B%E7%9B%98%E7%9A%84%E2%80%9C%E5%88%9D%E5%A7%8B%E5%8C%96%E2%80%9D%20-%20%E6%AD%A3%E5%9C%A8%E6%9B%B4%E6%96%B0">10. 棋盘的“初始化” </a></p>
<p id="11.%20%E5%AE%9E%E7%8E%B0%E6%A3%8B%E6%89%8B%E8%B5%B0%E6%A3%8B-toc" style="margin-left:0px;"><a href="#11.%20%E5%AE%9E%E7%8E%B0%E6%A3%8B%E6%89%8B%E8%B5%B0%E6%A3%8B">11. 实现棋手走棋</a></p>
<p id="11.1%20%E6%A3%8B%E6%89%8B%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:40px;"><a href="#11.1%20%E6%A3%8B%E6%89%8B%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96">11.1 棋手的初始化</a></p>
<p id="11.2%20%E6%A3%8B%E6%89%8B%E8%B5%B0%E6%A3%8B-toc" style="margin-left:40px;"><a href="#11.2%20%E6%A3%8B%E6%89%8B%E8%B5%B0%E6%A3%8B">11.2 棋手走棋</a></p>
<p id="11.3%20%E5%88%A4%E6%96%AD%E8%90%BD%E5%AD%90%E7%82%B9%E5%87%BB%E4%BD%8D%E7%BD%AE%E6%98%AF%E5%90%A6%E6%9C%89%E6%95%88-toc" style="margin-left:40px;"><a href="#11.3%20%E5%88%A4%E6%96%AD%E8%90%BD%E5%AD%90%E7%82%B9%E5%87%BB%E4%BD%8D%E7%BD%AE%E6%98%AF%E5%90%A6%E6%9C%89%E6%95%88">11.3 判断落子点击位置是否有效</a></p>
<p id="%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90-toc" style="margin-left:80px;"><a href="#%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90">原理分析</a></p>
<p id="%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px;"><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">代码实现</a></p>
<p id="12.%20%E5%AE%9E%E7%8E%B0%E6%A3%8B%E7%9B%98%E8%90%BD%E5%AD%90-toc" style="margin-left:0px;"><a href="#12.%20%E5%AE%9E%E7%8E%B0%E6%A3%8B%E7%9B%98%E8%90%BD%E5%AD%90">12. 实现棋盘落子</a></p>
<p id="12.1%20%E5%AE%9E%E7%8E%B0Chess%E7%B1%BB%E7%9A%84chessDown%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#12.1%20%E5%AE%9E%E7%8E%B0Chess%E7%B1%BB%E7%9A%84chessDown%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0">12.1 实现Chess类的chessDown成员函数</a></p>
<p id="12.2%20%E4%BF%AE%E6%94%B9%E6%A3%8B%E7%9B%98%E7%9A%84%E6%A3%8B%E5%AD%90%E6%95%B0%E6%8D%AE-toc" style="margin-left:40px;"><a href="#12.2%20%E4%BF%AE%E6%94%B9%E6%A3%8B%E7%9B%98%E7%9A%84%E6%A3%8B%E5%AD%90%E6%95%B0%E6%8D%AE">12.2 修改棋盘的棋子数据</a></p>
<p id="13.%20%E5%AE%9E%E7%8E%B0AI%E8%B5%B0%E6%A3%8B-toc" style="margin-left:0px;"><a href="#13.%20%E5%AE%9E%E7%8E%B0AI%E8%B5%B0%E6%A3%8B">13. 实现AI走棋</a></p>
<p id="13.1%20%E8%AE%BE%E8%AE%A1AI%E7%9A%84%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98-toc" style="margin-left:40px;"><a href="#13.1%20%E8%AE%BE%E8%AE%A1AI%E7%9A%84%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98">13.1 设计AI的数据成员</a></p>
<p id="13.2%20%E5%AF%B9AI%E8%BF%9B%E8%A1%8C%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:40px;"><a href="#13.2%20%E5%AF%B9AI%E8%BF%9B%E8%A1%8C%E5%88%9D%E5%A7%8B%E5%8C%96">13.2 对AI进行初始化</a></p>
<p id="13.3%20AI%E2%80%9C%E6%80%9D%E8%80%83%E2%80%9D%E6%80%8E%E6%A0%B7%E8%B5%B0%E6%A3%8B-toc" style="margin-left:40px;"><a href="#13.3%20AI%E2%80%9C%E6%80%9D%E8%80%83%E2%80%9D%E6%80%8E%E6%A0%B7%E8%B5%B0%E6%A3%8B">13.3 AI“思考”怎样走棋</a></p>
<p id="13.3.1%20AI%E5%AF%B9%E8%90%BD%E5%AD%90%E7%82%B9%E8%BF%9B%E8%A1%8C%E8%AF%84%E5%88%86-toc" style="margin-left:80px;"><a href="#13.3.1%20AI%E5%AF%B9%E8%90%BD%E5%AD%90%E7%82%B9%E8%BF%9B%E8%A1%8C%E8%AF%84%E5%88%86">13.3.1 AI对落子点进行评分</a></p>
<p id="13.3.2%C2%A0%C2%A0AI%E6%A0%B9%E6%8D%AE%E8%AF%84%E5%88%86%E8%BF%9B%E8%A1%8C%E2%80%9C%E6%80%9D%E8%80%83%E2%80%9D-toc" style="margin-left:80px;"><a href="#13.3.2%C2%A0%C2%A0AI%E6%A0%B9%E6%8D%AE%E8%AF%84%E5%88%86%E8%BF%9B%E8%A1%8C%E2%80%9C%E6%80%9D%E8%80%83%E2%80%9D">13.3.2  AI根据评分进行“思考”</a></p>
<p id="%C2%A012.3.3%20AI%E8%B5%B0%E6%A3%8B-toc" style="margin-left:80px;"><a href="#%C2%A012.3.3%20AI%E8%B5%B0%E6%A3%8B"> 12.3.3 AI走棋</a></p>
<p id="%C2%A012.3.4%20%E6%B5%8B%E8%AF%95-toc" style="margin-left:80px;"><a href="#%C2%A012.3.4%20%E6%B5%8B%E8%AF%95"> 12.3.4 测试</a></p>
<p id="14.%20AI%E7%9A%84BUG-toc" style="margin-left:0px;"><a href="#14.%20AI%E7%9A%84BUG">14. AI的BUG</a></p>
<p id="15.%20%E5%88%A4%E6%96%AD%E8%83%9C%E8%B4%9F-toc" style="margin-left:0px;"><a href="#15.%20%E5%88%A4%E6%96%AD%E8%83%9C%E8%B4%9F">15. 判断胜负</a></p>
<p id="15.1%20%E5%AF%B9%E8%83%9C%E8%B4%9F%E8%BF%9B%E8%A1%8C%E5%A4%84%E7%90%86-toc" style="margin-left:40px;"><a href="#15.1%20%E5%AF%B9%E8%83%9C%E8%B4%9F%E8%BF%9B%E8%A1%8C%E5%A4%84%E7%90%86">15.1 对胜负进行处理</a></p>
<p id="15.2%20%E8%83%9C%E8%B4%9F%E5%88%A4%E5%AE%9A%E5%8E%9F%E7%90%86-toc" style="margin-left:40px;"><a href="#15.2%20%E8%83%9C%E8%B4%9F%E5%88%A4%E5%AE%9A%E5%8E%9F%E7%90%86">15.2 胜负判定原理</a></p>
<p id="15.%203%20%E5%AE%9E%E7%8E%B0%E8%83%9C%E8%B4%9F%E5%88%A4%E5%AE%9A-toc" style="margin-left:40px;"><a href="#15.%203%20%E5%AE%9E%E7%8E%B0%E8%83%9C%E8%B4%9F%E5%88%A4%E5%AE%9A">15. 3 实现胜负判定</a></p>
<p id="15.%204%20%E6%B5%8B%E8%AF%95%E6%95%88%E6%9E%9C-toc" style="margin-left:40px;"><a href="#15.%204%20%E6%B5%8B%E8%AF%95%E6%95%88%E6%9E%9C">15. 4 测试效果</a></p>
<p id="16.%20AI%E8%BF%9B%E4%B8%80%E6%AD%A5%E4%BC%98%E5%8C%96-toc" style="margin-left:0px;"><a href="#16.%20AI%E8%BF%9B%E4%B8%80%E6%AD%A5%E4%BC%98%E5%8C%96">16. AI进一步优化</a></p>
<p id="AI%E6%8F%90%E5%8D%87-toc" style="margin-left:40px;"><a href="#AI%E6%8F%90%E5%8D%87">AI提升</a></p>
<p id="17.%20%E5%BC%80%E5%8F%91%E6%8B%93%E5%B1%95-toc" style="margin-left:0px;"><a href="#17.%20%E5%BC%80%E5%8F%91%E6%8B%93%E5%B1%95">17. 开发拓展</a></p>
<hr id="hr-toc"/>
<p>五子棋人机对战，已经有很版本。但是使用纯C++，严格按照C++面向对象思想开发的，却还是很少的，所以准备使用C++面向对象的思想，开发一个完整的五子棋人机对战，对于C++初学者，是很有帮助的哦！</p>
<h1 id="%C2%A0%E6%9C%AC%E6%95%99%E7%A8%8B%E9%85%8D%E5%A5%97%E8%A7%86%E9%A2%91"><br/><span style="color:#fe2c24;"> <a class="link-info" href="https://www.bilibili.com/video/BV1kL4y1P7rY?spm_id_from=333.999.0.0&amp;vd_source=05c3adf2198b00bec5d478e6a244b76b" title="本教程配套视频">本教程配套视频</a></span></h1>
<h1 id="1.%20%E9%A1%B9%E7%9B%AE%E7%9B%AE%E6%A0%87">1. 项目目标</h1>
<ul><li>掌握C++的核心技术</li><li>掌握C++开发项目的方法和流程</li><li>掌握AI算法的基础应用</li></ul>
<h1 id="2.%20%E6%95%88%E6%9E%9C%E6%BC%94%E7%A4%BA">2. 效果演示</h1>
<p style="text-align:center;"><img alt="" src="https://img-blog.csdnimg.cn/ecc66a2dd42b4cd0aea6c149b6203fec.gif"/></p>
<p>开局头像，没有看错，就是我哈，棋魂附体 :-)</p>
<p><img alt="" height="291" src="image\381438f72d54461b81174ae44e0c75be.png" width="701"/></p>
<p>准备好 了吗？直接上代码！</p>
<h1 id="3.%20%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE">3. 创建项目</h1>
<p>使用VS2019+easyx图形库开发，也可以使用VS的其他版本。</p>
<p>参考：<a class="link-info" href="https://www.bilibili.com/video/BV1244y1J7cV?spm_id_from=333.999.0.0" title="VS2019安装教程">VS2019安装教程</a>    <a class="link-info" href="https://www.bilibili.com/video/BV1M44y1p7Te?spm_id_from=333.999.0.0" title="easyx图形库入门教程">easyx图形库入门教程</a></p>
<p> 使用VS2019（或VS2022）创建一个新项目，选择空项目模板。</p>
<p><img alt="" height="680" src="image\66e20515547b4f01b78f48ed3fab8a7f.png" width="1024"/></p>
<p>然后再导入图片素材res目录。因网盘链接不稳定，在评论中回复邮件地址，即发送完整素材。也可以使用自己的素材。</p>
<p><img alt="" height="157" src="image\a6103f1a2f2c49d292ed04a0473862a6.png" width="650"/></p>
<h1 id="%C2%A04.%20%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1"> 4. 项目框架设计</h1>
<h2 id="4.1%20%E8%AE%BE%E8%AE%A1%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6">4.1 设计项目框架</h2>
<p>使用C语言开发的初学者，往往直接就在main函数中写详细的过程。使用C++面向对象，就需要“脱胎换骨”，改变开发思路了！不写过程，直接写需要几个类！</p>
<p><img alt="" height="627" src="image\c800f28170b547a39808c0514b4477bc.png" width="961"/></p>
<p>这里，设计了4个类，分别表示棋手，AI, 棋盘，游戏控制。这应该是最符合现实情况的简单设计了，如果是做网络对战版，就还需要添加其它模块。</p>
<h2 id="4.2%20%E6%A0%B9%E6%8D%AE%E8%AE%BE%E8%AE%A1%E6%A1%86%E6%9E%B6%E5%88%9B%E5%BB%BA%E7%B1%BB">4.2 根据设计框架创建类</h2>
<p>创建项目框架中描述的4个类。可以使用如下方式创建类：</p>
<p><img alt="" height="834" src="image\808cb67ab3f54eb8963f8a368b2346fd.png" width="902"/></p>
<p> 填写类名，再单击确定即可。</p>
<p><img alt="" height="450" src="image\62726c3664cd4526acdab468d656e106.png" width="600"/></p>
<p>按照这个方式，一共创建4个类：Man, AI, Chess, ChessGame. 创建完后，项目的目录结构如：</p>
<p><img alt="" height="352" src="image\06a89b62c13c46ddbdcd7b92219bc134.png" width="316"/></p>
<h1 id="%C2%A05.%20%E7%BB%99%E7%B1%BB%E6%B7%BB%E5%8A%A0%E4%B8%BB%E8%A6%81%E6%8E%A5%E5%8F%A3"> 5. 给类添加主要接口</h1>
<h2 id="5.1%20%E8%AE%BE%E8%AE%A1%E6%A3%8B%E7%9B%98%E7%B1%BBChess%E7%9A%84%E4%B8%BB%E8%A6%81%E6%8E%A5%E5%8F%A3">5.1 设计棋盘类Chess的主要接口</h2>
<p>注意：在给类设计接口时，建议先只考虑对外暴露的“接口”，可以先不用考虑数据成员，对外（public）提供的接口（函数）才是最重要的。</p>
<p>Chess.h</p>
<pre><code class="language-cpp">typedef enum {
	CHESS_WHITE = -1,  // 白方
	CHESS_BLACK = 1    // 黑方
} chess_kind_t;

struct ChessPos {
	int row;
	int col;
};

class Chess
{
public:
	// 棋盘的初始化：加载棋盘的图片资源，初始化棋盘的相关数据
	void init();

	// 判断在指定坐标(x,y)位置，是否是有效点击
	// 如果是有效点击，把有效点击的位置(行，列）保存在参数pos中
	bool clickBoard(int x, int y, ChessPos* pos);

	// 在棋盘的指定位置（pos）, 落子（kind）
	void chessDown(ChessPos* pos, chess_kind_t kind);

	// 获取棋盘的大小（13线、15线、19线）
	int getGradeSize();

	// 获取指定位置是黑棋，还是白棋，还是空白
	int getChessData(ChessPos* pos);
	int getChessData(int row, int col);

	// 判断棋局是否结束
	bool checkOver();
};</code></pre>
<h2 id="%C2%A05.2%20%E8%AE%BE%E8%AE%A1AI%E7%B1%BB%E7%9A%84%E4%B8%BB%E8%A6%81%E6%8E%A5%E5%8F%A3"> 5.2 设计AI类的主要接口</h2>
<p>AI.h</p>
<pre><code class="language-cpp">#include "Chess.h"
class AI
{
public:
	void init(Chess* chess);
	void go();
};</code></pre>
<h2 id="%C2%A05.3%20%E8%AE%BE%E8%AE%A1Man%E7%B1%BB%E7%9A%84%E4%B8%BB%E8%A6%81%E6%8E%A5%E5%8F%A3"> 5.3 设计Man类的主要接口</h2>
<p>Man.h </p>
<pre><code class="language-cpp">#include "Chess.h"

class Man
{
public:
	void init(Chess* chess);
	void go();
};</code></pre>
<h2 id="%C2%A05.4%20%E8%AE%BE%E8%AE%A1ChessGame%E7%9A%84%E4%B8%BB%E8%A6%81%E6%8E%A5%E5%8F%A3"> 5.4 设计ChessGame的主要接口</h2>
<p>ChessGame.h</p>
<pre><code class="language-cpp">class ChessGame
{
public:
	void play();
};</code></pre>
<h2 id="5.5%20%E6%B7%BB%E5%8A%A0%E5%90%84%E4%B8%AA%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0">5.5 添加各个接口的具体实现</h2>
<p style="margin-left:.0001pt;text-align:justify;">可以使用如下方式自动生成各接口的具体实现。先不用考虑各个接口的真正实现，直接使用空函数体代替。 </p>
<p id="%E2%80%8B%E7%BC%96%E8%BE%91" style="margin-left:.0001pt;text-align:justify;"><img alt="" height="319" src="image\4f6db9d47cfa42c185a68e641ad58e8d.png" width="778"/></p>
<h1 id="6.%20%E5%AE%9E%E7%8E%B0%E6%B8%B8%E6%88%8F%E6%8E%A7%E5%88%B6" style="margin-left:.0001pt;text-align:justify;">6. 实现游戏控制</h1>
<p>直接调用各个类定义的接口，实现游戏的主体控制。</p>
<h2 id="6.1%20%E6%B7%BB%E5%8A%A0%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98">6.1 添加数据成员</h2>
<p>为了便于调用各个类的功能，在ChessGame中，添加3各数据成员，并再构造函数中初始化这三个数据成员。</p>
<pre><code class="language-cpp">#include "Man.h"
#include "AI.h"
#include "Chess.h"

class ChessGame
{
public:
	ChessGame(Man*, AI*, Chess*);
	void play();

private:
	Man* man;
	AI* ai;
	Chess* chess;
};

ChessGame::ChessGame(Man* man, AI* ai, Chess* chess)
{
	this-&gt;man = man;
	this-&gt;ai = ai;
	this-&gt;chess = chess;

	ai-&gt;init(chess);
	man-&gt;init(chess);
}</code></pre>
<h2 id="6.2%20%E5%AE%9E%E7%8E%B0%E6%B8%B8%E6%88%8F%E6%8E%A7%E5%88%B6%E5%95%8A">6.2 实现游戏控制啊</h2>
<pre><code class="language-cpp">void ChessGame::play()
{
	chess-&gt;init();
	while (1) {
		man-&gt;go();
		if (chess-&gt;checkOver()) {
			chess-&gt;init();;
			continue;
		}

		ai-&gt;go();
		if (chess-&gt;checkOver()) {
			chess-&gt;init();
			continue;
		}
	}
}</code></pre>
<h1 id="7.%20%E5%88%9B%E5%BB%BA%E6%B8%B8%E6%88%8F%C2%A0">7. 创建游戏 </h1>
<p>在main函数中，创建游戏。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include "ChessGame.h"

int main(void) {
	Chess chess;
	Man man;
	AI ai;
	ChessGame game(&amp;man, &amp;ai, &amp;chess);

	game.play();

	return 0;
}</code></pre>
<h1 id="8.%20%E6%A3%8B%E7%9B%98%E7%9A%84%E2%80%9C%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E2%80%9D%E8%AE%BE%E8%AE%A1">8. 棋盘的“数据成员”设计</h1>
<p>为棋盘类，添加private权限的“数据成员”。</p>
<pre><code class="language-cpp">private:
	// 棋盘尺寸
	int gradeSize;
	float margin_x;//49;
	int margin_y;// 49;
	float chessSize; //棋子大小（棋盘方格大小）

	IMAGE chessBlackImg;
	IMAGE chessWhiteImg;

	// 存储当前游戏棋盘和棋子的情况,空白为0，黑子1，白子-1
	vector&lt;vector&lt;int&gt;&gt; chessMap;

	// 标示下棋方, true:黑棋方  false: AI 白棋方（AI方）
	bool playerFlag;</code></pre>
<p>再补充一下头文件。</p>
<pre><code class="language-cpp">#include &lt;graphics.h&gt;
#include &lt;vector&gt;
using namespace std;</code></pre>
<h1 id="9.%20%E4%BD%BF%E7%94%A8%E6%A3%8B%E7%9B%98%E7%B1%BB%E7%9A%84%E2%80%9C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E2%80%9D%20%E5%AF%B9%E6%A3%8B%E7%9B%98%E8%BF%9B%E8%A1%8C%E6%9E%84%E9%80%A0">9. 使用棋盘类的“构造函数” 对棋盘进行构造</h1>
<p>添加棋盘类的构造函数的定义以及实现。</p>
<p>Chess.h</p>
<pre><code class="language-cpp">Chess(int gradeSize, int marginX, int marginY, float chessSize);</code></pre>
<p>Chess.cpp</p>
<pre><code class="language-cpp">Chess::Chess(int gradeSize, int marginX, int marginY, float chessSize)
{
	this-&gt;gradeSize = gradeSize;
	this-&gt;margin_x = marginX;
	this-&gt;margin_y = marginY;
	this-&gt;chessSize = chessSize;
	playerFlag = CHESS_BLACK;

	for (int i = 0; i &lt; gradeSize; i++) {
		vector&lt;int&gt;row;
		for (int j = 0; j &lt; gradeSize; j++) {
			row.push_back(0);
		}
		chessMap.push_back(row);
	}
}</code></pre>
<p style="margin-left:.0001pt;text-align:justify;">同时修改main函数的Chess对象的创建。、</p>
<pre><code class="language-cpp">	//Chess chess;
	Chess chess(13, 44, 43, 67.4);</code></pre>
<h1 id="10.%20%E6%A3%8B%E7%9B%98%E7%9A%84%E2%80%9C%E5%88%9D%E5%A7%8B%E5%8C%96%E2%80%9D%20-%20%E6%AD%A3%E5%9C%A8%E6%9B%B4%E6%96%B0">10. 棋盘的“初始化” </h1>
<p>对棋盘进行数据初始化，使得能够看到实际的棋盘。</p>
<pre><code class="language-cpp">void Chess::init()
{
	initgraph(897, 895);
	loadimage(0, "res/棋盘2.jpg");

	mciSendString("play res/start.wav", 0, 0, 0); //需要修改字符集为多字节字符集

	loadimage(&amp;chessBlackImg, "res/black.png", chessSize, chessSize, true);
	loadimage(&amp;chessWhiteImg, "res/white.png", chessSize, chessSize, true);

	for (int i = 0; i &lt; chessMap.size(); i++) {
		for (int j = 0; j &lt; chessMap[i].size(); j++) {
			chessMap[i][j] = 0;
		}
	}

	playerFlag = true;
}</code></pre>
<p>添加头文件和相关库，使得能够播放落子音效。<br/> Chess.cpp</p>
<pre><code class="language-cpp">#include &lt;mmsystem.h&gt;
#pragma comment(lib, "winmm.lib")
</code></pre>
<p> 修改项目的字符集为“多字节字符集”。</p>
<p><img alt="" height="555" src="image\946113392c6244d3b2525170064de36f.png" width="800"/></p>
<p> 测试效果：</p>
<p><img alt="" height="934" src="image\37e51e38f0504f0091e6520f3133553d.png" width="913"/></p>
<h1 id="11.%20%E5%AE%9E%E7%8E%B0%E6%A3%8B%E6%89%8B%E8%B5%B0%E6%A3%8B">11. 实现棋手走棋</h1>
<p>现在执行程序，除了弹出的棋盘，什么都不能干。因为，棋手的走棋函数，还没有实现哦！现在来实现棋手走棋功能。</p>
<h2 id="11.1%20%E6%A3%8B%E6%89%8B%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96">11.1 棋手的初始化</h2>
<p>为棋手类，添加数据成员，表示棋盘</p>
<p>Man.h</p>
<pre><code>private:
	Chess* chess;</code></pre>
<p>实现棋手对象的初始化。</p>
<p>Man.cpp</p>
<pre><code class="language-cpp">void Man::init(Chess* chess)
{
	this-&gt;chess = chess;
}</code></pre>
<p>在ChessGame的构造函数中，实现棋手的初始化。</p>
<p>ChessGame.cpp</p>
<pre><code class="language-cpp">ChessGame::ChessGame(Man* man, AI* ai, Chess* chess)
{
	this-&gt;man = man;
	this-&gt;ai = ai;
	this-&gt;chess = chess;

	man-&gt;init(chess);  //初始化棋手
}</code></pre>
<h2 id="11.2%20%E6%A3%8B%E6%89%8B%E8%B5%B0%E6%A3%8B">11.2 棋手走棋</h2>
<p>Man.cpp</p>
<pre><code class="language-cpp">void Man::go(){
	// 等待棋士有效落子
	MOUSEMSG msg;
	ChessPos pos;
	while (1) {
		msg = GetMouseMsg();
		if (msg.uMsg == WM_LBUTTONDOWN &amp;&amp; chess-&gt;clickBoard(msg.x, msg.y, &amp;pos)) {
			break;
		}
	}

	// 落子
	chess-&gt;chessDown(&amp;pos, CHESS_BLACK);
}</code></pre>
<h2 id="11.3%20%E5%88%A4%E6%96%AD%E8%90%BD%E5%AD%90%E7%82%B9%E5%87%BB%E4%BD%8D%E7%BD%AE%E6%98%AF%E5%90%A6%E6%9C%89%E6%95%88">11.3 判断落子点击位置是否有效</h2>
<p>执行程序后，还是没有任何效果，因为落子的有效性还没有判断。</p>
<h3 id="%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90">原理分析</h3>
<p><img alt="" height="182" src="image\4758d29b64de4a04a6567a46af2f3bf9.png" width="235"/></p>
<p>先计算点击位置附近的4个点的位置，然后再计算点击位置到这四个点之间的距离，如果离某个点的距离小于“阈值”，就认为这个点是落子位置。这个“阈值”， 小于棋子大小的一半即可。我们这里取棋子大小的0.4倍。</p>
<h3 id="%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">代码实现</h3>
<p>Chess.cpp</p>
<pre><code class="language-cpp">bool Chess::clickBoard(int x, int y, ChessPos* pos)
{
	int col = (x - margin_x) / chessSize;
	int row = (y - margin_y) / chessSize;

	int leftTopPosX = margin_x + chessSize * col;
	int leftTopPosY = margin_y + chessSize * row;
	int offset = chessSize * 0.4; // 20 鼠标点击的模糊距离上限

	int len;
	int selectPos = false;

	do {
		len = sqrt((x - leftTopPosX) * (x - leftTopPosX) + (y - leftTopPosY) * (y - leftTopPosY));
		if (len &lt; offset) {
			pos-&gt;row = row;
			pos-&gt;col = col;
			if (chessMap[pos-&gt;row][pos-&gt;col] == 0) {
				selectPos = true;
			}
			break;
		}

		// 距离右上角的距离
		len = sqrt((x - leftTopPosX - chessSize) * (x - leftTopPosX - chessSize) + (y - leftTopPosY) * (y - leftTopPosY));
		if (len &lt; offset) {
			pos-&gt;row = row;
			pos-&gt;col = col + 1;
			if (chessMap[pos-&gt;row][pos-&gt;col] == 0) {
				selectPos = true;
			}
			break;
		}

		// 距离左下角的距离
		len = sqrt((x - leftTopPosX) * (x - leftTopPosX) + (y - leftTopPosY - chessSize) * (y - leftTopPosY - chessSize));
		if (len &lt; offset) {
			pos-&gt;row = row + 1;
			pos-&gt;col = col;
			if (chessMap[pos-&gt;row][pos-&gt;col] == 0) {
				selectPos = true;
			}
			break;
		}

		// 距离右下角的距离
		len = sqrt((x - leftTopPosX - chessSize) * (x - leftTopPosX - chessSize) + (y - leftTopPosY - chessSize) * (y - leftTopPosY - chessSize));
		if (len &lt; offset) {
			pos-&gt;row = row + 1;
			pos-&gt;col = col + 1;

			if (chessMap[pos-&gt;row][pos-&gt;col] == 0) {
				selectPos = true;
			}
			break;
		}
	} while (0);

	return selectPos;
}</code></pre>
<p>可以通过打印语句，测试判断是否准确。</p>
<h1 id="12.%20%E5%AE%9E%E7%8E%B0%E6%A3%8B%E7%9B%98%E8%90%BD%E5%AD%90">12. 实现棋盘落子</h1>
<h2 id="12.1%20%E5%AE%9E%E7%8E%B0Chess%E7%B1%BB%E7%9A%84chessDown%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0">12.1 实现Chess类的chessDown成员函数</h2>
<pre><code class="language-cpp">void Chess::chessDown(ChessPos *pos, chess_kind_t kind)
{
	mciSendString("play res/down7.WAV", 0, 0, 0);

	int x = margin_x + pos-&gt;col * chessSize - 0.5 * chessSize;
	int y = margin_y + pos-&gt;row * chessSize - 0.5 * chessSize;

	if (kind == CHESS_WHITE) {
		putimagePNG(x, y, &amp;chessWhiteImg);
	}
	else {
		putimagePNG(x, y, &amp;chessBlackImg);
	}

}</code></pre>
<p>检查落子效果： <img alt="" height="924" src="image\4954adfe755f44cfafb881bd0ee8fd99.png" width="913"/></p>
<p></p>
<p>棋子背后有黑色背景。这是因为easyx图形库默认不支持背景透明的png格式图片，把透明部分直接渲染为黑色了。解决方案，使用自定义的图形渲染接口，如下：</p>
<pre><code class="language-cpp">void putimagePNG(int x, int y, IMAGE* picture) //x为载入图片的X坐标，y为Y坐标
{
	// 变量初始化
	DWORD* dst = GetImageBuffer();    // GetImageBuffer()函数，用于获取绘图设备的显存指针，EASYX自带
	DWORD* draw = GetImageBuffer();
	DWORD* src = GetImageBuffer(picture); //获取picture的显存指针
	int picture_width = picture-&gt;getwidth(); //获取picture的宽度，EASYX自带
	int picture_height = picture-&gt;getheight(); //获取picture的高度，EASYX自带
	int graphWidth = getwidth();       //获取绘图区的宽度，EASYX自带
	int graphHeight = getheight();     //获取绘图区的高度，EASYX自带
	int dstX = 0;    //在显存里像素的角标

	// 实现透明贴图 公式： Cp=αp*FP+(1-αp)*BP ， 贝叶斯定理来进行点颜色的概率计算
	for (int iy = 0; iy &lt; picture_height; iy++)
	{
		for (int ix = 0; ix &lt; picture_width; ix++)
		{
			int srcX = ix + iy * picture_width; //在显存里像素的角标
			int sa = ((src[srcX] &amp; 0xff000000) &gt;&gt; 24); //0xAArrggbb;AA是透明度
			int sr = ((src[srcX] &amp; 0xff0000) &gt;&gt; 16); //获取RGB里的R
			int sg = ((src[srcX] &amp; 0xff00) &gt;&gt; 8);   //G
			int sb = src[srcX] &amp; 0xff;              //B
			if (ix &gt;= 0 &amp;&amp; ix &lt;= graphWidth &amp;&amp; iy &gt;= 0 &amp;&amp; iy &lt;= graphHeight &amp;&amp; dstX &lt;= graphWidth * graphHeight)
			{
				dstX = (ix + x) + (iy + y) * graphWidth; //在显存里像素的角标
				int dr = ((dst[dstX] &amp; 0xff0000) &gt;&gt; 16);
				int dg = ((dst[dstX] &amp; 0xff00) &gt;&gt; 8);
				int db = dst[dstX] &amp; 0xff;
				draw[dstX] = ((sr * sa / 255 + dr * (255 - sa) / 255) &lt;&lt; 16)  //公式： Cp=αp*FP+(1-αp)*BP  ； αp=sa/255 , FP=sr , BP=dr
					| ((sg * sa / 255 + dg * (255 - sa) / 255) &lt;&lt; 8)         //αp=sa/255 , FP=sg , BP=dg
					| (sb * sa / 255 + db * (255 - sa) / 255);              //αp=sa/255 , FP=sb , BP=db
			}
		}
	}
}
</code></pre>
<p> 再把chessDown中的putimage更换为putimagePNG, 测试效果如下：</p>
<p><img alt="" height="934" src="image\dbf69e1051a14b6aab831616463bfd40.png" width="913"/></p>
<p>如上，黑色背景已经被去除。</p>
<h2 id="12.2%20%E4%BF%AE%E6%94%B9%E6%A3%8B%E7%9B%98%E7%9A%84%E6%A3%8B%E5%AD%90%E6%95%B0%E6%8D%AE">12.2 修改棋盘的棋子数据</h2>
<p>在界面上落子之后，还需要修改棋盘的棋子数据。为Chess类添加updateGameMap函数来修改棋子数据。这个方法，是给棋盘对象内部使用的，不需要开放给他人使用，所有把权限设置为private，设置为public也可以，但是从技术角度就不安全了。如果他人直接调用这个函数，就会导致棋盘的数据和界面上看到的数据不一样。</p>
<p>Chess.h</p>
<pre><code class="language-cpp">private:
	void updateGameMap(ChessPos *pos);</code></pre>
<p>Chess.cpp</p>
<pre><code class="language-cpp">void Chess::updateGameMap(ChessPos* pos)
{
    lastPos = *pos;
	chessMap[pos-&gt;row][pos-&gt;col] = playerFlag ? 1 : -1;
	playerFlag = !playerFlag; // 换手
}</code></pre>
<p>在落子后，调用updateGameMap更新棋子数据。</p>
<pre><code class="language-cpp">void Chess::chessDown(ChessPos *pos, chess_kind_t kind)
{
	// ......

	updateGameMap(pos);
}</code></pre>
<h1 id="13.%20%E5%AE%9E%E7%8E%B0AI%E8%B5%B0%E6%A3%8B">13. 实现AI走棋</h1>
<p>终于可以设计我们的AI模块了！</p>
<h2 id="13.1%20%E8%AE%BE%E8%AE%A1AI%E7%9A%84%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98">13.1 设计AI的数据成员</h2>
<blockquote>
<ul><li>添加棋盘数据成员，以表示对哪个棋盘下棋。</li><li>添加评分数组, 用来存储AI对棋盘所有落点的价值评估。这也是人机对战最重要的部分。</li></ul>
</blockquote>
<p>AI.h </p>
<pre><code class="language-cpp">private:
	Chess* chess;
	// 存储各个点位的评分情况，作为AI下棋依据
	vector&lt;vector&lt;int&gt;&gt; scoreMap;</code></pre>
<h2 id="13.2%20%E5%AF%B9AI%E8%BF%9B%E8%A1%8C%E5%88%9D%E5%A7%8B%E5%8C%96">13.2 对AI进行初始化</h2>
<p>AI.cpp</p>
<pre><code class="language-cpp">void AI::init(Chess* chess)
{
    this-&gt;chess = chess;

    int size = chess-&gt;getGradeSize();
    for (int i = 0; i &lt; size; i++) {
        vector&lt;int&gt; row;
        for (int j = 0; j &lt; size; j++) {
            row.push_back(0);
        }
        scoreMap.push_back(row);
    }
}</code></pre>
<h2 id="13.3%20AI%E2%80%9C%E6%80%9D%E8%80%83%E2%80%9D%E6%80%8E%E6%A0%B7%E8%B5%B0%E6%A3%8B">13.3 AI“思考”怎样走棋</h2>
<p>AI的思考方法，就是对棋盘的所有可能落子点，做评分计算，然后选择一个评分最高的点落子。</p>
<h3 id="13.3.1%20AI%E5%AF%B9%E8%90%BD%E5%AD%90%E7%82%B9%E8%BF%9B%E8%A1%8C%E8%AF%84%E5%88%86">13.3.1 AI对落子点进行评分</h3>
<p>对每一个可能的落子点，从该点周围的八个方向，分别计算，确定出每个方向已经有几颗连续的棋子。</p>
<blockquote>
<p><strong>棋理格言：敌之好点，即我之好点。</strong><br/> 就是说，每个点，都要考虑，如果敌方占领了这个点，会产生多大的价值，如果我方占领了这个点，又会产生多大的价值。如果我方占领这个点，价值只有1000，但是敌方要是占领了这个点，价值有2000，而在自己在其它位置没有价值更高的点，那么建议直接抢占这个敌方的好点。</p>
</blockquote>
<p>兵家必争之地：荆州（隆中对的第一步，就是取荆州）<br/><img alt="" height="603" src="image\e9a974094e334b96accf9bcc61cc1371.png" width="660"/></p>
<p></p>
<p>AI先计算棋手如果在这个位置落子，会有多大的价值。然后再计算自己如果在这个位置落子，有大大价值。具体计算方法，就是计算如果黑棋或者白棋在这个位置落子，那么在这个位置的某个方向上， 一共有连续几个黑子或者连续几个白子。连续的数量越多，价值越大。</p>
<p><img alt="" height="409" src="image\4544c632392a493e9272b243ac683730.png" width="470"/></p>
<p><strong> 常见棋形</strong></p>
<p>连2：<br/><img alt="" height="127" src="image\593c0d4700954e76a780897becf2c1ad.png" width="344"/></p>
<p>活3<br/><img alt="" height="143" src="image\963e7d70a40345aaa008bac5afed75ff.png" width="398"/></p>
<p>死3<br/><img alt="" height="222" src="image\e42c6f58ad8f44dd97cc416d7c09c7b3.png" width="487"/></p>
<p>活4<br/><img alt="" height="247" src="image\2fa9cab098bb49efa04663d0de908224.png" width="509"/></p>
<p>死4<br/><img alt="" height="245" src="image\45c1e38d466749a491cbd9772772d7b8.png" width="584"/></p>
<p>连5（赢棋）<br/><img alt="" height="250" src="image\f2a6a76cebc847bd8b4269aa066cacd0.png" width="589"/></p>
<p>如果走这个点，产生的棋形以及对应评分：<br/><img alt="" height="309" src="image\f442bc0d65ab4cfca9adb1978df7f8b8.png" width="404"/></p>
<p> 用代码实现评分计算<br/> AI.h</p>
<pre><code>private:
	void calculateScore();</code></pre>
<p>AI.cpp</p>
<pre><code class="language-cpp">void AI::calculateScore()
{
    // 统计玩家或者电脑连成的子
    int personNum = 0;  // 玩家连成子的个数
    int botNum = 0;     // AI连成子的个数
    int emptyNum = 0;   // 各方向空白位的个数

    // 清空评分数组
    for (int i = 0; i &lt; scoreMap.size(); i++) {
        for (int j = 0; j &lt; scoreMap[i].size(); j++) {
            scoreMap[i][j] = 0;
        }
    }

    int size = chess-&gt;getGradeSize();
    for (int row = 0; row &lt; size; row++)
        for (int col = 0; col &lt; size; col++)
        {
            // 空白点就算
            if (chess-&gt;getChessData(row, col) == 0) {
                // 遍历周围八个方向
                for (int y = -1; y &lt;= 1; y++) {
                    for (int x = -1; x &lt;= 1; x++)
                    {
                        // 重置
                        personNum = 0;
                        botNum = 0;
                        emptyNum = 0;

                        // 原坐标不算
                        if (!(y == 0 &amp;&amp; x == 0))
                        {
                            // 每个方向延伸4个子
                            // 对黑棋评分（正反两个方向）
                            for (int i = 1; i &lt;= 4; i++)
                            {
                                int curRow = row + i * y;
                                int curCol = col + i * x;
                                if (curRow &gt;= 0 &amp;&amp; curRow &lt; size &amp;&amp;
                                    curCol &gt;= 0 &amp;&amp; curCol &lt; size &amp;&amp;
                                    chess-&gt;getChessData(curRow, curCol) == 1) // 真人玩家的子
                                {
                                    personNum++;
                                }
                                else if (curRow &gt;= 0 &amp;&amp; curRow &lt; size &amp;&amp;
                                    curCol &gt;= 0 &amp;&amp; curCol &lt; size &amp;&amp;
                                    chess-&gt;getChessData(curRow, curCol) == 0) // 空白位
                                {
                                    emptyNum++;
                                    break;
                                }
                                else            // 出边界
                                    break;
                            }

                            for (int i = 1; i &lt;= 4; i++)
                            {
                                int curRow = row - i * y;
                                int curCol = col - i * x;
                                if (curRow &gt;= 0 &amp;&amp; curRow &lt; size &amp;&amp;
                                    curCol &gt;= 0 &amp;&amp; curCol &lt; size &amp;&amp;
                                    chess-&gt;getChessData(curRow, curCol) == 1) // 真人玩家的子
                                {
                                    personNum++;
                                }
                                else if (curRow &gt;= 0 &amp;&amp; curRow &lt; size &amp;&amp;
                                    curCol &gt;= 0 &amp;&amp; curCol &lt; size &amp;&amp;
                                    chess-&gt;getChessData(curRow, curCol) == 0) // 空白位
                                {
                                    emptyNum++;
                                    break;
                                }
                                else            // 出边界
                                    break;
                            }

                            if (personNum == 1)                      // 杀二
                                scoreMap[row][col] += 10;
                            else if (personNum == 2)                 // 杀三
                            {
                                if (emptyNum == 1)
                                    scoreMap[row][col] += 30;
                                else if (emptyNum == 2)
                                    scoreMap[row][col] += 40;
                            }
                            else if (personNum == 3)                 // 杀四
                            {
                                // 量变空位不一样，优先级不一样
                                if (emptyNum == 1)
                                    scoreMap[row][col] += 60;
                                else if (emptyNum == 2)
                                    scoreMap[row][col] += 200;
                            }
                            else if (personNum == 4)                 // 杀五
                                scoreMap[row][col] += 20000;

                            // 进行一次清空
                            emptyNum = 0;

                            // 对白棋评分
                            for (int i = 1; i &lt;= 4; i++)
                            {
                                int curRow = row + i * y;
                                int curCol = col + i * x;
                                if (curRow &gt; 0 &amp;&amp; curRow &lt; size &amp;&amp;
                                    curCol &gt; 0 &amp;&amp; curCol &lt; size &amp;&amp;
                                    chess-&gt;getChessData(curRow, curCol) == -1) // 玩家的子
                                {
                                    botNum++;
                                }
                                else if (curRow &gt; 0 &amp;&amp; curRow &lt; size &amp;&amp;
                                    curCol &gt; 0 &amp;&amp; curCol &lt; size &amp;&amp;
                                    chess-&gt;getChessData(curRow, curCol) == 0) // 空白位
                                {
                                    emptyNum++;
                                    break;
                                }
                                else            // 出边界
                                    break;
                            }

                            for (int i = 1; i &lt;= 4; i++)
                            {
                                int curRow = row - i * y;
                                int curCol = col - i * x;
                                if (curRow &gt; 0 &amp;&amp; curRow &lt; size &amp;&amp;
                                    curCol &gt; 0 &amp;&amp; curCol &lt; size &amp;&amp;
                                    chess-&gt;getChessData(curRow, curCol) == -1) // 玩家的子
                                {
                                    botNum++;
                                }
                                else if (curRow &gt; 0 &amp;&amp; curRow &lt; size &amp;&amp;
                                    curCol &gt; 0 &amp;&amp; curCol &lt; size &amp;&amp;
                                    chess-&gt;getChessData(curRow, curCol) == 0) // 空白位
                                {
                                    emptyNum++;
                                    break;
                                }
                                else            // 出边界
                                    break;
                            }

                            if (botNum == 0)                      // 普通下子
                                scoreMap[row][col] += 5;
                            else if (botNum == 1)                 // 活二
                                scoreMap[row][col] += 10;
                            else if (botNum == 2)
                            {
                                if (emptyNum == 1)                // 死三
                                    scoreMap[row][col] += 25;
                                else if (emptyNum == 2)
                                    scoreMap[row][col] += 50;  // 活三
                            }
                            else if (botNum == 3)
                            {
                                if (emptyNum == 1)                // 死四
                                    scoreMap[row][col] += 55;
                                else if (emptyNum == 2)
                                    scoreMap[row][col] += 10000; // 活四
                            }
                            else if (botNum &gt;= 4)
                                scoreMap[row][col] += 30000;   // 活五，应该具有最高优先级
                        }
                    }
                }
            }
        }
}</code></pre>
<h3 id="13.3.2%C2%A0%C2%A0AI%E6%A0%B9%E6%8D%AE%E8%AF%84%E5%88%86%E8%BF%9B%E8%A1%8C%E2%80%9C%E6%80%9D%E8%80%83%E2%80%9D">13.3.2  AI根据评分进行“思考”</h3>
<p>各个落子点的评分确定后，“思考”就很简单了，直接使用“遍历”，找出评分最高的点即可。</p>
<p>AI.h</p>
<pre><code class="language-cpp">ChessPos think();  //private权限</code></pre>
<p></p>
<p>AI.cpp </p>
<pre><code class="language-cpp">ChessPos AI::think()
{
    // 计算评分
    calculateScore();

    // 从评分中找出最大分数的位置
    int maxScore = 0;
    //std::vector&lt;std::pair&lt;int, int&gt;&gt; maxPoints;
    vector&lt;ChessPos&gt; maxPoints;
    int k = 0;

    int size = chess-&gt;getGradeSize();
    for (int row = 0; row &lt; size; row++) {
        for (int col = 0; col &lt; size; col++)
        {
            // 前提是这个坐标是空的
            if (chess-&gt;getChessData(row, col) == 0) {
                if (scoreMap[row][col] &gt; maxScore)          // 找最大的数和坐标
                {
                    maxScore = scoreMap[row][col];
                    maxPoints.clear();
                    maxPoints.push_back(ChessPos(row, col));
                }
                else if (scoreMap[row][col] == maxScore) {   // 如果有多个最大的数，都存起来
                    maxPoints.push_back(ChessPos(row, col));
                }
            }
        }
    }

    // 随机落子，如果有多个点的话
    int index = rand() % maxPoints.size();
    return maxPoints[index];
}</code></pre>
<p>对ChesPos类补充构造函数<br/> Chess.h</p>
<pre><code class="language-cpp">ChessPos(int r=0, int c=0) :row(r), col(c){}</code></pre>
<p></p>
<h3 id="%C2%A012.3.3%20AI%E8%B5%B0%E6%A3%8B"> 12.3.3 AI走棋</h3>
<p>AI.cpp</p>
<pre><code class="language-cpp">void AI::go()
{
	ChessPos pos = think();
	Sleep(1000); //假装思考
    chess-&gt;chessDown(&amp;pos, CHESS_WHITE);
}</code></pre>
<p>因为思考速度太快，使用Sleep休眠作为停顿，以提高棋手的“对局体验” :-)</p>
<h3 id="%C2%A012.3.4%20%E6%B5%8B%E8%AF%95"> 12.3.4 测试</h3>
<p>检查执行效果：<br/><img alt="" height="603" src="image\685dd6cd19b344638ce04e6bad19a07c.png" width="1168"/></p>
<p>当AI在“思考”时，程序崩溃！设置断点后检查，发现ai对象的chess成员指向一个无效内存。因为可以判定，还没有对AI对象进行初始化。检查后发现，之前为AI对象定义了初始化init函数，但是没有调用这个函数。补充如下：</p>
<p>ChessGame.cpp</p>
<pre><code class="language-cpp">ChessGame::ChessGame(Man* man, AI* ai, Chess* chess)
{
	//...
	ai-&gt;init(chess);
}</code></pre>
<p>调试后还是发现，程序崩溃：<br/><img alt="" height="665" src="image\057a15fae5b445f08371d4b5e706337d.png" width="1164"/></p>
<p>加断点检查发现Chess类的getGradeSize函数返回0. 修改如下：<br/>  </p>
<pre><code class="language-cpp">int Chess::getGradeSize()
{
	return gradeSize;
}</code></pre>
<p> 测试运行后，发现AI很傻，落子很“臭”：</p>
<p><img alt="" height="934" src="image\c1be697310674222b23d84774ed83ec8.png" width="913"/></p>
<p>加断点调试，发现getChessData函数的返回值始终为0，原来是之前设计这个接口时，使用自动生产的，没有做真正的实现，需改如下：</p>
<pre><code class="language-cpp">int Chess::getChessData(ChessPos* pos)
{
	return chessMap[pos-&gt;row][pos-&gt;col];
}

int Chess::getChessData(int row, int col)
{
	return chessMap[row][col];
}</code></pre>
<p>测试后发现，AI的棋力，已经正常：</p>
<p><img alt="" height="934" src="image\66d89f2bdc1541c1bdf62f9e55e50b05.png" width="913"/></p>
<h1 id="14.%20AI%E7%9A%84BUG">14. AI的BUG</h1>
<p>现在的AI已经能够走棋了，而且还很不错，但是通过调试，发现AI在某些时候会下“昏招”， 成为“臭棋篓子”， 情况如下：<br/> 当下到这个局面时：<br/><img alt="" height="934" src="image\c77d57fc0952498db3c565179d72ab99.png" width="913"/><br/> 当棋手在第9行第9列落子时，形成冲4形态时，白棋应该进行阻挡防守，但是白棋却判断错误，在其它位置落子了！<br/><img alt="" height="934" src="image\bf5e19de58d14ee980c107a4d7007858.png" width="913"/></p>
<p>通过加断点判断分析，原因是我们对8个方向做了判断，而在每个方向进行判断时，又对反方向进行了判断。最终导致AI在第行第5列的位置进行价值分析时，在正上方和正下方两次判断中，认为改点有“活三”价值，导致这点的价值被重复计算了一次，被累加到 20000，超过了黑棋冲四的价值！解决方法也很简单，就是8个方向，只要判断4次即可（如下图的绿色箭头<br/><img alt="" height="595" src="image\48277a554fba40dc911aefbd60b2c26a.png" width="1130"/></p>
<p> 修改后的AI评分方法。</p>
<pre><code class="language-cpp">void AI::calculateScore()
{
	int personNum = 0; //棋手方（黑棋）多少个连续的棋子
	int aiNum = 0; //AI方（白棋）连续有多少个连续的棋子
	int emptyNum = 0; // 该方向上空白位的个数

	// 评分向量数组清零
	for (int i = 0; i &lt; scoreMap.size(); i++) {
		for (int j = 0; j &lt; scoreMap[i].size(); j++) {
			scoreMap[i][j] = 0;
		}
	}

	int size = chess-&gt;getGradeSize();
	for (int row = 0; row &lt; size; row++) {
		for (int col = 0; col &lt; size; col++) {
			//对每个点进行计算
			if (chess-&gt;getChessData(row, col)) continue;

			for (int y = -1; y &lt;= 0; y++) {        //Y的范围还是-1， 0
				for (int x = -1; x &lt;= 1; x++) {    //X的范围是 -1,0,1
					if (y == 0 &amp;&amp; x == 0) continue; 
					if (y == 0 &amp;&amp; x != 1) continue; //当y=0时，仅允许x=1

					personNum = 0;
					aiNum = 0;
					emptyNum = 0;

					// 假设黑棋在该位置落子，会构成什么棋型
					for (int i = 1; i &lt;= 4; i++) {
						int curRow = row + i * y;
						int curCol = col + i * x;

						if (curRow &gt;= 0 &amp;&amp; curRow &lt; size &amp;&amp;
							curCol &gt;= 0 &amp;&amp; curCol &lt; size &amp;&amp;
							chess-&gt;getChessData(curRow, curCol) == 1) {
							personNum++;
						}
						else if (curRow &gt;= 0 &amp;&amp; curRow &lt; size &amp;&amp;
							curCol &gt;= 0 &amp;&amp; curCol &lt; size &amp;&amp;
							chess-&gt;getChessData(curRow, curCol) == 0) {
							emptyNum++;
							break;
						}
						else {
							break;
						}
					}

					// 反向继续计算
					for (int i = 1; i &lt;= 4; i++) {
						int curRow = row - i * y;
						int curCol = col - i * x;

						if (curRow &gt;= 0 &amp;&amp; curRow &lt; size &amp;&amp;
							curCol &gt;= 0 &amp;&amp; curCol &lt; size &amp;&amp;
							chess-&gt;getChessData(curRow, curCol) == 1) {
							personNum++;
						}
						else if (curRow &gt;= 0 &amp;&amp; curRow &lt; size &amp;&amp;
							curCol &gt;= 0 &amp;&amp; curCol &lt; size &amp;&amp;
							chess-&gt;getChessData(curRow, curCol) == 0) {
							emptyNum++;
							break;
						}
						else {
							break;
						}
					}

					if (personNum == 1) { //连2
						//CSDN  程序员Rock
						scoreMap[row][col] += 10;
					}
					else if (personNum == 2) {
						if (emptyNum == 1) {
							scoreMap[row][col] += 30;
						}
						else if (emptyNum == 2) {
							scoreMap[row][col] += 40;
						}
					}
					else if (personNum == 3) {
						if (emptyNum == 1) {
							scoreMap[row][col] = 60;
						}
						else if (emptyNum == 2) {
							scoreMap[row][col] = 5000; //200
						}
					}
					else if (personNum == 4) {
						scoreMap[row][col] = 20000;
					}

					// 假设白棋在该位置落子，会构成什么棋型
					emptyNum = 0;

					for (int i = 1; i &lt;= 4; i++) {
						int curRow = row + i * y;
						int curCol = col + i * x;

						if (curRow &gt;= 0 &amp;&amp; curRow &lt; size &amp;&amp;
							curCol &gt;= 0 &amp;&amp; curCol &lt; size &amp;&amp;
							chess-&gt;getChessData(curRow, curCol) == -1) {
							aiNum++;
						}
						else if (curRow &gt;= 0 &amp;&amp; curRow &lt; size &amp;&amp;
							curCol &gt;= 0 &amp;&amp; curCol &lt; size &amp;&amp;
							chess-&gt;getChessData(curRow, curCol) == 0) {
							emptyNum++;
							break;
						}
						else {
							break;
						}
					}

					for (int i = 1; i &lt;= 4; i++) {
						int curRow = row - i * y;
						int curCol = col - i * x;

						if (curRow &gt;= 0 &amp;&amp; curRow &lt; size &amp;&amp;
							curCol &gt;= 0 &amp;&amp; curCol &lt; size &amp;&amp;
							chess-&gt;getChessData(curRow, curCol) == -1) {
							aiNum++;
						}
						else if (curRow &gt;= 0 &amp;&amp; curRow &lt; size &amp;&amp;
							curCol &gt;= 0 &amp;&amp; curCol &lt; size &amp;&amp;
							chess-&gt;getChessData(curRow, curCol) == 0) {
							emptyNum++;
							break;
						}
						else {
							break;
						}
					}

					if (aiNum == 0) {
						scoreMap[row][col] += 5;
					}
					else if (aiNum == 1) {
						scoreMap[row][col] += 10;
					}
					else if (aiNum == 2) {
						if (emptyNum == 1) {
							scoreMap[row][col] += 25;
						}
						else if (emptyNum == 2) {
							scoreMap[row][col] += 50;
						}
					}
					else if (aiNum == 3) {
						if (emptyNum == 1) {
							scoreMap[row][col] += 55;
						}
						else if (emptyNum == 2) {
							scoreMap[row][col] += 10000;
						}
					}
					else if (aiNum &gt;= 4) {
						scoreMap[row][col] += 30000;
					}
				}
			}
		}
	}
}</code></pre>
<h1 id="15.%20%E5%88%A4%E6%96%AD%E8%83%9C%E8%B4%9F">15. 判断胜负</h1>
<p>判断五子棋游戏是否结束。</p>
<h2 id="15.1%20%E5%AF%B9%E8%83%9C%E8%B4%9F%E8%BF%9B%E8%A1%8C%E5%A4%84%E7%90%86">15.1 对胜负进行处理</h2>
<p>Chess.cpp</p>
<pre><code class="language-cpp">bool Chess::checkOver()
{
	if (checkWin()) {
		Sleep(1500);
		if (playerFlag == false) {  //黑棋赢（玩家赢）,此时标记已经反转，轮到白棋落子
			mciSendString("play res/不错.mp3", 0, 0, 0);
			loadimage(0, "res/胜利.jpg");
		}
		else {
			mciSendString("play res/失败.mp3", 0, 0, 0);
			loadimage(0, "res/失败.jpg");
		}

		_getch(); // 补充头文件 #include &lt;conio.h&gt;
		return true;
	}

	return false;
}</code></pre>
<p>补充头文件 conio.h, 并添加CheckWin的定义和实现。</p>
<h2 id="15.2%20%E8%83%9C%E8%B4%9F%E5%88%A4%E5%AE%9A%E5%8E%9F%E7%90%86">15.2 胜负判定原理</h2>
<p>具体的判定原理，就是对刚才的落子位置进行判断，判断该位置在4个方向上是否有5颗连续的同类棋子。</p>
<p>对于水平位置的判断：<br/><img alt="" height="319" src="image\2208b9fcec484768aedde388a47c2807.png" width="575"/></p>
<p>其他方向的判断，原理类似。</p>
<h2 id="15.%203%20%E5%AE%9E%E7%8E%B0%E8%83%9C%E8%B4%9F%E5%88%A4%E5%AE%9A">15. 3 实现胜负判定</h2>
<p>添加最近落子位置。</p>
<p>Chess.h</p>
<pre><code class="language-cpp">ChessPos lastPos; //最近落子位置, Chess的private数据成员</code></pre>
<p> 更新最近落子位置。</p>
<p>Chess.cpp</p>
<pre><code class="language-cpp">void Chess::updateGameMap(ChessPos* pos)
{
	lastPos = *pos;
	//...
}
</code></pre>
<p>实现胜负判定。</p>
<p>Chess.cpp</p>
<pre><code class="language-cpp">bool Chess::checkWin()
{
	// 横竖斜四种大情况，每种情况都根据当前落子往后遍历5个棋子，有一种符合就算赢
	// 水平方向
	int row = lastPos.row;
	int col = lastPos.col;

	for (int i = 0; i &lt; 5; i++)
	{
		// 往左5个，往右匹配4个子，20种情况
		if (col - i &gt;= 0 &amp;&amp;
			col - i + 4 &lt; gradeSize &amp;&amp;
			chessMap[row][col - i] == chessMap[row][col - i + 1] &amp;&amp;
			chessMap[row][col - i] == chessMap[row][col - i + 2] &amp;&amp;
			chessMap[row][col - i] == chessMap[row][col - i + 3] &amp;&amp;
			chessMap[row][col - i] == chessMap[row][col - i + 4])
			return true;
	}

	// 竖直方向(上下延伸4个)
	for (int i = 0; i &lt; 5; i++)
	{
		if (row - i &gt;= 0 &amp;&amp;
			row - i + 4 &lt; gradeSize &amp;&amp;
			chessMap[row - i][col] == chessMap[row - i + 1][col] &amp;&amp;
			chessMap[row - i][col] == chessMap[row - i + 2][col] &amp;&amp;
			chessMap[row - i][col] == chessMap[row - i + 3][col] &amp;&amp;
			chessMap[row - i][col] == chessMap[row - i + 4][col])
			return true;
	}

	// “/"方向
	for (int i = 0; i &lt; 5; i++)
	{
		if (row + i &lt; gradeSize &amp;&amp;
			row + i - 4 &gt;= 0 &amp;&amp;
			col - i &gt;= 0 &amp;&amp;
			col - i + 4 &lt; gradeSize &amp;&amp;
			// 第[row+i]行，第[col-i]的棋子，与右上方连续4个棋子都相同
			chessMap[row + i][col - i] == chessMap[row + i - 1][col - i + 1] &amp;&amp;
			chessMap[row + i][col - i] == chessMap[row + i - 2][col - i + 2] &amp;&amp;
			chessMap[row + i][col - i] == chessMap[row + i - 3][col - i + 3] &amp;&amp;
			chessMap[row + i][col - i] == chessMap[row + i - 4][col - i + 4])
			return true;
	}

	// “\“ 方向
	for (int i = 0; i &lt; 5; i++)
	{
		// 第[row+i]行，第[col-i]的棋子，与右下方连续4个棋子都相同
		if (row - i &gt;= 0 &amp;&amp;
			row - i + 4 &lt; gradeSize &amp;&amp;
			col - i &gt;= 0 &amp;&amp;
			col - i + 4 &lt; gradeSize &amp;&amp;
			chessMap[row - i][col - i] == chessMap[row - i + 1][col - i + 1] &amp;&amp;
			chessMap[row - i][col - i] == chessMap[row - i + 2][col - i + 2] &amp;&amp;
			chessMap[row - i][col - i] == chessMap[row - i + 3][col - i + 3] &amp;&amp;
			chessMap[row - i][col - i] == chessMap[row - i + 4][col - i + 4])
			return true;
	}

	return false;
}</code></pre>
<h2 id="15.%204%20%E6%B5%8B%E8%AF%95%E6%95%88%E6%9E%9C">15. 4 测试效果</h2>
<p>已经能够完美判定胜负了，并能自动开启下一局。</p>
<p><img alt="" height="934" src="image\57539618b78240a7ad46499aea6e146f.png" width="913"/></p>
<p>再把落子音效加上，用户体验就更好了。</p>
<p>Chess.cpp</p>
<pre><code class="language-cpp">void Chess::chessDown(ChessPos* pos, chess_kind_t kind)
{
	mciSendString("play res/down7.WAV", 0, 0, 0);
    //......
}</code></pre>
<h1 id="16.%20AI%E8%BF%9B%E4%B8%80%E6%AD%A5%E4%BC%98%E5%8C%96">16. AI进一步优化</h1>
<p>现在AI的实力，对于一般的五子棋业余爱好者，已经能够秒杀，但是对于业余中的“大佬”，还是力不从心，甚至会屡战屡败，主要原因有两点：</p>
<blockquote>
<p>1. 没有对跳三和跳四进行判断。实际上，跳三和跳四的价值与连三连四的价值，是完全相同的。而现在的AI只计算了连三和连四，没有考虑跳三跳四，所以就会错失“好棋”！</p>
</blockquote>
<p><img alt="" height="272" src="image\8ed1fefeb28b4083aaec0a921c1e380a.png" width="478"/></p>
<p>对于上图，在位置1和位置2，都会形成“跳三”。</p>
<p><img alt="" height="305" src="image\4b8c583a2cf0485082be436d2a47d2e0.png" width="472"/></p>
<p>对于上图在位置3和位置4，都会形成连三.</p>
<p></p>
<p><img alt="" height="282" src="image\31980b1ba3a44152b8f8f533793086e4.png" width="470"/> </p>
<p>对于上图，在位置1对黑棋形成“跳四”，跳四的价值和“连四”或“冲四”的价值也是相同的！</p>
<blockquote>
<p>2. 没有对黑棋设置“禁手”。因为五子棋已经发展到“黑棋先行必胜”的套路，所以职业五子棋比赛，会对黑棋设置以下“禁手”。</p>
<ul><li>三三禁手</li><li>四四禁手</li><li>长连禁手</li></ul>
</blockquote>
<p>三三禁手（如果在该位置主动落子或者被动落子，直接判黑方战败！）</p>
<p><img alt="" height="264" src="image\153b106cf63c4efbbe3ee05b17058123.png" width="431"/></p>
<p> 四四禁手（如果在该位置主动落子或者被动落子，直接判黑方战败！）</p>
<p><img alt="" height="347" src="image\bdd0213b94c0486da7f3e2def87d0412.png" width="537"/></p>
<p>长连禁手（如果在该位置主动落子或者被动落子，直接判黑方战败！）<br/><img alt="" height="212" src="image\385da2f15c594921962700ebb38d9cdd.png" width="487"/></p>
<h2 id="AI%E6%8F%90%E5%8D%87">AI提升</h2>
<ul><li>在计算落子点价值的时候，增加对跳三和跳四的价值判断</li><li>在判断胜负时，增加对黑方禁手的判断。</li></ul>
<p>通过以上的优化后，业余高手也很难取胜了！但是对专业棋手，还是难以招架！原因在于，目前的AI只根据当前盘面进行判断，静态的最佳座子点。没有对后续步骤进行连续判断。可以使用“搜索树”，进行连续判定，搜索的深度越深，AI的棋力就越深。最终五子棋，就和象棋一样，彻底碾压人类棋手。</p>
<h1 id="17.%20%E5%BC%80%E5%8F%91%E6%8B%93%E5%B1%95">17. 开发拓展</h1>
<p>计分以及棋力等级|<br/> 悔棋功能 <br/> 棋力训练（充值送形势判断）<br/> 记棋谱功能<br/> 网络对战功能<br/> 邀请微信好友、QQ好友对战功能<br/> 移植到移动端（Android和IOS）</p>
<p>---END.</p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
</div>
</div>