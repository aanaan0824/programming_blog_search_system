<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="markdown_views prism-github-gist" id="content_views">
<svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
<path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
</svg>
<p><font color="red">备战实习，会定期的总结常考的面试题，大家一起加油！ 🎯</font></p>
<blockquote>
<p><font color="red">往期文章：</font></p>
<ul><li><a href="https://blog.csdn.net/qq_45966440/article/details/121389301">【面试题】计算机网络篇-10道常见面试题p1</a></li><li><a href="https://blog.csdn.net/qq_45966440/article/details/121308864">【面试题】JVM篇-10道常见面试题p1</a></li><li><a href="https://blog.csdn.net/qq_45966440/article/details/121450360?spm=1001.2014.3001.5501">【面试题】Java并发篇-10道常见面试题p1</a></li><li><a href="https://blog.csdn.net/qq_45966440/article/details/121536345">【面试题】Java基础篇-常见面试题总结p1</a></li><li><a href="https://blog.csdn.net/qq_45966440/article/details/121690695?spm=1001.2014.3001.5502">【面试题】Java基础篇-常见面试题总结p2</a></li><li><a href="https://blog.csdn.net/qq_45966440/article/details/122006579">【面试题】MySQL常见面试题合集</a></li><li><a href="https://blog.csdn.net/qq_45966440/article/details/122120307">【面试题】Java基础篇-常见面试题总结p3</a></li></ul>
</blockquote>
<blockquote>
<p><font color="red">注意：</font></p>
<p>如果本文中有错误的地方，欢迎评论区指正！🍭</p>
</blockquote>
<p></p>
<div class="toc">
<h3>文章目录</h3>
<ul><li><ul><li><a href="#1Java_21">1.说说Java中常用的容器有哪些？</a></li><li><a href="#2_Arraylist__LinkedList_52">2.详细说说 Arraylist 和 LinkedList的区别?</a></li><li><a href="#3ArrayList_RandomAccess_64">3.ArrayList实现 RandomAccess接口有何作用？</a></li><li><a href="#4Vector__ArrayList__93">4.说一说Vector 和 ArrayList 的区别？</a></li><li><a href="#5ArrayList__103">5.说说ArrayList 的扩容机制？</a></li><li><a href="#6ArrayArrayList_116">6.Array和ArrayList有何区别？</a></li><li><a href="#7List_128">7.遍历一个List有哪些不同的方式？</a></li><li><a href="#8comparablecomparator_172">8.comparable和comparator的区别？</a></li><li><a href="#9CollectionCollections_186">9.Collection和Collections有什么区别？</a></li><li><a href="#10PriorityQueue_191">10.说一下PriorityQueue？</a></li><li><a href="#11HashSet_206">11.说一下HashSet的实现原理？</a></li><li><a href="#12HashMap_216">12.HashMap的实现原理/底层数据结构？</a></li><li><a href="#13HashMap__2__248">13.HashMap 的长度为什么是 2 的幂次方？</a></li><li><a href="#14HashMapput_254">14.说说HashMap的put方法执行流程？</a></li><li><a href="#15HashMapget_269">15.说说HashMap的get方法执行流程？</a></li><li><a href="#16HashMapresize_278">16.说说HashMap的resize方法执行过程？</a></li><li><a href="#17HashMap_288">17.HashMap什么时候会树化？</a></li><li><a href="#18HashMap_302">18.HashMap底层为什么选择红黑树而不用其他树，比如二叉查找树？</a></li><li><a href="#19HashMap_075f_320">19.HashMap扩容（加载）因子为何默认是 0.75f？</a></li><li><a href="#20HashMap_key__hash__326">20.HashMap怎么计算 key 的 hash 值的？</a></li><li><a href="#21HashMap_360">21.HashMap是怎么解决哈希冲突的？</a></li><li><a href="#22HashMap_373">22.HashMap多线程操作导致死循环问题知道吗?</a></li><li><a href="#23LinkedHashMap__379">23.说说LinkedHashMap 的实现原理？</a></li><li><a href="#24HashMap__HashSet__384">24.说说HashMap 和 HashSet 区别？</a></li><li><a href="#25HashMap__Hashtable__396">25.说下HashMap 和 Hashtable 的区别？</a></li><li><a href="#26HashMap__TreeMap__412">26.说一下HashMap 和 TreeMap 区别？</a></li><li><a href="#27HashMapStringIntegerKey_459">27.为什么HashMap中String、Integer这样的包装类适合作为Key?</a></li><li><a href="#28Queue__Deque__476">28.说一下Queue 与 Deque 的区别？</a></li><li><a href="#29ArrayDeque__LinkedList__499">29.说说ArrayDeque 与 LinkedList 的区别？</a></li><li><a href="#30_HashSetLinkedHashSet__TreeSet__514">30.说一下 HashSet、LinkedHashSet 和 TreeSet 三者的异同？</a></li></ul>
</li></ul>
</div>
<br/>
<img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/c5082b19b8304f2b91f4476aa07118ff.webp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATEwuTEVCUk9O,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center"/>
<p></p>
<h2><a id="1Java_21"></a>1.说说Java中常用的容器有哪些？</h2>
<p>容器主要包括 <code>Collection</code> 和 <code>Map</code> 两种，Collection 存储着对象的集合，而 Map 存储着键值对(两个对象)的映射表。</p>
<p>如图：</p>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/cdef9c2fe26644febdcbb52f40c38895.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATEwuTEVCUk9O,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<blockquote>
<p>👨‍💻<font color="pick">面试官追问：说说集合有哪些类及他们各自的区别和特点？</font></p>
</blockquote>
<ul><li>Set 
  <ul><li><code>TreeSet</code> 基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。</li><li><code>HashSet</code> 基于HashMap实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。</li><li><code>LinkedHashSet</code> 是 HashSet 的子类，并且其内部是通过 LinkedHashMap 来实现的。内部使用双向链表维护元素的插入顺序。</li></ul> </li><li>List 
  <ul><li><code>ArrayList</code> 基于动态数组实现，支持随机访问。</li><li><code>Vector</code> 和 ArrayList 类似，但它是线程安全的。</li><li><code>LinkedList</code> 基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。</li></ul> </li><li>Queue 
  <ul><li><code>LinkedList</code> 可以用它来实现双向队列。</li><li><code>PriorityQueue</code> 基于堆结构实现，可以用它来实现优先队列。</li><li><code>ArrayQueue</code>基于数组实现，可以用它实现双端队列，也可以作为栈。</li></ul> </li></ul>
<blockquote>
<p>👨‍💻<font color="pick">面试官追问：说说Map有哪些类及他们各自的区别和特点？</font></p>
</blockquote>
<ul><li><code>TreeMap</code> 基于红黑树实现。</li><li><code>HashMap</code> 1.7基于数组+链表实现，1.8基于数组+链表+红黑树。链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</li><li><code>HashTable</code> 和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 HashTable 并且不会导致数据不一致。它是遗留类，不应该去使用它。（现在可以使用 ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高(1.7 ConcurrentHashMap 引入了分段锁, 1.8 引入了红黑树)。）</li><li><code>LinkedHashMap</code>继承自 HashMap。使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用(LRU)顺序。</li></ul>
<h2><a id="2_Arraylist__LinkedList_52"></a>2.详细说说 Arraylist 和 LinkedList的区别?</h2>
<ul><li><code>ArrayList</code>：底层是基于<strong>数组</strong>实现的，<strong>查找快，增删较慢</strong>。<code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code> 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</li><li><code>LinkedList</code>：底层是基于<strong>链表</strong>实现的。确切的说是循环双向链表(JDK1.6之前是双向循环链表、JDK1.7之后取消了循环)，<strong>查找慢、增删快</strong>。LinkedList链表由一系列表项连接而成，一个表项包含3个部分︰元素内容、前驱表和后驱表。因此<strong>内存空间占用</strong>比ArrayList 更多。</li></ul>
<blockquote>
<p>👨‍💻<font color="pick">面试官追问：ArrayList的增删一定比LinkedList要慢吗？</font></p>
</blockquote>
<p>不一定的。</p>
<ol><li>如果增删都是在末尾来操作（每次调用的都是 <code>remove()</code> 和 <code>add()</code>），此时 ArrayList就不需要移动和复制数组来进行操作了。如果数据量有百万级的时，速度是会比 LinkedList 要快的。</li><li>如果删除操作的位置是在中间。由于LinkedList的消耗主要是在遍历上，ArrayList的消耗主要是在移动和复制上(底层调用的是<code>arrayCopy()</code>方法，是native方法)。LinkedList 的遍历速度是要慢于ArrayList的复制移动速度的。如果数据量有百万级的时，还是ArrayList要快。</li></ol>
<h2><a id="3ArrayList_RandomAccess_64"></a>3.ArrayList实现 RandomAccess接口有何作用？</h2>
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">RandomAccess</span> <span class="token punctuation">{<!-- --></span>
<span class="token punctuation">}</span>
</code></pre>
<p>查看源码我们发现实际上 <code>RandomAccess</code> 接口中什么都没有定义。</p>
<p>从源码可以看出RandomAccess 接口只是一个标志接口，只要List集合实现这个接口，就能支持快速随机访问。通过查看<code>Collections</code>类中的<code>binarySearch()</code>方法，可以看出，判断List是否实现RandomAccess接口来实行<code>indexedBinarySerach(list, key)</code>或 <code>iteratorBinarySerach(list, key)</code>方法。再通过查看这两个方法的源码发现：<strong>实现RandomAccess接口的List集合采用一般的 for循环遍历，而未实现这接口则采用迭代器</strong>，即ArrayList 一般采用for循环遍历，而 LinkedList 一般采用迭代器遍历</p>
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">binarySearch</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">T</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> list<span class="token punctuation">,</span> <span class="token class-name">T</span> key<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>list <span class="token keyword">instanceof</span> <span class="token class-name">RandomAccess</span> <span class="token operator">||</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>BINARYSEARCH_THRESHOLD<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">indexedBinarySearch</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token keyword">return</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">iteratorBinarySearch</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>👨‍💻<font color="pick">面试官追问：为何LinkedList却没实现这个接口？</font></p>
</blockquote>
<p><code>ArrayList</code> 底层是数组，而 <code>LinkedList</code> 底层是链表。</p>
<p>数组天然支持随机访问，时间复杂度为 O(1)，所以称为快速随机访问。链表需要遍历到特定位置才能访问特定位置的元素，时间复杂度为 O(n)，所以不支持快速随机访问。</p>
<p><code>ArrayList</code> 实现了 <code>RandomAccess</code> 接口，就表明了他具有快速随机访问功能。 <code>RandomAccess</code> 接口只是标识，并不是说 <code>ArrayList</code> 实现 <code>RandomAccess</code> 接口才具有快速随机访问功能的！</p>
<h2><a id="4Vector__ArrayList__93"></a>4.说一说Vector 和 ArrayList 的区别？</h2>
<p>他们两个都实现了<code>List</code>接口。底层数据结构都是数组。</p>
<p>不同的是：</p>
<ol><li>vector通过<code>remove</code>、<code>add</code>等方法加上<code>synchronized</code>关键字实现线程同步，所以是线程安全的。而ArrayList是线程不安全的</li><li>由于vector使用了<code>synchronized</code>进行加锁，所以性能不如ArrayList</li><li>Vector 扩容时，如果未指定扩容递增值<code>capacityIncrement</code>，或该值不大于 0 时，每次扩容为原来的 <code>2</code> 倍，否则扩容量为<code>capacityIncrement</code>的值。ArrayList每次扩容为旧容量的<code>1.5</code>倍</li></ol>
<h2><a id="5ArrayList__103"></a>5.说说ArrayList 的扩容机制？</h2>
<ol><li> <p>当使用add方法的时候首先调用<code>ensureCapacityInternal</code>方法，传入 <code>size+1</code>进去，检查是否需要扩容</p> </li><li> <p>如果空数组<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>，就初始化为默认大小10，获取“默认的容量”和要扩容的大小两者之间的最大值</p> </li><li> <p>和当前数组长度比较，如果 <code>if (minCapacity - elementData.length &gt; 0)</code>执行<code>grow</code>扩容方法</p> </li><li> <p>将数组扩容为原来的1.5倍 <code>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</code></p> </li><li> <p>检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量</p> </li><li> <p>再检查新容量newCapacity 是否超出了ArrayList所定义的最大容量，若超出了，则调用<code>hugeCapacity()</code>来比较minCapacity和 MAX_ARRAY_SIZE，如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE（<code>MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8</code>）</p> </li><li> <p>ArrayList 中copy数组的核心就是<code>System.arraycopy</code>方法，将original数组的所有数据复制到copy数组中，这是一个本地方法</p> </li></ol>
<blockquote>
<p>详细的扩容源码可以参考：https://blog.csdn.net/qq_45966440/article/details/122270715?spm=1001.2014.3001.5501</p>
</blockquote>
<h2><a id="6ArrayArrayList_116"></a>6.Array和ArrayList有何区别？</h2>
<ul><li>Array可以容纳基本类型和对象，而ArrayList只能容纳对象</li><li>Array是指定大小的，ArrayList 的容量是根据需求自动扩展</li><li>ArrayList提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等</li></ul>
<blockquote>
<p>👨‍💻<font color="pick">面试官追问：什么时候更适合使用Array？</font></p>
</blockquote>
<ol><li>如果列表的大小已经指定，大部分情况下是存储和遍历它们可以使用Array</li><li>对于基本类型数据，ArrayList 使用自动装箱来减少编码工作量；而当处理固定大小的基本数据类型的时候，这种方式相对比较慢，这时候应该使用Array</li><li>如果你要使用多维数组，使用<code>[][]</code>比 List更容易</li></ol>
<h2><a id="7List_128"></a>7.遍历一个List有哪些不同的方式？</h2>
<p>先说一下常见的元素在内存中的存储方式，主要有两种:</p>
<ol><li><strong>顺序存储</strong>(Random Access)：相邻的数据元素在内存中的位置也是相邻的，可以根据元素的位置读取元素。</li><li><strong>链式存储</strong>(Sequential Access)：每个数据元素包含它下一个元素的内存地址，在内存中不要求相邻。例如LinkedList。</li></ol>
<p>主要的遍历方式主要有三种：</p>
<ol><li><code>for</code>循环遍历：遍历者自己在集合外部维护一个计数器，依次读取每一个位置的元素</li><li><code>Iterator</code>遍历：基于顺序存储集合的Iterator可以直接按位置访问数据。基于链式存储集合的Iterator，需要保存当前遍历的位置，然后根据当前位置来向前或者向后移动指针</li><li><code>foreach</code>遍历：也就是增强for循环，foreach内部也是采用了Iterator的方式实现，但使用时不需要显示地声明Iterator</li></ol>
<p>代码如下：</p>
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestLinkedList</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"aaa"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"bbb"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"ccc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//for循环遍历</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//Iterator遍历</span>
        <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> iterator <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//foreach遍历</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> s <span class="token operator">:</span> list<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>👨‍💻<font color="pick">面试官追问：那么对于以上三种遍历方式应该如何选取呢？</font></p>
</blockquote>
<p>在Java集合框架中，提供了一个<code>RandomAccess</code>接口，该接口没有方法，只是一个标记。通常用来标记List的实现是否支持RandomAccess。所以在遍历时，可以先判断是否支持RandomAccess ( list instanceof RandomAccess)，如果支持可用for循环遍历，否则建议用Iterator或 foreach遍历。</p>
<h2><a id="8comparablecomparator_172"></a>8.comparable和comparator的区别？</h2>
<ul><li><code>comparable</code>接口出自<code>java.lang</code>包，可以理解为一个内比较器，因为实现了comparable接口的类可以和自己比较，要和其他实现了Comparable接口类比较，可以使用<code>compareTo(objectobj)</code>方法。compareTo方法的返回值是int，有三种情况： 
  <ol><li>返回正整数（比较者大于被比较者）</li><li>返回0（比较者等于被比较者）</li><li>返回负整数（比较者小于被比较者）</li></ol> </li><li><code>comparator</code>接口出自<code>java.util</code>包，它有一个<code>compare(object obj1，object obj2)</code>方法用来排序，返回值同样是int，有三种情况，和compareTo类似。</li></ul>
<p>它们之间的区别：</p>
<ol><li>很多包装类都实现了comparable接口，像Integer、string等。所以直接调用<code>co1lections.sort()</code>直接可以使用。如果对类里面自带的自然排序不满意，而又不能修改其源代码的情况下，使用<code>comparator</code>就比较合适。</li><li>此外使用<code>comparator</code>可以避免添加额外的代码与我们的目标类耦合，同时可以定义多种排序规则，这一点是comparable接口没法做到的</li><li><strong>从灵活性和扩展性讲<code>Comparator</code>更优，故在面对自定义排序的需求时，可以优先考虑使用comparator接口。</strong></li></ol>
<h2><a id="9CollectionCollections_186"></a>9.Collection和Collections有什么区别？</h2>
<ul><li><code>Collection</code>：是最基本的<strong>集合接口</strong>，它提供了对集合对象进行基本操作的通用接口方法。一个Collection代表一组Object，即Collection的元素。它的直接继承接口有List，Set 和Queue。</li><li><code>Collections</code>：是不属于Java的集合框架的，它是<strong>集合类的一个工具类</strong>。<strong>此类不能被实例化</strong>，<strong>服务于Java的Collection框架</strong>。它包含有关集合操作的静态多态方法，实现对各种集合的搜索、排序、线程安全等操作。</li></ul>
<h2><a id="10PriorityQueue_191"></a>10.说一下PriorityQueue？</h2>
<p><code>PriorityQueue</code> 是在 JDK1.5 中被引入的, 其与 <code>Queue</code> 的区别在于元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。</p>
<p>它有这些特点：</p>
<ul><li><code>PriorityQueue</code> 利用了<strong>二叉堆</strong>的数据结构来实现的，底层使用<strong>可变长的数组来存储数据</strong>。</li><li><code>PriorityQueue</code> 通过堆元素的上浮和下沉，实现了在 <code>O(logn)</code> 的时间复杂度内插入元素和删除堆顶元素。</li><li><code>PriorityQueue</code> 是<strong>非线程安全的</strong>，且不支持存储 <code>NULL</code> 和 <code>non-comparable</code> 的对象。</li><li><code>PriorityQueue</code> <strong>默认是小顶堆</strong>，但可以接收一个 <code>Comparator</code> 作为构造参数，从而来自定义元素优先级的先后。</li><li>默认容量是<code>11</code>。当数组比较小（<strong>小于64</strong>）的时候每次<strong>扩容容量翻倍</strong>。当数组比较大（<strong>大于等于64</strong>）的时候每次扩容只<strong>增加一半的容量</strong>。</li><li><code>PriorityQueue</code><strong>不是有序的，只有堆顶存储着最小的元素</strong></li></ul>
<blockquote>
<p>可以参考PriorityQueue源码：https://blog.csdn.net/qq_45966440/article/details/122273598?spm=1001.2014.3001.5501</p>
</blockquote>
<h2><a id="11HashSet_206"></a>11.说一下HashSet的实现原理？</h2>
<p><code>HashSet</code> 的实现是依赖于<code>HashMap</code>的，HashSet 的值都是存储在HashMap中的。在 HashSet 的构造法中会初始化一个HashMap对象，HashSet 不允许值重复。因此，HashSet的值是作为HashMap的key存储在HashMap 中的，当存储的值已经存在时返回false。</p>
<blockquote>
<p>👨‍💻<font color="pick">面试官追问：HashSet有哪些特点？</font></p>
</blockquote>
<ul><li><strong>无序性</strong>（存储元素无序）</li><li><strong>唯一性</strong>（允许使用<strong>null</strong>）本质上，HashSet的值是作为HashMap的key存储在HashMap 中的，因此保证唯一性</li><li>HashSet没有提供<code>get()</code>方法，同HashMap一样，因为Set内部是<strong>无序</strong>的，所以只能通过<strong>迭代</strong>的方式获得</li></ul>
<h2><a id="12HashMap_216"></a>12.HashMap的实现原理/底层数据结构？</h2>
<ul><li>JDK1.7：数组 + 链表</li><li>JDK1.8：数组 + （链表 | 红黑树）</li></ul>
<p>HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</p>
<p><strong>所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。</strong></p>
<p>JDK1.8的hash方法：</p>
<pre><code class="prism language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> h<span class="token punctuation">;</span>
    <span class="token comment">// key.hashCode()：返回散列值也就是hashcode</span>
    <span class="token comment">// ^ ：按位异或</span>
    <span class="token comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>JDK1.7的hash方法：</p>
<pre><code class="prism language-java"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    h <span class="token operator">^=</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> h <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>从源码可以看出JDK 1.8 的 hash 方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。</p>
<h2><a id="13HashMap__2__248"></a>13.HashMap 的长度为什么是 2 的幂次方？</h2>
<ol><li><strong>计算索引时效率更高</strong>：<code>hash % tab.length</code>，而计算机中直接求余运算效率不如位移运算。所以源码中做了优化，使用 <code>hash &amp; (tab.length- 1)</code>来寻找桶位。而实际上 <code>hash % length</code> 等于 <code>hash &amp; ( length - 1)</code> 的<strong>前提是 length 必须为 2 的 n 次幂</strong></li><li><strong>扩容时重新计算索引效率更高</strong>： <code>hash &amp; oldCap == 0</code> 的元素留在原来位置 ，否则<code>新位置 = 旧位置 + oldCap</code></li><li>当根据 key 的 hash 值寻址计算确定桶位下标 index 时，如果HashMap 的数组长度 tab.length 是 2 的 n 次幂数，那么就<strong>可以保证新插入数组中的数据均匀分布，每个桶位都有可能分配到数据</strong>，而如果数组长度不是 2 的 n 次幂数，那么就可能导致一些桶位上永远不会被插入到数据，反而有些桶位频繁发生 hash 冲突，导致数组空间浪费，冲hash 突概率增加。</li></ol>
<h2><a id="14HashMapput_254"></a>14.说说HashMap的put方法执行流程？</h2>
<ol><li>计算key的hash值</li><li>如果桶（数组）数量为0，则初始化桶</li><li>如果key所在的桶没有元素，则直接插入</li><li>如果key所在的桶中的第一个元素的key与待插入的key相同，说明找到了元素，转后续流程（9）处理</li><li>如果第一个元素是树节点，则调用树节点的putTreeVal()寻找元素或插入树节点</li><li>如果不是以上三种情况，则遍历桶对应的链表查找key是否存在于链表中</li><li>如果找到了对应key的元素，则转后续流程（9）处理</li><li>如果没找到对应key的元素，则在链表最后插入一个新节点并判断是否需要树化</li><li>如果找到了对应key的元素，则判断是否需要替换旧值，并直接返回旧值</li><li>如果插入了元素，则数量加1并判断是否需要扩容</li></ol>
<blockquote>
<p>详细的HashMap方法执行过程可以参考：<a href="https://blog.csdn.net/qq_45966440/article/details/122274063?spm=1001.2014.3001.5501">【JDK源码】HashMap源码分析（附常见面试题）</a></p>
</blockquote>
<h2><a id="15HashMapget_269"></a>15.说说HashMap的get方法执行流程？</h2>
<ol><li>计算key的hash值</li><li>找到key所在的桶及其第一个元素</li><li>如果第一个元素的key等于待查找的key，直接返回</li><li>如果第一个元素是树节点就按树的方式来查找</li><li>否则就按链表方式查找</li><li>如果都没有，返回null</li></ol>
<h2><a id="16HashMapresize_278"></a>16.说说HashMap的resize方法执行过程？</h2>
<ol><li><strong>如果使用是默认构造方法</strong>，则第一次插入元素时初始化为默认值，容量为<code>16</code>，扩容门槛为<code>12</code></li><li><strong>如果使用的是非默认构造方法</strong>，则第一次插入元素时初始化容量等于扩容门槛，扩容门槛在构造方法里等于传入容量向上最近的2的n次方</li><li>如果旧容量大于0，则新容量等于旧容量的2倍，但不超过最大容量2的30次方，新扩容门槛为旧扩容门槛的2倍</li><li>创建一个新容量的桶</li><li>搬移元素，原链表分化成两个链表，低位链表存储在原来桶的位置，高位链表搬移到原来桶的位置加旧容量的位置</li></ol>
<blockquote>
<p>关于这部分建议详细看看源码：<a href="https://blog.csdn.net/qq_45966440/article/details/122274063?spm=1001.2014.3001.5501">【JDK源码】HashMap源码分析（附常见面试题）</a></p>
</blockquote>
<h2><a id="17HashMap_288"></a>17.HashMap什么时候会树化？</h2>
<p>必须满足两个条件：</p>
<ul><li>链表长度超过树化阈值<code>&gt;8</code></li><li>数组容量<code>&gt;=64</code></li></ul>
<p><strong>当链表长度超过树化阈值 8 时，先尝试扩容来减少链表长度，如果数组容量已经 &gt;=64，才会进行树化。</strong></p>
<blockquote>
<p>👨‍💻<font color="pick">面试官追问：那什么时候树化退化？</font></p>
</blockquote>
<ul><li>情况1：在扩容时如果拆分树时，树元素个数 <code>&lt;= 6</code> 则会退化链表</li><li>情况2：移除之前，remove 树节点时，若 root、root.left、root.right、root.left.left 有一个为 null ，也会退化为链表</li></ul>
<h2><a id="18HashMap_302"></a>18.HashMap底层为什么选择红黑树而不用其他树，比如二叉查找树？</h2>
<p>二叉查找树在特殊情况下也会变成一条线性结构，和原先的长链表存在一样的深度遍历问题，查找性能慢，如图：</p>
<p><img alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-HK0FBid9-1641174128439)(【面试题】Java集合篇-常见面试题总结.assets/20210213170920432.png)]" src="https://img-blog.csdnimg.cn/7f597ffa284e403aa5c9e2c63b6e455d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATEwuTEVCUk9O,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<p>使用红黑树主要是为了提升查找数据的速度，红黑树是平衡二叉树的一种，插入新数据（新数据初始是红色结点插入）后会<strong>通过左旋，右旋，变色等操作来保持平衡</strong>，解决单链表查询深度的问题。</p>
<blockquote>
<p>👨‍💻<font color="pick">面试官追问：那为什么要将链表中转红黑树的阈值设为8？</font></p>
</blockquote>
<p>之所以以 <code>8</code> 为树化门槛，是因为经过大量测试，8 这个值是最合适的。理想情况下，使用随机的哈希码，节点分布在 hash 桶中的频率<strong>遵循泊松分布</strong>，按照泊松分布的公式计算，长度超过 8 的链表出现概率是 <code>0.00000006</code>。树化阈值选择 8 就是为了让树化几率足够小</p>
<blockquote>
<p>👨‍💻<font color="pick">面试官继续追问：那为什么不一开始直接使用红黑树？</font></p>
</blockquote>
<ul><li>当链表数据量少的时候，遍历线性链表比遍历红黑树消耗的资源少 (因为少量数据，红黑树本身自选、变色保持平衡也是需要消耗资源的)，所以前期使用线性表。</li><li>然后TreeNode 占用空间也比普通 Node 的大，如非必要，尽量还是使用链表</li></ul>
<h2><a id="19HashMap_075f_320"></a>19.HashMap扩容（加载）因子为何默认是 0.75f？</h2>
<ol><li>在空间占用与查询时间之间取得较好的权衡</li><li>大于这个值，空间节省了，但链表就会比较长影响性能</li><li>小于这个值，冲突减少了，但扩容就会更频繁，空间占用也更多</li></ol>
<h2><a id="20HashMap_key__hash__326"></a>20.HashMap怎么计算 key 的 hash 值的？</h2>
<p>我们先看源码：</p>
<pre><code class="prism language-JAVA">static final int hash(Object key) {
    int h;
    //key==null直接返回0
    //1、否则调用key的hashCode()方法计算出key的哈希值然后赋值给h,
    //2、h &gt;&gt;&gt; 16。后与h无符号右移16位后的二进制进行按位异或得到最后的hash值,
    //3、这样做是为了使计算出的hash更分散，让高16位可以参与（低16位具有高16位的特征）
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
}

</code></pre>
<p>可以看出：</p>
<ol><li>首先，计算对象的 <code>hashCode()</code></li><li>然后将 key 的 hashCode 的高 16 位和 hashCode 低 16 位 进行<strong>异或</strong>（XOR）运算，最终得到新的 hash 值。<strong>二次 hash() 是为了综合高位数据，让哈希分布更为均匀</strong></li></ol>
<p>关于第二点，这里举个例子就知道了：</p>
<p>我们知道，HashMap 新插入的数据需要经过寻址算法 <code>index = hash &amp; (tab.length - 1)</code>来确定桶位下标。tab.length就是数组长度，我们这里设其为 n。</p>
<p>如果当 n 即数组长度很小，假设是 n = 16 的话，那么 n - 1 是 15 ，其二进制数为 1111 ，这样的值和 hashCode 直接做按位与操作，实际上只使用了哈希值的后 4 位。如果当哈希值的高位变化很大，低位变化很小，这样就很容易造成哈希冲突了，所以这里把高低位都利用起来，从而解决了这个问题</p>
<p>我们来看一个分析图：</p>
<p><img alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-dfDGFTm9-1641174128442)(【面试题】Java集合篇-常见面试题总结.assets/20210122170626394.png)]" src="https://img-blog.csdnimg.cn/9b7cc2f384184dc9b66921cefd1ce729.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATEwuTEVCUk9O,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<p>由上图，可以知道如果只使用 key.hashCode()方法计算得到的 hash 值，那么当 hash 值高位变化较大，而低位变化较小时，通过寻址算法 hash &amp; (tab.length - 1) 得到的桶位下标 index 就更容易出现 hash 冲突了！</p>
<h2><a id="21HashMap_360"></a>21.HashMap是怎么解决哈希冲突的？</h2>
<blockquote>
<p><mark>哈希冲突</mark>：hashMap在存储元素时会先计算key的hash值来确定存储位置，因为key的hash值计算最后有个对数组长度取余的操作，所以即使不同的key也可能计算出相同的hash值，这样就引起了hash冲突。hashMap的底层结构中的链表/红黑树就是用来解决这个问题的。</p>
</blockquote>
<p>HashMap中的哈希冲突解决方式可以主要从三方面考虑（以JDK1.8为背景)</p>
<ol><li><strong>拉链法</strong><br/> HasMap中的数据结构为数组+链表/红黑树，当不同的key计算出的hash值相同时，就用链表的形式将Node结点（冲突的key及key对应的value)挂在数组后面。</li><li><strong>hash函数</strong><br/> key的hash值经过两次扰动， key的hashcode值与key的hashcode值的右移16位进行异或，然后对数组的长度取余（实际为了提高性能用的是位运算，但目的和取余一样)，这样做可以让hashcode取值出的高位也参与运算，进一步降低hash冲突的概率，使得数据分布更平均。</li><li><strong>红黑树</strong><br/> 在拉链法中，如果hash冲突特别严重，则会导致数组上挂的链表长度过长，性能变差，因此在链表长度大于8时，将链表转化为红黑树，可以提高遍历链表的速度。</li></ol>
<h2><a id="22HashMap_373"></a>22.HashMap多线程操作导致死循环问题知道吗?</h2>
<p>在jdk1.7之前，主要原因在于并发下的 Rehash 会造成元素之间会形成一个循环链表。不过，jdk 1.8 后解决了这个问题，但是还是不建议在多线程下使用 HashMap,因为多线程下使用 HashMap 还是会存在其他问题比如数据丢失。并发环境下推荐使用 ConcurrentHashMap 。</p>
<blockquote>
<p>这部分建议详细参考：<a href="https://blog.csdn.net/chenyiminnanjing/article/details/82706942?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164117350716780261952150%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=164117350716780261952150&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-11-82706942.pc_search_result_cache&amp;utm_term=HashMap%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%93%8D%E4%BD%9C%E5%AF%BC%E8%87%B4%E6%AD%BB%E5%BE%AA%E7%8E%AF%E9%97%AE%E9%A2%98%E7%9F%A5%E9%81%93%E5%90%97&amp;spm=1018.2226.3001.4187">hashmap扩容时死循环问题</a></p>
</blockquote>
<h2><a id="23LinkedHashMap__379"></a>23.说说LinkedHashMap 的实现原理？</h2>
<ul><li>LinkedHashMap也是基于<code>HashMap</code> 实现的，不同的是它定义了一个Entry header，这个header不是放在Table里，它是额外独立出来的。LinkedHashMap通过继承hashMap 中的Entry，并添加两个属性Entrybefore，after和 header结合起来组成一个双向链表，来实现按插入顺序或访问顺序排序。</li><li>LinkedHashMap定义了排序模式 <code>accessOrder</code>，该属性为boolean型变量，对于访问顺序，为true，对于插入顺序，则为false。一般情况下，不必指定排序模式，其迭代顺序即为默认为插入顺序。</li></ul>
<h2><a id="24HashMap__HashSet__384"></a>24.说说HashMap 和 HashSet 区别？</h2>
<p><code>HashSet</code> 底层就是基于 <code>HashMap</code> 实现的。两者主要区别：</p>
<table><thead><tr><th>HashMap</th><th>HashSet</th></tr></thead><tbody><tr><td>实现了<code>Map</code>接口</td><td>实现了<code>set</code>接口</td></tr><tr><td>存储键值对</td><td>存储对象</td></tr><tr><td>key 唯一，value不唯一</td><td>存储对象唯一</td></tr><tr><td>HashMap使用键(Key )计算Hashcode</td><td>HashSet 使用成员对象来计算 hashcode 值，对于两个对象来说 hashcode 可能相同，所以equals()方法用来判断对象的相等性</td></tr><tr><td>速度相对较快</td><td>速度相对较慢</td></tr></tbody></table>
<h2><a id="25HashMap__Hashtable__396"></a>25.说下HashMap 和 Hashtable 的区别？</h2>
<ol><li> <p><strong>线程是否安全：</strong> <code>HashMap</code> 是非线程安全的，<code>Hashtable</code> 是线程安全的,因为 Hashtable 内部的方法基本都经过<code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 <code>ConcurrentHashMap</code> 吧！）</p> </li><li> <p>**效率：**因为Hashtable加了<code>synchronized</code>锁。所以HashMap 要比 Hashtable 效率高一点。另外，Hashtable 基本被淘汰，不要在代码中使用它</p> </li><li> <p><strong>对 Null key 和 Null value 的支持：</strong> <code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；<code>Hashtable</code> 不允许有 null 键和 null 值，否则会抛出 <code>NullPointerException</code>。</p> </li><li> <p><strong>初始容量大小和每次扩充容量大小的不同 ：</strong></p> <p>① 创建时如果不指定容量初始值，Hashtable 默认的初始大小为 <code>11</code>，之后每次扩充，容量变为原来的 <code>2n+1</code>。HashMap 默认的初始化大小为 <code>16</code>。之后每次扩充，容量变为原来的 <code>2</code> 倍。</p> <p>② 创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 <code>HashMap</code> 会将其扩充为 2 的幂次方大小。也就是说 <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小。</p> </li><li> <p><strong>底层数据结构：</strong> JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</p> </li></ol>
<h2><a id="26HashMap__TreeMap__412"></a>26.说一下HashMap 和 TreeMap 区别？</h2>
<p><code>TreeMap</code> 和<code>HashMap</code> 都继承自<code>AbstractMap</code> ，但是需要注意的是<code>TreeMap</code>它还实现了<code>NavigableMap</code>接口和<code>SortedMap</code> 接口。</p>
<ul><li>实现 <code>NavigableMap</code> 接口让 <code>TreeMap</code> 有了对集合内元素的搜索的能力。</li><li>实现<code>SortedMap</code>接口让 <code>TreeMap</code> 有了对集合中的元素根据键排序的能力。默认是按 key 的升序排序，不过我们也可以指定排序的比较器。</li></ul>
<p>示例代码如下：</p>
<pre><code class="prism language-java"><span class="token comment">/**
 * @author xppll
 * @date 2022/1/1 21:35
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token class-name">Integer</span> age<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> age<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">Integer</span> <span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> age<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">TreeMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> treeMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">(</span>o1<span class="token punctuation">,</span> o2<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>o1<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> o2<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        treeMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"person1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        treeMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"person2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        treeMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token number">22</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"person3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        treeMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"person4"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        treeMap<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">//输出：</span>
person1
person4
person3
person2
</code></pre>
<p>可以看出，<code>TreeMap</code> 中的元素已经是按照 <code>Person</code> 的 age 字段的升序来排列了。</p>
<p><strong>综上，相比于<code>HashMap</code>来说 <code>TreeMap</code> 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力</strong></p>
<h2><a id="27HashMapStringIntegerKey_459"></a>27.为什么HashMap中String、Integer这样的包装类适合作为Key?</h2>
<ol><li>这些包装类都是<code>final</code>修饰，是不可变性的，保证了key的不可更改性，不会出现放入和获取时哈希值不同的情况。</li><li>它们内部已经重写过<code>hashcode()</code> ， <code>equal()</code>等方法。</li></ol>
<blockquote>
<p>👨‍💻<font color="pick">面试官追问：如果使用Object作为HashMap的Key，应该怎么办呢？</font></p>
</blockquote>
<ol><li>重写<code>hashcode()</code>方法，<strong>因为需要计算hash值确定存储位置</strong></li><li>重写<code>equals()</code>方法，<strong>因为需要保证key的唯一性</strong></li></ol>
<blockquote>
<p>👨‍💻<font color="pick">面试官继续追问：能否使用任何类作为Map 的key？</font></p>
</blockquote>
<p>可以，但要注意以下两点:</p>
<ol><li>如果类重写了<code>equals()</code>方法，也应该重写<code>hashcode()</code>方法。</li><li><strong>最好定义key类是不可变的</strong>，这样key对应的<code>hashcode()</code>值可以被缓存起来，性能更好，这也是为什么string特别适合作为HashMap 的key 。</li></ol>
<h2><a id="28Queue__Deque__476"></a>28.说一下Queue 与 Deque 的区别？</h2>
<p><code>Queue</code> 是<strong>单端队列</strong>，只能从一端插入元素，另一端删除元素，实现上一般遵循 <strong>先进先出（FIFO）</strong> 规则。Queue 扩展了 <code>Collection</code> 的接口，根据 <strong>因为容量问题而导致操作失败后处理方式的不同</strong> 可以分为两类方法: 一种在操作失败后会抛出异常，另一种则会返回特殊值。</p>
<table><thead><tr><th>Queue 接口</th><th>抛出异常</th><th>返回特殊值</th></tr></thead><tbody><tr><td>插入队尾</td><td>add(E e)</td><td>offer(E e)</td></tr><tr><td>删除队首</td><td>remove()</td><td>poll()</td></tr><tr><td>查询队首元素</td><td>element()</td><td>peek()</td></tr></tbody></table>
<p><code>Deque</code> 是<strong>双端队列</strong>，在队列的两端均可以插入或删除元素。Deque 扩展了 <code>Queue</code> 的接口, 增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类：</p>
<table><thead><tr><th>Deque 接口</th><th>抛出异常</th><th>返回特殊值</th></tr></thead><tbody><tr><td>插入队首</td><td>addFirst(E e)</td><td>offerFirst(E e)</td></tr><tr><td>插入队尾</td><td>addLast(E e)</td><td>offerLast(E e)</td></tr><tr><td>删除队首</td><td>removeFirst()</td><td>pollFirst()</td></tr><tr><td>删除队尾</td><td>removeLast()</td><td>pollLast()</td></tr><tr><td>查询队首元素</td><td>getFirst()</td><td>peekFirst()</td></tr><tr><td>查询队尾元素</td><td>getLast()</td><td>peekLast()</td></tr></tbody></table>
<p>除此之外。<code>Deque</code> 还提供有 <code>push()</code> 和 <code>pop()</code> 等其他方法，可用于模拟栈。</p>
<h2><a id="29ArrayDeque__LinkedList__499"></a>29.说说ArrayDeque 与 LinkedList 的区别？</h2>
<p><code>ArrayDeque</code> 和 <code>LinkedList</code> 都实现了 <code>Deque</code> 接口，两者都具有队列的功能，也都可以实现栈。连着区别：</p>
<ul><li>ArrayDeque 是基于<strong>可变长的数组和双指针</strong>来实现，而 LinkedList 则通过<strong>链表</strong>来实现。</li><li>ArrayDeque 不支持存储 <code>NULL</code> 数据，但 LinkedList 支持。</li><li>ArrayDeque 是在 <code>JDK1.6</code> 才被引入的，而LinkedList 早在 <code>JDK1.2</code> 时就已经存在。</li><li>ArrayDeque 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 LinkedList 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</li></ul>
<p>从性能的角度上，选用 <code>ArrayDeque</code> 来实现队列要比 <code>LinkedList</code> 更好。</p>
<blockquote>
<p>ArrayDeque 源码可以参考：<a href="https://blog.csdn.net/qq_45966440/article/details/122273524?spm=1001.2014.3001.5501">【JDK源码】ArrayDeque源码分析</a></p>
<p>LinkedList 源码可以参考：<a href="https://blog.csdn.net/qq_45966440/article/details/122270999?spm=1001.2014.3001.5501">【JDK源码】LinkedList源码分析</a></p>
</blockquote>
<h2><a id="30_HashSetLinkedHashSet__TreeSet__514"></a>30.说一下 HashSet、LinkedHashSet 和 TreeSet 三者的异同？</h2>
<p><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 都是 <code>Set</code> 接口的实现类，<strong>都能保证元素唯一，并且都不是线程安全的</strong>。他们的不同点：</p>
<ul><li>HashSet、LinkedHashSet 和 TreeSet 的主要区别在于底层数据结构不同： 
  <ol><li><code>HashSet</code> 的底层数据结构是<strong>哈希表</strong>（基于 <code>HashMap</code> 实现）</li><li><code>LinkedHashSet</code> 的底层数据结构是<strong>链表和哈希表</strong>，元素的插入和取出顺序满足 FIFO</li><li><code>TreeSet</code> 底层数据结构是<strong>红黑树</strong>，元素是有序的，排序的方式有自然排序和定制排序</li></ol> </li><li>底层数据结构不同又导致这三者的应用场景不同： 
  <ol><li><code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景</li><li><code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景</li><li><code>TreeSet</code> 用于支持对元素自定义排序规则的场景</li></ol> </li></ul>
<blockquote>
<p><font color="red">参考文章：</font></p>
<ul><li>https://blog.csdn.net/qq_45966440/category_10889559.html</li><li>https://blog.csdn.net/weixin_43591980/category_10638797.html?spm=1001.2014.3001.5515</li><li>https://javaguide.cn/java/basis/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</li><li>https://pdai.tech/</li></ul>
</blockquote>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/224fa0aafe3640b085f3a9d518bc9684.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATEwuTEVCUk9O,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
</div>
<link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css" rel="stylesheet"/>
<link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css" rel="stylesheet"/>
</div>