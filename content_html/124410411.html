<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<p id="main-toc"><strong>目录</strong></p>
<p id="-toc" style="margin-left:40px;"></p>
<p id="%E5%9F%BA%E6%9C%AC%E6%A6%82%E8%A6%81%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E8%A6%81%EF%BC%9A">基本概要：</a></p>
<p id="1.%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%EF%BC%88Bubble%20Sort%EF%BC%89-toc" style="margin-left:40px;"><a href="#1.%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%EF%BC%88Bubble%20Sort%EF%BC%89">1.冒泡排序（Bubble Sort）</a></p>
<p id="%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%EF%BC%9A">基本思想：</a></p>
<p id="%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A">代码实现：</a></p>
<p id="2.%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%EF%BC%88Quick%20Sort%EF%BC%89-toc" style="margin-left:40px;"><a href="#2.%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%EF%BC%88Quick%20Sort%EF%BC%89">2.快速排序（Quick Sort）</a></p>
<p id="%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%EF%BC%9A">基本思想：</a></p>
<p id="%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A">代码实现：</a></p>
<p id="3.%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%88Insertion%20Sort%EF%BC%89-toc" style="margin-left:40px;"><a href="#3.%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%88Insertion%20Sort%EF%BC%89">3.插入排序（Insertion Sort）</a></p>
<p id="%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%EF%BC%9A">基本思想：</a></p>
<p id="%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A">代码实现：</a></p>
<p id="4.%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%EF%BC%88Simple%20Selection%20Sort%EF%BC%89-toc" style="margin-left:40px;"><a href="#4.%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%EF%BC%88Simple%20Selection%20Sort%EF%BC%89">4.简单选择排序（Simple Selection Sort）</a></p>
<p id="%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%EF%BC%9A">基本思想：</a></p>
<p id="%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A">代码实现：</a></p>
<p id="5.%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%EF%BC%88Shell%20Sort%EF%BC%89-toc" style="margin-left:40px;"><a href="#5.%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%EF%BC%88Shell%20Sort%EF%BC%89">5.希尔排序（Shell Sort）</a></p>
<p id="%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%EF%BC%9A">基本思想：</a></p>
<p id="%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A">代码实现：</a></p>
<hr id="hr-toc"/>
<p></p>
<h2 id="%E5%9F%BA%E6%9C%AC%E6%A6%82%E8%A6%81%EF%BC%9A">基本概要：</h2>
<p>本文主要介绍五种简单常用的排序算法：<span style="background-color:#f9eda6;">冒泡排序，快速排序，插入排序，选择排序，希尔排序</span>。包括它们的基本思想和代码实现。值得一说的是：插入排序，冒泡排序，选择排序平均情况下的时间复杂度为<img alt="O\left ( n^{2} \right )" class="mathcode" src="https://latex.codecogs.com/gif.latex?O%5Cleft%20%28%20n%5E%7B2%7D%20%5Cright%20%29"/>，<strong>因此在排序数据较少的情况下较好</strong>；而希尔排序和快速排序的平均时间复杂度为<img alt="O\left ( nlogn \right )" class="mathcode" src="https://latex.codecogs.com/gif.latex?O%5Cleft%20%28%20nlogn%20%5Cright%20%29"/>，<strong>因此在排序数据较多的情况下较好，但是对于快速排序而言，数据基本有序时反而不好</strong>，接下来会详细阐述。（皆以从小到大的顺序排列）</p>
<h2 id="1.%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%EF%BC%88Bubble%20Sort%EF%BC%89">1.冒泡排序（Bubble Sort）</h2>
<h3 id="%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%EF%BC%9A">基本思想：</h3>
<p>冒泡排序是一个非常好理解的排序，顾名思义——冒泡，此时将要排序的数据从上至下排列，从最上面的数（第一个数据）开始对相邻的两个数据进行比较，<span style="background-color:#f9eda6;">较小的数据往上浮，较大的数据往下沉</span>，达到排序的效果。</p>
<p>（1）对每一对相邻的元素进行比较，若第一个比第二个大，则调换这两个元素的位置，依次两两比较直到数据的最后一对，此为一轮操作。</p>
<p>（2）重复n轮此操作（n为元素的个数），不过每轮结束后的最后一个元素不用参与下一轮的比较，因为经历一轮排序后，最后一个元素一定比前面所有的元素都要大。</p>
<p>（3）因此每一轮需要比较的元素都在减少，一直到没有数可比较为止。<span style="background-color:#f9eda6;">（不过为了减少比较次数，可以记录每轮是否有数据的交换，如果没有交换，表明当前数据已经按从小到大的顺序拍好了，可直接跳出循环）</span></p>
<h3 id="%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A">代码实现：</h3>
<pre><code class="language-cs">#include&lt;stdio.h&gt;

int main() {
	int n, m, i, j, temp;
	int arr[100];

	scanf_s("%d", &amp;n);    //scnaf_s是更为安全的输入方式；n为元素的个数；
	for (i = 0; i &lt; n; i++) {
		scanf_s("%d", &amp;arr[i]);    //输入数据；
	}

	m = n;            //因为每进行一次第一轮循环，需要排序的数据都要“--”，因此定义变量m=n；
	for (i = 0; i &lt; n; i++) {
		int exchange = 0;           //记录这一轮会不会有数据的交换；
		for (j = 0; j &lt; m-1; j++) {
			if (arr[j] &gt; arr[j + 1]) {
				temp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = temp;
				exchange = 1;
			}
		}
		m--;
		if (!exchange)  //若没有数据的交换，则数据已经排列完毕，跳出循环；
			break;
	}
	for (i = 0; i &lt; n; i++) {
		printf("%d ", arr[i]);        //输出
	}

	return 0;

}</code></pre>
<h2 id="2.%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%EF%BC%88Quick%20Sort%EF%BC%89">2.快速排序（Quick Sort）</h2>
<p>快速排序是这五类中平均性能最优的排序算法，其中运用了<span style="background-color:#f9eda6;">分治</span>的思想，并且调用了<span style="background-color:#f9eda6;">递归函数</span>，因此也是这五类中最难的一个。</p>
<h3>基本思想：</h3>
<p>快速排序的重点在于找一个基准值，将数列分为两部分——大于基准值的放在右边，小于基准值的 放在左边。然后分别对这两部分重复次操作，一分为二，二分为四······直到每个元素自成一部分。</p>
<p>1.将数据的中间元素设为基准值，初始化令 <img alt="i" class="mathcode" src="https://latex.codecogs.com/gif.latex?i"/> 指向最左边个元素，令 <img alt="j" class="mathcode" src="https://latex.codecogs.com/gif.latex?j"/> 指向最右边个元素，通过<img alt="i++" class="mathcode" src="https://latex.codecogs.com/gif.latex?i&amp;plus;&amp;plus;"/>从左往右找一个大于基准数的数，通过<img alt="j--" class="mathcode" src="https://latex.codecogs.com/gif.latex?j--"/>从右往左找一个小于基准数的数，交换两数的位置，直到<img alt="i=j" class="mathcode" src="https://latex.codecogs.com/gif.latex?i%3Dj"/>。</p>
<p>2.如此不断的细分递归，达到排序的目的</p>
<h3>代码实现：</h3>
<pre><code class="language-cs">#include&lt;stdio.h&gt;

void Quicksort(int a[], int left, int right) {   //快排函数
	int temp;
	int mid = a[(left + right) / 2];            //找基准值
	int i = left;
	int j = right;
//在左侧找一个大于基准值的数，在右侧找一个小于基准数的数，然后交换位置
	while (i &lt;= j) {   
		while (a[i] &lt; mid) i++;
		while (a[j] &gt; mid) j--;
		if (i &lt;= j) {
			temp = a[i];
			a[i] = a[j];
			a[j] = temp;
			i++;
			j--;
		}
	}
	if (i &lt; right) Quicksort(a, i, right);        //递归
	if (j &gt; left) Quicksort(a, left, j);           //递归
}

int main() {
	int n, m, i;
	int arr[100];
	scanf_s("%d", &amp;n);
	for (i = 0; i &lt; n; i++) {
		scanf_s("%d", &amp;arr[i]);						//输入
	}

	Quicksort(arr, 0, n - 1);                        //调用函数

	for (i = 0; i &lt; n; i++) {
		printf("%d ", arr[i]);						//输出
	}
	return 0;
}</code></pre>
<h2 id="3.%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%88Insertion%20Sort%EF%BC%89">3.插入排序（Insertion Sort）</h2>
<h3>基本思想：</h3>
<p>将数据分为两组——<span style="background-color:#f9eda6;">一组是有序的，一组是无序的</span>，将无序数据中的元素依次插入到有序数据中，从而将整个数据变为有序的（这里的分组是<span style="background-color:#f9eda6;">潜意识</span>的，实际上并不会用两个数组来分）</p>
<p>1.初始时，将第一个元素分为有序组（因为只有一个元素，所以认为它是排好序的），其余元素分为无序组</p>
<p>2.因此只需从第二个元素开始，依次在有序组中找到自己的位置，插入即可，直到最后一个元素。</p>
<p>3.但这并不意味着只需要一次循环，因为在“找自己的位置”的过程中，需要将自己与前面的元素相比较，若是自己较小，则将那个元素后移一位；若是自己较大，则将自己插入到上一次比较的位置</p>
<h3>代码实现：</h3>
<pre><code class="language-cs">#include&lt;stdio.h&gt;

int main() {
	int n, m, i, j, temp;
	int arr[100];

	scanf_s("%d", &amp;n);
	for (i = 0; i &lt; n; i++) {
		scanf_s("%d", &amp;arr[i]);						//输入 
	}
    for(i=1; i&lt;n; i++)								//从无序组的第一个元素开始 
        if(arr[i] &lt; arr[i-1])   						// 判断是否要向前寻找插入的位置 
        {
            int temp = arr[i];                       
            for(j=i-1; j&gt;=0 &amp;&amp; arr[j]&gt;temp; j--)    //将大于自己的数依次向后挪位 
                arr[j+1] = arr[j];                    
            arr[j+1] = temp;                       //插入 
        }
	for (i = 0; i &lt; n; i++) {
		printf("%d ", arr[i]);						//输出 
	}
	return 0;
}</code></pre>
<h2 id="4.%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%EF%BC%88Simple%20Selection%20Sort%EF%BC%89">4.简单选择排序（Simple Selection Sort）</h2>
<h3>基本思想：</h3>
<p>设一个数据集有n个元素，选择这n个元素中最小的一个与第一个元素交换位置，再在剩下的n-1个元素中选择最小的一个与第二个元素交换位置，直到在最后两个元素中选择最小的一个放在倒数第二的位置上，排序完成。</p>
<pre><code class="language-cs">#include&lt;stdio.h&gt;

int main() {
	int n, m, i, j, p, temp;
	int arr[100];

	scanf_s("%d", &amp;n);
	for (i = 0; i &lt; n; i++) {
		scanf_s("%d", &amp;arr[i]);						//输入 
	}

	for (i = 0; i &lt; n - 1; i++) {
		p = i;                            //p用于记录最小元素的下标
		for (j = i + 1; j &lt; n; j++) {       //找到剩下元素中最小的那一个
			if (arr[p] &gt; arr[j])
				p = j;
		}
		temp = arr[i];                        //temp是交换两数时的中间变量
		arr[i] = arr[p];
		arr[p] = temp;
	}
	for (i = 0; i &lt; n; i++) {
		printf("%d ", arr[i]);						//输出 
	}
	return 0;
}</code></pre>
<h3>代码实现：</h3>
<h2 id="5.%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%EF%BC%88Shell%20Sort%EF%BC%89">5.希尔排序（Shell Sort）</h2>
<p><span style="background-color:#f9eda6;">希尔排序是插入排序的优化</span>，它先将待排序列进行预排序，然后对次序列进行一次插入排序，不一样的是经过预处理之后的插入排序时间复杂度为<img alt="O\left ( n \right )" class="mathcode" src="https://latex.codecogs.com/gif.latex?O%5Cleft%20%28%20n%20%5Cright%20%29"/></p>
<h3>基本思想：</h3>
<p>定义一个间隔gap，在一组数据中，将相隔为gap的元素作为一个组，对组内元素执行简单的插入排序，然后不断缩小gap重复此操作，完成数据的预处理，直到gap=1，表示对所有数进行插入排序，算法终止。</p>
<p>1.初始化<img alt="gap=\frac{n}{2}" class="mathcode" src="https://latex.codecogs.com/gif.latex?gap%3D%5Cfrac%7Bn%7D%7B2%7D"/>（n为元素个数），将数据中所有距离为gap的元素分在一组（此时这组数据会被分成<img alt="\frac{n}{2}" class="mathcode" src="https://latex.codecogs.com/gif.latex?%5Cfrac%7Bn%7D%7B2%7D"/>个组，每组有两个元素，对每个组进行排序）</p>
<p>2.接着缩小gap至<img alt="\frac{n}{4}" class="mathcode" src="https://latex.codecogs.com/gif.latex?%5Cfrac%7Bn%7D%7B4%7D"/>，将数据中所有距离为gap的元素分在一组（此时这组数据会被分成<img alt="\frac{n}{4}" class="mathcode" src="https://latex.codecogs.com/gif.latex?%5Cfrac%7Bn%7D%7B4%7D"/>个组，每组有四个元素，对每个组进行排序）</p>
<p>3.重复直到gap=1，此时数据为一组，有n个元素，简单插入排序即可。</p>
<p></p>
<h3>代码实现：</h3>
<pre><code class="language-cs">#include&lt;stdio.h&gt;

int main() {
	int n, m, i, j, temp,gap;
	int arr[100];

	scanf("%d", &amp;n);
	for (i = 0; i &lt; n; i++) {
		scanf("%d", &amp;arr[i]);						//输入
	}

    for(gap=n/2; gap&gt;0; gap/=2)
        for(i=gap; i&lt;n; i++)
            for(j=i-gap; j&gt;=0 &amp;&amp; arr[j]&gt;arr[j+gap]; j-=gap){
            	temp=arr[j];
            	arr[j]=arr[j+gap];
            	arr[j+gap]=temp;
			}
	for (i = 0; i &lt; n; i++) {
		printf("%d ", arr[i]);						//输出
	}
	return 0;
}</code></pre>
<p><strong>小白文一篇</strong></p>
</div>
</div>