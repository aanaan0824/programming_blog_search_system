<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<p id="main-toc"><strong>目录</strong></p>
<p id="%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFMybatisPlus-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFMybatisPlus">一、什么是MybatisPlus</a></p>
<p id="%E4%BA%8C%E3%80%81%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8">二、快速入门</a></p>
<p id="1%E3%80%81%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93mybatis_plus-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93mybatis_plus">2.1、创建数据库mybatis_plus</a></p>
<p id="2%E3%80%81%E5%88%9B%E5%BB%BAuser%E8%A1%A8-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E5%88%9B%E5%BB%BAuser%E8%A1%A8">2.2、创建user表</a></p>
<p id="3%E3%80%81%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE">2.3、插入数据</a></p>
<p id="4%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B9%E7%9B%AE-toc" style="margin-left:40px;"><a href="#4%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B9%E7%9B%AE">2.4、初始化项目</a></p>
<p id="5%E3%80%81%E6%B7%BB%E5%8A%A0%E4%BE%9D%E8%B5%96-toc" style="margin-left:40px;"><a href="#5%E3%80%81%E6%B7%BB%E5%8A%A0%E4%BE%9D%E8%B5%96">2.5、添加依赖</a></p>
<p id="6%E3%80%81%E9%85%8D%E7%BD%AE(%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93)-toc" style="margin-left:40px;"><a href="#6%E3%80%81%E9%85%8D%E7%BD%AE%28%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%29">2.6、配置(连接数据库)</a></p>
<p id="7%E3%80%81%E7%BC%96%E7%A0%81-toc" style="margin-left:40px;"><a href="#7%E3%80%81%E7%BC%96%E7%A0%81">2.7、编码</a></p>
<p id="8%E3%80%81%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px;"><a href="#8%E3%80%81%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8">2.8、开始使用</a></p>
<p id="9%E3%80%81%E5%B0%8F%E7%BB%93-toc" style="margin-left:40px;"><a href="#9%E3%80%81%E5%B0%8F%E7%BB%93">2.9、小结</a></p>
<p id="%E4%B8%89%E3%80%81%E9%85%8D%E7%BD%AE%E6%97%A5%E5%BF%97-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E9%85%8D%E7%BD%AE%E6%97%A5%E5%BF%97">三、配置日志</a></p>
<p id="%E2%80%8B-toc" style="margin-left:0px;"><a href="#%E2%80%8B">​</a></p>
<p id="%E5%9B%9B%E3%80%81CRUD-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81CRUD">四、CRUD</a></p>
<p id="4.1%E3%80%81%E6%8F%92%E5%85%A5%E6%B5%8B%E8%AF%95-toc" style="margin-left:40px;"><a href="#4.1%E3%80%81%E6%8F%92%E5%85%A5%E6%B5%8B%E8%AF%95">4.1、插入测试</a></p>
<p id="4.2%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89ID%E7%94%9F%E6%88%90%E5%99%A8-toc" style="margin-left:40px;"><a href="#4.2%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89ID%E7%94%9F%E6%88%90%E5%99%A8">4.2、自定义ID生成器</a></p>
<p id="4.2.1%E3%80%81UUID-toc" style="margin-left:80px;"><a href="#4.2.1%E3%80%81UUID">4.2.1、UUID</a></p>
<p id="4.2.2%E3%80%81SnowFlake%EF%BC%88%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95%EF%BC%89-toc" style="margin-left:80px;"><a href="#4.2.2%E3%80%81SnowFlake%EF%BC%88%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95%EF%BC%89">4.2.2、SnowFlake（雪花算法）</a></p>
<p id="4.3%E3%80%81%E6%9B%B4%E6%96%B0%E6%93%8D%E4%BD%9C-toc" style="margin-left:40px;"><a href="#4.3%E3%80%81%E6%9B%B4%E6%96%B0%E6%93%8D%E4%BD%9C">4.3、更新操作</a></p>
<p id="%E4%BA%94%E3%80%81%E8%87%AA%E5%8A%A8%E5%A1%AB%E5%85%85-toc" style="margin-left:0px;"><a href="#%E4%BA%94%E3%80%81%E8%87%AA%E5%8A%A8%E5%A1%AB%E5%85%85">五、自动填充</a></p>
<p id="1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E8%87%AA%E5%8A%A8%E5%A1%AB%E5%85%85-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E8%87%AA%E5%8A%A8%E5%A1%AB%E5%85%85">5.1、什么是自动填充</a></p>
<p id="2%E3%80%81%E8%87%AA%E5%8A%A8%E5%A1%AB%E5%85%85%E6%96%B9%E5%BC%8F-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E8%87%AA%E5%8A%A8%E5%A1%AB%E5%85%85%E6%96%B9%E5%BC%8F">5.2、自动填充方式</a></p>
<p id="%E5%85%AD%E3%80%81%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81-toc" style="margin-left:0px;"><a href="#%E5%85%AD%E3%80%81%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81">六、乐观锁和悲观锁</a></p>
<p id="6.1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E4%B9%90%E8%A7%82%E9%94%81-toc" style="margin-left:40px;"><a href="#6.1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E4%B9%90%E8%A7%82%E9%94%81">6.1、什么是乐观锁</a></p>
<p id="6.2%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%82%B2%E8%A7%82%E9%94%81-toc" style="margin-left:40px;"><a href="#6.2%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%82%B2%E8%A7%82%E9%94%81">6.2、什么是悲观锁</a></p>
<p id="6.3%E3%80%81%E9%85%8D%E7%BD%AE%E4%B9%90%E8%A7%82%E9%94%81-toc" style="margin-left:40px;"><a href="#6.3%E3%80%81%E9%85%8D%E7%BD%AE%E4%B9%90%E8%A7%82%E9%94%81">6.3、配置乐观锁</a></p>
<p id="6.3.1%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%B7%BB%E5%8A%A0version%E5%AD%97%E6%AE%B5-toc" style="margin-left:80px;"><a href="#6.3.1%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%B7%BB%E5%8A%A0version%E5%AD%97%E6%AE%B5">6.3.1、数据库中添加version字段</a></p>
<p id="6.3.2%E3%80%81%E5%90%8C%E6%AD%A5%E5%AE%9E%E4%BD%93%E7%B1%BB-toc" style="margin-left:80px;"><a href="#6.3.2%E3%80%81%E5%90%8C%E6%AD%A5%E5%AE%9E%E4%BD%93%E7%B1%BB">6.3.2、同步实体类</a></p>
<p id="6.3.3%E3%80%81%E9%85%8D%E7%BD%AE%E6%8F%92%E4%BB%B6-toc" style="margin-left:80px;"><a href="#6.3.3%E3%80%81%E9%85%8D%E7%BD%AE%E6%8F%92%E4%BB%B6">6.3.3、配置插件</a></p>
<p id="6.3.4%E3%80%81%E6%B5%8B%E8%AF%95%E4%B9%90%E8%A7%82%E9%94%81-toc" style="margin-left:80px;"><a href="#6.3.4%E3%80%81%E6%B5%8B%E8%AF%95%E4%B9%90%E8%A7%82%E9%94%81">6.3.4、测试乐观锁</a></p>
<p id="%E4%B8%83%E3%80%81%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5-toc" style="margin-left:0px;"><a href="#%E4%B8%83%E3%80%81%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5">七、增删改查</a></p>
<p id="7.1%E3%80%81%E6%9F%A5%E8%AF%A2%E6%93%8D%E4%BD%9C-toc" style="margin-left:40px;"><a href="#7.1%E3%80%81%E6%9F%A5%E8%AF%A2%E6%93%8D%E4%BD%9C">7.1、查询操作</a></p>
<p id="7.2%E3%80%81%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2-toc" style="margin-left:40px;"><a href="#7.2%E3%80%81%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2">7.2、分页查询</a></p>
<p id="7.3%E3%80%81%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C-toc" style="margin-left:40px;"><a href="#7.3%E3%80%81%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C">7.3、删除操作</a></p>
<p id="7.4%E3%80%81%E9%80%BB%E8%BE%91%E5%88%A0%E9%99%A4-toc" style="margin-left:40px;"><a href="#7.4%E3%80%81%E9%80%BB%E8%BE%91%E5%88%A0%E9%99%A4">7.4、逻辑删除</a></p>
<p id="%E5%85%AB%E3%80%81%E6%89%A7%E8%A1%8CSQL%E5%88%86%E6%9E%90%E6%89%93%E5%8D%B0-toc" style="margin-left:0px;"><a href="#%E5%85%AB%E3%80%81%E6%89%A7%E8%A1%8CSQL%E5%88%86%E6%9E%90%E6%89%93%E5%8D%B0">八、执行SQL分析打印</a></p>
<p id="8.1%E3%80%81p6spy%E4%BE%9D%E8%B5%96%E5%BC%95%E5%85%A5-toc" style="margin-left:40px;"><a href="#8.1%E3%80%81p6spy%E4%BE%9D%E8%B5%96%E5%BC%95%E5%85%A5">8.1、p6spy依赖引入</a></p>
<p id="8.2%E3%80%81application.yml%E9%85%8D%E7%BD%AE-toc" style="margin-left:40px;"><a href="#8.2%E3%80%81application.yml%E9%85%8D%E7%BD%AE">8.2、application.yml配置</a></p>
<p id="8.3%E3%80%81spy.properties%E9%85%8D%E7%BD%AE-toc" style="margin-left:40px;"><a href="#8.3%E3%80%81spy.properties%E9%85%8D%E7%BD%AE">8.3、spy.properties配置</a></p>
<p id="8.4%E3%80%81%E6%B5%8B%E8%AF%95-toc" style="margin-left:40px;"><a href="#8.4%E3%80%81%E6%B5%8B%E8%AF%95">8.4、测试</a></p>
<p id="%E4%B9%9D%E3%80%81%E6%9D%A1%E4%BB%B6%E6%9E%84%E9%80%A0%E5%99%A8-toc" style="margin-left:0px;"><a href="#%E4%B9%9D%E3%80%81%E6%9D%A1%E4%BB%B6%E6%9E%84%E9%80%A0%E5%99%A8">九、条件构造器</a></p>
<p id="9.1%E3%80%81%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA-toc" style="margin-left:40px;"><a href="#9.1%E3%80%81%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA">9.1、代码演示</a></p>
<p id="%E5%8D%81%E3%80%81%E4%BB%A3%E7%A0%81%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E5%99%A8-toc" style="margin-left:0px;"><a href="#%E5%8D%81%E3%80%81%E4%BB%A3%E7%A0%81%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E5%99%A8">十、代码自动生成器</a></p>
<p id="10.1%E3%80%81EasyCode-toc" style="margin-left:40px;"><a href="#10.1%E3%80%81EasyCode">10.1、EasyCode</a></p>
<p id="10.2%E3%80%81%E5%8A%9F%E8%83%BD-toc" style="margin-left:40px;"><a href="#10.2%E3%80%81%E5%8A%9F%E8%83%BD">10.2、功能</a></p>
<p id="10.3%E3%80%81%E6%93%8D%E4%BD%9C-toc" style="margin-left:40px;"><a href="#10.3%E3%80%81%E6%93%8D%E4%BD%9C">10.3、操作</a></p>
<hr id="hr-toc"/>
<p></p>
<h1 id="%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFMybatisPlus">一、什么是MybatisPlus</h1>
<blockquote>
<p>为什么要学MybatisPlus？</p>
</blockquote>
<p>MybatisPlus可以节省大量时间，所有的CRUD代码都可以自动化完成</p>
<p>MyBatis-Plus是一个MyBatis的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。</p>
<p><strong>特性：</strong></p>
<ul><li> <p><strong>无侵入</strong>：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑</p> </li><li> <p><strong>损耗小</strong>：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作</p> </li><li> <p><strong>强大的 CRUD 操作</strong>：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求</p> </li><li> <p><strong>支持 Lambda 形式调用</strong>：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错</p> </li><li> <p><strong>支持主键自动生成</strong>：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题</p> </li><li> <p><strong>支持 ActiveRecord 模式</strong>：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作</p> </li><li> <p><strong>支持自定义全局通用操作</strong>：支持全局通用方法注入（ Write once, use anywhere ）</p> </li><li> <p><strong>内置代码生成器</strong>：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用</p> </li><li> <p><strong>内置分页插件</strong>：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询</p> </li><li> <p><strong>分页插件支持多种数据库</strong>：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库</p> </li><li> <p><strong>内置性能分析插件</strong>：可输出 SQL 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询</p> </li><li> <p><strong>内置全局拦截插件</strong>：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作</p> </li></ul>
<h1 id="%E4%BA%8C%E3%80%81%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8">二、快速入门</h1>
<h2 id="1%E3%80%81%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93mybatis_plus">2.1、创建数据库mybatis_plus</h2>
<h2 id="2%E3%80%81%E5%88%9B%E5%BB%BAuser%E8%A1%A8">2.2、创建user表</h2>
<pre><code class="language-sql">DROP TABLE IF EXISTS user;
​
CREATE TABLE user
(
    id BIGINT(20) NOT NULL COMMENT '主键ID',
    name VARCHAR(30) NULL DEFAULT NULL COMMENT '姓名',
    age INT(11) NULL DEFAULT NULL COMMENT '年龄',
    email VARCHAR(50) NULL DEFAULT NULL COMMENT '邮箱',
    PRIMARY KEY (id)
);</code></pre>
<h2 id="3%E3%80%81%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE">2.3、插入数据</h2>
<pre><code class="language-sql">DELETE FROM user;
​
INSERT INTO user (id, name, age, email) VALUES
(1, 'Jone', 18, 'test1@baomidou.com'),
(2, 'Jack', 20, 'test2@baomidou.com'),
(3, 'Tom', 28, 'test3@baomidou.com'),
(4, 'Sandy', 21, 'test4@baomidou.com'),
(5, 'Billie', 24, 'test5@baomidou.com');</code></pre>
<h2 id="4%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B9%E7%9B%AE">2.4、初始化项目</h2>
<p>快速初始化一个空的spring boot 项目</p>
<h2 id="5%E3%80%81%E6%B7%BB%E5%8A%A0%E4%BE%9D%E8%B5%96">2.5、添加依赖</h2>
<p>引用spring boot starter 父工程</p>
<pre><code class="language-XML">&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;2.6.5&lt;/version&gt;
    &lt;relativePath/&gt;
&lt;/parent&gt;</code></pre>
<p>引入spring-boot-starter、spring-boot-starter-test、mybatis-plus-boot-starter、h2依赖：</p>
<pre><code class="language-XML">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
        &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;
        &lt;version&gt;3.5.1&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre>
<p>注意：尽量不要同时导入mybatis和mybatis_plus,版本差异</p>
<h2 id="6%E3%80%81%E9%85%8D%E7%BD%AE(%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93)">2.6、配置(连接数据库)</h2>
<p>在application.yml配置文件中添加MySQL数据库的相关配置：</p>
<pre><code class="language-XML"># DataSource Config
spring:
  datasource:
    username: root
    password: 123456
    url: jdbc:mysql:///mybatis_plus?userUnicode=true&amp;characterEncoding=utf-8
    driver-class-name: com.mysql.cj.jdbc.Driver</code></pre>
<pre>​</pre>
<p>在spring boot启动类中添加@MapperScan注解，扫描Mapper文件夹：</p>
<pre><code class="language-java">@SpringBootApplication
@MapperScan("com.wen.mybatis_plus.mapper")  //扫描mapper
public class MybatisPlusApplication {
​
    public static void main(String[] args) {
        SpringApplication.run(MybatisPlusApplication.class, args);
    }
​
}</code></pre>
<h2 id="7%E3%80%81%E7%BC%96%E7%A0%81">2.7、编码</h2>
<p>编写实体类User.java（此处使用Lombok简化代码）</p>
<pre><code class="language-java">import lombok.Data;
​
@Data
public class User {
    private Long id;
    private String name;
    private Integer age;
    private String email;
}</code></pre>
<p>编写Mapper包下的UserMapper接口</p>
<pre><code class="language-java">import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.wen.mybatis_plus.pojo.User;
import org.apache.ibatis.annotations.Mapper;
​
//再对应的mapper上面实现基本的接口 BaseMapper
@Mapper
public interface UserMapper extends BaseMapper&lt;User&gt; {
    //所有的CRUD都已经完成
    //不需要像以前一样配置一大堆文件：pojo-dao（连接mybatis，配置mapper.xml文件）==&gt;service-controller
}</code></pre>
<blockquote>
<p><strong>注意：</strong></p>
<p><strong>要在主启动类上去扫描mapper包下的所有接口：@MapperScan("com.wen.mybatis_plus.mapper")</strong></p>
</blockquote>
<h2 id="8%E3%80%81%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8">2.8、开始使用</h2>
<p>添加测试类，进行功能测试：</p>
<pre><code class="language-java">@SpringBootTest
class MybatisPlusApplicationTests {
​
    //继承了BaseMapper所有的方法，可以编写自己的扩展方法
    @Autowired
    private UserMapper userMapper;
​
    @Test
    public void testSelect(){
        System.out.println("--------selectAll method test-------");
        //查询全部用户，参数是一个Wrapper，条件构造器，先不使用为null
        List&lt;User&gt; userList = userMapper.selectList(null);
        userList.forEach(System.out::println);
    }</code></pre>
<blockquote>
<p><strong>提示：</strong></p>
<p><strong>UserMapper中的selectList()方法的参数为MP内置的条件封装器Wrapper，所以不填写就是无任何条件</strong>。</p>
</blockquote>
<p>控制台输出：</p>
<p>User(id=1, name=Jone, age=18, email=<a href="mailto:test1@baomidou.com">test1@baomidou.com</a>) User(id=2, name=Jack, age=20, email=<a href="mailto:test2@baomidou.com">test2@baomidou.com</a>) User(id=3, name=Tom, age=28, email=<a href="mailto:test3@baomidou.com">test3@baomidou.com</a>) User(id=4, name=Sandy, age=21, email=<a href="mailto:test4@baomidou.com">test4@baomidou.com</a>) User(id=5, name=Billie, age=24, email=<a href="mailto:test5@baomidou.com">test5@baomidou.com</a>)</p>
<h2 id="9%E3%80%81%E5%B0%8F%E7%BB%93">2.9、小结</h2>
<p>以上几个步骤就已经实现User表的CRUD功能，甚至连XML文件都不用编写，以上步骤可以看出集成MyBatis-Plus非常的简单，只需要引入starter工程，并配置mapper扫描路径即可。方法都是MyBatis-Plus写好的，直接引用即可。</p>
<h1 id="%E4%B8%89%E3%80%81%E9%85%8D%E7%BD%AE%E6%97%A5%E5%BF%97">三、配置日志</h1>
<blockquote>
<p>所有的SQL都是不可见的，所以在后台是希望看到SQL是怎么执行的，就必须要配置日志。</p>
</blockquote>
<p>在.yml配置文件中配置日志：</p>
<pre><code class="language-XML">#配置日志
mybatis-plus:
  configuration:
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl</code></pre>
<p></p>
<h1 id="%E2%80%8B"><img alt="" height="333" src="image\806ff53d97dc4a148112068243e834e6.png" width="840"/></h1>
<p></p>
<h1 id="%E5%9B%9B%E3%80%81CRUD">四、CRUD</h1>
<h2 id="4.1%E3%80%81%E6%8F%92%E5%85%A5%E6%B5%8B%E8%AF%95">4.1、插入测试</h2>
<pre><code class="language-java">//测试插入
@Test
public void testInsert(){
    User user = new User();
    user.setName("小文");
    user.setAge(21);
    user.setEmail("2312103645@qq.com");
​
    int insert = userMapper.insert(user);//如果没有设置id，那么会自动生成id
    System.out.println(insert);//受影响行数
    System.out.println(user);//id会自动回填
}</code></pre>
<p> <img alt="" height="231" src="image\1cc5dce6bf354dd88290d5c6b6d6734f.png" width="1135"/></p>
<p></p>
<p></p>
<blockquote>
<p>数据库插入ID默认值为全局唯一ID</p>
</blockquote>
<h2 id="4.2%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89ID%E7%94%9F%E6%88%90%E5%99%A8">4.2、自定义ID生成器</h2>
<p>在复杂分布式系统中，往往需要大量的数据和消息进行唯一标识。比如支付宝每一个账号在数据库分表后都需要有一个<strong>唯一</strong>ID做标识。此时一个能够生成全局唯一ID的系统是非常必要的。</p>
<p>所以，生成的ID需要具备一下特点：</p>
<ol><li> <p>全局唯一性：不能出现重复的ID号，既然是唯一标识，这是最基本的要求。</p> </li><li> <p>趋势递增：在MySQL InnoDB引擎中使用的是聚集索引，由于多数RDBMS使用B-tree的数据结构来存储索引数据，在主键的选择上面我们应该尽量使用有序的主键保证写入性能。</p> </li><li> <p>单调递增：保证下一个ID一定大于上一个ID，例如事务版本号、IM增量消息、排序等特殊需求。</p> </li><li> <p>信息安全：如果ID是连续的，恶意用户的扒取工作就非常容易做了，直接按照顺序下载指定URL即可；如果是订单号就更危险了，竞对可以直接知道我们一天的单量。所以在一些应用场景下，会需要ID无规则、不规则。</p> </li></ol>
<blockquote>
<p>上述123对应三类不同的场景，3和4需求还是互斥的，无法使用同一个方案满足。</p>
</blockquote>
<blockquote>
<p>在这里只讲两种自动生成ID的方案UUID和SnowFlake</p>
</blockquote>
<p>可以查看有哪些方法，查看源码：</p>
<p>在用户ID上添加@TableId注解，里面的值便是使用主键自动生成的方法</p>
<blockquote>
<p>自 3.3.0 开始,默认使用雪花算法+UUID(不含中划线)</p>
</blockquote>
<pre><code class="language-java">@Data
public class User {
    //对应数据库中的主键（UUID、自增id、雪花算法、redis、zookeeper）
    @TableId(type = IdType.ASSIGN_ID)
    private Long id;
    private String name;
    private Integer age;
    private String email;
}</code></pre>
<blockquote>
<p>点击 IdType查看源码看有哪些自动生成方法</p>
</blockquote>
<pre><code class="language-java">/**
 * 生成ID类型枚举类
 *
 * @author hubin
 * @since 2015-11-10
 */
@Getter
public enum IdType {
    /**
     * 数据库ID自增
     * &lt;p&gt;该类型请确保数据库设置了 ID自增 否则无效&lt;/p&gt;
     */
    AUTO(0),
    /**
     * 该类型为未设置主键类型(注解里等于跟随全局,全局里约等于 INPUT)
     */
    NONE(1),
    /**
     * 用户输入ID
     * &lt;p&gt;该类型可以通过自己注册自动填充插件进行填充&lt;/p&gt;
     */
    INPUT(2),
​
    /* 以下3种类型、只有当插入对象ID 为空，才自动填充。 */
    /**
     * 分配ID (主键类型为number或string）,
     * 默认实现类 {@link com.baomidou.mybatisplus.core.incrementer.DefaultIdentifierGenerator}(雪花算法)
     *
     * @since 3.3.0
     */
    ASSIGN_ID(3),
    /**
     * 分配UUID (主键类型为 string)
     * 默认实现类 {@link com.baomidou.mybatisplus.core.incrementer.DefaultIdentifierGenerator}(UUID.replace("-",""))
     */
    ASSIGN_UUID(4);
​
    private final int key;
​
    IdType(int key) {
        this.key = key;
    }
}   </code></pre>
<h3 id="4.2.1%E3%80%81UUID">4.2.1、UUID</h3>
<p>UUID(Universally Unique Identifier)的标准型式包含32个16进制数字，以连字号分为五段，形式为8-4-4-4-12的36个字符，示例：<code>550e8400-e29b-41d4-a716-446655440000</code>，到目前为止业界一共有5种方式生成UUID，详情见IETF发布的UUID规范 <a href="http://www.ietf.org/rfc/rfc4122.txt" title="A Universally Unique IDentifier (UUID) URN Namespace">A Universally Unique IDentifier (UUID) URN Namespace</a>。</p>
<p>优点：</p>
<ul><li> <p>性能非常高：本地生成，没有网络消耗。</p> </li></ul>
<p>缺点：</p>
<ul><li> <p>没有排序，无法保证趋势递增。</p> </li><li> <p>UUID往往使用字符串存储，查询的效率比较低。</p> </li><li> <p>不易于存储：UUID太长，16字节128位，通常以36长度的字符串表示，很多场景不适用。</p> </li><li> <p>信息不安全：基于MAC地址生成UUID的算法可能会造成MAC地址泄露，这个漏洞曾被用于寻找梅丽莎病毒的制作者位置。</p> </li><li> <p>ID作为主键时在特定的环境会存在一些问题，比如做DB主键的场景下，UUID就非常不适用：</p>
<ul><li> <p>MySQL官方有明确的建议主键要尽量越短越好[4]，36个字符长度的UUID不符合要求。</p> </li><li> <p>对MySQL索引不利：如果作为数据库主键，在InnoDB引擎下，UUID的无序性可能会引起数据位置频繁变动，严重影响性能。</p> </li></ul></li></ul>
<h3 id="4.2.2%E3%80%81SnowFlake%EF%BC%88%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95%EF%BC%89">4.2.2、SnowFlake（雪花算法）</h3>
<p>这种方案大致来说是一种以划分命名空间（UUID也算，由于比较常见，所以单独分析）来生成ID的一种算法，这种方案把64-bit分别划分成多段，分开来标示机器、时间等，比如在snowflake中的64-bit分别表示如下图（图片来自网络）所示：</p>
<p><img alt="" height="149" src="image\a57dd106bc1a4f68bbb48aff6974c358.png" width="645"/></p>
<p></p>
<p></p>
<p>41-bit的时间可以表示（1L&lt;&lt;41）/(1000L<em>3600</em>24*365)=69年的时间，10-bit机器可以分别表示1024台机器。如果我们对IDC划分有需求，还可以将10-bit分5-bit给IDC，分5-bit给工作机器。这样就可以表示32个IDC，每个IDC下可以有32台机器，可以根据自身需求定义。12个自增序列号可以表示2^12个ID，理论上snowflake方案的QPS约为409.6w/s，这种分配方式可以保证在任何一个IDC的任何一台机器在任意毫秒内生成的ID都是不同的。</p>
<blockquote>
<p>核心思想：</p>
<p>使用41bit作为毫秒数，10bit作为机器的ID(5个bit是数据中心，5个bit的机器ID)，12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生4096个ID），最后还有一个符号位，永远是0,。</p>
</blockquote>
<p>优点：</p>
<ul><li> <p>毫秒数在高位，自增序列在低位，整个ID都是趋势递增的。</p> </li><li> <p>不依赖数据库等第三方系统，以服务的方式部署，稳定性更高，生成ID的性能也是非常高的。</p> </li><li> <p>可以根据自身业务特性分配bit位，非常灵活。</p> </li></ul>
<p>缺点：</p>
<ul><li> <p>强依赖机器时钟，如果机器上时钟回拨，会导致发号重复或者服务会处于不可用状态。</p> </li></ul>
<h2 id="4.3%E3%80%81%E6%9B%B4%E6%96%B0%E6%93%8D%E4%BD%9C">4.3、更新操作</h2>
<blockquote>
<p>所有的SQL都是自动配置的</p>
</blockquote>
<pre><code class="language-java">//测试更新
@Test
public void testUpdate(){
    User user = new User();
    //可以通过条件自动拼接动态SQL
    user.setId(5L);
    user.setName("id:5,修改过后");
    //updateById 参数是一个对象！
    int i = userMapper.updateById(user);
    System.out.println(i);
}</code></pre>
<blockquote>
<p>注意：updateById 参数是一个对象！而不是ID</p>
</blockquote>
<p><img alt="" height="188" src="image\5a1e2b3cef424b3b9f8c6b62164e0e14.png" width="360"/></p>
<p></p>
<p></p>
<p><img alt="" height="86" src="image\658d373b8b4b4496b62779065b43dfe6.png" width="1086"/></p>
<p> <img alt="" height="154" src="image\b2fe11e128064f2ca1399cebcc31145b.png" width="665"/></p>
<p></p>
<p></p>
<h1 id="%E4%BA%94%E3%80%81%E8%87%AA%E5%8A%A8%E5%A1%AB%E5%85%85">五、自动填充</h1>
<h2 id="1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E8%87%AA%E5%8A%A8%E5%A1%AB%E5%85%85">5.1、什么是自动填充</h2>
<p>在常用业务中有些属性需要配置一些默认值，MyBatis-Plus提供了实现此功能的插件,也就是自动填充功能。比如创建时间、修改时间这些操作一般都是自动化完成的，是不用去手动更新的。</p>
<h2 id="2%E3%80%81%E8%87%AA%E5%8A%A8%E5%A1%AB%E5%85%85%E6%96%B9%E5%BC%8F">5.2、自动填充方式</h2>
<blockquote>
<p><strong>方式一：数据库级别（不建议使用）</strong></p>
</blockquote>
<p>1、在表中新增字段create_time,update_time</p>
<p><img alt="" height="445" src="image\9f83655dbea24312829ce17e7a9dfb3c.png" width="861"/></p>
<p></p>
<p></p>
<blockquote>
<p>注意：在create_time里除了没有勾选根据当前时间戳更新外其他步骤都一样！</p>
</blockquote>
<p>2、在此测试插入方法，需要将实体类同步！！</p>
<pre><code class="language-java">private Data createTime;
private Data updateTime;</code></pre>
<p>3、在此更新查看</p>
<pre><code class="language-java">//测试更新
@Test
public void testUpdate(){
    User user = new User();
    //可以通过条件自动拼接动态SQL
    user.setId(5l);
    user.setName("id:5,修改过后");
    user.setAge(25);
    //updateById 参数是一个对象！
    int i = userMapper.updateById(user);
    System.out.println(i);
}</code></pre>
<p>4、查看时间戳是否更新</p>
<p><img alt="" height="206" src="image\4c4ce5cfa40b47ef975b2a2101b47fe8.png" width="1113"/></p>
<p></p>
<p></p>
<blockquote>
<p><strong>方式二：代码级别</strong> </p>
</blockquote>
<p>1、删除数据库的默认值，更新操作</p>
<p><img alt="" height="438" src="image\b7ffb03b31ae46e6b818e826993d0d5a.png" width="847"/></p>
<p></p>
<p></p>
<p>2、注解填充字段 <code>@TableField(.. fill = FieldFill.INSERT)</code> 生成器策略部分也可以配置！</p>
<pre><code class="language-java">//注解填充字段 @TableField(.. fill = FieldFill.INSERT) 生成器策略部分也可以配置！
@TableField(fill = FieldFill.INSERT)
private Data createTime;
@TableField(fill = FieldFill.INSERT_UPDATE)
private Data updateTime;</code></pre>
<p>3、自定义实现类 MyMetaObjectHandler 处理这个注解</p>
<p><img alt="" height="173" src="image\a2b678b5a0e040e19cd882203bc6b430.png" width="210"/></p>
<p></p>
<p></p>
<pre><code class="language-java">@Slf4j
@Component
public class MyMetaObjectHandler implements MetaObjectHandler {
    //插入时的填充策略
    @Override
    public void insertFill(MetaObject metaObject) {
        log.info("start intsert fill ....");
        //strictInsertFill(MetaObject metaObject, String fieldName, Class&lt;T&gt; fieldType, E fieldVal)
        this.strictInsertFill(metaObject,"createTime", LocalDateTime.class,LocalDateTime.now());// 起始版本 3.3.0(推荐使用)
    }
​
    //更新时的填充策略
    @Override
    public void updateFill(MetaObject metaObject) {
        log.info("start update fill ....");
        this.strictUpdateFill(metaObject, "updateTime", LocalDateTime.class, LocalDateTime.now()); // 起始版本 3.3.0(推荐)
    }
}</code></pre>
<h1 id="%E5%85%AD%E3%80%81%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81">六、乐观锁和悲观锁</h1>
<h2 id="6.1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E4%B9%90%E8%A7%82%E9%94%81">6.1、什么是乐观锁</h2>
<blockquote>
<p>乐观锁：十分乐观，认为不会出现问题，无论干什么都不会去上锁，如果出现问题，就再次更新测试值</p>
</blockquote>
<p>乐观锁是对于数据冲突保持一种乐观态度，操作数据时不会对操作的数据进行加锁（这使得多个任务可以并行的对数据进行操作），只有到数据提交的时候才通过一种机制来验证数据是否存在冲突(一般实现方式是通过加版本号然后进行版本号的对比方式实现);</p>
<p>特点：乐观锁是一种并发类型的锁，其本身不对数据进行加锁而是通过业务实现锁的功能，不对数据进行加锁就意味着允许多个请求同时访问数据，同时也省掉了对数据加锁和解锁的过程，这种方式因为节省了悲观锁加锁的操作，所以可以一定程度的的提高操作的性能，不过在并发非常高的情况下，会导致大量的请求冲突，冲突导致大部分操作无功而返而浪费资源，所以在高并发的场景下，乐观锁的性能却反而不如悲观锁。</p>
<h2 id="6.2%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%82%B2%E8%A7%82%E9%94%81">6.2、什么是悲观锁</h2>
<blockquote>
<p>悲观锁：十分悲观，认为总是出现问题，无论干什么都会上锁，再去操作</p>
</blockquote>
<p>悲观锁是基于一种悲观的态度类来防止一切数据冲突，它是以一种预防的姿态在修改数据之前把数据锁住，然后再对数据进行读写，在它释放锁之前任何人都不能对其数据进行操作，直到前面一个人把锁释放后下一个人数据加锁才可对数据进行加锁，然后才可以对数据进行操作，一般数据库本身锁的机制都是基于悲观锁的机制实现的;</p>
<p>特点：可以完全保证数据的独占性和正确性，因为每次请求都会先对数据进行加锁， 然后进行数据操作，最后再解锁，而加锁释放锁的过程会造成消耗，所以性能不高;</p>
<h2 id="6.3%E3%80%81%E9%85%8D%E7%BD%AE%E4%B9%90%E8%A7%82%E9%94%81">6.3、配置乐观锁</h2>
<blockquote>
<p>本文主要讲解乐观锁机制</p>
</blockquote>
<p>乐观锁实现方式：</p>
<ul><li> <p>取出记录时，获取当前version</p> </li><li> <p>更新时，带上这个version</p> </li><li> <p>执行更新时，set version = newVersion where version = oldVersion</p> </li><li> <p>如果version不对，就更新失败</p> </li></ul>
<blockquote>
<p>当要更新一条记录时，是希望这条记录没有被更新的</p>
</blockquote>
<pre><code class="language-sql">-- 乐观锁：1、先查询，获取版本号 version=1
-- A线程
update user name = "tian" ,version = version +1
where id = 2 and version = 1
-- 如果B线程抢先完成，这个时候version=2，就会导致A线程修改失败
-- B线程
update user name = "tian" ,version = version +1
where id = 2 and version = 1</code></pre>
<blockquote>
<p>测试MP的乐观锁插件</p>
</blockquote>
<h3 id="6.3.1%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%B7%BB%E5%8A%A0version%E5%AD%97%E6%AE%B5">6.3.1、数据库中添加version字段</h3>
<p><img alt="" height="513" src="image\951bb3483d174467b471f13d4430ff9a.png" width="892"/></p>
<p></p>
<p></p>
<p>添加完成后查看是否更改完成</p>
<p><img alt="" height="263" src="image\69d804dd10114e4d9482c8ed48682f1a.png" width="1175"/></p>
<p></p>
<p></p>
<h3 id="6.3.2%E3%80%81%E5%90%8C%E6%AD%A5%E5%AE%9E%E4%BD%93%E7%B1%BB">6.3.2、同步实体类</h3>
<blockquote>
<p>记得在实体类上加上@Version注解</p>
</blockquote>
<pre><code class="language-java">@Version    //乐观锁version注解
private Integer version;</code></pre>
<p><img alt="" height="389" src="image\85cdb4d950484a2eb33ffb7ef2cdd58a.png" width="661"/></p>
<p></p>
<p></p>
<h3 id="6.3.3%E3%80%81%E9%85%8D%E7%BD%AE%E6%8F%92%E4%BB%B6">6.3.3、配置插件</h3>
<p>spring xml 方式：</p>
<pre><code class="language-XML">&lt;bean class="com.baomidou.mybatisplus.extension.plugins.inner.OptimisticLockerInnerInterceptor" id="optimisticLockerInnerInterceptor"/&gt;
​
&lt;bean id="mybatisPlusInterceptor" class="com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor"&gt;
    &lt;property name="interceptors"&gt;
        &lt;list&gt;
            &lt;ref bean="optimisticLockerInnerInterceptor"/&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
<pre>​</pre>
<blockquote>
<p>这里讲解的是springboot的注解方式</p>
</blockquote>
<p>spring boot 的注解方式</p>
<pre><code class="language-java">@Bean
public MybatisPlusInterceptor mybatisPlusInterceptor() {
    MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
    interceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor());
    return interceptor;
}</code></pre>
<p>首先创建配置类文件config，在该文件下创建配置类MyBatisPlusConfig，该类需要添加三个注解：</p>
<pre><code class="language-java">@Configuration  //配置类
@MapperScan("com.wen.mybatis_plus.mapper")  //扫描mapper
@EnableTransactionManagement    //自动管理事务，默认是开启的</code></pre>
<blockquote>
<p>@MapperScan()是将原先MybatisPlusApplication中的扫描换到这里的,所以MybatisPlusApplication中就不需要@MapperScan()，在该配置类里添加@MapperScan()即可</p>
</blockquote>
<p>创建完MyBatisPlusConfig类并添加完注解后，就可以将上面的组件的注解方式填入进来</p>
<pre><code class="language-java">@Configuration  //配置类
@MapperScan("com.wen.mybatis_plus.mapper")  //扫描mapper
@EnableTransactionManagement
public class MyBatisPlusConfig {
    //注册乐观锁插件
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor() {
        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
        interceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor());
        return interceptor;
    }
}</code></pre>
<p>此时乐观锁就已经配置完成了！</p>
<p><img alt="" height="506" src="image\7b54e94718504fc2bf0955a4ddbec7ac.png" width="1170"/></p>
<p></p>
<p></p>
<h3 id="6.3.4%E3%80%81%E6%B5%8B%E8%AF%95%E4%B9%90%E8%A7%82%E9%94%81">6.3.4、测试乐观锁</h3>
<p>在测试类中分别对成功与失败进行测试</p>
<p>测试成功：</p>
<pre><code class="language-java">//测试成功的乐观锁
@Test
void testOptimisticLocker_success() {
    //1.查询用户信息
    User user = userMapper.selectById(1l);
    //2.修改用户信息
    user.setName("tian");
    user.setAge(21);
    //3.执行更新操作
    userMapper.updateById(user);
}</code></pre>
<p>结果如下：</p>
<p><img alt="" height="413" src="image\6a5824ec48ab493dbdad2e41e1aab84e.png" width="1200"/></p>
<p></p>
<p></p>
<p>测试失败：</p>
<blockquote>
<p>模拟多线程的方式执行插队操作</p>
</blockquote>
<pre><code class="language-java">@Test
void testOptimisticLocker_failure() {
    //模拟多线程实现插队效果
    //线程1
    User user = userMapper.selectById(1l);
    user.setName("tian");
    user.setAge(21);
    //线程2
    User user2 = userMapper.selectById(1l);
    user2.setName("xiaotian");
    user2.setAge(19);
    userMapper.updateById(user2);   //在这里插队
​
    userMapper.updateById(user);    //如果没有乐观锁就会覆盖插队线程的值
}</code></pre>
<p>查看控制台输出：</p>
<p><img alt="" height="824" src="image\fa46eb7d1b52445eae2e4474142314af.png" width="1200"/></p>
<p></p>
<p>从数据库看结果：</p>
<p><img alt="" height="223" src="image\2e609a51628348c1b882abd375cd86d4.png" width="759"/></p>
<p></p>
<h1 id="%E4%B8%83%E3%80%81%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5">七、增删改查</h1>
<h2 id="7.1%E3%80%81%E6%9F%A5%E8%AF%A2%E6%93%8D%E4%BD%9C">7.1、查询操作</h2>
<p>1.通过Id查询用户</p>
<pre><code class="language-java">//测试查询
@Test
public void testSelectById(){
    User user = userMapper.selectById(1L);
    System.out.println(user);
}</code></pre>
<p>结果：</p>
<p><img alt="" height="119" src="image\934e909b18864aa7824f32c9db419c53.png" width="807"/></p>
<p></p>
<p>2.批量查询</p>
<pre><code class="language-java">//批量查询
@Test
public void selectBatchIds(){
    List&lt;User&gt; users = userMapper.selectBatchIds(Arrays.asList(1, 2, 3));
    users.forEach(System.out::println);
}</code></pre>
<blockquote>
<p>批量查询通过selectBatchIds方法，方法内放入的是集合，可以通过源码看</p>
</blockquote>
<p>selectBatchIds方法源码：</p>
<pre><code class="language-java">/**
 * 查询（根据ID 批量查询）
 *
 * @param idList 主键ID列表(不能为 null 以及 empty)
 */
List&lt;T&gt; selectBatchIds(@Param(Constants.COLLECTION) Collection&lt;? extends Serializable&gt; idList);</code></pre>
<blockquote>
<p>可以看到参数是Collection也就是集合，这里使用的是Arrays集合</p>
</blockquote>
<p>结果：<img alt="" height="196" src="image\4d744ff6790e42659490d1a70197cbf3.png" width="1094"/></p>
<p></p>
<p>3.条件查询</p>
<blockquote>
<p>通过自定义条件查询</p>
</blockquote>
<pre><code class="language-java">//条件查询
@Test
public void selectByMap(){
    HashMap&lt;String,Object&gt; map = new HashMap&lt;&gt;();
    //自定义查询
    map.put("name","小文");
    map.put("age",20);
    List&lt;User&gt; users = userMapper.selectByMap(map);
    users.forEach(System.out::println);
}</code></pre>
<blockquote>
<p>可以看出，map类的参数（字段名，参数）会被MySQLPlus自动组合成查询条件</p>
</blockquote>
<p> <img alt="" height="142" src="image\a83bc0fc21af48bca732a71372d2867e.png" width="1069"/></p>
<p></p>
<p></p>
<h2 id="7.2%E3%80%81%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2">7.2、分页查询</h2>
<ul><li> <p>原始的limit进行分页</p> </li><li> <p>pageHelper第三方插件</p> </li><li> <p>MyBatisPlus内置分页插件</p> </li></ul>
<blockquote>
<p>支持数据库：</p>
</blockquote>
<ul><li> <p>mysql，oracle，db2，h2，hsql，sqlite，postgresql，sqlserver，Phoenix，Gauss ，clickhouse，Sybase，OceanBase，Firebird，cubrid，goldilocks，csiidb</p> </li><li> <p>达梦数据库，虚谷数据库，人大金仓数据库，南大通用(华库)数据库，南大通用数据库，神通数据库，瀚高数据库</p> </li></ul>
<blockquote>
<p>属性介绍</p>
</blockquote>
<table><thead><tr><th>属性名</th><th>类型</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>overflow</td><td>boolean</td><td>false</td><td>溢出总页数后是否进行处理(默认不处理)</td></tr><tr><td>maxLimit</td><td>Long</td><td></td><td>单页分页条数限制(默认无限制)</td></tr><tr><td>dbType</td><td>DbType</td><td></td><td>数据库类型(根据类型获取应使用的分页方言)</td></tr><tr><td>dialect</td><td>IDialect</td><td></td><td>方言实现类</td></tr></tbody></table>
<blockquote>
<p>建议单一数据库类型的均设置 dbType</p>
</blockquote>
<p></p>
<blockquote>
<p>如何使用MyBatisPlus内页插件？</p>
</blockquote>
<p>1、配置拦截器组件即可</p>
<pre><code class="language-java">/**
 * 注册插件
 */
@Bean
public MybatisPlusInterceptor paginationInterceptor() {
​
    MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
    // 添加分页插件
    PaginationInnerInterceptor pageInterceptor = new PaginationInnerInterceptor();
    // 设置请求的页面大于最大页后操作，true调回到首页，false继续请求。默认false
    pageInterceptor.setOverflow(false);
    // 单页分页条数限制，默认无限制
    pageInterceptor.setMaxLimit(500L);
    // 设置数据库类型
    pageInterceptor.setDbType(DbType.MYSQL);
​
    interceptor.addInnerInterceptor(pageInterceptor);
    return interceptor;
}</code></pre>
<p>2、分页组件测试</p>
<pre><code class="language-java">//测试MybatisPlus分页插件
@Test
public void testMybatisPlus_Page(){
    // 两个参数：current的值默认是1，从1开始，不是0。size是每一页的条数。
    Page&lt;User&gt; page = new Page&lt;&gt;(1, 4);
    userMapper.selectPage(page,null);
    page.getRecords().forEach(System.out::println);
}</code></pre>
<p>结果分析：</p>
<p><img alt="" height="346" src="image\b3da6fd28d50463896a9d20d629c9698.png" width="1139"/></p>
<p></p>
<p>查询第二页试试看</p>
<p><img alt="" height="263" src="image\76e566fdbc4c44458ad358f7dea1de9e.png" width="1136"/></p>
<p></p>
<blockquote>
<p>除此之外，Page 的方法还有很多比如：</p>
</blockquote>
<pre><code class="language-java">//page的其他方法
System.out.println("当前页：" + page.getCurrent());
System.out.println("总页数：" + page.getPages());
System.out.println("记录数：" + page.getTotal());
System.out.println("是否有上一页：" + page.hasPrevious());
System.out.println("是否有下一页：" + page.hasNext());</code></pre>
<p>结果：</p>
<p> <img alt="" height="313" src="image\67d5254e96b7463ba6086df58c91b4bf.png" width="987"/></p>
<p></p>
<h2 id="7.3%E3%80%81%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C">7.3、删除操作</h2>
<blockquote>
<p>跟查询操作相似，就不详细讲解，直接上代码了</p>
</blockquote>
<pre><code class="language-java">//测试删除
@Test
public void testDeleteById(){
    userMapper.deleteById(4L);
}
​
//批量删除
@Test
public void testDeleteBatchId(){
    userMapper.deleteBatchIds(Arrays.asList(1L,2L));
}
​
//通过map删除
@Test
public void testdeleteByMap(){
    Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
    map.put("name","xiaotian");
    userMapper.deleteByMap(map);
}</code></pre>
<h2 id="7.4%E3%80%81%E9%80%BB%E8%BE%91%E5%88%A0%E9%99%A4">7.4、逻辑删除</h2>
<blockquote>
<p>物理删除：从数据库中直接删除</p>
<p>逻辑删除：在数据库中没有被删除，而是通过一个变量来让它失效。 deleted=0 ==》deleted=1</p>
</blockquote>
<p>管理员可以查看被删除的记录，防止数据丢失，相当于回收站。</p>
<p>测试：</p>
<p>1、在数据表中增加一个deleted字段</p>
<p><img alt="" height="437" src="image\5d0b7569ac3f4327a968aacf6091bb83.png" width="892"/></p>
<p></p>
<p>2、同步实体类，在实体类上加上@TableLogic 注解</p>
<pre><code class="language-java">@TableLogic //逻辑删除
private Integer deleted;</code></pre>
<p>3、配置application.yml文件</p>
<pre><code class="language-XML">#配置日志
mybatis-plus:
  global-config:
    db-config:
      logic-delete-field: flag # 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置步骤2)
      logic-delete-value: 1 # 逻辑已删除值(默认为 1)
      logic-not-delete-value: 0 # 逻辑未删除值(默认为 0)</code></pre>
<p>4、测试</p>
<p>在这里直接使用之前的delete测试</p>
<pre><code class="language-java">//测试删除
@Test
public void testDeleteById(){
    userMapper.deleteById(4L);
}</code></pre>
<blockquote>
<p>查看日志输出可以看到，delete的语句以经发生了更改</p>
<p>实质上就是update（修改）语句，将deleted字段从1修改为0</p>
</blockquote>
<p><img alt="" height="100" src="image\0ad718a2e0204a839026f6a3b1c3c19a.png" width="1149"/>  </p>
<p></p>
<p>5、对Id为4的用户进行查询</p>
<pre><code class="language-java">//测试查询
@Test
public void testSelectById(){
    User user = userMapper.selectById(4L);
    System.out.println(user);
}</code></pre>
<blockquote>
<p>查看日志输出可以看到，seletc的语句以经发生了更改</p>
<p>增加了deleted的判断语句，判断deleted是否为1，为1则能搜索，0则不能</p>
</blockquote>
<p> <img alt="" height="120" src="image\92f314a0b65a4c48b7187486a2ece132.png" width="1080"/></p>
<p></p>
<p>6、小结</p>
<p>只对自动注入的SQL有效：</p>
<ul><li> <p>插入: 不作限制</p> </li><li> <p>查找: 追加 where 条件过滤掉已删除数据,且使用 wrapper.entity 生成的 where 条件会忽略该字段</p> </li><li> <p>更新: 追加 where 条件防止更新到已删除数据,且使用 wrapper.entity 生成的 where 条件会忽略该字段</p> </li><li> <p>删除: 转变为 更新</p> </li></ul>
<p>比如：</p>
<p>删除语句转化为：update user set deleted=1 where id = 1 and deleted=0</p>
<p>查找语句转化为：select id,name,deleted from user where deleted=0</p>
<blockquote>
<p>注意事项：</p>
<ul><li> <p>逻辑删除是为了方便数据恢复和保护数据本身价值等等的一种方案，但实际就是删除。</p> </li><li> <p>如果你需要频繁查出来看就不应使用逻辑删除，而是以一个状态去表示。</p> </li></ul>
</blockquote>
<h1 id="%E5%85%AB%E3%80%81%E6%89%A7%E8%A1%8CSQL%E5%88%86%E6%9E%90%E6%89%93%E5%8D%B0">八、执行SQL分析打印</h1>
<blockquote>
<p>可输出 SQL 语句以及其执⾏时间，建议开发测试时启⽤该功能，能快速揪出慢查询</p>
<p>注意：PerformanceInterceptor在3.2.0被移除了，如果想进⾏性能分析，⽤第三⽅的，官⽅这样写的“该插件 3.2.0 以上版本移除 推荐使⽤第三⽅扩展 执⾏SQL分析打印 功能”。也就是p6spy。</p>
</blockquote>
<p>使用步骤：</p>
<h2 id="8.1%E3%80%81p6spy%E4%BE%9D%E8%B5%96%E5%BC%95%E5%85%A5">8.1、p6spy依赖引入</h2>
<p>Maven:</p>
<pre><code class="language-XML">&lt;dependency&gt;
  &lt;groupId&gt;p6spy&lt;/groupId&gt;
  &lt;artifactId&gt;p6spy&lt;/artifactId&gt;
  &lt;version&gt;最新版本&lt;/version&gt; &lt;!--这里用的是&gt;3.9.1版本--&gt;
&lt;/dependency&gt;</code></pre>
<h2 id="8.2%E3%80%81application.yml%E9%85%8D%E7%BD%AE">8.2、application.yml配置</h2>
<pre><code class="language-XML">spring:
  datasource:
    driver-class-name: com.p6spy.engine.spy.P6SpyDriver
    url: jdbc:p6spy:h2:mem:test
    ...</code></pre>
<blockquote>
<p>注意： driver-class-name 为 p6spy 提供的驱动类 url 前缀为 jdbc:p6spy 跟着冒号为对应数据库连接地址</p>
</blockquote>
<p>实际配置为：</p>
<pre><code class="language-XML">spring:
  datasource:
    username: root
    password: 123456
    driver-class-name: com.p6spy.engine.spy.P6SpyDriver
    url: jdbc:p6spy:mysql:///mybatis_plus?userUnicode=true&amp;characterEncoding=utf-8</code></pre>
<p> <img alt="" height="478" src="image\96eb241c78e745049507c29b444c21a6.png" width="1200"/></p>
<p></p>
<h2 id="8.3%E3%80%81spy.properties%E9%85%8D%E7%BD%AE">8.3、spy.properties配置</h2>
<pre><code class="language-XML">#3.2.1以上使用
modulelist=com.baomidou.mybatisplus.extension.p6spy.MybatisPlusLogFactory,com.p6spy.engine.outage.P6OutageFactory
#3.2.1以下使用或者不配置
#modulelist=com.p6spy.engine.logging.P6LogFactory,com.p6spy.engine.outage.P6OutageFactory
# 自定义日志打印
logMessageFormat=com.baomidou.mybatisplus.extension.p6spy.P6SpyLogger
#日志输出到控制台
appender=com.baomidou.mybatisplus.extension.p6spy.StdoutLogger
# 使用日志系统记录 sql
#appender=com.p6spy.engine.spy.appender.Slf4JLogger
# 设置 p6spy driver 代理
deregisterdrivers=true
# 取消JDBC URL前缀
useprefix=true
# 配置记录 Log 例外,可去掉的结果集有error,info,batch,debug,statement,commit,rollback,result,resultset.
excludecategories=info,debug,result,commit,resultset
# 日期格式
dateformat=yyyy-MM-dd HH:mm:ss
# 实际驱动可多个
#driverlist=org.h2.Driver
# 是否开启慢SQL记录
outagedetection=true
# 慢SQL记录标准 2 秒
outagedetectioninterval=2</code></pre>
<p><img alt="" height="569" src="image\f50ef71fc30f47e6a433f9fd0543b14f.png" width="1200"/></p>
<p></p>
<h2 id="8.4%E3%80%81%E6%B5%8B%E8%AF%95">8.4、测试</h2>
<p>这里使用之前的分页查询来测试一下</p>
<pre><code class="language-java">//测试MybatisPlus分页插件
@Test
public void testMybatisPlus_Page(){
    // 两个参数：current的值默认是1，从1开始，不是0。size是每一页的条数。
    Page&lt;User&gt; page = new Page&lt;&gt;(2, 4);
    userMapper.selectPage(page,null);
    page.getRecords().forEach(System.out::println);
    //page的其他方法
    System.out.println("当前页：" + page.getCurrent());
    System.out.println("总页数：" + page.getPages());
    System.out.println("记录数：" + page.getTotal());
    System.out.println("是否有上一页：" + page.hasPrevious());
    System.out.println("是否有下一页：" + page.hasNext());
}</code></pre>
<p>查看日志输出</p>
<p> <img alt="" height="389" src="image\d6027a700fd348178786bd23ca3a410d.png" width="1002"/></p>
<p></p>
<p></p>
<blockquote>
<p>因为在配置文件中设置了慢SQL的检查，为2s，所以这里的查询可以通过</p>
<p>但是只要超过了时长就会抛出异常</p>
</blockquote>
<p><img alt="" height="123" src="image\62e3cca32ec24f0cae88a0bdb6fab725.png" width="278"/></p>
<p></p>
<p></p>
<h1 id="%E4%B9%9D%E3%80%81%E6%9D%A1%E4%BB%B6%E6%9E%84%E9%80%A0%E5%99%A8">九、条件构造器</h1>
<blockquote>
<p>Wrapper，可以通过其构造复杂的SQL</p>
</blockquote>
<p><img alt="" height="763" src="image\b21f51efab564f7a97c3e1485c2b8258.png" width="163"/></p>
<p></p>
<p></p>
<blockquote>
<p>注意：</p>
<p>1、耦合性高</p>
<p>2、传输wrapper相当于conroller用map接收值，后期维护极为困难</p>
<p>所以这里只是采取少量代码进行演示</p>
</blockquote>
<h2 id="9.1%E3%80%81%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA">9.1、代码演示</h2>
<p>1、查询name、邮箱不为空且年龄大于等于20的用户</p>
<pre><code class="language-java">@Test
void WrapperTest(){
    //查询name、邮箱不为空且年龄大于等于20的用户
    QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;();
    wrapper
            .isNotNull("name")
            .isNotNull("email")
            .ge("age",12);
    userMapper.selectList(wrapper).forEach(System.out::println);
}</code></pre>
<p><img alt="" height="264" src="image\1b25b2fb83814658832479efb682ef5e.png" width="1200"/></p>
<p></p>
<p></p>
<p>2、查询姓名为小文的用户</p>
<pre><code class="language-java">@Test
void WrapperTest2(){
    //查询姓名为小文的用户
    QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;();
    wrapper.eq("name","小文");    //equals
    User user = userMapper.selectOne(wrapper); 
    System.out.println(user);
}</code></pre>
<p><img alt="" height="285" src="image\d6685095f47047b384e80b1afb590ae9.png" width="1155"/></p>
<p></p>
<p></p>
<blockquote>
<p>注意：</p>
<p>查询一个数据出现多个结果就使用List或map</p>
</blockquote>
<p>3、查询年龄在19-23之间的用户</p>
<pre><code class="language-java">@Test
void WrapperTest3(){
    //查询年龄在19-23之间的用户
    QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;();
    wrapper.between("age", 19, 23);
    Long count = userMapper.selectCount(wrapper);//查询结果数
    System.out.println(count);
}</code></pre>
<p></p>
<p>4、查询年龄在19-23之间的用户</p>
<pre><code class="language-java">@Test
void WrapperTest3(){
    //查询年龄在19-23之间的用户
    QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;();
    wrapper.between("age", 19, 23);
    Long count = userMapper.selectCount(wrapper);//查询结果数
    System.out.println(count);
}</code></pre>
<p> <img alt="" height="249" src="image\ee3c84bfb7834ba4947a7475fb04f9cf.png" width="1194"/></p>
<p></p>
<p></p>
<blockquote>
<p>这里的方法取值范围是左开右闭！</p>
</blockquote>
<p>5、模糊查询</p>
<pre><code class="language-java">@Test
void WrapperTest4(){
    QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;();
    wrapper
            .notLike("name","a")    //查询姓名中不包含a的用户
            .likeRight("email","t");   //左和右是代表%的位置 两边都要匹配则为%e%，这里是email以t开头的 t%
    List&lt;Map&lt;String, Object&gt;&gt; maps = userMapper.selectMaps(wrapper);
    maps.forEach(System.out::println);
}</code></pre>
<p> <img alt="" height="295" src="image\e0a097c8a6804d7e86432b0baba8a22f.png" width="1200"/></p>
<p></p>
<p></p>
<p>6、联表查询</p>
<pre><code class="language-java">//联表查询
@Test
void WrapperTest5(){
    QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;();
    wrapper.inSql("id","select id from user where id &lt; 4");
    List&lt;Object&gt; objects = userMapper.selectObjs(wrapper);
    objects.forEach(System.out::println);
}</code></pre>
<p> <img alt="" height="245" src="image\d88bff5a32e94bcaa4c835233425a908.png" width="1200"/></p>
<p></p>
<p></p>
<p>7、通过ID进行排序</p>
<pre><code class="language-java">@Test
void WrapperTest6(){
    //通过ID进行排序
    QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;();
    wrapper.orderByAsc("id");   //通过id升序
    List&lt;User&gt; users = userMapper.selectList(wrapper);
    users.forEach(System.out::println);
}</code></pre>
<p><img alt="" height="292" src="image\cbcf8d9ab9f14bd89c63ce750bcec507.png" width="1131"/></p>
<p></p>
<p></p>
<h1 id="%E5%8D%81%E3%80%81%E4%BB%A3%E7%A0%81%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E5%99%A8">十、代码自动生成器</h1>
<blockquote>
<p>MybatisPlus看官方文档即可，这里讲一个Idea插件Easy Code代码生成器</p>
</blockquote>
<h2 id="10.1%E3%80%81EasyCode">10.1、EasyCode</h2>
<p>EasyCode是基于IntelliJ IDEA Ultimate版开发的一个代码生成插件，主要通过自定义模板（基于velocity）来生成各种你想要的代码。通常用于生成Entity、Dao、Service、Controller。如果你动手能力强还可以用于生成HTML、JS、PHP等代码。理论上来说只要是与数据有关的代码都是可以生成的。</p>
<p><strong>支持的数据库类型：</strong></p>
<blockquote>
<ol><li> <p>MySQL</p> </li><li> <p>SQL Server</p> </li><li> <p>Oracle</p> </li><li> <p>PostgreSQL</p> </li><li> <p>Sqlite</p> </li><li> <p>Sybase</p> </li><li> <p>Derby</p> </li><li> <p>DB2</p> </li><li> <p>HSQLDB</p> </li><li> <p>H2</p> </li></ol>
<p>当然支持的数据库类型也会随着Database Tool插件的更新同步更新。</p>
</blockquote>
<h2 id="10.2%E3%80%81%E5%8A%9F%E8%83%BD">10.2、功能</h2>
<ul><li> <p>支持多表同时操作</p> </li><li> <p>支持同时生成多个模板</p> </li><li> <p>支持自定义模板</p> </li><li> <p>支持自定义类型映射（支持正则）</p> </li><li> <p>支持自定义附加列</p> </li><li> <p>支持列附加属性</p> </li><li> <p>所有配置项目支持分组模式，在不同项目（或选择不同数据库时），只需要切换对应的分组，所有配置统一变化</p> </li></ul>
<h2 id="10.3%E3%80%81%E6%93%8D%E4%BD%9C">10.3、操作</h2>
<p>1、安装EasyCode</p>
<p><img alt="" height="721" src="image\54f84dbb9dd84910b3cfef7858f5c42e.png" width="998"/></p>
<p></p>
<p>2、建立数据库</p>
<p>这里就不再多说了，就用之前的数据库即可</p>
<p>3、在IDEA配置连接数据库</p>
<p><img alt="" height="347" src="image\685fd53a9071469ea997d8b9ef70efd1.png" width="390"/></p>
<p></p>
<p></p>
<blockquote>
<p>这里也不多说了，就是idea连接自己的数据库</p>
</blockquote>
<p>4、使用EasyCode</p>
<p>在对应的字段上右键，就可以看到多出一个EasyCode，点击然后选择生成<img alt="" height="359" src="image\5ce7b08bfa3b489aa0da987d400123bb.png" width="424"/></p>
<p></p>
<p></p>
<p>5、开始生成代码</p>
<p><img alt="" height="369" src="image\efbefe9b43fd4f9db3dd693276d1c58e.png" width="502"/></p>
<p></p>
<p>勾选需要生成的代码，点击OK即可</p>
<p><img alt="" height="369" src="image\0ff145a2f0344dfa9e69c6ed5a42ffc3.png" width="502"/></p>
<p></p>
<p></p>
<p>6、效果图</p>
<p></p>
<p><img alt="" height="272" src="image\451ba3169080476181a8eab94df82f87.png" width="313"/></p>
<p></p>
<blockquote>
<p>这些就是自动生成的代码了，代码你成熟了，应该自己生成了&lt;狗头&gt;</p>
</blockquote>
</div>
</div>