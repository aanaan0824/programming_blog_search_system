<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<p><img alt="ced485cbb11e458d81a746890b32cf3f.gif" src="https://img-blog.csdnimg.cn/ced485cbb11e458d81a746890b32cf3f.gif"/></p>
<blockquote>
<p>作者：<span style="color:#faa572;">敲代码の流川枫</span></p>
<p>博客主页：<a href="https://blog.csdn.net/chenchenchencl?spm=1011.2421.3001.5343" title="流川枫的博客">流川枫的博客</a></p>
<p>专栏：<a href="https://blog.csdn.net/chenchenchencl/category_11932758.html" title="和我一起学java">和我一起学java</a></p>
<p>语录：<span style="color:#faa572;">Stay hungry stay foolish</span></p>
<p><span style="color:#faa572;">工欲善其事必先利其器，给大家介绍一款超牛的斩获大厂offer利器——牛客网</span></p>
<p><span style="color:#faa572;"><a href="https://www.nowcoder.com/link/pc_csdncpt_qdmdlcf_c" title="点击免费注册和我一起刷题吧">点击免费注册和我一起刷题吧</a>  </span></p>
</blockquote>
<p id="main-toc"><strong>文章目录</strong></p>
<p id="%E4%B8%80%E3%80%81%E7%BB%A7%E6%89%BF-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E7%BB%A7%E6%89%BF">一、继承</a></p>
<p id="1.%20%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E7%BB%A7%E6%89%BF%EF%BC%9F-toc" style="margin-left:0px;"><a href="#1.%20%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E7%BB%A7%E6%89%BF%EF%BC%9F">1. 如何理解继承？</a></p>
<p id="2.%20%E7%BB%A7%E6%89%BF%E7%9A%84%E8%AF%AD%E6%B3%95-toc" style="margin-left:0px;"><a href="#2.%20%E7%BB%A7%E6%89%BF%E7%9A%84%E8%AF%AD%E6%B3%95">2. 继承的语法</a></p>
<p id="3.%20%E5%AD%90%E7%B1%BB%E5%A6%82%E4%BD%95%E8%AE%BF%E9%97%AE%E7%88%B6%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%88%90%E5%91%98-toc" style="margin-left:0px;"><a href="#3.%20%E5%AD%90%E7%B1%BB%E5%A6%82%E4%BD%95%E8%AE%BF%E9%97%AE%E7%88%B6%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%88%90%E5%91%98">3. 子类如何访问父类中的成员</a></p>
<p id="3.1%20%E8%AE%BF%E9%97%AE%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-toc" style="margin-left:40px;"><a href="#3.1%20%E8%AE%BF%E9%97%AE%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F">3.1 访问成员变量</a></p>
<p id="3.2%20%E8%AE%BF%E9%97%AE%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#3.2%20%E8%AE%BF%E9%97%AE%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95">3.2 访问成员方法</a></p>
<p id="3.3%C2%A0super%E5%85%B3%E9%94%AE%E5%AD%97-toc" style="margin-left:40px;"><a href="#3.3%C2%A0super%E5%85%B3%E9%94%AE%E5%AD%97">3.3 super关键字</a></p>
<p id="4.%20%E5%AD%90%E7%B1%BB%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-toc" style="margin-left:0px;"><a href="#4.%20%E5%AD%90%E7%B1%BB%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95">4. 子类构造方法</a></p>
<p id="5.%20final%20%E5%85%B3%E9%94%AE%E5%AD%97-toc" style="margin-left:0px;"><a href="#5.%20final%20%E5%85%B3%E9%94%AE%E5%AD%97">5. final 关键字</a></p>
<p id="6.%20%E7%BB%A7%E6%89%BF%E4%B8%8E%E7%BB%84%E5%90%88-toc" style="margin-left:0px;"><a href="#6.%20%E7%BB%A7%E6%89%BF%E4%B8%8E%E7%BB%84%E5%90%88">6. 继承与组合</a></p>
<p id="%E4%BA%8C%E3%80%81%E5%A4%9A%E6%80%81-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E5%A4%9A%E6%80%81">二、多态</a></p>
<p id="1.%E8%AE%A4%E8%AF%86%E5%A4%9A%E6%80%81-toc" style="margin-left:0px;"><a href="#1.%E8%AE%A4%E8%AF%86%E5%A4%9A%E6%80%81">1.认识多态</a></p>
<p id="%C2%A02.%20%E5%A4%9A%E6%80%81%E5%AE%9E%E7%8E%B0%E6%9D%A1%E4%BB%B6-toc" style="margin-left:0px;"><a href="#%C2%A02.%20%E5%A4%9A%E6%80%81%E5%AE%9E%E7%8E%B0%E6%9D%A1%E4%BB%B6"> 2. 多态实现条件</a></p>
<p id="3.%20%E9%87%8D%E5%86%99-toc" style="margin-left:0px;"><a href="#3.%20%E9%87%8D%E5%86%99">3. 重写</a></p>
<p id="4.%C2%A0%E5%90%91%E4%B8%8A%E8%BD%AC%E7%A7%BB%E5%92%8C%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B-toc" style="margin-left:0px;"><a href="#4.%C2%A0%E5%90%91%E4%B8%8A%E8%BD%AC%E7%A7%BB%E5%92%8C%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B">4. 向上转移和向下转型</a></p>
<p id="%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B%EF%BC%9A%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%B0%86%E5%85%B6%E5%BD%93%E6%88%90%E7%88%B6%E7%B1%BB%E5%AF%B9%E8%B1%A1%E6%9D%A5%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px;"><a href="#%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B%EF%BC%9A%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%B0%86%E5%85%B6%E5%BD%93%E6%88%90%E7%88%B6%E7%B1%BB%E5%AF%B9%E8%B1%A1%E6%9D%A5%E4%BD%BF%E7%94%A8">向上转型：创建一个子类对象，将其当成父类对象来使用</a></p>
<p id="%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B%EF%BC%9A%E7%88%B6%E7%B1%BB%E5%BC%95%E7%94%A8%E5%86%8D%E8%BF%98%E5%8E%9F%E4%B8%BA%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1-toc" style="margin-left:40px;"><a href="#%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B%EF%BC%9A%E7%88%B6%E7%B1%BB%E5%BC%95%E7%94%A8%E5%86%8D%E8%BF%98%E5%8E%9F%E4%B8%BA%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1">向下转型：父类引用再还原为子类对象</a></p>
<hr id="hr-toc"/>
<p></p>
<h1 id="%E4%B8%80%E3%80%81%E7%BB%A7%E6%89%BF">一、继承</h1>
<h1 id="1.%20%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E7%BB%A7%E6%89%BF%EF%BC%9F">1. 如何理解继承？</h1>
<blockquote>
<p>类实例化产生的对象之间可能存在某些关联，继承就是提取这些共性从而达到代码复用</p>
<p></p>
<p>概念：在保持原有类特性的基础上进行扩展，增加新功能，产生新的类的过程，这个类称派生类</p>
<p>继承主要解决的问题是：共性的抽取，实现代码复用</p>
</blockquote>
<h1 id="2.%20%E7%BB%A7%E6%89%BF%E7%9A%84%E8%AF%AD%E6%B3%95">2. 继承的语法</h1>
<p>关键字：<strong>extends</strong></p>
<p>格式：</p>
<pre><code>修饰符 class 子类 extends 父类 {

    //... 

}</code></pre>
<p>子类会继承父类的成员变量或者成员方法</p>
<p>子类继承父类后要添加自己特有的成员，即除了父类之外的特性</p>
<pre><code>class Animal{
    public String name;
    public int age;

    public void eat() {
        System.out.println(name+"吃饭");
    }
}
class Dog extends Animal{
    //新加的属性
    public String silly;
    public void houseGuard() {
        System.out.println("看门");
    }
}
class Cat extends Animal {

    //没有添加新属性
    public void catchMouse()  {
        System.out.println(name+"抓老鼠");
    }
}
public class Test {
    public static void main(String[] args) {

        //name和age属性是从父类Animal中继承下来的

        Dog dog = new Dog();
        Cat cat = new Cat();

    }
}</code></pre>
<p>还要注意：Java中不支持多继承，一个子类只能继承一个父类</p>
<h1 id="3.%20%E5%AD%90%E7%B1%BB%E5%A6%82%E4%BD%95%E8%AE%BF%E9%97%AE%E7%88%B6%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%88%90%E5%91%98">3. 子类如何访问父类中的成员</h1>
<h2 id="3.1%20%E8%AE%BF%E9%97%AE%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F">3.1 访问成员变量</h2>
<p>成员变量访问遵循就近原则，自己有优先自己的，如果没有则向父类中找</p>
<p>如果找不到，则在父类继承下来的成员变量中寻找要访问的成员变量，找不到编译失败</p>
<h2 id="3.2%20%E8%AE%BF%E9%97%AE%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95">3.2 访问成员方法</h2>
<p>成员方法名字不同：</p>
<p>优先访问自己的，若没有，去访问从父类继承的</p>
<p>成员方法名字相同：</p>
<p>父类和子类同名方法的参数列表不同(重载)，根据调用方法适传递的参数选择合适的方法访问，没有则报错</p>
<h2 id="3.3%C2%A0super%E5%85%B3%E9%94%AE%E5%AD%97">3.3 super关键字</h2>
<p>用法：在子类方法中访问父类的成员</p>
<pre><code>class Dog extends Animal{
    
    public String silly;
    public void houseGuard() {

        System.out.println(super.name+"看门");

    }
}</code></pre>
<p> 父类的name没有赋初值，因此是null ，这样就访问到了同名的父类的成员变量</p>
<p><img alt="" height="156" src="image\54ab5cb456444a52816005ecffd9432d.png" width="724"/></p>
<p> this.会有优先问自己的，没有则访问从父类中继承的</p>
<p>super.直接访问从父类中继承下来的，在子类方法中，如果想要明确访问父类中成员时，借助super关键字即可</p>
<blockquote>
<p>总结：</p>
<p>super.data;访问父类的普通成员变量</p>
<p>super.func();访问父类的普通成员方法</p>
<p>super();访问父类的构造方法</p>
</blockquote>
<p>注意：上文父类的普通成员方法、变量是指非静态成员方法、变量</p>
<h1 id="4.%20%E5%AD%90%E7%B1%BB%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95">4. 子类构造方法</h1>
<p>子类对象构造时，需要先调用基类构造方法，然后执行子类的构造方法</p>
<p>看代码：</p>
<pre><code>class Animal{
    public String name;
    public int age;

    //提供一个两个该参数的构造方法
    public Animal(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public void eat() {
        System.out.println(name+"吃饭");
    }
}

    //此处报错
class Dog extends Animal{
    
    public String silly;
    public void houseGuard() {
        System.out.println(super.name+"看门");
    }
}</code></pre>
<p><img alt="" height="177" src="image\d9bc7ecf12be4adeb58e006527abbed9.png" width="754"/></p>
<p>对象的初始化需要调用构造方法</p>
<p>添加了带有两个参数的构造器后，编译器不会提供无参的构造方法，因此出现错误</p>
<p>接下来我们看当提供了两个参数的构造方法时如何初始化：</p>
<pre><code>class Dog extends Animal{
    
    public String silly;
        public Dog(String name, int age, String silly) {

        //先初始化父类部分
            super(name, age);
            this.silly = silly;

        }

        public void houseGuard() {
        System.out.println(super.name+"看门");
    }
}</code></pre>
<p>super(name,age)会先调用父类的构造方法完成初始化</p>
<p>this.silly = silly会完成自己属性的初始化</p>
<blockquote>
<p>总结：</p>
<p>1. 父类显式定义无参或者默认的构造方法，子类构造方法第一行会默认有隐含的super()调用</p>
<p>2. 父类构造方法是带有参数的，此时需要用户为子类显式定义构造方法，并在子类构造方法中选择合适的父类构造方法调用，否则编译失败</p>
<p>3. 在子类构造方法中，super(...)调用父类构造时，必须是子类构造函数中第一条语句</p>
<p>4. super(...)只能在子类构造方法中出现一次，并且不能和this同时出现</p>
</blockquote>
<h1 id="5.%20final%20%E5%85%B3%E9%94%AE%E5%AD%97">5. final 关键字</h1>
<p>1. 修饰变量或字段，表示常量</p>
<p>2. 修饰类：表示此类不能被继承</p>
<p>String 字符串类, 就是用 final 修饰的, 不能被继承</p>
<p>3. 修饰方法：表示该方法不能被重写</p>
<h1 id="6.%20%E7%BB%A7%E6%89%BF%E4%B8%8E%E7%BB%84%E5%90%88">6. 继承与组合</h1>
<p>与继承相似，组合也是表示类之间关系的方式，能实现代码的复用</p>
<p>继承表示各种类抽象出来的共性，对象之间是is-a的关系</p>
<p>组合(Composition)体现的是整体与部分、拥有的关系，即<a href="https://en.wikipedia.org/wiki/Has-a" title="has-a">has-a</a>的关系</p>
<p>例如交通工具车的组合：</p>
<pre><code>class Tire {
    public void run() {
        System.out.println("轮胎转动");
    }
}

class Light {
    public void light() {
        System.out.println("灯亮");
    }
}

public class Vehicle {
    private Tire tire;
    private Light light;

    public Vehicle(Tire tire,Light light) {
        this.tire = tire;
        this.light = light;
    }

    public void operation() {
        light.light();
        tire.run();
    }

    public static void main(String[] args) {
        Tire tire = new Tire();
        Light light = new Light();
        Vehicle vehicle = new Vehicle(tire,light);
        //灯亮
        //轮胎转动
        vehicle.operation();
    }
}</code></pre>
<h1 id="%E4%BA%8C%E3%80%81%E5%A4%9A%E6%80%81">二、多态</h1>
<h1 id="1.%E8%AE%A4%E8%AF%86%E5%A4%9A%E6%80%81">1.认识多态</h1>
<p>不同的对象在完成某个行为时会产生出不同的状态就叫多态</p>
<p>例如：手机支付时产生的多态</p>
<p class="img-center"><img alt="" height="440" src="image\df79004e874244bfab3a311a698b4a7f.png" width="953"/></p>
<h1 id="%C2%A02.%20%E5%A4%9A%E6%80%81%E5%AE%9E%E7%8E%B0%E6%9D%A1%E4%BB%B6"> 2. 多态实现条件</h1>
<blockquote>
<p>1. 必须在继承体系下</p>
<p>2. 子类必须要对父类中方法进行重写</p>
<p>3. 通过父类的引用调用重写的方法</p>
</blockquote>
<p>多态体现在：当代码运行时，传递不同类的对象时，会调用对应类中的方法</p>
<p>例如：</p>
<pre><code>class Animal{
    public String name;
    public int age;

    public Animal(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public void eat() {
        System.out.println(name+"吃饭");
    }
}

class Dog extends Animal{
    
    public String silly;

        public Dog(String name, int age, String silly) {
            super(name, age);
            this.silly = silly;
        }
        @Override
        public void eat() {
            System.out.println(name+"吃狗粮");
        }

        public void houseGuard() {
        System.out.println(super.name+"看门");
    }
}
class Cat extends Animal {

    public Cat(String name, int age) {
        super(name, age);
    }

    @Override
    public void eat() {
        System.out.println(name+"吃猫粮");
    }
    //没有添加新属性
    public void catchMouse()  {
        System.out.println(name+"抓老鼠");
    }
}
public class Test {
    public static void eat(Animal animal) {

        animal.eat;

}
    public static void main(String[] args) {
        Dog dog = new Dog("dog",2,"silly");
        Cat cat = new Cat("cat",3);
        eat(dog);
        eat(cat);

    }
}
</code></pre>
<p><img alt="" height="173" src="image\181b5f611c6f4025bbdd941647b38769.png" width="805"/></p>
<p> Test类中的eat方法参数为Animal，该方法内部并不知道，也不关注当前的a引用指向哪个实例，此时 a这个引用调用 eat方法可能会有多种不同的表现(和 a 引用的实例相关), 这种行为就称为多态</p>
<h1 id="3.%20%E9%87%8D%E5%86%99">3. 重写</h1>
<p>概念：返回值和形参都不能改变，子类对父类非静态、非private修饰，非final修饰，非构造方法等的实现过程进行重新编写</p>
<p>重写的好处在于子类可以根据需要，定义特定于自己的行为。也就是说子类能够根据需要实现父类的方法</p>
<blockquote>
<p>【方法重写的规则】</p>
<p>子类与父类方法原型一致：返回值类型 方法名 (参数列表) 要完全一致</p>
<p>被重写的方法返回值类型可以不同，但是必须是具有父子关系的</p>
<p>访问权限不能比父类中被重写的方法的访问权限更低，父类方法被public修饰，则子类中重写该方法就不能声明为 protected</p>
<p>父类被static、private修饰的方法、构造方法都不能被重写</p>
<p>@Override注解能帮我们进行一些合法性校验，重写没有构成时报错</p>
</blockquote>
<h1 id="4.%C2%A0%E5%90%91%E4%B8%8A%E8%BD%AC%E7%A7%BB%E5%92%8C%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B">4. 向上转移和向下转型</h1>
<h2 id="%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B%EF%BC%9A%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%B0%86%E5%85%B6%E5%BD%93%E6%88%90%E7%88%B6%E7%B1%BB%E5%AF%B9%E8%B1%A1%E6%9D%A5%E4%BD%BF%E7%94%A8">向上转型：创建一个子类对象，将其当成父类对象来使用</h2>
<pre><code>//语法格式：父类类型对象名 = new 子类类型()

    Animal animal = new Cat("cat",2);

</code></pre>
<p> 使用：</p>
<p>方法一：直接赋值（子类对象赋值给父类对象）</p>
<pre><code>public class Test {
    public static void main(String[] args) {
        Dog dog = new Dog("dog",2,"silly");
        Animal animal = dog;
        Animal animal1 = dog;
        Animal animal2 = dog;
    }
}</code></pre>
<p>方法二：方法传参（形参为父类型引用，可以接收任意子类的对象）</p>
<pre><code>    public static void eat(Animal animal) {

        animal.eat;

    }</code></pre>
<p>方法三：方法返回（作返回值：返回任意子类对象）</p>
<pre><code> public static Animal func(){
        return new Cat("dog",2);
    }</code></pre>
<blockquote>
<p>优点：让代码实现更简单灵活</p>
<p>缺陷：不能调用到子类特有的方法</p>
</blockquote>
<h2 id="%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B%EF%BC%9A%E7%88%B6%E7%B1%BB%E5%BC%95%E7%94%A8%E5%86%8D%E8%BF%98%E5%8E%9F%E4%B8%BA%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1">向下转型：父类引用再还原为子类对象</h2>
<pre><code>public class Test {
    public static void main(String[] args) {

        Animal animal = new Cat("haha",2);

        if(animal instanceof Cat){
            Cat cat = (Cat) animal;
            cat.catchMouse();
        }
    }
}</code></pre>
<p>为了提高向下转型的安全性，引入了instanceof，如果该表达式为true，则可以安全转换</p>
<blockquote>
<p><strong>“ 本期的分享就到这里了， 记得给博主一个三连哈，你的支持是我创作的最大动力！</strong></p>
</blockquote>
<p><img alt="ced485cbb11e458d81a746890b32cf3f.gif" src="https://img-blog.csdnimg.cn/ced485cbb11e458d81a746890b32cf3f.gif"/></p>
<p></p>
</div>
</div>