<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<p id="main-toc"><strong>目录</strong></p>
<p id="1.%20%E6%A0%88%EF%BC%88Stack%EF%BC%89%E4%B9%8B%E6%A6%82%E5%BF%B5-toc" style="margin-left:0px;"><a href="#1.%20%E6%A0%88%EF%BC%88Stack%EF%BC%89%E4%B9%8B%E6%A6%82%E5%BF%B5">1. 栈（Stack）之概念</a></p>
<p id="2.%20%E6%A0%88%EF%BC%88Stack%EF%BC%89%E4%B9%8B%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><a href="#2.%20%E6%A0%88%EF%BC%88Stack%EF%BC%89%E4%B9%8B%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0">2. 栈（Stack）之模拟实现</a></p>
<p id="3.%20%E6%A0%88%EF%BC%88Stack%EF%BC%89%E4%B9%8B%E4%BD%BF%E7%94%A8-toc" style="margin-left:0px;"><a href="#3.%20%E6%A0%88%EF%BC%88Stack%EF%BC%89%E4%B9%8B%E4%BD%BF%E7%94%A8">3. 栈（Stack）之使用</a></p>
<p id="4.%E6%A0%88%EF%BC%88Stack%EF%BC%89%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:0px;"><a href="#4.%E6%A0%88%EF%BC%88Stack%EF%BC%89%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">4.栈（Stack）之使用场景</a></p>
<p id="4.1%20%E6%94%B9%E5%8F%98%E5%85%83%E7%B4%A0%E7%9A%84%E5%BA%8F%E5%88%97-toc" style="margin-left:40px;"><a href="#4.1%20%E6%94%B9%E5%8F%98%E5%85%83%E7%B4%A0%E7%9A%84%E5%BA%8F%E5%88%97">4.1 改变元素的序列</a></p>
<p id="4.2%20%E5%B0%86%E9%80%92%E5%BD%92%E8%BD%AC%E5%8C%96%E4%B8%BA%E5%BE%AA%E7%8E%AF-toc" style="margin-left:40px;"><a href="#4.2%20%E5%B0%86%E9%80%92%E5%BD%92%E8%BD%AC%E5%8C%96%E4%B8%BA%E5%BE%AA%E7%8E%AF">4.2 将递归转化为循环</a></p>
<p id="4.3%C2%A0%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D-toc" style="margin-left:40px;"><a href="#4.3%C2%A0%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D">4.3 括号匹配</a></p>
<p id="4.4%20%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC-toc" style="margin-left:40px;"><a href="#4.4%20%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC">4.4 逆波兰表达式求值</a></p>
<p id="4.5%20%E5%87%BA%E6%A0%88%E5%85%A5%E6%A0%88%E6%AC%A1%E5%BA%8F%E5%8C%B9%E9%85%8D-toc" style="margin-left:40px;"><a href="#4.5%20%E5%87%BA%E6%A0%88%E5%85%A5%E6%A0%88%E6%AC%A1%E5%BA%8F%E5%8C%B9%E9%85%8D">4.5 出栈入栈次序匹配</a></p>
<hr id="hr-toc"/>
<p></p>
<h1 id="1.%20%E6%A0%88%EF%BC%88Stack%EF%BC%89%E4%B9%8B%E6%A6%82%E5%BF%B5"><span style="color:#ff9900;">1. 栈（Stack）之概念</span></h1>
<p><span style="color:#0d0016;"><strong>首先明确：</strong></span></p>
<blockquote>
<p><span style="color:#38d8f0;"><strong>栈是一种</strong></span><span style="color:#fe2c24;"><strong>特殊的线性表</strong></span><span style="color:#38d8f0;"><strong>，它特殊在只能在</strong></span><span style="color:#fe2c24;"><strong>一端进行插入删除操作</strong></span><span style="color:#38d8f0;"><strong>，并且最重要的是</strong></span><span style="color:#fe2c24;"><strong>先进后出</strong></span></p>
</blockquote>
<p><img alt="" height="358" src="image\89eb55bf018b4401ad9524f887a2ea31.png" width="881"/></p>
<blockquote>
<p><span style="color:#fe2c24;"><strong>（1）栈顶：进行数据插入和删除操作的一端 </strong></span></p>
<p><span style="color:#fe2c24;"><strong>（2）栈顶：栈顶的另一端</strong></span></p>
<p><span style="color:#fe2c24;"><strong>（3）入栈：栈的插入操作，也叫做压栈/进栈，</strong></span><span style="color:#0d0016;"><strong>入数据在栈顶</strong></span></p>
<p><span style="color:#fe2c24;"><strong>（4）出站：栈的删除操作，</strong></span><span style="color:#0d0016;"><strong>出数据也在栈顶</strong></span></p>
</blockquote>
<p><span style="color:#ff9900;"><strong> 下面理解一下，</strong></span><span style="color:#a2e043;"><strong>先进后出</strong></span><span style="color:#ff9900;"><strong>，看图解</strong></span></p>
<p><img alt="" height="301" src="image\bec27a5ba4724c7ab2ed630ba182024e.png" width="1200"/></p>
<p>分析一下，</p>
<p><span style="color:#ff9900;"><strong>1. 栈是先进后出的，那么入栈和出栈的时间复杂度是多少</strong></span></p>
<blockquote>
<p><span style="color:#956fe7;"><strong>因为入栈和出栈的数据都是在栈顶进行操作的 ，所以</strong></span></p>
<p><span style="color:#fe2c24;"><strong>入栈时间复杂度O（1）  出栈时间复杂度O（1）</strong></span></p>
</blockquote>
<p><span style="color:#ff9900;"><strong>2. 前面说的顺序存储的方式，那么栈的链式存储是什么样的</strong></span></p>
<blockquote>
<p><span style="color:#0d0016;"><strong> 假设栈是以单向链表存储，那么插入数据有头插和尾插</strong></span></p>
<p><span style="color:#956fe7;"><strong>（1）入栈是尾插法，那么时间复杂度就是O（N）</strong></span></p>
<p><span style="color:#956fe7;"><strong>         出栈，删除尾结点也是O（N）        </strong></span></p>
<p><span style="color:#956fe7;"><strong>（2）入栈是头插法，那么时间复杂度是O（1）从头结点插入不需要遍历链表</strong></span></p>
<p><span style="color:#956fe7;"><strong>          出栈，删除头结点就是O（1）        </strong></span></p>
<p><span style="color:#a2e043;"><strong>所以当栈的存储方式是链式时，并且是单链表，那么对比下来，</strong></span></p>
<p><span style="color:#fe2c24;"><strong>入栈就选头插法，出栈就删除头结点</strong></span></p>
</blockquote>
<p><span style="color:#ff9900;"><strong>3. 如果是以双向链表来看做栈，那么从哪里入哪里出 </strong></span></p>
<blockquote>
<p><span style="color:#ff9900;"><strong>（1）从头入栈，从头出栈</strong></span></p>
<p><span style="color:#ff9900;"><strong>（2）从尾入栈，从尾出栈</strong></span></p>
<p><span style="color:#ff9900;"><strong>两种时间复杂度都是O（1）因为双向链表有头结点和尾结点，两边入栈出栈都一样</strong></span></p>
</blockquote>
<hr/>
<p></p>
<h1 id="2.%20%E6%A0%88%EF%BC%88Stack%EF%BC%89%E4%B9%8B%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0"><span style="color:#a2e043;">2. 栈（Stack）之模拟实现</span></h1>
<blockquote>
<p><span style="color:#fe2c24;"><strong>栈继承了Vector，Vector和ArrayList类似，都是动态的顺序表，不过Vector的线程是安全的</strong></span></p>
</blockquote>
<p style="text-align:center;"><span style="color:#a2e043;"><img alt="" height="400" src="image\d53dd5de1429498bb5c312b22ca5dc5f.png" width="565"/></span></p>
<p><span style="color:#956fe7;"><strong>先写一个栈</strong></span></p>
<pre><code class="language-java">public int[] elem;
    public int usedSize;

    public static final int DEFAULT_CAPATI = 10;

    public MyStack() {
        elem = new int[DEFAULT_CAPATI];
    }</code></pre>
<p> <span style="color:#956fe7;"><strong> 1.入栈push()</strong></span></p>
<p><span style="color:#ff9900;"><strong>入栈前先要判断栈是否满的isFull()</strong></span></p>
<pre><code class="language-java">    public boolean isFull() {
        if (usedSize == elem.length) {
            return true;
        }
    return false;
    }</code></pre>
<pre><code class="language-java">    public void push(int val) {
        //判断栈满
        if (isFull()) {
            elem = Arrays.copyOf(elem,2*elem.length);
        }
        elem[usedSize] = val;
        usedSize++;
    }</code></pre>
<p><span style="color:#956fe7;"><strong>2.删除栈顶元素pos()</strong></span></p>
<p><span style="color:#ff9900;"><strong>删除栈顶元素前，先判断栈空isEmpty()</strong></span></p>
<pre><code class="language-java">    public boolean isEmpty() {
        return usedSize == 0;
    }</code></pre>
<p><span style="color:#ff9900;"><strong>如果栈是空的，还要写一个异常EmptyStackException</strong></span></p>
<pre><code class="language-java">public class EmptyStackException extends RuntimeException{
    public EmptyStackException() {

    }
    public EmptyStackException(String msg) {
        super(msg);
    }
}</code></pre>
<pre><code>    public int pop() {
        if (isEmpty()) {
            throw new EmptyStackException("栈是空的");
        }
        int oldVal = elem[usedSize-1];
        usedSize--;
        return oldVal;
    }</code></pre>
<p> <span style="color:#956fe7;"><strong>3.获取栈顶元素，不删除peek()</strong></span></p>
<pre><code class="language-java">    public int peek() {
        if (isEmpty()) {
            throw new EmptyStackException("栈是空的");
        }
        return elem[usedSize-1];
    }</code></pre>
<p><span style="color:#956fe7;"><strong>4.获取中有效元素个数getUsedSize()</strong></span></p>
<pre><code class="language-java">    public int getUsedSize() {
        return usedSize;
    }</code></pre>
<hr/>
<p></p>
<h1 id="3.%20%E6%A0%88%EF%BC%88Stack%EF%BC%89%E4%B9%8B%E4%BD%BF%E7%94%A8"><span style="color:#4da8ee;">3. 栈（Stack）之使用</span></h1>
<pre><code class="language-java">    public static void main(String[] args) {
        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
        stack.push(2);
        stack.push(3);
        stack.push(4);
        stack.push(7);
        System.out.println(stack.size());
        System.out.println(stack.peek());
        stack.pop();
        System.out.println(stack.pop());
    }</code></pre>
<hr/>
<p> </p>
<h1 id="4.%E6%A0%88%EF%BC%88Stack%EF%BC%89%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span style="color:#956fe7;">4.栈（Stack）之使用场景</span></h1>
<h2 id="4.1%20%E6%94%B9%E5%8F%98%E5%85%83%E7%B4%A0%E7%9A%84%E5%BA%8F%E5%88%97"><span style="color:#fe2c24;"><strong>4.1 改变元素的序列</strong></span></h2>
<p><span style="color:#fe2c24;"><strong>（1）先看牛客上的一道题</strong></span></p>
<p><img alt="" height="104" src="image\43cc35cb78de49418b42bd6cfb7b3c8d.png" width="453"/> </p>
<p> 分析一下 ，答案选C<img alt="" height="583" src="image\6c4e451be2964db399d0736210ee0f8b.png" width="861"/></p>
<blockquote>
<p><span style="color:#ff9900;"><strong>（2） 若进栈序列为 1,2,3,4 ，进栈过程中可以出栈，则下列不可能的一个出栈序列是（） </strong></span></p>
<div>
<span style="color:#ff9900;"><strong>             A: 1,4,3,2      B: 2,3,4,1      C: 3,1,4,2       D: 3,4,2,1 </strong></span>
</div>
</blockquote>
<p><span style="color:#fe2c24;"><strong> 分析一下，答案选C</strong></span></p>
<p><img alt="" height="271" src="image\b0e3f94a7f024a65a7bc50ee6cfb5e26.png" width="1200"/> </p>
<blockquote>
<div>
<span style="color:#4da8ee;"><strong>2.一个栈的初始状态为空。现将元素1、2、3、4、5、A、B、C、D、E依次入栈，然后再依次出栈，则元素出栈的顺序是（）。 </strong></span>
</div>
<div>
<span style="color:#4da8ee;"><strong>A: 12345ABCDE       B: EDCBA54321      C: ABCDE12345        D: 54321EDCBA </strong></span>
</div>
</blockquote>
<div>
<span style="color:#fe2c24;"><strong>分析一下，答案选B</strong></span>
</div>
<p> <img alt="" height="197" src="image\5de33be05c294395958fafc436cf8ad2.png" width="304"/></p>
<hr/>
<p> </p>
<h2 id="4.2%20%E5%B0%86%E9%80%92%E5%BD%92%E8%BD%AC%E5%8C%96%E4%B8%BA%E5%BE%AA%E7%8E%AF"><span style="color:#ff9900;">4.2 将递归转化为循环</span></h2>
<p><span style="color:#ff9900;"><strong>写一个逆序打印链表</strong></span></p>
<p><span style="color:#956fe7;"><strong>（1）递归</strong></span></p>
<pre><code class="language-java">public class Demo01 {
    static class Node{
        public int val;
        public Node next;
        public Node(int val) {
            this.val = val;
        }
    }
    public Node head;
    public void printList(Node head) {
        if (head == null) {
            return;
        }
        if (head.next == null) {
            System.out.print(head.val + " ");
            return;
        }
        printList(head.next);
        System.out.print(head.val + " ");
    }
}</code></pre>
<p><span style="color:#4da8ee;"><strong>（2）非递归实现</strong></span></p>
<p><span style="color:#4da8ee;"><strong>既然栈是先进后出的，那么可以将数字依次放进去，然后再pop取出栈顶元素，打印出来，这不就实现了逆序打印</strong></span></p>
<pre><code class="language-java">    public void printList2(Node head) {
        Stack&lt;Node&gt; stack = new Stack&lt;&gt;();
        Node cur = head;
        //将元素全部依次放入栈中
        while(cur != null) {
            stack.push(cur);
            cur = cur.next;
        }
        //给栈pop取出栈顶元素然后拿出val打印
        while(!stack.empty()) {
            Node top = stack.pop();
            System.out.println(top.val + " ");
        }
    }</code></pre>
<hr/>
<h2 id="4.3%C2%A0%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D"><span style="color:#a2e043;">4.3</span><span style="color:#4da8ee;"> </span><span style="color:#a2e043;">括号匹配</span></h2>
<p><span style="color:#ff9900;"><strong>链接</strong></span><span style="color:#a2e043;">   </span><a href="https://leetcode.cn/problems/valid-parentheses/" title="20. 有效的括号 - 力扣（LeetCode）">20. 有效的括号 - 力扣（LeetCode）</a></p>
<p><span style="color:#ff9900;"><strong>题目要求</strong></span></p>
<p><img alt="" height="196" src="image\454a30e1f20045d4a3fef23931ba49cb.png" width="697"/></p>
<p><span style="color:#ff9900;"><strong>分析一下</strong></span></p>
<p><img alt="" height="403" src="image\5ad6eaf3dc614400b46e40951e289e6e.png" width="949"/></p>
<p> <span style="color:#ff9900;"><strong>上代码</strong></span></p>
<pre><code class="language-java">class Solution {
    public boolean isValid(String s) {
        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();
        for(int i = 0; i &lt; s.length(); i++ ) {
            char ch = s.charAt(i);
            if(ch == '(' || ch == '[' || ch == '{') {
                stack.push(ch);
            }else {
                //此时ch 是右括号
                //说明走到右边括号了
                if(stack.empty()) {
                    //遇到有括号了，但是栈空了，说明1.右括号多
                    return false;
                }
                char top = stack.peek();
                if(ch == ')' &amp;&amp; top == '(' || ch == ']' &amp;&amp; top == '[' || ch == '}' &amp;&amp; top == '{') {
                    //说明当前字符是匹配的
                    stack.pop();
                }else {
                    //2.左右括号不匹配
                    return false;
                }
            }
        }
        if(stack.empty()) {
            return true;
        }else {
            //3.说明是左括号多
            return false;
        }
    }
}</code></pre>
<hr/>
<p> </p>
<h2 id="4.4%20%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span style="color:#4da8ee;">4.4 逆波兰表达式求值</span></h2>
<p>链接<a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/" title=" 150. 逆波兰表达式求值 - 力扣（LeetCode）"> 150. 逆波兰表达式求值 - 力扣（LeetCode）</a></p>
<p>在说这道题前先明白<span style="color:#fe2c24;"><strong> 逆波兰表达式又叫做后缀表达式</strong></span></p>
<p><span style="color:#ff9900;"><strong>（1）后缀表达式又可以通过中缀表达式来转化出来（考研-选择题）</strong></span></p>
<p><img alt="" height="328" src="image\066fb4755471490b946b9603cbfb67ae.png" width="440"/></p>
<p><span style="color:#ff9900;"><strong> </strong></span><span style="color:#956fe7;"><strong>所以中缀变后缀三步走</strong></span></p>
<blockquote>
<p><span style="color:#fe2c24;"><strong>（1）按规则加括号  （2）将运算符放括号外面  （3）去掉所有括号</strong></span></p>
</blockquote>
<p><span style="color:#ff9900;"><strong>（2）后缀表达式计算结果（代码题）</strong></span></p>
<p><img alt="" height="523" src="image\49f1fe4d14e24619ba233f14a75ff7f5.png" width="1055"/></p>
<p><span style="color:#ff9900;"><strong>后缀计算4步走</strong></span></p>
<blockquote>
<p><span style="color:#fe2c24;"><strong>（1）将数字按顺序依次放入栈中</strong></span></p>
<p><span style="color:#fe2c24;"><strong>（2）遇到运算符后，拿出栈顶两个元素</strong></span></p>
<p><span style="color:#fe2c24;"><strong>（3）按这样的规则计算（ 次栈顶元素 运算符  栈顶元素  ）</strong></span></p>
<p><span style="color:#fe2c24;"><strong>（4）将计算的结果，继续放入栈中，继续执行前面操作</strong></span></p>
</blockquote>
<p> 好了，下面看一下这道题</p>
<p><img alt="" height="202" src="image\47219a0d83f14cff82d5434ae6aa48f5.png" width="566"/></p>
<p><span style="color:#ff9900;"><strong>根据前面的后缀计算4步走验证一下这个例子</strong></span></p>
<p><img alt="" height="186" src="image\988ca94b37014a2187b019b64dc35754.png" width="424"/></p>
<p> </p>
<pre><code class="language-java">class Solution {
    public int evalRPN(String[] tokens) {
        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
        for(String x : tokens) {
            if(!isOperation(x)) {
                //不是加减乘除
                //字符转成整数.放进栈中
                stack.push(Integer.parseInt(x));
            }else {
                int num2 = stack.pop();
                int num1 = stack.pop();
                switch(x) {
                    case "+": stack.push(num1 + num2);
                    break;
                    case "-": stack.push(num1 - num2);
                    break;
                    case "*": stack.push(num1 * num2);
                    break; 
                    case "/": stack.push(num1 / num2);
                    break;
                }
            }
        }
        return stack.pop();
    }

    private boolean isOperation(String opera) {
        if(opera.equals("+") || opera.equals("-") || opera.equals("*") || opera.equals("/")) {
            return true;
        }
        return false;
    }
}</code></pre>
<p> </p>
<hr/>
<h2 id="4.5%20%E5%87%BA%E6%A0%88%E5%85%A5%E6%A0%88%E6%AC%A1%E5%BA%8F%E5%8C%B9%E9%85%8D"><span style="color:#956fe7;">4.5 出栈入栈次序匹配</span></h2>
<p><span style="color:#ff9900;"><strong>链接</strong></span> <a href="https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106?tpId=13&amp;&amp;tqId=11174&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/coding-interviews/question-ranking" title="栈的压入、弹出序列_牛客题霸_牛客网 (nowcoder.com)">栈的压入、弹出序列_牛客题霸_牛客网 (nowcoder.com)</a></p>
<p><span style="color:#ff9900;"><strong>题目要求：</strong></span></p>
<p><img alt="" height="431" src="image\c0a58d8be1e54551b2e6ca338d606796.png" width="761"/></p>
<p><span style="color:#ff9900;"><strong>分析一下</strong></span></p>
<p><img alt="" height="340" src="image\0c2d1ce262364acabc207c394dd6e030.png" width="437"/></p>
<p><span style="color:#ff9900;"><strong> 上代码 </strong></span></p>
<pre><code class="language-java">import java.util.*;
import java.util.ArrayList;

public class Solution {
    public boolean IsPopOrder(int [] pushA,int [] popA) {
        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
        int j = 0;
      for(int i = 0; i &lt; pushA.length; i++) {
          stack.push(pushA[i]);
          while(j &lt;popA.length &amp;&amp; !stack.empty() &amp;&amp; stack.peek().equals(popA[j])) {
              stack.pop();
              j++;
          }
      }
    return stack.empty();
    }
}</code></pre>
<hr/>
<p></p>
</div>
</div>