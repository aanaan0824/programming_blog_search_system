<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<p id="main-toc"><strong>目录</strong></p>
<p id="%E4%B8%80.set%E4%BB%8B%E7%BB%8D-toc" style="margin-left:0px;"><a href="#%E4%B8%80.set%E4%BB%8B%E7%BB%8D">一.set介绍</a></p>
<p id="1.set%E4%BB%8B%E7%BB%8D-toc" style="margin-left:40px;"><a href="#1.set%E4%BB%8B%E7%BB%8D">1.set介绍</a></p>
<p id="2.insert%20%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px;"><a href="#2.insert%20%E4%BD%BF%E7%94%A8">2.insert 使用</a></p>
<p id="%C2%A0set%E4%B8%AD%E7%9A%84%E6%99%AE%E9%80%9A%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%B0%B1%E6%98%AF%E7%94%A8%E7%9A%84const%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%81%EF%BC%81-toc" style="margin-left:80px;"><a href="#%C2%A0set%E4%B8%AD%E7%9A%84%E6%99%AE%E9%80%9A%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%B0%B1%E6%98%AF%E7%94%A8%E7%9A%84const%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%81%EF%BC%81"> set中的普通迭代器就是用的const迭代器！！</a></p>
<p id="3.find-toc" style="margin-left:40px;"><a href="#3.find">3.find</a></p>
<p id="set%3A%3Afind%E5%92%8Cstd%3A%3Afind%E5%AF%B9%E6%AF%94-toc" style="margin-left:80px;"><a href="#set%3A%3Afind%E5%92%8Cstd%3A%3Afind%E5%AF%B9%E6%AF%94">set::find和std::find对比</a></p>
<p id="4.erase-toc" style="margin-left:40px;"><a href="#4.erase">4.erase</a></p>
<p id="5.swap%20%E6%A0%B9%E8%8A%82%E7%82%B9%E4%BA%A4%E6%8D%A2-toc" style="margin-left:40px;"><a href="#5.swap%20%E6%A0%B9%E8%8A%82%E7%82%B9%E4%BA%A4%E6%8D%A2">5.swap 根节点交换</a></p>
<p id="6.count%20%E6%AF%94find%E6%96%B9%E4%BE%BF-toc" style="margin-left:40px;"><a href="#6.count%20%E6%AF%94find%E6%96%B9%E4%BE%BF">6.count 比find方便</a></p>
<p id="7.lower_bound%EF%BC%9A%E8%BF%94%E5%9B%9E%3E%3D%20val%E5%BE%97%E4%BD%8D%E7%BD%AE%E8%BF%AD%E4%BB%A3%E5%99%A8-toc" style="margin-left:40px;"><a href="#7.lower_bound%EF%BC%9A%E8%BF%94%E5%9B%9E%3E%3D%20val%E5%BE%97%E4%BD%8D%E7%BD%AE%E8%BF%AD%E4%BB%A3%E5%99%A8">7.lower_bound：返回&gt;= val得位置迭代器</a></p>
<p id="%EF%BC%881%EF%BC%89lower_bound-toc" style="margin-left:80px;"><a href="#%EF%BC%881%EF%BC%89lower_bound">（1）lower_bound</a></p>
<p id="%E7%94%A8%E9%80%94%EF%BC%9A%E4%B8%BE%E4%BE%8B%EF%BC%9A%E8%A6%81%E6%B1%82%E5%88%A0%E9%99%A4%3E%3Dx%E7%9A%84%E6%89%80%E6%9C%89%E5%80%BC%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E7%94%A8%E9%80%94%EF%BC%9A%E4%B8%BE%E4%BE%8B%EF%BC%9A%E8%A6%81%E6%B1%82%E5%88%A0%E9%99%A4%3E%3Dx%E7%9A%84%E6%89%80%E6%9C%89%E5%80%BC%EF%BC%9A">用途：举例：要求删除&gt;=x的所有值：</a></p>
<p id="%EF%BC%882%EF%BC%89upper_bound%C2%A0%E8%BF%94%E5%9B%9E%3Ex%E4%BD%8D%E7%BD%AE%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8-toc" style="margin-left:80px;"><a href="#%EF%BC%882%EF%BC%89upper_bound%C2%A0%E8%BF%94%E5%9B%9E%3Ex%E4%BD%8D%E7%BD%AE%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8">（2）upper_bound 返回&gt;x位置的迭代器</a></p>
<p id="8.%20std%3A%3Amultiset%20%E8%B7%9Fset%E6%8E%A5%E5%8F%A3%E4%B8%80%E6%A0%B7%EF%BC%8C%E5%8F%AA%E6%98%AF%E5%85%81%E8%AE%B8%E5%86%97%E4%BD%99%EF%BC%8C%E4%B8%8D%E5%8E%BB%E9%87%8D-toc" style="margin-left:40px;"><a href="#8.%20std%3A%3Amultiset%20%E8%B7%9Fset%E6%8E%A5%E5%8F%A3%E4%B8%80%E6%A0%B7%EF%BC%8C%E5%8F%AA%E6%98%AF%E5%85%81%E8%AE%B8%E5%86%97%E4%BD%99%EF%BC%8C%E4%B8%8D%E5%8E%BB%E9%87%8D">8. std::multiset 跟set接口一样，只是允许冗余，不去重</a></p>
<p id="9.set%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE-toc" style="margin-left:40px;"><a href="#9.set%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE">9.set相关题目</a></p>
<p id="%E4%BA%8C.map%E7%94%A8%E6%B3%95%E4%BB%8B%E7%BB%8D-toc" style="margin-left:0px;"><a href="#%E4%BA%8C.map%E7%94%A8%E6%B3%95%E4%BB%8B%E7%BB%8D">二.map用法介绍</a></p>
<p id="%E5%87%A0%E4%B8%AAmap%E5%92%8Cset%E7%9A%84%E5%86%B7%E7%9F%A5%E8%AF%86%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E5%87%A0%E4%B8%AAmap%E5%92%8Cset%E7%9A%84%E5%86%B7%E7%9F%A5%E8%AF%86%EF%BC%9A">几个map和set的冷知识：</a></p>
<p id="map%EF%BC%9A-toc" style="margin-left:40px;"><a href="#map%EF%BC%9A">map：</a></p>
<p id="%E2%91%A0map%E6%98%AFC%2B%2B98%E4%B8%AD%E5%B7%B2%E5%AD%98%E5%9C%A8%E7%9A%84%EF%BC%8Cunordered_map%E6%98%AFC%2B%2B11%E4%B8%AD%E6%89%8D%E6%9C%89%E7%9A%84-toc" style="margin-left:80px;"><a href="#%E2%91%A0map%E6%98%AFC%2B%2B98%E4%B8%AD%E5%B7%B2%E5%AD%98%E5%9C%A8%E7%9A%84%EF%BC%8Cunordered_map%E6%98%AFC%2B%2B11%E4%B8%AD%E6%89%8D%E6%9C%89%E7%9A%84">①map是C++98中已存在的，unordered_map是C++11中才有的</a></p>
<p id="%E2%91%A1map%E4%B8%AD%E9%83%BD%E9%87%8D%E8%BD%BD%E4%BA%86%5B%5D%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%8Cmultimap%E4%B8%AD%E6%B2%A1%E6%9C%89%E9%87%8D%E8%BD%BD%5B%5D%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%8Cset%E4%B9%9F%E6%B2%A1%E6%9C%89%E9%87%8D%E8%BD%BD%5B%5D%E3%80%82-toc" style="margin-left:80px;"><a href="#%E2%91%A1map%E4%B8%AD%E9%83%BD%E9%87%8D%E8%BD%BD%E4%BA%86%5B%5D%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%8Cmultimap%E4%B8%AD%E6%B2%A1%E6%9C%89%E9%87%8D%E8%BD%BD%5B%5D%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%8Cset%E4%B9%9F%E6%B2%A1%E6%9C%89%E9%87%8D%E8%BD%BD%5B%5D%E3%80%82">②map中都重载了[]运算符，multimap中没有重载[]运算符，set也没有重载[]。</a></p>
<p id="%E2%91%A2map%E4%B8%ADkey%E4%B8%8D%E8%83%BD%E4%BF%AE%E6%94%B9%EF%BC%8C%E5%9B%A0%E4%B8%BA%E5%A6%82%E6%9E%9C%E4%BF%AE%E6%94%B9%E4%BA%86%E5%B0%B1%E4%B8%8D%E8%83%BD%E4%BF%9D%E8%AF%81%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%9C%89%E5%BA%8F%E7%89%B9%E6%80%A7%E4%BA%86-toc" style="margin-left:80px;"><a href="#%E2%91%A2map%E4%B8%ADkey%E4%B8%8D%E8%83%BD%E4%BF%AE%E6%94%B9%EF%BC%8C%E5%9B%A0%E4%B8%BA%E5%A6%82%E6%9E%9C%E4%BF%AE%E6%94%B9%E4%BA%86%E5%B0%B1%E4%B8%8D%E8%83%BD%E4%BF%9D%E8%AF%81%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%9C%89%E5%BA%8F%E7%89%B9%E6%80%A7%E4%BA%86">③map中key不能修改，因为如果修改了就不能保证红黑树的有序特性了</a></p>
<p id="set%EF%BC%9A-toc" style="margin-left:40px;"><a href="#set%EF%BC%9A">set：</a></p>
<p id="%E2%91%A0set%E4%B8%AD%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%AD%98%E5%82%A8%E9%94%AE%E5%80%BC%E5%AF%B9%EF%BC%8C%E5%AE%9E%E4%BE%8B%E5%8C%96set%E6%97%B6%EF%BC%8C%E5%B0%86set%E4%B8%AD%E5%85%83%E7%B4%A0%E7%B1%BB%E5%9E%8B%E8%AE%BE%E7%BD%AE%E4%B8%BApair%E5%8D%B3%E5%8F%AF-toc" style="margin-left:80px;"><a href="#%E2%91%A0set%E4%B8%AD%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%AD%98%E5%82%A8%E9%94%AE%E5%80%BC%E5%AF%B9%EF%BC%8C%E5%AE%9E%E4%BE%8B%E5%8C%96set%E6%97%B6%EF%BC%8C%E5%B0%86set%E4%B8%AD%E5%85%83%E7%B4%A0%E7%B1%BB%E5%9E%8B%E8%AE%BE%E7%BD%AE%E4%B8%BApair%E5%8D%B3%E5%8F%AF">①set中也可以存储键值对，实例化set时，将set中元素类型设置为pair即可</a></p>
<p id="%E2%91%A1set%E9%BB%98%E8%AE%A4%E6%98%AF%E5%8D%87%E5%BA%8F%EF%BC%8C%E4%BD%86%E6%98%AF%E5%85%B6%E5%86%85%E9%83%A8%E9%BB%98%E8%AE%A4%E4%B8%8D%E6%98%AF%E6%8C%89%E7%85%A7%E5%A4%A7%E4%BA%8E%E6%AF%94%E8%BE%83%EF%BC%8C%E8%80%8C%E6%98%AF%E6%8C%89%E7%85%A7%20less%E5%B0%8F%E4%BA%8E%E6%AF%94%E8%BE%83-toc" style="margin-left:80px;"><a href="#%E2%91%A1set%E9%BB%98%E8%AE%A4%E6%98%AF%E5%8D%87%E5%BA%8F%EF%BC%8C%E4%BD%86%E6%98%AF%E5%85%B6%E5%86%85%E9%83%A8%E9%BB%98%E8%AE%A4%E4%B8%8D%E6%98%AF%E6%8C%89%E7%85%A7%E5%A4%A7%E4%BA%8E%E6%AF%94%E8%BE%83%EF%BC%8C%E8%80%8C%E6%98%AF%E6%8C%89%E7%85%A7%20less%E5%B0%8F%E4%BA%8E%E6%AF%94%E8%BE%83">②set默认是升序，但是其内部默认不是按照大于比较，而是按照 less小于比较</a></p>
<p id="%E2%91%A2map%E5%92%8Cset%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E9%83%BD%E6%98%AFO(log_2N)-toc" style="margin-left:80px;"><a href="#%E2%91%A2map%E5%92%8Cset%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E9%83%BD%E6%98%AFO%28log_2N%29">③map和set查询的时间复杂度都是O(log_2N)</a></p>
<p id="%E2%91%A3map%E5%92%8Cset%E5%BA%95%E5%B1%82%E9%83%BD%E6%98%AF%E4%BD%BF%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91%E5%AE%9E%E7%8E%B0%E7%9A%84-toc" style="margin-left:80px;"><a href="#%E2%91%A3map%E5%92%8Cset%E5%BA%95%E5%B1%82%E9%83%BD%E6%98%AF%E4%BD%BF%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91%E5%AE%9E%E7%8E%B0%E7%9A%84">④map和set底层都是使用红黑树实现的</a></p>
<p id="1.pair%E5%92%8Cmake_pair-toc" style="margin-left:40px;"><a href="#1.pair%E5%92%8Cmake_pair">1.pair和make_pair</a></p>
<p id="%EF%BC%881%EF%BC%89pair%E9%94%AE%E5%80%BC%E5%AF%B9%20%E7%9A%84%E4%BB%8B%E7%BB%8D-toc" style="margin-left:80px;"><a href="#%EF%BC%881%EF%BC%89pair%E9%94%AE%E5%80%BC%E5%AF%B9%20%E7%9A%84%E4%BB%8B%E7%BB%8D">（1）pair键值对 的介绍</a></p>
<p id="%EF%BC%882%EF%BC%89make_pair%20%E4%BB%8B%E7%BB%8D-toc" style="margin-left:80px;"><a href="#%EF%BC%882%EF%BC%89make_pair%20%E4%BB%8B%E7%BB%8D">（2）make_pair 介绍</a></p>
<p id="2.map%E7%9A%84%E9%81%8D%E5%8E%86-toc" style="margin-left:40px;"><a href="#2.map%E7%9A%84%E9%81%8D%E5%8E%86">2.map的遍历</a></p>
<p id="%EF%BC%881%EF%BC%89%E8%8B%B1%E6%B1%89%E5%AD%97%E5%85%B8%E7%9A%84%E9%81%8D%E5%8E%86-toc" style="margin-left:80px;"><a href="#%EF%BC%881%EF%BC%89%E8%8B%B1%E6%B1%89%E5%AD%97%E5%85%B8%E7%9A%84%E9%81%8D%E5%8E%86">（1）英汉字典的遍历</a></p>
<p id="%EF%BC%882%EF%BC%89%E8%AE%B0%E5%BD%95%E6%B0%B4%E6%9E%9C%E6%AC%A1%E6%95%B0-toc" style="margin-left:80px;"><a href="#%EF%BC%882%EF%BC%89%E8%AE%B0%E5%BD%95%E6%B0%B4%E6%9E%9C%E6%AC%A1%E6%95%B0">（2）记录水果次数</a></p>
<p id="3.insert%E5%86%99%E6%B3%95%E6%8F%90%E9%AB%98%20%E8%AE%B0%E5%BD%95%E6%B0%B4%E6%9E%9C%E6%AC%A1%E6%95%B0%20%E7%9A%84%E6%95%88%E7%8E%87%EF%BC%88%E4%B8%8D%E8%BF%99%E4%B9%88%E5%86%99%EF%BC%8C%E5%8F%AA%E6%98%AF%E4%B8%BA%5B%5D%E5%81%9A%E9%93%BA%E5%9E%AB%EF%BC%89-toc" style="margin-left:40px;"><a href="#3.insert%E5%86%99%E6%B3%95%E6%8F%90%E9%AB%98%20%E8%AE%B0%E5%BD%95%E6%B0%B4%E6%9E%9C%E6%AC%A1%E6%95%B0%20%E7%9A%84%E6%95%88%E7%8E%87%EF%BC%88%E4%B8%8D%E8%BF%99%E4%B9%88%E5%86%99%EF%BC%8C%E5%8F%AA%E6%98%AF%E4%B8%BA%5B%5D%E5%81%9A%E9%93%BA%E5%9E%AB%EF%BC%89">3.insert写法提高 记录水果次数 的效率（不这么写，只是为[]做铺垫）</a></p>
<p id="4.operator%5B%5D%20%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%C2%A0-toc" style="margin-left:40px;"><a href="#4.operator%5B%5D%20%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%C2%A0">4.operator[] 运算符重载 </a></p>
<p id="%EF%BC%881%EF%BC%89%20%E6%8F%90%E9%AB%98%20%E8%AE%B0%E5%BD%95%E6%B0%B4%E6%9E%9C%E6%AC%A1%E6%95%B0%20%E7%9A%84%E6%95%88%E7%8E%87%E7%9A%84%E7%9C%9F%E6%AD%A3%E5%86%99%E6%B3%95%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%EF%BC%881%EF%BC%89%20%E6%8F%90%E9%AB%98%20%E8%AE%B0%E5%BD%95%E6%B0%B4%E6%9E%9C%E6%AC%A1%E6%95%B0%20%E7%9A%84%E6%95%88%E7%8E%87%E7%9A%84%E7%9C%9F%E6%AD%A3%E5%86%99%E6%B3%95%EF%BC%9A">（1） 提高 记录水果次数 的效率的真正写法：</a></p>
<p id="%EF%BC%882%EF%BC%89%20%E5%AD%97%E5%85%B8%E4%B8%AD%E5%88%A9%E7%94%A8%5B%5D%E6%8F%92%E5%85%A5%E6%88%96%E4%BF%AE%E6%94%B9%20%E7%A4%BA%E4%BE%8B-toc" style="margin-left:80px;"><a href="#%EF%BC%882%EF%BC%89%20%E5%AD%97%E5%85%B8%E4%B8%AD%E5%88%A9%E7%94%A8%5B%5D%E6%8F%92%E5%85%A5%E6%88%96%E4%BF%AE%E6%94%B9%20%E7%A4%BA%E4%BE%8B">（2） 字典中利用[]插入或修改 示例</a></p>
<p id="5.multimap%20%E5%85%81%E8%AE%B8%E9%94%AE%E5%80%BC%E5%86%97%E4%BD%99-toc" style="margin-left:40px;"><a href="#5.multimap%20%E5%85%81%E8%AE%B8%E9%94%AE%E5%80%BC%E5%86%97%E4%BD%99">5.multimap 允许键值冗余</a></p>
<p id="%E4%B8%89.%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE-toc" style="margin-left:0px;"><a href="#%E4%B8%89.%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE">三.相关题目</a></p>
<p id="%E3%80%82692.%20%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%8D%95%E8%AF%8D-toc" style="margin-left:40px;"><a href="#%E3%80%82692.%20%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%8D%95%E8%AF%8D">。692. 前K个高频单词</a></p>
<p id="%E5%9B%9B.%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><a href="#%E5%9B%9B.%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0">四.模拟实现</a></p>
<p id="Map.h-toc" style="margin-left:40px;"><a href="#Map.h">Map.h</a></p>
<p id="Set.h-toc" style="margin-left:40px;"><a href="#Set.h">Set.h</a></p>
<p id="RBTree.h-toc" style="margin-left:40px;"><a href="#RBTree.h">RBTree.h</a></p>
<hr id="hr-toc"/>
<p></p>
<h1 id="%E4%B8%80.set%E4%BB%8B%E7%BB%8D">一.set介绍</h1>
<h2 id="1.set%E4%BB%8B%E7%BB%8D">1.set介绍</h2>
<p>set 是一个K模型的搜索二叉树 #include&lt;set&gt;</p>
<p><img alt="" height="167" src="image\963f23125271409a8788b856ec66df4a.png" width="869"/></p>
<p></p>
<h2 id="2.insert%20%E4%BD%BF%E7%94%A8">2.insert 使用</h2>
<p><img alt="" height="243" src="image\c099f111cad1435182374e757a4c543a.png" width="1023"/></p>
<p>(1)和(2)相当于一样，在pos位置插入也会自动排序</p>
<p> insert ：排序 + 去重 </p>
<pre><code class="language-cpp">void test_set1()
{
	set&lt;int&gt; s;
	s.insert(4);
	s.insert(5);
	s.insert(2);
	s.insert(1);
	s.insert(1);
	s.insert(3);
	s.insert(2);
	s.insert(1);


	// 排序 + 去重 
	set&lt;int&gt;::iterator it = s.begin();
	while (it != s.end())
	{
		//*it = 10;    迭代器不支持修改
		cout &lt;&lt; *it &lt;&lt; " ";
		++it;
	}
	cout &lt;&lt; endl;

    for (auto e : s)
	{
		cout &lt;&lt; e &lt;&lt; " ";
	}
	cout &lt;&lt; endl;
}
</code></pre>
<p><img alt="" height="132" src="image\1ad9bb72836147a195e92661a955c171.png" width="216"/></p>
<h3 id="%C2%A0set%E4%B8%AD%E7%9A%84%E6%99%AE%E9%80%9A%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%B0%B1%E6%98%AF%E7%94%A8%E7%9A%84const%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%81%EF%BC%81"> set中的普通迭代器就是用的const迭代器！！</h3>
<p><img alt="" height="77" src="image\fbd4ed41d9af4275baadb25d2707d127.png" width="758"/><br/>  </p>
<h2 id="3.find">3.find</h2>
<p><img alt="" height="128" src="image\b1db6e5ebbc84fd0aa95b5c4832ad4db.png" width="374"/></p>
<p>能找到就返回元素的迭代器，找不到就返回end</p>
<h3 id="set%3A%3Afind%E5%92%8Cstd%3A%3Afind%E5%AF%B9%E6%AF%94">set::find和std::find对比</h3>
<p>set::find 搜索二叉树特性查找，时间复杂度是O(logN)</p>
<p>全局的find 是暴力查找，时间复杂度是O(N)</p>
<p>所以set::find效率更高</p>
<pre><code class="language-cpp">void test_set2()
{
	set&lt;int&gt; s;
	s.insert(4);
	s.insert(5);
	s.insert(2);
	s.insert(1);
	s.insert(1);
	s.insert(3);
	s.insert(2);
	s.insert(1);

	set&lt;int&gt;::iterator pos = s.find(20);  // O(logN)
	if (pos != s.end())
	{
		cout &lt;&lt; "set.find找到了" &lt;&lt; endl;
	}

	pos = find(s.begin(), s.end(), 2); // O(N)
	if (pos != s.end())
	{
		cout &lt;&lt; "find找到了" &lt;&lt; endl;
	}
}</code></pre>
<p></p>
<h2 id="4.erase">4.erase</h2>
<p>size_type就是size_t，也就是unsigned int</p>
<p><img alt="" height="198" src="image\831aff9fd81a43d7a8e0f77526594664.png" width="559"/></p>
<p>(1) void erase (iterator position); 必须加检查if (pos != s.end()) s.erase(pos); 因为有pos时，正常运行，如果没有pos，就会报错。例如：s.erase(pos);</p>
<p>(2)size_ type erase (const value_ type&amp; val) ; 则可以随便删，无论有没有都不报错 例如：s.erase(3)</p>
<p>(3)void erase (iterator first，iterator last) 删的是[ first， last），即不包含 last</p>
<pre><code class="language-cpp">void test_set3()
{
	set&lt;int&gt; s;
	s.insert(4);
	s.insert(5);
	s.insert(2);
	s.insert(1);
	s.insert(1);
	s.insert(3);
	s.insert(2);
	s.insert(1);

	cout &lt;&lt; s.erase(3) &lt;&lt; endl;    //有就返回1
	cout &lt;&lt; s.erase(30) &lt;&lt; endl;   //没有就返回0

	for (auto e : s)
	{
		cout &lt;&lt; e &lt;&lt; " ";
	}
	cout &lt;&lt; endl;

	set&lt;int&gt;::iterator pos = s.find(3);
	if (pos != s.end())
		s.erase(pos);

	for (auto e : s)
	{
		cout &lt;&lt; e &lt;&lt; " ";
	}
	cout &lt;&lt; endl;
</code></pre>
<p><img alt="" height="176" src="image\ce9e04367fba4f2294166222125859a2.png" width="223"/></p>
<h2 id="5.swap%20%E6%A0%B9%E8%8A%82%E7%82%B9%E4%BA%A4%E6%8D%A2">5.swap 根节点交换</h2>
<p><img alt="" height="113" src="image\aad802b5b25e4d4fb7c571f560aa8d58.png" width="329"/></p>
<h2 id="6.count%20%E6%AF%94find%E6%96%B9%E4%BE%BF">6.count 比find方便</h2>
<p><img alt="" height="118" src="image\1bf4cdd980e24c5789395d562080c89f.png" width="555"/></p>
<pre><code class="language-cpp">
	if (s.count(5))
	{
		cout &lt;&lt; "5在" &lt;&lt; endl;
	}

	if (s.find(5) != s.end())
	{
		cout &lt;&lt; "5在" &lt;&lt; endl;
	}</code></pre>
<p>打印：</p>
<p>5在</p>
<p>5在</p>
<p><img alt="" height="207" src="image\a80ee86d3d3242c79ab69d1089c8abf6.png" width="384"/></p>
<p></p>
<h2 id="7.lower_bound%EF%BC%9A%E8%BF%94%E5%9B%9E%3E%3D%20val%E5%BE%97%E4%BD%8D%E7%BD%AE%E8%BF%AD%E4%BB%A3%E5%99%A8">7.lower_bound：返回&gt;= val得位置迭代器</h2>
<h3 id="%EF%BC%881%EF%BC%89lower_bound">（1）lower_bound</h3>
<p>返回&gt;= val得位置迭代器 3返回3位置 6 返回7位置</p>
<p><img alt="" height="139" src="image\99644c01ffb34395a974e414fe467cb0.png" width="497"/></p>
<pre><code class="language-cpp">返回&gt;= val的位置迭代器 3返回3位置 6 返回7位置
    set&lt;int&gt; s;
	s.insert(4);
	s.insert(5);
	s.insert(1);
	s.insert(3);
	s.insert(2);
	s.insert(7);
	s.insert(9);
    set&lt;int&gt;::iterator lowIt = s.lower_bound(3); 存在
	lowIt = s.lower_bound(6); 不存在</code></pre>
<h3 id="%E7%94%A8%E9%80%94%EF%BC%9A%E4%B8%BE%E4%BE%8B%EF%BC%9A%E8%A6%81%E6%B1%82%E5%88%A0%E9%99%A4%3E%3Dx%E7%9A%84%E6%89%80%E6%9C%89%E5%80%BC%EF%BC%9A">用途：举例：要求删除&gt;=x的所有值：</h3>
<pre><code class="language-cpp">void test_set4()
{
	set&lt;int&gt; s;
	s.insert(4);
	s.insert(5);
	s.insert(1);
	s.insert(3);
	s.insert(2);
	s.insert(7);
	s.insert(9);
    for (auto e : s)
	{
		cout &lt;&lt; e &lt;&lt; " ";
	}
	cout &lt;&lt; endl;

	// 要求删除&gt;=x的所有值
	int x;
	cin &gt;&gt; x;
	set&lt;int&gt;::iterator lowIt = s.lower_bound(x);
	s.erase(lowIt, s.end());

	for (auto e : s)
	{
		cout &lt;&lt; e &lt;&lt; " ";
	}
	cout &lt;&lt; endl;
}</code></pre>
<p><img alt="" height="127" src="image\7e1a52fbd322404eafa549d978e96926.png" width="491"/></p>
<h3 id="%EF%BC%882%EF%BC%89upper_bound%C2%A0%E8%BF%94%E5%9B%9E%3Ex%E4%BD%8D%E7%BD%AE%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8">（2）upper_bound 返回&gt;x位置的迭代器</h3>
<p>返回&gt;x位置的迭代器，s.upper_bound(5) 存在5，不存在6，则返回7；s.upper_bound(6) 不存在6，返回7；</p>
<pre><code class="language-cpp">    set&lt;int&gt; s;
	s.insert(4);
	s.insert(5);
	s.insert(1);
	s.insert(3);
	s.insert(2);
	s.insert(7);
	s.insert(9);

	返回&gt;x位置的迭代器  -》 都是返回 7位置的迭代器
	set&lt;int&gt;::iterator upIt = s.upper_bound(5);  // 存在
	upIt = s.upper_bound(6); // 不存在</code></pre>
<p>用途：例如 删除x &lt;=  &lt;= y的区间 删除 [x,y]</p>
<pre><code class="language-cpp">void test_set4()
{
	set&lt;int&gt; s;
	s.insert(4);
	s.insert(5);
	s.insert(1);
	s.insert(3);
	s.insert(2);
	s.insert(7);
	s.insert(8);

	// 返回&gt;= val得位置迭代器  3返回3位置  6 返回7位置
	/*set&lt;int&gt;::iterator lowIt = s.lower_bound(3); 存在
	lowIt = s.lower_bound(6); 不存在*/
	for (auto e : s)
	{
		cout &lt;&lt; e &lt;&lt; " ";
	}
	cout &lt;&lt; endl;

	// 删除x &lt;=  &lt;= y的区间 删除 [x,y]
	int x, y;
	cin &gt;&gt; x &gt;&gt; y;
	auto leftIt = s.lower_bound(x);  // [
	auto rightIt = s.upper_bound(y); // )
	s.erase(leftIt, rightIt);
	for (auto e : s)
	{
		cout &lt;&lt; e &lt;&lt; " ";
	}
	cout &lt;&lt; endl;
}</code></pre>
<p><img alt="" height="135" src="image\eb18ae79b2944faab61903887dc753e8.png" width="538"/></p>
<h2 id="8.%20std%3A%3Amultiset%20%E8%B7%9Fset%E6%8E%A5%E5%8F%A3%E4%B8%80%E6%A0%B7%EF%BC%8C%E5%8F%AA%E6%98%AF%E5%85%81%E8%AE%B8%E5%86%97%E4%BD%99%EF%BC%8C%E4%B8%8D%E5%8E%BB%E9%87%8D">8. std::multiset 跟set接口一样，只是允许冗余，不去重</h2>
<p><img alt="" height="172" src="image\e6f9bee586ee497ab32cf2dd70d20be3.png" width="932"/></p>
<p>插入重复的数时set会去重，multiset不去重，允许冗余</p>
<p>不同：</p>
<p>multiset 的count和erase 返回查找或删除个数</p>
<p>find(x) 多个x的话，find返回中序第一个x</p>
<pre><code class="language-cpp">void test_set6()
{
	multiset&lt;int&gt; s;
	s.insert(4);
	s.insert(5);
	s.insert(2);
	s.insert(1);
	s.insert(1);
	s.insert(3);
	s.insert(2);
	s.insert(1);
	s.insert(3);
	s.insert(3);
	s.insert(3);
	s.insert(3);

	// 排序 
	set&lt;int&gt;::iterator it = s.begin();    //迭代器打印
	while (it != s.end())
	{
		//*it = 10;
		cout &lt;&lt; *it &lt;&lt; " ";
		++it;
	}
	cout &lt;&lt; endl;

	for (auto e : s)        //范围for打印
	{
		cout &lt;&lt; e &lt;&lt; " ";
	}
	cout &lt;&lt; endl;

	cout &lt;&lt; s.count(1) &lt;&lt; endl;    //测试count，打印3，因为1有3个
	cout &lt;&lt; s.erase(1) &lt;&lt; endl;    //测试erase，打印3，因为1有3个
	for (auto e : s)    
	{
		cout &lt;&lt; e &lt;&lt; " ";
	}
	cout &lt;&lt; endl;
                           
	auto pos = s.find(3);         // 多个x的话，find返回中序第一个x
	while (pos != s.end())        //从中序第一个3开始打印完整个
	{
		cout &lt;&lt; *pos &lt;&lt; " ";
		++pos;
	}
	cout &lt;&lt; endl;
}</code></pre>
<p><img alt="" height="218" src="image\0775c8b05eb74cd39333dabcc4fd6884.png" width="346"/></p>
<p> <img alt="" height="177" src="image\a5075a636e4d4596baf10831512be586.png" width="262"/></p>
<h2 id="9.set%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE">9.set相关题目</h2>
<p><a href="https://leetcode.cn/problems/intersection-of-two-arrays/" title="349. 两个数组的交集">349. 两个数组的交集</a></p>
<p><img alt="" height="471" src="image\5a5b961832c14e2f83ff6d1d485c996f.png" width="553"/></p>
<p>方法一：把nums1和nums2分别放进s1和s2中进行去重，再利用范围for把s2中的每个元素在s1中进行查找，如果找到就放进v中。时间复杂度是：O(n*logn) n个节点，每个节点找logn高度次</p>
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {
        //去重
        set&lt;int&gt; s1;
        for(auto e:nums1)
        {
            s1.insert(e);
        }
        //去重
        set&lt;int&gt; s2;
        for(auto e:nums2)
        {
            s2.insert(e);
        }
        vector&lt;int&gt; v;
        for(auto e:s2)
        {
            if(s1.count(e))
            {
                v.push_back(e);
            }
        }
        return v;
    }
};</code></pre>
<p>方法二：</p>
<p><img alt="" height="357" src="image\64cd95b7ac054f3a8b5d0fdb66403182.png" width="467"/></p>
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {
        set&lt;int&gt; s1;
        for(auto e:nums1)
        {
            s1.insert(e);
        }

        set&lt;int&gt; s2;
        for(auto e:nums2)
        {
            s2.insert(e);
        }
        vector&lt;int&gt; v;
        set&lt;int&gt;::iterator it1=s1.begin();
        set&lt;int&gt;::iterator it2=s2.begin();
        while(it1!=s1.end() &amp;&amp; it2!=s2.end())
        {
            if(*it1&gt;*it2)    //相比较，值小的++
            {
                ++it2;
            }
            else if(*it1&lt;*it2)    //相比较，值小的++
            {
                ++it1;
            }
            else                //相比较，值相等就放进v中，同时++
            {
                v.push_back(*it1);
                ++it1;
                ++it2;
            }
        }
        return v;
    }
};</code></pre>
<p></p>
<h1 id="%E4%BA%8C.map%E7%94%A8%E6%B3%95%E4%BB%8B%E7%BB%8D">二.map用法介绍</h1>
<p>map是KV模型的搜索二叉树，<u>insert和[]用法是重点，其他用法参考set</u>        #include&lt;map&gt;</p>
<p><img alt="" height="215" src="image\e5d2c81392e24734a41a483da8fb048d.png" width="925"/></p>
<h2 id="%E5%87%A0%E4%B8%AAmap%E5%92%8Cset%E7%9A%84%E5%86%B7%E7%9F%A5%E8%AF%86%EF%BC%9A">几个map和set的冷知识：</h2>
<h2 id="map%EF%BC%9A">map：</h2>
<h3 id="%E2%91%A0map%E6%98%AFC%2B%2B98%E4%B8%AD%E5%B7%B2%E5%AD%98%E5%9C%A8%E7%9A%84%EF%BC%8Cunordered_map%E6%98%AFC%2B%2B11%E4%B8%AD%E6%89%8D%E6%9C%89%E7%9A%84">①map是C++98中已存在的，unordered_map是C++11中才有的</h3>
<h3 id="%E2%91%A1map%E4%B8%AD%E9%83%BD%E9%87%8D%E8%BD%BD%E4%BA%86%5B%5D%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%8Cmultimap%E4%B8%AD%E6%B2%A1%E6%9C%89%E9%87%8D%E8%BD%BD%5B%5D%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%8Cset%E4%B9%9F%E6%B2%A1%E6%9C%89%E9%87%8D%E8%BD%BD%5B%5D%E3%80%82">②map中都重载了[]运算符，multimap中没有重载[]运算符，<span style="color:#fe2c24;">set</span>也没有重载[]。</h3>
<p>原因：map中key是唯一的，每个key都有与之对应的value，经常需要通过key获取value，因此 map为了形象简单 就重载了[]运算符, multimap中key是可以重复的，如果重载了[]运算符，给定 一个key时，就没有办法返回     value了，因此，multimap中没有重载[]运算符</p>
<h3 id="%E2%91%A2map%E4%B8%ADkey%E4%B8%8D%E8%83%BD%E4%BF%AE%E6%94%B9%EF%BC%8C%E5%9B%A0%E4%B8%BA%E5%A6%82%E6%9E%9C%E4%BF%AE%E6%94%B9%E4%BA%86%E5%B0%B1%E4%B8%8D%E8%83%BD%E4%BF%9D%E8%AF%81%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%9C%89%E5%BA%8F%E7%89%B9%E6%80%A7%E4%BA%86">③map中key不能修改，因为如果修改了就不能保证红黑树的有序特性了</h3>
<h2 id="set%EF%BC%9A">set：</h2>
<h3 id="%E2%91%A0set%E4%B8%AD%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%AD%98%E5%82%A8%E9%94%AE%E5%80%BC%E5%AF%B9%EF%BC%8C%E5%AE%9E%E4%BE%8B%E5%8C%96set%E6%97%B6%EF%BC%8C%E5%B0%86set%E4%B8%AD%E5%85%83%E7%B4%A0%E7%B1%BB%E5%9E%8B%E8%AE%BE%E7%BD%AE%E4%B8%BApair%E5%8D%B3%E5%8F%AF">①set中也可以存储键值对，实例化set时，将set中元素类型设置为pair即可</h3>
<h3 id="%E2%91%A1set%E9%BB%98%E8%AE%A4%E6%98%AF%E5%8D%87%E5%BA%8F%EF%BC%8C%E4%BD%86%E6%98%AF%E5%85%B6%E5%86%85%E9%83%A8%E9%BB%98%E8%AE%A4%E4%B8%8D%E6%98%AF%E6%8C%89%E7%85%A7%E5%A4%A7%E4%BA%8E%E6%AF%94%E8%BE%83%EF%BC%8C%E8%80%8C%E6%98%AF%E6%8C%89%E7%85%A7%20less%E5%B0%8F%E4%BA%8E%E6%AF%94%E8%BE%83">②set默认是升序，但是其内部默认不是按照大于比较，而是按照 less<strong>小于比较</strong></h3>
<p>less是把小的放左边，所以是升序；greater是把大的放左边，所以是降序</p>
<p><img alt="" height="149" src="image\7a2dff96f5b44c478b3147497d5c8210.png" width="237"/></p>
<p></p>
<h3 id="%E2%91%A2map%E5%92%8Cset%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E9%83%BD%E6%98%AFO(log_2N)">③<span style="color:#4da8ee;">map</span>和set查询的时间复杂度都是O(log_2N)</h3>
<p>解释：map和set的底层结构都是红黑树，而红黑树是近似的平衡二叉搜索树，故查询时间 复杂度为O(log_2N)</p>
<h3 id="%E2%91%A3map%E5%92%8Cset%E5%BA%95%E5%B1%82%E9%83%BD%E6%98%AF%E4%BD%BF%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91%E5%AE%9E%E7%8E%B0%E7%9A%84">④<span style="color:#4da8ee;">map</span>和set底层都是使用红黑树实现的</h3>
<p></p>
<h2 id="1.pair%E5%92%8Cmake_pair">1.pair和make_pair</h2>
<h3 id="%EF%BC%881%EF%BC%89pair%E9%94%AE%E5%80%BC%E5%AF%B9%20%E7%9A%84%E4%BB%8B%E7%BB%8D">（1）pair<span style="color:#333333;"><strong>键值对 的</strong></span>介绍</h3>
<div>
<span style="color:#494949;"><strong>用来表示具有一一对应关系的一种结构，该结构中一般只包含两个成员变量key和value，key代 </strong></span>
</div>
<div>
<span style="color:#494949;"><strong>表键值，value表示与key对应的信息</strong>。比如：现在要建立一个英汉互译的字典，那该字典中必然 </span>
</div>
<div>
<span style="color:#494949;">有英文单词与其对应的中文含义，而且，英文单词与其中文含义是一一对应的关系，即通过该应 </span>
</div>
<div>
<span style="color:#494949;">该单词，在词典中就可以找到与其对应的中文含义。 </span>
</div>
<div></div>
<p>pair 打包了KV模型的key和val两个类型的值，c++不支持返回两个值，也就不知道返回key和val哪一个了，所以干脆打包key和val，返回一个pair结构</p>
<p>（value_type 是 <a href="https://legacy.cplusplus.com/pair" title="pair">pair</a>&lt;const key_type,mapped_type&gt;）</p>
<p>pair中的first就相当于KV模型中的key，second相当于KV模型中的val</p>
<p><img alt="" height="376" src="image\82ccf741dc6d4f83bd108de346b92347.png" width="509"/></p>
<h3 id="%EF%BC%882%EF%BC%89make_pair%20%E4%BB%8B%E7%BB%8D">（2）make_pair 介绍</h3>
<p>make_pair 相当于返回了一个pair的匿名对象</p>
<p><img alt="" height="178" src="image\1cc10c1d4bfa491f8d15bc1da49c2f28.png" width="781"/></p>
<h2 id="2.map%E7%9A%84%E9%81%8D%E5%8E%86">2.map的遍历</h2>
<h3 id="%EF%BC%881%EF%BC%89%E8%8B%B1%E6%B1%89%E5%AD%97%E5%85%B8%E7%9A%84%E9%81%8D%E5%8E%86">（1）英汉字典的遍历</h3>
<p>几种插入英汉字典的方式：匿名对象插入，普通对象插入，make_pair插入</p>
<pre><code class="language-cpp">void test_map1()
{
	map&lt;string, string&gt; dict;

	// pair构造函数
	dict.insert(pair&lt;string, string&gt;("sort", "排序")); //匿名对象插入更便捷
	pair&lt;string, string&gt; kv("insert", "插入");    //普通对象插入
	dict.insert(kv);

	// make_pair
	auto ret1 = dict.insert(make_pair("left", "左边"));  //make_pair插入
	auto ret2 = dict.insert(make_pair("left", "剩余"));
	// 遍历
//map&lt;string, string&gt;::iterator it = dict.begin();
	auto it = dict.begin();
	while (it != dict.end())
	{
		//cout &lt;&lt; *it &lt;&lt; " "; // it-&gt;operator*()
		//cout &lt;&lt; (*it).first &lt;&lt; ":" &lt;&lt; (*it).second &lt;&lt; endl;
		cout &lt;&lt; it-&gt;first &lt;&lt; ":" &lt;&lt; it-&gt;second &lt;&lt; endl;
		++it;
	}
	cout &lt;&lt; endl;

	for (const auto&amp; kv : dict)
	{
		cout &lt;&lt; kv.first &lt;&lt; ":" &lt;&lt; kv.second &lt;&lt; endl;
	}
}

int main()
{
	test_map1();
	return 0;
}</code></pre>
<p><img alt="" height="167" src="image\1de873cf2de9447194f53bb22dd5aced.png" width="150"/></p>
<h3 id="%EF%BC%882%EF%BC%89%E8%AE%B0%E5%BD%95%E6%B0%B4%E6%9E%9C%E6%AC%A1%E6%95%B0">（2）记录水果次数</h3>
<pre><code class="language-cpp">void test_map2()
{
	string arr[] = { "苹果", "西瓜", "苹果", "西瓜", "苹果", "苹果", "西瓜", "苹果", "香蕉", "苹果", "香蕉" };
	map&lt;string, int&gt; countMap;
	for (auto&amp; str : arr)
	{
		map&lt;string, int&gt;::iterator it = countMap.find(str);	
		if (it != countMap.end())	//如果countMap中有，就计数加1
		{
			it-&gt;second++;
		}
		else
		{
			countMap.insert(make_pair(str, 1));	//没有就插入水果
		}
	}
	for (auto&amp; str : arr)
	{
		countMap[str]++;
	}
	for (const auto&amp; kv : countMap)
	{
		cout &lt;&lt; kv.first &lt;&lt; ":" &lt;&lt; kv.second &lt;&lt; endl;
	}
}</code></pre>
<p><img alt="" height="105" src="image\549e1e44158d4954a7d3e611e6d4db1e.png" width="118"/></p>
<h2 id="3.insert%E5%86%99%E6%B3%95%E6%8F%90%E9%AB%98%20%E8%AE%B0%E5%BD%95%E6%B0%B4%E6%9E%9C%E6%AC%A1%E6%95%B0%20%E7%9A%84%E6%95%88%E7%8E%87%EF%BC%88%E4%B8%8D%E8%BF%99%E4%B9%88%E5%86%99%EF%BC%8C%E5%8F%AA%E6%98%AF%E4%B8%BA%5B%5D%E5%81%9A%E9%93%BA%E5%9E%AB%EF%BC%89">3.insert写法提高 记录水果次数 的效率（不这么写，只是为[]做铺垫）</h2>
<p><img alt="" height="263" src="image\341b0f1e461047b29ca21bdd89f5d534.png" width="1023"/></p>
<p> <img alt="" height="527" src="image\0ecf9b3ea5614f8a9eafe5c2c5916749.png" width="1200"/></p>
<p></p>
<pre><code class="language-cpp">    string arr[] = { "苹果", "西瓜", "苹果", "西瓜", "苹果", "苹果", "西瓜", "苹果", "香蕉", "苹果", "香蕉" };
	map&lt;string, int&gt; countMap;
	for (auto&amp; str : arr)
	{
pair&lt;map&lt;string, int&gt;::iterator, bool&gt; ret = countMap.insert(make_pair(str, 1));
		//或者 auto ret = countMap.insert(make_pair(str, 1));
		if (ret.second == false)
		{
			ret.first-&gt;second++;
		}
	}
	for (const auto&amp; kv : countMap)
	{
		cout &lt;&lt; kv.first &lt;&lt; ":" &lt;&lt; kv.second &lt;&lt; endl;
	}</code></pre>
<p><img alt="" height="106" src="image\b218021f8863476da91580c7a03fbf66.png" width="98"/></p>
<p>解释：</p>
<p>pair&lt;map&lt;string, int&gt;::iterator, bool&gt;  ret = countMap.insert(make_pair(str, 1)) 插入节点，若插入成功，ret.first这个iterator 存的是新插入节点的迭代器，ret.second 存的是true；若插入失败，ret.first这个iterator 存的是已有的相同节点的迭代器，ret.second 存的是false；插入失败就再记录个数++就行，ret.first-&gt;second++; 用于访问记录水果个数，ret.first 是节点迭代器，ret.first-&gt;second++; 节点中的second用于记录对应水果的个数<img alt="" height="390" src="image\53e109d5a08e4c6db30a181b8f188f65.png" width="1200"/></p>
<h2 id="4.operator%5B%5D%20%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%C2%A0">4.operator[] 运算符重载 </h2>
<p><img alt="" height="137" src="image\27b7ba53859946b48eb56759f8be179f.png" width="384"/></p>
<h3 id="%EF%BC%881%EF%BC%89%20%E6%8F%90%E9%AB%98%20%E8%AE%B0%E5%BD%95%E6%B0%B4%E6%9E%9C%E6%AC%A1%E6%95%B0%20%E7%9A%84%E6%95%88%E7%8E%87%E7%9A%84%E7%9C%9F%E6%AD%A3%E5%86%99%E6%B3%95%EF%BC%9A">（1） 提高 记录水果次数 的效率的真正写法：</h3>
<pre><code class="language-cpp">void test_map2()
{
	string arr[] = { "苹果", "西瓜", "苹果", "西瓜", "苹果", "苹果", "西瓜", "苹果", "香蕉", "苹果", "香蕉" };
	map&lt;string, int&gt; countMap;
	for (auto&amp; str : arr)
	{
		countMap[str]++;
	}

	for (const auto&amp; kv : countMap)
	{
		cout &lt;&lt; kv.first &lt;&lt; ":" &lt;&lt; kv.second &lt;&lt; endl;
	}
}</code></pre>
<p> <img alt="" height="96" src="image\d6f677691c8d485d8c3b610f6dbab4d6.png" width="92"/></p>
<p> 解释：</p>
<p><img alt="" height="1016" src="image\d4aeb88da0394a828bf18fdb973b64f5.png" width="1098"/></p>
<p> countMap[str]++; 中 countMap[str] 返回的是新插入节点中的 次数second 。</p>
<p>如果插入的str不在 对象countMap中，countMap[str]++; 就是<strong>插入</strong>这个节点，迭代器就是新节点的迭代器，看原码可知 int类型的次数second用的是缺省值（对应原码中的mapped_typed()，是缺省值 ），所以开始second就是0，++后就是1。作用就是插入并修改val (val意思就是second)。</p>
<p>如果插入的str在 对象countMap中，countMap[str]++; 就是查找到这个节点，迭代器就是已有节点的迭代器，int类型的次数second在第一次已经是1了，++后就是2。作用就是插入并修改val (val意思就是second，用于计水果次数)。</p>
<h3 id="%EF%BC%882%EF%BC%89%20%E5%AD%97%E5%85%B8%E4%B8%AD%E5%88%A9%E7%94%A8%5B%5D%E6%8F%92%E5%85%A5%E6%88%96%E4%BF%AE%E6%94%B9%20%E7%A4%BA%E4%BE%8B">（2） 字典中利用[]插入或修改 示例</h3>
<pre><code class="language-cpp">void test_map1()
{
	map&lt;string, string&gt; dict;

	// pair构造函数
	dict.insert(pair&lt;string, string&gt;("sort", "排序"));
	pair&lt;string, string&gt; kv("insert", "插入");
	dict.insert(kv);

	// make_pair
	auto ret1 = dict.insert(make_pair("left", "左边"));
	auto ret2 = dict.insert(make_pair("left", "剩余"));

	dict["operator"] = "重载"; // 插入+修改
	dict["left"] = "左边、剩余"; // 修改
	dict["erase"];  // 插入
	cout &lt;&lt; dict["left"] &lt;&lt; endl; // 查找
}</code></pre>
<p><img alt="" height="424" src="image\313200bc6b944a36b4c618b999004ccf.png" width="1200"/></p>
<p></p>
<h2 id="5.multimap%20%E5%85%81%E8%AE%B8%E9%94%AE%E5%80%BC%E5%86%97%E4%BD%99">5.multimap 允许键值冗余</h2>
<p><img alt="" height="191" src="image\7dba8f8bed0742d48b3003e0139dbef7.png" width="986"/></p>
<p></p>
<p><img alt="" height="574" src="image\fcdd8b45857c448da676d08a66e12240.png" width="1200"/></p>
<p>相比map，multimap使用函数接口最大的区别是什么?<br/> 答：不支持operator[] 。</p>
<p><img alt="" height="119" src="image\de18cc9a57de45cbbfa9cab41650f34e.png" width="645"/></p>
<p></p>
<h1 id="%E4%B8%89.%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE">三.相关题目</h1>
<h2 id="%E3%80%82692.%20%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%8D%95%E8%AF%8D">。<a href="https://leetcode.cn/problems/top-k-frequent-words/" title="692. 前K个高频单词">692. 前K个高频单词</a></h2>
<p><img alt="" height="754" src="image\0ed8d001ef2b4c19b815e88dabf4a26d.png" width="580"/></p>
<p> <img alt="" height="1200" src="image\580322e78f3b4d0f90b550a5039c50af.png" width="879"/></p>
<p></p>
<h1 id="%E5%9B%9B.%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0">四.模拟实现</h1>
<p>重点：</p>
<p>struct SetKeyOfT 仿函数，用于在RBTree.h找到map/set中所要比较的值，用于控制RBTree.h中pair类型的比较方法，因为库中的pair类型 先比first再比second 的比较方法不是我们想要的</p>
<h2 id="Map.h">Map.h</h2>
<pre><code class="language-cpp">#pragma once
#include "RBTree.h"

namespace bit
{
	template&lt;class K, class V&gt;
	class map
	{
		struct MapKeyOfT
		{
			const K&amp; operator()(const pair&lt;K, V&gt;&amp; kv)
			{
				return kv.first;
			}
		};
	public:
		typedef typename RBTree&lt;K, pair&lt;K, V&gt;, MapKeyOfT&gt;::iterator iterator;
		typedef typename RBTree&lt;K, pair&lt;K, V&gt;, MapKeyOfT&gt;::const_iterator const_iterator;

		iterator begin()
		{
			return _t.Begin();
		}

		iterator end()
		{
			return _t.End();
		}

		pair&lt;iterator, bool&gt; insert(const pair&lt;K, V&gt;&amp; kv)
		{
			return _t.Insert(kv);
		}

		iterator find(const K&amp; key)
		{
			return _t.Find(key);
		}

		V&amp; operator[](const K&amp; key)
		{
			pair&lt;iterator, bool&gt; ret = insert(make_pair(key, V()));
			return ret.first-&gt;second;
		}

	private:
		RBTree&lt;K, pair&lt;K, V&gt;, MapKeyOfT&gt; _t;
	};

	void test_map1()
	{
		map&lt;string, int&gt; m;
		m.insert(make_pair("111", 1));
		m.insert(make_pair("555", 5));
		m.insert(make_pair("333", 3));
		m.insert(make_pair("222", 2));

		map&lt;string, int&gt;::iterator it = m.begin();
		while (it != m.end())
		{
			cout &lt;&lt; it-&gt;first &lt;&lt; ":" &lt;&lt; it-&gt;second &lt;&lt; endl;
			++it;
		}
		cout &lt;&lt; endl;

		for (auto&amp; kv : m)
		{
			cout &lt;&lt; kv.first &lt;&lt; ":" &lt;&lt; kv.second &lt;&lt; endl;
		}
		cout &lt;&lt; endl;
	}

	void test_map2()
	{
		string arr[] = { "ƻ", "", "ƻ", "", "ƻ", "ƻ", "", "ƻ", "㽶", "ƻ", "㽶" };

		map&lt;string, int&gt; countMap;
		for (auto&amp; str : arr)
		{
			countMap[str]++;
		}

		for (const auto&amp; kv : countMap)
		{
			cout &lt;&lt; kv.first &lt;&lt; ":" &lt;&lt; kv.second &lt;&lt; endl;
		}
	}

	void test_map3()
	{
		map&lt;string, string&gt; dict;
		dict["insert"];
		dict["insert"] = "";
		dict["left"] = "";

	}
}</code></pre>
<h2 id="Set.h">Set.h</h2>
<p></p>
<pre><code class="language-cpp">#pragma once

#include "RBTree.h"

namespace bit
{
	template&lt;class K&gt;
	class set
	{
		struct SetKeyOfT
		{
			const K&amp; operator()(const K&amp; key)
			{
				return key;
			}
		};
	public:
		typedef typename RBTree&lt;K, K, SetKeyOfT&gt;::const_iterator iterator;
		typedef typename RBTree&lt;K, K, SetKeyOfT&gt;::const_iterator const_iterator;

		iterator begin() const    //set内容不想被修改(key值不修改)，则给this设置const，
		{                          //调用时会调用带const的Begin()
			return _t.Begin();
		}

		iterator end() const
		{
			return _t.End();
		}

		pair&lt;iterator, bool&gt; insert(const K&amp; key)
		{
			//pair&lt;typename RBTree&lt;K, K, SetKeyOfT&gt;::iterator, bool&gt; ret = _t.Insert(key);
			auto ret = _t.Insert(key);
			return pair&lt;iterator, bool&gt;(iterator(ret.first._node), ret.second);
		}

		iterator find(const K&amp; key)
		{
			return _t.Find(key);
		}
	private:
		RBTree&lt;K, K, SetKeyOfT&gt; _t;
	};

	void test_set1()
	{
		set&lt;int&gt; s;
		s.insert(8);
		s.insert(6);
		s.insert(11);
		s.insert(5);
		s.insert(6);
		s.insert(7);
		s.insert(10);
		s.insert(13);
		s.insert(12);
		s.insert(15);

		set&lt;int&gt;::iterator it = s.begin();
		while (it != s.end())
		{
			cout &lt;&lt; *it &lt;&lt; " ";
			++it;
		}
		cout &lt;&lt; endl;

		for (auto e : s)
		{
			cout &lt;&lt; e &lt;&lt; " ";
		}
		cout &lt;&lt; endl;
	}
}</code></pre>
<h2 id="RBTree.h">RBTree.h</h2>
<pre><code class="language-cpp">pragma once

enum Colour
{
	RED,
	BLACK,
};

template&lt;class T&gt;
struct RBTreeNode
{
	RBTreeNode&lt;T&gt;* _left;
	RBTreeNode&lt;T&gt;* _right;
	RBTreeNode&lt;T&gt;* _parent;
	T _data; // 数据

	Colour _col;

	RBTreeNode(const T&amp; data)
		:_data(data)
		, _left(nullptr)
		, _right(nullptr)
		, _parent(nullptr)
		, _col(RED)
	{}
};

template&lt;class T, class Ref, class Ptr&gt;
struct __RBTreeIterator
{
	typedef RBTreeNode&lt;T&gt; Node;
	typedef __RBTreeIterator&lt;T, Ref, Ptr&gt; Self;
	Node* _node;

	__RBTreeIterator(Node* node)
		:_node(node)
	{}

	Ref operator*()
	{
		return _node-&gt;_data;
	}

	Ptr operator-&gt;()
	{
		return &amp;_node-&gt;_data;
	}
	// 休息17:00
	Self&amp; operator++()
	{
		if (_node-&gt;_right == nullptr)
		{
			// 找祖先里面，孩子是父亲左的那个
			Node* cur = _node;
			Node* parent = cur-&gt;_parent;
			while (parent &amp;&amp; parent-&gt;_right == cur)
			{
				cur = cur-&gt;_parent;
				parent = parent-&gt;_parent;
			}

			_node = parent;
		}
		else
		{
			// 右子树的最左节点
			Node* subLeft = _node-&gt;_right;
			while (subLeft-&gt;_left)
			{
				subLeft = subLeft-&gt;_left;
			}

			_node = subLeft;
		}
		
		return *this;
	}

	Self operator++(int)
	{
		Self tmp(*this);
		
		++(*this);

		return tmp;
	}

	Self&amp; operator--()
	{
		if (_node-&gt;_left == nullptr)
		{
			// 找祖先里面，孩子是父亲
			Node* cur = _node;
			Node* parent = cur-&gt;_parent;
			while (parent &amp;&amp; cur == parent-&gt;_left)
			{
				cur = cur-&gt;_parent;
				parent = parent-&gt;_parent;
			}

			_node = parent;
		}
		else
		{
			// 左子树的最右节点
			Node* subRight = _node-&gt;_left;
			while (subRight-&gt;_right)
			{
				subRight = subRight-&gt;_right;
			}

			_node = subRight;
		}

		return *this;
	}

	Self operator--(int)
	{
		Self tmp(*this);

		--(*this);

		return tmp;
	}

	bool operator!=(const Self&amp; s) const
	{
		return _node != s._node;
	}

	bool operator==(const Self&amp; s) const
	{
		return _node == s-&gt;_node;
	}
};

// T决定红黑树存什么数据
// set  RBTree&lt;K, K&gt;
// map  RBTree&lt;K, pair&lt;K, V&gt;&gt;
// KeyOfT -&gt; 支持取出T对象中key的仿函数
template&lt;class K, class T, class KeyOfT&gt;
class RBTree
{
	typedef RBTreeNode&lt;T&gt; Node;
public:
	typedef __RBTreeIterator&lt;T, T&amp;, T*&gt; iterator;
	typedef __RBTreeIterator&lt;T, const T&amp;, const T*&gt; const_iterator;

	// 构造 拷贝构造 赋值 和析构 跟搜索树实现方式是一样的

	iterator Begin()
	{
		Node* subLeft = _root;
		while (subLeft &amp;&amp; subLeft-&gt;_left)
		{
			subLeft = subLeft-&gt;_left;
		}

		return iterator(subLeft);
	}

	iterator End()
	{
		return iterator(nullptr);
	}

	const_iterator Begin() const
	{
		Node* subLeft = _root;
		while (subLeft &amp;&amp; subLeft-&gt;_left)
		{
			subLeft = subLeft-&gt;_left;
		}

		return const_iterator(subLeft);
	}

	const_iterator End() const
	{
		return const_iterator(nullptr);
	}

	pair&lt;iterator, bool&gt; Insert(const T&amp; data)
	{
		// 1、搜索树的规则插入
		// 2、看是否违反平衡规则，如果违反就需要处理：旋转
		if (_root == nullptr)
		{
			_root = new Node(data);
			_root-&gt;_col = BLACK;
			return make_pair(iterator(_root), true);
		}

		KeyOfT kot;

		Node* parent = nullptr;
		Node* cur = _root;
		while (cur)
		{
			if (kot(cur-&gt;_data) &lt; kot(data))
			{
				parent = cur;
				cur = cur-&gt;_right;
			}
			else if (kot(cur-&gt;_data) &gt; kot(data))
			{
				parent = cur;
				cur = cur-&gt;_left;
			}
			else
			{
				return make_pair(iterator(cur), true);
			}
		}

		cur = new Node(data);
		Node* newnode = cur;
		cur-&gt;_col = RED;  
		if (kot(parent-&gt;_data) &lt; kot(data))
		{
			parent-&gt;_right = cur;
		}
		else
		{
			parent-&gt;_left = cur;
		}

		cur-&gt;_parent = parent;

		// 存在连续红色节点
		while (parent &amp;&amp; parent-&gt;_col == RED)
		{
			Node* grandfater = parent-&gt;_parent;
			assert(grandfater);

			if (grandfater-&gt;_left == parent)
			{
				Node* uncle = grandfater-&gt;_right;
				// 情况一：
				if (uncle &amp;&amp; uncle-&gt;_col == RED) // 叔叔存在且为红
				{
					// 变色
					parent-&gt;_col = uncle-&gt;_col = BLACK;
					grandfater-&gt;_col = RED;

					// 继续往上处理
					cur = grandfater;
					parent = cur-&gt;_parent;
				}
				else // 叔叔不存在 或者 叔叔存在且为黑
				{
					if (cur == parent-&gt;_left) // 单旋
					{
						//     g
						//   p
						// c
						RotateR(grandfater);
						parent-&gt;_col = BLACK;
						grandfater-&gt;_col = RED;
					}
					else // 双旋
					{
						//     g
						//   p
						//     c 
						RotateL(parent);
						RotateR(grandfater);
						cur-&gt;_col = BLACK;
						grandfater-&gt;_col = RED;
					}

					break;
				}
			}
			else //(grandfater-&gt;_right == parent)
			{
				Node* uncle = grandfater-&gt;_left;
				// 情况一：
				if (uncle &amp;&amp; uncle-&gt;_col == RED)
				{
					// 变色
					parent-&gt;_col = uncle-&gt;_col = BLACK;
					grandfater-&gt;_col = RED;

					// 继续往上处理
					cur = grandfater;
					parent = cur-&gt;_parent;
				}
				else
				{
					if (cur == parent-&gt;_right)
					{
						// g
						//   p
						//     c 
						RotateL(grandfater);
						parent-&gt;_col = BLACK;
						grandfater-&gt;_col = RED;
					}
					else // 双旋
					{
						// g
						//   p
						// c
						RotateR(parent);
						RotateL(grandfater);
						cur-&gt;_col = BLACK;
						grandfater-&gt;_col = RED;
					}

					break;
				}
			}
		}

		_root-&gt;_col = BLACK;

		return make_pair(iterator(newnode), true);
	}

	void RotateL(Node* parent)
	{
		Node* subR = parent-&gt;_right;
		Node* subRL = subR-&gt;_left;

		parent-&gt;_right = subRL;
		if (subRL)
			subRL-&gt;_parent = parent;

		Node* ppNode = parent-&gt;_parent;

		subR-&gt;_left = parent;
		parent-&gt;_parent = subR;

		if (parent == _root)
		{
			_root = subR;
			_root-&gt;_parent = nullptr;
		}
		else
		{
			if (parent == ppNode-&gt;_left)
			{
				ppNode-&gt;_left = subR;
			}
			else
			{
				ppNode-&gt;_right = subR;
			}

			subR-&gt;_parent = ppNode;
		}
	}

	void RotateR(Node* parent)
	{
		Node* subL = parent-&gt;_left;
		Node* subLR = subL-&gt;_right;

		parent-&gt;_left = subLR;
		if (subLR)
			subLR-&gt;_parent = parent;

		Node* ppNode = parent-&gt;_parent;

		subL-&gt;_right = parent;
		parent-&gt;_parent = subL;

		if (parent == _root)
		{
			_root = subL;
			_root-&gt;_parent = nullptr;
		}
		else
		{
			if (ppNode-&gt;_left == parent)
			{
				ppNode-&gt;_left = subL;
			}
			else
			{
				ppNode-&gt;_right = subL;
			}
			subL-&gt;_parent = ppNode;
		}
	}

	iterator Find(const K&amp; key)
	{
		Node* cur = _root;
		KeyOfT kot;
		while (cur)
		{
			if (kot(cur-&gt;_data) &lt; key)
			{
				cur = cur-&gt;_right;
			}
			else if (kot(cur-&gt;_data) &gt; key)
			{
				cur = cur-&gt;_left;
			}
			else
			{
				return iterator(cur);
			}
		}

		return End();
	}

private:
	Node* _root = nullptr;
};</code></pre>
<p></p>
</div>
</div>