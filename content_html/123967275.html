<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<p id="main-toc"><strong>目录</strong></p>
<p id="1.%E5%BD%A2%E8%B1%A1%E8%AF%B4%E6%98%8E%EF%BC%9A-toc" style="margin-left:0px;"><a href="#1.%E5%BD%A2%E8%B1%A1%E8%AF%B4%E6%98%8E%EF%BC%9A">1.形象说明：</a></p>
<p id="2.%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA%EF%BC%9A-toc" style="margin-left:0px;"><a href="#2.%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA%EF%BC%9A">2.代码演示：</a></p>
<p id="2.1%C2%A0REQUIRED-toc" style="margin-left:40px;"><a href="#2.1%C2%A0REQUIRED">2.1 REQUIRED</a></p>
<p id="2.1.1%C2%A0%20%E9%AA%8C%E8%AF%81%E5%85%B1%E7%94%A8%E4%B8%80%E4%B8%AA%E4%BA%8B%E5%8A%A1-toc" style="margin-left:80px;"><a href="#2.1.1%C2%A0%20%E9%AA%8C%E8%AF%81%E5%85%B1%E7%94%A8%E4%B8%80%E4%B8%AA%E4%BA%8B%E5%8A%A1">2.1.1  验证共用一个事务</a></p>
<p id="2.1.2%C2%A0%20%E9%AA%8C%E8%AF%81%E5%BD%93%E5%89%8D%E6%B2%A1%E6%9C%89%E4%BA%8B%E5%8A%A1%EF%BC%8C%E5%B0%B1%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%BA%8B%E5%8A%A1-toc" style="margin-left:80px;"><a href="#2.1.2%C2%A0%20%E9%AA%8C%E8%AF%81%E5%BD%93%E5%89%8D%E6%B2%A1%E6%9C%89%E4%BA%8B%E5%8A%A1%EF%BC%8C%E5%B0%B1%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%BA%8B%E5%8A%A1">2.1.2  验证当前没有事务，就新建一个事务</a></p>
<p id="2.2%C2%A0SUPPORTS-toc" style="margin-left:40px;"><a href="#2.2%C2%A0SUPPORTS">2.2 SUPPORTS</a></p>
<p id="2.2.1%20%E6%94%AF%E6%8C%81%E4%BD%BF%E7%94%A8%E5%BD%93%E5%89%8D%E4%BA%8B%E5%8A%A1-toc" style="margin-left:80px;"><a href="#2.2.1%20%E6%94%AF%E6%8C%81%E4%BD%BF%E7%94%A8%E5%BD%93%E5%89%8D%E4%BA%8B%E5%8A%A1">2.2.1 支持使用当前事务</a></p>
<p id="2.2.2%C2%A0%E5%A6%82%E6%9E%9C%E5%BD%93%E5%89%8D%E4%BA%8B%E5%8A%A1%E4%B8%8D%E5%AD%98%E5%9C%A8%EF%BC%8C%E5%88%99%E4%B8%8D%E4%BD%BF%E7%94%A8%E4%BA%8B%E5%8A%A1-toc" style="margin-left:80px;"><a href="#2.2.2%C2%A0%E5%A6%82%E6%9E%9C%E5%BD%93%E5%89%8D%E4%BA%8B%E5%8A%A1%E4%B8%8D%E5%AD%98%E5%9C%A8%EF%BC%8C%E5%88%99%E4%B8%8D%E4%BD%BF%E7%94%A8%E4%BA%8B%E5%8A%A1">2.2.2 如果当前事务不存在，则不使用事务</a></p>
<p id="2.3%C2%A0MANDATORY-toc" style="margin-left:40px;"><a href="#2.3%C2%A0MANDATORY">2.3 MANDATORY</a></p>
<p id="2.3.1%20%E6%94%AF%E6%8C%81%E4%BD%BF%E7%94%A8%E5%BD%93%E5%89%8D%E4%BA%8B%E5%8A%A1-toc" style="margin-left:80px;"><a href="#2.3.1%20%E6%94%AF%E6%8C%81%E4%BD%BF%E7%94%A8%E5%BD%93%E5%89%8D%E4%BA%8B%E5%8A%A1">2.3.1 支持使用当前事务</a></p>
<p id="2.3.2%C2%A0%E5%A6%82%E6%9E%9C%E5%BD%93%E5%89%8D%E4%BA%8B%E5%8A%A1%E4%B8%8D%E5%AD%98%E5%9C%A8%EF%BC%8C%E5%88%99%E6%8A%9B%E5%87%BAException-toc" style="margin-left:80px;"><a href="#2.3.2%C2%A0%E5%A6%82%E6%9E%9C%E5%BD%93%E5%89%8D%E4%BA%8B%E5%8A%A1%E4%B8%8D%E5%AD%98%E5%9C%A8%EF%BC%8C%E5%88%99%E6%8A%9B%E5%87%BAException">2.3.2 如果当前事务不存在，则抛出Exception</a></p>
<p id="2.4%C2%A0REQUIRES_NEW-toc" style="margin-left:40px;"><a href="#2.4%C2%A0REQUIRES_NEW">2.4 REQUIRES_NEW</a></p>
<p id="2.4.1%20%E5%BD%93%E5%89%8D%E4%BA%8B%E5%8A%A1%E4%B8%8D%E5%AD%98%E5%9C%A8%EF%BC%8C%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%B0%E4%BA%8B%E5%8A%A1-toc" style="margin-left:80px;"><a href="#2.4.1%20%E5%BD%93%E5%89%8D%E4%BA%8B%E5%8A%A1%E4%B8%8D%E5%AD%98%E5%9C%A8%EF%BC%8C%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%B0%E4%BA%8B%E5%8A%A1">2.4.1 当前事务不存在，创建一个新事务</a></p>
<p id="2.4.2%20%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%BA%8B%E5%8A%A1%EF%BC%8C%E5%BD%93%E5%89%8D%E4%BA%8B%E5%8A%A1%E5%AD%98%E5%9C%A8%EF%BC%8C%E6%8A%8A%E5%BD%93%E5%89%8D%E4%BA%8B%E5%8A%A1%E6%8C%82%E8%B5%B7-toc" style="margin-left:80px;"><a href="#2.4.2%20%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%BA%8B%E5%8A%A1%EF%BC%8C%E5%BD%93%E5%89%8D%E4%BA%8B%E5%8A%A1%E5%AD%98%E5%9C%A8%EF%BC%8C%E6%8A%8A%E5%BD%93%E5%89%8D%E4%BA%8B%E5%8A%A1%E6%8C%82%E8%B5%B7">2.4.2 新建一个事务，当前事务存在，把当前事务挂起</a></p>
<p id="2.5%C2%A0NOT_SUPPORTED-toc" style="margin-left:40px;"><a href="#2.5%C2%A0NOT_SUPPORTED">2.5 NOT_SUPPORTED</a></p>
<p id="2.5.1%20%E6%97%A0%E4%BA%8B%E5%8A%A1%E6%89%A7%E8%A1%8C-toc" style="margin-left:80px;"><a href="#2.5.1%20%E6%97%A0%E4%BA%8B%E5%8A%A1%E6%89%A7%E8%A1%8C">2.5.1 无事务执行</a></p>
<p id="2.5.2%C2%A0%E5%A6%82%E6%9E%9C%E5%BD%93%E5%89%8D%E4%BA%8B%E5%8A%A1%E5%AD%98%E5%9C%A8%EF%BC%8C%E6%8A%8A%E5%BD%93%E5%89%8D%E4%BA%8B%E5%8A%A1%E6%8C%82%E8%B5%B7%E3%80%82-toc" style="margin-left:80px;"><a href="#2.5.2%C2%A0%E5%A6%82%E6%9E%9C%E5%BD%93%E5%89%8D%E4%BA%8B%E5%8A%A1%E5%AD%98%E5%9C%A8%EF%BC%8C%E6%8A%8A%E5%BD%93%E5%89%8D%E4%BA%8B%E5%8A%A1%E6%8C%82%E8%B5%B7%E3%80%82">2.5.2 如果当前事务存在，把当前事务挂起。</a></p>
<p id="2.6%C2%A0NEVER-toc" style="margin-left:40px;"><a href="#2.6%C2%A0NEVER">2.6 NEVER</a></p>
<p id="2.6.1%20%E6%97%A0%E4%BA%8B%E5%8A%A1%E6%89%A7%E8%A1%8C-toc" style="margin-left:80px;"><a href="#2.6.1%20%E6%97%A0%E4%BA%8B%E5%8A%A1%E6%89%A7%E8%A1%8C">2.6.1 无事务执行</a></p>
<p id="2.6.2%C2%A0%E5%A6%82%E6%9E%9C%E5%BD%93%E5%89%8D%E6%9C%89%E4%BA%8B%E5%8A%A1%E5%88%99%E6%8A%9B%E5%87%BAException-toc" style="margin-left:80px;"><a href="#2.6.2%C2%A0%E5%A6%82%E6%9E%9C%E5%BD%93%E5%89%8D%E6%9C%89%E4%BA%8B%E5%8A%A1%E5%88%99%E6%8A%9B%E5%87%BAException">2.6.2 如果当前有事务则抛出Exception</a></p>
<p id="2.7%C2%A0%C2%A0NESTED-toc" style="margin-left:40px;"><a href="#2.7%C2%A0%C2%A0NESTED">2.7  NESTED</a></p>
<hr id="hr-toc"/>
<p></p>
<p></p>
<p></p>
<p>事务的传播机制有7种，如下图所示：</p>
<p style="text-align:center;"><img alt="" height="250" src="image\c52027676ed24f9a8e57e5b2b7ebeb2f.png" width="773"/></p>
<h1 id="1.%E5%BD%A2%E8%B1%A1%E8%AF%B4%E6%98%8E%EF%BC%9A">1.形象说明：</h1>
<p>为了更好的理解，下面我们形象的说明一下几种传播机制是什么意思：</p>
<p>比如你下班回家，有以下几种场景</p>
<p>0.REQUIRED ------ 就是如果老婆做饭了，你就吃老婆做的饭；如果老婆没有做饭，你就自己做饭吃，反正你就是要吃饭（反正要在事务中运行）；</p>
<p>1.SUPPORTS ------ 如果老婆做饭了，你就吃老婆做的饭；如果老婆没有做饭，你就不吃（不一定非要在事务中运行）；</p>
<p>2.MANDATORY ------ 非要吃老婆做的饭，老婆要是没有做饭，你就大发脾气，典型的家暴男；</p>
<p>3.REQUIRES_NEW ------ 劳资非要吃自己做的饭，就算老婆把饭做好了，你也不吃老婆做的；</p>
<p>4.NOT_SUPPORTED ------ 劳资就是不吃饭，就算老婆把饭做好了，我也不吃；</p>
<p>5.NEVER ------ 劳资就是不吃饭，如果老婆把饭做好了，我还要发脾气；</p>
<p>6.NESTED ------ 暂不做解释，后面会详解；</p>
<p></p>
<p>本文主要是想用代码实现这几种传播机制的具体使用；</p>
<h1 id="2.%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA%EF%BC%9A">2.代码演示：</h1>
<p>有两张表：</p>
<p>school表</p>
<p style="text-align:center;"><img alt="" height="223" src="image\7cfcc510c1414cb5b46df40b838fd658.png" width="374"/></p>
<p>student表</p>
<p style="text-align:center;"><img alt="" height="204" src="image\9afe056cd0d44e8e9636a7b0e155a06a.png" width="365"/></p>
<p>我们如何去测试两个方法是否使用的同一个事务呢？就看是否共用同一个数据库连接或者共用同一个会话；</p>
<h2 id="2.1%C2%A0REQUIRED">2.1 REQUIRED</h2>
<p>支持使用当前事务，如果当前事务不存在，创建一个新事务。</p>
<h3 id="2.1.1%C2%A0%20%E9%AA%8C%E8%AF%81%E5%85%B1%E7%94%A8%E4%B8%80%E4%B8%AA%E4%BA%8B%E5%8A%A1">2.1.1  验证共用一个事务</h3>
<p>schoolService.updateSchool()方法：</p>
<pre><code class="language-java">@Transactional
    public void updateSchool(){
        School school = new School();
        school.setId(1);
        school.setName("湖南大学");
        school.setLocation("湖南");
        //更新id为1的学校名称为湖南大学，地址为湖南
        schoolMapper.updateByPrimaryKeySelective(school);
        
        //调用另一个方法更新学生信息
        studentService.updateStudent();
        System.out.println(1/0);
    }</code></pre>
<p>studentService.updateStudent()方法，加了事务的，默认REQUIRED：</p>
<pre><code class="language-java">@Transactional
    public void updateStudent(){
        Student student = new Student();
        student.setSid(1);
        student.setAge(25);
        //更新sid为1的学生年龄为25
        studentMapper.updateByPrimaryKeySelective(student);
    }</code></pre>
<p>如上所示：updateSchool方法是加了事务的，调用完studentService.updateStudent方法后，会报错，如果updateSchool和updateStudent共用同一个事务，updateSchool报错，自身回滚，肯定会带着updateStudent一起回滚；如果不是共用同一个事务，那么updateStudent会执行成功并提交，不会回滚；</p>
<p><strong>结果：</strong></p>
<p>updateSchool成功回滚了</p>
<p style="text-align:center;"><img alt="" src="image\a7b48f2b2de340b5a45d689eec14ccfd.png"/></p>
<p> updateStudent也成功回滚了</p>
<p style="text-align:center;"><img alt="" height="73" src="image\3d3d1f7f1e4443d89a12939462eec6c0.png" width="402"/></p>
<p>看过我写的<a class="link-info" href="https://mp.csdn.net/mp_blog/creation/editor/123899022" title="深入理解@Transactional注解的使用和原理">深入理解@Transactional注解的使用和原理</a>就知道，两个方法会共用同一个数据库连接，也就共用同一个事务，两个方法一起提交或者回滚；</p>
<h3 id="2.1.2%C2%A0%20%E9%AA%8C%E8%AF%81%E5%BD%93%E5%89%8D%E6%B2%A1%E6%9C%89%E4%BA%8B%E5%8A%A1%EF%BC%8C%E5%B0%B1%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%BA%8B%E5%8A%A1">2.1.2  验证当前没有事务，就新建一个事务</h3>
<p>schoolService.updateSchool()方法：</p>
<pre><code class="language-java">  public void updateSchool(){
        School school = new School();
        school.setId(1);
        school.setName("湖南大学");
        school.setLocation("湖南");
        //更新id为1的学校名称为湖南大学，地址为湖南
        schoolMapper.updateByPrimaryKeySelective(school);
        
        //调用另一个方法更新学生信息
        studentService.updateStudent();
       
    }</code></pre>
<p>studentService.updateStudent()方法：</p>
<pre><code class="language-java">@Transactional
    public void updateStudent(){
        Student student = new Student();
        student.setSid(1);
        student.setAge(25);
        //更新sid为1的学生年龄为25
        studentMapper.updateByPrimaryKeySelective(student);
        //报错
        System.out.println(1/0);
    }</code></pre>
<p>如上所示：updateSchool方法是没有加事务的，调用studentService.updateStudent方法，updateStudent方法加了事务，并且会报错，如果updateStudent没有新建事务的话，不会回滚，如果是建了事务，就会回滚；</p>
<p><strong>结果：</strong></p>
<p>1.控制台提示报错</p>
<p style="text-align:center;"><img alt="" src="image\38b50354914646b6948beed193523ac7.png"/></p>
<p>2. updateSchool方法没有回滚（将北京大学刚改为湖南大学）</p>
<p style="text-align:center;"><img alt="" height="100" src="image\d470d2f0c5d54cf295bbdac177b534aa.png" width="304"/></p>
<p> 3.updateStudent方法回滚了（将age更新为25）</p>
<p>                                                <img alt="" height="49" src="image\2d09e19120a642afbcc237fb8823b731.png" width="270"/></p>
<p>验证通过；</p>
<h2 id="2.2%C2%A0SUPPORTS">2.2 SUPPORTS</h2>
<p>支持使用当前事务，如果当前事务不存在，则不使用事务。</p>
<h3 id="2.2.1%20%E6%94%AF%E6%8C%81%E4%BD%BF%E7%94%A8%E5%BD%93%E5%89%8D%E4%BA%8B%E5%8A%A1">2.2.1 支持使用当前事务</h3>
<p>updateSchool方法，加事务，更新id为1的name为“湖南大学”，location为“湖南”，输出1/0，肯定会报错的；</p>
<pre><code class="language-java">    @Transactional
    public void updateSchool(){
        School school = new School();
        school.setId(1);
        school.setName("湖南大学");
        school.setLocation("湖南");
        schoolMapper.updateByPrimaryKeySelective(school);
        studentService.updateStudent();
        System.out.println(1/0);
    }</code></pre>
<p>updateStudent方法更新id为1的age为25；</p>
<pre><code class="language-java">    @Transactional(propagation = Propagation.SUPPORTS)
    public void updateStudent(){
        Student student = new Student();
        student.setSid(1);
        student.setAge(25);
        studentMapper.updateByPrimaryKeySelective(student);
    }</code></pre>
<p>如上所示：updateSchool方法是加了事务的，studentService.updateStudent方法也加了事务，而且传播机制是SUPPORTS，如果updateSchool和updateStudent共用同一个事务，updateSchool报错，自身回滚，肯定会带着updateStudent一起回滚；如果不是共用同一个事务，那么updateStudent会执行成功并提交，不会回滚；</p>
<p><strong>结果：</strong></p>
<p>1.控制台提示报错</p>
<p style="text-align:center;"><img alt="" src="image\1cfb1d9728c4446f89955a72224dbf85.png"/></p>
<p>2. updateSchool方法回滚（将北京大学刚改为湖南大学）</p>
<p><img alt="" src="image\a7b48f2b2de340b5a45d689eec14ccfd.png"/></p>
<p>3.updateStudent方法回滚（将age改为25）</p>
<p><img alt="" height="73" src="image\3d3d1f7f1e4443d89a12939462eec6c0.png" width="402"/></p>
<p>显然，updateSchool和updateSchool共用同一个事务，正好验证了传播机制为supports，如果当前有事务，就支持使用当前事务；</p>
<h3 id="2.2.2%C2%A0%E5%A6%82%E6%9E%9C%E5%BD%93%E5%89%8D%E4%BA%8B%E5%8A%A1%E4%B8%8D%E5%AD%98%E5%9C%A8%EF%BC%8C%E5%88%99%E4%B8%8D%E4%BD%BF%E7%94%A8%E4%BA%8B%E5%8A%A1">2.2.2 如果当前事务不存在，则不使用事务</h3>
<p>updateSchool方法更新id为1的name为“湖南大学”，location为“湖南”，将@Transactional注释掉了，没有加事务</p>
<pre><code class="language-java">    //@Transactional
    public void updateSchool(){
        School school = new School();
        school.setId(1);
        school.setName("湖南大学");
        school.setLocation("湖南");
        schoolMapper.updateByPrimaryKeySelective(school);
        studentService.updateStudent();
    }</code></pre>
<p>updateStudent方法更新id为1的age为25，事务传播机制为SUPPORTS，打印1/0，将报错</p>
<pre><code class="language-java">    @Transactional(propagation = Propagation.SUPPORTS)
    public void updateStudent(){
        Student student = new Student();
        student.setSid(1);
        student.setAge(25);
        studentMapper.updateByPrimaryKeySelective(student);
        System.out.println(1/0);
    }</code></pre>
<p>如上所示：updateSchool方法没有加事务，studentService.updateStudent方法加了事务，而且传播机制是SUPPORTS，如果updateStudent没有事务，报错就不会回滚，如果有事务，就会回滚；</p>
<p><strong>结果：</strong></p>
<p>1.控制台报错</p>
<p style="text-align:center;"><img alt="" src="image\e343e65a9860453cbc39c7f50699a3cc.png"/></p>
<p> 2.updateSchool方法没有回滚，无事务执行（无事务这个说法其实不准确，任何操作数据库肯定是有事务的）；</p>
<p style="text-align:center;"><img alt="" height="48" src="image\09f901368e534097a83d3ee141bc3969.png" width="382"/></p>
<p> 3.updateStudent方法也没有回滚，也是无事务执行的；</p>
<p style="text-align:center;"><img alt="" height="40" src="image\76140e9cb195466492bca085b03f287f.png" width="290"/></p>
<p></p>
<p><strong>显然：  </strong>事务传播机制为SUPPORTS的方法，支持使用当前事务，如果当前事务不存在，则不使用事务。</p>
<p></p>
<h2 id="2.3%C2%A0MANDATORY">2.3 MANDATORY</h2>
<p>中文翻译为强制，支持使用当前事务，如果当前事务不存在，则抛出Exception。</p>
<h3 id="2.3.1%20%E6%94%AF%E6%8C%81%E4%BD%BF%E7%94%A8%E5%BD%93%E5%89%8D%E4%BA%8B%E5%8A%A1">2.3.1 支持使用当前事务</h3>
<p>updateSchool方法更新id为1的name为“湖南大学”，location为“湖南”，打印1/0，会报错；</p>
<pre><code class="language-java">    @Transactional
    public void updateSchool(){
        School school = new School();
        school.setId(1);
        school.setName("湖南大学");
        school.setLocation("湖南");
        schoolMapper.updateByPrimaryKeySelective(school);
        studentService.updateStudent();
        System.out.println(1/0);
    }</code></pre>
<p>updateStudent方法更新id为1的age为25，事务传播机制为MANDATORY</p>
<pre><code class="language-java">    @Transactional(propagation = Propagation.MANDATORY)
    public void updateStudent(){
        Student student = new Student();
        student.setSid(1);
        student.setAge(25);
        studentMapper.updateByPrimaryKeySelective(student);
    }</code></pre>
<p><strong>如上所示：</strong>updateSchool方法加事务，studentService.updateStudent方法加了事务，而且传播机制是MANDATORY，如果两者共用一个事务，都会回滚；</p>
<p><strong>结果：</strong></p>
<p>1.控制台报错</p>
<p style="text-align:center;"><img alt="" src="image\650f316f435c4e579ff462ffaf8ce9ef.png"/></p>
<p>2. updateSchool方法回滚（将北京大学刚改为湖南大学）</p>
<p style="text-align:center;"><img alt="" height="48" src="image\70d66a49e9c742938db0088f11011717.png" width="433"/></p>
<p> 3.updateStudent方法回滚（将age改为25）</p>
<p style="text-align:center;"><img alt="" height="59" src="image\51d9fecb89304bb682c6bea1eb0da224.png" width="325"/></p>
<p><strong>显然：</strong> 传播机制为MANDATORY，如果当前有事务，就使用当前事务；</p>
<p></p>
<h3 id="2.3.2%C2%A0%E5%A6%82%E6%9E%9C%E5%BD%93%E5%89%8D%E4%BA%8B%E5%8A%A1%E4%B8%8D%E5%AD%98%E5%9C%A8%EF%BC%8C%E5%88%99%E6%8A%9B%E5%87%BAException">2.3.2 如果当前事务不存在，则抛出Exception</h3>
<p>updateSchool方法更新id为1的name为“湖南大学”，location为“湖南”，没有事务；</p>
<pre><code class="language-java">    //@Transactional
    public void updateSchool(){
        School school = new School();
        school.setId(1);
        school.setName("湖南大学");
        school.setLocation("湖南");
        schoolMapper.updateByPrimaryKeySelective(school);
        studentService.updateStudent();
    }</code></pre>
<p>updateStudent方法更新id为1的age为25，事务传播机制为MANDATORY；</p>
<pre><code class="language-java">    @Transactional(propagation = Propagation.MANDATORY)
    public void updateStudent(){
        Student student = new Student();
        student.setSid(1);
        student.setAge(25);
        studentMapper.updateByPrimaryKeySelective(student);
    }</code></pre>
<p><strong>如上所示：</strong>updateSchool方法没有加事务，studentService.updateStudent方法加了事务，而且传播机制是MANDATORY，就看执行到updateStudent就不会报错；</p>
<p><strong>结果：</strong></p>
<p>1.控制台报错</p>
<p style="text-align:center;"><img alt="" src="image\c6f954051c1f4d07956580f077f309e4.png"/></p>
<p> org.springframework.transaction.IllegalTransactionStateException: No existing transaction found for transaction marked with propagation 'mandatory'</p>
<p>2.updateSchool方法没有回滚（将北京大学刚改为湖南大学）</p>
<p style="text-align:center;"><img alt="" height="51" src="image\d9115d485971411e9f0767a51c92d999.png" width="406"/></p>
<p> 3.pdateStudent方法直接报错： No existing transaction found for transaction marked with propagation 'mandatory'，传播机制为mandatory的，必须有当前事务存在，不存在就报错；</p>
<p><strong>综上：</strong>传播机制为MANDATORY，支持使用当前事务，如果当前事务不存在，则抛出Exception。</p>
<p></p>
<h2 id="2.4%C2%A0REQUIRES_NEW">2.4 REQUIRES_NEW</h2>
<p>新建一个新事务；如果当前事务存在，把当前事务挂起。</p>
<h3 id="2.4.1%20%E5%BD%93%E5%89%8D%E4%BA%8B%E5%8A%A1%E4%B8%8D%E5%AD%98%E5%9C%A8%EF%BC%8C%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%B0%E4%BA%8B%E5%8A%A1">2.4.1 当前事务不存在，创建一个新事务</h3>
<p>updateSchool方法更新id为1的name为“湖南大学”，location为“湖南”，没有事务；</p>
<pre><code class="language-java">    //@Transactional
    public void updateSchool(){
        School school = new School();
        school.setId(1);
        school.setName("湖南大学");
        school.setLocation("湖南");
        schoolMapper.updateByPrimaryKeySelective(school);
        studentService.updateStudent();
    }</code></pre>
<p>updateStudent方法更新id为1的age为25，事务传播机制为REQUIRES_NEW，打印1/0，报错；</p>
<pre><code class="language-java">    @Transactional(propagation = Propagation.MANDATORY)
    public void updateStudent(){
        Student student = new Student();
        student.setSid(1);
        student.setAge(25);
        studentMapper.updateByPrimaryKeySelective(student);
        System.out.println(1/0);
    }</code></pre>
<p><strong>如上所示：</strong>updateSchool方法没有加事务，studentService.updateStudent方法加了事务，而且传播机制是REQUIRES_NEW，如果updateStudent方法新建了事务，打印1/0，报错就会回滚，如果没有新建事务，updateStudent方法就不会回滚；</p>
<p><strong>结果：</strong></p>
<p>1.控制台报错</p>
<p style="text-align:center;"><img alt="" src="image\e158194ee73d46a59a8ba7eed70a5786.png"/></p>
<p>2.updateSchool方法没有回滚，无事务执行（无事务这个说法其实不准确，任何操作数据库肯定是有事务的）； </p>
<p style="text-align:center;"><img alt="" height="52" src="image\ddf7616ec4174b94a4c8310ca50cd2ee.png" width="414"/></p>
<p> 3. updateStudent方法回滚（将age改为25）</p>
<p style="text-align:center;"><img alt="" height="50" src="image\6809456aea9f4483b3c087fb49400412.png" width="275"/></p>
<p><strong> 显然：</strong>传播机制为REQUIRES_NEW的，当前没有事务，就新建一个事务，在事务中运行；</p>
<p></p>
<h3 id="2.4.2%20%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%BA%8B%E5%8A%A1%EF%BC%8C%E5%BD%93%E5%89%8D%E4%BA%8B%E5%8A%A1%E5%AD%98%E5%9C%A8%EF%BC%8C%E6%8A%8A%E5%BD%93%E5%89%8D%E4%BA%8B%E5%8A%A1%E6%8C%82%E8%B5%B7">2.4.2 新建一个事务，当前事务存在，把当前事务挂起</h3>
<p>updateSchool方法更新id为1的name为“湖南大学”，location为“湖南”，有事务,打印1/0，报错；</p>
<pre><code class="language-java">    @Transactional
    public void updateSchool(){
        School school = new School();
        school.setId(1);
        school.setName("湖南大学");
        school.setLocation("湖南");
        schoolMapper.updateByPrimaryKeySelective(school);
        studentService.updateStudent();
        System.out.println(1/0);
    }</code></pre>
<p>updateStudent方法更新id为1的age为25，事务传播机制为REQUIRES_NEW；</p>
<pre><code class="language-java">    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void updateStudent(){
        Student student = new Student();
        student.setSid(1);
        student.setAge(25);
        studentMapper.updateByPrimaryKeySelective(student);
    }</code></pre>
<p><strong>如上所示：</strong>updateSchool方法有加事务，studentService.updateStudent方法加了事务，而且传播机制是REQUIRES_NEW，如果updateStudent方法新建了另一个事务，updateSchool报错，updateStudent不会回滚，如果不是新建一个事务而是共用一个事务，就会一起回滚；</p>
<p><strong>结果：</strong></p>
<p>1.控制台报错</p>
<p style="text-align:center;"><img alt="" src="image\131409ab14de4eb1aa15d60dfc8219f3.png"/></p>
<p> 2.updateSchool方法回滚（将北京大学刚改为湖南大学）</p>
<p style="text-align:center;"><img alt="" height="43" src="image\075d89917559445ba7cfa305f6d5c5b7.png" width="388"/></p>
<p> 3. updateStudent没有回滚（将age改为25）</p>
<p style="text-align:center;"><img alt="" height="49" src="image\f3d1fe0cbd4e4bb5affee6c269055bcc.png" width="355"/></p>
<p><strong> 显然：</strong>updateStudent新建了另外一个事务，和updateSchool并不是共用一个事务；</p>
<p><strong>总结：</strong>传播机制是REQUIRES_NEW，新建一个新事务；如果当前事务存在，把当前事务挂起。</p>
<p>使用场景：被调用方法，不想因为调用方出错而回滚，可以使用REQUIRES_NEW；</p>
<p></p>
<h2 id="2.5%C2%A0NOT_SUPPORTED">2.5 NOT_SUPPORTED</h2>
<p>无事务执行，如果当前事务存在，把当前事务挂起。</p>
<h3 id="2.5.1%20%E6%97%A0%E4%BA%8B%E5%8A%A1%E6%89%A7%E8%A1%8C">2.5.1 无事务执行</h3>
<p>updateSchool方法更新id为1的name为“湖南大学”，location为“湖南”，没有事务,打印1/0，报错；</p>
<pre><code class="language-java">    //@Transactional
    public void updateSchool(){
        School school = new School();
        school.setId(1);
        school.setName("湖南大学");
        school.setLocation("湖南");
        schoolMapper.updateByPrimaryKeySelective(school);
        studentService.updateStudent();
    }</code></pre>
<p>updateStudent方法更新id为1的age为25，事务传播机制为NOT_SUPPORTED；</p>
<pre><code class="language-java">    @Transactional(propagation = Propagation.NOT_SUPPORTED)
    public void updateStudent(){
        Student student = new Student();
        student.setSid(1);
        student.setAge(25);
        studentMapper.updateByPrimaryKeySelective(student);
        System.out.println(1/0);
    }</code></pre>
<p><strong>如上所示：</strong>updateSchool方法没有事务，studentService.updateStudent方法加了事务，而且传播机制是NOT_SUPPORTED，如果updateStudent没有事务，那么在执行打印1/0报错后，也就不会回滚；</p>
<p><strong>结果：</strong></p>
<p>1.控制台报错</p>
<p style="text-align:center;"><img alt="" src="image\39434fb60791447f8c2f4671fb0d8be6.png"/></p>
<p>  2.updateSchool方法不回滚（将北京大学刚改为湖南大学）</p>
<p style="text-align:center;"><img alt="" height="51" src="image\39b9fc76f8194b1d997aa91ae1fba4c4.png" width="406"/></p>
<p>  3. updateStudent没有回滚（将age改为25）</p>
<p style="text-align:center;"><img alt="" height="48" src="image\182a80322f3444f6a262d59a164bb63b.png" width="347"/></p>
<p><strong> 显然：</strong>两个方法都没有在事务中运行，都没有回滚，所以，如果当前没有事务，NOT_SUPPORTED并不会新建一个事务，也是无事务执行；</p>
<p></p>
<h3 id="2.5.2%C2%A0%E5%A6%82%E6%9E%9C%E5%BD%93%E5%89%8D%E4%BA%8B%E5%8A%A1%E5%AD%98%E5%9C%A8%EF%BC%8C%E6%8A%8A%E5%BD%93%E5%89%8D%E4%BA%8B%E5%8A%A1%E6%8C%82%E8%B5%B7%E3%80%82">2.5.2 如果当前事务存在，把当前事务挂起。</h3>
<p>updateSchool方法更新id为1的name为“湖南大学”，location为“湖南”，有事务；</p>
<pre><code class="language-java">    @Transactional
    public void updateSchool(){
        School school = new School();
        school.setId(1);
        school.setName("湖南大学");
        school.setLocation("湖南");
        schoolMapper.updateByPrimaryKeySelective(school);
        studentService.updateStudent();
    }</code></pre>
<p>updateStudent方法更新id为1的age为25，事务传播机制为NOT_SUPPORTED，打印1/0，报错；</p>
<pre><code class="language-java">    @Transactional(propagation = Propagation.NOT_SUPPORTED)
    public void updateStudent(){
        Student student = new Student();
        student.setSid(1);
        student.setAge(25);
        studentMapper.updateByPrimaryKeySelective(student);
        System.out.println(1/0);
    }</code></pre>
<p><strong>如上所示：</strong>updateSchool方法有事务，studentService.updateStudent方法加了事务，而且传播机制是NOT_SUPPORTED，如果updateStudent没有事务，那么在执行打印1/0报错后，也就不会回滚，而updateSchool检测到报错，如果当前事务有效，updateSchool就会回滚；</p>
<p><strong>结果：</strong></p>
<p>1.控制台报错</p>
<p style="text-align:center;"><img alt="" src="image\7e18e60de11a4a79ab72d3150899e19e.png"/></p>
<p> 2.updateSchool方法回滚（将北京大学刚改为湖南大学）</p>
<p style="text-align:center;"><img alt="" height="33" src="image\c1a66d46bf0c4692a0ee79f07d31b16f.png" width="298"/></p>
<p>   3. updateStudent没有回滚（将age改为25）</p>
<p style="text-align:center;"><img alt="" height="42" src="image\e528973ed148448eb0ffbdabc79c0a3b.png" width="304"/></p>
<p> <strong>显然：</strong>当前有事务的情况下，传播机制为NOT_SUPPORTED的方法无事务运行；</p>
<p><strong>总结：</strong>事务传播机制为NOT_SUPPORTED，无事务执行，如果当前存在事务，把当前事务挂起；</p>
<p><strong>使用场景：</strong>被调用方法想无事务运行，但又不影响调用方的事务，可以用NOT_SUPPORTED；</p>
<p></p>
<h2 id="2.6%C2%A0NEVER">2.6 NEVER</h2>
<p>无事务执行，如果当前有事务则抛出Exception。</p>
<p>这个和MANDATORY就是两个完全相反的极端，一个强制不要事务，一个强制要事务，不满足都会报错；</p>
<h3 id="2.6.1%20%E6%97%A0%E4%BA%8B%E5%8A%A1%E6%89%A7%E8%A1%8C">2.6.1 无事务执行</h3>
<p>updateSchool方法更新id为1的name为“湖南大学”，location为“湖南”，没有事务；</p>
<pre><code class="language-java">    //@Transactional
    public void updateSchool(){
        School school = new School();
        school.setId(1);
        school.setName("湖南大学");
        school.setLocation("湖南");
        schoolMapper.updateByPrimaryKeySelective(school);
        studentService.updateStudent();
    }
</code></pre>
<p>updateStudent方法更新id为1的age为25，事务传播机制为NEVER，打印1/0，报错；</p>
<pre><code class="language-java">    @Transactional(propagation = Propagation.NEVER)
    public void updateStudent(){
        Student student = new Student();
        student.setSid(1);
        student.setAge(25);
        studentMapper.updateByPrimaryKeySelective(student);
        System.out.println(1/0);
    }</code></pre>
<p><strong>如上所示：</strong>updateSchool方法没有事务，studentService.updateStudent方法加了事务，而且传播机制是NEVER，打印1/0，会报错，如果updateStudent是无事务执行，那么就不会回滚</p>
<p><strong>结果：</strong></p>
<p>1.控制台报错</p>
<p><img alt="" src="image\7e18e60de11a4a79ab72d3150899e19e.png"/></p>
<p>2.updateSchool方法不回滚（将北京大学刚改为湖南大学）</p>
<p style="text-align:center;"><img alt="" height="49" src="image\6f5953f913c645868db0feb025394545.png" width="390"/></p>
<p> 3.updateStudent没有回滚（将age改为25）</p>
<p style="text-align:center;"><img alt="" height="47" src="image\1d7a329786c542db94bb15eece795a03.png" width="340"/></p>
<p>  <strong>显然：</strong>updateSchool和updateStudent都没有回滚，都是无事务执行，所以，传播机制为NEVER，如果当前没有事务，则无事务执行；</p>
<p></p>
<h3 id="2.6.2%C2%A0%E5%A6%82%E6%9E%9C%E5%BD%93%E5%89%8D%E6%9C%89%E4%BA%8B%E5%8A%A1%E5%88%99%E6%8A%9B%E5%87%BAException">2.6.2 如果当前有事务则抛出Exception</h3>
<p>updateSchool方法更新id为1的name为“湖南大学”，location为“湖南”，有事务；</p>
<pre><code class="language-java">    @Transactional
    public void updateSchool(){
        School school = new School();
        school.setId(1);
        school.setName("湖南大学");
        school.setLocation("湖南");
        schoolMapper.updateByPrimaryKeySelective(school);
        studentService.updateStudent();
    }</code></pre>
<p>updateStudent方法更新id为1的age为25，事务传播机制为NEVER；</p>
<pre><code class="language-java">    @Transactional(propagation = Propagation.NEVER)
    public void updateStudent(){
        Student student = new Student();
        student.setSid(1);
        student.setAge(25);
        studentMapper.updateByPrimaryKeySelective(student);
    }</code></pre>
<p><strong>如上所示：</strong>updateSchool方法有事务，studentService.updateStudent方法加了事务，而且传播机制是NEVER，当前有事务，就看执行updateStudent方法时到底报不报错；</p>
<p><strong>结果：</strong></p>
<p>1.控制台报错</p>
<p style="text-align:center;"><img alt="" src="image\6e4d3ef24c7d424db336e702a5733265.png"/></p>
<p>2.updateSchool方法回滚（将北京大学刚改为湖南大学）</p>
<p style="text-align:center;"><img alt="" height="34" src="image\c0a59767f82340ee80e409e168a4ca42.png" width="307"/></p>
<p>3. updateStudent直接报错</p>
<p>org.springframework.transaction.IllegalTransactionStateException: Existing transaction found for transaction marked with propagation 'never' </p>
<p> <strong>显然：</strong>传播机制为NEVER，如果当前有事务，则报错；</p>
<p><strong>总结：这种传播机制感觉没啥用途，哈哈，反正我是基本没用过；</strong></p>
<p></p>
<h2 id="2.7%C2%A0%C2%A0NESTED">2.7  NESTED</h2>
<p>嵌套事务，如果当前事务存在，那么在嵌套的事务中执行。如果当前事务不存在，则表现跟REQUIRED一样。</p>
<p>这个直接说，如果父事务回滚，子事务也会跟着回滚；如果子事务回滚，并抛出异常，父事务肯定会跟着回滚；</p>
<p>如果当前没有事务，就和REQUIRED,新建一个事务运行；</p>
<p></p>
<p>关于@Transactional注解的原理和事务传播机制的原理可以看我上一篇文章：</p>
<p><a class="link-info" href="https://mp.csdn.net/mp_blog/creation/editor/123899022" title="深入理解@Transactional注解的使用和原理">深入理解@Transactional注解的使用和原理</a></p>
<p></p>
</div>
</div>