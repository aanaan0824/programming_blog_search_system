<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<p><strong>2022/6/2更新</strong></p>
<p>传了一下本项目代码,文章里写到的基本都有用到,可以clone了看一下</p>
<p><a class="link-info has-card" href="https://github.com/shinjie1210/vite-config.git" title="下载地址"><span class="link-card-box"><span class="link-title">下载地址</span><span class="link-link"><img alt="" class="link-link-icon" src="image\icon-default.png"/>https://github.com/shinjie1210/vite-config.git</span></span></a>----------------------------------------------------------------------------------------------------------------------------</p>
<p>本来准备接在之前的文章</p>
<p><a class="has-card" href="https://mp.csdn.net/mp_blog/creation/editor/122127233" title="vite+vue3+elementplus教程"><span class="link-card-box"><span class="link-title">vite+vue3+elementplus教程</span><span class="link-link"><img alt="" class="link-link-icon" src="image\icon-default.png"/>https://mp.csdn.net/mp_blog/creation/editor/122127233</span></span></a>里面继续写的,但是看了下文章内容有点太多了,图多代码长的看的怪累的,</p>
<p>所以就在这里另开一篇记录了,都是一些比较基础的配置,记一下怕自己忘球了</p>
<p><em><span style="color:#fe2c24;"><strong>/*各位如果看到有其他vite配置相关文章可以评论区分享一下,私信分享给我也行,大家一起研究学习,感谢*/</strong></span></em></p>
<p id="main-toc"><strong>目录</strong></p>
<p id="1.%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E5%90%88%E5%B9%B6%E6%89%93%E5%8C%85-toc" style="margin-left:40px;"><a href="#1.%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E5%90%88%E5%B9%B6%E6%89%93%E5%8C%85">1.静态资源合并打包</a></p>
<p id="%C2%A02.%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E5%88%86%E6%8B%86-toc" style="margin-left:40px;"><a href="#%C2%A02.%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E5%88%86%E6%8B%86"> 2.静态资源文件分拆</a></p>
<p id="2.1%E6%8F%90%E9%AB%98%E5%A4%A7%E8%AD%A6%E5%91%8A%E9%97%A8%E6%A7%9B%C2%A0%C2%A0-toc" style="margin-left:80px;"><a href="#2.1%E6%8F%90%E9%AB%98%E5%A4%A7%E8%AD%A6%E5%91%8A%E9%97%A8%E6%A7%9B%C2%A0%C2%A0">2.1提高超大静态资源警告门槛  </a></p>
<p id="2.2%E8%B6%85%E5%A4%A7%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%8B%86%E5%88%86-toc" style="margin-left:80px;"><a href="#2.2%E8%B6%85%E5%A4%A7%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%8B%86%E5%88%86">2.2超大静态资源拆分</a></p>
<p id="3.gzip%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E5%8E%8B%E7%BC%A9-toc" style="margin-left:40px;"><a href="#3.gzip%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E5%8E%8B%E7%BC%A9">3.gzip静态资源压缩</a></p>
<p id="%C2%A04.%E6%B8%85%E9%99%A4console%E5%92%8Cdebugger-toc" style="margin-left:40px;"><a href="#%C2%A04.%E6%B8%85%E9%99%A4console%E5%92%8Cdebugger"> 4.清除console和debugger</a></p>
<p id="5.IE%E5%92%8C%E6%97%A7%E7%89%88chrome%E5%85%BC%E5%AE%B9-toc" style="margin-left:40px;"><a href="#5.IE%E5%92%8C%E6%97%A7%E7%89%88chrome%E5%85%BC%E5%AE%B9">5.IE和旧版chrome兼容</a></p>
<p id="%E6%9C%AA%E5%AE%8C%E5%BE%85%E7%BB%AD%2C%E7%9B%AE%E5%89%8D%E9%A1%B9%E7%9B%AE(a-project)%E7%9A%84vite%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B-toc" style="margin-left:40px;"><a href="#%E6%9C%AA%E5%AE%8C%E5%BE%85%E7%BB%AD%2C%E7%9B%AE%E5%89%8D%E9%A1%B9%E7%9B%AE%28a-project%29%E7%9A%84vite%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B">未完待续,目前项目(a-project)的vite配置代码如下</a></p>
<hr id="hr-toc"/>
<p></p>
<h2 id="1.%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E5%90%88%E5%B9%B6%E6%89%93%E5%8C%85">1.静态资源合并打包</h2>
<p>我们直接就接这上篇文章里vite.config的内容开写啊,</p>
<p>我们把之前的代码贴在这里,</p>
<p>不了解前面内容为什么这么写的的点链接过去看一下就行<a class="has-card" href="https://mp.csdn.net/mp_blog/creation/editor/122127233" title="vite+vue3+elementplus教程(更新到项目部署上线前准备)"><span class="link-card-box"><span class="link-title">vite+vue3+elementplus教程(更新到项目部署上线前准备)</span><span class="link-link"><img alt="" class="link-link-icon" src="image\icon-default.png"/>https://mp.csdn.net/mp_blog/creation/editor/122127233</span></span></a></p>
<pre><code class="language-javascript">import {
  defineConfig,
  loadEnv
} from 'vite'
import vue from '@vitejs/plugin-vue'
import Components from 'unplugin-vue-components/vite'
import AutoImport from 'unplugin-auto-import/vite'
import {
  ElementPlusResolver
} from 'unplugin-vue-components/resolvers'
// https://vitejs.dev/config/
export default defineConfig({
  base: '/aProject/',
  plugins: [vue(),
    AutoImport({
      resolvers: [ElementPlusResolver()],
    }),
    Components({
      resolvers: [ElementPlusResolver()],
    }),
  ]
})</code></pre>
<p>那么书接上回,直接运行vite run build 打包出来的文件非常杂乱,可能就像这样</p>
<p><img alt="" height="532" src="image\10c8baacfe7040f08a45d8e77e080e33.png" width="1200"/></p>
<p>如果只是写点简单的小demo倒是没什么,正儿八经写项目就不可以了,</p>
<p>所以我们要对静态资源打包做处理,在defineConfig里添加build设置</p>
<pre><code class="language-javascript">build: {
    rollupOptions: {
      output: {
        chunkFileNames: 'static/js/[name]-[hash].js',
        entryFileNames: 'static/js/[name]-[hash].js',
        assetFileNames: 'static/[ext]/[name]-[hash].[ext]',
      }
    }
  }
</code></pre>
<p> 那么我们来测试一下效果</p>
<pre><code>npm run build</code></pre>
<p><img alt="" height="537" src="image\a706a376f55641b68789e818eb9e451d.png" width="1200"/></p>
<p> 显然整齐多了,看着也舒服些</p>
<h2 id="%C2%A02.%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E5%88%86%E6%8B%86"> 2.静态资源文件分拆</h2>
<p><span style="color:#fe2c24;"><strong>注意:</strong></span></p>
<p><strong>此处用了其他项目文件来举例,</strong></p>
<p><strong>之前用来举例的项目(a-project)没引用什么插件,eleplus也是按需引入的,没办法复现警报场景,</strong></p>
<p><strong>主要在这里介绍用法,静态资源相关写完之后会用回项目(a-project)</strong></p>
<p>现在我们演示的只是个小项目,正常项目里可能会引入非常多的插件来实现功能,</p>
<p>打包是就会出现文件过大的警告,例如我拿来举例子的这个项目</p>
<p><strong>引入了诸如视频\声纹\elementplus(非按需自动引入)等组件</strong>,在打包时就出现了这种情况</p>
<p><img alt="" height="1200" src="image\e5b80084c3f44d7e93eb4c554c123fe1.png" width="1200"/></p>
<p> (!) Some chunks are larger than 500 KiB after minification. Consider:<br/> - Using dynamic import() to code-split the application<br/> - Use build.rollupOptions.output.manualChunks to improve chunking: https://rollupjs.org/guide/en/#outputmanualchunks<br/> - Adjust chunk size limit for this warning via build.chunkSizeWarningLimit.</p>
<p>超过500k就报警,然后这里有个1mb多的巨无霸在这里看着你= =</p>
<p>这时候我们有两个处理方案:</p>
<h3 id="2.1%E6%8F%90%E9%AB%98%E5%A4%A7%E8%AD%A6%E5%91%8A%E9%97%A8%E6%A7%9B%C2%A0%C2%A0">2.1提高超大静态资源警告门槛  </h3>
<p>我们先来说简单方案,不是超过500k就报警吗,</p>
<p>那我提高报警限制就好了啊,所以我们把警告限制提高到1500kb</p>
<p>我们在build设置里添加一行代码,像这样</p>
<pre><code class="language-javascript"> build:{
    chunkSizeWarningLimit: 1500,
//其他配置这里就省略了 减少点重复代码长度
  }</code></pre>
<p>然后我们run build</p>
<p><img alt="" height="906" src="image\37bb63c705dd48cf9adc2a3a69ce568f.png" width="1200"/></p>
<p> 巨无霸还在,但是不再报警告了</p>
<p>但是这他妈不是掩耳盗铃吗?所以我们要采用第二种方法</p>
<h3 id="2.2%E8%B6%85%E5%A4%A7%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%8B%86%E5%88%86">2.2超大静态资源拆分</h3>
<p>还是老样子,我们在build里的output设置内,添加以下代码</p>
<pre><code class="language-javascript"> manualChunks(id) {
          if (id.includes('node_modules')) {
            return id.toString().split('node_modules/')[1].split('/')[0].toString();
          }
        }</code></pre>
<p>再次run build 文件就被拆开了,而不是所有引入的js都糊在一起拼巨无霸了</p>
<p><img alt="" height="1200" src="image\f5a1d4e94ed34093b51cbc0dc3f80078.png" width="1140"/></p>
<p> 但是还是有个300多kb的视屏插件和500多kb的eleplus....所以按需引入eleplus和选择合适的插件还是很重要的</p>
<h2 id="3.gzip%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E5%8E%8B%E7%BC%A9">3.gzip静态资源压缩</h2>
<p>那么大文件也不能放任自流,我们还是可以通过gzip压缩来处理一下的</p>
<p>先安装插件,控制台输入</p>
<pre><code> npm i vite-plugin-compression -D</code></pre>
<p>然后修改vite.congfig.js页面,引入并在plugin内使用</p>
<pre><code class="language-javascript">//引入
import viteCompression from 'vite-plugin-compression'
//在plugins配置数组里添加gzip插件
 plugins: [viteCompression({
    verbose: true,
    disable: false,
    threshold: 10240,
    algorithm: 'gzip',
    ext: '.gz',
  })],

</code></pre>
<p>run build 运行一下,惊喜大大的,大文件压缩效率喜人</p>
<p><img alt="" height="1200" src="image\d1f5de0b77764e3e854e661bcce39fc3.png" width="1200"/></p>
<h2 id="%C2%A04.%E6%B8%85%E9%99%A4console%E5%92%8Cdebugger"> 4.清除console和debugger</h2>
<p>这一步比较简单,在build里添加terserOptions配置即可</p>
<pre><code class="language-javascript">terserOptions: {
        compress: {
          drop_console: true,
          drop_debugger: true,
        },
      },</code></pre>
<h2 id="5.IE%E5%92%8C%E6%97%A7%E7%89%88chrome%E5%85%BC%E5%AE%B9">5.IE和旧版chrome兼容</h2>
<p>首先在这里祝福还在<strong>非被迫情况下</strong>坚持使用IE和旧版chrome的人____,使用落后产品上瘾吗?</p>
<p>那么兼容主要就是安装一个插件,我们控制台输入</p>
<pre><code>npm i @vitejs/plugin-legacy -D</code></pre>
<p>然后老样子,去vite.config.js页面引入和使用</p>
<pre><code class="language-javascript">//引入
import legacyPlugin from '@vitejs/plugin-legacy'
//在plugins配置数组里添加legacy插件
 plugins: [legacyPlugin({
      targets: ['chrome 52'], // 需要兼容的目标列表，可以设置多个
      additionalLegacyPolyfills: ['regenerator-runtime/runtime'] // 面向IE11时需要此插件
    })],</code></pre>
<p>那么这样你的代码就可以兼容<strong>淘汰产品</strong>了</p>
<p>今天就写到这里,太累了写不动了</p>
<p></p>
<h2 id="%E6%9C%AA%E5%AE%8C%E5%BE%85%E7%BB%AD%2C%E7%9B%AE%E5%89%8D%E9%A1%B9%E7%9B%AE(a-project)%E7%9A%84vite%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B">未完待续,目前项目(a-project)的vite配置代码如下</h2>
<pre><code class="language-javascript">import {
  defineConfig,
  loadEnv
} from 'vite'
import vue from '@vitejs/plugin-vue'
import Components from 'unplugin-vue-components/vite'
import AutoImport from 'unplugin-auto-import/vite'
import viteCompression from 'vite-plugin-compression'
import {
  ElementPlusResolver
} from 'unplugin-vue-components/resolvers'
import legacyPlugin from '@vitejs/plugin-legacy'
export default defineConfig({
  base: '/aProject/',
  plugins: [vue(),
    AutoImport({
      resolvers: [ElementPlusResolver()],
    }),
    Components({
      resolvers: [ElementPlusResolver()],
    }), viteCompression({ //gzip压缩
      verbose: true,
      disable: false,
      threshold: 10240,
      algorithm: 'gzip',
      ext: '.gz',
    }), legacyPlugin({
      targets: ['chrome 52'], // 需要兼容的目标列表，可以设置多个
      additionalLegacyPolyfills: ['regenerator-runtime/runtime'] // 面向IE11时需要此插件
    })
  ],
  build: {
    terserOptions: {
      compress: {
        drop_console: true,
        drop_debugger: true,
      },
    },
    // chunkSizeWarningLimit: 1500,大文件报警阈值设置,不建议使用
    rollupOptions: {
      output: { //静态资源分类打包
        chunkFileNames: 'static/js/[name]-[hash].js',
        entryFileNames: 'static/js/[name]-[hash].js',
        assetFileNames: 'static/[ext]/[name]-[hash].[ext]',
        manualChunks(id) { //静态资源分拆打包
          if (id.includes('node_modules')) {
            return id.toString().split('node_modules/')[1].split('/')[0].toString();
          }
        }
      }
    }
  }
})</code></pre>
<p></p>
</div>
</div>