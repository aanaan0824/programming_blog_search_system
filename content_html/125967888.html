<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<p id="main-toc"><strong>目录</strong></p>
<p id="%E5%BC%95%E8%A8%80-toc" style="margin-left:0px;"><a href="#%E5%BC%95%E8%A8%80">引言</a></p>
<p id="%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E7%9A%84%E4%B8%89%E8%A6%81%E7%B4%A0%C2%A0-toc" style="margin-left:0px;"><a href="#%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E7%9A%84%E4%B8%89%E8%A6%81%E7%B4%A0%C2%A0">网络通信的三要素 </a></p>
<p id="IP%C2%A0-toc" style="margin-left:40px;"><a href="#IP%C2%A0">IP </a></p>
<p id="IP%E5%9C%B0%E5%9D%80%E6%93%8D%E4%BD%9C%E7%B1%BBInetAddress%C2%A0-toc" style="margin-left:80px;"><a href="#IP%E5%9C%B0%E5%9D%80%E6%93%8D%E4%BD%9C%E7%B1%BBInetAddress%C2%A0">IP地址操作类InetAddress </a></p>
<p id="%E7%AB%AF%E5%8F%A3%E5%8F%B7%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89%C2%A0-toc" style="margin-left:40px;"><a href="#%E7%AB%AF%E5%8F%A3%E5%8F%B7%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89%C2%A0">端口号（了解） </a></p>
<p id="%E5%8D%8F%E8%AE%AE%C2%A0-toc" style="margin-left:40px;"><a href="#%E5%8D%8F%E8%AE%AE%C2%A0">协议 </a></p>
<p id="UDP%E9%80%9A%E4%BF%A1%C2%A0-toc" style="margin-left:0px;"><a href="#UDP%E9%80%9A%E4%BF%A1%C2%A0">UDP通信 </a></p>
<p id="TCP%E9%80%9A%E4%BF%A1%C2%A0-toc" style="margin-left:0px;"><a href="#TCP%E9%80%9A%E4%BF%A1%C2%A0">TCP通信 </a></p>
<p id="%E5%AE%9E%E7%8E%B0%E5%90%8C%E6%97%B6%E6%8E%A5%E6%94%B6%E5%A4%9A%E4%B8%AA%E5%AE%A2%E6%88%B7%E7%AB%AF%C2%A0-toc" style="margin-left:40px;"><a href="#%E5%AE%9E%E7%8E%B0%E5%90%8C%E6%97%B6%E6%8E%A5%E6%94%B6%E5%A4%9A%E4%B8%AA%E5%AE%A2%E6%88%B7%E7%AB%AF%C2%A0">实现同时接收多个客户端 </a></p>
<p id="%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BC%98%E5%8C%96%C2%A0-toc" style="margin-left:80px;"><a href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BC%98%E5%8C%96%C2%A0">线程池优化 </a></p>
<hr id="hr-toc"/>
<p></p>
<p></p>
<h1 id="%E5%BC%95%E8%A8%80">引言</h1>
<blockquote>
<p>         经过前面的课程，我们已经大概地了解到多线程的知识了，不知道大家是否已经掌握了呢？如果已经掌握了的话，那么我们今天就开始学习Java中的网络编程的相关知识，那么什么是网络编程呢？网络编程是可以让程序与网络上的其他设备中的数据进行数据交互。常见的通信模式有两种形式：Client-Server(CS)、Browser/Server(BS)。接下来我们将要学习的知识是网络通信的三要素、UDP通信、TCP通信。</p>
<p><img alt="" height="1200" src="image\9cf3e118b7924a3985ae558a6986875c.png" width="1200"/></p>
<p></p>
</blockquote>
<h1 id="%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E7%9A%84%E4%B8%89%E8%A6%81%E7%B4%A0%C2%A0">网络通信的三要素 </h1>
<blockquote>
<p>关键的三要素：</p>
<ul><li><span style="background-color:#a2e043;">IP地址</span>：设备在网络中的地址。</li><li><span style="background-color:#38d8f0;">端口</span>：应用程序在设备中唯一的标识。</li><li><span style="background-color:#faa572;">协议</span>：数据库在网络中传输的规则，常见的协议有UDP协议和TCP协议。</li></ul>
<p>（在通信过程中通过IP地址寻找设备，端口确定设备中的应用中的程序。） </p>
<p></p>
</blockquote>
<h2 id="IP%C2%A0"><span style="background-color:#a2e043;">IP </span></h2>
<blockquote>
<p>IP地址形式：</p>
<ul><li>公网地址和私有地址（局域网使用）</li><li>192.168.开头的就是常见的局域网地址，范围即为192.168.0.0--192.168.255.255，专门为组织机构内部使用。</li></ul>
<p>IP常用命令：</p>
<ul><li>ipconfig：查看本机IP地址</li><li>ping IP地址：检查网路是否连通</li></ul>
<p>特殊IP地址：</p>
<ul><li>本机IP：127.0.0.1或者localhost：称为回送地址也可称为本地回环地址，只会寻找当前所在本机。 </li></ul>
</blockquote>
<h3 id="IP%E5%9C%B0%E5%9D%80%E6%93%8D%E4%BD%9C%E7%B1%BBInetAddress%C2%A0">IP地址操作类InetAddress </h3>
<blockquote>
<p>InetAddress常用API</p>
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>名称</td><td>说明</td></tr><tr><td>public static InetAddress getLocalHost()</td><td>返回本主机的地址对象</td></tr><tr><td>public static InetAddress getByName(String host)</td><td>得到指定主机的IP地址对象，参数是域名或者IP地址</td></tr><tr><td>public string getHostName()</td><td>获取此IP地址的主机名</td></tr><tr><td>public string getHostAddress()</td><td>返回IP地址字符串</td></tr><tr><td>public boolean isReachable(int timeout)</td><td>在指定毫秒内连通该IP地址对应的主机，连通返回true</td></tr></tbody></table>
<p></p>
<pre><code class="language-java">
        InetAddress ip1 = InetAddress.getLocalHost();
        //获取IP地址字符串
        System.out.println(ip1.getHostAddress());
        //返回IP地址主机名
        System.out.println(ip1.getHostName());
        //得到指定主机的IP地址对象
        InetAddress ip2 = InetAddress.getByName("www.bilibili.com");
        //返回IP地址主机名
        System.out.println(ip2.getHostName());
        //获取IP地址字符串
        System.out.println(ip2.getHostAddress());
        //得到指定主机的IP地址对象
        InetAddress ip3 = InetAddress.getByName("111.6.174.2");
        //返回IP地址主机名
        System.out.println(ip3.getHostName());
        //获取IP地址字符串
        System.out.println(ip3.getHostAddress());
        //5秒后连通
        System.out.println(ip3.isReachable(5000));</code></pre>
<p class="img-center"><img alt="" height="178" src="https://img-blog.csdnimg.cn/3668bb26ae8c48a6b917f895dabf17e2.gif" width="220"/></p>
<p></p>
</blockquote>
<h2 id="%E7%AB%AF%E5%8F%A3%E5%8F%B7%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89%C2%A0"><span style="background-color:#38d8f0;">端口号（了解） </span></h2>
<blockquote>
<p>端口号：标识正在计算机设备上运行的进程（程序），被规定为一个16位的二进制，范围是0-65535。</p>
<p>端口类型：0-1023，被预先定义的知名应用占用（如:HTTP占用80，FTP占用21)。</p>
<p>注册端口:1024-49151，分配给用户进程或某些应用程序。(如:Tomcat占用8080，MySQL占用3306)。</p>
<p>动态端口:49152-65535，之所以称为动态端口，是因为它一般不固定分配某种进程，而是动态分配。</p>
<p><span style="color:#fe2c24;"><strong>注意:</strong></span>我们自己开发的程序选择注册端口，且一个设备中不能出现两个程序的端口号一样，否则出错。</p>
</blockquote>
<h2 id="%E5%8D%8F%E8%AE%AE%C2%A0"><span style="background-color:#faa572;">协议 </span></h2>
<blockquote>
<p>传输层的两个常见协议：</p>
<ul><li><span style="background-color:#a2e043;">TCP：传输控制协议</span></li><li><span style="background-color:#38d8f0;">UDP：用户数据协议</span></li></ul>
<p><span style="background-color:#a2e043;">TCP</span>协议特点：</p>
<ul><li>使用TCP协议，必须双方先建立连接，它是一种面向连接的可靠通信协议</li><li>传输前，采用“三次握手”方式建立连接，所以是可靠的</li><li>在连接中可进行大数据量的传输</li><li>连接、发送数据都需要确认，且传输完毕后，还需释放已建立的连接，通信效率较低</li></ul>
<p><span style="background-color:#a2e043;">TCP</span>协议通信场景：</p>
<ul><li>对信息安全要求较高的场景，如：文件下载、金融等数据通信</li></ul>
<p><span style="background-color:#38d8f0;">UDP</span>协议：</p>
<ul><li>UDP是一种无连接、不可靠传输的协议</li><li>将数据源IP、目的地IP和端口封装成数据包，不需要建立连接</li><li>每个数据包的大小限制在64KB内</li><li>发送不管对方是否准备好，接收方收到也不确认，故是不可靠的</li><li>可以广播发送，发送数据结束时无需释放资源，开销小，速度快</li></ul>
<p><span style="background-color:#38d8f0;">UDP</span>协议通信场景：</p>
<p>语言通话、视频通话等。</p>
<p></p>
<p class="img-center"><img alt="" height="212" src="https://img-blog.csdnimg.cn/3103e087c8a7478092d80bca7e3d255a.gif" width="256"/></p>
<p></p>
</blockquote>
<h1 id="UDP%E9%80%9A%E4%BF%A1%C2%A0">UDP通信 </h1>
<blockquote>
<p>DatagramPacket：数据包对象</p>
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>构造器</td><td>说明</td></tr><tr><td>public DatagramPacket(byte[ ]buf,int length,InetAddress address,int port)</td><td> <p><span style="color:#fe2c24;">创建发送端数据包对象</span><br/> buf:要发送的内容，字节数组</p> <p>length:要发送内容的字节长度</p> <p>address:接收端的</p> <p>IP地址对象</p> <p>port:接收端的端口号</p> </td></tr><tr><td>public DatagramPacket(byte [ ] buf, int length  )</td><td> <p><span style="color:#fe2c24;">创建接收端的数据包对象</span></p> <p>buf:用来存储接收的内容</p> <p>length:能够接收内容的长度</p> </td></tr></tbody></table>
<p> DatagramSocket:发送端和接收端对象</p>
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>构造器</td><td>说明</td></tr><tr><td>public DatagramSocket( )</td><td>创建发送端的socket对象，系统会随机分配一个端口号</td></tr><tr><td>public DatagramSocket(int port)</td><td>创建接收端的socket对象并指定端口号</td></tr></tbody></table>
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>方法</td><td>说明</td></tr><tr><td>public void send （DatagramPacket dp）</td><td>发送数据包</td></tr><tr><td>public void receive （DatagramPacket p）</td><td>接收数据包</td></tr></tbody></table>
<p>        为了更好的理解DatagramSocket和DatagramPacket，我们可以形象的把UDP形象的想象成“网购”，其中DatagramPacket就代表我们想要网购的商品，虽然这是我们买的，但是我们肯定是没有办法亲自去把商品拿走，因此就需要快递的运送，而DatagramSocket就是充当这个角色。商家将需要邮寄的商品通过DatagramPacket封装起来，然后再通过快递DatagramSocket将该商品派送到买家的手中。</p>
<pre><code class="language-java">//客户端
public static void main(String[] args) throws Exception{
        DatagramSocket socket = new DatagramSocket();
        byte [] buffer = "你好，我是石原里美！".getBytes();
        DatagramPacket packet = new DatagramPacket(buffer,buffer.length, InetAddress.getLocalHost(),9999);
        socket.send(packet);
        socket.close();
    }</code></pre>
<pre><code class="language-java">//服务端
public static void main(String[] args) throws Exception{
        DatagramSocket socket = new DatagramSocket(9999);
        byte[] buffer = new byte[1024];
        DatagramPacket packet = new DatagramPacket(buffer,buffer.length);
        socket.receive(packet);
        int len = packet.getLength();//返回获取数据的长度
        String s = new String(buffer,0,len);
        System.out.println(s);
        socket.close();
    }</code></pre>
<p><span style="color:#fe2c24;">注意：</span>服务端需要先启动，等待客户端向服务端传送数据。</p>
<p class="img-center"><img alt="" height="177" src="https://img-blog.csdnimg.cn/2e1f3746c6f244389bf14101ca58837d.gif" width="230"/></p>
<p></p>
</blockquote>
<h1 id="TCP%E9%80%9A%E4%BF%A1%C2%A0">TCP通信 </h1>
<blockquote>
<p>Socket</p>
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>构造器</td><td>说明</td></tr><tr><td>public Socket(String host , int port)<br/>  </td><td>创建发送端的Socket对象与服务端连接，参数为服务端程序的ip和端口。<br/>  </td></tr></tbody></table>
<p></p>
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>方法</td><td>说明</td></tr><tr><td>OutputStream getOutputStream( )</td><td>获得字节输出流对象</td></tr><tr><td>InputStream getInputStream()</td><td>获得字节输入流对象</td></tr></tbody></table>
<p>ServerSocket(服务端)</p>
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>构造器</td><td>说明</td></tr><tr><td>public ServerSocket(int port)</td><td>注册服务端端口</td></tr></tbody></table>
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>方法</td><td>说明</td></tr><tr><td>public Socket accept（）</td><td> <p>等待接口客户端的Socket通信连接，连接成功返回Socket对象与客户端建立端与端通信</p> </td></tr></tbody></table>
<pre><code class="language-java">//客户端
public static void main(String[] args) throws Exception{
        Socket socket = new Socket("172.0.0.1",7777);
        OutputStream os = socket.getOutputStream();
        //通过打印输入流可以更高效
        PrintStream printStream = new PrintStream(os);
        printStream.println("你好，我是石原里美！");
        printStream.flush();
        }
    }</code></pre>
<pre><code class="language-java">public static void main(String[] args) throws  Exception{
        ServerSocket serverSocket = new ServerSocket(7777);
        Socket socket = serverSocket.accept();
        InputStream is = socket.getInputStream();
        //将字节输入流转化位字符输入流，再封装位缓冲字符输入流
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(is));
        String s ;
        while ((s = bufferedReader.readLine())!=null){
            System.out.println(socket.getLocalSocketAddress()+s);
        }
    }</code></pre>
<p class="img-center"><img alt="" height="207" src="https://img-blog.csdnimg.cn/f8bf0f38197c4171883f3e73eb762861.gif" width="207"/></p>
<p></p>
</blockquote>
<h2 id="%E5%AE%9E%E7%8E%B0%E5%90%8C%E6%97%B6%E6%8E%A5%E6%94%B6%E5%A4%9A%E4%B8%AA%E5%AE%A2%E6%88%B7%E7%AB%AF%C2%A0">实现同时接收多个客户端 </h2>
<blockquote>
<p>如果想要实现同时接收多个客户端的话，就需要使用多线程的知识，创建多个服务端。</p>
<p>首先创建一个类继承Thread，用于创建多线程：</p>
<pre><code class="language-java">public class ServerThread extends Thread{
    private Socket socket;

    public ServerThread(Socket socket) {
        this.socket = socket;
    }
//中间内容不在此赘述

    @Override
    public void run() {
        try {
            InputStream is = socket.getInputStream();
            BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(is));
            String s ;
            while ((s = bufferedReader.readLine())!=null){
                System.out.println(socket.getLocalSocketAddress()+s);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<p> 客户端代码：</p>
<pre><code class="language-java">public static void main(String[] args) throws Exception{
        Socket socket = new Socket("172.0.0.1",7777);
        OutputStream os = socket.getOutputStream();
        PrintStream printStream = new PrintStream(os);
        Scanner sc = new Scanner(System.in);
        while (true) {
            String s = sc.next();
            printStream.println(s);
            printStream.flush();
        }
    }</code></pre>
<p>服务端代码：</p>
<pre><code class="language-java">public static void main(String[] args) throws  Exception{
        ServerSocket serverSocket = new ServerSocket(7777);
        while (true) {
            Socket socket = serverSocket.accept();
            new ServerThread(socket).start();
        }

    }</code></pre>
<p>具体操作：在运行单个服务端代码之后，运行多个客户端代码即可实现同时接收多个客户端。</p>
<p class="img-center"><img alt="" height="205" src="https://img-blog.csdnimg.cn/453ff129b7ad46b28f1c523a1d320d46.gif" width="243"/></p>
<p></p>
</blockquote>
<h3 id="%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BC%98%E5%8C%96%C2%A0">线程池优化 </h3>
<blockquote>
<p>通过前面的知识，我们了解到每一次都创建一个线程会影响系统的效率，因此需要通过线程池来控制线程的数量，若对线程池不理解的可以看这篇文章：</p>
<p><a class="link-info" href="http://t.csdn.cn/sORad" title="Java中的多线程如何理解">Java中的多线程如何理解</a></p>
<p>相对之前需要将线程类更改一下，需要写一个实现Runnable接口的线程类。</p>
<pre><code class="language-java">public class ServerRunnable implements Runnable{
    private Socket socket;

    @Override
    public void run() {
        
    }
}</code></pre>
<p>最后则是需要在服务端作出修改，定义一个线程池：</p>
<pre><code class="language-java">public class ServerData {
    private static ExecutorService pool = new ThreadPoolExecutor(3,5,5, TimeUnit.SECONDS,new ArrayBlockingQueue&lt;&gt;(3),
            Executors.defaultThreadFactory(),new ThreadPoolExecutor.AbortPolicy());
    public static void main(String[] args) throws  Exception{
        ServerSocket serverSocket = new ServerSocket(7777);
        while (true) {
            Socket socket = serverSocket.accept();
            ServerRunnable target = new ServerRunnable(socket);
            pool.execute(target);
        }

    }
}</code></pre>
<p></p>
</blockquote>
<p style="text-align:center;"><span style="color:#38d8f0;"><strong>创作不易，给个三连</strong></span> </p>
<p></p>
<p class="img-center"><img alt="" height="331" src="image\87e44749101b4304a8acec5c12b37dd0.jpeg" width="232"/></p>
<p></p>
</div>
</div>