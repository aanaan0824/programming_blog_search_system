<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="markdown_views prism-atom-one-light" id="content_views">
<svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
<path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
</svg>
<h1><a id="_0"></a>项目场景：</h1>
<p>C++——WebServer服务器编程</p>
<hr/>
<h1><a id="_5"></a>项目搭建</h1>
<p>（1）配置虚拟机，下载XShell、Xftp以及windows版本的VScode；</p>
<p>（2）安装SSH：</p>
<pre><code class="prism language-cpp">sudo apt install openssh<span class="token operator">-</span>server
</code></pre>
<p>（3）在XShell中配置会话以连接到虚拟机，VScode中配置远程SSH；</p>
<p>（4）安装数据库：</p>
<pre><code class="prism language-cpp">sudo apt install mysql<span class="token operator">-</span>server
sudo apt install mysql<span class="token operator">-</span>client
sudo apt install libmysqlclient<span class="token operator">-</span>dev
</code></pre>
<p>查看账号以及密码以登录数据库：</p>
<pre><code class="prism language-cpp">sudo cat <span class="token operator">/</span>etc<span class="token operator">/</span>mysql<span class="token operator">/</span>debian<span class="token punctuation">.</span>cnf
</code></pre>
<p>之后修改密码。。。遇到修改密码问题参考<a href="https://blog.csdn.net/weixin_39718460/article/details/113426423">mysql debian-sys-maint_关于mysql安装后登不进的问题–ERROR 1045 (28000): Access denied for user 'debian-sys-main…</a></p>
<p>（5）安装g++、gcc、make等工具：</p>
<pre><code class="prism language-cpp">sudo apt install build<span class="token operator">-</span>essential
</code></pre>
<p>（6）在当前目录（有Makefile文件的目录）：</p>
<pre><code class="prism language-cpp">make
</code></pre>
<p>生成的可执行文件在<code>bin</code>目录下。<br/> 在终端输入：</p>
<pre><code class="prism language-cpp">bin<span class="token operator">/</span>server
</code></pre>
<p>打开浏览器，输入自己虚拟机的IP地址以及端口号1316。<br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/ff2a725ee23e457db8fd4d052f5064ef.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAd3Jkb2N0,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<h1><a id="_50"></a>知识点</h1>
<h2><a id="1Linux_51"></a>1.Linux相关</h2>
<p>（1）常用命令：</p>
<pre><code class="prism language-cpp">ifconfig  			<span class="token comment">//查看网络配置和IP地址</span>
ps aux				<span class="token comment">//查看进程</span>
ps <span class="token operator">-</span>ef <span class="token operator">|</span> grep ssh   <span class="token comment">//ps查看进程信息  |管道符   grep过滤</span>
top					<span class="token comment">//实时显示进程动态</span>
ulimit <span class="token operator">-</span>a			<span class="token comment">//查看进程id、状态、可使用的资源上限</span>
kill <span class="token operator">-</span>l				<span class="token comment">//列出所有信号</span>
netstat <span class="token operator">-</span>anp 		<span class="token comment">//查看网络状态</span>

cd					<span class="token comment">//返回根目录</span>
cd <span class="token punctuation">.</span><span class="token punctuation">.</span>				<span class="token comment">//返回上一级目录</span>
pwd  			   <span class="token comment">//查看当前目录</span>
ll  			   <span class="token comment">//查看当前目录下各文件（夹）的详细信息（权限、大小、修改时间等）</span>
chmod				<span class="token comment">//更改权限</span>
mkdir				<span class="token comment">//新建文件夹</span>
rename				<span class="token comment">//重命名文件夹</span>
rmdir				<span class="token comment">//删除文件夹</span>
mv					<span class="token comment">//移动  改名</span>
ls					<span class="token comment">//显示当前目录下的所有文件（夹）</span>
cp					<span class="token comment">//复制</span>
rm					<span class="token comment">//删除   -r 删除文件夹</span>
touch				<span class="token comment">//创建文件</span>
cat					<span class="token comment">//显示文件内容</span>
tree				<span class="token comment">//查看树形的文件分布</span>

echo				<span class="token comment">//用于字符串的输出</span>
clear				<span class="token comment">//清除屏幕  ctrl+l</span>
man					<span class="token comment">//使用手册</span>
history				<span class="token comment">//查看历史使用命令</span>
free <span class="token operator">-</span>m 			<span class="token comment">//查看内存使用情况</span>

gcc <span class="token operator">-</span>v				<span class="token comment">//查看gcc版本</span>
g<span class="token operator">++</span> <span class="token operator">-</span>v				<span class="token comment">//查看g++版本</span>
</code></pre>
<p>（2）程序的运行过程：<br/> 预处理–&gt;编译–&gt;汇编–&gt;链接。<br/> 预处理<code>-E</code>：宏替换、去掉注释、头文件拷贝生成<code>.i文件</code>；<br/> 编译不汇编<code>-S</code>生成<code>.s文件</code>，编译汇编<code>-c</code>：语法检查生成<code>.o文件</code>；<br/> 链接整合定义生成可执行程序<code>.out文件</code>。</p>
<p>【注】声明作用在编译阶段，定义（装在链接库里）作用在链接阶段。</p>
<p>（3）<code>Makefile</code>定义了一系列规则，通过make执行——&gt;自动化编译。<br/> </p>
<p>（4）gdb调试：</p>
<pre><code class="prism language-cpp"><span class="token operator">-</span>g				<span class="token comment">//调试  在可执行文件中加入源代码信息</span>
<span class="token operator">-</span>D				<span class="token comment">//在编译时指定一个宏</span>

<span class="token operator">-</span>w				<span class="token comment">//不生成警告</span>
<span class="token operator">-</span>Wall			<span class="token comment">//生成所有警告</span>
<span class="token operator">-</span>On				<span class="token comment">//优化级别 n：1 2 3</span>
<span class="token operator">-</span>l				<span class="token comment">//指定使用的库</span>
<span class="token operator">-</span>L				<span class="token comment">//库路径</span>
<span class="token operator">-</span>std			<span class="token comment">//-std==c++11</span>
<span class="token operator">-</span>I				<span class="token comment">//指定include包含搜索的目录</span>
</code></pre>
<p>终端输入</p>
<pre><code class="prism language-cpp">g<span class="token operator">++</span> <span class="token operator">-</span>g <span class="token operator">-</span>Wall main<span class="token punctuation">.</span>cpp <span class="token operator">-</span>o main
gdb main
</code></pre>
<p>进入调试模式，命令：</p>
<pre><code class="prism language-cpp">l 行号				<span class="token comment">//查看代码</span>
b 行号				<span class="token comment">//打断点</span>
i <span class="token keyword">break</span>				<span class="token comment">//查看断点信息</span>
d 断点编号			<span class="token comment">//删除断点</span>

start				<span class="token comment">//程序停在第一行</span>
run					<span class="token comment">//遇到断点停止</span>
c					<span class="token comment">//继续，到下一个断点停</span>

s					<span class="token comment">//向下单步调试（会进入函数体）</span>
finish				<span class="token comment">//跳出函数体</span>
n					<span class="token comment">//向下直行一行代码（不进入函数体）</span>

p 变量名				<span class="token comment">//打印变量的值</span>
ptype 变量名			<span class="token comment">//打印变量类型</span>
</code></pre>
<p>【注】多进程下的GDB调试：</p>
<pre><code class="prism language-bash"><span class="token builtin class-name">set</span> follow-fork-mode child 调试子进程
<span class="token builtin class-name">set</span> follow-fork-mode parent 调试父进程
</code></pre>
<p>（5）静态库（lib/a）和动态库（dll/so）：</p>
<pre><code class="prism language-cpp">静态库在链接阶段复制到程序中（速度快，占内存）
动态库在运行时由系统动态加载到程序中（速度慢，共享库）
</code></pre>
<pre><code class="prism language-cpp">静态库：
g<span class="token operator">++</span>得到<span class="token punctuation">.</span>o文件
ar rcs libxxx<span class="token punctuation">.</span>a xxx<span class="token punctuation">.</span>o

动态库：
g<span class="token operator">++</span> <span class="token operator">-</span>c <span class="token operator">-</span>fpic xxx<span class="token punctuation">.</span>cpp
g<span class="token operator">++</span> <span class="token operator">-</span>shared xxx<span class="token punctuation">.</span>o <span class="token operator">-</span>o libxxx<span class="token punctuation">.</span>so
<span class="token comment">//</span>
ldd 可执行文件名称  <span class="token comment">//查看动态库的依赖关系</span>
</code></pre>
<p>添加环境变量：</p>
<pre><code class="prism language-cpp">env						<span class="token comment">//查看当前系统所有的环境变量</span>
echo $LD_LIBRARY_PATH   <span class="token comment">//查看某个环境变量的值</span>

<span class="token comment">//临时添加环境变量</span>
<span class="token keyword">export</span>	 LD_LIBRARY_PATH<span class="token operator">=</span>$LD_LIBRARY_PATH<span class="token operator">:</span><span class="token operator">/</span>目录路径<span class="token operator">/</span>     

<span class="token comment">//永久添加环境变量</span>
vim <span class="token punctuation">.</span>bashrc   <span class="token comment">//.bashrc是用户级的配置文件</span>
再将<span class="token keyword">export</span>	 LD_LIBRARY_PATH<span class="token operator">=</span>$LD_LIBRARY_PATH<span class="token operator">:</span><span class="token operator">/</span>目录路径<span class="token operator">/</span>  加进去
<span class="token punctuation">.</span> <span class="token punctuation">.</span>bashrc  或者 source <span class="token punctuation">.</span>bashrc
</code></pre>
<h2><a id="2_178"></a>2.多进程</h2>
<p>（1）程序是包含一系列信息的文件，这些信息描述了如何在运行时创建一个进程。<br/> 进程是正在运行的程序的实例。</p>
<p>（2）<strong>并行</strong>：同一时刻，有多条指令在多个处理器上<strong>同时执行</strong>。<br/> <strong>并发</strong>：同一时刻，只能有一条指令执行，但多个进程指令被快速<strong>轮换执行</strong>，宏观上同时执行，微观上并不是同时执行，只是把时间片分成若干段，使多个进程快速交替的执行</p>
<p>（3）进程控制块<code>PCB</code>：为了管理进程，内核必须对每个进程所作的事情进行清楚的描述。</p>
<p>Linux的进程控制块是<code>task_struct</code>结构体。<br/> 里面主要有：<br/> 进程id、状态、可使用资源的上限；<br/> 切换时要保存和恢复的CPU寄存器；<br/> 虚拟地址空间信息；<br/> 终端信息、信号相关信息；<br/> 当前工作目录；<br/> umask掩码；<br/> 文件描述符表；<br/> 用户id、组id、会话和进程组。</p>
<p>（4）在终端输入<code>ulimit -a</code>可以查看资源上限。<br/> 可以使用<code>ulimit -s 具体数值</code>进行修改。</p>
<p>（5）进程状态：<br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/69eb5d0c2c8e4f8ba995efb0fd5846dd.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAd3Jkb2N0,size_20,color_FFFFFF,t_70,g_se,x_16"/><br/> 新建态：创建进程；<br/> 终止态：终止进程。</p>
<p>（6）</p>
<pre><code class="prism language-cpp">top   <span class="token comment">//实时显示进程动态</span>
kill 信号值 PID  <span class="token comment">//杀死进程</span>
kill <span class="token operator">-</span>l  <span class="token comment">//列出所有信号</span>
kill <span class="token operator">-</span><span class="token number">9</span> PID
</code></pre>
<p>（7）除了init进程外，每个进程都有父进程PPID。</p>
<pre><code class="prism language-cpp">pid_t <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取当前进程号</span>
pid_t <span class="token function">getppid</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取当前进程的父进程号</span>
pid_t <span class="token function">getpgid</span><span class="token punctuation">(</span>pid_t pid<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//如果传None获取当前进程的进程组id,如果传进程号获取进程号的进程组ID</span>

pid_t <span class="token function">fork</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//创建进程  //读时共享 写时拷贝  //会返回两次</span>
<span class="token comment">//pid_t pid = fork(); //pid &gt; 0时，执行父进程代码，此时的pid为子进程ID；pid = 0时，执行子进程代码；</span>
</code></pre>
<p>在虚拟地址空间的视角下，<code>fork()</code>函数相当于把父进程的虚拟地址空间clone给子进程。fork()以后，子进程用户区数据和父进程一样。内核区也会拷贝过来，但是<code>PID</code>不一样。但是两个虚拟地址空间是相互独立的。<br/> <img alt="虚拟地址空间" src="https://img-blog.csdnimg.cn/bc5d2366dbc0464891d0bd8d19856a68.png"/><br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/387b02ae6b4941b79e6572a4195cf8bc.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAd3Jkb2N0,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<p>（8）<code>exec</code> 函数族的作用是根据指定的文件名找到可执行文件，并用它来取代调用进程的内容。换句话说，就是<strong>在调用进程内部执行一个可执行文件</strong>。</p>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/4d67970c507042e7a7541e7c76ae5379.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAd3Jkb2N0,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<p>（9）进程的退出：</p>
<pre><code class="prism language-cpp"><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//会刷新I/O缓冲</span>
<span class="token function">_exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//不会刷新I/O缓冲</span>
</code></pre>
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hello\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// exit(0);  //输出hello world</span>
    <span class="token function">_exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//输出hello</span>
    
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>（10）孤儿进程和僵尸进程：<br/> <strong>孤儿进程</strong>：父死子没死，会被init进程接管回收；<br/> <strong>僵尸进程</strong>：父活子死，无法杀死，可以杀死父进程让init进程接管回收。也可以让内核给父进程一个<code>SIGCHLD</code>信号让其回收其子。</p>
<p>（11）进程退出：</p>
<pre><code class="prism language-cpp"><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//一次只能清理一个子进程</span>
<span class="token function">waitpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>（12）进程间的通信（<code>IPC</code>）：数据传输、通知事件、资源共享、进程控制。</p>
<pre><code class="prism language-cpp">信号；  <span class="token comment">//Unix</span>
管道；  <span class="token comment">//Unix</span>
有名管道（FIFO）；  <span class="token comment">//Unix</span>

消息队列；
共享内存；
信号量；

Socket套接字。
</code></pre>
<p>（13）管道：<br/> 用于有<strong>亲缘关系</strong>的进程间通信；<br/> 一个管道是一个<strong>字节流</strong>；<br/> 通过管道传递的数据是<strong>顺序</strong>的，从管道中读取出来字节的顺序和被写入管道的顺序是完全一样的（类似一个队列）；<br/> 管道中数据传递方向是<strong>单向</strong>的，一端写入一端读取，是<strong>半双工</strong>的；<br/> 管道读数据是<strong>一次性</strong>的。<br/> 终端命令：</p>
<pre><code class="prism language-cpp">ls <span class="token operator">|</span> wc <span class="token operator">-</span>l   <span class="token comment">//wc——统计文件数目</span>
ulimit <span class="token operator">-</span>a  <span class="token comment">//查看管道缓冲大小</span>
</code></pre>
<p>函数：</p>
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">pipe</span><span class="token punctuation">(</span><span class="token keyword">int</span> pipefd<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//创建一个匿名管道，用来进程间通信。</span>
<span class="token keyword">long</span> <span class="token function">fpathconf</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">int</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//查看管道缓冲大小</span>
</code></pre>
<p>【注】为什么管道用于有亲缘关系的进程间通信（为什么亲缘关系间的进程能通过管道通信）？<br/> 因为父进程fork出来一个子进程，会把<strong>虚拟地址空间复制</strong>一份，父进程中的这个虚拟地址空间中有一个<strong>文件描述符表</strong>，<strong>指向读端和写端</strong>，那么子进程复制出来也有一个文件描述符表，指向读端和写端，所以能进行通信。<br/> 【注】为什么要一个关闭读端一个要关闭写端？<br/> 为了避免父（子）进程<strong>写</strong>之后父（子）进程又<strong>读</strong>。</p>
<p>（14）有名管道<code>FIFO</code>：<br/> 有名管道提供了一个<strong>路径名</strong>与之关联，所以FIFO创建的进程不存在亲缘关系的限制，进程只要能访问该路径，就能通过FIFO相互通信。<br/> 终端命令：</p>
<pre><code class="prism language-cpp">mkfifo 名字  <span class="token comment">//创建FIFO管道</span>
</code></pre>
<p>函数：</p>
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">mkfifo</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> mode_t mode<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//创建FIFO管道</span>
</code></pre>
<p><strong>管道的读写特点</strong>：</p>
<pre><code class="prism language-cpp">读管道：
    管道中有数据：
    	read返回实际读到的字节数
    管道中无数据：
    	写端被全部关闭，read返回<span class="token number">0</span>（相当于读到文件的末尾）
    	写端没有完全关闭，read阻塞等待
    
写管道：
    读端全部被关闭：
    	进程异常终止（进程收到SIGPIPE信号）
    读端没有全部关闭：
        管道已满，write阻塞
        管道没有满，write将数据写入，并返回实际写入的字节数
</code></pre>
<p>（15）内存映射：<br/> （I/O）将磁盘<strong>文件</strong>数据映射到<strong>内存</strong>，通过<strong>修改内存可修改文件</strong>。<br/> 内存映射实现的进程通信是<strong>非阻塞</strong>的。<br/> 函数：</p>
<pre><code class="prism language-cpp"><span class="token comment">//将一个文件或者设备的数据映射到内存中</span>
<span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">mmap</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>addr<span class="token punctuation">,</span> size_t length<span class="token punctuation">,</span> <span class="token keyword">int</span> prot<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> off_t offset<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//释放内存映射</span>
<span class="token keyword">int</span> <span class="token function">munmap</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>addr<span class="token punctuation">,</span> size_t length<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>（16）共享内存：<br/> 共享内存允许两个或者多个进程共享物理内存的同一块区域（通常被称为段）。<br/> <strong>无需内核介入</strong>。<br/> 终端命令：</p>
<pre><code class="prism language-cpp">ipcs <span class="token operator">-</span>a <span class="token comment">//打印所有ipc信息</span>
ipcs <span class="token operator">-</span>m <span class="token comment">//打印共享内存ipc信息</span>
ipcs <span class="token operator">-</span>q <span class="token comment">//打印消息队列ipc信息</span>
ipcs <span class="token operator">-</span>s <span class="token comment">//打印信号ipc信息</span>

ipcrm <span class="token operator">-</span>M shmkey <span class="token comment">//移除shmkey创建的共享内存段</span>
ipcrm <span class="token operator">-</span>m shmid <span class="token comment">//移除shmid标识的共享内存段</span>
ipcrm <span class="token operator">-</span>Q msgkey <span class="token comment">//移除msgkey创建的消息队列</span>
ipcrm <span class="token operator">-</span>q msgid <span class="token comment">//移除msgid标识的消息队列</span>
ipcrm <span class="token operator">-</span>S semkey <span class="token comment">//移除semkey创建的信号</span>
ipcrm <span class="token operator">-</span>s semid <span class="token comment">//移除semid标识的信号</span>
</code></pre>
<p>函数：</p>
<pre><code class="prism language-cpp"><span class="token comment">//创建一个新的共享内存段，或者获取一个既有的共享内存段的标识。新创建的内存段中的数据都会被初始化为0</span>
<span class="token keyword">int</span> <span class="token function">shmget</span><span class="token punctuation">(</span>key_t key<span class="token punctuation">,</span> size_t size<span class="token punctuation">,</span> <span class="token keyword">int</span> shmflg<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//和当前的进程进行关联</span>
<span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">shmat</span><span class="token punctuation">(</span><span class="token keyword">int</span> shmid<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>shmaddr<span class="token punctuation">,</span> <span class="token keyword">int</span> shmflg<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//通信 addr</span>
<span class="token comment">//释放：</span>
<span class="token comment">//解除当前进程和共享内存的关联</span>
<span class="token keyword">int</span> <span class="token function">shmdt</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>shmaddr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//删除共享内存，只调用一次，所有的关联进程都解除了关联才调用</span>
<span class="token keyword">int</span> <span class="token function">shmctl</span><span class="token punctuation">(</span><span class="token keyword">int</span> shmid<span class="token punctuation">,</span> <span class="token keyword">int</span> cmd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">shmid_ds</span> <span class="token operator">*</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<pre><code class="prism language-cpp">操作系统如何知道一块共享内存被多少个进程关联？
答：	共享内存维护了一个结构体<span class="token keyword">struct</span> <span class="token class-name">shmid_ds</span>，
	这个结构体中有一个成员 shm_nattch，
	shm_nattach 记录了关联的进程个数
</code></pre>
<p>（17）信号：<br/> 信号是 Linux 进程间通信的最古老的方式之一，是事件发生时对进程的<strong>通知机制</strong>，有时也称之为<strong>软件中断</strong>，它是在软件层次上对中断机制的一种模拟，是一种<strong>异步通信</strong>的方式。<br/> 信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断，转而处理某一个突发事件。</p>
<pre><code class="prism language-cpp">信号的特点：
	简单；不能携带大量信息；满足某个特定条件才发送；优先级比较高。
</code></pre>
<p>终端命令：</p>
<pre><code class="prism language-cpp">kill <span class="token operator">-</span>l  <span class="token comment">//查看所有信号</span>
</code></pre>
<p>常用的信号：</p>
<pre><code class="prism language-cpp">SIGINT  <span class="token comment">//终止进程——ctrl+C</span>
SIGQUIT  <span class="token comment">//终止进程——ctrl+\
</span>
SIGKILL  <span class="token comment">//杀死进程</span>
SIGCSTOP  <span class="token comment">//停止进程</span>
SIGCONT  <span class="token comment">//继续进程</span>
</code></pre>
<pre><code class="prism language-cpp">信号的 <span class="token number">5</span> 种默认处理动作：
	Term 终止进程
	Ign 当前进程忽略掉这个信号
	Core 终止进程，并生成一个Core文件<span class="token punctuation">,</span>用于保存错误信息 <span class="token comment">//</span>
	Stop 暂停当前进程
	Cont 继续执行当前被暂停的进程
</code></pre>
<p>【注】Core的使用：</p>
<pre><code class="prism language-cpp">ulimit <span class="token operator">-</span>a
ulimit <span class="token operator">-</span>c unlimited  <span class="token comment">//更改可使用的资源上限</span>

g<span class="token operator">++</span> <span class="token punctuation">.</span><span class="token operator">/</span>a<span class="token punctuation">.</span>out <span class="token operator">-</span>g
gdb a<span class="token punctuation">.</span>out core<span class="token operator">-</span>file core <span class="token comment">//查看core文件的错误信息</span>
</code></pre>
<p>信号的状态：<strong>产生</strong>、<strong>未决</strong>（信号产生了没被处理）、<strong>阻塞</strong>（阻塞信号被处理，不阻塞信号产生）。</p>
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">kill</span><span class="token punctuation">(</span>pid_t pid<span class="token punctuation">,</span> <span class="token keyword">int</span> sig<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//给任何的进程或者进程组pid, 发送任何的信号 sig</span>
<span class="token keyword">int</span> <span class="token function">raise</span><span class="token punctuation">(</span><span class="token keyword">int</span> sig<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//给当前进程发送信号</span>
<span class="token keyword">void</span> <span class="token function">abort</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//发送SIGABRT信号给当前的进程，杀死当前进程</span>

<span class="token comment">//设置定时器（闹钟）。函数调用，开始倒计时，当倒计时为0的时候，函数会给当前的进程发送一个信号：SIGALARM，终止当前进程</span>
<span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token function">alarm</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> seconds<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">alarm</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//取消定时器</span>
<span class="token comment">//设置定时器（闹钟）。可以替代alarm函数。精度微妙us，可以实现周期性定时（每隔几秒钟做一件事）</span>
<span class="token keyword">int</span> <span class="token function">setitimer</span><span class="token punctuation">(</span><span class="token keyword">int</span> which<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">itimerval</span> <span class="token operator">*</span>new_value<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">itimerval</span> <span class="token operator">*</span>old_value<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//设置某个信号的捕捉行为 </span>
sighandler_t <span class="token function">signal</span><span class="token punctuation">(</span><span class="token keyword">int</span> signum<span class="token punctuation">,</span> sighandler_t handler<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token comment">//检查或者改变信号的处理。信号捕捉</span>
<span class="token keyword">int</span> <span class="token function">sigaction</span><span class="token punctuation">(</span><span class="token keyword">int</span> signum<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sigaction</span> <span class="token operator">*</span>act<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sigaction</span> <span class="token operator">*</span>oldact<span class="token punctuation">)</span><span class="token punctuation">;</span>           
</code></pre>
<p>【注】使用<code>SIGCHLD</code>信号解决僵尸进程的问题。</p>
<p>多个信号可使用一个称之为<strong>信号集</strong>的数据结构来表示。</p>
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">sigemptyset</span><span class="token punctuation">(</span>sigset_t <span class="token operator">*</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//清空信号集中的数据,将信号集中的所有的标志位置为0</span>
<span class="token keyword">int</span> <span class="token function">sigfillset</span><span class="token punctuation">(</span>sigset_t <span class="token operator">*</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将信号集中的所有的标志位置为1</span>
<span class="token keyword">int</span> <span class="token function">sigaddset</span><span class="token punctuation">(</span>sigset_t <span class="token operator">*</span>set<span class="token punctuation">,</span> <span class="token keyword">int</span> signum<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//设置信号集中的某一个信号对应的标志位为1，表示阻塞这个信号</span>
<span class="token keyword">int</span> <span class="token function">sigdelset</span><span class="token punctuation">(</span>sigset_t <span class="token operator">*</span>set<span class="token punctuation">,</span> <span class="token keyword">int</span> signum<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//设置信号集中的某一个信号对应的标志位为0，表示不阻塞这个信号</span>
<span class="token keyword">int</span> <span class="token function">sigismember</span><span class="token punctuation">(</span><span class="token keyword">const</span> sigset_t <span class="token operator">*</span>set<span class="token punctuation">,</span> <span class="token keyword">int</span> signum<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//判断某个信号是否阻塞</span>

<span class="token keyword">int</span> <span class="token function">sigprocmask</span><span class="token punctuation">(</span><span class="token keyword">int</span> how<span class="token punctuation">,</span> <span class="token keyword">const</span> sigset_t <span class="token operator">*</span>set<span class="token punctuation">,</span> sigset_t <span class="token operator">*</span>oldset<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将自定义信号集中的数据设置到内核中（设置阻塞，解除阻塞，替换）</span>
<span class="token keyword">int</span> <span class="token function">sigpending</span><span class="token punctuation">(</span>sigset_t <span class="token operator">*</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取内核中的未决信号集</span>
</code></pre>
<p>（18）守护进程：在后台运行，不会被<code>ctrl+C</code>停止。一般采用以 <code>d</code> 结尾的名字。</p>
<h2><a id="3_455"></a>3.多线程</h2>
<p>（1）多线程共享虚拟地址空间，其中栈空间和.text（代码段）被每个线程瓜分（不共享），其他都是共享的资源。<br/> 线程id、error变量、线程特有数据等也不共享。</p>
<p>（2）</p>
<pre><code class="prism language-cpp"><span class="token comment">//创建一个子线程</span>
<span class="token keyword">int</span> <span class="token function">pthread_create</span><span class="token punctuation">(</span>pthread_t <span class="token operator">*</span>thread<span class="token punctuation">,</span> <span class="token keyword">const</span> pthread_attr_t <span class="token operator">*</span>attr<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>start_routine<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//终止一个线程，在哪个线程中调用，就表示终止哪个线程</span>
<span class="token keyword">void</span> <span class="token function">pthread_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>retval<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//获取当前的线程的线程ID</span>
pthread_t <span class="token function">pthread_self</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//比较两个线程ID是否相等</span>
<span class="token keyword">int</span> <span class="token function">pthread_equal</span><span class="token punctuation">(</span>pthread_t t1<span class="token punctuation">,</span> pthread_t t2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//和一个已经终止的线程进行连接（回收线程）</span>
<span class="token keyword">int</span> <span class="token function">pthread_join</span><span class="token punctuation">(</span>pthread_t thread<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token operator">*</span>retval<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//分离一个线程。被分离的线程在终止的时候，会自动释放资源返回给系统</span>
<span class="token keyword">int</span> <span class="token function">pthread_detach</span><span class="token punctuation">(</span>pthread_t thread<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//取消线程（让线程终止）</span>
<span class="token keyword">int</span> <span class="token function">pthread_cancel</span><span class="token punctuation">(</span>pthread_t thread<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>（3）线程同步/线程安全：<br/> 原因：相较于进程需要通过各种<code>IPC</code>来共享信息进行通信，线程可以很方便的使用<strong>全局变量</strong>来共享信息。<br/> 【注】<strong>临界区</strong>是指访问某一共享资源的代码片段，并且这段代码的执行应为原子操作，不会被打断。一次仅允许一个线程使用的共享资源。</p>
<p>概念：当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作，其他线程才能对该内存地址进行操作，而其他线程则处于等待状态。</p>
<p>线程同步的实现一般有下面5种：<strong>互斥量</strong>，<strong>读写锁</strong>，<strong>条件变量</strong>，<strong>自旋锁</strong>，<strong>屏障</strong>。</p>
<pre><code class="prism language-cpp"><span class="token comment">//初始化互斥量</span>
<span class="token keyword">int</span> <span class="token function">pthread_mutex_init</span><span class="token punctuation">(</span>pthread_mutex_t <span class="token operator">*</span>restrict mutex<span class="token punctuation">,</span> <span class="token keyword">const</span> pthread_mutexattr_t <span class="token operator">*</span>restrict attr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//释放互斥量的资源</span>
<span class="token keyword">int</span> <span class="token function">pthread_mutex_destroy</span><span class="token punctuation">(</span>pthread_mutex_t <span class="token operator">*</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>    
<span class="token comment">//加锁，阻塞的，如果有一个线程加锁了，那么其他的线程只能阻塞等待</span>
<span class="token keyword">int</span> <span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span>pthread_mutex_t <span class="token operator">*</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>    
<span class="token comment">//尝试加锁，如果加锁失败，不会阻塞，会直接返回。</span>
<span class="token keyword">int</span> <span class="token function">pthread_mutex_trylock</span><span class="token punctuation">(</span>pthread_mutex_t <span class="token operator">*</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//解锁       - </span>
<span class="token keyword">int</span> <span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span>pthread_mutex_t <span class="token operator">*</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>（4）死锁：忘记释放锁；多次加锁；多线程多锁，抢占锁资源。</p>
<p>产生死锁的四个必要条件：<br/> <strong>互斥条件</strong>：一个资源每次只能被一个进程使用。<br/> <strong>请求与保持条件</strong>：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br/> <strong>不剥夺条件</strong>： 进程已获得的资源，在末使用完之前，不能强行剥夺。<br/> <strong>循环等待条件</strong>：若干进程之间形成一种头尾相接的循环等待资源关系。存在一个进程等待序列{P1，P2，…，Pn}，其中P1等待P2所占有的某一资源，P2等待P3所占有的某一资源，……，而Pn等待P1所占有的的某一资源，形成一个进程循环等待环。</p>
<p>解决死锁的四个方式：<br/> <strong>鸵鸟算法</strong>(直接忽略该问题)。<br/> <strong>检测死锁并且恢复</strong>（检测与解除策略）。<br/> <strong>仔细地对资源进行动态分配，以避免死锁</strong>（避免策略）。<br/> <strong>通过破除死锁四个必要条件之一，来防止死锁产生</strong>（预防策略）</p>
<p>（5）生产者与消费者模型：<br/> 条件变量：</p>
<pre><code class="prism language-cpp"><span class="token comment">//初始化一个条件变量</span>
<span class="token keyword">int</span> <span class="token function">pthread_cond_init</span><span class="token punctuation">(</span>pthread_cond_t <span class="token operator">*</span>restrict cond<span class="token punctuation">,</span> <span class="token keyword">const</span> pthread_condattr_t <span class="token operator">*</span>restrict attr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//释放一个条件变量</span>
<span class="token keyword">int</span> <span class="token function">pthread_cond_destroy</span><span class="token punctuation">(</span>pthread_cond_t <span class="token operator">*</span>cond<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//等待，调用了该函数，线程会阻塞。</span>
<span class="token keyword">int</span> <span class="token function">pthread_cond_wait</span><span class="token punctuation">(</span>pthread_cond_t <span class="token operator">*</span>restrict cond<span class="token punctuation">,</span> pthread_mutex_t <span class="token operator">*</span>restrict mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//等待多长时间，调用了这个函数，线程会阻塞，直到指定的时间结束。</span>
<span class="token keyword">int</span> <span class="token function">pthread_cond_timedwait</span><span class="token punctuation">(</span>pthread_cond_t <span class="token operator">*</span>restrict cond<span class="token punctuation">,</span> pthread_mutex_t <span class="token operator">*</span>restrict mutex<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">timespec</span> <span class="token operator">*</span>restrict abstime<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//唤醒一个或者多个等待的线程</span>
<span class="token keyword">int</span> <span class="token function">pthread_cond_signal</span><span class="token punctuation">(</span>pthread_cond_t <span class="token operator">*</span>cond<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//唤醒所有的等待的线程</span>
<span class="token keyword">int</span> <span class="token function">pthread_cond_broadcast</span><span class="token punctuation">(</span>pthread_cond_t <span class="token operator">*</span>cond<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>信号量：互斥锁+条件变量</p>
<pre><code class="prism language-cpp"><span class="token comment">//初始化信号量</span>
<span class="token keyword">int</span> <span class="token function">sem_init</span><span class="token punctuation">(</span>sem_t <span class="token operator">*</span>sem<span class="token punctuation">,</span> <span class="token keyword">int</span> pshared<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//释放资源</span>
<span class="token keyword">int</span> <span class="token function">sem_destroy</span><span class="token punctuation">(</span>sem_t <span class="token operator">*</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//对信号量加锁，调用一次对信号量的值-1，如果值为0，就阻塞</span>
<span class="token keyword">int</span> <span class="token function">sem_wait</span><span class="token punctuation">(</span>sem_t <span class="token operator">*</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//对信号量解锁，调用一次对信号量的值+1</span>
<span class="token keyword">int</span> <span class="token function">sem_post</span><span class="token punctuation">(</span>sem_t <span class="token operator">*</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>（6）读写锁：<br/> <strong>读多写少</strong>时使用读写锁，提高效率。</p>
<pre><code class="prism language-cpp">有线程在读，其他线程也可读，不能写；
有线程在写，其他线程不能读，不能写；
写是独占的，优先级高。
</code></pre>
<h2><a id="4_546"></a>4.网络编程</h2>
<p>（1）网卡功能：数据的封装与解封装；链路管理；数据编码与译码。</p>
<p>（2）MAC地址：48位（6个字节）。<br/> IP地址：32位（4个字节）。</p>
<p>（3）特殊地址：</p>
<pre><code class="prism language-cpp">当前主机：<span class="token number">0.0</span><span class="token punctuation">.</span><span class="token number">0.0</span>
当前子网的广播地址：<span class="token number">255.255</span><span class="token punctuation">.</span><span class="token number">255.255</span>
回路测试：<span class="token number">127.0</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token operator">~</span><span class="token number">127.255</span><span class="token punctuation">.</span><span class="token number">255.255</span>
</code></pre>
<p>（4）子网掩码：将IP地址分为<strong>网络地址</strong>和<strong>主机地址</strong>两部分。<br/> 【注】网络号：IP与子网掩码&amp;<br/> 主机号：子网掩码取反与IP&amp;</p>
<p>子网数：首先根据第一个字节判断是哪个类：<br/> &lt;=127:A——255.0.0.0<br/> &lt;=191:B——255.255.0.0<br/> &lt;223:C——255.255.255.0<br/> 看子网掩码比默认的多几个1，就是2的几次方个子网数；<br/> 主机数：后面的0有几个，就是2的几次方主机数。</p>
<p>（5）端口：网络通信中应用程序对外的一个接口，2个字节。</p>
<pre><code class="prism language-cpp">周知端口：<span class="token number">0</span><span class="token operator">~</span><span class="token number">1023</span>
注册端口：<span class="token number">1024</span><span class="token operator">~</span><span class="token number">49151</span>
动态端口：<span class="token number">49152</span><span class="token operator">~</span><span class="token number">65535</span>
</code></pre>
<p>（6）网络模型；TCP/IP协议族；UDP、TCP、IP、以太网帧、ARP的报文头部结构。</p>
<p>（7）上层使用下层提供的服务，通过<strong>封装</strong>实现。<br/> 从下往上进行解析：<strong>分用</strong>。</p>
<p>（8）socket套接字：一套通信的接口。<br/> socket地址——结构体。</p>
<p>（9）字节序：<br/> 大端（网络字节序）：整数的<strong>高位字节</strong>在内存的<strong>低地址</strong>处。<br/> 小端：整数的<strong>高位字节</strong>在内存的<strong>高地址</strong>处。</p>
<p>（10）TCP：可靠、面向连接、字节流、传输层。<br/> 三次握手目的：为了让双方都知道可以互相通信。<br/> TCP的状态转换。</p>
<p>（11）服务端的端口复用：防止服务器重启时之前绑定的端口还未释放；程序突然退出而系统没有释放端口。</p>
<p>（12）通信并发：多进程/多线程解决。</p>
<pre><code class="prism language-cpp">一个父进程，多个子进程；
父进程负责等待，并接收客户端连接；
子进程完成通信，每接收一个客户端连接，就创建一个子进程用于通信。
</code></pre>
<p>缺点：耗费资源。</p>
<p>（13）I/O多路复用技术：使程序能<strong>同时监听多个文件描述符</strong>，提高程序性能。分为阻塞（<code>BIO</code>）和非阻塞（<code>NIO</code>）。<br/> <code>select</code>、<code>poll</code>、<code>epoll</code>。</p>
<p>具体参考这篇<a href="https://blog.csdn.net/qq_34827674/article/details/115619261?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164973070416781685359971%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=164973070416781685359971&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-115619261.142%5Ev7%5Epc_search_result_control_group,157%5Ev4%5Econtrol&amp;utm_term=IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8&amp;spm=1018.2226.3001.4187">答应我，这次搞懂 I/O 多路复用！</a></p>
<p>epoll的工作模式：LT水平触发、ET边缘触发（减少了epoll事件被重复触发的次数）。</p>
<h2><a id="5HTTP_612"></a>5.补充(阻塞/非阻塞、同步/异步、HTTP、服务器编程、有限状态机、正则、压力测试等)</h2>
<p>（1）阻塞/非阻塞、同步/异步（网络I/O）：<br/> 【注】磁盘IO（I：从磁盘读入内存；O：从内存写入磁盘）。网络IO。</p>
<p><strong>在处理 IO 的时候，阻塞和非阻塞都是同步 IO，只有使用了特殊的 API 才是异步 IO。</strong></p>
<p>一个典型的网络IO接口调用，分为两个阶段，分别是 “<strong>数据就绪</strong>” 和 “<strong>数据读写</strong>”，数据就绪阶段分为阻塞和非阻塞，表现得结果就是，<strong>阻塞当前线程或是直接返回</strong>。数据读写阶段分为同步和异步。</p>
<p>同步表示A向B请求调用一个网络IO接口时（或者调用某个业务逻辑API接口时），数据的读写都是 由请求方<strong>A自己来完成</strong>的（不管是阻塞还是非阻塞）——效率低，编程简单，消耗用户时间。<br/> 异步表示A向B请求调用一个网络IO接口时 （或者调用某个业务逻辑API接口时），向B传入请求的事件(fd)以及事件发生时通知的方式(sigio)，A就<strong>可以处理其它逻辑</strong>了，当B监听到事件处理完成后，会用事先约定好的通知方式，通知A处理结果——效率高，编程复杂，不消耗用户时间。<br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/aa011ef3dd5640ecb85e3b62c6decfc2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAd3Jkb2N0,size_20,color_FFFFFF,t_70,g_se,x_16"/><br/> （2）Unix/Linux的五种IO模型：</p>
<pre><code class="prism language-cpp"><span class="token number">1</span>、阻塞 blocking：
等待数据（中间不能做其他事）；拷贝到用户区。

<span class="token number">2</span>、非阻塞 non<span class="token operator">-</span>blocking（NIO）：
等待数据（中间能做其他事）；拷贝到用户区；
返回<span class="token operator">-</span><span class="token number">1</span>带上EAGAIN；
线程不会挂起，系统调用次数多，影响性能。

<span class="token number">3</span>、IO复用（IO multiplexing）：
一个进程检测多个IO操作；
select、poll、epoll。

<span class="token number">4</span>、信号驱动（signal<span class="token operator">-</span>driven）：
内核在第一个阶段是异步，在第二个阶段是同步。

<span class="token number">5</span>、异步：
</code></pre>
<p>===========================================================================<br/> （3）HTTP协议：</p>
<pre><code class="prism language-cpp"><span class="token number">1.</span>客户端连接到Web服务器；
<span class="token number">2.</span>发送HTTP请求；
<span class="token number">3.</span>服务器接受请求并返回HTTP响应；
<span class="token number">4.</span>释放TCP连接；
<span class="token number">5.</span>客户端浏览器解析HTML内容。
</code></pre>
<p>（4）HTTP请求报文和响应报文格式。</p>
<p>（5）HTTP请求方法：</p>
<pre><code class="prism language-cpp">GET：显示请求。
POST：提交数据。
HEAD：请求资源。
PUT：上传资源。
</code></pre>
<p>（6）HTTP状态码：</p>
<pre><code class="prism language-cpp"><span class="token number">1</span>xx：请求已被接收，正在处理
<span class="token number">2</span>xx：请求接收成功
<span class="token number">3</span>xx：重定向
<span class="token number">4</span>xx：请求错误
<span class="token number">5</span>xx：服务器错误
</code></pre>
<p>【注】200 OK； 404 Not Found；403 Forbidden； 500 Internal Server Error。</p>
<p>===========================================================================</p>
<p>（7）服务器编程的基本框架：</p>
<table><thead><tr><th>模块</th><th>功能</th></tr></thead><tbody><tr><td>I/O 处理单元</td><td>处理客户连接，读写网络数据/接收发送数据</td></tr><tr><td>逻辑单元</td><td>业务进程或线程/解析数据</td></tr><tr><td>网络存储单元</td><td>数据库、文件或缓存</td></tr><tr><td>请求队列</td><td>各单元之间的通信方式</td></tr></tbody></table>
<p>（8）两种高效的事件处理模式：<br/> <code>Reactor</code> 和 <code>Proactor</code> ，<strong>同步</strong> I/O 模型通常用于实现 <code>Reactor</code> 模式，<strong>异步</strong> I/O 模型通常用于实现 <code>Proactor</code> 模式。</p>
<p><code>Reactor</code>和<code>Proactor</code>模式的主要区别就是 <strong>真正的读取和写入操作是由谁来完成的</strong>。<br/> <code>Reactor</code>来了事件操作系统通知应用进程，让应用进程来处理； <br/> <code>Proactor</code>来了事件操作系统来处理，处理完再通知应用进程。</p>
<pre><code class="prism language-cpp">Reactor：（实现简单）
主线程（I<span class="token operator">/</span>O处理单元）只负责监听fd是否有事件发生，有就通知工作线程（逻辑单元），
将socket事件（可读可写）放入请求队列，交给工作线程处理。除此之外主线程不做其他工作。

Proactor：（性能更高）
将所有I<span class="token operator">/</span>O操作都交给主线程和内核来处理（进行读写），
工作线程仅仅负责业务逻辑（解析HTTP请求，在封装成响应数据发回去）。
</code></pre>
<p><strong>工作流程：</strong><br/> 1、<strong>Reactor：</strong>（同步I/O）<br/> 主线程往 <code>epoll</code> 内核事件表中<strong>注册</strong>（<code>epoll_ctl</code>） <code>socket</code> 上的<strong>读就绪</strong>事件；<br/> 主线程调用 <code>epoll_wait</code> <strong>等待</strong> <code>socket</code> 上有数据可读；<br/> 当 <code>socket</code> 上有数据可读时， <code>epoll_wait</code> <strong>通知主线程</strong>。主线程则将 <code>socket</code> 可读事件<strong>放入请求队列</strong>；<br/> 睡眠在请求队列上的某个<strong>工作线程被唤醒</strong>，它从 <code>socket</code> 读取数据，并处理客户请求，<br/> 然后往<code>epoll</code>内核事件表中<strong>注册</strong>（<code>epoll_ctl</code>）该 <code>socket</code> 上的<strong>写就绪</strong>事件；<br/> 当主线程调用 <code>epoll_wait</code> <strong>等待</strong> <code>socket</code> 可写；<br/> 当 <code>socket</code> 可写时，<code>epoll_wait</code> <strong>通知主线程</strong>。主线程将 <code>socket</code> 可写事件<strong>放入请求队列</strong>；<br/> 睡眠在请求队列上的某个<strong>工作线程被唤醒</strong>，它往 <code>socket</code> 上写入服务器处理客户请求的结果。</p>
<p>2、<strong>Proactor：</strong><br/> （异步I/O 模型）（同步I/O模型）<br/> 见<a href="https://blog.csdn.net/ambition_zhou/article/details/118577759">Linux高并发服务器开发</a></p>
<p>【注】服务器处理三类事件：I/O事件、信号事件、定时事件。</p>
<p>（9）线程池：<strong>由服务器预先创建的一组子线程</strong>；线程池中的线程数量应该和 CPU 数量差不多；线程池中的所有子线程都运行着相同的代码。</p>
<p>实质：<br/> 1、<strong>空间换时间</strong>，浪费服务器的硬件资源，换取运行效率。<br/> 2、池是一组资源的集合，这组资源在服务器启动之初就被完全创建好并初始化，这称为<strong>静态资源</strong>。<br/> 3、当服务器进入正式运行阶段，开始处理客户请求的时候，如果它需要相关的资源，可以直接从池中 获取，<strong>无需动态分配</strong>。<br/> 4、当服务器处理完一个客户连接后，可以把相关的资源放回池中，<strong>无需执行系统调用释放资源</strong>。</p>
<pre><code class="prism language-cpp">实现线程池的步骤：（队列）
<span class="token number">1.</span>设置一个生产者消费者队列，作为临界资源；
<span class="token number">2.</span>初始化几个线程，并让其运行起来，加锁去队列里取任务运行；
<span class="token number">3.</span>当任务队列为空时，所有线程阻塞；
<span class="token number">4.</span>当生产者队列来了一个任务后，先对队列加锁，把任务挂到队列上，然后使用条件变量去通知阻塞中的一个线程来处理。
</code></pre>
<p>===========================================================================</p>
<p>（10）有限状态机：有的应用层协议头部包含数据包<strong>类型字段</strong>，每种类型可以映射为逻辑单元的<strong>一种执行状态</strong>，服务器可以根据它来编写相应的处理逻辑。<br/> 是逻辑单元内部的一种高效编程方法。可使用枚举+switch语句==&gt;解析头还是解析体。</p>
<p>（11）正则：<br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/f7bc5e1080554097939e9db716fcf088.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAd3Jkb2N0,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<p>（12）异步日志：开启一个<strong>子线程</strong>，从队列里读，开始<strong>写日志</strong>。<br/> 同步日志：在<strong>主线程里写日志</strong>。（要等待，效率慢，浪费性能）</p>
<p>（13）<code>EPOLLONESHOT</code>事件：<br/> 即使可以使用 ET 模式，<strong>一个 socket 上的某个事件还是可能被触发多次</strong>。这在并发程序中就会引起一个问题。比如一个线程在读取完某个 socket 上的数据后开始处理这些数据，而在数据的处理过程中该socket 上又有新数据可读（ EPOLLIN 再次被触发），此时另外一个线程被唤醒来读取这些新的数据。<br/> 于是就出现了<strong>两个线程同时操作一个 socket</strong> 的局面。<strong>一个 socket 连接在任一时刻都只被一个线程处理</strong>，可以使用 epoll 的 <code>EPOLLONESHOT</code> 事件实现。</p>
<p>对于注册了 <code>EPOLLONESHOT</code> 事件的文件描述符，操作系统最多触发其上注册的一个可读、可写或者异常事件，且<strong>只触发一次</strong>，除非我们使用 <code>epoll_ctl</code> 函数<strong>重置</strong>该文件描述符上注册的 <code>EPOLLONESHOT</code> 事件。这样，当一个线程在处理某个 socket 时，其他线程是不可能有机会操作该 socket 的。<br/> 但反过来思考，注册了 <code>EPOLLONESHOT</code> 事件的 socket 一旦被某个线程处理完毕， 该线程就应该<strong>立即重置</strong>这个socket 上的 <code>EPOLLONESHOT</code> 事件，以确保这个 socket 下一次可读时，其 <code>EPOLLIN</code> 事件能被触发，进而让其他工作线程有机会继续处理这个 socket 。</p>
<p>（14）服务器的压力测试：<br/> 展示服务器的两项内容： <strong>每秒钟响应请求数</strong>和<strong>每秒钟传输数据量</strong>。<br/> 基本原理：<br/> <code>Webbench</code> 首先 fork 出多个子进程，每个子进程都循环做 web 访问测试。子进程把访问的结果通过pipe 告诉父进程，父进程做最终的结果统计。</p>
<pre><code class="prism language-cpp">webbench <span class="token operator">-</span>c <span class="token number">1000</span> <span class="token operator">-</span>t <span class="token number">30</span> http<span class="token operator">:</span><span class="token comment">//192.168.160.128:10000/index.html </span>
    参数：
        <span class="token operator">-</span>c 表示客户端数 
        <span class="token operator">-</span>t 表示时间
</code></pre>
<h1><a id="_765"></a>源码地址（学习更新中）</h1>
<p><a href="https://github.com/wrdoct/webserver">webserver</a></p>
<p>参考：</p>
<blockquote>
<p><a href="https://kikoking.blog.csdn.net/article/details/123913779">【操作系统】进程的切换与控制·到底有啥关系？</a><br/> <a href="https://blog.csdn.net/qq_39354847/article/details/120590556">[项目] Linux高并发服务器</a><br/> <a href="https://blog.csdn.net/qq_34827674/article/details/115619261?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164973070416781685359971%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=164973070416781685359971&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-115619261.142%5Ev7%5Epc_search_result_control_group,157%5Ev4%5Econtrol&amp;utm_term=IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8&amp;spm=1018.2226.3001.4187">答应我，这次搞懂 I/O 多路复用！</a><br/> <a href="https://blog.csdn.net/ambition_zhou/article/details/118577759">Linux高并发服务器开发</a></p>
</blockquote>
</div>
<link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css" rel="stylesheet"/>
<link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css" rel="stylesheet"/>
</div>