<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="markdown_views prism-atelier-sulphurpool-light" id="content_views">
<svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
<path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
</svg>
<blockquote>
<p>🐋作者简介：博主是一位.Net开发者，同时也是RPA和低代码平台的践行者。<br/> 🐬个人主页：<a href="https://blog.csdn.net/baidu_33146219?type=blog">会敲键盘的肘子</a><br/> 🐰系列专栏：<a href="https://blog.csdn.net/baidu_33146219/category_11968078.html?spm=1001.2014.3001.5482">.Net实用方法总结</a><br/> 🦀专栏简介：博主针对.Net开发和C站问答过程中遇到的问题进行总结，形成本专栏，希望可以帮助到您解决问题。<br/> 🐶座右铭：总有一天你所坚持的会反过来拥抱你。</p>
</blockquote>
<hr/>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20149cf905ca46f78ca992f76476341b.png#pic_center"/></p>
<blockquote>
<p>🌈写在前面：</p>
<p>本文主要介绍<strong>System.IO</strong>命名空间的<strong>FileStream</strong> 类，介绍其常用的方法和示例说明。</p>
</blockquote>
<hr/>
<p><strong>👉本文关键字：System.IO、FileStream类、文件流、方法示例、C#</strong></p>
<p></p>
<div class="toc">
<h3>文章目录</h3>
<ul><li><ul><li><ul><li><a href="#1_SystemIO_21">1️⃣ System.IO命名空间</a></li><li><a href="#2_FileStream_45">2️⃣ FileStream类</a></li><li><ul><li><a href="#__47">♈ 定义</a></li><li><a href="#__55">⛎ 示例</a></li><li><a href="#__147">♉ 构造函数</a></li><li><ul><li><a href="#FileStreamString_FileMode_FileAccess_FileShare_Int32_FileOptions_151">FileStream(String, FileMode, FileAccess, FileShare, Int32, FileOptions)</a></li><li><a href="#FileStreamString_FileMode_FileAccess_FileShare_Int32_Boolean_264">FileStream(String, FileMode, FileAccess, FileShare, Int32, Boolean)</a></li><li><a href="#FileStreamString_FileMode_436">FileStream(String, FileMode)</a></li></ul>
</li><li><a href="#__504">♊ 属性</a></li><li><ul><li><a href="#CanRead__506">CanRead 当在派生类中重写时，获取指示当前流是否支持读取的值</a></li><li><a href="#CanWrite__535">CanWrite 当在派生类中重写时，获取指示当前流是否支持写入功能的值</a></li><li><a href="#Length__566">Length 当在派生类中重写时，获取流长度（以字节为单位）</a></li></ul>
</li><li><a href="#__572">♌ 常用方法</a></li><li><ul><li><a href="#Close__574">Close() 关闭当前流并释放与之关联的所有资源（如套接字和文件句柄）</a></li><li><a href="#CopyToStream__582">CopyTo(Stream) 从当前流中读取字节并将其写入到另一流中</a></li><li><a href="#CopyToStream_Int32__618">CopyTo(Stream, Int32) 使用指定的缓冲区大小，从当前流中读取字节并将其写入到另一流中</a></li><li><a href="#CopyToAsyncStream__638">CopyToAsync(Stream) 从当前流中异步读取字节并将其写入到另一个流中</a></li><li><a href="#Dispose__Stream__693">Dispose() 释放由 Stream 使用的所有资源</a></li><li><a href="#ReadByte_Int32_Int32__699">Read(Byte[], Int32, Int32) 当在派生类中重写时，从当前流读取字节序列，并将此流中的位置提升读取的字节数</a></li><li><a href="#ReadAsyncByte_Int32_Int32__772">ReadAsync(Byte[], Int32, Int32) 从当前流异步读取字节序列，并将流中的位置提升读取的字节数</a></li><li><a href="#ReadByte__842">ReadByte() 从文件中读取一个字节，并将读取位置提升一个字节</a></li><li><a href="#WriteByte_Int32_Int32__900">Write(Byte[], Int32, Int32) 当在派生类中重写时，向当前流中写入字节序列，并将此流中的当前位置提升写入的字节数</a></li><li><a href="#WriteAsyncByte_Int32_Int32__930">WriteAsync(Byte[], Int32, Int32) 将字节序列异步写入当前流，并将流的当前位置提升写入的字节数</a></li><li><a href="#WriteByteByte__1000">WriteByte(Byte) 一个字节写入文件流中的当前位置</a></li><li><a href="#Flush__1060">Flush() 清除此流的缓冲区，使得所有缓冲数据都写入到文件中</a></li><li><a href="#FlushAsync__1105">FlushAsync() 异步清除此流的所有缓冲区并导致所有缓冲数据都写入基础设备中</a></li><li><a href="#LockInt64_Int64__FileStream_1117">Lock(Int64, Int64) 防止其他进程读取或写入 FileStream</a></li><li><a href="#UnlockInt64_Int64__1299">Unlock(Int64, Int64) 允许其他进程访问以前锁定的某个文件的全部或部分</a></li></ul>
</li><li><a href="#__1481">♍ 注解</a></li><li><a href="#__1493">♎ 更多方法</a></li></ul>
</li></ul>
</li></ul>
</li></ul>
</div>
<p></p>
<h3><a id="1_SystemIO_21"></a>1️⃣ System.IO命名空间</h3>
<p>.NET中的IO操作命名空间，包含允许<strong>读写文件</strong>和<strong>数据流</strong>的类型以及提供基本<strong>文件和目录支持</strong>的类型。</p>
<p>我们在.NET中的IO操作，经常需要调用一下几个类。</p>
<ul><li><strong>FileStream类</strong></li></ul>
<p>​ 文件流类，负责大文件的拷贝，读写。</p>
<ul><li><strong>Path类</strong></li></ul>
<p>​ Path类中方法，基本都是对字符串（文件名）的操作，与实际文件没多大关系。</p>
<ul><li> <p><strong>File类</strong></p> <p>File类可以进行一些对小文件拷贝、剪切操作，还能读一些文档文件。</p> </li><li> <p><strong>Dirctory类</strong></p> <p>目录操作，创建文件、删除目录，获取目录下文件名等等。</p> </li></ul>
<h3><a id="2_FileStream_45"></a>2️⃣ FileStream类</h3>
<h4><a id="__47"></a>♈ 定义</h4>
<p>为文件提供 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.stream?view=net-6.0">Stream</a>，既支持同步读写操作，也支持异步读写操作。</p>
<pre><code class="prism language-C#">public class FileStream : System.IO.Stream
</code></pre>
<h4><a id="__55"></a>⛎ 示例</h4>
<p>下面的示例演示了一些 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream?view=net-6.0">FileStream</a> 构造函数。</p>
<pre><code class="prism language-c#">using System;
using System.IO;
using System.Text;

class Test
{

    public static void Main()
    {
        string path = @"c:\temp\MyTest.txt";

        // Delete the file if it exists.
        if (File.Exists(path))
        {
            File.Delete(path);
        }

        //Create the file.
        using (FileStream fs = File.Create(path))
        {
            AddText(fs, "This is some text");
            AddText(fs, "This is some more text,");
            AddText(fs, "\r\nand this is on a new line");
            AddText(fs, "\r\n\r\nThe following is a subset of characters:\r\n");

            for (int i=1;i &lt; 120;i++)
            {
                AddText(fs, Convert.ToChar(i).ToString());
            }
        }

        //Open the stream and read it back.
        using (FileStream fs = File.OpenRead(path))
        {
            byte[] b = new byte[1024];
            UTF8Encoding temp = new UTF8Encoding(true);
            while (fs.Read(b,0,b.Length) &gt; 0)
            {
                Console.WriteLine(temp.GetString(b));
            }
        }
    }

    private static void AddText(FileStream fs, string value)
    {
        byte[] info = new UTF8Encoding(true).GetBytes(value);
        fs.Write(info, 0, info.Length);
    }
}
</code></pre>
<p>下面的示例演示如何异步写入文件。 此代码在 WPF 应用中运行，该应用具有名为 UserInput 的 TextBlock 和已挂接到名为 Button_Click 的 Click 事件处理程序的按钮。 文件路径需要更改为计算机上存在的文件。</p>
<pre><code class="prism language-c#">using System;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.IO;

namespace WpfApplication1
{
    public partial class MainWindow : Window
    {
        public MainWindow()
        {
            InitializeComponent();
        }

        private async void Button_Click(object sender, RoutedEventArgs e)
        {
            UnicodeEncoding uniencoding = new UnicodeEncoding();
            string filename = @"c:\Users\exampleuser\Documents\userinputlog.txt";

            byte[] result = uniencoding.GetBytes(UserInput.Text);

            using (FileStream SourceStream = File.Open(filename, FileMode.OpenOrCreate))
            {
                SourceStream.Seek(0, SeekOrigin.End);
                await SourceStream.WriteAsync(result, 0, result.Length);
            }
        }
    }
}
</code></pre>
<h4><a id="__147"></a>♉ 构造函数</h4>
<p>初始化 FileStream 类的新实例</p>
<h5><a id="FileStreamString_FileMode_FileAccess_FileShare_Int32_FileOptions_151"></a>FileStream(String, FileMode, FileAccess, FileShare, Int32, FileOptions)</h5>
<p>使用指定的路径、创建模式、读/写和共享权限、其他 FileStreams 可以具有的对此文件的访问权限、缓冲区大小和附加文件选项初始化 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream?view=net-6.0">FileStream</a> 类的新实例。</p>
<pre><code class="prism language-C#">public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options);
</code></pre>
<p><strong>参数</strong></p>
<blockquote>
<p><code>path</code></p>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.string?view=net-6.0">String</a></p>
<p>当前 <code>FileStream</code> 对象将封装的文件的相对路径或绝对路径。</p>
<p><code>mode</code></p>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filemode?view=net-6.0">FileMode</a></p>
<p>用于确定文件的打开或创建方式的枚举值之一。</p>
<p><code>access</code></p>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.fileaccess?view=net-6.0">FileAccess</a></p>
<p>枚举值的按位组合，这些枚举值确定 <code>FileStream</code> 对象访问文件的方式。 该常数还可以确定由 <code>FileStream</code> 对象的 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream.canread?view=net-6.0#system-io-filestream-canread">CanRead</a> 和 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream.canwrite?view=net-6.0#system-io-filestream-canwrite">CanWrite</a> 属性返回的值。 如果 <code>path</code> 指定磁盘文件，则 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream.canseek?view=net-6.0#system-io-filestream-canseek">CanSeek</a> 为 <code>true</code>。</p>
<p><code>share</code></p>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.fileshare?view=net-6.0">FileShare</a></p>
<p>枚举值的按位组合，这些枚举值确定进程共享文件的方式。</p>
<p><code>bufferSize</code></p>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.int32?view=net-6.0">Int32</a></p>
<p>一个大于零的正 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.int32?view=net-6.0">Int32</a> 值，表示缓冲区大小。 默认缓冲区大小为 4096。</p>
<p><code>options</code></p>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.fileoptions?view=net-6.0">FileOptions</a></p>
<p>枚举值的按位组合，它用于指定其他文件选项。</p>
</blockquote>
<p><strong>示例</strong></p>
<p>以下示例将数据写入文件，然后使用 对象读取 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream?view=net-6.0">FileStream</a> 数据。</p>
<pre><code class="prism language-c#">using System;
using System.IO;
using System.Text;
using System.Security.AccessControl;

namespace FileSystemExample
{
    class FileStreamExample
    {
        public static void Main()
        {
            try
            {
                // Create a file and write data to it.

                // Create an array of bytes.
                byte[] messageByte = Encoding.ASCII.GetBytes("Here is some data.");

                // Create a file using the FileStream class.
                FileStream fWrite = new FileStream("test.txt", FileMode.Create, FileAccess.ReadWrite, FileShare.None, 8, FileOptions.None);

                // Write the number of bytes to the file.
                fWrite.WriteByte((byte)messageByte.Length);

                // Write the bytes to the file.
                fWrite.Write(messageByte, 0, messageByte.Length);

                // Close the stream.
                fWrite.Close();

                // Open a file and read the number of bytes.

                FileStream fRead = new FileStream("test.txt", FileMode.Open);

                // The first byte is the string length.
                int length = (int)fRead.ReadByte();

                // Create a new byte array for the data.
                byte[] readBytes = new byte[length];

                // Read the data from the file.
                fRead.Read(readBytes, 0, readBytes.Length);

                // Close the stream.
                fRead.Close();

                // Display the data.
                Console.WriteLine(Encoding.ASCII.GetString(readBytes));

                Console.WriteLine("Done writing and reading data.");
            }
            catch (Exception e)
            {
                Console.WriteLine(e);
            }

            Console.ReadLine();
        }
    }
}
</code></pre>
<h5><a id="FileStreamString_FileMode_FileAccess_FileShare_Int32_Boolean_264"></a>FileStream(String, FileMode, FileAccess, FileShare, Int32, Boolean)</h5>
<p>使用指定的路径、创建模式、读/写和共享权限、缓冲区大小和同步或异步状态初始化 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream?view=net-6.0">FileStream</a> 类的新实例。</p>
<pre><code class="prism language-C#">public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, bool useAsync);
</code></pre>
<p><strong>参数</strong></p>
<blockquote>
<p><code>path</code></p>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.string?view=net-6.0">String</a></p>
<p>当前 <code>FileStream</code> 对象将封装的文件的相对路径或绝对路径。</p>
<p><code>mode</code></p>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filemode?view=net-6.0">FileMode</a></p>
<p>用于确定文件的打开或创建方式的枚举值之一。</p>
<p><code>access</code></p>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.fileaccess?view=net-6.0">FileAccess</a></p>
<p>枚举值的按位组合，这些枚举值确定 <code>FileStream</code> 对象访问文件的方式。 该常数还可以确定由 <code>FileStream</code> 对象的 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream.canread?view=net-6.0#system-io-filestream-canread">CanRead</a> 和 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream.canwrite?view=net-6.0#system-io-filestream-canwrite">CanWrite</a> 属性返回的值。 如果 <code>path</code> 指定磁盘文件，则 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream.canseek?view=net-6.0#system-io-filestream-canseek">CanSeek</a> 为 <code>true</code>。</p>
<p><code>share</code></p>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.fileshare?view=net-6.0">FileShare</a></p>
<p>枚举值的按位组合，这些枚举值确定进程共享文件的方式。</p>
<p><code>bufferSize</code></p>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.int32?view=net-6.0">Int32</a></p>
<p>一个大于零的正 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.int32?view=net-6.0">Int32</a> 值，表示缓冲区大小。 默认缓冲区大小为 4096。</p>
<p><code>useAsync</code></p>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.boolean?view=net-6.0">Boolean</a></p>
<p>指定使用异步 I/O 还是同步 I/O。 但是，请注意，基础操作系统可能不支持异步 I/O，因此在指定 <code>true</code> 后，根据所用平台，句柄可能同步打开。 当异步打开时，[BeginRead(Byte<a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream.beginread?view=net-6.0#system-io-filestream-beginread%28system-byte%28%29-system-int32-system-int32-system-asynccallback-system-object%29">], Int32, Int32, AsyncCallback, Object)</a> 和 [BeginWrite(Byte<a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream.beginwrite?view=net-6.0#system-io-filestream-beginwrite%28system-byte%28%29-system-int32-system-int32-system-asynccallback-system-object%29">], Int32, Int32, AsyncCallback, Object)</a> 方法在执行大量读或写时效果更好，但对于少量的读/写，这些方法速度可能要慢得多。 如果应用程序打算利用异步 I/O，将 <code>useAsync</code> 参数设置为 <code>true</code>。 正确使用异步 I/O 可以使应用程序的速度加快 10 倍，但是如果在没有为异步 I/O 重新设计应用程序的情况下使用异步 I/O，则可能使性能降低 10 倍。</p>
</blockquote>
<p><strong>示例</strong></p>
<p>下面的代码示例演示如何将数据异步写入文件，然后验证数据是否写入正确。 <code>State</code>创建 对象以将信息从主线程传递到 和 <code>EndReadCallback</code> <code>EndWriteCallback</code> 方法。</p>
<pre><code class="prism language-c#">using System;
using System.IO;
using System.Threading;

class FStream
{
    static void Main()
    {
        // Create a synchronization object that gets
        // signaled when verification is complete.
        ManualResetEvent manualEvent = new ManualResetEvent(false);

        // Create random data to write to the file.
        byte[] writeArray = new byte[100000];
        new Random().NextBytes(writeArray);

        FileStream fStream =
            new FileStream("Test#@@#.dat", FileMode.Create,
            FileAccess.ReadWrite, FileShare.None, 4096, true);

        // Check that the FileStream was opened asynchronously.
        Console.WriteLine("fStream was {0}opened asynchronously.",
            fStream.IsAsync ? "" : "not ");

        // Asynchronously write to the file.
        IAsyncResult asyncResult = fStream.BeginWrite(
            writeArray, 0, writeArray.Length,
            new AsyncCallback(EndWriteCallback),
            new State(fStream, writeArray, manualEvent));

        // Concurrently do other work and then wait
        // for the data to be written and verified.
        manualEvent.WaitOne(5000, false);
    }

    // When BeginWrite is finished writing data to the file, the
    // EndWriteCallback method is called to end the asynchronous
    // write operation and then read back and verify the data.
    static void EndWriteCallback(IAsyncResult asyncResult)
    {
        State tempState = (State)asyncResult.AsyncState;
        FileStream fStream = tempState.FStream;
        fStream.EndWrite(asyncResult);

        // Asynchronously read back the written data.
        fStream.Position = 0;
        asyncResult = fStream.BeginRead(
            tempState.ReadArray, 0 , tempState.ReadArray.Length,
            new AsyncCallback(EndReadCallback), tempState);

        // Concurrently do other work, such as
        // logging the write operation.
    }

    // When BeginRead is finished reading data from the file, the
    // EndReadCallback method is called to end the asynchronous
    // read operation and then verify the data.
    static void EndReadCallback(IAsyncResult asyncResult)
    {
        State tempState = (State)asyncResult.AsyncState;
        int readCount = tempState.FStream.EndRead(asyncResult);

        int i = 0;
        while(i &lt; readCount)
        {
            if(tempState.ReadArray[i] != tempState.WriteArray[i++])
            {
                Console.WriteLine("Error writing data.");
                tempState.FStream.Close();
                return;
            }
        }
        Console.WriteLine("The data was written to {0} and verified.",
            tempState.FStream.Name);
        tempState.FStream.Close();

        // Signal the main thread that the verification is finished.
        tempState.ManualEvent.Set();
    }

    // Maintain state information to be passed to
    // EndWriteCallback and EndReadCallback.
    class State
    {
        // fStream is used to read and write to the file.
        FileStream fStream;

        // writeArray stores data that is written to the file.
        byte[] writeArray;

        // readArray stores data that is read from the file.
        byte[] readArray;

        // manualEvent signals the main thread
        // when verification is complete.
        ManualResetEvent manualEvent;

        public State(FileStream fStream, byte[] writeArray,
            ManualResetEvent manualEvent)
        {
            this.fStream   = fStream;
            this.writeArray = writeArray;
            this.manualEvent = manualEvent;
            readArray = new byte[writeArray.Length];
        }

        public FileStream FStream
        { get{ return fStream; } }

        public byte[] WriteArray
        { get{ return writeArray; } }

        public byte[] ReadArray
        { get{ return readArray; } }

        public ManualResetEvent ManualEvent
        { get{ return manualEvent; } }
    }
}
</code></pre>
<h5><a id="FileStreamString_FileMode_436"></a>FileStream(String, FileMode)</h5>
<p>使用指定的路径和创建模式初始化 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream?view=net-6.0">FileStream</a> 类的新实例。</p>
<pre><code class="prism language-C#">public FileStream (string path, System.IO.FileMode mode);
</code></pre>
<p><strong>参数</strong></p>
<blockquote>
<p><code>path</code></p>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.string?view=net-6.0">String</a></p>
<p>当前 <code>FileStream</code> 对象将封装的文件的相对路径或绝对路径。</p>
<p><code>mode</code></p>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filemode?view=net-6.0">FileMode</a></p>
<p>用于确定文件的打开或创建方式的枚举值之一。</p>
</blockquote>
<p><strong>示例</strong></p>
<p>下面的代码示例演示了如何按字节将数据写入文件，然后验证是否已正确写入数据。</p>
<pre><code class="prism language-c#">using System;
using System.IO;

class FStream
{
    static void Main()
    {
        const string fileName = "Test#@@#.dat";

        // Create random data to write to the file.
        byte[] dataArray = new byte[100000];
        new Random().NextBytes(dataArray);

        using(FileStream
            fileStream = new FileStream(fileName, FileMode.Create))
        {
            // Write the data to the file, byte by byte.
            for(int i = 0; i &lt; dataArray.Length; i++)
            {
                fileStream.WriteByte(dataArray[i]);
            }

            // Set the stream position to the beginning of the file.
            fileStream.Seek(0, SeekOrigin.Begin);

            // Read and verify the data.
            for(int i = 0; i &lt; fileStream.Length; i++)
            {
                if(dataArray[i] != fileStream.ReadByte())
                {
                    Console.WriteLine("Error writing data.");
                    return;
                }
            }
            Console.WriteLine("The data was written to {0} " +
                "and verified.", fileStream.Name);
        }
    }
}
</code></pre>
<h4><a id="__504"></a>♊ 属性</h4>
<h5><a id="CanRead__506"></a>CanRead 当在派生类中重写时，获取指示当前流是否支持读取的值</h5>
<pre><code class="prism language-C#">public abstract bool CanRead { get; }
</code></pre>
<p><strong>示例</strong></p>
<pre><code class="prism language-c#">using System;
using System.IO;

class TestRW
{
    public static void Main(String[] args)
    {
        FileStream fs = new FileStream("MyFile.txt", FileMode.OpenOrCreate, FileAccess.Read);
        if (fs.CanRead &amp;&amp; fs.CanWrite)
        {
            Console.WriteLine("MyFile.txt can be both written to and read from.");
        }
        else if (fs.CanRead)
        {
            Console.WriteLine("MyFile.txt is not writable.");
        }
    }
}
</code></pre>
<h5><a id="CanWrite__535"></a>CanWrite 当在派生类中重写时，获取指示当前流是否支持写入功能的值</h5>
<pre><code class="prism language-C#">public abstract bool CanWrite { get; }
</code></pre>
<p><strong>示例</strong></p>
<pre><code class="prism language-c#">using System;
using System.IO;

class TestRW
{
  public static void Main(String[] args)
  {
    FileStream fs = new FileStream("MyFile.txt", FileMode.OpenOrCreate,
       FileAccess.Write);
    if (fs.CanRead &amp;&amp; fs.CanWrite) {
        Console.WriteLine("MyFile.txt can be both written to and read from.");
    }
    else if (fs.CanWrite) {
        Console.WriteLine("MyFile.txt is writable.");
    }
  }
}
//This code outputs "MyFile.txt is writable."
//To get the output message "MyFile.txt can be both written to and read from.",
//change the FileAccess parameter to ReadWrite in the FileStream constructor.
</code></pre>
<h5><a id="Length__566"></a>Length 当在派生类中重写时，获取流长度（以字节为单位）</h5>
<pre><code class="prism language-C#">public abstract long Length { get; }
</code></pre>
<h4><a id="__572"></a>♌ 常用方法</h4>
<h5><a id="Close__574"></a>Close() 关闭当前流并释放与之关联的所有资源（如套接字和文件句柄）</h5>
<pre><code class="prism language-C#">public virtual void Close ();
</code></pre>
<blockquote>
<p>注意：此方法调用 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.stream.dispose?view=net-6.0">Dispose</a> ，指定 <code>true</code> 以释放所有资源。 不需要专门调用 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.stream.close?view=net-6.0">Close</a> 方法。 请确保 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.stream?view=net-6.0">Stream</a> 已正确释放每个对象。 可以 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.stream?view=net-6.0">Stream</a> <code>using</code> <code>Using</code> 在 Visual Basic) 中 (或块中声明对象，以确保释放流及其所有资源，或者可以显式调用 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.stream.dispose?view=net-6.0">Dispose</a> 方法。</p>
</blockquote>
<h5><a id="CopyToStream__582"></a>CopyTo(Stream) 从当前流中读取字节并将其写入到另一流中</h5>
<pre><code class="prism language-C#">public void CopyTo (System.IO.Stream destination);
</code></pre>
<p><strong>参数</strong></p>
<blockquote>
<p><code>destination</code></p>
<p><strong>Stream</strong></p>
<p>当前流的内容将复制到的流。</p>
</blockquote>
<p><strong>示例</strong></p>
<p>下面的示例将的内容复制 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream?view=net-6.0">FileStream</a> 到 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.memorystream?view=net-6.0">MemoryStream</a> 中。</p>
<pre><code class="prism language-C#">// Create the streams.
MemoryStream destination = new MemoryStream();

using (FileStream source = File.Open(@"c:\temp\data.dat",
    FileMode.Open))
{

    Console.WriteLine("Source length: {0}", source.Length.ToString());

    // Copy source to destination.
    source.CopyTo(destination);
}

Console.WriteLine("Destination length: {0}", destination.Length.ToString());
</code></pre>
<h5><a id="CopyToStream_Int32__618"></a>CopyTo(Stream, Int32) 使用指定的缓冲区大小，从当前流中读取字节并将其写入到另一流中</h5>
<pre><code class="prism language-C#">public virtual void CopyTo (System.IO.Stream destination, int bufferSize);
</code></pre>
<p><strong>参数</strong></p>
<blockquote>
<p><code>destination</code></p>
<p><strong>Stream</strong></p>
<p>当前流的内容将复制到的流。</p>
<p><code>bufferSize</code></p>
<p><strong>Int</strong></p>
<p>缓冲区的大小。 此值必须大于零。 默认大小为 81920。</p>
</blockquote>
<h5><a id="CopyToAsyncStream__638"></a>CopyToAsync(Stream) 从当前流中异步读取字节并将其写入到另一个流中</h5>
<pre><code class="prism language-C#">public System.Threading.Tasks.Task CopyToAsync (System.IO.Stream destination);
</code></pre>
<p><strong>参数</strong></p>
<blockquote>
<p><code>destination</code></p>
<p><strong>Stream</strong></p>
<p>当前流的内容将复制到的流。</p>
</blockquote>
<p><strong>示例</strong></p>
<p>下面的示例演示如何使用两个 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream?view=net-6.0">FileStream</a> 对象将文件从一个目录异步复制到另一个目录。 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream?view=net-6.0">FileStream</a> 类是从 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.stream?view=net-6.0">Stream</a> 类派生的。 请注意， <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.web.ui.webcontrols.button.click?view=net-6.0">Click</a> 控件的事件处理程序 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.windows.controls.button?view=net-6.0">Button</a> 使用修饰符标记， <code>async</code> 因为它调用异步方法</p>
<pre><code class="prism language-C#">using System;
using System.Threading.Tasks;
using System.Windows;
using System.IO;

namespace WpfApplication
{
    public partial class MainWindow : Window
    {
        public MainWindow()
        {
            InitializeComponent();
        }

        private async void Button_Click(object sender, RoutedEventArgs e)
        {
            string StartDirectory = @"c:\Users\exampleuser\start";
            string EndDirectory = @"c:\Users\exampleuser\end";

            foreach (string filename in Directory.EnumerateFiles(StartDirectory))
            {
                using (FileStream SourceStream = File.Open(filename, FileMode.Open))
                {
                    using (FileStream DestinationStream = File.Create(EndDirectory + filename.Substring(filename.LastIndexOf('\\'))))
                    {
                        await SourceStream.CopyToAsync(DestinationStream);
                    }
                }
            }
        }
    }
}
</code></pre>
<blockquote>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.stream.copytoasync?view=net-6.0">CopyToAsync</a>方法使你可以在不阻塞主线程的情况下执行占用大量资源的 i/o 操作。</p>
</blockquote>
<h5><a id="Dispose__Stream__693"></a>Dispose() 释放由 Stream 使用的所有资源</h5>
<pre><code class="prism language-C#">public void Dispose ();
</code></pre>
<h5><a id="ReadByte_Int32_Int32__699"></a>Read(Byte[], Int32, Int32) 当在派生类中重写时，从当前流读取字节序列，并将此流中的位置提升读取的字节数</h5>
<pre><code class="prism language-C#">public abstract int Read (byte[] buffer, int offset, int count);
</code></pre>
<p><strong>参数</strong></p>
<blockquote>
<p><code>buffer</code></p>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.byte?view=net-6.0">Byte</a>[]</p>
<p>字节数组。 当此方法返回时，此缓冲区包含指定的字符数组，此数组中 <code>offset</code> 和 (<code>offset</code> + <code>count</code> - 1) 之间的值被从当前源中读取的字节所替换。</p>
<p><code>offset</code></p>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.int32?view=net-6.0">Int32</a></p>
<p><code>buffer</code> 中的从零开始的字节偏移量，从此处开始存储从当前流中读取的数据。</p>
<p><code>count</code></p>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.int32?view=net-6.0">Int32</a></p>
<p>要从当前流中最多读取的字节数。</p>
</blockquote>
<p><strong>返回</strong></p>
<blockquote>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.int32?view=net-6.0">Int32</a></p>
<p>读入缓冲区中的总字节数。 如果很多字节当前不可用，则总字节数可能小于请求的字节数；如果已到达流结尾，则为零 (0)。</p>
</blockquote>
<p><strong>示例</strong></p>
<p>下面的示例演示如何使用 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.stream.read?view=net-6.0">Read</a> 读取数据块。</p>
<pre><code class="prism language-C#">using System;
using System.IO;

public class Block
{
    public static void Main()
    {
        Stream s = new MemoryStream();
        for (int i = 0; i &lt; 122; i++)
        {
            s.WriteByte((byte)i);
        }
        s.Position = 0;

        // Now read s into a byte buffer with a little padding.
        byte[] bytes = new byte[s.Length + 10];
        int numBytesToRead = (int)s.Length;
        int numBytesRead = 0;
        do
        {
            // Read may return anything from 0 to 10.
            int n = s.Read(bytes, numBytesRead, 10);
            numBytesRead += n;
            numBytesToRead -= n;
        } while (numBytesToRead &gt; 0);
        s.Close();

        Console.WriteLine("number of bytes read: {0:d}", numBytesRead);
    }
}
</code></pre>
<blockquote>
<p>使用 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.stream.canread?view=net-6.0">CanRead</a> 属性确定当前实例是否支持读取。 使用 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.stream.readasync?view=net-6.0">ReadAsync</a> 方法从当前流异步读取。</p>
<p>此方法的实现从当前流中读取最大字节 <code>count</code> 数，并存储从 <code>buffer</code> 开始的字节 <code>offset</code> 。 流中的当前位置按读取的字节数进行高级;但是，如果发生异常，则流中的当前位置保持不变。 实现返回读取的字节数。 在没有任何数据可用时，实现将一直阻止，直到至少可以读取一个字节的数据。 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.stream.read?view=net-6.0">Read</a> 仅在流中没有更多数据且预期没有更多数据（例如关闭套接字或文件结尾） (返回 0) 。 即使尚未到达流的末尾，实现也能够返回比请求的更少的字节。</p>
</blockquote>
<h5><a id="ReadAsyncByte_Int32_Int32__772"></a>ReadAsync(Byte[], Int32, Int32) 从当前流异步读取字节序列，并将流中的位置提升读取的字节数</h5>
<pre><code class="prism language-C#">public System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int count);
</code></pre>
<p><strong>参数</strong></p>
<blockquote>
<p><code>buffer</code></p>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.byte?view=net-6.0">Byte</a>[]</p>
<p>要写入数据的缓冲区。</p>
<p><code>offset</code></p>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.int32?view=net-6.0">Int32</a></p>
<p><code>buffer</code> 中的字节偏移量，从该偏移量开始写入从流中读取的数据。</p>
<p><code>count</code></p>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.int32?view=net-6.0">Int32</a></p>
<p>最多读取的字节数。</p>
</blockquote>
<p><strong>返回</strong></p>
<blockquote>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task-1?view=net-6.0">Task</a>&lt;<a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.int32?view=net-6.0">Int32</a>&gt;</p>
<p>表示异步读取操作的任务。 <code>TResult</code> 参数的值包含读入缓冲区的总字节数。 如果当前可用字节数少于所请求的字节数，则该结果值可小于所请求的字节数；如果已到达流结尾时，则为 0（零）。</p>
</blockquote>
<p><strong>示例</strong></p>
<p>下面的示例演示如何以异步方式从文件读取。 该示例使用 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream?view=net-6.0">FileStream</a> 类，该类派生自 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.stream?view=net-6.0">Stream</a> 类。</p>
<pre><code class="prism language-C#">using System;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.IO;

namespace WpfApplication1
{
    public partial class MainWindow : Window
    {
        public MainWindow()
        {
            InitializeComponent();
        }

        private async void Button_Click(object sender, RoutedEventArgs e)
        {
            string filename = @"c:\Temp\userinputlog.txt";
            byte[] result;

            using (FileStream SourceStream = File.Open(filename, FileMode.Open))
            {
                result = new byte[SourceStream.Length];
                await SourceStream.ReadAsync(result, 0, (int)SourceStream.Length);
            }

            UserInput.Text = System.Text.Encoding.ASCII.GetString(result);
        }
    }
}
</code></pre>
<h5><a id="ReadByte__842"></a>ReadByte() 从文件中读取一个字节，并将读取位置提升一个字节</h5>
<pre><code class="prism language-C#">public override int ReadByte ();
</code></pre>
<p><strong>返回</strong></p>
<blockquote>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.int32?view=net-6.0">Int32</a></p>
<p>强制转换为 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.int32?view=net-6.0">Int32</a> 的字节；或者如果已到达流的末尾，则为 -1。</p>
</blockquote>
<p><strong>示例</strong></p>
<p>下面的代码示例演示了如何按字节将数据写入文件，然后验证是否已正确写入数据。</p>
<pre><code class="prism language-C#">using System;
using System.IO;

class FStream
{
    static void Main()
    {
        const string fileName = "Test#@@#.dat";

        // Create random data to write to the file.
        byte[] dataArray = new byte[100000];
        new Random().NextBytes(dataArray);

        using(FileStream
            fileStream = new FileStream(fileName, FileMode.Create))
        {
            // Write the data to the file, byte by byte.
            for(int i = 0; i &lt; dataArray.Length; i++)
            {
                fileStream.WriteByte(dataArray[i]);
            }

            // Set the stream position to the beginning of the file.
            fileStream.Seek(0, SeekOrigin.Begin);

            // Read and verify the data.
            for(int i = 0; i &lt; fileStream.Length; i++)
            {
                if(dataArray[i] != fileStream.ReadByte())
                {
                    Console.WriteLine("Error writing data.");
                    return;
                }
            }
            Console.WriteLine("The data was written to {0} " +
                "and verified.", fileStream.Name);
        }
    }
}
</code></pre>
<h5><a id="WriteByte_Int32_Int32__900"></a>Write(Byte[], Int32, Int32) 当在派生类中重写时，向当前流中写入字节序列，并将此流中的当前位置提升写入的字节数</h5>
<pre><code class="prism language-C#">public abstract void Write (byte[] buffer, int offset, int count);
</code></pre>
<p><strong>参数</strong></p>
<blockquote>
<p><code>buffer</code></p>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.byte?view=net-6.0">Byte</a>[]</p>
<p>字节数组。 此方法将 <code>count</code> 个字节从 <code>buffer</code> 复制到当前流。</p>
<p><code>offset</code></p>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.int32?view=net-6.0">Int32</a></p>
<p><code>buffer</code> 中的从零开始的字节偏移量，从此处开始将字节复制到当前流。</p>
<p><code>count</code></p>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.int32?view=net-6.0">Int32</a></p>
<p>要写入当前流的字节数。</p>
</blockquote>
<blockquote>
<p>使用 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.stream.canwrite?view=net-6.0">CanWrite</a> 属性确定当前实例是否支持写入。 使用 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.stream.writeasync?view=net-6.0">WriteAsync</a> 方法异步写入当前流。</p>
<p>如果写入操作成功，则流中的位置将按写入的字节数前进。 如果发生异常，则流中的位置保持不变。</p>
</blockquote>
<h5><a id="WriteAsyncByte_Int32_Int32__930"></a>WriteAsync(Byte[], Int32, Int32) 将字节序列异步写入当前流，并将流的当前位置提升写入的字节数</h5>
<pre><code class="prism language-C#">public System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count);
</code></pre>
<p><strong>参数</strong></p>
<blockquote>
<p><code>buffer</code></p>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.byte?view=net-6.0">Byte</a>[]</p>
<p>从中写入数据的缓冲区。</p>
<p><code>offset</code></p>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.int32?view=net-6.0">Int32</a></p>
<p><code>buffer</code> 中的从零开始的字节偏移量，从此处开始将字节复制到该流。</p>
<p><code>count</code></p>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.int32?view=net-6.0">Int32</a></p>
<p>最多写入的字节数。</p>
</blockquote>
<p><strong>返回</strong></p>
<blockquote>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task?view=net-6.0">Task</a></p>
<p>表示异步写入操作的任务。</p>
</blockquote>
<p><strong>示例</strong></p>
<p>下面的示例演示如何异步写入文件。 该示例使用 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream?view=net-6.0">FileStream</a> 类，该类派生自 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.stream?view=net-6.0">Stream</a> 类。</p>
<pre><code class="prism language-C#">using System;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.IO;

namespace WpfApplication1
{
    public partial class MainWindow : Window
    {
        public MainWindow()
        {
            InitializeComponent();
        }

        private async void Button_Click(object sender, RoutedEventArgs e)
        {
            UnicodeEncoding uniencoding = new UnicodeEncoding();
            string filename = @"c:\Users\exampleuser\Documents\userinputlog.txt";

            byte[] result = uniencoding.GetBytes(UserInput.Text);

            using (FileStream SourceStream = File.Open(filename, FileMode.OpenOrCreate))
            {
                SourceStream.Seek(0, SeekOrigin.End);
                await SourceStream.WriteAsync(result, 0, result.Length);
            }
        }
    }
}
</code></pre>
<h5><a id="WriteByteByte__1000"></a>WriteByte(Byte) 一个字节写入文件流中的当前位置</h5>
<pre><code class="prism language-C#">public override void WriteByte (byte value);
</code></pre>
<p><strong>参数</strong></p>
<blockquote>
<p><code>value</code></p>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.byte?view=net-6.0">Byte</a></p>
<p>要写入流的字节。</p>
</blockquote>
<p><strong>示例</strong></p>
<p>下面的代码示例演示如何将数据以字节字节形式写入文件，然后验证数据是否写入正确。</p>
<pre><code class="prism language-C#">using System;
using System.IO;

class FStream
{
    static void Main()
    {
        const string fileName = "Test#@@#.dat";

        // Create random data to write to the file.
        byte[] dataArray = new byte[100000];
        new Random().NextBytes(dataArray);

        using(FileStream
            fileStream = new FileStream(fileName, FileMode.Create))
        {
            // Write the data to the file, byte by byte.
            for(int i = 0; i &lt; dataArray.Length; i++)
            {
                fileStream.WriteByte(dataArray[i]);
            }

            // Set the stream position to the beginning of the file.
            fileStream.Seek(0, SeekOrigin.Begin);

            // Read and verify the data.
            for(int i = 0; i &lt; fileStream.Length; i++)
            {
                if(dataArray[i] != fileStream.ReadByte())
                {
                    Console.WriteLine("Error writing data.");
                    return;
                }
            }
            Console.WriteLine("The data was written to {0} " +
                "and verified.", fileStream.Name);
        }
    }
}
</code></pre>
<h5><a id="Flush__1060"></a>Flush() 清除此流的缓冲区，使得所有缓冲数据都写入到文件中</h5>
<pre><code class="prism language-C#">public override void Flush ();
</code></pre>
<p><strong>示例</strong></p>
<p>此代码示例是为 方法提供的较大示例的 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream.lock?view=net-6.0">Lock</a> 一部分。</p>
<pre><code class="prism language-C#">// Update the file.
case 'W':
    try
    {
        fileStream.Seek(textLength,
            SeekOrigin.Begin);
        fileStream.Read(
            readText, textLength - 1, byteCount);
        tempString = new String(
            uniEncoding.GetChars(
            readText, textLength - 1, byteCount));
        recordNumber = int.Parse(tempString) + 1;
        fileStream.Seek(
            textLength, SeekOrigin.Begin);
        fileStream.Write(uniEncoding.GetBytes(
            recordNumber.ToString()),
            0, byteCount);
        fileStream.Flush();
        Console.WriteLine(
            "Record has been updated.");
    }
</code></pre>
<blockquote>
<p>此方法重写 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.stream.flush?view=net-6.0">Stream.Flush</a>。</p>
<p>调用 方法 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream.flush?view=net-6.0">FileStream.Flush</a> 时，也会刷新操作系统 I/O 缓冲区。</p>
<p>除非显式调用或释放 对象，否则不会刷新 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream.flush?view=net-6.0">Flush</a> 流的编码器。 设置为 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.streamwriter.autoflush?view=net-6.0">StreamWriter.AutoFlush</a> <code>true</code> 表示数据从缓冲区刷新到流，但不刷新编码器状态。 这允许编码器保留其状态 (部分字符) 以便它可以正确编码下一个字符块。 这种情况会影响 UTF8 和 UTF7，其中某些字符只能在编码器收到相邻字符后进行编码。</p>
<p>由于缓冲区可用于读取或写入， <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream.flush?view=net-6.0#system-io-filestream-flush">Flush()</a> 因此 执行以下两个函数：</p>
<ul><li>以前写入缓冲区的任何数据都复制到文件，并且缓冲区被清除，但编码器状态除外。</li><li>如果 为 且数据以前从文件复制到缓冲区进行读取，则文件中当前位置将减少缓冲区中未读 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.bufferedstream.canseek?view=net-6.0">BufferedStream.CanSeek</a> <code>true</code> 字节数。 然后清除缓冲区。</li></ul>
</blockquote>
<h5><a id="FlushAsync__1105"></a>FlushAsync() 异步清除此流的所有缓冲区并导致所有缓冲数据都写入基础设备中</h5>
<pre><code class="prism language-C#">public System.Threading.Tasks.Task FlushAsync ();
</code></pre>
<p><strong>返回</strong></p>
<blockquote>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task?view=net-6.0">Task</a></p>
<p>表示异步刷新操作的任务。</p>
</blockquote>
<h5><a id="LockInt64_Int64__FileStream_1117"></a>Lock(Int64, Int64) 防止其他进程读取或写入 FileStream</h5>
<pre><code class="prism language-C#">[System.Runtime.Versioning.UnsupportedOSPlatform("ios")]
[System.Runtime.Versioning.UnsupportedOSPlatform("macos")]
[System.Runtime.Versioning.UnsupportedOSPlatform("tvos")]
public virtual void Lock (long position, long length);
</code></pre>
<p><strong>参数</strong></p>
<blockquote>
<p><code>position</code></p>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.int64?view=net-6.0">Int64</a></p>
<p>要锁定的范围的起始处。 此参数的值必须大于或等于零 (0)。</p>
<p><code>length</code></p>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.int64?view=net-6.0">Int64</a></p>
<p>要锁定的范围。</p>
</blockquote>
<p><strong>示例</strong></p>
<p>下面的代码示例演示如何锁定文件的一部分，以便另一个进程无法访问该文件的该部分，即使它具有对文件的读/写访问权限。 在不同的命令窗口中同时运行程序，并使用不同的控制台输入选项进行调查。</p>
<pre><code class="prism language-C#">using System;
using System.IO;
using System.Text;

class FStreamLock
{
    static void Main()
    {
        UnicodeEncoding uniEncoding = new UnicodeEncoding();
        string lastRecordText =
            "The last processed record number was: ";
        int textLength = uniEncoding.GetByteCount(lastRecordText);
        int recordNumber = 13;
        int byteCount =
            uniEncoding.GetByteCount(recordNumber.ToString());
        string tempString;

        using(FileStream fileStream = new FileStream(
            "Test#@@#.dat", FileMode.OpenOrCreate,
            FileAccess.ReadWrite, FileShare.ReadWrite))
        {
            // Write the original file data.
            if(fileStream.Length == 0)
            {
                tempString =
                    lastRecordText + recordNumber.ToString();
                fileStream.Write(uniEncoding.GetBytes(tempString),
                    0, uniEncoding.GetByteCount(tempString));
            }

            // Allow the user to choose the operation.
            char consoleInput = 'R';
            byte[] readText = new byte[fileStream.Length];
            while(consoleInput != 'X')
            {
                Console.Write(
                    "\nEnter 'R' to read, 'W' to write, 'L' to " +
                    "lock, 'U' to unlock, anything else to exit: ");

                if((tempString = Console.ReadLine()).Length == 0)
                {
                    break;
                }
                consoleInput = char.ToUpper(tempString[0]);
                switch(consoleInput)
                {
                    // Read data from the file and
                    // write it to the console.
                    case 'R':
                        try
                        {
                            fileStream.Seek(0, SeekOrigin.Begin);
                            fileStream.Read(
                                readText, 0, (int)fileStream.Length);
                            tempString = new String(
                                uniEncoding.GetChars(
                                readText, 0, readText.Length));
                            Console.WriteLine(tempString);
                            recordNumber = int.Parse(
                                tempString.Substring(
                                tempString.IndexOf(':') + 2));
                        }

                        // Catch the IOException generated if the
                        // specified part of the file is locked.
                        catch(IOException e)
                        {
                            Console.WriteLine("{0}: The read " +
                                "operation could not be performed " +
                                "because the specified part of the " +
                                "file is locked.",
                                e.GetType().Name);
                        }
                        break;

                    // Update the file.
                    case 'W':
                        try
                        {
                            fileStream.Seek(textLength,
                                SeekOrigin.Begin);
                            fileStream.Read(
                                readText, textLength - 1, byteCount);
                            tempString = new String(
                                uniEncoding.GetChars(
                                readText, textLength - 1, byteCount));
                            recordNumber = int.Parse(tempString) + 1;
                            fileStream.Seek(
                                textLength, SeekOrigin.Begin);
                            fileStream.Write(uniEncoding.GetBytes(
                                recordNumber.ToString()),
                                0, byteCount);
                            fileStream.Flush();
                            Console.WriteLine(
                                "Record has been updated.");
                        }

                        // Catch the IOException generated if the
                        // specified part of the file is locked.
                        catch(IOException e)
                        {
                            Console.WriteLine(
                                "{0}: The write operation could not " +
                                "be performed because the specified " +
                                "part of the file is locked.",
                                e.GetType().Name);
                        }
                        break;

                    // Lock the specified part of the file.
                    case 'L':
                        try
                        {
                            fileStream.Lock(textLength - 1, byteCount);
                            Console.WriteLine("The specified part " +
                                "of file has been locked.");
                        }
                        catch(IOException e)
                        {
                            Console.WriteLine(
                                "{0}: The specified part of file is" +
                                " already locked.", e.GetType().Name);
                        }
                        break;

                    // Unlock the specified part of the file.
                    case 'U':
                        try
                        {
                            fileStream.Unlock(
                                textLength - 1, byteCount);
                            Console.WriteLine("The specified part " +
                                "of file has been unlocked.");
                        }
                        catch(IOException e)
                        {
                            Console.WriteLine(
                                "{0}: The specified part of file is " +
                                "not locked by the current process.",
                                e.GetType().Name);
                        }
                        break;

                    // Exit the program.
                    default:
                        consoleInput = 'X';
                        break;
                }
            }
        }
    }
}
</code></pre>
<h5><a id="UnlockInt64_Int64__1299"></a>Unlock(Int64, Int64) 允许其他进程访问以前锁定的某个文件的全部或部分</h5>
<pre><code class="prism language-C#">[System.Runtime.Versioning.UnsupportedOSPlatform("ios")]
[System.Runtime.Versioning.UnsupportedOSPlatform("macos")]
[System.Runtime.Versioning.UnsupportedOSPlatform("tvos")]
public virtual void Unlock (long position, long length);
</code></pre>
<p><strong>参数</strong></p>
<blockquote>
<p><code>position</code></p>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.int64?view=net-6.0">Int64</a></p>
<p>要取消锁定的范围的开始处。</p>
<p><code>length</code></p>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.int64?view=net-6.0">Int64</a></p>
<p>要取消锁定的范围。</p>
</blockquote>
<p><strong>示例</strong></p>
<p>下面的代码示例演示如何锁定部分文件，以便其他进程即使对文件具有读/写访问权限也无法访问该文件的该部分，然后对该文件的指定部分解除锁定。 在不同的命令窗口中同时运行程序，并使用不同的控制台输入选项进行调查。</p>
<pre><code class="prism language-C#">using System;
using System.IO;
using System.Text;

class FStreamLock
{
    static void Main()
    {
        UnicodeEncoding uniEncoding = new UnicodeEncoding();
        string lastRecordText =
            "The last processed record number was: ";
        int textLength = uniEncoding.GetByteCount(lastRecordText);
        int recordNumber = 13;
        int byteCount =
            uniEncoding.GetByteCount(recordNumber.ToString());
        string tempString;

        using(FileStream fileStream = new FileStream(
            "Test#@@#.dat", FileMode.OpenOrCreate,
            FileAccess.ReadWrite, FileShare.ReadWrite))
        {
            // Write the original file data.
            if(fileStream.Length == 0)
            {
                tempString =
                    lastRecordText + recordNumber.ToString();
                fileStream.Write(uniEncoding.GetBytes(tempString),
                    0, uniEncoding.GetByteCount(tempString));
            }

            // Allow the user to choose the operation.
            char consoleInput = 'R';
            byte[] readText = new byte[fileStream.Length];
            while(consoleInput != 'X')
            {
                Console.Write(
                    "\nEnter 'R' to read, 'W' to write, 'L' to " +
                    "lock, 'U' to unlock, anything else to exit: ");

                if((tempString = Console.ReadLine()).Length == 0)
                {
                    break;
                }
                consoleInput = char.ToUpper(tempString[0]);
                switch(consoleInput)
                {
                    // Read data from the file and
                    // write it to the console.
                    case 'R':
                        try
                        {
                            fileStream.Seek(0, SeekOrigin.Begin);
                            fileStream.Read(
                                readText, 0, (int)fileStream.Length);
                            tempString = new String(
                                uniEncoding.GetChars(
                                readText, 0, readText.Length));
                            Console.WriteLine(tempString);
                            recordNumber = int.Parse(
                                tempString.Substring(
                                tempString.IndexOf(':') + 2));
                        }

                        // Catch the IOException generated if the
                        // specified part of the file is locked.
                        catch(IOException e)
                        {
                            Console.WriteLine("{0}: The read " +
                                "operation could not be performed " +
                                "because the specified part of the " +
                                "file is locked.",
                                e.GetType().Name);
                        }
                        break;

                    // Update the file.
                    case 'W':
                        try
                        {
                            fileStream.Seek(textLength,
                                SeekOrigin.Begin);
                            fileStream.Read(
                                readText, textLength - 1, byteCount);
                            tempString = new String(
                                uniEncoding.GetChars(
                                readText, textLength - 1, byteCount));
                            recordNumber = int.Parse(tempString) + 1;
                            fileStream.Seek(
                                textLength, SeekOrigin.Begin);
                            fileStream.Write(uniEncoding.GetBytes(
                                recordNumber.ToString()),
                                0, byteCount);
                            fileStream.Flush();
                            Console.WriteLine(
                                "Record has been updated.");
                        }

                        // Catch the IOException generated if the
                        // specified part of the file is locked.
                        catch(IOException e)
                        {
                            Console.WriteLine(
                                "{0}: The write operation could not " +
                                "be performed because the specified " +
                                "part of the file is locked.",
                                e.GetType().Name);
                        }
                        break;

                    // Lock the specified part of the file.
                    case 'L':
                        try
                        {
                            fileStream.Lock(textLength - 1, byteCount);
                            Console.WriteLine("The specified part " +
                                "of file has been locked.");
                        }
                        catch(IOException e)
                        {
                            Console.WriteLine(
                                "{0}: The specified part of file is" +
                                " already locked.", e.GetType().Name);
                        }
                        break;

                    // Unlock the specified part of the file.
                    case 'U':
                        try
                        {
                            fileStream.Unlock(
                                textLength - 1, byteCount);
                            Console.WriteLine("The specified part " +
                                "of file has been unlocked.");
                        }
                        catch(IOException e)
                        {
                            Console.WriteLine(
                                "{0}: The specified part of file is " +
                                "not locked by the current process.",
                                e.GetType().Name);
                        }
                        break;

                    // Exit the program.
                    default:
                        consoleInput = 'X';
                        break;
                }
            }
        }
    }
}
</code></pre>
<h4><a id="__1481"></a>♍ 注解</h4>
<p>使用 类可以读取、写入、打开和关闭文件系统上的文件，以及操作其他与文件相关的操作系统句柄，包括管道、标准输入和 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream?view=net-6.0">FileStream</a> 标准输出。 可以使用 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream.read?view=net-6.0">Read</a> <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream.write?view=net-6.0">Write</a> 、、 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.stream.copyto?view=net-6.0">CopyTo</a> 和 方法来执行同步操作，或使用 、、 和 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream.flush?view=net-6.0">Flush</a> <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream.readasync?view=net-6.0">ReadAsync</a> <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream.writeasync?view=net-6.0">WriteAsync</a> <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.stream.copytoasync?view=net-6.0">CopyToAsync</a> <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream.flushasync?view=net-6.0">FlushAsync</a> 方法来执行异步操作。</p>
<blockquote>
<p>注意：</p>
<p>此类型实现 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.idisposable?view=net-6.0">IDisposable</a> 接口。 在使用完类型后，您应直接或间接释放类型。 若要直接释放类型，请在 <code>try</code>/<code>catch</code> 块中调用其 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.idisposable.dispose?view=net-6.0">Dispose</a> 方法。 若要间接释放类型，请使用 <code>using</code>（在 C# 中）或 <code>Using</code>（在 Visual Basic 中）等语言构造。 有关详细信息，请参阅 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.idisposable?view=net-6.0">IDisposable</a> 接口主题中的“使用实现 IDisposable 的对象”一节。</p>
</blockquote>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream.isasync?view=net-6.0">IsAsync</a>属性检测文件句柄是否已异步打开。 使用具有 、 或 参数的构造函数创建 类的实例时，请 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream?view=net-6.0">FileStream</a> <code>isAsync</code> <code>useAsync</code> 指定 <code>options</code> 此值。 当 属性为 <code>true</code> 时，流利用重叠的 I/O 以异步方式执行文件操作。 但是， <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream.isasync?view=net-6.0">IsAsync</a> 属性不一定调用 <code>true</code> <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream.readasync?view=net-6.0">ReadAsync</a> 、 或 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream.writeasync?view=net-6.0">WriteAsync</a> <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.stream.copytoasync?view=net-6.0">CopyToAsync</a> 方法。 当 属性为 并且调用异步读取和写入操作时，UI 线程仍未被阻止，但实际 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream.isasync?view=net-6.0">IsAsync</a> <code>false</code> I/O 操作是同步执行的。</p>
<h4><a id="__1493"></a>♎ 更多方法</h4>
<blockquote>
<p>更多方法请查阅官方文档<a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.filestream?view=net-6.0">FileStream类</a>。</p>
</blockquote>
<hr/>
<blockquote>
<p>⭐写在结尾：</p>
<p>文章中出现的任何错误请大家批评指出，一定及时修改。</p>
<p>希望写在这里的小伙伴能给个<strong>三连支持</strong>！</p>
</blockquote>
</div>
<link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css" rel="stylesheet"/>
<link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css" rel="stylesheet"/>
</div>