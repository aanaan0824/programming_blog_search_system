<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<p> <img alt="" height="109" src="image\451dfef5a53e4c94a3ecbfb02d167973.png" width="286"/>  ​​​​​​ 🤣 爆笑教程 👉 <a href="https://blog.csdn.net/weixin_50502862/category_11602059.html" title="《C++要笑着学》">《C++要笑着学》</a> 👈 火速订阅<strong>  </strong>🔥</p>
<p><img alt="" height="123" src="image\32974baa747043f9907e5bbd13639957.png" width="679"/></p>
<p><img alt="" height="50" src="image\c52b4035e4864f4ba6cbbd9070bc53cd.png" width="324"/>  <strong> 本篇博客全站热榜排名：<span style="color:#be191c;">2</span></strong></p>
<p></p>
<p><strong>💭 写在前面</strong></p>
<p><img alt="" height="110" src="https://img-blog.csdnimg.cn/0ed16f946b2a44dc9e3bc89510902c12.gif" width="180"/> 本章将正式介绍深浅拷贝，在模拟实现 string 的同时带着去理解深浅拷贝。我们模拟实现 string类不是为了造更好的轮子，而是为了去学习它，理解它的本质！你自己造一次，心里会更清楚，也有利于加深对 string 的理解。</p>
<p></p>
<hr/>
<h2 id="%E2%85%A0.%C2%A0%20%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D">Ⅰ.  深浅拷贝</h2>
<h3 id="0x00%20%E5%BC%95%E5%85%A5%EF%BC%9A">0x00 引入：</h3>
<p><img alt="" height="41" src="image\0b8acaba58854fa78391a2d4f49e38f0.png" width="49"/> 我们先来实现 string 的构造和析构：</p>
<p>💬 string.h</p>
<pre><code class="language-cpp">namespace chaos {      // 命名空间
	class string {   
	public:
		string(const char* str) {
            // ...
		}
		~string() {
            // ...
		}

	private:
		char* _str;
	};
}</code></pre>
<p>这里为了和原有的<span style="color:#4da8ee;"> string </span>进行区分，我们搞一个命名空间给它们括起来。</p>
<p>❓ 思考一个问题，构造函数能不能这样初始化呢？</p>
<pre><code class="language-cpp">string(char* str)
	: _str(str) {}
</code></pre>
<p><img alt="" height="108" src="image\1ebeee0dd2904cc39b5f3337be4ff820.png" width="106"/> 这是不行的，因为你初始化这个<span style="color:#4da8ee;"> string </span>时，比如我们通常情况会这么写：</p>
<pre><code class="language-cpp">void test_string1() {
	string s1("hello world");
}</code></pre>
<p>这是一个常量字符串，退一万步来讲，就算它不是常量字符串，它也是一个指针，</p>
<p>是不能被修改的，那我们后面要实现修改、插入删除，怎么扩容嘛？</p>
<p><img alt="" height="177" src="https://img-blog.csdnimg.cn/77b279db8812475a9a9691896b7b3d65.gif" width="214"/></p>
<p> 你就只能对堆上的空间扩容了，所以是不能这么写的！那该怎么写呢？</p>
<p>💬 我们可以这么写：</p>
<pre><code class="language-cpp">string(const char* str)
    : _str(new char[strlen(str) + 1]) {    // 开strlen大小的空间
    strcpy(_str, str);
}</code></pre>
<p><img alt="" height="72" src="https://img-blog.csdnimg.cn/783adaa473ad4eef85f8899465b1bd73.gif" width="73"/>值得注意的是，这里要 <span style="color:#e6b223;">strlen</span><span style="color:#0d0016;">(str) + 1</span>，因为 <span style="color:#e6b223;">strlen</span> 算的是有效字符的长度，没算 <span style="color:#be191c;">\0</span> 。</p>
<p></p>
<p>💬 然后我们实现析构，用 <span style="color:#956fe7;">new</span>[] 对应的 <span style="color:#956fe7;">delete</span>[] 来析构：</p>
<pre><code class="language-cpp">~string() {
    delete[] _str;    // 释放空间
	_str = nullptr;   // 置空
}</code></pre>
<p></p>
<p><img alt="" height="132" src="https://img-blog.csdnimg.cn/8601db3dac94434a8de92b685eea3193.gif" width="235"/> 我们来测试一下：</p>
<p>💬 string.h</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

namespace chaos {
	class string {
	public:
		string(const char* str)
			: _str(new char[strlen(str) + 1]) {
			strcpy(_str, str);
		}
		~string() {
			delete[] _str;
			_str = nullptr;
		}
	private:
		char* _str;
	};

	void test_string1() {
		string s1("hello world");
	}
}</code></pre>
<p>💬 test.h</p>
<pre><code class="language-cpp">#include "string.h"

int main(void)
{
	chaos::test_string1();

	return 0;
}</code></pre>
<blockquote>
<p>🚩 运行结果如下：</p>
</blockquote>
<p><img alt="" height="133" src="image\97a742d6139c4b0086a9b4e66c7de5f2.png" width="546"/></p>
<p></p>
<p>💬 此时我们改一下测试用例 <span style="color:#4da8ee;">test_string1</span>，如果我们要用 <span style="color:#4da8ee;">s1</span> 拷贝构造一下 <span style="color:#4da8ee;">s2</span>：</p>
<pre><code class="language-cpp">void test_string1() {
	string s1("hello world");
	string s2(s1);
}</code></pre>
<blockquote>
<p>🚩 运行结果如下：</p>
</blockquote>
<p><img alt="" height="361" src="image\7b70c28f60144b2981ad4dd8781b5338.png" width="509"/></p>
<p>🔑 详细解析：</p>
<p><img alt="" height="421" src="image\b399bd46ae414d5f9105f0dc35ffd2fd.png" width="447"/></p>
<p> <img alt="" height="488" src="image\5821ff1eccb24910913b41f2e4f87bfe.png" width="536"/></p>
<p>❓ 如何解决这样的问题呢？</p>
<p>我们 <span style="color:#4da8ee;">s2</span> 拷贝构造你 <span style="color:#4da8ee;">s1</span>，本意并不是想跟你指向一块空间！</p>
<p>我们的本意是想让<span style="color:#4da8ee;"> s2</span> 有一块自己的空间，并且能内容是<span style="color:#4da8ee;"> s1</span> 里的<span style="color:#1c7331;"> hello world</span></p>
<p> <img alt="" height="193" src="image\4bec3b550be246279b2c5b9ea1efbd79.png" width="428"/></p>
<p>所以这里就涉及到了深浅拷贝的问题，我们下面就来探讨一下深浅拷贝的问题。</p>
<p></p>
<h3 id="0x01%C2%A0%20%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%E9%97%AE%E9%A2%98">0x01  深浅拷贝问题</h3>
<p><img alt="" height="50" src="image\6615ac064dd048cab6a766a6efc9f714.png" width="46"/> 举个最简单的例子 —— 拷贝就像是在抄作业！</p>
<p><strong>浅拷贝：</strong>直接无脑照抄，连名字都不改。</p>
<p>            <span style="color:#a5a5a5;">（直接把内存无脑指过去）</span></p>
<p><strong>深拷贝：</strong>聪明地抄，抄的像是我自己写的一样。</p>
<p>          <span style="color:#a5a5a5;">  （开一块一样大的空间，再把数据拷贝下来，指向我自己开的空间）</span></p>
<p><img alt="" height="270" src="image\9c4bff41ac5a4cb0808a646e24ab5985.png" width="482"/></p>
<p><span style="background-color:#f9eda6;">浅拷贝就是原封不动地把成员变量按字节依次拷贝过去，</span></p>
<p><span style="background-color:#f9eda6;">深拷贝就是进行深一个层次的拷贝，不是直接拷贝，而是拷贝你指向的空间。</span></p>
<p></p>
<h3 id="0x02%20%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E7%9A%84%E5%AE%9E%E7%8E%B0">0x02 拷贝构造的实现</h3>
<p><img alt="" height="100" src="https://img-blog.csdnimg.cn/797313dda152439b989850478045b6e9.gif" width="100"/> 我们之前实现日期类的时候，用自动生成的拷贝构造（浅拷贝）是可以的，</p>
<p>所以当时我们不用自己实现拷贝构造，让它默认生成就足够了。</p>
<p><img alt="" height="48" src="image\44beffd9c6b34332b0b1e40bf3f852ed.png" width="48"/> 但是像 <span style="color:#4da8ee;">string </span>这样的类，它的拷贝构造我们不得不亲自写。</p>
<p></p>
<p>💬 string 的拷贝构造：</p>
<pre><code class="language-cpp">/* s2(s1) */
string(const string&amp; s)
	: _str(new char[strlen(s._str) + 1]) {
	strcpy(_str, s._str);
}</code></pre>
<p>🔍 我们监视看一下效果：</p>
<p><img alt="" height="395" src="image\9dd17f7f0ed340388aa62f389ac1a6e5.png" width="505"/></p>
<p></p>
<h3 id="0x03%20%E8%B5%8B%E5%80%BC%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D">0x03 赋值的深拷贝</h3>
<p><img alt="" height="157" src="image\adea8fefc49945809f0c7ebcf8bf135f.png" width="394"/></p>
<p> 💬 现在有一个<span style="color:#4da8ee;"> s3</span>，如果我们想把<span style="color:#4da8ee;"> s3</span> 赋值给 <span style="color:#4da8ee;">s1</span>：</p>
<pre><code class="language-cpp">void test_string1() {
	string s1("hello world");
	string s2(s1);

	string s3("pig");
	s1 = s3;
}</code></pre>
<p>如果你不自己实现赋值，就和之前一样，会是浅拷贝，也会造成崩溃：</p>
<p><img alt="" height="297" src="image\17b1a0342a734f13944920d8c485575d.png" width="403"/></p>
<p></p>
<p>所以，我们仍然需要自己实现一个 <span style="color:#956fe7;">operator=</span> ，实现思路如下：</p>
<p><img alt="" height="621" src="image\f9499a93657245b5a932d3a81846d58b.png" width="538"/></p>
<p> 💬 代码实现<span style="color:#956fe7;"> operator= </span></p>
<pre><code class="language-cpp">/* s1 = s3 */
string&amp; operator=(const string&amp; s) {
    if (this != &amp;s) {  // 防止自己给自己赋值
		delete[] _str;                        // 释放原有的空间
		_str = new char[strlen(s._str) + 1];  // 开辟新的空间
		strcpy(_str, s._str);                 // 把s3的值赋给s1
	}

	return *this;
}</code></pre>
<p>🔑 代码解析：</p>
<p>根据我们的实现思路，首先释放原有空间，然后开辟新的空间，</p>
<p>最后把 <span style="color:#4da8ee;">s3</span> 的值赋值给 <span style="color:#4da8ee;">s1</span>。为了防止自己给自己赋值，我们可以判断一下。</p>
<p></p>
<p>这时我们还要考虑一个难以发现的问题，如果 <span style="color:#956fe7;">new</span> 失败了怎么办？</p>
<p><img alt="" height="101" src="image\99ef06ee812e4327b6c3156c5cd9dddd.png" width="100"/> 抛异常！抛异常！抛异常！</p>
<p>失败了没问题，也不会走到 <span style="color:#e6b223;">strcpy</span>，但问题是我们已经把原有的空间释放掉了，</p>
<p>神不知鬼不觉地，走到析构那里二次释放可能会炸，所以我们得解决这个问题！</p>
<p></p>
<p>⚡ 我们可以试着把释放原有空间的步骤放到后面：</p>
<p><img alt="" height="782" src="image\513708b253d84d019c0bbd776b137aef.png" width="560"/></p>
<pre><code class="language-cpp">/* s1 = s3 */
string&amp; operator=(const string&amp; s) {
	if (this != &amp;s) {  // 防止自己给自己赋值	
		char* tmp = new char[strlen(s._str) + 1];  // 开辟新的空间到tmp中
		strcpy(tmp, s._str);                       // 把s3的值赋给 tmp
		delete[] _str;                             // 释放原有的空间
		_str = tmp;                                // 把tmp的值赋给 s1
	}

	return *this;
}</code></pre>
<p>🔑 代码解析：</p>
<p>这样一来，就算是动态内存开辟失败了，我们也不用担心出问题了。</p>
<p>这是更标准的实现方式，我们先去开辟空间，放到临时变量 <span style="color:#0d0016;">tmp</span> 中，</p>
<p><img alt="" height="128" src="https://img-blog.csdnimg.cn/7fdad05da2ec4aac94e441e091b622e6.gif" width="128"/><span style="color:#0d0016;"> tmp</span> 没有翻车，再去释放原有的空间，最后再把<span style="color:#0d0016;"> tmp </span>的值交付给 <span style="color:#4da8ee;">s1</span>，</p>
<p>这是非常保险的，有效避免了空间没开成还把<span style="color:#4da8ee;"> s1</span> 空间释放掉的 "偷鸡不成蚀把米" 的事发生。</p>
<p></p>
<h2 id="%E2%85%A1.%C2%A0%20string%20%E7%9A%84%E5%AE%9E%E7%8E%B0">Ⅱ.  string 的实现</h2>
<h3 id="0x00%20%E5%BC%95%E5%85%A5">0x00 引入</h3>
<p><img alt="" height="48" src="image\b105aa9fd35547d393808b55c142b696.png" width="48"/> 刚才我们为了方便讲解深浅拷贝的问题，有些地方所以没有写全，</p>
<p> 是没有考虑增删查改的问题的，所以我们现在要增加一些成员：</p>
<pre><code class="language-cpp">private:
	char*  _str;
	size_t _size;
	size_t _capacity;   // 有效字符的空间数，不算\0</code></pre>
<p></p>
<h3 id="0x01%20%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%20_size%20%E5%92%8C%20_capacity">0x01 成员函数 _size 和 _capacity</h3>
<p>💬 加上<span style="color:#0d0016;"> _size</span> 和<span style="color:#0d0016;"> _capacity</span> 后，在刚才实现的 <span style="color:#4da8ee;">string </span>基础上修改完善：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

namespace chaos 
{
	class string {
	public:
	string(const char* str) 
		: _size(strlen(str)) 
		, _capacity(_size) {
		_str = new char[_capacity + 1];     // 多开一个空间给\0
		strcpy(_str, str);
	}
	/* s2(s1) */
	string(const string&amp; s)
		: _size(s._size)
		, _capacity(s._capacity) {
		_str = new char[_capacity + 1];
		strcpy(_str, s._str);
	}
	/* s1 = s3 */
	string&amp; operator=(const string&amp; s) {
		if (this != &amp;s) {                              // 防止自己给自己赋值
			char* tmp = new char[s._capacity + 1];     // 开辟新的空间到tmp中
			strcpy(tmp, s._str);                       // 把s3的值赋给 tmp
			delete[] _str;                             // 释放原有的空间
			_str = tmp;                                // 把tmp的值赋给 s1

			_size = s._size;
			_capacity = s._capacity;
		}

		return *this;
	}
	~string() {
		delete[] _str; 
		_str = nullptr;
			
		_size = _capacity = 0;
	}

	private:
	char*  _str;
	size_t _size;
	size_t _capacity;   // 有效字符的空间数，不算\0
	};
}</code></pre>
<p><img alt="" height="107" src="https://img-blog.csdnimg.cn/26635ae6aca04e0cab13cd675e028d7f.gif" width="100"/> 为了减少 <span style="color:#e6b223;">strlen </span>的次数，我们在初始化列表里只处理<span style="color:#0d0016;"> _size</span> 和<span style="color:#0d0016;"> _capacity</span>。</p>
<p></p>
<h3 id="0x02%20c_str()%20%E7%9A%84%E5%AE%9E%E7%8E%B0">0x02 c_str() 的实现</h3>
<p>📚 <span style="color:#4da8ee;">c_str</span>() 返回的是C语言字符串的指针常量，是可读不写的。</p>
<p>💬<span style="color:#4da8ee;"> c_str </span>的实现：</p>
<pre><code class="language-cpp">/* 返回C格式字符串：c_str */
const char* c_str() const {
	return _str;
}</code></pre>
<p><span style="background-color:#f9eda6;">const char*，因为是可读不可写的，所以我们需要用 const 修饰。</span></p>
<p><span style="color:#4da8ee;">c_str </span>返回的是当前字符串的首字符地址，这里我们直接 <span style="color:#956fe7;">return</span> <span style="color:#0d0016;">_str</span> 即可实现。</p>
<p></p>
<p><img alt="" height="171" src="image\daf36ffd15c843639b383a15e9b15ea4.png" width="147"/> 我们来测试一下：</p>
<pre><code class="language-cpp">void test_string1() {
	string s1("hello world");
	string s2;

	cout &lt;&lt; s1.c_str() &lt;&lt; endl;
}</code></pre>
<blockquote>
<p>🚩 运行结果如下： </p>
</blockquote>
<p><img alt="" height="152" src="image\67898b2b13e44ed68c85b9a60cae8fe4.png" width="473"/></p>
<p><span style="color:#a5a5a5;">（c_str 是认 \0 的，下面我们探讨不带参全缺省值给什么值的时候需要知道这个点）</span></p>
<p></p>
<h3 id="0x03%C2%A0%E5%85%A8%E7%BC%BA%E7%9C%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">0x03 全缺省构造函数</h3>
<p><img alt="" height="111" src="https://img-blog.csdnimg.cn/519ab58b0b98408f90505256422353a5.gif" width="109"/> 我们还要考虑不带参的情况，比如下面的 <span style="color:#0d0016;">s2</span>：</p>
<pre><code class="language-cpp">void test_string1() {
	string s1("hello world");    // 带参
	string s2;                   // 不带参
}</code></pre>
<p>💬 不带参初始化：</p>
<pre><code class="language-cpp">string()
	: _str(new char[1])
	, _size(0)
	, _capacity(0) {
	_str[0] = '\0';
}</code></pre>
<p>这里我们开一个空间给 <span style="color:#be191c;">\0</span>，既然都这么写了，我们不如直接在缺省值上动手脚：</p>
<pre><code class="language-cpp">string(const char* str = "")
	: _size(strlen(str)) 
	, _capacity(_size) {
	_str = new char[_capacity + 1];     // 多开一个空间给\0
	strcpy(_str, str);
}</code></pre>
<p>一般的类都是提供全缺省的，值得注意的是，这里缺省值给的是<span style="color:#1c7331;"> " "</span></p>
<p>有人看到指针 <span style="color:#ad720d;">char* </span>就突发恶疾，这里缺省值就忍不住想给个空 <span style="color:#6eaad7;">nullptr</span>：</p>
<pre><code class="language-cpp">string(const char* str = nullptr)</code></pre>
<p><img alt="" height="56" src="image\2ff6e29127a742f5ac61421cf62dbee3.png" width="119"/> 不能给！给了就崩。因为 <span style="color:#e6b223;">strlen</span> 是不会去检查空的，它是去找 <span style="color:#be191c;">\0</span> ，</p>
<pre><code class="language-cpp">	void test_string2() {
		string s1("hello world");
		string s2;

		cout &lt;&lt; s1.c_str() &lt;&lt; endl;
		cout &lt;&lt; s2.c_str() &lt;&lt; endl;
	}</code></pre>
<p>也就相当于直接对这个字符串进行解引用了，这里的字符串又是空，所以会引发空指针问题。</p>
<p>所以我们这里给的是一个空的字符串 <span style="color:#1c7331;">" "</span>，<span style="background-color:#f9eda6;">常量字符串默认就带有 \0</span>，这样就不会出问题：</p>
<pre><code class="language-cpp">string(const char* str = "")</code></pre>
<p><img alt="" height="245" src="image\d7b91c64ebc9440db7b3c47954389656.png" width="434"/></p>
<p></p>
<h3 id="0x04%C2%A0size()%20%E5%92%8C%20operator%5B%5D%20%E7%9A%84%E5%AE%9E%E7%8E%B0">0x04 size() 和 operator[] 的实现</h3>
<p>💬 <span style="color:#4da8ee;">size</span>() 的实现：</p>
<pre><code class="language-cpp">size_t size() const {
	return _size;
}</code></pre>
<p><img alt="" height="102" src="image\841da3123c8a4fb39e17b34298ddd77b.png" width="118"/><span style="color:#4da8ee;"> size</span>() 只需要返回成员函数<span style="color:#0d0016;"> _size</span> 即可，考虑到不需要修改，我们加上<span style="color:#ad720d;"> const</span>。</p>
<p></p>
<p>💬 <span style="color:#956fe7;">operator[]</span> 的实现：</p>
<pre><code class="language-cpp">/* operator[] */
char&amp; operator[](size_t pos) {
	return _str[pos];  // 返回字符串对应下标位置的元素
}</code></pre>
<p><img alt="" height="46" src="image\d7fbeedc13a444cc85fdfb641fa26025.png" width="55"/> 直接返回字符串对应下标位置的元素，</p>
<p>因为返回的是一个字符，所以我们这里引用返回 <span style="color:#ad720d;">char</span>。</p>
<p></p>
<p>我们来测试一下，遍历整个字符串，这样既可以测试到 <span style="color:#e6b223;">size</span>() 也可以测试到<span style="color:#956fe7;"> operator[]</span> ：</p>
<pre><code class="language-cpp">void test_string1() {
	string s1("hello world");
	string s2;

	for (size_t i = 0; i &lt; s1.size(); i++) {
		cout &lt;&lt; s1[i] &lt;&lt; " ";
	}
	cout &lt;&lt; endl;
}</code></pre>
<blockquote>
<p>🚩 运行结果如下：</p>
</blockquote>
<p><img alt="" height="139" src="image\c292772a596440518bbc00ad86a17a5b.png" width="432"/></p>
<p></p>
<p><img alt="" height="43" src="image\a7577949aca848fb92dbd7cf20f700fe.png" width="52"/> 我们再来测试一下 <span style="color:#956fe7;">operator[] </span>的 "写" 功能：</p>
<pre><code class="language-cpp">void test_string1() {
	string s1("hello world");
	string s2;

	s1[0] = 'F';
	for (size_t i = 0; i &lt; s1.size(); i++) {
		cout &lt;&lt; s1[i] &lt;&lt; " ";
	}
	cout &lt;&lt; endl;
}</code></pre>
<p><img alt="" height="172" src="image\8dc895b0cdbc43eaaee642691f6f9a6c.png" width="573"/></p>
<p></p>
<p><img alt="" height="101" src="image\13b5737a3bf14e3db306f6f010e4668c.png" width="100"/> 普通对象可以调用，但是 <span style="color:#ad720d;">const </span>对象呢？所以我们还要考虑一下<span style="color:#ad720d;"> const </span>对象。</p>
<p>💬 我们写一个 <span style="color:#ad720d;">const </span>对象的重载版本：</p>
<pre><code class="language-cpp">const char&amp; operator[](size_t pos) const {
	return _str[pos];
}
</code></pre>
<p>因为返回的是 <span style="color:#0d0016;">pos</span> 位置字符的 <span style="color:#ad720d;">const</span> 引用，所以可读但不可写。</p>
<p></p>
<p>💬 最后我们还需要考虑一下越界的问题，这里我们使用<span style="color:#956fe7;">断言</span>暴力处理一下：</p>
<pre><code class="language-cpp">#include &lt;assert.h&gt;
...

char&amp; operator[](size_t pos) {
	assert(pos &lt; _size);
	return _str[pos];
}

const char&amp; operator[](size_t pos) const {
	assert(pos &lt; _size);
	return _str[pos];
}</code></pre>
<p></p>
<p><img alt="" height="119" src="https://img-blog.csdnimg.cn/8e8024d32efd4d68a34d522bffaa1e34.gif" width="141"/> 测试一下效果如何：</p>
<pre><code class="language-cpp">void test_string1() {
	string s1("hello world");
	s1[30];
}</code></pre>
<p><img alt="" height="461" src="image\e2965a2f7e674942827637f9950c23ad.png" width="496"/></p>
<p></p>
<p></p>
<h2 id="%E2%85%A2.%20%E5%AE%9E%E7%8E%B0%E8%BF%AD%E4%BB%A3%E5%99%A8">Ⅲ. 实现迭代器</h2>
<h3 id="0x00%20%E5%BC%95%E5%85%A5%20-%20%E5%86%8D%E6%8E%A2%E8%BF%AD%E4%BB%A3%E5%99%A8">0x00 引入 - 再探迭代器</h3>
<p>在上一章中，我们首次讲解迭代器，为了方便理解，我们当时解释其为像指针一样的类型。</p>
<p><img alt="" height="417" src="image\082297cd0b9746d09804702e512d577d.png" width="516"/></p>
<p>实际上，有没有一种可能，它就是一种指针呢？</p>
<p>遗憾的是，<span style="background-color:#f9eda6;">迭代器并非指针，而是类模板。</span> 只是它表现地像指针，模拟了指针的部分功能。</p>
<p></p>
<h3 id="0x01%20%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0">0x01 迭代器的实现</h3>
<p>实际上迭代器的实现非常简单，它就是一个 <span style="color:#ad720d;">char*</span> 的指针罢了（但也不一定）。</p>
<p>后面我们讲解 list 的时候它又™不是指针了，又是自定义类型了。如何评价？</p>
<p><img alt="" height="160" src="image\3d52cf8949bd4abfa9930a0c9e305f83.png" width="171"/> 我的评价是 —— 似是而非。</p>
<p>它是一个像指针的东西，有可能是指针有可能不是指针。</p>
<p></p>
<p>💬 实现迭代器的 <span style="color:#4da8ee;">begin</span>() 和 <span style="color:#4da8ee;">end</span>() ：</p>
<pre><code class="language-cpp">typedef char* iterator;
iterator begin() {
	return _str;          // 返回第一个字符位置
}
iterator end() {
	return _str + _size;  // 返回最后一个数据的下一个位置
}</code></pre>
<p></p>
<p>💬 我们来测试一下：</p>
<pre><code class="language-cpp">void test_string2() {
	string s1("hello world");

	// 迭代器写
	string::iterator it = s1.begin();
	while (it != s1.end()) {
		*it += 1;
		it++;
	}
		
	// 迭代器读
	it = s1.begin();   // 重置起点
	while (it != s1.end()) {
		cout &lt;&lt; *it &lt;&lt; " ";
		it++;
	}
}</code></pre>
<blockquote>
<p>🚩 运行结果如下：</p>
</blockquote>
<p><img alt="" height="150" src="image\8bbbe736c04140c088b5a8d30be82268.png" width="572"/></p>
<p></p>
<h3 id="0x02%20const%20%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0">0x02 const 迭代器的实现</h3>
<p><img alt="" height="100" src="image\4d1b53b1a22b41adba6c7f9725bfcd32.png" width="100"/> 我们知道，<span style="color:#ad720d;">const </span>迭代器就是可以读但是不可以写的迭代器。 </p>
<p></p>
<p>💬 const 迭代器：</p>
<pre><code class="language-cpp">typedef const char* const_iterator;
const_iterator begin() const {
	return _str;          // 返回第一个字符位置
}
const_iterator end() const {
	return _str + _size;  // 返回最后一个数据的下一个位置
}</code></pre>
<p>这里用 <span style="color:#ad720d;">const</span> 修饰，意味着解引用时可以读但不可以写。</p>
<p></p>
<h3 id="0x03%C2%A0%E5%86%8D%E5%BA%A6%E6%80%9D%E8%80%83%E8%BF%AD%E4%BB%A3%E5%99%A8">0x03 再度思考迭代器</h3>
<p><img alt="" height="156" src="image\318c38e48bfe48c6a5b6ced2d1747c2b.png" width="137"/></p>
<p>它的底层是连续地物理空间，给原生指针++解引用能正好贴合迭代器的行为，就能做到遍历。</p>
<p>但是对于链表和树型结构来说，迭代器的实现就没有这么简单了。</p>
<p>但是，强大的迭代器通过统一的封装，无论是树、链表还是数组……</p>
<p>它都能用统一的方式遍历，这就是迭代器的优势，也是它的强大之处。</p>
<p></p>
<h3 id="0x04%20%E5%86%8D%E7%9C%8B%E8%8C%83%E5%9B%B4%20for">0x04 再探范围 for</h3>
<p><img alt="" height="223" src="image\7dd4748e77504c18a235373bf681c391.png" width="564"/></p>
<p>上一章讲 string 类对象的遍历时，我们讲的第三种方式就是范围 <span style="color:#956fe7;">for</span>，回忆一下 ——</p>
<p><img alt="" height="184" src="image\68c5dbdee20b4944b36df1537d019efb.png" width="493"/>（五毛特效）</p>
<p>我们上一章提到过，我们现在就来演示一下范围 <span style="color:#956fe7;">for </span>的实现：</p>
<pre><code class="language-cpp">for (auto e : s1) {
	cout &lt;&lt; e &lt;&lt; " ";
}
cout &lt;&lt; endl;</code></pre>
<p>你会发现根本就不需要自己实现，你只要把迭代器实现好，范围<span style="color:#956fe7;"> for</span> 直接就可以用。</p>
<p><span style="background-color:#f9eda6;">范围 for 的本质是由迭代器支持的，编译时范围 for 会被替换成迭代器。</span></p>
<p><img alt="" height="47" src="image\e2d599e999f84f38a635fa12ba347654.png" width="56"/> 这么一看，又是自动加加，又是自动判断结束的范围 <span style="color:#956fe7;">for</span>，好像也没那么回事儿。</p>
<p></p>
<p>📌 注意事项：</p>
<p>它的替换是认 <span style="color:#4da8ee;">begin</span> 和<span style="color:#4da8ee;"> end</span> 的，我们可以试着把我们实现的迭代器<span style="color:#4da8ee;"> begin</span> 的 b 改成大写 B 试试：</p>
<pre><code class="language-cpp">		typedef char* iterator;
		iterator Begin() {
			return _str;         
		}
		iterator end() {
			return _str + _size;  
		}</code></pre>
<pre><code class="language-cpp">void test_string2() {
	string s1("hello world");
	string::iterator it = s1.Begin();
	while (it != s1.end()) {
		*it += 1;
		it++;
	}
	it = s1.Begin();   // 重置起点
	while (it != s1.end()) {
		cout &lt;&lt; *it &lt;&lt; " ";
		it++;
	}
	
    for (auto e : s1) {
		cout &lt;&lt; e &lt;&lt; " ";
	}
	cout &lt;&lt; endl;
}</code></pre>
<p><img alt="" height="79" src="image\e5d088206b2c443bb5c885bd256acb87.png" width="94"/> 迭代器是可以正常用的，但是范围<span style="color:#4da8ee;"> for</span> 就寄了。</p>
<p><img alt="" height="132" src="image\3114b2d86aed49c5b8a5d992024e270c.png" width="592"/></p>
<p>因为它是按迭代器固定的名称去替换的，<span style="color:#4da8ee;">begin</span> 和 <span style="color:#4da8ee;">end</span>，</p>
<p>如果你自己实现迭代器时没有按固定的规范去实现，</p>
<p>比如 <span style="color:#4da8ee;">begin</span> 取名为<span style="color:#0d0016;"> start</span>，那范围<span style="color:#956fe7;"> for</span> 就不支持了。</p>
<p></p>
<h2 id="%E2%85%A3.%C2%A0%20string%E7%9A%84%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9">Ⅳ.  string的增删查改</h2>
<h3 id="0x00%20reserve()%20%E7%9A%84%E5%AE%9E%E7%8E%B0">0x00 reserve() 的实现</h3>
<p>💬 我们先实现一下 <span style="color:#4da8ee;">reserve</span> 增容：</p>
<pre><code class="language-cpp">/* 增容：reverse */
void reserve(size_t new_capacity) {
	if (new_capacity &gt; _capacity) {
		char* tmp = new char[new_capacity + 1];  // 开新空间
		strcpy(tmp, _str);                       // 搬运
		delete[] _str;                           // 释放原空间

		_str = tmp;                              // 没问题，递交给_str
		_capacity = new_capacity;                // 更新容量
	}
}</code></pre>
<p>这里可以检查一下是否真的需要增容，万一接收的 <span style="color:#0d0016;">new_capacity</span> 比 <span style="color:#0d0016;">_capacity </span>小，就不动。</p>
<p><img alt="" height="48" src="image\c0c125b2816545a3bc60ae1083fb0bcf.png" width="48"/> 这里我们之前讲数据结构用的是<span style="color:#956fe7;"> realloc</span>，现在我们熟悉熟悉用<span style="color:#956fe7;"> new</span>，</p>
<p> 还是用申请新空间、原空间数据拷贝到新空间，再释放空间地方式去扩容。</p>
<p>我们的<span style="color:#0d0016;"> _capacity</span> 存储的是有效字符，没算<span style="color:#be191c;"> \0</span>，所以这里还要 <span style="color:#ad720d;">+1</span> 为 <span style="color:#be191c;">\0</span> 开一个空间。</p>
<p><img alt="" height="462" src="image\d7f4cfc2b1e642a382bd5d7998f880ac.png" width="586"/></p>
<p></p>
<h3 id="0x01%C2%A0push_back()%20%E7%9A%84%E5%AE%9E%E7%8E%B0">0x01 push_back() 的实现</h3>
<p>💬 <span style="color:#4da8ee;">push_back</span>：</p>
<pre><code class="language-cpp">/* 字符串尾插：push_back */
void push_back(char append_ch) {
	if (_size == _capacity) {      // 检查是否需要增容
		reserve(_capacity == 0 ? 4 : _capacity * 2); 
	}

	_str[_size] = append_ch;       // 插入要追加的字符
	_size++;
	_str[_size] = '\0';            // 手动添加'\0'
}</code></pre>
<p>首先检查是否需要增容，如果需要就调用我们上面实现的<span style="color:#956fe7;"> reserve </span>函数，</p>
<p>参数传递可以用三目操作符，防止容量是0的情况，0乘任何数都是0从而引发问题的情况。</p>
<p>然后在 <span style="color:#be191c;">\0</span> 处插入要追加的字符 <span style="color:#0d0016;">append_ch</span>，然后 <span style="color:#0d0016;">_size++</span> 并手动添加一个新的<span style="color:#be191c;"> \0</span> 即可。</p>
<p></p>
<p>我们来测试一下效果如何：</p>
<pre><code class="language-cpp">	void test_string4() {
		string s1("hello world");
		cout &lt;&lt; s1.c_str() &lt;&lt; endl;

		s1.push_back('!');
		cout &lt;&lt; s1.c_str() &lt;&lt; endl;

		s1.push_back('A');
		cout &lt;&lt; s1.c_str() &lt;&lt; endl;
	}</code></pre>
<blockquote>
<p> 🚩 运行结果如下：</p>
</blockquote>
<p><img alt="" height="166" src="image\97691753bc254c389ec260afca267cd4.png" width="460"/></p>
<p></p>
<p></p>
<h3 id="0x02%C2%A0append()%20%E7%9A%84%E5%AE%9E%E7%8E%B0">0x02 append() 的实现</h3>
<p>💬 <span style="color:#4da8ee;">append</span>：</p>
<pre><code class="language-cpp">/* 字符串追加：append */
void append(const char* append_str) {
	size_t len = strlen(append_str);     // 计算要追加的字符串的长度
	if (_size + len &gt; _capacity) {       // 检查是否需要增容
		reserve(_size + len);
	}

	strcpy(_str + _size, append_str);    // 首字符+大小就是\0位置
	_size += len;                        // 更新大小
}</code></pre>
<p><span style="color:#4da8ee;">append </span>是追加字符串的，首先我们把要追加的字符串长度计算出来，</p>
<p>然后看容量够不够，不够我们就交给 <span style="color:#e6b223;">reserve </span>去扩容，扩 <span style="color:#0d0016;">_size + len</span>，够用就行。</p>
<p><img alt="" height="443" src="image\57634f33f182448587e1e705245c5e04.png" width="526"/></p>
<p>这里我们甚至都不需要用<span style="color:#4da8ee;"> </span><span style="color:#e6b223;">strcat</span>，因为它的位置我们很清楚，不就在<span style="color:#0d0016;"> _str + _size</span><span style="color:#0d0016;"> </span>后面插入吗。</p>
<p>用<span style="color:#e6b223;"> strcat</span> 还需要遍历找到原来位置的<span style="color:#be191c;"> \0</span>，太麻烦了。</p>
<p></p>
<h3 id="0x03%C2%A0operator%2B%3D%C2%A0%E7%9A%84%E5%AE%9E%E7%8E%B0">0x03 operator+= 的实现</h3>
<p>这就是我们一章说的 "用起来爽到飞起" 的 += ，因为字符和字符串都可以用 += 去操作。</p>
<p>所以我们需要两个重载版本，一个是字符的，一个是字符串的。</p>
<p>我们不需要自己实现了，直接复用 <span style="color:#e6b223;">push_back</span> 和 <span style="color:#e6b223;">append</span> 就好了。</p>
<p>💬<span style="color:#4da8ee;"> </span><span style="color:#956fe7;">operator</span><span style="color:#be191c;">+= </span></p>
<pre><code class="language-cpp">/* operator+= */
string&amp; operator+=(char append_ch) {
	push_back(append_ch);    // 复用push_back
	return *this;
}
string&amp; operator+=(const char* append_str) {
	append(append_str);      // 复用append
	return *this;
}</code></pre>
<p></p>
<p><img alt="" height="86" src="https://img-blog.csdnimg.cn/25fa736f47a0442aa80d0539a2a2c38c.gif" width="100"/> 测试一下看看：</p>
<pre><code class="language-cpp">	void test_string5() {
		string s1("hello world");
		cout &lt;&lt; s1.c_str() &lt;&lt; endl;

		s1 += '!';
		cout &lt;&lt; s1.c_str() &lt;&lt; endl;

		s1 += "this is new data";
		cout &lt;&lt; s1.c_str() &lt;&lt; endl;
	}</code></pre>
<blockquote>
<p>🚩 运行结果如下：</p>
</blockquote>
<p><img alt="" height="164" src="image\3c54dd2e7b2644cbbf76e401d64fa5d8.png" width="483"/></p>
<p></p>
<h3 id="%C2%A00x04%C2%A0%E5%AE%9E%E7%8E%B0%20insert()">0x04 insert() 的实现</h3>
<p>💬 <span style="color:#4da8ee;">insert</span>：字符</p>
<pre><code class="language-cpp">/* 插入：insert */
string&amp; insert(size_t pos, char append_ch) {
	assert(pos &lt;= _size);

	// 检查是否需要增容
	if (_size == _capacity) {     
		reserve(_capacity == 0 ? 4 : _capacity * 2);
	}
			
	// 向后挪动数据
	//size_t end = _size;
	//while (end &gt;= (int)pos) {
	//	_str[end + 1] = _str[end];
	//	end--;
	//}

	size_t end = _size + 1;
	while (end &gt; pos) {
		_str[end] = _str[end - 1];
		end--;
	}

	// 插入
	_str[pos] = append_ch;
	_size++;

	return *this;
}
</code></pre>
<p></p>
<p>💬<span style="color:#4da8ee;"> insert</span>：字符串</p>
<pre><code class="language-cpp">string&amp; insert(size_t pos, const char* append_str) {
	assert(pos &lt;= _size);
	size_t len = strlen(append_str);

	// 检查是否需要增容
	if (_size + len &gt; _capacity) {
		reserve(_size + len);
	}

	// 向后挪动数据
	size_t end = _size + len;
	while (end &gt; pos + len - 1) {
		_str[end] = _str[end - len];
		end--;
	}

	// 插入
	strncpy(_str + pos, append_str, len);
	_size += len;

	return *this;
}</code></pre>
<p></p>
<p>测试一下：</p>
<pre><code class="language-cpp">	void test_string6() {
		string s1("hello world");
		cout &lt;&lt; s1.c_str() &lt;&lt; endl;

		s1.insert(0, 'X');
		cout &lt;&lt; s1.c_str() &lt;&lt; endl;

		s1.insert(0, "hahahaha");
		cout &lt;&lt; s1.c_str() &lt;&lt; endl;
	}</code></pre>
<blockquote>
<p>🚩 运行结果如下：</p>
</blockquote>
<p><img alt="" height="156" src="image\65f69790677a4675acc696fe47d4895c.png" width="433"/></p>
<p></p>
<p><span style="color:#4da8ee;">insert</span> 都实现了，那<span style="color:#4da8ee;"> push_back</span> 和 <span style="color:#4da8ee;">append</span> 直接复用，岂不美哉？</p>
<p><img alt="" height="218" src="image\37c5ef5daf294b039160e2c2996c5639.png" width="361"/></p>
<p>⚡ 修改<span style="color:#4da8ee;"> push_back</span> 和<span style="color:#4da8ee;"> append</span>：</p>
<pre><code class="language-cpp">/* 字符串尾插：push_back */
void push_back(char append_ch) {
	//if (_size == _capacity) {      // 检查是否需要增容
	//	reserve(_capacity == 0 ? 4 : _capacity * 2); 
	//}

	//_str[_size] = append_ch;       // 插入要追加的字符
	//_size++;
	//_str[_size] = '\0';            // 手动添加'\0'

	insert(_size, append_ch);
}

/* 字符串追加：append */
void append(const char* append_str) {
	//size_t len = strlen(append_str);     // 计算要追加的字符串的长度
	//if (_size + len &gt; _capacity) {       // 检查是否需要增容
	//	reserve(_size + len);
	//}

	//strcpy(_str + _size, append_str);    // 首字符+大小就是\0位置
	//_size += len;                        // 更新大小

	insert(_size, append_str);
}</code></pre>
<p></p>
<p>测试一下 <span style="color:#4da8ee;">push_back</span> 和<span style="color:#4da8ee;"> append</span>，和复用它们两实现的 <span style="color:#956fe7;">operator+=</span> 有没有问题：</p>
<pre><code class="language-cpp">	void test_string4() {
		string s1("hello world");
		cout &lt;&lt; s1.c_str() &lt;&lt; endl;

		s1.push_back('!');
		cout &lt;&lt; s1.c_str() &lt;&lt; endl;

		s1.push_back('A');
		cout &lt;&lt; s1.c_str() &lt;&lt; endl;

		s1.append("this is new data");
	}

    void test_string5() {
		string s1("hello world");
		cout &lt;&lt; s1.c_str() &lt;&lt; endl;

		s1 += "!";
		cout &lt;&lt; s1.c_str() &lt;&lt; endl;

		s1 += "this is new data";
		cout &lt;&lt; s1.c_str() &lt;&lt; endl;
	}</code></pre>
<blockquote>
<p>🚩 运行结果如下：</p>
</blockquote>
<p><img alt="" height="285" src="image\138ca665ee224f4bb077b952c08d277a.png" width="626"/></p>
<p></p>
<h3 id="0x05%C2%A0%E5%AE%9E%E7%8E%B0%20resize()">0x05 resize() 的实现</h3>
<p>我们为了扩容，先实现了 <span style="color:#4da8ee;">reverse</span>，现在我们再顺便实现一下 <span style="color:#4da8ee;">resize</span>。</p>
<p>这里再提一下<span style="color:#4da8ee;"> reverse</span> 和 <span style="color:#4da8ee;">resize </span>的区别：</p>
<p></p>
<p>resize 分给初始值和不给初始值的情况，所以有两种：</p>
<p><img alt="" height="75" src="image\fe85879a2cc84f6dadb3a70d33c17f1a.png" width="310"/> 他们也是这么实现的。</p>
<p>但是我们上面讲构造函数的时候说过，我们可以使用全缺省的方式，这样就可以二合一了。</p>
<p><span style="color:#4da8ee;">resize</span> 实现的难点是要考虑种种情况，我们来举个例子分析一下：</p>
<p><img alt="" height="255" src="image\33017672b77049d89976225cb829e3c2.png" width="328"/></p>
<p><strong>如果欲增容量比 _size 小的情况：</strong></p>
<p><img alt="" height="136" src="image\465c385101634fd5bb7cf933d927e5b1.png" width="416"/></p>
<p>因为标准库是没有缩容的，所以我们实现的时候也不考虑去缩容。我们可以加一个 <span style="color:#be191c;">\0</span> 去截断。</p>
<p></p>
<p><strong>如果预增容量比 _size 大的情况：</strong></p>
<p>resize 是开空间 + 初始化，开空间的工作我们就可以交给已经实现好的<span style="color:#e6b223;"> reserve</span>，</p>
<p>然后再写 resize 的初始化的功能，我们这里可以使用 <span style="color:#e6b223;">memset</span> 函数。</p>
<p><img alt="" height="267" src="image\3c9e63d4a3634dd5b129ebf445db2a70.png" width="587"/></p>
<p></p>
<p>💬 <span style="color:#4da8ee;">resize</span>：</p>
<pre><code class="language-cpp">/* resize */
void resize(size_t new_capacity, char init_ch = '\0') {
	// 如果欲增容量比_size小
	if (new_capacity &lt;= _size) {
		_str[new_capacity] = '\0';      // 拿斜杠零去截断
		_size = new_capacity;           // 更新大小
	}
	// 欲增容量比_size大
	else {
		if (new_capacity &gt; _capacity) { 
			reserve(new_capacity);
		}
		// 起始位置，初始化字符，初始化个数
		memset(_str + _size, init_ch, new_capacity - _size);
		_size = _capacity;
		_str[_size] = '\0';
	}
}</code></pre>
<p id=""></p>
<h3 id="0x06%C2%A0%E5%AE%9E%E7%8E%B0%20find()">0x06 find() 的实现</h3>
<p>💬 <span style="color:#4da8ee;">find</span>：查找字符</p>
<pre><code class="language-cpp">/* find */
size_t find(char aim_ch) {
	for (size_t i = 0; i &lt; _size; i++) {
		if (aim_ch == _str[i]) { 
			// 找到了
			return i;    // 返回下标
		}
	}
	// 找不到
	return npos;
}</code></pre>
<p><img alt="" height="56" src="image\ca593bb9d5314342800705677e4271de.png" width="136"/> 遍历整个字符串，找到了目标字符 <span style="color:#0d0016;">aim_ch</span> 就返回对应的下标。</p>
<p>如果遍历完整个字符串都没找到，就返回 <span style="color:#0d0016;">npos</span>（找到库的来）。</p>
<p> 💬 这个<span style="color:#0d0016;"> npos</span> 我们可以在成员变量中定义：</p>
<pre><code class="language-cpp">...
    private:
		/* 成员变量 */
		char* _str;
		size_t _size;
		size_t _capacity;   // 有效字符的空间数，不算\0
    public:
		static const size_t npos;
	};

	/* 初始化npos */
	const size_t string::npos = -1;   // 无符号整型的-1，即整型的最大值。

...
}</code></pre>
<p></p>
<p>💬 <span style="color:#4da8ee;">find</span>：查找字符串</p>
<pre><code class="language-cpp">size_t find(const char* aim_str, size_t pos = 0) {
	const char* ptr = strstr(_str + pos, aim_str);
	if (ptr == nullptr) {
		return npos;
	}
	else {
		return ptr - _str;  // 减开头
	}
}</code></pre>
<p><img alt="" height="175" src="image\0155aa43c71e43fb8081acdd46cc2a90.png" width="597"/></p>
<p>这里我们可以用 <span style="color:#956fe7;">strstr</span> 去找子串，如果找到了，返回的是子串首次出现的地址。如果没找到，返回的是空。所以我们这里可以做判断，如果是<span style="color:#6eaad7;"> nullptr </span>就返回<span style="color:#0d0016;"> npos</span>。如果找到了，就返回对应下标，子串地址 - 开头，就是下标了。</p>
<p></p>
<h3 id="0x07%C2%A0%E5%AE%9E%E7%8E%B0%20erase()">0x07 erase() 的实现</h3>
<p>💬 erase：</p>
<pre><code class="language-cpp">/* 删除：erase */
string&amp; erase(size_t pos, size_t len = npos) {
	assert(pos &lt; _size);

	if (len == pos || pos + len &gt;= _size) {
		_str[pos] = '\0';    // 放置\0截断
		_size = pos;
	}
	else {
		strcpy(_str + pos, _str + pos + len);
		_size -= len;
	}

	return *this;
}</code></pre>
<p></p>
<p>测试一下：</p>
<pre><code class="language-cpp">	void test_string7() {
		string s1("hello world");
		cout &lt;&lt; s1.c_str() &lt;&lt; endl;

		s1.erase(5, 2);   // 从第五个位置开始，删两个字符
		cout &lt;&lt; s1.c_str() &lt;&lt; endl;

		s1.erase(5, 20);  // 从第五个位置开始，删完
		cout &lt;&lt; s1.c_str() &lt;&lt; endl;

	}</code></pre>
<blockquote>
<p>🚩 运行结果如下：</p>
</blockquote>
<p><img alt="" height="143" src="image\0556054bd5774e93b512865ae8f80d86.png" width="501"/></p>
<p></p>
<p></p>
<h2 id="%E2%85%A4.%20%E4%BC%A0%E7%BB%9F%E5%86%99%E6%B3%95%E5%92%8C%E7%8E%B0%E4%BB%A3%E5%86%99%E6%B3%95">Ⅴ. 传统写法和现代写法</h2>
<h3 id="0x00%20%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E7%9A%84%E4%BC%A0%E7%BB%9F%E5%86%99%E6%B3%95">0x00 拷贝构造的传统写法</h3>
<p><img alt="" height="187" src="image\864b87e3ec59478c91fcb244a4856bbb.png" width="449"/></p>
<p>对于深拷贝，传统写法就是本本分分分地去完成深拷贝。</p>
<p>💬 我们刚才实现的方式，用的就是传统写法：</p>
<pre><code class="language-cpp">/* 拷贝构造函数：s2(s1) */
string(const string&amp; s)         // 拷贝构造必须使用引用传参，一般用const修饰 
	: _size(s._size)            // 将s1的size给给s2
	, _capacity(s._capacity)    // 将s1的capacity给给s2
{
	_str = new char[_capacity + 1];   // 开辟空间
	strcpy(_str, s._str);             // 将s1字符串给给s2
}</code></pre>
<p>这就是传统写法，非常的老实。</p>
<p></p>
<h3 id="0x01%20%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E7%9A%84%E7%8E%B0%E4%BB%A3%E5%86%99%E6%B3%95">0x01 拷贝构造的现代写法</h3>
<p>现在我们来介绍一种现代写法，它和传统写法本质工作是一样的，即完成深拷贝。</p>
<p>现代写法的方式不是本本分分地去按着 Step 一步步干活，而是 "投机取巧" 地去完成深拷贝。</p>
<p>💬 直接看代码：<span style="color:#be191c;">（为了方便讲解，我们暂不考虑 _size 和 _capacity）</span></p>
<pre><code class="language-cpp">// 现代写法
string(const string&amp; s)
	: _str(nullptr)        // 为tmp置空做准备
{
	string tmp(s._str);    
	swap(_str, tmp._str);  // 交换
}</code></pre>
<p><img alt="" height="560" src="image\5b238f7ff977400f87d402cb977d3366.png" width="620"/></p>
<p><img alt="" height="185" src="image\0a884ed12acc46adbe25cf9afd113093.png" width="139"/>现代写法的本质就是复用了构造函数。</p>
<p>我想拷贝，但我又不想自己干，我把活交给工具人<span style="color:#4da8ee;"> swap </span>来帮我干。妙啊！资本家看了都说好！</p>
<p></p>
<p>❓ 我们为什么要在初始化列表中，给 <span style="color:#0d0016;">_str</span> 个空指针：</p>
<pre><code class="language-cpp">string(const string&amp; s)
	: _str(nullptr)</code></pre>
<p>我们可以设想一下，如果我们不对他进行处理，那么它的默认指向会是个随机值。</p>
<p><img alt="" height="91" src="image\cd94cae9e645484da17111e6d2d1debe.png" width="397"/></p>
<p>这样交换看上去没啥问题，确实能完成深拷贝，但是会引发一个隐患！</p>
<p><span style="color:#0d0016;">tmp</span> 是一个局部对象，我们把 <span style="color:#4da8ee;">s2</span> 原来的指针和 <span style="color:#0d0016;">tmp </span>交换了，那么 <span style="color:#0d0016;">tmp </span>就成了个随机值了。</p>
<p><span style="color:#0d0016;">tmp</span> 出了作用域要调用析构函数，对随机值指向的空间进行释放，怎么释放？</p>
<p>都不是你自己的 <span style="color:#956fe7;">new</span> / <span style="color:#956fe7;">malloc</span> 出来的，你还硬要对它释放，就可能会引发崩溃。</p>
<p>但是 <span style="color:#956fe7;">delete</span> /<span style="color:#956fe7;"> free </span>一个空，是不会报错的，因为会进行一个检查。</p>
<p>所以是可以<span style="color:#956fe7;"> delete</span> 一个空的，我们这里初始化列表中把 <span style="color:#6eaad7;">nullptr</span> 给<span style="color:#0d0016;"> _str</span>，</p>
<p>是为了交换完之后， <span style="color:#6eaad7;">nullptr</span> 能交到<span style="color:#0d0016;"> tmp </span>手中，这样<span style="color:#0d0016;"> tmp</span> 出了作用域调用析构函数就不会翻车了。</p>
<p>🐞 我们来看看效果如何：</p>
<p><img alt="" height="116" src="image\ce567ac514ea4e2d87069472daca81c5.png" width="416"/></p>
<p></p>
<p>💬 如果还是不放心，我们还可以在析构函数那进行一个严格的检查：</p>
<pre><code class="language-cpp">/* 析构函数 */
~string() {
	if (_str != nullptr) {
		delete[] _str;
		_str = nullptr;
	}
	_size = _capacity = 0;
}</code></pre>
<p></p>
<h3 id="0x02%20%E8%B5%8B%E5%80%BC%E9%87%8D%E8%BD%BD%E7%9A%84%E7%8E%B0%E4%BB%A3%E5%86%99%E6%B3%95">0x02 赋值重载的现代写法</h3>
<p><img alt="" height="222" src="image\99348f95ac52429ab51061824750337a.png" width="478"/></p>
<p> 💬 传统写法：</p>
<pre><code class="language-cpp">/* 赋值重载：s1 = s3 */
string&amp; operator=(const string&amp; s) {
	if (this != &amp;s) {                              // 防止自己给自己赋值  
		char* tmp = new char[s._capacity + 1];     // Step1：先在tmp上开辟新的空间
		strcpy(tmp, s._str);                       // Step2：把s3的值赋给tmp
		delete[] _str;                             // Step3：释放原有的空间
		_str = tmp;                                // Step4：把tmp的值赋给s1

		// 把容量和大小赋过去
		_size = s._size;      
		_capacity = s._capacity;
	}

	return *this;   // 结果返回*this
}</code></pre>
<p><img alt="" height="48" src="image\e034e9f7e379479489d7ce1793c626e8.png" width="50"/> 传统写法，全都自己干，自己开空间自己拷贝数据。</p>
<p></p>
<p>💬 现代写法：复用拷贝构造</p>
<pre><code class="language-cpp">/* 赋值重载：s1 = s3 */
string&amp; operator=(const string&amp; s) {
	if (this != &amp;s) {
		string tmp(s);   // 复用拷贝构造
		swap(_str, tmp._str);
	}

	return *this;
}</code></pre>
<p><img alt="" height="193" src="image\fb815c99368c436faebb9258276657dc.png" width="594"/></p>
<p>我们先通过 <span style="color:#4da8ee;">s3 </span>拷贝构造出<span style="color:#0d0016;"> tmp</span>，这样<span style="color:#0d0016;"> tmp</span> 就是 <span style="color:#0d0016;">_str </span>的工具人了。</p>
<p><span style="color:#0d0016;">tmp</span> 里的 "<span style="color:#1c7331;">pig"</span> ，<span style="color:#4da8ee;">s1 </span>看的简直是垂涎欲滴，我们让<span style="color:#0d0016;"> tmp </span>和 <span style="color:#4da8ee;">s1</span> 交换一下</p>
<p><img alt="" height="239" src="image\65e4897894564d63ad04fea0caca6f4d.png" width="592"/></p>
<p>交换完之后，正好让<span style="color:#4da8ee;"> tmp </span>出作用域调用析构函数，属实是一石二鸟的美事。</p>
<p>把<span style="color:#4da8ee;"> tmp </span>压榨的干干净净，还让 <span style="color:#4da8ee;">tmp</span> 帮忙把屁股擦干净（释放空间）。</p>
<p></p>
<p>⚡ 还有更简洁的写法：</p>
<pre><code class="language-cpp">/* 赋值重载：s1 = s3 */
string&amp; operator=(string s) {
	swap(_str, s._str);
	return *this;
}</code></pre>
<p>和上面的写法本质是一样的。这种写法不用引用传参，它利用了拷贝构造。</p>
<p>这里的形参<span style="color:#0d0016;"> s</span> 就充当了<span style="color:#0d0016;"> tmp</span>，<span style="color:#0d0016;">s</span> 就是<span style="color:#0d0016;"> </span><span style="color:#4da8ee;">s3</span> 的拷贝，再把<span style="color:#0d0016;"> s1 </span>和 <span style="color:#0d0016;">s </span>交换。简直是物尽其用！</p>
<p></p>
<p>📌 注意：但是这种写法也有小缺点，可能会导致自己给自己赋值时地址被换。</p>
<p>你会发现我们这里没有加个<span style="color:#956fe7;"> if</span> 去判断自己给自己赋值的问题了。</p>
<p>因为这里没办法判断自己给自己赋值了。之前 <span style="color:#0d0016;">s </span>就是 <span style="color:#4da8ee;">s3</span>，<span style="color:#956fe7;">this </span>就是<span style="color:#4da8ee;"> s1</span>。</p>
<p>现在<span style="color:#956fe7;"> this </span>还是<span style="color:#4da8ee;"> s1</span>，但是 <span style="color:#0d0016;">s</span> 已经不是<span style="color:#4da8ee;"> s3 </span>了，所以判断不到自己</p>
<pre><code class="language-cpp">if (this != &amp;s)   ？？？？？？
     👆      👆
     s1      s1</code></pre>
<p><img alt="" height="46" src="image\eedccf94614a472bb7c72a9487f3b515.png" width="52"/> 所以这里加上 <span style="color:#956fe7;">if</span> 判断也没用。但是其实也没太大问题，谁会自己给自己赋值啊。</p>
<p></p>
<h3 id="0x03%20%E6%95%B4%E4%BD%93%E4%BB%A3%E7%A0%81%E6%94%B9%E8%BF%9B">0x03 整体代码改进</h3>
<p>我们现在再去考虑 <span style="color:#0d0016;">_size </span>和 <span style="color:#0d0016;">_capacity</span>，我们来把之前写的传统写法都改成现代写法。</p>
<p>💬 拷贝构造函数：s2(s1)</p>
<pre><code class="language-cpp">/* 拷贝构造函数：s2(s1) */
string(const string&amp; s)
	: _str(nullptr)        // 为tmp置空做准备
	, _size(0)
	, _capacity(0)
{
	string tmp(s._str);

	swap(_str, tmp._str);
	swap(_size, tmp._size);
	swap(_capacity, tmp._capacity);
}

</code></pre>
<p></p>
<p>💬 赋值重载函数：s1 = s3</p>
<pre><code class="language-cpp">/* 赋值重载：s1 = s3 */
string&amp; operator=(string s) {
	swap(_str, s._str);
	swap(_size, s._size);
	swap(_capacity, s._capacity);

	return *this;
}</code></pre>
<p>这里也是进行交换的，真是跟<span style="color:#0d0016;"> tmp</span> 交换改成了跟 <span style="color:#0d0016;">s</span> 交换。</p>
<p>我们不如写一个 <span style="color:#4da8ee;">Swap</span> 函数：</p>
<pre><code class="language-cpp">void Swap(string&amp; s) {
	swap(_str, s._str);
	swap(_size, s._size);
	swap(_capacity, s._capacity);
}</code></pre>
<p></p>
<p>这样就很简单了 ——</p>
<pre><code class="language-cpp">/* 拷贝构造函数：s2(s1) */
string(const string&amp; s)
	: _str(nullptr)        // 为tmp置空做准备
	, _size(0)
	, _capacity(0)
{
	string tmp(s._str);
	Swap(tmp);             // this-&gt;Swap(tmp);
}

/* 赋值重载：s1 = s3 */
string&amp; operator=(string s) {
	Swap(s);
	return *this;
}</code></pre>
<p></p>
<h3 id="0x04%20%E6%80%BB%E7%BB%93">0x04 总结</h3>
<p><img alt="" height="47" src="image\3935c44138fe460d8b6835369a4bde0f.png" width="58"/> 现代写法在 string 中体现的优势还不够大，因为好像和传统写法差不多。</p>
<p> 但是到后面我们实现 vector、list 的时候，你会发现现代写法的优势真的是太大了。</p>
<p>现代写法写起来会更简单些，比如如果是个链表，传统写法就不是 <span style="color:#956fe7;">strcpy</span> 这么简单的了，</p>
<p>你还要一个一个结点拷贝过去，但是现代写法只需要调用 <span style="color:#956fe7;">swap </span>交换一下就可以了。</p>
<p>现代写法更加简洁，只是在<span style="color:#956fe7;"> string</span> 这里优势体现的不明显罢了，我们后面可以慢慢体会。<br/>  </p>
<p></p>
<h2 id="%E2%85%A5.%20operator%20%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">Ⅵ. operator 运算符重载</h2>
<h3>0x00 引入</h3>
<p>学日期类的时候我们就说过，我们只需实现 &lt; 和 ==，剩下的都可以复用解决。</p>
<p></p>
<h3 id="0x00%20operator%3C">0x00 operator&lt;</h3>
<p>💬 我们在全局实现：</p>
<pre><code class="language-cpp">/* s1 &lt; s2*/
bool operator&lt;(const string&amp; s1, const string&amp; s2) {
	size_t i1 = 0, i2 = 0;
	while (i1 &lt; s1.size() &amp;&amp; i1 &lt; s2.size()) {
		if (s1[i1] &lt; s2[i2]) {
			return true;
		} 
		else if (s1[i1] &gt; s2[i2]) {
			return false;
		}
		else {
			i1++;
			i2++;
		}
	}
	return i2 &lt; s2.size() ? true : false;
}</code></pre>
<p>当然，我们还可以实现的更简单些，直接用 <span style="color:#ad720d;">strcmp</span> 偷个懒：</p>
<pre><code class="language-cpp">/* s1 &lt; s2*/
bool operator&lt;(const string&amp; s1, const string&amp; s2) {
	return strcmp(s1.c_str(), s2.c_str()) &lt; 0;
}</code></pre>
<p></p>
<h3 id="0x01%20operator%3D">0x01 operator=</h3>
<p>💬 全局作用域下：</p>
<pre><code class="language-cpp">/* s1 == s2 */
bool operator==(const string&amp; s1, const string&amp; s2) {
	return strcmp(s1.c_str(), s2.c_str()) == 0;
}</code></pre>
<p></p>
<h3 id="0x02%20%E5%89%A9%E4%B8%8B%E7%9A%84%E7%9B%B4%E6%8E%A5%E5%A4%8D%E7%94%A8">0x02 剩下的直接复用</h3>
<p>💬<span style="color:#956fe7;"> operator&lt;=</span></p>
<pre><code class="language-cpp">	/* s1 &lt;= s2 */
	bool operator&lt;=(const string&amp; s1, const string&amp; s2) {
		return s1 &lt; s2 || s1 == s2;
	}
</code></pre>
<p></p>
<p>💬 <span style="color:#956fe7;">operator&gt;</span></p>
<pre><code class="language-cpp">    /* s1 &gt; s2 */
	bool operator&gt;(const string&amp; s1, const string&amp; s2) {
		return !(s1 &lt;= s2);
	}</code></pre>
<p></p>
<p>💬 <span style="color:#956fe7;">operator&gt;=</span></p>
<pre><code class="language-cpp">	/* s1 &gt;= s2 */
	bool operator&gt;=(const string&amp; s1, const string&amp; s2) {
		return !(s1 &lt; s2);
	}</code></pre>
<p></p>
<p>💬 <span style="color:#956fe7;">operator!=</span></p>
<pre><code class="language-cpp">	/* s1 != s2 */
	bool operator!=(const string&amp; s1, const string&amp; s2) {
		return !(s1 == s2);
	}
</code></pre>
<p></p>
<p></p>
<h2 id="%E2%85%A6.%C2%A0%20%E6%B5%81%E6%8F%92%E5%85%A5%E5%92%8C%E6%B5%81%E6%8F%90%E5%8F%96">Ⅶ.  流插入和流提取</h2>
<h3>0x00 引入</h3>
<p><img alt="" height="80" src="image\fb7ed51284cf437b840b59b741b408e7.png" width="79"/> 我们当时实现日期类的流插入和流提取时，也详细讲过这些，当时讲解了友元。</p>
<p> 在友元那一章我们说过 "占参问题" ，这里就不再多做解释了。</p>
<p>如需复习猛戳 👇</p>
<p><a href="https://blog.csdn.net/weixin_50502862/article/details/123616212" title="【C++要笑着学】友元 | 初始化列表 | 关键字explicit | 静态成员static | 内部类">【C++要笑着学】友元 | 初始化列表 | 关键字explicit | 静态成员static | 内部类</a></p>
<p></p>
<p>如果我们重载成成员函数，第一个位置就会被隐含的 this 指针占据。</p>
<p>这样实现出来的流插入必然会不符合我们的使用习惯，所以我们选择在全局实现。</p>
<p>在全局里不存在隐含的<span style="color:#956fe7;"> this</span> 指针了。</p>
<p></p>
<h3 id="0x01%20%E5%AE%9E%E7%8E%B0%20operator%3C%3C">0x01 operator&lt;&lt; 的实现</h3>
<p>💬 <span style="color:#956fe7;">operator&lt;&lt;</span></p>
<pre><code class="language-cpp">// cout &lt;&lt; s1  →  operator&lt;&lt;(cout, s1)
ostream&amp; operator&lt;&lt;(ostream&amp; out, const string&amp; s) {
	//for (auto ch : s) {
	//	out &lt;&lt; ch;
	//}

	for (size_t i = 0; i &lt; s.size(); i++) {
		out &lt;&lt; s[i];
	}

	return out;
}</code></pre>
<p></p>
<h3 id="0x02%20%E5%AE%9E%E7%8E%B0%20operator%3E%3E">0x02 operator&gt;&gt; 的实现</h3>
<p>💬 <span style="color:#956fe7;">operator&gt;&gt;</span></p>
<pre><code class="language-cpp">// cin &gt;&gt;
istream&amp; operator&lt;&lt;(istream&amp; in, string&amp; s) {
	char ch = in.get();
	while (ch == '\n') {
		s += ch;
		ch = in.get();
	}

	return in;
}</code></pre>
<p></p>
<h2 id="%E2%85%A7.%C2%A0%20%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81">Ⅷ.  完整代码</h2>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;assert.h&gt;
using namespace std;

namespace chaos
{
	class string {
	public:
		/* 构造函数 */
		string(const char* str = "")
			: _size(strlen(str))        // 计算出字符串str的大小
			, _capacity(_size) {        // 初始容量等于字符串大小

			_str = new char[_capacity + 1];   // 开辟一块 "容量+1" 大小的空间 (_capacity存的是有效字符）
			strcpy(_str, str);                // 将传入的字符串str复制到 _str中
		}

		void Swap(string&amp; tmp) {
			swap(_str, tmp._str);
			swap(_size, tmp._size);
			swap(_capacity, tmp._capacity);
		}

		/* 拷贝构造函数：s2(s1) 
		string(const string&amp; src)
			: _size(src._size)                // 拷贝string大小
			, _capacity(src._capacity) {      // 拷贝string容量

			// 拷贝string内容
			_str = new char[src._capacity + 1];        // 开辟一块和src相同容量的空间
			strcpy(_str, src._str);					   // 将src中的_str内容拷贝到自己的_str中
		}
		*/
		string(const string&amp; src)
			: _str(nullptr)
			, _size(0)
			, _capacity(0) {

			string tmp(src._str);   // 拷贝构造一个src
			Swap(tmp);              // 现代写法：交换
		}
	

		/* 赋值重载：s1 = s3
		string&amp; operator=(const string&amp; src) {
			// 防止自己跟自己赋值
			if (this != &amp;src) {
				// 1. 暂时用tmp开辟一块相同的空间
				char* tmp = new char[src._capacity + 1];
				// 2. 把src的值复制给tmp
				strcpy(tmp, src._str);
				// 3. 释放this原空间
				delete[] _str;
				// 4. 没翻车，把tmp交付给_src
				_str = tmp;

				_size = src._size;
				_capacity = src._capacity;
			}
			return *this;
		}

		string&amp; operator=(const string&amp; src) {
			// 防止自己跟自己赋值
			if (this != &amp;src) {
				string tmp(src);   // 复用拷贝构造
				Swap(tmp);
			}
			return *this;
		}
		*/
		string&amp; operator=(string src) {
			Swap(src);    // 正好调用拷贝构造，不如让形参充当tmp
			return *this;
		}


		/* 返回C格式的字符串：c_str */
		const char* c_str() const {
			return _str;
		}

		/* 求字符串大小：size() */
		size_t size() const {
			return _size;
		}

		/* operator[] */
		char&amp; operator[](size_t pos) {
			assert(pos &lt; _size);
			return _str[pos];  // 返回字符串对应下标位置的元素
		}
		const char&amp; operator[](size_t pos) const {
			assert(pos &lt; _size);
			return _str[pos];
		}

		/* 迭代器 */
		typedef char* iterator;
		iterator begin() { 
			return _str;            // 返回第一个字符的位置
		}
		iterator end() {
			return _str + _size;    // 返回最后一个字符的位置
		}

		/* const迭代器 */
		typedef const char* const_iterator;
		const_iterator begin() const {
			return _str;
		}
		const_iterator end() const {
			return _str + _size;
		}

		/* reserve() */
		void reserve(size_t new_capacity) {
			if (new_capacity &gt; _capacity) {               // 检查是否真的需要扩容
				char* tmp = new char[new_capacity + 1];   // 开空间
				strcpy(tmp, _str);						  // 先搬运数据到tmp

				_str = tmp;								  // 没翻车，递交给_str
				_capacity = new_capacity;				  // 更新容量
			}
		}

		/* 字符尾插：push_back() */
		void push_back(char append_ch) {
			/*
			if (_size == _capacity) {                         // 检查是否需要扩容
				reserve(_capacity == 0 ? 4 : _capacity * 2);  // 首次给4，其他情况默认扩2倍
			}

			_str[_size] = append_ch;     // 插入要追加的字符
			_size++;						 
			_str[_size] = '\0';	         // 手动添加'\0'
			*/

			insert(_size, append_ch);
		}

		/* 字符串追加：append() */
		void append(const char* append_str) {
			/*
			size_t len = strlen(append_str);      // 计算出要追加的字符串的长度
			if (_size + len &gt; _capacity) {		  // 检查是否需要扩容
				reserve(_size + len);
			}

			strcpy(_str + _size, append_str);      // 首字符+大小，就是'\0'位置
			_size += len;						   // 更新大小
			*/
			
			insert(_size, append_str);
		}

		/* operator+= */
		string&amp; operator+=(char append_ch) {
			push_back(append_ch);
			return *this;
		}
		string&amp; operator+=(const char* append_str) {
			append(append_str);
			return *this;
		}

		/* insert */
		string&amp; insert(size_t pos, char append_ch) {
			assert(pos &lt;= _size);

			if (_size == _capacity) {		// 检查是否需要扩容
				reserve(_capacity == 0 ? 4 : _capacity * 2);
			}

			// 向后挪动数据
			size_t end = _size + 1;
			while (end &gt; pos) {
				_str[end] = _str[end - 1];
				end--;
			}

			// 插入
			_str[pos] = append_ch;
			_size++;

			return *this;
		}
		string&amp; insert(size_t pos, const char* append_str) {
			assert(pos &lt;= _size);
			size_t len = strlen(append_str);

			if (_size + len &gt; _capacity) {    // 检查是否需要增容
				reserve(_size + len);
			}

			// 向后挪动数据
			size_t end = _size + len;
			while (end &gt; pos + len - 1) {
				_str[end] = _str[end - len];
				end--;
			}

			// 插入
			strncpy(_str + pos, append_str, len);
			_size += len;

			return *this;
		}

		/* resize */
		void resize(size_t new_capacity, char init_ch = '\0') {
			// 如果欲增容量比_size小
			if (new_capacity &lt;= _size) {
				_str[new_capacity] = '\0';      // 拿斜杠零去截断
				_size = new_capacity;           // 更新大小
			}
			// 欲增容量比_size大
			else {
				if (new_capacity &gt; _capacity) {
					reserve(new_capacity);
				}
				// 起始位置，初始化字符，初始化个数
				memset(_str + _size, init_ch, new_capacity - _size);
				_size = _capacity;
				_str[_size] = '\0';
			}
		}

		/* find */
		size_t find(char aim_ch) {
			for (size_t i = 0; i &lt; _size; i++) {
				if (aim_ch == _str[i]) {
					// 找到了
					return i;    // 返回下标
				}
			}
			// 找不到
			return npos;
		}
		size_t find(const char* aim_str, size_t pos = 0) {
			const char* ptr = strstr(_str + pos, aim_str);
			if (ptr == nullptr) {
				return npos;
			}
			else {
				return ptr - _str;  // 减开头
			}
		}

		/* 删除：erase */
		string&amp; erase(size_t pos, size_t len = npos) {
			assert(pos &lt; _size);

			if (len == pos || pos + len &gt;= _size) {
				_str[pos] = '\0';    // 放置\0截断
				_size = pos;
			}
			else {
				strcpy(_str + pos, _str + pos + len);
				_size -= len;
			}

			return *this;
		}

		/* 析构函数 */
		~string() {
			if (_str != nullptr) {
				delete[] _str;
				_str = nullptr;
			}
			_size = _capacity = 0;
		}

	private:
		/* 成员变量 */
		char* _str;
		size_t _size;
		size_t _capacity;

	public:
		static const size_t npos;
	};

	/* 初始化npos */
	const size_t string::npos = -1;   // 无符号整型的-1，即整型最大值

	/* s1 &lt; s2*/
	bool operator&lt;(const string&amp; s1, const string&amp; s2) {
		/*
		size_t i1 = 0, i2 = 0;
		while (i1 &lt; s1.size() &amp;&amp; i1 &lt; s2.size()) {
			if (s1[i1] &lt; s2[i2]) {
				return true;
			}
			else if (s1[i1] &gt; s2[i2]) {
				return false;
			}
			else {
				i1++;
				i2++;
			}
		}
		return i2 &lt; s2.size() ? true : false;
		*/

		return strcmp(s1.c_str(), s2.c_str()) &lt; 0;
	}

	/* s1 == s2 */
	bool operator==(const string&amp; s1, const string&amp; s2) {
		return strcmp(s1.c_str(), s2.c_str()) == 0;
	}

	/* s1 &lt;= s2 */
	bool operator&lt;=(const string&amp; s1, const string&amp; s2) {
		return s1 &lt; s2 || s1 == s2;
	}

	/* s1 &gt; s2 */
	bool operator&gt;(const string&amp; s1, const string&amp; s2) {
		return !(s1 &lt;= s2);
	}

	/* s1 &gt;= s2 */
	bool operator&gt;=(const string&amp; s1, const string&amp; s2) {
		return !(s1 &lt; s2);
	}


	/* s1 != s2 */
	bool operator!=(const string&amp; s1, const string&amp; s2) {
		return !(s1 == s2);
	}

	// cout &lt;&lt; s1  →  operator&lt;&lt;(cout, s1)
	ostream&amp; operator&lt;&lt;(ostream&amp; out, const string&amp; s) {
		/*
		for (auto ch : s) {
			out &lt;&lt; ch;
		}
		*/

		for (size_t i = 0; i &lt; s.size(); i++) {
			out &lt;&lt; s[i];
		}

		return out;
	}

	// cin &gt;&gt;
	istream&amp; operator&lt;&lt;(istream&amp; in, string&amp; s) {
		char ch = in.get();
		while (ch == '\n') {
			s += ch;
			ch = in.get();
		}

		return in;
	}



	/* 测试用 */
	void test_string1() {
		string s1("hello world");
		string s2(s1);
		cout &lt;&lt; s1.c_str() &lt;&lt; endl;
		cout &lt;&lt; s2.c_str() &lt;&lt; endl;

		string s3("pig");
		cout &lt;&lt; s3.c_str() &lt;&lt; endl;

		s1 = s3;
		cout &lt;&lt; s1.c_str() &lt;&lt; endl;
	}

	void test_string2() {
		string s1("hello world");
		string s2;

		for (size_t i = 0; i &lt; s1.size(); i++) {
			cout &lt;&lt; s1[i] &lt;&lt; " ";
		}
		cout &lt;&lt; endl;
	}

	void test_string3() {
		string s1("hello world");
		string s2;

		s1[0] = 'F';
		for (size_t i = 0; i &lt; s1.size(); i++) {
			cout &lt;&lt; s1[i] &lt;&lt; " ";
		}
		cout &lt;&lt; endl;
	}

	void test_string4() {
		string s1("hello world");

		// 迭代器写
		string::iterator it = s1.begin();
		while (it != s1.end()) {
			*it += 1;
			it++;
		}

		// 迭代器读
		it = s1.begin();   // 重置起点
		while (it != s1.end()) {
			cout &lt;&lt; *it &lt;&lt; " ";
			it++;
		}
	}

	void test_string5() {
		string s1("hello world");
		cout &lt;&lt; s1.c_str() &lt;&lt; endl;

		s1.push_back('!');
		cout &lt;&lt; s1.c_str() &lt;&lt; endl;

		s1.push_back('A');
		cout &lt;&lt; s1.c_str() &lt;&lt; endl;
	}

	void test_string6() {
		string s1("hello world");
		cout &lt;&lt; s1.c_str() &lt;&lt; endl;

		s1 += '!';
		cout &lt;&lt; s1.c_str() &lt;&lt; endl;

		s1 += "this is new data";
		cout &lt;&lt; s1.c_str() &lt;&lt; endl;
	}

	void test_string7() {
		string s1("hello world");
		cout &lt;&lt; s1.c_str() &lt;&lt; endl;

		s1.insert(0, 'X');
		cout &lt;&lt; s1.c_str() &lt;&lt; endl;

		s1.insert(0, "hahahaha");
		cout &lt;&lt; s1.c_str() &lt;&lt; endl;
	}

	void test_string8() {
		string s1("hello world");
		cout &lt;&lt; s1.c_str() &lt;&lt; endl;

		s1.erase(5, 2);   // 从第五个位置开始，删两个字符
		cout &lt;&lt; s1.c_str() &lt;&lt; endl;

		s1.erase(5, 20);  // 从第五个位置开始，删完
		cout &lt;&lt; s1.c_str() &lt;&lt; endl;

	}
}

</code></pre>
<p></p>
<p></p>
<hr/>
<p style="text-align:right;"><strong>📜 参考资料</strong></p>
<p style="text-align:right;"><span style="color:#a5a5a5;">Microsoft. MSDN(Microsoft Developer Network)[EB/OL]. []. .</span></p>
<p style="text-align:right;"><span style="color:#a5a5a5;">. C++reference[EB/OL]. []. http://www.cplusplus.com/reference/.</span></p>
<p style="text-align:right;"><span style="color:#a5a5a5;">百度百科[EB/OL]. []. https://baike.baidu.com/.</span></p>
<p style="text-align:right;"><span style="color:#a5a5a5;">比特科技. C++[EB/OL]. 2021[2021.8.31]. .</span></p>
<blockquote>
<p>📌<strong> [ 笔者 ]   </strong>王亦优</p>
<p>📃<strong> [ 更新 ]   </strong>2022.5.6</p>
<p>❌<strong> [ 勘误 ] </strong>  /* 暂无 */</p>
<p>📜<strong> [ 声明 ]</strong>   由于作者水平有限，本文有错误和不准确之处在所难免，本人也很想知道这些错误，恳望读者批评指正！</p>
</blockquote>
<p>本章完。</p>
</div>
</div>