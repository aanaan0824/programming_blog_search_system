<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<p style="text-align:center;"><img alt="" src="https://img-blog.csdnimg.cn/863ec7b6d72947baaeae544d53cf682e.gif"/></p>
<p></p>
<blockquote>
<p><img alt="" height="16" src="image\cb2be72a3c2b4b59b1128abf613b8abe.png" width="16"/>专栏简介 :<span style="color:#fe2c24;">java语法及数据结构</span></p>
<p><img alt="" height="16" src="image\1254c5b119a44cf0ae350489fb7736ad.png" width="16"/>题目来源:<span style="color:#38d8f0;">leetcode,牛客,剑指offer</span></p>
<p><img alt="" height="16" src="image\4366a93aaa3142b5a0f16c7a2200339b.png" width="16"/>创作目标:<span style="color:#a2e043;">从java语法角度实现底层相关数据结构,达到手撕各类题目的水平</span>.</p>
<p><img alt="" height="15" src="image\52a3437a932f4621b25533c330f7c6cb.png" width="15"/><span style="color:#956fe7;">希望在提升自己的同时,帮助他人,与大家一起共同进步,互相成长.</span></p>
<p><img alt="" height="15" src="image\14aa2f0648ae44a299b8f9832af57d2c.png" width="15"/><span style="color:#fe2c24;">学历代表过去,能力代表现在,学习能力代表未来!</span></p>
</blockquote>
<hr/>
<blockquote>
<h1 id="%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B"><a id="_7"></a></h1>
<p id="main-toc"><strong>目录</strong></p>
<p id="%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B-toc" style="margin-left:0px;"></p>
<p id="%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#%E5%89%8D%E8%A8%80">前言</a></p>
<p id="%E4%B8%80.%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><a href="#%E4%B8%80.%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%AE%9E%E7%8E%B0">一.栈的定义与实现</a></p>
<p id="1)%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89%3A-toc" style="margin-left:40px;"><a href="#1%29%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89%3A">1)栈的定义:</a></p>
<p id="%C2%A02)%E6%A0%88%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95%3A-toc" style="margin-left:40px;"><a href="#%C2%A02%29%E6%A0%88%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95%3A"> 2)栈常见操作方法:</a></p>
<p id="%C2%A03)%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0%3A-toc" style="margin-left:40px;"><a href="#%C2%A03%29%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0%3A"> 3)栈的实现:</a></p>
<p id="%E4%BA%8C.%E6%A0%88%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE-toc" style="margin-left:0px;"><a href="#%E4%BA%8C.%E6%A0%88%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE">二.栈相关题目</a></p>
<p id="1)%E9%80%86%E6%B3%A2%E5%85%B0%E6%95%B0-toc" style="margin-left:40px;"><a href="#1%29%E9%80%86%E6%B3%A2%E5%85%B0%E6%95%B0">1)逆波兰数</a></p>
<p id="2)%E4%B8%8D%E5%8F%AF%E8%83%BD%E7%9A%84%E5%85%A5%E6%A0%88%E6%96%B9%E5%BC%8F-toc" style="margin-left:40px;"><a href="#2%29%E4%B8%8D%E5%8F%AF%E8%83%BD%E7%9A%84%E5%85%A5%E6%A0%88%E6%96%B9%E5%BC%8F">2)不可能的入栈方式</a></p>
<p id="3)%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7-toc" style="margin-left:40px;"><a href="#3%29%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7">3)有效括号</a></p>
<p id="4)%E6%9C%80%E5%B0%8F%E6%A0%88-toc" style="margin-left:40px;"><a href="#4%29%E6%9C%80%E5%B0%8F%E6%A0%88">4)最小栈</a></p>
<p id="%E4%B8%89.%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><a href="#%E4%B8%89.%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0">三.队列的实现</a></p>
<p id="1)%E5%8D%95%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97-toc" style="margin-left:40px;"><a href="#1%29%E5%8D%95%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97">1)单链表实现队列</a></p>
<p id="2)%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97-toc" style="margin-left:40px;"><a href="#2%29%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97">2)循环队列</a></p>
<p id="%E5%9B%9B.%E9%98%9F%E5%88%97%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE-toc" style="margin-left:0px;"><a href="#%E5%9B%9B.%E9%98%9F%E5%88%97%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE">四.队列相关题目</a></p>
<p id="1)%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%C2%A0-toc" style="margin-left:40px;"><a href="#1%29%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%C2%A0">1)用栈实现队列 </a></p>
<p id="2)%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88-toc" style="margin-left:40px;"><a href="#2%29%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88">2)用队列实现栈</a></p>
<p id="-toc" style="margin-left:0px;"></p>
<p id="%E6%80%BB%E7%BB%93-toc" style="margin-left:0px;"><a href="#%E6%80%BB%E7%BB%93">总结</a></p>
<hr id="hr-toc"/>
<p></p>
</blockquote>
<p></p>
<h1 id="%E5%89%8D%E8%A8%80">前言</h1>
<blockquote>
<p>        Hello!大家好!我是Node_Hao,今天给大家带来的是<span style="color:#fe2c24;">栈和队列的底层实现及其构造方法</span>,旨在<span style="color:#38d8f0;">熟练掌握栈和队列的使用以后,可以手撕各类栈相关的题目</span>.希望我的文章能对你有所帮助与启发!</p>
</blockquote>
<hr/>
<h1 id="%E4%B8%80.%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%AE%9E%E7%8E%B0">一.栈的定义与实现</h1>
<h2 id="1)%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89%3A">1)栈的定义:</h2>
<blockquote>
<p>      栈是一种数据结构特点是"<span style="color:#fe2c24;">先进后出</span>",基于这一特点栈<span style="color:#38d8f0;">不管是push()(压入元素)还是pop()(弹出栈顶元素),时间复杂度都是O(1)</span>.而java虚拟机栈只是JVM中的一块内存,用来存放局部变量..... 调用函数时我们会在java虚拟机栈中开辟一块内存叫栈帧.</p>
</blockquote>
<p> <img alt="" height="643" src="image\412cb90433e346fbbb006c434bebd35a.png" width="1200"/></p>
<p>  </p>
<h2 id="%C2%A02)%E6%A0%88%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95%3A"> <strong>2)栈常见操作方法:</strong></h2>
<blockquote>
<p>1.stack.empty().判断栈是否为空,为空就返回false,否则返回true.</p>
<p>2.stack.push().将元素压入栈底.</p>
<p>3.stack.pop().将栈顶元素弹出栈.</p>
<p>4.satck.peek().peek有窥视的意思,顾名思义作用就是查看栈顶元素,但不弹出.</p>
</blockquote>
<h2 id="%C2%A03)%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0%3A"> 3)栈的实现:</h2>
<blockquote>
<p>        栈的底层实现既可以用顺序表也可以使用双向链表,二者实现方式大同小异,而我们使用的是<span style="color:#fe2c24;">顺序表</span>.基本配置只需要<span style="color:#38d8f0;">一个数组来存放元素和一个usedSize记录顺序表元素的个数</span>.构造方法初始化时我们可以将栈的大小初始化为5,后续不够再扩容.扩容使用<span style="color:#38d8f0;">Arrays.copyof()</span>方法.</p>
</blockquote>
<p></p>
<pre><code class="language-java">class My_stack{
    int[] elem;
    int usedSize;

    public My_stack(int[] elem, int usedSize) {
        this.elem = new int[5];
        this.usedSize = usedSize;
    }
    public void push(int val){
        if (usedSize==elem.length){//如果满了就扩容
            Arrays.copyOf(elem,elem.length*2);
        }
        elem[usedSize] = val;
        usedSize++;
    }
    public int pop(){
        if (isEmpty()){
            throw new RuntimeException("栈为空");
        }
        return elem[usedSize--];
    }
    public int peek(){
        if (isEmpty()){
            throw new RuntimeException("栈为空");
        }
        return elem[usedSize-1];
    }
    public boolean isEmpty(){
        return usedSize==0;
    }
}</code></pre>
<p></p>
<h1 id="%E4%BA%8C.%E6%A0%88%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE">二.栈相关题目</h1>
<h2 id="1)%E9%80%86%E6%B3%A2%E5%85%B0%E6%95%B0">1)逆波兰数</h2>
<p><img alt="" height="696" src="image\676b1bc719e440be9ca6d468c8398044.png" width="1200"/></p>
<blockquote>
<p>        <span style="color:#fe2c24;">逆波兰数</span>也叫<span style="color:#38d8f0;">后缀表达式</span>,早年计算机并没有用括号来规定四则运算的计算顺序,那么如果计算9+(3-1)x3+10/2总不能直接输9+3-1x3+10/2吧,于是睿智的科学家通过栈解决了这个难题,<span style="color:#38d8f0;">栈中存放的只能是数字,所以只要遇到数字就压栈,遇到运算符号就从栈顶弹出两个数字,最顶部的在操作符右边,下一个在操作符左边,运算完后将结果压栈,继续重复上述操作.</span></p>
</blockquote>
<blockquote>
<p>        在此题的基础上我们拓展<span style="color:#fe2c24;">中缀表达式转后缀表达式</span>,首先按<span style="color:#38d8f0;">四则运算的优先级给表达式加上相应的括号((9+((3-1)x3))+(10/2))然后将每个括号中对应的操作符移到该括号之外</span>:</p>
<p>(((9((31)-3)x)+)10 2)/)+去掉括号后得:931-3x+102/+.</p>
</blockquote>
<p> <img alt="" height="791" src="image\3622142a7ed34154bdc769470151fef8.png" width="1200"/></p>
<pre><code class="language-java">class Solution {
    public int evalRPN(String[] tokens) {
        Stack&lt;Integer&gt; str = new Stack&lt;&gt;();
        for(int i = 0;i&lt;tokens.length;i++){
            String s = tokens[i];
            if(!isoperation(s)){
                str.push(Integer.parseInt(s));//将数字压栈
            }else{
                int num2 = str.pop();
                int num1 = str.pop();
                switch(s){
                    case "+":
                        str.push(num1+num2);
                        break;
                     case "-":
                        str.push(num1-num2);
                        break;
                     case "*":
                        str.push(num1*num2);
                        break;
                    case "/":
                        str.push(num1/num2);
                        break;
                }
            }
        }
        return str.pop();
    }
    public boolean isoperation(String s){
        if(s.equals("+")||s.equals("-")||s.equals("*")||s.equals("/")){
            return true;
        }
        return false;
    }
}</code></pre>
<p></p>
<h2 id="2)%E4%B8%8D%E5%8F%AF%E8%83%BD%E7%9A%84%E5%85%A5%E6%A0%88%E6%96%B9%E5%BC%8F">2)不可能的入栈方式</h2>
<p><img alt="" height="673" src="image\5758bca9fb204bce835fcf2265e26951.png" width="1200"/></p>
<blockquote>
<p>         根据栈"先进后出"的原理我们可以将<span style="color:#38d8f0;">pushed数组,每压入一个元素就与popped数组的栈顶元素相比较</span>,<span style="color:#fe2c24;">如果相同就弹出压入数组的元素</span>,<span style="color:#38d8f0;">然后访问popped数组的下一个元素继续比较.</span><span style="color:#fe2c24;">如果不相同</span>,pushed数组继续压栈,重复上述操作.当<span style="color:#fe2c24;">pushed数组全部压入后</span>,如果此时栈为空,那么符合出栈方式,如果不为空则不符合.</p>
</blockquote>
<p> <img alt="" height="812" src="image\70ef32df34e5404a83da8450ba8ebd07.png" width="1200"/></p>
<p></p>
<pre><code class="language-java">class Solution {
    public boolean validateStackSequences(int[] pushed, int[] popped) {
        Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();
         int j = 0;
        for(int i = 0;i&lt;pushed.length;i++){
            stack.push(pushed[i]);
            while(!stack.empty()&amp;&amp;i&lt;pushed.length&amp;&amp;stack.peek()==popped[j]){
                stack.pop();
                j++;
            }
        }
        if(!stack.empty()){
            return false;
        }
        return true;
    }
}</code></pre>
<p></p>
<h2 id="3)%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7">3)有效括号</h2>
<p><img alt="" height="633" src="image\4e493e5c6d6943e08b2abf720246fd86.png" width="1200"/></p>
<blockquote>
<p>         通过了解题目大致有四种情况<span style="color:#fe2c24;">,1.左边括号多( ( ( )</span> <span style="color:#38d8f0;">2.右边括号多( ( ) ) ) )</span><span style="color:#a2e043;"> 3.左右括号不匹配{ ) [ }</span> <span style="color:#956fe7;">4.左右括号匹配( ) { }</span> .那么根据栈的特点,我们可以<span style="color:#38d8f0;">遇到左边的括号就压入栈中,遇到右边的括号便和栈顶的元素比较是否匹配,如果不匹配返回false.</span>但要注意两点:1. 如果我们在比较的过程中发现<span style="color:#fe2c24;">栈为空</span>,那么就是<span style="color:#fe2c24;">右边括号多,返回fasle</span>.2.如果我们比较完毕,<span style="color:#fe2c24;">栈不为空</span>,说明<span style="color:#fe2c24;">左边括号多,返回false</span>.如果没有以上情形我们就可以返回true.</p>
</blockquote>
<p> <img alt="" height="654" src="image\181055c84d6849aa8b3e9519a91af14b.png" width="958"/></p>
<p></p>
<pre><code class="language-java">class Solution {
    public boolean isValid(String s) {
        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();
        for(int i = 0;i&lt;s.length();i++){
            char ch = s.charAt(i);
            if(ch=='('||ch=='['||ch=='{'){
                stack.push(ch);
            }else{
                if(stack.empty()){//右边括号多
                    return false;
                }
                char top = stack.peek();
                if((top=='('&amp;&amp;ch==')')||(top=='['&amp;&amp;ch==']')||(top=='{'&amp;&amp;ch=='}')){
                    stack.pop();
                }else{
                    return false;//左右括号不匹配
                }
            }
        }
        if(!stack.empty()){//左面括号多
            return false;
        }
    return true;
    }
}</code></pre>
<p></p>
<h2 id="4)%E6%9C%80%E5%B0%8F%E6%A0%88">4)最小栈</h2>
<p><img alt="" height="913" src="image\7bdba3eccc7b4ff1a90ac6f6ea35c21d.png" width="1200"/></p>
<blockquote>
<p>        要想实现在常数时间内检索到最小元素的栈,那么<span style="color:#fe2c24;">一定不可能一个栈</span>,因为根据栈的特点<span style="color:#38d8f0;">检索元素的时间复杂度必然是O(N),</span>所以如果我们可以把<span style="color:#fe2c24;">栈的最小元素单独保存起来</span>,那么当我们需要时查找最小元素<span style="color:#fe2c24;">时间复杂度必然是O(1)</span>.按照上述思路,首先我们<span style="color:#38d8f0;">创建两个栈</span>,第一个栈中<span style="color:#38d8f0;">存放元素</span>,第二个栈中<span style="color:#38d8f0;">存放最小值</span>.其次压入元素时,<span style="color:#a2e043;">如果是第一次压入,两个栈都压</span>.否则<span style="color:#a2e043;">判断要压入的元素是否小于第二个栈栈顶的元素</span>,如果<span style="color:#38d8f0;">小于就压入第二个栈,否则就不压入</span>.重复上述操作,无论任何时候我们都能按<span style="color:#fe2c24;">O(1)的时间复杂度取出第二个栈栈顶的元素</span>,也就是最小的元素.</p>
</blockquote>
<p><img alt="" height="717" src="image\b9e0d44603b9411f9b65eb7c764daf67.png" width="1173"/></p>
<p></p>
<pre><code class="language-java">class MinStack {
    public Stack&lt;Integer&gt; stack1;
    public Stack&lt;Integer&gt; stack2;
    public MinStack() {
        stack1 = new Stack&lt;Integer&gt;();
        stack2 = new Stack&lt;Integer&gt;();
    }

    public void push(int val) {
        stack1.push(val);
        if (stack2.empty()){
            stack2.push(val);
        }else {
            if(val&lt;=stack2.peek()){
                stack2.push(val);
            }
        }
    }

    public void pop() {
        int popVal = stack1.pop();
       if(!stack2.empty()){
           int top = stack2.peek();
           if(top==popVal){
               stack2.pop();
           }
       }
    }

    public int top() {
        return stack1.peek();
    }

    public int getMin() {
        return stack2.peek();
    }
}</code></pre>
<p></p>
<h1 id="%E4%B8%89.%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0">三.队列的实现</h1>
<blockquote>
<p>        <span style="color:#fe2c24;">队列是只允许在一端进行插入另一端进行删除的线性表</span>,与栈正好相反.简要概括为:"<span style="color:#fe2c24;">尾进头出</span>",同样队列的实现底层既可以用顺序表也可以用链表.首先我们用单链表来实现,为了使<span style="color:#38d8f0;">入队和出队的时间复杂度都为O(1)</span>,我们需要记录单链表的头结点和尾结点,<span style="color:#38d8f0;">入队时尾插,出队时删除头结点即可.</span></p>
</blockquote>
<p><img alt="" height="419" src="image\8edb8019c1274cc4ae4e539b44525705.png" width="448"/></p>
<p></p>
<h2 id="1)%E5%8D%95%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97">1)单链表实现队列</h2>
<pre><code class="language-java">class Node1{
    public Node1 next;
    public int val;

    public Node1(int val) {
        this.val = val;
    }
}
class My_queue{
    public Node1 head;
    public Node1 last;

    public void offer(int val){//入队
        Node1 node1 = new Node1(val);
        if (head==null){
            head = node1;
            last = node1;
        }else {
            last.next = node1;
            last = last.next;
        }
    }
    public int poll(){//出队
        if (isEmpty()){
            throw new RuntimeException("队列为空");
        }
        int pollVal = head.val;
        head = head.next;
        return pollVal;
    }
    public int peek(){
        if (isEmpty()){
            throw new RuntimeException("队列为空");
        }
        return head.val;
    }
    public boolean isEmpty(){
        return head==null;
    }

}</code></pre>
<p></p>
<h2 id="2)%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97">2)循环队列</h2>
<blockquote>
<p>        循环队列的底层为顺序表,为了使<span style="color:#38d8f0;">出队和入队的时间复杂度都是O(1)</span>,我们必须<span style="color:#fe2c24;">记录顺序表元素的首尾</span>,<span style="color:#a2e043;">rear为队尾控制元素入队</span>,<span style="color:#a2e043;">front为队首控制元素出队</span>. 为了使顺序表达到循环的效果,我们需要借助公式<span style="color:#fe2c24;">(rear+1)%elem.length</span>,<span style="color:#956fe7;">front</span>也同样借助这个公式.基于顺序表的特点,删除元素时只需后移front,增加元素只需在rear下标增加元素,之后后移rear即可.</p>
</blockquote>
<p><img alt="" height="761" src="image\67a12a715137432183929498e7b0b592.png" width="1200"/></p>
<p></p>
<pre><code class="language-java">class MyCircularQueue {
 public int elem[];
    public int front;
    public int rear;

    public MyCircularQueue(int k) {
        this.elem = new int[k+1];
    }

    public boolean enQueue(int value) {//入队
        if (isFull()){
            return false;
        }
        this.elem[rear] = value;
        rear = (rear +1)%elem.length;
        return true;
    }

    public boolean deQueue() {//出队
        if (isEmpty()){
            return false;
        }
        front = (front +1)%elem.length;
        return true;
    }

    public int Front() {//获取队头元素
        if (isEmpty()){
            return -1;
        }
        return elem[front];
    }

    public int Rear() {//获取队位元素
        if (isEmpty()){
            return -1;
        }
       if (rear==0){
           return elem[elem.length-1];
       }else {
           return elem[rear-1];
       }
    }

    public boolean isEmpty() {
        return front==rear;
    }

    public boolean isFull() {
        //rear的下一个如果为front
        if ((rear+1)%elem.length==front){
            return true;
        }
        return false;
    }
}</code></pre>
<p></p>
<h1 id="%E5%9B%9B.%E9%98%9F%E5%88%97%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE">四.队列相关题目</h1>
<h2 id="1)%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%C2%A0">1)用栈实现队列 </h2>
<p><img alt="" height="775" src="image\932570751c384aea959cb061586fcd41.png" width="1200"/></p>
<blockquote>
<p>        一个栈必定无法实现队列,那么我们可以考虑<span style="color:#fe2c24;">用两个栈</span>,<span style="color:#38d8f0;">入队时把要入队元素压入stack1中</span>,<span style="color:#a2e043;">出队时先把所有stack1中元素压入stack2中,然后弹出stack2的栈顶元素即可</span>. </p>
</blockquote>
<pre><code class="language-java">class MyQueue {
 public Stack&lt;Integer&gt; stack1;
    public Stack&lt;Integer&gt; stack2;

    public MyQueue() {
        stack1 = new Stack&lt;&gt;();
        stack2 = new Stack&lt;&gt;();
    }

    public void push(int x) {
        stack1.push(x);
    }

    public int pop() {
        if(empty()){
            return -1;
        }
        if(stack2.empty()) {
            int size = stack1.size();
            for (int i = 0; i &lt; size; i++) {
                stack2.push(stack1.pop());
            }
        }
         return stack2.pop();
    }
    public int peek() {
        if(empty()){
            return -1;
        }
        if(stack2.empty()) {
            int size = stack1.size();
            for (int i = 0; i &lt; size; i++) {
                stack2.push(stack1.pop());
            }
        }
         return stack2.peek();
    }

    public boolean empty() {
        return stack1.empty()&amp;&amp;stack2.empty();
    }
}
</code></pre>
<p></p>
<p></p>
<h2 id="2)%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88">2)用队列实现栈</h2>
<p><img alt="" height="859" src="image\58f3ebfcc3704125add454139f11ea0f.png" width="1200"/></p>
<blockquote>
<p>        同样一个队列也无法实现栈,可以考虑使用<span style="color:#fe2c24;">两个队列</span>,<span style="color:#38d8f0;">入队时哪个队列为空入哪个 ,如果都为空就入que1</span>.但是与栈不同的是队列的出队顺序,我们不能把que1中的元素全部放入que2再出que2中的元素,而是移size-1个到que2,出que1.<span style="color:#956fe7;">假设入队都在que1中,那么出队时只需将que1中的size-1个元素移到que2中,然后弹出que1中的元素即可</span>.</p>
</blockquote>
<pre><code class="language-java">class MyStack {

     public Queue&lt;Integer&gt; que1;
    public Queue&lt;Integer&gt; que2;

    public MyStack() {
        que1 = new LinkedList&lt;&gt;();
        que2 = new LinkedList&lt;&gt;();
    }
    public void push(int x) {
        if (!que1.isEmpty()){
            que1.offer(x);
        }else if (!que2.isEmpty()){
            que2.offer(x);
        }else {
            que1.offer(x);
        }
    }

    public int pop() {
        if (empty()){
            return -1;
        }
        if (!que1.isEmpty()){
            int size = que1.size();
            for (int i = 0; i &lt;size-1 ; i++) {
                que2.offer(que1.poll());
            }
            return que1.poll();
        }
        if (!que2.isEmpty()){
            int size = que2.size();
            for (int i = 0; i &lt;size-1 ; i++) {
                que1.offer(que2.poll());
            }
            return que2.poll();
        }
        return -1;
    }

    public int top() {
        if (empty()){
            return -1;
        }
        if (!que1.isEmpty()){
            int size = que1.size();
            int val = -1;
            for (int i = 0; i &lt;size ; i++) {
                val = que1.poll();
                que2.offer(val);
            }
            return val;
        }
        if (!que2.isEmpty()){
            int size = que2.size();
            int val = -1;
            for (int i = 0; i &lt;size ; i++) {
                val = que2.poll();
                que1.offer(val);
            }
            return val;
        }
        return -1;
    }

    public boolean empty() {
        return que1.isEmpty()&amp;&amp;que2.isEmpty();
    }
}
</code></pre>
<p style="text-align:center;"><img alt="" src="image\884c4bc8cefe49808a5a58525be8f62e.jpeg"/></p>
<p></p>
<hr/>
<h1 id="%E6%80%BB%E7%BB%93"><a id="_45"></a>总结</h1>
<blockquote>
<p>        以上就是<span style="color:#fe2c24;">快速入门栈和队列</span>的全部内容了,在了解栈和队列的各种实现并手撕相关习题,相信我们已经熟练掌握了栈和队列,<span style="color:#38d8f0;">如果我的文章对你有亿点点帮助和启发,麻烦不要忘记三连哦!</span></p>
</blockquote>
<p></p>
</div>
</div>