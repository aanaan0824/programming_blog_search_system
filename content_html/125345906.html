<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<p><strong>题目pdf下载</strong>：<a class="link-info" href="http://124.223.62.164/%E7%AC%AC%E5%8D%81%E4%B8%89%E5%B1%8A%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%A4%A7%E8%B5%9B%E8%BD%AF%E4%BB%B6%E8%B5%9B%E5%86%B3%E8%B5%9B_CB.pdf" title="十三届蓝桥杯c++b组2022国赛题目pdf下载">十三届蓝桥杯c++b组2022国赛题目pdf下载</a></p>
<p>G题没有写，J题是暴力的，其他好像都写出来，但是估计还是有错的。</p>
<p id="main-toc"><strong>目录</strong></p>
<p id="%E6%AD%A3%E6%96%87%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E6%AD%A3%E6%96%87%EF%BC%9A">正文：</a></p>
<p id="%E8%AF%95%E9%A2%98%20A%3A%202022-toc" style="margin-left:40px;"><a href="#%E8%AF%95%E9%A2%98%20A%3A%202022">试题 A: 2022</a></p>
<p id="%E8%AF%95%E9%A2%98%20B%3A%20%E9%92%9F%E8%A1%A8-toc" style="margin-left:40px;"><a href="#%E8%AF%95%E9%A2%98%20B%3A%20%E9%92%9F%E8%A1%A8">试题 B: 钟表</a></p>
<p id="%E8%AF%95%E9%A2%98%20C%3A%20%E5%8D%A1%E7%89%8C-toc" style="margin-left:40px;"><a href="#%E8%AF%95%E9%A2%98%20C%3A%20%E5%8D%A1%E7%89%8C">试题 C: 卡牌</a></p>
<p id="%E8%AF%95%E9%A2%98%20D%3A%20%E6%9C%80%E5%A4%A7%E6%95%B0%E5%AD%97-toc" style="margin-left:40px;"><a href="#%E8%AF%95%E9%A2%98%20D%3A%20%E6%9C%80%E5%A4%A7%E6%95%B0%E5%AD%97">试题 D: 最大数字</a></p>
<p id="%E8%AF%95%E9%A2%98%20E%3A%20%E5%87%BA%E5%B7%AE-toc" style="margin-left:40px;"><a href="#%E8%AF%95%E9%A2%98%20E%3A%20%E5%87%BA%E5%B7%AE">试题 E: 出差</a></p>
<p id="%E8%AF%95%E9%A2%98%20F%3A%20%E8%B4%B9%E7%94%A8%E6%8A%A5%E9%94%80-toc" style="margin-left:40px;"><a href="#%E8%AF%95%E9%A2%98%20F%3A%20%E8%B4%B9%E7%94%A8%E6%8A%A5%E9%94%80">试题 F: 费用报销</a></p>
<p id="%E8%AF%95%E9%A2%98%20G%3A%20%E6%95%85%E9%9A%9C-toc" style="margin-left:40px;"><a href="#%E8%AF%95%E9%A2%98%20G%3A%20%E6%95%85%E9%9A%9C">试题 G: 故障</a></p>
<p id="%E8%AF%95%E9%A2%98%20H%3A%20%E6%9C%BA%E6%88%BF-toc" style="margin-left:40px;"><a href="#%E8%AF%95%E9%A2%98%20H%3A%20%E6%9C%BA%E6%88%BF">试题 H: 机房</a></p>
<p id="%E8%AF%95%E9%A2%98%20I%3A%20%E9%BD%BF%E8%BD%AE-toc" style="margin-left:40px;"><a href="#%E8%AF%95%E9%A2%98%20I%3A%20%E9%BD%BF%E8%BD%AE">试题 I: 齿轮</a></p>
<p id="%E8%AF%95%E9%A2%98%20J%3A%20%E6%90%AC%E7%A0%96-toc" style="margin-left:40px;"><a href="#%E8%AF%95%E9%A2%98%20J%3A%20%E6%90%AC%E7%A0%96">试题 J: 搬砖</a></p>
<p id="%E7%BB%93%E5%B0%BE%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E7%BB%93%E5%B0%BE%EF%BC%9A">结尾：</a></p>
<hr id="hr-toc"/>
<p></p>
<h1 id="%E6%AD%A3%E6%96%87%EF%BC%9A">正文：</h1>
<h2 id="%E8%AF%95%E9%A2%98%20A%3A%202022" style="text-align:center;">试题 A: 2022</h2>
<p><img alt="" height="742" src="image\539aef8ddc064c08a24865ed2b7e65d3.png" width="841"/></p>
<p><strong>题意：</strong> 2022分为不同十个不同的正整数的情况数。</p>
<p><strong>思路：</strong><strong>动态规划,我的答案是：379187662194355221</strong>。</p>
<p>        以为挺简单的，但是dfs写完连100都跑不出来，这题难度不简单，估计卡了不少人时间</p>
<p>后面暴力出了答案，从55开始有答案（因为最小的十个不同的正整数是：1,2,3,4...10，和是55），根据前10个数很像<strong>哈代-拉马努金拆分数列</strong>，然后求出来和后面的不一样，而且会炸long long，所以这个数列应该是错的。</p>
<p><img alt="" height="129" src="image\8dc63af453a44b2086933860bacf715e.png" width="1200"/></p>
<p><img alt="" height="142" src="image\936f53b0804f400ea7bc9d1d1a335791.png" width="1200"/></p>
<p><img alt="" height="142" src="image\f9980497d4d24eaaa642158806f7cc87.png" width="1200"/></p>
<p><strong>动态规划思路：</strong></p>
<p>       解释在下面动态规划代码的注释，大致就是dp[2022][10]=dp[1][9]+dp[2][9]+dp[3][9]....+dp[2021][9]的动态规划，用倒叙去实现每个整数只用一次（类似01背包）。</p>
<p><strong>暴力代码：</strong></p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
int a=55;
int ans=0;
void dfs(int d,int sum,int pre){        //d是选的数量，sum是选的和，pre是上次选的点
    if(d==10){
        if(sum==a)
        ans++;
        return;
    }
    for(int i=pre+1;i&lt;=a;i++){
        if(i+sum&lt;=a){
            dfs(d+1,sum+i,i);
        }
    }
}
int main()
{
    dfs(0,0,0);
    cout&lt;&lt;ans&lt;&lt;endl;
    return 0;
}
</code></pre>
<p><strong>动态规划代码：</strong></p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
long long i,j,k,dp[50000][20];
//dp[i][j]表示选j个数总和为i的方案数
int main()
{
    for(i=2022;i&gt;=1;i--)
    {
        //这里i的顺序不影响结果
        for(j=2022;j&gt;=1;j--)
        {
            //为了dp不相互影响这里从大到小dp
            //如果从小到大的话需要再开数组存结果
            for(k=1;k&lt;=9;k++)
            {
                dp[j+i][k+1]+=dp[j][k];
                //对于k个数总和为j的方案dp[j][j];
                //可以选i使得k+1个数总和为j+i
            }
        }
        dp[i][1]=1;//表示选1个数总和为i的方法加1
    }
    for(i=1;i&lt;=100;i++)
    {
        cout&lt;&lt;i&lt;&lt;" "&lt;&lt;dp[i][10]&lt;&lt;endl;
    }
    cout&lt;&lt;dp[2022][10]&lt;&lt;endl;
    return 0;
}
</code></pre>
<hr/>
<p></p>
<p></p>
<p></p>
<h2 id="%E8%AF%95%E9%A2%98%20B%3A%20%E9%92%9F%E8%A1%A8" style="text-align:center;">试题 B: 钟表</h2>
<p><img alt="" height="803" src="image\7ecbb50f2da0490b82630d705a790e5c.png" width="803"/></p>
<p></p>
<p><strong>题意：</strong>一个钟表的时针、分针的角度差==分针、秒针的角度差，求此时的时分秒。</p>
<p><strong>思路：暴力，我的答案是：</strong>4 48 0</p>
<p>        三个for起手不难，主要就是计算三个针的角度，</p>
<p>秒的角度就是：m/60</p>
<p>分的角度就是：f/60+(m/60)/*60，因为秒贡献的度数最多是1/60，贡献了m/60*(1/60)</p>
<p>时的角度就是：s/12+(f+m*60)/(60*12);，因为分钟贡献的度数最多是1/12，如果有res分钟，那么a=s/12+res/12</p>
<p>注意优弧劣弧的概念，小数的角度是&lt;=0.5的。</p>
<p><strong>代码：</strong></p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
#define dou double
#define EXP 1e-6
#define M 100010
int main()
{
    for(dou s=0;s&lt;=6;s++)
        for(dou f=0;f&lt;60;f++)
            for(dou m=0;m&lt;60;m++){
                dou a=s/12+(f+m*60)/(60*12);    //时针在表上角度
                dou b=f/60+m/(60*60);       //分针在表上角度
                dou c=m/60;             //秒针在表上角度
                dou x=fabs(a-b)&gt;0.5?1-fabs(a-b):fabs(a-b);      //x是时针和分针夹角
                dou y=fabs(b-c)&gt;0.5?1-fabs(b-c):fabs(b-c);      //x是分针和秒针夹角
                if(fabs(x-2*y)&lt;EXP){                //如果A==2*B
                    cout&lt;&lt;s&lt;&lt;" "&lt;&lt;f&lt;&lt;" "&lt;&lt;m&lt;&lt;endl;
                }
            }
    return 0;
}
</code></pre>
<hr/>
<p></p>
<p></p>
<p></p>
<h2 id="%E8%AF%95%E9%A2%98%20C%3A%20%E5%8D%A1%E7%89%8C" style="text-align:center;">试题 C: 卡牌</h2>
<p><img alt="" height="1086" src="image\811fa8af280340e0974ab51247633326.png" width="801"/></p>
<p> <img alt="" height="372" src="image\00e62214a7494e249c17cf49bc69b89f.png" width="784"/></p>
<p><strong> 题意：</strong>a[i]数组是已有的 i 类手牌的数量，每个类（1-n类）的出1张可以组成一套，还有m张空白的，可以随便写成任意i类。b数组是该类最多被空白牌写成几张，求组成的最多套牌。</p>
<p><strong>修改：这题比赛的时候被改成a,b&lt;n*2了，不是原来的n*n了</strong></p>
<p><strong>思路：二分</strong></p>
<p><strong>        </strong>容易知道是把空白牌用到少的类上，这题思路就是直接二分答案了</p>
<p>如果当前类牌不够mid张，当然是将空白的编变成该类牌，一是看是否超过了b数组的限制，二是看是否超过了最大空白牌数量。</p>
<p>直到最后也是没有被返回NO，那么返回YES</p>
<p><strong>check函数：</strong></p>
<pre><code class="language-cpp">int check(int mid){        //看看mid套行不行
    LL sum=0;
    for(int i=1;i&lt;=n;i++){
        if(a[i]&lt;mid){        //i类原来数量就超过mid张就不用考虑了
            if(mid-a[i]&gt;b[i]) return 0;        //如果需要的比限制多返回NO
            sum+=mid-a[i];
            if(sum&gt;m) return 0;        //如果使用空白牌多与m，返回NO
        }
    }
    return 1;
}</code></pre>
<p><strong>代码：</strong></p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
#define LL long long
#define M 1000005
LL n,m;
LL a[M],b[M];
int check(int mid){
    LL sum=0;
    for(int i=1;i&lt;=n;i++){
        if(a[i]&lt;mid){
            if(mid-a[i]&gt;b[i]) return 0;
            sum+=mid-a[i];
            if(sum&gt;m) return 0;
        }
    }
    return 1;
}
int main()
{
    scanf("%lld%lld",&amp;n,&amp;m);
    for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;a[i]);
    for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;b[i]);
    LL l=0,r=n*2,ans=0;
    while(l&lt;=r){
        LL mid=(l+r)/2;
        if(check(mid)){
            l=mid+1;
            ans=mid;
        }else{
            r=mid-1;
        }
    }
    printf("%lld\n",ans);
    return 0;
}
</code></pre>
<hr/>
<p></p>
<p></p>
<p></p>
<h2 id="%E8%AF%95%E9%A2%98%20D%3A%20%E6%9C%80%E5%A4%A7%E6%95%B0%E5%AD%97" style="text-align:center;">试题 D: 最大数字</h2>
<h2 id="%E2%80%8B%E7%BC%96%E8%BE%91" style="text-align:center;"><img alt="" height="1099" src="image\7366769aa5644ac8a976d41fdcff2abf.png" width="788"/></h2>
<p><img alt="" height="77" src="image\428750397b8a4d5fab6ee1e4a5f846e7.png" width="764"/></p>
<p><strong> 题意：</strong>给一个小于1e18的数字，不超过a次可以给一位+1，9再+就变成0，</p>
<p>不超过b次可以给一位-1，0再-变成9。</p>
<p> <strong>思路：思维+暴力深搜（dfs）</strong></p>
<p>        使用肯定是从前面开始的，因为是不超过多少次使用，前面就是能省则省，但是但凡有用，必须使用，暴力出答案即可。</p>
<p>对于每种情况只能是暴力的搜答案，时间复杂度最坏应该是2^18了差不多。</p>
<p>然后一直纠结用字符串还是整数来表示，整数肯定更方便计算和简洁，字符串便于修改，后面用数量级还是实现了整数的修改。</p>
<p><strong>dfs代码：</strong></p>
<pre><code class="language-cpp">void dfs(LL a,LL ans,LL b,LL c){    //a表示当前的N，ans是10的某次方,表示数量级,b和c是剩余数量
    if(ans==0){
        maxx=max(maxx,a);        //更新答案
        return;
    }
    int d=a/ans%10;
    if(b&gt;9-d){                        //能变成9就变9,
        int r=b-(9-d);
        dfs(a+(9-d)*ans,ans/10,r,c);
    }else{                        //不能变成9就全用
        dfs(a+b*ans,ans/10,0,c);
    }
    if(c!=0){
        if(c&gt;=d+1){                //能变成9就用，不能变就省着
            int r=c-(d+1);
            dfs(a-d*ans+9*ans,ans/10,b,r);
        }
    }
}</code></pre>
<p><strong>代码：</strong></p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
#define fo(a,b) for(int i=a;i&lt;=b;i++)
#define inf 0x3f3f3f3f
#define LL long long
#define M 100010
LL a,b,c;
LL maxx=0;
void dfs(LL a,LL ans,LL b,LL c){
    if(ans==0){
        maxx=max(maxx,a);
        return;
    }
    int d=a/ans%10;
    if(b&gt;9-d){
        int r=b-(9-d);
        dfs(a+(9-d)*ans,ans/10,r,c);
    }else{
        dfs(a+b*ans,ans/10,0,c);
    }
    if(c!=0){
        if(c&gt;=d+1){
            int r=c-(d+1);
            dfs(a-d*ans+9*ans,ans/10,b,r);
        }
    }
}
int main()
{
    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;
    LL tmp=a;
    LL ans=1;
    while(a){
        a/=10;
        ans*=10;
    }
    dfs(tmp,ans/10,b,c);
    cout&lt;&lt;maxx&lt;&lt;endl;
	return 0;
}
</code></pre>
<hr/>
<p></p>
<p></p>
<p></p>
<h2 id="%E8%AF%95%E9%A2%98%20E%3A%20%E5%87%BA%E5%B7%AE" style="text-align:center;">试题 E: 出差</h2>
<p><img alt="" height="1200" src="image\7e0a31f6ed68451fb91b00c1b4a4c693.png" width="806"/></p>
<p></p>
<p><img alt="" height="1179" src="image\77f257f734254a8eba7b362334b46e6c.png" width="805"/></p>
<p><strong> 题意：</strong>n个点，m条边构成一个有边权的无向图，然后每个顶点都有自己的停留时间，即到达该点要停的时间，都是正数，求1到n点的最短时间</p>
<p><strong>思路：最短路的贝尔曼-福特算法(Bellman-Ford)</strong></p>
<p>        这题就是最短路模板题，只是加上了顶点要停留，感觉<strong>迪杰斯特拉算法（Dijkstra）</strong>应该也行，但觉得<strong>贝尔曼-福特算法(Bellman-Ford)</strong>应该更合适。</p>
<p>只是在使用边的时候，将边权+终点停留时间，终点为n时不加</p>
<p><strong>更新代码：</strong></p>
<pre><code class="language-cpp"> for(int k=1;k&lt;=n;k++){        //n次更新
        for(int i=1;i&lt;=m;i++){
            int res1=0,res2=0;
            if(b[i]!=n) res1=x[b[i]];        //终点不为n，边权+停留时间
            if(a[i]!=n) res2=x[a[i]];
            dist[b[i]]=min(dist[b[i]],dist[a[i]]+c[i]+res1);
            dist[a[i]]=min(dist[a[i]],dist[b[i]]+c[i]+res2);
        }
    }</code></pre>
<p><strong>代码：</strong></p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
#define fo(a,b) for(int i=a;i&lt;=b;i++)
#define inf 0x3f3f3f3f
#define LL long long
#define M 100005
int n,m;
int x[M];
int dist[M],a[M],b[M],c[M];
int main(){
    scanf("%d%d",&amp;n,&amp;m);
    memset(dist,inf,sizeof(dist));
    dist[1]=0;
    for(int i=1;i&lt;=n;i++) cin&gt;&gt;x[i];
    for(int i=1;i&lt;=m;i++)
        scanf("%d%d%d",&amp;a[i],&amp;b[i],&amp;c[i]);
    for(int k=1;k&lt;=n;k++){
        for(int i=1;i&lt;=m;i++){
            int res1=0,res2=0;
            if(b[i]!=n) res1=x[b[i]];
            if(a[i]!=n) res2=x[a[i]];
            dist[b[i]]=min(dist[b[i]],dist[a[i]]+c[i]+res1);
            dist[a[i]]=min(dist[a[i]],dist[b[i]]+c[i]+res2);
        }
    }
    cout&lt;&lt;dist[n]&lt;&lt;endl;
    return 0;
}
</code></pre>
<hr/>
<p></p>
<p></p>
<p></p>
<h2 id="%E8%AF%95%E9%A2%98%20F%3A%20%E8%B4%B9%E7%94%A8%E6%8A%A5%E9%94%80" style="text-align:center;">试题 F: 费用报销</h2>
<p><img alt="" height="1200" src="image\2c68772580b944539e72f24e22917dcc.png" width="813"/></p>
<p> <img alt="" height="600" src="image\85b2f395d41b4c4f81494a92938158cf.png" width="834"/></p>
<p><strong> 题意：</strong>给同一年的一些天，这些天都<strong>一个或多个</strong>的钱，选一些天使金额最多<strong>且不超多m</strong>，其中所有相邻的天数相差<strong>不低于k</strong>（&gt;=k）</p>
<p><strong>思路：动态规划</strong></p>
<p><strong>    </strong>    比较简单得到动态规划，首先将天转变为一维数组，dp[i]表示该天最大的金额。</p>
<p>那么dp[i]=max(dp[i-1],dp[i-k]+a[i])                //对应的就是不选和选</p>
<p><strong>核心代码：</strong></p>
<pre><code class="language-cpp">
    for(int i=1;i&lt;=500;i++){            //一年365天，dp超过365就行
        if(dp[i]+dp[max(0,i-k)]&lt;=m)
            dp[i]=max(dp[i]+dp[max(0,i-k)],dp[i-1]);
        else        //如果选了会超过m，就不选了
            dp[i]=dp[i-1];
    }</code></pre>
<p><strong>代码：</strong></p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
#define fo(a,b) for(int i=a;i&lt;=b;i++)
#define inf 0x3f3f3f3f
#define LL long long
#define M 100005
int n,m,k;
int x,y,z;
int mp[105][105],dp[10005];
int r[]={0,31,28,31,30,31,30,31,31,30,31,30,31};
int main(){
    int sum=0;
    for(int i=1;i&lt;=12;i++){
        for(int j=1;j&lt;=r[i];j++){
            sum++;
            mp[i][j]=sum;        //映射天数
        }
    }
    scanf("%d%d%d",&amp;n,&amp;m,&amp;k);
    for(int i=1;i&lt;=n;i++){
        scanf("%d%d%d",&amp;x,&amp;y,&amp;z);
        dp[mp[x][y]]=max(dp[mp[x][y]],z);        //k最小为1，当天的就选个最大的就行
    }
    for(int i=1;i&lt;=500;i++){
        if(dp[i]+dp[max(0,i-k)]&lt;=m)
            dp[i]=max(dp[i]+dp[max(0,i-k)],dp[i-1]);
        else
            dp[i]=dp[i-1];
    }
    cout&lt;&lt;dp[500]&lt;&lt;endl;
    return 0;
}</code></pre>
<hr/>
<p></p>
<p></p>
<p></p>
<h2 id="%E8%AF%95%E9%A2%98%20G%3A%20%E6%95%85%E9%9A%9C" style="text-align:center;">试题 G: 故障</h2>
<p><img alt="" height="1200" src="image\1a59b45c6f4e4ef787ba3b401c8fbb7d.png" width="861"/></p>
<p><img alt="" height="1200" src="image\d1d73ed629ce47c09dd2f44e9a922111.png" width="794"/></p>
<p><img alt="" height="236" src="image\dc762aaa84d0444f888b164856ea44cc.png" width="818"/></p>
<p><strong> 题意：</strong>不知</p>
<p><strong>思路：</strong>不知，题有点多，做不过来</p>
<p><strong>代码：</strong>未有</p>
<hr/>
<p></p>
<p></p>
<p></p>
<h2 id="%E8%AF%95%E9%A2%98%20H%3A%20%E6%9C%BA%E6%88%BF" style="text-align:center;">试题 H: 机房</h2>
<p><img alt="" height="1173" src="image\17683902f18b4049a8a14d72c6680ffd.png" width="826"/></p>
<p><img alt="" height="921" src="image\038b6189fbd04aaa8e7baf5b97423435.png" width="838"/></p>
<p><strong> 题意：</strong>给一颗无边权的树，查询m次两点路劲之间，所有点的<strong>直接连接点的数量</strong>和。</p>
<p> <strong>思路：LCA+树形DP</strong></p>
<p>        还是比较好想的，dfs处理出给个点的<strong>直接连接点的数量，</strong>再dfs，求出每个点到顶点的<strong>直接连接点的数量</strong>的前缀和，用dp[i]表示。</p>
<p>d表示两点x和y的LCA（共公祖先），pre[d]表示d的父点，结果就是dp[x]+dp[y]-dp[d]-dp[pre[d]]。</p>
<p><strong>核心代码：</strong></p>
<pre><code class="language-cpp">void dfs(int d,int pre,int sum)
{
    for(int i=1;i&lt;n+5;i++) lg[i]=lg[i-1]+(1&lt;&lt;lg[i-1]==i);           //LCA倍增
    fa[d][0]=pre;                   //LCA倍增
    h[d]=h[pre]+1;                  //LCA倍增
    p[d]=pre;                  //父点
    for(int i=1;i&lt;=lg[h[d]]+1;i++)                  //LCA倍增
        fa[d][i]=fa[fa[d][i-1]][i-1];
    int l=v[d].size();                    //l也是当前结点直接连接其他结点数量
    dp[d]=l+sum;                          //sum是之前父链的和
    fo(0,l-1){
        int now=v[d][i];
        if(pre!=now){
            dfs(now,d,dp[d]);
        }
    }
}</code></pre>
<p><strong>代码：</strong></p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
#define fo(a,b) for(int i=a;i&lt;=b;i++)
#define inf 0x3f3f3f3f
#define LL long long
#define M 200005
int n,m,x,y;
int dp[M],p[M];
vector&lt;int&gt;v[M];
int h[M],lg[M],fa[M][35];
void dfs(int d,int pre,int sum)
{
    for(int i=1;i&lt;n+5;i++) lg[i]=lg[i-1]+(1&lt;&lt;lg[i-1]==i);           //LCA倍增
    fa[d][0]=pre;                   //LCA倍增
    h[d]=h[pre]+1;                  //LCA倍增
    p[d]=pre;                  //父点
    for(int i=1;i&lt;=lg[h[d]]+1;i++)                  //LCA倍增
        fa[d][i]=fa[fa[d][i-1]][i-1];
    int l=v[d].size();                    //l也是当前结点直接连接其他结点数量
    dp[d]=l+sum;                          //sum是之前父链的和
    fo(0,l-1){
        int now=v[d][i];
        if(pre!=now){
            dfs(now,d,dp[d]);
        }
    }
}
int LCA(int a,int b)
{
    if(h[a]&lt;h[b]) swap(a,b);
    for(int i=lg[h[a]]+1;i&gt;=0;i--){
        if(h[a]-(1&lt;&lt;i)&gt;=h[b])
            a=fa[a][i];
    }
    if(a==b) return a;
    for(int i=lg[h[a]]+1;i&gt;=0;i--)
        if(fa[a][i]!=fa[b][i]){
            a=fa[a][i];
            b=fa[b][i];
        }
    return fa[a][0];
}
int main(){
    cin&gt;&gt;n&gt;&gt;m;
    fo(1,n-1){
        cin&gt;&gt;x&gt;&gt;y;
        v[x].push_back(y);
        v[y].push_back(x);
    }
    dfs(1,0,0);
    while(m--){
        int x,y;
        cin&gt;&gt;x&gt;&gt;y;
        int d=LCA(x,y);
        cout&lt;&lt;dp[x]+dp[y]-dp[d]-dp[p[d]]&lt;&lt;endl;
    }
    return 0;
}
</code></pre>
<hr/>
<p></p>
<p></p>
<p></p>
<h2 id="%E8%AF%95%E9%A2%98%20I%3A%20%E9%BD%BF%E8%BD%AE" style="text-align:center;">试题 I: 齿轮</h2>
<p><img alt="" height="1012" src="image\0ba32f8591aa4715a09729214d01c2bb.png" width="779"/></p>
<p><img alt="" height="713" src="image\dfb162deb63b4411a61ddba94cf1ecc4.png" width="786"/></p>
<p><strong> 题意：</strong>给一个数组为齿轮大小，问能不能换顺序后，尾转的速度是首转的速度的qi倍，询问Q次。</p>
<p><strong>思路：</strong>不难发现这个中间的没有用，就是首的半径=尾的半径*qi就可。而且这种排序是随便的，只需要找这个数组中<strong>有没有两个数相除==qi</strong>即可。</p>
<p>那么需处理出这个数组所有的可有倍数即可。具体看代码更容易理解，这个时间复杂度是n*logn的，对1e6也应该能用，注意倍数1的判断</p>
<p><strong>预处理代码：</strong></p>
<pre><code class="language-cpp">for(int i=1;i&lt;=MAX;i++){            //MAX=2e5
        if(vis[i]==1){                //vis[i]表示i在该数组中
            for(int j=i*2;j&lt;=MAX;j+=i){
                if(vis[j]==1) ans[j/i]=1;        //ans是结果数组
            }    
        }
    }
</code></pre>
<p><strong>代码：</strong></p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
#define inf 0x3f3f3f3f
#define LL long long
#define M 1000005
int MAX=400005;
int n,m,flag=0;
int a[M];
int vis[M],ans[M];
int main(){
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1;i&lt;=n;i++){
        cin&gt;&gt;a[i];
        if(vis[a[i]]==1) flag=1;        //单独判断ans[1]
        vis[a[i]]=1;            //表明数组有这个数
    }
    if(flag) ans[1]=1;
    for(int i=1;i&lt;=MAX;i++){
        if(vis[i]==1){
            for(int j=i*2;j&lt;=MAX;j+=i){
                if(vis[j]==1) ans[j/i]=1;
            }
        }
    }
    int x;
    while(m--){
        cin&gt;&gt;x;
        if(ans[x]) cout&lt;&lt;"YES"&lt;&lt;endl;
        else cout&lt;&lt;"NO"&lt;&lt;endl;
    }
    return 0;
}
</code></pre>
<hr/>
<p></p>
<p></p>
<p></p>
<h2 id="%E8%AF%95%E9%A2%98%20J%3A%20%E6%90%AC%E7%A0%96" style="text-align:center;">试题 J: 搬砖</h2>
<p><img alt="" height="1080" src="image\487f0086ee6e4bcfa3e35aad5a8c6112.png" width="776"/></p>
<p><img alt="" height="320" src="image\e0463d4e81ad401c8248ee9aa4b4d549.png" width="782"/></p>
<p><strong> 题意：</strong>选取若干个从上到下放，重量不能小于上面的和，求总价值最大</p>
<p><strong>思路：</strong>可能是<strong>动态规划</strong>，写差不多觉得和题意有点出入，就直接<strong>dfs暴力</strong>了</p>
<p>暴力挺简单的，先结构体排序，重量小的一定先选在上面，不然直接压垮了。然后同重量的价值大的一定先选。</p>
<p>dfs出所有的1-n排序，也就是：</p>
<p>1 2 3 4 5</p>
<p>1 2 3 4</p>
<p>3 4 5</p>
<p>2 4 5</p>
<p>这些</p>
<p>....</p>
<p>然后计算判断更新最后答案</p>
<p><strong>代码：</strong></p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
#define fo(a,b) for(int i=a;i&lt;=b;i++)
#define inf 0x3f3f3f3f
#define LL long long
#define M 200005
int n,maxx=0;
struct Node
{
    int a,b;
    bool operator&lt;(const Node temp)const{
        if(a==temp.a) return b&gt;temp.b;
        return a&lt;temp.a;
    }
}x[M];

//此代码是暴力代码，只能过30%

int q[M],v=0;
void dfs(int d,int pre){
    if(d==n){                //判断q数组中的顺序是否合法
        int sum=0,ans=0;
        for(int i=1;i&lt;=v;i++){
            if(x[q[i]].a&lt;sum) break;
            sum+=x[q[i]].a;
            ans+=x[q[i]].b;
            if(i==v) maxx=max(maxx,ans);
        }
        return;
    }
    for(int i=pre+1;i&lt;=n;i++){
        q[++v]=i;
        dfs(d+1,i);
        v--;
    }
    if(v!=0) dfs(d+1,pre);
}
int main(){
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++)
        cin&gt;&gt;x[i].a&gt;&gt;x[i].b;
    sort(x+1,x+n+1);
    dfs(0,0);
    cout&lt;&lt;maxx&lt;&lt;endl;
    return 0;
}
</code></pre>
<p></p>
<p></p>
<h1 id="%E7%BB%93%E5%B0%BE%EF%BC%9A">结尾：</h1>
<p>        看了下演草纸，才用了1页多，一般比赛要好几页的。不少题是算法及相关的题，总体acm选手估计是叫好，但是对其他选手不清楚了，这题个人觉得难度适中，因为往年很多题不能暴力，而且到现在，那些题也没有题解（csdn上）。今年只有一题没看，一个暴力，难度肯定是降了不少的。</p>
</div>
</div>