<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<p id="main-toc"><strong>目录</strong></p>
<p id="-toc" style="margin-left:0px;"></p>
<p id="1.%E7%BB%A7%E6%89%BF-toc" style="margin-left:0px;"><a href="#1.%E7%BB%A7%E6%89%BF">1.继承</a></p>
<p id="1.1%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%BB%A7%E6%89%BF%EF%BC%9F-toc" style="margin-left:40px;"><a href="#1.1%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%BB%A7%E6%89%BF%EF%BC%9F">1.1为什么要继承？</a></p>
<p id="1.2%E7%BB%A7%E6%89%BF%E7%9A%84%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#1.2%E7%BB%A7%E6%89%BF%E7%9A%84%E6%A6%82%E5%BF%B5">1.2继承的概念</a></p>
<p id="1.3%20%E7%BB%A7%E6%89%BF%E7%9A%84%E8%AF%AD%E6%B3%95-toc" style="margin-left:40px;"><a href="#1.3%20%E7%BB%A7%E6%89%BF%E7%9A%84%E8%AF%AD%E6%B3%95">1.3 继承的语法</a></p>
<p id="1.4%20%E7%88%B6%E7%B1%BB%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE-toc" style="margin-left:40px;"><a href="#1.4%20%E7%88%B6%E7%B1%BB%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE">1.4 父类成员访问</a></p>
<p id="1.4.1%20%E5%AD%90%E7%B1%BB%E4%B8%AD%E8%AE%BF%E9%97%AE%E7%88%B6%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-toc" style="margin-left:80px;"><a href="#1.4.1%20%E5%AD%90%E7%B1%BB%E4%B8%AD%E8%AE%BF%E9%97%AE%E7%88%B6%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F">1.4.1 子类中访问父类的成员变量</a></p>
<p id="1.4.2%20%E5%AD%90%E7%B1%BB%E4%B8%AD%E8%AE%BF%E9%97%AE%E7%88%B6%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#1.4.2%20%E5%AD%90%E7%B1%BB%E4%B8%AD%E8%AE%BF%E9%97%AE%E7%88%B6%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95">1.4.2 子类中访问父类的成员方法</a></p>
<p id="1.5%20super%E5%85%B3%E9%94%AE%E5%AD%97-toc" style="margin-left:40px;"><a href="#1.5%20super%E5%85%B3%E9%94%AE%E5%AD%97">1.5 super关键字</a></p>
<p id="1.6%20%E5%AD%90%E7%B1%BB%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#1.6%20%E5%AD%90%E7%B1%BB%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95">1.6 子类构造方法</a></p>
<p id="1.7super%E5%92%8Cthis-toc" style="margin-left:40px;"><a href="#1.7super%E5%92%8Cthis">1.7super和this</a></p>
<p id="%C2%A01.8%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E4%B8%8A%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F-toc" style="margin-left:40px;"><a href="#%C2%A01.8%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E4%B8%8A%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"> 1.8继承关系上的执行顺序</a></p>
<p id="1.9protected%20%E5%85%B3%E9%94%AE%E5%AD%97%C2%A0-toc" style="margin-left:40px;"><a href="#1.9protected%20%E5%85%B3%E9%94%AE%E5%AD%97%C2%A0">1.9protected 关键字 </a></p>
<p id="1.11%20final%20%E5%85%B3%E9%94%AE%E5%AD%97-toc" style="margin-left:40px;"><a href="#1.11%20final%20%E5%85%B3%E9%94%AE%E5%AD%97">1.11 final 关键字</a></p>
<p id="1.12%20%E7%BB%A7%E6%89%BF%E4%B8%8E%E7%BB%84%E5%90%88-toc" style="margin-left:40px;"><a href="#1.12%20%E7%BB%A7%E6%89%BF%E4%B8%8E%E7%BB%84%E5%90%88">1.12 继承与组合</a></p>
<hr id="hr-toc"/>
<p></p>
<h1 id="1.%E7%BB%A7%E6%89%BF">1.继承</h1>
<h2 id="1.1%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%BB%A7%E6%89%BF%EF%BC%9F">1.1为什么要继承？</h2>
<p>java中使用类对现实世界中实体进行描述，类经过实例化之后的产物对象，则可以用来表示现实中的实体。但是现实世界一些事物可能存在关联，在设计程序时就需要考虑。</p>
<p>比如：猫和狗都是动物。</p>
<p>创建一个狗类：</p>
<pre><code class="language-java">//狗类
public class Dog {
    String name;
    int age;
    float weight;
    public void eat(){
        System.out.println(name+"正在吃饭");
    }
    public void sleep(){
        System.out.println(name+"正在睡觉");
    }
    public void Bark(){
        System.out.println(name+"汪汪汪");
    }
}</code></pre>
<p>创建一个猫类</p>
<pre><code class="language-java">public class Cat {
    String name;
    int age;
    float weight;
    public void eat(){
        System.out.println(name+"正在吃饭");
    }
    public void sleep(){
        System.out.println(name+"正在睡觉");
    }
    public void mew(){
        System.out.println(name+"喵喵喵");
    }
}</code></pre>
<p><img alt="" height="542" src="image\bf0c4f7bff904af1a3563f209f9932f9.png" width="1200"/></p>
<p>我们会发现上述创建的狗类和猫类有很多相同的地方：它们都有名字，年龄，都会吃饭睡觉等等。我们能否<strong>将这些共性给抽取出来，实现代码的复用呢</strong>？</p>
<h2 id="1.2%E7%BB%A7%E6%89%BF%E7%9A%84%E6%A6%82%E5%BF%B5">1.2继承的概念</h2>
<p><span style="color:#333333;">允许程序员在保持原有类特性的基础上进行<strong>扩展，增加新功能</strong>，这样产生新的类，称<strong>子类（派生类）</strong></span><span style="color:#333333;">。</span></p>
<p><span style="color:#333333;">狗和猫都是动物，我们就可以将共性的内容进行抽取，然后用继承的思想来达到共用。</span></p>
<p><img alt="" height="591" src="image\59d986b1123a4df28eadbdb4581a3c9b.png" width="1140"/></p>
<div>
<span style="color:#333333;">Dog</span>
<span style="color:#333333;">和</span>
<span style="color:#333333;">Cat</span>
<span style="color:#333333;">都继承了</span>
<span style="color:#333333;">Animal</span>
<span style="color:#333333;">类，其中：</span>
<span style="color:#333333;">Animal</span>
<span style="color:#333333;">类称为父类</span>
<span style="color:#333333;">/</span>
<span style="color:#333333;">基类或超类，</span>
<span style="color:#333333;">Dog</span>
<span style="color:#333333;">和</span>
<span style="color:#333333;">Cat</span>
<span style="color:#333333;">可以称为</span>
<span style="color:#333333;">Animal</span>
<span style="color:#333333;">的 子类/</span>
<span style="color:#333333;">派生类，继承之后，子类可以复用父类中成员，子类在实现时只需关心自己新增加的成员即可。</span>
</div>
<p></p>
<h2 id="1.3%20%E7%BB%A7%E6%89%BF%E7%9A%84%E8%AF%AD%E6%B3%95"><span style="color:#333333;"><strong>1.3 </strong></span><span style="color:#333333;"><strong>继承的语法</strong></span></h2>
<p><span style="color:#333333;">在</span><span style="color:#333333;">Java</span><span style="color:#333333;">中如果要表示类之间的继承关系，需要借助</span><span style="color:#333333;"><strong>extends</strong></span><span style="color:#333333;">关键字</span></p>
<p>写一个Animal类作为父类：</p>
<pre><code class="language-java">public class Animal {
    String name;
    int age;
    float weight;
    public void eat(){
        System.out.println(name+"正在吃饭");
    }
    public void sleep(){
        System.out.println(name+"正在睡觉");
    }
}
</code></pre>
<p> 重写狗类：</p>
<pre><code class="language-java">public class Dog extends Animal {
    public void Bark(){
        System.out.println(name+"汪汪汪");
    }
}</code></pre>
<p>重写猫类：</p>
<pre><code class="language-java">public class Cat extends Animal {
    public void mew(){
        System.out.println(name+"喵喵喵");
    }
}</code></pre>
<p>可以发现我们重新写的狗类和猫类节省了大量的代码。</p>
<p>注意：</p>
<p><span style="color:#333333;">1. 子类会将父类中的成员变量或者成员方法继承到子类中</span></p>
<p><span style="color:#333333;">2. 子类继承父类之后，必须要新添加自己特有的成员，体现出与父类的不同，否则就没有必要继承了</span></p>
<h2 id="1.4%20%E7%88%B6%E7%B1%BB%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE"><span style="color:#333333;"><strong>1.4 </strong></span><span style="color:#333333;"><strong>父类成员访问</strong></span></h2>
<h3 id="1.4.1%20%E5%AD%90%E7%B1%BB%E4%B8%AD%E8%AE%BF%E9%97%AE%E7%88%B6%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span style="color:#333333;"><strong>1.4.1 </strong></span><span style="color:#333333;"><strong>子类中访问父类的成员变量</strong></span></h3>
<div>
<span style="color:#333333;">1. </span>
<span style="color:#333333;"><strong>子类和父类不存在同名成员变量</strong></span>
</div>
<div>
<pre><code class="language-java">public class Base {
    int a;
    int b;
}
public class Derived extends Base{
        int c;
    public void method(){
        a = 10;
        // 访问从父类中继承下来的a
        b = 20; // 访问从父类中继承下来的b
        c = 30; // 访问子类自己的c
     } 
}</code></pre>
<p><span style="color:#333333;">2. </span><span style="color:#333333;"><strong>子类和父类成员变量同名 </strong></span></p>
</div>
<div>
<span style="color:#333333;">在子类方法中 或者 通过子类对象访问成员时：<strong>成员变量访问遵循就近原则，自己有优先自己的，如果没有则向父类中找</strong></span>
<span style="color:#333333;">。 </span>
</div>
<div>
<pre><code class="language-java">public class Base { 
    int a; 
    int b; 
    int c; 
}
public class Derived extends Base {
    int a; // 与父类中成员a同名，且类型相同
    char b; // 与父类中成员b同名，但类型不同

    public void method() {
        a = 100; // 就近，访问子类自己的a
        b = 101; // 就近原则访问子类自己的b
        c = 102; // 子类没有c，访问的肯定是从父类继承下来的c 
        d = 103; // 编译失败，因为父类和子类都没有定义成员变量b
    }
}</code></pre>
<h2 id="1.4.2%20%E5%AD%90%E7%B1%BB%E4%B8%AD%E8%AE%BF%E9%97%AE%E7%88%B6%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span style="color:#333333;"><strong>1.4.2 </strong></span><span style="color:#333333;"><strong>子类中访问父类的成员方法</strong></span></h2>
<div>
<strong><span style="color:#333333;">通过子类对象访问父类与子类中不同名方法时，优先在子类中找，找到则访问，否则在父类中找，找到 则访问，否则编译报错。 </span></strong>
</div>
<div>
<strong><span style="color:#333333;">通过子类对象访问父类与子类同名方法时，如果父类和子类同名方法的参数列表不同</span><span style="color:#333333;">(</span><span style="color:#333333;">重载</span><span style="color:#333333;">)</span><span style="color:#333333;">，根据调用 方法适传递的参数选择合适的方法访问，如果没有则报错；</span></strong>
</div>
<div>
<pre><code class="language-java">public class Base {
    public void methodA(){
        System.out.println("Base中的methodA()"); 
    }
    public void methodB(){
        System.out.println("Base中的methodB()");
    }
}
public class Derived extends Base{
    public void methodA(int a) { 
        System.out.println("Derived中的method(int)方法");
    }
    public void methodB(){ 
        System.out.println("Derived中的methodB()方法"); 
    }
    public void methodC(){
        methodA(); // 没有传参，访问父类中的methodA()
        methodA(20); // 传递int参数，访问子类中的methodA(int)
        methodB(); // 直接访问，则永远访问到的都是子类中的methodB()，父类的无法访问到 
    }
}</code></pre>
<h2 id="1.5%20super%E5%85%B3%E9%94%AE%E5%AD%97"><span style="color:#333333;"><strong>1.5 super</strong></span><span style="color:#333333;"><strong>关键字</strong></span></h2>
</div>
<div>
<span style="color:#333333;"><strong>super</strong></span>
<span style="color:#333333;"><strong>关键字：该关键字主要作用：在子类方法中访问父</strong></span>
<span style="color:#333333;"><strong>类的成员</strong></span>
</div>
<div>
<div>
<span style="color:#333333;"><span style="background-color:#ffd900;">1. </span></span>
<span style="color:#333333;"><strong><span style="background-color:#ffd900;">只能在非静态方法中使用 </span></strong></span>
</div>
<div>
<span style="color:#333333;"><span style="background-color:#38d8f0;">2. </span></span>
<span style="color:#333333;"><strong><span style="background-color:#38d8f0;">在子类方法中，访问父类的成员变量和方法</span></strong></span>
<span style="color:#333333;"><span style="background-color:#38d8f0;">。</span></span>
</div>
<div>
   父类：
  </div>
<div>
<pre><code class="language-java">public class Base {
    int a;
    int b;
    public void methodA(){
        System.out.println("Base中的methodA()");
    }
    public void methodB(){
        System.out.println("Base中的methodB()");
    }
}</code></pre>
<p></p>
</div>
<div>
   子类：
  </div>
<div>
<pre><code class="language-java">public class Derived extends Base {
    int a;
    // 与父类中成员变量同名且类型相同
    char b; // 与父类中成员变量同名但类型不同 

    // 与父类中methodA()构成重载
    public void methodA(int a) {
        System.out.println("Derived中的method()方法");
    }
    // 与基类中methodB()构成重写

    public void methodB() {
        System.out.println("Derived中的methodB()方法");
    }

    public void methodC() { // 对于同名的成员变量，直接访问时，访问的都是子类的
        a = 100; // 等价于： this.a = 100; 
        b = 101; // 等价于： this.b = 101; 
        // 注意：this是当前对象的引用 // 访问父类的成员变量时，需要借助super关键字 
        // super是获取到子类对象中从基类继承下来的部分
        super.a = 200;
        super.b = 201; 
        // 父类和子类中构成重载的方法，直接可以通过参数列表区分清访问父类还是子类方法
        methodA(); // 没有传参，访问父类中的methodA()
        methodA(20); // 传递int参数，访问子类中的methodA(int) // 如果在子类中要访问重写的基类方法，则需要借助super关键字
        methodB(); // 直接访问，则永远访问到的都是子类中的methodA()，基类的无法访问到 
        super.methodB(); // 访问父类的methodB() 
    }
}</code></pre>
<h2 id="1.6%20%E5%AD%90%E7%B1%BB%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span style="color:#333333;"><strong>1.6 </strong></span><span style="color:#333333;"><strong>子类构造方法</strong></span></h2>
<div>
<div>
<strong><span style="color:#333333;"><span style="background-color:#fe2c24;">子类对象构造时，需要先调用父类构造方法，然后执行子类的构造方法。</span></span></strong>
</div>
<div>
<div></div>
<div>
<span style="color:#333333;">父类</span>
</div>
<div>
<pre><code class="language-java">public class Base {
    public Base(){ 
        System.out.println("Base()");
    }
}</code></pre>
<p>子类</p>
<pre><code class="language-java">public class Derived extends Base{
    public Derived() {
        // super();
        // 注意子类构造方法中默认会调用基类的无参构造方法：super(),
        // 用户没有写时,编译器会自动添加，而且super()必须是子类构造方法中第一条语句，
        // 并且只能出现一次
       System.out.println("Derived()");
    }
}</code></pre>
<p>运行结果：</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        Derived d = new Derived();
    }
}</code></pre>
<p><img alt="" height="139" src="image\33508f90edba4fe1b14bde985f6d1902.png" width="626"/></p>
<p>先调用了public Base,后调用了Derived</p>
<p><span style="background-color:#ffd900;"> </span><span style="color:#333333;"><strong><span style="background-color:#ffd900;">子类对象中成员是有两部分组成的，父类继承下来的以及子类新增加的部分 。</span></strong></span></p>
<div>
<span style="color:#333333;"><strong><span style="background-color:#38d8f0;">在构造子类对象时候 ，先要调用父类的构造方法，将从父类继承下来的成员构造完整 </span></strong></span>
</div>
<div>
<span style="color:#333333;"><strong><span style="background-color:#38d8f0;">，然后再调用子类自己的构造方法，将子类自己新增加的成员初始化完整 </span></strong></span>
<span style="color:#333333;"><span style="background-color:#38d8f0;">。</span></span>
</div>
<div></div>
<div>
<strong><span style="color:#fe2c24;">this()和super()不能同时出现</span></strong>
</div>
<div></div>
<div>
<img alt="" height="645" src="image\987e650184814d20b91e548512f94984.png" width="820"/>
</div>
<p><img alt="" height="672" src="image\c8a373cd35814f6796627bbf190b042f.png" width="876"/></p>
<p></p>
<div></div>
<div>
<div>
        注意：
       </div>
<div>
<strong><span style="color:#333333;"><span style="background-color:#e6b223;">1. </span></span><span style="color:#333333;"><span style="background-color:#e6b223;">若父类显式定义无参或者默认的构造方法，在子类构造方法第一行默认有隐含的</span></span><span style="color:#333333;"><span style="background-color:#e6b223;">super()</span></span><span style="color:#333333;"><span style="background-color:#e6b223;">调用，即调用基类构 造方法 </span></span></strong>
</div>
<div>
<strong><span style="color:#333333;"><span style="background-color:#79c6cd;">2. </span></span><span style="color:#333333;"><span style="background-color:#79c6cd;">如果父类构造方法是带有参数的，此时需要用户为子类显式定义构造方法，并在子类构造方法中选择合适的 父类构造方法调用，否则编译失败。 </span></span></strong>
</div>
<div>
<strong><span style="color:#333333;"><span style="background-color:#a2e043;">3. </span></span><span style="color:#333333;"><span style="background-color:#a2e043;">在子类构造方法中，</span></span><span style="color:#333333;"><span style="background-color:#a2e043;">super(...)</span></span><span style="color:#333333;"><span style="background-color:#a2e043;">调用父类构造时，必须是子类构造函数中第一条语句。 </span></span></strong>
</div>
<div>
<strong><span style="color:#333333;"><span style="background-color:#6eaad7;">4. super(...)</span></span><span style="color:#333333;"><span style="background-color:#6eaad7;">只能在子类构造方法中出现一次。</span></span></strong>
</div>
<div>
<h2 id="1.7super%E5%92%8Cthis"><span style="color:#333333;"><strong>1.7super</strong></span><span style="color:#333333;"><strong>和</strong></span><span style="color:#333333;"><strong>this </strong></span></h2>
<div>
         相同点：
        </div>
<div>
<strong>1.都是java中的关键字</strong>
</div>
<div></div>
<div>
<strong>2.只能在非静态方法中使用，<span style="color:#333333;">必须是构造方法中的第一条语句，并且不能同时存在 </span></strong>
</div>
<div></div>
<div>
         不同点：
        </div>
<div></div>
<div>
<div>
<strong><span style="color:#333333;"><span style="background-color:#ffd900;">1. this</span></span><span style="color:#333333;"><span style="background-color:#ffd900;">是当前对象的引用，当前对象即调用实例方法的对象，</span></span><span style="color:#333333;"><span style="background-color:#ffd900;">super</span></span><span style="color:#333333;"><span style="background-color:#ffd900;">相当于是子类对象中从父类继承下来部分成 员的引用</span></span></strong>
</div>
<div></div>
<div>
<div>
<strong><span style="color:#333333;"><span style="background-color:#38d8f0;">2. </span></span><span style="color:#333333;"><span style="background-color:#38d8f0;">在非静态成员方法中，</span></span><span style="color:#333333;"><span style="background-color:#38d8f0;">this</span></span><span style="color:#333333;"><span style="background-color:#38d8f0;">用来访问本类的方法和属性，</span></span><span style="color:#333333;"><span style="background-color:#38d8f0;">super</span></span><span style="color:#333333;"><span style="background-color:#38d8f0;">用来访问父类继承下来的方法和属性</span> </span></strong>
</div>
<div></div>
<div>
<strong><span style="color:#333333;"><span style="background-color:#956fe7;">3. </span></span><span style="color:#333333;"><span style="background-color:#956fe7;">构造方法中一定会存在</span></span><span style="color:#333333;"><span style="background-color:#956fe7;">super(...)</span></span><span style="color:#333333;"><span style="background-color:#956fe7;">的调用，用户没有写编译器也会增加，但是</span></span><span style="color:#333333;"><span style="background-color:#956fe7;">this(...)</span></span><span style="color:#333333;"><span style="background-color:#956fe7;">用户不写则没有 </span></span></strong>
</div>
<div></div>
<div>
<div>
<span style="color:#333333;"><strong>初始化</strong></span>
</div>
<div></div>
<div>
<p>代码执行顺序：</p>
<div>
<strong><span style="color:#0d0016;"><span style="background-color:#ffd900;">1. 静态代码块先执行，并且只执行一次，在类加载阶段执行 </span></span></strong>
</div>
<div></div>
<div>
<strong><span style="color:#0d0016;"><span style="background-color:#38d8f0;">2. 当有对象创建时，才会执行实例代码块，实例代码块执行完成后，最后构造方法执行</span></span></strong>
</div>
<div></div>
<div>
<pre><code class="language-java">class Person {
    public String name;
    public int age;
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
        System.out.println("构造方法执行");
    }
    {
        System.out.println("实例代码块执行");
    }
    static {
        System.out.println("静态代码块执行");
    }
}
public class TestDemo {
    public static void main(String[] args) { 
        Person person1 = new Person("zhangsan",10); 
        System.out.println("============================");
        Person person2 = new Person("lisi",20); 
    }
}</code></pre>
<p><img alt="" height="237" src="image\e16a0d4342d344e28b9559a317e42a2e.png" width="597"/></p>
<h2 id="%C2%A01.8%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E4%B8%8A%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"> 1.8<span style="color:#333333;"><strong>继承关系上的执行顺序</strong></span></h2>
<div>
<strong><span style="color:#0d0016;">1、父类静态代码块优先于子类静态代码块执行，且是最早执行 </span></strong>
</div>
<div>
<strong><span style="color:#0d0016;">2、父类实例代码块和父类构造方法紧接着执行 </span></strong>
</div>
<div>
<strong><span style="color:#0d0016;">3、子类的实例代码块和子类构造方法紧接着再执行 </span></strong>
</div>
<div>
<strong><span style="color:#0d0016;">4、第二次实例化子类对象时，父类和子类的静态代码块都将不会再执行</span></strong>
</div>
<div></div>
<div>
<pre><code class="language-java">class Student extends Person{
    public Student(String name,int age) {
        super(name,age);
        System.out.println("Student：构造方法执行");
    }
    {
        System.out.println("Student：实例代码块执行");
    }
    static {
        System.out.println("Student：静态代码块执行");
    }
}
public class TestDemo2 {
    public static void main(String[] args) {
        Student student1 = new Student("张三", 19);
        System.out.println("===========================");
        Student student2 = new Student("李四", 20);
    }
}</code></pre>
<p>执行结果：</p>
<p><img alt="" height="437" src="image\5bf26f716ea247b09a9e7c75e64c5551.png" width="679"/></p>
<h2 id="1.9protected%20%E5%85%B3%E9%94%AE%E5%AD%97%C2%A0"><span style="color:#333333;"><strong>1.9protected </strong></span><span style="color:#333333;"><strong>关键字</strong></span> </h2>
<div>
<span style="color:#333333;">Java</span>
<span style="color:#333333;">中引入了访问限定符，主要限定：类或者类中成员能否在类外或者其 他包中被访问。</span>
</div>
<div>
<img alt="" height="392" src="image\05448cf8be7d4949a57e614a13b391e4.png" width="679"/>
</div>
<p><span style="color:#333333;">父类中不同访问权限的成员，在子类中的可见性又是什么样子的呢？</span></p>
<p>extend01包中</p>
<pre><code class="language-java">// extend01包中
public class B {
    private int a;
    protected int b;
    public int c;
    int d;
}</code></pre>
<p> extend01包中的子类：</p>
<pre><code class="language-java">public class D extends B{
    public void method(){
        super.a = 10; // 编译报错，父类private成员在相同包子类中不可见
        super.b = 20;// 父类中protected成员在相同包子类中可以直接访问
        super.c = 30; // 父类中public成员在相同包子类中可以直接访问
        super.d = 40; // 父类中默认访问权限修饰的成员在相同包子类中可以直接访问
    }
}</code></pre>
<p>extend02包中的子类：</p>
<pre><code class="language-java">public class C extends B {
    public void method(){
        super.a = 10; // 编译报错，父类中private成员在不同包子类中不可见
        super.b = 20; // 父类中protected修饰的成员在不同包子类中可以直接访问
        super.c = 30; // 父类中public修饰的成员在不同包子类中可以直接访问
        super.d = 40; // 父类中默认访问权限修饰的成员在不同包子类中不能直接访问
     }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<p>extend02中的非子类</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        C c = new C();
        c.c = 10;// 父类中public成员在不同包其他类中可以直接访问
        c.d = 20;// 报错：父类中protected成员在不同包其他类中不能直接访问
    }</code></pre>
<p> <span style="color:#333333;">注意：父类中</span><span style="color:#333333;">private</span><span style="color:#333333;">成员变量虽然在子类中不能直接访问，但是也继承到子类中了</span></p>
<h2 id="1.11%20final%20%E5%85%B3%E9%94%AE%E5%AD%97"><span style="color:#333333;"><strong>1.11 final </strong></span><span style="color:#333333;"><strong>关键字</strong></span></h2>
<div>
<span style="color:#333333;">final</span>
<span style="color:#333333;">关键可以用来修饰变量、成员方法以及类。</span>
</div>
<div>
<span style="color:#333333;">1. </span>
<span style="color:#333333;"><strong>修饰变量或字段，表示常量</strong></span>
<span style="color:#333333;"><strong>(</strong></span>
<span style="color:#333333;"><strong>即不能修改</strong></span>
<span style="color:#333333;"><strong>)</strong></span>
</div>
<div>
<pre><code class="language-java">final int a = 10; 
a = 20; // 编译出错</code></pre>
<div>
<span style="color:#333333;">2. </span>
<span style="color:#333333;"><strong>修饰类：表示此类不能被继承 </strong></span>
</div>
<div>
<pre><code class="language-java">final public class Animal {
     ...
}
public class Bird extends Animal {
   ...
}// 编译出错</code></pre>
<div>
<span style="color:#333333;">3. </span>
<span style="color:#333333;"><strong>修饰方法：表示该方法不能被重写</strong></span>
</div>
<div></div>
<h2 id="1.12%20%E7%BB%A7%E6%89%BF%E4%B8%8E%E7%BB%84%E5%90%88"><span style="color:#333333;"><strong>1.12 </strong></span><span style="color:#333333;"><strong>继承与组合</strong></span></h2>
<div>
<span style="color:#333333;">和继承类似</span>
<span style="color:#333333;">, </span>
<span style="color:#333333;">组合也是一种表达类之间关系的方式</span>
<span style="color:#333333;">, </span>
<span style="color:#333333;">也是能够达到代码重用的效果。组合并没有涉及到特殊的语法 (诸如</span>
<span style="color:#333333;"> extends </span>
<span style="color:#333333;">这样的关键字</span>
<span style="color:#333333;">), </span>
<span style="color:#333333;">仅仅是将一个类的实例作为另外一个类的字段。 </span>
</div>
<div></div>
<div>
<div>
<span style="color:#333333;"><strong>继承表示对象之间是</strong></span>
<span style="color:#333333;"><strong>is-a</strong></span>
<span style="color:#333333;"><strong>的关系</strong></span>
<span style="color:#333333;">，比如：狗是动物，猫是动物 </span>
</div>
<div>
<span style="color:#333333;"><strong>组合表示对象之间是</strong></span>
<span style="color:#333333;"><strong>has-a</strong></span>
<span style="color:#333333;"><strong>的关系</strong></span>
<span style="color:#333333;">，比如：汽车有轮胎，发动机，和车载系统等</span>
</div>
<div>
<pre><code class="language-java">// 轮胎类
class Tire{
    // ...
}
// 发动机类
class Engine{
    // ...
}
// 车载系统类
class VehicleSystem{ 
    // ...
}
class Car{
    private Tire tire; // 可以复用轮胎中的属性和方法
    private Engine engine; // 可以复用发动机中的属性和方法
    private VehicleSystem vs; // 可以复用车载系统中的属性和方法 
    // ...
}
// 奔驰是汽车
class Benz extend Car{
 // 将汽车中包含的：轮胎、发送机、车载系统全部继承下来 
}</code></pre>
<p></p>
</div>
</div>
</div>
</div>
</div>
</div>