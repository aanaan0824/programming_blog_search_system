<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<blockquote>
<p> ✅作者简介：大家好我是@每天都要敲代码，一位材料转码农的选手，希望一起努力，一起进步！<br/> 📃个人主页：<a href="https://blog.csdn.net/m0_61933976?spm=1010.2135.3001.5421" title="@每天都要敲代码的个人主页">@每天都要敲代码的个人主页</a></p>
<p> 🔥系列专栏：<a href="https://blog.csdn.net/m0_61933976/category_11820121.html?spm=1001.2014.3001.5482" title="JavaSE从入门到精通">JavaSE从入门到精通</a><br/> 💬推荐一款模拟面试、刷题神器，从基础到大厂面试题👉<a href="https://www.nowcoder.com/link/pc_csdncpt_mtdyqdm_c" title="点击跳转刷题网站进行注册学习">点击跳转刷题网站进行注册学习</a></p>
</blockquote>
<p id="main-toc"><strong>目录</strong></p>
<p id="%F0%9F%A5%85%E7%BC%93%E5%86%B2%E6%B5%81-toc" style="margin-left:0px;"><a href="#%F0%9F%A5%85%E7%BC%93%E5%86%B2%E6%B5%81">🥅缓冲流</a></p>
<p id="1.%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E6%B5%81BufferedReader-toc" style="margin-left:80px;"><a href="#1.%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E6%B5%81BufferedReader">1.字符输入流BufferedReader</a></p>
<p id="2.%E5%AD%97%E7%AC%A6%E8%BE%93%E5%87%BA%E6%B5%81BufferedWriter-toc" style="margin-left:80px;"><a href="#2.%E5%AD%97%E7%AC%A6%E8%BE%93%E5%87%BA%E6%B5%81BufferedWriter">2.字符输出流BufferedWriter</a></p>
<p id="%F0%9F%A5%85%E8%BD%AC%E6%8D%A2%E6%B5%81-toc" style="margin-left:0px;"><a href="#%F0%9F%A5%85%E8%BD%AC%E6%8D%A2%E6%B5%81">🥅转换流</a></p>
<p id="1.OutputStreamWriter-toc" style="margin-left:80px;"><a href="#1.OutputStreamWriter">1.OutputStreamWriter</a></p>
<p id="2.InputStreamReader-toc" style="margin-left:80px;"><a href="#2.InputStreamReader">2.InputStreamReader</a></p>
<p id="%F0%9F%A5%85%E6%95%B0%E6%8D%AE%E6%B5%81-toc" style="margin-left:0px;"><a href="#%F0%9F%A5%85%E6%95%B0%E6%8D%AE%E6%B5%81">🥅数据流</a></p>
<p id="1.DataOutputStream-toc" style="margin-left:80px;"><a href="#1.DataOutputStream">1.DataOutputStream</a></p>
<p id="2.DataInputStream-toc" style="margin-left:80px;"><a href="#2.DataInputStream">2.DataInputStream</a></p>
<p id="%F0%9F%A5%85%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA%E6%B5%81-toc" style="margin-left:0px;"><a href="#%F0%9F%A5%85%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA%E6%B5%81">🥅标准输出流</a></p>
<p id="1.PrintStream-toc" style="margin-left:80px;"><a href="#1.PrintStream">1.PrintStream</a></p>
<p id="2.%E6%97%A5%E5%BF%97%E5%B7%A5%E5%85%B7%E7%B1%BB-toc" style="margin-left:80px;"><a href="#2.%E6%97%A5%E5%BF%97%E5%B7%A5%E5%85%B7%E7%B1%BB">2.日志工具类</a></p>
<p id="%F0%9F%A5%85File%E7%B1%BB%E7%9A%84%E7%90%86%E8%A7%A3-toc" style="margin-left:0px;"><a href="#%F0%9F%A5%85File%E7%B1%BB%E7%9A%84%E7%90%86%E8%A7%A3">🥅File类的理解</a></p>
<p id="1.%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%951-toc" style="margin-left:80px;"><a href="#1.%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%951">1.常用方法1</a></p>
<p id="2.%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%952-toc" style="margin-left:80px;"><a href="#2.%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%952">2.常用方法2</a></p>
<p id="3.listFiles%E6%96%B9%E6%B3%95-toc" style="margin-left:80px;"><a href="#3.listFiles%E6%96%B9%E6%B3%95">3.listFiles方法</a></p>
<p id="%E7%BB%93%E6%9D%9F%E8%AF%AD-toc" style="margin-left:0px;"><a href="#%E7%BB%93%E6%9D%9F%E8%AF%AD">结束语</a></p>
<hr id="hr-toc"/>
<p></p>
<h1 id="%F0%9F%A5%85%E7%BC%93%E5%86%B2%E6%B5%81">🥅缓冲流</h1>
<blockquote>
<p>（1）带有缓冲区的字符输入流；使用这个流的时候<span style="color:#fe2c24;">不需要自定义char数组</span>，或者说不需要自定义byte数组；自带缓冲！</p>
<p>（2）读取数据时，<span style="color:#fe2c24;">可以一次性读取一行</span></p>
<p>（3）这里只讲解字符缓冲流： <strong>java.io.BufferedReader 和 java.io.BufferedWriter</strong>；字节缓冲流使用方法是一样的</p>
<p>（4）<strong>BufferedReader和BufferedWriter都是包装流！</strong></p>
</blockquote>
<h3 id="1.%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E6%B5%81BufferedReader"><strong>1.字符输入流</strong><strong>BufferedReader</strong></h3>
<pre><code class="language-java">package com.bjpowernode.java.io;

import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;

public class BufferedReaderTest01 {
    public static void main(String[] args) throws Exception {
        FileReader reader = new FileReader("file");
        // 当一个流的构造方法中需要一个流的时候，这个被传进来的流叫做：节点流。
        // 外部负责包装的这个流，叫做：包装流或者叫做：处理流。
        // FileReader就是一个节点流。BufferedReader就是包装流/处理流。
        BufferedReader br = new BufferedReader(reader); // 只能传字符流

        // 优点：一次能读一行；但不带换行符！
        String s = null;
        while((s = br.readLine()) != null){ // br.readLine()返回的是一个字符串
            System.out.println(s);
        }

        // 关闭流,只需要关闭最外层流就行，里面的节点流会自动关闭。
        br.close();

    }
}
</code></pre>
<h3 id="2.%E5%AD%97%E7%AC%A6%E8%BE%93%E5%87%BA%E6%B5%81BufferedWriter"><strong>2.字符输出流</strong><strong>BufferedWriter</strong></h3>
<pre><code class="language-java">package com.bjpowernode.java.io;

import java.io.*;

public class BufferedWriterTest01 {
    public static void main(String[] args) throws IOException {
        // 创建带有缓冲区的字符输出流
        BufferedWriter writer = new BufferedWriter(new FileWriter("file"));

        // 开始写
        writer.write("hello world!");
        writer.write("\n");
        writer.write("hello kitty!");

        // 刷新
        writer.flush();
        // 关闭最外层
        writer.close();
    }
}
</code></pre>
<p></p>
<h1></h1>
<h1 id="%F0%9F%A5%85%E8%BD%AC%E6%8D%A2%E6%B5%81">🥅转换流</h1>
<h3 id="1.OutputStreamWriter">1.OutputStreamWriter</h3>
<blockquote>
<p>BufferedWriter：带有缓冲的字符输出流。</p>
<p>OutputStreamWriter：转换流</p>
</blockquote>
<pre><code class="language-java">package com.bjpowernode.java.io;

import java.io.*;

public class BufferedWriterTest01 {
    public static void main(String[] args) throws IOException {
        // 创建带有缓冲区的字符输出流
        BufferedWriter writer = new BufferedWriter(new FileWriter("file"));

        // 如果想要使用字节输出流，还是需要OutputStreamWriter进行流的转换
        // 如果使用的是字节流
        OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream("file"));
        BufferedWriter writer1 = new BufferedWriter(osw);
        
        // 合并在一起
        BufferedWriter writer1 = new BufferedWriter(new OutputStreamWriter
        (new FileOutputStream("file")));

        // 开始写
        writer.write("hello world!");
        writer.write("\n");
        writer.write("hello kitty!");

        // 刷新
        writer.flush();
        // 关闭最外层
        writer.close();
    }
}
</code></pre>
<h3></h3>
<h3 id="2.InputStreamReader">2.InputStreamReader</h3>
<blockquote>
<p>BufferedReader(reader)，里面只能传字符流；那如果是字节流怎么办呢？</p> 需要使用转换流：InputStreamReader，把将字节流转换成字符流
</blockquote>
<pre><code class="language-java">package com.bjpowernode.java.io;

import java.io.*;

public class BufferedReaderTest02 {
    public static void main(String[] args) {

        FileInputStream fis = null;
        try {
            // 字节流
            fis = new FileInputStream("file");
            // 通过转换流转换（InputStreamReader将字节流转换成字符流）
            // fis是节点流。reader是包装流。
            InputStreamReader reader = new InputStreamReader(fis);
            // 把转换成字符流的字节流，传过来
            // reader是节点流。br是包装流。
            BufferedReader br = new BufferedReader(reader);

            // 上面进行合并
            BufferedReader br1 = new BufferedReader(new InputStreamReader(new FileInputStream("file")));

            // 进行打印
            String s = null;
            while((s = br1.readLine()) != null){
                System.out.println(s);
            }

            // 关闭
            br.close(); // 关闭最外层

        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (fis != null) {
                try {
                    fis.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
</code></pre>
<p></p>
<h1></h1>
<h1 id="%F0%9F%A5%85%E6%95%B0%E6%8D%AE%E6%B5%81">🥅数据流</h1>
<h3 id="1.DataOutputStream"><strong>1.DataOutputStream</strong></h3>
<blockquote>
<p>（1）java.io.DataOutputStream：数据专属的流；也是一个包装流！<br/> （2）这个流可以<span style="color:#fe2c24;">将数据连同数据的类型一并写入文件</span>。<br/> （3）注意：这个文件不是普通文本文档。（这个文件使用记事本打不开）</p>
</blockquote>
<pre><code class="language-java">package com.bjpowernode.java.io;

import java.io.DataOutputStream;
import java.io.FileOutputStream;

public class DataOutputStreamTest01 {
    public static void main(String[] args) throws Exception{
        // 创建数据专属的字节输出流（写）
        DataOutputStream dos = new DataOutputStream(new FileOutputStream("file")); //生成的这个文件，记事本打不开
        // 写数据
        byte b = 100;
        short s = 200;
        int i = 300;
        long l = 400L;
        float f = 3.0F;
        double d = 3.14;
        boolean sex = false;
        char c = 'a';
        // 写；把数据以及数据的类型一并写入到文件当中
       dos.writeByte(b);
       dos.writeShort(s);
       dos.writeInt(i);
       dos.writeLong(l);
       dos.writeFloat(f);
       dos.writeDouble(d);
       dos.writeBoolean(sex);
       dos.writeChar(c);

        // 刷新
        dos.flush();
        
        // 关闭最外层
        dos.close();
    }
}
</code></pre>
<h3></h3>
<h3 id="2.DataInputStream"><strong>2.DataInputStream</strong></h3>
<blockquote>
<p>（1）DataInputStream：数据字节输入流。<br/> （2）DataOutputStream写的文件，只能使用DataInputStream去读。并且读的时候你需要提前知道写入的顺序；读的顺序需要和写的顺序一致。才可以正常取出数据<strong>。</strong></p>
</blockquote>
<pre><code class="language-java">package com.bjpowernode.java.io;

import java.io.DataInputStream;
import java.io.FileInputStream;

public class DataInputStreamTest01 {
    public static void main(String[] args) throws Exception {
        // 创建数据专属的字节输入流（读）
        DataInputStream dis = new DataInputStream(new FileInputStream("file"));
        // 开始读
        byte b = dis.readByte();
        short s = dis.readShort();
        int i = dis.readInt();
        long l = dis.readLong();
        float f = dis.readFloat();
        double d = dis.readDouble();
        boolean sex = dis.readBoolean();
        char c = dis.readChar();
        // 打印

        System.out.println(b);
        System.out.println(s);
        System.out.println(i);
        System.out.println(l);
        System.out.println(f);
        System.out.println(d);
        System.out.println(sex);
        System.out.println(c);

        // 关闭流
        dis.close();
    }
}
</code></pre>
<h1 id="%C2%A0"></h1>
<h1></h1>
<h1 id="%F0%9F%A5%85%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA%E6%B5%81">🥅标准输出流</h1>
<h3 id="1.PrintStream">1.PrintStream</h3>
<blockquote>
<p>（1）jva.io.PrintStream：标准的字节输出流。默认输出到控制台。<br/> （2）标准输出流<strong>不需要手动close()关闭</strong>。</p>
<p>（3）可以<span style="color:#fe2c24;">通过System.setOut()方法改变输出流的方向</span></p>
</blockquote>
<pre><code class="language-java">package com.bjpowernode.java.io;

import java.io.FileOutputStream;
import java.io.PrintStream;

public class PrintStreamTest {
    public static void main(String[] args) throws Exception {
        System.out.println("hello world");
        // 实际上上述代码可以拆分成
        PrintStream ps = System.out;
        ps.println("hello world");

        // 可以改变标准输出流的输出方向；
        // 例如：标准输出流不在指向控制台，指向log文件
        PrintStream printStream = new PrintStream(new FileOutputStream("log"));
        // 修改输出方向
        System.setOut(printStream);

        // 输出
        System.out.println("Hello World"); //不会再输出到控制台，而是到log文件

    }
}
</code></pre>
<h3 id="2.%E6%97%A5%E5%BF%97%E5%B7%A5%E5%85%B7%E7%B1%BB"><strong>2.日志工具类</strong></h3>
<blockquote>
<p>那么标准输出流PrintStream有什么用呢？我们不妨写一个简单的日志工具类！</p>
</blockquote>
<p><strong>日志框架</strong></p>
<pre><code class="language-java">package com.bjpowernode.java.io;

import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.PrintStream;
import java.text.SimpleDateFormat;
import java.util.Date;

// 日志工具
public class Logger {
    // 记录日志的方法
   public static void log(String msg) {
       try {
           PrintStream out = new PrintStream(new FileOutputStream("log.txt",true));
           // 改变流的方向
           System.setOut(out);
           // 获取系统当前时间
           Date nowDate = new Date();
           // 格式类型转换
           SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss SSS");
           String myNowdate = sdf.format(nowDate);
           // 打印
           System.out.println(myNowdate+":"+msg);

       } catch (FileNotFoundException e) {
           e.printStackTrace();
       }

   }
}
</code></pre>
<p><strong>日志测试</strong></p>
<pre><code class="language-java">package com.bjpowernode.java.io;

public class LoggerTest {
    public static void main(String[] args) {
        // 测试日志工具类
        Logger.log("调用了System类的gc()方法，建议启动垃圾回收");
        Logger.log("调用了UserService的doSome()方法");
        Logger.log("用户尝试进行登录，验证失败");

        // 在log.txt打印的结果
       /* 2022-07-22 08:47:49 667:调用了System类的gc()方法，建议启动垃圾回收
        2022-07-22 08:47:49 703:调用了UserService的doSome()方法
        2022-07-22 08:47:49 714:用户尝试进行登录，验证失败*/
    }
}
</code></pre>
<p></p>
<h1></h1>
<h1 id="%F0%9F%A5%85File%E7%B1%BB%E7%9A%84%E7%90%86%E8%A7%A3">🥅File类的理解</h1>
<blockquote>
<p><strong>java.io.File</strong><br/>     1、File类和四大家族没有关系，所以File类不能完成文件的读和写。<br/>     2、File对象代表什么？<br/>         文件和目录路径名的抽象表示形式。<br/>         C:\Drivers 这是一个File对象<br/>         C:\Drivers\Lan\Realtek\Readme.txt 也是File对象。<br/>         <span style="color:#fe2c24;">一个File对象有可能对应的是目录，也可能是文件</span>；File只是一个路径名的抽象表示形式；<strong>不能通过File完成文件的读和写</strong></p>
</blockquote>
<h3 id="1.%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%951"><strong>1.常用方法1</strong></h3>
<blockquote>
<p></p>
<p>（1）<span style="color:#fe2c24;">exists()</span>方法：判断当前文件是否存在</p>
<p>（2）<span style="color:#fe2c24;">creatNewFile()</span>方法：以文件的形式创建出来</p>
<p>（3）<span style="color:#fe2c24;">mkdir()</span>方法：以目录的形式创建出来；<span style="color:#fe2c24;">创建多重目录mkdirs()</span>方法</p>
<p>（4）<strong>获取当前文件的父路径</strong>：</p>
<p>        方法1： 使用<span style="color:#fe2c24;">getParent()</span>，返回的是一个<span style="color:#fe2c24;">String</span><br/>         方法2：使用<span style="color:#fe2c24;">getParentFile()</span>，返回的是一个<span style="color:#fe2c24;">File</span>；和上面效果是一样的</p>
<p>（5）<span style="color:#fe2c24;">getAbsolutePath()</span>方法：获取当前文件的绝对路径</p>
</blockquote>
<pre><code class="language-java">package com.bjpowernode.java.io;

import java.io.File;

public class FileTest01 {
    public static void main(String[] args) throws Exception {
        // 创建File对象
        File f1 = new File("D:\\file");
        // 1、判断当前文件是否存在；exists()方法
        System.out.println(f1.exists()); // false

        // 2、如果D:\file不存在，则以文件的形式创建出来；createNewFile()方法
        if (!f1.exists()) {
            f1.createNewFile();
        }

        // 3、如果D:\file不存在，则以目录的形式创建出来；mkdir()方法
        if (!f1.exists()) {
            f1.mkdir();
        }

        // 4、创建多重目录；mkdirs()方法
        File f2 = new File("D:/a/b/c/d");
        if (!f2.exists()) {
            f2.mkdirs();
        }

        // 5、获取当前文件的父路径
        File f3 = new File("D:\\python学习\\PyCharm Community Edition 2021.2.2");
        // 第一种：使用getParent()，返回的是一个String
        String parentPath = f3.getParent();
        System.out.println(parentPath); // D:\python学习
        // 第二种：使用getParentFile()，返回的是一个File；效果是一样的
        File parentFile = f3.getParentFile();
        System.out.println(parentFile); // D:\python学习

        // 6、获取当前文件的绝对路径
        File f4 = new File("file");
        System.out.println(f4.getAbsolutePath()); // C:\Users\86177\IdeaProjects\JavaSe1\file

    }
}
</code></pre>
<h3></h3>
<h3 id="2.%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%952"><strong>2.常用方法2</strong></h3>
<blockquote>
<p>（1）<span style="color:#fe2c24;">getName()</span>：获取当前文件的名字</p>
<p>（2）<span style="color:#fe2c24;">isDirectory()</span>：判断是否是一个目录</p>
<p>（3）<span style="color:#fe2c24;">isFile()</span>：判断是否是一个文件</p>
<p>（4）<span style="color:#fe2c24;">lastModified()</span>：获取文件最后一次修改时间；得到的是毫秒数，返回long型</p>
<p>（5）<span style="color:#fe2c24;">length()</span>：获取文件大小，结果是字节</p>
</blockquote>
<pre><code class="language-java">package com.bjpowernode.java.io;

import java.io.File;
import java.text.SimpleDateFormat;
import java.util.Date;

public class FileTest02 {
    public static void main(String[] args) {
        File  f1 = new File("C:\\Java学习\\javaSE学习\\2.1JavaSE进阶笔记\\javase\\Copy02.java");
        // 1、获取文件名，getName()方法
        System.out.println("文件名:"+f1.getName()); // 文件名:Copy02.java

        // 2、判断是否是一个目录，isDirectory()方法
        System.out.println(f1.isDirectory()); // false

        // 3、判断是否是一个文件，isFile()方法
        System.out.println(f1.isFile()); // true

        // 4、获取文件最后一次修改时间，lastModified()方法
        // 得到的是毫秒数
        long modifytTime = f1.lastModified();
        // 将总毫秒数转换成日期
        Date date = new Date(modifytTime);
        // 格式化
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss SSS");
        System.out.println(sdf.format(date)); //2020-03-11 14:35:46 154

        // 5、获取文件大小，length()方法
        System.out.println(f1.length()); //1490 字节
        
    }
}
</code></pre>
<p></p>
<h3 id="3.listFiles%E6%96%B9%E6%B3%95"><strong>3.</strong>listFiles方法</h3>
<blockquote>
<p>File中的<span style="color:#fe2c24;">listFiles方法</span>；<strong>获取当前目录下所有的子文件</strong>；<span style="color:#fe2c24;"><strong>返回的是一个File[]数组</strong></span></p>
</blockquote>
<pre><code class="language-java">package com.bjpowernode.java.io;

import java.io.File;

public class FileTest03 {
    public static void main(String[] args) {
        File f = new File("C:\\Java学习\\javaSE学习\\2.1JavaSE进阶笔记\\javase\\chapter15\\src");
        // 调用listFiles()方法，返回的是一个File[]数组
        File[] files = f.listFiles();
        // 用增强for循环打印
        for(File file :files){
            System.out.println(file.getAbsolutePath()); // 获取所有子目录的绝对路径
            System.out.println(file.getName()); //获取所有子目录的文件名
        }

    }
}
</code></pre>
<h1 id="%E7%BB%93%E6%9D%9F%E8%AF%AD"></h1>
<h1>结束语</h1>
<blockquote>
<p>今天的分享就到这里啦！快快通过下方链接注册加入刷题大军吧！各种大厂面试真题在等你哦！</p>
<p> 💬刷题神器，从基础到大厂面试题👉<a href="https://www.nowcoder.com/link/pc_csdncpt_mtdyqdm_c" title="点击跳转刷题网站">点击跳转刷题网站</a></p>
</blockquote>
<p><img alt="" height="511" src="image\184068dc41e94efbb14e555f972eaa17.png" width="1200"/></p>
<p></p>
<p></p>
</div>
</div>