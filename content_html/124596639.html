<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<p id="main-toc"><strong>目录</strong></p>
<p id="%E4%B8%80%E3%80%81%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD-toc" style="margin-left:80px;"><a href="#%E4%B8%80%E3%80%81%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD">一、函数重载</a></p>
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A01%E3%80%81%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E6%A6%82%E5%BF%B5-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A01%E3%80%81%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E6%A6%82%E5%BF%B5">        1、函数重载概念</a></p>
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A02%E3%80%81%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E6%B3%A8%E6%84%8F%E7%82%B9-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A02%E3%80%81%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E6%B3%A8%E6%84%8F%E7%82%B9">        2、函数重载注意点</a></p>
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A03%E3%80%81%E9%97%AE%E9%A2%98%EF%BC%9A%E4%B8%BA%E4%BD%95C%E8%AF%AD%E8%A8%80%E4%B8%8D%E6%94%AF%E6%8C%81%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%EF%BC%8C%E5%8F%8D%E5%80%92C%2B%2B%E5%8F%AF%E4%BB%A5%EF%BC%9F-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A03%E3%80%81%E9%97%AE%E9%A2%98%EF%BC%9A%E4%B8%BA%E4%BD%95C%E8%AF%AD%E8%A8%80%E4%B8%8D%E6%94%AF%E6%8C%81%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%EF%BC%8C%E5%8F%8D%E5%80%92C%2B%2B%E5%8F%AF%E4%BB%A5%EF%BC%9F">        3、问题：为何C语言不支持函数重载，反倒C++可以？</a></p>
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0Linux%E7%8E%AF%E5%A2%83%E4%B8%8B%E6%BC%94%E7%A4%BA%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0Linux%E7%8E%AF%E5%A2%83%E4%B8%8B%E6%BC%94%E7%A4%BA%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD">              Linux环境下演示函数重载</a></p>
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E5%9B%9E%E9%A1%BE%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E5%9B%9E%E9%A1%BE%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5">              回顾程序的编译链接</a></p>
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E9%87%87%E7%94%A8C%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E5%99%A8%E7%BC%96%E8%AF%91%E5%90%8E%E7%BB%93%E6%9E%9C-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E9%87%87%E7%94%A8C%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E5%99%A8%E7%BC%96%E8%AF%91%E5%90%8E%E7%BB%93%E6%9E%9C">              采用C语言编译器编译后结果</a></p>
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0gcc%E7%9A%84%E5%87%BD%E6%95%B0%E5%90%8D%E4%BF%AE%E9%A5%B0%E8%A7%84%E5%88%99-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0gcc%E7%9A%84%E5%87%BD%E6%95%B0%E5%90%8D%E4%BF%AE%E9%A5%B0%E8%A7%84%E5%88%99">                      gcc的函数名修饰规则</a></p>
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E9%87%87%E7%94%A8C%2B%2B%E7%BC%96%E8%AF%91%E5%99%A8%E7%BC%96%E8%AF%91%E5%90%8E%E7%BB%93%E6%9E%9C-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E9%87%87%E7%94%A8C%2B%2B%E7%BC%96%E8%AF%91%E5%99%A8%E7%BC%96%E8%AF%91%E5%90%8E%E7%BB%93%E6%9E%9C">              采用C++编译器编译后结果</a></p>
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0g%2B%2B%E7%9A%84%E5%87%BD%E6%95%B0%E5%90%8D%E4%BF%AE%E9%A5%B0%E8%A7%84%E5%88%99-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0g%2B%2B%E7%9A%84%E5%87%BD%E6%95%B0%E5%90%8D%E4%BF%AE%E9%A5%B0%E8%A7%84%E5%88%99">                      g++的函数名修饰规则</a></p>
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E7%BB%93%E8%AE%BA-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E7%BB%93%E8%AE%BA">              结论</a></p>
<p id="%E4%BA%8C%E3%80%81extern%22C%22-toc" style="margin-left:80px;"><a href="#%E4%BA%8C%E3%80%81extern%22C%22">二、extern"C"</a></p>
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A01%E3%80%81C%2B%2B%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8C%E7%9A%84%E9%9D%99%E6%80%81%E5%BA%93-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A01%E3%80%81C%2B%2B%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8C%E7%9A%84%E9%9D%99%E6%80%81%E5%BA%93">        1、C++如何调用C的静态库</a></p>
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E5%BB%BA%E7%AB%8BC%E7%9A%84%E9%9D%99%E6%80%81%E5%BA%93-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E5%BB%BA%E7%AB%8BC%E7%9A%84%E9%9D%99%E6%80%81%E5%BA%93">              建立C的静态库</a></p>
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E5%9C%A8C%2B%2B%E5%B7%A5%E7%A8%8B%E9%87%8C%E9%85%8D%E7%BD%AE%E9%93%BE%E6%8E%A5C%E7%9A%84%E9%9D%99%E6%80%81%E5%BA%93%E7%9B%AE%E5%BD%95-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E5%9C%A8C%2B%2B%E5%B7%A5%E7%A8%8B%E9%87%8C%E9%85%8D%E7%BD%AE%E9%93%BE%E6%8E%A5C%E7%9A%84%E9%9D%99%E6%80%81%E5%BA%93%E7%9B%AE%E5%BD%95">              在C++工程里配置链接C的静态库目录</a></p>
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B">              调用过程</a></p>
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A02%E3%80%81C%E5%A6%82%E4%BD%95%E8%B0%83C%2B%2B%E7%9A%84%E9%9D%99%E6%80%81%E5%BA%93-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A02%E3%80%81C%E5%A6%82%E4%BD%95%E8%B0%83C%2B%2B%E7%9A%84%E9%9D%99%E6%80%81%E5%BA%93">        2、C如何调C++的静态库</a></p>
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E5%BB%BA%E7%AB%8BC%2B%2B%E7%9A%84%E9%9D%99%E6%80%81%E5%BA%93-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E5%BB%BA%E7%AB%8BC%2B%2B%E7%9A%84%E9%9D%99%E6%80%81%E5%BA%93">              建立C++的静态库</a></p>
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E5%9C%A8C%E5%B7%A5%E7%A8%8B%E9%87%8C%E9%85%8D%E7%BD%AE%E9%93%BE%E6%8E%A5C%2B%2B%E7%9A%84%E9%9D%99%E6%80%81%E5%BA%93%E7%9B%AE%E5%BD%95-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E5%9C%A8C%E5%B7%A5%E7%A8%8B%E9%87%8C%E9%85%8D%E7%BD%AE%E9%93%BE%E6%8E%A5C%2B%2B%E7%9A%84%E9%9D%99%E6%80%81%E5%BA%93%E7%9B%AE%E5%BD%95">              在C工程里配置链接C++的静态库目录</a></p>
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B">              调用过程</a></p>
<hr/>
<h3>一、函数重载</h3>
<blockquote>
<p>自然语言中，一个词可以有多重含义，人们可以通过上下文来判断该词真实的含义，即该词被重载了。比如：以前有一个笑话，国有两个体育项目大家根本不用看，也不用担心。一个是乒乓球，一个是男足。前者是“谁也赢不了！”，后者是“谁也赢不了！”</p>
</blockquote>
<h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A01%E3%80%81%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E6%A6%82%E5%BF%B5">1、函数重载概念</h3>
<blockquote>
<p><strong>函数重载:</strong>是函数的一种特殊情况。C语言不支持函数重载，<span style="color:#956fe7;">而C++允许在同一作用域中声明几个功能类似的同名函数</span>，这些<span style="color:#fe2c24;">同名函数的形参列表(<strong>参数个数</strong> 或 <strong>类型 </strong>或 <strong>顺序</strong>)必须不同</span>，常用来处理实现功能类似数据类型不同的问题</p>
<ul><li><span style="background-color:#fbd4d0;">参数类型不同：</span></li></ul>
<p><img alt="" height="343" src="image\b491a8a5b70549a083d70cde04f87aea.png" width="786"/></p>
<ul><li><span style="background-color:#fbd4d0;">参数个数不同：</span></li></ul>
<p><img alt="" height="378" src="image\be633d62a49d4f5c83391f7f2bed8909.png" width="614"/></p>
<ul><li><span style="background-color:#fbd4d0;">顺序不同 </span></li></ul>
<p><img alt="" height="372" src="image\0afb60d562d6406fb49927ee313ab8e5.png" width="914"/></p>
</blockquote>
<h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A02%E3%80%81%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E6%B3%A8%E6%84%8F%E7%82%B9">2、函数重载注意点</h3>
<blockquote>
<p><span style="color:#fe2c24;"><strong>仅仅修改函数返回类型不是函数重载</strong></span></p>
<p>因为无法区分你要调用的是谁</p>
<p><img alt="" height="359" src="image\ec86599e85bf44c69a21d2e616ad9f50.png" width="885"/></p>
</blockquote>
<h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A03%E3%80%81%E9%97%AE%E9%A2%98%EF%BC%9A%E4%B8%BA%E4%BD%95C%E8%AF%AD%E8%A8%80%E4%B8%8D%E6%94%AF%E6%8C%81%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%EF%BC%8C%E5%8F%8D%E5%80%92C%2B%2B%E5%8F%AF%E4%BB%A5%EF%BC%9F">3、问题：为何C语言不支持函数重载，反倒C++可以？</h3>
<blockquote>
<p>有了函数重载，确实要比不支持函数重载的C语言上方便了许多，这难免会有人提问到：</p>
<ol><li><span style="color:#956fe7;">既然函数重载这么好，为何C语言就不行呢？</span></li><li><span style="color:#956fe7;">C++又是如何支持函数重载的呢？</span></li></ol>
<p>接下来，我就展开来讨论下：首先，为了更好的显现出其具体操作过程，我将在Linux的环境下向大家展示其具体过程。其次，解释其原理需要借助我们之前讲解过的程序的编译链接，所以下文我也会带着再简要讲解下。所以，正文开始：</p>
</blockquote>
<h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0Linux%E7%8E%AF%E5%A2%83%E4%B8%8B%E6%BC%94%E7%A4%BA%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD">Linux环境下演示函数重载</h3>
<blockquote>
<ul><li><span style="background-color:#fbd4d0;">gcc编译 -- C语言版本</span></li></ul>
<p>首先，我们在Linux环境下创建3个目录：<span style="color:#956fe7;"><strong>f.h</strong></span>、<strong><span style="color:#956fe7;">f.c</span></strong>、<span style="color:#956fe7;"><strong>test.c</strong></span>。来分别进行声明、定义、实现。</p>
<p>注意后缀，都是以.c命名，这说明以下操作是在C语言的情况下进行的</p>
<p><img alt="" height="519" src="image\26f51c9ba44f42b7ba0454bb51fbae1b.png" width="700"/></p>
<p>并且对上述代码编译运行后没有错误，接下来用gcc编译对它生成<span style="color:#956fe7;"><strong>tc</strong></span>可执行程序，用g++编译对它生成<span style="color:#956fe7;"><strong>tcpp</strong></span>可执行程序，并且两个文件编译运行均没错误</p>
<p class="img-center"><img alt="" height="459" src="image\a868607f694d468ca8bcc95d076dee01.png" width="837"/></p>
<p>接下来，我们在原有文件的基础上再写一个函数来确保其是函数重载 </p>
<p><img alt="" height="707" src="image\67094800082445a5895515dd9db829d4.png" width="726"/></p>
<p> 此时我们用gcc对它进行编译：</p>
<p><img alt="" height="472" src="image\44c03ed26b3d463baa5f5cb8c0853ede.png" width="692"/></p>
<p>很明显发生错误，再强调下，<span style="color:#956fe7;">上述操作是在C语言的基础上完成的</span>。这就足矣说明，C语言是不支持函数重载的，想要搞清楚原因前，就要先明白程序的编译链接，看下文：</p>
</blockquote>
<h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E5%9B%9E%E9%A1%BE%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5">回顾程序的编译链接</h3>
<blockquote>
<p>程序的编译链接我在曾经的一篇博文中已详细讲解过，这里直接给出链接：</p>
<p><a class="link-info" href="https://blog.csdn.net/bit_zyx/article/details/122888817" title="程序的环境">程序的环境</a></p>
<p>针对上述的三个目录文件：<span style="color:#956fe7;"><strong>f.h</strong></span>、<strong><span style="color:#956fe7;">f.c</span></strong>、<span style="color:#956fe7;"><strong>test.c</strong></span>，接下来展开讨论：</p>
<p>程序的编译链接分为四大过程：</p>
<ol><li><strong>预处理</strong> -- 头文件展开、宏替换、条件编译、去掉注释。预处理后生成<span style="color:#fe2c24;"><strong>f.i</strong></span>和<span style="color:#fe2c24;"><strong>test.i</strong></span>文件</li><li><strong>编译</strong> -- 检查语法，生成汇编代码。编译后生成<span style="color:#fe2c24;"><strong>f.s</strong></span>和<span style="color:#fe2c24;"><strong>test.s</strong></span>文件</li><li><strong>汇编</strong> -- 把汇编代码转换成二进制的机器码。汇编后生成<span style="color:#fe2c24;"><strong>f.o</strong></span>和<span style="color:#fe2c24;"><strong>test.o</strong></span>文件</li><li><strong>链接</strong> -- 合并段表、符号表的合并和符号表的重定位。<span style="color:#956fe7;">通俗讲就是找调用函数的地址，链接对应上，合并到一起</span></li></ol>
<p></p>
<p>看图：</p>
<ul><li>首先预处理：</li></ul>
<p><img alt="" height="343" src="image\8cc3ad30a66142d38dbe455a68171c29.png" width="1172"/></p>
<ul><li> 其次编译，会生成符号表（记录的是函数定义和函数地址的映射）以及函数调用指令</li></ul>
<p><img alt="" height="194" src="image\69cb8d9abc3941078797b5e46f00074a.png" width="856"/></p>
<p>这里生成了main函数的指令，其中有f，因为还不知道确切的地址，只是有声明，所以先用?表示，接着进入链接，找调用函数的地址，链接对应上，并合并到一起 。随后就在编译形成的符号表里寻找与main函数指令相同的函数名，并找到其地址</p>
</blockquote>
<h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E9%87%87%E7%94%A8C%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E5%99%A8%E7%BC%96%E8%AF%91%E5%90%8E%E7%BB%93%E6%9E%9C">采用C语言编译器编译后结果</h3>
<blockquote>
<p>我们采用如下指令进行编译：</p>
<p><img alt="" height="135" src="image\0c474508149e44d588fd7417e2a57a0d.png" width="523"/></p>
<p>结果如下：</p>
<p><img alt="" height="356" src="image\ca08e641255347ca9d11214dfc87617b.png" width="745"/></p>
</blockquote>
<h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0gcc%E7%9A%84%E5%87%BD%E6%95%B0%E5%90%8D%E4%BF%AE%E9%A5%B0%E8%A7%84%E5%88%99">gcc的函数名修饰规则</h3>
<blockquote>
<p>有没有发现<span style="color:#956fe7;">直接以函数名命名，没有任何其它的修饰</span>，这么做也就注定造成了出现多个相同函数名的时候，在链接时call不知道链接哪个，因为函数名都是一样的，找不到其地址，这也就说明了C语言不支持函数重载，其链接过程的图示和上述图示一样：</p>
<p><img alt="" height="194" src="image\69cb8d9abc3941078797b5e46f00074a.png" width="856"/></p>
</blockquote>
<h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E9%87%87%E7%94%A8C%2B%2B%E7%BC%96%E8%AF%91%E5%99%A8%E7%BC%96%E8%AF%91%E5%90%8E%E7%BB%93%E6%9E%9C">采用C++编译器编译后结果</h3>
<blockquote>
<p>我们采用如下指令编译：</p>
<p><img alt="" height="146" src="image\38dd60b1f6fe4b8290e2e60d2311f291.png" width="619"/></p>
<p>结果如下：</p>
<ul><li><span style="background-color:#fbd4d0;">函数一：</span></li></ul>
<p class="img-center"><img alt="" height="99" src="image\aa21f2bb3be7431284db0a6542f87311.png" width="355"/></p>
<p><img alt="" height="356" src="image\32762989ac18476daf7f1ea5e6da9d80.png" width="876"/></p>
<ul><li><span style="background-color:#fbd4d0;">函数二：</span></li></ul>
<p class="img-center"><img alt="" height="93" src="image\8ad4079708be416ca919c382689aaaa3.png" width="377"/></p>
<p> <img alt="" height="356" src="image\635981544e584a6e9739a817aa868949.png" width="713"/></p>
</blockquote>
<h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0g%2B%2B%E7%9A%84%E5%87%BD%E6%95%B0%E5%90%8D%E4%BF%AE%E9%A5%B0%E8%A7%84%E5%88%99">g++的函数名修饰规则</h3>
<blockquote>
<p>仔细观察C++版本的汇编指令，观察两个不同函数的函数名修饰样式：</p>
<ul><li>一个是<strong><span style="color:#956fe7;">&lt;_Z1fid</span></strong>&gt;:</li><li>另一个是<span style="color:#fe2c24;"><strong>&lt;_Z1fdi</strong></span>&gt;:</li></ul>
<p>有没有发现它把参数类型的首字母带进去了，那也就意味着你的参数的类型不同，个数不同，参数顺序不同都会导致函数名不同</p>
<p>这个时候，C++编译后生成的符号表里以及链接时函数调用指令应该是这个样子：</p>
<p><img alt="" height="442" src="image\7f961938b72048c7aed1a84b2d2b9217.png" width="759"/></p>
<p>这个时候，<span style="color:#956fe7;">C++在链接的过程中，call找的就是其修饰后的函数名，函数名不同，自然不会出错，这就是C++支持函数重载的核心所在</span>，<span style="color:#fe2c24;">而C语言的函数命名规则是根据函数名设定的，函数名相同的话，链接就会出错，找不到确切地址，自然不会支持函数重载</span></p>
<ul><li>再来确定下C++函数名的修饰规则：</li></ul>
<p><span style="color:#fe2c24;"><strong>_Z 函数名长度 函数名 类型首字母</strong></span></p>
<p>而<span style="color:#956fe7;">返回值的不同并不会影响到函数名的修饰规则</span>，<span style="color:#956fe7;">这也就是为什么前面强调的函数返回类型不同不支持函数重载</span></p>
</blockquote>
<h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E7%BB%93%E8%AE%BA">结论</h3>
<blockquote>
<p>C++支持函数重载而C语言不支持是因为函数在内存中的存储方式不相同，<span style="color:#956fe7;"><strong>C语言</strong></span>是<span style="color:#956fe7;">直接以函数名修饰</span>，而<span style="color:#fe2c24;">C++</span>是<span style="color:#fe2c24;">_Z 函数名长度 函数名 类型首字母</span>，导致C++支持重载，而C语言不支持重载。</p>
</blockquote>
<h3 id="%E4%BA%8C%E3%80%81extern%22C%22">二、extern"C"</h3>
<blockquote>
<p>有时候在C++工程中可能需要将某些函数按照C的风格来编译，在函数前加extern "C"，意思是告诉编译器，将该函数按照C语言规则来编译。比如：tcmalloc是google用C++实现的一个项目，他提供tcmallc()和tcfree两个接口来使用，但如果是C项目就没办法使用，那么他就使用extern “C”来解决。</p>
<p>接下来，我就向大家展示下如何在C++和C之间互相调用：</p>
</blockquote>
<h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A01%E3%80%81C%2B%2B%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8C%E7%9A%84%E9%9D%99%E6%80%81%E5%BA%93">1、C++如何调用C的静态库</h3>
<blockquote>
<p>我们以之前写过的队列为例，来演示：</p>
</blockquote>
<h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E5%BB%BA%E7%AB%8BC%E7%9A%84%E9%9D%99%E6%80%81%E5%BA%93">建立C的静态库</h3>
<blockquote>
<p>首先，把我们之前写好的栈拷贝到新项目来：</p>
<p><img alt="" height="949" src="image\1485da9681e4446eaaaeadeff6bd387b.png" width="1200"/></p>
<p>此时编译运行是不通过的（没有调用main函数接口），接下来将其改成静态库试试：</p>
<ul><li>1、右键属性</li></ul>
<p><img alt="" height="998" src="image\752b3f8ddbf94e42bca2c4b35b4d4cda.png" width="740"/></p>
<ul><li>单击配置类型更改为静态库</li></ul>
<p><img alt="" height="684" src="image\c4f37955f0394428945c8d01d9ac64a3.png" width="984"/>此时编译运行，生成.lib后缀的文件</p>
<p><img alt="" height="164" src="image\27e369273e4f4031b95e9c25313ba170.png" width="742"/></p>
<p><img alt="" height="180" src="image\de0fcdc9b75242e693cae104f2c20e7a.png" width="856"/>现在有一个C++的项目，想要调用刚才C语言的静态库，如下：</p>
<p>以括号匹配这道题为例，解决这道题需要用到栈的思想。</p>
<p><img alt="" height="751" src="image\7dd28a9a8ba34c36a903fd625d11a6f0.png" width="1016"/></p>
<p> 现在C++的项目已经创建完毕，该到了调用的时刻了，看下文：</p>
</blockquote>
<h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E5%9C%A8C%2B%2B%E5%B7%A5%E7%A8%8B%E9%87%8C%E9%85%8D%E7%BD%AE%E9%93%BE%E6%8E%A5C%E7%9A%84%E9%9D%99%E6%80%81%E5%BA%93%E7%9B%AE%E5%BD%95">在C++工程里配置链接C的静态库目录</h3>
<blockquote>
<p>首先，最基本的我要先<span style="color:#956fe7;">包头文件</span>，但是自己创建的这个项目工程里并没有栈.h文件，<span style="color:#956fe7;">所以要在文件目录的上层寻找：</span></p>
<p><img alt="" height="922" src="image\77a1e038bd1c4ec3a21aca84b4734dc8.png" width="975"/></p>
<p>此时编译之后就会看到，编译没有问题，但是运行会报一堆错误：</p>
<p><img alt="" height="391" src="image\b0f0ff1a8b2142d69cd775755f2a22aa.png" width="1200"/></p>
<p>为什么会出现运行错误呢？</p>
<p>就是因为我们对C配置了静态库，现在对这个C++工程也要配置下，如下：</p>
<p>首先：</p>
<p><img alt="" height="1003" src="image\ee5682cb9ea7407b92d6545a4ea89b41.png" width="827"/></p>
<p>其次：</p>
<p><img alt="" height="684" src="image\24cd8f158e254a489fcb4f4c8e8cb3ab.png" width="984"/></p>
<p>随后，把附加库目录生成的.lib文件名字放到如图所示位置：</p>
<p><img alt="" height="684" src="image\1b55cc1b378549eb88309ee8ec0e1564.png" width="984"/></p>
<p>此时链接器链接就会链接到它的静态库</p>
<p>此时再编译运行，发现依旧会出错</p>
<p><img alt="" height="924" src="image\c5bad65b512c4421aa3740105f21c565.png" width="1200"/></p>
<p> 但是当我把Stack.c的后缀改为cpp时</p>
<p><img alt="" height="820" src="image\7542092dfc8a4cd9b398264e4abba3b3.png" width="961"/></p>
<p>此时再运行看看：</p>
<p><img alt="" height="880" src="image\83027740206046e49eaeef2870fca9be.png" width="1200"/></p>
<p>此时编译运行通过了，<span style="color:#956fe7;">为什么把Stack_C的后缀改为.cpp就可以通过呢？</span></p>
<p>这里就牵扯到上文谈到的C++和C在汇编中不同的函数名修饰规则了，在C语言中，只有函数名，可是C++有函数类型个数什么的，用原先.c后缀的话就会导致链接出错，<span style="color:#ff9900;">改为后缀.cpp就实现了C++调C++，就没有问题了。</span></p>
<ul><li><span style="color:#fe2c24;">可现在明确指出要用C++调用C，该如何操作呢？</span></li></ul>
<p>见下文：</p>
</blockquote>
<h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B">调用过程</h3>
<blockquote>
<p>此时就要用到我们的extern"C"。要知道C++是兼容C的，它认识C语言的命名规则，</p>
<p><img alt="" height="127" src="image\52361998b44143a2ac066647a7c662d3.png" width="833"/></p>
<p>加上extern"C"后，我Stack.h声明的这些东西，都会展开在extern"C"这个括号里面，核心作用就是<span style="color:#956fe7;">告诉编译器，extern "C" 声明的函数，是C库，要用C的方式链接调用</span></p>
<p><img alt="" height="748" src="image\2b5f0733c6be4ffaa192e9335a7cd1b9.png" width="795"/></p>
<p>此时我再运行下看看：</p>
<p><img alt="" height="857" src="image\190ffa1af701460fa90d2d780c9ddc6c.png" width="1107"/></p>
<p>此时发现就没有任何问题了，这就成功实现了C++调用C。 </p>
</blockquote>
<h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A02%E3%80%81C%E5%A6%82%E4%BD%95%E8%B0%83C%2B%2B%E7%9A%84%E9%9D%99%E6%80%81%E5%BA%93">2、C如何调C++的静态库</h3>
<blockquote>
<p>实现了C++调C，接下来实现下C调C++。</p>
</blockquote>
<h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E5%BB%BA%E7%AB%8BC%2B%2B%E7%9A%84%E9%9D%99%E6%80%81%E5%BA%93">建立C++的静态库</h3>
<blockquote>
<p>老样子，依旧是新建一个空工程，还是以栈为例，把原先写的栈拷贝到新工程，不过此工程是封给C++的，这里我们要先把此工程配置为静态库。</p>
<p><img alt="" height="859" src="image\c5dc39be40224274938c60aac7f1b227.png" width="813"/>首先 </p>
<p><img alt="" height="986" src="image\902a093da6454e83bd31dfac375506e8.png" width="702"/></p>
<p>其次，改为静态库：</p>
<p><img alt="" height="684" src="image\5185dc2fa267451ab0accfd01ac7b58c.png" width="984"/></p>
<p>此时编译运行：</p>
<p><img alt="" height="166" src="image\fd0865adced04868832c648a0556c267.png" width="749"/></p>
<p>可以发现在如下的目录下生成.lib后缀的文件</p>
<p><img alt="" height="189" src="image\8a0a75a2232d4570a67de2fe49d7ff77.png" width="900"/></p>
<p> 此时配置静态库就完成了。</p>
</blockquote>
<h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E5%9C%A8C%E5%B7%A5%E7%A8%8B%E9%87%8C%E9%85%8D%E7%BD%AE%E9%93%BE%E6%8E%A5C%2B%2B%E7%9A%84%E9%9D%99%E6%80%81%E5%BA%93%E7%9B%AE%E5%BD%95">在C工程里配置链接C++的静态库目录</h3>
<blockquote>
<p>接着，创建一个C的项目：</p>
<p><img alt="" height="810" src="image\45c8d3d403534f3b9dd1fba927416964.png" width="1185"/></p>
<p>第一步依旧是把头文件包上，依然是去上层目录寻找：</p>
<p><img alt="" height="880" src="image\b8d72dc73c3741f49eda4ebb44101756.png" width="939"/></p>
<p>此时你会发现，编译没有错误，其实这里的编译是有问题的，这里链接的其实是C的库，这个时候是C调C，这里我们需要重新配置下链接库目录。</p>
<p><img alt="" height="684" src="image\1f0b58e4f7e7409894ef6e08a0693c12.png" width="984"/></p>
<p>随后，再把Stack_CPP.lib拷贝到附加依赖项的前面：</p>
<p><img alt="" height="684" src="image\7059a31c914247c9be15436940873505.png" width="984"/></p>
<p>此时编译运行依旧会报错</p>
<p><img alt="" height="888" src="image\087112d907e545e8897f4ca214f5fc02.png" width="957"/></p>
<p>此时就是链接错误</p>
<p>依旧是跟C++的函数名修饰规则有关，<span style="color:#956fe7;">C语言是没有修饰的，而C++是修饰过的，这里当然会出现链接错误。</span></p>
<p>这里的解决方案也并不是像C++那样仅仅加个extern"C"就可以解决的，因为<span style="color:#956fe7;">extern"C"只是在C++支持，C语言不支持。</span></p>
<p>具体如何操作呢？<span style="color:#fe2c24;"><strong>只需要在extern"C"的基础上加上条件编译即可解决</strong></span>，具体过程见下文：</p>
</blockquote>
<h3>调用过程</h3>
<blockquote>
<p>这里我们针对Stack_CPP静态库进行修改，这里有两种方法：</p>
<ul><li><span style="background-color:#fbd4d0;">法一：在Stack.h文件声明的所有函数前加上extern"C"</span></li></ul>
<p><img alt="" height="766" src="image\5b180f2d28384f57ba9361792a153882.png" width="915"/></p>
<p>在C++这个工程里面对每一个声明加上extern "C"是为了告诉C++这些函数要用C的方式去编译，此时我到C工程项目里面去编译运行：</p>
<p><img alt="" height="580" src="image\ba27ff59d8944eefa699140885046acf.png" width="923"/></p>
<p>发现又出错了，这又是为什么呢？（<span style="color:#956fe7;">头文件展开出错</span>）</p>
<p>很简单：在这个C的项目前面我们包了头文件Stack.h，包上的这个头文件中里面就加上了我们先前的extern "C"，此时出错不理所应当，因为C语言不支持extern"C"</p>
<p>此时我们针对C++工程巧用<span style="color:#fe2c24;"><strong>条件编译</strong></span>：</p>
<p><img alt="" height="710" src="image\9decf62b386145f49bb935036fb60f02.png" width="889"/></p>
<p>解释下此图红框框里的意思：</p>
<p><span style="color:#956fe7;">如若满足C++的标准，那么就把EXTERN_C替换成extern"C"</span>，让其在C++工程中将这些函数用C语言的标准去访问，<span style="color:#956fe7;">如若不满足C++标准，那么就把EXTERN_C看为空，啥也没有</span>，这样在C项目工程那链接的时候，根本不会出现EXTERN_C，又满足了链接要求</p>
<p>我们在C项目工程里编译运行看看：</p>
<p><img alt="" height="857" src="image\8fc3e70054cb4cde924233debca7ff5b.png" width="1057"/></p>
<p>编译运行成功了，是不是非常神奇。 不得不在这感慨一句条件编译学到现在没想到是在C调C++的时候体现出来了。</p>
<p>当然其实这里还有一种更为简洁的写法，看下文：</p>
<ul><li><span style="background-color:#fbd4d0;">法二：</span></li></ul>
<p>为了避免重复写EXTERN_C，我们可以这样：</p>
<p>先在C++项目工程里面把声明的函数用extern"C"整体包起来：</p>
<p><img alt="" height="704" src="image\61314bd53cb44bb391280aa2567d3a5d.png" width="871"/></p>
<p>其次，加上条件编译：</p>
<p><img alt="" height="705" src="image\0b61b787173a488aaff495b45346a5fd.png" width="830"/></p>
<p>再对C项目工程编译运行：</p>
<p><img alt="" height="712" src="image\1a5121efc8894f048abf56b59236b9f6.png" width="1104"/></p>
<p>此时编译运行同样是没有任何错误。</p>
<p>此时C调C++就结束了，不得不再次感慨条件编译牛皮！！</p>
</blockquote>
<hr/>
<h3>总结</h3>
<blockquote>
<p>本篇博文旨在强调了函数重载以及其内部原理，详解了为何C++支持函数重载，而C不支持。</p>
<p>此博文另一核心知识点旨在讲述了C++和C之间如何实现互相调用</p>
<p>创作不易、还望给个三连哈~</p>
</blockquote>
</div>
</div>