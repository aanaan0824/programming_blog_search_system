<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<h1></h1>
<h1 id="%E4%B8%80.Vuex%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E5%AE%83%EF%BC%9F">一.Vuex是什么？为什么要用它？</h1>
<blockquote>
<h3 id="%C2%A0vuex%E5%AE%98%E6%96%B9%E8%A7%A3%E9%87%8A"> vuex官方解释</h3>
<p>Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理模式 + 库</strong>。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p>
</blockquote>
<h3 id="%E5%A4%A7%E5%AE%B6%E5%8F%AF%E4%BB%A5%E6%80%9D%E8%80%83%E4%B8%80%E4%B8%8B%EF%BC%8C%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BC%A0%E5%80%BC%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E6%9C%89%E7%88%B6%E5%AD%90%E9%80%9A%E8%AE%AF%EF%BC%8C%E5%85%84%E5%BC%9F%E7%BB%84%E4%BB%B6%E9%80%9A%E8%AE%AF......%E4%BD%86%E6%98%AF%E4%BC%A0%E5%8F%82%E5%AF%B9%E4%BA%8E%E5%A4%9A%E5%B1%82%E5%B5%8C%E5%A5%97%E5%B0%B1%E6%98%BE%E5%BE%97%E9%9D%9E%E5%B8%B8%E7%B9%81%E7%90%90%EF%BC%8C%E4%BB%A3%E7%A0%81%E7%BB%B4%E6%8A%A4%E4%B9%9F%E4%BC%9A%E9%9D%9E%E5%B8%B8%E9%BA%BB%E7%83%A6%E3%80%82%E5%9B%A0%E6%AD%A4vuex%E5%B0%B1%E6%98%AF%E6%8A%8A%E7%BB%84%E4%BB%B6%E5%85%B1%E4%BA%AB%E7%8A%B6%E6%80%81%E6%8A%BD%E5%8F%96%E5%87%BA%E6%9D%A5%E4%BB%A5%E4%B8%80%E4%B8%AA%E5%85%A8%E5%B1%80%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%AE%A1%E7%90%86%EF%BC%8C%E6%8A%8A%E5%85%B1%E4%BA%AB%E7%9A%84%E6%95%B0%E6%8D%AE%E5%87%BD%E6%95%B0%E6%94%BE%E8%BF%9Bvuex%E4%B8%AD%EF%BC%8C%E4%BB%BB%E4%BD%95%E7%BB%84%E4%BB%B6%E9%83%BD%E5%8F%AF%E4%BB%A5%E8%BF%9B%E8%A1%8C%E4%BD%BF%E7%94%A8%E3%80%82">大家可以思考一下，组件之间的传值有哪些？有父子通讯，兄弟组件通讯......但是传参对于多层嵌套就显得非常繁琐，代码维护也会非常麻烦。因此vuex就是把组件共享状态抽取出来以一个全局单例模式管理，把共享的数据函数放进vuex中，任何组件都可以进行使用。</h3>
<h1 id="%E4%BA%8C.%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%88%91%E4%BB%AC%E8%AF%A5%E4%BD%BF%E7%94%A8%E5%AE%83%EF%BC%9F">二.什么时候我们该使用它？</h1>
<blockquote>
<p>Vuex 可以帮助我们管理共享状态，并附带了更多的概念和框架。这需要对短期和长期效益进行权衡。</p>
<p>如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的。确实是如此——如果您的应用够简单，您最好不要使用 Vuex。一个简单的 <a href="https://v3.cn.vuejs.org/guide/state-management.html#%E4%BB%8E%E9%9B%B6%E6%89%93%E9%80%A0%E7%AE%80%E5%8D%95%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86" title="store 模式">store 模式</a>就足够您所需了。但是，如果您需要构建一个中大型单页应用，您很可能会考虑如何更好地在组件外部管理状态，Vuex 将会成为自然而然的选择。</p>
</blockquote>
<h1 id="%E4%B8%89.%E5%AE%89%E8%A3%85">三.安装</h1>
<h3 id="%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A">方法一：</h3>
<p>在脚手架 创建项目时勾选vuex的选项系统会自动创建</p>
<p><img alt="" height="516" src="image\a6c65fdea5f5494491260692f9ccacbc.png" width="1200"/></p>
<h3 id="%C2%A0%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9Anpm%C2%A0%20%E6%88%96Yarn%E5%AE%89%E8%A3%85"> 方法二：npm  或Yarn安装</h3>
<pre><code>npm install vuex@next --save</code></pre>
<p></p>
<pre><code>yarn add vuex@next --save</code></pre>
<p></p>
<h1 id="%E5%9B%9B.%E9%85%8D%E7%BD%AE">四.配置</h1>
<p><span style="color:#fe2c24;">如果采用脚手架方式进行创建，无需任何操作，可以忽略此步骤</span></p>
<p><span style="color:#0d0016;">新建store文件-&gt;index.js，进行如下配置，在mian.js中进行引入</span></p>
<pre><code class="language-javascript">import Vue from 'vue'
import Vuex from 'vuex'

Vue.use(Vuex)

export default new Vuex.Store({
  //数据，相当于data
  state: {
    
  },
  getters: {
    
  },
  //里面定义方法，操作state方发
  mutations: {
    
  },
  // 操作异步操作mutation
  actions: {
    
  },
  modules: {
    
  },
})</code></pre>
<h1 id="%C2%A0main.js%E4%B8%AD"> main.js中</h1>
<h1 id="%E2%80%8B%E7%BC%96%E8%BE%91"><img alt="" height="365" src="image\e0cad56f88b7479da489f31f1819b7b4.png" width="483"/></h1>
<h1 id="%C2%A0%E4%BA%94.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"> 五.核心概念</h1>
<blockquote>
<p>vuex中一共有五个状态 State  Getter  Mutation   Action   Module  下面进行详细讲解</p>
</blockquote>
<h2 id="5.1%C2%A0%20State">5.1  State</h2>
<blockquote>
<p>提供唯一的公共数据源，所有共享的数据统一放到store的state进行储存，相似与data</p>
</blockquote>
<p> 在vuex中state中定义数据，可以在任何组件中进行调用</p>
<pre><code class="language-javascript">import Vue from 'vue'
import Vuex from 'vuex'

Vue.use(Vuex)

export default new Vuex.Store({
  //数据，相当于data
  state: {
    name:"张三",
    age:12,
    count:0
  },
})</code></pre>
<p> <strong>调用：</strong></p>
<p><span style="color:#fe2c24;">方法一：</span></p>
<p>在标签中直接使用</p>
<p><img alt="" height="63" src="image\c08338e0919843ab9a219e176848b0e6.png" width="605"/></p>
<p><span style="color:#fe2c24;"> 方法二：</span></p>
<pre><code>this.$store.state.全局数据名称</code></pre>
<p><span style="color:#fe2c24;">方法三：</span></p>
<p><span style="color:#0d0016;">从vuex中按需导入mapstate函数</span></p>
<pre><code>import { mapState } from "vuex";</code></pre>
<h3 id="%E6%B3%A8%E6%84%8F%EF%BC%9A%E5%BD%93%E5%89%8D%E7%BB%84%E4%BB%B6%E9%9C%80%E8%A6%81%E7%9A%84%E5%85%A8%E5%B1%80%E6%95%B0%E6%8D%AE%EF%BC%8C%E6%98%A0%E5%B0%84%E4%B8%BA%E5%BD%93%E5%89%8D%E7%BB%84%E4%BB%B6computed%E5%B1%9E%E6%80%A7"><span style="color:#fe2c24;">注意：</span><span style="color:#0d0016;">当前组件需要的全局数据，映射为当前组件</span><span style="color:#fe2c24;">computed</span><span style="color:#0d0016;">属性</span></h3>
<p><img alt="" height="107" src="image\aecef30824a64e2086173d2684670307.png" width="624"/></p>
<p> <img alt="" height="98" src="image\7d823b7be6ff483aa77aee9204ac2bf0.png" width="877"/></p>
<h2 id="%C2%A0"></h2>
<h2 id="5.2%20Mutation">5.2 Mutation</h2>
<blockquote>
<p>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的<strong>事件类型 (type)<strong>和一个</strong>回调函数 (handler)</strong>。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数：</p>
</blockquote>
<p><strong> 在vuex中定义：</strong></p>
<p>其中参数state参数是必须的，也可以自己传递一个参数，如下代码，进行计数器的加减操作，加法操作时可以根据所传递参数大小进行相加，减法操作没有传参每次减一</p>
<p><img alt="" height="514" src="image\3bbcbd67e9bf4c839f7a4b450342345b.png" width="538"/></p>
<p><strong>在组件中使用：</strong></p>
<p> 定义两个按钮进行加减操作</p>
<p><img alt="" height="55" src="image\0aa47bfe5bd4432a91b1de33c24a8fb1.png" width="852"/></p>
<p> <span style="color:#fe2c24;">方法一：</span></p>
<blockquote>
<p><span style="color:#fe2c24;">注意：</span><span style="color:#0d0016;">使用</span><span style="color:#fe2c24;">commit</span><span style="color:#0d0016;">触发Mutation操作</span></p>
</blockquote>
<pre><code class="language-javascript">methods:{
//加法
btn(){
this.$store.commit("addcount",10)     //每次加十
}
//减法
btn1(){
this.$store.commit("reduce") 
}
}</code></pre>
<p><span style="color:#fe2c24;">方法二：</span></p>
<p><span style="color:#0d0016;">使用辅助函数进行操作，具体方法同上</span></p>
<p><img alt="" height="272" src="image\7a8e1cd1115c403faa28eda17b27214b.png" width="673"/></p>
<h2 id="%C2%A05.3%C2%A0%20Action%20%E2%80%94%E2%80%94%E8%BF%9B%E8%A1%8C%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C"> 5.3  Action ——进行异步操作</h2>
<blockquote>
<p>Action和Mutation相似，Mutation 不能进行异步操作，若要进行异步操作，就得使用Action</p>
</blockquote>
<p><strong>在vuex中定义：</strong></p>
<p><strong>将上面的减法操作改为异步操作</strong></p>
<p><img alt="" height="271" src="image\27f7cb4d481f492fb57ed7c126fcb908.png" width="618"/></p>
<p> <strong>在组件中使用：</strong></p>
<p><span style="color:#fe2c24;">方法一：</span></p>
<p><span style="color:#0d0016;">直接使用  dispatch触发Action函数</span></p>
<pre><code>this.$store.dispatch("reduce")</code></pre>
<p><span style="color:#fe2c24;">方法二：</span></p>
<p><span style="color:#0d0016;">使用辅助函数</span></p>
<p><img alt="" height="131" src="image\b1aa7e935a9e4029a83ab369f9e959f9.png" width="519"/></p>
<h2 id="%C2%A05.4%20Getter"> 5.4 Getter</h2>
<blockquote>
<p>类似于vue中的computed，进行缓存，对于Store中的数据进行加工处理形成新的数据</p>
</blockquote>
<p> 具体操作类似于前几种，这里不做具体说明</p>
<h2 id="5.5%C2%A0%20Modules">5.5  Modules</h2>
<blockquote>
<p>当遇见大型项目时，数据量大，store就会显得很臃肿</p>
<p>为了解决以上问题，Vuex 允许我们将 store 分割成<strong>模块（module）</strong>。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：</p>
</blockquote>
<p> <img alt="" height="526" src="image\c0452af4b04c44d5b2662530acd1a5c6.png" width="436"/></p>
<p> 默认情况下，模块内部的 action 和 mutation 仍然是注册在<strong>全局命名空间</strong>的——这样使得多个模块能够对同一个 action 或 mutation 作出响应。</p>
<p>如果希望你的模块具有更高的封装度和复用性，你可以通过添加 <code>namespaced: true</code> 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。</p>
<p><img alt="" height="134" src="image\896e825f9246445eb1585ad39ee6fad0.png" width="967"/></p>
<p></p>
</div>
</div>