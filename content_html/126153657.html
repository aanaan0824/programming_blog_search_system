<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="markdown_views prism-tomorrow-night" id="content_views">
<svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
<path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
</svg>
<p></p>
<div class="toc">
<h3>目录</h3>
<ul><li><ul><li><a href="#_2">传统艺能😎</a></li><li><a href="#_19">概念🤔</a></li><li><a href="#_22">定义🤔</a></li><li><a href="#_60">区别🤔</a></li><li><a href="#_65">继承关系🤔</a></li><li><a href="#_84">对象赋值转换🤔</a></li><li><a href="#_130">重定义（隐藏）🤔</a></li><li><a href="#_150">派生类默认构造函数🤔</a></li><li><a href="#_200">友元与静态成员🤔</a></li><li><a href="#_206">菱形继承🤔</a></li><li><a href="#_246">虚拟继承🤔</a></li><li><a href="#_286">原理🤔</a></li></ul>
</li></ul>
</div>
<p></p>
<h2><a id="_2"></a>传统艺能😎</h2>
<p>小编是双非本科大一菜鸟不赘述，欢迎大佬指点江山（QQ：1319365055）<br/> 此前博客<a href="https://blog.51cto.com/">点我！点我！请搜索博主 【知晓天空之蓝】</a></p>
<p><mark>🎉🎉非科班转码社区诚邀您入驻🎉🎉</mark><br/> 小伙伴们，打码路上一路向北，背后烟火，彼岸之前皆是疾苦<br/> <mark>一个人的单打独斗不如一群人的砥砺前行</mark><br/> 这是我和梦想合伙人组建的社区，诚邀各位有志之士的加入！！<br/> 社区用户好文均加精（“标兵”文章字数2000+加精，“达人”文章字数1500+加精）<br/> 直达： <a href="https://bbs.csdn.net/forums/FKBZM?typeId=22226">社区链接点我</a></p>
<p>🎉🎉🎉<font color="orange" size="5">倾力打造转码社区微信公众号🎉🎉🎉<br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/d5a1afe7c7c2424184a62535a1ab2fb2.png#pic_center"/></font></p>
<hr/>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/21809fa755564a8099915854651aac01.png#pic_center"/></p>
<h2><a id="_19"></a>概念🤔</h2>
<p>继承允许我们依据另一个类来定义一个类，它是面向对象程序中最重要的一个概念，当创建了一个类时，不需要重新编写新的成员和成员函数，只需指定新建的类继承一个已有类的成员即可，这样也有功能复用和提高效率的效果。这个已有的类称为<mark>基类或者父类</mark>，新建的类称为<mark>派生类或者子类</mark>。</p>
<h2><a id="_22"></a>定义🤔</h2>
<p>继承定义的格式为：</p>
<blockquote>
<p>class B：public A<br/> {<!-- --><br/> ……<br/> }；</p>
</blockquote>
<p>这里的 B 就是子类对象，A 就是父类对象，比如：</p>
<pre><code class="prism language-c">class student
<span class="token punctuation">{<!-- --></span>
public<span class="token operator">:</span>
	<span class="token keyword">void</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"name:"</span> <span class="token operator">&lt;&lt;</span> name <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"age:"</span> <span class="token operator">&lt;&lt;</span> age <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
protected<span class="token operator">:</span>
	string name <span class="token operator">=</span> <span class="token string">"xx"</span><span class="token punctuation">;</span> 
	<span class="token keyword">int</span> age <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

class me <span class="token operator">:</span>public student
<span class="token punctuation">{<!-- --></span>
protected<span class="token operator">:</span>
	<span class="token keyword">int</span> score<span class="token punctuation">;</span><span class="token comment">//学分</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	me m<span class="token punctuation">;</span>
	m<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>子类 me 复用父类 student 的成员，继承后 student 的成员或者成员函数会成为子类的一部分，基类 private 成员在派生类中是不能被访问，如果基类成员不想在类外直接被访问，但需要在派生类中能访问，就定义为 protected ，可以看出保护成员限定符是因继承才出现的。</p>
<h2><a id="_60"></a>区别🤔</h2>
<p>继承和组合不同，<mark>继承代表了 is-a 关系</mark>，比如 she is a girl ，这里 she 派生类就和 girl 基类构成了继承关系，而<mark>组合代表了 has-a 关系</mark>，比如 she has a boyfriend ，这里 boyfriend 和 she 就是组合关系。<br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/9086f1dadacb42a6ba1633a7598dfb6a.jpeg#pic_center"/></p>
<h2><a id="_65"></a>继承关系🤔</h2>
<p>不同的访问限定符支持不同的继承方式，<font color="blue4" size="4">因此继承方式就分为了三种：public 继承，protected 继承和 private 继承<font color="0" size="3">，因此继承成员也会因为继承方式而有所决策：</font></font></p>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/362a9222ed514fc78ca798af05ae15d9.png#pic_center"/></p>
<p>其实很好记，只需要记住私有类都不可见，而依据访问限定符的权限划分， public &gt; protected &gt; private，两两结合时会遵循“ 弱者优先原则 ”，即以权限低的为标准执行。</p>
<p>假设我们把基类成员的访问限定修饰符改为private，然后在子类内或者在子类外去访问这些 private 成员，再编译代码结果必然报错，<font color="blue4" size="4">但是实际上 private 类中的成员是实打实的被继承下来了，但是由于权限原因不能被访问。<font color="0" size="3">基类private成员在派生类中无论以什么方式继承都是不可见的，这里的不可见是指基类的私有成员还是被继承到了派生类对象中，但是语法上限制派生类对象不管在类里面还是类外面都不能去访问它</font></font></p>
<p>我们在实际运用中一般使用都是 public 继承，几乎很少使用 protetced/private 继承，也不提倡使用后者，因为他们的成员都只能在派生类的类里面使用，实际中扩展维护性不强。</p>
<hr/>
<p><font color="blue4" size="4">在具体情况中还要注意下面这些点（敲黑板~）：</font></p>
<ol><li>派生类的 operator= 必须要调用基类的 operator= 完成基类的复制。</li><li>派生类的析构函数会在被调用完成后自动调用基类的析构函数清理基类成员。因为这样才能保证派生类对象先清理派生类后清理基类的先后顺序。</li><li>派生类对象初始化先调用基类构造再调派生类构造</li><li>派生类对象析构清理先调用派生类析构再调基类的析构 （其实构造和析构的调用特点可看作是一个栈的操作）</li></ol>
<hr/>
<h2><a id="_84"></a>对象赋值转换🤔</h2>
<p>派生类对象可以进行赋值操作，赋值给基类的对象 ，指针或者引用；一般叫他<mark>切片或者切割</mark>，顾名思义就是将派生类中对象切来赋值。</p>
<pre><code class="prism language-c">	base <span class="token operator">=</span> p<span class="token punctuation">;</span><span class="token comment">//派生类直接赋值</span>
	Student<span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token operator">&amp;</span>p<span class="token punctuation">;</span><span class="token comment">//派生类的地址赋给基类指针</span>
	Student<span class="token operator">&amp;</span> quote <span class="token operator">=</span> p<span class="token punctuation">;</span><span class="token comment">//派生类引用赋给基类引用</span>
</code></pre>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/d9c18d2e275040f1b4eb9dc8492c7ab9.png#pic_center"/></p>
<p><font color="orange" size="4">注意，我们说的将派生类引用赋给基类引用并不是类型转换，是语法支持的行为，为什么呢？</font></p>
<p>以例子来说：</p>
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">double</span> b <span class="token operator">=</span> <span class="token number">1.11</span><span class="token punctuation">;</span>
	a <span class="token operator">=</span> b<span class="token punctuation">;</span>
	<span class="token keyword">int</span><span class="token operator">&amp;</span> ret <span class="token operator">=</span> b<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/666d806f1cd7470681a16c8b47cd2d81.png#pic_center"/></p>
<p>当执行这个代码时就会报以上错误，我们类型转换的中间过程实际上是生成了一个中间的临时变量，临时变量属于应该被 const 修饰的常属性变量，但是我们在继承中赋值时并没有使用 const 关键字，所以其本质上就不属于类型转换，属于语法的支持，<mark>当然值得注意的是只有 public 才能切割，而 private 和 protected 不能被切割！！</mark></p>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/23ecff5890624912a019b89af0163476.jpeg#pic_center"/></p>
<p>派生类可以赋值给基类，但是该过程并不可逆，也就是说基类不可以赋值给派生类，原因很简单，派生类完全继承自基类，包含了基类的成员和成员函数以及自己的成员和成员函数，==此时基类类型对于子类类型来说是不完全的！==正所谓强扭的瓜不甜所以强转也是不通过的。</p>
<p>虽然不能强转赋值，但是可以间接强转，我们对指针进行强转可达到目的，<font color="blue4" size="4">基类的指针可以通过强制类型转换赋值给派生类指针，但是为了保证安全必须要基类指针指向派生类指针。<font color="0" size="3">此方法存在越界访问的问题，所以谨慎使用。</font></font></p>
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	student s<span class="token punctuation">;</span>
	me m<span class="token punctuation">;</span>
	me<span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token punctuation">(</span>student<span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>p<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>( 没有强转是会报错哒！)</p>
<h2><a id="_130"></a>重定义（隐藏）🤔</h2>
<p>一个类就是一个域，所以继承中基类和派生类拥有独立的作用域，当父类和子类中有同名的成员时，就会发生重定义机制，我们也称之为隐藏，<font color="blue4" size="4">即子类成员将屏蔽父类对该成员的直接访问<font color="0" size="3">，默认就近原则会直接访问子类的该成员，若需要父类访问，需要指定域名<strong>基类：基类对象</strong>的显示访问。</font></font></p>
<p>如果是成员函数的重定义，只需要函数名相同即可构成重定义，所以在继承体系中建议最好避免同名定义。</p>
<p>总的来说找变量或者函数遵循就近原则，即先局部，再全局，对于如下代码：</p>
<pre><code class="prism language-c"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">//打印1</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token operator">::</span>a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">//打印2</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>就从全局作用域和局部作用域的两次定义说明了作用域的机制。<mark>但是注意，隐藏机制确实存在于子类和父类之间，但是如果父类对象调用成员函数是不会发生隐藏机制的，也就是说父类就是老大哥，隐藏只能限制子类！</mark></p>
<h2><a id="_150"></a>派生类默认构造函数🤔</h2>
<p>子类会自动调用父类的构造函数去初始化父类继承下来的成员，自动调用父类的析构函数去释放，但对于子类自身的成员呢？</p>
<p>该成员无非就是内置类型和自定义类型两种，对于子类成员如果是内置类型，则不做处理，如果是自义定类型就要调用自义定类型的构造函数，不仅构造和析构是如此，拷贝和重载也是一样的。</p>
<p><mark>一句话就是继承下来调用父类去处理，自己的按照普通类基本规则去处理</mark>。但是什么情况下又需要自己写默认成员函数呢？先看下面这个例子：</p>
<pre><code class="prism language-c">class Person
<span class="token punctuation">{<!-- --></span>
public<span class="token operator">:</span>
	<span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> name<span class="token punctuation">)</span><span class="token comment">//这里不给默认构造函数</span>
		<span class="token operator">:</span><span class="token function">_name</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Person"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token operator">~</span><span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"~Person"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
protected<span class="token operator">:</span>
	string name <span class="token operator">=</span> <span class="token string">"吉良吉影"</span><span class="token punctuation">;</span> 
	<span class="token keyword">int</span> age <span class="token operator">=</span> <span class="token number">33</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span><span class="token punctuation">;</span>

class Student <span class="token operator">:</span>public Person
<span class="token punctuation">{<!-- --></span>
protected<span class="token operator">:</span>
	<span class="token keyword">int</span> score<span class="token punctuation">;</span><span class="token comment">//学分</span>
	string s<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Student stu<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>就这段代码来讲是会报错的</p>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/cd874891c0104becb036458a36035485.png#pic_center"/><br/> 原因很简单，父类没有默认构造函数，而继承父类的子类 student 中并没有构造函数，编译器会自动生成一个，然后调用父类的默认构造函数，而此时父类并没有默认构造函数，子类就无法进行初始化报错。</p>
<p>注意<mark>三种情况</mark>需要我们自己写构造函数：</p>
<blockquote>
<ol><li>父类没有默认构造</li><li>子类需要及时释放，需要自己写析构函数</li><li>子类存在浅拷贝问题时，就需要写构造函数和赋值来进行深拷贝</li></ol>
</blockquote>
<h2><a id="_200"></a>友元与静态成员🤔</h2>
<p><mark>友元类不能被继承，也就是说基类友元不能访问子类私有和保护成员</mark>。也就相当于你兄弟的爹不是你的爹。</p>
<p><mark>静态成员不参与继承不被包括在子类中，基类定义的 static 成员，会贯穿整个代码在整个继承体系中只有一份</mark>，他作为全局变量在继承时都可以访问，相同的值相同的空间相同的地址，看似每次都被继承了但是实际上并没有参与其中，因为静态变量属于整个类而不属于任何对象。</p>
<h2><a id="_206"></a>菱形继承🤔</h2>
<p>我们一直谈论的是单继承，即一个子类只有一个直接父类的继承关系，多继承就是一个子类有两个或两个以上的父类</p>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/31db4922aaad484ab9fa4faf8255b253.png#pic_center"/></p>
<p>而<strong>菱形继承</strong>是多继承下的复杂模型，因为 C++ 语法下继承语法本身的不完美性，在复杂化语法时带来了不可避免的缺陷：<font color="blue4" size="4">数据冗余和二义性<font color="0" size="3"></font></font></p>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/576bc0e620704f11afd6396c37bf0a89.png#pic_center"/><br/> <font color="blue4" size="4">二义性：</font></p>
<p>当 A,B 两个父类都被继承到类 C 中，当访问类中的成员时，这样就会引发二义性无法明确知道访问的是哪一个的成员，要解决二义性问题需要显示指定访问哪一个父亲的成员，但是这样依然无法解决数据冗余问题。</p>
<pre><code class="prism language-c">C information<span class="token punctuation">;</span>
information<span class="token punctuation">.</span>name <span class="token operator">=</span> “xxx”<span class="token punctuation">;</span>
information<span class="token punctuation">.</span>A<span class="token operator">::</span>name <span class="token operator">=</span> <span class="token string">"dio"</span><span class="token punctuation">;</span>
information<span class="token punctuation">.</span>B<span class="token operator">::</span>name <span class="token operator">=</span> <span class="token string">"jojo"</span><span class="token punctuation">;</span>
</code></pre>
<p><font color="blue4" size="4">数据冗余：</font></p>
<pre><code class="prism language-c">class test1
<span class="token punctuation">{<!-- --></span>
public<span class="token operator">:</span>
	<span class="token keyword">int</span> a<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
class test2<span class="token operator">:</span>public test1
<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>
class test3 <span class="token operator">:</span>public test1
<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>
class test4 <span class="token operator">:</span>public test2<span class="token punctuation">,</span>public test3
<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>上面菱形继承模型中如果 test1 中成员不是 int ，而是 int [1000000] , 我们跳出这个模型其实 test4 的根本目的就是继承 test1 的 1000000 个数据，但是走完菱形继承会继承两份也就是 2000000 个数据，从而造成数据冗余问题，这样极大造成了空间上的浪费。</p>
<h2><a id="_246"></a>虚拟继承🤔</h2>
<p>为了解决数据冗余和二义性，C++ 采用虚拟继承来解决它们。虚拟继承的原理是使用 <font color="blue4" size="4"><strong>virtual 关键字</strong><font color="0" size="3">，只需要在菱形继承的中间层，也就是上图的 B,C 类，在它们继承方式前面加上 virtual 即可：</font></font></p>
<pre><code class="prism language-c">using  namespace std<span class="token punctuation">;</span>
class test1
<span class="token punctuation">{<!-- --></span>
public<span class="token operator">:</span>
	string _s<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
class test2 <span class="token operator">:</span>virtual public test1
<span class="token punctuation">{<!-- --></span>
protected<span class="token operator">:</span>
	<span class="token keyword">int</span> num<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
class test3 <span class="token operator">:</span>virtual public test1
<span class="token punctuation">{<!-- --></span>
protected<span class="token operator">:</span>
	<span class="token keyword">int</span> score<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
class test4 <span class="token operator">:</span>public test2<span class="token punctuation">,</span> public test3
<span class="token punctuation">{<!-- --></span>
protected<span class="token operator">:</span>
	string information<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>


<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	test4 Ex<span class="token punctuation">;</span>
	Ex<span class="token punctuation">.</span>_s <span class="token operator">=</span> <span class="token string">"jojo"</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> Ex<span class="token punctuation">.</span>_s <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>Ex<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/a49068e3f1ee465e801fc119565fbec9.png#pic_center"/></p>
<p>如图访问 _s 时就不需要指定作用域了，test4 创建的对象 Ex 所占空间的大小也减少了一半，<mark>但是注虚拟继承不要在其他地方去使用</mark></p>
<h2><a id="_286"></a>原理🤔</h2>
<p>要探究底层原理不妨调用内存窗口看看是怎样的结构，我们以简化的模型来探究一下：</p>
<pre><code class="prism language-c">class A <span class="token punctuation">{<!-- --></span>
public<span class="token operator">:</span>
	<span class="token keyword">int</span> _a<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

class B <span class="token operator">:</span> public A <span class="token punctuation">{<!-- --></span>
public<span class="token operator">:</span>
	<span class="token keyword">int</span> _b<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

class C <span class="token operator">:</span> public A <span class="token punctuation">{<!-- --></span>
public<span class="token operator">:</span>
	<span class="token keyword">int</span> _c<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

class D <span class="token operator">:</span> public B<span class="token punctuation">,</span> public C<span class="token punctuation">{<!-- --></span>
public<span class="token operator">:</span>
	<span class="token keyword">int</span> _d<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	D d<span class="token punctuation">;</span>
	d<span class="token punctuation">.</span>B<span class="token operator">::</span>_a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	d<span class="token punctuation">.</span>C<span class="token operator">::</span>_a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
	d<span class="token punctuation">.</span>_b <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
	d<span class="token punctuation">.</span>_c <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
	d<span class="token punctuation">.</span>_d <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p><mark><font color="blue4" size="4">class D:public B,public C</font></mark>:先继承B再继承C</p>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/27cc434bedc64b8d8910961b09d7ac54.png#pic_center"/></p>
<p><mark><font color="blue4" size="4">class D:public C,public B</font></mark>:先继承C再继承B</p>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/a2fcd55ed5774a77b76ee82e50bd4b05.png#pic_center"/></p>
<p>如上在创建子类时，也会遵循先后关系进行继承的空间开辟，先继承的会先在内存的低地址处开辟空间，后继承的会在内存的高地址处开辟空间</p>
<p>==那虚拟继承呢？==我们稍作修改：</p>
<pre><code class="prism language-c">
class B <span class="token operator">:</span>virtual public A <span class="token punctuation">{<!-- --></span>
public<span class="token operator">:</span>
	<span class="token keyword">int</span> _b<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

class C <span class="token operator">:</span>virtual public A <span class="token punctuation">{<!-- --></span>
public<span class="token operator">:</span>
	<span class="token keyword">int</span> _c<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p>依然采用内存窗口观察：<br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/9aa82cb4ea354c40ab10927c12700810.png#pic_center"/><br/> 我们看到这个多出来的东东其实是存的<font color="red" size="4">偏移量<font color="0" size="3">，这个偏移量什么意思？难道是一个地址吗？这个很好验证我们再次代入内存中查找：<br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/8b6798082f484ac592225259135138a0.png#pic_center"/><br/> 得到了一个 14 ，这个 14 又是个什么鬼？这就要牵扯到一个东西叫<font color="red" size="4">虚基表<font color="0" size="3">，我们 A 一般叫<mark>虚基类</mark><strong>（额外的空间，不占用实例对象的空间）</strong>，它是通过 B 和 C 的两个指针指向的一张表，这两个指针叫<mark>虚基表指针</mark>，这两个表叫虚基表。虚基表中存的偏移量，通过偏移量可以找到下面的 A。</font></font></font></font></p>
<p>就拿这里为例，0x006FF7C0 到 0x006FF7D4 的绝对值之差是 20 字节，以内存的 16 进制转换过来就是 14，所以这个偏移量表达的内容就是相对于 _a 的位置！那么问题来了，<mark>为什么不直接访问 _a 而是去搞一个麻烦的偏移量呢？</mark></p>
<p>其实这是为了方便基类赋值给派生类时准确的找到 _a 的位置，因为发生切片时我们是无从得知此时的 _a 在表中什么位置，因此引入偏移量是为了方便的获取准确的位置。</p>
<p>可参考偏移量的原理图：<br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/1ff979c75bbd4034af05b5c445a27a62.png#pic_center"/><br/> 到此为止就总结完毕，很多人说继承和多态很难，其实他并不难，只是他的体系比较抽象，概念性的东西多看几遍其义自见~ aqa 芭蕾 eqe 亏内，代表着开心代表着快乐，ok 了家人们。</p>
</div>
<link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css" rel="stylesheet"/>
<link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css" rel="stylesheet"/>
</div>