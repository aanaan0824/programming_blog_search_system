<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<p id="main-toc"><strong>目录</strong></p>
<p id="%E6%A6%82%E5%BF%B5-toc" style="margin-left:0px;"><a href="#%E6%A6%82%E5%BF%B5">概念</a></p>
<p id="%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%86%E7%B1%BB-toc" style="margin-left:0px;"><a href="#%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%86%E7%B1%BB">链表的分类</a></p>
<p id="%E9%93%BE%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84-toc" style="margin-left:0px;"><a href="#%E9%93%BE%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84">链表的结构</a></p>
<p id="%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E9%93%BE%E8%A1%A8-toc" style="margin-left:0px;"><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E9%93%BE%E8%A1%A8">代码实现链表</a></p>
<p id="1.%E5%88%9B%E5%BB%BA%E8%8A%82%E7%82%B9%E7%B1%BB-toc" style="margin-left:40px;"><a href="#1.%E5%88%9B%E5%BB%BA%E8%8A%82%E7%82%B9%E7%B1%BB">1.创建节点类</a></p>
<p id="2.%E5%88%9B%E5%BB%BA%E9%93%BE%E8%A1%A8-toc" style="margin-left:40px;"><a href="#2.%E5%88%9B%E5%BB%BA%E9%93%BE%E8%A1%A8">2.创建链表</a></p>
<p id="%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E6%9E%9A%E4%B8%BE%E6%B3%95%EF%BC%88%E7%95%A5%E7%AE%80%E5%8D%95%EF%BC%8C%E7%95%A5low%EF%BC%89-toc" style="margin-left:80px;"><a href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E6%9E%9A%E4%B8%BE%E6%B3%95%EF%BC%88%E7%95%A5%E7%AE%80%E5%8D%95%EF%BC%8C%E7%95%A5low%EF%BC%89">方法一：枚举法</a></p>
<p id="%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E5%A4%B4%E6%8F%92%E6%B3%95public%20void%20addFirst(int%20data)-toc" style="margin-left:80px;"><a href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E5%A4%B4%E6%8F%92%E6%B3%95public%20void%20addFirst%28int%20data%29">方法二：头插法public void addFirst(int data)</a></p>
<p id="%E6%96%B9%E6%B3%95%E4%B8%89%EF%BC%9A%E5%B0%BE%E6%8F%92%E6%B3%95public%20void%20addLast(int%20data)-toc" style="margin-left:80px;"><a href="#%E6%96%B9%E6%B3%95%E4%B8%89%EF%BC%9A%E5%B0%BE%E6%8F%92%E6%B3%95public%20void%20addLast%28int%20data%29">方法三：尾插法public void addLast(int data)</a></p>
<p id="3.%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8%EF%BC%9Apublic%20void%20display()-toc" style="margin-left:40px;"><a href="#3.%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8%EF%BC%9Apublic%20void%20display%28%29">3.打印链表：public void display()</a></p>
<p id="4.%E6%9F%A5%E6%89%BE%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E5%85%B3%E9%94%AE%E5%AD%97key%E6%98%AF%E5%90%A6%E5%9C%A8%E5%8D%95%E9%93%BE%E8%A1%A8%E5%BD%93%E4%B8%AD%EF%BC%9Apublic%20boolean%20contains(int%20key)-toc" style="margin-left:40px;"><a href="#4.%E6%9F%A5%E6%89%BE%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E5%85%B3%E9%94%AE%E5%AD%97key%E6%98%AF%E5%90%A6%E5%9C%A8%E5%8D%95%E9%93%BE%E8%A1%A8%E5%BD%93%E4%B8%AD%EF%BC%9Apublic%20boolean%20contains%28int%20key%29">4.查找是否包含关键字key是否在单链表当中：public boolean contains(int key)</a></p>
<p id="5.%E5%BE%97%E5%88%B0%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E9%95%BF%E5%BA%A6%EF%BC%9Apublic%20int%20Size()-toc" style="margin-left:40px;"><a href="#5.%E5%BE%97%E5%88%B0%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E9%95%BF%E5%BA%A6%EF%BC%9Apublic%20int%20Size%28%29">5.得到单链表的长度：public int Size()</a></p>
<p id="6.%E4%BB%BB%E6%84%8F%E4%BD%8D%E7%BD%AE%E6%8F%92%E5%85%A5%2C%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E8%8A%82%E7%82%B9%E4%B8%BA0%E5%8F%B7%E4%B8%8B%E6%A0%87%EF%BC%9Apublic%20boolean%20addIndex(int%20index%2Cint%20data)-toc" style="margin-left:40px;"><a href="#6.%E4%BB%BB%E6%84%8F%E4%BD%8D%E7%BD%AE%E6%8F%92%E5%85%A5%2C%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E8%8A%82%E7%82%B9%E4%B8%BA0%E5%8F%B7%E4%B8%8B%E6%A0%87%EF%BC%9Apublic%20boolean%20addIndex%28int%20index%2Cint%20data%29">6.任意位置插入,第一个数据节点为0号下标：public boolean addIndex(int index,int data)</a></p>
<p id="7.%E5%88%A0%E9%99%A4%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%87%BA%E7%8E%B0%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%BAkey%E7%9A%84%E8%8A%82%E7%82%B9%EF%BC%9Apublic%20void%20remove(int%20key)-toc" style="margin-left:40px;"><a href="#7.%E5%88%A0%E9%99%A4%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%87%BA%E7%8E%B0%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%BAkey%E7%9A%84%E8%8A%82%E7%82%B9%EF%BC%9Apublic%20void%20remove%28int%20key%29">7.删除第一次出现关键字为key的节点：public void remove(int key)</a></p>
<p id="8.%E5%88%A0%E9%99%A4%E6%89%80%E6%9C%89%E5%80%BC%E4%B8%BAkey%E7%9A%84%E8%8A%82%E7%82%B9%EF%BC%9Apublic%20void%20removeAllKey(int%20key)-toc" style="margin-left:40px;"><a href="#8.%E5%88%A0%E9%99%A4%E6%89%80%E6%9C%89%E5%80%BC%E4%B8%BAkey%E7%9A%84%E8%8A%82%E7%82%B9%EF%BC%9Apublic%20void%20removeAllKey%28int%20key%29">8.删除所有值为key的节点：public void removeAllKey(int key)</a></p>
<p id="9.%E6%B8%85%E7%A9%BA%E9%93%BE%E8%A1%A8%EF%BC%9Apublic%20void%20clear()-toc" style="margin-left:40px;"><a href="#9.%E6%B8%85%E7%A9%BA%E9%93%BE%E8%A1%A8%EF%BC%9Apublic%20void%20clear%28%29">9.清空链表：public void clear()</a></p>
<p id="%E6%BA%90%E7%A0%81-toc" style="margin-left:0px;"><a href="#%E6%BA%90%E7%A0%81">源码</a></p>
<hr id="hr-toc"/>
<h1 id="%E6%A6%82%E5%BF%B5">概念</h1>
<p>链表(linked list)：是一种物理存储结构上非连续<strong><span style="background-color:#ff9900;">存储结构</span></strong>，数据元素的逻辑顺序是通过链表中的引用链接次序实现的.</p>
<p>链表由一系列<strong>结点</strong>（<span style="background-color:#ff9900;">链表中每一个元素称为结点</span>）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的<strong><span style="color:#fe2c24;">数据域</span></strong>，另一个是存储下一个结点地址的<strong><span style="color:#fe2c24;">指针域</span></strong>。 相比于线性表顺序结构，操作复杂。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而线性表和顺序表相应的时间复杂度分别是O(logn)和O(1)。</p>
<h1 id="%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%86%E7%B1%BB">链表的分类</h1>
<ul><li>单向链表，双向链表</li><li>带头链表，不带头链表</li><li>循环的，非循环的</li></ul>
<p>排列组合后一共有</p>
<p style="text-align:center;"><img alt="C_{2}^{1}*C_{2}^{1}*C_{2}^{1}=8" class="mathcode" src="https://latex.codecogs.com/gif.latex?C_%7B2%7D%5E%7B1%7D*C_%7B2%7D%5E%7B1%7D*C_%7B2%7D%5E%7B1%7D%3D8"/></p>
<p>即一共8种链表，其中单向、不带头、非循环以及双向、不带头、非循环的链表最为重要，也是本文主要介绍的链表类型。</p>
<h1 id="%E9%93%BE%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84">链表的结构</h1>
<p>对于链表的结构，可以用如下这个图来<span style="background-color:#a2e043;">模拟</span>。</p>
<p style="text-align:center;"><img alt="" height="412" src="image\d3c011b6cbf949c1b701c89801f4efb2.png" width="379"/></p>
<p>图中所示的为链表的一个节点，value是这个节点的所存储的数据值，next为下一节点的地址。</p>
<p>下面是一个5个节点的链表。</p>
<p><img alt="" height="355" src="image\6b4b9911dfe24e5fb57a57dfddc37f60.png" width="1200"/></p>
<p>接下来，我们来实现这样的链表的<strong><span style="background-color:#a2e043;">增删查改</span></strong>：</p>
<p><img alt="" height="474" src="image\af841ac2e5bf455994f6f2471893081d.png" width="1200"/></p>
<p>第一个节点，地址假设是0x999，存储的数据是11，next存储的是下一个节点的地址(假设是0x888)</p>
<p>第二个节点，地址假设是0x888，存储的数据是22，next存储的是下一个节点的地址(假设是0x777)</p>
<p>第三个节点，地址假设是0x777，存储的数据是33，next存储的是下一个节点的地址(假设是0x666)</p>
<p>第四个节点，地址假设是0x666，存储的数据是44，next存储的是下一个节点的地址(假设是0x555)</p>
<p>第五个节点，地址假设是0x555，存储的数据是55，由于没有后续节点，next存储的是空指针null</p>
<p>定义一个head，存储头节点（第一个节点）的地址（假设为0x999）。</p>
<h1 id="%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E9%93%BE%E8%A1%A8">代码实现链表</h1>
<h2 id="1.%E5%88%9B%E5%BB%BA%E8%8A%82%E7%82%B9%E7%B1%BB">1.创建节点类</h2>
<p>节点由val域(<span style="color:#fe2c24;"><strong>数据域</strong></span>)，以及next域(<strong><span style="color:#fe2c24;">指针域</span></strong>)组成，对于next域，其是引用类型，存放下一个节点的地址，故</p>
<p> 用public ListNode next来创建next。</p>
<p>同时设置构造函数，方便对val进行初始化。</p>
<pre><code class="language-java">//ListNode代表一个节点
class ListNode{
    public int val;
    public ListNode next;

    //构造函数
    public ListNode(int a){
        this.val = a;
    }
}</code></pre>
<h2 id="2.%E5%88%9B%E5%BB%BA%E9%93%BE%E8%A1%A8">2.创建链表</h2>
<ul><li> <h3 id="%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E6%9E%9A%E4%B8%BE%E6%B3%95%EF%BC%88%E7%95%A5%E7%AE%80%E5%8D%95%EF%BC%8C%E7%95%A5low%EF%BC%89">方法一：枚举法（略简单，略low）</h3> </li></ul>
<pre><code class="language-java">public class MyLinkedList {

    public ListNode head;//链表的头

    public void creatList(){
        ListNode listNode1 = new ListNode(11);
        ListNode listNode2 = new ListNode(22);
        ListNode listNode3 = new ListNode(33);
        ListNode listNode4 = new ListNode(44);
        ListNode listNode5 = new ListNode(55);

        this.head = listNode1;

        listNode1.next = listNode2;
        listNode2.next = listNode3;
        listNode3.next = listNode4;
        listNode4.next = listNode5;

    }
}</code></pre>
<p>直接进行val的赋值以及对next的初始化。</p>
<p><strong>注意</strong>：不用对最后一个节点的next进行赋值，因为next是引用类型，不赋值则默认为null。</p>
<ul><li> <h3 id="%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E5%A4%B4%E6%8F%92%E6%B3%95public%20void%20addFirst(int%20data)">方法二：头插法public void addFirst(int data)</h3> </li></ul>
<p>头插法是指在链表的头节点的位置插入一个新节点，定义一个node表示该节点，然后就是对node的next进行赋值，用node.next = this.head即可完成（注意：head应指向新节点）</p>
<p>代码实现</p>
<pre><code class="language-java">    public void addFirst(int data){
        ListNode node = new ListNode(data);
        node.next = this.head;
        this.head = node;
    }</code></pre>
<ul><li> <h3 id="%E6%96%B9%E6%B3%95%E4%B8%89%EF%BC%9A%E5%B0%BE%E6%8F%92%E6%B3%95public%20void%20addLast(int%20data)">方法三：尾插法public void addLast(int data)</h3> </li></ul>
<p>尾插法是指在链表的尾节点的位置插入一个新节点，定义一个node表示该节点，然后就是对原来最后一个节点的next进行赋值，先将head移动至原来最后一个节点，用head.next = node进行赋值（<strong>注意</strong>，如果链表不为空，需要定义cur来代替head）</p>
<p>代码实现</p>
<pre><code class="language-java">    public void addLast(int data){
        ListNode node = new ListNode(data);
        if(this.head == null){
            this.head = node;
        }else {
            ListNode cur = this.head;
            while(cur.next != null){
                cur = cur.next;
            }
            cur.next = node;
        }
    }</code></pre>
<h2 id="3.%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8%EF%BC%9Apublic%20void%20display()">3.打印链表：public void display()</h2>
<p>认识了链表的结构，我们可以知道，节点与节点之间通过next产生联系。并且我们已将创建了head，即头节点的地址，通过head的移动来实现链表的打印。</p>
<p><strong>注意</strong>：为了使head一直存在且有意义，我们在display()函数中定义一个cur：ListNode cur = this.head;来替代head。</p>
<p>对于head的移动，可用head = head.next来实现。</p>
<p>代码实现：</p>
<pre><code class="language-java">    public void display(){
        ListNode cur = this.head;
        while(cur != null){
            System.out.print(cur.val+" ");
            cur = cur.next;
        }
        System.out.println();
    }</code></pre>
<h2 id="4.%E6%9F%A5%E6%89%BE%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E5%85%B3%E9%94%AE%E5%AD%97key%E6%98%AF%E5%90%A6%E5%9C%A8%E5%8D%95%E9%93%BE%E8%A1%A8%E5%BD%93%E4%B8%AD%EF%BC%9Apublic%20boolean%20contains(int%20key)">4.查找是否包含关键字key是否在单链表当中：public boolean contains(int key)</h2>
<p>查找key，可以利用head移动，实现对于key的查找（<strong>注意</strong>：同样要定义一个cur来代替head）</p>
<p>代码实现</p>
<pre><code class="language-java">    public boolean contains(int key){
        ListNode cur = this.head;
        while(cur != null){
            if(cur.val == key){
                return true;
            }
            cur = cur.next;
        }
        return false;
    }</code></pre>
<h2 id="5.%E5%BE%97%E5%88%B0%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E9%95%BF%E5%BA%A6%EF%BC%9Apublic%20int%20Size()">5.得到单链表的长度：public int Size()</h2>
<p>定义计数器count = 0，通过head的移动来判断链表长度（<strong>注意</strong>：同样要定义一个cur来代替head）</p>
<p>代码实现</p>
<pre><code class="language-java">    public int Size(){
        int count = 0;
        ListNode cur = this.head;
        while(cur != null){
            count++;
            cur = cur.next;
        }
        return count;
    }</code></pre>
<h2 id="6.%E4%BB%BB%E6%84%8F%E4%BD%8D%E7%BD%AE%E6%8F%92%E5%85%A5%2C%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E8%8A%82%E7%82%B9%E4%B8%BA0%E5%8F%B7%E4%B8%8B%E6%A0%87%EF%BC%9Apublic%20boolean%20addIndex(int%20index%2Cint%20data)">6.任意位置插入,第一个数据节点为0号下标：public boolean addIndex(int index,int data)</h2>
<p>比如，我们把一个值为1314，地址是0x520（设为node引用）的节点，即val域值为1314，next域为null，地址是520，将该节点插入至3号位置，</p>
<p><img alt="" height="632" src="image\86742d9d78d1402abc9d0ce4de8490b0.png" width="865"/></p>
<p></p>
<p>经过分析，<strong><span style="background-color:#a2e043;">需要将head先移至2号位置</span></strong>（<strong>注意</strong>：用cur代替head，防止head丢失），然后</p>
<p><strong><span style="background-color:#a2e043;">node.next = cur.next使该节点的next域改为下一节点的地址</span></strong>，再cur.next = node.next使前一节点</p>
<p>的next域改为该节点的地址。</p>
<pre><code class="language-java">    public void addIndex(int index,int data){
        if(index &lt; 0 ||index &gt; Size()){   //对index位置的合法性进行判断
            return;
        }
        if(index == 0){          //相当于头插法
            addFirst(data);
            return;
        }
        if(index = Size()){      //相当于尾插法
            addLast(data);
            return;
        }
        ListNode cur = findIndex(index);//找到index位置前一位置的地址
        ListNode node = new ListNode(data);//初始化node
        node.next = cur.next;
        cur.next = node;
    }</code></pre>
<h2 id="7.%E5%88%A0%E9%99%A4%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%87%BA%E7%8E%B0%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%BAkey%E7%9A%84%E8%8A%82%E7%82%B9%EF%BC%9Apublic%20void%20remove(int%20key)">7.删除第一次出现关键字为key的节点：public void remove(int key)</h2>
<p>对于删除第一次出现的key值的节点，若不是头节点，我们只需将key值对应的节点的前一节点的next的域改为key值对应的节点的next域即可。</p>
<p>对于头节点，直接head = head.next即可。</p>
<p>对于key值对应的节点的前一节点，我们可以写一个函数来找到它，方便后续的代码书写。</p>
<pre><code class="language-java">    //找到key的前驱（前一节点）
    public ListNode searchPrev(int key){
        ListNode cur = this.head;
        while(cur.next != null){
            if(cur.next.val == key){
                return cur;
            }
            cur = cur.next;
        }
        return null;
    }
    //删除第一次出现关键字为key的节点
    public void remove(int key){
        if(this.head == null){
            return;
        }
        if(this.head.val == key){
            this.head = this.head.next;
            return;
        }
        ListNode cur = searchPrev(key);
        if(cur == null){
            return;             //没有要删除的节点
        }
        ListNode del = cur.next;//定义要删除的节点
        cur.next = del.next;
    }</code></pre>
<h2 id="8.%E5%88%A0%E9%99%A4%E6%89%80%E6%9C%89%E5%80%BC%E4%B8%BAkey%E7%9A%84%E8%8A%82%E7%82%B9%EF%BC%9Apublic%20void%20removeAllKey(int%20key)">8.删除所有值为key的节点：public void removeAllKey(int key)</h2>
<p>若要删除所有值为key的节点，其实我们只需<strong>多次调用</strong>上面所写的remove函数即可完成，<strong>但是，</strong></p>
<p>若要达到面试难度，那么要求就是<span style="background-color:#ff9900;">遍历一遍链表，删除所有值为key的节点。</span></p>
<p></p>
<p>情况一:key连续,如下(1,2,3节点)</p>
<p><img alt="" height="399" src="image\9f1523fb4ea945ac904a83b86980369f.png" width="898"/></p>
<p></p>
<p>情况二:key不连续,如下(1,3节点)</p>
<p><img alt="" height="385" src="image\6ae965510abe4fbfa2273df1c0c3aed6.png" width="866"/></p>
<p>代码实现:</p>
<pre><code class="language-java">    public ListNode removeAllKey(int key){
        if(this.head = null){
            return null;
        }
        ListNode prev = this.head;
        ListNode cur = this.head.next;
        while(cur != null){
            if(cur.val == key){
                prev.next = cur.next;
                cur = cur.next;
            }else {
                prev = cur;
                cur = cur.next;
            }
        }
        if(this.head.val == key){
            this.head = this.head.next;
        }
        return this.head;
    }</code></pre>
<p></p>
<h2 id="9.%E6%B8%85%E7%A9%BA%E9%93%BE%E8%A1%A8%EF%BC%9Apublic%20void%20clear()">9.清空链表：public void clear()</h2>
<p>1.简单粗暴的方法：将头节点置为空head = null；即可</p>
<p>2.细腻温柔的做法：将每一个节点都置为空</p>
<pre><code class="language-java">    public void clear(){
        while(this.head != null){
            ListNode curNext = this.head.next;
            this.head.next = null;
            this.head = curNext;
        }
    }</code></pre>
<h1 id="%E6%BA%90%E7%A0%81">源码</h1>
<pre><code class="language-java">import java.util.List;


//ListNode代表一个节点
class ListNode{
    public int val;
    public ListNode next;

    //构造函数
    public ListNode(int a){
        this.val = a;
    }
}
public class MyLinkedList {

    public ListNode head;//链表的头

    public void creatList() {
        ListNode listNode1 = new ListNode(11);
        ListNode listNode2 = new ListNode(22);
        ListNode listNode3 = new ListNode(33);
        ListNode listNode4 = new ListNode(44);
        ListNode listNode5 = new ListNode(55);

        this.head = listNode1;

        listNode1.next = listNode2;
        listNode2.next = listNode3;
        listNode3.next = listNode4;
        listNode4.next = listNode5;

    }

    //头插法
    public void addFirst(int data) {
        ListNode node = new ListNode(data);
        node.next = this.head;
        this.head = node;
        /*if(this.head == null){
            this.head = node;
        }else{
            node.next = this.head;
            this.head = node;
        }*/
    }

    //尾插法
    public void addLast(int data) {
        ListNode node = new ListNode(data);
        if (this.head == null) {
            this.head = node;
        } else {
            ListNode cur = this.head;
            while (cur.next != null) {
                cur = cur.next;
            }
            cur.next = node;
        }
    }

    //打印顺序表
    public void display() {
        ListNode cur = this.head;
        while (cur != null) {
            System.out.print(cur.val + " ");
            cur = cur.next;
        }
        System.out.println();
    }

    //查找是否包含关键字key是否在单链表当中
    public boolean contains(int key) {
        ListNode cur = this.head;
        while (cur != null) {
            if (cur.val == key) {
                return true;
            }
            cur = cur.next;
        }
        return false;
    }

    //得到单链表的长度
    public int Size() {
        int count = 0;
        ListNode cur = this.head;
        while (cur != null) {
            count++;
            cur = cur.next;
        }
        return count;
    }

    //找到index位置的前一位置的地址
    public ListNode findIndex(int index) {
        ListNode cur = head.next;
        while (index - 1 != 0) {
            cur = cur.next;
            index--;
        }
        return cur;
    }

    //任意位置插入,第一个数据节点为0号下标
    public void addIndex(int index, int data) {
        if (index &lt; 0 || index &gt; Size()) {
            return;
        }
        if (index == 0) {          //相当于头插法
            addFirst(data);
            return;
        }
        if (index == Size()) {      //相当于尾插法
            addLast(data);
            return;
        }
        ListNode cur = findIndex(index);//找到index位置前一位置的地址
        ListNode node = new ListNode(data);//初始化node
        node.next = cur.next;
        cur.next = node;
    }

    //找到key的前驱（前一节点）
    public ListNode searchPrev(int key) {
        ListNode cur = this.head;
        while (cur.next != null) {
            if (cur.next.val == key) {
                return cur;
            }
            cur = cur.next;
        }
        return null;
    }

    //删除第一次出现关键字为key的节点
    public void remove(int key) {
        if (this.head == null) {
            return;
        }
        if (this.head.val == key) {
            this.head = this.head.next;
            return;
        }
        ListNode cur = searchPrev(key);
        if (cur == null) {
            return;             //没有要删除的节点
        }
        ListNode del = cur.next;//定义要删除的节点
        cur.next = del.next;
    }

    //删除所有值为key的节点
    public ListNode removeAllKey(int key) {
        if (this.head = null) {
            return null;
        }
        ListNode prev = this.head;
        ListNode cur = this.head.next;
        while (cur != null) {
            if (cur.val == key) {
                prev.next = cur.next;
                cur = cur.next;
            } else {
                prev = cur;
                cur = cur.next;
            }
        }
        if (this.head.val == key) {
            this.head = this.head.next;
        }
        return this.head;
    }

    //清空链表
    public void clear() {
        while (this.head != null) {
            ListNode curNext = this.head.next;
            this.head.next = null;
            this.head = curNext;
        }
    }
}
</code></pre>
<p></p>
</div>
</div>