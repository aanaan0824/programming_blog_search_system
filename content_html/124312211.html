<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<blockquote>
<p> <img alt="" height="15" src="image\c556452bb2e641388ff5cbf0ad0cd087.png" width="15"/> <span style="color:#1c7331;"><strong>个人主页：欢迎大家光临——&gt;</strong></span><a href="https://blog.csdn.net/m0_64770095" title="沙漠下的胡杨">沙漠下的胡杨</a></p>
<p><img alt="" height="23" src="image\8677fe6ae6e446eba7e0203a3f198059.png" width="23"/> <span style="color:#ed7976;"><strong> 各位大帅哥，大漂亮</strong></span></p>
<p><img alt="" height="26" src="image\182b5d086f4c440aa67d6a3f6747f3ca.png" width="26"/> <span style="color:#956fe7;"><strong>如果觉得文章对自己有帮助</strong></span></p>
<p><img alt="" height="27" src="image\d1ec8894bf4b4d31ab1a86a58ea34714.png" width="27"/> <span style="color:#4da8ee;"><strong>可以一键三连支持博主</strong></span></p>
<p><img alt="" height="29" src="image\7b7d3b82439b40c48b5e0aa5e1468a51.png" width="29"/><strong> <span style="color:#38d8f0;">你的每一分关心都是我坚持的动力</span></strong></p>
<p></p>
<p><img alt="" height="175" src="https://img-blog.csdnimg.cn/b9890a16ced94dcc95130f5480d21937.gif" width="175"/><strong> </strong><img alt="" height="176" src="https://img-blog.csdnimg.cn/ebd7b09fe3334c569c31567a87064844.gif" width="176"/></p>
<h3 id="%C2%A0%E2%98%84%EF%BC%9A%20%E6%9C%AC%E6%9C%9F%E9%87%8D%E7%82%B9%EF%BC%9A%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86"> <strong>☄：</strong> <span style="color:#fe2c24;">本期重点：动态内存相关知识</span></h3>
<p> <strong> <span style="color:#6eaad7;">希望大家每天都心情愉悦的学习工作</span></strong></p>
<p></p>
<p><img alt="" src="image\73d8efb4db9140dfab67731c5fba2a7d.png"/><a href="#%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B">​​​​​</a></p>
</blockquote>
<p id="%C2%A0%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%91%A2%EF%BC%9F-toc" style="margin-left:0px;"><strong><a href="#%C2%A0%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%91%A2%EF%BC%9F"><span style="color:#fe2c24;"><span style="background-color:#ffd900;"> 什么是动态内存呢？</span></span></a></strong></p>
<p id="malloc%E4%BD%BF%E7%94%A8-toc" style="margin-left:80px;"><strong><a href="#malloc%E4%BD%BF%E7%94%A8"><span style="color:#fe2c24;"><span style="background-color:#ffd900;">malloc使用</span></span></a></strong></p>
<p id="calloc-toc" style="margin-left:80px;"><strong><a href="#calloc"><span style="color:#fe2c24;"><span style="background-color:#ffd900;">calloc</span></span></a></strong></p>
<p id="realloc-toc" style="margin-left:80px;"><strong><a href="#realloc"><span style="color:#fe2c24;"><span style="background-color:#ffd900;">realloc</span></span></a></strong></p>
<p id="C%E7%A8%8B%E5%BA%8F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4-toc" style="margin-left:0px;"><strong><a href="#C%E7%A8%8B%E5%BA%8F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span style="color:#fe2c24;"><span style="background-color:#ffd900;">C程序地址空间</span></span></a></strong></p>
<p id="%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%BC%80%E8%BE%9F%E5%91%A2%EF%BC%9F-toc" style="margin-left:0px;"><strong><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%BC%80%E8%BE%9F%E5%91%A2%EF%BC%9F"><span style="color:#fe2c24;"><span style="background-color:#ffd900;">为什么要有动态内存开辟呢？</span></span></a></strong></p>
<p id="%E8%AE%BF%E9%97%AE%E5%86%85%E5%AD%98%E5%87%BA%E9%94%99-toc" style="margin-left:0px;"><strong><a href="#%E8%AE%BF%E9%97%AE%E5%86%85%E5%AD%98%E5%87%BA%E9%94%99"><span style="color:#fe2c24;"><span style="background-color:#ffd900;">访问内存出错</span></span></a></strong></p>
<p id="%E6%8C%87%E9%92%88%E5%90%88%E6%B3%95%E6%80%A7%E9%97%AE%E9%A2%98-toc" style="margin-left:0px;"><strong><a href="#%E6%8C%87%E9%92%88%E5%90%88%E6%B3%95%E6%80%A7%E9%97%AE%E9%A2%98"><span style="color:#fe2c24;"><span style="background-color:#ffd900;">指针合法性问题</span></span></a></strong></p>
<p id="%E5%86%85%E5%AD%98%E8%B6%8A%E7%95%8C-toc" style="margin-left:0px;"><strong><a href="#%E5%86%85%E5%AD%98%E8%B6%8A%E7%95%8C"><span style="color:#fe2c24;"><span style="background-color:#ffd900;">内存越界</span></span></a></strong></p>
<p id="%C2%A0%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F-toc" style="margin-left:0px;"><strong><a href="#%C2%A0%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span style="color:#fe2c24;"><span style="background-color:#ffd900;"> 内存泄漏</span></span></a></strong></p>
<p id="free%E5%A4%9A%E5%A4%A7%E7%A9%BA%E9%97%B4%E5%91%A2%EF%BC%9F-toc" style="margin-left:0px;"><strong><a href="#free%E5%A4%9A%E5%A4%A7%E7%A9%BA%E9%97%B4%E5%91%A2%EF%BC%9F"><span style="color:#fe2c24;"><span style="background-color:#ffd900;">free多大空间呢？</span></span></a></strong></p>
<p id="free%E9%87%8A%E6%94%BE%E6%98%AF%E5%9C%A8%E5%B9%B2%E5%98%9B%EF%BC%9F-toc" style="margin-left:0px;"><strong><a href="#free%E9%87%8A%E6%94%BE%E6%98%AF%E5%9C%A8%E5%B9%B2%E5%98%9B%EF%BC%9F"><span style="color:#fe2c24;"><span style="background-color:#ffd900;">free释放是在干嘛？</span></span></a></strong></p>
<p id="%E4%B8%8B%E6%9C%9F%E9%A2%84%E5%91%8A%EF%BC%9A-toc" style="margin-left:0px;"><strong><a href="#%E4%B8%8B%E6%9C%9F%E9%A2%84%E5%91%8A%EF%BC%9A"><span style="color:#956fe7;">下期预告：</span></a></strong></p>
<hr id="hr-toc"/>
<p></p>
<h1 id="%C2%A0%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%91%A2%EF%BC%9F"><span style="color:#4da8ee;"><strong> 什么是动态内存呢？</strong></span></h1>
<blockquote>
<p>动态内存就是用malloc，calloc，realloc和free这些动态内存函数来进行向堆区申请空间，来交给程序员进行管理使用，这就动态内存管理。</p>
</blockquote>
<h3 id="malloc%E4%BD%BF%E7%94%A8"><span style="color:#956fe7;">malloc使用</span></h3>
<blockquote>
<p>malloc是申请一块空间，需要自己手动进行初始化，并且手动free和置空</p>
<p style="text-align:center;"><img alt="" src="image\0798204ceb7a49639fa65548b3eb42d1.png"/></p>
</blockquote>
<h3 id="calloc"><span style="color:#956fe7;">calloc</span></h3>
<blockquote>
<p>calloc是开辟空间num个sizeof（类型）并初始化为0。</p>
<p><img alt="" src="image\0276f567b81c4e4689cb9e8281909eef.png"/></p>
<p></p>
<p style="text-align:center;"><img alt="" src="image\49ba264b540e4adfb31a1a3ab82d7f62.png"/></p>
</blockquote>
<h3 id="realloc"><span style="color:#9c8ec1;">realloc</span></h3>
<blockquote>
<p>realloc有两种情况：</p>
<p>1.当源空间为0，即传入NULL时，和malloc作用一样。</p>
<p style="text-align:center;"><img alt="" src="image\4969ca7c5e5c4ac3ad534221b8752d91.png"/></p>
<p style="text-align:center;"><img alt="" src="image\74fdc9c4090a444ab2616a5147b469c7.png"/></p>
<p></p>
<p>2.如果做扩容空间时，即传入的指针有效时，又两种分为两种情况</p>
<p>         2.1.如果原空间后面空间足够，那么直接在原空间后面直接开辟，返回原空间的最低地址。（即返回值和传入值相同）</p>
<p style="text-align:center;"><img alt="" src="image\7498e9af56234a3595627a19daa482f3.png"/></p>
<p style="text-align:center;"><img alt="" src="image\7aa3e12a484b47149a2017527ebe6610.png"/></p>
<p></p>
<p>         2.2.如果原空间后面空间不够开辟的话，那么函数就会在堆区上，找一块能符合用户所需要的空间大小的空间，然后把原空间数据拷贝到函数开辟的空间上，然后把原空间释放，返回重新开辟的空间的最低的地址。</p>
<p>这个情况一般很少出现，所以不在举例子啦。</p>
</blockquote>
<h1 id="C%E7%A8%8B%E5%BA%8F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span style="color:#38d8f0;">C程序地址空间</span></h1>
<blockquote>
<p>首先我们要明白堆区在C程序地址空间的那个地方呢？或者说C程序地址空间是什么呢？</p>
<p style="text-align:center;"><img alt="" src="image\9e0f53a2257f4f17add36e83d450c058.png"/>我们今天我们主要聊下堆区。</p>
</blockquote>
<h1 id="%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%BC%80%E8%BE%9F%E5%91%A2%EF%BC%9F"><span style="color:#e6b223;"><strong>为什么要有动态内存开辟呢？</strong></span></h1>
<blockquote>
<p>首先我们知道平常申请空间可以直接在栈区上申请，那么为什么要有动态内存开辟呢？</p>
<p>举个例子：</p>
<p>我们要存放一些数字，这些数字可能很多，可能很少，这时我们该如何在栈区申请空间呢？</p>
<p>本着要全部存下的理念，我们要开辟空间大一点，但是栈区空间有限，稍微大点即形成栈溢出啦，这也就是为什么要有堆区的原因。</p>
<p style="text-align:center;"><img alt="" src="image\99d62aebb66c453b81e3f21d26f65567.png"/></p>
</blockquote>
<h1 id="%E8%AE%BF%E9%97%AE%E5%86%85%E5%AD%98%E5%87%BA%E9%94%99"><span style="color:#faa572;">访问内存出错</span></h1>
<blockquote>
<p>比如定义一个结构体，其中结构体成员是动态开辟的，如果没有初始化就使用，那么就会导致访问内存出错。</p>
<pre><code>struct stu
{
	char* p;
	int age;
}s1;


int main()
{
	strcpy(s1.p, "胡杨树下");
	s1.age = 18;
	return 0;
}</code></pre>
<p>这里的  s1.p  虽然是变量，但是没有相对性的空间，所以就会导致访问内存出错。</p>
<p>上面说啦，应该给 s.p开辟空间，下面就看看怎么开辟吧，下面的开辟是没问题的。</p>
<pre><code>struct stu
{
	char* p;
	int age;
}s1;
void Show(char *name)
{
	printf("%s\n", name);
}
int main()
{
	struct stu s1 = { NULL, 0 };
	s1.p = (char *)malloc(sizeof(char)* 30);
	strcpy(s1.p, "胡杨树下");
	
	Show(s1.p);
	free(s1.p);
	s1.p = NULL;

	return 0;
}</code></pre>
</blockquote>
<h1 id="%E6%8C%87%E9%92%88%E5%90%88%E6%B3%95%E6%80%A7%E9%97%AE%E9%A2%98"><span style="color:#38d8f0;">指针合法性问题</span></h1>
<blockquote>
<p>首先，什么 "合法" 的指针呢？</p>
<p>一般来说，就是传递的指针是能正常使用的。</p>
<p><span style="color:#fe2c24;"><strong><span style="background-color:#ffd900;">如果一个指针它是有指向的（野指针也是有指向的，只不过不知道指向哪里），那么我们没办法判断 "合法" 性。所以我们要求指针如果没有直接被使用，那么就应该赋值为NULL，这样我们验证 ”合法“ 性的问题时，就变成了对指针判断是否为NULL。</span></strong></span></p>
<p>对上面代码改进下就会变为以下的代码：</p>
<pre><code>struct stu
{
	char* p;
	int age;
}s1;
void Show(char *name)
{
	if (name == NULL)
	{
		exit(-1);
	}
	printf("%s\n", name);
}
int main()
{
	struct stu s1 = { NULL, 0 };
	s1.p = (char *)malloc(sizeof(char)* 30);
	if (s1.p == NULL)
	{
		exit(-1);
	}
	strcpy(s1.p, "胡杨树下");
	Show(s1.p);
	free(s1.p);
	s1.p = NULL;
	return 0;
}</code></pre>
<p>这里经过判断指针是否为NULL，这样就避免空指针的情况。也可使用 assert(宏)进行断言，引用头文件 "assert.h",但是这种宏只能在调试版本使用，不能用于发布版本。</p>
</blockquote>
<h1 id="%E5%86%85%E5%AD%98%E8%B6%8A%E7%95%8C"><span style="color:#a2e043;"><strong>内存越界</strong></span></h1>
<blockquote>
<p>相信大家都听过内存越界这个话题，那么指针越界一定会报错吗？</p>
<p>指针的越界有时候时不会进行报错的，比如：</p>
<p style="text-align:center;"><img alt="" src="image\cb4e55e407fe406ca075f7ca34be8b37.png"/></p>
<p> 或者malloc之后没有free也是有概率不报错的。</p>
<p style="text-align:center;"><img alt="" src="image\39586b1f3cd54710a3d322970863340b.png"/></p>
<p>但是不free会发生更严重的情况，叫内存泄漏。 </p>
</blockquote>
<h1 id="%C2%A0%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span style="color:#ffd900;"> 内存泄漏</span></h1>
<blockquote>
<p>内存泄漏简单来说就是，程序只申请内存，不释放不free。</p>
<p>那么如果没有程序，或者程序退出啦，那么还有内存泄漏问题吗？</p>
<p>如果程序退出啦，那么操作系统会强制收回申请的内存。</p>
<p>内存泄漏最更害怕的是一些永远不会主动退出的程序，那么就很恐怖的事，一个进程，只申请内存，不释放，那么就没有内存可用啦。</p>
</blockquote>
<h1 id="free%E5%A4%9A%E5%A4%A7%E7%A9%BA%E9%97%B4%E5%91%A2%EF%BC%9F"><span style="color:#ff9900;"><strong>free多大空间呢？</strong></span></h1>
<blockquote>
<p>我们只知道free的起始地址，那么释放多大呢？</p>
<p style="text-align:center;"><img alt="" src="image\9d902d9492d74089b6e52168f12d18aa.png"/></p>
<p> 我们看下，<span style="color:#fe2c24;"><strong>free的大小远远比释放的空间要大，所以就可以说，我malloc的大小要比我们要申请要大</strong></span>。</p>
<p>因为malloc要申请的空间要有多余的空间来管理申请的空间，所以要比我们正常申请的要大，所以如果我们malloc要越界的话不一定会报错。</p>
</blockquote>
<h1 id="free%E9%87%8A%E6%94%BE%E6%98%AF%E5%9C%A8%E5%B9%B2%E5%98%9B%EF%BC%9F"><span style="color:#fe2c24;">free释放是在干嘛？</span></h1>
<blockquote>
<p>free之后我们一般要把指针置空，为什么呢？不置空还会指向原空间吗？</p>
<p style="text-align:center;"><img alt="" src="image\e894964acb494939829d4eecdcce2400.png"/></p>
<p> <span style="color:#ff9900;"><strong>我们能看出空间的指向没变，也就是说指向没变，那么变的是什么呢</strong></span>？</p>
<p><span style="color:#ffd900;"><strong>变的是p和堆区申请的关系</strong></span>，所以free就是改变的关系，free本质就是改变关系，也就是说p还指向堆区申请的空间，所以我们应该把这种关系断掉，就把p置为NULL。</p>
<p><span style="color:#511b78;"><strong>就像你谈女朋友时，都分手啦，就不该留下联系方式啦，所以就该把联系方式断啦。</strong></span></p>
</blockquote>
<p></p>
<h1 id="%E4%B8%8B%E6%9C%9F%E9%A2%84%E5%91%8A%EF%BC%9A"><span style="color:#a2e043;">下期预告：</span></h1>
<p><span style="color:#4da8ee;"><strong>下期我们讲解函数相关的知识</strong></span></p>
<p><span style="color:#4da8ee;"><strong>下期更精彩 ~！~！~！</strong></span></p>
<p style="text-align:center;"><span style="color:#4da8ee;"><strong><img alt="" src="image\bc3f949ef0eb44af89bd0adc26f3d22f.png"/></strong></span></p>
<p> </p>
</div>
</div>