<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="markdown_views prism-atom-one-dark" id="content_views">
<svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
<path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
</svg>
<blockquote>
<p>评论"<mark>人生苦短，我爱Java</mark>"并<mark>关注</mark>、<mark>点赞</mark>、<mark>收藏</mark>，抽三位赠送一本 《Java核心技术卷一·基础知识》12版</p>
</blockquote>
<h3><a id="_2"></a>位运算基础知识</h3>
<p>Java提供的位运算符有：<strong>左移( &lt;&lt; )、右移( &gt;&gt; ) 、无符号右移( &gt;&gt;&gt; ) 、位与( &amp; ) 、位或( | )、位非( ~ )、位异或( ^ )</strong>，除了**位非( ~ )**是一元操作符外，其它的都是二元操作符。<br/> 1、左移( &lt;&lt; )Test1、将5左移2位：package com.xcy; public class Test { public static void main(String[] args) { System.out.println(5&lt;&lt;2);//运行结果是20 }}运行结果是20，但是程序是怎样执行的呢？首先会将5转为2进制表示形式(java中，整数默认就是int类型,也就是32位):0000 0000 0000 0000 0000 0000 0000 0101 然后左移2位后，低位补0：0000 0000 0000 0000 0000 0000 0001 0100 换算成10进制为202、右移( &gt;&gt; ) ，右移同理，只是方向不一样罢了(感觉和没说一样)System.out.println(5&gt;&gt;2);//运行结果是1还是先将5转为2进制表示形式：0000 0000 0000 0000 0000 0000 0000 0101 然后右移2位，高位补0：0000 0000 0000 0000 0000 0000 0000 00013、无符号右移( &gt;&gt;&gt; )我们知道在Java中int类型占32位，可以表示一个正数，也可以表示一个负数。正数换算成二进制后的最高位为0，负数的二进制最高为为1例如 -5换算成二进制后为：1111 1111 1111 1111 1111 1111 1111 1011 (刚开始接触二进制时，不知道最高位是用来表示正负之分的，当时就总想不通。。明明算起来得到的就是一个正数-_-)我们分别对5进行右移3位、 -5进行右移3位和无符号右移3位：package com.xcy; public class Test { public static void main(String[] args) { System.out.println(5&gt;&gt;3);//结果是0 System.out.println(-5&gt;&gt;3);//结果是-1 System.out.println(-5&gt;&gt;&gt;3);//结果是536870911 }}我们来看看它的移位过程(可以通过其结果换算成二进制进行对比)：5换算成二进制： 0000 0000 0000 0000 0000 0000 0000 01015右移3位后结果为0，0的二进制为： 0000 0000 0000 0000 0000 0000 0000 0000 // (用0进行补位) -5换算成二进制： 1111 1111 1111 1111 1111 1111 1111 1011-5右移3位后结果为-1，-1的二进制为： 1111 1111 1111 1111 1111 1111 1111 1111 // (用1进行补位)-5无符号右移3位后的结果 536870911 换算成二进制： 0001 1111 1111 1111 1111 1111 1111 1111 // (用0进行补位)通过其结果转换成二进制后，我们可以发现，正数右移，高位用0补，负数右移，高位用1补，当负数使用无符号右移时，用0进行部位(自然而然的，就由负数变成了正数了)注意：笔者在这里说的是右移，高位补位的情况。正数或者负数左移，低位都是用0补。(自行测试)4、位与( &amp; )package com.xcy; public class Test { public static void main(String[] args) { System.out.println(5 &amp; 3);//结果为1 }}还是老套路，将2个操作数和结果都转换为二进制进行比较：5转换为二进制：0000 0000 0000 0000 0000 0000 0000 01013转换为二进制：0000 0000 0000 0000 0000 0000 0000 0011-------------------------------------------------------------------------------------1转换为二进制：0000 0000 0000 0000 0000 0000 0000 0001位与：第一个操作数的的第n位于第二个操作数的第n位如果都是1，那么结果的第n为也为1，否则为05、位或( | )package com.xcy; public class Test { public static void main(String[] args) { System.out.println(5 | 3);//结果为7 }}5转换为二进制：0000 0000 0000 0000 0000 0000 0000 01013转换为二进制：0000 0000 0000 0000 0000 0000 0000 0011-------------------------------------------------------------------------------------7转换为二进制：0000 0000 0000 0000 0000 0000 0000 0111位或操作：第一个操作数的的第n位于第二个操作数的第n位 只要有一个是1，那么结果的第n为也为1，否则为06、位异或( ^ )package com.xcy; public class Test { public static void main(String[] args) { System.out.println(5 ^ 3);//结果为6 }}5转换为二进制：0000 0000 0000 0000 0000 0000 0000 01013转换为二进制：0000 0000 0000 0000 0000 0000 0000 0011-------------------------------------------------------------------------------------6转换为二进制：0000 0000 0000 0000 0000 0000 0000 0110位异或：第一个操作数的的第n位于第二个操作数的第n位 相反，那么结果的第n为也为1，否则为07、位非( ~ ) 位非是一元操作符package com.xcy; public class Test { public static void main(String[] args) { System.out.println(~5);//结果为-6 }} 5转换为二进制：0000 0000 0000 0000 0000 0000 0000 0101--------------------------------------------------------------------------------------6转换为二进制：1111 1111 1111 1111 1111 1111 1111 1010位非：操作数的第n位为1，那么结果的第n位为0，反之。由位运算操作符衍生而来的有：&amp;= 按位与赋值|= 按位或赋值^= 按位非赋值&gt;&gt;= 右移赋值&gt;&gt;&gt;= 无符号右移赋值&lt;&lt;= 赋值左移和 += 一个概念而已。举个例子：package com.xcy; public class Test { public static void main(String[] args) { int a = 5 a &amp;= 3; System.out.println(a);//结果是1 }}</p>
<h3><a id="_5"></a>利用位运算，实现加减乘除</h3>
<p>所有的数据在计算机中都以二进制的形式存储，对二进制的运算叫做位运算，即符号位共同参与运算的运算。<br/> 基本形式：&amp; 与：仅当两个位都为1时，结果为1；| 或 ：两个位有一个位为1时，结果就为1，仅当两个位都为0时，结果为0；~ 非 ：位为0，结果为1，位为1，结果为0；^ 异或：两个位相同为0，不同为1；&lt;&lt; 左移：二进位全部左移若干位，高位丢弃，低位补0（因为十进制左移一位相当于乘10，所以二进制左移一位相当于十进制的乘2）；&gt;&gt; 右移：各二进位全部右移若干位，对无符号数，高位补0，对于有符号数，算数右移需要补1，逻辑右移需要补0；利用位运算实现加减乘除：代码如下： public int aplusb(int a, int b) { // write your code here //1.判断加数是否为0； if (b==0) { return a; } //2.求出不考虑进位的得数 int sum =a^b; //3.求出只考虑进位的得数 int carry=(a&amp;b)&lt;&lt;1; //递归 return aplusb(sum, carry); } public int minus(int a,int b){ /*/ 计算机中并没有单独的设置一个减法器，而是通过转换刚才的加法器来实现减法 而所谓的减法就是加一个负数，实现方案是取反加一 <em>/ //1.调用加法器，加数转换为负数 ~:按位取反， int subtractor=aplusb(~b, 1); int result =aplusb(a, subtractor); return result; }public int multiply(int a,int b){ //去两个乘数的绝对值 int multiplicand =a&lt;0?aplusb(~a,1):a; int multiplier =b&lt;0?aplusb(~b, 1):b; int result = 0; //对于乘法而言，不过就是加上多少次 for (int i=0;i&lt;multiplier;i++){ result= aplusb(result, multiplicand); } //这里是判断结果的符号，负数不过是取反加一 if ((a^b)&lt;0){ result=aplusb(~result, 1); return result; } return result; } public int divide(int a,int b){ /</em> 相比于乘法，除法也不过是计算a-b减了几次罢了 */ int dividend=a&gt;0?a:aplusb(~a, 1); int divisor=b&gt;0?b:aplusb(~b, 1); int i=0; while (divisor&lt;=dividend){ dividend=minus(dividend, divisor); i=aplusb(i, 1); } if ((a^b)&lt;0){ return aplusb(~i, 1); } return i; }以上，借鉴的很多</p>
</div>
<link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css" rel="stylesheet"/>
<link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css" rel="stylesheet"/>
</div>