<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="markdown_views prism-atom-one-dark" id="content_views">
<svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
<path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
</svg>
<p><strong>💛 前情提要💛</strong></p>
<p>恭喜大家成功完成<code>C语言</code>，入门了这美丽的世界呀</p>
<p>本章节就开始进入<code>数据结构</code>啦~</p>
<p>接下来我们即将进入一个全新的空间，对代码有一个全新的视角~</p>
<p>以下的内容一定会让你对<code>数据结构</code>有一个颠覆性的认识哦！！！</p>
<p>❗以下内容以<code>C语言</code>的方式实现，对于<code>数据结构</code>来说最重要的是<code>思想</code>哦❗</p>
<p><font color="gray" size="3"><strong>以下内容干货满满，跟上步伐吧~</strong></font></p>
<hr color="#000000" size='1"'/>
<p><strong>作者介绍：</strong></p>
<blockquote>
<p>🎓 <strong>作者：</strong> 热爱编程不起眼的小人物🐐<br/> 🔎<strong>作者的Gitee：</strong><a href="https://gitee.com/Dream_Y-ocean">代码仓库</a><br/> 📌<strong>系列文章&amp;专栏推荐：</strong></p>
<ol><li> <p><a href="https://blog.csdn.net/qq_62817113/category_11605818.html?spm=1001.2014.3001.5482">🐶《刷题特辑》—实现由小白至入门者的学习记录_专栏</a></p> </li><li> <p><a href="https://blog.csdn.net/qq_62817113/category_11534485.html">😺C语言学习【小白-&gt;入门】_全过程_专栏</a></p> </li><li> <p><a href="https://dream-yocean.blog.csdn.net/article/details/124147075">【数据结构】顺序表（增、删、查、改）的实现 [初阶篇_ 复习专用]</a><br/> 📒<strong>我和大家一样都是初次踏入这个美妙的“元”宇宙🌏 希望在输出知识的同时，也能与大家共同进步、无限进步</strong>🌟</p> </li></ol>
</blockquote>
<hr color="#000000" size='1"'/>
<blockquote>
<p></p>
<div class="toc">
<h3>📌导航小助手📌</h3>
<ul><li><a href="#_43">💡本章重点</a></li><li><a href="#bb_61"><b>🍞一.</b>链表的概念</a></li><li><ul><li><a href="#bb_65"><b>🥐Ⅰ.</b>什么是链表</a></li><li><a href="#bb_78"><b>🥯Ⅱ.</b>总结</a></li></ul>
</li><li><a href="#bb_88"><b>🍞二.</b>链表</a></li><li><ul><li><a href="#bb_92"><b>🥐Ⅰ.</b>结构</a></li><li><a href="#bb_127"><b>🥐Ⅱ.</b>实现</a></li></ul>
</li><li><a href="#bb_165"><b>🍞三.</b>链表插口实现</a></li><li><ul><li><a href="#bb_186"><b>🥐Ⅰ.</b>创建新结点</a></li><li><a href="#bb_207"><b>🥐Ⅱ.</b>尾插链表</a></li><li><a href="#bb_250"><b>🥐Ⅲ.</b>头插链表</a></li><li><a href="#bb_289"><b>🥐Ⅳ.</b>尾删链表</a></li><li><a href="#bb_355"><b>🥐Ⅴ.</b>头删链表</a></li><li><a href="#bb_397"><b>🥐Ⅵ.</b>查找链表结点</a></li><li><a href="#bb_434"><b>🥐Ⅶ.</b>对某结点后插</a></li><li><a href="#bb_470"><b>🥐Ⅷ.</b>对某结点前插</a></li><li><a href="#bb_525"><b>🥐Ⅸ.</b>对某节点后删</a></li><li><a href="#bb_572"><b>🥐Ⅹ.</b>打印链表</a></li><li><a href="#bb_600"><b>🥐Ⅺ.</b>销毁链表</a></li><li><a href="#bb_629"><b>🥯Ⅻ.</b>总结</a></li></ul>
</li><li><a href="#bb_639"><b>🍞四.</b>链表的优缺点</a></li><li><a href="#bb_655"><b>🍞五.</b>一级指针&amp;二级指针接收问题</a></li><li><a href="#_683">🫓总结</a></li></ul>
</div>
<p></p>
</blockquote>
<hr color="#000000" size='1"'/>
<h1><a id="_43"></a>💡本章重点</h1>
<ul><li> <p>链表的概念</p> </li><li> <p>链表</p> </li><li> <p>链表的实现</p> </li><li> <p>链表的优缺点</p> </li><li> <p>一级指针&amp;二级指针接收问题</p> </li></ul>
<hr color="#000000" size='1"'/>
<h1><a id="bb_61"></a><b>🍞一.</b>链表的概念</h1>
<br/>
<h2><a id="bb_65"></a><b>🥐Ⅰ.</b>什么是链表</h2>
<ul><li> <p>链表是一种<code>物理</code>存储结构上<code>非连续</code>、<code>非顺序</code>的存储结构</p> </li><li> <p>数据元素的<code>逻辑顺序</code>是通过链表中的指针链接<code>次序</code>实现的</p> </li></ul>
<p>❗<strong>综上：</strong></p>
<ul><li><code>链表</code>也符合我们在<code>顺序表</code>中提及的<code>线性表</code>，即链表也是线性表的一种</li></ul>
<h2><a id="bb_78"></a><b>🥯Ⅱ.</b>总结</h2>
<p>✨综上：就是链表的概念啦~</p>
<p>➡️简单来说：链表是<code>逻辑结构</code>上类似于顺序表的连续的<code>结构</code>，但实际<code>物理结构</code>是不一定连续存储的</p>
<p>以下，我们便具体说说为什么？</p>
<hr color="#000000" size='1"'/>
<h1><a id="bb_88"></a><b>🍞二.</b>链表</h1>
<br/>
<h2><a id="bb_92"></a><b>🥐Ⅰ.</b>结构</h2>
<blockquote>
<p>①逻辑结构<img alt="这里是引用" src="https://img-blog.csdnimg.cn/90d358ccd05949079a38ca90ed2f108f.png"/><br/> ②物理结构<br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/1324bebe433d4971a05efa75ee386349.png"/></p>
</blockquote>
<p>💡<strong>综上我们可知：</strong></p>
<ul><li> <p>1️⃣链表实际上是由不同的结点<code>链接</code>而成的【<code>结点</code>是由<code>结构体</code>类型来创建而成的】</p> </li><li> <p>2️⃣<code>结点</code>是由<code>数据域</code>【存放数据】和<code>指针域</code>【存放下一个结点的地址】所组成的</p> </li><li> <p>3️⃣<code>结点</code>一般是在<code>堆</code>上申请空间的【申请的空间的地址在堆区上是<code>随机分配</code>的，即空间的地址是<code>随机</code>的，这也是为什么每个结点的地址不一定连续】</p> </li></ul>
<p>➡️<strong>简单来说：</strong></p>
<p><code>链表</code>的元素之间的访问并不像<code>顺序表</code>可以通过<code>下标</code>进行随机访问</p>
<p>而是通过访问每个结点的<code>指针域</code>【指针域内存储了下一个结点的空间地址】，即通过访问下一个结点的地址，去找到下一个结点</p>
<p>所以，链表就是由一个个结点的<code>指针域</code>里的地址<code>链接</code>起来的，其中元素之间的空间地址并不连续，所以不能像<code>顺序表</code>进行<code>下标访问</code></p>
<p>这也是为什么链表的<code>逻辑结构</code>与<code>物理结构</code>不同</p>
<p>【但我们实现的时候只需要依靠<code>逻辑结构</code>去实现即可】</p>
<p>✨有了以上对<code>链表</code>的概念后，我们便可以实现它啦~</p>
<br/>
<h2><a id="bb_127"></a><b>🥐Ⅱ.</b>实现</h2>
<p>💡<strong>结点：</strong> 我们所创建的<code>结点</code>都是从<code>堆区</code>上申请空间的</p>
<p>➡️<strong>简单来说：</strong> 使用<code>动态开辟</code>在堆区上开辟一个<code>结点</code>的空间</p>
<blockquote>
<p><strong>Tips:</strong> 关于<code>动态开辟</code>不熟悉的同学可以跳转去🔍<a href="https://dream-yocean.blog.csdn.net/article/details/124055537">【C语言】动态内存管理 [进阶篇_ 复习专用]</a>查看呀</p>
</blockquote>
<pre><code class="prism language-c"><span class="token keyword">typedef</span> <span class="token keyword">int</span> SLTDataType<span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">SlistNode</span>
<span class="token punctuation">{<!-- --></span>

	SLTDataType data<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">SlistNode</span><span class="token operator">*</span> next<span class="token punctuation">;</span>

<span class="token punctuation">}</span>SLTNode<span class="token punctuation">;</span>
</code></pre>
<p>👉<strong>由上述我们可知：</strong></p>
<p>结点本质是<code>结构体类型</code>，结构体内包含了<code>数据域</code>与<code>后驱指针域</code></p>
<ul><li> <p><code>SLTDataType* data</code>用来存储数据</p> </li><li> <p><code>struct SlistNode* next;</code>是用来指向下一个结点的地址，达到结点之间<code>链接</code>的目的</p> </li></ul>
<p>✨<strong>综上：</strong></p>
<ul><li> <p>链表可以根据存储的数据多少实现随时创建结点【动态开辟】进行链接，不会存在空间的浪费</p> </li><li> <p>所以下面我们实现<code>链表的接口</code></p> </li></ul>
<p>❗此处我们实现的是基础的<code>单向不带头不循环链表</code></p>
<hr color="#000000" size='1"'/>
<h1><a id="bb_165"></a><b>🍞三.</b>链表插口实现</h1>
<blockquote>
<p>对于数据结构的接口实现，一般围绕<code>增</code>、<code>删</code>、<code>查</code>、<code>改</code>的内容</p>
</blockquote>
<p>💡<strong>如下的实现围绕此原码进行：</strong></p>
<pre><code class="prism language-c"><span class="token keyword">typedef</span> <span class="token keyword">int</span> SLTDataType<span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">SlistNode</span>
<span class="token punctuation">{<!-- --></span>

	SLTDataType data<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">SlistNode</span><span class="token operator">*</span> next<span class="token punctuation">;</span>

<span class="token punctuation">}</span>SLTNode<span class="token punctuation">;</span>
</code></pre>
<h2><a id="bb_186"></a><b>🥐Ⅰ.</b>创建新结点</h2>
<p><strong>1️⃣创建新结点的函数声明：</strong></p>
<pre><code class="prism language-c">SLTNode<span class="token operator">*</span> <span class="token function">BuySLTNode</span><span class="token punctuation">(</span>SLTDataType x<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p><strong>2️⃣创建新结点函数的实现：</strong></p>
<pre><code class="prism language-c">SLTNode<span class="token operator">*</span> <span class="token function">BuySLTNode</span><span class="token punctuation">(</span>SLTDataType x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	SLTNode<span class="token operator">*</span>node <span class="token operator">=</span> <span class="token punctuation">(</span>SLTNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>SLTNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	node<span class="token operator">-&gt;</span>data <span class="token operator">=</span> x<span class="token punctuation">;</span>
	node<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> node<span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
</code></pre>
<h2><a id="bb_207"></a><b>🥐Ⅱ.</b>尾插链表</h2>
<p>👉<strong>简单来说：</strong> 对链表进行尾部链接一个新的结点</p>
<p>➡️<strong>实现：</strong> 通过访问链表走到链表最后一个结点，将此结点的<code>next</code>指向新的结点</p>
<p>❗<strong>特别注意：</strong> 当链表为<code>NULL</code>（空表）的时候，尾插即是在头插</p>
<p>✊<strong>图例：</strong></p>
<blockquote>
<p><img alt="这里是引用" src="https://img-blog.csdnimg.cn/67608e7516534b28b0231b40ed335eb9.png"/></p>
</blockquote>
<p><strong>1️⃣尾插的函数声明：</strong></p>
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">SListPushBack</span><span class="token punctuation">(</span>SLTNode<span class="token operator">*</span><span class="token operator">*</span> pplist<span class="token punctuation">,</span> SLTDataType x<span class="token punctuation">)</span>
</code></pre>
<p><strong>2️⃣尾插函数的实现：</strong></p>
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">SListPushBack</span><span class="token punctuation">(</span>SLTNode<span class="token operator">*</span><span class="token operator">*</span> pplist<span class="token punctuation">,</span> SLTDataType x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">//创建新结点</span>
	SLTNode<span class="token operator">*</span> newnode <span class="token operator">=</span> <span class="token function">BuySLTNode</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>pplist <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token operator">*</span>pplist <span class="token operator">=</span> newnode<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span>
	<span class="token punctuation">{<!-- --></span>
		SLTNode<span class="token operator">*</span> tail <span class="token operator">=</span> <span class="token operator">*</span>pplist<span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>tail<span class="token operator">-&gt;</span>next <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			tail <span class="token operator">=</span> tail<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">//将新结点 链接到 链表上去</span>
		tail<span class="token operator">-&gt;</span>next <span class="token operator">=</span> newnode<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<h2><a id="bb_250"></a><b>🥐Ⅲ.</b>头插链表</h2>
<p>👉<strong>简单来说：</strong> 对链表进行头部链接一个结点</p>
<p>➡️<strong>实现：</strong> 直接插入到原链表的第一个结点之前</p>
<p>❗<strong>特别注意：</strong></p>
<ul><li> <p>即使是<code>NULL</code>（空表），也可以实现头插</p> </li><li> <p>注意插入顺序，如果顺序反了，会丢失后面结点的地址，找不到后面结点</p> </li></ul>
<p>✊<strong>图例：</strong></p>
<blockquote>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/36334a61d6cf476d8267dbaaf2d6acd8.png"/></p>
</blockquote>
<p><strong>1️⃣头插的函数声明：</strong></p>
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">SListPushFront</span><span class="token punctuation">(</span>SLTNode<span class="token operator">*</span><span class="token operator">*</span> pplist<span class="token punctuation">,</span> SLTDataType x<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p><strong>2️⃣头插函数的实现：</strong></p>
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">SListPushFront</span><span class="token punctuation">(</span>SLTNode<span class="token operator">*</span><span class="token operator">*</span> pplist<span class="token punctuation">,</span> SLTDataType x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">//头插并不需要找头 --- 因为一上来就是 头了</span>
	SLTNode<span class="token operator">*</span> newnode <span class="token operator">=</span> <span class="token function">BuySLTNode</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>

	newnode<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token operator">*</span>pplist<span class="token punctuation">;</span>

	<span class="token operator">*</span>pplist <span class="token operator">=</span> newnode<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h2><a id="bb_289"></a><b>🥐Ⅳ.</b>尾删链表</h2>
<p>👉<strong>简单来说：</strong> 对链表进行删除最后一个结点</p>
<p>➡️<strong>实现：</strong> 遍历到链表到最后一个结点，并将其结点释放，且将倒数第二个结点的<code>next</code>置为<code>NULL</code></p>
<p>❗<strong>特别注意：</strong> 有三种情况需要特别分析</p>
<ul><li> <p>①链表为<code>NULL</code>（空链表）</p> </li><li> <p>②链表只有一个结点的情况</p> </li><li> <p>③此处需要应<code>二级指针</code>接收，否则会产生<code>野指针</code>的问题</p> </li></ul>
<p>✊<strong>图例：</strong></p>
<blockquote>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/5817863e714a4250be8a88f18ea94290.png"/></p>
</blockquote>
<p>❤️<mark>什么时候用二级指针接收，什么时候用一级指针接收的问题我们留到最后面再细细讨论</mark></p>
<p>✨<strong>此处我们先记住结论：</strong> 凡是需要修改头指针所指向的位置的时候，就需要传头指针的地址上来【即需要用<code>二级指针</code>接收】</p>
<p><strong>1️⃣尾删的函数声明：</strong></p>
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">SListPopBack</span><span class="token punctuation">(</span>SLTNode<span class="token operator">*</span><span class="token operator">*</span> pplist<span class="token punctuation">)</span>；
</code></pre>
<p><strong>2️⃣尾删函数的实现：</strong></p>
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">SListPopBack</span><span class="token punctuation">(</span>SLTNode<span class="token operator">*</span><span class="token operator">*</span> pplist<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">//先找尾</span>
	SLTNode<span class="token operator">*</span> tail <span class="token operator">=</span> <span class="token operator">*</span>pplist<span class="token punctuation">;</span>
	SLTNode<span class="token operator">*</span> prev <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	
	<span class="token comment">//1.链表为NULL</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>pplist <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//2.只有一个结点的情况</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>pplist<span class="token punctuation">)</span><span class="token operator">-&gt;</span>next <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">free</span><span class="token punctuation">(</span><span class="token operator">*</span>pplist<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token operator">*</span>pplist <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>tail<span class="token operator">-&gt;</span>next <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			prev <span class="token operator">=</span> tail<span class="token punctuation">;</span>
			tail <span class="token operator">=</span> tail<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token function">free</span><span class="token punctuation">(</span>tail<span class="token punctuation">)</span><span class="token punctuation">;</span>

		tail <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>

		prev<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<h2><a id="bb_355"></a><b>🥐Ⅴ.</b>头删链表</h2>
<p>👉<strong>简单来说：</strong> 对链表进行删除第一个结点</p>
<p>➡️<strong>实现：</strong> 记住链表的第二个结点，然后释放头结点，让第二个结点当新的头结点</p>
<p>❗<strong>特别注意：</strong> 有三种情况需要特别分析</p>
<ul><li> <p>①链表为<code>NULL</code>（空链表）</p> </li><li> <p>②链表只有一个结点的情况</p> </li><li> <p>③此处需要应<code>二级指针</code>接收，否则会产生<code>野指针</code>的问题</p> </li></ul>
<p>✊<strong>图例：</strong></p>
<blockquote>
<p><img alt="这里是引用" src="https://img-blog.csdnimg.cn/772122abe958466085d3c68d45e0dc26.png"/></p>
</blockquote>
<p><strong>1️⃣头删的函数声明：</strong></p>
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">SListPopFront</span><span class="token punctuation">(</span>SLTNode<span class="token operator">*</span><span class="token operator">*</span> pplist<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p><strong>2️⃣头删函数的实现：</strong></p>
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">SListPopFront</span><span class="token punctuation">(</span>SLTNode<span class="token operator">*</span><span class="token operator">*</span> pplist<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>pplist <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span>
	<span class="token punctuation">{<!-- --></span>
		SLTNode<span class="token operator">*</span> next <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>pplist<span class="token punctuation">)</span><span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
		<span class="token function">free</span><span class="token punctuation">(</span><span class="token operator">*</span>pplist<span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token operator">*</span>pplist <span class="token operator">=</span> next<span class="token punctuation">;</span> 
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<h2><a id="bb_397"></a><b>🥐Ⅵ.</b>查找链表结点</h2>
<p>👉<strong>简单来说：</strong> 对链表进行查找所需的结点</p>
<p>➡️<strong>实现：</strong> 遍历链表表一一比较查找是否有我们想要的结点</p>
<ul><li> <p>没有,则返回<code>NULL</code></p> </li><li> <p>有，则返回当前结点的<code>地址</code></p> </li></ul>
<p><strong>1️⃣查找链表结点的函数声明：</strong></p>
<pre><code class="prism language-c">SLTNode<span class="token operator">*</span> <span class="token function">SListFind</span><span class="token punctuation">(</span>SLTNode<span class="token operator">*</span>plist<span class="token punctuation">,</span> SLTDataType x<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p><strong>2️⃣查找链表结点函数的实现：</strong></p>
<pre><code class="prism language-c">SLTNode<span class="token operator">*</span> <span class="token function">SListFind</span><span class="token punctuation">(</span>SLTNode<span class="token operator">*</span>plist<span class="token punctuation">,</span> SLTDataType x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	SLTNode<span class="token operator">*</span>cur <span class="token operator">=</span> plist<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>next <span class="token operator">==</span> x<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> cur<span class="token punctuation">;</span>  
		<span class="token punctuation">}</span>

		cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h2><a id="bb_434"></a><b>🥐Ⅶ.</b>对某结点后插</h2>
<p>👉<strong>简单来说：</strong> 对链表的某个结点后进行插入</p>
<p>➡️<strong>实现：</strong> 类似于尾插的步骤</p>
<p>❗<strong>特别注意：</strong></p>
<ul><li> <p>需要判断要被后插的这个位置的结点是否存在</p> </li><li> <p>注意插入顺序，如果顺序反了，会丢失后面结点的地址，找不到后面结点</p> </li></ul>
<p>✊<strong>图例：</strong></p>
<blockquote>
<p><img alt="这里是引用" src="https://img-blog.csdnimg.cn/cff7f38cee6443eba82be88465a1280b.png"/></p>
</blockquote>
<p><strong>1️⃣对某结点后插的函数声明：</strong></p>
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">SListInsertAfter</span><span class="token punctuation">(</span>SLTNode<span class="token operator">*</span> pos<span class="token punctuation">,</span> SLTDataType x<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p><strong>2️⃣对某结点后插函数的实现：</strong></p>
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">SListInsertAfter</span><span class="token punctuation">(</span>SLTNode<span class="token operator">*</span> pos<span class="token punctuation">,</span> SLTDataType x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">;</span>

	SLTNode<span class="token operator">*</span> newnode <span class="token operator">=</span> <span class="token function">BuySLTNode</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>

	newnode<span class="token operator">-&gt;</span>next <span class="token operator">=</span> pos<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	pos<span class="token operator">-&gt;</span>next <span class="token operator">=</span> newnode<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h2><a id="bb_470"></a><b>🥐Ⅷ.</b>对某结点前插</h2>
<p>👉<strong>简单来说：</strong> 对链表的某个结点前进行插入</p>
<p>➡️<strong>实现：</strong> 类似于头插的步骤</p>
<p>❗<strong>特别注意：</strong></p>
<ul><li> <p>需要判断要被后插的这个位置的结点是否存在</p> </li><li> <p>此处有可能为对链表进行<code>头插</code>的情况，我们便可以复用<code>头插接口</code></p> </li></ul>
<p>✊<strong>图例：</strong></p>
<blockquote>
<p><img alt="这里是引用" src="https://img-blog.csdnimg.cn/08ac90a953eb4650a28a5c936d973e5e.png"/></p>
</blockquote>
<p><strong>1️⃣对某结点前插的函数声明：</strong></p>
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">SListInsert</span><span class="token punctuation">(</span>SLTNode<span class="token operator">*</span><span class="token operator">*</span> pplist<span class="token punctuation">,</span>SLTNode<span class="token operator">*</span> pos<span class="token punctuation">,</span> SLTDataType x<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p><strong>2️⃣对某结点前插函数的实现：</strong></p>
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">SListInsert</span><span class="token punctuation">(</span>SLTNode<span class="token operator">*</span><span class="token operator">*</span> pplist<span class="token punctuation">,</span>SLTNode<span class="token operator">*</span> pos<span class="token punctuation">,</span> SLTDataType x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">;</span>

	SLTNode<span class="token operator">*</span> newnode <span class="token operator">=</span> <span class="token function">BuySLTNode</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span>pos <span class="token operator">==</span> <span class="token operator">*</span>pplist<span class="token punctuation">)</span> <span class="token comment">//此时相当于头插</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">SListPushFront</span><span class="token punctuation">(</span>pplist<span class="token punctuation">,</span> SLTDataType x<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span>
	<span class="token punctuation">{<!-- --></span>
		SLTNode<span class="token operator">*</span> prev <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
		SLTNode<span class="token operator">*</span> cur <span class="token operator">=</span> <span class="token operator">*</span>pplist<span class="token punctuation">;</span>

		<span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> pos<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			prev <span class="token operator">=</span> cur<span class="token punctuation">;</span>

			cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		prev<span class="token operator">-&gt;</span>next <span class="token operator">=</span> newnode<span class="token punctuation">;</span>
		newnode<span class="token operator">-&gt;</span>next <span class="token operator">=</span> pos<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<h2><a id="bb_525"></a><b>🥐Ⅸ.</b>对某节点后删</h2>
<p>👉<strong>简单来说：</strong> 对链表的某个结点进行后删</p>
<p>➡️<strong>实现：</strong> 记住这个结点和要删除的结点的<code>next</code>，然后进行后删除释放即可</p>
<p>❗<strong>特别注意：</strong></p>
<ul><li> <p>对某结点进行后删，但不能对<code>最后一个结点</code>进行后删</p> </li><li> <p>需要判断要被后删的这个位置的结点是否存在</p> </li></ul>
<p>✊<strong>图例：</strong></p>
<blockquote>
<p><img alt="这里是引用" src="https://img-blog.csdnimg.cn/608d337f49af43e8add0d160793db647.png"/></p>
</blockquote>
<p><strong>1️⃣对某节点后删的函数声明：</strong></p>
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">SListEraseAfter</span><span class="token punctuation">(</span>SLTNode<span class="token operator">*</span>pos<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p><strong>2️⃣对某节点后删函数的实现：</strong></p>
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">SListEraseAfter</span><span class="token punctuation">(</span>SLTNode<span class="token operator">*</span>pos<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span>pos<span class="token operator">-&gt;</span>next <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span>
	<span class="token punctuation">{<!-- --></span>
		pos<span class="token operator">-&gt;</span>next <span class="token operator">=</span> pos<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
		<span class="token function">free</span><span class="token punctuation">(</span>pos<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span> 
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>💡我们一般不实现<code>某位置前删</code>的接口，因为对于单链表来说没必要，此功能我们放到<code>带头循环双向链表</code>中提及</p>
<h2><a id="bb_572"></a><b>🥐Ⅹ.</b>打印链表</h2>
<p>👉<strong>简单来说：</strong> 对链表逐个遍历打印</p>
<p>➡️<strong>实现：</strong> 遍历链表一一打印即可</p>
<p><strong>1️⃣打印链表的函数声明：</strong></p>
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">SListPrint</span><span class="token punctuation">(</span>SLTNode<span class="token operator">*</span> plist<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p><strong>2️⃣打印链表函数的实现：</strong></p>
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">SListPrint</span><span class="token punctuation">(</span>SLTNode<span class="token operator">*</span> plist<span class="token punctuation">)</span>  
<span class="token punctuation">{<!-- --></span>
	SLTNode<span class="token operator">*</span> cur <span class="token operator">=</span> plist<span class="token punctuation">;</span>

	<span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> cur<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span> 
		cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h2><a id="bb_600"></a><b>🥐Ⅺ.</b>销毁链表</h2>
<p>👉<strong>简单来说：</strong> 对链表进行销毁，释放内存空间</p>
<p>➡️<strong>实现：</strong> 逐一遍历链表结点，然后逐个释放</p>
<p><strong>1️⃣销毁链表的函数声明：</strong></p>
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">SListDestroy</span><span class="token punctuation">(</span>SListNode<span class="token operator">*</span><span class="token operator">*</span> pphead<span class="token punctuation">)</span>
</code></pre>
<p><strong>2️⃣销毁链表函数的实现：</strong></p>
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">SListDestroy</span><span class="token punctuation">(</span>SLTNode<span class="token operator">*</span><span class="token operator">*</span> pphead<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>pphead<span class="token punctuation">)</span><span class="token punctuation">;</span>

	SLTNode<span class="token operator">*</span> cur <span class="token operator">=</span> <span class="token operator">*</span>pphead<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		SLTNode<span class="token operator">*</span> next <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
		<span class="token function">free</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>
		cur <span class="token operator">=</span> next<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token operator">*</span>pphead <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h2><a id="bb_629"></a><b>🥯Ⅻ.</b>总结</h2>
<p>✨综上：就是单向链表接口实现的内容啦~</p>
<p>➡️相信大家对<code>单链表</code>有不一样的看法了吧🧡</p>
<hr color="#000000" size='1"'/>
<h1><a id="bb_639"></a><b>🍞四.</b>链表的优缺点</h1>
<p>🔵<strong>优点：</strong></p>
<ul><li> <p>可以按需申请内存【不会存在像<code>顺序表</code>一样的内存浪费】，需要存一个数据，就申请一块内存</p> </li><li> <p>任意位置都是<code>O(1)</code>时间内<code>插入</code>、<code>删除</code>数据</p> </li></ul>
<p>🔴<strong>缺点：</strong></p>
<ul><li>不支持下标的<code>随机访问</code>【访问的时候，需要从头往后找】</li></ul>
<hr color="#000000" size='1"'/>
<h1><a id="bb_655"></a><b>🍞五.</b>一级指针&amp;二级指针接收问题</h1>
<p>❓综上，我们看到有些链表接口的形参为<code>一级指针</code>接收，有些则是<code>二级指针</code>接收，这是为什么呢</p>
<p>➡️<strong>如图：</strong></p>
<blockquote>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/2dbe98a3a382449e8f96b1abd5575146.png"/></p>
</blockquote>
<p>💡<strong>此刻，我们便知道：</strong></p>
<ul><li> <p>1️⃣如果用<code>一级指针</code>接收，相当于在接口函数内部创建了一个<code>实参</code>的<code>临时拷贝</code>，即存的依然是地址，后续的结点访问也是通过访问地址正常修改链表</p>
<ul><li>但唯独<code>头结点p</code>的指向无法被修改，因为即使修改了头结点，也只是对函数的形参<code>plist</code>这个临时头结点的<code>指向</code>进行了修改，但正真的头结点<code>p</code>的指向没有被修改，那下次再传<code>p</code>的话，相当于传的是这个链表的头还处于没有被修改的地址</li></ul> </li><li> <p>2️⃣如果用<code>二级指针</code>接收，则相当于把头结点<code>p</code>这个变量的地址传给接口，即<code>pplist = &amp;p</code>,<code>*pplist = p</code>，这样在函数内部对<code>*pplist</code>这个头结点的指向进行修改，真正的头结点<code>p</code>也会跟着修改</p> </li></ul>
<p>✨<strong>综上，我们便可以总结出：</strong></p>
<ul><li> <p>若接口需要改<code>头指针</code>指向的时候时，需要传<code>头指针的地址</code>，即用<code>二级指针</code>接收</p> </li><li> <p>若不需要，则传<code>头指针</code>，即用<code>一级指针</code>接收即可</p> </li></ul>
<hr color="#000000" size='1"'/>
<h1><a id="_683"></a>🫓总结</h1>
<p>综上，我们基本了解了数据结构中的 <font color="#FF69B4"><strong>“链表”</strong> </font> 🍭 <font color="black">的知识啦~~</font></p>
<p>恭喜你的内功又双叒叕得到了提高！！！</p>
<p>感谢你们的阅读😆</p>
<p>后续还会继续更新💓，欢迎持续关注📌哟~</p>
<p>💫<strong>如果有错误❌，欢迎指正呀</strong>💫</p>
<p><strong>✨如果觉得收获满满，可以点点赞👍支持一下哟~✨</strong><br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/180aeac4a0134c779c66a016ea0c8fb9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARHJlYW1fWS5PY2Vhbg==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center"/></p>
</div>
<link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css" rel="stylesheet"/>
<link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css" rel="stylesheet"/>
</div>