<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="markdown_views prism-github-gist" id="content_views">
<svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
<path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
</svg>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/f7f5e8f696074d79bb7c7cfaab2ea5d2.gif#pic_center"/></p>
<blockquote>
<p>🐧<strong>主页详情</strong>：<a href="https://blog.csdn.net/weixin_51568389?spm=1011.2435.3001.5343">一名不会打字的程序员~的个人主页</a><br/> 📢<strong>作者简介</strong>：🏅物联网领域创作者🏅 and 🏅阿里专家博主🏅 and 🏅华为云享专家🏅<br/> ✍️<strong>人生格言</strong>：最慢的步伐不是跬步，而是徘徊；最快的脚步不是冲刺，而是坚持。<br/> 🧑‍💻<strong>人生目标</strong>：成为一名合格的程序员，做未完成的梦：实现财富自由。<br/> 🚩<strong>技术方向</strong>：NULL<br/> 👻如果觉得博主的文章还不错的话，请三连支持一下博主哦<br/> 💬给大家介绍一个我一直在用的求职刷题收割offe👉<a href="https://www.nowcoder.com/link/pc_csdncpt_choice_js">点击进入网站</a><br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/6210ee6e3d2b4720a246dca2c127478e.png"/></p>
</blockquote>
<p></p>
<div class="toc">
<h3>文章目录</h3>
<ul><li><ul><li><a href="#_12">零钱兑换</a></li><li><ul><li><a href="#__33">解法一 动态规划法</a></li><li><a href="#__103">解法二 递归</a></li></ul>
</li><li><a href="#_166">跳跃游戏</a></li><li><ul><li><a href="#__182">方法一 贪心算法</a></li><li><a href="#__221">方法二 动态规划</a></li><li><a href="#__259">方法三 回溯</a></li></ul>
</li></ul>
</li><li><a href="#Longest_Increasing_Subsequence_303">不同路径、Longest Increasing Subsequence和单词拆分</a></li><li><ul><li><a href="#_307">不同路径</a></li><li><ul><li><a href="#_332">思路</a></li><li><a href="#____343">方法一 递归</a></li><li><a href="#____365">方法二 动态规划</a></li><li><a href="#__414">方法三 动态规划优化</a></li><li><a href="#___439">方法四 排列组合</a></li></ul>
</li><li><a href="#Longest_Increasing_Subsequence_473">Longest Increasing Subsequence</a></li><li><ul><li><a href="#__487">方法一 动态规划</a></li><li><a href="#__536">方法二 二分查找</a></li></ul>
</li><li><a href="#_597">单词拆分</a></li><li><ul><li><a href="#__634">方法一 暴力破解法</a></li><li><a href="#__670">方法二 动态规划</a></li><li><a href="#__711">方法三 动态规划（优化版）</a></li></ul>
</li></ul>
</li></ul>
</div>
<p></p>
<h2><a id="_12"></a>零钱兑换</h2>
<p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p>
<p><strong>示例1</strong></p>
<pre><code>输入: coins = [1, 2, 5], amount = 11
输出: 3 
解释: 11 = 5 + 5 + 1
</code></pre>
<p><strong>示例2</strong></p>
<pre><code>输入: coins = [2], amount = 3
输出: -1
</code></pre>
<h3><a id="__33"></a>解法一 动态规划法</h3>
<p><strong>思路</strong></p>
<ol><li> <p>由于需要找到最少的硬币，所以需要列举出所有可能的结果（如题）</p> </li><li> <p>要凑够 amount 元硬币，可以从最 i -&gt; amount 之前进行枚举 (counter) (下列出 最少次数)</p> <p>amount = 1； counter[1] = 1 coins[1] = 1</p> <p>amount = 2； counter[2] = 1 coins[2] = 2</p> <p>amount = 3； counter[3] = 2 coins[1] + coins[2]</p> <p>amount = 4； counter[4] = 2 coins[2] + coins[2]</p> <p>amount = 5； counter[5] = 3 coins[2] + coins[2] + coins[1]</p> <p>amount = 6； counter[6] = 3 coins[2] + coins[2] + coins[2]</p> <p>amount = 7； counter[7] = 2 coins[5] + coins[2]</p> <p>amount = 8； counter[8] = 3 coins[5] + coins[2] + coins[1]</p> <p>amount = 9； counter[9] = 3 coins[5] + coins[2] + coins[2]</p> <p>amount = 10； counter[10] = 2 coins[5] + coins[5]</p> <p>amount = 11； counter[11] = 1 coins[5] + coins[5] + coins[1]</p> </li><li> <p>递增 i 并且记录下 能组合成 i 的 硬币数量 counter[i]</p> </li><li> <p>遍历 coins 数组，从 counter 中找到对应剩余金额（i - coins[j]）的最小次数 + 1</p> </li></ol>
<p><strong>详解</strong></p>
<ol><li>需要计算出每一步的最佳次数，因此可以将每一步的次数保存在 counter 数组中</li><li>counter中每一项的最大值应该是 amount / 1 次，此处默认填充 (amount / 1) + 1 次</li><li>遍历amoount 数组 依次递增，在 coins 数组中找到满足 i 的最少硬币数，保存在 counter 中</li><li>若 counter[i] 已经保存有最少的值，比较此次计算的最小次数，取两者较小</li><li>重复 3，4 步骤 直到 amount 遍历结束</li></ol>
<pre><code class="prism language-javascript"><span class="token keyword">const</span> <span class="token function-variable function">coinChange</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">coins<span class="token punctuation">,</span> amount</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">const</span> counter <span class="token operator">=</span> <span class="token function">Array</span><span class="token punctuation">(</span>amount <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  counter<span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>amount <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  counter<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> amount<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> coins<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> coins<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// i - coins[j] 能凑成 i 的上一步的 最小硬币数量</span>
        counter<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>counter<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> counter<span class="token punctuation">[</span>i <span class="token operator">-</span> coins<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 最坏结果应该是 counter[amount] = amount</span>
  <span class="token keyword">return</span> counter<span class="token punctuation">[</span>amount<span class="token punctuation">]</span> <span class="token operator">&gt;</span> amount <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> counter<span class="token punctuation">[</span>amount<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p><strong>复杂度分析</strong></p>
<ul><li> <p>时间复杂度：O(Sn)O(Sn)</p> <p>时间复杂度是 O(Sn)O(Sn)，S是 <code>amount</code>大小,需要迭代 <code>Sn</code>次</p> </li><li> <p>空间复杂度：O(S)O(S)</p> <p>每次迭代时没有增加新的资源，O(1)O(1)</p> </li></ul>
<h3><a id="__103"></a>解法二 递归</h3>
<p><strong>思路</strong></p>
<p>由于要获取最小奖金币次数，实质上就是能拿到的满足 amount 的面值尽可能大的银币的个数。例如：</p>
<p>coins = [11, 12, 5, 3] amount = 121;</p>
<p>则次数刚好是 121 / 11 = 11，其他的取法均大于 11 次。</p>
<p>若 amount = 124 则有次数 (121 / 11) + (3 / 3) = 12次</p>
<p>另外，在考虑最多次数时，应当满足有 amount / 1 = amount 次。</p>
<p><strong>详解</strong></p>
<ol><li>amount 是总金额，要用最少的硬币数，应当是从最大的硬币开始拿起</li><li>大的硬币可以多次拿取，就有 amount % coins[i] === 0 成立</li><li>可以保存一个最少硬币数 mincounter 的状态，按coins数组最大的开始，依次向最小的硬币循环</li><li>按照可以使用的最大硬币次数作为循环起始条件，依次减1直至为0，递归调用</li><li>当剩余 amount / coins[n] &gt; 当前次数 + mincounter 则直接退出循环</li><li>当amount为0时，即可得到最优结果</li></ol>
<pre><code class="prism language-java"><span class="token keyword">const</span> coinChange <span class="token operator">=</span> <span class="token punctuation">(</span>coins<span class="token punctuation">,</span> amount<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{<!-- --></span>
  <span class="token comment">// 假设 最少次数 最多不会超过 amount 次</span>
  let minCount <span class="token operator">=</span> amount <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
  let coinsTemp <span class="token operator">=</span> coins<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> b <span class="token operator">-</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 防止有超过 amount 面值的硬币出现</span>
  <span class="token keyword">const</span> maxValueIndex <span class="token operator">=</span> coinsTemp<span class="token punctuation">.</span><span class="token function">findIndex</span><span class="token punctuation">(</span>v <span class="token operator">=</span><span class="token operator">&gt;</span> v <span class="token operator">&lt;=</span> amount<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 已经计算的次数，剩余的金额，coins，当前硬币位置</span>
  <span class="token keyword">const</span> calculateCountes <span class="token operator">=</span> <span class="token punctuation">(</span>count<span class="token punctuation">,</span> amount<span class="token punctuation">,</span> coins<span class="token punctuation">,</span> index<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>amount <span class="token operator">==</span><span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">&lt;</span> minCount<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 每次递归的所有可能结果进行保存</span>
        minCount <span class="token operator">=</span> count<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    let maxCountatIndex <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token punctuation">(</span>amount <span class="token operator">/</span> coins<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 执行到超出数组边界 或者 预计最小次数大于已有 minCount 时 直接退出递归</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>index <span class="token operator">==</span><span class="token operator">=</span> coins<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">||</span> maxCountatIndex <span class="token operator">+</span> count <span class="token operator">&gt;=</span> minCount<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// amount 最少是 amount / coins[index] 次 coins[index] 的 和</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>let j <span class="token operator">=</span> maxCountatIndex<span class="token punctuation">;</span> j <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token punctuation">;</span> j <span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token comment">// 累计次数，剩余amount，银币数组，到达的coins数组下标</span>
      <span class="token function">calculateCountes</span><span class="token punctuation">(</span>count <span class="token operator">+</span> j<span class="token punctuation">,</span> amount <span class="token operator">-</span> <span class="token punctuation">(</span>coins<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">*</span> j<span class="token punctuation">)</span><span class="token punctuation">,</span> coins<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token function">calculateCountes</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> amount<span class="token punctuation">,</span> coinsTemp<span class="token punctuation">,</span> maxValueIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> minCount <span class="token operator">==</span><span class="token operator">=</span> amount <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> minCount<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p><strong>复杂度分析</strong></p>
<ul><li> <p>时间复杂度：O(Sn)O(Sn)</p> </li><li> <p>空间复杂度：O(n)O(n)</p> <p>nn 为递归调用的最大深度，即需要 O(n)O(n) 空间的递归堆栈。</p> </li></ul>
<h2><a id="_166"></a>跳跃游戏</h2>
<p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个位置。</p>
<p><strong>示例1</strong>:</p>
<p>输入: [2,3,1,1,4] 输出: true 解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。</p>
<p><strong>示例2</strong>:</p>
<p>输入: [3,2,1,0,4] 输出: false 解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。</p>
<h3><a id="__182"></a>方法一 贪心算法</h3>
<p><strong>思路</strong></p>
<p>贪心算法的思路就是每到一个位置，都跳跃到当前位置可以跳跃的最大距离。当最后跳跃的最远距离等于或大于最后一个位置的时候，我们就认为可以到达最后一个位置，返回true</p>
<p><strong>详解</strong></p>
<ol><li>首先我们初始化最远位置为0，然后遍历数组；</li><li>如果当前位置能到达，并且当前位置+跳数&gt;最远位置，就更新最远位置；</li><li>每次都去比较当前最远位置和当前数组下标，如果最远距离小于等于当前下标就返回false。</li></ol>
<pre><code class="prism language-javascript"><span class="token keyword">const</span> <span class="token function-variable function">canJump</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">nums</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">let</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 跳到最远的距离</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 找到能跳的最远的的距离</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> max<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      max <span class="token operator">=</span> i <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 如果跳的最远的小于当前脚标，返回false</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>max <span class="token operator">&lt;=</span> i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p><strong>复杂度分析</strong></p>
<ul><li> <p>时间复杂度：O(n)O(n)</p> <p>只需要访问 nums 数组一遍，共 nn 个位置，nn 是 numsnums 数组的长度。</p> </li><li> <p>空间复杂度：O(1)O(1)</p> <p>在 max 变量分配内存情况下，内存不会随着遍历有增长趋势，不需要额外的空间开销。</p> </li></ul>
<h3><a id="__221"></a>方法二 动态规划</h3>
<p><strong>思路</strong></p>
<p>我们遍历数组，每到一个点 i，我们就去判断是否可以到达当前点；如果可以，就记录 <code>true</code>，否则为<code>false</code>，最后判断 是否可以到达(nums.length - 1)；</p>
<p><strong>详解</strong></p>
<ol><li>遍历数组 nums，每到一个点 i，我们就判断时刻可以到达当前点；</li><li>如果 i 之前某点 j 本身是可以到达的，并且与当前点可达，表示点 i 是可达的；</li><li>我们遍完成后，直接判断(nums.length - 1)是否可以达到。</li></ol>
<pre><code class="prism language-javascript"><span class="token keyword">const</span> <span class="token function-variable function">canJump</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">nums</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token comment">// 定义一个数组，用来记录nums的点是否是可以达到的</span>
  <span class="token keyword">const</span> list <span class="token operator">=</span> <span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token comment">// 遍历nums</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 遍历list</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token comment">// 如果j点是可以到达的，并且j点是可以达到i点的</span>
      <span class="token comment">// 则表示i点也是可以达到的</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>list<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> j <span class="token operator">&gt;=</span> i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        list<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token comment">// 如果i点可以达到，则跳出当前循环</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> list<span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p><strong>复杂度分析</strong></p>
<ul><li>时间复杂度：O(n^2)O(n2) 对于每个元素，通过两次遍历数组的其余部分来寻找它所对应的目标元素，这将耗费 O(n^2)O(n2) 的时间</li><li>空间复杂度：O(n)O(n) 对于每次循环都需要给 j 重新分配空间，所以空间复杂度 O(n)O(n)</li></ul>
<h3><a id="__259"></a>方法三 回溯</h3>
<p><strong>思路</strong></p>
<p>我们模拟从第一个位置跳到最后位置的所有方案。从第一个位置开始，模拟所有可以跳到的位置，然后判断当前点是否可以到达(nums.length - 1);当没有办法继续跳的时候，就回溯。</p>
<p><strong>详解</strong></p>
<ol><li>我们每次传入一个下标 p，并且判断 p 是否可以达到最后的下标；</li><li>如果传入的 p 等于(nums.length - 1),则表示可以到达，如果不行，则继续循环判断；</li><li>如果存在 p 等于 (nums.length - 1)，则返回 <code>true</code>，不存在则返回 <code>false</code>。</li></ol>
<pre><code class="prism language-javascript"><span class="token keyword">const</span> <span class="token function-variable function">canJump</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">nums</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">return</span> <span class="token function">checkJumpPosition</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">checkJumpPosition</span> <span class="token punctuation">(</span><span class="token parameter">p<span class="token punctuation">,</span> nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token comment">// 定义p点可以到达的最远距离</span>
  <span class="token keyword">let</span> jump <span class="token operator">=</span> p <span class="token operator">+</span> nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token comment">// 如果p点可以到达nums.length - 1，则返回true</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">===</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 如果最远距离大于(nums.length - 1),我们就将(nums.length - 1),设为最远距离</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">+</span> nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">&gt;</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    jump <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 我们从p + 1开始到最远距离中间，找到(nums.length - 1)</span>
  <span class="token comment">// 如果可以，则返回true，找不到则返回false</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> p <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> jump<span class="token punctuation">;</span> i <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">checkJumpPosition</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p><strong>复杂度分析</strong></p>
<ul><li>时间复杂度：O(2^n)O(2n) 因为从第一个位置到最后一个位置的跳跃方式最多有 2^n 种，所以最多的耗时是 O(2^n)O(2n)</li><li>空间复杂度：O(n)O(n) 对于每次循环都需要给 ii 重新分配空间，最大的长度是 <code>nums.length</code>，所以空间复杂度 O(n)O(n)</li></ul>
<h1><a id="Longest_Increasing_Subsequence_303"></a>不同路径、Longest Increasing Subsequence和单词拆分</h1>
<h2><a id="_307"></a>不同路径</h2>
<p>一个机器人位于一个 m x n 网格的左上角，机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角，问总共有多少条不同的路径？</p>
<p><strong>示例 1</strong></p>
<pre><code>输入: m = 3, n = 2
输出: 3
解释:
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -&gt; 向右 -&gt; 向下
2. 向右 -&gt; 向下 -&gt; 向右
3. 向下 -&gt; 向右 -&gt; 向右
</code></pre>
<p><strong>示例 2</strong></p>
<pre><code>输入: m = 7, n = 3
输出: 28
</code></pre>
<h3><a id="_332"></a>思路</h3>
<pre><code>A B C D
E F G H
</code></pre>
<p>从点 (x = 0,y = 0)(x=0,y=0) 出发，每次只能向下或者向右移动一步，因此下一点的坐标为(x + 1, y)(x+1,y) 或者(x, y + 1)(x,y+1)，一直到(x = m, y = n)(x=m,y=n)。在上图中，H 只能从 G 或者 D 达到，因此从 A 到 H 的路径数等于从 A 到 D 的路径与从 A 到 G 的路径之和。得出路径数量 T(m, n) = T(m-1, n) + T(m, n-1)T(m,n)=T(m−1,n)+T(m,n−1)。</p>
<p>我们又发现，当<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        m
       
       
        =
       
       
        1
       
      
      
       m = 1
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1</span></span></span></span></span> 或 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        n
       
       
        =
       
       
        1
       
      
      
       n = 1
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1</span></span></span></span></span> 时（只能一直往下或往右走），路径数量为1，这里得出跳出递归的条件。</p>
<h3><a id="____343"></a>方法一 递归</h3>
<p><strong>详解</strong></p>
<p>由上面的分析可得，到达 (m, n)(m,n)的路径数量为 (m, n-1)(m,n−1)坐标的路径数量与 (m-1, n)(m−1,n)坐标的路径数量之和 。可以使用最简单粗暴的递归方法</p>
<p><strong>代码</strong></p>
<pre><code class="prism language-javascript"><span class="token comment">/**
 * @param {number} m
 * @param {number} n
 * @return {number}
 */</span>
<span class="token keyword">const</span> <span class="token function-variable function">uniquePaths</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">m<span class="token punctuation">,</span> n</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">===</span> <span class="token number">1</span> <span class="token operator">||</span> n <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token function">uniquePaths</span><span class="token punctuation">(</span>m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">uniquePaths</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<h3><a id="____365"></a>方法二 动态规划</h3>
<p><strong>详解</strong></p>
<p>根据以上思路，可以推出状态转移方程为</p>
<p>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]dp[i][j]=dp[i−1][j]+dp[i][j−1]</p>
<table><thead><tr><th>1</th><th>1</th><th>1</th><th>1</th><th>1</th><th>1</th><th>1</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr><tr><td>1</td><td>3</td><td>6</td><td>10</td><td>15</td><td>21</td><td>28</td></tr></tbody></table>
<p><strong>代码</strong></p>
<pre><code class="prism language-javascript"><span class="token comment">/**
 * @param {number} m
 * @param {number} n
 * @return {number}
 */</span>
<span class="token keyword">const</span> <span class="token function-variable function">uniquePaths</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">m<span class="token punctuation">,</span> n</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">const</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">===</span> <span class="token number">0</span> <span class="token operator">||</span> j <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> dp<span class="token punctuation">[</span>m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p><strong>复杂度分析</strong></p>
<ul><li>时间复杂度： O(m * n)O(m∗n)</li></ul>
<p>上述解法中，对 mm 和 nn 进行了双重循环，时间复杂度跟数字的个数线性相关，即为 O(m*n)O(m∗n)</p>
<ul><li>空间复杂度： O(m * n)O(m∗n)</li></ul>
<p>申请了大小为 m * nm∗n的二维数组</p>
<h3><a id="__414"></a>方法三 动态规划优化</h3>
<blockquote>
<p>减少空间复杂度</p>
</blockquote>
<p><strong>详解</strong></p>
<p>我们观察表格发现，下一个值等于当前值加上一行的值，利用这个发现，可以来压缩空间，用一维数组来实现</p>
<pre><code class="prism language-javascript"><span class="token keyword">const</span> <span class="token function-variable function">uniquePaths</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">m<span class="token punctuation">,</span> n</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">const</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p><strong>复杂度分析</strong></p>
<ul><li>时间复杂度： O(m * n)O(m∗n)</li><li>空间复杂度：O(n)O(n)</li></ul>
<h3><a id="___439"></a>方法四 排列组合</h3>
<p><strong>详解</strong></p>
<p>其实这是个高中数学问题。因为机器人只能向右或者向下移动，那么不论有多少中路径，向右和向下走的步数都是一样的。当 m = 3，n = 2 m=3，n=2 时，机器人向下走了一步，向右走了两步即可到达终点。所以我们可以得到</p>
<p>路径 = 从右边开始走的路径总数 + 从下边开始走的路径总数，转化为排列组合问题</p>
<p>不包括起点和终点，共移动 N = m + n - 2N=m+n−2，向右移动K = m - 1K=m−1，将 NN 和 KK 代入上述公式，可得</p>
<p>因此得出答案 C_{m + n -2}^{m - 1}Cm+n−2m−1</p>
<pre><code class="prism language-javascript"><span class="token comment">/**
 * @param {number} m
 * @param {number} n
 * @return {number}
 */</span>
<span class="token keyword">const</span> <span class="token function-variable function">uniquePaths</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">m<span class="token punctuation">,</span> n</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">const</span> <span class="token constant">N</span> <span class="token operator">=</span> m <span class="token operator">+</span> n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token constant">K</span> <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> num <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token constant">K</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    num <span class="token operator">=</span> num <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token constant">N</span> <span class="token operator">-</span> <span class="token constant">K</span> <span class="token operator">+</span> i<span class="token punctuation">)</span> <span class="token operator">/</span> i<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> num<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p><strong>复杂度分析</strong></p>
<ul><li>时间复杂度：O(n)O(n)</li><li>空间复杂度：O(1)O(1)</li></ul>
<h2><a id="Longest_Increasing_Subsequence_473"></a>Longest Increasing Subsequence</h2>
<p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p>
<p><strong>示例</strong></p>
<pre><code>输入: [10,9,2,5,3,7,101,18]
输出: 4
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。
</code></pre>
<h3><a id="__487"></a>方法一 动态规划</h3>
<p><strong>思路</strong></p>
<ul><li>状态定义：res[i] 表示以 nums[i] 为当前最长递增子序列尾元素的长度</li><li>转移方程：通过方程 res[i] = Math.max(res[i], nums[i] &gt; nums[j] ? res[j] + 1 : 1)，动态计算出各上升子序列的长度。</li><li>倒序取值：res 数组进行倒序，第一个即为最大长度的值。</li></ul>
<p><strong>详解</strong></p>
<ol><li> <p>如果给定数组长度小于等于 1，则最长上升子序列的长度等于数组长度。</p> </li><li> <p>初始化一个长度等于给定数组的长度，且元素都为 1 的数组 res。</p> </li><li> <p>当 nums[i] &gt; nums[j] 时，nums[i] 可以作为前一个最长的递增子序列 res[j] 新的尾元素，而组成新的相对于 res[i] 能够拼接的更长的递增子序列 res[i] = res[j] + 1，因为新的 res[i] 能够拼接的最长长度取决于 nums[i] 这个新的尾元素，而这个 nums[i] 不一定大于 nums[j]，所以也不一定大于 res[j]，那么在 i ~ j 之间，最大的递增子序列为 Max(res[i], res[j]+1)；当 nums[i] &lt;= nums[j]，长度为元素本身，即为 1。所以得出方程 res[i] = Math.max(res[i], nums[i] &gt; nums[j] ? res[j] + 1 : 1)，通过转移方程收集</p> <p>各上升子序列的长度。</p> </li><li> <p>通过 sort 函数对 res 倒序排列，第一元素值 res[0] 就是最长的上升子序列长度。</p> </li></ol>
<pre><code class="prism language-javascript"><span class="token comment">/**
 * @param {number[]} nums
 * @return {number}
 */</span>
<span class="token keyword">const</span> <span class="token function-variable function">lengthOfLIS</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">nums</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">const</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> len<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 初始化默认全为1</span>
  <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token comment">// 转移方程</span>
      res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">?</span> res<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 倒序</span>
  res<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> b <span class="token operator">-</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> res<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p><strong>复杂度分析</strong></p>
<ul><li>时间复杂度：O(n^2)O(n2)</li><li>空间复杂度：O(n)O(n)</li></ul>
<h3><a id="__536"></a>方法二 二分查找</h3>
<p><strong>思路</strong></p>
<ul><li> <p>当前遍历元素大于前一个递增子序列的尾元素时（nums[i] &gt; tail[end]），将当前元素追加到 tail 后面，这里解法其实和方法一中</p> <p>nums[i] &gt; nums[j] 的解法一样。</p> </li><li> <p>当 nums[i] &lt;= tail[end] 时，寻找前一个递增子序列第一个大于当前值的元素，替换为当前值，查找用二分，最后左边的元素即为查找到的需要被替换的结果元素。</p> </li></ul>
<p><strong>详解</strong></p>
<p>1、如果给定数组长度小于等于 1，则最长上升子序列的长度等于数组长度。 2、初始化一个长度等于给定数组的长度，且第一个元素值等于给定数组的第一个元素值的数组 tail，tail 用来存储最长递增子序列的元素。 3、循环给定的数组，当前遍历元素大于前一个递增子序列的尾元素时（nums[i] &gt; tail[end]），将当前元素追加到 tail 后面，这里解法 其实和方法一中nums[i] &gt; nums[j] 的解法一样；当 nums[i] &lt;= tail[end] 时，寻找前一个递增子序列第一个大于当前值的元素，替换为当前值，查找用二分，最后左边的元素即为查找到的需要被替换的结果元素。 4、循坏完之后，end + 1 即为最长的上升子序列长度。</p>
<pre><code class="prism language-javascript"><span class="token comment">/**
 * @param {number[]} nums
 * @return {number}
 */</span>
<span class="token keyword">const</span> <span class="token function-variable function">lengthOfLIS</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">nums</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">const</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> len<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">const</span> tail <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>
  tail<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> end <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> tail<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      end <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
      tail<span class="token punctuation">[</span>end<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">let</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
      <span class="token keyword">let</span> right <span class="token operator">=</span> end<span class="token punctuation">;</span>
      <span class="token comment">// 二分查找</span>
      <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 位运算，右移一位</span>
        <span class="token keyword">const</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>tail<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
          left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
          right <span class="token operator">=</span> mid<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
      tail<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> end <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p><strong>复杂度分析</strong></p>
<ul><li> <p>时间复杂度：O(nlogN)O(nlogN)</p> <p>外层一个数组循环遍历，里面嵌套一个二分查找，所以是 O(nlogN)O(nlogN)</p> </li><li> <p>空间复杂度：O(n)O(n)</p> <p>创建的数组 tail 占用空间大小为 n，循环遍历中并没有分配新的空间</p> </li></ul>
<h2><a id="_597"></a>单词拆分</h2>
<p><strong>示例</strong></p>
<p>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</p>
<p><strong>说明</strong>：</p>
<ul><li>拆分时可以重复使用字典中的单词。</li><li>你可以假设字典中没有重复的单词。</li><li>注意你可以重复使用字典中的单词。</li></ul>
<p><strong>示例 1：</strong></p>
<pre><code>输入: s = "leetcode", wordDict = ["leet", "code"]  
输出: true  
解释: 返回 true 因为 "leetcode" 可以被拆分成 "leet code"。
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入: s = "applepenapple", wordDict = ["apple", "pen"]  
输出: true  
解释: 返回 true 因为 "applepenapple" 可以被拆分成 "apple pen apple"。
</code></pre>
<p><strong>示例 3：</strong></p>
<pre><code>输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]  
输出: false
</code></pre>
<h3><a id="__634"></a>方法一 暴力破解法</h3>
<p><strong>思路</strong></p>
<p>把字符串 <code>s</code> 的前缀从短到长拆出来进行判断是否在单词字典中，若在字典中则把前缀截取掉继续递归，直到字符串的长度为 0。在递归中若遇到字符串任何长度的前缀都无法匹配到字典中的单词，则回溯到上层递归。</p>
<p><strong>详解</strong></p>
<p>1、检查字典中是否有字符串的前缀； 2、若有的话，将字符串去掉这个前缀后继续遍历，重复步骤 1、2； 3、若某次调用发现整个字符串都已拆分并且都在字典内则返回 true；</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-21YkVzx9-1659870334689)(https://3811097299-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-M5_VgO7Aapcy5begC-C%2F-M6-I6m57X_LoOQxykgn%2F-M6-IbJwjVrcOtj76ywA%2Fimage.png?alt=media&amp;token=e18dc987-f918-4880-9248-68395d352aea)]</p>
<pre><code class="prism language-javascript"><span class="token keyword">const</span> <span class="token function-variable function">wordBreak</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">s<span class="token punctuation">,</span> wordDict</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> wordDict<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">const</span> startIndex <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>wordDict<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>startIndex <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token comment">// 将字符串去掉这个匹配到的前缀后继续遍历</span>
      <span class="token keyword">const</span> temp <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>startIndex <span class="token operator">+</span> wordDict<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">wordBreak</span><span class="token punctuation">(</span>temp<span class="token punctuation">,</span> wordDict<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<ul><li>时间复杂度：最坏情况下是 O(n^n)O(nn)，因为考虑 <code>s = 'aaaaaaaaaaaaaaaa'， wordDict = ['a']</code>，每一个字符都在字典中，此时递归的时间复杂度会达到 O(n^n) O(nn)，妥妥超时</li><li>空间复杂度：O(1)O(1)，循环中申请了 3 个临时变量，与输入的字符串的长度无关，空间占用属于常数阶，故空间复杂度为 O(1)O(1)。</li></ul>
<h3><a id="__670"></a>方法二 动态规划</h3>
<p><strong>思路</strong></p>
<p><code>dp[i]</code> 表示字符串 <code>s</code> 从开始到 <code>i</code> 位置是否可以由 <code>wordDict</code> 组成。使用 <code>j</code> 从头开始遍历，若 <code>dp[i]</code> 可由 <code>wordDict</code> 组成，并且 <code>i</code> 到 <code>j</code> 之间的单词可以在 <code>wordDict中找到</code>，则说明 <code>dp[i] = true</code>。</p>
<p><strong>详解</strong></p>
<p>1、第一层遍历：用 i 从头到尾遍历字符串； 2、第二层遍历：用 j 从头到 i 遍历字符串； 3、若 <code>dp[j] = true</code> 而且字典中存在字符串 <code>s[i~j]</code>，则说明 <code>dp[i] = true</code>； 4、继续步骤 1、2，直到整个字符串都遍历一遍； 5、若 <code>dp[s.length()] = true</code>，则说明字符可由字段中的单词组合而成；</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-CoPFRWQl-1659870334693)(https://3811097299-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-M5_VgO7Aapcy5begC-C%2F-M6-I6m57X_LoOQxykgn%2F-M6-Ie1OD-shJ9PPcnsE%2Fimage.png?alt=media&amp;token=0d6c4555-cbba-48e9-8f4c-30565a75e7a8)]</p>
<p><strong>代码</strong></p>
<pre><code class="prism language-javascript"><span class="token keyword">const</span> <span class="token function-variable function">wordBreak</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">s<span class="token punctuation">,</span> wordDict</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">const</span> len <span class="token operator">=</span> s<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
  <span class="token keyword">const</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> wordDict<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> dp<span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p><strong>复杂度分析</strong></p>
<ul><li> <p>时间复杂度：O(n^2)O(n2)</p> <p>因为有两层循环，每层循环都从头遍历到尾。</p> </li><li> <p>空间复杂度：O(n)O(n)</p> <p>因为只开辟了一个 nn长度的数组。</p> </li></ul>
<h3><a id="__711"></a>方法三 动态规划（优化版）</h3>
<p><strong>思路</strong></p>
<p>第二层遍历中不用每次遍历 <code>i</code> 的长度，只要遍历字典中最长单词的长度 <code>maxStep</code> 即可。</p>
<p><strong>详解</strong></p>
<p>1、第一层遍历：用 <code>i</code> 从头到尾遍历字符串； 2、第二层遍历：用 <code>j</code> 从 <code>i - maxStep</code> 到 <code>i</code> 遍历字符串； 3、若 <code>dp[j] = true</code> 而且字典中存在字符串 <code>s[i~j]</code>，则说明 <code>dp[i] = true</code>； 4、继续步骤 1、2，直到整个字符串都遍历一遍； 5、若 <code>dp[s.length()] = true</code>，则说明字符可由字段中的单词组合而成；</p>
<pre><code class="prism language-javascript"><span class="token keyword">const</span> <span class="token function-variable function">wordBreak</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">s<span class="token punctuation">,</span> wordDict</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">const</span> len <span class="token operator">=</span> s<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
  <span class="token keyword">const</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token comment">// 计算单词的最长长度</span>
  <span class="token keyword">let</span> maxStep <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> wordDict<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>wordDict<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>length <span class="token operator">&gt;</span> maxStep<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      maxStep <span class="token operator">=</span> wordDict<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">const</span> startOfJ <span class="token operator">=</span> i <span class="token operator">-</span> maxStep <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">?</span> i <span class="token operator">-</span> maxStep <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> startOfJ<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> wordDict<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> dp<span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p><strong>复杂度分析</strong></p>
<ul><li> <p>时间复杂度：O(n^2)O(n2)</p> <p>因为有两层循环，每层循环都从头遍历到尾。</p> </li><li> <p>空间复杂度：O(n)O(n)</p> <p>因为最长只开辟了一个 nn 长度的数组。</p> </li></ul>
</div>
<link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css" rel="stylesheet"/>
<link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css" rel="stylesheet"/>
</div>