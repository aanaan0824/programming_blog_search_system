<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<p id="main-toc"><strong>目录</strong></p>
<p> </p>
<p id="%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86-toc" style="margin-left:0px;"><a href="#%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86">面向过程和面向对象初步认识</a></p>
<p id="%E7%B1%BB%E7%9A%84%E5%BC%95%E5%85%A5%C2%A0-toc" style="margin-left:40px;"><a href="#%E7%B1%BB%E7%9A%84%E5%BC%95%E5%85%A5%C2%A0">类的引入 </a></p>
<p id="%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%C2%A0-toc" style="margin-left:40px;"><a href="#%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%C2%A0">类的定义 </a></p>
<p id="%E7%B1%BB%E7%9A%84%E4%BF%A9%E7%A7%8D%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F-toc" style="margin-left:80px;"><a href="#%E7%B1%BB%E7%9A%84%E4%BF%A9%E7%A7%8D%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F">类的俩种定义方式</a></p>
<p id="%C2%A0%E5%B0%81%E8%A3%85-toc" style="margin-left:40px;"><a href="#%C2%A0%E5%B0%81%E8%A3%85"> 封装</a></p>
<p id="%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%C2%A0-toc" style="margin-left:40px;"><a href="#%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%C2%A0">类的实例化 </a></p>
<p id="%C2%A0%E7%B1%BB%E5%AF%B9%E8%B1%A1-toc" style="margin-left:0px;"><a href="#%C2%A0%E7%B1%BB%E5%AF%B9%E8%B1%A1"> 类对象</a></p>
<p id="%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%E7%8C%9C%E6%B5%8B%C2%A0-toc" style="margin-left:40px;"><a href="#%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%E7%8C%9C%E6%B5%8B%C2%A0">类对象的存储方式猜测 </a></p>
<p id="%C2%A0%E7%B1%BB%E7%9A%84%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90-toc" style="margin-left:40px;"><a href="#%C2%A0%E7%B1%BB%E7%9A%84%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90"> 类的内存对齐</a></p>
<p id="this%E6%8C%87%E9%92%88-toc" style="margin-left:0px;"><a href="#this%E6%8C%87%E9%92%88">this指针</a></p>
<hr id="hr-toc"/>
<p></p>
<h1 id="%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86">面向过程和面向对象初步认识</h1>
<blockquote>
<p> C语言是面向过程的，关注的是过程，分析出求解问题的步骤，通过函数调用逐步解决问题</p>
<p>如洗衣服：</p>
<p><img alt="" height="368" src="image\27c834f0c4eb481daf8f52150f787864.png" width="767"/></p>
<p> C++是基于面向对象的，关注的是对象，将一件事情拆分成不同的对象，靠对象之间的交互完成。</p>
<p><img alt="" height="410" src="image\662fe9270fa140f483462eda3dadfbb5.png" width="744"/></p>
<p></p>
</blockquote>
<h2 id="%E7%B1%BB%E7%9A%84%E5%BC%95%E5%85%A5%C2%A0">类的引入 </h2>
<blockquote>
<p> C语言中定义一个栈<img alt="" height="275" src="image\0910aa721aae4924b4f9bfad8a781f89.png" width="812"/></p>
<p> C++兼容C struct语法，C++同时将struct升级成了类</p>
<p>类包括：成员变量，成员函数，成员函数可以访问成员变量</p>
<p>由于C++中有域的概念，所以我们在初始化栈，入栈，出栈的时候可以不加Stack前缀</p>
<p><img alt="" height="464" src="image\06113553f9d24e5fa0c21af301f11bae.png" width="901"/></p>
<p> 这里Stack是类名，也是类型，可以直接定义变量 </p>
<p><img alt="" height="160" src="image\6cda8242ad944448a05fd937cdabd576.png" width="519"/></p>
<p><img alt="" height="634" src="image\ae5d39fa2cf84a3180a7554b00fe25b3.png" width="876"/></p>
<p> C++类还可以这样，这种写法在C语言是行不通的</p>
<p><img alt="" height="195" src="image\b1d6b12c5ae74c16a51960683a330d67.png" width="670"/></p>
<p> C语言写法</p>
<p><img alt="" height="110" src="image\bcffefa35aff43eba8f1a75a950a6581.png" width="629"/></p>
<p> 总结：C++兼容C的用法，同时struct升级成了类，类名就是类型，可以直接定义变量，函数</p>
</blockquote>
<h2 id="%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%C2%A0">类的定义 </h2>
<blockquote>
<p></p>
<pre><code class="language-cpp">class className
{
// 类体：由成员函数和成员变量组成
}; // 一定要注意后面的分号</code></pre>
<p>class为定义类的关键字，ClassName为类的名字，{}中为类的主体，注意类定义结束时后面分号不能省略。<br/> 类体中内容称为类的成员：类中的变量称为类的属性或成员变量; 类中的函数称为类的方法或者成员函数。<br/> C++中有访问限定符</p>
<p><img alt="" height="431" src="image\e24bebb5bcb44c4d87b409306e2417e5.png" width="1116"/></p>
<p>把刚才的struct改为calss，初始化的时候会报错</p>
<p><img alt="" height="779" src="image\04d387087d324f9a8dc9b6c7d0c9cc85.png" width="849"/></p>
<p><img alt="" height="779" src="image\9d1cad2bfbc741a29596d5be5e118b28.png" width="743"/></p>
<p></p>
<p> 这是因为struct默认的访问权限是public,class是private</p>
<p>接下来把class里面的部分内容改为公有，在遇见下一个访问限定符之前，或这个类结束之前都是公有，私有，保护也同理</p>
<p><img alt="" height="484" src="image\0c7cb2a8aa9c463795467e8c0c8bd4ee.png" width="940"/></p>
<p> <img alt="" height="632" src="image\dfb41e5c27fb4c44aff48be181a1dede.png" width="1200"/></p>
<p></p>
<p> 【访问限定符说明】<br/> 1. public修饰的成员在类外可以直接被访问<br/> 2. protected和private修饰的成员在类外不能直接被访问(此处protected和private是类似的)<br/> 3. 访问权限作用域<span style="color:#0d0016;"><strong>从该访问限定符出现的位置开始直到下一个访问限定符出现时为止</strong></span><br/> 4. 如果后面没有访问限定符，作用域就到 } 即类结束。<br/> 5. class的默认访问权限为private，struct为public(因为struct要兼容C)<br/> 注意：访问限定符只在编译时有用，当数据映射到内存后，没有任何访问限定符上的区别</p>
<p></p>
</blockquote>
<h3 id="%E7%B1%BB%E7%9A%84%E4%BF%A9%E7%A7%8D%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F">类的俩种定义方式</h3>
<blockquote>
<p> 1.声明和定义全部放在类体中，需注意：成员函数如果在类中定义，编译器可能会将其当成内联函数处理。（如果符合inline的条件就回当内联函数）</p>
<p><img alt="" height="618" src="image\282fa661b949449f9bf099eb63a6b8bb.png" width="1200"/></p>
<p>内联函数按F11调试进不去 </p>
<p><img alt="" height="759" src="image\ac75312bcae34f8fb1f592b134b4a059.png" width="1086"/></p>
<p> 2. 类声明放在.h文件中，成员函数定义放在.cpp文件中，<span style="color:#0d0016;"><strong>注意：成员函数名前需要加类名::</strong></span></p>
<p><img alt="" height="537" src="image\1f31c9b19cd84a849e29bf1bee6c114d.png" width="876"/></p>
<p> <img alt="" height="751" src="image\eb504bd5ebb14b718f44dd4ff8589441.png" width="1035"/></p>
<p>此时.cpp文件里链接报错 ，这是因为C++有域的概念，类也有自己的域，我们在.cpp文件里面描述清楚这些函数来自哪个域即可</p>
<p><img alt="" height="530" src="image\694713b73e92462cb1336737a8c732c8.png" width="1143"/></p>
<p>此时可以正常运行 ，队列调试可以进去，说明不是内联</p>
<p>类的定义：</p>
<p>1.小函数，想成为内联，直接在类里面定义即可（如刚才的栈）</p>
<p>2.如果是大函数，声明和定义分离，便于观察</p>
<p><span style="color:#fe2c24;"><strong>在类里面访问，不受访问限定符的限制（自己访问自己）</strong></span></p>
<p></p>
</blockquote>
<h2 id="%C2%A0%E5%B0%81%E8%A3%85"> 封装</h2>
<blockquote>
<p>面向对象的三大特性：封装、继承、多态。<br/> 在类和对象阶段，主要是研究类的封装特性，那什么是封装呢？<br/> 封装：将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行交互。<br/> 封装本质上是一种管理，让用户更方便使用类。比如：对于电脑这样一个复杂的设备，提供给用户的就只有开关机键、通过键盘输入，显示器，USB插孔等，让用户和计算机进行交互，完成日常事务。但实际上电脑真正工作的却是CPU、显卡、内存等一些硬件元件<br/>  一般把开放用的成员函数公开，成员变量私有</p>
<p>C语言没办法封装，使用的时候要规范访问数据，也可直接访问数据（不规范）</p>
</blockquote>
<h2 id="%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%C2%A0">类的实例化 </h2>
<blockquote>
<p>在定义类的时候不会开辟空间， 就像图纸一样，定义对象的时候才会开空间，这个叫类的实例化</p>
<p> 一个类可以实例化出多个对象，实例化出的对象 占用实际的物理空间，存储类成员变量</p>
<p></p>
<p>在.h文件里面定义一个变量 </p>
<p><img alt="" height="216" src="image\f61838157f794942973e1b114aaf73f7.png" width="508"/></p>
<p>在test1.cpp和test.cpp引用这个头文件</p>
<p><img alt="" height="166" src="image\cd0b378df5bb409594bc042a253af9e7.png" width="467"/></p>
<p> <img alt="" height="249" src="image\03bea5340ecc42e28d3230552de1f1d8.png" width="454"/></p>
<p> <img alt="" height="694" src="image\7ea61f7ac9294d17920c1af9f4dfd490.png" width="740"/></p>
<p>然后编译，此时链接报错 </p>
<p>这是因为链接发生了冲突，.h会在test1.cpp和test.cpp里面展开，也就是说会有俩个age，由于这个age是全局变量，所以会产生俩个符号表，在之后产生的.o文件里，会把这俩个文件合并到一起，此时俩个age，无法匹配符号表，所以链接报错，影刺声明要和定义分离，加extern，告诉编译器这里是声明</p>
<p><img alt="" height="149" src="image\79332322b7d54624980319c5917eaf02.png" width="466"/></p>
<p> 之后在test1.cpp里面定义age，在test.cpp里面使用age</p>
<p><img alt="" height="825" src="image\5ced29827865492081ebf6de89156073.png" width="872"/></p>
<p> extern告诉编译器这里是一个声明。符号表重匹配的时候就可以正确匹配到</p>
<p>如果这里不用extern，还可用其它方式加static修饰</p>
<p>static和extern链接属性不一样</p>
<p>extern 是所有文可见</p>
<p>static 当前文件可见，当前文件可见就是不放进符号表，给当前文件用，如在.h里面有static size语句，test1.cpp和test.cpp看到的不是同一个size，当前文件可见是指，test1.cpp和test.cpp都包含了.h头文件，test1.cpp可见一个size,test.cpp可见一个size，这俩个size不一样</p>
<p>.h文件</p>
<p><img alt="" height="221" src="image\817bc28b9726493392007c2150717f67.png" width="666"/></p>
<p> test1.cpp</p>
<p><img alt="" height="301" src="image\bb1b9a0cfd6546a1b69ef93a424d6f1c.png" width="1093"/></p>
<p> test.cpp</p>
<p><img alt="" height="479" src="image\f32c3ce5f3594cc4bdbd3c78222ab019.png" width="792"/></p>
<p> <img alt="" height="253" src="image\d94292fab932436b95cd883f2265f5a0.png" width="918"/></p>
<p>俩个size的地址不一样 ，说明不是同一个</p>
<p>这次加上age的地址，发现age地址一样，而size还是不一样</p>
<p><img alt="" height="266" src="image\4f67d7c671894aa586b0a0e96acac990.png" width="647"/></p>
<p> 这就说明extern修饰的变量在所有文件可见，static修饰的变量只在当前文件可见</p>
</blockquote>
<h1 id="%C2%A0%E7%B1%BB%E5%AF%B9%E8%B1%A1"> 类对象</h1>
<h2 id="%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%E7%8C%9C%E6%B5%8B%C2%A0">类对象的存储方式猜测 </h2>
<blockquote>
<p>方式一：对象中包含类的各个成员</p>
<p><img alt="" height="463" src="image\b16e87928305436496b57bdd1ca123b5.png" width="787"/> 缺陷：每个对象中成员变量是不同的，但是调用同一份函数，如果按照此种方式存储，当一个类创建多个对象时，每个对象中都会保存一份代码，相同代码保存多次，浪费空间。</p>
<p>实例化的每个对象成员变量都是独立空间，是不同变量，但每种成员函数都是同一个</p>
<p>这里age地址不一样，但Print函数一样</p>
<p><img alt="" height="364" src="image\424aa789642144dd9ed64a909c2a0284.png" width="903"/></p>
<p> <img alt="" height="302" src="image\6a8eecbe38944ffc8aeb1cee186f22b9.png" width="699"/></p>
<p></p>
<p></p>
<p> 方式二：代码只保存一份，在对象中保存存放代码的地址</p>
<p><img alt="" height="548" src="image\d2cf0fba13c44920a136bcd6bd4ba130.png" width="1130"/></p>
<p>把类函数专门存到一个函数表里，需要用函数的时候去表里取就行</p>
<p> 只保存成员变量，成员函数存放在公共的代码段</p>
<p><img alt="" height="746" src="image\51bb62dac0fa4f7dbc2dc612465a354f.png" width="914"/></p>
<p> 成员存到公共区域，这种方法的好处，编译链接的时候就根据函数的名字去公共代码区找到存储的地址，然后call函数，这样就不用运行的时候去对象里面找了。</p>
<p><img alt="" height="700" src="image\09be8077e8ba49b29b0358fd6f1b967d.png" width="1185"/></p>
<p> 此时程序正常运行，这里如果采用第一种或第二种存储方式都会崩溃，因为ptr是一个空指针，按照这俩种方式则会去对象里面找func函数，但由于是空指针找不到就会崩溃。</p>
<p>第三种存储方式下不会崩溃，这是因为func在公共区域，会在公共区域去找func，然后编译的时候call地址，找到之后就能正常运行</p>
</blockquote>
<h2 id="%C2%A0%E7%B1%BB%E7%9A%84%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90"> 类的内存对齐</h2>
<blockquote>
<p> <img alt="" height="603" src="image\30f5ad117ba34ed4a39c62297fb32364.png" width="1037"/></p>
<p>A2只有一个成员函数，A3什么都没有这俩者结果都是1 ，因为这里若果结果是0，就代表着一个字节都没开，说明连地址都没取，地址为空，此时就不可能有类存在，所以结果是1</p>
<p><strong><span style="color:#fe2c24;">没有成员变量的类对象，给1字节，不存储实际数据进行占位，标识对象存在</span></strong></p>
<p><span style="color:#0d0016;">内存对齐规则跟结构体一样：</span></p>
<p>1. 第一个成员在与结构体偏移量为0的地址处。<br/> 2. 其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。<br/> 注意：对齐数 = 编译器默认的一个对齐数 与 该成员大小的较小值。<br/> VS中默认的对齐数为8<br/> 3. 结构体总大小为：最大对齐数（所有变量类型最大者与默认对齐参数取最小）的整数倍。<br/> 4. 如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是<br/> 所有最大对齐数（含嵌套结构体的对齐数）的整数倍。</p>
</blockquote>
<h1 id="this%E6%8C%87%E9%92%88">this指针</h1>
<blockquote>
<p> 写一个类</p>
<p><img alt="" height="512" src="image\461673adbc86479e99891c92e86922d8.png" width="814"/></p>
<p></p>
<p> 我们可以看到，这里面成员对象名字前面都有_，这是一种命名的方法。叫驼峰命名法</p>
<p><span style="color:#0d0016;"><strong>驼峰法</strong></span></p>
<p><span style="color:#0d0016;"><strong>a、函数名、类名等所有单词首字母大写 DateMgr</strong></span></p>
<p><span style="color:#0d0016;"><strong> b、变量首字母小写，后面单词首字母大写 dateMgr</strong></span></p>
<p><span style="color:#0d0016;"><strong>c、成员变量，首单词前面加_  如：_dateMgr</strong></span></p>
<p><img alt="" height="619" src="image\c20ab4570d70431fa572aeec1b63e7b5.png" width="1200"/></p>
<p> C++如何给p1和p2准确的赋值呢？</p>
<p>C++提出了this指针的概念，非静态的成员函数在第一个位置都有一个隐含的参数，参数名字叫this指针，</p>
<p><img alt="" height="649" src="image\017a9009dd074bafa1f02130101d70cc.png" width="837"/></p>
<p> 编译器会生成并处理this指针</p>
<p><img alt="" height="439" src="image\fb33355effd9404db53fb9f9642c477c.png" width="1043"/></p>
<p> 传参的时候也会做相应的处理，会把地址传过去</p>
<p><img alt="" height="641" src="image\08a15bcc8ba742fd8ec15bb1565b621b.png" width="983"/></p>
<p>this指针不能在形参和实参的位置显示和接收，但是在函数内部可以使用，this指针也不能被修改，是因为它是被const修饰的</p>
<p><img alt="" height="652" src="image\aebfe9aa15f74db28d0d9740abf1626f.png" width="1039"/></p>
<p></p>
<p>看着一段程序，这一段正常运行，上面已经分析过了 </p>
<p><img alt="" height="450" src="image\85132f7ec58c49268637a250e5f6b583.png" width="972"/></p>
<p>this此时是空指针</p>
<p><img alt="" height="381" src="image\dc0a0c0be402421993ee8b77675dd4c8.png" width="887"/></p>
<p></p>
<p>看下面这一段程序，运行的时候程序会崩溃 </p>
<p><img alt="" height="430" src="image\31b117fd28564d27861514944e1bbdaf.png" width="801"/></p>
<p><img alt="" height="425" src="image\517bf2792ebb494584ba44818245d79d.png" width="857"/></p>
<p></p>
<p>这是因为p指针本身就是空指针，然后去公共区域找到print函数，但在打印_a的时候会让this去找a，this本身就是空指针，无法找到a，所以就崩溃</p>
<p>this指针的特性<br/><span style="color:#0d0016;"><strong>1. this指针的类型：类类型* const，即成员函数中，不能给this指针赋值。<br/> 2. 只能在“成员函数”的内部使用<br/> 3. this指针本质上是“成员函数”的形参，当对象调用成员函数时，将对象地址作为实参传递给this形参。所以对象中不存储this指针。<br/> 4. this指针是“成员函数”第一个隐含的指针形参，一般情况由编译器通过ecx寄存器自动传递，不需要用户传递</strong></span></p>
<p><span style="color:#fe2c24;"><strong>this指针存在于栈种，因为它是形参，函数结束，形参销毁</strong></span></p>
<p><img alt="" height="356" src="image\54a88c14aa674e1f9a6285091ee3090a.png" width="768"/></p>
<p></p>
<p><img alt="" height="150" src="image\b4c379677eef4affa3aa288b54b58000.png" width="688"/></p>
<p> 调用函数的时候，vs没把this放到栈上，而是放到了寄存器里面，取aa的地址放入ecx，存到寄存器里面访问会快一些，因此，this指针在不同编译器下可能被优化，vs里放到ecx寄存器可以提高访问效率，具体优不优化取决于编译器</p>
</blockquote>
</div>
</div>