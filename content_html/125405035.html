<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<p id="main-toc"><strong>目录</strong></p>
<p id="-toc" style="margin-left:0px;"></p>
<p id="STL%EF%BC%9A-toc" style="margin-left:0px;"><a href="#STL%EF%BC%9A">STL：</a></p>
<p id="vector%E5%AE%B9%E5%99%A8%EF%BC%9A-toc" style="margin-left:0px;"><a href="#vector%E5%AE%B9%E5%99%A8%EF%BC%9A">vector容器：</a></p>
<p id="string%E5%AE%B9%E5%99%A8%EF%BC%9A-toc" style="margin-left:0px;"><a href="#string%E5%AE%B9%E5%99%A8%EF%BC%9A">string容器：</a></p>
<p id="deque%E5%AE%B9%E5%99%A8%EF%BC%9A-toc" style="margin-left:0px;"><a href="#deque%E5%AE%B9%E5%99%A8%EF%BC%9A">deque容器：</a></p>
<p id="stack%E5%AE%B9%E5%99%A8%EF%BC%9A(%E5%85%88%E8%BF%9B%E5%90%8E%E5%87%BA)-toc" style="margin-left:0px;"><a href="#stack%E5%AE%B9%E5%99%A8%EF%BC%9A%28%E5%85%88%E8%BF%9B%E5%90%8E%E5%87%BA%29">stack容器：(先进后出)</a></p>
<p id="queue%E5%AE%B9%E5%99%A8%EF%BC%9A%EF%BC%88%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%EF%BC%89-toc" style="margin-left:0px;"><a href="#queue%E5%AE%B9%E5%99%A8%EF%BC%9A%EF%BC%88%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%EF%BC%89">queue容器：（先进先出）</a></p>
<p id="list%E5%AE%B9%E5%99%A8%EF%BC%9A-toc" style="margin-left:0px;"><a href="#list%E5%AE%B9%E5%99%A8%EF%BC%9A">list容器：</a></p>
<p id="set%2Fmultiset%E5%AE%B9%E5%99%A8%EF%BC%9A-toc" style="margin-left:0px;"><a href="#set%2Fmultiset%E5%AE%B9%E5%99%A8%EF%BC%9A">set/multiset容器：</a></p>
<p id="pair%E5%AF%B9%E7%BB%84%E5%88%9B%E5%BB%BA%EF%BC%9A-toc" style="margin-left:0px;"><a href="#pair%E5%AF%B9%E7%BB%84%E5%88%9B%E5%BB%BA%EF%BC%9A">pair对组创建：</a></p>
<p id="map%E5%AE%B9%E5%99%A8%EF%BC%9A-toc" style="margin-left:0px;"><a href="#map%E5%AE%B9%E5%99%A8%EF%BC%9A">map容器：</a></p>
<hr id="hr-toc"/>
<p></p>
<h1 id="STL%EF%BC%9A">STL：</h1>
<p>STL，即标准模板库，用着感觉和python差不多。</p>
<p>STL 六大组件：容器（序例式和关联式） 算法（质变和非质变） 迭代器 仿函数 适配器 空间配置器。首先，我们来看以下Vector容器：</p>
<h1 id="vector%E5%AE%B9%E5%99%A8%EF%BC%9A">vector容器：</h1>
<p>不同之处是数组是静态空间，而vector可以动态扩展。</p>
<p>迭代器：随机访问迭代器</p>
<pre><code class="language-cpp">vector.begin()指向第一个
vector.end()指向最后一个元素的后面一个
vector.rbegin()指向倒数第一个元素
vector.rend()指向第一个元素的前一个</code></pre>
<p><br/> 容器嵌套:</p>
<pre><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt;</code></pre>
<p><br/> 构造：</p>
<pre><code class="language-cpp">vector&lt;int&gt;v1;
vector&lt;int&gt;v2(v1.begin(),v1.end())
vector&lt;int&gt;v3(10,100)</code></pre>
<p><br/> 赋值：</p>
<pre><code class="language-cpp">直接等号赋值
vector.assign(10,100)
vector.assign(begin,end)</code></pre>
<p><br/> 容量和大小：</p>
<pre><code class="language-cpp">empty()
capacity()
size()
resize(num)
resize(num,elem)elem为填充元素</code></pre>
<p><br/> 插入和删除：</p>
<pre><code class="language-cpp">push_back() 尾部添加元素
pop_back()删除尾部元素
insert(迭代器pose，elem)
insert(迭代器pose，n,elem)插入n个
erase(迭代器pose)删除索引位置
erase（v.begin(),v.end()）区间删除
clear()清空</code></pre>
<p><br/> 数据存取：</p>
<pre><code>at(int dex)返回索引为idx的元素
operator[]返回索引为idx的元素，如v[idx]
front()返回容器中第一个数据元素
back()返回容器中最后一个数据元素</code></pre>
<p><br/> 互换容器：</p>
<pre><code>swap(v)</code></pre>
<p><br/> 实际用途：收缩占用空间 vector&lt;int&gt;(v).swap(v),创建匿名对象进行互换，达到收缩空间的效果<br/> 预留空间：<br/>  </p>
<pre><code>reserve(len) 容器预留len个元素长度，不进行初始化，不可访问，而resize（）则被初始化为0</code></pre>
<h1 id="string%E5%AE%B9%E5%99%A8%EF%BC%9A">string容器：</h1>
<p>string拼接函数：</p>
<pre><code>
string.append(str,n)截取前n个元素进行拼接
string.append(str,start,n)可以选择从第n个截取</code></pre>
<p><br/> string查找和替换：</p>
<pre><code>string.find(str)返回查找子字符串中第一个元素的索引，没有返回-1
string.rfind(str)区别在于rfind从右往左查
string.replace(start,n,str)从start开始的n个字符替换为str</code></pre>
<p><br/> 字符串比较（ASCII码值逐个比较）：</p>
<pre><code>string.compare(str)大于返回1，等于返回0，小于返回-1</code></pre>
<p><br/> 字符串存取：</p>
<pre><code>string[i],string.at(i)可以修改或访问第i个元素</code></pre>
<p><br/> 字符串插入和删除：</p>
<pre><code>string.insert(n,str) str.erase(i,n)删除从i开始的n个字符</code></pre>
<p><br/> 求子串操作：<br/>  </p>
<pre><code>string.substr(start,n)</code></pre>
<h1 id="deque%E5%AE%B9%E5%99%A8%EF%BC%9A">deque容器：</h1>
<p>构造：</p>
<pre><code>deque&lt;int&gt;d1;
deque&lt;int&gt;d2(d1.begin(),d1.end());
deque&lt;int&gt;d3(10,100);
deque&lt;int&gt;d4(d3);</code></pre>
<p><br/> 赋值操作：</p>
<pre><code>deque&lt;int&gt;d2=d1;
deque&lt;int&gt;d3.assign(d1.begin(),d1.end());
deque&lt;int&gt;d4.assign(10,100)</code></pre>
<p><br/> 大小操作：</p>
<pre><code>deque.empty()
deque.size()
deque.resize(size)
deque.resize(size,elem)</code></pre>
<p><br/> 插入和删除;</p>
<pre><code>deque.push_back()尾插
deque.push_front()头插
deque.pop_back()尾删
deque.pop_front()头删
deque.erase(迭代器pose)
deque.insert(deque.begin(),elem)
deque.insert(deque.begin(),num,elem)
deque.insert(deque.begin(),d2.begin(),d2.end())
deque.erase（deque.begin(),deque.end()）
deque.clear()清空</code></pre>
<p><br/> 数据存取：</p>
<pre><code>at(int dex)返回索引为idx的元素
operator[]返回索引为idx的元素，如deque[idx]
front()返回容器中第一个数据元素
back()返回容器中最后一个数据元素</code></pre>
<p><br/> 排序：<br/>  </p>
<pre><code>sort(iterator begin,iterator end)默认升序，对于支持随即访问迭代器的容器，都可以直接使用该算法进行排序</code></pre>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;deque&gt;
using namespace std;
void printdeq(const deque&lt;int &gt;&amp;d)
{
    for (deque&lt;int&gt;::const_iterator it=d.begin();it&lt;d.end();it++)
    {
        cout&lt;&lt;*it&lt;&lt;" ";
    }
    cout&lt;&lt;endl;
}
void test()
{
    deque&lt;int&gt;d;
    d.push_back(1);
    d.push_back(3);
    d.push_back(2);
    sort(d.begin(),d.end());
    printdeq(d);

}


int main()
{
    test();
}
</code></pre>
<p> </p>
<h1 id="stack%E5%AE%B9%E5%99%A8%EF%BC%9A(%E5%85%88%E8%BF%9B%E5%90%8E%E5%87%BA)">stack容器：(先进后出)</h1>
<p>构造：</p>
<pre><code>stack&lt;int&gt;s;</code></pre>
<p><br/> 插入和删除：<br/>  </p>
<pre><code>stack.push()插入
stack.pop()删除
stack.empty()判断是否为空
stack.size()大小
s.top()栈顶元素</code></pre>
<h1 id="queue%E5%AE%B9%E5%99%A8%EF%BC%9A%EF%BC%88%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%EF%BC%89">queue容器：（先进先出）</h1>
<pre><code>queue.push()插入
queue.pop()删除
queue.empty()判断是否为空
queue.size()大小
queue.front()队头元素
queue.back()队尾元素</code></pre>
<p> </p>
<h1 id="list%E5%AE%B9%E5%99%A8%EF%BC%9A">list容器：</h1>
<p>链表由一个个结点（数据域+指针域）构成，与数组相比可以快速添加或者和删除元素，但是遍历速度没有数组快，而且占用空间比数组要大。STL链表是双向循环链表。<br/> 迭代器属于双向迭代器，不支持随机访问，而且进行插入和删除操作时，原有迭代器不会失效。<br/> 构造函数：</p>
<pre><code>list&lt;int&gt;l1;
list&lt;int&gt;l2(l1.begin(),l1.end())
list&lt;int&gt;l3(num,elem)
list&lt;int&gt;l4(l3)</code></pre>
<p><br/> 赋值和交换：</p>
<pre><code>list.assign(beg,end)
list.assign(num,elem)
=赋值，如l1=l2
l1.swap(l2)交换</code></pre>
<p><br/> 大小操作：</p>
<pre><code>list.size()
list.empty()
list.resize(size)
list.resize(size,elem)</code></pre>
<p><br/> 插入和删除：</p>
<pre><code>push_back(elem)尾插
pop_back()尾删
push_front(elem)头插
pop_front()头删
insert(pose,elem) pose(迭代器)处插入元素
insert(pose,n,elem)插入n个元素
insert(pose,beg,end)区间插入，从pose开始
clear()清空
erase(pose)删除pose处的元素
erase(beg,end)删除区间元素
remove(elem)移除elem元素</code></pre>
<p><br/> 数据存取：<br/>  </p>
<pre><code>list.front()返回首元素
list.back()返回尾部元素
反转和排序：
list.reverse()反转
list.sort()排序,默认升序,若需要降序，则需要加仿函数</code></pre>
<pre><code class="language-cpp">//list降序升序排列
#include &lt;iostream&gt;
#include &lt;list&gt;
using namespace std;

void printlist(list&lt;int&gt;&amp;l)
{
    for(list&lt;int&gt;::iterator it=l.begin();it!=l.end();it++)
    {
        cout&lt;&lt;*it&lt;&lt;" ";
    }
    cout&lt;&lt;endl;
}
bool compare(int val1,int val2)
{
    return val1&gt;val2;
}
void test()
{
    list&lt;int&gt;l;

        l.push_back(40);
        l.push_back(60);
        l.push_back(430);
        l.push_back(0);
        l.push_back(5);
        l.push_back(4);
        cout&lt;&lt;"排序前： "&lt;&lt;endl;
        printlist(l);
        l.sort();
        cout&lt;&lt;"升序排列： "&lt;&lt;endl;
        printlist(l);
        cout&lt;&lt;"降序排列： "&lt;&lt;endl;
        l.sort(compare);
        printlist(l);
}

int main()
{
    test();
    return 0;
}</code></pre>
<p> </p>
<pre><code class="language-cpp">//自定义类型排序
#include&lt;iostream&gt;
#include &lt;list&gt;
using namespace std;
class Person
{
    public:
    string name;
    int age;
    int height;
    Person(string na,int a,int b)
    {
        name=na;
        age=a;
        height=b;
    }
};
void setperson(list&lt;Person&gt;&amp;l)
{
    Person p1("A",17,175);
    Person p2("B",18,172);
    Person p3("C",17,175);
    Person p4("D",18,168);
    Person p5("E",17,170);
    l.push_back(p1);
    l.push_back(p2);
    l.push_back(p3);
    l.push_back(p4);
    l.push_back(p5);
}
bool mycompare(Person p1,Person p2)
{
    if(p1.age==p2.age)
    {
        return p1.height&lt;p2.height;
    }
    else
    return p1.age&lt;p2.age;
}
void printperson(list&lt;Person&gt;l)
{
    for(list&lt;Person&gt;::iterator it=l.begin();it!=l.end();it++)
    {
        cout&lt;&lt;"姓名： "&lt;&lt;it-&gt;name&lt;&lt;"  age: "&lt;&lt;(*it).age&lt;&lt;"  height: "&lt;&lt;it-&gt;height&lt;&lt;endl;
    }
}
int main()
{

    list&lt;Person&gt;l;
    setperson(l);
    cout&lt;&lt;"排序前:"&lt;&lt;endl;
    printperson(l);
    l.sort(mycompare);
    cout&lt;&lt;"排序后:"&lt;&lt;endl;
    printperson(l);

    return 0;
}</code></pre>
<p> </p>
<h1 id="set%2Fmultiset%E5%AE%B9%E5%99%A8%EF%BC%9A">set/multiset容器：</h1>
<p>所有元素在插入时自动被排序，属于关联式容器，底层结构为二叉树<br/> set与multiset区别：set不允许有重复元素，而multiset可以<br/> 构造和赋值：</p>
<pre><code>set&lt;int&gt;s1
set&lt;int&gt;s2(s1)
=赋值
插入：只有insert方式
set.insert(elem)注意：若要是插入后元素是降序排列，则要使用仿函数作为排列规则</code></pre>
<p><br/> 大小和交换：</p>
<pre><code>set.size()
set.empty()
set.swap(l)</code></pre>
<p><br/> 插入和删除：</p>
<pre><code>set.insert(elem)
set.clear()
set.erase(pos)
set.erase(betg,end)
set.erase(elem)</code></pre>
<p><br/> 查找和统计：<br/>  </p>
<pre><code>set.find(key)返回该元素的迭代器，若不存在，则fanhuiset.end()
set.count(key)</code></pre>
<pre><code class="language-cpp">//利用仿函数指定创建时的排序规则
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;set&gt;
using namespace std;
class Person
{
public:
string name;
int age;
Person(string a,int b)
{
    this-&gt;name=a;
    this-&gt;age=b;
};
};

class mycompare
{
public:
   bool  operator()(const Person &amp;p1,const Person &amp;p2)
    {
        return p1.age&gt;p2.age;
    }

};

void printperson(set&lt;Person,mycompare&gt;s)
{
    for(set&lt;Person,mycompare&gt;::iterator it=s.begin();it!=s.end();it++)
    {
        cout&lt;&lt;it-&gt;name&lt;&lt;"  "&lt;&lt;(*it).age&lt;&lt;endl;
    }
}

void setperson()
{
    Person p1("A",13);
    Person p2("B",12);
    Person p3("C",16);
    Person p4("D",10);
    set&lt;Person,mycompare&gt;s;
    cout&lt;&lt;"降序插入"&lt;&lt;endl;
    s.insert(p1);
    s.insert(p2);
    s.insert(p3);
    s.insert(p4);
    printperson(s);
}

int main()
{
    set&lt;Person&gt;p;
    setperson();
    return 0;
}</code></pre>
<p> </p>
<h1 id="pair%E5%AF%B9%E7%BB%84%E5%88%9B%E5%BB%BA%EF%BC%9A">pair对组创建：</h1>
<pre><code>使用时不需要包含头文件
pair&lt;type,type&gt; p(val1,val2)
pair&lt;type,type&gt; p=make_pair(val1,val2)
获取：p.first p.second</code></pre>
<h1 id="map%E5%AE%B9%E5%99%A8%EF%BC%9A">map容器：</h1>
<p>1.map中所有元素都是pair<br/> 2.pair中第一个元素时键值key，起到索引作用，第二个元素为实值value<br/> 3.所有元素会根据键值自动排序<br/> 4.属于关联式容器，底层用二叉树实现<br/> map和multimap区别：<br/> 1.map允许有重复key值元素<br/> 2.multimap允许容器中有重复key值元素<br/> 构造和赋值：</p>
<pre><code>map&lt;int,int&gt;m1;
map&lt;int,int&gt;m2(m1);
map&lt;int,int&gt;m3;m3=m2;</code></pre>
<p><br/> 大小和交换：</p>
<pre><code>map.size()
m.empty()
m.swap(m1)</code></pre>
<p><br/> 插入和删除：</p>
<pre><code>m.insert(elem)
m.clear()
m.erase(pose)
m.erase(beg,end)
m.erase(key)</code></pre>
<p><br/> 查找和统计：</p>
<pre><code>m.find(key)
m.count(key)</code></pre>
<p><br/> 排序：可以利用仿函数指定排序规则</p>
<p></p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;map&gt;
using namespace std;

class Mycompare
{
    public:
    bool operator()(int v1,int v2)
    {
        return v1&gt;v2;
    }
};
void print1(map&lt;int,int&gt;&amp;m)
{
    for(map&lt;int,int&gt;::iterator it=m.begin();it!=m.end();it++)
    {
        cout&lt;&lt;"key="&lt;&lt;it-&gt;first&lt;&lt;"value="&lt;&lt;it-&gt;second&lt;&lt;endl;
    }
    cout&lt;&lt;endl;
}
void test01()
{
    map&lt;int,int&gt;m;
    m.insert(make_pair(1,10));
    m.insert(make_pair(3,30));
    m.insert(make_pair(2,20));
    cout&lt;&lt;"升序"&lt;&lt;endl;
    print1(m);
}
void print2(map&lt;int,int,Mycompare&gt;&amp;m)
{
    for(map&lt;int,int,Mycompare&gt;::iterator it=m.begin();it!=m.end();it++)
    {
        cout&lt;&lt;"key="&lt;&lt;it-&gt;first&lt;&lt;"value="&lt;&lt;it-&gt;second&lt;&lt;endl;
    }
    cout&lt;&lt;endl;
}
void test02()
{
    map&lt;int,int,Mycompare&gt;m1;
    m1.insert(make_pair(1,10));
    m1.insert(make_pair(3,30));
    m1.insert(make_pair(2,20));
    cout&lt;&lt;"降序"&lt;&lt;endl;
    print2(m1);
}
int main()
{
    test01();
    test02();
    return 0;
}</code></pre>
<p> 本文代码被本人不小心删除了大量例程，所以很多部分没有代码，若有不懂的小伙伴，欢迎讨论。</p>
</div>
</div>