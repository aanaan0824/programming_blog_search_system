<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<blockquote>
<p>✅🎡个人主页：<a href="https://blog.csdn.net/aasd23?spm=1000.2115.3001.5343" title="程序猿追">程序猿追</a></p>
<p>✅🎡系列专栏：<a href="https://blog.csdn.net/aasd23/category_11805404.html?spm=1001.2014.3001.5482" title="算法合集">算法合集</a></p>
<p>✅🎡目前状态：创建Java学习之路（零基础到就业实战）系列，目前更新到JAVAWEB开发</p>
<p>✅🎡作者简介：大家好，我是程序猿追，全栈领域新星创作者，算法爱好者，常在作者周榜排名前30，某不知名的 ACMer</p>
<p>✅🎡推荐一款刷题面试找工作三不误的网站——<a href="https://www.nowcoder.com/link/pc_csdncpt_cxyz_sf" title="牛客网">牛客网</a></p>
<p>✅🎡个人名言：不积跬步无以至千里，趁年轻，使劲拼，给未来的自己一个交代！</p>
</blockquote>
<p></p>
<p id="main-toc"><strong>目录</strong></p>
<p id="%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86">二叉树的前序遍历</a></p>
<p id="%E9%A2%98%E8%A7%A3%E4%BB%A3%E7%A0%81-toc" style="margin-left:40px;"><a href="#%E9%A2%98%E8%A7%A3%E4%BB%A3%E7%A0%81">题解代码</a></p>
<p id="%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86">二叉树的中序遍历</a></p>
<p id="%C2%A0%E9%A2%98%E8%A7%A3%E4%BB%A3%E7%A0%81-toc" style="margin-left:40px;"><a href="#%C2%A0%E9%A2%98%E8%A7%A3%E4%BB%A3%E7%A0%81"> 题解代码</a></p>
<p id="%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86">二叉树的后序遍历</a></p>
<p id="%E9%A2%98%E8%A7%A3%E4%BB%A3%E7%A0%81-toc" style="margin-left:40px;"><a href="#%E9%A2%98%E8%A7%A3%E4%BB%A3%E7%A0%81">题解代码</a></p>
<p id="%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-toc" style="margin-left:0px;"><a href="#%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86">求二叉树的层序遍历</a></p>
<p id="%E9%A2%98%E8%A7%A3%E4%BB%A3%E7%A0%81-toc" style="margin-left:40px;"><a href="#%E9%A2%98%E8%A7%A3%E4%BB%A3%E7%A0%81">题解代码</a></p>
<hr id="hr-toc"/>
<p></p>
<p></p>
<h1 id="%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86">二叉树的前序遍历</h1>
<blockquote>
<p><strong>描述</strong></p>
<p>给你二叉树的根节点 root ，返回它节点值的 前序<em> </em>遍历。</p>
<p>数据范围：二叉树的节点数量满足 0≤n≤100  ，二叉树节点的值满足1≤val≤100  ，树的各节点的值各不相同</p>
</blockquote>
<blockquote>
<p>示例1： </p>
<p><img alt="" height="229" src="image\632526253f35454e918e1d334d757560.png" width="189"/></p>
<p></p>
</blockquote>
<p></p>
<blockquote>
<p><strong>输入：</strong></p>
<pre>{1,#,2,3}</pre>
<p><strong>返回值：</strong></p>
<pre>[1,2,3]</pre>
</blockquote>
<h2 id="%E9%A2%98%E8%A7%A3%E4%BB%A3%E7%A0%81">题解代码</h2>
<pre><code class="language-java">import java.util.*;
public class Solution {
    public void preorder(List&lt;Integer&gt; list, TreeNode root){
        //遇到空节点则返回 fast-template
        if(root == null)
            return;
        //先遍历根节点
        list.add(root.val);
        //再去左子树
        preorder(list, root.left);
        //最后去右子树
        preorder(list, root.right);
    }
    public int[] preorderTraversal (TreeNode root) {
        //添加遍历结果的数组
        List&lt;Integer&gt; list = new ArrayList();
        //递归前序遍历
        preorder(list, root);
        //返回的结果
        int[] res = new int[list.size()];
        for(int i = 0; i &lt; list.size(); i++)
            res[i] = list.get(i);
        return res;}
}</code></pre>
<h1 id="%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86">二叉树的中序遍历</h1>
<blockquote>
<p><strong>描述</strong></p>
<p>给定一个二叉树的根节点root，返回它的中序遍历结果。</p>
<p></p>
<p>数据范围：树上节点数满足0≤n≤1000，树上每个节点的值满足 0≤val≤1000<br/> 进阶：空间复杂度 O(n)，时间复杂度 O(n)</p>
</blockquote>
<p><strong>示例1</strong></p>
<blockquote>
<p><strong>输入：</strong></p>
<pre>{1,2,#,#,3}</pre>
<p><strong>返回值：</strong></p>
<pre>[2,3,1]
</pre>
<p>说明：</p>
<pre>
</pre>
</blockquote>
<p></p>
<blockquote>
<p>示例2</p>
<p><strong>输入：</strong></p>
<p>{}</p>
<p><strong>返回值：</strong></p>
<p>[]</p>
<p>示例3</p>
<p><strong>输入：</strong></p>
<p>{1,2}</p>
<p><strong>返回值：</strong></p>
<p>[2,1]</p>
<p><strong>说明：</strong></p>
<p>示例4</p>
<p><strong>输入：</strong></p>
<p>{1,#,2}</p>
<p><strong>返回值：</strong></p>
<p>[1,2]</p>
</blockquote>
<h2 id="%C2%A0%E9%A2%98%E8%A7%A3%E4%BB%A3%E7%A0%81"> 题解代码</h2>
<pre><code class="language-java">import java.util.*;
public class Solution {
    public void inorder(List&lt;Integer&gt; list, TreeNode root){
        //遇到空节点则返回 fast-template
        if(root == null)
            return;
        //先去左子树
        inorder(list, root.left);
        //再访问根节点
        list.add(root.val);
        //最后去右子树
        inorder(list, root.right);
    }
    public int[] inorderTraversal (TreeNode root) {
         //添加遍历结果的数组
        List&lt;Integer&gt; list = new ArrayList();
        //递归中序遍历
        inorder(list, root);
        //返回的结果
        int[] res = new int[list.size()];
        for(int i = 0; i &lt; list.size(); i++)
            res[i] = list.get(i);
        return res;}
}</code></pre>
<h1 id="%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86">二叉树的后序遍历</h1>
<blockquote>
<p><strong>描述</strong></p>
<p>给定一个二叉树，返回他的后序遍历的序列。</p>
<p>后序遍历是值按照 左节点-&gt;右节点-&gt;根节点 的顺序的遍历。</p>
<p>数据范围：二叉树的节点数量满足0≤n≤100  ，二叉树节点的值满足 11≤val≤100  ，树的各节点的值各不相同</p>
<p></p>
<p><strong>样例图</strong></p>
<p><img alt="" height="214" src="image\6ea92b9215cb4ba89da209a4765f7578.png" width="323"/></p>
<p></p>
<p></p>
<p>示例1</p>
<p><strong>输入：</strong></p>
<pre>{1,#,2,3}</pre>
<p><strong>返回值：</strong></p>
<pre>[3,2,1]
</pre>
<p><strong>说明：</strong></p>
<pre>如题面图   </pre>
<p>示例2</p>
<p><strong>输入：</strong></p>
<pre>{1}</pre>
<p><strong>返回值：</strong></p>
<pre>[1]</pre>
</blockquote>
<h2>题解代码</h2>
<pre><code class="language-java">import java.util.*;
public class Solution {
    public void postorder(List&lt;Integer&gt; list, TreeNode root){
        //遇到空节点则返回 fast-template
        if(root == null)
            return;
         //先去左子树
        postorder(list, root.left);
        //再去右子树
        postorder(list, root.right);
        //最后访问根节点
        list.add(root.val);
    }
    public int[] postorderTraversal (TreeNode root) {
        //添加遍历结果的数组
        List&lt;Integer&gt; list = new ArrayList();
        //递归后序遍历
        postorder(list, root);
        //返回的结果
        int[] res = new int[list.size()];
        for(int i = 0; i &lt; list.size(); i++)
            res[i] = list.get(i);
        return res;}
}</code></pre>
<h1 id="%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86">求二叉树的层序遍历</h1>
<p>描述</p>
<blockquote>
<p>给定一个二叉树，返回该二叉树层序遍历的结果，（从左到右，一层一层地遍历）<br/> 例如：<br/> 给定的二叉树是{3,9,20,#,#,15,7},<br/><img alt="" height="219" src="image\29e445f5bb70484eaaa9ec06409f246d.png" width="267"/><br/> 该二叉树层序遍历的结果是<br/> [<br/> [3],<br/> [9,20],<br/> [15,7] </p>
<p>]</p>
<p>数据范围：二叉树的节点数满足 1≤n≤105 </p>
<p></p>
<p>示例1</p>
<p><strong>输入：</strong></p>
<p>{1,2}<br/><strong>返回值：</strong><br/> [[1],[2]]</p>
<p>示例2</p>
<p><strong>输入：</strong></p>
<p>{1,2,3,4,#,#,5}</p>
<p><strong>返回值：</strong></p>
<p>[[1],[2,3],[4,5]]</p>
</blockquote>
<h2>题解代码</h2>
<pre><code class="language-java">import java.util.*;
public class Solution {
    public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; levelOrder (TreeNode root) {
        ArrayList&lt;ArrayList&lt;Integer&gt; &gt; res = new ArrayList();
        if(root == null)
            //如果是空，则直接返回空数组 fast-template
            return res;
        //队列存储，进行层次遍历
        Queue&lt;TreeNode&gt; q = new ArrayDeque&lt;TreeNode&gt;();
        q.add(root);
        while(!q.isEmpty()){
            //记录二叉树的某一行
            ArrayList&lt;Integer&gt; row = new ArrayList();
            int n = q.size();
            //因先进入的是根节点，故每层结点多少，队列大小就是多少
            for(int i = 0; i &lt; n; i++){
                TreeNode cur = q.poll();
                row.add(cur.val);
                //若是左右孩子存在，则存入左右孩子作为下一个层次
                if(cur.left != null)
                    q.add(cur.left);
                if(cur.right != null)
                    q.add(cur.right);
            }
            //每一层加入输出
            res.add(row);
        }
        return res;}
}</code></pre>
<p></p>
<blockquote>
<p>算法对程序员来说及其重要，语言和开发平台不断变化，但是万变不离其宗的是那些算法和理论，依稀记得我那个玩的很好的一个学长（在大二就拿到了 offer），他告诉我想找一个好的工作，那刷题一定是必不可少的</p>
<p>现在算法刷题平台还是蛮多的，给大家介绍一个我认为与大厂关联最深的平台——<a href="https://www.nowcoder.com/link/pc_csdncpt_cxyz_sf" title="牛客网">牛客网</a></p>
</blockquote>
<p></p>
</div>
</div>