<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="markdown_views prism-dracula" id="content_views">
<svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
<path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
</svg>
<p></p>
<div class="toc">
<h3>C# 知识点汇总整理</h3>
<ul><li><a href="#_2">前言</a></li><li><a href="#_11">一，变量与常量</a></li><li><ul><li><a href="#11__12">1.1 命名</a></li><li><a href="#12__17">1.2 使用</a></li></ul>
</li><li><a href="#_23">二，数据类型</a></li><li><ul><li><a href="#21__24">2.1 值类型</a></li><li><a href="#22__26">2.2 引用类型</a></li><li><a href="#23__29">2.3 类型转换</a></li><li><a href="#24__32">2.4 拓展：字符串类型</a></li></ul>
</li><li><a href="#_40">三，运算符</a></li><li><ul><li><a href="#31__41">3.1 算数运算符</a></li><li><a href="#32__45">3.2 赋值运算符</a></li><li><a href="#33__49">3.3 关系运算符</a></li></ul>
</li><li><a href="#_57">四，语句类型</a></li><li><ul><li><a href="#41__58">4.1 顺序语句</a></li><li><a href="#42__59">4.2 分支语句</a></li><li><a href="#43__64">4.3 循环语句</a></li></ul>
</li><li><a href="#_70">五，数组</a></li><li><ul><li><a href="#51__71">5.1 一维数组</a></li><li><a href="#52__77">5.2 数组的使用</a></li><li><a href="#53__82">5.3 二维数组</a></li></ul>
</li><li><a href="#_92">六，函数</a></li><li><ul><li><a href="#61__94">6.1 方法的声明</a></li><li><a href="#62__98">6.2 方法的调用</a></li><li><a href="#63__101">6.3 方法的参数</a></li><li><a href="#64__111">6.4 方法返回值</a></li><li><a href="#65__115">6.5 方法的重载</a></li><li><a href="#66__119">6.6 方法的递归</a></li></ul>
</li><li><a href="#_127">七，类和对象</a></li><li><ul><li><a href="#71__129">7.1 访问修饰符</a></li><li><a href="#72__146">7.2 类和对象</a></li></ul>
</li><li><a href="#_183">八，面向对象</a></li><li><ul><li><a href="#81__184">8.1 封装</a></li><li><a href="#82__190">8.2 继承</a></li><li><a href="#83__201">8.3 多态</a></li></ul>
</li><li><a href="#_216">九，接口，结构体和枚举</a></li><li><ul><li><a href="#91__217">9.1 接口</a></li><li><a href="#92__225">9.2 结构体</a></li><li><a href="#93__239">9.3 枚举</a></li></ul>
</li><li><a href="#_266">十，委托和事件</a></li><li><ul><li><a href="#101__267">10.1 委托</a></li><li><a href="#102__289">10.2 事件</a></li></ul>
</li><li><a href="#_300">十一，泛型和系统类</a></li><li><ul><li><a href="#111__301">11.1 泛型</a></li><li><a href="#112____317">11.2 系统类 - 数据结构</a></li></ul>
</li><li><a href="#_335">十二，进阶部分</a></li><li><ul><li><a href="#121__337">12.1 异常</a></li><li><a href="#122__344">12.2 反射</a></li><li><a href="#123__362">12.3 特性</a></li><li><a href="#124__378">12.4 多线程</a></li></ul>
</li></ul>
</div>
<p></p>
<h1><a id="_2"></a>前言</h1>
<blockquote>
<p><font size="3">本文属于<strong>C#零基础入门之百识百例</strong>系列知识点整理目录。此系列文章旨在为学习C#语言的童鞋提供一套系统的学习路径。此系列文章都会通过【知识点】【练习题】的形式呈现。有任何问题，你都可以通过<strong>评论</strong>，<strong>私信</strong>等方式找到我，我会一对一解答你的问题。</font></p>
<p><br/><font color="qwasd" size="3">系列文章目录: </font><img alt="导图" src="https://img-blog.csdnimg.cn/3d3ca6e25dd7487e819f2e9806e4ddc8.png#pic_center"/><br/> <font color="a" size="3">《C#零基础入门之百识百例》</font> <font size="4"><u><a href="https://blog.csdn.net/czhenya/category_11241715.html">学习专栏地址</a></u></font></p>
</blockquote>
<hr/>
<h1><a id="_11"></a>一，变量与常量</h1>
<h2><a id="11__12"></a>1.1 命名</h2>
<ul><li>命名规则</li><li>组成规则</li><li>驼峰命名</li><li>见名知意</li></ul>
<h2><a id="12__17"></a>1.2 使用</h2>
<ul><li>定义声明</li><li>作用域</li><li>oreadonly，const关键字</li></ul>
<hr/>
<h1><a id="_23"></a>二，数据类型</h1>
<h2><a id="21__24"></a>2.1 值类型</h2>
<ul><li>在内存中存储的是一个具体的值</li></ul>
<h2><a id="22__26"></a>2.2 引用类型</h2>
<ul><li>在内存中存储的是一块内存地址</li></ul>
<h2><a id="23__29"></a>2.3 类型转换</h2>
<ul><li>强制转换</li><li>Convert类</li></ul>
<h2><a id="24__32"></a>2.4 拓展：字符串类型</h2>
<ul><li>常用方法</li><li>@字符</li><li>$字符</li></ul>
<hr/>
<h1><a id="_40"></a>三，运算符</h1>
<h2><a id="31__41"></a>3.1 算数运算符</h2>
<ul><li>+、-、*、/、%</li><li>++，–</li></ul>
<h2><a id="32__45"></a>3.2 赋值运算符</h2>
<ul><li>=</li><li>+=、-=、*=、/=、%=</li></ul>
<h2><a id="33__49"></a>3.3 关系运算符</h2>
<ul><li>或与非 | &amp; ！</li><li>双与&amp;&amp;，双或 ||</li><li>异或^</li><li>三目运算符 
  <ul><li>? :</li></ul> </li></ul>
<p>–</p>
<h1><a id="_57"></a>四，语句类型</h1>
<h2><a id="41__58"></a>4.1 顺序语句</h2>
<h2><a id="42__59"></a>4.2 分支语句</h2>
<ul><li>if else</li><li>switch case</li><li>break，continue，goto</li></ul>
<h2><a id="43__64"></a>4.3 循环语句</h2>
<ul><li>for</li><li>white 和 do…white</li><li>foreach</li></ul>
<hr/>
<h1><a id="_70"></a>五，数组</h1>
<h2><a id="51__71"></a>5.1 一维数组</h2>
<ul><li>概念</li><li>关键字</li><li>声明</li><li>初始化</li></ul>
<h2><a id="52__77"></a>5.2 数组的使用</h2>
<ul><li>遍历</li><li>排序</li><li>查找</li></ul>
<h2><a id="53__82"></a>5.3 二维数组</h2>
<ul><li>声明</li><li>初始化</li><li>访问</li><li>下标取值</li><li>遍历数组</li><li>应用</li><li>表示地图</li></ul>
<hr/>
<h1><a id="_92"></a>六，函数</h1>
<h2><a id="61__94"></a>6.1 方法的声明</h2>
<ul><li>语法格式</li><li>注意事项</li></ul>
<h2><a id="62__98"></a>6.2 方法的调用</h2>
<ul><li>调用语法</li></ul>
<h2><a id="63__101"></a>6.3 方法的参数</h2>
<ul><li>什么是参数？</li><li>参数的写法</li><li>参数默认值</li><li>特殊参数标识 
  <ul><li>ref</li><li>out</li><li>param</li><li>位置参数，命名参数</li></ul> </li></ul>
<h2><a id="64__111"></a>6.4 方法返回值</h2>
<ul><li>概念说明</li><li>return关键字</li></ul>
<h2><a id="65__115"></a>6.5 方法的重载</h2>
<ul><li>定义：使用同一个方法名，参数类型或个数不一样的函数</li><li>注意事项</li></ul>
<h2><a id="66__119"></a>6.6 方法的递归</h2>
<ul><li>定义：递归的本质就是自己调用自己。</li><li>要素</li><li>递归条件</li><li>递归出口</li></ul>
<hr/>
<h1><a id="_127"></a>七，类和对象</h1>
<h2><a id="71__129"></a>7.1 访问修饰符</h2>
<ul><li>修饰对象<br/> 变量，属性，方法，类</li><li>修饰作用<br/> 限制修饰内容的访问权限</li><li>修饰符 
  <ul><li>public<br/> 公有的，不受限制可任意访问</li><li>private<br/> 私有的，只限于本类中访问</li><li>protected<br/> 保护的，只限于本类和子类中访问</li><li>internal<br/> 内部的，只限于程序集内访问</li><li>protected internal<br/> 内部保护的，只限于程序集内或者子类访问</li></ul> </li></ul>
<h2><a id="72__146"></a>7.2 类和对象</h2>
<ul><li>定义：拥有一定特性和功能额一个类别</li><li>语法<br/> class 类名{ // 实现 }</li><li>成员<br/> 成员变量<br/> 成员方法</li><li>new 关键字<br/> 实例化 T t1 = new T();<br/> 访问对象成员</li><li>this关键字<br/> 表示当前对象</li><li>static关键字<br/> 用途<br/> 修饰变量，方法，类</li><li>声明<br/> 写法示例<br/> 静态类的访问</li><li>类名.属性名<br/> 和非静态之间区别<br/> 类的特殊函数</li><li>构造函数<br/> 定义概念<br/> 语法规则<br/> 调用方式</li><li>其他构造 
  <ul><li>静态构造 
    <ul><li>创建静态构造</li><li>语法规则</li></ul> </li><li>私有化构造 
    <ul><li>限定只有本类中实例化</li></ul> </li></ul> </li><li>析构函数<br/> 定义概念<br/> 调用方式<br/> 语法特性</li></ul>
<hr/>
<h1><a id="_183"></a>八，面向对象</h1>
<h2><a id="81__184"></a>8.1 封装</h2>
<ul><li>原则：在程序中，尽量不要出现重复的代码</li><li>封装 
  <ul><li>类中只存储当前类有关内容</li><li>每一个功能模块都是一个方法</li></ul> </li></ul>
<h2><a id="82__190"></a>8.2 继承</h2>
<ul><li>概念理解</li><li>实现语法</li><li>继承后对父类的访问</li><li>单继承</li><li>子类构造 
  <ul><li>执行逻辑：优先执行父类构造，在执行子类构造</li><li>构造函数无论有参无参，无论有多少个子类都必须至少有一个和父类保持一致</li></ul> </li><li>base关键字 
  <ul><li>语法： 子类构造:base(形参传递)</li></ul> </li></ul>
<h2><a id="83__201"></a>8.3 多态</h2>
<ul><li>向上转型(隐式转型) 
  <ul><li>将一个子类类型的对象称作父类类型</li></ul> </li><li>向下转型(强制转换) 
  <ul><li>将一个父类类型的对象称作子类类型</li><li>强制转换语法</li><li>as关键字</li><li>is关键字</li></ul> </li><li>override关键字 
  <ul><li>重写方法只能修改方法体</li><li>base.方法名()调用父类方法<br/> 面试问的多态</li><li>不同对象同一类型，这个类型的对象都可以做某一件事</li><li>因此不同的对象在做这件事的时候，做的方式也是不同的，当然结果也是不同的</li></ul> </li></ul>
<h1><a id="_216"></a>九，接口，结构体和枚举</h1>
<h2><a id="91__217"></a>9.1 接口</h2>
<ul><li>定义，关键字 
  <ul><li>interface 接口名称</li></ul> </li><li>接口实现 
  <ul><li>接口的实现实际上和类之间的继承是一样的，也是重写了接口中的方法，让其有了具体的实现内容。</li></ul> </li><li>接口中的多态实现 
  <ul><li>定义接口并使用类实现了接口中的成员。</li><li>创建接口的实例指向不同的实现类对象。</li></ul> </li></ul>
<h2><a id="92__225"></a>9.2 结构体</h2>
<ul><li>定义，关键字</li><li>结构体和类 
  <ul><li>相同点 
    <ul><li>都可以有变量，属性，方法</li><li>都可以有静态变量，方法</li><li>都是使用new关键字实例化</li></ul> </li><li>不同点 
    <ul><li>类是引用类型，结构体是值类型</li><li>构造函数的使用上的不同</li><li>与类相比结构体无继承关系</li><li>结构体重不能定义虚方法</li></ul> </li><li>用途</li></ul> </li></ul>
<h2><a id="93__239"></a>9.3 枚举</h2>
<ul><li>概念定义</li><li>使用示例</li><li>类型转换</li><li>osealed关键字 
  <ul><li>表示密封，可修饰类，方法</li><li>sealed修饰的类无法被继承</li><li>sealed只能修饰重写(override)方法</li></ul> </li><li>运算符重载 
  <ul><li>可重载的运算符 
    <ul><li>算数：+，-，x，/，%，++，–</li><li>关系：必须成对重载【&gt; &lt;】，【&gt;= &lt;=】，【==，!=】</li><li>逻辑：&amp; | ！^</li></ul> </li><li>作用<br/> 使不能进行运算的对象，运算符重载后，也能通过运算符运算</li></ul> </li><li>关键字<br/> operator</li><li>访问修饰<br/> 必须是public static</li><li>定义语法<br/> public static 返回值类型 operator 运算符（参数）{//⽅法体}</li><li>返回值 
  <ul><li>一元：返回值必须是参数类型或者参数子类型</li><li>二元：返回值可自定义</li></ul> </li><li>用途<br/> 对象与对象之间运算的快捷方式</li></ul>
<h1><a id="_266"></a>十，委托和事件</h1>
<h2><a id="101__267"></a>10.1 委托</h2>
<ul><li>委托定义<br/> [访问修饰符] delegate 返回值 委托名称 (参数列表);</li><li>关键字<br/> delegate</li><li>委托使用<br/> 使用示例</li><li>多波委托<br/> 概念说明<br/> 使用示例</li><li>系统带的委托 
  <ul><li>Action<br/> 没有返回值的委托<br/> 可传递无限个参数</li><li>Func<br/> 带有返回值的委托<br/> 最后一个参数代表返回值<br/> 最多传递16个参数和返回值</li></ul> </li><li>匿名函数<br/> 语法概念</li><li>Lambda表达式</li></ul>
<h2><a id="102__289"></a>10.2 事件</h2>
<ul><li>定义</li><li>事件就是一个特殊的委托对象</li><li>命名空间</li><li>概念定义</li><li>using 关键字 
  <ul><li>命名空间内可以包含类，接口，结构体，枚举，命名空间</li><li>访问命名空间内容</li></ul> </li></ul>
<hr/>
<h1><a id="_300"></a>十一，泛型和系统类</h1>
<h2><a id="111__301"></a>11.1 泛型</h2>
<ul><li>泛型 
  <ul><li>表示一种模糊的类型</li><li>泛型的应用范围</li></ul> </li><li>类/接口 
  <ul><li>声明泛型类 类名&lt;泛型标识符&gt;</li><li>使用泛型类 T p = new T();</li></ul> </li><li>方法 
  <ul><li>声明泛型方法 方法名&lt;泛型&gt;</li><li>用泛型作为方法返回值类型</li><li>用泛型作为方法参数类型</li></ul> </li><li>泛型特点 
  <ul><li>泛型类型不能继承</li><li>但泛型类和泛型接口可以继承/实现</li><li>在继承泛型类或泛型接口的时候必须将泛型设置为实际类型进行使用</li></ul> </li></ul>
<h2><a id="112____317"></a>11.2 系统类 - 数据结构</h2>
<ul><li>Array 数组<br/> 必须制定类型，指定长度，内存地址连续</li><li>Array List 动态数组<br/> 存储空间随着元素个数变换，地址不连续<br/> 内部定义好的增删改查的基础函数</li><li>List 列表<br/> 一个引用类型的容器，只能存一种类型数据<br/> 存储空间随着元素数量进行变换</li><li>Stack 栈<br/> 先进后出 - 枪膛上子弹</li><li>Queue 队列<br/> 先进先出 - 超市排队</li><li>Dictionary 字典<br/> 通过key值去找value<br/> 内部定义好的增删改查</li></ul>
<hr/>
<h1><a id="_335"></a>十二，进阶部分</h1>
<h2><a id="121__337"></a>12.1 异常</h2>
<ul><li>语法概念 
  <ul><li>一个try可以有多个catch 
    <ul><li>若多个catch中没有继承关系，顺序随意</li><li>若多个catch有继承关系，则子类在前，父类在后</li></ul> </li></ul> </li><li>自定义异常</li></ul>
<h2><a id="122__344"></a>12.2 反射</h2>
<ul><li>概念定义<br/> 反射指程序可以访问、检测和修改它本身状态或行为的一种能力。</li><li>优缺点 
  <ul><li>优点 
    <ul><li>反射提高了程序的灵活性和扩展性</li><li>降低耦合性，提高自适应能力</li><li>它允许程序创建和控制任何类队形，无需提前硬编码目标类</li></ul> </li><li>缺点</li><li>性能问题：使用反射基本上是一种解释操作，用于字段和方法接入是要远慢于直接代码</li><li>使用反射会模糊程序内部逻辑；反射代码比相应的直接代码更复杂</li></ul> </li><li>发射用途 
  <ul><li>它允许在运行时查看特性</li><li>它允许审查集合中的各种类型，以及实例化这些类型</li><li>它允许延迟绑定方法和属性</li><li>它允许在运行时创建新类型，然后使用其执行一个逻辑</li></ul> </li><li>查看元数据</li></ul>
<h2><a id="123__362"></a>12.3 特性</h2>
<ul><li>定义概念 
  <ul><li>特性（Attribute）是用于在运行时传递程序中各种元素（比如类、方法、结构、枚举、组件等）的行为信息的声明性标签。</li></ul> </li><li>规定特性 
  <ul><li>[attribute(positional_parameters, name_parameter = value, …)]element</li></ul> </li><li>特性（Attribute）的名称和值是在方括号内规定的，放置在它所应用的元素之前。positional_parameters 规定必需的信息，name_parameter 规定可选的信息。</li><li>预定义特性 
  <ul><li>AttributeUsage</li><li>Conditional</li><li>Obsolete</li></ul> </li><li>创建自定义特性 
  <ul><li>声明</li><li>构建</li><li>在目标元素上应用</li><li>通过反射访问</li></ul> </li></ul>
<h2><a id="124__378"></a>12.4 多线程</h2>
<ul><li>线程定义 
  <ul><li>线程 被定义为程序的执行路径。每个线程都定义了一个独特的控制流。</li></ul> </li><li>线程生命周期 
  <ul><li>未启动状态 
    <ul><li>线程实例被创建，但Start方法未被调用</li></ul> </li><li>就绪状态 
    <ul><li>当线程转变好运行并等待CPU周期时的状态</li></ul> </li><li>不可运行状态 
    <ul><li>已经调用Sleep方法</li><li>已经调用Wait方法</li><li>通过 I/O 操作阻塞</li></ul> </li><li>死亡状态 
    <ul><li>当线程已完成执行或终止执行的状态</li></ul> </li><li>主线程 
    <ul><li>进程中第一个被执行的线程称为主线程。</li></ul> </li></ul> </li><li>Thread 类常用的属性和方法</li><li>创建线程<br/> 线程是通过扩展 Thread 类创建的。</li><li>管理线程<br/> Thread 类提供了各种管理线程的方法。</li><li>销毁线程<br/> Abort() 方法用于销毁线程。</li></ul>
<hr/>
<hr/>
<center>
<font color="read" size="5">~完整导图~</font>
</center>
<p><img alt="请添加图片描述" src="https://img-blog.csdnimg.cn/ef2733d675004e38b1a9d096d19ac22d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6ZmI6KiA5b-F6KGM,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<p><a href="https://download.csdn.net/download/Czhenya/52674746">完整PDF下载地址</a>，没有积分的童鞋可以点击👇🏻 下方卡片，回复”C#学习“ 获取资料，还有免费教学视频等你哦~👇🏻</p>
</div>
<link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css" rel="stylesheet"/>
<link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css" rel="stylesheet"/>
</div>