<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<p id="main-toc"><strong>目录</strong></p>
<p id="%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%C2%A0%F0%9F%9A%80-toc" style="margin-left:0px;"><a href="#%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%C2%A0%F0%9F%9A%80">第七章 基本类型 🚀</a></p>
<p id="7.1%20%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B%C2%A0%F0%9F%9A%80-toc" style="margin-left:40px;"><a href="#7.1%20%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B%C2%A0%F0%9F%9A%80">7.1 整数类型 🚀</a></p>
<p id="7.1.1%20C99%20%E4%B8%AD%E7%9A%84%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B%C2%A0%F0%9F%9A%80-toc" style="margin-left:80px;"><a href="#7.1.1%20C99%20%E4%B8%AD%E7%9A%84%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B%C2%A0%F0%9F%9A%80">7.1.1 C99 中的整数类型 🚀</a></p>
<p id="7.1.2%20%E6%95%B4%E6%95%B0%E5%B8%B8%E9%87%8F%C2%A0%F0%9F%9A%80-toc" style="margin-left:80px;"><a href="#7.1.2%20%E6%95%B4%E6%95%B0%E5%B8%B8%E9%87%8F%C2%A0%F0%9F%9A%80">7.1.2 整数常量 🚀</a></p>
<p id="7.1.4%20%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%C2%A0%F0%9F%9A%80-toc" style="margin-left:80px;"><a href="#7.1.4%20%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%C2%A0%F0%9F%9A%80">7.1.4 整数溢出 🚀</a></p>
<p id="7.2%20%E6%B5%AE%E7%82%B9%E7%B1%BB%E5%9E%8B%C2%A0%F0%9F%9A%80-toc" style="margin-left:40px;"><a href="#7.2%20%E6%B5%AE%E7%82%B9%E7%B1%BB%E5%9E%8B%C2%A0%F0%9F%9A%80">7.2 浮点类型 🚀</a></p>
<p id="7.2.1%20%E6%B5%AE%E7%82%B9%E5%B8%B8%E9%87%8F%C2%A0%F0%9F%9A%80-toc" style="margin-left:80px;"><a href="#7.2.1%20%E6%B5%AE%E7%82%B9%E5%B8%B8%E9%87%8F%C2%A0%F0%9F%9A%80">7.2.1 浮点常量 🚀</a></p>
<p id="7.2.2%20%E8%AF%BB%2F%E5%86%99%E6%B5%AE%E7%82%B9%E6%95%B0%C2%A0%F0%9F%9A%80-toc" style="margin-left:80px;"><a href="#7.2.2%20%E8%AF%BB%2F%E5%86%99%E6%B5%AE%E7%82%B9%E6%95%B0%C2%A0%F0%9F%9A%80">7.2.2 读/写浮点数 🚀</a></p>
<p id="7.3.1%20%E5%AD%97%E7%AC%A6%E6%93%8D%E4%BD%9C%C2%A0%F0%9F%9A%80-toc" style="margin-left:80px;"><a href="#7.3.1%20%E5%AD%97%E7%AC%A6%E6%93%8D%E4%BD%9C%C2%A0%F0%9F%9A%80">7.3.1 字符操作 🚀</a></p>
<p id="7.3.2%20%E6%9C%89%E7%AC%A6%E5%8F%B7%E5%AD%97%E7%AC%A6%E5%92%8C%E6%97%A0%E7%AC%A6%E5%8F%B7%E5%AD%97%E7%AC%A6%C2%A0%F0%9F%9A%80-toc" style="margin-left:80px;"><a href="#7.3.2%20%E6%9C%89%E7%AC%A6%E5%8F%B7%E5%AD%97%E7%AC%A6%E5%92%8C%E6%97%A0%E7%AC%A6%E5%8F%B7%E5%AD%97%E7%AC%A6%C2%A0%F0%9F%9A%80">7.3.2 有符号字符和无符号字符 🚀</a></p>
<p id="7.3.3%20%E7%AE%97%E6%9C%AF%E7%B1%BB%E5%9E%8B%C2%A0%F0%9F%9A%80-toc" style="margin-left:80px;"><a href="#7.3.3%20%E7%AE%97%E6%9C%AF%E7%B1%BB%E5%9E%8B%C2%A0%F0%9F%9A%80">7.3.3 算术类型 🚀</a></p>
<p id="7.3.4%20%E8%BD%AC%E4%B9%89%E5%BA%8F%E5%88%97%C2%A0%F0%9F%9A%80-toc" style="margin-left:80px;"><a href="#7.3.4%20%E8%BD%AC%E4%B9%89%E5%BA%8F%E5%88%97%C2%A0%F0%9F%9A%80">7.3.4 转义序列 🚀</a></p>
<p id="7.3.6%20%E7%94%A8%20scanf%20%E5%92%8C%20printf%20%E8%AF%BB%2F%E5%86%99%E5%AD%97%E7%AC%A6%C2%A0%F0%9F%9A%80-toc" style="margin-left:80px;"><a href="#7.3.6%20%E7%94%A8%20scanf%20%E5%92%8C%20printf%20%E8%AF%BB%2F%E5%86%99%E5%AD%97%E7%AC%A6%C2%A0%F0%9F%9A%80">7.3.6 用 scanf 和 printf 读/写字符 🚀</a></p>
<p id="7.3.7%20%E7%94%A8%20getchar%20%E5%92%8C%20putchar%20%E8%AF%BB%2F%E5%86%99%E5%AD%97%E7%AC%A6%C2%A0%F0%9F%9A%80-toc" style="margin-left:80px;"><a href="#7.3.7%20%E7%94%A8%20getchar%20%E5%92%8C%20putchar%20%E8%AF%BB%2F%E5%86%99%E5%AD%97%E7%AC%A6%C2%A0%F0%9F%9A%80">7.3.7 用 getchar 和 putchar 读/写字符 🚀</a></p>
<p id="7.4%20%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%C2%A0%F0%9F%9A%80-toc" style="margin-left:40px;"><a href="#7.4%20%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%C2%A0%F0%9F%9A%80">7.4 类型转换 🚀</a></p>
<p id="7.4.1%20%E5%B8%B8%E7%94%A8%E7%AE%97%E6%9C%AF%E8%BD%AC%E6%8D%A2%C2%A0%F0%9F%9A%80-toc" style="margin-left:80px;"><a href="#7.4.1%20%E5%B8%B8%E7%94%A8%E7%AE%97%E6%9C%AF%E8%BD%AC%E6%8D%A2%C2%A0%F0%9F%9A%80">7.4.1 常用算术转换 🚀</a></p>
<p id="7.4.2%20%E8%B5%8B%E5%80%BC%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E8%BD%AC%E6%8D%A2%C2%A0%F0%9F%9A%80-toc" style="margin-left:80px;"><a href="#7.4.2%20%E8%B5%8B%E5%80%BC%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E8%BD%AC%E6%8D%A2%C2%A0%F0%9F%9A%80">7.4.2 赋值过程中的转换 🚀</a></p>
<p id="7.4.4%20%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%C2%A0%F0%9F%9A%80-toc" style="margin-left:80px;"><a href="#7.4.4%20%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%C2%A0%F0%9F%9A%80">7.4.4 强制类型转换 🚀</a></p>
<p id="7.5.2%20%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89%E5%92%8C%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%80%A7%C2%A0%F0%9F%9A%80-toc" style="margin-left:80px;"><a href="#7.5.2%20%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89%E5%92%8C%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%80%A7%C2%A0%F0%9F%9A%80">7.5.2 类型定义和可移植性 🚀</a></p>
<p id="7.6%20sizeof%20%E8%BF%90%E7%AE%97%E7%AC%A6%C2%A0%F0%9F%9A%80-toc" style="margin-left:40px;"><a href="#7.6%20sizeof%20%E8%BF%90%E7%AE%97%E7%AC%A6%C2%A0%F0%9F%9A%80">7.6 sizeof 运算符 🚀</a></p>
<p id="%E9%97%AE%E4%B8%8E%E7%AD%94%C2%A0%F0%9F%9A%80-toc" style="margin-left:0px;"><a href="#%E9%97%AE%E4%B8%8E%E7%AD%94%C2%A0%F0%9F%9A%80">问与答 🚀</a></p>
<hr id="hr-toc"/>
<p></p>
<blockquote>
<p><strong>各书</strong>的<strong>读书笔记</strong>已经陆陆续续开展了哈（本书为《C语言程序设计现代方法（第二版）》）（一本书一个专栏，订阅会第一时间推荐更新哈），主要会把作者认为<strong>比较重要</strong>或者<strong>比较新奇</strong>的知识点<strong>记录</strong>下来。但是要想真的了解一本书，自己去看可能才会有更深的体会哈。</p>
<hr/>
<p><strong>C语言</strong>的<strong>入门篇进阶篇</strong>和<strong>深剖篇</strong>都整理在<a class="link-info" href="https://bbs.csdn.net/forums/FKBZM" title="这里">这里</a>了哈。然后<a class="link-info" href="https://blog.csdn.net/weixin_62700590?spm=1011.2124.3001.5343" title="这里">这里</a>是<strong>个人主页</strong>，比点头像更好找文章哈。</p>
<p><span style="color:#fe2c24;">作者新建立的社区：</span><a href="https://bbs.csdn.net/forums/FKBZM" title="非科班转码社区-CSDN社区云">非科班转码社区-CSDN社区云</a>💖💛💙</p>
<p><span style="color:#956fe7;">期待hxd的支持哈🎉 🎉 🎉</span></p>
<hr/>
<p><strong>最后是打鸡血环节：</strong><span style="color:#4da8ee;">改变的确很难，但结果值得冒险，拿出点勇气来。路还很长，现在才刚开始而已。过去无可挽回，未来可以改变。🚀 🚀 🚀</span></p>
</blockquote>
<h1 id="%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%C2%A0%F0%9F%9A%80">第七章 基本类型 🚀</h1>
<h2 id="7.1%20%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B%C2%A0%F0%9F%9A%80"><span style="color:#000000;">7.1 整数类型 </span>🚀</h2>
<div></div>
<blockquote>
<div>
<div>
<span style="color:#000000;">C</span>
<span style="color:#000000;">语言支持两种根本不同的数值类型：整数类型（也称整型）和浮点类型（也称浮点型）。 </span>
</div>
<div>
<span style="color:#000000;">整数类型</span>
<span style="color:#000000;">的值是整数，而</span>
<span style="color:#000000;">浮点类型</span>
<span style="color:#000000;">的值则可能还有小数部分。整数类型又分为两大类：有符号 型和无符号型。</span>
</div>
</div>
</blockquote>
<blockquote>
<div>
<span style="color:#000000;">（例如，除非额外说明，否则所有整数都是有符号的。因此，long signed int</span>
<span style="color:#000000;">和</span>
<span style="color:#000000;">long int</span>
<span style="color:#000000;">是一样的类型。）另外，说明符的顺序没什么影响，所以unsigned short int和</span>
<span style="color:#000000;">short unsigned int</span>
<span style="color:#000000;">是一样的。</span>
</div>
</blockquote>
<blockquote>
<p><span style="color:#000000;">C</span><span style="color:#000000;">语言允许通过省略单词</span><span style="color:#000000;">int来缩写整数类型的名字。C程序员经常会省略</span><span style="color:#000000;">int</span><span style="color:#000000;">；一些新出现的基于C</span><span style="color:#000000;">的语言（包括</span><span style="color:#000000;">Java</span><span style="color:#000000;">）甚至不允许程序员使用</span><span style="color:#000000;">short int</span><span style="color:#000000;">或</span><span style="color:#000000;">long int</span><span style="color:#000000;">这样的名字，而必须写成short</span><span style="color:#000000;">或</span><span style="color:#000000;">long</span><span style="color:#000000;">。</span></p>
</blockquote>
<blockquote>
<div>
<span style="color:#000000;">6</span>
<span style="color:#000000;">种整数类型的每一种所表示的取值范围都会根据机器的不同而不同，但是有<strong>两条</strong>所有编译 </span>
</div>
<div>
<span style="color:#000000;">器都必须遵守的<strong>原则</strong>。<strong>首先</strong>，</span>
<span style="color:#000000;">C</span>
<span style="color:#000000;">标准要求</span>
<span style="color:#000000;">short int</span>
<span style="color:#000000;">、</span>
<span style="color:#000000;">int</span>
<span style="color:#000000;">和</span>
<span style="color:#000000;">long int</span>
<span style="color:#000000;">中的每一种类型都要覆盖 </span>
</div>
<div>
<span style="color:#000000;">一个确定的最小取值范围（详见</span>
<span style="color:#000000;">23.2</span>
<span style="color:#000000;">节）。<strong>其次</strong>，标准要求</span>
<span style="color:#000000;">int</span>
<span style="color:#000000;">类型不能比</span>
<span style="color:#000000;">short int</span>
<span style="color:#000000;">类型短， </span>
</div>
<div>
<span style="color:#000000;">long int</span>
<span style="color:#000000;">类型不能比</span>
<span style="color:#000000;">int</span>
<span style="color:#000000;">类型短。但是，</span>
<span style="color:#000000;">short int</span>
<span style="color:#000000;">类型的取值范围有可能和</span>
<span style="color:#000000;">int</span>
<span style="color:#000000;">类型的范围是 </span>
</div>
<div>
<span style="color:#000000;">一样的，</span>
<span style="color:#000000;">int</span>
<span style="color:#000000;">类型的取值范围也可以和</span>
<span style="color:#000000;">long int</span>
<span style="color:#000000;">的一样。</span>
</div>
</blockquote>
<blockquote>
<div>
<span style="color:#000000;">取值范围不是</span>
<span style="color:#000000;">C</span>
<span style="color:#000000;">标准强制的，会随着编译器的不同而不同。对于特定的实现，确定整数类型范围的一种方法是检查<strong>&lt;limits.h&gt;</strong></span>
<span style="color:#000000;">头（ </span>
<span style="color:#000000;">23.2</span>
<span style="color:#000000;">节）。该头是标准库的一部分，其中定义了表示每种整数类型的最大值和最小值的宏。</span>
</div>
</blockquote>
<h3 id="7.1.1%20C99%20%E4%B8%AD%E7%9A%84%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B%C2%A0%F0%9F%9A%80"><span style="color:#000000;">7.1.1 C99 中的整数类型 </span>🚀</h3>
<h3 id="7.1.2%20%E6%95%B4%E6%95%B0%E5%B8%B8%E9%87%8F%C2%A0%F0%9F%9A%80"><span style="color:#000000;">7.1.2 整数常量 </span>🚀</h3>
<blockquote>
<p> <img alt="" height="229" src="image\386a817bf0ed4da6978e2eecd927ce9b.png" width="1000"/></p>
<p><img alt="" height="139" src="image\181e69ca93c94902a1559acaf351ec5a.png" width="834"/></p>
<div>
<span style="color:#000000;">请记住八进制和十六进制只是书写数的方式，它们不会对数的实际存储方式产生影响。（整 </span>
</div>
<div>
<span style="color:#000000;">数都是以二进制形式存储的，跟表示方式无关。）任何时候都可以从一种书写方式切换到另一种书写方式，甚至可以混合使用：10 + 015 + 0x20</span>
<span style="color:#000000;">的值为</span>
<span style="color:#000000;">55</span>
<span style="color:#000000;">（十进制）。八进制和十六进制更适用于底层程序的编写，本书直到第20</span>
<span style="color:#000000;">章才会较多地用到它们。</span> 
 </div>
</blockquote>
<h3 id="7.1.4%20%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%C2%A0%F0%9F%9A%80"><span style="color:#000000;">7.1.4</span><span style="color:#000000;"> 整数溢出 </span>🚀</h3>
<blockquote>
<div>
<span style="color:#000000;"><strong>对整数执行算术运算时，其结果有可能因为太大而无法表示。</strong>例如，对两个</span>
<span style="color:#000000;">int</span>
<span style="color:#000000;">值进行算术 </span>
</div>
<div>
<span style="color:#000000;">运算时，结果必须仍然能用</span>
<span style="color:#000000;">int</span>
<span style="color:#000000;">类型来表示；否则（表示结果所需的数位太多）就会发生</span>
<span style="color:#000000;">溢出</span>
<span style="color:#000000;">。 </span>
</div>
<div>
<span style="color:#000000;"><strong>整数溢出时的行为要根据操作数是有符号型还是无符号型来确定。</strong>有符号整数运算中发生溢 </span>
</div>
<div>
<span style="color:#000000;">出时，程序的行为是未定义的。回顾</span>
<span style="color:#000000;">4.4</span>
<span style="color:#000000;">节的介绍可知，未定义行为的结果是不确定的。最可能的情况是，仅仅是运算的结果出错了，但程序也有可能崩溃，或出现其他意想不到的状况。 </span>
</div>
<div>
<span style="color:#000000;"><strong>无符号整数运算过程中发生溢出时，结果是有定义的</strong>：正确答案对</span>
<span style="color:#000000;">2</span>
<span style="color:#000000;"><em>n </em></span>
<span style="color:#000000;">取模，其中</span>
<span style="color:#000000;"><em>n</em></span>
<span style="color:#000000;">是用于存储结果的位数。例如，如果对无符号的16</span>
<span style="color:#000000;">位数</span>
<span style="color:#000000;">65 535</span>
<span style="color:#000000;">加</span>
<span style="color:#000000;">1</span>
<span style="color:#000000;">，其结果可以保证为</span>
<span style="color:#000000;">0</span>
<span style="color:#000000;">。</span>
</div>
</blockquote>
<h2 id="7.2%20%E6%B5%AE%E7%82%B9%E7%B1%BB%E5%9E%8B%C2%A0%F0%9F%9A%80"><span style="color:#000000;">7.2 浮点类型 </span>🚀</h2>
<blockquote>
<div>
<span style="color:#000000;">整数类型并不适用于所有应用。有些时候需要变量能存储带小数点的数，或者能存储极大 </span>
</div>
<div>
<span style="color:#000000;">数或极小数。这类数可以用浮点（因小数点是“浮动的”而得名）格式进行存储。</span>
<span style="color:#000000;">C</span>
<span style="color:#000000;">语言提供 </span>
</div>
<div>
<span style="color:#000000;">了</span>
<strong><span style="color:#000000;">3</span><span style="color:#000000;">种</span><span style="color:#000000;">浮点类型</span></strong>
<span style="color:#000000;">，对应三种不同的浮点格式。</span>
</div>
<div>
<img alt="" height="122" src="image\da4e7dc23c5f42a9a54487666de1e18f.png" width="892"/>
</div>
<div>
<div>
<span style="color:#000000;">当精度要求不严格时（例如，计算带一位小数的温度），</span>
<span style="color:#000000;">float</span>
<span style="color:#000000;">类型是很适合的类型。</span>
<span style="color:#000000;">double </span>
</div>
<div>
<span style="color:#000000;">提供更高的精度，对绝大多数程序来说都够用了。</span>
<span style="color:#000000;">long double</span>
<span style="color:#000000;">支持极高精度的要求，很少会 </span>
</div>
<div>
<span style="color:#000000;">用到。</span>
</div>
<div>
<div>
<span style="color:#000000;">        C标准没有说明</span>
<span style="color:#000000;">float</span>
<span style="color:#000000;">、</span>
<span style="color:#000000;">double</span>
<span style="color:#000000;">和</span>
<span style="color:#000000;">long double</span>
<span style="color:#000000;">类型提供的精度到底是多少，因为不同的计 </span>
</div>
<div>
<span style="color:#000000;">算机可以用不同方法存储浮点数。大多数现代计算机都遵循</span>
<span style="color:#000000;">IEEE 754</span>
<span style="color:#000000;">标准（即</span>
<span style="color:#000000;">IEC 60559</span>
<span style="color:#000000;">）的规范，所以这里也用它作为一个示例。</span>
</div>
<div></div>
<div>
<img alt="" height="480" src="image\67f142a0e4a74e849a1463514c4a0c95.png" width="1200"/>
</div>
<div></div>
<div></div>
<div>
<strong><span style="color:#000000;">可以在头 &lt;float.h&gt;（ </span><span style="color:#000000;">23.1</span><span style="color:#000000;">节）中找到定义浮点类型特征的宏。</span></strong>
</div>
</div>
</div>
</blockquote>
<h3 id="7.2.1%20%E6%B5%AE%E7%82%B9%E5%B8%B8%E9%87%8F%C2%A0%F0%9F%9A%80"><span style="color:#000000;">7.2.1 浮点常量 </span>🚀</h3>
<blockquote>
<p><span style="color:#000000;">浮点常量可以有许多种书写方式。例如，下面这些常量全都是表示数</span><span style="color:#000000;">57.0</span><span style="color:#000000;">的有效方式： </span></p>
<p><img alt="" height="45" src="image\49155e917e644117b8354acbfefeebba.png" width="854"/></p>
<div>
<span style="color:#000000;"><strong>浮点常量必须包含小数点或指数</strong>；其中，指数指明了对前面的数进行缩放所需的</span>
<span style="color:#000000;">10</span>
<span style="color:#000000;">的幂次。如果有指数，需要在指数数值前放置字母E</span>
<span style="color:#000000;">（或</span>
<span style="color:#000000;">e</span>
<span style="color:#000000;">）。可选符号</span>
<span style="color:#000000;">+</span>
<span style="color:#000000;">或</span>
<span style="color:#000000;">-</span>
<span style="color:#000000;">可以出现在字母</span>
<span style="color:#000000;">E</span>
<span style="color:#000000;">（或</span>
<span style="color:#000000;">e</span>
<span style="color:#000000;">）的后边。</span>
</div>
<div></div>
<div>
<span style="color:#956fe7;"><strong>默认情况下，浮点常量都以双精度数的形式存储。</strong></span>
<span style="color:#000000;">换句话说，当</span>
<span style="color:#000000;">C</span>
<span style="color:#000000;">语言编译器在程序中发 </span>
</div>
<div>
<span style="color:#000000;">现常量</span>
<span style="color:#000000;">57.0</span>
<span style="color:#000000;">时，它会安排数据以double</span>
<span style="color:#000000;">类型变量的格式存储在内存中。<strong>这条规则通常不会 </strong></span>
</div>
<div>
<strong><span style="color:#000000;">引发任何问题，因为在需要时</span><span style="color:#000000;">double</span><span style="color:#000000;">类型的值可以自动转化为</span><span style="color:#000000;">float</span><span style="color:#000000;">类型值。</span></strong>
</div>
<div></div>
<div>
<div>
<span style="color:#000000;">在某些极个别的情况下，可能会需要强制编译器以</span>
<span style="color:#000000;">float</span>
<span style="color:#000000;">或</span>
<span style="color:#000000;">long double</span>
<span style="color:#000000;">格式存储浮点常 </span>
</div>
<div>
<span style="color:#000000;">量。为了表明只需要单精度，<strong>可以在常量的末尾处加上字母</strong></span>
<strong><span style="color:#000000;">F</span><span style="color:#000000;">或</span><span style="color:#000000;">f</span></strong>
<span style="color:#000000;">（如</span>
<span style="color:#000000;">57.0F</span>
<span style="color:#000000;">）；而为了说明常量必须以long double</span>
<span style="color:#000000;">格式存储，<strong>可以在常量的末尾处加上字母</strong></span>
<strong><span style="color:#000000;">L</span><span style="color:#000000;">或</span><span style="color:#000000;">l</span></strong>
<span style="color:#000000;">（如</span>
<span style="color:#000000;">57.0L</span>
<span style="color:#000000;">）。</span>
</div>
<div></div>
<div>
<div>
<span style="color:#000000;">C99</span>
<span style="color:#000000;">提供了十六进制浮点常量的书写规范。十六进制浮点常量以0x</span>
<span style="color:#000000;">或</span>
<span style="color:#000000;">0X</span>
<span style="color:#000000;">开头（跟十六进制整数常量类似）。这一特性很少用到。</span>
</div>
</div>
</div>
</blockquote>
<h3 id="7.2.2%20%E8%AF%BB%2F%E5%86%99%E6%B5%AE%E7%82%B9%E6%95%B0%C2%A0%F0%9F%9A%80"><span style="color:#000000;">7.2.2</span><span style="color:#000000;"> 读</span><span style="color:#000000;">/写浮点数 </span>🚀</h3>
<blockquote>
<div>
<span style="color:#000000;">前面已讨论过，转换说明符</span>
<span style="color:#000000;">%e</span>
<span style="color:#000000;">、</span>
<span style="color:#000000;">%f</span>
<span style="color:#000000;">和</span>
<span style="color:#000000;">%g</span>
<span style="color:#000000;">用于读写单精度浮点数。读写</span>
<span style="color:#000000;">double</span>
<span style="color:#000000;">和</span>
<span style="color:#000000;">long double </span>
</div>
<div>
<span style="color:#000000;">类型的值所需的转换说明符略有不同。</span>
</div>
<div></div>
<p><span style="color:#000000;">读取</span><strong><span style="color:#000000;">double</span></strong><span style="color:#000000;">类型的值时，在</span><span style="color:#000000;">e</span><span style="color:#000000;">、</span><span style="color:#000000;">f</span><span style="color:#000000;">或</span><span style="color:#000000;">g</span><span style="color:#000000;">前放置字母</span><strong><span style="color:#000000;">l</span></strong><span style="color:#000000;">：</span> </p>
<p><img alt="" height="104" src="image\3947c76e7b784ce18ee26bb5bb7cc2c5.png" width="808"/></p>
<div>
<span style="color:#000000;">注意</span>
<span style="color:#000000;">： </span>
</div>
<div>
<span style="color:#000000;">只能在</span>
<span style="color:#000000;">scanf</span>
<span style="color:#000000;">函数格式串中使用</span>
<span style="color:#000000;">l</span>
<span style="color:#000000;">，不能在</span>
<span style="color:#000000;">printf</span>
<span style="color:#000000;">函数格式串中使用。在printf函数格式串中，转换</span>
<span style="color:#000000;">e</span>
<span style="color:#000000;">、</span>
<span style="color:#000000;">f</span>
<span style="color:#000000;">和</span>
<span style="color:#000000;">g</span>
<span style="color:#000000;">可以用来写</span>
<span style="color:#000000;">float</span>
<span style="color:#000000;">类型或</span>
<span style="color:#000000;">double</span>
<span style="color:#000000;">类型的值。（C99允许printf</span>
<span style="color:#000000;">函数调用中使用</span>
<span style="color:#000000;">%le</span>
<span style="color:#000000;">、</span>
<span style="color:#000000;">%lf</span>
<span style="color:#000000;">和</span>
<span style="color:#000000;">%lg</span>
<span style="color:#000000;">，不过字母</span>
<span style="color:#000000;">l</span>
<span style="color:#000000;">不起作用。）</span>
</div>
<p></p>
<p><span style="color:#000000;">读写</span><strong><span style="color:#000000;">long double</span></strong><span style="color:#000000;">类型的值时，在</span><span style="color:#000000;">e</span><span style="color:#000000;">、</span><span style="color:#000000;">f</span><span style="color:#000000;">或</span><span style="color:#000000;">g</span><span style="color:#000000;">前放置字母</span><strong><span style="color:#000000;">L</span></strong><span style="color:#000000;">：</span> </p>
<p><img alt="" height="125" src="image\7c2836f8ecf64776908b924f1e528f8c.png" width="759"/></p>
</blockquote>
<h3 id="7.3.1%20%E5%AD%97%E7%AC%A6%E6%93%8D%E4%BD%9C%C2%A0%F0%9F%9A%80"><span style="color:#000000;">7.3.1 字符操作 </span>🚀</h3>
<blockquote>
<div>
<span style="color:#000000;">在</span>
<span style="color:#000000;">C</span>
<span style="color:#000000;">语言中字符的操作非常简单，因为存在这样一个事实：</span>
<strong><span style="color:#000000;">C</span><span style="color:#000000;">语言把字符当作小整数进行处 </span></strong>
</div>
<div>
<strong><span style="color:#000000;">理</span></strong>
<span style="color:#000000;"><strong>。</strong>毕竟所有字符都是以二进制的形式进行编码的，而且无需花费太多的想象就可以将这些二进制代码看成整数。例如，在ASCII</span>
<span style="color:#000000;">码中，字符的取值范围是</span>
<span style="color:#000000;">0000000~1111111</span>
<span style="color:#000000;">，可以看成是</span>
<span style="color:#000000;">0~ 127的整数。<strong>字符'a'</strong></span>
<strong><span style="color:#000000;">的值为</span><span style="color:#000000;">97</span><span style="color:#000000;">，</span><span style="color:#000000;">'A'</span><span style="color:#000000;">的值为</span><span style="color:#000000;">65</span><span style="color:#000000;">，</span><span style="color:#000000;">'0'</span><span style="color:#000000;">的值为</span><span style="color:#000000;">48</span><span style="color:#000000;">，而</span><span style="color:#000000;">' '</span><span style="color:#000000;">的值为</span><span style="color:#000000;">32</span></strong>
<span style="color:#000000;"><strong>。</strong>在</span>
<span style="color:#000000;">C</span>
<span style="color:#000000;">中，<strong>字符和整数之间的关联是非常强的，</strong></span>
<span style="color:#fe2c24;"><strong>字符常量事实上是int类型而不是char类型</strong></span>
<span style="color:#000000;">（这是一个非常有趣的现象，但对我们并无影响）。</span>
</div>
<p></p>
<div>
<strong><span style="color:#000000;">当计算中出现字符时，</span><span style="color:#000000;">C</span></strong>
<span style="color:#000000;"><strong>语言只是使用它对应的整数值。</strong>思考下面这个例子，假设采用</span>
<span style="color:#000000;">ASCII </span>
</div>
<div>
<span style="color:#000000;">字符集：</span>
</div>
<p><img alt="" height="218" src="image\61aa25005cde4d9382d00f5121a6ee74.png" width="857"/></p>
<div>
<span style="color:#000000;">可以像比较数那样对字符进行比较。<strong>下面的</strong></span>
<strong><span style="color:#000000;">if</span><span style="color:#000000;">语句测试</span><span style="color:#000000;">ch</span><span style="color:#000000;">中是否含有小写字母，如果有， </span></strong>
</div>
<div>
<strong><span style="color:#000000;">那么它会把</span><span style="color:#000000;">ch</span><span style="color:#000000;">转化为相应的大写字母。</span></strong>
</div>
<p><img alt="" height="85" src="image\a6edfc88946c4b4eb520bb655c52071d.png" width="728"/></p>
<div>
<span style="color:#000000;">        诸如'a'&lt;= ch</span>
<span style="color:#000000;">这样的比较使用的是字符所对应的整数值，这些数值依据使用的字符集有所不同，所以程序使用&lt;</span>
<span style="color:#000000;">、</span>
<span style="color:#000000;">&lt;=</span>
<span style="color:#000000;">、</span>
<span style="color:#000000;">&gt;</span>
<span style="color:#000000;">和</span>
<span style="color:#000000;">&gt;=</span>
<span style="color:#000000;">来进行字符比较可能不易移植。</span>
</div>
<div>
<span style="color:#000000;">        <strong>字符拥有和数相同的属性，这一事实会带来一些好处。</strong>例如，可以让for</span>
<span style="color:#000000;">语句中的控制变 </span>
</div>
<div>
<span style="color:#000000;">量遍历所有的大写字母：</span>
</div>
<div>
<img alt="" height="49" src="image\b7e462129255412c82255ebb587c77b6.png" width="757"/>
</div>
<div>
<span style="color:#000000;">        <strong>另一方面，以数的方式处理字符可能会导致编译器无法检查出来的多种编程错误</strong>，还可能会导致我们编写出诸如'a' * 'b' / 'c'</span>
<span style="color:#000000;">这类无意义的表达式。此外，<strong>这样做也可能会妨碍程 </strong></span>
</div>
<div>
<span style="color:#000000;"><strong>序的可移植性，因为程序可能会基于一些对字符集的假设。</strong>（例如，上述</span>
<span style="color:#000000;">for</span>
<span style="color:#000000;">循环假设从字母</span>
<span style="color:#000000;">A到字母Z</span>
<span style="color:#000000;">的代码都是连续的。）</span>
</div>
</blockquote>
<h3 id="7.3.2%20%E6%9C%89%E7%AC%A6%E5%8F%B7%E5%AD%97%E7%AC%A6%E5%92%8C%E6%97%A0%E7%AC%A6%E5%8F%B7%E5%AD%97%E7%AC%A6%C2%A0%F0%9F%9A%80"><span style="color:#000000;">7.3.2 有符号字符和无符号字符 </span>🚀</h3>
<blockquote>
<div>
<span style="color:#4da8ee;"><strong>C语言标准没有说明普通char类型数据是有符号型还是无符号型</strong></span>
<span style="color:#000000;">，有些编译器把它们当作 </span>
</div>
<div>
<span style="color:#000000;">有符号型来处理，有些编译器则将它们当作无符号型来处理。（甚至还有一些编译器允许程序员通过编译器选项来选择把char</span>
<span style="color:#000000;">类型当成有符号型还是无符号型。）</span>
</div>
<div></div>
<div>
<img alt="" height="111" src="image\8b40dc4d7b0845bab5fc120b54a8c2bb.png" width="1200"/>
</div>
<div>
<span style="color:#000000;">        由于字符和整数之间有密切关系，C89</span>
<span style="color:#000000;">采用术语</span>
<strong><span style="color:#000000;">整值类型</span></strong>
<span style="color:#000000;">（</span>
<span style="color:#000000;">integral type</span>
<span style="color:#000000;">）来（统称）包含整数类型和字符类型。枚举类型（ 16.5</span>
<span style="color:#000000;">节）也属于整值类型。</span>
</div>
<div>
<span style="color:#000000;">        C99<strong>不使用术语“整值类型”</strong>，而是<strong>扩展了整数类型的含义</strong>使其包含字符类型和枚举类 </span>
</div>
<div>
<span style="color:#000000;">型。</span>
<span style="color:#000000;">C99</span>
<span style="color:#000000;">中的</span>
<span style="color:#000000;">_</span>
<span style="color:#000000;">Bool</span>
<span style="color:#000000;">型（ </span>
<span style="color:#000000;">5.2</span>
<span style="color:#000000;">节）是无符号整数类型。</span> 
 </div>
</blockquote>
<h3 id="7.3.3%20%E7%AE%97%E6%9C%AF%E7%B1%BB%E5%9E%8B%C2%A0%F0%9F%9A%80"><span style="color:#000000;">7.3.3 算术类型 </span>🚀</h3>
<div></div>
<blockquote>
<div></div>
<p><img alt="" height="719" src="image\1cbc2e6610a14700b871b24d4e0d4fd1.png" width="1136"/></p>
</blockquote>
<h3 id="7.3.4%20%E8%BD%AC%E4%B9%89%E5%BA%8F%E5%88%97%C2%A0%F0%9F%9A%80"><span style="color:#000000;">7.3.4 转义序列 </span>🚀</h3>
<blockquote>
<div>
<span style="color:#000000;">        然而，一些特殊符号（比如换行符）是无法采用上述方式书写的，因为它们不可见（非打印字符），或者无法从键盘输入。</span>因此，为了使程序可以处理字符集中的每一个字符，C语言提供了一种特殊的
  <span style="color:#000000;">表示法——转义序列</span>
<span style="color:#000000;">（</span>
<span style="color:#000000;">escape sequence</span>
<span style="color:#000000;">）.。</span>
</div>
<div>
<div>
<span style="color:#000000;">        转义序列共有两种：</span>
<strong><span style="color:#000000;">字符转义序列</span></strong>
<span style="color:#000000;">（</span>
<span style="color:#000000;">character escape</span>
<span style="color:#000000;">）和</span>
<strong><span style="color:#000000;">数字转义序列</span></strong>
<span style="color:#000000;">（numeric </span>
<span style="color:#000000;">escape</span>
<span style="color:#000000;">）。</span>
</div>
<div>
<img alt="" height="298" src="image\d92e69dcaf14450b907b4cd1336e4fed.png" width="1077"/>
</div>
<p></p>
<div>
<span style="color:#000000;">        字符转义序列使用起来很容易，但是它们有一个问题：转义序列列表没有包含所有无法打印的ASCII</span>
<span style="color:#000000;">字符，只包含了最常用的字符。字符转义序列也无法用于表示基本的</span>
<span style="color:#000000;">128</span>
<span style="color:#000000;">个</span>
<span style="color:#000000;">ASCII</span>
<span style="color:#000000;">字符以外的字符。数字转义序列可以表示任何</span>
<span style="color:#000000;">字符，所以它可以解决上述问题。</span>
</div>
<div></div>
<div>
           为了把特殊字符书写成数字转义序列，首先需要在类似附录E那样的表中查找字符的八进制或十六进制值。例如，某个ASCII码转义字符（十进制值为27）对应的八进制值为33，对应的十六进制值为1B。上述八进制或十六进制码可以用来书写转义序列。
  </div>
<div>
<img alt="" height="254" src="image\8ec6669c89df4945821bf0c5d2ebbdf7.png" width="1046"/>
</div>
<div>
<span style="color:#000000;">       <strong> 作为字符常量使用时，转义序列必须用一对单引号括起来。</strong>例如，表示转义字符的常量可以写成'\33'</span>
<span style="color:#000000;">（或</span>
<span style="color:#000000;">'\x1b'</span>
<span style="color:#000000;">）的形式。转义序列可能有点隐晦，所以采用</span>
<span style="color:#000000;">#define</span>
<span style="color:#000000;">的方式给它们 </span>
</div>
<div>
<span style="color:#000000;">命名通常是个不错的主意：</span>
</div>
<p><img alt="" height="33" src="image\0c8c9cefc8694fd0b686a4456f11798e.png" width="745"/></p>
</div>
</blockquote>
<h3 id="7.3.6%20%E7%94%A8%20scanf%20%E5%92%8C%20printf%20%E8%AF%BB%2F%E5%86%99%E5%AD%97%E7%AC%A6%C2%A0%F0%9F%9A%80"><span style="color:#000000;">7.3.6</span><span style="color:#000000;"> 用 </span><span style="color:#000000;"><strong>scanf </strong></span><span style="color:#000000;">和 </span><span style="color:#000000;"><strong>printf </strong></span><span style="color:#000000;">读</span><span style="color:#000000;">/写字符 </span>🚀</h3>
<blockquote>
<p><span style="color:#000000;">转换说明</span><span style="color:#000000;">%c</span><span style="color:#000000;">允许</span><span style="color:#000000;">scanf</span><span style="color:#000000;">函数和</span><span style="color:#000000;">printf</span><span style="color:#000000;">函数对单个字符进行读</span><span style="color:#000000;">/写操作： </span></p>
<p><img alt="" height="108" src="image\90061dd47fd14f66bf04a1b040d84bdf.png" width="782"/></p>
<div>
<span style="color:#000000;">在读入字符前，</span>
<span style="color:#000000;">scanf</span>
<span style="color:#000000;">函数不会跳过空白字符。如果下一个未读字符是空格，那么在前面 </span>
</div>
<div>
<span style="color:#000000;">的例子中，</span>
<span style="color:#000000;">scanf</span>
<span style="color:#000000;">函数返回后变量</span>
<span style="color:#000000;">ch</span>
<span style="color:#000000;">将包含一个空格。为了强制</span>
<span style="color:#000000;">scanf</span>
<span style="color:#000000;">函数在读入字符前跳过空白字符，需要在格式串中的转换说明%c</span>
<span style="color:#000000;">前面加上一个空格：</span>
</div>
<p><img alt="" height="45" src="image\72a3d195a1ea4a8e82f01402af9612fa.png" width="864"/></p>
<div>
<span style="color:#000000;">回顾</span>
<span style="color:#000000;">3.2</span>
<span style="color:#000000;">节的内容，</span>
<strong><span style="color:#fe2c24;">scanf格式串中的空白意味着“跳过零个或多个空白字符</span><span style="color:#000000;">”。 </span></strong>
</div>
<div>
<span style="color:#000000;">        因为通常情况下scanf</span>
<span style="color:#000000;">函数不会跳过空白，所以它很容易检查到输入行的结尾：检查刚读 </span>
</div>
<div>
<span style="color:#000000;">入的字符是否为换行符。例如，下面的循环将读入并且忽略掉当前输入行中剩下的所有字符：</span>
</div>
<div>
<img alt="" height="96" src="image\3acbf47397cd401bb1ea5df294489e4c.png" width="762"/>
</div>
<p><span style="color:#000000;">下次调用</span><span style="color:#000000;">scanf</span><span style="color:#000000;">函数时，将读入下一输入行中的第一个字符。</span>  </p>
</blockquote>
<h3 id="7.3.7%20%E7%94%A8%20getchar%20%E5%92%8C%20putchar%20%E8%AF%BB%2F%E5%86%99%E5%AD%97%E7%AC%A6%C2%A0%F0%9F%9A%80"><span style="color:#000000;">7.3.7</span><span style="color:#000000;"> 用 </span><span style="color:#000000;"><strong>getchar </strong></span><span style="color:#000000;">和 </span><span style="color:#000000;"><strong>putchar </strong></span><span style="color:#000000;">读</span><span style="color:#000000;">/写字符 </span>🚀</h3>
<blockquote>
<p></p>
<div>
<span style="color:#000000;">C</span>
<span style="color:#000000;">语言还提供了另外一些读</span>
<span style="color:#000000;">/</span>
<span style="color:#000000;">写单个字符的方法。特别是，<strong>可以使用getchar</strong></span>
<strong><span style="color:#000000;">函数和 </span></strong>
</div>
<div>
<strong><span style="color:#000000;">putchar函数来取代scanf</span><span style="color:#000000;">函数和</span><span style="color:#000000;">printf</span><span style="color:#000000;">函数。</span></strong>
<span style="color:#000000;">putchar</span>
<span style="color:#000000;">函数用于写单个字符：</span>
</div>
<div>
<img alt="" height="43" src="image\5af934c809cd454899621cb918bc2f69.png" width="664"/>
</div>
<div>
<strong><span style="color:#000000;">        每次调用getchar</span><span style="color:#000000;">函数时，它会读入一个字符并将其返回。为了保存这个字符，必须使用赋值</span></strong>
<strong><span style="color:#000000;">操作将其存储到变量中：</span></strong>
</div>
<div>
<img alt="" height="50" src="image\fd1699dbac3347b684bce79f81f2e831.png" width="816"/>
</div>
<div>
<strong><span style="color:#000000;">事实上，</span><span style="color:#000000;">getchar</span><span style="color:#000000;">函数返回的是一个</span><span style="color:#000000;">int</span><span style="color:#000000;">类型的值而不是</span><span style="color:#000000;">char</span></strong>
<span style="color:#000000;"><strong>类型的值（因为读取失败返回-1）。</strong>因此，如果一个变量用于存储getchar</span>
<span style="color:#000000;">函数读取的字符，其类型设置为</span>
<span style="color:#000000;">int</span>
<span style="color:#000000;">而不是</span>
<span style="color:#000000;">char</span>
<span style="color:#000000;">也 没啥好奇怪的。<strong>和scanf</strong></span>
<strong><span style="color:#000000;">函数一样，</span><span style="color:#000000;">getchar</span><span style="color:#000000;">函数也</span><span style="color:#fe2c24;">不会</span><span style="color:#000000;">在读取时跳过空白字符。</span></strong>
</div>
<div>
<div>
<strong><span style="color:#000000;">        执行程序时，使用getchar</span><span style="color:#000000;">函数和</span><span style="color:#000000;">putchar</span><span style="color:#000000;">函数（胜于</span><span style="color:#000000;">scanf</span><span style="color:#000000;">函数和</span><span style="color:#000000;">printf</span></strong>
<span style="color:#000000;"><strong>函数）可以节约时间。</strong>getchar</span>
<span style="color:#000000;">函数和</span>
<span style="color:#000000;">putchar</span>
<span style="color:#000000;">函数执行速度快有两个原因。<strong>第一个原因是</strong>，这两个函数比</span>
<span style="color:#000000;">scanf函数和printf</span>
<span style="color:#000000;">函数简单得多，因为</span>
<span style="color:#000000;">scanf</span>
<span style="color:#000000;">函数和</span>
<span style="color:#000000;">printf</span>
<span style="color:#000000;">函数是设计用来按不同的格式读</span>
<span style="color:#000000;">/</span>
<span style="color:#000000;">写多种不同类型数据的。<strong>第二个原因是</strong>，为了额外的速度提升，通常getchar</span>
<span style="color:#000000;">函数和</span>
<span style="color:#000000;">putchar</span>
<span style="color:#000000;">函数是作为宏（ 14.3</span>
<span style="color:#000000;">节）来实现的。</span>
</div>
</div>
<div>
<span style="color:#000000;">        getchar函数还有一个优于</span>
<span style="color:#000000;">scanf</span>
<span style="color:#000000;">函数的地方：因为返回的是读入的字符，所以</span>
<span style="color:#000000;">getchar</span>
<span style="color:#000000;">函 </span>
</div>
<div>
<span style="color:#000000;">数可以应用在多种不同的</span>
<span style="color:#000000;">C语言惯用法中，包括用在搜索字符或跳过所有出现的同一字符的循环中。思考下面这个</span>
<span style="color:#000000;">scanf</span>
<span style="color:#000000;">函数循环，前面我们曾用它来跳过输入行的剩余部分： </span>
</div>
<div>
<img alt="" height="313" src="image\18f6164c9883434fa8151343bdde6a6d.png" width="915"/>
</div>
<div>
<span style="color:#000000;">这个循环读入一个字符，把它存储在变量</span>
<span style="color:#000000;">ch</span>
<span style="color:#000000;">中，然后测试变量</span>
<span style="color:#000000;">ch</span>
<span style="color:#000000;">是否不是换行符。如果测试结果为真，那么执行循环体（循环体实际为空），接着再次测试循环条件，从而引发读入新的字符。<strong>实际上我们并不需要变量ch，可以把</strong></span>
<strong><span style="color:#000000;">getchar</span></strong>
<span style="color:#000000;"><strong>函数的返回值与换行符进行比较</strong>：</span>
</div>
<p><img alt="" height="326" src="image\2341ee8d79c440c0bf2bafc4780c73ae.png" width="1120"/></p>
<p><img alt="" height="346" src="image\33ffa5548d814a86a6113761a5973042.png" width="1193"/></p>
</blockquote>
<h2 id="7.4%20%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%C2%A0%F0%9F%9A%80"><span style="color:#000000;">7.4 类型转换 </span>🚀</h2>
<blockquote>
<div>
<span style="color:#000000;">C</span>
<span style="color:#000000;">语言则允许在表达式中混合使用基本类型。在单个表达式中可以组合整数、浮点数，甚 </span>
</div>
<div>
<span style="color:#000000;">至是字符。当然，在这种情况下</span>
<span style="color:#000000;">C</span>
<span style="color:#000000;">编译器可能需要生成一些指令将某些操作数转换成不同类型，使得硬件可以对表达式进行计算。例如，如果对16</span>
<span style="color:#000000;">位</span>
<span style="color:#000000;">short</span>
<span style="color:#000000;">型数和</span>
<span style="color:#000000;">32</span>
<span style="color:#000000;">位</span>
<span style="color:#000000;">int</span>
<span style="color:#000000;">型数进行加法操作，那么编译器将安排把16</span>
<span style="color:#000000;">位</span>
<span style="color:#000000;">short</span>
<span style="color:#000000;">型值转换成</span>
<span style="color:#000000;">32</span>
<span style="color:#000000;">位值。如果是</span>
<span style="color:#000000;">int</span>
<span style="color:#000000;">型数据和</span>
<span style="color:#000000;">float</span>
<span style="color:#000000;">型数据进行加法操作，那么编译器将安排把int</span>
<span style="color:#000000;">型值转换成为</span>
<span style="color:#000000;">float</span>
<span style="color:#000000;">格式。这个转换过程稍微复杂一些，因为</span>
<span style="color:#000000;">int型值和float</span>
<span style="color:#000000;">型值的存储方式不同。</span>
</div>
<div>
<span style="color:#000000;">因为编译器可以自动处理这些转换而无需程序员介入，所以这类转换称为</span>
<span style="color:#000000;"><strong>隐式转换</strong>（implicit conversion</span>
<span style="color:#000000;">）。</span>
<span style="color:#000000;">C</span>
<span style="color:#000000;">语言还允许程序员使用强制运算符执行</span>
<strong><span style="color:#000000;">显式转换</span></strong>
<span style="color:#000000;">（</span>
<span style="color:#000000;">explicitconversion）。</span>
</div>
<p><span style="color:#000000;">当发生下列情况时会进行隐式转换。</span></p>
<p><img alt="" height="191" src="image\555454412c4542feabddb01988f6fa95.png" width="1176"/></p>
</blockquote>
<h3 id="7.4.1%20%E5%B8%B8%E7%94%A8%E7%AE%97%E6%9C%AF%E8%BD%AC%E6%8D%A2%C2%A0%F0%9F%9A%80"><span style="color:#000000;">7.4.1 常用算术转换 </span>🚀</h3>
<blockquote>
<p><img alt="" height="483" src="image\c857778183fe47f09da92c04cdcc1796.png" width="1200"/></p>
</blockquote>
<h3 id="7.4.2%20%E8%B5%8B%E5%80%BC%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E8%BD%AC%E6%8D%A2%C2%A0%F0%9F%9A%80"><span style="color:#000000;">7.4.2 赋值过程中的转换 </span>🚀</h3>
<blockquote>
<div>
<span style="color:#000000;">        常用算术转换不适用于赋值运算。C</span>
<span style="color:#000000;">语言会遵循另一条简单的转换规则，那就是把赋值运算右边的表达式转换成左边变量的类型。如果变量的类型至少和表达式类型一样“宽”，那么这种转换将没有任何障碍。</span>
</div>
<div>
<img alt="" height="243" src="image\fce01f43b1e347889747622f1e7bcb44.png" width="860"/>
</div>
<div>
<div>
<span style="color:#000000;">其他情况下是有问题的。把浮点数赋值给整型变量会丢掉该数的小数部分。</span>
</div>
<div>
<img alt="" height="130" src="image\e1b81561f0f649f093f80c6962934dcc.png" width="757"/>
</div>
<div>
<div>
<span style="color:#000000;">此外，把某种类型的值赋给类型更狭小的变量时，如果该值在变量类型范围之外，那么将 </span>
</div>
<div>
<span style="color:#000000;">会得到无意义的结果（甚至更糟）。</span>
</div>
<div>
<img alt="" height="110" src="image\0e930c2533ae40feb96349b85b248c1f.png" width="754"/>
</div>
<p><span style="color:#000000;">这类赋值可能会导致编译器或</span><span style="color:#000000;">lint</span><span style="color:#000000;">之类的工具发出警告。 </span></p>
<div>
<strong><span style="color:#000000;">如果浮点常量被赋值给</span><span style="color:#000000;">float</span><span style="color:#000000;">型变量时，一个很好的方法是在浮点常量尾部加上后辍</span><span style="color:#000000;">f</span></strong>
<span style="color:#000000;">，本 </span>
</div>
<div>
<span style="color:#000000;">书从第</span>
<span style="color:#000000;">2</span>
<span style="color:#000000;">章开始就一直是这么做的：</span>
</div>
<p><img alt="" height="54" src="image\d14cf4f60d7f43f3a4bc8145f110f4b1.png" width="732"/></p>
<p><strong><span style="color:#000000;">如果没有后辍，常量</span><span style="color:#000000;">3.14159</span><span style="color:#000000;">将是</span><span style="color:#000000;">double</span><span style="color:#000000;">类型，可能会引起警告消息。</span> </strong></p>
</div>
</div>
</blockquote>
<div>
<span style="color:#000000;">7.4.3 C99 </span>
<span style="color:#000000;">中的隐式转换</span>
</div>
<blockquote>
<div>
<div>
<strong><span style="color:#000000;">C99</span><span style="color:#000000;">用</span><span style="color:#000000;">整数提升</span></strong>
<span style="color:#000000;">（</span>
<span style="color:#000000;">integer promotion</span>
<span style="color:#000000;">）取代了</span>
<strong><span style="color:#000000;">C89</span><span style="color:#000000;">中的</span><span style="color:#000000;">整值提升</span></strong>
<span style="color:#000000;">（</span>
<span style="color:#000000;">integral promotion</span>
<span style="color:#000000;">），可以将任何等级低于int</span>
<span style="color:#000000;">和</span>
<span style="color:#000000;">unsigned int</span>
<span style="color:#000000;">的类型转换为</span>
<span style="color:#000000;">int</span>
<span style="color:#000000;">（只要该类型的所有值都可以用</span>
<span style="color:#000000;">int</span>
<span style="color:#000000;">类型表 </span>
</div>
<div>
<span style="color:#000000;">示）或</span>
<span style="color:#000000;">unsigned int</span>
<span style="color:#000000;">。</span>
</div>
</div>
</blockquote>
<h3 id="7.4.4%20%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%C2%A0%F0%9F%9A%80"><span style="color:#000000;">7.4.4 强制类型转换 </span>🚀</h3>
<blockquote>
<div>
<img alt="" height="88" src="image\0d0fc37837bc4175812b67af29f9c593.png" width="830"/>
</div>
<p><img alt="" height="137" src="image\c7143bf60d1d41f8ab66a0159640bb3d.png" width="1154"/></p>
<div>
<span style="color:#000000;">强制类型转换表达式</span>
<span style="color:#000000;">(int)f</span>
<span style="color:#000000;">表示把</span>
<span style="color:#000000;">f</span>
<span style="color:#000000;">的值</span>
<span style="color:#000000;">转换成</span>
<span style="color:#000000;">int</span>
<span style="color:#000000;">类型后的结果。</span>
<span style="color:#000000;">C</span>
<span style="color:#000000;">语言的常用算术转换则要 </span>
</div>
<div>
<span style="color:#000000;">求在进行减法运算前把</span>
<span style="color:#000000;">(int)f</span>
<span style="color:#000000;">转换回</span>
<span style="color:#000000;">float</span>
<span style="color:#000000;">类型。</span>
<span style="color:#000000;">f</span>
<span style="color:#000000;">和</span>
<span style="color:#000000;">(int)f</span>
<span style="color:#000000;">的不同之处就在于</span>
<span style="color:#000000;">f</span>
<span style="color:#000000;">的小数部分， </span>
</div>
<div>
<span style="color:#000000;">这部分在强制类型转换时被丢掉了。</span>
</div>
<div></div>
<p><img alt="" height="256" src="image\f6cd0033ef7d4570b1b02bbe3386f6ec.png" width="1036"/></p>
<div>
<span style="color:#000000;">正如现在写的那样，除法的结果是一个整数，在把结果存储在</span>
<span style="color:#000000;">quotient</span>
<span style="color:#000000;">变量中之前，要把结果 </span>
</div>
<div>
<span style="color:#000000;">转换成</span>
<span style="color:#000000;">float</span>
<span style="color:#000000;">格式。但是，为了得到更精确的结果，可能需要在除法执行</span>
<span style="color:#000000;">之前</span>
<span style="color:#000000;">把</span>
<span style="color:#000000;">dividend</span>
<span style="color:#000000;">和 </span>
</div>
<div>
<span style="color:#000000;">divisor</span>
<span style="color:#000000;">的类型转换成</span>
<span style="color:#000000;">float</span>
<span style="color:#000000;">格式的。强制类型转换表达式可以完成这一点：</span>
</div>
<div>
<img alt="" height="52" src="image\6da5814594664c4eba17f7f2734a5bd0.png" width="824"/>
</div>
<div>
<span style="color:#000000;">变量</span>
<span style="color:#000000;">divisor</span>
<span style="color:#000000;">不需要进行强制类型转换，因为把变量</span>
<span style="color:#000000;">dividend</span>
<span style="color:#000000;">强制转换成</span>
<span style="color:#000000;">float</span>
<span style="color:#000000;">类型会迫使编 </span>
</div>
<div>
<span style="color:#000000;">译器把</span>
<span style="color:#000000;">divisor</span>
<span style="color:#000000;">也转换成</span>
<span style="color:#000000;">float</span>
<span style="color:#000000;">类型。</span>
</div>
<div>
<img alt="" height="389" src="image\7625cfbb535b407c92059503451e7f1c.png" width="1200"/>
</div>
<p><span style="color:#000000;">有些时候，<strong>需要使用强制类型转换来避免溢出</strong>。思考下面这个例子：</span> </p>
<p><img alt="" height="137" src="image\b0d8d1d5451b4667aedba054229ca1e6.png" width="1034"/></p>
<div>
<span style="color:#000000;">乍看之下，这条语句没有问题。表达式</span>
<span style="color:#000000;">j * j</span>
<span style="color:#000000;">的值是</span>
<span style="color:#000000;">1 000 000</span>
<span style="color:#000000;">，并且变量</span>
<span style="color:#000000;">i</span>
<span style="color:#000000;">是</span>
<span style="color:#000000;">long int</span>
<span style="color:#000000;">类型的，所 </span>
</div>
<div>
<span style="color:#000000;">以</span>
<span style="color:#000000;">i</span>
<span style="color:#000000;">应该能很容易地存储这种大小的值，不是吗？<strong>问题是，当两个</strong></span>
<strong><span style="color:#000000;">int</span><span style="color:#000000;">类型值相乘时，结果也应 </span></strong>
</div>
<div>
<strong><span style="color:#000000;">该是</span><span style="color:#000000;">int</span></strong>
<span style="color:#000000;"><strong>类型的</strong>，但是</span>
<span style="color:#000000;">j * j</span>
<span style="color:#000000;">的结果太大，以致在某些机器上无法表示成</span>
<span style="color:#000000;">int</span>
<span style="color:#000000;">型，从而导致溢出。 </span>
</div>
<div>
<span style="color:#000000;">幸运的是，可以使用强制类型转换避免这种问题的发生： </span>
</div>
<p><img alt="" height="44" src="image\e0e1b6f95e654d05a612605e18c831b6.png" width="685"/></p>
<div>
<span style="color:#000000;">因为强制运算符的优先级高于</span>
<span style="color:#000000;">*</span>
<span style="color:#000000;">，所以第一个变量</span>
<span style="color:#000000;">j</span>
<span style="color:#000000;">会被转换成</span>
<span style="color:#000000;">long int</span>
<span style="color:#000000;">类型，同时也迫使第 </span>
</div>
<div>
<span style="color:#000000;">二个</span>
<span style="color:#000000;">j</span>
<span style="color:#000000;">进行转换。注意，语句</span>
</div>
<p><img alt="" height="68" src="image\38321fd1f0b94eaa83efdae8f93d273b.png" width="746"/><span style="color:#000000;">是不对的，因为溢出在强制类型转换之前就已经发生了。</span></p>
</blockquote>
<h3 id="7.5.2%20%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89%E5%92%8C%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%80%A7%C2%A0%F0%9F%9A%80"><span style="color:#000000;">7.5.2 类型定义和可移植性 </span>🚀</h3>
<blockquote>
<div>
<span style="color:#956fe7;"><strong>C语言库自身使用typedef为那些可能依据C语言实现的不同而不同的类型创建类型名；这 </strong></span>
</div>
<div>
<span style="color:#956fe7;"><strong>些类型的名字经常以_t结尾</strong></span>
<span style="color:#000000;">，比如</span>
<span style="color:#000000;">ptrdiff_t</span>
<span style="color:#000000;">、</span>
<span style="color:#000000;">size_t</span>
<span style="color:#000000;">和</span>
<span style="color:#000000;">wchar_t</span>
<span style="color:#000000;">。这些类型的精确定义不尽 </span>
</div>
<div>
<span style="color:#000000;">相同，下面是一些常见的例子：</span>
</div>
<div>
<img alt="" height="105" src="image\73485256e2df4544be05cd1b23876b58.png" width="796"/>
</div>
<div>
<span style="color:#000000;">在</span>
<span style="color:#000000;">C99</span>
<span style="color:#000000;">中，</span>
<span style="color:#000000;">&lt;stdint.h&gt;</span>
<span style="color:#000000;">头使用</span>
<span style="color:#000000;">typedef</span>
<span style="color:#000000;">定义占用特定位数的整数类型名。例如，</span>
<span style="color:#000000;">int32_t </span>
</div>
<div>
<span style="color:#000000;">是恰好占用</span>
<span style="color:#000000;">32</span>
<span style="color:#000000;">位的有符号整型。这是一种有效的定义方式，<strong>能使程序更易于移植。</strong></span>
</div>
</blockquote>
<h2 id="7.6%20sizeof%20%E8%BF%90%E7%AE%97%E7%AC%A6%C2%A0%F0%9F%9A%80"><span style="color:#000000;">7.6 </span><span style="color:#000000;"><strong>sizeof </strong>运算符 </span>🚀</h2>
<blockquote>
<p><strong><span style="color:#000000;">sizeof</span></strong><span style="color:#000000;"><strong>运算符允许程序存储指定类型值所需空间的大小</strong>。表达式</span></p>
<p><img alt="" height="71" src="image\8101606688fd43239d0ae2d592d6bae5.png" width="812"/></p>
<div>
<strong><span style="color:#000000;">的值是一个无符号整数，代表存储属于</span><span style="color:#000000;">类型名</span></strong>
<span style="color:#000000;"><strong>的值所需要的字节数。</strong>表达式</span>
<span style="color:#000000;">sizeof(char)</span>
<span style="color:#000000;">的值 </span>
</div>
<div>
<span style="color:#000000;">始终为</span>
<span style="color:#000000;">1</span>
<span style="color:#000000;">，但是对其他类型计算出的值可能会有所不同。在</span>
<span style="color:#000000;">32</span>
<span style="color:#000000;">位的机器上，表达式</span>
<span style="color:#000000;">sizeof(int) </span>
</div>
<div>
<span style="color:#000000;">的值通常为</span>
<span style="color:#000000;">4</span>
<span style="color:#000000;">。<strong>注意，</strong></span>
<strong><span style="color:#000000;">sizeof</span><span style="color:#000000;">运算符是一种特殊的运算符，因为编译器本身通常就能够确 </span></strong>
</div>
<div>
<strong><span style="color:#000000;">定</span><span style="color:#000000;">sizeof</span><span style="color:#000000;">表达式的值。</span></strong>
</div>
<div>
<strong><span style="color:#000000;">通常情况下，</span><span style="color:#000000;">sizeof</span></strong>
<span style="color:#000000;"><strong>运算符也可以应用于常量、变量和表达式。</strong>如果</span>
<span style="color:#000000;">i</span>
<span style="color:#000000;">和</span>
<span style="color:#000000;">j</span>
<span style="color:#000000;">是整型变量，那么sizeof</span>
<span style="color:#000000;">(</span>
<span style="color:#000000;">i)</span>
<span style="color:#000000;">在</span>
<span style="color:#000000;">32</span>
<span style="color:#000000;">位机器上的值为</span>
<span style="color:#000000;">4</span>
<span style="color:#000000;">，这和表达式</span>
<span style="color:#000000;">sizeof(i+j)</span>
<span style="color:#000000;">的值一样。跟应用于类型时不同，<strong>sizeof应用于表达式时不要求圆括号，我们可以用</strong></span>
<strong><span style="color:#000000;">sizeof i</span><span style="color:#000000;">代替</span><span style="color:#000000;">sizeof(i)</span></strong>
<span style="color:#000000;"><strong>。但是</strong>，由于运算符优先级的问题，圆括号有时还是需要的。编译器会把表达式sizeof i + j</span>
<span style="color:#000000;">解释为</span>
<span style="color:#000000;">(</span>
<span style="color:#000000;">sizeof i)+ j，这是因为</span>
<span style="color:#000000;">sizeof</span>
<span style="color:#000000;">作为一元运算符的优先级高于二元运算符</span>
<span style="color:#000000;">+</span>
<span style="color:#000000;">。为了避免出现此类问题，本书在sizeof</span>
<span style="color:#000000;">表达式中始终加上圆括号。</span>
</div>
<div>
<strong><span style="color:#000000;">显示</span><span style="color:#000000;">sizeof</span><span style="color:#000000;">值时要注意，因为</span><span style="color:#000000;">sizeof</span><span style="color:#000000;">表达式的类型是</span><span style="color:#000000;">size_t</span><span style="color:#000000;">，这是一种由实现定义的类</span></strong>
<span style="color:#000000;"><strong>型。</strong>在</span>
<span style="color:#000000;">C89</span>
<span style="color:#000000;">中，最好在显示前把表达式的值转换成一种已知的类型。</span>
<strong><span style="color:#000000;">size_t</span></strong>
<span style="color:#000000;"><strong>一定是无符号整型</strong>，所以最安全的方法是把sizeof</span>
<span style="color:#000000;">表达式强制转换成</span>
<strong><span style="color:#000000;">unsigned long</span><span style="color:#000000;">类型（</span><span style="color:#fe2c24;">C89</span></strong>
<span style="color:#000000;"><strong>中最大的无符型）</strong>，然后使用转换说明符%lu</span>
<span style="color:#000000;">显示：</span>
</div>
<p><img alt="" height="61" src="image\6afda9e1747c4d659550bd6f4f277a34.png" width="890"/></p>
<div>
<span style="color:#000000;">在</span>
<span style="color:#fe2c24;">C99</span>
<span style="color:#000000;">中，</span>
<strong><span style="color:#000000;">size_t</span><span style="color:#000000;">类型可以比</span><span style="color:#000000;">unsigned long</span><span style="color:#000000;">更长。但</span><span style="color:#000000;">C99</span><span style="color:#000000;">中的</span><span style="color:#000000;">printf</span><span style="color:#000000;">可以直接显示出size_t</span><span style="color:#000000;">类型值而不需要强制转换。方法是在转换说明中的一般整数（通常用</span><span style="color:#000000;">u）代码前使用字母</span><span style="color:#000000;">z：</span></strong>
</div>
<div>
<img alt="" height="53" src="image\fd56dec561a8466bb9ccc535c7432fda.png" width="924"/>
</div>
</blockquote>
<h1 id="%E9%97%AE%E4%B8%8E%E7%AD%94%C2%A0%F0%9F%9A%80"><span style="color:#000000;">问与答 </span>🚀</h1>
<blockquote>
<div>
<span style="color:#000000;">问：</span>
<span style="color:#000000;">7.1</span>
<span style="color:#000000;">节说到</span>
<span style="color:#000000;"><strong>%o</strong></span>
<span style="color:#000000;">和</span>
<span style="color:#000000;"><strong>%x</strong></span>
<span style="color:#000000;">分别用于以八进制和十六进制书写无符号整数。那么如何以八进制和十六进制书写普通的（</span>
<span style="color:#000000;">有符号</span>
<span style="color:#000000;">）</span>
<span style="color:#000000;">整数呢？</span>
<span style="color:#000000;">（</span>
<span style="color:#000000;">p.92</span>
<span style="color:#000000;">）</span>
</div>
<div>
<span style="color:#000000;">答：<strong>只要有符号整数的值不是负值，就可以用</strong></span>
<strong><span style="color:#000000;">%o</span><span style="color:#000000;">和</span><span style="color:#000000;">%x</span></strong>
<span style="color:#000000;"><strong>显示。</strong>这些转换导致</span>
<span style="color:#000000;">printf</span>
<span style="color:#000000;">函数把有符号整数看成是无符号的；换句话说，printf</span>
<span style="color:#000000;">函数将假设符号位是数的绝对值部分。只要符号位为</span>
<span style="color:#000000;">0</span>
<span style="color:#000000;">，就没有问题。如果符号位为1</span>
<span style="color:#000000;">，那么</span>
<span style="color:#000000;">printf</span>
<span style="color:#000000;">函数将显示出一个超出预期的大数。</span>
</div>
</blockquote>
<blockquote>
<p><span style="color:#000000;">问：但是，如果数是负数该怎么办呢？如何以八进制或十六进制形式书写它？</span></p>
<div>
<span style="color:#000000;">答：<strong>没有直接的方法可以书写负数的八进制或十六进制形式。</strong>幸运的是，需要这样做的情况非常少。当然，我们可以判定这个数是否是负数，然后自己显示一个负号：</span>
</div>
<p><img alt="" height="128" src="image\7e791952eb6b4f3f8d99f775e211b8df.png" width="820"/></p>
</blockquote>
<blockquote>
<p><span style="color:#000000;">问：浮点常量为什么存储成</span><span style="color:#000000;"><strong>double</strong></span><span style="color:#000000;">格式而不是</span><span style="color:#000000;"><strong>float</strong></span><span style="color:#000000;">格式？</span><span style="color:#000000;">（</span><span style="color:#000000;">p.94</span><span style="color:#000000;">）</span></p>
<div>
<span style="color:#000000;">答：<strong>由于历史的原因，</strong></span>
<strong><span style="color:#000000;">C</span><span style="color:#000000;">语言更倾向于使用</span><span style="color:#000000;">double</span><span style="color:#000000;">类型，</span><span style="color:#000000;">float</span></strong>
<span style="color:#000000;"><strong>类型则被看成是“二等公民”。</strong>思考</span>
<span style="color:#000000;">Kernighan和Ritchie</span>
<span style="color:#000000;">的</span>
<span style="color:#000000;"><em>The C Programming Language</em></span>
<span style="color:#000000;">一书中关于</span>
<span style="color:#000000;">float</span>
<span style="color:#000000;">的论述：“使用</span>
<span style="color:#000000;">float</span>
<span style="color:#000000;">类型的主要原因是节省大型数组的存储空间，或者有时是为了节省时间，因为在一些机器上双精度计算的开销格外大。” <strong>经典C</strong></span>
<strong><span style="color:#000000;">要求所有浮点计算都采用双精度的格式。（</span><span style="color:#000000;">C89</span><span style="color:#000000;">和</span><span style="color:#000000;">C99</span><span style="color:#000000;">没有这样的要求。）</span></strong>
</div>
</blockquote>
<blockquote>
<p><span style="color:#000000;"><strong>*</strong></span><span style="color:#000000;">问：十六进制的浮点常量是什么样子？使用这种浮点常量有什么好处？</span><span style="color:#000000;">（</span><span style="color:#000000;">p.94</span><span style="color:#000000;">）</span></p>
<div>
<span style="color:#000000;">答：<strong>十六进制浮点常量以</strong></span>
<strong><span style="color:#000000;">0x</span><span style="color:#000000;">或</span><span style="color:#000000;">0X</span><span style="color:#000000;">开头，且必须包含指数（指数跟在字母</span><span style="color:#000000;">P</span><span style="color:#000000;">或</span><span style="color:#000000;">p</span><span style="color:#000000;">后面）。指数可以有符号，常量可以以f</span><span style="color:#000000;">、</span><span style="color:#000000;">F</span><span style="color:#000000;">、</span><span style="color:#000000;">l</span><span style="color:#000000;">或</span><span style="color:#000000;">L</span><span style="color:#000000;">结尾。指数以十进制数表示，但代表的是</span><span style="color:#000000;">2</span><span style="color:#000000;">的幂而不是</span><span style="color:#000000;">10</span></strong>
<span style="color:#000000;"><strong>的幂。</strong>例如，</span>
<span style="color:#000000;">0x1.Bp3表示1.6875×2</span>
<span style="color:#000000;">3 </span>
<span style="color:#000000;"> = 13.5</span>
<span style="color:#000000;">。十六进制位</span>
<span style="color:#000000;">B</span>
<span style="color:#000000;">对应的位模式为</span>
<span style="color:#000000;">1011</span>
<span style="color:#000000;">；由于</span>
<span style="color:#000000;">B</span>
<span style="color:#000000;">出现在小数点的右边，所以其每一位代表一个2</span>
<span style="color:#000000;">的负整数幂，把它们（2^-</span>
<span style="color:#000000;">1 </span>
<span style="color:#000000;"> + ^-</span>
<span style="color:#000000;">3 </span>
<span style="color:#000000;"> + 2^-</span>
<span style="color:#000000;">4 </span>
<span style="color:#000000;">）相加得到</span>
<span style="color:#000000;">0.6875</span>
<span style="color:#000000;">。</span>
</div>
<div>
<span style="color:#000000;">十六进制浮点常量主要用于指定精度要求较高的浮点常量（包括<em>e</em></span>
<span style="color:#000000;">和</span>
<span style="color:#000000;">π</span>
<span style="color:#000000;">等数学常量）。十进制数具有精确的二进制表示，而十进制常量在转换为二进制时则可能会受到舍入误差的些许影响。十六进制数对于定义极值（例如&lt;float.h&gt;</span>
<span style="color:#000000;">头中宏的值）常量也是很有用的，这些常量很容易用十六进制表示但难以用十进制表示。</span>
</div>
</blockquote>
<blockquote>
<p><span style="color:#000000;"><strong>*</strong></span><span style="color:#000000;">问：为什么使用</span><span style="color:#000000;"><strong>%lf</strong></span><span style="color:#000000;">读取</span><span style="color:#000000;"><strong>double</strong></span><span style="color:#000000;">类型的值，而用</span><span style="color:#000000;"><strong>%f</strong></span><span style="color:#000000;">进行显示呢？</span><span style="color:#000000;">（</span><span style="color:#000000;">p.94</span><span style="color:#000000;">）</span></p>
<div>
<span style="color:#000000;">答：这是一个十分难回答的问题。首先，注意，</span>
<strong><span style="color:#000000;">scanf</span><span style="color:#000000;">函数和</span><span style="color:#000000;">printf</span></strong>
<span style="color:#000000;"><strong>函数都是不同寻常的函数，因为它们都没有将函数的参数限制为固定数量。</strong>scanf</span>
<span style="color:#000000;">函数和</span>
<span style="color:#000000;">printf</span>
<span style="color:#000000;">函数有可变长度的参数列表（ </span>
<span style="color:#000000;">26.1节）。当调用带有可变长度参数列表的函数时，编译器会安排float</span>
<span style="color:#000000;">参数自动转换成为</span>
<span style="color:#000000;">double</span>
<span style="color:#000000;">类型，其结果是printf</span>
<span style="color:#000000;">函数无法区分</span>
<span style="color:#000000;">float</span>
<span style="color:#000000;">类型和</span>
<span style="color:#000000;">double</span>
<span style="color:#000000;">类型的参数。这解释了在</span>
<span style="color:#000000;">printf</span>
<span style="color:#000000;">函数调用中为何可以用%f</span>
<span style="color:#000000;">既表示</span>
<span style="color:#000000;">float</span>
<span style="color:#000000;">类型又表示</span>
<span style="color:#000000;">double</span>
<span style="color:#000000;">类型的参数。 </span>
</div>
<div>
<span style="color:#000000;">另一方面，</span>
<span style="color:#000000;">scanf</span>
<span style="color:#000000;">函数是通过</span>
<span style="color:#000000;">指针</span>
<span style="color:#000000;">指向变量的。</span>
<span style="color:#000000;">%f</span>
<span style="color:#000000;">告诉</span>
<span style="color:#000000;">scanf</span>
<span style="color:#000000;">函数在所传地址位置上存储一个 </span>
</div>
<div>
<span style="color:#000000;">float</span>
<span style="color:#000000;">类型值，而</span>
<span style="color:#000000;">%lf</span>
<span style="color:#000000;">告诉</span>
<span style="color:#000000;">scanf</span>
<span style="color:#000000;">函数在该地址上存储一个</span>
<span style="color:#000000;">double</span>
<span style="color:#000000;">类型值。<strong>这里</strong></span>
<strong><span style="color:#000000;">float</span><span style="color:#000000;">和</span><span style="color:#000000;">double </span></strong>
</div>
<div>
<span style="color:#000000;"><strong>的区别是非常重要的。</strong>如果给出了错误的转换说明，那么</span>
<span style="color:#000000;">scanf</span>
<span style="color:#000000;">函数将可能存储错误的字节数量（没有提到的是，float</span>
<span style="color:#000000;">类型的位模式可能不同于</span>
<span style="color:#000000;">double</span>
<span style="color:#000000;">类型的位模式）。</span>
</div>
</blockquote>
<blockquote>
<p><span style="color:#000000;">问：什么时候需要考虑字符变量是有符号的还是无符号的？</span><span style="color:#000000;">（</span><span style="color:#000000;">p.96</span><span style="color:#000000;">）</span></p>
<p><span style="color:#000000;">答：<strong>如果在变量中只存储</strong></span><strong><span style="color:#000000;">7</span><span style="color:#000000;">位的字符，那么不需要考虑，因为符号位将为零。但是，如果计划存储</span><span style="color:#000000;">8位字符，那么将希望变量是</span><span style="color:#000000;">unsigned char</span></strong><span style="color:#000000;"><strong>类型。</strong>思考下面的例子：</span></p>
<p><img alt="" height="47" src="image\d0c309170cce48bda9586c9cfe646cbc.png" width="747"/></p>
<div>
<span style="color:#000000;">如果已经把变量</span>
<span style="color:#000000;">ch</span>
<span style="color:#000000;">声明成</span>
<span style="color:#000000;">char</span>
<span style="color:#000000;">类型，那么编译器可能选择把它看作是有符号的字符来处理（许多编译器这么做）。只要变量ch</span>
<span style="color:#000000;">只是作为字符来使用，就不会有什么问题。</span>
</div>
<div>
<span style="color:#000000;">但是如果</span>
<span style="color:#000000;">ch</span>
<span style="color:#000000;">用在一些需要编译器将其值转换为整数的上下文中，那么可能就有问题了：转换为整数的结果将是负数，因为变量ch的符号位为</span>
<span style="color:#000000;">1</span>
<span style="color:#000000;">。</span>
</div>
<div>
<div>
<span style="color:#000000;">还有另外一种情况：在一些程序中，习惯使用</span>
<span style="color:#000000;">char</span>
<span style="color:#000000;">类型变量存储单字节的整数。如果编写了这类程序，就需要决定每个变量应该是signed char</span>
<span style="color:#000000;">类型的还是</span>
<span style="color:#000000;">unsigned char</span>
<span style="color:#000000;">类型的，这就像需要决定普通整型变量应该是int</span>
<span style="color:#000000;">类型还是</span>
<span style="color:#000000;">unsigned int</span>
<span style="color:#000000;">类型一样。</span>
</div>
</div>
</blockquote>
<blockquote>
<div>
<span style="color:#000000;">问：我无法理解换行</span>
<span style="color:#000000;">（</span>
<span style="color:#000000;">new-line</span>
<span style="color:#000000;">）</span>
<span style="color:#000000;">符怎么会是</span>
<span style="color:#000000;">ASCII</span>
<span style="color:#000000;">码的回行</span>
<span style="color:#000000;">（</span>
<span style="color:#000000;">line-feed</span>
<span style="color:#000000;">）</span>
<span style="color:#000000;">符。当用户录入输入内容并且按回车键时，程序不会把它作为回车符或者回车加回行符读取吗？（</span>
<span style="color:#000000;">p.97</span>
<span style="color:#000000;">）</span>
</div>
<div>
<div>
<span style="color:#000000;">答：<strong>不会的。作为</strong></span>
<strong><span style="color:#000000;">C</span><span style="color:#000000;">语言的</span><span style="color:#000000;">UNIX</span></strong>
<span style="color:#000000;"><strong>继承部分，行的结束位置标记一直被作为单独的回行符来看待。（在</strong></span>
<span style="color:#000000;"><strong>UNIX文本文件中，单独一个回行符（但不是回车符）会出现在每行的结束处。）C</strong></span>
<strong><span style="color:#000000;">语言函数库会把用户的按键翻译成回行符。当程序读文件时，输入/</span><span style="color:#000000;">输出函数库将文件的行结束标记（不管它是什么）翻译成单个的回行符。与之相对应的反向转换发生在将输出往屏幕或文件中写的时候。（详见22.1</span><span style="color:#000000;">节。）</span></strong>
</div>
<div>
<span style="color:#000000;">虽然这些翻译可能看上去很混乱，但是它们都为了一个重要的目的：<strong>使程序不受不同操作系统的影响。</strong></span>
</div>
</div>
</blockquote>
<blockquote>
<p><span style="color:#000000;"><strong>*</strong></span><span style="color:#000000;">问：使用转义序列</span><span style="color:#000000;"><strong>\?</strong></span><span style="color:#000000;">的目的是什么？</span><span style="color:#000000;">（</span><span style="color:#000000;">p.97</span><span style="color:#000000;">）</span></p>
<div>
<span style="color:#000000;">答：转义序列</span>
<span style="color:#000000;">\?</span>
<span style="color:#000000;">与三字符序列（ </span>
<span style="color:#000000;">25.3</span>
<span style="color:#000000;">节）有关，因为三字符序列以</span>
<span style="color:#000000;">??</span>
<span style="color:#000000;">开头。如果需要在字符串中加入</span>
<span style="color:#000000;">??</span>
<span style="color:#000000;">，那么编译器很可能会把它误当作三字符序列的开始。用\?</span>
<span style="color:#000000;">代替第二个？可以解决这个问题。</span>
</div>
</blockquote>
<blockquote>
<p><span style="color:#000000;">问：既然</span><span style="color:#000000;"><strong>getchar</strong></span><span style="color:#000000;">函数的读取速度更快，为什么仍然需要使用</span><span style="color:#000000;"><strong>scanf</strong></span><span style="color:#000000;">函数读取单个的字符呢？</span><span style="color:#000000;">（</span><span style="color:#000000;">p.98</span><span style="color:#000000;">）</span></p>
<div>
<span style="color:#000000;">答：虽然</span>
<span style="color:#000000;">scanf</span>
<span style="color:#000000;">函数没有</span>
<span style="color:#000000;">getchar</span>
<span style="color:#000000;">函数读取的速度快，<strong>但是它更灵活</strong>。<strong>正如前面已经看到的，格式串</strong></span>
<strong><span style="color:#000000;">"%c"可以使scanf</span><span style="color:#000000;">函数读入下一个输入字符；</span><span style="color:#000000;">" %c"</span><span style="color:#000000;">则可以使</span><span style="color:#000000;">scanf</span></strong>
<span style="color:#000000;"><strong>函数读入下一个非空白字符。而且，scanf函数也很擅长读取混合了其他数据类型的字符。</strong>假设输入数据中包含有一个整数、一个单独的非数值型字符和另一个整数。通过使用格式串"%d%c%d"</span>
<span style="color:#000000;">，就可以利用</span>
<span style="color:#000000;">scanf</span>
<span style="color:#000000;">函数读取全部三项内容。</span>
</div>
</blockquote>
<blockquote>
<p><span style="color:#000000;"><strong>*</strong></span><span style="color:#000000;">问：在什么情况下，整值提升会把字符或短整数转换成</span><span style="color:#000000;"><strong>unsigned int</strong></span><span style="color:#000000;">类型？</span><span style="color:#000000;">（</span><span style="color:#000000;">p.101</span><span style="color:#000000;">）</span></p>
<div>
<span style="color:#000000;">答：<strong>如果</strong></span>
<strong><span style="color:#000000;">int</span><span style="color:#000000;">类型整数没有大到足以包含所有可能的原始类型值，整值提升会产生</span><span style="color:#000000;">unsigned int</span></strong>
<span style="color:#000000;"><strong>类型。</strong>因为字符通常是8</span>
<span style="color:#000000;">位的长度，几乎总会转化为</span>
<span style="color:#000000;">int</span>
<span style="color:#000000;">类型（可以保证</span>
<span style="color:#000000;">int</span>
<span style="color:#000000;">类型至少为</span>
<span style="color:#000000;">16</span>
<span style="color:#000000;">位长度）。有符号短整数也总可以转换为int</span>
<span style="color:#000000;">类型，但无符号短整数却是有疑问的。如果短整数和普通整数的长度相同（例如在16</span>
<span style="color:#000000;">位机上），那么无符号短整数必须被转化为</span>
<span style="color:#000000;">unsigned int</span>
<span style="color:#000000;">类型，因为最大的无符号短整数（在16</span>
<span style="color:#000000;">位机上为</span>
<span style="color:#000000;">65 535</span>
<span style="color:#000000;">）要大于最大的</span>
<span style="color:#000000;">int</span>
<span style="color:#000000;">类型数（即</span>
<span style="color:#000000;">32 767</span>
<span style="color:#000000;">）。</span>
</div>
</blockquote>
<blockquote>
<p><span style="color:#000000;">问：如果把超出变量取值范围的值赋值给变量，究竟会发生什么？</span><span style="color:#000000;">（</span><span style="color:#000000;">p.102</span><span style="color:#000000;">）</span></p>
<div>
<span style="color:#000000;">答：粗略地讲，如果值是整值类型并且变量是无符号类型，那么会丢掉超出的位数；如果变量是有符号类型，那么结果是由实现定义的。把浮点数赋值给整型或浮点型变量的话，如果变量太小而无法承受，会产生未定义的</span>
<span style="color:#000000;">行为：任何事情都可能发生，包括程序终止。</span>
</div>
</blockquote>
<blockquote>
<div>
<span style="color:#000000;"><strong>*</strong></span>
<span style="color:#000000;">问：为什么</span>
<span style="color:#000000;">C</span>
<span style="color:#000000;">语言要提供类型定义呢？定义一个</span>
<span style="color:#000000;"><strong>BOOL</strong></span>
<span style="color:#000000;">宏不是和用</span>
<span style="color:#000000;"><strong>typedef</strong></span>
<span style="color:#000000;">定义一个</span>
<span style="color:#000000;"><strong>Bool</strong></span>
<span style="color:#000000;">类型一样好用吗？（</span>
<span style="color:#000000;">p.105</span>
<span style="color:#000000;">）</span>
</div>
<div>
<div>
<span style="color:#000000;">答：<strong>类型定义和宏定义存在两个重要的不同点。首先，类型定义比宏定义功能更强大。特别是，数组和指针类型是不能定义为宏的。</strong>假设我们试图使用宏来定义一个“指向整数的指针”类型：</span>
</div>
<div>
<img alt="" height="213" src="image\ffb53c6f08ba47f089c773909baec145.png" width="978"/>
</div>
<div></div>
<p><strong><span style="color:#000000;">可惜的是，只有</span><span style="color:#000000;">p</span><span style="color:#000000;">是指针，</span><span style="color:#000000;">q</span><span style="color:#000000;">和</span><span style="color:#000000;">r</span><span style="color:#000000;">都成了普通的整型变量。类型定义不会有这样的问题。</span></strong></p>
<div>
<span style="color:#000000;">其次，</span>
<strong><span style="color:#000000;">typedef</span><span style="color:#000000;">命名的对象具有和变量相同的作用域规则；定义在函数体内的</span><span style="color:#000000;">typedef</span><span style="color:#000000;">名字在函</span></strong>
<strong><span style="color:#000000;">数外是无法识别的。另一方面，宏的名字在预处理时会在任何出现的地方被替换掉。</span></strong>
</div>
</div>
</blockquote>
<blockquote>
<div>
<span style="color:#1a439c;">问：你提到“编译器本身通常就能够确定<strong>sizeof</strong>表达式的值”。难道编译器不总能确定<strong>sizeof</strong>表达式的值吗？（p.106）</span>
</div>
<div>
<div>
<span style="color:#000000;">答：在</span>
<span style="color:#000000;">C89</span>
<span style="color:#000000;">中编译器总是可以的，但在</span>
<span style="color:#000000;">C99</span>
<span style="color:#000000;">中有一个例外。编译器不能确定变长数组（ </span>
<span style="color:#000000;">8.3</span>
<span style="color:#000000;">节）的大小，因为数组中的元素个数在程序执行期间是可变的。</span>
</div>
</div>
</blockquote>
<blockquote>
<p><span style="color:#956fe7;">最后的最后，创作不易，希望读者三连支持💖</span></p>
<p><span style="color:#956fe7;">赠人玫瑰，手有余香💖</span></p>
</blockquote>
</div>
</div>