<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<p class="img-center"><img alt="ac8fa778091dd927be6c2c46f5507599.gif" src="https://img-blog.csdnimg.cn/img_convert/ac8fa778091dd927be6c2c46f5507599.gif"/></p>
<hr/>
<p><img alt="" height="48" src="https://img-blog.csdnimg.cn/img_convert/0a78b01e3c22de1dc1b7f5a96096b19a.gif" width="48"/>各位朋友们大家好呀！今天又又是游戏整活环节，先介绍一下这个版本的扫雷游戏完善的一些功能：</p>
<p><img alt="" src="https://img-blog.csdnimg.cn/img_convert/dc5ec4cc18d1816a904aad785e8b2117.gif"/>1、运气够好的话，首次选中的坐标3*3方格内如果没有安置地雷，将会为玩家展开一片空白区域【终于可以不用一个个手动排雷了】</p>
<p><img alt="" src="https://img-blog.csdnimg.cn/img_convert/dbc34fa2913321f1661c1b0543676e73.gif"/>2、添加了插旗/取消插旗功能，优化排雷过程；</p>
<p><img alt="" src="https://img-blog.csdnimg.cn/img_convert/4f09f67379212700c3ef558aaee4dec9.gif"/>3、新增了玩家首次获胜后再也不想玩第二次的功能</p>
<p id="u5cf24fdd">​<img alt="" src="https://img-blog.csdnimg.cn/img_convert/4f09f67379212700c3ef558aaee4dec9.gif"/>​4、拿着铲子的不一定是黄金矿工，还有可能是拆弹专家~</p>
<p id="u466943c8">核心思想：创建两个二维数组，show数组用于排雷的下棋界面，mine数组用于铺设地雷。</p>
<h1><img alt="" height="48" src="https://img-blog.csdnimg.cn/img_convert/0a78b01e3c22de1dc1b7f5a96096b19a.gif" width="48"/>​<span style="color:#956fe7;">1、game.h</span></h1>
<div>
<pre><code class="language-cpp">#pragma once
#define _CRT_SECURE_NO_WARNINGS 1
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;
#define ROW 9//用于展示的二维数组行的长度
#define COL 9//用于展示的二维数组列的长度
#define ROWS ROW+2//创建稍大的二维数组，防止判断时越界
#define COLS COL+2//创建稍大的二维数组，防止判断时越界
#define NUMS 10//雷的个数
void BoardInit(char arr[ROWS][COLS], int rows, int cols,char a);//初始化二维数组
void BoardPrint(char arr[ROWS][COLS], int row, int col);//打印二维数组
void GenerateMine(char mine[ROWS][COLS], int row, int col);//生成雷
void CheckMine(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col);//排查雷
void Flag(char show[ROWS][COLS], int x, int y);//插旗
void FlagCancel(char show[ROWS][COLS], int x, int y);//取消插旗
void Expand(char mine[ROWS][COLS], char show[ROWS][COLS], int x, int y);//展开
int Victory(char show[ROWS][COLS], int row, int col);//判断胜利</code></pre>
</div>
<blockquote>
<p>先看一下整体轮廓，从这几个头文件可以看出小游戏的功能和逻辑~</p>
</blockquote>
<h1 id="Xv9QY"><img alt="" height="48" src="https://img-blog.csdnimg.cn/img_convert/0a78b01e3c22de1dc1b7f5a96096b19a.gif" width="48"/>​<span style="color:#956fe7;">2、game.c</span></h1>
<h2 id="UyOMZ"><img alt="" src="https://img-blog.csdnimg.cn/img_convert/dc5ec4cc18d1816a904aad785e8b2117.gif"/>​<span style="color:#ed7976;">2.1初始化二维数组</span></h2>
<div>
<pre><code class="language-cpp">#include "game.h"
void BoardInit(char arr[ROWS][COLS], int rows, int cols,char a)//初始化二维数组
{
	for (int i = 0; i &lt; rows; i++)
	{
		for (int j = 0; j &lt; cols; j++)
		{
			arr[i][j] = a;
		}
	}
}</code></pre>
</div>
<blockquote>
<p> 由于创建了两个二维数组，需要将show棋盘初始化为'*'，mine棋盘初始化为'0',故在此函数中新增了第四个参数，用于保证两个数组初始化结果的不同。</p>
</blockquote>
<h2> <img alt="" src="https://img-blog.csdnimg.cn/img_convert/dc5ec4cc18d1816a904aad785e8b2117.gif"/><span style="color:#ed7976;">2.2打印二维数组</span></h2>
<pre><code class="language-cpp">void BoardPrint(char arr[ROWS][COLS], int row, int col)//打印二维数组
{
	for (int j = 0; j &lt;= col; j++)
		printf("%d ", j);
	printf("\n");
	for (int i = 1; i &lt;= row; i++)
	{
		printf("%d ", i);
		for (int j = 1; j &lt;= col; j++)
		{
			printf("%c ", arr[i][j]);
		}
		printf("\n");
	}
}</code></pre>
<blockquote>
<p> 打印二维数组，用for循环打印出行与列，方便排雷时输入坐标。如下图所示：</p>
</blockquote>
<p><img alt="" height="639" src="image\bbc172ebd94b4ef2a4d4a9d0daabdabb.png" width="1200"/></p>
<h2><img alt="" src="https://img-blog.csdnimg.cn/img_convert/dc5ec4cc18d1816a904aad785e8b2117.gif"/><span style="color:#ed7976;">2.3生成雷</span></h2>
<pre><code class="language-cpp">void GenerateMine(char mine[ROWS][COLS], int row, int col)//生成雷
{
	int i = NUMS;
	while(i)
	{
		int x = rand() % row + 1;
		int y = rand() % col + 1;
		if (mine[x][y] != '1')
		{
			mine[x][y] = '1';//字符1是雷
			i--;
		}
	}
}</code></pre>
<blockquote>
<p> 使用rand函数随机生成雷的坐标，将雷埋入mine数组。注意记得在main函数使用srand函数。</p>
</blockquote>
<h2 id="ojJJ0"><img alt="" src="https://img-blog.csdnimg.cn/img_convert/dc5ec4cc18d1816a904aad785e8b2117.gif"/><span style="color:#ed7976;">2.4插旗&amp;取消插旗</span></h2>
<pre><code class="language-cpp">void Flag(char show[ROWS][COLS], int x,int y)//插旗
{
	if (show[x][y] == '*')
	{
		show[x][y] = 'F';
	}
	else
		printf("非法插旗！\n");    
}
void FlagCancel(char show[ROWS][COLS], int x, int y)//取消插旗
{
	if (show[x][y] == 'F')
	{
		show[x][y] = '*';
	}
	else
		printf("非法取消插旗！\n");
}</code></pre>
<blockquote>
<p> 用'F'替代'*',注意需要检查坐标是否已经被排查。</p>
</blockquote>
<h2><img alt="" src="https://img-blog.csdnimg.cn/img_convert/dc5ec4cc18d1816a904aad785e8b2117.gif"/><span style="color:#ed7976;">2.5显示输入坐标3*3范围雷的个数</span></h2>
<pre><code class="language-cpp">void MineHint(char mine[ROWS][COLS], char show[ROWS][COLS], int x, int y)//显示周边几个雷
{
	int sum=mine[x - 1][y - 1] + mine[x - 1][y] + mine[x - 1][y + 1]
		+ mine[x][y - 1] + mine[x][y + 1] + mine[x + 1][y + 1]
		+ mine[x + 1][y] + mine[x + 1][y - 1] - 8 * '0';
	show[x][y] = '0' + sum;
}</code></pre>
<blockquote>
<p id="u58ae513c">解析：统计mine周边3*3范围内字符的和，减去8个字符0，差值即为3*3范围内地雷的个数sum，将其坐标置为'0' + sum。</p>
</blockquote>
<h2><img alt="" src="https://img-blog.csdnimg.cn/img_convert/dc5ec4cc18d1816a904aad785e8b2117.gif"/><span style="color:#ed7976;">2.6展开功能（递归）</span></h2>
<pre><code class="language-cpp">void Expand(char mine[ROWS][COLS], char show[ROWS][COLS], int x, int y)//展开
{
	if (mine[x - 1][y - 1] + mine[x - 1][y] + mine[x - 1][y + 1]
		+ mine[x][y - 1] + mine[x][y + 1] + mine[x + 1][y + 1]
		+ mine[x + 1][y] + mine[x + 1][y - 1] - 8 * '0'== 0)
	{
		show[x][y] = ' ';
		if (show[x - 1][y - 1] == '*')
			Expand(mine, show, x - 1, y - 1);
		if (show[x - 1][y] == '*')
			Expand(mine, show, x - 1, y);
		if (show[x - 1][y + 1] == '*')
			Expand(mine, show, x - 1,y+1); 
		if (show[x][y - 1] == '*')
			Expand(mine, show, x, y - 1);
		if (show[x][y + 1] == '*')
			Expand(mine, show, x, y + 1);
		if (show[x + 1][y + 1] == '*')
			Expand(mine, show, x + 1, y + 1);
		if (show[x + 1][y] == '*')
			Expand(mine, show, x + 1, y);
		if (show[x + 1][y - 1] == '*')
			Expand(mine, show, x + 1, y + 1);
	}
	else
		MineHint(mine, show, x, y);
}</code></pre>
<blockquote>
<p id="u6bab25c4">解析：如果输入坐标3*3范围内另8个点坐标和减去8*'0'等于0，说明周边没有雷，将其坐标置为空，并对其周边8个点进行判断递归，若点未判断过（'*'），则进行递归，若已判断，将显示该点周围地雷个数。如下图所示：</p>
</blockquote>
<p class="img-center"><img alt="" src="image\021f7e5bddb7986f907b12594e350abe.png"/></p>
<h2><img alt="" src="https://img-blog.csdnimg.cn/img_convert/dc5ec4cc18d1816a904aad785e8b2117.gif"/><span style="color:#ed7976;">2.7判断胜利</span></h2>
<pre><code class="language-cpp">int Victory(char show[ROWS][COLS], int row, int col)//判断胜利
{
	int count = 0;//统计剩余*的数量
	for (int i = 1; i &lt;= row; i++)
	{
		for (int j = 1; j &lt;= col; j++)
		{
			if (show[i][j] == '*'|| show[i][j] == 'F')
				count++;
		}
	}
	if (count == NUMS)
	{
		printf("恭喜获胜！\n");
		return 1;
	}
	else
		return 0;
}</code></pre>
<blockquote>
<p id="u4f32aa0b">遍历show数组，统计'*'与'F'的个数，若count和地雷书数NUMS相等，则认为游戏胜利！</p>
</blockquote>
<h2 id="dYvxa"><span style="color:#6eaad7;"><img alt="" src="https://img-blog.csdnimg.cn/img_convert/dc5ec4cc18d1816a904aad785e8b2117.gif"/></span><span style="color:#ed7976;">2.8排查雷</span></h2>
<pre><code class="language-cpp">void GameMenu()
{
	printf("#######1、排雷########\n");
	printf("#######2、插旗########\n");
	printf("#######3、取消插旗####\n");
	printf("请选择：");
}
void CheckMine(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col)//排查雷
{
	int x = 0;
	int y = 0;
	while (1)
	{
		GameMenu();
		int input = 0;
		scanf("%d", &amp;input);
		if (input != 1 &amp;&amp; input != 2 &amp;&amp; input != 3)
		{
			continue;
		}
		printf("请输入坐标：");
		scanf("%d%d", &amp;x, &amp;y);
		if (input == 1)
		{
			if (x &gt; 0 &amp;&amp; x &lt;= row &amp;&amp; y &gt; 0 &amp;&amp; y &lt;= col)
			{
				if (show[x][y] == '*' &amp;&amp; mine[x][y] != '1')
				{
					Expand(mine, show, x, y);//展开
					BoardPrint(show, row, col);//打印二维数组
					if (Victory(show, row, col) == 1)//判断胜利
					{
						break;
					}
				}
				else if (mine[x][y] == '1')
				{
					printf("被雷炸死了！\n");
					break;
				}
				else
					printf("坐标非法！请重新输入！\n");
			}
			else
				printf("坐标非法！请重新输入！\n");
		}
		else if (input == 2)
		{
			Flag(show, x, y);
			BoardPrint(show, row, col);//打印二维数组
		}
		else if (input == 3)
		{
			FlagCancel(show, x, y);
			BoardPrint(show, row, col);//打印二维数组
		}
		else
			printf("输入错误！请重新选择：\n");
	}
	BoardPrint(mine, row, col);//打印二维数组
}</code></pre>
<blockquote>
<p id="u6a179e5d">每次排雷前会让玩家选择排雷/插旗/取消插旗，如果输入的不是规定数字，会被continue直接重置回循环的起点。排查雷接口基本上是上述接口的调用和循环及判断语句的应用。细心梳理逻辑，勤加调试，问题不大。</p>
</blockquote>
<h1><img alt="" height="48" src="https://img-blog.csdnimg.cn/img_convert/0a78b01e3c22de1dc1b7f5a96096b19a.gif" width="48"/><span style="color:#956fe7;"><strong>3、text.c</strong></span></h1>
<pre><code class="language-cpp">#include "game.h"
void menu()
{
	printf("#######################\n");
	printf("########1、play########\n");
	printf("########2、exit########\n");
	printf("#######################\n");
}
void game()
{
	char show[ROWS][COLS] = { 0 };
	char mine[ROWS][COLS] = { 0 };
	BoardInit(show, ROWS, COLS, '*');//初始化二维数组
	BoardInit(mine, ROWS, COLS, '0');//初始化二维数组
	GenerateMine(mine, ROW, COL);//生成雷
	BoardPrint(show, ROW, COL);//打印二维数组
	CheckMine(mine, show, ROW, COL);//排查雷
}
int main()
{
	int input = 0;
	srand((unsigned)time(NULL));
	do
	{
		menu();
		printf("请选择：");
		scanf("%d", &amp;input);
		if (input == 1)
			game();
		else if (input == 2)
		{
			printf("游戏已退出！\n");
			break;
		}
		else
			printf("输入错误！请重新输入！\n");
	} while (1);
	return 0;
}</code></pre>
<h1><img alt="" height="48" src="https://img-blog.csdnimg.cn/img_convert/0a78b01e3c22de1dc1b7f5a96096b19a.gif" width="48"/><span style="color:#956fe7;">4、运行截图</span></h1>
<p><img alt="" height="639" src="image\c7845e8118a9420c8416104408310c8e.png" width="1200"/></p>
<blockquote>
<p></p>
<p id="u5bcbff15">有插旗功能玩着还是挺舒服的，不会忘记雷区，插错旗也可以取消。当旗帜和*的数量等于设定的雷的数量时，游戏获胜！</p>
<p id="u5a8a23cd">游戏挺好玩的（</p>
</blockquote>
<hr/>
<p></p>
<p id="u78a42b14"><span style="color:#fe2c24;">关注！点赞！评论！收藏！关注！点赞！评论！收藏！关注！点赞！评论！收藏！关注！点赞！评论！收藏！关注！点赞！评论！收藏！</span></p>
<p class="img-center"><img alt="" src="https://img-blog.csdnimg.cn/img_convert/b065b7d3f1fa2e866c6eb22426979693.gif"/></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
</div>
</div>