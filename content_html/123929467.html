<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<p id="main-toc"><strong>目录</strong></p>
<p id="1.%20C%2B%2B%E5%85%B3%E9%94%AE%E5%AD%97(C%2B%2B98)-toc" style="margin-left:0px;"><a href="#1.%20C%2B%2B%E5%85%B3%E9%94%AE%E5%AD%97%28C%2B%2B98%29">1. C++关键字(C++98)</a></p>
<p id="%C2%A02.%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4-toc" style="margin-left:0px;"><a href="#%C2%A02.%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"> 2.命名空间</a></p>
<p id="2.1%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%A7%84%E5%88%99-toc" style="margin-left:40px;"><a href="#2.1%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%A7%84%E5%88%99">2.1作用域规则</a></p>
<p id="2.2%C2%A0%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%AE%9A%E4%B9%89-toc" style="margin-left:40px;"><a href="#2.2%C2%A0%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%AE%9A%E4%B9%89">2.2 命名空间定义</a></p>
<p id="2.3%C2%A0%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px;"><a href="#2.3%C2%A0%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E4%BD%BF%E7%94%A8">2.3 命名空间使用</a></p>
<p id="2.3.1%20%E5%8A%A0%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%99%90%E5%AE%9A%E7%AC%A6%20%3A%3A-toc" style="margin-left:80px;"><a href="#2.3.1%20%E5%8A%A0%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%99%90%E5%AE%9A%E7%AC%A6%20%3A%3A">2.3.1 加作用域限定符 ::</a></p>
<p id="%C2%A02.3.2%20%E4%BD%BF%E7%94%A8using%E5%85%B3%E9%94%AE%E5%AD%97%E5%B0%86%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%BC%95%E5%85%A5-toc" style="margin-left:80px;"><a href="#%C2%A02.3.2%20%E4%BD%BF%E7%94%A8using%E5%85%B3%E9%94%AE%E5%AD%97%E5%B0%86%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%BC%95%E5%85%A5"> 2.3.2 使用using关键字将命名空间引入</a></p>
<p id="%C2%A02.3.3%20%E4%BD%BF%E7%94%A8using%20namespace%20%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%90%8D%E7%A7%B0%E5%BC%95%E5%85%A5-toc" style="margin-left:80px;"><a href="#%C2%A02.3.3%20%E4%BD%BF%E7%94%A8using%20namespace%20%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%90%8D%E7%A7%B0%E5%BC%95%E5%85%A5"> 2.3.3 使用using namespace 命名空间名称引入</a></p>
<p id="%C2%A03.C%2B%2B%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA-toc" style="margin-left:0px;"><a href="#%C2%A03.C%2B%2B%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA"> 3.C++输入和输出</a></p>
<p id="4.%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0-toc" style="margin-left:0px;"><a href="#4.%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0">4.缺省参数</a></p>
<p id="4.1C%E5%92%8CC%2B%2B%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:40px;"><a href="#4.1C%E5%92%8CC%2B%2B%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB">4.1C和C++函数的区别</a></p>
<p id="%C2%A04.1%20%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#%C2%A04.1%20%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0%E6%A6%82%E5%BF%B5"> 4.1 缺省参数概念</a></p>
<p id="4.2%C2%A0%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#4.2%C2%A0%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0%E6%A6%82%E5%BF%B5">4.2 缺省参数概念</a></p>
<p id="4.3%C2%A0%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0%E5%88%86%E7%B1%BB-toc" style="margin-left:40px;"><a href="#4.3%C2%A0%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0%E5%88%86%E7%B1%BB">4.3 缺省参数分类</a></p>
<p id="4.3.1%E5%85%A8%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0-toc" style="margin-left:80px;"><a href="#4.3.1%E5%85%A8%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0">4.3.1全缺省参数</a></p>
<p id="4.3.2%E5%8D%8A%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0-toc" style="margin-left:80px;"><a href="#4.3.2%E5%8D%8A%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0">4.3.2半缺省参数</a></p>
<p id="4.3.4%20%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A-toc" style="margin-left:80px;"><a href="#4.3.4%20%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A">4.3.4 函数调用约定</a></p>
<p id="5.%C2%A0%20%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD-toc" style="margin-left:0px;"><a href="#5.%C2%A0%20%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD">5.  函数重载</a></p>
<p id="5.1%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#5.1%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E6%A6%82%E5%BF%B5">5.1函数重载概念</a></p>
<p id="5.2%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E7%9A%84%E5%8E%9F%E7%90%86-toc" style="margin-left:40px;"><a href="#5.2%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E7%9A%84%E5%8E%9F%E7%90%86">5.2函数重载的原理</a></p>
<p id="5.3%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-toc" style="margin-left:40px;"><a href="#5.3%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">5.3函数重载的底层实现原理</a></p>
<p id="5.3.2%20C%2FC%2B%2B%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F-toc" style="margin-left:80px;"><a href="#5.3.2%20C%2FC%2B%2B%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F">5.3.2 C/C++编译器的处理方式</a></p>
<p id="5.3.3%20%E5%90%8D%E5%AD%97%E4%BF%AE%E9%A5%B0-toc" style="margin-left:80px;"><a href="#5.3.3%20%E5%90%8D%E5%AD%97%E4%BF%AE%E9%A5%B0">5.3.3 名字修饰</a></p>
<p id="5.4%20extern%20%E2%80%9C%20C%20%E2%80%9D-toc" style="margin-left:40px;"><a href="#5.4%20extern%20%E2%80%9C%20C%20%E2%80%9D">5.4 extern “ C ”</a></p>
<p id="6.%20%E5%BC%95%E7%94%A8-toc" style="margin-left:0px;"><a href="#6.%20%E5%BC%95%E7%94%A8">6. 引用</a></p>
<p id="6.1%E5%BC%95%E7%94%A8%E7%9A%84%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#6.1%E5%BC%95%E7%94%A8%E7%9A%84%E6%A6%82%E5%BF%B5">6.1引用的概念</a></p>
<p id="6.2%E5%BC%95%E7%94%A8%E7%9A%84%E8%AF%AD%E6%B3%95-toc" style="margin-left:40px;"><a href="#6.2%E5%BC%95%E7%94%A8%E7%9A%84%E8%AF%AD%E6%B3%95">6.2引用的语法</a></p>
<p id="6.3%E5%BC%95%E7%94%A8%E7%9A%84%E7%89%B9%E6%80%A7-toc" style="margin-left:40px;"><a href="#6.3%E5%BC%95%E7%94%A8%E7%9A%84%E7%89%B9%E6%80%A7">6.3引用的特性</a></p>
<p id="6.4%20%E5%B8%B8%E5%BC%95%E7%94%A8-toc" style="margin-left:40px;"><a href="#6.4%20%E5%B8%B8%E5%BC%95%E7%94%A8">6.4 常引用</a></p>
<p id="6.5%E5%BC%95%E7%94%A8%E7%9A%84%E5%BA%94%E7%94%A8-toc" style="margin-left:40px;"><a href="#6.5%E5%BC%95%E7%94%A8%E7%9A%84%E5%BA%94%E7%94%A8">6.5引用的应用</a></p>
<p id="6.5.1%E7%AE%80%E5%8C%96%E4%BB%A3%E7%A0%81%E5%A2%9E%E5%8A%A0%E5%8F%AF%E8%AF%BB%E6%80%A7-toc" style="margin-left:80px;"><a href="#6.5.1%E7%AE%80%E5%8C%96%E4%BB%A3%E7%A0%81%E5%A2%9E%E5%8A%A0%E5%8F%AF%E8%AF%BB%E6%80%A7">6.5.1简化代码增加可读性</a></p>
<p id="6.5.2%E5%A2%9E%E5%8A%A0%E4%BB%A3%E7%A0%81%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7-toc" style="margin-left:80px;"><a href="#6.5.2%E5%A2%9E%E5%8A%A0%E4%BB%A3%E7%A0%81%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7">6.5.2增加代码的安全性</a></p>
<p id="6.5.3%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B-toc" style="margin-left:80px;"><a href="#6.5.3%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B">6.5.3作为函数的返回值类型</a></p>
<p id="6.6%20%E5%BC%95%E7%94%A8%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:40px;"><a href="#6.6%20%E5%BC%95%E7%94%A8%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB">6.6 引用和指针的区别</a></p>
<p id="6.6.1%20%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8C%BA%E5%88%AB-toc" style="margin-left:80px;"><a href="#6.6.1%20%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8C%BA%E5%88%AB">6.6.1 底层实现区别</a></p>
<p id="6.6.2%20%E4%BD%BF%E7%94%A8%E5%8C%BA%E5%88%AB-toc" style="margin-left:80px;"><a href="#6.6.2%20%E4%BD%BF%E7%94%A8%E5%8C%BA%E5%88%AB">6.6.2 使用区别</a></p>
<p id="7.%20%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0-toc" style="margin-left:0px;"><a href="#7.%20%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0">7. 内联函数</a></p>
<p id="7.1%20%23define%20%E5%AE%8F-toc" style="margin-left:40px;"><a href="#7.1%20%23define%20%E5%AE%8F">7.1 #define 宏</a></p>
<p id="7.1.1%C2%A0%20%E5%AE%8F%E5%B8%B8%E9%87%8F-toc" style="margin-left:80px;"><a href="#7.1.1%C2%A0%20%E5%AE%8F%E5%B8%B8%E9%87%8F">7.1.1  宏常量</a></p>
<p id="7.1.2%20%E5%AE%9A%E4%B9%89%E5%AE%8F-toc" style="margin-left:80px;"><a href="#7.1.2%20%E5%AE%9A%E4%B9%89%E5%AE%8F">7.1.2 定义宏</a></p>
<p id="7.1.3%20%E5%AE%8F%E7%9A%84%E6%9B%BF%E6%8D%A2%E8%A7%84%E5%88%99-toc" style="margin-left:80px;"><a href="#7.1.3%20%E5%AE%8F%E7%9A%84%E6%9B%BF%E6%8D%A2%E8%A7%84%E5%88%99">7.1.3 宏的替换规则</a></p>
<p id="7.1.4%20%E5%AE%8F%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9-toc" style="margin-left:80px;"><a href="#7.1.4%20%E5%AE%8F%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9">7.1.4 宏的优缺点</a></p>
<p id="7.2%20%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#7.2%20%E6%A6%82%E5%BF%B5">7.2 概念</a></p>
<p id="%C2%A07.3%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-toc" style="margin-left:40px;"><a href="#%C2%A07.3%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"> 7.3注意事项</a></p>
<hr id="hr-toc"/>
<p></p>
<h1 id="1.%20C%2B%2B%E5%85%B3%E9%94%AE%E5%AD%97(C%2B%2B98)">1. C++关键字(C++98)</h1>
<p>C++总计63个关键字，C语言32个关键字</p>
<p>以下是C++98里面的关键字</p>
<table><tbody><tr><td>asm</td><td>do</td><td>if</td><td>return</td><td>try</td><td>continue</td></tr><tr><td>auto</td><td>double</td><td>inline</td><td>short</td><td>typedef</td><td>for</td></tr><tr><td>bool</td><td>dynamic_cast</td><td>int</td><td>signed</td><td>typeid</td><td>public</td></tr><tr><td>break</td><td>else</td><td>long</td><td>sizeof</td><td>typename</td><td>throw</td></tr><tr><td>case</td><td>enum</td><td>mutable</td><td>static</td><td>union</td><td>wchar_t</td></tr><tr><td>catch</td><td>explicit</td><td>namespace</td><td>static_cast</td><td>unsigned</td><td>default</td></tr><tr><td>char</td><td>export</td><td>new</td><td>struct</td><td>using</td><td>friend</td></tr><tr><td>class</td><td>extern</td><td>operator</td><td>switch</td><td>virtual</td><td>register</td></tr><tr><td>const</td><td>false</td><td>private</td><td>template</td><td>void</td><td>true</td></tr><tr><td>const_cast</td><td>float</td><td>protected</td><td>this</td><td>volatile</td><td>while</td></tr><tr><td>delete</td><td>goto</td><td>reinterpret_cast</td></tr></tbody></table>
<h1 id="%C2%A02.%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"> 2.命名空间</h1>
<h2 id="2.1%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%A7%84%E5%88%99">2.1作用域规则</h2>
<p>在C语言中我们知道他的程序中名字的作用域分为两种是 <strong>局部作用域</strong> 和 <strong>全局作用域。</strong></p>
<p><strong>1.局部变量</strong>：如果一个变量被定义在函数中，那么这个变量的作用域就是一个局部作用域，在函数体外面不能访问这个变量，在别的函数定义同名变量，编译器会给他分配新的内存，他们互补干扰，你在你的地盘，我在我的地盘。</p>
<p><strong>2.静态局部变量</strong>：想要延长他的生命周期我们可以在前面加一个static关键字把他变成静态局部变量，但是他的作用跟局部变量一样，即只能在定义该变量的函数内使用该变量，只是程序仅分配一次内存，函数返回后，该变量不会消失，该变量还存在只是不能使用他。但是他的生命周期延长到了整个工程。</p>
<p style="text-align:center;"><img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/0614cf56024146e1982278b12e483cbd.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<p><strong> 3.全局变量：</strong>在函数体外定义的变量，且存放在静态存储区中，在定义变量的位置到本源文件结束后都有效，在这个作用域中全局变量，可以为程序内各个函数引用，因此如果在一个函数中改变了全局变量的值， 就能影响到其他函数中全局变量的值。</p>
<p><strong>4.静态全局变量：</strong>和全局变量一样，不过加了static之后会限制他们的作用域，使他们只能在定义他们的文件内使用，加了static可以将名字限制在一个文件中，防止名字污染。</p>
<p>滥用全局变量可能还是造成会造成名字污染，我加static也不行。</p>
<p style="text-align:center;"><img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_17,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/697c06929c5245ef96625546e16efb7d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_17,color_FFFFFF,t_70,g_se,x_16"/></p>
<p>我们在之前说了C语言从你的文本文件变成可执行文件过程中，会经过预处理，编译，汇编，链接的过程。而在预处理里面会有 头文件的展开，宏替换  ，取消注释  ，条件编译。而qsort是C里面的一个快排函数，我预处理头文件展开了，恰巧有个函数声明，这个函数就叫qsort，即使你加了static关键字修饰，但是还是在本文件内使用，还是会有重定义的问题。</p>
<p>C语言这时只能去改这个变量的名称了，万一工程很大呢？这时为了解决命名冲突，C++里面就有了命名空间。</p>
<h2 id="2.2%C2%A0%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%AE%9A%E4%B9%89">2.2 命名空间定义</h2>
<p>定义命名空间，需要使用到namespace关键字，后面跟命名空间的名字，然后接一对{}即可，{}中即为命名空间的成员。<br/> 1.普通的命名空间</p>
<pre><code class="language-cpp">namespace A {
	int a = 10;
	// 命名空间中的内容，既可以定义变量，也可以定义函数
	int add(int a, int b) {
		return a + b;
	}
}
</code></pre>
<p>2. 命名空间可以嵌套</p>
<pre><code class="language-cpp">namespace B {
	int b = 20;
	int add(int a, int b) {
		return a + b;
	}
	namespace C {
		int c = 30;
		int add(int a, int b) {
			return a + b;
		}
	}
}</code></pre>
<p>3. 同一个工程中允许存在多个相同名称的命名空间,编译器最后会合成同一个命名空间中<br/>  </p>
<pre><code class="language-cpp">namespace A {
	int aa = 10;
	int sub(int a, int b) {
		return a - b;
	}
}
namespace A {
	int a = 10;
	int add(int a, int b) {
		return a + b;
	}
}</code></pre>
<p>一个命名空间就定义了一个新的作用域，命名空间中的所有内容都局限于该命名空间中。</p>
<h2 id="2.3%C2%A0%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E4%BD%BF%E7%94%A8">2.3 命名空间使用</h2>
<p>举个例子这个函数打印的是那个a呢？</p>
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
namespace A {
	int a = 10;
	// 命名空间中的内容，既可以定义变量，也可以定义函数
	int add(int a, int b) {
		return a + b;
	}
}

int main() {
	int a = 1000;
	printf("%d", a);
	return 0;
}</code></pre>
<p style="text-align:center;"><img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/87bcea480f554fc8a56c77c74f05b360.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<p>肯定是1000啦，那我怎么访问A这个命名空间里的a呢？ </p>
<p>命名空间的使用有三种方式：</p>
<h3 id="2.3.1%20%E5%8A%A0%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%99%90%E5%AE%9A%E7%AC%A6%20%3A%3A"><strong>2.3.1 加作用域限定符 ::</strong></h3>
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
namespace A {
	int a = 10;
	// 命名空间中的内容，既可以定义变量，也可以定义函数
	int add(int a, int b) {
		return a + b;
	}
}

int main() {
	int a = 1000;
	printf("%d", A::a);
	return 0;
}</code></pre>
<p style="text-align:center;"><img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_18,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/14456e99ec3f446d818475070001c670.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_18,color_FFFFFF,t_70,g_se,x_16"/></p>
<h3 id="%C2%A02.3.2%20%E4%BD%BF%E7%94%A8using%E5%85%B3%E9%94%AE%E5%AD%97%E5%B0%86%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%BC%95%E5%85%A5"><strong> 2.3.2 使用using关键字将命名空间引入</strong></h3>
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
namespace A {
	int a = 10;
	// 命名空间中的内容，既可以定义变量，也可以定义函数
	int add(int a, int b) {
		return a + b;
	}
}
using A::add;
int main() {
	int a = 10;
	int b = 20;
	printf("%d", add(a, b));
	return 0;
}</code></pre>
<p style="text-align:center;"><img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_19,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/f648bbd256ba48f996fdb291bd9191b4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_19,color_FFFFFF,t_70,g_se,x_16"/></p>
<h3 id="%C2%A02.3.3%20%E4%BD%BF%E7%94%A8using%20namespace%20%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%90%8D%E7%A7%B0%E5%BC%95%E5%85%A5"><strong> 2.3.3 使用using namespace 命名空间名称引入</strong></h3>
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
namespace A {
	int c = 10;
	// 命名空间中的内容，既可以定义变量，也可以定义函数
	int add(int a, int b) {
		return a + b;
	}
}
using namespace A;
int main() {
	int a = 10;
	int b = 20;
	printf("%d\n",c);
	printf("%d\n", add(a, b));
	return 0;</code></pre>
<p style="text-align:center;"><img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_16,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/73651b97ffb34ed1bf52c99fe6f14b8b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_16,color_FFFFFF,t_70,g_se,x_16"/></p>
<h1 id="%C2%A03.C%2B%2B%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA"> 3.C++输入和输出</h1>
<p>不知道你是否和我一样在刚刚开始接触C语言的时候写过以下的代码</p>
<p style="text-align:center;"><img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_12,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/fd0ea300c8ef4e40a4e4ed2b9ed0d3a9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_12,color_FFFFFF,t_70,g_se,x_16"/></p>
<p> 这个问题确实现在看起来让人啼笑皆非，但是刚刚开始学习的时候确实让我很费解，看半天也不知道错误在哪里。但是在C++里面输入和输出是不需要格式控制符的，输入也不需要取地址符了。</p>
<p>在C++中使用标准输入输出必须包含 &lt;iostream&gt; 头文件 和 std 命名空间</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
int main() {
	int a = 0;
	std::cin &gt;&gt; a;
	std::cout &lt;&lt; a &lt;&lt; std::endl;
}</code></pre>
<p>不过我们一般不这样用会用using关键字来使用这个命名空间。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
int main() {
	//int a = 0;
	//std::cin &gt;&gt; a;
	//std::cout &lt;&lt; a &lt;&lt; std::endl;

	int a, b, c;
	double d;
	//可以连着输入
	cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
	//可以连着输入不同类型的
	cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;

	cout &lt;&lt; a &lt;&lt; endl;
	//还可以连着输出不同类型的
	cout &lt;&lt; "hello world!" &lt;&lt; 100 &lt;&lt; 3.14 &lt;&lt; endl;
}</code></pre>
<h1 id="4.%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0">4.缺省参数</h1>
<h2 id="4.1C%E5%92%8CC%2B%2B%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB">4.1C和C++函数的区别</h2>
<p>举个例子，这个代码会报错吗？</p>
<p> <img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_15,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/8d1bd3ac22604e05a7e7c0bc62dbf901.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_15,color_FFFFFF,t_70,g_se,x_16"/></p>
<p> 答案是不会的，但是C++的编译器比C语言编译器更严格，就会报错。</p>
<p> <img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_16,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/94c8412c2877449bab4ebfdeb6703382.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_16,color_FFFFFF,t_70,g_se,x_16"/></p>
<p><img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_15,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/0e8f240a8af5480c8dd7876231e80c62.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_15,color_FFFFFF,t_70,g_se,x_16"/></p>
<p> 在看这个例子</p>
<p><img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_16,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/ef909f0610d0459394f89a498b082292.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_16,color_FFFFFF,t_70,g_se,x_16"/></p>
<p> 这个在C语言的的编译器下也是可以通过的但是在C++下就不行，C++编译器对函数的返回值类型检测的更加的严格。<img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/cae187156c30425a98d570d7e96dec9f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<p> <img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_16,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/80eb657f909e434a953535124d151208.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_16,color_FFFFFF,t_70,g_se,x_16"/></p>
<p>还记得在之前写栈的实现的时候我们在初始化时候默认给了栈3个空间，在C语言的时候我们只能在调用这个方法的时候穿一个3作为参数进去，但是在C++里面我们可以这样做。</p>
<h2 id="%C2%A04.1%20%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0%E6%A6%82%E5%BF%B5"> 4.1 缺省参数概念</h2>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
typedef struct Stack
{
	int* array;
	int size;
	int capacity;
}Stack;
void InitStack(Stack* ps, int initCapacity = 3)
{
	cout &lt;&lt; initCapacity &lt;&lt; endl;
}

int main()
{
	Stack s;
	InitStack(&amp;s, 100);
	InitStack(&amp;s);
	return 0;
}</code></pre>
<p><img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/66b9de410db84ab7a07ad11a06776782.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<p> 这个语法在C++是可以通过的，这个3相当与一个备胎你没有传参数，那我就用你了。</p>
<h2 id="4.2%C2%A0%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0%E6%A6%82%E5%BF%B5">4.2 缺省参数概念</h2>
<p>缺省参数是声明或定义函数时为函数的参数指定一个默认值。在调用该函数时，如果没有指定实参则采用该默认值，否则使用指定的实参</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
void Test(int a = 0)
{
	cout &lt;&lt; a &lt;&lt; endl;
}
int main()
{
	Test(); // 没有传参时，使用参数的默认值
	Test(10); // 传参时，使用指定的实参
}</code></pre>
<h2 id="4.3%C2%A0%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0%E5%88%86%E7%B1%BB">4.3 缺省参数分类</h2>
<h3 id="4.3.1%E5%85%A8%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0">4.3.1全缺省参数</h3>
<p>所有参数都有默认参数</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
void Test(int a = 10, int b = 20, int c = 30)
{
	cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; endl;
	cout &lt;&lt; "b = " &lt;&lt; b &lt;&lt; endl;
	cout &lt;&lt; "c = " &lt;&lt; c &lt;&lt; endl;
}
int main()
{
	Test(); // 没有传参时，使用参数的默认值
	Test(10); // 传参时，使用指定的实参
}</code></pre>
<p>那我们在看这段代码</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
void Test(int a = 10, int b = 20, int c = 30)
{
	cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; " b = " &lt;&lt; b &lt;&lt; " c = " &lt;&lt; c &lt;&lt; endl;
}
int main()
{
	Test(); // 没有传参时，使用参数的默认值
	Test(100); // 传参时，使用指定的实参
	Test(100, 200);
	Test(100, 200, 300);
}</code></pre>
<p>这里Test(100);和Test(100, 200, 300);我们都知道第一个替换和全部替换，那为啥Test(100, 200);</p>
<p>结果是100 200 30 不是 100 200 10呢？</p>
<p><img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/7e6ec2ab3f634bb7878dcc86558a74b0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<p> 这里先卖个关子不知道大家知道 __cdecl (下面会说)</p>
<h3 id="4.3.2%E5%8D%8A%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0">4.3.2半缺省参数</h3>
<p>从右往左依次给出默认值</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
void Test(int a, int b = 10, int c = 20)
{
	cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; endl;
	cout &lt;&lt; "b = " &lt;&lt; b &lt;&lt; endl;
	cout &lt;&lt; "c = " &lt;&lt; c &lt;&lt; endl;
}
int main()
{
	Test(10);
}</code></pre>
<p><strong>注意</strong></p>
<p>1. 半缺省参数必须从右往左依次来给出，不能间隔着给（下面会说）</p>
<p>2. 缺省参数不能在函数声明和定义中同时出现</p>
<p><img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/9d7b7774591248c68c46096caaf95a86.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<p> 如果声明与定义位置同时出现，恰巧两个位置提供的值不同，那编译器就无法确定到底该用那<br/> 个缺省值，所以声明和定义不能一起出现。</p>
<p>3. 缺省值必须是常量或者全局变量</p>
<h3 id="4.3.4%20%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A">4.3.4 函数调用约定</h3>
<p>给定以下代码</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
int Test(int a = 10, int b = 20, int c = 30)
{
	cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; " b = " &lt;&lt; b &lt;&lt; " c = " &lt;&lt; c &lt;&lt; endl;
	return a + b + c;
}
int main()
{
	int ret =Test(100, 200, 300);
	Test(100, 200, 300);

	return 0;
}</code></pre>
<p>__cdecl 这个其实是函数的调用约定，在msvc中C和C++函数调用约定都是__cdecl。</p>
<p>__cdecl调用约定又称为 C 调用约定，是 C/C++ 语言缺省的调用约定。参数按照从右至左的方式入栈，函数本身不清理栈，此工作由调用者负责，返回值在eax中。由于由调用者清理栈，所以允许可变参数函数存在</p>
<p><img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_17,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/a733bbe9fd2345e785c8b3feee89b9fd.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_17,color_FFFFFF,t_70,g_se,x_16"/></p>
<p> 我们可以清晰的看到 他把把返回值放在eax寄存器里面</p>
<p><img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_19,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/0f76c35d315141ed91b79c6d9a9acfd8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_19,color_FFFFFF,t_70,g_se,x_16"/></p>
<p>我们在汇编代码可以清晰到是由右向左依次入栈的 ，所以我们在给默认值的时候，必须是从右向左依次给的，如果不然那函数就不知道把谁压栈。</p>
<p>函数调用约定有很多在此就不一一赘述</p>
<h1 id="5.%C2%A0%20%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD">5.  函数重载</h1>
<p>重载？啥是重载呢？就好比是一个次在不同语境下会有不同的含义，比如说 菊花，鸹貔，老司机，这一类的词，我们就说他被重载了。</p>
<h2 id="5.1%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E6%A6%82%E5%BF%B5">5.1函数重载概念</h2>
<p>函数重载:是函数的一种特殊情况，C++允许在同一作用域中声明几个功能类似的同名函数，这些同名函数的形参列表(参数个数 或 类型 或 顺序)必须不同，常用来处理实现功能类似数据类型不同的问题</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
int Add(int left, int right)
{
	return left + right;
}

double Add(double left, double right)
{
	return left + right;
}

double Add(int left, double right)
{
	return left + right;
}

int main()
{
	cout &lt;&lt; Add(10, 20) &lt;&lt; endl;
	cout &lt;&lt; Add(1.2, 3.4) &lt;&lt; endl;
	return 0;
}</code></pre>
<p>调用这Add函数每次根据传入的实参的类型不同，系统找到与之相应的入口参数进行匹配从而实现一个函数多种用途，也就是我们的重载。所以我们根据以上例子就可以得出函数重载的条件：</p>
<ol><li>必须在同一个作用域下。</li><li>函数名相同。</li><li>参数数据类型不同，个数不同，顺序不同。</li></ol>
<p>函数返回值不可以作为重载条件！</p>
<h2 id="5.2%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E7%9A%84%E5%8E%9F%E7%90%86">5.2函数重载的原理</h2>
<ol><li>编译器在编译的时候，会对传递的实参类型进行推演，然后根据推演的结果选择合适的函数进行调用，如果是完全参数类型都是匹配的，则直接调用。</li><li>如果不能进行完全匹配，则编译器会进行隐式类型转换，如果转换之后还没有合适的函数进行调用则报错，反之若有合适的函数则进行调用。</li></ol>
<p><img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/04b893c9a2aa43aebca07d8e4f794562.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<p> 这个例子就很好的说明了发生了隐式类型转换，我传了2个参数一个int 一个 double int可以转换为double double 可以转换为int 这个时候编译器就不知道该调谁了，给你报错有两个相似的转换。</p>
<p>回到刚刚那个问题函数返回值不能作为重载的条件，我隐式类型转换，且匹配成功但是有两个函数返回值是不一样样，翻译器也不知调用谁。</p>
<h2 id="5.3%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">5.3函数重载的底层实现原理</h2>
<p> 为什么C语言不可以实现函数重载而C++可以呢？</p>
<p>首先我们回顾一下C和C++编译器的处理方式，预处理，编译，汇编，链接。</p>
<h3 id="5.3.2%20C%2FC%2B%2B%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F">5.3.2 C/C++编译器的处理方式</h3>
<ol><li>预处理 ：头文件展开，宏替换，去注释，条件编译。</li><li>编译 : 将预处理后的源文件转换为汇编语言文件，只编译源文件，不编译头文件，头文件在刚刚预处理阶段已经展开。</li><li>汇编 ： 虽然叫做汇编，但是不是转变为汇编代码，而是将刚刚的汇编语言文件转换为机器码，也就是二进制文件。</li><li>链接 ：将生成的二进制代码与库函数以及其他目标文件，通过链接器链接起来形成可执行文件的过程。</li></ol>
<p>对于这块不熟悉可看之前的一篇文章</p>
<p><a class="link-info" href="https://blog.csdn.net/qq_50119037/article/details/123424389?spm=1001.2014.3001.5501" title="C语言 程序的翻译 预处理 编译 汇编 链接 #define详解">C语言 程序的翻译 预处理 编译 汇编 链接 #define详解</a></p>
<p>C语言编译器的处理方式</p>
<p><img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/2c29e164505e433d84562ff596764b26.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<p>这时候光声明没定义，给你报错报的是链接错误就是你这函数没有定义，我编译器找不到他的入口地址，但是你的名字不是add吗前面这个_add 是啥。</p>
<p>C++编译器处理方法</p>
<p><img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/99a8c784e4444967af2b1da8abde1669.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<p>我这边也没有定义， 这个？add@@YAHHH@Z  ，？add@@YAHNH@Z  ,？add@@YAHNN@Z  是啥意思呀？</p>
<p>说明编译器在把函数名修改了！这里我们在谈到名字修饰的问题。</p>
<h3 id="5.3.3%20%E5%90%8D%E5%AD%97%E4%BF%AE%E9%A5%B0">5.3.3 名字修饰</h3>
<ol><li>编译器需保证每个函数的实体名称唯一，防止名字污染，而为每个函数名进行修饰;</li><li>编译器在链接时，当出现调用函数，就是通过修饰后的实体函数名来进行查找的，不同编译器不同语言的修饰规则不同。</li></ol>
<p>C语言的修饰规则就是简单在下面加上下划线。</p>
<p>在MSVC编译器下修饰规则则是这样的</p>
<p><img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/8044e3c897df4a89bdac1edccc420c16.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<p>我们再在Linux g++ 下面看一下</p>
<p>Linux是开源的他的方式方法就很好让人读懂没有MSVC这么诡异</p>
<p>C</p>
<p><img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_11,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/68bf683ea4ea4d01b1cf22bf35d88284.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_11,color_FFFFFF,t_70,g_se,x_16"/></p>
<p> <img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_19,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/3950024bf8e04af68c7fa92eb43bb99c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_19,color_FFFFFF,t_70,g_se,x_16"/></p>
<p>没有做啥修饰就是单纯函数名字 </p>
<p>C++</p>
<p><img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_14,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/54c24d1c33194aaeb727b76bf7fa3ec4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_14,color_FFFFFF,t_70,g_se,x_16"/></p>
<p><img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/1f3a577de5a840b3b29e40e4685a5de3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<p> 对于C++就是_z3指的是函数名字占三个字符，add就是函数名字，后面俩就是参数类型，i就是int，d就是double。 </p>
<p>我们在回到刚才那个问题 ，为什么有名字修饰，为什么C语言不能进行函数重载？</p>
<ol><li> .c或者.cpp文件，需要在编译器经过预处理 编译 汇编 链接 生成可执行文件，才能让计算机直接运行，而操作系统会在编译环节堆程序里的函数进程 名字修饰以便识别查找；</li><li>  C语言的所有编译器对进程函数的名字修饰并不涉及参数，只能通过函数名对不同的函数进行区分，故C语言不支持函数重载；</li><li>  C++的编译器对其函数进行的名字修饰会将参数类型包括，故C++支持函数重载</li><li> 链接阶段是通过经过修饰的函数名字找他的入口地址，而修饰规则跟他参数列表的参数类型有关，跟函数返回值没有关系，因此函数返回值不可以作为重载条件。<br/>  </li></ol>
<h2 id="5.4%20extern%20%E2%80%9C%20C%20%E2%80%9D">5.4 extern “ C ”</h2>
<p>假设一个情景在一个公司做开发，有人熟悉C语言，有人熟悉C++那怎么办呢？</p>
<p>在C++中可以使用extern “ C ”修饰一个函数，则是告诉编译器修饰函数按照C语言的风格编译.</p>
<p>在拿刚刚那个链接错误举例子来看。</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;

extern "C" int add(int left, int right);

int main() {
	int ret = add(1, 2);

}</code></pre>
<p><img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/17de5d524ae3408ea5f94c89fbd36e8a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<p>明显发现这是浓烈的C语言风格，函数名称前面加了个下划线来进行修饰。 </p>
<p>其实extern不是这样使用的一般是我们创建库的时候使用的。</p>
<p>这里演示一下VS2022静态库的创建以及使用。</p>
<p><img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/0489d7629d3446f1b710169fa8b1c831.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<p> <img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/8c0b9d1339b749a49d945c3b7836a695.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<p> <img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/7daff0bc970d4da19d1c8c82b896d43d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<p> <img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/778ff95569c546f798b07966670bff99.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<p> <img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/a4379b80a4d14e3b92fbe05d6f310d1a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<p>就可以看见是一个静态库了。</p>
<p>生成解决方案后就可以在目录中找到了</p>
<p> <img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/a37753a89a8e47c9b6ce85f4d9293840.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<p>找到刚刚 工程那个文件把静态库拷贝进去</p>
<p><img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/79bfa92633bd43c5a06aa757a8046780.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<p> <img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/c52df3ffc484405391ae82dfbf3e6676.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<p> <img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/9c4a037241614415b5197d4b9bfabb58.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<p> <img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/9006b350f63341cbb8c5e08cdec836ed.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16"/>我们在把他用起来</p>
<p></p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
//刚刚的静态库文件
#include"testlib.h"

//预处理命令把静态库引进来
// .\是当前目录然后\转义字一下..\是当前目录的上一级目录
#pragma comment (lib,".\\..\\Debug\\lib\\testlib.lib")


int main() {
	cout &lt;&lt; add(1, 2) &lt;&lt; endl;
}</code></pre>
<p><img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/c2c061fcf4f44708abb8c3758a227e2f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<p> 我现在是C++写的静态库我C++当然可以用，那我现在创建一个C语言的工程呢?</p>
<p>我现在在C程序里面调add函数，就发现报错了。</p>
<p><img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/0e3d0ce5c1764a0d87a4519e284200fe.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<p>这时候就该用到extern “ C ”了</p>
<pre><code class="language-cpp">#pragma once


#if __cpluscplus

extern "C"
{
#endif

	int add(int left, int right);
	int sub(int left, int right);
	int mul(int left, int right);
    int div(int left, int right);
#if __cpluscplus
}
#endif</code></pre>
<p> 条件编译一下就好了。</p>
<h1 id="6.%20%E5%BC%95%E7%94%A8">6. 引用</h1>
<h2 id="6.1%E5%BC%95%E7%94%A8%E7%9A%84%E6%A6%82%E5%BF%B5">6.1引用的概念</h2>
<p>引用不是新定义的一个变量，而是给已经存在的变量起了一个别名，编译器不会给他开辟内存空间，他和他的引用变量共用一个内存空间。张三，他也可以被叫做法外狂徒。</p>
<p>我们来看之前C语言这个例子。</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;

//void swap(int a, int b) {
//	int temp = a;
//	a = b;
//	b = temp;
//}
void swap(int *a, int *b) {
	int temp = *a;
	*a = *b;
	*b = temp;
}
void swap(int&amp; a, int&amp; b) {
	int temp = a;
	a = b;
	b = temp;
}
int main() {
	int a = 10;
	int b = 20;
	swap(a, b);
	cout &lt;&lt; a &lt;&lt; endl;
	cout &lt;&lt; b &lt;&lt; endl;
}</code></pre>
<p>在C++里面新增了引用类型，也可以做到！</p>
<h2 id="6.2%E5%BC%95%E7%94%A8%E7%9A%84%E8%AF%AD%E6%B3%95">6.2引用的语法</h2>
<p>类型&amp; 引用变量名(对象名) = 引用实体<br/>  </p>
<pre><code class="language-cpp">void Test()
{
    int a = 10;
    int&amp; ra = a;
    printf("%p\n", &amp;a);
    printf("%p\n", &amp;ra);
}</code></pre>
<h2 id="6.3%E5%BC%95%E7%94%A8%E7%9A%84%E7%89%B9%E6%80%A7">6.3引用的特性</h2>
<ol><li>引用在定义时必须初始化</li><li>一个变量可以有多个引用</li><li>引用一旦引用一个实体，再不能引用其他实体</li></ol>
<p><img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/8191d9e56b3c425e94653db200ea44f6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<p> 很明显验证了编译器不会给他开辟内存空间，他和他的引用变量共用一个内存空间。</p>
<p><img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/c31afb2bf989406eb1ac0e19a168e6fd.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<p> 一个变量可以有多个引用，这几个全是一个货，地址都一样，我rrra一改全改了。</p>
<p><img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/dd5afe202ca846e9b945caa3b0acd3ad.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<p><img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_16,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/90586ec6fa574b8db1af5b31a2637043.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_16,color_FFFFFF,t_70,g_se,x_16"/></p>
<p> 引用一旦引用一个实体，再不能引用其他实体，后面会说。</p>
<h2 id="6.4%20%E5%B8%B8%E5%BC%95%E7%94%A8">6.4 常引用</h2>
<p><img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_11,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/7fb4bc389bff44909c7760a7033a57b5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_11,color_FFFFFF,t_70,g_se,x_16"/><img alt="88016ff6bb684ef1beded31443dadae6.png" src="https://img-blog.csdnimg.cn/88016ff6bb684ef1beded31443dadae6.png"/></p>
<p>· 在C语言里面一个变量被const修饰之后他就是一个不可以被修改的变量,而在C++里面一个变量被const修饰之后就是一个常量了，我给个数组把a丢进去也是可行的充分说明这时候a就是一个常量。</p>
<p>那我现在去给他来个引用，就会发现报错了！</p>
<p> <img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/9491899b6b284b9aab4ea9ee88c15e96.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<p>再来看这个例子</p>
<p> <img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_10,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/b326d3686ec749dfaecffde83c8e31b5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_10,color_FFFFFF,t_70,g_se,x_16"/></p>
<p>刚刚说过引用必须引用的是一个实体跟引用实体类型相同，但是我们加const就可以，而且按理说我把a修改了ra应该也变呀，我们来看一下。</p>
<p><img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/9083916f3fd74121b13f4a945e01f85d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<p> <img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/20542298c15041da9baf2af1a8ffa904.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<p>不仅a和ra没变，而且这个ra不是a的引用，他俩地址都不一样，说明ra就不是a的引用那是谁的引用呢？</p>
<p>你引用整形的，编译器就是会知道要发生隐式类型转换，编译器把12放在一个临时变量里面，你不知道变量的名字，也不知道他的地址空间，他的地址空间也没有名字，你不可以读也不可以写，说明这个东西具有常性，相当于你引用的是一个常量，那你不加const咋行呢？</p>
<h2 id="6.5%E5%BC%95%E7%94%A8%E7%9A%84%E5%BA%94%E7%94%A8">6.5引用的应用</h2>
<h3 id="6.5.1%E7%AE%80%E5%8C%96%E4%BB%A3%E7%A0%81%E5%A2%9E%E5%8A%A0%E5%8F%AF%E8%AF%BB%E6%80%A7">6.5.1简化代码增加可读性</h3>
<p>还是那个swap的例子</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;

void swap(int** a, int** b) {
	int* temp = *a;
	*a = *b;
	*b = temp;
}
//有了引用就可以这样做
void swap(int*&amp; a, int*&amp; b) {
	int* temp = a;
	a = b;
	b = temp;
}
int main() {
	int a = 10;
	int b = 20;
	int* pa = &amp;a;
	int* pb = &amp;b;
	swap(&amp;pa, &amp;pb);
	swap(pa, pb);
}</code></pre>
<p>这样子代码的可读性增加了，引用其实可以代替一级指针（引用的本质......），可以吧指针简化一部分。</p>
<h3 id="6.5.2%E5%A2%9E%E5%8A%A0%E4%BB%A3%E7%A0%81%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7">6.5.2增加代码的安全性</h3>
<p>不想通过形参改变外部实参可以加一个常引用</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
typedef struct Stack
{
	int* array;
	int size;
	int capacity;
}Stack;

// 如果引用类型作为函数的形参，尽量传递引用
// 如果不想通过形参修改外部实参，将引用给成const类型的引用
int StackSize(const Stack&amp; s)
{
	// s.size = 100;
	return s.size;
}

int main()
{
	Stack s;

	//....进行一系列压栈操作之后，栈中有5个元素
	s.size = 5;
	cout &lt;&lt; StackSize(s) &lt;&lt; endl;
	return 0;
}</code></pre>
<h3 id="6.5.3%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B">6.5.3作为函数的返回值类型</h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
// 3. 作为函数的返回值类型
//int&amp; Add(int left, int right)
//{
//	int temp = left + right;
//	cout &lt;&lt; &amp;temp &lt;&lt; endl;
//	return temp;
//}
int temp = 0;

int&amp; Add(int left, int right)
{
	temp = left + right;
	cout &lt;&lt; &amp;temp &lt;&lt; endl;
	return temp;
}

// 注意：如果以引用方式作为函数的返回值类型，不能返回函数栈上的空间
// 如果要返回，返回的实体必须要比函数的声明周期长，即函数结束了，返回的实体依然存在
int main()
{
	int&amp; ret = Add(10, 20);
	Add(20, 30);
	Add(30, 40);
	return 0;
}</code></pre>
<p>这个例子来想一下这个ret会是多少呢？</p>
<p>走着</p>
<p><img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/dbd7b7aa521b4ea391e8bda1ddf019ee.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<p><img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/8de312af4b6545aa88348dd9fbb6c65d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<p><img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/2ebe25d73c014421b2157d0e04fbe184.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<p> 他这个引用的是啥呀咋就给变了。</p>
<p>来上汇编！</p>
<p><img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/e499e1bafd074f2cb56d62323d65e5e2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<p> <img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/8c5e06cbc58c4dc1b8cc3ce80d4c639b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<p>他引用的其实是临时变量的地址。</p>
<p>这里就要根据汇编语言来了解函数的调用过程</p>
<p> <img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/6839f8bc6c0048c5a180c9ab6f1e4f93.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<p> <img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/00b4d595b3c1476c9ad1c686cf21b7e6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU5q-b5Y-Y5ZCRLg==,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<p>当add函数结束调用后esp 和 ebp也回到原来位置，add函数对应的栈帧已经被系统回收了 ，即add对应的栈帧的空间不能使用了，但是空间还在而且add运行完成之后留下的垃圾数据也在，我的ret引用的是temp那个空间下次调用add就会把原来的垃圾数据覆盖掉，返回后空间还是在的，以此类推，编译的时候就会给你一个警告，你引用的其实是局部变量的地址，你一解引用访问的就是非法的地址！</p>
<p>注意：如果以引用方式作为函数的返回值类型，不能返回函数栈上的空间。<br/> 如果要返回，返回的实体必须要比函数的声明周期长，即函数结束了，返回的实体依然存在。</p>
<h2 id="6.6%20%E5%BC%95%E7%94%A8%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB">6.6 引用和指针的区别</h2>
<h3 id="6.6.1%20%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8C%BA%E5%88%AB">6.6.1 底层实现区别</h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
 
int main() {
	int a = 10;
	int* p = &amp;a;
	*p = 20;

	int&amp; ra = a;
	ra = 30;
}</code></pre>
<p><img alt="" height="272" src="image\f94da3e93f194929bf4d40ae8ffde69b.png" width="587"/></p>
<p> <img alt="" height="221" src="image\8bdd008257c34babb1388d859cecfdbb.png" width="569"/></p>
<p> 这俩好家伙一模一样，那就是说明引用的底层实现就是按照指针的方式实现的，在底层引用就是指针常量(一旦引用一个实体，就不能引用其他实体)</p>
<p>引用其实是有空间的，在概念层面上说， 引用就是起别名，编译器不会为引用变量开辟新的内存空间，引用的变量和引用的实体用的是同一份空间，但是其实在底层引用是有空间的，他就是指针呀，在底层跟指针没有任何区别。</p>
<h3 id="6.6.2%20%E4%BD%BF%E7%94%A8%E5%8C%BA%E5%88%AB">6.6.2 使用区别</h3>
<p>1.有NULL指针但是没有NULL引用。</p>
<p><img alt="" height="366" src="image\759ccc11a8354ef8bf17346658f4253c.png" width="444"/></p>
<p>这个NULL就是一个宏呀,是一个常量当然不能放在引用旁边。 </p>
<p>2.引用一旦引用一个实体就不能在引用其他实体。打码机指针可以任何时间指向同一个类型的实体。</p>
<p>其实就是好比char * 跟 char * const 的区别</p>
<p>3.指针初始化没有任何要求，可以随便指，只不过我们一般让他指向NULL，但是对与引用在使用的时候必须初始化。</p>
<p>4.引用++是给引用后的实体++,而指针++是+上其所指向类型的大小。</p>
<p>5.有多级指针但是没有多级引用。</p>
<p>6.在sizeof里面含义不一样，sizeof（引用）结果是的引用类型的大小，sizeof（指针）在64位下是8，32位下是4。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
 
int main() {
	int a = 10;
	double b = 12.34;

	double* p1 = &amp;b;
	int* p2 = &amp;a;

	int&amp; ra = a;
	double&amp; rb = b;

	cout &lt;&lt; sizeof(p1) &lt;&lt; endl;
	cout &lt;&lt; sizeof(p2) &lt;&lt; endl;
	cout &lt;&lt; sizeof(ra) &lt;&lt; endl;
	cout &lt;&lt; sizeof(rb) &lt;&lt; endl;

}</code></pre>
<p><img alt="" height="609" src="image\db83611a17d84bd29dd40700c4f347dc.png" width="611"/></p>
<p> <img alt="" height="554" src="image\7a97f7c2317f48a5a01908c74c2a047c.png" width="586"/></p>
<p> 7. 访问实体不同，指针需要解引用，引用编译器自己处理。</p>
<h1 id="7.%20%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0">7. 内联函数</h1>
<h2 id="7.1%20%23define%20%E5%AE%8F">7.1 #define 宏</h2>
<p>还记得在C语言里面的宏  #define  吗？</p>
<p>在你的文本文件变成可执行文件编译器处理的时候，第一步就是预处理，预处理会进行，头文件展开，去注释，条件编译，和宏替换，以为是在预处理进行的替换，那他会出一些奇奇怪怪的错误。</p>
<h3 id="7.1.1%C2%A0%20%E5%AE%8F%E5%B8%B8%E9%87%8F">7.1.1  宏常量</h3>
<p>那我们一般对于数字进行宏替换的时候要加；吗？</p>
<pre><code class="language-cpp">#define MAX 1000;
#define MAX 1000</code></pre>
<p>在Linux底下看看预处理完的文件</p>
<p><img alt="" height="214" src="image\e9661a9cc8b24d2ba0ef4894c38d7dbd.png" width="224"/></p>
<p>再举个例子在上文 我们刚刚谈到了const 修饰 一个变量在C++跟 C语言不同 </p>
<p>C语言 const修饰就是原本这个变量变成了一个不可修改的常量。</p>
<p>C++中const修饰就是原本这个变量变成了一个常量。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
 
//在C++中 const修饰的内容已经是一个常量了
// 在C语言中，const修饰的内容是一个不可以被修改的变量
int main()
{
	const int MAX_SIZE = 100;
	int array[MAX_SIZE];
	return 0;
}</code></pre>
<p>按理说我通过指针已经把a的内容修改了，不是应该是100吗？为啥是10？</p>
<p>const修饰的内容不仅仅是一个常量，而且还具有宏替换的效果，并且替换发生在编译时。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
 
// const修饰的内容不仅仅是一个常量，而且还具有宏替换的效果
// 并且替换发生在编译时
int main()
{
	const int a = 10;

	int* pa = (int*)&amp;a;  
	*pa = 100;

	cout &lt;&lt; a &lt;&lt; endl; 
	cout &lt;&lt; *pa &lt;&lt; endl;
	return 0;
}</code></pre>
<p> <img alt="" height="532" src="image\d9dbd7308c4d4316adf2304c07dc9d74.png" width="1078"/></p>
<h3 id="7.1.2%20%E5%AE%9A%E4%B9%89%E5%AE%8F">7.1.2 定义宏</h3>
<p>#define 机制包括了一个规定，允许把参数替换到文本中，这种实现通常称为宏。<br/> 下面是宏的申明方式：<br/> #define name( parament-list ) stuff其中的 parament-list 是一个由逗号隔开的符号表，它们可能出现在stuff中。<br/> 注意：<br/> 参数列表的左括号必须与name紧邻。如果两者之间有任何空白存在，参数列表就会被解释为stuff的一部分</p>
<p>比如这个例子</p>
<h2 id="%E2%80%8B"><img alt="" height="175" src="image\932775c23a164e4585327eb5347a2875.png" width="328"/></h2>
<p>我们原本想的是应该是11*11 结果是121 为啥是21呢，那就看看.i 文件看看到底宏替换哪块出问题了 </p>
<h2><img alt="" height="236" src="image\190670abab6a44b4a9b44f94d29c354e.png" width="851"/></h2>
<p>原来是替换之后根据运算符号的先后顺序所以结果是21那么怎样去避免这个问题呢我们在宏定义的时候这样去做 </p>
<pre><code class="language-cpp">#define sq(x) (x)*(x)</code></pre>
<h2><img alt="" height="200" src="image\aff92ee3abe549a7abd9137937a96859.png" width="296"/></h2>
<p> 不是按理来说应该是110吗咋变成1210了那我们再看看.i文件</p>
<h2><img alt="" height="366" src="image\1e1a8a652cb64f2e8550c745c08d2fa5.png" width="1200"/></h2>
<pre><code class="language-cpp">#define sq(x) ((x)*(x))</code></pre>
<p>带参宏就会有很多很多的问题在替换中提现到那只能尽可能的加（）来避免操作顺序带来的问题</p>
<p>尽量不要使用这种带参数的</p>
<p>但是却省掉了很多函数调用的开销，参数压栈，开辟栈帧等一些列操作，运行效率高，他就是简单的替换！</p>
<h3 id="7.1.3%20%E5%AE%8F%E7%9A%84%E6%9B%BF%E6%8D%A2%E8%A7%84%E5%88%99">7.1.3 宏的替换规则</h3>
<p>        1. 在调用宏时，首先对参数进行检查，看看是否包含任何由#define定义的符号。如果是，它们首先被替换。<br/>         2. 替换文本随后被插入到程序中原来文本的位置。对于宏，参数名被他们的值替换。<br/>         3. 最后，再次对结果文件进行扫描，看看它是否包含任何由#define定义的符号。如果是，就重复上述处理过程。<br/> 注意：<br/>         1. 宏参数和#define 定义中可以出现其他#define定义的变量。但是对于宏，不能出现递归。<br/>         2. 当预处理器搜索#define定义的符号的时候，字符串常量的内容并不被搜索。</p>
<h3 id="7.1.4%20%E5%AE%8F%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9">7.1.4 宏的优缺点</h3>
<p>优点：<br/>         1.增强代码的复用性。<br/>         2.提高性能。<br/> 缺点：<br/>         1.不方便调试宏。（因为预编译阶段进行了替换）<br/>         2.导致代码可读性差，可维护性差，容易误用。<br/>         3.没有类型安全的检查 。</p>
<p>但是宏的缺点还是很多的C++为了解决就提出了内联函数。</p>
<h2 id="7.2%20%E6%A6%82%E5%BF%B5">7.2 概念</h2>
<p> 以inline修饰的函数叫做内联函数，编译时C++编译器会在调用内联函数的地方展开，没有函数压栈的开销，内联函数提升程序运行的效率。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
 
inline int Add(int left, int right)
{
	return left + right;
}


int main()
{
	int a = 10;
	int b = 20;
	int ret = Add(a, b);
	cout &lt;&lt; ret &lt;&lt; endl;


	return 0;
}</code></pre>
<p>那他是怎样展开的呢？让我们再来看看汇编代码。</p>
<p><img alt="" height="654" src="image\b6c204ddb789425fa47a28759d100598.png" width="649"/></p>
<p>这一看没有展开呀 我call指令把这个当函数调用了，因为我们是在Debug模式下为了调试，如果展开了就不能调试了，在Debug模式下用户要进行调试。</p>
<p><img alt="" height="610" src="image\11c4c4cbc55646e58171161108e42c08.png" width="553"/></p>
<p> 发现就根本没有调用函数，直接把1Eh也就是30直接给打印了，就不用调用函数，也不需要参数压栈，开辟栈帧，那一系列的操作了。</p>
<p>那我要看展开没有那就得设置一下编译器。</p>
<p><img alt="" height="895" src="image\b85f60fcf8824baeb3d6af04e888004d.png" width="1200"/></p>
<p> <img alt="" height="692" src="image\f9a6e18d3aad46b6be666889537a4378.png" width="1000"/></p>
<p><img alt="" height="692" src="image\914f0200d29a4589b5fac7a0dddcab40.png" width="1000"/></p>
<p>就可以了 </p>
<p> <img alt="" height="669" src="image\0e64b1d6ef20467ba14367e44f478614.png" width="820"/></p>
<h2 id="%C2%A07.3%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"> 7.3注意事项</h2>
<p>        1. inline是一种以空间换时间的做法，省去调用函数额开销。所以代码很长或者有循环/递归的函数不适宜使用作为内联函数。</p>
<p>        2. inline对于编译器而言只是一个建议，编译器会自动优化，如果定义为inline的函数体内有循环/递归等等，编译器优化时会忽略掉内联。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

inline int Add(int left, int right)
{
	Add(left,right);
	return left + right;
}


int main()
{
	int a = 10;
	int b = 20;
	int ret = Add(a, b);
	printf("&amp;d", ret);
	return 0;
}</code></pre>
<p><img alt="" height="664" src="image\54047a3f89434e2b893d8e6f71471df9.png" width="781"/><br/>         3. inline不建议声明和定义分离，分离会导致链接错误。因为inline被展开，就没有函数地址了，链接就会找不到。</p>
<p></p>
<p><strong>持续更新中...........</strong></p>
</div>
</div>