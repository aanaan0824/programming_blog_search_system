<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<hr/>
<p id="main-toc"><strong>目录</strong></p>
<p id="1%E3%80%81string%E7%B1%BB%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-toc" style="margin-left:80px;"><a href="#1%E3%80%81string%E7%B1%BB%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">1、string类的基础知识</a></p>
<p id="2%E3%80%81string%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3%E8%AF%B4%E6%98%8E-toc" style="margin-left:80px;"><a href="#2%E3%80%81string%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3%E8%AF%B4%E6%98%8E">2、string类的常用接口说明</a></p>
<p id="2.1%E3%80%81string%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#2.1%E3%80%81string%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0">        2.1、string类的成员函数</a></p>
<p id="constructor%EF%BC%88%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%89-toc" style="margin-left:80px;"><a href="#constructor%EF%BC%88%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%89">                 constructor（构造函数）</a></p>
<p id="destructor%EF%BC%88%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%EF%BC%89-toc" style="margin-left:80px;"><a href="#destructor%EF%BC%88%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%EF%BC%89">                 destructor（析构函数）</a></p>
<p id="operator%3D%EF%BC%88%E8%B5%8B%E5%80%BC%EF%BC%89-toc" style="margin-left:80px;"><a href="#operator%3D%EF%BC%88%E8%B5%8B%E5%80%BC%EF%BC%89">                 operator=（赋值）</a></p>
<p id="string%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%B9%E9%87%8F%E6%93%8D%E4%BD%9C-toc" style="margin-left:80px;"><a href="#string%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%B9%E9%87%8F%E6%93%8D%E4%BD%9C">                 string类对象的容量操作</a></p>
<p id="%E8%BF%AD%E4%BB%A3%E5%99%A8-toc" style="margin-left:80px;"><a href="#%E8%BF%AD%E4%BB%A3%E5%99%A8">                 迭代器</a></p>
<p id="string%E7%B1%BB%E7%9A%84%E5%85%83%E7%B4%A0%E8%AE%BF%E9%97%AE-toc" style="margin-left:80px;"><a href="#string%E7%B1%BB%E7%9A%84%E5%85%83%E7%B4%A0%E8%AE%BF%E9%97%AE">                 string类的元素访问</a></p>
<p id="string%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%81%8D%E5%8E%86%E6%93%8D%E4%BD%9C-toc" style="margin-left:80px;"><a href="#string%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%81%8D%E5%8E%86%E6%93%8D%E4%BD%9C">                 string类对象的遍历操作</a></p>
<p id="string%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E6%93%8D%E4%BD%9C-toc" style="margin-left:80px;"><a href="#string%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E6%93%8D%E4%BD%9C">                 string类对象的修改操作</a></p>
<p id="2.2%E3%80%81sring%E7%B1%BB%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#2.2%E3%80%81sring%E7%B1%BB%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0">        2.2、sring类非成员函数</a></p>
<hr/>
<h3>1、string类的基础知识</h3>
<blockquote>
<ol><li>字符串是表示字符序列的类</li><li>标准的字符串类提供了对此类对象的支持，其接口类似于标准字符容器的接口，但添加了专门用于操作单字节字符字符串的设计特性。</li><li>string类是使用char(即作为它的字符类型，使用它的默认char_traits和分配器类型(关于模板的更多信息，请参阅basic_string)。</li><li>string类是basic_string模板类的一个实例，它使用char来实例化basic_string模板类，并用char_traits和allocator作为basic_string的默认参数(根于更多的模板信息请参考basic_string)。</li><li>注意，这个类独立于所使用的编码来处理字节:如果用来处理多字节或变长字符(如UTF-8)的序列，这个类的所有成员(如长度或大小)以及它的迭代器，将仍然按照字节(而不是实际编码的字符)来操作。</li></ol>
<p><span style="color:#0d0016;"><strong>总结：</strong></span></p>
<ol><li>string是表示字符串的字符串类</li><li>该类的接口与常规容器的接口基本相同，再添加了一些专门用来操作string的常规操作。</li><li>string包含的头文件是#include&lt;string&gt;</li><li>string是属于std命名空间的，using namespace std;</li><li>string类是管理动态增长字符数组，这个字符串以\0结尾</li></ol>
</blockquote>
<hr/>
<h3 id="2%E3%80%81string%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3%E8%AF%B4%E6%98%8E">2、string类的常用接口说明</h3>
<h3 id="2.1%E3%80%81string%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0">2.1、string类的成员函数</h3>
<h3 id="constructor%EF%BC%88%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%89">constructor（构造函数）</h3>
<blockquote>
<table border="3" cellpadding="1" cellspacing="1" style="width:672px;"><tbody><tr><td style="width:373px;"><strong>函数名称</strong></td><td style="width:289px;"><strong>功能说明</strong></td></tr><tr><td style="width:373px;"><span style="color:#494949;">1、</span><span style="color:#956fe7;">string()</span>（重点）</td><td style="width:289px;">无参构造空的string类对象，即空字符串</td></tr><tr><td style="width:373px;"><span style="color:#494949;">2、</span><span style="color:#956fe7;">string(const char* s)</span> （重点）</td><td style="width:289px;">带参的常量字符串初始化</td></tr><tr><td style="width:373px;"><span style="color:#494949;">3、</span><span style="color:#956fe7;">string(const string&amp;s)</span> （重点）</td><td style="width:289px;">拷贝构造函数</td></tr><tr><td style="width:373px;"><span style="color:#494949;">4、string (const char* s, size_t n)</span></td><td style="width:289px;">对一个字符串的前n个初始化</td></tr><tr><td style="width:373px;"><span style="color:#494949;">5、string (size_t n, char c)</span></td><td style="width:289px;">用 n 个 c 初始化</td></tr><tr><td style="width:373px;"><span style="color:#494949;">6、string (const string&amp; str, size_t pos, size_t len = npos)</span></td><td style="width:289px;">从pos位置处取len长度的字符进行拷贝构造</td></tr></tbody></table>
<ul><li><strong>1、string() 无参构造</strong></li></ul>
<pre><code class="language-cpp">string s1;//无参初始化</code></pre>
<ul><li><strong>2、string(const char* s) 带参构造</strong></li></ul>
<pre><code class="language-cpp">string s2("hello world!");//常量字符串初始化</code></pre>
<ul><li><strong>3、string(const string&amp;s) 拷贝构造</strong></li></ul>
<pre><code class="language-cpp">string s2("hello world!");//常量字符串带参构造
string s3(s2);//拷贝构造
string s4 = s2;//也是拷贝构造</code></pre>
<ul><li><strong>4、string (const char* s, size_t n) 对一个字符串的前n个初始化</strong></li></ul>
<pre><code class="language-cpp">string s5("https://mp.csdn.net/", 5);//对该字符串的前5个初始化
cout &lt;&lt; s5 &lt;&lt; endl;//https</code></pre>
<ul><li><strong>5、string (size_t n, char c) 用n个c初始化</strong></li></ul>
<pre><code class="language-cpp">string s6(5, 'k');//用5个k初始化
cout &lt;&lt; s6 &lt;&lt; endl;//kkkkk</code></pre>
<ul><li><strong>6、string (const string&amp; str, size_t pos, size_t len = npos) 从pos位置处取len长度的字符进行拷贝构造</strong></li></ul>
<pre><code class="language-cpp">string s2("hello world!");//带参拷贝构造
string s7(s2, 6, 5);//从s2字符串的第6个位置往后取5个字符初始化
cout &lt;&lt; s7 &lt;&lt; endl;//world
</code></pre>
</blockquote>
<hr/>
<h3 id="destructor%EF%BC%88%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%EF%BC%89">destructor（析构函数）</h3>
<blockquote>
<p>前面已经说过string类是管理动态增长字符数组，对于动态申请的空间，需要用到析构函数把它释放掉。不过这里我们无需操作，因为编译器会帮我们默认调用构造函数。</p>
</blockquote>
<hr/>
<h3 id="operator%3D%EF%BC%88%E8%B5%8B%E5%80%BC%EF%BC%89">operator=（赋值）</h3>
<blockquote>
<p><img alt="" height="131" src="image\996f624eb4b6461d89fc14721467044f.png" width="776"/></p>
<pre><code class="language-cpp">void test_string2()
{
	string s1("hello");
	string s2("xxx");
	s1 = s2;//string 
	s1 = "kkk";//c-string 
	s1 = 'y';//character 
}</code></pre>
</blockquote>
<hr/>
<h3 id="string%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%B9%E9%87%8F%E6%93%8D%E4%BD%9C">string类对象的容量操作</h3>
<blockquote>
<table border="3" cellpadding="1" cellspacing="1" style="width:549px;"><tbody><tr><td style="width:152px;"><span style="color:#0d0016;"><strong>函数名称</strong></span></td><td style="width:393px;"><span style="color:#0d0016;"><strong>功能说明</strong></span></td></tr><tr><td style="width:152px;"><span style="color:#494949;">1、</span><span style="color:#956fe7;">size</span>（重点）</td><td style="width:393px;">返回字符串有效字符长度</td></tr><tr><td style="width:152px;">2、length</td><td style="width:393px;">返回字符串有效字符长度</td></tr><tr><td style="width:152px;">3、max_size</td><td style="width:393px;">返回字符串最大长度</td></tr><tr><td style="width:152px;">4、capacity</td><td style="width:393px;">返回空间总大小</td></tr><tr><td style="width:152px;">5、<span style="color:#956fe7;">reserve</span>（重点）</td><td style="width:393px;">为字符串预留空间</td></tr><tr><td style="width:152px;">6、<span style="color:#956fe7;">resize</span>（重点）</td><td style="width:393px;">将有效字符的个数拆成n个，多出的空间用字符c填充</td></tr><tr><td style="width:152px;">7、<span style="color:#956fe7;">clear</span>（重点）</td><td style="width:393px;">清空有效字符</td></tr><tr><td style="width:152px;">8、<span style="color:#956fe7;">empty</span>（重点）</td><td style="width:393px;">检测字符串释放为空串，是返回true，否则返回false</td></tr></tbody></table>
<ul><li><strong>1、<span style="color:#956fe7;">size</span></strong></li></ul>
<p>size返回的是有效字符的个数：</p>
<pre><code class="language-cpp">size_t size() const;</code></pre>
<pre><code class="language-cpp">int main ()
{
  string str ("Test string");
  cout &lt;&lt; str.size() &lt;&lt; endl;//11
  return 0;
}</code></pre>
<ul><li> <strong>2、<span style="color:#956fe7;">length</span></strong></li></ul>
<pre><code class="language-cpp">size_t length() const;</code></pre>
<p>length和size无本质之差，返回的都是字符串的长度。</p>
<pre><code class="language-cpp">void test_string1()
{
	string s("hello world");
	cout &lt;&lt; s.length() &lt;&lt; endl;//11
}</code></pre>
<p>但是受到历史背景的影响，还是推荐用size合意。</p>
<ul><li><strong>3、<span style="color:#956fe7;">max_size</span></strong></li></ul>
<pre><code class="language-cpp">size_t max_size() const;</code></pre>
<p>max_size返回的就是最大值 </p>
<p><img alt="" height="124" src="image\b3c5bbb70aa944e6a03e05fa3ccf1fce.png" width="581"/></p>
<ul><li><strong> 4、<span style="color:#956fe7;">capacity</span></strong></li></ul>
<pre><code class="language-cpp">size_t capacity() const;</code></pre>
<p>capacity返回的就是容量大小</p>
<pre><code class="language-cpp">void test_string6()
{
	string s("hello world");
	cout &lt;&lt; s.capacity() &lt;&lt; endl;//15
}</code></pre>
<ul><li> <strong>5、<span style="color:#956fe7;">reserve</span></strong></li></ul>
<pre><code class="language-cpp">void reserve (size_t n = 0);</code></pre>
<p><span style="color:#0d0016;"><strong>reserve的特性：</strong></span></p>
<ol><li>请求将字符串容量适应计划的大小更改为最多 n 个字符的长度。</li><li>如果 n 大于当前字符串容量，则该函数会导致容器将其容量增加到 n 个字符（或更大）。</li><li>在所有其他情况下，它被视为收缩字符串容量的非约束性请求：容器实现可以自由地进行优化，并使字符串的容量大于n。</li><li>此函数对字符串长度没有影响，并且无法更改其内容。</li><li>利用reserve进行提前预留空间，可以减少扩容带来的损耗。</li></ol>
<p>如下没有reserve预留空间：</p>
<p><img alt="" height="415" src="image\6020f1f9f738498caabe0db4816aaaa8.png" width="1039"/><br/> 很明显，普通版本的尾插会进行多次扩容，而频繁扩容会带来效率损失，可以加上reserve预留空间进行优化：</p>
<p><img alt="" height="417" src="image\4b38c355c0694374ad15592d92a29073.png" width="1122"/><br/> 很清晰明了，加上了reserve提前预留空间大大减少了扩容的频次从而避免效率上的损失。</p>
<p>reserve只会改变容量，再看一组测试用例：</p>
<pre><code class="language-cpp">void test()
{
	string s("hello world");
	cout &lt;&lt; s &lt;&lt; endl; //hello world
	cout &lt;&lt; s.size() &lt;&lt; endl; //11
	cout &lt;&lt; s.capacity() &lt;&lt; endl; //15

	//reverse(n)当n大于对象当前的capacity时，将当前对象的capacity扩大为n或大于n
	s.reserve(20);
	cout &lt;&lt; s &lt;&lt; endl; //hello world
	cout &lt;&lt; s.size() &lt;&lt; endl; //11
	cout &lt;&lt; s.capacity() &lt;&lt; endl; //31

	//reverse(n)当n小于对象当前的capacity时，什么也不做
	s.reserve(5);
	cout &lt;&lt; s &lt;&lt; endl; //hello world
	cout &lt;&lt; s.size() &lt;&lt; endl; //11
	cout &lt;&lt; s.capacity() &lt;&lt; endl; //31
}</code></pre>
<ul><li><strong>6、<span style="color:#956fe7;">resize</span></strong></li></ul>
<p><img alt="" height="53" src="image\f53a41cd146f46d583da6534fe433fce.png" width="625"/></p>
<p><span style="color:#0d0016;"><strong>resize特性：</strong></span></p>
<ol><li> 将字符串大小调整为 n 个字符的长度。</li><li>如果 n 小于当前字符串长度，则当前值将缩短为其前 n 个字符，并删除超出第 n 个字符的字符。</li><li>如果 n 大于当前字符串长度，则通过在末尾插入所需数量的字符以达到 n 大小来扩展当前内容。<span style="color:#956fe7;">如果指定了 c，则新元素将初始化为 c 的副本</span>，否则，它们是值初始化字符（空字符）。</li></ol>
<pre><code class="language-cpp">void test()
{
	string s1("hello world");
	//resize(n)n小于对象当前的size时，将size缩小到n
	s1.resize(4);
	cout &lt;&lt; s1 &lt;&lt; endl; //hell
	cout &lt;&lt; s1.size() &lt;&lt; endl; //4
	cout &lt;&lt; s1.capacity() &lt;&lt; endl; //15

	string s2("hello world");
	//resize(n)n大于对象当前的size时，将size扩大到n，扩大的字符默认为'\0'
	s2.resize(20);
	cout &lt;&lt; s2 &lt;&lt; endl; //hello world
	cout &lt;&lt; s2.size() &lt;&lt; endl; //20
	cout &lt;&lt; s2.capacity() &lt;&lt; endl; //31

	string s3("hello world");
	//resize(n, char)n大于对象当前的size时，将size扩大到n，扩大的字符为char
	s3.resize(20, 'x');
	cout &lt;&lt; s3 &lt;&lt; endl; //hello worldxxxxxxxxx
	cout &lt;&lt; s3.size() &lt;&lt; endl; //20
	cout &lt;&lt; s3.capacity() &lt;&lt; endl; //31	
}
</code></pre>
<ul><li><strong>7、<span style="color:#956fe7;">clear</span></strong></li></ul>
<p><img alt="" height="138" src="image\c43949e9543641d78672a8919c03d1dd.png" width="640"/></p>
<p>clear的本质就是清掉所有空间。</p>
<pre><code class="language-cpp">void test()
{
	string s("hello world");
	cout &lt;&lt; s &lt;&lt; endl;//hello world
	s.clear();
	cout &lt;&lt; s.size() &lt;&lt; endl;//0
	cout &lt;&lt; s &lt;&lt; endl;//空
}</code></pre>
<ul><li><strong>8、<span style="color:#956fe7;">empty</span></strong></li></ul>
<p><img alt="" height="137" src="image\1cd65e835f0f447a86523ab2af48874c.png" width="627"/></p>
<pre><code class="language-cpp">void test()
{
	string s("hello world");
	cout &lt;&lt; s &lt;&lt; endl;//hello world
	s.clear();//清空有效字符
	if (s.empty())
		cout &lt;&lt; "empty" &lt;&lt; endl;//empty
}</code></pre>
</blockquote>
<hr/>
<h3 id="%E8%BF%AD%E4%BB%A3%E5%99%A8">迭代器</h3>
<blockquote>
<p>迭代器就是像<span style="color:#956fe7;">指针</span>一样的东西 </p>
<table border="3" cellpadding="1" cellspacing="1" style="width:534px;"><tbody><tr><td style="width:95px;"><span style="color:#0d0016;"><strong>函数名称</strong></span></td><td style="width:430px;"><span style="color:#0d0016;"><strong>功能说明</strong></span></td></tr><tr><td style="width:95px;"><span style="color:#0d0016;">1、</span><span style="color:#956fe7;">begin</span></td><td style="width:430px;"> <p>将迭代器返回到开头</p> </td></tr><tr><td style="width:95px;"><span style="color:#0d0016;">2、</span><span style="color:#956fe7;">end</span></td><td style="width:430px;">将迭代器返回到末尾</td></tr><tr><td style="width:95px;"><span style="color:#0d0016;">3、</span><span style="color:#956fe7;">rbegin</span></td><td style="width:430px;">返回一个<span style="color:#fe2c24;">逆序</span>迭代器，它指向容器c的最后一个元素</td></tr><tr><td style="width:95px;"><span style="color:#0d0016;">4、</span><span style="color:#956fe7;">rend</span></td><td style="width:430px;">返回一个<span style="color:#fe2c24;">逆序</span>迭代器，它指向容器c的第一个元素前面的位置</td></tr></tbody></table>
<ul><li><strong>1、<span style="color:#956fe7;">begin</span></strong></li></ul>
<p><img alt="" height="160" src="image\c581597ab3e143f790158434a29ab3d9.png" width="626"/></p>
<ul><li><strong>2、<span style="color:#956fe7;">e</span></strong><span style="color:#956fe7;"><strong>nd</strong></span></li></ul>
<p><img alt="" height="208" src="image\b2f3f1f631ab4544b9967192c8b38c91.png" width="698"/></p>
<p> <span style="color:#0d0016;"><strong>示例如下：</strong></span></p>
<pre><code class="language-cpp">void test_string3()
{
    string s1("hello");
	string::iterator it = s1.begin();
	while (it != s1.end())
	{
		cout &lt;&lt; *it &lt;&lt; " ";//h e l l o
		it++;
	}
}</code></pre>
<p><img alt="" height="120" src="image\930d760eb9a44d0c9a27657e3a9cf246.png" width="582"/></p>
<ul><li><strong>3、<span style="color:#956fe7;">rbegin</span></strong></li></ul>
<p>rbegin是一种<span style="color:#fe2c24;">逆向迭代器</span></p>
<p><img alt="" height="92" src="image\42bbe3ac64d1440eaf9d550403614d48.png" width="623"/></p>
<p> <span style="color:#0d0016;"><strong>rbegin的特性如下：</strong></span></p>
<ol><li>返回指向字符串最后一个字符（即其反向开头）的反向迭代器。</li><li>反向迭代器向后迭代：<span style="color:#956fe7;">增加它们会将它们移动到字符串的开头</span>。</li><li>rbegin 指向成员末尾将指向的字符之前的字符。</li></ol>
<p>要留心反向迭代器的++是往反方向走，区别于正向迭代器，而其根本原因等后续讲到模拟实现再深究。</p>
<ul><li><strong>4、<span style="color:#956fe7;">rend</span></strong></li></ul>
<p><img alt="" height="92" src="image\16e685fecb75460ead808e93087f5a20.png" width="578"/></p>
<p> <span style="color:#0d0016;"><strong>rend的特性如下：</strong></span></p>
<ol><li>返回一个反向迭代器，该迭代器指向字符串的<span style="color:#956fe7;">第一个字符（被视为其反向结尾）前面的理论元素</span>。</li><li>string:：rbegin 和 string:：rend 之间的范围包含字符串的所有字符（顺序相反）。</li></ol>
<p><img alt="" height="110" src="image\00d7054c8bdd4dcea79fee9ba7db164a.png" width="562"/></p>
<ul><li><strong>5、<span style="color:#956fe7;">const正向迭代器</span></strong></li></ul>
<p>普通迭代器是可读可写的，因此针对const修饰的特殊情况下我们不能如下操作：</p>
<p><img alt="" height="400" src="image\7e41222d2ad347e18fbb809d11f9bfd4.png" width="893"/></p>
<p>因为我Func里的s是const修饰的，而Func里的迭代器又是可读可写的版本，属于权限放大，因此要进行修正：</p>
<pre><code class="language-cpp">//const正向迭代器
void Func(const string&amp; s)
{
    //记得加上const_，使其对于const的函数
	string::const_iterator it = s.begin(); 
    /*
    或者使用auto自动推导类型
    auto it = s.begin();
	*/
	while (it != s.end())
	{
        //*it += 1; 不能写
		cout &lt;&lt; *it &lt;&lt; " ";
		it++;
	}
}</code></pre>
<ul><li><strong>6、<span style="color:#956fe7;">const反向迭代器</span></strong></li></ul>
<pre><code class="language-cpp">//const反向迭代器
void Func(const string&amp; s)
{
	string::const_reverse_iterator rit = s.rbegin();
    /*
    或者使用auto自动推导类型
    auto rit = s.rbegin();
	*/
    while (rit != s.rend())
	{
        //*rit += 1; 不能写
		cout &lt;&lt; *rit &lt;&lt; " ";
		++rit;
	}
}</code></pre>
</blockquote>
<hr/>
<h3 id="string%E7%B1%BB%E7%9A%84%E5%85%83%E7%B4%A0%E8%AE%BF%E9%97%AE">string类的元素访问</h3>
<blockquote>
<table border="3" cellpadding="1" cellspacing="1" style="width:552px;"><tbody><tr><td style="width:250px;"><span style="color:#0d0016;"><strong>函数名称</strong></span></td><td style="width:292px;"><span style="color:#0d0016;"><strong>功能说明</strong></span></td></tr><tr><td style="width:250px;"><span style="color:#0d0016;">1、</span><span style="color:#956fe7;">operator[ ]</span></td><td style="width:292px;">获取字符串的字符</td></tr><tr><td style="width:250px;"><span style="color:#0d0016;">2、</span><span style="color:#956fe7;">at</span></td><td style="width:292px;">获取字符串中的字符</td></tr></tbody></table>
<ul><li><strong>1、<span style="color:#956fe7;">operator[ ]</span></strong></li></ul>
<p><img alt="" height="117" src="image\df80206a72354450b8e4a19abe97265e.png" width="590"/></p>
<p>operator[ ] 是获取字符串中的字符。实际的场景如下：</p>
<pre><code class="language-cpp">void test_string_4()
{
	string s1("hello");
	const string s2("world");
	s1[0] = 'x';
	s2[0] = 'y'; //err
}</code></pre>
<p>因为s2是const修饰的，只读，所以不能修改，自然s2[0]就会出错，而s1可读可写。</p>
<ul><li><strong>2、<span style="color:#956fe7;">at</span></strong></li></ul>
<p><img alt="" height="166" src="image\d2a464b7c4f04768a815b1c1e11fbe9f.png" width="1064"/></p>
<p> at和operator[ ]的功能一样，都是访问pos位置的字符。</p>
<pre><code class="language-cpp">void test_string_4()
{
	string s1("hello");
	s1[0] = 'x';
    //等价于
	s1.at(0) = 'x';
}</code></pre>
<ul><li><strong>3、<span style="color:#956fe7;">at和operator[ ]对比：</span></strong></li></ul>
<p>虽然at和[ ]的功能一致，但还是有差异的，at和[ ]在处理<span style="color:#956fe7;">越界</span>的情况是不同的：</p>
<p><span style="color:#fe2c24;"><strong>operator[ ]：</strong></span></p>
<p><img alt="" height="189" src="image\4588595a597d408ba111c03037debe18.png" width="1200"/></p>
<ol><li>如果 pos 小于字符串长度，则该函数永远不会引发异常（无抛出保证）。</li><li>如果 pos 等于字符串长度，则 const 版本永远不会引发异常（无 throw 保证）。</li><li>否则，它会导致未定义的行为。</li><li>请注意，使用返回的引用来修改超出界限的元素（包括 pos 处的字符）也会导致未定义的行为。</li></ol>
<p>这里[ ]越界是通过<span style="color:#956fe7;">断言</span>来报错的：</p>
<p><img alt="" height="436" src="image\72cdeaf355fb452da6d36c3ece9f6b92.png" width="901"/></p>
<p><span style="color:#fe2c24;"><strong>at：</strong></span></p>
<p><img alt="" height="145" src="image\e06b26b7cec84d3aa70264c0ac086cfa.png" width="970"/></p>
<ol><li>强保证：如果抛出异常，字符串中没有变化。</li><li>如果 pos 不小于字符串长度，则会引发out_of_range异常。</li></ol>
<p><img alt="" height="274" src="image\ae344ff5dbf7405498b31120e0b90390.png" width="862"/></p>
<p><img alt="" height="48" src="image\8166293eece74b55baae5e49407bd1e8.png" width="1163"/></p>
<p> 这里简单演示下捕获异常的场景：</p>
<p><img alt="" height="420" src="image\54ccfbc5522e4b0da2eb013d41a59be3.png" width="892"/></p>
</blockquote>
<hr/>
<h3 id="string%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%81%8D%E5%8E%86%E6%93%8D%E4%BD%9C">string类对象的遍历操作</h3>
<blockquote>
<table border="3" cellpadding="1" cellspacing="1" style="width:645px;"><tbody><tr><td style="width:167px;"><strong>函数名称</strong></td><td style="width:466px;"><strong>功能说明</strong></td></tr><tr><td style="width:167px;"><span style="color:#494949;">1、</span><span style="color:#956fe7;">operator[ ] </span><span style="color:#494949;">（重点）</span></td><td style="width:466px;">返回pos位置的字符，const string类对象调用</td></tr><tr><td style="width:167px;"><span style="color:#494949;">2、</span><span style="color:#956fe7;">begin + end</span></td><td style="width:466px;">begin获取一个字符的迭代器 + end获取最后一个字符下一个位置的迭代器</td></tr><tr><td style="width:167px;"><span style="color:#494949;">3、</span><span style="color:#956fe7;">rbegin + rend</span></td><td style="width:466px;">begin获取一个字符的迭代器 + end获取最后一个字符下一个位置的迭代器</td></tr><tr><td style="width:167px;">4、范围for</td><td style="width:466px;">C++11支持更简洁的范围for的新遍历方式</td></tr></tbody></table>
<ul><li><strong>法1：<span style="color:#956fe7;">operator[ ] </span></strong></li></ul>
<p>有了[ ]的运算符重载，我们就可以实现像C语言一样的下标+[ ]去访问。</p>
<pre><code class="language-cpp">void test_string3()
{
    //法一：//下标+[]
	string s1("hello");
	for (size_t i = 0; i &lt; s1.size(); i++)
	{
		//s1.operator[](i);
		cout &lt;&lt; s1[i] &lt;&lt; " "; //h e l l o
	}
}</code></pre>
<ul><li><strong>法2：<span style="color:#956fe7;">正向迭代器 begin + end</span></strong></li></ul>
<pre><code class="language-cpp">void test_string3()
{
	//法二：正向迭代器
    string s1("hello");
	string::iterator it = s1.begin();
	while (it != s1.end())
	{
		cout &lt;&lt; *it &lt;&lt; " ";//h e l l o
		it++;
	}
}</code></pre>
<p><img alt="" height="120" src="image\930d760eb9a44d0c9a27657e3a9cf246.png" width="582"/></p>
<ul><li><strong>法3：<span style="color:#956fe7;">反向迭代器 rbegin + rend</span></strong></li></ul>
<pre><code class="language-cpp">void test_string3()
{
    //法三：反向迭代器
	string s1("hello");
	string::reverse_iterator rit = s1.rbegin();
	while (rit != s1.rend())
	{
		cout &lt;&lt; *rit &lt;&lt; " ";//o l l e h
		++rit;
	}
}</code></pre>
<p><img alt="" height="110" src="image\00d7054c8bdd4dcea79fee9ba7db164a.png" width="562"/></p>
<ul><li><strong>法4：<span style="color:#956fe7;">范围for</span></strong></li></ul>
<pre><code class="language-cpp">void test_string3()
{
    //法4：范围for
	string s1("hello");
	for (auto ch : s1)//auto自动取s1里的字符，自动++
	{
		cout &lt;&lt; ch &lt;&lt; " "; 
	}
	cout &lt;&lt; endl;
}</code></pre>
<p>范围for可以自动帮助我们实现这一整套循环，看着十分便捷。不过范围for的本质其实还是利用迭代器的原理。这里大家可以通过查看反汇编得知。</p>
</blockquote>
<hr/>
<h3 id="string%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BF%AE%E6%94%B9%E6%93%8D%E4%BD%9C">string类对象的修改操作</h3>
<blockquote>
<table border="3" cellpadding="1" cellspacing="1" style="width:542px;"><tbody><tr><td style="width:129px;"><span style="color:#0d0016;"><strong>函数名称</strong></span></td><td style="width:410px;"><span style="color:#0d0016;"><strong>功能说明</strong></span></td></tr><tr><td style="width:129px;"><span style="color:#0d0016;">1、</span><span style="color:#956fe7;">push_back</span></td><td style="width:410px;">在字符串后尾插字符c</td></tr><tr><td style="width:129px;"><span style="color:#0d0016;">2、</span><span style="color:#956fe7;">insert</span></td><td style="width:410px;">指定位置插入</td></tr><tr><td style="width:129px;"><span style="color:#0d0016;">3、</span><span style="color:#956fe7;">append</span></td><td style="width:410px;">在字符串后追加一个字符串</td></tr><tr><td style="width:129px;"><span style="color:#0d0016;">4、</span><span style="color:#956fe7;">operator+=</span></td><td style="width:410px;">在字符串后追加字符串str</td></tr><tr><td style="width:129px;"><span style="color:#0d0016;">5、</span><span style="color:#956fe7;">erase</span></td><td style="width:410px;">删除字符或字符串</td></tr><tr><td style="width:129px;"><span style="color:#0d0016;">6、</span><span style="color:#956fe7;">swap</span></td><td style="width:410px;">交换</td></tr><tr><td style="width:129px;"><span style="color:#0d0016;">7、</span><span style="color:#956fe7;">c_str</span></td><td style="width:410px;">返回C格式字符串</td></tr><tr><td style="width:129px;"><span style="color:#0d0016;">8、</span><span style="color:#956fe7;">find</span></td><td style="width:410px;">从字符串pos位置开始往后找字符C，返回该字符的位置</td></tr><tr><td style="width:129px;"><span style="color:#0d0016;">9、</span><span style="color:#956fe7;">substr</span></td><td style="width:410px;">在str中从pos位置开始，截取n个字符，然后返回</td></tr><tr><td style="width:129px;"><span style="color:#0d0016;">10、</span><span style="color:#956fe7;">rfind</span></td><td style="width:410px;">从字符串pos位置开始往前找字符C，返回该字符的位置</td></tr></tbody></table>
<ul><li><strong><span style="color:#0d0016;">1、</span></strong><span style="color:#956fe7;">push_back</span> 尾插字符</li></ul>
<pre><code class="language-cpp">void push_back (char c);</code></pre>
<p><span style="color:#0d0016;"><strong>作用：</strong>将字符 <em>c</em> 追加到<a href="https://cplusplus.com/string" title="字符串">字符串</a>的末尾，使其<a href="https://cplusplus.com/string::length" title="长度">长度</a>增加 1。 </span></p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
int main()
{
	string str("word");
	cout &lt;&lt; str &lt;&lt; endl; //world
	str.push_back('s');
	cout &lt;&lt; str &lt;&lt; endl; //worlds
}</code></pre>
<ul><li><strong><span style="color:#0d0016;">2、</span></strong><span style="color:#956fe7;">insert </span>指定位置插入</li></ul>
<p><img alt="" height="284" src="image\3af6be9a025a48ddb13bcd692c1b4e82.png" width="1016"/></p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
int main()
{
	string str("hello world");
	//头部插入一个字符：
	str.insert(0, 1, 'x'); 
	cout &lt;&lt; str &lt;&lt; endl; //xhello world
	//使用迭代器头插：
	str.insert(str.begin(), 1, 'y');
	cout &lt;&lt; str &lt;&lt; endl; //yxhello world
	//在第n个位置插入字符：
	str.insert(3, 1, 'x');
	cout &lt;&lt; str &lt;&lt; endl; //yxhxello world
	str.insert(str.begin() + 3, 1, 'k');
	cout &lt;&lt; str &lt;&lt; endl; //yxhkxello world
	//头插一个字符串：
	str.insert(0, "!!!!");
	cout &lt;&lt; str &lt;&lt; endl; //!!!!yxhkxello world
}</code></pre>
<ul><li><strong> 3、</strong><span style="color:#956fe7;">append </span>追加字符串</li></ul>
<p><img alt="" height="235" src="image\d66973d1ca884194b0c7aa3d1eaff2d0.png" width="1139"/></p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
int main()
{
	string s1("hello");
	string s2(" every");
	//追加一个string对象
	s1.append(s2);
	cout &lt;&lt; s1 &lt;&lt; endl; //hello every
	//追加一个常量字符串
	s1.append("body");
	cout &lt;&lt; s1 &lt;&lt; endl; //hello everybody
	//用n个字符拼接
	s1.append(3, '!');
	cout &lt;&lt; s1 &lt;&lt; endl; //hello everybody!!!
}</code></pre>
<ul><li><strong><span style="color:#0d0016;">4</span>、</strong><span style="color:#956fe7;">operator+=</span></li></ul>
<p><img alt="" height="131" src="image\45cdbf4094b14a6c924c17ebf0f47685.png" width="764"/></p>
<p><span style="color:#0d0016;"><strong>作用：</strong>通过在字符串的当前值末尾追加其他字符来扩展<span style="color:#0d0016;"><a href="https://cplusplus.com/string" title="字符串">字符串</a></span></span></p>
<p><strong><span style="color:#0d0016;">参数含义：</span></strong></p>
<ol><li><span style="color:#fe2c24;">str</span>：一个<a href="https://cplusplus.com/string" title="字符串">字符串</a>对象，其值在末尾复制。</li><li><span style="color:#fe2c24;">s</span>：指向以空值终止的字符序列的指针。序列在字符串的末尾复制。</li><li><span style="color:#fe2c24;">c</span>：一个字符，追加到字符串的当前值。</li></ol>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
int main()
{
	string str("hello");
	str += ' ';
	str += "world";
	cout &lt;&lt; str &lt;&lt; endl; //hello world
	string ptr = "!!!!";
	str += ptr;
	cout &lt;&lt; str &lt;&lt; endl; //hello world!!!!
}</code></pre>
<ul><li><strong><span style="color:#0d0016;">5、</span></strong><span style="color:#956fe7;">erase </span>删除</li></ul>
<p><img alt="" height="134" src="image\740d20c841484d238b3c13e00c431bf0.png" width="853"/></p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
int main()
{
	string str("hello world");
	//头删
	str.erase(str.begin());
	cout &lt;&lt; str &lt;&lt; endl; //ello world
	//头删指定字符：
	str.erase(str.begin() + 3);
	cout &lt;&lt; str &lt;&lt; endl; //ell world
	//从pos处位置删除n个字符：
	str.erase(2, 3);
	cout &lt;&lt; str &lt;&lt; endl; //elorld
	//利用缺省值，只给定删除的位置，往后全删：
	str.erase(2);
	cout &lt;&lt; str &lt;&lt; endl; //el
	str.erase(0);
	cout &lt;&lt; str &lt;&lt; endl; //空
}</code></pre>
<ul><li><strong>6、</strong><span style="color:#956fe7;">swap </span>交换：</li></ul>
<pre><code class="language-cpp">void swap (string&amp; str);</code></pre>
<p><span style="color:#0d0016;"><strong>注意：</strong></span></p>
<ol><li>通过 <em>str</em>（另一个<a href="https://cplusplus.com/string" title="字符串">字符串</a>对象）的内容交换容器的内容。<a href="https://cplusplus.com/string::length" title="长度">长度</a>可能不同。</li><li>调用此成员函数后，此对象的值是<em>调用前 str</em> 的值，<em>str</em> 的值是调用前此对象具有的值。</li><li>请注意，存在一个具有相同名称的非成员函数，<a href="https://cplusplus.com/string:swap" title="swap">swap</a>，使用与此成员函数类似的优化重载该算法。</li></ol>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
int main()
{
	string s1("hello world");
	string s2("HELLO WORLD");
	s1.swap(s2); //库里的swap 效率高 本质：交换指针
	swap(s1, s2);//全局的swap 效率低 本质：深拷贝
}</code></pre>
<ul><li><strong>7、</strong><span style="color:#956fe7;">c_str</span> 返回C格式字符串​​​​​​​</li></ul>
<p><img alt="" height="190" src="image\32bf1d762e5a427e9233684d89806fa9.png" width="918"/></p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
int main()
{
	string s1("hello");
	cout &lt;&lt; s1 &lt;&lt; endl; //hello
	cout &lt;&lt; s1.c_str() &lt;&lt; endl;//hello
}</code></pre>
<ul><li><strong>8、</strong><span style="color:#956fe7;">find</span></li></ul>
<p><img alt="" height="159" src="image\b053182ad6cb46838006b4eeb66a2042.png" width="916"/></p>
<p><strong><span style="color:#0d0016;">参数含义：</span></strong></p>
<ol><li><span style="color:#fe2c24;"><strong>str</strong></span>：另一个包含要搜索的主题的<a href="https://cplusplus.com/string" title="字符串">字符串</a>。</li><li><span style="color:#fe2c24;"><strong>pos</strong></span>：要在搜索中考虑的字符串中第一个字符的位置。如果此<a href="https://cplusplus.com/string::length" title="值大于字符串长度">值大于字符串长度</a>，则该函数永远不会找到匹配项。注意：第一个字符由值 0（而不是 1）表示：值为 0 表示搜索整个字符串。</li><li><span style="color:#fe2c24;"><strong>s</strong></span>：指向字符数组的指针。如果指定了参数 <em>n</em> <em>（3），</em>则要匹配的序列是数组中的前 <em>n</em> 个字符。否则<em>（2）</em>，则期望以空终止的序列：要匹配的序列的长度由空字符的第一次出现确定。</li><li><span style="color:#fe2c24;"><strong>n</strong></span>：要匹配的字符序列的长度。</li><li><span style="color:#fe2c24;"><strong>c</strong></span>：要搜索的单个字符。</li></ol>
<p><span style="color:#0d0016;"><strong>返回值含义：</strong></span></p>
<ol><li>第一个匹配项的第一个字符的位置。如果未找到匹配项，则该函数返回<a href="https://cplusplus.com/string::npos" title="字符串：：npos">字符串：：npos</a>。</li></ol>
<p><span style="color:#0d0016;"><strong> 示例：</strong></span></p>
<pre><code class="language-cpp">int main()
{
	
	string s1("https://blog.csdn.net/");
	string s2("blog");
	//正向搜索string类对象
	size_t pos1 = s1.find(s2);
	cout &lt;&lt; pos1 &lt;&lt; endl; //8
	//搜索字符
	size_t pos2 = s1.find('.');
	cout &lt;&lt; pos2 &lt;&lt; endl; //12
}</code></pre>
<ul><li><strong><span style="color:#0d0016;">9、</span></strong><span style="color:#956fe7;">substr</span>：</li></ul>
<p><img alt="" height="151" src="image\b495cad698eb4304beecddeb7e6ae845.png" width="923"/></p>
<p><span style="color:#0d0016;"><strong>参数含义：</strong></span></p>
<ol><li><span style="color:#fe2c24;"><strong>pos</strong></span><span style="color:#0d0016;">：</span>要作为子字符串复制的第一个字符的位置。如果此<em><a href="https://cplusplus.com/string::length" title="值等于字符串长度">值等于字符串长度</a></em>，则该函数返回空字符串。如果此值大于<em><a href="https://cplusplus.com/string::length" title="字符串长度">字符串长度</a></em>，则会抛出<a href="https://cplusplus.com/out_of_range" title="out_of_range">out_of_range</a>。注： 第一个字符由值 0（而不是 1）表示。</li><li><span style="color:#fe2c24;"><strong>len</strong></span>：要包含在子字符串中的字符数（如果字符串较短，则使用尽可能多的字符）。值 string：：npos表示在字符串末尾之前的所有字符。</li></ol>
<p><span style="color:#0d0016;"><strong>返回值：</strong>具有此对象的子字符串的<a href="https://cplusplus.com/string" title="字符串">字符串</a>对象。</span></p>
<pre><code class="language-cpp">int main()
{
	//要求取出文件的后缀
	string file("string.cpp.tar.zip");
	size_t pos = file.find('.');
	if (pos != string::npos)
	{
		//string suffix = file.substr(pos, file.size() - pos);
		string suffix = file.substr(pos);
		cout &lt;&lt; file &lt;&lt; "后缀：" &lt;&lt; suffix &lt;&lt; endl; //string.cpp.tar.zip后缀：.cpp.tar.zip
	}
	else
	{
		cout &lt;&lt; "没有后缀" &lt;&lt; endl;
	}
}
</code></pre>
<p>如果我要取出最后一个后缀<span style="color:#956fe7;">.zip</span>就需要用到<span style="color:#956fe7;">rfind</span>来完成：</p>
<ul><li><strong><span style="color:#0d0016;">10、</span></strong><span style="color:#956fe7;">rfind</span>：</li></ul>
<p><img alt="" height="271" src="image\b6182742390243f59cfd31d59960b4c5.png" width="927"/></p>
<p><strong><span style="color:#0d0016;">参数含义：</span></strong></p>
<ol><li><span style="color:#fe2c24;"><strong>str</strong></span>：另一个包含要搜索的主题的<a href="https://cplusplus.com/string" title="字符串">字符串</a>。</li><li><span style="color:#fe2c24;"><strong>pos</strong></span>：字符串中最后一个字符的位置，将被视为匹配的开始。任何大于或等于<a href="https://cplusplus.com/string::length" title="字符串长度">字符串长度</a>的值（包括<a href="https://cplusplus.com/string::npos" title="字符串：：npos">字符串：：npos</a>）都意味着将搜索整个字符串。注： 第一个字符由值 0（而不是 1）表示。</li><li><span style="color:#fe2c24;"><strong>s</strong></span>：指向字符数组的指针。如果指定了参数 <em>n</em> <em>（3），</em>则要匹配的序列是数组中的前 <em>n</em> 个字符。否则<em>（2）</em>，则期望以空终止的序列：要匹配的序列的长度由空字符的第一次出现确定。</li><li><span style="color:#fe2c24;"><strong>n</strong></span>：要匹配的字符序列的长度。</li><li><span style="color:#fe2c24;"><strong>c</strong></span>：要搜索的单个字符。</li></ol>
<p><strong><span style="color:#0d0016;">示例：</span></strong></p>
<pre><code class="language-cpp">int main()
{
	//要求取出文件的后缀
	string file("string.cpp.tar.zip");
	size_t pos = file.rfind('.');
	if (pos != string::npos)
	{
		//string suffix = file.substr(pos, file.size() - pos);
		string suffix = file.substr(pos);
		cout &lt;&lt; file &lt;&lt; "后缀：" &lt;&lt; suffix &lt;&lt; endl; //string.cpp.tar.zip后缀：.zip
	}
	else
	{
		cout &lt;&lt; "没有后缀" &lt;&lt; endl;
	}
}</code></pre>
<pre><code class="language-cpp">int main()
{
	//取出url的域名
	string url1("https://cplusplus.com/reference/string/string/rfind/");
	string url2("https://blog.csdn.net/bit_zyx?spm=1000.2115.3001.5343");
	//协议 域名 uri
	string&amp; url = url1;
	//取协议
	string protocol;
	size_t pos1 = url.find("://");
	if (pos1 != string::npos)
	{

		protocol = url.substr(0, pos1);
		cout &lt;&lt; "protocol:" &lt;&lt; protocol &lt;&lt; endl; //https
	}
	else
	{
		cout &lt;&lt; "非法url" &lt;&lt; endl;
	}
	//取域名
	string domain; 
	size_t pos2 = url.find('/', pos1 + 3);
	if (pos2 != string::npos)
	{
		domain = url.substr(pos1 + 3, pos2 - (pos1 + 3));
		cout &lt;&lt; "domain:" &lt;&lt; domain &lt;&lt; endl; //domain:cplusplus.com
	}
	//取uri
	string uri = url.substr(pos2 + 1);
	cout &lt;&lt; "uri:" &lt;&lt; uri &lt;&lt; endl;//uri:reference/string/string/rfind/
}
</code></pre>
</blockquote>
<hr/>
<h3 id="2.2%E3%80%81sring%E7%B1%BB%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0">2.2、sring类非成员函数</h3>
<blockquote>
<table border="3" cellpadding="1" cellspacing="1" style="width:522px;"><tbody><tr><td style="width:186px;"><span style="color:#0d0016;"><strong>函数</strong></span></td><td style="width:333px;"><span style="color:#0d0016;"><strong>功能说明</strong></span></td></tr><tr><td style="width:186px;"> <p><span style="color:#0d0016;">1、</span><span style="color:#956fe7;">operator+</span></p> </td><td style="width:333px;">尽量少用，因为传值返回，导致深拷贝效率低</td></tr><tr><td style="width:186px;"><span style="color:#0d0016;">2、</span><span style="color:#956fe7;">operator&gt;&gt;</span></td><td style="width:333px;">输入运算符重载</td></tr><tr><td style="width:186px;"><span style="color:#0d0016;">3、</span><span style="color:#956fe7;">operator&lt;&lt;</span></td><td style="width:333px;">输出运算符重载</td></tr><tr><td style="width:186px;"><span style="color:#0d0016;">4、</span><span style="color:#956fe7;">relational operators</span></td><td style="width:333px;">大小比较</td></tr><tr><td style="width:186px;"><span style="color:#0d0016;">5、</span><span style="color:#956fe7;">getline</span></td><td style="width:333px;">获取一行字符串</td></tr></tbody></table>
<ul><li>1、<span style="color:#956fe7;">operator+</span></li></ul>
<p><img alt="" height="173" src="image\4dcf3315d472454893cc5f346d2553f1.png" width="861"/></p>
<pre><code class="language-cpp">int main()
{
	string s1("hello");
	string s2(" world");
	//1、string类 + string类
	string s3 = s1 + s2;
	cout &lt;&lt; s3 &lt;&lt; endl; //hello world
	//2、string类 + 字符
	s3 = s1 + '!';
	cout &lt;&lt; s3 &lt;&lt; endl; //hello!
	//3、字符 + string类
	s3 = '!' + s2;
	cout &lt;&lt; s3 &lt;&lt; endl; //! world
	//4、string类 + 字符串
	s3 = s1 + "CSDN";
	cout &lt;&lt; s3 &lt;&lt; endl; //helloCSDN
	//5、字符串 + string类
	s3 = "!!!" + s2;
	cout &lt;&lt; s3 &lt;&lt; endl; //!!! world
}</code></pre>
<ul><li>2、<span style="color:#956fe7;">operator&gt;&gt;</span> / <span style="color:#956fe7;">operator&lt;&lt;</span></li></ul>
<pre><code class="language-cpp">istream&amp; operator&gt;&gt; (istream&amp; is, string&amp; str);
ostream&amp; operator&lt;&lt; (ostream&amp; os, const string&amp; str);</code></pre>
<pre><code class="language-cpp">int main()
{
	string str;
	cin &gt;&gt; str; //hello world
	cout &lt;&lt; str &lt;&lt; endl; //hello
}</code></pre>
<ul><li>3、<span style="color:#956fe7;">relational operators</span></li></ul>
<p>string类对 ==、!=、&lt;、&lt;=、&gt;、&gt;=这些运算符进行了重载，并且支持string类和string类，string类和字符串间的比较，使用效果如下：</p>
<pre><code class="language-cpp">int main()
{
	string s1("abcd");
	string s2("efgh");
	cout &lt;&lt; (s1 &gt; s2) &lt;&lt; endl;//0
	cout &lt;&lt; (s1 &lt; s2) &lt;&lt; endl;//1
	cout &lt;&lt; (s1 &gt;= s2) &lt;&lt; endl;//0
	cout &lt;&lt; (s1 &lt;= s2) &lt;&lt; endl;//1
}</code></pre>
<ul><li>5、<span style="color:#956fe7;">getline</span></li></ul>
<p><img alt="" height="99" src="image\17ddae5435bc444f932be86a65f48644.png" width="723"/></p>
<div id="I_description" style="margin-left:0;">
<strong><span style="color:#000000;"><span style="background-color:#ffffff;">将行从流转换为字符串</span></span></strong>
</div>
<ol><li>从 <em>is</em> 中提取字符并将其存储到 str 中<em>，</em>直到找到分隔字符 <em>delim</em>（或换行符 '\n'，表示 <em>（2）</em>）。</li><li>如果在 <em>is 中</em>到达文件末尾，或者在输入操作期间发生其他错误，则提取也会停止。</li><li>如果找到分隔符，则会提取并丢弃它（即不存储它，下一个输入操作将在它之后开始）。</li></ol>
<pre><code class="language-cpp">int main()
{
	string s1;
	getline(cin, s1); //hello world
	cout &lt;&lt; s1 &lt;&lt; endl;//hello world
	string s2;
	getline(cin, s2, 'r'); //输入hello world
	cout &lt;&lt; s2 &lt;&lt; endl; //输出hello wo
}</code></pre>
</blockquote>
</div>
</div>