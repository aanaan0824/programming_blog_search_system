<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<p><strong>目录</strong></p>
<p style="margin-left:0px;"><a href="#C%2B%2B%E7%B1%BB">C++类和对象</a></p>
<p style="margin-left:40px;"><a href="#1.%20%E7%B1%BB%E7%9A%84%E5%BC%95%E5%85%A5">1. 类的引入</a></p>
<p style="margin-left:40px;"><a href="#C%2B%2B%E5%AF%B9%E4%BA%8Estruct%E7%9A%84%E5%8D%87%E7%BA%A7">C++对于struct的升级</a></p>
<p style="margin-left:80px;"><a href="#1.%C2%A0%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%AF%E4%BB%A5%E5%81%9A%E7%B1%BB%E5%9E%8B%C2%A0">1. 结构体可以做类型 </a></p>
<p style="margin-left:80px;"><a href="#2.%E9%87%8C%E9%9D%A2%E5%8F%AF%E4%BB%A5%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0">2.里面可以定义函数</a></p>
<p style="margin-left:40px;"><a href="#2.%20%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%C2%A0">2. 类的定义 </a></p>
<p style="margin-left:80px;"><a href="#%E7%B1%BB%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F">类的两种定义方式</a></p>
<p style="margin-left:40px;"><a href="#3.%20%E7%B1%BB%E7%9A%84%E8%AE%BF%E9%97%AE%E9%99%90%E5%AE%9A%E7%AC%A6%E5%8F%8A%E5%B0%81%E8%A3%85%C2%A0">3. 类的访问限定符及封装 </a></p>
<p style="margin-left:80px;"><a href="#3.1.%C2%A0%E8%AE%BF%E9%97%AE%E9%99%90%E5%AE%9A%E7%AC%A6">3.1. 访问限定符</a></p>
<p style="margin-left:80px;"><a href="#3.2.%C2%A0%E5%B0%81%E8%A3%85">3.2. 封装</a></p>
<p style="margin-left:40px;"><a href="#4.%20%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F">4. 类的作用域</a></p>
<p style="margin-left:40px;"><a href="#5.%20%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%C2%A0">5. 类的实例化 </a></p>
<p style="margin-left:40px;"><a href="#6.%20%E7%B1%BB%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%20%C2%A0">6. 类对象模型  </a></p>
<p style="margin-left:80px;"><a href="#6.1.%20%E8%AE%A1%E7%AE%97%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%A7%E5%B0%8F">6.1. 计算类对象的大小</a></p>
<p style="margin-left:80px;"><a href="#6.2.%20%E7%B1%BB%E7%9A%84%E5%A4%9A%E6%96%87%E4%BB%B6%E5%86%99%E6%B3%95">6.2. 类的多文件写法</a></p>
<p style="margin-left:0px;"><a href="#2.%20this%E6%8C%87%E9%92%88%20%C2%A0">2. this指针  </a></p>
<p style="margin-left:0px;"><a href="#3.%20%E7%B1%BB%E7%9A%846%E4%B8%AA%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0">3. 类的6个默认成员函数</a></p>
<p style="margin-left:40px;"><a href="#3.1.%C2%A0%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">3.1. 构造函数</a></p>
<p style="margin-left:80px;"><a href="#%E6%A6%82%E5%BF%B5">3.1.1 概念</a></p>
<p style="margin-left:80px;"><a href="#%E7%89%B9%E6%80%A7">3.1.2 特性</a></p>
<p style="margin-left:80px;"><a href="#3.1.3%C2%A0explicit%E5%85%B3%E9%94%AE%E5%AD%97">3.1.3 explicit关键字</a></p>
<p style="margin-left:80px;"><a href="#%E6%80%BB%E7%BB%93">3.1.4 总结</a></p>
<p style="margin-left:40px;"><a href="#3.2.%20%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0">3.2. 析构函数</a></p>
<p style="margin-left:80px;"><a href="#%E6%A6%82%E5%BF%B5">3.2.1 概念</a></p>
<p style="margin-left:80px;"><a href="#%E7%89%B9%E6%80%A7">3.2.2 特性</a></p>
<p style="margin-left:40px;"><a href="#3.3.%20%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0">3.3. 拷贝构造</a></p>
<p style="margin-left:80px;"><a href="#%E6%A6%82%E5%BF%B5">3.3.1 概念</a></p>
<p style="margin-left:80px;"><a href="#%E7%89%B9%E5%BE%81">3.3.2 特征</a></p>
<p style="margin-left:80px;"><a href="#3.3.3%20%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1%C2%A0%E8%B5%8B%E5%80%BC%20%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E4%BC%98%E5%8C%96">3.3.3 匿名对象 赋值 编译器的优化</a></p>
<p style="margin-left:80px;"><a href="#%E7%B2%BE%E9%A2%98%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%81%EF%BC%89">精题（重要！）</a></p>
<p style="margin-left:80px;"><a href="#%E6%80%BB%E7%BB%93">3.3.4 总结</a></p>
<p style="margin-left:40px;"><a href="#3.4.%20%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">3.4. 运算符重载</a></p>
<p style="margin-left:80px;"><a href="#%E6%A6%82%E5%BF%B5">3.4.1 概念</a></p>
<p style="margin-left:80px;"><a href="#%E6%B3%A8%E6%84%8F">3.4.2 注意</a></p>
<p style="margin-left:80px;"><a href="#%E5%85%A8%E5%B1%80%E7%9A%84operator%3D%3D">3.4.3 全局的operator==</a></p>
<p style="margin-left:80px;"><a href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E6%94%BE%E8%BF%9B%E7%B1%BB%E9%87%8C%E9%9D%A2%C2%A0">3.4.4 运算符重载放进类里面 </a></p>
<p style="margin-left:80px;"><a href="#%E5%85%A8%E5%B1%80%E5%92%8C%E7%B1%BB%E5%9F%9F%E5%90%8C%E5%90%8D%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">3.4.5 全局和类域同名运算符重载</a></p>
<p style="margin-left:80px;"><a href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%C2%A0">3.4.6 赋值运算符重载 </a></p>
<p style="margin-left:80px;"><a href="#3.4.7%20%E6%8F%90%E9%97%AE">3.4.7 提问</a></p>
<p style="margin-left:40px;"><a href="#3.5%20%26%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%20and%C2%A0const%E6%88%90%E5%91%98">3.5 &amp;运算符重载 and const成员</a></p>
<p style="margin-left:80px;"><a href="#3.5.1%C2%A0const%E4%BF%AE%E9%A5%B0%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0">3.5.1 const修饰类的成员函数</a></p>
<p style="margin-left:80px;"><a href="#3.5.2%C2%A0%E5%8F%96%E5%9C%B0%E5%9D%80%E5%8F%8Aconst%E5%8F%96%E5%9C%B0%E5%9D%80%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD%20%C2%A0">3.5.2 取地址及const取地址操作符重载  </a></p>
<p style="margin-left:0px;"><a href="#4.%20%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%20%C2%A0">4. 初始化列表  </a></p>
<p style="margin-left:0px;"><a href="#5.%20static%E6%88%90%E5%91%98%C2%A0">5. static成员 </a></p>
<p style="margin-left:40px;"><a href="#%E6%A6%82%E5%BF%B5">5.1 概念</a></p>
<p style="margin-left:40px;"><a href="#%E8%AE%BF%E9%97%AE%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0">5.2 访问成员函数</a></p>
<p style="margin-left:80px;"><a href="#1.%E5%85%B1%E6%9C%89%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0">5.2.1 共有成员函数</a></p>
<p style="margin-left:80px;"><a href="#2.static%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0">5.2.2 static成员函数</a></p>
<p style="margin-left:0px;"><a href="#6.%C2%A0C%2B%2B11%20%E7%9A%84%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B0%E7%8E%A9%E6%B3%95">6. C++11 的成员初始化新玩法</a></p>
<p style="margin-left:80px;"><a href="#%E6%A6%82%E5%BF%B5">概念</a></p>
<p style="margin-left:80px;"><a href="#%E7%A4%BA%E4%BE%8B">示例</a></p>
<p style="margin-left:0px;"><a href="#7.%C2%A0%E5%8F%8B%E5%85%83%20%C2%A0">7. 友元  </a></p>
<p style="margin-left:40px;"><a href="#7.1%C2%A0%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0">7.1 友元函数</a></p>
<p style="margin-left:40px;"><a href="#7.2%20%E6%B3%A8%E6%84%8F">7.2 注意</a></p>
<p style="margin-left:40px;"><a href="#7.3%C2%A0%E5%8F%8B%E5%85%83%E7%B1%BB">7.3 友元类</a></p>
<p style="margin-left:0px;"><a href="#8.%C2%A0%E5%86%85%E9%83%A8%E7%B1%BB">8. 内部类</a></p>
<p style="margin-left:40px;"><a href="#8.1%C2%A0%E6%A6%82%E5%BF%B5">8.1 概念</a></p>
<hr/>
<p> </p>
<blockquote>
<p><strong>C语言总结<a href="https://blog.csdn.net/weixin_62700590/article/details/122200337" title="在这">在这</a></strong><strong>常见八大排序<a href="https://blog.csdn.net/weixin_62700590/article/details/124291850" title="在这">在这</a></strong></p>
<p><strong>作者和朋友建立的社区：</strong><a href="https://bbs.csdn.net/forums/FKBZM" title="非科班转码社区-CSDN社区云">非科班转码社区-CSDN社区云</a>💖💛💙</p>
<p><img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y6f5p2lNDU=,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/fa75bcd33e2344ffbf2d1f91521a6d89.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y6f5p2lNDU=,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<p><strong>期待hxd的支持哈🎉 🎉 🎉</strong></p>
<p><strong>最后是打鸡血环节：你只管努力，剩下的交给天意</strong>🚀 🚀 🚀  </p>
</blockquote>
<h1>C++类和对象</h1>
<blockquote>
<p>首先，说到类和对象，就要先谈谈什么是面向过程，什么是面向对象了，在之前</p>
<div>
  C语言是
  <strong>面向过程</strong>的，
  <strong>关注</strong>的是
  <strong>过程</strong>，分析出求解问题的步骤，通过函数调用逐步解决问题。
 </div>
<div>
  C++是
  <strong>基于面向对象</strong>的，
  <strong>关注</strong>的是
  <strong>对象</strong>，将一件事情拆分成不同的对象，靠对象之间的交互完成。
 </div>
</blockquote>
<h2><strong>1. 类的引入</strong></h2>
<blockquote>
<div>
<strong>C</strong>
<strong>语言中，结构体中只能定义变量，在</strong>
<strong>C++</strong>
<strong>中，结构体内不仅可以定义变量，也可以定义函数。 </strong>
</div>
<div>
<img alt="e8fadc374a1e43a789180443449ee18f.png" src="https://img-blog.csdnimg.cn/e8fadc374a1e43a789180443449ee18f.png"/>
</div>
<h2><strong>C++对于struct的升级</strong></h2>
<h3><strong>1. 结构体可以做类型 </strong></h3>
<p><img alt="2789669be72746259d49658ec4630441.png" src="https://img-blog.csdnimg.cn/2789669be72746259d49658ec4630441.png"/></p>
<h3><strong>2.里面可以定义函数</strong></h3>
<p><img alt="9120b02a7df44dc79fdbf152fa29cfa5.png" src="https://img-blog.csdnimg.cn/9120b02a7df44dc79fdbf152fa29cfa5.png"/></p>
<p><img alt="49003a0da74645bdb2c632fca326f570.png" src="https://img-blog.csdnimg.cn/49003a0da74645bdb2c632fca326f570.png"/></p>
<p> </p>
<p>PS:有人可能会问了， 编译器不是从上到下编译吗，那上面遇到成员变量会不会不认识？其实在类里面你要把类当成一个<strong>整体</strong>，如果在上面遇到了不认识的，会把整个类作用域运行完再去看是否能找到哈。</p>
<p> </p>
<p> 但是上述都是为了兼容C的，其实<strong>在</strong><strong>C++</strong><strong>中更喜欢用</strong><strong>class</strong><strong>来代替。</strong></p>
<p><img alt="28a0fe7014414bf8af6105ed82e42e0e.png" src="https://img-blog.csdnimg.cn/28a0fe7014414bf8af6105ed82e42e0e.png"/></p>
</blockquote>
<h2><strong>2. 类的定义</strong> </h2>
<blockquote>
<p><img alt="94f622f18ced4f90bd86f114a051b81d.png" src="https://img-blog.csdnimg.cn/94f622f18ced4f90bd86f114a051b81d.png"/></p>
<div>
<strong>class</strong>
<strong>为</strong>定义类的
  <strong>关键字，</strong>
<strong>ClassName</strong>
<strong>为类的名字，</strong>
<strong>{}</strong>
<strong>中为类的主体，注意</strong>类定义结束时后面
  <strong>分号</strong>。
 </div>
<div>
  类中的元素称为
  <strong>类的成员：</strong>类中的
  <strong>数据</strong>称为
  <strong>类的属性</strong>或者
  <strong>成员变量</strong>; 类中的
  <strong>函数</strong>称为
  <strong>类的方法</strong>或者
  <strong>成员函数</strong>。
 </div>
<div>
   
 </div>
<h3><strong>类的两种定义方式</strong></h3>
<div>
  1. 声明和定义全部放在类体中，需要注意：成员函数如果
  <strong>在类中定义</strong>，编译器可能会将其当成
  <strong>内联函数</strong>处理。
 </div>
<p><img alt="17efaaaa4f544748843f0711900cfcd5.png" src="https://img-blog.csdnimg.cn/17efaaaa4f544748843f0711900cfcd5.png"/></p>
<p>2. 声明放在.h文件中，类的定义放在.cpp文件中 </p>
<p><img alt="51ccbfeb147a448dab3d24e5ed3ba864.png" src="https://img-blog.csdnimg.cn/51ccbfeb147a448dab3d24e5ed3ba864.png"/></p>
<p><img alt="7ad3769358e24fafb679fe0853b96afd.png" src="https://img-blog.csdnimg.cn/7ad3769358e24fafb679fe0853b96afd.png"/>如果不加上类作用域会报错不是因为成员是private，是对于访问限定符限制的是从内外直接访问，而类内是都可以直接访问的</p>
<p> </p>
<p><strong>一般情况下，更期望采用第二种方式。  </strong></p>
</blockquote>
<h2><strong>3. 类的访问限定符及封装</strong> </h2>
<h3>3.1. <strong>访问限定符</strong></h3>
<blockquote>
<p> </p>
<div>
<strong>C++实现封装的方式：</strong>
<strong>用类将对象的属性与方法结合在一块，让对象更加完善，通过访问权限选择性的将其</strong>
<strong>接口提供给外部的用户使用</strong>。
 </div>
<div>
<img alt="7c09f3bf8566410680f85a8bb5a23538.png" src="https://img-blog.csdnimg.cn/7c09f3bf8566410680f85a8bb5a23538.png"/>
</div>
<p><strong>【访问限定符说明】 </strong></p>
<div>
  1. public修饰的成员在
  <strong>类外</strong>可以直接被访问
 </div>
<div>
  2. protected和private修饰的成员在
  <strong>类外</strong>不能直接被访问(
  <strong>此处</strong>protected和private是类似的)（到继承不一样）
 </div>
<div>
  3. 访问权限
  <strong>作用域从该访问限定符出现的位置开始直到下一个访问限定符出现时为止 </strong>
</div>
<div>
  4. 
  <strong>class</strong>的
  <strong>默认访问权限</strong>为
  <strong>private</strong>，
  <strong>struct</strong>为
  <strong>public</strong>(
  <strong>因为struct要兼容</strong>
<strong>C</strong>)
 </div>
<p> </p>
<div>
<strong>C++</strong>
<strong>中</strong>
<strong>struct</strong>
<strong>和</strong>
<strong>class</strong>
<strong>的区别是什么？</strong>
</div>
<div>
  C++需要兼容C语言，所以C++中struct可以当成结构体去使用。另外C++中struct还可以用来定义类。和class是定义类是一样的，区别是struct的成员默认访问方式是public，class是的成员默认访问方式是private。
 </div>
<div>
<div>
<div>
<div>
<div>
       
     </div>
</div>
</div>
</div>
</div>
</blockquote>
<h3><strong>3.2. </strong><strong>封装 </strong></h3>
<blockquote>
<div>
  面向对象的三大特性：
  <strong>封装、继承、多态</strong>。
 </div>
<div>
   
 </div>
<div>
<div>
   那什么是封装呢？
  </div>
<div>
<div>
<strong>封装：将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行</strong>
<strong>交互。 </strong>
</div>
<div>
     
   </div>
<div>
<div>
<strong>封装本质上是一种管理</strong>：我们使用类数据和方法都封装到一起。不想给别人看到的，我们使用protected/private把
     <strong>成员</strong>
<strong>封装</strong>起来。
     <strong>开放</strong>一些共有的成员函数对成员合理的访问。所以封装本质是一种管理。
    </div>
<div>
      
    </div>
<div>
     其实就是：
    </div>
<div>
     1.数据和方法封装到一起类里面
    </div>
<div>
     2.想给你自由访问的设计为public，不想的就是pvivate和protected
    </div>
<div>
     一般情况设计类：成员数据都是私有或者保护，想访问的函数是共有的，不想给你访问的私有或者保护。
    </div>
</div>
</div>
</div>
</blockquote>
<h2><strong>4. 类的作用域</strong></h2>
<blockquote>
<p> </p>
<div>
<strong>类定义了一个新的作用域</strong>，类的所有成员都在类的作用域中
  <strong>。</strong>在类体外定义成员，需要使用 
  <strong>:: </strong>作用域解析符指明成员属于哪个类域。
 </div>
<div>
  类的作用域和之前说的命名空间域是很像的，就如也可以出现不同域的同名函数。
 </div>
</blockquote>
<h2><strong>5. 类的实例化</strong> </h2>
<blockquote>
<div>
<strong>用类类型创建对象的过程，称为类的实例化</strong>
</div>
<div>
<div>
   1. 
   <strong>类只是</strong>一个
   <strong>模型</strong>一样的东西，限定了类有哪些成员，定义出一个类
   <strong>并没有分配实际的内存空间</strong>来存储它（比如说创建了一个类，类里面有成员变量，但是因为没有开辟空间，所以是声明）
  </div>
<div>
   2. 一个类可以实例化出多个对象，
   <strong>实例化出的对象</strong>
<strong>占用实际的物理空间，存储类成员变量 </strong>
</div>
<div>
   3. 做个比方。
   <strong>类实例化出对象就像现实中使用建筑设计图建造出房子，类就像是设计图</strong>，只设计出需要什么东西，但是并没有实体的建筑存在，同样类也只是一个设计，
   <strong>实例化出的对象才能实际存储数据，占用物理空间（一个类可以实例化多个对象，就像一个图纸可以造多个房子一样）</strong>
</div>
</div>
</blockquote>
<h2><strong>6. 类对象模型 </strong> </h2>
<h3><strong>6.1. 计算类对象的大小</strong></h3>
<blockquote>
<pre><code class="language-cpp">class A {
public:
 void PrintA()
 {
     cout&lt;&lt;_a&lt;&lt;endl;
 }
private:
 char _a;
};</code></pre>
<div>
  问题：类中既可以有成员变量，又可以有成员函数，那么一个类的对象中包含了什么？如何计算一个类的大小？
 </div>
<div>
   
 </div>
<div>
<strong>那我们先要知道</strong>
<strong>类对象的存储方式</strong>
</div>
<div>
   
 </div>
<div>
  如果
  <strong>对象中包含类的各个成员</strong>
<div>
   每个对象中成员变量是不同的，但是调用同一份函数，如果按照此种方式存储，当一个类创建多个对象时，
   <strong>每个对象中都会保存一份代码，相同代码保存多次，浪费空间。那么如何解决呢？</strong>
</div>
<div>
<div>
<strong>只保存成员变量，成员函数存放在公共的代码段（网图）</strong>
</div>
<div>
<img alt="bacff33c87ab4a619662f3529d87cc92.png" src="https://img-blog.csdnimg.cn/bacff33c87ab4a619662f3529d87cc92.png"/>
</div>
<p> </p>
<p><strong>然后我们现在去计算一下看看到底怎么存储的</strong></p>
<p><strong>先补充一下前面的</strong><strong>结构体内存对齐规则 </strong><strong>：</strong></p>
<div>
    1. 第一个成员在与结构体偏移量为0的地址处。
   </div>
<div>
    2. 其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。
   </div>
<div>
<div>
     注意：对齐数 = 编译器默认的一个对齐数 与 该成员大小的较小值。
    </div>
<div>
     VS中默认的对齐数为8  （可用 #progma pack（n）来改变默认对齐数大小）
    </div>
<div>
     3. 结构体总大小为：最大对齐数（所有变量类型最大者与默认对齐参数取最小）的整数倍。
    </div>
<div>
     4. 如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍。
    </div>
</div>
<p> </p>
<p><strong>然后是测试</strong></p>
<p><img alt="d3c2263011b148578821eb48d8672e08.png" src="https://img-blog.csdnimg.cn/d3c2263011b148578821eb48d8672e08.png"/></p>
<p> </p>
<div>
<strong>结论：一个类的大小，实际就是该类中</strong>
<strong>”</strong>
<strong>成员变量</strong>
<strong>”</strong>
<strong>之和，当然也要进行内存对齐，注意空类的大小，空类比</strong>
<strong>较特殊，编译器给了空类一个字节来唯一标识这个类。（操作系统规定每一个变量或者函数都要有其占位符以证明其存在，就比如sizeof（void）=1一样）</strong>
</div>
</div>
</div>
</blockquote>
<h3>6.2. 类的多文件写法</h3>
<blockquote>
<p><strong>这里我们小写一个栈（不实现）（图有详解）</strong></p>
<p><img alt="404a8bfa040b4ce49bc32f5fc3c687eb.png" src="https://img-blog.csdnimg.cn/404a8bfa040b4ce49bc32f5fc3c687eb.png"/></p>
<p><img alt="390b47a3916c42439b502e39bb41fef9.png" src="https://img-blog.csdnimg.cn/390b47a3916c42439b502e39bb41fef9.png"/><img alt="33a5d9f2b9ac4403a47879b9f03b4333.png" src="https://img-blog.csdnimg.cn/33a5d9f2b9ac4403a47879b9f03b4333.png"/><img alt="831ff8a7042a4f21917ab671c3030c5f.png" src="https://img-blog.csdnimg.cn/831ff8a7042a4f21917ab671c3030c5f.png"/></p>
</blockquote>
<h1><strong>2. this</strong><strong>指针 </strong> </h1>
<blockquote>
<p><strong>2.1. 初识this</strong></p>
<p><img alt="e01aadd311eb4b71af55c9c684da60c1.png" src="https://img-blog.csdnimg.cn/e01aadd311eb4b71af55c9c684da60c1.png"/></p>
<p>对于上述类，有这样的一个问题：</p>
<div>
  Date类中有SetDate与Display两个成员函数，
  <strong>函数体中没有关于不同对象的区分</strong>，那当s1调用SetDate函数时，该函数是如何知道应该设置s1对象，而不是设置s2对象呢？
 </div>
<p> </p>
<div>
  C++中通过引入this指针解决该问题，即：
  <strong>C++</strong>
<strong>编译器给每个</strong>
<strong>“</strong>
<strong>非静态的成员函数</strong>
<strong>“</strong>
<strong>增加了一个隐藏的指针参</strong>
<strong>数，让该指针指向当前对象</strong>
<strong>(</strong>
<strong>函数运行时调用该函数的对象</strong>
<strong>)</strong>
<strong>，在函数体中所有成员变量的操作，都是通过该</strong>
<strong>指针去访问。只不过所有的操作对用户是透明的，即用户不需要来传递，编译器自动完成</strong>。
 </div>
<div>
   
 </div>
<div>
<strong>所以上面的程序其实是这样的</strong>
</div>
<div>
<img alt="5ebd1919db7d45659b400c1fc72b8f63.png" src="https://img-blog.csdnimg.cn/5ebd1919db7d45659b400c1fc72b8f63.png"/>
</div>
<div>
<strong>（其实Date* this还不准确，真正应该是 Date* const this）</strong>
</div>
<div>
   
 </div>
<div>
  但是其实是报错的，我们不能这样去写，但是cout里面可以直接写哈
 </div>
<div>
<strong>类里面是声明，只有对象里面才是实实在在的定义<br/> 但是我们不能直接把形参里面的this写出来，这是编译器做的事情，但是我们可以直接使用</strong>
</div>
<div>
    (实参传地址和形参接收都是
  <strong>第一个参数</strong>哈（关于this）)
 </div>
<div>
  （这里访问的并不是声明的年月日，而是
  <strong>相应对象的成员</strong>）
 </div>
<div>
   
 </div>
<div>
  2.2. 
  <strong>this</strong>
<strong>指针的特性 </strong>
</div>
<div>
<div>
   1. this指针的类型：类类型* const  
  </div>
<div>
   因为this指针是const，所以在类内不可以修改，但是this是可以在类外初始化的，就比如下面，此时this就是nullptr。（隐藏传参传的时候就直接传值，不用传地址了）
  </div>
<div>
   记住nullptr只要没有解引用，程序就不会崩溃
  </div>
<div>
   PS：空指针一定是0地址，但不一定是物理内存的0地址，是虚拟地址空间的，虚拟地址空间要最后通过页表映射到物理地址上
  </div>
<div>
<img alt="b078d314657245e38c38e8f522a6ff8d.png" src="https://img-blog.csdnimg.cn/b078d314657245e38c38e8f522a6ff8d.png"/>
</div>
<div>
<img alt="d49f773edc7647ae82dee7d729dd53a5.png" src="https://img-blog.csdnimg.cn/d49f773edc7647ae82dee7d729dd53a5.png"/>
</div>
<p><img alt="e3ac49a6b4a5449f97326b8cca5fd0e2.png" src="https://img-blog.csdnimg.cn/e3ac49a6b4a5449f97326b8cca5fd0e2.png"/></p>
<div>
   2. 只能在“成员函数”的内部使用
  </div>
<div>
   3. 
   <strong>this</strong>
<strong>指针本质上其实是一个成员函数的形参</strong>，是对象调用成员函数时，将
   <strong>对象地址</strong>作为实参传递给
   <strong>this</strong>形参。所以
   <strong>对象中不存储</strong>
<strong>this</strong>
<strong>指针</strong>。(而且我们算对象大小的时候也没有算this指针，也说明了不在对象里面，其实是存在与栈里面的，形参这些都是在栈里面)
  </div>
<div>
   当然有些编译器会进行优化把this放到寄存器里面（因为快）所以也有可能是在寄存器里面并不是push压参数
  </div>
<div>
<img alt="e6bd8cb1b6304e26bb9a4c78644d1ac6.png" src="https://img-blog.csdnimg.cn/e6bd8cb1b6304e26bb9a4c78644d1ac6.png"/>
</div>
<div>
   4. 
   <strong>this</strong>
<strong>指针是成员函数第一个隐含的指针形参，一般情况由编译器通过</strong>
<strong>ecx</strong>
<strong>寄存器自动传递，不需要用户</strong>
<strong>传递 </strong>
</div>
<p><strong>网图 </strong></p>
<div>
<img alt="f4324e49e0a54a57a104ee11083a1bb2.png" src="https://img-blog.csdnimg.cn/f4324e49e0a54a57a104ee11083a1bb2.png"/>
</div>
</div>
</blockquote>
<h1><strong>3. 类的</strong><strong>6</strong><strong>个默认成员函数</strong></h1>
<blockquote>
<div>
  如果一个类中什么成员都没有，简称为空类。空类中什么都没有吗？并不是的，任何一个类在我们不写的情况下，都会自动生成下面6个默认成员函数。
 </div>
<div>
  class Date {};
 </div>
<p><strong>网图：</strong> </p>
<div>
<img alt="f1b5e5dcf05d421ba720baa553509ef8.png" src="https://img-blog.csdnimg.cn/f1b5e5dcf05d421ba720baa553509ef8.png"/>
</div>
</blockquote>
<h2>3.1. <strong>构造函数</strong></h2>
<blockquote>
<p>如果没有构造函数，我们以往来说调用</p>
<p><img alt="d07db77935ce4f44b0dd2e5afa35e699.png" src="https://img-blog.csdnimg.cn/d07db77935ce4f44b0dd2e5afa35e699.png"/></p>
<p>我们可以Init设置对象信息，但是如果每次创建对象都调用该方法设置信息，未免有点麻烦，那能否在对象创建时，就将信息设置进去呢？</p>
<p> </p>
<h3><strong>3.1.1 概念</strong></h3>
<div>
<strong>构造函数</strong>是一个
  <strong>特殊的成员函数，名字与类名相同</strong>
<strong>,</strong>
<strong>创建类类型对象时由编译器自动调用</strong>，保证每个数据成员都有 一个合适的初始值，并且
  <strong>在对象的生命周期内只调用一次</strong>。
 </div>
<p> </p>
<h3><strong>3.1.2 特性</strong></h3>
<div>
<div>
<strong>构造函数</strong>是特殊的成员函数，需要注意的是，构造函数的虽然名称叫构造，但是需要注意的是构造函数的主要任务
   <strong>并不是开空间创建对象，而是初始化对象</strong>。
  </div>
<div>
<div>
<strong>其特征如下：</strong>
</div>
<div>
<div>
     1. 函数名与类名
     <strong>相同</strong>。
    </div>
<div>
     2. 
     <strong>无</strong>返回值
     <strong>（也不要去写void）</strong>。
    </div>
<div>
     3. 对象实例化时编译器
     <strong>自动调用</strong>对应的构造函数。
    </div>
<div>
     4. 构造函数
     <strong>可以重载</strong>。
    </div>
<div>
      
    </div>
<div>
<strong>自己实现构造函数（有参和无参）</strong>
</div>
<div>
<img alt="1f65ccf91afc435db998cee720ccb922.png" src="https://img-blog.csdnimg.cn/1f65ccf91afc435db998cee720ccb922.png"/>
</div>
<p>注意：注意这里的构造函数的调用(构造函数可以重载)</p>
<p> </p>
<div>
     如果类中没有显式定义构造函数，则C++编译器会自动生成一个无参的默认构造函数，一旦用户显式定义编译器将不再生成。
    </div>
<div>
     默认生成的就相当于上面的无参构造函数，啥也没有，但是如何有自定义成员（类），那就会默认调用自定义成员的构造函数。
    </div>
<div>
      
    </div>
<div>
<strong>无参构造函数和全缺省构造函数</strong>
</div>
<div>
<img alt="2de243e4d5ee4a34825c40cee53b8fc5.png" src="https://img-blog.csdnimg.cn/2de243e4d5ee4a34825c40cee53b8fc5.png"/>
</div>
<p><img alt="a1a8cf7f9fd942068607ad78540309d1.png" src="https://img-blog.csdnimg.cn/a1a8cf7f9fd942068607ad78540309d1.png"/></p>
<div>
<div>
<strong>无参的构造函数（1）</strong>和
      <strong>全缺省的构造函数（2）</strong>都称为
      <strong>默认构造函数</strong>，并且默认构造函数
      <strong>只能有一个（多个编译器不知道调用哪个）</strong>。注意：无参构造函数、全缺省构造函数、
      <strong>我们没写编译器默认生成的构造函数（3）</strong>，都可以认为是
      <strong>默认成员函数（不用传参就可以调用）。</strong>
</div>
<div>
       
     </div>
<div>
       
     </div>
<div>
<img alt="6137e9214cbe46ecbebcc2a2270e8392.png" src="https://img-blog.csdnimg.cn/6137e9214cbe46ecbebcc2a2270e8392.png"/>
</div>
<div>
<img alt="3f4815ea8d7f4e9085591e68a0cc382e.png" src="https://img-blog.csdnimg.cn/3f4815ea8d7f4e9085591e68a0cc382e.png"/>
</div>
<p> </p>
<div>
<strong>敲重点：在稍微老一点的编译器（VS2013）默认生成构造函数对内置类型成员变量不做处理（随机值），对于自定义类型成员变量才处理，但是作者的VS2022是处理了的，但是有警告</strong>
</div>
<div>
<strong>总结：如果有内置类型的成员，或者需要显示传参初始化，那么都要自己实现构造函数。</strong>
</div>
<div>
<strong>对于上面C++11有所补充（如下图）</strong>
</div>
<div>
<img alt="eceaa9a34230437e80c444d7b8b26594.png" src="https://img-blog.csdnimg.cn/eceaa9a34230437e80c444d7b8b26594.png"/>
<br/>  
     </div>
<div>
<strong>如果构造函数只初始化内置类型不初始化自定义类型 </strong>
</div>
<div>
      发现会调用自定义类型的默认构造函数
     </div>
<div>
<img alt="334667c0cc00449f85dfd7321bec20c2.png" src="https://img-blog.csdnimg.cn/334667c0cc00449f85dfd7321bec20c2.png"/>
</div>
<p><img alt="ac52680eed00411684113f7e017fdeb9.png" src="https://img-blog.csdnimg.cn/ac52680eed00411684113f7e017fdeb9.png"/></p>
<p>//发现会调用自定义类型的默认构造函数</p>
<p><img alt="95233e009441479cb0990c4fc8ab4708.png" src="https://img-blog.csdnimg.cn/95233e009441479cb0990c4fc8ab4708.png"/></p>
<p> //如果不写自定义类型的默认构造函数，编译器会初始化为0</p>
<p><img alt="4dc776e45f7647a183da1d4b650d1828.png" src="https://img-blog.csdnimg.cn/4dc776e45f7647a183da1d4b650d1828.png"/><img alt="2c4b29de5c42497bbb76db1f200f5beb.png" src="https://img-blog.csdnimg.cn/2c4b29de5c42497bbb76db1f200f5beb.png"/></p>
</div>
</div>
</div>
</div>
</blockquote>
<blockquote>
<h3>3.1.3 <strong>explicit</strong><strong>关键字</strong></h3>
<p>构造函数不仅可以构造与初始化对象，<strong>对于单个参数的构造函数，还具有类型转换的作用</strong>。</p>
<p> </p>
<pre><code class="language-cpp">class Date
{
public:
 Date(int year)
 :_year(year)
 {}
 
 explicit Date(int year)
 :_year(year)
 {}
 
private:
 int _year;
 int _month:
 int _day; 
}；

void TestDate()
{
 Date d1(2022);
 
 // 用一个整形变量给日期类型对象赋值
 // 实际编译器背后会用2050构造一个无名对象，最后用无名对象给d1对象进行赋值
 d1 = 2050; 
}</code></pre>
<div>
  上述代码可读性不是很好，
  <strong>用</strong>
<strong>explicit</strong>
<strong>修饰构造函数，将会禁止单参构造函数的隐式转换</strong>。
 </div>
<div>
   
 </div>
<div>
  但是有很大可能优化，会直接变成拷贝构造
 </div>
<div>
<img alt="4bcfd9fd38dc4ef0b9ba032a53ae0119.png" src="https://img-blog.csdnimg.cn/4bcfd9fd38dc4ef0b9ba032a53ae0119.png"/>
</div>
<p> </p>
<p>那编译器这样优化的意义是什么呢？ </p>
<p>是为了用在这种情况：</p>
<p><img alt="098c3e252af94003b9b656b779337336.png" src="https://img-blog.csdnimg.cn/098c3e252af94003b9b656b779337336.png"/></p>
<p><img alt="6195f7994c154ee6a41d47a28c7a9e94.png" src="https://img-blog.csdnimg.cn/6195f7994c154ee6a41d47a28c7a9e94.png"/>190 191 192 那种调用就很麻烦，而且s1的作用仅仅只是去调用又很浪费，所以193这种调用（隐式类型转换）的好处就显示出来了。 </p>
<p> </p>
<p>PS：const引用临时变量后会延迟他的生命周期</p>
</blockquote>
<blockquote>
<h3><strong>3.1.4 总结</strong></h3>
<p><strong>构造函数不写会默认生成，啥也不做。写了就不生成，一般一个C++类，都要自己写构造函数。一般只有少数情况可让编译器自动生成</strong></p>
<p><strong>1.类里面都是自定义类型成员，并且这些成员提供了默认构造函数。</strong></p>
<p><strong>2.如果还要内置类型成员，声明时给了缺省值。</strong></p>
<p> </p>
<p><strong>默认构造有三种，编译器自动生成的，无参的，全缺省的。特性就是都是不用传参编译器自己调用的。</strong></p>
<p> </p>
<p><strong>对于默认构造函数，对内置类型不处理，对与自定义类型调用他们的默认构造（没有就编译错误）就要用初始化列表（后面讲）</strong><strong>。</strong></p>
<p> </p>
<p><strong>如果自己写了构造函数，但是没有处理自定义类型，也会调用自己的默认构造函数，如果有的没有初始化，编译器也会初始化为0（VS2022），老一点的应该是不会初始化的如VS2013，就报错了，VS2022是警告。</strong></p>
</blockquote>
<h2>3.2. 析构<strong>函数</strong></h2>
<blockquote>
<h3>3.2.1 概念<strong> </strong></h3>
<div>
  与
  <strong>构造函数</strong>功能
  <strong>相反</strong>，析构函数不是完成对象的销毁，局部对象销毁工作是由编译器完成的。而
  <strong>对象在销毁时会自动调用析构函数，完成类的一些资源清理工作。</strong>
<strong>（如malloc，new）</strong>
</div>
<div>
   
 </div>
<div>
<h3><strong>3.2.2 特性</strong></h3>
<div>
<div>
<strong>析构函数</strong>是特殊的成员函数
   </div>
<div>
<div>
     1. 析构函数名是在类名前加上字符 ~。
    </div>
<div>
     2. 无参数无返回值。
    </div>
<div>
     3. 一个类有且只有一个析构函数。若未显式定义，系统会自动生成默认的析构函数（也是啥也不做）。
    </div>
<div>
     4. 对象生命周期结束时，C++编译系统系统自动调用析构函数。
    </div>
<div>
      
    </div>
<div>
     也和上面的构造函数一样，默认生成的析构函数，内置类型成员不做处理，自定义类型成员去调用他的析构函数。
    </div>
<div>
      
    </div>
<div>
     什么时候要去自己实现析构函数？
    </div>
<div>
     当自己直接对资源进行管理的时候，就要去，这个资源是堆上的，因为栈上的是编译器会去处理。如栈，就要自己去free。
    </div>
</div>
</div>
</div>
</blockquote>
<h2>3.3. 拷贝构造</h2>
<blockquote>
<h3><strong>3.3.1 概念</strong></h3>
<div>
<strong>构造函数</strong>：
  <strong>只有单个形参</strong>，该形参是对
  <strong>本</strong>
<strong>类类型对象的引用</strong>
<strong>(</strong>
<strong>一般常用</strong>
<strong>const</strong>
<strong>修饰</strong>
<strong>)</strong>，在用
  <strong>已存在的类类型对象</strong>
<strong>创建新对象时由编译器自动调用。(类里面也会自动生成浅拷贝构造函数)</strong>
</div>
<div>
<div>
    
  </div>
<h3><strong>3.3.2 特征</strong></h3>
<div>
   1. 拷贝构造函数
   <strong>是构造函数的一个重载形式</strong>。
  </div>
<div>
   2. 拷贝构造函数的
   <strong>参数只有一个</strong>且
   <strong>必须使用引用传参</strong>，使用
   <strong>传值方式会引发无穷递归调用</strong>。
  </div>
<div>
    
  </div>
<div>
<strong>我们先自己实现一个</strong>
</div>
<div>
<img alt="ca4c1354a3204a978485239ba0ae8b37.png" src="https://img-blog.csdnimg.cn/ca4c1354a3204a978485239ba0ae8b37.png"/>
</div>
<p>如果不用&amp;，就会因为调用函数就会调用拷贝构造，然后就要传参，但是传参又要拷贝构造，拷贝构造就又要传参，导致死循环，所以加上&amp;。同时拷贝构造有所规定（如果不改变拷贝就加上const，怕函数写错了） 规定内置类型是直接拷贝，自定义类型调用其拷贝构造</p>
<div>
    
  </div>
<div>
<strong>浅拷贝构造可能的问题：</strong>
</div>
<div>
   析构函数重复free，同一个空间不能释放两次。要用深拷贝（后面讲）解决，这也是为什么自定义类型要用他自己的拷贝构造完成，之后还有其他的细节
  </div>
<div>
    
  </div>
<div>
<strong>当我们没有自己去实现的时候（浅拷贝）</strong>
</div>
<div>
<img alt="dc22dcfcd49b475e899899baf12c8b53.png" src="https://img-blog.csdnimg.cn/dc22dcfcd49b475e899899baf12c8b53.png"/>
</div>
<p>我们不写编译器会<strong>自动生成</strong>一个，但是是<strong>浅拷贝</strong>（就像memcopy一样），但是由于都是值拷贝（浅拷贝），对于有动态开辟像栈这样的内置类型的成员，就会出现浅拷贝的问题（free两次并且公用一块空间）要用<strong>深拷贝去解决</strong>（后面讲）</p>
<p><br/> 那要是有<strong>数组</strong>可以吗，其实是<strong>可以</strong>的，虽然也是浅拷贝，浅拷贝就是单纯去拷贝数据。如果成员是int，int a[10]，其实都可以认为是拷贝拷贝的空间和里面的数据，是开辟在不一样地方的（而且是在栈区）。拷贝int*这样指针其实也是拷贝数据，只不过里面的数据是地址，所以拷贝的时候就会两个指针指向同一块空间（堆区），free的时候就会free两次同一块空间。</p>
<p> </p>
<p><strong>拷贝构造只有自己直接管理资源的时候（像栈）才需要自己去写，自己实现深拷贝！</strong></p>
<p> </p>
<p> </p>
<h3><strong>3.3.3 匿名对象 </strong>赋值 编译器的优化</h3>
<p><strong>匿名对象</strong></p>
<p><img alt="a38f53aa39c244a88bf14a5b40017fef.png" src="https://img-blog.csdnimg.cn/a38f53aa39c244a88bf14a5b40017fef.png"/></p>
<p><strong>用法</strong></p>
<p><img alt="db0bf0fcafdc48e29e754bd58e5969c7.png" src="https://img-blog.csdnimg.cn/db0bf0fcafdc48e29e754bd58e5969c7.png"/></p>
<p>下面那种明显比上面那个简介（如果生成对象只是为了传参的话就可以这么用）</p>
<p> </p>
<p>PS：用一个已经存在的去初始化一个创建的对象，是<strong>拷贝构造</strong></p>
<p><img alt="998509697928471aaab4c5d561e2531f.png" src="https://img-blog.csdnimg.cn/998509697928471aaab4c5d561e2531f.png"/></p>
<p> </p>
<p><strong>编译器的优化（比较激进的编译器如VS）</strong></p>
<p>1. 在连续的构造，拷贝构造在一起，直接优化成构造（下面这个A只有一个成员变量）</p>
<p><img alt="cf8edb61cb3543fc883e98940e1ce78e.png" src="https://img-blog.csdnimg.cn/cf8edb61cb3543fc883e98940e1ce78e.png"/></p>
<p>2. 连续的构造优化成构造</p>
<h3>精题（重要！）</h3>
<p><strong>问调用拷贝构造多少次（单看左边，右边是左边函数的副本，为了更好看结果）</strong></p>
<p><img alt="6a980cb78f6842f589b5ed156169b762.png" src="https://img-blog.csdnimg.cn/6a980cb78f6842f589b5ed156169b762.png"/></p>
<p><strong>都是拷贝+拷贝优化成了拷贝</strong></p>
<h3><strong>3.3.4 总结</strong></h3>
<p>我们不写编译器默认生成一个拷贝构造</p>
<p>1.内置类型成员会完成值拷贝，浅拷贝。</p>
<p>2.自定义类型成员，去调用这个成员的拷贝构造。</p>
</div>
</blockquote>
<h2>3.4. 运算符重载</h2>
<blockquote>
<h3><strong>3.4.1 概念</strong></h3>
<div>
<strong>C++</strong>
<strong>为了增强代码的可读性引入了运算符重载</strong>，
  <strong>运算符重载是具有特殊函数名的函数</strong>，也具有其返回值类型，函数名字以及参数列表，其返回值类型与参数列表与普通的函数类似。
 </div>
<div>
   
 </div>
<div>
  函数名字为：关键字
  <strong>operator</strong>
<strong>后面接需要重载的运算符符号</strong>。
 </div>
<div>
<div>
   函数原型：
   <strong>返回值类型</strong>
<strong> operator</strong>
<strong>操作符</strong>
<strong>(</strong>
<strong>参数列表</strong>
<strong>)</strong>
</div>
<div>
    
  </div>
<div>
<h3><strong>3.4.2 注意</strong></h3>
<div>
<ol><li>不能通过连接其他符号来创建新的操作符：比如operator@</li><li>重载操作符必须有一个类类型或者枚举类型的操作数</li></ol>
<div>
<ol><li>用于内置类型的操作符，其含义不能改变，例如：内置的整型+，不 能改变其含义</li><li>作为类成员的重载函数时，其形参看起来比操作数数目少1成员函数的（this）</li><li>操作符有一个默认的形参this，限定为第一个形参</li><li><strong>.*</strong> 、:: 、sizeof 、?: 、<strong>.</strong> 注意以上5个运算符不能重载。这个经常在笔试选择题中出现</li></ol>
<p> </p>
<h3><strong>3.4.3 全局的operator==</strong></h3>
<div>
<img alt="2be413b549334dd8b8b4b42921cda3b6.png" src="https://img-blog.csdnimg.cn/2be413b549334dd8b8b4b42921cda3b6.png"/>
</div>
<p>当我们的成员是私有的，但是是全局的运算符重载时，有三种解决办法</p>
<p>1.成员私有改为共有<br/> 2.友元<br/> 3.把运算符重载放进类里面（注意类里面会有个默认this，所以要减少一个参数）</p>
<p> </p>
<p>第一种类的封装性不能保证，不行。第二种后面讲友元（friend）讲。</p>
<p>我们来讲第三种也是最常见的。</p>
<p> </p>
<h3><strong>3.4.4 运算符重载放进类里面 </strong></h3>
<p><img alt="614533312fd548b98ca708072c454ff0.png" src="https://img-blog.csdnimg.cn/614533312fd548b98ca708072c454ff0.png"/></p>
<p>因为会有默认的this指针，所以d1是不用传的，传就错了（参数过多）。</p>
<div>
      这里需要注意的是，左操作数是this指向的
      <strong>调用函数的对象</strong>
</div>
<p><img alt="7eaad7bf41c5417391bf7fc9fefc9384.png" src="https://img-blog.csdnimg.cn/7eaad7bf41c5417391bf7fc9fefc9384.png"/></p>
<p><img alt="351e93b4b26a49038b033991bea58104.png" src="https://img-blog.csdnimg.cn/351e93b4b26a49038b033991bea58104.png"/></p>
<div>
<img alt="e729a76cbbb04873931fd5c18494afe8.png" src="https://img-blog.csdnimg.cn/e729a76cbbb04873931fd5c18494afe8.png"/>
</div>
<p> </p>
<h3>3.4.5 全局和类域同名运算符重载</h3>
<p>如果有两个相同的运算符重载一个在全局一个在类里面（是可以存在的哈，所在的作用域是不同的，前面说过类是相当于一个新的空间），那调用的时候会先调用哪个呢？</p>
<p><img alt="c136b1a89ccd41a5bdbf37c829d3acd1.png" src="https://img-blog.csdnimg.cn/c136b1a89ccd41a5bdbf37c829d3acd1.png"/>我们发现是先调用类里面的哈，也就是说编译器会现在类里面找（就近原则） </p>
<p> </p>
<h3><strong>3.4.6 赋值运算符重载</strong> </h3>
<div>
      赋值运算符主要有四点：
     </div>
<div>
<div>
       1. 参数类型
      </div>
<div>
       2. 返回值
      </div>
<div>
       3. 检测是否自己给自己赋值
      </div>
<div>
       4. 返回*this
      </div>
<div>
       5. 一个类如果没有显式定义赋值运算符重载，编译器也会生成一个，完成对象按字节序的值拷贝。（浅拷贝）
      </div>
<div>
        
      </div>
</div>
<p><img alt="958c33f8a68f4f4db14e5134ee1ccdaa.png" src="https://img-blog.csdnimg.cn/958c33f8a68f4f4db14e5134ee1ccdaa.png"/></p>
<p>上面的Date d3(d1) 改成 <strong>Date d3=d1</strong> 哈。写错了但是图不好改，因为作者是懒鬼哈哈，前面的写法是拷贝构造了哈，所以打印结果也是一样的。 </p>
<p> </p>
<h3>3.4.7 提问</h3>
<p>那么<strong>编译器生成的默认赋值重载函数已经可以完成字节序的值拷贝了</strong>，我们还需要自己实现吗？答案是肯定的，因为和拷贝构造一样，都是浅拷贝，在遇到直接管理资源的时候（malloc），就需要深拷贝去解决。 </p>
</div>
</div>
</div>
</div>
</blockquote>
<h2>3.5 &amp;运算符重载 and <strong>const</strong><strong>成员</strong></h2>
<h3>3.5.1 <strong>const</strong><strong>修饰类的成员函数</strong></h3>
<blockquote>
<p> </p>
<div>
<strong>将</strong>
<strong>const</strong>
<strong>修饰的类成员函数称之为</strong>
<strong>const</strong>
<strong>成员函数</strong>，const修饰类成员函数，实际修饰该成员函数
  <strong>隐含的</strong>
<strong>this</strong>
<strong>指针</strong>，表明在该成员函数中
  <strong>不能对类的任何成员进行修改。（网图）</strong>
</div>
<div>
<img alt="36b23108d35e4cb58b6397aacca621d9.png" src="https://img-blog.csdnimg.cn/36b23108d35e4cb58b6397aacca621d9.png"/>
</div>
<div>
  其实还是有一点不对，我们知道this应该是  Date *const this 此时this指向不可变
 </div>
<div>
  修饰之后应该是   const Date* const this 此时this指向的值也不可改变
 </div>
<div>
   
 </div>
<div>
  然后对于最后加上const的作用
 </div>
<div>
<img alt="999e85b93d7b4cda9f202ab157c1ea3c.png" src="https://img-blog.csdnimg.cn/999e85b93d7b4cda9f202ab157c1ea3c.png"/>
</div>
<div>
<img alt="8b808465e35d4341b873311b24cb3a22.png" src="https://img-blog.csdnimg.cn/8b808465e35d4341b873311b24cb3a22.png"/>
</div>
<p> 我们只有把Print后面加上const这样才能编过，这里涉及到的还是权限问题，如果不加上Print，就是权限的放大了，从Func的是const Date* const this 而 Print的是没有前面的const的。</p>
<p>注意，this前面加const修饰的是指向的对象，所以不修改this里面的内容就可以加，也推荐加上，因为这样普通对象和const对象都可以调用。</p>
<div>
<br/> 然后对于权限放大和缩小，这里有几个问题
 </div>
<div>
<div>
   1. const对象可以调用非const成员函数吗？     不可以，权限放大
  </div>
<div>
   2. 非const对象可以调用const成员函数吗？      可以，缩小
  </div>
<div>
   3. const成员函数内可以调用其它的非const成员函数吗？    不可以，权限放大
  </div>
<div>
<img alt="7e011d2be71d4552af9ce5cf84e646aa.png" src="https://img-blog.csdnimg.cn/7e011d2be71d4552af9ce5cf84e646aa.png"/>
</div>
<div>
   4. 非const成员函数内可以调用其它的const成员函数吗？    可以，缩小
  </div>
</div>
</blockquote>
<h3>3.5.2 <strong>取地址及const</strong><strong>取地址操作符重载 </strong> </h3>
<blockquote>
<div>
  这两个默认成员函数一般不用重新定义 ，编译器默认会生成。
 </div>
<div>
<pre><code class="language-cpp">class Date
{ 
public :
 Date* operator&amp;()
 {
 return this ;
 }
 
 const Date* operator&amp;()const
 {
 return this ;
 }
private :
 int _year ; // 年
 int _month ; // 月
 int _day ; // 日
};</code></pre>
<div>
   这两个运算符一般不需要重载，使用编译器生成的默认取地址的重载即可，只有特殊情况，才需要重载，比如
   <strong>想让别人获取到指定的内容！</strong>
</div>
<div>
<pre><code class="language-cpp">class Date
{ 
public :
 Date* operator&amp;()
 {
 //return this ;
   return nullptr;
 }
 
 const Date* operator&amp;()const
 {
 //return this ;
   return nullptr;
 }
private :
 int _year ; // 年
 int _month ; // 月
 int _day ; // 日
};</code></pre>
</div>
</div>
</blockquote>
<h1><strong>4. 初始化列表 </strong> </h1>
<blockquote>
<div>
  对于构造函数的初始化列表
 </div>
<div>
<div>
   在创建对象时，编译器通过调用构造函数，给对象中各个成员变量一个合适的初始值。
  </div>
<div>
<pre><code class="language-cpp">class Date
{
public:
 Date(int year, int month, int day)
 {
 _year = year;
 _month = month;
 _day = day;
 }
 
private:
 int _year;
 int _month;
 int _day;
};</code></pre>
<div>
    虽然上述构造函数调用之后，对象中已经有了一个初始值，但是不能将其称作为类对象成员的初始化，
    <strong>构造</strong>
<strong>函数体中的语句只能将其称作为赋初值</strong>，而不能称作初始化。因为
    <strong>初始化只能初始化一次，而构造函数体内</strong>
<strong>可以多次赋值</strong>。
   </div>
</div>
</div>
<div>
   
 </div>
<div>
<strong>初始化列表：</strong>以一个
  <strong>冒号开始</strong>，接着是一个以
  <strong>逗号分隔的数据成员列表</strong>，每个
  <strong>"</strong>
<strong>成员变量</strong>
<strong>"</strong>后面跟一个
  <strong>放在括</strong>
<strong>号中的初始值或表达式。 </strong>
</div>
<div>
   
 </div>
<div>
  上面的叫函数体类初始化
  <br/> 下面的叫初始化列表
  <br/> 也可以混着用
 </div>
<div>
<img alt="2329587e947d4a678d958217d87f83ba.png" src="https://img-blog.csdnimg.cn/2329587e947d4a678d958217d87f83ba.png"/>
</div>
<p> </p>
<div>
<div>
   初始化列表的价值是什么？
  </div>
<div>
<img alt="bcab21204d0c4e3598f8e3927f59abd4.png" src="https://img-blog.csdnimg.cn/bcab21204d0c4e3598f8e3927f59abd4.png"/>
</div>
<p>我们都知道类里面是声明，下面是类的定义，那么对象里面的成员我们去找他定义的地方是在哪里呢？没错，初始化列表。</p>
<p>那为什么要为类成员找一个定义的地方？<br/> 因为有些成员需要在定义的地方初始化（初始化列表）： </p>
<p><img alt="c833c0daea1a406a82a27df3672d4d0b.png" src="https://img-blog.csdnimg.cn/c833c0daea1a406a82a27df3672d4d0b.png"/></p>
<p>注意在类里面都是声明，只有对象里面才是定义。 </p>
<p> </p>
<div>
   【注意】
  </div>
<div>
<div>
    1. 每个成员变量在初始化列表中
    <strong>只能出现一次</strong>(初始化只能初始化一次)
   </div>
<div>
    2. 类中包含以下成员，必须放在初始化列表位置进行初始化（就是不可修改或者定义时就要指定的数据）：
   </div>
<div>
<ul><li>引用成员变量</li><li>const成员变量</li><li>自定义类型成员(该类没有默认构造函数)</li></ul>
<p>其他的变量既可以在初始化列表初始化，也可以在函数体内初始化</p>
<p><strong>总结：建议尽量在初始化列表初始化。</strong></p>
<p> </p>
<p><img alt="7bcbbe7d5add4eeeaeb11abf327f46e3.png" src="https://img-blog.csdnimg.cn/7bcbbe7d5add4eeeaeb11abf327f46e3.png"/></p>
<p> </p>
<p>但是如果成员里面有自定义类型，初始化时还是会去调用其默认构造函数 </p>
<p><img alt="1ea9f1899c464e5fb9b75e8e75218cac.png" src="https://img-blog.csdnimg.cn/1ea9f1899c464e5fb9b75e8e75218cac.png"/></p>
<p>自定义类型先去走自己的默认构造函数进行初始化，然后走这里，同时这里如果不用初始化列表，就用赋值的方式（就是下面框起来的，但是要先运算符重载=）。 </p>
<p> </p>
<p><strong>用两个栈实现队列来加深理解</strong><br/> 下面两种，都是内置类型不处理，自定义类型调用其默认构造，如果我们没有显示去写初始化列表，也会像上面那样初始化</p>
<p><img alt="8ddd9c3817e745979ead82f1a3294a8a.png" src="https://img-blog.csdnimg.cn/8ddd9c3817e745979ead82f1a3294a8a.png"/></p>
<p><img alt="572b2c242dfd4a1dbcf28313b0a1daf7.png" src="https://img-blog.csdnimg.cn/572b2c242dfd4a1dbcf28313b0a1daf7.png"/></p>
<p><strong>接着 </strong></p>
<p><img alt="72d44a3cc8014da79779a9cf0962ea4e.png" src="https://img-blog.csdnimg.cn/72d44a3cc8014da79779a9cf0962ea4e.png"/>这个（上面框起来的）是在哪初始化的呢？ </p>
<p>其实这个缺省值是给初始化列表用的，如果写了就不用，如果没写就用缺省值</p>
<p> </p>
<p><strong>还有很重要的一点</strong></p>
<div>
<strong>成员变量</strong>在类中
     <strong>声明次序</strong>就是其在初始化列表中的
     <strong>初始化顺序</strong>，与其在初始化列表中的先后次序无关
    </div>
</div>
</div>
</div>
</blockquote>
<h1><strong>5. static</strong><strong>成员</strong> </h1>
<blockquote>
<h2><strong>5.1 概念 </strong></h2>
<div>
  声明为
  <strong>static</strong>
<strong>的类成员</strong>称为
  <strong>类的静态成员</strong>，用
  <strong>static</strong>修饰的
  <strong>成员变量</strong>，称之为
  <strong>静态成员变量</strong>；用
  <strong>static</strong>
<strong>修饰</strong>的
  <strong>成员函数</strong>，称之为
  <strong>静态成员函数</strong>。
  <strong>静态的成员变量一定要在类外进行初始化 </strong>
</div>
<div>
   
 </div>
<div>
  全局普通全局变量不好，没有封装，所以C++提供了静态成员全局变量
  <br/> 那两者有什么区别呢？
 </div>
<div>
<img alt="4a531651baed480ea0a9dd8f28c660b3.png" src="https://img-blog.csdnimg.cn/4a531651baed480ea0a9dd8f28c660b3.png"/>
<br/> 1.静态成员变量属于整个类，属于类的所有对象，sizeof里面也不算，是放在静态区的，与之前函数放在公共代码段是不一样的 
 </div>
<div>
  那么之前的程序就编译不通过了，因为不是在构造函数定义，是在类外定义：
 </div>
<div>
<img alt="7c1e131c03184d9aa4f2cc67386cc6e7.png" src="https://img-blog.csdnimg.cn/7c1e131c03184d9aa4f2cc67386cc6e7.png"/>
</div>
<p> </p>
<h2>5.2 访问成员函数</h2>
<h3><br/> 5.2.1 共有成员函数</h3>
<p><img alt="f9ab668aa33e4da198256ee4f0061b44.png" src="https://img-blog.csdnimg.cn/f9ab668aa33e4da198256ee4f0061b44.png"/></p>
<p>但是这个方法要有对象，但是如果没有对象呢？ </p>
<p> </p>
<h3>5.2.2 static成员函数</h3>
<p><img alt="7d811bb193cb4ad1ba93c008b7be1bef.png" src="https://img-blog.csdnimg.cn/7d811bb193cb4ad1ba93c008b7be1bef.png"/></p>
<p>这个对象也可以调，因为所有对象都用这个static成员函数</p>
<p>还可以类域直接调：</p>
<p><img alt="2a97c6afff4041349d1c0f2e6895272a.png" src="https://img-blog.csdnimg.cn/2a97c6afff4041349d1c0f2e6895272a.png"/></p>
<p>因为他没有this，所以可以指定类域去调<br/> 但是如果静态函数里面有非静态成员是不能访问的，因为没有this指针</p>
<p><img alt="0e306fbd833f49188874e043b48108ea.png" src="https://img-blog.csdnimg.cn/0e306fbd833f49188874e043b48108ea.png"/>但是可以创建对象然后去访问，因为这样就有this了</p>
<p><img alt="fc50f278ac7943d58f2c57df60efe5d9.png" src="https://img-blog.csdnimg.cn/fc50f278ac7943d58f2c57df60efe5d9.png"/></p>
</blockquote>
<h1>6. <strong>C++11 </strong><strong>的成员初始化新玩法</strong></h1>
<blockquote>
<p> </p>
<h3>概念</h3>
<div>
  C++11支持非静态成员变量在声明时进行初始化赋值，
  <strong>但是要注意这里不是初始化，这里是给声明的成员变</strong>
<strong>量缺省值</strong>。
 </div>
<p><strong> </strong></p>
<h3><strong>示例</strong></h3>
<p><img alt="334b8bdf7bcd4d649b40a3736f97273f.png" src="https://img-blog.csdnimg.cn/334b8bdf7bcd4d649b40a3736f97273f.png"/></p>
<p>上面就可以转换成下面那样：</p>
<p><img alt="f5bd1a556d9347a893cf32f61aa0de2e.png" src="https://img-blog.csdnimg.cn/f5bd1a556d9347a893cf32f61aa0de2e.png"/><strong>但是静态的不会在初始化列表初始化，还是要在全局给 </strong></p>
</blockquote>
<h1>7. <strong>友元 </strong> </h1>
<blockquote>
<h2>7.1 <strong>友元函数</strong></h2>
<div>
  友元分为：
  <strong>友元函数</strong>和
  <strong>友元类 </strong>
</div>
<div>
  友元提供了一种
  <strong>突破封装</strong>的方式，有时提供了便利。但是友元会增加耦合度，破坏了封装，所以友元
  <strong>不宜多用</strong>。
 </div>
<div>
   
 </div>
<div>
   
 </div>
<div>
<strong>就我们的日期类而言（作者忘记写博客了后面有时间了发）</strong>
<div>
<strong>问题：</strong>现在我们尝试去重载operator&lt;&lt;，然后发现我们没办法将operator&lt;&lt;重载成成员函数。
   <strong>因为</strong>
<strong>cout</strong>
<strong>的</strong>
<strong>输出流对象和隐含的</strong>
<strong>this</strong>
<strong>指针在抢占第一个参数的位置</strong>。this指针默认是第一个参数也就是左操作数了。但是实际使用中cout需要是第一个形参对象，才能正常使用。所以我们要将operator&lt;&lt;重载成
   <strong>全局函数</strong>。但是这样的话，又会导致类外没办法访问成员，那么这里就需要
   <strong>友元来解决</strong>。operator&gt;&gt;同理。
  </div>
<div>
    
  </div>
<div>
<img alt="bfb4e8ddfae149559e2796fa34a42f19.png" src="https://img-blog.csdnimg.cn/bfb4e8ddfae149559e2796fa34a42f19.png"/>
</div>
<div>
   （cout是ostream   cin是istream）
  </div>
<div>
<div>
     
   </div>
<div>
<strong>友元函数</strong>可以
    <strong>直接访问</strong>类的
    <strong>私有</strong>成员，它是
    <strong>定义在类外部</strong>的
    <strong>普通函数</strong>，不属于任何类，但需要在类的内部声明，声明时需要加
    <strong>friend</strong>关键字。
   </div>
</div>
<div>
    
  </div>
<h2>7.2 注意</h2>
<ul><li><strong>友元函数</strong>可访问类的私有和保护成员，但<strong>不是类的成员函数 </strong></li></ul>
<div>
<ul><li>友元函数<strong>不能用</strong><strong>const</strong><strong>修饰（因为没有this）</strong></li><li><strong>友元函数</strong>可以在类定义的任何地方<strong>声明</strong>，<strong>不受类访问限定符限制 </strong></li><li>一个函数可以是<strong>多个类</strong>的友元函数</li><li>友元函数的调用与普通函数的调用和原理<strong>相同 </strong></li></ul>
<p> </p>
<h2>7.3 <strong>友元类 </strong></h2>
<div>
    友元类的所有成员函数都可以是另一个类的友元函数，都可以访问另一个类中的非公有成员。
   </div>
<div>
     
   </div>
<div>
<strong> 注意：</strong>
</div>
<div>
<ul><li>友元关系是单向的，不具有交换性。 比如有Time类和Date类，在Time类中声明Date类为其友元类，那么可以在Date类中直接访问Time 类的私有成员变量，但想在Time类中访问Date类中私有的成员变量则不行。</li><li>友元关系不能传递。如果B是A的友元，C是B的友元，则不能说明C时A的友元。</li></ul>
</div>
</div>
</div>
</blockquote>
<h1>8. <strong>内部类</strong></h1>
<blockquote>
<h2>8.1 <strong>概念</strong></h2>
<div>
  如果一个类定义在另一个类的内部，这个内部类就叫做
  <strong>内部类</strong>。注意此时这个内部类是一个
  <strong>独立</strong>的类，它
  <strong>不属于</strong>外部类，更不能通过外部类的对象去调用内部类。外部类对内部类没有任何优越的访问权限。
 </div>
<div>
<img alt="a357bb49aa7f458a90b44f13e45b6708.png" src="https://img-blog.csdnimg.cn/a357bb49aa7f458a90b44f13e45b6708.png"/>
</div>
<p> </p>
<div>
<strong>注意：</strong>
</div>
<div>
  内部类就是外部类的友元类。注意友元类的定义，内部类可以通过外部类的对象参数来访问外部类中的所有成员。但是外部类不是内部类的友元。
 </div>
<div>
   
 </div>
<div>
<strong>特性：</strong>
</div>
<div>
<div>
   1. 内部类可以定义在外部类的public、protected、private都是可以的。
  </div>
<div>
   2. 注意内部类可以
   <strong>直接访问</strong>外部类中的static、枚举成员，
   <strong>不需要外部类的对象</strong>
<strong>/</strong>
<strong>类名</strong>。
  </div>
<div>
   3. 
   <strong>sizeof(</strong>
<strong>外部类)=</strong>
<strong>外部类</strong>，和内部类没有任何关系。
  </div>
</div>
</blockquote>
<blockquote>
<div>
<p>最后的最后，创作不易，希望读者三连支持💖</p>
<p>赠人玫瑰，手有余香💖</p>
</div>
</blockquote>
<p> </p>
</div>
</div>