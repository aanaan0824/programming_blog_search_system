<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<p id="main-toc"><strong>目录</strong></p>
<p id="%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFpriority_queue-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFpriority_queue">一、什么是priority_queue</a></p>
<p id="%E4%BA%8C%E3%80%81priority_queue%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81priority_queue%E7%9A%84%E4%BD%BF%E7%94%A8">二、priority_queue的使用</a></p>
<p id="1.priority_queue%E7%9A%84%E6%9E%84%E9%80%A0-toc" style="margin-left:40px;"><a href="#1.priority_queue%E7%9A%84%E6%9E%84%E9%80%A0">1.priority_queue的构造</a></p>
<p id="2.push(%20)-toc" style="margin-left:40px;"><a href="#2.push%28%20%29">2.push( )</a></p>
<p id="%C2%A03.pop(%20)-toc" style="margin-left:40px;"><a href="#%C2%A03.pop%28%20%29">3.pop( )</a></p>
<p id="%C2%A04.size(%20)-toc" style="margin-left:40px;"><a href="#%C2%A04.size%28%20%29">4.size( )</a></p>
<p id="5.empty(%20)%C2%A0-toc" style="margin-left:40px;"><a href="#5.empty%28%20%29%C2%A0">5.empty( ) </a></p>
<p id="%C2%A0%E4%B8%89%E3%80%81priority_queue%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><a href="#%C2%A0%E4%B8%89%E3%80%81priority_queue%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0"> 三、priority_queue模拟实现</a></p>
<p id="1.%E4%BB%BF%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#1.%E4%BB%BF%E5%87%BD%E6%95%B0">1.仿函数</a></p>
<p id="%EF%BC%881%EF%BC%89%E6%A6%82%E5%BF%B5%C2%A0-toc" style="margin-left:80px;"><a href="#%EF%BC%881%EF%BC%89%E6%A6%82%E5%BF%B5%C2%A0">（1）概念 </a></p>
<p id="%EF%BC%882%EF%BC%89%E4%BC%98%E7%82%B9-toc" style="margin-left:80px;"><a href="#%EF%BC%882%EF%BC%89%E4%BC%98%E7%82%B9">（2）优点</a></p>
<p id="%EF%BC%883%EF%BC%89%E7%BC%BA%E7%82%B9-toc" style="margin-left:80px;"><a href="#%EF%BC%883%EF%BC%89%E7%BC%BA%E7%82%B9">（3）缺点</a></p>
<p id="%EF%BC%884%EF%BC%89%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px;"><a href="#%EF%BC%884%EF%BC%89%E5%AE%9E%E7%8E%B0">（4）实现</a></p>
<p id="2.%E5%A0%86%E7%9A%84%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4-toc" style="margin-left:40px;"><a href="#2.%E5%A0%86%E7%9A%84%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4">2.堆的插入删除</a></p>
<p id="3.%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#3.%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">3.代码实现</a></p>
<p id="%C2%A0%EF%BC%881%EF%BC%89%E4%BB%BF%E5%87%BD%E6%95%B0%3C-toc" style="margin-left:80px;"><a href="#%C2%A0%EF%BC%881%EF%BC%89%E4%BB%BF%E5%87%BD%E6%95%B0%3C"> （1）仿函数&lt;</a></p>
<p id="%EF%BC%882%EF%BC%89%E4%BB%BF%E5%87%BD%E6%95%B0%3E-toc" style="margin-left:80px;"><a href="#%EF%BC%882%EF%BC%89%E4%BB%BF%E5%87%BD%E6%95%B0%3E">（2）仿函数&gt;</a></p>
<p id="%EF%BC%883%EF%BC%89push()-toc" style="margin-left:80px;"><a href="#%EF%BC%883%EF%BC%89push%28%29">（3）push()</a></p>
<p id="%EF%BC%884%EF%BC%89pop()-toc" style="margin-left:80px;"><a href="#%EF%BC%884%EF%BC%89pop%28%29">（4）pop()</a></p>
<p id="%EF%BC%885%EF%BC%89top()-toc" style="margin-left:80px;"><a href="#%EF%BC%885%EF%BC%89top%28%29">（5）top()</a></p>
<p id="%EF%BC%886%EF%BC%89size()-toc" style="margin-left:80px;"><a href="#%EF%BC%886%EF%BC%89size%28%29">（6）size()</a></p>
<p id="%EF%BC%887%EF%BC%89empty()-toc" style="margin-left:80px;"><a href="#%EF%BC%887%EF%BC%89empty%28%29">（7）empty()</a></p>
<p id="4.%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%E6%AE%B5-toc" style="margin-left:40px;"><a href="#4.%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%E6%AE%B5">4.完整代码段</a></p>
<hr id="hr-toc"/>
<p></p>
<p></p>
<h1 id="%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFpriority_queue"><span style="color:#956fe7;">一、什么是priority_queue</span></h1>
<p>（1）priority_queue即优先级队列，是一种容器适配器，最大元素放在第一个。</p>
<p>（2）底层用堆实现，默认是大堆，因为默认大的优先级高，可随时插入元素，可快速查找最大元素，即优先级队列中第一个元素。</p>
<p>（3）优先级队列元素从特定容器的“尾部”弹出，其称为优先队列的顶部。</p>
<p>（4）底层容器可以是任何标准容器类模板，也可以是其他特定设计的容器类。容器应该可以通过随机访问迭代器访问，并支持以下操作：<br/>         empty( )：检测容器是否为空<br/>         size( )：返回容器中有效元素个数<br/>         front( )：返回容器中第一个元素的引用<br/>         push_back( )：在容器尾部插入元素<br/>         pop_back( )：删除容器尾部元素</p>
<p>（5）标准容器类vector和deque满足这些需求。默认情况下，如果没有为特定的priority_queue类实例化指定容器类，则使用vector，堆的物理结构是数组，所以优先级队列也是一个vector。</p>
<p>（6） 需要支持随机访问迭代器，以便始终在内部保持堆结构。容器适配器通过在需要时自动调用算法函数make_heap、push_heap和pop_heap来自动完成此操作。</p>
<h1 id="%E4%BA%8C%E3%80%81priority_queue%E7%9A%84%E4%BD%BF%E7%94%A8"><span style="color:#956fe7;">二、priority_queue的使用</span></h1>
<p>优先级队列默认使用vector作为其底层存储数据的容器，在vector上又使用了堆算法将vector中元素构造成堆的结构，因此priority_queue就是堆，所有需要用到堆的位置，都可以考虑使用priority_queue。</p>
<h2 id="1.priority_queue%E7%9A%84%E6%9E%84%E9%80%A0"><span style="color:#956fe7;">1.priority_queue的构造</span></h2>
<p>priority_queue有两种构造方式：</p>
<p>（1）构造一个空的优先级队列</p>
<pre><code class="language-cpp">explicit priority_queue (const Compare&amp; comp = Compare(),
                         const Container&amp; ctnr = Container());//构造一个控的优先级队列</code></pre>
<p>构造一个空的优先级队列pq1： </p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;queue&gt;//队列
#include&lt;vector&gt;//数组
#include&lt;functional&gt;//比较符号，less 或 greater

using namespace std;

int main()
{
	priority_queue&lt;int&gt; pq1;//构造一个空的优先级队列
    
    pq1.push(3);//向优先级队列中插入元素
	pq1.push(1);
	pq1.push(6);
	pq1.push(12);
	pq1.push(7);

    while (!pq1.empty())
	{
		cout &lt;&lt; pq1.top() &lt;&lt; endl;
		pq1.pop();
	}
}</code></pre>
<p><img alt="" height="380" src="image\7d145cfc42334500b66673029d46cadc.png" width="1200"/></p>
<p>（2）用迭代器区间构造一个优先级队列</p>
<pre><code class="language-cpp">template &lt;class InputIterator&gt;
         priority_queue (InputIterator first, InputIterator last,
                         const Compare&amp; comp = Compare(),
                         const Container&amp; ctnr = Container());//用first和last之间的元素构造优先级队列</code></pre>
<p>使用数组的迭代器区间构造一个优先级队列：</p>
<pre><code class="language-cpp">    vector&lt;int&gt; v;
	v.push_back(1);
	v.push_back(2);
	v.push_back(3);
	v.push_back(4);

	priority_queue&lt;int&gt; pq2(v.begin(), v.end()) ;//用v的迭代器区间构造pq2</code></pre>
<p>以上都构造的是大堆，如何构造一个小堆呢？</p>
<p>可以使用如下模板构造：T是元素类型，Container 指定容器，Compare是元素比较方式，大于还是小于，默认为大于less，即大堆，如果想改成小堆，就用greater。</p>
<pre><code class="language-cpp">template &lt;class T, class Container = vector&lt;T&gt;,
  class Compare = less&lt;typename Container::value_type&gt; &gt; class priority_queue;</code></pre>
<p> value_type被typedef为T，编译器编译的时候是没有vecto的，因为vector没有被实例化，所以编译器编译的时候不知道Container是vector，不知道value_type类型。</p>
<p>构造一个小堆： </p>
<pre><code class="language-cpp">    priority_queue&lt;int,vector&lt;int&gt;,greater&lt;vector&lt;int&gt;::value_type&gt;&gt; pq4;
	pq4.push(20);
	pq4.push(2);
	pq4.push(8);
	pq4.push(5);

	while (!pq4.empty())
	{
		cout &lt;&lt; pq4.top() &lt;&lt; endl;
		pq4.pop();
	}</code></pre>
<p><img alt="" height="352" src="image\407d7252dcef407a811bfc30730a5e07.png" width="1200"/>  </p>
<h2 id="2.push(%20)"><span style="color:#956fe7;">2.push( )</span></h2>
<p>向优先级队列中插入元素 </p>
<pre><code class="language-cpp">void push (const value_type&amp; val);//向优先级队列中插入元素</code></pre>
<p> 向pq3中插入元素：</p>
<pre><code class="language-cpp">    priority_queue&lt;int&gt; pq3;
	pq3.push(6);//向优先级队列中插入元素
	pq3.push(3);
	pq3.push(9);
	pq3.push(8);</code></pre>
<h2 id="%C2%A03.pop(%20)"><span style="color:#956fe7;">3.pop( )</span></h2>
<p>删除优先级队列第一个元素 </p>
<pre><code class="language-cpp">void pop();//删除优先级队列第一个元素</code></pre>
<p> 删除pq3的第一个元素：</p>
<pre><code class="language-cpp">    pq3.pop();//删除优先级队列第一个元素</code></pre>
<h2 id="%C2%A04.size(%20)"><span style="color:#956fe7;">4.size( )</span></h2>
<p> 返回优先级队列的元素个数</p>
<pre><code class="language-cpp">size_type size() const;//返回优先级队列的元素个数</code></pre>
<p> 返回pq3的元素个数</p>
<pre><code class="language-cpp">    cout &lt;&lt; pq3.size() &lt;&lt; endl;//返回pq3的元素个数</code></pre>
<p><img alt="" height="250" src="image\38dee69c169b4105b2bbcc786b412c10.png" width="1200"/></p>
<h2 id="5.empty(%20)%C2%A0"><span style="color:#956fe7;">5.empty( ) </span></h2>
<p>判断优先级队列是否为空</p>
<pre><code class="language-cpp">bool empty() const;//判断优先级队列是否为空</code></pre>
<p> 判断pq3是否为空</p>
<pre><code class="language-cpp">    cout &lt;&lt; pq3.empty() &lt;&lt; endl;</code></pre>
<p><img alt="" height="254" src="image\95a0174c734945daa4e0a6de6fcba3ba.png" width="1200"/></p>
<h1 id="%C2%A0%E4%B8%89%E3%80%81priority_queue%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0"> <span style="color:#956fe7;">三、priority_queue模拟实现</span></h1>
<p>priority_queue底层用堆实现，priority_queue的模拟实现只需要对堆进行封装即可。</p>
<h2 id="1.%E4%BB%BF%E5%87%BD%E6%95%B0"><span style="color:#956fe7;">1.仿函数</span></h2>
<p>priority_queue默认是大堆，那么该如何实现小堆呢？需要先了解仿函数。</p>
<h3 id="%EF%BC%881%EF%BC%89%E6%A6%82%E5%BF%B5%C2%A0"><span style="color:#956fe7;">（1）概念 </span></h3>
<p>仿函数让一个类的使用看上去像个函数。仿函数是在类中实现了一个<a href="https://baike.baidu.com/item/operator/2387244" title="operator">operator</a>operator<a href="https://baike.baidu.com/item/operator/2387244" title="operator">operator</a>()，是一个类的对象，这个类就有了类似函数的行为，所以这个类就是一个仿函数类，目的是为了让函数拥有类的性质。</p>
<p>这个类的对象即仿函数，可以当作一般函数去用，只不过仿函数的功能是在一个类中的运算符operator()中实现的，使用的时候把函数作为参进行传递即可。</p>
<h3 id="%EF%BC%882%EF%BC%89%E4%BC%98%E7%82%B9"><span style="color:#956fe7;">（2）优点</span></h3>
<p> ① 仿函数比函数指针的执行速度快，函数指针通过地址调用，而仿函数是对运算符operator进行自定义来提高调用的效率。<br/>  ② 仿函数比一般函数灵活，可以同时拥有两个不同的状态实体，一般函数不具备此种功能。<br/>  ③ 仿函数可以作为模板参数使用，因为每个仿函数都拥有自己的类型。</p>
<h3 id="%EF%BC%883%EF%BC%89%E7%BC%BA%E7%82%B9"><span style="color:#956fe7;">（3）缺点</span></h3>
<p> ① 需要单独实现一个类。<br/>  ② 定义形式比较复杂。</p>
<h3 id="%EF%BC%884%EF%BC%89%E5%AE%9E%E7%8E%B0"><span style="color:#956fe7;">（4）实现</span></h3>
<p> 先看如下函数isLess，它实现了&lt;的比较</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;

bool isLess(int l, int r)
{
	return l &lt; r;
}

int main()
{
	cout &lt;&lt; isLess(1, 3) &lt;&lt; endl;
}</code></pre>
<p>如果在一个类里，实现同样功能，Less这个类就变成了仿函数类，它的对象就是一个仿函数</p>
<pre><code class="language-cpp">struct less
{
	bool operator()(int l, int r)
	{
		return l &lt; r;
	}
};</code></pre>
<p> 这个类还可以再完善一下，使用类模板来支持不同类型的数据使用&lt;比较大小</p>
<pre><code class="language-cpp">template &lt;class T&gt;
struct less
{
	bool operator()(const T&amp; l, const T&amp; r)
	{
		return l &lt; r;//&lt;的比较
	}
};</code></pre>
<p>同样，&gt;的仿函数类也可以实现了：</p>
<pre><code class="language-cpp">template &lt;class T&gt;
struct greater
{
	bool operator()(const T&amp; l, const T&amp; r)
	{
		return l &gt; r;//&gt;的比较
	}
};</code></pre>
<p>如何使用仿函数呢？</p>
<pre><code class="language-cpp">int main()
{
	less&lt;int&gt; lessInt;//定义一个仿函数类对象，参数类型指定为int
	std::cout &lt;&lt; lessInt(1, 3) &lt;&lt; std::endl;//对仿函数的调用等价于std::cout &lt;&lt; lessInt.operator()(1, 3) &lt;&lt; std::endl;
}</code></pre>
<p>priority_queue模板中的less替换成greater就可以实现&gt;的比较了：</p>
<pre><code class="language-cpp">template &lt;class T, class Container = vector&lt;T&gt;,
  class Compare = greater&lt;typename Container::value_type&gt; &gt; class priority_queue;</code></pre>
<p></p>
<h2 id="2.%E5%A0%86%E7%9A%84%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4"><span style="color:#956fe7;">2.堆的插入删除</span></h2>
<p>要对priority_queue插入删除，就是在堆上插入删除，堆在物理上是数组，在逻辑上是一颗完全二叉树。根据<a href="https://blog.csdn.net/gx714433461/article/details/122889673?spm=1001.2014.3001.5501" title="【数据结构】堆-C语言版">【数据结构】堆-C语言版</a>一文回忆一下堆的插入删除相关知识</p>
<p>（1）堆的插入（先插入，再向上调整）</p>
<p><img alt="" height="957" src="image\b19f8dc87699490eae8bbd370965b433.png" width="1200"/></p>
<p></p>
<p> （2）堆的删除（先交换，然后删除，再向下调整）</p>
<p><img alt="" height="1097" src="image\c64b1a7543d443af8166dce7ca9cf7e9.png" width="1200"/></p>
<h2 id="3.%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span style="color:#956fe7;">3.代码实现</span></h2>
<p>priority_queue类默认的Container是vector，是自定义类型。因此priority_queue的构造函数、拷贝构造函数、赋值运算符重载函数、析构函数都不用写，会调vector的默认构造函数、拷贝构造函数、赋值运算符重载函数、析构函数。只需要实现7个函数：仿函数&lt;、仿函数&gt;、push、pop、top、size、empty。</p>
<h3 id="%C2%A0%EF%BC%881%EF%BC%89%E4%BB%BF%E5%87%BD%E6%95%B0%3C"><span style="color:#956fe7;"> （1）仿函数&lt;</span></h3>
<pre><code class="language-cpp">template&lt;class T&gt;
struct less
{
	bool operator()(const T&amp; l, const T&amp; r)
	{
		return l &lt; r;
	}
};</code></pre>
<h3 id="%EF%BC%882%EF%BC%89%E4%BB%BF%E5%87%BD%E6%95%B0%3E"><span style="color:#956fe7;">（2）仿函数&gt;</span></h3>
<pre><code class="language-cpp">	template&lt;class T&gt;
	struct greater
	{
		bool operator()(const T&amp; l, const T&amp; r)
		{
			return l &gt; r;
		}
	};</code></pre>
<h3 id="%EF%BC%883%EF%BC%89push()"><span style="color:#956fe7;">（3）push()</span></h3>
<pre><code class="language-cpp">	template&lt;class T, class Container = vector&lt;T&gt;,class Compare = delia::less&lt;T&gt;&gt;//指定Compare方式是less，按&lt;比较
	class priority_queue
	{
	public:		
		//向上调整算法
		void AdjustUp(size_t child)
		{
			Compare com;//定义仿函数类对象

			size_t parent = (child - 1) / 2;//找父亲的位置
			while (child &gt; 0)
			{
				//if (_con[parent] &lt; _con[child])//父亲比孩子小，孩子就要往上提
				if (com(_con[parent] , _con[child]))//使用仿函数比较
				{
					swap(_con[parent], _con[child]);//交换父亲和孩子
					child = parent;//父亲变孩子
					parent = (child - 1) / 2;//重新计算新孩子的父亲位置
				}
				else
				{
					//父亲&gt;=孩子就不用动
					break;
				}	
			}
		}

		//插入
		void push(const T&amp; x)
		{
			_con.push_back(x);//尾插到堆
			AdjustUp(_con.size() - 1);//向上调整
		}
    
    private:
		Container _con;
	};</code></pre>
<h3 id="%EF%BC%884%EF%BC%89pop()"><span style="color:#956fe7;">（4）pop()</span></h3>
<pre><code class="language-cpp">		//向下调整算法
		void AdjustDown(size_t parent)
		{
			Compare com;//定义仿函数类对象

			size_t child = 2 * parent + 1;//找孩子位置
			while (child &lt; _con.size())
			{
				//找大孩子
				if (child + 1 &lt; _con.size() &amp;&amp; _con[child+1] &gt; _con[child])
				{
					child++;
				}

				//if(_con[parent] &lt; _con[child])父亲比孩子小，父亲就要往下挪
				if (com(_con[parent], _con[child]))//使用仿函数比较
				{
					swap(_con[parent], _con[child]);//交换父亲和孩子
					parent = child;//孩子变父亲
					child = parent * 2 + 1;//重新计算孩子的位置
				}
				else
				{
					break;
				}
			}
		}

        //删除
		void pop()
		{
			swap(_con[0], _con[_con.size() - 1]);//交换堆顶元素和堆尾元素
			_con.pop_back();//删除堆顶元素			
			AdjustDown(0);//向下调整算法
		}</code></pre>
<h3 id="%EF%BC%885%EF%BC%89top()"><span style="color:#956fe7;">（5）top()</span></h3>
<pre><code class="language-cpp">		//返回priority_queue第一个元素，即堆顶元素
		T top()
		{
			return _con[0];
		}</code></pre>
<h3 id="%EF%BC%886%EF%BC%89size()"><span style="color:#956fe7;">（6）size()</span></h3>
<pre><code class="language-cpp">		//求priority_queue队列中元素个数
		size_t size()
		{
			return _con.size();
		}</code></pre>
<h3 id="%EF%BC%887%EF%BC%89empty()"><span style="color:#956fe7;">（7）empty()</span></h3>
<pre><code class="language-cpp">		//判断priority_queue是否为空
		bool empty()
		{
			return _con.empty();
		}</code></pre>
<p></p>
<h2 id="4.%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%E6%AE%B5"><span style="color:#956fe7;">4.完整代码段</span><br/>  </h2>
<p>018-priority_queue.h</p>
<pre><code class="language-cpp">#pragma once
#include&lt;vector&gt;
using namespace std;

namespace delia
{
	template&lt;class T&gt;
	struct less
	{
		bool operator()(const T&amp; l, const T&amp; r)
		{
			return l &lt; r;
		}
	};

	template&lt;class T&gt;
	struct greater
	{
		bool operator()(const T&amp; l, const T&amp; r)
		{
			return l &gt; r;
		}
	};

	template&lt;class T, class Container = vector&lt;T&gt;,class Compare = std::less&lt;T&gt;&gt;
	class priority_queue
	{
	public:
		//Container默认是vector，自定义类型
		//构造函数、拷贝构造函数、赋值运算符重载函数、析构函数都不用写，会调用vector的构造函数和析构函数等
		
		

		//向上调整算法
		void AdjustUp(size_t child)
		{
			Compare com;//定义仿函数类对象

			size_t parent = (child - 1) / 2;//找父亲的位置
			while (child &gt; 0)
			{
				//if (_con[parent] &lt; _con[child])//父亲比孩子小，孩子就要往上提
				if (com(_con[parent] , _con[child]))//使用仿函数比较
				{
					swap(_con[parent], _con[child]);//交换父亲和孩子
					child = parent;//父亲变孩子
					parent = (child - 1) / 2;//重新计算新孩子的父亲位置
				}
				else
				{
					//父亲&gt;=孩子就不用动
					break;
				}	
			}
		}

		//插入
		void push(const T&amp; x)
		{
			_con.push_back(x);//尾插到堆
			AdjustUp(_con.size() - 1);//向上调整
		}

		//向下调整算法
		void AdjustDown(size_t parent)
		{
			Compare com;//定义仿函数类对象

			size_t child = 2 * parent + 1;//找孩子位置
			while (child &lt; _con.size())
			{
				//找大孩子
				if (child + 1 &lt; _con.size() &amp;&amp; _con[child+1] &gt; _con[child])
				{
					child++;
				}

				//if(_con[parent] &lt; _con[child])父亲比孩子小，父亲就要往下挪
				if (com(_con[parent], _con[child]))//使用仿函数比较
				{
					swap(_con[parent], _con[child]);//交换父亲和孩子
					parent = child;//孩子变父亲
					child = parent * 2 + 1;//重新计算孩子的位置
				}
				else
				{
					break;
				}
			}
		}

		//删除
		void pop()
		{
			swap(_con[0], _con[_con.size() - 1]);//交换堆顶元素和堆尾元素
			_con.pop_back();//删除堆顶元素			
			AdjustDown(0);//向下调整算法
		}

		//返回priority_queue第一个元素，即堆顶元素
		T top()
		{
			return _con[0];
		}

		//求priority_queue队列中元素个数
		size_t size()
		{
			return _con.size();
		}

		//判断priority_queue是否为空
		bool empty()
		{
			return _con.empty();
		}

	private:
		Container _con;
	};

}</code></pre>
<p>018-test.cpp</p>
<pre><code class="language-cpp">#include "018-priority_queue.h"
#include&lt;iostream&gt;

void test_priority_queue()
{
	delia::priority_queue&lt;int&gt; pq;
	pq.push(9);
	pq.push(26);
	pq.push(31);
	pq.push(3);
	pq.push(11);
	pq.push(1);
	pq.push(5);
	pq.push(39);
	pq.push(23);
	pq.push(18);

	std::cout &lt;&lt; "priority_queue:" &lt;&lt; std::endl;
	while (!pq.empty())
	{
		std::cout &lt;&lt; pq.top() &lt;&lt; std::endl;
		pq.pop();
	}
	std::cout &lt;&lt; std::endl;
}

void test_priority_queue_push()
{
	delia::priority_queue&lt;int&gt; pq;
	pq.push(9);
	pq.push(26);
	pq.push(31);
	pq.push(3);
	pq.push(11);
	pq.push(1);
	pq.push(5);
	pq.push(39);
	pq.push(23);
	pq.push(18);

	pq.push(83);

	std::cout &lt;&lt; "push:" &lt;&lt; std::endl;
	while (!pq.empty())
	{
		std::cout &lt;&lt; pq.top() &lt;&lt; std::endl;
		pq.pop();
	}
	std::cout &lt;&lt; std::endl;
}

void test_priority_queue_pop()
{
	delia::priority_queue&lt;int&gt; pq;
	pq.push(9);
	pq.push(26);
	pq.push(31);
	pq.push(3);
	pq.push(11);
	pq.push(1);
	pq.push(5);
	pq.push(39);
	pq.push(23);
	pq.push(18);

	std::cout &lt;&lt; "pop:" &lt;&lt; std::endl;
	pq.pop();
	while (!pq.empty())
	{
		std::cout &lt;&lt; pq.top() &lt;&lt; std::endl;
		pq.pop();
	}
	std::cout &lt;&lt; std::endl;
}

void test_priority_queue_top()
{
	delia::priority_queue&lt;int&gt; pq;
	pq.push(9);
	pq.push(26);
	pq.push(31);
	pq.push(3);
	pq.push(11);
	pq.push(1);
	pq.push(5);
	pq.push(39);
	pq.push(23);
	pq.push(18);

	std::cout &lt;&lt; "top:" &lt;&lt; std::endl;
	std::cout &lt;&lt; pq.top() &lt;&lt; std::endl;
	std::cout &lt;&lt; std::endl;
}

void test_priority_queue_size()
{
	delia::priority_queue&lt;int&gt; pq;
	pq.push(9);
	pq.push(26);
	pq.push(31);
	pq.push(3);
	pq.push(11);
	pq.push(1);
	pq.push(5);
	pq.push(39);
	pq.push(23);
	pq.push(18);

	std::cout &lt;&lt; "size:" &lt;&lt; std::endl;
	std::cout &lt;&lt; pq.size() &lt;&lt; std::endl;
	std::cout &lt;&lt; std::endl;
}

void test_priority_queue_empty()
{
	delia::priority_queue&lt;int&gt; pq;
	pq.push(9);
	pq.push(26);
	pq.push(31);
	pq.push(3);
	pq.push(11);
	pq.push(1);
	pq.push(5);
	pq.push(39);
	pq.push(23);
	pq.push(18);

	std::cout &lt;&lt; "empty:" &lt;&lt; std::endl;
	std::cout &lt;&lt; pq.empty() &lt;&lt; std::endl;
	std::cout &lt;&lt; std::endl;
}

int main()
{
	test_priority_queue();
	test_priority_queue_push();
	test_priority_queue_pop();
	test_priority_queue_top();
	test_priority_queue_size();
	test_priority_queue_empty();

	return 0;

}</code></pre>
<p>运行结果如下 </p>
<p><img alt="" height="373" src="image\f2aaa188aed541aeb89138c596f7d3de.png" width="231"/></p>
<p><img alt="" height="271" src="image\81c7520372f248bf84306a22969470d7.png" width="224"/></p>
<p></p>
</div>
</div>