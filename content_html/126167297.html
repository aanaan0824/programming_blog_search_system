<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<div class="img-center">
<figure class="image">
<img alt="" height="105" src="image\b4e6ca8983a34017be11d504193bfa0e.png" width="112"/>
<figcaption>
   篮球哥温馨提示：编程的同时不要忘记锻炼哦！
  </figcaption>
</figure>
</div>
<h1 style="text-align:center;">写代码就像圆周率，没有尽头</h1>
<hr/>
<p id="main-toc"><strong>目录</strong></p>
<p id="1%E3%80%81%E6%95%B0%E7%BB%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-toc" style="margin-left:0px;"><a href="#1%E3%80%81%E6%95%B0%E7%BB%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">1、数组的基本概念</a></p>
<p id="1.1%20%E6%88%91%E4%BB%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%95%B0%E7%BB%84%EF%BC%9F-toc" style="margin-left:40px;"><a href="#1.1%20%E6%88%91%E4%BB%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%95%B0%E7%BB%84%EF%BC%9F">1.1 我们为什么需要数组？</a></p>
<p id="1.2%20%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:40px;"><a href="#1.2%20%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96">1.2 数组的创建与初始化</a></p>
<p id="1.3%20%E6%95%B0%E7%BB%84%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px;"><a href="#1.3%20%E6%95%B0%E7%BB%84%E7%9A%84%E4%BD%BF%E7%94%A8">1.3 数组的使用</a></p>
<p id="1.4%20%E6%95%B0%E7%BB%84%E7%9A%84%E9%81%8D%E5%8E%86%C2%A0-toc" style="margin-left:40px;"><a href="#1.4%20%E6%95%B0%E7%BB%84%E7%9A%84%E9%81%8D%E5%8E%86%C2%A0">1.4 数组的遍历 </a></p>
<p id="2%E3%80%81%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%95%B0%E7%BB%84%E7%9A%84%E6%B7%B1%E5%85%A5%E8%AE%B2%E8%A7%A3-toc" style="margin-left:0px;"><a href="#2%E3%80%81%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%95%B0%E7%BB%84%E7%9A%84%E6%B7%B1%E5%85%A5%E8%AE%B2%E8%A7%A3">2、引用类型数组的深入讲解</a></p>
<p id="2.1%20%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3%20JVM%20%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83-toc" style="margin-left:40px;"><a href="#2.1%20%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3%20JVM%20%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83">2.1 简单了解 JVM 的内存分布</a></p>
<p id="2.2%20%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F%E4%B8%8E%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:40px;"><a href="#2.2%20%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F%E4%B8%8E%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB">2.2 基本类型变量与引用类型变量的区别</a></p>
<p id="2.3%20%E9%80%9A%E8%BF%87%E6%96%B9%E6%B3%95%E6%9B%B4%E6%B7%B1%E5%88%BB%E7%90%86%E8%A7%A3%E5%BC%95%E7%94%A8%E5%8F%98%E9%87%8F-toc" style="margin-left:40px;"><a href="#2.3%20%E9%80%9A%E8%BF%87%E6%96%B9%E6%B3%95%E6%9B%B4%E6%B7%B1%E5%88%BB%E7%90%86%E8%A7%A3%E5%BC%95%E7%94%A8%E5%8F%98%E9%87%8F">2.3 通过方法更深刻理解引用变量</a></p>
<p id="2.4%20%E6%95%B0%E7%BB%84%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC-toc" style="margin-left:40px;"><a href="#2.4%20%E6%95%B0%E7%BB%84%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC">2.4 数组作为函数返回值</a></p>
<p id="3%E3%80%81%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84-toc" style="margin-left:0px;"><a href="#3%E3%80%81%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84">3、二维数组</a></p>
<p id="3.1%20%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%C2%A0-toc" style="margin-left:40px;"><a href="#3.1%20%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%C2%A0">3.1 二维数组的概念和内存布局 </a></p>
<p id="3.2%20%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%C2%A0-toc" style="margin-left:40px;"><a href="#3.2%20%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%C2%A0">3.2 二维数组的定义和初始化 </a></p>
<p id="3.3%20%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86-toc" style="margin-left:40px;"><a href="#3.3%20%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86">3.3 二维数组遍历</a></p>
<p id="3.4%20%E4%B8%8D%E8%A7%84%E5%88%99%E7%9A%84%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84-toc" style="margin-left:40px;"><a href="#3.4%20%E4%B8%8D%E8%A7%84%E5%88%99%E7%9A%84%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84">3.4 不规则的二维数组</a></p>
<hr/>
<h1 id="1%E3%80%81%E6%95%B0%E7%BB%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span style="color:#ad720d;"><strong>1、数组的基本概念</strong></span></h1>
<h2 id="1.1%20%E6%88%91%E4%BB%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%95%B0%E7%BB%84%EF%BC%9F">1.1 我们为什么需要数组？</h2>
<p>假设说我们要存每个同学的期末考试总成绩，如果我们还不知道数组的话，那我们是不是得新建100个变量，而且赋值和打印也相当的麻烦， 而且我们发现成绩的数据类型都是一样的，所以就会有数组这个概念，数组即是相同类型元素的集合，而且是一块连续的存储空间，每个空间都有编号，也就是我们口中常说的数组下标。而且使用数组，也可以是代码变得更简化，方便的进行排序查找等，现在，我们就来进入数组的学习把：</p>
<h2 id="1.2%20%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96">1.2 数组的创建与初始化</h2>
<p>我们这期是由浅到深讲解的，所以在前边有一些不理解的问题，请坚持往后看，会得到解决的。</p>
<p>在Java中对数组的创建并初始化有两种方式，分别是静态初始化和动态初始化：</p>
<pre><code class="language-java">public static void arrayInit() {
        int[] array1 = { 1,2,3,4,5,6,7,8,9,10 }; //静态初始化
        int[] array2 = new int[] { 1,2,3,4,5,6,7,8,9,10 }; //静态初始化
    }</code></pre>
<p>这两种写法有什么不同呢？第一种虽然省去了 new int[ ]，但是在编译的时候还是会还原成第二种方式，这两种写法本质上没有区别，都是在JVM栈上开辟一个 array1和array2元素，同时也会在堆上开辟两个一维数组，这两个变量分别存这这两个数组的地址，当然，这里你不懂没关系，后面我们也会画图一一讲解到，你只需要知道，这两种定义并初始化的方式只是写法上的不同就可以了！</p>
<p><strong>那定义了数组但是不初始化呢？</strong></p>
<pre><code class="language-java">public static void arrayInit() {
        int[] array3 = new int[10]; //动态初始化
        int[] array4 = null;
    }</code></pre>
<p>如果是上面这种创建但是不初始化，array3 里面会默认初始化成0，也就是说，如果数组中存储的元素为基本类型，默认值为基本类型对对应的默认值0，像 array4 赋值成 null 这种情况，就可以理解成这个数组没有引用任何对象，这个地方听不懂没关系，往后看就能懂了。</p>
<table border="1" cellpadding="1" cellspacing="1" style="width:595px;"><thead><tr><th>类型</th><th style="width:342px;">默认值</th></tr></thead><tbody><tr><td>byte</td><td style="width:342px;"> <p>0</p> </td></tr><tr><td>short</td><td style="width:342px;">0</td></tr><tr><td>int</td><td style="width:342px;">0</td></tr><tr><td>long</td><td style="width:342px;">0L</td></tr><tr><td>float</td><td style="width:342px;">0.0f</td></tr><tr><td>double</td><td style="width:342px;">0.0</td></tr><tr><td>char</td><td style="width:342px;">/u0000</td></tr><tr><td>boolean</td><td style="width:342px;">false</td></tr></tbody></table>
<p>不知道学过C语言的小伙伴还记不记得，C语言数组是可以不完全初始化的，比如说你一个数组5个元素，你只初始化前三个元素，在C语言中后续未初始化的元素会默认补0，但是在Java中你就算完全初始化了，如果你指定了元素个数的话，也会报错，只有在使用 new int[10]，动态初始化的时候才能写明数组元素个数，你们也可以下来自己试试。</p>
<blockquote>
<p><strong>在Java的数组中，我们有几点需要注意：</strong></p>
<ul><li>数组 { } 里面的元素类型一定要跟 [ ] 前面的类型保持一致</li><li>静态初始化的时候不能指定长度，动态初始化的时候 new int[10]需要指定长度 </li><li>虽然没有指定数组长度，但是编译器在编译的时候会根据 { } 里面的元素个数来确定数组的长度</li><li>虽然Java数组可以写成跟C语言一样的写法 int array[ ]，但不推荐，因为这样语义不明确！</li><li>new int[n] ，[ ]中可以是变量</li></ul>
</blockquote>
<p><strong>这里有小伙伴就有个小问题了，如果我定义了但是没有初始化，我能不能在下面重新赋值呢？</strong></p>
<pre><code class="language-java">public static void arrayInit() {
        int[] array3;
        array3 = { 1,2,3,4,5 };
    }</code></pre>
<p>这样是绝对不可以的，虽然你现在可能不是很理解，但我们前面有提过，数组变量 array3 里面放的是地址，这个在下面我们会细讲。这里你知道即可。</p>
<p><strong>那如何正确的在定义之后初始化呢？或者重新赋值呢？</strong></p>
<pre><code class="language-java">public static void arrayInit() {
        int[] array1;
        array1 = new int[10];
        
        int[] array2;
        array2 = new int[]{ 1,2,3,4,5 };   
    }</code></pre>
<p>像如上代码这样是ok的，本质上其实就是在堆区创建了一个新对象，这个我们还是在后面细讲，这里让你们先见一见，为后面细节学习作铺垫。</p>
<h2 id="1.3%20%E6%95%B0%E7%BB%84%E7%9A%84%E4%BD%BF%E7%94%A8">1.3 数组的使用</h2>
<p>数组是定义好了，我们如何去使用他呢？在前面我们提到过，数组是一块连续的内存空间，都有对应的编号，也就是下标，我们就可以通过下标的方式快速访问数组的任意位置的元素：</p>
<pre><code class="language-java">public static void main(String[] args) {

        int[] array = { 1,2,3,4,5 };
        array[2] = 88;
        System.out.println(array[2]);
    }</code></pre>
<p>同时也可以对下标的值进行修改，但是这里我们要注意几点，数组的下标是从 0 开始的，所以最后一个元素下标应该是 n-1，也就是Java中大部分采用的都是左闭右开的，即：[ 0，n )</p>
<p>如果我们下标越界访问了，不用担心，程序会直接剖出下标越界异常，我们根据报错提示去找对应的位置即可。</p>
<p style="text-align:center;"><img alt="" src="image\1e98fdc25a40416796dbc96420372f04.png"/></p>
<h2 id="1.4%20%E6%95%B0%E7%BB%84%E7%9A%84%E9%81%8D%E5%8E%86%C2%A0">1.4 数组的遍历 </h2>
<p>在Java中对数组其实有三种遍历打印的方式，每一种的情况都会讲明优缺点，接着往下看：</p>
<p><span style="color:#fe2c24;"><strong>for 循环打印：</strong></span></p>
<pre><code class="language-java">public class TestDemo {
    public static void main(String[] args) {
        int[] array = { 1,2,3,4,5 };
        for (int i = 0; i &lt; array.length; i++) {
            System.out.print(array[i] + " ");
        }
        System.out.println();
    }
}
</code></pre>
<p>这种方式是很常规的通过下标遍历访问的方式，对于数组的长度我们可以通过，数组对象.length 来获取数组的长度。</p>
<p><span style="color:#fe2c24;"><strong>for-each 循环打印：</strong></span></p>
<pre><code class="language-java">public class TestDemo {
    public static void main(String[] args) {
        int[] array = { 1,2,3,4,5 };
        for (int a : array) {
            System.out.print(a + " ");
        }
        System.out.println();
    }
}</code></pre>
<p>这种打印方式呢，在 for 循环里冒号的左边必须是你要打印的数组里元素的类型定义的变量，右边则是你要打印数组的数组名，下面就可以通过你定义的变量进行打印了。for-each是for循环的另一种使用方式，他能在代码上更简洁，也可以避免循环条件和更新语句的书写错误，但是这样也有缺陷，比如说这种方式并不能拿到数组的下标。</p>
<p><span style="color:#fe2c24;"><strong>Arrays工具类打印</strong></span></p>
<pre><code class="language-java">public class TestDemo {
    public static void main(String[] args) {
        int[] array = { 1,2,3,4,5 };
        String ret = Arrays.toString(array); //既然返回的是字符串，我们就用字符串类型来接收
        System.out.println(ret);
        System.out.println(Arrays.toString(array)); //既然有返回值，那我们也可以直接链式访问
    }
}</code></pre>
<p>首先我们要介绍下Arrays，他是在 java.util 包下的一个工具类，里面定义了很多对数组的操作方法，而 Arrays.toString 他的作用是把数组转换成字符串并返回，所以严格意义上它并不是遍历数组，只是把数组转化成对应的字符串而已。</p>
<p><strong>以上三种方式各有优缺点，初学者结合实际情况作应用</strong></p>
<hr/>
<h1 id="2%E3%80%81%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%95%B0%E7%BB%84%E7%9A%84%E6%B7%B1%E5%85%A5%E8%AE%B2%E8%A7%A3"><span style="color:#ad720d;"><strong>2、引用类型数组的深入讲解</strong></span></h1>
<h2 id="2.1%20%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3%20JVM%20%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83">2.1 简单了解 JVM 的内存分布</h2>
<p>Java的程序需要运行在虚拟机上的，如果对于内存中的数据随意存储的话，那以后对内存管理起来将会是很麻烦的一件事，所以JVM也对所使用的内存按照不同的功能进行了划分：</p>
<p><img alt="" src="image\1526ad0d91564f61b9681b03662955ce.png"/></p>
<p>但是我们今天只重点关心堆和虚拟机栈这两块空间，在后续学习中会依次详细介绍这里面的内容：</p>
<p><strong>虚拟机栈：</strong>与方法调用相关的一些信息，每个方法在执行的时候都会先创建一个栈帧，栈帧中包含：局部变量，操作数栈，动态链接，返回地址，以及一些其他的信息，保存的都是与方法执行相关的一些信息，比如：局部变量，当方法运行结束了后，栈帧也被销毁，即栈帧中保存的数据也被销毁了</p>
<p><strong>堆：</strong>它是JVM管理的最大内存区域，使用 new 创建的对象都是在堆上保存的，堆是随着程序的开始而创建，随着程序的退出而销毁，堆中的数据只要还有在使用，就不会被销毁。</p>
<h2 id="2.2%20%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F%E4%B8%8E%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><strong>2.2 基本类型变量与引用类型变量的区别</strong></h2>
<p>对这个理解特别重要，很关系到你后面进行学习，首先我们要区别这个两个的区别，先说基本类型变量，这种变量中直接存放的是所对应的值，而引用类型创建的变量，一般称为对象的引用，这种变量里存储的是对象所在空间的地址，下面我们用一小段代码，并且画图让大家理解的更清楚：</p>
<pre><code class="language-java">public class TestDemo {
    public static void main(String[] args) {
        int a = 10;
        int b = 20;
        int[] array = { 1,2,3,4,5 };
    }
}</code></pre>
<p style="text-align:center;"><img alt="" src="image\b1e14355f4604aa68769733bb15e93dc.png"/></p>
<p>其实看到这张图，相信大家就能很好的理解了，其实我们引用变量并不是存储了对象本身，只是存储了对象的其实地址，那我们的 array 只是存储了在堆中开辟的一维数组的地址！并没有把整个数组都保存在变量中！通过该对象的地址，引用变量就可以去操作这个对象了！</p>
<h2 id="2.3%20%E9%80%9A%E8%BF%87%E6%96%B9%E6%B3%95%E6%9B%B4%E6%B7%B1%E5%88%BB%E7%90%86%E8%A7%A3%E5%BC%95%E7%94%A8%E5%8F%98%E9%87%8F">2.3 通过方法更深刻理解引用变量</h2>
<p>有了上面的认识，我们就要来理解下面这两个方法的作用了，相信你看完会有更深刻的认识：</p>
<p><img alt="" src="image\4a72943ffe4c4790a9a4fef961d34cc7.png"/></p>
<p>是不是结果可能跟你想得有点不一样呢？不用担心，我们来一个个分析下：</p>
<p>首先我们执行的是 func1 我们知道 array 变量中存的是一个对象的地址，那么通过传参给 func1 的 arr1，首先要建立栈帧，把 array 存的地址拷贝到 arr1 当中，这样一来就相当于 arr1 也指向了那个变量，但是我们又 new 了一个对象，并把新对象的地址赋值给了 arr1，相当于 arr1  原来存放的地址已经被替换了，也就说 arr1 指向了一个新的对象，因为只是把 array 存的地址拷贝给了 arr1 所以执行完 func1 这个方法之后，array 并不会受任何影响，当方法结束，arr2 变量销毁，因为arr2 销毁之后没有变量接着引用在 func1 中 new 的新对象，所以此时新的对象就被 JVM 回收了！</p>
<p>当我们执行完 func1 时，就是我们说的结果，所以 array 的值不受任何影响！</p>
<p style="text-align:center;"><img alt="" src="image\499ef12ed015487b9a77be9f3b193f50.png"/></p>
<p>我们接着再来看执行 func2 之后的结果，首先前半部分与 func1 一样，都是传递的 array 指向对象的地址，但是 func2 里面语句是直接对 arr2 中对象的地址进行下标访问，修改了 [1] 下标处的值，因为本质 array 和 arr2 引用的都是同一个对象，当 arr2 修改了对象的值，所以当函数结束后接着打印 array 指向对象的值肯定也被修改了！方法结束，arr2 被销毁，但是 arr2 指向的对象仍然被 array 指向着，所以JVM不会回收此时的对象！</p>
<p style="text-align:center;"><img alt="" src="image\6eb2d882388d4b5782f129d6f676b13e.png"/></p>
<blockquote>
<p>看到这，你肯定有了更深刻的理解，前面有疑问的地方肯定得到了解决，所谓的 "引用" 本质上只是存了一个地址，Java将数组设定成引用类型，这样后续进行数组传参，其实只是将数组的地址传入到形参当中，这样就可以避免对整个数组的拷贝！</p>
</blockquote>
<p><strong><span style="color:#fe2c24;">在我们目前认识中，如果对象没有被引用，则会自动回收，所以不用考虑内存泄漏的问题 </span></strong></p>
<h2 id="2.4%20%E6%95%B0%E7%BB%84%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC">2.4 数组作为函数返回值</h2>
<p>假设这里我们有一个题，需要实现一个方法，这个方法需要获取斐波那契数列的前 n 项，需要返回一个数组回来，本质其实就是返回数组的地址，如何实现呢？</p>
<pre><code class="language-java">public static int[] fib(int n) {
        if (n &lt;= 0) {
            return null;
        }
        int[] array = new int[n];
        array[0] = array[1] = 1;
        for (int i = 2; i &lt; n; i++) {
            array[i] = array[i - 1] + array[i - 2];
        }
        return array;
    }
    public static void main(String[] args) {
        int[] array = fib(8);
        System.out.println(Arrays.toString(array));
    }</code></pre>
<p>当然这个方法如果 n 为1 就会越界，这个下来可以自己优化下，来到这里我们就来介绍下Arrays这个工具类里面的一些方法了： 像一些将数组转换成字符串，数组二分查找，数组排序等等，可以下来查阅下帮助手册，这里我就不细说了，交给大家自己去扩展了，如果以后用到，我会进行说明。</p>
<hr/>
<h1 id="3%E3%80%81%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span style="color:#ad720d;"><strong>3、二维数组</strong></span></h1>
<h2 id="3.1%20%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%C2%A0">3.1 二维数组的概念和内存布局 </h2>
<p>这里我们一定要有一个概念，二维数组是一个特殊的一维数组，如何理解呢？用文字来说，二维数组的每个元素是一维数组，也就是说，二维数组的每个元素里面放的是一维数组的地址！</p>
<p>相信听完上面的话，大家可能不是很理解，那我们就定义一个二维数组，并画图：</p>
<pre><code class="language-java">public static void main(String[] args) {
        int[][] array = { {1,2,3}, {4,5,6} };
    }</code></pre>
<p><img alt="" src="image\a8ce12ebb80f49ff8b8ceb9e2090831d.png"/>这里就很清晰明了了，图中也能看到，二维数组本质就是一个一维数组，只不过这个一维数组的每个元素存的是地址而已！</p>
<h2 id="3.2%20%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%C2%A0">3.2 二维数组的定义和初始化 </h2>
<p> 当然，二维数组和一维数组一样，同样的三种定义方式：</p>
<pre><code class="language-java">int[][] array1 = { {1,2,3}, {4,5,6} }; //两行三列的二维数组
int[][] array2 = new int[][]{ {1,2,3}, {4,5,6} };
int[][] array3 = new int[2][3];</code></pre>
<p>如果只是单纯的 int[][] array; 这样数组里面没有任何引用对象，并不能直接使用未引用对象的数组，如果不引用最好置null</p>
<h2 id="3.3%20%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86">3.3 二维数组遍历</h2>
<p><span style="color:#fe2c24;"><strong>for 循环打印：</strong></span></p>
<pre><code class="language-java">public class TestDemo {
    public static void main(String[] args) {
        int[][] array1 = { {1,2,3}, {4,5,6} }; //两行三列的二维数组
        for (int i = 0; i &lt; array1.length; i++) {
            for (int j = 0; j &lt; array1[i].length; j++) {
                System.out.print(array1[i][j] + " ");
            }
            System.out.println();
        }
        System.out.println();
    }
}</code></pre>
<p>这里第一个 for 里面的长度求的是 array1.length，因为它本身就是一个特殊一维数组，这样求出的就是它的行，第二个for array1[i].length，自然求得就是每一行一维数组长度了</p>
<p><span style="color:#fe2c24;"><strong>for-each 循环打印：</strong></span></p>
<pre><code class="language-java">public class TestDemo {
    public static void main(String[] args) {
        int[][] array1 = { {1,2,3}, {4,5,6} }; //两行三列的二维数组
        for (int[] arr : array1) { //二维数组的每个元素是一维数组，所以每个元素的类型是int[]
            for (int a : arr) { //arr是一维数组，每个数组的元素的int
                System.out.print(a + " ");
            }
            System.out.println();
        }
    }
}</code></pre>
<p>Arrays 工具类有个方法也可以打印二维数组，是Arrays.deepToString，这个方法也是打印二维数组的但只能在一行显示，感兴趣的可以下来自己实验下。</p>
<h2 id="3.4%20%E4%B8%8D%E8%A7%84%E5%88%99%E7%9A%84%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84">3.4 不规则的二维数组</h2>
<p>在Java中，二维数组的列可以省略，也就是把二维数组看成一个特殊的一维数组的每个元素指向的一维数组是可以元素个数不同的，如何理解这句话呢？我们还是一样通过一小段并且以画图的形式给大家讲解：</p>
<pre><code class="language-java">int[][] array = new int[2][];
array[0] = new int[3];
array[1] = new int[2];</code></pre>
<p><img alt="" src="image\973d91890e8e4b4e8cf526e9ffd51d79.png"/>当然，他的遍历方法是跟普通二维数组一样的， 这里我就不多说，自己摸索，实在不懂可以问下博主。</p>
<hr/>
<p class="img-center"><img alt="" height="179" src="image\27a00978e7f44ff1a9982a17c16ad3ce.png" width="151"/></p>
<p style="text-align:center;"><strong>下期预告：【Java SE】类和对象</strong> </p>
</div>
</div>