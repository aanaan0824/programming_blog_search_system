<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<p id="main-toc"><strong>目录</strong></p>
<p id="-toc" style="margin-left:0px;"></p>
<p id="list%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%E6%80%BB%E8%A7%88%EF%BC%9A-toc" style="margin-left:0px;"><a href="#list%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%E6%80%BB%E8%A7%88%EF%BC%9A">list的模拟实现总览：</a></p>
<p id="1.%E8%8A%82%E7%82%B9%E7%B1%BB%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><a href="#1.%E8%8A%82%E7%82%B9%E7%B1%BB%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0">1.节点类的模拟实现</a></p>
<p id="%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">构造函数</a></p>
<p id="2.%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%B1%BB%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><a href="#2.%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%B1%BB%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0">2.迭代器类的模拟实现</a></p>
<p id="%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%B1%BB%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E-toc" style="margin-left:40px;"><a href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%B1%BB%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E">迭代器类的模板参数说明</a></p>
<p id="%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">构造函数</a></p>
<p id="%2B%2B%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD-toc" style="margin-left:40px;"><a href="#%2B%2B%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD">++运算符的重载</a></p>
<p id="--%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD-toc" style="margin-left:40px;"><a href="#--%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD">--运算符的重载</a></p>
<p id="%3D%3D%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD-toc" style="margin-left:40px;"><a href="#%3D%3D%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD">==运算符的重载</a></p>
<p id="!%3D%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD-toc" style="margin-left:40px;"><a href="#!%3D%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD">!=运算符的重载</a></p>
<p id="*%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD-toc" style="margin-left:40px;"><a href="#*%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD">*运算符的重载</a></p>
<p id="%C2%A0-%3E%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD-toc" style="margin-left:40px;"><a href="#%C2%A0-%3E%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD"> -&gt;运算符的重载</a></p>
<p id="list%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><a href="#list%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0">list的模拟实现</a></p>
<p id="%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0">默认成员函数</a></p>
<p id="%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">构造函数</a></p>
<p id="%C2%A0%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%88%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%89%88%E6%9C%AC%EF%BC%89-toc" style="margin-left:40px;"><a href="#%C2%A0%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%88%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%89%88%E6%9C%AC%EF%BC%89"> 拷贝构造函数（迭代器版本）</a></p>
<p id="%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0(%E7%8E%B0%E4%BB%A3%E5%86%99%E6%B3%95)-toc" style="margin-left:40px;"><a href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%28%E7%8E%B0%E4%BB%A3%E5%86%99%E6%B3%95%29">拷贝构造函数(现代写法)</a></p>
<p id="%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0%EF%BC%88%E7%8E%B0%E4%BB%A3%E5%86%99%E6%B3%95%EF%BC%89-toc" style="margin-left:40px;"><a href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0%EF%BC%88%E7%8E%B0%E4%BB%A3%E5%86%99%E6%B3%95%EF%BC%89">赋值运算符重载函数（现代写法）</a></p>
<p id="%C2%A0%E5%85%B6%E4%BB%96%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#%C2%A0%E5%85%B6%E4%BB%96%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"> 其他构造函数</a></p>
<p id="%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0">析构函数</a></p>
<p id="%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0">迭代器相关函数</a></p>
<p id="%C2%A0%E8%AE%BF%E9%97%AE%E5%AE%B9%E5%99%A8%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#%C2%A0%E8%AE%BF%E9%97%AE%E5%AE%B9%E5%99%A8%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"> 访问容器相关函数</a></p>
<p id="%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E5%87%BD%E6%95%B0">插入、删除函数</a></p>
<p id="insert%EF%BC%88%E5%89%8D%E6%8F%92%EF%BC%89-toc" style="margin-left:40px;"><a href="#insert%EF%BC%88%E5%89%8D%E6%8F%92%EF%BC%89">insert（前插）</a></p>
<p id="erase-toc" style="margin-left:40px;"><a href="#erase">erase</a></p>
<p id="push_back%E5%92%8Cpop_back-toc" style="margin-left:40px;"><a href="#push_back%E5%92%8Cpop_back">push_back和pop_back</a></p>
<p id="push_front%E5%92%8Cpop_front-toc" style="margin-left:40px;"><a href="#push_front%E5%92%8Cpop_front">push_front和pop_front</a></p>
<hr id="hr-toc"/>
<p></p>
<p><img alt="" height="494" src="image\326dd62e720947b7a775c8a12c753636.png" width="749"/></p>
<p></p>
<h1 id="list%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%E6%80%BB%E8%A7%88%EF%BC%9A">list的模拟实现总览：</h1>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;

namespace lxy
{
	//模拟实现list当中的结点类
	template&lt;class T&gt;
	struct ListNode
	{
		//构造函数
		ListNode(const T&amp; data = T());
		//成员变量
		T _data;			//数据域
		ListNode&lt;T&gt;* _next;	//后继指针
		ListNode&lt;T&gt;* _prev;	//前驱指针
	};

	//模拟实现list迭代器
	template&lt;class T,class Ref,class Ptr&gt;
	struct __list_iterator
	{
		typedef ListNode&lt;T&gt; Node;
		typedef __list_iterator&lt;T, Ref, Ptr&gt; self;

		//构造函数
		__list_iterator(Node* x);

		//各种运算符重载函数
		self&amp; operator++();
		self&amp; operator--();
		self operator++(int);
		self operator--(int);
		bool operator==(const self&amp; it) const;
		bool operator!=(const self&amp; it) const;
		Ref operator*();
		Ptr operator-&gt;();

		//成员变量
		Node* _node;
	};


	//模拟实现list
	template&lt;class T&gt;
	class list
	{
	public:
		typedef ListNode&lt;T&gt; Node;
		typedef __list_iterator&lt;T, T&amp;, T*&gt; iterator;
		typedef __list_iterator&lt;T, const T&amp;, const  T*&gt; const_iterator;
		
		//默认成员函数
		list();
		list(const list&lt;T&gt;&amp; lt);
		list&lt;T&gt;&amp; operator=(const list&lt;T&gt;&amp; lt);
		~list();

		//迭代器相关函数
		iterator begin();
		iterator end();
		const_iterator begin() const;
		const_iterator end() const;

		//访问容器相关函数
		T&amp; front();
		T&amp; back();
		const T&amp; front() const;
		const T&amp; back() const;

		//插入、删除函数
		iterator insert(iterator pos, const T&amp; x);
		iterator erase(iterator pos);
		void push_back(const T&amp; x);
		void pop_back();
		void push_front(const T&amp; x);
		void pop_front();

		//其他函数
		size_t size() const;
		void resize(size_t n, const T&amp; val = T());
		void clear();
		bool empty() const;
		void swap(list&lt;T&gt;&amp; lt);

	private:
		//指向链表头结点的指针
		Node* _head;
	};
}</code></pre>
<h1 id="1.%E8%8A%82%E7%82%B9%E7%B1%BB%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0">1.节点类的模拟实现</h1>
<pre><code class="language-cpp">	template&lt;class T&gt;
	struct ListNode
	{
		//构造函数
		ListNode(const T&amp; data = T());
		//成员变量
		T _data;			//数据域
		ListNode&lt;T&gt;* _next;	//后继指针
		ListNode&lt;T&gt;* _prev;	//前驱指针
	};
</code></pre>
<p class="img-center"><img alt="" src="image\a54ae561a0b06a20d0d9b6fd46ca795b.png"/></p>
<blockquote>
<p>list是一个带头双向循环链表，故先实现一个结点类。</p>
</blockquote>
<h2 id="%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">构造函数</h2>
<pre><code class="language-cpp">		ListNode(const T&amp; data = T())
			:_next(nullptr)
			, _prev(nullptr)
			, _data(data)
		{ }
</code></pre>
<p> <strong>注意：</strong> 若构造结点时未传入数据，则默认以list容器所存储类型的默认构造函数所构造出来的值为传入数据。</p>
<h1 id="2.%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%B1%BB%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0">2.迭代器类的模拟实现</h1>
<pre><code class="language-cpp">	//模拟实现list迭代器
	template&lt;class T,class Ref,class Ptr&gt;
	struct __list_iterator
	{
		typedef ListNode&lt;T&gt; Node;
		typedef __list_iterator&lt;T, Ref, Ptr&gt; self;

		//构造函数
		__list_iterator(Node* x);

		//各种运算符重载函数
		self&amp; operator++();
		self&amp; operator--();
		self operator++(int);
		self operator--(int);
		bool operator==(const self&amp; it) const;
		bool operator!=(const self&amp; it) const;
		Ref operator*();
		Ptr operator-&gt;();

		//成员变量
		Node* _node;
	};
</code></pre>
<p>对于list来说，其各个结点在内存当中的位置是随机的，并不是连续的，我们不能仅通过结点指针的自增、自减以及解引用等操作对相应结点的数据进行操作。迭代器让使用者可以不必关心容器的底层实现，可以用简单统一的方式对容器内的数据进行访问。</p>
<blockquote>
<p> list迭代器类，<strong>实际上就是对结点指针进行了封装，对其各种运算符进行了重载</strong>，使得结点指针的各种行为看起来和普通指针一样。</p>
</blockquote>
<h2 id="%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%B1%BB%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E">迭代器类的模板参数说明</h2>
<pre><code class="language-cpp">	template&lt;class T,class Ref,class Ptr&gt;
</code></pre>
<p>在list的模拟实现当中，typedef了两个迭代器类型，普通迭代器和const迭代器。</p>
<pre><code class="language-cpp">		typedef __list_iterator&lt;T, T&amp;, T*&gt; iterator;
		typedef __list_iterator&lt;T, const T&amp;, const  T*&gt; const_iterator;
</code></pre>
<p>可知：Ref代表<strong>引用</strong>类型，Ptr代表<strong>指针</strong>类型。</p>
<p>若该迭代器类不设计三个模板参数，那么就不能很好的区分普通迭代器和const迭代器。</p>
<h2>构造函数</h2>
<p>对结点指针进行了封装，封装成迭代器。</p>
<pre><code class="language-cpp">		__list_iterator(Node* x)
			:_node(x)
		{}
</code></pre>
<h2 id="%2B%2B%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD">++运算符的重载</h2>
<p>前置++，后置++</p>
<p>迭代器++，访问下一个节点</p>
<pre><code class="language-cpp">		// ++it
		self&amp; operator++()
		{
			_node = _node-&gt;_next;
			return *this;
		}

		// it++
		self operator++(int)
		{
			self tmp(*this);
			_node = _node-&gt;_next;
			return tmp;
		}
</code></pre>
<p><strong>说明：</strong> self是当前迭代器对象的类型：</p>
<pre><code class="language-cpp">		typedef __list_iterator&lt;T, Ref, Ptr&gt; self;
</code></pre>
<h2 id="--%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD">--运算符的重载</h2>
<p>前置--，后置--</p>
<p>迭代器--，访问上一个节点</p>
<pre><code class="language-cpp">		// --it
		self&amp; operator--()
		{
			_node = _node-&gt;_prev;
			return *this;
		}

		// it--
		self operator--(int)
		{
			self tmp(*this);
			_node = _node-&gt;_prev;
			return tmp;
		}
</code></pre>
<h2 id="%3D%3D%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD">==运算符的重载</h2>
<p>判断两个迭代器当中的结点指针的指向是否相同，注意加上const</p>
<pre><code class="language-cpp">		bool operator!=(const self&amp; it) const
		{
			return _node != it._node;
		}
</code></pre>
<h2 id="!%3D%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD">!=运算符的重载</h2>
<p>判断两个迭代器当中的结点指针的指向是否不同，注意加上const</p>
<pre><code class="language-cpp">		bool operator==(const self&amp; it) const
		{
			return _node != it._node;
		}
</code></pre>
<h2 id="*%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD">*运算符的重载</h2>
<p>*运算符得到该位置的数据内容，并且<strong>返回引用</strong></p>
<pre><code class="language-cpp">		Ref operator*()
		{
			return _node-&gt;_data;
		}
</code></pre>
<h2 id="%C2%A0-%3E%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD"> -&gt;运算符的重载</h2>
<p>某些情景下，我们使用迭代器的时候可能会用到-&gt;运算符。</p>
<p>当list容器当中的每个结点存储的<strong>不是内置类型，而是自定义类型</strong>，例如日期类，那么当我们拿到一个位置的迭代器时，我们可能会使用-&gt;运算符访问Date的成员：</p>
<pre><code class="language-cpp">	void test()
	{
		list&lt;Date&gt; lt;
		lt.push_back(Date(2022, 3, 12));
		lt.push_back(Date(2022, 3, 13));
		lt.push_back(Date(2022, 3, 14));

		list&lt;Date&gt;::iterator it = lt.begin();
		while (it != lt.end())
		{
			//cout &lt;&lt; (*it)._year &lt;&lt; "/" &lt;&lt; (*it)._month &lt;&lt; "/" &lt;&lt; (*it)._day &lt;&lt; endl;
			cout &lt;&lt; it-&gt;_year &lt;&lt; "/" &lt;&lt; it-&gt;_month &lt;&lt; "/" &lt;&lt; it-&gt;_day &lt;&lt; endl;

			++it;
		}
		cout &lt;&lt; endl;
	}
</code></pre>
<p> <strong>注意：</strong> 使用pos-&gt;_year这种访问方式时，需要将日期类的成员变量设置为公有。</p>
<p>对于-&gt;运算符的重载，我们直接<strong>返回结点当中所存储数据的地址</strong>即可。</p>
<pre><code class="language-cpp">		Ptr operator-&gt;()
		{
			return &amp;_node-&gt;_data;
		}
</code></pre>
<p>这里本来是应该有两个-&gt;的，第一个箭头是pos -&gt;去调用重载的operator-&gt;返回Date* 的指针，第二个箭头是Date* 的指针去访问对象当中的成员变量_year。</p>
<p>但是一个地方出现两个箭头，程序的可读性太差了，所以编译器做了特殊识别处理，为了增加程序的可读性，省略了一个箭头。</p>
<h1 id="list%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0">list的模拟实现</h1>
<h2 id="%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0">默认成员函数</h2>
<h2>构造函数</h2>
<p>list是一个<strong>带头双向循环链表</strong>，在构造一个list对象时，申请一个头结点，并让其前驱指针和后继指针都指向自己即可。</p>
<p><img alt="" height="154" src="image\ace70fb6ec8f448586f5f2bc7cd5c221.png" width="372"/></p>
<pre><code class="language-cpp">		list()
		{
			_head = new Node();
			_head-&gt;_next = _head;
			_head-&gt;_prev = _head;
		}
</code></pre>
<h2 id="%C2%A0%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%88%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%89%88%E6%9C%AC%EF%BC%89"> 拷贝构造函数（迭代器版本）</h2>
<p>先申请一个头节点，再遍历一个范围，push进去</p>
<p>说明：push_back函数稍后讲解。</p>
<pre><code class="language-cpp">		//list lst2(lst1.begin(),lst1.end());
        template&lt;class InputIterator&gt;
		list(InputIterator first, InputIterator last)
		{
			_head = new Node();
			_head-&gt;_next = _head;
			_head-&gt;_prev = _head;
			while (first != last)
			{
				push_back(*first);
				++first;
			}
		}
</code></pre>
<h2 id="%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0(%E7%8E%B0%E4%BB%A3%E5%86%99%E6%B3%95)">拷贝构造函数(现代写法)</h2>
<p>先用<strong>迭代器版本构造函数</strong>构造tmp，再<strong>交换头指针指向位置</strong>。</p>
<pre><code class="language-cpp">		// lt2(lt1)
		list(const list&lt;T&gt;&amp; lt)
		{
			_head = new Node();
			_head-&gt;_next = _head;
			_head-&gt;_prev = _head;

			list&lt;T&gt; tmp(lt.begin(), lt.end());
			std::swap(_head, tmp._head);
		}
</code></pre>
<h2 id="%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0%EF%BC%88%E7%8E%B0%E4%BB%A3%E5%86%99%E6%B3%95%EF%BC%89">赋值运算符重载函数（现代写法）</h2>
<p>利用编译器机制，故意<strong>不使用引用接收参数</strong>，通过编译器自动调用list的拷贝构造函数构造出来一个list对象，然后调用swap函数将原容器与该list对象进行交换即可。</p>
<pre><code class="language-cpp">		// lt2 = lt1
		list&lt;T&gt;&amp; operator=(list&lt;T&gt; lt)
		{
			std::swap(_head, lt._head);
			return *this;
		}
</code></pre>
<h2 id="%C2%A0%E5%85%B6%E4%BB%96%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"> 其他构造函数</h2>
<p>使用案例：</p>
<p>构造一个list：1，1，1，1，1</p>
<p>构造一个list含5个Date类型。</p>
<p><strong>注意：</strong></p>
<p><img alt="" height="71" src="image\0027640826944b009a553969a14cd267.png" width="738"/></p>
<p> class InputIterator应该为<strong>迭代器类型</strong>，但是如果</p>
<p>list&lt;int&gt; lt2(5, 1);</p>
<p>则会识别为<strong>int</strong>类型，所以写出带<strong>int</strong>的构造函数，编译器会优先选择。 </p>
<pre><code class="language-cpp">		// list&lt;Date&gt; lt1(5, Date(2022, 3, 15));
		// list&lt;int&gt; lt2(5, 1);
		list(int n, const T&amp; val = T())
		{
			_head = new Node();
			_head-&gt;_next = _head;
			_head-&gt;_prev = _head;
			for (int i = 0; i &lt; n; ++i)
			{
				push_back(val);
			}
		}

		list(size_t n, const T&amp; val = T())
		{
			_head = new Node();
			_head-&gt;_next = _head;
			_head-&gt;_prev = _head;
			for (size_t i = 0; i &lt; n; ++i)
			{
				push_back(val);
			}
		}
</code></pre>
<h2 id="%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0">析构函数</h2>
<p>首先说明：clear 函数（2钟写法），erase函数稍后解析。</p>
<pre><code class="language-cpp">void clear()
{
	iterator it = begin();
	while (it != end())
	{
		iterator del = it++;    //迭代器前进
		delete del._node;       //删除当前位置数据
	}

	_head-&gt;_next = _head;
	_head-&gt;_prev = _head;
}

void clear()
{
	iterator it = begin();
	while (it != end())
	{
		erase(it++);
	}
}</code></pre>
<p><strong>析构函数：</strong>首先调用clear函数清理容器当中的数据，然后将头结点释放，最后将头指针置空即可。</p>
<pre><code class="language-cpp">		~list()
		{
			clear();

			delete _head;
			_head = nullptr;
		}
</code></pre>
<h2 id="%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0">迭代器相关函数</h2>
<p><strong>begin和end：</strong>begin函数返回的是第一个有效数据的迭代器，end函数返回的是最后一个有效数据的下一个位置的迭代器。即begin指向首元素，end指向尾后。</p>
<p>对于list这个带头双向循环链表来说：</p>
<p><img alt="" height="219" src="image\b209df78e7cf4978a73feb8df2e1affc.png" width="876"/></p>
<p>说明：</p>
<pre><code class="language-cpp">typedef __list_iterator&lt;T, T&amp;, T*&gt; iterator;
typedef __list_iterator&lt;T, const T&amp;, const T*&gt; const_iterator;
</code></pre>
<p><strong>并且迭代器就是对节点指针的封装。</strong></p>
<pre><code class="language-cpp">
iterator begin()
{
	return iterator(_head-&gt;_next);
}

iterator end()
{
	return iterator(_head);
}

const_iterator begin() const
{
	return const_iterator(_head-&gt;_next);
}

const_iterator end() const
{
	return const_iterator(_head);
}</code></pre>
<h2 id="%C2%A0%E8%AE%BF%E9%97%AE%E5%AE%B9%E5%99%A8%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"> 访问容器相关函数</h2>
<p>front和back函数分别用于获取第一个有效数据和最后一个有效数据，并且返回引用。</p>
<pre><code class="language-cpp">T&amp; front()
{
	return *begin(); //返回第一个有效数据的引用
}
T&amp; back()
{
	return *(--end()); //返回最后一个有效数据的引用
}
</code></pre>
<p>const版本不再赘述。</p>
<h2 id="%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E5%87%BD%E6%95%B0">插入、删除函数</h2>
<p><strong>核心函数：insert函数  erase函数，其他函数复用insert和erase得到</strong></p>
<h2 id="insert%EF%BC%88%E5%89%8D%E6%8F%92%EF%BC%89">insert（前插）</h2>
<p>插入后返回指向newNode的迭代器。</p>
<pre><code class="language-cpp">		// 这里insert以后，pos不失效
		iterator insert(iterator pos, const T&amp; x)
		{
			Node* cur = pos._node;
			Node* prev = cur-&gt;_prev;
			Node* newnode = new Node(x);

			prev-&gt;_next = newnode;
			newnode-&gt;_prev = prev;
			newnode-&gt;_next = cur;
			cur-&gt;_prev = newnode;

			return iterator(newnode);
		}
</code></pre>
<h2 id="erase">erase</h2>
<pre><code class="language-cpp">		// 这里erase以后，pos失效
		iterator erase(iterator pos)
		{
			assert(pos != end());

			Node* prev = pos._node-&gt;_prev;
			Node* next = pos._node-&gt;_next;
			delete pos._node;
			prev-&gt;_next = next;
			next-&gt;_prev = prev;

			return iterator(next);
		}
</code></pre>
<p>删除后返回下一个位置的迭代器</p>
<h2 id="push_back%E5%92%8Cpop_back">push_back和pop_back</h2>
<p><strong>复用insert、erase</strong></p>
<pre><code class="language-cpp">//尾插
void push_back(const T&amp; x)
{
	insert(end(), x); //在头结点前插入结点
}
//尾删
void pop_back()
{
	erase(--end()); //删除头结点的前一个结点
}
</code></pre>
<h2 id="push_front%E5%92%8Cpop_front">push_front和pop_front</h2>
<p><strong>复用insert、erase</strong></p>
<pre><code class="language-cpp">//头插
void push_front(const T&amp; x)
{
	insert(begin(), x); //在第一个有效结点前插入结点
}
//头删
void pop_front()
{
	erase(begin()); //删除第一个有效结点
}
</code></pre>
<h2>其他函数</h2>
<h3>size</h3>
<pre><code class="language-cpp">size_t size() const
{
	size_t sz = 0; //统计有效数据个数
	const_iterator it = begin(); //获取第一个有效数据的迭代器
	while (it != end()) //通过遍历统计有效数据个数
	{
		sz++;
		it++;
	}
	return sz; //返回有效数据个数
}
</code></pre>
<p></p>
<p></p>
<p></p>
<p></p>
</div>
</div>