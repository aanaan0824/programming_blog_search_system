<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<p id="main-toc"><strong>目录</strong></p>
<p id="1%E3%80%81%E6%A6%82%E8%BF%B0-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E6%A6%82%E8%BF%B0">1、概述</a></p>
<p id="2%E3%80%81%E8%B0%83%E7%94%A8sort%E5%87%BD%E6%95%B0%E5%AF%B9%E5%88%97%E8%A1%A8%E5%85%83%E7%B4%A0%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E8%B0%83%E7%94%A8sort%E5%87%BD%E6%95%B0%E5%AF%B9%E5%88%97%E8%A1%A8%E5%85%83%E7%B4%A0%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F">2、调用sort函数对列表元素进行排序</a></p>
<p id="3%E3%80%81%E8%B0%83%E7%94%A8count_if%E6%9F%A5%E6%89%BE%E6%BB%A1%E8%B6%B3%E6%9D%A1%E4%BB%B6%E7%9A%84%E5%85%83%E7%B4%A0%E4%B8%AA%E6%95%B0-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E8%B0%83%E7%94%A8count_if%E6%9F%A5%E6%89%BE%E6%BB%A1%E8%B6%B3%E6%9D%A1%E4%BB%B6%E7%9A%84%E5%85%83%E7%B4%A0%E4%B8%AA%E6%95%B0">3、调用count_if查找满足条件的元素个数</a></p>
<p id="4%E3%80%81%E8%B0%83%E7%94%A8find_if%E5%87%BD%E6%95%B0%E6%89%BE%E5%88%B0%E7%9B%AE%E6%A0%87%E5%85%83%E7%B4%A0%E7%9A%84%E4%BF%A1%E6%81%AF-toc" style="margin-left:40px;"><a href="#4%E3%80%81%E8%B0%83%E7%94%A8find_if%E5%87%BD%E6%95%B0%E6%89%BE%E5%88%B0%E7%9B%AE%E6%A0%87%E5%85%83%E7%B4%A0%E7%9A%84%E4%BF%A1%E6%81%AF">4、调用find_if函数找到目标元素的信息</a></p>
<p id="5%E3%80%81%E8%B0%83%E7%94%A8remove_copy_if%E5%87%BD%E6%95%B0%E6%90%9C%E7%B4%A2%E6%BB%A1%E8%B6%B3%E6%9D%A1%E4%BB%B6%E7%9A%84%E5%A4%9A%E4%B8%AA%E5%85%83%E7%B4%A0-toc" style="margin-left:40px;"><a href="#5%E3%80%81%E8%B0%83%E7%94%A8remove_copy_if%E5%87%BD%E6%95%B0%E6%90%9C%E7%B4%A2%E6%BB%A1%E8%B6%B3%E6%9D%A1%E4%BB%B6%E7%9A%84%E5%A4%9A%E4%B8%AA%E5%85%83%E7%B4%A0">5、调用remove_copy_if函数搜索满足条件的多个元素</a></p>
<p id="6%E3%80%81%E6%80%BB%E7%BB%93-toc" style="margin-left:40px;"><a href="#6%E3%80%81%E6%80%BB%E7%BB%93">6、总结</a></p>
<hr id="hr-toc"/>
<p><a class="link-info has-card" href="https://blog.csdn.net/chenlycly/article/details/124272585" title="VC++常用功能开发汇总（专栏文章列表，欢迎订阅，持续更新...）"><span class="link-card-box"><span class="link-title">VC++常用功能开发汇总（专栏文章列表，欢迎订阅，持续更新...）</span><span class="link-link"><img alt="" class="link-link-icon" src="image\icon-default.png"/>https://blog.csdn.net/chenlycly/article/details/124272585</span></span></a>       STL（Standard Templete Library）活动模板库已被广泛地应用于各种C++程序的开发中，STL中vector、list、map等列表极大地方便了我们日常的开发，不再需要我们去实现链表等数据结构，使用这些列表能基本能解决开发过程中遇到的各种问题。今天我们就来讲讲如何使用STL内置的算法函数。</p>
<p class="img-center"><img alt="" height="189" src="image\5b1faeb3a3164d7792d3199f4d709c94.png" width="328"/></p>
<h2 id="1%E3%80%81%E6%A6%82%E8%BF%B0">1、概述</h2>
<p>       STL中提供了sort、conut、count_if、find、find_if、remove_copy、remove_copy_if等多个算法函数，我们不需要再自己去实现搜索或排序算法，使用STL提供的这些算法函数就能轻易地完成对应的任务。此外，当vector、list等STL列表中存放的数据量比较大时，直接使用for循环去遍历列表，去按条件搜索，效率就是个问题了，而使用STL的算法函数可以有效的提升搜索效率，提高代码的运行速度。</p>
<blockquote>
<p>STL提供了哪些算法函数，以及算法函数的详细说明，可以参见《STL源码剖析》一书的第6章。</p>
</blockquote>
<h2 id="2%E3%80%81%E8%B0%83%E7%94%A8sort%E5%87%BD%E6%95%B0%E5%AF%B9%E5%88%97%E8%A1%A8%E5%85%83%E7%B4%A0%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F">2、调用sort函数对列表元素进行排序</h2>
<p>       STL中的sort排序函数用的比较多，UI层在显示列表时，需要根据列表元素的名称进行排序，一般我们先在内存中进行排序。列表元素存放在STL列表中，我们调用STL算法函数sort进行排序。比如列表中的存放的是设备信息，设备信息结构体如下所示：（文章中的后续示例代码均以该结构体来说明）</p>
<pre><code class="language-cpp">// 设备信息
struct TDeviceInfo 
{
    char achDeviceId[64];   // 设备id
    char achDeviceName[64]; // 设备名称
    int nDevType;            // 设备类型
};</code></pre>
<p>设备信息列表数据存放在vector列表vtDevList中：</p>
<pre><code class="language-cpp">vector&lt;TDeviceInfo&gt; vtDevList; // 存放设备信息的列表</code></pre>
<p>       比如我们需要按照设备名称做升序排列，相关代码如下所示：</p>
<pre><code class="language-cpp">std::sort( vtDevList.begin(), vtDevList.end(), [](TDeviceInfo&amp; tDevInfo1, TDeviceInfo&amp; tDevInfo2)-&gt;bool{
CString strDevName1 = CopyUtf8ToCStringT(tDevInfo1.achDeviceName);
CString strDevName2 = CopyUtf8ToCStringT(tDevInfo2.achDeviceName);
return (lstrcmp( strDevName1, strDevName2 ) &lt; 0);
});</code></pre>
<p>上述代码中使用到了C++11引入的匿名函数，即lamda表达式。在低版本的Visual Studio中是不支持C++11规范的，所以要专门写个比较函数，设置到sort接口中，如下所示：</p>
<pre><code class="language-cpp">BOOL NameCompare( TDeviceInfo&amp; tDevInfo1, TDeviceInfo&amp; tDevInfo2 )
{
    CString strDevName1 = CopyUtf8ToCStringT(tDevInfo1.achDeviceName);
    CString strDevName2 = CopyUtf8ToCStringT(tDevInfo2.achDeviceName);
    return (lstrcmp( strDevName1, strDevName2 ) &lt; 0);
}

std::sort( vtDevList.begin(), vtDevList.end(), NameCompare );</code></pre>
<h2 id="3%E3%80%81%E8%B0%83%E7%94%A8count_if%E6%9F%A5%E6%89%BE%E6%BB%A1%E8%B6%B3%E6%9D%A1%E4%BB%B6%E7%9A%84%E5%85%83%E7%B4%A0%E4%B8%AA%E6%95%B0">3、调用count_if查找满足条件的元素个数</h2>
<p>       当我们需要到列表中搜索满足搜索条件的的元素个数时，可以使用count_if算法函数。比如我们需要到设备列表中搜索包含“东城区”关键字的所有设备个数，实现代码如下：</p>
<pre><code class="language-cpp">CString strKeyWords = _T("东城区");
std::count_if( vtDevList.begin(), vtDevList.end(), [&amp;](TDeviceInfo&amp; tDevInfo)-&gt;bool{
CString strDevName = CopyUtf8ToCStringT(tDevInfo.achDeviceName);
int nPos = strDevName.Find( strKeyWords );
return (nPos != -1 );
});</code></pre>
<p>       同样上述代码中也使用到了匿名函数，和上一个示例代码不同的是，我们在“[]”中添加了&amp;符号，使用该符号表示匿名函数可以访问所在函数中的变量。上例中的匿名函数中就访问了所在函数中的局部变量strKeyWords。</p>
<h2 id="4%E3%80%81%E8%B0%83%E7%94%A8find_if%E5%87%BD%E6%95%B0%E6%89%BE%E5%88%B0%E7%9B%AE%E6%A0%87%E5%85%83%E7%B4%A0%E7%9A%84%E4%BF%A1%E6%81%AF">4、调用find_if函数找到目标元素的信息</h2>
<p>       当我们需要到列表中搜索满足条件的设备信息时，可以使用find_if算法函数，该函数返回满足条件的元素对应的迭代器。比如我们要搜索设备id为E40CF3E4-CC2B-437F-A4B9-65F2D5BD0712的设备信息，示例代码如下：</p>
<pre><code class="language-cpp">char* pTarget = "E40CF3E4-CC2B-437F-A4B9-65F2D5BD0712";
 
vector&lt;TDeviceInfo&gt;::iterator itor = std::find_if(vtDevList.begin(), vtDevList.end(), 
[&amp;](TDeviceInfo tInfo) { return strcmp(pTarget, tInfo.achDeviceId)==0; } );
if (itor != vtDevList.end())
{
    // 找到目标设备
}</code></pre>
<p>有人可能会问，此处我们能不能使用find接口？我们可以go到STL算法函数的内部实现代码中：</p>
<pre><code class="language-cpp">template&lt;class _InIt,
    class _Ty&gt; inline
    _InIt find(_InIt _First, _InIt _Last, const _Ty&amp; _Val)
    {    // find first matching _Val
    _DEBUG_RANGE(_First, _Last);
    return (_Rechecked(_First,
        _Find(_Unchecked(_First), _Unchecked(_Last), _Val)));
    }

        // TEMPLATE FUNCTION find
template&lt;class _InIt,
    class _Ty&gt; inline
    _InIt _Find(_InIt _First, _InIt _Last, const _Ty&amp; _Val)
    {    // find first matching _Val
    for (; _First != _Last; ++_First)
        if (*_First == _Val)
            break;
    return (_First);
    }</code></pre>
<p>       传入的搜索条件是整个元素信息，如果STL列表中存放的是TDeviceInfo结构体对象，给Find函数传入的搜索条件就是一个TDeviceInfo对象，那这个Find函数内部是否相等的判断条件该如何解释呢？默认情况下，对于TDeviceInfo结构体，所有成员值相等，结构体对象才会相等的，显然我在搜素某个设备时，肯定是不知道目标设备的所有信息的，所以我们需要在该结构体中重载==操作符，在该函数中判断两个结构体是否相等。如下所示，设备Guid是全局唯一的，我们只要判断设备Guid是否相等就能确定是不是同一个设备了，所以我们实现如下的重载函数：</p>
<pre><code class="language-cpp">// 设备信息
struct TDeviceInfo 
{
    char achDeviceId[64];   // 设备id
    char achDeviceName[64]; // 设备名称
    int nDevType;            // 设备类型

    // 重载==操作符
    BOOL operator==( const TDeviceInfo&amp; tDevInfo )
    {
        return !strcmp(achDeviceId, tDevInfo.achDeviceId);
    }
};</code></pre>
<p>那下面就可以使用如下的代码去调用find函数了：</p>
<pre><code class="language-cpp">TDeviceInfo tDevInfo;
strcpy( tDevInfo.achDeviceId, "E40CF3E4-CC2B-437F-A4B9-65F2D5BD0712" );

TDeviceInfo tTragetDevInfo = std::find( vtDevList.begin(), vtDevList.end(), tDevInfo );</code></pre>
<h2 id="5%E3%80%81%E8%B0%83%E7%94%A8remove_copy_if%E5%87%BD%E6%95%B0%E6%90%9C%E7%B4%A2%E6%BB%A1%E8%B6%B3%E6%9D%A1%E4%BB%B6%E7%9A%84%E5%A4%9A%E4%B8%AA%E5%85%83%E7%B4%A0">5、调用remove_copy_if函数搜索满足条件的多个元素</h2>
<p>       我们有时需要到STL列表去搜索满足搜索条件的多个元素。比如我们要到设备列表中去搜索所有包含“东城区”字样的所有设备信息，使用for循环去遍历的代码如下：</p>
<pre><code class="language-cpp">// 通过for循环去遍历列表搜目标设备
char* pMatchNameStr = "东城区";
vector&lt;TDeviceInfo&gt; vtMatchedDevList; // 存放满足匹配条件的元素
vector&lt;TDeviceInfo&gt;::iterator itor = vtDevList.begin();
for (; itor != vtDevList.end(); itor++)
{
    CStringA strDeviceName = itor-&gt;achDeviceName;
    if (strDeviceName.Find(strDeviceName) != -1)
    {
        vtMatchedDevList.push_back(*itor);
    }
}</code></pre>
<p>       当设备列表vtDevList中存放了数万个元素时，上述for循环搜索的效率就不太高了，我们可以通过使用remove_copy_if算法函数去对现有代码进行替换：</p>
<pre><code class="language-cpp">BOOL MatchDeviceFunc(TDeviceInfo&amp; tInfo)
{
    char* pMatchNameStr = "东城区";
 
    CStringA strDeviceName = tInfo.achDeviceName;
    if ( strDeviceName.Find(pMatchNameStr) != -1 )
    {
        return TRUE;
    }
 
    return FALSE;
}
 
vector&lt;TDeviceInfo&gt; vtMatchedDevList;
std::remove_copy_if(vtDevList.begin(), vtDevList.end(), std::back_inserter(vtMatchedDevList), &amp;MatchDeviceFunc);</code></pre>
<p>       对于上述remove_copy_if调用，前两个参数指明搜索开始和结束的迭代器，第三个元素指定存放满足搜索条件的元素的列表，第四个参数指定条件判断函数MatchDeviceFunc。</p>
<p>        remove_copy_if算法函数的调用，可以有效地提升搜索速度。在我们项目中做过类似这样的优化，搜索速度可以提升1到2个数量级。</p>
<h2 id="6%E3%80%81%E6%80%BB%E7%BB%93">6、总结</h2>
<p>       在我们搜索STL列表速度遇到瓶颈时，可以考虑使用STL自带的算法函数去有效提升搜索效率。其实我们以前对比过STL算法函数内部的实现，很多STL算法函数内部实现和我们直接去通过for循环遍历的代码是类似的，甚至是一模一样的，比如find_if算法函数的实现，那为啥使用算法函数时就是要快很多呢？可能是编译器能对算法函数中的代码进行更好的优化，使其在运行时能跑的更快一点。</p>
</div>
</div>