<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<h2>1. 箭头函数比普通函数更加简洁</h2>
<p>如果没有参数，就直接写一个空括号即可</p>
<p>如果只有一个参数，可以省去参数的括号</p>
<p>如果有多个参数，用逗号分割</p>
<p>如果函数体的返回值只有一句，可以省略大括号</p>
<h2>2. 箭头函数没有自己的this</h2>
<p>箭头函数不会创建自己的this， 所以它没有自己的this，它只会在自己作用域的上一层继承this。所以箭头函数中this的指向在它在定义时已经确定了，之后不会改变。</p>
<h2>3. 箭头函数继承来的this指向永远不会改变</h2>
<pre><code class="language-javascript">var id = 'GLOBAL';
var obj = {
  id: 'OBJ',
  a: function(){
    console.log(this.id);
  },
  b: () =&gt; {
    console.log(this.id);
  }
};
obj.a();    // 'OBJ'
obj.b();    // 'GLOBAL'
new obj.a()  // undefined
new obj.b()  // Uncaught TypeError: obj.b is not a constructor
</code></pre>
<p>对象obj的方法b是使用箭头函数定义的，这个函数中的this就永远指向它定义时所处的全局执行环境中的this，即便这个函数是作为对象obj的方法调用，this依旧指向Window对象。需要注意，定义对象的大括号<strong>{ }</strong>是无法形成一个单独的执行环境的，它依旧是处于全局执行环境中。</p>
<h2>4. call()、apply()、bind()等方法不能改变箭头函数中this的指向 </h2>
<pre><code class="language-javascript">var id = 'Global';
let fun1 = () =&gt; {
    console.log(this.id)
};
fun1();                     // 'Global'
fun1.call({id: 'Obj'});     // 'Global'
fun1.apply({id: 'Obj'});    // 'Global'
fun1.bind({id: 'Obj'})();   // 'Global'
</code></pre>
<h2>5. 箭头函数不能作为构造函数使用 </h2>
<p>由于箭头函数时没有自己的this，且this指向外层的执行环境，且不能改变指向，所以不能当做构造函数使用。</p>
<h2>6. 箭头函数没有自己的arguments</h2>
<p>箭头函数没有自己的arguments对象。在箭头函数中访问arguments实际上获得的是它外层函数的arguments值。</p>
<h2>7. 箭头函数没有prototype</h2>
<h2>8. 箭头函数的this指向哪⾥？</h2>
<p>箭头函数不同于传统JavaScript中的函数，箭头函数并没有属于⾃⼰的this，它所谓的this是捕获其所在上下⽂的 this 值，作为⾃⼰的 this 值，并且由于没有属于⾃⼰的this，所以是不会被new调⽤的，这个所谓的this也不会被改变。</p>
<p></p>
</div>
</div>