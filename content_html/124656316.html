<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<h1 id="main-toc">一、vue是什么</h1>
<p><span style="color:#0d0016;">官方解释：vue是一套用于构建用户界面的渐进式框架。</span></p>
<p><span style="color:#7b7f82;">vue是一个js框架，提供了一套开发规则，按照这个开发规则可提高开发效率。</span></p>
<p><span style="color:#7b7f82;">补充：渐进式意思是，vue.js本身功能局限，一旦配合其他的工具可以增强其能力。</span></p>
<ul><li><span style="color:#7b7f82;">vue-router</span></li><li><span style="color:#7b7f82;">vuex</span></li><li><span style="color:#7b7f82;">axios</span></li><li><span style="color:#7b7f82;">nuxt</span></li></ul>
<h1 id="%E4%BA%8C%E3%80%81vue%E7%9A%84%E6%A0%B8%E5%BF%83">二、vue的核心</h1>
<h2 id="%E2%91%A0%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8%E8%A7%86%E5%9B%BE%EF%BC%88%E9%A1%B5%E9%9D%A2%EF%BC%89">①数据驱动视图（页面）</h2>
<p>修改绑定的数据（页面上依赖数据），就能对应的更新视图（页面），极大的解放了操作dom的工作，提供开发效率。</p>
<h2 id="%E2%91%A1MVVM%E6%A8%A1%E5%BC%8F">②MVVM模式</h2>
<ul><li>M  数据模型 model</li><li>V  视图（页面）view</li><li>VM数据模型和视图的控制器 viewmodel</li><li>数据双向绑定</li></ul>
<p><img alt="" height="313" src="image\0cfc139d6d004d119ac326c9d7d0240c.png" width="564"/></p>
<h2 id="%E2%91%A2%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91">③组件化开发</h2>
<p>通常一个应用会以一颗嵌套的组件树的形式来组织</p>
<p><img alt="" height="195" src="image\e9edf65f2d0a4e16b8e9a5ad26b15550.png" width="575"/></p>
<p>把页面按照页面功能（导航，侧边栏，下拉框）拆分业务，每一个组件时一个独立的功能，提供代码可维护性，和复用性。</p>
<h1 id="%C2%A0%E4%B8%89%E3%80%81vue%E4%BD%BF%E7%94%A8"> 三、vue使用</h1>
<h2 id="hello%20vue">hello vue</h2>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;Vue&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="app"&gt;
        &lt;h1&gt;{<!-- -->{msg}}&lt;/h1&gt; &lt;!-- 插值语法--&gt;
    &lt;/div&gt;
    &lt;!-- 引入 --&gt;
    &lt;script src="./vue2.js"&gt;&lt;/script&gt;
    &lt;script&gt;
        // 实例化vue
        let  vm = new Vue({
            // vue的选项，el选项的作用指定vue实例管理的容器
            el:'#app',
            // vue选项，data作用是声明响应式数据
            data:{
                msg:'hello vue'
            }
        })
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>页面显示：</p>
<p><img alt="" height="113" src="image\1e34105d1daa4a27ac38d84bfa46cd13.png" width="307"/></p>
<h1 id="%C2%A0%E5%9B%9B%E3%80%81vue-%E6%8C%87%E4%BB%A4"> 四、vue-指令</h1>
<h2 id="%C2%A0%201.v-text%E5%92%8Cv-html">  1.v-text和v-html</h2>
<p>        v-text：更新替换标签内容，文本；v-html更新替换标签内容，html</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;Vue&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="app"&gt;
        &lt;h1 v-text="text"&gt;&lt;/h1&gt;
        &lt;h1 v-html="html"&gt;&lt;/h1&gt;
    &lt;/div&gt;
    &lt;!-- 引入 --&gt;
    &lt;script src="./vue2.js"&gt;&lt;/script&gt;
    &lt;script&gt;
        // 实例化vue
        let  vm = new Vue({
            // vue的选项，el选项的作用指定vue实例管理的容器
            el:'#app',
            // vue选项，data作用是声明响应式数据
            data:{
                text:'v-text:&lt;span&gt;hello vue&lt;/span&gt;',
                html:'v-html:&lt;span&gt;hello vue&lt;/span&gt;'
            }
        })
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p><img alt="" height="141" src="image\aaf3b72a75924be5a818d5e82f4f2235.png" width="554"/></p>
<h2 id="%C2%A02.v-if%E5%92%8Cv-show"> 2.v-if和v-show</h2>
<p>      两者都是控制DOM元素的显示于隐藏，但是区别很大。</p>
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9Av-if%E5%92%8Cv-show%E7%9A%84%E5%8C%BA%E5%88%AB">        面试题：v-if和v-show的区别</h3>
<p>        答：v-if是动态的向dom树内添加或者删除DOM元素；v-show是通过设置DOM元素的display样式属性控制显示隐藏编译过程；性能消耗：v-if有更高的切换消耗；v-show有更高的初始渲染消耗</p>
<p>3.v-on</p>
<p>作用：v-on在基于vue的程序中绑定事件</p>
<p>语法：&lt;div v-on:事件名称='事件处理函数 | js表达式'&gt;&lt;div&gt;   简写 @</p>
<p>代码：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;文字的显示与隐藏&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="app"&gt;
        &lt;h1 v-text="text" v-show="ifShow" v-on:click="toggleShow"&gt;&lt;/h1&gt;
        &lt;h1 v-html="html"v-show="ifShow" v-on:click="ifShow=!ifShow"&gt;&lt;/h1&gt;
    &lt;/div&gt;
    &lt;!-- 引入 --&gt;
    &lt;script src="./vue2.js"&gt;&lt;/script&gt;
    &lt;script&gt;
        // 实例化vue
        let  vm = new Vue({
            // vue的选项，el选项的作用指定vue实例管理的容器
            el:'#app',
            // vue选项，data作用是声明响应式数据
            data:{
                text:'v-text:&lt;span&gt;hello vue&lt;/span&gt;',
                html:'v-html:&lt;span&gt;hello vue&lt;/span&gt;',
                ifShow:true
            },
            // vue选项，methods定义函数
            // 在此处定义的函数，可以通过vm调用，vue实例进行调用
            methods:{
                toggleShow(){
                    this.ifShow=!this.ifShow;
                }
            }
        })
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<h2 id="4.v-bind">4.v-bind</h2>
<p>作用：动态的去绑定属性的值，说白了通过数据去改变属性的值</p>
<p>语法：：<code>&lt;div v-bind:标签属性名称="数据名称|js表达式"&gt;&lt;/div&gt;</code> 简写 <code>:</code></p>
<h2 id="5.v-for">5.v-for</h2>
<p>作用：通过数据动态遍历标签</p>
<p>语法：</p>
<ul><li> <p>遍历4次 <code>&lt;div v-for="i in 4"&gt;i是从1开始序号&lt;/div&gt;</code></p> </li><li> <p>数组类型 list = [{},{},...]</p>
<ul><li> <p><code>&lt;div v-for="item in list"&gt;item就是每次遍历的选项数据&lt;/div&gt;</code></p> </li><li> <p><code>&lt;div v-for="(item,i) in list"&gt;item就是每次遍历的选项数据，i就是索引&lt;/div&gt;</code></p> </li></ul></li><li> <p>对象类型 obj = {a:1,b:2}</p>
<ul><li> <p><code>&lt;div v-for="(v,k,i) in obj"&gt;v属性值，k属性名，i索引&lt;/div&gt;</code></p> </li></ul></li></ul>
<p>规范：</p>
<ul><li> <p>在v-for指令使用的时候，需要带上一个属性 key 且指定唯一的标识</p> </li><li> <p>目的：给遍历的每一个元素加上唯一标识，提高操作的性能。</p> </li><li> <p>语法：<code>v-for="" :key="唯一标识"</code> 建议使用ID，不得已情况下才会使用索引。</p> </li></ul>
<p>代码：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8" /&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;
    &lt;title&gt;&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="app"&gt;
      &lt;!-- v-for="i in 4" --&gt;
      &lt;!-- 注意：v-for指令vue官方不建议使用v-if指令 --&gt;
      &lt;div v-for="i in 4" :key="i"&gt;第{<!-- -->{i}}个div&lt;/div&gt;
      &lt;hr&gt;
      &lt;!-- v-for="item in list" --&gt;
      &lt;div v-for="item in list" :key="item.id"&gt;名字：{<!-- -->{item.name}}&lt;/div&gt;
      &lt;hr&gt;
      &lt;!--  v-for="(item,i) in list" --&gt;
      &lt;div v-for="(item,i) in list" :key="i"&gt;名字：{<!-- -->{item.name}} 索引{<!-- -->{i}}&lt;/div&gt;
      &lt;!--  v-for="(v,k,i) in obj" --&gt;
      &lt;div v-for="(v,k,i) in obj" :key="k"&gt;值：{<!-- -->{v}} 键：{<!-- -->{k}} 索引：{<!-- -->{i}}&lt;/div&gt;
    &lt;/div&gt;
    &lt;script src="./vue.js"&gt;&lt;/script&gt;
    &lt;script&gt;
      const vm = new Vue({
        el: '#app',
        data: {
          // 数组
          list: [{id:1,name:'tom',age:10},{id:2,name:'tony',age:12}],
          // 对象
          obj: {
            name: 'tom',
            age: 10
          }
        },
        methods: {}
      })
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
<h2 id="6.v-model">6.v-model</h2>
<p>作用:数据的双向绑定</p>
<h3 id="%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E7%9A%84%E5%8E%9F%E7%90%86">面试题：双向数据绑定的原理</h3>
<p>答：vue.js是采用数据劫持解和发布者-订阅者模式的方式，</p>
<p>通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。主要分为以下几个步骤：</p>
<ol><li> <p>需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化</p> </li><li> <p>compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</p> </li><li> <p>Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是: ①在自身实例化时往属性订阅器(dep)里面添加自己 ②自身必须有一个update()方法 ③待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。</p> </li><li> <p>MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。</p> </li></ol>
<p>表单元素如何进行v-model进行绑定</p>
<p>输入框、下拉框、复选、单选、文本域</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;

&lt;head&gt;
    &lt;meta charset="UTF-8" /&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;
    &lt;title&gt;&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;div id="app"&gt;
        &lt;!-- input --&gt;
        &lt;input type="text" v-model="msg"&gt;
        {<!-- -->{msg}}

        &lt;hr&gt;

        &lt;!-- select --&gt;
        &lt;select name="" id="" v-model="selectMsg"&gt;
            &lt;option value="qd"&gt;前端&lt;/option&gt;
            &lt;option value="hd"&gt;后端&lt;/option&gt;
            &lt;option value="ui"&gt;UI&lt;/option&gt;
        &lt;/select&gt;
        {<!-- -->{selectMsg}}

        &lt;hr&gt;
        &lt;!-- 复选框 --&gt;
        &lt;input type="checkbox" name="GAME" value="wz"  v-model="checkMsg"&gt;王者
        &lt;input type="checkbox" name="GAME" value="lol" v-model="checkMsg"&gt;LOL
        &lt;input type="checkbox" name="GAME" value="cs"  v-model="checkMsg"&gt;CS
        {<!-- -->{checkMsg}}

        &lt;hr&gt;
        &lt;!-- 单选框 --&gt;
        &lt;input type="radio" name="sex" value="0" v-model="radioMsg"&gt;男
        &lt;input type="radio" name="sex" value="1"  v-model="radioMsg"&gt;女
        {<!-- -->{radioMsg}}

        &lt;hr&gt;
        &lt;!-- 文本域 --&gt;
        &lt;textarea v-model="text"&gt;&lt;/textarea&gt;
        &lt;div v-html="text"&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;script src="./vue2.js"&gt;&lt;/script&gt;
    &lt;script&gt;
        
        const vm = new Vue({
            el: '#app',
            data: {
                msg : "laila",
                selectMsg : "ui",
                checkMsg : [],
                radioMsg : '',
                text : ''
            },
            methods: {}
        })
    &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;</code></pre>
<h1 id="%E4%BA%94%E3%80%81vue-%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7">五、vue-常用属性</h1>
<h2 id="1.%E8%BF%87%E6%BB%A4%E5%99%A8%C2%A0%20filter">1.过滤器  filter</h2>
<p>作用：在插值表达式中使用，可以对输出的内容进行格式的转换。{<!-- -->{数据字段|过滤器名称}}</p>
<p>定义：</p>
<ul><li> <p>全局定义（在任何vue实例管理的视图中都可使用）</p>
<ul><li> <p>语法 <code>Vue.filter('过滤器名称',处理格式函数(val){ //val就行需要转换的值 //对val进行处理 //处理好的数据return出去即可 })</code></p> </li></ul></li><li> <p>局部定义（仅仅在当前定义过滤器的vue实例中使用）</p>
<ul><li> <p>语法 <code>new Vue({filters:{'过滤器名称':处理格式函数(val){ //val就行需要转换的值 //对val进行处理 //处理好的数据return出去即可 }}})</code></p> </li></ul></li></ul>
<p>代码：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="UTF-8" /&gt;
        &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;
        &lt;title&gt;&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div id="app1"&gt;
             {<!-- -->{ msg | test}}
            &lt;!--{<!-- -->{ list |  listFilter}}--&gt;
        &lt;/div&gt;
        &lt;div id="app2"&gt;
            &lt;hr&gt;
            {<!-- -->{ news |  test}}
            {<!-- -->{ news | forMsg }}
        &lt;/div&gt;
        &lt;script src="./vue2.js"&gt;&lt;/script&gt;
        &lt;script&gt;
            // 全局定义过滤器，每个vm都可以使用该过滤器
            // Vue.filter("过滤器的名字","回调函数")
            Vue.filter('test',(val)=&gt;{

                console.log(val)
                return val+123;
            })
            const vm1 = new Vue({
                el: '#app1',
                data: {
                    msg : 'hello',
                },
                methods: {}
            })

            const vm2 = new Vue({
                el: '#app2',
                data: {
                    news : "中国新闻",
                },
                methods: {},
                filters : {
                    //定义局部过滤器
                    // key 名字  val 函数
                    forMsg : (val)=&gt;{
                        return val + "局部过滤器"
                    }
                }
            })
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre>
<h2 id="%E4%BA%8C%E3%80%81%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%C2%A0computed">2.计算属性 computed</h2>
<p>作用：</p>
<ul><li> <p>根据data当中的数据，经过一定的逻辑处理，得到一项新数据（计算属性）。</p> </li><li> <p>当data中的数据发生变化的时候，计算属性也会更新。</p> </li><li> <p>计算属性也是响应式数据，改变的时候也会驱动视图的更新。</p> </li><li> <p>当多次获取计算属性的时候，处理逻辑不会重新执行，因为有缓存。</p> </li></ul>
<p>定义：</p>
<ul><li> <p>语法：<code>new Vue({computed:{ 书写计算属性 }})</code></p> </li><li> <p>书写计算属性：</p>
<ul><li> <p><code>myMsg () { // 处理逻辑 return ‘处理后的数据’ }</code></p> </li></ul></li><li> <p>使用：和data中的数据一致</p> </li></ul>
<h2 id="%E4%B8%89%E3%80%81%E5%B1%9E%E6%80%A7%E6%A3%80%E6%9F%A5%20watch">3.属性检测 watch</h2>
<p>作用：可以监控一个值的变换,并调用因为变化需要执行的方法。可以通过watch动态改变关联的状态。</p>
<p>代码：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="UTF-8" /&gt;
        &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;
        &lt;title&gt;&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div id="app"&gt;
            &lt;input type="text" v-model="firstName"&gt;
             +
            &lt;input type="text" v-model="lastName"&gt;
            =
            &lt;input type="text" v-model="fullName"&gt;

            &lt;hr&gt;
            &lt;input type="text" v-model="obj.name"&gt;
            {<!-- -->{ obj.name }}

            &lt;input type="text" v-model="obj.brand.name"&gt;
            {<!-- -->{ obj.brand.name }}
        &lt;/div&gt;
        &lt;script src="./vue2.js"&gt;&lt;/script&gt;
        &lt;script&gt;
            const vm = new Vue({
                el: '#app',
                data: {
                    firstName : "爱新觉罗",
                    lastName : "政",
                    fullName : "",
                    obj : {
                        name : "zs",
                        brand : {
                            name : "李四"
                        }
                    }
                },
                methods: {},
                watch : {
                    // 函数的写法
                    // firstName : function(newVal,oldVal){
                    //     this.fullName = newVal + this.lastName;
                    // },
                    // lastName : function(newVal,oldVal){
                    //     this.fullName = this.firstName + newVal;
                    // }
                    // 对象的写法
                    firstName : {
                        handler : function(newVal,oldVal){
                            setTimeout(()=&gt;{
                                this.fullName = newVal + this.lastName;
                            },3000)
                        },
                        immediate: true//一打开页面就开启监听
                    },
                    lastName : {
                        handler : function(newVal,oldVal){
                            this.fullName =  this.firstName + newVal;
                        },
                        immediate: true//一打开页面就开启监听
                    },
                    obj : {
                        handler : function(newVal,oldVal){
                           console.log(newVal,oldVal)
                        },
                        immediate: true,//一打开页面就开启监听
                        deep : true//深度监听
                    }
                }
            })
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre>
<h3 id="%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9Acomputed%E5%92%8Cwatch%E7%9A%84%E5%8C%BA%E5%88%AB">面试题：computed和watch的区别</h3>
<p>答：computed 计算属性 : 依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值。</p>
<p>watch 侦听器 : 更多的是观察的作用，无缓存性，类似于某些数据的监听回调，每当监听的数据变化时都会执行回调进行后续操作。</p>
<table align="left" border="1" cellpadding="1" cellspacing="1" style="width:522px;"><tbody><tr><td style="width:254px;"><span style="color:#fe2c24;">计算属性（computed）</span></td><td style="width:267px;"><span style="color:#fe2c24;">属性检测（wathch）</span></td></tr><tr><td style="width:254px;">首次运行</td><td style="width:267px;">首次不运行</td></tr><tr><td style="width:254px;">调用时需要在模板中渲染，修改计算所依赖原数据</td><td style="width:267px;">调用时只需修改元数据</td></tr><tr><td style="width:254px;">默认深度依赖</td><td style="width:267px;">默认浅度观测</td></tr><tr><td style="width:254px;">适合做筛选，不可异步</td><td style="width:267px;">适合做执行异步或者开销较大的操作</td></tr></tbody></table>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<hr/>
<p><strong>这个记录下希望看的的小伙伴能学到更多，也希望大佬们多多交流，多多留言，指出我的不足的之处啦！</strong></p>
</div>
</div>