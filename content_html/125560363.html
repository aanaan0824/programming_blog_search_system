<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<h3 id="main-toc"><span style="color:#1c7892;"><strong>文章目录：</strong></span></h3>
<p id="%C2%A0%E4%B8%80%EF%BC%9A%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-toc" style="margin-left:0px;"><a href="#%C2%A0%E4%B8%80%EF%BC%9A%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"> 一：构造函数</a></p>
<p id="%C2%A01.1%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#%C2%A01.1%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"> 1.1 构造函数使用方法</a></p>
<p id="%C2%A01.2%C2%A0%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0new%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B-toc" style="margin-left:40px;"><a href="#%C2%A01.2%C2%A0%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0new%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"> 1.2 构造函数new的执行过程</a></p>
<p id="new%20%E6%9C%89%E4%BB%A5%E4%B8%8B%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%9A-toc" style="margin-left:80px;"><a href="#new%20%E6%9C%89%E4%BB%A5%E4%B8%8B%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%9A">new 执行过程</a></p>
<p id="1.3%20%E5%AE%9E%E4%BE%8B%E6%88%90%E5%91%98%E4%B8%8E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%C2%A0-toc" style="margin-left:40px;"><a href="#1.3%20%E5%AE%9E%E4%BE%8B%E6%88%90%E5%91%98%E4%B8%8E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%C2%A0">1.3 实例成员与静态成员 </a></p>
<p id="%E4%BA%8C%EF%BC%9A%20%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%C2%A0prototype-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%EF%BC%9A%20%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%C2%A0prototype">二： 原型对象 prototype</a></p>
<p id="2.1%20%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1-toc" style="margin-left:40px;"><a href="#2.1%20%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1">2.1 为什么有原型对象</a></p>
<p id="2.2%C2%A0%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px;"><a href="#2.2%C2%A0%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BD%BF%E7%94%A8">2.2 原型对象的使用</a></p>
<p id="%C2%A0%E4%B8%89%EF%BC%9A%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B%20__proto__-toc" style="margin-left:0px;"><a href="#%C2%A0%E4%B8%89%EF%BC%9A%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B%20__proto__"> 三：对象原型 __proto__</a></p>
<p id="3.1%20%E4%BB%80%E4%B9%88%E6%98%AF%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B%EF%BC%9F-toc" style="margin-left:40px;"><a href="#3.1%20%E4%BB%80%E4%B9%88%E6%98%AF%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B%EF%BC%9F">3.1 什么是对象原型？</a></p>
<p id="3.2%20%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B__proto__%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9%C2%A0-toc" style="margin-left:40px;"><a href="#3.2%20%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B__proto__%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9%C2%A0">3.2 关于对象原型__proto__的注意点 </a></p>
<p id="%E6%96%B9%E6%B3%95%E7%9A%84%E6%9F%A5%E6%89%BE%E5%8E%9F%E5%88%99%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E6%96%B9%E6%B3%95%E7%9A%84%E6%9F%A5%E6%89%BE%E5%8E%9F%E5%88%99%EF%BC%9A">方法的查找原则</a></p>
<p id="%E5%9B%9B%EF%BC%9A%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%20constructor%C2%A0-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%EF%BC%9A%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%20constructor%C2%A0">四：构造函数 constructor </a></p>
<p id="4.1%20%E4%B8%BA%E4%BB%80%E4%B9%88%20constructor%20%E4%B9%9F%E5%8F%AB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#4.1%20%E4%B8%BA%E4%BB%80%E4%B9%88%20constructor%20%E4%B9%9F%E5%8F%AB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">4.1 为什么 constructor 也叫构造函数</a></p>
<p id="4.2%20%E6%89%8B%E5%8A%A8%E8%BF%94%E5%9B%9E%20constructor%20%E7%9A%84%E6%83%85%E5%86%B5-toc" style="margin-left:40px;"><a href="#4.2%20%E6%89%8B%E5%8A%A8%E8%BF%94%E5%9B%9E%20constructor%20%E7%9A%84%E6%83%85%E5%86%B5">4.2 手动返回 constructor 的情况</a></p>
<blockquote>
<p>  什么是原型？原型是 JS 基础学习中我们没有提及的概念，原型它是一个泛指，主要包含了<span style="background-color:#fff5e6;"> </span><span style="color:#be191c;"><strong><span style="background-color:#fff5e6;">原型对象 (prototype) </span></strong>，<span style="background-color:#fff5e6;"> </span><strong><span style="background-color:#fff5e6;">对象原型 (__proto__)</span></strong>，<span style="background-color:#fff5e6;"> </span><strong><span style="background-color:#fff5e6;">原型链</span></strong></span><span style="color:#fe2c24;"><strong><span style="background-color:#fff5e6;"> </span></strong></span>等等，这些概念据统计也是面试中常常问到的内容，这篇文章就带大家了解并掌握原型的相关知识，让大家不再迷茫。</p>
<p></p>
</blockquote>
<hr/>
<h1 id="%C2%A0%E4%B8%80%EF%BC%9A%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"> <span style="color:#4da8ee;">一：构造函数</span></h1>
<blockquote>
<p>     我们学习过很多面向对象的语言，例如 java c++ 等等，但是 JavaScript 是个例外，在 ES6 之前，是没有类的概念的，那在之前我们如何创建对象呢？原来在 ES6 之前，我们是利用 <span style="color:#be191c;"><strong>构造函数 </strong></span>来创建实例化对象的，构造函数是一种特殊的函数，包含了对象的公共特征，要配合 <span style="color:#be191c;"><strong>new</strong></span> 一起使用才有意义。</p>
<hr/>
<h3 id="%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A">构造函数的注意事项：</h3>
<ul><li><span style="color:#1c7331;"><strong>构造函数名的首字母要大写</strong></span></li><li><span style="color:#1c7331;"><strong>构造函数要配合 new 一起使用</strong></span></li></ul>
</blockquote>
<h2 id="%C2%A01.1%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span style="color:#b95514;"> 1.1 构造函数使用方法</span></h2>
<pre><code class="language-javascript">   &lt;script&gt; 
           function Animal(name,age){      //构造函数名首字母大写
                this.name=name;
                this.age=age;
                this.eat=function(){
                  console.log('我在吃东西');
                }
           }
           var dog=new Animal('旺财',3)     //要配合 new 一起使用创建对象
           console.log(dog.name);
           console.log(dog.age);
           dog.eat()
   &lt;/script&gt;</code></pre>
<p><img alt="" height="182" src="image\17cf561cda4a406e8ede573a07cd61ad.png" width="930"/></p>
<h2 id="%C2%A01.2%C2%A0%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0new%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"> <span style="color:#b95514;">1.2 构造函数new的执行过程</span></h2>
<blockquote>
<h3 id="new%20%E6%9C%89%E4%BB%A5%E4%B8%8B%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%9A">new 有以下执行过程：</h3>
<ul><li><span style="color:#1c7892;">new 的时候会创建一个空对象</span></li><li><span style="color:#1c7892;">构造函数内的 this 指向这个空对象</span></li><li><span style="color:#1c7892;">执行构造函数内的代码给空对象赋值，添加属性方法</span></li><li><span style="color:#1c7892;">返回这个对象</span></li></ul>
<hr/>
<p><img alt="" height="378" src="image\dfc84240a1e24a85943e515450c2342d.jpeg" width="647"/></p>
</blockquote>
<h2 id="1.3%20%E5%AE%9E%E4%BE%8B%E6%88%90%E5%91%98%E4%B8%8E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%C2%A0"><span style="color:#b95514;">1.3 实例成员与静态成员 </span></h2>
<blockquote>
<h3 id="%E5%AE%9E%E4%BE%8B%E6%88%90%E5%91%98%EF%BC%9A"><span style="color:#1a439c;">实例成员：</span></h3>
<ul><li><span style="color:#1c7331;">实例成员就是观战属内部用 this 添加的成员</span></li><li><span style="color:#1c7331;">实例成员只能通过实例化的对象调访问，不能通过构造函数名访问</span></li></ul>
<pre><code class="language-javascript">   &lt;script&gt;
           function Animal(name,age){
                this.name=name;
                this.age=age;
           }
           var dog=new Animal('旺财',3)
           console.log(dog.name);
           console.log(Animal.name);
   &lt;/script&gt;</code></pre>
<p><img alt="" height="109" src="image\a7b5363c091d47a7b1b8bf7fa2cce5a3.png" width="757"/></p>
<hr/>
<h3 id="%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%EF%BC%9A"><span style="color:#1a439c;">静态成员：</span></h3>
<ul><li><span style="color:#1c7331;">静态成员就是通过构造函数本身创建的成员</span></li><li><span style="color:#1c7331;">静态成员只能通过构造函数名访问，不能通过实例化对象访问</span></li></ul>
<pre><code class="language-javascript">   &lt;script&gt;
           function Animal(name,age){
                this.name=name;
                this.age=age;
           }
           var dog=new Animal('旺财',3)
           Animal.color='黑色'
           console.log(Animal.color);
           console.log(dog.color);
   &lt;/script&gt;</code></pre>
<p><img alt="" height="134" src="image\617c7f360f044896a112d5115526c7c6.png" width="826"/></p>
</blockquote>
<hr/>
<h1 id="%E4%BA%8C%EF%BC%9A%20%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%C2%A0prototype"><span style="color:#4da8ee;">二： 原型对象 prototype</span></h1>
<h2 id="2.1%20%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1"><span style="color:#b95514;">2.1 为什么有原型对象</span></h2>
<blockquote>
<p>在开始将原型对象是什么前，我们先说明一个案例，还是刚才的那个 Animal 类，我们创建了多个实例化对象，输出其实例化对象的两个方法的比较，我们发现输出了 false，即二者的这个复杂数据类型的地址不同，什么原因呢？</p>
<pre><code class="language-javascript">   &lt;script&gt; 
      function Animal(name,age){      
           this.name=name;
           this.age=age;
           this.eat=function(){
             console.log('我在吃东西');
           }
      }
      var dog=new Animal('旺财',3)     
      var cat=new Animal('咪咪',3)     
      var pig=new Animal('哼哼',3)     
      var fish=new Animal('咕噜',3)     
      var sheep=new Animal('咩咩',3)     
      console.log(dog.eat==cat.eat);
&lt;/script&gt;</code></pre>
<p><img alt="" height="127" src="image\24f64fb9fba34172aa7f70acf1f375bb.png" width="860"/></p>
<p></p>
<p>在我们创建实例化对象的过程中，new 的过程首先会创建一个新对象，但是复杂数据类型会领开辟一块空间存放（对象，方法），这就<span style="color:#be191c;"><strong>造成了构造函数内同样的方法被开辟了无数块内存，造成了内存的极度浪费</strong></span></p>
<p><img alt="" height="1013" src="image\ef55fa4c1e6448be938b107d76d4fd4d.png" width="1200"/></p>
</blockquote>
<h2 id="2.2%C2%A0%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BD%BF%E7%94%A8"><span style="color:#b95514;">2.2 原型对象的使用</span></h2>
<blockquote>
<p>     构造函数原型 prototype 是构造函数内的一个属性，其属性是一个指针，指向一个对象，这个对象内存放的就是公共的方法，存在这个对象里的方法，再通过构造函数创建实例化对象时就可以公共利用这一个方法了，不需要再对多个相同的复杂数据类型开辟多个重复的内存空间。就是为了解决上述存在的内存浪费的问题，其也可以直接称为原型对象。</p>
</blockquote>
<h3 id="%E4%B8%8A%E8%BF%B0%E6%A1%88%E4%BE%8B%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A%C2%A0"><span style="color:#1c7892;">上述案例解决方案： </span></h3>
<p>解决方案我们使用原型对象存放公共方法，并且让实例化对象调用该方法，并且比较二者的地址是否相同</p>
<pre><code class="language-javascript">   &lt;script&gt; 
      function Animal(name,age){      
           this.name=name;
           this.age=age;
      }
      Animal.prototype.eat=function(){
          console.log('我在吃东西');
      }
      var dog=new Animal('旺财',3)     
      var cat=new Animal('咪咪',3)     
      dog.eat()
      cat.eat()
      console.log(dog.eat==cat.eat);
&lt;/script&gt;</code></pre>
<blockquote>
<p>我们发现不但成功调用了这个方法，而且二者调用方法的地址是相同的，这就证明了，其公共的复杂数据类型只开辟了一块内存空间，减少了之前公共方法写在构造函数内部资源浪费的问题。</p>
</blockquote>
<p><img alt="" height="167" src="image\aeb5ebc6903443a0b6c0d966f5b83cf1.png" width="829"/></p>
<hr/>
<h1 id="%C2%A0%E4%B8%89%EF%BC%9A%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B%20__proto__"> <span style="color:#4da8ee;">三：对象原型 __proto__</span></h1>
<h2 id="3.1%20%E4%BB%80%E4%B9%88%E6%98%AF%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B%EF%BC%9F"><span style="color:#b95514;">3.1 什么是对象原型？</span></h2>
<blockquote>
<p>对象原型__proto__的作用是让你搞清楚一个问题：<span style="color:#be191c;"><strong>为什么给构造函数的prototype属性添加的方法，实例化对象却可以使用？</strong></span>这是因为每一个对象都有一个 __proto__属性（注意前后都是两个下划线），这个属性也是一个指针，指向的是其对应构造函数的原型对象 prototype，这就解释了为什么实例化的对象可以去调用原型对象里的方法。</p>
<h3 id="%E6%88%96%E8%80%85%E5%8F%AF%E4%BB%A5%E7%90%86%E8%A7%A3%E4%B8%BA%EF%BC%9A">或者可以理解为：</h3>
<ul><li><span style="color:#1c7331;"><strong>原型对象prototype 等价于 对象原型 __proto__</strong></span></li></ul>
<p></p>
<hr/>
<p><img alt="" height="820" src="image\5ff5130c26db4275ad656b546e3adc53.png" width="1200"/></p>
</blockquote>
<h2 id="3.2%20%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B__proto__%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9%C2%A0"><span style="color:#b95514;">3.2 关于对象原型__proto__的注意点 </span></h2>
<blockquote>
<p>我们要注意对象原型__protp__的作用仅仅是为了给查找原型对象内的内容提供一个方向，我们不需要使用它，只需要记住它指向对应的构造函数的原型对象 prototype 即可</p>
<hr/>
<h3 id="%E6%96%B9%E6%B3%95%E7%9A%84%E6%9F%A5%E6%89%BE%E5%8E%9F%E5%88%99%EF%BC%9A">方法的查找原则：</h3>
<ul><li><span style="color:#1c7331;"><strong>首先去找实例化自身的构造函数身上有没有目标方法，有则调用</strong></span></li><li><span style="color:#1c7331;"><strong>如果自身构造函数身上没有，由于因为对象自身有属性__protp__，其指向构造函数的原型对象prototype，则会去找原型对象身上有没有该方法</strong></span></li></ul>
<hr/>
<p><img alt="" height="472" src="image\154bb86b4095405b83655df81de2aeb3.jpeg" width="668"/></p>
</blockquote>
<hr/>
<h1 id="%E5%9B%9B%EF%BC%9A%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%20constructor%C2%A0"><span style="color:#4da8ee;">四：构造函数 constructor </span></h1>
<h2 id="4.1%20%E4%B8%BA%E4%BB%80%E4%B9%88%20constructor%20%E4%B9%9F%E5%8F%AB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span style="color:#b95514;">4.1 为什么 constructor 也叫构造函数</span></h2>
<blockquote>
<p>对象原型 __proto__ 身上和构造函数的原型对象 prototype 身上都有一个 constructor 属性，之所以叫 constructor 叫构造函数，是因为这个属性指向的是对应的构造函数本身，其主要用于记录实例化的对象引用于哪一个构造函数</p>
<hr/>
<h3 id="%E6%89%93%E5%8D%B0%E4%BA%8C%E8%80%85%E7%9A%84constructor%E5%B1%9E%E6%80%A7%EF%BC%9A">打印二者的constructor属性：</h3>
<pre><code class="language-javascript">   &lt;script&gt; 
      function Animal(name,age){      
           this.name=name;
           this.age=age;
      }
      Animal.prototype.eat=function(){
         console.log('我在吃东西');
      }
     var dog=new Animal('旺财',4)
     console.log(dog.__proto__.constructor);
     console.log(Animal.prototype.constructor);
&lt;/script&gt;</code></pre>
<p><img alt="" height="301" src="image\9b9e236ba3dc4942b9192c707775a464.png" width="1053"/></p>
<p><strong> 我们发现打印出来结果确实为构造函数本身</strong></p>
</blockquote>
<h2 id="4.2%20%E6%89%8B%E5%8A%A8%E8%BF%94%E5%9B%9E%20constructor%20%E7%9A%84%E6%83%85%E5%86%B5"><span style="color:#b95514;">4.2 手动返回 constructor 的情况</span></h2>
<blockquote>
<p>更多时候我们需要手动返回 constructor 指向的哪个构造函数，例如构造函数的原型对象中以对象的形式存入多个公共方法时，就会出现以下情况：</p>
<pre><code class="language-javascript">   &lt;script&gt; 
      function Animal(name,age){      
           this.name=name;
           this.age=age;
      }
      Animal.prototype={
        eat:function(){
          console.log('我在吃东西');
        },
        run:function(){
          console.log('我在跑');
        }
      }
      var dog=new Animal('wangchai',3)
      console.log(Animal.prototype.constructor);
      console.log(dog.__proto__.constructor);
&lt;/script&gt;</code></pre>
<p><img alt="" height="173" src="image\1f539a8e9494441ebdd063632e5df33d.png" width="901"/></p>
<hr/>
<p> 我们发现其找不到对应的构造函数了，这是因为我们给其原型对象添加方法的添加方式导致的，这钱我们采取的以.方式添加，是在原有基础上追加添加的，不会覆盖掉内部原有的内容。而我们采用=的方法以对象形式添加，其实是一个赋值的过程，将原有内容也给覆盖掉了，这就导致 prototype 内部原有的 constructor 方法被覆盖掉了</p>
<p><span style="color:#be191c;"><strong> 这时就需要我们手动返回 constructor 来找到返回的是哪个的构造函数</strong></span></p>
<pre><code class="language-javascript">   &lt;script&gt; 
      function Animal(name,age){      
           this.name=name;
           this.age=age;
      }
      Animal.prototype={
        constructor:Animal,
        eat:function(){
          console.log('我在吃东西');
        },
        run:function(){
          console.log('我在跑');
        }
      }
      var dog=new Animal('wangchai',3)
      console.log(Animal.prototype.constructor);
      console.log(dog.__proto__.constructor);
&lt;/script&gt;</code></pre>
<p><img alt="" height="290" src="image\6d31d7e55a5d4041973d41c23a00e1d8.png" width="1039"/></p>
<p>这样我们就可以成功拿到其 constructor 指向的哪个构造函数了</p>
<h3 id="%E5%85%B6%E6%A0%BC%E5%BC%8F%E4%B8%BA%EF%BC%9A">其格式为：</h3>
<ul><li><span style="color:#1c7331;"><strong>constructor : 构造函数名 </strong></span></li></ul>
</blockquote>
<h1 id="%E8%BF%99%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E7%9A%84%E5%86%85%E5%AE%B9%E5%B0%B1%E5%88%B0%E8%BF%99%E9%87%8C%EF%BC%8C%E4%B8%8B%E4%B8%80%E7%AF%87%E6%9B%B4%E7%B2%BE%E5%BD%A9%E5%93%A6%20%EF%BC%81%EF%BC%81"><span style="color:#956fe7;">这一篇文章的内容就到这里，下一篇更精彩哦 ！！</span></h1>
<p></p>
<p></p>
</div>
</div>