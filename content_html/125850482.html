<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<blockquote>
<p>✅作者简介：大家好我是@每天都要敲代码，一位材料转码农的选手，希望一起努力，一起进步！<br/> 📃个人主页：<a href="https://blog.csdn.net/m0_61933976?spm=1010.2135.3001.5421" title="@每天都要敲代码的个人主页">@每天都要敲代码的个人主页</a><br/> 💬推荐一款模拟面试、刷题神器，从基础到大厂面试题👉<a href="https://www.nowcoder.com/link/pc_csdncpt_mtdyqdm_c" title="点击跳转刷题网站进行注册学习">点击跳转刷题网站进行注册学习</a></p>
</blockquote>
<p id="main-toc"><strong>目录</strong></p>
<p id="%F0%9F%A5%85IO%E6%B5%81%E7%90%86%E8%AE%BA%E6%A6%82%E8%BF%B0-toc" style="margin-left:0px;"><a href="#%F0%9F%A5%85IO%E6%B5%81%E7%90%86%E8%AE%BA%E6%A6%82%E8%BF%B0">🥅IO流理论概述</a></p>
<p id="1.%E4%BB%80%E4%B9%88%E6%98%AFIO-toc" style="margin-left:80px;"><a href="#1.%E4%BB%80%E4%B9%88%E6%98%AFIO">1.什么是IO</a></p>
<p id="2.IO%E6%B5%81%E7%9A%84%E5%88%86%E7%B1%BB-toc" style="margin-left:80px;"><a href="#2.IO%E6%B5%81%E7%9A%84%E5%88%86%E7%B1%BB">2.IO流的分类</a></p>
<p id="3.%E6%B5%81%E7%9A%84%E5%9B%9B%E5%A4%A7%E5%AE%B6%E6%97%8F-toc" style="margin-left:80px;"><a href="#3.%E6%B5%81%E7%9A%84%E5%9B%9B%E5%A4%A7%E5%AE%B6%E6%97%8F">3.流的四大家族</a></p>
<p id="4.%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1%E7%9A%84%E5%8D%81%E5%85%AD%E4%B8%AA%E6%B5%81-toc" style="margin-left:80px;"><a href="#4.%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1%E7%9A%84%E5%8D%81%E5%85%AD%E4%B8%AA%E6%B5%81">4.需要掌握的十六个流</a></p>
<p id="%F0%9F%A5%85%E5%AD%97%E8%8A%82%E8%BE%93%E5%85%A5%E6%B5%81FileInputStream-toc" style="margin-left:0px;"><a href="#%F0%9F%A5%85%E5%AD%97%E8%8A%82%E8%BE%93%E5%85%A5%E6%B5%81FileInputStream">🥅字节输入流FileInputStream</a></p>
<p id="1.FileInputStream%E5%88%9D%E6%AD%A5%E7%90%86%E8%A7%A3-toc" style="margin-left:80px;"><a href="#1.FileInputStream%E5%88%9D%E6%AD%A5%E7%90%86%E8%A7%A3">1.FileInputStream初步理解</a></p>
<p id="2.FileInputStream%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-toc" style="margin-left:80px;"><a href="#2.FileInputStream%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95">2.FileInputStream常用方法</a></p>
<p id="%F0%9F%A5%85%E5%AD%97%E8%8A%82%E8%BE%93%E5%87%BA%E6%B5%81FileOutputStream-toc" style="margin-left:0px;"><a href="#%F0%9F%A5%85%E5%AD%97%E8%8A%82%E8%BE%93%E5%87%BA%E6%B5%81FileOutputStream">🥅字节输出流FileOutputStream</a></p>
<p id="%F0%9F%A5%85%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9D-toc" style="margin-left:0px;"><a href="#%F0%9F%A5%85%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9D">🥅任意文件拷贝</a></p>
<p id="%F0%9F%A5%85FileReader%20%26%26%20FileWriter%20%26%26%20%E6%99%AE%E9%80%9A%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9D-toc" style="margin-left:0px;"><a href="#%F0%9F%A5%85FileReader%20%26%26%20FileWriter%20%26%26%20%E6%99%AE%E9%80%9A%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9D">🥅FileReader &amp;&amp; FileWriter &amp;&amp; 普通文件拷贝</a></p>
<p id="1.%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E6%B5%81FileReader-toc" style="margin-left:80px;"><a href="#1.%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E6%B5%81FileReader">1.字符输入流FileReader</a></p>
<p id="2.%E5%AD%97%E7%AC%A6%E8%BE%93%E5%87%BA%E6%B5%81FileWriter-toc" style="margin-left:80px;"><a href="#2.%E5%AD%97%E7%AC%A6%E8%BE%93%E5%87%BA%E6%B5%81FileWriter">2.字符输出流FileWriter</a></p>
<p id="3.%E6%99%AE%E9%80%9A%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9D-toc" style="margin-left:80px;"><a href="#3.%E6%99%AE%E9%80%9A%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9D">3.普通文件拷贝</a></p>
<p id="%E7%BB%93%E6%9D%9F%E8%AF%AD-toc" style="margin-left:0px;"><a href="#%E7%BB%93%E6%9D%9F%E8%AF%AD">结束语</a></p>
<hr id="hr-toc"/>
<p></p>
<h1 id="%F0%9F%A5%85IO%E6%B5%81%E7%90%86%E8%AE%BA%E6%A6%82%E8%BF%B0">🥅IO流理论概述</h1>
<h3 id="1.%E4%BB%80%E4%B9%88%E6%98%AFIO"><strong>1.什么是IO</strong></h3>
<blockquote>
<p>❤️什么是IO？IO有什么用？</p>
<p>      ⭐️<strong>I代表Input</strong>，把<span style="color:#fe2c24;">硬盘里的文件放到内存里</span>，就叫做输入(Input)，也就是<span style="color:#fe2c24;">读</span></p>
<p>      ⭐️<strong>O代表Output</strong>，把<span style="color:#fe2c24;">内存里的文件放到硬盘里</span>，就叫做输出(Output)，也就是<span style="color:#fe2c24;">写</span></p>
<p>❤️通过IO流可以完成文件的读和写！并且<strong>读和写都是以内存为参照的！</strong></p>
</blockquote>
<p><img alt="" height="476" src="image\f13a42fa9e5f4487a4a2a99364f68e84.png" width="1200"/></p>
<h3></h3>
<h3 id="2.IO%E6%B5%81%E7%9A%84%E5%88%86%E7%B1%BB"><strong>2.IO流的分类</strong></h3>
<blockquote>
<p><strong>❤️IO流的分类？有多种分类方式：</strong><br/>     ⭐️第一种方式是<strong><span style="color:#fe2c24;">按照流的方向</span></strong>进行分类（<strong>以内存作为参照物</strong>）：            <br/>     （1）<span style="color:#fe2c24;">往内存中去，叫做输入(Input)。或者叫做读(Read)。</span><br/>     （2）<span style="color:#fe2c24;">从内存中出来，叫做输出(Output)。或者叫做写(Write)。</span><br/>     ⭐️另一种方式是<strong><span style="color:#fe2c24;">按照读取数据方式不同</span></strong>进行分类：<br/>     （1）有的流是<span style="color:#fe2c24;">按照<strong>字节</strong>的方式读取数据</span>，一次读取1个字节byte，等同于一次读取8个二进制位。这种流是万能的，<strong>什么类型的文件都可以读取</strong>。包括：文本文件，图片，声音文件，视频文件等....<br/>      例：假设文件file1.txt，采用字节流的话是这样读的：<br/>              a中国bc张三fe<br/>              第一次读：一个字节，正好读到'a'<br/>              第二次读：一个字节，正好读到'中'字符的一半。<br/>              第三次读：一个字节，正好读到'中'字符的另外一半。<br/>    （2）有的流是<span style="color:#fe2c24;">按照<strong>字符</strong>的方式读取数据</span>，一次读取一个字符，这种流是为了方便读取<br/>    普通文本文件而存在的，这种流不能读取：图片、声音、视频等文件。<strong>只能读取纯文本文件，连word文件都无法读取。</strong><br/>    例：假设文件file1.txt，采用字符流的话是这样读的：<br/>            a中国bc张三fe<br/>            第一次读：'a'字符（'a'字符在windows系统中占用1个字节。）<br/>            第二次读：'中'字符（'中'字符在windows系统中占用2个字节。）<br/>   ⭐️综上所述：流的分类<br/>         <span style="color:#fe2c24;">（1）输入流、输出流<br/>         （2）字节流、字符流</span></p>
</blockquote>
<h3></h3>
<h3 id="3.%E6%B5%81%E7%9A%84%E5%9B%9B%E5%A4%A7%E5%AE%B6%E6%97%8F"><strong>3.流的四大家族</strong></h3>
<blockquote>
<p><strong>❤️</strong>Java中的IO流都已经写好了，我们最主要还是掌握，在java中已经提供了哪些流，每个流的特点是什么，每个流对象上的常用方法有哪些<br/>     ⭐️java中<strong>所有的流</strong>都是在：<span style="color:#fe2c24;">java.io.*</span>;</p>
<p>    ⭐️ java中主要还是研究：怎么new流对象？调用流对象的哪个方法是读？哪个方法是写？</p>
<p><strong>❤️java IO流这块有四大家族</strong><strong>：</strong><br/>     ⭐️四大家族的四个首领：（<strong>都是抽象类</strong>(abstract class)）<br/>        <span style="color:#fe2c24;"> java.io.InputStream</span>          ​​​​<span style="color:#0d0016;">字节输入流（读）</span><br/>        <span style="color:#fe2c24;"> java.io.OutputStream       </span><span style="color:#0d0016;">字节输出流（写）</span></p>
<p><span style="color:#fe2c24;">        java.io.Reader </span>               ​​​​  <span style="color:#0d0016;">字符输入流（读）</span><br/>        <span style="color:#fe2c24;"> java.io.Writer </span>     <span style="color:#0d0016;">              字符输出流（写）</span></p>
<p>   ⭐️<strong>所有的<span style="color:#fe2c24;">流</span>都实现了：</strong></p>
<p>           （1）<strong><span style="color:#fe2c24;">java.io.Closeable接口，都是可关闭的，都有close()方法</span></strong>。<br/>            （2） 流，毕竟是一个管道，这个是内存和硬盘之间的通道，用完之后一定要关闭，<br/>              不然会耗费(占用)很多资源。养成好习惯，用完流一定要关闭。</p>
<p>   ⭐️<strong>所有的<span style="color:#fe2c24;">输出流</span>都实现了：</strong><br/>            （1）<span style="color:#fe2c24;"><strong> java.io.Flushable接口，都是可刷新的，都有flush()方法。</strong></span><br/>            （2）养成一个好习惯，输出流在最终输出之后，一定要记得flush()刷新一下，<br/>              这个刷新表示将通道/管道当中剩余未输出的数据强行输出完（清空管道），<br/>            （3）<strong>注意：</strong>  <strong>刷新的作用就是清空管道；</strong>如果没有flush()可能会导致丢失数据。<br/><strong>❤️</strong><strong>注意：<span style="color:#fe2c24;">在java中只要“类名”以Stream结尾的都是字节流。以“Reader/Writer”结尾的都是字符流。</span></strong></p>
</blockquote>
<p></p>
<h3 id="4.%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1%E7%9A%84%E5%8D%81%E5%85%AD%E4%B8%AA%E6%B5%81"><strong>4.需要掌握的十六个流</strong></h3>
<blockquote>
<p><strong>❤️java.io包下需要掌握的流有16个：</strong></p>
<p><strong> ⭐️文件专属：</strong><br/>       <span style="color:#fe2c24;">  java.io.FileInputStream（掌握）<br/>         java.io.FileOutputStream（掌握）<br/>         java.io.FileReader<br/>         java.io.FileWriter</span></p>
<p><strong> ⭐️转换流：（将字节流转换成字符流）</strong><br/>      <span style="color:#fe2c24;">   java.io.InputStreamReader<br/>         java.io.OutputStreamWriter</span></p>
<p><strong> ⭐️缓冲流专属：</strong><br/>      <span style="color:#fe2c24;">   java.io.BufferedReader<br/>         java.io.BufferedWriter<br/>         java.io.BufferedInputStream<br/>         java.io.BufferedOutputStream</span></p>
<p><strong> ⭐️数据流专属：</strong><br/>       <span style="color:#fe2c24;">  java.io.DataInputStream<br/>         java.io.DataOutputStream</span></p>
<p><strong> ⭐️标准输出流：</strong><br/>       <span style="color:#fe2c24;">  java.io.PrintWriter<br/>         java.io.PrintStream（掌握）</span></p>
<p><strong> ⭐️对象专属流：</strong><br/>       <span style="color:#fe2c24;">  java.io.ObjectInputStream（掌握）<br/>         java.io.ObjectOutputStream（掌握）</span></p>
</blockquote>
<p></p>
<h1 id="%F0%9F%A5%85%E5%AD%97%E8%8A%82%E8%BE%93%E5%85%A5%E6%B5%81FileInputStream">🥅字节输入流FileInputStream</h1>
<h3 id="1.FileInputStream%E5%88%9D%E6%AD%A5%E7%90%86%E8%A7%A3"><strong>1.FileInputStream初步理解</strong></h3>
<blockquote>
<p style="margin-left:0;text-align:justify;"><strong>⭐️java.io.FileInputStream:</strong><br/>     1、文件字节输入流，万能的，任何类型的文件都可以采用这个流来读。<br/>     2、字节的方式，完成输入的操作，完成读的操作（硬盘---&gt; 内存）</p>
<p style="margin-left:0;text-align:justify;">    3、调用read()方法进行读，返回的是int类型(字符对应的ASCII码）；没有元素的话，返回的是-1</p>
</blockquote>
<pre><code class="language-java">package com.bjpowernode.java.io;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;

public class FileInputStreamTest01 {
    public static void main(String[] args) {
        // 创建文件字节输入流对象
        // 文件路径：//C:\Java学习\temp.txt
        //（里面存的是abc，IDEA会自动把\编程\\，因为java中\表示转义）
        // FileInputStream这个方法会抛出异常，父类是Exception，属于编译时异常，需要处理
        FileInputStream fis = null; //写到外面，主要是为了finally里面能够调用
        try {  //C:/Java学习/temp.txt，路径写成这样也是可以的
            fis = new FileInputStream("C:\\Java学习\\temp.txt");
            //1、读文件，从此输入流中读取一个字节
            int readDate = fis.read();
            System.out.println(readDate); //97

            readDate = fis.read();
            System.out.println(readDate); //98

            readDate = fis.read();
            System.out.println(readDate); //99

            readDate = fis.read();
            System.out.println(readDate); //-1；最终没数据了，就返回-1
            
            //2、循环读
           while(true){
               int readDate1 = fis.read();
               if(readDate1 == -1){ // 没有数据返回的是-1
                   break;
               }
               System.out.println(readDate1);
           }

            //3、优化while
            int readDate1 = 0;
            while((readDate1 = fis.read()) != -1){
                System.out.println(readDate1);
            }

        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) { //read时候，补充的异常处理
            e.printStackTrace();
        } finally {
            // 加上finally关键字，无论最终有没有异常，都需要关闭这个流
            // 在finally语句块当中确保流一定关闭
            if (fis != null) { //生成这个的快捷键ifn
                // 关闭流的前提，流不是null；是空没必要关闭
                try {
                    fis.close(); //有异常，try...catch
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
</code></pre>
<blockquote>
<p><strong>⭐️</strong>分析上面这个程序的<strong>缺点</strong>：<br/> （1）一次读取一个字节byte，这样内存和硬盘交互太频繁，基本上时间/资源都耗费在交互上面了。所以能不能一次读取多个字节呢？答案是可以的。</p>
<p>（2）<span style="color:#fe2c24;"><strong>int read(byte[] b)</strong></span>；<strong> 一次最多读取 b.length 个字节</strong>。<br/>     减少硬盘和内存的交互，提高程序的执行效率；往byte[]数组当中读。</p>
<p>（3）这里我们不在使用绝对路径，而是相对路径；那么IDEA默认的路径是什么呢？</p>
<p style="margin-left:0;text-align:justify;">       <strong> 工程Project的根就是IDEA的默认当前路径；</strong></p>
</blockquote>
<pre><code class="language-java">package com.bjpowernode.java.io;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;

public class FileInputStreamTest02 {
    public static void main(String[] args) {
        FileInputStream fis = null;
        try {
            // 我们写成相对路径方式，在这里要先理解在IDEA默认的当前路径是哪里？
            // 工程Project的根就是IDEA的默认当前路径；例如我的：C:\Users\86177\IdeaProjects\JavaSe1
            //fis = new FileInputStream("tempfile.txt"); //这是在工程下面的tempfile.txt
            // 如果是day06模块下的src包下有一个tempfile.txt，怎么调用呢？
            fis = new FileInputStream("day06/src/tempfile.txt"); //存放的是abcdef

            // 开始读，采用byte数组，一次读取多个字节。最多读取“数组.length”个字节。
            byte[] bytes = new byte[4];  准备一个4个长度的byte数组，一次最多读取4个字节

           /* 1、普通打印
           int readCount = fis.read(bytes); // 返回的是当前的读取到的字节数量。（不是字节本身）
            System.out.println(readCount); // 4;第一次读到了4个字节
            //System.out.println(new String(bytes)); //abcd，将字符数组全部转换成字符串
            // 实际上应该读到多少个，就转换多少个
            System.out.println(new String(bytes,0,readCount)); // abcd

            readCount = fis.read(bytes);
            System.out.println(readCount); // 2;第二次只能读取到2个字节
            //System.out.println(new String(bytes)); //efcd，将字符数组全部转换成字符串，这里就出了问题
            System.out.println(new String(bytes,0,readCount)); //ef

            readCount = fis.read(bytes);
            System.out.println(readCount); //1个字节都没有读取到返回-1*/


           //2、 写成循环
            while(true){
                int readCount = fis.read(bytes);
                if(readCount == -1){
                    break;
                }
                System.out.print(new String(bytes,0,readCount)); // abcdef
            }

            //3、 代码优化
           int readCount = 0;
            while((readCount = fis.read(bytes)) != -1){
                // 将读取到的将字符数组全部转换成字符串
                System.out.print(new String(bytes,0,readCount)); // abcdef
            }

        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }finally{
            if (fis != null) {
                try {
                    fis.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }

    }
}
</code></pre>
<h3></h3>
<h3 id="2.FileInputStream%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><strong>2.FileInputStream常用方法</strong></h3>
<blockquote>
<p style="margin-left:0;text-align:justify;"><strong>❤️FileInputStream类的其它常用方法：</strong></p>
<p style="margin-left:0;text-align:justify;">      ⭐<span style="color:#fe2c24;">int available()</span>：<strong>返回流当中剩余的没有读到的字节数量</strong></p>
<p style="margin-left:0;text-align:justify;">      ⭐<span style="color:#fe2c24;">long skip(long n)</span>：<strong>跳过几个字节不读</strong></p>
</blockquote>
<pre><code class="language-java">package com.bjpowernode.java.io;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;

public class FileInputStreamTest03 {
    public static void main(String[] args) {
        FileInputStream fis = null;
        try {
            fis = new FileInputStream("tempfile.txt"); // 存的abcdef
            // 先读一个字节
            int readByte = fis.read();
            System.out.println(readByte); // 97
            //1、available方法，还剩下多少字节
            System.out.println(fis.available()); // 5，还剩下5个字节
            // available方法有什么用？
            // 我们知道当前有的字节数，就不用使用循环了，直接指定当前长度就行
            // 这种方式不太适合太大的文件，因为byte[]数组不能太大。
            byte[] bytes = new byte[fis.available()]; //不需要循环，直接读一次就行
            int readCount = fis.read(bytes);
            System.out.println(new String(bytes,0,readCount));

            // 2、skip方法，跳过几个字节
            fis = new FileInputStream("tempfile.txt");
            // 跳过3个字节
            fis.skip(3);
            System.out.println(fis.read()); //100（d）


        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                fis.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
</code></pre>
<p></p>
<h1 id="%F0%9F%A5%85%E5%AD%97%E8%8A%82%E8%BE%93%E5%87%BA%E6%B5%81FileOutputStream">🥅字节输出流FileOutputStream</h1>
<blockquote>
<p style="margin-left:0;text-align:justify;">❤️文件字节输出流，从内存到硬盘，负责写；怎么写呢？</p>
<p style="margin-left:0;text-align:justify;"> ⭐如果当前文件不存在，会自动创建！</p>
<p style="margin-left:0;text-align:justify;"> ⭐如果当前文件已经存在，会把原来文件的内容进行清空覆盖！</p>
<p style="margin-left:0;text-align:justify;"> ⭐后面的<span style="color:#fe2c24;"><strong>参数直接跟的是byte数组</strong></span>；</p>
<p style="margin-left:0;text-align:justify;"> ⭐如果是字符串，<strong>字符串转字节数组</strong>需要<span style="color:#fe2c24;">用getBytes()方法</span>，把<strong>字符串转换成byte数组；</strong>而把byte数组转换成字符串用的是new String(byte数组)<strong>       </strong></p>
</blockquote>
<pre><code class="language-java">package com.bjpowernode.java.io;

import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;

public class FileOutputStreamTest01 {
    public static void main(String[] args) {
        FileOutputStream fos = null;
        try {
            //1、 myfile文件如果不存在的时候会自动新建！
            // 这种方式谨慎使用，会先将原文件清空，然后重新写入。
            fos = new FileOutputStream("myfile");

            //2、以追加的方式在文件末尾写入。不会清空原文件内容。
            fos = new FileOutputStream("myfile",true);

            //3、开始写，写到数组里
            byte[] bytes = {97,98,99,100};
            fos.write(bytes); // 写进去abcd

            //4、将byte数组的一部分写出
            fos.write(bytes,0,2); //写进去ab

            //5、写一个字符串，然后把字符串转换成byte数组
            String s = "我是一个中国人！";
            //将一个字符串转换成byte数组
            byte[] byts = s.getBytes();
            fos.write(byts); //写进去“我是一个中国人！”

            //6、写完之后一定要刷新
            fos.flush();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (fos != null) {
                try {
                    fos.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
</code></pre>
<p></p>
<h1 id="%F0%9F%A5%85%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9D">🥅任意文件拷贝</h1>
<blockquote>
<p>有了上面的输入流和输出流学习，我们是不是就可以尝试完成一个文件拷贝的功能，无非就是读、写的结合应用，下面我们先看一下原理图：</p>
</blockquote>
<p><img alt="" height="707" src="image\eef9cd5c7a51451f8f7cec9c4a214cf8.png" width="1200"/></p>
<blockquote>
<p>⭐使用<strong>FileInputStream + FileOutputStream完成文件的拷贝</strong>。</p>
<p>⭐拷贝的过程应该是<strong>一边读，一边写</strong>。</p>
<p>⭐使用<strong>字节流拷贝文件</strong>的时候，文件类型随意，什么样的文件都能拷贝。</p>
</blockquote>
<pre><code class="language-java">package com.bjpowernode.java.io;


import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;

public class CopyTest {
    public static void main(String[] args) {
        FileInputStream fis = null;
        FileOutputStream fos = null;
        try {
            //1、 创建一个输入流对象
            fis = new FileInputStream("C:\\Java学习\\javaSE学习\\2.JavaSE初学习笔记\\2.第一章：Java环境搭建\\HelloWorld.java");
            //2、 创建一个输出流对象
            fos = new FileOutputStream("C:\\Java学习\\HelloWorld.java");

            //3、 最核心的部分：一边读，一边写
            byte[] bytes = new byte[1024 * 1024]; // 1MB（一次最多拷贝1MB。）
            int readCount = 0;
            while((readCount = fis.read(bytes)) != -1) {
                fos.write(bytes, 0, readCount);
            }

            //4、 刷新，输出流最后要刷新
            fos.flush();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            // 分开try，不要一起try。
            // 一起try的时候，其中一个出现异常，可能会影响到另一个流的关闭。
            if (fos != null) {
                try {
                    fos.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            if (fis != null) {
                try {
                    fis.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
</code></pre>
<h3></h3>
<h1 id="%F0%9F%A5%85FileReader%20%26%26%20FileWriter%20%26%26%20%E6%99%AE%E9%80%9A%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9D">🥅FileReader &amp;&amp; FileWriter &amp;&amp; <strong>普通</strong>文件拷贝</h1>
<h3 id="1.%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E6%B5%81FileReader"><strong>1.字符输入流FileReader</strong></h3>
<blockquote>
<p>（1）对于字符输入输出流FileReader 和 FileWriter的用法，与字节输入输出流<strong>FileInputStream </strong>和 <strong><span style="color:#fe2c24;">FileOutputStream</span></strong>的用法很相似；后者我们已经学过<strong>使用byte数组</strong>，前者是<span style="color:#fe2c24;"><strong>使用char数组</strong></span>！</p>
<p style="margin-left:0;text-align:justify;">（2）FileReader： 文件字符输入流，只能读取普通文本。 读取文本内容时，比较方便，快捷。</p>
</blockquote>
<pre><code class="language-java">package com.bjpowernode.java.io;

import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;

public class FileReaderTest01 {
    public static void main(String[] args) {
        FileReader reader = null;
        try {
            // 创建文件字符输入流
            reader  = new FileReader("C:\\Java学习\\javaSE学习\\2.JavaSE初学习笔记\\2.第一章：Java环境搭建\\HelloWorld.java");
            // 开始读
            char[] chars = new char[4]; // 一次读取4个字符

            // 第一种方法
           int readCount = 0;
            while((readCount = reader.read(chars)) != -1){
                System.out.print(new String(chars,0,readCount));
            }

            // 补充
            // reader.read(chars); // 往char数组中读
            
            // 按照字符的方式读取，一次读取一个字符
            for(char c :chars){
                System.out.println(c);
            }

        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (reader != null) {
                try {
                    reader.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }

    }
}
</code></pre>
<p></p>
<h3 id="2.%E5%AD%97%E7%AC%A6%E8%BE%93%E5%87%BA%E6%B5%81FileWriter"><strong>2.字符输出流FileWriter</strong></h3>
<blockquote>
<p>（1）FileWriter：文件字符输出流，写；只能输出普通文本！例如：图片、声音、视频、word文件等，都不可以！</p>
<p>（2）后面的参数<span style="color:#fe2c24;">直接跟的是char数组；也可以直接跟字符串</span>！</p>
</blockquote>
<pre><code class="language-java">package com.bjpowernode.java.io;

import java.io.FileWriter;
import java.io.IOException;

public class FileWriterTest01 {
    public static void main(String[] args) {
        FileWriter writer = null;
        try {
            //1、 创建文件字符输出流对象
            writer = new FileWriter("file",true); //file，没有会自动创建

            //2、 开始写
            char[] chars = {'我','是','中','国','人'};
            // 写整个数组的内容
            writer.write(chars);
            // 也可以只写数组的一部分
            writer.write(chars,0,2);
            // 后面也可以直接跟字符串
            writer.write("\n"); // 换行
            writer.write("我很骄傲");

            //3、 刷新
            writer.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }finally{
            if (writer != null) {
                try {
                    writer.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
</code></pre>
<h3></h3>
<h3 id="3.%E6%99%AE%E9%80%9A%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9D"><strong>3.普通文件拷贝</strong></h3>
<blockquote>
<p>使用FileReader 和 FileWriter进行拷贝，只能拷贝“普通文本”文件（能用记事本编辑的）！</p>
</blockquote>
<pre><code class="language-java">package com.bjpowernode.java.io;

import java.io.*;

public class CopyTest02 {
    public static void main(String[] args) {
        FileReader reader = null;
        FileWriter writer = null;

        {
            try {
                // 创建字符输入流
                reader = new FileReader("file");
                // 创建字符输出流
                writer = new FileWriter("myfile");

                // 边读边写
                char[] chars = new char[1024*1024]; // 1MB
                int readCount = 0;
                while((readCount = reader.read(chars)) != -1){
                    writer.write(chars,0,readCount);
                }

                // 刷新
                writer.flush();
            } catch (FileNotFoundException e) {
                e.printStackTrace();
            } catch (IOException e) {
                e.printStackTrace();
            }finally {
                if (reader != null) {
                    try {
                        reader.close();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
                if(writer != null){
                    try {
                        writer.close();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }

}
</code></pre>
<h1 id="%E7%BB%93%E6%9D%9F%E8%AF%AD">结束语</h1>
<blockquote>
<p>今天的分享就到这里啦！快快通过下方链接注册加入刷题大军吧！各种大厂面试真题在等你哦！</p>
<p> 💬刷题神器，从基础到大厂面试题👉<a href="https://www.nowcoder.com/link/pc_csdncpt_mtdyqdm_c" title="点击跳转刷题网站">点击跳转刷题网站</a></p>
</blockquote>
<p><img alt="" height="511" src="image\184068dc41e94efbb14e555f972eaa17.png" width="1200"/></p>
<p></p>
</div>
</div>