<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<p id="main-toc"><strong>目录</strong></p>
<p id="%E4%B8%80%E3%80%81%E9%9C%80%E6%B1%82-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E9%9C%80%E6%B1%82">一、需求</a></p>
<p id="Rectangle(Point%2C%20Size)-toc" style="margin-left:40px;"><a href="#Rectangle%28Point%2C%20Size%29">Rectangle(Point, Size)</a></p>
<p id="Rectangle(Int32%2C%20Int32%2C%20Int32%2C%20Int32)-toc" style="margin-left:40px;"><a href="#Rectangle%28Int32%2C%20Int32%2C%20Int32%2C%20Int32%29">Rectangle(Int32, Int32, Int32, Int32)</a></p>
<p id="%E4%BA%8C%E3%80%81%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8A%9F%E8%83%BD-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8A%9F%E8%83%BD">二、常用的功能</a></p>
<p id="1.%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E7%9F%A9%E5%BD%A2%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4-toc" style="margin-left:40px;"><a href="#1.%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E7%9F%A9%E5%BD%A2%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4">1.判断两个矩形是否相交</a></p>
<p id="2.%E6%B1%82%E5%87%BA%E4%B8%A4%E7%9F%A9%E5%BD%A2%E7%9B%B8%E4%BA%A4%E9%87%8D%E5%8F%A0%E5%A4%84%E7%9A%84%E7%9F%A9%E5%BD%A2-toc" style="margin-left:40px;"><a href="#2.%E6%B1%82%E5%87%BA%E4%B8%A4%E7%9F%A9%E5%BD%A2%E7%9B%B8%E4%BA%A4%E9%87%8D%E5%8F%A0%E5%A4%84%E7%9A%84%E7%9F%A9%E5%BD%A2">2.求出两矩形相交重叠处的矩形</a></p>
<p id="3.%E6%A1%88%E4%BE%8B-toc" style="margin-left:40px;"><a href="#3.%E6%A1%88%E4%BE%8B">3.案例</a></p>
<p id="%E4%B8%89%E3%80%81%E5%88%87%E5%9B%BEDemo-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E5%88%87%E5%9B%BEDemo">三、切图Demo</a></p>
<p id="%E7%BB%93%E6%9D%9F-toc" style="margin-left:0px;"><a href="#%E7%BB%93%E6%9D%9F">结束</a></p>
<hr id="hr-toc"/>
<p></p>
<p></p>
<h1 id="%E4%B8%80%E3%80%81%E9%9C%80%E6%B1%82">一、需求</h1>
<p>矩形在开发中非常常见，比如截图功能，GDI+ 画图，Rectangle 的构造函数中，需要提供四个参数，坐标x，y，宽度，高度，另外还封装了其他的一写方法，比如是否相交，两矩形相交处重叠的矩形，根据左上，和右下坐标生成矩形等等方法，下面是构造函数的一些介绍。</p>
<p>构造函数：</p>
<h2 id="Rectangle(Point%2C%20Size)">Rectangle(Point, Size)</h2>
<p>用指定的位置和大小初始化 Rectangle 类的新实例。</p>
<pre><code class="language-cs">public Rectangle (System.Drawing.Point location, System.Drawing.Size size);</code></pre>
<p>参数：location Point  Point，它表示矩形区域的左上角。size Size  Size，它表示矩形区域的宽度和高度。</p>
<h2 id="Rectangle(Int32%2C%20Int32%2C%20Int32%2C%20Int32)">Rectangle(Int32, Int32, Int32, Int32)</h2>
<p>用指定的位置和大小初始化 Rectangle 类的新实例。</p>
<pre><code class="language-cs">public Rectangle (int x, int y, int width, int height);</code></pre>
<p>参数：x Int32 矩形左上角的 x 坐标。y Int32 矩形左上角的 y 坐标。width Int32 矩形的宽度。height Int32 矩形的高度。</p>
<p><br/>  </p>
<h1 id="%E4%BA%8C%E3%80%81%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8A%9F%E8%83%BD">二、常用的功能</h1>
<h2 id="1.%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E7%9F%A9%E5%BD%A2%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4">1.判断两个矩形是否相交</h2>
<p>判断连个矩形是否相交，返回值是布尔类型</p>
<pre><code class="language-cs">Rectangle rectangle1 = new Rectangle(100,100,50,50);
Rectangle rectangle2 = new Rectangle(110,110,50,50);
bool isIntersect = rectangle1.IntersectsWith(rectangle2);</code></pre>
<h2 id="2.%E6%B1%82%E5%87%BA%E4%B8%A4%E7%9F%A9%E5%BD%A2%E7%9B%B8%E4%BA%A4%E9%87%8D%E5%8F%A0%E5%A4%84%E7%9A%84%E7%9F%A9%E5%BD%A2">2.求出两矩形相交重叠处的矩形</h2>
<p>两个矩形相交后，根据两个矩形的重叠处，得出一个新的矩形</p>
<pre><code class="language-cs">Rectangle rectangle1 = new Rectangle(100,100,50,50);
Rectangle rectangle2 = new Rectangle(110,110,50,50);
Rectangle overlap = Rectangle.Intersect(rectangle1, rectangle2);</code></pre>
<h2 id="3.%E6%A1%88%E4%BE%8B">3.案例</h2>
<p>上面这两个API，下面就用一个案例来展示</p>
<p>效果</p>
<p style="text-align:center;"><img alt="" class="left" src="https://img-blog.csdnimg.cn/9e9175279a734536af9fc8cf560d48e1.gif"/></p>
<p>上图可以看到，当两个图像重合后，就立马将重合的部分图像显示在旁边的小图中了，另外，我将是否重合的判断输出在控制台中了</p>
<p><img alt="" height="234" src="image\29be643721ff4621a6a71d3c129a7152.png" width="300"/></p>
<p>界面设计</p>
<p><img alt="" height="383" src="image\fb96dfbcf9074bcf9e1a78757f20cff4.png" width="600"/></p>
<p>代码</p>
<pre><code class="language-cs">using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace 矩形
{
    public partial class Form1 : Form
    {
        public Form1()
        {
            InitializeComponent();
        }

        //图片列表
        private string Img1Path = Application.StartupPath + "\\test.jpg";
        //存储矩形列表
        List&lt;Rectangle&gt; PictureCuttingList = new List&lt;Rectangle&gt;();
        //边长
        int SideLength = 180;

        private void Form1_Load(object sender, EventArgs e)
        {

        }

        private void Button_Examine_Click(object sender, EventArgs e)
        {
            if (!System.IO.File.Exists(Img1Path))
            {
                Console.WriteLine("图片路径不存在：" + Img1Path);
                return;
            }

            Bitmap bitmaps = new Bitmap(Img1Path);
            Random random = new Random();

            PictureCuttingList.Clear();
            PictureBox_Coincide.Image = null;

            for (int i = 0; i &lt; 2; i++)
            {
                int x = random.Next(10, bitmaps.Width - SideLength);
                int y = random.Next(10, bitmaps.Height - SideLength);
                PictureCuttingList.Add(new Rectangle(new Point(x, y), new Size(SideLength, SideLength)));
            }

            //给图片画矩形
            PictureBox_Template.Image = PaintingRectangle(PictureCuttingList, bitmaps);

            //判断两个矩形是否相交
            Rectangle rectangle1 = PictureCuttingList[0];
            Rectangle rectangle2 = PictureCuttingList[1];

            bool isRect = rectangle1.IntersectsWith(rectangle2);
            Console.WriteLine("两个矩形是否相交：" + isRect);
            if (isRect)
            {
                //两个矩形相交部分图片显示到小图中
                Rectangle overlap = Rectangle.Intersect(rectangle1, rectangle2);
                Bitmap newBitmap = new Bitmap(Img1Path);
                Bitmap cuttingBitmap = newBitmap.Clone(overlap, System.Drawing.Imaging.PixelFormat.DontCare);
                PictureBox_Coincide.Image = cuttingBitmap;
            }
        }

        /// &lt;summary&gt;
        /// 给图片画矩形
        /// &lt;/summary&gt;
        /// &lt;param name="rectanglesList"&gt;&lt;/param&gt;
        /// &lt;param name="bitmap"&gt;&lt;/param&gt;
        public Bitmap PaintingRectangle(List&lt;Rectangle&gt; rectanglesList, Bitmap bitmap)
        {
            Bitmap bit = null;
            for (int i = 0; i &lt; rectanglesList.Count; i++)
            {
                if (bit == null)
                {
                    bit = DrawRectangleInPicture(bitmap, rectanglesList[i], Color.Red, 4, "索引：" + i, 25);
                }
                else
                {
                    Bitmap newBit = new Bitmap(bit);
                    bit.Dispose();
                    bit = DrawRectangleInPicture(newBit, rectanglesList[i], Color.Red, 4, "索引：" + i, 25);
                }
            }
            if (bit == null)
            {
                Console.WriteLine("bit等于null");
                return null;
            }

            return bit;
        }

        /// &lt;summary&gt;
        /// 图片上画矩形和标记文字
        /// &lt;/summary&gt;
        /// &lt;param name="bmp"&gt;图片bitmap&lt;/param&gt;
        /// &lt;param name="imgRectangle"&gt;矩形&lt;/param&gt;
        /// &lt;param name="lineColor"&gt;线条的颜色&lt;/param&gt;
        /// &lt;param name="lineWidth"&gt;线条&lt;/param&gt;
        /// &lt;param name="text"&gt;矩形的文本&lt;/param&gt;
        /// &lt;param name="fontSize"&gt;字体大小&lt;/param&gt;
        /// &lt;param name="ds"&gt;线条的线型&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public Bitmap DrawRectangleInPicture(Bitmap bmp, Rectangle imgRectangle, Color lineColor, int lineWidth, string text, int fontSize, DashStyle ds = DashStyle.Solid)
        {
            if (bmp == null) return null;
            if (imgRectangle == null) return null;
            if (lineColor == null) return null;
            if (lineWidth == 0) return null;
            if (fontSize == 0) return null;
            if (string.IsNullOrEmpty(text)) return null;

            Point pos = imgRectangle.Location;
            Size size = imgRectangle.Size;

            Graphics g = Graphics.FromImage(bmp);

            Brush brush = new SolidBrush(lineColor);
            Pen pen = new Pen(brush, lineWidth);
            pen.DashStyle = ds;

            //画坐标的原点（用于测试）
            g.DrawEllipse(pen, new Rectangle(pos.X, pos.Y, 15, 15));

            //画矩形
            //int rectX = pos.X - (size.Width / 2);
            //int rectY = pos.Y - (size.Height / 2);
            //g.DrawRectangle(pen, rectX, rectY, size.Width, size.Height);
            g.DrawRectangle(pen, pos.X, pos.Y, size.Width, size.Height);

            Font myFont = new Font("宋体", fontSize, FontStyle.Regular);
            Brush bush = new SolidBrush(lineColor);//填充的颜色

            //字体位置的计算
            SizeF sizeF = g.MeasureString(text, myFont);
            //int fontPosX = (int)(pos.X - (sizeF.Width / 2));
            //int fontPosY = (int)(pos.Y + (sizeF.Height / 2) + (size.Height / 2));
            //g.DrawString(text, myFont, bush, fontPosX, fontPosY);
            int fontPosX = (int)(pos.X + (size.Width / 2) - (sizeF.Width / 2));
            int fontPosY = (int)(pos.Y + (size.Height / 2) - (sizeF.Height / 2));
            g.DrawString(text, myFont, bush, fontPosX, fontPosY);

            g.Dispose();

            return bmp;
        }
    }
}
</code></pre>
<p></p>
<h1 id="%E4%B8%89%E3%80%81%E5%88%87%E5%9B%BEDemo">三、切图Demo</h1>
<p>切图的demo和上面的案例的功能类似</p>
<p>界面</p>
<p><img alt="" height="564" src="image\9190b9a0bf90414589e3c3aa6b976e39.png" width="600"/></p>
<p>效果</p>
<p style="text-align:center;"><img alt="" class="left" src="https://img-blog.csdnimg.cn/0e121a43c2624b3ab65457aea8ea2b23.gif"/></p>
<p> 上面gif图片的最后画面</p>
<p><img alt="" height="665" src="image\efed4b0bf1b54af2a3514c82b8df3a29.png" width="700"/></p>
<p> 代码</p>
<pre><code class="language-cs">using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace 裁切小图
{
    public partial class Form1 : Form
    {
        public Form1()
        {
            InitializeComponent();
        }

        string Img1Path = Application.StartupPath + "\\test.jpg";

        List&lt;PictureBox&gt; PictureBoxesList = new List&lt;PictureBox&gt;();
        List&lt;Rectangle&gt; PictureCuttingList = new List&lt;Rectangle&gt;();

        //切割小图的宽度
        int ImgWidth = 180;

        private void Form1_Load(object sender, EventArgs e)
        {
            TextBox_ImaPath.Text = Img1Path;

            PictureBoxesList.Add(pictureBox1);
            PictureBoxesList.Add(pictureBox2);
            PictureBoxesList.Add(pictureBox3);
            PictureBoxesList.Add(pictureBox4);
            PictureBoxesList.Add(pictureBox5);
        }

        /// &lt;summary&gt;
        /// 选择图片路径
        /// &lt;/summary&gt;
        /// &lt;param name="sender"&gt;&lt;/param&gt;
        /// &lt;param name="e"&gt;&lt;/param&gt;
        private void Button_SelectImg_Click(object sender, EventArgs e)
        {
            OpenFileDialog dialog = new OpenFileDialog();
            dialog.Multiselect = true;//该值确定是否可以选择多个文件
            dialog.Title = "请选择文件";
            dialog.Filter = "所有文件(*.*)|*.*";
            if (dialog.ShowDialog() == System.Windows.Forms.DialogResult.OK)
            {
                TextBox_ImaPath.Text = dialog.FileName;
                Img1Path = dialog.FileName;
                PictureBox_Template.Image = new Bitmap(Img1Path);
            }
        }

        /// &lt;summary&gt;
        /// 生成矩形图
        /// &lt;/summary&gt;
        /// &lt;param name="sender"&gt;&lt;/param&gt;
        /// &lt;param name="e"&gt;&lt;/param&gt;
        private void Button_Examine_Click(object sender, EventArgs e)
        {
            if (!System.IO.File.Exists(Img1Path))
            {
                Console.WriteLine("图片路径不存在：" + Img1Path);
                return;
            }
   
            Bitmap bitmaps = new Bitmap(Img1Path);
            Random random = new Random();

            //Console.WriteLine(string.Format("总宽度：{0} 总高度：{1}", Bitmaps.Width, Bitmaps.Height));

            PictureCuttingList.Clear();
            for (int i = 0; i &lt; 2; i++)
            {
                int x = random.Next(10, bitmaps.Width - ImgWidth);
                int y = random.Next(10, bitmaps.Height - ImgWidth);

                //这样写矩形会超出图片范围，可以用来测试
                //int x = random.Next(10, Bitmaps.Width);
                //int y = random.Next(10, Bitmaps.Height);

                //Console.WriteLine(string.Format("索引值: {0} x: {1}, y: {2}", i, x, y));

                PictureCuttingList.Add(new Rectangle(new Point(x, y), new Size(ImgWidth, ImgWidth)));
            }

            //给图片画矩形
            PictureBox_Template.Image = PaintingRectangle(PictureCuttingList, bitmaps);

        }

        /// &lt;summary&gt;
        /// 开始切割
        /// &lt;/summary&gt;
        /// &lt;param name="sender"&gt;&lt;/param&gt;
        /// &lt;param name="e"&gt;&lt;/param&gt;
        private void Button_Cutting_Click(object sender, EventArgs e)
        {
            if (!System.IO.File.Exists(Img1Path))
            {
                Console.WriteLine("图片路径不存在：" + Img1Path);
                return;
            }
            if (PictureCuttingList.Count == 0)
            {
                Console.WriteLine("PictureCuttingList不能为空");
                return;
            }

            Bitmap bitmaps = new Bitmap(Img1Path);
            List&lt;Bitmap&gt; cuttingList = CuttingHandle(PictureCuttingList, bitmaps);
            if (cuttingList != null &amp;&amp; cuttingList.Count &gt; 0)
            {
                for (int i = 0; i &lt; cuttingList.Count; i++)
                {
                    PictureBoxesList[i].Image = cuttingList[i];
                }
            }
        }

        /// &lt;summary&gt;
        /// 给图片画矩形
        /// &lt;/summary&gt;
        /// &lt;param name="rectanglesList"&gt;&lt;/param&gt;
        /// &lt;param name="bitmap"&gt;&lt;/param&gt;
        public Bitmap PaintingRectangle(List&lt;Rectangle&gt; rectanglesList, Bitmap bitmap)
        {
            Bitmap bit = null;
            for (int i = 0; i &lt; rectanglesList.Count; i++)
            {
                if (bit == null)
                {
                    bit = DrawRectangleInPicture(bitmap, rectanglesList[i], Color.Red, 4, "索引：" + i, 25);
                }
                else
                {
                    Bitmap newBit = new Bitmap(bit);
                    bit.Dispose();
                    bit = DrawRectangleInPicture(newBit, rectanglesList[i], Color.Red, 4, "索引：" + i, 25);
                }
            }
            if (bit == null)
            {
                Console.WriteLine("bit等于null");
                return null;
            }

            return bit;
        }

        /// &lt;summary&gt;
        /// 裁切图片（切片的坐标以左上角为原点)
        /// &lt;/summary&gt;
        /// &lt;param name="pictureCuttingList"&gt;区域数据列表&lt;/param&gt;
        /// &lt;param name="bitmap"&gt;图片bitmap&lt;/param&gt;
        /// &lt;returns&gt;切片的图片列表&lt;/returns&gt;
        public List&lt;Bitmap&gt; CuttingHandle(List&lt;Rectangle&gt; pictureCuttingList, Bitmap bitmap)
        {
            if (pictureCuttingList == null || pictureCuttingList.Count == 0)
            {
                Console.WriteLine("[CuttingHandle]pictureCuttingList不能为空");
                return null;
            }
            if (bitmap == null)
            {
                Console.WriteLine("[CuttingHandle]图片bitmap不能为空");
                return null;
            }

            List&lt;Bitmap&gt; bitmapList = new List&lt;Bitmap&gt;();
            for (int i = 0; i &lt; pictureCuttingList.Count; i++)
            {
                Rectangle rectangle = pictureCuttingList[i];
                if(rectangle == null)
                {
                    Console.WriteLine("[CuttingHandle]pictureCuttingList有值为空，index：" + i);
                    return null;
                }
                //判断坐标是否在图片范围内
                Point pos = rectangle.Location;
                Size size = rectangle.Size;
                if(pos.X &lt; 0 || pos.X + size.Width &gt; bitmap.Width)
                {
                    Console.WriteLine("[CuttingHandle]当前区域X轴超出图片范围，索引是：" + i);
                    return null;
                }
                if(pos.Y &lt; 0 || pos.Y + size.Height &gt; bitmap.Height)
                {
                    Console.WriteLine("[CuttingHandle]当前区域Y轴超出图片范围，索引是：" + i);
                    return null;
                }

                Bitmap cuttingBitmap = bitmap.Clone(rectangle, System.Drawing.Imaging.PixelFormat.DontCare);
                bitmapList.Add(cuttingBitmap);
            }

            if (bitmapList.Count &gt; 0)
                return bitmapList;

            return null;
        }


        /// &lt;summary&gt;
        /// 图片上画矩形和标记文字
        /// &lt;/summary&gt;
        /// &lt;param name="bmp"&gt;图片bitmap&lt;/param&gt;
        /// &lt;param name="imgRectangle"&gt;矩形&lt;/param&gt;
        /// &lt;param name="lineColor"&gt;线条的颜色&lt;/param&gt;
        /// &lt;param name="lineWidth"&gt;线条&lt;/param&gt;
        /// &lt;param name="text"&gt;矩形的文本&lt;/param&gt;
        /// &lt;param name="fontSize"&gt;字体大小&lt;/param&gt;
        /// &lt;param name="ds"&gt;线条的线型&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public Bitmap DrawRectangleInPicture(Bitmap bmp, Rectangle imgRectangle, Color lineColor, int lineWidth, string text, int fontSize, DashStyle ds = DashStyle.Solid)
        {
            if (bmp == null) return null;
            if (imgRectangle == null) return null;
            if (lineColor == null) return null;
            if (lineWidth == 0) return null;
            if (fontSize == 0) return null;
            if (string.IsNullOrEmpty(text)) return null;

            Point pos = imgRectangle.Location;
            Size size = imgRectangle.Size;

            Graphics g = Graphics.FromImage(bmp);

            Brush brush = new SolidBrush(lineColor);
            Pen pen = new Pen(brush, lineWidth);
            pen.DashStyle = ds;

            //画坐标的原点（用于测试）
            g.DrawEllipse(pen, new Rectangle(pos.X, pos.Y, 15, 15));

            //画矩形
            //int rectX = pos.X - (size.Width / 2);
            //int rectY = pos.Y - (size.Height / 2);
            //g.DrawRectangle(pen, rectX, rectY, size.Width, size.Height);
            g.DrawRectangle(pen, pos.X, pos.Y, size.Width, size.Height);

            Font myFont = new Font("宋体", fontSize, FontStyle.Regular);
            Brush bush = new SolidBrush(lineColor);//填充的颜色

            //字体位置的计算
            SizeF sizeF = g.MeasureString(text, myFont);
            //int fontPosX = (int)(pos.X - (sizeF.Width / 2));
            //int fontPosY = (int)(pos.Y + (sizeF.Height / 2) + (size.Height / 2));
            //g.DrawString(text, myFont, bush, fontPosX, fontPosY);
            int fontPosX = (int)(pos.X + (size.Width / 2) - (sizeF.Width / 2));
            int fontPosY = (int)(pos.Y + (size.Height / 2) - (sizeF.Height / 2));
            g.DrawString(text, myFont, bush, fontPosX, fontPosY);

            g.Dispose();

            return bmp;
        }


    }
}
</code></pre>
<p> 源码地址：<a class="link-info" href="https://download.csdn.net/download/qq_38693757/86268551" title="点击下载">点击下载</a></p>
<p></p>
<h1 id="%E7%BB%93%E6%9D%9F">结束</h1>
<p>如果这个帖子对你有用，欢迎 关注 + 点赞 + 留言，谢谢</p>
<p>end</p>
</div>
</div>