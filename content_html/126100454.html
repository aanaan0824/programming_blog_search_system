<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<p id="main-toc"><strong>目录</strong></p>
<p id="1.%20vector%E7%9A%84%E4%BB%8B%E7%BB%8D-toc" style="margin-left:0px;"><a href="#1.%20vector%E7%9A%84%E4%BB%8B%E7%BB%8D">list的介绍</a></p>
<p id="list%E7%9A%84%E6%9E%84%E9%80%A0-toc" style="margin-left:40px;"><a href="#list%E7%9A%84%E6%9E%84%E9%80%A0">list的构造</a></p>
<p id="list%20iterator%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px;"><a href="#list%20iterator%E7%9A%84%E4%BD%BF%E7%94%A8">list iterator的使用</a></p>
<p id="list%20capacity-toc" style="margin-left:40px;"><a href="#list%20capacity">list capacity</a></p>
<p id="list%20element%20access-toc" style="margin-left:40px;"><a href="#list%20element%20access">list element access</a></p>
<p id="list%20modififiers-toc" style="margin-left:40px;"><a href="#list%20modififiers">list modififiers</a></p>
<p id="list%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88-toc" style="margin-left:40px;"><a href="#list%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88">list的迭代器失效</a></p>
<p id="%E5%85%B3%E4%BA%8E%E8%BF%AD%E4%BB%A3%E5%99%A8-toc" style="margin-left:0px;"><a href="#%E5%85%B3%E4%BA%8E%E8%BF%AD%E4%BB%A3%E5%99%A8">关于迭代器</a></p>
<p id="list%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><a href="#list%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0">list的模拟实现</a></p>
<p id="main.cpp-toc" style="margin-left:40px;"><a href="#main.cpp">main.cpp</a></p>
<p id="List.h-toc" style="margin-left:40px;"><a href="#List.h">List.h</a></p>
<hr id="hr-toc"/>
<p></p>
<blockquote>
<p><strong><span style="color:#fe2c24;">C语言总结</span><a href="https://blog.csdn.net/weixin_62700590/article/details/122200337" title="在这">在这</a></strong><strong><span style="color:#fe2c24;">常见八大排序</span><a href="https://blog.csdn.net/weixin_62700590/article/details/124291850" title="在这">在这</a></strong></p>
<p><span style="color:#956fe7;"><strong>作者和朋友建立的社区：</strong></span><a href="https://bbs.csdn.net/forums/FKBZM" title="非科班转码社区-CSDN社区云">非科班转码社区-CSDN社区云</a>💖💛💙</p>
<p><span style="color:#ff9900;"><strong>期待hxd的支持哈🎉 🎉 🎉</strong></span></p>
<p><strong><span style="color:#fe2c24;">最后是打鸡血环节：</span><span style="color:#4da8ee;">你只管努力，剩下的交给天意</span></strong><span style="color:#4da8ee;">🚀 🚀 🚀  </span></p>
</blockquote>
<h1 id="1.%20vector%E7%9A%84%E4%BB%8B%E7%BB%8D">list的介绍</h1>
<blockquote>
<p><a href="https://cplusplus.com/reference/list/list/?kw=list" title="list - C++ Reference (cplusplus.com)">list - C++ Reference (cplusplus.com)</a></p>
<p><img alt="" height="718" src="image\7fbfdb7177fa48c2bc98b8383a1dcd37.png" width="1200"/></p>
<p> <span style="color:#777777;">1. list是可以在常数范围内在<strong>任意位置</strong>进行插入和删除的序列式容器，并且该容器可以<strong>前后双向迭代。 </strong></span></p>
<div>
<span style="color:#777777;">2. list</span>
<span style="color:#777777;">的<strong>底层</strong>是<strong>带头双向循环链表</strong>结构，双向链表中每个元素存储在互不相关的独立节点中，在节点中通过指针指向其前一个元素和后一个元素。 </span>
</div>
<div>
<span style="color:#777777;">3. list</span>
<span style="color:#777777;">与</span>
<span style="color:#777777;">forward_list</span>
<span style="color:#777777;">非常相似：最主要的不同在于</span>
<span style="color:#777777;">forward_list</span>
<span style="color:#777777;">是单链表，只能朝前迭代，已让其更简单高效。 </span>
</div>
<div>
<span style="color:#777777;">4. </span>
<span style="color:#777777;">与其他的序列式容器相比</span>
<span style="color:#777777;">(array</span>
<span style="color:#777777;">，</span>
<span style="color:#777777;">vector</span>
<span style="color:#777777;">，</span>
<span style="color:#777777;">deque)</span>
<span style="color:#777777;">，</span>
<span style="color:#777777;">list</span>
<span style="color:#777777;">通常在任意位置进行插入、移除元素的执行效率更好。 </span>
</div>
<div>
<span style="color:#777777;">5. </span>
<span style="color:#777777;">与其他序列式容器相比，</span>
<span style="color:#777777;">list</span>
<span style="color:#777777;">和</span>
<span style="color:#777777;">forward_list</span>
<span style="color:#777777;"><strong>最大的缺陷是不支持任意位置的随机访问</strong>，比如：要访问</span>
<span style="color:#777777;">list的第6</span>
<span style="color:#777777;">个元素，必须从已知的位置</span>
<span style="color:#777777;">(</span>
<span style="color:#777777;">比如头部或者尾部</span>
<span style="color:#777777;">)</span>
<span style="color:#777777;">迭代到该位置，在这段位置上迭代需要线性的时间 </span>
</div>
<div>
<span style="color:#777777;">另外，</span>
<span style="color:#777777;">list</span>
<span style="color:#777777;">还需要一些额外的空间，以保存每个节点的相关联信息</span>
<span style="color:#777777;">(</span>
<span style="color:#777777;">对于存储类型较小元素的大</span>
<span style="color:#777777;">list</span>
<span style="color:#777777;">来说这可能是一个重要的因素)</span>
</div>
<div></div>
<div>
  早在C语言章节就已经实现过了带头双向循环链表了，但是这次C++不同的是迭代器类的实现，与以往有较大区别，注意理解
 </div>
</blockquote>
<h2 id="list%E7%9A%84%E6%9E%84%E9%80%A0"><span style="color:#777777;"><strong>list</strong></span><span style="color:#777777;"><strong>的构造 </strong></span></h2>
<blockquote>
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>
<div>
<span style="color:#777777;"><strong>构造函数（ </strong></span>
<span style="color:#4183c4;"><strong>(constructor)</strong></span>
<span style="color:#777777;"><strong>）</strong></span>
</div> </td><td>
<div>
<span style="color:#777777;"><strong>接口说明 </strong></span>
</div> </td></tr><tr><td>
<div>
<span style="color:#777777;"><strong>list (size_type n, const value_type&amp; val = value_type()) </strong></span>
</div> </td><td>
<div>
<span style="color:#777777;"><strong>构造的</strong></span>
<span style="color:#777777;"><strong>list</strong></span>
<span style="color:#777777;"><strong>中包含</strong></span>
<span style="color:#777777;"><strong>n</strong></span>
<span style="color:#777777;"><strong>个值为</strong></span>
<span style="color:#777777;"><strong>val</strong></span>
<span style="color:#777777;"><strong>的元素 </strong></span>
</div> </td></tr><tr><td>
<div>
<span style="color:#777777;"><strong>list() </strong></span>
</div> </td><td>
<div>
<span style="color:#777777;"><strong>构造空的</strong></span>
<span style="color:#777777;"><strong>list </strong></span>
</div> </td></tr><tr><td>
<div>
<span style="color:#777777;"><strong>list (const list&amp; x)</strong></span>
</div> </td><td>
<div>
<span style="color:#777777;"><strong>拷贝构造函数</strong></span>
</div> </td></tr><tr><td>
<div>
<span style="color:#777777;"><strong>list (InputIterator fifirst, InputIterator last)</strong></span>
</div> </td><td>
<div>
<span style="color:#777777;"><strong>用</strong></span>
<span style="color:#777777;"><strong>[fifirst, last)</strong></span>
<span style="color:#777777;"><strong>区间中的元素构造</strong></span>
<span style="color:#777777;"><strong>list </strong></span>
</div> </td></tr></tbody></table>
<p> 其实学到这里了这什么函数是用来干什么的应该是一看就会了，但是考虑到文章的完整性和一些小白，就还是“冗余”得把这些函数及解释写了出来</p>
</blockquote>
<h2 id="list%20iterator%E7%9A%84%E4%BD%BF%E7%94%A8"><span style="color:#777777;"><strong>list iterator</strong></span><span style="color:#777777;"><strong>的使用 </strong></span></h2>
<blockquote>
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>
<div>
<span style="color:#777777;"><strong>函数声明</strong></span>
</div> </td><td>
<div>
<span style="color:#777777;"><strong>接口说明</strong></span>
</div> </td></tr><tr><td>
<div>
<span style="color:#4183c4;"><strong>begin</strong></span>
<span style="color:#777777;"> + </span>
</div>
<div>
<span style="color:#4183c4;"><strong>end </strong></span>
</div> </td><td>
<div>
<span style="color:#777777;"><strong>返回第一个元素的迭代器</strong></span>
<span style="color:#777777;">+</span>
<span style="color:#777777;"><strong>返回最后一个元素下一个位置的迭代器</strong></span>
</div>
<div>
<span style="color:#777777;"><strong>                                end（）就是头的位置</strong></span>
</div> </td></tr><tr><td>
<div>
<span style="color:#4183c4;"><strong>rbegin</strong></span>
<span style="color:#777777;"> + </span>
</div>
<div>
<span style="color:#4183c4;"><strong>rend </strong></span>
</div> </td><td>
<div>
<span style="color:#777777;"><strong>返回第一个元素的</strong></span>
<span style="color:#777777;"><strong>reverse_iterator,</strong></span>
<span style="color:#777777;"><strong>即</strong></span>
<span style="color:#777777;"><strong>end</strong></span>
<span style="color:#777777;"><strong>位置</strong></span>
<span style="color:#777777;">，</span>
<span style="color:#777777;"><strong>返回最后一个元素下一个位置的 </strong></span>
<span style="color:#777777;"><strong>reverse_iterator,</strong></span>
<span style="color:#777777;"><strong>即</strong></span>
<span style="color:#777777;"><strong>begin</strong></span>
<span style="color:#777777;"><strong>位置 </strong></span>
</div> </td></tr></tbody></table>
<p>PS:</p>
<div>
<span style="color:#777777;">1. </span>
<span style="color:#777777;"><strong>begin</strong></span>
<span style="color:#777777;"><strong>与</strong></span>
<span style="color:#777777;"><strong>end</strong></span>
<span style="color:#777777;"><strong>为正向迭代器，对迭代器执行</strong></span>
<span style="color:#777777;"><strong>++</strong></span>
<span style="color:#777777;"><strong>操作，迭代器向后移动 </strong></span>
</div>
<div>
<span style="color:#777777;">2. </span>
<span style="color:#777777;"><strong>rbegin(end)</strong></span>
<span style="color:#777777;"><strong>与</strong></span>
<span style="color:#777777;"><strong>rend(begin)</strong></span>
<span style="color:#777777;"><strong>为反向迭代器，对迭代器执行</strong></span>
<span style="color:#777777;"><strong>++</strong></span>
<span style="color:#777777;"><strong>操作，迭代器向前移动</strong></span>
</div>
</blockquote>
<h2 id="list%20capacity"><span style="color:#777777;"><strong>list capacity </strong></span></h2>
<div></div>
<blockquote>
<div>
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>
<div>
<span style="color:#777777;"><strong>函数声明 </strong></span>
</div> </td><td>
<div>
<span style="color:#777777;"><strong>接口说明</strong></span>
</div> </td></tr><tr><td>
<div>
<span style="color:#4183c4;"><strong>empty </strong></span>
</div> </td><td>
<div>
<span style="color:#777777;"><strong>检测</strong></span>
<span style="color:#777777;"><strong>list</strong></span>
<span style="color:#777777;"><strong>是否为空，是返回</strong></span>
<span style="color:#777777;"><strong>true</strong></span>
<span style="color:#777777;"><strong>，否则返回</strong></span>
<span style="color:#777777;"><strong>false </strong></span>
</div> </td></tr><tr><td>
<div>
<span style="color:#4183c4;"><strong>size </strong></span>
</div> </td><td>
<div>
<span style="color:#777777;"><strong>返回</strong></span>
<span style="color:#777777;"><strong>list</strong></span>
<span style="color:#777777;"><strong>中有效节点的个数</strong></span>
</div> </td></tr></tbody></table>
</div>
</blockquote>
<h2 id="list%20element%20access"><span style="color:#777777;"><strong>list element access</strong></span></h2>
<div></div>
<blockquote>
<div>
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>
<div>
<span style="color:#777777;"><strong>函数声明</strong></span>
</div> </td><td>
<div>
<span style="color:#777777;"><strong>接口说明</strong></span>
</div> </td></tr><tr><td>
<div>
<span style="color:#4183c4;"><strong>front </strong></span>
</div> </td><td>
<div>
<span style="color:#777777;"><strong>返回</strong></span>
<span style="color:#777777;"><strong>list</strong></span>
<span style="color:#777777;"><strong>的第一个节点中值的引用</strong></span>
</div> </td></tr><tr><td>
<div>
<span style="color:#4183c4;"><strong>back </strong></span>
</div> </td><td>
<div>
<span style="color:#777777;"><strong>返回</strong></span>
<span style="color:#777777;"><strong>list</strong></span>
<span style="color:#777777;"><strong>的最后一个节点中值的引用</strong></span>
</div> </td></tr></tbody></table>
</div>
</blockquote>
<h2 id="list%20modififiers"><span style="color:#777777;"><strong>list modififiers</strong></span></h2>
<div></div>
<blockquote>
<div>
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>
<div>
<span style="color:#777777;"><strong>函数声明</strong></span>
</div> </td><td>
<div>
<span style="color:#777777;"><strong>接口说明 </strong></span>
</div> </td></tr><tr><td>
<div>
<span style="color:#4183c4;"><strong>push_front </strong></span>
</div> </td><td>
<div>
<span style="color:#777777;"><strong>在</strong></span>
<span style="color:#777777;"><strong>list</strong></span>
<span style="color:#777777;"><strong>首元素前插入值为</strong></span>
<span style="color:#777777;"><strong>val</strong></span>
<span style="color:#777777;"><strong>的元素 </strong></span>
</div> </td></tr><tr><td>
<div>
<span style="color:#4183c4;"><strong>pop_front </strong></span>
</div> </td><td>
<div>
<span style="color:#777777;"><strong>删除</strong></span>
<span style="color:#777777;"><strong>list</strong></span>
<span style="color:#777777;"><strong>中第一个元素 </strong></span>
</div> </td></tr><tr><td>
<div>
<span style="color:#4183c4;"><strong>push_back </strong></span>
</div> </td><td>
<div>
<span style="color:#777777;"><strong>在</strong></span>
<span style="color:#777777;"><strong>list</strong></span>
<span style="color:#777777;"><strong>尾部插入值为</strong></span>
<span style="color:#777777;"><strong>val</strong></span>
<span style="color:#777777;"><strong>的元素 </strong></span>
</div> </td></tr><tr><td>
<div>
<span style="color:#4183c4;"><strong>pop_back</strong></span>
</div> </td><td>
<div>
<span style="color:#777777;"><strong>删除</strong></span>
<span style="color:#777777;"><strong>list</strong></span>
<span style="color:#777777;"><strong>中最后一个元素 </strong></span>
</div> </td></tr><tr><td>
<div>
<span style="color:#4183c4;"><strong>insert </strong></span>
</div> </td><td>
<div>
<span style="color:#777777;"><strong>在</strong></span>
<span style="color:#777777;"><strong>list position </strong></span>
<span style="color:#777777;"><strong>位置中插入值为</strong></span>
<span style="color:#777777;"><strong>val</strong></span>
<span style="color:#777777;"><strong>的元素</strong></span>
</div> </td></tr><tr><td>
<div>
<span style="color:#4183c4;"><strong>erase </strong></span>
</div> </td><td>
<div>
<span style="color:#777777;"><strong>删除</strong></span>
<span style="color:#777777;"><strong>list position</strong></span>
<span style="color:#777777;"><strong>位置的元素</strong></span>
</div> </td></tr><tr><td>
<div>
<span style="color:#4183c4;"><strong>swap </strong></span>
</div> </td><td>
<div>
<span style="color:#777777;"><strong>交换两个</strong></span>
<span style="color:#777777;"><strong>list</strong></span>
<span style="color:#777777;"><strong>中的元素</strong></span>
</div> </td></tr><tr><td>
<div>
<span style="color:#4183c4;"><strong>clear </strong></span>
</div> </td><td>
<div>
<span style="color:#777777;"><strong>清空</strong></span>
<span style="color:#777777;"><strong>list</strong></span>
<span style="color:#777777;"><strong>中的有效元素</strong></span>
</div> </td></tr></tbody></table>
</div>
</blockquote>
<h2 id="list%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88"><span style="color:#777777;"><strong>list</strong></span><span style="color:#777777;"><strong>的迭代器失效</strong></span></h2>
<div></div>
<blockquote>
<div>
<div>
<span style="color:#777777;"><strong>迭代器失效即迭代器所指向的节点的无效，即该节</strong></span>
<span style="color:#777777;"><strong>点被删除了</strong></span>
<span style="color:#777777;">。因为</span>
<span style="color:#777777;"><strong>list</strong></span>
<span style="color:#777777;"><strong>的底层结构为带头结点的双向循环链表</strong></span>
<span style="color:#777777;">，因此</span>
<span style="color:#777777;"><strong>在</strong></span>
<span style="color:#777777;"><strong>list</strong></span>
<span style="color:#777777;"><strong>中进行插入时是不会导致</strong></span>
<span style="color:#777777;"><strong>list</strong></span>
<span style="color:#777777;"><strong>的迭代</strong></span>
<span style="color:#777777;"><strong>器失效的，只有在删除时才会失效，并且失效的只是指向被删除节点的迭代器，其他迭代器不会受到影响</strong></span>
<span style="color:#777777;">。</span>
</div>
</div>
</blockquote>
<h1 id="%E5%85%B3%E4%BA%8E%E8%BF%AD%E4%BB%A3%E5%99%A8">关于迭代器</h1>
<blockquote>
<div>
<span style="color:#777777;"><strong>迭代器是对原生态指针</strong></span>
<span style="color:#777777;"><strong>(</strong></span>
<span style="color:#777777;"><strong>节点指针</strong></span>
<span style="color:#777777;"><strong>)</strong></span>
<span style="color:#777777;"><strong>进行封装</strong></span>
</div>
<div>
<span style="color:#777777;"><strong>迭</strong></span>
<span style="color:#777777;"><strong>代</strong></span>
<span style="color:#777777;"><strong>器</strong></span>
<span style="color:#777777;"><strong>失</strong></span>
<span style="color:#777777;"><strong>效</strong></span>
</div>
<div>
<div>
<span style="color:#777777;"><strong>插入元素不会导致迭代器失效， </strong></span>
<span style="color:#777777;"><strong>删除元素时，只会导致当前迭代</strong></span>
<span style="color:#777777;"><strong>器失效，其他迭代器不受影响</strong></span>
</div>
</div>
</blockquote>
<h1 id="list%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0"><span style="color:#333333;"><strong>list</strong></span><span style="color:#333333;"><strong>的模拟实现 </strong></span></h1>
<div></div>
<h2 id="main.cpp">main.cpp</h2>
<div>
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS 1

#include"List.h"

int main()
{
	my_list&lt;int&gt; l;
	l.insert(l.begin(), 1);
	l.insert(l.end(), 2);
	l.insert(l.end(), 2);
	l.insert(l.end(), 2);
	l.insert(l.end(), 7);
	l.insert(l.end(), 5);
	l.push_back(100);
	l.push_back(150);
	l.push_back(11);
	l.push_front(33);
	l.push_front(66);
	my_list&lt;int&gt;::iterator it = l.begin();
	while (it != l.end())
	{
		cout &lt;&lt; *it &lt;&lt; " ";
		it++;
	}
	cout &lt;&lt; endl;
	cout &lt;&lt; endl;

	l.pop_back();
	l.pop_back();
	l.pop_front();
	l.pop_front();
	it = l.begin();

	it = l.begin();
	while (it != l.end())
	{
		cout &lt;&lt; *it &lt;&lt; " ";
		it++;
	}
	cout &lt;&lt; endl;
	cout &lt;&lt; endl;

	it = l.begin();
	while (it != l.end())
	{
		if (*it % 2 == 0)
		{
			it = l.erase(it);
		}
		else
		{
			it++;
		}
	}

	it = l.begin();
	while (it != l.end())
	{
		cout &lt;&lt; *it &lt;&lt; " ";
		it++;
	}
	cout &lt;&lt; endl;
	cout &lt;&lt; endl;

	my_list&lt;int&gt; l2(l);
	it = l2.begin();
	while (it != l2.end())
	{
		cout &lt;&lt; *it &lt;&lt; " ";
		it++;
	}
	cout &lt;&lt; endl;
	cout &lt;&lt; endl;

	it = l.begin();
	my_list&lt;int&gt;::iterator it2 = --it;

	cout &lt;&lt; *it &lt;&lt; endl;
	cout &lt;&lt; *it2 &lt;&lt; endl;
	//cout &lt;&lt; l.front() &lt;&lt; endl;
	//cout &lt;&lt; l.back() &lt;&lt; endl;

	//cout &lt;&lt;  *(l.begin()--) &lt;&lt; endl;
	//cout &lt;&lt; *(--l.begin()) &lt;&lt; endl;
	//cout &lt;&lt; *(l.begin()++) &lt;&lt; endl;
	//cout &lt;&lt; *(++l.begin()) &lt;&lt; endl;
}

</code></pre>
</div>
<h2 id="List.h">List.h</h2>
<div>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;assert.h&gt;

using std::cout;
using std::endl;

// List的节点类
template&lt;class T&gt;
struct ListNode
{
    ListNode(const T&amp; val = T())
        :_pPre(nullptr),
        _pNext(nullptr),
        _val(val)
    {}
    ListNode&lt;T&gt;* _pPre;
    ListNode&lt;T&gt;* _pNext;
    T _val;
};

//List的迭代器类
template&lt;class T, class Ref, class Ptr&gt;
struct  ListIterator
{
    typedef ListNode&lt;T&gt;* PNode;
    typedef ListIterator&lt;T, Ref, Ptr&gt; Self;

    //给reverse_iterator 用 ，这样反向迭代器类就可以不用传后面两个参数了
    typedef  T&amp; Ref;
    typedef  T* Ptr;

    ListIterator(PNode pNode = nullptr)
        :_pNode(pNode)
    {}
    //it1(it2)
    ListIterator(const Self&amp; l)
    {
        _pNode = l._pNode;
    }
    //模板参数  Ref    Ptr 的作用   ，返回 const和非const对象(由传参决定)
    //(其实就是两个类了，同一个类模板，参数不同，会实例化出不同类型的对象)
    Ref operator*()
    {
        return _pNode-&gt;_val;
    }
    Ptr operator-&gt;()             //注意返回值                            
    {
        //return &amp;(operator*());
        return &amp;_pNode-&gt;_val;
    }
    Self&amp; operator++()
    {
        _pNode = _pNode-&gt;_pNext;
        return*this;
    }
    Self operator++(int)
    {
        Self tmp(*this);
        _pNode = _pNode-&gt;_pNext;
        return tmp;
    }
    Self&amp; operator--()
    {
        _pNode = _pNode-&gt;_pPre;
        return *this;
    }
    Self&amp; operator--(int)
    {
        Self tmp = *this;
        _pNode = _pNode-&gt;_pPre;
        return tmp;
    }
    bool operator!=(const Self&amp; l)
    {
        return !(operator==(l));
    }
    bool operator==(const Self&amp; l)
    {
        return _pNode == l._pNode;
    }
    PNode _pNode;
};

//List的反向迭代器类
template&lt;class ListIterator&gt;
struct  ReverseIterator
{
    typedef typename ListIterator::Ref Ref;
    typedef typename ListIterator::Ptr Ptr;
    typedef ReverseIterator&lt;ListIterator&gt; Self;

    ReverseIterator(ListIterator it)
        :_it(it)
    {}
    //it1(it2)
    ReverseIterator(const Self&amp; l)
    {
        _it = l._it;
    }

    Ref operator*()
    {
        ListIterator temp(_it);
        --temp;
        return *temp;
    }
    Ptr operator-&gt;()             //注意返回值                            
    {
        return &amp;(operator*());
    }
    Self&amp; operator++()
    {
        --_it;
        return *this;
    }
    Self operator++(int)
    {
        Self temp(*this);
        --_it;
        return temp;
    }
    Self&amp; operator--()
    {
        ++_it;
        return *this;
    }
    Self&amp; operator--(int)
    {
        Self temp(*this);
        ++_it;
        return temp;
    }
    bool operator!=(const Self&amp; l)
    {
        return _it != l._it;
    }
    bool operator==(const Self&amp; l)
    {
        return _it == l._it;
    }
    ListIterator _it;
};

//list类
template&lt;class T&gt;
class my_list
{
    typedef ListNode&lt;T&gt; Node;
    typedef Node* PNode;
public:
    typedef ListIterator&lt;T, T&amp;, T*&gt; iterator;
    //只有后面两个加上const是因为只有这里是控制const迭代器不能修改的地方
    typedef ListIterator&lt;T, const T&amp;, const T&amp;&gt; const_iterator;

    typedef ReverseIterator&lt;iterator&gt; reverse_itrator;
    typedef ReverseIterator&lt;const_iterator&gt; const_reverse_itrator;
public:
    ///
    // List的构造
    my_list()
    {
        CreateHead();
    }
    my_list(int n, const T&amp; value = T())
    {
        CreateHead();
        for (int i = 0; i &lt; n; i++)
        {
            push_back(value);
        }
    }
    template &lt;class Iterator&gt;
    my_list(Iterator first, Iterator last)
    {
        CreateHead();
        while (first != last)
        {
            push_back(*first);
            first++;
        }
    }
    //lt1(lt2)                 lt2
    my_list(const my_list&lt;T&gt;&amp; l)
    {
        CreateHead();
        my_list&lt;T&gt; tmp(l.begin(), l.end());
        this-&gt;swap(tmp);
    }
    my_list&lt;T&gt;&amp; operator=(my_list&lt;T&gt; l)
    {
        this-&gt;swap(l);
        return *this;
    }
    ~my_list()
    {
        clear();
        delete _pHead;
        _pHead = nullptr;
    }
    ///
    // List Iterator
    iterator begin()
    {
        return iterator(_pHead-&gt;_pNext);
    }
    iterator end()
    {
        return iterator(_pHead);
    }
    const_iterator begin()const
    {
        return const_iterator(_pHead-&gt;_pNext);
    }
    const_iterator end()const
    {
        return const_iterator(_pHead);
    }

    // List Reversez_Iterator
    reverse_itrator rbegin()
    {
        return reverse_itrator(iterator);
    }
    reverse_itrator rend()
    {
        return reverse_itrator(iterator);
    }
    const_reverse_itrator crbegin()const
    {
        return const_reverse_itrator(const_iterator);
    }
    const_reverse_itrator crend()const
    {
        return const_reverse_itrator(const_iterator);
    }

    ///
    // List Capacity
    size_t size()const
    {
        size_t sz = 0;
        iterator it = begin();
        while (it != end())
        {
            sz++;
            it++;
        }
        return sz;
    }
    bool empty()const
    {
        return size() == 0;
    }
    
    // List Access
    T&amp; front()
    {
        return _pHead-&gt;_pNext-&gt;_val;
    }
    const T&amp; front()const
    {
        return _pHead-&gt;_pNext-&gt;_val;
    }
    T&amp; back()
    {
        return _pHead-&gt;_pPre-&gt;_val;
    }
    const T&amp; back()const
    {
        return _pHead-&gt;_pPre-&gt;_val;
    }
    
    // List Modify
    void push_back(const T&amp; val) { insert(end(), val); }
    void pop_back() { erase(--end()); }
    void push_front(const T&amp; val) { insert(begin(), val); }
    void pop_front() { erase(begin()); }
    // 在pos位置前插入值为val的节点
    iterator insert(iterator pos, const T&amp; val)
    {
        //    prev  new  cur 
        Node* newnode = new Node(val);
        Node* cur = pos._pNode;
        Node* prev = cur-&gt;_pPre;

        prev-&gt;_pNext = newnode;
        newnode-&gt;_pPre = prev;
        newnode-&gt;_pNext = cur;
        cur-&gt;_pPre = newnode;

        //返回新插入的位置
        return iterator(newnode);
    }
    // 删除pos位置的节点，返回该节点的下一个位置
    iterator erase(iterator pos)
    {
        assert(pos != end());

        Node* cur = pos._pNode;
        Node* prev = cur-&gt;_pPre;
        Node* next = cur-&gt;_pNext;

        prev-&gt;_pNext = next;
        next-&gt;_pPre = prev;
        delete cur;
        //匿名对象
        return iterator(next);
    }
    void clear()
    {
        iterator it = begin();
        while (it != end())
        {
            it = erase(it);
            it++;
        }
    }
    void swap(my_list&lt;T&gt;&amp; l)
    {
        std::swap(_pHead, l._pHead);
    }
private:
    void CreateHead()
    {
        _pHead = new Node();
        _pHead-&gt;_pPre = _pHead;
        _pHead-&gt;_pNext = _pHead;
    }
    PNode _pHead;
};</code></pre>
<blockquote>
<p><span style="color:#956fe7;">最后的最后，创作不易，希望读者三连支持💖</span></p>
<p><span style="color:#956fe7;">赠人玫瑰，手有余香💖</span></p>
</blockquote>
</div>
</div>
</div>