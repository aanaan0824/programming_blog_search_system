<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<h1>一、<strong>Map集合的特点</strong>：</h1>
<p><strong>Map集合的特点</strong>：<br/> 1.Map是一个双列集合，一个元素包含两个值（一个key，一个value）</p>
<p>2.Map集合中的元素，key和value的数据类型可以相同，也可以不同</p>
<p>3.Map中的元素，key不允许重复，value可以重复</p>
<p>4.Map里的key和value是一一对应的。</p>
<h1><span style="color:#494949;"><strong>二、Map中的方法:</strong></span></h1>
<p><span style="color:#0d0016;">1.</span>public  <span style="color:#0d0016;"> V  put （K key，V value） 把指定的键和值添加到Map集合中，返回值是V</span></p>
<p><span style="color:#0d0016;">如果要存储的键值对，key不重复返回值V是null</span></p>
<p><span style="color:#0d0016;">如果要存储的键值对，key重复返回值V是被替换的value值</span> </p>
<p><img alt="" height="318" src="image\4cc850d8e3954dfaad3345e236ae03e4.png" width="684"/></p>
<p>2. public  V remove（Object key）把指定键所对应的键值对元素，在Map集合中删除，返回被删除的元素的值。 返回值：V 。如果key存在，返回被删除的值，如果key不存在，返回null</p>
<p> <img alt="" height="308" src="image\ba19756a7f774ba997229424feddd7a6.png" width="737"/></p>
<p>3.public V remove （Object key）：根据指定的键 在Map集合中获取对应的值</p>
<p>如果key存在，返回对应的value值，如果key不存在，返回null</p>
<p> <img alt="" height="228" src="image\8708aa3139e449d7b0c003c6edb57435.png" width="393"/></p>
<p>  4.boolean containsKey（ Object key）判判断集合中是否包含指定的键</p>
<p>包含返回true，不包含返回false<img alt="" height="293" src="image\bd9e5c672c70478d91f221c10a2d2acf.png" width="523"/></p>
<h1>三、遍历Map集合的方式</h1>
<p>1.通过键找值的方法；</p>
<p>使用了setKey方法，将Map集合中的key值，存储到Set集合，用迭代器或foreach循环遍历Set集合来获取Map集合的每一个key，并使用get（key）方法来获取value值</p>
<p><img alt="" height="204" src="image\a59584c076f647c0acfb0b9a40fb952a.png" width="1138"/></p>
<p><img alt="" height="143" src="image\50af935ed5d64b3c99d72939e58fcc47.png" width="597"/></p>
<p><img alt="" height="340" src="image\aa443e0dacab46ceaefa7b8802786293.png" width="612"/></p>
<p><img alt="" height="102" src="image\2ea21161ecb84835b84b7c087532f979.png" width="407"/> </p>
<p> 2.使用Entry对象遍历</p>
<p>Map.Entry&lt;K,V&gt;,在Map接口中有一个内部接口Entry（内部类）</p>
<p>作用：当集合一创建，就会在Map集合中创建一个Entry对象，用来记录键与值（键值对对象，键值的映射关系）<img alt="" height="415" src="image\3833baaeba9940a5971e70233620537e.png" width="1200"/></p>
<p> 有了Entry对象就可以使用Map中的entrySet方法，把Map集合中的多个Entry对象存入一个Set集合来遍历Set集合，<strong>获取Set集合中每一个Entry对象</strong>，然后可以使用Entry中的两个方法getKey和getValue来分别获取键和值。</p>
<p>代码步骤：</p>
<p><img alt="" height="166" src="image\b6f1e1a81178421c9eb32125e267da32.png" width="651"/></p>
<p> <img alt="" height="372" src="image\354a555c91034a4298e18bc37bb09e9c.png" width="675"/></p>
<p> <img alt="" height="104" src="image\8ec332731a0d47bd8943803ffb6a2211.png" width="451"/></p>
<p> </p>
<h1><span style="color:#0d0016;">四、Map的常用实现类</span></h1>
<h1>（一）、HashMap</h1>
<p><strong>【1】.特点</strong>：1.HashMap底是哈希表，查询速度非常快（jdk1.8之前是数组+单向链表，1.8之后是数组+单向链表/红黑树 ，链表长度超过8时，换成红黑树）</p>
<p>     2. HashMap是无序的集合，存储元素和取出元素的顺序有可能不一致</p>
<p>     3.集合是不同步的，也就是说是多线程的，速度快</p>
<p><strong>【2】</strong>.HashMap存储自定义类型键值</p>
<p>HashMap存储自定义类型键值，Map集合保证key是唯一的：作为key的元素，必须重写hashCode方法和equals方法，以保证key唯一</p>
<p><img alt="" height="379" src="image\ba934914cf0e4b7b8cafc4f29b115191.png" width="496"/></p>
<p><img alt="" height="307" src="image\f1c0f4cf21f048fca5e7d041efe58204.png" width="550"/></p>
<h2> （二）LinkedHashMap</h2>
<p><strong>HashMap有子类LinkedHashMap：</strong>LinkedHashMap &lt;K,V&gt; extends HashMap &lt;K,V&gt;</p>
<p>是Map接口的哈希表和链表的实现，具有可预知的迭代顺序（有序）</p>
<p>底层原理：哈希表+链表（记录元素顺序）</p>
<p><strong>特点</strong>：1.LinkedHashMap底层是哈希表+链表（保证迭代的顺序）</p>
<p>2.LinkedHashMap是一个有序的集合，存储元素和取出元素的顺序一致</p>
<p>改进之处就是：元素存储有序了</p>
<h1>(三）Hashtable</h1>
<p>Hashtable&lt;K,V&gt; implements Map&lt;K,V&gt;</p>
<p>Hashtable：底层也是哈希表，是同步的，是一个单线程结合，是线程安全的集合，速度慢</p>
<p>HashMap：底层也是哈希表，但是线程不安全的集合，是多线程集合，速度快</p>
<p>HashMap（还有之前学的所有集合）：都可以存储null键，null值</p>
<p>Hashtable：不能存储null键，null值</p>
<p><img alt="" height="243" src="image\3a26ac14fec14805b7e293f1fe7f577b.png" width="522"/></p>
<p></p>
<p></p>
<p></p>
<p></p>
</div>
</div>