<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<p style="text-align:center;"><img alt="" class="left" src="https://img-blog.csdnimg.cn/50422e39407547ec999af330d381414b.gif"/></p>
<p>任何一个可以用计算机求解的问题所需的计算时间都与其规模有关：问题的规模越小，越容易直接求解。 要想直接解决一个规模较大的问题，有时是很困难的。那么，为了更好地解决这些规模较大的问题，分治法应运而生了。 在计算机科学中，分治法是一种很重要的算法。它采取各个击破的技巧来解决一个规模较大的问题，该技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)等。话不多说，直接上案例。</p>
<hr/>
<p id="main-toc"><strong>目录</strong></p>
<p id="%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE">二分查找</a></p>
<p id="%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0-toc" style="margin-left:40px;"><a href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0">问题描述</a></p>
<p id="%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-toc" style="margin-left:40px;"><a href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3">算法思想</a></p>
<p id="%E6%9E%84%E9%80%A0%E5%AE%9E%E4%BE%8B-toc" style="margin-left:40px;"><a href="#%E6%9E%84%E9%80%A0%E5%AE%9E%E4%BE%8B">构造实例</a></p>
<p id="%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95">实现方法</a></p>
<p id="1%E3%80%81%E4%B8%A4%E7%A7%8D%E9%9D%9E%E9%80%92%E5%BD%92-toc" style="margin-left:80px;"><a href="#1%E3%80%81%E4%B8%A4%E7%A7%8D%E9%9D%9E%E9%80%92%E5%BD%92">1、两种非递归</a></p>
<p id="2%E3%80%81%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95-toc" style="margin-left:80px;"><a href="#2%E3%80%81%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95">2、递归算法</a></p>
<p id="%C2%A0%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-toc" style="margin-left:40px;"><a href="#%C2%A0%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">时间复杂度</a></p>
<p id="%E4%BA%8C%E3%80%81-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81">二、合并排序</a></p>
<p id="%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-toc" style="margin-left:40px;"><a href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3">算法思想</a></p>
<p id="%E5%90%88%E5%B9%B6%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#%E5%90%88%E5%B9%B6%E6%96%B9%E6%B3%95">合并方法</a></p>
<p id="%C2%A0%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0-toc" style="margin-left:40px;"><a href="#%C2%A0%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0">算法描述</a></p>
<p id="%E9%9D%9E%E9%80%92%E5%BD%92%E5%BD%A2%E5%BC%8F-toc" style="margin-left:80px;"><a href="#%E9%9D%9E%E9%80%92%E5%BD%92%E5%BD%A2%E5%BC%8F">非递归形式</a></p>
<p id="%C2%A0%E9%80%92%E5%BD%92%E5%BD%A2%E5%BC%8F-toc" style="margin-left:80px;"><a href="#%C2%A0%E9%80%92%E5%BD%92%E5%BD%A2%E5%BC%8F">递归形式</a></p>
<p id="%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-toc" style="margin-left:40px;"><a href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">时间复杂度</a></p>
<p id="%E4%B8%89%E3%80%81-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81">三、快速排序</a></p>
<p id="%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-toc" style="margin-left:40px;"><a href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3">算法思想</a></p>
<p id="%E5%BF%AB%E6%8E%92%E5%88%86%E6%B2%BB%E4%BD%93%E7%8E%B0-toc" style="margin-left:40px;"><a href="#%E5%BF%AB%E6%8E%92%E5%88%86%E6%B2%BB%E4%BD%93%E7%8E%B0">快排分治体现</a></p>
<p id="%C2%A0%E5%88%92%E5%88%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%9E%84%E9%80%A0%E5%AE%9E%E4%BE%8B-toc" style="margin-left:40px;"><a href="#%C2%A0%E5%88%92%E5%88%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%9E%84%E9%80%A0%E5%AE%9E%E4%BE%8B">划分方法的构造实例</a></p>
<p id="%E5%9B%BE%E7%A4%BA%E5%8A%A9%E7%90%86%E8%A7%A3-toc" style="margin-left:80px;"><a href="#%E5%9B%BE%E7%A4%BA%E5%8A%A9%E7%90%86%E8%A7%A3">图示助理解</a></p>
<p id="%C2%A0%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px;"><a href="#%C2%A0%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">具体代码实现</a></p>
<p id="%C2%A0%E8%BF%90%E8%A1%8C%E6%95%88%E6%9E%9C-toc" style="margin-left:80px;"><a href="#%C2%A0%E8%BF%90%E8%A1%8C%E6%95%88%E6%9E%9C">运行效果</a></p>
<p id="%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-toc" style="margin-left:40px;"><a href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">时间复杂度</a></p>
<p id="%C2%A0%E7%BB%93%E8%AF%AD-toc" style="margin-left:0px;"><a href="#%C2%A0%E7%BB%93%E8%AF%AD"> 结语</a></p>
<hr id="hr-toc"/>
<p></p>
<h1 id="%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE">二分查找</h1>
<h2 id="%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0">问题描述</h2>
<p>二分查找又称为折半查找，它要求待查找的数据元素必须是按关键字大小有序排列的。给定已排好序的n个元素s1,…,sn，现要在这n个元素中找出一特定元素x。 首先较容易想到使用顺序查找方法，逐个比较s1,…,sn，直至找出元素x或搜索遍整个序列后确定x不在其中。显然，该方法没有很好地利用n个元素已排好序这个条件。因此，在最坏情况下，顺序查找方法需要O(n)次比较。</p>
<h2 id="%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3">算法思想</h2>
<p>假定元素序列已经由小到大排好序，将有序序列分成规模大致相等的两部分，然后取中间元素与特定查找元素x进行比较，如果x等于中间元素，则算法终止；如果x小于中间元素，则在序列的左半部继续查找，即在序列的左半部重复分解和治理操作；否则，在序列的右半部继续查找，即在序列的右半部重复分解和治理操作。可见，二分查找算法重复利用了元素间的次序关系。</p>
<h2 id="%E6%9E%84%E9%80%A0%E5%AE%9E%E4%BE%8B">构造实例</h2>
<p style="text-align:center;"><img alt="" src="image\fc2656fe83ca43569ec48a58f8cd1b93.png"/></p>
<p>创建数组并随机赋值，定义low为数组左边界high为数组右边界（数组长度-1）middle为数组长度的一半。middle=(low+high)/2，即指示中间元素；我们需要通过代码来每次折半查找我们需要的元素值。</p>
<h2 id="%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95">实现方法</h2>
<h3 id="1%E3%80%81%E4%B8%A4%E7%A7%8D%E9%9D%9E%E9%80%92%E5%BD%92">1、两种非递归</h3>
<p>twoFind1()</p>
<pre><code class="language-cpp">int twoFind1(int A[], int len, int K)
{
	int low = 0, high = len - 1,middle;
	if (low &gt; high) return -2;
	while (low &lt;= high)//包含等于的情况
	{
		middle = (low + high) / 2;
		if (K == A[middle]) return middle;
		else if (K &gt; A[middle]) low = middle + 1;
		else high = middle - 1;
	}
	return -1;
}</code></pre>
<p>twoFind2()</p>
<pre><code class="language-cpp">int twoFind2(int A[], int len, int K)
{
	int low = 0, high = len - 1,middle;
	if (low &gt; high) return -2;
	while (low &lt; high)//不含等于的情况，并在最后做判断
	{
		middle = (low + high) / 2;
		if (K == A[middle]) return middle;
		else if (K &gt; A[middle]) low = middle + 1;
		else high = middle - 1;
	}
	if (low == high &amp;&amp; A[low] == K) return low;
	return -1;
}</code></pre>
<h3 id="2%E3%80%81%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95">2、递归算法</h3>
<pre><code class="language-cpp">//递归二分查找算法
int twoFind3(int A[], int k, int low, int high)
{
	int middle;
	if (low &gt; high) return -1;//递归结束条件
	middle = (low + high) / 2;
	if (low==high &amp;&amp; A[middle] == k) return middle;
	if (low &lt; high) {
		if (A[middle] &lt; k)      return  twoFind3(A, k, middle + 1, high);
		else  if(A[middle]==k)  return middle;
		else                    return  twoFind3(A, k, 0, middle - 1);
	}
	return -1;
}</code></pre>
<h2 id="%C2%A0%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"> 时间复杂度</h2>
<p style="text-align:center;"><img alt="" src="image\a4629be5c0714a1da5ff4ad60b1742cd.png"/></p>
<p></p>
<h1 id="%E4%BA%8C%E3%80%81">二、合并排序</h1>
<h2>算法思想</h2>
<blockquote>
<p>合并排序是采用分治策略实现对n个元素进行排序的算法，是分治法的一个典型应用和完美体现。它是一种平衡、简单的二分分治策略，其计算过程分为三大步： （1）分解：将待排序元素分成大小大致相同的两个子序列。 （2）求解子问题：用合并排序法分别对两个子序列递归地进行排序。 （3）合并：将排好序的有序子序列进行合并，得到符合要求的有序序列。</p>
</blockquote>
<h2 id="%E5%90%88%E5%B9%B6%E6%96%B9%E6%B3%95">合并方法</h2>
<blockquote>
<p>设置三个工作指针i，j，k。其中，i和j指示两个待排序序列中当前需比较的元素，k指向辅助数组B中待放置元素的位置。比较A[i]和A[j]的大小关系，如果A[i]小于等于A[j]，则B[k]=A[i]，同时将指针i和k分别推进一步；反之，B[k]=A[j]，同时将指针j和k分别推进一步。如此反复，直到其中一个序列为空。最后，将非空序列中的剩余元素按原次序全部放到辅助数组B的尾部。 </p>
</blockquote>
<h2 id="%C2%A0%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0"> 算法描述</h2>
<h3 id="%E9%9D%9E%E9%80%92%E5%BD%92%E5%BD%A2%E5%BC%8F">非递归形式</h3>
<pre><code class="language-cpp">void Merge(int A[]，int low，int middle，int high)
{
int i,j,k; 
int *B=new int[high-low+1];
i=low; j=middle+1; k=low;
  while(i&lt;=middle&amp;&amp;j&lt;=high)  //两个子序列非空
 if(A[i]&lt;=A[j])  B[k++]=A[i++];
     else  B[k++]=A[j++];
 while (i&lt;=middle) B[k++]=A[i++];
 while (j&lt;=high) B[k++]=A[j++];
  for(i=low;i&lt;=high;i++) A[i++]=B[i++];
}</code></pre>
<h3 id="%C2%A0%E9%80%92%E5%BD%92%E5%BD%A2%E5%BC%8F"> 递归形式</h3>
<pre><code class="language-cpp">void MergeSort (int A[]，int low，int high)
{    
  int middle;
  if (low&lt;high) 
     {
        middle=(low+high)/2;   //取中点
        MergeSort(A,low,middle); 
        MergeSort(A,middle+1,high); 
        Merge(A,low,middle,high); //合并
     }
}</code></pre>
<h2 id="%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">时间复杂度</h2>
<p style="text-align:center;"><img alt="" src="image\7b33e49e2c2040be970177e70694efab.png"/></p>
<blockquote>
<p> 求得T(n)=nT(1)+nlogn=n+nlogn，即合并排序算法的时间复杂性为O(nlogn)</p>
</blockquote>
<h1 id="%E4%B8%89%E3%80%81">三、快速排序</h1>
<h2>算法思想</h2>
<blockquote>
<p>通过一趟扫描将待排序的元素分割成独立的三个序列：第一个序列中所有元素均不大于基准元素、第二个序列是基准元素、第三个序列中所有元素均不小于基准元素。由于第二个序列已经处于正确位置，因此需要再按此方法对第一个序列和第三个序列分别进行排序，整个排序过程可以递归进行，最终可使整个序列变成有序序列。</p>
</blockquote>
<h2 id="%E5%BF%AB%E6%8E%92%E5%88%86%E6%B2%BB%E4%BD%93%E7%8E%B0">快排分治体现</h2>
<blockquote>
<p>1、分解  </p>
<p>在A[low:high]中选定一个元素作为基准元素(P)，以此基准元素为标准将待排序序列划分为两个子序列并使序列A[low:P-1]中所有元素的值均小于等于A[P]，序列A[P+1:high]中所有元素的值均大于等于A[P]。</p>
<p>2、求解子问题 对子序列A[low:P-1]和A[P+1:high],分别通过递归调用快速排序算法来进行排序。</p>
<p>3、合并 就地排序。</p>
</blockquote>
<p>  对于基准元素P可以采取以下五种方法：</p>
<blockquote>
<p>（a）取第一个元素。 （b）取最后一个元素。 （c）取位于中间位置的元素。 （d）“三者取中的规则”。 （e）取位于low和high之间的随机数，用A[P]作为基准元素。即采用随机函数产生一个位于low和high之间的随机数P(low≤P≤high)，用A[P]作为基准，这相当于强迫R[low:high]中的元素是随机分布的。 </p>
</blockquote>
<h2 id="%C2%A0%E5%88%92%E5%88%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%9E%84%E9%80%A0%E5%AE%9E%E4%BE%8B"> 划分方法的构造实例</h2>
<h3 id="%E5%9B%BE%E7%A4%BA%E5%8A%A9%E7%90%86%E8%A7%A3">图示助理解</h3>
<p>以第一个元素作为基准元素</p>
<blockquote>
<p class="img-center"><img alt="" height="328" src="image\e5dc1dbb05c54146a0e51d7626105f6e.png" width="441"/></p>
<p class="img-center"><img alt="" height="334" src="image\00c7eefc6df24b62bd0c75c936ba1396.png" width="450"/></p>
</blockquote>
<h3 id="%C2%A0%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"> 具体代码实现</h3>
<p>tips：完整代码，可复制后直接使用</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
//交换函数swap
void swap1(int&amp; a, int&amp; b)
{
	int temp = a; a = b; b = temp;
}
//做一个把数组分两半的函数
int sortSecond(int A[], int low, int high)
{
	int P = A[high];//基数选择右边界
	while (low &lt; high)
	{
		while (low &lt; high &amp;&amp; A[low] &lt;= P)
			low++;//左边部分小的跳过
		if (low &lt; high){
			swap1(A[low], A[high--]);//大的扔到后面并使右边界减一
		}
		while (low&lt;high &amp;&amp; A[high]&gt;=P)
			high--;//右边大的跳过
		if (low &lt; high) {
			swap1(A[low++], A[high]);//小的扔到前面并使左边界加一
		}
	}
	return low;//此时low=high
}
void fastSort(int A[], int low, int high)
{
	if (low &gt; high) return;//递归结束条件 low&gt;high
	int v = sortSecond(A, low, high);
	fastSort(A, low,  v - 1);//对左区间递归排序
	fastSort(A, v + 1, high);//对右区间递归排序
}
int main()
{
	int A[9] = {4,3,1,2,4,9,5,8,6};
	int len = sizeof(A) / sizeof(A[0]);
	cout &lt;&lt; "排序前数组为：\t" &lt;&lt; endl;
	for (int i = 0; i &lt; len; i++)
	{
		cout &lt;&lt; A[i] &lt;&lt; " ";
	}
	cout &lt;&lt; endl;
	fastSort(A, 0, len-1);//时间复杂度 平均情况O(nlogn)，最坏情况O(n^2)
	cout &lt;&lt; "快速排序后数组为：\t" &lt;&lt; endl;
	for (int i = 0; i &lt; len; i++)
	{
		cout &lt;&lt; A[i] &lt;&lt; " ";
	}
}</code></pre>
<p>我选择的是以最右边的元素作为基准元素，所以先和基准元素左边的值作比较，如果A[low]&lt;=P，进行low++操作，反之交换数据并让让右边界减一，这是因为右半部分是和P作比较，所以没必要把判断过的数据重复判断，直到low!&lt;high，返回low的值，而且不难想到此时low=high。</p>
<h3 id="%C2%A0%E8%BF%90%E8%A1%8C%E6%95%88%E6%9E%9C"> 运行效果</h3>
<p style="text-align:center;"><img alt="" src="image\9147abd899304490a175c228aebaa3f0.png"/></p>
<h2>时间复杂度</h2>
<p> <img alt="" height="431" src="image\62e64140b2a344d096dec8f58b582094.png" width="494"/></p>
<h1 id="%C2%A0%E7%BB%93%E8%AF%AD"> 结语</h1>
<p>有趣的分治法到这里就结束了，分治法是一种很重要的算法。它采取各个击破的技巧来解决一个规模较大的问题，该技巧是很多高效算法的基础，所以希望这篇博客可以被大家收藏，如果有错误或者不规范的地方一定评论出来，我每天都会管理我的博客内容，你的点赞关注评论是我前进的最大动力，加油！！！</p>
<p></p>
</div>
</div>