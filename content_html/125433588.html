<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<p style="margin-left:0;text-align:center;"><strong>博弈论基础</strong></p>
<blockquote>
<p style="margin-left:0;text-align:justify;">    博弈论又被称为<span style="color:#5b9bd5;">对策论</span>(Game Theory)，既是现代数学的一个新分支，也是运筹学的一个重要学科。博弈论主要研究公式化了的<span style="color:#5b9bd5;">激励结构间的相互作用</span>，是研究具有斗争或竞争性质现象的数学理论和方法。博弈论考虑游戏中的<span style="color:#5b9bd5;">个体的预测行为和实际行为</span>，并研究<span style="color:#ffc000;">它们的优化策略</span>。</p>
</blockquote>
<p style="margin-left:0;text-align:justify;"><strong>引入：囚徒困境</strong></p>
<blockquote>
<p style="margin-left:0;text-align:justify;">    囚徒困境的故事讲的是,两个嫌疑犯小A、小B作案后被警察抓住,分别关在不同的屋子里接受审讯。警察知道两人有罪,但缺乏足够的证据。警察告诉每个人:<span style="color:#c55a11;">如果两人都抵赖,各判刑一年</span>;<span style="color:#bf9000;">如果两人都坦白,各判五年</span>;<span style="color:#548235;">如果两人中一个坦白而另一个抵赖,坦白的放出去,抵赖的判十年</span>。</p>
</blockquote>
<p style="margin-left:0;text-align:justify;">于是,每个囚徒都面临两种选择:坦白或抵赖。</p>
<p style="margin-left:0;text-align:justify;"><img alt="" height="444" src="image\6202d780d7224f8fa752516656ed5ea6.png" width="865"/></p>
<p>    在不和小B商量的情况下，作为小A的你是选择招供坐牢5年或0年，还是会选择抵赖坐牢10年或1年呢？</p>
<p>                                        <img alt="" height="245" src="image\c12c5de1af67450688d4ad9a28422d1f.png" width="315"/></p>
<p></p>
<p style="margin-left:0;text-align:justify;">一般的人都会选着保险一点的<span style="color:#38d8f0;">招供</span>吧。</p>
<p style="margin-left:0;text-align:justify;">    反观小B，也一定会做出同样的选择，也就是招供。换句话说，<strong>只要两名囚徒都是自私且理性的，那么双方都会同时选择招供，结果就是双方各判5年。</strong></p>
<blockquote>
<p style="margin-left:0;text-align:justify;">    在这个场景中，双方都无法<strong>单方面</strong>改变自己的博弈策略（单方面改变只会让自己蒙受损失），使得局面进入了一个微妙而又稳定的平衡，这个平衡被称为<strong>纳什均衡</strong>。</p>
</blockquote>
<blockquote>
<p style="margin-left:0;text-align:justify;">    在现实中,也有很多类似的现象,比如家长给孩子报越来越多的课外班,比如高三考生备战高考,<span style="color:#ff0000;">卷</span>起来了啊.从局外人看来,许多竞争都是显而易见双输的局面,但是我们没有办法,因为我们都是参与博弈的“囚徒”。</p>
</blockquote>
<h1 style="margin-left:0px;text-align:justify;">ICG博弈</h1>
<blockquote>
<p style="margin-left:0;text-align:justify;">所讨论的博弈问题满足以下条件：</p>
<p style="margin-left:0;text-align:justify;">    玩家<span style="background-color:#ffff00;">只有两个人</span>，<span style="background-color:#ffff00;">轮流</span>做出决策。</p>
<p style="margin-left:0;text-align:justify;">    游戏的<span style="background-color:#ffff00;">状态集有限</span>，保证游戏在有限步后结束，这样必然会<span style="background-color:#ffff00;">产生不能操作者</span>，其输。</p>
<p style="margin-left:0;text-align:justify;">    对任何一种局面，胜负只<span style="background-color:#ffff00;">决定于局面本身</span>，而与轮到哪位选手无关。</p>
</blockquote>
<p style="margin-left:0;text-align:justify;"><strong>取石子游戏：</strong>取石子游戏是一个古老的博弈游戏，发源于中国，它是组合数学领域的一个经典问题。它有许多不同的玩法，基本上是两个玩家，玩的形式是<span style="background-color:#ffff00;">轮流抓石子</span>，胜利的标准是<span style="background-color:#ffff00;">抓走最后的石子</span>。<strong>玩家设定</strong>： 先取石子的是玩家A（<span style="background-color:#ffff00;">先手A</span>），后取石子的是玩家B（<span style="background-color:#ffff00;">后手B</span>）。</p>
<blockquote>
<p style="margin-left:0;text-align:justify;"><strong>经典的三种玩法</strong></p>
<p style="text-align:justify;">一、巴什博奕(Bash Game)</p>
<p style="margin-left:0;text-align:justify;">二、尼姆博奕(Nimm Game)</p>
<p style="margin-left:0;text-align:justify;">三、威佐夫博奕(Wythoff Game)</p>
</blockquote>
<h1 style="margin-left:0px;text-align:justify;"></h1>
<h1 style="margin-left:0px;text-align:justify;">（一）巴什博弈</h1>
<p style="margin-left:0;text-align:justify;"><span style="color:#4472c4;">1</span><span style="color:#4472c4;">堆n个石子</span>每次<span style="color:#ffc000;">最多取m个、至少取1个</span></p>
<blockquote>
<p style="margin-left:0;text-align:justify;">Case 1:如果n=m+1，那么<span style="color:#4da8ee;">由于一次最多只能取m个</span>，所以，无论先取者拿走多少个，后取者都能够一次拿走剩余的物品，<span style="color:#fe2c24;"><span style="background-color:#fefcd8;">后者取胜</span></span>。</p>
<p style="margin-left:0;text-align:justify;">Case 2:n=(m+1)*r+s，(r为任意自然数，s≤m),那么先取者要拿走s个物品，如果后者拿走k(1≤k≤m)个，那么先取者再拿走m+1-k个，结果剩下(m+1)(r-1)个，以后保持这样的取法，那么<span style="color:#fe2c24;"><span style="background-color:#fefcd8;">先取者肯定获胜</span></span>。</p>
<p style="margin-left:0;text-align:justify;">Case 3:n=r*(m+1)，先手拿走k(1≤k≤m)个，那么后手再拿走m+1-k个，结果剩下(m+1)(r-1)个，以后保持这样的取法，<span style="color:#fe2c24;"><span style="background-color:#fefcd8;">则后手胜，先手必败</span></span>。</p>
</blockquote>
<p style="margin-left:0;text-align:justify;">总之，要保持给对手留下（m+1）的倍数，就能最后获胜。</p>
<blockquote>
<p style="margin-left:0;text-align:justify;">术语:正经人称(m+1)的局面为奇异局势</p>
</blockquote>
<p style="margin-left:0;text-align:justify;"><strong>变相的玩法</strong></p>
<p style="text-align:justify;">两个人轮流报数，每次至少报一个，最多报十个，谁能报到100者胜。（等价于从一堆100个石子中取石子，最后取完的胜）</p>
<p style="margin-left:0;text-align:justify;">例题：<a href="http://poj.org/problem?id=2368" title="2368 -- Buttons (poj.org)">2368 -- Buttons (poj.org)</a></p>
<p style="margin-left:0;text-align:justify;">题面：</p>
<p style="margin-left:0;text-align:justify;"><img alt="" height="904" src="image\d7d60ef5c269443cb9858a28afada388.png" width="1200"/></p>
<p>      题面意思：有一堆k个的石头，每人轮流拿1,2，..L个石头，数据范围是3 &lt;= K &lt;= 100 000 000 ，2 &lt;= L &lt; K。输入k的值，要求输出最小的L，使得后者胜。</p>
<blockquote>
<p>在理解了巴什博弈之后来看这题还是思路比较清晰的，首先<span style="color:#4da8ee;">想让后手胜，就必须把（1+L）的局面留给先手</span>。这题没问我们谁会赢，问的是<span style="background-color:#fbd4d0;">后手要赢的最小L值为多少</span>。那我们就找到能<strong>被k整除的最小大于2的因数</strong>，之后<strong>减1</strong>输出就是答案了。</p>
</blockquote>
<p>于是有了以下代码注意下（poj用不了万能头文件，编译器要求有点严格。）：</p>
<pre><code>//#include&lt;bits/stdc++.h&gt;
#include&lt;iostream&gt;
using namespace std;
typedef long long ll;
const int N=100005;
ll n;//石子数量
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin&gt;&gt;n;
    ll i;
    for(i=2;i&lt;n;i++)//依次找最小的因子
    {
        if(n%(i+1)==0)
        {
            cout&lt;&lt;i&lt;&lt;endl;
            break;
        }
    }
    if(i==n) cout&lt;&lt;0&lt;&lt;endl;//找不到的情况下输出0
    return 0;
}
</code></pre>
<p> 就是说数据范围1e8，就超时快乐，TEL了哈哈哈哈哈哈。由于循环2~n，时间复杂度是O(n)。</p>
<blockquote>
<p>    再有一个新的思路就是，遍历一遍所有的n的因数，存起来，在输出最小大于等于3的因数减一。一下代码时间复杂度为O(log n)。AC快乐。</p>
</blockquote>
<pre><code>//#include&lt;bits/stdc++.h&gt;
#include&lt;algorithm&gt;
#include&lt;math.h&gt;
#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
using namespace std;
typedef long long ll;
const int N=100005;
ll n,a[N];//n为石头总数，a[i]存n的因数
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin&gt;&gt;n;
    int temp=0;
    for(int i=1;i*i&lt;=n;i++)
    {
        if(n%i==0&amp;&amp;i*i!=n) a[temp++]=i,a[temp++]=n/i;
        //注意要区别开类似n=4时，因数为1,2,4.而不是1,2,2,4的情况
        else if(n%i==0&amp;&amp;i*i==n) a[temp++]=i;
    }
    sort(a,a+temp);//从小到大排序一下
    for(int i=0;i&lt;temp;i++)
    {
        if(a[i]&gt;=3)//找到最小大于等于3的因数，减一输出
        {
            cout&lt;&lt;a[i]-1&lt;&lt;endl;
            break;
        }
    }
    return 0;
}
</code></pre>
<p style="margin-left:0;text-align:justify;"></p>
<p style="margin-left:0;text-align:justify;"></p>
<h2 style="margin-left:0px;text-align:justify;">（二）尼姆博弈</h2>
<p style="margin-left:0;text-align:justify;">有n堆石子，每堆石子的数量是a1,a2,a3……，二个人依次从这些<span style="color:#4472c4;">石子堆中的一个拿取任意的石子</span>，<span style="color:#ffc000;">至少一个</span>，最后一个拿光石子的人胜利</p>
<blockquote>
<p style="margin-left:0;text-align:justify;"><strong>n=1: </strong>先手全拿，先手必胜。</p>
<p style="margin-left:0;text-align:justify;"><strong>n=2:</strong>有两种情况，一种可能相同，一种情况一堆比另一堆少（多）</p>
<p style="margin-left:0;text-align:justify;">        (m,m) 按照“有一学一，照猫画猫”法，先手必输。</p>
<p style="margin-left:0;text-align:justify;">        (m,M)先手先从多的一堆中拿出(M-m)个，此时后手面对(m,m)的局面先手必胜。</p>
<p style="margin-left:0;text-align:justify;"></p>
<p style="margin-left:0;text-align:justify;">术语:正经人称(m,m)的局面为奇异局势</p>
<p style="margin-left:0;text-align:justify;"></p>
<p style="margin-left:0;text-align:justify;"><strong>n=3:</strong>(m,m,M)先手必胜局，先手可以先拿M,之后变成了(m,m,0)的局面，是不是很熟悉~</p>
<p style="margin-left:0;text-align:justify;"> (a1,a2,a3)的话，举个例子(1,2,3),先手取完之后可能的局面为(0,2,3),(1,1,3),(1,0,3),(1,2,2),(1,2,1),(1,2,0)都是之前讲过的，情况如下：</p>
</blockquote>
<p style="margin-left:0;text-align:justify;"><img alt="" height="277" src="image\6980fe7bd483488ba27249e5cd89ef12.png" width="865"/></p>
<p> <img alt="" height="92" src="image\d14436b06ce94bfbbca0c8ccba154b9c.png" width="865"/></p>
<p><img alt="" height="92" src="image\fcb1c1d22d7b40fb82bc01632717e5a3.png" width="865"/></p>
<blockquote>
<p style="margin-left:0;text-align:justify;">前人告诉我们的规律是：异或的结果均为0</p>
</blockquote>
<p style="margin-left:0;text-align:justify;"><strong>获胜情况的讨论</strong></p>
<p style="margin-left:0;text-align:justify;">面对异或结果为0的玩家必输。</p>
<p style="margin-left:0;text-align:justify;">结果不为0，则玩家有获胜的取法。</p>
<p style="margin-left:0;text-align:justify;">例题：<a href="https://www.acwing.com/problem/content/893/" title="891. Nim游戏 - AcWing题库">891. Nim游戏 - AcWing题库</a></p>
<p> 题面：</p>
<p><img alt="" height="752" src="image\b84367947db443d89e0b270bcfb0e85b.png" width="1003"/></p>
<p>看懂了尼姆博奕，这个题目就是分分钟AC咯。</p>
<p>上代码：</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
const int N=100005;
ll n,a[N];
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin&gt;&gt;n;
    for(int i=0;i&lt;n;i++)
        cin&gt;&gt;a[i];
    int ans=a[0];
    for(int i=1;i&lt;n;i++) ans^=a[i];//^就是做异或运算
    if(ans==0) cout&lt;&lt;"No"&lt;&lt;endl;
    else cout&lt;&lt;"Yes"&lt;&lt;endl;
    return 0;
}
</code></pre>
<p></p>
<p></p>
<h2 style="margin-left:0px;text-align:justify;">(三)威佐夫博弈</h2>
<p style="margin-left:0;text-align:justify;">有两堆各若干个物品，两个人轮流从<span style="color:#4472c4;">任一堆取至少一个</span>或<span style="color:#4472c4;">同时从两堆中取同样多的物品</span>，规定<span style="color:#ffc000;">每次至少取一个，多者不限</span>，最后取光者得胜。</p>
<p style="margin-left:0;text-align:justify;"></p>
<blockquote>
<p style="margin-left:0;text-align:justify;">举一个例子:局势是(1,2)，先手有四种取法，动动你聪明的脑子就会发现无论先手怎么取，后手都能胜利，也就是说(1,2)是奇异局势。</p>
</blockquote>
<p style="margin-left:0;text-align:justify;">没脑子的人来看看分析咯：</p>
<p style="margin-left:0;text-align:justify;">先手从第一堆里面拿1个，后者拿光后面的2个，后者胜。</p>
<p style="margin-left:0;text-align:justify;">先手从第一堆和第二堆里面同时拿1个，后者只能拿走第二堆剩下的1个，后者胜。</p>
<p style="margin-left:0;text-align:justify;">先手从第二堆里面拿2个，后手拿走第一堆的1个，后者胜.</p>
<p style="margin-left:0;text-align:justify;">先手从第二堆里面拿1个，后手从第一堆和第二堆里面同时拿走1个，后者胜。</p>
<blockquote>
<p style="margin-left:0;text-align:justify;">假设现在的局势是（3,5)：</p>
</blockquote>
<p style="margin-left:0;text-align:justify;">（1）先手在“3”中取1个，后手就可以在“5”中取走4个，这样就变成了（1，2）的局势</p>
<p style="margin-left:0;text-align:justify;">（2）先手在“3”中取2个，后手就可以在 “5” 中取走3个，这样也变成了（1,2）的局势</p>
<p style="margin-left:0;text-align:justify;">（3）先手在“5”中取1个，后手就在 “3”和“5” 中各取走2个，这样成了（1，2）的局势</p>
<p style="margin-left:0;text-align:justify;">（4）先手在”5”中取2个,后手就在 “3”和”5”中各取走3个,这样变成了(0，0)的局势，先手输</p>
<p style="margin-left:0;text-align:justify;">（5）先手在“5”中取3个，后手就在 “3”和“5” 中各取走1个，也变成了（1，2）的局势</p>
<p style="margin-left:0;text-align:justify;">（6）先手在“5”中取4个，后手在“3”中取走1个，还是（1，2）的局势</p>
<p style="margin-left:0;text-align:justify;"></p>
<blockquote>
<p style="margin-left:0;text-align:justify;">我们可以来找找那些先手必输局势的规律（奇异局势）</p>
</blockquote>
<ul><li style="text-align:justify;">第一种（0，0）</li><li style="text-align:justify;">第二种（1，2）</li><li style="text-align:justify;">第三种（3，5）</li><li style="text-align:justify;">第四种  (4 ，7）</li><li style="text-align:justify;">第五种（6，10）</li><li style="text-align:justify;">第六种  (8，13）              </li><li style="text-align:justify;">第七种  (9 ，15）</li><li style="text-align:justify;">第八种  (11 ，18）</li><li style="text-align:justify;">第n种（a，b）</li></ul>
<blockquote>
<p style="margin-left:0;text-align:justify;"><strong>我们会发现他们的<span style="color:#38d8f0;">差值是递增</span>的，分别是0,1,2,3,4,5,6,7......n</strong></p>
<p style="margin-left:0;text-align:justify;"><strong>还有一个规律(正常人都发现不了):<span style="color:#fe2c24;">a=(b-a)*1.618向下取整</span></strong></p>
</blockquote>
<p style="margin-left:0;text-align:justify;"> 就是：a = int(b - a)*1.618</p>
<p style="margin-left:0;text-align:justify;">注：这里的int是强制类型转换，注意这不是简单的四舍五入，假如后面的值是3.9，转换以后得到的不是4而是3，也就是说强制int类型转换得到的是<span style="color:#4da8ee;">不大于这个数值的最大整数</span>。</p>
<blockquote>
<p style="margin-left:0;text-align:justify;">有些题目要求精度较高，我们可以用下述式子来表示这个值:</p>
<p style="margin-left:0;text-align:justify;">1.618 = (sqrt(5.0) + 1) / 2   </p>
<p style="margin-left:0;text-align:justify;">头文件：include&lt;math.h&gt;</p>
</blockquote>
<p>例题：<a href="http://poj.org/problem?id=1067" title="1067 -- 取石子游戏 (poj.org)">1067 -- 取石子游戏 (poj.org)</a></p>
<p>题面：</p>
<p><img alt="" height="887" src="image\acf036bf34c5427b87ac7e8237ace45a.png" width="1200"/></p>
<p> 代码：</p>
<pre><code>//#include&lt;bits/stdc++.h&gt;
#include&lt;algorithm&gt;
#include&lt;math.h&gt;
#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
using namespace std;
typedef long long ll;
const int N=100005;
ll a,b;
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    while(cin&gt;&gt;a&gt;&gt;b)//多组输入！！！
    {
        double flag= (sqrt(5.0) + 1) / 2.0;//精度高一些用double来存1.618
        if(a&gt;b) swap(a,b);//保证b要比a大，后面有用到b-a
        if(a==int((b-a)*flag))cout&lt;&lt;0&lt;&lt;endl;//先手面对奇异局势必输
        else cout&lt;&lt;1&lt;&lt;endl;
    }

    return 0;
}
</code></pre>
<p></p>
<p></p>
<p></p>
</div>
</div>