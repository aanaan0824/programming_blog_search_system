<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="markdown_views prism-atom-one-dark" id="content_views">
<svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
<path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
</svg>
<p>/*<br/> *文章未优化完成，我会尽快维护<br/> */<br/> 目錄<br/> 一、类库：图书馆，命名空间：书架，类：书籍，方法：目录<br/> 1、类库的引用： <br/> 2、初识类与名称空间： <br/> 3、依赖关系： <br/> 4、类与对象的关系： <br/> 5、类的三大成员：<br/> 6、静态成员与实例成员： <br/> 二、C#语言的基本元素、类型、变量、方法、算法：<br/> 1、构成C#语言的基本元素： <br/> 2、简要介绍类型、变量和方法： <br/> 3、算法简介： <br/> 三、类型 <br/> 1、什么是类型（Type） <br/> 2、类型在C#语言中的作用 <br/> 3、C#语言的类型系统 <br/> 四、变量、对象与内存<br/> 1、什么是变量： <br/> 2、值类型的变量 <br/> 3、引用类型的变量和实例 <br/> 4、局部变量是在stack(栈)上分配内存 <br/> 5、变量的默认值 <br/> 6、常量（值不可改变的变量） <br/> 7、装箱与拆箱（Boxing &amp; Unboxing） <br/> 五、方法的定义、调用与调试： <br/> 1、方法的由来： <br/> 2、方法的定义与调用： <br/> 3、构造器（一种特殊的方法）： <br/> 4、方法的重载： <br/> 5、如何对方法进行Debug <br/> 6、方法的调用与栈（*难点） <br/> 六、操作符 <br/> 1、操作符概述 <br/> 2、操作符的本质 <br/> 3、操作符的优先级 <br/> 4、同级操作符的运算顺序 <br/> 5、基本操作符 <br/> 6.一元操作符 <br/> 七、表达式和语句 <br/> 1、表达式的定义 <br/> 2、各式表达式概览 <br/> 3、语句的定义 <br/> 4、语句详解 <br/> 八、字段、属性、索引器、常量<br/> 1、字段 <br/> 2、属性： <br/> 3、索引器 <br/> 4、常量 <br/> 九、传值/输出/引用/数组/具名/可选参数，扩展方法 <br/> 1、传值参数 <br/> 2、输出参数 <br/> 3、引用参数 <br/> 4、数组参数 <br/> 5、具名参数 <br/> 6、可选参数 <br/> 7、扩展方法（this参数） <br/> 十、委托 <br/> 1、什么是委托 <br/> 2、委托的声明（自定义委托） <br/> 3、委托的使用 <br/> 十一、事件 <br/> 1、初步了解事件 <br/> 2、事件的应用 <br/> 3、深入理解事件 <br/> 4、事件的声明 <br/> 5、问题辨析</p>
<p>一、类库：图书馆，命名空间：书架，类：书籍，方法：目录</p>
<p>1、类库的引用：<br/> （1） 类库引用是使用名称空间的物理基础<br/> 不同技术类型的项目会默认引用不同类型的类库。 <br/> （2） DLL引用（黑盒引用，无源代码）<br/> NuGet简介(DLL服务器)<br/> （3） 项目引用（白盒引用，有源代码）</p>
<p>2、初识类与名称空间： <br/> （1） 类（class）是构成程序的主体【初学者需要知道的定义】。<br/> （2） 类（class）是最基础的C#类型。类是一个数据结构，将状态（字段）和操作（方法和其他函数成员）组合在一个单元中。类为动态创建的类实例（instance）提供了定义，实例也称为对象（object）。类支持继承（inheritance）和多态性（polymorphism），这是派生类（derived class）可用来扩展和专用化基类（base class）的机制【C#语言文档的定义】。<br/> （3） 类（class）是现实世界事物的模型；<br/> 类是对现实世界事物进行抽象所得到的结果；<br/> [1]事物包括“物质”（实体）与“运动”（逻辑）；<br/> [2]建模是一个去伪存真、由表及里的过程（将程序中用到的东西留下；“表” 就是看得到的接口，“里”就是看不到的封装的逻辑。）。<br/> 名称空间（namespace）：以树型结构组织类（和其他类型），例如：Button和Path类。<br/> 命名空间保证同名的类不冲突。</p>
<p>3、依赖关系：<br/> （1） 类（或对象）之间的耦合关系；<br/> （2） 优秀的程序追求“高内聚，低耦合”；<br/> 高内聚：将类放到该放的类库中；<br/> 低耦合：类与类之间的关系尽量低依赖；<br/> 教学程序往往会违反这个原则；<br/> （3） UML（通用建模语言）类图；<br/> 【*依赖关系是软件质量的关键。】</p>
<p>4、类与对象的关系：<br/> （1） 对象也叫实例，是类经过“实例化”后得到的内存中的实体；<br/> Formally “instanc” is synonymous with “object”——对象和实例是一回事；<br/> “飞机”与“一架飞机”有何区别？天上有（一架）飞机——必须是实例飞，概念是不能飞的；<br/> 有些类是不能实例化的，比如“数学”（Math Class），我们不能说“一个数学”。<br/> （2） 依照类，我们可以创建对象，这就是“实例化”；<br/> 现实世界中常称“对象”，程序世界中常称“实例”，二者并无太大区别，常常混用。<br/> （3） 实例化：使用new操作符创建类的实例，后面加上()构造器。<br/> （4） 引用变量与实例的关系；<br/> 孩子与气球；<br/> 气球不一定有孩子牵着；<br/> 多个孩子可以使用各自的绳子牵着一个气球，也可以都通过一个绳子牵着气球。</p>
<pre><code class="prism language-csharp"><span class="token keyword">namespace</span> <span class="token namespace">ClassAndInstance</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">class</span> <span class="token class-name">Program</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> args<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">Form</span> myForm<span class="token punctuation">;</span>    <span class="token comment">//创建引用变量</span>
            myForm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Form</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//将new出来的实例Form，赋值给引用变量myForm</span>
            myForm<span class="token punctuation">.</span>Text <span class="token operator">=</span> <span class="token string">"MyForm"</span><span class="token punctuation">;</span> <span class="token comment">//给Form的标题命名为MyForm</span>
            myForm<span class="token punctuation">.</span><span class="token function">ShowDialog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//显示输出窗口</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>5、类的三大成员：<br/> （1） 属性（Property）<br/> 存储数据，组合起来表示类或对象当前的状态<br/> （2） 方法（Method）<br/> 由C语言中的函数（function）进化而来，表示类或对象“能做什么”<br/> 工作中90%的时间是在与方法打交道，因为它是“真正做事”、“构成逻辑”的成员</p>
<pre><code class="prism language-csharp"><span class="token keyword">namespace</span> <span class="token namespace">EventSample</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">partial</span> <span class="token keyword">class</span> <span class="token class-name">MainWindow</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">Window</span></span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">public</span> <span class="token function">MainWindow</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token function">InitializeComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//*实例化</span>
            <span class="token class-name">DispatcherTimer</span> timer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">DispatcherTimer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//*给属性值</span>
            <span class="token comment">//间隔多长时间触发一次Tick（这里是一秒钟）</span>
            timer<span class="token punctuation">.</span>Interval <span class="token operator">=</span> TimeSpan<span class="token punctuation">.</span><span class="token function">FromSeconds</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
            <span class="token comment">//*挂接事件处理器</span>
            <span class="token comment">//事件“Tick”通过“+=”将函数“timer_Tick”挂接，这个事件触发时，下面的函数就会执行。</span>
            <span class="token comment">//所以这个方法叫做事件处理器。</span>
            timer<span class="token punctuation">.</span>Tick <span class="token operator">+=</span> timer_Tick<span class="token punctuation">;</span>       
            <span class="token comment">//*方法调用</span>
            <span class="token comment">//让时钟开始</span>
            timer<span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">timer_Tick</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">object</span></span> sender<span class="token punctuation">,</span> <span class="token class-name">EventArgs</span> e<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>	
            <span class="token comment">//事件触发时，执行下面方法</span>
            <span class="token comment">//访问当前时间（时钟）</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>timeTextBox<span class="token punctuation">.</span>Text <span class="token operator">=</span> DateTime<span class="token punctuation">.</span>Now<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>（3） 事件（Event）<br/> 类或对象通知其它类或对象的机制，为C#所特有（Java通过其他办法实现这个机制）<br/> 善用事件机制非常重要<br/> （4） 使用MSDN文档<br/> （5） 某些特殊类或对象在成员方面侧重点不同<br/> 模型类或对象重在属性，如：Entity Framework<br/> 工具类或对象重在方法，如：Math，Console<br/> 通知类或对象重在事件，如各种Timer</p>
<p>6、静态成员与实例成员：<br/> （1） 静态（Static）成员在语义上表示它是“类的成员”<br/> （2） 实例（非静态）成员在语义表示它是“对象的成员”</p>
<pre><code class="prism language-csharp"><span class="token keyword">namespace</span> <span class="token namespace">StaticSample</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">class</span> <span class="token class-name">Program</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> args<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Hello!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//*静态：WriteLine隶属于Console，由Console直接调用</span>

            <span class="token class-name">Form</span> form <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Form</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//*实例：实例化，定义变量form</span>
            form<span class="token punctuation">.</span>Text <span class="token operator">=</span> <span class="token string">"Hello!"</span><span class="token punctuation">;</span>       <span class="token comment">//通过变量form来调用实例的方法“Text”</span>
            form<span class="token punctuation">.</span><span class="token function">ShowDialog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>	
</code></pre>
<p>（3） 绑定（Binding）指的是编译器如何把一个成员与类或对象关联起来<br/> 不可小觑的“.”操作符——成员访问<br/> （类.类成员，实例.实例成员）</p>
<p>二、C#语言的基本元素、类型、变量、方法、算法：<br/> 1、构成C#语言的基本元素：<br/> （1）关键字（Keyword） <br/> MSDN文档：Visual C#-&gt;C#Reference（所有关键字）<br/> （2）操作符（Operator）<br/> Visual C#-&gt;C#Reference-&gt;C#Operators（所有运算符）<br/> （3）标识符（Identifier）<br/> 合法的标识符（阅读语言定义文档）<br/> 大小写规范（变量名用驼峰命名法，类、方法用Pascal命名法[所有单词首字母大写]）<br/> 命名规范<br/> int inForm = 100; //驼峰命名法<br/> Console.WriteLine(inForm); //Pascal命名法<br/> （4）标点符号<br/> （5）文本（字面值）<br/> 整数（多种后缀）<br/> int z = 10;<br/> long h = 10L; <br/> 实数（多种后缀）<br/> float X = 10.0F;<br/> double Y = 20.0D;<br/> 字符<br/> char c = ‘a’;<br/> 字符串<br/> string str = “abcde”;<br/> 布尔<br/> bool b = true;<br/> bool b2 = false;<br/> 空（NULL）<br/> （6）注释与空白<br/> 单行<br/> 多行（块注释）</p>
<p>2、简要介绍类型、变量和方法：<br/> （1）初识类型（Type）<br/> 亦称数据类型（Data Type）<br/> var v = 3L;<br/> Console.WriteLine(v.GetType().Name); //INT64<br/> （2）变量是存放数据的地方，简称“数据”<br/> 变量的声明<br/> 变量的使用<br/> （3）方法（旧称函数）是处理数据的逻辑，又称“算法”<br/> 方法的声明<br/> 方法的调用</p>
<pre><code class="prism language-csharp"><span class="token keyword">namespace</span> <span class="token namespace">Identifiers</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">class</span> <span class="token class-name">Program</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> args<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">Calculator</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Calculator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name"><span class="token keyword">int</span></span> x <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token class-name">Calculator</span> d <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Calculator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name"><span class="token keyword">string</span></span> str <span class="token operator">=</span> d<span class="token punctuation">.</span><span class="token function">Today</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token class-name">Calculator</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Calculator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            a<span class="token punctuation">.</span><span class="token function">PrintSum</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">class</span> <span class="token class-name">Calculator</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">int</span></span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> a<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">int</span></span> b<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token class-name"><span class="token keyword">int</span></span> result <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
            <span class="token keyword">return</span> result<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">string</span></span> <span class="token function">Today</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token class-name"><span class="token keyword">int</span></span> day <span class="token operator">=</span> DateTime<span class="token punctuation">.</span>Now<span class="token punctuation">.</span>Day<span class="token punctuation">;</span>
            <span class="token keyword">return</span> day<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">PrintSum</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> a<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">int</span></span> b<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token class-name"><span class="token keyword">int</span></span> result <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>（4）程序=数据+算法<br/> 3、算法简介：<br/> （1）循环体验<br/> （2）判断体验</p>
<pre><code class="prism language-csharp"><span class="token keyword">namespace</span> <span class="token namespace">Identifiers</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">class</span> <span class="token class-name">Program</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> args<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">Calculator</span> x <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Calculator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            x<span class="token punctuation">.</span><span class="token function">PrintXTo1</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">class</span> <span class="token class-name">Calculator</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//public void PrintXTo1(int x)  //循环输出</span>
        <span class="token comment">//{<!-- --></span>
        <span class="token comment">//    for (int i = x; i &gt; 0; i--)</span>
        <span class="token comment">//    {<!-- --></span>
        <span class="token comment">//        Console.WriteLine(i);</span>
        <span class="token comment">//    }</span>
        <span class="token comment">//}</span>

        <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">PrintXTo1</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> x<span class="token punctuation">)</span>    <span class="token comment">//判断输出（自己调用自己）</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>
            <span class="token punctuation">{<!-- --></span>
                Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">else</span>
            <span class="token punctuation">{<!-- --></span>
                Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">PrintXTo1</span><span class="token punctuation">(</span>x<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>（3）1~100相加</p>
<pre><code class="prism language-csharp"><span class="token keyword">namespace</span> <span class="token namespace">Identifiers</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">class</span> <span class="token class-name">Program</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> args<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">Calculator</span> x <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Calculator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name"><span class="token keyword">int</span></span> result <span class="token operator">=</span> x<span class="token punctuation">.</span><span class="token function">SumFrom1ToX</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">class</span> <span class="token class-name">Calculator</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//public int SumFrom1ToX(int x)     //循环</span>
        <span class="token comment">//{<!-- --></span>
        <span class="token comment">//    int result = 0;</span>
        <span class="token comment">//    for (int i = 1; i &lt; x + 1; i++)</span>
        <span class="token comment">//    {<!-- --></span>
        <span class="token comment">//        result = result + i;</span>
        <span class="token comment">//    }</span>
        <span class="token comment">//    return result;</span>
        <span class="token comment">//}</span>

        <span class="token comment">//public int SumFrom1ToX(int x)   //递归</span>
        <span class="token comment">//{<!-- --></span>
        <span class="token comment">//    if (x==1)</span>
        <span class="token comment">//    {<!-- --></span>
        <span class="token comment">//        return 1;</span>
        <span class="token comment">//    }</span>
        <span class="token comment">//    else</span>
        <span class="token comment">//    {<!-- --></span>
        <span class="token comment">//        int result = x + SumFrom1ToX(x-1);</span>
        <span class="token comment">//        return result;</span>
        <span class="token comment">//    }</span>
        <span class="token comment">//}</span>

        <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">int</span></span> <span class="token function">SumFrom1ToX</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> x<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> x<span class="token punctuation">)</span> <span class="token operator">*</span> x <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>【*注：ctrl+k+c：所选部分注释； ctrl+k+u：所选部分解除注释。】</p>
<p>三、类型<br/> 1、什么是类型（Type）<br/> （1）又名数据类型（Data Type）<br/> A data type is a homogeneous collection of values,effectively presented,equipped presented,equipped with a set of operations which manipulate these values.<br/> 是数据在内存中存储时的“型号”。<br/> 小内存容纳大尺寸数据会丢失精准度、发生错误。<br/> 大内存容纳小尺寸数据会造成浪费。<br/> 编程语言的数据类型与数据的数据类型不完全相同。</p>
<pre><code class="prism language-csharp"><span class="token keyword">namespace</span> <span class="token namespace">StrongTyped</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">class</span> <span class="token class-name">Program</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> args<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token class-name"><span class="token keyword">int</span></span> x<span class="token punctuation">;</span>      <span class="token comment">//int：32个bit，4字节</span>
            x <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
            <span class="token class-name"><span class="token keyword">long</span></span> y<span class="token punctuation">;</span>     <span class="token comment">//long：64个bit位，8个字节</span>
            y <span class="token operator">=</span> <span class="token number">100L</span><span class="token punctuation">;</span>
            x <span class="token operator">=</span> <span class="token number">100L</span><span class="token punctuation">;</span>   <span class="token comment">//int型的x，放不了100L</span>

            <span class="token class-name"><span class="token keyword">bool</span></span> b<span class="token punctuation">;</span>
            b <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>    <span class="token comment">//识别不了数值</span>

            <span class="token keyword">if</span><span class="token punctuation">(</span> x <span class="token operator">=</span> <span class="token number">200</span> <span class="token punctuation">)</span>   <span class="token comment">//因为x被赋值200，不是布尔值，就输出不了</span>
            <span class="token punctuation">{<!-- --></span>
                Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"It's OK!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<pre><code>（2）强类型语言与弱类型语言的比较
	强类型语言：受数据类型影响较大，弱类型语言则相反。
	C语言示例：if条件。
	JavaScript示例：动态类型。
	C#语言对弱类型/动态类型的模仿。
</code></pre>
<pre><code class="prism language-csharp"><span class="token return-type class-name"><span class="token keyword">int</span></span> <span class="token function">_tmain</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> argc<span class="token punctuation">,</span> _TCHAR<span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token class-name"><span class="token keyword">int</span></span> x <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span> x <span class="token operator">=</span> <span class="token number">200</span> <span class="token punctuation">)</span>	<span class="token comment">//在if语句中被重新赋值为200，会输出结果。因此常被写作 200==x</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"It's OK!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>2、类型在C#语言中的作用<br/> （1）一个C#类型中所包含的信息有：<br/> [1]存储此类型变量所需的内存空间大小。<br/> [2]此类型的值可表示的最大最小值范围。<br/> [3]此类型所包含的成员（如方法、属性、事件等）。<br/> [4]此类型由何基类派生而来。</p>
<pre><code class="prism language-csharp"><span class="token keyword">namespace</span> <span class="token namespace">TypeSample</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">class</span> <span class="token class-name">Program</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> args<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">Type</span> myType <span class="token operator">=</span> <span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token type-expression class-name">Form</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token class-name">PropertyInfo<span class="token punctuation">[</span><span class="token punctuation">]</span></span> pInfo <span class="token operator">=</span> myType<span class="token punctuation">.</span><span class="token function">GetProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//PropertyInfo：属性的信息</span>
            <span class="token class-name">MethodInfo<span class="token punctuation">[</span><span class="token punctuation">]</span></span> mInfo <span class="token operator">=</span> myType<span class="token punctuation">.</span><span class="token function">GetMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//MethodInfo：方法的信息</span>
            <span class="token comment">//foreach(var p in pInfo)</span>
            <span class="token comment">//{<!-- --></span>
            <span class="token comment">//    Console.WriteLine(p.Name);</span>
            <span class="token comment">//}</span>
            <span class="token keyword">foreach</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">var</span></span> m <span class="token keyword">in</span> mInfo<span class="token punctuation">)</span>
            <span class="token punctuation">{<!-- --></span>
                Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span>Name<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>myType<span class="token punctuation">.</span>Name<span class="token punctuation">)</span><span class="token punctuation">;</span>
            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>myType<span class="token punctuation">.</span>FullName<span class="token punctuation">)</span><span class="token punctuation">;</span>
            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>myType<span class="token punctuation">.</span>BaseType<span class="token punctuation">)</span><span class="token punctuation">;</span>
            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>myType<span class="token punctuation">.</span>BaseType<span class="token punctuation">.</span>BaseType<span class="token punctuation">.</span>FullName<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>[5]程序运行的时候，此类型的变量在分配在内存的什么位置：<br/> Stack简介（栈），<br/> Stack overflow，<br/> Heap简介（堆），<br/> 使用Performance Monitor查看进程的堆内存使用量，<br/> 关于内存泄漏；</p>
<pre><code class="prism language-csharp"><span class="token comment">/*栈*/</span>
<span class="token keyword">namespace</span> <span class="token namespace">StackOverflow</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">class</span> <span class="token class-name">Program</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> args<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">BadGuy</span> bg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">BadGuy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//先创建实例</span>
            bg<span class="token punctuation">.</span><span class="token function">BadMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">//调用方法</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">class</span> <span class="token class-name">BadGuy</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">BadMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token class-name"><span class="token keyword">int</span></span> x <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">BadMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//递归：不断的调用自己，最后栈会爆掉</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">namespace</span> <span class="token namespace">StackOverflow</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">class</span> <span class="token class-name">Program</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> args<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">unsafe</span>
            <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">int</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token keyword">stackalloc</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">9999999</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">//在栈上面切内存，只要足够大就会爆掉</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">/*堆*/</span>
<span class="token keyword">namespace</span> <span class="token namespace">HeapSample</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">/// &lt;summary&gt;</span>
    <span class="token comment">/// MainWindow.xaml 的交互逻辑</span>
    <span class="token comment">/// &lt;/summary&gt;</span>
    <span class="token keyword">public</span> <span class="token keyword">partial</span> <span class="token keyword">class</span> <span class="token class-name">MainWindow</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">Window</span></span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">public</span> <span class="token function">MainWindow</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token function">InitializeComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token class-name">List<span class="token punctuation">&lt;</span>Window<span class="token punctuation">&gt;</span></span> winList<span class="token punctuation">;</span>       <span class="token comment">//变量，声明在函数之外，Window占用内存高</span>

        <span class="token keyword">private</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Button1_Click</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">object</span></span> sender<span class="token punctuation">,</span> <span class="token class-name">RoutedEventArgs</span> e<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            winList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">List<span class="token punctuation">&lt;</span>Window<span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//创建List实例，可以装Window</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">15000</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span>
            <span class="token punctuation">{<!-- --></span>
                <span class="token class-name">Window</span> w <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Window</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//引用变量w，牵着Windows（）实例</span>
                winList<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//加入队列</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">private</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Button2_Click</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">object</span></span> sender<span class="token punctuation">,</span> <span class="token class-name">RoutedEventArgs</span> e<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            winList<span class="token punctuation">.</span><span class="token function">Clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//清除内存</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>[6]此类型所允许的操作（运算）。</p>
<pre><code class="prism language-csharp"><span class="token keyword">namespace</span> <span class="token namespace">TypeSample</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">class</span> <span class="token class-name">Program</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> args<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token class-name"><span class="token keyword">double</span></span> result <span class="token operator">=</span> <span class="token number">3.0</span> <span class="token operator">/</span> <span class="token number">4.0</span><span class="token punctuation">;</span>
            <span class="token class-name"><span class="token keyword">double</span></span> results <span class="token operator">=</span> <span class="token number">3</span> <span class="token operator">/</span> <span class="token number">4</span><span class="token punctuation">;</span>
            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">//0.75</span>
            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>results<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//0</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>3、C#语言的类型系统<br/> （1）C#的五大数据类型<br/> [1]类（class）：如Window,Form,Console,String<br/> [2]结构体（Structures）:如Int32,Int64,Single,Double<br/> [3]枚举（Enumerations）:如HorizontalAlignment,Visibility<br/> [4]接口（Interfaces）： <br/> [5]委托（Delegates）：<br/> //class:声明和定义 类<br/> //struct:声明和定义 结构体<br/> //enum:声明和定义 枚举类型<br/> （2）C#类型的派生谱系<br/> <img alt="类型" src="https://img-blog.csdnimg.cn/b2c95b9ea4744af7ad507ccd13c85216.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6K6w5b-G5Lit55qE5pif56m6,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<p>四、变量、对象与内存<br/> 1、什么是变量：<br/> 表面上来看（从C#代码的上下文行文来看），变量的用途是存储数据。<br/> 实际上，变量表示了存储位置，并且每个变量都有一个类型，以决定什么样的值能够存入变量。<br/> 变量一共有7种：<br/> 静态变量，实例变量（成员变量，字段），数组元素，值参数，引用参数，输出形参，局部变量。</p>
<pre><code class="prism language-csharp"><span class="token keyword">namespace</span> <span class="token namespace">TypelnCSharp</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">class</span> <span class="token class-name">Program</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> args<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token comment">//1、Student.Amount:静态成员变量 </span>
            <span class="token class-name">Student</span> stu <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//2、stu.Add:非静态成员变量</span>
            <span class="token class-name"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name"><span class="token keyword">int</span></span><span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token comment">//3、array[0]:数组元素，0~99</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">class</span> <span class="token class-name">Student</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name"><span class="token keyword">int</span></span> Amount<span class="token punctuation">;</span>       <span class="token comment">//创建静态成员</span>
        <span class="token keyword">public</span> <span class="token class-name"><span class="token keyword">int</span></span> Age<span class="token punctuation">;</span>                 <span class="token comment">//创建非静态成员</span>
        <span class="token keyword">public</span> <span class="token class-name"><span class="token keyword">string</span></span> Name<span class="token punctuation">;</span>

        <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">double</span></span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">double</span></span> a<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">double</span></span> b<span class="token punctuation">)</span>   <span class="token comment">//double a和double b：是值参数变量；ref double a:引用参数变量；out double a:输出参数变量</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token class-name"><span class="token keyword">double</span></span> result <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>  <span class="token comment">//result是方法Add的局部变量</span>
            <span class="token keyword">return</span> result<span class="token punctuation">;</span>	
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>狭义的变量指局部变量，因为其他种类的变量都有自己的约定名称：<br/> 简单地讲，局部变量就是方法体（函数体）里生命的变量。<br/> 变量的声明：<br/> 格式：有效的修饰符组合类型opt 类型 变量名 初始化器opt。<br/> 如：public static int Amount = 0;<br/> 2、值类型的变量<br/> 以byte/sbyte/short/ushort为例</p>
<pre><code class="prism language-csharp"><span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> args<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
     <span class="token class-name"><span class="token keyword">short</span></span> s<span class="token punctuation">;</span>
      s <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1000</span><span class="token punctuation">;</span>
      <span class="token class-name"><span class="token keyword">string</span></span> str <span class="token operator">=</span> Convert<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    
      Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//1111110000011000</span>
 <span class="token punctuation">}</span>
	值类型没有实例，所谓的“实例”与变量合而为一
<span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> args<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token class-name"><span class="token keyword">short</span></span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name"><span class="token keyword">short</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//和 short a; 一样</span>
            <span class="token class-name"><span class="token keyword">short</span></span> a<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
</code></pre>
<p>3、引用类型的变量和实例<br/> 引用类型变量与实例的关系：引用类型变量里存储的数据是对象的内存地址。</p>
<pre><code class="prism language-csharp"><span class="token keyword">namespace</span> <span class="token namespace">TypelnCSharp</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">class</span> <span class="token class-name">Program</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> args<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">Student</span> stu<span class="token punctuation">;</span>             <span class="token comment">//引用类型，系统自动分配4个字节，存放实例堆内存地址</span>
            stu <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//创建实例，将Student实例的堆内存地址存储在变量stu中</span>
            <span class="token class-name">Student</span> stu2<span class="token punctuation">;</span>
            stu2 <span class="token operator">=</span> stu<span class="token punctuation">;</span>             <span class="token comment">//stu2同样存储实例的堆内存地址，这就是两个孩子牵着同一个气球</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">class</span> <span class="token class-name">Student</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token class-name"><span class="token keyword">uint</span></span> ID<span class="token punctuation">;</span>        <span class="token comment">//4个字节，值内存</span>
        <span class="token class-name"><span class="token keyword">ushort</span></span> Score<span class="token punctuation">;</span>   <span class="token comment">//2个字节，值内存</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>4、局部变量是在stack(栈)上分配内存<br/> 5、变量的默认值</p>
<pre><code class="prism language-csharp"><span class="token keyword">namespace</span> <span class="token namespace">TypelnCSharp</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">class</span> <span class="token class-name">Program</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> args<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">Student</span> stu <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>stu<span class="token punctuation">.</span>ID<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">//0</span>
            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>stu<span class="token punctuation">.</span>Score<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//0</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">class</span> <span class="token class-name">Student</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">public</span> <span class="token class-name"><span class="token keyword">uint</span></span> ID<span class="token punctuation">;</span>        <span class="token comment">//一但变量在内存中分配好后，内存块就会全部刷成0，默认值就变成0</span>
        <span class="token keyword">public</span> <span class="token class-name"><span class="token keyword">ushort</span></span> Score<span class="token punctuation">;</span>   <span class="token comment">//添加public，就可以从外部看到</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">namespace</span> <span class="token namespace">TypelnCSharp</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">class</span> <span class="token class-name">Program</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> args<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token class-name"><span class="token keyword">int</span></span> x<span class="token punctuation">;</span>          <span class="token comment">//本地变量必须要有赋值，否则就编译不过去</span>
            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">class</span> <span class="token class-name">Student</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">public</span> <span class="token class-name"><span class="token keyword">uint</span></span> ID<span class="token punctuation">;</span>        <span class="token comment">//一但变量在内存中分配好后，内存块就会全部刷成0，默认值就变成0</span>
        <span class="token keyword">public</span> <span class="token class-name"><span class="token keyword">ushort</span></span> Score<span class="token punctuation">;</span>   <span class="token comment">//添加public，就可以从外部看到</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>6、常量（值不可改变的变量）</p>
<pre><code class="prism language-csharp"><span class="token keyword">namespace</span> <span class="token namespace">TypelnCSharp</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">class</span> <span class="token class-name">Program</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> args<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">const</span> <span class="token class-name"><span class="token keyword">int</span></span> x <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>      <span class="token comment">//常量只能赋值一次，还有初始化器也必须带着，不可以分开</span>
            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
            x <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span>        <span class="token comment">//再次赋值会报错</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">class</span> <span class="token class-name">Student</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">public</span> <span class="token class-name"><span class="token keyword">uint</span></span> ID<span class="token punctuation">;</span>        <span class="token comment">//一但变量在内存中分配好后，内存块就会全部刷成0，默认值就变成0</span>
        <span class="token keyword">public</span> <span class="token class-name"><span class="token keyword">ushort</span></span> Score<span class="token punctuation">;</span>   <span class="token comment">//添加public，就可以从外部看到</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>7、装箱与拆箱（Boxing &amp; Unboxing）<br/> *：装箱与拆箱都会损失程序的性能。</p>
<pre><code class="prism language-csharp"><span class="token keyword">namespace</span> <span class="token namespace">TypelnCSharp</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">class</span> <span class="token class-name">Program</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> args<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token class-name"><span class="token keyword">int</span></span> x <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>    <span class="token comment">//（1）变量存储在栈中</span>
            <span class="token class-name"><span class="token keyword">object</span></span> obj<span class="token punctuation">;</span> <span class="token comment">//（2）obj是个引用类型，分配4个字节</span>
            obj <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token comment">//（3）在堆上找个可存储空间，把空间变成一个对象，然后把对象的地址存储到obj的空间中去</span>
            <span class="token comment">/*：2和3就是装箱，即object obj = x;
                装箱就是把栈上面值类型的值封装成一个object类型的实例放到堆上；
                拆箱：把堆上的object类型的实例里面的值，按照要求拆成目标数据类型，然后存储到栈上去；
            */</span>
            <span class="token class-name"><span class="token keyword">int</span></span> y <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>obj<span class="token punctuation">;</span>
            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">class</span> <span class="token class-name">Student</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">public</span> <span class="token class-name"><span class="token keyword">uint</span></span> ID<span class="token punctuation">;</span>        <span class="token comment">//一但变量在内存中分配好后，内存块就会全部刷成0，默认值就变成0</span>
        <span class="token keyword">public</span> <span class="token class-name"><span class="token keyword">ushort</span></span> Score<span class="token punctuation">;</span>   <span class="token comment">//添加public，就可以从外部看到</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>五、方法的定义、调用与调试：<br/> 1、方法的由来：<br/> （1）方法（method）的前身是C/C++语言的函数（function）：<br/> 方法是面向对象范畴的概念，在面向对象语言中仍然称为函数。<br/> 使用C/C++语言做对比。<br/> （2）永远都是类（或结构体）的成员：<br/> C#语言中函数不可能独立于类（或结构体）之外。<br/> 只有作为类（或结构体）成员时才被称为方法。<br/> C++中是可以的，称为“全局变量”<br/> （3）是类（或结构体）最基本的成员之一：<br/> 最基本的成员只有两个——字段和方法（成员变量与成员函数），本质还是数据+算法<br/> 方法表示类（或结构体）“能做什么事情”<br/> （4）为什么需要方法和函数：<br/> 目的1：隐藏复杂的逻辑<br/> 目的2：把大算法分解为小算法<br/> 目的3：复用（reuse，重用）<br/> 示例：计算圆面积、圆柱体积、圆锥体积</p>
<pre><code class="prism language-csharp"><span class="token keyword">namespace</span> <span class="token namespace">CSharpMethodExample</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">class</span> <span class="token class-name">Program</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> args<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">Calculator</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Calculator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">GetCircleArea</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">GetConeVolume</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">class</span> <span class="token class-name">Calculator</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//自顶向下，逐步求精的算法</span>
        <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">double</span></span> <span class="token function">GetCircleArea</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">double</span></span> r<span class="token punctuation">)</span>   <span class="token comment">//方法头。方法1：求底部圆面积</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> Math<span class="token punctuation">.</span>PI <span class="token operator">*</span> r <span class="token operator">*</span> r<span class="token punctuation">;</span>             <span class="token comment">//方法体</span>
        <span class="token punctuation">}</span>
        
        <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">double</span></span> <span class="token function">GetCylinderVolume</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">double</span></span> r<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">double</span></span> h<span class="token punctuation">)</span> <span class="token comment">//方法2：求圆柱体积</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token function">GetCircleArea</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span> <span class="token operator">*</span> h<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">double</span></span> <span class="token function">GetConeVolume</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">double</span></span> r<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">double</span></span> h<span class="token punctuation">)</span>     <span class="token comment">//方法3：求圆锥体积</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span>  <span class="token function">GetCylinderVolume</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span>h<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">3</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>2、方法的定义与调用：<br/> （1）声明方法的语法详解<br/> 参见C#语言文档（声明/定义不分家）<br/> Parameter全称为“formal parameter”，形式上的参数称为“形参”<br/> Parameter是一种变量<br/> （2）为方的命名规范<br/> 大小写规范<br/> 需要以动词或者动词短语作为名字<br/> （3）重温静态（static）方法和实例方法<br/> public static double GetCircleArea(double r) //静态方法<br/> public double GetCircleArea(double r) //实例方法</p>
<p>（4）调用方法<br/> Argument中文C#文档的官方译法为“实际参数”，简称“实参”，可理解为调用方法时的真实条件<br/> 调用方法时的argument列表要与定义方法时的parameter列表相匹配。[C#是强类型语言，argument是值、 parameter是变量，值与变量一定要匹配，不然编译器会报错]</p>
<pre><code>namespace CSharpMethodExample
{
    class Program
    {
        static void Main(string[] args)
        {
            Calculator c = new Calculator();
            double result = Calculator.GetCylinderVolume(3.0,4.0);
            Console.WriteLine(result);
        }
    }

    class Calculator
    {
        //自顶向下，逐步求精的算法
        public static double GetCircleArea(double r)   //方法头。方法1：求底部圆面积
        {
            return Math.PI * r * r;             //方法体
        }
        
        public static double GetCylinderVolume(double r, double h) //方法2：求圆柱体积
        {
            return GetCircleArea(r) * h;
        }

        public static double GetConeVolume(double r, double h)     //方法3：求圆锥体积
        {
            return  GetCylinderVolume(r,h) / 3;
        }
    }
}
</code></pre>
<p>3、构造器（一种特殊的方法）：<br/> （1）构造器（constructor）是类型的成员之一；[*类型成员：字段、方法、属性、事件…10多种]。<br/> （2）狭义构造器指的是“实例构造器”（instance constructor）:构建实例内部内存结构。<br/> （3）如何调用构造器：<br/> （4）声明构造器</p>
<pre><code>namespace ConstructorExample
{
    class Program
    {
        static void Main(string[] args)
        {
            //声明变量：Student stu，创建实例：new Student();其中“()”就在调用构造器
            Student stu = new Student(1, "Mr.Okay");
            Console.WriteLine(stu.ID);
            Console.WriteLine(stu.Name);
            Console.WriteLine("==================");
            Student stu2 = new Student();
            Console.WriteLine(stu2.ID);
            Console.WriteLine(stu2.Name);
        }
    }

    class Student
    {
        //*注：敲出“ctor”，然后敲击两次“Tab”键，就会直接生成构造器模板
        public Student()    //自定义一个构造器。函数名必须与类名完全一致。括号里面是参数列表，没有就空着。
        {
            this.ID = 1;                //this:指的是实例自己
            this.Name = "No name";
        }

        public Student(int initId, string initName)
        {
            this.ID = initId;
            this.Name = initName;
        }

        //创建两个公有的字段
        public int ID;          //默认构造器把ID和Name初始化为0。将内存里的对象里的字段初始化进行构造了
        public string Name;
    }
}
</code></pre>
<p>（5）构造器的内存原理<br/> 4、方法的重载：<br/> （1）调用重载方法的示例<br/> （2）声明带有重载的方法<br/> [1]方法签名（method signature）由方法的名称、类型形参的个数和它的每一个形象（按从左到右的顺序）的类 型和种类（值、引用或输出）组成。方法签名不包含返回类型。</p>
<pre><code>namespace OverloadExample
{
    class Program
    {
        static void Main(string[] args)
        {
        }
    }

    class Calculator
    {
        public int Add(int a, int b)        //（1）先创建一个方法
        {
            return a + b;
        }
        public int Add(ref int a,int b)     //参数的种类不同，方法签名就会不同，可以编译通过（ref int a：引用参数）
        {
            return a + b;
        }
        public int Add(out int a, int b)     //参数的种类不同，方法签名就会不同，可以编译通过（out int a：输出参数）
        {
            a = 100;
            return a + b;
        }
        public int Add(int a, int b, int c)     //参数数量不同，方法签名就会不同
        {
            return a + b + c;
        }
        public double Add(double a, double b)   //改参数的类型，方法签名不同，可以编译过去
        {
            return a + b;
        }
        public int Add&lt;T&gt;(int a, int b)     //多了一个类型形参，方法签名不同，可以编译过去。
        {                                   //&lt;T&gt;类型形参：里面的T代表将来会有一个类型参与到方法里来
            T t;    //声明一个t的变量...
            return a + b;
        }
    }
}
</code></pre>
<p>[2]实例构造函数签名由它的每一个形参（从左到右的顺序）的类型和种类（值、引用或输出）组成。<br/> [3]重载决策（到底调用哪一个重载）：用于在给定了参数列表和一组候选函数成员的情况下，选择一个最佳函数 成员来实施调用。在调用方法的时候，根据传递参数的类型来决定调用哪一个方法重载。</p>
<pre><code>namespace OverloadExample
{
    class Program
    {
        static void Main(string[] args)
        {
            Calculator c = new Calculator();
            double result = c.Add(100D,200D);   //根据里面传递的参数来决定选择哪一个方法重载
            Console.WriteLine(result);
        }
    }

    class Calculator
    {
        public int Add(int a, int b)        //（1）先创建一个方法
        {
            return a + b;
        }

        public int Add(int a, int b, int c)     //参数数量不同，方法签名就会不同
        {
            return a + b + c;
        }

        public double Add(double a, double b)   //改参数的类型，方法签名不同，可以编译过去
        {
            return a + b;
        }

        public int Add&lt;T&gt;(int a, int b)     //多了一个类型形参，方法签名不同，可以编译过去。
        {                                   //&lt;T&gt;类型形参：里面的T代表将来会有一个类型参与到方法里来
            T t;   		    //声明一个t的变量...
            return a + b;
        }
    }
}
</code></pre>
<p>5、如何对方法进行Debug<br/> （1）设置断点（breakpoint）；<br/> （2）观察方法调用时的call stack；<br/> call stack:调用堆栈<br/> 最顶层是当前所指方法，下一行是哪里调用这个方法的</p>
<p>（3）Step-in, Step-over, Step-out；<br/> Step-in:F11，逐句查看，小范围细致查找Bug；<br/> Step-over:F10,跳过过程直接到达结果处，快速大范围的定位Bug位置；<br/> Step-out:(shift+F11),回到调用这个方法的地方。<br/> （4）观察局部变量的值与变化；<br/> 在局部变量小窗口观察值；<br/> 也可以鼠标放到变量上进行查看。</p>
<p>6、方法的调用与栈（*难点）<br/> （1）方法调用时内存的分配<br/> 对stack frame的分析<br/> stack frame:当一个方法被调用时，在栈内存当中的布局。（谁调用，就谁负责压栈）</p>
<p>六、操作符<br/> 1、操作符概述<br/> （1）操作符（Operator）：也译为“运算符”。<br/> 操作符是用来操作数据的，被操作符操作的数据称为操作数（Operand）。<br/> 下表按照优先级进行排序：（由高到低）【*注意：数值提升】<br/> 类别 运算符<br/> 基本 x.y f(x) a[x] x++ x-- new typeof default checked unchecked delegate sizeof -&gt;<br/> 一元 + - ! ~ ++x --x (T)x await &amp;x <em>x<br/> 乘法 * / %<br/> 加减 + -<br/> 移位 &lt;&lt; &gt;&gt;<br/> 关系和类型检测 &lt; &gt; &lt;= &gt;= is as<br/> 相等 == !=<br/> 逻辑“与” &amp;<br/> 逻辑 XOR ^<br/> 逻辑 OR |<br/> 条件 AND &amp;&amp;<br/> 条件 OR ||<br/> Null 合并 ??<br/> 条件 ?:<br/> 赋值和lambda = <em>= /= %= += -= &lt;&lt;= &gt;&gt;= &amp;= ^= |= =&gt;<br/> 2、操作符的本质<br/> （1）操作符的本质是函数（即算法）的“简记法”。<br/> 假如没有发明“+”、只有Add函数，算法3+4+5将可以写成Add(Add(3,4),5)；<br/> 假如没有发明“</em>”、只有Mul函数，算法3+4</em>5将可以写成Add(3,Mul(4,5))，注意优先级。<br/> （2）操作符不能脱离与它关联的数据类型<br/> 可以说操作符就是与固定数据类型相关联的一套基本算法的“简记法”。<br/> 实例：为自定义数据类型创建操作符。</p>
<pre><code>namespace CreatorOperatpr
{
    class Program
    {
        static void Main(string[] args)
        {
            Person person1 = new Person();
            Person person2 = new Person();
            person1.Name = "Deer";
            person2.Name = "Deer's wife";
            List&lt;Person&gt; nation = Person.GetMarry(person1,person2);
            foreach (var p in nation)
            {
                Console.WriteLine(p.Name);
            }
        }
    }

    class Person
    {
        public string Name;

        public static List&lt;Person&gt; GetMarry(Person p1, Person p2)   //List&lt;Person&gt;:返回值，返回一组Person
        { 
            List&lt;Person&gt; people = new List&lt;Person&gt;();
            people.Add(p1);
            people.Add(p2);
            for (int i = 0; i &lt; 11; i++)
			{
                Person child = new Person();
                child.Name = p1.Name + "&amp;" + p2.Name+"'s child";
                people.Add(child);
			}
            return people;
        }
    }
}
</code></pre>
<p>3、操作符的优先级<br/> （1）可以使用圆括号提高被括起来表达式的优先级；<br/> （2）圆括号可以嵌套；<br/> （3）不像数学里有方括号和花括号，在C#语言中“[]”与“{}”有专门的用途。<br/> []：访问索引器<br/> {}：名称空间、类空间、方法的body<br/> 4、同级操作符的运算顺序<br/> （1）除了带有赋值功能的操作符，同优先级操作符都由左向右进行运算；<br/> （2）带有赋值功能的操作符的运算顺序是由右向左；</p>
<pre><code>namespace OperatorPriority
{
    class Program
    {
        static void Main(string[] args)
        {
            int x = 100;
            int y = 200;
            int z = 300;
            x += y += z;
            Console.WriteLine(x);   //600
            Console.WriteLine(y);   //500
            Console.WriteLine(z);   //300
        }
    }
}
</code></pre>
<p>（3）与数学运算不同，计算机语言的同优先级运算没有“结合律”；<br/> 3+4+5只能理解为Add(Add(3,4),5)不能理解为Add(3,Add(4,5))。</p>
<p>5、基本操作符<br/> （1）表达式：表达一定算数意图的式子。基本表达式就是不能再拆分的表达式。 <br/> （2）x.y：”.”叫做成员访问操作符，<br/> 功能：能够访问外层命名空间中的子级命名空间，<br/> 能访问名称空间中的类型，<br/> 能访问类型的静态成员，<br/> 能访问对象的成员。</p>
<pre><code>namespace OperatorExample
{
    class Program
    {
        static void Main(string[] args)
        {
            System.IO.File.Create("D:\\HelloWorld.txt");    //外层命名空间.子级命名空间.类.静态成员
        }
    }
}

namespace OperatorExample
{
    class Program
    {
        static void Main(string[] args)
        {
            Form myForm = new Form();       //创建对象并赋给myForm
            myForm.Text = "Hello world!";   //使用myForm的属性TEXT
            myForm.ShowDialog();            //使用ShowDialog方法
        }
    }
}
</code></pre>
<p>（3）f(x):方法调用操作符，里面的x是参数</p>
<pre><code>namespace OperatorsExample
{
    class Program
    {
        static void Main(string[] args)
        {
            Calculator c = new Calculator();
            Action myAction = new Action(c.PrintHello);     //委托
            myAction();                 //Hello

            double x = c.Add(3.0,4.0);
            Console.WriteLine(x);       //8
        }
    }

    class Calculator
    {
        public double Add(double a, double b)
        {
            return a + b;
        }

        public void PrintHello()
        {
            Console.WriteLine("Hello");
        }
    }
}
</code></pre>
<p>（4）a[x]：元素访问操作符，访问元素</p>
<pre><code>namespace OperatorsExample
{
    class Program
    {
        static void Main(string[] args)
        {
            int[] myIntArray = new int[5]{1,2,3,4,5};   //创建一个数组
            Console.WriteLine(myIntArray[0]);           //输出数组第一个数
            Console.WriteLine(myIntArray[4]);           //输出第五个
            Console.WriteLine(myIntArray[myIntArray.Length - 1]);   //永远不会超出边界
        }
    }
}

namespace OperatorsExample
{
    class Program
    {
        static void Main(string[] args)
        {
            //string:当作索引类型，Student：当作值类型
            Dictionary&lt;string, Student&gt; stuDic = new Dictionary&lt;string,Student&gt;();        //带有尖括号的，叫做泛型类：泛型类不是完整的类，必须要和其他类型组合在一起，才是完整的类
            for (int i = 1; i &lt; 100; i++)
            {
                Student stu = new Student();
                stu.Name = "s_" + i.ToString();
                stu.Score = 100 + i;
                stuDic.Add(stu.Name, stu);      //stu.Name：当作索引，stu当作值
            }
            Student number6=stuDic["s_6"];      //元素访问操作符，[]中放的是集合的索引，这个索引不一定都是整数
            Console.WriteLine(number6.Score);
        }
    }

    class Student
    {
        public string Name;
        public int Score;
    }
}
</code></pre>
<p>（5）自增自减：x++,x–:<br/> namespace OperatorsExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> int x;<br/> int y;<br/> x = 100;<br/> y = x++; //首先x的值赋给y，x再减1：y=x,x=x-1<br/> Console.WriteLine(x); //101<br/> Console.WriteLine(y); //100<br/> }<br/> }<br/> }<br/> （6）Typeof：查看一个类型的内部结构（Metadata）<br/> namespace OperatorsExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> Type t = typeof(int);<br/> Console.WriteLine(t.Namespace);<br/> Console.WriteLine(t.FullName);<br/> Console.WriteLine(t.Name);<br/> //查看int有多方法:<br/> int c = t.GetMethods().Length;<br/> foreach (var mi in t.GetMethods())<br/> {<!-- --><br/> Console.WriteLine(mi.Name);<br/> }<br/> Console.WriteLine©;<br/> }<br/> }<br/> }<br/> （7）default：<br/> namespace OperatorsExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> int x = default(int); //如果default发现操纵的是结构体类型的话，就会返回内存块为0的值<br/> Console.WriteLine(x); //0</p>
<pre><code>        Form myForm = default(Form);    //default发现操作的是引用类型时，会返回null（空值）
        Console.WriteLine(myForm==null);    //TRUE

        Level level=default(Level);     //当枚举里面没赋值时，返回第一个，赋值后返回最小的。
        Console.WriteLine(level);
    }
}

enum Level      //声明一个枚举类型：设计枚举类型的时候，最好设计一个为0
</code></pre>
<p>{<!-- --><br/> Low = 1,<br/> Mid = 1,<br/> High = 2<br/> }<br/> }<br/> （8）NEW：在内存当中帮助我们创建实例，并且调用实例构造器，可以把这个实例的内存地址赋值给变量。<br/> 如：new Form(); //创建实例构造器</p>
<p>namespace OperatorsExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> int a = 100; //int:显式变量<br/> var x = 100; //var:隐式变量；赋值为int类型<br/> var y = 100L; //赋值为INT64<br/> var z = 100D; //double类型<br/> z = “100”; //z已经定义为double类型了，不能赋值string类型的数据<br/> Console.WriteLine(a.GetType().Name);<br/> Console.WriteLine(x.GetType().Name);<br/> Console.WriteLine(y.GetType().Name);<br/> Console.WriteLine(z.GetType().Name);<br/> }<br/> }<br/> }</p>
<p>namespace OperatorsExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> //new调用初始化器和构造器<br/> Form myForm = new Form() { Text = “Hello”, FormBorderStyle=FormBorderStyle.SizableToolWindow }; //调用初始化器<br/> //Form myForm = new Form() 调用构造器<br/> //myForm.Text = “Hello”;<br/> myForm.ShowDialog();</p>
<pre><code>        /*可以执行。new和.操作符的优先级相同，从左至右运算。先创建实例并调用构造器，再引用ShowDialog()方法。
            只是没用变量引用这个实例，很快就被垃圾收集器回收了。
         */
        new Form() { Text = "Hello"}.ShowDialog();

        int x = 100;
        string y = "time";
        string name = new string();

        //
        int[] myArray = new int[10];
        int[] myArray1 = { 1, 2, 3, 4 };    //不用NEW操作符。这是语法糖衣，在创建某些实例时可以使用new操作符，也可以不用
    }
}
</code></pre>
<p>}</p>
<p>namespace OperatorsExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> /<em>var和new联用，为匿名类型创建对象，并且用隐式类型变量来引用实例</em>/<br/> var myForm = new Form() { Text = “Hello”}; //Program类和Form形成了紧耦合。Form如果有问题，那么这个类就会出问题。<br/> var person = new { Name = “Mr.Okay”, Age = 34 }; //不知道对象是什么类型<br/> Console.WriteLine(person.Name);<br/> Console.WriteLine(person.Age);<br/> Console.WriteLine(person.GetType().Name);<br/> }<br/> }<br/> }</p>
<p>namespace OperatorsExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> Student stu = new Student(); //这里的 new 是操作符<br/> stu.Report();<br/> CsStudent csStu = new CsStudent();<br/> csStu.Report();<br/> }<br/> }</p>
<pre><code>class Student
{
    public void Report()
    {
        Console.WriteLine("I'm a student.");
    }
}

class CsStudent:Student
{
    /*
     * 如果类里面什么都不写，它就自动继承了父类所有的内容
     */
    new public void Report()    //子类对父类的方法进行隐藏。  这里的new是修饰符。
    {
        Console.WriteLine("I'm a csStudent.");  //子类对父类的方法进行隐藏
    }
}
</code></pre>
<p>}</p>
<p>（9）checked和unchecked：检查一个值在内存中是否有溢出。<br/> namespace OperatorsExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> uint x = uint.MaxValue;<br/> Console.WriteLine(x);<br/> string binStr = Convert.ToString(x, 2); //32位的二进制表示<br/> Console.WriteLine(binStr);<br/> //uint y = x + 1; //超过最大值，溢出归零<br/> //uint y = checked(x + 1); //使用checked检测是否溢出<br/> //Console.WriteLine(y);</p>
<pre><code>        //try
        //{
        //    uint y = checked(x + 1);  //使用checked检测是否溢出。使用unchecked就不会抛出溢出异常
        //    Console.WriteLine(y);
        //}
        //catch (OverflowException ex)
        //{
        //    Console.WriteLine("There's overflow!!!");
        //}

        checked
        {
            try
            {
                uint y = checked(x + 1);
                Console.WriteLine(y);
            }
            catch (OverflowException ex)
            {
                Console.WriteLine("There's overflow!!!");
            }
        }
    }
}
</code></pre>
<p>}</p>
<p>（10）delegate操作符：（delegate也是一个关键字，委托）<br/> namespace Example<br/> {<!-- --><br/> /// <br/> /// MainWindow.xaml 的交互逻辑<br/> /// <br/> public partial class MainWindow : Window<br/> {<!-- --><br/> public MainWindow()<br/> {<!-- --><br/> InitializeComponent();<br/> //通过+=挂接了一个事件处理器myButton_Click</p>
<pre><code>        //this.myButton.Click += myButton_Click;
        //void myButton_Click(object sender, RoutedEventArgs e)     //1、有名字的函数
        //{
        //    throw new NotImplementedException();
        //}

        //this.myButton.Click += delegate(object sender, RoutedEventArgs e)   //2、delegate操作符声明匿名方法，没名字（过时技术）
        //{
        //    this.myTextBox.Text = "Hello,World!";
        //};  

        this.myButton.Click += (object sender, RoutedEventArgs e) =&gt;   //3、拉姆达表达式，没名字（现在常用）
        {
            this.myTextBox.Text = "Hello,World!";
        };  
    }
}
</code></pre>
<p>}</p>
<p>（11）sizeof操作符：获取一个对象在内存当中的所占字节数的尺寸。<br/> 注意：1、默认情况下，只能用于去获取基本数据类型它们的实例在内存当中所占的字节数<br/> 基本数据类型：C#关键字里面的结构体数据类型，除了string，object不是结构体，就不能获取；<br/> 像uint,long,ulong,double等就可以使用。<br/> 2、在非默认的情况下，我们可以使用sizeof获取自定义的结构体类型的实例在内存当中占的字节数，<br/> 但是需要放在不安全的上下文当中。<br/> namespace OperatorsExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> int z = sizeof(int);<br/> int x = sizeof(decimal); //decinal：16字节，比double更加精准，常用在金融计算中<br/> Console.WriteLine(z);<br/> Console.WriteLine(x);</p>
<pre><code>        unsafe
        {
            int y = sizeof(Student);    //sizeof获取自定义结构体中的字节数，需要放在不安全上下文当中
            Console.WriteLine(y);
        }
    }
}

struct Student
{
    int ID;
    long Score;
}
</code></pre>
<p>}</p>
<p>（12）-&gt;：直接操作内存，需要放在不安全的上下文当中。（像指针操作、取地址操作、指针访问成员操作，只能用来操作结构体类型，不能操作引用类型）<br/> namespace OperatorsExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> unsafe<br/> {<!-- --><br/> Student stu;<br/> stu.ID = 1; //.：直接访问<br/> stu.Score = 99; //直接访问<br/> Student* pStu = &amp;stu;<br/> pStu-&gt;Score = 100; //-&gt;:通过指针的间接访问<br/> Console.WriteLine(stu.Score);<br/> }<br/> }<br/> }</p>
<pre><code>struct Student
{
    public int ID;
    public long Score;
}
</code></pre>
<p>}</p>
<p>6.一元操作符<br/> （1）&amp;x：取地址操作符，需要在不安全上下文中<br/> <em>x：取引用符号，需要在不安全上下文中<br/> namespace OperatorsExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> unsafe<br/> {<!-- --><br/> Student stu;<br/> stu.ID = 1; //.：直接访问<br/> stu.Score = 99; //直接访问<br/> Student</em> pStu = &amp;stu; //取地址，&amp;取地址给指针<br/> pStu-&gt;Score = 100; //-&gt;:通过指针的间接访问<br/> (<em>pStu).Score = 1000; //</em>：取引用<br/> Console.WriteLine(stu.Score);<br/> }<br/> }<br/> }</p>
<pre><code>struct Student
{
    public int ID;
    public long Score;
}
</code></pre>
<p>}</p>
<p>（2）+ - ！ ~：正 负 非 反<br/> namespace OperatorsExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> Console.WriteLine(int.MaxValue); //2147483647<br/> Console.WriteLine(int.MinValue); //-2147483648</p>
<pre><code>        int x = int.MinValue; 	  
        int y = checked(-x);    //已经溢出
        Console.WriteLine(x);
        Console.WriteLine(y);
    }
}
</code></pre>
<p>}</p>
<p>namespace OperatorsExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> int x = int.MinValue;<br/> int y = -x;<br/> Console.WriteLine(y); //-2147483648<br/> string xStr = Convert.ToString(x, 2).PadLeft(32, ‘0’);<br/> Console.WriteLine(xStr); //10000000000000000000000000000000<br/> }<br/> }<br/> }</p>
<p>namespace OperatorsExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> int x = 12345678;<br/> int y = ~x; //取反，-12345679<br/> string xStr = Convert.ToString(x, 2).PadLeft(32, ‘0’);<br/> string yStr = Convert.ToString(y, 2).PadLeft(32, ‘0’);<br/> Console.WriteLine(xStr); //00000000101111000110000101001110<br/> Console.WriteLine(yStr); //11111111010000111001111010110001<br/> }<br/> }<br/> }</p>
<p>namespace OperatorsExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> bool b1 = true;<br/> bool b2 = !b1; //!:非操作符，！true=false<br/> Console.WriteLine(b2);<br/> }<br/> }<br/> }</p>
<p>namespace OperatorsExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> Student stu = new Student(null);<br/> Console.WriteLine(stu.Name);<br/> }<br/> }</p>
<pre><code>class Student
{
    public string Name;

    public Student(string initName)
    {
        if (!string.IsNullOrEmpty(initName))
        {
            this.Name = initName;
        }
        else
        {
            throw new ArgumentException("initName cannot be null or empty.");
        }
    }
}
</code></pre>
<p>}</p>
<p>（3）x++,x–:自增自减，尽量单独使用它们，它们的可读性很差<br/> namespace OperatorsExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> int x = 100;<br/> –x; //99<br/> x–; //99<br/> ++x; //101<br/> x++; //101<br/> int y = x–; //x=99,y=100<br/> int y = --x; //x=99,y=99<br/> Console.WriteLine(x);<br/> }<br/> }<br/> }</p>
<p>（4）(T)x，await：<br/> 类型转换：<br/> （1）隐形(implicit)类型转换<br/> [1]不丢失精度的转换<br/> 从sbyte 到short、int、long、float、double或decimal。<br/> 从byte 到short、ushort、int、uint、long、ulong、float、double或decimal。<br/> 从short 到int、long、float、double或decimal。<br/> 从ushort 到int、uint、long、ulong、float、double或decimal。<br/> 从int 到long、float、double或decimal。<br/> 从uint 到long、ulong、float、double或decimal。<br/> 从long 到float、double或decimal。<br/> 从ulong 到float、double或decimal。<br/> 从char 到ushort、int、uint、long、ulong、float、double或decimal。<br/> 从float 到double。<br/> 从int、uint、long或ulong到float的转换以及从long或ulong到double的转换可能导致精度损失，但绝不会影响数值大小。 其他的隐式数值转换绝不会丢失任何信息。<br/> 不存在向char类型的隐式转换，因此其他整形的值不会自动转换为char类型。</p>
<p>namespace OperatorsExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> int x = int.MaxValue;<br/> long y = x; //不丢失精度的类型转换<br/> Console.WriteLine(y);<br/> }<br/> }<br/> }<br/> [2]子类向父类转换（所有的面向对象语言都支持这个转换）<br/> namespace OperatorsExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> /*<br/> 子类向父类的隐形转换，teacher-&gt;Human-&gt;Animal<br/> */<br/> Teacher t = new Teacher();<br/> t.Eat();<br/> t.Think();<br/> t.Teach();</p>
<pre><code>        Human h = t;
        h.Eat();
        h.Think();

        Animal a = h;
        a.Eat();
    }
}

class Animal
{
    public void Eat()
    {
        Console.WriteLine("Eating...");
    }
}

class Human:Animal 
{
    public void Think()
    {
        Console.WriteLine("Who i am?");
    }
}

class Teacher:Human
{
    public void Teach()
    {
        Console.WriteLine("I teaching .");
    }
}
</code></pre>
<p>}<br/> [3]装箱<br/> （2）显式(explicit)类型转换<br/> [1]有可能丢失精度（甚至发生错误）的转换，即cast<br/> 显示数值转换是指从一个numeric-type到另一个numeric-type的转换，此转换不能已知的隐式数值转换实现，它包括：<br/> 从sbyte到byte、ushort、uint、ulong或char。<br/> 从byte到sbyte和char。<br/> 从short到sbyte、byte、ushort、uint、ulong或char。<br/> 从ushort到sbyte、byte、short或char。<br/> 从int到sbyte、byte、short、ushort、uint、ulong或char。<br/> 从uint到sbyte、byte、short、ushort、int或char。<br/> 从long到sbyte、byte、short、ushort、int、uint、ulong或char。<br/> 从ulong到sbyte、byte、short、ushort、int、uint、long或char。<br/> 从char到sbyte、byte或short。<br/> 从float到sbyte、byte、short、ushort、int、uint、long、ulong、char或decimal。<br/> 从double到sbyte、byte、short、ushort、int、uint、long、ulong、char、float或decimal。<br/> 从decimal到sbyte、byte、short、ushort、int、uint、long、ulong、char、float或double。<br/> 由于显示转换包括隐式或显示数值转换，因此总是可以使用强制转换表达式从任何numeric-type转换为任何其他的numeric-type。<br/> [2]拆箱<br/> [3]使用Covert类<br/> [4]ToString方法与各种数据类型的Parse/TryParse方法<br/> namespace Convert<br/> {<!-- --><br/> /// <br/> /// MainWindow.xaml 的交互逻辑<br/> /// <br/> public partial class MainWindow : Window<br/> {<!-- --><br/> public MainWindow()<br/> {<!-- --><br/> InitializeComponent();<br/> }</p>
<pre><code>    private void btn_Click(object sender, RoutedEventArgs e)
    {
        //double x = System.Convert.ToDouble(tb1.Text);
        //double y = System.Convert.ToDouble(tb2.Text);
        double x = double.Parse(this.tb1.Text);
        double y = double.Parse(this.tb2.Text);
        double result = x + y;
        //this.tb3.Text = System.Convert.ToString(result);
        this.tb3.Text = result.ToString();                    
    }
}
</code></pre>
<p>}<br/> （3）自定义类型转换操作符<br/> namespace ConversionExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> Stone stone = new Stone();<br/> stone.Age = 5000;<br/> Monkey wukongSun = (Monkey)stone; //显式类型转换（变成隐式类型转换：删去“(Monkey)”）<br/> Console.WriteLine(wukongSun.Age);<br/> }<br/> }</p>
<pre><code>class Stone
{
    public int Age;

    //显示类型转换操作符 就是一个目标类型实例的构造器，写在被转换的类中
    //explicit:显式类型转换;  operator:因为是操作符，需要加上这个关键字（变成隐式类型转换：explicit改为implicit）
    public static explicit operator Monkey(Stone stone)     
    {
        Monkey m = new Monkey();
        m.Age = stone.Age / 500;
        return m;
    }
}

class Monkey
{
    public int Age;
}
</code></pre>
<p>}</p>
<p>（5）* / % + -：（算数运算符）<br/> [1]*左右两边的类型为整型时，就是整型乘法<br/> int operator *(int x, int y);<br/> uint operator *(uing x, uing y);<br/> long operator *(long x, long y);<br/> ulong operator *(ulong x,);<br/> [2]*左右两边的类型为浮点型时，就是浮点乘法<br/> float operator *(float x,float y);<br/> double operator <em>(double x,double y);<br/> 下表列出了非零有限制、零、无穷大、和NaN（not a number）的可能组合结果。x和y是正有限制，z是x</em>y的结果。如果结果对目标类型而言太大，则z为无穷大，反之则无穷小。<br/> +y -y +0 -0 +∞ -∞ NaN<br/> +x +z -z +0 -0 +∞ -∞ NaN<br/> -x -z +z -0 +0 -∞ +∞ NaN<br/> +0 +0 -0 +0 -0 NaN NaN NaN<br/> -0 -0 +0 -0 +0 NaN NaN NaN<br/> +∞ +∞ -∞ NaN NaN +∞ -∞ NaN<br/> -∞ -∞ +∞ NaN NaN -∞ +∞ NaN<br/> NaN NaN NaN NaN NaN NaN NaN NaN</p>
<pre><code>[3]小数（金融）乘法
	decimal operator *(decimal x, decimal y);
如果结果值太小，不能用decimal格式表示，则将引发Systems.OverflowException。如果结果值太小，无法用decimal格式表示，则结果为零。在进行任何舍入之前，结果的小数位数是两个操作数的小数位数的和。
[4]整数除法：
	int operator /(int x, int y);
	uint operator /(uint x, uint y);
	long operator /(long x, long y);
	ulong operator /(ulong x,ulong y);
如果右操作数的值为零，则引发System.DivideByZeroException异常。
除法将结果舍入到零。因此，结果的绝对值是小于或等于两个操作数的商的绝对值的最大可能整数。当两个操作数符号相同时，结果为零或正；当两个操作数符号相反时，结果为零或负。
如果左操作数为最小可表示int或long值，右操作数为-1，则发生溢出。在checked上下文中，这会导致引发System.ArithmeticException（或其子类）。在unchecked上下文中，它由实现定义为或者引发System. ArithmeticException（或其子类）,或者不以左操作数的结果值报告溢出。
[5]浮点除法：
	float operator /(float x, float y);
	double operator /(double x, double y);
下表列出了非零有限制、零、无穷大和NaN的所有可能组合的结果。在该表中，x和y是正有限值，z是x/y的结果。如果结果对目标类型而言太小，则z为无穷大。如果结果对目标类型而言太小，则z为零。
+y	-y	+0	-0	+∞	-∞	NaN
</code></pre>
<p>+x +z -z +∞ -∞ +0 -0 NaN<br/> -x -z +z -∞ +∞ -0 +0 NaN<br/> +0 +0 -0 NaN NaN +0 -0 NaN<br/> -0 -0 +0 NaN NaN -0 +0 NaN<br/> +∞ +∞ -∞ +∞ -∞ NaN NaN NaN<br/> -∞ -∞ +∞ -∞ +∞ NaN NaN NaN<br/> NaN NaN NaN NaN NaN NaN NaN NaN</p>
<pre><code>[6]小数除法：
	decimal operator /(decimal x, decimal y);
如果右操作数的值为零，则引发System.DivideByZeroException异常。如果结果值太大，不能用decimal格式表示，则将引发System.OverflowException。如果结果值太小，无法用decimal格式表示，则结果为零。结果的小数位数是最小的小数位数，它保留等于最接近真实算数结果的可表示小数值的结果。小数除法等效于使用System.Decimal类型的除法运算符。
[7]整数余数：
	int operator %(int x, int y);
	uint operator %(uint x, uint y);
	long operator %(long x, long y);
	ulong operator %(ulong x, ulong y);
x % y的结果是由x-(x/y)*y生成的值。如果y为零，则将引发System.DivideByZeroException异常。
如果左侧的操作数是最小的int或long值，且右侧的操作数是-1，将引发System.OverflowException。只有x % y不引发异常，x / y也不会引发异常。
[8]浮点余数：
	float operator %(float x, float y);
	double operator %(double x, double y);
下表列出了非零有限值、零、无穷大和NaN的所有可能组合的结果。在该表中，x和y是有限的正值。z是x%y的结果，按照     x – n * y进行计算，其中n是小于或等于x/y的最大可能整数。这种计算余数的方法类似于用于整数操作数的方法。
+y	-y	+0	-0	+∞	-∞	NaN
</code></pre>
<p>+x +z +z NaN NaN x x NaN<br/> -x -z -z NaN NaN -x -x NaN<br/> +0 +0 +0 NaN NaN +0 +0 NaN<br/> -0 -0 -0 NaN NaN -0 -0 NaN<br/> +∞ NaN NaN NaN NaN NaN NaN NaN<br/> -∞ NaN NaN NaN NaN NaN NaN NaN<br/> NaN NaN NaN NaN NaN NaN NaN NaN</p>
<pre><code>[9]小数余数：
decimal operator %(decimal x, decimal y);
如果右操作数为零，则引发System.DivideByZeroException异常。在进行任何舍入之前，结果的小数位数是两个操作数中较大的小数位数，而且结果的符号与x的相同（如果非零）。
[10]整数加法：
int operator +(int x, int y);
uint operator +(uint x, uint y);
long operator +(long x, long y);
ulong operator +(ulong x, ulong y);
[11]浮点加法
float operator +(float x, float y);
double operator +(double x, double y);
y	+0	-0	+∞	-∞	NaN
</code></pre>
<p>x z x x +∞ -∞ NaN<br/> +0 y +0 +0 +∞ -∞ NaN<br/> -0 y +0 -0 +∞ -∞ NaN<br/> +∞ +∞ +∞ +∞ +∞ NaN NaN<br/> -∞ -∞ -∞ -∞ NaN -∞ NaN<br/> NaN NaN NaN NaN NaN NaN NaN</p>
<pre><code>[12]小数加法：
decimal operator +(decimal x, decimal y);
[13]整数减法：
int operator -(int x, int y);
uint operator -(uint x, uint y);
long operator -(long x, long y);
ulong operator -(ulong x, ulong y);
[14]浮点减法：
float operator -(float x, float y);
double operator -(double x, double y);
y	+0	-0	+∞	-∞	NaN
</code></pre>
<p>x z x x -∞ +∞ NaN<br/> +0 -y +0 +0 -∞ +∞ NaN<br/> -0 -y -0 +0 -∞ +∞ NaN<br/> +∞ +∞ +∞ +∞ NaN +∞ NaN<br/> -∞ -∞ -∞ -∞ -∞ NaN NaN<br/> NaN NaN NaN NaN NaN NaN NaN</p>
<pre><code>[15]小数减法：
decimal operator +(decimal x, decimal y);
</code></pre>
<p>（6）&lt;&lt; &gt;&gt;:左位移，右位移。左移是把数乘2，右移是把数除2。<br/> namespace ConversionExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> int x = 7;<br/> int y = x &lt;&lt; 2;<br/> string strX = Convert.ToString(x, 2).PadLeft(32, ‘0’);<br/> string strY = Convert.ToString(y, 2).PadLeft(32, ‘0’);<br/> Console.WriteLine(strX);<br/> Console.WriteLine(strY);<br/> }<br/> }<br/> }</p>
<p>（7）关系操作符：<br/> 关系和类型检测："&lt; &gt; &lt;= &gt;=" “is as”<br/> 相等: == !=</p>
<p>namespace ConversionExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> int x = 5;<br/> double y = 4.0;<br/> var result = x &gt; y;<br/> Console.WriteLine(result.GetType().FullName); //System.Boolean<br/> Console.WriteLine(result); //TRUE<br/> }<br/> }<br/> }</p>
<p>namespace ConversionExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> char char1 = ‘a’;<br/> char char2 = ‘A’;<br/> ushort u1 = (ushort)char1; //97<br/> ushort u2 = (ushort)char2; //65<br/> Console.WriteLine(u1);<br/> Console.WriteLine(u2);</p>
<pre><code>        var result = char1 &gt; char2;     //true
        Console.WriteLine(result);
    }
}
</code></pre>
<p>}</p>
<p>namespace ConversionExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> { <br/> string str1 = “abc”;<br/> string str2 = “Abc”;<br/> Console.WriteLine(str1==str2);<br/> }<br/> }<br/> }</p>
<p>namespace ConversionExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> object o = new Teacher();<br/> //if (o is Teacher)<br/> //{<!-- --><br/> // Teacher t = new Teacher();<br/> // t.Teach();<br/> //}</p>
<pre><code>        Teacher t = o as Teacher;
        if (t!=null)
        {
            t.Teach();
        }
    }
}

class Animal
{
    public void Eat()
    {
        Console.WriteLine("Eating...");
    }
}

class Human : Animal
{
    public void Think()
    {
        Console.WriteLine("Who i am?");
    }
}

class Teacher : Human
{
    public void Teach()
    {
        Console.WriteLine("I teaching .");
    }
}

class Car
{
    public void Run()
    {
        Console.WriteLine("Runing...");
    }
}
</code></pre>
<p>}</p>
<p>（8）逻辑运算符：<br/> &amp; ：与。 ^ : XOR。 | ：OR。<br/> namespace ConversionExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> //按位求与<br/> int x = 23;<br/> int y = 35;<br/> int z = x &amp; y;<br/> string strX = Convert.ToString(x, 2).PadLeft(32, ‘0’);<br/> string strY = Convert.ToString(y, 2).PadLeft(32, ‘0’);<br/> string strZ = Convert.ToString(z, 2).PadLeft(32, ‘0’);<br/> Console.WriteLine(strX);<br/> Console.WriteLine(strY);<br/> Console.WriteLine(strZ);<br/> }<br/> }<br/> }<br/> （9）条件运算符：<br/> &amp;&amp;：AND。 ||：OR。<br/> namespace ConversionExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> //按位求与<br/> int x = 23;<br/> int y = 35;<br/> int a = 3;<br/> if (x&gt;y &amp;&amp; ++a&gt;3) //||:或的左边为true，就不会运行右边。&amp;&amp;：左边为false，右边就不会运行。（这叫短路效应，要避开）<br/> {<!-- --><br/> Console.WriteLine(“Hello”);<br/> }<br/> Console.WriteLine(a);<br/> }<br/> }<br/> }<br/> （10）??（null合并）<br/> namespace ConversionExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> Nullable x = null; //可空类型，可以赋值null<br/> x = 100;<br/> //int? x = 100; //可空类型<br/> //Console.WriteLine(x);<br/> //Console.WriteLine(x.HasValue); //输出是否有值</p>
<pre><code>        int? x = null;          //x为空
        int y = x ?? 1;         //如果x为空，就返回1
        Console.WriteLine(y);
    }
}
</code></pre>
<p>}<br/> （11）? :（条件操作符，接受三个参数）<br/> namespace ConversionExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> st atic void Main(string[] args)<br/> {<!-- --><br/> int x = 80;<br/> string str = (x &gt;= 60) ? “Pass” : “Failed”; //if…else…的简写<br/> Console.WriteLine(str);<br/> }<br/> }<br/> }<br/> （12）= *= /= %= += -= &lt;&lt;= &gt;&gt;= &amp;= ^= |= =&gt; (赋值和lambda表达式)<br/> （***赋值操作符是从右向左）<br/> namespace ConversionExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> int x = 5;<br/> x += 1;<br/> Console.WriteLine(x);</p>
<pre><code>        int y = 4;
        y &lt;&lt;= 2;    //左移两位，变成2的4次方
        Console.WriteLine(y);
    }
}
</code></pre>
<p>}</p>
<p>namespace ConversionExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> int x = 10;<br/> int y = 6;<br/> int z = 7;<br/> int a = x += y *= z; //从右向左运算<br/> Console.WriteLine(a);<br/> }<br/> }<br/> }<br/> 七、表达式和语句<br/> 1、表达式的定义<br/> （1）什么是表达式：表达式是基本组件之一，而且是最重要的组件。<br/> 表达式是语法实体，专门用来求值。<br/> （2）C#语言对表达式的定义：<br/> [1]表达式求值完后的结果为single value（单值）,object（对象）,method（方法）,or namespace（命名空间） 这四类值。<br/> [2]表达式可能由字面值、方法调用、操作符操作数、简单的名字。<br/> 简单的名字可能是变量、类型的成员、方法的参数、命名空间或类型名。<br/> [3]表达式是算法逻辑的最基本（最小）单元，表达一定的算法意图。<br/> [4]因为操作符有优先级，所以表达式也就有了优先级。<br/> 2、各式表达式概览<br/> （1）C#语言中表达式的分类：<br/> [1]A value.任何能得到值的运算（回顾操作符和结果类型）<br/> Every value has an associated type.每个值都要有自己的类型。<br/> 表达式经过运算得出来的值的数据类型，就是这个表达式的数据类型。<br/> namespace ConversionExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> var x = 3 &lt; 5;<br/> if (x) //其中 3&lt;5 就是布尔类型的表达式<br/> {<!-- --><br/> Console.WriteLine(“OK”);<br/> }<br/> Console.WriteLine(x.GetType().FullName); //System.Boolean。输出x的类型，发现x为布尔类型的值<br/> }<br/> }<br/> }<br/> [2]A variable.一个变量。<br/> Every variable has an associated type.<br/> static void Main(string[] args)<br/> {<!-- --><br/> int x = 100;<br/> int y;<br/> y = x;<br/> }<br/> [3]A namespace.一个命名空间<br/> static void Main(string[] args)<br/> {<!-- --><br/> System.Windows.Forms.Form myForm; //System、Windows、Forms三个命名空间都访问方法，这三个都是表达式<br/> }<br/> [4]A type.一个类型<br/> static void Main(string[] args)<br/> {<!-- --><br/> var t = typeof(Int32); //int32是typeof的操作数，因此typeof就是表达式<br/> }<br/> [5]A method group.例如：Console.WriteLine，这是一组方法，重载决策决定具体调用哪一个<br/> static void Main(string[] args)<br/> {<!-- --><br/> Console.WriteLine(“Hello,world!”); //Console.WriteLine():会访问一组方法，等输入"Hello,world!"才知道调用哪个<br/> }<br/> [6]A null literal.<br/> static void Main(string[] args)<br/> {<!-- --><br/> Form myForm = null; //null就是一个表达式，表示空，不是数据类型<br/> int x = 100;<br/> }<br/> [7]An anonymous function.匿名方法<br/> static void Main(string[] args)<br/> {<!-- --><br/> Action a = delegate() { Console.WriteLine(“Hello,world”); }; //匿名方法表达式，返回值就是一个委托<br/> a();<br/> }<br/> [8]A property access.属性访问<br/> static void Main(string[] args)<br/> {<!-- --><br/> Form myForm = new Form();<br/> myForm.Text = “Hello”; //myForm.Text:成员访问表达式，调用属性Text<br/> myForm.ShowDialog();<br/> }<br/> [9]An event access.访问某个对象的事件<br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> Form myForm = new Form();<br/> myForm.Text = “Hello”; //myForm.Text:成员访问表达式，调用属性Text<br/> myForm.Load += myForm_Load; //myForm.Load：访问load事件<br/> myForm.ShowDialog();<br/> }</p>
<pre><code>    static void myForm_Load(object sender, EventArgs e)
    {
        Form form = sender as Form;
        if (form ==null)
        {
            return;
        }
        form.Text = "New Title";
    }
}
[10]An indexer access.访问索引器
    static void Main(string[] args)
    {
        List&lt;int&gt; intList = new List&lt;int&gt;(){ 1, 2, 3 };
        int x = intList(2);
    }
[11]Nothing.对返回值为void的方法的调用
    static void Main(string[] args)
    {
        Console.WriteLine("Hello");   //不返回任何值
    }
</code></pre>
<p>（2）复合表达式的求值<br/> 注意操作符的优先级和同优先级操作符的运算方向<br/> 复合表达式是由一些小的表达式组成的更复杂的表达式。<br/> （3）参考C#语言定义文档<br/> 仅作参考，不必深究——毕竟我们是在学习语言、不是去实现这门语言<br/> 3、语句的定义<br/> （1）Wikipedia对语句的定义：<br/> [1]In computer programming a statement is the smallest standalone element of an imperative programming language which expresses some action to be carried out.A program written in such a language is formed by a sequence of one or more statements.A statement will have internal components(e.g,expressions).（在计算机编程学科范畴里，语句是命令编程语言[高级语言]中最小的独立元素。语句这种语法实体就是表达一些将被执行的动作[表达式]。一个由高级语言写成的程序，实际上就是一系列的语句构成的。语句还具有自己的内部组件。）<br/> [2]语句是高级语言的语法——编译语言和机器语言只有指令（高级语言中的表达式对应低级语言中的指令），语句等价于一个或一组有明显逻辑关联的指令。举例：求圆柱体积。</p>
<p>（2）C#语言对语句的定义<br/> [1]The actions that a program takes are expressed in statements.Common actions include declaring variables, assigning values, calling methods, looping through collection, and branching to one or another block of code, depending on a given condition. The order in which statements are executed in a program is called the flow of control or flow of execution. The flow of control may vary every time that a pragram is run, depending on how the program reacts to input that it receives at run time.<br/> 一个程序所要执行的动作就是以语句的形式来表达的。常用的语句的功能有声明变量、对变量赋值、调用函数、在集合中循环（迭代语句）、根据给定的条件在分支中进行跳转（判断语句）。程序由语句构成，语句执行的顺序叫做控制流和执行流。（输入数据的不同，控制流和执行流的顺序是不同的。）<br/> namespace StatementsExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> string input = Console.ReadLine();<br/> try<br/> {<!-- --><br/> double score = double.Parse(input);<br/> if (score&gt;=60)<br/> {<!-- --><br/> Console.WriteLine(“Pass”);<br/> }<br/> else<br/> {<!-- --><br/> Console.WriteLine(“Failed”);<br/> }<br/> }<br/> catch<br/> {<!-- --><br/> Console.WriteLine(“Failed”);<br/> }<br/> }<br/> }<br/> }<br/> [2]C#语言的语句除了让程序员“顺序的”（sequentially）表达算法思想，还能通过条件判断、跳转和循环等方法控制程序逻辑的走向。<br/> [3]简而言之就是：陈述算法思想，控制逻辑走向，完成有意义的动作（action）。<br/> [4]C#语言的语句由分号（;）结尾，但由分号结尾的不一定都是语句。<br/> [5]语句一定是出现在方法体里。<br/> 4、语句详解<br/> statement:<br/> labeled-statement（标签语句）<br/> declaration-statement（声明语句）<br/> embedded-statement（嵌入式语句）<br/> embedded-statement:（下面的语句都可以作为嵌入体使用）<br/> block<br/> empty-statement<br/> expression-statement<br/> selection-statement（选择语句）<br/> iteration-statement<br/> jump-statement<br/> try-statement<br/> checked-statement<br/> unchecked-statement<br/> lock-statement<br/> using-statement<br/> yield-statement</p>
<p>（1）局部变量声明：<br/> local-variable-declaration 声明一个或多个局部变量。</p>
<pre><code>Local-variable-declaration:
	local-variable-type  local-variable-declarators

local-variable-type:
	type
	var

local-variable-declarators:
	local-variable-declarator
	local-variable-declarators , local-variable-declarator

local-variable-declarator:
	identifier
	identifier = local-variable-initializer

local-variable-initializer:
	expression
	array-initializer
</code></pre>
<p>local-variable-declaration的local-variable-type要么直接指定声明引入的变量的类型，要么通过标识符var指示应基于初始值设定项来推断该类型。此类型后接一个local-variable-declarator列表，其中每一项都引入一个新变量。local-variable-declarator由一个命名变量的identifier组成，根据需要此identifier后接一个“=”标记和一个赋予变量初始值的local-variable-initializer。</p>
<p>（2）局部常量声明：<br/> local-constant-declaration用于声明一个或多个局部常量。</p>
<pre><code>local-constant-declaration：
	const  type  constant-declarators
	如：const int x = 100;
constant-declarators:
	constant-declarator
	constant-declarators , constant-declarator

constant-declarator:
	identifier = constant-expression
</code></pre>
<p>local-constant-declaration的type指定由该声明引入的常量的类型。此类型后接一个constant-declarator列表，其中每一项都引入一个新常量。constant-declarator包含一个命名常量的identifier，后接一个“=”标记，然后是一个对该常量赋值的constant-expression。</p>
<p>（3）表达式语句：<br/> expression-statement用于计算所给定的表达式。由此表达式计算出来的值（如果有）被丢弃。<br/> expression-statement：<br/> statement-expression;</p>
<pre><code> statement-expression:
	invocation-expression
	object-creation-expression
	assignment
	post-increment-expression
	post-decrement-expression
	pre-increment-expression
	pre-decrement-expression
	await-expression
</code></pre>
<p>不是所有的表达式都允许作为语句使用。具体而言，不允许像x + y和x==1这样只计算一个值（此值将被放弃）的表达式作为语句使用。<br/> 执行一个expression-statement就是对包含的表达式进行计算，然后将控制转到该expression-statement的结束点。如果一个expression-statement是可到达的，则expression-statement结束点也是可到达的。</p>
<p>（4）选择语句：<br/> 选择语句会根据表达式的值从若干个给定的语句中选择一个来执行。<br/> selection-statement:<br/> if-statement<br/> switch-statement</p>
<p>（5）块语句：<br/> block用于只允许使用单个语句的上下文中编写多条语句：<br/> block：<br/> {statement-listopt}</p>
<p>block由一个扩大在大括号的可选statement-listzucheng组成。如果没有此句语句列表，则称块是空的。<br/> 块可以包含声明语句。在一个块中声明的局部变量或常量的范围就是该块本身。<br/> 在块内，在表达式上下文中使用的名称的含义必须相同。<br/> 块语句在方法体中，且块语句是一条语句。<br/> 块按下述规则执行：<br/> -如果块是块的，控制转换块的结束点<br/> -如果块不是空的，控制转到语句块列表。当（如果）控制到达语句列表的结束点时，控制转到块的结束点。<br/> namespace StatementsExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> //一个花括号就是一个块语句，这样写不多见，一般和循环一起写<br/> {<!-- --><br/> int x = 100;<br/> if (x &gt; 80) Console.WriteLine(x); //嵌入语句<br/> }</p>
<pre><code>        //{
        //hello: Console.WriteLine("Hello!World!");   //标签语句
        //goto hello;                                 //回到标签，形成死循环
        //}

        //块外面的变量可以被块内使用，但是块内的变量不能被块外所引用
        int a = 100;    
        {
            Console.WriteLine(a);                 
        }
    }
}
</code></pre>
<p>}</p>
<p>（6）选择（判断、分支）语句<br/> 选择语句会根据表达式的值从若干个给定的语句中选择一个来执行。<br/> selection-statement:<br/> if-statement<br/> switch-statement</p>
<p>[1]if语句<br/> if语句根据布尔表达式的值选择要执行的语句。<br/> if-statement:<br/> if ( boolean-expression ) embedded-statement<br/> if ( boolean-expression ) embedded-statement else embedded-statement<br/> else部分与语法允许的、词法上最相近的上一个if语句相关联。因而，下列形式的if语句<br/> if (x) if (y) F(); else G();<br/> 相当于<br/> if (x) {<!-- --><br/> if (y) {<!-- --><br/> F();<br/> }<br/> else {<!-- --><br/> G();<br/> }<br/> }<br/> namespace StatementsExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> int x = 100;<br/> int y = 200;<br/> if (x&lt;y)<br/> { //块语句，条件为真就执行这个块语句<br/> Console.WriteLine(“Hello!”);<br/> Console.WriteLine(“World”);<br/> }<br/> else<br/> {<!-- --><br/> Console.WriteLine(“Hello!”);<br/> }<br/> }<br/> }<br/> }</p>
<p>[2]switch语句<br/> switch语句选择一个要执行的语句列表，此列表具有一个相关联的switch标签，它对应与switch表达式的值。<br/> switch-statement:<br/> switch ( expression ) switch-block<br/> switch-block:<br/> { switch-sectionsopt }<br/> switch-sections:<br/> switch-section<br/> switch-sections switch-section<br/> switch-section:<br/> switch-labels statement-list<br/> switch-labels:<br/> switch-label<br/> switch-labels switch-label<br/> switch-label:<br/> case constant-expression :<br/> default :<br/> switch-statement包含关键字switch，后接带括号的表达式（称为switch表达式），然后是一个switch-block。switch-block包含零个或多个括在大括号内的switch-section。每个switch-section包含一个或多个switch-labels，后接一个statement-list。<br/> switch语句的主导类型（governing type）由switch表达式。<br/> -如果switch表达式的类型为sbyte、byte、short、ushort、int、uint、long、ulong、bool、char、string或 enumtype，或者是对应于以上某种类型的可以为null的类型，则该类型就是switch语句的主导类型。<br/> namespace StatementsExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> //需求：80-100-&gt;A；60-79-&gt;B；40-59-&gt;C；0-39-&gt;D；其他-&gt;Error<br/> int score = -1;<br/> switch (score/10)<br/> {<!-- --><br/> case 10:<br/> if (score==100)<br/> {<!-- --><br/> goto case 8;<br/> }<br/> else<br/> {<!-- --><br/> goto default;<br/> }<br/> case 9:<br/> case 8:<br/> Console.WriteLine(“A”);<br/> break;<br/> case 7:<br/> case 6:<br/> Console.WriteLine(“B”);<br/> break;<br/> case 5:<br/> case 4:<br/> Console.WriteLine(“C”);<br/> break;<br/> case 0:<br/> if (score == 0)<br/> {<!-- --><br/> goto case 1;<br/> }<br/> else<br/> {<!-- --><br/> goto default;<br/> }<br/> case 1:<br/> case 2:<br/> case 3:<br/> Console.WriteLine(“D”);<br/> break;<br/> default:<br/> Console.WriteLine(“Error”);<br/> break;<br/> }<br/> }<br/> }<br/> }</p>
<p>（7）try语句<br/> try语句提供一种机制，用于捕捉在块的执行期间发生的各种异常。此外，try语句还能让您指定一个代码块，并保证当控制离开try语句时，总是先执行该代码。<br/> Try-statement:<br/> try block catch-clauses<br/> try block finally-clause<br/> try block catch-clauses finally-clause<br/> catch-clauses:<br/> specific-catch-clauses specific-catch-clauseopt<br/> specific-catch-clausesopt specific-catch-clause<br/> specific-catch-clauses:<br/> specific-catch-clause<br/> specific-catch-clauses specific-catch-clause<br/> specific-catch-clause:<br/> catch ( class-type identifieropt ) block<br/> specific-catch-clause:<br/> catch block<br/> finally-clause:<br/> finally block<br/> 有三种可能的try语句形式：</p>
<ul><li>一个try块后接一个或多个catch块。</li><li>一个try块后接一个finally块。</li><li>一个try块后接一个或多个catch块，后面再跟一个finally块。<br/> 当catch子句指定class-type时，该类型必须为System.Exception、从System.Exception派生的类型，或者以System.Exception（或其子类）作为其有效基类的类型参数类型。<br/> namespace StatementsExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> Calculator c = new Calculator();<br/> int r = c.Add(“abc”, “200”);<br/> Console.WriteLine®;<br/> }<br/> }<br/> class Calculator<br/> {<!-- --><br/> public int Add(string arg1, string arg2)<br/> {<!-- --><br/> int a = 0;<br/> int b = 0;<br/> try<br/> {<!-- --><br/> a = int.Parse(arg1);<br/> b = int.Parse(arg2);<br/> }<br/> catch (ArgumentException)<br/> {<!-- --><br/> Console.WriteLine(“Your argument(s) are null.”);<br/> }<br/> catch (FormatException)<br/> {<!-- --><br/> Console.WriteLine(“Your argument(s) are not number.”);<br/> }<br/> catch (OverflowException)<br/> {<!-- --><br/> Console.WriteLine(“Out of range!”);<br/> }<br/> int result = checked(a + b);<br/> return result;<br/> }<br/> }<br/> }</li></ul>
<p>namespace StatementsExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> Calculator c = new Calculator();<br/> int r = c.Add(null, “200”);<br/> Console.WriteLine®;<br/> }<br/> }<br/> class Calculator<br/> {<!-- --><br/> public int Add(string arg1, string arg2)<br/> {<!-- --><br/> int a = 0;<br/> int b = 0;<br/> bool hasError = false;<br/> try<br/> {<!-- --><br/> a = int.Parse(arg1);<br/> b = int.Parse(arg2);<br/> }<br/> catch (ArgumentException ane)<br/> {<!-- --><br/> Console.WriteLine(ane.Message);<br/> hasError = true;<br/> }<br/> catch (FormatException fe)<br/> {<!-- --><br/> Console.WriteLine(fe.Message);<br/> hasError = true;<br/> }<br/> catch (OverflowException oe)<br/> {<!-- --><br/> Console.WriteLine(oe.Message);<br/> hasError = true;<br/> }<br/> finally<br/> {<!-- --><br/> if (hasError=true)<br/> {<!-- --><br/> Console.WriteLine(“Excution has error!”);<br/> }<br/> else<br/> {<!-- --><br/> Console.WriteLine(“Done!”);<br/> }<br/> }<br/> int result = checked(a + b);<br/> return result;<br/> }<br/> }<br/> }</p>
<p>（8）迭代（循环）语句，跳转语句<br/> 迭代语句重复执行嵌入语句。<br/> Iteration-statement:<br/> while-statement<br/> do-statement<br/> for-statement<br/> foreach-statement<br/> 跳转语句用于无条件的转移控制。<br/> Jump-statement:<br/> break-statement<br/> continue-statement<br/> goto-statement<br/> return-statement<br/> throw-statement<br/> 跳转语句将控制转到的位置称为跳转语句的目标（target）。</p>
<p>[1]while语句：<br/> while语句按不同条件执行一个嵌入语句一次或多次。<br/> While-statement:<br/> while ( boolean-expression ) embedded-statement<br/> namespace StatementsExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> int score = 0;<br/> bool canContinue = true;<br/> Console.WriteLine(“Beggin!!!”);<br/> while (canContinue)<br/> {<!-- --><br/> Console.WriteLine(“Please input your first number:”);<br/> int x = int.Parse(Console.ReadLine());</p>
<pre><code>            Console.WriteLine("Please input your first number:");
            int y = int.Parse(Console.ReadLine());

            int sum = x + y;
            if (sum==100)
            {
                score++;
                Console.WriteLine("Correct! {0}+{1}={2}",x,y,sum);
            }
            else
            {
                Console.WriteLine("Error! {0}+{1}={2}",x,y,sum);
                canContinue = false;
            }
        }
        Console.WriteLine("Your score is {0}",score);
        Console.WriteLine("Game over!");
    }
}
</code></pre>
<p>}</p>
<p>[2]do…while语句：<br/> do语句按不同条件执行一个嵌入语句一次或多次。<br/> do-statement:<br/> do embedded-statement while ( boolean-expression )<br/> 先执行循环体一次，然后再判断是否继续循环。<br/> namespace StatementsExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> int score = 0;<br/> //bool canContinue = true;<br/> int sum;<br/> Console.WriteLine(“Beggin!!!”);<br/> do<br/> {<!-- --><br/> Console.WriteLine(“Please input your first number:”);<br/> int x = int.Parse(Console.ReadLine());</p>
<pre><code>            Console.WriteLine("Please input your first number:");
            int y = int.Parse(Console.ReadLine());

            sum = x + y;
            if (sum == 100)
            {
                score++;
                Console.WriteLine("Correct! {0}+{1}={2}", x, y, sum);
            }
            else
            {
                Console.WriteLine("Error! {0}+{1}={2}", x, y, sum);
                //canContinue = false;
            }
        } while (sum==100);
        Console.WriteLine("Your score is {0}",score);
        Console.WriteLine("Game over!");
    }
}
</code></pre>
<p>}</p>
<p>[3]break:立即结束循环语句(只对直接包含自己的那个循环起作用)<br/> break-statement:<br/> break;<br/> [4]continue:结束这一循环，进入下一次循环(只对直接包含自己的那个循环起作用)<br/> continue-statement:<br/> continue;<br/> namespace StatementsExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> int score = 0;<br/> //bool canContinue = true;<br/> int sum = 100;<br/> Console.WriteLine(“Beggin!!!”);<br/> do<br/> {<!-- --><br/> Console.WriteLine(“Please input your first number:”);<br/> int x = 0;<br/> try<br/> {<!-- --><br/> x = int.Parse(Console.ReadLine());<br/> }<br/> catch<br/> {<!-- --><br/> Console.WriteLine(“First number has problem!Restart.”);<br/> continue;<br/> }</p>
<pre><code>            Console.WriteLine("Please input your first number:");
            int y = 0;
            try
            {
                y = int.Parse(Console.ReadLine());
            }
            catch
            {
                Console.WriteLine("Second number has problem!Restart.");
                continue;
            }

            sum = x + y;
            if (sum == 100)
            {
                score++;
                Console.WriteLine("Correct! {0}+{1}={2}", x, y, sum);
            }
            else
            {
                Console.WriteLine("Error! {0}+{1}={2}", x, y, sum);
                //canContinue = false;
            }
        } while (sum==100);
        Console.WriteLine("Your score is {0}",score);
        Console.WriteLine("Game over!");
    }
}
</code></pre>
<p>}</p>
<p>[5]for语句：<br/> for语句计算一个初始化表达式序列，然后，当某个条件为真时，重复执行相关的嵌入语句并计算一个迭代表达式序列。<br/> for-statement:<br/> for ( for-initializeropt ; for-conditionopt ; for-iteratoropt ) embedded-statement<br/> for-initializer:<br/> local-variable-declaration<br/> statement-expression-list<br/> for-condition:<br/> boolean-expresion<br/> for-iterator:<br/> statement-expression-list<br/> statement-expression-list:<br/> statement-expression<br/> statement-expression-list , statement-expression<br/> namespace StatementsExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> for (int a = 1; a &lt;= 9; a++)<br/> {<!-- --><br/> for (int b = 1; b &lt;= a; b++)<br/> {<!-- --><br/> Console.Write("{0}<em>{1}={2}\t",a,b,a</em>b);<br/> }<br/> Console.WriteLine();<br/> }<br/> }<br/> }<br/> }</p>
<p>[6]foreach语句：<br/> foreach语句用于枚举一个集合的元素，并对该集合中的每个元素执行一次相关的嵌入语句。<br/> foreach-statement:<br/> foreach ( local-variable-type identifier in expression ) embedded-statement <br/> namespace StatementsExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> int[] intArray = new int[] { 1, 2, 3, 4, 5, 6, 7, 8 };<br/> List intList = new List() { 1, 2, 3, 4, 5, 6 };<br/> //foreach作用：对集合进行遍历<br/> foreach (var current in intList)<br/> {<!-- --><br/> Console.WriteLine(current);<br/> }<br/> }<br/> }<br/> }</p>
<p>[7]return语句：尽早return<br/> namespace StatementsExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> Greeting(“Mr.Okay”);<br/> var result = WholsWho(“Okary”);<br/> Console.WriteLine(result);<br/> }</p>
<pre><code>    static string WholsWho(string alias)
    {
        if (alias == "Mr.Okary")
        {
            return "Tim";
        }
        else
        {
            return "I don't know!";
        }
    }

    static void Greeting(string name)
    {   //尽早return，可以使结构更加精短
        if (string.IsNullOrEmpty(name))
        {
            return;
        }
        Console.WriteLine("Hello {0}!" ,name);
    }
}
</code></pre>
<p>}<br/> 八、字段、属性、索引器、常量<br/> 成员 说明<br/> 常量 与类关联的常量值<br/> 字段 类的变量<br/> 方法 类可执行的计算和操作<br/> 属性 与读写类的命名属性相关联的操作<br/> 索引器 与以数组方式索引类的实例相关联的操作<br/> 事件 可由类生成的通知<br/> 运算符 类所支持的转换和表达式运算符<br/> 构造函数 初始化类的实例或类本身所需的操作<br/> 析构函数 在永久丢弃类的实例之前执行的操作<br/> 类型 类所声明的嵌套类型</p>
<p>1、字段<br/> （1）什么是字段：<br/> [1]字段（field）是一种表示与对象或类型（类与结构体）关联的变量。field-declarators用于引入一个或多个给定类型字段。字段的定义放在类体里，不能放在函数体中。字段不是语句<br/> field-declaration:<br/> attributesopt field-modifiersopt type variable-declarators ;<br/> field-modifiers:<br/> field-modifier<br/> field-modifiers field-modifier<br/> field-modifier<br/> new<br/> public<br/> protected<br/> internal<br/> private<br/> static<br/> readonly只读<br/> volatile<br/> variable-declarators:<br/> variable-declarator<br/> [2]字段是类型的成员，旧称“成员变量”<br/> [3]与对象关联的字段亦称“实例字段”<br/> [4]与类型关联的字段称为“静态字段”，由static修饰<br/> namespace StatementsExample<br/> {<!-- --><br/> class Program <br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> List stuList = new List();<br/> for (int i = 0; i &lt; 100; i++)<br/> {<!-- --><br/> Student stu = new Student();<br/> stu.Age = 24;<br/> stu.Score = i;<br/> stuList.Add(stu);<br/> }</p>
<pre><code>        int totalAge = 0;
        int totalScore = 0;
        foreach (var stu in stuList)
        {
            totalAge += stu.Age;
            totalScore += stu.Score;
        }

        Student.AverageAge = totalAge / Student.Amount;
        Student.AverageScore = totalScore / Student.Amount;

        Student.ReportAmount();
        Student.ReportAverageAge();
        Student.ReportAverageScore();
    }
}

class Student
{
    public int Age;         //实例字段
    public int Score;       //实例字段

    public static int AverageAge;       //静态字段
    public static int AverageScore;
    public static int Amount;

    public Student()        //构造函数
    {
        Student.Amount++;   //学生总数加一
    }

    public static void ReportAmount()           //创建静态方法
    {
        Console.WriteLine(Student.Amount);
    }

    public static void ReportAverageAge()
    {
        Console.WriteLine(Student.AverageAge);
    }

    public static void ReportAverageScore()
    {
        Console.WriteLine(Student.AverageScore);
    }
}
</code></pre>
<p>}</p>
<p>（2）字段的声明：<br/> [1]参见C#语言定义文档<br/> [2]尽管字段声明带有分号，但它不是语句<br/> [3]字段的名字一定是名词<br/> namespace StatementsExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> Console.WriteLine(Student.Amount);<br/> }<br/> }</p>
<pre><code>class Student
{
    public int Age = 20;         //实例字段
    public int Score;       //实例字段

    public static int AverageAge;       //静态字段
    public static int AverageScore;
    public static int Amount = 100;     //声明时就被执行；静态实例构造器只会执行一次，就是在运行环境加载数据类型的时候
        
    //static Student()        //静态构造器
    //{
    //    Student.Amount = 100;
    //}
}
</code></pre>
<p>}</p>
<p>（4）只读字段：<br/> [1]实例只读字段<br/> [2]静态只读字段<br/> namespace StatementsExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> Student stu1 = new Student(1);<br/> Console.WriteLine(stu1.ID);<br/> stu1.ID = 2; //只读字段不能再被赋值<br/> }<br/> }</p>
<pre><code>class Student
{
    public readonly int ID;      //只读实例
    public int Age = 20;         //实例字段
    public int Score;       //实例字段

    public static int AverageAge;       //静态字段
    public static int AverageScore;
    public static int Amount = 100;     //声明时就被执行；静态实例构造器只会执行一次，就是在运行环境加载数据类型的时候
        
    //static Student()        //静态构造器
    //{
    //    Student.Amount = 100;
    //}

    public Student(int id)
    {
        this.ID = id;
    }
}
</code></pre>
<p>}</p>
<p>2、属性：<br/> （1）什么是属性：<br/> [1]属性（property）是一种用于访问对象或类型的特征的成员，特征反映了状态；属性的示例包括字符串的长度、字体的大小、窗口的标题、客户的名称，等等。属性是字段的自然扩展，此二者都是具有关联类型的命名成员，而且访问字段和属性的语法是相同的。然而，与字段不同，属性不表示存储位置。相反，属性有访问器（accessor），这些访问器指定在它们的值被读取或写入时需执行的语句。因此属性提供了一种机制，它把读取和写入对象的某些特性与一些操作关联起来；甚至，它们还可以对此类特性进行计算。<br/> 属性是使用property-declaration声明：<br/> property-declaration:<br/> attributesopt property-modifiersopt type member-name { accessor-declarations }<br/> property-modifiers:<br/> property-modifier<br/> property-modifiers property-modifier<br/> [2]属性是字段的自然扩展<br/> 从命名上看，field更偏向于实例对象在内存中的布局，Property更偏向于反映现实世界对象的特征；<br/> 对外：暴露数据，数据可以是存储在字段里的，也可以是动态计算出来的；<br/> 对内：保护字段不被非法值“污染”；<br/> [3]属性由Get/Set方法对进化而来；<br/> namespace PorpertyExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> try<br/> {<!-- --><br/> Student stu1 = new Student();<br/> stu1.Age = 20;<br/> Student stu2 = new Student();<br/> stu2.Age = 20;<br/> Student stu3 = new Student(); <br/> stu3.Age = 20;</p>
<pre><code>            int avgAge = (stu1.Age + stu2.Age + stu3.Age) / 3;
            Console.WriteLine(avgAge);
        }
        catch (Exception ex)
        {
            Console.WriteLine(ex.Message);
        }
    }
}

class Student       
{
    private int age;

    public int Age      //创建属性（由Get和Set方法进化而来，更加安全）
    {
        get
        {
            return this.age;
        }

        set             //在set get上下文中 value 是系统设定的关键词，不需要自己申明
        {
            if (value&gt;=0 &amp;&amp; value&lt;=120)
            {
                this.age = value;
            }
            else
            {
                throw new Exception("Age value has error!"); 
            }
        }
    }

    //public int GetAge()       //Get方法
    //{
    //    return this.age;
    //}

    //public void SetAge(int value) //Set方法
    //{
    //    if (value&gt;=0 &amp;&amp; value &lt;=120)
    //    {
    //        this.age = value;
    //    }
    //    else
    //    {
    //        throw new Exception("Age value is error!");
    //    }
    //}
}
</code></pre>
<p>}<br/> [4]又一个“语法糖”——属性背后的秘密；</p>
<p>（2）属性的声明：<br/> [1]完整声明——后台（back）成员变量与访问器（注意使用code snippet和refactor工具）；<br/> [2]简略声明——只有访问器（查看IL代码）；<br/> //完整声明<br/> namespace PorpertyExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> try<br/> {<!-- --><br/> Student.Amount = -100;<br/> Console.WriteLine(Student.Amount);<br/> }<br/> catch (Exception ex)<br/> {<!-- --><br/> Console.WriteLine(ex.Message);<br/> }<br/> }<br/> }</p>
<pre><code>    class Student       
    {
        //打出propfull再按两次Tab键，就会自动创建属性（有两部分，属性及其支持字段）
        private int age;

        public int Age
        {
            get { return age; }
            set {
                if (value&gt;=0 &amp;&amp; value&lt;=120)
                {
                    age = value;
                }
                else
                {
                    throw new Exception("Age value has error!");
                }
            }
        }

        private static int amount;

        public static int Amount
        {
            get { return amount; }
            set {
                if (value &gt;= 0)
                {
                    Student.amount = value;
                }
                else
                {
                    throw new Exception("Amount must greater than 0.");
                }
            }
        }
    }
}
</code></pre>
<p>//简略声明<br/> class Student<br/> {<!-- --><br/> //简略声明<br/> public int Age { get; set; }<br/> }</p>
<p>[3]动态计算值的属性；<br/> namespace PorpertyExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> try<br/> {<!-- --><br/> Student stu = new Student();<br/> stu.Age = 16;<br/> Console.WriteLine(stu.CanWork);<br/> }<br/> catch (Exception ex)<br/> {<!-- --><br/> Console.WriteLine(ex.Message);<br/> }<br/> }<br/> }</p>
<pre><code>class Student       
{
    private int age;            //字段

    public int Age              //属性
    {
        get { return age; }     //删掉set后变成只读
        set { age = value; }    //private：私有，只在这个类中可以set（写）到
    }

    public bool CanWork 
    { 
        get 
        {
            if (this.age&gt;=16)
            {
                return true;
            }
            else
            {
                return false;
            }
        } 
    }
}      
</code></pre>
<p>}</p>
<p>[4]注意实例属性和静态属性；<br/> [5]属性的名字一定是名词；<br/> [6]只读属性——只有getter没有setter；<br/> 尽管语法上正确，几乎没有人使用“只写属性”，因为属性的主要目的是通过向外暴露数据而表示对象/类型的状态。<br/> namespace PorpertyExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> try<br/> {<!-- --><br/> Student stu = new Student();<br/> stu.Age = 100;<br/> }<br/> catch (Exception ex)<br/> {<!-- --><br/> Console.WriteLine(ex.Message);<br/> }<br/> }<br/> }</p>
<pre><code>class Student       
{
    private int age;

    public int Age
    {
        get { return age; }             //删掉set后变成只读
        private set { age = value; }    //private：私有，只在这个类中可以set（写）到
    }

    public void SomeMethod()
    {
        this.Age = 20;                  //不是只读，它的setter不能从外界访问到
    }
}
</code></pre>
<p>}</p>
<p>（3）属性与字段的关系：<br/> [1]一般情况下，它们都用于表示实体（对象或类型）的状态。<br/> [2]属性大多数情况下是字段的包装器（wrapper）。<br/> [3]建议：永远使用属性（而不是字段）来暴露数据，即字段永远都是private或protected的。</p>
<p>3、索引器<br/> （1）什么是索引器：<br/> 索引器（indexer）是这样一种成员：它使对象能够用与数组相同的方式（即使用下标）进行索引<br/> （2）索引器的声明：<br/> 参见C#语言定义文档<br/> 注意：没有静态索引器<br/> namespace IndexerExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> Student stu = new Student();<br/> stu[“Math”] = 100;<br/> stu[“Math”] = 150; //赋值过，再次赋值就更新值<br/> var mathScore = stu[“Math”];<br/> Console.WriteLine(mathScore); //如果没有存储过Math的值，就是空值；如果有值，就返回值；<br/> }<br/> }</p>
<pre><code>class Student
{
    //创建字典类型的私有字段。字典类型：Dictionary&lt;'键', '值'&gt;
    private Dictionary&lt;string, int&gt; scoreDictionary = new Dictionary&lt;string, int&gt;();
    //声明索引器。输入indexer，再敲两次Tab键就可以生成索引器框架代码
    public int? this[string subject]        //int?：表示返回可空的数据类型。string：用字符串类型进行索引。subject:表示上过的科目
    {
        get 
        {   //拿着传进来的科目名称，去字典里面查。如果字典里面有这个值就返回去，没有就返回NULL值
            if(this.scoreDictionary.ContainsKey(subject))   //ContainsKey()：判断字典里是否有指定的键
            {
                return this.scoreDictionary[subject];       //返回这个键的内容
            }
            else
            {
                return null;
            }
        }
        set 
        {
            if (value.HasValue==false)      //如果可空类型没有值，就抛出异常
            {
                throw new Exception("Score cannot be null.");
            }

            if (this.scoreDictionary.ContainsKey(subject))      //传进字典里的值不能为空值，需要使用value.Value
            {
                this.scoreDictionary[subject] = value.Value;    //判断字典中是否有这个键，有的话就更新这个键。value表示赋进来的值
            }
            else
            {
                this.scoreDictionary.Add(subject, value.Value); //字典中如果没有这个科目的值，就加进去
            }
        }
    }
}
</code></pre>
<p>}</p>
<p>4、常量<br/> （1）什么是常量：<br/> [1]常量（constant）是表示常量值（即，可以在编译时计算的值）的类成员<br/> [2]常量隶属于类型而不是对象，即没有“实例常量”<br/> “实例常量”的角色由只读实例字段来但当<br/> [3]注意区分成员常量与局部常量<br/> 成员常量：类型的成员<br/> 局部常量：参与组成方法体中的算法<br/> namespace ConstantExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> int b = int.MaxValue; //int.MaxValue:成员常量<br/> double x = GetArea(1.0);<br/> Console.WriteLine(x);<br/> Console.WriteLine(b);</p>
<pre><code>        const int y = 100;              //局部常量
        y = 200;                        //报错：常量不可以更改
    }

    static double GetArea(double r)
    {
        double a = Math.PI * r * r;     //Math.PI：（成员常量）就是个常量值3.14159，提高运行效率
        return a;
    }
}
</code></pre>
<p>}</p>
<p>（2）常量的声明<br/> namespace ConstantExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> Console.WriteLine(WASPEC.WebsiteURL);<br/> }<br/> }</p>
<pre><code>class WASPEC
{
    public const string WebsiteURL="http://www.waspec.org";
}
</code></pre>
<p>}<br/> （3）各种“只读”的应用场景<br/> [1]为了提高程序可读性和执行效率——常量（高效率）<br/> [2]为了防止对象的值被改变——只读字段（比常量效率低）<br/> [3]向外暴露不允许修改的数据——只读属性（静态或非静态），功能与常量有一些重叠<br/> [4]当希望成为常量的值其类型不能被常量声明接受时（类/自定义结构体）——静态只读字段（代码如下：）<br/> namespace ConstantExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> Console.WriteLine(WASPEC.WebsiteURL);<br/> }<br/> }</p>
<pre><code>class WASPEC
{
    public const string WebsiteURL="http://www.waspec.org";
    public static readonly Building Location = new Building("Some Adress");
}

class Building
{
    public Building(string address)
    {
        this.Address = address;
    }
    public string Address { get; set; }
}
</code></pre>
<p>}</p>
<p>九、传值/输出/引用/数组/具名/可选参数，扩展方法<br/> 1、传值参数<br/> 声明时不带修饰符的形参是值形参。一个值形参对应于一个局部变量，只是它的初始值来自该方法调用所提供的相关实参。<br/> 当形参是值形参时，方法调用中的对应实参必须是表达式，并且它的类型可以隐式转换为形参的类型。<br/> 允许方法将新值赋给值参数。这样的赋值只影响由该值形参表示的局部存储位置，而不会影响在方法调用时由调用方给出的实参。<br/> [1]值类型的传值参数的用法<br/> 注意：值参数创建变量的副本；<br/> 对值参数的操作永远不影响变量的值。<br/> namespace ParametersExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> Student stu = new Student();<br/> int y = 100;<br/> stu.AddOne(y); //101<br/> Console.WriteLine(y); //100<br/> }<br/> }</p>
<pre><code>class Student
{
    public void AddOne(int x)       //传值参数，传进来的是副本的值，不改变其它类值
    {
        x = x + 1;
        Console.WriteLine(x);
    }
}
</code></pre>
<p>}</p>
<p>[2]引用参数的传值参数，并且新创建对象<br/> 即 原方法里的值不会改变<br/> namespace ParametersExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> Student stu = new Student() { Name = “Tim” }; //调用SomeMethod方法时，两个变量名不一定一样<br/> SomeMethod(stu);<br/> Console.WriteLine("{0},{1}", stu.GetHashCode(), stu.Name); //GetHashCode()：每个对象的GetHashCode都不同。<br/> }</p>
<pre><code>    static void SomeMethod(Student stu)                          //这个stu的作用域是SomeMethod方法,与main方法的方法体里的stu作用域不同
    {
        //方法为对象赋新值，这个新值是新对象在内存当中的地址，这个新对象的Name属性是Tom
        stu = new Student() { Name = "Tom" };                             //新创建一个实例交给参数进行引用，新实例名字设为Tom
        Console.WriteLine("{0},{1}", stu.GetHashCode(), stu.Name);        //所有的类型都直接或间接是Object的派生类，因此无论什么类型，都有GetHashCode方法
    }
}

class Student
{
    public string Name { get; set; }    //简化声明属性：向外暴露数据，比字段更安全
}
</code></pre>
<p>}</p>
<p>[3]引用类型的传值参数：只操作对象，不创建新对象<br/> 注意：对象还是那个对象，但对象里的值（字段/属性）已经改变<br/> namespace ParametersExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> Student stu = new Student() { Name = “Tim” };<br/> UpdateObject(stu);<br/> Console.WriteLine(“HashCode={0},Name={1}”, stu.GetHashCode(), stu.Name);<br/> }</p>
<pre><code>    static void UpdateObject(Student stu)       
    {
        //只更新对象，而不创建新对象的情形
        //我们把这种修改参数引用值的情况叫做某个方法的副作用(side-effect)。这种副作用一般是要避免的，方法返回参数值一般使用return。
        stu.Name = "Tom";
        Console.WriteLine("HashCode={0},Name={1}", stu.GetHashCode(), stu.Name);
    }
}

class Student
{
    public string Name { get; set; }    //简化声明属性：向外暴露数据，比字段更安全
}
</code></pre>
<p>}<br/> 2、输出参数<br/> 用out修饰符声明的形参是输出形参。类似于引用形参，输出形参不创建新的存储位置（即不创建副本）。相反，输出形参表示的存储位置恰是在该方法调用中作为实参给出的那个变量所表示的存储位置。（是打算将输出参数当作一个值输出。）<br/> 当形参为输出形参时，方法调用中的相应实参必须由关键字out并后接一个与形参类型相同的variable-reference组成。变量在可以作为输出参数传递之前不一定需要明确赋值，但是在将变量作为输出形参传递的调用之后，该变量被认为是明确赋值的（即在方法体中要有明确的赋值）。<br/> 在方法内部，与局部变量相同，输出形参最初被认为是未赋值的，因而必须在使用它的值之前明确赋值。在方法返回之前，该方法的每个输出形参都必须明确赋值。<br/> 声明为分部方法或迭代器的方法不能有输出形参。<br/> 输出形参通常用在需要产生多个返回值的方法中。例如：<br/> using System;<br/> class Test<br/> {<!-- --><br/> static void sqlitpath(string path, out string dir, out string name){<!-- --><br/> int i = path.Length;<br/> while(i&gt;0){<!-- --><br/> char ch = path[i – 1];<br/> if(ch == ‘\’ || ch == ‘/’ || ch == ‘:’) break;<br/> i–;<br/> }<br/> dir = path.Substring(0, i);<br/> name = path.Substring(i);<br/> }<br/> static void Main(){<!-- --><br/> string dir, name;<br/> SplitPath(“c:\Windows\System\hello.txt”, out dir, out name);<br/> Console.WriteLine(dir);<br/> Console.WriteLine(name);<br/> }<br/> }<br/> [1]值类型的输出参数：<br/> 注意：输出参数并不创建变量的副本；<br/> 方法体内必须有对输出变量的赋值操作；<br/> 使用out修饰符显式指出——此方法的副作用是通过参数向外输出值；<br/> 从语义上来讲——ref是为了“改变”，out是为了“输出”。<br/> namespace ParametersExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> Console.WriteLine(“Please input first number:”);<br/> string arg1 = Console.ReadLine();<br/> double x = 0;<br/> //TryParse是double类型，因此，需要out关键字返回x值<br/> //需要写出out关键字，显式的提醒我们通过这个参数拿到输出值，并把值传给x，然后由b1接收返回值。<br/> bool b1 = double.TryParse(arg1, out x);<br/> if (b1 == false)<br/> {<!-- --><br/> Console.WriteLine(“Input error!”);<br/> return;<br/> }</p>
<pre><code>        Console.WriteLine("Please input second number:");
        string arg2 = Console.ReadLine();
        double y = 0;
        bool b2 = double.TryParse(arg2, out y);
        if (b2==false)
        {
            Console.WriteLine("Input error!");
            return;
        }

        double z = x + y;
        Console.WriteLine("{0}+{1}={2}", x, y, z);
    }
}
</code></pre>
<p>}</p>
<p>TryParse的逻辑：<br/> namespace ParametersExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> double x = 100;<br/> bool b = DoubleParser.TryParse(“211”, out x); //输入值错误时，x的值会被覆盖为0，这是正常的<br/> if (b==true)<br/> {<!-- --><br/> Console.WriteLine(x + 1);<br/> }<br/> else<br/> {<!-- --><br/> Console.WriteLine(x);<br/> }<br/> }<br/> }</p>
<pre><code>class DoubleParser
{
    public static bool TryParse(string input, out double result)
    {
        try
        {
            result = double.Parse(input);
            return true;
        }
        catch               //不写Exception，所有的错误都抓取
        {
            result = 0;
            return false;
        }
    }
}
</code></pre>
<p>}</p>
<p>[2]引用类型的输出参数：<br/> namespace ParametersExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> Student stu = null;<br/> bool b = StudentFactory.Create(“Tom”, 23, out stu); //传进去名字和年龄，输出给stu<br/> if (b==true) //如果创建成功<br/> {<!-- --><br/> Console.WriteLine(“Student {0}, age is {1}.”, stu.Name, stu.Age);<br/> }<br/> }<br/> }</p>
<pre><code>class Student
{
    //创建两个类型
    public int Age { get; set; }
    public string Name { get; set; }
}

class StudentFactory
{
    public static bool Create(string stuName, int stuAge, out Student result)   //用输出参数将创建的实例交还回来
    {
        //逻辑：将传入进来的姓名和年龄，赋给创建的学生实例的属性
        result = null;
        if (string.IsNullOrEmpty(stuName))      //学生名字如果为空，就返回false
        {
            return false;
        }

        if (stuAge&lt;20||stuAge&gt;80)
        {
            return false;
        }

        result = new Student() { Name = stuName, Age = stuAge };    //名字和年龄都合法后，创建对象，并将名字和年龄赋值给类型
        return true;
    }
}
</code></pre>
<p>}</p>
<p>3、引用参数<br/> 引用参数是用ref修饰符声明的形参。与值形参不同，引用形参并不创建新的存储位置。相反，引用形参表示的存储位置恰是在方法调用中作为实参给出的那个变量所表示的存储位置。（即引用参数直接指向传进来的实际参数所指向的内存地址。）<br/> 当形参为引用形参时，方法调用中的对应实参必须由关键字ref并后接一个与形参类型相同的variable-reference组成。变量在可以作为引用形参传递之前，必须先明确赋值。<br/> 在方法内部，引用形参始终被认为是明确赋值的。<br/> 声明为迭代器的方法不能有引用形参。<br/> 下面的示例：<br/> using System;<br/> class Test<br/> {<!-- --><br/> static void Swap(ref int x, ref int y){<!-- --><br/> int temp = x;<br/> x = y;<br/> y = temp;<br/> }<br/> static void Main(){<!-- --><br/> int i = 1, j = 2;<br/> Swap(ref i, ref j);<br/> Console.WriteLine(“i = {0}, j = {1}”, i, j); <br/> }<br/> }<br/> 产生输出：<br/> i = 2, j = 1<br/> [1]值类型的引用参数：<br/> 注意：引用参数并不创建变量的副本；<br/> 使用ref修饰符显式指出——此方法的副作用是改变实际参数的值，也就是利用此副作用；<br/> 方法内的参数获得新值时，方法外部的变量也会获得新值；<br/> namespace ParametersExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> int y = 1;<br/> IWantSideEffect(ref y);<br/> Console.WriteLine(y);<br/> }</p>
<pre><code>    static void IWantSideEffect(ref int x)  //值类型引用参数所指向的内存地址，就是main方法里的变量y所指向的地址
    {
        x = x + 100;                        //变量通过IWantSideEffect方法来获得值的时候，变量里的值也会改变
    }
}
</code></pre>
<p>}</p>
<p>[2]引用类型的引用参数：创建新对象<br/> namespace ParametersExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> Student outterStu = new Student() { Name = “Tim” }; //使用outterStu来与stu进行区分，并设置不同的名字Tim<br/> Console.WriteLine(“HashCode={0},Name={1}”, outterStu.GetHashCode(), outterStu.Name); //打印出调用方法前的GetHashCode和Name属性的值<br/> Console.WriteLine("——————————————————————————");<br/> IWantSideEffect(ref outterStu); //调用方法，引用类型需要加上ref关键字<br/> Console.WriteLine(“HashCode={0},Name={1}”, outterStu.GetHashCode(), outterStu.Name); //打印调用后的值，发现参数和方法外的变量所引用的对象是一个对象，且在方法体外定义的对象<br/> }</p>
<pre><code>    static void IWantSideEffect(ref Student stu)    //stu是引用类型的类型参数，引用的是Student类
    {
        stu = new Student() { Name = "Tom" };       //在方法体中为引用类型赋上新值
        Console.WriteLine("HashCode={0},Name={1}",stu.GetHashCode(),stu.Name);  //打印出来
    }
}

class Student
{
    public string Name { get; set; }
}
</code></pre>
<p>}</p>
<p>[3]引用类型的引用参数：不创建新对象只改变对象值<br/> namespace ParametersExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> Student outterStu = new Student() { Name = “Tim” }; //调用方法<br/> Console.WriteLine(“HashCode={0},Name={1}”, outterStu.GetHashCode(), outterStu.Name); //打印方法外的变量的GetHashCode和Name值<br/> Console.WriteLine("————————————————————");<br/> SomeSideEffect(ref outterStu); //调用方法，将outterStu传进去<br/> Console.WriteLine(“HashCode={0},Name={1}”, outterStu.GetHashCode(), outterStu.Name); //打印调用后的两个值<br/> //结果发现，三个输出的GetHashCode和Name值是一样的，对象里的属性值发生了改变Tim-》Tom，GetHashCode没有改变，所以我们一直在操作一个对象<br/> }</p>
<pre><code>    static void SomeSideEffect(ref Student stu)
    {
        stu.Name = "Tom";           //不为引用参数赋新值，而是只通过这个参数访问由它引用的对象
        Console.WriteLine("HashCode={0},Name={1}", stu.GetHashCode(), stu.Name);    //打印对象的GetHashCode和Name属性值
    }
}

class Student
{
    public string Name { get; set; }
}
</code></pre>
<p>}</p>
<p>与值参数一样的结果，但是值参数内存操作机理不同，值参数的传值函数在内存中创建了实际参数的副本，即stu参数和outterStu变量所指向的内存地址是不一样的，但是这两个不同的地址却存储着一个相同的地址，这个地址是实例在堆内存当中的地址，这是传值的情况。引用参数的情况是这样的，stu参数和outterStu变量存储的地址是同一个地址，储存的就是对象在堆内存当中的地址。<br/> namespace ParametersExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> Student outterStu = new Student() { Name = “Tim” }; //调用方法<br/> Console.WriteLine(“HashCode={0},Name={1}”, outterStu.GetHashCode(), outterStu.Name); //打印方法外的变量的GetHashCode和Name值<br/> Console.WriteLine("————————————————————");<br/> SomeSideEffect(outterStu); //调用方法，将outterStu传进去<br/> Console.WriteLine(“HashCode={0},Name={1}”, outterStu.GetHashCode(), outterStu.Name); //打印调用后的两个值<br/> //结果发现，三个输出的GetHashCode和Name值是一样的，对象里的属性值发生了改变Tim-》Tom，GetHashCode没有改变，所以我们一直在操作一个对象<br/> }</p>
<pre><code>    static void SomeSideEffect(Student stu)
    {
        stu.Name = "Tom";           //不为引用参数赋新值，而是只通过这个参数访问由它引用的对象
        Console.WriteLine("HashCode={0},Name={1}", stu.GetHashCode(), stu.Name);    //打印对象的GetHashCode和Name属性值
    }
}

class Student
{
    public string Name { get; set; }
}
</code></pre>
<p>}<br/> 4、数组参数<br/> 必须是形参列表中的最后一个，由params修饰；<br/> 举例：String.Format方法和String.Sqlit方法。<br/> namespace ParametersExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> //int[] myIntArray = new int[] { 1, 2, 3 }; //声明一个数组，如果使用了params就不用自己声明数组了<br/> int result = CalculateSun(1, 2, 3); //如果使用params，在CalculateSun(1,2,3)中加上数组就好，系统会自动为我们创建数组<br/> Console.WriteLine(result);<br/> }</p>
<pre><code>    static int CalculateSun(params int[] intArray)     //创建一个方法：传进来一个整型数组，然后将数组里面所有元素的和返回出去
    {
        int sum = 0;
        foreach (var item in intArray)
        {
            sum += item;
        }

        return sum;
    }
}
</code></pre>
<p>}</p>
<p>String.Sqlit方法：<br/> namespace ParametersExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> string str = “Tim;Tom,Arry.Lisa”; //数组中含有特殊间隔符<br/> string[] result = str.Split(’;’, ‘,’, ‘.’); //Split分割数组<br/> foreach (var name in result) //迭代一下这个数组<br/> {<!-- --><br/> Console.WriteLine(name);<br/> }<br/> }<br/> }<br/> }</p>
<p>5、具名参数<br/> 参数的位置不再受约束</p>
<p>namespace ParametersExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> PrintInfo(age: 23,name: “Tom”); //参数的位置不受约束，并且可读性很高<br/> }</p>
<pre><code>    static void PrintInfo(string name, int age)
    {
        Console.WriteLine("Hello {0},you are {1}.",name,age);
    }
}
</code></pre>
<p>}</p>
<p>6、可选参数<br/> 参数因为具有默认值而变得“可选”<br/> 不推荐使用可选参数<br/> namespace ParametersExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> PrintInfo(); //调用方法，里面没有写参数<br/> }</p>
<pre><code>    static void PrintInfo(string name = "Tim", int age = 24)    //声明方法时参数是带有默认值的，如果在调用时没写参数，则这个参数自动获得声明时的默认值
    {
        Console.WriteLine("Hello {0},you are {1}.", name, age);
    }
}
</code></pre>
<p>}<br/> 7、扩展方法（this参数）<br/> 方法必须是共有、静态的，即被public static所修饰<br/> 必须是形参列表中的第一个，由this修饰<br/> 必须由一个静态类（一般类名为SomeTypeExtension）来统一收纳对SomeType类型的扩展方法<br/> 举例：LINQ方法<br/> namespace ParametersExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> //当我们无法对一个类型的源码进行修改时，可以使用扩展方法，为目标数据类型来追加方法<br/> double x = 3.14159;<br/> double y = x.Round(4); //不能直接使用Round方法，扩展一个方法来使用<br/> Console.WriteLine(y);<br/> }<br/> }</p>
<pre><code>static class DoubleExtension        //声明静态类
{
    public static double Round(this double input, int digits)   //this修饰符，生成扩展方法
    {
        double result = Math.Round(input, digits);
        return result;
    }
}
</code></pre>
<p>}</p>
<p>举例：LINQ方法<br/> namespace ParametersExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> List myList = new List() { 11, 12, 13, 14, 15 };<br/> bool result = myList.All(i =&gt; i &gt; 10); //ALL是扩展方法<br/> Console.WriteLine(result);<br/> }</p>
<pre><code>    static bool AllGreaterThanTen(List&lt;int&gt; intList)
    {
        foreach (var item in intList)
        {
            if (item&lt;=10)
            {
                return false;
            }
        }

        return true;
    }
}
</code></pre>
<p>}</p>
<p>8、总结：各种参数的使用场景总结：<br/> [1]传值参数：参数的默认传递方式（参数是实参的副本，不会影响实参的值）<br/> [2]输出参数：用于除返回值外还需要输出的场景<br/> [3]引用参数：用于需要修改实际参数值的场景<br/> [4]数组参数：用于简化方法的调用<br/> [5]具名参数：提高可读性<br/> [6]可选参数：参数拥有默认值<br/> [7]扩展方法（this参数）：为目标数据类型“追加”方法</p>
<p>十、委托<br/> 1、什么是委托<br/> [1]委托（delegate）是函数指针的“升级版”<br/> 实例：C/C++中的函数指针<br/> [2]一切皆地址<br/> 变量（数据）是以某个地址为起点的一段内存中所存储的值<br/> 函数（算法）是以某个地址为起点的一段内存中所存储的一组机器语言指令<br/> [3]直接调用与间接调用<br/> 直接调用：通过函数名来调用函数，CPU通过函数名直接获得函数所在地址并开始执行-&gt;返回<br/> 间接调用：通过函数指针来调用函数，CPU通过读取函数指针存储的值获得函数所在地址并开始执行-&gt;返回<br/> [4]Java中没有与委托相对应的功能实体<br/> Java没有指针，不允许直接访问地址[5]委托的简单使用<br/> [5]委托的简单实用:（下面两个委托是C#准备好的）<br/> Action委托（没有返回值）<br/> Func委托（有返回值）<br/> namespace DelegateExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> //委托是函数指针的升级版：可以按照一定的约束，指向某些目标方法，帮助我们对方法的间接调用<br/> //第一种委托：action<br/> Calculator calculator = new Calculator();<br/> Action action = new Action(calculator.Report); //calculator.Report后面不加圆括号，只需要方法名就好（如果加上就是调用了）<br/> calculator.Report(); //直接调用<br/> action.Invoke(); //间接调用<br/> action(); //类似于指针的方式</p>
<pre><code>        //第二种委托：function委托。泛型委托，提供目标方法的参数类型（17种重载）
        Func&lt;int, int, int&gt; func1 = new Func&lt;int, int, int&gt;(calculator.Add);    //
        Func&lt;int, int, int&gt; func2 = new Func&lt;int, int, int&gt;(calculator.Sub);    //&lt;&gt;中的前两个int是目标方法的参数类型，第三个是返回值类型

        int x = 100;
        int y = 200;
        int z = 0;

        z = func1(x, y);
        Console.WriteLine(z);
        z = func2.Invoke(x, y);
        Console.WriteLine(z);
    }
}

class Calculator
{
    public void Report()
    {
        Console.WriteLine("I have 3 methods.");
    }

    public int Add(int a, int b)
    {
        int result = a + b;
        return result;
    }

    public int Sub(int a, int b)
    {
        int result = a - b;
        return result;
    }
}
</code></pre>
<p>}</p>
<h2><a id="2%0A1class%0Anamespace_DelegateExample%0A%0A____class_Program%0A____%0A________static_void_Mainstring_args%0A________%0A____________Type_t_typeofAction_________typeofAction%0A____________ConsoleWriteLinetIsClass___tureAction%0A________%0A____%0A%0A2CC%0A3%0A%09%0A4%0Adelegate__double_Calcdouble_x_double_y_3959"></a>2、委托的声明（自定义委托）<br/> [1]委托是一种类（class），类是数据类型所以委托也是一种数据类型<br/> namespace DelegateExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> Type t =typeof(Action); //调用typeof操作符，查看Action委托<br/> Console.WriteLine(t.IsClass); //判断委托是不是类，返回ture，表示Action真的是类<br/> }<br/> }<br/> }<br/> [2]它的声名方式与一般的类不同，主要是为了照顾可读性和C/C++传统<br/> [3]注意声明委托的位置：声明在名称空间体中<br/> 避免写错地方结果声明成嵌套类型<br/> [4]委托与所封装的方法必须“类型兼容”：<br/> delegate double Calc(double x, double y);</h2>
<pre><code>     	  double Add(double x, double y)     { return x + y; }
     	  double Sub(double x, double y)     { return x - y; }
     	  double Mul(double x, double y)     { return x * y; }
     	  double Div(double x, double y)     { return x / y; }
返回值的数据类型一致
参数列表在个数和数据类型上一致（参数名不需要一样）
</code></pre>
<p>namespace DelegateExample<br/> {<!-- --><br/> //自定义委托类型<br/> public delegate double Calc(double x, double y); //声明委托。delegate后面的double是返回值的类型。括号里加上目标方法的参数列表</p>
<pre><code>class Program
{
    static void Main(string[] args)
    {
        Calculator calculator = new Calculator();
        Calc calc1 = new Calc(calculator.Add);      //委托的实例，委托的构造函数要求在委托里面加上方法，添加方法的参数要与委托一致
        Calc calc2 = new Calc(calculator.Sub);
        Calc calc3 = new Calc(calculator.Mul);
        Calc calc4 = new Calc(calculator.Div);

        double a = 100;
        double b = 200;
        double c = 0;

        c = calc1(a, b);            //间接调用委托，类似指针的调用方法
        Console.WriteLine(c);
        c = calc2(a, b);            //间接调用委托，类似指针的调用方法
        Console.WriteLine(c);
        c = calc3.Invoke(a, b);     //间接调用委托
        Console.WriteLine(c);
        c = calc4.Invoke(a, b);     //间接调用委托
        Console.WriteLine(c);
    }
}

class Calculator
{
    public double Add(double x, double y)
    {
        return x + y;
    }

    public double Sub(double x, double y)
    {
        return x - y;
    }

    public double Mul(double x, double y)
    {
        return x * y;
    }

    public double Div(double x, double y)
    {
        return x / y;
    }
}
</code></pre>
<p>}</p>
<p>3、委托的使用<br/> [1]委托的一般使用：<br/> 实例：把方法当作参数传给另一个方法<br/> 正确使用1：模板方法，“借用”指定的外部方法来产生结果<br/> 相当于“填空题”<br/> 常位于代码中部<br/> 委托有返回值<br/> 正确使用2：回调（callback）方法，调用指定的外部方法<br/> 相当于“流水线”<br/> 常位于代码末尾<br/> 委托无返回值<br/> 【*无论是模板方法还是回调方法，都是用委托类型的参数来封装一个外部的方法，然后将这个方法传进方法的内部来进 行间接调用】<br/> 模板方法：<br/> namespace DelegateExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> ProductFactory productFactory = new ProductFactory(); //调用工厂实例<br/> WrapFactory wrapFactory = new WrapFactory(); //包装工厂的实例</p>
<pre><code>        Func&lt;Product&gt; func1 = new Func&lt;Product&gt;(productFactory.MakePizza);  //第一个委托实例，返回值为Product，参数为空。用它封装产品工厂里生产披萨饼的那个方法
        Func&lt;Product&gt; func2 = new Func&lt;Product&gt;(productFactory.MakeToyCar); //func2封装MakeToyCar方法

        //正式调用模板方法
        Box box1 = wrapFactory.WrapProduct(func1);      //用Box类型的变量box1接收返回值。func1作为参数，代进了WrapProduct方法，将结果赋给box1
        Box box2 = wrapFactory.WrapProduct(func2);

        Console.WriteLine(box1.Product.Name);
        Console.WriteLine(box2.Product.Name);
    }
}

class Product   //产品类
{
    public string Name { get; set; }    //每个产品都有自己的名字
}

class Box   //包装箱类
{
    public Product Product { get; set; }    //每个包装箱里都有一个product属性，就是所包装的产品
}

class WrapFactory   //把产品包装上盒子给用户
{
    //为了方法的复用，将参数设为委托，传入一个方法，那所有的元素都能进行这个操作了
    public Box WrapProduct(Func&lt;Product&gt; getProduct)    //模板方法,接收一个委托类型的参数（Function委托）。所封装的方法能返回Product类型的对象
    {
        //模板方法的逻辑：
        Box box = new Box();                    //Box实例
        Product product = getProduct.Invoke();  //调用完后获得一个Product类型的对象（拿到Product）
        box.Product = product;                  //将box的Product属性的值，设为刚刚拿到的product（将Product包装到Box里）
        return box;
    }
}

class ProductFactory        //生产产品的工厂
{
    public Product MakePizza()          //Pizzar工厂，返回值为Product类型，参数为空
    {
        Product product = new Product();
        product.Name = "Pizza";     //产品名
        return product;
    }

    public Product MakeToyCar()         //玩具汽车工厂
    {
        Product product = new Product();
        product.Name = "ToyCar";
        return product;
    }
}
</code></pre>
<p>}</p>
<p>回调方法：<br/> namespace DelegateExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> ProductFactory productFactory = new ProductFactory(); //调用工厂实例<br/> WrapFactory wrapFactory = new WrapFactory(); //包装工厂的实例</p>
<pre><code>        Func&lt;Product&gt; func1 = new Func&lt;Product&gt;(productFactory.MakePizza);  //第一个委托实例，返回值为Product，参数为空。用它封装产品工厂里生产披萨饼的那个方法
        Func&lt;Product&gt; func2 = new Func&lt;Product&gt;(productFactory.MakeToyCar); //func2封装MakeToyCar方法

        Logger logger = new Logger();                           //声明实例
        Action&lt;Product&gt; log = new Action&lt;Product&gt;(logger.Log);  //委托实例

        //正式调用模板方法
        Box box1 = wrapFactory.WrapProduct(func1,log);      //用Box类型的变量box1接收返回值。func1作为参数，代进了WrapProduct方法，将结果赋给box1
        Box box2 = wrapFactory.WrapProduct(func2,log);

        Console.WriteLine(box1.Product.Name);
        Console.WriteLine(box2.Product.Name);
    }
}

class Logger    //记录程序运行状态
{
    public void Log(Product product)    //没有返回值，只做记录
    {
        Console.WriteLine("Product '{0}' create at {1}.Price is {2}.", product.Name, DateTime.UtcNow, product.Price);   //DateTime.UtcNow表示没有时区的时间
    }
}

class Product   //产品类
{
    public string Name { get; set; }    //每个产品都有自己的名字
    public double Price { get; set; }
}

class Box   //包装箱类
{
    public Product Product { get; set; }    //每个包装箱里都有一个product属性，就是所包装的产品
}

class WrapFactory   //把产品包装上盒子给用户
{
    //为了方法的复用，将参数设为委托，传入一个方法，那所有的元素都能进行这个操作了
    public Box WrapProduct(Func&lt;Product&gt; getProduct,Action&lt;Product&gt; logCallba)    //模板方法,接收一个委托类型的参数（Function委托）。所封装的方法能返回Product类型的对象
    {
        //模板方法的逻辑：
        Box box = new Box();                    //Box实例
        Product product = getProduct.Invoke();  //调用完后获得一个Product类型的对象（拿到Product）
        if (product.Price&gt;=50)                  //价格超过50就log一下
        {
            logCallba(product);
        }

        box.Product = product;                  //将box的Product属性的值，设为刚刚拿到的product（将Product包装到Box里）
        return box;
    }
}

class ProductFactory        //生产产品的工厂
{
    public Product MakePizza()          //Pizzar工厂，返回值为Product类型，参数为空
    {
        Product product = new Product();
        product.Name = "Pizza";     //产品名
        product.Price = 12;
        return product;
    }

    public Product MakeToyCar()         //玩具汽车工厂
    {
        Product product = new Product();
        product.Name = "ToyCar";
        product.Price = 200;
        return product;
    }
}
</code></pre>
<p>}</p>
<p>注意：难精通+易使用+功能强大东西，一旦被滥用则后果非常严重：<br/> 缺点1：这是一种方法级别的紧耦合（违反设计模式），现实工作中一定要慎之又慎<br/> 缺点2：使用不当的话，使可读性下降、debug的难度增加<br/> 缺点3：把委托回调、异步调用和多线程纠缠在一起，会让代码变得难以阅读和维护<br/> 缺点4：委托使用不当有可能造成内存泄漏和程序性能下降</p>
<p>[2]委托的高级使用：<br/> 【1】多播（multicast）委托：一个委托里封装着不止一个方法。<br/> namespace MulticastDelegateExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> Student stu1 = new Student() { ID = 1, PenColor = ConsoleColor.Yellow };<br/> Student stu2 = new Student() { ID = 2, PenColor = ConsoleColor.Green };<br/> Student stu3 = new Student() { ID = 3, PenColor = ConsoleColor.Red };<br/> //创建委托<br/> Action action1 = new Action(stu1.DoHomework);<br/> Action action2 = new Action(stu2.DoHomework);<br/> Action action3 = new Action(stu3.DoHomework);</p>
<pre><code>        //调用委托，单播委托
        //action1.Invoke();
        //action2.Invoke();
        //action3.Invoke();

        //多播委托（action1封装有顺序）
        action1 += action2;     //将action2合并到action1里
        action1 += action3;     //将action3合并到action1里

        action1.Invoke();       //action1里封装了三个方法
    }
}

class Student
{
    public int ID { get; set; }
    public ConsoleColor PenColor { get; set; }

    public void DoHomework()                    //实例方法
    {
        for (int i = 0; i &lt; 5; i++)
        {
            Console.ForegroundColor = this.PenColor;
            Console.WriteLine("Student {0} doing homework {1} hour(s).",this.ID,i);
            Thread.Sleep(1000);                //1000毫秒==1秒
        }
    }
}
</code></pre>
<p>}</p>
<p>隐式异步调用：<br/> 同步与异步的简介：<br/> 中英文的语言差异；<br/> 同步：你做完了我（在你的基础上）接着做；<br/> 异步：咱们两个同时做（相当于汉语中的“同步进行”）。<br/> 同步调用与异步调用：<br/> 每一个运行的程序是一个进程（process）；<br/> 每个进程可以有一个或多个线程（thread）；<br/> 同步调用是在同一线程内；<br/> 异步调用的底层机理是多线程；<br/> 串行<mark>同步</mark>单线程，并行<mark>异步</mark>多线程。<br/> 隐式多线程V.S. 显式多线程：<br/> 直接同步调用：使用方法名；<br/> 间接同步调用：使用单播/多播委托的Invoke方法；<br/> 隐式异步调用：使用委托的BeginInvoke；<br/> 显示异步调用：使用Thread或Task。<br/> /<em>同步代码</em>/<br/> namespace MulticastDelegateExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> Student stu1 = new Student() { ID = 1, PenColor = ConsoleColor.Yellow };<br/> Student stu2 = new Student() { ID = 2, PenColor = ConsoleColor.Green };<br/> Student stu3 = new Student() { ID = 3, PenColor = ConsoleColor.Red };</p>
<pre><code>        ///*直接同步调用：用方法名字直接调用方法*/
        //stu1.DoHomework();      //直接调用三个方法，前一个执行完，再执行后一个方法
        //stu2.DoHomework();
        //stu3.DoHomework();

        /*第二种：单播委托间接、同步调用*/
        Action action1 = new Action(stu1.DoHomework);
        Action action2 = new Action(stu2.DoHomework);
        Action action3 = new Action(stu3.DoHomework);

        //action1.Invoke();
        //action2.Invoke();
        //action3.Invoke();

        /*第三种：多播委托的间接、同步调用*/
        action1 += action2;
        action1 += action3;
        action1.Invoke();

        for (int i = 0; i &lt; 10; i++)    //调用完方法后，主线程还有事情要做
        {
            Console.ForegroundColor = ConsoleColor.Cyan;
            Console.WriteLine("Main thread {0}.",i);
            Thread.Sleep(1000);
        }
    }
}

class Student
{
    public int ID { get; set; }
    public ConsoleColor PenColor { get; set; }

    public void DoHomework()                    //实例方法
    {
        for (int i = 0; i &lt; 5; i++)             
        {
            Console.ForegroundColor = this.PenColor;
            Console.WriteLine("Student {0} doing homework {1} hour(s).", this.ID, i);
            Thread.Sleep(1000);                //1000毫秒==1秒
        }
    }
}
</code></pre>
<p>}</p>
<p>/<em>使用委托进行隐式的异步调用代码示例：</em>/<br/> namespace MulticastDelegateExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> Student stu1 = new Student() { ID = 1, PenColor = ConsoleColor.Yellow };<br/> Student stu2 = new Student() { ID = 2, PenColor = ConsoleColor.Green };<br/> Student stu3 = new Student() { ID = 3, PenColor = ConsoleColor.Red };</p>
<pre><code>        Action action1 = new Action(stu1.DoHomework);
        Action action2 = new Action(stu2.DoHomework);
        Action action3 = new Action(stu3.DoHomework);

        //使用委托进行隐式异步调用（使用BeginInvoke方法进行隐式异步调用）
        //主线程和三个分支线程会一起执行，谁也不会等着谁。因此，有可能会在争抢资源时发生冲突。
        action1.BeginInvoke(null, null);
        action2.BeginInvoke(null, null);
        action3.BeginInvoke(null, null);

        for (int i = 0; i &lt; 10; i++)    //调用完方法后，主线程
        {
            Console.ForegroundColor = ConsoleColor.Cyan;
            Console.WriteLine("Main thread {0}.",i);
            Thread.Sleep(1000);
        }
    }
}

class Student
{
    public int ID { get; set; }
    public ConsoleColor PenColor { get; set; }

    public void DoHomework()                    //实例方法
    {
        for (int i = 0; i &lt; 5; i++)             
        {
            Console.ForegroundColor = this.PenColor;
            Console.WriteLine("Student {0} doing homework {1} hour(s).", this.ID, i);
            Thread.Sleep(1000);                //1000毫秒==1秒
        }
    }
}
</code></pre>
<p>}</p>
<p>/<em>显式的异步调用（即我们自己声明多线程）</em>/<br/> namespace MulticastDelegateExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> Student stu1 = new Student() { ID = 1, PenColor = ConsoleColor.Yellow };<br/> Student stu2 = new Student() { ID = 2, PenColor = ConsoleColor.Green };<br/> Student stu3 = new Student() { ID = 3, PenColor = ConsoleColor.Red };</p>
<pre><code>        //显式的异步调用：
        ///*第一种：（古老）使用Thread创建三个线程*/
        //Thread thread1 = new Thread(new ThreadStart(stu1.DoHomework));
        //Thread thread2 = new Thread(new ThreadStart(stu2.DoHomework));
        //Thread thread3 = new Thread(new ThreadStart(stu3.DoHomework));
        启动线程：
        //thread1.Start();
        //thread2.Start();
        //thread3.Start();

        /*第二种：使用Task进行显式异步调用*/
        Task task1 = new Task(new Action(stu1.DoHomework));
        Task task2 = new Task(new Action(stu2.DoHomework));
        Task task3 = new Task(new Action(stu3.DoHomework));
        //启动线程：
        task1.Start();
        task2.Start();
        task3.Start();

        for (int i = 0; i &lt; 10; i++)    //调用完方法后，主线程
        {
            Console.ForegroundColor = ConsoleColor.Cyan;
            Console.WriteLine("Main thread {0}.",i);
            Thread.Sleep(1000);
        }
    }
}

class Student
{
    public int ID { get; set; }
    public ConsoleColor PenColor { get; set; }

    public void DoHomework()                    //实例方法
    {
        for (int i = 0; i &lt; 5; i++)             
        {
            Console.ForegroundColor = this.PenColor;
            Console.WriteLine("Student {0} doing homework {1} hour(s).", this.ID, i);
            Thread.Sleep(1000);                //1000毫秒==1秒
        }
    }
}
</code></pre>
<p>}</p>
<p>【2】应该适时地使用接口（interface）取代一些对委托的使用：<br/> Java完全地使用接口取代了委托的功能，即Java没有与C#中委托相对应的功能实体。<br/> namespace DelegateExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> IProductFactory pizzaFactory = new PizzaFactory(); //调用工厂实例<br/> IProductFactory toyCarFactory = new ToyCarFactory(); //包装工厂的实例<br/> WrapFactory wrapFactory = new WrapFactory();</p>
<pre><code>        //正式调用模板方法
        Box box1 = wrapFactory.WrapProduct(pizzaFactory);      //用Box类型的变量box1接收返回值。func1作为参数，代进了WrapProduct方法，将结果赋给box1
        Box box2 = wrapFactory.WrapProduct(toyCarFactory);

        Console.WriteLine(box1.Product.Name);
        Console.WriteLine(box2.Product.Name);
    }
}

interface IProductFactory   //使用接口取代委托
{
    Product Make();         //这个接口只有一个方法，接口的返回值类型是Product
}

class PizzaFactory : IProductFactory      //披萨工厂类，实现IProductFactory接口
{

    public Product Make()
    {
        Product product = new Product();
        product.Name = "Pizza";     //产品名
        product.Price = 12;
        return product;
    }
}

class ToyCarFactory : IProductFactory      //玩具汽车工厂类，实现IProductFactory接口
{

    public Product Make()
    {
        Product product = new Product();
        product.Name = "ToyCar";
        product.Price = 200;
        return product;
    }
}


class Product   //产品类
{
    public string Name { get; set; }    //每个产品都有自己的名字
    public double Price { get; set; }
}

class Box   //包装箱类
{
    public Product Product { get; set; }    //每个包装箱里都有一个product属性，就是所包装的产品
}

class WrapFactory   //把产品包装上盒子给用户
{
    //为了方法的复用，将参数设为委托，传入一个方法，那所有的元素都能进行这个操作了
    public Box WrapProduct(IProductFactory productFactory)    //模板方法。需要工厂类型参数
    {
        //模板方法的逻辑：
        Box box = new Box();                    //Box实例
        Product product = productFactory.Make();  //调用完后获得一个Product类型的对象（拿到Product）
        box.Product = product;                  //将box的Product属性的值，设为刚刚拿到的product（将Product包装到Box里）
        return box;
    }
}
</code></pre>
<p>}</p>
<p>十一、事件<br/> 1、初步了解事件<br/> 【1】定义：单词Event，译为“事件”<br/> 《牛津词典》中的解释是“a thing that happens, especially something important”<br/> 通顺的解释就是“能够发生的什么事情”<br/> 【2】角色：使对象或类具备通知能力的成员<br/> （中译）事件（event）是一种使对象或类能够提供通知的成员<br/> （原文）An event is a menber that enables an object or class to provide notifications.<br/> "对象O拥有一个事件E"想表达的思想是：当事件E发生的时候，O有能力通知别的对象<br/> 【3】使用：用于对象或类间的动作协调与信息传递（消息推送）<br/> 经由事件发送过来的与事件本身相关的数据，称为事件参数（EventArgs）。<br/> 处理事件时具体所做的事情，叫做事件处理器。<br/> 【4】原理：事件模型（event model）中的两个“5<br/> “发生-&gt;响应”中的5个部分——闹钟响了你起床、孩子饿了你做饭……这里隐含着“订阅”关系<br/> “发生-&gt;响应”中的5个部分——[1]我有一个事件 -&gt; [2]一个人或者一群人关心我的这个事件 -&gt; [3]我的这个事 件发生了 -&gt; [4]关心这个事件的人会被一次通知到 -&gt; [5]被通知到的人根据拿到的事件信息（又称“事件数据”、 “事件参数”、“通知”）对事件进行响应（又被“处理事件”）。<br/> 事件的功能 = 通知 + 可选的事件参数（即详细信息）<br/> 【5】提示：<br/> [1]事件多用于桌面、手机等开发的客户端编程，因为这些程序经常是用户通过事件来“驱动”的<br/> [2]各种编程语言对这个机制的实现方法不尽相同<br/> [3]Java语言里没有事件这种成员，也没有委托这种数据类型。Java的“事件”是使用接口来实现的<br/> [4]MVC、MVP、MVVM等模式，是事件模式更高级、更有效的“玩法”<br/> [5]日常开发的时候，使用已有事件的机会比较多，自己声明事件的机会比较少，所以先学使用<br/> 2、事件的应用<br/> 【1】实例演示<br/> 派生（继承）与扩展（extends）<br/> 【2】事件模型的五个组成部分：<br/> [1]事件的拥有者（event source，对象/类）：事件的主体、事件消息的发送者都统称为事件的拥有者（方法里 的参数叫做Sender）。事件不会主动通知。在事件的拥有者完成某个逻辑之后，明确的告诉事件成员需要通知， 事件才会使用通知功能。就如Click按钮，按下时才会发生。（即，事件不会主动发生，只有当事件拥有者的内 部某些逻辑被触发后，它才能发生，能够发挥通知的作用。）<br/> [2]事件成员（event，成员）：事件自己不会主动发生的，。<br/> [3]事件的响应者（event subscriber，对象）：被通知到（即，订阅了事件）的类和对象。<br/> [4]事件处理器（event handler，[方法]成员）——本质上是一个回调方法。C#规定：用于订阅事件的事件处理 器，必须和事件遵守同一个约定。这个约定既约束了事件能够把什么样的消息发送给事件的处理器，也约束了事 件处理器能够处理什么样的约定。<br/> [5]事件订阅——把事件处理器与事件关联在一起，本质上是一种以委托类型为”基础“的约定。实现了如下三点：<br/> 第一，当事件发生时，都通知到了谁，即那些订阅了事件的对象。<br/> 第二，拿什么样的方法（事件处理器）才能够处理这些事件。<br/> 第三，事件的响应者具体拿哪个方法来处理事件。<br/> 【3】注意：<br/> -事件处理器是方法成员。<br/> -挂接事件处理器时，可以使用委托实例，也可以直接使用方法名，这是个”语法糖“。<br/> -事件处理器对事件的订阅不是随意的，匹配与否由声明事件时所使用的委托类型来检测。<br/> -事件可以同步调用也可以异步调用。<br/> -一个事件可以挂接多个事件处理器，一个事件处理器可以被多个事件所挂接。</p>
<p>【4】组合方式：（*）[1]标准的事件机制模型：是MVC、MVP等设计模式的雏形</p>
<p>namespace EventExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> //一个简单的事件<br/> Timer timer = new Timer(); //Timer是事件的拥有者<br/> timer.Interval = 1000; //设置时间间隔<br/> Boy boy = new Boy(); //事件的响应者<br/> Girl girl = new Girl();<br/> timer.Elapsed += boy.Action; //Elapsed是事件。+=：事件订阅符。(敲完Action后，双击提醒框，自动生成事件处理器)<br/> timer.Elapsed += girl.Action; //Action是事件名，最好有意义<br/> timer.Start(); //时间开始<br/> Console.ReadLine();<br/> }<br/> }</p>
<pre><code>class Boy
{
    //事件的处理器
    internal void Action(object sender, ElapsedEventArgs e)
    {
        Console.WriteLine("Jump!");     //每触发一次，跳一次舞
    }
}

class Girl
{

    internal void Action(object sender, ElapsedEventArgs e)
    {
        Console.WriteLine("Sing!");
    }
}
</code></pre>
<p>}</p>
<pre><code>	（***）[2]事件的拥有者是事件响应者的一个字段成员：使用最普遍。因为这个机制模型是Windows平		台上默认的事件订阅和处理结构。
</code></pre>
<p>namespace EventExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> MyForm form = new MyForm();<br/> form.ShowDialog();<br/> }<br/> }</p>
<pre><code>class MyForm : Form                 //4、MyForm：事件的响应者
{
    private TextBox textBook;       //文本框成员
    private Button button;          //按钮成员。1、button：事件的拥有者。button是成员

    public MyForm()                 //构造函数。
    {
        this.textBook = new TextBox();
        this.button = new Button();
        this.Controls.Add(this.button);
        this.Controls.Add(this.textBook);
        this.button.Click += this.ButtonClicked;    //2、.Click：事件。5、订阅
        this.button.Text = "Say:";
        this.button.Top = 50;       //button高度
    }

    private void ButtonClicked(object sender, EventArgs e)      //3、ButtonClicked：事件处理器
    {
        this.textBook.Text = "Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!";
    }
}
</code></pre>
<p>}</p>
<p>/<em>窗口应用代码：两种挂接的方式</em>/<br/> namespace WinFormExample<br/> {<!-- --><br/> public partial class Form1 : Form<br/> {<!-- --><br/> public Form1()<br/> {<!-- --><br/> InitializeComponent();<br/> this.button3.Click += new EventHandler(this.ButtonClicked); //第二种挂接的方式</p>
<pre><code>        this.button4.Click += delegate(object sender, EventArgs e)      //第三种挂接方式（已经弃用）。匿名委托（没有方法名，不能被调用）
        {
            this.textBox1.Text = "Hello4!";
        };

        //Lambda表达式。编译器甚至能通过委托约束来推断出这两个参数是什么数据类型的（即，可以不写参数类型就可以运行）。
        this.button5.Click += (object sender, EventArgs e) =&gt;           //第四种挂接方式（比较流行）。
        {
            this.textBox1.Text = "Hello5";
        };
    }

    private void ButtonClicked(object sender, EventArgs e)      //第一种挂接的方式
    {
        if (sender == this.button1)
        {
            this.textBox1.Text = "Hello1!";
        }

        if (sender == this.button2)
        {
            this.textBox1.Text = "Hello2!";
        }

        if (sender == this.button3)
        {
            this.textBox1.Text = "Hello3";
        }
    }
}
</code></pre>
<p>}</p>
<pre><code>	（无）[3]
</code></pre>
<p>namespace EventExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> Form form = new Form(); //form就是事件的拥有者<br/> Controller controller = new Controller(form); //事件的响应者controller<br/> form.ShowDialog(); //显示窗口<br/> }<br/> }</p>
<pre><code>class Controller
{
    private Form form;      //Form类型的字段

    public Controller(Form form)     //构造器
    {
        if (form != null)            //判断是否为空。如果一个对象是空的话，是没有办法访问事件的。
        {
            this.form = form;        //this.form里的form是字段，后面的form是传进来的参数。
            //form字段获得对象form的引用之后，挂接（+=）一个事件处理器，用Controller类里的实例（this.）作为事件处理器，名字是FormClicked。Click事件。
            this.form.Click += this.FormClicked;    //事件定义
        }
    }

    //参数中EventArgs约束会有所不同。也就是说，不能拿影响Elapsed事件处理器去响应Click事件——因为循环约束不同，所以他们是不通的。
    private void FormClicked(object sender, EventArgs e)       //事件处理器的方法。
    {
        this.form.Text = DateTime.Now.ToString();       //Text显示当前时间
    }
}
</code></pre>
<p>}</p>
<pre><code>	（**）[4]这个方法用自己的方法订阅着自己的事件：
</code></pre>
<p>namespace EventExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> MyForm form = new MyForm(); //4、这个实例：事件的响应者。<br/> form.Click += form.FormClickded; //2、.Click：事件。5、+=：事件订阅<br/> form.ShowDialog();<br/> }<br/> }</p>
<pre><code>class MyForm : Form     //新建类MyForm，派生自Form（继承）。1、MyForm：事件拥有者。
{

    internal void FormClickded(object sender, EventArgs e)      //3、FormClickded：事件处理器
    {
        this.Text = DateTime.Now.ToString();
    }
}
</code></pre>
<p>}</p>
<p>3、深入理解事件</p>
<p>4、事件的声明<br/> 【1】事件的声明：<br/> 完整声明：<br/> *创建事件的步骤：<br/> *1、创建事件拥有者。<br/> *2、创建委托类型OrderEventHandler。两个参数，第一个参数是事件拥有者。<br/> *3、创建事件消息数据类型OrderEventAgs，作为第二步的第二个参数。<br/> *4、在事件拥有者中创建私有字段orderEventHandler。<br/> *5、在拥有者中创建事件Order。Order包含add(添加事件处理器)和remove(移除事件处理器)<br/> *6、创建事件响应者Waiter。<br/> *7、订阅+=。把事件和事件响应者连接到一起。<br/> *8、创建事件响应者Action。<br/> namespace EventExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> Customer customer = new Customer(); //事件的拥有者<br/> Waiter waiter = new Waiter(); //事件的响应者<br/> customer.Order += waiter.Action; //使用一个叫做Action的方法作为事件的事件处理器。（Order事件；+=订阅事件；Action事件处理器）<br/> customer.Action(); //顾客进来坐下思考<br/> customer.PayTheBill(); //付账<br/> }<br/> }</p>
<pre><code>/*
 OrderEventArgs、OrderEventHandler、Customer这3个类要配合在一起使用，访问级别要相同，都使用public
 */
public class OrderEventArgs : EventArgs    //事件的名字+后缀（传递事件信息EventArgs）：传递事件消息。EventArgs是系统提供的基类
{
    public string DishName { get; set; }    //菜名

    public string Size { get; set; }        //大小份
}

//使用EventHandler有三个意义：1、使用这个名字，表明这个委托类型是专门使用事件的，别人就不会拿这个委托做其他事情
//2、表明是约束事件处理器的；3、表明这个委托未来创建出来的实例是专门存储事件处理器的。（这3点增强可读性）
public delegate void OrderEventHandler(Customer customer, OrderEventArgs e);    //创建委托，为声明事件做准备。不能放进类里。

public class Customer                               //事件的拥有者       
{
    private OrderEventHandler orderEventHandler;    //用委托类型声明一个字段，并不被外界访问到。用于引用事件处理器

    public event OrderEventHandler Order            //点菜事件。声明事件，并希望被外界访问到。用OrderEventHandler约束事件。（事件）
    {
        //事件处理器的添加器
        add 
        {
            this.orderEventHandler += value;        //接收从外界传进来的EventHandler。value是上下文关键字，表示赋进来的值。
        }
        //移除器
        remove
        {
            this.orderEventHandler -= value;
        }
    }

    public double Bill { get; set; }                //账单

    public void PayTheBill()                        //付账
    {
        Console.WriteLine("I will ${0}.", this.Bill);
    }

    public void WalkIn()                            //走进
    {
        Console.WriteLine("Walk into the restaurant.");
    }

    public void SitDown()                           //坐下
    {
        Console.WriteLine("Sit down.");
    }

    public void Think()                             //思考
    {
        for (int i = 0; i &lt; 5; i++)                 //5秒
        {
            Console.WriteLine("Let me think...");
            Thread.Sleep(1000);
        }

        if (this.orderEventHandler != null)         //（触发事件）为避免异常，判断引用存储事件处理器的委托是否为空。不为空就有人调用。
        {
            OrderEventArgs e = new OrderEventArgs();
            e.DishName = "Kongpao Chicken";
            e.Size = "large";
            this.orderEventHandler.Invoke(this,e);  //this表示自己点菜，e是菜品名字和大小份
        }
    }

    public void Action()                            //一连串调用动作。
    {
        Console.ReadLine();
        this.WalkIn();
        this.SitDown();
        this.Think();
    }
}

public class Waiter     //事件的拥有者
{

    public void Action(Customer customer, OrderEventArgs e)       //事件处理器，记账
    {
        Console.WriteLine("I will serve you the dish - {0}.",e.DishName);   //菜品名（第二个参数传进来的值）
        double price = 10;              //假设每份菜品10元
        switch (e.Size)                 
        {
            case "small":               //如果是小份，就价格减半
                price = price * 0.5;    
                break;
            case "large":               //如果是大份，价格加一半
                price = price * 1.5;
                break;
            default:
                break;
        }

        customer.Bill += price;         //将所点菜品价格相加，生成账单。（第一个参数传进来的）
    }
}
</code></pre>
<p>}<br/> 简略声明（字段式声明，field-like）：委托类型的字段依旧在，只是隐藏起来了。<br/> 注意，在Customer类内部能够使用Order事件去做非空比较以及调用Order.Invoke方法纯属不得已而为之，因 为使用事件的简化声明时，我们没有手动声明一个委托类型的字段。这是微软编译器语法糖所造成的语法冲突和 前后不一致。<br/> namespace EventExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> Customer customer = new Customer(); //事件的拥有者<br/> Waiter waiter = new Waiter(); //事件的响应者<br/> customer.Order += waiter.Action; //使用一个叫做Action的方法作为事件的事件处理器。（Order事件；+=订阅事件；Action事件处理器）<br/> customer.Action(); //顾客进来坐下思考<br/> customer.PayTheBill(); //付账<br/> }<br/> }</p>
<pre><code>/*
 OrderEventArgs、OrderEventHandler、Customer这3个类要配合在一起使用，访问级别要相同，都使用public
 */
public class OrderEventArgs : EventArgs    //事件的名字+后缀（传递事件信息EventArgs）：传递事件消息。EventArgs是系统提供的基类
{
    public string DishName { get; set; }    //菜名

    public string Size { get; set; }        //大小份
}

//使用EventHandler有三个意义：1、使用这个名字，表明这个委托类型是专门使用事件的，别人就不会拿这个委托做其他事情
//2、表明是约束事件处理器的；3、表明这个委托未来创建出来的实例是专门存储事件处理器的。（这3点增强可读性）
public delegate void OrderEventHandler(Customer customer, OrderEventArgs e);    //创建委托，为声明事件做准备。不能放进类里。

public class Customer                               //事件的拥有者       
{
    public event OrderEventHandler Order;           //声明事件。OrderEventHandler约束；Order事件名。（不是字段，和字段很像）

    public double Bill { get; set; }                //账单

    public void PayTheBill()                        //付账
    {
        Console.WriteLine("I will ${0}.", this.Bill);
    }

    public void WalkIn()                            //走进
    {
        Console.WriteLine("Walk into the restaurant.");
    }

    public void SitDown()                           //坐下
    {
        Console.WriteLine("Sit down.");
    }

    public void Think()                             //思考
    {
        for (int i = 0; i &lt; 5; i++)                 //5秒
        {
            Console.WriteLine("Let me think...");
            Thread.Sleep(1000);
        }

        if (this.Order != null)         //（触发事件）为避免异常，判断引用存储事件处理器的委托是否为空。不为空就有人调用。orderEventHandler-》Order
        {
            OrderEventArgs e = new OrderEventArgs();
            e.DishName = "Kongpao Chicken";
            e.Size = "large";
            this.Order.Invoke(this, e);  //this表示自己点菜，e是菜品名字和大小份。orderEventHandler-》Order
        }
    }

    public void Action()                            //一连串调用动作。
    {
        Console.ReadLine();
        this.WalkIn();
        this.SitDown();
        this.Think();
    }
}

public class Waiter     //事件的拥有者
{

    public void Action(Customer customer, OrderEventArgs e)       //事件处理器，记账
    {
        Console.WriteLine("I will serve you the dish - {0}.",e.DishName);   //菜品名（第二个参数传进来的值）
        double price = 10;              //假设每份菜品10元
        switch (e.Size)                 
        {
            case "small":               //如果是小份，就价格减半
                price = price * 0.5;    
                break;
            case "large":               //如果是大份，价格加一半
                price = price * 1.5;
                break;
            default:
                break;
        }

        customer.Bill += price;         //将所点菜品价格相加，生成账单。（第一个参数传进来的）
    }
}
</code></pre>
<p>}<br/> 【2】有了委托字段/属性，为什么还需要事件？<br/> 事件只能在“+=”或“-=”的左边，如果是字段，就会被滥用。<br/> 为了程序的逻辑更加”有道理“、更加安全，谨防”借刀杀人“。例子如下：<br/> namespace EventExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> Customer customer = new Customer();<br/> Waiter waiter = new Waiter();<br/> customer.Order += waiter.Action;<br/> //customer.Action();</p>
<pre><code>        OrderEventArgs e = new OrderEventArgs();
        e.DishName = "Quanxi";
        e.Size = "large";

        OrderEventArgs e2 = new OrderEventArgs();
        e2.DishName = "Beer";
        e2.Size = "large";

        Customer badGuy=new Customer();
        badGuy.Order += waiter.Action;
        badGuy.Order.Invoke(customer, e);
        badGuy.Order.Invoke(customer, e2);

        customer.PayTheBill();
    }
}

public class OrderEventArgs : EventArgs
{
    public string DishName { get; set; }
    public string Size { get; set; }
}

public delegate void OrderEventHandler(Customer customer, OrderEventArgs e);

public class Customer
{
    public  OrderEventHandler Order;

    public double Bill { get; set; }

    public void PayTheBill()
    {
        Console.WriteLine("I will pay the bill ${0}.", this.Bill);
    }

    public void WalkIn()
    {
        Console.WriteLine("Walk in the restaurant.");
    }

    public void SitDown()
    {
        Console.WriteLine("Sit down.");
    }

    public void Think()
    {
        for (int i = 0; i &lt; 5; i++)
        {
            Console.WriteLine("Tinking...");
            Thread.Sleep(1000);
        }

        if (this.Order != null)
        {
            OrderEventArgs e = new OrderEventArgs();
            e.DishName = "Kongpao";
            e.Size = "large";
            this.Order.Invoke(this, e);
        }
    }

    public void Action()
    {
        Console.ReadLine();
        this.WalkIn();
        this.SitDown();
        this.Think();
    }
}

public class Waiter
{

    internal void Action(Customer customer, OrderEventArgs e)
    {
        Console.WriteLine("I will serve the dish-{0}", e.DishName);
        double price = 10;
        switch (e.Size)
        {
            case "small":
                price *= 0.5;
                break;
            case "large":
                price *= 1.5;
                break;
            default:
                break;
        }
        customer.Bill += price;
    }
}
</code></pre>
<p>}</p>
<p>【3】所以事件的本质是委托字段的一个包装器：<br/> 这个包装器对委托字段的访问起限制作用，相当于一个”蒙板“；<br/> 封装（encapsulation）的一个重要功能就是隐藏；<br/> 事件对外界隐藏了委托实例的大部分功能，仅暴露添加/移除事件处理器的功能；<br/> 添加/移除事件处理器的时候可以 直接使用方法名，这是委托实例所不具的功能。<br/> 【4】用于声明事件的委托类型的命名约定：<br/> [1]用于声明Foo事件的委托，一般命名为FoolEventHandler（除非是一个非常通用的事件约束）。<br/> namespace EventExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> Customer customer = new Customer(); //事件的拥有者<br/> Waiter waiter = new Waiter(); //事件的响应者<br/> customer.Order += waiter.Action; //使用一个叫做Action的方法作为事件的事件处理器。（Order事件；+=订阅事件；Action事件处理器）<br/> customer.Action(); //顾客进来坐下思考<br/> customer.PayTheBill(); //付账<br/> }<br/> }</p>
<pre><code>/*
 OrderEventArgs、OrderEventHandler、Customer这3个类要配合在一起使用，访问级别要相同，都使用public
 */
public class OrderEventArgs : EventArgs    //事件的名字+后缀（传递事件信息EventArgs）：传递事件消息。EventArgs是系统提供的基类
{
    public string DishName { get; set; }    //菜名

    public string Size { get; set; }        //大小份
}

//使用EventHandler有三个意义：1、使用这个名字，表明这个委托类型是专门使用事件的，别人就不会拿这个委托做其他事情
//2、表明是约束事件处理器的；3、表明这个委托未来创建出来的实例是专门存储事件处理器的。（这3点增强可读性）
//public delegate void OrderEventHandler(Customer customer, OrderEventArgs e);    //创建委托，为声明事件做准备。不能放进类里。

public class Customer                               //事件的拥有者       
{
    //event:声明事件的关键字，不加就会变成字段定义。事件的作用是防止字段被滥用，增加安全性。
    //EventHandler委托：厂商为我们准备好的一个通用的专门用于去声明事件的委托类型。如果使用EventHandler，就不用声明委托了。
    public event EventHandler Order;           //声明事件。OrderEventHandler约束；Order事件名。（不是字段，和字段很像）。

    public double Bill { get; set; }                //账单

    public void PayTheBill()                        //付账
    {
        Console.WriteLine("I will ${0}.", this.Bill);
    }

    public void WalkIn()                            //走进
    {
        Console.WriteLine("Walk into the restaurant.");
    }

    public void SitDown()                           //坐下
    {
        Console.WriteLine("Sit down.");
    }

    public void Think()                             //思考
    {
        for (int i = 0; i &lt; 5; i++)                 //5秒
        {
            Console.WriteLine("Let me think...");
            Thread.Sleep(1000);
        }

        if (this.Order != null)         //（触发事件）为避免异常，判断引用存储事件处理器的委托是否为空。不为空就有人调用。orderEventHandler-》Order
        {
            OrderEventArgs e = new OrderEventArgs();
            e.DishName = "Kongpao Chicken";
            e.Size = "large";
            this.Order.Invoke(this, e);  //this表示自己点菜，e是菜品名字和大小份。orderEventHandler-》Order
        }
    }

    public void Action()                            //一连串调用动作。
    {
        Console.ReadLine();
        this.WalkIn();
        this.SitDown();
        this.Think();
    }
}

public class Waiter     //事件的拥有者
{

    public void Action(object sender, EventArgs e)       //事件处理器，记账
    {
        Customer customer = sender as Customer;          //做类型转换
        OrderEventArgs orderInfo = e as OrderEventArgs;
        Console.WriteLine("I will serve you the dish - {0}.",orderInfo.DishName);   //菜品名（第二个参数传进来的值）
        double price = 10;              //假设每份菜品10元
        switch (orderInfo.Size)                 
        {
            case "small":               //如果是小份，就价格减半
                price = price * 0.5;    
                break;
            case "large":               //如果是大份，价格加一半
                price = price * 1.5;
                break;
            default:
                break;
        }

        customer.Bill += price;         //将所点菜品价格相加，生成账单。（第一个参数传进来的）
    }
}
</code></pre>
<p>}<br/> [2]FoolEventHandler委托的参数一般有两个（由Win32 API演化而来，历史悠久）：<br/> 第一个参数是object类型，名字为sender，实际上就是事件的拥有者、事件的source。<br/> 第二个是EventArgs类的派生类，类名一般为FooEventArgs，参数名为e。也就是前面讲过的事件参数。<br/> 虽然没有官方的说法，但是我们可以把委托的参数列表看做是事件发生后发送给事件响应者的“事件消息”。<br/> [3]触发Foo事件的方法一般命名为OnFoo，即“因何引发”、“事出有因”：<br/> 访问级别为protected，不能为public，不然又成了可以“借刀杀人”了。【protected：被自己的成员访问】<br/> namespace EventExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> Customer customer = new Customer(); //事件的拥有者<br/> Waiter waiter = new Waiter(); //事件的响应者<br/> customer.Order += waiter.Action; //使用一个叫做Action的方法作为事件的事件处理器。（Order事件；+=订阅事件；Action事件处理器）<br/> customer.Action(); //顾客进来坐下思考<br/> customer.PayTheBill(); //付账<br/> }<br/> }</p>
<pre><code>/*
 OrderEventArgs、OrderEventHandler、Customer这3个类要配合在一起使用，访问级别要相同，都使用public
 */
public class OrderEventArgs : EventArgs    //事件的名字+后缀（传递事件信息EventArgs）：传递事件消息。EventArgs是系统提供的基类
{
    public string DishName { get; set; }    //菜名

    public string Size { get; set; }        //大小份
}

//使用EventHandler有三个意义：1、使用这个名字，表明这个委托类型是专门使用事件的，别人就不会拿这个委托做其他事情
//2、表明是约束事件处理器的；3、表明这个委托未来创建出来的实例是专门存储事件处理器的。（这3点增强可读性）
//public delegate void OrderEventHandler(Customer customer, OrderEventArgs e);    //创建委托，为声明事件做准备。不能放进类里。

public class Customer                               //事件的拥有者
{
    //event:声明事件的关键字，不加就会变成字段定义。事件的作用是防止字段被滥用，增加安全性。
    //EventHandler委托：厂商为我们准备好的一个通用的专门用于去声明事件的委托类型。如果使用EventHandler，就不用声明委托了。
    public event EventHandler Order;           //声明事件。OrderEventHandler约束；Order事件名。（不是字段，和字段很像）。

    public double Bill { get; set; }                //账单

    public void PayTheBill()                        //付账
    {
        Console.WriteLine("I will ${0}.", this.Bill);
    }

    public void WalkIn()                            //走进
    {
        Console.WriteLine("Walk into the restaurant.");
    }

    public void SitDown()                           //坐下
    {
        Console.WriteLine("Sit down.");
    }

    public void Think()                             //思考
    {
        for (int i = 0; i &lt; 5; i++)                 //5秒
        {
            Console.WriteLine("Let me think...");
            Thread.Sleep(1000);
        }

        this.OnOrder("Kongpao Chicken", "large");
    }

    protected void OnOrder(string dishName, string size)    //触发Order事件的方法
    {
        if (this.Order != null)         //（触发事件）为避免异常，判断引用存储事件处理器的委托是否为空。不为空就有人调用。orderEventHandler-》Order
        {
            OrderEventArgs e = new OrderEventArgs();
            e.DishName = dishName;
            e.Size = size;
            this.Order.Invoke(this, e);  //this表示自己点菜(即事件的拥有者)，e是菜品名字和大小份。orderEventHandler-》Order
        }
    }

    public void Action()                            //一连串调用动作。
    {
        Console.ReadLine();
        this.WalkIn();
        this.SitDown();
        this.Think();
    }
}

public class Waiter     //事件的拥有者
{

    public void Action(object sender, EventArgs e)       //事件处理器，记账
    {
        Customer customer = sender as Customer;          //做类型转换
        OrderEventArgs orderInfo = e as OrderEventArgs;
        Console.WriteLine("I will serve you the dish - {0}.",orderInfo.DishName);   //菜品名（第二个参数传进来的值）
        double price = 10;              //假设每份菜品10元
        switch (orderInfo.Size)                 
        {
            case "small":               //如果是小份，就价格减半
                price = price * 0.5;    
                break;
            case "large":               //如果是大份，价格加一半
                price = price * 1.5;
                break;
            default:
                break;
        }

        customer.Bill += price;         //将所点菜品价格相加，生成账单。（第一个参数传进来的）
    }
}
</code></pre>
<p>}<br/> 【5】事件的命名约定：<br/> 带有时态的动词或者动词短语；<br/> 事件拥有者“正在做”什么事情，用进行时；事件拥有者“做完了”什么事情，用完成时。<br/> 【6】事件是基于委托的，有两层意思：（委托是底层基础，事件是上层建筑）<br/> （1）事件需要用委托类型来做一个约束，这个约束既规定事件能够发送什么消息给事件的响应者，也规定了事件 响应者能收到什么样的事件消息。这就决定了事件响应者的事件处理器，必须能够和这个约束匹配上，它才能订 阅这个事件。<br/> （2）当事件的响应者对事件的拥有者提供能够匹配这个事件处理器的事件之后，需要找个地方将事件处理器保存 记录起来，能够记录或者说引用方法的任务也只有委托类型的实例才能做到。<br/> 总结，事件这种成员，无论是从表层约束这层来讲，还是底层实现来讲，它都是依赖于委托类型的。<br/> 【7】事件与委托的关系</p>
<p>5、问题辨析<br/> [1]事件真的是“以特殊方式声明的委托字段/实例”吗？<br/> 不是！只是声明的时候“看起来像”（对比委托字段与事件的简化声明，field-like）。<br/> 事件声明的时候使用了委托类型，简化声明造成事件看上去像一个委托的字段（实例），而event关键 字则更像是一个修饰符——这就是错觉的来源之一。<br/> 订阅事件的时候+=操作符后面可以是一个委托实例，这与委托实例的赋值方法语法相同，这也让事件看 起来像是一个委托字段——这是错觉的又一来源。<br/> 重申：事件的本质是加装在委托字段上的一个“蒙板”绝不是委托字段本身。<br/> [2]为什么要使用委托类型来声明事件？<br/> 站在source的角度来看，是为了表明source能对外传递哪些消息。<br/> 站在subscriber的角度来看，它是一种约定，是为了约束能够使用什么样签名的方法来处理(响应)事件。<br/> 委托类型的实例将用于存储（引用）事件处理器。<br/> [3]对比事件与属性：<br/> 属性不是字段——很多时候属性是字段的包装器，这个包装器用来保护字段不被滥用。<br/> 事件不是委托字段——它是委托字段的包装器，这个包装器用来保护委托字段不被滥用。<br/> 包装器永远都不可能是被包装的东西。</p>
<p>namespace EventExample<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> Customer customer = new Customer();<br/> Waiter waiter = new Waiter();<br/> customer.Order += waiter.Action;<br/> customer.Action();<br/> customer.PayBill();<br/> }<br/> }</p>
<pre><code>public class OrderEventArgs : EventArgs    //创建数据类型，作为委托类型的第二个参数
{
    public string DishName { get; set; }
    public string Size { get; set; }
}

public delegate void OrderEventHandler(Customer customer, OrderEventArgs e);      //第二个参数的名字一般写作“e”。委托类型：声明Order事件。

public class Customer
{
    private OrderEventHandler orderEventHandler;    //这个委托字段就是用来存储、引用那些事件处理器的

    public event OrderEventHandler Order            //事件。用OrderEventHandler约束事件
    {
        add                                         //添加器
        {
            this.orderEventHandler += value;        //用value存储传进来的EventHandler
        }

        remove                                      //移除器
        {
            this.orderEventHandler -= value;
        }
    }

    public double Bill { get; set; }

    public void PayBill()
    {
        Console.WriteLine("I will pay ${0}.", this.Bill);
    }

    public void WalkIn()
    {
        Console.WriteLine("Walk into the restaurant.");
    }

    public void SitDwon()
    {
        Console.WriteLine("Sit dwon.");
    }

    public void Think()
    {
        for (int i = 0; i &lt; 5; i++)
        {
            Console.WriteLine("Let me think...");
            Thread.Sleep(1000);
        }

        if (this.orderEventHandler != null)
        {
            OrderEventArgs e = new OrderEventArgs();
            e.DishName = "Kongpao Chicken";
            e.Size = "large";
            this.orderEventHandler.Invoke(this, e);
        }
    }

    public void Action()
    {
        Console.ReadLine();
        this.WalkIn();
        this.SitDwon();
        this.Think();
        //this.PayBill();
    }
}

public class Waiter
{

    internal void Action(Customer customer, OrderEventArgs e)
    {
        Console.WriteLine("I will serve you the dish - {0}.", e.DishName);
        double price = 10;
        switch (e.Size)
        {
            case "small":
                price *= 0.5;
                break;
            case "large":
                price *= 1.5;
                break;
            default:
                break;
        }

        customer.Bill += price;
    }
}
</code></pre>
<p>}</p>
<p>十二、Linq<br/> 1、委托：<br/> 【1】什么是委托？</p>
<p>【2】委托类型是怎么声明出来的？<br/> namespace Combine<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> MyDele dele1 = new MyDele(M1); //dele1这个变量引用着一个MyDele类型的实例，这个实例里“包裹”着M1这个方法<br/> //dele1 += (new Student()).SayHello; //dele1也包裹着Student.SayHello方法。简写，省略了实例的引用<br/> //dele1(); //dele1.Invoke();省略而来。<br/> }</p>
<pre><code>    static void M1()
    {
        Console.WriteLine("M1 is called.");
    }
}

class Student
{
    public void SayHello()
    {
        Console.WriteLine("Hello,I'm a student!");
    }
}

delegate int MyDele(int a,int b);     //创建委托
</code></pre>
<p>}<br/> 【3】泛型委托：<br/> [1]自定义委托<br/> namespace Combine<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> MyDele deleAdd = new MyDele(Add); //int类型的委托<br/> int result1 = deleAdd(100, 200);<br/> Console.WriteLine(result1);<br/> MyDele deleMul = new MyDele(Mul); //double类型的委托<br/> double result2 = deleMul(3.0, 4.0);<br/> Console.WriteLine(result2);<br/> Console.WriteLine(deleAdd.GetType().IsClass); //判断deleAdd是否为类<br/> }</p>
<pre><code>    static int Add(int a, int b)
    {
        return a + b;
    }

    static double Mul(double x, double y)
    {
        return x * y;
    }
}

delegate T MyDele&lt;T&gt;(T a, T b);         //定义泛型委托
</code></pre>
<p>}</p>
<pre><code>[2]Action委托：
</code></pre>
<p>namespace Combine<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> Action&lt;string, int&gt; action = new Action&lt;string, int&gt;(SayHello); //Action委托的&lt;&gt;中的数据类型要与所包裹方法的参数类型一致<br/> action(“LGQ”, 23);<br/> }</p>
<pre><code>    static void SayHello(string name, int round) {
        for (int i = 0; i &lt; round; i++)
        {
            Console.WriteLine("Hello, " + name + " .");
        }
    }

    static int Add(int a, int b)
    {
        return a + b;
    }

    static double Mul(double x, double y)
    {
        return x * y;
    }
}
</code></pre>
<p>}</p>
<pre><code>[3]Function委托：
</code></pre>
<p>namespace Combine<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> var fun = new Func&lt;double, double, double&gt;(Mul); //Func&lt;double, double, double&gt;用var来替代<br/> double result = fun(3.0, 4.0);<br/> Console.WriteLine(result);<br/> }</p>
<pre><code>    static void SayHello(string name, int round) {
        for (int i = 0; i &lt; round; i++)
        {
            Console.WriteLine("Hello, " + name + " .");
        }
    }

    static int Add(int a, int b)
    {
        return a + b;
    }

    static double Mul(double x, double y)
    {
        return x * y;
    }
}
</code></pre>
<p>}</p>
<p>【4】我们必须自己创建委托类型吗？</p>
<p>【5】泛型委托的类型参数推断：</p>
<p>2、Lambda：<br/> 【1】方法与Lambda之间的关系：<br/> Lambda表达式<br/> 作用：<br/> 1、匿名方法<br/> 2、Inline方法<br/> namespace Combine<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> //(int a, int b) =&gt; { return a + b; }：Lambda表达式<br/> Func&lt;int, int, int&gt; func = new Func&lt;int, int, int&gt;((int a, int b) =&gt; { return a + b; });<br/> int result = func(100, 200);<br/> Console.WriteLine(result);</p>
<pre><code>        func = new Func&lt;int, int, int&gt;((int a, int b) =&gt; { return a * b; });
        result = func(3, 4);
        Console.WriteLine(result);

        func = new Func&lt;int, int, int&gt;((a, b) =&gt; { return a * b; });
        result = func(3, 4);
        Console.WriteLine(result);

        func = (a, b) =&gt; { return a + b; };     //最简约的Lambda表达式
        result = func(100, 200);
        Console.WriteLine(result);
    }
}
</code></pre>
<p>}</p>
<p>【2】如何把一个Lambda表达式赋值给一个委托类型变量：<br/> 【3】如何把一个Lambda表达式“喂”给一个委托类型参数：<br/> namespace Combine<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> //DoSomeCalc((int a, int b) =&gt; { return a * b; },100,100);<br/> //DoSomeCalc((a, b) =&gt; { return a * b; }, 100, 100);<br/> DoSomeCalc((a, b) =&gt; { return a * b; }, 100, 100); //最简语句<br/> }</p>
<pre><code>    //DoSomeCalc&lt;T&gt;：泛型方法
    //Func&lt;T, T, T&gt; func：泛型的委托类型参数
    //T x, T y：泛型参数
    static void DoSomeCalc&lt;T&gt;(Func&lt;T, T, T&gt; func, T x, T y) {   //函数的泛型&lt;T&gt;，交给了泛型委托的T，T类型的参数也传进来
        T res = func(x, y);
        Console.WriteLine(res);
    }
}
</code></pre>
<p>}<br/> 3、LINQ串讲：</p>
<p>十三、类<br/> 1、什么是“类”<br/> class-declaration:<br/> attributesopt class-modifiersopt partialopt class identifier type-parameter-listopt<br/> class-baseopt type-parameter-constraints-clausesopt class-body ;opt<br/> 【1】是一种数据结构（data structure）；<br/> 类是一种数据结构，它可以包含数据成员（常量和字段）、函数成员（方法、属性、事件、索引器、运算符、实例构造函数、静态构造函数和析构函数）以及嵌套类型。类类型支持继承，继承是一种机制，它使派生类可以对基类进行扩展和专业化。 ——《C#语言规范》 <br/> 【2】是一种数据类型；<br/> 类是一种引用类型，具体到每一个类上，每一个类都是一个自定义的引用类型。类可以声明变量，可以声明实例。<br/> /<em>用new创建实例</em>/<br/> namespace HelloClass {<!-- --><br/> class Program {<!-- --><br/> static void Main(string[] args) {<!-- --><br/> Student stu = new Student(1,“LGQ”);<br/> stu.Report();<br/> }<br/> }</p>
<pre><code>class Student {
    public Student(int id, string name) {       //实例构造器
        this.ID = id;
        this.Name = name;
    }

    public int ID { get; set; }
    public string Name { get; set; }
    public void Report() {
        Console.WriteLine("I'm "+this.ID+" student, my name is "+this.Name+".");
    }
}
</code></pre>
<p>}</p>
<p>/<em>反射</em>/<br/> namespace HelloClass {<!-- --><br/> class Program {<!-- --><br/> static void Main(string[] args) {<!-- --><br/> /<em>类是一种数据类型</em>/<br/> Type t = typeof(Student); //Type类型类，t是类名。一个typeof(Student)类型的t类<br/> object o = Activator.CreateInstance(t, 1, “LGQ”); //CreateInstance()创建实例的话，都是object类型的实例<br/> Console.WriteLine(o.GetType().Name);<br/> } //当调用结束后，对象就没人引用了，然后析构器就会被调用<br/> }</p>
<pre><code>class Student {
    public Student(int id, string name) {            //实例构造器
        this.ID = id;
        this.Name = name;
    }

    ~Student() {                                                 //析构器
        Console.WriteLine("Bye bye! Release the system resources...");
    }

    public int ID { get; set; }
    public string Name { get; set; }
    public void Report() {
        Console.WriteLine("I'm "+this.ID+" student, my name is "+this.Name+".");
    }
}
</code></pre>
<p>}</p>
<p>/<em>Dynamic编程</em>/<br/> namespace HelloClass {<!-- --><br/> class Program {<!-- --><br/> static void Main(string[] args) {<!-- --><br/> Type t = typeof(Student);<br/> dynamic stu = Activator.CreateInstance(t, 1, “LGQ”);<br/> Console.WriteLine(stu.Name);<br/> } //当调用结束后，对象就没人引用了，然后析构器就会被调用<br/> }</p>
<pre><code>class Student {
    public Student(int id, string name) {            //实例构造器
        this.ID = id;
        this.Name = name;
    }

    ~Student() {                                                 //析构器
        Console.WriteLine("Bye bye! Release the system resources...");
    }

    public int ID { get; set; }
    public string Name { get; set; }
    public void Report() {
        Console.WriteLine("I'm "+this.ID+" student, my name is "+this.Name+".");
    }
}
</code></pre>
<p>}</p>
<p>/<em>类中类</em>/<br/> namespace HelloClass {<!-- --><br/> class Program {<!-- --><br/> static void Main(string[] args) {<!-- --><br/> /<em>类是一种数据类型</em>/<br/> Type t = typeof(Student); //Type类型类，t是类名。一个typeof(Student)类型的t类<br/> object o = Activator.CreateInstance(t, 1, “LGQ”); //CreateInstance()创建实例的话，都是object类型的实例<br/> Student stu = o as Student; //将类型Stu从类型转变回类<br/> Console.WriteLine(stu.Name); //这样就可以输出类stu的Name属性<br/> } //当调用结束后，对象就没人引用了，然后析构器就会被调用<br/> }</p>
<pre><code>class Student {
    public Student(int id, string name) {                       //实例构造器
        this.ID = id;
        this.Name = name;
    }

    //~Student() {                                                 //析构器
    //    Console.WriteLine("Bye bye! Release the system resources...");
    //}

    public int ID { get; set; }
    public string Name { get; set; }
    public void Report() {
        Console.WriteLine("I'm "+this.ID+" student, my name is "+this.Name+".");
    }
}
</code></pre>
<p>}</p>
<p>【3】代表现实世界中的“种类”；</p>
<p>2、构造器与析构器<br/> 析构器：释放内存中的某些资源。<br/> 【1】实例；</p>
<p>/<em>析构器：</em>/<br/> namespace HelloClass {<!-- --><br/> class Program {<!-- --><br/> static void Main(string[] args) {<!-- --><br/> Student stu = new Student(1,“LGQ”);<br/> stu.Report(); <br/> } //当调用结束后，对象就没人引用了，然后析构器就会被调用<br/> }</p>
<pre><code>class Student {
    public Student(int id, string name) {       //实例构造器
        this.ID = id;
        this.Name = name;
    }

    ~Student() {                                            //析构器
        Console.WriteLine("Bye bye! Release the system resources...");
    }

    public int ID { get; set; }
    public string Name { get; set; }
    public void Report() {
        Console.WriteLine("I'm "+this.ID+" student, my name is "+this.Name+".");
    }
}
</code></pre>
<p>}</p>
<pre><code>【2】静态；
</code></pre>
<p>十四、类的声明，继承和访问控制：<br/> 1、类声明的全貌：<br/> 【1】C#类声明的位置<br/> 【2】声明既定义（C#与Java）</p>
<p>2、最简单的类声明：<br/> 【1】类的访问控制</p>
<p>3、类的继承：<br/> 【1】类在功能上的扩展（extend）<br/> namespace HelloOOP<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> Type t = typeof(Car);<br/> Type tb = t.BaseType;<br/> Type tTop = tb.BaseType;<br/> Console.WriteLine(tTop.FullName);<br/> }<br/> }</p>
<pre><code>class Vehicle
{

}

class Car : Vehicle
{

}
</code></pre>
<p>}</p>
<p>namespace HelloOOP<br/> {<!-- --><br/> class Program<br/> {<!-- --><br/> static void Main(string[] args)<br/> {<!-- --><br/> Car car = new Car();<br/> Console.WriteLine(car is Vehicle);<br/> }<br/> }</p>
<pre><code>class Vehicle
{

}

class Car : Vehicle
{

}
</code></pre>
<p>}<br/> 【2】只能继承一个基类，但可以实现多个与其接口（规范用语）<br/> 【3】类访问级别对继承的影响<br/> 【4】sealed类不能被继承<br/> 【5】特点： <br/> [*一个子类的实例也是父类的实例。父类的实例不一定是子类的实例]<br/> [*所有类最底层的基类就是Object]<br/> [*1、子类对父类成员的全盘继承，并依次传递下去，类成员只能增加不能移除的特点]<br/> [*2、派生类的访问级别不能高于基类，只能小于等于]<br/> [*3、继承就是子类在完整接收父类成员的前提下对父类进行的横向和纵向的扩展]<br/> [*横向扩展：是对类成员个数的扩充。纵向扩展：是对类成员版本的更新（即重写）。]</p>
<p>4、成员的继承与访问：<br/> 【1】派生类对基类的成员获得与访问。</p>
<pre><code class="prism language-csharp"><span class="token keyword">namespace</span> <span class="token namespace">HelloOOP</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">class</span> <span class="token class-name">Program</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> args<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">Car</span> car <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Car</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>car<span class="token punctuation">.</span>Owner<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//先从基类的构造器开始执行，构造基类对象，然后再一级一级向下进行构造，最终构造出来这个子类对象</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">class</span> <span class="token class-name">Vehicle</span>                               <span class="token comment">//创建基类,这几个类中的顶端</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">public</span> <span class="token function">Vehicle</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>Owner <span class="token operator">=</span> <span class="token string">"N/A"</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">string</span></span> Owner <span class="token punctuation">{<!-- --></span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">class</span> <span class="token class-name">Car</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">Vehicle</span></span>                         <span class="token comment">//派生类</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">public</span> <span class="token function">Car</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                            <span class="token comment">//构造函数</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>Owner <span class="token operator">=</span> <span class="token string">"Car Owner"</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">ShowOwner</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                 <span class="token comment">//打印出Owner的名字</span>
        <span class="token punctuation">{<!-- --></span>
            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token keyword">base</span><span class="token punctuation">.</span>Owner<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">//base:只能访问上一级基类的对象。因为子类把基类的所有成员继承下来了，因此this和base指向的是同一个地址</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>【2】在派生类中访问基类的成员。<br/> 【3】构造器的不可继承。</p>
<pre><code class="prism language-csharp"><span class="token keyword">namespace</span> <span class="token namespace">HelloOOP</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">class</span> <span class="token class-name">Program</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> args<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">Car</span> car <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Car</span><span class="token punctuation">(</span><span class="token string">"Liang"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>car<span class="token punctuation">.</span>Owner<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//先从基类的构造器开始执行，构造基类对象，然后再一级一级向下进行构造，最终构造出来这个子类对象</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">class</span> <span class="token class-name">Vehicle</span>                               <span class="token comment">//创建基类,这几个类中的顶端</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">public</span> <span class="token function">Vehicle</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span></span> owner<span class="token punctuation">)</span>            <span class="token comment">//带参数的构造器，系统不会再提供默认构造器</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>Owner <span class="token operator">=</span> owner<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">string</span></span> Owner <span class="token punctuation">{<!-- --></span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">class</span> <span class="token class-name">Car</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">Vehicle</span></span>                         <span class="token comment">//派生类</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//public Car():base("N/A")                            //构造函数</span>
        <span class="token comment">//{<!-- --></span>
        <span class="token comment">//    this.Owner = "Car Owner";</span>
        <span class="token comment">//}</span>

        <span class="token keyword">public</span> <span class="token function">Car</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span></span> owner<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">base</span><span class="token punctuation">(</span>owner<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">ShowOwner</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                 <span class="token comment">//打印出Owner的名字           </span>
        <span class="token punctuation">{<!-- --></span>
            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token keyword">base</span><span class="token punctuation">.</span>Owner<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">//base:只能访问上一级基类的对象。因为子类把基类的所有成员继承下来了，因此this和base指向的是同一个地址</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>[*类成员的访问级别不能高于类的]</p>
<p>5、面向对象的实现风格：<br/> 【1】Class-based<br/> 【2】Prototype-based</p>
</div>
<link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css" rel="stylesheet"/>
<link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css" rel="stylesheet"/>
</div>