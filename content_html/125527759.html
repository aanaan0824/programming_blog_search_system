<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<h1 id="%E7%9B%AE%E5%BD%95">目录</h1>
<p id="%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#%E5%89%8D%E8%A8%80">前言</a></p>
<p id="%E4%B8%80%E3%80%81%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8">一、高并发服务器</a></p>
<p id="%F0%9F%92%BB%E4%BB%80%E4%B9%88%E6%98%AF%E9%AB%98%E5%B9%B6%E5%8F%91%EF%BC%9F-toc" style="margin-left:40px;"><a href="#%F0%9F%92%BB%E4%BB%80%E4%B9%88%E6%98%AF%E9%AB%98%E5%B9%B6%E5%8F%91%EF%BC%9F">💻什么是高并发？</a></p>
<p id="%F0%9F%92%BB%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9A%84%E5%A4%84%E7%90%86%E6%8C%87%E6%A0%87%EF%BC%9F-toc" style="margin-left:40px;"><a href="#%F0%9F%92%BB%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9A%84%E5%A4%84%E7%90%86%E6%8C%87%E6%A0%87%EF%BC%9F">💻高并发的处理指标？</a></p>
<p id="%F0%9F%92%BB%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB%EF%BC%9F-toc" style="margin-left:40px;"><a href="#%F0%9F%92%BB%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB%EF%BC%9F">💻高并发和多线程的关系和区别？</a></p>
<p id="%E4%BA%8C%E3%80%81%E6%90%AD%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8%2F%E5%AE%A2%E6%88%B7%E7%AB%AF-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E6%90%AD%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8%2F%E5%AE%A2%E6%88%B7%E7%AB%AF">二、搭建服务器/客户端</a></p>
<p id="%F0%9F%92%BB%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BB%A3%E7%A0%81-toc" style="margin-left:40px;"><a href="#%F0%9F%92%BB%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BB%A3%E7%A0%81">💻服务器代码（4种类的封装）</a></p>
<p id="%F0%9F%8C%88%E5%9C%B0%E5%9D%80%E7%B1%BB%EF%BC%88CHostAddress%EF%BC%89-toc" style="margin-left:80px;"><a href="#%F0%9F%8C%88%E5%9C%B0%E5%9D%80%E7%B1%BB%EF%BC%88CHostAddress%EF%BC%89">🌈地址类【CHostAddress】</a></p>
<p id="%F0%9F%8C%88socket%E5%9F%BA%E7%B1%BB%EF%BC%88CBaseSocket%EF%BC%89-toc" style="margin-left:80px;"><a href="#%F0%9F%8C%88socket%E5%9F%BA%E7%B1%BB%EF%BC%88CBaseSocket%EF%BC%89">🌈socket类【CBaseSocket】</a></p>
<p id="%F0%9F%8C%88TCP%E6%B4%BE%E7%94%9F%E7%B1%BB%EF%BC%88CTcpServer%EF%BC%89-toc" style="margin-left:80px;"><a href="#%F0%9F%8C%88TCP%E6%B4%BE%E7%94%9F%E7%B1%BB%EF%BC%88CTcpServer%EF%BC%89">🌈TCP类【CTcpServer】</a></p>
<p id="%F0%9F%8C%88epoll%E7%B1%BB%20%EF%BC%88CEpollServer%EF%BC%89-toc" style="margin-left:80px;"><a href="#%F0%9F%8C%88epoll%E7%B1%BB%20%EF%BC%88CEpollServer%EF%BC%89">🌈epoll类 【CEpollServer】</a></p>
<p id="%F0%9F%92%BB%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BB%A3%E7%A0%81-toc" style="margin-left:40px;"><a href="#%F0%9F%92%BB%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BB%A3%E7%A0%81">💻客户端代码</a></p>
<p id="%F0%9F%92%BB%E6%A1%88%E4%BE%8B%E6%B5%8B%E8%AF%95-toc" style="margin-left:40px;"><a href="#%F0%9F%92%BB%E6%A1%88%E4%BE%8B%E6%B5%8B%E8%AF%95">💻案例测试</a></p>
<hr/>
<h1 id="%E5%89%8D%E8%A8%80">前言</h1>
<p>本文主要学习<span style="color:#be191c;"><strong>Linux内核编程</strong></span>，结合<span style="color:#be191c;"><strong>Visual Studio 2019</strong></span>进行跨平台编程，内容包括高并发服务器的介绍、服务器代码封装（socket+epoll）、服务器/客户端测试</p>
<h1 id="%E4%B8%80%E3%80%81%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8">一、高并发服务器</h1>
<p style="text-align:center;"><img alt="" height="335" src="image\0dedfc5dee0a4fdabd57bf3abb7c2a64.png" width="377"/></p>
<h2 id="%F0%9F%92%BB%E4%BB%80%E4%B9%88%E6%98%AF%E9%AB%98%E5%B9%B6%E5%8F%91%EF%BC%9F">💻什么是高并发？</h2>
<blockquote>
<p><span style="color:#be191c;"><strong>📘  高并发 </strong></span>是一种系统运行过程中遇到的一种<strong> </strong> <strong>“短时间内遇到大量操作请求”</strong>  的情况</p>
<p>      【主要发生在web系统集中大量访问收到大量请求】</p>
<p></p>
<p>🌰举个例子：12306的抢票情况；天猫双十一活动【突然下单一万张票，上万人下单购物】</p>
<p></p>
<p>该情况发生会导致系统在这段时间内执行大量操作，例如，对资源的请求，数据库的操作等</p>
</blockquote>
<p style="text-align:center;"><img alt="" height="290" src="image\ba232185ba154127ab745dedb9e0c393.png" width="434"/></p>
<h2 id="%F0%9F%92%BB%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9A%84%E5%A4%84%E7%90%86%E6%8C%87%E6%A0%87%EF%BC%9F">💻高并发的处理指标？</h2>
<blockquote>
<p><strong>高并发相关常用的一些指标有：</strong></p>
<p><br/><strong>1️⃣响应时间（Response Time）</strong></p>
<p>📗含义：系统对请求做出响应的时间</p>
<p>🌰举个例子：系统处理一个HTTP请求需要200ms，这个200ms就是系统的响应时间</p>
<hr/>
<p><strong>2️⃣吞吐量（Throughput）</strong></p>
<p>📗含义：单位时间内处理的请求数量</p>
<hr/>
<p><strong>3️⃣每秒查询率QPS（Query Per Second）</strong></p>
<p>📗含义 ：每秒响应请求数</p>
<p>📖在互联网领域，这个指标和吞吐量区分的没有这么明显</p>
<hr/>
<p><strong>4️⃣并发用户数</strong></p>
<p>📗含义：同时承载正常使用系统功能的用户数量</p>
<p>🌰举个例子：例如一个即时通讯系统，同时在线量一定程度上代表了系统的并发用户数</p>
</blockquote>
<h2 id="%F0%9F%92%BB%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB%EF%BC%9F">💻<strong>高并发和多线程的关系和区别？</strong></h2>
<blockquote>
<p><strong>“高并发和多线程”</strong>   总是被一起提起，给人感觉两者好像相等，实则    【<strong><span style="color:#be191c;">高并发 ≠ 多线程</span><span style="color:#0d0016;">】</span></strong></p>
<hr/>
<p><strong>1️⃣多线程</strong></p>
<p></p>
<ul><li>多线程是java的特性，因为现在CPU都是多核多线程的，可以同时执行几个任务，为了提高jvm的执行效率，java提供了这种多线程的机制，以增强数据处理效率</li><li>多线程对应的是CPU，高并发对应的是访问请求，可以用单线程处理所有访问请求，也可以用多线程同时处理访问请求</li><li>在过去单CPU时代，单任务在一个时间点只能执行单一程序。之后发展到多任务阶段，计算机能在同一时间点并行执行多任务或多进程</li><li>虽然并不是真正意义上的 <strong>“同一时间点”</strong>，而是多个任务或进程共享一个CPU，并交由操作系统来完成多任务间对CPU的运行切换，以使得每个任务都有机会获得一定的时间片运行</li><li>再后来发展到多线程技术，使得在一个程序内部能拥有多个线程并行执行。一个线程的执行可以被认为是一个CPU在执行该程序。当一个程序运行在多线程下，就好像有多个CPU在同时执行该程序</li><li>📗总结：多线程是处理高并发的一种编程方法，即并发需要用多线程实现</li></ul>
<hr/>
<p><strong>2️⃣高并发</strong></p>
<p></p>
<ul><li>高并发不是JAVA的专有的东西，是语言无关的广义的，为提供更好互联网服务而提出的概念</li><li>典型的场景：例如，12306抢火车票，天猫双十一秒杀活动等。该情况的发生会导致系统在这段时间内执行大量操作，例如对资源的请求，数据库的操作等。</li><li>如果高并发处理不好，不仅仅降低了用户的体验度（请求响应时间过长），同时可能导致系统宕机，严重的甚至导致OOM异常，系统停止工作等</li><li>如果，要想系统能够适应高并发状态，则需要从各个方面进行系统优化，包括，硬件、网络、系统架构、开发语言的选取、数据结构的运用、算法优化、数据库优化等，而多线程只是其中解决方法之一</li></ul>
</blockquote>
<h1 id="%E4%BA%8C%E3%80%81%E6%90%AD%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8%2F%E5%AE%A2%E6%88%B7%E7%AB%AF">二、搭建服务器/客户端</h1>
<h2 id="%F0%9F%92%BB%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BB%A3%E7%A0%81">💻服务器代码（4种类的封装）</h2>
<blockquote>
<ul><li><strong>🍔地址类</strong></li><li><strong>🍟socket基类</strong></li><li><strong>🍕TCP派生类</strong></li><li><strong>🍿epoll类</strong></li></ul>
</blockquote>
<h3 id="%F0%9F%8C%88%E5%9C%B0%E5%9D%80%E7%B1%BB%EF%BC%88CHostAddress%EF%BC%89">🌈地址类【CHostAddress】</h3>
<p id="1%EF%BC%89CHostAddress.h"><strong>📍CHostAddress.h</strong></p>
<pre><code class="language-cpp">#pragma once
#include &lt;sys/types.h&gt;          /* See NOTES */
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;string.h&gt;
#include &lt;arpa/inet.h&gt;

class CHostAddress
{
public:
	CHostAddress(char* ip, unsigned short port);
	~CHostAddress();

	char* getIp();
	void setIp(char* ip);

	unsigned short getPort();
	void setPort(unsigned short port);

	struct sockaddr_in getAddr_in();
	struct sockaddr* getAddr();

	int getLength();

private:
	char ip[16]; //保存ip地址
	int length; //保存 sockaddr_in 结构体长度
	unsigned short port; //端口号
	struct sockaddr_in s_addr;

};
</code></pre>
<p id="%C2%A0%F0%9F%93%8DCHostAddress.cpp"><strong>📍CHostAddress.cpp</strong></p>
<pre><code class="language-cpp">#include "CHostAddress.h"

CHostAddress::CHostAddress(char* ip, unsigned short port)
{
    memset(this-&gt;ip, 0, sizeof(this-&gt;ip));
    strcpy(this-&gt;ip, ip);

    this-&gt;port = port;

    this-&gt;s_addr.sin_family = AF_INET; 
    this-&gt;s_addr.sin_port = htons(this-&gt;port); 
    this-&gt;s_addr.sin_addr.s_addr = inet_addr(this-&gt;ip);

    this-&gt;length = sizeof(this-&gt;s_addr);
}

CHostAddress::~CHostAddress()
{

}

char* CHostAddress::getIp()
{
    return this-&gt;ip;
}

void CHostAddress::setIp(char* ip)
{
    strcpy(this-&gt;ip, ip);
}

unsigned short CHostAddress::getPort()
{
    return this-&gt;port;
}

void CHostAddress::setPort(unsigned short port)
{
    this-&gt;port = port;
}

sockaddr_in CHostAddress::getAddr_in()
{
    return this-&gt;s_addr;
}

sockaddr* CHostAddress::getAddr()
{
    // bind函数需要用到struct sockaddr *，因此return类型转换之后数据
    return (struct sockaddr*)&amp;(this-&gt;s_addr);
}

int CHostAddress::getLength()
{
    return this-&gt;length;
}</code></pre>
<h3 id="%F0%9F%8C%88socket%E5%9F%BA%E7%B1%BB%EF%BC%88CBaseSocket%EF%BC%89">🌈socket类【CBaseSocket】</h3>
<p id="1%EF%BC%89CBaseSocket.h"><strong>📍CBaseSocket.h</strong></p>
<pre><code class="language-cpp">#pragma once

#include &lt;sys/types.h&gt; //socket头文件        
#include &lt;sys/socket.h&gt;//socket头文件  
#include &lt;netinet/in.h&gt;
#include &lt;stdio.h&gt;

class CBaseSocket
{
public:
	CBaseSocket(char* ip, unsigned short port);
	~CBaseSocket();
	void Start();
	int getSocketFd();
	virtual void Run() = 0;//写成纯虚函数，子类来实现
	virtual void Stop() = 0;//写成纯虚函数，子类来实现

protected:
	int socketFd;//写到受保护区，子类可以用到

};</code></pre>
<p id="%F0%9F%93%8DCBaseSocket.cpp%C2%A0">📍<strong>CBaseSocket.cpp </strong></p>
<pre><code class="language-cpp">#include "CBaseSocket.h"

CBaseSocket::CBaseSocket(char* ip, unsigned short port)
{
	this-&gt;socketFd = 0;
}

CBaseSocket::~CBaseSocket()
{
}

void CBaseSocket::Start()
{
	//打通网络通道
	this-&gt;socketFd = socket(AF_INET, SOCK_STREAM, 0);//IPPROTO_TCP用0替换也行

	if (this-&gt;socketFd &lt; 0)//大于0成功，小于0失败
	{
		perror("socket error");//socket创建失败
	}

	this-&gt;Run();//子类实现的run函数
}

int CBaseSocket::getSocketFd()
{
	return this-&gt;socketFd;
}</code></pre>
<h3 id="%F0%9F%8C%88TCP%E6%B4%BE%E7%94%9F%E7%B1%BB%EF%BC%88CTcpServer%EF%BC%89">🌈TCP类【CTcpServer】</h3>
<p id="%F0%9F%93%8DCTcpServer.h%C2%A0">📍<strong>CTcpServer.h </strong></p>
<pre><code class="language-cpp">#pragma once

#include&lt;iostream&gt;
#include "CBaseSocket.h"
#include "CHostAddress.h"
#include &lt;netinet/in.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;          /* See NOTES */
#include &lt;sys/socket.h&gt;

using namespace std;

#define LISTEN_MAX_NUM 10  

class CTcpServer :
    public CBaseSocket
{
public:
    CTcpServer(char* ip, unsigned short port);
    ~CTcpServer();
    void Run();
    void Stop();
    CHostAddress* getAddress();
    void setAddress(CHostAddress* address);

private:
    CHostAddress* address;//地址类
};</code></pre>
<p id="%F0%9F%93%8DCTcpServer.cpp%C2%A0">📍<strong>CTcpServer.cpp </strong></p>
<pre><code class="language-cpp">#include "CTcpSever.h"

CTcpServer::CTcpServer(char* ip, unsigned short port)
    :CBaseSocket(ip, port)
{
    this-&gt;address = new CHostAddress(ip, port);
}

CTcpServer::~CTcpServer()
{
}

void CTcpServer::Run()
{
    int opt_val = 1;
    int res = 0;

    //端口复用 解决出现 adress already use的问题
    res = setsockopt(this-&gt;socketFd, SOL_SOCKET, SO_REUSEADDR, (const void*)&amp;opt_val, sizeof(opt_val));
    if (res == -1)
    {
        perror("setsockopt error");
    }
    //绑定端口号和地址 协议族
    res = bind(this-&gt;socketFd, this-&gt;address-&gt;getAddr(), this-&gt;address-&gt;getLength());
    if (res == -1)
    {
        perror("bind error");
    }
    //监听这个地址和端口有没有客户端来连接
    res = listen(this-&gt;socketFd, LISTEN_MAX_NUM);
    if (res == -1)
    {
        perror("listen error");
    }
    cout &lt;&lt; "Server start success socketFd = " &lt;&lt; this-&gt;socketFd &lt;&lt; endl;
}

void CTcpServer::Stop()
{
    if (this-&gt;socketFd != 0)
    {
        close(this-&gt;socketFd);
        this-&gt;socketFd = 0;
    }
}

CHostAddress* CTcpServer::getAddress()
{
    return this-&gt;address;
}

void CTcpServer::setAddress(CHostAddress* address)
{
    this-&gt;address = address;
}</code></pre>
<h3 id="%F0%9F%8C%88epoll%E7%B1%BB%20%EF%BC%88CEpollServer%EF%BC%89">🌈epoll类 【CEpollServer】</h3>
<p id="%C2%A0%F0%9F%93%8DCEpollServer.h"><strong> </strong>📍<strong>CEpollServer.h</strong></p>
<pre><code class="language-cpp">#pragma once
#include &lt;sys/epoll.h&gt;
#include &lt;iostream&gt;
#include "CTcpSever.h"

#define EPOLL_SIZE 5

using namespace std;

class CEpollServer
{
public:
	CEpollServer(char* ip, unsigned short port);
	~CEpollServer();
	void Start();

private:
	int epollfd;
	int epollwaitefd;
	int acceptFd;
	char buf[1024]; //存放客户端发来的消息
	struct epoll_event epollEvent;
	struct epoll_event epollEventArray[5];
	CTcpServer* tcp;//TCP类

};
</code></pre>
<p id="%F0%9F%93%8D%C2%A0CEpollServer.cpp">📍<strong> CEpollServer.cpp</strong></p>
<pre><code class="language-cpp">#include "CEpollServer.h"

CEpollServer::CEpollServer(char* ip, unsigned short port)
{
	//初始化 TcpServer类
	this-&gt;tcp = new CTcpServer(ip, port);
	this-&gt;tcp-&gt;Start();
	cout &lt;&lt; "socketFd = " &lt;&lt; this-&gt;tcp-&gt;getSocketFd() &lt;&lt; endl;

	//初始化数据成员
	this-&gt;epollfd = 0;
	this-&gt;epollwaitefd = 0;
	this-&gt;acceptFd = 0;
	bzero(this-&gt;buf, sizeof(this, buf));

	//事件结构体初始化
	bzero(&amp;(this-&gt;epollEvent), sizeof(this-&gt;epollEvent));
	//绑定当前准备好的sockedfd（可用网络对象）
	this-&gt;epollEvent.data.fd = this-&gt;tcp-&gt;getSocketFd();
	//绑定事件为客户端接入事件
	this-&gt;epollEvent.events = EPOLLIN;
	//创建epoll
	this-&gt;epollfd = epoll_create(EPOLL_SIZE);
	//将已经准备好的网络描述符添加到epoll事件队列中
	epoll_ctl(this-&gt;epollfd, EPOLL_CTL_ADD, this-&gt;tcp-&gt;getSocketFd(), &amp;(this-&gt;epollEvent));
}

CEpollServer::~CEpollServer()
{
}

void CEpollServer::Start()
{
	while (1)
	{
		cout &lt;&lt; "epoll wait client" &lt;&lt; endl;
		this-&gt;epollwaitefd = epoll_wait(this-&gt;epollfd, epollEventArray, EPOLL_SIZE, -1);
		if (this-&gt;epollwaitefd &lt; 0)
		{
			perror("epoll wait error");
		}
		for (int i = 0; i &lt; this-&gt;epollwaitefd; i++)
		{
			//判断是否有客户端上线
			if (epollEventArray[i].data.fd == this-&gt;tcp-&gt;getSocketFd())
			{
				cout &lt;&lt; "网络_开始工作_等待客户端_上线" &lt;&lt; endl;
				this-&gt;acceptFd = accept(this-&gt;tcp-&gt;getSocketFd(), NULL, NULL);
				cout &lt;&lt; "acceptfd = " &lt;&lt; this-&gt;acceptFd &lt;&lt; endl;

				//上线的客户端描述符是acceptfd 绑定事件添加到epoll
				epollEvent.data.fd = this-&gt;acceptFd;
				epollEvent.events = EPOLLIN; //EPOLLIN表示对应的文件描述符可以读
				epoll_ctl(this-&gt;epollfd, EPOLL_CTL_ADD, this-&gt;acceptFd, &amp;epollEvent);
			}
			else if (epollEventArray[i].events &amp; EPOLLIN)
			{
				bzero(this-&gt;buf, sizeof(this-&gt;buf));
				int res = read(epollEventArray[i].data.fd, this-&gt;buf, sizeof(this-&gt;buf));
				if (res &gt; 0)
				{
					cout &lt;&lt; "服务器_收到 fd = " &lt;&lt; epollEventArray[i].data.fd &lt;&lt; "  送达数据: buf = " &lt;&lt; this-&gt;buf &lt;&lt; endl;
				}
				else if (res &lt;= 0)
				{
					cout &lt;&lt; "客户端 fd = " &lt;&lt; epollEventArray[i].data.fd &lt;&lt; " _掉线_" &lt;&lt; endl;
					close(epollEventArray[i].data.fd);

					//从epoll中删除客户端描述符
					epollEvent.data.fd = epollEvent.data.fd;
					epollEvent.events = EPOLLIN;
					epoll_ctl(this-&gt;epollfd, EPOLL_CTL_DEL, epollEventArray[i].data.fd, &amp;epollEvent);
				}
			}
		}
	}
}</code></pre>
<h2 id="%F0%9F%92%BB%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BB%A3%E7%A0%81">💻<strong>客户端代码</strong></h2>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;sys/types.h&gt;          
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;

using namespace std;

int main()
{
	int socketfd = 0;
	int acceptfd = 0;
	int len = 0;
	int res = 0;
	char buf[255] = { 0 };//初始化

	//初始化网络
	socketfd = socket(AF_INET, SOCK_STREAM, 0);
	if (socketfd == -1)
	{
		perror("socket error");
	}
	else
	{
		struct sockaddr_in s_addr;
		//确定使用哪个协议族  ipv4
		s_addr.sin_family = AF_INET;

		//填入服务器的ip地址  也可以是  127.0.0.1 （回环地址）
		s_addr.sin_addr.s_addr = inet_addr("192.168.48.129");

		//端口一个计算机有65535个  10000以下是操作系统自己使用的，自己定义的端口号为10000以后
		s_addr.sin_port = htons(12345);  //自定义端口号为12345

		len = sizeof(s_addr);

		//绑定ip地址和端口号
		int res = connect(socketfd, (struct sockaddr*)&amp;s_addr, len);
		if (res == -1)
		{
			perror("connect error");
		}
		else
		{
			while (1)
			{
				cout &lt;&lt; "请输入内容：" &lt;&lt; endl;
				cin &gt;&gt; buf;
				write(socketfd, buf, sizeof(buf));
				bzero(buf, sizeof(buf));
			}
		}
	}
	return 0;
}</code></pre>
<h2 id="%F0%9F%92%BB%E6%A1%88%E4%BE%8B%E6%B5%8B%E8%AF%95">💻<strong>案例测试</strong></h2>
<p id="main.cpp">📍<strong>main.cpp</strong></p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include "CEpollServer.h"

using namespace std;

int main()
{
	CEpollServer* epoll = new CEpollServer("192.168.48.129", 12345);
	epoll-&gt;Start();
	return 0;
}</code></pre>
<p id="%F0%9F%93%8D%E6%B5%8B%E8%AF%95%E6%95%88%E6%9E%9C%C2%A0">📍<strong>测试效果 </strong></p>
<p>通过Linux连接VS进行跨平台编程，上为本文设计的服务器，下为两个与之相连的客户端，在客户端1和客户端2中输入内容，服务器上能接收到相应的信息，即表示测试成功！如下动图所示： </p>
<p><img alt="" src="https://img-blog.csdnimg.cn/e5b46f537b794429b321992e509f28a9.gif"/></p>
<p></p>
<p><strong>参考：</strong></p>
<p><a href="https://www.csdn.net/tags/MtjaUgxsMzAzMjgtYmxvZwO0O0OO0O0O.html" title="https://www.csdn.net/tags/MtjaUgxsMzAzMjgtYmxvZwO0O0OO0O0O.html">https://www.csdn.net/tags/MtjaUgxsMzAzMjgtYmxvZwO0O0OO0O0O.html</a>  </p>
<p><a href="https://blog.csdn.net/wmcy123/article/details/124054385" title="【Linux】高并发服务器设计——socket封装_似末的博客-CSDN博客_linux socket 高并发">【Linux】高并发服务器设计——socket封装_似末的博客-CSDN博客_linux socket 高并发</a></p>
<p></p>
<p><span style="color:#38d8f0;"><strong><em>以上就是本文的全部内容啦！如果对您有帮助，麻烦点赞啦！收藏啦！欢迎各位评论区留言</em>！！！</strong></span></p>
<p style="text-align:center;"><img alt="" src="https://img-blog.csdnimg.cn/9b848022d42d491cb0d59ea13b5f2f84.gif"/></p>
<p style="text-align:center;"></p>
</div>
</div>