<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<p> 🔥 🔥 🔥 🔥 🔥  火速猛戳订阅 👉  <a href="https://blog.csdn.net/weixin_50502862/category_11602059.html" title="《C++要笑着学》">《C++要笑着学》</a>   👈 趣味教学博客 🔥 🔥 🔥 🔥 🔥</p>
<p><img alt="" src="image\b53338b09e69459b894fa4840fc02f40.png"/></p>
<p><img alt="" height="50" src="image\c52b4035e4864f4ba6cbbd9070bc53cd.png" width="324"/>  <strong> <span style="color:#e6b223;"><em>[ 本篇博客热榜最高排名：7 ]</em></span></strong></p>
<p></p>
<h3>写在前面</h3>
<p><img alt="" height="51" src="image\aad595a3c2c24739aba93262084123b9.png" width="61"/> 朋友们好啊，今天终于更新了。我是<span style="color:#e6b223;"><strong>柠檬</strong></span><span style="color:#1c7331;"><strong>叶子</strong></span><span style="color:#0d0016;"><strong>C</strong></span>，本章将继续讲解C++中的面向对象的知识点，本篇主要讲解默认成员函数中的构造函数、析构函数和拷贝构造函数。还是和以前一样，我们将由浅入深地去讲解，<span style="background-color:#fbd4d0;">以 "初学者" 的角度去探索式地学习。</span>会一步步地推进讲解，而不是直接把枯燥的知识点倒出来，应该会有不错的阅读体验。如果觉得不错，可以 "一键三连" 支持一下博主！你们的关注就是我更新的最大动力！Thanks ♪ (･ω･)ﾉ</p>
<p></p>
<hr/>
<h2 id="%E2%85%A0.%20%E7%B1%BB%E7%9A%84%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0">Ⅰ.  默认成员函数</h2>
<p><img alt="" height="225" src="image\11842e8c36ca4ec28a486a6512bac44f.png" width="320"/></p>
<p>如果一个类中什么成员都没有，我们称之为 "空类" 。</p>
<p>❓ 但是空类中真的什么都没有吗？</p>
<p><img alt="" height="111" src="image\52ba0d6feb53441d8f09d6a6cdda555a.png" width="151"/> 并不是的……</p>
<p></p>
<p><span style="background-color:#f9eda6;">类有六个默认成员函数</span>，特殊的点非常多，后面我们会壹壹学习。</p>
<p><img alt="" height="271" src="image\5e1ba242ab8a45fa91b2318b25a34c39.png" width="414"/></p>
<p><img alt="" height="642" src="image\3c26cc0116a74612a33c950ef4bb7080.png" width="1200"/></p>
<p></p>
<p><img alt="" height="61" src="image\4690005f605449e8bfbffa51ceaaab0e.png" width="72"/> 对于默认成员函数，如果我们不主动实现，编译器会自己生成一份。</p>
<p></p>
<p>❓ 他们有什么用呢？举个例子：</p>
<p>比如我们在上一章里举过的一个 <strong>Stack </strong>的例子，</p>
<p>如果需要初始化和清理，"构造函数" 和 "析构函数" 就可以帮助我们完成。</p>
<p>构造函数就类似于<span style="color:#956fe7;"> Init</span>，而析构函数就类似于 <span style="color:#956fe7;">Destroy</span>。</p>
<p><img alt="" height="160" src="image\c0336c99a116421eab25dc67da0cef35.png" width="217"/></p>
<p>还是和以前一样，我们将先由浅入深地进行学习，我们先从 "构造函数" 开始讲起。</p>
<p></p>
<p></p>
<h2 id="%E2%85%A1.%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">Ⅱ. 构造函数</h2>
<h3 id="0x00%20%E9%97%AE%E9%A2%98%E5%BC%95%E5%85%A5">0x00 引入</h3>
<p><img alt="" height="158" src="image\bf279f94cc94473e98690246720e494f.png" width="176"/>打开宇宙第一编辑器，一起敲一敲看看 ~</p>
<p>📚 为了能够更好地讲解，我们来写一个简单的日期类，通过日期类来讲解。</p>
<p>💬 Date.cpp</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

class Date {
public:
    void SetDate(int year, int month, int day) {
        _year = year;
        _month = month;
        _day = day;
    }
    void Print() {
        printf("%d-%d-%d\n", _year, _month, _day);
    }

private:
    int _year;
    int _month;
    int _day;
};

int main(void)
{
    Date d1;
    d1.SetDate(2022, 3, 8);
    d1.Print();

    Date d2;
    d2.SetDate(2022, 3, 12);
    d2.Print();

    return 0;
}</code></pre>
<p>💡 对于 <strong>Date</strong> 类，我们可以通过我们写的成员函数 <span style="color:#e6b223;">SetDate </span>给对象设置内容。</p>
<p><img alt="" height="114" src="image\b1eaf3ddca98458282018ba6360c70f8.png" width="106"/> 但是每次创建对象都要调用这个 SetDate ，是不是太鸡儿烦了？</p>
<p></p>
<p>❓ 那有没有什么办法能在创建对象时，自动将我们要传递的内容放置进去呢？</p>
<p><img alt="" height="50" src="image\649aa8f01696497cbfc791ca45b3a25e.png" width="46"/> 有！下面我们来隆重介绍一下 <strong>构造函数</strong>！</p>
<p></p>
<p></p>
<h3 id="0x01%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%A6%82%E5%BF%B5">0x01 构造函数的概念</h3>
<p><img alt="" height="116" src="image\659e5ad7ab31443c971a75a0913a1b0b.png" width="109"/></p>
<p>📚 <span style="background-color:#f9eda6;">构造函数是一个特殊的成员函数，名字与类名相同，创建类类型对象时由编译器自动调用。</span></p>
<p>能够保证每个数据成员都有一个合适的初始值，并且在对象的生命周期内只调用一次。</p>
<p></p>
<p><img alt="" height="52" src="image\1937ef1085f74c4e9de35231ec04ea82.png" width="52"/> 构造函数的意义：能够保证对象被初始化。</p>
<p>构造函数是特殊的成员函数，主要任务是初始化，而不是开空间。（虽然构造函数的名字叫构造）</p>
<p></p>
<h3 id="0x02%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E7%89%B9%E6%80%A7">0x02 构造函数的特性</h3>
<p>📚 构造函数是特殊的成员函数，主要特征如下：</p>
<p>① 构造函数的函数名和类名是相同的</p>
<p>② 构造函数无返回值</p>
<p>③ 构造函数可以重载</p>
<p>③ 会在对象实例化时自动调用对象定义出来。</p>
<p>比如下面的代码只要 <img alt="" height="20" src="image\4c6d810245c6457a9470a58d1e1c23ea.png" width="71"/> 就会自动调用，保证了对象一定是被初始化过的。</p>
<p></p>
<p><img alt="" height="55" src="image\4fd59d90b6084894b80204781b2bd42a.png" width="66"/> 我们直接来看看它是怎么用的！ </p>
<p>💬 构造函数的用法：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

class Date {
public:
    /* 无参构造函数 */
    Date() {
        _year = 0;
        _month = 1;
        _day = 1;
    }
    /* 带参构造函数 */
    Date(int year, int month, int day) {
        _year = year;
        _month = month;
        _day = day;
    }
    void Print() {
        printf("%d-%d-%d\n", _year, _month, _day);
    }

private:
    int _year;
    int _month;
    int _day;
};

int main(void)
{
    Date d1;   // 对象实例化，此时触发构造，调用无参构造函数
    d1.Print();

    Date d2(2022, 3, 9);   // 对象实例化，此时触发构造，调用带参构造函数
    d2.Print();

    return 0;
}</code></pre>
<blockquote>
<p>🚩 运行结果如下：</p>
</blockquote>
<p><img alt="" height="118" src="image\dfc30469a28f4515a1b5be584109212c.png" width="544"/></p>
<p> 🔑 解读：不给参数时就会调用无参构造函数，给参数则会调用带参构造函数。</p>
<p></p>
<p><img alt="" height="110" src="image\54a3a77a338f47f58774b5613c7d3b4a.png" width="604"/></p>
<p></p>
<p>📌 注意事项：</p>
<p>① 构造函数是特殊的，不是常规的成员函数，不能直接调 <img alt="" height="25" src="image\2aae57abea39420a851a895702e57c3b.png" width="105"/> 。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

class Date {
public:
    Date(int year = 1, int month = 0, int day = 0) {
        _year = year;
        _month = month;
        _day = day;
    }
private:
    int _year;
    int _month;
    int _day;
};

int main(void)
{
    Date d1;
    d1.Date(); // 不能这么去调，构造函数是特殊的，不是常规的成员函数！

    return 0;
}</code></pre>
<blockquote>
<p>🚩 运行结果：（报错）</p>
</blockquote>
<p><img alt="" height="216" src="image\8d0d20c7ae1c42ffaf35199cd320fd04.png" width="610"/></p>
<p></p>
<p>② 如果通过无参构造函数创建对象，对象后面不用跟括号，否则就成了函数声明。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

class Date {
public:
    Date(int year = 1, int month = 0, int day = 0) {
        _year = year;
        _month = month;
        _day = day;
    }
    void Print() {
        printf("%d-%d-%d\n", _year, _month, _day);
    }
private:
    int _year;
    int _month;
    int _day;
};

int main(void)
{
    //带参这么调：加括号()，在括号中加参数列表
    Date d2(2022, 3, 9);

    Date d3();   // 这样可以吗？ 
                 // 既然代参的调用加括号，在括号中加参数列表。
                 // 那我不带参，可不可以加括号呢？
                 ❌ 仍然不可以。
                 // 这个对象实际上没有被定义出来，这里会报错。 
                 // 编译器不会识别，所以不传参数就老老实实地  
                 // Date d3; 不要 Date d3();   
    // 主要是编译器没法识别，所以这里记住不能这么干就行了。

    return 0;
}</code></pre>
<p><img alt="" height="255" src="image\371c6a4a508344c18dfccd40ddf0532f.png" width="562"/></p>
<p></p>
<p>③ 这里如果调用带参构造函数，我们需要传递三个参数（这里我们没设缺省） 。</p>
<p><img alt="" height="230" src="image\9e3b84d4d8674465addf5a1dd3ecf9c6.png" width="631"/></p>
<p></p>
<p>④ 如果你没有自己定义构造函数（类中未显式定义），C++ 编译器会自动生成一个无参的默认构造函数。当然，如果你自己定义了，编译器就不会帮你生成了。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

class Date {
public:
    /* 如果用户显式定义了构造函数，编译器将不再生成
    Date(int year, int month, int day) {
        _year = year;
        _month = month;
        _day = day;
    }
    */
    void Print() {
        printf("%d-%d-%d\n", _year, _month, _day);
    }

private:
    int _year;
    int _month;
    int _day;
};

int main(void)
{
    Date d1;  // 这里调用的是默认生成的无参的构造函数
    d1.Print();

    return 0;
}</code></pre>
<blockquote>
<p>🚩 运行结果如下：</p>
</blockquote>
<p><img alt="" height="184" src="image\79cef0783975456a94ed2cfddd9965c9.png" width="1013"/></p>
<p>🔑 没有定义构造函数，对象也可以创建成功，因此此处调用的是编译器默认生成的构造函数。</p>
<p><img alt="" height="181" src="image\1ef1d58f8c8e4ed0b52313b8c80b14a5.png" width="650"/></p>
<p></p>
<p></p>
<h3 id="0x03%20%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">0x03 默认构造函数</h3>
<p><img alt="" height="55" src="image\4b7d9ed114ea4d90853496b1d5da635f.png" width="66"/> 无参构造函数、全缺省构造函数都被称为默认构造函数。</p>
<p>并且默认构造函数只能有一个！</p>
<pre><code class="language-cpp">class Date {
public:
    /* 全缺省构造函数 - 默认构造函数 */
    Date(int year = 1970, int month = 1, int day = 1) {
        _year = year;
        _month = month;
        _day = day;
    }

private:
    int _year;
    int _month;
    int _day;
};</code></pre>
<p></p>
<p>📌 注意事项：</p>
<p>① 无参构造函数、全缺省构造函数、我们没写编译器默认生成的无参构造函数，都可以认为是默认成员函数。</p>
<p>② 语法上无参和全缺省可以同时存在，但如果同时存在会引发二义性：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

class Date {
public:
    Date() {
        _year = 1970;
        _month = 1;
        _day = 1;
    }
    Date(int year = 1970, int month = 1, int day = 1) {
        _year = year;
        _month = month;
        _day = day;
    }
    
private:
    int _year;
    int _month;
    int _day;
};

int main(void)
{
    Date d1; ❌

    return 0;
}</code></pre>
<blockquote>
<p>🚩 运行结果如下：（报错）</p>
</blockquote>
<p>🔑 解读：无参的构造函数和全缺省的构造函数都成为默认构造函数，并且默认构造参数只能有一个，语法上他们两个可以同时存在，但是如果有对象定义去调用就会报错。</p>
<p><img alt="" height="383" src="image\801ea12a4a0e49c186d7d6d87e5ff0c1.png" width="607"/></p>
<p></p>
<p> <img alt="" height="55" src="image\e35df21f34074bbf8e81b203003808ee.png" width="66"/> 推荐实现全缺省或者半缺省，因为真的很好用：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

class Date {
    public:
        /* 全缺省 */
        Date(int year = 0, int month = 1, int day = 1) {
            _year = year;
            _month = month;
            _day = day;
        }
    
        void Print() {
            printf("%d-%d-%d\n", _year, _month, _day);
        } 
    private:
        int _year;
        int _month;
        int _day;
};

int main(void)
{
    Date d1; // 如果不传，就是缺省值
    Date d2(2022, 1, 15);
    Date d3(2009);
    Date d4(2012, 4);

    d1.Print();  // 0-1-1
    d2.Print();  // 2022-1-15
    d3.Print();  // 2009-1-1
    d4.Print();  // 2012-4-1

    return 0;
}</code></pre>
<blockquote>
<p>🚩 运行结果如下：</p>
</blockquote>
<p><img alt="" height="147" src="image\a55ebd7aa4e54bbbb8de25ff2cb12b13.png" width="522"/></p>
<p></p>
<p></p>
<h3 id="0x04%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E7%89%B9%E6%80%A7%E7%9A%84%E6%B5%8B%E8%AF%95">0x04 构造函数的特性的测试</h3>
<p><img alt="" height="186" src="image\3e3692c130d848d799df1fa6c077ad6e.png" width="292"/></p>
<p>📚 任何一个类的默认构造函数，只有三种：</p>
<p>① 无参的构造函数</p>
<p>② 全缺省的构造函数</p>
<p>③ 我们不写，编译器自己生成的构造函数</p>
<p></p>
<p>💬 如果你没有自己定义构造函数（类中未显式定义），</p>
<p>C++ 编译器会自动生成一个无参的默认构造函数。</p>
<p>当然，如果你自己定义了，编译器就不会帮你生成了。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

class Date {
public:
    // 让编译器自己生成一个
    void Print() {
        printf("%d-%d-%d\n", _year, _month, _day);
    }

private:
    int _year;
    int _month;
    int _day;
};

int main(void)
{
    Date d1;  // 这里调用的是默认生成的无参的构造函数
    d1.Print();

    return 0;
}</code></pre>
<blockquote>
<p>🚩 运行结果如下：</p>
</blockquote>
<p><img alt="" height="95" src="image\79cef0783975456a94ed2cfddd9965c9.png" width="521"/></p>
<p> <img alt="" height="72" src="image\430db65bb33f4ffcbbeb08cc3e371d05.png" width="113"/> 好了，我们来好好探讨探讨这个问题！</p>
<p>在我们不是先构造函数的情况下，编译器生成的默认构造函数。</p>
<p>似乎这看起来没有什么鸟用啊，这不就是一堆随机值嘛……</p>
<p><strong>d1 </strong>对象调用了编译器生成的默认函数，但<strong> d1</strong> 对象 year / month / day 依旧是随机值，</p>
<p>也就是说这里编译器生成的默认构造函数好像并没有什么卵用。</p>
<p><img alt="" height="189" src="image\7d322a9ddfff4f9a92bd822a6d911aaf.png" width="270"/></p>
<p></p>
<p>🔑 解答：C++ 把类型分成内置类型（基本类型）和自定义类型。</p>
<p>内置类型就是语法已经定义好的类型：如 <span style="color:#e6b223;">int</span> / <span style="color:#e6b223;">char</span>...，</p>
<p>自定义类型就是我们使用<span style="color:#e6b223;"> </span><span style="color:#956fe7;">class</span> / <span style="color:#956fe7;">struct</span> / <span style="color:#956fe7;">union</span> / <span style="color:#956fe7;">自己定义的类型</span>。</p>
<p>💬 看看下面的程序，就会发现。编译器生成默认的构造函数会对自定类型成员<strong> aa</strong> 调用的它的默认成员函数：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class Time {
public:
	Time()
	{
		cout &lt;&lt; "Time()" &lt;&lt; endl;
		_hour = 0;
		_minute = 0;
		_second = 0;
	}
private:
	int _hour;
	int _minute;
	int _second;
};

class Date {
private:
	// 基本类型（内置类型）
	int _year;
	int _month;
	int _day;

	// 自定义类型
	Time _t;
};

int main()
{
	Date d;

	return 0;
}</code></pre>
<blockquote>
<p>🚩 运行结果如下： </p>
</blockquote>
<p><img alt="" height="121" src="image\1e9a65d3d12b45d5a50392df5fce430f.png" width="522"/></p>
<p></p>
<p>💬 测试：对自定义类型处理，会调用默认构造函数（不用参数就可以调的函数）</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;

class A {
public:
    // 默认构造函数（不用参数就可以调的）
    A() {
        cout &lt;&lt; " A() " &lt;&lt; endl;
        _a = 0;
    }

private:
    int _a;
};

class Date {
public:
private:
    int _year;
    int _month;
    int _day;

    A _aa;   // 对自定义类型处理，此时会调用默认构造函数 A() {...}
};

int main(void)
{
    Date d1;

    return 0;
}</code></pre>
<blockquote>
<p>🚩 运行结果如下：</p>
</blockquote>
<p><img alt="" height="120" src="image\cc765fd27d03430788e664d44786f627.png" width="531"/></p>
<p>C++ 里面把类型分为两类：<span style="color:#e6b223;"><strong>内置类型</strong></span>（基本类型）和 <span style="color:#956fe7;"><strong>自定义类型</strong></span>。</p>
<p><img alt="" height="208" src="image\cad3cfd3386642e29d16bb0841414ab4.png" width="286"/></p>
<p>C++ 规定：我们不写编译器默认生成构造函数，对于内置类型的成员变量，不做初始化处理。</p>
<p>但是对于自定义类型的成员变量会去调用它的默认构造函数（不用参数就可以调的）初始化。</p>
<p>如果没有默认构造函数（不用参数就可以调用的构造函数）<span style="color:#ed7976;">就会报错！</span></p>
<p></p>
<p>💬 为了验证，这里我们故意写个带参的默认构造函数，让编译器不默认生成：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class A {
public:
    // 如果没有默认的构造函数，会报错。
    A(int a) {    // 故意给个参
        cout &lt;&lt; " A() " &lt;&lt; endl;
        _a = 0;
    }
private:
    int _a;
};

class Date {
public:
private:
    // 如果没有默认构造函数就会报错

    int _year;
    int _month;
    int _day;

    A _aa;
};

int main(void)
{
    Date d1;

    return 0;
}</code></pre>
<blockquote>
<p>🚩 运行结果如下（报错）</p>
</blockquote>
<p><img alt="" height="52" src="image\4c41b0d175a345d7bf5a2122c9606319.png" width="605"/></p>
<p></p>
<p>💬 我们不写，让编译器默认生成一个：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;

class A {
public:
    // 让编译器默认生成
private:
    int _a;
};

class Date {
public:
private:
    int _year;
    int _month;
    int _day;

    A _aa;
};

int main(void)
{
    Date d1;

    return 0;
}</code></pre>
<p><img alt="" height="163" src="image\cafc426be24945fba8f5046522d01d73.png" width="458"/></p>
<p><img alt="" height="64" src="image\048d54b172e94d3bb30a9c17b8ac9c16.png" width="87"/> 是随机值没错，但是这是一种对自定义类型的 "处理" 。</p>
<p></p>
<p><img alt="" height="46" src="image\691f45ceea694367a5a2fc87a3e72f1d.png" width="55"/> 这里说个题外话，个人认为 C++里，我们不写构造函数编译器会默认生成的这个特性设计得不好（狗头保命）……因为没有对内置类型和自定义类型统一处理，不处理内置类型成员变量，只处理自定义类型成员变量。</p>
<p></p>
<p></p>
<h2 id="%E2%85%A2.%20%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0">Ⅲ. 析构函数</h2>
<h3 id="0x00%20%E5%BC%95%E5%85%A5">0x00 引入</h3>
<p><img alt="" height="55" src="image\9c493c63b5c7485d8bafc45d6b4f53fd.png" width="66"/> 通过前面构造函数的学习，我们知道了一个对象是怎么来的了，</p>
<p>❓ 那一个对象又是怎么没的呢？既然构造函数的本质是初始化，那清理的工作交给谁来干呢？</p>
<p>💡 交给专门擦屁股的 —— <span style="color:#956fe7;"><strong>析构函数</strong></span>！</p>
<p></p>
<p>以前我们玩数据结构的时候经常忘记调用 <span style="color:#4da8ee;">destroy</span> 函数，但是现在我们有析构函数了！！！</p>
<p><img alt="" height="438" src="image\c91e123a79db4f71bc36206cdb6d41ec.png" width="541"/></p>
<p><span style="color:#ff9900;"><em>多么振奋人心啊！话不多说让我们开始讲解！！！ </em></span></p>
<p></p>
<p></p>
<h3 id="0x01%20%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E6%A6%82%E5%BF%B5">0x01 析构函数的概念</h3>
<p><img alt="" height="120" src="image\29de6102b88b4c66b7a989dde9d5a266.png" width="116"/> 析构函数与构造函数的功能相反。</p>
<p>构造函数是特殊的成员函数，主要任务是初始化，而不是开空间；</p>
<p>析构函数也一样，<span style="background-color:#f9eda6;">主要任务是清理，而不是做对象销毁的工作。</span></p>
<p>（局部对象销毁工作是由编译器完成的）</p>
<p>📚 概念：<span style="background-color:#f9eda6;">对象在销毁时会自动调用析构函数，完成对象的一些资源清理工作。</span></p>
<p></p>
<h3>0x02 析构函数的特性</h3>
<p><img alt="" height="101" src="image\3a1bcce09f92437391772b477d5d0653.png" width="67"/> 构造函数是特殊的成员函数，主要特征如下：</p>
<p>① 析构函数名是在类名前面加上字符 <img alt="~" class="mathcode" src="https://latex.codecogs.com/gif.latex?~"/><img alt="" height="26" src="image\f9bc458a44584587a9f28c5a9032213c.png" width="16"/></p>
<p>② 析构函数既没有参数也没有返回值（因为没有参数，所以也不会构成重载问题）</p>
<p>③ 一个类的析构函数有且仅有一个（如果不写系统会默认生成一个析构函数）</p>
<p>④ 析构函数在对象生命周期结束后，会自动调用。</p>
<p>（和构造函数是对应的构造函数是在对象实例化的时候自动调用）</p>
<p></p>
<p>💬 为了演示自动调用，我们来让析构函数被调用时 "吱" 一声：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class Date {
public:
    Date(int year = 1, int month = 0, int day = 0) {
        _year = year;
        _month = month;
        _day = day;
    }
    void Print() {
        printf("%d-%d-%d\n", _year, _month, _day);
    }

    ~Date() {
        // Date 类没有资源需要清理，所以Date不实现析构函都是可以的
        cout &lt;&lt; "~Date() 吱~ " &lt;&lt; endl;  // 测试一下，让他吱一声
    }

private:
    int _year;
    int _month;
    int _day;
};

int main(void)
{
    Date d1;
    Date d2(2022, 3, 9);

    return 0;
}</code></pre>
<blockquote>
<p>🚩 运行结果：</p>
</blockquote>
<p><img alt="" height="281" src="image\ece1a5c7e1634ced8175924c09185d28.png" width="582"/></p>
<p></p>
<p><img alt="" height="92" src="image\b2582f7559734e30b94366fc20a5c554.png" width="123"/>额，之前举得日期类的例子没法很好地展示析构函数的 "魅力" ……</p>
<p>就像本段开头说情景，我们拿 <strong>Stack </strong>来举个例子，这就很贴切了。</p>
<p>我们知道，栈是需要<span style="color:#956fe7;"> destroy</span> 清理开辟的内存空间的。</p>
<p></p>
<p><img alt="" height="57" src="https://img-blog.csdnimg.cn/f082b9c6b0fa4873a8740244ad8fd041.gif" width="57"/> 这里我们让析构函数来干这个活，简直美滋滋！</p>
<p>💬 析构函数的用法：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;stdlib.h&gt;
using namespace std;

typedef int StackDataType;
class Stack {
public:
    /* 构造函数 - StackInit */
    Stack(int capacity = 4) {  // 这里只需要一个capacity就够了，默认给4（利用缺省参数）
        _array = (StackDataType*)malloc(sizeof(StackDateType) * capacity);
        if (_array == NULL) {
            cout &lt;&lt; "Malloc Failed!" &lt;&lt; endl;
            exit(-1);
        }
        _top = 0;
        _capacity = capacity;
    }

    /* 析构函数 - StackDestroy */
    ~Stack() {   // 这里就用的上析构函数了，我们需要清理开辟的内存空间（防止内存泄漏）
        free(_array);
        _array = nullptr;
        _top = _capacity = 0;
    }

private:
    int* _array;
    size_t _top;
    size_t _capacity;
};

int main(void)
{
    Stack s1;
    Stack s2(20); // s2 栈 初始capacity给的是20（可以理解为"客制化"）

    return 0;
}
</code></pre>
<p>🔑 解读：我们在设置栈的构造函数时，定义容量<strong> capacity </strong>时利用缺省参数默认给个4的容量，这样用的时候默认就是4，如果不想要4可以自己传。</p>
<p>如此一来，就可以保证了栈被定义出来就一定被初始化，用完后会自动销毁。以后就不会有忘记调用 <span style="color:#956fe7;">destroy</span> 而导致内存泄露的惨案了，这里的析构函数就可以充当销毁的作用。</p>
<p></p>
<p>❓ 问一个比较有意思的问题，这里是先析构<strong> s1 </strong>还是先析构 <strong>s2</strong>？</p>
<p><img alt="" height="55" src="image\41357a5718824b0e80a45ab3007af9f2.png" width="66"/> 既然都这样问了，应该是先析构 <strong>s2 </strong>了 ~</p>
<p>析构的顺序在局部的栈中是相反的，栈帧销毁清理资源时 <strong>s2</strong> 先清理，然后再清理<strong> s1 </strong>。</p>
<p><span style="color:#a5a5a5;">（不信的话可以去监视一下 this 观察下成员变量）</span></p>
<p></p>
<p></p>
<h3 id="0x03%C2%A0%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E7%89%B9%E6%80%A7%E7%9A%84%E6%B5%8B%E8%AF%95">0x03 析构函数的特性的测试</h3>
<p><img alt="" height="118" src="image\9020620a49254ff392d07c5a1afa5fd9.png" width="197"/>又到了测试环节，上号！</p>
<p>我们知道，如果没写析构函数编译器会自动生成一个。</p>
<p>那生成的析构函数会做什么事情呢？它会帮我们 <span style="color:#956fe7;">destroy</span> 嘛？</p>
<p><img alt="" height="140" src="image\dcbcb0d9e0aa4d4a814d25489934be2b.png" width="142"/> 想屁吃？哪有这种好事。</p>
<p>如果我们不写默认生成的析构函数，结果和构造函数类似，</p>
<p>对于自定义类型的成员变量不作处理，对于自定义类型的成员变量会去调用它的析构函数。</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;stdlib.h&gt;
using namespace std;
typedef int StackDataType;

class Stack {
public:
    Stack(int capacity = 4) {
        _array = (StackDataType*)malloc(sizeof(int*) * capacity);
        if (_array == NULL) {
            cout &lt;&lt; "Malloc Failed!" &lt;&lt; endl;
            exit(-1);
        }
        _top = 0;
        _capacity = capacity;
    }
    // ~Stack() {
    //     free(_array);
    //     _array = nullptr;
    //     _top = _capacity = 0;
    // }

private:
    int* _array;
    size_t _top;
    size_t _capacity;
};

int main(void)
{
    Stack s1;
    Stack s2(20);


    return 0;
}</code></pre>
<p><img alt="" height="135" src="image\4a0c84c0d7184a2d8b4fbfffe808b8f2.png" width="200"/>难道就不能帮我把这些事都干了吗？帮我都销毁掉不就好了？</p>
<p></p>
<p>不不不，举个最简单的例子，迭代器，析构的时候是不释放的，因为不需要他来管，</p>
<p>所以默认不对内置类型处理是正常的，万一误杀了怎么办，对吧。 </p>
<p><img alt="" height="165" src="image\6141b050aa8741b2a8d79f62d15e9106.png" width="156"/></p>
<p>有人可能又要说了，这么一来默认生成的析构函数不就没有用了吗？</p>
<p>有用！他对内置类型的成员类型不作处理，会在一些情况下非常的有用！</p>
<p>比如说：   两个栈实现一个队列（LeetCode232） ，用C++可以非常的爽。</p>
<p></p>
<p>💬 自定义类型的成员变量调用它的析构函数：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class String {
public:
	String(const char* str = "jack") {
		_str = (char*)malloc(strlen(str) + 1);
		strcpy(_str, str);
	}
	~String() {
		cout &lt;&lt; "~String()" &lt;&lt; endl;
		free(_str);
	}
private:
	char* _str;
};

class Person {
private:
	String _name;
	int _age;
};

int main()
{
	Person p;

	return 0;
}
</code></pre>
<blockquote>
<p>🚩 运行结果如下：</p>
</blockquote>
<p><img alt="" height="101" src="image\fba4fe23a9c84c0f802f22f2739e22f5.png" width="521"/></p>
<p></p>
<p></p>
<h2 id="%E2%85%A3.%C2%A0%20%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">Ⅳ.  拷贝构造函数</h2>
<h3>0x00 引入</h3>
<p><img alt="" height="241" src="image\458225ab34844a9884734d81de00bda2.png" width="533"/></p>
<p>我们在创建对象的时候，能不能创建一个与某一个对象一模一样的新对象呢？</p>
<pre><code class="language-cpp">Date d1(2022, 3, 9);    
d1.Print();

Date d2(d1);    // 照着d1的模子做一个d2
d2.Print();</code></pre>
<p>当然可以，这时我们就可以用拷贝构造函数。</p>
<p><img alt="" height="287" src="image\2e2cac346b3c4d57a643086f0bf10621.png" width="617"/></p>
<p></p>
<h3 id="0x01%20%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%A6%82%E5%BF%B5">0x01 拷贝构造函数的概念</h3>
<p><img alt="" height="142" src="image\c7bbae49c7b44de2bd984880b90e2d09.png" width="215"/></p>
<p>📚 拷贝构造函数：只有单个形参，该形参是对本类类型对象的引用（一般常用<span style="color:#956fe7;"> const </span>修饰），在用已存在的类类型对象创建新对象时由编译器自动调用。</p>
<p></p>
<h3 id="0x02%20%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E7%89%B9%E6%80%A7">0x02 拷贝构造函数的特性</h3>
<p><img alt="" height="194" src="image\0e8ad27b057c48019edd4db991826271.png" width="202"/>它也是一个特殊的成员函数，所以他符合构造函数的一些特性：</p>
<p>① 拷贝构造函数是构造函数的一个重载形式。函数名和类名相同，没有返回值。</p>
<p>② 拷贝构造函数的参数只有一个，并且必须要使用引用传参！</p>
<p>     <img alt="" height="163" src="image\d9d87c6c3dc24260b9fee91ef1b3682a.png" width="240"/> 使用传值方式会引发无穷递归调用！</p>
<p></p>
<p>💬 拷贝构造函数的用法：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

class Date {
public:
    Date(int year = 0, int month = 1, int day = 1) {
        _year = year;
        _month = month;
        _day = day;
    }

    /* Date d2(d1); */
    Date(Date&amp; d) {         // 这里要用引用，否则就会无穷递归下去
        _year = d._year;
        _month = d._month;
        _day = d._day;
    }
    void Print() {
        printf("%d-%d-%d\n", _year, _month, _day);
    }

private:
    int _year;
    int _month;
    int _day;
};

int main(void)
{
    Date d1(2022, 3, 9);
    Date d2(d1);          // 拷贝复制

    // 看看拷贝成功没
    d1.Print();
    d2.Print();

    return 0;
}</code></pre>
<blockquote>
<p>🚩 运行结果如下：</p>
</blockquote>
<p><img alt="" height="128" src="image\9d6ef494314d4e2c8db76bac63157f50.png" width="532"/></p>
<p></p>
<p>❓ 为什么必须使用引用传参呢？</p>
<p>调用拷贝构造，需要先穿参数，传值传参又是一个拷贝构造。</p>
<p>调用拷贝构造，需要先穿参数，传值传参又是一个拷贝构造。</p>
<p>调用拷贝构造，需要先穿参数，传值传参又是一个拷贝构造。</p>
<p>……</p>
<p>一直在传参这里出不去了，所以这个递归是一个无穷无尽的。</p>
<p></p>
<p>💬 我们来验证一下：</p>
<p><img alt="" height="426" src="image\b8ca5dcd31e74606b361dbdf0ad20a0d.png" width="430"/></p>
<p><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">error: invalid constructor; you probably meant 'Date (const Date&amp;)'</span></span></p>
<p><img alt="" height="404" src="image\dafe45d28d1740c49848add2cf3efe6f.png" width="586"/></p>
<p>这里不是加不加 <span style="color:#956fe7;">const </span>的问题，而是没有用引用导致的问题。</p>
<p>不用引用，他就会在传参那无线套娃递归。至于为什么我们继续往下看。</p>
<p></p>
<p>💬 拷贝构造函数加<span style="color:#956fe7;"> const </span>：</p>
<p>如果函数内不需要改变，建议把<span style="color:#956fe7;"> const</span> 也给它加上</p>
<pre><code class="language-cpp">class Date {
public:
    Date(int year = 0, int month = 1, int day = 1) {
        _year = year;
        _month = month;
        _day = day;
    }

    /* Date d2(d1); */
    Date(const Date&amp; d) {    // 如果内部不需要改变，建议加上const
        _year = d._year;
        _month = d._month;
        _day = d._day;
    }

    void Print() {
        printf("%d-%d-%d\n", _year, _month, _day);
    }

private:
    int _year;
    int _month;
    int _day;
};</code></pre>
<p><strong>第一个原因：</strong>怕出错，万一你一不小心写反了怎么办？</p>
<pre><code class="language-cpp">/* Date d2(d1); */
Date(Date&amp; d) {
    d._year = _year;
    d._month = _month;
    d._day = _day;
}</code></pre>
<p>这样会产生一个很诡异的问题，这一个可以被编译出来的 BUG ，结果会变为随机值。</p>
<p>所以，这里加一个<span style="color:#956fe7;"> const </span>就安全多了，这些错误就会被检查出来了。</p>
<p></p>
<p><strong>第二个原因：</strong>以后再讲，因为涉及一些临时对象的概念。</p>
<p>🔺 反正，不想深究的话就记住：<span style="background-color:#f9eda6;">如果函数体内不需要改变，建议把</span><span style="color:#956fe7;"><span style="background-color:#f9eda6;"> const </span></span><span style="background-color:#f9eda6;">加上</span>就完事了。</p>
<p></p>
<p></p>
<h3 id="0x03%20%E5%85%B3%E4%BA%8E%E9%BB%98%E8%AE%A4%E7%94%9F%E6%88%90%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0">0x03 关于默认生成的拷贝构造</h3>
<p><img alt="" height="110" src="image\baca864b292e42edb1e4363b4746d530.png" width="109"/> 这里比较特殊，我们单独领出来讲。 </p>
<p></p>
<p>📚 默认生成拷贝构造：</p>
<p>① <span style="background-color:#f9eda6;">内置类型的成员，会完成按字节序的拷贝</span>（把每个字节依次拷贝过去）。</p>
<p>② 自定义类型成员，会再调用它的拷贝构造。</p>
<p>💬 拷贝构造我们不写生成的默认拷贝构造函数，对于内置类型和自定义类型都会拷贝处理。但是处理的细节是不一样的，这个跟构造和析构是不一样的！</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;

class Date {
    public:
        Date(int year = 0, int month = 1, int day = 1) {
            _year = year;
            _month = month;
            _day = day;
        }

        // Date(Date&amp; d) {
        //     _year = d._year;
        //     _month = d._month;
        //     _day = d._day;
        // }

        void Print() {
            printf("%d-%d-%d\n", _year, _month, _day);
        } 
    
    private:
        int _year;
        int _month;
        int _day;
};

int main(void)
{
    Date d1(2002, 4, 8);

    // 拷贝复制
    Date d2(d1);

    // 没有写拷贝构造，但是也拷贝成功了
    d1.Print();
    d2.Print();

    return 0;
}</code></pre>
<blockquote>
<p>🚩 运行结果如下：</p>
</blockquote>
<p><img alt="" height="120" src="image\3bbb3b3273604b7ab4990e1843ee9fa8.png" width="515"/></p>
<p>🔑 他这和之前几个不同了，这个他还真给我解决了。</p>
<p>所以为什么要写拷贝构造？写他有什么意义？没有什么意义。</p>
<p><img alt="" height="38" src="image\69a4d7d238d741c1a1ab62fb3e6cd376.png" width="38"/> 默认生成的一般就够用了！</p>
<p></p>
<p><img alt="" height="46" src="image\487032e9759a498b87423c35b61efb3f.png" width="52"/> 当然，这并不意味着我们都不用写了，有些情况还是不可避免要写的</p>
<p>比如实现栈的时候，栈的结构问题，导致这里如果用默认的 拷贝构造，会翻车。</p>
<p>按字节把所有东西都拷过来会产生问题，如果<span style="color:#e6b223;"> Stack</span> <strong>st1</strong> 拷贝出另一个 <span style="color:#e6b223;">Stack</span><strong> st2</strong>(<strong>st1</strong>) </p>
<p>会导致他们都指向那块开辟的内存空间，导致他们指向的空间被析构两次，导致程序崩溃</p>
<p>然而问题不止这些……</p>
<p><img alt="" height="98" src="https://img-blog.csdnimg.cn/5ce4e887e192427f89c32d72d9e450fa.gif" width="98"/> 其实这里的字节序拷贝是浅拷贝，下面几章我会详细讲一下深浅拷贝，这里的深拷贝和浅拷贝先做一个大概的了解。</p>
<p></p>
<p>🔺 总结：对于常见的类，比如日期类，默认生成的拷贝构造能用。但是对于栈这样的类，默认生成的拷贝构造不能用。</p>
<p></p>
<h2 id="%E2%85%A4.%C2%A0%20%E4%B8%89%E7%A7%8D%E6%9E%84%E9%80%A0%E7%9A%84%E6%80%BB%E7%BB%93">Ⅴ.  总结</h2>
<p><img alt="" height="126" src="image\2b2034afa08142ddbb2c07fb62943967.png" width="459"/></p>
<p>默认成员函数有六只，本篇只介绍了三只，剩下的我们后面讲。</p>
<p>类和对象部分知识很重要，所以我们来做一个简单的总结 ~</p>
<p></p>
<h3 id="0x00%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">0x00 构造函数 </h3>
<p><img alt="" height="87" src="image\0802eb38b3dc447bb9ed7babdf7e3c3d.png" width="78"/>初始化，在对象实例化时候自动调用，保证实例化对象一定被初始化。</p>
<p>构造函数是默认成员函数，我们不写编译器会自己生成一份，我们写了编译器就不会生成。</p>
<p>我们不写内置类型成员变量不处理。</p>
<p>对于内置类型成员变量不处理。</p>
<p>对于自定义类型的成员变量会调用它的默认构造函数。</p>
<pre><code class="language-cpp">// 我们需要自己实现构造函数
class Date {
    int _year;
    int _month;
    int _day;
};
        
// 我们不需要自己实现构造函数，默认生成的就可以
class MyQueue {
    Stack _pushST;
    Stack _popST;
};</code></pre>
<p></p>
<p></p>
<h3 id="0x01%20%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0">0x01 析构函数</h3>
<p><img alt="" height="90" src="image\2120e1dfd65f4b3c92909bb8a605cb91.png" width="83"/> 完成对象中自愿的清理。如果类对象需要资源清理，才需要自己实现析构函数。</p>
<p>析构函数在对象生命周期到了以后自动调用，如果你正确实现了析构函数，保证了类对象中的资源被清理。</p>
<p>什么时候生命周期到了？如果是局部变量，出了作用域。全局和静态变量，整个程序结束。</p>
<p>我们不写编译器会默认生成析构函数，我们实现了，编译器就不会实现了。</p>
<p>对于内置类型成员变量不处理。</p>
<p>对于自定义类型的成员变量会调用它的析构函数。</p>
<pre><code class="language-cpp">// 没有资源需要清理，不徐需要自己实现析构函数
class Date {
    int _year;
    int _month;
    int _day;
};

// 需要自己实现析构函数，清理资源。
class Stack {
    int* _a;
    int  _top;
    int  _capacity;
};</code></pre>
<p></p>
<h3 id="0x02%20%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0">0x02 拷贝构造</h3>
<p><img alt="" height="113" src="image\c90553d71b2c4a0ab0f90daf97457fc8.png" width="166"/>使用同类型的对象去初始化实例对象。</p>
<p>参数必须是引用！不然会导致无穷递归。</p>
<p></p>
<p>如果我们不实现，编译器会默认生成一份默认的拷贝构造函数。</p>
<p>默认生成的拷贝构造：</p>
<p>① 内置类型完成按子继续的值拷贝。 —— 浅拷贝</p>
<p>② 自定义类型的成员变量，会去调用它的拷贝构造。</p>
<pre><code class="language-cpp">// 不需要自己实现，默认生成的拷贝构造，完成浅拷贝就能满足需求
class Date {
    int _year;
    int _month;
    int _day;
};

// 需要自己实现，因为默认生成的浅拷贝不能满足需求。
// 我们需要自己实现深拷贝的拷贝构造，深拷贝我们后面会用专门的章节去讲解。        
class Stack {
    int* _a;
    int  _top;
    int  _capacity;
};</code></pre>
<p></p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class Date {
public:
    Date(int year = 1, int month = 0, int day = 0) {
        _year = year;
        _month = month;
        _day = day;
    }

    void Print() {
        printf("%d-%d-%d\n", _year, _month, _day);
    }

    ~Date() {
        cout &lt;&lt; "&amp;Date()" &lt;&lt; endl;
    }

private:
    int _year;
    int _month;
    int _day;
};

int main(void)
{
    Date d1;
    d1.Print();

    Date d2(2002);
    d2.Print();

    Date d3(2022, 3);
    d3.Print();

    Date d4(2022, 3, 9);
    d4.Print();

    return 0;
}</code></pre>
<blockquote>
<p> 🚩 运行结果如下：</p>
</blockquote>
<p><img alt="" height="213" src="image\d3768872beb641cd9e88ae021c0cd870.png" width="509"/></p>
<p></p>
<p></p>
<hr/>
<p><strong>参考资料：</strong></p>
<p><span style="color:#a5a5a5;">Microsoft. MSDN(Microsoft Developer Network)[EB/OL]. []. .</span></p>
<p><span style="color:#a5a5a5;">百度百科[EB/OL]. []. https://baike.baidu.com/.</span></p>
<p><span style="color:#a5a5a5;">比特科技. C++[EB/OL]. 2021[2021.8.31]. .</span></p>
<blockquote>
<p>📌 笔者：王亦优</p>
<p>📃 更新： 2022.3.15</p>
<p>❌ 勘误：Star丶北辰：拿栈举例时malloc空间 sizeof 有误【已修正】</p>
<p>📜 声明： 由于作者水平有限，本文有错误和不准确之处在所难免，本人也很想知道这些错误，恳望读者批评指正！</p>
</blockquote>
<p></p>
<p>本章完。</p>
</div>
</div>