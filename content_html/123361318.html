<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="markdown_views prism-github-gist" id="content_views">
<svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
<path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
</svg>
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        By 
       
       
        
         C
        
        
         h
        
        
         e
        
        
         s
        
        
         i
        
        
         u
        
        
         m
        
       
      
      
       \text{By}\ \mathsf{Chesium}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord text"><span class="mord">By</span></span><span class="mspace"> </span><span class="mord"><span class="mord mathsf">C</span><span class="mord mathsf">h</span><span class="mord mathsf">e</span><span class="mord mathsf">s</span><span class="mord mathsf">i</span><span class="mord mathsf">u</span><span class="mord mathsf">m</span></span></span></span></span></span></p>
<p><strong>DPLL 算法</strong>，全称为 Davis-Putnam-Logemann-Loveland（戴维斯-普特南-洛吉曼-洛夫兰德）算法，是一种完备的，基于<strong>回溯</strong>（backtracking）的搜索算法，用于判定命题逻辑公式（为合取范式形式）的<strong>可满足性</strong>，也就是求解 SAT（布尔可满足性问题）的一种（或者一类）算法。</p>
<h3><a id="SAT__4"></a>SAT 问题简介</h3>
<p>何为布尔可满足性问题？给定一条真值表达式，包含<strong>逻辑变量</strong>（又称 <em>变量</em>、<em>命题变号</em>、<em>原子</em>，用小写字母 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        a
       
       
        ,
       
       
        b
       
       
        ,
       
       
        …
       
      
      
       a,b,\dots
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="minner">…</span></span></span></span></span> 表示）、<strong>逻辑与</strong>（AND，记为 “<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        ∧
       
      
      
       \wedge
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.55556em; vertical-align: 0em;"></span><span class="mord">∧</span></span></span></span></span>” ）运算符、<strong>逻辑或</strong>（OR，记为 “<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        ∨
       
      
      
       \vee
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.55556em; vertical-align: 0em;"></span><span class="mord">∨</span></span></span></span></span>” ）运算符以及<strong>非</strong>（NOT，否定，记为“<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        ¬
       
      
      
       \neg
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord">¬</span></span></span></span></span>”）运算符，如：<br/> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         a
        
        
         ∧
        
        
         ¬
        
        
         b
        
        
         ∧
        
        
         (
        
        
         ¬
        
        
         (
        
        
         c
        
        
         ∨
        
        
         d
        
        
         ∨
        
        
         ¬
        
        
         a
        
        
         )
        
        
         ∨
        
        
         (
        
        
         b
        
        
         ∧
        
        
         ¬
        
        
         d
        
        
         )
        
        
         )
        
        
         )
        
        
         ∨
        
        
         (
        
        
         ¬
        
        
         (
        
        
         ¬
        
        
         (
        
        
         ¬
        
        
         b
        
        
         ∨
        
        
         a
        
        
         )
        
        
         ∧
        
        
         c
        
        
         )
        
        
         ∧
        
        
         d
        
        
         )
        
       
       
         (a\wedge\neg b\wedge(\neg(c\vee d\vee\neg a)\vee(b\wedge\neg d)))\vee(\neg(\neg(\neg b\vee a)\wedge c)\wedge d) 
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord">¬</span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">¬</span><span class="mopen">(</span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">¬</span><span class="mord mathdefault">a</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">¬</span><span class="mord mathdefault">d</span><span class="mclose">)</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">¬</span><span class="mopen">(</span><span class="mord">¬</span><span class="mopen">(</span><span class="mord">¬</span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">a</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">c</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">d</span><span class="mclose">)</span></span></span></span></span></span><br/> 是否存在一组对这些变量的赋值（如把所有 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        a
       
      
      
       a
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">a</span></span></span></span></span> 和 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        d
       
      
      
       d
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault">d</span></span></span></span></span> 均赋值为 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        T
       
       
        r
       
       
        u
       
       
        e
       
      
      
       \mathrm{True}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathrm">T</span><span class="mord mathrm">r</span><span class="mord mathrm">u</span><span class="mord mathrm">e</span></span></span></span></span></span> ，将所有 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        b
       
      
      
       b
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault">b</span></span></span></span></span> 和 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        c
       
      
      
       c
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">c</span></span></span></span></span> 赋值为 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        F
       
       
        a
       
       
        l
       
       
        s
       
       
        e
       
      
      
       \mathrm{False}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathrm">F</span><span class="mord mathrm">a</span><span class="mord mathrm">l</span><span class="mord mathrm">s</span><span class="mord mathrm">e</span></span></span></span></span></span> ），使得整条式子最终的运算结果为 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        T
       
       
        r
       
       
        u
       
       
        e
       
      
      
       \mathrm{True}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathrm">T</span><span class="mord mathrm">r</span><span class="mord mathrm">u</span><span class="mord mathrm">e</span></span></span></span></span></span> ？若可以，那么这个性质被称为这条逻辑公式的<strong>可满足性</strong>（satisfiability），如何快速高效地判断任意指定逻辑公式的可满足性是理论计算机科学中的一个重要的问题，也是第一个被证明为<strong>NP-完全</strong>（NP-complete，NPC）的问题。</p>
<h3><a id="_12"></a>暴力方案</h3>
<p>对于这个问题，我们能够很容易地想到一种“暴力”的判定方法：测试这些变量赋值的每种可能的排列方式（如全部赋为 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        T
       
       
        r
       
       
        u
       
       
        e
       
      
      
       \mathrm{True}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathrm">T</span><span class="mord mathrm">r</span><span class="mord mathrm">u</span><span class="mord mathrm">e</span></span></span></span></span></span> 、其一为 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        T
       
       
        r
       
       
        u
       
       
        e
       
      
      
       \mathrm{True}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathrm">T</span><span class="mord mathrm">r</span><span class="mord mathrm">u</span><span class="mord mathrm">e</span></span></span></span></span></span> 其他全为 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        F
       
       
        a
       
       
        l
       
       
        s
       
       
        e
       
      
      
       \mathrm{False}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathrm">F</span><span class="mord mathrm">a</span><span class="mord mathrm">l</span><span class="mord mathrm">s</span><span class="mord mathrm">e</span></span></span></span></span></span> ……），若存在一种赋值排列使得公式的结果为 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        T
       
       
        r
       
       
        u
       
       
        e
       
      
      
       \mathrm{True}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathrm">T</span><span class="mord mathrm">r</span><span class="mord mathrm">u</span><span class="mord mathrm">e</span></span></span></span></span></span> ，那么就可以说明这条公式是可满足的。但很显然，最坏情况下这种方法需要我们测试 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         2
        
        
         n
        
       
      
      
       2^n
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.664392em; vertical-align: 0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.664392em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span></span> 种（<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        n
       
      
      
       n
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span></span></span></span></span> 为变量数）赋值排列，而用于检查每种赋值排列最终的运算结果也是不可忽略的。因此，随着公式规模的扩大，这种暴力算法所需的运算量会呈指数级飞快增长，这是我们不可接受的。</p>
<h3><a id="_16"></a>算法概述</h3>
<p>但是根据现有计算复杂度理论，SAT问题是无法在多项式时间复杂度内解决的，DPLL算法也不例外。</p>
<p>DPLL算法是一种搜索算法，思想与DFS（Depth-first search，深度优先搜索）十分相似，或者说DPLL算法本身就属于DFS的范畴，其类似于上述我们设想的“暴力”算法：搜索所有可能的赋值排列。</p>
<p>具体地说，算法会在公式中选择一个变量（命题变号），将其赋值为 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        T
       
       
        r
       
       
        u
       
       
        e
       
      
      
       \mathrm{True}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathrm">T</span><span class="mord mathrm">r</span><span class="mord mathrm">u</span><span class="mord mathrm">e</span></span></span></span></span></span> ，化简赋值后的公式，如果简化的公式是可满足的（递归地判断），那么原公式也是可满足的。否则就反过来将该变量赋值为 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        F
       
       
        a
       
       
        l
       
       
        s
       
       
        e
       
      
      
       \mathrm{False}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathrm">F</span><span class="mord mathrm">a</span><span class="mord mathrm">l</span><span class="mord mathrm">s</span><span class="mord mathrm">e</span></span></span></span></span></span> ，再执行一遍递归的判定，若也不能满足，那么原公式便是不可满足的。</p>
<p>这被称为 <em>分离规则</em> （splitting rule），因为其将原问题分离为了两个更加简单的问题。</p>
<h3><a id="_26"></a>概念说明</h3>
<p>DPLL算法求解的是<strong>合取范式</strong>（Conjunctive normal form，CNF），这是指形如下式的逻辑公式：<br/> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         a
        
        
         ∨
        
        
         b
        
        
         ∨
        
        
         ¬
        
        
         c
        
        
         )
        
        
         ∧
        
        
         (
        
        
         ¬
        
        
         d
        
        
         ∨
        
        
         
          x
         
         
          1
         
        
        
         ∨
        
        
         ¬
        
        
         
          x
         
         
          2
         
        
        
         ∨
        
        
         ⋯
        
        
         ∨
        
        
         
          x
         
         
          7
         
        
        
         )
        
        
         ∧
        
        
         (
        
        
         ¬
        
        
         r
        
        
         ∨
        
        
         v
        
        
         ∨
        
        
         g
        
        
         )
        
        
         ∧
        
        
         ⋯
        
        
         ∧
        
        
         (
        
        
         a
        
        
         ∨
        
        
         d
        
        
         ∨
        
        
         ¬
        
        
         d
        
        
         )
        
       
       
         (a\vee b\vee\neg c)\wedge (\neg d\vee x_1\vee\neg x_2\vee\dots\vee x_7)\wedge (\neg r\vee v\vee g)\wedge\dots\wedge (a\vee d\vee\neg d) 
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">¬</span><span class="mord mathdefault">c</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">¬</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.70556em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.70556em; vertical-align: -0.15em;"></span><span class="mord">¬</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.55556em; vertical-align: 0em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">¬</span><span class="mord mathdefault" style="margin-right: 0.02778em;">r</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.55556em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.55556em; vertical-align: 0em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">¬</span><span class="mord mathdefault">d</span><span class="mclose">)</span></span></span></span></span></span><br/> 其由多个括号括住部分的<strong>逻辑与</strong>组成，每一个括号内又是许多变量或变量的<strong>否定</strong>（逻辑非）的<strong>逻辑或</strong>组成。可以证明，所有只包含逻辑与、逻辑或、逻辑非、逻辑蕴含和括号的逻辑公式均可化为等价的合取范式。下面，我们称整个范式为“公式”，称每个括号里的部分为该公式的<strong>子句</strong>（clause），每个子句中的每个变量或其否定为<strong>文字</strong>（literal）。</p>
<p>可以看出，要使整条公式结果为 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        T
       
       
        r
       
       
        u
       
       
        e
       
      
      
       \mathrm{True}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathrm">T</span><span class="mord mathrm">r</span><span class="mord mathrm">u</span><span class="mord mathrm">e</span></span></span></span></span></span> ，其所有子句都必须为 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        T
       
       
        r
       
       
        u
       
       
        e
       
      
      
       \mathrm{True}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathrm">T</span><span class="mord mathrm">r</span><span class="mord mathrm">u</span><span class="mord mathrm">e</span></span></span></span></span></span> ，也就是说，每个子句中都至少有一个文字为 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        T
       
       
        r
       
       
        u
       
       
        e
       
      
      
       \mathrm{True}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathrm">T</span><span class="mord mathrm">r</span><span class="mord mathrm">u</span><span class="mord mathrm">e</span></span></span></span></span></span> ，这个结论下面会用到。</p>
<p>DPLL 算法中的化简步骤实际上就是移除所有在赋值后值为 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        T
       
       
        r
       
       
        u
       
       
        e
       
      
      
       \mathrm{True}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathrm">T</span><span class="mord mathrm">r</span><span class="mord mathrm">u</span><span class="mord mathrm">e</span></span></span></span></span></span> 的子句，以及所有在赋值后值为 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        F
       
       
        a
       
       
        l
       
       
        s
       
       
        e
       
      
      
       \mathrm{False}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathrm">F</span><span class="mord mathrm">a</span><span class="mord mathrm">l</span><span class="mord mathrm">s</span><span class="mord mathrm">e</span></span></span></span></span></span> 的文字。</p>
<h3><a id="_41"></a>化简步骤</h3>
<p>这两个化简步骤是 DPLL 算法与我们“暴力”算法的主要区别，它们大大减少了搜索量，亦即加快了算法的运行速度。</p>
<h4><a id="Unit_propagation_45"></a>第一个化简步骤：<strong>单位子句传播</strong>（Unit propagation）</h4>
<p>我们称只含有一个（未赋值）变量的子句为<strong>单位子句</strong>（unit clause），根据上面的结论，要想让公式为 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        T
       
       
        r
       
       
        u
       
       
        e
       
      
      
       \mathrm{True}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathrm">T</span><span class="mord mathrm">r</span><span class="mord mathrm">u</span><span class="mord mathrm">e</span></span></span></span></span></span> ，这个子句必须为 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        T
       
       
        r
       
       
        u
       
       
        e
       
      
      
       \mathrm{True}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathrm">T</span><span class="mord mathrm">r</span><span class="mord mathrm">u</span><span class="mord mathrm">e</span></span></span></span></span></span> ，即这个变量对应的文字必须被赋值为 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        T
       
       
        r
       
       
        u
       
       
        e
       
      
      
       \mathrm{True}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathrm">T</span><span class="mord mathrm">r</span><span class="mord mathrm">u</span><span class="mord mathrm">e</span></span></span></span></span></span> 。</p>
<p>比如下面的这条公式：<br/> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         a
        
        
         ∨
        
        
         b
        
        
         ∨
        
        
         c
        
        
         ∨
        
        
         ¬
        
        
         d
        
        
         )
        
        
         ∧
        
        
         (
        
        
         ¬
        
        
         a
        
        
         ∨
        
        
         c
        
        
         )
        
        
         ∧
        
        
         (
        
        
         ¬
        
        
         c
        
        
         ∨
        
        
         d
        
        
         )
        
        
         ∧
        
        
         (
        
        
         a
        
        
         )
        
       
       
         (a\vee b\vee c\vee\neg d)\wedge(\neg a\vee c)\wedge(\neg c\vee d)\wedge(a) 
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.55556em; vertical-align: 0em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">¬</span><span class="mord mathdefault">d</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">¬</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">c</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">¬</span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">d</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mclose">)</span></span></span></span></span></span><br/> 其中最后一个子句就为单位子句，亦即我们要使文字 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        (
       
       
        a
       
       
        )
       
      
      
       (a)
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mclose">)</span></span></span></span></span> 为 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        T
       
       
        r
       
       
        u
       
       
        e
       
      
      
       \mathrm{True}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathrm">T</span><span class="mord mathrm">r</span><span class="mord mathrm">u</span><span class="mord mathrm">e</span></span></span></span></span></span> 。</p>
<p>然后，我们要依次处理这个变量在其他子句中的出现，如果另一个子句中的一个文字与单位子句中的文字相同，如上面例子中的 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        (
       
       
        a
       
       
        ∨
       
       
        b
       
       
        ∨
       
       
        c
       
       
        ∨
       
       
        ¬
       
       
        d
       
       
        )
       
      
      
       (a\vee b\vee c\vee\neg d)
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.55556em; vertical-align: 0em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">¬</span><span class="mord mathdefault">d</span><span class="mclose">)</span></span></span></span></span> 子句，我们知道 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        (
       
       
        a
       
       
        )
       
      
      
       (a)
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mclose">)</span></span></span></span></span> 的值必须为 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        T
       
       
        r
       
       
        u
       
       
        e
       
      
      
       \mathrm{True}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathrm">T</span><span class="mord mathrm">r</span><span class="mord mathrm">u</span><span class="mord mathrm">e</span></span></span></span></span></span> ，所以这个子句也肯定为 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        T
       
       
        r
       
       
        u
       
       
        e
       
      
      
       \mathrm{True}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathrm">T</span><span class="mord mathrm">r</span><span class="mord mathrm">u</span><span class="mord mathrm">e</span></span></span></span></span></span> ，这意味着这个子句就不会对整个公式产生额外的约束（即 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        b
       
       
        ,
       
       
        c
       
       
        ,
       
       
        d
       
      
      
       b,c,d
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault">d</span></span></span></span></span> 的取值不会影响该子句的取值），我们完全可以忽略这个子句，那就删掉它吧。</p>
<p>再考虑上式中第二个子句，其中出现了 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        (
       
       
        a
       
       
        )
       
      
      
       (a)
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mclose">)</span></span></span></span></span> 的否定文字，我们知道它不可能为 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        T
       
       
        r
       
       
        u
       
       
        e
       
      
      
       \mathrm{True}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathrm">T</span><span class="mord mathrm">r</span><span class="mord mathrm">u</span><span class="mord mathrm">e</span></span></span></span></span></span> 了，要让这个子句的值为 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        T
       
       
        r
       
       
        u
       
       
        e
       
      
      
       \mathrm{True}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathrm">T</span><span class="mord mathrm">r</span><span class="mord mathrm">u</span><span class="mord mathrm">e</span></span></span></span></span></span> ，只能寄希望于 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        c
       
      
      
       c
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">c</span></span></span></span></span> 的取值了，我们完全可以把 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        ¬
       
       
        a
       
      
      
       \neg a
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord">¬</span><span class="mord mathdefault">a</span></span></span></span></span> 删除（因为有没有它不影响该子句的取值）。</p>
<p>而第上式中第三个子句不包含 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        (
       
       
        a
       
       
        )
       
      
      
       (a)
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mclose">)</span></span></span></span></span> 或其否定的出现，即 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        a
       
      
      
       a
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">a</span></span></span></span></span> 的取值不影响这个子句的取值，我们保持其不变即可。</p>
<p>这样，上述公式便被化简为了：<br/> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         c
        
        
         )
        
        
         ∧
        
        
         (
        
        
         ¬
        
        
         c
        
        
         ∨
        
        
         d
        
        
         )
        
        
         ∧
        
        
         (
        
        
         a
        
        
         )
        
       
       
         (c)\wedge(\neg c\vee d)\wedge(a) 
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">c</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">¬</span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">d</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mclose">)</span></span></span></span></span></span><br/> 这个操作就被称为<strong>单位子句传播</strong>。</p>
<p>概括：<strong>对于所有只包含一个文字 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         L
        
       
       
        \mathrm{L}
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathrm">L</span></span></span></span></span></span> 的子句，对于公式剩余部分中的每个子句 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         C
        
       
       
        \mathrm{C}
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathrm">C</span></span></span></span></span></span>：</strong></p>
<ul><li><strong>若 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
      
       
        
         
          C
         
        
        
         \mathrm{C}
        
       
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathrm">C</span></span></span></span></span></span> 包含 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
      
       
        
         
          L
         
        
        
         \mathrm{L}
        
       
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathrm">L</span></span></span></span></span></span>（非否定），则删除 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
      
       
        
         
          C
         
        
        
         \mathrm{C}
        
       
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathrm">C</span></span></span></span></span></span>。</strong></li><li><strong>若 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
      
       
        
         
          C
         
        
        
         \mathrm{C}
        
       
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathrm">C</span></span></span></span></span></span> 包含 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
      
       
        
         
          ¬
         
         
          L
         
        
        
         \neg\mathrm{L}
        
       
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord">¬</span><span class="mord"><span class="mord mathrm">L</span></span></span></span></span></span>，则删除这个 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
      
       
        
         
          ¬
         
         
          L
         
        
        
         \neg\mathrm{L}
        
       
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord">¬</span><span class="mord"><span class="mord mathrm">L</span></span></span></span></span></span>。</strong></li></ul>
<p>经过一次操作，我们发现公式中又出现了一个新的单位子句 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        (
       
       
        c
       
       
        )
       
      
      
       (c)
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">c</span><span class="mclose">)</span></span></span></span></span> ，我们可以继续对其实施一遍单位子句传播，一直到整个公式中不存在任何一个单位子句对应的变量在其他子句中出现为止。</p>
<p>上式可被化简为：<br/> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         c
        
        
         )
        
        
         ∧
        
        
         (
        
        
         d
        
        
         )
        
        
         ∧
        
        
         (
        
        
         a
        
        
         )
        
       
       
         (c)\wedge(d)\wedge(a) 
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">c</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mclose">)</span></span></span></span></span></span><br/> 现在即使公式中每个子句都是单位子句，但是其分别对应的变量 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        c
       
       
        ,
       
       
        d
       
       
        ,
       
       
        a
       
      
      
       c,d,a
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord mathdefault">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault">d</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault">a</span></span></span></span></span> 没有在除单位子句之外的子句中出现了，单位子句传播已经没有用了，我们要实施第二个化简步骤。</p>
<h4><a id="Pure_literal_elimination_80"></a>第二个化简步骤：<strong>孤立文字消去</strong>（Pure literal elimination）</h4>
<p>如果一个变量在整个公式中只出现了一次，那么我们可以将其进行恰当的赋值，使其所在的子句为 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        T
       
       
        r
       
       
        u
       
       
        e
       
      
      
       \mathrm{True}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathrm">T</span><span class="mord mathrm">r</span><span class="mord mathrm">u</span><span class="mord mathrm">e</span></span></span></span></span></span> 。具体地说，如果其出现的那一次是以否定形式出现的，那么就将变量赋值为 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        F
       
       
        a
       
       
        l
       
       
        s
       
       
        e
       
      
      
       \mathrm{False}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathrm">F</span><span class="mord mathrm">a</span><span class="mord mathrm">l</span><span class="mord mathrm">s</span><span class="mord mathrm">e</span></span></span></span></span></span> ，这可使其对应文字为 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        T
       
       
        r
       
       
        u
       
       
        e
       
      
      
       \mathrm{True}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathrm">T</span><span class="mord mathrm">r</span><span class="mord mathrm">u</span><span class="mord mathrm">e</span></span></span></span></span></span> ，即使其所在子句为 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        T
       
       
        r
       
       
        u
       
       
        e
       
      
      
       \mathrm{True}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathrm">T</span><span class="mord mathrm">r</span><span class="mord mathrm">u</span><span class="mord mathrm">e</span></span></span></span></span></span> ，反正则将变量赋值为 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        T
       
       
        r
       
       
        u
       
       
        e
       
      
      
       \mathrm{True}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathrm">T</span><span class="mord mathrm">r</span><span class="mord mathrm">u</span><span class="mord mathrm">e</span></span></span></span></span></span> ，最终也能使其所在的子句为 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        T
       
       
        r
       
       
        u
       
       
        e
       
      
      
       \mathrm{True}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathrm">T</span><span class="mord mathrm">r</span><span class="mord mathrm">u</span><span class="mord mathrm">e</span></span></span></span></span></span> ，接下来就和上述单位子句传播中发现子句为 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        T
       
       
        r
       
       
        u
       
       
        e
       
      
      
       \mathrm{True}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathrm">T</span><span class="mord mathrm">r</span><span class="mord mathrm">u</span><span class="mord mathrm">e</span></span></span></span></span></span> 时的处理方式相同——删掉这个子句。</p>
<p>一句话概括，就为：<strong>删除所有孤立变量所在的子句</strong>。</p>
<p>对于以下的公式：<br/> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         ¬
        
        
         r
        
        
         ∨
        
        
         u
        
        
         )
        
        
         ∧
        
        
         (
        
        
         r
        
        
         ∨
        
        
         
          c
         
        
        
         ∨
        
        
         ¬
        
        
         u
        
        
         )
        
        
         ∧
        
        
         (
        
        
         ¬
        
        
         k
        
        
         ∨
        
        
         r
        
        
         )
        
        
         ∧
        
        
         (
        
        
         
          ¬
         
         
          d
         
        
        
         ∧
        
        
         k
        
        
         )
        
       
       
         (\neg r\vee u)\wedge(r\vee \textcolor{red}{c}\vee\neg u)\wedge(\neg k\vee r)\wedge(\textcolor{blue}{\neg d}\wedge k) 
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">¬</span><span class="mord mathdefault" style="margin-right: 0.02778em;">r</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">u</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.02778em;">r</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.55556em; vertical-align: 0em;"></span><span class="mord mathdefault" style="color: red;">c</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">¬</span><span class="mord mathdefault">u</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">¬</span><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">r</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord" style="color: blue;">¬</span><span class="mord mathdefault" style="color: blue;">d</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span><span class="mclose">)</span></span></span></span></span></span><br/> 其中标红的变量 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        c
       
      
      
       c
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">c</span></span></span></span></span> 在整个公式中只出现了一次，我们可以将其赋值为 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        T
       
       
        r
       
       
        u
       
       
        e
       
      
      
       \mathrm{True}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathrm">T</span><span class="mord mathrm">r</span><span class="mord mathrm">u</span><span class="mord mathrm">e</span></span></span></span></span></span> 使得其所在的子句 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        (
       
       
        r
       
       
        ∨
       
       
        
         c
        
       
       
        ∨
       
       
        ¬
       
       
        u
       
       
        )
       
      
      
       (r\vee \textcolor{red}{c}\vee\neg u)
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.02778em;">r</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.55556em; vertical-align: 0em;"></span><span class="mord mathdefault" style="color: red;">c</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">¬</span><span class="mord mathdefault">u</span><span class="mclose">)</span></span></span></span></span> 为 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        T
       
       
        r
       
       
        u
       
       
        e
       
      
      
       \mathrm{True}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathrm">T</span><span class="mord mathrm">r</span><span class="mord mathrm">u</span><span class="mord mathrm">e</span></span></span></span></span></span> ，我们可以将这个子句删除。同样的，标蓝的变量 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        d
       
      
      
       d
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault">d</span></span></span></span></span> 在整个公式中只出现了一次，且是以否定形式出现的，我们可以将其赋值为 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        F
       
       
        a
       
       
        l
       
       
        s
       
       
        e
       
      
      
       \mathrm{False}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathrm">F</span><span class="mord mathrm">a</span><span class="mord mathrm">l</span><span class="mord mathrm">s</span><span class="mord mathrm">e</span></span></span></span></span></span> ，使其所在子句为 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        T
       
       
        r
       
       
        u
       
       
        e
       
      
      
       \mathrm{True}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathrm">T</span><span class="mord mathrm">r</span><span class="mord mathrm">u</span><span class="mord mathrm">e</span></span></span></span></span></span> ，我们也可以将其删除。由此，公式被化简为了：<br/> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         ¬
        
        
         r
        
        
         ∨
        
        
         u
        
        
         )
        
        
         ∧
        
        
         (
        
        
         ¬
        
        
         k
        
        
         ∨
        
        
         r
        
        
         )
        
       
       
         (\neg r\vee u)\wedge(\neg k\vee r) 
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">¬</span><span class="mord mathdefault" style="margin-right: 0.02778em;">r</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">u</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">¬</span><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">r</span><span class="mclose">)</span></span></span></span></span></span><br/> 再来看上面的例子：<br/> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         c
        
        
         )
        
        
         ∧
        
        
         (
        
        
         d
        
        
         )
        
        
         ∧
        
        
         (
        
        
         a
        
        
         )
        
       
       
         (c)\wedge(d)\wedge(a) 
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">c</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mclose">)</span></span></span></span></span></span><br/> 所有三个变量都是孤立出现的，我们可以把这三个子句全部删除，整个公式就为空了，由此我们能判断出原公式是可满足的。</p>
<p>以上就是这两个化简步骤。</p>
<h3><a id="_102"></a>算法流程</h3>
<p>下面给出 DPLL 算法的伪代码，先前说过，DPLL 算法实质上是一个深度优先搜索算法，所以两者十分相似。<br/> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml">
     
      
       
        
         
          
           
          
         
         
          
           
            
            
             1
            
            
            
             
              A
             
             
              l
             
             
              g
             
             
              o
             
             
              r
             
             
              i
             
             
              t
             
             
              h
             
             
              m
             
            
            
               
            
            
             
              D
             
             
              P
             
             
              L
             
             
              L
             
            
            
             (
            
            
             
              C
             
             
              N
             
             
              F
             
            
            
               
            
            
             
              Φ
             
            
            
             )
            
            
             :
            
            
             =
            
           
          
         
        
        
         
          
           
          
         
         
          
           
            
            
             2
            
            
            
            
             
              d
             
             
              o
             
            
            
               UP
            
            
             (
            
            
             
              Φ
             
            
            
             )
            
            
               
            
            
             
              u
             
             
              n
             
             
              t
             
             
              i
             
             
              l
             
            
            
               It changed nothing
            
            
             .
            
           
          
         
        
        
         
          
           
          
         
         
          
           
            
            
             3
            
            
            
            
             
              d
             
             
              o
             
            
            
               PLE
            
            
             (
            
            
             
              Φ
             
            
            
             )
            
            
               
            
            
             
              u
             
             
              n
             
             
              t
             
             
              i
             
             
              l
             
            
            
               It changed nothing
            
            
             .
            
           
          
         
        
        
         
          
           
          
         
         
          
           
            
            
             4
            
            
            
            
             
              i
             
             
              f
             
            
            
               
            
            
             
              Φ
             
            
            
             =
            
            
             ∅
            
            
               
            
            
             
              t
             
             
              h
             
             
              e
             
             
              n
             
            
           
          
         
        
        
         
          
           
          
         
         
          
           
            
            
             5
            
            
            
            
            
             
              r
             
             
              e
             
             
              t
             
             
              u
             
             
              r
             
             
              n
             
            
            
               
            
            
             
              t
             
             
              r
             
             
              u
             
             
              e
             
            
            
             .
            
           
          
         
        
        
         
          
           
          
         
         
          
           
            
            
             6
            
            
            
            
             
              i
             
             
              f
             
            
            
               
            
            
             ∃
            
            
             L
            
            
             ∈
            
            
             
              Φ
             
            
            
             ,
            
            
             L
            
            
             =
            
            
             ∅
            
            
               
            
            
             
              t
             
             
              h
             
             
              e
             
             
              n
             
            
           
          
         
        
        
         
          
           
          
         
         
          
           
            
            
             7
            
            
            
            
            
             
              r
             
             
              e
             
             
              t
             
             
              u
             
             
              r
             
             
              n
             
            
            
               
            
            
             
              f
             
             
              a
             
             
              l
             
             
              s
             
             
              e
             
            
            
             .
            
           
          
         
        
        
         
          
           
          
         
         
          
           
            
            
             8
            
            
            
            
             x
            
            
             ←
            
            
             
              C
             
             
              h
             
             
              o
             
             
              o
             
             
              s
             
             
              e
             
             
              V
             
             
              a
             
             
              r
             
             
              i
             
             
              a
             
             
              b
             
             
              l
             
             
              e
             
            
            
             (
            
            
             
              Φ
             
            
            
             )
            
           
          
         
        
        
         
          
           
          
         
         
          
           
            
            
             9
            
            
            
            
             
              r
             
             
              e
             
             
              t
             
             
              u
             
             
              r
             
             
              n
             
            
            
               
            
            
             
              D
             
             
              P
             
             
              L
             
             
              L
             
            
            
             (
            
            
             
              
               Φ
              
             
             
              
               x
              
              
               →
              
              
               
                t
               
               
                r
               
               
                u
               
               
                e
               
              
             
            
            
             )
            
            
               
            
            
             
              o
             
             
              r
             
            
            
               
            
            
             
              D
             
             
              P
             
             
              L
             
             
              L
             
            
            
             (
            
            
             
              
               Φ
              
             
             
              
               x
              
              
               →
              
              
               
                f
               
               
                a
               
               
                l
               
               
                s
               
               
                e
               
              
             
            
            
             )
            
           
          
         
        
       
       
         \begin{aligned} &amp;\mathtt{1}\quad \mathtt{\textcolor{red}{Algorithm}}\ \ \mathrm{DPLL}(\mathtt{CNF}\ \ \textcolor{green}{\Phi}):=\\ &amp;\mathtt{2}\quad\qquad \mathtt{\textcolor{red}{do}}\ \ \text{UP}(\textcolor{green}{\Phi})\ \ \mathtt{\textcolor{red}{until}}\ \ \text{It changed nothing}.\\ &amp;\mathtt{3}\quad\qquad \mathtt{\textcolor{red}{do}}\ \ \text{PLE}(\textcolor{green}{\Phi})\ \ \mathtt{\textcolor{red}{until}}\ \ \text{It changed nothing}.\\ &amp;\mathtt{4}\quad\qquad \mathtt{\textcolor{red}{if}}\ \ \textcolor{green}{\Phi}=\varnothing\ \ \mathtt{\textcolor{red}{then}}\\ &amp;\mathtt{5}\quad\qquad\qquad \mathtt{\textcolor{red}{return}}\ \ \mathrm{\textcolor{blue}{true}}.\\ &amp;\mathtt{6}\quad\qquad \mathtt{\textcolor{red}{if}}\ \ \exists L\in\textcolor{green}{\Phi},L=\varnothing\ \ \mathtt{\textcolor{red}{then}}\\ &amp;\mathtt{7}\quad\qquad\qquad \mathtt{\textcolor{red}{return}}\ \ \mathrm{\textcolor{blue}{false}}.\\ &amp;\mathtt{8}\quad\qquad x\leftarrow\mathrm{ChooseVariable}(\textcolor{green}{\Phi})\\ &amp;\mathtt{9}\quad\qquad \mathtt{\textcolor{red}{return}}\ \ \mathrm{DPLL}(\textcolor{green}{\Phi}_{x\to\mathrm{\textcolor{blue}{true}}}) \ \ \mathtt{\textcolor{red}{or}}\ \ \mathrm{DPLL}(\textcolor{green}{\Phi}_{x\to\mathrm{\textcolor{blue}{false}}}) \end{aligned} 
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 13.5em; vertical-align: -6.5em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 7em;"><span class="" style="top: -9em;"><span class="pstrut" style="height: 2.84em;"></span><span class="mord"></span></span><span class="" style="top: -7.5em;"><span class="pstrut" style="height: 2.84em;"></span><span class="mord"></span></span><span class="" style="top: -6em;"><span class="pstrut" style="height: 2.84em;"></span><span class="mord"></span></span><span class="" style="top: -4.5em;"><span class="pstrut" style="height: 2.84em;"></span><span class="mord"></span></span><span class="" style="top: -3em;"><span class="pstrut" style="height: 2.84em;"></span><span class="mord"></span></span><span class="" style="top: -1.5em;"><span class="pstrut" style="height: 2.84em;"></span><span class="mord"></span></span><span class="" style="top: 8.88178e-16em;"><span class="pstrut" style="height: 2.84em;"></span><span class="mord"></span></span><span class="" style="top: 1.5em;"><span class="pstrut" style="height: 2.84em;"></span><span class="mord"></span></span><span class="" style="top: 3em;"><span class="pstrut" style="height: 2.84em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 6.5em;"><span class=""></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 7em;"><span class="" style="top: -9.16em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord"></span><span class="mord"><span class="mord mathtt">1</span></span><span class="mspace" style="margin-right: 1em;"></span><span class="mord"><span class="mord mathtt" style="color: red;">A</span><span class="mord mathtt" style="color: red;">l</span><span class="mord mathtt" style="color: red;">g</span><span class="mord mathtt" style="color: red;">o</span><span class="mord mathtt" style="color: red;">r</span><span class="mord mathtt" style="color: red;">i</span><span class="mord mathtt" style="color: red;">t</span><span class="mord mathtt" style="color: red;">h</span><span class="mord mathtt" style="color: red;">m</span></span><span class="mspace"> </span><span class="mspace"> </span><span class="mord"><span class="mord mathrm">D</span><span class="mord mathrm">P</span><span class="mord mathrm">L</span><span class="mord mathrm">L</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathtt">C</span><span class="mord mathtt">N</span><span class="mord mathtt">F</span></span><span class="mspace"> </span><span class="mspace"> </span><span class="mord" style="color: green;">Φ</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">:</span><span class="mrel">=</span></span></span><span class="" style="top: -7.66em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord"></span><span class="mord"><span class="mord mathtt">2</span></span><span class="mspace" style="margin-right: 1em;"></span><span class="mspace" style="margin-right: 2em;"></span><span class="mord"><span class="mord mathtt" style="color: red;">d</span><span class="mord mathtt" style="color: red;">o</span></span><span class="mspace"> </span><span class="mspace"> </span><span class="mord text"><span class="mord">UP</span></span><span class="mopen">(</span><span class="mord" style="color: green;">Φ</span><span class="mclose">)</span><span class="mspace"> </span><span class="mspace"> </span><span class="mord"><span class="mord mathtt" style="color: red;">u</span><span class="mord mathtt" style="color: red;">n</span><span class="mord mathtt" style="color: red;">t</span><span class="mord mathtt" style="color: red;">i</span><span class="mord mathtt" style="color: red;">l</span></span><span class="mspace"> </span><span class="mspace"> </span><span class="mord text"><span class="mord">It changed nothing</span></span><span class="mord">.</span></span></span><span class="" style="top: -6.16em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord"></span><span class="mord"><span class="mord mathtt">3</span></span><span class="mspace" style="margin-right: 1em;"></span><span class="mspace" style="margin-right: 2em;"></span><span class="mord"><span class="mord mathtt" style="color: red;">d</span><span class="mord mathtt" style="color: red;">o</span></span><span class="mspace"> </span><span class="mspace"> </span><span class="mord text"><span class="mord">PLE</span></span><span class="mopen">(</span><span class="mord" style="color: green;">Φ</span><span class="mclose">)</span><span class="mspace"> </span><span class="mspace"> </span><span class="mord"><span class="mord mathtt" style="color: red;">u</span><span class="mord mathtt" style="color: red;">n</span><span class="mord mathtt" style="color: red;">t</span><span class="mord mathtt" style="color: red;">i</span><span class="mord mathtt" style="color: red;">l</span></span><span class="mspace"> </span><span class="mspace"> </span><span class="mord text"><span class="mord">It changed nothing</span></span><span class="mord">.</span></span></span><span class="" style="top: -4.66em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord"></span><span class="mord"><span class="mord mathtt">4</span></span><span class="mspace" style="margin-right: 1em;"></span><span class="mspace" style="margin-right: 2em;"></span><span class="mord"><span class="mord mathtt" style="color: red;">i</span><span class="mord mathtt" style="color: red;">f</span></span><span class="mspace"> </span><span class="mspace"> </span><span class="mord" style="color: green;">Φ</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mord amsrm">∅</span><span class="mspace"> </span><span class="mspace"> </span><span class="mord"><span class="mord mathtt" style="color: red;">t</span><span class="mord mathtt" style="color: red;">h</span><span class="mord mathtt" style="color: red;">e</span><span class="mord mathtt" style="color: red;">n</span></span></span></span><span class="" style="top: -3.16em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord"></span><span class="mord"><span class="mord mathtt">5</span></span><span class="mspace" style="margin-right: 1em;"></span><span class="mspace" style="margin-right: 2em;"></span><span class="mspace" style="margin-right: 2em;"></span><span class="mord"><span class="mord mathtt" style="color: red;">r</span><span class="mord mathtt" style="color: red;">e</span><span class="mord mathtt" style="color: red;">t</span><span class="mord mathtt" style="color: red;">u</span><span class="mord mathtt" style="color: red;">r</span><span class="mord mathtt" style="color: red;">n</span></span><span class="mspace"> </span><span class="mspace"> </span><span class="mord"><span class="mord mathrm" style="color: blue;">t</span><span class="mord mathrm" style="color: blue;">r</span><span class="mord mathrm" style="color: blue;">u</span><span class="mord mathrm" style="color: blue;">e</span></span><span class="mord">.</span></span></span><span class="" style="top: -1.66em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord"></span><span class="mord"><span class="mord mathtt">6</span></span><span class="mspace" style="margin-right: 1em;"></span><span class="mspace" style="margin-right: 2em;"></span><span class="mord"><span class="mord mathtt" style="color: red;">i</span><span class="mord mathtt" style="color: red;">f</span></span><span class="mspace"> </span><span class="mspace"> </span><span class="mord">∃</span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mord" style="color: green;">Φ</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mord amsrm">∅</span><span class="mspace"> </span><span class="mspace"> </span><span class="mord"><span class="mord mathtt" style="color: red;">t</span><span class="mord mathtt" style="color: red;">h</span><span class="mord mathtt" style="color: red;">e</span><span class="mord mathtt" style="color: red;">n</span></span></span></span><span class="" style="top: -0.16em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord"></span><span class="mord"><span class="mord mathtt">7</span></span><span class="mspace" style="margin-right: 1em;"></span><span class="mspace" style="margin-right: 2em;"></span><span class="mspace" style="margin-right: 2em;"></span><span class="mord"><span class="mord mathtt" style="color: red;">r</span><span class="mord mathtt" style="color: red;">e</span><span class="mord mathtt" style="color: red;">t</span><span class="mord mathtt" style="color: red;">u</span><span class="mord mathtt" style="color: red;">r</span><span class="mord mathtt" style="color: red;">n</span></span><span class="mspace"> </span><span class="mspace"> </span><span class="mord"><span class="mord mathrm" style="margin-right: 0.07778em; color: blue;">f</span><span class="mord mathrm" style="color: blue;">a</span><span class="mord mathrm" style="color: blue;">l</span><span class="mord mathrm" style="color: blue;">s</span><span class="mord mathrm" style="color: blue;">e</span></span><span class="mord">.</span></span></span><span class="" style="top: 1.34em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord"></span><span class="mord"><span class="mord mathtt">8</span></span><span class="mspace" style="margin-right: 1em;"></span><span class="mspace" style="margin-right: 2em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mord"><span class="mord mathrm">C</span><span class="mord mathrm">h</span><span class="mord mathrm">o</span><span class="mord mathrm">o</span><span class="mord mathrm">s</span><span class="mord mathrm">e</span><span class="mord mathrm" style="margin-right: 0.01389em;">V</span><span class="mord mathrm">a</span><span class="mord mathrm">r</span><span class="mord mathrm">i</span><span class="mord mathrm">a</span><span class="mord mathrm">b</span><span class="mord mathrm">l</span><span class="mord mathrm">e</span></span><span class="mopen">(</span><span class="mord" style="color: green;">Φ</span><span class="mclose">)</span></span></span><span class="" style="top: 2.84em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord"></span><span class="mord"><span class="mord mathtt">9</span></span><span class="mspace" style="margin-right: 1em;"></span><span class="mspace" style="margin-right: 2em;"></span><span class="mord"><span class="mord mathtt" style="color: red;">r</span><span class="mord mathtt" style="color: red;">e</span><span class="mord mathtt" style="color: red;">t</span><span class="mord mathtt" style="color: red;">u</span><span class="mord mathtt" style="color: red;">r</span><span class="mord mathtt" style="color: red;">n</span></span><span class="mspace"> </span><span class="mspace"> </span><span class="mord"><span class="mord mathrm">D</span><span class="mord mathrm">P</span><span class="mord mathrm">L</span><span class="mord mathrm">L</span></span><span class="mopen">(</span><span class="mord"><span class="mord" style="color: green;">Φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.280556em;"><span class="" style="top: -2.55em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mrel mtight">→</span><span class="mord mtight"><span class="mord mathrm mtight" style="color: blue;">t</span><span class="mord mathrm mtight" style="color: blue;">r</span><span class="mord mathrm mtight" style="color: blue;">u</span><span class="mord mathrm mtight" style="color: blue;">e</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace"> </span><span class="mspace"> </span><span class="mord"><span class="mord mathtt" style="color: red;">o</span><span class="mord mathtt" style="color: red;">r</span></span><span class="mspace"> </span><span class="mspace"> </span><span class="mord"><span class="mord mathrm">D</span><span class="mord mathrm">P</span><span class="mord mathrm">L</span><span class="mord mathrm">L</span></span><span class="mopen">(</span><span class="mord"><span class="mord" style="color: green;">Φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mrel mtight">→</span><span class="mord mtight"><span class="mord mathrm mtight" style="margin-right: 0.07778em; color: blue;">f</span><span class="mord mathrm mtight" style="color: blue;">a</span><span class="mord mathrm mtight" style="color: blue;">l</span><span class="mord mathrm mtight" style="color: blue;">s</span><span class="mord mathrm mtight" style="color: blue;">e</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 6.5em;"><span class=""></span></span></span></span></span></span></span></span></span></span></span></span><br/> 其中 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         U
        
        
         P
        
       
       
        (
       
       
        Φ
       
       
        )
       
      
      
       \mathrm{UP}(\Phi)
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathrm">U</span><span class="mord mathrm">P</span></span><span class="mopen">(</span><span class="mord">Φ</span><span class="mclose">)</span></span></span></span></span> 与 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         P
        
        
         L
        
        
         E
        
       
       
        (
       
       
        Φ
       
       
        )
       
      
      
       \mathrm{PLE}(\Phi)
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathrm">P</span><span class="mord mathrm">L</span><span class="mord mathrm">E</span></span><span class="mopen">(</span><span class="mord">Φ</span><span class="mclose">)</span></span></span></span></span> 分别是指对公式 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        Φ
       
      
      
       \Phi
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord">Φ</span></span></span></span></span> 进行<strong>单位子句传播</strong>和<strong>孤立文字消去</strong>，<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         C
        
        
         h
        
        
         o
        
        
         o
        
        
         s
        
        
         e
        
        
         V
        
        
         a
        
        
         r
        
        
         i
        
        
         a
        
        
         b
        
        
         l
        
        
         e
        
       
       
        (
       
       
        Φ
       
       
        )
       
      
      
       \mathrm{ChooseVariable}(\Phi)
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathrm">C</span><span class="mord mathrm">h</span><span class="mord mathrm">o</span><span class="mord mathrm">o</span><span class="mord mathrm">s</span><span class="mord mathrm">e</span><span class="mord mathrm" style="margin-right: 0.01389em;">V</span><span class="mord mathrm">a</span><span class="mord mathrm">r</span><span class="mord mathrm">i</span><span class="mord mathrm">a</span><span class="mord mathrm">b</span><span class="mord mathrm">l</span><span class="mord mathrm">e</span></span><span class="mopen">(</span><span class="mord">Φ</span><span class="mclose">)</span></span></span></span></span> 是指在公式 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        Φ
       
      
      
       \Phi
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord">Φ</span></span></span></span></span> 中选取一个变量（未赋值），根据现有的研究，这个选取变量的策略（被称为<strong>启发函数</strong>（heuristic function））会大大影响 DPLL 算法的运行效率，根据变量选择策略不同，DPLL 算法也有许多变种，但这不在我们现在的讨论范围内，作为初学者，我们就让<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         C
        
        
         h
        
        
         o
        
        
         o
        
        
         s
        
        
         e
        
        
         V
        
        
         a
        
        
         r
        
        
         i
        
        
         a
        
        
         b
        
        
         l
        
        
         e
        
       
       
        (
       
       
        Φ
       
       
        )
       
      
      
       \mathrm{ChooseVariable}(\Phi)
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathrm">C</span><span class="mord mathrm">h</span><span class="mord mathrm">o</span><span class="mord mathrm">o</span><span class="mord mathrm">s</span><span class="mord mathrm">e</span><span class="mord mathrm" style="margin-right: 0.01389em;">V</span><span class="mord mathrm">a</span><span class="mord mathrm">r</span><span class="mord mathrm">i</span><span class="mord mathrm">a</span><span class="mord mathrm">b</span><span class="mord mathrm">l</span><span class="mord mathrm">e</span></span><span class="mopen">(</span><span class="mord">Φ</span><span class="mclose">)</span></span></span></span></span> 直接选择变量序列中的第一个变量。</p>
<p>第 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        9
       
      
      
       9
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">9</span></span></span></span></span> 行中的 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         Φ
        
        
         
          x
         
         
          →
         
         
          
           t
          
          
           r
          
          
           u
          
          
           e
          
         
        
       
      
      
       \Phi_{x\to\mathrm{true}}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord">Φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.280556em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mrel mtight">→</span><span class="mord mtight"><span class="mord mathrm mtight">t</span><span class="mord mathrm mtight">r</span><span class="mord mathrm mtight">u</span><span class="mord mathrm mtight">e</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 是指将公式 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        Φ
       
      
      
       \Phi
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord">Φ</span></span></span></span></span> 中的变量 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        x
       
      
      
       x
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">x</span></span></span></span></span> 赋值为 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        T
       
       
        r
       
       
        u
       
       
        e
       
      
      
       \mathrm{True}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathrm">T</span><span class="mord mathrm">r</span><span class="mord mathrm">u</span><span class="mord mathrm">e</span></span></span></span></span></span>，并根据在化简规则中描述过的方式处理赋值变量（删除包含其肯定出现的子句，并删除其否定形式的文字）后的公式， <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         Φ
        
        
         
          x
         
         
          →
         
         
          
           f
          
          
           a
          
          
           l
          
          
           s
          
          
           e
          
         
        
       
      
      
       \Phi_{x\to\mathrm{false}}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord">Φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mrel mtight">→</span><span class="mord mtight"><span class="mord mathrm mtight" style="margin-right: 0.07778em;">f</span><span class="mord mathrm mtight">a</span><span class="mord mathrm mtight">l</span><span class="mord mathrm mtight">s</span><span class="mord mathrm mtight">e</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 也如此，只不过将两种操作反过来。</p>
<p>可以看出这是个递归程序，对于输入的非空的原始公式 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         Φ
        
        
         0
        
       
      
      
       \Phi_0
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord">Φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>，其在两种情况下中止：</p>
<ul><li>公式 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         Φ
        
       
       
        \Phi
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord">Φ</span></span></span></span></span> 为空，产生这种情况的原因只可能是：各个子句经过变量的赋值后值必为 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         T
        
        
         r
        
        
         u
        
        
         e
        
       
       
        \mathrm{True}
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathrm">T</span><span class="mord mathrm">r</span><span class="mord mathrm">u</span><span class="mord mathrm">e</span></span></span></span></span></span>，不对 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         Φ
        
       
       
        \Phi
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord">Φ</span></span></span></span></span> 中其他变量的赋值产生约束而全被删除。这意味着原始的 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         
          Φ
         
         
          0
         
        
       
       
        \Phi_0
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord">Φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 经过一部分（当然也可能是全部）变量的赋值后其所有子句的值都恒为 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         T
        
        
         r
        
        
         u
        
        
         e
        
       
       
        \mathrm{True}
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathrm">T</span><span class="mord mathrm">r</span><span class="mord mathrm">u</span><span class="mord mathrm">e</span></span></span></span></span></span>，<span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         
          Φ
         
         
          0
         
        
       
       
        \Phi_0
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord">Φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 是可满足的。</li><li>公式 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         Φ
        
       
       
        \Phi
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord">Φ</span></span></span></span></span> 包含空子句，产生这种情况的原因只可能是：这个子句中所有文字均在经过赋值后值为 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         F
        
        
         a
        
        
         l
        
        
         s
        
        
         e
        
       
       
        \mathrm{False}
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathrm">F</span><span class="mord mathrm">a</span><span class="mord mathrm">l</span><span class="mord mathrm">s</span><span class="mord mathrm">e</span></span></span></span></span></span>，因此这些文字均被删除了，那么这个子句便不可能值为 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         T
        
        
         r
        
        
         u
        
        
         e
        
       
       
        \mathrm{True}
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathrm">T</span><span class="mord mathrm">r</span><span class="mord mathrm">u</span><span class="mord mathrm">e</span></span></span></span></span></span>，公式 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         Φ
        
       
       
        \Phi
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord">Φ</span></span></span></span></span> 是不可满足的。（这并不代表 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         
          Φ
         
         
          0
         
        
       
       
        \Phi_0
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord">Φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 无法满足，因为这只是一种可能的赋值排列）</li></ul>
<h3><a id="_139"></a>具体实现</h3>
<p>接下来，我们就开始着手从零实现一个基础款（不带复杂的 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         C
        
        
         h
        
        
         o
        
        
         o
        
        
         s
        
        
         e
        
        
         V
        
        
         a
        
        
         r
        
        
         i
        
        
         a
        
        
         b
        
        
         l
        
        
         e
        
       
       
        (
       
       
        Φ
       
       
        )
       
      
      
       \mathrm{ChooseVariable}(\Phi)
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathrm">C</span><span class="mord mathrm">h</span><span class="mord mathrm">o</span><span class="mord mathrm">o</span><span class="mord mathrm">s</span><span class="mord mathrm">e</span><span class="mord mathrm" style="margin-right: 0.01389em;">V</span><span class="mord mathrm">a</span><span class="mord mathrm">r</span><span class="mord mathrm">i</span><span class="mord mathrm">a</span><span class="mord mathrm">b</span><span class="mord mathrm">l</span><span class="mord mathrm">e</span></span><span class="mopen">(</span><span class="mord">Φ</span><span class="mclose">)</span></span></span></span></span> 启发函数）的 DPLL 算法。</p>
<p>注意到，算法中涉及到大量的文字删除和子句删除操作，而且可能出现在文字列表和子句列表中间的任意位置（即不是简单地删除头或尾），而且处理各个子句、文字时遍历较多，而无需随机访问。我使用了<strong>链表</strong>（Linked list）来存储我们处理的公式。具体地说，我们使用一个二维链表来存储合取范式，它可以看作是子句的列表，而每个子句又可看作文字的列表。</p>
<p>每个文字有两个属性：变量编号（整数）和是否为否定文字（布尔值）。输入时我们将所有变量标识符离散化为变量编号。<br/> <img alt="用二维链表来存储合取范式" src="https://img-blog.csdnimg.cn/8cc5b1e4534d43c093ff6fee833dd5e6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ2hlc2l1bQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center"/></p>
<center>
<font face="楷体">图1：用二维链表来存储合取范式</font>
</center>
<p>要删除一个文字时，我们只需将前一个文字的 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        .
       
       
        n
       
       
        x
       
       
        t
       
      
      
       \mathrm{.nxt}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.61508em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathrm">.</span><span class="mord mathrm">n</span><span class="mord mathrm">x</span><span class="mord mathrm">t</span></span></span></span></span></span> 指针指向下一个文字，并将下一个文字的 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        .
       
       
        p
       
       
        r
       
       
        v
       
      
      
       \mathrm{.prv}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord"><span class="mord mathrm">.</span><span class="mord mathrm">p</span><span class="mord mathrm">r</span><span class="mord mathrm" style="margin-right: 0.01389em;">v</span></span></span></span></span></span> 指针指向前一个文字即可，删除子句同理。</p>
<p>但是，我们发现算法过程中涉及到 <font face="楷体">找到特定逻辑变量的所有文字</font> 的操作，如将某个变量赋值时就必须依次处理其所有文字，若只采取上述链表的结构，每次处理时就必须遍历所有子句、文字。我们可以通过再维护一个按变量名索引的二维链表，从而实现高效地遍历任意变量的所有文字。这看上去像是给上面的链表结构增加了许多“跳线”。对于合取范式：<br/> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         a
        
        
         ∨
        
        
         ¬
        
        
         c
        
        
         ∨
        
        
         d
        
        
         )
        
        
         ∧
        
        
         (
        
        
         d
        
        
         ∨
        
        
         ¬
        
        
         b
        
        
         ∨
        
        
         c
        
        
         ∨
        
        
         ¬
        
        
         t
        
        
         )
        
        
         ∧
        
        
         (
        
        
         ¬
        
        
         a
        
        
         ∨
        
        
         b
        
        
         ∨
        
        
         c
        
        
         )
        
       
       
         (a\vee\neg c\vee d)\wedge(d\vee\neg b\vee c\vee\neg t)\wedge(\neg a\vee b\vee c) 
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.55556em; vertical-align: 0em;"></span><span class="mord">¬</span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">d</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord">¬</span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.55556em; vertical-align: 0em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">¬</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">¬</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">c</span><span class="mclose">)</span></span></span></span></span></span><br/> 我们就可以建立如下图的结构来存储：</p>
<p><img alt="在二维链表的基础上添加“跳线”以实现更高效的遍历" src="https://img-blog.csdnimg.cn/c9c1945ee7db4e53a7c2aa0e74b32bab.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ2hlc2l1bQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center"/></p>
<center>
<font face="楷体">图2：在二维链表的基础上添加“跳线”以实现更高效的遍历</font>
</center>
<p>当然，其中仅仅画出了部分关键的指针结构，具体实现中天蓝色的“跳线”也是双向的，我们也可以通过增加一些额外的指针存储实现 <font face="楷体">通过文字找到其所在子句、通过文字找到其对应的文字列表</font>。</p>
<p>除了图中的结构，通过在文字、子句的删除中维护一个“没有经过单位子句传播的单位子句”集合（或列表），以及一个 <font face="楷体">只有一个对应文字的变量</font> 集合，我们可以不通过遍历找到所有单位子句和孤立变量以上述两个化简步骤。</p>
<p>但是，难题还在后头：这是个递归算法，涉及到对前几次历史版本的回溯。具体地说，在某种赋值（部分）组合下公式不可能满足，这时我们需要还原刚刚进行的化简操作和赋值操作，检查不同的赋值下公式能否满足，即进入另一个搜索分支。</p>
<p>如何进行回溯呢？最简单的就如伪代码中的，递归时直接通过调用函数中参数的复制传递复制一份整个公式结构的历史版本，这听上去虽然效率不高但实现简单，但事实上对于包含如此多指针的数据结构，要复制出完整、独立的一份必然涉及到大量指针的重定向，而这是十分困难且涉及到许多细节的，何况即使实现了，面对较大的递归层数，程序会占用很多内存，而且包含大量重复的冗余部分。</p>
<p>这里，我采用了一种基于 <font face="楷体">栈</font> 和 <font face="楷体">增量存储</font> 思想的数据结构。DPLL 算法可以看作一个在二叉树上进行 DFS 搜索的算法，程序在执行这种递归算法时会在函数（递归时就是自身）的调用中维护一个堆栈，存储每次函数调用中的局部变量。我仿照了这种结构，用栈来存储公式结构在一层层搜索的赋值中改变的部分。</p>
<p>具体地说，上面 <font face="楷体">图2</font> 中的每一个箭头都是一个“指针栈”，存储着一系列的指针，标识该指针在递归过程中的一系列变化。在每一个搜索到的公式状态节点进行化简、赋值时，我们只访问、修改栈顶的指针，并用一个集合来标识在本次处理（化简、赋值）中修改过的指针栈，这些集合又用一个栈来维护。回溯至上一层时遍历栈顶的集合，将其中所有指针栈的栈顶释出，从而实现对历史公式版本的还原。上述数据结构可以看作一个简单的 <font face="楷体">部分可持久化链表组</font> ，当然这其中也有许多可供优化的地方。</p>
<h3><a id="_173"></a>实现代码</h3>
<p>下面给出部分核心代码，完整代码可见：</p>
<ul><li> <p>Chesium/DPLL (github.com)</p> <p><a href="https://github.com/Chesium/DPLL">https://github.com/Chesium/DPLL</a></p> <p>代码使用说明见文末。</p> </li></ul>
<h4><a id="_183"></a>“指针栈链表”实现部分：</h4>
<pre><code class="prism language-c++">template &lt;typename T&gt;
struct node {
  stack&lt;node&lt;T&gt; *&gt; prvPS, nxtPS;
  slist&lt;T&gt; *L;
  T *X = nullptr;

  node(slist&lt;T&gt; *l, T *x = nullptr, node&lt;T&gt; *_prv = nullptr,
       node&lt;T&gt; *_nxt = nullptr) {
    this-&gt;L = l;
    if (x != nullptr) this-&gt;X = new T(*x);
    this-&gt;init_upd(_prv, _nxt);
  }

  void __upd(node&lt;T&gt; *_prv, node&lt;T&gt; *_nxt) {
    if (_prv != nullptr) this-&gt;prvPS.push(_prv);
    if (_nxt != nullptr) this-&gt;nxtPS.push(_nxt);
  }

  void init_upd(node&lt;T&gt; *_prv, node&lt;T&gt; *_nxt) {
    if (_prv != nullptr)
      while (!this-&gt;prvPS.empty()) this-&gt;prvPS.pop();
    if (_nxt != nullptr)
      while (!this-&gt;nxtPS.empty()) this-&gt;nxtPS.pop();
    this-&gt;__upd(_prv, _nxt);
  }

  void upd(node&lt;T&gt; *_prv, node&lt;T&gt; *_nxt) {
    if (_prv != nullptr) {
      auto it = this-&gt;L-&gt;Recorder-&gt;ch.top().find(&amp;(this-&gt;prvPS));
      if (it == this-&gt;L-&gt;Recorder-&gt;ch.top().end())
        this-&gt;L-&gt;Recorder-&gt;ch.top().insert(&amp;(this-&gt;prvPS));
      else
        this-&gt;prvPS.pop();
      this-&gt;prvPS.push(_prv);
    }
    if (_nxt != nullptr) {
      auto it = this-&gt;L-&gt;Recorder-&gt;ch.top().find(&amp;(this-&gt;nxtPS));
      if (it == this-&gt;L-&gt;Recorder-&gt;ch.top().end())
        this-&gt;L-&gt;Recorder-&gt;ch.top().insert(&amp;(this-&gt;nxtPS));
      else
        this-&gt;nxtPS.pop();
      this-&gt;nxtPS.push(_nxt);
    }
  }

  bool isHead() { return this-&gt;L-&gt;begin() == this; }
  bool isTail() { return this-&gt;L-&gt;end() == this; }
  node&lt;T&gt; *prev() { return this-&gt;prvPS.top(); }
  node&lt;T&gt; *next() { return this-&gt;nxtPS.top(); }
};

template &lt;typename T&gt;
struct slist {
  stack&lt;node&lt;T&gt; *&gt; beginPS, endPS;
  rmRecorder&lt;T&gt; *Recorder = nullptr;

  slist() {
    auto primNode = new node&lt;T&gt;(this);
    this-&gt;beginPS.push(primNode);
    this-&gt;endPS.push(primNode);
  }

  node&lt;T&gt; *begin() { return this-&gt;beginPS.top(); }
  node&lt;T&gt; *end() { return this-&gt;endPS.top(); }

  void regRec(rmRecorder&lt;T&gt; *rec) { this-&gt;Recorder = rec; }

  bool empty() { return this-&gt;begin() == this-&gt;end(); }

  bool single() {
    if (this-&gt;empty()) return false;
    return this-&gt;begin()-&gt;next() == this-&gt;end();
  }

  void add(T x) {
    if (this-&gt;empty()) {
      while (!this-&gt;beginPS.empty()) this-&gt;beginPS.pop();
      this-&gt;beginPS.push(new node&lt;T&gt;(this, &amp;x, nullptr, this-&gt;end()));
      this-&gt;end()-&gt;init_upd(this-&gt;begin(), nullptr);
    } else {
      auto NewNode = new node&lt;T&gt;(this, &amp;x, this-&gt;end()-&gt;prev(), this-&gt;end());
      this-&gt;end()-&gt;prev()-&gt;init_upd(nullptr, NewNode);
      this-&gt;end()-&gt;init_upd(NewNode, nullptr);
    }
  }

  void rm(node&lt;T&gt; *nd) {
    if (nd-&gt;L != this) return;
    if (nd == this-&gt;end()) return;
    if (nd == this-&gt;begin()) {
      auto it = this-&gt;Recorder-&gt;ch.top().find(&amp;this-&gt;beginPS);
      if (it == this-&gt;Recorder-&gt;ch.top().end())
        this-&gt;Recorder-&gt;ch.top().insert(&amp;this-&gt;beginPS);
      else
        this-&gt;beginPS.pop();
      this-&gt;beginPS.push(nd-&gt;next());
    } else {
      nd-&gt;prev()-&gt;upd(nullptr, nd-&gt;next());
      nd-&gt;next()-&gt;upd(nd-&gt;prev(), nullptr);
    }
  }

  T *front() { return this-&gt;begin()-&gt;X; }

  T *back() { return this-&gt;end()-&gt;prev()-&gt;X; }
};

template &lt;typename T&gt;
struct rmRecorder {
  stack&lt;set&lt;stack&lt;node&lt;T&gt; *&gt; *&gt;&gt; ch;
  int layer = 0;

  rmRecorder() { this-&gt;nextLayer(); }

  void nextLayer() {
    this-&gt;ch.push(set&lt;stack&lt;node&lt;T&gt; *&gt; *&gt;());
    this-&gt;layer++;
  }

  void backtrack() {
    for (auto it = this-&gt;ch.top().begin(); it != this-&gt;ch.top().end(); it++)
      (*it)-&gt;pop();
    this-&gt;layer--;
    ch.pop();
  }
};
</code></pre>
<h4><a id="_314"></a>数据结构部分：</h4>
<pre><code class="prism language-c++">struct Literal {
  llu index;  //
  bool neg;
  CNF *cnf;
  node&lt;Clause&gt; *cl;
  node&lt;Occur&gt; *oc;
  Literal(CNF *_cnf, string s, bool _neg);
  string str();
  void RemoveOccurrence();
};

struct Clause {
  slist&lt;Literal&gt; *lt;
  CNF *cnf;
  Clause(CNF *_cnf);
  string str();
};

struct Occur {
  node&lt;Literal&gt; *lit;
  Occur(node&lt;Literal&gt; *_lit) { this-&gt;lit = _lit; }
};

struct AvAtom {
  llu index;
  slist&lt;Occur&gt; *oc;
  CNF *cnf;
  AvAtom(CNF *_cnf, llu i);
};

struct CNF {
  map&lt;string, llu&gt; Dict;
  vector&lt;string&gt; Atoms;
  vector&lt;ll&gt; scheme;
  llu AtomN = 0;
  slist&lt;Clause&gt; CL;
  slist&lt;AvAtom&gt; AVA;
  vector&lt;node&lt;AvAtom&gt; *&gt; avAtoms;
  rmRecorder&lt;Literal&gt; Rec_Literal;
  rmRecorder&lt;Clause&gt; Rec_Clause;
  rmRecorder&lt;Occur&gt; Rec_Occur;
  rmRecorder&lt;AvAtom&gt; Rec_AvAtom;
  stack&lt;list&lt;ll&gt;&gt; Rec_assign;
  CNF() {
    this-&gt;CL.regRec(&amp;this-&gt;Rec_Clause);
    this-&gt;AVA.regRec(&amp;this-&gt;Rec_AvAtom);
  }
  void read();
  string str();
  string occurStr();
  string schemeStr();
  void removeLiteral(node&lt;Clause&gt; *cl, node&lt;Literal&gt; *lit);
  void removeClause(node&lt;Clause&gt; *cl);
  ll AssignLiteralIn(node&lt;Clause&gt; *cl, node&lt;Literal&gt; *unit);
  bool PureLiteralAssign();
  bool UnitPropagate();
  void nextLayer();
  void backtrack();
  bool containEmptyClause = false;
  bool DPLL(bool disableSimp);
};

void CNF::removeLiteral(node&lt;Clause&gt; *cl, node&lt;Literal&gt; *lit) {
  cout &lt;&lt; "DEL literal \"" &lt;&lt; lit-&gt;X-&gt;str() &lt;&lt; "\" in \"" &lt;&lt; cl-&gt;X-&gt;str()
       &lt;&lt; "\"" &lt;&lt; endl;
  lit-&gt;X-&gt;RemoveOccurrence();
  cl-&gt;X-&gt;lt-&gt;rm(lit);
}

void CNF::removeClause(node&lt;Clause&gt; *cl) {
  cout &lt;&lt; "DEL Clause \"" &lt;&lt; cl-&gt;X-&gt;str() &lt;&lt; "\"" &lt;&lt; endl;
  for (auto lit = cl-&gt;X-&gt;lt-&gt;begin(); lit != cl-&gt;X-&gt;lt-&gt;end();
       lit = lit-&gt;next())
    lit-&gt;X-&gt;RemoveOccurrence();
  this-&gt;CL.rm(cl);
}

void CNF::nextLayer() {
  this-&gt;Rec_Literal.nextLayer();
  this-&gt;Rec_Clause.nextLayer();
  this-&gt;Rec_Occur.nextLayer();
  this-&gt;Rec_AvAtom.nextLayer();
  this-&gt;Rec_assign.push(list&lt;ll&gt;());
}

void CNF::backtrack() {
  this-&gt;Rec_Literal.backtrack();
  this-&gt;Rec_Clause.backtrack();
  this-&gt;Rec_Occur.backtrack();
  this-&gt;Rec_AvAtom.backtrack();
  for (auto it = this-&gt;Rec_assign.top().begin();
       it != this-&gt;Rec_assign.top().end(); it++)
    this-&gt;scheme[*it] = 0;
  this-&gt;Rec_assign.pop();
}
</code></pre>
<h4><a id="_414"></a>算法主体部分：</h4>
<pre><code class="prism language-cpp">ll CNF<span class="token operator">::</span><span class="token function">AssignLiteralIn</span><span class="token punctuation">(</span>node<span class="token operator">&lt;</span>Clause<span class="token operator">&gt;</span> <span class="token operator">*</span>cl<span class="token punctuation">,</span> node<span class="token operator">&lt;</span>Literal<span class="token operator">&gt;</span> <span class="token operator">*</span>unit<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">&gt;</span>scheme<span class="token punctuation">[</span>unit<span class="token operator">-</span><span class="token operator">&gt;</span>X<span class="token operator">-</span><span class="token operator">&gt;</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> unit<span class="token operator">-</span><span class="token operator">&gt;</span>X<span class="token operator">-</span><span class="token operator">&gt;</span>neg <span class="token operator">?</span> <span class="token number">2</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">&gt;</span>Rec_assign<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>unit<span class="token operator">-</span><span class="token operator">&gt;</span>X<span class="token operator">-</span><span class="token operator">&gt;</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">bool</span> changed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">=</span> cl<span class="token operator">-</span><span class="token operator">&gt;</span>X<span class="token operator">-</span><span class="token operator">&gt;</span>lt<span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> cl<span class="token operator">-</span><span class="token operator">&gt;</span>X<span class="token operator">-</span><span class="token operator">&gt;</span>lt<span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">=</span> it<span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>it<span class="token operator">-</span><span class="token operator">&gt;</span>X<span class="token operator">-</span><span class="token operator">&gt;</span>index <span class="token operator">==</span> unit<span class="token operator">-</span><span class="token operator">&gt;</span>X<span class="token operator">-</span><span class="token operator">&gt;</span>index<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>it<span class="token operator">-</span><span class="token operator">&gt;</span>X<span class="token operator">-</span><span class="token operator">&gt;</span>neg <span class="token operator">==</span> unit<span class="token operator">-</span><span class="token operator">&gt;</span>X<span class="token operator">-</span><span class="token operator">&gt;</span>neg<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">removeClause</span><span class="token punctuation">(</span>cl<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">removeLiteral</span><span class="token punctuation">(</span>cl<span class="token punctuation">,</span> it<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>cl<span class="token operator">-</span><span class="token operator">&gt;</span>X<span class="token operator">-</span><span class="token operator">&gt;</span>lt<span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
          <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">&gt;</span>containEmptyClause <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
          <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        changed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token keyword">return</span> changed <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">bool</span> CNF<span class="token operator">::</span><span class="token function">UnitPropagate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">bool</span> ok <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> it1 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">&gt;</span>CL<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it1 <span class="token operator">!=</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">&gt;</span>CL<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it1 <span class="token operator">=</span> it1<span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>it1<span class="token operator">-</span><span class="token operator">&gt;</span>X<span class="token operator">-</span><span class="token operator">&gt;</span>lt<span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">single</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      node<span class="token operator">&lt;</span>Literal<span class="token operator">&gt;</span> <span class="token operator">*</span>A <span class="token operator">=</span> it1<span class="token operator">-</span><span class="token operator">&gt;</span>X<span class="token operator">-</span><span class="token operator">&gt;</span>lt<span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> it2 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">&gt;</span>CL<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it2 <span class="token operator">!=</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">&gt;</span>CL<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
           it2 <span class="token operator">=</span> it2<span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>it1 <span class="token operator">==</span> it2<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>
        ll res <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">AssignLiteralIn</span><span class="token punctuation">(</span>it2<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>res <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">)</span> ok <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>ok<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">bool</span> CNF<span class="token operator">::</span><span class="token function">PureLiteralAssign</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span>llu i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">&gt;</span>AtomN<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">&gt;</span>avAtoms<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token operator">&gt;</span>X<span class="token operator">-</span><span class="token operator">&gt;</span>oc<span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">single</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">&gt;</span>scheme<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">&gt;</span>avAtoms<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token operator">&gt;</span>X<span class="token operator">-</span><span class="token operator">&gt;</span>index<span class="token punctuation">]</span> <span class="token operator">=</span>
          <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">&gt;</span>avAtoms<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token operator">&gt;</span>X<span class="token operator">-</span><span class="token operator">&gt;</span>oc<span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">&gt;</span>X<span class="token operator">-</span><span class="token operator">&gt;</span>lit<span class="token operator">-</span><span class="token operator">&gt;</span>X<span class="token operator">-</span><span class="token operator">&gt;</span>neg <span class="token operator">?</span> <span class="token number">2</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>
      <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">&gt;</span>Rec_assign<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">&gt;</span>avAtoms<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token operator">&gt;</span>X<span class="token operator">-</span><span class="token operator">&gt;</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">removeClause</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">&gt;</span>avAtoms<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token operator">&gt;</span>X<span class="token operator">-</span><span class="token operator">&gt;</span>oc<span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">&gt;</span>X<span class="token operator">-</span><span class="token operator">&gt;</span>lit<span class="token operator">-</span><span class="token operator">&gt;</span>X<span class="token operator">-</span><span class="token operator">&gt;</span>cl<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">bool</span> CNF<span class="token operator">::</span><span class="token function">DPLL</span><span class="token punctuation">(</span><span class="token keyword">bool</span> disableSimp <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  stack<span class="token operator">&lt;</span>ll<span class="token operator">&gt;</span> STACK<span class="token punctuation">;</span>
  AvAtom <span class="token operator">*</span>x<span class="token punctuation">;</span>
  ll layerNow <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> Status<span class="token punctuation">;</span>
  STACK<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>STACK<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    Status <span class="token operator">=</span> STACK<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    STACK<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/***/</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"=== NEW STATUS : "</span> <span class="token operator">&lt;&lt;</span> Status <span class="token operator">&lt;&lt;</span> <span class="token string">" ==="</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>layerNow <span class="token operator">&gt;=</span> <span class="token function">abs</span><span class="token punctuation">(</span>Status<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      layerNow<span class="token operator">--</span><span class="token punctuation">;</span>
      <span class="token comment">/***/</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"BACKTRACK: -&gt; "</span> <span class="token operator">&lt;&lt;</span> layerNow <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
      <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">backtrack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    layerNow <span class="token operator">=</span> <span class="token function">abs</span><span class="token punctuation">(</span>Status<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/***/</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"FORMULA: begin processing(layer="</span> <span class="token operator">&lt;&lt;</span> layerNow
               <span class="token operator">&lt;&lt;</span> <span class="token string">"):"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token comment">/***/</span> cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">nextLayer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>Status <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token comment">/***/</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"INIT: skip assignments"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
      <span class="token keyword">goto</span> SIMPLIFICATION<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    x <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">&gt;</span>AVA<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">&gt;</span>X<span class="token punctuation">;</span>
    <span class="token comment">/***/</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ASSIGN: \""</span> <span class="token operator">&lt;&lt;</span> Atoms<span class="token punctuation">[</span>x<span class="token operator">-</span><span class="token operator">&gt;</span>index<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\" -&gt; "</span>
               <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>Status <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token string">"True"</span> <span class="token operator">:</span> <span class="token string">"False"</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">&gt;</span>scheme<span class="token punctuation">[</span>x<span class="token operator">-</span><span class="token operator">&gt;</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> Status <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">&gt;</span>Rec_assign<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>x<span class="token operator">-</span><span class="token operator">&gt;</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">=</span> x<span class="token operator">-</span><span class="token operator">&gt;</span>oc<span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> x<span class="token operator">-</span><span class="token operator">&gt;</span>oc<span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">=</span> it<span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>Status <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">==</span> it<span class="token operator">-</span><span class="token operator">&gt;</span>X<span class="token operator">-</span><span class="token operator">&gt;</span>lit<span class="token operator">-</span><span class="token operator">&gt;</span>X<span class="token operator">-</span><span class="token operator">&gt;</span>neg<span class="token punctuation">)</span>
        <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">removeClause</span><span class="token punctuation">(</span>it<span class="token operator">-</span><span class="token operator">&gt;</span>X<span class="token operator">-</span><span class="token operator">&gt;</span>lit<span class="token operator">-</span><span class="token operator">&gt;</span>X<span class="token operator">-</span><span class="token operator">&gt;</span>cl<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">removeLiteral</span><span class="token punctuation">(</span>it<span class="token operator">-</span><span class="token operator">&gt;</span>X<span class="token operator">-</span><span class="token operator">&gt;</span>lit<span class="token operator">-</span><span class="token operator">&gt;</span>X<span class="token operator">-</span><span class="token operator">&gt;</span>cl<span class="token punctuation">,</span> it<span class="token operator">-</span><span class="token operator">&gt;</span>X<span class="token operator">-</span><span class="token operator">&gt;</span>lit<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>it<span class="token operator">-</span><span class="token operator">&gt;</span>X<span class="token operator">-</span><span class="token operator">&gt;</span>lit<span class="token operator">-</span><span class="token operator">&gt;</span>X<span class="token operator">-</span><span class="token operator">&gt;</span>cl<span class="token operator">-</span><span class="token operator">&gt;</span>X<span class="token operator">-</span><span class="token operator">&gt;</span>lt<span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
          <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">&gt;</span>containEmptyClause <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
          <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/***/</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"FORMULA: finish assignments:"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token comment">/***/</span> cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  SIMPLIFICATION<span class="token operator">:</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>disableSimp<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">UnitPropagate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token punctuation">}</span>
      <span class="token comment">/***/</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"FORMULA: Unit-propagatated:"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
      <span class="token comment">/***/</span> cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">PureLiteralAssign</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token punctuation">}</span>
      <span class="token comment">/***/</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"FORMULA: Pure-literal-assigned:"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
      <span class="token comment">/***/</span> cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">&gt;</span>CL<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token comment">/***/</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"***FORMULA IS EMPTY: It can be satisfied."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
      <span class="token comment">/***/</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"***ALGORITHM FINISHED."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">&gt;</span>containEmptyClause<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token comment">/***/</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"***FORMULA CONTAIN EMPTY CLAUSES: backtrack."</span> <span class="token operator">&lt;&lt;</span> endl
                 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
      <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">&gt;</span>containEmptyClause <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
      <span class="token keyword">continue</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    STACK<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token function">abs</span><span class="token punctuation">(</span>Status<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    STACK<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token function">abs</span><span class="token punctuation">(</span>Status<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/***/</span> cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">/***/</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"***The formula cannot be satisfied."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
  <span class="token comment">/***/</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"***ALGORITHM FINISHED."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h3><a id="_540"></a>代码使用示例</h3>
<p>最低 C++ 标准：C++ 11</p>
<p>输入格式：一行一个正整数 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        n
       
      
      
       n
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span></span></span></span></span>，表示合取范式包含 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        n
       
      
      
       n
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span></span></span></span></span> 个子句。接下来 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        n
       
      
      
       n
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span></span></span></span></span> 行，第 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        i
       
      
      
       i
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.65952em; vertical-align: 0em;"></span><span class="mord mathdefault">i</span></span></span></span></span> 行开头为一个正整数 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         k
        
        
         i
        
       
      
      
       k_i
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.84444em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: -0.03148em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 表示该子句包含 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         k
        
        
         i
        
       
      
      
       k_i
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.84444em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: -0.03148em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 个文字，随即有 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         k
        
        
         i
        
       
      
      
       k_i
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.84444em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: -0.03148em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 个以空格分隔的字符串，表示各个文字，若该字符串以<code>^</code>开头，则表示该文字为否定文字。</p>
<p>例如，下列合取范式：<br/> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml">
     
      
       
        
         
          
           
          
         
         
          
           
            
            
             (
            
            
             a
            
            
             ∨
            
            
             b
            
            
             )
            
           
          
         
        
        
         
          
           
            
             ∧
            
            
              
            
           
          
         
         
          
           
            
            
             (
            
            
             ¬
            
            
             a
            
            
             ∨
            
            
             ¬
            
            
             c
            
            
             )
            
           
          
         
        
        
         
          
           
            
             ∧
            
            
              
            
           
          
         
         
          
           
            
            
             (
            
            
             b
            
            
             ∨
            
            
             ¬
            
            
             t
            
            
             ∨
            
            
             a
            
            
             ∨
            
            
             ¬
            
            
             c
            
            
             )
            
           
          
         
        
        
         
          
           
            
             ∧
            
            
              
            
           
          
         
         
          
           
            
            
             (
            
            
             c
            
            
             ∨
            
            
             d
            
            
             )
            
           
          
         
        
        
         
          
           
            
             ∧
            
            
              
            
           
          
         
         
          
           
            
            
             a
            
           
          
         
        
       
       
         \begin{aligned} &amp;(a\vee b)\\ \wedge\ &amp;(\neg a\vee\neg c)\\ \wedge\ &amp;(b\vee\neg t\vee a\vee\neg c)\\ \wedge\ &amp;(c\vee d)\\ \wedge\ &amp;a \end{aligned} 
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 7.5em; vertical-align: -3.5em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 4em;"><span class="" style="top: -6.16em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"></span></span><span class="" style="top: -4.66em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">∧</span><span class="mspace"> </span></span></span><span class="" style="top: -3.16em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">∧</span><span class="mspace"> </span></span></span><span class="" style="top: -1.66em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">∧</span><span class="mspace"> </span></span></span><span class="" style="top: -0.16em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">∧</span><span class="mspace"> </span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 3.5em;"><span class=""></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 4em;"><span class="" style="top: -6.16em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span><span class="" style="top: -4.66em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord"></span><span class="mopen">(</span><span class="mord">¬</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mord">¬</span><span class="mord mathdefault">c</span><span class="mclose">)</span></span></span><span class="" style="top: -3.16em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord"></span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mord">¬</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mord">¬</span><span class="mord mathdefault">c</span><span class="mclose">)</span></span></span><span class="" style="top: -1.66em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord"></span><span class="mopen">(</span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mord mathdefault">d</span><span class="mclose">)</span></span></span><span class="" style="top: -0.16em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord"></span><span class="mord mathdefault">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 3.5em;"><span class=""></span></span></span></span></span></span></span></span></span></span></span></span><br/> 的输入代码就为：</p>
<pre><code>5
2 a b
2 ^a ^c
4 b ^t a ^c
2 c d
1 a
</code></pre>
<p>包含头文件<code>dpll.hpp</code>，保证其和<code>slist.hpp</code>在同一文件夹下，即可创建<code>CNF</code>对象，调用其<code>.read()</code>方法以从标准输入输出中读入合取范式。接着便可通过调用方法<code>.DPLL()</code>应用算法（加上参数<code>true</code>可以使算法跳过化简步骤），许多调试信息都会一并输出出来。如果要获取一种可行的赋值方案（前提是公式可满足），可以在应用 DPLL 算法后输出 <code>.schemeStr()</code> 方法生成的字符串，其样式如下：</p>
<pre><code>"a" -&gt; True
"b" -&gt; _
"c" -&gt; False
"t" -&gt; _
"d" -&gt; True
</code></pre>
<p>每行表示一个变量的赋值，若赋值为下划线<code>_</code>则说明其赋值为<code>true</code>或<code>false</code>均可。</p>
<p>我们对上述合取范式示例应用算法，输出应为：</p>
<pre><code>=== NEW STATUS : 0 ===
FORMULA: begin processing(layer=0):
{
| 　 ( a ∨ b )
| ∧ ( ¬a ∨ ¬c )
| ∧ ( b ∨ ¬t ∨ a ∨ ¬c )
| ∧ ( c ∨ d )
| ∧ a
}
INIT: skip assignments
DEL Clause "a ∨ b"
DEL literal "¬a" in "¬a ∨ ¬c"
DEL Clause "b ∨ ¬t ∨ a ∨ ¬c"
DEL literal "c" in "c ∨ d"
FORMULA: Unit-propagatated:
{
| 　 ¬c
| ∧ d
| ∧ a
}
DEL Clause "a"
DEL Clause "¬c"
DEL Clause "d"
FORMULA: Pure-literal-assigned:
{
}
***FORMULA IS EMPTY: It can be satisfied.
***ALGORITHM FINISHED.
1
"a" -&gt; True
"b" -&gt; _
"c" -&gt; False
"t" -&gt; _
"d" -&gt; True
</code></pre>
<p>从中可以清晰地看到算法执行的流程和经过各个化简步骤后公式的内容。这条公式经过一次化简后就足以判断其是否可满足了，我们通过<code>.DPLL(true)</code>禁用化简步骤可以清晰地看到算法回溯的过程：</p>
<pre><code>=== NEW STATUS : 0 ===
FORMULA: begin processing(layer=0):
{
| 　 ( a ∨ b )
| ∧ ( ¬a ∨ ¬c )
| ∧ ( b ∨ ¬t ∨ a ∨ ¬c )
| ∧ ( c ∨ d )
| ∧ a
}
INIT: skip assignments

=== NEW STATUS : -1 ===
FORMULA: begin processing(layer=1):
{
| 　 ( a ∨ b )
| ∧ ( ¬a ∨ ¬c )
| ∧ ( b ∨ ¬t ∨ a ∨ ¬c )
| ∧ ( c ∨ d )
| ∧ a
}
ASSIGN: "a" -&gt; False
DEL literal "a" in "a ∨ b"
DEL Clause "¬a ∨ ¬c"
DEL literal "a" in "b ∨ ¬t ∨ a ∨ ¬c"
DEL literal "a" in "a"
FORMULA: finish assignments:
{
| 　 b
| ∧ ( b ∨ ¬t ∨ ¬c )
| ∧ ( c ∨ d )
| ∧ (  )
}
***FORMULA CONTAIN EMPTY CLAUSES: backtrack.

=== NEW STATUS : 1 ===
BACKTRACK: -&gt; 0
FORMULA: begin processing(layer=1):
{
| 　 ( a ∨ b )
| ∧ ( ¬a ∨ ¬c )
| ∧ ( b ∨ ¬t ∨ a ∨ ¬c )
| ∧ ( c ∨ d )
| ∧ a
}
ASSIGN: "a" -&gt; True
DEL Clause "a ∨ b"
DEL literal "¬a" in "¬a ∨ ¬c"
DEL Clause "b ∨ ¬t ∨ a ∨ ¬c"
DEL Clause "a"
FORMULA: finish assignments:
{
| 　 ¬c
| ∧ ( c ∨ d )
}

=== NEW STATUS : -2 ===
FORMULA: begin processing(layer=2):
{
| 　 ¬c
| ∧ ( c ∨ d )
}
ASSIGN: "c" -&gt; False
DEL Clause "¬c"
DEL literal "c" in "c ∨ d"
FORMULA: finish assignments:
{
| 　 d
}

=== NEW STATUS : -3 ===
FORMULA: begin processing(layer=3):
{
| 　 d
}
ASSIGN: "d" -&gt; False
DEL literal "d" in "d"
FORMULA: finish assignments:
{
| 　 (  )
}
***FORMULA CONTAIN EMPTY CLAUSES: backtrack.

=== NEW STATUS : 3 ===
BACKTRACK: -&gt; 2
FORMULA: begin processing(layer=3):
{
| 　 d
}
ASSIGN: "d" -&gt; True
DEL Clause "d"
FORMULA: finish assignments:
{
}
***FORMULA IS EMPTY: It can be satisfied.
***ALGORITHM FINISHED.
1
"a" -&gt; True
"b" -&gt; _
"c" -&gt; False
"t" -&gt; _
"d" -&gt; True
</code></pre>
<p>输出中间出现<code>BACKTRACK</code>就说明算法执行了一次回溯，将公式还原回赋值、化简前的形态。</p>
<h3><a id="_726"></a>参考</h3>
<ul><li> <p>Boolean satisfiability problem - Wikipedia<br/> <a href="https://en.wikipedia.org/wiki/Boolean_satisfiability_problem">https://en.wikipedia.org/wiki/Boolean_satisfiability_problem</a></p> </li><li> <p>DPLL algorithm - Wikipedia<br/> <a href="https://en.wikipedia.org/wiki/DPLL_algorithm">https://en.wikipedia.org/wiki/DPLL_algorithm</a></p> </li></ul>
</div>
<link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css" rel="stylesheet"/>
<link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css" rel="stylesheet"/>
</div>