<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<blockquote>
<p>✅🎡个人主页：<a href="https://blog.csdn.net/aasd23?spm=1000.2115.3001.5343" title="程序猿追">程序猿追</a></p>
<p>✅🎡系列专栏：<a href="https://blog.csdn.net/aasd23/category_11805404.html?spm=1001.2014.3001.5482" title="算法合集">算法合集</a></p>
<p>✅🎡目前状态：创建Java学习之路（零基础到就业实战）系列，目前更新到JAVAWEB开发</p>
<p>✅🎡作者简介：大家好，我是程序猿追，全栈领域新星创作者，算法爱好者，常在作者周榜排名前30，某不知名的 ACMer</p>
<p>✅🎡推荐一款刷题面试找工作三不误的网站——<a href="https://www.nowcoder.com/link/pc_csdncpt_cxyz_sf" title="牛客网">牛客网</a></p>
<p>✅🎡个人名言：不积跬步无以至千里，趁年轻，使劲拼，给未来的自己一个交代！</p>
</blockquote>
<p></p>
<p id="main-toc"><strong>目录</strong></p>
<p id="%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;">🍟<a href="#%E5%89%8D%E8%A8%80">前言</a></p>
<p id="%C2%A0%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-toc" style="margin-left:0px;">🍟<a href="#%C2%A0%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8">反转链表</a></p>
<p id="%E9%A2%98%E8%A7%A3%E4%BB%A3%E7%A0%81-toc" style="margin-left:40px;">🍔<a href="#%E9%A2%98%E8%A7%A3%E4%BB%A3%E7%A0%81">题解代码</a></p>
<p id="%E9%93%BE%E8%A1%A8%E5%86%85%E6%8C%87%E5%AE%9A%E5%8C%BA%E9%97%B4%E5%8F%8D%E8%BD%AC-toc" style="margin-left:0px;">🍟<a href="#%E9%93%BE%E8%A1%A8%E5%86%85%E6%8C%87%E5%AE%9A%E5%8C%BA%E9%97%B4%E5%8F%8D%E8%BD%AC">链表区间反转</a></p>
<p id="%E9%A2%98%E8%A7%A3%E4%BB%A3%E7%A0%81-toc" style="margin-left:40px;">🍔<a href="#%E9%A2%98%E8%A7%A3%E4%BB%A3%E7%A0%81">题解代码</a></p>
<p id="%C2%A0%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A5%87%E5%81%B6%E9%87%8D%E6%8E%92-toc" style="margin-left:0px;">🍟<a href="#%C2%A0%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A5%87%E5%81%B6%E9%87%8D%E6%8E%92">链表的奇偶重排</a></p>
<p id="%E9%A2%98%E8%A7%A3%E4%BB%A3%E7%A0%81-toc" style="margin-left:40px;">🍔<a href="#%E9%A2%98%E8%A7%A3%E4%BB%A3%E7%A0%81">题解代码</a></p>
<p id="%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9%E6%AF%8Fk%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC-toc" style="margin-left:0px;">🍟<a href="#%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9%E6%AF%8Fk%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC">链表中的节点每k个一组翻转</a></p>
<p id="%E9%A2%98%E8%A7%A3%E4%BB%A3%E7%A0%81-toc" style="margin-left:40px;">🍔<a href="#%E9%A2%98%E8%A7%A3%E4%BB%A3%E7%A0%81">题解代码</a></p>
<p></p>
<h1 id="%E5%89%8D%E8%A8%80">前言</h1>
<blockquote>
<p>       哈喽，大家好，我是程序猿追，众所周知算法是比较复杂又基础的学科，每个学编程的人都会学习大量的算法。无论在我们面试还是笔试算法是必不可少的，我们打开某招聘网站，发现薪资待遇都很友好。</p>
</blockquote>
<p><img alt="" height="637" src="image\3bb3115d6bd543aa9dccd09ed8418016.png" width="1200"/></p>
<p> 再看看某大厂的面试题</p>
<p> <img alt="" height="114" src="image\bd70b227c70848839cfdc104e1b9b441.png" width="882"/></p>
<blockquote>
<p> 无论是找工作，还是打比赛，搞科研，算法占据了主要地位，在我刚开始学习算法时（我还是一个小菜鸡时），我的一个大牛学长（已经拿到了心仪的 offer）推荐我一个神奇的神奇——<a class="link-info" href="https://www.nowcoder.com/link/pc_csdncpt_cxyz_sf" title="我是神奇">我是神奇</a>，里面大厂的算法题、面试题以及面经应有尽有，我们来看看吧。</p>
</blockquote>
<p></p>
<h1 id="%C2%A0%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8">反转链表</h1>
<p>🎀<strong>描述</strong></p>
<blockquote>
<p>给定一个单链表的头结点pHead(该头节点是有值的，比如在下图，它的val是1)，长度为n，反转该链表后，返回新链表的表头。</p>
<p>数据范围： 0 ≤ n ≤ 1000</p>
<p>要求：空间复杂度 O(1)，时间复杂度 O(n)。</p>
<p>如当输入链表{1,2,3}时，</p>
<p>经反转后，原链表变为{3,2,1}，所以对应的输出为{3,2,1}。</p>
<p>以上转换过程如下图所示：</p>
<p><img alt="" height="193" src="image\56e6954863a44b059fe8dd9546ca7df3.png" width="314"/></p>
<p></p>
</blockquote>
<p> 🎀<strong>示例1</strong></p>
<blockquote>
<p>输入：{1,2,3}</p>
<p>返回值：{3,2,1}</p>
</blockquote>
<p> 🎀<strong>示例2</strong></p>
<blockquote>
<p>输入：{}</p>
<p>返回值：{}</p>
</blockquote>
<blockquote>
<p>说明：空链表则输出空</p>
</blockquote>
<p></p>
<h2 id="%E9%A2%98%E8%A7%A3%E4%BB%A3%E7%A0%81">题解代码</h2>
<pre><code class="language-java">public class Solution {
    public ListNode ReverseList(ListNode head) {
        //处理空链表 fast-template
        if (head == null)
            return null;
        ListNode cur = head;
        ListNode pre = null;
        while (cur != null) {
            //断开链表，要记录后续一个
            ListNode temp = cur.next;
            //当前的next指向前一个
            cur.next = pre;
            //前一个更新为当前
            pre = cur;
            //当前更新为刚刚记录的后一个
            cur = temp;
        }
        return pre;}
}</code></pre>
<h1></h1>
<h1 id="%E9%93%BE%E8%A1%A8%E5%86%85%E6%8C%87%E5%AE%9A%E5%8C%BA%E9%97%B4%E5%8F%8D%E8%BD%AC">链表内指定区间反转</h1>
<p id="%E6%8F%8F%E8%BF%B0"><strong>💎描述</strong></p>
<blockquote>
<p>将一个节点数为 size 链表 m 位置到 n 位置之间的区间反转，要求时间复杂度 O(n)，空间复杂度 O(1)O(1)。<br/> 例如：<br/> 给出的链表为 NULL1→2→3→4→5→NULL, m=2,n=4m=2,n=4,<br/> 返回  NULL1→4→3→2→5→NULL.<br/>  </p>
<p>数据范围： 链表长度 0 &lt; size ≤ 1000，0 &lt; size0 &lt; m ≤ n ≤ size，链表中每个节点的值满足 ∣val∣≤1000</p>
<p><strong>要求：</strong>时间复杂度 O(n) ，空间复杂度 O(n)</p>
<p><strong>进阶：</strong>时间复杂度 O(n)，空间复杂度 O(1)</p>
</blockquote>
<p><strong>💎示例1</strong></p>
<blockquote>
<p><strong>输入：</strong>{1,2,3,4,5},2,4</p>
<p><strong>返回值：</strong>{1,4,3,2,5}</p>
</blockquote>
<p><strong>💎示例2</strong></p>
<blockquote>
<p><strong>输入：</strong>{5},1,1</p>
<p><strong>返回值：</strong>{5}</p>
</blockquote>
<h2></h2>
<h2>题解代码</h2>
<pre><code class="language-java">import java.util.*;
public class Solution {
    public ListNode reverseBetween (ListNode head, int m, int n) {
        //加个表头 fast-template
        ListNode res = new ListNode(-1);
        res.next = head;
        //前序节点
        ListNode pre = res;
        //当前节点
        ListNode cur = head;
        //找到m
        for (int i = 1; i &lt; m; i++) {
            pre = cur;
            cur = cur.next;
        }
        //从m反转到n
        for (int i = m; i &lt; n; i++) {
            ListNode temp = cur.next;
            cur.next = temp.next;
            temp.next = pre.next;
            pre.next = temp;
        }
        //返回去掉表头
        return res.next;}
}</code></pre>
<h1 id="%C2%A0%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A5%87%E5%81%B6%E9%87%8D%E6%8E%92">链表的奇偶重排</h1>
<p><strong>💕描述</strong></p>
<blockquote>
<p>给定一个单链表，请设定一个函数，将链表的奇数位节点和偶数位节点分别放在一起，重排后输出。</p>
<p>注意是节点的编号而非节点的数值。</p>
<p>数据范围：节点数量满足 0 ≤ n ≤ 10^5，节点中的值都满足 0 ≤ val ≤ 1000</p>
<p>要求：空间复杂度 O(n)，时间复杂度 O(n)</p>
</blockquote>
<p><strong>💕示例1</strong></p>
<blockquote>
<p><strong>输入：</strong>{1,2,3,4,5,6}</p>
<p><strong>返回值：</strong>{1,3,5,2,4,6}</p>
</blockquote>
<p><strong>💕说明：</strong></p>
<blockquote>
<p>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;NULL</p>
<p>重排后为</p>
<p>1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;6-&gt;NULL</p>
</blockquote>
<p><strong>💕示例2</strong></p>
<blockquote>
<p><strong>输入：</strong>{1,4,6,3,7}</p>
<p><strong>返回值：</strong>{1,6,7,4,3}</p>
</blockquote>
<p><strong>💕说明：</strong></p>
<blockquote>
<p>1-&gt;4-&gt;6-&gt;3-&gt;7-&gt;NULL</p>
<p>重排后为</p>
<p>1-&gt;6-&gt;7-&gt;4-&gt;3-&gt;NULL<br/> 奇数位节点有1,6,7，偶数位节点有4,3。重排后为1,6,7,4,3</p>
</blockquote>
<p><strong>💕备注：</strong></p>
<blockquote>
<p>链表长度不大于200000。每个数范围均在int内。</p>
</blockquote>
<p></p>
<h2>题解代码</h2>
<pre><code class="language-java">import java.util.*;
public class Solution {
    public ListNode oddEvenList (ListNode head) { 
        //如果链表为空，不用重排 fast-template
        if(head == null)
            return head;
        //even开头指向第二个节点，可能为空
        ListNode even = head.next;
        //odd开头指向第一个节点
        ListNode odd = head;
        //指向even开头
        ListNode evenhead = even;
        while(even != null &amp;&amp; even.next != null){
            //odd连接even的后一个，即奇数位
            odd.next = even.next;
            //odd进入后一个奇数位
            odd = odd.next;
            //even连接后一个奇数的后一位，即偶数位
            even.next = odd.next;
            //even进入后一个偶数位
            even = even.next;
        }
        //even整体接在odd后面
        odd.next = evenhead;
        return head;}
}</code></pre>
<h1 id="%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9%E6%AF%8Fk%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC">链表中的节点每k个一组翻转</h1>
<p><strong>🎉描述</strong></p>
<blockquote>
<p>将给出的链表中的节点每 k 个一组翻转，返回翻转后的链表<br/> 如果链表中的节点数不是 k 的倍数，将最后剩下的节点保持原样<br/> 你不能更改节点中的值，只能更改节点本身。</p>
<p>数据范围： 0 ≤ n ≤ 2000 ， 1 ≤ k ≤ 2000 ，链表中每个元素都满足 0 ≤ val ≤ 1000<br/> 要求空间复杂度 O(1)，时间复杂度 O(n)</p>
</blockquote>
<p><strong>🎉例如：</strong></p>
<blockquote>
<p>给定的链表是 1→2→3→4→5</p>
<p>对于 k = 2, 你应该返回 2→1→4→3→5</p>
<p>对于 k = 3, 你应该返回 3→2→1→4→5</p>
</blockquote>
<p><strong>🎉示例1</strong></p>
<blockquote>
<p><strong>输入：</strong>{1,2,3,4,5},2</p>
<p><strong>返回值：</strong>{2,1,4,3,5}</p>
</blockquote>
<p><strong>🎉示例2</strong></p>
<blockquote>
<p><strong>输入：</strong>{},1</p>
<p><strong>复制返回值：</strong>{}</p>
</blockquote>
<h2></h2>
<h2></h2>
<pre><code class="language-java">import java.util.*;
public class Solution {
    public ListNode reverseKGroup (ListNode head, int k) {
         //找到每次翻转的尾部 fast-template
        ListNode tail = head;
        //遍历k次到尾部
        for (int i = 0; i &lt; k; i++) {
            //如果不足k到了链表尾，直接返回，不翻转
            if (tail == null)
                return head;
            tail = tail.next;
        }
        //翻转时需要的前序和当前节点
        ListNode pre = null;
        ListNode cur = head;
       //在到达当前段尾节点前
        while (cur != tail) {
            //翻转
            ListNode temp = cur.next;
            cur.next = pre;
            pre = cur;
            cur = temp;
        }
       //当前尾指向下一段要翻转的链表
        head.next = reverseKGroup(tail, k);
        return pre;}
}</code></pre>
<p></p>
<blockquote>
<p><strong>不积跬步无以至千里，趁年轻，使劲拼，给未来的自己一个交代！向着明天更好的自己前进吧！</strong></p>
<p class="img-center"><img alt="" height="228" src="https://img-blog.csdnimg.cn/43e17a5ffd1e49a7814db0afd1a077e5.gif" width="405"/></p>
<p></p>
</blockquote>
<p></p>
</div>
</div>