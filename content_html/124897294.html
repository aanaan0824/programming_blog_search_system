<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<p id="main-toc"><strong>目录</strong></p>
<p id="%E4%B8%80%E3%80%81%E5%89%8D%E8%A8%80-toc" style="margin-left:80px;"><a href="#%E4%B8%80%E3%80%81%E5%89%8D%E8%A8%80">一、前言</a></p>
<p id="%E4%BA%8C%E3%80%81%E6%97%A5%E6%9C%9F%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px;"><a href="#%E4%BA%8C%E3%80%81%E6%97%A5%E6%9C%9F%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0">二、日期类的实现</a></p>
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E6%A3%80%E6%9F%A5%E6%97%A5%E6%9C%9F%E7%9A%84%E5%90%88%E6%B3%95%E6%80%A7-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E6%A3%80%E6%9F%A5%E6%97%A5%E6%9C%9F%E7%9A%84%E5%90%88%E6%B3%95%E6%80%A7">        检查日期的合法性</a></p>
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%3C%C2%A0%C2%A0%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%3C%C2%A0%C2%A0%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">         &lt;  运算符重载</a></p>
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%3D%3D%20%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%3D%3D%20%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">        == 运算符重载</a></p>
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%3C%3D%20%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%3C%3D%20%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">        &lt;= 运算符重载</a></p>
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%3E%C2%A0%C2%A0%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%3E%C2%A0%C2%A0%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">         &gt;  运算符重载</a></p>
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%3E%3D%20%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%3E%3D%20%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">        &gt;= 运算符重载</a></p>
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0!%3D%20%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0!%3D%20%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">         != 运算符重载</a></p>
<p id="%E6%94%B9%E8%BF%9B%E5%92%8C%E4%BC%98%E5%8C%96-toc" style="margin-left:80px;"><a href="#%E6%94%B9%E8%BF%9B%E5%92%8C%E4%BC%98%E5%8C%96">        </a><a href="#%E6%94%B9%E8%BF%9B%E5%92%8C%E4%BC%98%E5%8C%96">改进和优化</a></p>
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E6%97%A5%E6%9C%9F%20%2B%20%E5%A4%A9%E6%95%B0-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E6%97%A5%E6%9C%9F%20%2B%20%E5%A4%A9%E6%95%B0">        日期 + 天数</a></p>
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E6%97%A5%E6%9C%9F%20%2B%3D%20%E5%A4%A9%E6%95%B0-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E6%97%A5%E6%9C%9F%20%2B%3D%20%E5%A4%A9%E6%95%B0">        日期 += 天数</a></p>
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E6%97%A5%E6%9C%9F%20-%3D%20%E5%A4%A9%E6%95%B0-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E6%97%A5%E6%9C%9F%20-%3D%20%E5%A4%A9%E6%95%B0">        日期 -= 天数</a></p>
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E6%97%A5%E6%9C%9F%20-%20%E5%A4%A9%E6%95%B0-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E6%97%A5%E6%9C%9F%20-%20%E5%A4%A9%E6%95%B0">        日期 - 天数</a></p>
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E5%89%8D%E7%BD%AE%20%2B%2B-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E5%89%8D%E7%BD%AE%20%2B%2B">        前置 ++</a></p>
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E5%90%8E%E7%BD%AE%20%2B%2B-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E5%90%8E%E7%BD%AE%20%2B%2B">        后置 ++</a></p>
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E5%89%8D%E7%BD%AE%20---toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E5%89%8D%E7%BD%AE%20--">        前置 --</a></p>
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E5%90%8E%E7%BD%AE%20---toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E5%90%8E%E7%BD%AE%20--">        后置 --</a></p>
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E6%97%A5%E6%9C%9F%20-%20%E6%97%A5%E6%9C%9F-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E6%97%A5%E6%9C%9F%20-%20%E6%97%A5%E6%9C%9F">        日期 - 日期</a></p>
<p id="%E4%B8%89%E3%80%81%E6%80%BB%E7%BB%93-toc" style="margin-left:80px;"><a href="#%E4%B8%89%E3%80%81%E6%80%BB%E7%BB%93">三、总结</a></p>
<hr/>
<h3>一、前言</h3>
<blockquote>
<p>在我们的日常生活中，我们可能需要计算几天后的日期，或计算日期差等，现如今计算日期的方式有很多，简单粗暴的直接查看日历，快捷点的直接使用<span style="color:#956fe7;">日期计算器</span>来求得，先给一个网络上的日期计算器截图：</p>
<p><img alt="" height="444" src="image\5bb8c58572444b73bf58bb6ab3f99917.png" width="911"/></p>
<p>现在，就让我们用代码来实现其工作原理吧。 </p>
<ul><li><span style="background-color:#fefcd8;">注意：</span>本篇日期类<span style="color:#956fe7;"><strong>.h</strong></span>文件放声明，<span style="color:#956fe7;"><strong>.cpp</strong></span>文件放定义</li></ul>
</blockquote>
<h3 id="%E4%BA%8C%E3%80%81%E6%97%A5%E6%9C%9F%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0">二、日期类的实现</h3>
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E6%A3%80%E6%9F%A5%E6%97%A5%E6%9C%9F%E7%9A%84%E5%90%88%E6%B3%95%E6%80%A7">检查日期的合法性</h3>
<blockquote>
<p>实现日期类首先就得检查日期的合法性，这其中就包括大小月，闰年的2月有29天，一年只有12个月等等细节都要考虑到。</p>
<pre><code class="language-cpp">class Date
{
public:
    bool isLeapYear(int year) //判断是否为闰年
    {
    	//四年一闰百年不闰或四百年一闰
    	return (year % 4 == 0 &amp;&amp; year % 100 != 0) || (year % 400 == 0);
    }
	int GetMonthDay(int year, int month)
	{
        //加上static防止函数频繁调用开辟几十个字节大小的数组，最好加上
		static int monthDayArray[13] = { 0,31,28,31,30,31,30,31,31,30,31,30,31 };
		if (month == 2 &amp;&amp; isLeapYear(year))
			return 29; //闰月29天
		else
			return monthDayArray[month];
	}
	Date(int year = 1, int month = 1, int day = 1)
	{
		if (year &gt;= 1 &amp;&amp; month &lt;= 12 &amp;&amp; month &gt;= 1 &amp;&amp; day &lt;= GetMonthDay(year, month))
		{
            //确保日期合法
			_year = year;
			_month = month;
			_day = day;
		}
	}
private:
	int _year;
	int _month;
	int _day;
};
</code></pre>
</blockquote>
<h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%3C%C2%A0%C2%A0%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">&lt;  运算符重载</h3>
<blockquote>
<ul><li><span style="background-color:#fbd4d0;">思路：</span></li></ul>
<p>&lt; 运算符重载在我上一篇博文已经详细讲解过，主要是先把大于的情况全部统计出来，就比如我要比较实例化对象d1是否小于实例化对象d2，只需考虑如下三种满足的情况：</p>
<ul><li>d1的年小于d2的年</li><li>d1与d2年相等，d1的月小于d2的月</li><li>d1与d2年相等月相等，d1的天小于d2的天</li></ul>
<p>这三种全是小于的情况，返回true，其余返回false</p>
<ul><li><span style="background-color:#edf6e8;">代码如下：</span></li></ul>
<pre><code class="language-cpp">// &lt;运算符重载
bool Date::operator&lt;(const Date&amp; d) const //类外访问成员函数需要设定类域
{
	if (_year &lt; d._year ||
		_year == d._year &amp;&amp; _month &lt; d._month ||
		_year == d._year &amp;&amp; _month == d._month &amp;&amp; _day &lt; d._day)
		return true;
	else
		return false;
}</code></pre>
</blockquote>
<h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%3D%3D%20%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">== 运算符重载</h3>
<blockquote>
<ul><li><span style="background-color:#fbd4d0;"> 思路：</span></li></ul>
<p>== 运算符重载其实非常简单，只需要判断d1和d2的年、月、天是否对应相等即可：</p>
<ul><li><span style="background-color:#edf6e8;">代码如下：</span></li></ul>
<pre><code class="language-cpp">// ==运算符重载
bool Date::operator==(const Date&amp; d) const
{
	return _year == d._year &amp;&amp;
		_month == d._month &amp;&amp;
		_day == d._day;
}</code></pre>
</blockquote>
<h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%3C%3D%20%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">&lt;= 运算符重载</h3>
<blockquote>
<ul><li><span style="background-color:#fbd4d0;">思路： --  </span><strong><span style="background-color:#fbd4d0;">复用</span></strong></li></ul>
<p>&lt;= 的运算符重载，这里要仔细想一想 &lt;= 成立的条件是啥。不就是<span style="color:#956fe7;"> 要么 &lt; 要么 =</span> 吗？我们只需要<span style="color:#fe2c24;"><strong>复用</strong></span>先前写的<span style="color:#956fe7;"> &lt; 运算符重载</span>和 <span style="color:#956fe7;">&lt;=运算符重载</span>，无需自己费老大劲推导其内部原理。</p>
<ul><li><span style="background-color:#edf6e8;">代码如下：</span></li></ul>
<pre><code class="language-cpp">// &lt;=运算符重载
bool Date::operator&lt;=(const Date&amp; d) const
{
	return *this &lt; d || *this == d;
}</code></pre>
</blockquote>
<h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%3E%C2%A0%C2%A0%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">&gt;  运算符重载</h3>
<blockquote>
<ul><li><span style="background-color:#fbd4d0;">思路： --  </span><strong><span style="background-color:#fbd4d0;">复用</span></strong></li></ul>
<p>&gt; 的反义就是 &lt;=，所以我们只需要<span style="color:#fe2c24;"><strong>复用</strong> </span><span style="color:#956fe7;">&lt;= 运算符重载</span>，再<span style="color:#fe2c24;">对其取反</span>即可解决此问题。</p>
<ul><li><span style="background-color:#edf6e8;">代码如下：</span></li></ul>
<pre><code class="language-cpp">// &gt;运算符重载
bool Date::operator&gt;(const Date&amp; d) const
{
	return !(*this &lt;= d);
}</code></pre>
</blockquote>
<h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%3E%3D%20%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">&gt;= 运算符重载</h3>
<blockquote>
<ul><li><span style="background-color:#fbd4d0;">思路： --  </span><strong><span style="background-color:#fbd4d0;">复用</span></strong></li></ul>
<p>&gt;= 的反义就是 &lt;，所以我们只需要<span style="color:#fe2c24;"><strong>复用</strong></span> <span style="color:#956fe7;">&lt; 运算符重载</span>，再<span style="color:#fe2c24;">对其取反</span>即可。</p>
<ul><li><span style="background-color:#edf6e8;">代码如下：</span></li></ul>
<pre><code class="language-cpp">// &gt;=运算符重载
bool Date::operator&gt;=(const Date&amp; d) const
{
	return !(*this &lt; d);
}</code></pre>
</blockquote>
<h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0!%3D%20%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">!= 运算符重载</h3>
<blockquote>
<ul><li><span style="background-color:#fbd4d0;">思路： --  <strong>复用</strong></span></li></ul>
<p>有了前面的基础，写个 != 也很简单，<span style="color:#956fe7;">对 == 取反</span>即可</p>
<ul><li><span style="background-color:#edf6e8;">代码如下：</span></li></ul>
<pre><code class="language-cpp">//!=运算符重载
bool Date::operator!=(const Date&amp; d) const
{
	return !(*this == d);
}</code></pre>
</blockquote>
<h3 id="%E6%94%B9%E8%BF%9B%E5%92%8C%E4%BC%98%E5%8C%96">改进和优化</h3>
<blockquote>
<p>上述我们写的运算符重载都是建立在声明定义分离的，这里我们可以对其进行优化，如下：</p>
<p>先前我们学过内联，可以帮助我们对于短小函数减少函数调用而引发的效率损失问题，因此我们可以把上述几个运算符重载函数放成内联，此外，有一种简单粗暴的方法：<span style="color:#fe2c24;">直接在类里定义，因为类里的函数默认内联</span>，还省的我们自己写inline，而且我们也不用在类外加上类域了，当然，有些长的函数还是声明和定义分离比较好。</p>
<ul><li><span style="background-color:#fbd4d0;">Date.h 文件：</span></li></ul>
<pre><code class="language-cpp">#pragma once
#include&lt;iostream&gt;
#include&lt;assert.h&gt;
using std::cout;
using std::cin;
using std::endl;
class Date
{
public:
	bool isLeapYear(int year)
	{
		//四年一润百年不润或四百年一润
		return (year % 4 == 0 &amp;&amp; year % 100 != 0) || (year % 400 == 0);
	}
	//获取某月天数
	int GetMonthDay(int year, int month);
	//构造函数
	Date(int year = 1, int month = 1, int day = 1);
	//打印
	void Print() const
	{
		cout &lt;&lt; _year &lt;&lt; "-" &lt;&lt; _month &lt;&lt; "-" &lt;&lt; _day &lt;&lt; endl;
	}
	// &lt;运算符重载
	bool operator&lt;(const Date&amp; d) const;
	// ==运算符重载
	bool operator==(const Date&amp; d) const;
	// &lt;=运算符重载
	bool operator&lt;=(const Date&amp; d) const
	{
		return *this &lt; d || *this == d;
	}
	// &gt;运算符重载
	bool operator&gt;(const Date&amp; d) const
	{
		return !(*this &lt;= d);
		//return (d &lt; *this);
	}
	// &gt;=运算符重载
	bool operator&gt;=(const Date&amp; d) const
	{
		return !(*this &lt; d);
	}
	// !=运算符重载
	bool operator!=(const Date&amp; d) const
	{
		return !(*this == d);
	}
private:
	int _year;
	int _month;
	int _day;
};</code></pre>
<ul><li><span style="background-color:#fbd4d0;">Date.cpp 文件：</span></li></ul>
<pre><code class="language-cpp">#include"Date.h"
//获取某月天数
int Date::GetMonthDay(int year, int month)
{
	assert(year &gt;= 0 &amp;&amp; month &gt; 0 &amp;&amp; month &lt; 13);
	static int monthDayArray[13] = { 0,31,28,31,30,31,30,31,31,30,31,30,31 };
	if (month == 2 &amp;&amp; isLeapYear(year))
		return 29;
	else
		return monthDayArray[month];
}
//构造函数
Date::Date(int year, int month, int day)
{
	if (year &gt;= 1 &amp;&amp; month &lt;= 12 &amp;&amp; month &gt;= 1 &amp;&amp; day &lt;= GetMonthDay(year, month))
	{
		_year = year;
		_month = month;
		_day = day;
	}
	else
		cout &lt;&lt; "日期非法" &lt;&lt; endl;
}
// &lt;运算符重载
bool Date::operator&lt;(const Date&amp; d) const //类外访问成员函数需要设定类域
{
	if (_year &lt; d._year ||
		_year == d._year &amp;&amp; _month &lt; d._month ||
		_year == d._year &amp;&amp; _month == d._month &amp;&amp; _day &lt; d._day)
		return true;
	else
		return false;
}
// ==运算符重载
bool Date::operator==(const Date&amp; d) const
{
	return _year == d._year &amp;&amp;
		_month == d._month &amp;&amp;
		_day == d._day;
}</code></pre>
</blockquote>
<h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E6%97%A5%E6%9C%9F%20%2B%20%E5%A4%A9%E6%95%B0">日期 + 天数</h3>
<blockquote>
<ul><li><span style="background-color:#fbd4d0;">思路：</span></li></ul>
<p>对于日期 + 天数，我们得到的还是一个日期。特别需要注意进位的问题（<span style="color:#956fe7;">天满了往月进，月满了往年进</span>），主要考虑如下几个特殊点：</p>
<ul><li>加过的天数超过该月的最大天数，需要进位</li><li>当月进位到13时，年进位+1，月置为1</li></ul>
<p><img alt="" height="419" src="image\cb8eeb08fe7b4bf2b86850ce943c2a12.png" width="906"/></p>
<ul><li><span style="background-color:#fbd4d0;">法一：</span></li></ul>
<pre><code class="language-cpp">Date Date::operator+(int day) const
{
	Date ret(*this); //拷贝构造，拿d1去初始化ret
	ret._day += day;
	while (ret._day &gt; GetMonthDay(ret._year, ret._month))
	{
		ret._day -= GetMonthDay(ret._year, ret._month);
		ret._month++;
		if (ret._month == 13)
		{
			ret._year++;
			ret._month = 1;
		}
	}
	return ret;
}</code></pre>
<p>出了作用域，对象ret不在，它是一个局部对象，我们这里不能用引用，用了的话，返回的就是ret的别名，但是ret又已经销毁了，访问野指针了，<span style="color:#956fe7;">所以出了作用域，如果对象不在了，就不能用引用返回，要用传值返回</span></p>
<ul><li><span style="background-color:#fbd4d0;">法二：<strong>复用日期+=天数</strong></span></li></ul>
<p>此法是建立在日期+=天数的基础上完成的，这里各位可以先看下文日期+=天数，然后我们进行复用：</p>
<pre><code class="language-cpp">Date Date::operator+(int day) const
{
	//法二：复用日期 += 天数
	Date ret(*this);
	ret += day;
	return ret;
}</code></pre>
<ul><li><span style="background-color:#edf6e8;">法一和法二熟优？</span></li></ul>
<p>答案：<span style="color:#956fe7;">法二</span>更好，也就是用+去复用+=，具体原因在下文会解释。</p>
</blockquote>
<h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E6%97%A5%E6%9C%9F%20%2B%3D%20%E5%A4%A9%E6%95%B0">日期 += 天数</h3>
<blockquote>
<p>这里实现 += 其实有两种方案</p>
<ul><li><span style="background-color:#fbd4d0;">法一：</span></li></ul>
<p>前面我实现的日期+天数，仔细观察我的代码，函数的第一行，我就调用了一个拷贝构造：</p>
<pre><code class="language-cpp">Date ret(*this); //拷贝构造，拿d1去初始化ret</code></pre>
<p>这里调用拷贝构造，是为了不在*this本身上做变动，只在ret上进行操作，其理由是日期+天数得到的是另一个日期，而不用拷贝构造直接在*this上做改动只会导致原有的日期也变化，而这个变化正是我日期 += 天数的需求</p>
<p></p>
<p>仔细想想：+=天数就是在原有的日期上再加一定的天数，直接对*this做手脚即可，因此只需对日期+天数的代码进行小改动即可：</p>
<pre><code class="language-cpp">Date&amp; Date::operator+=(int day) //传引用返回
{
	//如果day小于0，要单独处理
	if (day &lt; 0)
	{
		return *this -= -day;
	}
	_day += day;
	while (_day &gt; GetMonthDay(_year, _month))
	{
		_day -= GetMonthDay(_year, _month);
		_month++;
		if (_month == 13)
		{
			_year++;
			_month = 1;
		}
	}
	return *this;
}</code></pre>
<p>注意这里是传引用返回，原因就在于我返回的*this是全局的，出了作用域还在</p>
<ul><li><span style="background-color:#fbd4d0;">法二：<strong>复用日期 +天数</strong></span></li></ul>
<pre><code class="language-cpp">Date&amp; Date::operator+=(int day)
{
	//法二：复用
	* this = *this + day; //让d1+过天数后再返回给自己从而实现+=
	return *this;
}</code></pre>
<ul><li><span style="background-color:#edf6e8;">法一和法二熟优？</span></li></ul>
<p>答案：<span style="color:#956fe7;">法一</span>。其实讨论这个问题就是在讨论用+去复用+=号还是用+=复用+号，答案是用+去复用+=好，因为+有两次拷贝，而+=没有拷贝，所以实现+=，并且用+去复用+=效率更高</p>
</blockquote>
<h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E6%97%A5%E6%9C%9F%20-%3D%20%E5%A4%A9%E6%95%B0">日期 -= 天数</h3>
<blockquote>
<ul><li><span style="background-color:#fbd4d0;">思路：</span></li></ul>
<p>日期-=天数得到的还是一个日期，且是在原日期的基础上做改动。合法的日期减去天数后的day只要&gt;0就没问题，若小于0就要借位了。要注意当减去的天数&lt;0时单独讨论。具体步骤如下：</p>
<ol><li>当减的天数为负数，则为+=，直接调用</li><li>若减后的day&lt;0，月-1</li><li>若月 = 0，则年-1，月置为12</li></ol>
<ul><li><span style="background-color:#edf6e8;">代码如下：</span></li></ul>
<pre><code class="language-cpp">//日期 -=天数  d1-=100
Date&amp; Date::operator-=(int day)
{
	//如果减去的天数是负数，要单独处理，直接调用+=运算符重载
	if (day &lt; 0)
	{
		return *this += -day;
	}
	_day -= day;
	while (_day &lt;= 0)
	{
		--_month;
		if (_month == 0)
		{
			_month = 12;
			--_year;
		}
		_day += GetMonthDay(_year, _month);
	}
	return *this;
}
</code></pre>
</blockquote>
<h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E6%97%A5%E6%9C%9F%20-%20%E5%A4%A9%E6%95%B0">日期 - 天数</h3>
<blockquote>
<p>有了先前日期+和+=的基础，这里实现日期 - 天数直接复用日期 -= 天数即可：</p>
<pre><code class="language-cpp">//日期 - 天数
Date Date::operator-(int day) const
{
	Date ret(*this);
	ret -= day;
	return ret;
}</code></pre>
</blockquote>
<h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E5%89%8D%E7%BD%AE%20%2B%2B">前置 ++</h3>
<blockquote>
<ul><li><span style="background-color:#fbd4d0;">思路：</span></li></ul>
<p>C++里有前置++和后置++，这就导致一个巨大的问题，该如何区分它们，具体实现过程不难（<span style="color:#956fe7;">直接复用+=即可</span>），难的是如何区分前置和后置。因此C++规定，<span style="color:#fe2c24;">无参的为前置，有参的为后置</span>。</p>
<ul><li><span style="background-color:#edf6e8;">代码如下：</span></li></ul>
<pre><code class="language-cpp">//前置++
Date&amp; Date::operator++() //无参的为前置
{
	*this += 1; //直接复用+=
	return *this;
}</code></pre>
</blockquote>
<h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E5%90%8E%E7%BD%AE%20%2B%2B">后置 ++</h3>
<blockquote>
<ul><li><span style="background-color:#fbd4d0;">思路：</span></li></ul>
<p>有参的即为后置，后置++拿到的返回值应该是自己本身未加过的，因此要<span style="color:#956fe7;">先把自己保存起来，再++*this，随后返回自己。</span></p>
<ul><li><span style="background-color:#edf6e8;">代码如下：</span></li></ul>
<pre><code class="language-cpp">//后置++
Date Date::operator++(int i) //有参数的为后置
{
	Date tmp(*this);
	*this += 1; //复用+=
	return tmp;
}</code></pre>
</blockquote>
<h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E5%89%8D%E7%BD%AE%20--">前置 --</h3>
<blockquote>
<ul><li><span style="background-color:#fbd4d0;">思路：</span></li></ul>
<p>前置--和前置++没啥区别，只不过内部复用的是-=</p>
<ul><li><span style="background-color:#edf6e8;">代码如下：</span></li></ul>
<pre><code class="language-cpp">//前置--
Date&amp; Date::operator--() //无参的为前置
{
	*this -= 1; //直接复用-=
	return *this;
}
</code></pre>
</blockquote>
<h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E5%90%8E%E7%BD%AE%20--">后置 --</h3>
<blockquote>
<ul><li><span style="background-color:#fbd4d0;">思路：</span></li></ul>
<p>后置--和后置++类似，只不过内部复用的是-=，不再赘述</p>
<ul><li><span style="background-color:#edf6e8;">代码如下：</span></li></ul>
<pre><code class="language-cpp">//后置--
Date Date::operator--(int i) //有参数的为后置
{
	Date tmp(*this);
	*this -= 1;
	return tmp;
}</code></pre>
</blockquote>
<h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E6%97%A5%E6%9C%9F%20-%20%E6%97%A5%E6%9C%9F">日期 - 日期</h3>
<blockquote>
<ul><li><span style="background-color:#fbd4d0;">思路：</span></li></ul>
<p>日期 - 日期得到的是天数，首先我们得判断两个日期的大小，用min和max代替小的和大的，随后，算出min和max之间的差距，若min!=max，则min就++，随即定义变量n也自增++，最后返回n（注意符号）</p>
<ul><li><span style="background-color:#edf6e8;">代码如下：</span></li></ul>
<pre><code class="language-cpp">//日期 - 日期
int Date::operator-(const Date&amp; d) const
{
	int flag = 1; //方便后续计算正负
	Date max = *this;
	Date min = d;
	if (*this &lt; d)
	{
		min = *this;
		max = d;
		flag = -1; //计算正负
	} //确保max是大的，min是小的
	int n = 0;
	while (min != max)
	{
		min++;
		n++;
	}//算出min和max之间绝对值差距
	return n * flag; //如果d1大，结果为正，d2大结果为负
}</code></pre>
</blockquote>
<h3 id="%E4%B8%89%E3%80%81%E6%80%BB%E7%BB%93">三、总结</h3>
<blockquote>
<p>本篇日期类把先前学到的<span style="color:#956fe7;">引用，传值/传引用返回、拷贝构造、复用</span>等等知识点柔和到了一起，非常值得大家操手练习练习，创作不易，还望三连。</p>
<ul><li>日期类的源码链接：<a class="link-info" href="https://gitee.com/bit-zy/class104/tree/master/Date/Date" title="gitee链接：日期计算器完善版">gitee链接：日期计算器完善版</a></li></ul>
</blockquote>
</div>
</div>