<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<p id="main-toc"><strong>目录</strong></p>
<p id="-toc" style="margin-left:0px;"></p>
<p id="1%E3%80%81%E6%8C%87%E9%92%88%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-toc" style="margin-left:0px;"><a href="#1%E3%80%81%E6%8C%87%E9%92%88%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">1、指针是什么？</a></p>
<p id="2.%20%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B-toc" style="margin-left:0px;"><a href="#2.%20%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B">2. 指针和指针类型</a></p>
<p id="2.1%20%E6%8C%87%E9%92%88%2B-%E6%95%B4%E6%95%B0-toc" style="margin-left:40px;"><a href="#2.1%20%E6%8C%87%E9%92%88%2B-%E6%95%B4%E6%95%B0">2.1 指针+-整数</a></p>
<p id="2.2%20%E6%8C%87%E9%92%88%E7%9A%84%E8%A7%A3%E5%BC%95%E7%94%A8-toc" style="margin-left:40px;"><a href="#2.2%20%E6%8C%87%E9%92%88%E7%9A%84%E8%A7%A3%E5%BC%95%E7%94%A8">2.2 指针的解引用</a></p>
<p id="3.%20%E9%87%8E%E6%8C%87%E9%92%88-toc" style="margin-left:0px;"><a href="#3.%20%E9%87%8E%E6%8C%87%E9%92%88">3. 野指针</a></p>
<p id="3.1%20%E9%87%8E%E6%8C%87%E9%92%88%E6%88%90%E5%9B%A0-toc" style="margin-left:40px;"><a href="#3.1%20%E9%87%8E%E6%8C%87%E9%92%88%E6%88%90%E5%9B%A0">3.1 野指针成因</a></p>
<p id="3.2%20%E5%A6%82%E4%BD%95%E8%A7%84%E9%81%BF%E9%87%8E%E6%8C%87%E9%92%88-toc" style="margin-left:40px;"><a href="#3.2%20%E5%A6%82%E4%BD%95%E8%A7%84%E9%81%BF%E9%87%8E%E6%8C%87%E9%92%88">3.2 如何规避野指针</a></p>
<p id="4.%20%E6%8C%87%E9%92%88%E8%BF%90%E7%AE%97-toc" style="margin-left:0px;"><a href="#4.%20%E6%8C%87%E9%92%88%E8%BF%90%E7%AE%97">4. 指针运算</a></p>
<p id="4.1%20%E6%8C%87%E9%92%88%2B-%E6%95%B4%E6%95%B0-toc" style="margin-left:40px;"><a href="#4.1%20%E6%8C%87%E9%92%88%2B-%E6%95%B4%E6%95%B0">4.1 指针+-整数</a></p>
<p id="4.2%20%E6%8C%87%E9%92%88-%E6%8C%87%E9%92%88-toc" style="margin-left:40px;"><a href="#4.2%20%E6%8C%87%E9%92%88-%E6%8C%87%E9%92%88">4.2 指针-指针</a></p>
<p id="4.3%20%E6%8C%87%E9%92%88%E7%9A%84%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97-toc" style="margin-left:40px;"><a href="#4.3%20%E6%8C%87%E9%92%88%E7%9A%84%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97">4.3 指针的关系运算</a></p>
<p id="5.%20%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84-toc" style="margin-left:0px;"><a href="#5.%20%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84">5. 指针和数组</a></p>
<p id="%C2%A06.%20%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88-toc" style="margin-left:0px;"><a href="#%C2%A06.%20%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88"> 6. 二级指针</a></p>
<p id="7.%20%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84-toc" style="margin-left:0px;"><a href="#7.%20%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84">7. 指针数组</a></p>
<hr id="hr-toc"/>
<h1 id="1%E3%80%81%E6%8C%87%E9%92%88%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">1、指针是什么？</h1>
<blockquote>
<p>指针是什么？</p>
<p>指针理解的2个要点：</p>
<ul><li>1. 指针是内存中一个最小单元的编号，也就是地址，即我们常说的指针即地址</li><li>2. 平时口语中说的指针，通常指的是指针变量，是用来存放内存地址的变量，即指针即变量</li></ul>
<p><strong>总结：指针就是地址，口语中说的指针通常指的是指针变量。</strong></p>
<p>那么我们就可以这样理解：</p>
<p><strong>内存</strong></p>
<p><img alt="" height="492" src="image\821a82724b4a4573b0ed1328a414a5fa.png" width="463"/></p>
<p>指针变量</p>
<p>我们可以通过&amp;（取地址操作符）取出变量的内存其实地址，把地址可以存放到一个变量中，这个 变量就是指针变量。</p>
<pre><code>#include &lt;stdio.h&gt;
int main()
{
	int a = 10;//在内存中开辟一块空间
	int* p = &amp;a;//这里我们对变量a，取出它的地址，可以使用&amp;操作符。
	   //a变量占用4个字节的空间，这里是将a的4个字节的第一个字节的地址存放在p变量
	中，p就是一个之指针变量。
		return 0;
}</code></pre>
<p><strong>总结：</strong></p>
<p><strong>指针变量，用来存放地址的变量。（存放在指针中的值都被当成地址处理）。</strong></p>
<p>那这里的问题是：</p>
<ul><li>一个小的单元到底是多大？（1个字节）</li><li>如何编址？</li></ul>
<p>经过仔细的计算和权衡我们发现一个字节给一个对应的地址是比较合适的。</p>
<p>对于32位的机器，假设有32根地址线，那么假设每根地址线在寻址的时候产生高电平（高电压）和低电平（低电压）就是（1或者0）；</p>
<p>那么32根地址线产生的地址就会是：</p>
<p>00000000 00000000 00000000 00000000</p>
<p>00000000 00000000 00000000 00000001</p>
<p>...</p>
<p>11111111 11111111 11111111 11111111</p>
<p>这里就有2的32次方个地址。</p>
<p>每个地址标识一个字节，那我们就可以给 （2^32Byte == 2^32/1024KB ==2^32/1024/1024MB==2^32/1024/1024/1024GB == 4GB） 4G的空闲进行编址。</p>
<p>同样的方法，那64位机器，如果给64根地址线，那能编址多大空间，自己计算，计算方法如上所示，此处不再计算。</p>
<p>这里我们就明白： 在32位的机器上，地址是32个0或者1组成二进制序列，那地址就得用4个字节的空间来存储，所以 一个指针变量的大小就应该是4个字节。 那如果在64位机器上，如果有64个地址线，那一个指针变量的大小是8个字节，才能存放一个地 址。</p>
<p><strong>总结： 指针是用来存放地址的，地址是唯一标示一块地址空间的。 指针的大小在32位平台是4个字节，在64位平台是8个字节。</strong></p>
</blockquote>
<h1 id="2.%20%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B">2. 指针和指针类型</h1>
<blockquote>
<p>这里我们在讨论一下：指针的类型 我们都知道，变量有不同的类型，整形，浮点型等。</p>
<p>那指针有没有类型呢？ 准确的说：有的。 当有这样的代码：</p>
<pre><code>int num = 10;
p = &amp;num;</code></pre>
<p>要将&amp;num（num的地址）保存到p中，我们知道p就是一个指针变量，那它的类型是怎样的呢？ 我们给指针变量相应的类型。</p>
<pre><code>char  *pc = NULL;
int   *pi = NULL;
short *ps = NULL;
long  *pl = NULL;
float *pf = NULL;
double *pd = NULL;
</code></pre>
<p>这里可以看到，指针的定义方式是： type + * 。</p>
<p>其实： char* 类型的指针是为了存放 char 类型变量的地址。</p>
<p>short* 类型的指针是为了存放 short 类型变量的地址。</p>
<p>int* 类型的指针是为了存放 int 类型变量的地址。 那指针类型的意义是什么？下面我们会进行讲解！</p>
</blockquote>
<h2 id="2.1%20%E6%8C%87%E9%92%88%2B-%E6%95%B4%E6%95%B0">2.1 指针+-整数</h2>
<blockquote>
<pre><code>#include &lt;stdio.h&gt;
int main()
{
 int n = 10;
 char *pc = (char*)&amp;n;
 int *pi = &amp;n;
 
 printf("%p\n", &amp;n);
 printf("%p\n", pc);
 printf("%p\n", pc+1);
 printf("%p\n", pi);
 printf("%p\n", pi+1);
 return  0;
}
</code></pre>
<p><img alt="" height="156" src="image\732fddd96dd6423ca6bd89093ed7780f.png" width="291"/></p>
<p><strong>总结：指针的类型决定了指针向前或者向后走一步有多大（距离）。</strong></p>
</blockquote>
<h2 id="2.2%20%E6%8C%87%E9%92%88%E7%9A%84%E8%A7%A3%E5%BC%95%E7%94%A8">2.2 指针的解引用</h2>
<blockquote>
<pre><code>#include &lt;stdio.h&gt;
int main()
{
	int n = 0x11223344;
	char* pc = (char*)&amp;n;
	int* pi = &amp;n;
	*pc = 0;   //重点在调试的过程中观察内存的变化。
	*pi = 0;   //重点在调试的过程中观察内存的变化。
	return 0;
}</code></pre>
<p>下图为执行完*pc = 0之后n的内存空间</p>
<p><img alt="" height="476" src="image\09b24f849d1f46488f6d54999cab8f44.png" width="722"/></p>
<p>由图可以看出，我们执行完该语句后，只改变了一个字节的空间所对应的值！</p>
<p> 下图为执行完*pi = 0之后的内存空间，与我们定义的指针类型一致，因为我们定义的pc是char类型的指针变量，char只占据四个字节的内存空间。</p>
<p><img alt="" height="476" src="image\8399f50dbeed4ca6b720f14850854adc.png" width="744"/></p>
<p> 由图可以看出，我们这次是改变了四个字节的空间所对应的值，与我们定义的指针类型所一致，因为pi是int 类型的指针变量，int在内存中占据四个字节的空间。</p>
<p><strong>总结：</strong></p>
<p> 指针的类型决定了，对指针解引用的时候有多大的权限（能操作几个字节）。</p>
<p>比如： char* 的指针解引用就只能访问一个字节，而 int* 的指针的解引用就能访问四个字节。</p>
</blockquote>
<h1 id="3.%20%E9%87%8E%E6%8C%87%E9%92%88">3. 野指针</h1>
<blockquote>
<p>概念： 野指针就是指针指向的位置是不可知的（随机的、不正确的、没有明确限制的）</p>
</blockquote>
<h2 id="3.1%20%E9%87%8E%E6%8C%87%E9%92%88%E6%88%90%E5%9B%A0">3.1 野指针成因</h2>
<blockquote>
<p>1. 指针未初始化</p>
<pre><code>#include &lt;stdio.h&gt;
int main()
{
    int* p;//局部变量指针未初始化，默认为随机值
    *p = 20;
    return 0;
}</code></pre>
<p>2. 指针越界访问</p>
<pre><code>#include &lt;stdio.h&gt;
int main()
{
    int arr[10] = { 0 };
    int* p = arr;
    int i = 0;
    for (i = 0; i &lt;= 11; i++)
    {
        //当指针指向的范围超出数组arr的范围时，p就是野指针
        *(p++) = i;
    }
    return 0;
}</code></pre>
<p>3. 指针指向的空间释放（后续会讲，此处暂时不讲）</p>
</blockquote>
<h2 id="3.2%20%E5%A6%82%E4%BD%95%E8%A7%84%E9%81%BF%E9%87%8E%E6%8C%87%E9%92%88">3.2 如何规避野指针</h2>
<blockquote>
<ul><li>1. 指针初始化</li><li>2. 小心指针越界</li><li>3. 指针指向空间释放即使置NULL</li><li>4. 避免返回局部变量的地址</li><li>5. 指针使用之前检查有效性</li></ul>
<pre><code>#include &lt;stdio.h&gt;
int main()
{
    int* p = NULL;
    //....
    int a = 10;
    p = &amp;a;
    if (p != NULL)
    {
        *p = 20;
    }
    return 0;
}</code></pre>
</blockquote>
<h1 id="4.%20%E6%8C%87%E9%92%88%E8%BF%90%E7%AE%97">4. 指针运算</h1>
<h2 id="4.1%20%E6%8C%87%E9%92%88%2B-%E6%95%B4%E6%95%B0">4.1 指针+-整数</h2>
<blockquote>
<pre><code>#include&lt;stdio.h&gt;
int main()
{
	int x = 0;
	int* p = &amp;x;
	printf("%p\n", p);
	printf("%p\n", p + 1);
	char* p2 = (char*)&amp;x;
	printf("%p\n", p2);
	printf("%p\n", p2+1);
	return 0;
}</code></pre>
<p><img alt="" height="347" src="image\346f6e2affb74d1f8388c487fbe78358.png" width="521"/></p>
<p> 指针+-整数实际上是跨越指针所指变量类型的字节数乘以我们加的数字，比如在上面的例子中，我们一开始是将整型指针p进行了+1操作，然后我们对p+1进行以地址形式打印后，相比原来的p，增加了4个字节，同理，后面的p2是char类型的指针，我们对其进行+1操作后，相比原来的p2的地址，增加了1个字节。</p>
</blockquote>
<h2 id="4.2%20%E6%8C%87%E9%92%88-%E6%8C%87%E9%92%88">4.2 指针-指针</h2>
<blockquote>
<pre><code>#include&lt;stdio.h&gt;
int main()
{
	int arr[5] = { 1,2,3,4,5 };
	int* p1 = &amp;arr[4];
	int* p2 = &amp;arr[0];
	printf("%d", p1 - p2);
	return 0;
}</code></pre>
<p><img alt="" height="355" src="image\691e371857284f4d84c1d14f8022db39.png" width="1095"/></p>
<p>上面进行相减后得出的结果是4，为什么会得出4这个结果呢？因为p1和p2之间相差4个整型元素，这个地方为什么我们要强调是整形元素呢？因为我们在运算符两侧的指针类型均是整型指针，实际上<strong>指针类型的变量进行相减是指针所代表的地址进行相减，将得出的值除以指针所指向的空间所占据的字节数</strong>，这样将大家不是很容易理解，有一点点抽象，我给大家简单举一下例子，比如在上面这个例子中p1中所存储的地址值是16，而p2中所存储的值是0，那么我们将p2减去p1后得出的16除以p1和p2所指向的数据类型即整型类型，每个整型元素所占据的字节数为4，所以16除以4之后的结果为4，即最终在屏幕上的输出结果为4，那么很多小伙伴就问了，在上面这个例子中，我们将两个指针的类型进行强制转换为char类型后得出的结果是不是就会改变为16了呢，因为根据上面的我给出的推理方式确实应该是这样的，因为char类型占据的字节数为1，16除以1之后的结果仍为16，接下来我们代码展示一下是不是就像我们的推理一样，得出的结果是16.</p>
<p><img alt="" height="350" src="image\e85d77e0eaad4ada920ed5bc5b4828e0.png" width="1037"/></p>
<p> 同我们的推导一样，这就印证了我们的推导是正确的！</p>
</blockquote>
<h2 id="4.3%20%E6%8C%87%E9%92%88%E7%9A%84%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97">4.3 指针的关系运算</h2>
<blockquote>
<p>既然指针变量中所存储的是地址，地址从本质上来说也只是一串数据，那么也是可以进行比较大小的！此处不再进行举例给大家进行展示，因为不难理解，但是下面会给大家进行强调一个要点！</p>
<p>标准规定：</p>
<p><strong>允许指向数组元素的指针与指向数组最后一个元素后面的那个内存位置的指针比较，但是不允许与 指向第一个元素之前的那个内存位置的指针进行比较。</strong></p>
</blockquote>
<h1 id="5.%20%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84">5. 指针和数组</h1>
<blockquote>
<p>我们看一个例子：</p>
<pre><code>#include &lt;stdio.h&gt;
int main()
{
    int arr[10] = { 1,2,3,4,5,6,7,8,9,0 };
    printf("%p\n", arr);
    printf("%p\n", &amp;arr[0]);
    return 0;
}</code></pre>
<p>运行结果：</p>
<p><img alt="" height="153" src="image\0dab8fa4cf2649e8b10e9d8d6550c006.png" width="1026"/></p>
<p>可见数组名和数组首元素的地址是一样的。</p>
<p>结论：<strong>数组名表示的是数组首元素的地址。</strong>（2种情况除外，数组章节讲解了）</p>
<p>那么这样写代码是可行的：</p>
<pre><code>int arr[10] = {1,2,3,4,5,6,7,8,9,0};
int *p = arr;//p存放的是数组首元素的地址</code></pre>
<p>既然可以把数组名当成地址存放到一个指针中，我们使用指针来访问一个就成为可能。</p>
<p>例如：</p>
<pre><code>#include &lt;stdio.h&gt;
int main()
{
    int arr[] = { 1,2,3,4,5,6,7,8,9,0 };
    int* p = arr; //指针存放数组首元素的地址
    int sz = sizeof(arr) / sizeof(arr[0]);
    for (int i = 0; i &lt; sz; i++)
    {
        printf("&amp;arr[%d] = %p   &lt;====&gt; p+%d = %p\n", i, &amp;arr[i], i, p + i);
    }
    return 0;
}</code></pre>
<p><img alt="" height="320" src="image\f60a392f841a4fd3b6e3bfc28dc19ced.png" width="988"/></p>
<p>所以 p+i 其实计算的是数组 arr 下标为i的地址。</p>
<p>那我们就可以直接通过指针来访问数组。</p>
<p>如下：</p>
<pre><code>int main()
{
	int arr[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 };
	int* p = arr; //指针存放数组首元素的地址
	int sz = sizeof(arr) / sizeof(arr[0]);
	int i = 0;
	for (i = 0; i &lt; sz; i++)
	{
		printf("%d ", *(p + i));
	}
	return 0;
}</code></pre>
<p><img alt="" height="381" src="image\b980302ccfb9446d8d3f8cba61753e1d.png" width="768"/></p>
</blockquote>
<h1 id="%C2%A06.%20%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88"> 6. 二级指针</h1>
<blockquote>
<p>指针变量也是变量，是变量就有地址，那指针变量的地址存放在哪里？ 这就是二级指针 。</p>
<p><img alt="" height="296" src="image\225181574b154a1398906a7fb0879ea1.png" width="639"/></p>
<p>对于二级指针的运算有：</p>
<ul><li>*ppa 通过对ppa中的地址进行解引用，这样找到的是 pa ， *ppa 其实访问的就是 pa .</li></ul>
<pre><code>int b = 20;
*ppa = &amp;b;//等价于 pa = &amp;b;</code></pre>
<ul><li>**ppa 先通过 *ppa 找到 pa ,然后对 pa 进行解引用操作： *pa ，那找到的是 a .</li></ul>
<pre><code>**ppa = 30;
//等价于*pa = 30;
//等价于a = 30;
</code></pre>
</blockquote>
<h1 id="7.%20%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84">7. 指针数组</h1>
<blockquote>
<p>指针数组是指针还是数组？</p>
<p>答案：是数组。是存放指针的数组。</p>
<p>数组我们已经知道整形数组，字符数组。</p>
<pre><code>int arr1[5];
char arr2[6];
</code></pre>
<p><img alt="" height="244" src="image\9f2cdd084e8e4ecea2fb06b6e03751a9.png" width="517"/></p>
<p> 那指针数组是怎样的？</p>
<pre><code>int* arr3[5];//是什么？</code></pre>
<p>arr3是一个数组，有五个元素，每个元素是一个整形指针。</p>
<p><img alt="" height="363" src="image\31a1f0face1c44ac829f730e6b0ad1c4.png" width="440"/></p>
</blockquote>
<p></p>
</div>
</div>