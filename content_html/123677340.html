<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<p><strong>        注意：这篇文章很长，学习完后将会解决你对于过滤器(Filter)的所有疑惑，下面将通过理论和代码的结合来进行讲解演示..... </strong></p>
<hr/>
<p> <strong>目录</strong></p>
<p id="%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-toc" style="margin-left:0px;"><a href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D">基本介绍</a></p>
<p id="%E8%BF%87%E6%BB%A4%E5%99%A8%E5%8E%9F%E7%90%86-toc" style="margin-left:40px;"><a href="#%E8%BF%87%E6%BB%A4%E5%99%A8%E5%8E%9F%E7%90%86">过滤器原理</a></p>
<p id="%E8%BF%87%E6%BB%A4%E5%99%A8(Filter)%E6%8E%A5%E5%8F%A3-toc" style="margin-left:40px;"><a href="#%E8%BF%87%E6%BB%A4%E5%99%A8%28Filter%29%E6%8E%A5%E5%8F%A3">过滤器(Filter)接口</a></p>
<p id="%E4%BD%BF%E7%94%A8%E8%BF%87%E6%BB%A4%E5%99%A8(Filter)-toc" style="margin-left:0px;"><a href="#%E4%BD%BF%E7%94%A8%E8%BF%87%E6%BB%A4%E5%99%A8%28Filter%29">使用过滤器(Filter)</a></p>
<p id="%E5%88%9B%E5%BB%BA%E8%BF%87%E6%BB%A4%E5%99%A8(Fliter)-toc" style="margin-left:40px;"><a href="#%E5%88%9B%E5%BB%BA%E8%BF%87%E6%BB%A4%E5%99%A8%28Fliter%29">创建过滤器(Fliter)</a></p>
<p id="%E4%BD%BF%E7%94%A8%E8%BF%87%E6%BB%A4%E5%99%A8(Filter)-toc" style="margin-left:40px;"><a href="#%E4%BD%BF%E7%94%A8%E8%BF%87%E6%BB%A4%E5%99%A8%28Filter%29">使用过滤器(Filter)</a></p>
<p id="%E9%85%8D%E7%BD%AE%E8%BF%87%E6%BB%A4%E5%99%A8(Filter)%E6%8B%A6%E6%88%AA%E8%B7%AF%E5%BE%84%C2%A0-toc" style="margin-left:40px;"><a href="#%E9%85%8D%E7%BD%AE%E8%BF%87%E6%BB%A4%E5%99%A8%28Filter%29%E6%8B%A6%E6%88%AA%E8%B7%AF%E5%BE%84%C2%A0">配置过滤器(Filter)拦截路径 </a></p>
<p id="%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F-toc" style="margin-left:80px;"><a href="#%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F">注解方式</a></p>
<p id="xml%E6%96%B9%E5%BC%8F%C2%A0-toc" style="margin-left:80px;"><a href="#xml%E6%96%B9%E5%BC%8F%C2%A0">xml方式 </a></p>
<p id="%E8%BF%87%E6%BB%A4%E5%99%A8(Filter)%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-toc" style="margin-left:40px;"><a href="#%E8%BF%87%E6%BB%A4%E5%99%A8%28Filter%29%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">过滤器(Filter)生命周期</a></p>
<p id="%E7%90%86%E8%AE%BA%E8%AF%B4%E6%98%8E%C2%A0-toc" style="margin-left:80px;"><a href="#%E7%90%86%E8%AE%BA%E8%AF%B4%E6%98%8E%C2%A0">理论说明 </a></p>
<p id="%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA-toc" style="margin-left:80px;"><a href="#%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA">代码演示</a></p>
<p id="%C2%A0FilterConfig%E5%92%8CFilterChain%E8%AF%B4%E6%98%8E-toc" style="margin-left:0px;"><a href="#%C2%A0FilterConfig%E5%92%8CFilterChain%E8%AF%B4%E6%98%8E">FilterConfig和FilterChain说明</a></p>
<p id="FilterConfig-toc" style="margin-left:40px;"><a href="#FilterConfig">FilterConfig</a></p>
<p id="FilterConfig%E5%AE%9E%E4%BE%8B%E8%BF%90%E7%94%A8-toc" style="margin-left:80px;"><a href="#FilterConfig%E5%AE%9E%E4%BE%8B%E8%BF%90%E7%94%A8">FilterConfig实例运用</a></p>
<p id="FilterChain%C2%A0-toc" style="margin-left:40px;"><a href="#FilterChain%C2%A0">FilterChain </a></p>
<p id="FilterChain%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B-toc" style="margin-left:80px;"><a href="#FilterChain%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B">FilterChain应用实例</a></p>
<p id="%C2%A0%E5%A4%9A%E4%B8%AAFilter%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F-toc" style="margin-left:0px;"><a href="#%C2%A0%E5%A4%9A%E4%B8%AAFilter%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F">多个Filter的执行顺序</a></p>
<p id="%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E9%AA%8C%E8%AF%81-toc" style="margin-left:40px;"><a href="#%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E9%AA%8C%E8%AF%81">执行顺序验证</a></p>
<p id="Filter%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B(%E5%AE%9E%E7%8E%B0%E6%95%8F%E6%84%9F%E8%AF%8D%E6%B1%87%E8%BF%87%E6%BB%A4)%C2%A0-toc" style="margin-left:0px;"><a href="#Filter%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B%28%E5%AE%9E%E7%8E%B0%E6%95%8F%E6%84%9F%E8%AF%8D%E6%B1%87%E8%BF%87%E6%BB%A4%29%C2%A0">Filter应用实例(实现敏感词汇过滤) </a></p>
<p id="%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">代码实现</a></p>
<p id="%E4%BB%A3%E7%A0%81%E9%AA%8C%E8%AF%81-toc" style="margin-left:40px;"><a href="#%E4%BB%A3%E7%A0%81%E9%AA%8C%E8%AF%81">代码验证</a></p>
<p id="%E6%80%BB%E7%BB%93%C2%A0-toc" style="margin-left:0px;"><a href="#%E6%80%BB%E7%BB%93%C2%A0">总结 </a></p>
<hr id="hr-toc"/>
<h1>基本介绍</h1>
<p>        过滤器，顾名思义就是对事物进行过滤的，在Web中的过滤器，当然就是对请求进行过滤，我们使用过滤器，就可以对请求进行拦截，然后做相应的处理，实现许多特殊功能。如登录控制，权限管理，过滤敏感词汇等.</p>
<h2 id="%E8%BF%87%E6%BB%A4%E5%99%A8%E5%8E%9F%E7%90%86">过滤器原理</h2>
<p>        当我们使用过滤器时，过滤器会对游览器的请求进行过滤，过滤器可以动态的分为3个部分，<strong>1.放行之前的代码，2.放行，3.放行后的代码</strong>，这3个部分分别会发挥不同作用。</p>
<ul><li>第一部分代码会对游览器请求进行第一次过滤，然后继续执行</li><li>第二部分代码就是将游览器请求放行，如果还有过滤器，那么就继续交给下一个过滤器</li><li>第三部分代码就是对返回的Web资源再次进行过滤处理</li></ul>
<p>我们使用过滤器，也就是说，不止请求会经过过滤器，我们的响应也会经过过滤器。</p>
<p><img alt="" height="397" src="image\262f1540db18409a80f75ca7814dcdd4.png" width="1200"/></p>
<hr/>
<h2 id="%E8%BF%87%E6%BB%A4%E5%99%A8(Filter)%E6%8E%A5%E5%8F%A3">过滤器(Filter)接口</h2>
<p>        我们学习过滤器，肯定就要先看一下官方给我们提供的过滤器接口。下面我们使用Idea来查看Filter。</p>
<p><img alt="" height="234" src="image\ea00532a13aa4dfc993b4ec9163f7b77.png" width="789"/></p>
<p><img alt="" height="503" src="image\4f6ef2c382aa427ea9e5e707a93114f5.png" width="1200"/></p>
<blockquote>
<p>         我们通过官方提供的过滤器可以看出过滤器(Filter)使用起来还是比较简单的，下面我们就来学习如何使用过滤器(Filter)</p>
</blockquote>
<hr/>
<h1 id="%E4%BD%BF%E7%94%A8%E8%BF%87%E6%BB%A4%E5%99%A8(Filter)">使用过滤器(Filter)</h1>
<p>        我们使用过滤器肯定要导入相应的jar包才行，Filter就在servlet-api.jar中，我们将该jar包放到WEB-INF下的lib目录下面，然后加入项目。</p>
<h2 id="%E5%88%9B%E5%BB%BA%E8%BF%87%E6%BB%A4%E5%99%A8(Fliter)">创建过滤器(Fliter)</h2>
<blockquote>
<p>        我们创建Filter，只需要继承Filter接口就行。</p>
</blockquote>
<pre><code class="language-java">import javax.servlet.*;
import java.io.IOException;

public class MyFilter implements Filter {

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {

    }
}</code></pre>
<blockquote>
<p>         Filter接口有3个方法，但是只有一个方法没有实现，我们只需要实现这个方法就行。我们可以发现，我们实现了一个doFilter方法，这个方法就是我们写过滤代码的地方，具体逻辑就是和上面介绍的过滤器原理一样的。</p>
</blockquote>
<hr/>
<h2>使用过滤器(Filter)</h2>
<p>        我们先来感受一下如何使用过滤器，细节我们后面慢慢说明。我们在上面创建的类中写入以下代码，并且加一个WebFIlter注解</p>
<pre><code class="language-java">import javax.servlet.*;
import javax.servlet.annotation.WebFilter;
import java.io.IOException;

@WebFilter("/*")
public class MyFilter implements Filter {
    
    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        System.out.println("对request进行过滤");
        //下面这行代码就是放行
        filterChain.doFilter(servletRequest,servletResponse);
        System.out.println("对response进行过滤");
    }
}
</code></pre>
<blockquote>
<p>        我简单介绍下上面的代码，WebFilter("/*")表示对所有请求进行过滤,而在doFilter中的放行代码，也就是filterChain.doFilter(servletRequest,servletResponse);这行代码就是对拦截进行放行，细节我们后面讲，现在先怎么理解就行。</p>
<p>        启动服务器，然后我们在游览器中输入<a href="http://localhost:8080/filter/abc" title="http://localhost:8080/filter/abc">http://localhost:8080/filter/abc</a>,注意，filter是我们自己配置的web工程路径，后面的abc随便输入的。我们下面来查看游览器后控制台输出。</p>
</blockquote>
<p><span style="color:#fe2c24;"><strong>游览器输出 </strong></span></p>
<p><img alt="" height="331" src="image\3277fd5f6f9244848719cd87098f7eb8.png" width="960"/></p>
<p><span style="color:#fe2c24;"><strong>控制台输出 </strong></span></p>
<p><img alt="" height="222" src="image\791582cedaa64503b3bc2b2c40b92c2b.png" width="931"/></p>
<blockquote>
<p>      <strong>  现在，我们就已经可以得出两个结论了，过滤器并不会管资源是否存在，而只会对配置的拦截路径进行拦截。拦截不仅会对请求进行拦截，而且还会对相应进行拦截。</strong></p>
</blockquote>
<hr/>
<h2 id="%E9%85%8D%E7%BD%AE%E8%BF%87%E6%BB%A4%E5%99%A8(Filter)%E6%8B%A6%E6%88%AA%E8%B7%AF%E5%BE%84%C2%A0">配置过滤器(Filter)拦截路径 </h2>
<p>        配置Filter的拦截路径有2种方式，一种是注解，一种是xml方式，我们分别进行讲解。</p>
<h3 id="%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F">注解方式</h3>
<p>        我们如果使用注解来进行配置，那么我们就需要使用@WebFilter，我们不说废话，直接看该注解的源码。</p>
<p><img alt="" height="760" src="image\87da91fd12914c8a9caf9a76347d8dc2.png" width="1200"/></p>
<p>        里面的配置项还是有很多的，下面我对常用配置项进行说明：</p>
<ul><li>filterName：该filter的名字</li><li>initParams：初始化参数</li><li>displayName：filter显示名称</li><li>servletNames：指定对哪些servlet进行过滤</li><li> asyncSupported：是否支持异步模式</li><li>urlPatterns：指定拦截路径</li><li>value：指定拦截路径</li></ul>
<blockquote>
<p>  <strong>      注意：urlPatterns和value是一样的。urlPatterns和value只能配置一个，不能两个都配置，两个都配置就会报错。</strong></p>
</blockquote>
<p>        对于使用<strong>@WebFilter</strong>,里面的多个参数用 <strong>,</strong> 进行分隔。 </p>
<p><img alt="" height="114" src="image\8c26291992774eb9b06586851a669648.png" width="747"/></p>
<blockquote>
<p><strong>        说明：如果我们仅仅需要配置一个拦截路径，那么我们可以直接简写@WebLister("拦截路径")，如@WebFilter("/*")就是拦截所有请求。 </strong></p>
</blockquote>
<hr/>
<h3 id="xml%E6%96%B9%E5%BC%8F%C2%A0">xml方式 </h3>
<p>        xml方式可以说是和Servlet使用xml配置方式一样了，这里就不废话，直接配置一个。</p>
<pre><code class="language-XML">    &lt;filter&gt;
        &lt;filter-name&gt;myFilter&lt;/filter-name&gt;
        &lt;filter-class&gt;com.clucky.filter.MyFilter&lt;/filter-class&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;myFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;</code></pre>
<p>        这个就是xml配置方式，只不过把注解换成了xml标签来配置，里面属性都是一样的，这个和Servlet的配置方式基本一样，这里就不再赘述了。</p>
<hr/>
<h2 id="%E8%BF%87%E6%BB%A4%E5%99%A8(Filter)%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">过滤器(Filter)生命周期</h2>
<p>        我们都知道Servlet有一个生命周期，当然Filter也有一个生命周期，下面我们就来探讨一下Filter的生命周期。</p>
<p>        Filter的生命周期和Servlet也十分相似，如果大家对Servlet的生命周期不怎么熟悉，那么可以看一下这篇文章<a class="link-info" href="https://blog.csdn.net/m0_51545690/article/details/123122603" title="Servlet生命周期">Servlet生命周期</a>。</p>
<p>        我们创建一个类，实现Filter的所有方法。</p>
<pre><code class="language-java">import javax.servlet.*;
import java.io.IOException;

public class LifeCycleFilter implements Filter {
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
    }

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
    }

    @Override
    public void destroy() {
    }
}
</code></pre>
<hr/>
<h3 id="%E7%90%86%E8%AE%BA%E8%AF%B4%E6%98%8E%C2%A0">理论说明 </h3>
<p>          Filter有3个阶段，分别是初始化，拦截和过滤，销毁。</p>
<ol><li>初始化阶段：当服务器启动时，我们的服务器(Tomcat)就会读取配置文件，扫描注解，然后来创建我们的Filter。</li><li>拦截和过滤阶段：只要请求资源的路径和拦截的路径相同，那么过滤器就会对请求进行过滤，这个阶段在服务器运行过程中会一直循环。</li><li>销毁阶段：当服务器(Tomcat)关闭时，服务器创建的Filter也会随之销毁。</li></ol>
<hr/>
<h3 id="%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA">代码演示</h3>
<p>        Filter的三个阶段就对应着Filter的3个方法，<strong>init方法会在Filter创建时调用，doFilter方法会在请求和拦截匹配时调用，destroy方法会在Filter销毁时调用</strong>。我们来对这些方法进行编写验证。</p>
<pre><code class="language-java">import javax.servlet.*;
import javax.servlet.annotation.WebFilter;
import java.io.IOException;

@WebFilter("/*")
public class LifeCycleFilter implements Filter {
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        //这个方法就是初始化方法，在Filter创建时调用
        System.out.println("调用了init()方法");
    }

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        //这个方法就是过滤和拦截的方法，当请求和拦截匹配时调用
        System.out.println("调用了doFilter()方法");
    }

    @Override
    public void destroy() {
        //这个方法就是销毁方法，在Filter销毁前调用
        System.out.println("调用了destroy()方法");
    }
}
</code></pre>
<p><span style="color:#fe2c24;"><strong>启动服务器控制台输出</strong></span></p>
<p><img alt="" height="246" src="image\8da213b53eca4fadb28c3ffdbeaff0ea.png" width="1065"/></p>
<p><span style="color:#fe2c24;"><strong>进行拦截时控制台输出 </strong></span></p>
<p><img alt="" height="204" src="image\1ca0557f4f2a4c4dafba191bd3deea46.png" width="862"/></p>
<p><span style="color:#fe2c24;"><strong>关闭服务器控制台输出 </strong></span></p>
<p><img alt="" height="195" src="image\a6f719e15cad4d16bd61e4b6118a35c7.png" width="999"/></p>
<blockquote>
<p>        都和我们预想的一样，到此，我们就成功验证了Filter的生命周期。 </p>
</blockquote>
<hr/>
<h1 id="%C2%A0FilterConfig%E5%92%8CFilterChain%E8%AF%B4%E6%98%8E"> FilterConfig和FilterChain说明</h1>
<p>        FilterConfig和FilterConfig这2个对象是由服务器(Tomcat)在创建和调用Filter对象时所传入的，这2个对象十分有用，FilterConfig对象可以读取我们配置的初始参数，FilterChain可以实现多个Filter之间的连接。</p>
<hr/>
<h2 id="FilterConfig">FilterConfig</h2>
<p>        老规矩，我们要学习一个对象，首先查看类图和源代码</p>
<p><img alt="" height="236" src="image\0bfbeb054f3d4b169542c02efc47fa7e.png" width="927"/></p>
<p><img alt="" height="336" src="image\df2b16781905464e9af681887a03c0e5.png" width="1055"/></p>
<p>        里面的方法就4个，下面我们分别进行讲解</p>
<ul><li>getFilterName()：获取filter的名称</li><li>getServletContext()：获取ServletContext</li><li>getInitparamter(String var1)：获取配置的初始参数的值</li><li>getInitParamterNames()：获取配置的所有参数名称</li></ul>
<hr/>
<h3 id="FilterConfig%E5%AE%9E%E4%BE%8B%E8%BF%90%E7%94%A8">FilterConfig实例运用</h3>
<p>        我们在init方法中使用FilterConfig来读取配置的数据库的信息，然后输出。</p>
<p><span style="color:#fe2c24;"><strong>java代码</strong></span></p>
<pre><code class="language-java">import javax.servlet.*;
import java.io.IOException;
import java.util.Enumeration;

public class MyFilterConfig implements Filter {

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        System.out.println("-----------获取全部key:value------------");
        //得到所有配置参数的名字
        Enumeration&lt;String&gt; names = filterConfig.getInitParameterNames();
        while (names.hasMoreElements()) {
            //得到每一个名字
            String name = names.nextElement();
            System.out.println(name+" = "+filterConfig.getInitParameter(name));
        }
        System.out.println("-----------end.....------------");
    }

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
    }

    @Override
    public void destroy() {
    }
}</code></pre>
<p><span style="color:#fe2c24;"><strong>xml配置 </strong></span></p>
<pre><code class="language-XML">&lt;filter&gt;
        &lt;filter-name&gt;myFilterConfig&lt;/filter-name&gt;
        &lt;filter-class&gt;com.clucky.filter.MyFilterConfig&lt;/filter-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;driver&lt;/param-name&gt;
            &lt;param-value&gt;com.mysql.jdbc.Driver&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;url&lt;/param-name&gt;
            &lt;param-value&gt;jdbc:mysql://localhost:3306/equip_employ_manage?serverTimezone=GMT&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;username&lt;/param-name&gt;
            &lt;param-value&gt;root&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;password&lt;/param-name&gt;
            &lt;param-value&gt;root&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;myFilterConfig&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;</code></pre>
<p><span style="color:#fe2c24;"><strong>启动服务器，控制台输出</strong></span></p>
<p><img alt="" height="301" src="image\1ddf1358932b4939ae445a5ef460e367.png" width="1088"/></p>
<blockquote>
<p>         我们使用FilterConfig提供的方法就成功实现了功能，FilterConfig就是用来读取配置文件的。</p>
</blockquote>
<hr/>
<h2 id="FilterChain%C2%A0">FilterChain </h2>
<p>        一样，我们还是先来查看源代码以及类图</p>
<p><img alt="" height="157" src="image\cf9032f97774432e8bc3df5f8d622bc7.png" width="710"/></p>
<p><img alt="" height="278" src="image\9f15c2cebc794f10bdc4a68ed9f4e84a.png" width="1200"/></p>
<blockquote>
<p>         我们查看类图，可以发现FilterChain就只有一个方法，其实这个方法就是用来对拦截进行放行的，如果有多个拦截器，那么就会继续调用下一个Filter进行拦截。doFilter方法需要传入个参数，一个是ServletRequest，一个是ServletResponse参数，这个直接传入进行。</p>
<p>        Tomcat在调用过滤器时，默认就会传入Request和Response，这个参数封装了请求和响应，我们直接使用就行。ServletResquest和ServletResponse可以直接强转成HttpServletRequest和HttpServletResponse，然后使用相应的方法。</p>
</blockquote>
<p> <span style="color:#fe2c24;"><strong>将ServletRequest转成HttpServletRequest</strong></span><img alt="" height="188" src="image\7d1ae684b49b4e5d8ffdd981a3af05f4.png" width="1055"/></p>
<hr/>
<h3 id="FilterChain%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B">FilterChain应用实例</h3>
<p>        我们前面一直都是一个Filter，现在我们来配置2个Filter，通过FilterChain来进行多个过滤。</p>
<p><span style="color:#fe2c24;"><strong>第一个Filter</strong></span></p>
<pre><code class="language-java">import javax.servlet.*;
import javax.servlet.annotation.WebFilter;
import java.io.IOException;

@WebFilter("/*")
public class Filter01 implements Filter {

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
    }

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        System.out.println("调用过滤器01对请求进行过滤~~~~");
        //放行,如果还有过滤器，那么就执行下一个过滤器
        filterChain.doFilter(servletRequest,servletResponse);
        System.out.println("调用过滤器01对响应进行过滤~~~~");
    }

    @Override
    public void destroy() {
    }
}</code></pre>
<p><span style="color:#fe2c24;"><strong>第二个过滤器</strong></span></p>
<pre><code class="language-java">import javax.servlet.*;
import javax.servlet.annotation.WebFilter;
import java.io.IOException;

@WebFilter("/*")
public class Filter02 implements Filter {
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
    }

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        System.out.println("调用过滤器02对请求进行过滤~~~~");
        //放行,如果还有过滤器，那么就执行下一个过滤器
        filterChain.doFilter(servletRequest,servletResponse);
        System.out.println("调用过滤器02对响应进行过滤~~~~");
    }

    @Override
    public void destroy() {
    }
}</code></pre>
<blockquote>
<p>        启动服务器，然后我们游览器输入<a href="http://localhost:8080/filter/abc" title="http://localhost:8080/filter/abc">http://localhost:8080/filter/abc</a>（filter是我配置的web工程路径）来进行访问，查看控制台输出。</p>
</blockquote>
<p><img alt="" height="254" src="image\6191f4d070e64fd9a324d63a40c8cfd1.png" width="886"/></p>
<blockquote>
<p>         我们可以看见Filter01先进行过滤，然后交给Filter02，然后访问资源，然后Filter02对响应进行过滤，然后Filter01对响应进行过滤。图示如下：</p>
</blockquote>
<p><img alt="" height="495" src="image\345bdecae07b4944afd20c202e8ef77b.png" width="1171"/></p>
<blockquote>
<p>        我们先使用Filter01对请求进行过滤，那么很自然的，我们就是使用Filter02先对响应进行过滤。 </p>
</blockquote>
<hr/>
<h1 id="%C2%A0%E5%A4%9A%E4%B8%AAFilter%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"> 多个Filter的执行顺序</h1>
<p>        上面我们配置了2个过滤器，那么我们怎么知道那个过滤器先执行呢？其实大家可以直接使用代码进行验证，培养独立思考的习惯，这里我就直接给出答案了。</p>
<ul><li>如果我们是在web.xml中配置的过滤器，那么过滤器的执行顺序就是&lt;filter-mapping&gt;在web配置的顺序，配置在上面那么就会先执行。</li><li>如果我们是使用@WebFilter进行配置的，那么执行顺序就是字符比较顺序来执行，例如有2个过滤器，一个是AFilter，一个是BFilter，那么AFilter就会先执行。</li><li>如果注解和xml混用，那么在web.xml中配置的会先执行。</li></ul>
<h2 id="%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E9%AA%8C%E8%AF%81">执行顺序验证</h2>
<p>        我这里就验证第一条，也就是web.xml中配置的顺序和&lt;filter-mapping&gt;顺序一样，其他大家感兴趣自己验证。</p>
<p><span style="color:#fe2c24;"><strong>xml配置顺序 3-&gt;1-&gt;2</strong></span></p>
<pre><code class="language-XML">    &lt;filter&gt;
        &lt;filter-name&gt;filter03&lt;/filter-name&gt;
        &lt;filter-class&gt;com.clucky.filter.Filter03&lt;/filter-class&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;filter03&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
    &lt;filter&gt;
        &lt;filter-name&gt;filter01&lt;/filter-name&gt;
        &lt;filter-class&gt;com.clucky.filter.Filter01&lt;/filter-class&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;filter01&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
    &lt;filter&gt;
        &lt;filter-name&gt;filter02&lt;/filter-name&gt;
        &lt;filter-class&gt;com.clucky.filter.Filter02&lt;/filter-class&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;filter02&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;</code></pre>
<p><span style="color:#fe2c24;"><strong>Filter01</strong></span></p>
<pre><code class="language-java">import javax.servlet.*;
import java.io.IOException;

public class Filter01 implements Filter {

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
    }

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        System.out.println("调用过滤器01对请求进行过滤~~~~");
        //放行,如果还有过滤器，那么就执行下一个过滤器
        filterChain.doFilter(servletRequest,servletResponse);
        System.out.println("调用过滤器01对响应进行过滤~~~~");
    }

    @Override
    public void destroy() {
    }
}</code></pre>
<p><span style="color:#fe2c24;"><strong>Filter02</strong></span></p>
<pre><code class="language-java">import javax.servlet.*;
import java.io.IOException;

public class Filter02 implements Filter {
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
    }

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        System.out.println("调用过滤器02对请求进行过滤~~~~");
        //放行,如果还有过滤器，那么就执行下一个过滤器
        filterChain.doFilter(servletRequest,servletResponse);
        System.out.println("调用过滤器02对响应进行过滤~~~~");
    }

    @Override
    public void destroy() {
    }
}</code></pre>
<p><span style="color:#fe2c24;"><strong>Filter03</strong></span></p>
<pre><code class="language-java">import javax.servlet.*;
import java.io.IOException;

public class Filter03 implements Filter{
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
    }

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        System.out.println("调用过滤器03对请求进行过滤~~~~");
        //放行,如果还有过滤器，那么就执行下一个过滤器
        filterChain.doFilter(servletRequest,servletResponse);
        System.out.println("调用过滤器03对响应进行过滤~~~~");
    }

    @Override
    public void destroy() {
    }
}
</code></pre>
<blockquote>
<p>        我们启动服务器，游览器访问，然后查看控制台输出是不是我们配置的3-&gt;1-&gt;2的顺序</p>
</blockquote>
<p><img alt="" height="280" src="image\b4c3b3b44fb34fd883950008b3b7d904.png" width="932"/></p>
<blockquote>
<p>         发现执行顺序果然是这样，另外2个的验证大家感兴趣可以自己验证，我这里就不验证了，如果嫌麻烦，那么记住就行了。</p>
</blockquote>
<hr/>
<h1 id="Filter%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B(%E5%AE%9E%E7%8E%B0%E6%95%8F%E6%84%9F%E8%AF%8D%E6%B1%87%E8%BF%87%E6%BB%A4)%C2%A0">Filter应用实例(实现敏感词汇过滤) </h1>
<p>        我们学了那么多，现在来做一个实例，我们写一个评论页面，可以进行评论，如果评论中含有我们定义的敏感词汇，那么我们就进行过滤，使用**来进行代替。</p>
<h2 id="%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">代码实现</h2>
<p><span style="color:#fe2c24;"><strong>jsp页面</strong></span></p>
<pre><code class="language-html">&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;评论&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;输入评论内容&lt;/h1&gt;
&lt;form action="${pageContext.request.contextPath}/comment" method="post"&gt;
    &lt;textarea name="message" cols="30" rows="10"&gt;&lt;/textarea&gt;
    &lt;input type="submit" value="提交"&gt;
&lt;/form&gt;
&lt;p &gt;${requestScope.get("name")}&lt;span style="color: red"&gt;${requestScope.get("comment")}&lt;/span&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p><span style="color:#fe2c24;"><strong>Filter代码</strong></span></p>
<pre><code class="language-java">import javax.servlet.*;
import javax.servlet.annotation.WebFilter;
import javax.servlet.annotation.WebInitParam;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

@WebFilter(servletNames = {"comment"},initParams = {@WebInitParam(name = "sensitiveWord", value = "zz")})
public class CommentFilter implements Filter {

    private List&lt;String&gt; sensitiveWords = new ArrayList&lt;&gt;();
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        //得到敏感词汇
        String word = filterConfig.getInitParameter("sensitiveWord");
        //加入集合
        sensitiveWords.add(word);
    }

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        //设置编码
        servletRequest.setCharacterEncoding("utf-8");
        servletResponse.setContentType("text/html;charset=utf-8");
        //得到评论
        String message = servletRequest.getParameter("message");
        for (String sensitiveWord : sensitiveWords) {
            //对所有敏感词汇进行过滤
            if (message.contains(sensitiveWord)){
                //替换敏感词汇
                message = message.replace(sensitiveWord, "**");
            }
        }
        //存入request域
        servletRequest.setAttribute("comment",message);
        //放行
        filterChain.doFilter(servletRequest,servletResponse);
    }

    @Override
    public void destroy() {
    }
}
</code></pre>
<p><span style="color:#fe2c24;"><strong>Servlet代码</strong></span></p>
<pre><code class="language-java">import javax.servlet.*;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.*;
import java.io.IOException;
import java.util.HashSet;

@WebServlet(name = "comment",value = "/comment")
public class CommentServlet extends HttpServlet {

    //记录评论敏感词汇的ip
    private HashSet&lt;String&gt; hashSet = new HashSet&lt;&gt;();

    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        String message = request.getParameter("message");
        String comment = (String) request.getAttribute("comment");
        if (message.equals(comment)){
            System.out.println("没有敏感词汇.....");
            //设置名字
            request.setAttribute("name","good boy：");
        }else {
            //有敏感词汇，记录IP
            String localAddr = request.getLocalAddr();
            System.out.println(localAddr);
            hashSet.add(localAddr);
            //设置名字
            request.setAttribute("name","bad boy：");
        }
        //转发到comment.jsp页面
        request.getRequestDispatcher("/comment.jsp").forward(request,response);
    }

    @Override
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        this.doGet(request, response);
    }
}
</code></pre>
<hr/>
<h2 id="%E4%BB%A3%E7%A0%81%E9%AA%8C%E8%AF%81">代码验证</h2>
<blockquote>
<p>        我们输入<a href="http://localhost:8080/filter/comment.jsp" title="http://localhost:8080/filter/comment.jsp">http://localhost:8080/filter/comment.jsp</a>，来访问jsp页面.</p>
</blockquote>
<p><img alt="" height="379" src="image\5626704aa5764843b78f99161368dfe1.png" width="959"/></p>
<blockquote>
<p>         输入评论内容：你好啊！！!</p>
</blockquote>
<p><img alt="" height="474" src="image\cf26e9b1fd7540cf894779c4a07bcdd3.png" width="1061"/></p>
<blockquote>
<p>         下面显示了我们的评论，我们再来输入：你真是个zz</p>
</blockquote>
<p><img alt="" height="455" src="image\ed131f4ca3ea437585b0511adbba8249.png" width="1047"/></p>
<blockquote>
<p>         显示你真是个**，我们的评论过滤就成功了。</p>
</blockquote>
<hr/>
<h1 id="%E6%80%BB%E7%BB%93%C2%A0">总结 </h1>
<p><strong>        通过上面的学习，相信大家对Filter的掌握肯定也上了一个台阶，但是理论知识的掌握并不能代码大家已经真正学会了，打开编译器，开始练习吧，技术就就是靠一行行代码堆起来的！！！</strong></p>
<p>      <strong>  如果觉得讲的还不错，那么就点赞评论支持一下吧 </strong></p>
</div>
</div>