<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<h2>一、js中blob对象介绍</h2>
<p><code>Blob</code><strong> </strong>对象表示一个不可变、原始数据的类文件对象。它的数据可以按文本或二进制的格式进行读取，也可以转换成 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ReadableStream" title="ReadableStream">ReadableStream</a> 来用于数据操作。 </p>
<p>Blob 表示的不一定是 JavaScript 原生格式的数据。File 接口基于<code>Blob</code>，继承了 blob 的功能并将其扩展使其支持用户系统上的文件。</p>
<p>要从其他非 blob 对象和数据构造一个 <code>Blob</code>，请使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/Blob" title="Blob()">Blob()</a> 构造函数。要创建一个 blob 数据的子集 blob，请使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/slice" title="slice()">slice()</a> 方法。要获取用户文件系统上的文件对应的 <code>Blob</code> 对象，请参阅 File 文档。</p>
<p>接受 <code>Blob</code> 对象的 API 也被列在 File 文档中。</p>
<p><strong>注意：</strong><code>slice()</code> 方法原本接受 <code>length</code> 作为第二个参数，以表示复制到新 <code>Blob</code> 对象的字节数。如果设置的参数使 <code>start + length</code> 超出了源 <code>Blob</code> 对象的大小，则返回从开始到结尾的所有数据。</p>
<p><strong>注意：</strong><code>slice()</code> 方法在某些浏览器和版本上带有浏览器引擎前缀：比如 Firefox 12 及更早版本的<code>blob.mozSlice()</code> 和 Safari 中的<code>blob.webkitSlice()</code>。没有浏览器引擎前缀的老版本 <code>slice()</code> 方法有不同的语义，并且已过时。Firefox 30 取消了对 <code>blob.mozSlice()</code> 的支持。</p>
<h3 id="构造函数">构造函数</h3>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/Blob" title="Blob(blobParts[, options])">Blob(blobParts[, options])</a></p>
<pre>标准语法：var aBlob = new Blob(<em> array</em>, <em>options</em> );
</pre>
<ul><li><em>array</em> 是一个由<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer" title="ArrayBuffer">ArrayBuffer</a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypedArray" title="ArrayBufferView">ArrayBufferView</a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob" title="Blob">Blob</a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DOMString" title="DOMString">DOMString</a> 等对象构成的 Array，或者其他类似对象的混合体，它将会被放进 Blob。DOMStrings 会被编码为 UTF-8。</li><li><em>option</em><em>s</em> 是一个可选的<code>BlobPropertyBag</code>字典，它可能会指定如下两个属性： 
  <ul><li><code>type</code>，默认值为 <code>""</code>，它代表了将会被放入到 blob 中的数组内容的 MIME 类型。</li><li><code>endings</code>，默认值为<code>"transparent"</code>，用于指定包含行结束符<code>\n</code>的字符串如何被写入。 它是以下两个值中的一个： <code>"native"</code>，代表行结束符会被更改为适合宿主操作系统文件系统的换行符，或者 <code>"transparent"</code>，代表会保持 blob 中保存的结束符不变</li></ul></li></ul>
<p>返回一个新创建的 <code>Blob</code> 对象，其内容由参数中给定的数组串联组成。</p>
<h3 id="属性">属性</h3>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/size" title="Blob.size">Blob.size</a> 只读</p>
<p><code>Blob</code> 对象中所包含数据的大小（字节）。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/type" title="Blob.type">Blob.type</a> 只读</p>
<p>一个字符串，表明该 <code>Blob</code> 对象所包含数据的 MIME 类型。如果类型未知，则该值为空字符串。</p>
<h3 id="方法">方法</h3>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/slice" title="Blob.slice([start[, end[, contentType]]])">Blob.slice([start[, end[, contentType]]])</a></p>
<p>返回一个新的 <code>Blob</code> 对象，包含了源 <code>Blob</code> 对象中指定范围内的数据。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/stream" title="Blob.stream()">Blob.stream()</a></p>
<p>返回一个能读取 blob 内容的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ReadableStream" title="ReadableStream">ReadableStream</a>。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/text" title="Blob.text()">Blob.text()</a></p>
<p>返回一个 promise 且包含 blob 所有内容的 UTF-8 格式的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/USVString" title="USVString">USVString</a>。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/arrayBuffer" title="Blob.arrayBuffer()">Blob.arrayBuffer()</a></p>
<p>返回一个 promise 且包含 blob 所有内容的二进制格式的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer" title="ArrayBuffer">ArrayBuffer</a> </p>
<h3 id="blob_构造函数用法举例">Blob 构造函数用法举例</h3>
<p>Blob 构造函数允许通过其它对象创建 Blob 对象。比如，用字符串构建一个 blob：</p>
<pre><code>var debug = {hello: "world"};
var blob = new Blob([JSON.stringify(debug, null, 2)], {type : 'application/json'});</code></pre>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/BlobBuilder" title="BlobBuilder">BlobBuilder</a> 接口提供了另外一种创建<code>Blob</code> 对象的方式，但该方式现在已经废弃，不应继续使用：</p>
<pre><code>var builder = new BlobBuilder();
var fileParts = ['&lt;a id="a"&gt;&lt;b id="b"&gt;hey!&lt;/b&gt;&lt;/a&gt;'];
builder.append(fileParts[0]);
var myBlob = builder.getBlob('text/xml');
</code></pre>
<h3><strong>使用 Blob 创建一个指向类型化数组的 URL</strong></h3>
<h3 id="示例：使用_blob_创建一个指向类型化数组的url"></h3>
<p>参考下面的代码：</p>
<pre><code>var typedArray = GetTheTypedArraySomehow();
var blob = new Blob([typedArray.buffer], {type: 'application/octet-stream'}); // 传入一个合适的 MIME 类型
var url = URL.createObjectURL(blob);
// 会产生一个类似 blob:d3958f5c-0777-0845-9dcf-2cb28783acaf 这样的 URL 字符串
// 你可以像使用普通 URL 那样使用它，比如用在 img.src 上。
</code></pre>
<h3 id="示例：从_blob_中提取数据"><strong>从 Blob 中提取数据</strong></h3>
<p>一种从 Blob 中读取内容的方法是使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader" title="FileReader">FileReader</a>。以下代码将 Blob 的内容作为类型数组读取：</p>
<pre><code>var reader = new FileReader();
reader.addEventListener("loadend", function() {
   // reader.result 包含被转化为类型数组 typed array 的 blob
});
reader.readAsArrayBuffer(blob);</code></pre>
<p>另一种读取 Blob 中内容的方式是使用 Response 对象。下述代码将 Blob 中的内容读取为文本：</p>
<pre><code>var text = await (new Response(blob)).text();
</code></pre>
<p>通过使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader" title="FileReader">FileReader</a> 的其它方法可以把 Blob 读取为字符串或者数据 URL</p>
<p></p>
<h2> 二、php+js 实现切片上传</h2>
<p>前端代码（upload.html）：</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
	&lt;title&gt;&lt;/title&gt;
&lt;/head&gt;
&lt;meta http-equiv="content-type" content="text/html; charset=utf-8"&gt;
&lt;body&gt;
&lt;input type="file" id="file" name="file"&gt;
&lt;button&gt;切片上传&lt;/button&gt;
&lt;/body&gt;
&lt;script type="text/javascript" src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"&gt;&lt;/script&gt;
    &lt;script&gt;
    $("button").click(function(){
    	var cur_time = new Date(); //开始执行时间
    	var BYTES_PER_CHUNK = 1024 * 1024; // 每个文件切片大小定为1MB .
		var file = document.getElementById("file").files[0];
		var file_info = document.getElementById("file").value;
		var file_info_arr = file_info.split("\\");
		var file_name = file_info_arr[file_info_arr.length-1];

		var start = 0;
		var blobs = [];
		var file_num = Math.ceil(file.size / BYTES_PER_CHUNK);

		for (var i = 0; i &lt; file_num; i++) {
		    var end = start + BYTES_PER_CHUNK;
		    blobs[i] = file.slice(start, end);
		    start = end;
	   }
		console.log(file_num)
		$.each(blobs, function(key, value){
			console.log(key);

			var fd = new FormData();
			fd.append('file_num', file_num); //切片总数
			fd.append('index', key+1); //切片份数
 			fd.append('file', value); //切片分成的blob对象
			fd.append('file_name', file_name); //文件名称
			$.ajax({
                type: 'POST',
				url: './upload.php',
				data: fd,
				processData: false,
				contentType: false,
                dataType: "json",   // 预期返回一个 json 类型数据
                success: function (data) {   // data是形参名，代表返回的数据
                    console.log(data.code);

					if(data.code == 1){
						var old_time = new Date();
						var difftime = (old_time - cur_time) / 1000; //秒
						alert('文件上传完成，使用时间 '+difftime+'s');
					}
                }
            });
		})
    })

    &lt;/script&gt;

    &lt;script type="text/javascript"&gt;
    	

    &lt;/script&gt;

&lt;/html&gt;</code></pre>
<p>后端代码（upload.php）：</p>
<pre><code>&lt;?php
header('content-type:text/html;charset=utf-8');
ini_set('memory_limit', -1);
ini_set('max_execution_time', 0);


$file = $_FILES['file'];
$data = $_POST;

$index = $data['index'];
$file_num = $data['file_num'];
$file_name = $data['file_name'];

$file_path = './file/';

//判断切片份数与切片总数相等后，将切片生成上传文件
if($index != $file_num){
	move_uploaded_file($file['tmp_name'], $file_path.$file_name.'_'.$index);
	echo json_encode(['code'=&gt;2, 'msg'=&gt;'切片上传成功']);
	exit;
}else{
	move_uploaded_file($file['tmp_name'], $file_path.$file_name.'_'.$index);

	$newData = '';
	for($i=1; $i&lt;=$file_num; $i++){
		$newData .= file_get_contents($file_path.$file_name.'_'.$i);
		unlink($file_path.$file_name.'_'.$i);
	}
	file_put_contents($file_path.$file_name, $newData);
	echo json_encode(['code'=&gt;1, 'msg'=&gt;'切片全部上传完毕，并生成文件']);
	exit;
}</code></pre>
<p></p>
</div>
</div>