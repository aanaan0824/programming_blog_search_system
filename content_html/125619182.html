<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<p id="main-toc"><strong>目录</strong></p>
<p id="%E5%9F%BA%E6%9C%AC%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-toc" style="margin-left:80px;"><a href="#%E5%9F%BA%E6%9C%AC%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F">1、基本成员变量</a></p>
<p id="%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0">2、默认成员函数</a></p>
<p id="%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">        构造函数</a></p>
<p id="%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0">        析构函数</a></p>
<p id="%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%88%E6%B7%B1%E6%8B%B7%E8%B4%9D%EF%BC%89-toc" style="margin-left:80px;"><a href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%88%E6%B7%B1%E6%8B%B7%E8%B4%9D%EF%BC%89">        拷贝构造函数（深拷贝）</a></p>
<p id="%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD-toc" style="margin-left:80px;"><a href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">        赋值运算符重载（深拷贝）</a></p>
<p id="%E5%AE%B9%E9%87%8F%E4%B8%8E%E5%A4%A7%E5%B0%8F%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#%E5%AE%B9%E9%87%8F%E4%B8%8E%E5%A4%A7%E5%B0%8F%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0">3、容量与大小相关函数</a></p>
<p id="size-toc" style="margin-left:80px;"><a href="#size">        size</a></p>
<p id="capacity-toc" style="margin-left:80px;"><a href="#capacity">        capacity</a></p>
<p id="%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0">4、字符串访问相关函数</a></p>
<p id="%E5%A2%9E%E5%8A%A0-toc" style="margin-left:80px;"><a href="#%E5%A2%9E%E5%8A%A0">        operator[ ]重载</a></p>
<p id="11-toc" style="margin-left:80px;"><a href="#11">        迭代器</a></p>
<p id="22-toc" style="margin-left:80px;"><a href="#22">5、增加的相关函数接口</a></p>
<p id="33-toc" style="margin-left:80px;"><a href="#33">        reserve扩容</a></p>
<p id="44-toc" style="margin-left:80px;"><a href="#44">        resize</a></p>
<p id="%E5%88%A0%E9%99%A4-toc" style="margin-left:80px;"><a href="#%E5%88%A0%E9%99%A4">        push_back追加字符</a></p>
<p id="11-toc" style="margin-left:80px;"><a href="#11">        append追加字符串</a></p>
<p id="22-toc" style="margin-left:80px;"><a href="#22">        operator+=</a></p>
<p id="33-toc" style="margin-left:80px;"><a href="#33">        insert</a></p>
<p id="44-toc" style="margin-left:80px;"><a href="#44">6、删除的相关函数接口</a></p>
<p id="%E6%9F%A5%E6%89%BE-toc" style="margin-left:80px;"><a href="#%E6%9F%A5%E6%89%BE">        erase</a></p>
<p id="11-toc" style="margin-left:80px;"><a href="#11">        clear清空数据</a></p>
<p id="22-toc" style="margin-left:80px;"><a href="#22">7、查找的相关函数接口</a></p>
<p id="33-toc" style="margin-left:80px;"><a href="#33">        find</a></p>
<p id="11-toc" style="margin-left:80px;"><a href="#11">8、c_str获取字符串</a></p>
<p id="22-toc" style="margin-left:80px;"><a href="#22">9、swap交换函数</a></p>
<p id="33-toc" style="margin-left:80px;"><a href="#33">10、非成员函数</a></p>
<p id="%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD-toc" style="margin-left:80px;"><a href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD">        关系运算符函数重载</a></p>
<p id="%E6%BA%90%E7%A0%81%E6%B1%87%E6%80%BB-toc" style="margin-left:80px;"><a href="#%E6%BA%90%E7%A0%81%E6%B1%87%E6%80%BB">        &lt;&lt;流插入运算符重载</a></p>
<p id="%3E%3E%E5%92%8C%3C%3C%E9%87%8D%E8%BD%BD-toc" style="margin-left:80px;"><a href="#%3E%3E%E5%92%8C%3C%3C%E9%87%8D%E8%BD%BD">        &gt;&gt;流提取运算符重载</a></p>
<p id="getline%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#getline%E5%87%BD%E6%95%B0">        getline函数</a></p>
<p id="%E6%80%BB%E8%A7%88-toc" style="margin-left:80px;"><a href="#%E6%80%BB%E8%A7%88">11、源码链接</a></p>
<hr/>
<h3>1、基本成员变量</h3>
<blockquote>
<pre><code class="language-cpp">namespace cpp
{
    //使用命名空间防止定义的string类与库里的string类冲突
	class string
	{
	public:
	//……
	private:
		char* _str;       //存储字符串
		size_t _size;	  //有效字符个数
		size_t _capacity; //实际存储有效字符的空间，不包含'\0'
        const static size_t npos;
	};
    const size_t string::npos = -1;
}</code></pre>
</blockquote>
<hr/>
<h3 id="%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0">2、默认成员函数</h3>
<h3 id="%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">构造函数</h3>
<blockquote>
<p>这里的构造函数最好写成全缺省函数，与标准库里的构造函数相一致</p>
<pre><code class="language-cpp">//全缺省的默认构造函数
string(const char* str = "")//标准库里string定义对象的默认值为空串""
	//按声明的顺序进行初始化
	:_size(strlen(str))
	, _capacity(_size)
{
	_str = new char[_capacity + 1];//在堆上为_str开空间，+1是给'\0'留的
	strcpy(_str, str);//把常量字符串的内容拷贝过去
}</code></pre>
</blockquote>
<hr/>
<h3 id="%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0">析构函数</h3>
<blockquote>
<p>这里string类里的_str是动态开辟建立在堆中的，堆区的空间不能自动销毁因此需要我们手动去销毁。</p>
<pre><code class="language-cpp">//析构函数
~string()
{
	if (_str)
	{
		delete[] _str;
		_str = nullptr;
		_size = _capacity = 0;
	}
}</code></pre>
</blockquote>
<hr/>
<h3 id="%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%88%E6%B7%B1%E6%8B%B7%E8%B4%9D%EF%BC%89">拷贝构造函数（深拷贝）</h3>
<blockquote>
<p>首先，我们不写，编译器会默认生成一个拷贝构造函数，不过是<span style="color:#956fe7;">值拷贝或者浅拷贝</span>，按字节拷贝的。</p>
<p><img alt="" height="163" src="image\ea348e15c61d4e93880b650165b0eff4.png" width="583"/></p>
<p>浅拷贝针对于日期类这种是非常适合的，不过对于string类这样_str是动态开辟到堆上的，如果使用<span style="color:#956fe7;">值拷贝会导致</span><span style="color:#0d0016;">1、</span><span style="color:#956fe7;">析构两次</span><span style="color:#0d0016;"> 2、</span><span style="color:#956fe7;">一个对象修改会影响另外一个</span>。因此我们需要写深拷贝。</p>
<p>深拷贝的核心要点在于<span style="color:#fe2c24;">我和你的有一样的值，但是使用的不是同一块空间</span>。</p>
<p><img alt="" height="127" src="image\6fe2c4bdfd95478dafa8b79cef7b98ce.png" width="561"/></p>
<p>深拷贝有两种写法：传统写法和现代写法。</p>
<ul><li><span style="background-color:#fbd4d0;">1、传统写法：</span></li></ul>
<p>传统写法就是先开辟一块能够容纳原字符串大小的空间，最后把拷贝的对象的字符串数据拷贝到新开的空间里头即可。</p>
<pre><code class="language-cpp">//拷贝构造函数
//不能用浅拷贝，原因如下：1、析构两次 2、一个对象修改会影响另外一个
//传统写法
//s2(s1);
string(const string&amp; s)
	:_size(strlen(s._str))
	,_capacity(_size)
{
	_str = new char[_capacity + 1];
	strcpy(_str, s._str);
}</code></pre>
<ul><li><span style="background-color:#fbd4d0;">2、现代方法：</span></li></ul>
<p>传统写法是本分的自己开空间，然后再拷贝数据，而现代方法就是剥削，要完成深拷贝，自己不想干活就安排别人干活，然后窃取别人的劳动成果。</p>
<p>假如我拿s1去拷贝s2，现代方法就是我<span style="color:#956fe7;">设定了一个tmp对象，拿s1._str的字符串作为参数去给tmp对象完成构造函数，再利用swap函数把tmp对象的_str、_size、_capacity全部与s1的交换即可完成现代方法的深拷贝</span>。但是在这之前注意把s1的数据置空，避免交换后tmp调用析构函数出现析构随机值的错误现象。</p>
<pre><code class="language-cpp">/*现代写法*/
string(const string&amp; s)
	:_str(nullptr)
	, _size(0)
	, _capacity(0)
{
	string tmp(s._str);//调用构造函数，构造一个字符串作为s.c_str的对象
	swap(tmp);
}</code></pre>
</blockquote>
<hr/>
<h3 id="%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">赋值运算符重载</h3>
<blockquote>
<p>这里和上述拷贝构造函数一样，我们不写编译器会自动生成，不过对于string类的_str来说，在堆上申请的空间需要自己去释放，否则会导致同一块空间析构两次。此深拷贝依旧有传统写法和现代写法。</p>
<ul><li><span style="background-color:#fbd4d0;">思路：</span></li></ul>
<p>如若我把s3赋值给s1，这里不能直接进行赋值。要考虑两个问题。</p>
<ol><li>如若我<span style="color:#ff9900;">s1的空间小于s3</span>，此时直接拷贝过去会导致<span style="color:#ff9900;">越界</span>。</li><li>如若我<span style="color:#956fe7;">s1的空间过分大于s3的空间</span>，又会导致直接拷贝后<span style="color:#956fe7;">空间过渡浪费</span>。只有在我s1和s3的空间差不多大时，才可以直接进行拷贝。</li></ol>
<p><span style="color:#0d0016;"><strong>综上：</strong></span>先把s1原先指向的空间delete释放掉，再把s1重新开辟和s3一样大的空间，记得多开一个字节，因为还有'\0'。再利用strcpy把s3的内容拷贝给s1即可。不过要避免一种特殊情况：<span style="color:#956fe7;">自己给自己赋值</span>，如若自己赋值给自己，直接返回，所以加个if条件判断即可。</p>
<p>如果我new开空间失败了，那么就要抛异常，而先前我依旧释放了s1，此时就把s1给破坏了。为了避免这一点，我们可以<span style="color:#956fe7;">先开空间再拷贝数据最后再释放</span>从而进行优化，具体见下文。</p>
<ul><li><span style="background-color:#fbd4d0;">1、传统写法：</span></li></ul>
<pre><code class="language-cpp">//赋值运算符重载 --&gt; 深拷贝
//s1 = s3  s1.operator=(&amp;s1, s3);
string&amp; operator=(const string&amp; s)
{
	//防止自己给自己赋值
	if (this != &amp;s)
	{
	/*	
//法一：
		//先删除原先s1的所有空间，防止赋值后s1过大导致空间浪费，s1过小导致空间不够
		delete[] _str;
		//给s1开辟与s3等价的空间大小，要多开一字节给'\0'
		_str = new char[strlen(s._str) + 1];
		strcpy(_str, s._str);
	*/
//法二优化
        //先开辟空间
		char* tmp = new char[s._capacity + 1];
		strcpy(tmp, s._str);
		delete[] _str;
		_str = tmp;
		_size = s._size;
		_capacity = s._capacity;
	}
	return *this;
}</code></pre>
<p>C语言的动态开辟内存malloc需要检查合法性，而C++的new不需要，new失败的话需要抛异常捕获：</p>
<pre><code class="language-cpp">int main()
{
	try
	{
		//C++new失败要抛异常捕获
		//test_string1();
		test_string2();
	}
	catch (const exception&amp; e)
	{
		cout &lt;&lt; e.what() &lt;&lt; endl;
	}
	return 0;
}</code></pre>
<ul><li><span style="color:#0d0016;"><span style="background-color:#fbd4d0;">2、现代写法：</span></span></li></ul>
<p>这里的现代方法和上文拷贝构造的现代方法没两样，只不过多了个返回值。具体操作如下：</p>
<pre><code class="language-cpp">//现代写法1：
string&amp; operator=(const string&amp; s)
{
	if (this != &amp;s)//避免自己给自己赋值
	{
		string tmp(s._str);
		swap(tmp);
	}
	return *this;
}</code></pre>
<p>这里还有另一种更加简洁的现代方法，<span style="color:#956fe7;">上述写法是引用传参，这里我们可以直接传值传参，让编译器自动调用拷贝构造函数，再把拷贝出来的对象作为右值与左值交换即可</span>。</p>
<pre><code class="language-cpp">//法二：简洁版	
//s1 = s3;
string&amp; operator=(string s)//传值传参调用拷贝构造，s就是s3的深拷贝结果
{
	swap(s);//交换这俩对象
	return *this;
}</code></pre>
<p>不过这种简洁的版本无法避免自己给自己赋值，但很少会出现自己给自己赋值的行为，除非你有啥癖好。所以上述两种方法都可使用。</p>
</blockquote>
<hr/>
<h3 id="%E5%AE%B9%E9%87%8F%E4%B8%8E%E5%A4%A7%E5%B0%8F%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0">3、容量与大小相关函数</h3>
<h3 id="size">size</h3>
<blockquote>
<p>直接返回隐含this指针指向的_size即为字符串长度</p>
<pre><code class="language-cpp">//返回字符串的长度
size_t size() const //不改变内部成员，最好加上const
{
	return _size;
}</code></pre>
</blockquote>
<hr/>
<h3 id="capacity">capacity</h3>
<blockquote>
<p>直接返回隐含this指针指向的_capacity即可</p>
<pre><code class="language-cpp">//返回字符串容量
size_t capacity() const //不改变内部成员，最好加上const
{
	return _capacity;
}</code></pre>
</blockquote>
<hr/>
<h3 id="%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0">4、字符串访问相关函数</h3>
<h3 id="%E5%A2%9E%E5%8A%A0">operator[ ]重载</h3>
<blockquote>
<p>有了operator[ ]运算符重载，便可以直接用下标+[ ]进行元素访问，不过这里还应提供一个<span style="color:#ff9900;">const版本的operator[ ]运算符重载</span>，<span style="color:#956fe7;">以便于普通对象和const对象均可调用而不会出现权限放大的问题</span>。</p>
<pre><code class="language-cpp">//版本1：
char&amp; operator[](size_t pos)//引用返回，便于后续修改返回的字符
{
	assert(pos &lt; _size);//记得确保pos位置的合法性，不能超过字符串
	return _str[pos]; //返回pos位置字符的引用
}
//版本2：
const char&amp; operator[](size_t pos) const//引用返回，便于后续修改返回的字符
{
	assert(pos &lt; _size);
	return _str[pos]; //返回pos位置字符的引用
}</code></pre>
</blockquote>
<hr/>
<h3 id="11">迭代器</h3>
<blockquote>
<p>string类的迭代器就是像<span style="color:#956fe7;">字符指针</span>一样的东西</p>
<ol><li>begin函数的作用就是返回字符串中第一个字符的地址</li><li>end函数的作用就是返回字符串最后一个字符的后一个位置的地址，即'\0'的地址</li></ol>
<pre><code class="language-cpp">//版本1：
typedef char* iterator;
iterator begin()
{
	return _str;//返回第一个有效字符的指针
}
iterator end()
{
	return _str + _size;//返回最后一个字符后一个位置的地址，即'\0'的地址
}</code></pre>
<p>和上文的operator[ ]重载一样，这里也要写一个const版本的迭代器，以便于后续的const对象也能够调用。</p>
<pre><code class="language-cpp">//版本2：只读，const对象可调用
typedef const char* const_iterator;
const_iterator begin() const
{
	return _str;//返回第一个有效字符的指针
}
const_iterator end() const
{
	return _str + _size;//返回最后一个字符后一个位置的地址，即'\0'的地址
}</code></pre>
<p>这里还有一种基于迭代器的遍历方式：<strong><span style="color:#956fe7;">范围for</span></strong></p>
<p>范围for的底层实现原理和迭代器没两样，只不过写法看着很高端。</p>
<pre><code class="language-cpp">void test_string()
{
	cpp::string s1("hello world");
	//迭代器
	cpp::string::iterator it = s1.begin();
	while (it != s1.end())
	{
		cout &lt;&lt; *it &lt;&lt; " "; //h e l l o   w o r l d
		it++;
	}
	cout &lt;&lt; endl;
	//范围for
	for (auto&amp; ch : s1) //加上引用，相当于是每个字符的别名，便于修改
	{
		ch -= 1;
	}
	for (auto&amp; ch : s1)
	{
		cout &lt;&lt; ch &lt;&lt; " "; //g d k k n  v n q k c
	}
}</code></pre>
</blockquote>
<hr/>
<h3>5、增加的相关函数接口</h3>
<h3 id="33">reserve扩容</h3>
<blockquote>
<p>reserve扩容只影响_capacity空间，不影响_size，其有以下两点规则</p>
<ol><li>当n大于对象当前的capacity时，将capacity扩大到n或大于n。</li><li>当n小于对象当前的capacity时，无需操作。</li></ol>
<pre><code class="language-cpp">//reserve扩容
void reserve(size_t n)
{
	if (n &gt; _capacity)
	{
		char* tmp = new char[n + 1];//每次开空间一定要多给一个字节给'\0'
		strcpy(tmp, _str);
        //释放旧空间
		delete[] _str;
        //把新空间赋给_str
		_str = tmp;
        //更新容量_capacity
		_capacity = n;
	}
}</code></pre>
</blockquote>
<hr/>
<h3 id="44">resize</h3>
<blockquote>
<p>resize是将字符串调整为n个字符的长度，不仅会改变_size，还会改变_capacity空间。规则如下：</p>
<ol><li>如果n小于当前的_size长度，将_size缩小到n</li><li>如果n大于当前的_size长度，将_size扩大到n，扩大的字符默认为'\0'</li></ol>
<p><img alt="" height="163" src="image\9abc65d90334431db226c1de801c8df8.png" width="656"/></p>
<pre><code class="language-cpp">//resize调整大小
void resize(size_t n, char ch = '\0')
{
	//如果n &lt; _size，就保留前n个字符即可，把下标n置为'\0'
	if (n &lt; _size)
	{
		_size = n;
		_str[_size] = '\0';
	}
	else
	{
		//如果n &gt; _capacity，就要扩容了
		if (n &gt; _capacity)
		{
			reserve(n);
		}
		for (size_t i = _size; i &lt; n; i++)
		{
			//把剩余的字符置为ch
			_str[i] = ch;
		}
		_size = n;
		_str[_size] = '\0';
	}
}</code></pre>
</blockquote>
<hr/>
<h3 id="%E5%88%A0%E9%99%A4">push_back追加字符</h3>
<blockquote>
<p>首先要考虑需不需要扩容，如若需要，直接复用reserve函数进行增容，追加字符后，记得把最后一个下标_size对应的值置为'\0'。</p>
<pre><code class="language-cpp">//push_back
void push_back(char ch)
{
/*法一*/
	//先检查是否需要扩容
	if (_size == _capacity)
	{
		//复用reserve进行扩容，如果一开始容量为0，记得处理，否则容量*2依旧为0
		reserve(_capacity == 0 ? 4 : _capacity * 2);
	}
	_str[_size] = ch;
	_size++;
	_str[_size] = '\0'; //注意最后一个值恒为'\0'以确保字符串的完整性
}</code></pre>
<p>这里我们还可使用后文写好的<span style="color:#956fe7;">insert尾插字符</span>，因为当insert函数中的pos为_size时即为尾插：</p>
<pre><code class="language-cpp">//push_back尾插字符
void push_back(char ch)
{
	//法二：复用insert尾插入字符
	insert(_size, ch);
}</code></pre>
</blockquote>
<hr/>
<h3>append追加字符串</h3>
<blockquote>
<p>使用append追加字符串首先要判断是否需要扩容，扩容后利用strcpy函数把追加的字符串拷贝到原字符串末尾即可，不需要额外处理'\0'，因为strcpy默认把'\0'拷贝过去。</p>
<pre><code class="language-cpp">//append
void append(const char* str)
{
	//统计追加字符串后的长度
	size_t len = _size + strlen(str);
	//判断是否需要扩容
	if (len &gt; _capacity)
	{
		reserve(len);
	}
	//把字符串追加到末尾
	strcpy(_str + _size, str);
	_size = len;
}</code></pre>
<p>这里也可以使用后文的insert追加字符串来完成，因为当pos为_size时，就是在尾部追加字符串。</p>
<pre><code class="language-cpp">void append(const char* str)
{
	//法二：复用insert函数
	insert(_size, str);
}</code></pre>
</blockquote>
<hr/>
<h3 id="22">operator+=</h3>
<blockquote>
<p>operator+=可以追加字符、字符串、对象。因此我们可以分开来讨论：</p>
<ul><li><span style="background-color:#edf6e8;"><strong>追加字符：</strong>直接复用push_back</span></li></ul>
<pre><code class="language-cpp">//operator+=字符
string&amp; operator+=(char ch)
{
	//复用push_back
	push_back(ch);
	return *this;
}</code></pre>
<ul><li><span style="color:#0d0016;"><span style="background-color:#edf6e8;"><strong>追加字符串：</strong>直接复用append</span></span></li></ul>
<pre><code class="language-cpp">//operator+=字符串
string&amp; operator+=(const char* str)
{
	//复用append
	append(str);
	return *this;
}</code></pre>
</blockquote>
<hr/>
<h3>insert</h3>
<blockquote>
<p>insert的作用是在指定pos位置往后<span style="color:#956fe7;">插入字符</span><span style="color:#494949;">或</span><span style="color:#956fe7;">字符串</span>。</p>
<ul><li><span style="background-color:#edf6e8;">insert在pos位置插入字符</span></li></ul>
<p>这里首先要判断pos的合法性，接下来就要挪动数据了，这里我们优先考虑从最后一个'\0'位置的下一个位置（_size + 1）开始往前挪动。因此定义end指向'\0'后一个位置，当end挪到与pos位置重合时停止，最后把插入的字符ch挪到下标pos处。记得最后更新_size++。</p>
<p><img alt="" height="210" src="image\a4d6f8b2d2e84b5caf2e38d3df5b283e.png" width="730"/></p>
<pre><code class="language-cpp">//insert插入字符
string&amp; insert(size_t pos, char ch)
{
	assert(pos &lt;= _size);
	if (_size == _capacity)
	{
		//复用reserve进行扩容，如果一开始容量为0，记得处理，否则容量*2依旧为0
		reserve(_capacity == 0 ? 4 : _capacity * 2);
	}
	size_t end = _size + 1; //最好把end放到_size + 1的位置，防止后续出现整型提升等问题
	while (end &gt; pos)
	{
		_str[end] = _str[end - 1];
		end--;
	}
	//当end挪动到pos的位置时停止挪动，并把ch赋到pos的下标处
	_str[pos] = ch;
	_size += 1;
	return *this;
}</code></pre>
<p>测试入下：</p>
<pre><code class="language-cpp">void test_string()
{
	cpp::string s("hello world");
	s.insert(6, '@');
	s += '@';
	cout &lt;&lt; s.c_str() &lt;&lt; endl; //hello @world@
	for (auto&amp; ch : s)
	{
		cout &lt;&lt; ch &lt;&lt; " "; 
	}
	cout &lt;&lt; "#" &lt;&lt; endl; //h e l l o   @ w o r l d @ #
	
 	s += '\0';
	for (auto&amp; ch : s)
	{
		cout &lt;&lt; ch &lt;&lt; " "; 
	}
	cout &lt;&lt; "#" &lt;&lt; endl; //h e l l o   @ w o r l d @  #
	s.insert(0, '@');
	cout &lt;&lt; s.c_str() &lt;&lt; endl;//@hello @world@
}
</code></pre>
<ul><li><span style="background-color:#edf6e8;">insert在pos位置插入字符串</span></li></ul>
<p>首先判断是否需要扩容，接下来挪动数据。定义变量end为_size + len的位置，把pos处往后的字符串整体往后挪动直至空出插入字符串的长度。利用循环+ _str[end] = _str[end - len];来完成。当end挪动到pos + len - 1时结束循环，再利用strncpy函数把插入的字符串拷贝过去即可。</p>
<p><img alt="" height="478" src="image\330fc087470748d0aa841a9c9676d595.png" width="738"/></p>
<pre><code class="language-cpp">//insert插入字符串
string&amp; insert(size_t pos, const char* str)
{
	assert(pos &lt;= _size);
	size_t len = strlen(str);
    if (len == 0)
	{
		//如果传进来的字符串为空，直接返回即可
		return *this;
	}
	if (_size + len &gt; _capacity)
	{
		//判断是否扩容
		reserve(_size + len);
	}
	size_t end = _size + len;
	//当end &gt;= pos + len时都不结束循环
	while (end &gt;= pos + len)
	{
		_str[end] = _str[end - len];
		end--;
	}
	//不能使用strcpy，因为会把\0也拷过去，就会出错
	strncpy(_str + pos, str, len);
	_size += len;
	return *this;
}</code></pre>
<p>测试如下：</p>
<pre><code class="language-cpp">void test_string()
{
	cpp::string s("hello world");
	s.insert(0, "xxx");
	cout &lt;&lt; s.c_str() &lt;&lt; endl;//xxxhello world
}</code></pre>
</blockquote>
<hr/>
<h3>6、删除的相关函数接口</h3>
<h3 id="%E6%9F%A5%E6%89%BE">erase</h3>
<blockquote>
<p>如果给定删除的长度len为npos无符号值，或者说len + pos的长度&gt;=_size，那么直接把pos位置的值设定为'\0\即可，因为此时就是把pos后的所有数据全部删除。出去这种特殊情况，其余的就是从pos + len处开始先前挪动到_size + 1为止。pos后的数据往前覆盖即可。</p>
<p><img alt="" height="325" src="image\b47a646341f14c97a565724ac09956cf.png" width="828"/></p>
<pre><code class="language-cpp">//erase删除
void erase(size_t pos, size_t len = npos)
{
    assert(pos &lt; _size);
	if (len == npos || pos + len &gt;= _size)
	{
		//这种情况是删除pos后的所有数据，直接把pos处设定为'\0'即可
		_str[pos] = '\0';
		_size = pos;
	}
	else
	{
		size_t begin = pos + len;
		while (begin &lt;= _size)
		{
			_str[begin - len] = _str[begin];
			++begin;
		}
		_size -= len;
	}
}</code></pre>
<p>测试如下：</p>
<pre><code class="language-cpp">void test_string9()
{
	cpp::string s("hello world");
	s.insert(0, "xxx");
	cout &lt;&lt; s.c_str() &lt;&lt; endl;//xxxhello world
	s.erase(0, 3);
	cout &lt;&lt; s.c_str() &lt;&lt; endl;//hellow world
}</code></pre>
</blockquote>
<hr/>
<h3>clear清除数据</h3>
<blockquote>
<p>clear函数是用来清除原字符串的所有数据，并不是连空间一并清除了，所以我们只需要把下标0置为'\0'，并把有效字符个数_size置为0即可。</p>
<pre><code class="language-cpp">//clear清除数据
void clear()
{
	_str[0] = '\0';
	_size = 0;
}</code></pre>
</blockquote>
<hr/>
<h3>7、查找的相关函数接口</h3>
<h3>find</h3>
<blockquote>
<p>find函数也分查找字符和字符串</p>
<ul><li><span style="background-color:#edf6e8;">find查找字符：</span></li></ul>
<p>直接遍历即可：</p>
<pre><code class="language-cpp">//find查找字符	
size_t find(char ch, size_t pos = 0)
{
	for (; pos &lt; _size; pos++)
	{
		if (_str[pos] == ch)
			return pos;
	}
	//没找到就返回npos，-1
	return npos; //-1
}</code></pre>
<ul><li><span style="background-color:#edf6e8;">find查找字符串：</span></li></ul>
<p>这里可以直接复用C语言的strstr函数进行查找，不过该函数返回的是地址，想要获得最终的下标直接利用地址相减即可，p - _str</p>
<pre><code class="language-cpp">size_t find(const char* str, size_t pos = 0)
{
	//直接复用C语言库函数strstr即可，strstr函数返回的是地址
	const char* p = strstr(_str + pos, str);
	if (p == nullptr)
	{
		return npos;
	}
	else
	{
		//返回下标直接用p - str即可
		return p - _str;
	}
}</code></pre>
</blockquote>
<hr/>
<h3>8、c_str获取字符串</h3>
<blockquote>
<p>c_str用于获取c类型的字符串，直接返回字符串即可</p>
<pre><code class="language-cpp">//c_str  获取c形式的字符串
const char* c_str() const //最好加上const，便于普通及const对象均可调用
{
	return _str;
}</code></pre>
</blockquote>
<hr/>
<h3>9、swap交换函数</h3>
<blockquote>
<p>swap函数用于交换两个对象的数据，我们可以通过复用库里的swap函数来完成，但是要在前面加上作用域限定符"<span style="color:#fe2c24;"><strong>::</strong></span>"。让编译器在全局域的库里调用swap函数。</p>
<pre><code class="language-cpp">//swap交换函数
void swap(string&amp; s)
{
	std::swap(_str, s._str);
	std::swap(_size, s._size);
	std::swap(_capacity, s._capacity);
}</code></pre>
</blockquote>
<hr/>
<h3>10、非成员函数</h3>
<h3 id="%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD">关系运算符函数重载</h3>
<blockquote>
<p>关系运算符有==、!=、&lt;、&lt;=、&gt;、&gt;=这6类，先前的日期类已经讲解过类似的。这里关系运算符重载我们不把它放到成员函数里头。</p>
<ul><li><span style="background-color:#edf6e8;">1、operator&lt;</span></li></ul>
<p>直接借用库函数strcmp进行字符串大小比较即可。此外，和日期类一样，写好了&lt;和==的重载，剩下的4个关系运算符直接复用即可。</p>
<pre><code class="language-cpp">//1、operator&lt;
bool operator&lt;(const string&amp; s1, const string&amp; s2)
{
	return strcmp(s1.c_str(), s2.c_str()) &lt; 0;
}	
//2、operator==
bool operator==(const string&amp; s1, const string&amp; s2)
{
	return strcmp(s1.c_str(), s2.c_str()) == 0;
}</code></pre>
<p>剩下4个关系运算符复用上面两个：</p>
<pre><code class="language-cpp">//3、operator&lt;=
bool operator&lt;=(const string&amp; s1, const string&amp; s2)
{
	return s1 &lt; s2 || s1 == s2;
}
//4、operator&gt;
bool operator&gt;(const string&amp; s1, const string&amp; s2)
{
	return !(s1 &lt;= s2);
}
//5、operator&gt;=
bool operator&gt;=(const string&amp; s1, const string&amp; s2)
{
	return !(s1 &lt; s2);
}
//6、operator!=
bool operator!=(const string&amp; s1, const string&amp; s2)
{
	return !(s1 == s2);
}</code></pre>
</blockquote>
<hr/>
<h3 id="%E6%BA%90%E7%A0%81%E6%B1%87%E6%80%BB">&lt;&lt;流插入运算符重载</h3>
<blockquote>
<p>这里我们可以通过范围for来完成&lt;&lt;运算符的重载</p>
<pre><code class="language-cpp">//&lt;&lt;流插入运算符重载
ostream&amp; operator&lt;&lt;(ostream&amp; out, const string&amp; s)
{
	for (auto ch : s)
	{
		out &lt;&lt; ch;
	}
	return out;
}</code></pre>
</blockquote>
<hr/>
<h3 id="%3E%3E%E5%92%8C%3C%3C%E9%87%8D%E8%BD%BD">&gt;&gt;流提取运算符重载</h3>
<blockquote>
<p>这里实现的过程种要注意当遇到空格或换行符时就要停止读取了。此外，<span style="color:#956fe7;">在一开始要记得调用clear函数把原字符串的所有数据给清空</span>，然后才能正常往后输入新的数据，否则新数据会累加到原数据后面，就不是&gt;&gt;预期的效果了。</p>
<pre><code class="language-cpp">//&gt;&gt;流提取运算符重载
istream&amp; operator&gt;&gt;(istream&amp; in, string&amp; s)
{
	法一：
    //要先把原字符串的所有数据给清空才可以输入新的数据，否则会累加到原数据后面，出错
	s.clear();
	char ch;
	ch = in.get();//使用get()函数才能获取空格或者换行字符
	while (ch != ' ' &amp;&amp; ch != '\n')
	{
		s += ch;
		ch = in.get();
	}
	return in;
}</code></pre>
<p>这里有个缺陷，如若频繁输入大量字符，那么就会多次扩容，扩容也会在效率上有所损耗，因此我们可以提前开辟一个128字节大小的数组，把每次输进的字符放到数组里头，最后当遇到停止的符号时，+=到字符串s上，如若下标加到127，把数组的字符+=到字符串s上，并充值数组为'\0'，更新下标为0即可。以此类推。</p>
<pre><code class="language-cpp">//&gt;&gt;流提取运算符重载
istream&amp; operator&gt;&gt;(istream&amp; in, string&amp; s)
{
    //法二：
    //要先把原字符串的所有数据给清空才可以输入新的数据，否则会累加到原数据后面，出错
	s.clear();
	char ch;
	ch = in.get();//使用get()函数才能获取空格或者换行字符
	char buff[128] = { '\0' };
	size_t i = 0;
	while (ch != ' ' &amp;&amp; ch != '\n')
	{
		buff[i++] = ch;
		if (i == 127)
		{
			s += buff;
			memset(buff, '\0', 128);
			i = 0;
		}
		ch = in.get();
	}
	s += buff;
	return in;
}</code></pre>
</blockquote>
<hr/>
<h3 id="getline%E5%87%BD%E6%95%B0">getline函数</h3>
<blockquote>
<p>getline函数与上述写的&lt;&lt;流提取运算符重载非常相似，唯一不同的地方在于<span style="color:#956fe7;">getline只有在遇到换行符才停止读取</span>，而<span style="color:#956fe7;">&lt;&lt;在遇到换行符停止外，遇到空格也会停止读取</span>，因此，在&lt;&lt;的基础上改变下if种的判断条件即可：</p>
<pre><code class="language-cpp">//getline函数
istream&amp; getline(istream&amp; in, string&amp; s)
{
	s.clear();
	char ch;
	ch = in.get();
	//getline函数只有在遇到换行符才会停止
	while (ch != '\n')
	{
		s += ch;
		ch = in.get();
	}
	return in;
}</code></pre>
<p>测试如下：</p>
<p><img alt="" height="142" src="image\b5fc970b01654602a53efac1b9f715b9.png" width="672"/></p>
<p></p>
</blockquote>
<hr/>
<h3 id="%E6%80%BB%E8%A7%88">11、源码链接</h3>
<blockquote>
<p>gitee仓库一键传送：<a class="link-info" href="https://gitee.com/bit-zy/xzy--c/blob/master/stl_string/stl_string/String.h" title="string类的模拟实现完整版链接">string类的模拟实现完整版链接</a></p>
</blockquote>
</div>
</div>