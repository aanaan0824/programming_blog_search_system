<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<h2>总结：</h2>
<ol><li> <p>var  let const的区别</p> </li><li>数组新增拓展</li><li>对象新增拓展</li><li>函数新增拓展</li><li>Set 和 Map</li><li>Promise</li><li>Generator</li><li>Proxy</li><li>Module</li><li>Decorator</li></ol>
<h2>具体介绍：</h2>
<h3>1.var  let  const</h3>
<p>一、var</p>
<p>1、在ES5中，顶层对象的属性和全局变量是等价的，用<code>var</code>声明的变量既是全局变量，也是顶层变量：</p>
<ul><li>顶层对象，在浏览器环境指的是<code>window</code>对象，在 <code>Node</code> 指的是<code>global</code>对象</li></ul>
<p>2、使用<code>var</code>声明的变量存在变量提升的情况</p>
<p>3、使用<code>var</code>，我们能够对一个变量进行多次声明，后面声明的变量会覆盖前面的变量声明：</p>
<ul><li>在函数中使用使用<code>var</code>声明变量时候，该变量是局部的</li><li>而如果在函数内不使用<code>var</code>，该变量是全局的</li></ul>
<p>二、let</p>
<p>1、<code>let</code>是<code>ES6</code>新增的命令，用来声明变量</p>
<p>2、用法类似于<code>var</code>，但是所声明的变量，只在<code>let</code>命令所在的代码块内有效，不存在变量提：</p>
<ul><li>只要块级作用域内存在<code>let</code>命令，这个区域就不再受外部影响</li></ul>
<p>3、使用<code>let</code>声明变量前，该变量都不可用，也就是大家常说的暂时性死区：</p>
<ul><li><code>let</code>不允许在相同作用域中重复声明</li><li>注意的是相同作用域，下面这种情况是不会报错的，因此，我们不能在函数内部重新声明参数</li></ul>
<p>三、const</p>
<p>1、<code>const</code>声明一个只读的常量，一旦声明，常量的值就不能改变：</p>
<ul><li><code>const</code>一旦声明变量，就必须立即初始化，不能留到以后赋值</li><li>如果之前用<code>var</code>或<code>let</code>声明过变量，再用<code>const</code>声明同样会报错</li></ul>
<p>2、<code>const</code>实际上保证的并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动：</p>
<ul><li>对于简单类型的数据，值就保存在变量指向的那个内存地址，因此等同于常量</li><li>对于复杂类型的数据，变量指向的内存地址，保存的只是一个指向实际数据的指针，<code>const</code>只能保证这个指针是固定的，并不能确保改变量的结构不变</li></ul>
<p>四、区别</p>
<p>1、变量提升：</p>
<ul><li><code>var</code>声明的变量存在变量提升，即变量可以在声明之前调用，值为undefined</li><li><code>let</code>和<code>const</code>不存在变量提升，即它们所声明的变量一定要在声明后使用，否则报错</li></ul>
<p>2、暂时性死区：</p>
<ul><li><code>var</code>不存在暂时性死区</li><li><code>let</code>和<code>const</code>存在暂时性死区，只有等到声明变量的那一行代码出现，才可以获取和使用该变量</li></ul>
<p>3、块级作用域：</p>
<ul><li><code>var</code>不存在块级作用域</li><li><code>let</code>和<code>const</code>存在块级作用域</li></ul>
<p>4、重复声明：</p>
<ul><li><code>var</code>允许重复声明变量</li><li><code>let</code>和<code>const</code>在同一作用域不允许重复声明变量</li></ul>
<p>5、修改声明的变量：</p>
<ul><li><code>var</code>和<code>let</code>可以</li><li><code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变</li></ul>
<p>五、使用</p>
<ul><li>能用<code>const</code>的情况尽量使用<code>const</code>，其他情况下大多数使用<code>let</code>，避免使用<code>var</code></li></ul>
<h3>二  数组新增拓展</h3>
<p>一、扩展运算符的应用</p>
<p>1、ES6通过扩展元素符<code>...</code>，好比 <code>rest</code> 参数的逆运算，将一个数组转为用逗号分隔的参数序列：</p>
<ul><li>主要用于函数调用的时候，将一个数组变为参数序列</li><li>可以将某些数据结构转为数组，能够更简单实现数组复制，数组的合并也更为简洁</li></ul>
<p>2、扩展运算符可以与解构赋值结合起来，用于生成数组。如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错：</p>
<ul><li>可以将字符串转为真正的数组</li></ul>
<p>3、定义了遍历器（Iterator）接口的对象，都可以用扩展运算符转为真正的数组。如果对没有 Iterator 接口的对象，使用扩展运算符，将会报错</p>
<p>二、构造函数新增的方法</p>
<p>1、Array.from()：将两类对象转为真正的数组：类似数组的对象和可遍历<code>（iterable）</code>的对象（包括 <code>ES6</code> 新增的数据结构 <code>Set</code> 和 <code>Map</code>）</p>
<ul><li>可以接受第二个参数，用来对每个元素进行处理，将处理后的值放入返回的数组</li></ul>
<p>2、Array.of()：用于将一组值，转换为数组</p>
<ul><li>没有参数的时候，返回一个空数组</li><li>当参数只有一个的时候，实际上是指定数组的长度</li><li>参数个数不少于 2 个时，<code>Array()</code>才会返回由参数组成的新数组</li></ul>
<p>三、实例对象新增的方法</p>
<p>1、copyWithin()：将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组</p>
<ul><li>target（必需）：从该位置开始替换数据。如果为负值，表示倒数。</li><li>start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。</li><li>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。</li></ul>
<p>2、find()、findIndex()：<code>find()</code>用于找出第一个符合条件的数组成员</p>
<ul><li>参数是一个回调函数，接受三个参数依次为当前的值、当前的位置和原数组</li><li>findIndex返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1</li><li>这两个方法都可以接受第二个参数，用来绑定回调函数的<code>this</code>对象</li></ul>
<p>3、fill()：使用给定值，填充一个数组</p>
<ul><li>还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置</li><li>注意，如果填充的类型为对象，则是浅拷贝</li></ul>
<p>4、entries()，keys()，values()：</p>
<ul><li><code>keys()</code>是对键名的遍历</li><li><code>values()</code>是对键值的遍历</li><li><code>entries()</code>是对键值对的遍历</li></ul>
<p>5、includes()：用于判断数组是否包含给定的值</p>
<ul><li>方法的第二个参数表示搜索的起始位置，默认为<code>0</code></li><li>参数为负数则表示倒数的位置</li></ul>
<p>6、flat()，flatMap()：将数组扁平化处理，返回一个新数组，对原数据没有影响</p>
<ul><li><code>flat()</code>：默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将<code>flat()</code>方法的参数写成一个整数，表示想要拉平的层数，默认为1</li><li><code>flatMap()</code>方法对原数组的每个成员执行一个函数相当于执行<code>Array.prototype.map()</code>，然后对返回值组成的数组执行<code>flat()</code>方法。该方法返回一个新数组，不改变原数组。flatMap()方法还可以有第二个参数，用来绑定遍历函数里面的this</li></ul>
<p>四、数组的空位</p>
<p>1、数组的空位指，数组的某一个位置没有任何值</p>
<ul><li>ES6 则是明确将空位转为<code>undefined</code></li><li>包括<code>Array.from</code>、扩展运算符、<code>copyWithin()</code>、<code>fill()</code>、<code>entries()</code>、<code>keys()</code>、<code>values()</code>、<code>find()</code>和<code>findIndex()</code></li></ul>
<h3>3.对象新增拓展</h3>
<p>一、属性的简写</p>
<p>1、ES6中，当对象键名与对应值名相等的时候，可以进行简写。方法也能够进行简写。在函数内作为返回值，也会变得方便很多：</p>
<ul><li>注意：简写的对象方法不能用作构造函数，否则会报错</li></ul>
<p>二、属性名表达式</p>
<p>1、ES6 允许字面量定义对象时，将表达式放在括号内。表达式还可以用于定义方法名：</p>
<ul><li>注意，属性名表达式与简洁表示法，不能同时使用，会报错</li><li>注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串<code>[object Object]</code></li></ul>
<p>三、super关键字</p>
<ul><li><code>this</code>关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字<code>super</code>，指向当前对象的原型对象</li></ul>
<p>四、扩展运算符的应用</p>
<p>1、在解构赋值中，未被读取的可遍历的属性，分配到指定的对象上面：</p>
<ul><li>注意：解构赋值必须是最后一个参数，否则会报错</li></ul>
<p>2、解构赋值是浅拷贝。对象的扩展运算符等同于使用<code>Object.assign()</code>方法</p>
<p>五、属性的遍历</p>
<p>1、ES6 一共有 5 种方法可以遍历对象的属性：</p>
<ul><li>for...in：循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）</li><li>Object.keys(obj)：返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名</li><li>Object.getOwnPropertyNames(obj)：回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名</li><li>Object.getOwnPropertySymbols(obj)：返回一个数组，包含对象自身的所有 Symbol 属性的键名</li><li>Reflect.ownKeys(obj)：返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举</li></ul>
<p>2、上述遍历，都遵守同样的属性遍历的次序规则：</p>
<ul><li>首先遍历所有数值键，按照数值升序排列</li><li>其次遍历所有字符串键，按照加入时间升序排列</li><li>最后遍历所有 Symbol 键，按照加入时间升序排</li></ul>
<p>六、对象新增的方法</p>
<p>1、Object.is()：严格判断两个值是否相等，与严格比较运算符（===）的行为基本一致，不同之处只有两个：一是<code>+0</code>不等于<code>-0</code>，二是<code>NaN</code>等于自身</p>
<p>2、Object.assign()：</p>
<ul><li><code>Object.assign()</code>方法用于对象的合并，将源对象source的所有可枚举属性，复制到目标对象target</li><li><code>Object.assign()</code>方法的第一个参数是目标对象，后面的参数都是源对象</li><li>注意：<code>Object.assign()</code>方法是浅拷贝，遇到同名属性会进行替换</li></ul>
<p>3、Object.getOwnPropertyDescriptors()：返回指定对象所有自身属性（非继承属性）的描述对象</p>
<p>4、Object.setPrototypeOf()：用来设置一个对象的原型对象</p>
<p>5、Object.getPrototypeOf()：用于读取一个对象的原型对象</p>
<p>6、Object.keys()：返回自身的（不含继承的）所有可遍历（enumerable）属性的键名的数组</p>
<p>7、Object.values()：返回自身的（不含继承的）所有可遍历（enumerable）属性的键对应值的数组</p>
<p>8、Object.entries()：返回一个对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对的数组</p>
<p>9、Object.fromEntries()：用于将一个键值对数组转为对象</p>
<h3>4.函数新增拓展</h3>
<p>一、参数</p>
<p>1、<code>ES6</code>允许为函数的参数设置默认值：</p>
<ul><li>函数的形参是默认声明的，不能使用<code>let</code>或<code>const</code>再次声明</li><li>参数默认值可以与解构赋值的默认值结合起来使用</li><li>当参数为对象的时候才能进行解构，如果没有提供参数的时候，变量<code>x</code>和<code>y</code>就不会生成，从而报错，这里设置默认值避免</li><li>参数默认值应该是函数的尾参数，如果不是非尾部的参数设置默认值，实际上这个参数是没发省略的</li></ul>
<p>二、属性</p>
<p>1、length：</p>
<ul><li><code>length</code>将返回没有指定默认值的参数个数</li><li><code>rest</code> 参数也不会计入<code>length</code>属性</li><li>如果设置了默认值的参数不是尾参数，那么<code>length</code>属性也不再计入后面的参数了</li></ul>
<p>2、name：</p>
<ul><li>返回该函数的函数名</li><li>如果将一个具名函数赋值给一个变量，则 <code>name</code>属性都返回这个具名函数原本的名字</li><li>Function<code>构造函数返回的函数实例，</code>name<code>属性的值为</code>anonymous</li><li><code>bind</code>返回的函数，<code>name</code>属性值会加上<code>bound</code>前缀</li></ul>
<p>三、作用域</p>
<p>1、一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域</p>
<p>2、等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的</p>
<p>四、严格模式</p>
<ul><li>只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错</li></ul>
<p>五、箭头函数</p>
<p>1、如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分</p>
<p>2、如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用<code>return</code>语句返回</p>
<p>3、如果返回对象，需要加括号将对象包裹</p>
<p>4、注意点：</p>
<ul><li>函数体内的<code>this</code>对象，就是定义时所在的对象，而不是使用时所在的对象</li><li>不可以当作构造函数，也就是说，不可以使用<code>new</code>命令，否则会抛出一个错误</li><li>不可以使用<code>arguments</code>对象，该对象在函数体内不存在。如果要用，可以用 <code>rest</code> 参数代替</li><li>不可以使用<code>yield</code>命令，因此箭头函数不能用作 Generator 函数</li></ul>
<h3>5.Set Map</h3>
<p>一、定义</p>
<p>1、<code>Set</code>是一种叫做集合的数据结构，<code>Map</code>是一种叫做字典的数据结构</p>
<p>2、什么是集合和字典：</p>
<ul><li>集合：是由一堆无序的、相关联的，且不重复的内存结构【数学中称为元素】组成的组合</li><li>字典：是一些元素的集合。每个元素有一个称作key 的域，不同元素的key 各不相同</li></ul>
<p>3、区别：</p>
<ul><li>共同点：集合、字典都可以存储不重复的值</li><li>不同点：集合是以[值，值]的形式存储元素，字典是以[键，值]的形式存储</li></ul>
<p>二、Set</p>
<p>1、<code>Set</code>是<code>es6</code>新增的数据结构，类似于数组，但是成员的值都是唯一的，没有重复的值，我们一般称为集合</p>
<ul><li><code>Set</code>本身是一个构造函数，用来生成 Set 数据结构</li></ul>
<p>2、增删改查：</p>
<ul><li>add()：添加某个值，返回 <code>Set</code> 结构本身。当添加实例中已经存在的元素，<code>set</code>不会进行处理添加</li><li>delete()：删除某个值，返回一个布尔值，表示删除是否成功</li><li>has()：返回一个布尔值，判断该值是否为<code>Set</code>的成员</li><li>clear()：清除所有成员，没有返回值</li></ul>
<p>2、遍历：</p>
<ul><li>keys()：返回键名的遍历器</li><li>values()：返回键值的遍历器</li><li>entries()：返回键值对的遍历器</li><li>forEach()：使用回调函数遍历每个成员</li></ul>
<p>3、<code>Set</code>的遍历顺序就是插入顺序：</p>
<ul><li><code>keys</code>方法、<code>values</code>方法、<code>entries</code>方法返回的都是遍历器对象</li><li>forEach()用于对每个成员执行某种操作，没有返回值，键值、键名都相等，同样的forEach方法有第二个参数，用于绑定处理函数的this</li><li>扩展运算符和<code>Set</code> 结构相结合实现数组或字符串去重</li><li>实现并集、交集、和差集</li></ul>
<p>三、Map</p>
<p>1、<code>Map</code>类型是键值对的有序列表，而键和值都可以是任意类型</p>
<ul><li><code>Map</code>本身是一个构造函数，用来生成 <code>Map</code> 数据结构</li></ul>
<p>2、增删改查：</p>
<ul><li>size：<code>size</code>属性返回 Map 结构的成员总数。</li><li>set()：设置键名<code>key</code>对应的键值为<code>value</code>，然后返回整个 Map 结构。如果<code>key</code>已经有值，则键值会被更新，否则就新生成该键。同时返回的是当前<code>Map</code>对象，可采用链式写法</li><li>get()：get<code>方法读取</code>key<code>对应的键值，如果找不到</code>key<code>，返回</code>undefined</li><li>has()：<code>has</code>方法返回一个布尔值，表示某个键是否在当前 Map 对象之中</li><li>delete()：delete<code>方法删除某个键，返回</code>true<code>。如果删除失败，返回</code>false</li><li>clear()：<code>clear</code>方法清除所有成员，没有返回值</li></ul>
<p>3、遍历：</p>
<ul><li>keys()：返回键名的遍历器</li><li>values()：返回键值的遍历器</li><li>entries()：返回所有成员的遍历器</li><li>forEach()：遍历 Map 的所有成员</li></ul>
<p>4、遍历顺序就是插入顺序</p>
<p>四、WeakSet</p>
<p>1、<code>WeakSet</code>可以接受一个具有 <code>Iterable</code>接口的对象作为参数</p>
<p>2、在<code>API</code>中<code>WeakSet</code>与<code>Set</code>有两个区别：</p>
<ul><li>没有遍历操作的<code>API</code></li><li>没有<code>size</code>属性</li></ul>
<p>3、<code>WeackSet</code>只能成员只能是引用类型，而不能是其他类型的值</p>
<p>4、<code>WeakSet</code>里面的引用只要在外部消失，它在 <code>WeakSet</code>里面的引用就会自动消失</p>
<p>五、WeakMap</p>
<p>1、<code>WeakMap</code>结构与<code>Map</code>结构类似，也是用于生成键值对的集合</p>
<p>2、在<code>API</code>中<code>WeakMap</code>与<code>Map</code>有两个区别：</p>
<ul><li>没有遍历操作的<code>API</code></li><li>没有<code>clear</code>清空方法</li></ul>
<p>3、<code>WeakMap</code>只接受对象作为键名（<code>null</code>除外），不接受其他类型的值作为键名</p>
<p>4、<code>WeakMap</code>的键名所指向的对象，一旦不再需要，里面的键名对象和所对应的键值对会自动消失，不用手动删除引用</p>
<h3>6.Promise</h3>
<p>一、定义</p>
<p>1、<code>Promise</code>，译为承诺，是异步编程的一种解决方案，比传统的解决方案（回调函数）更加合理和更加强大</p>
<p>2、状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）、<code>rejected</code>（已失败）</p>
<p>二、优点</p>
<ul><li>链式操作减低了编码难度</li><li>代码可读性明显增强</li></ul>
<p>三、特点</p>
<ul><li>对象的状态不受外界影响，只有异步操作的结果，可以决定当前是哪一种状态</li><li>一旦状态改变（从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>），就不会再变，任何时候都可以得到这个结果</li></ul>
<p>四、用法</p>
<p>1、<code>Promise</code>对象是一个构造函数，用来生成<code>Promise</code>实例：</p>
<pre><code>const promise = new Promise(function(resolve, reject) {});
</code></pre>
<p>2、Promise<code>构造函数接受一个函数作为参数，该函数的两个参数分别是</code>resolve<code>和</code>reject：</p>
<ul><li><code>resolve</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“成功”</li><li><code>reject</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“失败</li></ul>
<p>3、实例方法：<code>Promise</code>构建出来的实例存在以下方法</p>
<ul><li>then()：<code>then</code>是实例状态发生改变时的回调函数，第一个参数是<code>resolved</code>状态的回调函数，第二个参数是<code>rejected</code>状态的回调函数</li><li>catch()：<code>catch()</code>方法是<code>.then(null, rejection)</code>或<code>.then(undefined, rejection)</code>的别名，用于指定发生错误时的回调函数</li><li>finally()：<code>finally()</code>方法用于指定不管 Promise 对象最后状态如何，都会执行的操作</li></ul>
<p>4、构造函数方法：<code>Promise</code>构造函数存在以下方法</p>
<ul><li>all()：<code>Promise.all()</code>方法用于将多个 <code>Promise</code>实例，包装成一个新的 <code>Promise</code>实例</li><li>race()：<code>Promise.race()</code>方法同样是将多个 Promise 实例，包装成一个新的 Promise 实</li><li>allSettled()：<code>Promise.allSettled()</code>方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例</li><li>resolve()：将现有对象转为 <code>Promise</code>对象</li><li>reject()：Promise.reject(reason)<code>方法也会返回一个新的 Promise 实例，该实例的状态为</code>rejected</li></ul>
<p>五、使用场景</p>
<ul><li>将图片的加载写成一个<code>Promise</code>，一旦加载完成，<code>Promise</code>的状态就发生变化</li><li>通过链式操作，将多个渲染数据分别给个<code>then</code>，让其各司其职。或当下个异步请求依赖上个请求结果的时候，我们也能够通过链式操作友好解决问题</li><li>通过<code>all()</code>实现多个请求合并在一起，汇总所有请求结果，只需设置一个<code>loading</code>即可</li><li>通过<code>race</code>可以设置图片请求超时</li></ul>
<h3>7.Generator</h3>
<p>一、定义</p>
<p>1、Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同</p>
<p>2、执行 <code>Generator</code> 函数会返回一个遍历器对象，可以依次遍历 <code>Generator</code> 函数内部的每一个状态</p>
<p>二、特征</p>
<p>1、<code>function</code>关键字与函数名之间有一个星号</p>
<p>2、函数体内部使用<code>yield</code>表达式，定义不同的内部状态</p>
<p>三、异步解决方案</p>
<p>1、回调函数：所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，再调用这个函数</p>
<p>2、Promise：<code>Promise</code>就是为了解决回调地狱而产生的，将回调函数的嵌套，改成链式调用</p>
<p>3、generator：<code>yield</code>表达式可以暂停函数执行，<code>next</code>方法用于恢复函数执行，这使得<code>Generator</code>函数非常适合将异步任务同步化</p>
<p>4、async/await：将上面<code>Generator</code>函数改成<code>async/await</code>形式，更为简洁，语义化更强了</p>
<p>5、区别：</p>
<ul><li><code>promise</code>和<code>async/await</code>是专门用于处理异步操作的</li><li><code>Generator</code>并不是为异步而设计出来的，它还有其他功能（对象迭代、控制输出、部署<code>Interator</code>接口...）</li><li><code>promise</code>编写代码相比<code>Generator</code>、<code>async</code>更为复杂化，且可读性也稍差</li><li><code>Generator</code>、<code>async</code>需要与<code>promise</code>对象搭配处理异步情况</li><li><code>async</code>实质是<code>Generator</code>的语法糖，相当于会自动执行<code>Generator</code>函数</li><li><code>async</code>使用上更为简洁，将异步代码以同步的形式进行编写，是处理异步编程的最终方案</li></ul>
<h3>8.Proxy</h3>
<p>一、定义</p>
<ul><li>用于定义基本操作的自定义行为</li></ul>
<p>二、本质</p>
<p>1、修改的是程序默认形为，就形同于在编程语言层面上做修改，属于元编程<code>(meta programming)</code></p>
<p>2、<code>Proxy</code> 亦是如此，用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）</p>
<p>三、用法</p>
<p>1、<code>Proxy</code>为 构造函数，用来生成 <code>Proxy</code>实例</p>
<pre><code>var proxy = new Proxy(target, handler)
</code></pre>
<p>2、参数：</p>
<ul><li><code>target</code>表示所要拦截的目标对象（任何类型的对象，包括原生数组，函数，甚至另一个代理））</li><li><code>handler</code>通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 <code>p</code> 的行为</li></ul>
<p>四、使用场景</p>
<p>1、<code>Proxy</code>其功能非常类似于设计模式中的代理模式，常用功能如下：</p>
<ul><li>拦截和监视外部对对象的访问</li><li>降低函数或类的复杂度</li><li>在复杂操作前对操作进行校验或对所需资源进行管理</li></ul>
<p>2、使用 <code>Proxy</code> 保障数据类型的准确性：</p>
<ul><li>声明了一个私有的 <code>apiKey</code>，便于 <code>api</code> 这个对象内部的方法调用，但不希望从外部也能够访问 <code>api._apiKey</code></li></ul>
<p>3、观察者模式（Observer mode）指的是函数自动观察数据对象，一旦对象有变化，函数就会自动执行：</p>
<ul><li><code>observable</code>函数返回一个原始对象的 <code>Proxy</code>代理，拦截赋值操作，触发充当观察者的各个函数</li></ul>
<p>4、观察者函数都放进<code>Set</code>集合，当修改<code>obj</code>的值，在会<code>set</code>函数中拦截，自动执行<code>Set</code>所有的观察者</p>
<h3>9.Module</h3>
<p>一、定义</p>
<p>1、模块：</p>
<ul><li>是能够单独命名并独立地完成一定功能的程序语句的集合（即程序代码和数据结构的集合体）</li></ul>
<p>2、原因：</p>
<ul><li>变量和方法不容易维护，容易污染全局作用域</li><li>加载资源的方式通过script标签从上到下。</li><li>依赖的环境主观逻辑偏重，代码较多就会比较复杂。</li><li>大型项目资源难以维护，特别是多人合作的情况下，资源的引入会让人奔溃</li></ul>
<p>二、方案</p>
<p>1、CommonJs（典型代表：node.js早期）：</p>
<ul><li>它通过 require 来引入模块，通过 module.exports 定义模块的输出接口</li><li>这种模块加载方案是服务器端的解决方案，它是以同步的方式来引入模块的</li><li>因为在服务端文件都存储在本地磁盘，所以读取非常快，所以以同步的方式加载没有问题</li><li>但如果是在浏览器端，由于模块的加载是使用网络请求，因此使用异步加载的方式更加合适</li></ul>
<p>2、AMD（典型代表：require.js）：</p>
<ul><li>这种方案采用异步加载的方式来加载模块，模块的加载不影响后面语句的执行</li><li>所有依赖这个模块的语句都定义在一个回调函数里，等到加载完成后再执行回调函数。require.js 实现了 AMD 规范</li></ul>
<p>3、CMD（典型代表：sea.js）：</p>
<ul><li>这种方案和 AMD 方案都是为了解决异步模块加载的问题，sea.js 实现了 CMD 规范</li><li>它和require.js的区别在于模块定义时对依赖的处理不同和对依赖模块的执行时机的处理不同</li></ul>
<p>4、ES6 Module：</p>
<ul><li>ES6 提出的方案，使用 import 和 export 的形式来导入导出模块</li></ul>
<h3>10.Decorator</h3>
<p>一、定义</p>
<p>1、Decorator，即装饰器，从名字上很容易让我们联想到装饰者模式：</p>
<ul><li>简单来讲，装饰者模式就是一种在不改变原类和使用继承的情况下，动态地扩展对象功能的设计理论</li></ul>
<p>2、<code>ES6</code>中<code>Decorator</code>功能亦如此，其本质也不是什么高大上的结构，就是一个普通的函数，用于扩展类属性和类方法：</p>
<ul><li>代码可读性变强了，装饰器命名相当于一个注释</li><li>在不改变原有代码情况下，对原来功能进行扩展</li></ul>
<p>二、用法</p>
<p>1、类的装饰：当对类本身进行装饰的时候，能够接受一个参数，即类本身</p>
<p>2、类属性的装饰：当对类属性进行装饰的时候，能够接受三个参数</p>
<ul><li>类的原型对象</li><li>需要装饰的属性名</li><li>装饰属性名的描述对象</li></ul>
<p>3、注意：装饰器不能用于修饰函数，因为函数存在变量声明情况</p>
<p>三、使用场景</p>
<p>1、基于<code>Decorator</code>强大的作用，我们能够完成各种场景的需求，下面简单列举几种</p>
<p>2、使用<code>react-redux</code>的时候，如果写成下面这种形式，既不雅观也很麻烦：</p>
<pre><code>class MyReactComponent extends React.Component {}
​
export default connect(mapStateToProps, mapDispatchToProps)(MyReactComponent);
</code></pre>
<p>3、通过装饰器就变得简洁多了：</p>
<pre><code>@connect(mapStateToProps, mapDispatchToProps)
export default class MyReactComponent extends React.Component {}
</code></pre>
<p>4、将<code>mixins</code>，也可以写成装饰器，让使用更为简洁了：</p>
<pre><code>function mixins(...list) {
  return function (target) {
    Object.assign(target.prototype, ...list);
  };
}
​
// 使用
const Foo = {
  foo() { console.log('foo') }
};
​
@mixins(Foo)
class MyClass {}
​
let obj = new MyClass();
obj.foo() // "foo"
</code></pre>
<h2>结尾</h2>
<ul><li>好了，本篇的所有内容就到这里了，希望大家能够在未来的日子里学以致用！</li></ul>
</div>
</div>