<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<p><strong>目录</strong></p>
<p style="margin-left:0px;"><a href="#%E5%85%A5%E5%9D%91rc%E8%BD%A6%E7%9A%84%E6%88%91%E5%8F%88%E6%9D%A5%E5%86%99%E6%96%87%E5%95%A6%E3%83%BE%28%E2%89%A7%E2%96%BD%E2%89%A6*%29o">入坑rc车的我又来写文啦ヾ(≧▽≦*)o</a></p>
<p style="margin-left:0px;"><a href="#%E9%A6%96%E5%85%88%EF%BC%8C%E5%92%B1%E4%BB%AC%E6%90%9E%E6%B8%85%E6%A5%9ASTL%E5%BA%93%E6%98%AF%E5%95%A5%E4%B8%9C%E8%A5%BF%EF%BC%88%E5%A4%A7%E4%BD%AC%E5%BE%80%E4%B8%8B%E7%9C%8B%EF%BC%89">首先，咱们搞清楚STL库是啥东西</a></p>
<p style="margin-left:0px;"><a href="#One.%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%28Sort%29%3A">One.快速排序(Sort):</a></p>
<p style="margin-left:40px;"><a href="#Sort%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%3A">1.Sort的基本用法:</a></p>
<p style="margin-left:40px;"><a href="#Sort%E8%BF%9B%E9%98%B6%E7%94%A8%E6%B3%95%EF%BC%88CMP%EF%BC%89%EF%BC%9A">2.Sort进阶用法（CMP）：</a></p>
<p style="margin-left:40px;"><a href="#3.Sort%E5%AF%B9%E7%BB%93%E6%9E%84%E4%BD%93%28%E6%88%96%E8%80%85%E7%B1%BB%29%E7%9A%84%E6%8E%92%E5%BA%8F%EF%BC%9A">3.Sort对结构体(或者类)的排序：</a></p>
<p style="margin-left:0px;"><a href="#Two.Map">Two.Map</a></p>
<p style="margin-left:40px;"><a href="#Map%E7%AE%80%E4%BB%8B%3A">Map简介:</a></p>
<p style="margin-left:80px;"><a href="#%E5%AE%9A%E4%B9%89%EF%BC%9A">定义：</a></p>
<p style="margin-left:80px;"><a href="#%E4%B8%BE%E4%B8%AA%E6%A0%97%E5%AD%90%3A">举个栗子:</a></p>
<p style="margin-left:0px;"><a href="#%E5%88%B7%E9%A2%98%E6%97%B6%E9%97%B4!">刷题时间!</a></p>
<p style="margin-left:40px;"><a href="#%C2%A0%E7%A6%BB%E6%95%A3%E5%8C%96%E5%9F%BA%E7%A1%80%3A"> 题目：离散化基础</a></p>
<p style="margin-left:80px;"><a href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F">输入格式</a></p>
<p style="margin-left:80px;"><a href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F">输出格式</a></p>
<p style="margin-left:80px;"><a href="#%E8%BE%93%E5%85%A5%2F%E8%BE%93%E5%87%BA%E4%BE%8B%E5%AD%901">输入/输出例子1</a></p>
<p style="margin-left:40px;"><a href="#%E9%A2%98%E8%A7%A3%3A">题解:</a></p>
<p style="margin-left:0px;"><a href="#Three.stack%28%E6%A0%88%29">Three.stack(栈)</a></p>
<p style="margin-left:40px;"><a href="#%E6%A0%88%E7%9A%84%E4%BB%8B%E7%BB%8D%EF%BC%9A">栈的介绍：</a></p>
<p style="margin-left:40px;"><a href="#%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%9A">栈的定义：</a></p>
<p style="margin-left:40px;"><a href="#%E6%A0%88%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%EF%BC%9A">栈的成员函数：</a></p>
<p style="margin-left:0px;"><a href="#Four.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE">Four.二分查找</a></p>
<p style="margin-left:40px;"><a href="#%E7%BE%8E%E5%A6%99%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%9A">美妙的函数：</a></p>
<p style="margin-left:80px;"><a href="#1.lower_bound%E5%87%BD%E6%95%B0">1.lower_bound函数</a></p>
<p style="margin-left:80px;"><a href="#2.upper_bound%E5%87%BD%E6%95%B0">2.upper_bound函数</a></p>
<p style="margin-left:80px;"><a href="#3.binary_search%EF%BC%9A%E6%9F%A5%E6%89%BE%E6%95%B0%E7%BB%84%E5%86%85%E6%9F%90%E4%B8%AA%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6%E5%87%BA%E7%8E%B0%E3%80%82">3.binary_search：查找数组内某个元素是否出现。</a></p>
<p style="margin-left:0px;"><a href="#%E5%86%8D%E6%9D%A5%E4%B8%80%E9%A2%98%EF%BC%81">再来一题！</a></p>
<p style="margin-left:0px;"><a href="#%E2%80%8B%C2%A0">​ </a></p>
<p style="margin-left:40px;"><a href="#%E9%A2%98%E7%9B%AE%EF%BC%9A%E6%95%B0%E7%BB%84%E7%BA%BF%E6%AE%B5%E5%92%8CM">题目：数组线段和M</a></p>
<p style="margin-left:80px;"><a href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F">输入格式</a></p>
<p style="margin-left:80px;"><a href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F">输出格式</a></p>
<p style="margin-left:80px;"><a href="#%E8%BE%93%E5%85%A5%2F%E8%BE%93%E5%87%BA%E4%BE%8B%E5%AD%901">输入/输出例子1</a></p>
<p style="margin-left:40px;"><a href="#%E9%A2%98%E8%A7%A3%EF%BC%9A">题解：</a></p>
<p style="margin-left:0px;"><a href="#Six.list%28%E9%93%BE%E8%A1%A8%29">Six.list(链表)</a></p>
<p style="margin-left:40px;"><a href="#%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0%EF%BC%9A">常用操作函数：</a></p>
<p style="margin-left:40px;"><a href="#list%E7%9A%84%E5%AE%9A%E4%B9%89">list的定义</a></p>
<p style="margin-left:0px;"><a href="#%E3%83%BD%28%EF%BF%A3%CF%89%EF%BF%A3%28%EF%BF%A3%CF%89%EF%BF%A3%E3%80%83%29%E3%82%9D%E4%BB%8A%E5%A4%A9%E5%B0%B1%E5%88%B0%E8%BF%99%EF%BC%8C%E5%A4%A7%E5%AE%B6%E5%86%8D%E8%A7%81%EF%BC%81%E3%80%82">ヽ(￣ω￣(￣ω￣〃)ゝ今天就到这，大家再见！。</a></p>
<hr/>
<p> </p>
<p> </p>
<p> </p>
<h1>入坑rc车的我又来写文啦ヾ(≧▽≦*)o</h1>
<blockquote>
<p>要“深入探讨”的可以加我qq28562939</p>
<p>想必经常搞C++的人大概都听说过STL库吧(正好最近在研究)，其中最知名我就是我们的——sort快速排序了！</p>
<p>不了解的兄弟也没关系，</p>
<p>我们继续往下看。</p>
<p style="text-align:center;"><img alt="971a71db51780b6ae7e37c02d9491cba.png" src="https://img-blog.csdnimg.cn/img_convert/971a71db51780b6ae7e37c02d9491cba.png"/></p>
<p> 难度逐次递增。</p>
</blockquote>
<p> </p>
<h1>首先，咱们搞清楚STL库是啥东西</h1>
<blockquote>
<p>STL,学名Standard Template Library，一般我们称他为标准模板库，是一系列软件的统称。</p>
<p>从根本上说，STL是一些“容器”的集合，这些“容器”有list,vector,set,map一大堆，STL也是算</p>
<p>法和其他一些组件的集合。比如说&lt;algorithm&gt;中sort函数、&lt;string&gt;中string类都</p>
<p>是STL的内容。</p>
</blockquote>
<p>STL库还有很多内容，比如：向量（vector）、栈（stack）、队列（queue）、优先队列</p>
<p>（priority_queue）、链表（list）、集合（set）、映射（map）等容器；min、max、swap</p>
<p>、sort、lower_bound、upper_bound 等算法，有的甚至都没人知道。ㄟ( ▔, ▔ )ㄏ</p>
<hr/>
<h1>One.快速排序(Sort):</h1>
<p>众所周知，c++有各种正常排序和奇葩的排序，比如说冒泡排序，时间复杂度为N(O^2)，就很离谱</p>
<p>是不是，随便排一个100000的元素的数组就超时。</p>
<p style="text-align:center;"><img alt="39fde83e8ab951081df3bfad24aca8bd.png" src="https://img-blog.csdnimg.cn/img_convert/39fde83e8ab951081df3bfad24aca8bd.png"/></p>
<p> </p>
<p>所以，咱们以后不用冒泡，用sort快排（弃暗投明）,时间复杂度为N*LogN，对一百万个数排序也不会超过1秒。</p>
<h2>1.Sort的基本用法:</h2>
<p>sort是STL自带的系统函数，它的格式是：</p>
<p>void sort(要排序元素的起始地址，要排序元素的结束地址，比较函数)；</p>
<p>这里可以省略比较函数，他是默认从小到大排序的（升序排序）</p>
<pre><code class="language-cpp">#include&lt;algorithm&gt;
#include&lt;iostream&gt;
using namespace std;
int main()
{
	int a[]={3,5,2,6,9,3,5};
	sort(a,a+7);//7是数组的元素个数，这里a为数组的开头，a+7就等于排序到数组的第七个元素
	for(int i=0;i&lt;6;i++)
		cout&lt;&lt;a[i]&lt;&lt;" ";
}
</code></pre>
<p>输出:</p>
<pre><code class="language-cpp">2 3 3 5 5 6</code></pre>
<h2>2.Sort进阶用法（CMP）：</h2>
<p>void sort(要排序元素的起始地址，要排序元素的结束地址，比较函数)；,没错又是他，这里我们发</p>
<p>现还有个比较函数没说，这个比较函数的作用就是可以自定义排序方式，比如降序排序。</p>
<p>定义：bool cmp(int x,int y).....，如果返回True那么x就排在y前面。</p>
<pre><code class="language-cpp">#include&lt;algorithm&gt;
#include&lt;iostream&gt;
using namespace std;
bool cmp(int x,int y)
{
	if(x&gt;y)return true;//降序
	return false;
}
int main()
{
	int a[]={3,5,2,6,9,3,5};
	sort(a,a+7,cmp);//7是数组的元素个数
	for(int i=0;i&lt;6;i++)
		cout&lt;&lt;a[i]&lt;&lt;" ";
}
</code></pre>
<p>输出：</p>
<pre><code>9 6 5 5 3 3</code></pre>
<h2>3.Sort对结构体(或者类)的排序：</h2>
<p>同学们进行干饭比赛，参赛队员分别为“法外狂徒张三”，“干饭者老八”以及王五同学，谁吃的更多谁就排在更前面，如果吃的一样多那么谁吃的老八汉堡多谁就排在更前面：</p>
<pre><code class="language-cpp">#include&lt;algorithm&gt;
#include&lt;iostream&gt;
using namespace std;
struct ganfan
{
	string name;
	int zongshu;
	int hanbao;
};
bool cmp(ganfan x,ganfan y)
{
	if(x.zongshu&gt;y.zongshu)return true;
	else if(x.hanbao&gt;y.hanbao&amp;&amp;x.zongshu==y.zongshu)//如果一样多那么比谁吃的汉堡多
	return false;
}
int main()
{
	ganfan a[3];
	a[0].name="zhangsan";a[0].zongshu=200;a[0].hanbao=6;
	a[1].name="laoba";a[1].zongshu=170;a[1].hanbao=13;
	a[2].name="wangwu";a[2].zongshu=170;a[2].hanbao=10;
	sort(a,a+3,cmp);
	for(int i=0;i&lt;3;i++)
		cout&lt;&lt;a[i].name&lt;&lt;" ";
}
</code></pre>
<p>输出：</p>
<pre><code>wangwu laoba zhangsan</code></pre>
<p>我们可以看到，张三的干饭总数是最多的，所以排在最前面，老八和王五的干饭总数一样多，但是老八吃的汉堡更多些，所以老八排在王五前面。</p>
<h1>Two.Map</h1>
<h2>Map简介:</h2>
<p>map是STL的一个关联容器，它提供一对一的<a href="https://so.csdn.net/so/search?q=hash&amp;spm=1001.2101.3001.7020" title="hash">hash</a>。</p>
<ul><li>第一个可以称为关键字(key)，每个关键字只能在map中出现一次；</li><li>第二个可能称为该关键字的值(value)；</li></ul>
<h3>定义：</h3>
<pre><code class="language-cpp">map&lt;类型,类型&gt; m;</code></pre>
<h3>举个栗子:</h3>
<p>记录每个人的名字的对应的爱好,张三喜欢吃汉堡：</p>
<pre><code class="language-cpp">#include&lt;map&gt;
#include&lt;iostream&gt;
using namespace std;
int main()
{
	map&lt;string,string&gt; m;
	m["张三"]="吃汉堡";
	cout&lt;&lt;"张三: "&lt;&lt;m["张三"]; 
}
</code></pre>
<p> 输出：</p>
<pre><code>张三: 吃汉堡</code></pre>
<p> </p>
<h1>刷题时间!</h1>
<p style="text-align:center;"><img alt="df2b8fc98dbf62e1e2f5863a43a8ecfc.png" src="https://img-blog.csdnimg.cn/img_convert/df2b8fc98dbf62e1e2f5863a43a8ecfc.png"/></p>
<h2> 题目：离散化基础</h2>
<p>在使用离散化方法编程时，通常要知道每个数排序后的编号(rank值)，相同的数对应同一个编号。</p>
<h3>输入格式</h3>
<p> </p>
<p>第1行：一个整数N。 1&lt;=N&lt;=100000。<br/> 第2行：有N个整数，每个数都是int范围的。注意：可能有相同整数。</p>
<p> </p>
<h3>输出格式</h3>
<p> </p>
<p>依次输出每个数的排名。</p>
<p> </p>
<h3>输入/输出例子1</h3>
<p>输入：</p>
<p>5<br/> 8 2 6 9 2</p>
<p>输出：</p>
<p>3 1 2 4 1</p>
<h2>题解:</h2>
<p>这题用Sort和Map就可以很容易解决:</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int N,a[100001],b[100001];
map&lt;int,int&gt; m;
int main(){
    
    cin&gt;&gt;N;
    for(int i=0;i&lt;N;i++)
    {
        cin&gt;&gt;a[i];
        b[i]=a[i];
    }
    sort(b,b+N);//将数组排序
    int c=1;//排名
    m[b[0]]=1;//因为数组经过排序，所以第1个元素肯定是第一
    for(int i=1;i&lt;N;i++)
    {
        if(b[i]!=b[i-1])//判断是否不与前一个数相等
        {
            c++;
            m[b[i]]=c;
        }
    }
    for(int i=0;i&lt;N;i++)
        if(m[a[i]]!=0)
            cout&lt;&lt;m[a[i]]&lt;&lt;" ";//按照原来的下标输出
    
    return 0;
}</code></pre>
<h1>Three.stack(栈)</h1>
<p>头文件:</p>
<pre><code class="language-cpp">#include&lt;stack&gt;</code></pre>
<p>stack好像还有个翻译叫“咸鱼”...嘿嘿。</p>
<h2>栈的介绍：</h2>
<blockquote>
<p>栈就像一个盒子，可以放入或去除元素，但是个人类都知道，<strong>要把盒子底下的东西取出来，就必须先取出他上面的东西。</strong></p>
</blockquote>
<p>假如我们把1、2、3、4、5按顺序分别<strong>入栈</strong>：</p>
<p style="text-align:center;"><img alt="04c131ebc812f96f01151e3a54b8f13c.png" src="https://img-blog.csdnimg.cn/img_convert/04c131ebc812f96f01151e3a54b8f13c.png"/></p>
<p>                                                                                                                         ——博主美丽的手绘 </p>
<h2>栈的定义：</h2>
<pre><code class="language-cpp">stack&lt;类型(可以不写)&gt; st;
或者stack st;</code></pre>
<p>很easy是不？</p>
<h2>栈的成员函数：</h2>
<table border="1" cellpadding="1" cellspacing="1" style="width:329px;"><tbody><tr><td>.empty()</td><td style="width:129px;">判断栈是否为空，空则返回true</td></tr><tr><td>.pop()</td><td style="width:129px;">移除栈顶元素</td></tr><tr><td>.push(啥啥啥)</td><td style="width:129px;">在栈顶增加元素</td></tr><tr><td>.size()</td><td style="width:129px;">返回栈中元素数目</td></tr><tr><td>.top()</td><td style="width:129px;">返回栈顶元素</td></tr></tbody></table>
<p>.empty()  判断栈是否为空。</p>
<pre><code class="language-cpp">stack st;
if(st.empty())//如果是空那么执行下面代码
    ......</code></pre>
<p> .push(啥啥啥),在栈顶增加元素。</p>
<p>.top()，返回栈顶元素，记住是返回，要单独输出。</p>
<pre><code class="language-cpp">#include&lt;stack&gt;
#include&lt;iostream&gt;
using namespace std;
stack&lt;int&gt; st;
int main(){
    
    st.push(5418);
    cout&lt;&lt;st.top();//输出栈顶元素
    return 0;
}</code></pre>
<p>输出5418。 </p>
<p>                                                    </p>
<hr/>
<p>.size(), 返回栈中元素数目。</p>
<pre><code class="language-cpp">#include&lt;stack&gt;
#include&lt;iostream&gt;
using namespace std;
stack&lt;int&gt; st;
int main(){
    
    st.push(5418);
    cout&lt;&lt;st.size();
    
    return 0;
}</code></pre>
<p>输出1 </p>
<hr/>
<p>.pop()，移除栈顶元素：</p>
<pre><code class="language-cpp">#include&lt;stack&gt;
#include&lt;iostream&gt;
using namespace std;
stack&lt;int&gt; st;
int main(){
    
    st.push(1452);
    st.push(5418);
    st.pop();
    cout&lt;&lt;st.top();
    
    return 0;
}</code></pre>
<p> 输出1452。</p>
<p> </p>
<p>简单不？</p>
<hr/>
<h1>Four.二分查找</h1>
<p>头文件：</p>
<pre><code class="language-cpp">#include &lt;algorithm&gt;</code></pre>
<h2>美妙的函数：</h2>
<h3>1.lower_bound函数</h3>
<blockquote>
<p>对于有序容器，有序容器，有序容器（重要的事情说三遍）快速二分查找出第一个大于等于</p>
<p>指定数的位置（下标），如果没有找到，返回最后一个数据后面的位置。</p>
</blockquote>
<p>  对于数组，通常的格式为：</p>
<p>查找的数组下标 = lower_bound(数组要查找的开始位置，数组要查找的结束位置后面，要找的数) – 数组开始位置(一般写数组名);</p>
<p>比如：</p>
<pre><code class="language-cpp">#include&lt;algorithm&gt;
#include&lt;iostream&gt;

using namespace std;

int main() {

    int a[5] = { 1,2,3,3,8 };

    //从 a 数组中找到第一个不小于   3 的元素

    int   index = lower_bound(a, a + 5, 3)-a;//查找的数组下标 = lower_bound(数组要查找的开始位置，数组要查找的结束位置后面，要找的数) – 数组开始位置;

    if   (index==5 ) cout &lt;&lt; " not found! ";//index=5，也就是数组末尾的位置。
    else  cout &lt;&lt; index;

    return   0;

}</code></pre>
<p> 输出2。</p>
<h3>2.upper_bound函数</h3>
<blockquote>
<p>有一个类似lower_bound的函数upper_bound, 快速二分查找出第一个大于指定数的位置（下</p>
<p>标），如果没有找到，返回最后一个数据后面的位置。</p>
</blockquote>
<p>举个栗子，啊......快没栗子了。(っ °Д °;)っ</p>
<pre><code class="language-cpp">#include&lt;algorithm&gt;
#include&lt;iostream&gt;

using namespace std;

int main() {

    int a[5] = { 1,2,3,3,8 };
    //从 a 数组中找到第一个大于 3 的元素

    int   index = upper_bound(a, a + 5, 3)-a;

    if   (index==5 ) cout &lt;&lt; " not found! ";
    else cout &lt;&lt; index;

    return   0;

}</code></pre>
<p> 输出4.</p>
<h3>3.binary_search：查找数组内某个元素是否出现。</h3>
<blockquote>
<p>void binary_search(数组首地址，结束地址，要查找的数)</p>
<p>返回值为bool类型，找到了返回true。</p>
</blockquote>
<p> </p>
<p> </p>
<h1>再来一题！</h1>
<h1 style="text-align:center;"><img alt="41392fe6aaffa9f5bc56fbe02133c7d1.png" src="https://img-blog.csdnimg.cn/img_convert/41392fe6aaffa9f5bc56fbe02133c7d1.png"/> </h1>
<h2>题目：数组线段和M</h2>
<h3>输入格式</h3>
<p> </p>
<p>  第一行2个正整数N和M，N范围[1，1000000],M范围[1，10^9]。</p>
<p>  第二行是N个正整数，每个数范围[1，1000]。</p>
<p> </p>
<p> </p>
<h3>输出格式</h3>
<p> </p>
<p>  一个整数。</p>
<p> </p>
<h3>输入/输出例子1</h3>
<p>输入：</p>
<p>10 20</p>
<p>1 7 10 10 7 10 6 4 6 6</p>
<p> </p>
<p>输出：</p>
<p>2</p>
<h2>题解：</h2>
<p>这题我是用<a class="link-info" href="https://blog.csdn.net/qq_52109814/article/details/119038243?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=C++%20%E5%89%8D%E7%BC%80%E5%92%8C&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-119038243.142%5Ev7%5Epc_search_result_control_group,157%5Ev4%5Econtrol&amp;spm=1018.2226.3001.4187" title="前缀和">前缀和</a>的方法解的，因为数据较多，这样快一点,还能变成有序数列。</p>
<p>代码稍稍有点难，大家看着办吧：</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int N,M;
int a[1000001];
int main(){
    
    cin&gt;&gt;N&gt;&gt;M;
    cin&gt;&gt;a[0];
    for(int i=1;i&lt;N;i++)
    {
        cin&gt;&gt;a[i];
        a[i]+=a[i-1];//求前缀和数组
    }
    int ans=0;
    int mubiao=M;//目标
    for(;int index = lower_bound(a, a + N, mubiao)-a;)
    {
        if(index==N)//找不到了说明没有了
        {
            break;
        }
        if(a[index]==M)
        {
            mubiao=a[index]+1;
        }
        else{
            int fl=a[index]-M;
            int ind=lower_bound(a, a + N, fl)-a;
            if(a[ind]==fl)
                ans++;
            mubiao=a[index]+1;//目标加一，防止重复查找
        }
    }
    cout&lt;&lt;ans;
    
    return 0;
}</code></pre>
<p>思路是找一个比M大的数，如果能找到，那么求出这个数和M的差，再找这个差，如果能找到，那根据前缀和的定义这一串的和就等于M，然后把目标+1，防止重复查找。</p>
<h1>Six.list(链表)</h1>
<h2>常用操作函数：</h2>
<p>List.assign() 给list赋值 </p>
<p><br/> List.back() 返回最后一个元素 </p>
<p><br/> List.begin() 返回指向第一个元素的迭代器 </p>
<p><br/> List.clear() 删除所有元素 </p>
<p><br/> List.empty() 如果list是空的则返回true </p>
<p><br/> List.end() 返回末尾的迭代器 </p>
<p><br/> List.erase() 删除一个元素 </p>
<p><br/> List.front() 返回第一个元素 </p>
<p><br/> List.get_allocator() 返回list的配置器 </p>
<p><br/> List.insert() 插入一个元素到list中 </p>
<p><br/> List.max_size() 返回list能容纳的最大元素数量 </p>
<p><br/> List.merge() 合并两个list </p>
<p><br/> List.pop_back() 删除最后一个元素 </p>
<p><br/> List.pop_front() 删除第一个元素 </p>
<p><br/> List.push_back() 在list的末尾添加一个元素 </p>
<p><br/> List.push_front() 在list的头部添加一个元素 </p>
<p><br/> List.rbegin() 返回指向第一个元素的逆向迭代器 </p>
<p><br/> List.remove() 从list删除元素 </p>
<p><br/> List.remove_if() 按指定条件删除元素 </p>
<p><br/> List.rend() 指向list末尾的逆向迭代器 </p>
<p><br/> List.resize() 改变list的大小 </p>
<p><br/> List.reverse() 把list的元素倒转 </p>
<p><br/> List.size() 返回list中的元素个数 </p>
<p><br/> List.sort() 给list排序 </p>
<p><br/> List.splice() 合并两个list </p>
<p><br/> List.swap() 交换两个list的内容</p>
<p><br/> List.unique() 删除list中相邻重复的元素</p>
<hr/>
<h2>list的定义</h2>
<pre><code class="language-cpp">list&lt;int&gt; lst1;          //创建一个空list

list&lt;int&gt; lst2(10);       //创建一个含有10个元素的list

list&lt;int&gt; lst3(3,2);  //创建含有3个元素2的list

list&lt;int&gt; lst4(lst2);    //使用lst2初始化lst4

list&lt;int&gt; lst5(lst2.begin(),lst2.end());  //同lst4</code></pre>
<p>部分内容与栈那篇差不多，我们不讲。</p>
<p> </p>
<h1>ヽ(￣ω￣(￣ω￣〃)ゝ今天就到这，大家再见！。</h1>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
</div>
</div>