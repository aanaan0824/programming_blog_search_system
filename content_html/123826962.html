<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<p><strong>目录</strong></p>
<p style="margin-left:0px;"> </p>
<p style="margin-left:0px;"><a href="#%E5%93%88%E5%96%BD%F0%9F%98%86">哈喽😆</a></p>
<p style="margin-left:0px;"><a href="#%E7%A9%BF%E6%A2%AD%E9%97%A8">穿梭门</a></p>
<p style="margin-left:0px;"><a href="#%E6%95%88%E6%9E%9C%F0%9F%A7%90">效果🧐</a></p>
<p style="margin-left:0px;"><a href="#%E6%A1%B6%E6%8E%92%E5%BA%8F%E6%98%AF%E4%BB%80%E4%B9%88%F0%9F%92%A1">桶排序是什么💡</a></p>
<p style="margin-left:0px;"><a href="#%F0%9F%A4%94%E5%86%8D%E7%AE%80%E5%8D%95%E7%82%B9%E8%AF%B4">🤔再简单点说</a></p>
<p style="margin-left:0px;"><a href="#%F0%9F%91%80%E5%86%8D%E5%86%8D%E7%AE%80%E5%8D%95%E7%82%B9%E8%AF%B4">👀再再简单点说</a></p>
<p style="margin-left:0px;"><a href="#%E6%80%9D%E8%B7%AF">思路</a></p>
<p style="margin-left:0px;"><a href="#%E7%A1%AE%E5%AE%9A%E2%80%9C%E5%88%86%E6%A1%B6%E2%80%9D%E4%B8%AA%E6%95%B0%F0%9F%94%8D">确定“分桶”个数🔍</a></p>
<p style="margin-left:0px;"><a href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%F0%9F%98%90">复杂度分析😐</a></p>
<p style="margin-left:0px;"><a href="#c%2B%2B%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">c++代码实现</a></p>
<p style="margin-left:0px;"><a href="#python%E7%89%88%E4%BB%A3%E7%A0%81%28%E5%98%BF%E5%98%BF%EF%BC%8C%E6%B2%A1%E6%83%B3%E5%88%B0%E5%90%A7%29">python版代码(嘿嘿，没想到吧)</a></p>
<p style="margin-left:0px;"><a href="#%E6%9C%80%E5%90%8E">最后</a></p>
<hr/>
<p> </p>
<h1>哈喽😆</h1>
<p>这次来发一下桶排序，它的时间复杂度低，代码也不难</p>
<h1>穿梭门</h1>
<p><a href="https://blog.csdn.net/m0_64036070/article/details/123804075?utm_source=app&amp;app_version=5.3.0" title="二分算法">二分算法</a></p>
<p><a href="https://blog.csdn.net/m0_64036070/article/details/123770678?utm_source=app&amp;app_version=5.3.0" title="堆排序">堆排序</a></p>
<h1>效果🧐</h1>
<p style="text-align:center;"><img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETkBZUl9U,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/c18ee5d2e3d643e8b1a2c4703de5444c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETkBZUl9U,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<p>就是排序</p>
<p>所以说，还是比较简单滴 </p>
<p style="text-align:center;"><img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETkBZUl9U,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/45c01775f2954648a65378d9ee1ddce7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETkBZUl9U,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<h1>桶排序是什么💡</h1>
<blockquote>
<p>桶排序是计数排序的升级版，也是分治算法。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：<strong>假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。简言之，将值为i的元素放入i号桶，最后依次把桶里的元素倒出来。</strong><br/> 怎么样，是不是很“简单”？                  </p>
</blockquote>
<p>还有这张一看就头疼的图</p>
<p style="text-align:center;"><img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETkBZUl9U,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/791166833ec54015845660c445e020c1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETkBZUl9U,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<p> </p>
<p><img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETkBZUl9U,size_15,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/734a8e7d1fa0465aa07d5e7242b0bc1c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETkBZUl9U,size_15,color_FFFFFF,t_70,g_se,x_16"/>                       </p>
<p> 🤔🤔🤔🤔🤔🤔🤔🤔🤔🤔🤔🤔🤔🤔🤔🤔🤔🤔🤔</p>
<h1>🤔再简单点说</h1>
<p>桶排序的基本思想是假设数据在[min,max]之间均匀分布，其中min、max分别指数据中的最小值和最大值。那么将区间[min,max]等分成n份，这n个区间便称为n个桶。将数据加入对应的桶中，然后每个桶内单独排序。由于桶之间有大小关系，因此可以从大到小(或从小到大)将桶中元素放入到数组中。</p>
<h1>👀再再简单点说</h1>
<p>简单说，你有一个数组1 , 3 , 7 , 77 ，100 ，234</p>
<p>比如，</p>
<p>你把一位数、两位数和三位数分到3个桶里，</p>
<p>各自排完序再合到一起</p>
<p>排序前：1 , 3 , 7 , 77 ，100 ，234</p>
<p>一位数：1、7、3</p>
<p>两位数：77</p>
<p>三位数：100、234</p>
<p>排序后：</p>
<p>一位数：1、3、7</p>
<p>两位数：77</p>
<p>三位数：100、234</p>
<p>合起来：1、3、7、77、100、234 </p>
<h1>思路</h1>
<p><strong>1.</strong><em>设置一个定量的数组当作空桶子。</em><br/><strong>2</strong>.<em>寻访序列，并且把项目一个一个放到对应的桶子去。</em><br/><strong>3.</strong><em>对每个非空的桶子进行排序。</em><br/><strong>4.</strong><em>从不是空的桶子里把项目再放回原来的序列中。</em></p>
<h1>确定“分桶”个数🔍<br/>  </h1>
<p>假如要对数组arr={ 2,0,1,6,8,10,5,99,87,333,2,0,1 }排序，假设需要桶的个数为bucketNum=std::ceil(size/3)，向上取整，反之桶个数不够映射时越界。</p>
<h1>复杂度分析😐</h1>
<p><br/> 桶排序实际上只需要遍历一遍所有的待排序元素，然后依次放入指定的位置，如果加上输出排序的时间，那么需要遍历所有的桶，时间复杂度为O(n+m)，其中n为待排序元素的个数，m为桶的个数，这时相当快的排序算法，但是，对于空间的小号来说太大了。当n越大，空间浪费就越大，所以，如果数据跨度过大，桶排序并不适用跨度范围大的排序。</p>
<h1>c++代码实现</h1>
<p>直接放代码，如果你报错了，就把前面的万能头文件改了</p>
<p>c++版(devc++无报错无警告)</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;

// 打印数组
void print_array(int *arr, int n) {
    if(n==0){
        printf("ERROR: Array length is ZERO\n");
        return;
    }
    printf("%d", arr[0]);
    for (int i=1; i&lt;n; i++) 
        printf(" %d", arr[i]);
    printf("\n");
}


int* sort_array(int *arr, int n) {
    int i;
	int maxValue = arr[0];
	for (i = 1; i &lt; n; i++) 
		if (arr[i] &gt; maxValue)  // 输入数据的最大值
			maxValue = arr[i]; 
	
	// 设置10个桶，依次0，1，，，9
	const int bucketCnt = 10;
	vector&lt;int&gt; buckets[bucketCnt];
	// 桶的大小bucketSize根据数组最大值确定：比如最大值99， 桶大小10
	// 最大值999，桶大小100
	// 根据最高位数字映射到相应的桶，映射函数为 arr[i]/bucketSize
	int bucketSize = 1;
	while (maxValue) {		//求最大尺寸 
		maxValue /= 10;
		bucketSize *= 10;
	}
	bucketSize /= 10;		//桶的个数 
	// 入桶
	for (int i=0; i&lt;n; i++) {
		int idx = arr[i]/bucketSize;			//放入对应的桶 
		buckets[idx].push_back(arr[i]);
		// 对该桶使用插入排序(因为数据过少，插入排序即可)，维持该桶的有序性
		for (int j=int(buckets[idx].size())-1; j&gt;0; j--) {
			if (buckets[idx][j]&lt;buckets[idx][j-1]) {
				swap(buckets[idx][j], buckets[idx][j-1]);
			}
		}
	}
	// 顺序访问桶，得到有序数组
	for (int i=0, k=0; i&lt;bucketCnt; i++) {
		for (int j=0; j&lt;int(buckets[i].size()); j++) {
			arr[k++] = buckets[i][j];
		}
	}
	return arr;
}



int main() {
    int n;
    scanf("%d", &amp;n);
    
    int *arr;
    arr = (int*)malloc(sizeof(int)*n);
    
    for (int i=0; i&lt;n; i++) scanf("%d", &amp;arr[i]);
    
    arr = sort_array(arr, n);
    
    print_array(arr, n);
    
    system("pause"); 
    return 0;
}
</code></pre>
<h1>python版代码(嘿嘿，没想到吧)</h1>
<pre><code class="language-python">def bucketSort(nums):
    # 选择一个最大的数
    max_num = max(nums)
    # 创建一个元素全是0的列表, 当做桶
    bucket = [0]*(max_num+1)
    # 把所有元素放入桶中, 即把对应元素个数加一
    for i in nums:
        bucket[i] += 1
 
    # 存储排序好的元素
    sort_nums = []
    # 取出桶中的元素
    for j in range(len(bucket)):
        if bucket[j] != 0:
            for y in range(bucket[j]):
                sort_nums.append(j)
 
    return sort_nums
 
nums = [5,6,3,2,1,65,2,0,8,0]
print bucketSort(nums)
 
"""
[0, 0, 1, 2, 2, 3, 5, 6, 8, 65]
"""</code></pre>
<h1>最后</h1>
<p>今天想给大家推荐一本书</p>
<p><img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETkBZUl9U,size_20,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/b40e74529fe744c2949daaf0646b0dbf.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETkBZUl9U,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<p><img alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAWVJfVA==,size_15,color_FFFFFF,t_70,g_se,x_16" src="https://img-blog.csdnimg.cn/896a242d5dcb41e4ac662ad2f6a9c738.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAWVJfVA==,size_15,color_FFFFFF,t_70,g_se,x_16"/></p>
<p> </p>
<p> 互粉必回！   白白👋</p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
</div>
</div>