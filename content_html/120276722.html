<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="htmledit_views" id="content_views">
<p><strong>前言：本文章将带你刷8道比较有意思的指针笔试题，笔者将由深入浅出解析这些题目！必要的题目，作者已经加上内存布局图！希望本文对你有所帮助！</strong></p>
<hr/>
<p> <strong>目录</strong></p>
<p id="%E4%B8%80.%E7%AC%94%E8%AF%95%E9%A2%981%20-%E6%8C%87%E9%92%88%E4%B8%8E%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%85%B3%E7%B3%BB-%E5%80%BC-toc" style="margin-left:80px;"><a href="#%E4%B8%80.%E7%AC%94%E8%AF%95%E9%A2%981%20-%E6%8C%87%E9%92%88%E4%B8%8E%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%85%B3%E7%B3%BB-%E5%80%BC" title="一.笔试题1 -指针与一维数组的关系-值">一.笔试题1 -指针与一维数组的关系-值</a></p>
<p id="%E4%BA%8C.%E7%AC%94%E8%AF%95%E9%A2%982-%E6%8C%87%E9%92%88%E4%B8%8E%E7%BB%93%E6%9E%84%E4%BD%93-toc" style="margin-left:80px;"><a href="#%E4%BA%8C.%E7%AC%94%E8%AF%95%E9%A2%982-%E6%8C%87%E9%92%88%E4%B8%8E%E7%BB%93%E6%9E%84%E4%BD%93" title="二.笔试题2-指针与结构体">二.笔试题2-指针与结构体</a></p>
<p id="%E4%B8%89.%E7%AC%94%E8%AF%95%E9%A2%983-%E6%8C%87%E9%92%88%E4%B8%8E%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%85%B3%E7%B3%BB-%E5%9D%80-toc" style="margin-left:80px;"><a href="#%E4%B8%89.%E7%AC%94%E8%AF%95%E9%A2%983-%E6%8C%87%E9%92%88%E4%B8%8E%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%85%B3%E7%B3%BB-%E5%9D%80" title="三.笔试题3-指针与一维数组的关系-址">三.笔试题3-指针与一维数组的关系-址</a></p>
<p id="%E5%9B%9B.%E7%AC%94%E8%AF%95%E9%A2%984-%E6%8C%87%E9%92%88%E4%B8%8E%E9%80%97%E5%8F%B7%E8%A1%A8%E8%BE%BE%E5%BC%8F-toc" style="margin-left:80px;"><a href="#%E5%9B%9B.%E7%AC%94%E8%AF%95%E9%A2%984-%E6%8C%87%E9%92%88%E4%B8%8E%E9%80%97%E5%8F%B7%E8%A1%A8%E8%BE%BE%E5%BC%8F" title="四.笔试题4-指针与逗号表达式">四.笔试题4-指针与逗号表达式</a></p>
<p id="%E4%BA%94.%E7%AC%94%E8%AF%95%E9%A2%985-%E6%8C%87%E9%92%88%E4%B8%8E%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84-toc" style="margin-left:80px;"><a href="#%E4%BA%94.%E7%AC%94%E8%AF%95%E9%A2%985-%E6%8C%87%E9%92%88%E4%B8%8E%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84" title="五.笔试题5-指针与二维数组">五.笔试题5-指针与二维数组</a></p>
<p id="%E5%85%AD.%E7%AC%94%E8%AF%95%E9%A2%986-%E6%8C%87%E9%92%88%E4%B8%8E%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84-toc" style="margin-left:80px;"><a href="#%E5%85%AD.%E7%AC%94%E8%AF%95%E9%A2%986-%E6%8C%87%E9%92%88%E4%B8%8E%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84" title="六.笔试题6-指针与二维数组">六.笔试题6-指针与二维数组</a></p>
<p id="%E4%B8%83.%E7%AC%94%E8%AF%95%E9%A2%987-%E6%8C%87%E9%92%88%E4%B8%8E%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84-toc" style="margin-left:80px;"><a href="#%E4%B8%83.%E7%AC%94%E8%AF%95%E9%A2%987-%E6%8C%87%E9%92%88%E4%B8%8E%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84" title="七.笔试题7-指针与字符指针数组">七.笔试题7-指针与字符指针数组</a></p>
<p id="%E5%85%AB.%E7%AC%94%E8%AF%95%E9%A2%989-%E6%8C%87%E9%92%88%E4%B8%8E%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84(%E9%9A%BE)-toc" style="margin-left:80px;"><a href="#%E5%85%AB.%E7%AC%94%E8%AF%95%E9%A2%989-%E6%8C%87%E9%92%88%E4%B8%8E%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%28%E9%9A%BE%29" title="八.笔试题9-指针与字符指针数组(难)">八.笔试题9-指针与字符指针数组(难)</a></p>
<hr id="hr-toc"/>
<h3>一.笔试题1 -指针与一维数组的关系-值</h3>
<pre><code>int main()
{
    int a[5] = { 1, 2, 3, 4, 5 };
    int *ptr = (int *)(&amp;a + 1);	//&amp;a：取出整个数组的地址，&amp;a+1：跳过一个数组
    //&amp;a的类型为：数组指针  int(*)[5] 			所以要强转
    
    //a为数组名，首元素地址，即为1的地址，+1，跳过一个元素，即为2的地址
    printf( "%d,%d", *(a + 1), *(ptr - 1));  // 2  5
    return 0;
}</code></pre>
<hr/>
<p>图解：<img alt="" height="250" src="image\20210913220920908.png" width="371"/> </p>
<hr/>
<h2> 二.笔试题2-指针与结构体</h2>
<pre><code>//这里告知结构体的大小是20个字节
struct Test
{
    int Num;
    char *pcName;
    short sDate;
    char cha[2];
    short sBa[4];
}*p;
//假设p 的值为0x100000。 如下表表达式的值分别为多少？
int main()
{
    p = 0x00100000;
    //0x1--&gt;对应的值就是1  相当于0x00000001
    printf("%p\n", p + 0x1);//p为结构体指针，指向一个结构体，+1，跳过一个结构体，即跳过20个字节，
    //   0x00100000+20 -&gt; 0x00100020 错误，  要将20转化为16进制再加，或者将16进制0x00100000转化为10进制之后加上20，然后再转化为16进制
    // 20-&gt; 0X00000014 
    //所以最终结果为：0x00100014
    printf("%p\n", (unsigned long)p + 0x1);//将p转化为长整形，+1，即为整形+1，  例如：500+1= 501，
    //所以结果为： 0x00100001
    printf("%p\n", (unsigned int*)p + 0x1);
    //将p强转为无符号整形，+1跳过一个整形-&gt;跳过4个字节
    //所以结果为：0x00100004
    return 0;
}</code></pre>
<p><strong>注意坑点：整数+1 -&gt;跳过一个字节  执行普通的加减运算</strong></p>
<p><strong>       而整形指针+1 -&gt;跳过四个字节 </strong></p>
<p><span style="color:#fe2c24;"><strong>指针+1 的步长取决于指针指向的数据的类型</strong></span></p>
<hr/>
<h3>三.笔试题3-指针与一维数组的关系-址</h3>
<pre><code>int main()
{
    int a[4] = { 1, 2, 3, 4 };
    int *ptr1 = (int *)(&amp;a + 1);
    int *ptr2 = (int *)((int)a + 1);
    printf( "%x,%x", ptr1[-1], *ptr2);	// 4 2000000
    return 0;
}</code></pre>
<blockquote>
<p>解析： </p>
<p><strong>int *ptr1 = (int *)(&amp;a + 1)</strong>:  取出数组的地址+1，跳过一个数组，因为&amp;a的类型为数组指针：int(*)[4] 类型不匹配，所以强转为int类型</p>
<p>prt1[-1]==&gt; *(ptr1+（-1)）==&gt;*(ptr1-1)</p>
<p>-------------------------------------------------------------------------------------------------------</p>
<p><strong>int *ptr2 = (int *)((int)a + 1)</strong></p>
<p>此时的a代表的首元素地址，<span style="color:#be191c;">地址值是一个常量，</span></p>
<p><span style="color:#e6b223;">整数+1：相当于跳过一个字节</span></p>
<p>所以应该画出数组的整体字节布局，注意要考虑<strong><span style="color:#ff9900;">小端存放</span>，<span style="color:#fe2c24;">读取时倒着读取的问题</span></strong></p>
<p><img alt="" height="286" src="image\20210913221439852.png" width="674"/></p>
<p><strong>ptr2是整形指针，解引用向后访问4个字节</strong></p>
<p><strong>所以ptr2指向的是00 00 00 02这四个字节</strong></p>
<p><strong>要倒着拿：所以打印结果为：02000000</strong></p>
</blockquote>
<p>图解：</p>
<p><img alt="" height="266" src="image\20210913221237918.png" width="614"/></p>
<p>注意点：<strong>整形+1：加一个字节</strong>    如：500+1 = 501  </p>
<p>           <strong>   整形指针+1：跳过(加)4个字节</strong></p>
<hr/>
<h2> 四.笔试题4-指针与逗号表达式 </h2>
<pre><code>int main()
{
   int a[3][2] = { (0, 1), (2, 3), (4, 5) };
   int *p;
   p = a[0];
   printf("%d ",p[0]);	//1
   return 0;
}</code></pre>
<p><strong>坑点：<span style="color:#fe2c24;">逗号表达式-结果为最后一个表达式的结果</span></strong></p>
<p>图解：<img alt="" height="340" src="image\2021091322205932.png" width="641"/> </p>
<p><strong>所以相当于只初始化了前三个元素，后面的元素未初始化，默认为0  </strong></p>
<blockquote>
<p>解析：</p>
<p>a[0] : 二维数组第一行的数组名，在这里是首元素地址，即第一行第一个元素的地址</p>
<p>p[0] ==&gt;*(p+0)==&gt;*p</p>
<p>p是整形指针，解引用向后访问4个字节</p>
</blockquote>
<p><img alt="" height="266" src="image\20210913222449401.png" width="511"/>  </p>
<hr/>
<h3>五.笔试题5-指针与二维数组</h3>
<pre><code>int main()
{
    int a[5][5];
    int(*p)[4];
    p = a;
    printf( "%p,%d\n", &amp;p[4][2]-&amp;a[4][2], &amp;p[4][2]-&amp;a[4][2]);
    return 0;
}</code></pre>
<p><strong>注意：p是数组指针，指向的数组有4个元素</strong></p>
<p><span style="color:#fe2c24;"><strong>指针-指针得到的是二者之间的元素个数</strong></span></p>
<p><strong>p[4] = *(p+4)</strong></p>
<p><strong>p[4][2] ==&gt; *(*(p+4)+2)</strong></p>
<p>图解：</p>
<p><img alt="" height="342" src="image\20210913222622589.png" width="682"/></p>
<p><strong>&amp;p[4][2]为小地址，&amp;a[4][2]为大地址，小地址减大地址，所以最后结果为-4</strong>  </p>
<hr/>
<blockquote>
<p>-4：<br/> 原码：10000000 00000000 00000000 00000100<br/> 反码：11111111 11111111 11111111 11111011<br/> 补码：11111111 11111111 11111111 11111100</p>
</blockquote>
<p>使用%p方式打印：打印的是-4对应的补码 1111 1111 1111 1111 1111 1111 1111 1100 -&gt;结果为：FFFFFFFC</p>
<p><span style="color:#fe2c24;"><strong>整数在内存中以补码方式存储<em>，</em>打印地址和打印无符号整数一样，都是打印内存中补码</strong></span></p>
<p>使用%d方式打印：打印二进制补码对应的原码，=&gt;  -4</p>
<hr/>
<p><span style="color:#fe2c24;">注意</span>：<strong>a是二维数组，对应数组指针的类型为：int(*)[5]，指向的是有5个元素的一维数组</strong></p>
<p><strong>而p是数组指针，指向的数组只有4个元素，所以会有警告</strong></p>
<p>-&gt;可以写成 <strong>int(*p)[4] = (int(*)[4])a</strong> 消除警告</p>
<hr/>
<h3>六.笔试题6-指针与二维数组</h3>
<pre><code>int main()
{
    int aa[2][5] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
    int *ptr1 = (int *)(&amp;aa + 1);
    int *ptr2 = (int *)(*(aa + 1));
    printf( "%d,%d", *(ptr1 - 1), *(ptr2 - 1));    // 5 10
	return 0;
}</code></pre>
<blockquote>
<p>解析：</p>
<p><strong>&amp;aa：取出二维数组的地址 &amp;aa+1：跳过二维数组</strong></p>
<p><strong>&amp;二维数组应该使用数组指针接收，现在保存到整形指针，所以要强转。</strong></p>
<p><strong>aa:没有单独放在sizeof内部，没有&amp;数组名，所以代表的是二维数组首元素地址，即二维数组第一行的地址</strong></p>
<p><strong>aa+1：跳过一行</strong></p>
<p><strong>*(aa+1) : 相当于拿到了第二行的数组名 等价于 aa[1]</strong> </p>
</blockquote>
<p>图解：<img alt="" height="300" src="image\20210913223015739.png" width="538"/> </p>
<hr/>
<h3>七.笔试题7-指针与字符指针数组</h3>
<pre><code>#include &lt;stdio.h&gt;
int main()
{
    char *a[] = {"work","at","alibaba"};
    char**pa = a;
    pa++;
    printf("%s\n", *pa);
	return 0;
}</code></pre>
<blockquote>
<p>解析： </p>
<p><strong>a是数组，元素类型为：char* ，存放的是指向字符串的首字符地址</strong></p>
<p><strong>根据后面初始化的内容确定数组的大小</strong></p>
<p><strong>char** pa = a ; 此处的a是首元素地址，char**类型</strong></p>
<p><strong>--------</strong></p>
<p><strong>char**pa ：一颗*说明pa是指针，另一颗*说明pa指向的类型是char*</strong></p>
<p><strong>pa+1:跳过char*</strong></p>
<p><strong>所以从字符a的地址向后打印，遇到\0即停止打印</strong></p>
<p><strong>打印结果为：at</strong></p>
</blockquote>
<hr/>
<p>图解：</p>
<p><img alt="" height="417" src="image\20210913223532721.png" width="1200"/></p>
<hr/>
<h1><strong> 八.笔试题9-指针与字符指针数组(难)</strong></h1>
<pre><code>int main()
{
    char *c[] = {"ENTER","NEW","POINT","FIRST"};
    char**cp[] = {c+3,c+2,c+1,c};
    char***cpp = cp;
    printf("%s\n", **++cpp);
    printf("%s\n", *--*++cpp+3);
    printf("%s\n", *cpp[-2]+3);
    printf("%s\n", cpp[-1][-1]+1);
    return 0;
}</code></pre>
<p>这道题比较难，所以我们分表达式解决！</p>
<hr/>
<p> 最最最初的内存布局：</p>
<p><img alt="" height="459" src="image\20210913223638246.png" width="1200"/></p>
<hr/>
<blockquote>
<p>解析：**++cpp</p>
<p><strong>前置++，cpp先自增，</strong></p>
<p><img alt="" height="682" src="image\20210913223712717.png" width="1008"/></p>
<hr/>
<p>此时cpp</p>
<p>（存放了）指向存放c+2地址的空间（地址）</p>
<p>*cpp-&gt;得到c+2的地址</p>
<p>**cpp得到c+2中存放的内容-&gt;首字符P的地址</p>
<hr/>
<p>所以从首字符P开始向后打印，打印结果为：POINT</p>
</blockquote>
<hr/>
<blockquote>
<p> 解析：*--*++cpp+3</p>
<p>注意：<span style="color:#fe2c24;"><strong>上面的表达式，cpp发生自增，指向的已经是存放c+2地址的空间</strong> </span></p>
<p>++cpp ：前置++，cpp发生自增原来是指向存放c+2地址的空间，变为指向存放c+1地址的空间</p>
<p><img alt="" height="702" src="image\20210913223827553.png" width="1117"/></p>
<hr/>
<p>*++cpp：<strong>拿到存放c+1地址的空间</strong>，里面存放的是c+1的地址</p>
<p>--*++cpp；前置--，相当于自减解引用cpp之后的内容，即自减c+1的地址，（地址值是常量）。即把原来空间存放的是c+1的地址变成了存放的是c的地址，即<strong>现在拿到的是存放c地址的空间</strong></p>
<hr/>
<p><img alt="" height="410" src="image\20210913223855716.png" width="1200"/></p>
<p>*--*++cpp ： 得到c空间中存放的内容（首字符E的地址）</p>
<p>*--*++cpp+3 ：从首字符E的地址向后+3 ，即为E的地址</p>
<hr/>
<p>从E的地址向后打印-&gt;打印结果为ER</p>
</blockquote>
<hr/>
<blockquote>
<p>解析：*cpp[-2]+3</p>
<p><img alt="" height="400" src="image\20210913223921393.png" width="1200"/></p>
<hr/>
<p>cpp[-2] ==&gt;*(cpp+(-2) )==&gt; *(cpp-2)</p>
<p>*cpp[-2]+3 ==&gt; **(cpp-2) )+3</p>
<p>cpp-2:从指向存放c地址空间又变为了指向存放c+3地址的空间</p>
<p><img alt="" height="480" src="image\20210913223945363.png" width="1198"/></p>
<p>*(cpp-2):得到cpp现在指向的内容，即c+3的地址</p>
<p>**(cpp-2)：得到c+3空间的内容（首字符F的地址）</p>
<p>**(cpp-2)+3 :从首字符F的地址向后+3，即为S的地址</p>
<hr/>
<p>从S的地址向后打印，打印结果为：ST</p>
</blockquote>
<hr/>
<blockquote>
<p>解析：cpp[-1][-1]+1</p>
<p>cpp[-1] ==&gt;*(cpp-1)</p>
<p>cpp[-1][-1] ==&gt; *(*(cpp-1)-1)</p>
<p>cpp[-1][-1] +1 ==&gt; *(*(cpp-1)-1) +1</p>
<p><span style="color:#fe2c24;"> <strong>注意：此时的cpp指向为第二条表达式之后的状态，上面的第三条表达式并没有改变cpp（即cpp没有自增自减以及被赋值）</strong>，<strong>也没有改变其指向内容</strong>，<strong>所以第四条表达式的初始状态为计算第二条表达式之后的内存布局</strong> </span></p>
<p><img alt="" height="546" src="image\20210913224046864.png" width="1195"/></p>
<p> cpp-1：变为指向存放c+2地址的空间</p>
<p><img alt="" height="457" src="image\20210913224057840.png" width="1200"/></p>
<p>*(cpp-1):<strong>得到c+2的地址</strong></p>
<p>*(cpp-1)-1 ：c+2的地址值（常量）自减，变成了c+1的地址，<strong>即得到了c+1的地址</strong></p>
<p><img alt="" height="399" src="image\20210913224117751.png" width="1200"/></p>
<p>*(*(cpp-1)-1): 得到c+1的内容（首字符N的地址）</p>
<p>*(*(cpp-1)-1)+1:得到首字符N向后+1跳过一个字符，即为字符E的地址</p>
<hr/>
<p>从字符E向后打印，打印结果为EW</p>
</blockquote>
<hr/>
<p><strong>总结： </strong></p>
<p><strong>能坚持看完，你已经比别人优秀很多了！也感谢你看到最后，如果笔者哪里写错了的话，欢迎大佬们评论区指正！<span style="color:#fe2c24;">如果此文对你有帮助的话，欢迎留个关注，留个赞再走呀！</span></strong></p>
</div>
</div>