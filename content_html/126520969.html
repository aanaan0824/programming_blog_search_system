<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="markdown_views prism-atom-one-dark" id="content_views">
<svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
<path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
</svg>
<p></p>
<div class="toc">
<h3>文章目录</h3>
<ul><li><a href="#_8">排序</a></li><li><a href="#1__26">1. 插⼊排序</a></li><li><ul><li><a href="#11__28">（稳定）1.1 直接插入排序【适用于顺序存储和链式存储的线性表】</a></li><li><ul><li><a href="#_85">时间、空间复杂度</a></li></ul>
</li><li><a href="#12__104">（稳定）1.2 折半插入排序【先⽤折半查找找到应该插⼊的位置，再移动元素】</a></li><li><ul><li><a href="#_135">时间、空间复杂度</a></li></ul>
</li><li><a href="#13__140">（不稳定）1.3 希尔排序【多次直接插入排序】</a></li><li><ul><li><a href="#_179">时间、空间复杂度</a></li></ul>
</li></ul>
</li><li><a href="#2__195">2. 交换排序</a></li><li><ul><li><a href="#21__197">2.1 (稳定）冒泡排序</a></li><li><ul><li><a href="#_255">时间、空间复杂度</a></li></ul>
</li><li><a href="#22__263">2.2 (不稳定)快速排序【所有内部排序算法中，平均性能最优的排序算法】</a></li><li><ul><li><a href="#_318">时间、空间复杂度</a></li></ul>
</li></ul>
</li><li><a href="#3_346">3.选择排序</a></li><li><ul><li><a href="#31__348">3.1 （不稳定）简单选择排序</a></li><li><ul><li><a href="#_398">时间、空间复杂度</a></li></ul>
</li><li><a href="#32__410">3.2 （不稳定）堆排序</a></li><li><ul><li><a href="#__412">① 什么是堆、⼤根堆（⼤顶堆）、⼩根堆（⼩顶堆）？</a></li><li><a href="#_BuildMaxHeapint_A_int_lenHeadAdjustint_A_int_k_int_len_423">② 建⽴⼤根堆：BuildMaxHeap(int A[], int len)、HeadAdjust(int A[], int k, int len)</a></li><li><a href="#HeapSortint_A_int_len_460">③基于⼤根堆进⾏排序：HeapSort(int A[], int len)</a></li><li><a href="#_490">时间、空间复杂度</a></li><li><a href="#__502">④ 补充：在堆中插⼊新元素</a></li><li><a href="#__508">⑤ 补充：在堆中删除元素</a></li></ul>
</li></ul>
</li><li><a href="#4__515">4. （稳定）归并排序</a></li><li><ul><li><ul><li><a href="#_2_518">① 明白什么是“2路”归并？——就是“⼆合⼀”</a></li><li><a href="#_2Mergeint_A_int_low_int_mid_int_high_526">② 一次“2路”归并的代码【Merge(int A[], int low, int mid, int high)】</a></li><li><a href="#MergeSortint_A_int_low_int_high_531">③递归进行分治思想【MergeSort(int A[], int low, int high)】</a></li><li><a href="#__534">④ 总实现代码</a></li><li><a href="#_567">时间、空间复杂度</a></li></ul>
</li></ul>
</li><li><a href="#5__573">5. 基数排序</a></li><li><a href="#_592">内部排序算法总结</a></li></ul>
</div>
<p></p>
<h1><a id="_8"></a>排序</h1>
<p><code>排序</code>：重新排列表中的元素，使表中元素<mark>满足按关键字有序</mark>的过程。</p>
<p><code>排序算法的评价指标</code>：时间复杂度、空间复杂度、稳定性。</p>
<blockquote>
<p>算法的稳定性：<font color="blue" size="4">关键字相同的元素在使用某一排序算法之后相对位置不变，则称这个排序算法是稳定的</font>，否则称其为不稳定的。<br/> <mark>稳定的排序算法</mark>不一定比<mark>不稳定的排序算法</mark>要好。<br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/e4ff6bfaf0ba404ea26bf6869afd2082.png#pic_center" width="700"/></p>
</blockquote>
<p><code>排序算法的分类</code>：<br/> 内部排序 ： 排序期间<mark>元素都在内存中</mark>——关注如何使时间、空间复杂度更低。<br/> 外部排序 ：排序期间元素<mark>无法全部同时存在内存中</mark>，必须在排序的过程中根据要求，<strong>不断地在内、外存之间移动</strong>——关注如何使时间、空间复杂度更低，如何使读/写磁盘次数更少。</p>
<blockquote>
<p>各自排序算法演示过程参考：<a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">https://www.cs.usfca.edu/~galles/visualization/Algorithms.html</a></p>
</blockquote>
<p><br/></p>
<hr/>
<p></p>
<h1><a id="1__26"></a>1. 插⼊排序</h1>
<h2><a id="11__28"></a>（稳定）1.1 直接插入排序【适用于顺序存储和链式存储的线性表】</h2>
<blockquote>
<p>基本操作就是：将<code>有序数据后的第一个元素</code> 插入到 <code>已经排好序的有序数据中</code> 从而得到一个新的、个数加一的有序数据</p>
</blockquote>
<p>算法解释：（从小到大）<br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/8502d67fb9a4493c84d17cb67dbe320a.png#pic_center" width="700"/></p>
<p>算法三个步骤：</p>
<blockquote>
<p>先保留要插入的数字<br/> 往后移<br/> 插入元素</p>
</blockquote>
<pre><code class="prism language-cpp"><span class="token comment">// 对A[]数组中共n个元素进行插入排序</span>
<span class="token keyword">void</span> <span class="token function">InsertSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>temp<span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
    	<span class="token comment">//如果是A[i-1] &lt;= A[i]，直接就是有序了，就不用下面的步骤【也是算法稳定的原因】</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>A<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>    	
            temp<span class="token operator">=</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">//保留要插入的数字</span>
            
            <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">&gt;=</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&gt;</span>temp<span class="token punctuation">;</span> <span class="token operator">--</span>j<span class="token punctuation">)</span>
                A<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">//所有大于temp的元素都向后挪</span>
                
            A<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>temp<span class="token punctuation">;</span><span class="token comment">//插入元素</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>用算法再带入这个例子，进行加深理解<br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/074cb4a198ed401c999e30d15827c3ad.png#pic_center" width="600"/></p>
</blockquote>
<blockquote>
<p><font color="red" size="5"><strong>带哨兵：</strong></font><br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/5299eae1ef13464b9ff2d91d4cc5627d.png#pic_center" width="700"/></p>
</blockquote>
<p>补充：对链表L进行插入排序</p>
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">InsertSort</span><span class="token punctuation">(</span>LinkList <span class="token operator">&amp;</span>L<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    LNode <span class="token operator">*</span>p<span class="token operator">=</span>L<span class="token operator">-&gt;</span>next<span class="token punctuation">,</span> <span class="token operator">*</span>pre<span class="token punctuation">;</span>
    LNode <span class="token operator">*</span>r<span class="token operator">=</span>p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    p<span class="token operator">-&gt;</span>next<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>
    p<span class="token operator">=</span>r<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        r<span class="token operator">=</span>p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
        pre<span class="token operator">=</span>L<span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>pre<span class="token operator">-&gt;</span>next<span class="token operator">!=</span><span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> pre<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>data<span class="token operator">&lt;</span>p<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span>
            pre<span class="token operator">=</span>pre<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
        p<span class="token operator">-&gt;</span>next<span class="token operator">=</span>pre<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
        pre<span class="token operator">-&gt;</span>next<span class="token operator">=</span>p<span class="token punctuation">;</span>
        p<span class="token operator">=</span>r<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<h3><a id="_85"></a>时间、空间复杂度</h3>
<blockquote>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/ae168cb59db84e168049a2b506f398b8.png"/></p>
</blockquote>
<p><code>最好情况</code>： 共n-1趟处理，每⼀趟只需要对⽐关键字1次，不⽤移动元素<br/> <mark>最好时间复杂度—— O(n)</mark></p>
<p><code>最坏情况</code>： 【感觉第1趟：对⽐关键字2次，移动元素1次？ 】<br/> 第1趟：对⽐关键字2次，移动元素3次<br/> 第2趟：对⽐关键字3次，移动元素4次<br/> …<br/> 第 i 趟：对⽐关键字 i+1次，移动元素 i+2 次<br/> <mark>最坏时间复杂度——O(n<sup>2</sup>)</mark></p>
<blockquote>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/7eaf81d4fd27425a94c05f864d9dfd95.png#pic_center"/></p>
</blockquote>
<p><br/></p>
<hr/>
<p></p>
<h2><a id="12__104"></a>（稳定）1.2 折半插入排序【先⽤折半查找找到应该插⼊的位置，再移动元素】</h2>
<p>过程：</p>
<blockquote>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/fe46e9646d6f42d793572ddc831b45ee.png"/></p>
</blockquote>
<pre><code class="prism language-c"><span class="token comment">//对A[]数组中共n个元素进行折半插入排序</span>
<span class="token keyword">void</span> <span class="token function">InsertSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span> 
    <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>low<span class="token punctuation">,</span>high<span class="token punctuation">,</span>mid<span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//存到A[0]</span>
        <span class="token comment">//-----------------折半查找【代码一样】---------------------------</span>
        low<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> high<span class="token operator">=</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>low<span class="token operator">&lt;=</span>high<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>            
            mid<span class="token operator">=</span><span class="token punctuation">(</span>low<span class="token operator">+</span>high<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">&gt;</span>A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
                high<span class="token operator">=</span>mid<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span>
                low<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
         <span class="token comment">//--------------------------------------------</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">&gt;</span>high<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">--</span>j<span class="token punctuation">)</span><span class="token comment">//右移</span>
            A<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
            
        A<span class="token punctuation">[</span>high<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//插入</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<h3><a id="_135"></a>时间、空间复杂度</h3>
<p>空间复杂度：O(1)</p>
<p>【右移】的次数变少了，但是<mark>关键字对⽐的次数</mark>依然是O(n<sup>2</sup>) 数量级，整体来看<code>时间复杂度</code>依然是O(n<sup>2</sup>)<br/> <br/></p>
<hr/>
<p></p>
<h2><a id="13__140"></a>（不稳定）1.3 希尔排序【多次直接插入排序】</h2>
<blockquote>
<p>是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种<strong>插入排序</strong>，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序，同时该算法是冲破O(n2）的第一批算法之一。</p>
</blockquote>
<p>算法思想</p>
<ul><li>希尔排序是把记录<mark>按下标的一定增量</mark>分组，对每组使用<font color="red" size="4"><strong>直接插入排序算法</strong></font>排序；</li><li>随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</li></ul>
<p>图解：</p>
<blockquote>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/e1624484009b47fb8e318044fa300e2c.png#pic_center" width="700"/></p>
</blockquote>
<p>代码实现：</p>
<pre><code class="prism language-cpp"><span class="token comment">//从小到大</span>
<span class="token keyword">void</span> <span class="token function">shellSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> gap<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> temp<span class="token punctuation">;</span>
        <span class="token comment">//小组的个数，小组的个数从n/2个，变成n/4，再变变变，越来越少，直到变成一个</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>gap <span class="token operator">=</span> n <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> gap <span class="token operator">&gt;=</span> <span class="token number">1</span><span class="token punctuation">;</span> gap <span class="token operator">=</span> gap <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span> 
        <span class="token punctuation">{<!-- --></span>
            <span class="token comment">//**********************************直接插入排序（只是步长改变）**************************************************</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> gap<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token comment">//因为这个小组的元素使隔了gap个，所以排的时候也要隔gap个</span>
            <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>i <span class="token operator">-</span> gap<span class="token punctuation">]</span><span class="token punctuation">)</span>
                <span class="token punctuation">{<!-- --></span>
                    temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
                    
                    <span class="token comment">//后移</span>
                    <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> i <span class="token operator">-</span> gap<span class="token punctuation">;</span> j <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> temp <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> j <span class="token operator">-=</span> gap<span class="token punctuation">)</span> 
                        arr<span class="token punctuation">[</span>j <span class="token operator">+</span> gap<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                    
                    arr<span class="token punctuation">[</span>j <span class="token operator">+</span> gap<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span><span class="token comment">//插入进去</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token comment">//************************************************************************************</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<h3><a id="_179"></a>时间、空间复杂度</h3>
<p><code>空间复杂度</code>：O(1)</p>
<p><code>时间复杂度</code>：和步长的大小有关，⽬前⽆法⽤数学⼿段证明确切的时间复杂度 ，最坏时间复杂度为 O(n<sup>2</sup>)，当n在某个范围内时，可达O(n<sup>1.3</sup>)</p>
<p><code>稳定性</code>：不稳定！</p>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/0da048a734514ab4ac0a3727d84f4fdf.png#pic_center"/></p>
<p><code>适⽤性</code>：仅适⽤于顺序表，不适⽤于链表</p>
<p><br/></p>
<hr/>
<p></p>
<h1><a id="2__195"></a>2. 交换排序</h1>
<h2><a id="21__197"></a>2.1 (稳定）冒泡排序</h2>
<blockquote>
<p>英文:<code>bubble sort </code>     <strong>(bubble 动和名词 起泡，冒泡)</strong><br/> <font color="red" size="4"><strong>从头到尾相邻的两个元素进行比较 大小顺序不满足就交换两个元素位置</strong></font></p>
<p>每一轮比较会让一个<mark>最大数字沉底</mark>或者一个<mark>最小数字上浮</mark><br/><br/> 这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”。</p>
</blockquote>
<p>实现代码：</p>
<pre><code class="prism language-cpp"><span class="token comment">//从小到大：</span>
<span class="token keyword">void</span> <span class="token function">bubble_sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token comment">//冒泡排序int*arr</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> temp<span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token comment">//循环比较次数</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">//for (int j = 0; j &lt; len - 1; ++j)//从头到尾比较一轮</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> len <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> i<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span><span class="token comment">//相对于上面的一个优化 </span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">//发现两个位置不对的元素//j+1&lt;len</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token comment">//交换两个元素位置</span>
				temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
				arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
				arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>优化代码【当初始序列有序时，<code>外层for</code>会执行“<mark>【1】</mark>”，从而<code>外层for</code>只执行了一次】：</p>
<pre><code class="prism language-cpp"><span class="token comment">//从小到大：</span>
<span class="token keyword">void</span> <span class="token function">bubble_sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> temp<span class="token punctuation">;</span>
	<span class="token keyword">bool</span> flag<span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
	    <span class="token comment">//表示本趟冒泡是否发生交换的标志</span>
		flag<span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">;</span>
		
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> len <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> i<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">//稳定的原因</span>
			<span class="token punctuation">{<!-- --></span>
				temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
				arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
				arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
				<span class="token comment">//有发生交换</span>
				flag<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span><span class="token comment">//for</span>
		
		<span class="token comment">//本趟遍历后没有发生交换，说明表已经有序</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>flag<span class="token operator">==</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">;</span>【<span class="token number">1</span>】
	<span class="token punctuation">}</span><span class="token comment">//for</span>
<span class="token punctuation">}</span>
</code></pre>
<h3><a id="_255"></a>时间、空间复杂度</h3>
<blockquote>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/85c3259c34c341d39bd82b80dfcd286b.png#pic_center" width="700"/><br/> 适用性：冒泡排序可以用于顺序表、链表<br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/2a13cab068334ab38629eb8eff9cd6ec.png#pic_center"/></p>
</blockquote>
<p><br/></p>
<hr/>
<p></p>
<h2><a id="22__263"></a>2.2 (不稳定)快速排序【所有内部排序算法中，平均性能最优的排序算法】</h2>
<p>算法思想：<br/> 在待排序表L[1…n]中<code>任取⼀个元素pivot作为枢轴（或基准，通常取⾸元素）</code>，<br/> 通过⼀趟排序将待排序表划分为独⽴的两部分<mark>L[1…k-1]</mark> 和 <mark>L[k+1…n]</mark>，<br/> <font color="red" size="4"><strong>使得L[1…k-1]中的所有元素⼩于pivot，L[k+1…n]中的所有元素⼤于等于pivot</strong></font>，<br/> 再<font color="blue" size="4"><strong>令pivot放在位置L(k)上</strong></font>，这个过程称为⼀次“划分”。</p>
<p>然后分别递归地对两个⼦表重复上述过程，直⾄每部分内只有⼀个元素或空为⽌，即所有元素放在了其最终位置上。</p>
<p><mark>划分的过程：</mark></p>
<blockquote>
<p>初始状态：取首元素为pivot，定义low，high指针<br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/31cd9244a4b9480bb94b517a0e8767c1.png#pic_center"/><br/> 首元素为49<br/> high指针指向的数据小于49，就放在low指向的位置<br/> low指针指向的数据大于49，就放在high指向的位置</p>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/96d3bd833f3c4381b48edebcf71103de.png#pic_center" width="700"/><br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/b0276d2280324c118c529279bbced04e.png#pic_center" width="700"/><br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/b64db972b3c0404da0fd5c4afdb563c1.png#pic_center"/></p>
</blockquote>
<pre><code class="prism language-c"><span class="token comment">// 用第一个元素将数组A[]划分为两个部分</span>
<span class="token keyword">int</span> <span class="token function">Partition</span><span class="token punctuation">(</span><span class="token keyword">int</span> A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token comment">//取首元素为pivot</span>
    <span class="token keyword">int</span> pivot <span class="token operator">=</span> A<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">;</span>
    
    <span class="token keyword">while</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
    	<span class="token comment">//先是high开始向左移动</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high <span class="token operator">&amp;&amp;</span> A<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token operator">&gt;=</span>pivot<span class="token punctuation">)</span>
            <span class="token operator">--</span>high<span class="token punctuation">;</span>
        A<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">;</span>
        
        <span class="token comment">//随后low向右移动</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high <span class="token operator">&amp;&amp;</span> A<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token operator">&lt;=</span>pivot<span class="token punctuation">)</span> 
            <span class="token operator">++</span>low<span class="token punctuation">;</span>
        A<span class="token punctuation">[</span>high<span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">//low=high的位置，即pivot放在的位置</span>
    A<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">=</span> pivot<span class="token punctuation">;</span>
    
    <span class="token keyword">return</span> low<span class="token punctuation">;</span>
<span class="token punctuation">}</span> 

<span class="token comment">// 对A[]数组的low到high进行快速排序</span>
<span class="token keyword">void</span> <span class="token function">QuickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> pivotpos <span class="token operator">=</span> <span class="token function">Partition</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//划分</span>
        <span class="token function">QuickSort</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> low<span class="token punctuation">,</span> pivotpos <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">QuickSort</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> pivotpos <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<h3><a id="_318"></a>时间、空间复杂度</h3>
<blockquote>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/9bb6d1e9208f4d0aad91d5da0e1e08c3.png"/></p>
</blockquote>
<p><font color="red" size="4"><strong>把n个元素组织成⼆叉树，<mark>⼆叉树的层数</mark>就是<mark>递归调⽤的层数</mark></strong></font></p>
<p>n个结点的⼆叉树： 最⼩⾼度 = ⌊log<sub>2</sub>n⌋ + 1，最⼤⾼度 = n</p>
<blockquote>
<p><font color="blue" size="4"><strong>时间复杂度=O(n*递归层数)</strong></font><br/> 最好时间复杂度=O(n * log<sub>2</sub>n)<br/> 最坏时间复杂度=O(n<sup>2</sup>)<br/> 平均时间复杂度=O(n * log<sub>2</sub>n)，是所有内部排序算法中平均性能最优的排序算法</p>
</blockquote>
<blockquote>
<p><font color="blue" size="4"><strong>空间复杂度=O(递归层数)</strong></font><br/> 最好空间复杂度=O(log<sub>2</sub>n)<br/> 最坏空间复杂度=O(n)</p>
</blockquote>
<p>最坏的情况</p>
<blockquote>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/e69ba27d2cc742a49bde3d9d99e1b464.png#pic_center" width="700"/></p>
</blockquote>
<p>⽐较好的情况</p>
<blockquote>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/e09885be5f9848eab1500cc6bc4d98f2.png#pic_center" width="700"/></p>
</blockquote>
<p>不稳定的原因：</p>
<blockquote>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/3f31b9ae4a844b5482b8ddc96d7a8c02.png#pic_center" width="500"/></p>
</blockquote>
<p><br/></p>
<hr/>
<p></p>
<h1><a id="3_346"></a>3.选择排序</h1>
<p>选择排序：每⼀趟在待排序元素中，<mark>选取关键字最⼩（或最⼤）的元素</mark>加⼊<code>有序⼦序列</code></p>
<h2><a id="31__348"></a>3.1 （不稳定）简单选择排序</h2>
<p>算法思路：每一趟在待排序元素中，选取<mark>关键字最小的元素</mark>与<font color="blue" size="4"><strong>待排序元素中的第一个元素</strong></font>交换位置</p>
<blockquote>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/baff7181f44d4783a3a13ebc92c2b4e4.png#pic_center" width="600"/></p>
</blockquote>
<pre><code class="prism language-c"><span class="token comment">// 交换a和b的值</span>
<span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> temp <span class="token operator">=</span> a<span class="token punctuation">;</span>
    a <span class="token operator">=</span> b<span class="token punctuation">;</span>
    b <span class="token operator">=</span> temp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 对A[]数组共n个元素进行选择排序</span>
<span class="token keyword">void</span> <span class="token function">SelectSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">//一共进行n-1趟，i指向待排序序列中第一个元素</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>          	
        <span class="token keyword">int</span> min <span class="token operator">=</span> i<span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>		<span class="token comment">//在A[i...n-1]中选择最小的元素</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;</span>A<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token punctuation">)</span>
                min <span class="token operator">=</span> j<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>min<span class="token operator">!=</span>i<span class="token punctuation">)</span>                     
            <span class="token function">swap</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> A<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>补充：对链表进行简单选择排序</p>
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">selectSort</span><span class="token punctuation">(</span>LinkList <span class="token operator">&amp;</span>L<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    LNode <span class="token operator">*</span>h<span class="token operator">=</span>L<span class="token punctuation">,</span><span class="token operator">*</span>p<span class="token punctuation">,</span><span class="token operator">*</span>q<span class="token punctuation">,</span><span class="token operator">*</span>r<span class="token punctuation">,</span><span class="token operator">*</span>s<span class="token punctuation">;</span>
    L<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>h<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        p<span class="token operator">=</span>s<span class="token operator">=</span>h<span class="token punctuation">;</span> q<span class="token operator">=</span>r<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>data<span class="token operator">&gt;</span>s<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                s<span class="token operator">=</span>p<span class="token punctuation">;</span> r<span class="token operator">=</span>q<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            q<span class="token operator">=</span>p<span class="token punctuation">;</span> p<span class="token operator">=</span>p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token operator">==</span>h<span class="token punctuation">)</span>
            h<span class="token operator">=</span>h<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            r<span class="token operator">-&gt;</span>next<span class="token operator">=</span>s<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
        s<span class="token operator">-&gt;</span>next<span class="token operator">=</span>L<span class="token punctuation">;</span> L<span class="token operator">=</span>s<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<h3><a id="_398"></a>时间、空间复杂度</h3>
<blockquote>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/b134fa99ad424b10932a2d206e119f35.png#pic_center" width="500"/></p>
</blockquote>
<blockquote>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/f128a5b649bd4a079ba52a6095c8b6ca.png#pic_center" width="300"/></p>
</blockquote>
<p>适用性：适用于顺序存储和链式存储的线性表。</p>
<p><br/></p>
<hr/>
<p></p>
<h2><a id="32__410"></a>3.2 （不稳定）堆排序</h2>
<h3><a id="__412"></a>① 什么是堆、⼤根堆（⼤顶堆）、⼩根堆（⼩顶堆）？</h3>
<p>堆是具有以下性质的<font color="red" size="4"><strong>完全二叉树</strong></font>：<br/> 每个结点的值<mark>都大于或等于</mark>其左右孩子结点的值，称为<font color="blue" size="4"><strong>大顶堆</strong></font>；<br/> 或者每个结点的值<mark>都小于或等于</mark>其左右孩子结点的值，称为<font color="blue" size="4"><strong>小顶堆</strong></font>。</p>
<blockquote>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/cf826f79f3554bdd9d7f9afb8ae36d01.png"/><br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/aa7d4d63aa954afa956305be214fafbe.png"/><br/> 即：<br/> <strong>若满⾜：L(i) ≥ L(2i) 且 L(i) ≥ L(2i+1) （1 ≤ i ≤n/2）—— ⼤根堆（⼤顶堆）<br/> 若满⾜：L(i) ≤ L(2i) 且 L(i) ≤ L(2i+1) （1 ≤ i ≤n/2）—— ⼩根堆（⼩顶堆）</strong></p>
</blockquote>
<h3><a id="_BuildMaxHeapint_A_int_lenHeadAdjustint_A_int_k_int_len_423"></a>② 建⽴⼤根堆：BuildMaxHeap(int A[], int len)、HeadAdjust(int A[], int k, int len)</h3>
<p>思路：<br/> 把<mark>所有⾮终端结点</mark>都检查⼀遍，看是否<font color="red" size="4"><strong>满⾜⼤根堆的要求</strong></font>，如果不满⾜，则进⾏调整</p>
<p>在顺序存储的完全⼆叉树中，<mark>⾮终端结点</mark>编号 i≤⌊n/2⌋，也就是<font color="blue" size="4"><strong>检查 i=1 到 i=⌊n/2⌋ 之间的所有结点</strong></font></p>
<p>检查内容：是否满⾜ <code>根 ≥ 左、右</code>，若不满⾜，将当前结点<strong>与其更⼤的⼀个孩⼦互换</strong></p>
<blockquote>
<p>过程例子：<br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/3afa2deff2cf49de8cd84c7dc8a31412.png#pic_center" width="700"/><br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/eac693c5691f471e9f9a7444bf3ee00c.png#pic_center" width="700"/></p>
</blockquote>
<p><strong>建⽴⼤根堆（代码）</strong>：</p>
<blockquote>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/1289e6a78aab46749cb48bfb94cb856c.png"/></p>
</blockquote>
<pre><code class="prism language-c"><span class="token comment">// 对初始序列建立大根堆</span>
<span class="token keyword">void</span> <span class="token function">BuildMaxHeap</span><span class="token punctuation">(</span><span class="token keyword">int</span> A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>len<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> 		<span class="token comment">//从后往前调整所有非终端结点</span>
        <span class="token function">HeadAdjust</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> i<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 将以k为根的子树调整为大根堆</span>
<span class="token keyword">void</span> <span class="token function">HeadAdjust</span><span class="token punctuation">(</span><span class="token keyword">int</span> A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token operator">*</span>k<span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>len<span class="token punctuation">;</span> i<span class="token operator">*=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>	<span class="token comment">//沿k较大的子结点向下调整</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>len <span class="token operator">&amp;&amp;</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>A<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>	
            i<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&gt;=</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
            A<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>			<span class="token comment">//将A[i]调整至双亲结点上</span>
            k<span class="token operator">=</span>i<span class="token punctuation">;</span>					<span class="token comment">//修改k值，以便继续向下筛选</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    A<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre>
<h3><a id="HeapSortint_A_int_len_460"></a>③基于⼤根堆进⾏排序：HeapSort(int A[], int len)</h3>
<p>选择排序：每⼀趟在待排序元素中，<mark>选取关键字最⼩（或最⼤）的元素</mark>加⼊<code>有序⼦序列</code></p>
<p>堆排序：每⼀趟将<mark>堆顶元素</mark>加⼊<code>有序⼦序列</code>（<font color="blue" size="4"><strong>即与待排序序列中的最后⼀个元素交换</strong></font>）</p>
<blockquote>
<p>过程：<img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/bf9f482522d746fc98b055f797457675.png#pic_center" width="700"/></p>
</blockquote>
<pre><code class="prism language-c"><span class="token comment">// 交换a和b的值</span>
<span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> temp <span class="token operator">=</span> a<span class="token punctuation">;</span>
    a <span class="token operator">=</span> b<span class="token punctuation">;</span>
    b <span class="token operator">=</span> temp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 对长为len的数组A[]进行堆排序</span>
<span class="token keyword">void</span> <span class="token function">HeapSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token comment">//初始建立大根堆</span>
    <span class="token function">BuildMaxHeap</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>         	
   
    <span class="token comment">//n-1趟的交换和建堆过程</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>len<span class="token punctuation">;</span> i<span class="token operator">&gt;</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>      	
        <span class="token function">swap</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> A<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">HeadAdjust</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<h3><a id="_490"></a>时间、空间复杂度</h3>
<p>建堆时间 O(n)，之后进行 n-1 次向下调整操作，每次调整时间复杂度为 O(log<sub>2</sub>n)；<br/> 故<code>时间复杂度</code> = O(n) + O(n * log<sub>2</sub>n) = O(n* log<sub>2</sub>n)</p>
<p><code>空间复杂度</code> = O(1)</p>
<p>结论：堆排序是不稳定的<br/> <br/></p>
<hr/>
<p></p>
<h3><a id="__502"></a>④ 补充：在堆中插⼊新元素</h3>
<p>对于⼩根堆，新元素<mark>放到表尾</mark>，并与⽗节点对⽐，若<font color="red" size="4"><strong>新元素⽐⽗节点更⼩，则将⼆者互换</strong></font>。<br/> 新元素就这样⼀路“上升”，直到⽆法继续上升为⽌</p>
<blockquote>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/d56aacbb396446409def121de67fea07.png#pic_center" width="700"/></p>
</blockquote>
<h3><a id="__508"></a>⑤ 补充：在堆中删除元素</h3>
<p><code>被删除的元素</code>⽤<mark>堆底元素</mark>替代，然后让<font color="red" size="4"><strong>该元素不断“下坠”</strong></font>，直到⽆法下坠为⽌</p>
<blockquote>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/276e8f16423247fab802d9453e5b2935.png#pic_center" width="700"/></p>
</blockquote>
<p><br/></p>
<hr/>
<p></p>
<h1><a id="4__515"></a>4. （稳定）归并排序</h1>
<p>归并：把<font color="red" size="4"><strong>两个或多个已经有序的序列</strong></font>合并成<mark>⼀个</mark></p>
<h3><a id="_2_518"></a>① 明白什么是“2路”归并？——就是“⼆合⼀”</h3>
<blockquote>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/4fc949e21def4a9eb823be0397a99603.png"/><br/> 多路归并：<br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/69447218d4274e41aae0cfcc93acb69b.png#pic_center"/></p>
</blockquote>
<h3><a id="_2Mergeint_A_int_low_int_mid_int_high_526"></a>② 一次“2路”归并的代码【Merge(int A[], int low, int mid, int high)】</h3>
<blockquote>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/76fce20a232642e18118d0c0cc685b20.png"/><br/> B[ i ] = B[ j ]时，优先用B[ i ]，故算法稳定</p>
</blockquote>
<h3><a id="MergeSortint_A_int_low_int_high_531"></a>③递归进行分治思想【MergeSort(int A[], int low, int high)】</h3>
<blockquote>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/7ceeefe7f6904c9483b5dbcc1f937459.png#pic_center" width="700"/></p>
</blockquote>
<h3><a id="__534"></a>④ 总实现代码</h3>
<pre><code class="prism language-c"><span class="token comment">// 辅助数组B</span>
<span class="token keyword">int</span> <span class="token operator">*</span>B<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>n<span class="token operator">*</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// A[low,...,mid]，A[mid+1,...,high]各自有序，将这两个部分归并</span>
<span class="token keyword">void</span> <span class="token function">Merge</span><span class="token punctuation">(</span><span class="token keyword">int</span> A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> mid<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>k<span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>k<span class="token operator">=</span>low<span class="token punctuation">;</span> k<span class="token operator">&lt;=</span>high<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>
        B<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">=</span>A<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span>low<span class="token punctuation">,</span> j<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> k<span class="token operator">=</span>i<span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>mid <span class="token operator">&amp;&amp;</span> j<span class="token operator">&lt;=</span> high<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>B<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;=</span>B<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>
            A<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">=</span>B<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            A<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">=</span>B<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span>mid<span class="token punctuation">)</span>
        A<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>B<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>j<span class="token operator">&lt;=</span>high<span class="token punctuation">)</span> 
        A<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>B<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token comment">// 递归操作（使用了分治法思想）</span>
<span class="token keyword">void</span> <span class="token function">MergeSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>low<span class="token operator">+</span>high<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token function">MergeSort</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> low<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">MergeSort</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">Merge</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>low<span class="token punctuation">,</span>mid<span class="token punctuation">,</span>high<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//归并</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<h3><a id="_567"></a>时间、空间复杂度</h3>
<blockquote>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/6e6262ebaf3c403586951f0418bc64ef.png"/></p>
</blockquote>
<p><br/></p>
<hr/>
<p></p>
<h1><a id="5__573"></a>5. 基数排序</h1>
<blockquote>
<p>直接看课本的过程图来理解P352</p>
</blockquote>
<p>再看这个例子：<br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/78d79d6d6183434eb0753d8a459aad67.gif"/></p>
<ol><li><code>算法思想</code>：把整个关键字拆分为d位，按照各个关键字位递增的次序（比如：个、十、百），做d趟“分配”和“收集”，若当前处理关键字位可能取得r个值，则需要建立r个队列。</li><li><code>分配</code>：顺序扫描各个元素，根据当前处理的关键字位，将元素插入相应的队列。一趟分配耗时 O(n) 。</li><li><code>收集</code>：把各个队列中的结点依次出队并链接。一趟收集耗时 O( r ) 。</li><li>基数排序<mark>擅长处理的问题</mark>：<br/> ①数据元素的关键字可以方便地拆分为d组，且d较小。<br/> ②每组关键字的取值范围不大，即r较小。<br/> ③ 数据元素个数n较大。</li><li><mark>算法效率分析</mark>： 
  <ul><li><code>时间复杂度</code>：一共进行d趟分配收集，一趟分配需要 O(n) ，一趟收集需要O( r ) ，时间复杂度O[d(n+r)] ，且与序列的初始状态无关.</li><li><code>空间复杂度</code>： O( r ) ，其中r为辅助队列数量。</li><li><code>稳定性</code>：稳定。</li></ul> </li></ol>
<p><br/></p>
<hr/>
<p></p>
<h1><a id="_592"></a>内部排序算法总结</h1>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/05846c5ee4464fd1ade0a98b3fd996fa.png"/></p>
</div>
<link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css" rel="stylesheet"/>
<link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css" rel="stylesheet"/>
</div>