<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="markdown_views prism-github-gist" id="content_views">
<svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
<path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
</svg>
<p>⭐ <strong>前言</strong></p>
<p>本章将介绍常见八大排序中的 <strong>插入排序</strong>；</p>
<p>可能你会好奇，为什么只介绍插入排序呢？</p>
<p>因为我学完了所有排序以后，也看了市面上很多写排序的文章，都是一篇文章全部把所有排序都写完了的！</p>
<p>我觉得一篇文章把所有排序全部写完的话，会存在2个问题：</p>
<blockquote>
<p>1、一篇文章写完所有排序，会导致某个知识点不全面，换个话来说，就是越往后写，容易产生疲劳；<br/>  <br/> 2、读者的直观感受可能不是那么好，毕竟更多的是要让大家能看懂！其次自己也能看懂！</p>
</blockquote>
<p>所以，先分章节，慢慢来，把多个知识点深度剖析！</p>
<p><em>Let’s get it！</em></p>
<hr/>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/9f2b8dcab7384e3d8cf6f54fceb2e875.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6aOe5ZCR5pif55qE5a6i5py6,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<hr/>
<p></p>
<div class="toc">
<h3>文章目录</h3>
<ul><li><ul><li><a href="#1__26">1. 排序是什么</a></li><li><ul><li><a href="#__28">🍑 排序的概念</a></li><li><a href="#__44">🍑 排序的运用</a></li></ul>
</li><li><a href="#2__60">2. 插入排序分类</a></li><li><a href="#3__66">3. 直接插入排序</a></li><li><ul><li><a href="#___68">🍑 基本思想</a></li><li><a href="#___94">🍑 动图演示</a></li><li><a href="#__105">📃 代码实现</a></li><li><a href="#___138">🍑 概括总结</a></li></ul>
</li><li><a href="#4__168">4. 希尔排序</a></li><li><ul><li><a href="#___170">🍑 基本思想</a></li><li><a href="#___190">🍑 动图演示</a></li><li><a href="#___214">🍑 举例说明</a></li><li><a href="#__234">📃 代码实现</a></li><li><a href="#___271">🍑 概括总结</a></li></ul>
</li><li><a href="#5__310">5. 总结</a></li></ul>
</li></ul>
</div>
<p></p>
<hr/>
<h2><a id="1__26"></a>1. 排序是什么</h2>
<h3><a id="__28"></a>🍑 排序的概念</h3>
<blockquote>
<p><strong>排序：</strong> 所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。</p>
<p> </p>
<p><strong>稳定性：</strong> 假定在待排序的记录序列中，存在多个具有<strong>相同</strong>的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，<code>r[i]=r[j]</code>，且<code>r[i]</code>在<code>r[j]</code>之前，而在排序后的序列中，<code>r[i]</code>仍在<code>r[j]</code>之前，则称这种排序算法是稳定的；否则称为不稳定的。</p>
<p> </p>
<p><strong>内部排序：</strong> 数据元素全部放在内存中的排序。</p>
<p> </p>
<p><strong>外部排序：</strong> 数据元素太多不能同时放在内存中，根据排序过程的要求不能在内外存之间移动数据的排序。</p>
</blockquote>
<h3><a id="__44"></a>🍑 排序的运用</h3>
<p>这里给大家举几个生活中，常见排序的栗子👇：</p>
<blockquote>
<p>购物平台里面<strong>按某个商品的维度排序</strong></p>
<p><img alt="image-20211212213019712" src="https://img-blog.csdnimg.cn/img_convert/0e2f01913374002c1ed24f8ff2b27b7a.png"/></p>
<p><strong>全国高校排名</strong></p>
<p><img alt="" src="image\6bc5606fc2ec8851a8d708990bdc0d00.png"/></p>
</blockquote>
<p>其实在我们平时日常生活中还有很多都会用到排序的地方；</p>
<p>由此可见，排序与我们的生活息息相关😄</p>
<h2><a id="2__60"></a>2. 插入排序分类</h2>
<p>插入排序可以分为：<strong>直接插入排序</strong> 和 <strong>希尔排序</strong></p>
<p><img alt="image-20211212213649416" src="https://img-blog.csdnimg.cn/img_convert/42593aa8a38ad04d136c043965f6f585.png"/></p>
<h2><a id="3__66"></a>3. 直接插入排序</h2>
<h3><a id="___68"></a>🍑 基本思想</h3>
<p>🎃直接插入排序是一种简单的插入排序法；</p>
<blockquote>
<p>插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。</p>
<p> </p>
<p>实际中我们玩扑克牌时，就用了插入排序的思想，不信你看👇</p>
<p><img alt="image-20211212213858969" src="https://img-blog.csdnimg.cn/img_convert/a479754a991d9a0f379898f15b7f4b5d.png"/></p>
</blockquote>
<p>❗❓那么怎么去理解它呢？很简单</p>
<blockquote>
<p><strong>直接插入排序是指</strong>：在待排序的元素中，假设前面<code>n-1</code>(其中<code>n&gt;=2</code>)个数<strong>已经是排好顺序的</strong>，现将第<strong>n</strong>个数<strong>插到前面</strong>已经排好的序列中，然后找到合适自己的位置，使得<strong>插入第n个数的这个序列也是排好顺序的</strong>。</p>
<p> </p>
<p>按照此法对所有元素进行插入，<strong>直到整个序列排为有序的过程</strong>，称为插入排序 。</p>
<p> </p>
<p>但我们并不能确定待排元素中<strong>究竟哪一部分是有序的</strong>，所以我们一开始<strong>只能认为第一个元素是有序的</strong>，<strong>依次将其后面的元素插入到这个有序序列中来</strong>，<strong>直到整个序列有序为止</strong>。</p>
<p><img alt="img" src="https://img-blog.csdnimg.cn/img_convert/7a171f6bb9cf35e0ec9071151f2bc1b8.png"/></p>
</blockquote>
<h3><a id="___94"></a>🍑 动图演示</h3>
<p>🍅我们先来看个动态图演示：</p>
<p><img alt="img" src="https://img-blog.csdnimg.cn/img_convert/df939519fc99ca7a2c4b23e0db1b8d46.gif"/></p>
<blockquote>
<p>1、从图中观察的现象是如果后一个数不比前一个数小，那就不需要插入，不插入的动作就是<strong>break</strong>出循环</p>
<p> </p>
<p>2、如果前面的数都比<strong>pos</strong>(拿出的数)值大，那么就将前<strong>n</strong>个数都往后挪动，直到比<strong>pos</strong>值小或者相等就停止，可以用循环控制，这里防止越界需要再加判断</p>
</blockquote>
<h3><a id="__105"></a>📃 代码实现</h3>
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">InsertSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

	<span class="token comment">//注意控制好终止条件，这里的end的位置是在倒数第二个位置，所以要-1</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">int</span> end <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token comment">//记录有序序列的最后一个元素的下标</span>

		<span class="token keyword">int</span> tmp <span class="token operator">=</span> a<span class="token punctuation">[</span>end <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//待插入的元素</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>end <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>tmp <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">//还需继续比较</span>
			<span class="token punctuation">{<!-- --></span>
				a<span class="token punctuation">[</span>end <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">;</span>
				end<span class="token operator">--</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">else</span><span class="token comment">//找到应插入的位置</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token keyword">break</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		a<span class="token punctuation">[</span>end <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
		<span class="token comment">//代码执行到此位置有两种情况:</span>
		<span class="token comment">//1.待插入元素找到应插入位置（break跳出循环到此）。</span>
		<span class="token comment">//2.待插入元素比当前有序序列中的所有元素都小（while循环结束后到此）。</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<h3><a id="___138"></a>🍑 概括总结</h3>
<p><strong>复杂度分析：</strong></p>
<blockquote>
<p>元素集合越接近有序，直接插入排序算法的时间效率越高，反之越低</p>
<p> </p>
<p>时间复杂度：<span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         O
        
        
         (
        
        
         
          n
         
         
          2
         
        
        
         )
        
       
       
        O(n^2)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.06411em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
<p> </p>
<p>空间复杂度：<span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         O
        
        
         (
        
        
         1
        
        
         )
        
       
       
        O(1)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></p>
<p> </p>
<p>稳定性的分析：直接插入排序在遇到相同的数时，可以就放在这个数的后面，就可以保持稳定性了，所以说这个排序是稳定的。</p>
</blockquote>
<p><strong>特性总结：</strong></p>
<blockquote>
<p>插入排序是一种最简单直观的排序算法；</p>
<p> </p>
<p>它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
<p> </p>
<p>也就是说：把待排序的记录<strong>按其关键码值的大小</strong>逐个<strong>插入到一个已经排好序的有序序列中</strong>，直到所有的记录插入完为止，得到一个新的有序序列 。</p>
</blockquote>
<h2><a id="4__168"></a>4. 希尔排序</h2>
<h3><a id="___170"></a>🍑 基本思想</h3>
<blockquote>
<p>希尔排序，也称<strong>缩小增量法</strong>，是插入排序的一种更高效的改进版本；</p>
<p> </p>
<p>但希尔排序是<strong>非稳定排序算法</strong>。</p>
</blockquote>
<p>❗❓那么它的思路是什么呢？</p>
<blockquote>
<p>每次从一个有序序列开始，将待排元素与有序序列中的元素从后往前逐个比较，</p>
<p> </p>
<p>若有序序列中的元素大于待排元素，则将较大的元素往后覆盖；</p>
<p> </p>
<p>否则，将待排元素插入其前面，并结束此轮比较。</p>
</blockquote>
<h3><a id="___190"></a>🍑 动图演示</h3>
<p><img alt="img" src="https://img-blog.csdnimg.cn/img_convert/c3163ddd0c32c27669636684b98ae167.gif"/></p>
<p>🤔<strong>实现原理</strong></p>
<blockquote>
<p>1、先选定一个小于N的整数gap作为第一增量，然后将所有距离为gap的元素分在同一组，并对每一组的元素进行直接插入排序。然后再取一个比第一增量小的整数作为第二增量，重复上述操作…</p>
<p> </p>
<p>2、当增量的大小减到1时，就相当于整个序列被分到一组，进行一次直接插入排序，排序完成。</p>
<p> </p>
<p><strong>为什么要让gap由大到小呢？</strong></p>
<p> </p>
<p>答：gap越大，数据挪动得越快；gap越小，数据挪动得越慢。前期让gap较大，可以让数据更快得移动到自己对应的位置附近，减少挪动次数。</p>
<p> </p>
<p>注：一般情况下，取序列的一半作为增量，然后依次减半，直到增量为1（也可自己设置）。</p>
</blockquote>
<h3><a id="___214"></a>🍑 举例说明</h3>
<blockquote>
<p>现在我们用<strong>希尔排序</strong>对该序列进行排序。</p>
<p><img alt="img" src="https://img-blog.csdnimg.cn/img_convert/7b7cee9c30bab016292a4522f01e7e80.png"/></p>
<p>我们用<strong>序列长度的一半</strong>作为第一次排序时<strong>gap</strong>的值，此时<strong>相隔距离为5</strong>的元素被分为一组（共分了5组，每组有2个元素），然后分别对每一组进行直接插入排序。</p>
<p><img alt="img" src="https://img-blog.csdnimg.cn/img_convert/fda66f2b6bbe8fe85110f94b37d97d24.png"/></p>
<p><strong>gap</strong>的值折半，此时<strong>相隔距离为2的元素被分为一组</strong>（共分了2组，每组有5个元素），然后再分别对每一组进行直接插入排序。</p>
<p><img alt="img" src="https://img-blog.csdnimg.cn/img_convert/7c675e2d268ab7e7b84a1f732553a9f1.png"/></p>
<p><strong>gap</strong>的值再次减半，此时gap减为1，即整个序列被分为一组，进行一次直接插入排序。</p>
<p><img alt="img" src="https://img-blog.csdnimg.cn/img_convert/c903fe4ccd6aecbea28b46df97477ab7.png"/></p>
</blockquote>
<p>上述示例中，前两趟就是希尔排序的预排序，最后一趟就是希尔排序的直接插入排序。</p>
<h3><a id="__234"></a>📃 代码实现</h3>
<pre><code class="prism language-c"><span class="token comment">//希尔排序</span>
<span class="token keyword">void</span> <span class="token function">ShellSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> gap <span class="token operator">=</span> n<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>gap <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">//别加等号，不然就是死循环</span>
	<span class="token punctuation">{<!-- --></span>
        <span class="token comment">//控制gap值的变化，让数组接近有序，gap == 1就可以直接插入排序</span>
		gap <span class="token operator">=</span> gap <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">//gap折半</span>
		<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token comment">//进行一趟排序</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> gap<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">int</span> end <span class="token operator">=</span> i<span class="token punctuation">;</span>
			<span class="token keyword">int</span> tmp <span class="token operator">=</span> a<span class="token punctuation">[</span>end <span class="token operator">+</span> gap<span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token keyword">while</span> <span class="token punctuation">(</span>end <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
                <span class="token comment">//当前的end的值比tmp大就要往end+gap位置挪</span>
				<span class="token comment">//所以要提前保存end+gap的值</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>tmp <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span>
				<span class="token punctuation">{<!-- --></span>
					a<span class="token punctuation">[</span>end <span class="token operator">+</span> gap<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">;</span>
					end <span class="token operator">-=</span> gap<span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				<span class="token keyword">else</span>
				<span class="token punctuation">{<!-- --></span>
					<span class="token keyword">break</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
			a<span class="token punctuation">[</span>end <span class="token operator">+</span> gap<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<h3><a id="___271"></a>🍑 概括总结</h3>
<p><strong>复杂度分析：</strong></p>
<blockquote>
<p>时间复杂度：<span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         O
        
        
         (
        
        
         N
        
        
         l
        
        
         o
        
        
         g
        
        
         N
        
        
         )
        
       
       
        O(NlogN)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.10903em;">N</span><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="mord mathdefault" style="margin-right: 0.10903em;">N</span><span class="mclose">)</span></span></span></span></span><br/>  <br/> 空间复杂度：<span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         O
        
        
         (
        
        
         1
        
        
         )
        
       
       
        O(1)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span><br/>  <br/> 平均时间复杂度：<span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         O
        
        
         (
        
        
         
          N
         
         
          1.3
         
        
        
         )
        
       
       
        O(N^{1.3})
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.06411em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">.</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span><br/>  <br/> 稳定性的分析：可以这样想，相同的数被分到了不同的组，就不能保证原有的顺序了，所以说这个排序是<strong>不稳定的</strong>。</p>
</blockquote>
<p><strong>特性总结：</strong></p>
<blockquote>
<p>希尔排序是对直接插入排序的优化。</p>
<p> </p>
<p>当<code>gap &gt; 1</code>时都是预排序，目的是让数组更接近于有序。当<code>gap == 1</code>时，数组已经接近有序的了，这样就 会很快。这样整体而言，可以达到优化的效果。我们实现后可以进行性能测试的对比。</p>
<p> </p>
<p>希尔排序的时间复杂度不好计算，因为<strong>gap</strong>的取值方法很多，导致很难去计算，因此在好些树中给出的 希尔排序的时间复杂度都不固定：</p>
<p> </p>
<p>在 <strong>《数据结构(C语言版)》</strong> 中，是这样说的：</p>
<p><img alt="image-20211214101932338" src="https://img-blog.csdnimg.cn/img_convert/914d916255b7700fac90999d7b8ea32f.png"/></p>
<p>在 <strong>《数据结构-用面相对象方法与C++描述》</strong> 中，是这样说的：</p>
<p><img alt="image-20211214102013752" src="https://img-blog.csdnimg.cn/img_convert/8b7fc3045d60c5ebb1599fd1b51f05db.png"/></p>
<p>因为我们的<strong>gap</strong>是按照<strong>Knuth</strong>提出的方式取值的，而且Knuth进行了大量的试验统计，我们暂时就按照：<span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         O
        
        
         (
        
        
         
          n
         
         
          1.25
         
        
        
         )
        
       
       
        O(n^{1.25})
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.06411em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">.</span><span class="mord mtight">2</span><span class="mord mtight">5</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span> 到 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         O
        
        
         (
        
        
         1.6
        
        
         ∗
        
        
         
          n
         
         
          1.25
         
        
        
         )
        
       
       
        O(1.6*n^{1.25})
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mord">.</span><span class="mord">6</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1.06411em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">.</span><span class="mord mtight">2</span><span class="mord mtight">5</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span> 来计算</p>
<p> </p>
<p>稳定性：不稳定</p>
</blockquote>
<h2><a id="5__310"></a>5. 总结</h2>
<p>以上就是关于 <strong>插入排序</strong> 的全部内容，下一篇就进入到我们的 <strong>选择排序</strong></p>
<blockquote>
<p>🌟<em>你知道的越多，你不知道越多，我们下期见！</em></p>
</blockquote>
</div>
<link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css" rel="stylesheet"/>
<link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css" rel="stylesheet"/>
</div>