<div class="article_content clearfix" id="article_content">
<link href="style.css" rel="stylesheet"/>
<div class="markdown_views prism-tomorrow-night" id="content_views">
<svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
<path d="M5,0 0,2.5 5,5z" id="raphael-marker-block" stroke-linecap="round" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
</svg>
<p>欢迎订阅我的C++专栏，分享整套C++学习知识：<a href="https://blog.csdn.net/qq_51492202/category_11584982.html">C++编程</a><br/> </p>
<div class="toc">
<h3>文章目录</h3>
<ul><li><a href="#_2">零.前言</a></li><li><a href="#1_4">1.继承的概念和定义</a></li><li><ul><li><a href="#1_5">(1)继承的概念</a></li><li><a href="#2_8">(2)继承的定义方法</a></li><li><a href="#2_23">(2)继承后子类的成员类型</a></li></ul>
</li><li><a href="#2_41">2.基类与派生类的赋值转换</a></li><li><ul><li><a href="#1_42">(1)派生类赋值给基类</a></li><li><a href="#2_59">(2)基类给派生类</a></li></ul>
</li><li><a href="#3_74">3.继承中的作用域</a></li><li><ul><li><a href="#1_75">(1)隐藏的概念</a></li><li><a href="#2_109">(2)例题</a></li></ul>
</li><li><a href="#4_140">4.派生类的默认成员函数</a></li><li><ul><li><a href="#1_142">(1)默认生成的成员函数</a></li><li><a href="#2_146">(2)自己写</a></li><li><ul><li><a href="#_147">自己写的情况</a></li><li><a href="#_151">构造函数</a></li><li><a href="#_183">拷贝构造和运算符重载函数</a></li><li><a href="#_207">析构函数</a></li></ul>
</li></ul>
</li><li><a href="#5_232">5.友元与静态成员</a></li><li><a href="#6_236">6.多继承</a></li><li><ul><li><a href="#1_237">(1)概念</a></li><li><a href="#2_261">(2)复杂的菱形继承</a></li><li><a href="#3_307">(3)虚继承解决菱形继承问题</a></li><li><a href="#4_327">(4)虚继承的原理</a></li><li><ul><li><a href="#_328">内存演示</a></li><li><a href="#_384">虚基表</a></li></ul>
</li></ul>
</li><li><a href="#7_407">7.继承与组合</a></li><li><ul><li><a href="#1_408">(1)两者区别</a></li><li><a href="#2_436">(2)继承与组合的区别</a></li><li><a href="#3_448">(3)使用情况</a></li></ul>
</li><li><a href="#8_453">8.总结</a></li></ul>
</div>
<p></p>
<h1><a id="_2"></a>零.前言</h1>
<p>C++的继承机制相对其他语言是比较复杂的一种，不同于java只支持单继承，C++不仅支持单继承，也支持多继承，对于多继承中的菱形问题会引发一系列的麻烦，C++的两个重要缺陷，一个是多继承，一个是垃圾回收器。本文将详细讲解C++的单继承和多继承，以及菱形继承的解决方法及原理。</p>
<h1><a id="1_4"></a>1.继承的概念和定义</h1>
<h2><a id="1_5"></a>(1)继承的概念</h2>
<p>继承是面向对象设计使代码可以<strong>复用</strong>的重要手段，它允许程序员在保持原有类的基础上进行扩展。被扩展的类称为<strong>基类</strong>或者<strong>父类</strong>，扩展生成的类叫做<strong>子类</strong>或者<strong>派生类</strong>，继承是类设计层次的复用。<br/> <font color="red">继承的作用是使得子类中既包含父类的成员，也可以包含自己的成员。</font></p>
<h2><a id="2_8"></a>(2)继承的定义方法</h2>
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Person</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">private</span><span class="token operator">:</span>
	string _name<span class="token punctuation">;</span>
	<span class="token keyword">int</span> _age<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Person</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _id<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p>看这一段代码，其中子类Student继承了父类Person，Student后的public表示的是继承方式。</p>
<h2><a id="2_23"></a>(2)继承后子类的成员类型</h2>
<p><strong>继承方式和父类的成员属性共同决定了子类中的成员属性</strong>。我们用一张表来表示三者之间的关系。</p>
<table><thead><tr><th>类成员/继承方式</th><th>public继承</th><th>protected继承</th><th>private继承</th></tr></thead><tbody><tr><td>基类的public成员</td><td>派生类的public成员</td><td>派生类的protected成员</td><td>派生类的private成员</td></tr><tr><td>基类的protected成员</td><td>派生类的protected成员</td><td>派生类的protected成员</td><td>派生类的private成员</td></tr><tr><td>基类的private成员</td><td>派生类中不可见</td><td>派生类中不可见</td><td>派生类中不可见</td></tr></tbody></table>
<p>我们只需要两点来记忆这个表格：</p>
<blockquote>
<p>1.基类的private成员在派生类中无论以什么方式继承都是不可见的。<br/> 2.子类中的成员属性取继承方式和父类成员属性中权限小的那个： public&gt;protected&gt;private</p>
</blockquote>
<p>表格的说明：<br/> 1.不可见的意思不是没有被继承，而是不能使用，在底层继承下来比没有继承下来更方便。<br/> 2.在父类中private和protected没有区别，但是在子类中，protected成员可以在类内访问，而private不能，因此可以说protected是为了继承而存在的。<br/> 3.如果不写继承方式，如果子类是class定义的，那么默认为private继承，是struct定义的，默认是public继承。<br/> 4.不可见与private成员区别：不可见指的是在类内与类外都不能使用，private成员在类内可以使用，在类外不可以使用。<br/> 5.不想给子类访问的成员我们设成private。</p>
<h1><a id="2_41"></a>2.基类与派生类的赋值转换</h1>
<h2><a id="1_42"></a>(1)派生类赋值给基类</h2>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/99371f004745467daec72e2f464d5d41.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2W5a-C5a-e55qE5bCP55S35a2p,size_19,color_FFFFFF,t_70,g_se,x_16"/><br/> 我们定义了一个父类person和它的派生类student，以上是它们各自的成员。<br/> 当我们将一个派生类的对象赋值给基类的对象时，发生的过程我们称之为<strong>切片</strong>。即只将子类中父类成员赋值过去。当父类中有private成员时，同样会进行切片，只是不显示而已，因此继承中尽量不要定义私有成员。<br/> <font color="red">注意，这种赋值兼容方式仅限于公有继承。</font><br/> 私有继承不支持切片，这是因为对于父类中的public成员，私有或保护继承之后会转变成private/protected类型，而赋值时会发生将派生类对象中的private/protected成员赋值给父类对象中的public成员的现象，但是private/protected成员在类外是不能被访问的，因此不支持私有继承。<br/> 我们不仅可以传值，还可以传指针和引用。</p>
<pre><code class="prism language-cpp">	Person b<span class="token punctuation">;</span>
	Student a<span class="token punctuation">;</span>
	b <span class="token operator">=</span> a<span class="token punctuation">;</span>
	Person<span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>
	Person<span class="token operator">&amp;</span> ref <span class="token operator">=</span> a<span class="token punctuation">;</span>
</code></pre>
<p><font color="green">注意一个细节，我们可以使用引用赋值，说明这里并不存在类型转换的行为，因为类型转换中间会产生临时变量，需要使用const引用。</font></p>
<blockquote>
<p>double d;<br/> const int&amp; r=d;//发生了类型转换。</p>
</blockquote>
<h2><a id="2_59"></a>(2)基类给派生类</h2>
<p>先说结论：<br/> <font color="red">父类对象不可以直接赋值给子类对象。</font><br/> 这是因为子类对象中有父类不存在的类型，无法进行赋值。也不能通过所谓的强制类型转换进行赋值。<br/> 但是C++支持指针和引用的赋值：</p>
<pre><code class="prism language-cpp">	Person b<span class="token punctuation">;</span>
	Student a<span class="token punctuation">;</span>
	a <span class="token operator">=</span> <span class="token punctuation">(</span>Student<span class="token punctuation">)</span>b<span class="token punctuation">;</span><span class="token comment">//不正确</span>
	Student<span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token punctuation">(</span>Student<span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>b<span class="token punctuation">;</span><span class="token comment">//支持</span>
	Student<span class="token operator">&amp;</span> ref <span class="token operator">=</span> <span class="token punctuation">(</span>Student<span class="token operator">&amp;</span><span class="token punctuation">)</span>b<span class="token punctuation">;</span><span class="token comment">//支持</span>
</code></pre>
<p>虽然指针和引用可以，但是当指针向下访问的时候超过父类对象的时候会出现问题。<br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/843d49d1a16e4e9fadf8c8c79edf6b99.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2W5a-C5a-e55qE5bCP55S35a2p,size_10,color_FFFFFF,t_70,g_se,x_16"/><br/> 会出现指向空的情况。</p>
<h1><a id="3_74"></a>3.继承中的作用域</h1>
<h2><a id="1_75"></a>(1)隐藏的概念</h2>
<p><font color="red">基类和派生类都有各自独立的作用域。</font><br/> 如果不同的域内有同名的成员，我们根据<strong>就近原则</strong>或者<strong>指定作用域</strong>的方式来指定成员的位置。<br/> 隐藏：子类与父类中出现同名成员，子类成员将屏蔽父类成员对同名成员进行直接访问，这种情况叫<strong>隐藏</strong>，也叫<strong>重定向</strong>。<br/> <font color="red">注意如果是成员函数的隐藏，只要函数名相同就会构成隐藏，与参数无关。</font><br/> 举一个例子：</p>
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Person</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">protected</span><span class="token operator">:</span>
	string _name <span class="token operator">=</span> <span class="token string">"小六子"</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> _num <span class="token operator">=</span> <span class="token number">111</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Person</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">void</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"姓名："</span> <span class="token operator">&lt;&lt;</span> _name <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"身份证号："</span> <span class="token operator">&lt;&lt;</span> Person<span class="token operator">::</span>_num <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"学号："</span> <span class="token operator">&lt;&lt;</span> _num <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _num <span class="token operator">=</span> <span class="token number">999</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Student s1<span class="token punctuation">;</span>
	s1<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>在这段代码中，Person和Student分别定义了_num，当子类对象中的成员函数直接访问_num时，根据的是就近原则，访问的是子类中的_num，当要访问父类中的_num时，需要使用::来指定类域，就可以进行访问。父类中的_num与子类中的_num构成隐藏。<br/> 这段代码打印的结果是：<br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/3b5c3ca981f7472cbd22953da256be01.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2W5a-C5a-e55qE5bCP55S35a2p,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<h2><a id="2_109"></a>(2)例题</h2>
<p>这里有一道小小的题目，是关于函数隐藏的：</p>
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"func"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token class-name">A</span><span class="token operator">::</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"func(int i)-&gt;"</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	B b<span class="token punctuation">;</span>
	b<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	b<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>提问在Test中的两个函数能否调用成功?</p>
<blockquote>
<p>b.func(10)可以调用成功，因为构成了隐藏。<br/> b.func()不能调用成功，会发生变异报错，因为隐藏了调不动。</p>
</blockquote>
<h1><a id="4_140"></a>4.派生类的默认成员函数</h1>
<p>对于六大默认成员函数我们这里暂时先讨论4种重要的，即:构造函数，析构函数，拷贝构造，赋值运算符重载。</p>
<h2><a id="1_142"></a>(1)默认生成的成员函数</h2>
<p>当我们不在子类中书写时，编译器会默认生成。这里只需要记住一句话：<br/> <font color="red">继承下来的成员调用父类的来处理，自己的按基本规则来处理。</font><br/> 以构造函数举例：派生类中的父类成员调用父类中的构造函数，自己的成员按照构造函数自动生成的规则来。</p>
<h2><a id="2_146"></a>(2)自己写</h2>
<h3><a id="_147"></a>自己写的情况</h3>
<p>1.父类没有默认构造函数，需要我们自己写构造函数。<br/> 2.子类有资源需要释放，需要我们自己写析构函数。<br/> 3.如果子类涉及浅拷贝问题，需要自己写拷贝构造和赋值重载。</p>
<h3><a id="_151"></a>构造函数</h3>
<p>父类成员调用对应的父类构造函数处理。子类成员按普通类处理。<br/> 举一个例子：</p>
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Person</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">Person</span><span class="token punctuation">(</span>string name <span class="token punctuation">,</span> <span class="token keyword">int</span> num<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>
		<span class="token operator">:</span><span class="token function">_name</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>
		<span class="token punctuation">,</span><span class="token function">_num</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
	string _name <span class="token punctuation">;</span>
	<span class="token keyword">int</span> _num <span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Person</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">Student</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">,</span>string _name<span class="token punctuation">,</span><span class="token keyword">int</span> _num<span class="token punctuation">)</span>
		<span class="token operator">:</span><span class="token function">_num</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span>
		<span class="token punctuation">,</span><span class="token function">Person</span><span class="token punctuation">(</span>_name<span class="token punctuation">,</span>_num<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _num<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Student <span class="token function">s1</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">"zhangsan"</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>看这一段代码，父类中没有默认构造函数（注意与默认成员函数区分），因此要初始化父类中的对象需要我们自己书写子类中的构造函数。在书写构造函数时，父类对象成员初始化使用父类中的构造函数，子类成员的初始化按正常方式书写即可。</p>
<h3><a id="_183"></a>拷贝构造和运算符重载函数</h3>
<pre><code class="prism language-cpp">	<span class="token function">Student</span><span class="token punctuation">(</span><span class="token keyword">const</span> Student<span class="token operator">&amp;</span> s<span class="token punctuation">)</span>
		<span class="token operator">:</span><span class="token function">Person</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>
		<span class="token punctuation">,</span><span class="token function">_num</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>_num<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
	Student<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Student<span class="token operator">&amp;</span> s<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">!=</span> <span class="token operator">&amp;</span>s<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			Person<span class="token operator">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//不指明类域的话会发生自己调自己的情况</span>
			_num <span class="token operator">=</span> s<span class="token punctuation">.</span>_num<span class="token punctuation">;</span>
			<span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Student <span class="token function">s1</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">"zhangsan"</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	Student <span class="token function">s2</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>
	Student s3 <span class="token operator">=</span> s2<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>我们可以通过调试来查看结果：<br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/8a75fd825bd84677a3ff197fcd8c84e9.png"/>``</p>
<h3><a id="_207"></a>析构函数</h3>
<p>析构函数比较特殊，对于父类中的析构函数，我们不需要指定去书写，就像下面这种情况：</p>
<pre><code class="prism language-cpp"><span class="token comment">//父类中的析构</span>
	<span class="token operator">~</span><span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"~Person"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token comment">//子类中的析构</span>
		<span class="token operator">~</span><span class="token function">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token class-name">Person</span><span class="token operator">::</span><span class="token operator">~</span><span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre>
<p><font color="red">注意，析构函数的名字在最后会被统一处理成destructor()，如果不指定类域的话，父类析构函数和子类析构函数会构成隐藏，因此需要指定类域。</font><br/> 对于上述int中的代码，需要析构三个子类对象，打印出的结果是：<br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/c127deddf4f747ca8d742d24c560e243.png"/><br/> 我们发现调用了六次父类中的析构函数。这说明每个对象的父类成员都被析构了两次。如果需要释放空间，则一定会报错。<br/> 先说结论：<font color="">我们自己实现子类构造函数时，不需要显示调用父类析构函数，我们显示调用一次，它还会自动调用一次。</font><br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/f50d74688d3b4eb0ace1118a00c495f4.png"/><br/> 下面简单说明一下，为什么程序需要自动调用：<br/> 我们知道变量的定义是发生在栈中的，因此就存在构造和析构的顺序问题，栈满足先入后出原则，因此先构造的需要后析构。<br/> <font color="red">在构造的过程中，我们会先初始化父类成员，再初始化子类成员。</font>因此我们需要先析构子类成员，再析构父类成员。<br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/26721b593a55445486c62535e96bab72.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2W5a-C5a-e55qE5bCP55S35a2p,size_20,color_FFFFFF,t_70,g_se,x_16"/><br/> 如果先析构父类会打乱栈的顺序，因此编译器会自动调用父类的析构函数。</p>
<h1><a id="5_232"></a>5.友元与静态成员</h1>
<p>这个只需要记住两点：<br/> 1.<font color="red">友元关系不能继承。</font><br/> 2.静态成员会被继承下来，无论继承多少，静态成员只有一个。</p>
<h1><a id="6_236"></a>6.多继承</h1>
<h2><a id="1_237"></a>(1)概念</h2>
<p>一个类有两个及以上父类时称这个继承关系为多继承。</p>
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Student</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _id<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Teacher</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _course<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Assistant</span><span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Student</span><span class="token punctuation">,</span><span class="token keyword">public</span> <span class="token class-name">Teacher</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p>我们使用逗号表示分隔，即继承多个父类。可以通过调试来观察子类Assitant的内容：<br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/9765c4f005c5474dad4b334809a2ee45.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2W5a-C5a-e55qE5bCP55S35a2p,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<h2><a id="2_261"></a>(2)复杂的菱形继承</h2>
<p>菱形继承是多继承的一种情况：<br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/bfdcc81724904fc9a16c38b3d83bddfe.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2W5a-C5a-e55qE5bCP55S35a2p,size_20,color_FFFFFF,t_70,g_se,x_16"/><br/> 具有这样的继承关系的称为菱形继承。<br/> <font color="red">菱形继承出现的问题：从对象成员模型构造，可以看出菱形继承有数据冗余和二义性的问题。</font><br/> 数据冗余指的是类Assistant中会有两份Person的成员，二义性指的是这两份成员每一次调用不知道调用的的是哪一个，需要指定类域。<br/> 这段代码表示的就是菱形继承的关系：</p>
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Person</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	string _name<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Person</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _num<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Teacher</span><span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Person</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _id<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Assistant</span><span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Student</span><span class="token punctuation">,</span><span class="token keyword">public</span> <span class="token class-name">Teacher</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _course<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Assistant a<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>我们通过调试可以观测a中的内容，发现会存在两份Person中的成员：<br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/fccd6798ca4644c0b1be7f866b0ff608.png"/><br/> 如果要对这两个Person成员赋值时，需要指定类域。</p>
<pre><code class="prism language-cpp">	a<span class="token punctuation">.</span>Student<span class="token operator">::</span>_name <span class="token operator">=</span> <span class="token string">"xxx"</span><span class="token punctuation">;</span>
	a<span class="token punctuation">.</span>Teacher<span class="token operator">::</span>_name <span class="token operator">=</span> <span class="token string">"yyy"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>这就是所谓的二义性，在实际中一个人不能有两个名字，对于冗余性来说，如果Person中有一个很大的数组浪费的空间会很多。</p>
<h2><a id="3_307"></a>(3)虚继承解决菱形继承问题</h2>
<p>虚继承可以解决菱形继承的二义性和数据冗余问题。如上面的继承关系，在Student和Teacher的继承Person时使用的虚拟继承，即可解决问题。需要注意的是，虚拟继承不要在其他地方去使用。</p>
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token operator">:</span><span class="token base-clause"><span class="token keyword">virtual</span> <span class="token keyword">public</span> <span class="token class-name">Person</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _num<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Teacher</span><span class="token operator">:</span><span class="token base-clause"><span class="token keyword">virtual</span> <span class="token keyword">public</span> <span class="token class-name">Person</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _id<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p>只需要在菱形的腰部两个父类加入virtual关键词即可。<br/> <font color="red">注意要在菱形的腰部。</font><br/> 当加完之后，在Assistant的对象中，Person类的_name成员就只有一个了。无论是否指定类域，更改的变量都只有一个：<br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/c6726e183ee64ecc82d6be6b921a13f0.png"/></p>
<h2><a id="4_327"></a>(4)虚继承的原理</h2>
<h3><a id="_328"></a>内存演示</h3>
<p>要研究虚继承的原理，我们给出一个简化的菱形继承结构，再借助内存窗口窗口观察对象成员的模型。</p>
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _a<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">B</span><span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _b<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">C</span><span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _c<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">D</span> <span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">B</span><span class="token punctuation">,</span> <span class="token keyword">public</span> <span class="token class-name">C</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _d<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	D d<span class="token punctuation">;</span>
	d<span class="token punctuation">.</span>B<span class="token operator">::</span>_a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	d<span class="token punctuation">.</span>C<span class="token operator">::</span>_a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
	d<span class="token punctuation">.</span>_b <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
	d<span class="token punctuation">.</span>_c <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
	d<span class="token punctuation">.</span>_d <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>当没使用虚继承（即没有使用virtual时）<br/> 我们使用内存窗口来观察内容：<br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/15a64157a0104e23a425c169faa6ca3f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2W5a-C5a-e55qE5bCP55S35a2p,size_20,color_FFFFFF,t_70,g_se,x_16"/></p>
<p>通过观察内存中的布局，我们发现d中的B父类对象和C父类对象中的内容分别是连续存放的，B中有父类A中成员_a的值是1，其自己成员_b的值是3，两者的内存是挨着的，C同理，对于D类中自己的成员_d，放在了内存的最后。<br/> <font color="blue">确定d中B类对象和C类对象的存储顺序是根据继承顺序决定的。</font>由于上述代码是class D :public B, public C，因此B类的对象会存在C类的前面。<br/> 而当我们给腰部加上virtual构成虚继承之后：</p>
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token operator">:</span><span class="token base-clause"><span class="token keyword">virtual</span> <span class="token keyword">public</span> <span class="token class-name">A</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _b<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">C</span><span class="token operator">:</span><span class="token base-clause"><span class="token keyword">virtual</span> <span class="token keyword">public</span> <span class="token class-name">A</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _c<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p><img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/9b1e136944b14bd08084e5a62f40729f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2W5a-C5a-e55qE5bCP55S35a2p,size_20,color_FFFFFF,t_70,g_se,x_16"/><br/> 使用virtual之后，我们发现已经将A中对象_a放入在了最后，因此无论指定不指定类域，改变的都是同一个_a的值。<br/> 但同时我们发现内存中多了两行，那么这两行是干什么的呢？</p>
<h3><a id="_384"></a>虚基表</h3>
<p>从格式来看，这两行显然是都是地址。<br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/1e1063c560bf415f9113c4be9a0d4354.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y2W5a-C5a-e55qE5bCP55S35a2p,size_17,color_FFFFFF,t_70,g_se,x_16"/><br/> 我们再开辟一个内存2，向其中输入上面地址，我们发现地址中存储的内容是00 00 00 00，C类对象中同理，这里就不演示了。<br/> 这里00 00 00 00的意义在后面多态中会学习到，注意看它的下一个位置存放的是00 00 00 14<br/> 这里是十六进制，因此表示的是20这个数字。<br/> 再来看内存1：<br/> <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/a96c08e2d3af4a8b8bf5d361ce67f873.png"/><br/> 两者的地址之差刚刚好是20个字节。<br/> 因此我们可以知道：在虚继承中，B类对象和C类对象的内存中新加入的是一个地址，分别用于寻找两者与A类型变量的偏移量。B类对象与A类对象的偏移量是20，同理可验证C类对象的偏移量是12。而内存2也有一个专有名词：<strong>虚基表</strong><br/> <font color="red">总结：A一般叫做虚基类，在D里面，A类成员放在一个公共的位置，有时B要找A，C要找A，就要通过虚基表中的偏移量进行计算。</font><br/> 比如，当我们再用B类和C类建立两个变量：</p>
<pre><code class="prism language-cpp">	B b <span class="token operator">=</span> d<span class="token punctuation">;</span>
	C c <span class="token operator">=</span> d<span class="token punctuation">;</span>
</code></pre>
<p>此时会发生切片处理，需要将d中的A类对象赋值到b和c中，此时就需要使用到虚基表来寻找。<br/> 再比如：</p>
<pre><code class="prism language-cpp">	B<span class="token operator">*</span> pb <span class="token operator">=</span> <span class="token operator">&amp;</span>d<span class="token punctuation">;</span>
	pb<span class="token operator">-&gt;</span>_a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre>
<p>pb指向了d的首地址，要更改d中的_a的值，指针pb也需要使用虚基表来进行寻找。</p>
<h1><a id="7_407"></a>7.继承与组合</h1>
<h2><a id="1_408"></a>(1)两者区别</h2>
<p>首先我们要对继承和组合进行区分：<br/> 继承表示的是子类继承父类，组合表示的是在一个类中定义了另一个类的成员变量。</p>
<pre><code class="prism language-cpp"><span class="token comment">//继承</span>
<span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _a<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">B</span><span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _b<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">//组合</span>
<span class="token keyword">class</span> <span class="token class-name">C</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _c<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">D</span> 
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _d<span class="token punctuation">;</span>
	C _obj<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<h2><a id="2_436"></a>(2)继承与组合的区别</h2>
<p>我们需要明确一点：<font color="red">类之间，模块之间最好是低耦合，高内聚的，因为方便维护。</font><br/> 低耦合：类之间依赖关系越弱越好。<br/> 高内聚：内部成员关系紧密。<br/> 1.继承对应于白盒：B可以直接使用A中的公有和保护成员，破坏了封装性。<br/> 2.组合对应于黑盒：D只能使用C的公有，不能直接使用保护成员。<br/> 举一个例子：<br/> 如果A中有5个public，5个protected<br/> 对于组合来说，非基类只能使用这5个public，基类中的其他成员随便修改都不会影响该非基类。<br/> 对于继承来说，基类中一切的改变都会影响子类。<br/> 那可以抛弃继承的语法吗？当然是不行的。<br/> <font color="red">多态是建立在继承的基础上的。</font></p>
<h2><a id="3_448"></a>(3)使用情况</h2>
<blockquote>
<p>1.如果B就是一个A，比如Student是一个Person，我们称这种关系为is-a关系，此时适合使用继承。<br/> 2.如果D被包含于C，比如head包含eyes，我们称这种关系为has-a关系，此时适合使用组合。<br/> 3.当遇到特殊情况，is-a和has-a都可以讲通时，<strong>优先使用组合</strong>。</p>
</blockquote>
<h1><a id="8_453"></a>8.总结</h1>
<p>C++的语法复杂在于C++是第一个吃螃蟹的人，很多地方会考虑太多，拿多继承举例，有了多继承就有了菱形继承，有了菱形继承，就有了菱形虚拟继承，底层实现就更为复杂了，所以一般不建议设计多继承，设计了多继承也不建议设计菱形继承。</p>
</div>
<link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css" rel="stylesheet"/>
<link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css" rel="stylesheet"/>
</div>