{"blogid": "126138054", "writerAge": "码龄158天", "writerBlogNum": "22", "writerCollect": "214", "writerComment": "306", "writerFan": "127", "writerGrade": "4级", "writerIntegral": "1244", "writerName": "Node_Hao", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126138054.jpg", "writerRankTotal": "15734", "writerRankWeekly": "658", "writerThumb": "308", "writerVisitNum": "9852", "blog_read_count": "436", "blog_time": "已于 2022-08-30 22:37:08 修改", "blog_title": "[Java]快速入门二叉树,手撕相关面试题", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p style=\"text-align:center;\"><img alt=\"\" src=\"https://img-blog.csdnimg.cn/9a6f8af437cc4b45a6cf4baf9fbeb179.gif\"/></p>\n<blockquote>\n<p><img alt=\"\" height=\"16\" src=\"..\\..\\static\\image\\cb2be72a3c2b4b59b1128abf613b8abe.png\" width=\"16\"/><span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">专栏简介 :java语法及数据结构</span></span></p>\n<p><img alt=\"\" height=\"16\" src=\"..\\..\\static\\image\\1254c5b119a44cf0ae350489fb7736ad.png\" width=\"16\"/><span style=\"color:#38d8f0;\"><span style=\"background-color:#fef2f0;\">题目来源:leetcode,牛客,剑指offer</span></span></p>\n<p><img alt=\"\" height=\"16\" src=\"..\\..\\static\\image\\4366a93aaa3142b5a0f16c7a2200339b.png\" width=\"16\"/><span style=\"color:#0d0016;\">创作目标:从java语法角度实现底层相关数据结构,达到手撕各类题目的水平.</span></p>\n<p><img alt=\"\" height=\"15\" src=\"..\\..\\static\\image\\52a3437a932f4621b25533c330f7c6cb.png\" width=\"15\"/><span style=\"color:#956fe7;\">希望在提升自己的同时,帮助他人,,与大家一起共同进步,互相成长.</span></p>\n<p><img alt=\"\" height=\"15\" src=\"..\\..\\static\\image\\14aa2f0648ae44a299b8f9832af57d2c.png\" width=\"15\"/><span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">学历代表过去,能力代表现在,学习能力代表未来!</span></span></p>\n</blockquote>\n<blockquote>\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E5%89%8D%E8%A8%80-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%89%8D%E8%A8%80\">前言</a></p>\n<p id=\"%E4%B8%80%3E%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%80%3E%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84\">一&gt;树形结构</a></p>\n<p id=\"1.%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5-toc\" style=\"margin-left:40px;\"><a href=\"#1.%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5\">1.树的概念</a></p>\n<p id=\"2.%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8-toc\" style=\"margin-left:40px;\"><a href=\"#2.%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8\">2.树的应用</a></p>\n<p id=\"%E4%BA%8C%3E%E4%BA%8C%E5%8F%89%E6%A0%91-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BA%8C%3E%E4%BA%8C%E5%8F%89%E6%A0%91\">二&gt;二叉树</a></p>\n<p id=\"1.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5-toc\" style=\"margin-left:40px;\"><a href=\"#1.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5\">1.二叉树的概念</a></p>\n<p id=\"%C2%A02.%E4%B8%A4%E7%A7%8D%E7%89%B9%E6%AE%8A%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A02.%E4%B8%A4%E7%A7%8D%E7%89%B9%E6%AE%8A%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91\"> 2.两种特殊的二叉树</a></p>\n<p id=\"3.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8-toc\" style=\"margin-left:40px;\"><a href=\"#3.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8\">3.二叉树的性质</a></p>\n<p id=\"4.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8-toc\" style=\"margin-left:40px;\"><a href=\"#4.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8\">4.二叉树的存储</a></p>\n<p id=\"5.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%9B%E5%BB%BA-toc\" style=\"margin-left:40px;\"><a href=\"#5.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%9B%E5%BB%BA\">5.二叉树的创建</a></p>\n<p id=\"6.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86-toc\" style=\"margin-left:40px;\"><a href=\"#6.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86\">6.二叉树的遍历</a></p>\n<p id=\"1)%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86-toc\" style=\"margin-left:80px;\"><a href=\"#1%29%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86\">1)前序遍历</a></p>\n<p id=\"2)%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86-toc\" style=\"margin-left:80px;\"><a href=\"#2%29%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86\">2)中序遍历</a></p>\n<p id=\"3)%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%C2%A0-toc\" style=\"margin-left:80px;\"><a href=\"#3%29%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%C2%A0\">3)后序遍历 </a></p>\n<p id=\"4)%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-toc\" style=\"margin-left:80px;\"><a href=\"#4%29%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86\">4)层序遍历</a></p>\n<p id=\"5)%E5%AD%90%E9%97%AE%E9%A2%98%E6%80%9D%E8%B7%AF%E4%B8%8E%E9%81%8D%E5%8E%86%E6%80%9D%E8%B7%AF%E7%9A%84%E5%8C%BA%E5%88%AB%C2%A0-toc\" style=\"margin-left:80px;\"><a href=\"#5%29%E5%AD%90%E9%97%AE%E9%A2%98%E6%80%9D%E8%B7%AF%E4%B8%8E%E9%81%8D%E5%8E%86%E6%80%9D%E8%B7%AF%E7%9A%84%E5%8C%BA%E5%88%AB%C2%A0\">5)子问题思路与遍历思路的区别 </a></p>\n<p id=\"5)leetcode%E6%8F%90%E4%BA%A4%E5%81%9A%E6%B3%95-toc\" style=\"margin-left:80px;\"><a href=\"#5%29leetcode%E6%8F%90%E4%BA%A4%E5%81%9A%E6%B3%95\">6)leetcode提交做法</a></p>\n<p id=\"%E4%B8%89%20%3E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%89%20%3E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98\">三 &gt;二叉树常见面试题</a></p>\n<p id=\"1.%E9%80%89%E6%8B%A9%E9%A2%98%E9%83%A8%E5%88%86%3A-toc\" style=\"margin-left:40px;\"><a href=\"#1.%E9%80%89%E6%8B%A9%E9%A2%98%E9%83%A8%E5%88%86%3A\">1.选择题部分:</a></p>\n<p id=\"2.%E7%BC%96%E7%A8%8B%E9%A2%98%E9%83%A8%E5%88%86%3A-toc\" style=\"margin-left:40px;\"><a href=\"#2.%E7%BC%96%E7%A8%8B%E9%A2%98%E9%83%A8%E5%88%86%3A\">2.编程题部分:</a></p>\n<p id=\"1.%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0-toc\" style=\"margin-left:80px;\"><a href=\"#1.%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0\">1.节点个数</a></p>\n<p id=\"2.%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0-toc\" style=\"margin-left:80px;\"><a href=\"#2.%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0\">2.叶子节点个数</a></p>\n<p id=\"3.%E8%8E%B7%E5%8F%96%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AC%ACK%E5%B1%82%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%AA%E6%95%B0-toc\" style=\"margin-left:80px;\"><a href=\"#3.%E8%8E%B7%E5%8F%96%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AC%ACK%E5%B1%82%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%AA%E6%95%B0\">3.获取二叉树第K层节点的个数</a></p>\n<p id=\"4.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%AB%98%E5%BA%A6-toc\" style=\"margin-left:80px;\"><a href=\"#4.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%AB%98%E5%BA%A6\">4.二叉树的高度</a></p>\n<p id=\"5.%E6%A3%80%E6%B5%8B%E5%80%BC%E4%B8%BAvalue%E7%9A%84%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8-toc\" style=\"margin-left:80px;\"><a href=\"#5.%E6%A3%80%E6%B5%8B%E5%80%BC%E4%B8%BAvalue%E7%9A%84%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8\">5.检测值为value的元素是否存在</a></p>\n<p id=\"6.%E5%88%A4%E6%96%AD%E4%B8%80%E6%A3%B5%E6%A0%91%E6%98%AF%E4%B8%8D%E6%98%AF%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91-toc\" style=\"margin-left:80px;\"><a href=\"#6.%E5%88%A4%E6%96%AD%E4%B8%80%E6%A3%B5%E6%A0%91%E6%98%AF%E4%B8%8D%E6%98%AF%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91\">6.判断一棵树是不是完全二叉树(栈)</a></p>\n<p id=\"7.%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91-toc\" style=\"margin-left:80px;\"><a href=\"#7.%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91\">7.相同的树</a></p>\n<p id=\"8.%E5%8F%A6%E4%B8%80%E6%A3%B5%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91-toc\" style=\"margin-left:80px;\"><a href=\"#8.%E5%8F%A6%E4%B8%80%E6%A3%B5%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91\">8.另一棵树的子树</a></p>\n<p id=\"9.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91-toc\" style=\"margin-left:80px;\"><a href=\"#9.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91\">9.平衡二叉树(字节跳动原题)</a></p>\n<p id=\"10.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91-toc\" style=\"margin-left:80px;\"><a href=\"#10.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91\">10.对称二叉树</a></p>\n<p id=\"11.%E5%88%9B%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91-toc\" style=\"margin-left:80px;\"><a href=\"#11.%E5%88%9B%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91\">11.创建二叉树</a></p>\n<p id=\"12.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88-toc\" style=\"margin-left:80px;\"><a href=\"#12.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88\">12.二叉树的最近公共祖先</a></p>\n<p id=\"13.%E4%BA%8C%E6%8F%92%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8-toc\" style=\"margin-left:80px;\"><a href=\"#13.%E4%BA%8C%E6%8F%92%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8\">13.二插搜索树转双向链表</a></p>\n<p id=\"14.%E4%BB%8E%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E5%88%B0%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91-toc\" style=\"margin-left:80px;\"><a href=\"#14.%E4%BB%8E%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E5%88%B0%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91\">14.从前序遍历到中序遍历构造二叉树</a></p>\n<p id=\"15.%E4%BB%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%88%B0%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91-toc\" style=\"margin-left:80px;\"><a href=\"#15.%E4%BB%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%88%B0%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91\">15.从中序遍历到后序遍历构造二叉树</a></p>\n<p id=\"16.%E6%A0%B9%E6%8D%AE%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2-toc\" style=\"margin-left:80px;\"><a href=\"#16.%E6%A0%B9%E6%8D%AE%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2\">16.根据二叉树创建字符串</a></p>\n<p id=\"17.%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E9%9D%9E%E9%80%92%E5%BD%92%E5%86%99%E6%B3%95-toc\" style=\"margin-left:80px;\"><a href=\"#17.%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E9%9D%9E%E9%80%92%E5%BD%92%E5%86%99%E6%B3%95\">17.前序遍历非递归写法</a></p>\n<p id=\"18.%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E9%9D%9E%E9%80%92%E5%BD%92%E5%86%99%E6%B3%95-toc\" style=\"margin-left:80px;\"><a href=\"#18.%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E9%9D%9E%E9%80%92%E5%BD%92%E5%86%99%E6%B3%95\">18.中序遍历非递归写法</a></p>\n<p id=\"19.%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E9%9D%9E%E9%80%92%E5%BD%92%E5%86%99%E6%B3%95-toc\" style=\"margin-left:80px;\"><a href=\"#19.%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E9%9D%9E%E9%80%92%E5%BD%92%E5%86%99%E6%B3%95\">19.后序遍历非递归写法</a></p>\n<p id=\"%E6%80%BB%E7%BB%93%3E-toc\" style=\"margin-left:0px;\"><a href=\"#%E6%80%BB%E7%BB%93%3E\">总结&gt;</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n</blockquote>\n<h1 id=\"%E5%89%8D%E8%A8%80\"><a id=\"_7\"></a>前言</h1>\n<blockquote>\n<p>        本文主要讲解<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">二叉树重点知识</span></span>很少涉及无关的背景知识,<span style=\"color:#38d8f0;\">旨在即快速又清晰熟练掌握二叉树并手撕相关面试题</span>,希望我的文章能对你有所帮助与启发.</p>\n</blockquote>\n<hr/>\n<h1 id=\"%E4%B8%80%3E%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84\">一&gt;树形结构</h1>\n<h2 id=\"1.%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5\">1.树的概念</h2>\n<p><img alt=\"\" height=\"635\" src=\"..\\..\\static\\image\\ebfacd12f29f42279968e64210f6e0e5.png\" width=\"1200\"/></p>\n<blockquote>\n<p>         学习二叉树之前我们首先要了解树形结构,树是一种<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">非线性</span></span>结构,它是由n(n&gt;=0)个有限节点组成的的具有层次关系的集合,之所以把它叫做树,是因为该结构看起来像是一颗倒挂的树.树具有以下特点:</p>\n<ul><li>树的<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">根节点</span></span>无前驱节点</li><li>其余节点有且仅有一个<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">前驱</span></span>,但有多个<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">后继</span></span></li><li>树是由<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">递归</span></span>定义的</li></ul>\n</blockquote>\n<blockquote>\n<p><strong>重要概念:</strong></p>\n<ul><li><strong>节点</strong>的<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">度</span></span>:一个节点含有的<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">子节点</span></span>的个数叫做节点的度,如上图中A的度为7.</li><li><strong>树</strong>的<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">度</span></span>:一个树中,最大节点的度称为树的度,如上图数的度为7.</li><li><strong>叶子节点</strong>:度数为<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">0</span></span>的节点叫叶子节点</li><li><strong>父节点</strong>:若一个节点有子节点,则这个节点称为其子节点的父节点.</li><li><strong>根节点</strong>:一个树种,无父节点的节点.如A</li><li><strong>节点的</strong><span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">层次</span></span>:从根开始定义,根为第一层,根的子节点为第二层,以此类推.</li><li><strong>树的</strong><span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">深度</span></span>:树的<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">最大</span></span>层次.如上图树的深度为3.</li></ul>\n</blockquote>\n<hr/>\n<h2 id=\"2.%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8\">2.树的应用</h2>\n<blockquote>\n<p>我们平时使用的各种文件系统管理,其底层逻辑都是<span style=\"background-color:#a2e043;\">树形结构.</span></p>\n</blockquote>\n<p><img alt=\"\" height=\"731\" src=\"..\\..\\static\\image\\ce5dcd4d631e45e299e8f1a5434a0791.png\" width=\"1200\"/></p>\n<hr/>\n<h1 id=\"%E4%BA%8C%3E%E4%BA%8C%E5%8F%89%E6%A0%91\">二&gt;二叉树</h1>\n<h2 id=\"1.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5\">1.二叉树的概念</h2>\n<blockquote>\n<p>在树形结构的基础上二叉树有<strong>两个特点</strong>:</p>\n<ul><li>每个节点最多<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">两颗</span></span>子树,即二叉树不存在度数大于二的节点.</li><li>每个二叉树的子树有左右之分,其子树的次序不能颠倒,因此二叉树是<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">有序</span></span>树.</li></ul>\n</blockquote>\n<hr/>\n<h2 id=\"%C2%A02.%E4%B8%A4%E7%A7%8D%E7%89%B9%E6%AE%8A%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91\"> 2.两种特殊的二叉树</h2>\n<p><img alt=\"\" height=\"657\" src=\"..\\..\\static\\image\\47c600b49f794e0696ada34888579414.png\" width=\"1200\"/></p>\n<blockquote>\n<ul><li><strong>满二叉树</strong>:每一层的节点数都达到最大值就是满二叉树.</li><li><strong>完全二叉树</strong>:完全二叉树是效率很高的数据结构,每一个节点与树中编号一一对应,所以<span style=\"background-color:#a2e043;\">满二叉树是一种特殊的完全二叉树. </span></li></ul>\n</blockquote>\n<hr/>\n<h2 id=\"3.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8\"><strong>3.二叉树的性质</strong></h2>\n<blockquote>\n<ul><li>若规定<span style=\"color:#0d0016;\"><span style=\"background-color:#d4e9d5;\">根节点的层数为1</span></span><span style=\"background-color:#d4e9d5;\">,</span>则一颗<span style=\"color:#0d0016;\">非空二叉树的</span><span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">第i层</span></span><span style=\"color:#0d0016;\">有有 </span><span style=\"color:#38d8f0;\"><img alt=\"2^{i-1}\" class=\"mathcode\" src=\"https://latex.codecogs.com/gif.latex?2%5E%7Bi-1%7D\"/></span><span style=\"color:#0d0016;\">(i&gt;0)个节点.</span></li><li>若规定<span style=\"color:#0d0016;\"><span style=\"background-color:#d4e9d5;\">根节点的二叉树的深度为1</span></span>,则<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">深度为k</span></span>的二叉树的<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">最大</span></span><span style=\"color:#0d0016;\">节点个数为</span><span style=\"color:#38d8f0;\"><img alt=\"2^{k-1}\" class=\"mathcode\" src=\"https://latex.codecogs.com/gif.latex?2%5E%7Bk-1%7D\"/></span><span style=\"color:#0d0016;\">(k&gt;=0).</span></li><li><span style=\"color:#0d0016;\">对于</span><span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">高度为k</span></span><span style=\"color:#0d0016;\">的二叉树,最多有<img alt=\"2^{k+1}-1\" class=\"mathcode\" src=\"https://latex.codecogs.com/gif.latex?2%5E%7Bk&amp;plus;1%7D-1\"/>个节点.</span></li><li><span style=\"color:#0d0016;\">对任何一颗二叉树</span><span style=\"color:#0d0016;\">,</span><span style=\"color:#0d0016;\">如果其叶子节点个数为n0,其度数为2的非叶子节点的个数为n2,那么   </span><span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">     n0=n2+1</span>.</span><span style=\"color:#956fe7;\">证法如下(1)</span></li><li>具有<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">n</span></span><span style=\"color:#0d0016;\">个节点</span>的<span style=\"color:#38d8f0;\">完全二叉树的深度为<img alt=\"\\log_{2} (n+1)\" class=\"mathcode\" src=\"https://latex.codecogs.com/gif.latex?%5Clog_%7B2%7D%20%28n&amp;plus;1%29\"/>向上取整.</span><span style=\"color:#956fe7;\">证法如下(2)</span></li><li>对于有n个节点的完全二叉树,如果按照从<span style=\"background-color:#a2e043;\">上到下</span><span style=\"color:#0d0016;\"><span style=\"background-color:#a2e043;\">从左到右</span>的顺序</span>对所以有节点从0开始编号,则对于序号为i的节点有: \n   <ul><li>若i&gt;0双亲序号为:<span style=\"color:#38d8f0;\">(i/2)-1</span>.</li><li>若2i+1&lt;n,左孩子序列为<span style=\"color:#38d8f0;\">2i+1</span>,否则无左孩子.</li><li>若2i+2&lt;n,右孩子序列为<span style=\"color:#38d8f0;\">2i+2</span>,否则无右孩子.</li></ul></li></ul>\n<hr/>\n<p></p>\n</blockquote>\n<blockquote>\n<p><span style=\"color:#956fe7;\">证(1):&gt;</span></p>\n<ol><li>设二叉树顶点数=N,度数为0的节点为n0,度数为1的节点为n1,度数为2的为n2.</li><li><span style=\"color:#0d0016;\">度数和=顶点数(N)-1.(度数和 = N-1)</span></li><li>顶点数(N) = n0+n1+n2.</li><li>度数和 = 0*n0+1*n1+2*n2.</li><li>结合2,3,4可得:0*n0+1*n1+2*n2 = n0+n1+n2-1</li><li>化简得:n0 = n2+1</li></ol>\n<p><span style=\"color:#956fe7;\"> 证(2):&gt; </span></p>\n<ul><li><span style=\"color:#0d0016;\">深度为1的节点数<img alt=\"2^{0}\" class=\"mathcode\" src=\"https://latex.codecogs.com/gif.latex?2%5E%7B0%7D\"/>,深度为2的节点数为<img alt=\"2^{1}\" class=\"mathcode\" src=\"https://latex.codecogs.com/gif.latex?2%5E%7B1%7D\"/>.....深度为k的节点数为<img alt=\"2^{k-1}\" class=\"mathcode\" src=\"https://latex.codecogs.com/gif.latex?2%5E%7Bk-1%7D\"/>,由</span><span style=\"color:#956fe7;\">等比数列        求和公式: </span>  <img alt=\"{\\color{Red} \\frac{1-2^{n}}{1-2}\" class=\"mathcode\" src=\"https://latex.codecogs.com/gif.latex?%7B%5Ccolor%7BRed%7D%20%5Cfrac%7B1-2%5E%7Bn%7D%7D%7B1-2%7D\"/><span style=\"color:#0d0016;\">   .那么节点数为n的深度为<img alt=\"{\\color{Magenta} \\log_{2}n+1}\" class=\"mathcode\" src=\"https://latex.codecogs.com/gif.latex?%7B%5Ccolor%7BMagenta%7D%20%5Clog_%7B2%7Dn&amp;plus;1%7D\"/>.</span></li></ul>\n</blockquote>\n<hr/>\n<h2 id=\"4.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8\">4.二叉树的存储</h2>\n<blockquote>\n<p>        二叉树的存储结构分为<span style=\"color:#38d8f0;\">顺序存储</span>和<span style=\"color:#38d8f0;\">类似于链表的链式存储</span>,本章采用<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">链式存储</span></span>.表示方法采用<span style=\"color:#fe2c24;\">孩子表示法</span>,即一个节点中包含<strong><span style=\"color:#0d0016;\">数据域,左孩子与右孩子</span></strong>.</p>\n</blockquote>\n<pre><code class=\"language-java\">class Node {\nint val; // 数据域\nNode left; // 左孩子的引用，常常代表左孩子为根的整棵左子树\nNode right; // 右孩子的引用，常常代表右孩子为根的整棵右子树\n}</code></pre>\n<hr/>\n<h2 id=\"5.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%9B%E5%BB%BA\">5.二叉树的创建</h2>\n<blockquote>\n<p><strong>二叉树的创建需要三步:</strong></p>\n<ol><li>创建<strong>结点</strong>:包含<span style=\"background-color:#a2e043;\">数值域</span>,<span style=\"background-color:#fbd4d0;\">左</span>孩子结点,<span style=\"background-color:#fbd4d0;\">右</span>孩子结点</li><li>创建<strong>二叉树</strong>:我们采用<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">前序遍历</span></span>+<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">递归</span></span>的方式创建二叉树.</li><li>输入要创建的<strong>序列</strong>:本文二叉树的物理连接方式是<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">链表</span></span>,所以我们采用LinkedList集合存储二叉树内容.使用<strong>asList</strong>方法写入数组.</li></ol>\n</blockquote>\n<p><img alt=\"\" height=\"778\" src=\"..\\..\\static\\image\\c64d51ea3fb8477ea443196e3fbada65.png\" width=\"1200\"/></p>\n<pre><code class=\"language-java\">class TreeNode{//二叉树节点\n   int data;\n   TreeNode1 leftChild;\n   TreeNode1 rightChild;\n\n    public TreeNode1(int data) {\n        this.data = data;\n    }\n}\npublic static TreeNode createBinaryTree(LinkedList&lt;Integer&gt; inputList){//创建二叉树\n        TreeNode node = null;\n        if (inputList==null||inputList.isEmpty()){\n            return null;\n        }\n        Integer data = inputList.removeFirst();//每次取出集合中的第一个元素\n        //这里判空很重要,如果元素为空,则不在进一步递归.\n        if (data!=null){\n            node = new TreeNode1(data);\n            node.leftChild = createBinaryTree(inputList);\n            node.rightChild = createBinaryTree(inputList);\n        }\n        return node;\n    }\npublic static void main(String[] args) {\n        LinkedList&lt;Integer&gt; inputList = new LinkedList&lt;&gt;        \n        (Arrays.asList(3,2,9,null,null,10,null,null,8,null,4));\n        TreeNode1 treeNode1 = createBinaryTree(inputList);\n    }</code></pre>\n<hr/>\n<h2 id=\"6.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86\">6.二叉树的遍历</h2>\n<blockquote>\n<p>        初学二叉树时,许多同学会很疑惑二叉树为什么需要这么多的遍历方法?</p>\n</blockquote>\n<h3 id=\"1)%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86\">1)前序遍历</h3>\n<pre><code class=\"language-java\">public static void preOrderTraveral(TreeNode node){//to前序遍历\n        if (node==null){\n            return;\n        }\n        System.out.print(node.data+\" \");\n        preOrderTraveral(node.leftChild);\n        preOrderTraveral(node.rightChild);\n    }</code></pre>\n<hr/>\n<h3 id=\"2)%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86\">2)中序遍历</h3>\n<pre><code class=\"language-java\">public static void midOrderTraveral(TreeNode node){//中序遍历\n        if (node==null){\n            return;\n        }\n        midOrderTraveral(node.leftChild);\n        System.out.print(node.data+\" \");\n        midOrderTraveral(node.rightChild);\n    }</code></pre>\n<hr/>\n<h3 id=\"3)%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%C2%A0\">3)后序遍历 </h3>\n<pre><code class=\"language-java\">public static void lastOrderTraveral(TreeNode node){//后序遍历\n        if (node==null){\n            return;\n        }\n        lastOrderTraveral(node.leftChild);\n        lastOrderTraveral(node.rightChild);\n        System.out.print(node.data+\" \");\n    }</code></pre>\n<hr/>\n<h3 id=\"4)%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86\">4)层序遍历</h3>\n<pre><code class=\"language-java\">  public static void levelOrderTraveral(TreeNode root) {//层序遍历\n        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();\n        queue.offer(root);\n        while (!queue.isEmpty()){\n            TreeNode node = queue.poll();\n            System.out.println(node.data);\n            if (node.leftChild!=null){\n                queue.offer(node.leftChild);\n            }\n            if (node.rightChild!=null){\n                queue.offer((node.rightChild));\n            }\n        }\n    }</code></pre>\n<hr/>\n<h3 id=\"5)%E5%AD%90%E9%97%AE%E9%A2%98%E6%80%9D%E8%B7%AF%E4%B8%8E%E9%81%8D%E5%8E%86%E6%80%9D%E8%B7%AF%E7%9A%84%E5%8C%BA%E5%88%AB%C2%A0\">5)子问题思路与遍历思路的区别 </h3>\n<blockquote>\n<p>        许多初学二叉树的同学,可能无法很好的理解子问题思路与遍历思路的区别,导致许多题目一知半解.下面我们详细讲解一下子问题思路与遍历思路.假设我们要求一颗二叉树所有节点的个数.</p>\n<ul><li>遍历思路:定义一个变量count记录节点个数,每遍历一个节点count++,最后返回count即可.</li><li>子问题思路:将二叉树看成由许多个小的二插树组成.每个小树算完再返回给上一层的大树.</li></ul>\n</blockquote>\n<p><img alt=\"\" height=\"500\" src=\"..\\..\\static\\image\\ccf5522ca9cf436b9488fc04206ab730.png\" width=\"841\"/></p>\n<pre><code class=\"language-java\">class Solution {//遍历思路\n    int count = 0;\n    public int countNodes(TreeNode root) {\n        if(root==null){\n            return 0;\n        }\n            count++;\n            countNodes(root.left);\n            countNodes(root.right);\n    return count;\n  }\n}</code></pre>\n<pre><code class=\"language-java\">class Solution {//子问题思路拆解写法\n    public int countNodes(TreeNode root) {\n        if(root==null){\n            return 0;\n        }\n        int leftTreeCount = countNodes(root.left);\n        int rightTreeCount = countNodes(root.right);\n        return leftTreeCount+rightTreeCount+1;\n    }\n}</code></pre>\n<hr/>\n<h3 id=\"5)leetcode%E6%8F%90%E4%BA%A4%E5%81%9A%E6%B3%95\">6)leetcode提交做法</h3>\n<blockquote>\n<p>        在leetcode中刷题我们发现,无论是哪种遍历方式都需要返回一个<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">List集合</span></span>类型的值,也就是将<strong>二叉树的信息存在集合中并返回</strong>.这里提供两种思路:</p>\n<ul><li><strong>遍历思路</strong>:如果在二叉树的类中new一个List对象,那么每次遍历都会new对象,很显然这样做无法返回所有对象,所以我们只需将List集合创建在前序遍历类外,不断的遍历二叉树向集合中添加元素,最后返回存好的对象即可.</li><li><strong>子问题思路</strong>:如果每次遍历二叉树都会创建新的对象,那么我们可以把所有创建出的对象,分为左右子树,最终加和到一个对象里返回即可.</li></ul>\n</blockquote>\n<p><img alt=\"\" height=\"500\" src=\"..\\..\\static\\image\\366d49ffd3f4498c8777a20b44e6b1e0.png\" width=\"689\"/></p>\n<pre><code class=\"language-java\">    List&lt;Integer&gt; relist = new ArrayList&lt;Integer&gt;();//集合创建在类外\n    public List&lt;Integer&gt; preorderTraversal(TreeNode root) {//遍历思路\n        if(root==null){\n            return relist;\n        }\n        relist.add(root.val);\n        preorderTraversal(root.left);\n        preorderTraversal(root.right);\n        return relist;\n    }</code></pre>\n<pre><code class=\"language-java\">public List&lt;Integer&gt; preorderTraversal(TreeNode root) {//子问题思路\n        List&lt;Integer&gt; relist = new ArrayList&lt;Integer&gt;();\n        if(root==null){\n            return relist;\n        }\n        relist.add(root.val);\n        List&lt;Integer&gt; leftTree = preorderTraversal(root.left);\n        relist.addAll(leftTree);//所有的左树\n        List&lt;Integer&gt; rigthTree = preorderTraversal(root.right);\n        relist.addAll(rigthTree);//所有的右树\n        return relist;\n    }</code></pre>\n<blockquote>\n<p>        leetcode中<strong>层序遍历</strong>的提交方法更为特殊,需要返回一个List集合的二维数组.只需每遍历一层二叉树就存进一个一维数组中,最后将所有一位数组存进二维数组中返回即可.</p>\n</blockquote>\n<p><img alt=\"\" height=\"500\" src=\"..\\..\\static\\image\\9b74d97f3a6545d58183647ba0a7cbd6.png\" width=\"668\"/></p>\n<pre><code class=\"language-java\">public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {\n        List&lt;List&lt;Integer&gt;&gt; ret = new ArrayList();\n        if(root==null) return ret;\n        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();\n        queue.offer(root);\n        while(!queue.isEmpty()){\n            int size = queue.size();\n            List&lt;Integer&gt; list = new ArrayList&lt;&gt;();\n            while(size!=0){\n                TreeNode cur = queue.poll();\n                if(cur.left!=null){\n                    queue.offer(cur.left);\n                }\n                if(cur.right!=null){\n                    queue.offer(cur.right);\n                }\n                size--;\n                list.add(cur.val);\n            }\n            ret.add(list);\n        }\n        return ret;\n\n    }</code></pre>\n<hr/>\n<h1 id=\"%E4%B8%89%20%3E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98\">三 &gt;二叉树常见面试题</h1>\n<h2 id=\"1.%E9%80%89%E6%8B%A9%E9%A2%98%E9%83%A8%E5%88%86%3A\">1.选择题部分:</h2>\n<blockquote>\n<p>1.1 某二叉树公有399个节点,其中有199个度为2的节点,则该二叉树中子节点的个数为().</p>\n<p></p>\n<p>A.200                      B.198                          C.199                       D.不存在这样的二叉树</p>\n</blockquote>\n<p>由上文已知,n0 = n2+1.那么199个2度节点就对应198个0度节点.<strong>(B)</strong></p>\n<hr/>\n<blockquote>\n<p>1.2 在具有2n个节点的完全二叉树中,子节点个数为()</p>\n<p></p>\n<p>A.n                          B.n+1                          C.n-1                        D.n/2            </p>\n</blockquote>\n<p><img alt=\"\" height=\"705\" src=\"..\\..\\static\\image\\4dde25dedf3643adb05c3d8e98d62d22.png\" width=\"1200\"/></p>\n<p>2n个节点说明节点数一定是<span style=\"background-color:#fef2f0;\">偶数</span>, 那么该二叉树<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">n1 = 1</span></span>(只有一个一度点),根据定理可知n0 = n2+1.设子节点个数为x,那么2n = n0+1+n2可写为:2n = 2x,化简得:x = n. <strong>(A)</strong></p>\n<hr/>\n<blockquote>\n<p> 1.3  一个具有767个节点的完全二叉树,其叶子节点个数为多少()</p>\n<p></p>\n<p>A.383                      B.384                          C.385                        D.386</p>\n</blockquote>\n<p>由上文已知767个节点为奇数,那么一定没有<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">1度</span></span>的节点,根据定理 n0 = n2+1,设子节点个数为x,那么767 = n0+n2可写为:2x-1,化简得x = 384. <strong>(B)</strong></p>\n<hr/>\n<blockquote>\n<p> 1.4 一颗完全二叉树的节点个数为531,那么这棵树的高度为()</p>\n<p>A.11                         B.10                            C.8                            D.12 </p>\n</blockquote>\n<p> 由定理具有n个节点的完全二叉树深度为:<img alt=\"\\log_{2} (n+1)\" class=\"mathcode\" src=\"https://latex.codecogs.com/gif.latex?%5Clog_%7B2%7D%20%28n&amp;plus;1%29\"/><span style=\"color:#0d0016;\">向上取整,所以我们需要估算<img alt=\"\\log_{2}532\" class=\"mathcode\" src=\"https://latex.codecogs.com/gif.latex?%5Clog_%7B2%7D532\"/>,答案比9大但比10小,基于向上取整的原则我们选择10. <strong>(B)</strong></span></p>\n<hr/>\n<blockquote>\n<p>1.5 二叉树的前序遍历和中序遍历如下:前序遍历:EFHIGJK;中序遍历:HFIEJKG,则二叉树的根节点为()</p>\n<p></p>\n<p>A.E                           B.F                              C.G                            D.H</p>\n</blockquote>\n<p>前序遍历确定根节点为E,中序遍历确定二叉树的分布为:左树HFI,右树:JKG.<strong>(E)</strong></p>\n<hr/>\n<blockquote>\n<p>1.6 设一颗二叉树的中序遍历序列:badce,后序遍历:bdeca,则二叉树前序遍历序列为()</p>\n<p></p>\n<p>A.adbce                  B.decab                        C.debac                    D.abcde</p>\n</blockquote>\n<p>后续遍历确定二叉树的根节点位a,中序遍历确定二叉树的分布为:左树b,右树为dce.由后续遍历的规则画好二叉树后得前序遍历为abcde.</p>\n<hr/>\n<blockquote>\n<p>1.7 某二叉的后序遍历和中序遍历序列相同,均为ABCDEF,则按层序输出的序列为()</p>\n<p></p>\n<p>A.FEDCBA             B.CBAFED                   C.DEFCBA                D.ABCDEF </p>\n</blockquote>\n<p> 后续遍历确定根节点为F,中序遍历确定节点全部在左树,根据后续遍历的规则画出图:</p>\n<p><img alt=\"\" height=\"500\" src=\"..\\..\\static\\image\\3f3113a1665e4b1d828907b50b5a2c68.png\" width=\"814\"/></p>\n<p>按层序输出为FEDCBA. <strong>(A)</strong></p>\n<hr/>\n<h2 id=\"2.%E7%BC%96%E7%A8%8B%E9%A2%98%E9%83%A8%E5%88%86%3A\">2.编程题部分:</h2>\n<h3 id=\"1.%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0\">1.节点个数</h3>\n<p><img alt=\"\" height=\"500\" src=\"..\\..\\static\\image\\6ddc5fc4520b47adb2121f62070dfbad.png\" width=\"388\"/></p>\n<blockquote>\n<p>此题变相考察二叉树的<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">遍历</span></span>方式,只要会遍历二叉树即可得出结果.博主提供两种思路:<strong>遍历思路</strong>和<strong>子问题思路.</strong>上文已对子问题思路和遍历思路详细的解析这里不过多赘述.</p>\n</blockquote>\n<pre><code class=\"language-java\">class Solution {//子问题思路\n    public int countNodes(TreeNode root) {\n        if(root==null){\n            return 0;\n        }\n        return countNodes(root.left)+countNodes(root.right)+1;\n    }\n}\nclass Solution {//子问题思路拆解写法\n    public int countNodes(TreeNode root) {\n        if(root==null){\n            return 0;\n        }\n        int leftTreeCount = countNodes(root.left);\n        int rightTreeCount = countNodes(root.right);\n        return leftTreeCount+rightTreeCount+1;\n    }\n}</code></pre>\n<pre><code class=\"language-java\">class Solution {//遍历思路\n    int count = 0;\n    public int countNodes(TreeNode root) {\n        if(root==null){\n            return 0;\n        }\n            count++;\n            countNodes(root.left);\n            countNodes(root.right);\n    return count;\n  }\n}</code></pre>\n<hr/>\n<h3 id=\"2.%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0\">2.叶子节点个数</h3>\n<blockquote>\n<p>与节点个数写法一致,只不过记录数据的条件改为:当<span style=\"background-color:#a2e043;\">左右节点都为空</span>时<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">++</span></span>.依旧是两种思路:</p>\n</blockquote>\n<pre><code class=\"language-java\">public static int getLeafNodeCount(TreeNode root){//完全二叉树叶子节点个数 遍历思路\n        if (root==null){\n            return 0;\n        }\n        if (root.leftChild==null&amp;&amp;root.rightChild==null){\n            count++;\n        }\n        getLeafNodeCount(root.leftChild);\n        getLeafNodeCount(root.rightChild);\n        return count;\n    }\n   </code></pre>\n<pre><code class=\"language-java\"> public static int getLeafNodeCount1(TreeNode root){//完全二叉树叶子节点个数 子问题思路\n        if (root==null){\n            return 0;\n        }\n        if (root.leftChild==null&amp;&amp;root.rightChild==null){\n            return 1;\n        }\n        return getLeafNodeCount(root.leftChild)+getLeafNodeCount(root.rightChild);\n    }\n</code></pre>\n<hr/>\n<h3 id=\"3.%E8%8E%B7%E5%8F%96%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AC%ACK%E5%B1%82%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%AA%E6%95%B0\">3.获取二叉树第K层节点的个数</h3>\n<blockquote>\n<p>该题使用<strong>子问题思路</strong>,重点是如何找到第K层?我们可以逆向来思考,如果让我们找第三层,我们可以假设第一层为3,每下一层就减1,当k==1时找到第三层.</p>\n</blockquote>\n<p> <img alt=\"\" height=\"500\" src=\"..\\..\\static\\image\\fca18535bbc447d2885d48c1df7d36c8.png\" width=\"1090\"/></p>\n<pre><code class=\"language-java\">public static int getLevelNodeCount(TreeNode root,int k){//获取第k层节点的个数\n        if(root==null||k&lt;=0){\n            return 0;\n        }\n        if (k==1){\n            return 1;\n        }\n        return getLevelNodeCount(root.leftChild,k-1)\n                +getLevelNodeCount(root.rightChild,k-1);\n    }</code></pre>\n<hr/>\n<h3 id=\"4.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%AB%98%E5%BA%A6\">4.二叉树的高度</h3>\n<blockquote>\n<p>该题使用<strong>子问题思路</strong>,由于可能出现<span style=\"background-color:#a2e043;\">左树或右树为空另一颗树不为空的情况</span>,所以我们可以比较左树和右树的高度,返回<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">最大</span></span>的即可.</p>\n</blockquote>\n<p> <img alt=\"\" height=\"500\" src=\"..\\..\\static\\image\\32c00d5156214e78973d5e703969c8ae.png\" width=\"585\"/></p>\n<pre><code class=\"language-java\">public static int getHeight(TreeNode root){//获取二叉树的高度\n        if (root==null){\n            return 0;\n        }\n        int leftHeight = getHeight(root.leftChild);\n        int rightHeight = getHeight(root.rightChild);\n        return leftHeight&gt;rightHeight?leftHeight+1:rightHeight+1;\n    }</code></pre>\n<hr/>\n<h3 id=\"5.%E6%A3%80%E6%B5%8B%E5%80%BC%E4%B8%BAvalue%E7%9A%84%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8\">5.检测值为value的元素是否存在</h3>\n<blockquote>\n<p>该题为<strong>遍历思路</strong>,设置好递归的结束条件:<span style=\"background-color:#a2e043;\">节点为空或者节点的值为要查找的值</span>.</p>\n</blockquote>\n<pre><code class=\"language-java\">public static TreeNode find(TreeNode root,char val){//检测value元素是否存在\n        if (root==null){\n            return null;\n        }\n        if (root.data==val){\n            return root;\n        }\n        TreeNode retLeft = find(root.leftChild,val);//先去左树找\n        if (retLeft!=null){//说明找到了\n            return retLeft;\n        }\n        TreeNode retRight = find(root.rightChild,val);//再去右树找\n        if (retRight!=null){//说明找到了\n            return retRight;\n        }\n        return null;\n    }</code></pre>\n<hr/>\n<h3 id=\"6.%E5%88%A4%E6%96%AD%E4%B8%80%E6%A3%B5%E6%A0%91%E6%98%AF%E4%B8%8D%E6%98%AF%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91\">6.判断一棵树是不是完全二叉树(栈)</h3>\n<blockquote>\n<p>由之前的知识可知,完全二叉树每一个节点都与树中编号对应,说明一定是有<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">顺序</span></span>的.说到顺序我们首先要考虑<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">栈</span></span>和<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">队列</span></span>这两种数据结构.判断是不是完全二叉树,当一个节点没有利用价值时要立刻弹出,所以<span style=\"background-color:#a2e043;\">队列头进头出</span>的方式最为合适.如下图所示,如果是<span style=\"background-color:#38d8f0;\">完全二叉树那么队列中的空元素一定是连续的.</span></p>\n</blockquote>\n<p><img alt=\"\" height=\"655\" src=\"..\\..\\static\\image\\25ff878322a3423ab45a9ac59e8bab28.png\" width=\"1200\"/></p>\n<pre><code class=\"language-java\"> public static boolean isCompleteTree1(TreeNode root){//判断是不是完全二叉树,队列\n        if (root==null)return true;\n        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();\n        queue.offer(root);\n        while (!queue.isEmpty()){\n            TreeNode cur = queue.poll();\n            if (cur!=null){\n                queue.offer(cur.leftChild);\n                queue.offer(cur.rightChild);\n            }else {\n                break;\n            }\n        }\n        while (!queue.isEmpty()){\n            if (queue.poll()!=null){\n                return false;\n            }\n        }\n        return true;\n    }</code></pre>\n<hr/>\n<h3 id=\"7.%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91\">7.相同的树</h3>\n<p><img alt=\"\" height=\"500\" src=\"..\\..\\static\\image\\122a3fe0580c49a4b22174318c22e1d6.png\" width=\"556\"/></p>\n<blockquote>\n<p>该题为<strong>子问题思路</strong>,做法为排除所有错误情况,剩余正确的.相同的树指的是,节点的值相同且树的结构也是相同的.</p>\n<p>时间复杂度O(min(m,n)){左树节点个数为m,右树节点个数为n}</p>\n</blockquote>\n<pre><code class=\"language-java\">public boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p==null&amp;&amp;q!=null)return false;\n        if(p!=null&amp;&amp;q==null)return false;\n        if(p==null&amp;&amp;q==null)return true;\n        if(p.val!=q.val){\n            return false;\n        }\n        return isSameTree(p.left,q.left)&amp;&amp;isSameTree(p.right,q.right);\n    }</code></pre>\n<hr/>\n<h3 id=\"8.%E5%8F%A6%E4%B8%80%E6%A3%B5%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91\">8.另一棵树的子树</h3>\n<p><img alt=\"\" height=\"500\" src=\"..\\..\\static\\image\\e9ae9ad7dfc746f8a201667e87c588b3.png\" width=\"345\"/></p>\n<blockquote>\n<p>该题建立在判断两颗树是否<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">相同</span></span>的基础上,运用子问题思路,先判断<span style=\"background-color:#a2e043;\">根节点</span>是不是子树,如果没有再判断<span style=\"background-color:#a2e043;\">左子树</span>中有没有子树,如果没有再判断<span style=\"background-color:#a2e043;\">右子树</span>中有没有子树.</p>\n</blockquote>\n<p> 时间复杂度O(m*n)</p>\n<p>本质判断相同</p>\n<pre><code class=\"language-java\">public boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p==null&amp;&amp;q!=null)return false;\n        if(p!=null&amp;&amp;q==null)return false;\n        if(p==null&amp;&amp;q==null)return true;\n       \n        if(p.val!=q.val){\n            return false;\n        }\n        return isSameTree(p.left,q.left)&amp;&amp;isSameTree(p.right,q.right);\n    }\n    public boolean isSubtree(TreeNode root, TreeNode subRoot) {\n        if(root==null||subRoot==null){\n            return false;\n        }\n        //判断是否是相同的树\n        if(isSameTree(root,subRoot)){\n            return true;\n        }\n        //判断是不是左子树\n        if(isSubtree(root.left,subRoot)){\n            return true;\n        }\n        //判读是否是右子树\n        if(isSubtree(root.right,subRoot)){\n            return true;\n        }\n        //既不是左子树,也不是右子树,且不相同\n        return false;\n    }</code></pre>\n<hr/>\n<h3 id=\"9.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91\">9.平衡二叉树(字节跳动原题)</h3>\n<p><img alt=\"\" height=\"500\" src=\"..\\..\\static\\image\\73750360cd394a4883dee473ab69cd04.png\" width=\"591\"/></p>\n<blockquote>\n<p>该题为<strong>子问题思路</strong>,需要之前判断<span style=\"background-color:#a2e043;\">二叉树高度</span>的知识,一棵树如果是平衡二叉树那么其子树也一定是平衡二叉树,本质就是判断所有子树的高度差是否<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">大于1</span></span>.由于该题较为经典,所以提供两种做法不同的做法.</p>\n</blockquote>\n<p><strong>时间复杂度O(N^2)</strong></p>\n<blockquote>\n<p>遍历每一个子树,如果高度差&lt;=1,返回true.但是该方法要为每一个节点都计算高度,时间复杂度大大增加.</p>\n</blockquote>\n<pre><code class=\"language-java\">public int height (TreeNode root){\n        if(root==null){\n            return 0;\n        }\n        int leftHeight = height(root.left);\n        int rightHeight = height(root.right);\n        return leftHeight&gt;rightHeight?(leftHeight+1):(rightHeight+1);\n    }\n    public boolean isBalanced(TreeNode root) {\n        if(root==null){\n            return true;\n        }\n        int leftHeight = height(root.left);\n        int rightHeight = height(root.right);\n        return Math.abs(leftHeight-rightHeight)&lt;=1&amp;&amp;isBalanced(root.left)&amp;&amp;isBalanced(root.right);\n\n    }</code></pre>\n<p><strong>时间复杂度O(N)</strong></p>\n<blockquote>\n<p>改进方法是如果父亲节点已经计算过高度那么子节点无需再次遍历.如果左右子树的高度差&gt;1说明不是平衡二叉树,那么将不断递归返回<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">-1</span></span>.如果是平衡二叉树那么一定会返回一个正数,所以我们只需判断返回值的<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">正负</span></span>即可.</p>\n</blockquote>\n<pre><code class=\"language-java\">public int height (TreeNode root){\n        if(root==null){\n            return 0;\n        }\n        int leftHeight = height(root.left);\n        int rightHeight = height(root.right);\n        if(leftHeight&gt;=0&amp;&amp;rightHeight&gt;=0&amp;&amp;Math.abs(leftHeight-rightHeight)&lt;=1){\n           return leftHeight&gt;rightHeight?(leftHeight+1):(rightHeight+1);\n        }else{\n            return -1;\n        }\n    }\n    public boolean isBalanced(TreeNode root) {\n        if(root==null){\n            return true;\n        }\n       return height(root)&gt;=0;\n    }</code></pre>\n<hr/>\n<h3 id=\"10.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91\">10.对称二叉树</h3>\n<p><img alt=\"\" height=\"500\" src=\"..\\..\\static\\image\\2952d8dbee4749829a495fd08c6281da.png\" width=\"421\"/></p>\n<blockquote>\n<p> 该题为<strong>子问题思路</strong>,对称二叉树要求左右子树对称的部分值相同,很明显一个参数的函数无法同时比较两颗子树,所以我们需要构造一个两个参数的函数,分别比较<span style=\"background-color:#a2e043;\">左树的左与右树的右</span>.</p>\n</blockquote>\n<pre><code class=\"language-java\">public boolean isSymmetricChild(TreeNode rootleft,TreeNode rootrigth){\n        \n        if(rootleft==null&amp;&amp;rootrigth!=null){\n            return false;\n        }\n        if(rootleft!=null&amp;&amp;rootrigth==null){\n            return false;\n        }\n        if(rootleft==null&amp;&amp;rootrigth==null){\n            return true;\n        }\n        if(rootleft.val!=rootrigth.val){\n            return false;\n        }\n        return isSymmetricChild(rootleft.left,rootrigth.right)&amp;&amp;isSymmetricChild(rootleft.right,rootrigth.left);\n    }\n    public boolean isSymmetric(TreeNode root) {\n        if(root==null){\n            return true;\n        }\n        return isSymmetricChild(root.left,root.right);\n    }</code></pre>\n<hr/>\n<h3 id=\"11.%E5%88%9B%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91\">11.创建二叉树</h3>\n<p><img alt=\"\" height=\"500\" src=\"..\\..\\static\\image\\2a5c75d3644d4cf0afa0bf0affddff9e.png\" width=\"946\"/></p>\n<blockquote>\n<p> 该题主要分为三部分:<span style=\"background-color:#a2e043;\">创建结点</span>,<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">创建二叉树</span></span>,<span style=\"background-color:#a2e043;\">中序遍历输出</span>.创建结点与中序遍历上文已经提到过,创建二叉树时采用前序遍历的思想也可以很容易写出.</p>\n</blockquote>\n<pre><code class=\"language-java\">import java.util.*;\n\nclass TreeNode{//创建结点\n    public char val;\n    public TreeNode left;\n    public TreeNode right;\n    public TreeNode(char val){\n        this.val = val;\n    }\n}\npublic class Main{\n    public static int i = 0;\n    public static TreeNode createTree(String str){//创建二叉树\n        TreeNode root = null;\n        if(str.charAt(i)!='#'){\n            root = new TreeNode(str.charAt(i));\n            i++;\n            root.left = createTree(str);\n            root.right = createTree(str);\n        }else{\n            i++;\n        }\n        return root;\n    }\n    public static void inorder(TreeNode root){//中序遍历\n        if(root==null){\n            return ;\n        }\n        inorder(root.left);\n        System.out.print(root.val+\" \");\n        inorder(root.right);\n    }\n    public static void main(String[] args){\n        Scanner in = new Scanner(System.in);\n        while(in.hasNextLine()){\n            String str = in.nextLine();\n            TreeNode root = createTree(str);\n            inorder(root);\n        }\n    }\n}</code></pre>\n<hr/>\n<h3 id=\"12.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88\">12.二叉树的最近公共祖先</h3>\n<p><img alt=\"\" height=\"500\" src=\"..\\..\\static\\image\\31dc6f1a15714ad6945fa277c61a3bc2.png\" width=\"425\"/></p>\n<blockquote>\n<p>该题为<strong>子问题思路</strong>,先写明结束条件:节点等于空返回空节点,节点为根节点直接返回节点.然后去遍历左树与右树,判断返回值的三种情况:</p>\n<ol><li>节点分布在左右树两侧,即返回值都不为空,那么公共祖先一定是根节点.</li><li>节点分布在右侧,即返回值为第一个遇到的节点,那么公共祖先为第一个遇到的节点.</li><li>节点分布在右侧同理.</li></ol>\n</blockquote>\n<p><img alt=\"\" height=\"500\" src=\"..\\..\\static\\image\\3d366dcfb34747c78b81d2ab9102f856.png\" width=\"693\"/></p>\n<pre><code class=\"language-java\">public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        if(root==null) return null;\n        if(root==p||root==q){\n            return root;\n        }\n        TreeNode leftT = lowestCommonAncestor(root.left,p,q);\n        TreeNode rightT = lowestCommonAncestor(root.right,p,q);\n        if(leftT!=null&amp;&amp;rightT!=null){\n            return root;\n        }else if(leftT!=null){\n            return leftT;\n        }else{\n            return rightT;\n        }\n    }</code></pre>\n<blockquote>\n<p>假设这颗二叉树使用孩子双亲表示法:那么该问题就可以转化为<span style=\"color:#38d8f0;\">双向链表求焦点</span>,先让较长的链表走长度的差值步,两个链表长度相同时一边向前走一边判断值是否相同,值相同的节点即为公共祖先.但该题使用的是<strong>孩子表示法</strong>,无法得知上一个节点是谁,所以只能将节点的路径保存下来,而路径又是<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">有序</span></span>的,提到顺序我们想到<span style=\"background-color:#a2e043;\">栈和队列</span>,我们需要从后向前找公共节点,很明显需要用<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">栈</span></span>来保存,而一个栈只能保存一个节点的路径,所以我们需要<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">两个栈</span></span>.保存好如图所示的路径后,让栈内元素多的先pop(),直到两个栈元素个数<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">相同</span></span>,然后两个栈一边出元素一边比较元素,遇到相同的就是公共节点.现在最关键的问题就是如何在栈内保存指定的路径?我们可以构造一个储存路径的函数,<span style=\"background-color:#a2e043;\">比较目标节点node和根节点root的关系不断更新路径</span>.栈内路径保存完毕后,就是出栈操作相对简单,这里不过多赘述.</p>\n</blockquote>\n<p><img alt=\"\" height=\"500\" src=\"..\\..\\static\\image\\c709cbc33aaa4eb2a965213bbdcecfd9.png\" width=\"964\"/></p>\n<pre><code class=\"language-java\">public boolean getPath(TreeNode root,TreeNode node,Stack&lt;TreeNode&gt;stack){\n        if(root==null||node==null){\n            return false;\n        }\n        stack.push(root);\n        if(root==node){\n            return true;\n        }\n        boolean flg = getPath(root.left,node,stack);\n        if(flg==true){\n            return true;\n        }\n        flg = getPath(root.right,node,stack);\n        if(flg==true){\n            return true;\n        }\n        stack.pop();\n        return false;\n    }\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        if(root==null) return null;\n        Stack&lt;TreeNode&gt; stack1 = new Stack&lt;&gt;();\n        getPath(root,p,stack1);\n        Stack&lt;TreeNode&gt; stack2 = new Stack&lt;&gt;();\n        getPath(root,q,stack2);\n\n        int size1 = stack1.size();\n        int size2 = stack2.size();\n        if(size1&gt;size2){\n            int size = size1-size2;\n            while(size!=0){\n                stack1.pop();\n                size--;\n            }\n            while(!stack1.isEmpty()&amp;&amp;!stack2.isEmpty()){\n                if(stack1.peek()==stack2.peek()){\n                    return stack1.pop();\n                }else{\n                    stack1.pop();\n                    stack2.pop();\n                }\n            }\n        }else{\n            int size = size2-size1;\n            while(size!=0){\n                stack2.pop();\n                size--;\n            }\n            while(!stack1.isEmpty()&amp;&amp;!stack2.isEmpty()){\n                if(stack1.peek()==stack2.peek()){\n                    return stack2.pop();\n                }else{\n                    stack1.pop();\n                    stack2.pop();\n                }\n            }\n        }\n        return null;\n    }</code></pre>\n<hr/>\n<h3 id=\"13.%E4%BA%8C%E6%8F%92%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8\">13.二插搜索树转双向链表</h3>\n<p><img alt=\"\" height=\"500\" src=\"..\\..\\static\\image\\f3476a4d40be4635acf068c0455b9fe4.png\" width=\"695\"/></p>\n<blockquote>\n<p>该题为<strong>遍历思路</strong>,难点在于如何在<span style=\"background-color:#a2e043;\">中序遍历的过程中修改指向</span>,首先我们确定递归的结束条件为节点为空,当节点为<strong>null</strong>时说明我们此时找到了中序遍历的第一个节点(4),此时我们可以修改节点的指向让它的left指向null,再去遍历左树左树也为null,返回到节点(6),此时应该让(6)的左指向(4),再让(4)的右指向(6),但我们已经找不到(4)这个节点了,所以为了<span style=\"background-color:#a2e043;\">记录节点可以在函数外定义成员遍历prev记录node的值</span>,但在第一个节点时不需要这一步操作,因为prev初始值为null,prev.right会出现空指针异常.</p>\n</blockquote>\n<p><img alt=\"\" height=\"838\" src=\"..\\..\\static\\image\\21016f5f93e94fa490639138a76e9013.png\" width=\"1200\"/></p>\n<pre><code class=\"language-java\">TreeNode prev = null;\n    public void inOrder(TreeNode node){\n        if(node==null) return;\n        inOrder(node.left);\n        //打印\n        node.left = prev;\n        if(prev!=null){\n            prev.right = node;\n        }\n        prev = node;\n        inOrder(node.right);\n    }\n    public TreeNode Convert(TreeNode pRootOfTree) {\n        if(pRootOfTree==null) return null;\n        inOrder(pRootOfTree);\n        TreeNode head = pRootOfTree;\n        while(head.left!=null){\n            head = head.left;\n        }\n        return head;\n    }</code></pre>\n<hr/>\n<h3 id=\"14.%E4%BB%8E%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E5%88%B0%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91\">14.从前序遍历到中序遍历构造二叉树</h3>\n<p><img alt=\"\" height=\"500\" src=\"..\\..\\static\\image\\46f00322ffbd40ed86c4fb6a9d52d481.png\" width=\"396\"/></p>\n<blockquote>\n<p>该题为<strong>子问题思路</strong>,首先要明白的是前序遍历用来确定每一颗子树<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">根节点</span></span>,中序遍历用来确定二叉树的构造情况并创建二叉树, </p>\n</blockquote>\n<p><img alt=\"\" height=\"992\" src=\"..\\..\\static\\image\\737bcb61d20f4c408e16cf95fece97ef.png\" width=\"1200\"/></p>\n<p></p>\n<pre><code class=\"language-java\">int preIndex = 0;\n    public TreeNode creativePbyI(int[] preorder, int[] inorder,int beging,int end){\n        if(beging&gt;end){\n            return null;\n        }\n        TreeNode root = new TreeNode(preorder[preIndex]);\n        int rootIndex = findIndex(inorder,beging,end,preorder[preIndex]);\n        if(rootIndex==-1){\n            return null;\n        }\n        preIndex++;\n        root.left = creativePbyI(preorder,inorder,beging,rootIndex-1);\n        root.right = creativePbyI(preorder,inorder,rootIndex+1,end);\n        return root;\n    }\n    public int findIndex( int[] inorder,int beging,int end,int key){\n        for(int i = 0;i&lt;=end;i++){\n            if(inorder[i]==key){\n                return i;\n            }\n        }\n        return -1;\n    }\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\n        if(preorder==null||inorder==null){\n            return null;\n        }\n        return creativePbyI(preorder,inorder,0,preorder.length-1);\n    }</code></pre>\n<hr/>\n<h3 id=\"15.%E4%BB%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%88%B0%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91\">15.从中序遍历到后序遍历构造二叉树</h3>\n<p><img alt=\"\" height=\"500\" src=\"..\\..\\static\\image\\dd0f8fb51696419db439c192b0967824.png\" width=\"378\"/></p>\n<blockquote>\n<p>做法与上一题类似,更改函数名即可. </p>\n</blockquote>\n<pre><code class=\"language-java\">int postIndex = 0;\n    public TreeNode creativePbyI(int[] inorder, int[] postorder,int beging,int end){\n        if(beging&gt;end){\n            return null;\n        }\n        TreeNode root = new TreeNode(postorder[postIndex]);\n        int rootIndex = findIndex(inorder,beging,end,postorder[postIndex]);\n        if(rootIndex==-1){\n            return null;\n        }\n        postIndex--;\n        root.right = creativePbyI(inorder,postorder,rootIndex+1,end);\n        root.left = creativePbyI(inorder,postorder,beging,rootIndex-1);\n        return root;\n    }\n    public int findIndex( int[] inorder,int beging,int end,int key){\n        for(int i = 0;i&lt;=end;i++){\n            if(inorder[i]==key){\n                return i;\n            }\n        }\n        return -1;\n    }\n    \n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        if(postorder==null||inorder==null){\n            return null;\n        }\n        postIndex = postorder.length-1;\n        return creativePbyI(inorder,postorder,0,inorder.length-1);\n    }</code></pre>\n<hr/>\n<h3 id=\"16.%E6%A0%B9%E6%8D%AE%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2\">16.根据二叉树创建字符串</h3>\n<p><img alt=\"\" height=\"500\" src=\"..\\..\\static\\image\\d17855b798c44516977a0d27cdb4b4a3.png\" width=\"348\"/></p>\n<blockquote>\n<p>本题考察了对二叉树递归的<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">应用</span></span>与字符串拼接相关的知识,按题意我们分析出<span style=\"background-color:#a2e043;\">可能出现的所有情况</span>,由于是前序遍历,所以我们先从左树的情况来判断,先拼接一个元素当t.left!=null时加\"(\",并继续递归.当t.left=null&amp;&amp;t.right=null时直接retrun,回溯到上一步会再加一个\")\",当t.left=null&amp;&amp;t.right!=null加\"()\".如果左树遍历完我们再去遍历右树t,right!=null加\"(\",t.right=null时直接返回.</p>\n</blockquote>\n<p><img alt=\"\" height=\"500\" src=\"..\\..\\static\\image\\8f8e5e44cf524fb4b9d7afeb12491018.png\" width=\"844\"/></p>\n<pre><code class=\"language-java\">public void treeToString(TreeNode t,StringBuffer sb){\n        if(t==null){\n            return;\n        }\n        sb.append(t.val);\n        if(t.left!=null){\n            sb.append(\"(\");\n            treeToString(t.left,sb);\n            sb.append(\")\");\n        }else{\n            //t.left==null\n            if(t.right==null){\n                return;\n            }else{\n                sb.append(\"()\");\n            }\n        }\n        if(t.right!=null){\n            sb.append(\"(\");\n            treeToString(t.right,sb);\n            sb.append(\")\");\n        }else{\n            return;\n        }\n\n    }\n    public String tree2str(TreeNode root) {\n        if(root==null) return null;\n        StringBuffer sb = new StringBuffer();\n        treeToString(root,sb);\n        return sb.toString();\n    }</code></pre>\n<hr/>\n<h3 id=\"17.%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E9%9D%9E%E9%80%92%E5%BD%92%E5%86%99%E6%B3%95\">17.前序遍历非递归写法</h3>\n<blockquote>\n<p>牵扯到顺序就考虑栈和队列,前序遍历遍历完左树后需要回溯到右树继续遍历,所以必须保存它的路径,方便后续<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">回溯</span></span>,那么用<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">栈</span></span>最为合适.</p>\n</blockquote>\n<pre><code class=\"language-java\">public static void preOrderTraveralWithStack(TreeNode root){//非递归前序遍历\n        Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;();\n        TreeNode node = root;\n        while (node!=null||!stack.isEmpty()){\n            while (node!=null){\n                System.out.println(node.data);\n                stack.push(node);\n                node = node.leftChild;\n            }\n            if(!stack.isEmpty()){\n                node = stack.pop();\n                node = node.rightChild;\n            }\n        }\n    }</code></pre>\n<hr/>\n<h3 id=\"18.%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E9%9D%9E%E9%80%92%E5%BD%92%E5%86%99%E6%B3%95\">18.中序遍历非递归写法</h3>\n<blockquote>\n<p>与前序遍历写法一致,不过更改打印元素位置,当中序遍历元素被弹出时打印.</p>\n</blockquote>\n<pre><code class=\"language-java\"> public List&lt;Integer&gt;inorderTraversal(TreeNode root) {\n        List&lt;Integer&gt; ret = new ArrayList&lt;&gt;();\n        if(root==null) return ret;\n        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();\n        TreeNode cur = root;\n        while(cur!=null||!stack.isEmpty()){\n            while(cur!=null){\n            stack.push(cur);\n            cur = cur.left;\n        }\n        if(!stack.isEmpty()){\n            TreeNode top = stack.pop();\n            ret.add(top.val);\n            cur = top.right;\n        }\n    }\n    return ret;\n  }</code></pre>\n<hr/>\n<h3 id=\"19.%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E9%9D%9E%E9%80%92%E5%BD%92%E5%86%99%E6%B3%95\">19.后序遍历非递归写法</h3>\n<blockquote>\n<p>与中序遍历不同的是,后续遍历到<span style=\"background-color:#a2e043;\">cur.left=null时必须确保cur.right=null</span>才能弹出cur.所以只能<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">peek(）</span></span>栈顶的元素看它的右树是否存在,不存在就弹出,存在还需遍历右树.但此时会出现一个为问题,右树的遍历会陷入死循环.所以需要对右树的遍历加限制条件,如果右树已经遍历或者右树为空,可以直接弹出.因此当右树遍历后就用prev来记录top节点,如果<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">prev=top</span></span>说明已经遍历过,直接弹出即可.</p>\n</blockquote>\n<pre><code class=\"language-java\">public List&lt;Integer&gt; postorderTraversal(TreeNode root) {\n        List&lt;Integer&gt; ret = new ArrayList&lt;&gt;();\n        if(root==null) return ret;\n        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();\n        TreeNode cur = root;\n        TreeNode prev = null;\n        while(cur!=null||!stack.isEmpty()){\n            while(cur!=null){\n            stack.push(cur);\n            cur = cur.left;\n        }\n        TreeNode top = stack.peek();\n        if(top.right==null||top.right==prev){\n            stack.pop();\n            ret.add(top.val);\n            prev = top;//记录最近一次遍历二叉树\n        }else{\n            cur = top.right;\n        }\n    }\n    return ret;\n   }</code></pre>\n<hr/>\n<h1 id=\"%E6%80%BB%E7%BB%93%3E\">总结&gt;</h1>\n<blockquote>\n<p>        以上就是快速入门二叉树的全部内容,从最基础知识到手撕面试题,认真看完的同学可能会发现,二叉树的知识点非常综合,稍有难度的题不仅涉及到之前数据结构的知识,还会牵连到一些二叉树的子问题.码字不易耗时半月,如果对你的学习有所启发,麻烦不要忘记<span style=\"color:#fe2c24;\"><span style=\"background-color:#fef2f0;\">三连</span></span>哦!</p>\n</blockquote>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"..\\..\\static\\image\\79a615f6390b4c358ee4402f94b819ae.jpeg\"/></p>\n<p></p>\n</div>\n</div>", "first_tag": "Java", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2022-08-30 22:37:08", "summary": "专栏简介语法及数据结构题目来源牛客剑指创作目标从语法角度实现底层相关数据结构达到手撕各类题目的水平希望在提升自己的同时帮助他人与大家一起共同进步互相成长学历代表过去能力代表现在学习能力代表未来目录前言"}