{"blogid": "126349616", "writerAge": "码龄144天", "writerBlogNum": "46", "writerCollect": "439", "writerComment": "943", "writerFan": "1756", "writerGrade": "5级", "writerIntegral": "2290", "writerName": "兔7", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126349616.jpg", "writerRankTotal": "8995", "writerRankWeekly": "1616", "writerThumb": "657", "writerVisitNum": "13970", "blog_read_count": "112", "blog_time": "于 2022-09-07 08:34:42 发布", "blog_title": "网络编程套接字-----实现网络间通信", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p style=\"text-align:center;\"><strong><img alt=\"\" height=\"90\" src=\"https://img-blog.csdnimg.cn/b6f20f614157431ba83ad9378ab10a32.gif\" width=\"714\"/></strong></p>\n<p><strong><img alt=\"\" height=\"747\" src=\"..\\..\\static\\image\\af03afb19d1a401cb431bb52b1b046d1.png\" width=\"1200\"/></strong></p>\n<blockquote>\n<p><strong>꧁ 大家好，我是 <span style=\"color:#ff9900;\">兔7</span> ，一位努力学习C++的博主~ ꧂</strong></p>\n<p><strong>☙ 如果文章知识点有错误的地方，请指正！和大家一起学习，一起进步❧</strong></p>\n<p><strong>🚀 如有不懂，可以随时向我提问，我会全力讲解~💬</strong></p>\n<p><strong>🔥 如果感觉博主的文章还不错的话，<u>希望大家关注、点赞、收藏三连支持一下博主哦</u>~！👀</strong></p>\n<p><strong>🔥 你们的支持是我创作的动力！⛅</strong></p>\n<p id=\"2.2%E5%9B%BE%E8%A7%A3\"><strong>🧸<span style=\"color:#fe2c24;\"> 我相信现在的努力的艰辛，都是为以后的美好最好的见证！⭐</span></strong></p>\n<p><strong><span style=\"color:#fe2c24;\">🧸 人的心态决定姿态！⭐</span></strong></p>\n<p><strong>🚀 本文章CSDN首发！✍</strong></p>\n</blockquote>\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"0.%20%E5%89%8D%E8%A8%80-toc\" style=\"margin-left:0px;\"><strong><a href=\"#0.%20%E5%89%8D%E8%A8%80\">0. 前言</a></strong></p>\n<p id=\"1.%20%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-toc\" style=\"margin-left:0px;\"><strong><a href=\"#1.%20%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86\">1. 预备知识</a></strong></p>\n<p id=\"1.%201%20%E7%90%86%E8%A7%A3%E6%BA%90IP%E5%9C%B0%E5%9D%80%E5%92%8C%E7%9B%AE%E7%9A%84IP%E5%9C%B0%E5%9D%80-toc\" style=\"margin-left:40px;\"><strong><a href=\"#1.%201%20%E7%90%86%E8%A7%A3%E6%BA%90IP%E5%9C%B0%E5%9D%80%E5%92%8C%E7%9B%AE%E7%9A%84IP%E5%9C%B0%E5%9D%80\">1. 1 理解源IP地址和目的IP地址</a></strong></p>\n<p id=\"1.2%20%E8%AE%A4%E8%AF%86%E7%AB%AF%E5%8F%A3%E5%8F%B7-toc\" style=\"margin-left:40px;\"><strong><a href=\"#1.2%20%E8%AE%A4%E8%AF%86%E7%AB%AF%E5%8F%A3%E5%8F%B7\">1.2 认识端口号</a></strong></p>\n<p id=\"1.3%C2%A0%E7%90%86%E8%A7%A3%20%22%E7%AB%AF%E5%8F%A3%E5%8F%B7%22%20%E5%92%8C%20%22%E8%BF%9B%E7%A8%8BID%22-toc\" style=\"margin-left:40px;\"><strong><a href=\"#1.3%C2%A0%E7%90%86%E8%A7%A3%20%22%E7%AB%AF%E5%8F%A3%E5%8F%B7%22%20%E5%92%8C%20%22%E8%BF%9B%E7%A8%8BID%22\">1.3 理解 \"端口号\" 和 \"进程ID\"</a></strong></p>\n<p id=\"1.4%20%E7%90%86%E8%A7%A3%E6%BA%90%E7%AB%AF%E5%8F%A3%E5%8F%B7%E5%92%8C%E7%9B%AE%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%8F%B7-toc\" style=\"margin-left:40px;\"><strong><a href=\"#1.4%20%E7%90%86%E8%A7%A3%E6%BA%90%E7%AB%AF%E5%8F%A3%E5%8F%B7%E5%92%8C%E7%9B%AE%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%8F%B7\">1.4 理解源端口号和目的端口号</a></strong></p>\n<p id=\"articleContentId-toc\" style=\"margin-left:40px;\"><strong><a href=\"#articleContentId\">1.5 IP地址、MAC地址、端口号的区别？</a></strong></p>\n<p id=\"1.6%C2%A0%E8%AE%A4%E8%AF%86TCP%E5%8D%8F%E8%AE%AE-toc\" style=\"margin-left:40px;\"><strong><a href=\"#1.6%C2%A0%E8%AE%A4%E8%AF%86TCP%E5%8D%8F%E8%AE%AE\">1.6 认识TCP协议</a></strong></p>\n<p id=\"1.7%20%E8%AE%A4%E8%AF%86UDP%E5%8D%8F%E8%AE%AE-toc\" style=\"margin-left:40px;\"><strong><a href=\"#1.7%20%E8%AE%A4%E8%AF%86UDP%E5%8D%8F%E8%AE%AE\">1.7 认识UDP协议</a></strong></p>\n<p id=\"1.8%C2%A0%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F-toc\" style=\"margin-left:40px;\"><strong><a href=\"#1.8%C2%A0%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F\">1.8 网络字节序</a></strong></p>\n<p id=\"2.%20socket%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3-toc\" style=\"margin-left:0px;\"><strong><a href=\"#2.%20socket%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3\">2. socket编程接口</a></strong></p>\n<p id=\"2.1%20socket%20%E5%B8%B8%E8%A7%81API-toc\" style=\"margin-left:40px;\"><strong><a href=\"#2.1%20socket%20%E5%B8%B8%E8%A7%81API\">2.1 socket 常见API</a></strong></p>\n<p id=\"2.2%C2%A0sockaddr%E7%BB%93%E6%9E%84-toc\" style=\"margin-left:40px;\"><strong><a href=\"#2.2%C2%A0sockaddr%E7%BB%93%E6%9E%84\">2.2 sockaddr结构</a></strong></p>\n<p id=\"sockaddr%20%E7%BB%93%E6%9E%84-toc\" style=\"margin-left:80px;\"><strong><a href=\"#sockaddr%20%E7%BB%93%E6%9E%84\">sockaddr 结构</a></strong></p>\n<p id=\"%C2%A0sockaddr_in%20%E7%BB%93%E6%9E%84-toc\" style=\"margin-left:80px;\"><strong><a href=\"#%C2%A0sockaddr_in%20%E7%BB%93%E6%9E%84\"> sockaddr_in 结构</a></strong></p>\n<p id=\"in_addr%E7%BB%93%E6%9E%84-toc\" style=\"margin-left:80px;\"><strong><a href=\"#in_addr%E7%BB%93%E6%9E%84\">in_addr结构</a></strong></p>\n<p id=\"3.%20%E7%AE%80%E5%8D%95%E7%9A%84UDP%E7%BD%91%E7%BB%9C%E7%A8%8B%E5%BA%8F-toc\" style=\"margin-left:0px;\"><strong><a href=\"#3.%20%E7%AE%80%E5%8D%95%E7%9A%84UDP%E7%BD%91%E7%BB%9C%E7%A8%8B%E5%BA%8F\">3. 简单的UDP网络程序</a></strong></p>\n<p id=\"3.1%20%E6%8E%A5%E5%8F%A3-toc\" style=\"margin-left:40px;\"><strong><a href=\"#3.1%20%E6%8E%A5%E5%8F%A3\">3.1 接口</a></strong></p>\n<p id=\"3.1.1%20%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E6%8E%A5%E5%8F%A3-toc\" style=\"margin-left:80px;\"><strong><a href=\"#3.1.1%20%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E6%8E%A5%E5%8F%A3\">3.1.1 初始化的接口</a></strong></p>\n<p id=\"3.1.2%20%E8%BF%90%E8%A1%8C%E8%B5%B7%E6%9D%A5%E9%9C%80%E8%A6%81%E7%9A%84%E6%8E%A5%E5%8F%A3-toc\" style=\"margin-left:80px;\"><strong><a href=\"#3.1.2%20%E8%BF%90%E8%A1%8C%E8%B5%B7%E6%9D%A5%E9%9C%80%E8%A6%81%E7%9A%84%E6%8E%A5%E5%8F%A3\">3.1.2 运行起来需要的接口</a></strong></p>\n<p id=\"3.2%20%E5%AE%9E%E7%8E%B0%20UDP-toc\" style=\"margin-left:40px;\"><strong><a href=\"#3.2%20%E5%AE%9E%E7%8E%B0%20UDP\">3.2 实现 UDP</a></strong></p>\n<p id=\"udp_server.hpp-toc\" style=\"margin-left:80px;\"><strong><a href=\"#udp_server.hpp\">udp_server.hpp</a></strong></p>\n<p id=\"udp_server.cc-toc\" style=\"margin-left:80px;\"><strong><a href=\"#udp_server.cc\">udp_server.cc</a></strong></p>\n<p id=\"udp_client.hpp-toc\" style=\"margin-left:80px;\"><strong><a href=\"#udp_client.hpp\">udp_client.hpp</a></strong></p>\n<p id=\"udp_client.cc-toc\" style=\"margin-left:80px;\"><strong><a href=\"#udp_client.cc\">udp_client.cc</a></strong></p>\n<p id=\"3.3%20UDP%E6%80%BB%E4%BB%A3%E7%A0%81-toc\" style=\"margin-left:40px;\"><strong><a href=\"#3.3%20UDP%E6%80%BB%E4%BB%A3%E7%A0%81\">3.3 UDP总代码</a></strong></p>\n<p id=\"udp_server.hpp-toc\" style=\"margin-left:80px;\"><strong><a href=\"#udp_server.hpp\">udp_server.hpp</a></strong></p>\n<p id=\"udp_server.cc-toc\" style=\"margin-left:80px;\"><strong><a href=\"#udp_server.cc\">udp_server.cc</a></strong></p>\n<p id=\"udp_client.hpp-toc\" style=\"margin-left:80px;\"><strong><a href=\"#udp_client.hpp\">udp_client.hpp</a></strong></p>\n<p id=\"udp_client.cc-toc\" style=\"margin-left:80px;\"><strong><a href=\"#udp_client.cc\">udp_client.cc</a></strong></p>\n<p id=\"4.%20%E5%A4%9A%E6%96%B9%E6%B3%95TCP%E9%80%9A%E4%BF%A1-toc\" style=\"margin-left:0px;\"><strong><a href=\"#4.%20%E5%A4%9A%E6%96%B9%E6%B3%95TCP%E9%80%9A%E4%BF%A1\">4. 多方法TCP通信</a></strong></p>\n<p id=\"4.1%20%E6%8E%A5%E5%8F%A3-toc\" style=\"margin-left:40px;\"><strong><a href=\"#4.1%20%E6%8E%A5%E5%8F%A3\">4.1 接口</a></strong></p>\n<p id=\"4.2%20TCP%20%E5%8D%95%E6%89%A7%E8%A1%8C%E6%B5%81-toc\" style=\"margin-left:40px;\"><strong><a href=\"#4.2%20TCP%20%E5%8D%95%E6%89%A7%E8%A1%8C%E6%B5%81\">4.2 TCP 单执行流</a></strong></p>\n<p id=\"tcp_server.hpp-toc\" style=\"margin-left:80px;\"><strong><a href=\"#tcp_server.hpp\">tcp_server.hpp</a></strong></p>\n<p id=\"tcp_server.cc-toc\" style=\"margin-left:80px;\"><strong><a href=\"#tcp_server.cc\">tcp_server.cc</a></strong></p>\n<p id=\"tcp_client.hpp-toc\" style=\"margin-left:80px;\"><strong><a href=\"#tcp_client.hpp\">tcp_client.hpp</a></strong></p>\n<p id=\"tcp_client.cc-toc\" style=\"margin-left:80px;\"><strong><a href=\"#tcp_client.cc\">tcp_client.cc</a></strong></p>\n<p id=\"4.3%20TCP%20%E5%A4%9A%E8%BF%9B%E7%A8%8B-toc\" style=\"margin-left:40px;\"><strong><a href=\"#4.3%20TCP%20%E5%A4%9A%E8%BF%9B%E7%A8%8B\">4.3 TCP 多进程</a></strong></p>\n<p id=\"tcp_server.hpp-toc\" style=\"margin-left:80px;\"><strong><a href=\"#tcp_server.hpp\">tcp_server.hpp</a></strong></p>\n<p id=\"tcp_server.cc-toc\" style=\"margin-left:80px;\"><strong><a href=\"#tcp_server.cc\">tcp_server.cc</a></strong></p>\n<p id=\"tcp_client.hpp-toc\" style=\"margin-left:80px;\"><strong><a href=\"#tcp_client.hpp\">tcp_client.hpp</a></strong></p>\n<p id=\"tcp_client.cc-toc\" style=\"margin-left:80px;\"><strong><a href=\"#tcp_client.cc\">tcp_client.cc</a></strong></p>\n<p id=\"4.4%C2%A0TCP%20%E5%A4%9A%E7%BA%BF%E7%A8%8B-toc\" style=\"margin-left:40px;\"><strong><a href=\"#4.4%C2%A0TCP%20%E5%A4%9A%E7%BA%BF%E7%A8%8B\">4.4 TCP 多线程</a></strong></p>\n<p id=\"tcp_server.hpp-toc\" style=\"margin-left:80px;\"><strong><a href=\"#tcp_server.hpp\">tcp_server.hpp</a></strong></p>\n<p id=\"tcp_server.cc-toc\" style=\"margin-left:80px;\"><strong><a href=\"#tcp_server.cc\">tcp_server.cc</a></strong></p>\n<p id=\"tcp_client.hpp-toc\" style=\"margin-left:80px;\"><strong><a href=\"#tcp_client.hpp\">tcp_client.hpp</a></strong></p>\n<p id=\"%C2%A0tcp_client.cc-toc\" style=\"margin-left:80px;\"><strong><a href=\"#%C2%A0tcp_client.cc\"> tcp_client.cc</a></strong></p>\n<p id=\"4.5%C2%A0TCP%20%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%89%88%E6%9C%AC)-toc\" style=\"margin-left:40px;\"><strong><a href=\"#4.5%C2%A0TCP%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%28%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%89%88%E6%9C%AC%29\">4.5 TCP 多线程(线程池版本)</a></strong></p>\n<p id=\"ThreadPool.hpp-toc\" style=\"margin-left:80px;\"><strong><a href=\"#ThreadPool.hpp\">ThreadPool.hpp</a></strong></p>\n<p id=\"Task.hpp-toc\" style=\"margin-left:80px;\"><strong><a href=\"#Task.hpp\">Task.hpp</a></strong></p>\n<p id=\"tcp_server.hpp-toc\" style=\"margin-left:80px;\"><strong><a href=\"#tcp_server.hpp\">tcp_server.hpp</a></strong></p>\n<p id=\"tcp_server.cc-toc\" style=\"margin-left:80px;\"><strong><a href=\"#tcp_server.cc\">tcp_server.cc</a></strong></p>\n<p id=\"tcp_client.hpp-toc\" style=\"margin-left:80px;\"><strong><a href=\"#tcp_client.hpp\">tcp_client.hpp</a></strong></p>\n<p id=\"%C2%A0tcp_client.cc-toc\" style=\"margin-left:80px;\"><strong><a href=\"#%C2%A0tcp_client.cc\"> tcp_client.cc</a></strong></p>\n<p id=\"5.%20%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9-toc\" style=\"margin-left:0px;\"><strong><a href=\"#5.%20%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9\">5. 零碎知识点</a></strong></p>\n<p id=\"5.1%C2%A0%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:40px;\"><strong><a href=\"#5.1%C2%A0%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0\">5.1 地址转换函数</a></strong></p>\n<p id=\"5.2%C2%A0%E5%85%B3%E4%BA%8Einet_ntoa-toc\" style=\"margin-left:40px;\"><strong><a href=\"#5.2%C2%A0%E5%85%B3%E4%BA%8Einet_ntoa\">5.2 关于inet_ntoa</a></strong></p>\n<hr id=\"hr-toc\"/>\n<h1><strong><span style=\"color:#ff9900;\">0. 前言</span></strong></h1>\n<p><strong>        此博客为博主以后复习的资料，所以大家放心学习，总结的很全面，每段代码都给大家发了出来，大家如果有疑问可以尝试去调试。</strong></p>\n<p><strong>        <span style=\"color:#79c6cd;\">大家一定要认真看图，图里的文字都是精华，好多的细节都在图中展示、写出来了，所以大家一定要仔细哦~</span></strong></p>\n<p><strong>        感谢大家对我的支持，感谢大家的喜欢， <span style=\"color:#ff9900;\">兔7</span> 祝大家在学习的路上一路顺利，生活的路上顺心顺意~！</strong></p>\n<h1 id=\"1.%20%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86\"><strong><span style=\"color:#faa572;\">1. 预备知识</span></strong></h1>\n<h2 id=\"1.%201%20%E7%90%86%E8%A7%A3%E6%BA%90IP%E5%9C%B0%E5%9D%80%E5%92%8C%E7%9B%AE%E7%9A%84IP%E5%9C%B0%E5%9D%80\"><strong><span style=\"color:#9c8ec1;\">1. 1 理解源IP地址和目的IP地址</span></strong></h2>\n<p><strong>        在IP数据包头部中，有两个IP地址，分别叫做源IP地址，和目的IP地址。</strong></p>\n<p><strong>        就像唐僧经常说：贫僧从东土大唐而来，到西天求取真经。</strong></p>\n<p><strong>        其中\"东土大唐\"和\"西天\"就是源IP地址和目的IP地址。所以源IP地址和目的IP地址基本是不变的。</strong></p>\n<p><strong>        比方说上一次经过了女儿国，再往黑风岭走，唐僧可能就会说，我上一站是女儿国，我现在在往黑风岭走。</strong></p>\n<p><strong>        其中的地址就是源MAC地址和目的MAC地址，它在唐僧一路上都是会发生变化的，在计算机中之所以MAC地址会变化是因为在传输中会经过路由，从而进行解包和封包。</strong></p>\n<h2 id=\"1.2%20%E8%AE%A4%E8%AF%86%E7%AB%AF%E5%8F%A3%E5%8F%B7\"><strong><span style=\"color:#9c8ec1;\">1.2 认识端口号</span></strong></h2>\n<p><strong>        端口号(port)是传输层协议的内容。</strong></p>\n<blockquote>\n<ul><li><strong>端口号是一个2字节16位的整数。</strong></li><li><strong>端口号用来标识一个进程，告诉操作系统，当前的这个数据要交给哪一个进程来处理。</strong></li><li><strong>IP地址 + 端口号能够标识网络上的某一台主机的某一个进程。</strong></li><li><strong>一个端口号只能被一个进程占用。</strong></li></ul>\n</blockquote>\n<p><strong>        唐僧到西天不是为了去西天而去西天，而是为了到西天拿到经书，所以西天是唐僧必须到的地方。</strong></p>\n<p><strong>        所以我们把数据从一台主机送到另一台主机没有意义，最终我们是想请求到对应的数据。所以我们的请求不只是要发送到对方的机器上，而是为了访问到这个机器上一个特定的服务。</strong></p>\n<p><strong><img alt=\"\" height=\"360\" src=\"..\\..\\static\\image\\3bc0b952d59242b7829cd3160db0ab3a.png\" width=\"795\"/></strong></p>\n<p><strong>       <span style=\"color:#79c6cd;\"> 所以 socket 通信，本质上是进程间通信，而且可以是跨网络的进程间通信。</span></strong></p>\n<p><strong>        那么：</strong></p>\n<p><strong><img alt=\"\" height=\"385\" src=\"..\\..\\static\\image\\56c1f1d558044254adbe4ae546acd2a2.png\" width=\"738\"/></strong></p>\n<ul><li><strong><span style=\"color:#1c7331;\">当数据来到对端的网络层，它怎么知道要访问服务端的哪个服务呢？</span>(当然像前面搜索引擎这么重要的服务，一台主机上就只有一个服务)</strong></li><li><strong><span style=\"color:#1c7331;\">传递回来的时候又是要传给哪个服务呢？</span></strong></li></ul>\n<p><strong>        所以这里就用到了端口号。</strong></p>\n<p><strong>        任何的网络服务与网络客户端，如果要进行正常的数据通信，必须要用端口号来唯一标识。在同一个OS内，一个进程可以与一个端口号进行绑定，该端口号就在网络层面唯一表示一台主机上的唯一一个进程。</strong></p>\n<blockquote>\n<ul><li><strong>公网IP：唯一的标识全网内唯一的一台主机。</strong></li><li><strong>port：表示一台主机上的唯一一个进程。</strong></li></ul>\n</blockquote>\n<p><strong>        所以 IP+port 就是标识全网内唯一的一个进程。</strong></p>\n<p><strong>        所以两端都有对应的 IP+port ，那么也就是唯二的两个进程之间进行通信。</strong></p>\n<p><strong>        所以我们就将 IP+port 这种标识进程间通信的方式就叫做 socket通信。</strong></p>\n<h2 id=\"1.3%C2%A0%E7%90%86%E8%A7%A3%20%22%E7%AB%AF%E5%8F%A3%E5%8F%B7%22%20%E5%92%8C%20%22%E8%BF%9B%E7%A8%8BID%22\"><strong><span style=\"color:#9c8ec1;\">1.3 理解 \"端口号\" 和 \"进程ID\"</span></strong></h2>\n<p><strong>        我在前面写的系统编程的时候，我们学习了 pid 表示唯一一个进程。此处我们的端口号也是唯一表示一个进程。</strong></p>\n<p><strong><span style=\"color:#1c7331;\">那么这两者之间是怎样的关系？</span></strong></p>\n<p><strong>        首先，一台机器上可能存在大量的进程，但不是所有的进程都要对外进行网络数据请求。</strong></p>\n<p><strong>        所以其实存在大量的进程是系统的概念，而进程进行网络数据请求是网络级的概念。</strong></p>\n<p><strong>例如：</strong></p>\n<p><strong>        在学校中有自己的学号，在社会上有自己的身份证号，在公司又有自己的工号，都可以通过这些来标识自己，它们之间互不冲突，不同的地方用不同的号，是为了方便管理或者识别。</strong></p>\n<p><strong>        所以这里的端口号和进程ID也是如此，这也是为什么网络中单独出现个 port 的原因，因为 port 更适合。</strong></p>\n<p><strong><span style=\"color:#1c7331;\">IP地址和端口号它们之间的关系？</span></strong></p>\n<p><strong>例如：</strong></p>\n<p><strong>        手机欠费了，手机只能打 10086，这时是一个人工客服接的电话提供服务。</strong></p>\n<p><strong>        那么这里的 10086 就相当于IP地址，而为我们提供人工客服的那个员工的工号就相当于端口号。</strong></p>\n<h2 id=\"1.4%20%E7%90%86%E8%A7%A3%E6%BA%90%E7%AB%AF%E5%8F%A3%E5%8F%B7%E5%92%8C%E7%9B%AE%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%8F%B7\"><strong><span style=\"color:#9c8ec1;\">1.4 理解源端口号和目的端口号</span></strong></h2>\n<p><strong>        传输层协议(TCP和UDP)的数据段中有两个端口号，分别叫做源端口号和目的端口号。就是在描述 \"数据是谁发的，要发给谁\"。</strong></p>\n<p><strong>        所以这时唐僧应该说的是：贫僧奉唐皇帝之令从东土大唐而来，到西天求取真经。</strong></p>\n<h2 id=\"articleContentId\"><strong><span style=\"color:#9c8ec1;\">1.5 IP地址、MAC地址、端口号的区别？</span></strong></h2>\n<blockquote>\n<ul><li><strong>mac地址是在数据链路层包裹在以太网头部中的，它主要用来识别同一个链路中的不同计算机。Mac地址即网卡号，每块网卡出厂的时候，都有一个全世界独一无二的 MAC 地址，长度是 48 个二进制位，通常用 12 个十六进制数表示。</strong></li><li><strong>IP地址是在网络层的IP头部里，用于识别网络中互联的主机和路由器，其实主要是确认子网，通过子网掩码确认某个IP地址所在的子网，而后再在子网内部确认mac地址就能找到准确的用户了。</strong></li><li><strong>端口号是在运输层包含在TCP/UDP头部中的，用于识别应用程序。一台主机上能运行多个程序，那么接收到的消息到底是哪个程序发送的，就需要端口号来确认。</strong></li></ul>\n</blockquote>\n<h2 id=\"1.6%C2%A0%E8%AE%A4%E8%AF%86TCP%E5%8D%8F%E8%AE%AE\"><strong><span style=\"color:#9c8ec1;\">1.6 认识TCP协议</span></strong></h2>\n<p><strong>        此处我们先对TCP(Transmission Control Protocol 传输控制协议)有一个直观的认识。后面我们再详细讨论TCP的一些细节问题。</strong></p>\n<blockquote>\n<ul><li><strong>传输层协议</strong></li><li><strong>有连接</strong></li><li><strong>可靠传输</strong></li><li><strong>面向字节流</strong></li></ul>\n</blockquote>\n<h2 id=\"1.7%20%E8%AE%A4%E8%AF%86UDP%E5%8D%8F%E8%AE%AE\"><strong><span style=\"color:#9c8ec1;\">1.7 认识UDP协议</span></strong></h2>\n<p><strong>        此处我们也是对UDP(User Datagram Protocol 用户数据报协议)有一个直观的认识。后面再详细讨论。</strong></p>\n<blockquote>\n<ul><li><strong>传输层协议</strong></li><li><strong>无连接</strong></li><li><strong>不可靠传输</strong></li><li><strong>面向数据报</strong></li></ul>\n</blockquote>\n<h2 id=\"1.8%C2%A0%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F\"><strong><span style=\"color:#9c8ec1;\">1.8 网络字节序</span></strong></h2>\n<p><strong>        我们已经知道，内存中的多字节数据相对于内存地址有大端和小端之分，磁盘文件中的多字节数据相对于文件中的偏移地址也有大端小端之分，网络数据流同样有大端小端之分。那么如何定义网络数据流的地址呢？</strong></p>\n<blockquote>\n<ul><li><strong>发送主机通常将发送缓冲区中的数据按内存地址<span style=\"color:#79c6cd;\">从低到高的顺序发出</span>。</strong></li><li><strong>接收主机把从网络上接到的字节依次保存在接收缓冲区中，也是按内存地址<span style=\"color:#79c6cd;\">从低到高的顺序保存</span>。</strong></li><li><strong>因此，网络数据流的地址应这样规定：先发出的数据是低地址，后发出的数据是高地址。</strong></li><li><strong>TCP/IP协议规定，网络数据流应采用大端字节序，即低地址高字节。</strong></li><li><strong>不管这台主机是大端机还是小端机，都会按照这个TCP/IP规定的网络字节序来发送/接收数据。</strong></li><li><strong>如果当前发送主机是小端，就需要先将数据转成大端。否则就忽略，直接发送即可。</strong></li></ul>\n</blockquote>\n<p><strong><img alt=\"\" height=\"499\" src=\"..\\..\\static\\image\\73d4d6f59f0f48aea0c6d7e3c808d0ce.png\" width=\"1200\"/></strong></p>\n<p><strong>        如果不注意大小端的问题，那么可能写和读的时候都会读反。所以网络必须解决大小端的问题。</strong></p>\n<p><strong><span style=\"color:#1c7331;\">那么如何解决呢？</span></strong></p>\n<p><strong>        规定网络序列：网路上的数据必须都是大端。</strong></p>\n<p><strong>        例如从 client 到网络要以大端的方式传输，从网络到 server ，如果 server 是大端机器就之间向上解释，如果是小端就反过来向上解释就可以了。</strong></p>\n<hr/>\n<p><strong>        为使网络程序具有可移植性,使同样的C代码在大端和小端计算机上编译后都能正常运行,可以调用以下库函数做网络 字节序和主机字节序的转换。</strong></p>\n<p><strong><img alt=\"\" height=\"210\" src=\"..\\..\\static\\image\\422ced757a8545498302d0cb98086e60.png\" width=\"1184\"/></strong></p>\n<blockquote>\n<ul><li><strong>这些函数名很好记，h 表示 host，n 表示network，l 表示 32 位长整数，s 表示 16 位短整数。</strong></li><li><strong>例如 htonl 表示将 32 位的长整数从主机字节序转换为网络字节序，例如将IP地址转换后准备发送。</strong></li><li><strong>如果主机是小端字节序，这些函数将参数做相应的大小端转换然后返回。</strong></li><li><strong>如果主机是大端字节序，这些函数不做转换，将参数原封不动地返回。</strong></li></ul>\n</blockquote>\n<h1 id=\"2.%20socket%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3\"><strong><span style=\"color:#faa572;\">2. socket编程接口</span></strong></h1>\n<h2 id=\"2.1%20socket%20%E5%B8%B8%E8%A7%81API\"><strong><span style=\"color:#9c8ec1;\">2.1 socket 常见API</span></strong></h2>\n<pre><code class=\"language-cpp\">// 创建 socket 文件描述符 (TCP/UDP, 客户端 + 服务器)\nint socket(int domain, int type, int protocol);\n// 绑定端口号 (TCP/UDP, 服务器)\nint bind(int socket, const struct sockaddr *address,\n socklen_t address_len);\n// 开始监听socket (TCP, 服务器)\nint listen(int socket, int backlog);\n// 接收请求 (TCP, 服务器)\nint accept(int socket, struct sockaddr* address,\n socklen_t* address_len);\n// 建立连接 (TCP, 客户端)\nint connect(int sockfd, const struct sockaddr *addr,\n socklen_t addrlen);</code></pre>\n<h2 id=\"2.2%C2%A0sockaddr%E7%BB%93%E6%9E%84\"><strong><span style=\"color:#9c8ec1;\">2.2 sockaddr结构</span></strong></h2>\n<p><strong>        socket API 是一层抽象的网络编程接口，适用于各种底层网络协议，如IPv4、IPv6，以及后面要讲的UNIX Domain Socket。然而，各种网络协议的地址格式并不相同。</strong></p>\n<p><strong><img alt=\"\" height=\"814\" src=\"..\\..\\static\\image\\1680c720afbe41d58dea8f3df5b2b1e7.png\" width=\"749\"/></strong></p>\n<blockquote>\n<ul><li><strong>IPv4 和 IPv6 的地址格式定义在netinet/in.h中，IPv4 地址用 sockaddr_in 结构体表示，包括16位地址类型，16 位端口号和 32 位 IP 地址。</strong></li><li><strong>IPv4、IPv6地址类型分别定义为常数 AF_INET、AF_INET6。这样，只要取得某种 sockaddr 结构体的首地址，不需要知道具体是哪种类型的 sockaddr 结构体，就可以根据地址类型字段确定结构体中的内容。</strong></li><li><strong>socket API可以都用struct sockaddr *类型表示, 在使用的时候需要强制转化成sockaddr_in。这样的好处是程序的通用性，可以接收IPv4， IPv6，以及UNIX Domain Socket 各种类型的sockaddr 结构体指针做为参数。</strong></li></ul>\n</blockquote>\n<h3 id=\"sockaddr%20%E7%BB%93%E6%9E%84\"><strong><span style=\"color:#ad720d;\">sockaddr 结构</span></strong></h3>\n<p><strong><img alt=\"\" height=\"124\" src=\"..\\..\\static\\image\\93738d280eea4535a826e9b2341fabc4.png\" width=\"883\"/></strong></p>\n<h3 id=\"%C2%A0sockaddr_in%20%E7%BB%93%E6%9E%84\"><strong><span style=\"color:#ad720d;\"> sockaddr_in 结构</span></strong></h3>\n<p><strong><img alt=\"\" height=\"315\" src=\"..\\..\\static\\image\\8960d98be0984456b09fd335a7b5faa2.png\" width=\"694\"/></strong></p>\n<p><strong>         虽然 socket api 的接口是sockaddr，但是我们真正在基于 IPv4 编程时，使用的数据结构是sockaddr_in。这个结构里主要有三部分信息：地址类型, 端口号，IP 地址。</strong></p>\n<h3 id=\"in_addr%E7%BB%93%E6%9E%84\"><strong><span style=\"color:#ad720d;\">in_addr结构</span></strong></h3>\n<p><strong><img alt=\"\" height=\"172\" src=\"..\\..\\static\\image\\b155cecb10bc45f78941c6df56b734c6.png\" width=\"384\"/></strong></p>\n<p><strong>        in_addr 用来表示一个 IPv4 的 IP 地址。其实就是一个32位的整数。</strong></p>\n<h1 id=\"3.%20%E7%AE%80%E5%8D%95%E7%9A%84UDP%E7%BD%91%E7%BB%9C%E7%A8%8B%E5%BA%8F\"><strong><span style=\"color:#faa572;\">3. 简单的UDP网络程序</span></strong></h1>\n<h2 id=\"3.1%20%E6%8E%A5%E5%8F%A3\"><strong><span style=\"color:#9c8ec1;\">3.1 接口</span></strong></h2>\n<h3 id=\"3.1.1%20%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E6%8E%A5%E5%8F%A3\"><strong><span style=\"color:#ad720d;\">3.1.1 初始化的接口</span></strong></h3>\n<p><strong><img alt=\"\" height=\"388\" src=\"..\\..\\static\\image\\defb0797d0be40508ca1ead153caa1c6.png\" width=\"1200\"/></strong></p>\n<p><strong><img alt=\"\" height=\"89\" src=\"..\\..\\static\\image\\4c8f3195b50a4be9b1133e38fe10ed81.png\" width=\"1200\"/></strong></p>\n<p><strong><img alt=\"\" height=\"235\" src=\"..\\..\\static\\image\\6bc66875752a4f678c4dbaad0282261d.png\" width=\"1174\"/></strong></p>\n<p><strong><img alt=\"\" height=\"395\" src=\"..\\..\\static\\image\\261162af1e3e48efad5591f28b66e75e.png\" width=\"1138\"/></strong></p>\n<p><strong><img alt=\"\" height=\"314\" src=\"..\\..\\static\\image\\992801923f0044c1ae4caa5d6ab962ab.png\" width=\"815\"/></strong></p>\n<p><strong><img alt=\"\" height=\"452\" src=\"..\\..\\static\\image\\1022c305584e4b99a2d2f142ad85b5bc.png\" width=\"656\"/></strong></p>\n<h3 id=\"3.1.2%20%E8%BF%90%E8%A1%8C%E8%B5%B7%E6%9D%A5%E9%9C%80%E8%A6%81%E7%9A%84%E6%8E%A5%E5%8F%A3\"><strong><span style=\"color:#ad720d;\">3.1.2 运行起来需要的接口</span></strong></h3>\n<p><strong><img alt=\"\" height=\"354\" src=\"..\\..\\static\\image\\3c466e6e3a574aa1b69a3efc6e5a0eb4.png\" width=\"1200\"/></strong></p>\n<h2 id=\"3.2%20%E5%AE%9E%E7%8E%B0%20UDP\"><strong><span style=\"color:#9c8ec1;\">3.2 实现 UDP</span></strong></h2>\n<h3 id=\"udp_server.hpp\"><strong><span style=\"color:#ad720d;\">udp_server.hpp</span></strong></h3>\n<pre><code class=\"language-cpp\">  1 #pragma once\n  2 \n  3 #include &lt;iostream&gt;\n  4 #include &lt;string&gt;\n  5 #include &lt;cstring&gt;\n  6 #include &lt;sys/socket.h&gt;\n  7 #include &lt;sys/types.h&gt;\n  8 #include &lt;netinet/in.h&gt;\n  9 #include &lt;arpa/inet.h&gt;\n 10 \n 11 \n 12 #define DEFAULT 8081\n 13 \n 14 class UdpServer{\n 15   private:\n 16     short port;\n 17     int sockfd;\n 18     std::string ip;\n 19   public:\n 20     UdpServer(std::string _ip, int _port = DEFAULT)\n 21       : port(_port)\n 22       , sockfd(-1)\n 23       , ip(_ip)                                                                                                                         \n 24     {}\n 25 \n 26     bool InitUdpServer()\n 27     {\n 28       sockfd = socket(AF_INET, SOCK_DGRAM, 0);\n 29       if(sockfd &lt; 0){\n 30         std::cerr &lt;&lt; \"socket error\" &lt;&lt; std::endl;\n 31         return false;\n 32       }\n 33       std::cout &lt;&lt; \"socket create success, sockfd: \" &lt;&lt; sockfd &lt;&lt; std::endl;//大概率是3                                                 \n 34 \n 35 \n 36       struct sockaddr_in local;\n 37       memset(&amp;local, '\\0', sizeof(local));\n 38       local.sin_family = AF_INET;\n 39       local.sin_port = htons(port);\n 40       local.sin_addr.s_addr = inet_addr(ip.c_str());\n 41 \n 42       if(bind(sockfd, (struct sockaddr*)&amp;local, sizeof(local)) &lt; 0){\n 43         std::cerr &lt;&lt; \"bind error\" &lt;&lt; std::endl;\n 44         return false;\n 45       }\n 46       std::cout &lt;&lt; \"bind success\" &lt;&lt; std::endl;\n 47 \n 48 \n 49       return true;\n 50     }\n 51     \n 52     void Start()\n 53     {\n 54 #define SIZE 128\n 55       char buffer[SIZE];\n 56       for( ; ; ){\n 57         struct sockaddr_in peer;                                                                                                        \n 58         socklen_t len = sizeof(peer);\n 59         ssize_t size = recvfrom(sockfd, buffer, sizeof(buffer)-1, 0, (struct sockaddr*)&amp;peer, &amp;len);\n 60         if(size &gt; 0){\n 61           buffer[size] = 0;\n 62           short _port = ntohs(peer.sin_port);\n 63           std::string _ip = inet_ntoa(peer.sin_addr);\n 64           std::cout &lt;&lt; _ip &lt;&lt; \":\" &lt;&lt; _port &lt;&lt; \"# \" &lt;&lt; buffer &lt;&lt; std::endl;\n 65         }\n 66         else{\n 67           std::cerr &lt;&lt; \"recvfrom error\" &lt;&lt; std::endl;\n 68         }\n 69       }\n 70     }\n 71 \n 72     ~UdpServer()\n 73     {}\n 74 };\n</code></pre>\n<p><strong>        现在只写了服务器的端口，因为没有写用户的，但是我们想看一下我们可以不可以让别人访问到：</strong></p>\n<p><strong><img alt=\"\" height=\"117\" src=\"..\\..\\static\\image\\86b53bfae3b74bc38e2bbe4fba7e1283.png\" width=\"566\"/></strong></p>\n<p><strong>netstat 用来查看网络状态：</strong></p>\n<blockquote>\n<ul><li><strong>-n：能显示出数字就显示出数字</strong></li><li><strong>-l：列表</strong></li><li><strong>-t  -u：一个是tcp 一个是udp</strong></li><li><strong>-p：查看进程相关的信息</strong></li></ul>\n</blockquote>\n<p><strong><img alt=\"\" height=\"307\" src=\"..\\..\\static\\image\\0a005faee86347d1b8a21e13210dbb78.png\" width=\"1200\"/></strong></p>\n<p><strong>        Local Address 是 IP 地址和端口号。</strong></p>\n<p><strong>        Foreign Address 是对端的 IP 地址和端口号，0.0.0.0：* 表示的是任意的 IP，任意的端口都可以给我发送信息。</strong></p>\n<p><strong>        最后面的就是 PID 和程序的名字。</strong></p>\n<p><strong>        那么接下来我们就需要写 client 了。</strong></p>\n<p><strong><span style=\"color:#1c7331;\">客户端需要port么？客户端需要绑定么？</span></strong></p>\n<p><strong>        当然需要 port ，因为这里叫做网络编程、套接字编程，那么客户端和服务器都需要端口，但是客户端是不需要绑定的，在讲解这个问题前先说一下：</strong></p>\n<p><strong>        服务器为何要bind一个端口：服务器是为了给别人提供服务的，别人一定要知道你的 ip 和端口，所以端口一定要是一个众所周知的端口，而且 bind 之后，不能轻易改变，这也是为什么服务器需要 bind 一个端口，因为只有 bind 了之后这个端口才真正的属于它而不属于别人。</strong></p>\n<p><strong>        那么现在再为什么客户端不需要绑定：这里是不需要，而不是不能。但是一般情况下是不绑定的，因为客户端访问服务器，端口只要是唯一的即可，不需要和特定 client 进程强相关，client 端口可以动态的设置，要说绑定的话会有很多问题，比方说 bind 的是 8088，如果 8088 被别人占用了，那么这个客户端就启动不起来。</strong></p>\n<p><strong>        所以客户端只需要调用该 sendto 类似的接口，client 直接在 OS 层面会自动给 client 获取一个唯一的端口。</strong></p>\n<h3 id=\"udp_server.cc\"><strong><span style=\"color:#ad720d;\">udp_server.cc</span></strong></h3>\n<pre><code class=\"language-cpp\">  1 #include \"udp_server.hpp\"\n  2 \n  3 //./udp_server port\n  4 \n  5 int main(int argc, char* argv[])\n  6 {\n  7   if(argc != 2){\n  8     std::cerr &lt;&lt; \"Usage: \" &lt;&lt; argv[0] &lt;&lt; \" port\" &lt;&lt; std::endl;\n  9     return 1;\n 10   }\n 11 \n 12   std::string ip = \"127.0.0.1\"; //127.0.0.1 == localhost : 标识本机器 ： 本地环回\n 13   int port = atoi(argv[1]);                                                                        \n 14 \n 15   UdpServer* svr = new UdpServer(ip, port);\n 16   svr-&gt;InitUdpServer();\n 17 \n 18   svr-&gt;Start();\n 19   return 0;\n 20 }\n</code></pre>\n<h3 id=\"udp_client.hpp\"><strong><span style=\"color:#ad720d;\">udp_client.hpp</span></strong></h3>\n<pre><code class=\"language-cpp\">  1 #pragma once\n  2 \n  3 #include &lt;iostream&gt;\n  4 #include &lt;string&gt;\n  5 #include &lt;cstring&gt;\n  6 #include &lt;sys/socket.h&gt;\n  7 #include &lt;sys/types.h&gt;\n  8 #include &lt;arpa/inet.h&gt;\n  9 #include &lt;netinet/in.h&gt;\n 10 \n 11 \n 12 class UdpClient{\n 13   private:\n 14     int sockfd;\n 15     std::string ip;\n 16     int port;\n 17   public:\n 18     UdpClient(std::string _ip, int _port)\n 19       :ip(_ip)\n 20       , port(_port)\n 21   {}\n 22     bool InitUdpClient()\n 23     {                                                                                              \n 24       sockfd = socket(AF_INET, SOCK_DGRAM, 0);\n 25       if(sockfd &lt; 0){\n 26         std::cerr &lt;&lt; \"socket error!\" &lt;&lt; std::endl;\n 27         return false;\n 28       }\n 29       return true;\n 30     }\n 31     void Start()\n 32     {\n 33       struct sockaddr_in peer;                                                                     \n 34       memset(&amp;peer, 0, sizeof(peer));\n 35       peer.sin_family = AF_INET;\n 36       peer.sin_port = htons(port);\n 37       peer.sin_addr.s_addr = inet_addr(ip.c_str());\n 38 \n 39       std::string msg;\n 40       for(; ; ){\n 41         std::cout &lt;&lt; \"Pleace Enter# \";\n 42         std::cin &gt;&gt; msg;\n 43         sendto(sockfd, msg.c_str(), msg.size(), 0,(struct sockaddr*) &amp;peer, sizeof(peer));\n 44       }\n 45 \n 46 \n 47     }\n 48     ~UdpClient()\n 49     {}\n 50 };\n</code></pre>\n<h3 id=\"udp_client.cc\"><strong><span style=\"color:#ad720d;\">udp_client.cc</span></strong></h3>\n<pre><code class=\"language-cpp\">  1 #include \"udp_client.hpp\"\n  2 \n  3 //./udp_cilent ip port\n  4 int main(int argc, char* argv[])\n  5 {\n  6   if(argc != 3){\n  7     std::cerr &lt;&lt; \"Usage: \" &lt;&lt; argv[0] &lt;&lt; \"ip port\" &lt;&lt; std::endl;\n  8     return 1;\n  9   }\n 10   std::string ip = argv[1];\n 11   int port = atoi(argv[2]);                                                                        \n 12   UdpClient* uclt = new UdpClient(ip, port);\n 13   uclt-&gt;InitUdpClient();\n 14 \n 15   uclt-&gt;Start();\n 16 \n 17   return 0;\n 18 }</code></pre>\n<p><strong>        因为<span style=\"color:#79c6cd;\">这里我们绑定的不是外网，而是本地环回</span>，我们接下来通信一下：</strong></p>\n<p><strong><img alt=\"\" height=\"274\" src=\"..\\..\\static\\image\\2f8902254cfa434aa4896a048788d50c.png\" width=\"1200\"/></strong></p>\n<p><strong>        我们可以看到，我们完成了通信。</strong></p>\n<p><strong><img alt=\"\" height=\"317\" src=\"..\\..\\static\\image\\91923d41a2c84eda9e3dd4cd7786b4a3.png\" width=\"1200\"/></strong></p>\n<p><strong>        我们可以通过网络工具查看到这两个服务器。</strong></p>\n<p><strong><span style=\"color:#1c7331;\">那么如果我们的 IP 地址绑定的是公网 IP ，那么我们的 udp_server 就可以被外网访问呢？</span></strong></p>\n<p><strong><img alt=\"\" height=\"124\" src=\"..\\..\\static\\image\\92508bb931b64296a07f9a6af2226905.png\" width=\"1104\"/></strong></p>\n<p><strong>        那么此时我换上我的公网 IP 试试。</strong></p>\n<p><strong><img alt=\"\" height=\"223\" src=\"..\\..\\static\\image\\a7220311f4954eae91e53fb3fd33fae9.png\" width=\"552\"/></strong></p>\n<p><strong>        我们可以看到每次 bind 都是失败的，所以：</strong></p>\n<p><strong>        其实云服务器的 ip，是由对应的云厂商提供的，这个 ip 并不一定是真正的公网 ip，当然有可能这个云服务器收到公网 ip 再做一下转发的工作，但是现在不管这个。</strong></p>\n<p><strong>        所以这个 ip 不能直接被绑定，如果需要 bind，需要让外网访问，需要 bind 0 ，INADDR_ANY -&gt; 0 ，这个就是个宏，这个宏是 0 。 bind 0 意味着服务器可以接收来自任何 client 的请求。</strong></p>\n<p><strong>        但是有没有可能一个服务器有多张网卡呢？当然是有可能，那么当然也就有多个 ip。</strong></p>\n<p><strong><img alt=\"\" height=\"318\" src=\"..\\..\\static\\image\\bb4c2d35d0684c39b4437371d6fe8fe2.png\" width=\"481\"/></strong></p>\n<p><strong>        所以 INADDR_ANY 也是强烈推荐使用的。</strong></p>\n<p><strong>        所以我们其实就不需要去写 ip。</strong></p>\n<p><strong><img alt=\"\" height=\"332\" src=\"..\\..\\static\\image\\ed1c6b516ead4809aae22f0ffedb75a1.png\" width=\"1200\"/></strong></p>\n<p><strong>        我们可以看到，前面的是 127.0.0.1 ，此时的就是 0.0.0.0，也就意味着我们可以在本地读取任何一张网卡里的数据，只要能发过去，就能接收。</strong></p>\n<p><strong><span style=\"color:#1c7331;\">我们现在只做了读取，那么如果想要再发送回去呢？</span></strong></p>\n<p><strong>        那么接下来就写一个回声服务器，就是客户端发什么数据，服务器就给返回去。</strong></p>\n<p><strong><img alt=\"\" height=\"745\" src=\"..\\..\\static\\image\\1528f25f32894719bc9964a97ebb8158.png\" width=\"1189\"/></strong></p>\n<p><strong>        我们只要加上上面红框的内容就可以，其实也就是再 server 里添加一个发送传过来的字符串的接口，然后再让 client 接收 server 传过来的字符串再打印下来就可以了。</strong></p>\n<p><strong><img alt=\"\" height=\"226\" src=\"..\\..\\static\\image\\875d3399dd124349ba65d76977890270.png\" width=\"1200\"/></strong></p>\n<p><strong>         接下来就写一个简单的业务：</strong></p>\n<p><strong><img alt=\"\" height=\"359\" src=\"..\\..\\static\\image\\c12b9f62be1746e2ac643a18d7b88d35.png\" width=\"916\"/></strong></p>\n<p><strong>        我们只在 udp_server 中创建一个子进程，让子进程去完成这个业务就好。</strong></p>\n<p><strong><img alt=\"\" height=\"408\" src=\"..\\..\\static\\image\\e5a9c11315024d62bc1e1a3f17be7942.png\" width=\"1200\"/></strong></p>\n<p><strong>         我们可以看到，客户端输入 ls，服务端也完成了对应的业务。</strong></p>\n<p><strong>        那么接下来想要再回显给客户端：</strong></p>\n<pre><code class=\"language-cpp\">  1 #pragma once\n  2 \n  3 #include &lt;iostream&gt;\n  4 #include &lt;string&gt;\n  5 #include &lt;cstring&gt;\n  6 #include &lt;sys/socket.h&gt;\n  7 #include &lt;sys/types.h&gt;\n  8 #include &lt;netinet/in.h&gt;\n  9 #include &lt;arpa/inet.h&gt;\n 10 #include &lt;unistd.h&gt;\n 11 #include &lt;sys/wait.h&gt;\n 12 #define DEFAULT 8081\n 13 \n 14 class UdpServer{\n 15   private:\n 16     int port;\n 17     int sockfd;\n 18     //std::string ip;\n 19   public:\n 20     UdpServer(int _port = DEFAULT)\n 21       : port(_port)\n 22       , sockfd(-1)\n 23     {}                                                                                                                \n 24 \n 25     bool InitUdpServer()\n 26     {\n 27       sockfd = socket(AF_INET, SOCK_DGRAM, 0);\n 28       if(sockfd &lt; 0){\n 29         std::cerr &lt;&lt; \"socket error\" &lt;&lt; std::endl;\n 30         return false;\n 31       }\n 32       std::cout &lt;&lt; \"socket create success, sockfd: \" &lt;&lt; sockfd &lt;&lt; std::endl;//大概率是3\n 33                                                                                                                       \n 34 \n 35       struct sockaddr_in local;//网络通信地址\n 36       memset(&amp;local, '\\0', sizeof(local));\n 37       local.sin_family = AF_INET;\n 38       local.sin_port = htons(port);//端口号\n 39       //local.sin_addr.s_addr = inet_addr(ip.c_str());\n 40       local.sin_addr.s_addr = INADDR_ANY;\n 41       if(bind(sockfd, (struct sockaddr*)&amp;local, sizeof(local)) &lt; 0){\n 42         std::cerr &lt;&lt; \"bind error\" &lt;&lt; std::endl;\n 43         return false;\n 44       }\n 45       std::cout &lt;&lt; \"bind success\" &lt;&lt; std::endl;\n 46 \n 47 \n 48       return true;\n 49     }\n 50     \n 51     void Start()\n 52     {\n 53 #define SIZE 128\n 54       char buffer[SIZE];\n 55 \n 56       for( ; ; ){\n 57         struct sockaddr_in peer;\n 58         socklen_t len = sizeof(peer);\n 59         ssize_t size = recvfrom(sockfd, buffer, sizeof(buffer)-1, 0, (struct sockaddr*)&amp;peer, &amp;len);\n 60         if(size &gt; 0){                                                                                                 \n 61           buffer[size] = 0;\n 62           int _port = ntohs(peer.sin_port);\n 63           std::string _ip = inet_ntoa(peer.sin_addr);\n 64           std::cout &lt;&lt; _ip &lt;&lt; \":\" &lt;&lt; _port &lt;&lt; \"# \" &lt;&lt; buffer &lt;&lt; std::endl;\n 65 \n 66           std::string cmd = buffer;\n 67           std::string result;\n 68           if(cmd == \"ls\"){\n 69             int pipes[2];\n 70             pipe(pipes);\n 71 \n 72             pid_t id = fork();\n 73             if(id == 0){\n 74               close(pipes[0]);//子进程要写，所以关闭读\n 75               dup2(pipes[1], 1);\n 76               execl(\"/usr/bin/ls\", \"ls\", \"-a\", \"-l\", \"-i\", nullptr);\n 77               exit(1);\n 78             }\n 79             close(pipes[1]);//父进程要读，所以要关闭写\n 80             char c;\n 81             while(1){\n 82               if(read(pipes[0], &amp;c, 1) &gt; 0){\n 83                 result.push_back(c);\n 84               }\n 85               else{\n 86                 break;\n 87               }\n 88             }\n 89             wait(nullptr);\n 90           }                                                                                                           \n 91 \n 92           std::string echo_msg;\n 93           if(result.empty()){\n 94             echo_msg = \"server get!-&gt;\";\n 95             echo_msg += buffer;\n 96           }\n 97           else{\n 98             echo_msg = result;\n 99           }\n100           sendto(sockfd, echo_msg.c_str(), echo_msg.size(), 0, (struct sockaddr*)&amp;peer, len);\n101         }\n102         else{\n103           std::cerr &lt;&lt; \"recvfrom error\" &lt;&lt; std::endl;\n104         }\n105       }\n106     }\n107 \n108     ~UdpServer()\n109     {\n110       if(sockfd &gt;= 0){\n111         close(sockfd);\n112       }\n113     }\n114 };\n</code></pre>\n<p><strong><img alt=\"\" height=\"1054\" src=\"..\\..\\static\\image\\380eae02911d47a0a7d2bf93c376d37c.png\" width=\"897\"/></strong></p>\n<p><strong>         这里的思路是：如果输入的是 ls，那么创建一个匿名管道，然后子进程要写，所以关闭读，父进程要读，所以关闭写，因为管道只能单向通信，然后父进程将读到的写到 result 字符串里，然后打印到客户端。</strong></p>\n<p><strong>        如果输入的不是 ls，那么就打印到客户端是你输入的内容。</strong></p>\n<p><strong><img alt=\"\" height=\"187\" src=\"..\\..\\static\\image\\56edc0d8300f4fa49511d485910da7eb.png\" width=\"1200\"/></strong></p>\n<p><strong>        这里效果其实有点问题，我们可以看到我们打印的是 ls -a -l -i，他应该展示出来的要比这个多，这应该是因为管道是有大小的，所以 execl 的时候已经都将管道占满了还没有打印完，所以出现这个情况，但是如果我们打印 ls 的话就是这样的：</strong></p>\n<p><strong><img alt=\"\" height=\"263\" src=\"..\\..\\static\\image\\68444028f1634f528aa020665abebf4e.png\" width=\"1200\"/></strong></p>\n<p><strong>        我们可以看到这样是打印全的，所以应该就是上面所说的问题~</strong></p>\n<p><strong>        此时我们的 UDP 就会用了，下面给出了代码，大家可以也去试试。</strong></p>\n<h2 id=\"3.3%20UDP%E6%80%BB%E4%BB%A3%E7%A0%81\"><strong><span style=\"color:#9c8ec1;\">3.3 UDP总代码</span></strong></h2>\n<h3><strong><span style=\"color:#ad720d;\">udp_server.hpp</span></strong></h3>\n<pre><code class=\"language-cpp\">  1 #pragma once                                                                                                                                            \n  2 \n  3 #include &lt;iostream&gt;\n  4 #include &lt;string&gt;\n  5 #include &lt;cstring&gt;\n  6 #include &lt;sys/socket.h&gt;\n  7 #include &lt;sys/types.h&gt;\n  8 #include &lt;netinet/in.h&gt;\n  9 #include &lt;arpa/inet.h&gt;\n 10 #include &lt;unistd.h&gt;\n 11 #include &lt;sys/wait.h&gt;\n 12 #define DEFAULT 8081\n 13 \n 14 class UdpServer{\n 15   private:\n 16     int port;\n 17     int sockfd;\n 18     //std::string ip;\n 19   public:\n 20     UdpServer(int _port = DEFAULT)\n 21       : port(_port)\n 22       , sockfd(-1)\n 23     {}\n 24 \n 25     bool InitUdpServer()\n 26     {\n 27       sockfd = socket(AF_INET, SOCK_DGRAM, 0);\n 28       if(sockfd &lt; 0){\n 29         std::cerr &lt;&lt; \"socket error\" &lt;&lt; std::endl;\n 30         return false;\n 31       }\n 32       std::cout &lt;&lt; \"socket create success, sockfd: \" &lt;&lt; sockfd &lt;&lt; std::endl;//大概率是3\n 33                                                                                                                                                         \n 34 \n 35       struct sockaddr_in local;//网络通信地址\n 36       memset(&amp;local, '\\0', sizeof(local));\n 37       local.sin_family = AF_INET;\n 38       local.sin_port = htons(port);//端口号\n 39       //local.sin_addr.s_addr = inet_addr(ip.c_str());\n 40       local.sin_addr.s_addr = INADDR_ANY;\n 41       if(bind(sockfd, (struct sockaddr*)&amp;local, sizeof(local)) &lt; 0){\n 42         std::cerr &lt;&lt; \"bind error\" &lt;&lt; std::endl;\n 43         return false;\n 44       }\n 45       std::cout &lt;&lt; \"bind success\" &lt;&lt; std::endl;\n 46 \n 47 \n 48       return true;\n 49     }\n 50     \n 51     void Start()\n 52     {\n 53 #define SIZE 1000\n 54       char buffer[SIZE];\n 55 \n 56       for( ; ; ){\n 57         struct sockaddr_in peer;\n 58         socklen_t len = sizeof(peer);\n 59         ssize_t size = recvfrom(sockfd, buffer, sizeof(buffer)-1, 0, (struct sockaddr*)&amp;peer, &amp;len);\n 60         if(size &gt; 0){                                                                                                                                   \n 61           buffer[size] = 0;\n 62           int _port = ntohs(peer.sin_port);\n 63           std::string _ip = inet_ntoa(peer.sin_addr);\n 64           std::cout &lt;&lt; _ip &lt;&lt; \":\" &lt;&lt; _port &lt;&lt; \"# \" &lt;&lt; buffer &lt;&lt; std::endl;\n 65 \n 66           std::string cmd = buffer;\n 67           std::string result;\n 68           if(cmd == \"ls\"){\n 69             int pipes[2];\n 70             pipe(pipes);\n 71 \n 72             pid_t id = fork();\n 73             if(id == 0){\n 74               close(pipes[0]);//子进程要写，所以关闭读\n 75               dup2(pipes[1], 1);\n 76               execl(\"/usr/bin/ls\", \"ls\", nullptr);\n 77               exit(1);\n 78             }\n 79             close(pipes[1]);//父进程要读，所以要关闭写\n 80             char c;\n 81             while(1){\n 82               if(read(pipes[0], &amp;c, 1) &gt; 0){\n83                 result.push_back(c);\n 84               }\n 85               else{\n 86                 break;\n 87               }                                                                                                                                         \n 88             }\n 89             wait(nullptr);\n 90           }\n 91 \n 92           std::string echo_msg;\n 93           if(result.empty()){\n 94             echo_msg = \"server get!-&gt;\";\n 95             echo_msg += buffer;\n 96           }\n 97           else{\n 98             echo_msg = result;\n 99           }\n100           sendto(sockfd, echo_msg.c_str(), echo_msg.size(), 0, (struct sockaddr*)&amp;peer, len);\n101         }\n102         else{\n103           std::cerr &lt;&lt; \"recvfrom error\" &lt;&lt; std::endl;\n104         }\n105       }\n106     }\n107 \n108     ~UdpServer()\n109     {\n110       if(sockfd &gt;= 0){\n111         close(sockfd);\n112       }\n113     }\n114 };\n</code></pre>\n<h3><strong><span style=\"color:#ad720d;\">udp_server.cc</span></strong></h3>\n<pre><code class=\"language-cpp\">  1 #include \"udp_server.hpp\"                                                                                                                               \n  2 \n  3 //./udp_server port\n  4 \n  5 int main(int argc, char* argv[])\n  6 {\n  7   if(argc != 2){\n  8     std::cerr &lt;&lt; \"Usage: \" &lt;&lt; argv[0] &lt;&lt; \" port\" &lt;&lt; std::endl;\n  9     return 1;\n 10   }\n 11 \n 12   //std::string ip = \"127.0.0.1\"; //127.0.0.1 == localhost : 标识本机器 ： 本地环回\n 13   //std::string ip = \"49.232.134.146\";\n 14   int port = atoi(argv[1]);\n 15 \n 16   UdpServer* svr = new UdpServer(port);\n 17   svr-&gt;InitUdpServer();\n 18 \n 19   svr-&gt;Start();\n 20   return 0;\n 21 }\n</code></pre>\n<h3><strong><span style=\"color:#ad720d;\">udp_client.hpp</span></strong></h3>\n<pre><code class=\"language-cpp\">  1 #pragma once                                                                                                                                            \n  2 \n  3 #include &lt;iostream&gt;\n  4 #include &lt;string&gt;\n  5 #include &lt;cstring&gt;\n  6 #include &lt;sys/socket.h&gt;\n  7 #include &lt;sys/types.h&gt;\n  8 #include &lt;arpa/inet.h&gt;\n  9 #include &lt;netinet/in.h&gt;\n 10 #include &lt;unistd.h&gt;\n 11 \n 12 class UdpClient{\n 13   private:\n 14     int sockfd;\n 15     std::string ip;\n 16     int port;\n 17   public:\n 18     UdpClient(std::string _ip, int _port)\n 19       :ip(_ip)\n 20       , port(_port)\n 21   {}\n 22     bool InitUdpClient()\n 23     {\n 24       sockfd = socket(AF_INET, SOCK_DGRAM, 0);\n 25       if(sockfd &lt; 0){\n 26         std::cerr &lt;&lt; \"socket error!\" &lt;&lt; std::endl;\n 27         return false;\n 28       }\n 29       return true;\n 30     }\n 31     void Start()\n 32     {\n 33       struct sockaddr_in peer;                                                                                                                          \n 34       memset(&amp;peer, 0, sizeof(peer));\n 35       peer.sin_family = AF_INET;\n 36       peer.sin_port = htons(port);\n 37       peer.sin_addr.s_addr = inet_addr(ip.c_str());\n 38 \n 39       std::string msg;\n 40       for(; ; ){\n 41         std::cout &lt;&lt; \"Pleace Enter# \";\n 42         std::cin &gt;&gt; msg;\n 43         sendto(sockfd, msg.c_str(), msg.size(), 0,(struct sockaddr*) &amp;peer, sizeof(peer));\n 44 \n 45         char buffer[128];\n 46         //当然如果担心客户端发生变化就可以把peer传过来\n 47         struct sockaddr_in temp;\n 48         socklen_t len = sizeof(temp);\n 49         ssize_t size = recvfrom(sockfd, buffer, sizeof(buffer)-1, 0, (struct sockaddr*)&amp;temp, &amp;len);\n 50         if(size &gt; 0){\n 51           buffer[size] = 0;\n 52           std::cout &lt;&lt; buffer &lt;&lt; std::endl;\n 53         }\n 54       }\n 55 \n 56 \n 57     }\n 58     ~UdpClient()\n 59     {\n 60       if(sockfd &gt;= 0){\n 61         close(sockfd);\n 62       }\n 63     }\n 64 };\n</code></pre>\n<h3><strong><span style=\"color:#ad720d;\">udp_client.cc</span></strong></h3>\n<pre><code class=\"language-cpp\">  1 #include \"udp_client.hpp\"                                                                                                                               \n  2 \n  3 //./udp_cilent ip port\n  4 int main(int argc, char* argv[])\n  5 {\n  6   if(argc != 3){\n  7     std::cerr &lt;&lt; \"Usage: \" &lt;&lt; argv[0] &lt;&lt; \"ip port\" &lt;&lt; std::endl;\n  8     return 1;\n  9   }\n 10   std::string ip = argv[1];\n 11   int port = atoi(argv[2]);\n 12   UdpClient* uclt = new UdpClient(ip, port);\n 13   uclt-&gt;InitUdpClient();\n 14 \n 15   uclt-&gt;Start();\n 16 \n 17   return 0;\n 18 }\n</code></pre>\n<h1 id=\"4.%20%E5%A4%9A%E6%96%B9%E6%B3%95TCP%E9%80%9A%E4%BF%A1\"><strong><span style=\"color:#faa572;\">4. 多方法TCP通信</span></strong></h1>\n<h2 id=\"4.1%20%E6%8E%A5%E5%8F%A3\"><strong><span style=\"color:#9c8ec1;\">4.1 接口</span></strong></h2>\n<p><strong><img alt=\"\" height=\"136\" src=\"..\\..\\static\\image\\4c3d60923def44c0a25670928ef3770f.png\" width=\"633\"/></strong></p>\n<p><strong><img alt=\"\" height=\"224\" src=\"..\\..\\static\\image\\b4092d5d83214ab8b4ecf468f1fc1bf0.png\" width=\"1200\"/></strong></p>\n<p><strong><img alt=\"\" height=\"218\" src=\"..\\..\\static\\image\\37c4cdd1ca934fc2af634436dfad5bf2.png\" width=\"1200\"/></strong></p>\n<h2 id=\"4.2%20TCP%20%E5%8D%95%E6%89%A7%E8%A1%8C%E6%B5%81\"><strong><span style=\"color:#9c8ec1;\">4.2 TCP 单执行流</span></strong></h2>\n<p><strong>        因为 tcp 是面向连接的，所以需要在正式发送数据之前，先要建立链接。既然要建立连接，那么服务器端必须得不断的花时间进行检测是否有新的链接到来。</strong></p>\n<h3 id=\"tcp_server.hpp\"><strong><span style=\"color:#ad720d;\">tcp_server.hpp</span></strong></h3>\n<pre><code class=\"language-cpp\">  1 #pragma once \n  2 \n  3 #include &lt;iostream&gt;\n  4 #include &lt;string&gt;\n  5 #include &lt;cstring&gt;\n  6 #include &lt;sys/socket.h&gt;\n  7 #include &lt;sys/types.h&gt;\n  8 #include &lt;arpa/inet.h&gt;\n  9 #include &lt;unistd.h&gt;\n 10 \n 11 #define  BACKLOG 5\n 12 \n 13 class TcpServer{\n 14   private:\n 15     short port;\n 16     int listen_sock;\n 17   public:\n 18     TcpServer(short _port)\n 19       :port(_port)\n 20        ,listen_sock(-1)\n 21   {}\n 22     bool InitTcpServer()\n 23     {                                                                                                                               \n 24       listen_sock = socket(AF_INET, SOCK_STREAM, 0);\n 25       if(listen_sock &lt; 0){\n 26         std::cerr &lt;&lt; \"socket error\" &lt;&lt; std::endl;\n 27         return false;\n 28       }\n 29 \n 30       struct sockaddr_in local;\n 31       //bzero(&amp;local, sizeof(local));\n 32       memset(&amp;local, 0, sizeof(local));\n 33       local.sin_family = AF_INET;                                                                                                   \n 34       local.sin_port = htons(port);\n 35       local.sin_addr.s_addr = INADDR_ANY;\n 36 \n 37       if(bind(listen_sock, (struct sockaddr*)&amp;local, sizeof(local)) &lt; 0){\n 38         std::cerr &lt;&lt; \"bind error\" &lt;&lt; std::endl;\n 39         return false;\n 40       }\n 41       \n 42       if(listen(listen_sock, BACKLOG) &lt; 0){\n 43         std::cerr &lt;&lt; \"listen error\" &lt;&lt;std::endl;\n 44         return false;\n 45       }\n 46       std::cout &lt;&lt; \"listen success\" &lt;&lt; std::endl;\n 47       return true;\n 48     }\n 49     void Loop()\n 50     {\n 51       struct sockaddr_in peer;\n 52       for(;;)\n 53       {\n 54         //先获取链接\n 55         socklen_t len = sizeof(peer);\n 56         int sock = accept(listen_sock, (struct sockaddr*)&amp;peer, &amp;len);\n 57         if(sock &lt; 0){\n 58           std::cerr &lt;&lt; \"accept error\" &lt;&lt; std::endl;\n 59           continue;\n 60         }\n 61         std::cout &lt;&lt; \"get a new link: \" &lt;&lt; sock &lt;&lt; std::endl;\n 62       }\n 63     }\n 64     ~TcpServer()\n 65     {}\n 66 };</code></pre>\n<h3 id=\"tcp_server.cc\"><strong><span style=\"color:#ad720d;\">tcp_server.cc</span></strong></h3>\n<pre><code class=\"language-cpp\">  1 #include \"tcp_server.hpp\"\n  2 \n  3 int main()\n  4 {\n  5   TcpServer tsvr(8081);\n  6   tsvr.InitTcpServer();                                                                                                             \n  7 \n  8   tsvr.Loop();\n  9 \n 10 \n 11   return 0;\n 12 }\n</code></pre>\n<p><strong>        listen_sock：获取新链接。</strong></p>\n<p><strong>        sock：服务新链接(读取数据、分析数据、处理数据、写入数据)。</strong></p>\n<p><strong>        这里有一个命令 telnet 是远程登陆。</strong></p>\n<p><strong><img alt=\"\" height=\"376\" src=\"..\\..\\static\\image\\9d464fd58a554bfb9e9f0b7bee482a19.png\" width=\"1200\"/></strong></p>\n<p><strong>        我们可以看到，用本地环回可以建立链接，用公网 ip 也可以。</strong></p>\n<p><strong>        甚至，我们还可以用浏览器去访问 8081，虽然服务器里现在什么都没有，但是浏览器底层用的是 http，或者 https ，底层都是 tcp，所以它也会向服务器发送请求。</strong></p>\n<h3 id=\"tcp_client.hpp\"><strong><span style=\"color:#ad720d;\">tcp_client.hpp</span></strong></h3>\n<pre><code class=\"language-cpp\">  1 #pragma once\n  2 \n  3 #include &lt;iostream&gt;\n  4 #include &lt;string&gt;\n  5 #include &lt;cstring&gt;\n  6 #include &lt;unistd.h&gt;\n  7 #include &lt;sys/types.h&gt;\n  8 #include &lt;sys/socket.h&gt;\n  9 #include &lt;arpa/inet.h&gt;\n 10 #include &lt;netinet/in.h&gt;\n 11 \n 12 class TcpClient{\n 13   private:\n 14     std::string ip;\n 15     short port;\n 16     int sock;\n 17   public:                                                                                                                  \n 18     TcpClient(std::string _ip, short _port)\n 19       :ip(_ip)\n 20        ,port(_port)\n 21        ,sock(-1)\n 22     {}\n 23     void InitTcpClient()\n 24     {\n 25       sock = socket(AF_INET, SOCK_STREAM, 0);\n 26       if(sock &lt; 0){\n 27         std::cerr &lt;&lt; \"socket error\" &lt;&lt; std::endl;\n 28         exit(2);\n 29       }\n 30 \n 31     }\n 32 \n 33     void Loop()                                                                                                            \n 34     {\n 35       struct sockaddr_in peer;\n 36       memset(&amp;peer, 0, sizeof(peer));\n 37       peer.sin_family = AF_INET;\n 38       peer.sin_port = htons(port);\n 39       peer.sin_addr.s_addr = inet_addr(ip.c_str());;\n 40       //连接服务器\n 41       if(connect(sock, (struct sockaddr*)&amp;peer, sizeof(peer)) == 0){\n 42         //success\n 43         std::cout &lt;&lt; \"connect success ...\" &lt;&lt; std::endl;\n 44         Request(sock);\n 45       }\n 46       else{\n 47         //failed\n 48         std::cerr &lt;&lt; \"connect failed ...\" &lt;&lt; std::endl;\n 49       }\n 50     }\n 51 \n 52     void Request(int sock)\n 53     {\n 54       std::string msg;\n 55       char buffer[1024];\n 56       while(true){\n 57         std::cout &lt;&lt; \"Please Entet# \";\n 58         std::cin &gt;&gt; msg;\n 59 \n 60         write(sock, msg.c_str(), msg.size());                                                                              \n 61 \n 62         ssize_t s = read(sock, buffer, sizeof(buffer)-1);\n 63         if(s &gt; 0){\n 64           buffer[s] = 0;\n 65         }\n 66         std::cout &lt;&lt; \"server echo# \" &lt;&lt; buffer &lt;&lt; std::endl;\n 67       }\n 68     }\n 69 \n 70     ~TcpClient()\n 71     {\n 72       if(sock &gt;= 0){\n 73         close(sock);\n 74       }\n 75     }\n 76 };</code></pre>\n<h3 id=\"tcp_client.cc\"><strong><span style=\"color:#ad720d;\">tcp_client.cc</span></strong></h3>\n<pre><code class=\"language-cpp\">  1 #include \"tcp_client.hpp\"\n  2 \n  3 \n  4 int main(int argc, char* argv[])\n  5 {\n  6   if(argc != 3){\n  7     std::cout &lt;&lt; \"Usage: \" &lt;&lt; argv[0] &lt;&lt; \"ip port\" &lt;&lt; std::endl;\n  8     exit(1);\n  9   }\n 10 \n 11   TcpClient tclt(argv[1], atoi(argv[2]));                                                                                  \n 12   tclt.InitTcpClient();\n 13 \n 14   tclt.Loop();\n 15 \n 16   return 0;\n 17 }\n</code></pre>\n<p><strong><img alt=\"\" height=\"220\" src=\"..\\..\\static\\image\\169a39d05d6341acba9fc6e42a131d71.png\" width=\"1200\"/></strong></p>\n<p><strong><img alt=\"\" height=\"226\" src=\"..\\..\\static\\image\\1262366acc8f4cc4a97dd359bb862e3f.png\" width=\"1200\"/></strong></p>\n<p><strong>        我们可以看到，我们是可以进行通信的，而且当我们关掉客户端的时候，服务就会终止，但是服务器还是在运行的，它再等下一个服务请求。</strong></p>\n<p><strong>        但是这里有个问题：</strong></p>\n<p><strong><img alt=\"\" height=\"335\" src=\"..\\..\\static\\image\\c03855f7011a459a9d157b2a4a12b28b.png\" width=\"1200\"/></strong></p>\n<p><strong>        当我们两个客户端同时链接，同时发消息就会出现这个情况，然后：</strong></p>\n<p><strong><img alt=\"\" height=\"361\" src=\"..\\..\\static\\image\\a8449a3c7d754ade8217678985daad7d.png\" width=\"1200\"/></strong></p>\n<p><strong>        当我们 ctrl+c 的时候 42424 退出了，又来了个链接 42436，然后 \"你是好人\" 也发送了，</strong></p>\n<p><strong>        所以这里现在其实是串行的，因为我们现在写的这个是一个单执行流的服务器，现在只能处理一个人的请求。</strong></p>\n<h2 id=\"4.3%20TCP%20%E5%A4%9A%E8%BF%9B%E7%A8%8B\"><strong><span style=\"color:#9c8ec1;\">4.3 TCP 多进程</span></strong></h2>\n<h3><strong><span style=\"color:#ad720d;\">tcp_server.hpp</span></strong></h3>\n<pre><code class=\"language-cpp\">  1 #pragma once \n  2 \n  3 #include &lt;iostream&gt;\n  4 #include &lt;string&gt;\n  5 #include &lt;cstring&gt;\n  6 #include &lt;sys/socket.h&gt;\n  7 #include &lt;sys/types.h&gt;\n  8 #include &lt;arpa/inet.h&gt;\n  9 #include &lt;unistd.h&gt;\n 10 #include &lt;signal.h&gt;\n 11 #include &lt;sys/wait.h&gt;\n 12 #define  BACKLOG 5\n 13 \n 14 class TcpServer{\n 15   private:\n 16     short port;\n 17     int listen_sock;\n 18   public:\n 19     TcpServer(short _port)\n 20       :port(_port)\n 21        ,listen_sock(-1)\n 22   {}\n 23     bool InitTcpServer()\n 24     {\n 25       listen_sock = socket(AF_INET, SOCK_STREAM, 0);\n 26       if(listen_sock &lt; 0){\n 27         std::cerr &lt;&lt; \"socket error\" &lt;&lt; std::endl;\n 28         return false;\n 29       }                                                                                                                                                                      \n 30 \n 31       struct sockaddr_in local;\n 32       //bzero(&amp;local, sizeof(local));\n 33       memset(&amp;local, 0, sizeof(local));\n 34       local.sin_family = AF_INET;\n 35       local.sin_port = htons(port);\n 36       local.sin_addr.s_addr = INADDR_ANY;\n 37 \n 38       if(bind(listen_sock, (struct sockaddr*)&amp;local, sizeof(local)) &lt; 0){\n 39         std::cerr &lt;&lt; \"bind error\" &lt;&lt; std::endl;                                                                                                                              \n 40         return false;\n 41       }\n 42       \n 43       if(listen(listen_sock, BACKLOG) &lt; 0){\n 44         std::cerr &lt;&lt; \"listen error\" &lt;&lt;std::endl;\n 45         return false;\n 46       }\n 47       std::cout &lt;&lt; \"listen success\" &lt;&lt; std::endl;\n 48       return true;\n 49     }\n 50     void Loop()\n 51     {\n 52       //这样写父进程就不用等子进程了，很推荐，因为很简单\n 53       //signal(SIGCHLD, SIG_IGN);\n 54        struct sockaddr_in peer;\n 55       for(;;)\n 56       {\n 57         //先获取链接\n 58         socklen_t len = sizeof(peer);\n 59         int sock = accept(listen_sock, (struct sockaddr*)&amp;peer, &amp;len);\n 60         //这里是accept失败\n 61         if(sock &lt; 0){\n 62           std::cerr &lt;&lt; \"accept error\" &lt;&lt; std::endl;\n 63           continue;\n 64         }\n 65         \n 66 \n 67         pid_t id = fork();\n 68         if(id == 0){\n 69           //创建出来孙子进程是为了土共服务的\n 70           //所以不用关心 listen_sock了\n 71           close(listen_sock);//这里不是必要的\n 72           if(fork() &gt; 0){                                                                                                                                                    \n 73             exit(0);\n 74           }\n 75           //孙子进程\n 76           //这样做的原因是父进程退出，子进程被系统领养成为孤儿进程\n 77           std::string ip = inet_ntoa(peer.sin_addr);\n 78           int port = ntohs(peer.sin_port);\n 79           std::cout &lt;&lt; \"get a new link:\"&lt;&lt; sock &lt;&lt;\"[\" &lt;&lt; ip &lt;&lt; \"]\" &lt;&lt; port &lt;&lt; std::endl;\n 80           Service(sock, ip, port);//处理\n 81           exit(0);\n 82         }\n 83 \n 84         //这里关掉sock不会影响孙子进程的使用\n 85         //因为就相当于爷爷进程将指向sock这个文件描述符关掉\n 86         close(sock);//这里是必要的\n 87         //这里还是要等的，因为父进程退出，爷爷进程是要等父进程的\n 88         //但是这里就不算是挂起了，因为父进程是直接就退出，爷爷进程直接回收\n 89         waitpid(id, nullptr, 0);//这里的id就是父进程的id，当然这里也可以写成-1\n 90       }\n 91 \n 92     }\n 93 \n 94     void Service(int sock, std::string&amp; ip, short port)\n 95     {\n 96       char buffer[1024];\n 97       while(true){\n 98         ssize_t size = read(sock, buffer, sizeof(buffer)-1);\n 99         if(size &gt; 0){\n100           buffer[size] = 0;\n101           std::cout &lt;&lt; ip &lt;&lt; \":\" &lt;&lt; port &lt;&lt; \"# \" &lt;&lt; buffer &lt;&lt; std::endl;\n102           //回显\n103           write(sock, buffer, size);\n104         }\n105         else if (size == 0){                                                                                                                                                 \n106           std::cout &lt;&lt; ip &lt;&lt; \":\" &lt;&lt; port &lt;&lt; \"close!\" &lt;&lt; buffer &lt;&lt; std::endl;\n107           break;\n108         }\n109         else{\n110           std::cerr &lt;&lt; port &lt;&lt; \"read error\" &lt;&lt; std::endl;\n111           break;\n112         }\n113       }\n114       \n115       close(sock);\n116       std::cout &lt;&lt; \"Service done!\" &lt;&lt; std::endl;\n117     }\n118 \n119     ~TcpServer()\n120     {\n121       if(listen_sock &gt;= 0){\n122         close(listen_sock);\n123       }\n124     }\n125 };</code></pre>\n<h3><strong><span style=\"color:#ad720d;\">tcp_server.cc</span></strong></h3>\n<pre><code class=\"language-cpp\">  1 #include \"tcp_server.hpp\"\n  2 \n  3 int main(int argc, char* argv[])\n  4 {\n  5   if(argc != 2){\n  6     std::cout &lt;&lt; \"Usage: \" &lt;&lt; argv[0] &lt;&lt; \"port\" &lt;&lt; std::endl;\n  7     exit(1);\n  8   }\n  9   TcpServer tsvr(atoi(argv[1]));                                                                                                                                             \n 10   tsvr.InitTcpServer();\n 11 \n 12   tsvr.Loop();\n 13 \n 14 \n 15   return 0;\n 16 }\n</code></pre>\n<h3><strong><span style=\"color:#ad720d;\">tcp_client.hpp</span></strong></h3>\n<pre><code class=\"language-cpp\">  1 #pragma once\n  2 \n  3 #include &lt;iostream&gt;\n  4 #include &lt;string&gt;\n  5 #include &lt;cstring&gt;\n  6 #include &lt;unistd.h&gt;\n  7 #include &lt;sys/types.h&gt;\n  8 #include &lt;sys/socket.h&gt;\n  9 #include &lt;arpa/inet.h&gt;\n 10 #include &lt;netinet/in.h&gt;\n 11 \n 12 class TcpClient{\n 13   private:\n 14     std::string ip;\n 15     short port;\n 16     int sock;\n 17   public:                                                                                                                  \n 18     TcpClient(std::string _ip, short _port)\n 19       :ip(_ip)\n 20        ,port(_port)\n 21        ,sock(-1)\n 22     {}\n 23     void InitTcpClient()\n 24     {\n 25       sock = socket(AF_INET, SOCK_STREAM, 0);\n 26       if(sock &lt; 0){\n 27         std::cerr &lt;&lt; \"socket error\" &lt;&lt; std::endl;\n 28         exit(2);\n 29       }\n 30 \n 31     }\n 32 \n 33     void Loop()                                                                                                            \n 34     {\n 35       struct sockaddr_in peer;\n 36       memset(&amp;peer, 0, sizeof(peer));\n 37       peer.sin_family = AF_INET;\n 38       peer.sin_port = htons(port);\n 39       peer.sin_addr.s_addr = inet_addr(ip.c_str());;\n 40       //连接服务器\n 41       if(connect(sock, (struct sockaddr*)&amp;peer, sizeof(peer)) == 0){\n 42         //success\n 43         std::cout &lt;&lt; \"connect success ...\" &lt;&lt; std::endl;\n 44         Request(sock);\n 45       }\n 46       else{\n 47         //failed\n 48         std::cerr &lt;&lt; \"connect failed ...\" &lt;&lt; std::endl;\n 49       }\n 50     }\n 51 \n 52     void Request(int sock)\n 53     {\n 54       std::string msg;\n 55       char buffer[1024];\n 56       while(true){\n 57         std::cout &lt;&lt; \"Please Entet# \";\n 58         std::cin &gt;&gt; msg;\n 59 \n 60         write(sock, msg.c_str(), msg.size());                                                                              \n 61 \n 62         ssize_t s = read(sock, buffer, sizeof(buffer)-1);\n 63         if(s &gt; 0){\n 64           buffer[s] = 0;\n 65         }\n 66         std::cout &lt;&lt; \"server echo# \" &lt;&lt; buffer &lt;&lt; std::endl;\n 67       }\n 68     }\n 69 \n 70     ~TcpClient()\n 71     {\n 72       if(sock &gt;= 0){\n 73         close(sock);\n 74       }\n 75     }\n 76 };</code></pre>\n<h3><strong><span style=\"color:#ad720d;\">tcp_client.cc</span></strong></h3>\n<pre><code class=\"language-cpp\">  1 #include \"tcp_client.hpp\"\n  2 \n  3 \n  4 int main(int argc, char* argv[])\n  5 {\n  6   if(argc != 3){\n  7     std::cout &lt;&lt; \"Usage: \" &lt;&lt; argv[0] &lt;&lt; \"ip port\" &lt;&lt; std::endl;\n  8     exit(1);\n  9   }\n 10 \n 11   TcpClient tclt(argv[1], atoi(argv[2]));                                                                                  \n 12   tclt.InitTcpClient();\n 13 \n 14   tclt.Loop();\n 15 \n 16   return 0;\n 17 }\n</code></pre>\n<p><strong><img alt=\"\" height=\"616\" src=\"..\\..\\static\\image\\547aee4aeab44b31b0f2174b69bc8537.png\" width=\"1038\"/></strong></p>\n<p><strong>        这里其实只在 tcp_server.hpp 中添加了这个，这里的文字很重要，大家根据步骤看看，应该是可以看懂的，写的解析很全面。</strong></p>\n<p><strong>        这里的理解非常重要，但是我要说的是，其实这里实际写不用这么复杂，因为这只是一个很好玩的方法，但是有比这个简单很多很多的，就是直接：</strong></p>\n<p><strong><img alt=\"\" height=\"109\" src=\"..\\..\\static\\image\\3dec57a501db4d5892fe770091af07c9.png\" width=\"676\"/></strong></p>\n<p><strong>        因为上面写那么多的目的就是为了让子进程单独去完成任务，这样写直接就不用等子进程了，所以这个是最推荐，或者说是最好的~！</strong></p>\n<p><strong><img alt=\"\" height=\"791\" src=\"..\\..\\static\\image\\714a11b6173c4f86b421473800b98333.png\" width=\"1200\"/></strong></p>\n<p><strong>        首先我们通过右边的监视脚本看到从一个进程到三个进程，然后随着退出从三个进程到一个进程。</strong></p>\n<p><strong>        而且我们连接服务器的时候它的文件描述符都是 4 ，这是因为我们是一个一个连的，连玩之后爷爷进程就会关闭 sock 文件描述符，所以就一直是 4 ，但是如果一次性来多个客户端，可能会出现 4、5、6......。</strong></p>\n<p><strong>        而且我们也可以看到我们两个进程是直接都连上了客户端，而且服务器端都会给客户端提供 服务。</strong></p>\n<h2 id=\"4.4%C2%A0TCP%20%E5%A4%9A%E7%BA%BF%E7%A8%8B\"><strong><span style=\"color:#9c8ec1;\">4.4 TCP 多线程</span></strong></h2>\n<h3><strong><span style=\"color:#ad720d;\">tcp_server.hpp</span></strong></h3>\n<pre><code class=\"language-cpp\">  1 #pragma once \n  2 \n  3 #include &lt;iostream&gt;\n  4 #include &lt;string&gt;\n  5 #include &lt;cstring&gt;\n  6 #include &lt;sys/socket.h&gt;\n  7 #include &lt;sys/types.h&gt;\n  8 #include &lt;arpa/inet.h&gt;\n  9 #include &lt;unistd.h&gt;\n 10 #include &lt;signal.h&gt;\n 11 #include &lt;sys/wait.h&gt;\n 12 #define  BACKLOG 5\n 13 \n 14 class TcpServer{\n 15   private:\n 16     short port;\n 17     int listen_sock;\n 18   public:\n 19     TcpServer(short _port)\n 20       :port(_port)\n 21        ,listen_sock(-1)\n 22   {}\n 23     bool InitTcpServer()\n 24     {\n 25       listen_sock = socket(AF_INET, SOCK_STREAM, 0);\n 26       if(listen_sock &lt; 0){\n 27         std::cerr &lt;&lt; \"socket error\" &lt;&lt; std::endl;\n 28         return false;\n 29       }                                                                                                                                                                      \n 30 \n 31       struct sockaddr_in local;\n 32       //bzero(&amp;local, sizeof(local));\n 33       memset(&amp;local, 0, sizeof(local));\n 34       local.sin_family = AF_INET;\n 35       local.sin_port = htons(port);\n 36       local.sin_addr.s_addr = INADDR_ANY;\n 37 \n 38       if(bind(listen_sock, (struct sockaddr*)&amp;local, sizeof(local)) &lt; 0){\n 39         std::cerr &lt;&lt; \"bind error\" &lt;&lt; std::endl;                                                                                                                              \n 40         return false;\n 41       }\n 42       \n 43       if(listen(listen_sock, BACKLOG) &lt; 0){\n 44         std::cerr &lt;&lt; \"listen error\" &lt;&lt;std::endl;\n 45         return false;\n 46       }\n 47       std::cout &lt;&lt; \"listen success\" &lt;&lt; std::endl;\n 48       return true;\n 49     }\n 50     void Loop()\n 51     {\n 52       //这样写父进程就不用等子进程了，很推荐，因为很简单\n 53       //signal(SIGCHLD, SIG_IGN);\n 54       for(;;)\n 55       {\n 56         //先获取链接\n 57         struct sockaddr_in peer;\n 58         socklen_t len = sizeof(peer);\n 59         int sock = accept(listen_sock, (struct sockaddr*)&amp;peer, &amp;len);\n 60         //这里是accept失败\n 61         if(sock &lt; 0){\n 62           std::cerr &lt;&lt; \"accept error\" &lt;&lt; std::endl;\n 63           continue;\n 64         }\n 65         \n 66 \n 67         pid_t id = fork();\n 68         if(id == 0){\n 69           //创建出来孙子进程是为了土共服务的\n 70           //所以不用关心 listen_sock了\n 71           close(listen_sock);//这里不是必要的\n 72           if(fork() &gt; 0){                                                                                                                                                    \n 73             exit(0);\n 74           }\n 75           //孙子进程\n 76           //这样做的原因是父进程退出，子进程被系统领养成为孤儿进程\n 77           std::string ip = inet_ntoa(peer.sin_addr);\n 78           int port = ntohs(peer.sin_port);\n 79           std::cout &lt;&lt; \"get a new link:\"&lt;&lt; sock &lt;&lt;\"[\" &lt;&lt; ip &lt;&lt; \"]\" &lt;&lt; port &lt;&lt; std::endl;\n 80           Service(sock, ip, port);//处理\n 81           exit(0);\n 82         }\n 83 \n 84         //这里关掉sock不会影响孙子进程的使用\n 85         //因为就相当于爷爷进程将指向sock这个文件描述符关掉\n 86         close(sock);//这里是必要的\n 87         //这里还是要等的，因为父进程退出，爷爷进程是要等父进程的\n 88         //但是这里就不算是挂起了，因为父进程是直接就退出，爷爷进程直接回收\n 89         waitpid(id, nullptr, 0);//这里的id就是父进程的id，当然这里也可以写成-1\n 90       }\n 91 \n 92     }\n 93 \n 94     void Service(int sock, std::string&amp; ip, short port)\n 95     {\n 96       char buffer[1024];\n 97       while(true){\n 98         ssize_t size = read(sock, buffer, sizeof(buffer)-1);\n 99         if(size &gt; 0){\n100           buffer[size] = 0;\n101           std::cout &lt;&lt; ip &lt;&lt; \":\" &lt;&lt; port &lt;&lt; \"# \" &lt;&lt; buffer &lt;&lt; std::endl;\n102           //回显\n103           write(sock, buffer, size);\n104         }\n105         else if (size == 0){                                                                                                                                                 \n106           std::cout &lt;&lt; ip &lt;&lt; \":\" &lt;&lt; port &lt;&lt; \"close!\" &lt;&lt; buffer &lt;&lt; std::endl;\n107           break;\n108         }\n109         else{\n110           std::cerr &lt;&lt; port &lt;&lt; \"read error\" &lt;&lt; std::endl;\n111           break;\n112         }\n113       }\n114       \n115       close(sock);\n116       std::cout &lt;&lt; \"Service done!\" &lt;&lt; std::endl;\n117     }\n118 \n119     ~TcpServer()\n120     {\n121       if(listen_sock &gt;= 0){\n122         close(listen_sock);\n123       }\n124     }\n125 };</code></pre>\n<h3><strong><span style=\"color:#ad720d;\">tcp_server.cc</span></strong></h3>\n<pre><code class=\"language-cpp\">  1 #include \"tcp_server.hpp\"\n  2 \n  3 int main(int argc, char* argv[])\n  4 {\n  5   if(argc != 2){\n  6     std::cout &lt;&lt; \"Usage: \" &lt;&lt; argv[0] &lt;&lt; \"port\" &lt;&lt; std::endl;\n  7     exit(1);\n  8   }\n  9   TcpServer tsvr(atoi(argv[1]));                                                                                                                                             \n 10   tsvr.InitTcpServer();\n 11 \n 12   tsvr.Loop();\n 13 \n 14 \n 15   return 0;\n 16 }\n</code></pre>\n<h3><strong><span style=\"color:#ad720d;\">tcp_client.hpp</span></strong></h3>\n<pre><code class=\"language-cpp\">  1 #pragma once \n  2 \n  3 #include &lt;iostream&gt;\n  4 #include &lt;string&gt;\n  5 #include &lt;cstring&gt;\n  6 #include &lt;sys/socket.h&gt;\n  7 #include &lt;sys/types.h&gt;\n  8 #include &lt;arpa/inet.h&gt;\n  9 #include &lt;unistd.h&gt;\n 10 #include &lt;signal.h&gt;\n 11 #include &lt;sys/wait.h&gt;\n 12 #include &lt;pthread.h&gt;\n 13 \n 14 \n 15 #define  BACKLOG 5\n 16 \n 17 class Prama{\n 18   public:\n 19     int sock;\n 20     std::string ip;\n 21     short port;\n 22 \n 23     Prama(int _sock, std::string _ip, short _port)                                                                                                     \n 24       :sock(_sock)\n 25        ,ip(_ip)\n 26        ,port(_port)\n 27   {}\n 28     ~Prama()\n 29     {}\n 30 };\n 31 \n 32 \n 33 class TcpServer{                                                                                                                                       \n 34   private:\n 35     short port;\n 36     int listen_sock;\n 37   public:\n 38     TcpServer(short _port)\n 39       :port(_port)\n 40        ,listen_sock(-1)\n 41   {}\n 42     bool InitTcpServer()\n 43     {\n 44       listen_sock = socket(AF_INET, SOCK_STREAM, 0);\n 45       if(listen_sock &lt; 0){\n 46         std::cerr &lt;&lt; \"socket error\" &lt;&lt; std::endl;\n 47         return false;\n 48       }\n 49 \n 50       struct sockaddr_in local;\n 51       //bzero(&amp;local, sizeof(local));\n 52       memset(&amp;local, 0, sizeof(local));\n 53       local.sin_family = AF_INET;\n 54       local.sin_port = htons(port);\n 55       local.sin_addr.s_addr = INADDR_ANY;\n 56 \n 57       if(bind(listen_sock, (struct sockaddr*)&amp;local, sizeof(local)) &lt; 0){\n 58         std::cerr &lt;&lt; \"bind error\" &lt;&lt; std::endl;\n 59         return false;\n 60       }\n 61       \n 62       if(listen(listen_sock, BACKLOG) &lt; 0){\n 63         std::cerr &lt;&lt; \"listen error\" &lt;&lt;std::endl;                                                                                                       \n 64         return false;\n 65       }\n 66       std::cout &lt;&lt; \"listen success\" &lt;&lt; std::endl;\n 67       return true;\n 68     }\n 69 \n 70     static void* HanderRequest(void* arg)\n 71     {\n 72       Prama* p = (Prama*)arg;\n 73 \n 74       //这里要分离，不分离也不等的话，会出现像僵尸进程一样的东西\n 75       pthread_detach(pthread_self());\n 76 \n 77       Service(p-&gt;sock, p-&gt;ip, p-&gt;port);\n 78 \n 79       close(p-&gt;sock);\n 80       delete p;\n 81       return nullptr;\n 82     }\n 83     void Loop()\n 84     {\n 85       //这样写父进程就不用等子进程了，很推荐，因为很简单\n 86       //signal(SIGCHLD, SIG_IGN);\n 87       struct sockaddr_in peer;\n 88       for(;;)\n 89       {\n 90         //先获取链接\n 91         socklen_t len = sizeof(peer);\n 92         int sock = accept(listen_sock, (struct sockaddr*)&amp;peer, &amp;len);\n 93         //这里是accept失败\n 94         if(sock &lt; 0){\n 95           std::cerr &lt;&lt; \"accept error\" &lt;&lt; std::endl;\n 96           continue;                                                                                                                                    \n 97         }\n 98         \n 99         pthread_t tid;\n100         std::string ip = inet_ntoa(peer.sin_addr);\n101         short port = ntohs(peer.sin_port);\n102         //这里因为可能会出现并发的问题，也就是sock的结果可能会出现问题\n103         //所以我们这里有一种方法可以new一个p，这样p就肯定是属于特定一个线程了\n104         Prama* p = new Prama(sock, ip, port);\n105         pthread_create(&amp;tid, nullptr, HanderRequest, p);\n106 \n107 \n108       }\n109 \n110     }\n111 \n112     //这里我们将 sock ip port 都传进来了，所以这里我们可以设成static\n113     //也为了让HanderRequete调用\n114     static void Service(int sock, std::string&amp; ip, short port)                                                                                         \n115     {\n116       char buffer[1024];\n117       while(true){\n118         ssize_t size = read(sock, buffer, sizeof(buffer)-1);\n119         if(size &gt; 0){\n120           buffer[size] = 0;\n121           std::cout &lt;&lt; ip &lt;&lt; \":\" &lt;&lt; port &lt;&lt; \"# \" &lt;&lt; buffer &lt;&lt; std::endl;\n122           //回显\n123           write(sock, buffer, size);\n124         }\n125         else if (size == 0){\n126           std::cout &lt;&lt; ip &lt;&lt; \":\" &lt;&lt; port &lt;&lt; \"close!\" &lt;&lt; buffer &lt;&lt; std::endl;\n127           break;\n128         }\n129         else{\n130           std::cerr &lt;&lt; port &lt;&lt; \"read error\" &lt;&lt; std::endl;\n131           break;\n132         }\n133       }\n134       \n135       std::cout &lt;&lt; \"Service done!\" &lt;&lt; std::endl;\n136     }\n137 \n138     ~TcpServer()\n139     {\n140       if(listen_sock &gt;= 0){\n141         close(listen_sock);\n142       }\n143     }\n144 };</code></pre>\n<h3 id=\"%C2%A0tcp_client.cc\"><strong><span style=\"color:#ad720d;\"> tcp_client.cc</span></strong></h3>\n<pre><code class=\"language-cpp\">  1 #include \"tcp_client.hpp\"\n  2 \n  3 \n  4 int main(int argc, char* argv[])\n  5 {\n  6   if(argc != 3){\n  7     std::cout &lt;&lt; \"Usage: \" &lt;&lt; argv[0] &lt;&lt; \"ip port\" &lt;&lt; std::endl;\n  8     exit(1);\n  9   }\n 10 \n 11   TcpClient tclt(argv[1], atoi(argv[2]));                                                                                  \n 12   tclt.InitTcpClient();\n 13 \n 14   tclt.Loop();\n 15 \n 16   return 0;\n 17 }\n</code></pre>\n<p><strong>        当然这里也是只对 tcp_server.hpp 做了处理，具体的情况，大家去看代码的不同吧，大致就是创建线程，然后让线程分离再让线程执行服务的操作，然后其中的服务也改成了 static，为了让 static 的 Hander 可以调用，又因为 Hander 里要用到 sock、ip、port ，所以设计了一个类进行保存，然后传给 Hander。</strong></p>\n<p><strong><img alt=\"\" height=\"813\" src=\"..\\..\\static\\image\\3bacd6f9d1da4842b7e439abb3286c87.png\" width=\"1200\"/></strong></p>\n<p><strong>        我们可以看到，和多进程相比，除了细节上的不同，效果上大致是相同的，那么这里我也就不过多赘述了。</strong></p>\n<h2 id=\"4.5%C2%A0TCP%20%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%89%88%E6%9C%AC)\"><strong><span style=\"color:#9c8ec1;\">4.5 TCP 多线程(线程池版本)</span></strong></h2>\n<p><strong>        上面多线程是到用的时候，去创建新线程，没有什么问题，就是效率很低。</strong></p>\n<p><strong>        好的做法是，已经都有线程了，有人需要服务，那么直接使用线程就好。</strong></p>\n<p><strong>        还有一点是，如果线程多了，线程之间的相互切换的频率也就会高，也就是成本很高，导致效率非常低。比方说第一个线程执行了一点被切走了，直到执行到了第一千个线程才切换回来，因为线程代表的是用户，在用户看来就是你的服务提供的有问题。</strong></p>\n<p><strong>        所以我们这里应该设置好线程的个数，如果申请的人多，那么就让用户排队，最起码让正在接收服务的人得到好的服务。</strong></p>\n<p><strong>        所以这个方案就是基于多线程的线程池方案。</strong></p>\n<h3 id=\"ThreadPool.hpp\"><strong><span style=\"color:#ad720d;\">ThreadPool.hpp</span></strong></h3>\n<pre><code class=\"language-cpp\">  1 #pragma once\n  2 \n  3 #include &lt;iostream&gt;\n  4 #include &lt;queue&gt;\n  5 #include &lt;pthread.h&gt;\n  6 \n  7 #define NUM 5\n  8 \n  9 template&lt;typename T&gt;\n 10 class ThreadPool{\n 11 private:\n 12   int thread_num;\n 13   std::queue&lt;T&gt; task_queue;\n 14   pthread_mutex_t lock;\n 15   pthread_cond_t cond;\n 16 \n 17 public:\n 18   ThreadPool(int _num = NUM)\n 19     :thread_num(_num)\n 20   {\n 21     pthread_mutex_init(&amp;lock, nullptr);\n 22     pthread_cond_init(&amp;cond, nullptr);\n 23   }\n 24 \n 25   //因为static不能直接访问private\n 26   //所以要对其进行封装\n 27   void LockQueue()\n 28   {\n 29     pthread_mutex_lock(&amp;lock);                                                                                                                                                       \n 30   }\n 31   void UnlockQueue()\n 32   {\n 33     pthread_mutex_unlock(&amp;lock);\n 34   }\n 35   bool IsEmpty()\n 36   {\n 37     return task_queue.empty();\n 38   }\n 39   void Wait()\n 40   {\n 41     pthread_cond_wait(&amp;cond, &amp;lock);\n 42   }\n 43   void Wakeup()\n 44   {\n 45     pthread_cond_signal(&amp;cond);\n 46   }\n 47   // 这里要用static是因为在类里写成员函数时会带上\n 48   // this指针，但是这个参数只能传一个void*类型的参数                                                                                                                                 \n 49   static void* Routine(void* arg)\n 50   {\n 51     pthread_detach(pthread_self());\n 52     ThreadPool* self = (ThreadPool*)arg;\n 53     while(true){\n 54       self-&gt;LockQueue();\n 55       while(self-&gt;IsEmpty()){\n 56         //wait\n 57         self-&gt;Wait();\n 58       }\n 59       //任务\n 60      T t;\n 61      self-&gt;Pop(t);\n 62      self-&gt;UnlockQueue();\n 63      //因为执行任务的时候，这个任务属于你当前线程\n 64      //所以接下来只需要在Unlock之后处理就可以了\n 65      //如果在里面处理，那其它线程要等你处理完才可以处理下一个\n 66      //如果这样，虽然是线程池，那也没有让多个线程同时跑起来\n 67      t.Run();\n 68     }\n 69   }\n 70   void InitThreadPool()\n 71   {\n 72     pthread_t tid;\n 73     for(int i = 0; i &lt; thread_num; i++){\n 74       pthread_create(&amp;tid, nullptr, Routine, this);//所以这里要传this\n 75     }                                                                                                                                                                                \n 76   }\n 77 \n 78   void Push(const T&amp; in)\n 79   {\n 80     LockQueue();\n 81     task_queue.push(in);\n 82     UnlockQueue();\n 83     //插入数据后其它线程的不知道\n 84     //所以要唤醒其它线程\n 85     Wakeup();\n 86   }\n 87 \n 88   void Pop(T&amp; out)\n 89   {\n 90     out = task_queue.front();\n 91     task_queue.pop();\n 92   }\n 93 \n 94   ~ThreadPool()\n 95   {\n 96     pthread_mutex_destroy(&amp;lock);\n 97     pthread_cond_destroy(&amp;cond);\n 98   }\n 99 };</code></pre>\n<h3 id=\"Task.hpp\"><strong><span style=\"color:#ad720d;\">Task.hpp</span></strong></h3>\n<pre><code class=\"language-cpp\">  1 #pragma once\n  2 \n  3 #include &lt;iostream&gt;\n  4 #include &lt;string&gt;\n  5 #include &lt;unistd.h&gt;\n  6 \n  7 class Handler{\n  8   public:\n  9     Handler(){}\n 10 \n 11     void operator()(int sock, std::string ip, short port)\n 12     {\n 13       char buffer[1024];\n 14       while(true){\n 15         ssize_t size = read(sock, buffer, sizeof(buffer)-1);\n 16         if(size &gt; 0){\n 17           buffer[size] = 0;\n 18           std::cout &lt;&lt; ip &lt;&lt; \":\" &lt;&lt; port &lt;&lt; \"# \" &lt;&lt; buffer &lt;&lt; std::endl;\n 19           //回显\n 20           write(sock, buffer, size);\n 21         }\n 22         else if (size == 0){\n 23           std::cout &lt;&lt; ip &lt;&lt; \":\" &lt;&lt; port &lt;&lt; \"close!\" &lt;&lt; buffer &lt;&lt; std::endl;\n 24           break;\n 25         }\n 26         else{\n 27           std::cerr &lt;&lt; port &lt;&lt; \"read error\" &lt;&lt; std::endl;\n 28           break;\n 29         }                                                                                                                                                                            \n 30       }\n 31 \n 32       std::cout &lt;&lt; \"Service done!\" &lt;&lt; std::endl;\n 33       close(sock);\n 34     }\n 35 \n 36     ~Handler(){}\n 37 };\n 38 \n 39                                                                                                                                                                                      \n 40 class Task{\n 41   private:\n 42     int sock;\n 43     std::string ip;\n 44     short port;\n 45     Handler handler;\n 46   public:\n 47     Task(){}\n 48     Task(int _sock, std::string _ip, short _port)\n 49       :sock(_sock)\n 50        ,ip(_ip)\n 51        ,port(_port)\n 52     {}\n 53 \n 54 \n 55     void Run()\n 56     {\n 57       handler(sock, ip, port);\n 58     }\n 59 \n 60     ~Task()\n 61     {}\n 62 };</code></pre>\n<h3><strong><span style=\"color:#ad720d;\">tcp_server.hpp</span></strong></h3>\n<pre><code class=\"language-cpp\">  1 #pragma once \n  2 \n  3 #include &lt;iostream&gt;\n  4 #include &lt;string&gt;\n  5 #include &lt;cstring&gt;\n  6 #include &lt;sys/socket.h&gt;\n  7 #include &lt;sys/types.h&gt;\n  8 #include &lt;arpa/inet.h&gt;\n  9 #include &lt;unistd.h&gt;\n 10 #include &lt;signal.h&gt;\n 11 #include &lt;sys/wait.h&gt;\n 12 #include &lt;pthread.h&gt;\n 13 #include \"ThreadPool.hpp\"\n 14 #include \"Task.hpp\"\n 15 \n 16 #define  BACKLOG 5\n 17 \n 18 class Prama{\n 19   public:\n 20     int sock;\n 21     std::string ip;\n 22     short port;\n 23 \n 24     Prama(int _sock, std::string _ip, short _port)\n 25       :sock(_sock)\n 26        ,ip(_ip)\n 27        ,port(_port)\n 28   {}\n 29     ~Prama()                                                                                                                                                                         \n 30     {}\n 31 };\n 32 \n 33 \n 34 class TcpServer{\n 35   private:\n 36     short port;\n 37     int listen_sock;\n 38     ThreadPool&lt;Task&gt;* tp;\n 39   public:                                                                                                                                                                            \n 40     TcpServer(short _port)\n 41       :port(_port)\n 42        ,listen_sock(-1)\n 43        ,tp(nullptr)\n 44   {}\n 45     bool InitTcpServer()\n 46     {\n 47       listen_sock = socket(AF_INET, SOCK_STREAM, 0);\n 48       if(listen_sock &lt; 0){\n 49         std::cerr &lt;&lt; \"socket error\" &lt;&lt; std::endl;\n 50         return false;\n 51       }\n 52 \n 53       struct sockaddr_in local;\n 54       //bzero(&amp;local, sizeof(local));\n 55       memset(&amp;local, 0, sizeof(local));\n 56       local.sin_family = AF_INET;\n 57       local.sin_port = htons(port);\n 58       local.sin_addr.s_addr = INADDR_ANY;\n 59 \n 60       if(bind(listen_sock, (struct sockaddr*)&amp;local, sizeof(local)) &lt; 0){\n 61         std::cerr &lt;&lt; \"bind error\" &lt;&lt; std::endl;\n 62         return false;\n 63       }\n 64       \n 65       if(listen(listen_sock, BACKLOG) &lt; 0){\n 66         std::cerr &lt;&lt; \"listen error\" &lt;&lt;std::endl;\n 67         return false;\n 68       }\n 69 \n 70       tp = new ThreadPool&lt;Task&gt;();\n 71 \n 72       std::cout &lt;&lt; \"listen success\" &lt;&lt; std::endl;\n 73       return true;\n 74     }\n 75 \n 76     void Loop()\n 77     {\n 78       //这样写父进程就不用等子进程了，很推荐，因为很简单                                                                                                                             \n 79       //signal(SIGCHLD, SIG_IGN);\n 80       tp-&gt;InitThreadPool();\n 81       struct sockaddr_in peer;\n 82       for(;;)\n 83       {\n 84         //先获取链接\n 85         socklen_t len = sizeof(peer);\n 86         int sock = accept(listen_sock, (struct sockaddr*)&amp;peer, &amp;len);\n 87         //这里是accept失败\n 88         if(sock &lt; 0){\n 89           std::cerr &lt;&lt; \"accept error\" &lt;&lt; std::endl;\n 90           continue;\n 91         }\n 92 \n 93         std::string ip = inet_ntoa(peer.sin_addr);\n 94         short port = ntohs(peer.sin_port);\n 95         \n 96         Task t(sock, ip, port);\n 97 \n 98         tp-&gt;Push(t);\n 99 \n100       }\n101     }\n102 \n103     ~TcpServer()\n104     {\n105       if(listen_sock &gt;= 0){\n106         close(listen_sock);\n107       }\n108     }\n109 };</code></pre>\n<h3><strong><span style=\"color:#ad720d;\">tcp_server.cc</span></strong></h3>\n<pre><code class=\"language-cpp\">  1 #include \"tcp_server.hpp\"\n  2 \n  3 int main(int argc, char* argv[])\n  4 {\n  5   if(argc != 2){\n  6     std::cout &lt;&lt; \"Usage: \" &lt;&lt; argv[0] &lt;&lt; \"port\" &lt;&lt; std::endl;\n  7     exit(1);\n  8   }\n  9   TcpServer tsvr(atoi(argv[1]));                                                                                                                                             \n 10   tsvr.InitTcpServer();\n 11 \n 12   tsvr.Loop();\n 13 \n 14 \n 15   return 0;\n 16 }\n</code></pre>\n<h3><strong><span style=\"color:#ad720d;\">tcp_client.hpp</span></strong></h3>\n<pre><code class=\"language-cpp\">  1 #pragma once \n  2 \n  3 #include &lt;iostream&gt;\n  4 #include &lt;string&gt;\n  5 #include &lt;cstring&gt;\n  6 #include &lt;sys/socket.h&gt;\n  7 #include &lt;sys/types.h&gt;\n  8 #include &lt;arpa/inet.h&gt;\n  9 #include &lt;unistd.h&gt;\n 10 #include &lt;signal.h&gt;\n 11 #include &lt;sys/wait.h&gt;\n 12 #include &lt;pthread.h&gt;\n 13 \n 14 \n 15 #define  BACKLOG 5\n 16 \n 17 class Prama{\n 18   public:\n 19     int sock;\n 20     std::string ip;\n 21     short port;\n 22 \n 23     Prama(int _sock, std::string _ip, short _port)                                                                                                     \n 24       :sock(_sock)\n 25        ,ip(_ip)\n 26        ,port(_port)\n 27   {}\n 28     ~Prama()\n 29     {}\n 30 };\n 31 \n 32 \n 33 class TcpServer{                                                                                                                                       \n 34   private:\n 35     short port;\n 36     int listen_sock;\n 37   public:\n 38     TcpServer(short _port)\n 39       :port(_port)\n 40        ,listen_sock(-1)\n 41   {}\n 42     bool InitTcpServer()\n 43     {\n 44       listen_sock = socket(AF_INET, SOCK_STREAM, 0);\n 45       if(listen_sock &lt; 0){\n 46         std::cerr &lt;&lt; \"socket error\" &lt;&lt; std::endl;\n 47         return false;\n 48       }\n 49 \n 50       struct sockaddr_in local;\n 51       //bzero(&amp;local, sizeof(local));\n 52       memset(&amp;local, 0, sizeof(local));\n 53       local.sin_family = AF_INET;\n 54       local.sin_port = htons(port);\n 55       local.sin_addr.s_addr = INADDR_ANY;\n 56 \n 57       if(bind(listen_sock, (struct sockaddr*)&amp;local, sizeof(local)) &lt; 0){\n 58         std::cerr &lt;&lt; \"bind error\" &lt;&lt; std::endl;\n 59         return false;\n 60       }\n 61       \n 62       if(listen(listen_sock, BACKLOG) &lt; 0){\n 63         std::cerr &lt;&lt; \"listen error\" &lt;&lt;std::endl;                                                                                                       \n 64         return false;\n 65       }\n 66       std::cout &lt;&lt; \"listen success\" &lt;&lt; std::endl;\n 67       return true;\n 68     }\n 69 \n 70     static void* HanderRequest(void* arg)\n 71     {\n 72       Prama* p = (Prama*)arg;\n 73 \n 74       //这里要分离，不分离也不等的话，会出现像僵尸进程一样的东西\n 75       pthread_detach(pthread_self());\n 76 \n 77       Service(p-&gt;sock, p-&gt;ip, p-&gt;port);\n 78 \n 79       close(p-&gt;sock);\n 80       delete p;\n 81       return nullptr;\n 82     }\n 83     void Loop()\n 84     {\n 85       //这样写父进程就不用等子进程了，很推荐，因为很简单\n 86       //signal(SIGCHLD, SIG_IGN);\n 87       struct sockaddr_in peer;\n 88       for(;;)\n 89       {\n 90         //先获取链接\n 91         socklen_t len = sizeof(peer);\n 92         int sock = accept(listen_sock, (struct sockaddr*)&amp;peer, &amp;len);\n 93         //这里是accept失败\n 94         if(sock &lt; 0){\n 95           std::cerr &lt;&lt; \"accept error\" &lt;&lt; std::endl;\n 96           continue;                                                                                                                                    \n 97         }\n 98         \n 99         pthread_t tid;\n100         std::string ip = inet_ntoa(peer.sin_addr);\n101         short port = ntohs(peer.sin_port);\n102         //这里因为可能会出现并发的问题，也就是sock的结果可能会出现问题\n103         //所以我们这里有一种方法可以new一个p，这样p就肯定是属于特定一个线程了\n104         Prama* p = new Prama(sock, ip, port);\n105         pthread_create(&amp;tid, nullptr, HanderRequest, p);\n106 \n107 \n108       }\n109 \n110     }\n111 \n112     //这里我们将 sock ip port 都传进来了，所以这里我们可以设成static\n113     //也为了让HanderRequete调用\n114     static void Service(int sock, std::string&amp; ip, short port)                                                                                         \n115     {\n116       char buffer[1024];\n117       while(true){\n118         ssize_t size = read(sock, buffer, sizeof(buffer)-1);\n119         if(size &gt; 0){\n120           buffer[size] = 0;\n121           std::cout &lt;&lt; ip &lt;&lt; \":\" &lt;&lt; port &lt;&lt; \"# \" &lt;&lt; buffer &lt;&lt; std::endl;\n122           //回显\n123           write(sock, buffer, size);\n124         }\n125         else if (size == 0){\n126           std::cout &lt;&lt; ip &lt;&lt; \":\" &lt;&lt; port &lt;&lt; \"close!\" &lt;&lt; buffer &lt;&lt; std::endl;\n127           break;\n128         }\n129         else{\n130           std::cerr &lt;&lt; port &lt;&lt; \"read error\" &lt;&lt; std::endl;\n131           break;\n132         }\n133       }\n134       \n135       std::cout &lt;&lt; \"Service done!\" &lt;&lt; std::endl;\n136     }\n137 \n138     ~TcpServer()\n139     {\n140       if(listen_sock &gt;= 0){\n141         close(listen_sock);\n142       }\n143     }\n144 };</code></pre>\n<h3><strong><span style=\"color:#ad720d;\"> tcp_client.cc</span></strong></h3>\n<pre><code class=\"language-cpp\">  1 #include \"tcp_client.hpp\"\n  2 \n  3 \n  4 int main(int argc, char* argv[])\n  5 {\n  6   if(argc != 3){\n  7     std::cout &lt;&lt; \"Usage: \" &lt;&lt; argv[0] &lt;&lt; \"ip port\" &lt;&lt; std::endl;\n  8     exit(1);\n  9   }\n 10 \n 11   TcpClient tclt(argv[1], atoi(argv[2]));                                                                                  \n 12   tclt.InitTcpClient();\n 13 \n 14   tclt.Loop();\n 15 \n 16   return 0;\n 17 }\n</code></pre>\n<p><strong>        当然这里就有很多的细节了，我先来说整体的思路，然后具体的实现大家去对照上面的代码去看看：</strong></p>\n<p><strong>        我先说下，线程池这块我因为在多线程的时候讲过，所以这里我就不讲了，大家可以去看我多线程的博客，写的很详细，从零到尾讲的很详细，链接也给大家贴到最开始了。</strong></p>\n<p><strong>        这里就是在服务器中先初始化线程池，然后将服务器的循环里改为了线程池，然后主线程就一直将任务 Task 放到任务队列里。</strong></p>\n<p><strong>        因为在 tcp_server.hpp 中要将任务放到任务队列里，所以就将原本 tcp_server.hpp 里的让服务器和用户通信的过程放到了 Task.hpp 里，在 Task 中通过 Run 调用 handler 方法，其中应用了回调函数，这样也相当于进行了解耦，如果想更改任务直接更改 handler 方法中的方式就可以了。</strong></p>\n<p><strong>        这就是大体的思路，具体的细节大家去看看代码，自己动手去写写吧，接下来给大家展示效果。</strong></p>\n<p><strong><img alt=\"\" height=\"813\" src=\"..\\..\\static\\image\\7ce4132adcff45639f7959f39e3a9c40.png\" width=\"1200\"/></strong></p>\n<p><strong>        我们可以看到，从开始到最后，不管有几个客户端向服务器端申请，都只有特定的线程数个，当然这里我默认设置成的 5 个，这个可以自己设置。</strong></p>\n<h1 id=\"5.%20%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9\"><strong><span style=\"color:#faa572;\">5. 零碎知识点</span></strong></h1>\n<h2 id=\"5.1%C2%A0%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0\"><strong><span style=\"color:#9c8ec1;\">5.1 地址转换函数</span></strong></h2>\n<p><strong>        本节只介绍基于IPv4的socket网络编程，sockaddr_in中的成员struct in_addr sin_addr表示32位的IP地址，但是我们通常用点分十进制的字符串表示IP地址，以下函数可以在字符串表示和in_addr表示之间转换。</strong></p>\n<p><strong>字符串转in_addr的函数：</strong></p>\n<p><strong><img alt=\"\" height=\"187\" src=\"..\\..\\static\\image\\92988d6e9b934286bd2249be216ffaf3.png\" width=\"1170\"/></strong></p>\n<p><strong> in_addr转字符串的函数：</strong></p>\n<p><strong><img alt=\"\" height=\"121\" src=\"..\\..\\static\\image\\5c0fa80678ba4765be3c297269de0336.png\" width=\"1165\"/></strong></p>\n<p><strong>        其中inet_pton和inet_ntop不仅可以转换IPv4的in_addr，还可以转换IPv6的in6_addr，因此函数接口是void *addrptr。</strong></p>\n<p><strong>代码示例：</strong></p>\n<p><strong><img alt=\"\" height=\"309\" src=\"..\\..\\static\\image\\4a2d619370bc496da39394e21310bff4.png\" width=\"616\"/></strong></p>\n<h2 id=\"5.2%C2%A0%E5%85%B3%E4%BA%8Einet_ntoa\"><strong><span style=\"color:#9c8ec1;\">5.2 关于inet_ntoa</span></strong></h2>\n<p><strong>        inet_ntoa这个函数返回了一个char*，很显然是这个函数自己在内部为我们申请了一块内存来保存ip的结果。那么是否需要调用者手动释放呢?</strong></p>\n<p><strong><img alt=\"\" height=\"80\" src=\"..\\..\\static\\image\\168318011f0d445db0a406cb1eb05b6a.png\" width=\"1129\"/></strong></p>\n<p><strong>        man手册上说，inet_ntoa函数，是把这个返回结果放到了静态存储区。这个时候不需要我们手动进行释放。</strong></p>\n<p><strong>        那么问题来了，如果我们调用多次这个函数，会有什么样的效果呢? </strong></p>\n<p><strong>参见如下代码：</strong></p>\n<p><strong><img alt=\"\" height=\"341\" src=\"..\\..\\static\\image\\7bf96a44f2134c37b3c4762ef7888c34.png\" width=\"572\"/></strong></p>\n<p><strong>运行结果如下：</strong></p>\n<p><strong><img alt=\"\" height=\"45\" src=\"..\\..\\static\\image\\fdaa2c61803741bd9adbc843b72f7c01.png\" width=\"482\"/></strong></p>\n<p><strong>        因为inet_ntoa把结果放到自己内部的一个静态存储区，这样第二次调用时的结果会覆盖掉上一次的结果。</strong></p>\n<blockquote>\n<ul><li><strong>在APUE中，明确提出inet_ntoa不是线程安全的函数。</strong></li><li><strong>但是在centos7上测试，并没有出现问题，可能内部的实现加了互斥锁。</strong></li><li><strong>在多线程环境下，推荐使用inet_ntop，这个函数由调用者提供一个缓冲区保存结果，可以规避线程安全问题。</strong></li></ul>\n</blockquote>\n<p><img alt=\"\" height=\"1200\" src=\"..\\..\\static\\image\\282497adef754cc38ca327bf3aa9438a.jpeg\" width=\"1200\"/></p>\n<p> <strong>        如上就是 <span style=\"color:#fe2c24;\"><span style=\"background-color:#9c8ec1;\">网络编程套接字</span></span> 的所有知识，如果大家喜欢看此文章并且有收获，可以支持下 <span style=\"color:#ff9900;\">兔7</span> ，给 <span style=\"color:#ff9900;\">兔7</span> 三连加关注，你的关注是对我最大的鼓励，也是我的创作动力~！</strong></p>\n<p><strong>        再次感谢大家观看，感谢大家支持！</strong></p>\n</div>\n</div>", "first_tag": "C++", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-09-07 08:34:42", "summary": "大家好，我是兔，一位努力学习的博主如果文章知识点有错误的地方，请指正！和大家一起学习，一起进步如有不懂，可以随时向我提问，我会全力讲解如果感觉博主的文章还不错的话，希望大家关注、点赞、收藏三连支持一下"}