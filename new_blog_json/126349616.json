{"blogid": "126349616", "writerAge": "ç é¾„144å¤©", "writerBlogNum": "46", "writerCollect": "439", "writerComment": "943", "writerFan": "1756", "writerGrade": "5çº§", "writerIntegral": "2290", "writerName": "å…”7", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126349616.jpg", "writerRankTotal": "8995", "writerRankWeekly": "1616", "writerThumb": "657", "writerVisitNum": "13970", "blog_read_count": "112", "blog_time": "äºÂ 2022-09-07 08:34:42Â å‘å¸ƒ", "blog_title": "ç½‘ç»œç¼–ç¨‹å¥—æ¥å­—-----å®ç°ç½‘ç»œé—´é€šä¿¡", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p style=\"text-align:center;\"><strong><img alt=\"\" height=\"90\" src=\"https://img-blog.csdnimg.cn/b6f20f614157431ba83ad9378ab10a32.gif\" width=\"714\"/></strong></p>\n<p><strong><img alt=\"\" height=\"747\" src=\"..\\..\\static\\image\\af03afb19d1a401cb431bb52b1b046d1.png\" width=\"1200\"/></strong></p>\n<blockquote>\n<p><strong>ê§ å¤§å®¶å¥½ï¼Œæˆ‘æ˜¯ <span style=\"color:#ff9900;\">å…”7</span> ï¼Œä¸€ä½åŠªåŠ›å­¦ä¹ C++çš„åšä¸»~ ê§‚</strong></p>\n<p><strong>â˜™ å¦‚æœæ–‡ç« çŸ¥è¯†ç‚¹æœ‰é”™è¯¯çš„åœ°æ–¹ï¼Œè¯·æŒ‡æ­£ï¼å’Œå¤§å®¶ä¸€èµ·å­¦ä¹ ï¼Œä¸€èµ·è¿›æ­¥â§</strong></p>\n<p><strong>ğŸš€ å¦‚æœ‰ä¸æ‡‚ï¼Œå¯ä»¥éšæ—¶å‘æˆ‘æé—®ï¼Œæˆ‘ä¼šå…¨åŠ›è®²è§£~ğŸ’¬</strong></p>\n<p><strong>ğŸ”¥ å¦‚æœæ„Ÿè§‰åšä¸»çš„æ–‡ç« è¿˜ä¸é”™çš„è¯ï¼Œ<u>å¸Œæœ›å¤§å®¶å…³æ³¨ã€ç‚¹èµã€æ”¶è—ä¸‰è¿æ”¯æŒä¸€ä¸‹åšä¸»å“¦</u>~ï¼ğŸ‘€</strong></p>\n<p><strong>ğŸ”¥ ä½ ä»¬çš„æ”¯æŒæ˜¯æˆ‘åˆ›ä½œçš„åŠ¨åŠ›ï¼â›…</strong></p>\n<p id=\"2.2%E5%9B%BE%E8%A7%A3\"><strong>ğŸ§¸<span style=\"color:#fe2c24;\"> æˆ‘ç›¸ä¿¡ç°åœ¨çš„åŠªåŠ›çš„è‰°è¾›ï¼Œéƒ½æ˜¯ä¸ºä»¥åçš„ç¾å¥½æœ€å¥½çš„è§è¯ï¼â­</span></strong></p>\n<p><strong><span style=\"color:#fe2c24;\">ğŸ§¸ äººçš„å¿ƒæ€å†³å®šå§¿æ€ï¼â­</span></strong></p>\n<p><strong>ğŸš€ æœ¬æ–‡ç« CSDNé¦–å‘ï¼âœ</strong></p>\n</blockquote>\n<p id=\"main-toc\"><strong>ç›®å½•</strong></p>\n<p id=\"0.%20%E5%89%8D%E8%A8%80-toc\" style=\"margin-left:0px;\"><strong><a href=\"#0.%20%E5%89%8D%E8%A8%80\">0. å‰è¨€</a></strong></p>\n<p id=\"1.%20%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-toc\" style=\"margin-left:0px;\"><strong><a href=\"#1.%20%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86\">1. é¢„å¤‡çŸ¥è¯†</a></strong></p>\n<p id=\"1.%201%20%E7%90%86%E8%A7%A3%E6%BA%90IP%E5%9C%B0%E5%9D%80%E5%92%8C%E7%9B%AE%E7%9A%84IP%E5%9C%B0%E5%9D%80-toc\" style=\"margin-left:40px;\"><strong><a href=\"#1.%201%20%E7%90%86%E8%A7%A3%E6%BA%90IP%E5%9C%B0%E5%9D%80%E5%92%8C%E7%9B%AE%E7%9A%84IP%E5%9C%B0%E5%9D%80\">1. 1 ç†è§£æºIPåœ°å€å’Œç›®çš„IPåœ°å€</a></strong></p>\n<p id=\"1.2%20%E8%AE%A4%E8%AF%86%E7%AB%AF%E5%8F%A3%E5%8F%B7-toc\" style=\"margin-left:40px;\"><strong><a href=\"#1.2%20%E8%AE%A4%E8%AF%86%E7%AB%AF%E5%8F%A3%E5%8F%B7\">1.2 è®¤è¯†ç«¯å£å·</a></strong></p>\n<p id=\"1.3%C2%A0%E7%90%86%E8%A7%A3%20%22%E7%AB%AF%E5%8F%A3%E5%8F%B7%22%20%E5%92%8C%20%22%E8%BF%9B%E7%A8%8BID%22-toc\" style=\"margin-left:40px;\"><strong><a href=\"#1.3%C2%A0%E7%90%86%E8%A7%A3%20%22%E7%AB%AF%E5%8F%A3%E5%8F%B7%22%20%E5%92%8C%20%22%E8%BF%9B%E7%A8%8BID%22\">1.3 ç†è§£ \"ç«¯å£å·\" å’Œ \"è¿›ç¨‹ID\"</a></strong></p>\n<p id=\"1.4%20%E7%90%86%E8%A7%A3%E6%BA%90%E7%AB%AF%E5%8F%A3%E5%8F%B7%E5%92%8C%E7%9B%AE%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%8F%B7-toc\" style=\"margin-left:40px;\"><strong><a href=\"#1.4%20%E7%90%86%E8%A7%A3%E6%BA%90%E7%AB%AF%E5%8F%A3%E5%8F%B7%E5%92%8C%E7%9B%AE%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%8F%B7\">1.4 ç†è§£æºç«¯å£å·å’Œç›®çš„ç«¯å£å·</a></strong></p>\n<p id=\"articleContentId-toc\" style=\"margin-left:40px;\"><strong><a href=\"#articleContentId\">1.5 IPåœ°å€ã€MACåœ°å€ã€ç«¯å£å·çš„åŒºåˆ«ï¼Ÿ</a></strong></p>\n<p id=\"1.6%C2%A0%E8%AE%A4%E8%AF%86TCP%E5%8D%8F%E8%AE%AE-toc\" style=\"margin-left:40px;\"><strong><a href=\"#1.6%C2%A0%E8%AE%A4%E8%AF%86TCP%E5%8D%8F%E8%AE%AE\">1.6 è®¤è¯†TCPåè®®</a></strong></p>\n<p id=\"1.7%20%E8%AE%A4%E8%AF%86UDP%E5%8D%8F%E8%AE%AE-toc\" style=\"margin-left:40px;\"><strong><a href=\"#1.7%20%E8%AE%A4%E8%AF%86UDP%E5%8D%8F%E8%AE%AE\">1.7 è®¤è¯†UDPåè®®</a></strong></p>\n<p id=\"1.8%C2%A0%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F-toc\" style=\"margin-left:40px;\"><strong><a href=\"#1.8%C2%A0%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F\">1.8 ç½‘ç»œå­—èŠ‚åº</a></strong></p>\n<p id=\"2.%20socket%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3-toc\" style=\"margin-left:0px;\"><strong><a href=\"#2.%20socket%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3\">2. socketç¼–ç¨‹æ¥å£</a></strong></p>\n<p id=\"2.1%20socket%20%E5%B8%B8%E8%A7%81API-toc\" style=\"margin-left:40px;\"><strong><a href=\"#2.1%20socket%20%E5%B8%B8%E8%A7%81API\">2.1 socket å¸¸è§API</a></strong></p>\n<p id=\"2.2%C2%A0sockaddr%E7%BB%93%E6%9E%84-toc\" style=\"margin-left:40px;\"><strong><a href=\"#2.2%C2%A0sockaddr%E7%BB%93%E6%9E%84\">2.2 sockaddrç»“æ„</a></strong></p>\n<p id=\"sockaddr%20%E7%BB%93%E6%9E%84-toc\" style=\"margin-left:80px;\"><strong><a href=\"#sockaddr%20%E7%BB%93%E6%9E%84\">sockaddr ç»“æ„</a></strong></p>\n<p id=\"%C2%A0sockaddr_in%20%E7%BB%93%E6%9E%84-toc\" style=\"margin-left:80px;\"><strong><a href=\"#%C2%A0sockaddr_in%20%E7%BB%93%E6%9E%84\"> sockaddr_in ç»“æ„</a></strong></p>\n<p id=\"in_addr%E7%BB%93%E6%9E%84-toc\" style=\"margin-left:80px;\"><strong><a href=\"#in_addr%E7%BB%93%E6%9E%84\">in_addrç»“æ„</a></strong></p>\n<p id=\"3.%20%E7%AE%80%E5%8D%95%E7%9A%84UDP%E7%BD%91%E7%BB%9C%E7%A8%8B%E5%BA%8F-toc\" style=\"margin-left:0px;\"><strong><a href=\"#3.%20%E7%AE%80%E5%8D%95%E7%9A%84UDP%E7%BD%91%E7%BB%9C%E7%A8%8B%E5%BA%8F\">3. ç®€å•çš„UDPç½‘ç»œç¨‹åº</a></strong></p>\n<p id=\"3.1%20%E6%8E%A5%E5%8F%A3-toc\" style=\"margin-left:40px;\"><strong><a href=\"#3.1%20%E6%8E%A5%E5%8F%A3\">3.1 æ¥å£</a></strong></p>\n<p id=\"3.1.1%20%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E6%8E%A5%E5%8F%A3-toc\" style=\"margin-left:80px;\"><strong><a href=\"#3.1.1%20%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E6%8E%A5%E5%8F%A3\">3.1.1 åˆå§‹åŒ–çš„æ¥å£</a></strong></p>\n<p id=\"3.1.2%20%E8%BF%90%E8%A1%8C%E8%B5%B7%E6%9D%A5%E9%9C%80%E8%A6%81%E7%9A%84%E6%8E%A5%E5%8F%A3-toc\" style=\"margin-left:80px;\"><strong><a href=\"#3.1.2%20%E8%BF%90%E8%A1%8C%E8%B5%B7%E6%9D%A5%E9%9C%80%E8%A6%81%E7%9A%84%E6%8E%A5%E5%8F%A3\">3.1.2 è¿è¡Œèµ·æ¥éœ€è¦çš„æ¥å£</a></strong></p>\n<p id=\"3.2%20%E5%AE%9E%E7%8E%B0%20UDP-toc\" style=\"margin-left:40px;\"><strong><a href=\"#3.2%20%E5%AE%9E%E7%8E%B0%20UDP\">3.2 å®ç° UDP</a></strong></p>\n<p id=\"udp_server.hpp-toc\" style=\"margin-left:80px;\"><strong><a href=\"#udp_server.hpp\">udp_server.hpp</a></strong></p>\n<p id=\"udp_server.cc-toc\" style=\"margin-left:80px;\"><strong><a href=\"#udp_server.cc\">udp_server.cc</a></strong></p>\n<p id=\"udp_client.hpp-toc\" style=\"margin-left:80px;\"><strong><a href=\"#udp_client.hpp\">udp_client.hpp</a></strong></p>\n<p id=\"udp_client.cc-toc\" style=\"margin-left:80px;\"><strong><a href=\"#udp_client.cc\">udp_client.cc</a></strong></p>\n<p id=\"3.3%20UDP%E6%80%BB%E4%BB%A3%E7%A0%81-toc\" style=\"margin-left:40px;\"><strong><a href=\"#3.3%20UDP%E6%80%BB%E4%BB%A3%E7%A0%81\">3.3 UDPæ€»ä»£ç </a></strong></p>\n<p id=\"udp_server.hpp-toc\" style=\"margin-left:80px;\"><strong><a href=\"#udp_server.hpp\">udp_server.hpp</a></strong></p>\n<p id=\"udp_server.cc-toc\" style=\"margin-left:80px;\"><strong><a href=\"#udp_server.cc\">udp_server.cc</a></strong></p>\n<p id=\"udp_client.hpp-toc\" style=\"margin-left:80px;\"><strong><a href=\"#udp_client.hpp\">udp_client.hpp</a></strong></p>\n<p id=\"udp_client.cc-toc\" style=\"margin-left:80px;\"><strong><a href=\"#udp_client.cc\">udp_client.cc</a></strong></p>\n<p id=\"4.%20%E5%A4%9A%E6%96%B9%E6%B3%95TCP%E9%80%9A%E4%BF%A1-toc\" style=\"margin-left:0px;\"><strong><a href=\"#4.%20%E5%A4%9A%E6%96%B9%E6%B3%95TCP%E9%80%9A%E4%BF%A1\">4. å¤šæ–¹æ³•TCPé€šä¿¡</a></strong></p>\n<p id=\"4.1%20%E6%8E%A5%E5%8F%A3-toc\" style=\"margin-left:40px;\"><strong><a href=\"#4.1%20%E6%8E%A5%E5%8F%A3\">4.1 æ¥å£</a></strong></p>\n<p id=\"4.2%20TCP%20%E5%8D%95%E6%89%A7%E8%A1%8C%E6%B5%81-toc\" style=\"margin-left:40px;\"><strong><a href=\"#4.2%20TCP%20%E5%8D%95%E6%89%A7%E8%A1%8C%E6%B5%81\">4.2 TCP å•æ‰§è¡Œæµ</a></strong></p>\n<p id=\"tcp_server.hpp-toc\" style=\"margin-left:80px;\"><strong><a href=\"#tcp_server.hpp\">tcp_server.hpp</a></strong></p>\n<p id=\"tcp_server.cc-toc\" style=\"margin-left:80px;\"><strong><a href=\"#tcp_server.cc\">tcp_server.cc</a></strong></p>\n<p id=\"tcp_client.hpp-toc\" style=\"margin-left:80px;\"><strong><a href=\"#tcp_client.hpp\">tcp_client.hpp</a></strong></p>\n<p id=\"tcp_client.cc-toc\" style=\"margin-left:80px;\"><strong><a href=\"#tcp_client.cc\">tcp_client.cc</a></strong></p>\n<p id=\"4.3%20TCP%20%E5%A4%9A%E8%BF%9B%E7%A8%8B-toc\" style=\"margin-left:40px;\"><strong><a href=\"#4.3%20TCP%20%E5%A4%9A%E8%BF%9B%E7%A8%8B\">4.3 TCP å¤šè¿›ç¨‹</a></strong></p>\n<p id=\"tcp_server.hpp-toc\" style=\"margin-left:80px;\"><strong><a href=\"#tcp_server.hpp\">tcp_server.hpp</a></strong></p>\n<p id=\"tcp_server.cc-toc\" style=\"margin-left:80px;\"><strong><a href=\"#tcp_server.cc\">tcp_server.cc</a></strong></p>\n<p id=\"tcp_client.hpp-toc\" style=\"margin-left:80px;\"><strong><a href=\"#tcp_client.hpp\">tcp_client.hpp</a></strong></p>\n<p id=\"tcp_client.cc-toc\" style=\"margin-left:80px;\"><strong><a href=\"#tcp_client.cc\">tcp_client.cc</a></strong></p>\n<p id=\"4.4%C2%A0TCP%20%E5%A4%9A%E7%BA%BF%E7%A8%8B-toc\" style=\"margin-left:40px;\"><strong><a href=\"#4.4%C2%A0TCP%20%E5%A4%9A%E7%BA%BF%E7%A8%8B\">4.4 TCP å¤šçº¿ç¨‹</a></strong></p>\n<p id=\"tcp_server.hpp-toc\" style=\"margin-left:80px;\"><strong><a href=\"#tcp_server.hpp\">tcp_server.hpp</a></strong></p>\n<p id=\"tcp_server.cc-toc\" style=\"margin-left:80px;\"><strong><a href=\"#tcp_server.cc\">tcp_server.cc</a></strong></p>\n<p id=\"tcp_client.hpp-toc\" style=\"margin-left:80px;\"><strong><a href=\"#tcp_client.hpp\">tcp_client.hpp</a></strong></p>\n<p id=\"%C2%A0tcp_client.cc-toc\" style=\"margin-left:80px;\"><strong><a href=\"#%C2%A0tcp_client.cc\"> tcp_client.cc</a></strong></p>\n<p id=\"4.5%C2%A0TCP%20%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%89%88%E6%9C%AC)-toc\" style=\"margin-left:40px;\"><strong><a href=\"#4.5%C2%A0TCP%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%28%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%89%88%E6%9C%AC%29\">4.5 TCP å¤šçº¿ç¨‹(çº¿ç¨‹æ± ç‰ˆæœ¬)</a></strong></p>\n<p id=\"ThreadPool.hpp-toc\" style=\"margin-left:80px;\"><strong><a href=\"#ThreadPool.hpp\">ThreadPool.hpp</a></strong></p>\n<p id=\"Task.hpp-toc\" style=\"margin-left:80px;\"><strong><a href=\"#Task.hpp\">Task.hpp</a></strong></p>\n<p id=\"tcp_server.hpp-toc\" style=\"margin-left:80px;\"><strong><a href=\"#tcp_server.hpp\">tcp_server.hpp</a></strong></p>\n<p id=\"tcp_server.cc-toc\" style=\"margin-left:80px;\"><strong><a href=\"#tcp_server.cc\">tcp_server.cc</a></strong></p>\n<p id=\"tcp_client.hpp-toc\" style=\"margin-left:80px;\"><strong><a href=\"#tcp_client.hpp\">tcp_client.hpp</a></strong></p>\n<p id=\"%C2%A0tcp_client.cc-toc\" style=\"margin-left:80px;\"><strong><a href=\"#%C2%A0tcp_client.cc\"> tcp_client.cc</a></strong></p>\n<p id=\"5.%20%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9-toc\" style=\"margin-left:0px;\"><strong><a href=\"#5.%20%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9\">5. é›¶ç¢çŸ¥è¯†ç‚¹</a></strong></p>\n<p id=\"5.1%C2%A0%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0-toc\" style=\"margin-left:40px;\"><strong><a href=\"#5.1%C2%A0%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0\">5.1 åœ°å€è½¬æ¢å‡½æ•°</a></strong></p>\n<p id=\"5.2%C2%A0%E5%85%B3%E4%BA%8Einet_ntoa-toc\" style=\"margin-left:40px;\"><strong><a href=\"#5.2%C2%A0%E5%85%B3%E4%BA%8Einet_ntoa\">5.2 å…³äºinet_ntoa</a></strong></p>\n<hr id=\"hr-toc\"/>\n<h1><strong><span style=\"color:#ff9900;\">0. å‰è¨€</span></strong></h1>\n<p><strong>        æ­¤åšå®¢ä¸ºåšä¸»ä»¥åå¤ä¹ çš„èµ„æ–™ï¼Œæ‰€ä»¥å¤§å®¶æ”¾å¿ƒå­¦ä¹ ï¼Œæ€»ç»“çš„å¾ˆå…¨é¢ï¼Œæ¯æ®µä»£ç éƒ½ç»™å¤§å®¶å‘äº†å‡ºæ¥ï¼Œå¤§å®¶å¦‚æœæœ‰ç–‘é—®å¯ä»¥å°è¯•å»è°ƒè¯•ã€‚</strong></p>\n<p><strong>        <span style=\"color:#79c6cd;\">å¤§å®¶ä¸€å®šè¦è®¤çœŸçœ‹å›¾ï¼Œå›¾é‡Œçš„æ–‡å­—éƒ½æ˜¯ç²¾åï¼Œå¥½å¤šçš„ç»†èŠ‚éƒ½åœ¨å›¾ä¸­å±•ç¤ºã€å†™å‡ºæ¥äº†ï¼Œæ‰€ä»¥å¤§å®¶ä¸€å®šè¦ä»”ç»†å“¦~</span></strong></p>\n<p><strong>        æ„Ÿè°¢å¤§å®¶å¯¹æˆ‘çš„æ”¯æŒï¼Œæ„Ÿè°¢å¤§å®¶çš„å–œæ¬¢ï¼Œ <span style=\"color:#ff9900;\">å…”7</span> ç¥å¤§å®¶åœ¨å­¦ä¹ çš„è·¯ä¸Šä¸€è·¯é¡ºåˆ©ï¼Œç”Ÿæ´»çš„è·¯ä¸Šé¡ºå¿ƒé¡ºæ„~ï¼</strong></p>\n<h1 id=\"1.%20%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86\"><strong><span style=\"color:#faa572;\">1. é¢„å¤‡çŸ¥è¯†</span></strong></h1>\n<h2 id=\"1.%201%20%E7%90%86%E8%A7%A3%E6%BA%90IP%E5%9C%B0%E5%9D%80%E5%92%8C%E7%9B%AE%E7%9A%84IP%E5%9C%B0%E5%9D%80\"><strong><span style=\"color:#9c8ec1;\">1. 1 ç†è§£æºIPåœ°å€å’Œç›®çš„IPåœ°å€</span></strong></h2>\n<p><strong>        åœ¨IPæ•°æ®åŒ…å¤´éƒ¨ä¸­ï¼Œæœ‰ä¸¤ä¸ªIPåœ°å€ï¼Œåˆ†åˆ«å«åšæºIPåœ°å€ï¼Œå’Œç›®çš„IPåœ°å€ã€‚</strong></p>\n<p><strong>        å°±åƒå”åƒ§ç»å¸¸è¯´ï¼šè´«åƒ§ä»ä¸œåœŸå¤§å”è€Œæ¥ï¼Œåˆ°è¥¿å¤©æ±‚å–çœŸç»ã€‚</strong></p>\n<p><strong>        å…¶ä¸­\"ä¸œåœŸå¤§å”\"å’Œ\"è¥¿å¤©\"å°±æ˜¯æºIPåœ°å€å’Œç›®çš„IPåœ°å€ã€‚æ‰€ä»¥æºIPåœ°å€å’Œç›®çš„IPåœ°å€åŸºæœ¬æ˜¯ä¸å˜çš„ã€‚</strong></p>\n<p><strong>        æ¯”æ–¹è¯´ä¸Šä¸€æ¬¡ç»è¿‡äº†å¥³å„¿å›½ï¼Œå†å¾€é»‘é£å²­èµ°ï¼Œå”åƒ§å¯èƒ½å°±ä¼šè¯´ï¼Œæˆ‘ä¸Šä¸€ç«™æ˜¯å¥³å„¿å›½ï¼Œæˆ‘ç°åœ¨åœ¨å¾€é»‘é£å²­èµ°ã€‚</strong></p>\n<p><strong>        å…¶ä¸­çš„åœ°å€å°±æ˜¯æºMACåœ°å€å’Œç›®çš„MACåœ°å€ï¼Œå®ƒåœ¨å”åƒ§ä¸€è·¯ä¸Šéƒ½æ˜¯ä¼šå‘ç”Ÿå˜åŒ–çš„ï¼Œåœ¨è®¡ç®—æœºä¸­ä¹‹æ‰€ä»¥MACåœ°å€ä¼šå˜åŒ–æ˜¯å› ä¸ºåœ¨ä¼ è¾“ä¸­ä¼šç»è¿‡è·¯ç”±ï¼Œä»è€Œè¿›è¡Œè§£åŒ…å’Œå°åŒ…ã€‚</strong></p>\n<h2 id=\"1.2%20%E8%AE%A4%E8%AF%86%E7%AB%AF%E5%8F%A3%E5%8F%B7\"><strong><span style=\"color:#9c8ec1;\">1.2 è®¤è¯†ç«¯å£å·</span></strong></h2>\n<p><strong>        ç«¯å£å·(port)æ˜¯ä¼ è¾“å±‚åè®®çš„å†…å®¹ã€‚</strong></p>\n<blockquote>\n<ul><li><strong>ç«¯å£å·æ˜¯ä¸€ä¸ª2å­—èŠ‚16ä½çš„æ•´æ•°ã€‚</strong></li><li><strong>ç«¯å£å·ç”¨æ¥æ ‡è¯†ä¸€ä¸ªè¿›ç¨‹ï¼Œå‘Šè¯‰æ“ä½œç³»ç»Ÿï¼Œå½“å‰çš„è¿™ä¸ªæ•°æ®è¦äº¤ç»™å“ªä¸€ä¸ªè¿›ç¨‹æ¥å¤„ç†ã€‚</strong></li><li><strong>IPåœ°å€ + ç«¯å£å·èƒ½å¤Ÿæ ‡è¯†ç½‘ç»œä¸Šçš„æŸä¸€å°ä¸»æœºçš„æŸä¸€ä¸ªè¿›ç¨‹ã€‚</strong></li><li><strong>ä¸€ä¸ªç«¯å£å·åªèƒ½è¢«ä¸€ä¸ªè¿›ç¨‹å ç”¨ã€‚</strong></li></ul>\n</blockquote>\n<p><strong>        å”åƒ§åˆ°è¥¿å¤©ä¸æ˜¯ä¸ºäº†å»è¥¿å¤©è€Œå»è¥¿å¤©ï¼Œè€Œæ˜¯ä¸ºäº†åˆ°è¥¿å¤©æ‹¿åˆ°ç»ä¹¦ï¼Œæ‰€ä»¥è¥¿å¤©æ˜¯å”åƒ§å¿…é¡»åˆ°çš„åœ°æ–¹ã€‚</strong></p>\n<p><strong>        æ‰€ä»¥æˆ‘ä»¬æŠŠæ•°æ®ä»ä¸€å°ä¸»æœºé€åˆ°å¦ä¸€å°ä¸»æœºæ²¡æœ‰æ„ä¹‰ï¼Œæœ€ç»ˆæˆ‘ä»¬æ˜¯æƒ³è¯·æ±‚åˆ°å¯¹åº”çš„æ•°æ®ã€‚æ‰€ä»¥æˆ‘ä»¬çš„è¯·æ±‚ä¸åªæ˜¯è¦å‘é€åˆ°å¯¹æ–¹çš„æœºå™¨ä¸Šï¼Œè€Œæ˜¯ä¸ºäº†è®¿é—®åˆ°è¿™ä¸ªæœºå™¨ä¸Šä¸€ä¸ªç‰¹å®šçš„æœåŠ¡ã€‚</strong></p>\n<p><strong><img alt=\"\" height=\"360\" src=\"..\\..\\static\\image\\3bc0b952d59242b7829cd3160db0ab3a.png\" width=\"795\"/></strong></p>\n<p><strong>       <span style=\"color:#79c6cd;\"> æ‰€ä»¥ socket é€šä¿¡ï¼Œæœ¬è´¨ä¸Šæ˜¯è¿›ç¨‹é—´é€šä¿¡ï¼Œè€Œä¸”å¯ä»¥æ˜¯è·¨ç½‘ç»œçš„è¿›ç¨‹é—´é€šä¿¡ã€‚</span></strong></p>\n<p><strong>        é‚£ä¹ˆï¼š</strong></p>\n<p><strong><img alt=\"\" height=\"385\" src=\"..\\..\\static\\image\\56c1f1d558044254adbe4ae546acd2a2.png\" width=\"738\"/></strong></p>\n<ul><li><strong><span style=\"color:#1c7331;\">å½“æ•°æ®æ¥åˆ°å¯¹ç«¯çš„ç½‘ç»œå±‚ï¼Œå®ƒæ€ä¹ˆçŸ¥é“è¦è®¿é—®æœåŠ¡ç«¯çš„å“ªä¸ªæœåŠ¡å‘¢ï¼Ÿ</span>(å½“ç„¶åƒå‰é¢æœç´¢å¼•æ“è¿™ä¹ˆé‡è¦çš„æœåŠ¡ï¼Œä¸€å°ä¸»æœºä¸Šå°±åªæœ‰ä¸€ä¸ªæœåŠ¡)</strong></li><li><strong><span style=\"color:#1c7331;\">ä¼ é€’å›æ¥çš„æ—¶å€™åˆæ˜¯è¦ä¼ ç»™å“ªä¸ªæœåŠ¡å‘¢ï¼Ÿ</span></strong></li></ul>\n<p><strong>        æ‰€ä»¥è¿™é‡Œå°±ç”¨åˆ°äº†ç«¯å£å·ã€‚</strong></p>\n<p><strong>        ä»»ä½•çš„ç½‘ç»œæœåŠ¡ä¸ç½‘ç»œå®¢æˆ·ç«¯ï¼Œå¦‚æœè¦è¿›è¡Œæ­£å¸¸çš„æ•°æ®é€šä¿¡ï¼Œå¿…é¡»è¦ç”¨ç«¯å£å·æ¥å”¯ä¸€æ ‡è¯†ã€‚åœ¨åŒä¸€ä¸ªOSå†…ï¼Œä¸€ä¸ªè¿›ç¨‹å¯ä»¥ä¸ä¸€ä¸ªç«¯å£å·è¿›è¡Œç»‘å®šï¼Œè¯¥ç«¯å£å·å°±åœ¨ç½‘ç»œå±‚é¢å”¯ä¸€è¡¨ç¤ºä¸€å°ä¸»æœºä¸Šçš„å”¯ä¸€ä¸€ä¸ªè¿›ç¨‹ã€‚</strong></p>\n<blockquote>\n<ul><li><strong>å…¬ç½‘IPï¼šå”¯ä¸€çš„æ ‡è¯†å…¨ç½‘å†…å”¯ä¸€çš„ä¸€å°ä¸»æœºã€‚</strong></li><li><strong>portï¼šè¡¨ç¤ºä¸€å°ä¸»æœºä¸Šçš„å”¯ä¸€ä¸€ä¸ªè¿›ç¨‹ã€‚</strong></li></ul>\n</blockquote>\n<p><strong>        æ‰€ä»¥ IP+port å°±æ˜¯æ ‡è¯†å…¨ç½‘å†…å”¯ä¸€çš„ä¸€ä¸ªè¿›ç¨‹ã€‚</strong></p>\n<p><strong>        æ‰€ä»¥ä¸¤ç«¯éƒ½æœ‰å¯¹åº”çš„ IP+port ï¼Œé‚£ä¹ˆä¹Ÿå°±æ˜¯å”¯äºŒçš„ä¸¤ä¸ªè¿›ç¨‹ä¹‹é—´è¿›è¡Œé€šä¿¡ã€‚</strong></p>\n<p><strong>        æ‰€ä»¥æˆ‘ä»¬å°±å°† IP+port è¿™ç§æ ‡è¯†è¿›ç¨‹é—´é€šä¿¡çš„æ–¹å¼å°±å«åš socketé€šä¿¡ã€‚</strong></p>\n<h2 id=\"1.3%C2%A0%E7%90%86%E8%A7%A3%20%22%E7%AB%AF%E5%8F%A3%E5%8F%B7%22%20%E5%92%8C%20%22%E8%BF%9B%E7%A8%8BID%22\"><strong><span style=\"color:#9c8ec1;\">1.3 ç†è§£ \"ç«¯å£å·\" å’Œ \"è¿›ç¨‹ID\"</span></strong></h2>\n<p><strong>        æˆ‘åœ¨å‰é¢å†™çš„ç³»ç»Ÿç¼–ç¨‹çš„æ—¶å€™ï¼Œæˆ‘ä»¬å­¦ä¹ äº† pid è¡¨ç¤ºå”¯ä¸€ä¸€ä¸ªè¿›ç¨‹ã€‚æ­¤å¤„æˆ‘ä»¬çš„ç«¯å£å·ä¹Ÿæ˜¯å”¯ä¸€è¡¨ç¤ºä¸€ä¸ªè¿›ç¨‹ã€‚</strong></p>\n<p><strong><span style=\"color:#1c7331;\">é‚£ä¹ˆè¿™ä¸¤è€…ä¹‹é—´æ˜¯æ€æ ·çš„å…³ç³»ï¼Ÿ</span></strong></p>\n<p><strong>        é¦–å…ˆï¼Œä¸€å°æœºå™¨ä¸Šå¯èƒ½å­˜åœ¨å¤§é‡çš„è¿›ç¨‹ï¼Œä½†ä¸æ˜¯æ‰€æœ‰çš„è¿›ç¨‹éƒ½è¦å¯¹å¤–è¿›è¡Œç½‘ç»œæ•°æ®è¯·æ±‚ã€‚</strong></p>\n<p><strong>        æ‰€ä»¥å…¶å®å­˜åœ¨å¤§é‡çš„è¿›ç¨‹æ˜¯ç³»ç»Ÿçš„æ¦‚å¿µï¼Œè€Œè¿›ç¨‹è¿›è¡Œç½‘ç»œæ•°æ®è¯·æ±‚æ˜¯ç½‘ç»œçº§çš„æ¦‚å¿µã€‚</strong></p>\n<p><strong>ä¾‹å¦‚ï¼š</strong></p>\n<p><strong>        åœ¨å­¦æ ¡ä¸­æœ‰è‡ªå·±çš„å­¦å·ï¼Œåœ¨ç¤¾ä¼šä¸Šæœ‰è‡ªå·±çš„èº«ä»½è¯å·ï¼Œåœ¨å…¬å¸åˆæœ‰è‡ªå·±çš„å·¥å·ï¼Œéƒ½å¯ä»¥é€šè¿‡è¿™äº›æ¥æ ‡è¯†è‡ªå·±ï¼Œå®ƒä»¬ä¹‹é—´äº’ä¸å†²çªï¼Œä¸åŒçš„åœ°æ–¹ç”¨ä¸åŒçš„å·ï¼Œæ˜¯ä¸ºäº†æ–¹ä¾¿ç®¡ç†æˆ–è€…è¯†åˆ«ã€‚</strong></p>\n<p><strong>        æ‰€ä»¥è¿™é‡Œçš„ç«¯å£å·å’Œè¿›ç¨‹IDä¹Ÿæ˜¯å¦‚æ­¤ï¼Œè¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆç½‘ç»œä¸­å•ç‹¬å‡ºç°ä¸ª port çš„åŸå› ï¼Œå› ä¸º port æ›´é€‚åˆã€‚</strong></p>\n<p><strong><span style=\"color:#1c7331;\">IPåœ°å€å’Œç«¯å£å·å®ƒä»¬ä¹‹é—´çš„å…³ç³»ï¼Ÿ</span></strong></p>\n<p><strong>ä¾‹å¦‚ï¼š</strong></p>\n<p><strong>        æ‰‹æœºæ¬ è´¹äº†ï¼Œæ‰‹æœºåªèƒ½æ‰“ 10086ï¼Œè¿™æ—¶æ˜¯ä¸€ä¸ªäººå·¥å®¢æœæ¥çš„ç”µè¯æä¾›æœåŠ¡ã€‚</strong></p>\n<p><strong>        é‚£ä¹ˆè¿™é‡Œçš„ 10086 å°±ç›¸å½“äºIPåœ°å€ï¼Œè€Œä¸ºæˆ‘ä»¬æä¾›äººå·¥å®¢æœçš„é‚£ä¸ªå‘˜å·¥çš„å·¥å·å°±ç›¸å½“äºç«¯å£å·ã€‚</strong></p>\n<h2 id=\"1.4%20%E7%90%86%E8%A7%A3%E6%BA%90%E7%AB%AF%E5%8F%A3%E5%8F%B7%E5%92%8C%E7%9B%AE%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%8F%B7\"><strong><span style=\"color:#9c8ec1;\">1.4 ç†è§£æºç«¯å£å·å’Œç›®çš„ç«¯å£å·</span></strong></h2>\n<p><strong>        ä¼ è¾“å±‚åè®®(TCPå’ŒUDP)çš„æ•°æ®æ®µä¸­æœ‰ä¸¤ä¸ªç«¯å£å·ï¼Œåˆ†åˆ«å«åšæºç«¯å£å·å’Œç›®çš„ç«¯å£å·ã€‚å°±æ˜¯åœ¨æè¿° \"æ•°æ®æ˜¯è°å‘çš„ï¼Œè¦å‘ç»™è°\"ã€‚</strong></p>\n<p><strong>        æ‰€ä»¥è¿™æ—¶å”åƒ§åº”è¯¥è¯´çš„æ˜¯ï¼šè´«åƒ§å¥‰å”çš‡å¸ä¹‹ä»¤ä»ä¸œåœŸå¤§å”è€Œæ¥ï¼Œåˆ°è¥¿å¤©æ±‚å–çœŸç»ã€‚</strong></p>\n<h2 id=\"articleContentId\"><strong><span style=\"color:#9c8ec1;\">1.5 IPåœ°å€ã€MACåœ°å€ã€ç«¯å£å·çš„åŒºåˆ«ï¼Ÿ</span></strong></h2>\n<blockquote>\n<ul><li><strong>macåœ°å€æ˜¯åœ¨æ•°æ®é“¾è·¯å±‚åŒ…è£¹åœ¨ä»¥å¤ªç½‘å¤´éƒ¨ä¸­çš„ï¼Œå®ƒä¸»è¦ç”¨æ¥è¯†åˆ«åŒä¸€ä¸ªé“¾è·¯ä¸­çš„ä¸åŒè®¡ç®—æœºã€‚Macåœ°å€å³ç½‘å¡å·ï¼Œæ¯å—ç½‘å¡å‡ºå‚çš„æ—¶å€™ï¼Œéƒ½æœ‰ä¸€ä¸ªå…¨ä¸–ç•Œç‹¬ä¸€æ— äºŒçš„ MAC åœ°å€ï¼Œé•¿åº¦æ˜¯ 48 ä¸ªäºŒè¿›åˆ¶ä½ï¼Œé€šå¸¸ç”¨ 12 ä¸ªåå…­è¿›åˆ¶æ•°è¡¨ç¤ºã€‚</strong></li><li><strong>IPåœ°å€æ˜¯åœ¨ç½‘ç»œå±‚çš„IPå¤´éƒ¨é‡Œï¼Œç”¨äºè¯†åˆ«ç½‘ç»œä¸­äº’è”çš„ä¸»æœºå’Œè·¯ç”±å™¨ï¼Œå…¶å®ä¸»è¦æ˜¯ç¡®è®¤å­ç½‘ï¼Œé€šè¿‡å­ç½‘æ©ç ç¡®è®¤æŸä¸ªIPåœ°å€æ‰€åœ¨çš„å­ç½‘ï¼Œè€Œåå†åœ¨å­ç½‘å†…éƒ¨ç¡®è®¤macåœ°å€å°±èƒ½æ‰¾åˆ°å‡†ç¡®çš„ç”¨æˆ·äº†ã€‚</strong></li><li><strong>ç«¯å£å·æ˜¯åœ¨è¿è¾“å±‚åŒ…å«åœ¨TCP/UDPå¤´éƒ¨ä¸­çš„ï¼Œç”¨äºè¯†åˆ«åº”ç”¨ç¨‹åºã€‚ä¸€å°ä¸»æœºä¸Šèƒ½è¿è¡Œå¤šä¸ªç¨‹åºï¼Œé‚£ä¹ˆæ¥æ”¶åˆ°çš„æ¶ˆæ¯åˆ°åº•æ˜¯å“ªä¸ªç¨‹åºå‘é€çš„ï¼Œå°±éœ€è¦ç«¯å£å·æ¥ç¡®è®¤ã€‚</strong></li></ul>\n</blockquote>\n<h2 id=\"1.6%C2%A0%E8%AE%A4%E8%AF%86TCP%E5%8D%8F%E8%AE%AE\"><strong><span style=\"color:#9c8ec1;\">1.6 è®¤è¯†TCPåè®®</span></strong></h2>\n<p><strong>        æ­¤å¤„æˆ‘ä»¬å…ˆå¯¹TCP(Transmission Control Protocol ä¼ è¾“æ§åˆ¶åè®®)æœ‰ä¸€ä¸ªç›´è§‚çš„è®¤è¯†ã€‚åé¢æˆ‘ä»¬å†è¯¦ç»†è®¨è®ºTCPçš„ä¸€äº›ç»†èŠ‚é—®é¢˜ã€‚</strong></p>\n<blockquote>\n<ul><li><strong>ä¼ è¾“å±‚åè®®</strong></li><li><strong>æœ‰è¿æ¥</strong></li><li><strong>å¯é ä¼ è¾“</strong></li><li><strong>é¢å‘å­—èŠ‚æµ</strong></li></ul>\n</blockquote>\n<h2 id=\"1.7%20%E8%AE%A4%E8%AF%86UDP%E5%8D%8F%E8%AE%AE\"><strong><span style=\"color:#9c8ec1;\">1.7 è®¤è¯†UDPåè®®</span></strong></h2>\n<p><strong>        æ­¤å¤„æˆ‘ä»¬ä¹Ÿæ˜¯å¯¹UDP(User Datagram Protocol ç”¨æˆ·æ•°æ®æŠ¥åè®®)æœ‰ä¸€ä¸ªç›´è§‚çš„è®¤è¯†ã€‚åé¢å†è¯¦ç»†è®¨è®ºã€‚</strong></p>\n<blockquote>\n<ul><li><strong>ä¼ è¾“å±‚åè®®</strong></li><li><strong>æ— è¿æ¥</strong></li><li><strong>ä¸å¯é ä¼ è¾“</strong></li><li><strong>é¢å‘æ•°æ®æŠ¥</strong></li></ul>\n</blockquote>\n<h2 id=\"1.8%C2%A0%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F\"><strong><span style=\"color:#9c8ec1;\">1.8 ç½‘ç»œå­—èŠ‚åº</span></strong></h2>\n<p><strong>        æˆ‘ä»¬å·²ç»çŸ¥é“ï¼Œå†…å­˜ä¸­çš„å¤šå­—èŠ‚æ•°æ®ç›¸å¯¹äºå†…å­˜åœ°å€æœ‰å¤§ç«¯å’Œå°ç«¯ä¹‹åˆ†ï¼Œç£ç›˜æ–‡ä»¶ä¸­çš„å¤šå­—èŠ‚æ•°æ®ç›¸å¯¹äºæ–‡ä»¶ä¸­çš„åç§»åœ°å€ä¹Ÿæœ‰å¤§ç«¯å°ç«¯ä¹‹åˆ†ï¼Œç½‘ç»œæ•°æ®æµåŒæ ·æœ‰å¤§ç«¯å°ç«¯ä¹‹åˆ†ã€‚é‚£ä¹ˆå¦‚ä½•å®šä¹‰ç½‘ç»œæ•°æ®æµçš„åœ°å€å‘¢ï¼Ÿ</strong></p>\n<blockquote>\n<ul><li><strong>å‘é€ä¸»æœºé€šå¸¸å°†å‘é€ç¼“å†²åŒºä¸­çš„æ•°æ®æŒ‰å†…å­˜åœ°å€<span style=\"color:#79c6cd;\">ä»ä½åˆ°é«˜çš„é¡ºåºå‘å‡º</span>ã€‚</strong></li><li><strong>æ¥æ”¶ä¸»æœºæŠŠä»ç½‘ç»œä¸Šæ¥åˆ°çš„å­—èŠ‚ä¾æ¬¡ä¿å­˜åœ¨æ¥æ”¶ç¼“å†²åŒºä¸­ï¼Œä¹Ÿæ˜¯æŒ‰å†…å­˜åœ°å€<span style=\"color:#79c6cd;\">ä»ä½åˆ°é«˜çš„é¡ºåºä¿å­˜</span>ã€‚</strong></li><li><strong>å› æ­¤ï¼Œç½‘ç»œæ•°æ®æµçš„åœ°å€åº”è¿™æ ·è§„å®šï¼šå…ˆå‘å‡ºçš„æ•°æ®æ˜¯ä½åœ°å€ï¼Œåå‘å‡ºçš„æ•°æ®æ˜¯é«˜åœ°å€ã€‚</strong></li><li><strong>TCP/IPåè®®è§„å®šï¼Œç½‘ç»œæ•°æ®æµåº”é‡‡ç”¨å¤§ç«¯å­—èŠ‚åºï¼Œå³ä½åœ°å€é«˜å­—èŠ‚ã€‚</strong></li><li><strong>ä¸ç®¡è¿™å°ä¸»æœºæ˜¯å¤§ç«¯æœºè¿˜æ˜¯å°ç«¯æœºï¼Œéƒ½ä¼šæŒ‰ç…§è¿™ä¸ªTCP/IPè§„å®šçš„ç½‘ç»œå­—èŠ‚åºæ¥å‘é€/æ¥æ”¶æ•°æ®ã€‚</strong></li><li><strong>å¦‚æœå½“å‰å‘é€ä¸»æœºæ˜¯å°ç«¯ï¼Œå°±éœ€è¦å…ˆå°†æ•°æ®è½¬æˆå¤§ç«¯ã€‚å¦åˆ™å°±å¿½ç•¥ï¼Œç›´æ¥å‘é€å³å¯ã€‚</strong></li></ul>\n</blockquote>\n<p><strong><img alt=\"\" height=\"499\" src=\"..\\..\\static\\image\\73d4d6f59f0f48aea0c6d7e3c808d0ce.png\" width=\"1200\"/></strong></p>\n<p><strong>        å¦‚æœä¸æ³¨æ„å¤§å°ç«¯çš„é—®é¢˜ï¼Œé‚£ä¹ˆå¯èƒ½å†™å’Œè¯»çš„æ—¶å€™éƒ½ä¼šè¯»åã€‚æ‰€ä»¥ç½‘ç»œå¿…é¡»è§£å†³å¤§å°ç«¯çš„é—®é¢˜ã€‚</strong></p>\n<p><strong><span style=\"color:#1c7331;\">é‚£ä¹ˆå¦‚ä½•è§£å†³å‘¢ï¼Ÿ</span></strong></p>\n<p><strong>        è§„å®šç½‘ç»œåºåˆ—ï¼šç½‘è·¯ä¸Šçš„æ•°æ®å¿…é¡»éƒ½æ˜¯å¤§ç«¯ã€‚</strong></p>\n<p><strong>        ä¾‹å¦‚ä» client åˆ°ç½‘ç»œè¦ä»¥å¤§ç«¯çš„æ–¹å¼ä¼ è¾“ï¼Œä»ç½‘ç»œåˆ° server ï¼Œå¦‚æœ server æ˜¯å¤§ç«¯æœºå™¨å°±ä¹‹é—´å‘ä¸Šè§£é‡Šï¼Œå¦‚æœæ˜¯å°ç«¯å°±åè¿‡æ¥å‘ä¸Šè§£é‡Šå°±å¯ä»¥äº†ã€‚</strong></p>\n<hr/>\n<p><strong>        ä¸ºä½¿ç½‘ç»œç¨‹åºå…·æœ‰å¯ç§»æ¤æ€§,ä½¿åŒæ ·çš„Cä»£ç åœ¨å¤§ç«¯å’Œå°ç«¯è®¡ç®—æœºä¸Šç¼–è¯‘åéƒ½èƒ½æ­£å¸¸è¿è¡Œ,å¯ä»¥è°ƒç”¨ä»¥ä¸‹åº“å‡½æ•°åšç½‘ç»œ å­—èŠ‚åºå’Œä¸»æœºå­—èŠ‚åºçš„è½¬æ¢ã€‚</strong></p>\n<p><strong><img alt=\"\" height=\"210\" src=\"..\\..\\static\\image\\422ced757a8545498302d0cb98086e60.png\" width=\"1184\"/></strong></p>\n<blockquote>\n<ul><li><strong>è¿™äº›å‡½æ•°åå¾ˆå¥½è®°ï¼Œh è¡¨ç¤º hostï¼Œn è¡¨ç¤ºnetworkï¼Œl è¡¨ç¤º 32 ä½é•¿æ•´æ•°ï¼Œs è¡¨ç¤º 16 ä½çŸ­æ•´æ•°ã€‚</strong></li><li><strong>ä¾‹å¦‚ htonl è¡¨ç¤ºå°† 32 ä½çš„é•¿æ•´æ•°ä»ä¸»æœºå­—èŠ‚åºè½¬æ¢ä¸ºç½‘ç»œå­—èŠ‚åºï¼Œä¾‹å¦‚å°†IPåœ°å€è½¬æ¢åå‡†å¤‡å‘é€ã€‚</strong></li><li><strong>å¦‚æœä¸»æœºæ˜¯å°ç«¯å­—èŠ‚åºï¼Œè¿™äº›å‡½æ•°å°†å‚æ•°åšç›¸åº”çš„å¤§å°ç«¯è½¬æ¢ç„¶åè¿”å›ã€‚</strong></li><li><strong>å¦‚æœä¸»æœºæ˜¯å¤§ç«¯å­—èŠ‚åºï¼Œè¿™äº›å‡½æ•°ä¸åšè½¬æ¢ï¼Œå°†å‚æ•°åŸå°ä¸åŠ¨åœ°è¿”å›ã€‚</strong></li></ul>\n</blockquote>\n<h1 id=\"2.%20socket%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3\"><strong><span style=\"color:#faa572;\">2. socketç¼–ç¨‹æ¥å£</span></strong></h1>\n<h2 id=\"2.1%20socket%20%E5%B8%B8%E8%A7%81API\"><strong><span style=\"color:#9c8ec1;\">2.1 socket å¸¸è§API</span></strong></h2>\n<pre><code class=\"language-cpp\">// åˆ›å»º socket æ–‡ä»¶æè¿°ç¬¦ (TCP/UDP, å®¢æˆ·ç«¯ + æœåŠ¡å™¨)\nint socket(int domain, int type, int protocol);\n// ç»‘å®šç«¯å£å· (TCP/UDP, æœåŠ¡å™¨)\nint bind(int socket, const struct sockaddr *address,\n socklen_t address_len);\n// å¼€å§‹ç›‘å¬socket (TCP, æœåŠ¡å™¨)\nint listen(int socket, int backlog);\n// æ¥æ”¶è¯·æ±‚ (TCP, æœåŠ¡å™¨)\nint accept(int socket, struct sockaddr* address,\n socklen_t* address_len);\n// å»ºç«‹è¿æ¥ (TCP, å®¢æˆ·ç«¯)\nint connect(int sockfd, const struct sockaddr *addr,\n socklen_t addrlen);</code></pre>\n<h2 id=\"2.2%C2%A0sockaddr%E7%BB%93%E6%9E%84\"><strong><span style=\"color:#9c8ec1;\">2.2 sockaddrç»“æ„</span></strong></h2>\n<p><strong>        socket API æ˜¯ä¸€å±‚æŠ½è±¡çš„ç½‘ç»œç¼–ç¨‹æ¥å£ï¼Œé€‚ç”¨äºå„ç§åº•å±‚ç½‘ç»œåè®®ï¼Œå¦‚IPv4ã€IPv6ï¼Œä»¥åŠåé¢è¦è®²çš„UNIX Domain Socketã€‚ç„¶è€Œï¼Œå„ç§ç½‘ç»œåè®®çš„åœ°å€æ ¼å¼å¹¶ä¸ç›¸åŒã€‚</strong></p>\n<p><strong><img alt=\"\" height=\"814\" src=\"..\\..\\static\\image\\1680c720afbe41d58dea8f3df5b2b1e7.png\" width=\"749\"/></strong></p>\n<blockquote>\n<ul><li><strong>IPv4 å’Œ IPv6 çš„åœ°å€æ ¼å¼å®šä¹‰åœ¨netinet/in.hä¸­ï¼ŒIPv4 åœ°å€ç”¨ sockaddr_in ç»“æ„ä½“è¡¨ç¤ºï¼ŒåŒ…æ‹¬16ä½åœ°å€ç±»å‹ï¼Œ16 ä½ç«¯å£å·å’Œ 32 ä½ IP åœ°å€ã€‚</strong></li><li><strong>IPv4ã€IPv6åœ°å€ç±»å‹åˆ†åˆ«å®šä¹‰ä¸ºå¸¸æ•° AF_INETã€AF_INET6ã€‚è¿™æ ·ï¼Œåªè¦å–å¾—æŸç§ sockaddr ç»“æ„ä½“çš„é¦–åœ°å€ï¼Œä¸éœ€è¦çŸ¥é“å…·ä½“æ˜¯å“ªç§ç±»å‹çš„ sockaddr ç»“æ„ä½“ï¼Œå°±å¯ä»¥æ ¹æ®åœ°å€ç±»å‹å­—æ®µç¡®å®šç»“æ„ä½“ä¸­çš„å†…å®¹ã€‚</strong></li><li><strong>socket APIå¯ä»¥éƒ½ç”¨struct sockaddr *ç±»å‹è¡¨ç¤º, åœ¨ä½¿ç”¨çš„æ—¶å€™éœ€è¦å¼ºåˆ¶è½¬åŒ–æˆsockaddr_inã€‚è¿™æ ·çš„å¥½å¤„æ˜¯ç¨‹åºçš„é€šç”¨æ€§ï¼Œå¯ä»¥æ¥æ”¶IPv4ï¼Œ IPv6ï¼Œä»¥åŠUNIX Domain Socket å„ç§ç±»å‹çš„sockaddr ç»“æ„ä½“æŒ‡é’ˆåšä¸ºå‚æ•°ã€‚</strong></li></ul>\n</blockquote>\n<h3 id=\"sockaddr%20%E7%BB%93%E6%9E%84\"><strong><span style=\"color:#ad720d;\">sockaddr ç»“æ„</span></strong></h3>\n<p><strong><img alt=\"\" height=\"124\" src=\"..\\..\\static\\image\\93738d280eea4535a826e9b2341fabc4.png\" width=\"883\"/></strong></p>\n<h3 id=\"%C2%A0sockaddr_in%20%E7%BB%93%E6%9E%84\"><strong><span style=\"color:#ad720d;\"> sockaddr_in ç»“æ„</span></strong></h3>\n<p><strong><img alt=\"\" height=\"315\" src=\"..\\..\\static\\image\\8960d98be0984456b09fd335a7b5faa2.png\" width=\"694\"/></strong></p>\n<p><strong>         è™½ç„¶ socket api çš„æ¥å£æ˜¯sockaddrï¼Œä½†æ˜¯æˆ‘ä»¬çœŸæ­£åœ¨åŸºäº IPv4 ç¼–ç¨‹æ—¶ï¼Œä½¿ç”¨çš„æ•°æ®ç»“æ„æ˜¯sockaddr_inã€‚è¿™ä¸ªç»“æ„é‡Œä¸»è¦æœ‰ä¸‰éƒ¨åˆ†ä¿¡æ¯ï¼šåœ°å€ç±»å‹, ç«¯å£å·ï¼ŒIP åœ°å€ã€‚</strong></p>\n<h3 id=\"in_addr%E7%BB%93%E6%9E%84\"><strong><span style=\"color:#ad720d;\">in_addrç»“æ„</span></strong></h3>\n<p><strong><img alt=\"\" height=\"172\" src=\"..\\..\\static\\image\\b155cecb10bc45f78941c6df56b734c6.png\" width=\"384\"/></strong></p>\n<p><strong>        in_addr ç”¨æ¥è¡¨ç¤ºä¸€ä¸ª IPv4 çš„ IP åœ°å€ã€‚å…¶å®å°±æ˜¯ä¸€ä¸ª32ä½çš„æ•´æ•°ã€‚</strong></p>\n<h1 id=\"3.%20%E7%AE%80%E5%8D%95%E7%9A%84UDP%E7%BD%91%E7%BB%9C%E7%A8%8B%E5%BA%8F\"><strong><span style=\"color:#faa572;\">3. ç®€å•çš„UDPç½‘ç»œç¨‹åº</span></strong></h1>\n<h2 id=\"3.1%20%E6%8E%A5%E5%8F%A3\"><strong><span style=\"color:#9c8ec1;\">3.1 æ¥å£</span></strong></h2>\n<h3 id=\"3.1.1%20%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E6%8E%A5%E5%8F%A3\"><strong><span style=\"color:#ad720d;\">3.1.1 åˆå§‹åŒ–çš„æ¥å£</span></strong></h3>\n<p><strong><img alt=\"\" height=\"388\" src=\"..\\..\\static\\image\\defb0797d0be40508ca1ead153caa1c6.png\" width=\"1200\"/></strong></p>\n<p><strong><img alt=\"\" height=\"89\" src=\"..\\..\\static\\image\\4c8f3195b50a4be9b1133e38fe10ed81.png\" width=\"1200\"/></strong></p>\n<p><strong><img alt=\"\" height=\"235\" src=\"..\\..\\static\\image\\6bc66875752a4f678c4dbaad0282261d.png\" width=\"1174\"/></strong></p>\n<p><strong><img alt=\"\" height=\"395\" src=\"..\\..\\static\\image\\261162af1e3e48efad5591f28b66e75e.png\" width=\"1138\"/></strong></p>\n<p><strong><img alt=\"\" height=\"314\" src=\"..\\..\\static\\image\\992801923f0044c1ae4caa5d6ab962ab.png\" width=\"815\"/></strong></p>\n<p><strong><img alt=\"\" height=\"452\" src=\"..\\..\\static\\image\\1022c305584e4b99a2d2f142ad85b5bc.png\" width=\"656\"/></strong></p>\n<h3 id=\"3.1.2%20%E8%BF%90%E8%A1%8C%E8%B5%B7%E6%9D%A5%E9%9C%80%E8%A6%81%E7%9A%84%E6%8E%A5%E5%8F%A3\"><strong><span style=\"color:#ad720d;\">3.1.2 è¿è¡Œèµ·æ¥éœ€è¦çš„æ¥å£</span></strong></h3>\n<p><strong><img alt=\"\" height=\"354\" src=\"..\\..\\static\\image\\3c466e6e3a574aa1b69a3efc6e5a0eb4.png\" width=\"1200\"/></strong></p>\n<h2 id=\"3.2%20%E5%AE%9E%E7%8E%B0%20UDP\"><strong><span style=\"color:#9c8ec1;\">3.2 å®ç° UDP</span></strong></h2>\n<h3 id=\"udp_server.hpp\"><strong><span style=\"color:#ad720d;\">udp_server.hpp</span></strong></h3>\n<pre><code class=\"language-cpp\">  1 #pragma once\n  2 \n  3 #include &lt;iostream&gt;\n  4 #include &lt;string&gt;\n  5 #include &lt;cstring&gt;\n  6 #include &lt;sys/socket.h&gt;\n  7 #include &lt;sys/types.h&gt;\n  8 #include &lt;netinet/in.h&gt;\n  9 #include &lt;arpa/inet.h&gt;\n 10 \n 11 \n 12 #define DEFAULT 8081\n 13 \n 14 class UdpServer{\n 15   private:\n 16     short port;\n 17     int sockfd;\n 18     std::string ip;\n 19   public:\n 20     UdpServer(std::string _ip, int _port = DEFAULT)\n 21       : port(_port)\n 22       , sockfd(-1)\n 23       , ip(_ip)                                                                                                                         \n 24     {}\n 25 \n 26     bool InitUdpServer()\n 27     {\n 28       sockfd = socket(AF_INET, SOCK_DGRAM, 0);\n 29       if(sockfd &lt; 0){\n 30         std::cerr &lt;&lt; \"socket error\" &lt;&lt; std::endl;\n 31         return false;\n 32       }\n 33       std::cout &lt;&lt; \"socket create success, sockfd: \" &lt;&lt; sockfd &lt;&lt; std::endl;//å¤§æ¦‚ç‡æ˜¯3                                                 \n 34 \n 35 \n 36       struct sockaddr_in local;\n 37       memset(&amp;local, '\\0', sizeof(local));\n 38       local.sin_family = AF_INET;\n 39       local.sin_port = htons(port);\n 40       local.sin_addr.s_addr = inet_addr(ip.c_str());\n 41 \n 42       if(bind(sockfd, (struct sockaddr*)&amp;local, sizeof(local)) &lt; 0){\n 43         std::cerr &lt;&lt; \"bind error\" &lt;&lt; std::endl;\n 44         return false;\n 45       }\n 46       std::cout &lt;&lt; \"bind success\" &lt;&lt; std::endl;\n 47 \n 48 \n 49       return true;\n 50     }\n 51     \n 52     void Start()\n 53     {\n 54 #define SIZE 128\n 55       char buffer[SIZE];\n 56       for( ; ; ){\n 57         struct sockaddr_in peer;                                                                                                        \n 58         socklen_t len = sizeof(peer);\n 59         ssize_t size = recvfrom(sockfd, buffer, sizeof(buffer)-1, 0, (struct sockaddr*)&amp;peer, &amp;len);\n 60         if(size &gt; 0){\n 61           buffer[size] = 0;\n 62           short _port = ntohs(peer.sin_port);\n 63           std::string _ip = inet_ntoa(peer.sin_addr);\n 64           std::cout &lt;&lt; _ip &lt;&lt; \":\" &lt;&lt; _port &lt;&lt; \"# \" &lt;&lt; buffer &lt;&lt; std::endl;\n 65         }\n 66         else{\n 67           std::cerr &lt;&lt; \"recvfrom error\" &lt;&lt; std::endl;\n 68         }\n 69       }\n 70     }\n 71 \n 72     ~UdpServer()\n 73     {}\n 74 };\n</code></pre>\n<p><strong>        ç°åœ¨åªå†™äº†æœåŠ¡å™¨çš„ç«¯å£ï¼Œå› ä¸ºæ²¡æœ‰å†™ç”¨æˆ·çš„ï¼Œä½†æ˜¯æˆ‘ä»¬æƒ³çœ‹ä¸€ä¸‹æˆ‘ä»¬å¯ä»¥ä¸å¯ä»¥è®©åˆ«äººè®¿é—®åˆ°ï¼š</strong></p>\n<p><strong><img alt=\"\" height=\"117\" src=\"..\\..\\static\\image\\86b53bfae3b74bc38e2bbe4fba7e1283.png\" width=\"566\"/></strong></p>\n<p><strong>netstat ç”¨æ¥æŸ¥çœ‹ç½‘ç»œçŠ¶æ€ï¼š</strong></p>\n<blockquote>\n<ul><li><strong>-nï¼šèƒ½æ˜¾ç¤ºå‡ºæ•°å­—å°±æ˜¾ç¤ºå‡ºæ•°å­—</strong></li><li><strong>-lï¼šåˆ—è¡¨</strong></li><li><strong>-t  -uï¼šä¸€ä¸ªæ˜¯tcp ä¸€ä¸ªæ˜¯udp</strong></li><li><strong>-pï¼šæŸ¥çœ‹è¿›ç¨‹ç›¸å…³çš„ä¿¡æ¯</strong></li></ul>\n</blockquote>\n<p><strong><img alt=\"\" height=\"307\" src=\"..\\..\\static\\image\\0a005faee86347d1b8a21e13210dbb78.png\" width=\"1200\"/></strong></p>\n<p><strong>        Local Address æ˜¯ IP åœ°å€å’Œç«¯å£å·ã€‚</strong></p>\n<p><strong>        Foreign Address æ˜¯å¯¹ç«¯çš„ IP åœ°å€å’Œç«¯å£å·ï¼Œ0.0.0.0ï¼š* è¡¨ç¤ºçš„æ˜¯ä»»æ„çš„ IPï¼Œä»»æ„çš„ç«¯å£éƒ½å¯ä»¥ç»™æˆ‘å‘é€ä¿¡æ¯ã€‚</strong></p>\n<p><strong>        æœ€åé¢çš„å°±æ˜¯ PID å’Œç¨‹åºçš„åå­—ã€‚</strong></p>\n<p><strong>        é‚£ä¹ˆæ¥ä¸‹æ¥æˆ‘ä»¬å°±éœ€è¦å†™ client äº†ã€‚</strong></p>\n<p><strong><span style=\"color:#1c7331;\">å®¢æˆ·ç«¯éœ€è¦portä¹ˆï¼Ÿå®¢æˆ·ç«¯éœ€è¦ç»‘å®šä¹ˆï¼Ÿ</span></strong></p>\n<p><strong>        å½“ç„¶éœ€è¦ port ï¼Œå› ä¸ºè¿™é‡Œå«åšç½‘ç»œç¼–ç¨‹ã€å¥—æ¥å­—ç¼–ç¨‹ï¼Œé‚£ä¹ˆå®¢æˆ·ç«¯å’ŒæœåŠ¡å™¨éƒ½éœ€è¦ç«¯å£ï¼Œä½†æ˜¯å®¢æˆ·ç«¯æ˜¯ä¸éœ€è¦ç»‘å®šçš„ï¼Œåœ¨è®²è§£è¿™ä¸ªé—®é¢˜å‰å…ˆè¯´ä¸€ä¸‹ï¼š</strong></p>\n<p><strong>        æœåŠ¡å™¨ä¸ºä½•è¦bindä¸€ä¸ªç«¯å£ï¼šæœåŠ¡å™¨æ˜¯ä¸ºäº†ç»™åˆ«äººæä¾›æœåŠ¡çš„ï¼Œåˆ«äººä¸€å®šè¦çŸ¥é“ä½ çš„ ip å’Œç«¯å£ï¼Œæ‰€ä»¥ç«¯å£ä¸€å®šè¦æ˜¯ä¸€ä¸ªä¼—æ‰€å‘¨çŸ¥çš„ç«¯å£ï¼Œè€Œä¸” bind ä¹‹åï¼Œä¸èƒ½è½»æ˜“æ”¹å˜ï¼Œè¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆæœåŠ¡å™¨éœ€è¦ bind ä¸€ä¸ªç«¯å£ï¼Œå› ä¸ºåªæœ‰ bind äº†ä¹‹åè¿™ä¸ªç«¯å£æ‰çœŸæ­£çš„å±äºå®ƒè€Œä¸å±äºåˆ«äººã€‚</strong></p>\n<p><strong>        é‚£ä¹ˆç°åœ¨å†ä¸ºä»€ä¹ˆå®¢æˆ·ç«¯ä¸éœ€è¦ç»‘å®šï¼šè¿™é‡Œæ˜¯ä¸éœ€è¦ï¼Œè€Œä¸æ˜¯ä¸èƒ½ã€‚ä½†æ˜¯ä¸€èˆ¬æƒ…å†µä¸‹æ˜¯ä¸ç»‘å®šçš„ï¼Œå› ä¸ºå®¢æˆ·ç«¯è®¿é—®æœåŠ¡å™¨ï¼Œç«¯å£åªè¦æ˜¯å”¯ä¸€çš„å³å¯ï¼Œä¸éœ€è¦å’Œç‰¹å®š client è¿›ç¨‹å¼ºç›¸å…³ï¼Œclient ç«¯å£å¯ä»¥åŠ¨æ€çš„è®¾ç½®ï¼Œè¦è¯´ç»‘å®šçš„è¯ä¼šæœ‰å¾ˆå¤šé—®é¢˜ï¼Œæ¯”æ–¹è¯´ bind çš„æ˜¯ 8088ï¼Œå¦‚æœ 8088 è¢«åˆ«äººå ç”¨äº†ï¼Œé‚£ä¹ˆè¿™ä¸ªå®¢æˆ·ç«¯å°±å¯åŠ¨ä¸èµ·æ¥ã€‚</strong></p>\n<p><strong>        æ‰€ä»¥å®¢æˆ·ç«¯åªéœ€è¦è°ƒç”¨è¯¥ sendto ç±»ä¼¼çš„æ¥å£ï¼Œclient ç›´æ¥åœ¨ OS å±‚é¢ä¼šè‡ªåŠ¨ç»™ client è·å–ä¸€ä¸ªå”¯ä¸€çš„ç«¯å£ã€‚</strong></p>\n<h3 id=\"udp_server.cc\"><strong><span style=\"color:#ad720d;\">udp_server.cc</span></strong></h3>\n<pre><code class=\"language-cpp\">  1 #include \"udp_server.hpp\"\n  2 \n  3 //./udp_server port\n  4 \n  5 int main(int argc, char* argv[])\n  6 {\n  7   if(argc != 2){\n  8     std::cerr &lt;&lt; \"Usage: \" &lt;&lt; argv[0] &lt;&lt; \" port\" &lt;&lt; std::endl;\n  9     return 1;\n 10   }\n 11 \n 12   std::string ip = \"127.0.0.1\"; //127.0.0.1 == localhost : æ ‡è¯†æœ¬æœºå™¨ ï¼š æœ¬åœ°ç¯å›\n 13   int port = atoi(argv[1]);                                                                        \n 14 \n 15   UdpServer* svr = new UdpServer(ip, port);\n 16   svr-&gt;InitUdpServer();\n 17 \n 18   svr-&gt;Start();\n 19   return 0;\n 20 }\n</code></pre>\n<h3 id=\"udp_client.hpp\"><strong><span style=\"color:#ad720d;\">udp_client.hpp</span></strong></h3>\n<pre><code class=\"language-cpp\">  1 #pragma once\n  2 \n  3 #include &lt;iostream&gt;\n  4 #include &lt;string&gt;\n  5 #include &lt;cstring&gt;\n  6 #include &lt;sys/socket.h&gt;\n  7 #include &lt;sys/types.h&gt;\n  8 #include &lt;arpa/inet.h&gt;\n  9 #include &lt;netinet/in.h&gt;\n 10 \n 11 \n 12 class UdpClient{\n 13   private:\n 14     int sockfd;\n 15     std::string ip;\n 16     int port;\n 17   public:\n 18     UdpClient(std::string _ip, int _port)\n 19       :ip(_ip)\n 20       , port(_port)\n 21   {}\n 22     bool InitUdpClient()\n 23     {                                                                                              \n 24       sockfd = socket(AF_INET, SOCK_DGRAM, 0);\n 25       if(sockfd &lt; 0){\n 26         std::cerr &lt;&lt; \"socket error!\" &lt;&lt; std::endl;\n 27         return false;\n 28       }\n 29       return true;\n 30     }\n 31     void Start()\n 32     {\n 33       struct sockaddr_in peer;                                                                     \n 34       memset(&amp;peer, 0, sizeof(peer));\n 35       peer.sin_family = AF_INET;\n 36       peer.sin_port = htons(port);\n 37       peer.sin_addr.s_addr = inet_addr(ip.c_str());\n 38 \n 39       std::string msg;\n 40       for(; ; ){\n 41         std::cout &lt;&lt; \"Pleace Enter# \";\n 42         std::cin &gt;&gt; msg;\n 43         sendto(sockfd, msg.c_str(), msg.size(), 0,(struct sockaddr*) &amp;peer, sizeof(peer));\n 44       }\n 45 \n 46 \n 47     }\n 48     ~UdpClient()\n 49     {}\n 50 };\n</code></pre>\n<h3 id=\"udp_client.cc\"><strong><span style=\"color:#ad720d;\">udp_client.cc</span></strong></h3>\n<pre><code class=\"language-cpp\">  1 #include \"udp_client.hpp\"\n  2 \n  3 //./udp_cilent ip port\n  4 int main(int argc, char* argv[])\n  5 {\n  6   if(argc != 3){\n  7     std::cerr &lt;&lt; \"Usage: \" &lt;&lt; argv[0] &lt;&lt; \"ip port\" &lt;&lt; std::endl;\n  8     return 1;\n  9   }\n 10   std::string ip = argv[1];\n 11   int port = atoi(argv[2]);                                                                        \n 12   UdpClient* uclt = new UdpClient(ip, port);\n 13   uclt-&gt;InitUdpClient();\n 14 \n 15   uclt-&gt;Start();\n 16 \n 17   return 0;\n 18 }</code></pre>\n<p><strong>        å› ä¸º<span style=\"color:#79c6cd;\">è¿™é‡Œæˆ‘ä»¬ç»‘å®šçš„ä¸æ˜¯å¤–ç½‘ï¼Œè€Œæ˜¯æœ¬åœ°ç¯å›</span>ï¼Œæˆ‘ä»¬æ¥ä¸‹æ¥é€šä¿¡ä¸€ä¸‹ï¼š</strong></p>\n<p><strong><img alt=\"\" height=\"274\" src=\"..\\..\\static\\image\\2f8902254cfa434aa4896a048788d50c.png\" width=\"1200\"/></strong></p>\n<p><strong>        æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œæˆ‘ä»¬å®Œæˆäº†é€šä¿¡ã€‚</strong></p>\n<p><strong><img alt=\"\" height=\"317\" src=\"..\\..\\static\\image\\91923d41a2c84eda9e3dd4cd7786b4a3.png\" width=\"1200\"/></strong></p>\n<p><strong>        æˆ‘ä»¬å¯ä»¥é€šè¿‡ç½‘ç»œå·¥å…·æŸ¥çœ‹åˆ°è¿™ä¸¤ä¸ªæœåŠ¡å™¨ã€‚</strong></p>\n<p><strong><span style=\"color:#1c7331;\">é‚£ä¹ˆå¦‚æœæˆ‘ä»¬çš„ IP åœ°å€ç»‘å®šçš„æ˜¯å…¬ç½‘ IP ï¼Œé‚£ä¹ˆæˆ‘ä»¬çš„ udp_server å°±å¯ä»¥è¢«å¤–ç½‘è®¿é—®å‘¢ï¼Ÿ</span></strong></p>\n<p><strong><img alt=\"\" height=\"124\" src=\"..\\..\\static\\image\\92508bb931b64296a07f9a6af2226905.png\" width=\"1104\"/></strong></p>\n<p><strong>        é‚£ä¹ˆæ­¤æ—¶æˆ‘æ¢ä¸Šæˆ‘çš„å…¬ç½‘ IP è¯•è¯•ã€‚</strong></p>\n<p><strong><img alt=\"\" height=\"223\" src=\"..\\..\\static\\image\\a7220311f4954eae91e53fb3fd33fae9.png\" width=\"552\"/></strong></p>\n<p><strong>        æˆ‘ä»¬å¯ä»¥çœ‹åˆ°æ¯æ¬¡ bind éƒ½æ˜¯å¤±è´¥çš„ï¼Œæ‰€ä»¥ï¼š</strong></p>\n<p><strong>        å…¶å®äº‘æœåŠ¡å™¨çš„ ipï¼Œæ˜¯ç”±å¯¹åº”çš„äº‘å‚å•†æä¾›çš„ï¼Œè¿™ä¸ª ip å¹¶ä¸ä¸€å®šæ˜¯çœŸæ­£çš„å…¬ç½‘ ipï¼Œå½“ç„¶æœ‰å¯èƒ½è¿™ä¸ªäº‘æœåŠ¡å™¨æ”¶åˆ°å…¬ç½‘ ip å†åšä¸€ä¸‹è½¬å‘çš„å·¥ä½œï¼Œä½†æ˜¯ç°åœ¨ä¸ç®¡è¿™ä¸ªã€‚</strong></p>\n<p><strong>        æ‰€ä»¥è¿™ä¸ª ip ä¸èƒ½ç›´æ¥è¢«ç»‘å®šï¼Œå¦‚æœéœ€è¦ bindï¼Œéœ€è¦è®©å¤–ç½‘è®¿é—®ï¼Œéœ€è¦ bind 0 ï¼ŒINADDR_ANY -&gt; 0 ï¼Œè¿™ä¸ªå°±æ˜¯ä¸ªå®ï¼Œè¿™ä¸ªå®æ˜¯ 0 ã€‚ bind 0 æ„å‘³ç€æœåŠ¡å™¨å¯ä»¥æ¥æ”¶æ¥è‡ªä»»ä½• client çš„è¯·æ±‚ã€‚</strong></p>\n<p><strong>        ä½†æ˜¯æœ‰æ²¡æœ‰å¯èƒ½ä¸€ä¸ªæœåŠ¡å™¨æœ‰å¤šå¼ ç½‘å¡å‘¢ï¼Ÿå½“ç„¶æ˜¯æœ‰å¯èƒ½ï¼Œé‚£ä¹ˆå½“ç„¶ä¹Ÿå°±æœ‰å¤šä¸ª ipã€‚</strong></p>\n<p><strong><img alt=\"\" height=\"318\" src=\"..\\..\\static\\image\\bb4c2d35d0684c39b4437371d6fe8fe2.png\" width=\"481\"/></strong></p>\n<p><strong>        æ‰€ä»¥ INADDR_ANY ä¹Ÿæ˜¯å¼ºçƒˆæ¨èä½¿ç”¨çš„ã€‚</strong></p>\n<p><strong>        æ‰€ä»¥æˆ‘ä»¬å…¶å®å°±ä¸éœ€è¦å»å†™ ipã€‚</strong></p>\n<p><strong><img alt=\"\" height=\"332\" src=\"..\\..\\static\\image\\ed1c6b516ead4809aae22f0ffedb75a1.png\" width=\"1200\"/></strong></p>\n<p><strong>        æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œå‰é¢çš„æ˜¯ 127.0.0.1 ï¼Œæ­¤æ—¶çš„å°±æ˜¯ 0.0.0.0ï¼Œä¹Ÿå°±æ„å‘³ç€æˆ‘ä»¬å¯ä»¥åœ¨æœ¬åœ°è¯»å–ä»»ä½•ä¸€å¼ ç½‘å¡é‡Œçš„æ•°æ®ï¼Œåªè¦èƒ½å‘è¿‡å»ï¼Œå°±èƒ½æ¥æ”¶ã€‚</strong></p>\n<p><strong><span style=\"color:#1c7331;\">æˆ‘ä»¬ç°åœ¨åªåšäº†è¯»å–ï¼Œé‚£ä¹ˆå¦‚æœæƒ³è¦å†å‘é€å›å»å‘¢ï¼Ÿ</span></strong></p>\n<p><strong>        é‚£ä¹ˆæ¥ä¸‹æ¥å°±å†™ä¸€ä¸ªå›å£°æœåŠ¡å™¨ï¼Œå°±æ˜¯å®¢æˆ·ç«¯å‘ä»€ä¹ˆæ•°æ®ï¼ŒæœåŠ¡å™¨å°±ç»™è¿”å›å»ã€‚</strong></p>\n<p><strong><img alt=\"\" height=\"745\" src=\"..\\..\\static\\image\\1528f25f32894719bc9964a97ebb8158.png\" width=\"1189\"/></strong></p>\n<p><strong>        æˆ‘ä»¬åªè¦åŠ ä¸Šä¸Šé¢çº¢æ¡†çš„å†…å®¹å°±å¯ä»¥ï¼Œå…¶å®ä¹Ÿå°±æ˜¯å† server é‡Œæ·»åŠ ä¸€ä¸ªå‘é€ä¼ è¿‡æ¥çš„å­—ç¬¦ä¸²çš„æ¥å£ï¼Œç„¶åå†è®© client æ¥æ”¶ server ä¼ è¿‡æ¥çš„å­—ç¬¦ä¸²å†æ‰“å°ä¸‹æ¥å°±å¯ä»¥äº†ã€‚</strong></p>\n<p><strong><img alt=\"\" height=\"226\" src=\"..\\..\\static\\image\\875d3399dd124349ba65d76977890270.png\" width=\"1200\"/></strong></p>\n<p><strong>         æ¥ä¸‹æ¥å°±å†™ä¸€ä¸ªç®€å•çš„ä¸šåŠ¡ï¼š</strong></p>\n<p><strong><img alt=\"\" height=\"359\" src=\"..\\..\\static\\image\\c12b9f62be1746e2ac643a18d7b88d35.png\" width=\"916\"/></strong></p>\n<p><strong>        æˆ‘ä»¬åªåœ¨ udp_server ä¸­åˆ›å»ºä¸€ä¸ªå­è¿›ç¨‹ï¼Œè®©å­è¿›ç¨‹å»å®Œæˆè¿™ä¸ªä¸šåŠ¡å°±å¥½ã€‚</strong></p>\n<p><strong><img alt=\"\" height=\"408\" src=\"..\\..\\static\\image\\e5a9c11315024d62bc1e1a3f17be7942.png\" width=\"1200\"/></strong></p>\n<p><strong>         æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œå®¢æˆ·ç«¯è¾“å…¥ lsï¼ŒæœåŠ¡ç«¯ä¹Ÿå®Œæˆäº†å¯¹åº”çš„ä¸šåŠ¡ã€‚</strong></p>\n<p><strong>        é‚£ä¹ˆæ¥ä¸‹æ¥æƒ³è¦å†å›æ˜¾ç»™å®¢æˆ·ç«¯ï¼š</strong></p>\n<pre><code class=\"language-cpp\">  1 #pragma once\n  2 \n  3 #include &lt;iostream&gt;\n  4 #include &lt;string&gt;\n  5 #include &lt;cstring&gt;\n  6 #include &lt;sys/socket.h&gt;\n  7 #include &lt;sys/types.h&gt;\n  8 #include &lt;netinet/in.h&gt;\n  9 #include &lt;arpa/inet.h&gt;\n 10 #include &lt;unistd.h&gt;\n 11 #include &lt;sys/wait.h&gt;\n 12 #define DEFAULT 8081\n 13 \n 14 class UdpServer{\n 15   private:\n 16     int port;\n 17     int sockfd;\n 18     //std::string ip;\n 19   public:\n 20     UdpServer(int _port = DEFAULT)\n 21       : port(_port)\n 22       , sockfd(-1)\n 23     {}                                                                                                                \n 24 \n 25     bool InitUdpServer()\n 26     {\n 27       sockfd = socket(AF_INET, SOCK_DGRAM, 0);\n 28       if(sockfd &lt; 0){\n 29         std::cerr &lt;&lt; \"socket error\" &lt;&lt; std::endl;\n 30         return false;\n 31       }\n 32       std::cout &lt;&lt; \"socket create success, sockfd: \" &lt;&lt; sockfd &lt;&lt; std::endl;//å¤§æ¦‚ç‡æ˜¯3\n 33                                                                                                                       \n 34 \n 35       struct sockaddr_in local;//ç½‘ç»œé€šä¿¡åœ°å€\n 36       memset(&amp;local, '\\0', sizeof(local));\n 37       local.sin_family = AF_INET;\n 38       local.sin_port = htons(port);//ç«¯å£å·\n 39       //local.sin_addr.s_addr = inet_addr(ip.c_str());\n 40       local.sin_addr.s_addr = INADDR_ANY;\n 41       if(bind(sockfd, (struct sockaddr*)&amp;local, sizeof(local)) &lt; 0){\n 42         std::cerr &lt;&lt; \"bind error\" &lt;&lt; std::endl;\n 43         return false;\n 44       }\n 45       std::cout &lt;&lt; \"bind success\" &lt;&lt; std::endl;\n 46 \n 47 \n 48       return true;\n 49     }\n 50     \n 51     void Start()\n 52     {\n 53 #define SIZE 128\n 54       char buffer[SIZE];\n 55 \n 56       for( ; ; ){\n 57         struct sockaddr_in peer;\n 58         socklen_t len = sizeof(peer);\n 59         ssize_t size = recvfrom(sockfd, buffer, sizeof(buffer)-1, 0, (struct sockaddr*)&amp;peer, &amp;len);\n 60         if(size &gt; 0){                                                                                                 \n 61           buffer[size] = 0;\n 62           int _port = ntohs(peer.sin_port);\n 63           std::string _ip = inet_ntoa(peer.sin_addr);\n 64           std::cout &lt;&lt; _ip &lt;&lt; \":\" &lt;&lt; _port &lt;&lt; \"# \" &lt;&lt; buffer &lt;&lt; std::endl;\n 65 \n 66           std::string cmd = buffer;\n 67           std::string result;\n 68           if(cmd == \"ls\"){\n 69             int pipes[2];\n 70             pipe(pipes);\n 71 \n 72             pid_t id = fork();\n 73             if(id == 0){\n 74               close(pipes[0]);//å­è¿›ç¨‹è¦å†™ï¼Œæ‰€ä»¥å…³é—­è¯»\n 75               dup2(pipes[1], 1);\n 76               execl(\"/usr/bin/ls\", \"ls\", \"-a\", \"-l\", \"-i\", nullptr);\n 77               exit(1);\n 78             }\n 79             close(pipes[1]);//çˆ¶è¿›ç¨‹è¦è¯»ï¼Œæ‰€ä»¥è¦å…³é—­å†™\n 80             char c;\n 81             while(1){\n 82               if(read(pipes[0], &amp;c, 1) &gt; 0){\n 83                 result.push_back(c);\n 84               }\n 85               else{\n 86                 break;\n 87               }\n 88             }\n 89             wait(nullptr);\n 90           }                                                                                                           \n 91 \n 92           std::string echo_msg;\n 93           if(result.empty()){\n 94             echo_msg = \"server get!-&gt;\";\n 95             echo_msg += buffer;\n 96           }\n 97           else{\n 98             echo_msg = result;\n 99           }\n100           sendto(sockfd, echo_msg.c_str(), echo_msg.size(), 0, (struct sockaddr*)&amp;peer, len);\n101         }\n102         else{\n103           std::cerr &lt;&lt; \"recvfrom error\" &lt;&lt; std::endl;\n104         }\n105       }\n106     }\n107 \n108     ~UdpServer()\n109     {\n110       if(sockfd &gt;= 0){\n111         close(sockfd);\n112       }\n113     }\n114 };\n</code></pre>\n<p><strong><img alt=\"\" height=\"1054\" src=\"..\\..\\static\\image\\380eae02911d47a0a7d2bf93c376d37c.png\" width=\"897\"/></strong></p>\n<p><strong>         è¿™é‡Œçš„æ€è·¯æ˜¯ï¼šå¦‚æœè¾“å…¥çš„æ˜¯ lsï¼Œé‚£ä¹ˆåˆ›å»ºä¸€ä¸ªåŒ¿åç®¡é“ï¼Œç„¶åå­è¿›ç¨‹è¦å†™ï¼Œæ‰€ä»¥å…³é—­è¯»ï¼Œçˆ¶è¿›ç¨‹è¦è¯»ï¼Œæ‰€ä»¥å…³é—­å†™ï¼Œå› ä¸ºç®¡é“åªèƒ½å•å‘é€šä¿¡ï¼Œç„¶åçˆ¶è¿›ç¨‹å°†è¯»åˆ°çš„å†™åˆ° result å­—ç¬¦ä¸²é‡Œï¼Œç„¶åæ‰“å°åˆ°å®¢æˆ·ç«¯ã€‚</strong></p>\n<p><strong>        å¦‚æœè¾“å…¥çš„ä¸æ˜¯ lsï¼Œé‚£ä¹ˆå°±æ‰“å°åˆ°å®¢æˆ·ç«¯æ˜¯ä½ è¾“å…¥çš„å†…å®¹ã€‚</strong></p>\n<p><strong><img alt=\"\" height=\"187\" src=\"..\\..\\static\\image\\56edc0d8300f4fa49511d485910da7eb.png\" width=\"1200\"/></strong></p>\n<p><strong>        è¿™é‡Œæ•ˆæœå…¶å®æœ‰ç‚¹é—®é¢˜ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°æˆ‘ä»¬æ‰“å°çš„æ˜¯ ls -a -l -iï¼Œä»–åº”è¯¥å±•ç¤ºå‡ºæ¥çš„è¦æ¯”è¿™ä¸ªå¤šï¼Œè¿™åº”è¯¥æ˜¯å› ä¸ºç®¡é“æ˜¯æœ‰å¤§å°çš„ï¼Œæ‰€ä»¥ execl çš„æ—¶å€™å·²ç»éƒ½å°†ç®¡é“å æ»¡äº†è¿˜æ²¡æœ‰æ‰“å°å®Œï¼Œæ‰€ä»¥å‡ºç°è¿™ä¸ªæƒ…å†µï¼Œä½†æ˜¯å¦‚æœæˆ‘ä»¬æ‰“å° ls çš„è¯å°±æ˜¯è¿™æ ·çš„ï¼š</strong></p>\n<p><strong><img alt=\"\" height=\"263\" src=\"..\\..\\static\\image\\68444028f1634f528aa020665abebf4e.png\" width=\"1200\"/></strong></p>\n<p><strong>        æˆ‘ä»¬å¯ä»¥çœ‹åˆ°è¿™æ ·æ˜¯æ‰“å°å…¨çš„ï¼Œæ‰€ä»¥åº”è¯¥å°±æ˜¯ä¸Šé¢æ‰€è¯´çš„é—®é¢˜~</strong></p>\n<p><strong>        æ­¤æ—¶æˆ‘ä»¬çš„ UDP å°±ä¼šç”¨äº†ï¼Œä¸‹é¢ç»™å‡ºäº†ä»£ç ï¼Œå¤§å®¶å¯ä»¥ä¹Ÿå»è¯•è¯•ã€‚</strong></p>\n<h2 id=\"3.3%20UDP%E6%80%BB%E4%BB%A3%E7%A0%81\"><strong><span style=\"color:#9c8ec1;\">3.3 UDPæ€»ä»£ç </span></strong></h2>\n<h3><strong><span style=\"color:#ad720d;\">udp_server.hpp</span></strong></h3>\n<pre><code class=\"language-cpp\">  1 #pragma once                                                                                                                                            \n  2 \n  3 #include &lt;iostream&gt;\n  4 #include &lt;string&gt;\n  5 #include &lt;cstring&gt;\n  6 #include &lt;sys/socket.h&gt;\n  7 #include &lt;sys/types.h&gt;\n  8 #include &lt;netinet/in.h&gt;\n  9 #include &lt;arpa/inet.h&gt;\n 10 #include &lt;unistd.h&gt;\n 11 #include &lt;sys/wait.h&gt;\n 12 #define DEFAULT 8081\n 13 \n 14 class UdpServer{\n 15   private:\n 16     int port;\n 17     int sockfd;\n 18     //std::string ip;\n 19   public:\n 20     UdpServer(int _port = DEFAULT)\n 21       : port(_port)\n 22       , sockfd(-1)\n 23     {}\n 24 \n 25     bool InitUdpServer()\n 26     {\n 27       sockfd = socket(AF_INET, SOCK_DGRAM, 0);\n 28       if(sockfd &lt; 0){\n 29         std::cerr &lt;&lt; \"socket error\" &lt;&lt; std::endl;\n 30         return false;\n 31       }\n 32       std::cout &lt;&lt; \"socket create success, sockfd: \" &lt;&lt; sockfd &lt;&lt; std::endl;//å¤§æ¦‚ç‡æ˜¯3\n 33                                                                                                                                                         \n 34 \n 35       struct sockaddr_in local;//ç½‘ç»œé€šä¿¡åœ°å€\n 36       memset(&amp;local, '\\0', sizeof(local));\n 37       local.sin_family = AF_INET;\n 38       local.sin_port = htons(port);//ç«¯å£å·\n 39       //local.sin_addr.s_addr = inet_addr(ip.c_str());\n 40       local.sin_addr.s_addr = INADDR_ANY;\n 41       if(bind(sockfd, (struct sockaddr*)&amp;local, sizeof(local)) &lt; 0){\n 42         std::cerr &lt;&lt; \"bind error\" &lt;&lt; std::endl;\n 43         return false;\n 44       }\n 45       std::cout &lt;&lt; \"bind success\" &lt;&lt; std::endl;\n 46 \n 47 \n 48       return true;\n 49     }\n 50     \n 51     void Start()\n 52     {\n 53 #define SIZE 1000\n 54       char buffer[SIZE];\n 55 \n 56       for( ; ; ){\n 57         struct sockaddr_in peer;\n 58         socklen_t len = sizeof(peer);\n 59         ssize_t size = recvfrom(sockfd, buffer, sizeof(buffer)-1, 0, (struct sockaddr*)&amp;peer, &amp;len);\n 60         if(size &gt; 0){                                                                                                                                   \n 61           buffer[size] = 0;\n 62           int _port = ntohs(peer.sin_port);\n 63           std::string _ip = inet_ntoa(peer.sin_addr);\n 64           std::cout &lt;&lt; _ip &lt;&lt; \":\" &lt;&lt; _port &lt;&lt; \"# \" &lt;&lt; buffer &lt;&lt; std::endl;\n 65 \n 66           std::string cmd = buffer;\n 67           std::string result;\n 68           if(cmd == \"ls\"){\n 69             int pipes[2];\n 70             pipe(pipes);\n 71 \n 72             pid_t id = fork();\n 73             if(id == 0){\n 74               close(pipes[0]);//å­è¿›ç¨‹è¦å†™ï¼Œæ‰€ä»¥å…³é—­è¯»\n 75               dup2(pipes[1], 1);\n 76               execl(\"/usr/bin/ls\", \"ls\", nullptr);\n 77               exit(1);\n 78             }\n 79             close(pipes[1]);//çˆ¶è¿›ç¨‹è¦è¯»ï¼Œæ‰€ä»¥è¦å…³é—­å†™\n 80             char c;\n 81             while(1){\n 82               if(read(pipes[0], &amp;c, 1) &gt; 0){\n83                 result.push_back(c);\n 84               }\n 85               else{\n 86                 break;\n 87               }                                                                                                                                         \n 88             }\n 89             wait(nullptr);\n 90           }\n 91 \n 92           std::string echo_msg;\n 93           if(result.empty()){\n 94             echo_msg = \"server get!-&gt;\";\n 95             echo_msg += buffer;\n 96           }\n 97           else{\n 98             echo_msg = result;\n 99           }\n100           sendto(sockfd, echo_msg.c_str(), echo_msg.size(), 0, (struct sockaddr*)&amp;peer, len);\n101         }\n102         else{\n103           std::cerr &lt;&lt; \"recvfrom error\" &lt;&lt; std::endl;\n104         }\n105       }\n106     }\n107 \n108     ~UdpServer()\n109     {\n110       if(sockfd &gt;= 0){\n111         close(sockfd);\n112       }\n113     }\n114 };\n</code></pre>\n<h3><strong><span style=\"color:#ad720d;\">udp_server.cc</span></strong></h3>\n<pre><code class=\"language-cpp\">  1 #include \"udp_server.hpp\"                                                                                                                               \n  2 \n  3 //./udp_server port\n  4 \n  5 int main(int argc, char* argv[])\n  6 {\n  7   if(argc != 2){\n  8     std::cerr &lt;&lt; \"Usage: \" &lt;&lt; argv[0] &lt;&lt; \" port\" &lt;&lt; std::endl;\n  9     return 1;\n 10   }\n 11 \n 12   //std::string ip = \"127.0.0.1\"; //127.0.0.1 == localhost : æ ‡è¯†æœ¬æœºå™¨ ï¼š æœ¬åœ°ç¯å›\n 13   //std::string ip = \"49.232.134.146\";\n 14   int port = atoi(argv[1]);\n 15 \n 16   UdpServer* svr = new UdpServer(port);\n 17   svr-&gt;InitUdpServer();\n 18 \n 19   svr-&gt;Start();\n 20   return 0;\n 21 }\n</code></pre>\n<h3><strong><span style=\"color:#ad720d;\">udp_client.hpp</span></strong></h3>\n<pre><code class=\"language-cpp\">  1 #pragma once                                                                                                                                            \n  2 \n  3 #include &lt;iostream&gt;\n  4 #include &lt;string&gt;\n  5 #include &lt;cstring&gt;\n  6 #include &lt;sys/socket.h&gt;\n  7 #include &lt;sys/types.h&gt;\n  8 #include &lt;arpa/inet.h&gt;\n  9 #include &lt;netinet/in.h&gt;\n 10 #include &lt;unistd.h&gt;\n 11 \n 12 class UdpClient{\n 13   private:\n 14     int sockfd;\n 15     std::string ip;\n 16     int port;\n 17   public:\n 18     UdpClient(std::string _ip, int _port)\n 19       :ip(_ip)\n 20       , port(_port)\n 21   {}\n 22     bool InitUdpClient()\n 23     {\n 24       sockfd = socket(AF_INET, SOCK_DGRAM, 0);\n 25       if(sockfd &lt; 0){\n 26         std::cerr &lt;&lt; \"socket error!\" &lt;&lt; std::endl;\n 27         return false;\n 28       }\n 29       return true;\n 30     }\n 31     void Start()\n 32     {\n 33       struct sockaddr_in peer;                                                                                                                          \n 34       memset(&amp;peer, 0, sizeof(peer));\n 35       peer.sin_family = AF_INET;\n 36       peer.sin_port = htons(port);\n 37       peer.sin_addr.s_addr = inet_addr(ip.c_str());\n 38 \n 39       std::string msg;\n 40       for(; ; ){\n 41         std::cout &lt;&lt; \"Pleace Enter# \";\n 42         std::cin &gt;&gt; msg;\n 43         sendto(sockfd, msg.c_str(), msg.size(), 0,(struct sockaddr*) &amp;peer, sizeof(peer));\n 44 \n 45         char buffer[128];\n 46         //å½“ç„¶å¦‚æœæ‹…å¿ƒå®¢æˆ·ç«¯å‘ç”Ÿå˜åŒ–å°±å¯ä»¥æŠŠpeerä¼ è¿‡æ¥\n 47         struct sockaddr_in temp;\n 48         socklen_t len = sizeof(temp);\n 49         ssize_t size = recvfrom(sockfd, buffer, sizeof(buffer)-1, 0, (struct sockaddr*)&amp;temp, &amp;len);\n 50         if(size &gt; 0){\n 51           buffer[size] = 0;\n 52           std::cout &lt;&lt; buffer &lt;&lt; std::endl;\n 53         }\n 54       }\n 55 \n 56 \n 57     }\n 58     ~UdpClient()\n 59     {\n 60       if(sockfd &gt;= 0){\n 61         close(sockfd);\n 62       }\n 63     }\n 64 };\n</code></pre>\n<h3><strong><span style=\"color:#ad720d;\">udp_client.cc</span></strong></h3>\n<pre><code class=\"language-cpp\">  1 #include \"udp_client.hpp\"                                                                                                                               \n  2 \n  3 //./udp_cilent ip port\n  4 int main(int argc, char* argv[])\n  5 {\n  6   if(argc != 3){\n  7     std::cerr &lt;&lt; \"Usage: \" &lt;&lt; argv[0] &lt;&lt; \"ip port\" &lt;&lt; std::endl;\n  8     return 1;\n  9   }\n 10   std::string ip = argv[1];\n 11   int port = atoi(argv[2]);\n 12   UdpClient* uclt = new UdpClient(ip, port);\n 13   uclt-&gt;InitUdpClient();\n 14 \n 15   uclt-&gt;Start();\n 16 \n 17   return 0;\n 18 }\n</code></pre>\n<h1 id=\"4.%20%E5%A4%9A%E6%96%B9%E6%B3%95TCP%E9%80%9A%E4%BF%A1\"><strong><span style=\"color:#faa572;\">4. å¤šæ–¹æ³•TCPé€šä¿¡</span></strong></h1>\n<h2 id=\"4.1%20%E6%8E%A5%E5%8F%A3\"><strong><span style=\"color:#9c8ec1;\">4.1 æ¥å£</span></strong></h2>\n<p><strong><img alt=\"\" height=\"136\" src=\"..\\..\\static\\image\\4c3d60923def44c0a25670928ef3770f.png\" width=\"633\"/></strong></p>\n<p><strong><img alt=\"\" height=\"224\" src=\"..\\..\\static\\image\\b4092d5d83214ab8b4ecf468f1fc1bf0.png\" width=\"1200\"/></strong></p>\n<p><strong><img alt=\"\" height=\"218\" src=\"..\\..\\static\\image\\37c4cdd1ca934fc2af634436dfad5bf2.png\" width=\"1200\"/></strong></p>\n<h2 id=\"4.2%20TCP%20%E5%8D%95%E6%89%A7%E8%A1%8C%E6%B5%81\"><strong><span style=\"color:#9c8ec1;\">4.2 TCP å•æ‰§è¡Œæµ</span></strong></h2>\n<p><strong>        å› ä¸º tcp æ˜¯é¢å‘è¿æ¥çš„ï¼Œæ‰€ä»¥éœ€è¦åœ¨æ­£å¼å‘é€æ•°æ®ä¹‹å‰ï¼Œå…ˆè¦å»ºç«‹é“¾æ¥ã€‚æ—¢ç„¶è¦å»ºç«‹è¿æ¥ï¼Œé‚£ä¹ˆæœåŠ¡å™¨ç«¯å¿…é¡»å¾—ä¸æ–­çš„èŠ±æ—¶é—´è¿›è¡Œæ£€æµ‹æ˜¯å¦æœ‰æ–°çš„é“¾æ¥åˆ°æ¥ã€‚</strong></p>\n<h3 id=\"tcp_server.hpp\"><strong><span style=\"color:#ad720d;\">tcp_server.hpp</span></strong></h3>\n<pre><code class=\"language-cpp\">  1 #pragma once \n  2 \n  3 #include &lt;iostream&gt;\n  4 #include &lt;string&gt;\n  5 #include &lt;cstring&gt;\n  6 #include &lt;sys/socket.h&gt;\n  7 #include &lt;sys/types.h&gt;\n  8 #include &lt;arpa/inet.h&gt;\n  9 #include &lt;unistd.h&gt;\n 10 \n 11 #define  BACKLOG 5\n 12 \n 13 class TcpServer{\n 14   private:\n 15     short port;\n 16     int listen_sock;\n 17   public:\n 18     TcpServer(short _port)\n 19       :port(_port)\n 20        ,listen_sock(-1)\n 21   {}\n 22     bool InitTcpServer()\n 23     {                                                                                                                               \n 24       listen_sock = socket(AF_INET, SOCK_STREAM, 0);\n 25       if(listen_sock &lt; 0){\n 26         std::cerr &lt;&lt; \"socket error\" &lt;&lt; std::endl;\n 27         return false;\n 28       }\n 29 \n 30       struct sockaddr_in local;\n 31       //bzero(&amp;local, sizeof(local));\n 32       memset(&amp;local, 0, sizeof(local));\n 33       local.sin_family = AF_INET;                                                                                                   \n 34       local.sin_port = htons(port);\n 35       local.sin_addr.s_addr = INADDR_ANY;\n 36 \n 37       if(bind(listen_sock, (struct sockaddr*)&amp;local, sizeof(local)) &lt; 0){\n 38         std::cerr &lt;&lt; \"bind error\" &lt;&lt; std::endl;\n 39         return false;\n 40       }\n 41       \n 42       if(listen(listen_sock, BACKLOG) &lt; 0){\n 43         std::cerr &lt;&lt; \"listen error\" &lt;&lt;std::endl;\n 44         return false;\n 45       }\n 46       std::cout &lt;&lt; \"listen success\" &lt;&lt; std::endl;\n 47       return true;\n 48     }\n 49     void Loop()\n 50     {\n 51       struct sockaddr_in peer;\n 52       for(;;)\n 53       {\n 54         //å…ˆè·å–é“¾æ¥\n 55         socklen_t len = sizeof(peer);\n 56         int sock = accept(listen_sock, (struct sockaddr*)&amp;peer, &amp;len);\n 57         if(sock &lt; 0){\n 58           std::cerr &lt;&lt; \"accept error\" &lt;&lt; std::endl;\n 59           continue;\n 60         }\n 61         std::cout &lt;&lt; \"get a new link: \" &lt;&lt; sock &lt;&lt; std::endl;\n 62       }\n 63     }\n 64     ~TcpServer()\n 65     {}\n 66 };</code></pre>\n<h3 id=\"tcp_server.cc\"><strong><span style=\"color:#ad720d;\">tcp_server.cc</span></strong></h3>\n<pre><code class=\"language-cpp\">  1 #include \"tcp_server.hpp\"\n  2 \n  3 int main()\n  4 {\n  5   TcpServer tsvr(8081);\n  6   tsvr.InitTcpServer();                                                                                                             \n  7 \n  8   tsvr.Loop();\n  9 \n 10 \n 11   return 0;\n 12 }\n</code></pre>\n<p><strong>        listen_sockï¼šè·å–æ–°é“¾æ¥ã€‚</strong></p>\n<p><strong>        sockï¼šæœåŠ¡æ–°é“¾æ¥(è¯»å–æ•°æ®ã€åˆ†ææ•°æ®ã€å¤„ç†æ•°æ®ã€å†™å…¥æ•°æ®)ã€‚</strong></p>\n<p><strong>        è¿™é‡Œæœ‰ä¸€ä¸ªå‘½ä»¤ telnet æ˜¯è¿œç¨‹ç™»é™†ã€‚</strong></p>\n<p><strong><img alt=\"\" height=\"376\" src=\"..\\..\\static\\image\\9d464fd58a554bfb9e9f0b7bee482a19.png\" width=\"1200\"/></strong></p>\n<p><strong>        æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œç”¨æœ¬åœ°ç¯å›å¯ä»¥å»ºç«‹é“¾æ¥ï¼Œç”¨å…¬ç½‘ ip ä¹Ÿå¯ä»¥ã€‚</strong></p>\n<p><strong>        ç”šè‡³ï¼Œæˆ‘ä»¬è¿˜å¯ä»¥ç”¨æµè§ˆå™¨å»è®¿é—® 8081ï¼Œè™½ç„¶æœåŠ¡å™¨é‡Œç°åœ¨ä»€ä¹ˆéƒ½æ²¡æœ‰ï¼Œä½†æ˜¯æµè§ˆå™¨åº•å±‚ç”¨çš„æ˜¯ httpï¼Œæˆ–è€… https ï¼Œåº•å±‚éƒ½æ˜¯ tcpï¼Œæ‰€ä»¥å®ƒä¹Ÿä¼šå‘æœåŠ¡å™¨å‘é€è¯·æ±‚ã€‚</strong></p>\n<h3 id=\"tcp_client.hpp\"><strong><span style=\"color:#ad720d;\">tcp_client.hpp</span></strong></h3>\n<pre><code class=\"language-cpp\">  1 #pragma once\n  2 \n  3 #include &lt;iostream&gt;\n  4 #include &lt;string&gt;\n  5 #include &lt;cstring&gt;\n  6 #include &lt;unistd.h&gt;\n  7 #include &lt;sys/types.h&gt;\n  8 #include &lt;sys/socket.h&gt;\n  9 #include &lt;arpa/inet.h&gt;\n 10 #include &lt;netinet/in.h&gt;\n 11 \n 12 class TcpClient{\n 13   private:\n 14     std::string ip;\n 15     short port;\n 16     int sock;\n 17   public:                                                                                                                  \n 18     TcpClient(std::string _ip, short _port)\n 19       :ip(_ip)\n 20        ,port(_port)\n 21        ,sock(-1)\n 22     {}\n 23     void InitTcpClient()\n 24     {\n 25       sock = socket(AF_INET, SOCK_STREAM, 0);\n 26       if(sock &lt; 0){\n 27         std::cerr &lt;&lt; \"socket error\" &lt;&lt; std::endl;\n 28         exit(2);\n 29       }\n 30 \n 31     }\n 32 \n 33     void Loop()                                                                                                            \n 34     {\n 35       struct sockaddr_in peer;\n 36       memset(&amp;peer, 0, sizeof(peer));\n 37       peer.sin_family = AF_INET;\n 38       peer.sin_port = htons(port);\n 39       peer.sin_addr.s_addr = inet_addr(ip.c_str());;\n 40       //è¿æ¥æœåŠ¡å™¨\n 41       if(connect(sock, (struct sockaddr*)&amp;peer, sizeof(peer)) == 0){\n 42         //success\n 43         std::cout &lt;&lt; \"connect success ...\" &lt;&lt; std::endl;\n 44         Request(sock);\n 45       }\n 46       else{\n 47         //failed\n 48         std::cerr &lt;&lt; \"connect failed ...\" &lt;&lt; std::endl;\n 49       }\n 50     }\n 51 \n 52     void Request(int sock)\n 53     {\n 54       std::string msg;\n 55       char buffer[1024];\n 56       while(true){\n 57         std::cout &lt;&lt; \"Please Entet# \";\n 58         std::cin &gt;&gt; msg;\n 59 \n 60         write(sock, msg.c_str(), msg.size());                                                                              \n 61 \n 62         ssize_t s = read(sock, buffer, sizeof(buffer)-1);\n 63         if(s &gt; 0){\n 64           buffer[s] = 0;\n 65         }\n 66         std::cout &lt;&lt; \"server echo# \" &lt;&lt; buffer &lt;&lt; std::endl;\n 67       }\n 68     }\n 69 \n 70     ~TcpClient()\n 71     {\n 72       if(sock &gt;= 0){\n 73         close(sock);\n 74       }\n 75     }\n 76 };</code></pre>\n<h3 id=\"tcp_client.cc\"><strong><span style=\"color:#ad720d;\">tcp_client.cc</span></strong></h3>\n<pre><code class=\"language-cpp\">  1 #include \"tcp_client.hpp\"\n  2 \n  3 \n  4 int main(int argc, char* argv[])\n  5 {\n  6   if(argc != 3){\n  7     std::cout &lt;&lt; \"Usage: \" &lt;&lt; argv[0] &lt;&lt; \"ip port\" &lt;&lt; std::endl;\n  8     exit(1);\n  9   }\n 10 \n 11   TcpClient tclt(argv[1], atoi(argv[2]));                                                                                  \n 12   tclt.InitTcpClient();\n 13 \n 14   tclt.Loop();\n 15 \n 16   return 0;\n 17 }\n</code></pre>\n<p><strong><img alt=\"\" height=\"220\" src=\"..\\..\\static\\image\\169a39d05d6341acba9fc6e42a131d71.png\" width=\"1200\"/></strong></p>\n<p><strong><img alt=\"\" height=\"226\" src=\"..\\..\\static\\image\\1262366acc8f4cc4a97dd359bb862e3f.png\" width=\"1200\"/></strong></p>\n<p><strong>        æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œæˆ‘ä»¬æ˜¯å¯ä»¥è¿›è¡Œé€šä¿¡çš„ï¼Œè€Œä¸”å½“æˆ‘ä»¬å…³æ‰å®¢æˆ·ç«¯çš„æ—¶å€™ï¼ŒæœåŠ¡å°±ä¼šç»ˆæ­¢ï¼Œä½†æ˜¯æœåŠ¡å™¨è¿˜æ˜¯åœ¨è¿è¡Œçš„ï¼Œå®ƒå†ç­‰ä¸‹ä¸€ä¸ªæœåŠ¡è¯·æ±‚ã€‚</strong></p>\n<p><strong>        ä½†æ˜¯è¿™é‡Œæœ‰ä¸ªé—®é¢˜ï¼š</strong></p>\n<p><strong><img alt=\"\" height=\"335\" src=\"..\\..\\static\\image\\c03855f7011a459a9d157b2a4a12b28b.png\" width=\"1200\"/></strong></p>\n<p><strong>        å½“æˆ‘ä»¬ä¸¤ä¸ªå®¢æˆ·ç«¯åŒæ—¶é“¾æ¥ï¼ŒåŒæ—¶å‘æ¶ˆæ¯å°±ä¼šå‡ºç°è¿™ä¸ªæƒ…å†µï¼Œç„¶åï¼š</strong></p>\n<p><strong><img alt=\"\" height=\"361\" src=\"..\\..\\static\\image\\a8449a3c7d754ade8217678985daad7d.png\" width=\"1200\"/></strong></p>\n<p><strong>        å½“æˆ‘ä»¬ ctrl+c çš„æ—¶å€™ 42424 é€€å‡ºäº†ï¼Œåˆæ¥äº†ä¸ªé“¾æ¥ 42436ï¼Œç„¶å \"ä½ æ˜¯å¥½äºº\" ä¹Ÿå‘é€äº†ï¼Œ</strong></p>\n<p><strong>        æ‰€ä»¥è¿™é‡Œç°åœ¨å…¶å®æ˜¯ä¸²è¡Œçš„ï¼Œå› ä¸ºæˆ‘ä»¬ç°åœ¨å†™çš„è¿™ä¸ªæ˜¯ä¸€ä¸ªå•æ‰§è¡Œæµçš„æœåŠ¡å™¨ï¼Œç°åœ¨åªèƒ½å¤„ç†ä¸€ä¸ªäººçš„è¯·æ±‚ã€‚</strong></p>\n<h2 id=\"4.3%20TCP%20%E5%A4%9A%E8%BF%9B%E7%A8%8B\"><strong><span style=\"color:#9c8ec1;\">4.3 TCP å¤šè¿›ç¨‹</span></strong></h2>\n<h3><strong><span style=\"color:#ad720d;\">tcp_server.hpp</span></strong></h3>\n<pre><code class=\"language-cpp\">  1 #pragma once \n  2 \n  3 #include &lt;iostream&gt;\n  4 #include &lt;string&gt;\n  5 #include &lt;cstring&gt;\n  6 #include &lt;sys/socket.h&gt;\n  7 #include &lt;sys/types.h&gt;\n  8 #include &lt;arpa/inet.h&gt;\n  9 #include &lt;unistd.h&gt;\n 10 #include &lt;signal.h&gt;\n 11 #include &lt;sys/wait.h&gt;\n 12 #define  BACKLOG 5\n 13 \n 14 class TcpServer{\n 15   private:\n 16     short port;\n 17     int listen_sock;\n 18   public:\n 19     TcpServer(short _port)\n 20       :port(_port)\n 21        ,listen_sock(-1)\n 22   {}\n 23     bool InitTcpServer()\n 24     {\n 25       listen_sock = socket(AF_INET, SOCK_STREAM, 0);\n 26       if(listen_sock &lt; 0){\n 27         std::cerr &lt;&lt; \"socket error\" &lt;&lt; std::endl;\n 28         return false;\n 29       }                                                                                                                                                                      \n 30 \n 31       struct sockaddr_in local;\n 32       //bzero(&amp;local, sizeof(local));\n 33       memset(&amp;local, 0, sizeof(local));\n 34       local.sin_family = AF_INET;\n 35       local.sin_port = htons(port);\n 36       local.sin_addr.s_addr = INADDR_ANY;\n 37 \n 38       if(bind(listen_sock, (struct sockaddr*)&amp;local, sizeof(local)) &lt; 0){\n 39         std::cerr &lt;&lt; \"bind error\" &lt;&lt; std::endl;                                                                                                                              \n 40         return false;\n 41       }\n 42       \n 43       if(listen(listen_sock, BACKLOG) &lt; 0){\n 44         std::cerr &lt;&lt; \"listen error\" &lt;&lt;std::endl;\n 45         return false;\n 46       }\n 47       std::cout &lt;&lt; \"listen success\" &lt;&lt; std::endl;\n 48       return true;\n 49     }\n 50     void Loop()\n 51     {\n 52       //è¿™æ ·å†™çˆ¶è¿›ç¨‹å°±ä¸ç”¨ç­‰å­è¿›ç¨‹äº†ï¼Œå¾ˆæ¨èï¼Œå› ä¸ºå¾ˆç®€å•\n 53       //signal(SIGCHLD, SIG_IGN);\n 54        struct sockaddr_in peer;\n 55       for(;;)\n 56       {\n 57         //å…ˆè·å–é“¾æ¥\n 58         socklen_t len = sizeof(peer);\n 59         int sock = accept(listen_sock, (struct sockaddr*)&amp;peer, &amp;len);\n 60         //è¿™é‡Œæ˜¯acceptå¤±è´¥\n 61         if(sock &lt; 0){\n 62           std::cerr &lt;&lt; \"accept error\" &lt;&lt; std::endl;\n 63           continue;\n 64         }\n 65         \n 66 \n 67         pid_t id = fork();\n 68         if(id == 0){\n 69           //åˆ›å»ºå‡ºæ¥å­™å­è¿›ç¨‹æ˜¯ä¸ºäº†åœŸå…±æœåŠ¡çš„\n 70           //æ‰€ä»¥ä¸ç”¨å…³å¿ƒ listen_sockäº†\n 71           close(listen_sock);//è¿™é‡Œä¸æ˜¯å¿…è¦çš„\n 72           if(fork() &gt; 0){                                                                                                                                                    \n 73             exit(0);\n 74           }\n 75           //å­™å­è¿›ç¨‹\n 76           //è¿™æ ·åšçš„åŸå› æ˜¯çˆ¶è¿›ç¨‹é€€å‡ºï¼Œå­è¿›ç¨‹è¢«ç³»ç»Ÿé¢†å…»æˆä¸ºå­¤å„¿è¿›ç¨‹\n 77           std::string ip = inet_ntoa(peer.sin_addr);\n 78           int port = ntohs(peer.sin_port);\n 79           std::cout &lt;&lt; \"get a new link:\"&lt;&lt; sock &lt;&lt;\"[\" &lt;&lt; ip &lt;&lt; \"]\" &lt;&lt; port &lt;&lt; std::endl;\n 80           Service(sock, ip, port);//å¤„ç†\n 81           exit(0);\n 82         }\n 83 \n 84         //è¿™é‡Œå…³æ‰sockä¸ä¼šå½±å“å­™å­è¿›ç¨‹çš„ä½¿ç”¨\n 85         //å› ä¸ºå°±ç›¸å½“äºçˆ·çˆ·è¿›ç¨‹å°†æŒ‡å‘sockè¿™ä¸ªæ–‡ä»¶æè¿°ç¬¦å…³æ‰\n 86         close(sock);//è¿™é‡Œæ˜¯å¿…è¦çš„\n 87         //è¿™é‡Œè¿˜æ˜¯è¦ç­‰çš„ï¼Œå› ä¸ºçˆ¶è¿›ç¨‹é€€å‡ºï¼Œçˆ·çˆ·è¿›ç¨‹æ˜¯è¦ç­‰çˆ¶è¿›ç¨‹çš„\n 88         //ä½†æ˜¯è¿™é‡Œå°±ä¸ç®—æ˜¯æŒ‚èµ·äº†ï¼Œå› ä¸ºçˆ¶è¿›ç¨‹æ˜¯ç›´æ¥å°±é€€å‡ºï¼Œçˆ·çˆ·è¿›ç¨‹ç›´æ¥å›æ”¶\n 89         waitpid(id, nullptr, 0);//è¿™é‡Œçš„idå°±æ˜¯çˆ¶è¿›ç¨‹çš„idï¼Œå½“ç„¶è¿™é‡Œä¹Ÿå¯ä»¥å†™æˆ-1\n 90       }\n 91 \n 92     }\n 93 \n 94     void Service(int sock, std::string&amp; ip, short port)\n 95     {\n 96       char buffer[1024];\n 97       while(true){\n 98         ssize_t size = read(sock, buffer, sizeof(buffer)-1);\n 99         if(size &gt; 0){\n100           buffer[size] = 0;\n101           std::cout &lt;&lt; ip &lt;&lt; \":\" &lt;&lt; port &lt;&lt; \"# \" &lt;&lt; buffer &lt;&lt; std::endl;\n102           //å›æ˜¾\n103           write(sock, buffer, size);\n104         }\n105         else if (size == 0){                                                                                                                                                 \n106           std::cout &lt;&lt; ip &lt;&lt; \":\" &lt;&lt; port &lt;&lt; \"close!\" &lt;&lt; buffer &lt;&lt; std::endl;\n107           break;\n108         }\n109         else{\n110           std::cerr &lt;&lt; port &lt;&lt; \"read error\" &lt;&lt; std::endl;\n111           break;\n112         }\n113       }\n114       \n115       close(sock);\n116       std::cout &lt;&lt; \"Service done!\" &lt;&lt; std::endl;\n117     }\n118 \n119     ~TcpServer()\n120     {\n121       if(listen_sock &gt;= 0){\n122         close(listen_sock);\n123       }\n124     }\n125 };</code></pre>\n<h3><strong><span style=\"color:#ad720d;\">tcp_server.cc</span></strong></h3>\n<pre><code class=\"language-cpp\">  1 #include \"tcp_server.hpp\"\n  2 \n  3 int main(int argc, char* argv[])\n  4 {\n  5   if(argc != 2){\n  6     std::cout &lt;&lt; \"Usage: \" &lt;&lt; argv[0] &lt;&lt; \"port\" &lt;&lt; std::endl;\n  7     exit(1);\n  8   }\n  9   TcpServer tsvr(atoi(argv[1]));                                                                                                                                             \n 10   tsvr.InitTcpServer();\n 11 \n 12   tsvr.Loop();\n 13 \n 14 \n 15   return 0;\n 16 }\n</code></pre>\n<h3><strong><span style=\"color:#ad720d;\">tcp_client.hpp</span></strong></h3>\n<pre><code class=\"language-cpp\">  1 #pragma once\n  2 \n  3 #include &lt;iostream&gt;\n  4 #include &lt;string&gt;\n  5 #include &lt;cstring&gt;\n  6 #include &lt;unistd.h&gt;\n  7 #include &lt;sys/types.h&gt;\n  8 #include &lt;sys/socket.h&gt;\n  9 #include &lt;arpa/inet.h&gt;\n 10 #include &lt;netinet/in.h&gt;\n 11 \n 12 class TcpClient{\n 13   private:\n 14     std::string ip;\n 15     short port;\n 16     int sock;\n 17   public:                                                                                                                  \n 18     TcpClient(std::string _ip, short _port)\n 19       :ip(_ip)\n 20        ,port(_port)\n 21        ,sock(-1)\n 22     {}\n 23     void InitTcpClient()\n 24     {\n 25       sock = socket(AF_INET, SOCK_STREAM, 0);\n 26       if(sock &lt; 0){\n 27         std::cerr &lt;&lt; \"socket error\" &lt;&lt; std::endl;\n 28         exit(2);\n 29       }\n 30 \n 31     }\n 32 \n 33     void Loop()                                                                                                            \n 34     {\n 35       struct sockaddr_in peer;\n 36       memset(&amp;peer, 0, sizeof(peer));\n 37       peer.sin_family = AF_INET;\n 38       peer.sin_port = htons(port);\n 39       peer.sin_addr.s_addr = inet_addr(ip.c_str());;\n 40       //è¿æ¥æœåŠ¡å™¨\n 41       if(connect(sock, (struct sockaddr*)&amp;peer, sizeof(peer)) == 0){\n 42         //success\n 43         std::cout &lt;&lt; \"connect success ...\" &lt;&lt; std::endl;\n 44         Request(sock);\n 45       }\n 46       else{\n 47         //failed\n 48         std::cerr &lt;&lt; \"connect failed ...\" &lt;&lt; std::endl;\n 49       }\n 50     }\n 51 \n 52     void Request(int sock)\n 53     {\n 54       std::string msg;\n 55       char buffer[1024];\n 56       while(true){\n 57         std::cout &lt;&lt; \"Please Entet# \";\n 58         std::cin &gt;&gt; msg;\n 59 \n 60         write(sock, msg.c_str(), msg.size());                                                                              \n 61 \n 62         ssize_t s = read(sock, buffer, sizeof(buffer)-1);\n 63         if(s &gt; 0){\n 64           buffer[s] = 0;\n 65         }\n 66         std::cout &lt;&lt; \"server echo# \" &lt;&lt; buffer &lt;&lt; std::endl;\n 67       }\n 68     }\n 69 \n 70     ~TcpClient()\n 71     {\n 72       if(sock &gt;= 0){\n 73         close(sock);\n 74       }\n 75     }\n 76 };</code></pre>\n<h3><strong><span style=\"color:#ad720d;\">tcp_client.cc</span></strong></h3>\n<pre><code class=\"language-cpp\">  1 #include \"tcp_client.hpp\"\n  2 \n  3 \n  4 int main(int argc, char* argv[])\n  5 {\n  6   if(argc != 3){\n  7     std::cout &lt;&lt; \"Usage: \" &lt;&lt; argv[0] &lt;&lt; \"ip port\" &lt;&lt; std::endl;\n  8     exit(1);\n  9   }\n 10 \n 11   TcpClient tclt(argv[1], atoi(argv[2]));                                                                                  \n 12   tclt.InitTcpClient();\n 13 \n 14   tclt.Loop();\n 15 \n 16   return 0;\n 17 }\n</code></pre>\n<p><strong><img alt=\"\" height=\"616\" src=\"..\\..\\static\\image\\547aee4aeab44b31b0f2174b69bc8537.png\" width=\"1038\"/></strong></p>\n<p><strong>        è¿™é‡Œå…¶å®åªåœ¨ tcp_server.hpp ä¸­æ·»åŠ äº†è¿™ä¸ªï¼Œè¿™é‡Œçš„æ–‡å­—å¾ˆé‡è¦ï¼Œå¤§å®¶æ ¹æ®æ­¥éª¤çœ‹çœ‹ï¼Œåº”è¯¥æ˜¯å¯ä»¥çœ‹æ‡‚çš„ï¼Œå†™çš„è§£æå¾ˆå…¨é¢ã€‚</strong></p>\n<p><strong>        è¿™é‡Œçš„ç†è§£éå¸¸é‡è¦ï¼Œä½†æ˜¯æˆ‘è¦è¯´çš„æ˜¯ï¼Œå…¶å®è¿™é‡Œå®é™…å†™ä¸ç”¨è¿™ä¹ˆå¤æ‚ï¼Œå› ä¸ºè¿™åªæ˜¯ä¸€ä¸ªå¾ˆå¥½ç©çš„æ–¹æ³•ï¼Œä½†æ˜¯æœ‰æ¯”è¿™ä¸ªç®€å•å¾ˆå¤šå¾ˆå¤šçš„ï¼Œå°±æ˜¯ç›´æ¥ï¼š</strong></p>\n<p><strong><img alt=\"\" height=\"109\" src=\"..\\..\\static\\image\\3dec57a501db4d5892fe770091af07c9.png\" width=\"676\"/></strong></p>\n<p><strong>        å› ä¸ºä¸Šé¢å†™é‚£ä¹ˆå¤šçš„ç›®çš„å°±æ˜¯ä¸ºäº†è®©å­è¿›ç¨‹å•ç‹¬å»å®Œæˆä»»åŠ¡ï¼Œè¿™æ ·å†™ç›´æ¥å°±ä¸ç”¨ç­‰å­è¿›ç¨‹äº†ï¼Œæ‰€ä»¥è¿™ä¸ªæ˜¯æœ€æ¨èï¼Œæˆ–è€…è¯´æ˜¯æœ€å¥½çš„~ï¼</strong></p>\n<p><strong><img alt=\"\" height=\"791\" src=\"..\\..\\static\\image\\714a11b6173c4f86b421473800b98333.png\" width=\"1200\"/></strong></p>\n<p><strong>        é¦–å…ˆæˆ‘ä»¬é€šè¿‡å³è¾¹çš„ç›‘è§†è„šæœ¬çœ‹åˆ°ä»ä¸€ä¸ªè¿›ç¨‹åˆ°ä¸‰ä¸ªè¿›ç¨‹ï¼Œç„¶åéšç€é€€å‡ºä»ä¸‰ä¸ªè¿›ç¨‹åˆ°ä¸€ä¸ªè¿›ç¨‹ã€‚</strong></p>\n<p><strong>        è€Œä¸”æˆ‘ä»¬è¿æ¥æœåŠ¡å™¨çš„æ—¶å€™å®ƒçš„æ–‡ä»¶æè¿°ç¬¦éƒ½æ˜¯ 4 ï¼Œè¿™æ˜¯å› ä¸ºæˆ‘ä»¬æ˜¯ä¸€ä¸ªä¸€ä¸ªè¿çš„ï¼Œè¿ç©ä¹‹åçˆ·çˆ·è¿›ç¨‹å°±ä¼šå…³é—­ sock æ–‡ä»¶æè¿°ç¬¦ï¼Œæ‰€ä»¥å°±ä¸€ç›´æ˜¯ 4 ï¼Œä½†æ˜¯å¦‚æœä¸€æ¬¡æ€§æ¥å¤šä¸ªå®¢æˆ·ç«¯ï¼Œå¯èƒ½ä¼šå‡ºç° 4ã€5ã€6......ã€‚</strong></p>\n<p><strong>        è€Œä¸”æˆ‘ä»¬ä¹Ÿå¯ä»¥çœ‹åˆ°æˆ‘ä»¬ä¸¤ä¸ªè¿›ç¨‹æ˜¯ç›´æ¥éƒ½è¿ä¸Šäº†å®¢æˆ·ç«¯ï¼Œè€Œä¸”æœåŠ¡å™¨ç«¯éƒ½ä¼šç»™å®¢æˆ·ç«¯æä¾› æœåŠ¡ã€‚</strong></p>\n<h2 id=\"4.4%C2%A0TCP%20%E5%A4%9A%E7%BA%BF%E7%A8%8B\"><strong><span style=\"color:#9c8ec1;\">4.4 TCP å¤šçº¿ç¨‹</span></strong></h2>\n<h3><strong><span style=\"color:#ad720d;\">tcp_server.hpp</span></strong></h3>\n<pre><code class=\"language-cpp\">  1 #pragma once \n  2 \n  3 #include &lt;iostream&gt;\n  4 #include &lt;string&gt;\n  5 #include &lt;cstring&gt;\n  6 #include &lt;sys/socket.h&gt;\n  7 #include &lt;sys/types.h&gt;\n  8 #include &lt;arpa/inet.h&gt;\n  9 #include &lt;unistd.h&gt;\n 10 #include &lt;signal.h&gt;\n 11 #include &lt;sys/wait.h&gt;\n 12 #define  BACKLOG 5\n 13 \n 14 class TcpServer{\n 15   private:\n 16     short port;\n 17     int listen_sock;\n 18   public:\n 19     TcpServer(short _port)\n 20       :port(_port)\n 21        ,listen_sock(-1)\n 22   {}\n 23     bool InitTcpServer()\n 24     {\n 25       listen_sock = socket(AF_INET, SOCK_STREAM, 0);\n 26       if(listen_sock &lt; 0){\n 27         std::cerr &lt;&lt; \"socket error\" &lt;&lt; std::endl;\n 28         return false;\n 29       }                                                                                                                                                                      \n 30 \n 31       struct sockaddr_in local;\n 32       //bzero(&amp;local, sizeof(local));\n 33       memset(&amp;local, 0, sizeof(local));\n 34       local.sin_family = AF_INET;\n 35       local.sin_port = htons(port);\n 36       local.sin_addr.s_addr = INADDR_ANY;\n 37 \n 38       if(bind(listen_sock, (struct sockaddr*)&amp;local, sizeof(local)) &lt; 0){\n 39         std::cerr &lt;&lt; \"bind error\" &lt;&lt; std::endl;                                                                                                                              \n 40         return false;\n 41       }\n 42       \n 43       if(listen(listen_sock, BACKLOG) &lt; 0){\n 44         std::cerr &lt;&lt; \"listen error\" &lt;&lt;std::endl;\n 45         return false;\n 46       }\n 47       std::cout &lt;&lt; \"listen success\" &lt;&lt; std::endl;\n 48       return true;\n 49     }\n 50     void Loop()\n 51     {\n 52       //è¿™æ ·å†™çˆ¶è¿›ç¨‹å°±ä¸ç”¨ç­‰å­è¿›ç¨‹äº†ï¼Œå¾ˆæ¨èï¼Œå› ä¸ºå¾ˆç®€å•\n 53       //signal(SIGCHLD, SIG_IGN);\n 54       for(;;)\n 55       {\n 56         //å…ˆè·å–é“¾æ¥\n 57         struct sockaddr_in peer;\n 58         socklen_t len = sizeof(peer);\n 59         int sock = accept(listen_sock, (struct sockaddr*)&amp;peer, &amp;len);\n 60         //è¿™é‡Œæ˜¯acceptå¤±è´¥\n 61         if(sock &lt; 0){\n 62           std::cerr &lt;&lt; \"accept error\" &lt;&lt; std::endl;\n 63           continue;\n 64         }\n 65         \n 66 \n 67         pid_t id = fork();\n 68         if(id == 0){\n 69           //åˆ›å»ºå‡ºæ¥å­™å­è¿›ç¨‹æ˜¯ä¸ºäº†åœŸå…±æœåŠ¡çš„\n 70           //æ‰€ä»¥ä¸ç”¨å…³å¿ƒ listen_sockäº†\n 71           close(listen_sock);//è¿™é‡Œä¸æ˜¯å¿…è¦çš„\n 72           if(fork() &gt; 0){                                                                                                                                                    \n 73             exit(0);\n 74           }\n 75           //å­™å­è¿›ç¨‹\n 76           //è¿™æ ·åšçš„åŸå› æ˜¯çˆ¶è¿›ç¨‹é€€å‡ºï¼Œå­è¿›ç¨‹è¢«ç³»ç»Ÿé¢†å…»æˆä¸ºå­¤å„¿è¿›ç¨‹\n 77           std::string ip = inet_ntoa(peer.sin_addr);\n 78           int port = ntohs(peer.sin_port);\n 79           std::cout &lt;&lt; \"get a new link:\"&lt;&lt; sock &lt;&lt;\"[\" &lt;&lt; ip &lt;&lt; \"]\" &lt;&lt; port &lt;&lt; std::endl;\n 80           Service(sock, ip, port);//å¤„ç†\n 81           exit(0);\n 82         }\n 83 \n 84         //è¿™é‡Œå…³æ‰sockä¸ä¼šå½±å“å­™å­è¿›ç¨‹çš„ä½¿ç”¨\n 85         //å› ä¸ºå°±ç›¸å½“äºçˆ·çˆ·è¿›ç¨‹å°†æŒ‡å‘sockè¿™ä¸ªæ–‡ä»¶æè¿°ç¬¦å…³æ‰\n 86         close(sock);//è¿™é‡Œæ˜¯å¿…è¦çš„\n 87         //è¿™é‡Œè¿˜æ˜¯è¦ç­‰çš„ï¼Œå› ä¸ºçˆ¶è¿›ç¨‹é€€å‡ºï¼Œçˆ·çˆ·è¿›ç¨‹æ˜¯è¦ç­‰çˆ¶è¿›ç¨‹çš„\n 88         //ä½†æ˜¯è¿™é‡Œå°±ä¸ç®—æ˜¯æŒ‚èµ·äº†ï¼Œå› ä¸ºçˆ¶è¿›ç¨‹æ˜¯ç›´æ¥å°±é€€å‡ºï¼Œçˆ·çˆ·è¿›ç¨‹ç›´æ¥å›æ”¶\n 89         waitpid(id, nullptr, 0);//è¿™é‡Œçš„idå°±æ˜¯çˆ¶è¿›ç¨‹çš„idï¼Œå½“ç„¶è¿™é‡Œä¹Ÿå¯ä»¥å†™æˆ-1\n 90       }\n 91 \n 92     }\n 93 \n 94     void Service(int sock, std::string&amp; ip, short port)\n 95     {\n 96       char buffer[1024];\n 97       while(true){\n 98         ssize_t size = read(sock, buffer, sizeof(buffer)-1);\n 99         if(size &gt; 0){\n100           buffer[size] = 0;\n101           std::cout &lt;&lt; ip &lt;&lt; \":\" &lt;&lt; port &lt;&lt; \"# \" &lt;&lt; buffer &lt;&lt; std::endl;\n102           //å›æ˜¾\n103           write(sock, buffer, size);\n104         }\n105         else if (size == 0){                                                                                                                                                 \n106           std::cout &lt;&lt; ip &lt;&lt; \":\" &lt;&lt; port &lt;&lt; \"close!\" &lt;&lt; buffer &lt;&lt; std::endl;\n107           break;\n108         }\n109         else{\n110           std::cerr &lt;&lt; port &lt;&lt; \"read error\" &lt;&lt; std::endl;\n111           break;\n112         }\n113       }\n114       \n115       close(sock);\n116       std::cout &lt;&lt; \"Service done!\" &lt;&lt; std::endl;\n117     }\n118 \n119     ~TcpServer()\n120     {\n121       if(listen_sock &gt;= 0){\n122         close(listen_sock);\n123       }\n124     }\n125 };</code></pre>\n<h3><strong><span style=\"color:#ad720d;\">tcp_server.cc</span></strong></h3>\n<pre><code class=\"language-cpp\">  1 #include \"tcp_server.hpp\"\n  2 \n  3 int main(int argc, char* argv[])\n  4 {\n  5   if(argc != 2){\n  6     std::cout &lt;&lt; \"Usage: \" &lt;&lt; argv[0] &lt;&lt; \"port\" &lt;&lt; std::endl;\n  7     exit(1);\n  8   }\n  9   TcpServer tsvr(atoi(argv[1]));                                                                                                                                             \n 10   tsvr.InitTcpServer();\n 11 \n 12   tsvr.Loop();\n 13 \n 14 \n 15   return 0;\n 16 }\n</code></pre>\n<h3><strong><span style=\"color:#ad720d;\">tcp_client.hpp</span></strong></h3>\n<pre><code class=\"language-cpp\">  1 #pragma once \n  2 \n  3 #include &lt;iostream&gt;\n  4 #include &lt;string&gt;\n  5 #include &lt;cstring&gt;\n  6 #include &lt;sys/socket.h&gt;\n  7 #include &lt;sys/types.h&gt;\n  8 #include &lt;arpa/inet.h&gt;\n  9 #include &lt;unistd.h&gt;\n 10 #include &lt;signal.h&gt;\n 11 #include &lt;sys/wait.h&gt;\n 12 #include &lt;pthread.h&gt;\n 13 \n 14 \n 15 #define  BACKLOG 5\n 16 \n 17 class Prama{\n 18   public:\n 19     int sock;\n 20     std::string ip;\n 21     short port;\n 22 \n 23     Prama(int _sock, std::string _ip, short _port)                                                                                                     \n 24       :sock(_sock)\n 25        ,ip(_ip)\n 26        ,port(_port)\n 27   {}\n 28     ~Prama()\n 29     {}\n 30 };\n 31 \n 32 \n 33 class TcpServer{                                                                                                                                       \n 34   private:\n 35     short port;\n 36     int listen_sock;\n 37   public:\n 38     TcpServer(short _port)\n 39       :port(_port)\n 40        ,listen_sock(-1)\n 41   {}\n 42     bool InitTcpServer()\n 43     {\n 44       listen_sock = socket(AF_INET, SOCK_STREAM, 0);\n 45       if(listen_sock &lt; 0){\n 46         std::cerr &lt;&lt; \"socket error\" &lt;&lt; std::endl;\n 47         return false;\n 48       }\n 49 \n 50       struct sockaddr_in local;\n 51       //bzero(&amp;local, sizeof(local));\n 52       memset(&amp;local, 0, sizeof(local));\n 53       local.sin_family = AF_INET;\n 54       local.sin_port = htons(port);\n 55       local.sin_addr.s_addr = INADDR_ANY;\n 56 \n 57       if(bind(listen_sock, (struct sockaddr*)&amp;local, sizeof(local)) &lt; 0){\n 58         std::cerr &lt;&lt; \"bind error\" &lt;&lt; std::endl;\n 59         return false;\n 60       }\n 61       \n 62       if(listen(listen_sock, BACKLOG) &lt; 0){\n 63         std::cerr &lt;&lt; \"listen error\" &lt;&lt;std::endl;                                                                                                       \n 64         return false;\n 65       }\n 66       std::cout &lt;&lt; \"listen success\" &lt;&lt; std::endl;\n 67       return true;\n 68     }\n 69 \n 70     static void* HanderRequest(void* arg)\n 71     {\n 72       Prama* p = (Prama*)arg;\n 73 \n 74       //è¿™é‡Œè¦åˆ†ç¦»ï¼Œä¸åˆ†ç¦»ä¹Ÿä¸ç­‰çš„è¯ï¼Œä¼šå‡ºç°åƒåƒµå°¸è¿›ç¨‹ä¸€æ ·çš„ä¸œè¥¿\n 75       pthread_detach(pthread_self());\n 76 \n 77       Service(p-&gt;sock, p-&gt;ip, p-&gt;port);\n 78 \n 79       close(p-&gt;sock);\n 80       delete p;\n 81       return nullptr;\n 82     }\n 83     void Loop()\n 84     {\n 85       //è¿™æ ·å†™çˆ¶è¿›ç¨‹å°±ä¸ç”¨ç­‰å­è¿›ç¨‹äº†ï¼Œå¾ˆæ¨èï¼Œå› ä¸ºå¾ˆç®€å•\n 86       //signal(SIGCHLD, SIG_IGN);\n 87       struct sockaddr_in peer;\n 88       for(;;)\n 89       {\n 90         //å…ˆè·å–é“¾æ¥\n 91         socklen_t len = sizeof(peer);\n 92         int sock = accept(listen_sock, (struct sockaddr*)&amp;peer, &amp;len);\n 93         //è¿™é‡Œæ˜¯acceptå¤±è´¥\n 94         if(sock &lt; 0){\n 95           std::cerr &lt;&lt; \"accept error\" &lt;&lt; std::endl;\n 96           continue;                                                                                                                                    \n 97         }\n 98         \n 99         pthread_t tid;\n100         std::string ip = inet_ntoa(peer.sin_addr);\n101         short port = ntohs(peer.sin_port);\n102         //è¿™é‡Œå› ä¸ºå¯èƒ½ä¼šå‡ºç°å¹¶å‘çš„é—®é¢˜ï¼Œä¹Ÿå°±æ˜¯sockçš„ç»“æœå¯èƒ½ä¼šå‡ºç°é—®é¢˜\n103         //æ‰€ä»¥æˆ‘ä»¬è¿™é‡Œæœ‰ä¸€ç§æ–¹æ³•å¯ä»¥newä¸€ä¸ªpï¼Œè¿™æ ·på°±è‚¯å®šæ˜¯å±äºç‰¹å®šä¸€ä¸ªçº¿ç¨‹äº†\n104         Prama* p = new Prama(sock, ip, port);\n105         pthread_create(&amp;tid, nullptr, HanderRequest, p);\n106 \n107 \n108       }\n109 \n110     }\n111 \n112     //è¿™é‡Œæˆ‘ä»¬å°† sock ip port éƒ½ä¼ è¿›æ¥äº†ï¼Œæ‰€ä»¥è¿™é‡Œæˆ‘ä»¬å¯ä»¥è®¾æˆstatic\n113     //ä¹Ÿä¸ºäº†è®©HanderRequeteè°ƒç”¨\n114     static void Service(int sock, std::string&amp; ip, short port)                                                                                         \n115     {\n116       char buffer[1024];\n117       while(true){\n118         ssize_t size = read(sock, buffer, sizeof(buffer)-1);\n119         if(size &gt; 0){\n120           buffer[size] = 0;\n121           std::cout &lt;&lt; ip &lt;&lt; \":\" &lt;&lt; port &lt;&lt; \"# \" &lt;&lt; buffer &lt;&lt; std::endl;\n122           //å›æ˜¾\n123           write(sock, buffer, size);\n124         }\n125         else if (size == 0){\n126           std::cout &lt;&lt; ip &lt;&lt; \":\" &lt;&lt; port &lt;&lt; \"close!\" &lt;&lt; buffer &lt;&lt; std::endl;\n127           break;\n128         }\n129         else{\n130           std::cerr &lt;&lt; port &lt;&lt; \"read error\" &lt;&lt; std::endl;\n131           break;\n132         }\n133       }\n134       \n135       std::cout &lt;&lt; \"Service done!\" &lt;&lt; std::endl;\n136     }\n137 \n138     ~TcpServer()\n139     {\n140       if(listen_sock &gt;= 0){\n141         close(listen_sock);\n142       }\n143     }\n144 };</code></pre>\n<h3 id=\"%C2%A0tcp_client.cc\"><strong><span style=\"color:#ad720d;\"> tcp_client.cc</span></strong></h3>\n<pre><code class=\"language-cpp\">  1 #include \"tcp_client.hpp\"\n  2 \n  3 \n  4 int main(int argc, char* argv[])\n  5 {\n  6   if(argc != 3){\n  7     std::cout &lt;&lt; \"Usage: \" &lt;&lt; argv[0] &lt;&lt; \"ip port\" &lt;&lt; std::endl;\n  8     exit(1);\n  9   }\n 10 \n 11   TcpClient tclt(argv[1], atoi(argv[2]));                                                                                  \n 12   tclt.InitTcpClient();\n 13 \n 14   tclt.Loop();\n 15 \n 16   return 0;\n 17 }\n</code></pre>\n<p><strong>        å½“ç„¶è¿™é‡Œä¹Ÿæ˜¯åªå¯¹ tcp_server.hpp åšäº†å¤„ç†ï¼Œå…·ä½“çš„æƒ…å†µï¼Œå¤§å®¶å»çœ‹ä»£ç çš„ä¸åŒå§ï¼Œå¤§è‡´å°±æ˜¯åˆ›å»ºçº¿ç¨‹ï¼Œç„¶åè®©çº¿ç¨‹åˆ†ç¦»å†è®©çº¿ç¨‹æ‰§è¡ŒæœåŠ¡çš„æ“ä½œï¼Œç„¶åå…¶ä¸­çš„æœåŠ¡ä¹Ÿæ”¹æˆäº† staticï¼Œä¸ºäº†è®© static çš„ Hander å¯ä»¥è°ƒç”¨ï¼Œåˆå› ä¸º Hander é‡Œè¦ç”¨åˆ° sockã€ipã€port ï¼Œæ‰€ä»¥è®¾è®¡äº†ä¸€ä¸ªç±»è¿›è¡Œä¿å­˜ï¼Œç„¶åä¼ ç»™ Handerã€‚</strong></p>\n<p><strong><img alt=\"\" height=\"813\" src=\"..\\..\\static\\image\\3bacd6f9d1da4842b7e439abb3286c87.png\" width=\"1200\"/></strong></p>\n<p><strong>        æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œå’Œå¤šè¿›ç¨‹ç›¸æ¯”ï¼Œé™¤äº†ç»†èŠ‚ä¸Šçš„ä¸åŒï¼Œæ•ˆæœä¸Šå¤§è‡´æ˜¯ç›¸åŒçš„ï¼Œé‚£ä¹ˆè¿™é‡Œæˆ‘ä¹Ÿå°±ä¸è¿‡å¤šèµ˜è¿°äº†ã€‚</strong></p>\n<h2 id=\"4.5%C2%A0TCP%20%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%89%88%E6%9C%AC)\"><strong><span style=\"color:#9c8ec1;\">4.5 TCP å¤šçº¿ç¨‹(çº¿ç¨‹æ± ç‰ˆæœ¬)</span></strong></h2>\n<p><strong>        ä¸Šé¢å¤šçº¿ç¨‹æ˜¯åˆ°ç”¨çš„æ—¶å€™ï¼Œå»åˆ›å»ºæ–°çº¿ç¨‹ï¼Œæ²¡æœ‰ä»€ä¹ˆé—®é¢˜ï¼Œå°±æ˜¯æ•ˆç‡å¾ˆä½ã€‚</strong></p>\n<p><strong>        å¥½çš„åšæ³•æ˜¯ï¼Œå·²ç»éƒ½æœ‰çº¿ç¨‹äº†ï¼Œæœ‰äººéœ€è¦æœåŠ¡ï¼Œé‚£ä¹ˆç›´æ¥ä½¿ç”¨çº¿ç¨‹å°±å¥½ã€‚</strong></p>\n<p><strong>        è¿˜æœ‰ä¸€ç‚¹æ˜¯ï¼Œå¦‚æœçº¿ç¨‹å¤šäº†ï¼Œçº¿ç¨‹ä¹‹é—´çš„ç›¸äº’åˆ‡æ¢çš„é¢‘ç‡ä¹Ÿå°±ä¼šé«˜ï¼Œä¹Ÿå°±æ˜¯æˆæœ¬å¾ˆé«˜ï¼Œå¯¼è‡´æ•ˆç‡éå¸¸ä½ã€‚æ¯”æ–¹è¯´ç¬¬ä¸€ä¸ªçº¿ç¨‹æ‰§è¡Œäº†ä¸€ç‚¹è¢«åˆ‡èµ°äº†ï¼Œç›´åˆ°æ‰§è¡Œåˆ°äº†ç¬¬ä¸€åƒä¸ªçº¿ç¨‹æ‰åˆ‡æ¢å›æ¥ï¼Œå› ä¸ºçº¿ç¨‹ä»£è¡¨çš„æ˜¯ç”¨æˆ·ï¼Œåœ¨ç”¨æˆ·çœ‹æ¥å°±æ˜¯ä½ çš„æœåŠ¡æä¾›çš„æœ‰é—®é¢˜ã€‚</strong></p>\n<p><strong>        æ‰€ä»¥æˆ‘ä»¬è¿™é‡Œåº”è¯¥è®¾ç½®å¥½çº¿ç¨‹çš„ä¸ªæ•°ï¼Œå¦‚æœç”³è¯·çš„äººå¤šï¼Œé‚£ä¹ˆå°±è®©ç”¨æˆ·æ’é˜Ÿï¼Œæœ€èµ·ç è®©æ­£åœ¨æ¥æ”¶æœåŠ¡çš„äººå¾—åˆ°å¥½çš„æœåŠ¡ã€‚</strong></p>\n<p><strong>        æ‰€ä»¥è¿™ä¸ªæ–¹æ¡ˆå°±æ˜¯åŸºäºå¤šçº¿ç¨‹çš„çº¿ç¨‹æ± æ–¹æ¡ˆã€‚</strong></p>\n<h3 id=\"ThreadPool.hpp\"><strong><span style=\"color:#ad720d;\">ThreadPool.hpp</span></strong></h3>\n<pre><code class=\"language-cpp\">  1 #pragma once\n  2 \n  3 #include &lt;iostream&gt;\n  4 #include &lt;queue&gt;\n  5 #include &lt;pthread.h&gt;\n  6 \n  7 #define NUM 5\n  8 \n  9 template&lt;typename T&gt;\n 10 class ThreadPool{\n 11 private:\n 12   int thread_num;\n 13   std::queue&lt;T&gt; task_queue;\n 14   pthread_mutex_t lock;\n 15   pthread_cond_t cond;\n 16 \n 17 public:\n 18   ThreadPool(int _num = NUM)\n 19     :thread_num(_num)\n 20   {\n 21     pthread_mutex_init(&amp;lock, nullptr);\n 22     pthread_cond_init(&amp;cond, nullptr);\n 23   }\n 24 \n 25   //å› ä¸ºstaticä¸èƒ½ç›´æ¥è®¿é—®private\n 26   //æ‰€ä»¥è¦å¯¹å…¶è¿›è¡Œå°è£…\n 27   void LockQueue()\n 28   {\n 29     pthread_mutex_lock(&amp;lock);                                                                                                                                                       \n 30   }\n 31   void UnlockQueue()\n 32   {\n 33     pthread_mutex_unlock(&amp;lock);\n 34   }\n 35   bool IsEmpty()\n 36   {\n 37     return task_queue.empty();\n 38   }\n 39   void Wait()\n 40   {\n 41     pthread_cond_wait(&amp;cond, &amp;lock);\n 42   }\n 43   void Wakeup()\n 44   {\n 45     pthread_cond_signal(&amp;cond);\n 46   }\n 47   // è¿™é‡Œè¦ç”¨staticæ˜¯å› ä¸ºåœ¨ç±»é‡Œå†™æˆå‘˜å‡½æ•°æ—¶ä¼šå¸¦ä¸Š\n 48   // thisæŒ‡é’ˆï¼Œä½†æ˜¯è¿™ä¸ªå‚æ•°åªèƒ½ä¼ ä¸€ä¸ªvoid*ç±»å‹çš„å‚æ•°                                                                                                                                 \n 49   static void* Routine(void* arg)\n 50   {\n 51     pthread_detach(pthread_self());\n 52     ThreadPool* self = (ThreadPool*)arg;\n 53     while(true){\n 54       self-&gt;LockQueue();\n 55       while(self-&gt;IsEmpty()){\n 56         //wait\n 57         self-&gt;Wait();\n 58       }\n 59       //ä»»åŠ¡\n 60      T t;\n 61      self-&gt;Pop(t);\n 62      self-&gt;UnlockQueue();\n 63      //å› ä¸ºæ‰§è¡Œä»»åŠ¡çš„æ—¶å€™ï¼Œè¿™ä¸ªä»»åŠ¡å±äºä½ å½“å‰çº¿ç¨‹\n 64      //æ‰€ä»¥æ¥ä¸‹æ¥åªéœ€è¦åœ¨Unlockä¹‹åå¤„ç†å°±å¯ä»¥äº†\n 65      //å¦‚æœåœ¨é‡Œé¢å¤„ç†ï¼Œé‚£å…¶å®ƒçº¿ç¨‹è¦ç­‰ä½ å¤„ç†å®Œæ‰å¯ä»¥å¤„ç†ä¸‹ä¸€ä¸ª\n 66      //å¦‚æœè¿™æ ·ï¼Œè™½ç„¶æ˜¯çº¿ç¨‹æ± ï¼Œé‚£ä¹Ÿæ²¡æœ‰è®©å¤šä¸ªçº¿ç¨‹åŒæ—¶è·‘èµ·æ¥\n 67      t.Run();\n 68     }\n 69   }\n 70   void InitThreadPool()\n 71   {\n 72     pthread_t tid;\n 73     for(int i = 0; i &lt; thread_num; i++){\n 74       pthread_create(&amp;tid, nullptr, Routine, this);//æ‰€ä»¥è¿™é‡Œè¦ä¼ this\n 75     }                                                                                                                                                                                \n 76   }\n 77 \n 78   void Push(const T&amp; in)\n 79   {\n 80     LockQueue();\n 81     task_queue.push(in);\n 82     UnlockQueue();\n 83     //æ’å…¥æ•°æ®åå…¶å®ƒçº¿ç¨‹çš„ä¸çŸ¥é“\n 84     //æ‰€ä»¥è¦å”¤é†’å…¶å®ƒçº¿ç¨‹\n 85     Wakeup();\n 86   }\n 87 \n 88   void Pop(T&amp; out)\n 89   {\n 90     out = task_queue.front();\n 91     task_queue.pop();\n 92   }\n 93 \n 94   ~ThreadPool()\n 95   {\n 96     pthread_mutex_destroy(&amp;lock);\n 97     pthread_cond_destroy(&amp;cond);\n 98   }\n 99 };</code></pre>\n<h3 id=\"Task.hpp\"><strong><span style=\"color:#ad720d;\">Task.hpp</span></strong></h3>\n<pre><code class=\"language-cpp\">  1 #pragma once\n  2 \n  3 #include &lt;iostream&gt;\n  4 #include &lt;string&gt;\n  5 #include &lt;unistd.h&gt;\n  6 \n  7 class Handler{\n  8   public:\n  9     Handler(){}\n 10 \n 11     void operator()(int sock, std::string ip, short port)\n 12     {\n 13       char buffer[1024];\n 14       while(true){\n 15         ssize_t size = read(sock, buffer, sizeof(buffer)-1);\n 16         if(size &gt; 0){\n 17           buffer[size] = 0;\n 18           std::cout &lt;&lt; ip &lt;&lt; \":\" &lt;&lt; port &lt;&lt; \"# \" &lt;&lt; buffer &lt;&lt; std::endl;\n 19           //å›æ˜¾\n 20           write(sock, buffer, size);\n 21         }\n 22         else if (size == 0){\n 23           std::cout &lt;&lt; ip &lt;&lt; \":\" &lt;&lt; port &lt;&lt; \"close!\" &lt;&lt; buffer &lt;&lt; std::endl;\n 24           break;\n 25         }\n 26         else{\n 27           std::cerr &lt;&lt; port &lt;&lt; \"read error\" &lt;&lt; std::endl;\n 28           break;\n 29         }                                                                                                                                                                            \n 30       }\n 31 \n 32       std::cout &lt;&lt; \"Service done!\" &lt;&lt; std::endl;\n 33       close(sock);\n 34     }\n 35 \n 36     ~Handler(){}\n 37 };\n 38 \n 39                                                                                                                                                                                      \n 40 class Task{\n 41   private:\n 42     int sock;\n 43     std::string ip;\n 44     short port;\n 45     Handler handler;\n 46   public:\n 47     Task(){}\n 48     Task(int _sock, std::string _ip, short _port)\n 49       :sock(_sock)\n 50        ,ip(_ip)\n 51        ,port(_port)\n 52     {}\n 53 \n 54 \n 55     void Run()\n 56     {\n 57       handler(sock, ip, port);\n 58     }\n 59 \n 60     ~Task()\n 61     {}\n 62 };</code></pre>\n<h3><strong><span style=\"color:#ad720d;\">tcp_server.hpp</span></strong></h3>\n<pre><code class=\"language-cpp\">  1 #pragma once \n  2 \n  3 #include &lt;iostream&gt;\n  4 #include &lt;string&gt;\n  5 #include &lt;cstring&gt;\n  6 #include &lt;sys/socket.h&gt;\n  7 #include &lt;sys/types.h&gt;\n  8 #include &lt;arpa/inet.h&gt;\n  9 #include &lt;unistd.h&gt;\n 10 #include &lt;signal.h&gt;\n 11 #include &lt;sys/wait.h&gt;\n 12 #include &lt;pthread.h&gt;\n 13 #include \"ThreadPool.hpp\"\n 14 #include \"Task.hpp\"\n 15 \n 16 #define  BACKLOG 5\n 17 \n 18 class Prama{\n 19   public:\n 20     int sock;\n 21     std::string ip;\n 22     short port;\n 23 \n 24     Prama(int _sock, std::string _ip, short _port)\n 25       :sock(_sock)\n 26        ,ip(_ip)\n 27        ,port(_port)\n 28   {}\n 29     ~Prama()                                                                                                                                                                         \n 30     {}\n 31 };\n 32 \n 33 \n 34 class TcpServer{\n 35   private:\n 36     short port;\n 37     int listen_sock;\n 38     ThreadPool&lt;Task&gt;* tp;\n 39   public:                                                                                                                                                                            \n 40     TcpServer(short _port)\n 41       :port(_port)\n 42        ,listen_sock(-1)\n 43        ,tp(nullptr)\n 44   {}\n 45     bool InitTcpServer()\n 46     {\n 47       listen_sock = socket(AF_INET, SOCK_STREAM, 0);\n 48       if(listen_sock &lt; 0){\n 49         std::cerr &lt;&lt; \"socket error\" &lt;&lt; std::endl;\n 50         return false;\n 51       }\n 52 \n 53       struct sockaddr_in local;\n 54       //bzero(&amp;local, sizeof(local));\n 55       memset(&amp;local, 0, sizeof(local));\n 56       local.sin_family = AF_INET;\n 57       local.sin_port = htons(port);\n 58       local.sin_addr.s_addr = INADDR_ANY;\n 59 \n 60       if(bind(listen_sock, (struct sockaddr*)&amp;local, sizeof(local)) &lt; 0){\n 61         std::cerr &lt;&lt; \"bind error\" &lt;&lt; std::endl;\n 62         return false;\n 63       }\n 64       \n 65       if(listen(listen_sock, BACKLOG) &lt; 0){\n 66         std::cerr &lt;&lt; \"listen error\" &lt;&lt;std::endl;\n 67         return false;\n 68       }\n 69 \n 70       tp = new ThreadPool&lt;Task&gt;();\n 71 \n 72       std::cout &lt;&lt; \"listen success\" &lt;&lt; std::endl;\n 73       return true;\n 74     }\n 75 \n 76     void Loop()\n 77     {\n 78       //è¿™æ ·å†™çˆ¶è¿›ç¨‹å°±ä¸ç”¨ç­‰å­è¿›ç¨‹äº†ï¼Œå¾ˆæ¨èï¼Œå› ä¸ºå¾ˆç®€å•                                                                                                                             \n 79       //signal(SIGCHLD, SIG_IGN);\n 80       tp-&gt;InitThreadPool();\n 81       struct sockaddr_in peer;\n 82       for(;;)\n 83       {\n 84         //å…ˆè·å–é“¾æ¥\n 85         socklen_t len = sizeof(peer);\n 86         int sock = accept(listen_sock, (struct sockaddr*)&amp;peer, &amp;len);\n 87         //è¿™é‡Œæ˜¯acceptå¤±è´¥\n 88         if(sock &lt; 0){\n 89           std::cerr &lt;&lt; \"accept error\" &lt;&lt; std::endl;\n 90           continue;\n 91         }\n 92 \n 93         std::string ip = inet_ntoa(peer.sin_addr);\n 94         short port = ntohs(peer.sin_port);\n 95         \n 96         Task t(sock, ip, port);\n 97 \n 98         tp-&gt;Push(t);\n 99 \n100       }\n101     }\n102 \n103     ~TcpServer()\n104     {\n105       if(listen_sock &gt;= 0){\n106         close(listen_sock);\n107       }\n108     }\n109 };</code></pre>\n<h3><strong><span style=\"color:#ad720d;\">tcp_server.cc</span></strong></h3>\n<pre><code class=\"language-cpp\">  1 #include \"tcp_server.hpp\"\n  2 \n  3 int main(int argc, char* argv[])\n  4 {\n  5   if(argc != 2){\n  6     std::cout &lt;&lt; \"Usage: \" &lt;&lt; argv[0] &lt;&lt; \"port\" &lt;&lt; std::endl;\n  7     exit(1);\n  8   }\n  9   TcpServer tsvr(atoi(argv[1]));                                                                                                                                             \n 10   tsvr.InitTcpServer();\n 11 \n 12   tsvr.Loop();\n 13 \n 14 \n 15   return 0;\n 16 }\n</code></pre>\n<h3><strong><span style=\"color:#ad720d;\">tcp_client.hpp</span></strong></h3>\n<pre><code class=\"language-cpp\">  1 #pragma once \n  2 \n  3 #include &lt;iostream&gt;\n  4 #include &lt;string&gt;\n  5 #include &lt;cstring&gt;\n  6 #include &lt;sys/socket.h&gt;\n  7 #include &lt;sys/types.h&gt;\n  8 #include &lt;arpa/inet.h&gt;\n  9 #include &lt;unistd.h&gt;\n 10 #include &lt;signal.h&gt;\n 11 #include &lt;sys/wait.h&gt;\n 12 #include &lt;pthread.h&gt;\n 13 \n 14 \n 15 #define  BACKLOG 5\n 16 \n 17 class Prama{\n 18   public:\n 19     int sock;\n 20     std::string ip;\n 21     short port;\n 22 \n 23     Prama(int _sock, std::string _ip, short _port)                                                                                                     \n 24       :sock(_sock)\n 25        ,ip(_ip)\n 26        ,port(_port)\n 27   {}\n 28     ~Prama()\n 29     {}\n 30 };\n 31 \n 32 \n 33 class TcpServer{                                                                                                                                       \n 34   private:\n 35     short port;\n 36     int listen_sock;\n 37   public:\n 38     TcpServer(short _port)\n 39       :port(_port)\n 40        ,listen_sock(-1)\n 41   {}\n 42     bool InitTcpServer()\n 43     {\n 44       listen_sock = socket(AF_INET, SOCK_STREAM, 0);\n 45       if(listen_sock &lt; 0){\n 46         std::cerr &lt;&lt; \"socket error\" &lt;&lt; std::endl;\n 47         return false;\n 48       }\n 49 \n 50       struct sockaddr_in local;\n 51       //bzero(&amp;local, sizeof(local));\n 52       memset(&amp;local, 0, sizeof(local));\n 53       local.sin_family = AF_INET;\n 54       local.sin_port = htons(port);\n 55       local.sin_addr.s_addr = INADDR_ANY;\n 56 \n 57       if(bind(listen_sock, (struct sockaddr*)&amp;local, sizeof(local)) &lt; 0){\n 58         std::cerr &lt;&lt; \"bind error\" &lt;&lt; std::endl;\n 59         return false;\n 60       }\n 61       \n 62       if(listen(listen_sock, BACKLOG) &lt; 0){\n 63         std::cerr &lt;&lt; \"listen error\" &lt;&lt;std::endl;                                                                                                       \n 64         return false;\n 65       }\n 66       std::cout &lt;&lt; \"listen success\" &lt;&lt; std::endl;\n 67       return true;\n 68     }\n 69 \n 70     static void* HanderRequest(void* arg)\n 71     {\n 72       Prama* p = (Prama*)arg;\n 73 \n 74       //è¿™é‡Œè¦åˆ†ç¦»ï¼Œä¸åˆ†ç¦»ä¹Ÿä¸ç­‰çš„è¯ï¼Œä¼šå‡ºç°åƒåƒµå°¸è¿›ç¨‹ä¸€æ ·çš„ä¸œè¥¿\n 75       pthread_detach(pthread_self());\n 76 \n 77       Service(p-&gt;sock, p-&gt;ip, p-&gt;port);\n 78 \n 79       close(p-&gt;sock);\n 80       delete p;\n 81       return nullptr;\n 82     }\n 83     void Loop()\n 84     {\n 85       //è¿™æ ·å†™çˆ¶è¿›ç¨‹å°±ä¸ç”¨ç­‰å­è¿›ç¨‹äº†ï¼Œå¾ˆæ¨èï¼Œå› ä¸ºå¾ˆç®€å•\n 86       //signal(SIGCHLD, SIG_IGN);\n 87       struct sockaddr_in peer;\n 88       for(;;)\n 89       {\n 90         //å…ˆè·å–é“¾æ¥\n 91         socklen_t len = sizeof(peer);\n 92         int sock = accept(listen_sock, (struct sockaddr*)&amp;peer, &amp;len);\n 93         //è¿™é‡Œæ˜¯acceptå¤±è´¥\n 94         if(sock &lt; 0){\n 95           std::cerr &lt;&lt; \"accept error\" &lt;&lt; std::endl;\n 96           continue;                                                                                                                                    \n 97         }\n 98         \n 99         pthread_t tid;\n100         std::string ip = inet_ntoa(peer.sin_addr);\n101         short port = ntohs(peer.sin_port);\n102         //è¿™é‡Œå› ä¸ºå¯èƒ½ä¼šå‡ºç°å¹¶å‘çš„é—®é¢˜ï¼Œä¹Ÿå°±æ˜¯sockçš„ç»“æœå¯èƒ½ä¼šå‡ºç°é—®é¢˜\n103         //æ‰€ä»¥æˆ‘ä»¬è¿™é‡Œæœ‰ä¸€ç§æ–¹æ³•å¯ä»¥newä¸€ä¸ªpï¼Œè¿™æ ·på°±è‚¯å®šæ˜¯å±äºç‰¹å®šä¸€ä¸ªçº¿ç¨‹äº†\n104         Prama* p = new Prama(sock, ip, port);\n105         pthread_create(&amp;tid, nullptr, HanderRequest, p);\n106 \n107 \n108       }\n109 \n110     }\n111 \n112     //è¿™é‡Œæˆ‘ä»¬å°† sock ip port éƒ½ä¼ è¿›æ¥äº†ï¼Œæ‰€ä»¥è¿™é‡Œæˆ‘ä»¬å¯ä»¥è®¾æˆstatic\n113     //ä¹Ÿä¸ºäº†è®©HanderRequeteè°ƒç”¨\n114     static void Service(int sock, std::string&amp; ip, short port)                                                                                         \n115     {\n116       char buffer[1024];\n117       while(true){\n118         ssize_t size = read(sock, buffer, sizeof(buffer)-1);\n119         if(size &gt; 0){\n120           buffer[size] = 0;\n121           std::cout &lt;&lt; ip &lt;&lt; \":\" &lt;&lt; port &lt;&lt; \"# \" &lt;&lt; buffer &lt;&lt; std::endl;\n122           //å›æ˜¾\n123           write(sock, buffer, size);\n124         }\n125         else if (size == 0){\n126           std::cout &lt;&lt; ip &lt;&lt; \":\" &lt;&lt; port &lt;&lt; \"close!\" &lt;&lt; buffer &lt;&lt; std::endl;\n127           break;\n128         }\n129         else{\n130           std::cerr &lt;&lt; port &lt;&lt; \"read error\" &lt;&lt; std::endl;\n131           break;\n132         }\n133       }\n134       \n135       std::cout &lt;&lt; \"Service done!\" &lt;&lt; std::endl;\n136     }\n137 \n138     ~TcpServer()\n139     {\n140       if(listen_sock &gt;= 0){\n141         close(listen_sock);\n142       }\n143     }\n144 };</code></pre>\n<h3><strong><span style=\"color:#ad720d;\"> tcp_client.cc</span></strong></h3>\n<pre><code class=\"language-cpp\">  1 #include \"tcp_client.hpp\"\n  2 \n  3 \n  4 int main(int argc, char* argv[])\n  5 {\n  6   if(argc != 3){\n  7     std::cout &lt;&lt; \"Usage: \" &lt;&lt; argv[0] &lt;&lt; \"ip port\" &lt;&lt; std::endl;\n  8     exit(1);\n  9   }\n 10 \n 11   TcpClient tclt(argv[1], atoi(argv[2]));                                                                                  \n 12   tclt.InitTcpClient();\n 13 \n 14   tclt.Loop();\n 15 \n 16   return 0;\n 17 }\n</code></pre>\n<p><strong>        å½“ç„¶è¿™é‡Œå°±æœ‰å¾ˆå¤šçš„ç»†èŠ‚äº†ï¼Œæˆ‘å…ˆæ¥è¯´æ•´ä½“çš„æ€è·¯ï¼Œç„¶åå…·ä½“çš„å®ç°å¤§å®¶å»å¯¹ç…§ä¸Šé¢çš„ä»£ç å»çœ‹çœ‹ï¼š</strong></p>\n<p><strong>        æˆ‘å…ˆè¯´ä¸‹ï¼Œçº¿ç¨‹æ± è¿™å—æˆ‘å› ä¸ºåœ¨å¤šçº¿ç¨‹çš„æ—¶å€™è®²è¿‡ï¼Œæ‰€ä»¥è¿™é‡Œæˆ‘å°±ä¸è®²äº†ï¼Œå¤§å®¶å¯ä»¥å»çœ‹æˆ‘å¤šçº¿ç¨‹çš„åšå®¢ï¼Œå†™çš„å¾ˆè¯¦ç»†ï¼Œä»é›¶åˆ°å°¾è®²çš„å¾ˆè¯¦ç»†ï¼Œé“¾æ¥ä¹Ÿç»™å¤§å®¶è´´åˆ°æœ€å¼€å§‹äº†ã€‚</strong></p>\n<p><strong>        è¿™é‡Œå°±æ˜¯åœ¨æœåŠ¡å™¨ä¸­å…ˆåˆå§‹åŒ–çº¿ç¨‹æ± ï¼Œç„¶åå°†æœåŠ¡å™¨çš„å¾ªç¯é‡Œæ”¹ä¸ºäº†çº¿ç¨‹æ± ï¼Œç„¶åä¸»çº¿ç¨‹å°±ä¸€ç›´å°†ä»»åŠ¡ Task æ”¾åˆ°ä»»åŠ¡é˜Ÿåˆ—é‡Œã€‚</strong></p>\n<p><strong>        å› ä¸ºåœ¨ tcp_server.hpp ä¸­è¦å°†ä»»åŠ¡æ”¾åˆ°ä»»åŠ¡é˜Ÿåˆ—é‡Œï¼Œæ‰€ä»¥å°±å°†åŸæœ¬ tcp_server.hpp é‡Œçš„è®©æœåŠ¡å™¨å’Œç”¨æˆ·é€šä¿¡çš„è¿‡ç¨‹æ”¾åˆ°äº† Task.hpp é‡Œï¼Œåœ¨ Task ä¸­é€šè¿‡ Run è°ƒç”¨ handler æ–¹æ³•ï¼Œå…¶ä¸­åº”ç”¨äº†å›è°ƒå‡½æ•°ï¼Œè¿™æ ·ä¹Ÿç›¸å½“äºè¿›è¡Œäº†è§£è€¦ï¼Œå¦‚æœæƒ³æ›´æ”¹ä»»åŠ¡ç›´æ¥æ›´æ”¹ handler æ–¹æ³•ä¸­çš„æ–¹å¼å°±å¯ä»¥äº†ã€‚</strong></p>\n<p><strong>        è¿™å°±æ˜¯å¤§ä½“çš„æ€è·¯ï¼Œå…·ä½“çš„ç»†èŠ‚å¤§å®¶å»çœ‹çœ‹ä»£ç ï¼Œè‡ªå·±åŠ¨æ‰‹å»å†™å†™å§ï¼Œæ¥ä¸‹æ¥ç»™å¤§å®¶å±•ç¤ºæ•ˆæœã€‚</strong></p>\n<p><strong><img alt=\"\" height=\"813\" src=\"..\\..\\static\\image\\7ce4132adcff45639f7959f39e3a9c40.png\" width=\"1200\"/></strong></p>\n<p><strong>        æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œä»å¼€å§‹åˆ°æœ€åï¼Œä¸ç®¡æœ‰å‡ ä¸ªå®¢æˆ·ç«¯å‘æœåŠ¡å™¨ç«¯ç”³è¯·ï¼Œéƒ½åªæœ‰ç‰¹å®šçš„çº¿ç¨‹æ•°ä¸ªï¼Œå½“ç„¶è¿™é‡Œæˆ‘é»˜è®¤è®¾ç½®æˆçš„ 5 ä¸ªï¼Œè¿™ä¸ªå¯ä»¥è‡ªå·±è®¾ç½®ã€‚</strong></p>\n<h1 id=\"5.%20%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9\"><strong><span style=\"color:#faa572;\">5. é›¶ç¢çŸ¥è¯†ç‚¹</span></strong></h1>\n<h2 id=\"5.1%C2%A0%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0\"><strong><span style=\"color:#9c8ec1;\">5.1 åœ°å€è½¬æ¢å‡½æ•°</span></strong></h2>\n<p><strong>        æœ¬èŠ‚åªä»‹ç»åŸºäºIPv4çš„socketç½‘ç»œç¼–ç¨‹ï¼Œsockaddr_inä¸­çš„æˆå‘˜struct in_addr sin_addrè¡¨ç¤º32ä½çš„IPåœ°å€ï¼Œä½†æ˜¯æˆ‘ä»¬é€šå¸¸ç”¨ç‚¹åˆ†åè¿›åˆ¶çš„å­—ç¬¦ä¸²è¡¨ç¤ºIPåœ°å€ï¼Œä»¥ä¸‹å‡½æ•°å¯ä»¥åœ¨å­—ç¬¦ä¸²è¡¨ç¤ºå’Œin_addrè¡¨ç¤ºä¹‹é—´è½¬æ¢ã€‚</strong></p>\n<p><strong>å­—ç¬¦ä¸²è½¬in_addrçš„å‡½æ•°ï¼š</strong></p>\n<p><strong><img alt=\"\" height=\"187\" src=\"..\\..\\static\\image\\92988d6e9b934286bd2249be216ffaf3.png\" width=\"1170\"/></strong></p>\n<p><strong> in_addrè½¬å­—ç¬¦ä¸²çš„å‡½æ•°ï¼š</strong></p>\n<p><strong><img alt=\"\" height=\"121\" src=\"..\\..\\static\\image\\5c0fa80678ba4765be3c297269de0336.png\" width=\"1165\"/></strong></p>\n<p><strong>        å…¶ä¸­inet_ptonå’Œinet_ntopä¸ä»…å¯ä»¥è½¬æ¢IPv4çš„in_addrï¼Œè¿˜å¯ä»¥è½¬æ¢IPv6çš„in6_addrï¼Œå› æ­¤å‡½æ•°æ¥å£æ˜¯void *addrptrã€‚</strong></p>\n<p><strong>ä»£ç ç¤ºä¾‹ï¼š</strong></p>\n<p><strong><img alt=\"\" height=\"309\" src=\"..\\..\\static\\image\\4a2d619370bc496da39394e21310bff4.png\" width=\"616\"/></strong></p>\n<h2 id=\"5.2%C2%A0%E5%85%B3%E4%BA%8Einet_ntoa\"><strong><span style=\"color:#9c8ec1;\">5.2 å…³äºinet_ntoa</span></strong></h2>\n<p><strong>        inet_ntoaè¿™ä¸ªå‡½æ•°è¿”å›äº†ä¸€ä¸ªchar*ï¼Œå¾ˆæ˜¾ç„¶æ˜¯è¿™ä¸ªå‡½æ•°è‡ªå·±åœ¨å†…éƒ¨ä¸ºæˆ‘ä»¬ç”³è¯·äº†ä¸€å—å†…å­˜æ¥ä¿å­˜ipçš„ç»“æœã€‚é‚£ä¹ˆæ˜¯å¦éœ€è¦è°ƒç”¨è€…æ‰‹åŠ¨é‡Šæ”¾å‘¢?</strong></p>\n<p><strong><img alt=\"\" height=\"80\" src=\"..\\..\\static\\image\\168318011f0d445db0a406cb1eb05b6a.png\" width=\"1129\"/></strong></p>\n<p><strong>        manæ‰‹å†Œä¸Šè¯´ï¼Œinet_ntoaå‡½æ•°ï¼Œæ˜¯æŠŠè¿™ä¸ªè¿”å›ç»“æœæ”¾åˆ°äº†é™æ€å­˜å‚¨åŒºã€‚è¿™ä¸ªæ—¶å€™ä¸éœ€è¦æˆ‘ä»¬æ‰‹åŠ¨è¿›è¡Œé‡Šæ”¾ã€‚</strong></p>\n<p><strong>        é‚£ä¹ˆé—®é¢˜æ¥äº†ï¼Œå¦‚æœæˆ‘ä»¬è°ƒç”¨å¤šæ¬¡è¿™ä¸ªå‡½æ•°ï¼Œä¼šæœ‰ä»€ä¹ˆæ ·çš„æ•ˆæœå‘¢? </strong></p>\n<p><strong>å‚è§å¦‚ä¸‹ä»£ç ï¼š</strong></p>\n<p><strong><img alt=\"\" height=\"341\" src=\"..\\..\\static\\image\\7bf96a44f2134c37b3c4762ef7888c34.png\" width=\"572\"/></strong></p>\n<p><strong>è¿è¡Œç»“æœå¦‚ä¸‹ï¼š</strong></p>\n<p><strong><img alt=\"\" height=\"45\" src=\"..\\..\\static\\image\\fdaa2c61803741bd9adbc843b72f7c01.png\" width=\"482\"/></strong></p>\n<p><strong>        å› ä¸ºinet_ntoaæŠŠç»“æœæ”¾åˆ°è‡ªå·±å†…éƒ¨çš„ä¸€ä¸ªé™æ€å­˜å‚¨åŒºï¼Œè¿™æ ·ç¬¬äºŒæ¬¡è°ƒç”¨æ—¶çš„ç»“æœä¼šè¦†ç›–æ‰ä¸Šä¸€æ¬¡çš„ç»“æœã€‚</strong></p>\n<blockquote>\n<ul><li><strong>åœ¨APUEä¸­ï¼Œæ˜ç¡®æå‡ºinet_ntoaä¸æ˜¯çº¿ç¨‹å®‰å…¨çš„å‡½æ•°ã€‚</strong></li><li><strong>ä½†æ˜¯åœ¨centos7ä¸Šæµ‹è¯•ï¼Œå¹¶æ²¡æœ‰å‡ºç°é—®é¢˜ï¼Œå¯èƒ½å†…éƒ¨çš„å®ç°åŠ äº†äº’æ–¥é”ã€‚</strong></li><li><strong>åœ¨å¤šçº¿ç¨‹ç¯å¢ƒä¸‹ï¼Œæ¨èä½¿ç”¨inet_ntopï¼Œè¿™ä¸ªå‡½æ•°ç”±è°ƒç”¨è€…æä¾›ä¸€ä¸ªç¼“å†²åŒºä¿å­˜ç»“æœï¼Œå¯ä»¥è§„é¿çº¿ç¨‹å®‰å…¨é—®é¢˜ã€‚</strong></li></ul>\n</blockquote>\n<p><img alt=\"\" height=\"1200\" src=\"..\\..\\static\\image\\282497adef754cc38ca327bf3aa9438a.jpeg\" width=\"1200\"/></p>\n<p> <strong>        å¦‚ä¸Šå°±æ˜¯ <span style=\"color:#fe2c24;\"><span style=\"background-color:#9c8ec1;\">ç½‘ç»œç¼–ç¨‹å¥—æ¥å­—</span></span> çš„æ‰€æœ‰çŸ¥è¯†ï¼Œå¦‚æœå¤§å®¶å–œæ¬¢çœ‹æ­¤æ–‡ç« å¹¶ä¸”æœ‰æ”¶è·ï¼Œå¯ä»¥æ”¯æŒä¸‹ <span style=\"color:#ff9900;\">å…”7</span> ï¼Œç»™ <span style=\"color:#ff9900;\">å…”7</span> ä¸‰è¿åŠ å…³æ³¨ï¼Œä½ çš„å…³æ³¨æ˜¯å¯¹æˆ‘æœ€å¤§çš„é¼“åŠ±ï¼Œä¹Ÿæ˜¯æˆ‘çš„åˆ›ä½œåŠ¨åŠ›~ï¼</strong></p>\n<p><strong>        å†æ¬¡æ„Ÿè°¢å¤§å®¶è§‚çœ‹ï¼Œæ„Ÿè°¢å¤§å®¶æ”¯æŒï¼</strong></p>\n</div>\n</div>", "first_tag": "C++", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-09-07 08:34:42", "summary": "å¤§å®¶å¥½ï¼Œæˆ‘æ˜¯å…”ï¼Œä¸€ä½åŠªåŠ›å­¦ä¹ çš„åšä¸»å¦‚æœæ–‡ç« çŸ¥è¯†ç‚¹æœ‰é”™è¯¯çš„åœ°æ–¹ï¼Œè¯·æŒ‡æ­£ï¼å’Œå¤§å®¶ä¸€èµ·å­¦ä¹ ï¼Œä¸€èµ·è¿›æ­¥å¦‚æœ‰ä¸æ‡‚ï¼Œå¯ä»¥éšæ—¶å‘æˆ‘æé—®ï¼Œæˆ‘ä¼šå…¨åŠ›è®²è§£å¦‚æœæ„Ÿè§‰åšä¸»çš„æ–‡ç« è¿˜ä¸é”™çš„è¯ï¼Œå¸Œæœ›å¤§å®¶å…³æ³¨ã€ç‚¹èµã€æ”¶è—ä¸‰è¿æ”¯æŒä¸€ä¸‹"}