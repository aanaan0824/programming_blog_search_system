{"blogid": "124093285", "writerAge": "码龄2年", "writerBlogNum": "99", "writerCollect": "141", "writerComment": "27", "writerFan": "8151", "writerGrade": "4级", "writerIntegral": "1058", "writerName": "靖瑶_", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_124093285.jpg", "writerRankTotal": "22361", "writerRankWeekly": "1104", "writerThumb": "64", "writerVisitNum": "97796", "blog_read_count": "12057", "blog_time": "于 2022-04-11 10:42:07 发布", "blog_title": "Sm4【国密4加密解密】实战", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-dark\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p>由于工作需要使用sm4加密一些个人隐私信息，就研究了一下sm4；感觉它和上章节讲的Rsa（非对称加密）很相似</p>\n<p><strong>国密算法SM1-SM4简介</strong></p>\n<blockquote>\n<p>SM1 ：为对称加密。其加密强度与AES相当。该算法不公开，调用该算法时，需要通过加密芯片的接口进行调用。</p>\n</blockquote>\n<blockquote>\n<p>SM2：非对称加密算法，基于ECC。该算法已公开。由于该算法基于ECC，故其签名速度与秘钥生成速度都快于RSA。ECC<br/> 256位（SM2采用的就是ECC 256位的一种）安全强度比RSA 2048位高，但运算速度快于RSA。</p>\n</blockquote>\n<blockquote>\n<p>SM3： 消息摘要。可以用MD5作为对比理解。该算法已公开。校验结果为256位。</p>\n</blockquote>\n<blockquote>\n<p>SM4：无线局域网标准的分组数据算法。对称加密，密钥长度和分组长度均为128位。</p>\n</blockquote>\n<p><strong>sm4</strong></p>\n<blockquote>\n<p>我国国家密码管理局在20012年公布了无线局域网产品使用的SM4密码算法——商用密码算法。<br/> 它是分组算法当中的一种，算法特点是设计简沽，结构有特点，安全高效。<br/> 数据分组长度为128比特，密钥长度为128 比特。加密算法与密钥扩展算法都采用32轮迭代结构。<br/> SM4密码算法以字节(8位)和字(32位)作为单位进行数据处理。</p>\n<p>SM4密码算法是对合运算，因此解密算法与加密算法的结构相同，只是轮密钥的使用顺序相反，解密轮密钥是加密轮密钥的逆序。</p>\n</blockquote>\n<p><strong>SM4基本算法</strong></p>\n<blockquote>\n<p>SM4密码算法使用的基本运算为异或和循环移位。</p>\n<p>异或：⊕，32位异或运算</p>\n<p>循环移位：&lt;&lt;&lt;i，把32位字循环左移i位</p>\n<p>字：(32位)</p>\n</blockquote>\n<p>1.依赖</p>\n<pre><code>    &lt;!--sm4加密算法依赖--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.bouncycastle&lt;/groupId&gt;\n            &lt;artifactId&gt;bcprov-jdk15on&lt;/artifactId&gt;\n            &lt;version&gt;1.59&lt;/version&gt;\n        &lt;/dependency&gt;\n</code></pre>\n<p>2.工具类</p>\n<pre><code>\nimport java.security.Key;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.NoSuchProviderException;\nimport java.security.SecureRandom;\nimport java.security.Security;\nimport java.util.Arrays;\nimport javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.spec.SecretKeySpec;\nimport org.bouncycastle.jce.provider.BouncyCastleProvider;\nimport org.bouncycastle.pqc.math.linearalgebra.ByteUtils;\n\n/**\n * sm4加密算法工具类\n * @explain sm4加密、解密与加密结果验证 可逆算法\n * @Autor：jingyao\n */\npublic class Sm4Util {\n    static {\n        Security.addProvider(new BouncyCastleProvider());\n    }\n    private static final String ENCODING = \"UTF-8\";\n    public static final String ALGORITHM_NAME = \"SM4\";\n    // 加密算法/分组加密模式/分组填充方式\n    // PKCS5Padding-以8个字节为一组进行分组加密\n    // 定义分组加密模式使用：PKCS5Padding\n    public static final String ALGORITHM_NAME_ECB_PADDING = \"SM4/ECB/PKCS5Padding\";\n    // 128-32位16进制；256-64位16进制\n    public static final int DEFAULT_KEY_SIZE = 128;\n\n    /**\n     * 生成ECB暗号\n     * @explain ECB模式（电子密码本模式：Electronic codebook）\n     * @param algorithmName 算法名称\n     * @param mode 模式\n     * @param key\n     * @return\n     * @throws Exception\n     */\n    private static Cipher generateEcbCipher(String algorithmName, int mode, byte[] key) throws Exception {\n        Cipher cipher = Cipher.getInstance(algorithmName, BouncyCastleProvider.PROVIDER_NAME);\n        Key sm4Key = new SecretKeySpec(key, ALGORITHM_NAME);\n        cipher.init(mode, sm4Key);\n        return cipher;\n    }\n\n    /**\n     * 自动生成密钥\n     * @explain\n     * @return\n     * @throws NoSuchAlgorithmException\n     * @throws NoSuchProviderException\n     */\n    public static byte[] generateKey() throws Exception {\n        return generateKey(DEFAULT_KEY_SIZE);\n    }\n\n\n    //加密******************************************\n    /**\n     * @explain 系统产生秘钥\n     * @param keySize\n     * @return\n     * @throws Exception\n     */\n    public static byte[] generateKey(int keySize) throws Exception {\n        KeyGenerator kg = KeyGenerator.getInstance(ALGORITHM_NAME, BouncyCastleProvider.PROVIDER_NAME);\n        kg.init(keySize, new SecureRandom());\n        return kg.generateKey().getEncoded();\n    }\n\n    /**\n     * sm4加密\n     * @explain 加密模式：ECB 密文长度不固定，会随着被加密字符串长度的变化而变化\n     * @param hexKey 16进制密钥（忽略大小写）\n     * @param paramStr 待加密字符串\n     * @return 返回16进制的加密字符串\n     * @throws Exception\n     */\n    public static String encryptEcb(String hexKey, String paramStr) throws Exception {\n        String cipherText = \"\";\n        // 16进制字符串--&gt;byte[]\n        byte[] keyData = ByteUtils.fromHexString(hexKey);\n        // String--&gt;byte[]\n        byte[] srcData = paramStr.getBytes(ENCODING);\n        // 加密后的数组\n        byte[] cipherArray = encrypt_Ecb_Padding(keyData, srcData);\n        // byte[]--&gt;hexString\n        cipherText = ByteUtils.toHexString(cipherArray);\n        return cipherText;\n    }\n\n    /**\n     * 加密模式之Ecb\n     * @param key\n     * @param data\n     * @return\n     * @throws Exception\n     */\n    public static byte[] encrypt_Ecb_Padding(byte[] key, byte[] data) throws Exception {\n        Cipher cipher = generateEcbCipher(ALGORITHM_NAME_ECB_PADDING, Cipher.ENCRYPT_MODE, key);//声称Ecb暗号,通过第二个参数判断加密还是解密\n        return cipher.doFinal(data);\n    }\n\n    //解密****************************************\n    /**\n     * sm4解密\n     * @explain 解密模式：采用ECB\n     * @param hexKey 16进制密钥\n     * @param cipherText 16进制的加密字符串（忽略大小写）\n     * @return 解密后的字符串\n     * @throws Exception\n     */\n    public static String decryptEcb(String hexKey, String cipherText) throws Exception {\n        // 用于接收解密后的字符串\n        String decryptStr = \"\";\n        // hexString--&gt;byte[]\n        byte[] keyData = ByteUtils.fromHexString(hexKey);\n        // hexString--&gt;byte[]\n        byte[] cipherData = ByteUtils.fromHexString(cipherText);\n        // 解密\n        byte[] srcData = decrypt_Ecb_Padding(keyData, cipherData);\n        // byte[]--&gt;String\n        decryptStr = new String(srcData, ENCODING);\n        return decryptStr;\n    }\n\n    /**\n     * 解密\n     * @explain\n     * @param key\n     * @param cipherText\n     * @return\n     * @throws Exception\n     */\n    public static byte[] decrypt_Ecb_Padding(byte[] key, byte[] cipherText) throws Exception {\n        Cipher cipher = generateEcbCipher(ALGORITHM_NAME_ECB_PADDING, Cipher.DECRYPT_MODE, key);//生成Ecb暗号,通过第二个参数判断加密还是解密\n        return cipher.doFinal(cipherText);\n    }\n\n    /**\n     * 校验加密前后的字符串是否为同一数据\n     * @explain\n     * @param hexKey 16进制密钥（忽略大小写）\n     * @param cipherText 16进制加密后的字符串\n     * @param paramStr 加密前的字符串\n     * @return 是否为同一数据\n     * @throws Exception\n     */\n    public static boolean verifyEcb(String hexKey, String cipherText, String paramStr) throws Exception {\n        // 用于接收校验结果\n        boolean flag = false;\n        // hexString--&gt;byte[]\n        byte[] keyData = ByteUtils.fromHexString(hexKey);\n        // 将16进制字符串转换成数组\n        byte[] cipherData = ByteUtils.fromHexString(cipherText);\n        // 解密\n        byte[] decryptData = decrypt_Ecb_Padding(keyData, cipherData);\n        // 将原字符串转换成byte[]\n        byte[] srcData = paramStr.getBytes(ENCODING);\n        // 判断2个数组是否一致\n        flag = Arrays.equals(decryptData, srcData);\n        return flag;\n    }\n\n}\n</code></pre>\n<p>3.测试一下</p>\n<pre><code>import com.example.mybatiseplusdemo.util.Sm4Util;\n\npublic class Sm4Test {\n    public static void main(String[] args) {\n        try {\n            System.out.println(\"开始测试SM4加密解密====================\");\n            String json = \"{\\\"name\\\":\\\"静瑶\\\",\\\"描述\\\":\\\"测试SM4加密解密\\\"}\";\n            System.out.println(\"加密前：\"+json);\n            //自定义的32位16进制秘钥\n            String key = \"86C63180C2806ED1F47B859DE501215B\";\n            String cipher = Sm4Util.encryptEcb(key,json);//sm4加密\n            System.out.println(\"加密后：\"+cipher);\n            System.out.println(\"校验：\"+Sm4Util.verifyEcb(key,cipher,json));//校验加密前后是否为同一数据\n            json = Sm4Util.decryptEcb(key,cipher);//解密\n            System.out.println(\"解密后：\"+json);\n            System.out.println(\"结束===================\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n    }\n}\n\n</code></pre>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "Java", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2022-04-11 10:42:07", "summary": "由于工作需要使用加密一些个人隐私信息，就研究了一下；感觉它和上章节讲的非对称加密很相似国密算法简介：为对称加密。其加密强度与相当。该算法不公开，调用该算法时，需要通过加密芯片的接口进行调用。：非对称加"}