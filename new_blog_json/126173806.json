{"blogid": "126173806", "writerAge": "码龄4年", "writerBlogNum": "164", "writerCollect": "4583", "writerComment": "2524", "writerFan": "25516", "writerGrade": "6级", "writerIntegral": "8067", "writerName": "fanstuck", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126173806.jpg", "writerRankTotal": "1632", "writerRankWeekly": "25", "writerThumb": "2599", "writerVisitNum": "326451", "blog_read_count": "2991", "blog_time": "已于 2022-08-15 19:11:26 修改", "blog_title": "K-means聚类算法一文详解+Python代码实例", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"%E5%89%8D%E8%A8%80-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%89%8D%E8%A8%80\">前言</a></p>\n<p id=\"%E4%B8%80%E3%80%81%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%80%E3%80%81%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90\">一、聚类分析</a></p>\n<p id=\"%E4%BA%8C%E3%80%81K-means%E5%8E%9F%E7%90%86-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BA%8C%E3%80%81K-means%E5%8E%9F%E7%90%86\">二、K-means原理</a></p>\n<p id=\"1.%E8%B7%9D%E7%A6%BB%E5%BA%A6%E9%87%8F%E7%AE%97%E6%B3%95-toc\" style=\"margin-left:40px;\"><a href=\"#1.%E8%B7%9D%E7%A6%BB%E5%BA%A6%E9%87%8F%E7%AE%97%E6%B3%95\">1.距离度量算法</a></p>\n<p id=\"1.%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E8%B7%9D%E7%A6%BB%EF%BC%88%E6%AC%A7%E6%B0%8F%E8%B7%9D%E7%A6%BB%EF%BC%89-toc\" style=\"margin-left:80px;\"><a href=\"#1.%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E8%B7%9D%E7%A6%BB%EF%BC%88%E6%AC%A7%E6%B0%8F%E8%B7%9D%E7%A6%BB%EF%BC%89\">欧几里得距离（欧氏距离）</a></p>\n<p id=\"%E6%9B%BC%E5%93%88%E9%A1%BF%E8%B7%9D%E7%A6%BB-toc\" style=\"margin-left:80px;\"><a href=\"#%E6%9B%BC%E5%93%88%E9%A1%BF%E8%B7%9D%E7%A6%BB\">曼哈顿距离</a></p>\n<p id=\"%E5%88%87%E6%AF%94%E9%9B%AA%E5%A4%AB%E8%B7%9D%E7%A6%BB-toc\" style=\"margin-left:80px;\"><a href=\"#%E5%88%87%E6%AF%94%E9%9B%AA%E5%A4%AB%E8%B7%9D%E7%A6%BB\">切比雪夫距离</a></p>\n<p id=\"2.K-means%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-toc\" style=\"margin-left:40px;\"><a href=\"#2.K-means%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3\">2.K-means算法思想</a></p>\n<p id=\"%E4%B8%89.K-means%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%89.K-means%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0\">三.K-means算法实现</a></p>\n<p id=\"step1%3A%E9%80%89%E5%8F%96K%E5%80%BC-toc\" style=\"margin-left:40px;\"><a href=\"#step1%3A%E9%80%89%E5%8F%96K%E5%80%BC\">step1:选取K值</a></p>\n<p id=\"1.%E6%89%8B%E8%82%98%E6%B3%95-toc\" style=\"margin-left:80px;\"><a href=\"#1.%E6%89%8B%E8%82%98%E6%B3%95\">1.手肘法</a></p>\n<p id=\"python%E4%BB%A3%E7%A0%81%EF%BC%9A-toc\" style=\"margin-left:80px;\"><a href=\"#python%E4%BB%A3%E7%A0%81%EF%BC%9A\">python代码：</a></p>\n<p id=\"2.%E8%BD%AE%E5%BB%93%E7%B3%BB%E6%95%B0%E6%B3%95-toc\" style=\"margin-left:80px;\"><a href=\"#2.%E8%BD%AE%E5%BB%93%E7%B3%BB%E6%95%B0%E6%B3%95\">2.轮廓系数法</a></p>\n<p id=\"python%E4%BB%A3%E7%A0%81%EF%BC%9A-toc\" style=\"margin-left:80px;\"><a href=\"#python%E4%BB%A3%E7%A0%81%EF%BC%9A\">python代码：</a></p>\n<p id=\"%C2%A0step2%3A%E8%AE%A1%E7%AE%97%E5%88%9D%E5%A7%8B%E5%8C%96K%E7%82%B9-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A0step2%3A%E8%AE%A1%E7%AE%97%E5%88%9D%E5%A7%8B%E5%8C%96K%E7%82%B9\"> step2:计算初始化K点</a></p>\n<p id=\"%C2%A0step3%3A%E8%BF%AD%E4%BB%A3%E8%AE%A1%E7%AE%97%E9%87%8D%E6%96%B0%E5%88%92%E5%88%86-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A0step3%3A%E8%BF%AD%E4%BB%A3%E8%AE%A1%E7%AE%97%E9%87%8D%E6%96%B0%E5%88%92%E5%88%86\"> step3:迭代计算重新划分</a></p>\n<p id=\"%C2%A0%C2%A0step4%3A%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B1%95%E7%8E%B0-toc\" style=\"margin-left:40px;\"><a href=\"#%C2%A0%C2%A0step4%3A%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B1%95%E7%8E%B0\">  step4:可视化展现</a></p>\n<p id=\"%E5%9B%9B%E3%80%81K-means%E4%BC%98%E7%BC%BA%E7%82%B9-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%9B%9B%E3%80%81K-means%E4%BC%98%E7%BC%BA%E7%82%B9\">四、K-means优缺点</a></p>\n<p id=\"%E4%BC%98%E7%82%B9%EF%BC%9A-toc\" style=\"margin-left:40px;\"><a href=\"#%E4%BC%98%E7%82%B9%EF%BC%9A\">优点：</a></p>\n<p id=\"%E7%BC%BA%E7%82%B9%EF%BC%9A-toc\" style=\"margin-left:40px;\"><a href=\"#%E7%BC%BA%E7%82%B9%EF%BC%9A\">缺点：</a></p>\n<p id=\"%E7%82%B9%E5%85%B3%E6%B3%A8%EF%BC%8C%E9%98%B2%E8%B5%B0%E4%B8%A2%EF%BC%8C%E5%A6%82%E6%9C%89%E7%BA%B0%E6%BC%8F%E4%B9%8B%E5%A4%84%EF%BC%8C%E8%AF%B7%E7%95%99%E8%A8%80%E6%8C%87%E6%95%99%EF%BC%8C%E9%9D%9E%E5%B8%B8%E6%84%9F%E8%B0%A2-toc\" style=\"margin-left:40px;\"><a href=\"#%E7%82%B9%E5%85%B3%E6%B3%A8%EF%BC%8C%E9%98%B2%E8%B5%B0%E4%B8%A2%EF%BC%8C%E5%A6%82%E6%9C%89%E7%BA%B0%E6%BC%8F%E4%B9%8B%E5%A4%84%EF%BC%8C%E8%AF%B7%E7%95%99%E8%A8%80%E6%8C%87%E6%95%99%EF%BC%8C%E9%9D%9E%E5%B8%B8%E6%84%9F%E8%B0%A2\">点关注，防走丢，如有纰漏之处，请留言指教，非常感谢</a></p>\n<p id=\"%E5%8F%82%E9%98%85%EF%BC%9A-toc\" style=\"margin-left:0px;\"><a href=\"#%E5%8F%82%E9%98%85%EF%BC%9A\">参阅：</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h1 id=\"%E5%89%8D%E8%A8%80\"><a id=\"_7\"></a>前言</h1>\n<p>博主共参与了数十场数学建模，其中对于未给出标签的数据进行分析时一般第一个想到的就是聚类算法。聚类算法分析又称群分析，它是研究（样品或指标）分类问题的一种统计分析方法，同时也是数据挖掘的一个重要算法。聚类（Cluster）分析是由若干模式（Pattern）组成的，通常，模式是一个度量（Measurement）的向量，或者是多维空间中的一个点。聚类分析以相似性为基础，在一个聚类中的模式之间比不在同一聚类中的模式之间具有更多的相似性。</p>\n<p>K-means均值聚类算法作为最经典也是最基础的无标签分类学习算法，根据不断的迭代优化衍生出许多十分好用的算法，例如K-mean++、K-MEDOIDS等。因此学习K-means的底层原理和计算方法是十分有必要。</p>\n<p>本篇博客的愿景是希望我或者读者通过阅读这篇博客能够学会方法并能实际运用，而且能够记录到你的思想之中。希望读者看完能够提出错误或者看法，博主会长期维护博客做及时更新。</p>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"379\" src=\"..\\..\\static\\image\\39e28ec7f5af404dbae0bf251fed1c50.jpeg\" width=\"379\"/></p>\n<hr/>\n<p></p>\n<h1 id=\"%E4%B8%80%E3%80%81%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90\"><a id=\"pandas_16\"></a>一、聚类分析</h1>\n<p>我们知道我们是使用聚类算法的目的就是从大量数据中将他们具有相关性的特征输入，然后通过算法返回标签类型。也就是说该算法的目的就是将具有相同特性的数据归纳为一类。当然我们的算法是贪心的，尽可能将所有相同类型的数据归为一类，本质还在站在分类的角度上，只不过没有标签需要我们进行运算得出。</p>\n<p>那么既然是找到具有相同性质的数据，那么回到原始的方法，例如KNN算法，我们只需要去根据两个数据点的距离去判断他们是否属于一类，其实聚类的思想也类似，只不过我们选择圆心的点不再是判断数据类型的点，而是划分为一类标签的最大范围半径的点，类似画一个最大的圆：</p>\n<div>\n<p><img alt=\"\" height=\"235\" src=\"..\\..\\static\\image\\570c188e66224c25a242655b25a32c19.png\" width=\"294\"/>​</p>\n</div>\n<h1 id=\"%E4%BA%8C%E3%80%81K-means%E5%8E%9F%E7%90%86\">二、K-means原理</h1>\n<p>既然前面我们谈到了聚类分析也就是根据彼此的相关性来划分聚类，那么他们的相关性又以什么来衡量呢？这点和KNN算法类似，这设计到了距离度量算法。</p>\n<h2 id=\"1.%E8%B7%9D%E7%A6%BB%E5%BA%A6%E9%87%8F%E7%AE%97%E6%B3%95\">1.距离度量算法</h2>\n<p>在不同情况维度下，我们计算两点之间的距离也不同，不过我们在初中高中学的两点之间的距离计算公式，为欧式距离：</p>\n<h3 id=\"1.%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E8%B7%9D%E7%A6%BB%EF%BC%88%E6%AC%A7%E6%B0%8F%E8%B7%9D%E7%A6%BB%EF%BC%89\">欧几里得距离（欧氏距离）</h3>\n<p><img alt=\"\" height=\"124\" src=\"..\\..\\static\\image\\f7415fe78be0483e9b4bf057d0798aa7.png\" width=\"671\"/></p>\n<p>衡量多维空间中的两点间距离，也是最常用的距离度量方法。</p>\n<p></p>\n<h3 id=\"%E6%9B%BC%E5%93%88%E9%A1%BF%E8%B7%9D%E7%A6%BB\">曼哈顿距离</h3>\n<p> 对于曼哈顿距离大家可能会比较陌生，这是种使用在几何度量空间的几何学用语，用以标明两个点在标准坐标系上的绝对轴距总和。</p>\n<div>\n<p><img alt=\"\" height=\"283\" src=\"..\\..\\static\\image\\a5ec01546a554421ad8739e97bd43fcc.png\" width=\"283\"/>​</p>\n</div>\n<p>图中红线代表曼哈顿距离，绿色代表欧氏距离，也就是直线距离，而蓝色和黄色代表等价的曼哈顿距离。曼哈顿距离——两点在南北方向上的距离加上在东西方向上的距离，即：</p>\n<p><img alt=\"\" height=\"100\" src=\"..\\..\\static\\image\\f67a7447d3984b67b710de97f8ed412e.png\" width=\"618\"/></p>\n<p>对于一个具有正南正北、正东正西方向规则布局的城镇街道，从一点到达另一点的距离正是在南北方向上旅行的距离加上在东西方向上旅行的距离，因此，曼哈顿距离又称为出租车距离。曼哈顿距离不是距离不变量，当坐标轴变动时，点间的距离就会不同。</p>\n<h3 id=\"%E5%88%87%E6%AF%94%E9%9B%AA%E5%A4%AB%E8%B7%9D%E7%A6%BB\">切比雪夫距离</h3>\n<p>相信大家对于距离的了解，了解多的知道除了欧式距离以外还有个曼哈顿距离，但是除去曼哈顿距离之外还有个切比雪夫距离。在数学中，切比雪夫距离或是L∞度量，是向量空间中的一种度量，二个点之间的距离定义是其各坐标数值差绝对值的最大值。</p>\n<div>\n<p><img alt=\"\" height=\"300\" src=\"..\\..\\static\\image\\3d2e615d9e8944379d40d50c305571e8.png\" width=\"300\"/>​</p>\n</div>\n<p>国际象棋棋盘上二个位置间的切比雪夫距离是指王要从一个位子移至另一个位子需要走的步数。由于王可以往斜前或斜后方向移动一格，因此可以较有效率的到达目的的格子。图是棋盘上所有位置距f6位置的切比雪夫距离。一维空间中，所有的Lp度量都是一样的，即为二座标差的绝对值。</p>\n<p>平面上两点<img alt=\"A(x_{1},y_{1}),B({x_{2},y_{2})\" class=\"mathcode\" src=\"https://latex.codecogs.com/gif.latex?A%28x_%7B1%7D%2Cy_%7B1%7D%29%2CB%28%7Bx_%7B2%7D%2Cy_%7B2%7D%29\"/>的切比雪夫距离为：</p>\n<div>\n<p><img alt=\"\" height=\"76\" src=\"..\\..\\static\\image\\fe63217c0b7b41a4ae851d00a5894d62.png\" width=\"431\"/>​</p>\n</div>\n<p> n维空间上的切比雪夫距离：</p>\n<p>n 维空间则有两点<img alt=\"A(x_{11},x_{12},...x_{1n}),B({x_{21},x_{22},x_{2n}})\" class=\"mathcode\" src=\"https://latex.codecogs.com/gif.latex?A%28x_%7B11%7D%2Cx_%7B12%7D%2C...x_%7B1n%7D%29%2CB%28%7Bx_%7B21%7D%2Cx_%7B22%7D%2Cx_%7B2n%7D%7D%29\"/></p>\n<div>\n<p><img alt=\"\" height=\"89\" src=\"..\\..\\static\\image\\c9bb96ec80a4467596bd52e538d9f42d.png\" width=\"286\"/>​</p>\n</div>\n<h2 id=\"2.K-means%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3\">2.K-means算法思想</h2>\n<p>K-means聚类算法思想可以看它设计诞生的伪代码看出：</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"..\\..\\static\\image\\e1d3b0a9ae7e4037a9b6e2237ee34734.png\"/></p>\n<p>我们发现这是一种迭代求解的聚类分析算法，其步骤是，预将数据分为K组，则随机选取K个对象作为初始的聚类中心，然后计算每个对象与各个种子聚类中心之间的距离，把每个对象分配给距离它最近的聚类中心。聚类中心以及分配给它们的对象就代表一个聚类。每分配一个样本，聚类的聚类中心会根据聚类中现有的对象被重新计算。这个过程将不断重复直到满足某个终止条件。终止条件可以是没有（或最小数目）对象被重新分配给不同的聚类，没有（或最小数目）聚类中心再发生变化，误差平方和局部最小。</p>\n<h1 id=\"%E4%B8%89.K-means%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0\">三.K-means算法实现</h1>\n<p style=\"text-align:center;\"><img alt=\"\" height=\"441\" src=\"..\\..\\static\\image\\8aef870c8b9d4c3ca1c55efedeaa8b5d.jpeg\" width=\"418\"/></p>\n<p>我们将算法步骤细化来分析：</p>\n<h2 id=\"step1%3A%E9%80%89%E5%8F%96K%E5%80%BC\">step1:选取K值</h2>\n<p>k 的选择一般是按照实际需求进行决定，或在实现算法时直接给定 k 值。这是基于项目你想要聚类的个数来决定的，但是也有不确定的情况，我们可能需要去一个最优的K值来将数据很好的归类达到最大化区分类别，这时候就需要思考从数据角度出发，应该进行怎么样的计算能够得到最优的K。</p>\n<h3 id=\"1.%E6%89%8B%E8%82%98%E6%B3%95\">1.手肘法</h3>\n<p>手肘法是最常用的确定K-means算法K值的方法，所用到的衡量标准是SSE（sum of the squared errors，误差平方和）  。</p>\n<p><img alt=\"\" height=\"1080\" src=\"..\\..\\static\\image\\7435306dd7674ee2a40b301c0479b10c.png\" width=\"1200\"/></p>\n<p>SEE各个计算在K-means里含义如下图：</p>\n<p><img alt=\"\" height=\"838\" src=\"..\\..\\static\\image\\b2dbc71b3b5c4d48a39bf4ec0f2c22b8.png\" width=\"1200\"/></p>\n<p>误差平方和又称残差平方和，根据n个观察值拟合适当的模型后，余下未能拟合部份(<img alt=\"e_{i}=y_{i}- \\bar y\" class=\"mathcode\" src=\"https://latex.codecogs.com/gif.latex?e_%7Bi%7D%3Dy_%7Bi%7D-%20%5Cbar%20y\"/>)称为<strong>残差</strong>，其中y平均表示n个观察值的平均值，所有n个残差平方之和称<strong>误差平方和</strong>。</p>\n<p>残差我在最小二乘法已经做了详细解释，想要了解的可以去看我这篇文章：</p>\n<p><a class=\"link-info\" href=\"https://blog.csdn.net/master_hunter/article/details/126058212\" title=\"一文速学-最小二乘法曲线拟合算法详解+项目代码\">一文速学-最小二乘法曲线拟合算法详解+项目代码</a></p>\n<p>在回归分析中通常用SSE表示，其大小用来表明函数拟合的好坏。将残差平方和除以自由度n-p-1(其中p为自变量个数)可以作为误差方差σ2的无偏估计，通常用来检验拟合的模型是否显著也用来寻找K值。</p>\n<p>主要思想：当k小于真实聚类数时，随着k的增大，会大幅提高类间聚合程度，SSE会大幅下降，当k达到真实聚类数时，随着k的增加，类间的聚合程度不会大幅提高，SSE的下降幅度也不会很大，所以k/SSE的折线图看起来像一个手肘，我们选取肘部的k值进行运算。</p>\n<p>这里我们以欧几里德距离来计算两点之间的相关性：</p>\n<h3 id=\"python%E4%BB%A3%E7%A0%81%EF%BC%9A\">python代码：</h3>\n<div>\n<pre><code class=\"language-python\">import matplotlib.pyplot as plt\nimport pandas as pd\nfrom sklearn.metrics import silhouette_score\nfrom sklearn.cluster import KMeans\ndata=pd.read_csv(r'C:\\Users\\10799\\get_info\\sklearn_try\\series_gpstime_level.csv')\ndistortions=[]#簇内误差平方和  SSE\nfor i in range(2,10):\n    Kmeans_model=KMeans(n_clusters=i)\n    predict_=Kmeans_model.fit_predict(data)\n    distortions.append(Kmeans_model.inertia_)\n    print(\"簇内误差平方和：\",distortions)\n#SSE  手肘法\nplt.plot(range(2,10),distortions,marker='x')\nplt.xlabel('Number of clusters')\nplt.ylabel('Distortion')\nplt.title('distortions')\nplt.show()</code></pre>\n</div>\n<p><img alt=\"\" height=\"344\" src=\"..\\..\\static\\image\\b34ef383de8549899bbeef0a30600324.png\" width=\"496\"/></p>\n<p>根据拟合图片我们知道选K为5时能够得到最效率的K值。</p>\n<h3 id=\"2.%E8%BD%AE%E5%BB%93%E7%B3%BB%E6%95%B0%E6%B3%95\">2.轮廓系数法</h3>\n<p>轮廓系数这一指标无需知道数据集的真实标签。取值范围[-1, 1]，值越大，聚类效果越好。旨在将某个对象与自己的簇的相似程度和与其他簇的相似程度作比较。轮廓系数最高的簇的数量表示簇的数量的最佳选择。</p>\n<p>轮廓系数综合考虑了内聚度和分离度两种因素。</p>\n<p>方法：  轮廓系数公式：</p>\n<p><img alt=\"S(i)=\\frac{b(i)-a(i)}{max(a(i),b(i))}\" class=\"mathcode\" src=\"https://latex.codecogs.com/gif.latex?S%28i%29%3D%5Cfrac%7Bb%28i%29-a%28i%29%7D%7Bmax%28a%28i%29%2Cb%28i%29%29%7D\"/></p>\n<p>1）计算样本i到同簇其他样本的平均距离a(i)。a(i) 越小，说明样本i越应该被聚类到该簇。将a(i)称为样本i的簇内不相似度。</p>\n<p><img alt=\"\" height=\"113\" src=\"..\\..\\static\\image\\e32ccd92189c4250b0ffb07518a92ef5.png\" width=\"351\"/></p>\n<p>最近簇定义如下：</p>\n<p><img alt=\"C_{j}=arg(\\underset{c_{k}}{min}\\frac{1}{n}\\sum_{p\\epsilon C_{k}}^{}\\left |p-X_{i} \\right |^{2} )\" class=\"mathcode\" src=\"https://latex.codecogs.com/gif.latex?C_%7Bj%7D%3Darg%28%5Cunderset%7Bc_%7Bk%7D%7D%7Bmin%7D%5Cfrac%7B1%7D%7Bn%7D%5Csum_%7Bp%5Cepsilon%20C_%7Bk%7D%7D%5E%7B%7D%5Cleft%20%7Cp-X_%7Bi%7D%20%5Cright%20%7C%5E%7B2%7D%20%29\"/></p>\n<p>2）计算样本i到其他某簇Cj的所有样本的平均距离bij，称为样本i与簇Cj 的不相似度。定义为样本i的簇间不相似度：bi =min{bi1, bi2, ..., bik}，bi越大，说明样本i越不属于其他簇。</p>\n<ul><li>轮廓系数范围在[-1,1]之间。该值越大，越合理。</li><li>si接近1，则说明样本i聚类合理；</li><li>si接近-1，则说明样本i更应该分类到另外的簇；</li><li>若si 近似为0，则说明样本i在两个簇的边界上。</li><li>有样本的s i 的均值称为聚类结果的轮廓系数，是该聚类是否合理、有效的度量。</li></ul>\n<p>3）根据样本i的簇内不相似度a(i)和簇间不相似度b(i) ，定义样本i的轮廓系数.</p>\n<p class=\"img-center\"><img alt=\"\" height=\"147\" src=\"..\\..\\static\\image\\8ccd27ea80874b80a6bca371de48714b.png\" width=\"372\"/></p>\n<p>    求出所有点的轮廓系数再求平均值就得出了平均轮廓系数，平均轮廓系数的取值在[-1,1],显然，由轮廓系数公式可以观察出，凝聚度越小，分离度越大，分类效果越好，平均轮廓系数也越大，所以，取平均轮廓系数最大的点的k值时，分类效果越好.</p>\n<h3>python代码：</h3>\n<pre><code class=\"language-python\">scores=[]  #存放轮廓系数\nfor i in range(2,10):\n    Kmeans_model=KMeans(n_clusters=i)\n    predict_=Kmeans_model.fit_predict(data)\n    scores.append( silhouette_score(data,predict_))\n    print(\"轮廓系数：\",scores)\n#轮廓系数法\nplt.plot(range(2,10),scores,marker='x')\nplt.xlabel('Number of clusters')\nplt.ylabel('scores')\nplt.title('scores')\nplt.show()</code></pre>\n<p><img alt=\"\" height=\"360\" src=\"..\\..\\static\\image\\eb25fe8448594aa082e3be7b9cd52c22.png\" width=\"565\"/></p>\n<h2 id=\"%C2%A0step2%3A%E8%AE%A1%E7%AE%97%E5%88%9D%E5%A7%8B%E5%8C%96K%E7%82%B9\"> step2:计算初始化K点</h2>\n<p>初始质心随机选择即可，每一个质心为一个类。对剩余的每个样本点，计算它们到各个质心的欧式距离，并将其归入到相互间距离最小的质心所在的簇。</p>\n<pre><code class=\"language-python\">def euclDistance(x1, x2):\n    return np.sqrt(sum((x2 - x1) ** 2))\n</code></pre>\n<pre><code class=\"language-python\">def initCentroids(data, k):\n    numSamples, dim = data.shape\n    # k个质心，列数跟样本的列数一样\n    centroids = np.zeros((k, dim))\n    # 随机选出k个质心\n    for i in range(k):\n        # 随机选取一个样本的索引\n        index = int(np.random.uniform(0, numSamples))\n        # 作为初始化的质心\n        centroids[i, :] = data[index, :]\n    return centroids\n</code></pre>\n<h2 id=\"%C2%A0step3%3A%E8%BF%AD%E4%BB%A3%E8%AE%A1%E7%AE%97%E9%87%8D%E6%96%B0%E5%88%92%E5%88%86\"> step3:迭代计算重新划分</h2>\n<ul><li>计算各个新簇的质心。</li><li>在所有样本点都划分完毕后，根据划分情况重新计算各个簇的质心所在位置，然后迭代计算各个样本点到各簇质心的距离，对所有样本点重新进行划分</li><li>重复2. 和 3.，直到质心不在发生变化时或者到达最大迭代次数时</li></ul>\n<pre><code class=\"language-python\"># 传入数据集和k值\ndef kmeans(data, k):\n    # 计算样本个数\n    numSamples = data.shape[0]\n    # 样本的属性，第一列保存该样本属于哪个簇，第二列保存该样本跟它所属簇的误差\n    clusterData = np.array(np.zeros((numSamples, 2)))\n    # 决定质心是否要改变的质量\n    clusterChanged = True\n    # 初始化质心\n    centroids = initCentroids(data, k)\n    while clusterChanged:\n        clusterChanged = False\n        # 循环每一个样本\n        for i in range(numSamples):\n            # 最小距离\n            minDist = 100000.0\n            # 定义样本所属的簇\n            minIndex = 0\n            # 循环计算每一个质心与该样本的距离\n            for j in range(k):\n                # 循环每一个质心和样本，计算距离\n                distance = euclDistance(centroids[j, :], data[i, :])\n                # 如果计算的距离小于最小距离，则更新最小距离\n                if distance &lt; minDist:\n                    minDist = distance\n                    # 更新最小距离\n                    clusterData[i, 1] = minDist\n                    # 更新样本所属的簇\n                    minIndex = j\n            # 如果样本的所属的簇发生了变化\n            if clusterData[i, 0] != minIndex:\n                # 质心要重新计算\n                clusterChanged = True\n                # 更新样本的簇\n                clusterData[i, 0] = minIndex\n        # 更新质心\n        for j in range(k):\n            # 获取第j个簇所有的样本所在的索引\n            cluster_index = np.nonzero(clusterData[:, 0] == j)\n            # 第j个簇所有的样本点\n            pointsInCluster = data[cluster_index]\n            # 计算质心\n            centroids[j, :] = np.mean(pointsInCluster, axis=0)\n    return centroids, clusterData\n</code></pre>\n<h2 id=\"%C2%A0%C2%A0step4%3A%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B1%95%E7%8E%B0\">  step4:可视化展现</h2>\n<pre><code class=\"language-python\">def showCluster(data, k, centroids, clusterData):\n    numSamples, dim = data.shape\n    if dim != 2:\n        print('dimension of your data is not 2!')\n        return 1\n    # 用不同颜色形状来表示各个类别\n    mark = ['or', 'ob', 'og', 'ok', '^r', '+r', 'dr', '&lt;r', 'pr']\n    if k &gt; len(mark):\n        print('your k is too large!')\n        return 1\n    # 画样本点\n    for i in range(numSamples):\n        markIndex = int(clusterData[i, 0])\n        plt.plot(data[i, 0], data[i, 1], mark[markIndex])\n    # 用不同颜色形状来表示各个类别\n    mark = ['*r', '*b', '*g', '*k', '^b', '+b', 'sb', 'db', '&lt;b', 'pb']\n    # 画质心点\n    for i in range(k):\n        plt.plot(centroids[i, 0], centroids[i, 1], mark[i], markersize=20)\n    plt.show()\n</code></pre>\n<p>最后结果根据 手肘法我们选取k为5：</p>\n<pre><code class=\"language-python\">k = 5\ncentroids, clusterData = kmeans(data, k)\nif np.isnan(centroids).any():\n    print('Error')\nelse:\n    print('cluster complete!')\n    # 显示结果\nshowCluster(data, k, centroids, clusterData)\n</code></pre>\n<p><img alt=\"\" height=\"357\" src=\"..\\..\\static\\image\\5d2e8087488d44c1b569479057d4d60f.png\" width=\"526\"/></p>\n<h1 id=\"%E5%9B%9B%E3%80%81K-means%E4%BC%98%E7%BC%BA%E7%82%B9\"><strong>四、K-means优缺点</strong></h1>\n<h2 id=\"%E4%BC%98%E7%82%B9%EF%BC%9A\">优点：</h2>\n<ul><li>k‐均值算法原理简单，容易实现，且运行效率比较高</li><li>k‐均值算法聚类结果容易解释，适用于高维数据的聚类</li></ul>\n<h2 id=\"%E7%BC%BA%E7%82%B9%EF%BC%9A\">缺点：</h2>\n<ul><li>k‐均值算法采用贪心策略，导致容易局部收敛，在大规模数据集上求解较慢</li><li>k‐均值算法对离群点和噪声点非常敏感，少量的离群点和噪声点可能对算法求平均值产生极大影响，从而影响聚类结果</li></ul>\n<h2 id=\"%E7%82%B9%E5%85%B3%E6%B3%A8%EF%BC%8C%E9%98%B2%E8%B5%B0%E4%B8%A2%EF%BC%8C%E5%A6%82%E6%9C%89%E7%BA%B0%E6%BC%8F%E4%B9%8B%E5%A4%84%EF%BC%8C%E8%AF%B7%E7%95%99%E8%A8%80%E6%8C%87%E6%95%99%EF%BC%8C%E9%9D%9E%E5%B8%B8%E6%84%9F%E8%B0%A2\">点关注，防走丢，<strong>如有纰漏之处，请留言指教，非常感谢</strong></h2>\n<p>以上就是本期全部内容。我是fanstuck ，有问题大家随时留言讨论 ，我们下期见。</p>\n<hr/>\n<h1 id=\"%E5%8F%82%E9%98%85%EF%BC%9A\">参阅：</h1>\n<p><a class=\"link-info\" href=\"https://baike.baidu.com/item/%E6%9B%BC%E5%93%88%E9%A1%BF%E8%B7%9D%E7%A6%BB/743092\" title=\"曼哈顿距离\">曼哈顿距离</a></p>\n<p><a class=\"link-info\" href=\"https://www.thepaper.cn/newsDetail_forward_11338779\" title=\"数据科学中常见的9种距离度量方法，内含欧氏距离、切比雪夫距离等\">数据科学中常见的9种距离度量方法，内含欧氏距离、切比雪夫距离等</a></p>\n<p><a class=\"link-info\" href=\"https://baike.baidu.com/item/K%E5%9D%87%E5%80%BC%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/15779627?fromtitle=K-means&amp;fromid=4934806&amp;fr=aladdin\" title=\"K均值聚类算法\">K均值聚类算法</a></p>\n<p><a class=\"link-info\" href=\"https://blog.csdn.net/weixin_46336091/article/details/123874584?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165967885216782184676197%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=165967885216782184676197&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-123874584-null-null.142%5Ev39%5Epc_rank_34_1,185%5Ev2%5Econtrol&amp;utm_term=K-means&amp;spm=1018.2226.3001.4187\" title=\"K-means算法（知识点梳理）\">K-means算法（知识点梳理）</a></p>\n<p><a class=\"link-info\" href=\"https://baike.baidu.com/item/%E8%AF%AF%E5%B7%AE%E5%B9%B3%E6%96%B9%E5%92%8C/554572\" title=\"误差平方和\">误差平方和</a><br/><a class=\"link-info\" href=\"https://blog.csdn.net/qq_30377909/article/details/94596305?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165986379716781790725378%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=165986379716781790725378&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-94596305-null-null.142%5Ev39%5Epc_rank_34_1,185%5Ev2%5Econtrol&amp;utm_term=K-mean%E4%BB%A3%E7%A0%81&amp;spm=1018.2226.3001.4187\" title=\"K-means算法代码实现（python）\">K-means算法代码实现（python）</a></p>\n<p><a class=\"link-info\" href=\"https://blog.csdn.net/weixin_46336091/article/details/123881505\" title=\"手撕K-means聚类算法\">手撕K-means聚类算法</a></p>\n</div>\n</div>", "first_tag": "Python", "cpp": 0, "csharp": 0, "python": 1, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-08-15 19:11:26", "summary": "目录前言一、聚类分析二、原理距离度量算法欧几里得距离欧氏距离曼哈顿距离切比雪夫距离算法思想三算法实现选取值手肘法代码：轮廓系数法代码：计算初始化点迭代计算重新划分可视化展现四、优缺点优点：缺点：点关注"}