{"blogid": "126742421", "writerAge": "码龄11年", "writerBlogNum": "54", "writerCollect": "41", "writerComment": "26", "writerFan": "44", "writerGrade": "4级", "writerIntegral": "1347", "writerName": "程龙-音视频", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126742421.jpg", "writerRankTotal": "15566", "writerRankWeekly": "8392", "writerThumb": "18", "writerVisitNum": "77570", "blog_read_count": "11", "blog_time": "于 2022-09-07 11:37:00 发布", "blog_title": "std::make_from_tuple 源码分析", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p style=\"margin-left:.0001pt;text-align:justify;\"><strong>std::make_from_tuple </strong><strong>源码分析</strong></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><strong>背景：</strong></p>\n<p style=\"margin-left:.0001pt;text-align:left;\">std::make_from_tuple 配合tuple 可以类参数构造，这个功能在c++17中还算常用，接下来分析下其内部原理</p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><strong>std::make_from_tuple </strong><strong>用例</strong></p>\n<table border=\"1\" cellspacing=\"0\"><tbody><tr><td style=\"background-color:#f5f6f7;border-color:#dee0e3;width:15cm;\"> <p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#646a73;\">C++</span><br/> #include &lt;iostream&gt;<br/> #include &lt;tuple&gt;<br/>  <br/> struct Foo {<!-- --><br/>     Foo(int first, float second, int third) {<!-- --><br/>         std::cout &lt;&lt; first &lt;&lt; \", \" &lt;&lt; second &lt;&lt; \", \" &lt;&lt; third &lt;&lt; \"\\n\";<br/>     }<br/> };<br/>  <br/> int main()<br/> {<!-- --><br/>    auto tuple = std::make_tuple(42, 3.14f, 0);<br/>    std::make_from_tuple&lt;Foo&gt;(std::move(tuple));<br/> }</p> </td></tr></tbody></table>\n<p style=\"margin-left:.0001pt;text-align:left;\">Output</p>\n<table border=\"1\" cellspacing=\"0\"><tbody><tr><td style=\"background-color:#f5f6f7;border-color:#dee0e3;width:15cm;\"> <p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#646a73;\">C++</span><br/> 42, 3.14, 0</p> </td></tr></tbody></table>\n<p style=\"margin-left:.0001pt;text-align:left;\"></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><strong>std::make_from_tuple </strong><strong>源码解析</strong></p>\n<table border=\"1\" cellspacing=\"0\"><tbody><tr><td style=\"background-color:#f5f6f7;border-color:#dee0e3;width:15cm;\"> <p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#646a73;\">C++</span><br/> template &lt;class _Tp, class _Tuple&gt;<br/> inline<br/> constexpr _Tp make_from_tuple(_Tuple&amp;&amp; __t)<br/><br/>     _VSTD::__make_from_tuple_impl&lt;_Tp&gt;(_VSTD::forward&lt;_Tuple&gt;(__t),<br/>         typename __make_tuple_indices&lt;tuple_size_v&lt;remove_reference_t&lt;_Tuple&gt;&gt;&gt;::type{})<br/>  </p> </td></tr></tbody></table>\n<p style=\"margin-left:.0001pt;text-align:left;\">可以看的出来make_from_tuple 是一个函数模版, 并且用constexpr 修饰，说明在编译期做了这个事情</p>\n<p style=\"margin-left:.0001pt;text-align:left;\">紧接着下边使用了__make_from_tuple_impl 进行调用，typename __make_tuple_indices&lt;tuple_size_v&lt;remove_reference_t&lt;_Tuple&gt;&gt;&gt;::type{} 这个也是关键的地方，把tuple里边的数据整理成__tuple_indices&lt;<em>_Idx</em>...&gt;，以供下边使用</p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><strong>tuple_size_v</strong></p>\n<table border=\"1\" cellspacing=\"0\"><tbody><tr><td style=\"background-color:#f5f6f7;border-color:#dee0e3;width:15cm;\"> <p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#646a73;\">C++</span><br/> template &lt;class _Tp&gt;<br/> _LIBCPP_INLINE_VAR constexpr size_t tuple_size_v = tuple_size&lt;_Tp&gt;::value;<br/>  </p> </td></tr></tbody></table>\n<p style=\"margin-left:.0001pt;text-align:left;\"></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><strong>tuple_size</strong></p>\n<table border=\"1\" cellspacing=\"0\"><tbody><tr><td style=\"background-color:#f5f6f7;border-color:#dee0e3;width:15cm;\"> <p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#646a73;\">C++</span><br/> template &lt;class ..._Tp&gt;<br/> struct _LIBCPP_TEMPLATE_VIS tuple_size&lt;tuple&lt;_Tp...&gt; &gt;<br/>     : public integral_constant&lt;size_t, sizeof...(_Tp)&gt;<br/> {<!-- --><br/> };</p> </td></tr></tbody></table>\n<p style=\"margin-left:.0001pt;text-align:left;\">可以看的出来它是把tuple 拆解出来，通过integral_constant记录tuple组成元素的个数</p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><strong>integral_constant</strong></p>\n<table border=\"1\" cellspacing=\"0\"><tbody><tr><td style=\"background-color:#f5f6f7;border-color:#dee0e3;width:15cm;\"> <p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#646a73;\">C++</span><br/> template &lt;class _Tp, _Tp <em>__v</em>&gt;<br/> struct _LIBCPP_TEMPLATE_VIS integral_constant<br/> {<!-- --><br/>   static _LIBCPP_CONSTEXPR const _Tp      value = <em>__v</em>;<br/>   typedef _Tp               value_type;<br/>   typedef integral_constant type;<br/>   _LIBCPP_INLINE_VISIBILITY<br/>   _LIBCPP_CONSTEXPR operator value_type() const _NOEXCEPT {return value;}<br/> };</p> </td></tr></tbody></table>\n<p style=\"margin-left:.0001pt;text-align:left;\"></p>\n<p style=\"margin-left:.0001pt;text-align:left;\">在回到上边的tuple_size_v&lt;remove_reference_t&lt;_Tuple&gt;&gt;，分析可以得出这个得到tuple的参数个数，接下来看下__make_tuple_indices它的源码__make_tuple_indices&lt;tuple_size_v&lt;remove_reference_t&lt;_Tuple&gt;&gt;&gt;</p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><strong>__make_tuple_indices</strong></p>\n<table border=\"1\" cellspacing=\"0\"><tbody><tr><td style=\"background-color:#f5f6f7;border-color:#dee0e3;width:15cm;\"> <p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#646a73;\">C++</span><br/> template &lt;size_t <em>_Ep</em>, size_t <em>_Sp </em>= 0&gt;<br/> struct __make_tuple_indices<br/> {<!-- --><br/>     static_assert(<em>_Sp </em>&lt;= <em>_Ep</em>, \"__make_tuple_indices input error\");<br/>     typedef __make_indices_imp&lt;<em>_Ep</em>, <em>_Sp</em>&gt; type;<br/> };<br/><br/> template &lt;size_t _Ep, size_t _Sp&gt;<br/> using __make_indices_imp =<br/>     typename __detail::__make&lt;_Ep - _Sp&gt;::type::template __to_tuple_indices&lt;_Sp&gt;;<br/>   <br/> template&lt;&gt; struct __make&lt;0&gt; { typedef __integer_sequence&lt;size_t&gt; type; };<br/> template&lt;&gt; struct __make&lt;1&gt; { typedef __integer_sequence&lt;size_t, 0&gt; type; };<br/> template&lt;&gt; struct __make&lt;2&gt; { typedef __integer_sequence&lt;size_t, 0, 1&gt; type; };<br/> template&lt;&gt; struct __make&lt;3&gt; { typedef __integer_sequence&lt;size_t, 0, 1, 2&gt; type; };<br/> template&lt;&gt; struct __make&lt;4&gt; { typedef __integer_sequence&lt;size_t, 0, 1, 2, 3&gt; type; };<br/> template&lt;&gt; struct __make&lt;5&gt; { typedef __integer_sequence&lt;size_t, 0, 1, 2, 3, 4&gt; type; };<br/> template&lt;&gt; struct __make&lt;6&gt; { typedef __integer_sequence&lt;size_t, 0, 1, 2, 3, 4, 5&gt; type; };<br/> template&lt;&gt; struct __make&lt;7&gt; { typedef __integer_sequence&lt;size_t, 0, 1, 2, 3, 4, 5, 6&gt; type; };<br/>  </p> </td></tr></tbody></table>\n<p style=\"margin-left:.0001pt;text-align:left;\">上边源码我整理到一起了，方便查看，举个例子假如tuple&lt;int, double, float&gt;,推导过程会是template&lt;&gt; struct __make&lt;3&gt;，其type就是__integer_sequence&lt;size_t, 0, 1, 2&gt;，也就是__detail::__make&lt;_Ep - _Sp&gt;::type == __integer_sequence&lt;size_t, 0, 1, 2&gt;， 那typename __detail::__make&lt;_Ep - _Sp&gt;::type::template __to_tuple_indices&lt;_Sp&gt; =  __integer_sequence&lt;size_t, 0, 1, 2&gt;::__to_tuple_indices&lt;_Sp&gt;, 接下来我们就看下__integer_sequence它的源码</p>\n<p style=\"margin-left:.0001pt;text-align:left;\"></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><strong>__integer_sequence</strong></p>\n<table border=\"1\" cellspacing=\"0\"><tbody><tr><td style=\"background-color:#f5f6f7;border-color:#dee0e3;width:15cm;\"> <p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#646a73;\">C++</span><br/> template &lt;size_t...&gt; struct __tuple_indices {};<br/><br/> template &lt;class _IdxType, _IdxType... <em>_Values</em>&gt;<br/> struct __integer_sequence {<!-- --><br/>   template &lt;template &lt;class _OIdxType, _OIdxType...&gt; class _ToIndexSeq, class _ToIndexType&gt;<br/>   using __convert = _ToIndexSeq&lt;_ToIndexType, <em>_Values</em>...&gt;;<br/><br/>   template &lt;size_t <em>_Sp</em>&gt;<br/>   using __to_tuple_indices = __tuple_indices&lt;(<em>_Values </em>+ <em>_Sp</em>)...&gt;;<br/> };</p> </td></tr></tbody></table>\n<p style=\"margin-left:.0001pt;text-align:left;\">这个很简单就是把用__tuple_indices记录一个index 序列</p>\n<p style=\"margin-left:.0001pt;text-align:left;\"></p>\n<p style=\"margin-left:.0001pt;text-align:left;\">经过上边解读，你活着好奇如果超过8个怎么半，你就会看到struct __make : __parity&lt;_Np % 8&gt; 推导到这个也就会它会拆分两部分，一部分是8的余数，另外一部分 如果大于8还会继续拆解，最终会把拆解后的统一合并成__tuple_indices&lt;0,1,2,3,4,....&gt;;</p>\n<table border=\"1\" cellspacing=\"0\"><tbody><tr><td style=\"background-color:#f5f6f7;border-color:#dee0e3;width:15cm;\"> <p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#646a73;\">C++</span><br/> template&lt;typename _Tp, size_t ..._Extra&gt; struct __repeat;<br/> template&lt;typename _Tp, _Tp ..._Np, size_t ..._Extra&gt; struct __repeat&lt;__integer_sequence&lt;_Tp, _Np...&gt;, _Extra...&gt; {<!-- --><br/>   typedef _LIBCPP_NODEBUG_TYPE __integer_sequence&lt;_Tp,<br/>                            _Np...,<br/>                            sizeof...(_Np) + _Np...,<br/>                            2 * sizeof...(_Np) + _Np...,<br/>                            3 * sizeof...(_Np) + _Np...,<br/>                            4 * sizeof...(_Np) + _Np...,<br/>                            5 * sizeof...(_Np) + _Np...,<br/>                            6 * sizeof...(_Np) + _Np...,<br/>                            7 * sizeof...(_Np) + _Np...,<br/>                            _Extra...&gt; type;<br/> };<br/> template&lt;size_t _Np&gt; struct __make : __parity&lt;_Np % 8&gt;::template __pmake&lt;_Np&gt; {};<br/><br/> template&lt;&gt; struct __parity&lt;0&gt; { template&lt;size_t _Np&gt; struct __pmake : __repeat&lt;typename __make&lt;_Np / 8&gt;::type&gt; {}; };<br/> template&lt;&gt; struct __parity&lt;1&gt; { template&lt;size_t _Np&gt; struct __pmake : __repeat&lt;typename __make&lt;_Np / 8&gt;::type, _Np - 1&gt; {}; };<br/> template&lt;&gt; struct __parity&lt;2&gt; { template&lt;size_t _Np&gt; struct __pmake : __repeat&lt;typename __make&lt;_Np / 8&gt;::type, _Np - 2, _Np - 1&gt; {}; };<br/> template&lt;&gt; struct __parity&lt;3&gt; { template&lt;size_t _Np&gt; struct __pmake : __repeat&lt;typename __make&lt;_Np / 8&gt;::type, _Np - 3, _Np - 2, _Np - 1&gt; {}; };<br/> template&lt;&gt; struct __parity&lt;4&gt; { template&lt;size_t _Np&gt; struct __pmake : __repeat&lt;typename __make&lt;_Np / 8&gt;::type, _Np - 4, _Np - 3, _Np - 2, _Np - 1&gt; {}; };<br/> template&lt;&gt; struct __parity&lt;5&gt; { template&lt;size_t _Np&gt; struct __pmake : __repeat&lt;typename __make&lt;_Np / 8&gt;::type, _Np - 5, _Np - 4, _Np - 3, _Np - 2, _Np - 1&gt; {}; };<br/> template&lt;&gt; struct __parity&lt;6&gt; { template&lt;size_t _Np&gt; struct __pmake : __repeat&lt;typename __make&lt;_Np / 8&gt;::type, _Np - 6, _Np - 5, _Np - 4, _Np - 3, _Np - 2, _Np - 1&gt; {}; };<br/> template&lt;&gt; struct __parity&lt;7&gt; { template&lt;size_t _Np&gt; struct __pmake : __repeat&lt;typename __make&lt;_Np / 8&gt;::type, _Np - 7, _Np - 6, _Np - 5, _Np - 4, _Np - 3, _Np - 2, _Np - 1&gt; {}; };  <br/>  </p> </td></tr></tbody></table>\n<p style=\"margin-left:.0001pt;text-align:left;\">综上所述，可以得到</p>\n<p style=\"margin-left:.0001pt;text-align:left;\">typename __make_tuple_indices&lt;tuple_size_v&lt;remove_reference_t&lt;_Tuple&gt;&gt;&gt;::type = __tuple_indices&lt;0,1,2,3,4,....&gt;，那紧接着我在看下最后的调用</p>\n<p style=\"margin-left:.0001pt;text-align:left;\"></p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><strong>__make_from_tuple_impl</strong></p>\n<table border=\"1\" cellspacing=\"0\"><tbody><tr><td style=\"background-color:#f5f6f7;border-color:#dee0e3;width:15cm;\"> <p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#646a73;\">C++</span><br/> template &lt;class _Tp, class _Tuple, size_t... <em>_Idx</em>&gt;<br/> inline _LIBCPP_INLINE_VISIBILITY<br/> constexpr _Tp __make_from_tuple_impl(_Tuple&amp;&amp; __t, __tuple_indices&lt;<em>_Idx</em>...&gt;)<br/>     _Tp(_VSTD::get&lt;<em>_Idx</em>&gt;(_VSTD::forward&lt;_Tuple&gt;(__t))...<br/> )</p> </td></tr></tbody></table>\n<p style=\"margin-left:.0001pt;text-align:left;\">可以看的出来其本质就是调用_Tp 然后通过std::get把tuple里边的参数一个一个拿出来，做为_Tp的构造方法的参数</p>\n<p style=\"margin-left:.0001pt;text-align:left;\"><strong>总结：</strong></p>\n<p style=\"margin-left:.0001pt;text-align:left;\">经过这么多其实都是编译器帮我门做的事情，最终本质就是 构造方法的调用，我门可以看下编译后的符号表是什么样的std::__1::__make_from_tuple_impl&lt;Foo, std::__1::tuple&lt;int, float, int&gt;, 0ul, 1ul, 2ul&gt;(std::__1::tuple&lt;int, float, int&gt;&amp;&amp;, std::__1::__tuple_indices&lt;0ul, 1ul, 2ul&gt;)，大体跟我们上边介绍是一样的。</p>\n<p style=\"margin-left:.0001pt;text-align:left;\">我们改进一下</p>\n<table border=\"1\" cellspacing=\"0\"><tbody><tr><td style=\"background-color:#f5f6f7;border-color:#dee0e3;width:15cm;\"> <p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#646a73;\">Assembly language</span><br/><strong>struct</strong> Foo {<!-- --><br/>     Foo(<strong>int</strong> first, <strong>float</strong> second, <strong>int</strong> third) {<!-- --><br/>         a = first;<br/>         b = second;<br/>         c = third;<br/>     }<br/>     <strong>int</strong> a;<br/>     <strong>float</strong> b;<br/>     <strong>int</strong> c;<br/> };</p> </td></tr></tbody></table>\n<p style=\"margin-left:.0001pt;text-align:left;\">我们从汇编角度看下</p>\n<table border=\"1\" cellspacing=\"0\"><tbody><tr><td style=\"background-color:#f5f6f7;border-color:#dee0e3;width:15cm;\"> <p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#646a73;\">C++</span><br/><strong>auto</strong> tuple = std::make_tuple(0x123456, 3.14f, 0);<br/> Foo fool = std::make_from_tuple&lt;Foo&gt;(std::move(tuple));</p> </td></tr></tbody></table>\n<p style=\"margin-left:.0001pt;text-align:left;\">它对应的汇编std::make_from_tuple&lt;Foo&gt;(std::move(tuple))</p>\n<table border=\"1\" cellspacing=\"0\"><tbody><tr><td style=\"background-color:#f5f6f7;border-color:#dee0e3;width:15cm;\"> <p style=\"margin-left:.0001pt;text-align:left;\"><span style=\"color:#646a73;\">C++</span><br/>  0x100003658 &lt;+16&gt;:  mov    x8, #0x3456<br/> 0x10000365c &lt;+20&gt;:  movk   x8, #0x12, lsl #16<br/> 0x100003660 &lt;+24&gt;:  movk   x8, #0xf5c3, lsl #32<br/> 0x100003664 &lt;+28&gt;:  movk   x8, #0x4048, lsl #48<br/> 0x100003668 &lt;+32&gt;:  str    x8, [sp, #0x8]<br/> 0x10000366c &lt;+36&gt;:  str    wzr, [sp, #0x10]<br/>  </p> </td></tr></tbody></table>\n<p style=\"margin-left:.0001pt;text-align:left;\">可以看的出来，根本没有函数调用，那为什么刚才那个构造方法家了cout就会有函数调用呢，是因为constexpr 推到的时候并不是真正的推到撑编译处理，因此我们看到汇编就可以搞清楚怎么回事了</p>\n</div>\n</div>", "first_tag": "C++", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-09-07 11:37:00", "summary": "源码分析背景：配合可以类参数构造，这个功能在中还算常用，接下来分析下其内部原理用例源码解析可以看的出来是一个函数模版并且用修饰，说明在编译期做了这个事情紧接着下边使用了进行调用，这个也是关键的地方，把"}