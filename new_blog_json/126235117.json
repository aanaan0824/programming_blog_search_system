{"blogid": "126235117", "writerAge": "码龄1年", "writerBlogNum": "43", "writerCollect": "1846", "writerComment": "2943", "writerFan": "2177", "writerGrade": "6级", "writerIntegral": "6934", "writerName": "敲代码の流川枫", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_126235117.jpg", "writerRankTotal": "2211", "writerRankWeekly": "65", "writerThumb": "2428", "writerVisitNum": "29461", "blog_read_count": "593", "blog_time": "已于 2022-08-09 08:53:52 修改", "blog_title": "JavaSE——继承和多态详解", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p><img alt=\"ced485cbb11e458d81a746890b32cf3f.gif\" src=\"https://img-blog.csdnimg.cn/ced485cbb11e458d81a746890b32cf3f.gif\"/></p>\n<blockquote>\n<p>作者：<span style=\"color:#faa572;\">敲代码の流川枫</span></p>\n<p>博客主页：<a href=\"https://blog.csdn.net/chenchenchencl?spm=1011.2421.3001.5343\" title=\"流川枫的博客\">流川枫的博客</a></p>\n<p>专栏：<a href=\"https://blog.csdn.net/chenchenchencl/category_11932758.html\" title=\"和我一起学java\">和我一起学java</a></p>\n<p>语录：<span style=\"color:#faa572;\">Stay hungry stay foolish</span></p>\n<p><span style=\"color:#faa572;\">工欲善其事必先利其器，给大家介绍一款超牛的斩获大厂offer利器——牛客网</span></p>\n<p><span style=\"color:#faa572;\"><a href=\"https://www.nowcoder.com/link/pc_csdncpt_qdmdlcf_c\" title=\"点击免费注册和我一起刷题吧\">点击免费注册和我一起刷题吧</a>  </span></p>\n</blockquote>\n<p id=\"main-toc\"><strong>文章目录</strong></p>\n<p id=\"%E4%B8%80%E3%80%81%E7%BB%A7%E6%89%BF-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%80%E3%80%81%E7%BB%A7%E6%89%BF\">一、继承</a></p>\n<p id=\"1.%20%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E7%BB%A7%E6%89%BF%EF%BC%9F-toc\" style=\"margin-left:0px;\"><a href=\"#1.%20%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E7%BB%A7%E6%89%BF%EF%BC%9F\">1. 如何理解继承？</a></p>\n<p id=\"2.%20%E7%BB%A7%E6%89%BF%E7%9A%84%E8%AF%AD%E6%B3%95-toc\" style=\"margin-left:0px;\"><a href=\"#2.%20%E7%BB%A7%E6%89%BF%E7%9A%84%E8%AF%AD%E6%B3%95\">2. 继承的语法</a></p>\n<p id=\"3.%20%E5%AD%90%E7%B1%BB%E5%A6%82%E4%BD%95%E8%AE%BF%E9%97%AE%E7%88%B6%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%88%90%E5%91%98-toc\" style=\"margin-left:0px;\"><a href=\"#3.%20%E5%AD%90%E7%B1%BB%E5%A6%82%E4%BD%95%E8%AE%BF%E9%97%AE%E7%88%B6%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%88%90%E5%91%98\">3. 子类如何访问父类中的成员</a></p>\n<p id=\"3.1%20%E8%AE%BF%E9%97%AE%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-toc\" style=\"margin-left:40px;\"><a href=\"#3.1%20%E8%AE%BF%E9%97%AE%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F\">3.1 访问成员变量</a></p>\n<p id=\"3.2%20%E8%AE%BF%E9%97%AE%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95-toc\" style=\"margin-left:40px;\"><a href=\"#3.2%20%E8%AE%BF%E9%97%AE%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95\">3.2 访问成员方法</a></p>\n<p id=\"3.3%C2%A0super%E5%85%B3%E9%94%AE%E5%AD%97-toc\" style=\"margin-left:40px;\"><a href=\"#3.3%C2%A0super%E5%85%B3%E9%94%AE%E5%AD%97\">3.3 super关键字</a></p>\n<p id=\"4.%20%E5%AD%90%E7%B1%BB%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-toc\" style=\"margin-left:0px;\"><a href=\"#4.%20%E5%AD%90%E7%B1%BB%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95\">4. 子类构造方法</a></p>\n<p id=\"5.%20final%20%E5%85%B3%E9%94%AE%E5%AD%97-toc\" style=\"margin-left:0px;\"><a href=\"#5.%20final%20%E5%85%B3%E9%94%AE%E5%AD%97\">5. final 关键字</a></p>\n<p id=\"6.%20%E7%BB%A7%E6%89%BF%E4%B8%8E%E7%BB%84%E5%90%88-toc\" style=\"margin-left:0px;\"><a href=\"#6.%20%E7%BB%A7%E6%89%BF%E4%B8%8E%E7%BB%84%E5%90%88\">6. 继承与组合</a></p>\n<p id=\"%E4%BA%8C%E3%80%81%E5%A4%9A%E6%80%81-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BA%8C%E3%80%81%E5%A4%9A%E6%80%81\">二、多态</a></p>\n<p id=\"1.%E8%AE%A4%E8%AF%86%E5%A4%9A%E6%80%81-toc\" style=\"margin-left:0px;\"><a href=\"#1.%E8%AE%A4%E8%AF%86%E5%A4%9A%E6%80%81\">1.认识多态</a></p>\n<p id=\"%C2%A02.%20%E5%A4%9A%E6%80%81%E5%AE%9E%E7%8E%B0%E6%9D%A1%E4%BB%B6-toc\" style=\"margin-left:0px;\"><a href=\"#%C2%A02.%20%E5%A4%9A%E6%80%81%E5%AE%9E%E7%8E%B0%E6%9D%A1%E4%BB%B6\"> 2. 多态实现条件</a></p>\n<p id=\"3.%20%E9%87%8D%E5%86%99-toc\" style=\"margin-left:0px;\"><a href=\"#3.%20%E9%87%8D%E5%86%99\">3. 重写</a></p>\n<p id=\"4.%C2%A0%E5%90%91%E4%B8%8A%E8%BD%AC%E7%A7%BB%E5%92%8C%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B-toc\" style=\"margin-left:0px;\"><a href=\"#4.%C2%A0%E5%90%91%E4%B8%8A%E8%BD%AC%E7%A7%BB%E5%92%8C%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B\">4. 向上转移和向下转型</a></p>\n<p id=\"%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B%EF%BC%9A%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%B0%86%E5%85%B6%E5%BD%93%E6%88%90%E7%88%B6%E7%B1%BB%E5%AF%B9%E8%B1%A1%E6%9D%A5%E4%BD%BF%E7%94%A8-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B%EF%BC%9A%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%B0%86%E5%85%B6%E5%BD%93%E6%88%90%E7%88%B6%E7%B1%BB%E5%AF%B9%E8%B1%A1%E6%9D%A5%E4%BD%BF%E7%94%A8\">向上转型：创建一个子类对象，将其当成父类对象来使用</a></p>\n<p id=\"%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B%EF%BC%9A%E7%88%B6%E7%B1%BB%E5%BC%95%E7%94%A8%E5%86%8D%E8%BF%98%E5%8E%9F%E4%B8%BA%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1-toc\" style=\"margin-left:40px;\"><a href=\"#%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B%EF%BC%9A%E7%88%B6%E7%B1%BB%E5%BC%95%E7%94%A8%E5%86%8D%E8%BF%98%E5%8E%9F%E4%B8%BA%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1\">向下转型：父类引用再还原为子类对象</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h1 id=\"%E4%B8%80%E3%80%81%E7%BB%A7%E6%89%BF\">一、继承</h1>\n<h1 id=\"1.%20%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E7%BB%A7%E6%89%BF%EF%BC%9F\">1. 如何理解继承？</h1>\n<blockquote>\n<p>类实例化产生的对象之间可能存在某些关联，继承就是提取这些共性从而达到代码复用</p>\n<p></p>\n<p>概念：在保持原有类特性的基础上进行扩展，增加新功能，产生新的类的过程，这个类称派生类</p>\n<p>继承主要解决的问题是：共性的抽取，实现代码复用</p>\n</blockquote>\n<h1 id=\"2.%20%E7%BB%A7%E6%89%BF%E7%9A%84%E8%AF%AD%E6%B3%95\">2. 继承的语法</h1>\n<p>关键字：<strong>extends</strong></p>\n<p>格式：</p>\n<pre><code>修饰符 class 子类 extends 父类 {\n\n    //... \n\n}</code></pre>\n<p>子类会继承父类的成员变量或者成员方法</p>\n<p>子类继承父类后要添加自己特有的成员，即除了父类之外的特性</p>\n<pre><code>class Animal{\n    public String name;\n    public int age;\n\n    public void eat() {\n        System.out.println(name+\"吃饭\");\n    }\n}\nclass Dog extends Animal{\n    //新加的属性\n    public String silly;\n    public void houseGuard() {\n        System.out.println(\"看门\");\n    }\n}\nclass Cat extends Animal {\n\n    //没有添加新属性\n    public void catchMouse()  {\n        System.out.println(name+\"抓老鼠\");\n    }\n}\npublic class Test {\n    public static void main(String[] args) {\n\n        //name和age属性是从父类Animal中继承下来的\n\n        Dog dog = new Dog();\n        Cat cat = new Cat();\n\n    }\n}</code></pre>\n<p>还要注意：Java中不支持多继承，一个子类只能继承一个父类</p>\n<h1 id=\"3.%20%E5%AD%90%E7%B1%BB%E5%A6%82%E4%BD%95%E8%AE%BF%E9%97%AE%E7%88%B6%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%88%90%E5%91%98\">3. 子类如何访问父类中的成员</h1>\n<h2 id=\"3.1%20%E8%AE%BF%E9%97%AE%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F\">3.1 访问成员变量</h2>\n<p>成员变量访问遵循就近原则，自己有优先自己的，如果没有则向父类中找</p>\n<p>如果找不到，则在父类继承下来的成员变量中寻找要访问的成员变量，找不到编译失败</p>\n<h2 id=\"3.2%20%E8%AE%BF%E9%97%AE%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95\">3.2 访问成员方法</h2>\n<p>成员方法名字不同：</p>\n<p>优先访问自己的，若没有，去访问从父类继承的</p>\n<p>成员方法名字相同：</p>\n<p>父类和子类同名方法的参数列表不同(重载)，根据调用方法适传递的参数选择合适的方法访问，没有则报错</p>\n<h2 id=\"3.3%C2%A0super%E5%85%B3%E9%94%AE%E5%AD%97\">3.3 super关键字</h2>\n<p>用法：在子类方法中访问父类的成员</p>\n<pre><code>class Dog extends Animal{\n    \n    public String silly;\n    public void houseGuard() {\n\n        System.out.println(super.name+\"看门\");\n\n    }\n}</code></pre>\n<p> 父类的name没有赋初值，因此是null ，这样就访问到了同名的父类的成员变量</p>\n<p><img alt=\"\" height=\"156\" src=\"..\\..\\static\\image\\54ab5cb456444a52816005ecffd9432d.png\" width=\"724\"/></p>\n<p> this.会有优先问自己的，没有则访问从父类中继承的</p>\n<p>super.直接访问从父类中继承下来的，在子类方法中，如果想要明确访问父类中成员时，借助super关键字即可</p>\n<blockquote>\n<p>总结：</p>\n<p>super.data;访问父类的普通成员变量</p>\n<p>super.func();访问父类的普通成员方法</p>\n<p>super();访问父类的构造方法</p>\n</blockquote>\n<p>注意：上文父类的普通成员方法、变量是指非静态成员方法、变量</p>\n<h1 id=\"4.%20%E5%AD%90%E7%B1%BB%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95\">4. 子类构造方法</h1>\n<p>子类对象构造时，需要先调用基类构造方法，然后执行子类的构造方法</p>\n<p>看代码：</p>\n<pre><code>class Animal{\n    public String name;\n    public int age;\n\n    //提供一个两个该参数的构造方法\n    public Animal(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public void eat() {\n        System.out.println(name+\"吃饭\");\n    }\n}\n\n    //此处报错\nclass Dog extends Animal{\n    \n    public String silly;\n    public void houseGuard() {\n        System.out.println(super.name+\"看门\");\n    }\n}</code></pre>\n<p><img alt=\"\" height=\"177\" src=\"..\\..\\static\\image\\d9bc7ecf12be4adeb58e006527abbed9.png\" width=\"754\"/></p>\n<p>对象的初始化需要调用构造方法</p>\n<p>添加了带有两个参数的构造器后，编译器不会提供无参的构造方法，因此出现错误</p>\n<p>接下来我们看当提供了两个参数的构造方法时如何初始化：</p>\n<pre><code>class Dog extends Animal{\n    \n    public String silly;\n        public Dog(String name, int age, String silly) {\n\n        //先初始化父类部分\n            super(name, age);\n            this.silly = silly;\n\n        }\n\n        public void houseGuard() {\n        System.out.println(super.name+\"看门\");\n    }\n}</code></pre>\n<p>super(name,age)会先调用父类的构造方法完成初始化</p>\n<p>this.silly = silly会完成自己属性的初始化</p>\n<blockquote>\n<p>总结：</p>\n<p>1. 父类显式定义无参或者默认的构造方法，子类构造方法第一行会默认有隐含的super()调用</p>\n<p>2. 父类构造方法是带有参数的，此时需要用户为子类显式定义构造方法，并在子类构造方法中选择合适的父类构造方法调用，否则编译失败</p>\n<p>3. 在子类构造方法中，super(...)调用父类构造时，必须是子类构造函数中第一条语句</p>\n<p>4. super(...)只能在子类构造方法中出现一次，并且不能和this同时出现</p>\n</blockquote>\n<h1 id=\"5.%20final%20%E5%85%B3%E9%94%AE%E5%AD%97\">5. final 关键字</h1>\n<p>1. 修饰变量或字段，表示常量</p>\n<p>2. 修饰类：表示此类不能被继承</p>\n<p>String 字符串类, 就是用 final 修饰的, 不能被继承</p>\n<p>3. 修饰方法：表示该方法不能被重写</p>\n<h1 id=\"6.%20%E7%BB%A7%E6%89%BF%E4%B8%8E%E7%BB%84%E5%90%88\">6. 继承与组合</h1>\n<p>与继承相似，组合也是表示类之间关系的方式，能实现代码的复用</p>\n<p>继承表示各种类抽象出来的共性，对象之间是is-a的关系</p>\n<p>组合(Composition)体现的是整体与部分、拥有的关系，即<a href=\"https://en.wikipedia.org/wiki/Has-a\" title=\"has-a\">has-a</a>的关系</p>\n<p>例如交通工具车的组合：</p>\n<pre><code>class Tire {\n    public void run() {\n        System.out.println(\"轮胎转动\");\n    }\n}\n\nclass Light {\n    public void light() {\n        System.out.println(\"灯亮\");\n    }\n}\n\npublic class Vehicle {\n    private Tire tire;\n    private Light light;\n\n    public Vehicle(Tire tire,Light light) {\n        this.tire = tire;\n        this.light = light;\n    }\n\n    public void operation() {\n        light.light();\n        tire.run();\n    }\n\n    public static void main(String[] args) {\n        Tire tire = new Tire();\n        Light light = new Light();\n        Vehicle vehicle = new Vehicle(tire,light);\n        //灯亮\n        //轮胎转动\n        vehicle.operation();\n    }\n}</code></pre>\n<h1 id=\"%E4%BA%8C%E3%80%81%E5%A4%9A%E6%80%81\">二、多态</h1>\n<h1 id=\"1.%E8%AE%A4%E8%AF%86%E5%A4%9A%E6%80%81\">1.认识多态</h1>\n<p>不同的对象在完成某个行为时会产生出不同的状态就叫多态</p>\n<p>例如：手机支付时产生的多态</p>\n<p class=\"img-center\"><img alt=\"\" height=\"440\" src=\"..\\..\\static\\image\\df79004e874244bfab3a311a698b4a7f.png\" width=\"953\"/></p>\n<h1 id=\"%C2%A02.%20%E5%A4%9A%E6%80%81%E5%AE%9E%E7%8E%B0%E6%9D%A1%E4%BB%B6\"> 2. 多态实现条件</h1>\n<blockquote>\n<p>1. 必须在继承体系下</p>\n<p>2. 子类必须要对父类中方法进行重写</p>\n<p>3. 通过父类的引用调用重写的方法</p>\n</blockquote>\n<p>多态体现在：当代码运行时，传递不同类的对象时，会调用对应类中的方法</p>\n<p>例如：</p>\n<pre><code>class Animal{\n    public String name;\n    public int age;\n\n    public Animal(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public void eat() {\n        System.out.println(name+\"吃饭\");\n    }\n}\n\nclass Dog extends Animal{\n    \n    public String silly;\n\n        public Dog(String name, int age, String silly) {\n            super(name, age);\n            this.silly = silly;\n        }\n        @Override\n        public void eat() {\n            System.out.println(name+\"吃狗粮\");\n        }\n\n        public void houseGuard() {\n        System.out.println(super.name+\"看门\");\n    }\n}\nclass Cat extends Animal {\n\n    public Cat(String name, int age) {\n        super(name, age);\n    }\n\n    @Override\n    public void eat() {\n        System.out.println(name+\"吃猫粮\");\n    }\n    //没有添加新属性\n    public void catchMouse()  {\n        System.out.println(name+\"抓老鼠\");\n    }\n}\npublic class Test {\n    public static void eat(Animal animal) {\n\n        animal.eat;\n\n}\n    public static void main(String[] args) {\n        Dog dog = new Dog(\"dog\",2,\"silly\");\n        Cat cat = new Cat(\"cat\",3);\n        eat(dog);\n        eat(cat);\n\n    }\n}\n</code></pre>\n<p><img alt=\"\" height=\"173\" src=\"..\\..\\static\\image\\181b5f611c6f4025bbdd941647b38769.png\" width=\"805\"/></p>\n<p> Test类中的eat方法参数为Animal，该方法内部并不知道，也不关注当前的a引用指向哪个实例，此时 a这个引用调用 eat方法可能会有多种不同的表现(和 a 引用的实例相关), 这种行为就称为多态</p>\n<h1 id=\"3.%20%E9%87%8D%E5%86%99\">3. 重写</h1>\n<p>概念：返回值和形参都不能改变，子类对父类非静态、非private修饰，非final修饰，非构造方法等的实现过程进行重新编写</p>\n<p>重写的好处在于子类可以根据需要，定义特定于自己的行为。也就是说子类能够根据需要实现父类的方法</p>\n<blockquote>\n<p>【方法重写的规则】</p>\n<p>子类与父类方法原型一致：返回值类型 方法名 (参数列表) 要完全一致</p>\n<p>被重写的方法返回值类型可以不同，但是必须是具有父子关系的</p>\n<p>访问权限不能比父类中被重写的方法的访问权限更低，父类方法被public修饰，则子类中重写该方法就不能声明为 protected</p>\n<p>父类被static、private修饰的方法、构造方法都不能被重写</p>\n<p>@Override注解能帮我们进行一些合法性校验，重写没有构成时报错</p>\n</blockquote>\n<h1 id=\"4.%C2%A0%E5%90%91%E4%B8%8A%E8%BD%AC%E7%A7%BB%E5%92%8C%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B\">4. 向上转移和向下转型</h1>\n<h2 id=\"%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B%EF%BC%9A%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%B0%86%E5%85%B6%E5%BD%93%E6%88%90%E7%88%B6%E7%B1%BB%E5%AF%B9%E8%B1%A1%E6%9D%A5%E4%BD%BF%E7%94%A8\">向上转型：创建一个子类对象，将其当成父类对象来使用</h2>\n<pre><code>//语法格式：父类类型对象名 = new 子类类型()\n\n    Animal animal = new Cat(\"cat\",2);\n\n</code></pre>\n<p> 使用：</p>\n<p>方法一：直接赋值（子类对象赋值给父类对象）</p>\n<pre><code>public class Test {\n    public static void main(String[] args) {\n        Dog dog = new Dog(\"dog\",2,\"silly\");\n        Animal animal = dog;\n        Animal animal1 = dog;\n        Animal animal2 = dog;\n    }\n}</code></pre>\n<p>方法二：方法传参（形参为父类型引用，可以接收任意子类的对象）</p>\n<pre><code>    public static void eat(Animal animal) {\n\n        animal.eat;\n\n    }</code></pre>\n<p>方法三：方法返回（作返回值：返回任意子类对象）</p>\n<pre><code> public static Animal func(){\n        return new Cat(\"dog\",2);\n    }</code></pre>\n<blockquote>\n<p>优点：让代码实现更简单灵活</p>\n<p>缺陷：不能调用到子类特有的方法</p>\n</blockquote>\n<h2 id=\"%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B%EF%BC%9A%E7%88%B6%E7%B1%BB%E5%BC%95%E7%94%A8%E5%86%8D%E8%BF%98%E5%8E%9F%E4%B8%BA%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1\">向下转型：父类引用再还原为子类对象</h2>\n<pre><code>public class Test {\n    public static void main(String[] args) {\n\n        Animal animal = new Cat(\"haha\",2);\n\n        if(animal instanceof Cat){\n            Cat cat = (Cat) animal;\n            cat.catchMouse();\n        }\n    }\n}</code></pre>\n<p>为了提高向下转型的安全性，引入了instanceof，如果该表达式为true，则可以安全转换</p>\n<blockquote>\n<p><strong>“ 本期的分享就到这里了， 记得给博主一个三连哈，你的支持是我创作的最大动力！</strong></p>\n</blockquote>\n<p><img alt=\"ced485cbb11e458d81a746890b32cf3f.gif\" src=\"https://img-blog.csdnimg.cn/ced485cbb11e458d81a746890b32cf3f.gif\"/></p>\n<p></p>\n</div>\n</div>", "first_tag": "Java", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2022-08-09 08:53:52", "summary": "作者：敲代码流川枫博客主页：流川枫的博客流川枫的博客专栏：和我一起学和我一起学语录：工欲善其事必先利其器，给大家介绍一款超牛的斩获大厂利器牛客网点击免费注册和我一起刷题吧点击免费注册和我一起刷题吧文章"}