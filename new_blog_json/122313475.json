{"blogid": "122313475", "writerAge": "码龄2年", "writerBlogNum": "16", "writerCollect": "60", "writerComment": "3", "writerFan": "8", "writerGrade": "2级", "writerIntegral": "192", "writerName": "蓝图_BP", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_122313475.jpg", "writerRankTotal": "202199", "writerRankWeekly": "693307", "writerThumb": "25", "writerVisitNum": "10532", "blog_read_count": "5139", "blog_time": "于 2022-01-04 23:32:39 发布", "blog_title": "循环队列详解", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>概述</p>\n<p>1.先进先出的线性序列，称为队列，队列也是一种线性表，只不过它是操作受限的线性表，只能在两端操作。一端进，一端出。进的一端称为队尾，出的一端称为队头，队列可以用顺序存储也可以用链式存储。</p>\n<p>2.队列的顺序存储形式，可以用一段连续的空间存储数据元素，用两个整型变量记录队头和队尾元素的下标。</p>\n<p></p>\n<p></p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"..\\..\\static\\image\\f504a17c7b004793b25e5fb24961dc84.png\"/></p>\n<p style=\"text-align:center;\"></p>\n<p>3初始化</p>\n<p>(1)</p>\n<p>base为数组的基地址,front,base分别代表指向队头和队尾的\"指针\"(数组下标),构造空队列只需要申请一块内存给基地址,并且将队头指针与队尾指针赋值为0.</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"..\\..\\static\\image\\3988571ebf0e4b91b8c5e59e10cb2c0f.png\"/></p>\n<p> </p>\n<p>(2)</p>\n<p>因为该队列为循环队列所以</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"..\\..\\static\\image\\d02e4020ce14472abae5934fcaf595b4.png\"/></p>\n<p> </p>\n<p></p>\n<pre><code>typedef struct SqQueue\n{\n\tint* base;\n\tint front, rear;\n}SqQueue;\n\n//构造空队列\nbool InitQueue(SqQueue&amp; Q)\n{\n\tQ.base = new int[Maxsize];\n\tif (Q.base == NULL)\n\t{\n\t\treturn false;\n\t}\n\tQ.front = Q.rear = 0;\n\treturn true;\n}</code></pre>\n<p></p>\n<p> 4入队</p>\n<p> (1)将队尾指向的位置赋值,并且赋值后将队尾的位置后移</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"..\\..\\static\\image\\3a5213d8eb974646bdc5227c0735789c.png\"/></p>\n<p> </p>\n<p> (2)在入队时难免会出现以下情况</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"..\\..\\static\\image\\86999327ddc64c57b6c16608c6a62854.png\"/></p>\n<p> 队列的空间未利用完,但是却造成了元素的溢出(又称\"假溢出\"),所以要利用循环队列,这样就不会有这样的顾虑</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"..\\..\\static\\image\\8387a72a5db8426094c5f284e928d942.png\"/></p>\n<p> 入队的操作为</p>\n<p>Q.base[Q.rear]=e;  将元素e放入Q.rear指向的空间</p>\n<p>Q.rear=(Q.rear+1)%Maxsize rear指针向后移动一个单位</p>\n<p>至于为什么要加对(Q.rear+1)取模,这是因为rear指针会一直增加到比队列容量大的数字,对其取模就是为了使其缩小,指向真正的位置例如 容量大小为5 队尾指向9 取模队尾指向的是4,说明队尾指正已经走过了一个圈</p>\n<p>tips:在入队前要判断队列是否为空怎们办</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"..\\..\\static\\image\\6ba4f6efd8fb4781bfc9709ca12e98b3.png\"/></p>\n<p>如图此时队尾指向的是循环队列的最后一个空间,这个空间并没有存放任何数据,判断队列是否为满只要将队尾指针+1看看其是否与队头相等,此处为什么要取模?</p>\n<p>例如队列空间大小为10,队尾指向第10个空间,下标为9,对其加1等于10,取模等于0,此时队头也是指向0的所以需要取模</p>\n<p>有例如如果一开始队头指向的是1,队尾指向的是0,那么队尾加1,取模后为1,那么此时对也满</p>\n<p> </p>\n<pre><code>//入队\nbool Push(SqQueue&amp; Q, int e)\n{\n\tif ((Q.rear + 1) % Maxsize == Q.front)\n\t{\n\t\tcout &lt;&lt; \"队满\" &lt;&lt; endl;\n\t\treturn false;\n\t}\n\n\tQ.base[Q.rear] = e;\n\tQ.rear = (Q.rear + 1) % Maxsize;\n\treturn true;\n}</code></pre>\n<p>5出队</p>\n<p>出队前判断队列是否为空</p>\n<p>当尾指针与头指针指向一起时队空,注意与队满的区别</p>\n<p>出队的操作</p>\n<p>e=Q.base[Q.front];</p>\n<p>Q.front=[Q.front+1]%Maxsize;</p>\n<p>将头指针向着元素增长方向移动一个单元,原来的头指针指向的元素并没有真正的删除,只是逻辑上的删除,后序如果要用到这个空间,会用新的元素将其覆盖掉</p>\n<p>至于为什么要用取模和上述的入队是一致的</p>\n<p style=\"text-align:center;\"><img alt=\"\" src=\"..\\..\\static\\image\\f3672e365343417ea5b5bfa67377cff9.png\"/></p>\n<p> </p>\n<pre><code>bool Pop(SqQueue&amp; Q, int&amp; e)\n{\n\tif (Q.rear == Q.front)\n\t{\n\t\tcout &lt;&lt; \"队空\" &lt;&lt; endl;\n\t\treturn false;\n\t}\n\te = Q.base[Q.front];\n\tQ.front = (Q.front + 1) % Maxsize;\n}</code></pre>\n<p></p>\n<p>6.获取队头元素</p>\n<p>判断队列是否为空</p>\n<p>简单的数组取元素而已</p>\n<pre><code>int Get_front(SqQueue Q)\n{\n\tif (Q.rear == Q.front)\n\t{\n\t\tcout &lt;&lt; \"队空\" &lt;&lt; endl;\n\t\treturn -1;\n\t}\n\n\treturn Q.base[Q.front];\n}\n</code></pre>\n<p>7.获取队尾元素</p>\n<p>判断队列是否为空</p>\n<p>因为队尾一直指向最后一个元素的后一个位置,所以要去指正前面的空间,就是队尾元素</p>\n<pre><code>int Get_back(SqQueue Q)\n{\n\tif (Q.front == Q.rear)\n\t{\n\t\tcout &lt;&lt; \"队空\" &lt;&lt; endl;\n\t\treturn -1;\n\t}\n\n\treturn Q.base[Q.rear - 1];\n}</code></pre>\n<p>8.获取队列元素个数</p>\n<p>这两段的代码意思是一样的</p>\n<p>因为队尾减队头可能会出现负数,所以需要加上容量大小后取模,这样才会得到真实的容量大小</p>\n<p></p>\n<p>例如队列大小6,队尾指向1,队头指向2,那么元素个数为(1-2+6)%6=5个</p>\n<p>例如队列大小6,队尾指向5,队头指向0,那么元素个数为(5-0+6)%6=5个</p>\n<pre><code>int length(SqQueue Q)\n{\n\treturn (Q.rear - Q.front + MaxSize) % MaxSize;\n\n\t/*if (Q.rear - Q.front &gt;= 0)\n\t{\n\t\treturn Q.rear - Q.front;\n\t}\n\telse\n\t{\n\t\treturn (Q.rear - Q.front + MaxSize);\n\t}*/\n}</code></pre>\n<p>完整代码如下</p>\n<pre><code>#define _CRT_SECURE_NO_WARNINGS\n#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\n\nconst int MaxSize = 100;\n\ntypedef struct SqQueue\n{\n\tint* base;\n\tint front, rear;\n}SqQueue;\n\nbool InitQueue(SqQueue&amp; Q)\n{\n\tQ.base = new int[MaxSize];\n\tif (Q.base == NULL)\n\t{\n\t\treturn false;\n\t}\n\tQ.front = Q.rear = 0;\n\treturn true;\n}\n\nbool Push(SqQueue&amp; Q, int e)\n{\n\tif ((Q.rear + 1) % MaxSize == Q.front)\n\t{\n\t\treturn false;\n\t}\n\n\tQ.base[Q.rear] = e;\n\tQ.rear = (Q.rear + 1) % MaxSize;\n\treturn true;\n\n}\n\nbool Pop(SqQueue&amp; Q, int&amp; e)\n{\n\tif (Q.rear == Q.front)\n\t{\n\t\treturn false;\n\t}\n\te = Q.base[Q.front];\n\tQ.front = (Q.front + 1) % MaxSize;\n}\n\nint Get_front(SqQueue Q)\n{\n\tif (Q.front == Q.rear)\n\t{\n\t\treturn -1;\n\t}\n\n\treturn Q.base[Q.front];\n}\n\nint Get_back(SqQueue Q)\n{\n\tif (Q.front == Q.rear)\n\t{\n\t\treturn -1;\n\t}\n\n\treturn Q.base[Q.rear - 1];\n}\n\nint length(SqQueue Q)\n{\n\treturn (Q.rear - Q.front + MaxSize) % MaxSize;\n\n\t/*if (Q.rear - Q.front &gt;= 0)\n\t{\n\t\treturn Q.rear - Q.front;\n\t}\n\telse\n\t{\n\t\treturn (Q.rear - Q.front + MaxSize);\n\t}*/\n}\n\nint main()\n{\n\n\tSqQueue S;\n\tInitQueue(S);\n\n\tint n = 0;\n\tcout &lt;&lt; \"请输入有多少元素\" &lt;&lt; endl;\n\tcin &gt;&gt; n;\n\tcout &lt;&lt; \"依次输入元素\" &lt;&lt; endl;\n\twhile (n--)\n\t{\n\t\tint e;\n\t\tcin &gt;&gt; e;\n\t\tPush(S, e);\n\t}\n\tint L = length(S);\n\tfor (int i = 0; i &lt; L; i++)\n\t{\n\t\tcout &lt;&lt; \"队尾:\"&lt;&lt;Get_back(S) &lt;&lt; \" \"&lt;&lt;\"队头:\"&lt;&lt;Get_front(S)&lt;&lt;\"---\";\n\n\t\tint e = 0;\n\t\tPop(S, e);\n\t\tcout &lt;&lt; e &lt;&lt;\" \";\n\t\tcout &lt;&lt; endl;\n\t}\n\t//cout &lt;&lt; length(S);\n\tcout &lt;&lt; endl;\n\n\n\n\n\tsystem(\"pause\");\n\treturn EXIT_SUCCESS;\n}</code></pre>\n<p></p>\n</div>\n</div>", "first_tag": "Others", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-01-04 23:32:39", "summary": "概述先进先出的线性序列，称为队列，队列也是一种线性表，只不过它是操作受限的线性表，只能在两端操作。一端进，一端出。进的一端称为队尾，出的一端称为队头，队列可以用顺序存储也可以用链式存储。队列的顺序存储"}