{"blogid": "120506175", "writerAge": "码龄2年", "writerBlogNum": "46", "writerCollect": "13353", "writerComment": "904", "writerFan": "6582", "writerGrade": "5级", "writerIntegral": "4121", "writerName": "一个数学不怎么好的程序员", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_120506175.jpg", "writerRankTotal": "125957", "writerRankWeekly": "9840", "writerThumb": "2475", "writerVisitNum": "183403", "blog_read_count": "4994", "blog_time": "于 2021-09-27 21:04:56 发布", "blog_title": "C++类和对象（万字总结）（建议收藏！！！）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atom-one-light\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p></p>\n<div class=\"toc\">\n<h3>文章目录</h3>\n<ul><li><a href=\"#_1\">面向过程和面向对象初步认识</a></li><li><a href=\"#_6\">类的引入</a></li><li><a href=\"#_33\">类的定义</a></li><li><ul><li><a href=\"#_46\">类的两种定义方法</a></li><li><ul><li><a href=\"#1_47\">1.声明和定义全部放在类体中</a></li><li><a href=\"#2_hcpp_71\">2. 声明放在.h文件中，类的定义放在.cpp文件中</a></li></ul>\n</li></ul>\n</li><li><a href=\"#_97\">类的访问限定符及封装</a></li><li><ul><li><a href=\"#_99\">访问限定符</a></li><li><a href=\"#_110\">封装</a></li></ul>\n</li><li><a href=\"#_115\">类的作用域</a></li><li><a href=\"#_135\">类的实例化</a></li><li><a href=\"#_165\">类对象模型</a></li><li><ul><li><a href=\"#_166\">如何计算类对象的大小</a></li><li><a href=\"#_183\">类对象的存储方式</a></li></ul>\n</li><li><a href=\"#this__195\">this 指针</a></li><li><ul><li><a href=\"#this_196\">this指针的引出</a></li><li><a href=\"#this_241\">this指针的特性</a></li></ul>\n</li><li><a href=\"#6_256\">类的6个默认成员函数</a></li><li><ul><li><a href=\"#_266\">构造函数</a></li><li><ul><li><a href=\"#_293\">构造函数的特性</a></li></ul>\n</li><li><a href=\"#_404\">析构函数</a></li><li><ul><li><a href=\"#_410\">特性</a></li></ul>\n</li><li><a href=\"#_422\">拷贝构造函数</a></li><li><ul><li><a href=\"#_426\">特性</a></li></ul>\n</li><li><a href=\"#_510\">运算符重载</a></li><li><ul><li><a href=\"#_526\">==运算符重载</a></li><li><a href=\"#__537\">= 运算符重载</a></li></ul>\n</li></ul>\n</li><li><a href=\"#const_587\">const修饰成员函数</a></li><li><a href=\"#_602\">再谈构造函数</a></li><li><ul><li><a href=\"#_603\">构造函数体赋值</a></li><li><a href=\"#_647\">初始化列表</a></li><li><ul><li><a href=\"#_668\">注意事项</a></li><li><ul><li><a href=\"#1_670\">1.每个成员变量在初始化列表中只能出现一次(初始化只能初始化一次)</a></li><li><a href=\"#2_672\">2.类中包含以下成员，必须放在初始化列表进行初始化：</a></li><li><a href=\"#3_726\">3.尽量使用初始化列表初始化</a></li><li><a href=\"#4_798\">4.成员变量在类中声明的次序就是其在初始化列表中的初始化顺序，与其在初始化列表中的先后顺序无关</a></li></ul>\n</li></ul>\n</li></ul>\n</li><li><a href=\"#explicit_831\">explicit关键字</a></li><li><a href=\"#static_881\">static成员</a></li><li><ul><li><a href=\"#_884\">特性</a></li><li><ul><li><a href=\"#1%E2%80%83staticstaticstatic_885\">1. 声明为static的类成员称为类的静态成员。用static修饰的成员变量，称之为静态成员变量；用static修饰的成员函数，称之为静态成员函数。静态成员变量一定要在类外进行初始化。</a></li><li><a href=\"#2static_904\">2.静态成员变量必须在类外定义，定义时不添加static关键字</a></li><li><a href=\"#3this_918\">3.静态成员函数没有隐藏的this指针，不能访问任何非静态成员</a></li><li><a href=\"#4_938\">4.访问静态成员变量的方法</a></li><li><ul><li><a href=\"#_940\">一.当静态成员变量为公有时，有以下几种访问方式：</a></li><li><a href=\"#_962\">二.当静态成员变量为私有时，有以下几种访问方式：</a></li></ul>\n</li><li><a href=\"#5publicprivateprotected_990\">5.静态成员和类的普通成员一样，也有public、private和protected这三种访问级别</a></li></ul>\n</li></ul>\n</li><li><a href=\"#C11_999\">C++11中成员初始化的新玩法</a></li><li><a href=\"#_1022\">友元</a></li><li><ul><li><a href=\"#_1027\">友元函数</a></li><li><a href=\"#_1077\">友元类</a></li></ul>\n</li><li><a href=\"#_1111\">内部类</a></li><li><a href=\"#_1158\">再次理解封装</a></li><li><a href=\"#_1164\">再次理解面向对象</a></li></ul>\n</div>\n<p></p>\n<h1><a id=\"_1\"></a>面向过程和面向对象初步认识</h1>\n<blockquote>\n<p>C语言是面向过程的，关注的是过程，分析出求解问题的步骤，通过函数调用逐步解决问题。<br/> C++是基于面向对象的，关注的是对象，将一件事情拆分成不同的对象，靠对象之间的交互完成。</p>\n</blockquote>\n<hr/>\n<h1><a id=\"_6\"></a>类的引入</h1>\n<p>C语言中，结构体中只能定义变量，在C++中，结构体内不仅可以定义变量，也可以定义函数。</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">struct</span> <span class=\"token class-name\">Student</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token keyword\">void</span> <span class=\"token function\">SetStudentInfo</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span><span class=\"token operator\">*</span> name<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span><span class=\"token operator\">*</span> gender<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> age<span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\t<span class=\"token function\">strcpy</span><span class=\"token punctuation\">(</span>_name<span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token function\">strcpy</span><span class=\"token punctuation\">(</span>_gender<span class=\"token punctuation\">,</span> gender<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t_age <span class=\"token operator\">=</span> age<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\n\t<span class=\"token keyword\">void</span> <span class=\"token function\">PrintStudentInfo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\tcout <span class=\"token operator\">&lt;&lt;</span> _name <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" \"</span> <span class=\"token operator\">&lt;&lt;</span> _gender <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" \"</span> <span class=\"token operator\">&lt;&lt;</span> _age <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\n\t<span class=\"token keyword\">char</span> _name<span class=\"token punctuation\">[</span><span class=\"token number\">20</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">char</span> _gender<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> _age<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>上面结构体的定义，在C++中更喜欢用class来代替</p>\n<hr/>\n<h1><a id=\"_33\"></a>类的定义</h1>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">className</span>\n<span class=\"token punctuation\">{<!-- --></span>\n <span class=\"token comment\">// 类体：由成员函数和成员变量组成</span>\n \n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 一定要注意后面的分号</span>\n</code></pre>\n<blockquote>\n<p><strong>class</strong>为定义类的<strong>关键字</strong>，<strong>ClassName</strong>为类的名字，<strong>{}中为类的主体</strong>，<strong>注意</strong>类定义结束时后面<strong>分号</strong>。<br/> 类中的元素称为<strong>类的成员</strong>：类中的<strong>数据</strong>称为<strong>类的属性</strong>或者<strong>成员变量</strong>; 类中的<strong>函数</strong>称为<strong>类的方法</strong>或者<strong>成员函数</strong>。</p>\n</blockquote>\n<h2><a id=\"_46\"></a>类的两种定义方法</h2>\n<h3><a id=\"1_47\"></a>1.声明和定义全部放在类体中</h3>\n<p>声明和定义全部放在类体中，需要注意：成员函数如果在类中定义，编译器可能会将其当成内联函数处<br/> 理</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Student</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token keyword\">void</span> <span class=\"token function\">SetStudentInfo</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span><span class=\"token operator\">*</span> name<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span><span class=\"token operator\">*</span> gender<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> age<span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\t<span class=\"token function\">strcpy</span><span class=\"token punctuation\">(</span>_name<span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token function\">strcpy</span><span class=\"token punctuation\">(</span>_gender<span class=\"token punctuation\">,</span> gender<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t_age <span class=\"token operator\">=</span> age<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\n\t<span class=\"token keyword\">void</span> <span class=\"token function\">PrintStudentInfo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\tcout <span class=\"token operator\">&lt;&lt;</span> _name <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" \"</span> <span class=\"token operator\">&lt;&lt;</span> _gender <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\" \"</span> <span class=\"token operator\">&lt;&lt;</span> _age <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\n\t<span class=\"token keyword\">char</span> _name<span class=\"token punctuation\">[</span><span class=\"token number\">20</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">char</span> _gender<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> _age<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h3><a id=\"2_hcpp_71\"></a>2. 声明放在.h文件中，类的定义放在.cpp文件中</h3>\n<pre><code class=\"prism language-cpp\"><span class=\"token comment\">//person.h</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Person</span>\n<span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n   <span class=\"token comment\">//显示信息</span>\n   <span class=\"token keyword\">void</span> <span class=\"token function\">show</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n   <span class=\"token keyword\">char</span><span class=\"token operator\">*</span> _name<span class=\"token punctuation\">;</span>\n   <span class=\"token keyword\">char</span><span class=\"token operator\">*</span> _sex<span class=\"token punctuation\">;</span>\n   <span class=\"token keyword\">int</span> _age<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">//person.cpp</span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span><span class=\"token expression\">\"person<span class=\"token punctuation\">.</span>h<span class=\"token operator\">&gt;</span></span></span>\n\n<span class=\"token keyword\">void</span> <span class=\"token class-name\">Person</span><span class=\"token operator\">::</span><span class=\"token function\">show</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n   cout<span class=\"token operator\">&lt;&lt;</span>_name<span class=\"token operator\">&lt;&lt;</span><span class=\"token string\">\"  \"</span><span class=\"token operator\">&lt;&lt;</span>_sex<span class=\"token operator\">&lt;&lt;</span><span class=\"token string\">\"  \"</span><span class=\"token operator\">&lt;&lt;</span>_age<span class=\"token operator\">&lt;&lt;</span>endl<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>   \n</code></pre>\n<blockquote>\n<p>注意：一般情况下我们采用第二种方式</p>\n</blockquote>\n<hr/>\n<h1><a id=\"_97\"></a>类的访问限定符及封装</h1>\n<h2><a id=\"_99\"></a>访问限定符</h2>\n<blockquote>\n<p>C++实现封装的方式：用类将对象的属性与方法结合在一块，让对象更加完善，通过访问权限选择性的将其<br/> 接口提供给外部的用户使用。</p>\n</blockquote>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\63530a5792aa4379aaab7b92ba7a8f3f.png\"/><br/> 【访问限定符说明】</p>\n<ol><li>public修饰的成员在类外可以直接被访问</li><li>protected和private修饰的成员在类外不能直接被访问(此处protected和private是类似的)</li><li>访问权限作用域从该访问限定符出现的位置开始直到下一个访问限定符出现时为止</li><li>class的默认访问权限为private，struct为public(因为struct要兼容C)</li></ol>\n<h2><a id=\"_110\"></a>封装</h2>\n<p>在类和对象阶段，我们只研究类的封装特性，那什么是封装呢？</p>\n<blockquote>\n<p>封装本质上是一种管理：我们使用类将数据和方法都封装起来。不想对外开放的就用 protected/private 封装起来，用 public 封装的成员允许外界对其进行合理的访问。所以封装本质上是一种管理。</p>\n</blockquote>\n<hr/>\n<h1><a id=\"_115\"></a>类的作用域</h1>\n<p>类定义了一个新的作用域，类的所有成员都在类的作用域中。在类体外定义成员，需要使用 <code>:: 作用域解析符</code>指明成员属于哪个类域。</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Person</span>\n<span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n <span class=\"token keyword\">void</span> <span class=\"token function\">PrintPersonInfo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">private</span><span class=\"token operator\">:</span>\n <span class=\"token keyword\">char</span> _name<span class=\"token punctuation\">[</span><span class=\"token number\">20</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n <span class=\"token keyword\">char</span> _gender<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n <span class=\"token keyword\">int</span> _age<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 这里需要指定PrintPersonInfo是属于Person这个类域</span>\n<span class=\"token keyword\">void</span> <span class=\"token class-name\">Person</span><span class=\"token operator\">::</span><span class=\"token function\">PrintPersonInfo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n cout<span class=\"token operator\">&lt;&lt;</span>_name<span class=\"token operator\">&lt;&lt;</span><span class=\"token string\">\" \"</span>_gender<span class=\"token operator\">&lt;&lt;</span><span class=\"token string\">\" \"</span><span class=\"token operator\">&lt;&lt;</span>_age<span class=\"token operator\">&lt;&lt;</span>endl<span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">}</span>\n</code></pre>\n<hr/>\n<h1><a id=\"_135\"></a>类的实例化</h1>\n<p><strong>用类类型创建对象的过程，称为类的实例化</strong></p>\n<ol><li>类只是一个模型一样的东西，限定了类有哪些成员，定义出一个类<strong>并没有分配实际的内存空间</strong>来存储它</li><li>一个类可以实例化出多个对象，<strong>实例化出的对象 占用实际的物理空间，存储类成员变量</strong></li><li>做个比方。<strong>类实例化出对象就像现实中使用建筑设计图建造出房子，类就像是设计图</strong>，只设计出需要什<br/> 么东西，但是并没有实体的建筑存在，同样类也只是一个设计，实例化出的对象才能实际存储数据，占<br/> 用物理空间</li></ol>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Person</span>\n<span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n <span class=\"token keyword\">void</span> <span class=\"token function\">PrintPersonInfo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">private</span><span class=\"token operator\">:</span>\n <span class=\"token keyword\">char</span> _name<span class=\"token punctuation\">[</span><span class=\"token number\">20</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n <span class=\"token keyword\">char</span> _gender<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n <span class=\"token keyword\">int</span> _age<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n  Person man<span class=\"token punctuation\">;</span>   <span class=\"token comment\">//类的实例化</span>\n  man<span class=\"token punctuation\">.</span>_name<span class=\"token operator\">=</span><span class=\"token string\">\"hehe\"</span><span class=\"token punctuation\">;</span>\n  man<span class=\"token punctuation\">.</span>_age<span class=\"token operator\">=</span><span class=\"token string\">\"66\"</span><span class=\"token punctuation\">;</span>\n  man<span class=\"token punctuation\">.</span>_sex<span class=\"token operator\">=</span><span class=\"token string\">\"男\"</span><span class=\"token punctuation\">;</span>\n  man<span class=\"token punctuation\">.</span><span class=\"token function\">_PrintPersonInfo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<hr/>\n<h1><a id=\"_165\"></a>类对象模型</h1>\n<h2><a id=\"_166\"></a>如何计算类对象的大小</h2>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">A</span> <span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n <span class=\"token keyword\">void</span> <span class=\"token function\">PrintA</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n <span class=\"token punctuation\">{<!-- --></span>\n cout<span class=\"token operator\">&lt;&lt;</span>_a<span class=\"token operator\">&lt;&lt;</span>endl<span class=\"token punctuation\">;</span>\n <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">private</span><span class=\"token operator\">:</span>\n <span class=\"token keyword\">char</span> _a<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>那么问题来了？类中既可以有成员变量，又可以有成员函数，那么一个类的对象中包含了什么？如何计算一个类的大<br/> 小？ 想要知道这个，首先我们要弄明白类在内存中的存储方式。</p>\n<h2><a id=\"_183\"></a>类对象的存储方式</h2>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\fa19c3c3e0324bed901cd76a5381e310.png\"/></p>\n<blockquote>\n<p>那为什么内存要这样存储类了？<br/> 原因：每个对象中成员变量是不同的，但是调用同一份函数，如果按照此种方式存储，当一个类创建多<br/> 个对象时，每个对象中都会保存一份代码，相同代码保存多次，浪费空间。</p>\n</blockquote>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\666f92ca2cda423ba5a06b5f8bacc4a6.png\"/></p>\n<blockquote>\n<p>结论：一个类的大小，实际就是该类中”成员变量”之和，当然也要进行内存对齐，注意空类的大小，空类比<br/> 较特殊，编译器给了空类一个字节来唯一标识这个类。 如果有小伙伴不怎么明白内存对齐：可以看看这篇文章：<a href=\"https://blog.csdn.net/IamGreeHand/article/details/119637097\">自定义类型的知识点</a></p>\n</blockquote>\n<hr/>\n<h1><a id=\"this__195\"></a>this 指针</h1>\n<h2><a id=\"this_196\"></a>this指针的引出</h2>\n<p>我们先来定义一个日期类Date</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Date</span>\n<span class=\"token punctuation\">{<!-- --></span> \n<span class=\"token keyword\">public</span> <span class=\"token operator\">:</span>\n <span class=\"token keyword\">void</span> <span class=\"token function\">Display</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n <span class=\"token punctuation\">{<!-- --></span>\n cout <span class=\"token operator\">&lt;&lt;</span>_year<span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"-\"</span> <span class=\"token operator\">&lt;&lt;</span>_month <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"-\"</span><span class=\"token operator\">&lt;&lt;</span> _day <span class=\"token operator\">&lt;&lt;</span>endl<span class=\"token punctuation\">;</span>\n <span class=\"token punctuation\">}</span>\n \n <span class=\"token keyword\">void</span> <span class=\"token function\">SetDate</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> year <span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> month <span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> day<span class=\"token punctuation\">)</span>\n <span class=\"token punctuation\">{<!-- --></span>\n _year <span class=\"token operator\">=</span> year<span class=\"token punctuation\">;</span>\n _month <span class=\"token operator\">=</span> month<span class=\"token punctuation\">;</span>\n _day <span class=\"token operator\">=</span> day<span class=\"token punctuation\">;</span>\n <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">private</span> <span class=\"token operator\">:</span>\n <span class=\"token keyword\">int</span> _year <span class=\"token punctuation\">;</span> <span class=\"token comment\">// 年</span>\n <span class=\"token keyword\">int</span> _month <span class=\"token punctuation\">;</span> <span class=\"token comment\">// 月</span>\n <span class=\"token keyword\">int</span> _day <span class=\"token punctuation\">;</span> <span class=\"token comment\">// 日</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n Date d1<span class=\"token punctuation\">,</span> d2<span class=\"token punctuation\">;</span>\n d1<span class=\"token punctuation\">.</span><span class=\"token function\">SetDate</span><span class=\"token punctuation\">(</span><span class=\"token number\">2018</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n d2<span class=\"token punctuation\">.</span><span class=\"token function\">SetDate</span><span class=\"token punctuation\">(</span><span class=\"token number\">2018</span><span class=\"token punctuation\">,</span><span class=\"token number\">7</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n d1<span class=\"token punctuation\">.</span><span class=\"token function\">Display</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n d2<span class=\"token punctuation\">.</span><span class=\"token function\">Display</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> \n <span class=\"token punctuation\">}</span>\n</code></pre>\n<blockquote>\n<p>对于上述类，有这样的一个问题：<br/> Date类中有SetDate与Display两个成员函数，函数体中没有关于不同对象的区分，那当d1调用SetDate函数<br/> 时，该函数是如何知道应该设置d1对象，而不是设置d2对象呢？</p>\n</blockquote>\n<blockquote>\n<p>C++中通过引入this指针解决该问题，即：C++编译器给每个“非静态的成员函数“增加了一个隐藏的指针参<br/> 数，让该指针指向当前对象(函数运行时调用该函数的对象)，在函数体中所有成员变量的操作，都是通过该<br/> 指针去访问。只不过所有的操作对用户是透明的，即用户不需要来传递，编译器自动完成</p>\n</blockquote>\n<h2><a id=\"this_241\"></a>this指针的特性</h2>\n<ol><li>this指针的类型：类类型* const</li><li>只能在“成员函数”的内部使用</li><li><strong>this指针本质上其实是一个成员函数的形参</strong>，是对象调用成员函数时，将对象地址作为实参传递给this形参。所以<strong>对象中不存储this指针</strong>。</li><li><strong>this指针是成员函数第一个隐含的指针形参，一般情况由编译器通过ecx寄存器自动传递，不需要用户传递</strong></li></ol>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\f2cc0dd1954a4f288a965ec8d736f047.png\"/></p>\n<blockquote>\n<p><code>注意：this指针不能为空</code>下面来看一个例子</p>\n</blockquote>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\a0d2e1b5329f4cf6b63ac79394e7add2.png\"/><br/> 这里为什么会报错了？首先这个p是一个空指针，但是并不是对象是空指针就一定报错，这里其实更重要的一个原因是PrintA里面为this-&gt;_a你对p进行了访问，而空指针是不能访问的。下面我们再来来p-&gt;Show（）会不会报错？</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\5b99f5b4f1a44a119bc4e67104c43ab3.png\"/></p>\n<hr/>\n<h1><a id=\"6_256\"></a>类的6个默认成员函数</h1>\n<p>如果一个类中什么成员都没有，我们简称其为空类。但是空类中真的什么都没有吗？其实不然，任何一个类，即使我们什么都不写，类中也会自动生成6个默认成员函数。</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Date</span> <span class=\"token punctuation\">{<!-- --></span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//空类</span>\n\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\ece04908a5864d5396aa353d5fef39e0.png\"/></p>\n<h2><a id=\"_266\"></a>构造函数</h2>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Date</span>\n<span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n\t<span class=\"token function\">Date</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> year <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> month <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> day <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token comment\">// 构造函数</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\t_year <span class=\"token operator\">=</span> year<span class=\"token punctuation\">;</span>\n\t\t_month <span class=\"token operator\">=</span> month<span class=\"token punctuation\">;</span>\n\t\t_day <span class=\"token operator\">=</span> day<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token keyword\">void</span> <span class=\"token function\">Print</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\tcout <span class=\"token operator\">&lt;&lt;</span> _year <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"年\"</span> <span class=\"token operator\">&lt;&lt;</span> _month <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"月\"</span> <span class=\"token operator\">&lt;&lt;</span> _day <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"日\"</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">private</span><span class=\"token operator\">:</span>\n\t<span class=\"token keyword\">int</span> _year<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> _month<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> _day<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n</code></pre>\n<p>例如，上述日期类中的成员函数Date就是一个构造函数。当你用该日期类创建一个对象时，编译器会自动调用该构造函数对新创建的变量进行初始化。</p>\n<blockquote>\n<p>注意：构造函数的主要任务并不是开空间创建对象，而是初始化对象。(这儿可以先暂时这么理解）</p>\n</blockquote>\n<h3><a id=\"_293\"></a>构造函数的特性</h3>\n<ol><li>函数名与类名相同。</li><li>无返回值。</li><li>对象实例化时编译器自动调用对应的构造函数。</li><li>构造函数可以重载。</li></ol>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Date</span>\n<span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n     <span class=\"token comment\">// 1.无参构造函数</span>\n     <span class=\"token function\">Date</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n     <span class=\"token punctuation\">{<!-- --></span><span class=\"token punctuation\">}</span>\n\t<span class=\"token function\">Date</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> year <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> month <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> day <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token comment\">// 构造函数</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\t_year <span class=\"token operator\">=</span> year<span class=\"token punctuation\">;</span>\n\t\t_month <span class=\"token operator\">=</span> month<span class=\"token punctuation\">;</span>\n\t\t_day <span class=\"token operator\">=</span> day<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token keyword\">void</span> <span class=\"token function\">Print</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\tcout <span class=\"token operator\">&lt;&lt;</span> _year <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"年\"</span> <span class=\"token operator\">&lt;&lt;</span> _month <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"月\"</span> <span class=\"token operator\">&lt;&lt;</span> _day <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"日\"</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">private</span><span class=\"token operator\">:</span>\n\t<span class=\"token keyword\">int</span> _year<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> _month<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> _day<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">TestDate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n Date d1<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 调用无参构造函数</span>\n Date <span class=\"token function\">d2</span> <span class=\"token punctuation\">(</span><span class=\"token number\">2015</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 调用带参的构造函数</span>\n \n <span class=\"token comment\">// 注意：如果通过无参构造函数创建对象时，对象后面不用跟括号，否则就成了函数声明</span>\n <span class=\"token comment\">// 以下代码的函数：声明了d3函数，该函数无参，返回一个日期类型的对象</span>\n Date <span class=\"token function\">d3</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">}</span>\n</code></pre>\n<ol start=\"5\"><li>如果类中没有显式定义构造函数，则C++编译器会自动生成一个无参的默认构造函数，一旦用户显式定义编译器将不再生成。</li></ol>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Date</span>\n<span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n <span class=\"token comment\">/*\n // 如果用户显式定义了构造函数，编译器将不再生成\n Date (int year, int month, int day)\n {\n _year = year;\n _month = month;\n _day = day;\n }\n */</span>\n<span class=\"token keyword\">private</span><span class=\"token operator\">:</span>\n <span class=\"token keyword\">int</span> _year<span class=\"token punctuation\">;</span>\n <span class=\"token keyword\">int</span> _month<span class=\"token punctuation\">;</span>\n <span class=\"token keyword\">int</span> _day<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">Test</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n  <span class=\"token comment\">// 没有定义构造函数，对象也可以创建成功，因此此处调用的是编译器生成的默认构造函数</span>\n   Date d<span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">}</span>\n</code></pre>\n<ol start=\"6\"><li>无参的构造函数和全缺省的构造函数都称为默认构造函数，并且默认构造函数只能有一个。注意：无参构造函数、全缺省构造函数、我们没写编译器默认生成的构造函数，都可以认为是默认成员函数。</li></ol>\n<pre><code class=\"prism language-cpp\"><span class=\"token comment\">// 默认构造函数</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Date</span>\n<span class=\"token punctuation\">{<!-- --></span> \n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n <span class=\"token function\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n <span class=\"token punctuation\">{<!-- --></span>\n _year <span class=\"token operator\">=</span> <span class=\"token number\">1900</span> <span class=\"token punctuation\">;</span>\n _month <span class=\"token operator\">=</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">;</span>\n _day <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n <span class=\"token punctuation\">}</span>\n \n <span class=\"token function\">Date</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> year <span class=\"token operator\">=</span> <span class=\"token number\">1900</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> month <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> day <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n <span class=\"token punctuation\">{<!-- --></span>\n _year <span class=\"token operator\">=</span> year<span class=\"token punctuation\">;</span>\n _month <span class=\"token operator\">=</span> month<span class=\"token punctuation\">;</span>\n _day <span class=\"token operator\">=</span> day<span class=\"token punctuation\">;</span>\n <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">private</span> <span class=\"token operator\">:</span>\n <span class=\"token keyword\">int</span> _year <span class=\"token punctuation\">;</span>\n <span class=\"token keyword\">int</span> _month <span class=\"token punctuation\">;</span>\n <span class=\"token keyword\">int</span> _day <span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 以下测试函数能通过编译吗？</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">Test</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n Date d1<span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\64858e38673b473692084e5039295cf4.png\"/><br/> 显然这儿是过不了的，因为类中有多个默认函数。</p>\n<p>7.编译器对内置类型使用默认构造函数时，对其成员赋的是随机值。但对自定义类型，会调用它的默认函数。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\375f8254016e4bc19931be9a29562752.png\"/><br/> 这儿并没有我们自己写的构造函数，所以编译时会调用默认的构造函数，又由于类成员都是内置类型，因此赋的都是随机值。下面我们再来看看自定义类型。<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\e3d15b605f314ab49f4e6f63c0b65a35.png\"/></p>\n<blockquote>\n<p>注意：如果你Time类中没有自己写构造函数，用编译器默认的构造函数，它也是一样会输入随机值的。</p>\n</blockquote>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\1523d1bc902141648d8449bfee132380.png\"/></p>\n<h2><a id=\"_404\"></a>析构函数</h2>\n<p>前面通过构造函数的学习，我们知道一个对象时怎么来的，那一个对象又是怎么没呢的？</p>\n<blockquote>\n<p>析构函数：与构造函数功能相反，析构函数不是完成对象的销毁，局部对象销毁工作是由编译器完成的。而<br/> 对象在销毁时会自动调用析构函数，完成类的一些资源清理工作。</p>\n</blockquote>\n<h3><a id=\"_410\"></a>特性</h3>\n<ol><li>析构函数名是在类名前加上字符 ~。</li><li>无参数无返回值。</li><li>一个类有且只有一个析构函数。若未显式定义，系统会自动生成默认的析构函数。<br/> 编译器自动生成的析构函数机制：<br/>  1、编译器自动生成的析构函数对内置类型不做处理。<br/>  2、对于自定义类型，编译器会再去调用它们自己的默认析构函数。</li><li>对象生命周期结束时，C++编译系统系统自动调用析构函数。</li><li>先构造的后析构，后构造的先析构</li></ol>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\9747c4ee1d704e298bd84e1733f800e6.png\"/></p>\n<h2><a id=\"_422\"></a>拷贝构造函数</h2>\n<blockquote>\n<p>构造函数：只有单个形参，该形参是对本类类型对象的引用(一般常用const修饰)，在用已存在的类类型对象 创建新对象时由编译器自动调用</p>\n</blockquote>\n<h3><a id=\"_426\"></a>特性</h3>\n<ol><li>拷贝构造函数是构造函数的一个重载形式。</li><li>拷贝构造函数的参数只有一个且必须使用引用传参，使用传值方式会引发无穷递归调用。</li></ol>\n<pre><code class=\"prism language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream&gt;</span></span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Date</span>\n<span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n\t<span class=\"token function\">Date</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> year <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> month <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> day <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token comment\">// 构造函数</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\t_year <span class=\"token operator\">=</span> year<span class=\"token punctuation\">;</span>\n\t\t_month <span class=\"token operator\">=</span> month<span class=\"token punctuation\">;</span>\n\t\t_day <span class=\"token operator\">=</span> day<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token function\">Date</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> Date<span class=\"token operator\">&amp;</span> d<span class=\"token punctuation\">)</span><span class=\"token comment\">// 拷贝构造函数 ，与构造函数形成函数重载</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\t_year <span class=\"token operator\">=</span> d<span class=\"token punctuation\">.</span>_year<span class=\"token punctuation\">;</span>\n\t\t_month <span class=\"token operator\">=</span> d<span class=\"token punctuation\">.</span>_month<span class=\"token punctuation\">;</span>\n\t\t_day <span class=\"token operator\">=</span> d<span class=\"token punctuation\">.</span>_day<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">private</span><span class=\"token operator\">:</span>\n\t<span class=\"token keyword\">int</span> _year<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> _month<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> _day<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\tDate <span class=\"token function\">d1</span><span class=\"token punctuation\">(</span><span class=\"token number\">2021</span><span class=\"token punctuation\">,</span> <span class=\"token number\">9</span><span class=\"token punctuation\">,</span> <span class=\"token number\">27</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\tDate <span class=\"token function\">d2</span><span class=\"token punctuation\">(</span>d1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 用已存在的对象d1创建对象d2</span>\n\n\t<span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\c6e125e1e75743ee96c8e4275294a489.png\"/><br/> 因此通过形参不写成引用的形式，会形成无限递归。</p>\n<ol start=\"3\"><li>若未显示定义，系统生成默认的拷贝构造函数。 默认的拷贝构造函数对象按内存存储按字节序完成拷<br/> 贝，这种拷贝我们叫做浅拷贝，或者值拷贝。</li></ol>\n<blockquote>\n<p><code>一般涉及到堆区的问题，浅拷贝是无法解决问题的。</code>下面我们来举个例子：</p>\n</blockquote>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Stack</span>\n<span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n\t<span class=\"token function\">Stack</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> capacity <span class=\"token operator\">=</span> <span class=\"token number\">4</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\t_ps <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token operator\">*</span> capacity<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t_size <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\t\t_capacity <span class=\"token operator\">=</span> capacity<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token keyword\">void</span> <span class=\"token function\">Print</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\tcout <span class=\"token operator\">&lt;&lt;</span> _ps <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span><span class=\"token comment\">// 打印栈空间地址</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">private</span><span class=\"token operator\">:</span>\n\t<span class=\"token keyword\">int</span><span class=\"token operator\">*</span> _ps<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> _size<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> _capacity<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\tStack s1<span class=\"token punctuation\">;</span>\n\ts1<span class=\"token punctuation\">.</span><span class=\"token function\">Print</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 打印s1栈空间的地址</span>\n\tStack <span class=\"token function\">s2</span><span class=\"token punctuation\">(</span>s1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 用已存在的对象s1创建对象s2</span>\n\ts2<span class=\"token punctuation\">.</span><span class=\"token function\">Print</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 打印s2栈空间的地址</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>我们可以看到，类中没有自己定义拷贝构造函数，那么当我们用已存在的对象来创建另一个对象时，将调用编译器自动生成的拷贝构造函数。这段代码中，我们的本意是用已存在的对象s1创建对象s2，但编译器自动生成的拷贝构造函数，完成的是浅拷贝，拷贝出来的对象s2将不能满足我们的要求。</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\dffd0d75b33f45f98cdd5090147b0e9d.png\"/></p>\n<p>结果打印s1栈和s2栈空间的地址相同，这就意味着，就算在创建完s2栈后，我们对s1栈做的任何操作都会直接影响到s2栈。<br/>  <br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\e6ec85f4a3864a89af3ae0875fbfe8f6.png\"/><br/> 这个时候问题就很严重了。首先我们对s1的修改都会直接影响s2，而且更重要的一个是：我们对它们共同指向的那块空间进行了两次的析构，会造成空间多次释放的问题。</p>\n<h2><a id=\"_510\"></a>运算符重载</h2>\n<p>C++为了增强代码的可读性引入了运算符重载，运算符重载是具有特殊函数名的函数，也具有其返回值类<br/> 型，函数名字以及参数列表，其返回值类型与参数列表与普通的函数类似。</p>\n<p><em>函数名字为：关键字operator后面接需要重载的运算符符号。</em></p>\n<p><em>函数原型：返回值类型 operator操作符(参数列表)</em></p>\n<p><strong>注意</strong>：<br/> 1.不能通过连接其他符号来创建新的操作符：比如operator@<br/> 2.重载操作符必须有一个类类型或者枚举类型的操作数<br/> 3.用于内置类型的操作符，其含义不能改变，例如：内置的整型+，不 能改变其含义<br/> 4.作为类成员的重载函数时，其形参看起来比操作数数目少1成员函数的<br/> 操作符有一个默认的形参this，限定为第一个形参<br/> 5.* 、:: 、sizeof 、?: 、. 注意以上5个运算符不能重载。这个经常在笔试选择题中出现。</p>\n<h3><a id=\"_526\"></a>==运算符重载</h3>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">bool</span> <span class=\"token keyword\">operator</span><span class=\"token operator\">==</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> Date<span class=\"token operator\">&amp;</span> d1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> Date<span class=\"token operator\">&amp;</span> d2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n <span class=\"token keyword\">return</span> d1<span class=\"token punctuation\">.</span>_year <span class=\"token operator\">==</span> d2<span class=\"token punctuation\">.</span>_year<span class=\"token punctuation\">;</span>\n <span class=\"token operator\">&amp;&amp;</span> d1<span class=\"token punctuation\">.</span>_month <span class=\"token operator\">==</span> d2<span class=\"token punctuation\">.</span>_month\n <span class=\"token operator\">&amp;&amp;</span> d1<span class=\"token punctuation\">.</span>_day <span class=\"token operator\">==</span> d2<span class=\"token punctuation\">.</span>_day<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n</code></pre>\n<blockquote>\n<p>对于这个重载的函数，你可以定义再类里面，这样就少一个参数，因为有this指针的存在。你也可以定义在外面，但是定义在外面时，可能你的类成员时private封装的，无法访问到，这时有两个解决办法：一是把类成员用public封装，二是用友元函数（之后会讲到）。</p>\n</blockquote>\n<h3><a id=\"__537\"></a>= 运算符重载</h3>\n<pre><code class=\"prism language-cpp\">\tDate<span class=\"token operator\">&amp;</span> <span class=\"token keyword\">operator</span><span class=\"token operator\">=</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> Date<span class=\"token operator\">&amp;</span> d<span class=\"token punctuation\">)</span><span class=\"token comment\">// 赋值运算符重载函数</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span> <span class=\"token operator\">!=</span> <span class=\"token operator\">&amp;</span>d<span class=\"token punctuation\">)</span>\n\t\t<span class=\"token punctuation\">{<!-- --></span>\n\t\t\t_year <span class=\"token operator\">=</span> d<span class=\"token punctuation\">.</span>_year<span class=\"token punctuation\">;</span>\n\t\t\t_month <span class=\"token operator\">=</span> d<span class=\"token punctuation\">.</span>_month<span class=\"token punctuation\">;</span>\n\t\t\t_day <span class=\"token operator\">=</span> d<span class=\"token punctuation\">.</span>_day<span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t\t<span class=\"token keyword\">return</span> <span class=\"token operator\">*</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n</code></pre>\n<blockquote>\n<p>这里为什么要返回引用了？如果你去测试发现D1=D2，如果你的返回值是Date的话，似乎也能过，但是如果你的测试用例是D1=D2=D3的话，那就一定过不了了，因为你不是返回的对象本身，无法形成链式编程，这也是为什么这儿返回*this的原因，因为this是指向左操作符的。</p>\n</blockquote>\n<p>其他一些运算符的重载这儿就不多说了，有兴趣的小伙伴可以自己去尝试尝试。下面来说几个重载运算符时的注意点。</p>\n<p><strong>重载赋值运算符需要注意以下几点</strong>：<br/> <strong>一</strong>、参数类型设置为引用，并用const进行修饰<br/> 赋值运算符重载函数的第一个形参默认是this指针，第二个形参是我们赋值运算符的右操作数。<br/> 由于是自定义类型传参，我们若是使用传值传参，会额外调用一次拷贝构造函数，所以函数的第二个参数最好使用引用传参（第一个参数是默认的this指针，我们管不了）。<br/> 其次，第二个参数，即赋值运算符的右操作数，我们在函数体内不会对其进行修改，所以最好加上const进行修饰。</p>\n<p><strong>二</strong>、返回值使用引用返回<br/> 原因在=运算符重载中说过了，为了返回对象自身，形成链式编程。（return *this才是返回自身，不要忘记解引用哦）</p>\n<p><strong>三</strong>、一个类如果没有显示定义赋值运算符重载，编译器也会自动生成一个，完成对象按字节序的值拷贝</p>\n<p>没错，赋值运算符重载编译器也可以自动生成，并且也是支持连续赋值的。但是编译器自动生成的赋值运算符重载完成的是对象按字节序的值拷贝，例如d2 = d1，编译器会将d1所占内存空间的值完完全全地拷贝到d2的内存空间中去，类似于memcpy。<br/> 但是有些类就不行了，所以有些类还是要我们自己写赋值运算符重载的。</p>\n<p><strong>注意区分拷贝和赋值：</strong></p>\n<pre><code class=\"prism language-cpp\">\tDate <span class=\"token function\">d1</span><span class=\"token punctuation\">(</span><span class=\"token number\">2021</span><span class=\"token punctuation\">,</span> <span class=\"token number\">6</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\tDate <span class=\"token function\">d2</span><span class=\"token punctuation\">(</span>d1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\tDate d3 <span class=\"token operator\">=</span> d1<span class=\"token punctuation\">;</span>\n\n</code></pre>\n<p>这里一个三句代码，我们现在都知道第二句代码调用的是拷贝构造函数，那么第三句代码呢？调用的是哪一个函数？是赋值运算符重载函数吗？<br/> 其实第三句代码调用的也是拷贝构造函数，注意区分拷贝构造函数和赋值运算符重载函数的使用场景：<br/> <strong>拷贝构造函数：用一个已经存在的对象去构造初始化另一个即将创建的对象。<br/> 赋值运算符重载函数：在两个对象都已经存在的情况下，将一个对象赋值给另一个对象。</strong></p>\n<hr/>\n<h1><a id=\"const_587\"></a>const修饰成员函数</h1>\n<p>我们将const修饰的类成员函数称之为const成员函数，const修饰类成员函数，实际修饰的是类成员函数隐含的this指针，表明在该成员函数中不能对this指针指向的对象进行修改。</p>\n<p>例如，我们可以对类成员函数中的打印函数进行const修饰，避免在函数体内不小心修改了对象：</p>\n<pre><code class=\"prism language-cpp\">\t<span class=\"token keyword\">void</span> <span class=\"token function\">Print</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token keyword\">const</span><span class=\"token comment\">// cosnt修饰的打印函数</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\tcout <span class=\"token operator\">&lt;&lt;</span> _year <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"年\"</span> <span class=\"token operator\">&lt;&lt;</span> _month <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"月\"</span> <span class=\"token operator\">&lt;&lt;</span> _day <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"日\"</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\n</code></pre>\n<blockquote>\n<p>注意：<code>在使用const时要注意，权限不能放大，但是可以缩小。</code></p>\n</blockquote>\n<hr/>\n<h1><a id=\"_602\"></a>再谈构造函数</h1>\n<h2><a id=\"_603\"></a>构造函数体赋值</h2>\n<p>在创建对象时，编译器会通过调用构造函数，给对象中的各个成员变量一个合适的初始值：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Date</span>\n<span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n\t<span class=\"token comment\">// 构造函数</span>\n\t<span class=\"token function\">Date</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> year <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> month <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> day <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\t_year <span class=\"token operator\">=</span> year<span class=\"token punctuation\">;</span>\n\t\t_month <span class=\"token operator\">=</span> month<span class=\"token punctuation\">;</span>\n\t\t_day <span class=\"token operator\">=</span> day<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">private</span><span class=\"token operator\">:</span>\n\t<span class=\"token keyword\">int</span> _year<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> _month<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> _day<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n</code></pre>\n<p>虽然上述构造函数调用之后，对象中已经有了一个初始值，但是不能将其称作为类对象成员的初始化，构造函数体中的语句只能将其称作为赋初值，而不能称作初始化。因为初始化只能初始化一次，而构造函数体内可以多次赋值。</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Date</span>\n<span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n\t<span class=\"token comment\">// 构造函数</span>\n\t<span class=\"token function\">Date</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> year <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> month <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> day <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\t_year <span class=\"token operator\">=</span> year<span class=\"token punctuation\">;</span><span class=\"token comment\">// 第一次赋值</span>\n\t\t_year <span class=\"token operator\">=</span> <span class=\"token number\">2022</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 第二次赋值</span>\n\t\t<span class=\"token comment\">//...</span>\n\t\t_month <span class=\"token operator\">=</span> month<span class=\"token punctuation\">;</span>\n\t\t_day <span class=\"token operator\">=</span> day<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">private</span><span class=\"token operator\">:</span>\n\t<span class=\"token keyword\">int</span> _year<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> _month<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> _day<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n</code></pre>\n<h2><a id=\"_647\"></a>初始化列表</h2>\n<p><strong>初始化列表</strong>：以一个冒号开始，接着是一个以逗号分隔的数据成员列表，每个成员变量后面跟一个放在括号中的初始值或表达式。</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Date</span>\n<span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n\t<span class=\"token comment\">// 构造函数  </span>\n\t<span class=\"token function\">Date</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> year <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> month <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> day <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n\t\t<span class=\"token operator\">:</span><span class=\"token function\">_year</span><span class=\"token punctuation\">(</span>year<span class=\"token punctuation\">)</span>\n\t\t<span class=\"token punctuation\">,</span> <span class=\"token function\">_month</span><span class=\"token punctuation\">(</span>month<span class=\"token punctuation\">)</span>\n\t\t<span class=\"token punctuation\">,</span> <span class=\"token function\">_day</span><span class=\"token punctuation\">(</span>day<span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">private</span><span class=\"token operator\">:</span>\n\t<span class=\"token keyword\">int</span> _year<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> _month<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> _day<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n</code></pre>\n<h3><a id=\"_668\"></a>注意事项</h3>\n<h4><a id=\"1_670\"></a>1.每个成员变量在初始化列表中只能出现一次(初始化只能初始化一次)</h4>\n<h4><a id=\"2_672\"></a>2.类中包含以下成员，必须放在初始化列表进行初始化：</h4>\n<pre><code>💥.引用成员变量\n     引用类型的变量在定义时就必须给其一个初始值，所以引用成员变量必须使用初始化列表对其进行初始化。\n</code></pre>\n<pre><code class=\"prism language-cpp\">\t<span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span><span class=\"token operator\">&amp;</span> b <span class=\"token operator\">=</span> a<span class=\"token punctuation\">;</span><span class=\"token comment\">// 创建时就初始化</span>\n\n</code></pre>\n<pre><code>💥.const成员变量\n被const修饰的变量也必须在定义时就给其一个初始值，也必须使用初始化列表进行初始化\n</code></pre>\n<pre><code class=\"prism language-cpp\">\t<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//correct 创建时就初始化</span>\n\t<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> b<span class=\"token punctuation\">;</span><span class=\"token comment\">//error 创建时未初始化</span>\n\n</code></pre>\n<pre><code>💥.自定义类型成员（该类没有默认构造函数）\n若一个类没有默认构造函数，那么我们在实例化该类对象时就需要传参对其进行初始化，所以实例化没有默认构造函数的类对象时必须使用初始化列表对其进行初始化。\n</code></pre>\n<p><strong>在这里再声明一下，默认构造函数是指不用传参就可以调用的构造函数：</strong><br/>  1.我们不写，编译器自动生成的构造函数。<br/>  2.无参的构造函数。<br/>  3.全缺省的构造函数。</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">A</span> <span class=\"token comment\">//该类没有默认构造函数 </span>\n<span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n\t<span class=\"token function\">A</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> val<span class=\"token punctuation\">)</span> <span class=\"token comment\">//注：这个不叫默认构造函数（需要传参调用）</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\t_val <span class=\"token operator\">=</span> val<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">private</span><span class=\"token operator\">:</span>\n\t<span class=\"token keyword\">int</span> _val<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">B</span>\n<span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n\t<span class=\"token function\">B</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t\t<span class=\"token operator\">:</span><span class=\"token function\">_a</span><span class=\"token punctuation\">(</span><span class=\"token number\">2021</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">//必须使用初始化列表对其进行初始化</span>\n\t<span class=\"token punctuation\">{<!-- --></span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">private</span><span class=\"token operator\">:</span>\n\tA _a<span class=\"token punctuation\">;</span> <span class=\"token comment\">//自定义类型成员（该类没有默认构造函数）</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n</code></pre>\n<blockquote>\n<p><strong>总结一下</strong>：在定义时就必须进行初始化的变量类型，就必须放在初始化列表进行初始化。</p>\n</blockquote>\n<h4><a id=\"3_726\"></a>3.尽量使用初始化列表初始化</h4>\n<p>因为初始化列表实际上就是当你实例化一个对象时，该对象的成员变量定义的地方，所以无论你是否使用初始化列表，都会走这么一个过程（成员变量需要定义出来）。</p>\n<p><strong>严格来说：</strong><br/> <strong>1</strong>.对于内置类型，使用初始化列表和在构造函数体内进行初始化实际上是没有差别的，其差别就类似于如下代码：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token comment\">// 使用初始化列表</span>\n<span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token number\">10</span>\n<span class=\"token comment\">// 在构造函数体内初始化（不使用初始化列表）</span>\n<span class=\"token keyword\">int</span> a<span class=\"token punctuation\">;</span>\na <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n\n</code></pre>\n<p><strong>2</strong>.对于自定义类型，使用初始化列表可以提高代码的效率</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Time</span>\n<span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n\t<span class=\"token function\">Time</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> hour <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\t_hour <span class=\"token operator\">=</span> hour<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">private</span><span class=\"token operator\">:</span>\n\t<span class=\"token keyword\">int</span> _hour<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Test</span>\n<span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n\t<span class=\"token comment\">// 使用初始化列表</span>\n\t<span class=\"token function\">Test</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> hour<span class=\"token punctuation\">)</span>\n\t\t<span class=\"token operator\">:</span><span class=\"token function\">_t</span><span class=\"token punctuation\">(</span><span class=\"token number\">12</span><span class=\"token punctuation\">)</span><span class=\"token comment\">// 调用一次Time类的构造函数</span>\n\t<span class=\"token punctuation\">{<!-- --></span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">private</span><span class=\"token operator\">:</span>\n\tTime _t<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n</code></pre>\n<p>对于以上代码，当我们要实例化一个Test类的对象时，我们使用了初始化列表，在实例化过程中只调用了一次Time类的构造函数。<br/>  我们若是想在不使用初始化列表的情况下，达到我们想要的效果，就不得不这样写了：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Time</span>\n<span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n\t<span class=\"token function\">Time</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> hour <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\t_hour <span class=\"token operator\">=</span> hour<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">private</span><span class=\"token operator\">:</span>\n\t<span class=\"token keyword\">int</span> _hour<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Test</span>\n<span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n\t<span class=\"token comment\">// 在构造函数体内初始化（不使用初始化列表）</span>\n\t<span class=\"token function\">Test</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> hour<span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\tTime <span class=\"token function\">t</span><span class=\"token punctuation\">(</span>hour<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 调用一次Time类的构造函数</span>\n\t\t_t <span class=\"token operator\">=</span> t<span class=\"token punctuation\">;</span><span class=\"token comment\">// 调用一次Time类的赋值运算符重载函数</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">private</span><span class=\"token operator\">:</span>\n\tTime _t<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n</code></pre>\n<p>这时如果我们要实例化一个Test类的对象，在实例化过程中先调用了一次Time类的构造函数，又调用了一次Time类的赋值运算符重载函数，效率就降下来了。</p>\n<h4><a id=\"4_798\"></a>4.成员变量在类中声明的次序就是其在初始化列表中的初始化顺序，与其在初始化列表中的先后顺序无关</h4>\n<p>还是一样举个例子来看看：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream&gt;</span></span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Test</span>\n<span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n\t<span class=\"token function\">Test</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t\t<span class=\"token operator\">:</span><span class=\"token function\">_b</span><span class=\"token punctuation\">(</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n\t\t<span class=\"token punctuation\">,</span><span class=\"token function\">_a</span><span class=\"token punctuation\">(</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span><span class=\"token punctuation\">}</span>\n\t<span class=\"token keyword\">void</span> <span class=\"token function\">Print</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\tcout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"_a:\"</span> <span class=\"token operator\">&lt;&lt;</span> _a <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n\t\tcout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"_b:\"</span> <span class=\"token operator\">&lt;&lt;</span> _b <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">private</span><span class=\"token operator\">:</span>\n\t<span class=\"token keyword\">int</span> _a<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> _b<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\tTest test<span class=\"token punctuation\">;</span>\n\ttest<span class=\"token punctuation\">.</span><span class=\"token function\">Print</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//打印结果test._a为0，test._b为1</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n</code></pre>\n<p>代码中，Test类构造函数的初始化列表中成员变量_b先初始化，成员变量_a后初始化，按道理打印结果test._a为1，test._b为0，但是初始化列表的初始化顺序是成员变量在类中声明次序，所以最终test._a为0，test._b为1。</p>\n<hr/>\n<h1><a id=\"explicit_831\"></a>explicit关键字</h1>\n<p>构造函数不仅可以构造和初始化对象，对于单个参数的构造函数，还支持隐式类型转换。</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream&gt;</span></span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Date</span>\n<span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n\t<span class=\"token function\">Date</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> year <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">//单个参数的构造函数</span>\n\t\t<span class=\"token operator\">:</span><span class=\"token function\">_year</span><span class=\"token punctuation\">(</span>year<span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span><span class=\"token punctuation\">}</span>\n\t<span class=\"token keyword\">void</span> <span class=\"token function\">Print</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\tcout <span class=\"token operator\">&lt;&lt;</span> _year <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">private</span><span class=\"token operator\">:</span>\n\t<span class=\"token keyword\">int</span> _year<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\tDate d1 <span class=\"token operator\">=</span> <span class=\"token number\">2021</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//支持该操作</span>\n\td1<span class=\"token punctuation\">.</span><span class=\"token function\">Print</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n</code></pre>\n<p>在<strong>语法上</strong>，代码中Date d1 = 2021等价于以下两句代码：</p>\n<pre><code class=\"prism language-cpp\">Date <span class=\"token function\">tmp</span><span class=\"token punctuation\">(</span><span class=\"token number\">2021</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//先构造</span>\nDate <span class=\"token function\">d1</span><span class=\"token punctuation\">(</span>tmp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//再拷贝构造</span>\n\n</code></pre>\n<p>在早期的编译器中，当编译器遇到Date d1 = 2021这句代码时，会先构造一个临时对象，再用临时对象拷贝构造d1；但是现在的编译器已经做了优化，当遇到Date d1 = 2021这句代码时，会按照Date d1(2021)这句代码处理，这就叫做隐式类型转换。</p>\n<p>实际上，我们早就接触了隐式类型转换，只是我们不知道而已，以下代码也叫隐式类型转换：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">double</span> b <span class=\"token operator\">=</span> a<span class=\"token punctuation\">;</span> <span class=\"token comment\">//隐式类型转换</span>\n\n</code></pre>\n<p>在这个过程中，编译器会先构建一个double类型的临时变量接收a的值，然后再将该临时变量的值赋值给b。这就是为什么函数可以返回局部变量的值，因为当函数被销毁后，虽然作为返回值的变量也被销毁了，但是隐式类型转换过程中所产生的临时变量并没有被销毁，所以该值仍然存在。</p>\n<p>但是，对于单参数的自定义类型来说，Date d1 = 2021这种代码的可读性不是很好，我们<strong>若是想禁止单参数构造函数的隐式转换，可以用关键字explicit来修饰构造函数</strong>。</p>\n<hr/>\n<h1><a id=\"static_881\"></a>static成员</h1>\n<p>声明为static的类成员称为类的静态成员。用static修饰的成员变量，称之为静态成员变量；用static修饰的成员函数，称之为静态成员函数。静态成员变量一定要在类外进行初始化。</p>\n<h2><a id=\"_884\"></a>特性</h2>\n<h3><a id=\"1%E2%80%83staticstaticstatic_885\"></a>1. 声明为static的类成员称为类的静态成员。用static修饰的成员变量，称之为静态成员变量；用static修饰的成员函数，称之为静态成员函数。静态成员变量一定要在类外进行初始化。</h3>\n<pre><code class=\"prism language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream&gt;</span></span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Test</span>\n<span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">private</span><span class=\"token operator\">:</span>\n\t<span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> _n<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\tcout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>Test<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n</code></pre>\n<p>结果计算Test类的大小为1，因为静态成员_n是存储在静态区的，属于整个类，也属于类的所有对象。所以计算类的大小或是类对象的大小时，静态成员并不计入其总大小之和。</p>\n<h3><a id=\"2static_904\"></a>2.静态成员变量必须在类外定义，定义时不添加static关键字</h3>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Test</span>\n<span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">private</span><span class=\"token operator\">:</span>\n\t<span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> _n<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 静态成员变量的定义初始化</span>\n<span class=\"token keyword\">int</span> Test<span class=\"token operator\">::</span>_n <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n</code></pre>\n<p><strong>注意</strong>：这里静态成员变量_n虽然是私有，但是我们在类外突破类域直接对其进行了访问。这是一个特例，不受访问限定符的限制，否则就没办法对静态成员变量进行定义和初始化了</p>\n<h3><a id=\"3this_918\"></a>3.静态成员函数没有隐藏的this指针，不能访问任何非静态成员</h3>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Test</span>\n<span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n\t<span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">Fun</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\tcout <span class=\"token operator\">&lt;&lt;</span> _a <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span> <span class=\"token comment\">//error不能访问非静态成员</span>\n\t\tcout <span class=\"token operator\">&lt;&lt;</span> _n <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span> <span class=\"token comment\">//correct</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">private</span><span class=\"token operator\">:</span>\n\t<span class=\"token keyword\">int</span> _a<span class=\"token punctuation\">;</span> <span class=\"token comment\">//非静态成员</span>\n\t<span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> _n<span class=\"token punctuation\">;</span> <span class=\"token comment\">//静态成员</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n</code></pre>\n<p>注意：含有静态成员变量的类，一般含有一个静态成员函数，用于访问静态成员变量</p>\n<h3><a id=\"4_938\"></a>4.访问静态成员变量的方法</h3>\n<h4><a id=\"_940\"></a>一.当静态成员变量为公有时，有以下几种访问方式：</h4>\n<pre><code class=\"prism language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream&gt;</span></span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Test</span>\n<span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n\t<span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> _n<span class=\"token punctuation\">;</span> <span class=\"token comment\">//公有</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 静态成员变量的定义初始化</span>\n<span class=\"token keyword\">int</span> Test<span class=\"token operator\">::</span>_n <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\tTest test<span class=\"token punctuation\">;</span>\n\tcout <span class=\"token operator\">&lt;&lt;</span> test<span class=\"token punctuation\">.</span>_n <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span> <span class=\"token comment\">//1.通过类对象突破类域进行访问</span>\n\tcout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token function\">Test</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>_n <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span> <span class=\"token comment\">//3.通过匿名对象突破类域进行访问</span>\n\tcout <span class=\"token operator\">&lt;&lt;</span> Test<span class=\"token operator\">::</span>_n <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span> <span class=\"token comment\">//2.通过类名突破类域进行访问</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n</code></pre>\n<h4><a id=\"_962\"></a>二.当静态成员变量为私有时，有以下几种访问方式：</h4>\n<pre><code class=\"prism language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream&gt;</span></span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Test</span>\n<span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n\t<span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">GetN</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\t<span class=\"token keyword\">return</span> _n<span class=\"token punctuation\">;</span>   <span class=\"token comment\">//既然你的成员是私有的，那么我就通过公有的函数来返回你私有的成员</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">private</span><span class=\"token operator\">:</span>\n\t<span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> _n<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 静态成员变量的定义初始化</span>\n<span class=\"token keyword\">int</span> Test<span class=\"token operator\">::</span>_n <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\tTest test<span class=\"token punctuation\">;</span>\n\tcout <span class=\"token operator\">&lt;&lt;</span> test<span class=\"token punctuation\">.</span><span class=\"token function\">GetN</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span> <span class=\"token comment\">//1.通过对象调用成员函数进行访问</span>\n\tcout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token function\">Test</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">GetN</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span> <span class=\"token comment\">//2.通过匿名对象调用成员函数进行访问</span>\n\tcout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token class-name\">Test</span><span class=\"token operator\">::</span><span class=\"token function\">GetN</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span> <span class=\"token comment\">//3.通过类名调用静态成员函数进行访问</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n</code></pre>\n<h3><a id=\"5publicprivateprotected_990\"></a>5.静态成员和类的普通成员一样，也有public、private和protected这三种访问级别</h3>\n<p>所以当静态成员变量设置为private时，尽管我们突破了类域，也不能对其进行访问。</p>\n<p>注意区分两个问题：<br/>  <strong>1、静态成员函数可以调用非静态成员函数吗？<br/>  2、非静态成员函数可以调用静态成员函数吗？</strong><br/> 问题1：不可以。因为非静态成员函数的第一个形参默认为this指针，而静态成员函数中没有this指针，故静态成员函数不可调用非静态成员函数。<br/> 问题2：可以。因为静态成员函数和非静态成员函数都在类中，在类中不受访问限定符的限制。</p>\n<hr/>\n<h1><a id=\"C11_999\"></a>C++11中成员初始化的新玩法</h1>\n<p>C++11支持非静态成员变量在声明时进行初始化赋值，但是要注意这里不是初始化，这里是给声明的成员变量一个缺省值。</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">A</span>\n<span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n\t<span class=\"token keyword\">void</span> <span class=\"token function\">Print</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\tcout <span class=\"token operator\">&lt;&lt;</span> _a <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n\t\tcout <span class=\"token operator\">&lt;&lt;</span> _p <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">private</span><span class=\"token operator\">:</span>\n\t<span class=\"token comment\">// 非静态成员变量，可以在成员声明时给缺省值。</span>\n\t<span class=\"token keyword\">int</span> _a <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> \n\t<span class=\"token keyword\">int</span><span class=\"token operator\">*</span> _p <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> _n<span class=\"token punctuation\">;</span> <span class=\"token comment\">//静态成员变量不能给缺省值</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n</code></pre>\n<p>初始化列表是成员变量定义初始化的地方，你若是给定了值，就用你所给的值对成员变量进行初始化，你若没有给定值，则用缺省值进行初始化，若是没有缺省值，则内置类型的成员就是随机值。</p>\n<hr/>\n<h1><a id=\"_1022\"></a>友元</h1>\n<p>友元分为：友元函数和友元类<br/> 友元提供了一种突破封装的方式，有时提供了便利。但是友元会增加耦合度，破坏了封装，所以友元不宜多<br/> 用。</p>\n<h2><a id=\"_1027\"></a>友元函数</h2>\n<p>这里就以我们之前没有实现的一个重载来举例，我们来实现一下&lt;&lt;的重载。<br/> 这里要实现首先要明白一个问题：</p>\n<blockquote>\n<p>我们尝试去重载operator&lt;&lt;，然后发现我们没办法将operator&lt;&lt;重载成成员函数。因为cout的<br/> 输出流对象和隐含的this指针在抢占第一个参数的位置。this指针默认是第一个参数也就是左操作数了。但是<br/> 实际使用中cout需要是第一个形参对象，才能正常使用。所以我们要将operator&lt;&lt;重载成全局函数。但是这<br/> 样的话，又会导致类外没办法访问成员，那么这里就需要友元来解决。operator&gt;&gt;同理。</p>\n</blockquote>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Date</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token comment\">// 友元函数的声明</span>\n\t<span class=\"token keyword\">friend</span> ostream<span class=\"token operator\">&amp;</span> <span class=\"token keyword\">operator</span><span class=\"token operator\">&lt;&lt;</span><span class=\"token punctuation\">(</span>ostream<span class=\"token operator\">&amp;</span> out<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> Date<span class=\"token operator\">&amp;</span> d<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">friend</span> istream<span class=\"token operator\">&amp;</span> <span class=\"token keyword\">operator</span><span class=\"token operator\">&gt;&gt;</span><span class=\"token punctuation\">(</span>istream<span class=\"token operator\">&amp;</span> in<span class=\"token punctuation\">,</span> Date<span class=\"token operator\">&amp;</span> d<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n\t<span class=\"token function\">Date</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> year <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> month <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> day <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\t_year <span class=\"token operator\">=</span> year<span class=\"token punctuation\">;</span>\n\t\t_month <span class=\"token operator\">=</span> month<span class=\"token punctuation\">;</span>\n\t\t_day <span class=\"token operator\">=</span> day<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">private</span><span class=\"token operator\">:</span>\n\t<span class=\"token keyword\">int</span> _year<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> _month<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> _day<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// &lt;&lt;运算符重载</span>\nostream<span class=\"token operator\">&amp;</span> <span class=\"token keyword\">operator</span><span class=\"token operator\">&lt;&lt;</span><span class=\"token punctuation\">(</span>ostream<span class=\"token operator\">&amp;</span> out<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> Date<span class=\"token operator\">&amp;</span> d<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\tout <span class=\"token operator\">&lt;&lt;</span> d<span class=\"token punctuation\">.</span>_year <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"-\"</span> <span class=\"token operator\">&lt;&lt;</span> d<span class=\"token punctuation\">.</span>_month <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"-\"</span> <span class=\"token operator\">&lt;&lt;</span> d<span class=\"token punctuation\">.</span>_day<span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">return</span> out<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// &gt;&gt;运算符重载</span>\nistream<span class=\"token operator\">&amp;</span> <span class=\"token keyword\">operator</span><span class=\"token operator\">&gt;&gt;</span><span class=\"token punctuation\">(</span>istream<span class=\"token operator\">&amp;</span> in<span class=\"token punctuation\">,</span> Date<span class=\"token operator\">&amp;</span> d<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\tin <span class=\"token operator\">&gt;&gt;</span> d<span class=\"token punctuation\">.</span>_year <span class=\"token operator\">&gt;&gt;</span> d<span class=\"token punctuation\">.</span>_month <span class=\"token operator\">&gt;&gt;</span> d<span class=\"token punctuation\">.</span>_day<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">return</span> in<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n</code></pre>\n<p><strong>友元函数说明：</strong><br/>  1、友元函数可以访问类是私有和保护成员，但不是类的成员函数。<br/>  2、友元函数不能用const修饰。<br/>  3、友元函数可以在类定义的任何地方声明，不受访问限定符的限制。<br/>  4、一个函数可以是多个类的友元函数。<br/>  5、友元函数的调用与普通函数的调用原理相同。</p>\n<h2><a id=\"_1077\"></a>友元类</h2>\n<p>友元类的所有成员函数都可以是另一个类的友元函数，都可以访问另一个类中非公有成员。</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">A</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token comment\">// 声明B是A的友元类  可以理解为B是A的好朋友，A的任何东西B都可以访问，包括私有类型的。</span>\n\t<span class=\"token keyword\">friend</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">B</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n\t<span class=\"token function\">A</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n\t\t<span class=\"token operator\">:</span><span class=\"token function\">_n</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">private</span><span class=\"token operator\">:</span>\n\t<span class=\"token keyword\">int</span> _n<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">B</span>\n<span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n\t<span class=\"token keyword\">void</span> <span class=\"token function\">Test</span><span class=\"token punctuation\">(</span>A<span class=\"token operator\">&amp;</span> a<span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t\t<span class=\"token comment\">// B类可以直接访问A类中的私有成员变量  </span>\n\t\tcout <span class=\"token operator\">&lt;&lt;</span> a<span class=\"token punctuation\">.</span>_n <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n</code></pre>\n<p><strong>友元类说明：</strong><br/> <strong>1</strong>、友元关系是单向的，不具有交换性。<br/>  例如上述代码中，B是A的友元，所以在B类中可以直接访问A类的私有成员变量，但是在A类中不能访问B类中的私有成员变量。<br/> <strong>2</strong>、友元关系不能传递。<br/>  如果A是B的友元，B是C的友元，不能推出A是C的友元。</p>\n<hr/>\n<h1><a id=\"_1111\"></a>内部类</h1>\n<p><strong>概念</strong>：如果一个类定义在另一个类的内部，这个内部类就叫做内部类。注意此时这个内部类是一个独立的<br/> 类，它不属于外部类，更不能通过外部类的对象去调用内部类。外部类对内部类没有任何优越的访问权限。</p>\n<p><strong>注意</strong>：<strong>内部类就是外部类的友元类</strong>。注意友元类的定义，内部类可以通过外部类的对象参数来访问外部类中的所有成员。但是<strong>外部类不是内部类的友元</strong>。</p>\n<p><strong>特性</strong>：</p>\n<ol><li>内部类可以定义在外部类的public、protected、private都是可以的。</li><li>注意内部类可以直接访问外部类中的static、枚举成员，不需要外部类的对象/类名。</li><li>sizeof(外部类)=外部类，和内部类没有任何关系。</li></ol>\n<pre><code class=\"prism language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">A</span> <span class=\"token punctuation\">{<!-- --></span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n\t<span class=\"token function\">A</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> k<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> h<span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{<!-- --></span> \n\t\t<span class=\"token keyword\">this</span><span class=\"token operator\">-&gt;</span>_k <span class=\"token operator\">=</span> k<span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">this</span><span class=\"token operator\">-&gt;</span>_h <span class=\"token operator\">=</span> h<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">private</span><span class=\"token operator\">:</span>\n\t<span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> _k<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> _h<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n\t<span class=\"token keyword\">class</span> <span class=\"token class-name\">B</span>\n\t<span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n\t\t<span class=\"token keyword\">void</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> A<span class=\"token operator\">&amp;</span> a<span class=\"token punctuation\">)</span>\n\t\t<span class=\"token punctuation\">{<!-- --></span>\n\t\t\tcout <span class=\"token operator\">&lt;&lt;</span>_k <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span><span class=\"token comment\">//OK  a._k也ok</span>\n\t\t\tcout <span class=\"token operator\">&lt;&lt;</span> a<span class=\"token punctuation\">.</span>_h <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span><span class=\"token comment\">//OK</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">int</span> A<span class=\"token operator\">::</span>_k <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{<!-- --></span>\n\tA<span class=\"token operator\">::</span>B b<span class=\"token punctuation\">;</span>\n\tb<span class=\"token punctuation\">.</span><span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token function\">A</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\2d034adfbb2d418ab72911d239713fe4.png\"/></p>\n<hr/>\n<h1><a id=\"_1158\"></a>再次理解封装</h1>\n<p>C++是基于面向对象的程序，面向对象有三大特性：封装、继承、多态。</p>\n<p>C++通过类，将一个对象的属性与行为结合在一起，使其更符合人们对于一件事物的认知，将属于该对象的所有东西打包在一起。通过访问限定符的将其部分功能开放出来与其他对象进行交互，而对于对象内部的一些实现细节，外部用户不需要知道，知道了有些情况下也没用，反而增加了使用或者维护的难度，让整个事情复杂化。</p>\n<hr/>\n<h1><a id=\"_1164\"></a>再次理解面向对象</h1>\n<p>可以看出，面向对象其实是在模拟抽象映射现实世界：<br/> <img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\fd04d21c80434433a0cc683b1a1c8b10.png\"/></p>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "C++", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2021-09-27 21:04:56", "summary": "文章目录面向过程和面向对象初步认识类的引入类的定义类的两种定义方法声明和定义全部放在类体中声明放在文件中，类的定义放在文件中类的访问限定符及封装访问限定符封装类的作用域类的实例化类对象模型如何计算类对"}