{"blogid": "124211114", "writerAge": "码龄8年", "writerBlogNum": "51", "writerCollect": "111", "writerComment": "13", "writerFan": "10", "writerGrade": "4级", "writerIntegral": "1234", "writerName": "hacker_lpy", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_124211114.jpg", "writerRankTotal": "21674", "writerRankWeekly": "90982", "writerThumb": "34", "writerVisitNum": "84614", "blog_read_count": "1675", "blog_time": "已于 2022-08-02 15:53:10 修改", "blog_title": "基于 gmssl实现的sm2加密（C++）", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>项目中需要用到sm2加密，在网上搜索了一下相关的库，发现只有openssl和gmssl这两个库可以用，于是基于gmssl库做了封装，gmssl的版本是：GmSSL 2.5.4 - OpenSSL 1.1.0d  19 Jun 2019</p>\n<p>搞这个库的确要费不少功夫，现在分享出来给需要的人。目前我是用在linux环境中，因此编译成linux动态库，并且屏蔽相关库的头文件和符号，只暴露sm2加解密相关的接口符号，gmssl库通过静态库的方式引用。</p>\n<p>关于sm2加密有几个比较重要的参数，第一个是椭圆曲线参数，第二个是密文编码方式，第三个是哈希算法，目前我们用的都是固定的参数，所以封装的时候没有提供参数选择这些功能，需要的可以自行扩展。下面的sm2加密相关从参数为：使用默认的椭圆曲线参数(sm2p256v1)，ASN.1/DER编码方式(C1|C3|C2编码方式) ，哈希（杂凑）算法使用sm3</p>\n<p>gmutil.h头文件：</p>\n<pre><code class=\"language-cpp\">#ifndef __GM_UTIL_H__\n#define __GM_UTIL_H__\n#include &lt;string&gt;\nusing namespace std;\n\n#ifdef _WIN32\n#define UNIX_EXPORT\n#else\n#define UNIX_EXPORT __attribute__((visibility(\"default\")))\n#endif\n// namespace GM\n//{\n\n// 错误码\nenum EGMErrorCode\n{\n    GM_UTIL_CODE_OK = 0,\n    GM_UTIL_CODE_CREATE_EV_KEY_FAILED, // 密钥解析失败\n    GM_UTIL_CODE_SM2_ENCRYPT_FAILED,   // SM2加密失败\n    GM_UTIL_CODE_SM2_DECRYPT_FAILED,   // SM2解密失败\n    GM_UTIL_CODE_NOT_SM2P256V1,        // 不是默认的sm2p256v1椭圆曲线参数\n    GM_UTIL_CODE_INIT_BIO_FAILED,      // 初始化BIO失败\n    GM_UTIL_CODE_CIPHER_TEXT_TO_BIO_FAILED,      // 加密数据存储到BIO失败\n    GM_UTIL_CODE_BIO_DATA_TO_MEM_FAILED,      // BIO数据转存到缓冲区失败\n    GM_UTIL_CODE_BIO_DATA_TO_CIPHER_TEXT_FAILED,      // BIO数据转成Ciphertext结构失败\n};\nextern \"C\"\n{\n    // 从文件中读入公钥/私钥数据到string中,失败返回空字符串\n    UNIX_EXPORT string GmReadKeyFromFile(string strFileName);\n\n    /**\n     * @brief sm2加密，使用默认的椭圆曲线参数(NID_sm2p256v1)，ASN.1/DER编码方式(C1|C3|C2编码方式) ，哈希（杂凑）算法使用sm3\n     * @param strPubKey 公钥数据\n     * @param strIn 需要加密的数据\n     * @param strCiphertext 密文,加密后的密文不是可见字符\n     * @return 返回GM_UTIL_ERR_OK表示加密成功，否则失败，具体见EGMErrorCode定义\n     */\n    UNIX_EXPORT int GmSm2Encrypt(string strPubKey, const string &amp;strIn, string &amp;strCiphertext);\n\n    /**\n     * @brief sm2解密，使用默认的椭圆曲线参数(NID_sm2p256v1)，ASN.1/DER编码方式(C1|C3|C2编码方式)，哈希（杂凑）算法使用sm3\n     * @param strPubKeyFile 私钥数据\n     * @param strCiphertext 需要解密的数据(不是可见字符)\n     * @param strOut 解密后的明文\n     * @return 返回GM_UTIL_ERR_OK表示解密成功，否则失败，具体见EGMErrorCode定义\n     */\n    UNIX_EXPORT int GmSm2Decrypt(string strPriKey, const string &amp;strCiphertext, string &amp;strOut);\n\n    // 将二进制数据转换成十六进制字符串\n    UNIX_EXPORT string GmByte2HexStr(const string &amp;data, bool bLowerCase = true);\n\n    // 将十六进制字符串转换成二进制\n    UNIX_EXPORT string GmHexStr2Byte(const string&amp; hex, bool bLowerCase = true);\n}\n\n// } // namespace GM\n#endif // end __GM_UTIL_H__</code></pre>\n<p>gmutil.cpp文件：</p>\n<pre><code class=\"language-cpp\">#include \"gmutil.h\"\n#include &lt;iostream&gt;\n#include&lt;fstream&gt;\n#include&lt;sstream&gt;\n#include &lt;stdio.h&gt;\n#include &lt;openssl/evp.h&gt;\n#include &lt;openssl/pem.h&gt;\n#include &lt;openssl/sm2.h&gt;\n#include &lt;openssl/bio.h&gt;\n//using namespace GM;\n\n/**\n * @brief 使用公钥/私钥数据获取EV_KEY对象\n * @param key 公钥/私钥数据\n * @param is_public 是否公钥\n * @return 失败返回NULL\n */\nstatic EC_KEY *CreateEC(unsigned char *key, int is_public)\n{\n    EC_KEY *ec_key = NULL;\n    BIO *keybio = NULL;\n    keybio = BIO_new_mem_buf(key, -1);\n \n    if (keybio == NULL) {\n        printf(\"%s\", \"[BIO_new_mem_buf]-&gt;key len=%d,Failed to Get Key\", strlen((char *) key));\n        return NULL;\n    }\n \n    if (is_public) {\n        ec_key = PEM_read_bio_EC_PUBKEY(keybio, NULL, NULL, NULL);\n    } else {\n        ec_key = PEM_read_bio_ECPrivateKey(keybio, NULL, NULL, NULL);\n    }\n \n    if (ec_key == NULL) {\n        printf(\"Failed to Get Key\");\n        BIO_free_all(keybio);\n        return NULL;\n    }\n\n    BIO_free_all(keybio); // 此处是不是要free?\n    return ec_key;\n}\n\nint GmSm2Encrypt(string strPubKey, const string &amp;strIn, string &amp;strCiphertext)\n{\n    EC_KEY *evKey = CreateEC((unsigned char *)strPubKey.c_str(), 1);\n    if (NULL == evKey)\n    {\n        return GM_UTIL_CODE_CREATE_EV_KEY_FAILED;\n    }\n    \n    // 目前只支持默认的sm2p256v1椭圆曲线参数\n    if (!EC_KEY_is_sm2p256v1(evKey))\n    {\n        EC_KEY_free(evKey);\n        return GM_UTIL_CODE_NOT_SM2P256V1;\n    }\n\n    // 加密后的密文会比明文长97字节\n    unsigned char *buff = NULL;\n    size_t outLen = 0;\n    SM2CiphertextValue *cval = NULL;\n    size_t mlen, clen;\n    unsigned char *p;\n\n    if (NULL == (cval = SM2_do_encrypt(EVP_sm3(), (const unsigned char *)strIn.c_str(), strIn.size(), evKey)))\n    {\n        EC_KEY_free(evKey);\n        return GM_UTIL_CODE_SM2_ENCRYPT_FAILED;\n    }\n    \n    BIO *bOut = BIO_new(BIO_s_mem());\n    if (NULL == bOut)\n    {\n        EC_KEY_free(evKey);\n        SM2CiphertextValue_free(cval);\n        return GM_UTIL_CODE_INIT_BIO_FAILED;\n    }\n\n    if (i2d_SM2CiphertextValue_bio(bOut, cval) &lt;= 0)\n    {\n        SM2CiphertextValue_free(cval);\n        BIO_free(bOut);\n        EC_KEY_free(evKey);\n        return GM_UTIL_CODE_CIPHER_TEXT_TO_BIO_FAILED;\n    }\n\n    if (0 == (outLen = BIO_get_mem_data(bOut, (char **)&amp;buff)))\n    {\n        SM2CiphertextValue_free(cval);\n        BIO_free(bOut);\n        EC_KEY_free(evKey);\n        return GM_UTIL_CODE_BIO_DATA_TO_MEM_FAILED;\n    }\n\n    strCiphertext.assign((char *)buff, outLen);\n    // 释放内存\n    SM2CiphertextValue_free(cval);\n    BIO_free(bOut);\n    EC_KEY_free(evKey);\n    // OPENSSL_free(buff); //此处释放会挂掉，不应该free，应该是在BIO_free的时候内存已经被释放掉\n    return GM_UTIL_CODE_OK;\n}\n\n\nint GmSm2Decrypt(string strPriKey, const string &amp;strCiphertext, string &amp;strOut)\n{\n    EC_KEY *evKey = CreateEC((unsigned char *)strPriKey.c_str(), 0);\n    if (NULL == evKey)\n    {\n        return GM_UTIL_CODE_CREATE_EV_KEY_FAILED;\n    }\n\n    if (!EC_KEY_is_sm2p256v1(evKey))\n    {\n        EC_KEY_free(evKey);\n        return GM_UTIL_CODE_NOT_SM2P256V1;\n    }\n    BIO *bIn = NULL;\n    bIn = BIO_new_mem_buf(strCiphertext.c_str(), strCiphertext.size());\n    if (bIn == NULL)\n    {\n        EC_KEY_free(evKey);\n        return GM_UTIL_CODE_INIT_BIO_FAILED;\n    }\n\n    int ret = 0;\n\tSM2CiphertextValue *cval = NULL;\n\tvoid *buf = NULL;\n\tsize_t siz;\n    const EVP_MD* md = EVP_sm3();\n\n    if (NULL == (cval = d2i_SM2CiphertextValue_bio(bIn, NULL)))\n    {\n        BIO_free(bIn);\n        EC_KEY_free(evKey);\n        return GM_UTIL_CODE_BIO_DATA_TO_CIPHER_TEXT_FAILED;\n    }\n\n\tif (0 == SM2_do_decrypt(md, cval, NULL, &amp;siz, evKey) || !(buf = OPENSSL_malloc(siz)))\n    {\n        BIO_free(bIn);\n        SM2CiphertextValue_free(cval);\n        EC_KEY_free(evKey);\n\t\treturn GM_UTIL_CODE_SM2_DECRYPT_FAILED;\n\t}\n\n    if (0 == SM2_do_decrypt(md, cval, (unsigned char*)buf, &amp;siz, evKey))\n    {\n        BIO_free(bIn);\n        SM2CiphertextValue_free(cval);\n        OPENSSL_free(buf);\n        EC_KEY_free(evKey);\n        return GM_UTIL_CODE_SM2_DECRYPT_FAILED;\n    }\n    \n    strOut.assign((char*)buf, siz);\n    // 释放内存\n    BIO_free(bIn);\n    SM2CiphertextValue_free(cval);\n\tOPENSSL_free(buf);\n    EC_KEY_free(evKey);\n    return GM_UTIL_CODE_OK;\n}\n\nstatic streamsize Read(istream &amp;stream, char *buffer, streamsize count)\n{\n    streamsize reads = stream.rdbuf()-&gt;sgetn(buffer, count);\n    stream.rdstate();\n    stream.peek();\n    return reads;\n}\n\nstring GmReadKeyFromFile(string strFileName)\n{\n    fstream myfile;\n\tmyfile.open(strFileName, ifstream::in | ifstream::binary);\n\tif (!myfile.is_open())\n    {\n        return \"\";\n    }\n\n    char buff[1024];\n    std::ostringstream oss;\n    int len;\n    while (!myfile.eof())\n    {\n        size_t read = Read(myfile, buff, sizeof(buff));\n        oss &lt;&lt; string(buff, read);\n    }\n\n    myfile.close();\n    return oss.str();\n}\n\nstatic char sDigit1[16] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};\nstatic char sDigit2[16] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};\nstring GmByte2HexStr(const string&amp; data, bool bLowerCase)\n{\n    char *sDigit = sDigit1;\n    if (!bLowerCase)\n    {\n        sDigit = sDigit2;\n    }\n    const char* pData = data.c_str();\n    char cTemp;\n    string strHex;\n    for (unsigned int i = 0; i &lt; data.size(); i++)\n    {\n        cTemp = *pData;\n        pData++;\n        strHex += sDigit[(cTemp &gt;&gt; 4) &amp; 0x0F];\n        strHex += sDigit[cTemp &amp; 0x0F];\n    }\n\n    return strHex;\n}\n\nstring GmHexStr2Byte(const string&amp; hex, bool bLowerCase)\n{\n    if (hex.size() % 2 != 0)\n    {\n        // 十六进制字符串必须是偶数长度\n        return \"\";\n    }\n\n    char chA = 'a';\n    if (!bLowerCase)\n    {\n        chA = 'A';\n    }\n\n    std::ostringstream oss;\n    for (int i = 0; i &lt; hex.size(); i += 2)\n    {\n        unsigned int highBit;\n        if (hex[i] &gt;= '0' &amp;&amp; hex[i] &lt;= '9')\n        {\n            highBit = hex[i] - '0';\n        }\n        else\n        {\n            highBit = hex[i] - chA + 10;\n        }\n        unsigned int lowBit;\n        if (hex[i + 1] &gt;= '0' &amp;&amp; hex[i + 1] &lt;= '9')\n        {\n            lowBit = hex[i + 1] - '0';\n        }\n        else\n        {\n            lowBit = hex[i + 1] - chA + 10;\n        }\n        unsigned char ch = (highBit &lt;&lt; 4) + lowBit; \n        oss &lt;&lt; ch;\n    }\n\n    return oss.str();\n}</code></pre>\n<p>下面是测试验证test.cpp:</p>\n<pre><code class=\"language-cpp\">#include \"gmutil.h\"\n#include &lt;iostream&gt;\n#include &lt;sstream&gt;\n\nint main(int argc, char** argv)\n{\n    string strPriKey = GmReadKeyFromFile(\"sm2_server_private_key.key\");\n    string strPubKey = GmReadKeyFromFile(\"sm2_server_public_key.key\");\n    string strText = \"hello world, this is a test\";\n    string strCipher;\n    string strOut;\n    std::cout &lt;&lt; \"plaintext:\" &lt;&lt; strText &lt;&lt; std::endl;\n    int nRet = GmSm2Encrypt(strPubKey, strText, strCipher);\n    if (GM_UTIL_CODE_OK != nRet)\n    {\n        cout &lt;&lt; \"GmSm2Encrypt fail\" &lt;&lt; endl;\n    }\n    string strCipherTextHex = GmByte2HexStr(strCipher);\n    cout &lt;&lt; \"hex ciper text:\" &lt;&lt; strCipherTextHex &lt;&lt; endl;\n    string strCipher1 = GmHexStr2Byte(strCipherTextHex);\n    if (strCipher1 == strCipher)\n    {\n        cout &lt;&lt; \"conver hex str to byte sucess\" &lt;&lt; endl;\n    }\n    nRet = GmSm2Decrypt(strPriKey, strCipher1, strOut);\n    std::cout &lt;&lt; \"after decrypt:\" &lt;&lt; strOut &lt;&lt; std::endl;\n\n    return 0;\n}</code></pre>\n<p>编译的时候要加这几个关键的编译参数：-fvisibility=hidden -Wl,-Bsymbolic -Wl,--exclude-libs,ALL</p>\n<p>用来屏蔽动态库中的符号的。</p>\n<p>gmssl库相关函数的文档可以参考官网：<a href=\"http://gmssl.org/docs/sm2.html\" title=\"国密SM2椭圆曲线密码标准 (gmssl.org)\">国密SM2椭圆曲线密码标准 (gmssl.org)</a></p>\n<p>还有可以直接参考gmssl源码中的sm2test.c以及sm2utl.c，里面有相关的代码</p>\n<p>还有gmssl库用到openssl库的很多函数比如BIO等，可以参数openssl官网来使用</p>\n<p>参考文章：</p>\n<p><a href=\"https://blog.csdn.net/qq_39952971/article/details/115082906\" title=\"(20条消息) 基于GMSSL的SM2加解密测试_viqjeee的博客-CSDN博客_gmssl sm2\">(20条消息) 基于GMSSL的SM2加解密测试_viqjeee的博客-CSDN博客_gmssl sm2</a></p>\n<p><a href=\"https://blog.csdn.net/qq_19734597/article/details/104060859\" title=\"(20条消息) C语言SM2算法实现（基于GMSSL）_张志翔 ̮的博客-CSDN博客_sm2实现\">(20条消息) C语言SM2算法实现（基于GMSSL）_张志翔 ̮的博客-CSDN博客_sm2实现</a> --这个最详细，直接有完整代码</p>\n<p><a href=\"https://blog.csdn.net/qq_40123036/article/details/118297806\" title=\"(25条消息) SM2算法全套（基于GMSSL）_wincent1的博客-CSDN博客_gmssl sm2算法\">(25条消息) SM2算法全套（基于GMSSL）_wincent1的博客-CSDN博客_gmssl sm2算法</a></p>\n<p></p>\n</div>\n</div>", "first_tag": "C++", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-08-02 15:53:10", "summary": "项目中需要用到加密，在网上搜索了一下相关的库，发现只有和这两个库可以用，于是基于库做了封装，的版本是：搞这个库的确要费不少功夫，现在分享出来给需要的人。目前我是用在环境中，因此编译成动态库，并且屏蔽相"}