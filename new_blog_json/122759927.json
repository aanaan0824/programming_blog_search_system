{"blogid": "122759927", "writerAge": "码龄1年", "writerBlogNum": "124", "writerCollect": "297", "writerComment": "91", "writerFan": "59", "writerGrade": "4级", "writerIntegral": "1547", "writerName": "我行我素，向往自由", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_122759927.jpg", "writerRankTotal": "12570", "writerRankWeekly": "82077", "writerThumb": "173", "writerVisitNum": "85711", "blog_read_count": "18104", "blog_time": "于 2022-01-31 16:05:28 发布", "blog_title": "C++中string如何实现字符串分割函数split()——4种方法", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p>如：</p>\n<pre><code>string str1 = \"This is a test\";\nstring str2 = \"This-is-a-test\";\nstring str2 = \"This+is+a+test\";\n</code></pre>\n<p>我们如何将以上字符串按照某种分隔符（ ,<code>-</code>,<code>+</code>），将其分割成四个子串，其值分别为 “This” “is” “a” “test” 。</p>\n<h1>一、使用<a href=\"https://so.csdn.net/so/search?q=stringstream&amp;spm=1001.2101.3001.7020\" title=\"stringstream\">stringstream</a>流</h1>\n<p>这里我们只需要用到 <code>istringstream</code>（字符串输入流） 构造字符串流，然后从字符串流中<strong>按照一定的格式</strong>读取数据即可。</p>\n<p>通常我们使用 <strong>cin</strong> 从流中读取数据，而我们也可以使用 <strong>getline</strong> 读取，而后者在读取时可以选择接受的数据格式，其函数原型如下：</p>\n<p></p>\n<pre><code>// istream &amp; getline(char* buf, int bufSize);\t// 读到 \\n 为止\nistream &amp; getline(char* buf, int bufSize, char delim); //读到 delim 字符为止\n\t\t\t\t// \\n 或 delim 都不会被读入 buf，但会被从文件输入流缓冲区中取走\n</code></pre>\n<p> 因此，我们可以按照此方式设计一个C++中的string <a href=\"https://so.csdn.net/so/search?q=split&amp;spm=1001.2101.3001.7020\" title=\"split\">split</a>函数。</p>\n<pre><code>void Stringsplit(string str,const const char split)\n{\n\tistringstream iss(str);\t// 输入流\n\tstring token;\t\t\t// 接收缓冲区\n\twhile (getline(iss, token, split))\t// 以split为分隔符\n\t{\n\t\tcout &lt;&lt; token &lt;&lt; endl; // 输出\n\t}\n}\n</code></pre>\n<p>如此，我们就设计出了我们的Stringsplit() 函数。该函数有以下 2 种语法格式</p>\n<pre><code>void Stringsplit(string str,const const char split);\n// 默认将传入的字符串str以split为分隔符进行分割，并将得到的子串打印在屏幕上，无返回值\nvoid Stringsplit(string str, const const char split,vector&lt;string&gt;&amp; rst);\n// 默认将传入的字符串str以split为分隔符进行分割，    不会将子串打印在屏幕上，无返回值\n// \t\t\t\t\t分割的子串将会保存在rst数组中被带出函数。\n</code></pre>\n<p> 以上，我们简单的设计了一种C++中的分割字符串的函数，下面来看一个测试用例：</p>\n<pre><code>int main() {\n\n\tstring str(\"This is a test\");\n\tStringsplit(str, ' ');\t\t// 打印子串\n\t\n\tvector&lt;string&gt; strList;\n\tstring str2(\"This-is-a-test\");\n\tStringsplit(str2, '-', strList);\t// 将子串存放到strList中\n\tfor (auto s : strList)\n\t\tcout &lt;&lt; s &lt;&lt; \" \";\n\tcout &lt;&lt; endl;\n\n\treturn 0;\n}\n</code></pre>\n<pre><code># 输出\nThis\nis\na\ntest\nThis is a test\n</code></pre>\n<h1>二、使用string类提供的find方法与substr方法</h1>\n<p><strong>find函数原型： </strong></p>\n<pre><code>size_type find( const basic_string&amp; str, size_type pos = 0 ) const;\n</code></pre>\n<blockquote>\n<p><strong>参数:</strong><br/> str - 要搜索的 string ， pos - 开始搜索的位置<br/> 返回值<br/> 找到的子串的首字符位置，或若找不到这种子串则为 npos 。</p>\n</blockquote>\n<p><strong>substr函数原型：</strong> </p>\n<pre><code>basic_string substr( size_type pos = 0, size_type count = npos ) const;\n</code></pre>\n<blockquote>\n<p><strong>参数:</strong><br/> pos - 要包含的首个字符的位置 ，count - 子串的长度<br/> 返回值<br/> 含子串 [pos, pos+count) 的 string 。</p>\n</blockquote>\n<p>由以上两个函数我们便可以设计出我们的Stringsplit()来。同时，因为find()函数查找的可以是字符串，因此我们的分隔符可以是单个的字符，也可以是一个字符串。 </p>\n<pre><code>// 使用字符分割\nvoid Stringsplit(const string&amp; str, const char split, vector&lt;string&gt;&amp; res)\n{\n\tif (str == \"\")\t\treturn;\n\t//在字符串末尾也加入分隔符，方便截取最后一段\n\tstring strs = str + split;\n\tsize_t pos = strs.find(split);\n\n\t// 若找不到内容则字符串搜索函数返回 npos\n\twhile (pos != strs.npos)\n\t{\n\t\tstring temp = strs.substr(0, pos);\n\t\tres.push_back(temp);\n\t\t//去掉已分割的字符串,在剩下的字符串中进行分割\n\t\tstrs = strs.substr(pos + 1, strs.size());\n\t\tpos = strs.find(split);\n\t}\n}\n// 使用字符串分割\nvoid Stringsplit(const string&amp; str, const string&amp; splits, vector&lt;string&gt;&amp; res)\n{\n\tif (str == \"\")\t\treturn;\n\t//在字符串末尾也加入分隔符，方便截取最后一段\n\tstring strs = str + splits;\n\tsize_t pos = strs.find(splits);\n\tint step = splits.size();\n\n\t// 若找不到内容则字符串搜索函数返回 npos\n\twhile (pos != strs.npos)\n\t{\n\t\tstring temp = strs.substr(0, pos);\n\t\tres.push_back(temp);\n\t\t//去掉已分割的字符串,在剩下的字符串中进行分割\n\t\tstrs = strs.substr(pos + step, strs.size());\n\t\tpos = strs.find(splits);\n\t}\n}\n</code></pre>\n<p>下面是一个测试用例：</p>\n<pre><code>int main()\n{\n\tvector&lt;string&gt; strList;\n\tstring str(\"This-is-a-test\");\n\tStringsplit(str, '-', strList);\n\tfor (auto s : strList)\n\t\tcout &lt;&lt; s &lt;&lt; \" \";\n\tcout &lt;&lt; endl;\n\n\tvector&lt;string&gt; strList2;\n\tstring str2(\"This%20is%20a%20test\");\n\tStringsplit(str2, \"%20\", strList2);\n\tfor (auto s : strList2)\n\t\tcout &lt;&lt; s &lt;&lt; \" \";\n\tcout &lt;&lt; endl;\n\treturn 0;\n}\n</code></pre>\n<pre><code># 输出\nThis is a test\nThis is a test\n</code></pre>\n<h1>三、使用C库函数strtok</h1>\n<pre><code>char* strtok( char* str, const char* delim );\n</code></pre>\n<blockquote>\n<p><strong>参数:</strong><br/> str - 指向要记号化的空终止字节字符串的指针<br/> delim - 指向标识分隔符的空终止字节字符串的指针<br/><strong>返回值:</strong><br/> 指向下个记号起始的指针，或若无更多记号则为空指针。</p>\n</blockquote>\n<p>需要注意的是，该函数使用一个全局的静态变量来保存每次分割后的位置，因此在多线程中是不安全的，这里我们也可以选择使用它的线程安全版本</p>\n<pre><code> char *strtok_r(char *str, const char *delim, char **saveptr); 。</code></pre>\n<pre><code>void Stringsplit(const string&amp; str, const string&amp; split, vector&lt;string&gt;&amp; res)\n{\n\tchar* strc = new char[str.size() + 1];\n\tstrcpy(strc, str.c_str());   // 将str拷贝到 char类型的strc中\n\tchar* temp = strtok(strc, split.c_str());\n\twhile (temp != NULL)\n\t{\n\t\tres.push_back(string(temp));\t\t\n\t\ttemp = strtok(NULL, split.c_str());\t// 下一个被分割的串\n\t}\n\tdelete[] strc;\n}\n</code></pre>\n<p>如此，我们的使用 strtok 版本的Stringsplit() 就完成了。不过，我们使用这种方法实现的字符串分割函数只能根据字符来分割，而我们传入的参数是字符串类型，这样可能会对函数的使用这造成误导（注：参数传入字符串用的双引号，传入字符用的单引号），因此我们也可以使用下面的方法封装一个参数是字符类型的函数。</p>\n<pre><code>void Stringsplit(const string&amp; str, const char split, vector&lt;string&gt;&amp; res)\n{\n\tStringsplit(str, string(1,split), res);\t// 调用上一个版本的Stringsplit()\n}\n</code></pre>\n<p> 下面给出一个测试用例，我们分别使用单/双引号传入分割的限定字符。</p>\n<pre><code>int main()\n{\n\tvector&lt;string&gt; strList;\n\tstring str(\"This+is+a+test\");\n\tStringsplit(str, '+', strList);\n\tfor (auto s : strList)\n\t\tcout &lt;&lt; s &lt;&lt; \" \";\n\tcout &lt;&lt; endl;\n\n\tvector&lt;string&gt; strList2;\n\tstring str2(\"This-is-a-test\");\n\tStringsplit(str2, \"-\", strList2);\n\tfor (auto s : strList2)\n\t\tcout &lt;&lt; s &lt;&lt; \" \";\n\tcout &lt;&lt; endl;\n\n\n\treturn 0;\n}\n</code></pre>\n<h1>四、使用regex_token_iterator（正则表达式）</h1>\n<blockquote>\n<p>正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。 </p>\n</blockquote>\n<p>而在C++的正则中，把这种操作称为Tokenize分词（或者叫切割）。这种操作刚好可以满足我们的需求，用模板类regex_token_iterator&lt;&gt;提供分词迭代器，可以完成字符串的分割。</p>\n<pre><code>void Stringsplit(const string&amp; str, const string&amp; split, vector&lt;string&gt;&amp; res)\n{\n\t//std::regex ws_re(\"\\\\s+\"); // 正则表达式,匹配空格 \n\tstd::regex reg(split);\t\t// 匹配split\n\tstd::sregex_token_iterator pos(str.begin(), str.end(), reg, -1);\n\tdecltype(pos) end;              // 自动推导类型 \n\tfor (; pos != end; ++pos)\n\t{\n\t\tres.push_back(pos-&gt;str());\n\t}\n}\n</code></pre>\n<p><strong>测试用例：</strong></p>\n<pre><code>int main()\n{\n\t// 单个字符分词\n\tvector&lt;string&gt; strList;\n\tstring str(\"This is a test\");\n\tStringsplit(str,\" \", strList);\n\tfor (auto s : strList)\n\t\tcout &lt;&lt; s &lt;&lt; \" \";\n\tcout &lt;&lt; endl;\n\n\t// 使用字符串分词\n\tvector&lt;string&gt; strList2;\n\tstring str2(\"ThisABCisABCaABCtest\");\n\tStringsplit(str2, \"ABC\", strList2);\n\tfor (auto s : strList2)\n\t\tcout &lt;&lt; s &lt;&lt; \" \";\n\tcout &lt;&lt; endl;\n}\n</code></pre>\n<pre><code># 输出\nThis is a test\nThis is a test\n</code></pre>\n<p> </p>\n</div>\n</div>", "first_tag": "C++", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-01-31 16:05:28", "summary": "如：我们如何将以上字符串按照某种分隔符，将其分割成四个子串，其值分别为。一、使用流这里我们只需要用到字符串输入流构造字符串流，然后从字符串流中按照一定的格式读取数据即可。通常我们使用从流中读取数据，而"}