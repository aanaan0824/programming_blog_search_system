{"blogid": "125638414", "writerAge": "码龄1年", "writerBlogNum": "202", "writerCollect": "7515", "writerComment": "4756", "writerFan": "74190", "writerGrade": "7级", "writerIntegral": "12182", "writerName": "步尔斯特", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_125638414.jpg", "writerRankTotal": "921", "writerRankWeekly": "259", "writerThumb": "4208", "writerVisitNum": "471328", "blog_read_count": "1971", "blog_time": "已于 2022-07-08 23:02:38 修改", "blog_title": "CAS自旋锁，看这一篇就够了", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"markdown_views prism-atelier-sulphurpool-light\" id=\"content_views\">\n<svg style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" stroke-linecap=\"round\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n</svg>\n<p><code>前序</code></p>\n<p>时隔多年，杰伦终于出了新专辑，《最伟大的作品》让我们穿越到1920年，见到了马格利特的绿苹果、大利的超现实、常玉画的大腿、莫奈的睡莲、徐志摩的诗…</p>\n<p>他说“最伟大的作品”并不是自己的歌，而是这个世界上最伟大的艺术作品们。</p>\n<p>为什么要写CAS自旋锁呢？最近看了一下Java实现随机数的几种方式，研究研究就研究到量子力学去了，所以还是回归代码上来，看了看底层实现都是用的CAS，正好又赶上周董发歌，就凑个巧吧～</p>\n<p>大家给我这几个免费的专栏点点订阅【后期会变成付费专栏】，听我说谢谢你，因为有你，温暖了四季～</p>\n<p><a href=\"https://blog.csdn.net/csdn_savior/category_11830903.html\">《Java系核心技术》</a><a href=\"https://blog.csdn.net/csdn_savior/category_11830904.html\">《中间件核心技术》</a><br/> <a href=\"https://blog.csdn.net/csdn_savior/category_11830911.html\">《微服务核心技术》</a><a href=\"https://blog.csdn.net/csdn_savior/category_11743977.html\">《云原生核心技术》</a></p>\n<hr/>\n<p></p>\n<div class=\"toc\">\n<h3>文章目录</h3>\n<ul><li><a href=\"#CAS_19\">CAS核心原理</a></li><li><a href=\"#ii_29\">i++和++i是原子操作么</a></li><li><a href=\"#i__43\">++i 如何实现原子性</a></li><li><a href=\"#JavaC_112\">如何用Java调用C++</a></li><li><a href=\"#JNI_220\">JNI命名规范</a></li><li><a href=\"#compareAndSwarpInt_238\">compareAndSwarpInt源码分析</a></li><li><a href=\"#CAS_256\">CAS缺点</a></li></ul>\n</div>\n<p></p>\n<h1><a id=\"CAS_19\"></a>CAS核心原理</h1>\n<p>CAS即Compare and Swap，翻译成比较并交换。</p>\n<p>CAS是一种乐观锁，所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。</p>\n<p>【至于其他的各种锁，我们下一篇再谈论，本篇主要讲解CAS】</p>\n<p>CAS 操作包含三个操作数 —— 内存位置V、预期原值A和新值B。</p>\n<p>如果内存位置的值与预期原值相匹配，那么处理器会自动将该内存位置值更新为新值 ，否则，处理器不做任何操作。</p>\n<h1><a id=\"ii_29\"></a>i++和++i是原子操作么</h1>\n<p>先说答案：不是。</p>\n<p>反编译成字节码文件就很容易看出来此非原子性操作，先是getfield，然后再iadd。</p>\n<blockquote>\n<p>i++大体分为三步：</p>\n<ol><li>栈中取出i</li><li>i自增1</li><li>将i存到栈</li></ol>\n</blockquote>\n<blockquote>\n<p>++i</p>\n<p>在多核的机器上，cpu在读取内存i时也会可能发生同时读取到同一值，这就导致两次自增，实际只增加了一次。</p>\n</blockquote>\n<h1><a id=\"i__43\"></a>++i 如何实现原子性</h1>\n<p><strong>【<code>++i</code>是如何实现原子性】</strong></p>\n<p>代码实现</p>\n<pre><code class=\"prism language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> <span class=\"token function\">incrementAndGet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token comment\">// 死循环</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    \t<span class=\"token comment\">// 预期原值（A）</span>\n        <span class=\"token keyword\">int</span> current <span class=\"token operator\">=</span> <span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// 新值(B)</span>\n        <span class=\"token keyword\">int</span> next <span class=\"token operator\">=</span> current <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// CAS操作</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">compareAndSet</span><span class=\"token punctuation\">(</span>current<span class=\"token punctuation\">,</span> next<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        \t<span class=\"token comment\">// 成功则返回结果</span>\n            <span class=\"token keyword\">return</span> next<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>这里采用了CAS操作，每次从内存中读取数据然后将此数据和+1后的结果进行CAS操作，如果成功就返回结果，否则重试直到成功为止。</p>\n<p>#compareAndSet利用JNI来完成CPU指令的操作</p>\n<pre><code class=\"prism language-java\"><span class=\"token comment\">/**\n * Atomically sets the value to the given updated value\n * if the current value {@code ==} the expected value.\n *\n * @param expect the expected value\n * @param update the new value\n * @return {@code true} if successful. False return indicates that\n * the actual value was not equal to the expected value.\n */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">compareAndSet</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> expect<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> update<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n    <span class=\"token keyword\">return</span> unsafe<span class=\"token punctuation\">.</span><span class=\"token function\">compareAndSwapInt</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> valueOffset<span class=\"token punctuation\">,</span> expect<span class=\"token punctuation\">,</span> update<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>深入到#compareAndSwapInt方法，你会发现它是通过JNI方法实现的</p>\n<pre><code class=\"prism language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">native</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">compareAndSwapInt</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> var1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">long</span> var2<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> var4<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> var5<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>这个方法到底做了什么事呢？应该做了两件事情。</p>\n<ol><li>当前内存位置V是否等于预期原值A</li><li>如果等于就将内存位置V更新为新值B，反正返回false</li></ol>\n<p>为了更清晰、直观的说明这里存在的问题，我们用代码说明。</p>\n<pre><code class=\"prism language-java\"><span class=\"token comment\">// 1.当前内存位置V是否等于预期原值A</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">V</span> <span class=\"token operator\">==</span> <span class=\"token class-name\">A</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token comment\">// 2.如果等于就将内存位置V更新为新值B</span>\n    <span class=\"token class-name\">V</span> <span class=\"token operator\">=</span> <span class=\"token class-name\">B</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{<!-- --></span>\n\t<span class=\"token comment\">// 反正返回false</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>这里存在一个问题，如何保证步骤1和步骤2的原子性呢？</p>\n<p>那么，我们接下来的问题，就要探究一下compareAndSwapInt的实现了。</p>\n<p>上面我们提到，CAS是通过调用JNI的代码实现的。</p>\n<p>JNI:Java Native Interface为JAVA本地调用，允许java调用其他语言，JNI方法最终会通过 Jni.dvmCallJNIMethod() -&gt; dvmPlatformInvoke() 来根据不同cpu架构实现进行调用，具体如何使用，我们下一篇再聊。</p>\n<h1><a id=\"JavaC_112\"></a>如何用Java调用C++</h1>\n<p>算了，我就先给大家写一个小demo，让大家先简单的了解一下如何使用Java调用其他语言。</p>\n<p><strong>第一步：</strong></p>\n<p>写一个测试类</p>\n<pre><code class=\"prism language-java\"><span class=\"token keyword\">package</span> <span class=\"token namespace\">com<span class=\"token punctuation\">.</span>ossa<span class=\"token punctuation\">.</span>producer<span class=\"token punctuation\">.</span>jni</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">/**\n * JNI测试类\n *\n * @author issavior\n */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">JniUnit</span> <span class=\"token punctuation\">{<!-- --></span>\n\n    <span class=\"token comment\">/**\n     * 调用本地方法\n     */</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">native</span> <span class=\"token keyword\">void</span> <span class=\"token function\">sayHello</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">/**\n     * 静态块用来加载库，jni.so需要我们手动生成，放在该路径下\n     */</span>\n    <span class=\"token keyword\">static</span> <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span><span class=\"token function\">load</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/Users/issavior/java/mygit/ossa/ossa-service-producer/src/main/resources/jni.so\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\">/**\n     * 程序入口\n     *\n     * @param args 参数\n     */</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token keyword\">new</span> <span class=\"token class-name\">JniUnit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">sayHello</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p><strong>第二步：</strong></p>\n<p>如果是Maven项目，可以通过mvn命令来编译该Java文件，如果不是，就用javac编译即可，我这里采用mavan方式。</p>\n<p><strong>第三步：</strong></p>\n<p>在<code>class</code>路径下，执行javah命令</p>\n<blockquote>\n<p>issavior@issavior classes % <code>javah com.ossa.producer.jni.JniUnit</code></p>\n</blockquote>\n<p>之后会生成jni头文件<code>com_ossa_producer_jni_JniUnit.h</code>：</p>\n<pre><code class=\"prism language-java\"><span class=\"token comment\">/* DO NOT EDIT THIS FILE - it is machine generated */</span>\n#include <span class=\"token string\">\"jni.h\"</span>\n<span class=\"token comment\">/* Header for class com_ossa_producer_jni_JniUnit */</span>\n\n#ifndef _Included_com_ossa_producer_jni_JniUnit\n#define _Included_com_ossa_producer_jni_JniUnit\n#ifdef __cplusplus\nextern <span class=\"token string\">\"C\"</span> <span class=\"token punctuation\">{<!-- --></span>\n#endif\n<span class=\"token comment\">/*\n * Class:     com_ossa_producer_jni_JniUnit\n * Method:    sayHello\n * Signature: ()I\n */</span>\nJNIEXPORT <span class=\"token keyword\">void</span> JNICALL <span class=\"token class-name\">Java_com_ossa_producer_jni_JniUnit_sayHello</span>\n  <span class=\"token punctuation\">(</span><span class=\"token class-name\">JNIEnv</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">,</span> jobject<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n#ifdef __cplusplus\n<span class=\"token punctuation\">}</span>\n#endif\n#endif\n</code></pre>\n<p><strong>第四步：</strong></p>\n<p>编写实现的c文件jniUnit.c，引入刚才生成的头文件和方法实现</p>\n<pre><code class=\"prism language-java\">#include <span class=\"token string\">\"com_ossa_producer_jni_JniUnit.h\"</span>\nJNIEXPORT <span class=\"token keyword\">void</span> JNICALL <span class=\"token class-name\">Java_com_ossa_producer_jni_JniUnit_sayHello</span>\n  <span class=\"token punctuation\">(</span><span class=\"token class-name\">JNIEnv</span> <span class=\"token operator\">*</span> env<span class=\"token punctuation\">,</span> jobject obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{<!-- --></span>\n   <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello JNI\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n</code></pre>\n<p>从你的<code>$JAVA_HOME/include/ </code>目录和<code>$JAVA_HOME/include/darwin/</code>目录下分别找到<code>jni.h</code>和 <code>jni_md.h</code>头复制到当前目录【mac的话，首先需要<code>shift</code>+<code>command</code>+<code>.</code>打开隐藏文件】</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\ec9107d4e0e54fec8dd621f361440abb.png\" width=\"500\"/><br/> 执行 <code>gcc -shared -fPIC -o jni.so jniUnit.c</code> 进行编译生成动态库</p>\n<p>如果此时报如下错误</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\55e3e36080b742e18a69e891e2b0ff4b.png\" width=\"800\"/><br/> 就将<code>com_ossa_producer_jni_JniUnit.h</code>文件中<code>#include &lt;jni.h&gt;</code>修改为<code>#include \"jni.h\"</code></p>\n<p>编译成功后当前目录会出现<code>jni.so</code>文件，放置到指定的目录下即可。</p>\n<p>最后测试我们的JniUnit类，成功！</p>\n<p><img alt=\"在这里插入图片描述\" src=\"..\\..\\static\\image\\64a84036fce94d729f64e5a873b0a513.png\" width=\"800\"/></p>\n<p>到此，我已经亲手带大家完成了Java调用其他语言的小案例，这样大家是不是对native方法有了更深的了解，而compareAndSwapInt就是借助C来调用CPU底层的指令（cmpxchg）来实现的。</p>\n<p>cmpxchg是一个原子指令，这个指令是给数据总线进行加锁，所以是线程安全的。</p>\n<p>那我们就来分析一下它的源码吧，那么如何找到本地方法实现的位置呢？</p>\n<h1><a id=\"JNI_220\"></a>JNI命名规范</h1>\n<p>通过上面的案例，我们可以知道javah可以帮助我们生成头文件，那么大家就会发现native方法的本地方法名是遵循一定的规则生成的。因此可以先生成对应的本地方法名，然后再到源码中搜索。</p>\n<blockquote>\n<p>根据 JNI 的本地方法名生成规范：</p>\n<ul><li>前缀为 Java_</li><li>完全限定的类名（包括包名和类的全路径），中间以 _ 分割</li><li>方法名</li><li>对于重载的 native 方法，方法名后要再跟上 __ 和参数标签</li></ul>\n</blockquote>\n<blockquote>\n<p>我们可以推断出 intern 方法的本地方法名：</p>\n<ul><li>以 Java_ 开头</li><li>包名转换后为 java_lang_String</li><li>方法名为 intern</li><li>拼接后结果为 Java_sun_misc_Unsafe_compareAndSwapInt</li></ul>\n</blockquote>\n<h1><a id=\"compareAndSwarpInt_238\"></a>compareAndSwarpInt源码分析</h1>\n<p>在unsafe.cpp文件中，可以找到compareAndSwarpInt的实现：</p>\n<pre><code class=\"prism language-cpp\"><span class=\"token function\">UNSAFE_ENTRY</span><span class=\"token punctuation\">(</span>jboolean<span class=\"token punctuation\">,</span> <span class=\"token function\">Unsafe_CompareAndSwapInt</span><span class=\"token punctuation\">(</span>JNIEnv <span class=\"token operator\">*</span>env<span class=\"token punctuation\">,</span> jobject unsafe<span class=\"token punctuation\">,</span> jobject obj<span class=\"token punctuation\">,</span> jlong offset<span class=\"token punctuation\">,</span> jint e<span class=\"token punctuation\">,</span> jint x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> \n \n\t<span class=\"token function\">UnsafeWrapper</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Unsafe_CompareAndSwapInt\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n    <span class=\"token comment\">// 将Java对象解析成JVM的oop（普通对象指针）</span>\n\toop p <span class=\"token operator\">=</span> <span class=\"token class-name\">JNIHandles</span><span class=\"token double-colon punctuation\">::</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n \t<span class=\"token comment\">// 根据对象p和地址偏移量找到地址 </span>\n\tjint<span class=\"token operator\">*</span> addr <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>jint <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token function\">index_oop_from_field_offset_long</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">,</span> offset<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n \t<span class=\"token comment\">// //基于cas比较并替换， x表示需要更新的值，addr表示state在内存中的地址，e表示预期值 </span>\n\t<span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>jint<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Atomic</span><span class=\"token double-colon punctuation\">::</span><span class=\"token function\">cmpxchg</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> addr<span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> e<span class=\"token punctuation\">;</span> \n\n\tUNSAFE_END\n</code></pre>\n<h1><a id=\"CAS_256\"></a>CAS缺点</h1>\n<p>CAS虽然很高效的解决原子操作，但是CAS仍然存在三大问题。<br/> <strong><code>ABA问题</code></strong></p>\n<p>如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。</p>\n<p>ABA问题的解决思路就是使用版本号。</p>\n<p>在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。</p>\n<p>从Java1.5开始JDK的atomic包里提供了一个类<code>AtomicStampedReference</code>来解决ABA问题。这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p>\n<pre><code class=\"prism language-java\"><span class=\"token comment\">// 静态内部类，封装了 变量引用 和 版本号</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Pair</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">&gt;</span></span> <span class=\"token punctuation\">{<!-- --></span>\n        <span class=\"token keyword\">final</span> <span class=\"token class-name\">T</span> reference<span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 变量引用</span>\n        <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> stamp<span class=\"token punctuation\">;</span>    <span class=\"token comment\">// 版本号</span>\n        <span class=\"token keyword\">private</span> <span class=\"token class-name\">Pair</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">T</span> reference<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> stamp<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>reference <span class=\"token operator\">=</span> reference<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>stamp <span class=\"token operator\">=</span> stamp<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">static</span> <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">&gt;</span></span> <span class=\"token class-name\">Pair</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">&gt;</span></span> <span class=\"token function\">of</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">T</span> reference<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> stamp<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n            <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Pair</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">&gt;</span></span><span class=\"token punctuation\">(</span>reference<span class=\"token punctuation\">,</span> stamp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n \n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">volatile</span> <span class=\"token class-name\">Pair</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">V</span><span class=\"token punctuation\">&gt;</span></span> pair<span class=\"token punctuation\">;</span>\n \n    <span class=\"token comment\">/**\n     *\n     * @param initialRef  初始变量引用\n     * @param initialStamp  版本号\n     */</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">AtomicStampedReference</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">V</span> initialRef<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> initialStamp<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n        pair <span class=\"token operator\">=</span> <span class=\"token class-name\">Pair</span><span class=\"token punctuation\">.</span><span class=\"token function\">of</span><span class=\"token punctuation\">(</span>initialRef<span class=\"token punctuation\">,</span> initialStamp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n<p>常用方法</p>\n<pre><code class=\"prism language-java\"><span class=\"token comment\">// 构造函数，初始化引用和版本号</span>\n<span class=\"token keyword\">public</span> <span class=\"token class-name\">AtomicStampedReference</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">V</span> initialRef<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> initialStamp<span class=\"token punctuation\">)</span>\n \n<span class=\"token comment\">// 以原子方式获取当前引用值</span>\n<span class=\"token keyword\">public</span> <span class=\"token class-name\">V</span> <span class=\"token function\">getReference</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n \n<span class=\"token comment\">// 以原子方式获取当前版本号</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">getStamp</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n \n<span class=\"token comment\">// 以原子方式获取当前引用值和版本号</span>\n<span class=\"token keyword\">public</span> <span class=\"token class-name\">V</span> <span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> stampHolder<span class=\"token punctuation\">)</span>\n \n<span class=\"token comment\">// 以原子的方式同时更新引用值和版本号</span>\n<span class=\"token comment\">// 当期望引用值不等于当前引用值时，操作失败，返回false</span>\n<span class=\"token comment\">// 当期望版本号不等于当前版本号时，操作失败，返回false</span>\n<span class=\"token comment\">// 在期望引用值和期望版本号同时等于当前值的前提下</span>\n<span class=\"token comment\">// 当新的引用值和新的版本号同时等于当前值时，不更新，直接返回true</span>\n<span class=\"token comment\">// 当新的引用值和新的版本号不同时等于当前值时，同时设置新的引用值和新的版本号，返回true</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">weakCompareAndSet</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">V</span>  expectedReference<span class=\"token punctuation\">,</span>\n                                 <span class=\"token class-name\">V</span>  newReference<span class=\"token punctuation\">,</span>\n                                 <span class=\"token keyword\">int</span> expectedStamp<span class=\"token punctuation\">,</span>\n                                 <span class=\"token keyword\">int</span> newStamp<span class=\"token punctuation\">)</span>\n \n<span class=\"token comment\">// 以原子的方式同时更新引用值和版本号</span>\n<span class=\"token comment\">// 当期望引用值不等于当前引用值时，操作失败，返回false</span>\n<span class=\"token comment\">// 当期望版本号不等于当前版本号时，操作失败，返回false</span>\n<span class=\"token comment\">// 在期望引用值和期望版本号同时等于当前值的前提下</span>\n<span class=\"token comment\">// 当新的引用值和新的版本号同时等于当前值时，不更新，直接返回true</span>\n<span class=\"token comment\">// 当新的引用值和新的版本号不同时等于当前值时，同时设置新的引用值和新的版本号，返回true</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">compareAndSet</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">V</span>   expectedReference<span class=\"token punctuation\">,</span>\n                             <span class=\"token class-name\">V</span>   newReference<span class=\"token punctuation\">,</span>\n                             <span class=\"token keyword\">int</span> expectedStamp<span class=\"token punctuation\">,</span>\n                             <span class=\"token keyword\">int</span> newStamp<span class=\"token punctuation\">)</span>\n \n<span class=\"token comment\">// 以原子方式设置引用的当前值为新值newReference</span>\n<span class=\"token comment\">// 同时，以原子方式设置版本号的当前值为新值newStamp</span>\n<span class=\"token comment\">// 新引用值和新版本号只要有一个跟当前值不一样，就进行更新</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">set</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">V</span> newReference<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> newStamp<span class=\"token punctuation\">)</span>\n \n<span class=\"token comment\">// 以原子方式设置版本号为新的值</span>\n<span class=\"token comment\">// 前提：引用值保持不变</span>\n<span class=\"token comment\">// 当期望的引用值与当前引用值不相同时，操作失败，返回fasle</span>\n<span class=\"token comment\">// 当期望的引用值与当前引用值相同时，操作成功，返回true</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">attemptStamp</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">V</span> expectedReference<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> newStamp<span class=\"token punctuation\">)</span>\n \n<span class=\"token comment\">// 使用`sun.misc.Unsafe`类原子地交换两个对象</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">casPair</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Pair</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">V</span><span class=\"token punctuation\">&gt;</span></span> cmp<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Pair</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">V</span><span class=\"token punctuation\">&gt;</span></span> val<span class=\"token punctuation\">)</span>\n</code></pre>\n<p><strong>案例</strong></p>\n<p>如果线程安全</p>\n<pre><code class=\"prism language-java\">    <span class=\"token comment\">/**\n     * 程序入口\n     *\n     * @param args 参数\n     */</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n\n        <span class=\"token comment\">// 初始引用值是【1】；版本号是【1】</span>\n        <span class=\"token class-name\">AtomicStampedReference</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">&gt;</span></span> reference <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">AtomicStampedReference</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">&gt;</span></span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">Integer</span> reference1 <span class=\"token operator\">=</span> reference<span class=\"token punctuation\">.</span><span class=\"token function\">getReference</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"初始引用值\"</span> <span class=\"token operator\">+</span> reference1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 初始引用值1</span>\n\n        <span class=\"token comment\">// 期望的初始引用值是【1】；</span>\n        <span class=\"token comment\">// 更新引用为2；</span>\n        <span class=\"token comment\">// 期望的初始版本号是【1】；</span>\n        <span class=\"token comment\">// 更新版本号为2</span>\n        <span class=\"token keyword\">boolean</span> b <span class=\"token operator\">=</span> reference<span class=\"token punctuation\">.</span><span class=\"token function\">weakCompareAndSet</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\">// 是否swap成功</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\n        <span class=\"token comment\">// 再次获取引用值</span>\n        <span class=\"token class-name\">Integer</span> reference2 <span class=\"token operator\">=</span> reference<span class=\"token punctuation\">.</span><span class=\"token function\">getReference</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"最新引用值\"</span> <span class=\"token operator\">+</span> reference2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 最新引用值2</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n<p>如果线程不安全</p>\n<pre><code class=\"prism language-java\">    <span class=\"token comment\">/**\n     * 程序入口\n     *\n     * @param args 参数\n     */</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{<!-- --></span>\n\n        <span class=\"token comment\">// 初始引用值是【1】；版本号是【1】</span>\n        <span class=\"token class-name\">AtomicStampedReference</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">&gt;</span></span> reference <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">AtomicStampedReference</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">&gt;</span></span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">Integer</span> reference1 <span class=\"token operator\">=</span> reference<span class=\"token punctuation\">.</span><span class=\"token function\">getReference</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"初始引用值\"</span> <span class=\"token operator\">+</span> reference1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 初始引用值1</span>\n\n        <span class=\"token comment\">// 此时线程不安全，期望的引用值是【2】；</span>\n        <span class=\"token comment\">// 更新引用为2；</span>\n        <span class=\"token comment\">// 此时线程不安全，期望的版本号是【2】；</span>\n        <span class=\"token comment\">// 更新版本号为2</span>\n        <span class=\"token keyword\">boolean</span> b <span class=\"token operator\">=</span> reference<span class=\"token punctuation\">.</span><span class=\"token function\">weakCompareAndSet</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\">// 是否swap成功</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// false</span>\n        <span class=\"token comment\">// 再次获取引用值</span>\n        <span class=\"token class-name\">Integer</span> reference2 <span class=\"token operator\">=</span> reference<span class=\"token punctuation\">.</span><span class=\"token function\">getReference</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"最新引用值\"</span> <span class=\"token operator\">+</span> reference2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 最新引用值1</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n<p><strong><code>循环时间长开销大</code></strong></p>\n<p>如果CAS不成功，则会原地自旋，如果长时间自旋会给CPU带来非常大且没必要的开销。</p>\n<p>可以破坏掉for死循环，当超过一定时间或者一定次数时，return退出。</p>\n<p>JDK8新增的LongAdder和ConcurrentHashMap类似的方法。</p>\n<p>当多个线程竞争时，将粒度变小，将一个变量拆分为多个变量，达到多个线程访问多个资源的效果，最后再调用sum把它合起来。</p>\n<p>虽然base和cells都是volatile修饰的，但这个sum操作没有加锁，可能sum的结果不是那么精确。</p>\n<p><strong><code>只能保证一个共享变量的原子操作</code></strong></p>\n<p>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。</p>\n<p>比如有两个共享变量i＝2，j=a，合并一下ij=2a，然后用CAS来操作ij。从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。</p>\n<p>AtomicReference的API</p>\n<pre><code class=\"prism language-java\"><span class=\"token comment\">// 当使用无参构造函数创建AtomicReference对象的时候，</span>\n<span class=\"token comment\">// 需要再次调用set()方法为AtomicReference内部的value指定初始值。</span>\n<span class=\"token class-name\">AtomicReference</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 创建AtomicReference对象时顺便指定初始值。</span>\n<span class=\"token class-name\">AtomicReference</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">V</span> initialValue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">/**\n原子性地更新AtomicReference内部的value值，\n其中expect代表当前AtomicReference的value值，update则是需要设置的新引用值。\n该方法会返回一个boolean的结果，\n当expect和AtomicReference的当前值不相等时，修改会失败，返回值为false，\n若修改成功则会返回true。\n**/</span>\n<span class=\"token function\">compareAndSet</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">V</span> expect<span class=\"token punctuation\">,</span> <span class=\"token class-name\">V</span> update<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 原子性地更新AtomicReference内部的value值，并且返回AtomicReference的旧值。</span>\n<span class=\"token function\">getAndSet</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">V</span> newValue<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 原子性地更新value值，并且返回AtomicReference的旧值，该方法需要传入一个Function接口。</span>\n<span class=\"token function\">getAndUpdate</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">UnaryOperator</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">V</span><span class=\"token punctuation\">&gt;</span></span> updateFunction<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 原子性地更新value值，并且返回AtomicReference更新后的新值，该方法需要传入一个Function接口。</span>\n<span class=\"token function\">updateAndGet</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">UnaryOperator</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">V</span><span class=\"token punctuation\">&gt;</span></span> updateFunction<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 原子性地更新value值，并且返回AtomicReference更新前的旧值。</span>\n<span class=\"token comment\">// 该方法需要传入两个参数，第一个是更新后的新值，第二个是BinaryOperator接口。</span>\n<span class=\"token function\">getAndAccumulate</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">V</span> x<span class=\"token punctuation\">,</span> <span class=\"token class-name\">BinaryOperator</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">V</span><span class=\"token punctuation\">&gt;</span></span> accumulatorFunction<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 原子性地更新value值，并且返回AtomicReference更新后的值。</span>\n<span class=\"token comment\">// 该方法需要传入两个参数，第一个是更新的新值，第二个是BinaryOperator接口。</span>\n<span class=\"token function\">accumulateAndGet</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">V</span> x<span class=\"token punctuation\">,</span> <span class=\"token class-name\">BinaryOperator</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">V</span><span class=\"token punctuation\">&gt;</span></span> accumulatorFunction<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 获取AtomicReference的当前对象引用值。</span>\n<span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 设置AtomicReference最新的对象引用值，该新值的更新对其他线程立即可见。</span>\n<span class=\"token function\">set</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">V</span> newValue<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 设置AtomicReference的对象引用值。</span>\n<span class=\"token function\">lazySet</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">V</span> newValue<span class=\"token punctuation\">)</span>\n\n</code></pre>\n</div>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css\" rel=\"stylesheet\"/>\n<link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css\" rel=\"stylesheet\"/>\n</div>", "first_tag": "Java", "cpp": 1, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2022-07-08 23:02:38", "summary": "前序时隔多年，杰伦终于出了新专辑，《最伟大的作品》让我们穿越到年，见到了马格利特的绿苹果、大利的超现实、常玉画的大腿、莫奈的睡莲、徐志摩的诗他说最伟大的作品并不是自己的歌，而是这个世界上最伟大的艺术作"}