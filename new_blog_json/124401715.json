{"blogid": "124401715", "writerAge": "码龄5年", "writerBlogNum": "8", "writerCollect": "4", "writerComment": "1", "writerFan": "0", "writerGrade": "1级", "writerIntegral": "90", "writerName": "雨太阳呀呀", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_124401715.jpg", "writerRankTotal": "149269", "writerRankWeekly": "353213", "writerThumb": "1", "writerVisitNum": "3614", "blog_read_count": "920", "blog_time": "于 2022-04-25 11:57:24 发布", "blog_title": ".Net Core AutoFac 使用方法讲解大全,具体详细使用知识总结", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<ul><li> <h3 id=\"autofac-具体使用知识总结\">AutoFac 具体使用知识总结</h3> </li><li> <p>阅读前提示 AutoFac 只是众多IOC框架的其中一种, 比较主流的有<code>Unity</code>、<code>autofac</code>、<code>spring.net</code>、<code>MEF</code>、<code>Injection</code>、<code>Asp.Net Core</code>的<code>ServiceCollection</code>，等一些,还有一些,可能自己实现这一套东西。</p> </li></ul>\n<p>1.为什么使用AutoFac? (自己的理解综合所链接的因素)</p>\n<ol><li>传说是速度最快的一个,轻量级性能高</li><li>C#语言联系很紧密,许多框架如Abp都会有默认支持AutoFac,微软的Orchad开源程序使用的就是Autofac</li><li>支持很多的注入方式,除了传统的 构造函数注入,DI容器注入(使用 <code>IServiceProvider</code> 接口的对象) 如方法注入,属性注入,控制器注入 这些特殊的方式<br/> 2.缺点</li><li>传说没有微软自带的 依赖注入 速度快</li></ol>\n<p>AutoFac 几种依赖注入使用方法介绍</p>\n<ol><li> <p>演示绝大部分都是在 Startup.cs 里面进行的,也有一个测试的控制器<code>TestController</code>,重在理解,以下是自己研究的项目源码GitHub地址:</p>\n<ul><li> <p><a href=\"https://github.com/goodluckily/WebApi-AutoFac\" title=\"GitHub - goodluckily/WebApi-AutoFac\">GitHub - goodluckily/WebApi-AutoFac</a></p> </li><li> <p>结构图片</p> <p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\24ad9fe53337d2a39926888ea5a9311d.png\"/></p> </li></ul></li><li> <p>最基本的注入方式 通过DL容器的方式 一般的容器注入 初始</p>\n<ol><li> <pre><code>IServiceCollection serviceDescriptors = new ServiceCollection();\n//指定关系\nserviceDescriptors.AddScoped&lt;ITestAService, TestAService&gt;();\n//build\nServiceProvider serviceProvider = serviceDescriptors.BuildServiceProvider();\n\n//下面是作用域的关系比较\n\n//1.同一个作用域 获取的实例 时同一个\n//var testA = (ITestAService)serviceProvider.GetService&lt;ITestAService&gt;();\n//var testA1 = (ITestAService)serviceProvider.GetService&lt;ITestAService&gt;();\n//var isEq = object.ReferenceEquals(testA, testA1);\n\n//2.再次Build时 范围声明周期 已经发生了变化\n//ServiceProvider serviceProvider1 = serviceDescriptors.BuildServiceProvider();\n//var testA2 = (ITestAService)serviceProvider1.GetService&lt;ITestAService&gt;();\n\n//var isEq1 = object.ReferenceEquals(testA1, testA2);\n\n//testA.show();\n</code></pre> </li></ol></li><li> <p>AutoFac容器最简单的使用</p>\n<ol><li> <pre><code>//容器构建着\nContainerBuilder containerBuilder = new ContainerBuilder();\n//指定关系\ncontainerBuilder.RegisterType&lt;TestAService&gt;().As&lt;ITestAService&gt;();\n//构建\nIContainer container = containerBuilder.Build();\n//获取服务\nITestAService testA3 = container.Resolve&lt;ITestAService&gt;();\ntestA3.show();\n\n</code></pre> </li></ol></li><li> <p>AutoFac容器 默认支持构造函数注入</p>\n<ol><li> <pre><code>ContainerBuilder containerBuilder1 = new ContainerBuilder();\ncontainerBuilder1.RegisterType&lt;TestAService&gt;().As&lt;ITestAService&gt;();\ncontainerBuilder1.RegisterType&lt;TestBService&gt;().As&lt;ITestBService&gt;();\nIContainer container1 = containerBuilder1.Build();\nITestBService testB = container1.Resolve&lt;ITestBService&gt;();\ntestB.show();\n</code></pre> </li></ol></li><li> <p>AutoFac容器 属性注入 PropertiesAutowired()</p>\n<ol><li> <pre><code>ContainerBuilder containerBuilder2 = new ContainerBuilder();\ncontainerBuilder2.RegisterType&lt;TestAService&gt;().As&lt;ITestAService&gt;();\ncontainerBuilder2.RegisterType&lt;TestBService&gt;().As&lt;ITestBService&gt;();\n//支持属性注入的方法\ncontainerBuilder2.RegisterType&lt;TestCService&gt;().As&lt;ITestCService&gt;().PropertiesAutowired();\nIContainer container2 = containerBuilder2.Build();\n\nITestCService testC = container2.Resolve&lt;ITestCService&gt;();\ntestC.show();\n\n</code></pre> </li></ol></li><li> <p>AutoFac 支持的方法注入</p>\n<ol><li> <pre><code>ContainerBuilder containerBuilder3 = new ContainerBuilder();\ncontainerBuilder3.RegisterType&lt;TestAService&gt;().As&lt;ITestAService&gt;();\ncontainerBuilder3.RegisterType&lt;TestBService&gt;().As&lt;ITestBService&gt;();\n//支持属性注入的方法\ncontainerBuilder3.RegisterType&lt;TestCService&gt;().As&lt;ITestCService&gt;().PropertiesAutowired();\n//方法注入\n//其中的SetSevice()方法是在 TestDService里面定义的一个方法\ncontainerBuilder3.RegisterType&lt;TestDService&gt;().OnActivated(a =&gt; a.Instance.SetSevice(a.Context.Resolve&lt;ITestAService&gt;())).As&lt;ITestDService&gt;();\n//使用\nIContainer container3 = containerBuilder3.Build();\nITestDService testD = container3.Resolve&lt;ITestDService&gt;();\ntestD.show();\n</code></pre> </li></ol></li><li> <p>AutoFac 声明周期 瞬时(每次获取对象都是一个全新的实例) 示例</p> </li><li> <pre><code> ContainerBuilder containerBuilder4 = new ContainerBuilder();\n   containerBuilder4.RegisterType&lt;TestAService&gt;().As&lt;ITestAService&gt;().InstancePerRequest();\n\n   \t\t\t//InstancePerDependency 瞬时\n            //InstancePerLifetimeScope()  范围\n            // InstancePerMatchingLifetimeScope(\"name名称\") *匹配 name* 声明周期范围实例\n            //SingleInstance  单例\n            //InstancePerRequest 每一个请求,一个实例\n\n    IContainer container4 = containerBuilder4.Build();\n    ITestAService testA4 = container4.Resolve&lt;ITestAService&gt;();\n    ITestAService testA5 = container4.Resolve&lt;ITestAService&gt;();\n\t//比较\n    var IsEq = object.ReferenceEquals(testA4, testA5);\n    Console.WriteLine(IsEq);\n</code></pre> </li><li> <p>AutoFac 特殊的控制器中使用 属性注入方式</p>\n<ol><li> <p>需要使用两个特性来实现</p> </li><li> <p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\4d2370b8267ef96fd32b993ff57715b7.png\"/></p> </li><li> <p>CustomPropertyAttribute 特性用来 当作标识,且声明只能是属性才能使用该特性</p> </li><li> <p>CustomPropertySelector 特性是需要给控制器告知哪些属性是可以注入的 (需要一个判断的维度)</p> </li><li> <p>具体代码详见 GitHub 示例</p> </li></ol></li></ol>\n<ul><li> <p>整个项目 使用AutoFac 自动构建 关系</p>\n<ul><li> <p>方式一 使用 配置文件 (完全断开对 实体的依赖)</p>\n<ul><li>安装 支持的Nuget包 \n      <ul><li>Autofac.Extensions.DependencyInjection</li><li>Autofac.Configuration</li></ul></li><li>内部好像也是用来反射<code>Dll</code> 来实现,感觉配置文件也挺复杂,所以就没有使用这种方案</li></ul></li><li> <p>方式二 使用用反射来实现 ******</p>\n<ul><li> <p>1.收钱 需要在ConfigureServices 里面提供 控制器注入的支持</p>\n<ul><li> <pre><code> //AutoFac 提供控制器支持\n //1   替换控制器的替换规则\n //1.1 可以指定控制器让 容器来创建\nservices.Replace(ServiceDescriptor.Transient&lt;IControllerActivator,ServiceBasedControllerActivator&gt;());\n</code></pre> </li><li> <p>需要实现自定义实现<code>ConfigureContainer</code>方法,注意反射注入的方法需要写在这里面,不然没有效果</p>\n<ul><li> <p>代码如下</p> </li><li> <pre><code>/// &lt;summary&gt;\n        /// AutoFac 自己会调用这个方法 进行注册\n        /// 1.负责注册 各种服务\n        /// 2.ServiceCollection 注册的,也同样是可以使用的\n        /// 3.还支持控制器 里面的属性注入\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"builder\"&gt;&lt;/param&gt;\n        public void ConfigureContainer(ContainerBuilder builder)\n        {\n            Assembly serviceDLL = Assembly.Load(new AssemblyName(\"WebApplicationApi\"));\n\n            //1.Service 后缀类的反射 注入\n            var serviceTypes = serviceDLL.GetTypes().Where(t =&gt; t.Name.EndsWith(\"Service\") &amp;&amp; !t.GetTypeInfo().IsAbstract);\n            foreach (var serviceType in serviceTypes)\n            {\n                //var asdfasf = serviceType.Name;\n                foreach (var interType in serviceType.GetInterfaces())\n                {\n                    var sname = serviceType.Name;\n                    var Iname = interType.Name;\n                    Console.WriteLine($\"{sname}---&gt;{Iname}\");\n                    builder.RegisterType(serviceType).As(interType).InstancePerDependency()\n                        .AsImplementedInterfaces()//自动以其实现的所有接口类型暴露（包括IDisposable接口）\n                        .InstancePerLifetimeScope()\n                        .PropertiesAutowired();//支持属性注入的方法;\n                }\n            }\n\n            //2   首先需要在Service,里面提供支持 services.Replace(.......)\n            //2.1 控制器实例的注入 \n            var controllerTypes = typeof(Startup).GetTypeInfo().Assembly.DefinedTypes.\n                Where(x =&gt; x.IsClass &amp;&amp; typeof(ControllerBase).GetTypeInfo().IsAssignableFrom(x)).\n                Select(x =&gt; x.AsType()).\n                ToArray();\n            builder.RegisterTypes(controllerTypes)\n                //支持属性注入的方法;\n                //CustomPropertySelector 设置哪些是可以被注入的 (指定特性属性注入的支持)\n                .PropertiesAutowired(new CustomPropertySelector());\n\n        }\n</code></pre> </li></ul></li></ul></li><li> <p>这样就能直接在控制里面使用了</p>\n<ul><li>具体使用如下 \n        <ul><li> <p class=\"img-center\"><img alt=\"\" src=\"..\\..\\static\\image\\9a61454584f36d56fc832578fdc99ae6.png\"/></p> </li></ul></li></ul></li></ul></li></ul></li></ul>\n<p>以上就是AutoFac的一些基本使用方法,欢迎大家讨论,转载请标明原创地址~ 谢谢~~~Bye~</p>\n</div>\n</div>", "first_tag": "C#", "cpp": 0, "csharp": 1, "python": 0, "javascript": 0, "java": 0, "sql": 0, "php": 0, "time": "2022-04-25 11:57:24", "summary": "具体使用知识总结具体使用知识总结阅读前提示只是众多框架的其中一种比较主流的有、、、、、的，等一些还有一些可能自己实现这一套东西。为什么使用自己的理解综合所链接的因素传说是速度最快的一个轻量级性能高语言"}