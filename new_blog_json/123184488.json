{"blogid": "123184488", "writerAge": "码龄2年", "writerBlogNum": "95", "writerCollect": "358", "writerComment": "66", "writerFan": "556", "writerGrade": "4级", "writerIntegral": "1277", "writerName": "筑梦小子", "writerProfileAdress": "..\\..\\static\\writer_image\\profile_123184488.jpg", "writerRankTotal": "14489", "writerRankWeekly": "160309", "writerThumb": "219", "writerVisitNum": "72560", "blog_read_count": "2144", "blog_time": "已于 2022-03-31 13:14:55 修改", "blog_title": "单例模式中的饿汉和懒汉模式", "content": "<div class=\"article_content clearfix\" id=\"article_content\">\n<link href=\"../../static/bootstrap/css/csdnstyle.css\" rel=\"stylesheet\"/>\n<div class=\"htmledit_views\" id=\"content_views\">\n<p id=\"main-toc\"><strong>目录</strong></p>\n<p id=\"-toc\" style=\"margin-left:0px;\"></p>\n<p id=\"%E4%B8%80.%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%80.%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F\">一.什么是单例模式</a></p>\n<p id=\"%E4%B8%80.%E9%A5%BF%E6%B1%89%E6%A8%A1%E5%BC%8F-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%B8%80.%E9%A5%BF%E6%B1%89%E6%A8%A1%E5%BC%8F\">一.饿汉模式</a></p>\n<p id=\"1.%E9%A5%BF%E6%B1%89%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%A6%82%E5%BF%B5-toc\" style=\"margin-left:40px;\"><a href=\"#1.%E9%A5%BF%E6%B1%89%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%A6%82%E5%BF%B5\">1.饿汉模式的概念</a></p>\n<p id=\"2.%E9%A5%BF%E6%B1%89%E6%A8%A1%E5%BC%8F%E4%BB%A3%E7%A0%81-toc\" style=\"margin-left:40px;\"><a href=\"#2.%E9%A5%BF%E6%B1%89%E6%A8%A1%E5%BC%8F%E4%BB%A3%E7%A0%81\">2.饿汉模式代码</a></p>\n<p id=\"2.%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%A6%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8-toc\" style=\"margin-left:40px;\"><a href=\"#2.%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%A6%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8\">2.多线程是否线程安全</a></p>\n<p id=\"%E4%BA%8C.%E6%87%92%E6%B1%89%E6%A8%A1%E5%BC%8F-toc\" style=\"margin-left:0px;\"><a href=\"#%E4%BA%8C.%E6%87%92%E6%B1%89%E6%A8%A1%E5%BC%8F\">二.懒汉模式</a></p>\n<p id=\"1.%E6%87%92%E6%B1%89%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%A6%82%E5%BF%B5-toc\" style=\"margin-left:40px;\"><a href=\"#1.%E6%87%92%E6%B1%89%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%A6%82%E5%BF%B5\">1.懒汉模式的概念</a></p>\n<p id=\"2.%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84%E6%87%92%E6%B1%89%E6%A8%A1%E5%BC%8F-toc\" style=\"margin-left:40px;\"><a href=\"#2.%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84%E6%87%92%E6%B1%89%E6%A8%A1%E5%BC%8F\">2.单线程情况下的懒汉模式</a></p>\n<p id=\"2.%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84%E6%87%92%E6%B1%89%E6%A8%A1%E5%BC%8F-toc\" style=\"margin-left:40px;\"><a href=\"#2.%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84%E6%87%92%E6%B1%89%E6%A8%A1%E5%BC%8F\">2.多线程情况下的懒汉模式</a></p>\n<p id=\"%EF%BC%881%EF%BC%89%E5%AF%BC%E8%87%B4%E6%87%92%E6%B1%89%E6%A8%A1%E5%BC%8F%E5%9C%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84%E4%B8%8D%E5%AE%89%E5%85%A8%E5%8E%9F%E5%9B%A0-toc\" style=\"margin-left:80px;\"><a href=\"#%EF%BC%881%EF%BC%89%E5%AF%BC%E8%87%B4%E6%87%92%E6%B1%89%E6%A8%A1%E5%BC%8F%E5%9C%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84%E4%B8%8D%E5%AE%89%E5%85%A8%E5%8E%9F%E5%9B%A0\">（1）导致懒汉模式在多线程情况下的不安全原因</a></p>\n<p id=\"%EF%BC%882%EF%BC%89%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-toc\" style=\"margin-left:80px;\"><a href=\"#%EF%BC%882%EF%BC%89%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B\">（2）解决方法代码示例</a></p>\n<p id=\"%E7%89%88%E6%9C%AC1-toc\" style=\"margin-left:80px;\"><a href=\"#%E7%89%88%E6%9C%AC1\">版本1</a></p>\n<p id=\"%E7%89%88%E6%9C%AC2-toc\" style=\"margin-left:80px;\"><a href=\"#%E7%89%88%E6%9C%AC2\">版本2</a></p>\n<p id=\"%E7%89%88%E6%9C%AC2%E7%9A%84%E8%A7%A3%E9%87%8A%E8%AF%B4%E6%98%8E-toc\" style=\"margin-left:80px;\"><a href=\"#%E7%89%88%E6%9C%AC2%E7%9A%84%E8%A7%A3%E9%87%8A%E8%AF%B4%E6%98%8E\">版本2的解释说明</a></p>\n<hr id=\"hr-toc\"/>\n<p></p>\n<h1 id=\"%E4%B8%80.%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F\">一.什么是单例模式</h1>\n<p>保证某个类在程序中只存在一份实例，而不会创建多个实例，这样就会提高效率。</p>\n<p>在单利模式中一般只提供一个getInstance()方法来获取实例对象，不提供setInstance()方法,目的是为了避免再实例化出其他实例对象。</p>\n<p>其中单例模式中有两种模式一种是饿汉模式，一种是懒汉模式。</p>\n<p></p>\n<h1 id=\"%E4%B8%80.%E9%A5%BF%E6%B1%89%E6%A8%A1%E5%BC%8F\">一.饿汉模式</h1>\n<h2 id=\"1.%E9%A5%BF%E6%B1%89%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%A6%82%E5%BF%B5\">1.饿汉模式的概念</h2>\n<p>饿汉模式就是在类加载的时候立刻会实例化，后续使用就只会出现一份实例。</p>\n<p></p>\n<h2 id=\"2.%E9%A5%BF%E6%B1%89%E6%A8%A1%E5%BC%8F%E4%BB%A3%E7%A0%81\">2.饿汉模式代码</h2>\n<pre><code class=\"language-java\">package thread.example;\n//饿汉模式\npublic class HungrySingle {\n//在类加载的时候就实例化了，类加载只有一次，所以值实例化出了一份该实例对象\n    private static HungrySingle instance = new HungrySingle();\n    public static HungrySingle getInstance() {\n        return instance;\n    }\n}</code></pre>\n<p></p>\n<h2 id=\"2.%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%A6%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8\">2.多线程是否线程安全</h2>\n<p>在类加载的时候就已经实例化了，所以该实例化没有涉及到实例化的修改操作，只是进行读取操作。在多线程情况下是线程安全的。 </p>\n<p></p>\n<p></p>\n<h1 id=\"%E4%BA%8C.%E6%87%92%E6%B1%89%E6%A8%A1%E5%BC%8F\">二.懒汉模式</h1>\n<h2 id=\"1.%E6%87%92%E6%B1%89%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%A6%82%E5%BF%B5\">1.懒汉模式的概念</h2>\n<p>在类加载的时候没有直接实例化，而是调用指定实例方法的时候再进行实例化，这样就能保证不想使用的时候也不会实例化。一般来说比饿汉模式的效率高。</p>\n<p></p>\n<h2 id=\"2.%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84%E6%87%92%E6%B1%89%E6%A8%A1%E5%BC%8F\">2.单线程情况下的懒汉模式</h2>\n<pre><code class=\"language-java\">package thread.example;\n//单线程的懒汉模式\npublic class LazySingle {\n    private static LazySingle instance = null;\n    //只有在调用该方法的时候才实例化\n    public static LazySingle getInstance() {\n        if(instance == null) {\n            instance = new LazySingle();\n        }\n        return instance;\n    }\n}</code></pre>\n<p></p>\n<h2 id=\"2.%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84%E6%87%92%E6%B1%89%E6%A8%A1%E5%BC%8F\">2.多线程情况下的懒汉模式</h2>\n<h3 id=\"%EF%BC%881%EF%BC%89%E5%AF%BC%E8%87%B4%E6%87%92%E6%B1%89%E6%A8%A1%E5%BC%8F%E5%9C%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84%E4%B8%8D%E5%AE%89%E5%85%A8%E5%8E%9F%E5%9B%A0\">（1）导致懒汉模式在多线程情况下的不安全原因</h3>\n<p>在多线程的情况下，由于可能两个线程都会得到一份instance=null，这是因为如果线程1修改了自己县城中的instance后还没来得及修改主内存中的instance，所导致线程2也实例化出了一份instance对象，这时候也就不再是单例模式了。主要导致该问题的是由于这里面涉及到了对instance的修改操作，失去了原子性，为了保证原子性，我们想到了加锁，从而实现线程安全问题。</p>\n<h3 id=\"%EF%BC%882%EF%BC%89%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B\">（2）解决方法代码示例</h3>\n<h3 id=\"%E7%89%88%E6%9C%AC1\">版本1</h3>\n<pre><code class=\"language-java\">package thread.example;\n//多线程安全下的懒汉模式\n    public class LazySingle {\n        private LazySingle() {\n    }\n    private static LazySingle instance = null;\n    //只有在调用该方法的时候才实例化\n    public static synchronized LazySingle getInstance() {\n        if (instance == null) {\n            instance = new LazySingle();\n        }\n        return instance;\n    }\n}</code></pre>\n<p>版本1的代码虽然保证了线程安全，但是每次调用该方法时还是会出现加锁解锁问题，为了进一步优化，我们可以减小锁的粒度来提高效率，因为加了锁之后也就和高并发无缘了，但我们还是想提高效率，所以才会进行优化。</p>\n<h3 id=\"%E7%89%88%E6%9C%AC2\">版本2</h3>\n<p>双重if判断加锁提高效率</p>\n<pre><code class=\"language-java\">package thread.example;\n\npublic class SecurityLazyModle {\n    private LazySingle() {\n    }\n    private static volatile SecurityLazyModle instance = null;//保证内存可见性，防止编译器过度优化(指令重排序)\n    public static SecurityLazyModle getInstance() {\n        if(instance == null) {\n            synchronized (SecurityLazyModle.class) {\n                if(instance == null) {\n                    instance = new SecurityLazyModle();\n                }\n            }\n        }\n        return instance;\n    }\n}\n</code></pre>\n<h3 id=\"%E7%89%88%E6%9C%AC2%E7%9A%84%E8%A7%A3%E9%87%8A%E8%AF%B4%E6%98%8E\">版本2的解释说明</h3>\n<p>第一层if是为了判断当前是否已经把实例创建出来，第二层synchronized是为了使进入当前if中的线程来竞争锁，当拿到锁的线程进入到第三层if之后判断是否为空，不为空就是实例化对象，然后再释放锁，释放锁之后，instance已经不为空了，后面的线程就被阻挡在了第三层if这里了，之后再来访问getInstance()方法，发现该instance已经不为空了，也就不用再抢占锁资源了，因为竞争锁也消耗大量的时间。通过这样处理，既保证了线程安全，也提高了效率。</p>\n<p>这里使用volatile是为了防止编译器优化导致的指令重排序，在进行new一个对象不是原子性操作，可以分为三步骤：</p>\n<p>1.分配内存空间</p>\n<p>2.实例化对象</p>\n<p>3.给变量赋值</p>\n<p>对于上面的执行，如果1和3先执行了（假设2还没有完成），在第一层if外的线程这时候判断不为null,这时候就会直接返回该对象，但是这个对象只执行了一半，之后使用就会导致线程安全问题。</p>\n<p>通过volatile就可以确保这3步骤必须执行完（无论顺序如何，最终都会执行完），外面的线程才可以执行，这时候就保证了该对象的完整性。</p>\n</div>\n</div>", "first_tag": "Java", "cpp": 0, "csharp": 0, "python": 0, "javascript": 0, "java": 1, "sql": 0, "php": 0, "time": "2022-03-31 13:14:55", "summary": "目录一什么是单例模式一饿汉模式饿汉模式的概念饿汉模式代码多线程是否线程安全二懒汉模式懒汉模式的概念单线程情况下的懒汉模式多线程情况下的懒汉模式导致懒汉模式在多线程情况下的不安全原因解决方法代码示例版本"}